# [IOI 2022] 数字电路

## 题目背景

**滥用评测资源者封号。**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

由于本题数据点过多，结合洛谷评测技术实现情况，本题将不按照题给 Subtask 评分。

## 题目描述

有一个数字电路，由编号为从 $0$ 到 $N + M - 1$ 的 $N + M$ 个**门**组成。其中，$0$ 到 $N - 1$ 号门是**阈值门**，而 $N$ 到 $N + M - 1$ 号门是**输入门**。

除 $0$ 号门之外的每个门都是恰好一个某阈值门的**输入**。具体来说，对于每个满足 $1 \le i \le N + M - 1$ 的 $i$，门 $i$ 是门 $P[i]$ 的一个输入，其中 $0 \le P[i] \le N-1$。重要的是，我们保证 $P[i] \lt i$ 成立。此外，我们假设有 $P[0] = -1$。每个阈值门有一个或多个的输入。输入门没有任何输入。

每个门都有一个**状态**，取 $0$ 或 $1$。输入门的初始状态由一个包含 $M$ 个整数的数组 $A$ 给定。也就是说，对于每个满足 $0 \le j \le M - 1$ 的 $j$ ，输入门 $N + j$ 的初始状态为 $A[j]$。

每个阈值门的状态取决于它的输入的状态，具体如下。首先，每个阈值门会被指定一个阈值**参数**。对于一个有 $c$ 个输入的阈值门，其所指定的参数必须是 $1$ 到 $c$ 之间的某个整数（包括 $1$ 和 $c$）。随后，对于一个参数为 $p$ 的阈值门，如果它的输入中至少有 $p$ 个门的状态为 $1$，则当前阈值门的状态为 $1$，否则状态为 $0$。

例如，假设有 $N = 3$ 个阈值门和 $M = 4$ 个输入门。其中，门 $0$ 的输入为门 $1$ 和门 $6$，门 $1$ 的输入为门 $2$、$4$ 和 $5$，门 $2$ 仅有的输入为门 $3$。

上述例子的说明可见下图。

![](https://arina.loli.net/2022/08/12/JtjqOi4HVBXeD3x.png)

假设输入门 $3$ 和 $5$ 的状态为 $1$，而门 $4$ 和 $6$ 的状态为 $0$。假设阈值门 $2$、$1$、$0$ 被指定的参数分别为 $1$、$2$、$2$。在这种情况下，门 $2$ 的状态为 $1$，门 $1$ 的状态为 $1$ ，门 $0$ 的状态为 $0$。下面给出了参数赋值以及状态的示意图。状态为 $1$ 的门被标记为黑色。

![](https://arina.loli.net/2022/08/12/Sdiye2vg3B1aYPu.png)

输入门的状态将会经历 $Q$ 次更新。每次更新用两个整数 $L$ 和 $R$ 来描述 ($N \le L \le R \le N + M - 1$) ，表示翻转所有编号在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）的输入门的状态。这就是说，对于所有满足 $L \le i \le R$ 的 $i$，输入门 $i$ 的状态如果为 $0$，则会被翻转为$1$；如果状态为 $1$，则会被翻转为 $0$。每个门被翻转后将会一直保持在新状态，直到在后续某次更新中被翻转。

你的目标是，计算每次更新后有多少种阈值门参数的赋值方案，使得门 $0$ 的状态为 $1$。当有至少一个阈值门的参数不同时，两种参数赋值方案被认为是不同的。由于方案数可能较大，你需要计算它对 $1\;000\;002\;022$ 取模的结果。

注意，在上面的例子中，共有 $6$ 种不同的对阈值门参数进行赋值的方案，因为门 $0$、$1$、$2$ 分别有 $2$、$3$、$1$ 个输入。在这 $6$ 种方案里面，有 $2$ 种参数赋值方案使得门 $0$ 的状态为 $1$。

## 说明/提示

### 约束条件

- $1 \le N, M \le 10^5$；
- $1 \le Q \le 10^5$；
- $P[0] = -1$；
- $0 \le P[i] \lt i$ 且 $P[i] \le N - 1$（对于所有满足 $1 \le i \le N + M - 1$ 的 $i$）；
- 每个阈值门至少有一个输入（对于所有满足 $0 \le i \le N - 1$ 的 $i$，存在某个下标 $x$ 满足 $i \lt x \le N + M - 1$ 且 $P[x] = i$）；
- $0 \le A[j] \le 1$（对于所有满足 $0 \le j \le M - 1$的 $j$）；
- $N \le L \le R \le N + M - 1$。

### 子任务

1. （2 分）$N = 1$，$M \le 1000$，$Q \le 5$；
2. （7 分）$N, M \le 1000$，$Q \le 5$，每个阈值门都有恰好两个输入；
3. （9 分）$N, M \le 1000$，$Q \le 5$；
4. （4 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$）， $P[i] = \lfloor\frac{i - 1}{2}\rfloor$（对于所有满足 $1 \le i \le N + M - 1$ 的 $i$），$L = R$；
5. （12 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$），$P[i] = \lfloor\frac{i - 1}{2}\rfloor$（对于所有满足$1 \le i \le N + M - 1$的 $i$）；
6. （27 分）每个阈值门都恰好有两个输入；
7. （28 分）$N, M \le 5000$；
8. （11 分）没有额外的约束条件。

### 评测程序示例

评测程序示例读取如下格式的输入：

- 第 $1$ 行： $N \; M \; Q$；
- 第 $2$ 行： $P[0] \; P[1] \; \ldots \; P[N + M - 1]$；
- 第 $3$ 行： $A[0] \; A[1] \; \ldots \; A[M - 1]$；
- 第 $4 + k$ 行（$0 \le k \le Q - 1$）： 第 $k$ 次更新对应的 $L \; R$。

评测程序示例按照如下格式打印你的答案：

- 第 $1 + k$ 行（$0 \le k \le Q - 1$）： `count_ways` 函数对第 $k$ 次更新的返回值。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `bool` | `int` | `int[]`            |
| ------- | ------ | ------| ------------------ |
| `void ` | `bool` | `int` | `std::vector<int>` |

| `union(bool, int[])`                   | 数组 `a` 的长度 |
| -------------------------------------- | ------------------- |
| `std::variant<bool, std::vector<int>>` | `a.size()`          |

C++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。
一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。
以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：

```cpp
std::variant<bool, std::vector<int>> foo(int N) {
    return N % 2 == 0;
}

std::variant<bool, std::vector<int>> goo(int N) {
    return std::vector<int>(N, 0);
}

std::variant<bool, std::vector<int>> hoo(int N) {
    if (N % 2 == 0) {
        return false;
    }

    return std::vector<int>(N, 0);
}
```

# 题解

## 作者：GIFBMP (赞：8)

我们发现算方案数很麻烦，于是考虑计算节点 $0$ 的值为 $1$ 的概率。设 $f_{i,j}$ 表示以 $i$ 为根的子树，$i$ 的位置参数为 $j$ 时，$i$ 的值为 $1$ 的概率。

但这样显然是过不去的，考虑记 $c_i$ 表示 $i$ 的儿子数，$g_x=\dfrac{1}{c_x}\sum\limits_{i=1}^{c_x}f_{x,i}$，我们发现我们只关心 $g_x$ 的值，考虑化简。

为了方便，记 $x$ 的儿子依次为 $a_1,a_2,a_3,\dots,a_{c_x}$，记 $p_1=\sum\limits_{i=1}^{c_x} g_{a_i}$，$p_2=\sum\limits_{i<j}g_{a_i}\times g_{a_j}$，以下以此类推。那么根据容斥原理，有：

$$f_{x,1}=p_1-p_2+p_3-p_4+p_5\dots$$

$$f_{x,2}=p_2-2p_3+3p_4-4p_5\dots$$

$$f_{x,3}=p_3-3p_4\dots+6p_5$$

$$f_{x,4}=p_4-4p_5\dots$$

通过观察我们发现后面几项在加起来的时候都能被消掉，于是有 $g_x=\dfrac{1}{c_x}p_1=\sum\limits_{i=1}^{c_x}g_{a_i}$。

那么一个叶子节点对概率的贡献就是自身的初始值除以**所有在这个叶子节点到根的路径上的节点的儿子数的积**。由于答案还要乘上 $\prod\limits_{i=0}^{n+m-1}c_i$，所以一个节点的贡献就是所有不在这个叶子节点到根的路径上的节点的儿子数的积乘上自身初始权值。这个可以在 dfs 时顺便求出。

至于区间翻转，在线段树上维护两个值 $s_0$，$s_1$ 表示区间内权值为 $0$ 的贡献和以及权值为 $1$ 的贡献和即可。

时间复杂度：$\Theta(n+m+q\log m)$

Code:

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include "circuit.h"
using namespace std ;
const int MAXN = 2e5 + 10 , mod = 1000002022 ;
typedef long long ll ;
typedef vector<int> vi ;
int n , m , a[MAXN] , fir[MAXN] , tot , id[MAXN] , f[MAXN] ;
ll mul[MAXN] , w[MAXN] , pre[MAXN] , suf[MAXN] ;
struct edge {int to , nxt ;} e[MAXN] ;
void add (int u , int v) {
	e[++tot].to = v ; e[tot].nxt = fir[u] ; fir[u] = tot ;
}
void dfs1 (int x) {
	int cnt = 0 ; 
	for (int i = fir[x] ; i ; i = e[i].nxt) cnt++ ;
	if (!fir[x]) mul[x] = 1 ;
	else mul[x] = cnt ;
	for (int i = fir[x] ; i ; i = e[i].nxt)
		dfs1 (e[i].to) , mul[x] = mul[x] * mul[e[i].to] % mod ;
}
void dfs2 (int x) {
	if (!fir[x]) return ;
	int cnt = 0 ; 
	for (int i = fir[x] ; i ; i = e[i].nxt)
		id[e[i].to] = ++cnt , pre[cnt] = suf[cnt] = mul[e[i].to] ;
	pre[0] = suf[cnt + 1] = 1 ;
	for (int i = 2 ; i <= cnt ; i++) pre[i] = pre[i - 1] * pre[i] % mod ;
	for (int i = cnt - 1 ; i ; i--) suf[i] = suf[i + 1] * suf[i] % mod ;
	for (int i = fir[x] ; i ; i = e[i].nxt) {
		int v = e[i].to ;
		w[v] = w[x] * pre[id[v] - 1] % mod * suf[id[v] + 1] % mod ;
	}
	for (int i = fir[x] ; i ; i = e[i].nxt) dfs2 (e[i].to) ;
}
#define lc (o << 1)
#define rc (o << 1 | 1)
#define mid ((l + r) >> 1)
ll s0[MAXN << 2] , s1[MAXN << 2] ;
int lz[MAXN << 2] ;
void build (int o , int l , int r) {
	if (l == r) {f[l] ? (s1[o] = w[l + n - 1]) : (s0[o] = w[l + n - 1]) ; return ;}
	build (lc , l , mid) , build (rc , mid + 1 , r) ;
	s0[o] = (s0[lc] + s0[rc]) % mod , s1[o] = (s1[lc] + s1[rc]) % mod ;
}
void pushdown (int o) {
	if (!o || !lz[o]) return ;
	swap (s0[lc] , s1[lc]) , swap (s0[rc] , s1[rc]) , lz[lc] ^= 1 , lz[rc] ^= 1 , lz[o] = 0 ;
}
void upd (int o , int l , int r , int x , int y) {
	if (x <= l && r <= y) {lz[o] ^= 1 , swap (s0[o] , s1[o]) ; return ;}
	pushdown (o) ;
	if (x <= mid) upd (lc , l , mid , x , y) ;
	if (mid < y) upd (rc , mid + 1 , r , x , y) ;
	s0[o] = (s0[lc] + s0[rc]) % mod , s1[o] = (s1[lc] + s1[rc]) % mod ;
}
void init (int N , int M , vi p , vi a) {
	n = N , m = M ;
	for (int i = 1 ; i < n + m ; i++) add (p[i] , i) ;
	for (int i = 0 ; i < m ; i++) f[i + 1] = a[i] ;
	dfs1 (0) , w[0] = 1 , dfs2 (0) ;
	build (1 , 1 , m) ;
}
int count_ways (int x , int y) {
	upd (1 , 1 , m , x - n + 1 , y - n + 1) ;
	return s1[1] ;
}
```

---

## 作者：FZzzz (赞：6)

给个生草推法。

令 $f_u$ 为只考虑 $u$ 子树，使得 $u$ 为 $1$ 的合法方案数；$s_u$ 为 $u$ 子树的总方案数。$s$ 容易计算，考虑如何从 $u$ 儿子的 $f$ 得到 $f_u$。发现相当于对每种选 $i$ 个为 $1$ 的儿子的方案，把它们的 $f$ 和其他儿子的 $s-f$ 乘起来，然后再乘上 $i$，这是这种方案的贡献。

——这可以用生成函数描述。记 $F_u(x)=f_ux+s_u-f_u$，$C_u$ 为 $u$ 的儿子集合，$P_u(x)=\prod\limits_{v\in C_u}F_v(x)$，则 $f_u=P_u'(1)$。要求出 $P_u'(1)$，我们只关心每个 $v$ 的 $F_v(1)$ 和 $F_v'(1)$，即 $s_v$ 和 $f_v$。

那么根据乘法求导法则，我们可以得到：
$$f_u=\sum_{v\in C_u}f_v\prod_{w\in C_u,w\ne v}s_w$$
这个形式就很漂亮了。接下来就顺理成章，发现每个叶子对 $f_0$ 的贡献都是线性，系数可以 dfs 求出来，线段树维护即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int maxn=1e5+5;
int n,m;
vector<int> g[maxn];
bool a[maxn];
const ll mod=1e9+2022;
ll s[maxn*2];
void dfs1(int u){
	if(u>=n){
		s[u]=1;
		return;
	}
	s[u]=g[u].size();
	for(int v:g[u]){
		dfs1(v);
		s[u]=s[u]*s[v]%mod;
	}
}
ll b[maxn*2];
void dfs2(int u){
	if(u>=n) return;
	vector<ll> s1(g[u].size()+1),s2(g[u].size()+1);
	s1[0]=1;
	for(int i=0;i<(int)g[u].size();i++) s1[i+1]=s1[i]*s[g[u][i]]%mod;
	s2[g[u].size()]=1;
	for(int i=(int)g[u].size()-1;i>=0;i--) s2[i]=s2[i+1]*s[g[u][i]]%mod;
	for(int i=0;i<(int)g[u].size();i++){
		int v=g[u][i];
		b[v]=b[u]*s1[i]%mod*s2[i+1]%mod;
		dfs2(v);
	}
}
struct node{
	int l,r;
	node* ch[2];
	ll s1,s2;
	bool flip=0;
	void pushup(){
		s1=(ch[0]->s1+ch[1]->s1)%mod;
		s2=(ch[0]->s2+ch[1]->s2)%mod;
	}
	node(int l,int r):l(l),r(r){
		if(l==r){
			s1=a[r]?b[n+r]:0;
			s2=a[r]?0:b[n+r];
			return;
		}
		int mid=l+(r-l)/2;
		ch[0]=new node(l,mid);
		ch[1]=new node(mid+1,r);
		pushup();
	}
	void pushtag(){
		swap(s1,s2);
		flip^=1;
	}
	void pushdown(){
		if(flip){
			ch[0]->pushtag();
			ch[1]->pushtag();
			flip=0;
		}
	}
	void modify(int ql,int qr){
		if(ql>r||qr<l) return;
		if(ql<=l&&qr>=r){
			pushtag();
			return;
		}
		pushdown();
		ch[0]->modify(ql,qr);
		ch[1]->modify(ql,qr);
		pushup();
	}
}*rt;
void init(int _n,int _m,vector<int> fa,vector<int> _a){
	n=_n;
	m=_m;
	for(int i=0;i<m;i++) a[i]=_a[i];
	for(int i=1;i<n+m;i++) g[fa[i]].push_back(i);
	dfs1(0);
	b[0]=1;
	dfs2(0);
	rt=new node(0,m-1);
}
int count_ways(int l,int r){
	rt->modify(l-n,r-n);
	return rt->s1;
}
```

---

## 作者：Purslane (赞：2)

# Solution

~~小萌新竟然能爆切 IOI 签到题，太感动了。TAT~~

设 $col_u$ 表示 $u$ 的颜色。

假设我们确定了 $col_u$，再去选 $c_u$。发现

$$
c_u = \sum_{v \in son_u} [col_v=1]
$$

由于 $col_0 = 1$，所以对于 $c_0$ 而言，其组合意义就是选一个儿子让他 $col=1$，对总方案计数。如此过程重复下去，会选出一条 $0 \to leaf$ 的链。

不在链上的节点，他 $c$ 选多少是无所谓的，有 $\deg$ 种可能（$\deg$ 指的是儿子的个数）。

所以用树形 DP 求出，删掉每个叶子到根的链之后，其他点 $\deg$ 的乘积（特别的，我们不考虑叶子）。

这样相当于维护 $01$ 序列 $a$，以及静态序列 $b$，支持动态翻转 $a$ 的一个区间，求 $\sum a_i b_i$ 的和。使用线段树维护即可。

这是萌新的第 $694$ 篇题解，喜欢就点个赞吧。 /kel

代码：

```cpp
#include<bits/stdc++.h>
#include "circuit.h"
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MOD=1e9+2022;
int n,m,deg[MAXN],op[MAXN];
ll pre[MAXN],mul[MAXN];
vector<int> G[MAXN];
void dfs(int u) {
	if(G[u].size()) pre[u]=G[u].size();
	else pre[u]=1;
	for(auto v:G[u]) dfs(v),pre[u]=pre[u]*pre[v]%MOD;
	return ;	
}
void Dfs(int u) {
	ll tmp=1;
	for(auto v:G[u]) mul[v]=tmp,tmp=tmp*pre[v]%MOD;
	tmp=mul[u],reverse(G[u].begin(),G[u].end());
	for(auto v:G[u]) mul[v]=mul[v]*tmp%MOD,tmp=tmp*pre[v]%MOD;
	for(auto v:G[u]) Dfs(v);
	return ;
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
int tag[MAXN<<2],sum[MAXN<<2][2];
void build(int k,int l,int r) {
	if(l==r) return sum[k][op[l]]=mul[l+n-1],void();
	build(lson,l,mid),build(rson,mid+1,r);
	return sum[k][0]=(sum[lson][0]+sum[rson][0])%MOD,sum[k][1]=(sum[lson][1]+sum[rson][1])%MOD,void();
}
void assign(int k) {return tag[k]^=1,swap(sum[k][0],sum[k][1]),void();}
void push_down(int k) {
	if(tag[k]) assign(lson),assign(rson);
	return tag[k]=0,void();	
}
void update(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return assign(k),void();
	push_down(k);
	if(x<=mid) update(lson,l,mid,x,y);
	if(y>mid) update(rson,mid+1,r,x,y);
	return sum[k][0]=(sum[lson][0]+sum[rson][0])%MOD,sum[k][1]=(sum[lson][1]+sum[rson][1])%MOD,void();	
}
void init(int N,int M,vector<int> P,vector<int> A) {
	n=N,m=M;
	ffor(i,1,n+m-1) G[P[i]].push_back(i);
	mul[0]=1,dfs(0),Dfs(0);
	ffor(i,1,m) op[i]=A[i-1];
	build(1,1,m);
	return ;
}
int count_ways(int L,int R) {
	L-=n-1,R-=n-1;
	update(1,1,m,L,R);
	return sum[1][1];
}
```

---

## 作者：biyi_mouse (赞：2)

#### [P8493 [IOI 2022] 数字电路](https://www.luogu.com.cn/problem/P8493)

一个很喵喵的套路。我们考虑为 $1$ 的方案数等于为 $1$ 的概率乘上总方案数。

于是做 DP，令 $f_u$ 表示 $u$ 为 $1$ 的概率，那么考虑当 $u$ 的儿子中有 $i$ 个 $1$ 时，阈值就只能设为 $[1, i]$。所以 $f_u = \sum_{i = 1}^{|\operatorname{son}(u)|}\frac{i}{|\operatorname{son}(u)|}g_{u, i}$，其中 $g_{u, i}$ 表示 $u$ 的儿子中有 $i$ 个 $1$ 的概率。

直接算 $g_{u, i}$ 显得不是那么可行，但你会发现 $\sum_{i = 1}^{|\operatorname{son}(u)|}i \times g_{u, i}$ 其实就是 $u$ 儿子中 $1$ 数量的期望 $E(u)$。

而 $E(u) = \sum_{v \in \operatorname{son}(u)}f_v$，所以就的得到了 $f_v$ 到 $f_u$ 的递推式：$f_u = \frac{1}{|\operatorname{son}(u)|}\sum_{v \in \operatorname{son}(u)} f_v$。

进一步分析，贡献的出发点一定是非阈值点，在题目给出的结构中即为叶子。所以对于 $f_0$ 来说，总的概率就是 $\sum_u\prod_{v \in \operatorname{path}(u, 0)}\frac{1}{|\operatorname{son}(v)|}$。

当然，这是概率。我们还要再乘总的方案数 $\prod_{u}|\operatorname{son}(u)|$，会发现这么乘完后答案就是 $\sum_{u}\prod_{v \notin \operatorname{path}(u, 0)}$。

于是你对于每个叶子预处理一下贡献，存到线段树上。接着维护一下区间翻转即可，每次将还为 $1$ 的叶子的贡献输出即可。

```cpp
const int N = 200010, Mod = 1000002022;
vector<int> g[N];
int n, m, s[N], f[N], d[N], a[N], p[N];
vector<int> pre, suf;

IL int add(int a, int b) { return (a + b) % Mod; }
IL int mul(int a, int b) { return  1ll * a * b % Mod; }
void add_edge(int a, int b) { g[a].push_back(b); }

void dfs1(int u) {
	if (!s[u]) { d[u] = 1; return; }
	d[u] = s[u];
	for (auto v : g[u]) {
		dfs1(v);
		d[u] = mul(d[u], d[v]); 
	}
}

void dfs2(int u, int res) {
	f[u] = res; 
    if (!s[u]) return;
    int sz = s[u];
	vector<int> pre(sz), suf(sz);
	pre[0] = d[g[u][0]], suf[sz - 1] = d[g[u][sz - 1]];
	for (int i = 1; i < sz; i ++) {
		int v = g[u][i];
		pre[i] = mul(pre[i - 1], d[v]);
	}
	for (int i = sz - 2; i >= 0; i --) {
		int v = g[u][i];
		suf[i] = mul(suf[i + 1], d[v]);
	}
	for (int i = 0; i < sz; i ++) {
		int t = res, v = g[u][i];
		if (i) t = mul(t, pre[i - 1]);
		if (i < sz - 1) t = mul(t, suf[i + 1]);
		dfs2(v, t);
	} 
}

struct Node { int l, r, s[2], rev; };
struct Segment_Tree {
	Node tr[N << 2];
	void pushup(int u) { 
		tr[u].s[0] = add(tr[u << 1].s[0], tr[u << 1 | 1].s[0]);
		tr[u].s[1] = add(tr[u << 1].s[1], tr[u << 1 | 1].s[1]);
	}
	void reverse(int u) {
		tr[u].rev ^= 1;
		swap(tr[u].s[0], tr[u].s[1]);
	} 
	void pushdown(int u) {
		if (tr[u].rev) {
			reverse(u << 1); reverse(u << 1 | 1); 
			tr[u].rev ^= 1;
		}
	}
	void build(int u, int l, int r) {
		tr[u] = {l, r, {0, 0}, 0};
		if (l == r) { tr[u].s[a[l - 1]] = f[l + n - 1]; return; }
		int mid = l + r >> 1;
		build(u << 1, l, mid); build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	void modify(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) {
			reverse(u); 
			return;
		}
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) modify(u << 1, l, r);
		if (r > mid) modify(u << 1 | 1, l, r); 
		pushup(u);
	}
	int query() { return tr[1].s[1]; }
} sgt;

void init(int N, int M, vector<int> P, vector<int> A) {
	n = N, m = M;
	for (int i = 1; i < n + m; i ++) add_edge(P[i], i);
	for (int i = 0; i < n + m; i ++) s[i] = g[i].size();
	for (int i = 0; i < m; i ++) a[i] = A[i];
	dfs1(0); dfs2(0, 1);
	sgt.build(1, 1, m);
}

int count_ways(int L, int R) {
	sgt.modify(1, L - n + 1, R - n + 1);
	return sgt.query();
}
```

---

## 作者：DaiRuiChen007 (赞：1)

# P8493 题解



## 思路分析

首先，我们把计数问题转成概率问题，假设每个点的阈值是对应范围内的一个随机整数，用 $f_u$ 表示此时 $u$ 的值为 $1$ 的概率。

考虑 $u$ 的所有儿子 $v\in\operatorname{son}(u)$，我们能求出 $\operatorname{son}(u)$ 中 $1$ 的期望数量，设 $c_u$ 表示 $\operatorname{son}(u)$ 中 $1$ 的个数，那么：$E(c_u)=\sum_{v\in\operatorname{son}(v)}f_v$。

接下来考虑如何通过 $E(c_u)$ 推出 $f_u$，我们可以把 $E(c_u)$ 按定义对于不同的 $c_u$ 给拆开，即令 $g_{u,i}$ 表示 $\operatorname{son}(u)$ 中出现恰好 $i$ 个 $1$ 的概率，设 $|\operatorname{son}(u)|=s_u$，那么我们有 $\sum_{i=1}^{s_u} i\times g_{u,i}=E(c_u)$，这是根据期望的定义推出的。

显然，为了求出 $f_u$，我们只需对于每个 $i\in[1,s_u]$ 求出：当 $\operatorname{son}(u)$ 中有恰好 $i$ 个 $1$ 时，$u$ 的值为 $1$ 的概率，显然，此时阈值应该 $\le i$，而阈值的总取值共有 $s_u$ 种，因此此时有 $\dfrac i{s_u}$ 的概率使得 $u$ 的值为 $1$，将对应的 $i$ 的贡献相加得到：$f_u=\sum_{i=1}^{s_u}\dfrac i{s_u}\times g_{u,i}$。

联立两式，我们知道 $f_u=\dfrac1{s_u}\sum_{i=1}^{s_u} i\times g_{u,i}=\dfrac{E(c_u)}{s_u}=\dfrac 1{s_u}\sum_{v\in\operatorname{son}(v)}f_v$，因此我们得到了 $f_u$ 的转移。

注意到 $f_u$ 的转移形式是线性的，因此每个叶子结点对 $f_0$ 的贡献也是线性的，准确来说：某个叶子 $v$ 对 $f_0$ 的贡献是 $\prod_{u\in\operatorname{path}(v,0)} \dfrac{1}{s_u}$（忽略 $s_u=0$ 的项，即不考虑叶子结点的贡献）。

回到原来的计数问题上，某个叶子 $v$ 对答案的贡献就是 $\prod_{u\not\in\operatorname{path}(v,0)} s_u$，直接预处理出每个叶子对答案的贡献，注意到只有值为 $1$ 的叶子对答案有贡献，因此用线段树维护区间反转，统计（有贡献的叶子的）整体和的操作即可。

注意题目给出的模数不支持求逆元，因此可能要预处理子树内的 $s_u$ 积，再用 dfs 逐个转移出每个叶子对答案的贡献。

时间复杂度 $\Theta((m+q)\log m)$。

## 代码呈现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2e5+1,MOD=1e9+2022;
class SegmentTree {
	private:
		struct node {
			int rev,sum[2];
			node() { rev=0,sum[0]=sum[1]=0; }
		}	tree[MAXN<<2];
		inline int left(int x) { return x<<1; }
		inline int right(int x) { return x<<1|1; }
		inline void pushup(int pos) {
			tree[pos].sum[0]=(tree[left(pos)].sum[0]+tree[right(pos)].sum[0])%MOD;
			tree[pos].sum[1]=(tree[left(pos)].sum[1]+tree[right(pos)].sum[1])%MOD;
		}
		inline void reverse(int pos) {
			tree[pos].rev^=1;
			swap(tree[pos].sum[0],tree[pos].sum[1]);
		}
		inline void pushdown(int pos) {
			if(tree[pos].rev) {
				reverse(left(pos));
				reverse(right(pos));
				tree[pos].rev=0;
			}
		}
	public:
		inline void Insert(int u,int s,int k,int l,int r,int pos)  {
			tree[pos]=node();
			if(l==r) {
				tree[pos].sum[s]=k;
				return ;
			}
			int mid=(l+r)>>1;
			if(u<=mid) Insert(u,s,k,l,mid,left(pos));
			if(mid<u) Insert(u,s,k,mid+1,r,right(pos));
			pushup(pos);
		}
		inline void Modify(int ul,int ur,int l,int r,int pos) {
			if(ul<=l&&r<=ur) {
				reverse(pos);
				return ;
			}
			int mid=(l+r)>>1;
			pushdown(pos);
			if(ul<=mid) Modify(ul,ur,l,mid,left(pos));
			if(mid<ur) Modify(ul,ur,mid+1,r,right(pos));
			pushup(pos);
		}
		inline int Query() { return tree[1].sum[1]; }
}	S;
vector <int> G[MAXN];
int n,m,siz[MAXN],coef[MAXN],prod[MAXN];
inline void dfs1(int u) {
	if(!siz[u]) {
		prod[u]=1;
		return ;
	}
	prod[u]=siz[u];
	for(int v:G[u]) {
		dfs1(v);
		prod[u]=(ll)prod[v]*(ll)prod[u]%MOD;
	}
}
inline void dfs2(int u,int k) {
	coef[u]=k;
	if(!siz[u]) return ;
	vector <int> pre(siz[u]),suf(siz[u]);
	pre[0]=prod[G[u][0]];
	for(int i=1;i<=siz[u]-1;++i) pre[i]=(ll)prod[G[u][i]]*(ll)pre[i-1]%MOD;
	suf[siz[u]-1]=prod[G[u][siz[u]-1]];
	for(int i=siz[u]-2;i>=0;--i) suf[i]=(ll)prod[G[u][i]]*(ll)suf[i+1]%MOD;
	for(int i=0;i<=siz[u]-1;++i) {
		int tmp=k;
		if(i>0) tmp=(ll)tmp*(ll)pre[i-1]%MOD;
		if(i<siz[u]-1) tmp=(ll)tmp*(ll)suf[i+1]%MOD;
		dfs2(G[u][i],tmp);
	}
}
void init(int N,int M,vector <int> P,vector <int> A) {
	n=N,m=M;
	for(int i=1;i<n+m;++i) G[P[i]].push_back(i);
	for(int i=0;i<n+m;++i) siz[i]=G[i].size();
	dfs1(0),dfs2(0,1);
	for(int i=0;i<m;++i) S.Insert(i+1,A[i],coef[n+i],1,m,1);
}
int count_ways(int L,int R) {
	S.Modify(L-n+1,R-n+1,1,m,1);
	return S.Query();
}
```



---

## 作者：World_Creater (赞：0)

组合意义天地灭。

假如对于一个点，其恰好有 $i$ 个儿子是黑的方案数是 $g_i$，那么点是黑的方案数是 $\sum_{i>0} g_i\times i$。

组合意义一下，发现那个乘 $i$ 的系数等价于从已经有 $i$ 个黑儿子里面再选一个儿子，把他染成灰色的方案数。

那么令 $f_u$ 为点 $u$ 为黑色的方案数，枚举 $u$ 的哪个儿子是灰色的，可以得到 $f_u=\sum_{v\in \mathrm{son}(u)}f_v\times \prod_{v'\in\mathrm{son}(v)\cap v'\not=v} s_{v'}$，其中 $s_x$ 代表 $x$ 子树内不管 $x$ 是黑还是白的方案数，这个是容易的，就是把 $x$ 子树内每个非叶点的儿子数乘起来。

再考虑每个点选一个灰儿子其实是一个类似于链剖分的过程，因此必然有一个染黑的叶子，通过从根结点开始，不断跳这个当前点选择的灰儿子，能够跳到这个叶子上。

考虑把贡献拆到每个这样的叶子上，那就是钦定这个点到根全部被染成灰色，这个系数是把到根的链扣出来后，每个点除去链上下一个点以外的所有儿子的 $s$ 乘起来。

因此每个点贡献独立且系数固定，线段树维护即可。

```cpp
// #include "circuit.h"
#include <vector>
#include<bits/stdc++.h>
using namespace std;
const int mod=1000002022;
inline int add(int x,int y)
{
	return x+y>=mod?x+y-mod:x+y;
}
vector<int> G[200005];
int s[200005],h[200005];
int n,m;
void dfs(int x)
{
	if(x>=n)
	{
		s[x]=1;
		return ;
	}
	s[x]=G[x].size();
	for(auto g:G[x])
	{
		dfs(g);
		s[x]=1ll*s[x]*s[g]%mod;
	}
}
void dfs1(int x)
{
	if(x>=n) return ;
	vector<int> pre(G[x].size()),suc(G[x].size());
	for(int i=0;i<G[x].size();i++)
	{
		pre[i]=suc[i]=s[G[x][i]];
	}
	for(int i=1;i<G[x].size();i++)
	{
		pre[i]=1ll*pre[i]*pre[i-1]%mod;
	}
	for(int i=(int)G[x].size()-2;i>=0;i--)
	{
		suc[i]=1ll*suc[i]*suc[i+1]%mod;
	}
	for(int i=0;i<G[x].size();i++)
	{
		int p=1;
		if(i!=0) p=1ll*p*pre[i-1]%mod;
		if(i+1!=G[x].size()) p=1ll*p*suc[i+1]%mod;
		int g=G[x][i];
		h[g]=1ll*h[x]*p%mod;
		dfs1(g);
	}
}
struct segtree{
	struct node{
		int s1,s2;
	}tree[400005];
	int tag[400005];
	#define lc(x) (x<<1)
	#define rc(x) (x<<1|1)
	#define M(l,r) ((l+r)>>1)
	void pushup(int p)
	{
		tree[p].s1=add(tree[lc(p)].s1,tree[rc(p)].s1);
		tree[p].s2=add(tree[lc(p)].s2,tree[rc(p)].s2);
	}
	void build(int p,int l,int r,vector<int> &a)
	{
		if(l==r)
		{
			if(a[l-n]) tree[p]={h[l],0};
			else tree[p]={0,h[l]};
			return ;
		}
		int mid=M(l,r);
		build(lc(p),l,mid,a);
		build(rc(p),mid+1,r,a);
		pushup(p);
	}
	void maketag(int p)
	{
		swap(tree[p].s1,tree[p].s2);
		tag[p]^=1;
	}
	void pushdown(int p)
	{
		if(!tag[p]) return ;
		maketag(lc(p));
		maketag(rc(p));
		tag[p]=0;
	}
	void modify(int p,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R)
		{
			maketag(p);
			return ;
		}
		pushdown(p);
		int mid=M(l,r);
		if(L<=mid) modify(lc(p),l,mid,L,R);
		if(mid<R) modify(rc(p),mid+1,r,L,R);
		pushup(p);
	}
}T;
void init(int N, int M, std::vector<int> P, std::vector<int> A) {
	n=N,m=M;
	for(int i=1;i<n+m;i++) G[P[i]].emplace_back(i);
	dfs(0);
	h[0]=1;
	dfs1(0);
	T.build(1,n,n+m-1,A);
}

int count_ways(int L, int R) {
	T.modify(1,n,n+m-1,L,R);
	return T.tree[1].s1;
}

```

---


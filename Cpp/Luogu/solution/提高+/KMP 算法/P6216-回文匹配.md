# 回文匹配

## 题目描述

对于一对字符串 $(s_1,s_2)$，若 $s_1$ 的长度为奇数的子串 $(l,r)$ 满足 $(l,r)$ 是回文的，那么 $s_1$ 的“分数”会增加 $s_2$ 在 $(l,r)$ 中出现的次数。

现在给出一对 $(s_1,s_2)$，请计算出 $s_1$ 的“分数”。

答案对 $2 ^ {32}$ 取模。

## 说明/提示

**【样例解释】**

   对于样例一：

   子串 $(1,5)$ 中 $s_2$ 出现了一次，子串 $(2,4)$ 中 $s_2$ 出现了一次。

   子串 $(7,9)$ 中 $s_2$ 出现了一次，子串 $(6,10)$ 中 $s_2$ 出现了一次。

--------------------------------------

**【数据范围】**

**本题采用捆绑测试。**

- 对于 $100\%$ 的数据：$1 \le n,m \le 3 \times 10 ^ 6$，字符串中的字符都是小写字母。

- **详细的数据范围：**

  | Subtask 编号 |     $n,m \le$     | 分值 |
  | :----------: | :---------------: | :--: |
  |     $1$      |       $100$       | $15$ |
  |     $2$      |     $10 ^ 3$      | $15$ |
  |     $3$      | $5 \times 10 ^ 3$ | $20$ |
  |     $4$      | $4 \times 10 ^ 5$ | $30$ |
  |     $5$      | $3 \times 10 ^ 6$ | $20$ |

## 样例 #1

### 输入

```
10 2
ccbccbbcbb bc```

### 输出

```
4```

## 样例 #2

### 输入

```
20 2
cbcaacabcbacbbabacca ba
```

### 输出

```
4
```

# 题解

## 作者：chenxinyang2006 (赞：26)

- **算法1**

  枚举所有区间，然后扫一遍判断是否回文，暴力匹配求出包含 $s_2$ 的次数
  
  时间复杂度：$O(n ^ 4)$
  
- **算法2**

  在算法1的基础上，把暴力匹配改成 $kmp$ 匹配；当然你也可以仿照算法3的做法，用暴力匹配
  
  时间复杂度：$O(n ^ 3)$
  
- **算法3**

   在算法2的基础上，进行优化
   
   每次枚举一个左端点 $l$ ，然后从左往右扫一遍 $r$ ，边扫边匹配，每次 $O(1)$ 在 $(l,r - 1)$ 的基础上计算出 $(l,r)$ 中 $str2$ 出现的次数
   
   然后就是判定回文，可以用[manacher](https://www.luogu.com.cn/problem/P3805)，也可以每次枚举对称点，往两边暴力找。总之就是找出每个有效的回文区间，然后加上 $s_2$ 的出现次数就行
   
   时间复杂度：$O(n ^ 2)$

- **算法4**
   
   枚举所有区间的做法肯定是不行了，得从点的角度来考虑问题
   
   可以先跑一遍 $kmp$ ，知道哪些点可以作为 $s_2$ 的左端点，将这些点标为 $1$ ，其他点标为 $0$ ，用 $a_i$ 表示这个值。然后问题就简化为：
   
   查询所有回文区间的区间和
   
   但是这样还是太过复杂，因为区间数量是 $n ^ 2$ 的，所以考虑从 $manacher$ 的角度解决问题
   
   $manacher$ 可以帮助我们求出每个对称点的最长回文串，这$n$个最长回文串实际上包含了所有最多$n ^ 2$个回文串
   
   实际上，想到这一步的话，问题已经迎刃而解了
   
   设这个最长回文串包含 $(l,r)$ ，那么其实就是求：
   
   $(a_l + ... a_r) + (a_{l + 1} + ... a_{r - 1}) + (a_{l + 2} + ... + a_{r - 2}) + ...$
   
   （最长回文串的答案） + （次长回文串的答案） + ……
   
   当然，这个式子是假的，因为你得考虑左端点在范围内，右边却超了的情况
   
   不过这不重要，总之，这个式子是可以快速计算的，它相当于给每个 $a_i$ 标了一个权值，然后求一个和
   
   那么这个实际上是两段等差数列加起来
   
   这个有一个通用套路就是前缀和
   
   设现在求和的段是$[l,r]$，如果公差为1，就是要求：
   
   $\quad \sum\limits_{i = l} ^ r a_i \times (i - l + 1)$
   
   $=\sum\limits_{i=l} ^ r (a_i \times i) - (\sum\limits_{i = l} ^ r a_i) \times l + \sum\limits_{i = l} ^ r a_i$
   
   显然，维护 $a_i \times i$ 的前缀和、 $a_i$ 的前缀和就可以算了
   
   另一端也是一样的，就不推了
   
   时间复杂度：$O(n)$
   
   Subtask 4是随便放的，想看看有没有 $O(n\ log\ n)$的奇怪解法
   
[code](https://www.luogu.com.cn/paste/70khg746)

---

## 作者：ZCETHAN (赞：19)

[传送门](https://www.luogu.com.cn/problem/P6216)

## 题目大意

给两个字符串 $s$ 和 $t$，求对于 $s$ 的 **每个** 回文串，$t$ 出现的次数之和。

## Solution

这题有点坑，$n,m$ 输入与 $s,t$ 的长度并不符合……

所以需要在字符串最后手动加一个终止符，比如 美元符号什么的。

但是这题的做法非常简单，大概只要会马拉车和 KMP 就可以了。

首先先找出 $t$ 在 $s$ 中出现的位置，然后一个自然的想法就是对于每个位置求出 $t$ 的起点在这个位置之前的匹配数，也就是匹配的前缀和，这很容易想到。

然后写写写，写完一个马拉车，然后非常 naive 地在马拉车每次扩展的时候加上答案。但这是会 GG 的，因为~~我试过~~这样会把马拉车优化的部分对答案的贡献丢掉。

所以正确的做法是对于每个回文串都算一下答案，注意到回文串的个数是 $n^2$ 级别的，于是得到了 $O(n^2)$ 的优秀复杂度。

那我们怎么优化这个东西呢？考虑求这个东西的式子。假设 `x` 是任意字符：


对于这样一个回文串：

```
str: xxxxxxx
pos: 1234567
```
如果前面的前缀和数组是 $pre$，$t$ 的长度是 $2$，那么这个回文串的贡献应该是：$pre_6-pre_0+pre_5-pre_1+\dots+pre_3-pre_3$。我们对它进行一个重新的排列：$pre_6+pre_5+pre_4-(pre_2+pre_1+pre_0)$。不难发现，在原来的基础上再做一次前缀和，就可以快速得到这个东西了。

所以我们做 **二次前缀和** 就可以了。

然后对于每个 **极大** 回文串就可以 $O(1)$，总体复杂度就是 $O(n)$ 了。

## Code

```cpp
// Problem: P6216 回文匹配
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6216
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// Author: ZCETHAN
// Time: 2021-11-02 17:58:03

#include<bits/stdc++.h>
#define ll long long
#define inf (1<<30)
#define INF (1ll<<60)
using namespace std;
const int MAXN=3e6+10;
char s[MAXN],t[MAXN];
int nxt[MAXN],pre[MAXN];
int rd[MAXN];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	scanf("%s%s",s+1,t+1);
	nxt[1]=0;int k=0;s[n+1]=t[m+1]='$';
	for(int i=2;i<=m;i++){
		while(k&&t[k+1]!=t[i]) k=nxt[k];
		if(t[k+1]==t[i]) k++;nxt[i]=k;
	}k=0;
	for(int i=1;i<=n;i++){
		while(k&&t[k+1]!=s[i]) k=nxt[k];
		if(t[k+1]==s[i]) k++;
		if(k==m){pre[i-m+1]++;k=nxt[k];}
	}
	for(int i=1;i<=n;i++) pre[i]+=pre[i-1];
	for(int i=1;i<=n;i++) pre[i]+=pre[i-1];
	int mx=0,R=0;unsigned int ans=0;
	for(int i=1;i<=n;i++){
		rd[i]=(i<R?min(R-i,rd[mx*2-i]):1);
		while(s[i+rd[i]]==s[i-rd[i]])
			rd[i]++;
		if(R<i+rd[i]) mx=i,R=i+rd[i];
	}//这上面都是板子，KMP+Manacher
	for(int i=1;i<=n;i++){
		if(2*rd[i]-1<m) continue;
		int r=i+rd[i]-1,l=i-rd[i]+1;
		l--;r=r-m+1;
		int mid=(l+r)>>1;//注意一下奇偶，特判一下就可以了
		ans+=(pre[r]-pre[mid]-pre[((l+r)&1)?mid:mid-1]+pre[l-1]);
	}
	printf("%u\n",ans);
	return 0;
}
```

---

## 作者：SDNetFriend (赞：11)

####　这个代码真是花了一整天才调出来，坑真的巨多，当然这个题ＡＣ率也是出奇的低

那我就来简要分析下这个题，顺便总结一些易错点

这个题其实是Manacher算法和KMP算法的结合体，因为这里需要判断回文串，并且需要字符匹配

那么首先可以肯定的是,要跑一遍KMP算法,找到所有能和Str2的子串,因为这个子串的长度是不变的

所以这里可以通过记录一个端点来记录整个子串的位置,在这里我们可以选择左端点

下一步我们需要的就是用Manacher算法跑出所有的点的回文半径,因为这里已经确定回文串长度是奇数,所以不需要添加隔断,可以在0位置添加一个"~"

#### 然后就是这个题的精华所在

我这里介绍的是用二次前缀和的方法,那么为什么要用二前缀和呢?大家可以看一下这个样例:

##### 7 2

##### bbbcbbb cb

根据题意,我们可以在这里找到三个回文串,分别是bcb,bbcbb,bbbcbbb

虽然说这三个点的回文中心都在c,但的的确确是三个不同的回文串,所以这里出来的结果应该是3

同样的,假如我们要在上面的样例中寻找b,那就应该是24

为什么用前缀和很好理解,前缀和可以让我们更方便的找出某个区间有多少个Str2,比如在这个样例寻找b那么这个区间前缀和之差就应该是6

但其实我们在寻找的时候,字符是这样分布的:
bbbcbbb

0 0 1 0 1 0 0-->bcb

0 1 2 0 2 1 0-->bbcbb

1 2 3 0 3 2 1-->bbbcbbb

2 3 4 0 4 3 2-->分别对于六个回文串b

3 4 5 0 5 4 3-->分别对于两个回文串bbb

这样就比较好理解24是怎么来的了,那么我们可以声明match数组,如果i位置有该子串就是1,没有就是0

而我们的做法是,每一次寻找一个回文中心$i(1\leq i \leq Len1-Len2+1)$,每一次把在以i为中心的最大回文串范围内的所有Str2统计出来

最后求和就是我们想要的结果,那么比较显而易见的是我们这里可以采用前缀和优化,我们定义$Sum'[i]$就是前i个match的前缀和

这样我们就可以得到对于回文中心i来说

$Ans[i]= \sum_{p=0}^{P[i]} Sum'[i+p-Len2]-Sum'[i-p](2 \times P[i]-1 \ge Len2)$

但我们在这个位置可以发现一个限制条件:$2 \times P[i]-1 \ge Len2$

通过变形,我们可以得到$\lceil \frac{Len2}{2} \rceil \leq P[i]$

因为我们知道$i-P[i]\ge 0$,故有$i\ge P[i]$,那么上式可以转化成$\lceil \frac{Len2}{2} \rceil \leq i$

那么我们就可以对最终结果进行一个比较小的优化,同时定义$Mid=\lceil \frac{Len2}{2} \rceil$,将最终结果转化为

$Ans= \sum_{i=Mid }^{Len1} \sum_{p=Mid}^{P[i]} Sum'[i+p-Len2]-Sum'[i-p]$

对于这个结果,我们同样可以再次使用前缀和优化,定义$Sum''[i]$为i之前的$Sum'$的前缀和,就可以得到

$Ans=\sum_{i=Mid}^{Len1}Sum''[i-Len2+P[i]]-Sum''[i-Len2+Mid-1]-Sum''[i-Mid]+Sum''[i-P[i]-1]$

这样我们就成功地把时间复杂度降低到了O(n),同时要注意的几个地方,一个是要对$2^{32}$取模

另一个是$P[i]\leq \lceil \frac{Len2}{2} \rceil$,还有一点,如果WA掉了#5,#9,#13,#14,#17的话,跑Manacher的时候一定要加上限制条件i-P[i]>=1&&i+P[i]<=Len1

下面就贴代码好了

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
const long long int MAXN=4e6+5;
long long int Len1,Len2,P[MAXN],Next[MAXN]={0};
char Str1[MAXN],Str2[MAXN];
long long int  Match[MAXN],Sum[MAXN],Ans=0;
long long int getSum(long long int b,long long int a){return Sum[a]-Sum[b-1];}
inline void Manacher(){
    long long int R=0,Mid=0;
    for(register long long int i=1;i<=Len1;++i){
        if(i<=R)
            P[i]=min(P[Mid*2-i],R-i+1);
        while(Str1[i+P[i]]==Str1[i-P[i]]&&i-P[i]>=1&&i+P[i]<=Len1)
            ++P[i];
        if(i+P[i]>R){
            R=i+P[i]-1;
            Mid=i;
        }
    }
}
inline void getNext(){
    long long int j=0;
    for(register long long int i=2;i<=Len1;++i){
        while(j&&Str2[j+1]!=Str2[i])
            j=Next[j];
        if(Str2[j+1]==Str2[i])
            ++j;
        Next[i]=j;
    }
}
inline void KMP(){
    getNext();
    long long int j=0;
    for(register long long int i=1;i<=Len1;++i){
        while(j&&Str2[j+1]!=Str1[i])
            j=Next[j];
        if(Str2[j+1]==Str1[i])
            ++j;
        if(j==Len2){
            j=Next[j];
            ++Match[i-Len2+1];
        }
    }
}
int main(){
    scanf("%lld%lld",&Len1,&Len2);
    cin>>Str1+1>>Str2+1;
    Str1[0]='~';
    KMP();
    for(register long long int i=1;i<=Len1;++i)Sum[i]=Match[i];
    for(register long long int i=1;i<=Len1;++i)Sum[i]+=Sum[i-1];
    for(register long long int i=1;i<=Len1;++i)Sum[i]+=Sum[i-1];
    Manacher();
    long long int mid=(Len2+1)/2;
    for(register long long int i=mid;i<=Len1;++i){
        if(2*P[i]-1<Len2)continue;
        Ans+=getSum(i-Len2+mid,i-Len2+P[i]);
        Ans-=getSum(i-P[i],i-mid);
    }
    long long int mod=pow(2,32);
    printf("%lld\n",Ans%mod);
    return 0;
}
```





---

## 作者：Deep_Kevin (赞：11)

看到题解$O(n+m)$的跑的比我慢,我就放心了

我的时间复杂度是$O((n+m)\log n)$的,而且很好想

首先我们考虑对于一个$s2$在$s1$出现的区间$[l,r]$,对于一个回文中心i的贡献,显然两个端点哪个离中心更远,就应该在哪个上算贡献,从左往右遍历每一个我们只需要在中间点的右边一个点切换一下即可

一个区间$[l,r]$对回文中心$i$的贡献具体应该是:

用$[i-mx[i],i+mx[i]]]$来表示i这个回文中心管理的区间

若用$l$来计算贡献,那么对于所有的$l>=i-mx[i]$,有$ans=\sum_l l-(i-mx[i])+1=\sum_l l +\sum_l -i+mx[i]+1$

若用$r$来计算贡献,那么对于所有的$r<=i+mx[i]$,有$ans=\sum_r i+mx[i]-r+1=\sum_r -r+\sum_r i+mx[i]+1$

发现我们只要维护$l$的后缀和,$l$的后缀个数,$r$的前缀和,$r$的前缀个数,就可以计算当前i的答案了,$i$做$manacher$的时候从左往右遍历,记住切换$l,r$就可以了

用时最高点$572ms$,这个树状数组的常数可以相信!

希望$LG$管理员赶紧修好有时开$O2$会全部点$RE$的锅$orz$

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;

#define unsigned int uint
const int N=3000010;
int fail[N],mx[N];
uint tot[N][2],sum[N][2];
char s[N],t[N];
int n,m;
vector<int> V[N];

void add(int x,int op,int t){
	for(int i=(op?n-x+1:x);i<=n;i+=lowbit(i)) 
		sum[i][op]+=x*t,tot[i][op]+=t;
}

uint gs(int x,int op,uint b){
	uint ans=0,we=0;
	for(int i=(op?n-x+1:x);i;i-=lowbit(i)) 
		ans+=sum[i][op],we+=tot[i][op];
	return ans+we*b;
}

void gn(){
	fail[0]=-1;
	for(int i=1;i<=m;i++){
		int now=fail[i-1];
		while(now!=-1 && t[now+1]!=t[i]) now=fail[now];
		fail[i]=now+1;
	}
}

void kmp(){
	int i=1,j=1;
	for(int i=1,j=1;i<=n;i++,j+=2){
		j--;
		while(j!=-1 && t[j+1]!=s[i]) j=fail[j];
		if(j==m-1){ 
			add(i,0,1);
			V[(i+i-m+1)/2+1].push_back(i);
		}
	}
}

void mnc(){
	int mr=0,op=0;
	uint ans=0;
	for(int i=1;i<=n;i++){
		if(i<mr) mx[i]=min(mr-i,mx[2*op-i]);
		while(i-mx[i]>1 && i+mx[i]<n && s[i-mx[i]-1]==s[i+mx[i]+1]) mx[i]++;
		if(i+mx[i]>mr) mr=i+mx[i],op=i;
		for(int j=0;j<V[i].size();j++){
			add(V[i][j],0,-1);
			add(V[i][j]-m+1,1,1);
		}
		ans+=gs(i-mx[i],1,-i+mx[i]+1);
		ans-=gs(i+mx[i],0,-i-mx[i]-1);
	}
	printf("%u\n",ans);
}

int main(){
	scanf("%d %d",&n,&m);
	scanf("%s %s",s+1,t+1);
	gn();kmp();mnc();
}

```

---

## 作者：zzzyhaaa (赞：6)

### PAM+KMP+TOPO  
数据量巨大，出题人估计想卡PAM，，，但我还是强行A了  
也挺简单，，基本步骤：  
1.对s1构建PAM，每个结点对应的回文串的出现次数用TOPO解决。  
2.s2在每个奇数回文中的出现次数用KMP解决。  
然后最后答案，就是(每个奇数回文的出现次数乘以s2在该奇数回文中的出现次数)之和了。  
其中求第2步时，应先在s1上跑一遍KMP，求出区间[1,i]内s2的出现次数(即前缀和)，然后对PAM中的每个结点，判断其对应的回文在s1中的区间，直接O(1)求出s2在该回文中的出现次数。  
求前缀和，s2在s1中出现的终结点记为s2的出现位置。  

**时间复杂度O(n+m)，常数很大，基本把时间复杂度向上翻了一个数量级。**

AC代码
```c++
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
const int maxn = 3e6+5;
typedef struct PAM{
    int Trie[maxn][27],fail[maxn],size,last,Len[maxn],in[maxn];
    int times[maxn];
    int len1,len2;
    char s1[maxn],s2[maxn];
    int Next[maxn],mark[maxn];               //mark标记结点在母串s1中的位置
    ll dp[maxn];
    ll ans,mod;
    PAM(){
        last = size = 1;
        Len[0] = 0,Len[1] = -1;
        fail[0] = fail[1] = 1;
        ans = 0;
        mod = pow(2, 32);
    }
    void Insert(char ch,int idx){
        while (s1[idx-Len[last]-1]!=s1[idx])  last = fail[last];
        if (!Trie[last][ch-'a'+1]){
            int v = fail[last];
            while (s1[idx-Len[v]-1]!=s1[idx])   v = fail[v];
            fail[++size] = Trie[v][ch-'a'+1];
            in[fail[size]]++;
            Trie[last][ch-'a'+1] = size;
            Len[size] = Len[last] + 2;
        }
        times[Trie[last][ch-'a'+1]]++;
        last = Trie[last][ch-'a'+1];
        if (!mark[last])    mark[last] = idx;
    }
    void Build(){
        for (int i=1;i<=len1;i++)
            Insert(s1[i],i);
        topu();
        printf ("%lld", ans);
        return;
    }
    void KMP(){
        for (int i=2,j=0;i<=len2;i++){
            while (j && s2[i]!=s2[j+1])    j = Next[j];
            if (s2[i]==s2[j+1])   j++;
            Next[i] = j;
        }
        for (int i=1,j=0;i<=len1;i++){
            while (j && s1[i]!=s2[j+1])  j = Next[j];
            if (s1[i]==s2[j+1])  j++;
            dp[i] = dp[i-1];
            if (j==len2){
                dp[i]++;
                j = Next[j];
            }
        }
        return;
    }
    void topu(){
        queue<int>  q;
        for (int i=2;i<=size;i++)   if (in[i]==0)
            q.push(i);
        while (!q.empty()){
            int tmp = q.front();    q.pop();
            if (Len[tmp]&1)                     //拓扑排序进行时，统计答案。
                ans = (ans+GetAns(mark[tmp], Len[tmp])*times[tmp])%mod;
            times[fail[tmp]] += times[tmp];
            in[fail[tmp]]--;
            if (in[fail[tmp]]==0)
                q.push(fail[tmp]);
        }
        return;
    }
    ll GetAns(int idx, int len){
        int l = idx-len+1 + len2-1-1;
        if (l>idx)  return 0;
        return dp[idx]-dp[l];
    }
}PAM;
PAM P;
int main(){
    scanf ("%d %d",&P.len1,&P.len2);
    scanf ("%s %s",P.s1+1,P.s2+1);
    P.KMP();
    P.Build();
    return 0;
}
```

![](http://www.zyhcoding.club:80/wp-content/uploads/2020/04/UNY2DDHY6K5J@NCNO5CM.png)

---

## 作者：破忆 (赞：5)

[P6216 回文匹配](https://www.luogu.com.cn/problem/P6216)

复习字符串算法。

## 【题意】

对于一对字符串 $s_1\ s_2$，若 $s_1$ 的子串 $(l,r)$ 是奇回文串，则分数会增加 $s_2$ 在 $(l,r)$ 中出现的次数，求分数。

## 【分析】

首先用 KMP 处理出 $s_2$ 在 $s_1$ 中出现的所有位置。

要求每个位置被多少个回文串覆盖了。

跑 manacher，得到以 $i$ 为中心的最大回文串半径。

如下图所示，下标 $1-7$ 的位置形成了回文串，$s_2$ 的长度为 $2$。

| 下标 | 贡献 | 一阶差分 | 二阶差分 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | 1 | 1 | 1 |
| 2 | 2 | 1 | 0 |
| 3 | 3 | 1 | 0 |
| 4 | 3 | 0 | -1 |
| 5 | 2 | -1 | -1 |
| 6 | 1 | -1 | 0 |
| 7 | 0 | -1 | 0 |
| 8 | 0 | 0 | 1 |

观察到贡献值的二阶差分只用修改 $4$ 个量。

$s_2$ 长度为奇数同理，以 $3$ 为例。

| 下标 | 贡献 | 一阶差分 | 二阶差分 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | 1 | 1 | 1 |
| 2 | 2 | 1 | 0 |
| 3 | 3 | 1 | 0 |
| 4 | 2 | -1 | -2 |
| 5 | 1 | -1 | 0 |
| 6 | 0 | -1 | 0 |
| 7 | 0 | 0 | 1 |
| 8 | 0 | 0 | 0 |

推推式子搞出需要修改的几个位置即可。

## 【算法】

KMP+manacher+差分

## 【代码】

```cpp
#include<bits/stdc++.h>
using namespace std;
char gc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
char readc(){
	char ch=getchar();
	while(ch>'z'||ch<'a') ch=getchar();
	return ch;
}
const int maxn=3e6+5;
int n,m;
char A[maxn],B[maxn];
int kmp[maxn];
bool st[maxn];
int r[maxn],c[maxn],d[maxn];
unsigned int ans;
void KMP(){
	for(int i=2,j=0;i<=m;i++){
		while(j&&B[i]!=B[j+1]) j=kmp[j];
		if(B[i]==B[j+1]) j++;
		kmp[i]=j;
	}
	for(int i=1,j=0;i<=n;i++){
		while(j&&A[i]!=B[j+1]) j=kmp[j];
		if(A[i]==B[j+1]) j++;
		if(j==m) st[i-m+1]=1,j=kmp[j];
	}
}
void Manacher(){
	for(int i=1,p=1,mx=1;i<=n;i++){
		r[i]=min(r[2*p-i],mx-i);
		while(i+r[i]<=n&&A[i-r[i]]==A[i+r[i]]) r[i]++;
		if(2*r[i]-1>=m){
			c[i-r[i]+1]++;
			if(m&1){
				c[(2*r[i]-1-m)/2+i-r[i]+2]-=2;
			}else{
				c[(2*r[i]-1-m)/2+i-r[i]+2]--;
				c[(2*r[i]-1-m)/2+i-r[i]+3]--;
			}
			c[i+r[i]-m+2]++;
		}
		if(i+r[i]>mx) mx=i+r[i],p=i;
	}
} 
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P6216.in","r",stdin);
	freopen("P6216.out","w",stdout);
	#endif
	n=read(),m=read();
	for(int i=1;i<=n;i++) A[i]=readc();
	for(int i=1;i<=m;i++) B[i]=readc();
	KMP();
	Manacher();
	for(int i=1;i<=n;i++){
		c[i]+=c[i-1];
		d[i]=d[i-1]+c[i];
		ans+=d[i]*st[i];
	}
	printf("%u\n",ans);
	return 0;
}
```


---

## 作者：_Diu_ (赞：5)

题目[传送门](https://www.luogu.com.cn/problem/P6216)

这么多人都用 manacher，就没有~~不正经的~~人用 hash ~~水~~过吗？

本题我的思路比较奇怪，是**字符串 hash+ 二分 +kmp+ 前缀和**。

思路新奇。

首先第一步：

## ~~看一下毛片~~

咳咳，

## kmp

我们可以用一个数组存起来每一段区间是不是和待匹配字符串匹配。

可以以这个字符串的左端点存也可以以右端点。

我这里是以右端点的。

```cpp
	for(int i=2,j=0;i<=m;i++){
		while(j>0&&s2[j+1]!=s2[i])j=nxt[j];
		if(s2[j+1]==s2[i])j++;
		nxt[i]=j;
	}
	for(int i=1,j=0;i<=n;i++){
		while(j>0&&s2[j+1]!=s1[i])j=nxt[j];
		if(s2[j+1]==s1[i])j++;
		if(j==m){
			a[i]=1;
			j=nxt[j];
		}
	}
```

然后，我们就可以处理回文串了。

处理回文串时，我们用 

## 字符串 hash+ 二分

来代替 manacher。

很明显回文串有一个单调性：

- 当 $[l,r]$ 是回文串时，$[l+1,r-1]$ 也是回文串 $(l+1<r)$。

因此，我们可以枚举每一个中心点，

对于每一个中心点进行二分，

二分的是左右扩展的长度。

用字符串哈希（前后缀都要）来判断当前字符串是不是回文串。

然后对于每一个中心点统计答案就好了。

```cpp
for(int i=1;i<=n;i++){
	int l=0,r=min(i,n-i+1);
	while(l+1<r){
		int mid=(l+r)/2;
		if(ha[i]-ha[i-mid-1]*t[mid+1]==hb[i]-hb[i+mid+1]*t[mid+1])l=mid;
		else r=mid;
	}
}
```

## 前缀和

我们可以分析一下：

我们现在已经知道区间 $[i,i],[i-1,i+1],…,[i-l,i+l]$ 是回文串，

每一个区间要统计多少个呢：

![](https://cdn.luogu.com.cn/upload/image_hosting/ogd5crab.png?x-oss-process=image/resize,m_lfit,h_170,w_325)

看图我们就可以知道，这个统计数量分别是：

$1,2,3,…,l-1,l,l-1,…3,2,1$

但是，这里每一个字符串是以右端点存的，

所以对应的，我们要求的是：

$1*a[i-l+m-1]+2*a[i-l+m]+…+1*a[i+l]$

这里面我们可以这样求

我们存储三个前缀和：

$s[i]$ 表示 $a[1,l]$ 的和，

$ss[i]=\sum_{j-1}^i i*a[i]$，

$sss[i]=\sum_{j-1}^i (n-i+1)*a[i]$

这样，我们就可以把原来的那一段区间分成两段：

假设当前区间左右两端点为 $x$ 和 $y$。

一段递增：$[x,mid]$。

一段递减：$[mid+1,y]$。

则 $mid=(l+r)/2$。

递增：$(ss[mid]-ss[x-1])-(s[mid]-s[x-1])*(mid-x)$

同理，递减部分：$(sss[r]-sss[mid])-(s[r]-s[mid])*(n-r)$

```cpp
int gts(int l,int r){
	if(l>r)return 0;
	int mid=(l+r)/2;
	int L=((ss[mid]-ss[l-1])%p-(s[mid]-s[l-1])*(l-1)%p+p)%p;
	int R=((sss[r]-sss[mid])%p-(s[r]-s[mid])*(n-r)%p+p)%p;
	return (L+R)%p;
}
```

## code

其实核心代码都给出来了，

再给一个完整代码吧！

~~我真的太仁慈了~~

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define int long long
using namespace std;
const int N=3e6+10,p=(1ll<<32);
string s1,s2;
int n,m,nxt[N],s[N],ss[N],sss[N],ans;
ull ha[N],hb[N],t[N],b=131;
int gts(int l,int r){
	if(l>r)return 0;
	int mid=(l+r)/2;
	int L=((ss[mid]-ss[l-1])%p-(s[mid]-s[l-1])*(l-1)%p+p)%p;
	int R=((sss[r]-sss[mid])%p-(s[r]-s[mid])*(n-r)%p+p)%p;
//	printf("%d %d %d\n",l,r,(L+R)%p);
	return (L+R)%p;
}
signed main(){
	cin>>n>>m>>s1>>s2;
//	n=s1.size(),m=s2.size();
	s1=' '+s1,s2=' '+s2;
	t[0]=1;
	for(int i=1;i<=n;i++)t[i]=t[i-1]*b;
	for(int i=2,j=0;i<=m;i++){
		while(j>0&&s2[j+1]!=s2[i])j=nxt[j];
		if(s2[j+1]==s2[i])j++;
		nxt[i]=j;
	}
	for(int i=1,j=0;i<=n;i++){
		while(j>0&&s2[j+1]!=s1[i])j=nxt[j];
		if(s2[j+1]==s1[i])j++;
		if(j==m){
			s[i]=1;
			j=nxt[j];
		}
		ha[i]=ha[i-1]*b+s1[i];
		ss[i]=(ss[i-1]+s[i]*i%p)%p;
		sss[i]=(sss[i-1]+s[i]*(n-i+1)%p)%p;
	}
	for(int i=n;i>=1;i--)hb[i]=hb[i+1]*b+s1[i];
	for(int i=1;i<=n;i++)s[i]+=s[i-1];
	for(int i=1;i<=n;i++){
		int l=0,r=min(i,n-i+1);
		while(l+1<r){
			int mid=(l+r)/2;
			if(ha[i]-ha[i-mid-1]*t[mid+1]==hb[i]-hb[i+mid+1]*t[mid+1])l=mid;
			else r=mid;
		}
		ans=(ans+gts(i-l+m-1,i+l))%p;
	}
	printf("%lld\n",ans);
}
```

完结

---

## 作者：LightningUZ (赞：5)

似乎是不一样的思路？

简介： Manacher+KMP+二次前缀和 （确信）

~~两个板子+一个思维~~

~~板子都不带变形的~~

### 思路

大体框架：
1. 求出所有的奇数长度回文串的表达形式 （Manacher）
2. 统计所有奇数长度回文串中一共出现了多少次 $s_2$，累加起来  (KMP 求匹配，然后二次前缀和)

看起来是两个很慢的东西，但实际上都可以 $O(n)$ 算。

#### 求出所有回文串的表达形式

我们设 $p_i$ 表示 $i$ 为中心的最长回文半径（即：$[i-p_i+1,i+p_i-1]$ 这一段子串回文且 $p_i$ 最大）。

比如 $s=\texttt{"abcba"}$，那么 $p[3]=3$。

然后这个可以用 $Manacher$ 求出来。因为只要求奇数长度的，我们甚至不用补特殊字符，直接算即可。复杂度 $O(n)$。

#### 求和

##### 求区间出现次数
我们考虑如何快速的求 $[l,r]$ 中 $s_2$ 出现了多少次：

设 $match[i]$ 表示 $S$ 以 $i$ 开头长度为 $m$ 的子串，是否和 $s2$ 匹配 （这个可以 $KMP$ 算）。

然后维护 $match$ 数组的前缀和，设为 $s$ 数组。$s[r-m+1]-s[l-1]$ 就是 $[l,r]$ 中 $s_2$ 出现的次数了。

##### 优化
那么现在我们相当于，对于每个 $i$ 的每一个 $\le p_i$ 的回文半径 $l$，求和 $[i-l+1,i+l-1]$ 中 $s_2$ 的出现次数，即 $s[i+l-m]-s[i-l]$

当然，$2l-1\ge m$，所以 $l$ 可以从 $\lceil\dfrac{m}{2}\rceil$ 开始枚举。如果 $\lceil\dfrac{m}{2}\rceil < m$，那就直接 `continue` ...

后面为了方便，设 $mid=\lceil\dfrac{m}{2}\rceil$

转化一下数学式子，变成

 $\sum\limits_{i=mid}^n\sum\limits_{l=mid}^{p_i} s[i+l-m]-s[i-l]$
$=\sum\limits_{i=mid}^n s[i-m+mid\dots i-m+p_i]
-s[i-p_i...i-mid]$

然后我们维护 $s$ 的前缀和 $ss$ （额，也就是 $match$ 数组的前缀和的前缀和），上面的式子就能 $O(n)$ 算了。枚举一个 $i$，然后四个二次前缀和加加减减，就出来了。

详见代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 3666666
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I()
    {
        int x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        return (x=(f==1)?x:-x);
    }
    void Rd(int cnt,...)
    {
        va_list args; va_start(args,cnt);
        F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();}
        va_end(args);
    }

    int n,m;
    char a[N],b[N];
    void Input()
    {
        Rd(2,&n,&m);
        scanf("%s%s",a+1,b+1);
    }

    int fail[N];
    void Getfail()
    {
        fail[1]=0;
        F(i,2,n) 
        {
            int j=fail[i-1];
            while(j and b[j+1]!=b[i]) j=fail[j];
            if (b[j+1]==b[i]) fail[i]=j+1; 
        }
    }
    bool match[N];
    void KMP()
    {
        Getfail();
        int j=0;
        F(i,1,n)
        {
            while(j and b[j+1]!=a[i]) j=fail[j]; 
            if (b[j+1]==a[i]) ++j;
            if (j==m) match[i-m+1]=1,j=fail[j];
        }
    }
    // 这一段是 KMP 求 match 数组
    // 其实就是 KMP 板子
    int ss[N];
    int p[N];
    int sum(int l,int r){return ss[r]-ss[l-1];}
    // 前缀和的区间和 （用二次前缀和相减）
    void Soviet()
    {
        KMP();
        F(i,1,n) ss[i]=match[i];
        F(i,1,n) ss[i]+=ss[i-1];
        F(i,1,n) ss[i]+=ss[i-1]; // 二次前缀和

        int id=0,Max=0;
        F(i,1,n)
        {
            int j=2*id-i;
            p[i]=(i<Max)?min(p[j],Max-i):1;
            while(a[i-p[i]]==a[i+p[i]] and i-p[i]>=1 and i+p[i]<=n) ++p[i];
            if (i+p[i]>Max) Max=i+p[i],id=i;
        }
        // 这一段是 Manacher 求最长回文半径
        // 其实就是 Manacher 的板子...

        unsigned int ans=0;
        int mid=(m+1)/2;
        F(i,mid,n)
        {
            if (2*p[i]-1<m) continue; // 这个注意一下
            ans+=sum(i-m+mid,i-m+p[i]);
            ans-=sum(i-p[i],i-mid);
        }
        printf("%u\n",ans);
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input();
        Soviet();
    }
    #undef int //long long 
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：4)

~~不要问我为什么做这种水题~~

首先直接建 PAM，平凡的有 $O(n)$ 种本质不同的回文串。

对于这道题来说每个本质相同的回文串贡献相同，我们只需要求出一个的贡献再乘上个数即可。

如果每个串暴力 KMP 复杂度就炸了，因为每个串长度可能 $O(n)$，比如给你全 `a` 串。

我们没利用到什么？这些回文串都出自于原串，于是我们对原串做一遍 KMP，然后用仿佛是 SAM 的技巧：

在原串随便找一个 endpos 位置取出一个串来算贡献，那么就是求一个区间内的贡献，前缀和即可。

细节：

- 只取奇数长度回文串，题目要求。

- 这道题卡空间，不支持非基于势能的写法，空间是 $O(26n)$ 的，基于势能的空间才是 $O(n)$。（当然你要写 Hash 表才是标准的 $O(n)$）

- 对 $2^{32}$ 取模，既不是 `long long`，也不是 `unsigned long long`，是 `unsigned int`。

总结：有 PAM 就可以不动脑做的题。

[代码](https://www.luogu.com.cn/paste/13rtxqyy)

---

## 作者：suxxsfe (赞：2)

https://www.cnblogs.com/suxxsfe/p/13324750.html  

KMP+manacher：https://www.luogu.com.cn/problem/P6216  

对于一对字符串 $(s_1,s_2)$，若 $s_1$ 的长度为奇数的子串 $(l,r)$ 满足 $(l,r)$ 是回文的，那么 $s_1$ 的“分数”会增加 $s_2$ 在 $(l,r)$ 中出现的次数。  
现在给出一对 $(s_1,s_2),n=|s1|,m=|s2|$，请计算出 $s_1$ 的“分数”。  
答案对 $2 ^ {32}$ 取模。  

首先因为要求 $(l,r)$ 回文，所以可以用 manacher 求出每一个字符的回文半径，然后根据半径确定以它为对称轴的最长回文串 $(l,r)$  
然后答案要加上 $(l,r),(l+1,r-1),(l+2,r-2),\cdots$ 中 $s2$ 出现次数和  
对于字串 $(l,r)$，就看区间 $[l,r-m+1]$ 中，有几个字符可以作为 $s2$ 的开头并与之完全匹配  
这一点可以用 kmp 求出，以 $a_i$ 表示 $s1_i$ 能否作为 $s2$ 的开头并和它完全匹配  
这里用前缀和，则求每个区间的复杂度是 $O(1)$，但区间个数 $O(n)$，还要继续优化  
表达成式子，方便表示，设 $L=l,R=r-m+1,maxk=\lfloor\frac{R-L}{2}\rfloor$：  

$$\sum_{k=0}^{maxk}\sum_{i=L+k}^{R-k}a_i$$  
$$\sum_{k=0}^{maxk}sum(R-k)-sum(L+k-1)$$  
$$\sum_{i=R-maxk}^{R}sum(i)-\sum_{i=L-1}^{L+maxk-1}sum(i)$$  

发现这里的前缀和，也就是 $sum$ 还是一个区间求和的形式，所以可以求一个二次前缀和（前缀和的前缀和），记之为 $summ$  
所以原来的式子就是：  

$$summ(R)-summ(R-maxk-1)-summ(L+maxk-1)-summ(L-2)$$  

所以总复杂度就是 $O(n)$ 了  

题目里说 $(l,r)$ 长度仅限奇数，所以 manacher 时不用像模板一样在字符间隙填充无意义字符  
但一开始没看到这点，等注意到时代码都写的差不多了，懒得改了  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
#define mod 4294967296ll
int fail[3000005];
char s1[3000005],s2[3000005];
int len1,len2;
int summ[3000005];
char s[6000005];
int n;
int len[6000005];
inline void KMP(){
	fail[1]=0;
	for(reg int j,i=2;i<=len2;i++){
		j=fail[i-1];
		while(j&&s2[j+1]!=s2[i]) j=fail[j];
		if(j) fail[i]=j+1;
		else fail[i]=(s2[1]==s2[i]);
	}
	for(reg int j=0,i=1;i<=len1;i++){
		while(s1[i]!=s2[j+1]&&j) j=fail[j];
		if(s1[i]==s2[j+1]) j++;
		if(j==len2){
			j=fail[j];
			summ[i-len2+1]=1;
		}
	}
}
inline LL manacher(){
	LL ans=0;
	s[0]=1;s[1]=2;n=1;
	for(reg int i=1;i<=len1;i++) s[++n]=s1[i],s[++n]=2;
	s[n+1]=3;
	reg int pos=0,max=0;
	for(reg int L,R,i=1;i<=n;i++){
		if(pos+max-1<i) len[i]=1;
		else len[i]=std::min(len[pos+pos-i],pos+max-i);
		while(s[i+len[i]]==s[i-len[i]]) len[i]++;
		if(i+len[i]-1>=pos+max-1) pos=i,max=len[i];
		L=(i-len[i]+2)>>1;R=((i+len[i]-2)>>1)-len2+1;
//			printf("i : %d, id : %d, len[i] : %d, L : %d, R : %d\n",i,i>>1,len[i],L,R);
		if(s[i]!=2&&R>=L) ans+=summ[R]-summ[R-((R-L)>>1)-1]-summ[L+((R-L)>>1)-1]+summ[std::max(L-2,0)],ans%=mod;
		//长度为奇数 
//			printf("ans : %d\n",ans); 
	}
	return ans%mod;
}
int main(){
	len1=read();len2=read();
	scanf("%s",s1+1);scanf("%s",s2+1);
	if(len1<len2) return puts("0"),0;
	KMP();
	for(reg int i=1;i<=len1;i++) summ[i]+=summ[i-1];
	for(reg int i=1;i<=len1;i++) summ[i]+=summ[i-1];
	printf("%lld",manacher());
	return 0;
}
```

---

## 作者：Alex_Wei (赞：1)

> [P6216 回文匹配](https://www.luogu.com.cn/problem/P6216)

旧题重做。

首先 KMP 求出 $s_2$ 在 $s_1$ 中所有出现位置 $P = \{p_i\}$。

考虑一个回文子串 $s[l, r]$ 对答案的贡献：$l + |s_2| - 1 \sim r$ 之间的出现位置个数。

注意对于固定的对称中心 $i$ 随着回文半径 $j$ 从 $1$ 增大至 $R_i$，$[i - j + |s_2|, i + j - 1]$ 的左右端点向两侧不断扩展 $1$。

令 $l = i - R_i + |s_2|$，$r = i + R_i + 1$。因为位置 $k$ 被区间覆盖的次数等于第一次覆盖到它后区间继续扩展的次数 $\min(k - l + 1, r - k + 1)$，所以回文中心 $i$ 的贡献为
$$
\sum\limits_{k = l} ^ r \min(k - l + 1, r - k + 1) [k\in P]
$$


分类讨论去掉 $\min$。令 $m$ 为 $l + r$ 除以 $2$ 下取整，则贡献为
$$
\sum\limits_{k = l} ^ {mid} (k - l + 1) [k\in P] + \sum\limits_{k  = mid + 1} ^ r (r - k + 1)[k\in P]
$$


括号拆掉，维护 $a_k = [k\in P]$ 和 $b_k = k[k\in P]$ 的前缀和 $pa_k$ 和 $pb_k$，则贡献为
$$
((pb_{mid} - pb_{l - 1}) - (l - 1)(pa_{mid} - pa_{l - 1})) + ((r + 1)(pa_r - pa_{mid }) - (pb_r - pb_{mid}))
$$
默认 $|s_2| \leq |s_1|$，时间复杂度 $\mathcal{O}(|s_1|)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6 + 5;
int n, m, cnt, nxt[N], R[N];
char s[N], t[N], h[N << 1];
unsigned ans, ap[N], ia[N];
unsigned s1(int l, int r) {return ap[r] - ap[l - 1];}
unsigned s2(int l, int r) {return ia[r] - ia[l - 1];}
int main() {
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  scanf("%d%d%s%s", &n, &m, s + 1, t + 1);
  for(int i = 2, p = 0; i <= m; i++) {
    while(p && t[p + 1] != t[i]) p = nxt[p];
    nxt[i] = p += t[p + 1] == t[i];
  }
  for(int i = 1, p = 0; i <= n; i++) {
    while(p && t[p + 1] != s[i]) p = nxt[p];
    if((p += t[p + 1] == s[i]) == m) ap[i] = 1, ia[i] = i;
  }
  for(int i = 1; i <= n; i++) ap[i] += ap[i - 1], ia[i] += ia[i - 1];
  h[0] = '!', h[cnt = 1] = '@';
  for(int i = 1; i <= n; i++) h[++cnt] = s[i], h[++cnt] = '@';
  h[++cnt] = '#';
  for(int i = 1, c = 0, r = 0; i < cnt; i++) {
    R[i] = i > r ? 1 : min(R[2 * c - i], r - i + 1);
    while(h[i - R[i]] == h[i + R[i]]) R[i]++;
    if(i + R[i] - 1 > r) c = i, r = i + R[i] - 1;
  }
  for(int i = 1; i <= n; i++) {
    int radius = R[i << 1] >> 1;
    int l = i - radius + m, r = i + radius - 1;
    if(l > r) continue;
    int mid = l + r >> 1;
    ans += s2(l, mid) - (l - 1) * s1(l, mid);
    ans += (r + 1) * s1(mid + 1, r) - s2(mid + 1, r);
  }
  cout << ans << endl;
  return cerr << "Time: " << clock() << endl, 0;
}
/*
2022/6/15
start coding at 9:26
finish debugging at 9:46
*/
```

---

## 作者：Clever_Jimmy (赞：1)

upd: fixed a typo

### 题意简述：

给定 $S, T$，求 $T$ 在 $S$ 的所有奇数长度的回文子串中出现的次数之和。

$1\le\left|S\right|, \left|T\right| \le 3\cdot10^6$

### 解题思路：

记 $n = \left|S\right|, m = \left|T\right|$。

在回文树上，从长度为 $-1$ 的虚拟节点 $1$ 开始 dfs，即可遍历所有奇数长度的回文子串。

注意到，即使回文树上的某个点对应的回文串在 $S$ 中多次出现，其本质上是相同的。

我们考虑记录一下每个回文串在 $S$ 中对应的右界，并用 KMP 处理出 $T$ 在 $S$ 的每一个前缀中出现的次数。

利用差分的思想，$T$ 在 $S[l\ldots r]$ 中出现的次数就是 $sum_r - sum_{l + m - 2}$

答案即为

$\sum\limits_{u \in \text{subtree of node }1}(sum_r - sum_{l + m - 2})\cdot cnt_u$

### 参考代码：

```cpp
#include <bits/stdc++.h>
#define LL long long
#define uint64 unsigned int

const int N = 3e6 + 5;
const int C = 26 + 5;

int n, m, sum[N], _next[N];
char str1[N], str2[N];

uint64 ans;

struct EERTREE {
    static const int MS = N;

    int n;
    int last;
    int cntNode;
    int len[MS];
    int R[MS];
    int cnt[MS];
    int link[MS];
    int ch[MS][C];

    int make(int l) {
        len[cntNode] = l;
        return cntNode++;
    }
    int GetFail(int x) {
        while(str1[n] != str1[n - len[x] - 1]) x = link[x];
        return x;
    }
    void extend(int x) {
        ++n;
        int fa = GetFail(last);
        if(!ch[fa][x]) {
            int now = make(len[fa] + 2);
            link[now] = ch[ GetFail(link[fa]) ][x];
            ch[fa][x] = now;
        }
        last = ch[fa][x];
        R[last] = n;
        ++cnt[last];
    }
    void init() {
        n = cntNode = last = 0;
        make(0), make(-1);
        link[0] = 1, link[1] = 0;
        str1[0] = -1;
    }
    void refresh() {
        for(int i = cntNode - 1; i >= 0; --i) cnt[ link[i] ] += cnt[i];
    }
    void dfs(int x) {
        if(len[x] >= m)
           ans += (sum[ R[x] ] - sum[ R[x] - len[x] + m - 1]) * cnt[x];
        for(int i = 1; i <= C; ++i) if (ch[x][i])
            dfs(ch[x][i]);
    }
    EERTREE() { init(); }
} t;

void Get_Next(char *S, int len) {
    for(int i = 1, j = 0; i < len; ++i, j = _next[i]) {
        while(j > 0 && S[i + 1] != S[j + 1])
            j = _next[j];
        if(S[i + 1] == S[j + 1])
            j++;
        _next[i + 1] = j;
    }
}
void KMP(char *S, int len1, char *T, int len2) {
    for(int i = 0, j = 0; i <= len1; ) {
        if(j == len2)
            sum[i] = 1;
        if(S[i + 1] == T[j + 1])
            ++i, ++j;
        else {
            if (j == 0) ++i;
            else j = _next[j];
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    scanf("%s %s", str1 + 1, str2 + 1);
    Get_Next(str2, m);
    KMP(str1, n, str2, m);
    for(int i = 1; i <= n; ++i) sum[i] += sum[i - 1];
    for(int i = 1; i <= n; ++i) t.extend(str1[i] - 'a' + 1);
    t.refresh();
    t.dfs(1);
    printf("%u", ans);
    return 0;
}
/*
10 2
ccbccbbcbb bc

20 2
cbcaacabcbacbbabacca ba

*/
```


---

## 作者：FutaRimeWoawaSete (赞：1)

以下涉及的回文字符串均是长为奇数的回文字符串。

我们考虑先用 kmp 求出以所有位置为开头的长为 $m$ 的字串是否可以与 $s2$ 匹配，并且用一个数组 $sum_i$ 记录当前这个位置为开头的长为 $m$ 的字串是否可以与 $s2$ 匹配，然后把 $sum$ 滚一遍前缀和。         

现在我们知道，如果要查询区间 $[l , r]$ 中出现了多少个 $s2$ 就直接用 $sum_{r - m + 1} - sum_{l - 1}$ 即可。          

考虑再用 manacher 求出以每个点为对称轴得到的最长回文半径 $p_i$ ，那么我们现在只需要枚举所有点为对称轴得到的回文字符串中包含了多少个 $s2$ 即可，显然用上面的式子可以做到枚举出了回文字符串后 $O(1)$ 算。     

这里枚举的时候由于回文串长度至少要大于等于 $m$ ，所以外层枚举点可以从 $\lceil \frac{m}{2} \rceil$ 开始枚举。

接着我们观察一下一下我们的式子，发现在枚举好了中心点后，内部需要计算的 $sum$ 数组又可以被拆分成两部分连续的段，所以我们再把 $sum$ 数组滚一遍前缀和就好了。            

个人认为此题的重难点在于发现 $m$ 的长度固定，然后可以转化为前缀的形式 $O(1)$ 计算一个子问题，比较精妙。              

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e6 + 5;
unsigned int ans,n,m,lens,lenp,kmp[Len],cnt,P[Len];
char s[Len],p[Len];
unsigned int sum[Len]; 
inline unsigned int C(int l,int r)
{
	if(l <= 0) return sum[r];
	return sum[r] - sum[l - 1];
}
int main()
{	
	scanf("%u %u",&n,&m);
	scanf("%s",s + 1);scanf("%s",p + 1);
	lens = n , lenp = m;
	kmp[0] = kmp[1] = 0;
	int j = 0;
	for(int i = 2 ; i <= lenp ; i ++)
	{
		while(j > 0 && p[j + 1] != p[i]) j = kmp[j];
		if(p[j + 1] == p[i]) j ++;
		kmp[i] = j;
	}
	j = 0;
	for(int i = 1 ; i <= lens ; i ++)
	{
		while(j > 0 && p[j + 1] != s[i]) j = kmp[j];
		if(p[j + 1] == s[i]) j ++;
		if(j == lenp) 
		{
			sum[i - j + 1] ++;
			j = kmp[j];
		}
	}
	for(int i = 1 ; i <= lens ; i ++) sum[i] += sum[i - 1];
	for(int i = 1 ; i <= lens ; i ++) sum[i] += sum[i - 1];
	unsigned int Mid = (m + 1) / 2;
	for(unsigned int t = 1 , r = 0 , mid = 0 ; t <= n ; t ++)
	{
		if(t <= r) P[t] = min(P[(mid << 1) - t] , r - t + 1);
		while(t - P[t] >= 1 && t + P[t] <= n && s[t - P[t]] == s[t + P[t]]) P[t] ++;
		if(P[t] + t > r)
		{
			r = P[t] + t - 1;
			mid = t;
		}
		//printf("###%d\n",P[t]);
	}
	for(int i = Mid ; i <= n ; i ++) 
	{
		if(2 * P[i] - 1 < m) continue;
		//printf("%d %d %d %d\n",i + Mid - m - 1,i + P[i] - m,i - P[i] - 1,i - Mid);
		ans += C(i + Mid - m , i + P[i] - m);
		ans -= C(i - P[i] , i - Mid);
	} 
	printf("%u\n",ans);
	return 0;
}
```

---


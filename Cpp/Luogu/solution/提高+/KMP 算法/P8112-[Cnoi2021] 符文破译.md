# [Cnoi2021] 符文破译

## 题目背景

Cirno 想要解读一本古老的魔法书。

## 题目描述

为了保护魔法书中记载的禁忌的魔法，撰写者将符咒的魔法词缀不加空格地连接在一起，形成一个符文串，记作 $\texttt{S}$。

而构成符文串的所有魔法词缀都被记载在更远古的先知所编写的魔法辞典中，记作 $\texttt{T}$。具体地，$\texttt{T}$ 的所有非空前缀均是一个合法的魔法词缀。

简洁是魔法书撰写的第一要务，所以使用的魔法词缀应该尽可能少。所以在破译魔法书时，将 $\texttt{S}$ 分解成的魔法词缀数越少，破译正确的可能性就越高。

Cirno 想知道，这本魔法书最少的魔法词缀划分段数是多少。

特别地，如果不存在一种合法的划分方案，则表明这本魔法书是假的。Cirno 将得到一个字符串 `Fake`。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据，保证 $1\le |\texttt{S}|,|\texttt{T}|\le 10^7$，$\texttt{S}_x,\texttt{T}_x \in [\texttt{a},\texttt{z}]$。

**子任务**

Subtask1（$10$ points）：$\texttt{T}_x=\texttt{a}$。

Subtask2（$20$ points）：$|\texttt{S}|\le1000$。

Subtask3（$30$ points）：$|\texttt{S}|\le 10^6$。

Subtask4（$40$ points）：无特殊限制。

## 样例 #1

### 输入

```
3 5
aba
abaab```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
aba
ababa```

### 输出

```
2```

## 样例 #3

### 输入

```
3 5
aba
abbaa```

### 输出

```
Fake```

# 题解

## 作者：chayi (赞：16)

### 一些废话：

蒟蒻在练习字符串的时候看到的题，试了试用 KMP + DP 做，

然后 ~~竟然~~ AC 了。

好奇翻看了一下题解，发现 ~~好像~~ 没人写我这种做法，故写一下题解。


---
### 思路
本题要求我们将 $S$ 串分割成 **尽可能少的** $T$ 串的非空前缀。

显然，假如 $S$ 串可以由 $T$ 串的非空前缀组成，则 $S$ 串的前缀肯定可分成两部分：一部分由许多（假设已知） $T$ 串的非空前缀组成的部分，另一部分则是由一个 $T$ 串的非空前缀组成。


换言之，
**若 $S$ 串可以由 $T$ 串的非空前缀组成**，
则对于 $S[1, i]$ ，肯定存在断点 $1 \le j \le i$，满足
$$S[1, i] \leftarrow {S[1, j]}+T[1,k]$$
其中有， 
$$T[1, k] =S[j+1,i]$$

说人话就是，**串 $S[1, i]$ 的后缀一定是串 $T$ 的某个前缀。**

想到这里，我们就可以开始想 DP 的状态表示以及转移方程了。

### 解法
不妨设字符串的下标从 1 开始。

我们设 $dp[i]$ 表示串 $S[1, i]$ 最少能被分成多少个串 $T$ 的非空前缀。

显然有转移式（不知道为什么可以重新看看 **思路**）
$$dp[i] \leftarrow {\min{{(dp[j] + 1)}}}, S[j+1,i] = T[1,i-j]$$
重新看看 $S[j+1,i] = T[1,i-j]$ 这个式子，**这不就是 KMP 双串匹配的经典形式吗？**

因此我们可以先求出串 $T$ 的 $nxt$ 数组，然后再对 串 $S$ 和串 $T$ 跑一遍 KMP 双串匹配，一边跑，一边更新 $dp$ 数组即可。

答案是 $dp[m]$ 。

边界显然是 $dp[0] \leftarrow 0$，由于存在 No solution 的情况，所以得注意无法转移的情况。

以下是**代码时间**

```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cmath>
#include<cstring>
using namespace std;
//========================================

const int MAXN = 1e7 + 10;
char s[MAXN], t[MAXN];
int nxt[MAXN];
int dp[MAXN];

void getnxt(char *str, int n)
{
    for(int i = 2, j = 0; i <= n; i++)
    {
        while(j && str[i] != str[j + 1]) j = nxt[j];
        if(str[i] == str[j + 1]) j++;
        nxt[i] = j;
    }
}

int main(int argc, char const *argv[])
{
    clock_t c1 = clock();
#ifdef CHAYI
    freopen("in.in", "r", stdin);
    freopen("out.out", "w", stdout);
#endif
    //=========================================
    int n, m; scanf("%d%d", &n, &m);
    scanf("%s%s", t + 1, s + 1);
    getnxt(t, n); t[n + 1] = '#'; nxt[n + 1] = 1;
    for(int i = 0; i <= m; i++) dp[i] = 0x3f3f3f3f;
    int INF = dp[0]; dp[0] = 0;
    for(int i = 1, j = 0; i <= m; i++)
    {
        while(j && s[i] != t[j + 1]) j = nxt[j];
        if(s[i] == t[j + 1]) j++;
        dp[i] = min(dp[i], dp[i - j] + 1);
    }
    if(dp[m] < INF) printf("%d\n", dp[m]);
    else puts("Fake");
    //=========================================
#ifdef CHAYI
end:
    cerr << "Time Used:" << clock() - c1 << "ms" << endl;
#endif
    return 0;
}
```


---

## 作者：Terrific_Year (赞：14)

## 题意简述

给定两个字符串 $t,s$，将 $s$ 划分为 $n$ 个子串，使得每一个子串都是字符串 $t$ 的前缀（含 $t$）。

求满足条件时最小的 $n$，无满足的情况则输出`Fake`。

数据范围： $|t|,|s|\le 1\times10^7$。

## 思路分析

注：记字符串规模为 $n$。

考虑到字符串长度如此之大，我们需要一个 $O(n)$ 的算法，因为要求和前缀有着很强的关联性，我们不难想到 KMP 算法，如果没有了解过 KMP 算法，可以先尝试 [P3375 【模板】KMP](/problem/P3375)，关于该算法的详细分析，这里就不过多赘述了。

这是一个 KMP 模板的关键操作：

```cpp
//预处理next数组
for(int i=2,j=0; i<=lt; ++i) {
	while(j&&(t[i]!=t[j+1]))j=nxt[j];
	if(t[i]==t[j+1])++j;
	nxt[i]=j;
}
//进行匹配
for(int i=1,j=0; i<=ls; ++i) {
	while(j&&(j==lt||s[i]!=t[j+1]))j=nxt[j];
	if(s[i]==t[j+1])++j;
}
```

字符串 $s$ 每匹配成功一次，我们就得到了一个可划分出的子串，也就是说：只要每次尝试匹配后，匹配长度 $j$ 都不为 $0$，字符串 $s$ 就是可划分的，这样就解决了什么时候输出 `Fake` 的问题。

那么，怎样求最小划分呢？

其实，只需要尽可能利用已匹配的部分，只有当这次匹配的起点超过上次记录的终点位置时，才进行更新答案。因为当前匹配的终点只会往前推进，所以这样操作可以证明是正确的。

具体看代码：

```cpp
//匹配部分进行答案更新,x表示上次匹配的终点位置
for(int i=1,j=0,x=0; i<=ls; ++i) {
	while(j&&(j==lt||s[i]!=t[j+1]))j=nxt[j];
	if(s[i]==t[j+1])++j;
	if(j==0){//当匹配失败时，输出Fake
		puts("Fake");
		return 0;
	}
	if(i-j+1>x)++ans,x=i;//本次匹配的起点超过上次的终点时，更新答案和位置,i-j+1即为起点
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
int lt,ls,nxt[N],ans;
char t[N],s[N];
int main(){
	ios::sync_with_stdio(0);
	cin>>lt>>ls;
	cin>>t+1,cin>>s+1;
	for(int i=2,j=0;i<=lt;++i){
		while(j&&(t[i]!=t[j+1]))j=nxt[j];
		if(t[i]==t[j+1])++j;
		nxt[i]=j;
	}
	for(int i=1,j=0,x=0;i<=ls;++i){
		while(j&&(j==lt||s[i]!=t[j+1]))j=nxt[j];
		if(s[i]==t[j+1])++j;
		if(j==0)puts("Fake"),exit(0);
		if(i+1>j+x)++ans,x=i;
	}
	cout<<ans;
	return 0;
}
```

截止文章发布时，本题的题解和提交均没有在时间效率和空间消耗上更优的代码，因此写了这篇题解~~以增加 RP~~。

---

## 作者：Legitimity (赞：14)

场上的小丑做法不请自来。

开题：SAM 的萌萌题？这数据范围的不对劲啊。哦，Z 函数就能做了，我降智了。（此时还没意识到自己还是降智了）

------------

#### problem

给定字符串 $\texttt{S}$ 和 $\texttt{T}$，要求将 $\texttt{S}$ 划分成最少的段，且每段是 $\texttt{T}$ 的前缀。（$1\leq|\texttt{S}||\texttt{T}|\leq 10^7$）


------------


#### solution

正着不好做，考虑倒着 dp，$lim_i$ 表示 $\texttt{S}_{[i,n]}$ 与 $\texttt{T}$ 的最长公共前缀，设 $f_i$ 表示 $\texttt{S}_{[i,n]}$ 最少的划分，则转移方程为：$f_i=\min_{i<j\leq i+lim_i}\{f_j\}+1$。

$lim$ 可以用 Z-box 求，然后 $O(n^2)$ 和 $O(n\log n)$ 做法就显然了，但是这题要求线性。

分析一下，若：$i<i^{\prime}$ 且 $i+lim_i>i^{\prime}+lim_{i^{\prime}}$，那么从 $i^{\prime}$ 进行划分一定不优，这里的 $i^{\prime}$ 可以直接不用考虑。

把上述的位置扔掉后，$i+lim_i$ 就是单调的了，可以使用单调队列进行优化，时间复杂度 $O(n)$。

~~比 kmp 更优美。~~


------------


#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define ll long long
#define ull unsigned ll
#define inf 0x3f3f3f3f
#define djq 998244353
#define lowbit(x) (x&(-x))
inline void file(){
	freopen("baka.in","r",stdin);
	freopen("baka.out","w",stdout);
}
char buf[1<<21],*p1=buf,*p2=buf;
inline int getc(){
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	rg int ret=0,f=0;char ch=getc();
    while(!isdigit(ch)){if(ch==EOF)exit(0);if(ch=='-')f=1;ch=getc();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getc();}
    return f?-ret:ret;
}
int n,m,lim[10000005],z[10000005],f[10000005];;
char s[10000005],t[10000005];
int q[10000005],fr,re;
signed main(){
	//file();
	scanf("%d%d%s%s",&m,&n,t+1,s+1);
	z[1]=m;
	for(rg int i=2,l=0,r=0;i<=m;++i){
		if(i<=r) z[i]=min(r-i+1,z[i-l+1]);
		else z[i]=0;
		while(i+z[i]<=m&&t[1+z[i]]==t[i+z[i]]) ++z[i];
		if(r<i+z[i]-1) l=i,r=i+z[i]-1;
	}
	for(rg int i=1,l=0,r=0;i<=n;++i){
		if(i<=r) lim[i]=min(r-i+1,z[i-l+1]);
		else lim[i]=0;
		while(i+lim[i]<=n&&1+lim[i]<=m&&t[1+lim[i]]==s[i+lim[i]]) ++lim[i];
		if(r<i+lim[i]-1) l=i,r=i+lim[i]-1;
	}
	for(rg int i=1,j=0;i<=n;++i) j>i+lim[i]?lim[i]=inf:j=i+lim[i];
	memset(f,0x3f,sizeof(f));
	f[n+1]=0; q[fr=re=1]=n+1;
	for(rg int i=n;i>=1;--i){
		if(lim[i]==inf) continue;
		while(fr-1!=re&&q[fr]>i+lim[i]) ++fr; 
		const int j=q[fr];
		f[i]=f[j]+1;
		while(fr-1!=re&&f[q[re]]>=f[i]) --re;
		q[++re]=i;
	}
	if(f[1]>=0x3f3f3f3f) puts("Fake");
	else printf("%d",f[1]);
	return 0;
}
/*

*/
```


---

## 作者：XXh0919 (赞：11)

刚学 KMP，来道题练练手。

### 解法

注意到题目中有两种输出，我们便一个一个来解决。

首先解决输出 $\texttt{Fake}$ 的情况。我们知道，每一次字符串 $s$ 匹配成功时就一定能分出一个子串，那么此时对应的长度 $j$ 一定是大于 $0$ 的，换句话说，就是当 $j$ 为 $0$ 时，就表示 $s$ 失配了，那么就说明不能分出子串，直接输出 $\texttt{Fake}$。

然后就是正常输出的情况。我们可以记录每次匹配成功后的终点，如果在后面某个地方又发现匹配成功了，就说明又能分出一个子串，于是更新终点的位置并记录一下划分的个数，最后输出即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define pi pair<int,int>
#define mkp(a,b) make_pair((a),(b)) 
#define IOS ios::sync_with_stdio(0)
//奇特的码头
using namespace std;
const int N=2e7+15;

char s[N],p[N];
int n,m,ans;
int nxt[N];

signed main(){
	//IOS;
	cin>>n>>m;
	scanf("%s%s",p+1,s+1);
	int j=0;
	rep(i,2,n){
		while(j&&p[i]!=p[j+1])j=nxt[j];
		if(p[i]==p[j+1])++j;
		nxt[i]=j;
	}//预处理 nxt 数组（KMP 模板）
	j=0;
	int en=0;//结尾
	rep(i,1,m){
		while(j&&s[i]!=p[j+1])j=nxt[j];
		if(s[i]==p[j+1])++j;
		if(!j){
			cout<<"Fake"<<endl;
			return 0;
		}//失配，输出 Fake
		if(i-j+1>en){
			++ans;
			en=i;
		}//可划分
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：KemononeRou (赞：10)

赛时 $O(n\log{n})$ 过了 $10^7$，来水篇题解（

设 $g_i$ 代表字符串 $\texttt{S}$ 以 $i$ 为开头与 $\texttt{T}$ 匹配的最长长度，可以用 exkmp 求出。

考虑 dp，设 $f_i$ 表示以 $i$ 结尾的最少划分次数，每次用 $i$ 更新 $j\in\left[i+1,i+g_i-1\right]$。

~~这个 dp 可能可以用吉司机线段树优化，不知道过不过的去。~~

考虑将这个 dp 倒过来，设 $f_i$ 表示以 $i$ 开始的最少划分次数，每次用 $j\in\left[i+1,i+g_i-1\right]$ 更新 $i$。

这个 dp 可以用普通的线段树来优化，支持单点修改区间求 min 即可，用 zkw 能 900+ms 卡过去。

[Code](https://www.luogu.com.cn/paste/uqz0pd8c)

---

## 作者：Liveddd (赞：7)

不错的 **Z 函数**练习题。

很明显正着做不好搞，因为假如选取了当前某个前缀，很容易影响到后面的选取，并且不好优化。

经典**正难则反**的思想，考虑从后面逐渐选取模式串的前缀，这样就不会影响到前面前缀的选取（感性理解）。也就意味着，我们每次尝试选取一个文本串的一个**后缀**，使其等于模式串的**前缀**，然后进行下一步操作。

这是我们想到什么？ **Z 函数**不就是用来求出这东西的吗。考虑 **DP**，我们很容易写出状态转移方程：

$f_i=min_{i+1\le j\le i+p_i}{f[j]+1}$。

有了这个，直接暴力DP是 $\mathcal O(N^2)$ 的，显然可以用线段树来维护，但 $\mathcal O(N\log N)$ 复杂度仍不允许我们通过此题。

还能继续优化吗？注意到对于所以可以转移到的 $f_i$  一定是具有**单调性**，因为较短的后缀的代价一定不会大于较长的后缀的代价。而且根据 **Z 函数**的性质，对于所有可以转移到的 $i$，$i+p_i$ 明显是**单调递减**的。这瞬间就转化为经典模型了，我们很容易用**单调队列**来优化，于是复杂度就变为了优秀的 $\mathcal O(N)$。

因为 $f_i$ 具有**单调性**，每次我们直接将其加入队尾就可以了。然后注意一些细节就可以了。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e7+10,INF=1e9;
int n,m;
char a[N],b[N];
int z[N],p[N],f[N];
int l,r,q[N];
void Z(char *s,int n)
{
    z[1]=n;
    for(int i=2,l=0,r=0;i<=n;i++)
    {
        if(i<=r)z[i]=min(z[i-l+1],r-i+1);
        while(i+z[i]<=n&&s[i+z[i]]==s[z[i]+1])z[i]++;
        if(i+z[i]-1>r)l=i,r=i+z[i]-1;
    }
}
void exkmp(char *s,int n,char *t,int m)
{
    Z(t,m);
    for(int i=1,l=0,r=0;i<=n;i++)
    {
        if(i<=r)p[i]=min(z[i-l+1],r-i+1);
        while(i+p[i]<=n&&s[i+p[i]]==t[p[i]+1])p[i]++;
        if(i+p[i]-1>r)l=i,r=i+p[i]-1;
    }
}//Z函数模板
int main()
{
    scanf("%d %d %s %s",&m,&n,b+1,a+1);
    exkmp(a,n,b,m);
    for(int i=1,j=0;i<=n;i++)
        j>i+p[i]?p[i]=0:j=i+p[i];//注意处理不可能转移到的情况
    memset(f,0x3f,sizeof(f));
    f[q[l=r=1]=n+1]=0;
    for(int i=n;i;i--)
    {
        if(!p[i])continue;
        while(l<=r&&q[l]>i+p[i])l++;
        f[i]=f[q[l]]+1;
        // while(l<=r&&f[q[r]]>=f[i])r--;
        //这里直接入队就可以了
        q[++r]=i;
    }
    if(f[1]<=INF)printf("%d\n",f[1]);
    else puts("Fake");
    return 0;
}
```

希望没有误人子弟 qwq。

---

## 作者：YellowBean_Elsa (赞：6)

### 当你不会 KMP 及更高级的字符串算法时，看这里

设 $f(S)$ 表示将一个字符串 $S$ 表示成 $T$ 的前缀相连最少需要划分几段。

首先由一个平凡的贪心（引理），每个字符串拆成 $T$ 的前缀相连时，最后一个子串应该尽可能长。只要注意到当 $A$ 为 $B$ 的前缀时，必有 $f(A)<=f(B)$，再反证即得。

所以我们从前往后对题目所给 $S$ 的所有前缀求 $f$：首先处理出 $f=1$ 的前面一些前缀串，再从前往后用已经处理出 $f$ 的前缀串通过后面接上一段 $T$  的前缀，向后面未处理的转移；由引理每个前缀串 $S_i$ 第一次被转移到时，可以取到 $f(S_i)$ 的最小值。

如果用每个前缀 $S_i$ 向后转移时，都暴力加每个 $T$ 的前缀，是 $O(n^2)$ 的。

##### 优化

我们发现每次转移完后，当前已经处理好的位置必然是最前面连续一段（即已算出 $S$ 最前面几个前缀串的 $f$），所以用一个指标 $pos$ 指示当前已经处理到哪个位置，下次直接从 $pos+1$ 开始进行转移即可。由于整个过程 $pos$ 从 $1$ 变到 $n$，复杂度为 $O(n)$

##### 问题来了

如何判断 $pos+1$ 位置能否成功转移？也就是说，判断 $S$ 的从“当前正在向后转移的 $S$ 前缀”的下一位到 $pos+1$ 位置这段子串是否为 $T$ 的前缀？

**不会 KMP 时，我们要想到字符串 Hash！**

Hash见代码

如果 $pos+1$ 位可以转移，之后的位置判断能否转移时只需将该位置和 $T$ 的对应位置比较即可。

那整个过程就梳理完了。

```cpp
//coder: YB-Elsa of Ahtohallan
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; --i)
using namespace std;
typedef long long ll;
const int N=1e7+10;
const int base=131;
const int mod=19491001;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}int n,m;
string s,t;
int dp[N],pt,pos;
int hs1[N],hs2[N],p[N];
void init1(){//注意S和T要分开Hash 
    p[0]=1;
    fu(i,1,N-5)p[i]=1LL*p[i-1]*base%mod;
    fu(i,1,m)hs1[i]=(1LL*hs1[i-1]*base%mod+(s[i-1]-'a'))%mod;
}void init2(){
    fu(i,1,n)hs2[i]=(1LL*hs2[i-1]*base%mod+(t[i-1]-'a'))%mod;
}
inline int get1(int l,int r){
    return ((hs1[r]-1LL*hs1[l-1]*p[r-l+1]%mod)%mod+mod)%mod;
}inline int get2(int l,int r){
    return ((hs2[r]-1LL*hs2[l-1]*p[r-l+1]%mod)%mod+mod)%mod;//Beware！可能是负数取模！要转为正数判断！ 
}
signed main(){
//	freopen("frozen.in","r",stdin);
	n=read(),m=read();
	cin>>t>>s;
	init1();init2();
	memset(dp,0x7f,sizeof(dp));
	fu(i,0,m-1){//处理最前面的位置 
		pos=i;
		if(pt==n)break;
		if(s[i]==t[pt]){
			dp[i]=1;
			pt++;
		}else break;
	}
	fu(i,0,m-1){
	//	cout<<i<<' '<<dp[i]<<endl;
		if(pos>=m || pos-i>n || dp[i]==dp[m])continue;
		if(get1(i+2,pos+1)!=get2(1,pos-i))continue;//判断第 pos+1 位能否转移 
		pt=pos-i-1;//指示对应 T 的哪一位 
		fu(j,pos-i,m-1-i){
			pos=i+j;
			if(pt>=n || s[i+j]!=t[pt])break;
			if(dp[i+j]==dp[m])dp[i+j]=dp[i]+1;
			pt++;
		}
	}if(dp[m-1]==dp[m])puts("Fake");//无解 
	else printf("%d\n",dp[m-1]);
    return 0;
}
```



---

## 作者：Superiority (赞：6)

# 思路

思维难度还是比较高的，我们可以尝试使用 KMP 再加上少许贪心思想来进行求解，不会 KMP 的同学看[这里](https://oi.wiki/string/kmp/)。

首先我们要很深刻理解 KMP，$next_i$ 代表 $1\sim i$ 中最长重复的前缀和后缀，而题目要求我们求字符串 $S$ 中最少需要被分成多少部分，并且每一部分都为 $T$ 的前缀。

我们思考如何匹配，这时候只要一点贪心思想就可以了。我们定义 $P$ 为前一个部分的终点，如果 $i-j+1$ 也就是如果左端点大于前一个部分终点了，也就是出现了一个新的部分，我们用 $ans$ 记录下来，最后就是总共最少划分的部分，并将这时候的 $P$ 赋值为此时的终点 $i$。

接下来就是不成立的情况，如果这个 $S$ 的某个部分不属于 $T$ 的前缀，这时候 $j$ 会等于 $0$，因为 $next$ 会不断向前找前缀，直到 $j = 0$ 或者满足条件的时候才会停止，如果没有就会一直搜到 $0$，只要在中间过程里判断一下 $j$ 是否等于 $0$ 就可以了。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;//by cqbzbbd
#define zjj long long
const int MAXN=1e7+5;
int n,m;
int idx;
string x,y;
int nxt[MAXN];
int ans,p;
void KMP(){
	nxt[1]=0;
	for(int i=2;i<=n;i++){
		while(idx&&x[i]!=x[idx+1]) idx=nxt[idx];
		if(x[idx+1]==x[i]) idx++;
		nxt[i]=idx;
	}
}
int main(){
	cin>>n>>m;
	cin>>x>>y;
	x=" "+x;
	y=" "+y;
	KMP();
	idx=0;
	for(int i=1;i<=m;i++){
		while(idx&&y[i]!=x[idx+1]) idx=nxt[idx];
		if(y[i]==x[idx+1]) idx++;
		if(idx==0){
			cout<<"Fake"<<endl;
			return 0;
		}
		if(i-idx+1>p){
			p=i;
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：w9095 (赞：3)

[P8112 [Cnoi2021]符文破译](https://www.luogu.com.cn/problem/P8112)

借用 KMP 思想优化的动态规划。

首先，用 $dp[i]$ 表示把前 $i$ 位的字符完全匹配需要的最少词缀数（下标均从 $1$ 开始）。那么，我们可以从点 $i+1$ 开始，向后逐位与字符串 $T$ 比较。设此时匹配到了 $T$ 中的第 $j$ 位，如果相等，则易得转移方程： 

$$dp[i+j]=\min(dp[i+j],dp[i]+1)$$

如果不相等或到达了字符串 $T$ 末尾，则证明在此之后不会更长的有魔法词缀，可以结束这一次匹配，令 $i=i+1$ 计算下一位即可。

很明显，这个算法的时间复杂度是 $O(|S||T|)$ 的，当数据范围达到 $|S|,|T|\le10^6$ 时，算法必然超时。

考虑优化这个算法，我们知道，如果不相等或到达了字符串 $T$ 末尾，失配后是可以直接跳过一部分不可能产生新的解的数据。这样就自然而然地想到了用这个思想把单模字符串匹配优化到 $O(|S|+|T|)$ 的 KMP 算法。

借助 KMP 的思想，首先求出字符串 $T$ 的 $next$ 数组，然后开始按照 KMP 的方式匹配：（设此时文本串匹配到第 $i$ 项，模式串匹配到第 $j$ 项）

设置一个名为 $now$ 的临时变量，用于存储如果匹配的最少词缀数。

可以直接逐位比较。如果相等，则按照 KMP 思想，将模式串和文本串指针一起后移，令 $dp[i]=now$ 后比较下一位。

如果不相等，可以令 $j=next[j]$ 之后重新计算 $now$ 的值。因为一旦匹配失败，只能再次选择一个词缀。每次 KMP 算法在匹配失败后，会利用最长公共前后缀的性质使得文本串指针 $i$ 不往前跳。而每次利用最长公共前后缀的性质，会改变模式串匹配的起始位置，所以需要重新计算 $now$ 的值。可以直接用 $dp[i-j]$ 计算出模式串匹配的起始位置的前一个位置，把 $now$ 的值更新为 $dp[i-j]+1$ 以保证正确性。模式串匹配到末尾也是同理。

DP 边界：$dp[0]=1$。 

DP 目标：$dp[|S|]$。

时间复杂度：$O(|S|+|T|)$。

注意，由于有无解的情况，所以当 $next$ 数组跳到 $-1$ 时，应该直接判定无解并输出 `Fake`。因为如果 $next$ 数组跳到 $-1$ 证明匹配第一个字符就失配了，此时后面没有办法再进行匹配，无解。

完整代码：（由于代码中的字符串下标是从 $0$ 开始的，所以可能会和上文的讲解有些出入）

```cpp
#include <bits/stdc++.h>
using namespace std;
int lt,ls,next1[10000010],f[10000010];
char t[10000010],s[10000010]; 
void get_next(char t[],int next[])
{
	int i=0,j=-1;
	next[0]=-1;
	while(i<lt)
	   {
	   	if(j==-1||t[i]==t[j])i++,j++,next[i]=j;
	   	else j=next[j];
	   }
}

bool kmp(char s[],char t[],int next[])
{
	int i=0,j=0,now=1;
	f[0]=1;
	while(i<ls)
	   {
	   	if(j==-1)return 0;
	   	if(s[i]==t[j])i++,j++,f[i]=now;
	   	else j=next[j],now=f[i-j]+1;
	   	if(j==lt)now=f[i-j]+1,j=next[j];
	   }
	return 1;
}

int main()
{
	scanf("%d%d%s%s",&lt,&ls,t,s);
	get_next(t,next1);
	if(!kmp(s,t,next1))printf("Fake");
	else printf("%d",f[ls]);
    return 0;
}

```

[AC记录](https://www.luogu.com.cn/record/105966531)

---

## 作者：Loser_Syx (赞：2)

考虑 kmp 做法。

我们先跑一遍 kmp 然后在匹配过程中找到最长的 border $j$ 进行 dp，则有转移方程式 $dp_i = dp_{i-j}+1$。

其实这个是看上去很假的做法，和贪心差不多，**但是它是正确的**。

问了一下 myee 带神，得到的结论是 $dp_i$ 一定是单调的，我们来感性理解一下。

对于拼接成 $S$ 的每个字符串而言，他们一定是 $T$ 的**前缀**，那么我们在当前 $S_i$，对于一个 border $j$，一定从 $S_{i-j+1}$ 开始的这个前缀被之前某一个 $k$ 给用了，而如果我 $i$ 要接在 $k$ 后面一定不优，而 $i$ 接在 $i-j$ 后面一定更优。

显然替换的都是前缀，换一个更长且更少的何乐而不为呢？

```cpp
const int N = 1e7 + 19;
int n, m, dp[N], nxt[N];
string a, b;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> m >> n >> b >> a;
	a = " " + a; b = " " + b + ".";
	for (int i = 2, j = 0; i <= m; ++i) {
		while (j && b[i] != b[j + 1]) j = nxt[j];
		if (b[i] == b[j+1]) ++j;
		nxt[i] = j;
	} memset(dp, 0x3f, sizeof dp);
	dp[0] = 0;
	for (int i = 1, j = 0; i <= n; ++i) {
		while (j && a[i] != b[j + 1]) j = nxt[j];
		if (a[i] == b[j+1]) ++j;
		smin(dp[i], dp[i - j] + 1);
	} if (dp[n] > 1e9) puts("Fake");
	else write(dp[n]);
	return 0;
}
```

---

## 作者：MrSWdAxiv (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8112)

[更好的阅读体验](https://www.cnblogs.com/MithrilSwordXIV/p/17976794)

[双倍经验](https://www.luogu.com.cn/problem/AT_abc257_g)

## 思路

先看数据范围，我们发现两个字符串的长度最大会达到 $5 \times 10^7$。 ~~这立刻打消了我用暴力的想法。~~

于是，我选择了用 KMP 模式匹配，这一个能够在线性时间内判定字符串 $A$ 是否是字符串 $B$ 的字串，并求出字符串 $A$ 在字符串 $B$ 中各次出现的位置。

如果不清楚 KMP 算法是如何实现的，可以看看[这个](https://oi-wiki.org//string/kmp/)或[这个](https://www.cnblogs.com/MithrilSwordXIV/p/17976737)。

我们知道一个字符串 $A$ 每次往后成功匹配一次，匹配长度就会改变成一个不为 $0$ 的数，而如果没有匹配成功，则会重新从头开始匹配，匹配长度为 $0$。

由此当匹配长度 $j$ 为 $0$ 时，无解输出 `Fake`。

我们也知道每次匹配成功都是 $A\left[i - j + 1 \sim i\right] = A\left[1 \sim j\right]$，所以当每次 $i - j + 1$ 这一个起始点超过了上一次的终止点 $i$ 时，就可以让划分的段数变小，更新答案。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 50000005
using namespace std;
int nxt[MAX],lens,lent,ans,tmp;
string s,t;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>lens>>lent>>s>>t;
    s=" "+s;
    t=" "+t;
    for(int i=2,j=0;i<=lens;i++){
        while(j&&s[i]!=s[j+1])j=nxt[j];
        if(s[i]==s[j+1])j++;
        nxt[i]=j;
    }
    for(int i=1,j=0;i<=lent;i++){
        while(j&&(j==lens||t[i]!=s[j+1]))j=nxt[j];
        if(t[i]==s[j+1])j++;
        if(j==0){
            cout<<"Fake\n";
            exit(0);
        }
        if(i-j+1>tmp){//更新答案
            ans++,tmp=i;
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```


---

## 作者：SkyLines (赞：1)

## Solution

在 KMP 中，每次循环 $S$ 中的第 $i$ 个时，会找到与此字符串相等的 $T$ 中的前 $j$ 个，则此字符串的起点为 $i-j+1$，终点为 $i$，如果此字符串的起点 $i-j+1$ 比前一个字符串的终点 $p$ 大，则不能与前一个字符串合并，另外划分一段。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5;
string s1, s2;
int n, m, j, nxt[N], ans, p = -1;
int main(){
	scanf("%d %d", &m, &n);
	cin >> s2 >> s1;
	s1 = " " + s1;
	s2 = " " + s2;
	j = 0;
	nxt[1] = 0;
	for(int i = 2; i <= m; i++){
		while(j && s2[i] != s2[j + 1]) j = nxt[j];
		if(s2[i] == s2[j + 1]) j++;
		nxt[i] = j;
	}
	j = 0;
	p = -1e9;
	for(int i = 1; i <= n; i++){
		while(j && s1[i] != s2[j + 1]) j = nxt[j];
		if(s1[i] == s2[j + 1]) j++;
		if(j == 0){
			printf("Fake");
			return 0;
		}
		if(i - j + 1 > p){
			ans++;
			p = i;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：ZBH_123 (赞：1)

## 题目分析

显然，本题需要使用 KMP 进行字符串匹配。并且，因为本题要求最小的划分段数，所以考虑使用贪心，即当出现新的一段时，增加段数的答案。我们定义 $p$ 为上一段的终点，当 $S_i$ 与 $T_j$ 匹配时，如果 $i-j+1>p$，即 $i$ 这一段的起点超过了 $p$。这时就是出现了新的一段，将 $p$ 设为 $i$。接下来就是无解的情况。根据 KMP 的思想，当 $S_i$ 与 $T_j$ 不匹配时，会一直向前找 $next_j$，直到 $j=0$。因此，当 $j=0$ 时就是无解。

## 示例代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;

const int maxn=1e7;
int n,m,nxt[maxn+5];
char s[maxn+5],t[maxn+5];

void getnxt(){
	nxt[1]=0;
	int j=0;
	for(int i=2;i<=n;i++){
		while(j&&s[i]!=s[j+1]) j=nxt[j];
		if(s[i]==s[j+1]) j++;
		nxt[i]=j;
	}
}

void solve(){
	cin>>n>>m>>(s+1)>>(t+1);
	
	getnxt();
	int p=0,j=0,ans=0;
	for(int i=1;i<=m;i++){
		while(j&&t[i]!=s[j+1]) j=nxt[j];
		if(t[i]==s[j+1]) j++;
		if(!j){
			cout<<"Fake\n";
			return;
		}
		if(i-j+1>p)
			p=i,ans++;
	}
	
	cout<<ans<<'\n';
}

int main(){
	int T=1;
//	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：Frictional (赞：0)

一开始想从前向后做，发现好像贪心没有正确性（或许是我太菜了，没想到更好的贪心方法）。

遂考虑从后向前做，我们发现如果 $S$ 从后向前有一个后缀向前扩一个后仍然是 $T$ 的前缀，那么就向前扩是更优的，且不会影响无解的情况。因为如果本来不扩是有解的，那扩完后，前面一个 $T$ 的前缀仍然是 $T$ 的前缀。这样我们就要求出来对于 $S$ 的每一个前缀的最长与 $T$ 的前缀相同的后缀。那这不就成了 KMP 的板子了。求出这个后就每次减掉一个满足条件的 $S$ 的最长后缀，至于无解不就是对于当前的 $S$，不存在一个后缀等于 $T$ 的某个前缀。

## Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define db double
#define U unsigned
#define int long long
#define P pair<int,int>
#define pb push_back
#define MP make_pair
#define all(x) x.begin(),x.end()
#define CLR(i,a) memset(i,a,sizeof(i))
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define ROF(i,a,b) for(int i=a;i>=b;--i)
#define debug(x) cerr<<#x<<'='<<x<<endl
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define pcn putchar('\n')
#define pcs putchar(' ');
#define pc putchar
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define ClockB clock_t start,end; start = clock();
#define ClockE end = clock(); cerr<<"time = "<<double(end-start)/CLOCKS_PER_SEC<<"s"<<endl;
using namespace std;
int _=1;
inline int rd(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
inline void wr(int x){
    if(x<0) pc('-'),x=(~x)+1;
    if(x>9) wr(x/10);
    pc((x%10)^48);
}
int lens,lent;
const int N=1e7+3;
char t[N],s[N];
int nex[N*2];
int cnt;
char tmp[N*2];
int ans[N*2];
signed main(){
    // _=rd();
    while(_--){
        lent=rd(),lens=rd();
        scanf("%s",t+1);scanf("%s",s+1);
        FOR(i,1,lent) tmp[i]=t[i];
        FOR(i,lent+1,lent+lens) tmp[i]=s[i-lent];
        int j=0;
        nex[1]=0;
        FOR(i,2,lent){
            while(j&&t[i]!=t[j+1]) j=nex[j];
            if(t[i]==t[j+1]) j++;
            nex[i]=j;
        }
        j=0;
        FOR(i,1,lens){
            while(j&&s[i]!=t[j+1]) j=nex[j];
            if(s[i]==t[j+1]) j++;
            ans[i]=j;
        }
        while(lens>0){
            if(!ans[lens]){
                cout<<"Fake";
                return 0;
            }
            lens-=ans[lens];
            cnt++;
        }
        cout<<cnt;
    }
    return 0;
}
```

---


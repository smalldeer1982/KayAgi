# 「Stoi2033」园游会

## 题目背景

> 我顶着大太阳 只想为你撑伞  
> 你靠在我肩膀 深呼吸怕遗忘  
> 因为捞鱼的蠢游戏我们开始交谈  
> 多希望话题不断园游会永不打烊  
> 气球在我手上 我牵着你瞎逛  
> 有话想对你讲 你眼睛却装忙  
> 鸡蛋糕跟你嘴角果酱我都想要尝  
> 园游会影片在播放 这个世界约好一起逛  
> ——《园游会》

## 题目描述

设 $F(x)=(x+1)\bmod 3-1$，给定 $n$，求：

$$\sum_{l=0}^n \sum_{r=l}^n F\left(C_{r}^{l}\right)$$

对 $1732073999$ 取模。其中 $C_{r}^{l}$ 为组合数，具体地，

$$C_{r}^{l}=\dfrac{r!}{l!(r-l)!}$$

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

| Subtask | 分值 | $1\le t \le$ | $1\le n \le maxn \le$ |
| :-: | :-: | :-: | :-: |
| $1$ | $16$ | $1$ | $300$ |
| $2$ | $37$ | $300$ | $7 \times 10^6$ |
| $3$ | $47$ | $3 \times 10^4$ | $2 \times 10^{16}$ |

对于 $100\%$ 的数据，$1 \le t \le 3 \times 10^4,1 \le n \le maxn \le 2 \times 10^{16}$。

## 样例 #1

### 输入

```
4 173
1
5
20
34```

### 输出

```
3
12
52
94```

# 题解

## 作者：Untitled_unrevised (赞：12)

## 概述

本文介绍对于题目 [P7976「Stoi2033」园游会](https://www.luogu.com.cn/problem/P7976) 在现在的计算模型下，一种单次询问时间复杂度 $O(\log n)$，空间复杂度 $O(1)$ 的算法。

## 题意简述

定义函数 $\chi(n)$ 为：

$$
\chi(n) = \begin{cases}
0 & n \equiv 0 \pmod 3 \\
1 & n \equiv 1 \pmod 3 \\
-1 & n \equiv 2 \pmod 3
\end{cases}
$$

$t$ 次询问，每次给定一个 $n \le 2 \times 10^{16}$，计算下列式子：

$$
G(n) = \Bigg[\sum_{k = 0}^{n}\sum_{m = k}^{n}\chi\big(\mathrm C_{m}^{k}\big)\Bigg] \bmod 1732073999
$$

其中 $\mathrm C_{m}^{k} = \dbinom{m}{k} = \dfrac{m!}{k!(m-k)!}$ 表示组合数。

也就是计算杨辉三角前 $n+1$ 行所有系数通过 $\chi$ 函数映射后的和，结果对 $1732073999$ 取模。

## 解法

任何时候先通过实例来分析总是有益无害的。首先考虑杨辉三角各系数通过 $\chi$ 函数映射后的结果（$0 \le n < 27$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6rqrv6f8.png)

其中 `Z` 表示 $-1$，`.` 表示 $0$。

可以发现，该系数分布具有某种分形对称性。具体地，如果已经构造出了 $3^p$ 行的三角，则将该三角形复制后放在新三角形的顶角、左上边、左下角、右上边、右下角后，再取一个系数 $\times (-1)$ 的三角放在底边的位置，其余系数填 $0$，即可得到 $3^{p+1}$ 行的三角。

因此，当 $n = 3^{p}$ 时，$G(n) = (5 - 1)G(n / 3) = 4^{p}$。记住这个结论，后面要用。

现在考虑如何用这个特性快速计算 $G(n)$。

对于 $3^p < n \le 3^{p+1}$，分两种情况讨论：

1. $3^p < n \le 2 \times 3^{p}$：代表 $n$ 的取值碰到左上边和右上边的三角形，但没有碰到左下角、右下角和底边的三角形；

顶角的三角形各系数之和为 $4^p$，左上边和右上边的三角形系数之和为 $2G(n \bmod 3^p)$，合计 $4^p + 2G(n \bmod 3^p)$，问题转化为计算 $G(n \bmod 3^p)$。

2. $2 \times 3^p < n \le 3^{p + 1}$：代表 $n$ 的取值碰到左下角、右下角和底边的三角形；

顶角的三角形各系数之和为 $4^p$，左上边和右上边的三角形系数之和为 $2 \times 4^p$，左下角、右下角和底边的三角形系数之和为 $G(n \bmod 3^p)$（别忘了底边的系数乘过 $-1$），合计 $3 \times 4^p + G(n \bmod 3^p)$，问题转化为计算 $G(n \bmod 3^p)$。

递归终点是 $n = 0$，此时 $G(n) = 1$。

将上述算法由递归转递推，从低到高枚举 $n$ 的三进制位，如果为 $1$ 则对应第 1 种情况，如果为 $2$ 则对应第 2 种情况，直接更新答案即可；如果为 $0$ 则什么也不做。

此时一步递推的时间复杂度和空间复杂度皆为 $O(1)$，枚举所有三进制位总计时间复杂度 $O(\log n)$。

参考代码：

```cpp
#include <iostream>

typedef unsigned long long u64;

const u64 P = 1732073999;
const u64 pRes[36] = {
	1, 4, 16, 64, 256, 1024,
	4096, 16384, 65536, 262144, 1048576, 4194304,
	16777216, 67108864, 268435456, 1073741824, 830819298, 1591203193,
	1168590775, 1210215102, 1376712410, 310627643, 1242510572, 1505894290,
	827355163, 1577346653, 1113164615, 988510462, 489893850, 227501401,
	910005604, 175874418, 703497672, 1081916689, 863518758, 1722001033
};

inline void call() {
	u64 n, p = 0, res = 1;
	std::cin >> n;
	for(; n; n /= 3, ++p) {
		switch(n % 3) {
			case 0: {
				break;
			}
			case 1: {
				res = (pRes[p] + 2 * res) % P;
				break;
			}
			case 2: {
				res = (3 * pRes[p] + res) % P;
				break;
			}
		}
	}
	std::cout << res << std::endl;
}

int main() {

	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	u64 T, maxn;
	std::cin >> T >> maxn;
	while(T--) call();

	return 0;

}
```

---

## 作者：VinstaG173 (赞：9)

首先容易发现这就是对杨辉三角（进行 $F(\cdot)$ 运算后）的前 $n$ 行求和。

$16$ 分的部分分直接 $O(n^2)$ 暴力计算就可以了。

由于 $53$ 分是正解的不够优秀的实现，因此直接讲正解。看到数据范围很大，尝试打表找规律。

打出来表后尝试几种方法求和。我的做法是对每行依次求和，会发现行和都是 $2$ 的幂。于是猜测规律在这个幂次上，并考虑合并相同的幂，于是只需要求出 $2^k$ 的个数就可以了。

由于 $F$ 是模 $3$，考虑三进制。表示完之后会发现一件事情：若第 $n$ 行的答案为 $2^k$，则 $k$ 是 $n$ 的三进制表示中 $1$ 的个数。

然后就是计数型数位 dp，设 $f_{i,j}$ 表示 $[0,3^i)$ 之中三进制有 $j$ 个 $1$ 的数个数（代码中的 `num` 数组），显然可以 $O(\log^2{n})$ 预处理（$i,j=O(\log{n})$）。

计算 $n$ 的答案时，考虑拆三进制位处理。首先记 $res_i$ 为 $[0,n)$ 中三进制有 $i$ 个 $1$ 的数个数。设 $n=3^ki+n'$，其中 $0 \le n'<3^k,i \in \{1,2\}$，则我们需要处理的是 $i$ 个末 $k$ 位取遍 $[0,3^k)$ 的整段的一个末 $k$ 位为 $[0,n')$ 的段的贡献。因此我们只需作一些整段的处理后将 $n$ 变为 $n'$ 继续处理。但是变为 $n'$ 时我们需要注意更高位的 $1$ 带来的影响，所以需要记录一个值 $vl$ 表示更高位中 $1$ 的个数。下面对 $i$ 的值分情况讨论。

$i=1$：我们需要计算 $[0,3^k)$ 对答案的贡献，即

$$res_{i+vl} \leftarrow res_{i+vl}+f_{k,i}$$

这是因为更高位贡献了 $vl$ 个 $1$。接下来，这一位会给后面的低位贡献一个高位的 $1$，因此需要 `++vl`。

$i=2$：我们先像上面一样计算 $[0,3^k)$ 对答案的贡献，接着需要计算 $[3^k,2 \times 3^k)$ 对答案的贡献，即

$$res_{i+vl+1} \leftarrow res_{i+vl+1}+f_{k,i}$$

这是因为当前处理的这段区间的首位上有一个 $1$。这一位不会给后面的低位贡献高位 $1$，故 $vl$ 不变。

容易发现上面的过程是 $O(\log^2{n})$ 的，故总时间复杂度为 $O(t\log^2{n})$。

$53$ 分部分分就是直接把上面的东西随便怎么处理一下就可以了。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
const int ntf=1732073999;
ll pw3[37];
inline int getb(ll x)
{
	int bt=int(log(x+0.9)/log(3));
	if((bt==30&&x>=pw3[31])||(bt==33&&x>=pw3[34]))++bt;
	if((bt==32&&x<pw3[32])||(bt==33&&x<pw3[33])||(bt==35&&x<pw3[35]))--bt;
	return bt;
}
ll num[37][37];
ll res[37],sum;
inline void solve(ll x)
{
	int tg=0,vl=0;
	while(x)
	{
		int bt=getb(x);x-=pw3[bt];
		for(rg int i=0;i<=bt;++i)res[i+tg+vl]=(res[i+tg+vl]+num[bt][i])%ntf;
		(x>=pw3[bt])?(tg=1):((tg)?(tg=0):(++vl));
	}
}
int t,b;
ll n,mxn;
int main()
{
	scanf(" %d %lld",&t,&mxn);
	num[0][0]=1,pw3[0]=1;
	while(pw3[b]<=mxn)
	{
		num[++b][0]=(1ll<<b)%ntf,pw3[b]=pw3[b-1]*3;
		for(rg int i=1;i<=b;++i)num[b][i]=((num[b-1][i]<<1)+num[b-1][i-1])%ntf;
	}
	while(t--)
	{
		scanf(" %lld",&n),sum=0;
		for(rg int i=0;i<=b;++i)res[i]=0;solve(n+1);
		for(rg int i=0;i<=b;++i)sum=(sum+(1ll<<i)%ntf*res[i])%ntf;
		printf("%lld\n",sum);
	}
	return 0;
}
```

补个结论的证明。

用 Lucas 定理，设 $n$ 表示成三进制数后有 $a_0$ 位为 $0$，$a_1$ 位为 $1$，$a_2$ 位为 $2$。对于某个 $m$，若 $m$ 的某一位上数值比 $n$ 对应位大，由 Lucas 定理知 $3 \mid \binom{n}{m}$。否则，$n$ 为 $0$ 的位置上 $m$ 只能为 $0$，对余数的贡献为 $1$。$n$ 为 $1$ 的位置上 $m$ 可能为 $0,1$，对余数的贡献均为 $1$，故对总和的贡献为 $2$。$n$ 为 $2$ 的位置上 $m$ 可能为 $0,1,2$，对余数的贡献分别为 $1,-1,1$，故对总和的贡献为 $1$。由乘法原理，$n$ 对总和的贡献即为 $2^{a_1}$。

---

## 作者：DengDuck (赞：5)

感觉这题还是反映出自己思维方面很多短板的。

这题是一个 Trick 集大成者。

首先映入眼帘的模数 $3$ 告诉我们值域很小，这种题可以考虑拆，对于每一种可能的数值分别求解方案数，此乃第一 Trick。

一个组合数处理之后可能的数值是：$-1,0,1$。

分别对应的原来的组合数的数值是：$2,0,1$。

那么根据这个神秘关系变换一下，式子变成这么一个东西：

$$
\sum_{l=0}^n\sum_{r=l}^n [(C_r^l\bmod 3)=1]-[(C_r^l\bmod 3)=2]
$$

这时候似乎没啥头绪，看着这个神秘的组合数非常让人恼火。

唉？小模数，组合数，这个组合就像红色电音极地大冲击的主打 DJ RoySten 和 Bobo 一样，搭配来势汹汹的 Lucas 定理可以情不自禁 High 起来，飞起来。

所以我们利用 Lucas 把 $l,r$ 变成三进制位一一配对，求解组合数再乘起来的关系，此乃第二 Trick。

然后我们发现不关心 $C_r^l=0$ 的情况，所以我们希望 $l,r$ 三进制下每一位都有 $l$ 的这一位不大于 $r$ 的这一位。

否则除了 $C_2^1=2$ 之外，其他所有的 $C_r^l=1$。

因此我们关心的就是 $C_2^1$ 的数量。

你发现这里要是拿已知的 $l,r$ 去推规律那确实没啥规律，考虑对于一个已知的 $r$ 求所有的 $l$ 对应的结果的和。

那么剩下的 $\text{kernel\_panic}$ 写得很详细了，写出式子之后一减，然后二项式反演，你就可以得到的一个很酷炫的结论。

假设你的 $r$ 三进制下 $1$ 的个数为 $x$，则这个 $r$ 的贡献就为 $2^x$。

然后你就可以考虑数位 DP 了，由于你看的是有几位是 $1$，所以位数这个值域也是很小的。

所以......

我们致敬第一个 Trick，枚举在数字中 $1$ 的个数，然后统计符合这个条件的数字的数量即可。

剩下的就很典了。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
//#define fir first
//#define sec second
using namespace std;
//const LL inf;
const LL N=60;
//const LL M;
const LL mod=1732073999;
//const LF eps;
//const LL P;
LL T,MX,n,b[N],tot,f[N+5][N+5][2],pw[N];
LL dfs(LL x,LL sum,LL lim)
{
	if(sum<0)return 0;
	if(x==0)return sum==0;
	if(f[x][sum][lim]!=-1)return f[x][sum][lim];
	LL ans=0;
	for(LL i=0;i<3;i++)
	{
		if(lim&&i>b[x])break;
		ans=(ans+dfs(x-1,sum-(i==1),lim&&(i==b[x])));
	}
	return f[x][sum][lim]=ans%mod;
}
LL work(LL x)
{
	tot=0;
	LL ans=0;
	memset(f,-1,sizeof(f));
	while(x)
	{
		b[++tot]=x%3,x/=3;
	}
	for(int i=0;i<=tot;i++)
	{
		ans=(ans+dfs(tot,i,1)*pw[i]%mod)%mod;
	}
	return ans;
}
int main()
{
	pw[0]=1;
	for(int i=1;i<=N;i++)pw[i]=pw[i-1]*2%mod;
	scanf("%lld%lld",&T,&MX);
	while(T--)
	{
		scanf("%lld",&n);
		printf("%lld\n",work(n));
	}
	return 0;
}
//RP++
```

---

## 作者：kernel_panic (赞：5)

## 思路

先证明一下打表找出的规律．

> 引理：记 $i$ 的三进制表达中 $1$ 的个数为 $\mathrm{ct}$，有
>
> $$\sum_{j} \left(\binom{i}{j} + 1\right) \bmod 3 - 1 = 2^\mathrm{ct}$$

在我校 MO 爷的帮助下给出的证明：

设满足 $\binom{n}{m} \equiv 1 \pmod 3$ 的 $m$ 有 $a$ 个，满足 $\binom{n}{m} \equiv 2 \pmod 3$ 的 $m$ 有 $b$ 个，即证明 $a - b = 2^\mathrm{ct}$．

考虑对 $\binom{n}{m} \bmod 3$ 应用 Lucas 定理，设 $n, m$ 的三进制表达分别为 $(n_1 n_2 \cdots n_p)_3, (m_1 m_2 \cdots m_p)_3$，有 $\binom{n}{m} \equiv \prod_i \binom{n_i}{m_i} \pmod 3$．记 $r, s, t$ 分别为 $n_i$ 等于 $0, 1, 2$ 时 $i$ 构成的集合．

考虑计算 $a$．要使 $\binom{n}{m} \equiv 1 \pmod 3$，$m$ 需要满足下列条件：

- 由于 $r, s$ 中的位对乘积的贡献只能为 $1$，那么有 $\forall i \in r, m_i = 0$，$\forall i \in s, m_i \in \{0, 1\}$．
- 由于 $2^k \equiv 1 \pmod 3 \iff 2 \mid k$，有 $\sum\limits_{i \in t} [m_i = 1]$ 是偶数．

枚举有多少 $i \in t$ 使得 $m_i = 1$，有

$$
a = 2^{|s|} \sum_{k = 0}^{|t|} [2 \mid k] \binom{|t|}{k} 2^{|t| - k}
$$

同理可得

$$
b = 2^{|s|} \sum_{k = 0}^{|t|} [2 \nmid k] \binom{|t|}{k} 2^{|t| - k}
$$

那么有

$$
a - b = 2^{|s|} \sum_{k = 0}^{|t|} \binom{|t|}{k} (-1)^k 2^{|t| - k}
$$

这不是我们二项式定理的题目吗！于是有

$$
a - b = 2^{|s|} (2 - 1)^{|t|} = 2^{|s|} = 2^\mathrm{ct}
$$

得证．

然后就可以枚举 $\mathrm{ct}$，数位 DP 计算 $\le n$ 的数中有几个满足三进制表达中 $1$ 的个数为 $\mathrm{ct}$．

## 代码

卡了下常，写得很丑．

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define debug(...) fprintf(stderr, __VA_ARGS__)

using u64 = unsigned long long;

inline u64 rd() {
	u64 x = 0; int c = getchar();
	while (((c - '0') | ('9' - c)) < 0) c = getchar();
	while (((c - '0') | ('9' - c)) > 0)
		x = x * 10 + c - '0', c = getchar();
	return x;
}

const u64 P = 1732073999;

const int N = 40;

int nn[N + 5], len;
u64 pw[N + 5];

u64 f[N + 5][N + 5][2];
u64 dfs(int i, int ct, bool rmx) {
	if (i == len + 1) return ct == 0;
	if (f[i][ct][rmx] != 0xffffffffffffffff) return f[i][ct][rmx];
	u64 res = 0;
	for (int cur = 0, li = (rmx ? nn[i] : 2); cur <= li; cur++) {
		int nc = ct - (cur == 1);
		if (nc < 0) continue;
		int nxt = dfs(i + 1, nc, rmx && cur == nn[i]);
		res += nxt;
	}
	return f[i][ct][rmx] = res % P;
}

void solve() {
	memset(f, 0xff, sizeof(f));

	u64 n = rd(); len = 0;
	while (n) nn[++len] = n % 3, n /= 3;
	std::reverse(nn + 1, nn + 1 + len);
	u64 ans = 0;
	for (int i = 0; i <= len; i++) {
		ans += dfs(1, i, 1) * pw[i] % P;
	}
	printf("%llu\n", ans % P);
}

int main() {
	pw[0] = 1; for (int i = 1; i <= N; i++) pw[i] = pw[i - 1] * 2 % P;
	int T = rd(); rd();
	while (T--) solve();
	return 0;
}
```


---

## 作者：Brilliant11001 (赞：3)

[更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18408547)

## [题目传送门](https://www.luogu.com.cn/problem/P7976)

### 题目大意：

设函数 $F(x) := (x + 1) \bmod 3 − 1$，$T$ 次询问，计算：

$$\sum\limits_{i = 0}^{n}\sum\limits_{j}F\left({i\choose j}\right)$$

### 思路：

看到奇奇怪怪的组合数求和首先考虑 $\text{Lucas}$，将原数在 $3$ 进制下拆位，得：

$${i\choose j} = \prod\limits_{k = 1}^{m}{i_k\choose j_k}\bmod 3$$

其中 $m$ 表示 $i$ 和三进制下较长的那个数的数字位数。

接着注意到 $F$ 函数是一个**积性函数**（这个可以分九类讨论证明），即 $F(xy) = F(x)F(y)$，所以实际上 $F\left({i\choose j}\right)$ 要计算的就是所有 $F\left({i_k\choose j_k}\right)$ 的乘积。

对于每一个 $i$，$j$ 的每一位就独立了，这时候再分类讨论：

1. 当 $i_k = 0$ 时，$j_k$ 取 $0$ 的时候有贡献，此时这一位的值为 $F(1) = 1$；
2. 当 $i_k = 1$ 时，$j_k$ 取 $0,1$ 的时候有贡献，此时这一位的值为 $F(1) + F(1) = 2$；
3. 当 $i_k = 2$ 时，$j_k$ 取 $0,1,2$ 的时候有贡献，此时这一位的值为 $F(1) + F(2) + F(1) = 1$。

而乘 $1$ 是不会是答案增加的，所以只用考虑乘 $2$ 的个数就行了，即：

$$\sum\limits_{j}F\left(i\choose j\right) = \left(\prod\limits_{i_k = 0}1\right)\left(\prod\limits_{i_k = 1}2\right)\left(\prod\limits_{i_k = 2}1\right) = 2^{\#\{i_k = 1\}}$$

然后就会发现统计一下三进制表示下 $1$ 的个数就行了，数位 dp 即可。

$\texttt{Code:}$

```cpp
#include <cmath>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long ll;

const int N = 65, mod = 1732073999;

int T;
ll vmax, n;
vector<int> num;
ll f[N][N];

ll qpow(int a, int b) {
    ll ans = 1, base = a;
    while(b) {
        if(b & 1) ans = ans * base % mod;
        base = base * base % mod;
        b >>= 1;
    }
    return ans;
}

ll dfs(int pos, int cnt, bool limit, bool zero) {
    if(pos < 0) return qpow(2, cnt);
    if(!limit && !zero && ~f[pos][cnt]) return f[pos][cnt];
    int mx = (limit ? num[pos] : 2);
    ll res = 0;
    for(int i = 0; i <= mx; i++)
        res = (res + dfs(pos - 1, cnt + (i == 1), limit && (i == num[pos]), zero && (!i))) % mod;
    if(!limit && !zero) f[pos][cnt] = res;
    return res;
}

ll calc(ll x) {
    num.clear();
    ll tmp = x;
    while(tmp) {
        num.push_back(tmp % 3);
        tmp /= 3;
    }
    return dfs(num.size() - 1, 0, 1, 1);
}

int main() {
    scanf("%d%lld", &T, &vmax);
    memset(f, -1, sizeof f);
    while(T--) {
        scanf("%lld", &n);
        printf("%lld\n", calc(n));
    }
    return 0;
}
```

---

## 作者：forest114514 (赞：2)

一道很好的绿题，让我证明了半天。~~（思维难度完全有蓝）~~

首先对于 $F(x)$，我们很快可以给出等价的变形（记 $d=x\bmod 3,d\in{\{0,1,2}\}$ ）：
$$
F(d)=\begin{cases}0&d=0\\1&d=1\\-1&d=2\end{cases}
$$

对原式简单变形一下，所以我们要求的式子就变成了 ：
$$
\sum\limits_{r=0}^{n}\sum\limits_{l=0}^{r}\left[\binom{r}{l}\equiv1\pmod3\right]-\left[\binom{r}{l}\equiv2\pmod3\right]
$$
很显然对 3 取模我们考虑卢卡斯定理，记 $a_{0\sim V},b_{0\sim V}$ 分别为 $r,l$ 的三进制各位数，则 $\binom{r}{l}=\prod\limits_{i=0}^{V}\binom{a_i}{b_i}$。

注意到在 $a_i\le2,b_i\le2$ 时，只有 $\binom{2}{1}=2$，其余 $a_i\ge b_i$ 均有 $\binom{a_i}{b_i}=1$，我们考虑每一个 $a_{i}=0/1/2$ 的贡献，记 $cnt_{r,0/1/2}$ 为 $r$ 的三进制分解序列 $a_i$ 中的 $0/1/2$ 的个数，通过乘法原理不难发现原式的贡献就是 $2^{cnt_1}$，所以对于每一个 $\sum\limits_{l=0}^{r}\left[\binom{r}{l}\equiv1\pmod3\right]-\left[\binom{r}{l}\equiv2\pmod3\right]$，其贡献就为 $2^{cnt_{r,1}}$，所以原式就化为了 $\sum\limits_{r=0}^{n}2^{cnt_{r,1}}$，如果暴力统计是 $O(N\log N)$ 的，我们考虑数位 DP，预处理 $f_{i,k}$ 为数三进制前 $i$ 位有 $k$ 位为 1 的数字的个数，有转移 ~~（其实还是一个组合数相关式子，可以直接预处理阶乘和逆元与 2 的幂次）~~：
$$
f_{i,k}=2f_{i-1,k}+f_{i-1,k-1}
$$
时间复杂度为 $O(\log^2 N)$ 。

总结：本题如果只看数位 DP 只有上位绿到下位蓝的难度（这道题数位 DP 和 P4317 花神的数论题  很相似），但我认为用卢卡斯推式子的难度完全有中位蓝的难度 ~~（建议评蓝）~~。

CODE：

```cpp
const int N=40;
const LL mod=1732073999;
LL f[N][N],num[N],mul[N];
void add(LL &u,LL v){
	u=(u+v>=mod)?(u+v-mod):u+v;
}
void init(){
	f[0][0]=mul[0]=1;
	rep(i,1,36){
		mul[i]=mul[i-1]*2ll%mod;
		f[i][0]=2ll*f[i-1][0]%mod;
		rep(j,1,36) f[i][j]=(2ll*f[i-1][j]+f[i-1][j-1])%mod;
	}
}
void solve(LL n){
	LL res=0,len=0,cnt=0;++n;
	while(n) num[++len]=n%3,n/=3;
	per(i,len,1){
		if(num[i]>=1){//0
			rep(k,0,i-1) add(res,mul[k+cnt]*f[i-1][k]%mod);
		}
		if(num[i]==2){//1
			rep(k,0,i-1) add(res,mul[k+cnt+1]*f[i-1][k]%mod);
		} 
		cnt+=(num[i]==1?1:0);
	}
	write(res,'\n');
}
signed main(){
	LL T,maxn;
	read(T,maxn);
	init();LL n;
	while(T--) read(n),solve(n);
	return 0;
}
```

---

## 作者：Celtic (赞：2)

这题其实是可以 $O((T+\log_n)\log{n})$ 做的。首先有个性质是第 $i$ 行的和是 $2^{k}$，$k$ 为 $i$ 的三进制表示中 $1$ 的个数。证明用 lucas 定理就行了，具体可以看其他题解。然后考虑数位 dp，设 $f_{i,j,0/1}$ 表示当前 dp 到第 $i$ 位，$1$ 的个数为 $j$，是否解除了最高位的限制的方案数，这样直接 dp 因为每次的 $n$ 不同，所以解除限制这个状态每次都要重新算，是 $O(T\log^2{n})$ 的，非常浪费。考虑去掉最后一维状态，每次改为枚举第一个解除限制的位。这样 dp 状态就不用清空了，每次询问的时候只有一个从高到低位枚举，复杂度就是 $O((T+\log_n)\log{n})$ 的。

这个做法常数也非常小，很轻松就能跑到 15ms 左右。[提交记录](https://www.luogu.com.cn/record/64932756)。

---

## 作者：hgckythgcfhk (赞：0)

注意到：

$$F(0)=0,F(1)=1,F(2)=-1$$

同时，有 $F(x)=F(x\bmod 3)$

不难发现，这个函数其实表示对 $3$ 取模。

题意是让我们求组合数的前 $n+1$ 行对 $3$ 取模后的和，其中把 $2$ 视为 $-1$。

定义 $dp_n$ 表示前 $n$ 行的和，显然 $dp_0=0,dp_1=1$。

对于这种对组合数取模后求和的问题，最好的方法是打表找规律，打表发现，对于每个 $n=3^x$ 其中 $x$ 是非负整数，第 $n+1$ 到第 $2n$ 层，相当于把前 $n$ 层复制两遍，第 $2n+1$ 到第 $3n$ 层相当于把前 $n$ 层复制一遍，取反一遍，再复制一遍，这样肯定是填不满位置的，剩下的位置都是 $0$，没有贡献，具体怎么摆放可以自己打个表看看，这个摆放方式很好理解但描述起来比较麻烦，不过怎么摆放其实并不重要，反正我们只关心这几行的和，把复制这个过程想象成这些复制出来的东西直接堆在一起也没问题，所以，对于每个 $3$ 的幂，$dp_{2n}=dp_n+2\times dp_n=3\times dp_n,dp_{3n}=dp_{2n}+dp_n-dp_n+dp_n=4\times dp_n$。

考虑更一般的情况，前面说过了，摆放方式并不重要，设 $a$ 表示最大的小于 $n$ 的 $3$ 的幂.

若 $n<2a$，则有 $dp_n=dp_a+2\times dp_{n-a}$。

若 $n>2a$，则有 $dp_n=3\times dp_a+dp_{n-2a}$。

然后可以递归的求，每次递归 $n$ 会减小到不超过原来的 $\dfrac{1}{3}$ 所以时间复杂度为 $O(\log_3 n)$，同时，可以预处理 $3$ 的幂和 $3$ 的幂的 $2$ 倍，并记忆化一下来优化常数。

为防止因火车头导致无法过审，仅给出核心程序和部分可能引起歧义的宏定义。

```cpp
#define int rg unsigned
#define rg register
#define cit const rg unsigned

ump<ull,ull>dp;
void init(){dp[1]=1;
	for(int ll i=1;i*3ll<=2e16;i*=3ll)
	dp[i*3ll]=dp[i]*4ll%p;
}
il ull f(cit ll n){if(dp.count(n))return dp[n];
	int ll _=1;while(_<=n)_*=3ll;_/=3ll;
	return dp[n]=(n>_+_?f(n-_-_)+dp[_]*3ll%p:dp[_]+f(n-_)*2ll%p)%p;
}
ull n;
void solve(){cin>>n;cout<<f(n+1ll)<<'\n';
}signed main(){open;int t=1;init();cin>>t>>n;
	while(t--)solve();}
```
剩余的宏定义没有给出，但根据字面意思很容易理解。

---


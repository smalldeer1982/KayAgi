# [国家集训队] 最长双回文串

## 题目描述

顺序和逆序读起来完全一样的串叫做回文串。比如 `acbca` 是回文串，而 `abc` 不是：`abc` 的顺序为 `abc`，逆序为 `cba`，不相同。

输入长度为 $n$ 的串 $S$，求 $S$ 的最长双回文子串 $T$，即可将 $T$ 分为两部分 $X, Y$（$|X|,|Y|≥1$）且 $X$ 和 $Y$ 都是回文串。

## 说明/提示

**样例说明**

从第二个字符开始的字符串 `aacaabbacabb` 可分为 `aacaa` 与 `bbacabb` 两部分，且两者都是回文串。

**数据范围**

对于 $100\%$ 的数据，$2\leq |S|\leq 10^5$。

2018.12.10，2018.12.15：感谢 @Ycrpro 提供 hack 数据两组。

## 样例 #1

### 输入

```
baacaabbacabb```

### 输出

```
12```

# 题解

## 作者：楚泫 (赞：129)

# 初学Manacher，写给和自己一样的小白们

---

下午刚学了 $Manacher$ ，做到这题。

然后对于大佬们的题解做一个更为详细的补充说明，

主要针对自己的一些疑惑，以及不理解的地方做了详尽的诠释

顺手就全写代码里了！有哪里讲的不清楚可以问窝(虽然我很弱

---

```cpp
#include <bits/stdc++.h>
#define ll long long
#define space putchar(' ')
#define endl putchar('\n')
#define debug puts("------------------------")
using namespace std;
inline void read(int &a) {a = 0; int c = getchar(), b = 1; while (c > '9' || c < '0') {if (c == '-')b = -1; c = getchar();} while (c >= '0' && c <= '9') a = (a << 3) + (a << 1) + c - 48, c = getchar(); a *= b; }
inline int  Rem() {int a = 0, c = getchar(), b = 1; while (c > '9' || c < '0') {if (c == '-')b = -1; c = getchar();} while (c >= '0' && c <= '9') a = (a << 3) + (a << 1) + c - 48, c = getchar(); return a *= b; }
inline void write(int x) {if (x > 9)write(x / 10); putchar('0' + x % 10);}
inline void W(int x) {if (x < 0) {putchar('-'), x = -x;} write(x);}
/**/
const int N = 11000005;
char a[N], s[N << 1];
int n, hw[N << 1], ans, l[N << 1], r[N << 1];
/**/
void Pre()//非常模板的插入
{
	s[0] = '#';
	s[1] = '$';
	int cnt = 1;
	for (int i = 1; i <= n; i++)
	{
		s[++cnt] = a[i];
		s[++cnt] = '$';
	}
	n = (n << 1) + 2;
	s[n] = '~';
}

void work()//同样非常模板的Manacher
{
	int mr = 0, mid;
	for (int i = 1; i <= n; i++)
	{
		if (i < mr) hw[i] = min(hw[(mid << 1) - i], mr - i);
		else hw[i] = 1;
		while (s[i + hw[i]] == s[i - hw[i]]) ++hw[i];
		if (hw[i] + i > mr) mr = hw[i] + i, mid = i;
		/**
		 * l[i]表示以i为左端点的最长的回文串
		 * r[i]表示以i为右端点的最长的回文串
		 *
		 * 对于蒟蒻(我)来讲有点抽象所以我们举一个生动的栗子：
		 *
		 * 		首先，字符串为ababaccd
		 *
		 * 				  0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17
		 * 		插入后变成 #|$|a|$|b|$|a|$|b|$|a |$ |c |$ |c |$ |d |~
		 *
		 * 		显然i = 4时,hw[4] = 4
		 * 		L = 7 = i + hw[4]-1;
		 * 		R = 1 = i-hw[4]+1;
		 * 		回文串实际长度=hw[4]-1;
		 * 		所以转移就是: l[i+hw[i]-1]=max(l[i+hw[i]-1],hw[i]-1);
		 * 					 r[i-hw[i]+1]=max(r[i-hw[i]+1],hw[i]-1);
		 *
		 */
		r[i + hw[i] - 1] = max(r[i + hw[i] - 1], hw[i] - 1);
		l[i - hw[i] + 1] = max(l[i - hw[i] + 1], hw[i] - 1);
	}
}

int main()
{
	scanf("%s", a + 1);
	n = strlen(a + 1);
	Pre();
	work();
/**
 *	又因为两块不能重叠，所以我们选择'$'作为断点进行枚举
 *
 *  那么先提出一个困扰蒟蒻我的问题：
 * 
 *	Q: 上面不是已经求过了吗，为什么还要递推呢？
 *
 *  A: 上面求出的每个l[i]和r[i]都是在i最大的情况下求的
 *  	
 *  	eg:0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17
 *		   #|$|a|$|b|$|a|$|b|$|a |$ |c |$ |c |$ |d |~
 *
 * 		l[3]求出来的是0,但很明显bab是一个回文,l[3]应该等于3
 * 		这是因为我们在i=6时,hw[i]=6,只更新了l[1]和r[11],因为bab不是i=6的最长回文串所以没有更新
 *
 * 		这时就需要递推把前面的转移过来了：
 *
 * 			bab 比 ababa 短两个字符。
 * 			每一个回文串向后挪动一个 都会少两个字符,所以：
 * 		 	l[i] = max(l[i], l[i - 2] - 2);
 * 			r[i] = max(r[i], r[i + 2] - 2);
 * 			我们枚举的是'$'的位置，所以l[i]正推由前一个'$'的位置转移来,r[i]逆推由后面的'$'转移来，每次都会-2回文串长度
 *
 */
	for (int i = n; i >= 1; i -= 2) r[i] = max(r[i], r[i + 2] - 2);
	for (int i = 1; i <= n; i += 2) l[i] = max(l[i], l[i - 2] - 2);

	for (int i = 1; i <= n; i += 2) if (r[i] && l[i]) ans = max(ans, l[i] + r[i]);
	W(ans);
	return 0;
}
```


---

## 作者：浅色调 (赞：94)

### Solution：

　　本题$zyys$啊！～

　　很容易想到$manacher$，于是先打个板子看看，处理出以$i$为中心的最长回文半径$p[i]$后，就断思路了。

　　我首先想到的是，在每次更新$p[i]$后，分别处理出以$i$为中心的半径$p[i]$内，每个位置为开头和结尾的最长回文子串长度($manacher$结束后直接枚举断点就可以得到答案)，但是这样强行又将复杂度拉到了$O(n^2)$。于是，开始断线～

　　后面看看巨佬们的思路，豁然**，我是真的蠢啊～

　　其实，将我开始的思路修改一下即可：

　　我们维护最长回文半径$p[i]$的同时，再分别维护两个东西，以$i$为结尾的最长回文子串的长度$ll[i]$，和以$i$为开头的最长回文子串的长度$rr[i]$。

　　那么很显然，因为以$i$为中心的最长回文子串长度为$p[i]-1$，所以每次更新$p[i]$后，我们只需处理出当前这个回文子串的左右边界(中间的每个点的$ll[i],rr[i]$可以在$manacher$结束后$O(n)$处理出)，则$ll[i+p[i]-1]=max(ll[i+p[i]-1],p[i]-1)$(更新以$i+p[i]-1$为结尾的最长回文长度)，同理$rr[i-p[i]+1]=max(rr[i-p[i]+1],p[i]-1)$。

　　跑完$manacher$后，我们$O(n)$递推出每个'#'为断点的$ll[i]$和$rr[i]$，其中$rr[i]$因为是$i$结尾的回文长度，所以直接顺推，每往后移一位，最长回文子串长度$-2$，于是$rr[i]=max(rr[i],rr[i-2]-2)$($i-2$是上一个'#'位置)，同理$ll[i]$直接逆推，类似地$ll[i]=max(ll[i],ll[i+2]-2)$。

　　最后枚举每个'#'为断点，更新$ans$就$OK$了。

$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9090876.html)（蒟蒻写题解不易，转载请注明出处～万分感谢！）
 
### 代码：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))
#define Bor(i,a,b,c) for(int (i)=(b);(i)>=(a);(i)-=(c))
#define Min(a,b) ((a)>(b)?(b):(a))
#define Max(a,b) ((a)>(b)?(a):(b))
using namespace std;
const int N=200050;
int p[N],ll[N],ans,rr[N],mx,id,cnt;
char s[N],t[N];
int main(){
    scanf("%s",t);
    int len=strlen(t);
    s[++cnt]='$',s[++cnt]='#';
    For(i,0,len-1,1)s[++cnt]=t[i],s[++cnt]='#';
    s[++cnt]='\0';
    For(i,1,cnt,1){
        if(i<mx)p[i]=Min(p[id*2-i],mx-i);
        else p[i]=1;
        while(s[i-p[i]]==s[i+p[i]])p[i]++;
        if(mx<i+p[i])id=i,mx=i+p[i];
        ll[i+p[i]-1]=Max(ll[i+p[i]-1],p[i]-1);
        rr[i-p[i]+1]=Max(rr[i-p[i]+1],p[i]-1);
    }
    For(i,2,cnt,2)rr[i]=Max(rr[i],rr[i-2]-2);
    Bor(i,2,cnt,2)ll[i]=Max(ll[i],ll[i+2]-2);
    For(i,2,cnt,2)if(rr[i]&&ll[i])ans=Max(ans,ll[i]+rr[i]);
    cout<<ans;
    return 0;
}
```




---

## 作者：蒟蒻初音ミク (赞：40)

# 广告

[蒟蒻的blog](http://www.luogu.com.cn/blog/111990/#)

# 正文

这道题的具体做法本蒟蒻在这里不多作阐释，因为本蒟蒻的做法与前面大佬的做法是一样的，这篇题解也是为了解答[浅色调](https://www.cnblogs.com/five20/p/9090876.html)
大佬未给大家解答的一个问题（注意打斜杠的两行代码）：
```cpp
//因为每个双回文串中间不能交叉，所以只能枚举'#'来找答案 
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int min(int a,int b){return a<b?a:b;}
inline int max(int a,int b){return a>b?a:b;}

#define re register
#define ll long long
#define N 100100

int n,len[(N<<1)+10],l[(N<<1)+10],r[(N<<1)+10];
//l[i]表示以i结尾的最长回文串的长度
//r[i]表示以i开头的最长回文串的长度 
char ch[N+10],s[(N<<1)+10];
//ch是原数组，s是中间加了'#'的数组

void manache()
{
	int id=0,maxx=0;
	for(re int i=1;i<=n;++i)
	{
		if(i<maxx)len[i]=min(maxx-i,len[id*2-i]);
		else len[i]=1;
		while(s[i+len[i]]==s[i-len[i]])++len[i];
		if(i+len[i]>maxx)
		{
			maxx=i+len[i];
			id=i;
		}
		l[i+len[i]-1]=max(l[i+len[i]-1],len[i]-1);//回文串真实长度为len[i]-1 
		r[i-len[i]+1]=max(r[i-len[i]+1],len[i]-1);
	}
}

int main()
{
	scanf("%s",ch+1);
	int tlen=strlen(ch+1);
	s[0]='$';s[1]='#';n=1;
	for(re int i=1;i<=tlen;++i)
	{
		s[++n]=ch[i];
		s[++n]='#';
	}
	manache();
	for(re int i=3;i<=n;i+=2)r[i]=max(r[i],r[i-2]-2);////////
	for(re int i=n;i>=3;i-=2)l[i]=max(l[i],l[i+2]-2);////////
	int ans=0;
	for(re int i=3;i<=n;i+=2)if(r[i]&&l[i])ans=max(ans,l[i]+r[i]);//一定要写r[i]&&l[i]，否则会wa 
	printf("%d\n",ans);
	return 0;
}
```
路过的读者大大有很多都因为不理解打斜杠的两句而发表评论求解，本蒟蒻今天就告诉大家这两句的意义吧。

首先明确两个东西：**饱和回文串**和**不饱和回文串**

定义如图：
![](https://cdn.luogu.com.cn/upload/pic/62952.png)

那么刚才的代码当中manache函数貌似已经计算了每一个字符作为开头和结尾的最大长度，但是仔细一想就可以发现，这只是计算了每一个字符作为开头和结尾的**饱和回文串的长度**！！！因为len[i]-1实际上指的是原数组中以i为中心的饱和回文串的长度！！！

那么，为了计算每一个字符作为不饱和字符串开头和结尾的长度，上面的代码中便加上了两行：
```cpp
for(re int i=3;i<=n;i+=2)r[i]=max(r[i],r[i-2]-2);
for(re int i=n;i>=3;i-=2)l[i]=max(l[i],l[i+2]-2);
```
为什么**i+=2**？？？为什么**l[i+2]-2**？？？我们来看一下。

首先，双回文串的两端不能有交叉的地方，所以我们找到的双回文串的断点必须是'#'，而每一个'#'中间间隔一个字符，所以要**i+=2**

其次，关于l[i]=l[i+2]-2的问题，我们来画图：
![](https://cdn.luogu.com.cn/upload/pic/62954.png)

从图中可以看出，对于i来讲，因为他是'#'，所以它在原来的数组中是处于夹缝中的，那么以它结尾的**不饱和回文串**的最大长度=以i+2结尾的**回文串**的最大长度-2

即l[i]=l[i+2]-2

那么以此类推，r[i]也是一样的：
![](https://cdn.luogu.com.cn/upload/pic/62955.png)

所以，总代码便是：

## code：

```cpp
//因为每个双回文串中间不能交叉，所以只能枚举'#'来找答案 
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int min(int a,int b){return a<b?a:b;}//手写min函数
inline int max(int a,int b){return a>b?a:b;}//手写max函数

#define re register
#define ll long long
#define N 100100

int n,len[(N<<1)+10],l[(N<<1)+10],r[(N<<1)+10];
//l[i]表示以i结尾的最长回文串的长度
//r[i]表示以i开头的最长回文串的长度 
char ch[N+10],s[(N<<1)+10];
//ch：原数组，s：加了'#'的数组

void manache()//manacher求最长回文串的函数
{
	int id=0,maxx=0;
	for(re int i=1;i<=n;++i)
	{
		if(i<maxx)len[i]=min(maxx-i,len[id*2-i]);
		else len[i]=1;
		while(s[i+len[i]]==s[i-len[i]])++len[i];
		if(i+len[i]>maxx)
		{
			maxx=i+len[i];
			id=i;
		}
		l[i+len[i]-1]=max(l[i+len[i]-1],len[i]-1);//求出以i结尾的饱和回文串的最大长度
		r[i-len[i]+1]=max(r[i-len[i]+1],len[i]-1);//求出以i开头的饱和回文串的最大长度
	}
}

int main()
{
	scanf("%s",ch+1);
	int tlen=strlen(ch+1);
	s[0]='$';s[1]='#';n=1;
	for(re int i=1;i<=tlen;++i)
	{
		s[++n]=ch[i];
		s[++n]='#';
	}
	manache();
	for(re int i=3;i<=n;i+=2)r[i]=max(r[i],r[i-2]-2);//求出以i开头的饱和与不饱和回文串的最大长度
	for(re int i=n;i>=3;i-=2)l[i]=max(l[i],l[i+2]-2);//求出以i结尾的饱和与不饱和回文串的最大长度
	int ans=0;
	for(re int i=3;i<=n;i+=2)if(r[i]&&l[i])ans=max(ans,l[i]+r[i]);//一定要写r[i]&&l[i]，否则会wa 
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：foreverlasting (赞：29)

回文自动机裸题。

分别建两个回文自动机，一个是正序，一个是倒序，然后通过自动机得出最长回文长度，接着枚举切割点就好了。

2018.12.15update：之前忘记考虑不切割的情况，那只要不枚举$n$为切割点就好了。

code：
```
//2018.11.21 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e5+10;
namespace MAIN{
    int n;
    int a[N],b[N];
    struct PAM{
        struct Pam{
            int vis[26],len,fail;
        }pam[N];
        int las,cnt;
        PAM() {pam[1].fail=pam[0].fail=1,pam[cnt=1].len=-1;}
        inline void extend(const res &x,const res &id,char *str){
            res p=las;
            for(;str[id-pam[p].len-1]!=str[id];p=pam[p].fail);
            if(!pam[p].vis[x]){
                res np=++cnt,q=pam[p].fail;
                for(;str[id-pam[q].len-1]!=str[id];q=pam[q].fail);
                pam[np].fail=pam[q].vis[x],pam[p].vis[x]=np,pam[np].len=pam[p].len+2;
            }
            las=pam[p].vis[x];
        }
    }A,B;
    char str[N];
    int ans;
    inline void MAIN(){
        scanf("%s",str+1);
        n=strlen(str+1);
        for(res i=1;i<=n;i++)A.extend(str[i]-'a',i,str),a[i]=A.pam[A.las].len;
        reverse(str+1,str+n+1);
        for(res i=1;i<=n;i++)B.extend(str[i]-'a',i,str),b[n-i+1]=B.pam[B.las].len;
        for(res i=1;i<n;i++)ans=_max(a[i]+b[i+1],ans);
        printf("%d\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Nemlit (赞：21)

~~不知道有没有人跟我一样数据结构学傻了~~

首先这道题是要求回文串，那么我们可以想到[manacher算法](https://www.luogu.org/blog/tbr-blog/solution-p3805)

但由于$manacher$不能求出双回文子串，我们要考虑一些性质

首先对于一个回文串，删掉两边的字符它一样是回文串

然后$manacher$求出的$p$数组就是他能拓展的数量，发现对于一个点对$i, j$，当满足$i+p_i+1≥j-p_j+1$时，两个回文串有交集，根据上述性质，这对点对是可以构成双回文子串的

上述式子是可以用权值线段树实现的，每找到一个$i+p_i$，丢尽权值线段树里面，每次查询权值线段树中$[j-p_j, MAX]$的最小的$i$，用$j-i+1$更新答案即可

（注意本身就是一个回文串的情况）
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rep(i, s, t) for(int i = s; i <= t; ++ i)
#define maxn 200005
#define inf 123456789
int n, m, cnt, p[maxn], Ans, MAX = 200000, mi[maxn << 2], pax;
char c[maxn], s[maxn];
#define ls k << 1
#define rs k << 1 | 1
il void build(int k, int l, int r) {
	mi[k] = inf;
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
}
il void insert(int k, int l, int r, int ll, int v) {
	if(l == r) return(void)(mi[k] = min(v, mi[k]));
	int mid = (l + r) >> 1;
	if(ll <= mid) insert(ls, l, mid, ll, v);
	else insert(rs, mid + 1, r, ll, v);
	mi[k] = min(mi[ls], mi[rs]);
}
il int query(int k, int l, int r, int ll, int rr) {
	if(ll <= l && r <= rr) return mi[k];
	int mid = (l + r) >> 1, ans = inf;
	if(ll <= mid) ans = query(ls, l, mid, ll, rr);
	if(mid < rr) ans = min(ans, query(rs, mid + 1, r, ll, rr));
	return ans;
}
il void build() {
	scanf("%s", c + 1), n = strlen(c + 1), s[++ cnt] = '~', s[++ cnt] = '#';
	rep(i, 1, n) s[++ cnt] = c[i], s[++ cnt] = '#';
	s[++ cnt] = '!';
}
il void solve() {
	int mid = 0, mr = 0;
	rep(i, 2, cnt - 1) {
		if(i <= mr) p[i] = min(p[mid * 2 - i], mr - i + 1);
		else p[i] = 1;
		while(s[i - p[i]] == s[i + p[i]]) ++ p[i];
		if(i + p[i] > mr) mr = i + p[i] - 1, mid = i;
		Ans = max(Ans, i - query(1, 1, MAX, i - p[i] + 1, MAX));
		insert(1, 1, MAX, i + p[i], i), pax = max(pax, p[i]);
	}
	if(pax - 1 == n) printf("%d", n - 1);
	else printf("%d", Ans);
}
int main() {
	return build(1, 1, MAX), build(), solve(), 0;
}

```

---

## 作者：RPChe_ (赞：12)

让窝来贡献一个~~垃圾~~$O(n+n\log n)$算法

--------------
首先发现此题跟回文串有关，那么我们就可以很容易的联想到manacher算法。如果不会这个算法可以先康康这道题——[**P3805** 【模板】manacher算法](https://www.luogu.com.cn/problemnew/show/P3805)。

于是我们先跑一遍manacher算法，得到了以每个点为对称轴的回文串的最大半径，即下文的$lr$数组。然后我们再读一读题，题目要求的是最长的双回文串，也就是找到两个不同的回文串，使得它们相交，内含或相切，且这两个回文串的对称轴的距离尽量的长。

那怎么找到这两个回文串呢？

大佬就直接用$O(n)$递推了，然而我可能是数据结构学傻了，就把它当作了一个RMQ问题。

我们可以这样考虑：枚举每个回文串，寻找左端点在这个回文串的范围内，且对称轴距尽量靠右，也就是距当前回文串对称轴尽量远的回文串，即$maxx=\max\limits^{r_i}_{j=l_i}{mid_j}$。（$l_i$和$r_i$分别是当前回文串的左、右端点，$j$是在这个回文串范围内的左端点，$mid$是对应的对称轴）然后我们再用maxx减去当前回文串的对称轴，因为之前跑manacher算法时添加过‘#’，所以就得到了这个双回文串的长度。然后再更新答案即可。

这样我们就考虑了相交和内含的情况。因为‘#’的存在，这样还同时解决了相切的情况。

于是这个问题就被转化为了一个RMQ问题。有很多算法可供选择，这里就窝就用线段树了，因为本人写的比较熟。

这样就可以达到如下的代码——

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<string.h>
#define rep(i,a,b) for(register int i=a;i<=b;i++)
#define maxn 500005
using namespace std;

int ans,rl[maxn],maxright,pos,len,maxx[maxn],rl1[maxn],v[maxn];
string res="@#";

void manacher(string s) {
	len=s.size()-1;
	rep(i,0,len) {
		res+=s[i];
		res+="#";
	}
	len=res.size()-1;
	rep(i,1,len) {
		rl[i]= maxright > i ? min(rl[pos*2-i],maxright-i) : 1 ;
		while(res[i-rl[i]]==res[i+rl[i]]) rl[i]++;
		if(i+rl[i]>maxright) maxright=i+rl[i],pos=i;
	}
	rep(i,1,len) if(res[i]!='#'||rl[i]!=1) v[i-rl[i]+1]=max(v[i-rl[i]+1],i);//注意当这个回文串为空，也就是仅存在一个'#'时不能添加，避免答案出现只有一个回文串的情况。
}//manacher算法

void build(int k,int l,int r) {
	if(l==r) {
		maxx[k]=v[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	maxx[k]=max(maxx[k*2],maxx[k*2+1]);
}//构建一棵线段树

int query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return maxx[k];
	int mid=(l+r)>>1,res=0;
	if(x<=mid) res=max(res,query(k*2,l,mid,x,y));
	if(y>mid) res=max(res,query(k*2+1,mid+1,r,x,y));
	return res;
}//询问操作

void work(string s) {
	manacher(s);
	build(1,1,len);
	rep(i,1,len) {
		if(res[i]=='#'&&rl[i]==1) continue;//与上文同理。
		ans=max(ans,query(1,1,len,i-rl[i],i+rl[i])-i);
	}
}

int main() {
	ios::sync_with_stdio(false);
	string s;
	cin>>s;
	work(s);
	cout<<ans;
	return 0;
}
```



---

## 作者：panda_2134 (赞：9)

[Luogu-P4555](https://www.luogu.org/problemnew/solution/P4555)

[Blog上阅读效果更好](https://panda2134.tk/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/2018/06/06/double-palindrome/)

## 题意

标题即题意。注意两个子串不能重复。

## 思路

并不会 $\text{Manacher}$ ，所以脑补了一种 $O(n \lg n)$ 的做法。

首先考虑转化所有偶数长度回文串。每个字符之间以及开头结尾插入 `#` 即可全部转为奇数长度。

然后可以维护正反串 Hash，每次枚举回文中心并且枚举回文串一半的长度。但是这样是 $O(n^2)$ 的。这个长度显然满足单调和有界性，类似求 $\text{LCP}$ ，可以二分它。于是我们就处理出了以每个点为回文中心的最长回文串。

类似 \[NOI2016\] 优秀的拆分，考虑用 `pre[], suf[]` 表示某个点往左，往右的最长回文串。显然，最长双回文串由两个极长回文串拼接而成。

如何求出这两个数组呢？实际上求出每个回文中心的回文串长后，可以注意到这个回文串以及它的同回文中心的子串对左右的贡献成等差数列，以对于 `pre[] `的贡献为例，如图：

![eg](https://panda2134.github.io/img/doublepalindrome.jpg)

于是问题就变成了：

1. 区间加 $a_0 = 1, d = 1$ 的等差数列
2. 单点求值。

我们用线段树实现。（感谢Claris神犇和Anoxiacxy同学）

考虑维护数组 $b_i$，$b_i = a_i - i$，所以初始时 $b_i = -i$。于是操作1就变为 $\{b_n\}$ 的区间 chkmax ，也就是对于 $[l, r]$ 的区间加等差数列，转为了在 $\{b_n\}$ 中 $[l, r]$ 对于 $-i+1$ 去 chkmax。

考虑 chkmax 的实现。可以采取标记永久化，不下放线段树标记，在查询单点的时候返回树上所有祖先和叶子的 $\max$ 即可。

最后统计答案的时候，只需在 `#` 处加以统计。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

const int MAXN = 3e5, INF = 0x3f3f3f3f;
const ull base = 1313;
int n, ans, pre[MAXN + 10], suf[MAXN + 10];
char s0[MAXN + 10], s[MAXN + 10], *ptr = &s[1];
ull powbase[MAXN + 10], hval[MAXN + 10], hrev[MAXN + 10];

struct SegTree {
#define lc(o) ((o) << 1)
#define rc(o) ((o) << 1 | 1)
    int sumv[(MAXN + 10) << 2], setv[(MAXN + 10) << 2];

    SegTree() { fill(setv, setv + ((MAXN + 10) << 2), -INF); }

    void maintain(int o, int l, int r) {
        if(l != r) sumv[o] = sumv[lc(o)] + sumv[rc(o)];
        if(setv[o] != -INF) sumv[o] = setv[o] * (r - l + 1);
    }

    void build_tree(int o, int l, int r) {
        if(l == r)
            setv[o] = -l;
        else {
            int mid = (l + r) >> 1;
            build_tree(lc(o), l, mid);
            build_tree(rc(o), mid + 1, r);
        }
        maintain(o, l, r);
    }

    void cover(int o, int l, int r, int ql, int qr, int val) {
        if(ql > qr) return;
        if(ql <= l && r <= qr)
            setv[o] = max(setv[o], val);
        else {
            int mid = (l + r) >> 1;
            if(ql <= mid) cover(lc(o), l, mid, ql, qr, val);
            if(qr >= mid + 1) cover(rc(o), mid + 1, r, ql, qr, val);
        }
        maintain(o, l, r);
    }

    int query(int o, int l, int r, int p) {
        maintain(o, l, r);
        if(l == r)
            return sumv[o];
        else {
            int mid = (l + r) >> 1;
            if(p <= mid)
                return max(setv[o], query(lc(o), l, mid, p));
            else
                return max(setv[o], query(rc(o), mid + 1, r, p));
        }
    }
#undef lc
#undef rc
} seg1, seg2;

inline ull get_hash(ull h[], int l, int r) {
    return h[r] - h[l - 1] * powbase[r - l + 1];
}

inline int odd_palindrome(int p) {  // p是回文中心
    int l = 1, r = n + 1;
    while(l < r) {
        int mid = (l + r) >> 1;
        if(mid <= max(p, n - p + 1) &&
           get_hash(hval, p, p + mid - 1) ==
               get_hash(hrev, n - p + 1, n - p + mid))
            l = mid + 1;
        else
            r = mid;
    }
    return l - 1;
}

int main() {
    scanf("%s", &s0[1]);
    n = strlen(s0 + 1);
    *(ptr++) = '#';
    for(int i = 1; i <= n; i++) {
        *(ptr++) = s0[i];
        *(ptr++) = '#';
    }
    n = strlen(s + 1);

    powbase[0] = 1;
    for(int i = 1; i <= MAXN; i++) powbase[i] = powbase[i - 1] * base;
    for(int i = 1; i <= n; i++) hval[i] = hval[i - 1] * base + s[i];
    for(int i = 1; i <= n; i++) hrev[i] = hrev[i - 1] * base + s[n - i + 1];

    seg1.build_tree(1, 1, n);
    seg2.build_tree(1, 1, n);

    for(int i = 1; i <= n; i++) {
        int len;
        len = odd_palindrome(i);
        seg1.cover(1, 1, n, i, i + len - 1, -i + 1);
        seg2.cover(1, 1, n, n - i + 1, n - i + len, -n + i);
    }
    for(int i = 1; i <= n; i++) pre[i] = i + seg1.query(1, 1, n, i);
    for(int i = 1; i <= n; i++) suf[i] = i + seg2.query(1, 1, n, i);
    reverse(suf + 1, suf + n + 1);
    for(int i = 2; i <= n - 1; i++)
        if(s[i] == '#') ans = max(ans, pre[i - 1] + suf[i + 1]);
    printf("%d\n", ans);
    return 0;
}
```



---

## 作者：木木！ (赞：6)

做法也是 Manacher，但是和 dalao 们枚举切割点不太一样。

先定义回文串的“核”为回文串最中间的字符。两翼即为回文串去掉最中间字符之后的两个分串。显然，一个最长双回文串的长度就是 Manacher 形式下插入 `'#'` 过后的两个核之间的距离。

证明的话，定义“虚核”即核为字符 `'#'`，“实核”即不是虚核的核，然后分情况讨论。不管是实核还是虚核，在插入 `'#'` 过后两翼的长度就是原回文串长，而两个核的两翼会在最末端的 `'#'` 处重叠，所以不管是实核还是虚核还是一虚一实，两个核之间的距离都是两个回文串两翼长度相加，就是双回文串长。

所以，只需要在 Manacher 的时候对每一个位置维护一下两翼包含它的最小的核的位置就好了。~~根本不需要考虑什么极大回文串~~，在 Manacher 的过程中，找一下两翼能够触及到的最远的地方的那个位置被覆盖到的最远的核。

考虑每次循环的时候如何维护。可以发现，如果两翼覆盖到的字符中有一些已经有值，新的值必然比原来的值大。所以，每次循环的时候只会更新那些没有值的字符，而那些没有值的字符就是 Manacher 过程中 maxr 之外的字符。至此，我们已经可以 $\Theta(n)$ 维护了。

至于 `ababa` 这种出锅数据，只需要简单地将包含最开头的 `#` 的核的位置设置成 1 就好了。

至于优势，只需要额外扫一遍，常数较小（说得好像有人卡这点常数一样）

附 AC 代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

void chkmax(int& a,int b)
{
	if(a<b)
	{
		a = b;
	}
}

char inp[100005];
char str[200005];

int ri[200005];
int core[200005];

int manacher(int n)
{
	int ans = 0;

	int maxr = 0;
	int mid = 0;

	core[0] = 1;
	for(int i=1; i<n; ++i)
	{
		ri[i] = maxr<i ? 0 : min(maxr-i+1,ri[2*mid-i]);
		while(str[i+ri[i]] == str[i-ri[i]])
		{
			++ri[i];
		}
		
		chkmax(ans,i-core[i-ri[i]]); // 如果按照上面所写的，这里是两翼覆盖到的最前的位置，那么应该是 core[i-ri[i]+1]。但是，最末一个字符没有两翼，因此会出锅。所以，这里必须是两翼覆盖到的最前的位置 -1。容易证明，这样做不会影响答案。

		if(i+ri[i]-1 > maxr)
		{
			for(int j=maxr+1; j<i+ri[i]; ++j)
			{
				core[j] = i;
			}
			maxr = i+ri[i]-1;
			mid = i;
		}
	}

	return ans;
}

int main()
{
	scanf("%s",inp+1);

	int len = strlen(inp+1);
	for(int i=1; i<=len; ++i)
	{
		str[i*2-1] = inp[i];
		str[i*2] = '#';
	}
	str[len*2] = '$';
	str[0] = '#';

	printf("%d\n",manacher(len*2));
}
```

---

## 作者：chihik (赞：6)



显然是一道回文自动机板题。

设 $L[i]$ 表示以 $i$ 号点为左端点的最长回文串 ， $R[i]$ 表示以 $i$ 号点为右端点的最长回文串。

$L[i]$ 可以通过将回文串倒过来建自动机求得 ， $R[i]$ 可以直接用原回文串建自动机求得。

最后答案为

$$Ans=max(R[i]+L[i+1]) ~~~ (i<n-1)$$

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int MAXN = 100000 , MAXK = 26;
struct Palindrome_Automaton {
    int Size , Last , Root0 , Root1 , Trans[ MAXN + 5 ][ MAXK + 5 ] , Link[ MAXN + 5 ];
    int n , Str[ MAXN + 5 ];
    int Len[ MAXN + 5 ] , L[ MAXN + 5 ] , R[ MAXN + 5 ];

    void Init( ) {
        n = 0 , Size = 0;
        memset( Trans , 0 , sizeof( Trans ) );
        memset( Link , 0 , sizeof( Link ) );
        memset( Len , 0 , sizeof( Len ) );

        Root0 = Size ++ , Root1 = Size ++; Last = Root1;
        Len[ Root0 ] = 0  , Link[ Root0 ] = Root1;
        Len[ Root1 ] = -1 , Link[ Root1 ] = Root1;
    }
    
    int Extend( int ch ) {
        int u = Last; Str[ ++ n ] = ch;
        for( ; Str[ n ] != Str[ n - Len[ u ] - 1 ] ; u = Link[ u ] );
        if( !Trans[ u ][ ch ] ) {
            int Newnode = ++ Size , v = Link[ u ];
            Len[ Newnode ] = Len[ u ] + 2;
            for( ; Str[ n ] != Str[ n - Len[ v ] - 1 ] ; v = Link[ v ] );
            Link[ Newnode ] = Trans[ v ][ ch ]; Trans[ u ][ ch ] = Newnode;
        }
        Last = Trans[ u ][ ch ];
        return Len[ Last ];
    }
    void Build1( char *str ) {
        Init( );
        int len = strlen( str );
        for( int i = 0 ; i < len ; i ++ )
            R[ i ] = Extend( str[ i ] - 'a' + 1 );
    }
    void Build2( char *str ) {
        Init( );
        int len = strlen( str );
        for( int i = len - 1 ; i >= 0 ; i -- )
           L[ i ] = Extend( str[ i ] - 'a' + 1 );
    }

    int Calc( char *str ) {
        int Ans = 0 , len = strlen( str );
        for( int i = 0 ; i < len - 1 ; i ++ )
            Ans = max( Ans , R[ i ] + L[ i + 1 ] );
        return Ans;
    }
}PAM;

char str[ MAXN + 5 ];
int main() {
    scanf("%s", str );
    PAM.Build1( str );
    PAM.Build2( str );
    printf("%d", PAM.Calc( str ) );
    return 0;
}
```


---

## 作者：RicardoShips (赞：5)

学长讲过的$Manacher$例题，~~上课睡觉没听懂~~

开题的时候毫无思路，最后终于找到思路了

思路主要是枚举分界点，把这个点两边的最长回文串的长度拼起来

在每一次$Manacher$操作完成之后，我们可以顺便维护

- 以这个回文串的左端点为其左端点的最长回文串的长度

- 以这个回文串的右端点为其右端点的最长回文串的长度

事实上，这两个最长回文串的长度一定不小于这个回文串的长度

这样我们就可以在线性的时间复杂度里预处理出每个点左右的最长回文串的长度

预处理之后还要递推，大致就是不断地将之前回文串的长度$-$$2$取最大值

最后枚举每个#所在位置，不断更新$ans$取最大值

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[222222];
char t[222222];
int p[222222];
int l[222222];
int r[222222];
int n,k,o,ans;
int main()
{
    scanf("%s",t+1);n=strlen(t+1);
    for(register int i=1;i<=n;++i) s[i*2]=t[i],s[i*2+1]='#';
    s[0]=s[1]='#';n=n*2+2;s[n]='\0';
    for(register int i=0;i<n;++i)
    {
        p[i]=i<o?min(o-i,p[k*2-i]):1;
        while(s[i+p[i]]==s[i-p[i]]) ++p[i];
        if(i+p[i]>o) k=i,o=i+p[i];
        l[i+p[i]-1]=max(p[i]-1,l[i+p[i]-1]);
        r[i-p[i]+1]=max(p[i]-1,r[i-p[i]+1]); 
    }
    for(register int i=n-3;i>0;i-=2) l[i]=max(l[i],l[i+2]-2);
    for(register int i=3;i<n;i+=2) r[i]=max(r[i],r[i-2]-2);
    for(register int i=1;i<n;i+=2) if(l[i]&&r[i]) ans=max(ans,l[i]+r[i]);
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：scp020 (赞：4)

# P4555 [国家集训队] 最长双回文串 题解

补一个题解区没有的解法。

## 解法

通过哈希实现的线性做法，受讨论区启发。

考虑枚举双回文串的分割点，即分割点左右各是一个回文串，对于每个分割点，我们最大化两个回文串的长度，而且两个回文串是互不影响的。

问题转化为求原串的所有前缀的最长回文后缀和所有后缀的最长回文前缀。因为两个问题求法是类似的，所以这里只说如何求所有前缀的最长回文后缀。

我们记 $pre_i$ 表示前 $i$ 个字符组成的最长回文后缀。显然，$pre_i \le i$。再思考一下，可以发现 $pre_i \le pre_{i-1}+2$，因为回文中心不可能向左移动，否则 $pre_{i-1}$ 将会变得更大，不符合定义。我们可以从 $\min(i,pre_{i-1}+2)$ 开始向 $1$ 暴力枚举 $pre_i$，使用哈希 $\mathcal{O}(1)$ 检验。

乍一看，这个做法是暴力，不能保证复杂度。但发现每次 $pre$ 的上界只能增加 $2$，一共只能增加 $2n$，所以只会暴力检验 $\mathcal{O}(n)$ 次，所以总复杂度是线性。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
	#define Getchar() p1==p2 and (p2=(p1=Inf)+fread(Inf,1,1<<21,stdin),p1==p2)?EOF:*p1++
	char Inf[1<<21],*p1,*p2;
	inline bool inrange(const char &ch)
	{
		if(ch>=33 && ch<=126) return true;
		return false;
	}
	inline void read(std::string &st,char c=Getchar())
	{
		st.clear();
		while(!inrange(c)) c=Getchar();
		while(inrange(c)) st+=c,c=Getchar();
	}
};
using namespace fast_IO;
#define int long long
std::string st;
int pre[100010],suf[100010],n,has1[100010],has2[100010],pw[100010],ans;
const int base=131,p=998244353;
inline int cal1(const int l,const int r)
{
	if(l>r) return 0;
	return (has1[r]-has1[l-1]*pw[r-l+1]%p+p)%p;
}
inline int cal2(const int l,const int r)
{
	if(l>r) return 0;
	return (has2[l]-has2[r+1]*pw[r-l+1]%p+p)%p;
}
inline void solve()
{
	pre[1]=1;
	for(int i=2,len;i<=n;i++)
	{
		len=std::min(i,pre[i-1]+2);
		while(cal1(i-len+1,i)!=cal2(i-len+1,i)) len--;
		pre[i]=len;
	}
	suf[n]=1;
	for(int i=n-1,len;i;i--)
	{
		len=std::min(n-i+1,suf[i+1]+2);
		while(cal1(i,i+len-1)!=cal2(i,i+len-1)) len--;
		suf[i]=len;
	}
}
signed main()
{
	read(st),n=st.size(),st="#"+st,pw[0]=1;
	for(int i=1;i<=100000;i++) pw[i]=pw[i-1]*base%p;
	for(int i=1;i<=n;i++) has1[i]=(has1[i-1]*base+st[i]-'a'+1)%p;
	for(int i=n;i;i--) has2[i]=(has2[i+1]*base+st[i]-'a'+1)%p;
	solve();
	for(int i=1;i<n;i++) ans=std::max(ans,pre[i]+suf[i+1]);
	std::cout<<ans;
	return 0;
}
```

---

## 作者：xMinh (赞：3)

这是一篇蒟蒻的娱乐题解

### 显然

这个题只需要打一个马拉车板子

而且O(n)就能解出来

各位大爷的题解也都说的很详细了

### 但是

我作为一个强迫症患者

看到这个1e5的数据

怎么能不写个**非常严谨**的nlogn的做法呢？

看了这句话你们肯定想裱死我2333不过皮这一下我很开心

### 如何做到nlogn

好办，**加个log级别的数据结构**就行了

考虑线段树~~优化~~**劣化**复杂度

这个题中的最长双回文串可以看做两个回文串拼起来

我们先跑一遍马拉车

记录每个点为中心构成的回文串最左和最右分别能到达哪里，记为$L_i$和$R_i$

对于一个点$i$，如果以它为中心的最长回文串作为右边的回文串，那么我们可以找$j<i$而且$R_j>=L_i$的点来和它拼到一块

设重叠部分$R_j-L_i+1=x$

这样拼接起来的长度就是

$2*(p_i-x)-1+2*p_j-1$

因为要去掉分隔符所以长度除以2

式子就化成了

$p_i+L_i+p_j-R_j-2$

我们让$R$数组作为线段树的下标，每次在$R_i$加入$p_i-R_i-2$，维护最大值

然后就是用扫描线求二维最大值辣

### 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define BIG 1000000000
#define N 100010
using namespace std;
int tot,ans,T[N<<3],L[N<<1],R[N<<1],p[N<<1];
char data[N],s[N<<1];

void Manacher() {
	int mid=0,right=0,x=0;
	for (int i=1; i<=tot; i++) {
		if (i>right) x=1;
		else x=min(p[2*mid-i],right-i+1);
		while (s[i+x]==s[i-x]) x++;
		p[i]=x;
		if (i+x-1>right) {
			right=i+x-1;
			mid=i;
		} 
		L[i]=i-p[i]+1;
		R[i]=i+p[i]-1;
	} 
}

void Pushup(int x) {
	T[x]=max(T[x<<1],T[x<<1|1]);
}

void Build(int x,int l,int r) {
	if (l==r) {
		T[x]=-BIG;
		return;
	}
	int mid=(l+r)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
	Pushup(x);
}

void Change(int pos,int l,int r,int x,int val) {
	if (l==r) {
		T[x]=max(T[x],val);
		return;
	}
	int mid=(l+r)>>1;
	if (pos<=mid) Change(pos,l,mid,x<<1,val);
	else Change(pos,mid+1,r,x<<1|1,val);
	Pushup(x);
}

int Query(int L,int R,int l,int r,int x) {
	if (L<=l && r<=R) return T[x];
	int mid=(l+r)>>1;
	int res=-BIG;
	if (L<=mid) res=max(res,Query(L,R,l,mid,x<<1));
	if (R>mid) res=max(res,Query(L,R,mid+1,r,x<<1|1));
	return res;
}

int main() {
	scanf("%s",(data+1));
	int n=strlen(data+1);
	s[++tot]='@'; s[++tot]='#';
	for (int i=1; i<=n; i++) 
		s[++tot]=data[i],s[++tot]='#';
	s[++tot]='$';
	Manacher();
	Build(1,1,tot); 
	Change(R[2],1,tot,1,p[2]-R[2]-2);
	for (int i=3; i<=tot-1; i++) {
		int now=p[i]+L[i]+Query(L[i],tot,1,tot,1);
		ans=max(ans,now);
		Change(R[i],1,tot,1,p[i]-R[i]-2);
	}
	printf("%d",ans);
}
```

---

## 作者：LengChu (赞：2)

马拉车~

虽然知道它是道马拉车的题但是求出了l数组以后并没有思路2333

l数组就是i为中点的最长回文串的半径 （i本身也算在内）

可以求出left和right数组 意思是从左边（右边）过来的以i为终点（回文串包括i这个点）的最长回文串的半径

在求l数组的时候就可以很顺便的维护它~

但是我们发现维护它的时候 如果i是在中途截断了一个回文串 那就不会计算这个串的长度（毕竟不能每求一个l就把这整个回文串都扫一遍 时间复杂度太高）

也就是说求出一个回文串时只是顺便计算了该回文串两个端点的left和right 中间一连串的点并没有考虑

但是通过打表？ 可以发现 

left[i]=max(left[i+1]-1,left[i]) 

right[i]=max(right[i-1]+1,right[i])


然后我们就处理出了left和right数组~

用处也很显然了

枚举每一个‘#’（因为两个回文串是不会相互关联的 left和right数组中包含了i这个点 如果枚举不是‘#’的字符就会重复）

找到left+right最大的点

答案就是left+right-2 减掉的是重复计算的‘#’

不知道为什么是-2就手推一下吧 我也说不清楚（逃

```cpp
#include<bits/stdc++.h>
using namespace std;
char ss[100010],s[200010];
int len,l[200010],mid=1,r=1;
int le[200010],ri[200010];//从左边右边来的在这个点结束的最长回文串的半径 
int maxx,t;
int main()
{
	scanf("%s",ss); len=strlen(ss);
	s[0]='*'; len=2*len+1;
	for(int i=1;i<=len;i++)
	{
		if(i%2==1) s[i]='#';
		else s[i]=ss[i/2-1];
	}
	l[1]=1;
	for(int i=2;i<=len;i++)
	{
		if(i<r) l[i]=min(l[2*mid-i],r-i);
		else l[i]=1;
		while(s[i+l[i]]==s[i-l[i]]) l[i]++;
		if(i+l[i]>r) mid=i,r=l[i]+i; 
		if(i+l[i]-1<=len) le[i+l[i]-1]=max(le[i+l[i]-1],l[i]);
		if(i-l[i]+1>=1) ri[i-l[i]+1]=max(ri[i-l[i]+1],l[i]);
	}
	for(int i=1;i<=len;i++) ri[i]=max(ri[i],ri[i-1]-1);
	for(int i=len;i>=1;i--) le[i]=max(le[i],le[i+1]-1);
	for(int i=1;i<=len;i+=2)
	{
		if(le[i]+ri[i]>maxx)
		{
			maxx=le[i]+ri[i];
			t=i;
		}
	}
	printf("%d",maxx-2);
	return 0;
}
```


---

## 作者：xiayucc (赞：2)

一开始WA了好几发，看了题解发现思路是一样的

**PS（一点题外话）:
所有用马拉车的人不仅思路一样不奇怪，但是连做法和码风都完全一样，是让我很不解的  

不知道copy别人的代码还发题解是什么心态**

这道很水的题目的的确确改了我一个多小时，但是我不觉得我浪费了这一小时，他让我更熟悉了马拉车的用法

这题在我的知识范围内用回文树不会写，因为我掌握的回文树只能求出本质不同的回文串中其中一个的出现位置，所以选择了马拉车算法


------------

和其他各位大佬的题解思路是一样的 

在求马拉车的过程中我再维护了两个变量

一个 a[i] 表示以i结束的点的最长回文串长度

一个 b[i] 表示以i开始的点的最长回文串长度

然后在求出所有位置的a和b之后枚举所有可能性，求出最大值（ans）
    
    ans=max（ans，a[i]+b[i+1]）;
    
    为什么是a[i]+b[i+1]呢？
    因为我们要求出以i位置结尾的最长回文串和他下一个位置i+1开始的最长回文串长度
    
    下面放代码：
    
```c
	#include<stdio.h>
	#include <set>
	#include<map>
	#include<string.h>
	#include <cmath>
	#include <queue>
	#include <stack>
	#include <vector>
	#include <string>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	#include <iomanip>
	#include <iostream>
	#include <algorithm>
	#define FOR(i,a,b) for (int i=(a);i<(b);i++)
	using namespace std;
	typedef long long ll;
	const ll INF = 0x3f3f3f3f;
	const ll MOD=1000000007;
	#define in(a) scanf("%d",&(a))
	const int MAXN=100010;
	char Ma[MAXN*2];
	int Mp[MAXN*2];
	int a[MAXN],b[MAXN];
void Manacher(char s[],int len)
{
int l=0; Ma[l++]='$';
Ma[l++]='#';
for(int i=0;i<len;i++)
{
Ma[l++]=s[i];
Ma[l++]='#';
}
Ma[l]=0;
int mx=0,id=0;
for(int i=0;i<l;i++)
{
Mp[i]=mx>i?min(Mp[2*id-i],mx-i):1;
    if(i%2==1&&(Mp[i]-1)%2==0)//如果是为‘#’且长度是偶数的话就更新，这里必须加长度为偶数条件，不然会WA（我试过）
    {
        if(Mp[i]-1)//长度不为零才能更新
        {
            a[i/2+(Mp[i]-1)/2]=max(a[i/2+(Mp[i]-1)/2],Mp[i]-1);  // i/2+(Mp[i]-1)/2  是a的位置，这个需要你自己算，这里就不说怎么算得了，很简单的，下面也不说了
            b[i/2-(Mp[i]-1)/2+1]=max(b[i/2-(Mp[i]-1)/2+1],Mp[i]-1);
        }
    }
     else if(i%2==0&&(Mp[i]-1)%2==1)//如果是为‘字母’且长度是奇数的话就更新
    {
        if(Mp[i]-1)
        {
            a[i/2+(Mp[i]-1)/2]=max(a[i/2+(Mp[i]-1)/2],Mp[i]-1);
            b[i/2-(Mp[i]-1)/2]=max(b[i/2-(Mp[i]-1)/2],Mp[i]-1);
        }
    }
while(Ma[i+Mp[i]]==Ma[i-Mp[i]])
    {
        Mp[i]++;
        if(i%2==1&&(Mp[i]-1)%2==0)//这里和上面的更新是一样的，直接复制粘贴下来，因为马拉车在逐步扩大回文串长度的 所以过程中出来的也都是回文串，这个时候我们依然需要更新a和b数组
    {
        if(Mp[i]-1)
        {
            a[i/2+(Mp[i]-1)/2]=max(a[i/2+(Mp[i]-1)/2],Mp[i]-1);
            b[i/2-(Mp[i]-1)/2+1]=max(b[i/2-(Mp[i]-1)/2+1],Mp[i]-1);
        }
    }
    else if(i%2==0&&(Mp[i]-1)%2==1)
    {
        if(Mp[i]-1)
        {
            a[i/2+(Mp[i]-1)/2]=max(a[i/2+(Mp[i]-1)/2],Mp[i]-1);
            b[i/2-(Mp[i]-1)/2]=max(b[i/2-(Mp[i]-1)/2],Mp[i]-1);
        }
    }
    }


if(i+Mp[i]>mx)
{
mx=i+Mp[i]; id=i;
}

}
}
char s[MAXN];
int len;
int main()
{
scanf("%s",s);
len=strlen(s); Manacher(s,len);
int ans=0;
for(int i=1;i<len;i++)
{
    if(a[i]!=0&&b[i+1]!=0)
    ans=max(ans,a[i]+b[i+1]);
}
    cout<<ans<<endl;
return 0;
}

```

就是这样了，虽然看着代码很长，但是懂马拉车的人应该看的出来我只是魔改了一点点

我觉得我写的思路是一个用马拉车的常人都能想到的思路，所以聪明的你一定能看的懂我的代码






---

## 作者：Forsaken2020 (赞：1)

因为大家的常用做法想不出来，我又非常喜欢简单粗暴的做法，所以我来给大家介绍个暴力的O(nlogn)的做法。

首先我们一边马拉车可以知道以每个点为中心的回文串半径。然后我们假设左回文子串的**回文中心**为**id**,右回文子串的**回文中心**为**i**，那么对于每个右中心i，我们需要做的就是去查询一个左中心id，使得以id为中心的这个回文串可以和以i为中心的这个回文串相连，并且我们可以发现id位置越靠左越好，所以我们可以直接一棵线段树贪心的去找id。

找到id之后，我们可以发现新的双回文子串的长度是i - id， 所以更新答案就行了。但是当id == 1时可能得到一个单回文串，所以特判一下就好了。下面是代码：

```cpp
//author Eterna
#define Hello the_cruel_world!
#pragma GCC optimize(2)
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<string>
#include<cstring>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<utility>
#include<cmath>
#include<climits>
#include<deque>
#include<functional>
#include<numeric>
#define max(x,y) ((x) > (y) ? (x) : (y))
#define min(x,y) ((x) < (y) ? (x) : (y))
#define ABS(x) ((x) >= 0 ? (x) : (-(x)))
#define pb(x) push_back(x)
#define lowbit(x) ((x) & (-(x)))
#define FRIN freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\in.txt", "r", stdin)
#define FROUT freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\out.txt", "w", stdout)
#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define outd(x) printf("%d\n", x)
#define outld(x) printf("%I64d\n", x)
#define memset0(arr) memset(arr, 0, sizeof(arr))
#define il inline
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int maxn = 1e5;
const int INF = 0x7fffffff;
const int mod = 1e9 + 7;
const double eps = 1e-7;
const double Pi = acos(-1.0);
inline int read_int() {
	char c;
	int ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
inline ll read_ll() {
	char c;
	ll ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
char p[maxn + 5], s[2 * maxn + 5];
int m, n, len[2 * maxn + 5], res;
int manacher() {
	int id = 0, max_len = 0, res = 0;
	s[0] = '@';
	for (int i = 1; i <= 2 * m; i += 2)s[i] = '#', s[i + 1] = p[i / 2];
	s[2 * m + 1] = '#';
	s[2 * m + 2] = '\0';
	n = 2 * m + 1;
	for (int i = 1; i <= n; ++i) {
		if (max_len > i)len[i] = min(max_len - i, len[2 * id - i]);
		else len[i] = 1;
		while (s[i + len[i]] == s[i - len[i]])++len[i];
		if (len[i] + i > max_len) {
			max_len = len[i] + i;
			id = i;
		}
		res = max(res, len[i]);
	}
	return res;
}
int arr[8 * maxn + 5];
il void Push_Up(int index) {
	arr[index] = max(arr[2 * index], arr[2 * index + 1]);
}
void Build(int index, int L, int R) {
	arr[index] = -INF;
	if (L == R)return;
	int mid = L + R >> 1;
	Build(2 * index, L, mid);
	Build(2 * index + 1, mid + 1, R);
}
void update(int index, int L, int R, int pos, int value) {
	if (L == R) {
		arr[index] = value;
		return;
	}
	int mid = L + R >> 1;
	if (mid >= pos)update(2 * index, L, mid, pos, value);
	else update(2 * index + 1, mid + 1, R, pos, value);
	Push_Up(index);
}
int Query(int index, int L, int R, int value) {
	if (arr[index] < value)return 0;
	if (L == R)return L;
	int mid = L + R >> 1;
	if (arr[2 * index] >= value)return Query(2 * index, L, mid, value);
	else if (arr[2 * index + 1] >= value)return Query(2 * index + 1, mid + 1, R, value);
}
int main()
{
	scanf("%s", p);
	m = strlen(p);
	manacher();
	Build(1, 1, n);
	for (int i = 1; i < n; ++i) {
		int pos = i - len[i];
		int id = Query(1, 1, n, pos);
		update(1, 1, n, i, i + len[i] - 1);
		if (id == 0 || id == 1)continue;
		else res = max(res, len[i] + pos - id);
	}
	cout << res << endl;
	return 0;
}
```


---

## 作者：qiyue7 (赞：1)

来一发回文树的题解，枚举切割点n两侧最长回文串的长度已经是很经典的操作了，那么这里主要就是分享下模板w

```java
// luogu-judger-enable-o2
import java.math.BigInteger;
import java.util.*;
import java.io.*;

public class Main {

    public static InputReader in = new InputReader(System.in);
    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    public static void main(String[] args)
    {
        String s;
        s=in.next();
        Palindromic_Tree a=new Palindromic_Tree(s.length()+10);
        Palindromic_Tree b=new Palindromic_Tree(s.length()+10);
        a.init();
        b.init();
        int k1[]=new int[s.length()+10];
        int k2[]=new int[s.length()+10];
        Arrays.fill(k1,0);
        Arrays.fill(k2,0);
        for(int i=0;i<s.length();++i)
        {
            k1[i+1]=a.add(s.charAt(i));
            k2[i+1]=b.add(s.charAt(s.length()-i-1));
        }
        int ans=0;
        for(int i=1;i<s.length();++i)
            ans=Math.max(ans,k1[i]+k2[s.length()-i]);
        out.println(ans);
        out.flush();
        out.close();
    }
}
class Palindromic_Tree
{
    int len[]; //以节点i为结尾的回文串的长度
    int str[];//第i次添加的字符
    int last;//
    int point;//
    int n;
    int Next[][];//
    int fail[];//类似于AC自动机的fail指针，指向失配后需要跳转到的节点（即为i的最长回文后缀且不为i）
    int count[];//节点i表示的回文串在S中出现的次数（建树时求出的不是完全的，count()加上子节点以后才是正确的）
    int num[];//以节点i回文串的末尾字符结尾的但不包含本条路径上的回文串的数目。(也就是fail指针路径的深度)
    Palindromic_Tree(int N)
    {
        n=N;
        len=new int[N];
        str=new int[N];
        fail=new int[N];
        count=new int[N];
        num=new int[N];
        Next=new int[N][26];
    }
    int newnode(int l)
    {
        for (int i = 0; i < 26; ++i)
            Next[point][i] = 0;
        count[point] = 0;
        num[point] = 0;
        len[point] = l;
        return point++;
    }
    void init()
    {
        Arrays.fill(len,0);
        Arrays.fill(str,0);
        Arrays.fill(fail,0);
        Arrays.fill(count,0);
        Arrays.fill(num,0);
        for(int i=0;i<n;++i)
            Arrays.fill(Next[i],0);
        point = 0;
        newnode(0);
        newnode(-1);
        last = 0;
        n = 0;
        str[n] = -1;
        fail[0] = 1;
    }
    int get_fail(int x)
    {
        while (str[n - len[x] - 1] != str[n])
            x = fail[x];
        return x;
    }
    int add(int c)
    {
        c -= 'a';
        str[++n] = c;
        int cur = get_fail(last);
        if (Next[cur][c]==0)
        {
            int now = newnode(len[cur] + 2);
            fail[now] = Next[get_fail(fail[cur])][c];
            Next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
        last = Next[cur][c];
        count[last]++;
        return len[last];
    }
    void counting()//统计本质相同的回文串的出现次数
    {
        for (int i = point-1; i >= 0; i--)//逆序累加，保证每个点都会比它的父亲节点先算完，于是父亲节点能加到所有子孙
            count[fail[i]] += count[i];
    }
}
class manacher
{
    int cnt, len, ans = 0;
    char ss[],s[];
    int p[];
    manacher(String str)
    {
        s=str.toCharArray();
        ss=new char[s.length*2+10];
        p=new int[s.length*2+10];
    }
    void init() {//将每两个字符中插入一个字符
        len = s.length;
        cnt = 1;
        ss[0] = '!';
        ss[cnt] = '#';
        for (int i = 0; i < len; i++)
        {
            ss[++cnt] = s[i];
            ss[++cnt] = '#';
        }
        ans = 0;
    }

    void manacher1() {
        int pos = 0, mx = 0;
        for (int i = 1; i <= cnt; i++) {
            if (i < mx) p[i] = Math.min(p[pos * 2 - i], mx - i);
            else p[i] = 1;
            while (ss[i + p[i]] == ss[i - p[i]]) p[i]++;
            if (mx < i + p[i])
            {
                mx = i + p[i];
                pos = i;
            }
            ans = Math.max(ans, p[i] - 1);
        }
    }
}


class InputReader{
    private final static int BUF_SZ = 65536;
    BufferedReader in;
    StringTokenizer tokenizer;
    public InputReader(InputStream in) {
        super();
        this.in = new BufferedReader(new InputStreamReader(in),BUF_SZ);
        tokenizer = new StringTokenizer("");
    }
    public boolean hasNext() {  //处理EOF
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                String line = in.readLine();
                if(line == null) return false;
                tokenizer = new StringTokenizer(line);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return true;
    }
    public String next() {
        while (!tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(in.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }
    public int nextInt() {
        return Integer.parseInt(next());
    }
    public long nextLong()
    {
        return Long.parseLong(next());
    }
}
```


---

## 作者：吾王美如画 (赞：1)

# 唔姆

最近刚学了manacher，想着来做几道题

-------------
前置芝士[Manacher算法](https://www.luogu.org/problemnew/show/P3805)

- 根据manacher算法，我们可以知道以每个字符为中心的最长回文子串的半径（rad数组）。

- 但我们发现，如果看中心的话，很难进行转移。于是我们记录一个sta，和end数组，表示以i开始的最大回文子串的长度和以i结束的最大回文子串的长度。这个在我们求rad数组时可以求出来每个中心对应的最大回文子串的两个端点的sta和end，中间剩下的等下可以O（n）推出（这个看代码就没问题了

- 既然知道了每个点的sta和end，我们很快可以像到，在manacher中，我们在原字符之间插入了许多无关字符。这时我们只需扫描这些字符，找到最大的（sta[i]+end[i]),也就是把两个回文子串拼起来。这就是答案了

```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm> 
#define MAXN 410000
using namespace std;
int rad[MAXN],n;
char s[MAXN],ch[MAXN];
int sta[MAXN],end[MAXN]; 
int mr=-1,c;
void find(int x,int y){
    int i=y;
    for(;(x-i)>=0&&(x+i)<=2*n;i++){
        if (s[x-i]!=s[x+i])break;
    }
    rad[x]=i;
}
int main(){
    s[0]='#';
    cin>>ch+1;
    n=strlen(ch+1);
    for(int i=1;i<=n;i++){
        s[2*i-1]=ch[i];
        s[2*i]='#'; 
    }
    int ans=0;
    memset(end,0,sizeof(end));
    memset(sta,0,sizeof(sta));
    memset(rad,0,sizeof(rad));
    for(int i=0;i<=n*2;i++){
        if (i>mr) find(i,0);
        else {
            int cl,p2,pl;
            cl=c-(mr-c);
            p2=c-(i-c);
            pl=p2-rad[p2]+1;
            if (pl>cl){
                rad[i]=rad[p2];
            }
            else if (pl<cl){
                rad[i]=mr-i+1;
            }
            else {
                find(i,mr-i+1);
            }
        }
        if (i+rad[i]-1>mr){
            mr=i+rad[i]-1;
            c=i;
        }
        if (i+rad[i]-1<=2*n){
            end[i+rad[i]-1]=max(end[i+rad[i]-1],rad[i]-1);
        }
        if (i-rad[i]+1>=0){
            sta[i-rad[i]+1]=max(sta[i-rad[i]+1],rad[i]-1);
        }
    }
    for(int i=2;i<2*n;i=i+2){
        sta[i]=max(sta[i],sta[i-2]-2);
        end[i]=max(end[i],end[i+2]-2);
    }
    
    for(int i=2;i<2*n;i=i+2){
        ans=max(ans,sta[i]+end[i]);
    }
    cout<<ans<<endl;
    return 0;
}
```


---


# 魔鬼杀手

## 题目背景

你生活在一个怪兽世界里。

你需要用魔法反抗这些怪兽。

## 题目描述

每个怪兽都有一定的生命值。

你可以靠施魔法，减少怪兽的生命值。

每个魔法都会有一定的伤害，表示用该魔法进行一次攻击能使得被攻击者的生命值减少的数量。

一个怪兽被击败了当前仅当它的生命值小于等于 $0$。

魔法是要消耗魔力的。

因为你的魔力是有限的，你希望用最少的魔力击败所有的怪兽。

写一个程序完成这个任务。

## 样例 #1

### 输入

```
3
8000 15000 30000
3
Flare 45 Single 8000
Meteor 62 All 6000
Ultimate 80 All 9999```

### 输出

```
232```

# 题解

## 作者：Sooke (赞：8)

## 思路概述

极坑，细节极多，这是对本题的概括 = . =

读完题后，首先发现一个性质：**用相同攻击方式杀敌，结果与顺序没有关系**。

如何理解？通俗地说，如果现在有 3 个怪兽，我们使用 法术 1 群体攻击 一次，接着用 法术 2 对 怪兽 1 单体攻击 一次，最后再用 法术 1 群体攻击 一次。假设 3 只怪兽都在这样的攻击下全部阵亡了，那么我们直接使用 法术 1 群体攻击 两次，最后才用 法术 2 对 怪兽 1 单体攻击，效果仍然是一样的。这样，我们就可以将杂乱的攻击方式整理成：**先放 群体攻击，再放 单体攻击**。

算法已经很显然了，群体攻击的伤害对任何怪兽都是有效的，如果仍有怪兽在群体攻击下没有死，我们再耗费法力用单体攻击补个刀。群体攻击的所有伤害，我们可以从 0（不群体攻击）到 100000（怪兽最大的血量）枚举，加上枚举量所需最小花费，再依次看每只怪兽有无血量剩余，有的话放一个该剩余血量的单体攻击，再加上单体攻击最小花费。

这是最后的过程而已。我们之前需要预处理一下。先给法术分类。我们设 $f_i$ 为 要作出**刚好（不多不少）** $i$ 的群体伤害所需最小花费。这个过程我们可以用完全背包求解（因为同个法术可以施展多次。将类别为 群体伤害 的法术当做一个物品，请自行思考转移方程和依据是什么，应该不难看出）。类似地，设 $v_i$ 为 要作出**至少（可以多不能少）** $i$ 的单体伤害所需最小花费，之所以是至少而不是刚好，是因为对于一只在群体伤害下仍然坚强活着的 血量 3 的怪兽，不论使用 3 的单体攻击，还是 4 啊 100000 啊，他都得死。这个过程仍旧使用完全背包，不同之处是背包做完后还要逆序转移最小值一遍。

上面就是这道题的主要解法了。然而你以为这就能过了吗？本题坑点还多着~详见下面。

## 注意事项

- 坑点 1，统计和做背包的数组用 long long，并且初始化什么的要设的恰好，反正我是 $(long long)1 << 50$。

- 坑点 2，注意有耗费为 0 的法术，此时如果它伤害大于 0，就用它了呗！直接输出 0 退出程序。

- 坑点 3，有伤害等于 0 的法术，此时需要过滤。

- 坑点 4，有伤害大于 100000 的法术，出于怪兽的血量最多也就 100000，将那个法术的伤害削成 100000，效果相同。

- 值得注意的就上面这些坑点了，如果还有第 5 个坑点，应该是您代码的问题了吧……

## 代码实现

（注：已经小小修改了一个地方，不要直接复制交上去了）

```cpp
#include <iostream>
#include <cstring>

using namespace std;

int n , m , a[101] , b[101] , c[101];
long long res , ans = (long long)1 << 50 , f[100001] , v[100001];
bool u[101];
string s;

int main(){
    cin >> n; // 输入怪兽数量 
    for(int i = 1 ; i <= n ; i++)
        cin >> a[i]; // 输入每个怪兽的血量 
    cin >> m; // 输入法术数量
    for(int i = 1 ; i <= m ; i++){
        cin >> s; // 输入（没有用的）法术名字
        cin >> b[i]; // 输入法术花费
        cin >> s; // 输入法术类型
        u[i] = (bool)(s == "A11"); // 将法术类型转换成逻辑值
        cin >> c[i]; // 输入法术伤害
        if(c[i] == 0){
            i-- , m--; // 法术没有伤害，可以废掉 
            continue;
        }
        if(c[i] > 100000)
            c[i] = 100000; // 法术伤害过高，削掉一点 
        if(b[i] == 0){
            cout << 0 << endl; // 花费为 0 伤害不为 0，很坑，直接免费用完 
            return 0;
        }
    } // 上面的输入完全可以缩成一行啊 QAQ
    // f[i] 表示群体伤害时刚好伤害 i 血最小花费
    // v[i] 表示单体伤害时至少伤害 i 血最小花费（两个不一样！） 
    for(int i = 1 ; i <= 100000 ; i++)
       f[i] = v[i] = (long long)1 << 50; // 初始化 
    for(int i = 1 ; i <= m ; i++)
        if(u[i]) // 确定为群体伤害 
            for(int j = c[i] ; j <= 100000 ; j++)
                if(f[j] > f[j - c[i]] + b[i])
                    f[j] = f[j - c[i]] + b[i]; // 跑一遍完全背包（法术可以放多次） 
    for(int i = 1 ; i <= m ; i++)
        if(!u[i]) // 确定为单体伤害 
            for(int j = c[i] ; j <= 100000 ; j++)
                if(v[j] > v[j - c[i]] + b[i])
                    v[j] = v[j - c[i]] + b[i]; // 再跑一遍完全背包，注意数组不同 
    for(int j = 99999 ; j >= 0 ; j--)
        if(v[j] > v[j + 1])
            v[j] = v[j + 1]; // 造成 j+1 点伤害，其实也造成了至少 j 点伤害，可以转移 
    // 最后，我们枚举群体伤害有多少，剩下打不死就用个体伤害咯 
    for(int i = 0 ; i <= 100000 ; i++){
        res = f[i]; // 群体伤害所需最小花费
        for(int j = 1 ; j <= n ; j++)
            if(a[j] - i > 0)
                res += v[a[j] - i]; // 打不死，用个体伤害，还要多的花费
        if(ans > res)
            ans = res; // 更新最小总花费 
    }
    cout << ans << endl; // 输出最小总花费 
    return 0;
}
```

---

## 作者：xqh07 (赞：3)

算法：背包 $dp$

## 指导思想：

考虑到按照不同顺序攻击结果不会改变，不妨
**先用集体攻击将怪打残，再用个体攻击补刀。**

## 具体思路：

考虑 $dp$ 数组 $f$ , $f_i$ 表示**使用群体攻击造成伤害为 $i$（不多不少）耗费的最少魔力。**

考虑 $dp$ 数组 $g$ , $g_i$ 表示**使用个体攻击造成伤害至少为 $i$（可多不可少）耗费的最少魔力。**（这两个数组均由完全背包求解）

将**群体攻击**的伤害从 $1$ ~ $200000$ 依次枚举，加上**所需最小花费**，再依次看每只怪兽有无血量剩余，若有，则释放一个造成同等血量伤害的**单体攻击**，再加上该单体攻击**最小花费** 。

以上，为此题的具体思路。

## 注意事项：

- 坑点1，若有两个伤害为 $99999$ 的群体攻击， 相加后伤害会大于 $100000$ , 这种情况是会对答案产生影响的，故数组大小要设到 $200005$ 。

- 坑点2，伤害非零且耗费魔力为零，直接输出 $0$ , 退出程序。

- 坑点3， $g_i$ 表示的是伤害**至少**为 $i$ 时的最小花费。故后面还要进行一次**倒序**转移最小值一遍。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[105], b[105], c[105];
long long res, ans = (long long)1 << 50, f[2000005], g[2000005];
bool u[105];// 群体攻击还是个体攻击 
string s, t;
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);// 怪的血量 
	scanf("%d", &m);
	for(int i = 1; i <= m; i++)
	{
		cin >> s >> b[i] >> t >> c[i];
		if(t == "All")// 标记为群体攻击 
			u[i] = 1;
		if(!b[i] && c[i]) // 免费的午餐 
		{
			printf("0\n");
			return 0;
		}
		c[i] = min(c[i], 200000);// 稍微削减伤害 
	}
	for(int i = 1; i <= 200000; i++)
		f[i] = g[i] = (long long)1 << 50;// 初始化 
	for(int i = 1; i <= m; i++)// 群体攻击 
	{
		if(u[i])
		{
			for(int j = c[i]; j <= 200000; j++)
				f[j] = min(f[j], f[j - c[i]] + b[i]);
		}
	}
	for(int i = 1; i <= m; i++)// 个体攻击 
	{
		if(!u[i])
		{
			for(int j = c[i]; j <= 200000; j++)
			{
				g[j] = min(g[j], g[j - c[i]] + b[i]);
			}
		}
	}
	for(int i = 199999; i >= 0; i--)// 逆序转移 
	{
		if(g[i] > g[i + 1])
			g[i] = g[i + 1];
	}
	for(int i = 0; i <= 200000; i++)// 枚举群体攻击伤害 
	{
		res = f[i];
		for(int j = 1; j <= n; j++)
		{
			if(a[j] - i > 0)// 个体攻击补刀 
				res += g[a[j] - i];
		}
		ans = min(ans, res);
	}
	printf("%lld\n", ans);// 愉快输出 
    return 0;
}
// hjz AK IOI 
```


---

## 作者：Aleph1022 (赞：3)

这题很容易想到一个做法：
> 先用团体攻击把怪打残，再用单体攻击补刀。

辣么，我们就开两个数组，$f$和$g$，$f_i$表示使用团体攻击打$i$滴血至少用的$mp$，$g_i$同样，不过是使用单体攻击。

最后枚举团体攻击造成的伤害，统计答案。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
struct note
{
	int mp,dmg;
	bool tar;
} skill[110];
int n,m,hp[110],f[100010],g[100010],mini = 0x3f3f3f3f,tmp,maxi;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	memset(f,-1,sizeof f);
	memset(g,-1,sizeof g);
	f[0] = 0;
	cin >> n;
	for(register int i = 1;i <= n;++i)
	{
		cin >> hp[i];
		maxi = max(maxi,hp[i]);
	}
	cin >> m;
	for(register int i = 1;i <= m;++i)
	{
		string tar,name;
		cin >> name >> skill[i].mp >> tar >> skill[i].dmg;
		skill[i].tar = (tar == "All");
		if(skill[i].mp == 0)
		{
			cout << 0;
			return 0;
		}
	}
	for(register int i = 1;i <= maxi;++i)
		for(register int j = 1;j <= m;++j)
			if(skill[j].tar)
				if(i >= skill[j].dmg && f[i - skill[j].dmg] != -1)
				{
					if(f[i] == -1)
						f[i] = f[i - skill[j].dmg] + skill[j].mp;
					else
						f[i] = min(f[i],f[i - skill[j].dmg] + skill[j].mp);
				}
				else
				{
					if(f[i] == -1)
						f[i] = skill[j].mp;
					else
						f[i] = min(f[i],skill[j].mp);
				}
	for(register int i = 1;i <= maxi;++i)
		for(register int j = 1;j <= m;++j)
			if(!skill[j].tar)
				if(i >= skill[j].dmg)
				{
					if(g[i] == -1)
						g[i] = g[i - skill[j].dmg] + skill[j].mp;
					else
						g[i] = min(g[i],g[i - skill[j].dmg] + skill[j].mp);
				}
				else
				{
					if(g[i] == -1)
						g[i] = skill[j].mp;
					else
						g[i] = min(g[i],skill[j].mp);
				}
	for(register int i = 1;i <= maxi;++i)
	{
		if(f[i] == -1)
			continue;
		tmp = f[i];
		for(register int j = 1;j <= n;++j)
			if(hp[j] > i && g[hp[j] - i] != -1)
				tmp += g[hp[j] - i];
		mini = min(mini,tmp);
	}
	cout << mini;
}
```

---

## 作者：NightTide (赞：2)

## PART 0：吐槽
老规矩，开头先吐槽一下这个题目。坑点太多了，而且第三个点还得开无符号长整型才能过（也有可能是我写的不太优秀）。

接下来放正片

## PART 1：解题思路
~~从题目中可以看出，这类似于一个卡牌策略类的回合战斗游戏，那么根据我们玩游戏的经验，肯定是先用群体攻击，最后再补刀。~~（用力划掉）

很显然的，这是一个完全背包问题。我们可以把魔法当做物品，怪物的生命值当做背包，其中群体攻击是往所有背包中加入一个物品，而单体攻击只往一个背包中加入物品，要求将背包填满。并且，放入物品的顺序与最终的消耗没有关系，因此，我么可以先处理群体攻击，最后再一个个得物品放入将背包填满。但是，这与背包有不同，我们最终造成的伤害是可以大于怪物的总 PH 值的。

我们可以开两个数组 $group$ 和 $monomer$ 分别代表群体攻击和单体攻击的最小花费。$group_i$ 表示 **恰好造成 $i$ 的群体伤害** 时最小的花费，而 $monomer_i$ 表示 **至少造成 $i$ 伤害** 时最小的花费。

注意到区别了吗？由于单体伤害可以超过当前的攻击对象的生命值，因此是 **至少**造成 $i$ 的伤害，而群体攻击则需要求准确值，因此是 **恰好** 造成 $i$ 的伤害。

理解了这个，我们就很容易得到递推公式了：
$$group_i=\min(group_i,group_{(i-danage_j)}+mp_i)$$
$$monome_i=\min(monome_i,monome_{(i-danage_j)}+mp_i,monome_{(i+1)})$$

其中 $danage$ 和 $mp$ 的含义如题，分别是魔法的攻击力和消耗的魔力。

到了这里，最终的结果也就近在眼前了，只需要从 $1 \sim 200000$ 枚举 $group_i$，枚举每一个怪物，求出补刀还需要多少魔力，相加取最小值就可以了。关于为什么枚举到 $200000$，后面会讲。

然而，你以为你这就可以说 I AK MONSTER 了吗？不不不，你还差的远了，接着往下看。
## PART 2：坑点
这道题目最毒瘤的就是它的坑点极多，而且极其隐蔽，很难不踩坑、

#### 坑点1：有 0 消耗但是有攻击力的魔法
像这种情况，我们可以直接无脑使用这种魔法，一直到把怪 AK。所以，我们可以在读入的时候就判断好，直接输出 $0$ 即可。（免费的午餐.jpg）
#### 坑点2：有 0 攻击力的魔法
上面提到了免费的午餐，这里就是做慈善的情况了，消耗魔力不造成任何效果，直接略过这种魔法不存即可。（对方免疫了你的攻击并鄙视了你一下）
#### 坑点3：3 号测试点答案要开到 unsigned long long
这个没什么好说的，如题。
#### 坑点4：有攻击力极高的魔法（$danage_i \gt 100000$）
题目中给出了怪物生命值最多为 $100000$，因此，这种攻击力高于 $100000$ 的核弹流法术可以直接看成攻击力为 $100000$。但是由于最终可能存在两种法术的伤害相加可能大于 $100000$（比如 $99999+99999$），这样最大可以到 $200000$ 左右，即 $100000 \sim 200000$ 范围内，的法术伤害也会对前面的结果有影响，所以背包要开到 $200000$。前面的枚举范围也是如此。

## PART 3：AC 代码
做到这里，你可以真正地说 I AK MONSTER 了，下面是 AC 代码，不懂的代码里有注释
```cpp
#include<bits/stdc++.h>
#define max_att 200000
#define INF 1e18
using namespace std;
struct magic{
    string name;
    string type;
    int damage,mp;
    bool isgt;//判断是不是群体攻击魔法
};

magic maho[110];//存魔法的各种参数
int n,m;
unsigned long long ans=INF;
int monster[110];
long long mon[max_att+10],gro[max_att+10];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&monster[i]);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        cin>>maho[i].name>>maho[i].mp>>maho[i].type>>maho[i].damage;
        maho[i].isgt=(bool)(maho[i].type=="All");
        if(maho[i].damage==0){
            i--;m--;//略过慈善魔法
        }else if(maho[i].mp==0){
            //免费的午餐
            printf("0\n");
            exit(0);
        }
        //处理核爆流魔法
        maho[i].damage=min(maho[i].damage,max_att);
    }
    //两次背包求出群体和单体的最小花费
    memset(mon,0x7f,sizeof(mon));
    memset(gro,0x7f,sizeof(gro));
    mon[0]=gro[0]=0;
    for(int i=1;i<=m;i++){
        if(maho[i].isgt){
            for(int j=maho[i].damage;j<=max_att;j++){
                gro[j]=min(gro[j],gro[j-maho[i].damage]+maho[i].mp);
            }
        }
    }
    for(int i=1;i<=m;i++){
        if(!maho[i].isgt){
            for(int j=maho[i].damage;j<=max_att;j++){
                mon[j]=min(mon[j],mon[j-maho[i].damage]+maho[i].mp);
            }
        }
    }
    //注意这里要逆序在遍历一次，因为mon数组是求至少造成i伤害时的最小花费
    for(int i=max_att-1;i>=0;i--){
        mon[i]=min(mon[i],mon[i+1]);
    }
    //开始刷怪
    for(int i=0;i<=max_att;i++){
        //群攻
        unsigned long long res=gro[i];
        for(int j=1;j<=n;j++){
            //补刀
            if(monster[j]-i>0){
                res+=mon[monster[j]-i];
            }
        }
        ans=min(ans,res);
    }
    printf("%llu\n",ans);
    return 0;
}
```
## 广告
推销 [我的博客](https://www.luogu.com.cn/blog/Michaela-chr/)

---

## 作者：Mine_King (赞：2)

首先，很明显的一点就是，交换两次攻击的顺序，结果是不会变的，因为 $a-b-c=a-c-b$。那么，我们可以先做完群体攻击，再做单个的攻击。   
那么，对于群体/单个攻击造成 $i$ 点或 $i$ 点以上的攻击最少需要的魔力，我们可以用背包来求。这里，由于后面要进行单个攻击，所以群体攻击求的是准确的造成 $i$ 点攻击需要的魔力，而对于单个攻击，最后造成 $i$ 点或 $i$ 点以上的攻击，都能打败怪物，所以要求的是造成 $i$ 点或 $i$ 点以上的攻击需要的魔力。  
然后，求完这些之后，我们就可以直接枚举群体造成了多少伤害，然后再求群体伤害后打死每个怪物所需的单体伤害的魔力，最后加起来就是答案。  
记得取最小值。

另外，群体伤害造成的伤害也可能是0。

另外还有一些坑点：

- 攻击力为 $0$ 的魔法可以直接省略。
- 如果有消耗为 $0$ 攻击力不为 $0$ 的魔法，直接输出 $0$。
- 攻击力大于 $100000$ （最大的怪兽血量）的魔法要削成 $100000$。
- 由于大于 $100000$ 的伤害需要的魔力的答案可能会影响前面的，所以背包要做到 $200000$。

然后，就可以快乐地敲代码了。
```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
int n,m,hp[105],mp[105],damage[105];
bool target[105];
long long ans=(long long)1<<50,all[200005],single[200005];
//ans是答案，all是群体伤害需要的魔力，single是单个伤害需要的魔力，其他如题目所述。
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&hp[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		string s;
		cin>>s;
		scanf("%d",&mp[i]);
		cin>>s;
		target[i]=(bool)(s=="All");
		scanf("%d",&damage[i]);
		if(damage[i]>200000) damage[i]=200000;
		if(mp[i]==0&&damage[i]>0)
		{
			printf("0\n");
			return 0;
		}
		if(damage[i]==0) i--,m--;
	}
	for(int i=1;i<=200000;i++) all[i]=single[i]=(long long)1<<50;
	for(int i=1;i<=m;i++)//两个背包
		if(target[i])
		{
			for(int j=damage[i];j<=200000;j++)
				if(all[j]>all[j-damage[i]]+mp[i])
					all[j]=all[j-damage[i]]+mp[i];
		}
		else
		{
			for(int j=damage[i];j<=200000;j++)
				if(single[j]>single[j-damage[i]]+mp[i])
					single[j]=single[j-damage[i]]+mp[i];
		}
	for(int i=199999;i>=0;i--)
		if(single[i]>single[i+1]) single[i]=single[i+1];
	for(int i=1;i<=200000;i++)//枚举
	{
		long long res=all[i];
		for(int j=1;j<=n;j++)
			if(hp[j]>i) res+=single[hp[j]-i];
		if(res<ans) ans=res;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 思路

首先是证明操作的可交换性。

这里不证明其他的，就证明最重要的部分：若给出群体攻击 $A,B$，单体攻击 $C$。若对单体 $i$ 使用 $C$ 后对群体使用 $A,B$，可以消灭所有怪物，则先使用群体攻击 $A,B$ 然后再对单体 $i$ 使用 $C$ 也定可以消灭所有怪物。

- 若 $i$ 的 $hp$ 在 $C$ 后不是所有（存活的）怪物中的最大值，那么 $A,B$ 的 $damage$ 和一定大于 $hp-damage_C$。故按第二种攻击方法也可以清场。

- 若 $i$ 的 $hp$ 在 $C$ 后是所有（存活的）怪物中的最大值，那么 $A,B$ 的 $damage$ 和一定大于等于 $hp-damage_C$。故按第二种攻击方法也可以清场。

将上面的 $A,B$ 替换为单独的 $A$ 即可证明最基本情况。证明了最基本情况后对于任意的单体/群体技能组合都是可以证明可行的。



证明完毕。

---

现在我们考虑选法。$f_{i}$ 表示对群体恰好造成i伤害的最小花费，$g_i$ 表示对单体造成**至少** $i$ 伤害的最小花费。

先考虑这样做的意义。有了 $f,g$，那么我们就可以 $O(damage_{\text{max}})$ 枚举 $f_i$，然后 $O(N)$ 计算答案（枚举每个怪物，用 $g$ 来 $O(1)$ 累加进答案）。这样的复杂度是可以接受的。

---

现在考虑预处理 $g,f$。

嗯？$n$ 个物品，每个物品有价值和代价。求取到 $1\sim damage_{\text{max}}$ 的所有价值的最小代价。妥妥的完全背包啦（惯性思维 $01$ 背包背了半天发现是完全背包）。

至于 $f$ 的“至少”，倒序 $\min$ 一遍即可。

## 代码

```C++
/*
Edit by Ntsc.
*/

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define pf first
#define ps second

#define rd read()
#define ot write
#define nl putchar('\n')
inline int rd{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out){
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=1e6+5;
const int M=5e4+5;
const int INF=2e18+5;
const int MOD=1e9+7;
const int BASE=17737;
bool f1;
int m;
int n,mhp,dmg[N],mp[N];
bool tp[N];
int hp[N];
int f[N],g[N];

bool f2;

void init(){
	memset(g,0x3f3f,sizeof g);
	memset(f,0x3f3f,sizeof f);
	g[0]=f[0]=0;
//求f
	for(int i=1;i<=m;i++){
		for(int j=1;j<=mhp;j++){
			if(!tp[i])continue;
			if(j-dmg[i]<0)continue;
			f[j]=min(f[j],f[j-dmg[i]]+mp[i]);
		}
	}
//求g

	for(int j=1;j<=m;j++){
		if(tp[j])continue;
		for(int i=1;i<=mhp;i++){
			
			if(i-dmg[j]<0)continue;
			g[i]=min(g[i],g[i-dmg[j]]+mp[j]);
		}
	}
	int mn=INF;
	for(int i=mhp;i;i--){
		g[i]=min(g[i],mn);
		mn=min(mn,g[i]);
	}
}
signed main(){
	n=rd;
	for(int i=1;i<=n;i++){
		hp[i]=rd;
		mhp=max(mhp,hp[i]);
	}
	m=rd;
	for(int i=1;i<=m;i++){
		string s;
		cin>>s;
		mp[i]=rd;
		string t;
		cin>>t;
		if(t=="All")tp[i]=1;
		else tp[i]=0;
		dmg[i]=rd;
		dmg[i]=min(dmg[i],mhp);
	}

	init();

	int ans=INF;
	for(int i=0;i<=mhp;i++){
		int res=0;
		for(int j=1;j<=n;j++){
			if(hp[j]>i)res+=g[hp[j]-i];
		}
		if(f[i]>ans)continue;//防止f[i]+res爆LL
		if(res>ans)continue;
		ans=min(ans,f[i]+res);
	}
	cout<<ans<<endl;
}
```




---


# 集合分组【征集 spj】

## 题目描述

现有 $k$ 个整数集合，第 $i$ 个集合有 $s_i$ 个元素。

集合中的数都为正数，且不大于 $n$。现定义集合 $A$ 与集合 $B$ 相似，当且仅当满足如下条件之一：

1. $B$ 与 $A$ 相似；
2. 将 $A$ 集合删去一个元素，或更改一个元素的值之后 $A$ 集合与 $B$ 集合相等。

现要将 $K$ 个集合分成至多 $M$ 组（$M>N$），使得每一组内的集合互不相似。要求你给出一种合法的方案。如果无解请输出 `impossible`。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据满足 $n \le 10$，$m \le 2$，$k \le 10$；
- 对于 $100\%$ 的数据满足 $1\le n \le 100$，$1\le m \le 100$，$1\le k \le 50000$，$1\le s_i \le 100$。

## 样例 #1

### 输入

```
8 20 12 
5 1 3 5 6 4 
5 1 3 5 6 3 
4 5 6 3 3 
4 5 6 3 4 
4 4 6 5 8 
4 7 7 7 7 
3 7 7 7 
2 2 2 
3 2 2 7 
3 1 2 3 
3 1 2 4 
10 1 2 3 4 5 6 7 8 7 6 
10 8 7 6 5 4 3 2 1 2 1 
20 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 3 5 7 
5 4 6 4 6 4 
5 6 4 6 4 6 
6 6 6 6 6 6 6 
3 6 6 6 
1 1 
1 2```

### 输出

```
2 
1 
9 
1 
6 
2 
4 
5 
3 
7 
8 
5 
4 
8
7 
9 
1 
1 
2
3```

# 题解

## 作者：梦离 (赞：25)

我们可以发现，对于两个相似的集合，其和的差值绝对是0-n之间的，所以，如果我们将其%n+1，结果绝对不等，那么换而言之，%的结果相等的绝对不相似，那么我们就将%的结果相等的放在一个集合里就可以了，集合编号为%的结果+1（因为如果会出现%的结果为0的情况）

代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k;
int main()
{
    cin>>n>>k>>m;
    for(int i=1;i<=k;i++)
    {
        int a,u=0,c;
        cin>>a;
        for(int j=1;j<=a;j++)cin>>c,u+=c;
        cout<<u%(n+1)+1<<endl;
    }
    return 0;
}
```

---

## 作者：hgckythgcfhk (赞：3)

首先指出某篇题解的错误，不可能无解不是因为可以每个单独一组，而是最多需要 $n+1$ 组，数据保证了 $m>n$，所以必然有解。

做法：每组求和，求每组的和对 $n+1$ 取模的值，因为不能有第 $0$ 组，需要最后加 $1$。

首先证明两个集合和相等的情况，显然，如果两个和相等，要么两个集合相等，要么两个集合的和的差值至少为 $n+1$，不能通过改变一个元素（删除视为改为 $0$）使两个集合相等，所以两个集合不相似。

然后集合的和在对 $n+1$ 取模意义下的的种类数是 $n+1$，由于前面提到过删除视为改为 $0$，与一个集合相同或相似的集合的种类数也是 $n+1$，所以 $n+1$ 组一定是够用的。

最后说一下这个题的题意的锅，题面中的 $N$ 和 $n$ 是同一个东西，相等不是相似，这一点要吐槽一下，按理说改为和原来相等的数也叫改了，但题面并没有声明这种特殊情况，然后这个题就很简单了，其实这个题主要难在理解题意。

注意事项：**不要 while(m--)，会 T**

```
#include<bits/stdc++.h>
using namespace std;
#define int register unsigned
#define ge getchar/*_unlocked*/()
#define pu(c) putchar/*_unlocked*/(c)
inline unsigned rd(){int char c=ge;while(c<0b110000||c>0b111001)c=ge;int s=0;while(c<0b111010&&c>0b101111)s=(s<<0b11)+(s<<0b1)+(c&0b1111);return s;}
inline void wt(int x){static unsigned char c[0b1010];int char s=0;while(x)c[++s]=x%0b1010|0b110000,x/=0b1010;while(s)pu(c[s--]);pu(0b1010);}
#define void inline void
signed main(){ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,m,k;cin>>n>>k>>m;while(k--){cin>>m;int s=0,a;
		for(int i=1;i<=m;++i)cin>>a,s+=a;cout<<s%(n+1)+1<<'\n';}
}
```


---

## 作者：luxiaomao (赞：2)

## 这题真的是思维好题

题意很简单，这里不予以再进一步的分析。

但可以玩出花来的其实是这个**两个集合相似**的定义。

> 将 $A$ 集合删去一个元素，或更改一个元素的值之后 $A$ 集合与 $B$ 集合相等。

再看题目中的一个不起眼的规定：

> 集合中的数都为正数，且不大于 $n$。

不用数学证明，大家自己用膝盖想想就可以得出：**两个相似的集合，把它们自己的数值数值分别加起来，得到两个和，这两个和相差在 $1 - n$ 的范围内**。

拍拍脑袋理解一下，这道题的关键就出来了。

将集合的数值和 $\bmod$ 上 $(n+1)$，如果两个集合相似，那么它们的这个 $\bmod$ 值必然不相等，如果相等了，那它们必然是两个不相似的集合。

那我们把所有 $\bmod$ 值相等的集合全部放在一个组即可~

## Code Time

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,nn,x,sum;

int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i = 1;i <= k;i++)
	{
		scanf("%d",&nn); 
		sum = 0;
		for(int j = 1;j <= nn;j++)
			scanf("%d",&x),sum += x;
		printf("%d\n",sum%(n+1)+1);
	}
}
```
时间复杂度 $O(ks_i)$，可以通过本题。

ps：总共会安排好 $(n+1)$ 组，然后要求题目最多 $m$ 组 $(m > n)$，所以一定不会超出，没有什么用处。

虽然这是一道码量很少，看起来很水的蓝题，但是从锻炼思维上来讲，是一道好题。~~但是我看到这道题第一念头竟然是写差分约束~~（捂脸）。

---

## 作者：2021changqing52 (赞：2)

# 思路：
- 灵感来自题解。
- 性质一：两个集合的总和不相同。
- 性质二：对于两个相似的集合，其和的差值一定是 $0 \sim n$ 之间的，如果我们将其 $\bmod (n+1)$，结果一定不相等。

所以我们可以把编号求和再 $\bmod (n+1)$，但由于题目告诉我们编号从一开始，而取模可能为零，所以要再加一。
# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a,s,c;//s:和
int main(){
    cin>>n>>k>>m;
    for(int i=1;i<=k;i++){
        s=0,cin>>a;//注意s初始化为0
        for(int j=1;j<=a;j++)cin>>c,s+=c;//读入相加
        cout<<s%(n+1)+1<<"\n";//取模可能为0,所以加1
    }
    return 0;
}
```

---

## 作者：yangwenbin (赞：2)

由于某些充满恶意出题人导致我被卡了好几次 ~~(嘤嘤嘤)~~

# 题解 P1810 【集合分组】

没看过题目的请走着 ([传送门](https://www.luogu.com.cn/problem/P1810))

其实题目的里的意思就是保证在一个组合里的集合互不相似.

相似就是指将A集合删去一个元素，或更改一个元素的值之后A集合与B集合相等。

即 { ( 其它数 )  +  Y } 与 { ( 其它数 ) + { X | X != Y , X >= 0 , X <= n } }

所以两个集合的和必然是相差  ( 0 , n ) . 

所以和若对于 ( n + 1 ) 进行求余操作,就可以得到答案.

但要注意必须必须加上 1 

因为从一看是记录组数

## 注意

这道题出题人加了一些 EOF 在数据里面

所以不建议要快读优化 ( 其实正常读入就够了 )

而且输入集合数据时也不建议用 ```while ( num -- )```

会被卡掉

## code

```cpp

#include <bits/stdc++.h>
using namespace std;

int n,k,m;

int main()
{
	scanf("%d %d %d",&n,&k,&m);
	for (int i = 0; i < k; ++i)
	{
		int num,sum = 0,x;
		scanf("%d",&num);
		for (int j = 0;j < num; ++j)
		{
			scanf("%d",&x);
			sum += x;
		}
		int ans = sum % (n + 1) + 1;
		printf("%d\n",ans);
	}
	return 0;
}

```

---

## 作者：scp020 (赞：1)

# P1810 集合分组 题解

限制条件很弱的题，感觉有点太水了。

## 解法

考虑两个集合相似的条件。仔细读题发现 $n$ 这个条件很怪，于是断定答案一定与 $n$ 有关。

根据题目描述，两个集合相等则不相似。若两个集合中元素的和相等，则两集合相等，或者两集合至少有两个元素不同，无法通过更改一个集合中的一个元素使两集合相等。

若两集合相似，则两集合只有一个（或一对）元素不同。题中说了集合中的数都为正数，且不大于 $n$，所以两相似集合中元素的和的差的绝对值在 $[1,n]$ 之间。所以以 $n + 1$ 为模数对相似集合中元素的和取模，两个余数肯定不相同。一个命题的逆否命题等价于该命题，所以如果两个集合的余数相同，则两个集合一定不相似。我们就可以将这 $k$ 个集合根据其余数分成 $n+1$ 个组，集合编号即为余数。注意到会有余数为 $0$ 的情况，我们只要把 $0$ 放到编号为 $n + 1$ 的组里就行了。

题中说 $m > n$，所以这个问题一定有解。

## 代码

```cpp
#include<bits/stdc++.h>
int n,k,m,sum[50010];
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1,num,tmp;i<=k;i++)
	{
		scanf("%d",&num);
		for(int j=1;j<=num;j++) scanf("%d",&tmp),sum[i]+=tmp;
	}
	for(int i=1;i<=k;i++) printf("%d\n",sum[i]%(n+1)+1);
	return 0;
}
```


---

## 作者：白简 (赞：1)

#### 思路

由于每个元素的值均不大于 $n$，设集合的值为该集合内所有元素值之和，那么相似集合之间的差值一定小于等于 $n$，不相似集合之间差值一定大于 $n$。

那么相似集合的值对 $n+1$ 取模的值一定不同，这样可以实现合法的分组。

那么我们把对 $n+1$ 取模值相同的集合是一定不相似的，可以分到同一组，考虑取模后结果从 $0$ 开始，而要求的集合编号从 $1$ 开始，取模后结果加上 $1$。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

int n,k,m;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> k >> m;

    for(int i = 1;i <= k; i++) {
        int num,sum = 0;
        
        cin >> num;
        for(int j = 1,x;j <= num; j++) {
            cin >> x;
            sum += x;
        }
        
        cout << (sum % (n + 1) + 1) << endl;
    }
    return 0;
}
```

---

## 作者：_cmh (赞：1)

来个通俗易懂的题解吧！

阅读题面，对“相似的集合”进行简要概括：

- 性质 $1$ ：因为集合的元素都是正数，所以两个集合的总和不相同。

- 性质 $2$ ：因为集合的数都不大于 $n$ ，并且相似的集合有且只有 $1$ 个元素不等，所以两个相似的集合的差在 $1\sim n$ 之间，相等的集合差为 $0$。

- 性质 $3$ ：观察性质 $2$ 可得，至多有 $n+1$ 组集合相似。由题知，$m>n$ ，所以不可能出现 `impossible` 的情况。

- 性质 $4$ ：对于每个集合的编号，我们可以对其求和（令和为 $ans$），由性质 $3$ ，可以推出，我们用 $ans$ 对 $n+1$ 取模。分到的组内的集合一定不相似。**但是**，题目告诉我们编号为 $1\sim m$ ，而取模的结果可能为 $0$ 。所以我们需要对结果 $+1$ ，保证其从 $1$ 开始编号。即，它的编号为 $ans\mod(n+1)+1$。

根据以上性质，容易写出程序：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
int n,k,m;
int main(){
	cin>>n>>k>>m;
	for(int i=1;i<=k;i++){
		int x,ans=0;
		cin>>x;
		for(int j=1;j<=x;j++){
			int a;
			cin>>a;
			ans+=a;
		}
		cout<<ans%(n+1)+1<<endl;
	}
    return 0;
}
```


---

## 作者：_Yoimiya_ (赞：1)

[题目传送门。](https://www.luogu.com.cn/problem/P1810)

解题思路：
- 灵感来自第一篇题解。
- 首先考虑不可能的情况。即使全部都相似，那分成 $k$ 组亦可以实现，所以不可能输出“impossible”。
- 开始正式分析。题目定义两个相似的集合是“将 A 集合删去一个元素，或更改一个元素的值之后 A 集合与 B 集合相等”，而集合中的元素是不大于 $n$ 的正数，说明对于两个相似的集合，和的差值不会超过 $n$ 。
- 因为我们知道两个相似的集合差值不会超过 $n$ ，所以我们可以基于此来进行分组。如果我们将集合的和 $\bmod (n+1)$ ， 相似的集合的结果是不等的，因此我们可以就按结果来分组，这样就可以保证分组后组内不相似。
- 最后输出要加 1，因为取模可能结果为 0。  

AC 代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k>>m;
	for(register int i(1);i<=k;++i){
		int x,sum(0),c;
		cin>>x;
		for(register int j(1);j<=x;++j) cin>>c,sum+=c;
		cout<<sum%(n+1)+1<<'\n';
	}
	return 0;
}
```

---

## 作者：Furina_Saikou (赞：0)

题意中集合 $A$ 与集合 $B$ 相等应为元素和相等。

# 思路

首先若集合 $A$ 和集合 $B$ 相似，那他们的和一定不能相等，否则更改值后一定不相等，因为元素不超过 $n$，所以 $A$ 和 $B$ 中的元素和之差一定不超过 $n$。因此，如果 $sum_A\equiv sum_B(\mod (n+1))$，那么集合 $A$ 和集合 $B$ 不相似。因此我们将每个集合按元素和对 $n+1$ 取模的值分组即可，因为 $n<m$，所以必定有解。**注意取模后加一防止有 $0$。**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=114514;
int n,k,m,s;
int main()
{
	cin>>n>>k>>m;
	for(int i=1,sum=0;i<=k;i++,sum=0)
	{
		cin>>s;
		for(int j=1,x;j<=s;j++)
		{
			cin>>x;
			sum+=x;
		}
		cout<<sum%(n+1)+1<<"\n";
	}
}
```

---

## 作者：ydkxj (赞：0)

你说得对，但是这是一道思维题。

### 前言

思维题，顾名思义就是就是考察思维的题目，在本篇文章中，我会将我写题的思路详细说出，并尽量解释清楚思路的来源。

## Solution

由题意，我们可以知晓：

若 A 与 B 相似，则只有两种情况：

- B 与 A 相似。

- 将 A 集合删去一个元素或更改一个元素的值之后 A 集合与 B 集合相等。

上述条件中的相等的意思是：这两个集合内容完全相等。

题目保证了 $m$ 大于 $n$ ，再因为至多分为 $n+1$ 组，因而题目保证有解。

又从题目中可以看出，每一个数都是小于 $n$ 的，一开始，我就觉得最终结果与 $n$ 有关，因为鄙人不才，用手把样例推了一遍，发现了向 $n+1$ 可以非常完美的完成分组；所以我们可以通过向 $n+1$ 取模来进行合法分组。

## CODE

```
#include<iostream>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
	int n,k,m,a,ans,bx;
	cin>>n>>k>>m;  
    for(int i=1;i<=k;i++){
        ans=0;
        cin>>a;
        for(int j=1;j<=a;j++){  
            cin>>bx;
  			ans+=bx;
         }
        cout<<ans%(n+1)+1<<endl;
    }
    return 0;
}
```
完结撒花

---


# 最短路

## 题目描述

给定一个包含 $N$ 个点，$M$ 条边的无向图，每条边的边权均为 $1$。

再给定 $K$ 个三元组 $(A,B,C)$，表示从 $A$ 点走到 $B$ 点后不能往 $C$ 点走。注意三元组是有序的，如可以从 $B$ 点走到 $A$ 点再走到 $C$。

现在你要在 $K$ 个三元组的限制下，找出 $1$ 号点到 $N$ 号点的最短路径，并输出任意一条合法路径，会有 Check 检查你的输出。

## 说明/提示

对于 $40\%$ 的数据满足 $N \le 10$，$M \le 20$，$K \le 5$。

对于 $100\%$ 的数据满足 $N \le 3000$，$M \le 20000$，$K \le 100000$。

## 样例 #1

### 输入

```
4 4 2
1 2
2 3
3 4
1 3
1 2 3
1 3 4```

### 输出

```
4 
1 3 2 3 4 ```

# 题解

## 作者：Fuko_Ibuki (赞：18)

Codeforces上有一道和这题题面一样并且有spj的题,如果你不幸被spj卡了可以去交一下.  
[Codeforces 59E Shortest Path](https://www.luogu.org/problemnew/show/CF59E)  
不过我这个代码没有spj也可以过.
据@hehe_54321大佬说题解的复杂度是假的,会被卡成指数级?  
我用我的AC代码跑了一下大佬的数据,跑得飞快.  
所以这是第一篇~~正确的题解~~?  
我们考虑用边跑$bfs$.  
以前我们写的$bfs$都是用点跑的,这一次我们用边跑.  
为什么要用边跑?  
这题中不能通过的三元组如果用点来跑$bfs$,非常难运用这个限制条件.  
但是如果化边为点(~~线图(逃)~~思想),这些三元组就变成了不能从一个点走到另一个点,非常适合运用题目的条件了.    
以上是@Styx大佬的思路,感谢他的高妙思路.  
我们用$d[u][v]$表示从$(0\to 1)$(我们虚构的初始边)的边走到$(u\to v)$的这一条边所用的最少步数; 用$pre[u][v]=last$表示$u\to v$走过的前一条边是$last\to u$(由于边之间必须共点才算做有连边,因此$pre$只需要记录一个点,它指向的点藏在数组下标里).  
用$vector$储存每个点连向哪些边,$set$存储不能走的三元组,$bfs$的时候$queue$里装$pair<int,int>$,表示当前搜索的点和这条边的另一个端点.  
剩下的就在代码里说了.  
(省略快读快写,大家肯定看得懂)
```cpp
typedef pair<int,int> pii;
const int aoi=3058;
typedef int fuko[aoi][aoi];
fuko d,pre; 
vector<int> lj[aoi];
set<pii> ban[aoi];
int main() {
  int i,n,m,k,u,v,a;
  read(n),read(m),read(k);
  for (i=1;i<=m;++i) { // 加边
    read(u),read(v);
    lj[u].push_back(v);
    lj[v].push_back(u);
  }
  for (i=1;i<=k;++i) { 
    read(u),read(v),read(a);
    ban[u].insert(pii(v,a)); // 存储不能走的三元组
  }
  queue<pii> q; q.push(pii(1,0)); // 加入0->1 的边
  for (;!q.empty();) {
    pii now=q.front(); q.pop();
    int u=now.first,lat=now.second; // 表示当前的边是lat->u的,并且从u这个点向外扩展.
    if (u==n) { // u=n,标明有解并输出路径
      write(d[lat][n]),pl; // 注意u=n,就是到这条边的最短路长度.
      int stk[aoi<<5]={0},fa=n,tmp; 
      for (;;) {  // 接下来好好思考输出路径的方法
        stk[++*stk]=fa; // 当前走到的点.
        if (fa==1) break; // 到1了就跑
        tmp=lat,lat=pre[lat][fa],fa=tmp; 
        /*
        当前边是lat连向fa的,它的上一条边就应该是pre[lat][fa]连向lat的.
        所以这么往回跳.
        */
      }
      for (;*stk;--*stk) write(stk[*stk]),p32; 
      // 倒序输出并结束.解释一下,*stk=stk[0]
      return 0;
    }
    for (int v:lj[u]) {  // 遍历u能够到达的每一个点.
      if (!ban[lat].count(pii(u,v))&&!d[u][v]) { //lat->u->v的这个三元组没有被禁,并且u->v的这条边的距离也没有标记
        pre[u][v]=lat; // 标记pre
        d[u][v]=d[lat][u]+1; // 加距离
        q.push(pii(v,u)); // 推入队列
      }
    }
  }
  puts("-1"); // 无解.
}
```
谢谢大家.

---

## 作者：封禁用户 (赞：7)

这题数据有点坑啊，说好的Check呢？？

边不能重复，所以直接用f[x][y]表示从x到y后不能走到的点，

因为要记录路径，所以用广搜找最短路，广搜的状态里加一个变量记录上一个点，最后dfs输出。

注意，这题目没有Check，所以要把边按起点为第一关键词和终点为第二关键词排序再加边，然后就是乱搞了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=3010;
const int maxm=20010;
struct Edge{
    int next,to;
}e[maxm<<2];
int head[maxn],n,m,k,no[maxn],num,f[maxn][maxn],h,t=1;
void Add(int from,int to){
    e[++num].to=to;
    e[num].next=head[from];
    head[from]=num;
}
struct SL{
    int last,now,time,from;
}s[maxm];
void dfs(int now){
    if(s[now].from) dfs(s[now].from);
    printf("%d ",s[now].now);
}
struct Q{
    int a,b;
    bool operator < (const Q &A) const{    //按起点为第一关键词和终点为第二关键词排序
         return a==A.a?b<A.b:a<A.a;
    }
}x[maxm<<1];
int main(){
    n=read();m=read();k=read();
    rep(i,1,m) x[i].a=read(),x[i].b=read(),x[i+m].a=x[i].b,x[i+m].b=x[i].a;     //把边记录下来
    sort(x+1,x+m+1);
    rep(i,1,2*m) Add(x[i].a,x[i].b);
    rep(i,1,k) f[read()][read()]=read();     //简洁写法
    s[1]=(SL){0,1,0,0};
    while(h<=t){
      ++h;
      SL now=s[h];
      for(int i=head[now.now];i;i=e[i].next){
         if(f[now.last][now.now]!=e[i].to&&e[i].to!=now.now){       //如果能走到这且不是原地走的话（好傻哦）
           s[++t]=(SL){now.now,e[i].to,now.time+1,h};      //入队
           if(e[i].to==n){ 
             printf("%d\n",now.time+1);
             dfs(t);
             return 0;
           }
         }
      }
    }
    return 0;
}
```

---

## 作者：Lmx120815 (赞：2)

因为边权都为 1，考虑搜索。对于每一个三元组，我们可以用一个集合记录一下，在搜索过程中记录每两个点的前驱，如果构成三元组，就跳过，否则继续搜，并求出最短路。

最后通过记录的前驱回溯，并输出方案。


```cpp
#include <bits/stdc++.h>
#define int long long
#define ll long long
#define ull unsigned long long
#define inf 1e18
#define eps 1e-9
#define endl "\n"
#define il inline
using namespace std;
const int N=3005,M=5e5+5;
const int mod=100003;
inline int read(){
    int x(0),f(1);char c=getchar();
    while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    return x*f;
}
int n,m,k;
vector<int>E[N];
signed main(){
	scanf("%lld %lld %lld",&n,&m,&k);
	for(int i=1,x,y;i<=m;i++){
		scanf("%lld %lld",&x,&y);
		E[x].push_back(y);
		E[y].push_back(x);
	}
	
	set<tuple<int,int,int> > st;
	for(int i=1,x,y,z;i<=k;i++){
		scanf("%lld %lld %lld",&x,&y,&z);
		st.insert(make_tuple(x,y,z));
	}
	
	queue<pair<int,int> >q;
	q.push(make_pair(0,1));
	vector<vector<int> > dis(n+1,vector<int> (n+1,-1)),pre(n+1,vector<int> (n+1,0));
	for(int i=0;i<=n;i++) dis[i][1]=0,pre[i][1]=0;
	
	auto dfs=[&](auto dfs,pair<int,int> cur) -> void{
		auto to=cur;
		int u=to.first,v=to.second;
		if(pre[u][v]!=0) dfs(dfs,make_pair(pre[u][v],u));
		cout<<u<<' ';
	};
	
	while(!q.empty()){
		auto to=q.front();
		int p=to.first,u=to.second;
		q.pop();
		if(u==n){
			printf("%lld\n",dis[p][u]);
			dfs(dfs,make_pair(p,u));
			cout<<u<<' ';
			break;
		}
		for(int v:E[u]){
			if(st.count(make_tuple( (int)p,u,v))) continue;
			
			if(dis[u][v]==-1){
				dis[u][v]=dis[p][u]+1;
				pre[u][v]=p;
				q.push(make_pair(u,v));
			}
		}
	}
	return 0;
}
```

---

## 作者：vanueber (赞：1)

# 题目分析

求 $1 \sim n$ 的最短路径，并且有 $K$ 个约束，表示不能存在 $a \to b \to c$ 的走法。

观察到 $n$ 很小，可以设计类似 dp 的状态转移，由于有环，需要最短路辅助。

设 $dp_{i,j}$ 表示走到 $i$ 点且上一个点走的是 $j$ 的最短距离，将 $dp$ 数组看成最短路中的 $dis$ 数组，有转移方程：
$$
dis_{v,u}=\min dis_{u,pred} + 1
$$

其中 $(pred,u,v)$ 是合法的三元组。

跑一遍 dijkstra 即可。

时间复杂度：总状态数是 $\Theta(n^2)$ 的，堆优化 dijkstra 复杂度为 $\Theta(n^2 \log n)$。

注意此题略卡空间。

# Code


```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#define umap unordered_map
#define vint vector<int>
#define ll long long
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define ull unsigned long long
#define uint unsigned int
#define rg register
#define il inline
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define sqr(x) ((x)*(x))
using namespace std;
using namespace __gnu_pbds;
const int INF=0x3f3f3f3f;
inline int read()
{
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        w=(w<<1)+(w<<3)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int N=3005;
umap<int,umap<int,umap<int,int>>> f;
int n,m,K;
vint G[N];
int dis[N][N],vis[N][N];
pii pre[N][N];
struct state
{
    int u,pred,dis;
    bool operator <(const state &b)const
    {
        return dis>b.dis;
    }
};
void dijkstra(int s)
{
    memset(dis,0x3f,sizeof dis);
    priority_queue<state> Q;
    dis[s][0]=0;
    Q.push({s,0,0});
    while(!Q.empty())
    {
        auto temp=Q.top();Q.pop();
        int u=temp.u,pred=temp.pred;
        if(vis[u][pred]) continue;
        vis[u][pred]=1;
        for(int v:G[u])
        {
            if(f.find(pred)!=f.end()&&f[pred].find(u)!=f[pred].end()&&f[pred][u].find(v)!=f[pred][u].end()) continue;
            if(dis[v][u]>dis[u][pred]+1) dis[v][u]=dis[u][pred]+1,pre[v][u]=make_pair(u,pred),Q.push({v,u,dis[v][u]});
        }
    }
}
void print(int u,int pred)
{
    if(!u) return;
    print(pre[u][pred].first,pre[u][pred].second);
    cout<<u<<" ";
}

int main()
{
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    #endif
    n=read(),m=read(),K=read();
    for(int i=1,u,v;i<=m;++i)
    {
        u=read(),v=read();
        G[u].push_back(v),G[v].push_back(u);
    }
    for(int i=1,a,b,c;i<=K;++i)
    {
        a=read(),b=read(),c=read();
        f[a][b][c]=1;
    }
    dijkstra(1);
    int pos=min_element(dis[n]+1,dis[n]+n+1)-dis[n];
    cout<<dis[n][pos]<<endl;
    print(n,pos);
    cout<<endl;
    #ifndef ONLINE_JUDGE
    fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
    #endif
    return 0;
}
```

---

## 作者：luoxb (赞：0)

# 题意分析

题面本身已经很清晰了，即考虑限制条件下的单源最短路问题，注意无向图，以及观察样例可知可以走回头路。

# 算法分析

## 部分 1

单源最短路肯定考虑 *dijkstra* 算法，但是限制条件如何体现呢？

实际上，*dijkstra* 算法虽然不是 DP 而是贪心，但是其与 DP 有着不小的相似性，其中最重要的就是 *状态转移*。

普通的 *dijkstra* 算法包含 3 个容器，分别是记录距离 **状态** 的 *dist*，记录松弛 **状态** 的 *confirm* 以及一个堆。

那么回到题目所说的限制条件，重新翻译一下就是：

- *若当前节点为 B，上一个节点为 A，目标节点为 C，则这一次转移不能进行*

也就是说我们需要记录每个节点的上一个节点的状态，考虑到不同的转移，每种合法的转移方式都对应了不同的距离，于是给 *dist* 数组和 *confirm* 数组多开一维，含义分别如下：

- ***dist \[i]\[j]： 在节点 j，上一个节点为 i 时到原点的最小距离***
- ***confirm \[i]\[j]： 在节点 j，上一个节点为 i 时是否已经确认答案正确***

至此，只需要在读入时用 map 储存节点 B 对应的 A 和 C，就可以在尝试松弛时检查转移是否合法，剩下的部分即为普通的 *dijkstra* 算法。

## 部分 2

但是至此只完成了题目的第一问，路径如何记录呢？

其实记录路径有很多种方法，但是由于题目有时必须走回头路，所以我用了 string 来进行储存，在每次搜到终点时记录即可。

## 复杂度分析

- *dijkstra* 复杂度： $O(n\log n)$。
- 路径记录最差复杂度： $O(nm)$。
- 综合来看最差即为 $O(nm)$ 可以通过本题。

# 实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX = 3e3+5;

int n,m,k,a,b,c;
int dist[MAX][MAX],confirm[MAX][MAX];

vector<int> g[MAX];

struct Node{
	int u,v,d;
	string path;
	bool operator < (Node t)const{
		return d>t.d;
	}
	bool operator == (Node t)const{
		return u == t.u && v == t.v;
	}
}ans;
map<int,Node> restrict;
priority_queue<Node> q;

string concat(int i,string s){
	return s+" "+to_string(i);
}

void dijkstra(int u){
	memset(dist,0x3f,sizeof dist);
	for(int i=1;i<=n;i++) dist[u][i] = 0;
	ans.d = 0x3f3f3f3f;
	
	q.push({u,u,0,to_string(u)});
	
	while(q.size()){
		Node top = q.top();
		q.pop();
		
		int u = top.v;
		
		if (confirm[top.u][u]) continue;
		confirm[top.u][u] = true;
		
		for (int i:g[u]){
			if (restrict[u] == (Node){top.u,i}) continue;
			if (dist[u][top.u] + 1 < dist[i][u]){
				dist[i][u] = dist[u][top.u] + 1;
				Node node = (Node){u,i,dist[i][u],concat(i,top.path)};
				q.push(node);
				if (i == n && node.d<ans.d){
					ans = node;
				} 
			}
		}
	}
}

int main(){
	cin>>n>>m>>k;
	for (int y=0;y<m;y++){
		cin>>a>>b;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	
	for (int y=0;y<k;y++){
		cin>>a>>b>>c;
		restrict[b] = (Node){a,c};
	}
	
	dijkstra(1);
	
	int f = INT_MAX;
	for(int i=1;i<=n;i++) f = min(f,dist[n][i]);
	cout<<f<<'\n';
	cout<<ans.path;
	return 0;
}
```

# 后记

首先由于边权固定为 1，这题肯定是不需要用 *dijkstra* 的。其次，对于同一个 B 可能有多个限制，目前的代码是无法体现的，不过数据很水，遂罢之。

---


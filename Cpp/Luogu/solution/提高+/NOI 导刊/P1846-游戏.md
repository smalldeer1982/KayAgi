# 游戏

## 题目描述

给定两个正整数数列，你要用它们来做一个游戏：你需要对数列进行若干次操作，每一次操作，应选择两个正整数 $k_1$ 和 $k_2$，并删除第一个数列的最后 $k_1$ 个数，计算出它们的和 $s_1$；删除第二个数列的最后 $k_2$ 个数，计算出它们的和 $s_2$。这一次操作的得分就是 $(s_2-k_2)\times(s_1-k_1)$。两个数列应同时被清空，不允许一个数列空了，而另一个数列中还有数。游戏的总得分就是每一次操作的得分总和。

求最小的总得分。

## 说明/提示

- 对于 $20\%$ 的数据，$n,m\le20$；
- 对于 $40\%$ 的数据，$n,m\le200$；
- 对于 $100\%$ 的数据，$n,m\le2000$。

## 样例 #1

### 输入

```
3 2
1 2 3 
1 2 ```

### 输出

```
2```

# 题解

## 作者：litc (赞：14)

首先，由于(s2-k2)\*(s1-k1)每次加上一个数都要减去1，我们可以预处理全部减一，每次的操作得分就变成s2\*s1。

因为每个数都是正整数，对于数列1中的连续两段数a,c数列2中的连续两段数b,d易得(a+c)\*(b+d)>=ab+cd。所以当每次两个数列都只取一个数时结果最小。

但是，两个数列不等长，无法一对一消除。所以可能出现一对多的情况。

综上，使用DP

F[i][j]表示一数列已删去i个数另一数列已删去j个数时的最优解。

F[i][j]=min{f[i-1][j-1],f[i-1][j],f[i][j-1]}+a[i]\*b[j];

当两边都只取一个数的时候f[i][j]=f[i-1][j-1]+a[i]\*b[j];

当其中一个数列取多个数的时候 f[i][j]=f[i][j-1]+a[i]\*b[j] 表示a中只取一个数，b中可能取多个数，由乘法分配律a\*(b+c)=a\*b+a\*c得相对于f[i][j-1]增加的数为a[i]\*b[j]

初始化：f=maxlint，f[0][0]=0

——————by stranded


---

## 作者：stansxt (赞：13)

# 前言

- 感觉其它大佬的题解都不是很友善呢~

- 所以这里我主要讲下dp的设计和转移，然后附上窝的代码QwQ

# 思路

- 一眼dp。
- s代表的是所有数的和，k是个数。所以让每个数都减一，然后求和就直接是s-k了。
- 从前面删和从后面删是没有本质区别的，因为最终要求删完。
- 注意到如果两个数列同时删超过1个数，比如$a$中$a_i,a_j$，设删掉的b中元素的和为$b_{sum}$，那么对答案的贡献就是$(a_i+a_j)\times b_{sum}$，它与$a_i\times b_{sum}+a_j\times b_{sum}$是相等的。所以每次至多有一个数列删去超过一个数。
- 看上去是个类似匹配dp的东西。所以设计$dp[i][j]$表示$a$数列删去i个数，b数列删去j个数，此时答案的最小值。
- 对于$dp[i][j]$，那么有三种情况：
	- $a$数列仅删去$a_i$，b数列仅删去$b_j$，那么就是$dp[i-1][j-1]+a[i]\times b[j]$
   - $a$数列删去$a_i$的时候b数列同时删去$b_j$和之前连续的一段数（$b_{j-1}, b_{j-2},……,b_{k}$），那么就是$dp[i-1][k-1]+a_i\times\Sigma_{x=k}^j{b_x}$，由于$a_i\times\Sigma_{x=k}^{j-1}{b_x}$已经更新过$dp[i][j-1]$，所以也即是$dp[i][j-1]+a[i]\times b[j]$。
   - 同理，还有一个是$dp[i-1][j]+a[i]\times b[j]$。
- 然后就完啦，$O(n^2)$直接转移即可。

# 代码

```
//P1846 游戏
//submit 1
//By sxt on 2020.5.23
#include<bits/stdc++.h>

#define rg register int
#define il inline
#define in read()
#define _num(x) (x >= '0' && x <= '9')
#define ql(x) memset(x, 0, sizeof(x)) 
#define mid (l+r>>1)
#define min(x, y) (x<y?x:y)
#define Min(x, y, z) min(x, min(y, z))

using namespace std;

const int N = 2007; 

il int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!_num(ch)){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(_num(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

char f[10];
int pcnt;

il void pint(int x){
	pcnt = 0;
	if(x == 0) putchar('0');
	while(x){
		f[++pcnt] = x % 10 + '0';
		x /= 10;
	}
	while(pcnt) putchar(f[pcnt--]);
	putchar('\n');
}

int b[N], a[N], dp[N][N], n, m;

signed main()
{
	n = in, m = in;
	for(rg i = 1; i <= n; ++ i)a[i] = in, --a[i];
	for(rg i = 1; i <= m; ++ i)b[i] = in, --b[i];
	memset(dp, 0x3f3f3f, sizeof(dp));
	dp[0][0] = 0;
	for(rg i = 1; i <= n; ++ i)for(rg j = 1; j <= m; ++ j)
		dp[i][j] = Min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + a[i] * b[j];
	pint(dp[n][m]);
	return 0;
}




```

***The · End.***

---

## 作者：Demeanor_Roy (赞：10)

## 前言
- 感觉之前各位大佬的讲解都不够详尽，这里就来分享一下做题经历。

## 36pts做法
- 像这种一眼 DP 的题，大多都需要优化，但无论如何先写暴力 DP 是没错的。  
- 暴力的话就很好想了，我们用 $f(i,j)$ 表示对序列 $A$ 的前 $i$ 个数，序列 $B$ 的前 $j$ 个数进行操作可以得到的最小总得分。
- 很显然我们只需要枚举 $0 \leq k1 < i$ , $0 \leq k2 < j$ 就可以得到如下转移方程：   
$$ f(i,j)=\min(f(i,j),f(k1,k2)+(sum1(i)-sum1(k1)-(i-k1))\times(sum2(j)-sum2(k2)-(j-k2))) $$
- 时间复杂度：$O(n^4)$
- 下附代码：

```c
#include<bits/stdc++.h> 
using namespace std;

const int N=2020;
int n,m,A[N],B[N],sum1[N],sum2[N],f[N][N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	scanf("%d",&A[i]),sum1[i]=sum1[i-1]+A[i];
	for(int i=1;i<=m;i++)	scanf("%d",&B[i]),sum2[i]=sum2[i-1]+B[i];
	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int s1=0;s1<i;s1++)
				for(int s2=0;s2<j;s2++)
					f[i][j]=min(f[i][j],f[s1][s2]+(sum1[i]-sum1[s1]-(i-s1))*(sum2[j]-sum2[s2]-(j-s2)));
	printf("%d",f[n][m]);
	return 0;
}

```
## 45pts做法
- 将上面的 int 换成 long long 就行了。

## 一个小优化
- 在讲正解之前，我们先对之前繁琐的状态转移方程进行一个优化。
- 很容易发现：当我们删除一段数时，这段数的贡献既可以表示成 (总和 $-$ 数量)，也可以表示成 :  
$$\sum\limits_{i=1}^{n}{w_i-1}$$
- 所以不难想到，如果我们输入时将 $w_i$ 减一，那么转移方程就变为：
$$f(i,j)=\min(f(i,j),f(k1,k2)+(sum1(i)-sum1(k1))\times(sum2(j)-sum2(k2)))$$
- 这样一来，就简洁了许多。

## 100pts分做法
- 首先我们需要发现一个十分关键的性质：
- 性质：对于正整数 $a$ , $b$ , $c$ , $d$ ：
$$(a+b)(c+d) \geq ab+cd$$
- 假设我们从 $A$ 序列和 $B$ 序列中各取两段数，前者总和为 $(a+b)$ ，后者总和为 $(c+d)$ ,那么如果我们不分割，删除这两段对答案的贡献就是 $(a+b)(c+d)$ ,而如果将前者分割为 总和为 $a$ 和 $b$ 的两段，后者分割为总和为 $c$ 和 $d$ 的两段，再一一删除的话，对答案的贡献就为 $(ab+cd)$ 。
- 这说明：对于两个序列，每一次我们将其尽量小段小段的删除，所得到的答案会更优。
- 最小的正整数是多少？小学老师告诉我们，是 $1$ 。
- 但由于两个序列长度不一，所以我们不能每次各删除长度为 $1$ 的子序列，否则就无法同时删除完。
- 我们用 $(x,y)$ 表示 $A$ 序列删除后 $x$ 位， $B$ 序列删除后 $y$ 位，那由刚刚的结论可知，只会出现 $(1,x)$ , $(x,1)$ , $(1,1)$ 三种情况，于是我们的DP便可更快地进行。
$$(1,1): f(i,j)=f(i-1,j-1)+A(i)\times B(j)$$
$$(1,x): f(i,j)=f(i,j-1)+A(i)\times B(j)$$
$$(x,1): f(i,j)=f(i-1,j)+A(i)\times B(j)$$
- 对于后两个方程，以第三个为例，是这样得到的: 
$$f(i,j)=f(i-1,k)+A(i)\sum\limits_{t=k+1}^{j}A(t)$$
- 但由于 $f(i,j-1)$ 已经更新为了 
$$f(i-1,k)+A(i)\times \sum\limits_{t=k+1}^{j}A(t)$$
- 所以便可以直接从 $f(i,j-1)$ 推出 $f(i,j)$ 。
- 时间复杂度：$O(n^2)$
- 下附代码：

```c
#include<bits/stdc++.h> 
using namespace std;
#define LL long long 
const int N=2020;
int n,m;
LL A[N],B[N],f[N][N];
inline LL min(LL a,LL b,LL c)
{
	return min(a,min(b,c));
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	scanf("%lld",&A[i]),A[i]--;
	for(int i=1;i<=m;i++)	scanf("%lld",&B[i]),B[i]--;
	memset(f,127,sizeof f);
	f[0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
					f[i][j]=min(f[i-1][j-1],f[i-1][j],f[i][j-1])+A[i]*B[j];
	printf("%lld",f[n][m]);
	return 0;
}
```

- 完结撒花~




---

## 作者：姬小路秋子 (赞：8)

个人认为这道题难度评分过于低下，感觉评个黑题都不过分！！！（自闭了好一会才会做>_<）

首先发现如果单次操作在第一个和第二个数列中都选择了超过一个数，那么答案肯定不是最优的（拆开来算显然更划算），所以最后删数的形式肯定是从一个数列中选了一个数，并在另一个数列中选了若干个数。

所以说高赞的那位上古老哥讲的“**所以当每次两个数列都只取一个数时结果最小。
但是，两个数列不等长，无法一对一消除。所以可能出现一对多的情况。**”是不对的！！

那么就可以设dp状态进行转移了！（这一步我又想了一好会>_<）。

这个dp还是蛮巧妙的，具体就是因为你只要求最优答案，所以那样子做是对的！

Q_Q




```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,i,j,a[2010],b[2010],f[2020][2010];
int main(){
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<=m;i++)scanf("%d",&b[i]);
	for(i=1;i<=n;i++)a[i]--;
	for(i=1;i<=m;i++)b[i]--;
	memset(f,44,sizeof(f));
	f[1][1]=a[1]*b[1];
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++){
	 	if(i>1&&j>1)f[i][j]=min(f[i][j],f[i-1][j-1]+a[i]*b[j]);
	 	if(i>1)f[i][j]=min(f[i][j],f[i-1][j]+a[i]*b[j]);
	 	if(j>1)f[i][j]=min(f[i][j],f[i][j-1]+a[i]*b[j]);
	 }
	printf("%d",f[n][m]);
}
```


---

## 作者：CrazyDance (赞：7)

## [~~传送门~~](https://www.luogu.org/problemnew/show/P1846)

简单起见我们把每个数字都减一（因为无论取什么数，都会减去$1$的贡献值，所以我们的$A$和$B$都提前$-1$）

并简化题意如下：给定两个非负数列A和B，每次可以从数列尾部连续取非空的若干个数

假设$A$取出的数的和是$K1$，$B$是$K2$，那么得分就是$K1*K2$

要求把$A$和$B$同时取空，并且使得总得分最小

对于$f$，初值为无限大，但$f_{0,0}=0$

显然我们有：

$$f_{i,j}=\min_{i=1,i=1}^{n,m}(f_{i-1,j-1}+a_i*b_j,f_{i-1,j}+a_i*b_j,f_{i,j-1}+a_i*b_j)$$

好吧，不讲这么多，上代码：
```cpp
#include<cstdio>
#include<cstring>
#define N 2010
int min(int a,int b){return a<b?a:b;}//手打对身体好！
int n,m,a[N],b[N],f[N][N];
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]--;
	for (int i=1;i<=m;i++) scanf("%d",&b[i]),b[i]--;
	memset(f,127,sizeof(f));
	f[0][0]=0;
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++)
	f[i][j]=min(f[i-1][j-1]+a[i]*b[j],min(f[i-1][j]+a[i]*b[j],f[i][j-1]+a[i]*b[j]));
	printf("%d",f[n][m]);
	return 0;
}
```

---

## 作者：fish_love_cat (赞：6)

Upd：式子写错了，谢罪谢罪谢罪谢罪谢罪 /kel

---

设 $f_{i,j}$ 表示第一个序列删 $i$ 个，第二个序列删 $j$ 个的最小代价。

因为我们注意到每一次操作如果多个对应多个肯定不如拆开做优，证明可以看乘法分配律。

所以只需要考虑一对多的情况。

于是枚举 $i$ 与 $j$，令 $a_i$ 与 $b_j$ 对应删除，有转移：

$$f_{i,j}=\min(f_{i-1,j-1},f_{i,j-1},f_{i-1,j})+a_i\times b_j$$

做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2005],b[2005],dp[2005][2005],n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>a[i],a[i]--,dp[i][0]=1e9;
    for(int i=1;i<=m;i++)
    cin>>b[i],b[i]--,dp[0][i]=1e9;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
    dp[i][j]=min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]})+a[i]*b[j];
    cout<<dp[n][m];
    return 0;
}
// 忘掉的名字还能重新再记，但是，逝去的回忆，已经不可能再回来了。
```

---

## 作者：syksykCCC (赞：6)

首先令 $A_i \gets A _i - 1, B_i \gets B_i - 1$，在这个新的序列上，问题转化为，求将 $A, B$ 分为数量相等的若干段，使得对应段乘积之和最小。

考虑到 $(a+b)(c+d) \ge ac + bd$，所以要尽量拆开来。

那么，“多对多”就是不可能出现的了，尝试“一对多”，也就是要么从 $A$ 中只取一个，$B$ 中取一段，要么$A$ 中取一段，$B$ 中只取一个。

下面记 $S_{\!A\ i}$ 表示 $A$ 的前缀和，$S_{\!B\ i}$ 表示 $B$ 的前缀和。

于是可以设计一个简单的 $O(n^3)$ 的 DP，用 $f_{i, j}$ 表示考虑 $A_1 \sim A_i, B_1 \sim B_j$，乘积的最小值。初始值 $f_{0,0} = 0$，答案显然为 $f_{n,m}$。转移的时候可以枚举这一段的开头，得到：

$$ f_{i, j} = \min\left\{\min_{0 \le k < i} \{ f_{k, j-1}+ (S_{\!A\ i} - S_{\!A\ k}) \times B_j \}, \min_{0 \le k < j} \{ f_{i-1, k}+ A_i \times (S_{\!B\ j} - S_{\!B\ k}) \} \right\}$$

然后智商不够设计那么优秀的转移，只能靠斜率优化勉强维持生活。

比如前一半的式子：

$f_{i, j} = f_{k, j-1}+ (S_{\!A\ i} - S_{\!A\ k}) \times B_j$

拆开来移项 $f_{i, j} - S_{\!A\ i} \times B_j + S_{\!A\ k} \times B_j = f_{k, j-1}$

那么把 $f_{k, j-1}$ 看作 $y$，$S_{\!A\ k}$ 看作 $x$，$f_{i, j} - S_{\!A\ i} \times B_j$ 看作 $d$，那么就有 $d+B_j \times x = y $，这是一条斜率为 $B_j$ 的一次函数，可以通过维护下凸壳的方式解决求 $d$ 的最小值的问题。另外一个式子也是同理的。

具体的来说，对于所有 $f_{i, j}$ 组成的一个 $n \times m$ 的矩阵，我们可以对上一行开一个单调队列，维护 $(i-1, k)$ 这样的来源，同时对每一列开一个单调队列，在 $j-1$ 列对应的单调队列中维护 $(k, j - 1)$ 这样的来源，就可以做到 $O(nm)$ 的复杂度了，具体可以看代码。

```cpp
#include <bits/stdc++.h>
#define Slope1(x, y) ((double)(f[i-1][y] - f[i-1][x]) / (double)(SB[y] - SB[x]))
#define Slope2(x, y) ((double)(f[y][j-1] - f[x][j-1]) / (double)(SA[y] - SA[x]))
#define int long long
using namespace std;
inline int read()
{
	int res = 0;
	char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') { res = res * 10 + c - 48; c = getchar(); }
	return res;
}
const int N = 2005;
int n, m, A[N], B[N], SA[N], SB[N];
int f[N][N];
struct mono_que
{
	int v[N], hd, tl;
	inline int front() { return v[hd]; }
	inline int front2() { return v[hd + 1]; }
	inline int back() { return v[tl]; }
	inline int back2() { return v[tl - 1]; }
	inline void pop_front() { hd++; }
	inline void pop_back() { tl--; }
	inline void push(int i) { v[++tl] = i; }
} moq[N], bigmono;
signed main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) A[i] = read() - 1;
	for(int i = 1; i <= m; i++) B[i] = read() - 1;
	for(int i = 1; i <= n; i++) SA[i] = SA[i - 1] + A[i];
	for(int i = 1; i <= m; i++) SB[i] = SB[i - 1] + B[i];
	f[0][0] = 0;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			f[i][j] = SA[i] * SB[j];
	for(int j = 1; j <= m; j++) // 初始化每一列的单调队列 
	{
		moq[j].hd = 0; moq[j].tl = 1;
		moq[j].push(1);
	}
	for(int i = 2; i <= n; i++)
	{
		bigmono.hd = 1; bigmono.tl = 0;
		f[i][1] = SA[i] * B[1]; // 初始化当前行的单调队列 
		bigmono.push(1);
		for(int j = 2; j <= m; j++)
		{
			// (i-1, k) 
			while(bigmono.hd < bigmono.tl && Slope1(bigmono.front(), bigmono.front2()) < A[i])  
				bigmono.pop_front();
			f[i][j] = min(f[i][j], f[i-1][bigmono.front()] - A[i] * SB[bigmono.front()] + A[i] * SB[j]);
			while(bigmono.hd < bigmono.tl && Slope1(bigmono.back2(), bigmono.back()) >= Slope1(bigmono.back2(), j))
				bigmono.pop_back();
			bigmono.push(j);
			
			// (k, j-1) 这里只求值，暂时不加入
			while(moq[j-1].hd < moq[j-1].tl && Slope2(moq[j-1].front(), moq[j-1].front2()) < B[j])
				moq[j-1].pop_front();
			f[i][j] = min(f[i][j], f[moq[j-1].front()][j-1] - B[j] * SA[moq[j-1].front()] + B[j] * SA[i]);
		}
		for(int j = 1; j <= m; j++) // 更新每一列的单调队列
		{
			while(moq[j].hd < moq[j].tl && Slope2(moq[j].back2(), moq[j].back()) >= Slope2(moq[j].back2(), i))
				moq[j].pop_back();
			moq[j].push(i);
		}
	}
	printf("%lld\n", f[n][m]);
	return 0;
}
```

---

## 作者：灵乌路空 (赞：3)

# 知识点：DP

Updated on 10.4：感谢 @[七色丶人偶使](https://www.luogu.com.cn/user/249294) 指出错误！

原题面： [Luogu](https://www.luogu.com.cn/problem/P1846)

---

## 扯

考试题，场上写挂爆零了没到 300= =   
写错变量名就是真的离谱。


---

## 题意简述

>给定两数列 $a,b$，长度分别为 $n,m$，可以做如下操作：  
>删除 $a$ 的最后 $x(x\ge 1)$ 个数，设其和为 $sum_a$，删除 $b$ 的最后 $y(y\ge 1)$ 个数，其花费为 $sum_b$。  
>该次操作的总花费为 $(sum_a - x) \times (sum_b - y)$。  
>一直操作到 $a,b$ 均为空，最小化所有操作的总花费。  
>$1\le n,m\le 2000$，$1\le a_i\le 1000$。


---

## 分析题意

### 40pts

~~感谢出题人送的超高暴力分！~~  

暴力 DP，设 $f_{i,j}$ 表示将数列 $a$ 删剩下 $i$ 个，数列 $b$ 删剩下 $j$ 个时，需要的最小的花费。  
转移时枚举两数列最后一次删除的长度 $x,y$，则有很简单但是写起来很长的方程：  

$$f_{i,j} = \left\{ \min_{x=1}^{n-i}\min_{y=1}^{m-j} \left(f_{i+x,j+y} + \left(\sum_{k=i+1}^{i+x}a_k - x\right) \times \left(\sum_{k=j+1}^{j+y}b_l - y\right)\right)\right\}$$

可以使用前缀和预处理 $\sum a$ 和 $\sum b$，转移复杂度 $O(n^2m2)$。  
由于要保证不出现一个数列为空，一个不为空的情况，统计答案时枚举最后一次删除的长度，则有：  

$$ans = \min_{i=1}^{n}\min_{j=1}^{m}\left\{ f_{i,j} + \left(\sum_{k=1}^{i} a_k - i\right) \times \left(\sum_{l=1}^{j} b_l - j\right)\right\}$$

统计答案复杂度为 $O(nm)$，总复杂度为 $O(n^2m^2)$。

---

### 一点性质

发现选择一个数的贡献，是该数的值，减去 1。  
考虑将所有数都减去 1，转移方程变为：  

$$f_{i,j} = \left\{ \min_{x=1}^{n-i}\min_{y=1}^{m-j} \left(f_{i+x,j+y} + \sum_{k=i+1}^{i+x}a_k \sum_{k=j+1}^{j+y}b_l \right)\right\}$$

转移方程会比较好写，并且减小了某些分析的难度。  
以下分析均在此方程下展开。

---

### 60pts

一个结论：每次各删除 $a$，$b$ 中的一段数时，一定有一边删除的个数为 $1$。

是不是很扯皮？  
略证，对于某次操作，设删除的部分为 $a_i \sim a_{i+x}$，$b_j \sim b_{j+y}$。删除它们的花费即为：   
$$\sum_{k=i}^{i+x} a_k\sum_{l=j}^{j+y} b_l$$

设存在一组 $x',y'$，满足：$1\le x'<x$，$1\le y'<y$。  
如果先删除 $a_{i+x'}\sim a_{i+x}$ 和 $b_{j+y'} \sim b_{j+y}$，再删除 $a_{i}\sim a_{i+x'-1}$ 和 $b_{j}\sim b_{j + y' - 1}$，其花费为：  

$$\begin{aligned}
  &\sum_{k=i}^{i+x'-1} a_k\sum_{l=j}^{j+y'-1} b_l + \sum_{k=i+x'}^{i+x} a_k\sum_{l=j+y'}^{j+y} b_l\\
  \le& \sum_{k=i}^{i+x} a_k\sum_{l=j}^{j+y} b_l\\
  =& \left(\sum_{k=i}^{i+x'-1} a_k + \sum_{l=j}^{j+y'-1} b_l\right) \times \left(\sum_{k=i+x'}^{i+x} a_k + \sum_{l=j+y'}^{j+y} b_l\right)
\end{aligned}$$

将一大段被删除的数划分成更小的段，代价一定不会更劣。  
则最后一定会划分出长度为 $1$ 的删除段，结论成立。

---

则可修改状态转移方程，钦定一边选仅一个，仅需枚举另一边的选择个数，即仅枚举 $x$ **或** $y$。  
转移复杂度变为 $O(nm(n + m))$。

---

### 100pts

考虑优化状态。  
发现转移时需要钦定一边只选择 $1$ 个。若钦定 $a$ 仅选择 $1$ 个，有用状态的 $i'$ 均为当前状态的 $i+1$。  

设 $f_{i,j}$ 表示将数列 $a$ 删剩下 $i$ 个，数列 $b$ 删剩下 $j$ 个时，且上一次删数时钦定 $a$ 删除了 $1$ 个，需要的最小花费。  
同理，设 $g_{i,j}$ 表示上一次删数时钦定 $b$ 删除了 $1$ 个，需要的最小的花费。  

---

考虑转移，以 $f_{i,j}$ 为例，分类讨论：   

1. $a,b$ 均删除 $1$ 个，代价即为 $a_{i+1}\times b_{j+1}$。  
   上一次删多少不受影响，显然可以从 $f_{i+1,j+1}$ 和 $g_{i+1,j+1}$ 转移而来。  
   则有转移：  

   $$f_{i,j} = \min\left\{ f_{i+1,j+1},g_{i+1,j+1}\right\} + a_{i+1}\times b_{j+1}$$
2. $a$ 删除 $1$ 个，$b$ 删除 $y(y>1)$ 个，则其代价为 $a_{i+1}\times \sum_{k=j+1}^{j+y} b_{k}$。  
   发现代价可以拆成 $a_{i+1}\times b_{j+1} + a_{i+1} \times \sum_{k=j+2}^{j+y} b_k$。  
   对于后一项，其已经被统计到 $i'=i,j'=j+1$ 的情况中了。  
   则有转移：  
   $$f_{i,j} = f_{i,j+1} + a_{i+1}\times b_{j+1}$$

   

综上，则有：  

$$f_{i,j} = \min\left\{ f_{i,j+1},f_{i+1,j+1},g_{i+1,j+1}\right\} + a_{i+1}\times b_{j+1}$$

同理，对于 $g_{i,j}$，有： 

$$g_{i,j} = \min\left\{ g_{i+1,j},f_{i+1,j+1},g_{i+1,j+1}\right\} + a_{i+1}\times b_{j+1}$$

每次转移是 $O(1)$ 的，转移总复杂度 $O(nm)$。  
答案即为 $\min \{f_{0,0}, g_{0,0}\}$

---

## 为啥你的状态和别人不一样啊？

发现上面两个转移方程形式基本相同，所以可以合并状态。  
就得到了其他题解的形式。

---

## 爆零小技巧

有些看起来无意义的状态仍然对答案有贡献。  
比如当 $i,j$ 其中有一个为 $0$ 时，


---

## 代码实现

```cpp
//知识点：DP 
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define ll long long
#define min std::min
const int kMaxn = 2e3 + 10;
//===========================================================
int n, m, a[kMaxn], b[kMaxn];
ll f[kMaxn][kMaxn], g[kMaxn][kMaxn];
//===========================================================
inline int read() {
  int w = 0, f = 1;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Chkmin(ll &fir, ll sec) {
  if (sec < fir) fir = sec; 
}
//===========================================================
int main() {
  n = read(), m = read();
  for (int i = 1; i <= n; ++ i) a[i] = read() - 1;
  for (int i = 1; i <= m; ++ i) b[i] = read() - 1;
  
  memset(f, 127, sizeof (f));
  memset(g, 127, sizeof (g));
  f[n][m] = g[n][m] = 0;
  
  for (int i = n - 1; i >= 0; -- i) {
    for (int j = m - 1; j >= 0; -- j) {
      ll val = 1ll * a[i + 1] * b[j + 1];
      Chkmin(f[i][j], min(f[i][j + 1], min(f[i + 1][j + 1], g[i + 1][j + 1])) + val);
      Chkmin(g[i][j], min(g[i + 1][j], min(f[i + 1][j + 1], g[i + 1][j + 1])) + val);
    }
  }
  printf("%lld\n", min(f[0][0], g[0][0]));
  return 0;
}
/*
3 2
1 2 3 
1 2 
*/
```

---

## 作者：lijunxi20231818 (赞：2)

# 题意

给你两个序列（文中记为序列 $a$ 和序列 $b$），每次操作在两个序列中分别删去 $k_1$、$k_2$ 个数，和分别为 $s_1$、$s_2$，得分为 $(s_2-k_2)\times(s_1-k_1)$，求最小得分。

**注意：两个序列必须同时删完。**

# 思路

一眼 dp 题。


## dp 状态


每次操作得分是 $(s_2-k_2)\times(s_1-k_1)$，不妨直接将所有的值都 $-1$，这样得分就变为 $s_2\times s_1$，便于计算。

这样 dp 状态就很显然了：

$dp_{i,j}$ 表示 $a$ 序列删去 $i$ 个数，$b$ 序列删去 $j$ 个数时的最小得分。

## dp 转移
性质：

> 每次操作中，一定会有一个序列只删除了 $1$ 个数字。


证明：
> 反证法：
>
> 如果最优情况下，有一次操作在两个序列中都删除了 $\gt 1$ 个数字，则记两个操作为删除 $a$ 的子串 $sub_1$ 和删除 $b$ 的子串 $sub_2$。
>
> 此时，我们可以将 $sub_1$ 和 $sub_2$ 拆成更小的不空的子串：
>
> $sub_1\rightarrow sub_{1, 1} + sub_{1, 2}$
> 
> $sub_2\rightarrow sub_{2, 1} + sub_{2, 2}$
>
> 此时若将这次操作分为两次：
>
> 第一次操作 $sub_{1, 1}$ 、$sub_{1, 2}$，第二次操作 $sub_{2, 1}$、$sub_{2, 2}$。
>
> 这样的得分就从
>
> $(|sub_{1,1}|+|sub_{1,2}|)\times(|sub_{2,1}|+|sub_{2,2}|)$
>
> $ = |sub_{1,1}|\times|sub_{2,1}|+|sub_{1,1}|\times|sub_{2,2}|+|sub_{1,2}|\times|sub_{2,1}|+|sub_{1,2}|\times|sub_{2,2}|$
>
>变为：
>
> $|sub_{1,1}|\times|sub_{2,1}|+|sub_{1,2}|\times|sub_{2,2}|$
>
> （注：$|X|$ 表示串 $X$ 的长度）
>
> 后者显然更优。
>
> 与假设最优秀情况矛盾，性质得证。


考虑删除 $a$ 中 $1$ 个数的情况：


$
dp_{i,j}
=\min\limits_{k=1}^{j} (dp_{i-1,k-1}+a_i\times\sum\limits_{l=k}^{j}b_l)
$

但这样转移是 $O(n^3)$ 的，显然不行。

可以发现 $\min$ 里是对于 $b$ 的一个类似于前缀的东西。

可以将求和以及最小值拆分，得到：


$
dp_{i,j}
=\min\limits_{k=1}^{j} (dp_{i-1,k-1}+a_i\times\sum\limits_{l=k}^{j}b_l)
$

$
=\min\limits_{k=1}^{j} (dp_{i-1,k-1}+a_i\times\sum\limits_{l=k}^{j-1}b_l+a_i\times b_j)
$

$
=\min\limits_{k=1}^{j} (dp_{i-1,k-1}+a_i\times\sum\limits_{l=k}^{j-1}b_l)+a_i\times b_j
$

$
=\min(\min\limits_{k=1}^{j-1} (dp_{i-1,k-1}+\sum\limits_{l=k}^{j-1}b_l),dp_{i-1,j-1})+a_i\times b_j
$

$
=\min(dp_{i,j-1},dp_{i-1,j-1})+a_i\times b_j
$

相似地，考虑删除 $b$ 中 $1$ 个数的情况：

$
dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j-1})+a_i\times b_j
$

综上：

$dp_{i,j}=\min(dp_{i-1,j-1},dp_{i-1,j},dp_{i,j-1})+a_i \times b_j$

## dp 初始化

$dp_{0,0}=0$，其他全部设为 $+\infty$。

## 细节

由于原题目是从序列的末尾删除，我本来想的是先反转后 dp，但实际上没有影响，因为我们 dp 的本质是找到几对操作区间，操作顺序不重要。

# Code

[记录](/record/191050214)

```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for(register int i = l; i <= r; ++i)
const int maxn = 2e3 + 5;
using namespace std;
int n, m;
int a[maxn], b[maxn];
int dp[maxn][maxn];
signed main(){
	scanf("%d %d", &n, &m);
	rep(i, 1, n) scanf("%d", &a[i]), a[i]--;
	rep(i, 1, m) scanf("%d", &b[i]), b[i]--;
	reverse(a + 1, a + n + 1), reverse(b + 1, b + m + 1);//可加可不加
	memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0;
	rep(i, 1, n){
		rep(j, 1, m){
			dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + a[i] * b[j];
		}
	}
	cout << dp[n][m];
	return 0;
}
```

# 结语

很好的一道 dp 题，偏向考察思维（性质的发现和转移的优化），代码其实非常短。

---

## 作者：luyuxuan11 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P1846)

## 题意

在两个序列中取数，每次把取走数字的数字和减去数字个数再相乘得到积分，求积分最低是多少。

## 思路

考虑 dp
 - 因为要把取走数的和减去数字个数，所以对 $a_i$ 和 $b_i$ 一开始就减一，就可以直接相乘得出答案。
 - 我比较喜欢根据要求的答案来设计状态，本题求 $a$ 序列取 $n$ 个，$b$ 序列取 $m$ 个，可以设计 $f(i,j)$ 表示 $a$ 序列取 $i$ 个，$b$ 序列取 $j$ 个。
 - 对于每个 $f(i,j)$ 有三种情况：
   - $a$ 数列只取走 $a_i$，$b$ 数列只取走 $b_i$，显然 $f(i,j) = f(i - 1,j - 1) + a_i \times b_j$。

   - $a$ 数列取走 $a_i$ 时，$b$ 数列取走了 $b_j$ 到 $b_k$ 之间的数，$f(i,j) = f(i - 1,k - 1) + a_i \times \sum_{x = k} ^ {j} b_x$，而 $a_i \times \sum_{x = k} ^ {j} b_x$ 处理过 $f(i,j - 1)$，所以 $f(i,j) = f(i,j - 1) + a_i \times b_j$。

   - 同理，$f(i,j) = f(i-1,j) + a_i \times b_j$。

## 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define lyx std;
Code by lyx
typedef long long ll;
typedef pair<int,int> pii;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x*f;
}
int n,m;
int a[2005],b[2005];
int f[2005][2005];//第一个序列取了i个，第二个序列取了j个
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read()-1;//提前减去k_i
	for(int i=1;i<=m;i++)b[i]=read()-1;
	memset(f,127,sizeof(f));
	f[0][0]=0;//没有取数，积分为0
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=min(f[i][j],min(f[i-1][j-1],min(f[i-1][j],f[i][j-1])))+a[i]*b[j];
		}
	}
	cout<<f[n][m];
	return 0;
}




```

---

## 作者：断清秋 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1846)

以下认为 $n,m$ 同阶。

首先套路性观察，直接将每个数减 $1$ 把式子转化成 $s_1 \times s_2$ 保证跟选数个数无关。

然后考虑这个删数本质上就是把两个序列分成多个连续段，每个对应段之间匹配，所以从前面开始删还是从后面开始删不影响最终结果。

稍微观察一下就能直观感受到这个乘积的形式两边都选 $>1$ 个数显然是不优的，证明也很显然，直接把一边拆开再乘肯定比放在一起乘的答案要小。

所以能够得出每组匹配中，至少有一段的长度 $=1$。那么就可以考虑状态转移了。

设 $f_{i,j}$ 表示第一个序列选前 $i$ 个数，第二个序列选前 $j$ 个数的最小贡献。然后一个显然的转移是枚举当前匹配的两段中长度不为 $1$ 的那一段选数的数量，于是有 $f_{i,j}=\min(f_{i-1,j-k}+a_i\sum\limits_{p=k+1}^jb_p,f_{i-k,j-1}+b_j\sum\limits_{p=k+1}^ia_p)$，前缀和优化可以做到 $O(n^3)$。

发现瓶颈在枚举 $k$ 上。如果依然需要枚举选数个数的话我们第一个观察就白做了。考虑从这个角度入手优化。

设 $s_i,t_i$ 分别为 $a,b$ 序列的前缀和。

考虑对于 $dp_{i,j}$，如果它能从 $f_{i-1,j-k}+a_i(s_j-s_k)$ 转移过来，那么必然是 $a_i$ 之前已经乘了一段数了。那么实际上转移过来就只多了 $b_j$ 一项，直接从 $dp_{i,j-1}+a_i \times b_j$ 转移过来即可。

其他情况也是同理的。于是可以把状态转移方程重新写成 $f_{i,j}=\min(f_{i,j-1}+a_i\times b_j,f_{i-1,j}+b_j\times a_i,f_{i-1,j-1}+a_i\times b_j)$。

直接转移即可，时间复杂度 $O(n^2)$。

当然如果没注意到这个性质，对每一行和每一列都开个单调队列做，复杂度应该也是正确的……这个想法更加直观，不过写起来可能会稍微麻烦一点。

---

## 作者：__liujy (赞：0)

## 零. 前言
- 前置知识：动态规划。
- 所用数组：$dp_{i,j}$ 表示第一个数列前 $i$ 个，第二个数列前 $j$ 个的最小总分。
- 在下文中用 $a$ 表示第一个数列，$b$ 表示第二个数列。
## 壹. 思路
因为要把取走的数的和减去数字个数，因此一开始就对 $a_{i}$ 和 $b_{i}$ 减一，就能直接相乘。

接下来对于 $dp_{i,j}$ 有三种情况：

- $a$ 只取 $a_{i}$，$b$ 只取 $b_{j}$，显然 $dp_{i,j}=dp_{i-1,j-1}+a_{i} \times b_{j}$。
- $a$ 只取 $a_{i}$，$b$ 取走 $b_{j}$ 到 $b_{k}$ 之间的数。$dp_{i,j}=dp_{i-1,k-1}+a_{i} \times \sum^{j}_{p=k} b_{p}$，观察一下式子，发现 $a_{i} \times \sum^{j}_{p=k} b_{p}$ 已经在 $dp_{i,j-1}$ 中所过了，因此所以可以从 $dp_{i,j-1}$ 推出 $dp_{i,j}$，也就是说 $dp_{i,j}=dp_{i,j-1}+a_{i} \times b_{j}$。
- 同理，还有一个就是 $dp_{i,j}=dp_{i-1,j}+a_{i} \times b_{j}$。

综上所述 $dp_{i,j}=\min(dp_{i-1,j-1}+a_{i} \times b_{j},dp_{i-1,j}+a_{i} \times b_{j},dp_{i,j-1}+a_{i} \times b_{j})$，稍微整理以下 $dp_{i,j}=\min(dp_{i-1,j-1},dp_{i-1,j},dp_{i,j-1})+a_{i} \times b_{j}$。
## 贰. 代码
```cpp
// P1846 游戏
#include<bits/stdc++.h>
const int MAXN=2005;
const int INF=0x3f3f3f3f;
int n,m,a[MAXN],b[MAXN],dp[MAXN][MAXN];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]--;
    for(int i=1;i<=m;i++) scanf("%d",&b[i]),b[i]--;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            dp[i][j]=INF;
    dp[0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            dp[i][j]=std::min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]})+a[i]*b[j];
    printf("%d\n",dp[n][m]);
    return 0;
}
```

---

## 作者：vеctorwyx (赞：0)

说真的，这题真的没有看上去这么难，其实一想懂就觉得很简单了（~~虽然我做了两遍还是差点没做出来~~）

1. 每次减去数列个数可以在输入上预处理减一，然后价值就变成了$S_1*S_2$

1. 因为$S_1=\sum_{i=l}^{r}a_i$，$S_2=\sum_{i=x}^yb_i$,

	所以$S_1*S_2=\sum_{i=l}^{r}a_i*\sum_{i=x}^yb_i$，

	这时如果把他分开乘，即设$S_3=\sum_{i=l}^{r}\sum_{i=x}^ya_ib_i$，
    
    根据乘法分配律，能证明对于任意$S_3$，$S_3\le S_1*S_2$恒成立（随便弄个数据手玩一下就知道了）
    
    
  **综上所述**,我们可以得出结论：
  
  最优解仅可能出现在以下情况中
    
   1. $b$序列一个与$a$序列多个

   2. $a$序列一个与$b$序列多个

   3. 两个序列个各一个
   
  同时1情况和2情况可以转化为多个3情况重复出现
  
  于是我们得到了以下状态转移方程（倒叙枚举）：
  
  $dp_{i,j}=\min (dp_{i+1,j+1}+a_i*b_j,dp_{i+1,j}+a_i*b_j,dp_{i,j+1}+a_i*b_j,)$
  
  别忘了判断边界！
  
  code：
  ```
    #include<bits/stdc++.h>
    #define int long long
    #define main signed main
    using namespace std;
    int n,m,a[2010],b[2010],dp[2010][2010];
    main()
    {
        memset(dp,0x7f7f7f,sizeof(dp));//初始化
          cin>>n>>m;
          for(int i=1;i<=n;i++)
          {
              cin>>a[i];
              a[i]--;
          }
          for(int i=1;i<=m;i++)
          {
              cin>>b[i];
              b[i]--;
          }
          dp[n][m]=a[n]*b[m];//初始点赋值
          for(int i=n;i>=1;i--)
          {
              for(int j=m;j>=1;j--)
              {
                  if(i<n&&j<m)
                  dp[i][j]=min(dp[i][j],dp[i+1][j+1]+a[i]*b[j]);
                  if(i<n)
                  dp[i][j]=min(dp[i][j],dp[i+1][j]+a[i]*b[j]);
                  if(j<m)
                  dp[i][j]=min(dp[i][j],dp[i][j+1]+a[i]*b[j]);
              }
          }
          cout<<dp[1][1];
      }
 ```
      
当然正序枚举也是可以的，~~只是我懒没写到题解里。~~
                  

---


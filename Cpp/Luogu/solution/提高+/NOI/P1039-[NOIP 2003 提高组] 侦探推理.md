# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# 题解

## 作者：wjyyy (赞：27)

**我的博客：[传送门](https://www.wjyyy.top/2305.html)**

## 题解：

这个题数据范围比较小，考虑枚举，但是枚举谁说真话谁说假话也比较耗时，但是我们发现日期只有一天，罪犯也只有一个，考虑枚举罪犯是谁，和今天是星期几。

在读入每一句话时，把这一句的主人（即冒号前的人）对应到它的编号，这里推荐使用`std::map`，然后判断种类，如果语句不合法就不读这句话，并用`gets()`把这一行读完进入下一句。如果发现第一个单词是人名，则用`std::map`找到它的编号，然后看它是**肯定句**还是**否定句**。对于每一个点开一个`vector`用来存它说过的**合法**的话，区分一下这句话是说人的信息还是日期，如果说人的信息还需要对应到对象，这里最好把`I`转化为自己的名字。

接着就可以枚举罪犯和日期了，因为有的人自始至终都没有说过一句合法的话，这样的人既可能说真话也可能说假话，我们用一个变量$ran$来存有多少个这样的人，剩下的人根据它第一句话来确定它是说真话还是说假话。如果一个人前后矛盾，即前面说真话后面说假话，那么这次枚举就不合法，可以直接跳到下次枚举去。

在一次成功的枚举中，我们得知了有多少人说假话，有多少人不确定，假设说假话的人有$cnt$个，并有$ran$个人不确定，那么当要求说假话的人数在$[cnt,cnt+ran]$范围内就合法。

如果一个罪犯被多次确定，是不会对答案造成额外影响的，但是当确定一个罪犯时发现前面已经确定一个人了，此时就要输出`Cannot Determine`了。当程序结束时还没有找到一个罪犯，则输出`Impossible`。找到罪犯了输出名字即可。

`stl`还是非常方便的，`std::string`用来存名字并进行字符串处理；`std::map`用来映射人名；`std::vector`用来存每个人说的话。不过这个题有一个比较坑的地方，必须要确定一个人说的一句话**每个单词**都合法后，才能把这整句话当作合法的。`&&`一定要注意单词后面的冒号和句号！

## Code：
以前以为码量很大，但是只要注意细节，条理清晰，$\sout{130}$~~行~~是很容易写出来的。

```cpp
#include<iostream>
#include<map>
#include<vector>
#include<cstdio>
using namespace std;
map<string,int> per;//存人名
string nm[25];
map<string,int> day;//映射日期
struct sta
{
    int u;//u表示主语
    bool to;//0表示罪犯，1表示日期
    bool is;//表示肯定或否定
    sta(int u,bool to,bool is)
    {
        this->u=u;
        this->to=to;
        this->is=is;
    }
    sta(){}
};
vector<sta> v[25];
char asdfghjkl[1000];//用来读废掉的语句
int main()
{
    int n,m,p;
    cin>>n>>m>>p;
    string s;
    for(int i=1;i<=n;++i)
    {
        cin>>s;
        per[s]=i;
        nm[i]=s;
    }
    per["Today"]=n+1;
    day["Monday."]=1;//句号是因为答案
    day["Tuesday."]=2;
    day["Wednesday."]=3;
    day["Thursday."]=4;
    day["Friday."]=5;
    day["Saturday."]=6;
    day["Sunday."]=7;
    for(int i=1;i<=p;++i)
    {
        cin>>s;
        s=s.substr(0,s.size()-1);//自动去掉
        int t=per[s];
        cin>>s;
        int u=per[s];
        if(u<=n)//表示人名
        {
            cin>>s;
            if((u&&s!="is")||(!u&&s!="am"))
            {
                gets(asdfghjkl);
                continue;
            }
            if(!u)
                u=t;
            cin>>s;
            if(s=="not")
            {
                cin>>s;
                if(s=="guilty.")
                    v[t].push_back(sta(u,0,0));
            }
            else if(s=="guilty.")
                v[t].push_back(sta(u,0,1));
        }
        else if(u==n+1)//表示日期
        {
            cin>>s;
            if(s!="is")
                continue;
            cin>>s;
            if(day[s])
                v[t].push_back(sta(day[s],1,1));
        }
        else
            gets(asdfghjkl);
    }
    string ans="";
    //枚举谁是罪犯
    for(int i=1;i<=n;++i)
    {
        //枚举今天星期几
        for(int j=1;j<=7;++j)
        {
            int flag=0,cnt=n,ran=0;//ran表示波动范围
            for(int k=1;!flag&&k<=n;++k)
            {
                vector<sta>::iterator it=v[k].begin();
                if(!v[k].size())
                {
                    ++ran;
                    continue;
                }
                sta tmp=*it;
                bool rea;
                if(tmp.to)
                    rea=(tmp.u==j);
                else
                    rea=((tmp.u==i)^(!tmp.is));
                ++it;
                for(;!flag&&it!=v[k].end();++it)
                {
                    if(it->to)
                    {
                        if(rea!=(it->u==j))
                            flag=1;
                    }
                    else
                    {
                        if(rea==((it->u==i)^it->is))
                            flag=1;
                    }
                }
                cnt-=rea;
            }
            if(!flag&&cnt>=m&&cnt-ran<=m)
            {
                if(ans=="")
                    ans=nm[i];
                else if(ans!=nm[i])
                {
                    cout<<"Cannot Determine"<<endl;
                    return 0;
                }
            }
        }
    }
    if(ans=="")
        cout<<"Impossible"<<endl;
    else
        cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Ebola (赞：14)

> 这是一篇刚刚被撤下的题解，因为 markdown 排版的问题，目前已经修复。另外我发现八年前我的文笔确实相当稚嫩，但我不打算修改本文措辞，因为这确实见证了一些个人的成长。

大家不要被题面吓到，其实这题不算很难。

## 总体思路

首先是读入，我采用了一个二维数组来保存证言，第一维是人名，第二维表示此人说的第几句话。接下来我们进行枚举，第一重循环枚举人名（$1\sim m$），第二重循环枚举星期几（$1\sim 7$）。对于每一次枚举，我们进行两次判断：第一个判断是判断是否有人既说了真话又说了假话（题目中有谈到说一个人要么全部说真话，要么全部说假话），出现了这种情况可以直接说明枚举条件不成立；第二个判断是判断说假话的人数是否为 $n$ 个。如果以上两个判断都成立，则可以认定这个枚举条件是一个解。

## 细节

- 读入

  我在这里被坑死了，也许是我菜吧，`getline`、`gets`、`getchar`居然全部出了莫名错误。好吧，我最后选择了 `cin`，将证言一个一个单词读入，遇到标点符号则退出。具体参见 `gl` 函数。

- 废话的处理

  因为有些人会说废话，而这些废话没有任何实际意义，故我们应该舍弃废话。我写了一个 `crap` 函数，判断是否为废话，这个函数代码清晰明了，请自行阅读。如果是废话则直接摒弃。

- 判断一

  我上面说到的判断一体现在我代码里的 `judge` 函数中。枚举人名，每遇到一句假话，`ans++`，我们会发现，`ans==0` 表示此人全说真话，`ans==此人总共说的话` 表示此人全部说假话。假如 `ans==其它数`，则直接认为与题设冲突，枚举条件不成立。

- 判断二

  我上面说到的判断二体现在我代码里的 `check` 函数中。枚举人名，遇到假话，则说假话的人数++，然后直接 `break` 出去判断下一个人。如果 `说假话的人数==n`，则枚举条件成立。这里有个细节，就是要考虑没说话的人，这个细节的处理方法可以看一下我的代码。


## 奉上C++代码：









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
using namespace std;
map<string,int> name;
string s,ss;
string names[25];
string testimony[25][105];
int num[25];
int n,m,p;
bool crap(string tmp)
{
    if(tmp==" I am guilty.") return 0;
    if(tmp==" I am not guilty.") return 0;
    if(tmp==" Today is Monday.") return 0;
    if(tmp==" Today is Tuesday.") return 0;
    if(tmp==" Today is Wednesday.") return 0;
    if(tmp==" Today is Thursday.") return 0;
    if(tmp==" Today is Friday.") return 0;
    if(tmp==" Today is Saturday.") return 0;
    if(tmp==" Today is Sunday.") return 0;
    for(int i=1;i<=m;i++)
        if(tmp==" "+names[i]+" is guilty."||tmp==" "+names[i]+" is not guilty.") return 0;
    return 1;
}
bool judge(int guilty,int day)
{
    int ans;
    for(int i=1;i<=m;i++)
    {
        ans=0;
        for(int j=1;j<=num[i];j++)
        {
            if(testimony[i][j]==" I am guilty."&&guilty!=i) {ans++;}
            if(testimony[i][j]==" I am not guilty."&&guilty==i) {ans++;}
            if(testimony[i][j]==" Today is Monday."&&day!=1) {ans++;}
            if(testimony[i][j]==" Today is Tuesday."&&day!=2) {ans++;}
            if(testimony[i][j]==" Today is Wednesday."&&day!=3) {ans++;}
            if(testimony[i][j]==" Today is Thursday."&&day!=4) {ans++;}
            if(testimony[i][j]==" Today is Friday."&&day!=5) {ans++;}
            if(testimony[i][j]==" Today is Saturday."&&day!=6) {ans++;}
            if(testimony[i][j]==" Today is Sunday."&&day!=7) {ans++;}
            for(int k=1;k<=m;k++)
            {
                if(testimony[i][j]==" "+names[k]+" is guilty."&&guilty!=k) {ans++;}
                if(testimony[i][j]==" "+names[k]+" is not guilty."&&guilty==k) {ans++;}
            }
        }
        if(ans!=num[i]&&ans!=0) return 0;
    }
    return 1;
}
int check(int guilty,int day)
{
    int ans=0;
    bool twice;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=num[i];j++)
        {
            twice=0;
            if(testimony[i][j]==" I am guilty."&&guilty!=i) {ans++;break;}
            if(testimony[i][j]==" I am not guilty."&&guilty==i) {ans++;break;}
            if(testimony[i][j]==" Today is Monday."&&day!=1) {ans++;break;}
            if(testimony[i][j]==" Today is Tuesday."&&day!=2) {ans++;break;}
            if(testimony[i][j]==" Today is Wednesday."&&day!=3) {ans++;break;}
            if(testimony[i][j]==" Today is Thursday."&&day!=4) {ans++;break;}
            if(testimony[i][j]==" Today is Friday."&&day!=5) {ans++;break;}
            if(testimony[i][j]==" Today is Saturday."&&day!=6) {ans++;break;}
            if(testimony[i][j]==" Today is Sunday."&&day!=7) {ans++;break;}
            for(int k=1;k<=m;k++)
            {
                if(testimony[i][j]==" "+names[k]+" is guilty."&&guilty!=k) {ans++;twice=1;break;}
                if(testimony[i][j]==" "+names[k]+" is not guilty."&&guilty==k) {ans++;twice=1;break;}
            }
            if(twice==1) break;
        }
    if(ans!=n)
        for(int i=1;i<=m;i++)
        {
            if(num[i]==0) ans++;
            if(ans==n) break;
        }
    return ans;
}
int read()
{
    char c=getchar();
    int ans=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
    {
        ans=ans*10+c-48;
        c=getchar();
    }
    return ans;
}
string gl()
{
    string sss,c;
    do
    {
        cin>>c;
        sss=sss+" "+c;
    }
    while(c[c.size()-1]!='.'&&c[c.size()-1]!='?'&&c[c.size()-1]!='!'&&c[c.size()-1]!=',');
    return sss;
}
int main()
{
    m=read();n=read();p=read();
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        name[s]=i;
        names[i]=s;
    }
    for(int i=1;i<=p;i++)
    {
        cin>>s;
        s=s.substr(0,s.size()-1);
        ss=gl();
        if(crap(ss)) continue;
        num[name[s]]++;
        testimony[name[s]][num[name[s]]]=ss;
    }
    int flag=0;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=7;j++)
            if(check(i,j)==n&&judge(i,j))
            {
                if(flag!=0)
                {
                    cout<<"Cannot Determine"<<endl;
                    return 0;
                }
                else
                {
                    flag=i;
                    break;
                }
            }
    if(flag==0) cout<<"Impossible"<<endl; else cout<<names[flag]<<endl;
    return 0;
}

```

---

## 作者：Lovelace_qwq (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1039)

题目有点难懂的。可爱中模拟。

感觉我这个版本可能是题解区暂时最适于自己阅读的。至少对于我的知识水平，其他几位巨佬的我看不大懂（？


## 题意简述
$m$ 个人，说了 $p$ 句话，其中有 $n$ 句假话。

需要推断出唯一的凶手并输出其名字。

若凶手不唯一，输出`Cannot Determine`；

若找不到凶手，输出`Impossible`。

## 大致思路
这不就是经典三年级奥数。

统一的解决方法是，假设一个日期，假设一个凶手。

以此为基础来鉴定大家说的话是否都符合当前情况。

若凶手可以确定，则一定**有且仅有一种**假设是成立的。

若凶手不唯一，则有**多种**假设是成立的。

若找不到凶手，则**无**假设成立。

不多赘述，我觉得代码注释已经很清晰了。

## 易错点

1. 字符串请直接从题面中复制下来。

2. 不要漏字符串中的空格！！！冒号前后都是有空格的！！！

3. 洛谷的数据比较绷（？），字符串最后会有一个多余的空格，需要删去。

4. 注意假话可能也是无意义的。
## 代码

请从**主函数**开始阅读。~~不然真的会晕，我自己都看不懂。~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define endl '\n'
using namespace std;
//xi huan yue zheng ling zen mo ni le
//0412 0412 0412 a ling sheng ri kuai le!
int m,n,p,guilty=-1;
int vis[105];
string name[105];
pair<int,string> sen[105];
string weekday[]={
	"Today is Monday.",
	"Today is Tuesday.",
	"Today is Wednesday.",
	"Today is Thursday.",
	"Today is Friday.",
	"Today is Saturday.",
	"Today is Sunday."
}; 
int getid(string s){//为名字编号 
	for(int i=0;i<m;i++){
		if(s==name[i]){
			return i;
		}
	}
	return -1;
}
//真话返回0 假话返回1 无意义的话返回-1 
int judge(int day,int gui,int now,string s){
	//day:假设的天数
	//gui：假设的罪犯
	//now:现在需要鉴定的人
	//s:now说的需鉴定的话 
	//需要分成五种情况讨论。 
	if(s=="I am guilty."){
		return gui!=now; //如果此人就是假设罪犯，他说的是真话 
	}
	if(s=="I am not guilty."){
		return gui==now; //如果此人就不是假设罪犯，他说的是真话 
	}
	for(int i=0;i<m;i++){
		if(name[i]+" is guilty."==s){
			return i!=gui; //如果他指认的确实是假设罪犯，他说的是真话 
		}
	}
	for(int i=0;i<m;i++){
		if(name[i]+" is not guilty."==s){
			return i==gui; 	//如果他洗白的确实不是假设罪犯，他说的就是真话 
		}
	}
	for(int i=0;i<7;i++){
		if(weekday[i]==s){//如果此人提供的日期就是假设日期，他说的就是真话 
			return day!=i;
		}
	}
	return -1;//剩下的都是无意义的话了。 
}
bool check(int day,int man){
	memset(vis,-1,sizeof vis);
	for(int i=0;i<p;i++){
		pair<int,string>sente=sen[i];
		int t=judge(day,man,sente.first,sente.second);
	//	cout<<t<<endl;
		int q=sente.first;
		if(t==0){//这句话是真话 
			if(vis[q]==-1){
				vis[q]=0;//把这句话标记一下 
			}else if(vis[q]==1){
				return 0;//如果这句话之前被证明过是真的，现在被推翻了，则假设不成立 
			}
		}else if(t==1){
			if(vis[q]==-1){
				vis[q]=1;
			}else if(vis[q]==0){
				return 0;
			}
		}
	}
	int cntf=0,cnto=0;//cntf:说假话的人数 cnto：说无意义话的人数 
	for(int i=0;i<m;i++){
		if(vis[i]==1)cntf++;
		else if(vis[i]==-1)cnto++;
	}
	//注意到，有的无意义话也可以是假话。 
	return cntf<=n&&cntf+cnto>=n;
}

main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>m>>n>>p;//输入人数，始终说谎的人数，证言数量 
	for(int i=0;i<m;i++){
		cin>>name[i];
	}
	for(int i=0;i<p;i++){
		string nam,say;
		cin>>nam;
		nam.erase(nam.end()-1);//删除人名和冒号间的空格 
		getline(cin,say);//注意到行末有一个空格。需要用getline读入。 
		say.erase(say.end()-1);//删除冒号 
		say.erase(say.begin());//删除行末空格 
		sen[i]=make_pair(getid(nam),say); //将名字编号和说的话打包。 
	}
	int cnt;//用于计算成立的假设数量 
	for(int day=0;day<7;day++){//枚举假设的时间 
		cnt=0;
		for(int i=0;i<m;i++){//枚举假设的罪犯编号 
			if(check(day,i)){ 
				cnt++;//若该假设成立，则成立数量+1，猜想罪犯为i 
				guilty=i;
			}
		}
		if(cnt>1){//成立方案不止一种，则不止一个人可能成为罪犯	
			cout<<"Cannot Determine";
			return 0;
		}
	}
	if(guilty==-1){//经过了所有假设后，依然找不到罪犯 
		cout<<"Impossible";
	}else{
		cout<<name[guilty];//输出编号对应的罪犯 
	}
	return 0;
}

```

---

## 作者：Lan_yan (赞：5)

~~很像小学学某思的奥数题。~~

但是我们的计算机可没有所谓机灵的脑袋，那就枚举所有情景。

模拟每个人是罪犯和今天的日期，模拟每一句话，发现始终说谎的人数。

如果有人真假话都说或者大于 $N$ 个直接跳过该情景。

如果发现和前面情景推定的凶手不同或者有多个凶手可能性即输出 `Cannot Determine`。

如果所有情景都没有凶手即输出 `Impossible`。

否则即输出名字。

这边输入与判断建议用 string，容易发现 string 比较好比较，插入也很方便。

假设该字符串为 $y$，删除最后一个字符用 `y.erase(y.length()-1,1);`。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[25],rub[105];
int n,m,p,wer=0,tf[21];
string name[21];
string bish[105],ans[21];
void dat(int x,int y)
{
	int i,j,t=0,f=0;
	for(i=0;i<p;i++)
	{
		int flag;
		if(bish[i]=="Today is Monday.")
		{
			if(y==1)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Tuesday.")
		{
			if(y==2)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Wednesday.")
		{
			if(y==3)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Thursday.")
		{
			if(y==4)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Friday.")
		{
			if(y==5)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Saturday.")
		{
			if(y==6)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="Today is Sunday.")
		{
			if(y==7)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="I am guilty.")
		{
			if(rub[i]==x)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		if(bish[i]=="I am not guilty.")
		{
			if(rub[i]!=x)flag=1;
			else flag=0;
			if(tf[rub[i]]==-1)tf[rub[i]]=flag;
			if(tf[rub[i]]!=flag)return;
		}
		for(j=0;j<m;j++)
		{
			string d=name[j]+" is guilty.";
			if(d==bish[i])
			{
				if(j==x)flag=1;
				else flag=0;
				if(tf[rub[i]]==-1)tf[rub[i]]=flag;
				if(tf[rub[i]]!=flag)return;
			}
		}
		for(j=0;j<m;j++)
		{
			string d=name[j]+" is not guilty.";
			if(d==bish[i])
			{
				if(j!=x)flag=1;
				else flag=0;
				if(tf[rub[i]]==-1)tf[rub[i]]=flag;
				if(tf[rub[i]]!=flag)return;
			}
		}
	}
	for(i=0;i<m;i++)
	{
		if(tf[i]==1)t++;
		if(tf[i]==0)f++;
	}
	if(f>n||t>m-n)return;
	ans[wer++]=name[x];
}
int main()
{
	int i,j;
	scanf("%d%d%d",&m,&n,&p);
	for(i=0;i<m;i++)
		cin>>name[i];
	for(i=0;i<p;i++)
	{
		string x,y;
		cin>>x;
		x.erase(x.length()-1,1);
		for(j=0;j<m;j++)
			if(name[j]==x)rub[i]=j;
		getline(cin,y);
		y.erase(0,1);
		if(y[y.length()-1]=='\n'||y[y.length()-1]=='\r')
			y.erase(y.length()-1,1);
		bish[i]=y;
	}
	for(i=0;i<m;i++)
	{
		for(j=1;j<=7;j++)
		{
			memset(tf,-1,sizeof(tf));
			dat(i,j);
		}
	}
	if(wer<1)
	{
		printf("Impossible");
		return 0;
	}
	string lan=ans[0];
	for(i=1;i<wer;i++)
	{
		if(ans[i]!=lan)
		{
			printf("Cannot Determine");
			return 0;
		}
	}
	cout<<lan;
	return 0;
}
```

如果你想要珍惜自己的生命这边建议直接跳过该题。

---

## 作者：封禁用户 (赞：5)

### 题意
有 $M$ 个人（人名是大写字母），其中 $N$ 个始终说假话，另外 $M-N$ 个始终说真话，一共有 $P$ 句证词，其中只有 `I am guilty.`（自己是罪犯）、`I am not guilty.`（自己不是罪犯）、`Y is guilty.`（`Y` 是罪犯）、`Y is not guilty.`（`Y` 不是罪犯）和 `Today is X.`（今天是星期 `X`）是生效的，其余均无效，其中 `Y` 是人名，`X` 是星期单词，取值于 `Sunday`、`Monday`、`Tuesday`、`Wednesday`、`Thursday`、`Friday` 和 `Saturday` 之间。

如果有一个人可能是罪犯，输出这个人的名字，如果不止一个人可能是罪犯，输出 `Cannot Determine`，如果没有人可能是罪犯，输出 `Impossible`。

### 思路
暴力枚举所有可能的罪犯、星期，根据证词判断可能说假话的人数，一定说真话的记为 $0$，一定说假话的记为 $1$，没说话或者只说了无关话的记为 $-1$。对于每一种可能性，累加非 $-1$ 的数字记为 $x$，并统计 $-1$ 的个数记为 $y$，如果 $x \le N \le x+y$，则说明这个人可能成为罪犯（因为状态为 $-1$ 的人既可能是说真话的人，也可能是说假话的人），这时就不需要继续对这个人枚举星期了，直接枚举下一个人。

最后，如果只有 $1$ 个人可能是罪犯，输出其名字，否则如果至少 $2$ 个人可能是罪犯，输出 `Cannot Determine`，否则输出 `Impossible`。

### 剪枝
提供几种可能的剪枝思路：
- 如果一个人既说了真话也说了假话，那么就说明这种情况不可能（例如枚举到星期三的时候，有一个人既说今天星期三也说今天星期四），直接返回 `false`。
- 当一个人既说 $X$ 是罪犯，也说 $X$ 不是罪犯，或者说了全部 $7$ 种星期，则一定是不可能的，可以直接输出 `Impossible` 退出程序。
- 如果已经确定了 $2$ 个人可能成为罪犯，则跳过后面的枚举，直接输出 `Cannot Determine`。

### 注意

本题的数据疑似是在 Windows 系统下造的，洛谷的评测环境为 Linux，因此 `getline` 会多读一个 `\r`，这时我们要判断字符串末尾是否是空格或控制字符，如果是，把这个字符去掉以免影响后面的判断。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct word{
	string name;
	int saying;
	string gname="n";
};
string temname;
string said;
int m,n,k;
string name[25];word words[105];
map<string,int>mp;
string realguil="Impossible";
int judge(string saying){
	temname="n";
	if(saying=="Today is Monday.")return 1;
		if(saying=="Today is Tuesday.")return 2;
		if(saying=="Today is Wednesday.")return 3;
		if(saying=="Today is Thursday.")return 4;
		if(saying=="Today is Friday.")return 5;
		if(saying=="Today is Saturday.")return 6;
		if(saying=="Today is Sunday.")return 7;
		if(saying=="I am guilty.")return 1001;
		if(saying=="I am not guilty.")return 1000;
		if(saying.size()>11&&saying.substr(saying.size()-10,10)=="is guilty."){
			temname=saying.substr(0,saying.size()-11);
			return 2001;
		}
		if(saying.size()>15&&saying.substr(saying.size()-14,14)=="is not guilty."){
			temname=saying.substr(0,saying.size()-15);
			return 2000;
		}
		return 0;
}
void init(){
	for(int i=1;i<=m;i++){
		mp[name[i]]=-1;
	}
}
bool play(string guil,int week){
	init();
	int negs=0,sum=0;
	for(int i=1;i<=k;i++){
		if(!words[i].saying)continue;
		if(words[i].saying<1000){
			if(words[i].saying!=week){
				if(mp[words[i].name]==0)return 0;
				mp[words[i].name]=1;
			}
			else{
				if(mp[words[i].name]==1)return 0;
				mp[words[i].name]=0;
			}
		}
		else if(words[i].saying<2000){
			if(words[i].saying==1001){
				if(words[i].name==guil){
					if(mp[words[i].name]==1)return 0;
					mp[words[i].name]=0;
				}
				else{
					if(mp[words[i].name]==0)return 0;
					mp[words[i].name]=1;
				}
			}
			else{
				if(words[i].name!=guil){
					if(mp[words[i].name]==1)return 0;
					mp[words[i].name]=0;
				}
				else{
					if(mp[words[i].name]==0)return 0;
					mp[words[i].name]=1;
				}
			}
		}
		else{
			if(words[i].saying==2001){
				if(words[i].gname==guil){
					if(mp[words[i].name]==1)return 0;
					mp[words[i].name]=0;
				}
				else{
					if(mp[words[i].name]==0)return 0;
					mp[words[i].name]=1;
				}
			}
			else{
				if(words[i].gname!=guil){
					if(mp[words[i].name]==1)return 0;
					mp[words[i].name]=0;
				}
				else{
					if(mp[words[i].name]==0)return 0;
					mp[words[i].name]=1;
				}
			}
		}
	}
	for(int i=1;i<=m;i++){
		if(mp[name[i]]==-1)negs++;
		else sum+=mp[name[i]];
	}
	if(n>=sum&&n<=sum+negs)return 1;
	return 0;
}
int main(){
	cin>>m>>n>>k;
	for(int i=1;i<=m;i++){
		cin>>name[i];
	}
	for(int i=1;i<=k;i++){
		string st;
		char sp;
		cin>>st;
		words[i].name=st.substr(0,st.size()-1); //去掉冒号
		sp=getchar();
		getline(cin,st);
		if(st[st.size()-1]<=32)st=st.substr(0,st.size()-1); //<=32：空格或控制字符
		words[i].saying=judge(st);
		words[i].gname=temname;
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=7;j++){
			if(play(name[i],j)){
				if(realguil!="Impossible"){
					cout<<"Cannot Determine";
					return 0;
				}
				realguil=name[i];
				break;
			}
		}
	}
	cout<<realguil;
	return 0;
}

```

---

## 作者：Little_duck_GGG (赞：4)

### 题目意思
共有 $M$ 个人，其中有 $N$ 个人说的是假话，再给出 $P$ 条证言。其中，第一，第二条证词就是说自己是不是罪犯。第三，第四条就是说别人是不是罪犯，第五条则比较特殊，意思是今天是周几。如果证词中出现其他内容，均不用管。
### 题目思路
其实看到这道题时，我也懵，但其实只要仔细分析，并不难。~我甚至不知道我是以什么心态打完的~。

首先，先处理证词。
*   先把证词中无关的话丢弃。
*   接着把有关证词中的人和证词分开，用结构体存储。

做完这些应该不难，这里不过多叙述，给出代码。

```cpp
    getline(cin,q[0]);//注意cin与getline之间要多加一条getline 
	for(int i=1;i<=p;i++)
	{
		getline(cin,q[i]);
		if(q[i][q[i].size()-1]=='\n'||q[i][q[i].size()-1]=='\r'||q[i][q[i].size()-1]==' ')//处理换行，空格的情况。 
		{
			q[i].erase(q[i].size()-1,1);
		}
		string m="",o="";f=0;
		for(int j=0;j<q[i].size();j++)//这里将人与证词分开 
		{
			if(f==1&&q[i][j-1]!=':') o+=q[i][j]; //冒号后的证词 
			if(q[i][j]==':') f=1;
			if(f==0) m+=q[i][j];//如果在冒号前的肯定是人！ 
		}
		a[i].people=m;
		a[i].post=o;
	}
```

接下来，我们暴力枚举当天的日期，犯人。

试试看犯人为 $i$ 的时候所有人的证词是否合法。

我们用一个数组表示名字为 $name$ 的人是否被前面的证词判定为说谎。

如果此时犯人为 $i$ 是不可行的，当且仅当其中某个人的证词出现了矛盾。接下来我们来列举出矛盾的情况。

我们不妨假设当前此人被前面的人判定为说谎。
*   当他说自己是犯人时，如果他确实是犯人，则矛盾，反之，一样。
*   当他说其他人是犯人时，如果那个人确实是犯人，则矛盾，反之，一样。
*   当他说出的日期与枚举的日期相符时，矛盾。

如果它被前面的人判定为诚实，则其操作与以上操作类似，这里不过多叙述。

那第一，第三点都很好实现吧，这里不多说了。我们直接讲第二点。这个有些麻烦，需要指认人的其他人的名字与后半部分分解出来，再进行判断。

```cpp
string fun(string x,string guilty,int as)//as没用别管，x表示证词，guilty表示当前的犯人 
{
	int ty=0;
	string y="",xx="";
	for(int i=0;i<x.size();i++)//分解。这里不多说 
	{
		if(ty==1) y+=x[i];
		if(x[i]==' ') ty=1;
		if(ty==0) xx+=x[i]; 
	}	
	int fo=0;
	for(int i=1;i<=n;i++)
	{
		if(xx==name[i])//找到当前名字是第几个人 
		{
			fo=1;
			break;
		}
	}
	if(fo==0) return "abcd";//如果找不到不管，退出 
	if(y=="is not guilty.")//如果他不是罪犯 
	{
		if(xx==guilty) return "bad";//但当前的罪犯是他，矛盾 
		else return "good";
	}
	else if(y=="is guilty.")//反之，一样的 
	{
		if(xx!=guilty)
		{
			two=1;
			return "bad";
		} 
		else return "good";
	}
	return "abcd";
}
```


那么如何统计有几个人说谎，这里我们可以通过以下操作实现。
对于每一个人，他必须是**没有被任何人判断过是否说谎**的人。
*   如果他说自己是罪犯，但他并不是罪犯，他说谎，反之一样的。
*   如果他说的日期与枚举的日期不符，矛盾，反之亦然。
*   如果他当前说别人是罪犯，但别人不是，说谎，反之亦然。

给出这边判断的代码，有点长。

```cpp
				if(l_or_w[a[k].people]==0)//当他没被任何人判定为诚实或说谎 
				{
					if(a[k].post=="I am guilty.")//如果他说自己是罪犯 
					{
						if(a[k].people==name[j])//如果他确实是，那么他诚实 
						{
							l_or_w[a[k].people]=2;
							good++;
						} 
						else//反之 
						{
							l_or_w[a[k].people]=1;
							bad++;
						} 
	 					continue;	
					} 
					else if(a[k].post=="I am not guilty.")//这里跟上述操作相反，不多说 
					{
						if(a[k].people!=name[j])
						{
							l_or_w[a[k].people]=2;
							good++;
						} 
						else
						{
							l_or_w[a[k].people]=1;
							bad++;
						} 
						continue;
					}
					else
					{
						id=0;
						for(int l=1;l<=7;l++)//判定当前说的是在哪一天 
						{
							if(day[l]==a[k].post)
							{
								id=l;
								break;
							}
						}
						if(id!=0)
						{
							if(id==i)//如果日期相符，诚实 
							{
								l_or_w[a[k].people]=2;
								good++;
							}
							else 
							{
								l_or_w[a[k].people]=1;
								bad++; 
							}
							continue;
						} 
						if(fun(a[k].post,name[j],0)=="good")//判断对其他人说的话是否诚实 
						{
							l_or_w[a[k].people]=2;
							good++;
						}
						if(fun(a[k].post,name[j],0)=="bad")
						{
							l_or_w[a[k].people]=1;
							bad++;
						}
					}
				}
```

那么其实就差不多了，这道题目思路很简单，暴力。但难的是大量枚举且不出错，所以最后打一步，写一点注释。

最后给出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,f,flag,id,bad,asd,good,two;
string name[10005],q[10005],aaa,ans;
string day[8]={"","Today is Monday.","Today is Tuesday.","Today is Wednesday.","Today is Thursday.","Today is Friday.","Today is Saturday.","Today is Sunday."};
struct node
{
	string post,people;
}a[10005];
char gh;
map<string,int> l_or_w;
map<string,int> man;
string fun(string x,string guilty,int as)//as没用别管，x表示证词，guilty表示当前的犯人 
{
	int ty=0;
	string y="",xx="";
	for(int i=0;i<x.size();i++)//分解。这里不多说 
	{
		if(ty==1) y+=x[i];
		if(x[i]==' ') ty=1;
		if(ty==0) xx+=x[i]; 
	}	
	int fo=0;
	for(int i=1;i<=n;i++)
	{
		if(xx==name[i])//找到当前名字是第几个人 
		{
			fo=1;
			break;
		}
	}
	if(fo==0) return "abcd";//如果找不到不管，退出 
	if(y=="is not guilty.")//如果他不是罪犯 
	{
		if(xx==guilty) return "bad";//但当前的罪犯是他，矛盾 
		else return "good";
	}
	else if(y=="is guilty.")//反之，一样的 
	{
		if(xx!=guilty)
		{
			two=1;
			return "bad";
		} 
		else return "good";
	}
	return "abcd";
}
int main()
{
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++) cin>>name[i];
	getline(cin,q[0]);
	for(int i=1;i<=p;i++)
	{
		getline(cin,q[i]);
		if(q[i][q[i].size()-1]=='\n'||q[i][q[i].size()-1]=='\r'||q[i][q[i].size()-1]==' ')
		{
			q[i].erase(q[i].size()-1,1);
		}
		string m="",o="";f=0;
		for(int j=0;j<q[i].size();j++)
		{
			if(f==1&&q[i][j-1]!=':') o+=q[i][j];
			if(q[i][j]==':') f=1;
			if(f==0) m+=q[i][j];
		}
		a[i].people=m;
		a[i].post=o;
	}

	for(int i=7;i>=1;i--)//枚举日期 
	{
		for(int j=1;j<=n;j++)//枚举犯人 
		{
			for(int k=1;k<=n;k++)//清0 
			{
				l_or_w[name[k]]=0;
			}
			bad=good=flag=0;
			for(int k=1;k<=p;k++)
			{
				if(l_or_w[a[k].people]==1)//这里表示他说谎，可以参考下面不说谎的。 
				{
					id=0;
					for(int l=1;l<=7;l++)
					{
						if(a[k].post==day[l])
						{
							id=l;
							break;
						}
					}
					if(id!=0&&id==i)
					{
						flag=1;
						break;
					}
					if(a[k].post=="I am guilty."&&name[j]==a[k].people)
					{
						flag=1;
						break;
					}
					if(a[k].post=="I am not guilty."&&a[k].people!=name[j])
					{
						flag=1;
						break;
					}
					if(fun(a[k].post,name[j],0 )=="good")
					{
						flag=1;
						break;
					} 
					continue;
				}
				if(l_or_w[a[k].people]==2)//当他是诚实的时候 
				{ 
					id=0;
					for(int l=1;l<=7;l++)//判断日期 
					{
						if(a[k].post==day[l])
						{
							id=l;
							break;
						}
					}
					if(id!=0&&id!=i)//这里日期不一样，说明他说谎，但前面的人判定他是诚实的，则矛盾。 
					{
						flag=1;
						break;
					}
					if(a[k].post=="I am guilty."&&name[j]!=a[k].people)//如果他说他自己是罪犯，而他不是，矛盾。 
					{
						two=1;
						flag=1;
						break;
					}
					if(a[k].post=="I am not guilty.")//反之 
					{
						if(a[k].people==name[j])
						{
							flag=1;
							break;
						}
						
					}
					if(fun(a[k].post,name[j],1)=="bad")//如果他说谎，矛盾 
					{
						flag=1;
						break;
					}
					continue; 
				}
				if(l_or_w[a[k].people]==0)//当他没被任何人判定为诚实或说谎 
				{
					if(a[k].post=="I am guilty.")//如果他说自己是罪犯 
					{
						if(a[k].people==name[j])//如果他确实是，那么他诚实 
						{
							l_or_w[a[k].people]=2;
							good++;
						} 
						else//反之 
						{
							l_or_w[a[k].people]=1;
							bad++;
						} 
	 					continue;	
					} 
					else if(a[k].post=="I am not guilty.")//这里跟上述操作相反，不多说 
					{
						if(a[k].people!=name[j])
						{
							l_or_w[a[k].people]=2;
							good++;
						} 
						else
						{
							l_or_w[a[k].people]=1;
							bad++;
						} 
						continue;
					}
					else
					{
						id=0;
						for(int l=1;l<=7;l++)//判定当前说的是在哪一天 
						{
							if(day[l]==a[k].post)
							{
								id=l;
								break;
							}
						}
						if(id!=0)
						{
							if(id==i)//如果日期相符，诚实 
							{
								l_or_w[a[k].people]=2;
								good++;
							}
							else 
							{
								l_or_w[a[k].people]=1;
								bad++; 
							}
							continue;
						} 
						if(fun(a[k].post,name[j],0)=="good")//判断对其他人说的话是否诚实 
						{
							l_or_w[a[k].people]=2;
							good++;
						}
						if(fun(a[k].post,name[j],0)=="bad")
						{
							l_or_w[a[k].people]=1;
							bad++;
						}
					}
				}
			}
			if(flag==1||bad>m||good>n-m) continue;//判定此时是否符合，不矛盾。 
			man[name[j]]=1;
			ans=name[j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(man[name[i]]==1) asd++; 
	}
	if(asd>1) cout<<"Cannot Determine";
	if(asd==1) cout<<ans;
	if(asd==0) cout<<"Impossible\n";
	return 0;
}
```

---

## 作者：Sanust (赞：4)

# P1039 侦探推理
 
### 难点一：证言的读入

我们使用一个 `vector` 数组记录证言，数组下标表示是谁说的句子，内容是一个结构体，其中 `id` 表示该句的主语，`day` 表示是否是说日期的语句，`rev` 表示是不是否定句，其为真则是否定句，为假则是肯定句。

由于证言必定满足“人名: 文字”的形式，故先 `cin` 一次，`pop_back` 掉冒号，记录下来这句话谁说的。接下来再 `cin` 一次，判第一个词是 `I`，`Today` 或其它。考虑第一种，由于有可能一个人本身就叫 `I`，所以读入人名时提前判断一下。

> 具体而言，如果是 `I am` 开头的则为表示说话人自己为主语的句子，如果是 `I is` 开头的则为名字叫 `I` 的人为主语的句子，之后 `getline` 读完句子，判断句子合法性并记录即可。

考虑最后一种，检查这个词是否是一个人名，如果是则与前者同理，如果不是则直接读完并跳过即可。中间那种也一样。

**由于数据有锅，每次 `getline` 的时候都要把尾部的 `\r` 和 `\n` 清除掉，这样才能正常判断。强烈建议读入完输出一下你的证言 `vector` 的内容看看有没有什么问题。**

### 难点二：推理的判断

由于数据量很小且只有一个罪犯，我们可以直接循环枚举所有可能的情况。两层循环，第一层枚举谁是罪犯，第二层枚举今天星期几。接着再枚举每一个人及其证词，判断满不满足条件即可。

对于一个没说过话的人，他既可以说真话也可以说假话，我们单独记录一个值 $none$ 表示没说过话的人的数量。

对于一个说过话的人，我们依据假设的条件判断每句句子的真伪即可，如果这个人说的话全真则此时他说真话，如果全假则此时他说假话，如果有真有假则不合法跳过该种假设条件。对于一个合法的假设，我们记录说假话的人的数量 $cnt$。

接着再判断一次假设关于 $n$ 的合法性，若 $none + cnt < n$ 或 $cnt > n$，即加上所有不说话的人说假话的人数仍到不了总说假话人数 $n$，或不算不说话的人说假话的人数也已经超过总说假话人数 $n$，则这种假设是不合法的。

经过这些判断后，假设的这个人就可能是罪犯了，我们记录下来。如果当前假设的罪犯和之前的罪犯不一致，则输出 `Cannot Determine` 并退出。注意若多种情况都能判断出某一个人是罪犯，则不应该输出 `Cannot Determine`。

把所有的假设都遍历过一遍后，还没有记录过任何答案，则输出 `Impossible`，否则记录的这个人就是罪犯。

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, p, I; // I 是名字为 I 的人的编号
string s;
map<string, int> name; // 把名字、天数与编号进行转化
map<int, string> reday, ren;
struct node // 含义见前文
{
    int id, day;
    bool rev;
};
vector<node> v[25]; // 记录证言
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> m >> n >> p;
    for (int i = 1; i <= m; i++)
    {
        cin >> s, name[s] = i, ren[i] = s;
        if (s == "I")
            I = i; // 特判名字叫 I 的人
    }
    reday[1] = "Monday.", reday[2] = "Tuesday.", reday[3] = "Wednesday.", reday[4] = "Thursday.", reday[5] = "Friday.", reday[6] = "Saturday.", reday[7] = "Sunday.";
    for (int i = 1; i <= p; i++)
    {
        cin >> s;
        s.pop_back(); // 去冒号
        int u = name[s]; // 记录这句证言谁说的
        cin >> s;
        if (s == "I")
        {
            getline(cin, s);
            while (s.back() == '\r' || s.back() == '\n')
                s.pop_back(); // 防数据的锅
            if (s == " am guilty.")
                v[u].push_back({ u, 0, 0 }); // 如果不是日期类，则第二项为 0，否则为日期编号
            if (s == " am not guilty.")
                v[u].push_back({ u, 0, 1 });
            if (I && s == " is guilty.") // 特判名字叫 I 的人
                v[u].push_back({ I, 0, 0 });
            if (I && s == " is not guilty.")
                v[u].push_back({ I, 0, 1 });
        }
        else if (s == "Today")
        {
            getline(cin, s);
            while (s.back() == '\r' || s.back() == '\n')
                s.pop_back();
            for (int j = 1; j <= 7; j++)
                if (s == " is " + reday[j])
                    v[u].push_back({ u, j, 0 });
        }
        else
        {
            int id = 0;
            for (int j = 1; j <= m; j++)
                if (s == ren[j])
                    id = j; // 找主语
            if (!id) // 非法语句读完直接跳
            {
                getline(cin, s);
                continue;
            }
            getline(cin, s);
            while (s.back() == '\r' || s.back() == '\n')
                s.pop_back();
            if (s == " is guilty.")
                v[u].push_back({ id, 0, 0 });
            if (s == " is not guilty.")
                v[u].push_back({ id, 0, 1 });
        }
    }
    s = ""; // 罪犯名字
    for (int i = 1; i <= m; i++) // 假设编号为 i 的人是罪犯
        for (int d = 1; d <= 7; d++) // 假设今天星期 d
        {
            bool flag = false;
            int cnt = 0, none = 0; // 含义见上文
            for (int j = 1; j <= m; j++) // 遍历所有证言
            {
                int tot = 0; // tot 为假证言的数量
                if (v[j].empty()) // 没说过话加 none 并跳过
                {
                    none++;
                    continue;
                }
                for (auto k : v[j])
                    if (k.day && k.day != d) // 证言日期和假设日期不符 
                        tot++;
                    else if (!k.day && k.rev && k.id == i) // 否定句证言罪犯和实际罪犯相符
                        tot++;
                    else if (!k.day && !k.rev && k.id != i) // 肯定句证言罪犯和实际罪犯不符
                        tot++;
                if (tot == v[j].size()) // 证言全假说假话；证言全真说真话
                    cnt++;
                else if (tot != 0) // 其它情况都不合法
                {
                    flag = true;
                    break;
                }
            }
            if (flag || cnt > n || cnt + none < n) // 判定理由见上文
                continue;
            if (s == "") // 记录罪犯名字
                s = ren[i];
            else if (s == ren[i])
                continue;
            else // 有多个罪犯名字
            {
                cout << "Cannot Determine";
                return 0;
            }
        }
    if (s == "") // 遍历完所有情况都没找到
        cout << "Impossible";
    else
        cout << s;
    return 0;
}
```

---

## 作者：uncle_steve (赞：2)

**算法知识点: 枚举，模拟，字符串处理**

**复杂度：$O(m^2p)$**

## 解题思路：

对于比较繁琐的模拟题，写代码的时候建议尽可能模块化。

依次枚举每个同学是否可能是凶手。最终结果有三种：

可能的凶手只有一个，输出凶手名字；

可能的凶手多于一个，输出 "`Cannot Determin`"；

任何一个同学都不可能是凶手，输出 "`Impossible`"；

在枚举每个同学是凶手的过程中，依次枚举今天是星期几，然后判断说谎的同学是否有可能有 $n$ 个。

**这里有两点需要注意：**

1. 每个同学需要始终如一，如果出现某个同学既说真话又说假话，那么当前枚举的情况不合法；

2. 每个句子有三种情况：真话、假话、废话。最终只要 $假话数量  \le n \le  假话数量 + 废话数量$，那么说谎的同学就有可能有 $n$ 个；

## 时间复杂度分析：

我们会依次枚举凶手、星期几以及句子，对于每个句子在判断是谁说的时会再循环一遍所有同学，所以总时间复杂度是 $O(m^2p)$，其中 $m$ 是总人数，$p$ 是总句子数。

## 代码：


```cpp
#include<bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::stringstream;
const int maxn = 25, maxm = 105;
int m, n, p;
string name[maxn];
std::map<string,int> mmp;
std::vector<std::pair<int,int> > proof[maxn];
int fake[maxn];
bool check(int who, int now) {
    memset(fake, -1, sizeof fake);
    for(int i = 1; i <= m; i++) {
        for(auto it: proof[i]) {
            if(it.first == 1) {
                if(who == i) {
                    if(fake[i] == -1) fake[i] = 0;
                    else if(fake[i] == 1) return false;
                } else {
                    if(fake[i] == -1) fake[i] = 1;
                    else if(fake[i] == 0) return false;
                }
            } else if(it.first == 2) {
                if(who != i) {
                    if(fake[i] == -1) fake[i] = 0;
                    else if(fake[i] == 1) return false;
                } else {
                    if(fake[i] == -1) fake[i] = 1;
                    else if(fake[i] == 0) return false;
                }
            } else if(it.first == 3) {
                if(who == it.second) {
                    if(fake[i] == -1) fake[i] = 0;
                    else if(fake[i] == 1) return false;
                } else {
                    if(fake[i] == -1) fake[i] = 1;
                    else if(fake[i] == 0) return false;
                }
            } else if(it.first == 4) {
                if(who != it.second) {
                    if(fake[i] == -1) fake[i] = 0;
                    else if(fake[i] == 1) return false;
                } else {
                    if(fake[i] == -1) fake[i] = 1;
                    else if(fake[i] == 0) return false;
                }
            } else if(it.first == 5) {
                if(it.second == now) {
                    if(fake[i] == -1) fake[i] = 0;
                    else if(fake[i] == 1) return false;
                } else {
                    if(fake[i] == -1) fake[i] = 1;
                    else if(fake[i] == 0) return false;
                }
            }
        }
    }
    int cnt = 0, help = 0;
    for(int i = 1; i <= m; i++) {
        if(fake[i] == 1) cnt++;
        else if(fake[i] == -1) help++;
    }
    //cout << cnt << ' ' << help << endl;
    if(cnt <= n && n <= cnt + help) return true;
    return false;
}
void solve() {
    int cnt = 0, id = -1;
    for(int i = 1; i <= m; i++) {
        bool flag = false;
        for(int j = 0; j >= -6; j--) {
            int temp = check(i, j);
            //printf("(%d %d): %d\n", i, j, temp);
            flag |= temp;
        }
        if(flag) {
            cnt++; id = i;
        }
    }
    if(cnt == 1) {
        cout << name[id] << endl;
    } else if(cnt == 0) {
        cout << "Impossible" << endl;
    } else {
        cout << "Cannot Determine" << endl;
    }
}
void init() {
    cin >> m >> n >> p;
    string temp;
    for(int i = 1; i <= m; i++) {
        cin >> name[i]; mmp[name[i]] = i;
    }
    mmp["Sunday"] = 0;
    mmp["Monday"] = -1; mmp["Tuesday"] = -2;
    mmp["Wednesday"] = -3; mmp["Thursday"] = -4;
    mmp["Friday"] = -5; mmp["Saturday"] = -6;
    getline(cin, temp);
    for(int i = 1; i <= p; i++) {
        getline(cin, temp);
        stringstream ss(temp);
        ss >> temp; temp.pop_back();
        int idx = mmp[temp];
        ss >> temp;
        if(temp == "I") {
            ss >> temp;
            if(temp == "am") {
                ss >> temp;
                if(temp == "guilty.") {
                    if(ss >> temp) continue;
                    proof[idx].push_back(std::make_pair(1, 0));
                } else if(temp == "not") {
                    ss >> temp;
                    if(temp != "guilty.") continue;
                    if(ss >> temp) continue;
                    proof[idx].push_back(std::make_pair(2, 0));
                } else continue;
            } else if(temp == "is") {
                if(!mmp.count("I")) continue;
                int id = mmp["I"];
                ss >> temp;
                if(temp == "guilty.") {
                    if(ss >> temp) continue;
                    proof[idx].push_back(std::make_pair(3, id));
                } else if(temp == "not") {
                    ss >> temp;
                    if(temp != "guilty.") continue;
                    if(ss >> temp) continue;
                    proof[idx].push_back(std::make_pair(4, id));
                } else continue;
            } else continue;
        } else if(temp == "Today") {
            ss >> temp; ss >> temp; temp.pop_back();
            int id = mmp[temp];
            if(ss >> temp) {
                //cout << "GG" << endl;
                continue;
            }
            proof[idx].push_back(std::make_pair(5, id));
            //cout << 5 << ' ' << id << endl;
        } else {
            if(!mmp.count(temp)) continue;
            int id = mmp[temp];
            ss >> temp;
            if(temp != "is") continue;
            ss >> temp;
            if(temp == "guilty.") {
                if(ss >> temp) {
                    //cout << "GG" << endl;
                    continue;
                }
                proof[idx].push_back(std::make_pair(3, id));
                //cout << 3 << ' ' << id << endl;
            } else if(temp == "not") {
                ss >> temp;
                if(ss >> temp) {
                    //cout << "GG" << endl;
                    continue;
                }
                proof[idx].push_back(std::make_pair(4, id));
                //cout << 4 << ' ' << id << endl;
            }
        }
    }
}
int main() {
    init();
    solve();
    return 0;
}
```

---


# [NOIP 2005 提高组] 篝火晚会

## 题目描述

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。


佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？


## 说明/提示

- 对于 $30\%$ 的数据，满足 $n \le 1000$；
- 对于 $100\%$ 的数据，满足 $3\le n  \le  50000$。

**【题目来源】**

NOIP 2005 提高组第三题

## 样例 #1

### 输入

```
4
3 4
4 3
1 2
1 2
```

### 输出

```
2```

# 题解

## 作者：Actinoi (赞：48)

## NOIP2005 提高组——篝火晚会

​																																										$by - Actinoi $	

$2019/6/22$

为获取最佳阅读效果，建议访问https://www.actinoi.com/2019/06/22/NOIP2005提高组——篝火晚会/			   	 															

​	本题有一个坑，那就是移动的人不需要连续。然后。。。知道这个坑点之后，我们很容易想到最优解，那就是化环为链，构建目标链与初始链，然后找到目标链与初始链中不一样的人的总数，用总人数 $-$ 相同的人数就是需要调换的人数。至于为什么能够在 $O(N)$ 内完成操作，下图可以做一个更加直观的说明。

![1.jpg](https://i.loli.net/2019/06/22/5d0e0754e17fb49023.png)

> 例如，初始环是左边的这个环，目标环是右边的环，如箭头所示的路径，我们可以通过 $（2,5,6）$ 的指令 $O(N)$ 完成变换。

&nbsp;&nbsp;&nbsp;&nbsp;但是，环是可以旋转的，因此我们并不知道怎样转动是最优的。我们便可以考虑以每个点为起点进行搜索，因此，一个~~绝佳的~~ $O(N^2)$ 的算法便出炉啦！

&nbsp;&nbsp;&nbsp;&nbsp;无疑，这个算法会让我们看到一片 $TLE$ 。所以，我们便可以考虑优化这个算法。

 	
&nbsp;&nbsp;&nbsp;&nbsp;如上图，我们从 $1$ 开始构建一条初始链，再构建一条目标链。

#### 初始链： $1,  2,  3,  4,  5,  6$

#### 目标链： $1, 6, 3, 4, 2, 5$

我们将两条链对应的数相减，取绝对值，便可以得到：

#### 差值：$0, 4, 0, 0, 3, 1 $

​&nbsp;&nbsp;&nbsp;&nbsp;在这条差值中， $0$ 出现的次数的是最多的。那么，若果有一条差值 $1$ 出现的次数是最多的，那么，这意味着什么？无疑，将那条链转动 $1$ 个单位，我们便可以得到最优解了！而在程序中，我们并不需要真正转动，只需要统计出现次数最多的差值 $c$，这就代表初始环在转动 $c$ 个单位之后，在同一个位置上的人数与目标环重合的最多，然后用总人数 $n$ 减去差值 $c$ 出现总次数，便是我们需要调换的人的数w量，也就是我们想要的答案 $m$ 啦！

### 等等！

​&nbsp;&nbsp;&nbsp;&nbsp;这既然是一个环，那么，会不会构建目标链得到的结果不一样呢？的确是这样滴。还是以上图为例，从 $1$ 开始我们可以得到 $1, 6, 3, 4, 2, 5$ 与 $1, 5, 2, 4, 3, 6$ 两条链。那这怎么办呢？既然我们不确定我们拥有的目标链是顺时针构建的还是逆时针构建的，我们便可以在计算差值时顺时针与逆时针各跑一边，然后取最大值。我们用 $target$ 数组存储目标链，用 $ initial $ 数组存储初始链，便可以用 $(target[i] - initial[i] + n) % n$ 顺时针从 $1 ～ n$ 跑一遍，再用 $(target[i]- initial[n - initial[i] + 1] + n) % n$ 逆时针从 $n ～ 1$ 跑一遍差值，然后找出最大的差值。

​&nbsp;&nbsp;&nbsp;&nbsp;那么，什么时候不能符合每个同学的愿望呢？其实，只要构出目标环，便一定可以~~用玄学的方法~~使每个同学满意。那么，只有在构不成目标环的时候才输出 $-1$ 。那什么时候构不成目标环呢？无疑，第 $i$ 个同学想挨着的那个人不想挨着他~~（好一个悲伤的故事）~~的时候才构不成环，此时输出 $-1$。所以，我们直接判断第 $i$ 个同学左右两边是否还有空座就可以，如果没有的话，那就。。。输出 $-1$ 了。

最后附上代码：

```cpp
#include <iostream>
using namespace std;
int target[50001], initial[50001], people[50001][3], pluss[50001], minuss[50001]; //存储目标链，初始链，每个人最希望相邻的两个同学的编号，正序相同人数以及逆序相同人数
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch=='-')
            w=-1;
    ch=getchar();
    }
    while(ch >= '0' && ch <= '9')
        s = s * 10 + ch - '0', ch = getchar();
    return s * w;
}
int main() {
    int n;
    n = read();
    for (int i = 1; i <= n; i++) //读入编号是 i 的同学最希望相邻的两个同学的编号
        people[i][1] =read(), people[i][2] = read();
    target[1] = 1;
    target[2] = people[1][2]; //构建目标链
    initial[1] = 1;
    initial[n] = n; //构建初始链
    for (int i = 2; i <= n - 1; i++) {
        initial[i] = i; //构建初始链
        if (target[i - 1] == people[target[i]][1])
            target[i + 1] = people[target[i]][2];
        else if (target[i - 1] == people[target[i]][2])
            target[i + 1] = people[target[i]][1]; //构建目标链
        else{
            cout << -1 << endl; //第 i 个人希望相邻的人旁边没有空位了，无法构建目标链（一个悲伤的故事）
            return 0;
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        pluss[(target[i] - initial[i] + n) % n]++; //顺时针从 1 ~ n 跑一遍
        minuss[(target[i]- initial[n - initial[i] + 1] + n) % n]++; //逆时针从 n ~ 1 跑一遍差
    }
    for (int i = 0; i <= n - 1; i++)
        ans = max(ans, max(pluss[i], minuss[i])); //找差值人数最多的
    cout << n - ans; //总人数 - 不用移动的人数 = 需要移动的人数，也就是答案
    return 0;
}
```



---

## 作者：Drinkkk (赞：10)

- ### NOIP2005提高组第 3 题

**题面**

https://www.luogu.org/problemnew/show/P1053 。

**题目描述**

佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$ 。一开始，同学们按照 $1,2,…,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。

佳佳可向同学们下达命令，每一个命令的形式如下：

$$(b_1, b_2,... b_{m-1}, b_m)$$

这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,…, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上， $b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$ 。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？

**输入输出格式**

- 输入格式

第一行是一个整数 $n\;(3 \leq n \leq 50000)$ ，表示一共有 $n$ 个同学。

其后 $n$ 行每行包括 $2$ 个不同的正整数，以一个空格隔开，分别表示编号是 $1$ 的同学最希望相邻的两个同学的编号，编号是 $2$ 的同学最希望相邻的两个同学的编号，……，编号是 $n$ 的同学最希望相邻的两个同学的编号。

- 输出格式
一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出 ``-1``。

**输入输出样例**

- 输入样例#1
```
4
3 4
4 3
1 2
1 2
```
- 输出样例#1
```
2
```

**数据范围**

对于 $30\%$ 的数据，$n \leq 1000$ ；

对于全部的数据，$n \leq 50000$ 。

## 题解

首先我们可以通过给出来的相邻关系把这个环给建出来。

怎么建呢？首先先设 $a_i$ 表示这个环中的第 $i$ 个人的原来的编号（$1$~$n$）， $l_i$ 和 $r_i$ 分别是这个人想要的与之相邻的两个人的编号。那么我们就可以先让 $a_n=l_1,a_1=1,a_2=r_1$。因为这个环是可旋转的qwq。

然后如果 $a_{i-2}$ 是 $a_{i-1}$ 期望的左边，那么 $a_i$ 就应是 $a_{i-1}$ 所期望的右边，所以 $a_i=r_{a_{i-1}}$。

反之，如果 $a_{i-2}$ 是 $a_{i-1}$ 期望的右边，那么 $a_i$ 就应是 $a_{i-1}$ 所期望的左边，所以 $a_i=l_{a_{i-1}}$。

如果都不满足的话说明这样的环不存在，输出 $-1$ 。

这一部分的代码是这样的：
```
a[n]=l[1],a[1]=1,a[2]=r[1];
for(int i=3;i<=n-1;i++)
{
	if(a[i-2]==l[a[i-1]])
	{
		a[i]=r[a[i-1]];
	}
	else if(a[i-2]==r[a[i-1]])
	{
		a[i]=l[a[i-1]];
	}
	else
	{
		printf("-1");
		return 0;
	}
}
```

然后就是求答案辣！

我们用 $dis1_i$ 表示从原位置走到目标位置顺时针要走 $i$ 步的人有多少个。

并且用 $dis2_i$ 表示从原位置走到目标位置逆时针要走 $i$ 步的人有多少个。

易得，对于一个人 $i$，他会对 $dis1_{(i-a_i+n)\;mod\;n}$ 以及 $dis2_{(i+a_i+n)\;mod\;n}$ 均产生 $1$ 的贡献。然后我们就可以把它们统计出来了。

下面是这一部分的代码。

```
for(int i=1;i<=n;i++)
{
	dis1[(i-a[i]+n)%n]++;
	dis2[(i+a[i]+n)%n]++;
}
```

因为若有 $k$ 个人不在目标位置上，则需要 $k$ 的代价。所以有

$$ans=n-\max_{i=0}^{2n} max(dis1_i,dis2_i)$$

求一下就可以了。

完整代码：
```
#include <cstdio>
int l[1000001],r[1000001];
int a[1000001],cx[1000001];
int dis1[1000001],dis2[1000001];
int max(int x,int y)
{
	return x>y?x:y;
}
int main()
{
	int n=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d %d",&l[i],&r[i]);
	}
	a[n]=l[1],a[1]=1,a[2]=r[1];
	for(int i=3;i<=n-1;i++)
	{
		if(a[i-2]==l[a[i-1]])
		{
			a[i]=r[a[i-1]];
		}
		else if(a[i-2]==r[a[i-1]])
		{
			a[i]=l[a[i-1]];
		}
		else
		{
			printf("-1");
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		dis1[(i-a[i]+n)%n]++;
		dis2[(a[i]+i+n)%n]++;
	}
	int ans=0;
	for(int i=0;i<=n*2;i++)
	{
		ans=max(ans,max(dis1[i],dis2[i]));
	}
	printf("%d",n-ans);
	return 0;
}
```

---

## 作者：EdenSurvivor (赞：4)

## 题目大意：

$n$ 个人按照 $1$ 到 $n$ 的顺序围成了一个环，你可以不断进行操作，每条操作表示为 $(b_1,b_2,\cdots,b_{m-1},b_m)$，意思是将 $b_1$ 换到 $b_2$ 的位置上，将 $b_2$ 换到 $b_3$ 的位置上 $\cdots$ 将 $b_m$ 换到 $b_1$ 的位置上，代价为 $m$，求出这个环变成一个给定的环需要多少代价，其中 $n\leq100000$。

## 解题：

首先要知道一个性质，就是对于一个字符串，最少的交换次数就是对应位不同的个数，因为 $(b_1.b_2,\cdots,b_{m-1},b_m)$ 不要求连续，所以可以用贪心。

我们只需要把目标串弄出来，然后从每一位开始转一圈的都统计一遍对应不同的有几个就行，是不是很棒棒！！！

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 50005;
int x[N], y[N], a[N], fa[N], n, ans = (1<<30);
int main () {
    ios::sync_with_stdio (false), cin.tie (0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    for (int i = 1; i <= n; i++) {
        if (x[x[i]] != i && y[x[i]] != i || x[y[i]] != i && y[y[i]] != i) {
            cout << "-1";
            return 0;
        }
    }
    a[1] = 1, a[2] = x[1];
    for (int i = 2; i < n; i++) {
        if (a[i - 1] == x[a[i]]) a[i + 1] = y[a[i]];
        else if (a[i - 1] == y[a[i]]) a[i + 1] = x[a[i]];
    }
    for (int i = 1; i <= n; i++) fa[(i - a[i] + n) % n]++;
    for (int i = 0; i < n; i++) ans = min (ans, n - fa[i]);
    for (int i = 0; i < n; i++) fa[i] = a[i + 1] = 0;
    a[1] = 1, a[2] = y[1];
    for (int i = 2; i < n; i++) {
        if (a[i - 1] == x[a[i]]) a[i + 1] = y[a[i]];
        else if (a[i - 1] == y[a[i]]) a[i + 1] = x[a[i]];
    }
    for (int i = n; i >=1; i--) fa[(i - a[i] + n) % n]++;
    for (int i = 0; i < n; i++) ans = min (ans, n - fa[i]);
    cout << ans << '\n';
    return 0;
}
```

不要抄代码哦。

---

## 作者：bjzjh (赞：3)

# P1053 [NOIP 2005 提高组] 篝火晚会题解
## 题目重述  
[在博客中食用效果更佳](https://www.luogu.com.cn/article/qpvc2w1f)  
[题目传送门](https://www.luogu.com.cn/problem/P1053)  
给定一个数 $n$，有一个序列 $1,2,3,...,n-1,n$，现要进行若干次操作，使得该序列满足 $i$ 左右旁边分别是 $l_i$ 和 $r_i$,每个操作的形式如下：  
$$ b_1,b_2,b_3,...b_m-1,b_m$$  
其中，$m$ 的值由你决定，$b$ 如同，该操作能使 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，$b_m$ 换到 $b_1$ 的位置上。  
该操作要花费 $m$ 的代价，你要使总代价最小，若无解输出 `-1`。
## 题解
### 第一步：求目标数列
该步骤可以通过给出的相邻关系求解。   
首先就是设第一个为 $1$ ，然后设置第二个为第一个的左边，最后一个设置为第一个的右边，写成代码就是：  
$$a_1=1,a_2=r_1,a_n=l_1$$  
第一位，第二位，最后一位,已经求出来了，接下来就是 $3 \rightarrow n-1$ 为了，考虑以下情况： 

+ $a_{i-2}=l_{a_{i-1}}$
> $a_i=r_{a_{i-1}}$
+ $a_{i-2}=r_{a_{i-1}}$
> $a_i=l_{a_{i-1}}$

+ 如果以上情况都不是则输出 `-1`。

### 第二步：求解
我们考虑用 $shun_i$ 表示从原位置走到目标位置顺时针要走 $i$ 步的人有多少个。  
再用 $ni_i$ 表示从原位置走到目标位置逆时针要走 $i$ 步的人有多少个。  
我们通过一些些的~~玛卡巴卡~~推理可以得出：一个人对 $shun_{(i-a_i+n) \bmod n}$ 和 $ni_{(i+a[i]+n) \bmod n}$ 做出了一点贡献，有了这些，我们就可以把 $shun$ 和 $ni$ 都求出来了。  
$shun$ 和 $ni$ 都求出来了，我们怎么求解呢？我们考虑到若有 $k$ 个人不对应目标链的话，我们就需要 $k$ 的代价去修改他们，所以我们可以得出：  
$$ans=n-\max_{i=0}^{n}{\max(shun_i,ni_i)}$$  
我们只要求出来就可以了。
### 代码
~~你们最喜欢的代码来了~~  

```cpp
#include<bits/stdc++.h>
#defing 点个赞吧 cout<<n-maxn;
using namespace std;
int n,l[51000],r[51000],a[51000],shun[51000],ni[51000],maxn;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>l[i]>>r[i];
	}
	a[1]=1;
	a[2]=r[1];
	a[n]=l[1];
	for(int i=3;i<=n;i++){
		if(l[a[i-1]]==a[i-2]){
			a[i]=r[a[i-1]];
			continue;
		}
		if(r[a[i-1]]==a[i-2]){
			a[i]=l[a[i-1]];
			continue;
		}
		puts("-1");
		return 0;
	}
	for(int i=1;i<=n;i++){
		shun[(i-a[i]+n)%n]++;
		ni[(i+a[i]+n)%n]++; 
	}
	for(int i=0;i<=n;i++){
		maxn=max(maxn,max(shun[i],ni[i]));
	}
	点个赞吧
    return -1;
}
```
~~完结撒花~~

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18879339)

挺不错的思维题。

考虑如何表示所有人的愿望，显然可以把“相邻”的条件**转化为图论**角度考虑，如果两人相邻则在他们之间连边。那么这张图合法当且仅当**所有人都在一个连通块中**，且这张图是一个**环**。

继续考虑有没有可能出现无法进行操作使局面变成这个环的情况。发现这是不可能的，因为如果每次都进行 $k=2$ 的操作，就一定可以使当前局面变成任意的局面。

首先对于判定环相同的条件有点难做，于是先**断环为链**，枚举链的位置，则原序列与链匹配上了即为环相等。注意环可以**正着也可以反着**，因此要做两遍。

那么怎样的操作才是最优的呢？注意到**链确定后每个人要去的位置也随之固定了**，并且操作支持将任意位置的人循环移位，于是就形成了一个**置换环**。每个置换环内进行一次移动，置换环上的所有人便和链匹配上了。

因此一个链的最小操作代价就是 $n-x$，其中 $x$ 表示不在任何一个置换环中的人的个数，即 $pos=i$ 的个数。

当前的算法是 $O(n^2)$ 的，考虑如何优化到线性。发现一个位置的人不在置换环中，只发生在 $pos=i$ 的情况，因此对应的链也是唯一的。所以可以不去枚举链，而是**让每个人反过来贡献链**。于是每种链的代价即可算出来，取最小值即可。

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=100005;
int f[N],n,x[N],y[N],a[N],v[N],cnt=0,ans=0x3f3f3f3f;
bitset<N>vis;
void init()
{
    for(int i=1;i<=n;i++)
        f[i]=i;
}
int findf(int x)
{
    if(f[x]!=x)f[x]=findf(f[x]);
    return f[x];
}
void combine(int x,int y)
{
    int fx=findf(x),fy=findf(y);
    f[fx]=fy;
}
void dfs(int u)
{
    a[++cnt]=u;
    vis[u]=1;
    if(vis[x[u]]==0)
        dfs(x[u]);
    else if(vis[y[u]]==0)
        dfs(y[u]);
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    init();
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
        combine(i,x[i]);
        combine(i,y[i]);
    }
    int tot=0;
    for(int i=1;i<=n;i++)
        tot+=(findf(i)==i)+(x[x[i]]!=i&&y[x[i]]!=i)+(x[y[i]]!=i&&y[y[i]]!=i);
    if(tot>1)
    {
        cout<<-1;
        return 0;
    }
    dfs(1);
    fill(v,v+n+1,n);
    for(int i=1;i<=n;i++)
        v[(i-a[i]+n)%n]--;
    for(int i=0;i<=n;i++)
        ans=min(ans,v[i]);
    reverse(a+1,a+n+1);
    fill(v,v+n+1,n);
    for(int i=1;i<=n;i++)
        v[(i-a[i]+n)%n]--;
    for(int i=0;i<=n;i++)
        ans=min(ans,v[i]);    
    cout<<ans;
    return 0;
}
```

---

## 作者：LastKismet (赞：1)

# [NOIP 2005 提高组] 篝火晚会

## 一个性质

你会发现，如果存在合法最终状态的话，那么这个最终状态是唯一的。（不考虑顺时针与逆时针的差异）原因很简单，每个节点两侧的节点是固定的。

所以考虑构造最终序列。直接深搜即可。

当不存在合法序列，当且仅当一个节点想相邻的节点不想与它相邻。深搜的时候和上一个节点判断一下即可。

为了方便，我们考虑直接储存这个最终环中，任意一个起点向任意一个方向开始遍历整个环形成的链。

## 另一个性质

考虑题目中的操作，你发现并不要求 $b$ 相邻连续。然后就很傻。

你可以对任何当前需要换的节点集合构造出一次操作使得它们全部归位。每个节点在操作序列中的下一个节点，就是它本来应该在的位置当前的节点，显然最后一个节点应该在第一个节点当前的位置上。这样构造出来的操作一次就可以让序列复原，并显然最优。

所以问题就变成了，已知初始序列（就是 $1$ 到 $n$ 的顺序排列），和最终序列，任意翻转或旋转最终序列，最大化与初始序列相等的元素数。最后的答案就是与最终序列不相等的位置数的最小值。

## 最后的细节

如果你枚举所有起点与方向的话，复杂度是 $O(n^2)$ 的。

首先我们暂时忽略翻转操作（就是顺时针与逆时针两种情况），只考虑旋转起点。

你发现，由于每个节点应该在的位置唯一，所以要想他“和最初序列匹配上”所需要的旋转次数也是唯一的。（只考虑顺时针旋转，也就是非负。显然右移 $n-1$ 次等价于左移 $1$ 次。）

我们记录当前起点下每个节点要想匹配需要的旋转次数，就可以选择一个匹配上节点最多的旋转次数，得到答案。

这里我们假设我们构造出的最终序列为 $a$。从 $1$ 开始编号。

具体的，$a_i$ 节点当前的位置是 $i$，本来应该在 $a_i$，它要想匹配上需要旋转 $(a_i-i+n)\bmod n$ 次。

然后考虑翻转一次序列，这时 $a_i$ 节点当前的位置在 $n-i+1$，所以就需要旋转 $[a_i-(n-i+1)+n]\bmod n$ 次。显然翻转多于一次没有意义。

分别记录翻转和不翻转的答案取最优值即可。

## 主要代码

```cpp
#define chmax(a,b) a=max(a,b)
#define chmin(a,b) a=min(a,b)
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define per(i,x,y) for(int i=(x);i>=(y);i--)
#define repl(i,x,y) for(int i=(x);i<(y);i++)

const int N=5e4+5;

int n;
int l[N],r[N];
int a[N];
int num[N];

int cnt;
int be;
void dfs(int now,int fid){
    if(fid){
        if(l[now]!=fid&&r[now]!=fid)cout<<-1,exit(0);
        if(r[now]==fid)swap(l[now],r[now]);
    }
    a[++cnt]=now;
    if(!be)be=now;
    else if(now==be)return;
    dfs(r[now],now);
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
    rep(i,1,n)cin>>l[i]>>r[i];
    dfs(1,0);
    rep(i,1,n)num[(a[i]-i+n)%n]++;
    int chs=0;
    repl(i,0,n)if(num[i]>num[chs])chs=i;
    int ans=num[chs];
    repl(i,0,n)num[i]=0;
    rep(i,1,n)num[(a[i]-(n-i+1)+n)%n]++;
    repl(i,0,n)if(num[i]>num[chs])chs=i;
    chmax(ans,num[chs]);
    cout<<n-ans;
    return 0;
}
```

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P1053)
# 题意
现有 $n$ 个人，编号为 $1$ 到 $n$。一开始，他们按 $1,2,\cdots,n$ 的顺序排成一圈。然而，每个人都有其最希望相邻的两个人。

我们可以执行以下操作若干次，使得最后排列的顺序能满足每个人的要求：

- 给定一个序列 $(b_1,b_2,\cdots,b_{m-1},b_m)$，并让 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……$b_{m-1}$ 换到 $b_m$ 的位置上，$b_m$ 换到 $b_1$ 的位置上。这一操作的代价为 $m$，并且每次操作的 $m$ 可以不相等。

**注意：移动的人不一定要连续。**

若能通过若干次操作，使得最后的顺序能满足每个人的要求，则输出最小总代价；否则输出 $-1$。
# 思路
首先，根据每个人的希望，我们可以先尝试构造出一条目标链，如果构造不出来，则可以直接输出 $-1$。

然后，我们将目标链与初始链对应的数作差（模 $n$ 的意义下），那些结果为 $0$ 的人的位置是不用变的，而剩下的人都需要调整。

接着我们便可以惊奇的发现，若需要调整的人数为 $m$，则我们只需要 $1$ 次代价为 $m$ 的操作即可将他们调整好 ~~（至于为什么则留给读者思考）~~。

当然由于环是可以旋转的，所以实际上我们不需要调整的人不一定就是作差后结果为 $0$ 的人。那么，选择哪些人可以使我们操作的总代价最小呢？

为了使调整的人数最少，我们无需调整的人数就要最多。而实际上，只要我们采取合适的旋转方式，任何一个人都可以由需要调整，变为不需要调整。因此，我们只需统计在作差得到的结果中出现次数最多的数（即众数）出现了几次，而这就是无需调整的人数。

最后，由于最初的顺序是顺时针还是逆时针不确定，所以我们需要二者都跑一遍，最后得出结果。

例如，对于样例，模拟结果如下：

- 构造目标链：$1,4,2,3$。
- 构造初始链：$1,2,3,4$。
- 顺时针统计：$0,2,3,3$。
- 逆时针统计：$1,1,0,2$。
- 无需调整的人数：$2$。
- 最终结果：$4-2=2$。

因此输出结果为：
```cpp
2
```
# 程序
```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
using namespace std;
long long T=1,mod;
#define ll long long
#define ull unsigned long long
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define MAX int(50000)
//#define DEBUG
//#define use_cin
//#define more_text

int n,                       //人数 
	expect_person[MAX+1][2]; //每个人希望相邻的两个人 

int target_list[MAX+1],      //目标链 
	initial_list[MAX+1],     //初始链 
	plus_order[MAX+1],       //顺时针，统计作差结果出现的次数 
	minus_order[MAX+1],      //逆时针，统计作差结果出现的次数 
	ans;                     //记录无需调整的人数的最大值 

void solve(int step){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d%d",&expect_person[i][0],&expect_person[i][1]);//输入 
	
	target_list[1]=1;
	target_list[2]=expect_person[1][1];
	for(int i=2;i<=n-1;++i){
		if(target_list[i-1]==expect_person[target_list[i]][0])
			target_list[i+1]=expect_person[target_list[i]][1];
		else if(target_list[i-1]==expect_person[target_list[i]][1])
			target_list[i+1]=expect_person[target_list[i]][0];
		else{
			printf("-1"); //无法满足要求 
			return;
		}
	} //构造目标链 
	
	for(int i=1;i<=n;++i)initial_list[i]=i; //构造初始链 
	
	for(int i=1;i<=n;++i)
		++plus_order[(target_list[i]-initial_list[i]+n)%n],      //顺时针统计
		++minus_order[(target_list[i]-initial_list[n-i+1]+n)%n]; //逆时针统计
	
	for(int i=0;i<n;++i)
		ans=max(ans,max(plus_order[i],minus_order[i])); //统计答案 
	
	printf("%d",n-ans); //输出 
}
int main(){//模板，不用在意
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	#ifdef use_cin
	cin>>T;
	#else
	scanf("%lld",&T);
	#endif
	#endif
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
/*
Input:

Output:

Outline:

*/
```

---

## 作者：cwxcplh (赞：1)

这是一道很有趣的题。

先开始看到这道题是用模拟，还有点惊讶，后来看了一下题解才恍然大悟，我主要是对题解的进一步解释和说明。

首先我们要求最小代价 ~~（一般看到这种题都很难）~~，直接想肯定想不出来，我们倒着想。

我们先不看最小，就求如何把一个环变成另一个环。因为环不方便接，所以我们首先会断环成链，把一个环变成一个链式数组，举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/82ate6gt.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

这个图中很明显把 $2$ 跟 $5$ 交换、$3$ 跟 $4$ 交换，只需要四步就行，我们来断环成链：

**初始链：**`1 2 3 4 5 6`。

**目标链：**`1 5 4 3 2 6`。

很明显，我们只需要找出有多少个点不动，剩下的全都要动，所以剩下的点都可以算作一个代价。

但有一个问题：环是可以旋转的，不一定初始链和目标链的 $1$ 就要在同一个位置，这也很简单，我们只需要枚举每个点跟 $1$ 对应就行了，这样我们就找到了一个~~极好的~~ $O(n^2)$ 的做法。

那么增么优化成 $O(n)$ 的呢？很简单，我们这么想：只要环往后旋转一格，那那些差值为 $1$ 的格之间就没有差值了，因为初始链是有序的，所以往后转一格相当于给每个数所对应的数加一。所以我们只需要一作差，然后求出差当中出现数量做多的那个数的次数，总数减去这个数就是答案了。

但还有个问题：环是没有方向的，怎么判断顺时针还是逆时针呢？很简单，正反都跑一遍不就对了。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201885638)

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,a[50006][6],cs[50006],mb[50006],mp1[50006],mp2[50006];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i][1]>>a[i][2];
		cs[i]=i;
	}
	mb[1]=1,mb[2]=a[1][2],mb[n]=a[1][1];
	for(int i=2;i<n;i++)
	{
		if(mb[i-1]==a[mb[i]][1])
		{
			mb[i+1]=a[mb[i]][2];
		}
		else if(mb[i-1]==a[mb[i]][2])
		{
			mb[i+1]=a[mb[i]][1];
		}
		else
		{
			cout<<-1;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		mp1[(mb[i]-cs[i]+n)%n]++;
		mp2[(mb[i]-cs[n-i+1]+n)%n]++;
	}
	for(int i=0;i<n;i++)
	{
		ans=max(ans,max(mp1[i],mp2[i]));
	}
	cout<<n-ans;
	return 0;
}
```

---

## 作者：chenruikai (赞：0)

### 题意
显然，由于换的位置可以不连续，每次代价就是换的人数，就是让你求一个  $1,2,⋯,n$ 的环和目标环的数值不同的位置最少数量。
### 解
#### 目标环
显然，从一个人沿着想相邻的同学一直走就行了。但如果遇到他想和她相邻但她不想和他相邻的情况（即她想相邻的人里没他），那该情况无解，因为一个人旁边只有两人。

#### 不同位置数目
手搓两个环，假定环不能旋转，偏移量为该同学顺时针到目标位置经过的同学数。这个显然很好求。通过偏移量，我们可以知道，假如目标环逆时针转偏移量个单位，该同学就可以与他目标位置对上号，该同学不用移动。

到这里，答案显然，把每一个偏移量都求出后，答案为总人数减众数的数量。

检查是否包含了所有情况。我们发现，当构造目标环换一个方向（顺逆）时，该情况为包括。解决方案就是反一下。

### CODE
```cpp
/*
build aim;
compute pos_beta1 => ans1;
reverse aim;
compute pos_beta2 => ans2;
ans = min(ans1 , ans2);
*/
#include <bits/stdc++.h>
using namespace std;

int qread()
{
    int res = 0;char ch = getchar();
    for(;ch < '0' || ch > '9';ch = getchar());
    for(;ch >= '0' && ch <= '9';ch = getchar())
        res = (res << 1) + (res << 3) + ch - '0';
    return res;
}
#define maxn 50004
struct cell{int con1 , con2;bool vis;};
cell point[maxn];
int pointnum , num1 , num2;
int aim[maxn] , aimpos[maxn];
int cbeta[maxn] , cou[maxn << 1];
int ans1 , ans2 , maxpos;
int main()
{
    pointnum = qread();
    for(int i = 0;i < pointnum;i++)
    {
        point[i].con1 = qread() - 1;
        point[i].con2 = qread() - 1;
    }
    //compute aim
    aim[0] = 0;
    for(int i = 1 , pos = point[0].con1;i < pointnum;i++)
    {
        aim[i] = pos;
        if(point[pos].con1 != aim[i - 1] && point[pos].con2 != aim[i - 1])
            {puts("-1");return 0;}
        pos = point[pos].con1 + point[pos].con2 - aim[i - 1];
    }
    for(int i = 0;i < pointnum;i++)aimpos[aim[i]] = i;
    //compute cbeta
    memset(cou , 0 , sizeof(int) * (maxn << 1));
    for(int i = 0;i < pointnum;i++)
    {
        if(aimpos[i] >= i)cou[aimpos[i] - i]++;
        else cou[aimpos[i] + pointnum - i]++;
    }
    maxpos = 0;
    for(int i = 1;i < (maxn << 1);i++)
        if(cou[maxpos] < cou[i])maxpos = i;
    ans1 = pointnum - cou[maxpos];
    for(int i = 0;i < pointnum;i++)aimpos[i] = pointnum - aimpos[i] - 1;
    memset(cou , 0 , sizeof(int) * (maxn << 1));
    for(int i = 0;i < pointnum;i++)
    {
        if(aimpos[i] >= i)cou[aimpos[i] - i]++;
        else cou[aimpos[i] + pointnum - i]++;
    }
    maxpos = 0;
    for(int i = 1;i < (maxn << 1);i++)
        if(cou[maxpos] < cou[i])maxpos = i;
    ans2 = pointnum - cou[maxpos];
    printf("%d\n" , min(ans1 , ans2));
    return 0;
}
```
### Fun fact
有一次写的时候写错了，写成这样。
```cpp
 //compute cbeta
    memset(cou , 0 , sizeof(int) * (maxn << 1));
    maxpos = 0;
    for(int i = 0;i < pointnum;i++)
    {
        if(aimpos[i] >= i)cou[aimpos[i] - i]++;
        else cou[aimpos[i] + pointnum - i]++;
        if(cou[maxpos] < cou[i])maxpos = i;
    }
    ans1 = pointnum - cou[maxpos];
    for(int i = 0;i < pointnum;i++)aimpos[i] = pointnum - aimpos[i] - 1;
    memset(cou , 0 , sizeof(int) * (maxn << 1));
    maxpos = 0;
    for(int i = 0;i < pointnum;i++)
    {
        if(aimpos[i] >= i)cou[aimpos[i] - i]++;
        else cou[aimpos[i] + pointnum - i]++;
        if(cou[maxpos] < cou[i])maxpos = i;
    }
    ans2 = pointnum - cou[maxpos];
```
这样有 $80$。数据有点水……

玥玥月月如今朝。

---

## 作者：我梦见一片焦土 (赞：0)

我们可以发现，由初始序列我们可以得到 $2\times n$ 个目标序列，将目标序列与初始序列做差，如果差相同则不用移动，所以我们只要枚举出最大的相同数，那么 $ans$ 就是 $ans-max$，但这样会超时。

只要求出目标环各元素值与初始环对应位置的元素值之差的结果相同的最多是多少个就可以了。

为使差值为正数，可用 ```(a[i]-b[i]+n)%n``` 来求差值（```b[i]``` 表示初始序列，实际就是 $1,2,3,4,5\dots n$）。

同时注意因为是一个环，那么与方向无关，所以顺时针，逆时针我们都用上述方法求解一次。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
struct node{
	int y,next;
}sa[N*2];
int len,first[N],n,sd[N],flag,yu[N],ans,now=1,f;
void ins(int x,int y){
	for(int i=first[x];i!=-1;i=sa[i].next){
        if(y==sa[i].y){
            return;
        }
    }
	len++;
	sa[len].y=y;
	sa[len].next=first[x];
	first[x]=len;
}
signed main(){
	cin>>n;
	memset(first,-1,sizeof first);
	for(int i=1,l,r;i<=n;i++){
		cin>>l>>r;
		ins(i,l);
        ins(l,i);
		ins(i,r);
        ins(r,i);
	}
	for(int num=0,x=1;x<=n;x++,num=0){
		for(int i=first[x];i!=-1;i=sa[i].next){
            num++;
        }
		if(num!=2){
			cout<<-1;
			flag=1;
			return 0;
		}
	}
	for(int x=1;x<=n;x++){
		sd[x]=now;
		for(int i=first[now];i!=-1;i=sa[i].next){
			int y=sa[i].y;
			if(y!=f){
				f=now;
				now=y;
				break;
			}
		}
		
	}
	if(flag!=1){
        memset(yu,0,sizeof yu);
        for(int i=1;i<=n;i++){
            int o=i-sd[i];
            if(o<0){
                o+=n;
            }
            yu[o]++;
            ans=max(yu[o],ans);
        }
        memset(yu,0,sizeof yu);
        for(int i=1;i<=n;i++){
            int o=i-sd[n-i+1];
            if(o<0){
                o+=n;
            }
            yu[o]++;
            ans=max(yu[o],ans);
        }
        cout<<n-ans;
    }
    return 0;
}
```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Analysis]}}$

话说这题和贪心、图论有什么关系。

~~不过这种题目是我的死穴。~~

我们首先证明如下结论：**如果目标状态和初始状态有 $x$ 个人位置失配，则一定可以通过 $x$ 的代价调整回来。**

> 我们考察其中一个失配的同学 $\alpha_{1}$，假设 Ta **最终**应该在的位置是 $\beta_{1}$，现在所在的位置是 $\xi$。
> 
> 如果有解的情况下，那么 $\beta_{1}$ 位置上的同学 $\alpha_{2}$ 一定也是失配的（不然就无解了）。假设 $\alpha_{2}$ 同学**最终**应该在 $\beta_{2}$ 位置。
> 
> - 如果 $\beta_{2}=\xi$，即 $\alpha_{1},\alpha_{2}$ 两名同学刚好错开，那么我们可以通过一次 $m=2$ 的操作使得 $2$ 个失配的人都回到应该在的位置。
> - 如果 $\beta_{2} \not = \xi$，那么我们继续考察在 $\beta_{2}$ 位置的同学 $\alpha_{3}$，然后假设 $\alpha_{3}$ **最终**应该在的位置 $\beta_{3}$。如果 $\beta_{3}=\xi$，那么我们可以通过一次 $m=3$ 的操作 $\{ \alpha_{1},\alpha_{2},\alpha_{3} \}$，通过 $3$ 的代价使得 $3$ 个失配的同学回到应该在的位置。
> - 如果还不行，继续按照这个规则考察 $\alpha_{4},\beta_{4},\alpha_{5},\beta_{5},\cdots,\alpha_{k},\beta_{k}$，其中 $\beta_{k}=\xi$。可以证明 $k$ 一定是存在的，因为人数是有限的，最多就是 $n$ 个人全部进来了。可以通过一次 $m=k$ 的操作 $\{ \alpha_{1},\alpha_{2},\cdots,\alpha_{k} \}$ 使得 $k$ 个失配的同学回到应该在的位置。

这里的证明倒是有一点图论的味道，最终失配的同学按照上述规则可以形成若干个环，而每个环可以通过一次代价为环大小的操作复原。因此证明了所需的结论。

那么现在问题就变成了，究竟**最少**有多少个人失配。

根据输入，我们可以确定最后环的形态。

环是没有头尾的，当然可以强制定义一个头尾，即强制第 $i$ 个同学在序列的开头，检查有多少个人失配，但是这样做是 $O(n^{2})$ 的。

我们还是考虑以 $1$ 作为序列的开头。把初始链和目标链对应位作减法，将会得到一个数列 $\text{tmp}_{1 \dots n}$。

旋转目标链和旋转初始链是等价的，我们考虑旋转初始链。

由于初始链是 $1,2,3,\dots,n$，因此旋转之后，除了末尾特殊位置之外，其它位置的 $\text{tmp}$ 值都同样的增大或减小了 $1$。也就是说，如果两个位置 $x_{1},x_{2}$，它们是适配的，即它们无需做操作，则 $\text{tmp}_{x_{1}},\text{tmp}_{x_{2}}$ 的差将保持不变。

我们也知道，在初始链旋转到某一个位置时，如果一个位置的 $\text{tmp}_{i}^{'}=0$，那么这个位置在这个初始链下是适配的，无需做操作的。因此我们可以统计 $\text{tmp}_{i}$ 里的众数出现的次数，然后我们根据上一段的性质可以通过旋转初始链使得众数都变为 $0$，那么适配的人数不就最多了吗。

因此，一个 $O(n)$ 的算法就产生了。

注意链的方向对答案是有影响的，需要顺反做两次。

$\color{blue}{\text{Code}}$

```cpp
int Clock[N],Counter[N],ans;
int n,anti[N][2],target[N],init[N];

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		anti[i][0]=read();
		anti[i][1]=read();
		
		init[i]=i;
	}
	
	target[1]=1;
	target[2]=anti[1][0];
	for(int i=2;i<n;i++){
		if (target[i-1]==anti[target[i]][0])
			target[i+1]=anti[target[i]][1];
		else if (target[i-1]==anti[target[i]][1])
			target[i+1]=anti[target[i]][0];
		else{
			printf("-1");
			return 0;
		}//你喜欢人家，人家不喜欢你 
	}//构造目标链
	
	for(int i=1;i<=n;i++){
		Clock[(target[i]-init[i]+n)%n]++;
		Counter[(target[i]-init[n-i+1]+n)%n]++;
	}
	
	for(int i=0;i<n;i++)
		ans=max(ans,max(Clock[i],Counter[i]));
	
	return printf("%d",n-ans)*0;
}
```

---


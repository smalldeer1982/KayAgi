# [NOIP 2009 普及组] 道路游戏

## 题目描述

小新正在玩一个简单的电脑游戏。

游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\le i\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。

游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\le i\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。

以下是游戏的一些补充说明：

1. 游戏从小新第一次购买机器人开始计时。
2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。
3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。
4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。
5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。

现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。


## 说明/提示

对于 $40\%$ 的数据，$2\le n\le 40$，$1\le m\le 40$。

对于 $90\%$ 的数据，$2\le n\le 200$，$1\le m\le 200$。

对于 $100\%$ 的数据，$2\le n\le 1000$，$1\le m\le 1000$，$1\le p\le m$。

NOIP 2009 普及组 第四题


## 样例 #1

### 输入

```
2 3 2 
1 2 3 
2 3 4 
1 2```

### 输出

```
5```

# 题解

## 作者：ButterflyDew (赞：153)

写这个题真是累啊，好毒。应该练练处理比较麻烦的DP。

在读完题目以后，其实初始版的方程并不难想

$dp[i][j][k]$表示时间$i$在工厂$j$当机器人前已经走了$k$步的方案。

$k$那一维可以通过直接枚举消去

$dp[i][j][1/0]$表示时间$i$工厂$j$是否能够继续再走

转移为
$dp[i][j][1]=max(dp[i][j][1],dp[i-k][j-k][0]+cal(i,j,k))$//没有列出关于环的情况的，以下会详细说
$dp[i][j][0]=max(dp[i][j][0],dp[i][k][1]-cost[j])$

确实很不完美，我当时也只是想到了这么多，感觉过个90还是比较轻松的，1000的点拿单调队列优化一下就行了。

然后我就开始写$cal$函数，处理那个对角线式的前缀和，然后成功把自己搅糊了。

这个题把**点权释放到了边权上**，人话就是存储的路径位置其实是某个点伸出去的那一条

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/IKTRiIfqT8ZSvzcJllg7dbY5UnO2c8D2vJN5UquBjdk!/b/dDABAAAAAAAA&bo=xAJ5AcQCeQEDGTw!&rf=viewer_4)

比如用这个图来描述读入的某时间某费用数组

$f[i][j]$表示时间$i$位置$j$所延伸回去的45°的链的值，如下图，黄点为$(i,j)$的位置，则它所代表的链为蓝色的一条链上的点权之和。

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/6YV.sneltfuZ53B.vTuVQpXvIvFx1o633f*CkCB8vmA!/b/dEABAAAAAAAA&bo=4QJrAeECawEDCSw!&rf=viewer_4)

好吧，弄清楚了这个，写一下$cal(i,j,k)$函数了，如下图，它要返回这样一个链的值

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/u*PMefg5t4pVbB94AgrkwBVsNVyWjjtUhfSzz1Fif3o!/b/dC8BAAAAAAAA&bo=vAKKAbwCigEDCSw!&rf=viewer_4)

事实上看起来也不是那么麻烦

```
int cal(int i,int j,int k)
{
    return f[i-1][j-1]-f[i-k-1][j-k-1];
}
```

但是，当转移设计到拐弯时

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/u*PMefg5t4pVbB94AgrkwBVsNVyWjjtUhfSzz1Fif3o!/b/dC8BAAAAAAAA&bo=vAKKAbwCigEDCSw!&rf=viewer_4)

确实有点麻烦。。。我最开始漏掉了那条虚线。。

这是带拐弯的转移：$dp[i][j][1]=max(dp[i][j][1],dp[i-k][n+j-k][0]+cal(i-j+1,n+1,k-j+1)+cal(i,j,j-1))$

好吧，到这里我已经感觉我写不出单调队列了。

交了一下果然拿到了90分，其实在如果在考场上做到这里已经可以了（鬼知道为什么部分分有这么多）

部分分代码：
```
#include <cstdio>
#include <cstring>
int max(int x,int y){return x>y?x:y;}
int min(int x,int y){return x<y?x:y;}
const int N=1010;
const int inf=0x3f3f3f3f;
int dp[N][N][2],n,m,p,harv[N][N],f[N][N],cost[N],ans=-inf;//n数量，m时间
int cal(int i,int j,int k)
{
    return f[i-1][j-1]-f[i-k-1][j-k-1];
}
int main()
{
    memset(dp,-0x3f,sizeof(dp));
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&harv[i][j]);
            f[j][i]=f[j-1][i-1]+harv[i][j];
        }
    for(int i=1;i<=n;i++)
        scanf("%d",cost+i);
    for(int i=1;i<=n;i++)
        dp[1][i][0]=-cost[i];
    m++;
    for(int i=2;i<=m;i++)//时间
    {
        for(int j=1;j<=n;j++)//路程
        {
            for(int k=1;k<=min(i,p);k++)//从第几个之前转移
            {
                if(j>k)
                    dp[i][j][1]=max(dp[i][j][1],dp[i-k][j-k][0]+cal(i,j,k));
                else if(i>j)
                    dp[i][j][1]=max(dp[i][j][1],dp[i-k][n+j-k][0]+cal(i-j+1,n+1,k-j+1)+cal(i,j,j-1));
            }

        }
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
            {
                if(k==j) continue;
                dp[i][j][0]=max(dp[i][j][0],dp[i][k][1]-cost[j]);
            }
    }
    for(int i=1;i<=n;i++)
        ans=max(ans,dp[m][i][1]);
    printf("%d\n",ans);
    return 0;
}

```

看看各位佬爷的题解。

------------
才发现自己的方程太不优秀了，优秀的方程$O(N^3)$甚至可以卡过。

$dp[i]$表示时间$i$的最大答案。

转移：$dp[i]=max(dp[i-k]+cal(i,j,k)-cost[j-k])$//无环

看着减去的$cost[i]$，我明白了应该给$dp[i]$加一个定语

$dp[i]$表示时间$i$处在某位置上还未在此位置上消费机器人的最大答案，每一步的机器人花费是在被转移的时候才扣得啊。而我最初的方程，是代表当前时间$i$和地点$j$已经买了机器人的最大答案。为了区分是否处理花费机器人的状态，我甚至得用第三维的0/1维护。

读了读题目中**“必须立刻在 任意 一个机器人工厂中购买一个新的机器人”**，我明白了为什么可以不要地点这一维，其实每一个时间都可以当做是步数已经到了的时间，而此时地点的选择是具有任意性的，即此时地点也是不重要的。

我把方程改了改，果然$O(N^3)$卡过了

------------
### 单调队列优化

但是，如果数据再卡一点，单队优化就是必须的了。

在这里，因为实在是觉得这种点权下放的方式不优雅，我将工厂的实际编号和时间给减去了1，而读入时不变

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/zLicmWslxFNVhjDepk9XfsmJIJUG5FN7DgQDNQQQVMI!/b/dDABAAAAAAAA&bo=yAJ*AcgCfwEDCSw!&rf=viewer_4)

这样，查询$f[i][j]$所代表的就不是再多延伸出去一条链了，很舒服了。

再列出转移方程：//无环
$dp[i]=max(dp[i-k]+f[i][j]-f[i-k][j-k]-cost[j-k])$
$=max(dp[i-k]-f[i-k][j-k]-cost[j-k])+f[i][j]$

转移时维护$q[i][j]=dp[i]-f[i][j]-cost[j]$即可

因为每一个$f[i][j]$都可以唯一的确定一个$dp[i]$和$cost[j]$，所以我们考虑$f[i][j]$在转移时的分布。

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/huyYyTgue0**JHVsNJYn*hbPZ7wZ8n8YFa0yFYv0Ehg!/b/dFYAAAAAAAAA&bo=2gKYAdoCmAEDCSw!&rf=viewer_4)

对同一个答案的贡献，这个分布大概是这样。

为了准确的定位某个答案从哪个单调队列转移，考虑给每一个单调队列编号，将单队与$location$轴相交的那个点作为它的编号。

在还没拐弯时，所属单队即为$j-i$，拐弯了以后我们发现它减去了$l$个$n$，$l$为拐弯次数，很简单，取膜以后加一个再取膜即可

```
int get(int i,int j)//获取单队编号
{
    return ((j-i)%n+n)%n;
}
```

还有两点要注意的地方

一是虚线所连的边仍然需要特判一下
二是为了确保拐弯后不出现问题，要把$dp[i]=max(dp[i-k]-f[i-k][j-k]-cost[j-k])+f[i][j]$中的$f[i][j]$加上它失去的链的长度，维护一个$add[i]$数组。

参考代码：
```
#include <cstdio>
#include <cstring>
const int N=1010;
int max(int x,int y){return x>y?x:y;}
int n,m,p;
int f[N][N],cost[N],q[N][N],loc[N][N],l[N],r[N],add[N],dp[N];
int get(int i,int j)//获取单队编号
{
    return ((j-i)%n+n)%n;
}
int main()
{
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&f[j][i]);
            f[j][i]+=f[j-1][i-1];
        }
    for(int i=0;i<n;i++)
    {
        scanf("%d",cost+i);
        q[i][++r[i]]=-cost[i],l[i]++;
    }
    memset(dp,-0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=m;i++)
    {
        for(int j=0;j<n;j++)
        {
            int id=get(i,j);
            while(l[id]<=r[id]&&loc[id][l[id]]+p<i) l[id]++;
            if(!j) add[id]+=f[i][n];
            if(l[id]<=r[id])
                dp[i]=max(dp[i],q[id][l[id]]+add[id]+f[i][j]);
        }
        for(int j=0;j<n;j++)
        {
            int id=get(i,j);
            int tmp=dp[i]-add[id]-f[i][j]-cost[j];
            while(l[id]<=r[id]&&q[id][r[id]]<=tmp)
                r[id]--;
            loc[id][++r[id]]=i;
            q[id][r[id]]=tmp;
        }
    }
    printf("%d\n",dp[m]);
    return 0;
}

```

---

## 作者：gorokokoro (赞：26)

居然没有单调队列题解不科学

状态表示和楼上差不多，用 $f[i]$ 表示到时间 $i$ 可以得到的最多金钱

转移很显然，枚举**到达**的点 $j$ 以及走的步数 $k$：

$f[i]=max(f[i-k]+(g[j-1][i]-g[j-k-1][i])-a[j-k])\; \; (0<j<n,0<k \leq min(i,p))$

（其中 $g$ 数组表示斜着的部分和）注意上面没有考虑环的情况

然而这样子做是 $O(N^3)$ 的，理论上是过不了的

我们考虑进行简化，（即省掉 $k$ 循环）先把只有关 $i$ 和 $j$ 的独立出来

$f[i]=max(f[i-k]-g[j-k-1][i]-a[j-k])+g[j-1][i]$

然后我们设一个 $h[i][j]$：

$h[i][j]=f[i]-g[j-1][i]-a[j]$

则转移方程变成了：

$f[i][j]=max(h[i-k][j-k])+g[j-1][i]\; \; (0<k \leq min(i,p))$

而每个对于每个 $f[i][j]$，它都是相当于在**斜线**上转移：

 ![](https://cdn.luogu.com.cn/upload/pic/7773.png) 

（相同颜色的格子代表斜线）对于每个 $f[i][j]$，相当于要求斜线上最多 $p$ 个元素的最大值

然后注意到这是个连续的滑动区间，并且是二维的，于是用 $n$ 个单调队列维护一下就好了

``` cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <utility>
#define N 1020
#define INFINITE 999999999
using namespace std;

class Queue
{
private:
    pair<int, int> f[N];
    int l, r;

public:
    Queue() : l(0), r(0)
    {
        return;
    }

    bool Empty(void)
    {
        return l == r;
    }

    pair<int, int> Back (void)
    {
        return f[r - 1];
    }

    pair<int, int> Front(void)
    {
        return f[l    ];
    }

    void Push_Back(pair<int, int> x)
    {
        f[r ++] = x;

        return;
    }

    void Pop_Back (void)
    {
        r --;

        return;
    }

    void Pop_Front(void)
    {
        l ++;

        return;
    }
};

int n, a[N];
int f[N], g[N][N];
Queue q[N];

void PushOrder(Queue &q, int x, int p)
{
    while(!q.Empty() && q.Back().first <= x)
        q.Pop_Back();
    q.Push_Back(make_pair(x, p));

    return;
}

void PopOrder(Queue &q, int p)
{
    if(q.Front().second <= p)
        q.Pop_Front();
    
    return;
}

int MaxOrder(Queue &q)
{
    return q.Front().first;
}


int Reload(int x, int k)
{
    return ((x - k) % n + n) % n;
}

int main()
{
    int m, p;
    int i, j;

    scanf("%d %d %d", &n, &m, &p);
    for(i = 0;i < n;i ++)
        for(j = 1;j <= m;j ++)
            scanf("%d", &g[i][j]);
    for(i = 0;i < n;i ++)
        scanf("%d", &a[i]);

    for(j = 2;j <= m;j ++)
        for(i = 0;i < n;i ++)
            g[i][j] += g[(i - 1 + n) % n][j - 1];

    for(i = 0;i < n;i ++)
        PushOrder(q[Reload(i, -1)], -a[i], 0);

    for(i = 1;i <= m;i ++)
    {
        for(j = 0, f[i] = -INFINITE;j < n;j ++)
            f[i] = max(f[i], MaxOrder(q[Reload(j, i - 1)]) + g[Reload(j, 1)][i]);

        for(j = 0;j < n;j ++)
        {
            PopOrder (q[Reload(j, i - 1)], i - p);
            PushOrder(q[Reload(j, i - 1)], f[i] - g[Reload(j, 1)][i] - a[j], i);
        }
    }
    cout << f[m] << endl;

    return 0;
}
```

---

## 作者：小水滴 (赞：14)

非常有难度的一道DP。

看100分数据范围: $2≤n≤1000,1≤m≤1000,1≤p≤m$. 一般来说$O(n^3)$的时间复杂度是过不去的，但是我奇迹般的卡过了，最慢的一个点跑了664ms，还可以吧。

#### 算法一：动态规划 ####

我们设$dp[i][j][k]$为目前是第$i$个时刻，目前在第$j$个位置，当前的机器人还要走$k$步的最大金币数。

如果现在不考虑换机器人，那么我们马上可以推出状态转移方程：

$dp[i][j][k]=max(dp[i][j][k],dp[i-1][s(j-1)][k+1]+get(i,j))$

其中，$s(j-1)$是指第$j$个位置的前驱（也就是$j$是从$s(j-1)$走过来的）。

$get$函数返回的是第$i$个时刻第$j$号道路上的金币数量。

那么现在考虑换机器人。

我们只需要在$dp[i-1][j'][0]$中找一个最大值（走完了），记为w，然后，可以将$dp[i][j(1..n)][p]$都赋值为$w-costcoin[j]$，再将$dp[i][j(1..n)][k(0..p-1)]$都赋值为$w-costcoin[s(j-1)]+get(i,j)$（一定要手动赋值一步！）

然后再进行第$1$个状态转移方程即可。

时间复杂度：$O(n^3)$ 空间复杂度：$O(n^3)$

此算法可以通过90%的数据。

参考程序：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,p,dp[201][201][201];
int get_coin[201][201];
int cost_coin[201];
int abc(int x)
{
    if(x==0) return n;
    else return x;
}
int read()
{
    int f=1,w=0; char c=getchar();
    while((c<'0' || c>'9') && c!='-') c=getchar();
    if(c=='-') {f=-1;c=getchar();}
    while(c>='0' && c<='9')
    {
        w=w*10+c-48;
        c=getchar();
    }
    return w*f;
}
int get(int i,int j)
{
    if(j==1) return get_coin[n][i];
    else return get_coin[j-1][i];
}
int main()
{
    n=read();m=read();p=read();
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        get_coin[i][j]=read();
    for(int i=1;i<=n;i++)
      cost_coin[i]=read();
    for(int i=1;i<=n;i++)
      for(int k=0;k<=p;k++)
        dp[0][i][k]=-cost_coin[i];
    for(int i=1;i<=m;i++)
    {
        int zhi=0xafffffff;
        for(int j=1;j<=n;j++)
        {
            if(dp[i-1][j][0]>zhi)
              zhi=dp[i-1][j][0];
        }
        for(int j=1;j<=n;j++)
        {
            for(int k=0;k<=p-1;k++)
              dp[i][j][k]=zhi-cost_coin[abc(j-1)]+get(i,j);
            dp[i][j][p]=zhi-cost_coin[abc(j-1)];
        }
        for(int j=1;j<=n;j++)
          for(int k=0;k<=p-1;k++)
            dp[i][j][k]=max(dp[i][j][k],dp[i-1][abc(j-1)][k+1]+get(i,j));
    }
    int ans=0xafffffff;
    for(int j=1;j<=n;j++)
      for(int k=0;k<=p;k++)
        ans=max(ans,dp[m][j][k]);
    printf("%d\n",ans);
    return 0;
}
```

#### 算法二：动态规划 ####

在算法一的基础上，发现 $dp$ 数组的第一维是可以滚动的，这就让空间复杂度降到了$O(n^2)$，但是最后2个点的时间依然超限。

时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$

（此算法由于要改动的东西过少，所以我就不放程序啦）

#### 算法三：动态规划 ####

我们可以将方程的定义稍稍改一改，将$dp[i][j][k]$改为第$i$个时刻，第$j$个位置，已经走了$k$步的最大金币数。
由于$i$必须大于等于$k$，所以当$i<k$时可以直接$break$，压缩了时间复杂度，这样就可以通过全部测试点了！

此算法和算法一相比，有以下几个不同：

1. 求最大值不仅仅扫描$dp[i-1][j][0]$，而是$dp[i-1][j][k]$；
2. 状态转移方程要改为：
$dp[i][j][k]=max(dp[i][j][k],dp[i-1][s(j-1)][k-1]+get(i,j))$；
3. 换机器人的开始时，只将$dp[i][j][0]$和$dp[i][j][1]$进行赋值。

其他还有一些细节需要改动，大家就在代码里面看吧！

时间复杂度：$O(n^3)$不满 空间复杂度：$O(n^2)$

参考代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,p,dp_1[1001][1001],dp[1001][1001];
int get_coin[1001][1001];
int cost_coin[1001];
int zhi=0xafffffff;
inline int abc(int x)
{
    if(x==0) return n;
    else return x;
}
inline int read()
{
    int f=1,w=0; char c=getchar();
    while((c<'0' || c>'9') && c!='-') c=getchar();
    if(c=='-') {f=-1;c=getchar();}
    while(c>='0' && c<='9')
    {
        w=w*10+c-48;
        c=getchar();
    }
    return w*f;
}
inline int get(int i,int j)
{
    if(j==1) return get_coin[n][i];
    else return get_coin[j-1][i];
}
int main()
{
    n=read();m=read();p=read();
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        get_coin[i][j]=read();
    for(int i=1;i<=n;i++)
      cost_coin[i]=read();
    for(int i=1;i<=n;i++)
    {
        dp_1[i][0]=-cost_coin[i];
        zhi=max(zhi,dp_1[i][0]);
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dp[j][0]=zhi-cost_coin[j];
            for(int k=1;k<=p;k++)
            {
                if(i<k) break;
                if(k==1)
                {
                    dp[j][k]=zhi-cost_coin[abc(j-1)]+get(i,j);
                    dp[j][k]=max(dp[j][k],dp_1[abc(j-1)][k-1]+get(i,j));
                }
                else dp[j][k]=dp_1[abc(j-1)][k-1]+get(i,j);
            }
        }
        zhi=0xafffffff;
        for(int j=1;j<=n;j++)
        {
            for(int k=0;k<=p;k++)
            {
                if(i<k) break;
                dp_1[j][k]=dp[j][k];
                zhi=max(zhi,dp[j][k]);
            }
        }
    }
    int ans=0xafffffff;
    for(int j=1;j<=n;j++)
      for(int k=0;k<=p;k++)
        ans=max(ans,dp[j][k]);
    printf("%d\n",ans);
    return 0;
}
```

备注：我求最大值是一边赋值一边求的，稍稍优化了一下。

总结：非常有难度的DP，是选手们在DP成长路上的必刷之题。要做出本题，不仅要有丰富的DP刷题经验，还要有缜密的思维和很强的分析能力。

---

## 作者：Kevin_Wa (赞：10)

解题分析：

如果设$f[i,j]$为时间$i$，当前机器人在$j$处，最大能捡取的金币数，以划分时间段，

则当前$f[i,j]$的值可以由两种状态得到

1、前一时间点不改变机器人 则 
$f[i,j]=f[i-1,j-1]+a[i,j];$

要注意当前机器人走路的次数不能超过$p$；要考虑$j=1$的情况

2、前一时间点改变机器人

则现在的$f[i,j]$可由数组$f[i-1,x]$中的任意值得到 由题意应取最大值

所以 $f[i,j]=max(f[i-1,x]+a[j,i]-b[j]);$
($1 \leq x \leq n$)

综合得$f[i,j]=max(f[i-1,j-1]+a[j,i],max(f[i-1,x]+a[j,i]-b[j]));$

### 代码

```pascal
var n,m,p,i,j,sum,k,ans1,ans:longint;
f:array[0..2001,0..2001] of longint;
c,a:array[0..2001,0..2001] of longint;
b:array[0..2001] of longint;
function max(x,y:longint):longint;
begin
if x>y then exit(x) else exit(y);
end;
begin
readln(n,m,p);
for i:=1 to n do
  for j:=1 to m do
    read(a[i,j]);
ans1:=-maxlongint;
for i:=1 to n do
  begin
  read(b[i]);
  f[1,i]:=a[i,1]-b[i];
  c[1,i]:=1;
  ans1:=max(ans1,f[1,i]);
  end;
for i:=2 to m do
  begin
  ans:=ans1;
  ans1:=-maxlongint;
  for j:=1 to n do
    begin
    k:=j-1;
    if k=0 then k:=n;
    if c[i-1,k]<p then
      begin
      f[i,j]:=f[i-1,k]+a[j,i];
      c[i,j]:=c[i-1,k]+1;
      end;
    if ans+a[j,i]-b[j]>f[i,j] then
      begin
      f[i,j]:=ans+a[j,i]-b[j];
      c[i,j]:=1;
      end;
    ans1:=max(ans1,f[i,j]);
    end;
  end;
writeln(ans1);
close(input);close(output);
end.
```


如果这样做那好，恭喜你只有$80$分。因为这种方法无法判断一个格子小的情况，所以我们将他由一个个传递来改变成区间，就能避免让更优的方案被覆盖掉。另外因为$f[i,j]$除了和$f[i-1,j]$有关以外就没有其他关联了，所以可以将他压缩至一维数组。


### Code 


```
# include<iostream>
# include<cstring>
using namespace std;
int n,m,p;
int pay[1001];
int money[1001][1001];
int f[1001];
int main()
{
    cin>>n>>m>>p;
    memset(f,-999999,sizeof(f));
    f[0]=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        cin>>money[i][j];
    for(int i=1;i<=n;i++)
      cin>>pay[i];
    for(int i=1;i<=m;i++)
      for(int j=1;j<=n;j++)
        {
            int ff=j-1;
            if(!ff) ff=n;
            int ss=money[ff][i];
            for(int k=1;k<=p;k++)
              {
                  if(i-k<0) break;
                  f[i]=max(f[i],f[i-k]+ss-pay[ff]);
                  ff--;
                  if(!ff) ff=n;
                  ss+=money[ff][i-k];
              }
        }
    cout<<f[m];
    return 0;
}
```


---

## 作者：dengyaotriangle (赞：9)

## 这里提供一个很巧的想法

非常好理解，也非常妙

这道题的$O(n^3)$dp很显然，如果不会的话先看其它题解

而如何优化到$O(n^2)$或$O(n^2logn)$过掉本题就有意思了

首先观察到这个机器人在动就很烦人，我们要想办法把它定住。

那咋整啊，**众所周知运动是相对的，所以我们可以让工厂的代价，和金币随着时间逆时针旋转，这样就等价于机器人顺时针旋转**

那么显然，现在第$i$个工厂第$j$时刻的代价是$ c[(i+j+2)\%n\ +1]$，而第$i$条路上第$j$时刻的金币数是$ a[(i+j+2)\%n\ +1][j] $，其中$c[i]$为原输入中第$i$个工厂的代价，$a[i][j]$为原输入中第$i$条路第$j$单位时间的金币数

那么问题转化为

**每次花一定的代价在一个地方放机器人，最多维持$p$单位时间，每单位时间机器人都会捡起自己右边道路上的金币，机器人不动**

那么我们朴素的列一个dp方程
$$ dp[i]=\max_{j=1}^{n}\max_{k= max(0,i-p)}^{i-1} dp[k]+pfx[j][i]-pfx[j][k]-cost[j][k+1]$$

$dp[i]$代表$i$单位时间内的最大价值

其中$cost[i][j]$代表第$i$个工厂第$j$单位时间的代价（注意我们转动了它，所以虽然原题中不变这里也是变化的）   
$pfx[i][j]$代表$\sum_{k=1}^{j} val[i][k]$，$val[i][j]$代表第$i$条路第$j$秒的金币数

### 注意上述的都是转化后的值

**所以dp方程的意义是：枚举所以可能的上次选的工厂和时间，然后取max**

显然这个dp是$O(n^3)$的

那么如何优化？

我们做一个简单的变形

$$ dp[i]=\max_{j=1}^{n}\max_{k= max(0,i-p)}^{i-1} dp[k]+pfx[j][i]-pfx[j][k]-cost[j][k+1]$$
$$ =\max_{j=1}^{n} pfx[j][i]+\max_{k= max(0,i-p)}^{i-1} dp[k]-pfx[j][k]-cost[j][k+1]$$
设$g[j][k]=dp[k]-pfx[j][k]-cost[j][k+1]$，则
$$ =\max_{j=1}^{n} pfx[j][i]+\max_{k= max(0,i-p)}^{i-1} g[j][k]$$
其中$\max_{k= max(0,i-p)}^{i-1} g[j][k]$，可以开$n$个优先队列/单调队列，然后参见[滑动窗口的50分或100分解法](https://www.luogu.org/problemnew/show/P1886)，来实现单次询问$O(1)$或$O(logn)$，均可通过此题

注意这里是一边求值一边询问最大值的，故不能用st表。

个人认为优先队列更好写，如果时间复杂度以及常数允许的话尽量写优先队列，减少写挂的概率

**注意答案有可能有负数，dp初始值需设为0xc0c0c0c0（约等于-1e9）**

参考代码
```cpp
#include<bits/stdc++.h>

using namespace std;

const int maxn=1005;

int n,m,p;
int a[maxn][maxn],r[maxn][maxn];
int c[maxn];
int pfx[maxn][maxn];

priority_queue<pair<int,int> > q[maxn];

bool operator<(pair<int,int> a,pair<int,int> b){
    if(a.first==b.first) return a.second>b.second;
    return a.first<b.first;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>p;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            r[j][i]=a[(j+i-2)%n+1][i];
        }
    }
    for(int i=1;i<=n;i++)cin>>c[i];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) pfx[i][j]=pfx[i][j-1]+r[i][j];
    }
    for(int i=1;i<=n;i++){
        q[i].push(make_pair(-c[(i-1)%n+1],0));
    }
    int ans=0xc0c0c0c0;
    for(int i=1;i<=m;i++){
        int mx=0xc0c0c0c0;
        for(int j=1;j<=n;j++){
            int cur=pfx[j][i];
            while(q[j].top().second<i-p) q[j].pop();
            cur+=q[j].top().first;
            mx=max(mx,cur);
        }
        for(int j=1;j<=n;j++){
            q[j].push(make_pair(mx-pfx[j][i]-c[(j+i-1)%n+1],i));
        }
        ans=max(ans,mx);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Ofnoname (赞：7)

题解几乎都是填表法，只有一篇刷表法。我再来写一篇$O(n^3)$刷表题解。

填表法就是从后往前算，比如用$f[i]$计算出$f[i-1]$的值。

而刷表就是反过来，比如用$f[i]$计算出$f[i+1]$的值。

那么对于当前这一列，它有可能在计算后面任何一列时被用到.

![]( https://cdn.luogu.com.cn/upload/pic/71104.png )

比如对于选择时刻2的第二个数字得到的序列（红色方块），它就有可能作为第3,4,5,6,7列最优解的最后一步（即候选答案）。所以在算第二列时就可以把它们考虑一遍。
```
//f[i]表示只考虑前i列的最优解
for (int y = 1; y <= M; y++)//枚举每一列
	for (int x = 1; x <= N; x++)//枚举每一排
	{
		int v = f[y-1] - d0[x];//选(x,y)要d0[x]个金币，同时继承上一列的答案。
		for (int k = 0; k < min(P,M-y+1); k++)
		{//不能越界
			int p = x+k>N ? x+k-N : x+k;
            //避免取模是最重要的卡常
			v += d[p][y+k];
            //v 为对角线上一路累计的答案
			f[y+k] = max(f[y+k], v); 
            //用备选答案刷新以后的f值。
		}
	}
```
$O(n^3)$看似多达1e9，但是第三层循环跑不满，稍微卡常就可以通过。

---

## 作者：ez_lcw (赞：6)

# bfs能过的题为什么要dp？

这是一道很典型的dp，可是当我第一眼看过去的时候，不知为什么，觉得像bfs的题。

于是，我就~~抱着人有多大胆地有多大产的心态~~打出了bfs。

其实思路很简单：队列里存的是当前时间点，然后拿出来枚举下一次在哪个工厂造机器人，走多少步，然后用一个类似于SPFA的dis和inqueue来记录就可以啦。

具体代码如下：

```cpp
//因为是模拟赛的题，所以会有一些inline、register、快读什么之类的
#include<cstdio>
#include<queue>
#include<cstring>
 
#define N 1001
#define INF 0x7fffffff
 
using namespace std;
 
int n,m,p,w[N][N],mon[N],dis[N];
bool inq[N];
 
inline int read() {//快读
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-') {
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') {
        x=(x<<1)+(x<<3)+(ch^'0');
        ch=getchar();
    }
    return x*f;
}
 
queue<int>q;
 
int bfs() {
    for(int i=1;i<=m;i++){
        dis[i]=-INF;//初始化
    }
    q.push(0);//开始时间点为0
    while(!q.empty()){
        int now=q.front();
        q.pop();
        inq[now]=false;
        for(register int i=1; i<=n; i++) {//枚举起始点
            int sum2=0;//记录能获得的金币
            for(register int t=1,u=i; t<=p&&now+t<=m; t++,u++) {//枚举走几步
                if(u>n) {//注意有环
                    u-=n;
                }
                sum2+=w[u][now+t];//更新sum2
                if(dis[now]+sum2-mon[i]>dis[now+t]){//如果有更优方案
                    dis[now+t]=dis[now]+sum2-mon[i];
                    if(!inq[now+t]){//类似SPFA的判断inqueue
                        q.push(now+t);
                        inq[now+t]=true;
                    }
                }
            }
        }
    }
    return dis[m];
}
 
int main() {
//  freopen("game.in","r",stdin);
//  freopen("game.out","w",stdout);
    n=read();
    m=read();
    p=read();
    for(register int i=1; i<=n; i++) {
        for(register int j=1; j<=m; j++) {
            w[i][j]=read();
        }
    }
    for(register int i=1; i<=n; i++) {
        mon[i]=read();
    }
    printf("%d\n",bfs());
    return 0;
}
/*
2 3 2
1 2 3
2 3 4
1 2
*/

```

---

## 作者：zzr8178541919 (赞：4)

这道题很值得写一篇题解来记录一下：

首先看题，感觉题特别的长。但是只要仔细的思考一下，发现题目并不难理解。

把整个问题转化之后，题目就变得简单了不少。

我们可以直接设计出状态转移方程。

我们设dp[i]表示前i的时间能收集到的最多金币。那么最后的答案就是输出dp[m];
那我们怎么转移呢。

我们发现影响的因素有n,m,p;所以我们可以考虑n^3的状态转移方程。
#### 我们可以枚举n,m,p;
先枚举时间m，然后枚举在m的这个时间我们当前在哪个点。然后再枚举k表示在当前的基础上我们要向前走的距离。并且我们保证我们在当前的这个仓库购买机器人。

具体过程见代码：
```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int a[1005][1005];
int money[1005];
int dp[2005];
int main()
{
	int n,m,p;
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		scanf("%d",&a[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&money[i]);
	}
	for(int i=1;i<=m;i++)
	{
		dp[i]=-1e9;
	}//由于可能有负数，先赋值成-1e9 
	for(int i=1;i<=m;i++)//枚举时间。 
	{
		for(int j=1;j<=n;j++)//枚举当前到达了那个点。 
		{
			int ans=dp[i-1]-money[j];//ans先记录的是从当前开始买的初始值。 
			for(int k=0;k<p && k+i<=m;k++)
			//k从0到p-1枚举，同时要保证总时间不能超过m的限制。 
			{
				int t=(j+k)>n?((j+k)%n):(j+k);//把k时间后到达哪个位置处理出来。
				//当前的ans不断更新。这样还能保证ans不断更新。 
				ans=ans+a[t][i+k];
				dp[i+k]=max(dp[i+k],ans);
				//更新答案。 
			}
		}
	}
	printf("%d\n",dp[m]);
	return 0;
}
```


从而更新答案。但这其中有很多需要注意的地方、

---

## 作者：Whitecate (赞：3)

dp 好题，就是数据水了。

因为道路是环形的，并且每个机器人走的步数范围给定，所以我们定义一个前缀和数组 $pfx_{i,j}$，为在第 $i$ 秒时，从第 $j$ 个点出发所能收集到的金币数。于是可以得到：

$$pfx_{i,j} = pfx_{i,j} + pfx_{i-1,F(j-1)}$$


特别说明一下，其中的 $F$ 函数是处理循环的。

```cpp
int F(int pos) {return (pos % n + n) % n;}
```

这些都是准备，正片开始。我们设 $dp_i$ 为在第 $i$ 秒时所能取得的最多的金币。我们考虑从第 $k$ 秒前的 $dp_{i-k}$ 转移。如果在此时正好到达了第 $j$ 个工厂，就可以得到：

$$
dp_i = \max(dp_i,dp_{i-k} - c_{F(j-k+1)} + pfx_{i,j} - pfx_{i-k,F(j-k)})
$$

其中 $c_i$ 为在第 $i$ 个工厂买机器人的代价。

于是，dp 部分的代码就可以得到了。

```cpp
for(int i = 1; i <= m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            for(int k = 1; k <= min(p,i); k++)
            {
                dp[i] = max(dp[i],dp[i-k] - c[F(j-k+1)] + pfx[i][j] - pfx[i-k][F(j-k)]);
                
            }
        }
    }
```

最终，只要输出 $dp_m$ 即可。

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,p,dp[1008],pfx[1008][1008],c[1008];
int F(int pos) {return (pos % n + n) % n;}

int main()
{
    cin >> n >> m >> p;
    for(int j = 0; j < n; j++)
    {
        for(int i = 1; i <= m; i++)
        {
            //直接输入这个就可以，反正到时候会处理。
            cin >> pfx[i][j];
        }
    }
    //对前缀和的处理
    for(int i = 1; i <= m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            pfx[i][j] += pfx[i-1][F(j-1)];
        }
    }
    
    for(int j = 0; j < n; j++)
    {
        cin >> c[j];
    }
    
    memset(dp,0xc0c0c0c0,sizeof(dp));
    //由于是环形的，从0开始方便处理
    dp[0] = 0;
    for(int i = 1; i <= m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            for(int k = 1; k <= min(p,i); k++)
            {
                //注意是 min(p,i)，因为机器人最多存在 p 秒，同时你的时间不能为负数。
                dp[i] = max(dp[i],dp[i-k] - c[F(j-k+1)] + pfx[i][j] - pfx[i-k][F(j-k)]);
                
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```

---

## 作者：zhouth (赞：2)

# [NOIP 2009 普及组]道路游戏题解

[题目传送门](https://www.luogu.com.cn/problem/P1070)

这是一道枚举起点和步数的典范 dp 例题，非常值得掌握。
## 题目描述

给定一个**环形道路**上的 $n$ 个机器人工厂和连接工厂的 $n$ 段马路，第 $i$ 段马路连接第 $i$ 个工厂与第 $i+1$ 个工厂（第 $n$ 段连接第 $n$ 个和第 $1$ 个）。每条马路每个单位时间内会生成一定数量的金币。你可以在任意时间点购买一个机器人放在某个工厂，该机器人会以顺时针方向每秒前进一格，并把经过的马路的金币全拿走。每个机器人最多可以走 $p$ 次，一次只能存在一个机器人，走完就必须买新的。

## dp分析

### 1.状态定义：求啥设啥

由于我们要求的是第 $m$ 单位时间的最大得分，因此无法使用间接的状态定义，而应直接设 $dp[t]$ 表示在前 $t$ 个时间单位内，最多能获得多少个金币（包括收集的金币减去购买机器人的花费）。

### 2.考虑状态转移：从哪里来

要计算 $dp[t]$，我们可以去枚举：

+ 机器人最后一次购买是在什么时候，设为 $st$。

+ 该机器人行走了几步，设为 $k$。

+ 在哪个工厂买的机器人。

  每次转移的含义：

  在第 $t - k$ 时刻买机器人，让它从第 $st$ 个工厂出发，走 $k$ 步，经过 $k$ 条马路，收集金币后更新 $dp[t]$。

  所以我们的状态转移方程为：
  $$
  dp[t] = \max\left(dp[t],\ dp[t-k] + \sum_{j=0}^{k-1} gold[(st + j - 1) \bmod n + 1][t-k+1 + j] - cost[st]\right)
  $$

### 3.初始化：起始点

很显然，我们刚开始的时候是没有任何分数的，所以我们的初始值就是 $dp[0] = 0$。
### 4.答案输出：结果在哪里

我们要求的是前 $m$ 时间单位的最大值，所以我们最后的结果就是 $dp[m]$。

## AC code

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1005;
// gold[i][j] 表示第 i 条马路在第 j 单位时间内的金币数量
int gold[N][N];
// cost[i] 表示在第 i 个工厂购买机器人的花费
int cost[N];
// rp[t] 表示前 t 单位时间最大可获得的金币数（包括扣除购买机器人花费）
int rp[N];
int main(){
	int n, m, p;
    scanf("%d%d%d", &n, &m, &p);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			scanf("%d", &gold[i][j]);
		}
	}
	for(int i = 1; i <= n; i++){
		scanf("%d", cost + i);
	}
	memset(rp, -0x3f, sizeof(rp));
	rp[0] = 0;
	for(int t = 1; t <= m; t++){ // 枚举当前时间点 t
		for(int i = 1; i <= n; i++){ // 枚举从哪个工厂购买机器人
            int sum = 0;
			for(int k = 1; k <= p && k <= t; k++){ // 枚举机器人行走的步数 k（最多为 p）
                 // 环形结构处理：计算起始工厂 st
				int st = (i - k) % n;
				if(st <= 0){
					st += n;
				}
                 // 机器人开始工作的时间（当前时间倒推 k 步）
				int time = t - k + 1;
				if(time <= 0){
					break; // 时间非法，跳出
				}
				sum += gold[st][time]; // 累加该时间该马路上的金币
				rp[t] = max(rp[t], rp[t - k] + sum - cost[st]);
			}
		}
	}
    printf("%d\n", rp[m]);
	int zsr = 0;
	rp[zsr]++;
	return 0;
}
```

时间复杂度为 $O(nmp)$ 看似是 $O(1000 ^ 3)$ 的复杂度，实际上最内层循环跑不了这么慢，还是比较快的。

题外话

中考结束了，祝我的朋友zsr能考上二十四中。

祝所有OIer，rp++。
审核员不要再卡我了，谢谢

---

## 作者：xyvsvg (赞：1)

提供一个实现起来简单一些的代码。

基本思路其他题解已经讲述的比较完全了，不过多数都是斜着转移，比较复杂。所以我们考虑在输入时斜着输入，转移时横着转移。

即对于第 $i$ 列输入，我们把这一列循环向上滚动 $i-1$ 位。

大致代码：


```cpp
int main()
{
    int n,m,k;
    cin>>n>>m>>k;
    vector<vector<int> >a(n+10,vector<int>(m+10));
    vector<vector<int> >dp(n+10,vector<int>(m+10));
    vector<int>b(n+10);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            cin>>a[(i+n-j%n)%n+1][j];
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            a[i][j]+=a[i][j-1];
    vector<deque<P> >deq(n+10);
    for(int i=1;i<=n;++i)
        cin>>b[i],deq[i].emplace_back(0,-b[i]);
    #define x first
    #define y second
    for(int j=1;j<=m;++j)
    {
        auto pop=[&](deque<P>&deq,const P p)
        {
            while(!deq.empty()&&deq.back().y<=p.y)
                deq.pop_back();
            deq.push_back(p);
        };
        int res=-infi;
        for(int i=1;i<=n;++i)
        {
            while(j-deq[i].front().x>k)
                deq[i].pop_front();
            dp[i][j]=a[i][j]+deq[i].front().y;
            dmax(res,dp[i][j]);
        }
        for(int i=1;i<=n;++i)
            pop(deq[i],{j,res-a[i][j]-b[(i+j-1)%n+1]});
    }
    int ans=-infi;
    for(int i=1;i<=n;++i)
        dmax(ans,dp[i][m]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Ericnoi (赞：1)

# P1070 题解

[题目传送门](https://www.luogu.com.cn/problem/P1070)

# 分析

看到 $O(nmp)$ 的题解中很多是用前缀和实现的。提供一种简洁的思路，最慢的测试点不超过 $100$ 毫秒。

显然，这题应该使用动态规划的思路。那我们首先要解决的就是状态空间的设计。我们可以尽量在状态空间中提供更多的信息。不难发现，我们可以令 $dp_{i,j,k}$ 表示第 $i$ 秒时走了第 $j$ 条路，并且这个机器人已经走过 $k$ 条路情况下的最大收益。令 $w_{i,j}$ 表示第 $i$ 条路第 $j$ 秒的收益，$c_i$ 表示使用第 $i$ 个机器人厂的费用，$mx_i = \max_{j=1}^{n}\max_{k=1}^{\min(i,p)}dp_{i,j,k}$。有显然的状态转移方程：

$$
dp_{i,j,k}=
\left\{\begin{matrix}
mx_{i-1}-c_i+w_{i,j} &(k=1)
 \\
dp_{i-1,left(j),k-1}+w_{i,j} &(1<k \le \min(i,p))
\end{matrix}\right.
$$

其中 $left(i)$ 当 $i \in [2,n]$ 时表示 $i-1$，当 $i=1$ 时表示 $n$。

由于第三维的上界不为 $p$，所以跑不满 $10^9$，这种常数小的程序时间上能稳过。空间上用滚动数组优化一维即可，代码实现十分简洁：

# Code

```cpp
#include <bits/stdc++.h>
#define inf (0x3f3f3f3f)
#define left(x) (((x) == 1) ? (n) : ((x) - 1))
#define right(x) (((x) == n) ? (1) : ((x) + 1))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline int read(int &x) { 
	int f = 1; x = 0; char s = getchar();
	while(!isnumber(s)) {if(s == '-') f = -1; s = getchar();}
	while(isnumber(s)) x = (x << 1) + (x << 3) + (s ^ '0'), s = getchar();
	return x *= f;
}
inline void print(int x, char suf = 0, int base = 10) {
	if(x < 0) {putchar('-'); x = -x;}
	if(x >= base) print(x / base, 0, base);
	putchar(48 ^ (x % base));
	if(suf) putchar(suf);
}
int cx = 1;
const int N = 1e3 + 5;
const int M = 1e3 + 5;
const int P = 1e3 + 5;
int n, m, p, a[N][M], dp[N][2][P], c[N], mx[2];
void solve() {
	read(n), read(m), read(p);
	for(int i = 1 ; i <= n ; i++) {
		for(int j = 1 ; j <= m ; j++) {
			read(a[i][j]);
		}
	}
	for(int i = 1 ; i <= n ; i++) {
		read(c[i]);
	}
	int old = 0, now = 1;
	for(int i = 1 ; i <= m ; i++) {
		swap(old, now);
		mx[now] = -inf;
		for(int j = 1 ; j <= n ; j++) {
			dp[j][now][1] = mx[old] - c[j] + a[j][i];
			for(int k = 2 ; k <= min(i, p) ; k++) {
				dp[j][now][k] = dp[left(j)][old][k-1] + a[j][i];
			}
		}
		for(int j = 1 ; j <= n ; j++) {
			for(int k = 1 ; k <= min(i, p) ; k++) {
				chkmax(mx[now], dp[j][now][k]);
				// printf("dp[%d][%d][%d] = %d\n", j, i, k, dp[j][now][k]);
			}
		}
	}
	print(mx[now], '\n');
}
signed main() {
    // int st_t = clock();
    // read(cx);
	// init();
    while(cx--) {
        solve();
    }
    // cerr << clock() - st_t << "ms" << endl; 
    return 0;
}



```

---

## 作者：xuanfeng101 (赞：0)

## 前言

~~题目阅读量大，细节多~~

## 思路

首先我们可以发现每次机器人的贡献是一段一段的，于是我们可以先用前缀和预处理一下设 $g_i,_j$ 表示从 $i$ 工厂由零时刻向前走 $j$ 秒的贡献，$a_i,_j$ 表示原时间数组，那么有 
$$
g_i,_j = g_{i - 1},_j + a_{(i + j - 2)\bmod n + 1},_j
$$
也就是维护对于 $a$ 数组的连续的斜线权值和。

然后题目要求求一个跟时间有关的权值最大值问题，那么我们可以想到 $dp$ ,并且将时间作为重要的一维，设 $f_t$ 表达 $t$ 时间内的最大收益，朴素地有
$$
f_t = \max\limits_{j = t - p} ^ {t - 1}\max\limits_{pos = 1}^{n} (f_j - g_{pos},_j - c_{pos},_j)
$$
其中 $c_{pos},_j$ 表示从 $pos$ 经过 $j$ 秒到达的工厂购买一个机器人要话费的代价。

观察这个有三个变量的式子时间复杂度为 $O(n ^ 3)$ 按理说是过不了（不过听说数据很水好像优化一下也可以过），但是我们可以观察这个 $dp$ 式子，考虑固定一个 $pos$ 我们发现，此时的 $f_t$ 只与 $j \in [t - p, t - 1]$ 有关，这不就是一个长度为 p 的滑动窗口嘛，于是，我们可以对每一个 $pos$ 开一个滑动窗口，这样时间复杂度就降低为 $O(n ^ 2)$ 。

## Code

```cpp
#include <bits/stdc++.h>
const int N = 1010;
using namespace std;
int n, m, p;
int q[N][N];
int hh[N], tt[N];
int g[N][N], f[N], a[N][N], c[N]; 

int get(int pos, int j)
{
	return f[j] - g[pos][j] - c[(pos + j - 1) % n + 1];
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	memset(tt, -1, sizeof tt);
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
			cin >> a[i][j];
	for (int i = 1; i <= n; i ++ ) cin >> c[i];

	for (int i = 1; i <= n; i ++ )
	{
		for (int j = 1; j <= m; j ++ )
			g[i][j] = g[i][j - 1] + a[(i + j - 2) % n + 1][j];
	}

	for (int i = 1; i <= n; i ++ ) q[i][ ++ tt[i]] = 0;	
	for (int t = 1; t <= m; t ++ )
	{
		int mx = -0x3f3f3f3f;
		for (int i = 1; i <= n; i ++ ) 
		{
			if (hh[i] <= tt[i] && t - q[i][hh[i]] > p) hh[i] ++ ;
			if (hh[i] <= tt[i]) mx = max(mx, get(i, q[i][hh[i]]) + g[i][t]);
		}
		f[t] = mx;
		for (int i = 1; i <= n; i ++ )
		{
			while (hh[i] <= tt[i] && get(i, q[i][tt[i]]) <= get(i, t)) tt[i] -- ;
			q[i][ ++ tt[i]] = t; 
		}
	}		
	cout << f[m];
	return 0;
} 
```

---

## 作者：GG_Grass (赞：0)

**一道有点阴间但是挺值得啃的单调队列优化 dp，我在前缀和处理的思路上有些特别，所以写篇题解记录下。**

_~~刚学单调队列优化就啃这题，啃了一下午。~~_


---
由于机器人可以走 $k\in[1, p]$ 步，且机器人可以在 $pos \in[1, n]$ 处购买，所以枚举在 $k$ 时间前，在 $pos$ 处购买机器人能得到的最大的金币数量。

那么就得到了状态转移方程：

$$f(t) = f(t - k) + \max(get(pos, k))$$

$f(t)$ 表示在 $t$ 时间时，机器人能收集到的最大的金币数量。

$get(pos, k)$ 表示从 $pos$ 处买机器人走 $k$ 步能收集到的金币数量。

有三个变量，还要模拟一下机器人走路，时间复杂度是吓人的 $O(mnp^2)$，不优化怕是 $200$ 的数据都够呛能过。
 
---

来想想怎么优化。

先把一长串 $get$ 拆开，变成：从 $pos$ 开始，走 $k$ 步，能收集到的金币数量，再减去买机器人花费的钱。

为了节省模拟机器人走路的 $O(p)$ 复杂度，我们用前缀和来代替。

所以这个前缀和怎么写？

显然这是个螺旋一样的前缀和。如果用第 $t$ 时间走到第 $pos$ 个工厂的形式的话，需要特别注意在两个时间里，两个工厂的对应关系。~~太阴间了，写不明白~~。

想想别的思路：由于机器人停下后可以任选一个工厂买机器人，**那么我们无需关注机器人在哪个工厂停下，只要保证每个工厂都可以被枚举到就可以了**。并且由于我们只是要求一个最大值，**所以也没有必要保证枚举工厂的顺序是从 $1$ 到 $n$**。

**所以让我们换一个前缀和的思路**：让这个机器人一开始从工厂 $pos$ 出发，不考虑自动消失，一直顺时针行走，直到时间为 $m$。那么 $pf(pos, t)$ 就是它从 $pos$ 开始行走，走了 $t$ 时间收集到的金币数。我们可以将它命名为路线 $pos$。那么在 $t$ 时间点的 $k$ 时间前，如果机器人走的是路线 $pos$，**它收集到的金币数量就是** $pf(pos, t) - pf(pos, t - k)$。只要枚举路线 $0$ 到路线 $n - 1$，就相当于枚举到了每个工厂。前缀和的问题就解决了。

我们还需要计算一下花费，只要计算一下在 $t - k$ 时，路线 $pos$ 走到哪个工厂就可以了。具体看代码的 $cost$ 函数吧。

**那么我们就得到了最终的转移方程：**

$$f(t) = \max(f(t - k) + pf(pos, t) - pf(pos, t - k) - cost(pos, t- k))$$

~~好了，恭喜你拿到90分。~~

时间复杂度是 $O(mnp)$，还需要继续优化。 

---

文章开头就已经开门见山的提到了这是一道**单调队列优化的 dp** 了。看到这一大坨可爱的 $t - k$，用单调队列优化它吧。

我们选择枚举每个 $pos$，给每个 $pos$ 都建一个降序的单调队列。先把没有 $k$ 的 $pf(pos, t)$ 丢到外面，把有 $k$ 的合到一起，那么**单调队列维护的就是** $f(t - k) - pf(pos, t- k) - cost(pos, t - k)$ 了。然后就是经典的单调队列优化 dp：

- 直接取队首作为该 $pos$ 的答案。
- 队首越界则弹出。
- 加入新的元素并维护。

这里需要注意一下，由于 $f(t)$ 是在枚举完每个 $pos$ 才取得具体值的，所以需要先枚举完每个 $pos$ 再加入新的元素。弹出队首倒是无所谓。

时间复杂度 $O(mn)$，可以通过了。 

# AC代码

```cpp
#include <bits/stdc++.h>
#define imin INT_MIN
using namespace std;
const int MAXN = 1e3 + 10;

int n, m, p;
int gd[MAXN][MAXN], cst[MAXN], pf[MAXN][MAXN];
int f[MAXN];
deque<int> q[MAXN];

inline int cost(int pos, int t){
    return cst[(pos + t) % n];
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> p;
    for (int i = 0; i < n; i++)
        for (int j = 1; j <= m; j++)
            cin >> gd[i][j];
    for (int i = 0; i < n; i++)
        cin >> cst[i];

    //求前缀和
    for (int pos = 0; pos < n; pos++)
        for (int t = 1; t <= m; t++)
            pf[pos][t] = pf[pos][t - 1] + gd[(pos + t - 1) % n][t];

    //dp边界条件初始化
    f[0] = 0;
    for (int pos = 0; pos < n; pos++)
        q[pos].push_back(f[0] - pf[pos][0] - cost(pos, 0));

    for (int t = 1; t <= m; t++){
        int maxx = imin;
        for (int pos = 0; pos < n; pos++)
            maxx = max(maxx, q[pos].front() + pf[pos][t]);
        f[t] = maxx;
        //注意这里要先求出f[t]再维护单调队列
        for (int pos = 0; pos < n; pos++){
            if (t >= p)
                if (q[pos].front() == f[t - p] - pf[pos][t - p] - cost(pos, t - p)) 
                    q[pos].pop_front();
            while(!q[pos].empty())
                if (q[pos].back() <= f[t] - pf[pos][t] - cost(pos, t)) q[pos].pop_back();
                else break;
            q[pos].push_back(f[t] - pf[pos][t] - cost(pos, t));
        }
    }
    cout << f[m] << '\n';
    return 0;
}
```
这里的 $pos$ 是从 $0$ 开始的，毕竟要处理环，从 $1$ 开始会非常麻烦。

题解里没有具体给出的计算 $cost$ 和计算前缀和时怎么找加哪个数可以看代码。搞几个数手搓一下找找规律就可以了。它们是该题解中唯二需要对环进行处理的部分。

---

## 作者：zaolong (赞：0)

## 解法

考虑动态规划，因为题目的数据较小，所以可以用三层循环进行动态规划。设 $f_i$ 为前 $i$ 分钟获得金币的最优解，用 $s$ 记录前 $i$ 个工厂能获得的金币总和，由题可得以下状态转移方程：
$$f_i=\max(f_i,f_{i-k}+s-c_t)$$
因为马路是环形的，所以还需判断当前是否在 $1$ 工厂右边，如下：

```cpp
if(j-k<=0) t=n+(j-k)%n;
else t=j-k;
```

## AC 代码

一些细节，详见代码。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p,c[1005],f[1005],a[1005][1005],t,ans;
main(){
    cin>>n>>m>>p;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
    		cin>>a[i][j];
    		//i号马路在时间j时的金币数量
		}
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
		//在第i个工厂购买机器人所需的金币 
	}
	for(int i=1;i<=m;i++){
		f[i]=-1e9;
		//因为结果可能是负数，所以初始值需设为极小负数 
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			//设置每个工厂购买机器人所获金币的初始值 
			s=-c[j]+f[i-1];
			for(int k=0;k<p&&i+k<=m;k++){
				//环形马路，所以需要取余 
				if(j+k>n) t=((j+k)%n);
				else t=j+k;
				//动态转移方程 
				s=s+a[t][i+k];
				if(f[i+k]<=s) f[i+k]=s;
			}
		}
	}
	cout<<f[m];
    return 0;
}
```

---


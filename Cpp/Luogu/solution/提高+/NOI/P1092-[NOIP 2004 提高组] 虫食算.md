# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# 题解

## 作者：zzlzk (赞：282)

#### 这个题官方正解是高斯消元，可是我不会啊QAQ。


- 说一下搜索怎么做


- 这个题目第一个难点在于你要理解 $ n $ 进制的加法


-  $ n $ 进制的加法就是在十进制的基础上满十进一改成满$ n $ 进一


- 由于这道题只考虑加法，所以进位只可能是 $ 1 $ ，证明小学生都会，略


- 搜索的大体思路就是从第 $1$ 位的值开始搜，搜到最后一位，判断是否合法


-  考虑剪枝


-  $ 3 $ 个字符串的长度都是 $n$ ，由此可以想到一个最简单的剪枝


-  最高位不能有进位

-  如果有进位，显然第 $3$ 个串的长度不会是 $n$ ，而是$n+1$，这并不合法


-  一个剪枝显然不够啊，再想一个


- 文字不太好描述，我们看图（不会用latex写竖式啊QAQ）


   

   ![qwq](https://i.loli.net/2017/08/22/599bd0b8e5d0b.png)

- 假设这是十进制下的加法，怎么判断这个竖式对不对？


- 显然这个竖式是错误的，因为个位上$ (8+6)  mod 10=4 \not=5$


- 由此推广到每一位，但是还要考虑进位，不慌，看另一张图



   ![qwq](https://i.loli.net/2017/08/22/599bd3642a721.png)

- 这个竖式是对的还是错的？


- 这并不好判断，虽然$ (8+6)  mod 10=4 \not=5$，但是这是中间位，有可能有进位


- 如果有进位， 那么$ (8+6+1)  mod 10=5 $，这一位就是合法的了。


- 综合上面的分析，得到了另一个剪枝方法


- 用 $A$ 和 $B$ 表示两个加数，用 $C$ 表示两个加数的和

- 如果某 $i$ 位，满足$(A[i]+B[i])mod\;n\not=C[i]$ 和 $(A[i]+B[i]+1)mod\;n\not=C[i]$


- 根据上面的分析，这种状态肯定不对，直接 $return$ 就好了


- 或许还有别的剪枝，但是这两个应该够用了


- 我的代码里还用了一个玄学的 $next $ 数组，有什么用照着样例手推一遍就知道了，比较好理解。实在看不懂可以私信我qwq


> 学习科学，实用玄学——某钟姓dalao

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 30
int a[maxn],b[maxn],c[maxn];
int num[maxn],Next[maxn],n,cnt;
char s1[maxn],s2[maxn],s3[maxn];
bool used[maxn];
bool Judge() {
    for(int i=n-1,x=0;i>=0;i--) {
        int A=num[a[i]],B=num[b[i]],C=num[c[i]];
        if((A+B+x)%n!=C) return false;
        x=(A+B+x)/n;
    }
    return true;
}
bool CanPrune() {//prune: 剪枝—百度翻译。
    if(num[a[0]]+num[b[0]]>=n)
        return true;
    for(int i=n-1;i>=0;i--) {
        int A=num[a[i]],B=num[b[i]],C=num[c[i]];
        if(A==-1||B==-1||C==-1) continue;
        if((A+B)%n!=C&&(A+B+1)%n!=C)
            return true;
    }
    return false;
}
void Print() {
    for(int i=0;i<n;i++)
        printf("%d ",num[i]);
    exit(0);
}
void dfs(int x) {
    if(CanPrune()==true) return;
    if(x==n) {
        if(Judge()==true) Print();
        return;
    }
    for(int i=n-1;i>=0;i--)
        if(used[i]==false) {
            num[Next[x]]=i;
            used[i]=true;
            dfs(x+1);
            num[Next[x]]=-1;
            used[i]=false;
        }
    return;
}
inline int id(char c) {
    return c-'A';
}
void GetNext(int x) {
    if(used[x]==false) {
        used[x]=true;
        Next[cnt++]=x;
    }
    return;
}
int main() {
    scanf("%d",&n);
    scanf("%s%s%s",s1,s2,s3);
    for(int i=0;i<n;i++) {
        a[i]=id(s1[i]);
        b[i]=id(s2[i]);
        c[i]=id(s3[i]);
        num[i]=-1;
    }
    for(int i=n-1;i>=0;i--) {
        GetNext(a[i]);
        GetNext(b[i]);
        GetNext(c[i]);
    }
    for(int i=0;i<n;i++) used[i]=false;
    dfs(0);
    return 0;
}
```
代码看不懂也可以问我qwq


---

## 作者：feecle6418 (赞：82)

看了各位大佬的题解，还是不是很理解，于是过了之后决定自己写一个，来帮帮像我一样的蒟蒻吧qwq

好的，进入正题

读完题后，我们第一时间想到的肯定是搜索。如何搜索？一种很显然的~~暴力~~搜索方法为枚举 $0$ 至 $n-1$ 的全排列，然后采用回溯法，边搜索边判断合法性，最后输出结果。

这种方法的思路为：
- 读入数据
- 开始搜索
- 第 $i$ 层搜索第 $i$ 个字母的值（即 ```char(i+'A'-1)```）的值，采用一个```judge```函数判断合法性
- 当搜索完所有字母并且全部合法后，直接输出，退出程序

主要代码如下：
```
char a[30],b[30],c[30];
int t[300],used[30];
int n;
bool ok_(){
    for(int i=n;i>=1;i--){
        if(t[a[i]]==-1||t[b[i]]==-1||t[c[i]]==-1)continue;
        if((t[a[i]]+t[b[i]])%n!=t[c[i]]){
            if((t[a[i]]+t[b[i]]+1)%n!=t[c[i]])return 0;
        }
    }
    return 1;
}
void Try_(){
    int jw=0;
    for(int i=n;i>=1;i--){
        int s=t[a[i]]+t[b[i]]+jw;
        if(t[c[i]]!=s%n)return ;
        jw=s/n;
    }
    cout<<t['A'];
    for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<t[i];
    exit(0);//直接结束程序，头文件"cstdlib"
}
void dfs(int now){
    //产生0到n-1的全排列 
    if(now>n){
        Try_();
        return ;
    }
    for(int i=n-1;i>=0;i--){//注意倒序搜索
        if(used[i])continue;
        t[now+'A'-1]=i;
        if(ok_()){
            used[i]=1;
            dfs(now+1);
            used[i]=0;
        }
    }
    t[now+'A'-1]=-1;
}
```

这样，可以拿到 $50$ 分。

那么如何拿到 $100$ 分呢？

我们发现，```ok_()```函数并没有为我们消除太多的搜索情况。因为搜索顺序是按照字母顺序来搜的，很难碰到三个字母都搜过的情况，因此还不够快。

于是，我们想到了另一个剪枝：改变搜索顺序，从等式的**最低位的字母**开始搜。一位一位往前搜。例如样例
```
ABCED
BDACE
EBBAA
```
我们的搜索顺序即为：```DEACB```。这样便可以获得 $100$ 分。具体代码实现如下：
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<string>
#include<cstdlib>
using namespace std;
char a[30],b[30],c[30];
int t[300],used[30],p[30],u[30],y;
int n;
bool ok_(){
    for(int i=n;i>=1;i--){
        if(t[a[i]]==-1||t[b[i]]==-1||t[c[i]]==-1)continue;
        if((t[a[i]]+t[b[i]])%n!=t[c[i]]){
            if((t[a[i]]+t[b[i]]+1)%n!=t[c[i]])return 0;
        }
    }
    return 1;
}
void Try_(){
    int jw=0;
    for(int i=n;i>=1;i--){
        int s=t[a[i]]+t[b[i]]+jw;
        if(t[c[i]]!=s%n)return ;
        jw=s/n;
    }
    cout<<t['A'];
    for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<t[i];
    exit(0);
}
void dfs(int now){
    //产生0到n-1的全排列 
    if(now>n){
        Try_();
        return ;
    }
    for(int i=n-1;i>=0;i--){
        if(used[i])continue;
        t[p[now]+'A'-1]=i;
        if(ok_()){
            used[i]=1;
            dfs(now+1);
            used[i]=0;
        }
    }
    t[p[now]+'A'-1]=-1;
}
int main(){
    memset(t,-1,sizeof(t));
    scanf("%d",&n);
    scanf("%s%s%s",a+1,b+1,c+1);
    for(int i=n;i>=1;i--){
        if(!u[a[i]-'A'+1])p[++y]=a[i]-'A'+1,u[a[i]-'A'+1]=1;
        if(!u[b[i]-'A'+1])p[++y]=b[i]-'A'+1,u[b[i]-'A'+1]=1;
        if(!u[c[i]-'A'+1])p[++y]=c[i]-'A'+1,u[c[i]-'A'+1]=1;
    }
    dfs(1);
    return 0;
}
```

当然，以上的剪枝仅仅是所有剪枝中的皮毛。限于篇幅，这里不再赘述，有兴趣的读者可以自行优化，给出一些提示：
- ```ok_()```函数是否可以给我们消除更多的情况？比如，已经搜过了两个加数的第 $x$ 位分别值为 $a,b$，但是 $used[(a+b)\ mod\ n]$ 和 $used[(a+b+1)\ mod\ n]$ 都已经为 $true$，那么是不是可以被剪掉？
- 最高位能否有进位？想想为什么？
- ......

---

## 作者：BakaC1rno (赞：20)

以样例为例子，

![](https://cdn.luogu.com.cn/upload/pic/49117.png )

我们可以用未知数x将字母代替，将等式写成这样:

![](https://cdn.luogu.com.cn/upload/pic/49118.png )

其中，r是在字母所代表的值上增加的数，例如D+E=A+r1，此时r1的值是5

将未知数全移动到左边，得到：

![](https://cdn.luogu.com.cn/upload/pic/49116.png )

这样一来，只要我们搜索每个r的值，然后将方程解出来就好了

但是r的值有2的26次方种，运用高斯消元解方程又要26^3次运算，肯定超时了啊，那我们考虑先用高斯消元法表示出每个x，再搜索r的值，最后判断答案是否符合要求就行了

我们用矩阵将系数存起来：

![](https://cdn.luogu.com.cn/upload/pic/49121.png )

经过高斯消元，得到

![](https://cdn.luogu.com.cn/upload/pic/49122.png )

本质上就是
![](https://cdn.luogu.com.cn/upload/pic/49124.png )

然后我们搜索r的值，算出x的值，值得注意的是，ri的初始值取决于r(i-1)的决策，如果r(i-1)保持初始值不变，那么ri的初始值为0，如果r(i-1)在初始值的基础上+n，那么ri的初始值则为-1。那么显然rn不能+n，r1的初始值只能为0。

关于判断答案是否符合要求，看每个x是否小于0，或大于等于n，还要主意不同的字母代表不同的值

代码写得丑，仅供参考

```cpp
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
using namespace std;
int n,lcn,multi,multj;
struct HAHA{
	int coe[30][30];
	int con[30][30];
}squre;
int num[30];

void read()
{
	cin>>n;
	string s1,s2,s3;
	cin>>s1>>s2>>s3;
	for(int i=1;i<=n;i++)
	{
		int pos=n-i;
		int c1=s1[pos]-'A'+1;squre.coe[i][c1]++;
		int c2=s2[pos]-'A'+1;squre.coe[i][c2]++;
		int c3=s3[pos]-'A'+1;squre.coe[i][c3]--;
		squre.con[i][i]=1;
	}	
}

int gcd(int a,int b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}

void gauss()
{
	
	for(int i=1;i<=n;i++)
	{
		int vec=i;
		for(int j=i+1;j<=n;j++) { if(abs(squre.coe[vec][i])<abs(squre.coe[j][i])) vec=j; }
		if(vec!=i)
		{ 
			for(int j=1;j<=n;j++) {swap(squre.coe[i][j],squre.coe[vec][j]);swap(squre.con[i][j],squre.con[vec][j]);}
		}
		for(int j=1;j<=n;j++)
		{
			if(squre.coe[j][i]!=0&&j!=i)
			{
				lcn=squre.coe[j][i]*squre.coe[i][i]/gcd(squre.coe[i][i],squre.coe[j][i]);
				multi=lcn/squre.coe[i][i];
				multj=lcn/squre.coe[j][i];
				for(int k=1;k<=n;k++)
				{
					squre.coe[j][k]=squre.coe[j][k]*multj-squre.coe[i][k]*multi;
					squre.con[j][k]=squre.con[j][k]*multj-squre.con[i][k]*multi;
				}
			}
		}
	}
}

void judge()
{
	bool flag=true;
	int unk[30];
	int dead[30];
	for(int i=0;i<=n;i++) dead[i]=0;
	for(int i=1;i<=n;i++)
	{
		unk[i]=0;
		for(int j=1;j<=n;j++) unk[i]+=squre.con[i][j]*num[j];
		if(unk[i]%squre.coe[i][i]!=0) return;
		else unk[i]/=squre.coe[i][i];
		if(unk[i]<0||unk[i]>=n||dead[unk[i]]==1){flag=false;break;}
		dead[unk[i]]=1;
	}
	if(flag==true)
	{
		for(int i=1;i<=n;i++) cout<<unk[i]<<" ";
		cout<<endl;
		exit(0);
	}
}

void dfs(int pos,int value)
{
	num[pos]=value;
	if(pos==n)
	{
		judge();
		return;
	}
	dfs(pos+1,0);
	num[pos]=value+n;
	dfs(pos+1,-1);
}

int main()
{
	read();
	gauss();
	dfs(1,0);
	return 0;
}
```

---

## 作者：lym2022 (赞：15)

### [题目传送门](https://www.luogu.com.cn/problem/P1092)

这道题我们通过分析（~~标签~~）发现这道题是搜索，考虑深搜。

### 思路
开两个数组，$vis$ 和 $f$，$vis$ 记录当前数字用过几次，$f$ 记录每个字母分别对应哪个数字，因为可选的数字中包含 $0$，所以要把 $f$ 初始化成 $-1$。$s1$ 是最上面的字符串，$s2$ 是中间的，$s3$ 是下面的。

从低到高，枚举字符串的每一位，到第 $i$ 位，先判断当前位之前的是否都是成立的。

枚举 $s1[i]$ 可取哪些数字，记为 $s$，$s$ 的使用次数加 $1$，记录 $f[s1[i]]$ 为 $s$。

枚举 $s2[i]$ 可取哪些数字，记为 $z$，$z$ 的使用次数加 $1$，记录 $f[s2[i]]$ 为 $z$。

当前位的结果 $x$ 为 $s$ 加上 $z$ 再加上一位的进位数 $k$ 除以 $n$，题目说了是 $n$ 进制，不是 $10$ 进制！当前进位数 $nxt$ 为 $s$ 加 $z$ 加 $k$ 取模 $n$，判断是否可行后搜下去。

直到 $i$ 为 $-1$，所有位都搜过了后，判断如果没有进位，就直接输出答案，因为在搜每一位时都已经判断过当前是否成立，输出完后退出程序就好。

注意：在枚举回溯时不要直接将当前数字的使用次数改为 $0$ 次，因为有可能当前的其他字母赋值错误而导致结果错误，之前有些字母的赋值是对的，这样的话直接改为 $0$ 就不对了，所以要记录的是使用次数，而非是否使用。在次数为 $0$ 时说明当前字母的赋值肯定不对，这时将字母赋值改为 $-1$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,f[100],vis[30];      // f 范围超过 ASCII 中 大写 Z 的大小，确保能直接用字符的 ASCII 值当下标，最多 26 个字母，对应 0 到 25 中的数字，vis 超过 26 就行 

string s1,s2,s3;

bool check(int x) {        //当前是第 x 位
	for(int i = x;i>=0;i--) {     //枚举 x 位之前的所有位 
		if(f[s1[i]] != -1 && f[s2[i]] != -1 && f[s3[i]] != -1) {    //如果所有数都填过了 
			int a = f[s1[i]],b = f[s2[i]],c = f[s3[i]];           //记录一下，写判断时好看一些 
			if((a+b) % n != c && (a+b+1) % n != c) return true;   //如果两个加数之和模 n 不为结果，或者加上进位模 n 也不为结果，直接 return 不成立 
		}
	}
	return false;           //当前所有的都成立 
}

void dfs(int i,int k) {
	if(i == -1) {            //搜到头了 
		if(k == 0) {         //不能有进位 
			for(char c = 'A';c<='A'+n-1;c++) cout << f[c] << ' ';     //输出每个字母对应的数字 
			exit(0);         //退出程序 
		}
		return;              //不满足条件就返回 
	}
	if(check(i)) return;         //当前填的数字有问题返回
	for(int s = 0;s<n;s++) {     //枚举每个 s
		if(f[s1[i]] == s || (f[s1[i]] == -1 && vis[s] == 0)) {      //如果这个字母本身填的就是 s，或者它没填并且 s 也没人用 
			vis[s]++;              // s 使用次数加一 
			f[s1[i]] = s;          //s1[i]填的数字为 s 
			for(int z = 0;z<n;z++) {     //枚举每个 z 
				if(f[s2[i]] == z || (f[s2[i]] == -1 && vis[z] == 0)) {      //如果这个字母本身填的就是 z，或者它没填并且 z 也没人用 
					vis[z]++;      // z 使用次数加一 
					f[s2[i]] = z;  //s2[i]填的数字为 z 
					int x = (s + z + k) % n,nxt = (s + z + k) / n;          //计算出 x 是几，进位要进几，是 n 进制 !!!
					if(f[s3[i]] == x || (f[s3[i]] == -1 && vis[x] == 0)) {  //如果这个字母本身填的就是 x，或者它没填并且 x 也没人用
						vis[x]++;  // x 使用次数加一 
						f[s3[i]] = x;  //s3[i]填的数字为 x 
						dfs(i - 1,nxt);  //搜下一位 
						vis[x]--;      //回溯
						if(vis[x] == 0) f[s3[i]] = -1;  //如果 x 的使用次数为 0 了，f[s3[i]] 改为 -1，就是没有数字 
					}
					vis[z]--;          //回溯
					if(vis[z] == 0) f[s2[i]] = -1;      //如果 z 的使用次数为 0 了，f[s2[i]] 改为 -1
				}
			}
			vis[s]--;                  //回溯 
			if(vis[s] == 0) f[s1[i]] = -1;              //如果 s 的使用次数为 0 了，f[s1[i]] 改为 -1
		} 
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> s1 >> s2 >> s3;
	memset(f,-1,sizeof(f));            //初始化为没填数字 
	dfs(n-1,0);                //字符串最低位下标是长度 - 1，没有进位 
	return 0;
} 
```
有什么不恰当的地方请大佬指出，代码有问题可以找我。

---

## 作者：潘德理2010 (赞：4)

### 前言：

这是一篇高斯消元的题解。

感谢 [这篇题解](https://www.luogu.com.cn/article/s9ixgzud) 对我思路的启发。

### 正文：

我们先设字母 `A` 表示 $x_1$，`B` 表示 $x_2$，以此类推。我们再设**从左向右数**第 $i+1$ 位向第 $i$ 位的进位为 $r_i$，$r_i=1$ 表示有进位，$r_i=0$ 表示没有进位。那么，我们不难发现：

一位上两个作为加数的字母对应的数相加，再加上右边一位向这一位的进位，等于这一位上作为结果的字母对应的数，加上这一位向左边一位的进位的 $n$ 倍。据此列出式子，以样例为例：

样例：


```
5
ABCED
BDACE
EBBAA
```

式子：

$$x_1+x_2+r_1=x_5$$
$$x_2+x_4+r_2=x_2+5\times r_1$$
$$x_3+x_1+r_3=x_2+5\times r_2$$
$$x_5+x_3+r_4=x_1+5\times r_3$$
$$x_4+x_5=x_1+5\times r_4$$

变形，得到：

$$1\times x_1+1\times x_2+0\times x_3+0\times x_4+(-1)\times  x_5=-r_1$$
$$0\times x_1+0\times x_2+0\times x_3+1\times x_4+0\times  x_5=5\times r_1-r_2$$
$$1\times x_1+(-1)\times x_2+1\times x_3+0\times x_4+0\times  x_5=5\times r_2-r_3$$
$$(-1)\times x_1+0\times x_2+1\times x_3+0\times x_4+1\times  x_5=5\times r_3-r_4$$
$$(-1)\times x_1+0\times x_2+0\times x_3+1\times x_4+1\times  x_5=5\times r_4$$

下将 $x,r$ 分别作为 $x_1,x_2\dots$ 和 $r_1,r_2\dots$ 的简称。

我们将 $x$ 作为未知数，$r$ 作为参数。将上面式子高斯消元，得到：

$$x_1=-11r_1+7r_2-6r_3+11r_4$$
$$x_2=-6r_1+1r_2+0r_3+5r_4$$
$$x_3=5r_1-1r_2+5r_3-6r_4$$
$$x_4=5r_1-1r_2+0r_3+0r_4$$
$$x_5=-16r_1+8r_2-6r_3+16r_4$$

由于 $r$ 都只能是 $0$ 或 $1$，我们对其取值进行枚举。如果 $x$ 都是 $[0,n)$ 范围内的整数，且互不相同，则满足条件。

注意，如果我们暴力枚举，则时间复杂度会到达 $O(2^n\times n^2)$。我们枚举时，将所有 $r$ 按二进制顺序进行枚举，看当前情况 $r$ 的取值与上一种情况的差异，将上一种情况 $x$ 的取值，加上（或减去）$r$ 的变化带来的差值即可（具体实现请见代码）。这样时间复杂度就可以达到 $O(2^n\times n)$。

考虑到历年 NOIP 真题中也有 $n=1000$ 时，立方级别复杂度的代码能过的，所以认为可以通过。并且本题数据较水，只用了 $50$ 毫秒左右。

代码：


```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(-x)//x 在二进制下的末位 1 
using namespace std;
int n,s[5][30];
char c[5][30];
double a[30][30],b[30][30],r[30][30];//a 对应字母 b 对应参数 r 结果
void pr(){//输出函数，用于代码调试 
	printf("a\n");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%5.1lf ",a[i][j]);
		}
		putchar('\n');
	}
	printf("b\n");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%5.1lf ",b[i][j]);
		}
		putchar('\n');
	}
	printf("r\n");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%5.1lf ",r[i][j]);
		}
		putchar('\n');
	}
}
void cs(int x,int y){//找主元 
	int r=x;
	for(int i=x+1;i<=n;i++){
		if(fabs(a[i][y])>fabs(a[r][y])){
			r=i;
		}
	}
	for(int j=y;j<=n;j++){
		swap(a[r][j],a[x][j]);
	}
	for(int j=1;j<=n;j++){
		swap(b[r][j],b[x][j]);
	}
}
void de(int x,int y){//消去当前主元 
	for(int i=x+1;i<=n;i++){
		double p=-a[i][y]/a[x][y];
		for(int j=y;j<=n;j++){
			a[i][j]+=p*a[x][j];
		}
		for(int j=1;j<=n;j++){
			b[i][j]+=p*b[x][j];
		}
	}
}
void gs(int x,int y){//高斯消元主函数 
	if(y==n+1) return ;
	cs(x,y);
	de(x,y);
	gs(x+1,y+1);
	double res[30];
	memcpy(res,b[x],sizeof(res));
	for(int j=y+1;j<=n;j++){//枚举 未知数 
		for(int i=1;i<=n;i++){//枚举 参数 
			res[i]-=r[j][i]*a[x][j];
		}
	}
	for(int i=1;i<=n;i++){
		res[i]/=a[x][y];
	}
	memcpy(r[y],res,sizeof(res));
}
int main(){
	scanf("%d",&n);//输入 
	for(int i=1;i<=3;i++){
		scanf("%s",c[i]+1);
	}
	for(int i=1;i<=3;i++){//预处理 
		for(int j=1;j<=n;j++){
			s[i][j]=c[i][j]-'A'+1;
		}
	}
	for(int j=n;j>=1;j--){
		for(int i=1;i<=3;i++){
			int u=s[i][j];
			if(i!=3) a[j][u]++;
			else a[j][u]--;
		}
		if(j!=n) b[j][j]--;
		if(j!=1) b[j][j-1]+=n;
	}
	gs(1,1);//高斯消元 
	double rs[30]={};
	for(int i=0;i<(1<<(n-1));i++){//枚举参数，求出答案 
		if(i==0) continue;
		int u=i^(i-1);
		while(lowbit(u)){//找 r 的差异并算出 x 的取值 
			int v=log2(lowbit(u))+1;
			int w=(i>>(v-1))&1;
			if(w==0) w=-1;
			for(int j=1;j<=n;j++){
				rs[j]+=w*r[j][v];
			}
			u-=lowbit(u);
		}
		bool ok=1;
		int ch=0;
		for(int j=1;j<=n;j++){//判断答案合法性 
			if(fabs(rs[j]-round(rs[j]))>1e-8){
				ok=0;
				break;
			}
			int w=round(rs[j]);
			if(w<0||w>n){
				ok=0;
				break;
			}
			if(ch&(1<<w)){
				ok=0;
				break;
			}
			ch|=(1<<w);
		}
		if(!ok) continue;
		for(int j=1;j<=n;j++){
			printf("%d ",int(round(rs[j])));
		}
		return 0;
	}
}
```

---

## 作者：KaguyaH (赞：4)

# [虫食算](https://www.luogu.com.cn/problem/P1092)

- 既然放在试炼场-PJ-深搜里面，就说明深搜可做。

- 考虑深搜。

- 当然是要搜索每个字母代表什么，考虑搜索顺序。

### 按字母顺序搜索

- 暴力枚举所有全排列是O(n!)的。过不去。

- 考虑剪枝。

- 见[这篇题解](https://www.luogu.com.cn/blog/zzlzk/solution-p1092)。

### 按算式顺序搜索

- 竖式计算是从右往左计算的。考虑从右往左依次使每一位的竖式都成立。

- 假设当前为的竖式为

```
	a + b + d = c//d为上次搜索求得的进位。
```

- 若a，b，c均已知
    - 若a + b + d = c
        - 搜索下一位
    - 否则
        - 剪枝
- 若a，b已知
    - 求出c
    - 若c与之前求出的某数相等
        - 剪枝
    - 否则
        - 搜索下一位
- 若仅a已知
    - 枚举b
    - 当作a，b已知来做
- 以此类推。
    

- [231行的代码](https://www.luogu.com.cn/paste/z0fomlrq)。
- 但是TLE了一个点。

- 考虑剪枝。（好吧我承认怎么搜都得剪枝）

- 综合[这篇题解](https://www.luogu.com.cn/blog/zzlzk/solution-p1092)中的剪枝，可以AC。

- [244行的AC代码](https://www.luogu.com.cn/paste/s8cik0k6)。

---

## 作者：Tgotp (赞：3)

\*44ms，算比较快的了吧。

思路如下：

如果知道此列两个数，就可以求第三个数（知二求一嘛！）

然后如果没有满足的条件，就只用管第一列的，这样避免了很多实质性重复的操作。剪短了代码！

然后重点是，每次都要判断当前式子是否成立，如果一列三个都知道的话，且无论进位与否都不满足，就可以直接返回。（很多人90应该就是没想到这）这样的话减少大量的重复性操作。












```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 25 + 2;
char a[N],b[N],c[N];
int num[N],n,k[N];
bool pan[N],ban[N];
bool pd(int i)
{
     while(i--)
     {
         if(pan[a[i]] && pan[b[i]] && pan[c[i]])
         {
             int k=num[a[i]]+num[b[i]];int x=num[c[i]];
             if((k+1)%n==x || k%n==x || (k+n-1)%n==x)continue;
            else return true;
         }
     }
     return false;
}
void dfs(int temp)
{
    if(temp == -1)
    {
        for(int i=0;i<n;i++)printf("%d ",num[i]);
        exit(0);
    } 
    else 
    {
        if(pd(temp))return;
        if(pan[a[temp]] && pan[b[temp]] && pan[c[temp]] )
        {
            if((num[a[temp]]+num[b[temp]]+k[temp])%n == num[c[temp]])
            {
                k[temp-1]+=(num[a[temp]]+num[b[temp]]+k[temp])/n;
                dfs(temp-1);
                k[temp-1]-=(num[a[temp]]+num[b[temp]]+k[temp])/n;
            }
            else return;
        }
        else if(pan[a[temp]] && pan[b[temp]]) 
        {
            if(ban[(k[temp]+num[a[temp]]+num[b[temp]])%n]) return;
            num[c[temp]]=(k[temp]+num[a[temp]]+num[b[temp]])%n;
            ban[num[c[temp]]]=true;
            pan[c[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[c[temp]]=false;
            ban[num[c[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[a[temp]] && pan[c[temp]]) 
        {
            if(ban[(num[c[temp]]+n-k[temp]-num[a[temp]])%n]) return;
            num[b[temp]]=(num[c[temp]]+n-k[temp]-num[a[temp]])%n;
            ban[num[b[temp]]]=true;
            pan[b[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[b[temp]]=false;
            ban[num[b[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[b[temp]] && pan[c[temp]]) 
        {
            if(ban[(num[c[temp]]+n-k[temp]-num[b[temp]])%n]) return;
            num[a[temp]]=(num[c[temp]]+n-k[temp]-num[b[temp]])%n;
            ban[num[a[temp]]]=true;
            pan[a[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[a[temp]]=false;
            ban[num[a[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[a[temp]])
        {
            for(int i=n-1;i>=0;i--)
            {
                if(!ban[i])
                {
                    num[b[temp]]=i; 
                    ban[i]=true;
                    pan[b[temp]]=true;
                    dfs(temp);
                    ban[i]=false;
                    pan[b[temp]]=false;
                }
            }
        }
        else
        {
            for(int i=n-1;i>=0;i--)
            {
                if(!ban[i])
                {
                    num[a[temp]]=i;
                    ban[i]=true;
                    pan[a[temp]]=true;
                    dfs(temp);
                    ban[i]=false;
                    pan[a[temp]]=false;
                }
            }
        }
    } 
} 
int main()
{
    cin>>n;
    scanf("%s%s%s",a,b,c);
    for(int i=0;i<n;i++)
    {
        a[i]-='A';
        b[i]-='A';
        c[i]-='A';
    }
    dfs(n-1);
    return 0;
}
```
/\*
5
ABCED
BDACE
EBBAA
\*/

---

## 作者：Milthm (赞：2)

这题一看没有什么好的算法来解决，但是注意到 $n\le 26$，考虑直接 dfs。

如果我们把要填的三个数当成一个 $3\times n$ 的矩阵，那么我们 dfs 时要记录的是：当前填到的行 $x$，当前填到的列 $y$ 和进位值。

我们从低位向高位 dfs。当我们 dfs 到某个位置，如果这个字母有值，就继续进行下一步 dfs。如果这个位置没有值，我们枚举这个值，填上去进行下一步 dfs。最后判断是否可行即可。

但是这个 dfs 方法显然会 TLE，这个时候就需要我们 dfs 的精髓——剪枝。

我们发现每次到最后再看合不合法很不好，我们想想人类是如何做这种问题的。首先如果你填上一个东西之后该位矛盾了，那你肯定不会继续往下填了，所以这种情况可以直接剪掉。然后如果到某个位置的时候，存在高位的位置虽然没有填满，但已经不合法的情况，也可以剪掉。

如果你不明白这个过程，可以看代码里的注释，解释了整个 dfs 的过程。

这样，我们通过添加适当的剪枝，就可以通过这道题目。


```cpp
#include<iostream>
using namespace std;
int n,p[30],c[30],f;
char a[100][100];
void dfs(int x,int y,int jw){
//x 表示行，y 表示列，jw 表示进位
	if(y==0&&jw==0){
//如果填完了而且没有进位，说明是符合要求的，直接输出并终止程序
		for(int i=0;i<n;++i){
			cout<<p[i]<<" ";
		}
		exit(0);
	}
	if(p[a[x][y]-'A']!=-1){
//如果这个字母已经有代表的值了
		if(x==3){
//这是一个剪枝，如果这一位不满足就 return
			if((p[a[1][y]-'A']+p[a[2][y]-'A']+jw)%n!=p[a[3][y]-'A']){
				return;
			}
//这个和下一个 else 里都是进行下一步 dfs
			dfs(1,y-1,(p[a[1][y]-'A']+p[a[2][y]-'A']+jw)/n);
		}
		else dfs(x+1,y,jw);
	}
	else{
        for(int i=1;i<y;++i){
//这是一个剪枝：枚举比这位高的每一位，如果三个数都已经填上，且无论是否进位都无法满足要求，直接 return
            if(p[a[1][i]-'A']!=-1&&p[a[2][i]-'A']!=-1&&p[a[3][i]-'A']!=-1&&((p[a[1][i]-'A']+p[a[2][i]-'A'])%n!=p[a[3][i]-'A'])&&((p[a[1][i]-'A']+p[a[2][i]-'A']+1)%n!=p[a[3][i]-'A'])){
                return;
            }
        }
		for(int k=0;k<n;++k){
//枚举这一位填什么，p[i] 表示第 i 个字母对应的值，c[i] 表示数字 i 是否有对应字母
			if(p[a[x][y]-'A']==-1&&c[k]==0){
//如果能填
				p[a[x][y]-'A']=k;
				c[k]=1;
				if(x==3){
//这是一个剪枝，如果填上去不满足就 return
					if((p[a[1][y]-'A']+p[a[2][y]-'A']+jw)%n!=p[a[3][y]-'A']){
						p[a[x][y]-'A']=-1;
						c[k]=0;
						continue;
					}
				}
//进行下一步 dfs
				if(x==3){
					dfs(1,y-1,(p[a[1][y]-'A']+p[a[2][y]-'A']+jw)/n);
				}
				else dfs(x+1,y,jw);
//回溯
				p[a[x][y]-'A']=-1;
				c[k]=0;
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i=0;i<n;++i)p[i]=-1;
	for(int i=1;i<=3;++i){
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
		}
	}
	dfs(1,n,0);
	
	return 0;
} 
```

现在已经是新时代了，直接的 dfs 加剪枝也往往不会成为题目的正解，但在骗分这一方面很有用处。

还记得当年刚学 OI 的时候很喜欢 dfs，CSP 前还在研究各种剪枝。如今看着这份两年前的代码，想想两年来一份份喜悦、一个个挫折，令人感慨万千。

---

## 作者：Chen_Johnny (赞：1)

# [NOIP 2004 提高组] 虫食算 题解
看到不会的题目，不用想着每一次去寻找正解，打暴力是最好的选择，这题也是！
## 1. 万物从暴力开始 30pts
我们采用 DFS 对每一个字母代表的值进行枚举，并且再使用后一个函数判断。

显然这个时间复杂度为 $O(n!)$ 能拿 $30$ 分的高分了。
当然，这个代码其实也很短。

## 2. 优化
### 1. 可行性剪枝 50pts
我们发现，其实我们发现其实并不需要在后面再判断这个的可行性。

很简单，我们每完成一整个数位之后，设计函数 $\operatorname {Ok}(i
)$ 可以判断是否满足：$a_i + b_i \equiv c _i \lor a_i + b_i \equiv c_i + 1 \pmod {10}$。

即对进位和不进位两种情况分类讨论。当然，这个并不能保证满足上述条件的字符串一定满足原条件，所以最后还是要设计 $\operatorname {Check} (i)$ 函数进行最后一次检查。

因为数据的原因，这种已经可以做到 $50$ 分了。
### 2. 启发式搜索
我们不难发现其实我们的 $\operatorname {Ok} (i)$ 剪枝函数并没用起到极大的作用，毕竟几乎每一次进行判定的时候，很难会有一整个数位被搜索过了。

因此，我们选择调整计算顺序，在读入的时候，以处于数位后面的作为优先级进行计算，发现其实到了最后，因为前两个数位可以确定第三个数位，所以其实复杂度降到了 $O(n^2)$ 左右，可以 AC。

---

## 作者：Dark__Dream (赞：0)

# 题目大意:
给定一个 $n$ 进制的加法竖式，每个数有 $n$ 位，用英文中的前 $n$ 个字母来表示 $0\sim n-1$ 这 $n$ 个数字，求出每个字母所代表的数字。 
# 题目分析:
观察一眼数据范围，$n$ 不超过 $26$，考虑搜索。
### 朴素做法:
对 $n$ 个数进行全排列，然后进行判断，查看是否符合题目要求，代码实现很简单。预期得分：$30$ 分，实际得分 $40$ 分。代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a,b,c;
int A[30],B[30],C[30];
int p[30],t[30];
int main()
{
	cin>>n;
	cin>>a;
	cin>>b;
	cin>>c;
	for(int i=1;i<=n;i++) t[i]=i-1;
	do
	{
		memset(A,0,sizeof(A));
		memset(B,0,sizeof(B));
		memset(C,0,sizeof(C));
		memset(p,0,sizeof(p));
		int jw=0;
		bool f=1;
		for(int i=0;i<a.size();i++)
			A[i]=t[(int)a[i]-'A'+1];
		for(int i=0;i<a.size();i++)
			B[i]=t[(int)b[i]-'A'+1];
		for(int i=0;i<a.size();i++)
			C[i]=t[(int)c[i]-'A'+1];
		for(int i=a.size()-1;i>=0;i--)
		{
			p[i]=A[i]+B[i]+jw;
			jw=p[i]/n;
			p[i]=p[i]%n;
		}
		for(int i=0;i<a.size();i++)
		if(p[i]!=C[i])
		{
			f=0;
			break;
		}
		if(f)
		{
			for(int i=1;i<=n;i++)cout<<t[i]<<" ";
			return 0;
		}
	}while(next_permutation(t+1,t+n+1));
}
```

### 优化:
考虑剪枝。我们可以发现，对于同一列上的三个数，例如 $x$，$y$，$z$，由于只考虑加法，进位应为 $1$ 或没有进位，那么就可以判断若 $(x+y+1)\bmod n \ne z$ 或 $(x+y)\bmod n \ne z$ 那么就是不合法的，可以剪枝。最高位也不能有进位。另外，我们可以从竖式中最低位的字母开始搜索，一直往前搜。~~代码可以自己码~~。预期得分 $100$ 分，实际得分 $100$ 分。代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b,c;
int ans[270];
bool f[27];
int go[27];
int d[27];
int n;
void dfs(int now)
{
    if(now>n)
	{
		int jw=0;
    	for(int i=n;i>=1;i--)
		{
        	int s=ans[a[i-1]]+ans[b[i-1]]+jw;
        	if(ans[c[i-1]]!=s%n)return ;
        	jw=s/n;
    		}
    	cout<<ans['A'];
    	for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<ans[i];
    	exit(0);
        return ;
    }
    for(int i=n-1;i>=0;i--)
	{
        if(f[i])continue;
        ans[go[now]+'A'-1]=i;
        bool v=1;
		for(int j=n;j>=1;j--)
		{
        	if(ans[a[j-1]]==-1||ans[b[j-1]]==-1||ans[c[j-1]]==-1)
			continue;
			int sum=ans[a[j-1]]+ans[b[j-1]];
        	if(sum%n!=ans[c[j-1]])
			{
            	if((sum+1)%n!=ans[c[j-1]])
				v=0;
        	}
    	}
        if(v){
            f[i]=1;
            dfs(now+1);
            f[i]=0;
        }
    }
    ans[go[now]+'A'-1]=-1;
}
int main()
{
    
    cin>>n;
    cin>>a>>b>>c;
	int cnt=0;
    for(int i=n;i>=1;i--){
        if(!d[a[i-1]-'A'+1])
		{
			go[++cnt]=a[i-1]-'A'+1;
			d[a[i-1]-'A'+1]=1;	
		}
        if(!d[b[i-1]-'A'+1])
		{
			go[++cnt]=b[i-1]-'A'+1;
			d[b[i-1]-'A'+1]=1;
		}
        if(!d[c[i-1]-'A'+1])
		{
			go[++cnt]=c[i-1]-'A'+1;
			d[c[i-1]-'A'+1]=1;
		}
    }
    memset(ans,-1,sizeof(ans));
    dfs(1);
}
```

---


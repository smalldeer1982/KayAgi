# [NOIP2024] 编辑字符串

## 题目描述

小 M 有两个长度为 $n$ 且字符集为 $\{0, 1\}$ 的字符串 $s_1, s_2$。

小 M 希望两个字符串中对应位置字符相同的出现次数尽可能多，即满足 $s_{1,i} = s_{2,i}$ 的 $i(1 \leq i \leq n)$ 尽可能多。为此小 M 有一个字符串编辑工具，这个工具提供的基本操作是在一个字符串中交换两个**相邻**的字符。为了保持字符串的可辨识性，规定两个字符串中的部分字符不能参与交换。小 M 可以用工具对 $s_1$ 或 $s_2$ 进行多次字符交换，其中可以参与交换的字符能够交换任意多次。

现在小 M 想知道，在使用编辑工具后，两个字符串中对应位置字符相同的出现次数最多能有多少。

## 说明/提示

**【样例 1 解释】**

最开始时，$s_1 = \tt{011101}$，第 $4$ 和第 $6$ 个字符不能参与交换；$s_2 = \tt{111010}$，第 $2$ 和第 $5$ 个字符不能参与交换。

考虑如下操作：先交换 $s_{1,1}$ 与 $s_{1,2}$ 得到 $s_1 = \tt{101101}$，再交换 $s_{1,2}$ 与 $s_{1,3}$ 得到 $s_1 = \tt{110101}$，最后交换 $s_{2,3}$ 与 $s_{2,4}$ 得到 $s_2 = \tt{110110}$。此时 $s_1$ 与 $s_2$ 的前 $4$ 个位置上的字符都是相同的。可以证明不存在更好的方案，故输出 $4$。

**【样例 2 解释】**

见附件的 edit/edit2.in 与 edit/edit2.ans。

该样例共有 $10$ 组测试数据，其中第 $i(1 \leq i \leq 10)$ 组测试数据满足数据范围中描述的测试点 $2i - 1$ 的限制。

**【数据范围】**

对于所有的测试数据，保证：$1 \leq T \leq 10$，$1 \leq n \leq 10^5$。

::cute-table{tuack}

| 测试点编号 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $10$ | 无 |
| $5,6$ | $10^3$ | A |
| $7,8$ | $10^5$ | ^ |
| $9,10$ | $10^3$ | B |
| $11,12$ | $10^5$ | ^ |
| $13,14$ | $10^3$ | C |
| $15,16$ | $10^5$ | ^ |
| $17,18$ | $10^3$ | 无 |
| $19,20$ | $10^5$ | ^ |


- 特殊性质 A：保证 $s_1$ 的所有字符相同。
- 特殊性质 B：保证 $t_1 = t_2$。
- 特殊性质 C：保证 $t_1$ 和 $t_2$ 中各自恰有一个字符  $\tt 0$。

## 样例 #1

### 输入

```
1
6
011101
111010
111010
101101```

### 输出

```
4```

# 题解

## 作者：Bingxiu2 (赞：220)

没去 NOIP，今天在学校里某同学告诉我今年 T1 非常难打，他打了 $100$ 多行

所以回来打了一下，$2024/12/3\ 18:09$ 开题，$2024/12/3\ 18:27$ AC

发篇题解~~炫耀一下~~

考虑贪心，从左到右每个字符能匹配就匹配。

显然是对的，因为匹配这一对字符至多会导致后面的一对字符不匹配。

但是很多题解到这一步开始就过于复杂了，各种分段模拟的方法码量都很大。

这里提供一种简单的方法。

考虑预处理两个数组，记录每个字符所在可以交换的连续段（后面简称段）的编号，只要从左往右判断每个字符**和上一个字符**是否可以交换，可以的就和上一个字符在同一段，否则作为一个新段。

再预处理每一段还有多少个没有使用的 $0/1$，同样从左到右把每个字符所在的段对应变量加 $1$ 即可。

然后从左到右，每次判断对应的两个字符 $s_{1,i},s_{2,i}$ 所在段是否有相同的未使用的字符，有的话按照贪心直接取并将使用的字符在对应段的变量 $-1$，否则将对应段还有的字符的变量分别 $-1$。

最后一个细节问题：如果一个字符不能被交换该怎么办？

大部分题解都选择分类讨论，但是这里不用，因为预处理的时候考虑的是和**上一个字符**是否可以交换，所以不能交换的字符在单独的一段中，满足要求。

现在就有一个 $10$ 分钟以内能写完调完的解法了。

[AC Code](https://www.luogu.com.cn/record/192628862)

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans,p[100009],q[100009],e[100009],f[100009],g[100009],h[100009];
string a,b,c,d;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>a>>b>>c>>d,p[0]=q[0]=0,(a[0]&1)?++f[0]:++e[0],(b[0]&1)?++h[0]:++g[0],ans=0;
        for(int i=1;i<n;++i) p[i]=((c[i]&1)&&(c[i-1]&1)?p[i-1]:i),(a[i]&1)?++f[p[i]]:++e[p[i]];
        for(int i=1;i<n;++i) q[i]=((d[i]&1)&&(d[i-1]&1)?q[i-1]:i),(b[i]&1)?++h[q[i]]:++g[q[i]];
        for(int i=0;i<n;++i){
            if(e[p[i]]&&g[q[i]]) ++ans,--e[p[i]],--g[q[i]];
            else if(f[p[i]]&&h[q[i]]) ++ans,--f[p[i]],--h[q[i]];
            else if(e[p[i]]) --e[p[i]],--h[q[i]];
            else --f[p[i]],--g[q[i]];
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```

~~让我看看还有谁抱怨写不完~~

---

## 作者：WaterSun (赞：68)

感谢传奇 NOIP T1 送我彻底退役/wx

一个奶龙的贪心是，把 $t_1,t_2$ 里面 $1$ 的连续段给剖下来，然后有交的段把答案加上 $\min(len,\min(num_{1,0},num_{2,0}) + \min(num_{1,1},num_{2,1}))$，其中 $num_{i,j}$ 表示连续段 $j$ 的出现次数，$len$ 表示两个连续段交的长度。

这个是错的，因为对于有两个交的连续段，可能有不止一种策略。不妨调整一下。

首先发现如果有一段能可能被完全匹配上，则将它匹配完一定不劣，因为这一段所有元素都产生贡献了。所以若有一段被另一段包含，直接匹配完是不劣的。

那么现在每一段最多只与两段有交，且一定至少有一段只与一段有交。对于只与一段有交的策略是唯一的，然后发现消掉一个这样的段就会出现另一个只与一个交的段，一直做下去即可。

不难发现这个东西极度难写，于是 all in t1，大约三小时通过，一个半小时猛拼暴力，最后会 t2 正解没时间，无力回天……

---

## 作者：keatsli (赞：61)

考虑代数化：所求即为 $n-\sum\limits_{i=1}^n(s_{1,i}-s_{2,i})^2=n-\sum\limits_{i=1}^n s_{1,i}^2-\sum\limits_{i=1}^n s_{2,i}^2+2\sum\limits_{i=1}^n s_{1,i}s_{2,i}$。

前三项是定值，故考虑最大化最后一项。

将 $s$ 按是否可以交换分段，对 $s$ 的限制即变为了若干个三元组 $(l_{i,j},r_{i,j},d_{i,j})$ 表示 $s_i$ 中 $[l_{i,j},r_{i,j}]$ 中有 $d_{i,j}$ 个 $1$（因为可以交换，所以只关心连续一段的数量）。

于是可以直接双指针扫一遍 $s_2$ 中的段，从前往后贪心地取 $s_1$ 中的段中的 $1$，因为是从前往后取，故一定不劣（即放弃一个 $1\to 1$ 对最多在未来增加一个 $1\to 1$ 对）。

---

## 作者：_H17_ (赞：54)

依次打开折叠框，提示由浅入深，希望对大家有用。提示框是提示，成功框是提示的答案。

没思路：

:::info
想想什么策略可以匹配的最多。
:::

:::success
显然能匹配尽量匹配。
:::

只有不成熟的想法（上面的内容）：

:::info
注意到有一些固定的位置。好像和不固定的位置形成某种关系？观察一下具体怎么处理。
:::

:::success
不能动的位置把可以移动的位置分成了若干段。
:::

:::info
不能移动的位置怎么当分割点？
:::

:::success
单独组成一段即可。
:::

成功分段的看这里：

:::info
考虑两个段怎么处理？
:::

:::success
你注意到能匹配尽量匹配，比如说这两个段 $0,1$ 数量是 $(5,3),(4,4)$，尽量匹配之后能匹配 $(4,3)$ 个。

证明：如果这里不匹配那到后面匹配贡献不变。

这里给一个参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,ans;
string s1,s2,t1,t2;
vector<tuple<int,int,int,int> >seg1,seg2;
void Main(){
    seg1.clear(),seg2.clear();
    cin>>n>>s1>>s2>>t1>>t2;
    s1=" "+s1,s2=" "+s2,t1=" "+t1,t2=" "+t2;
    ans=0;
    for(int i=1,cnt10=0,cnt11=0,cnt20=0,cnt21=0,lst1=1,lst2=1;i<=n+1;i++){
        if(i==n+1){
            if(lst1!=n+1)
                seg1.push_back(make_tuple(lst1,n,cnt10,cnt11));
            if(lst2!=n+1)
                seg2.push_back(make_tuple(lst2,n,cnt20,cnt21));
            break;
        }
        if(t1[i]=='0'){
            if(lst1!=i)
                seg1.push_back(make_tuple(lst1,i-1,cnt10,cnt11));
            seg1.push_back(make_tuple(i,i,s1[i]=='0',s1[i]=='1'));
            cnt10=cnt11=0,lst1=i+1;
        }
        else
            cnt10+=(s1[i]=='0'),cnt11+=(s1[i]=='1');
        if(t2[i]=='0'){
            if(lst2!=i)
                seg2.push_back(make_tuple(lst2,i-1,cnt20,cnt21));
            seg2.push_back(make_tuple(i,i,s2[i]=='0',s2[i]=='1'));
            cnt20=cnt21=0,lst2=i+1;
        }
        else
            cnt20+=(s2[i]=='0'),cnt21+=(s2[i]=='1');
    }// 分段
    for(int i=0,j=0;i<seg1.size()&&j<seg2.size();){
        auto&[l1,r1,cnt10,cnt11]=seg1[i];
        auto&[l2,r2,cnt20,cnt21]=seg2[j];
        ans+=min(cnt10,cnt20)+min(cnt11,cnt21);//尽量匹配
        if(r1<=r2){
            cnt20-=min(cnt10,cnt20),cnt21-=min(cnt11,cnt21);
            i++;
        }
        if(r1>=r2){
            cnt10-=min(cnt10,cnt20),cnt11-=min(cnt11,cnt21);
            j++;
        }//后续更新剩余
    }
    cout<<ans<<'\n';
    return;
}
int main(){
    for(cin>>T;T;--T)
        Main();
    return 0;
}
```
:::

:::warning
有问题，只有 $60$ 分，输出答案比正确答案大。

思考有什么问题。问题在下面一个框。
:::

:::error
注意到我们只考虑尽量匹配更多的数，但是对于位置区间出现 $[1,5],[3,7]$，这两个段只有 $[3,5]$ 相交。如果两段公共的 $0,1$ 超过长度限制怎么办？

答案在下面。
:::

::::success
我们进行观察，显然不能一个段包含另一个（不然公共部分长度短于短的段，短的段的长度就是公共部分），不相交更不用考虑贡献。显然是 $l_1<l_2\le r_1<r_2$（两个段反过来同理）。

:::info
考虑怎么匹配？匹配 $0/1$ 还是分情况？
:::

:::success
其实你被诈骗了。

你注意到左边的段剩余的比公共部分长，说明前面有位置没匹配上。前面没匹配上有什么条件？至少 $0,1$ 中有一种缺失。

证明：考虑反证法，如果这个段有 $0,1$，那之前没匹配的那一位无论是啥都可以匹配，矛盾！

所以不需要考虑到底匹配哪个，匹配 $0$ 还是匹配 $1$，因为你压根没得选，这个段只会剩一种数，全都和后面尽量匹配即可。

这也是[这篇题解](/article/iicikjuv)在这种情况遇到没匹配的直接匹配就是正确的的原因。

我不知道我是不是讲复杂了，应该没有吧。
:::

::::

于是你切了，发现代码不长。正解代码稍微改改即可，不在给了。

[存档](/article/d62d7xw8)，如果觉得有帮助可以在这个专栏点赞，不知道能不能全站推荐。

---

## 作者：Mingjunyi (赞：39)

因为只有相邻的数能交换，所以，我们将能相邻交换的数融合在一起。

将每个数所在的连通块记录下来，同时记录连通块内 $01$ 的个数。

然后考虑贪心配对，我们可以分讨：
1. 字符串上下都固定，那么直接计算答案。
2. 字符串一边固定，考虑另一边所在连通块内是否含有这个数，如果有，贪心匹配上。
3. 最后考虑两边都不固定，考虑 $00$ 配对或 $11$ 配对。

>一个感性的证明：          
> &emsp; 假设不先让一边固定的数先配对，那么一个不固定的数只能和不固定的数配对，那么你就会消耗两个不固定的数，得到的贡献和与固定的数配对的贡献是一样的，并且会让之后的配对灵活性更低。故先让固定的数配对是不劣的。

赛时代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
char s[N],t[N],a[N],b[N];
int n,pos_s[N],pos_t[N],c[N][2],d[N][2];
void solve(){
    cin>>n;
    cin>>(s + 1);cin>>(t + 1);
    cin>>(a + 1);cin>>(b + 1);
    int cnt = 0;
    memset(c,0,sizeof(c));memset(d,0,sizeof(d));
    memset(pos_s,0,sizeof(pos_s));
    memset(pos_t,0,sizeof(pos_t));
    a[0] = '*';b[0] = '*';
    for(int i = 1;i<=n;i++) {
        if(a[i] != a[i - 1]) pos_s[i] = ++cnt;
        else pos_s[i] = pos_s[i - 1];
        c[pos_s[i]][s[i] - '0']++;
    }
    cnt = 0;
    for(int i = 1;i<=n;i++) {
        if(b[i] != b[i - 1]) pos_t[i] = ++cnt;
        else pos_t[i] = pos_t[i - 1];
        d[pos_t[i]][t[i] - '0']++;
    }
    int ans = 0;
    //判上下都固定的情况和一边固定的情况
    for(int i = 1;i<=n;i++) {
        if(a[i] == '0' && b[i] == '0') {
            if(s[i] == t[i]) 
                ans++;
            continue;
        }else if(a[i] == '0') {
            if(d[pos_t[i]][s[i] - '0']) {
                d[pos_t[i]][s[i] - '0']--;
                ans++;
            }
        }else if(b[i] == '0') {
            if(c[pos_s[i]][t[i] - '0']) {
                c[pos_s[i]][t[i] - '0']--;
                ans++;
            }
        }
    }
    // 最后判断上下都不固定的情况
    for(int i = 1;i<=n;i++) {
        if(a[i] == '1' && b[i] == '1') {
            if(c[pos_s[i]][0] && d[pos_t[i]][0]) {
                c[pos_s[i]][0]--;d[pos_t[i]][0]--;
                ans++;
            }else if(c[pos_s[i]][1] && d[pos_t[i]][1]) {
                c[pos_s[i]][1]--;d[pos_t[i]][1]--;
                ans++;
            }
        }
    }
    cout<<ans<<'\n';
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    freopen("edit.in","r",stdin);
    freopen("edit.out","w",stdout);
    int T;cin>>T;
    while(T--) solve();
	return 0;
}
```
题外话：这道题放T1真的很搞心态，考场想了1h。

---

## 作者：船酱魔王 (赞：16)

题目来源：NOIP 2024 全国统考（仅一试）第一题。

## 题意回顾

两个 0-1 串，有些位置固定，可以任意交换不固定的两个同一个串中的相邻位置，最大化两个串对应位置上相同的字符个数。

字符串长度上限为 $ 10^5 $，单测试点内最多 $ 10 $ 组测试数据，时限 1s，空限 512MB。

## 分析

下文中，称两个字符串为 $ s,t $，$ u,v $ 分别表示 $ s,t $ 对应位置可否移动，说明中下标从 $ 1 $ 开始，实现中从 $ 0 $ 开始（这是因为 `std::string` 的特性）。

### Subtask 1~4（$ n \le 10 $）

首先有一个显然的结论，对于一个序列交换相邻项有限次一定可以排序。

考虑如何将一个序列通过相邻项交换转化为另一个序列？如果两个序列组成元素不同的话那么不可以，否则的话对于目标序列的每个元素依次编号，对于初始序列的每个元素找到这个元素在目标序列中所有编号还没被使用的最小的一个，然后不弱于序列排序问题。

故对于一段不固定位置，可以任意排列其中的字符。

枚举全排列即可，时间复杂度为 $ O((n!)^2) $，剪枝得当应该是能过的（心虚）。

### Subtask 5~8（性质 A：第一个串中所有字符相同）

考虑答案可以转化为，$ \sum_{i=1}^n{[s_i=t_i]} $。

由特殊性质得，答案转化为 $ \sum_{i=1}^n{[s_1=t_i]} $。

直接统计即可。

时间复杂度为 $ O(n) $。

### Subtask 9~12（性质 B：是否固定情况相同）

考虑问题可以转化为，对于若干组可以任意排列的两个等长 0-1 串，将它们分别匹配求出最大匹配个数。

显然，每个串的答案为两串同种出现次数的差值（一一匹配所有 $ 0 $，再一一匹配所有 $ 1 $，没被消耗的即为差值）。

### Subtask 13~16（性质 C：保证两串各仅有一个位置固定）

感觉，不太好打？

也对正解没什么启发意义。

### Subtask 17~20（无特殊性质）

$ O(n^2) $ 有什么简便做法吗？

直接讲正解吧。

考虑暴力子任务的结论，可以任意排列一段连续的可以移动的字符。

那么我们把问题转化为：对于一段连续的可以移动的字符，把他们打成一个包裹放到这段的开头一个字符，对于所有可以移动的字符从包裹中取数最大化匹配次数。

从左到右依次匹配：

* 如果此时两个字符串该位置均为固定，则直接统计答案。
* 如果此时两个字符串位置有一个不固定，那么让不固定的位置去找包裹中是否有与固定位置相同的字符，匹配上去，否则匹配另一个字符。
* 如果此时两个字符串均不固定，那么有相同字符任选一个匹配，否则匹配仅有的字符。

对于情况二，如果可以匹配上而不去匹配，那么这个位置上答案少 $ 1 $，而我们只会多获得一个字符（甚至还要考虑到放置另一个字符的对其的消耗），对答案的贡献最大为 $ 1 $。

对于情况三，如果不能匹配那么只有唯一的放置方案，否则不匹配的证明参见情况二，本质等价。设该位置为 $ s_i=t_i=0 $，则若 $ s_i=t_i $ 更改为 1，那么若答案更优一定存在（不妨设）$ s_j=0 $ 固定，$ t_j $ 由 1 换为 0 ，则存在一个 $ k $ 使得 $ s_k $ 被由 1 换为 0，则此时若 $ t_k $ 原来为 1 则答案一定不会更优，若 $ t_k $ 原来为 0 的话，因为贪心策略的原因 $ i<k<j $，则此时 $ t_p(k<p \le j) $ 一定不能为 1，因为 $ t_k $ 已经属于是被强制匹配。故 $ t_j $ 原来即为 0，与前置条件矛盾。

故贪心策略得证。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;
const int N = 1e5 + 5;
int T;
int n;
string s, t, u, v;
int a[N][2], b[N][2];
int main() {
	cin >> T;
	for(int ti = 1; ti <= T; ti++) {
		cin >> n;
		cin >> s >> t >> u >> v;
		for(int i = 0; i < n; i++) a[i][0] = a[i][1] = b[i][0] = b[i][1] = 0;
		int beg = 0;
		for(int i = 0; i < n; i++) {
			if(u[i] == '0') continue;
			if(i > 0 && u[i - 1] == '0') beg = i;
			a[beg][s[i] - '0']++;
		}
		beg = 0;
		for(int i = 0; i < n; i++) {
			if(v[i] == '0') continue;
			if(i > 0 && v[i - 1] == '0') beg = i;
			b[beg][t[i] - '0']++;
		}
		int c[2] = {0, 0};
		int d[2] = {0, 0};
		int ans = 0;
		for(int i = 0; i < n; i++) {
			c[0] += a[i][0], c[1] += a[i][1], d[0] += b[i][0], d[1] += b[i][1];
			int o = 0;
			if(u[i] == '0' && v[i] == '0') ans += (s[i] == t[i]);
			else if(u[i] == '0') {
				o = s[i] - '0';
				if(d[o] > 0) ans++, d[o]--;
				else d[1 - o]--;
			} else if(v[i] == '0') {
				o = t[i] - '0';
				if(c[o] > 0) ans++, c[o]--;
				else c[1 - o]--;
			} else {
				if(c[0] > 0 && d[0] > 0) c[0]--, d[0]--, ans++;
				else if(c[1] > 0 && d[1] > 0) c[1]--, d[1]--, ans++;
				else {
					if(c[0] > 0) c[0]--;
					if(c[1] > 0) c[1]--;
					if(d[0] > 0) d[0]--;
					if(d[1] > 0) d[1]--; 
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：llamn (赞：16)

本题没那么难。

注意到题面中提到，**相邻**的字符才能交换，所以不能交换的字符会把字符串分割。我们这样把字符串分割，用前缀和分别记录每段中 $0$ 和 $1$ 的数量，并记录每一个位置属于第几段。

然后，一一比较每一个对应字符。   
如果 $t_{1,i} = t_{2,i} = 0$ 直接比较计算答案。   
如果 $t_{1,i} \neq t_{2,i}$ 的话，让能交换的那个字符**优先**把对应字符换到 $i$ 处。这样做正确的原因是：如果有字符不换到 $i$ 处，那么那个字符在另一个地方的贡献最大为 $1$，和在 $i$ 时产生的贡献是相同的。    
最后再用剩下的字符处理剩下的 $t_{1,i} = t_{2,i} = 1$ 的位置。

---

## 作者：SunPanda (赞：13)

[[NOIP2024 T1] 编辑字符串](https://www.luogu.com.cn/problem/P11361)
# 题目分析
给定两个长度为 $ n $ 的 $ 01 $ 数列 $ a,b $ ，其中各有一些位置被锁定。以相邻两个被锁定的位置为端点（不含），构建区间，区间内的内容可以任意交换。求最优交换方案使得两个数列 $ a_i = b_i $ 最多，只需要输出最多的个数即可。


---

可以对数列初始化，统计每个区间内 $ 0 $ 与  $ 1 $ 的数量（被锁定的位置单独开一个长度为 $ 1 $ 的区间），遍历每个 $ i $，若 $ a_i $ 所在区间与 $ b_i $ 所在区间可以给出相同字符，具体地，记 $ a1_i $ 为 $ a_i $ 所在区间 $ 1 $ 的个数，$ a0_i $ 为 $ a_i $ 所在区间 $ 0 $ 的个数，$ b1_i $ 为 $ b_i $ 所在区间 $ 1 $ 的个数，$ b0_i $ 为 $ b_i $ 所在区间 $ 0 $ 的个数，如果 $ a1_i \ne 0 $ 并且 $ b1_i \ne 0 $ ，则 $ a1_i $ 与 $ b1_i $ 都减 $ 1 $ ， $ ans $ 加 $ 1 $ 。如果 $ a1_i $ 与 $ b1_i $ 中有一个等于 $ 0 $ ，则继续判断如果 $ a0_i \ne 0 $ 并且 $ b0_i \ne 0 $ ，则 $ a0_i $ 与 $ b0_i $ 都减 $ 1 $ ， $ ans $ 加 $ 1 $ 。如果以上两条都不满足，则这个位置无法为 $ ans $ 做出贡献。

按照这个规则遍历后，输出 $ ans $ 即可。

# 注意事项
1. **请注意，本题有多组测试数据！**
2. 数列边界也算一个分界点。
3. 本人认为此解正确，并且已过所有样例。

# 代码来啦

```cpp
#include<iostream>
#include<string>
using namespace std;
const int MAX = 100005;

string a, b;
string lock01, lock02;		//谁可以移动谁不行
int t, n;
int save101[MAX];			//字符串a每个小区间内有多少个1
int save001[MAX];			//		a					 0
int save102[MAX];			//		b					 1
int save002[MAX];			//		b					 0
int link01[MAX];			//将a的每个位置联系到他所对应的区间
int link02[MAX];			//  b

int tackle() {
	cin >> n;
	cin >> a >> b >> lock01 >> lock02;
	int index01, index02;
	index01 = index02 = 0;			//当前已经有了多少个小区间
	int aOne, bOne, aZero, bZero;			//目前处理的区间内，每个字符串有几个0几个1
	aZero = bZero = aOne = bOne = 0;
	for (int i = 0; i < n; i++) {
		if (lock01[i] == '1') {		//可以移动
			if (a[i] == '1') {
				aOne++;		//当前区间加一个1
			} else {
				aZero++;	//				0
			}
			link01[i] = index01;		//链接到自己的区间
		} else {					//碰到锁定的位置了
			if (aOne + aZero == 0) {			//上一个区间才长度为0，即无效区间，不予存储
				index01--;			//与下面的index01++抵消
			} else {
				save101[index01] = aOne;			//存储上一个区间的情况
				save001[index01] = aZero;
			}
			aOne = aZero = 0;			//清空上一个区间的数据
			index01++;				//下一个区间（给锁定位置单独开的区间）
			if (a[i] == '1') {			//锁定位置是1
				save101[index01] = 1;
				save001[index01] = 0;
			} else {					//锁定位置是0
				save101[index01] = 0;
				save001[index01] = 1;
			}
			link01[i] = index01;		//锁定位置也要链接到自己的区间呀
			index01++;			//下一个区间喽
		}

		//和上面那块一样的，用于处理b数列
		if (lock02[i] == '1') {
			if (b[i] == '1') {
				bOne++;
			} else {
				bZero++;
			}
			link02[i] = index02;
		} else {
			if (bOne + bZero == 0) {
				index02--;
			} else {
				save102[index02] = bOne;
				save002[index02] = bZero;
			}
			bOne = bZero = 0;
			index02++;
			if (b[i] == '1') {
				save102[index02] = 1;
				save002[index02] = 0;
			} else {
				save102[index02] = 0;
				save002[index02] = 1;
			}
			link02[i] = index02;
			index02++;
		}
	}
	//原数列终点也算区间末尾哦
	save101[index01] = aOne;
	save001[index01] = aZero;
	save102[index02] = bOne;
	save002[index02] = bZero;

	int ans = 0;
	for (int i = 0; i < n; i++) {
		if ((save101[link01[i]] > 0) && (save102[link02[i]] > 0)) {			//判断两个区间是否都能给出1
			ans++;
			save101[link01[i]]--;
			save102[link02[i]]--;
		} else if ((save001[link01[i]] > 0) && (save002[link02[i]] > 0)) {				//是否都能给出0
			ans++;
			save001[link01[i]]--;
			save002[link02[i]]--;
		}
	}
	return ans;		//算完啦
}

int main() {
	//freopen("edit.in","r",stdin);
	//freopen("edit.out","w",stdout);
	cin >> t;
	for (int i = 0; i < t; i++) {
		cout << tackle() << "\n";
	}
}
```
~~点个赞吧~~


---

Upd:2024.12.1-14:55 洛谷民间数据评测时，文章内的代码会出现数组访问越界，但是将 $ MAX $ 开到 $ 10^6 + 6 $ 就可以过了，但是 $ n $ 的范围只有 $ 10^5 $ 。算是此题的一个疑点吧。
Upd:2024.12.3-17:41 本人代码出现错误，导致碰到连续出现的被锁定位置时会浪费一个数组位置，导致极端情况下需要开 $ 2n $ 的数组长度，代码现已纠正为没有空间浪费，数组长度开 $ n $ 。

---

## 作者：Happy_mouse (赞：10)

[AC 记录](https://www.luogu.com.cn/record/192247759)
## 分析与解答
一道非常抽象的题（赛时调了三个小时啊喂……）

### step 1
#### ——全部都可以换的情况
没有该特殊性质，但这是我们的出发点。

显然，为了使不同的最少，将可以凑到一起的尽量凑。两个序列都把所有 $0$ 丢到前面，所有 $1$ 甩到后面是一种最优解（原理显而易见），不同的数量是 $|c_{1,0}-c_{2,0}|$（也可表示为 $|c_{1,1}-c_{2,1}|$），其中 $c_{i,j}$ 指第 $i$个序列中 $j$ 的个数。

### step 2
#### ——特殊性质 B

保证 $t_1=t_2$。

这里分可以换和不可以换两种。

不可以换的位置，直接比，肯定不会改变。

可以换的位置，有一个巧妙的想法：用不可以换的位置，把它们分隔成一段一段的。同一段里随便调顺序，不在一段再怎么调也不能互换，就变成了一个个小型的 `step 1`，累加即可。

### step 3
#### ——特殊性质 C
保证 $t_1$ 和 $t_2$ 中各自恰有一个字符 $0$。

就像下面这样（两个竖杠分别表示两个不能动的点，即 $0$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/0x57rao0.png)

然后将两部分分开：
![](https://cdn.luogu.com.cn/upload/image_hosting/qjvfaoi0.png)

贪心：优先满足短的那部分（$s_{1,1}$），从 $s_{2,1}$ 中扣除（记得同样要计算那个不能动的点），变成 $s_{2,1}'$；如果无法完全满足就计入总数，变成这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/2uqjd5ws.png)

同样优先满足较短的 $s_{2,1}'$，从处于另一段的 $s_{1,2}$ 中扣除。最终对比 $s_{1,2}'$ 和 $s_{2,2}$，累加计算最终答案。

### step 4
#### ——普遍情况

结合 `step 2` 的想法，可以看作多个 `step 3` 组合起来。

不作详细解释，详见代码。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fi first
#define se second
#define ls 2*u
#define rs 2*u+1
#define stps setprecision
#define pb push_back
const int N=1e5+5;
const int mod=1e9+7;
int c[2][2][N],t[2][N],s[2][N],e[2][N];
void solve(){
	//不必初始化，因为算完后 c 数组会重新变回全 0
	//其余的是不需要
	
	//输入
	int n;
	char ch;
	cin>>n;
	for(int j=0;j<2;j++) for(int i=1;i<=n;i++) cin>>ch,s[j][i]=ch-'0';
	for(int j=0;j<2;j++) for(int i=1;i<=n;i++) cin>>ch,t[j][i]=ch-'0';
	
	//分段
	int cnt1=1,cnt2=1,cnt=n;
	//cnt 统计最后结果，cnt1 和 cnt2统计两个序列分别的段数
	//下文的 c[i][j][k] 表示第 i 个序列第 k 段中 j 的个数
	//下文的 e[i][k] 表示第 i 个序列第 k 段的结尾位置
	for(int i=1;i<=n;i++){
		if(t[0][i]) c[0][s[0][i]][cnt1]++;//依旧处于同一段，累加
		else e[0][cnt1++]=i;//不能动了，新建一段，标记上一段的结尾
		//同上
		if(t[1][i]) c[1][s[1][i]][cnt2]++;
		else e[1][cnt2++]=i;
	}
	e[0][cnt1]=e[1][cnt2]=n+1;//最后一段也要标记
	
	//主体
	int wz[2]={0,0};//双指针，分别指着两个序列当前计算的段的位置
	while(wz[0]<cnt1||wz[1]<cnt2){
		//推进指针
		if(e[0][wz[0]]==e[1][wz[1]]) wz[0]++,wz[1]++;//结尾位置相等，即两段都算完了，均推进
		else if(e[0][wz[0]]>e[1][wz[1]]) wz[1]++;//一段算完了，推进
		else wz[0]++;//同理
		//z 记较长的一段
		int z;
		if(e[0][wz[0]]>e[1][wz[1]]) z=0;//由于起点相同，比较结尾即可
		else z=1;
		//分类讨论
		int sz=c[!z][0][wz[!z]]+c[!z][1][wz[!z]];//重合部分大小
		if(c[!z][0][wz[!z]]>c[z][0][wz[z]]){//若小的那段的 0 的个数比大的那段多
			cnt-=c[!z][0][wz[!z]]-c[z][0][wz[z]];//无法保持完全相同，计算
			//进行修改
			c[z][1][wz[z]]-=sz-c[z][0][wz[z]];//为 1 的部分需要献出一部分补充 0 造成的空白
			//同时也相当于扣掉了与另一段的 1 抵消的部分
			c[!z][0][wz[!z]]=c[!z][1][wz[!z]]=c[z][0][wz[z]]=0;//其余项均被用完
		}
		else if(c[!z][1][wz[!z]]>c[z][1][wz[z]]){//若小的那段的 1 的个数比大的那段多
			//同上
			cnt-=c[!z][1][wz[!z]]-c[z][1][wz[z]];
			c[z][0][wz[z]]-=sz-c[z][1][wz[z]];
			c[!z][0][wz[!z]]=c[!z][1][wz[!z]]=c[z][1][wz[z]]=0;
		}
		//注意，上两种情况不会同时出现，所以才可以判断
		//如果小的那段的 0 和 1 的个数均比大的那段多，会导致小的那段长度大于大的那段，矛盾
		else{//保证全部满足
			//修改
			c[z][0][wz[z]]-=c[!z][0][wz[!z]];//0 和 1 分别减去需抵消的部分
			c[z][1][wz[z]]-=c[!z][1][wz[!z]];//0 和 1 分别减去需抵消的部分
			c[!z][0][wz[!z]]=c[!z][1][wz[!z]]=0;//用完了，赋值为 0
		}
		if(wz[0]==cnt1&&wz[1]==cnt2) break;//如果算完了，直接跳出，否则最后一步会算多
		//判结尾那个不能动的数
		//两结尾在同一位置时，即该位置两数均不能动，直接判断
		if(e[z][wz[z]]==e[!z][wz[!z]]) cnt-=(s[z][e[z][wz[z]]]!=s[!z][e[z][wz[z]]]);
		//否则，分类讨论长的那段中是否有多余的部分，拿来对应短的那段的结尾
		//如果可以，就消掉
		else if(c[z][s[!z][e[!z][wz[!z]]]][wz[z]]) c[z][s[!z][e[!z][wz[!z]]]][wz[z]]--;
		//否则累加答案，并用另一种数来占位
		else cnt--,c[z][!s[!z][e[!z][wz[!z]]]][wz[z]]--;
	}
	
	//输出
	cout<<cnt<<'\n';
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//多测
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：Ivan422 (赞：8)

考场思路，代码等 GD 代码公示。

首先我们看到题目，先想有没有什么显然的东西。

发现要是一个点左右两边都是不可交换的，那么我们也可以把这个点标记为不可交换。

接着，我们就可以容易统计出 $t_{1,i}$ 与 $t_{2,i}$ 都为 $0$ 的情况答案，就是所有 $s_{1,i}$ 与 $s_{2,i}$ 字符相同的个数。

接着，还有两种情况需要统计：

1. $t_{1,i}$ 与 $t_{2,i}$ 都为 $1$，即 $t_{1,i}+t_{2,i}=2$。
2.  $t_{1,i}$ 与 $t_{2,i}$ 其中一个为 $1$，即 $t_{1,i}+t_{2,i}=1$。

我们发现，$2$ 类情况可以通过贪心尽可能拼凑出来。即让其中一个 $t_i=1$ 进行交换，让 $s_{1,i}=s_{2,i}$。我们考虑对每一个 $1$ 的连续子串进行统计，统计里面有多少 $s_{i}=0$ 与 $s_{i}=1$，用 $cnt_{0/1,0/1,i}$ 数组来统计。我们令一个块的组长为这个块的第一个数，可以通过简单的方式，跟找最长子段一样，维护 $cnt$ 与 $fa$ 两个数组，可以统计出块内 $0/1$ 以及块编号的信息。

我们考虑如何求 $2$ 类答案。每一次，对于第 $i$ 个位置的调换花费，考虑在 $cnt_{0/1,0/1,fa_i}$ 上进行使用，毕竟一个块内是可以任意排列的，所以可以直接这样标记使用，以此类推，$\mathcal O(n)$ 的预处理，$\mathcal O(n)$ 的求解即可。

最后就是 $1$ 类情况。我们再用刚刚没用完的 $cnt$，剩下的数是不是 $0$ 还是 $1$ 已经不重要了，只要能配对，就是正确的。配对方式一样，最后统计答案即可。

赛场上我用了 $40$ 分钟左右的时间打了个 $76$ 行的严格 $\mathcal O(n)$ 小常数算法，建议绿到蓝左右。

---

## 作者：ZZ_WYZ (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P11361)


---



## 题意理解：

- 交换相邻字符：连续的 $c[i]=1$ 内 $a[i]$ 位置可以任意调换顺序，连续的 $d[i]=1$ 内 $b[i]$ 位置可以任意调换顺序。
- 目标：使对应位置字符尽可能相等。

## 思路：

已知 $a[i]$ 与 $b[i]$ 只有以下三种对应情况：

- $c[i]=d[i]=0$ 时，此时 $a[i]$ 与 $b[i]$ 字符已经锁死，因此只需要比较对应位置字符是否相同即可，如果相同就使 $ans++$。
- $c[i]=d[i]=1$ 时，此时 $a[i]$ 与 $b[i]$ 都不确定，下面会讨论。
- $c[i]=0$，$d[i]=1$ 或 $c[i]=1$，$d[i]=0$ 时，有一个字符确定，要尽量使另一个字符去迎合锁定字符，下面再进行讨论。

现在问题变成了可移动字符应该如何移动？

由于连续的可移动字符可以任意调换顺序，因此可以将连续的可移动字符看作一块。

因此原序列就变成了若干个可调换顺序的字符块与锁定字符的序列。在划分块的时需要记录在当前位置 $i$ 的字符属于哪个可移动块，并且记录当前块有多少个 $1$ 和 $0$。

接下来再考虑如何调换。

首先考虑 $c[i]=0$，$d[i]=1$ 或 $c[i]=1$，$d[i]=0$ 的情况。我们只需要考虑可移动的块内是否拥有当前不可移动的字符。如果有，则使当前可移动块的对应字符个数减 $1$，并使 $ans++$，相当于将这个字符填在了这个位置。

接着考虑 $c[i]=d[i]=1$ 的情况，此时这个位置都在可移动块内，只需分别比对对应块的 $1$ 的个数以及 $0$ 的个数，如果都有 $1$ 或者都有 $0$，就在这个位置填上 $1$ 或者 $0$，并使 $ans++$，两个可移动块对应字符个数分别减 $1$。

至此，问题已经解决，请看代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char a[1145140],b[1145140],c[1145140],d[1145140];
int loca[1145140],locb[1145140];//a[i]与b[i]当前位置为第几块
int blocka[1145140][3],blockb[1145140][3];//记录第某一块的字符0的总数与1的总数 
int main(){
	freopen("edit.in","r",stdin);
	freopen("edit.out","w",stdout);
	cin>>t;
	while(t--){
		int ans=0;//记录答案 
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i];
		for(int i=1;i<=n;i++)cin>>c[i];
		for(int i=1;i<=n;i++)cin>>d[i];
		//输入
		int cnta=1;//cnta记录当前为第几块 
		for(int i=1;i<=n;i++){
			if(c[i]=='1'){
				loca[i]=cnta;//记录当前位置属于哪个块 
				blocka[cnta][a[i]-'0']++;//块内对应字符个数+1 
			}
			if(c[i]=='0'&&c[i-1]=='1'){
				cnta++;//此块已经结束，开一个新块 
			}
		}
		int cntb=1;//b[i]与a[i]同理进行处理 
		for(int i=1;i<=n;i++){
			if(d[i]=='1'){
				locb[i]=cntb;
				blockb[cntb][b[i]-'0']++;
			}
			if(d[i]=='0'&&d[i-1]=='1'){
				cntb++;
			}
		}
		
		for(int i=1;i<=n;i++)if(c[i]=='0'&&d[i]=='0'&&a[i]==b[i])ans++;//当两位置锁定且相同时ans++
		
		for(int i=1;i<=n;i++){
			if(c[i]=='1'&&d[i]=='0'){
				if(blocka[loca[i]][b[i]-'0']!=0){//若当前块存在与锁定字符相同的字符时，将此字符填入 
					blocka[loca[i]][b[i]-'0']--;
					ans++;
				}
			}
			if(c[i]=='0'&&d[i]=='1'){
				if(blockb[locb[i]][a[i]-'0']!=0){//同理
					blockb[locb[i]][a[i]-'0']--; 
					ans++;
				}
			}
		}
		
		for(int i=1;i<=n;i++){
			if(c[i]=='1'&&d[i]=='1'){
				if(blocka[loca[i]][1]!=0&&blockb[locb[i]][1]!=0){
					blocka[loca[i]][1]--;
					blockb[locb[i]][1]--;
					ans++;
				}
				else if(blocka[loca[i]][0]!=0&&blockb[locb[i]][0]!=0){
					blocka[loca[i]][0]--;
					blockb[locb[i]][0]--;
					ans++;
				}
			}
		}
		cout<<ans<<endl;
		
		for(int i=1;i<=n;i++)loca[i]=0,locb[i]=0;
		//多测不清空，亲人两行泪 
		for(int i=1;i<=cnta;i++)blocka[i][0]=0,blocka[i][1]=0;
		//多测不清空，亲人两行泪 
		for(int i=1;i<=cntb;i++)blockb[i][0]=0,blockb[i][1]=0;
		//多测不清空，亲人两行泪
		//重要的事情说三遍 
	}
	return 0;
} 
```

这可能是真正意义上的第一次场切蓝题，但这也可能是最后一场比赛了，珍惜和 OI 在一起的时光吧，继续走下去。

---

## 作者：cff_0102 (赞：5)

这道题给人又贪心又模拟的感觉。可以看出按贪心的方法做，但是不同人的具体实现也不尽相同。下面是我的考场做法。

按 $t$ 中的 $0$ 把 $s$ 分成多块，不难算出每一块中 $0$ 和 $1$ 的数量。

接着配两个指针 $x,y$ 分别从 $s_1$ 和 $s_2$ 的头跳到尾。每次都让靠前的那个指针从前一个块跳到后一个块，顺便处理这两块分界线的不能动的点的答案以及下一块的答案。具体的：

- 首先可以把 ${s_{1,0}}$ 设为 $0$，把 ${s_{2,0}}$ 设为 $1$。把上一块的末尾当成 $0$，这样就不需要特判第一个块的情况了。
- 预处理 $s$ 的前缀和，并把所有 $t_i=1$ 的 $i$ 分别存进两个 vector $v_1,v_2$ 中。
- 接着，将 $x$ 和 $y$ 设为 $0$，就可以开始让它们往后跳了。用四个变量存下当前 $x,y$ 在的块中剩余 $0$ 或 $1$ 的数量，只要 $x$ 和 $y$ 并非都为 $n+1$，就这样操作：
  - 首先需要处理这两块之间的不动点，并将靠前的那个往后跳。
    - 如果 $v_x<v_y$，则将 $x$ 自增 $1$。在自增前，判断 $s_{v_x}$ 在当前 $y$ 所在的块是否还存在。如果还存在就把其中之一交换过来；如果没有只能把另一种数放到这里了。
    - 否则，如果 $v_y<v_x$，则将 $y$ 自增 $1$。在自增前，判断 $s_{v_y}$ 在当前 $x$ 所在的块是否还存在。如果还存在就把其中之一交换过来；如果没有只能把另一种数放到这里了。
    - 否则，$v_x=v_y$，判断 $s_{v_x}$ 和 $s_{v_y}$ 的关系并存进答案中。然后让 $x,y$ 都往后跳一次。
  - 往后跳之后，就可以处理这两块之间的问题了。
    - 先让当前 $x,y$ 所在块的 $1$ 和 $0$ 匹配，直到两个块中至少有一个块不再有 $1$，至少有一个块不再有 $0$，即不能再匹配了。
    - 接着，如果更靠前的那块还没到头，说明这一块还剩下一堆 $0$（或 $1$），它只可能匹配到另一个字符串的当前块的 $1$（或 $0$）了。把这些从剩余数量里扣掉，记得此时不能累加进答案里。
    - 现在就又处理完一块了。那么就可以回到循环开头，重新匹配。
- 结束之后，输出答案。

至于为什么这样贪心是正确的：

就像上面所说，按照这样的方法匹配，两个字符串一定会有一边不再有 $1$，有一边（可以是同一边）不再有 $0$，即不能再匹配了。
- 如果此时某一边的 $0$ 和 $1$ 都花完了，显然这样匹配尽量利用到了两边的 $0$ 和 $1$。即使可能另一边匹配这边的下一块时会出现匹配不够的问题，但是这样这些 $0$ 或 $1$ 在哪里匹配又有什么关系呢？反正匹配过去是不够的，也就是这一块的所有 $1$ 会和另一边匹配完了，那么不如全部放到前面去匹配。因此在这种情况下把现在的所有 $0$ 和 $1$ 匹配完的贪心方法是没有问题的。
- 如果此时一边剩一些 $0$，另一边剩一些 $1$，也没什么好说的，一边把所有 $1$ 已经在前面用完了，你换到后面来也没办法增加匹配个数吧。另一边也是一样的，这个时候只能把剩下的 $0$ 和 $1$ 往后堆，直到其中一边花完，碰到另一个区间。

~~一个更显然的贪心“证明”为：如果这题贪心是错解，还能放 NOIP T1 吗~~？

因此只需要像上文所说的方法模拟即可。

[代码，以及可能会有一些题解内容的补充](/paste/zjugjipe)。

---

## 作者：ykzzldz (赞：4)

由题目可知，如果 $t$ 中的一段区间均为 $1$，那么 $s$ 串中对应的区间可以任意排列。我们称一个由连续 $1$ 构成的极长区间为一段，那么，我们可以预先处理出每一段的 $0$ 和 $1$ 的个数。从左往右考虑每个位置，如果 $t_{1,i}=t_{2,i}=0$，那么直接统计答案。如果 $t_{1,i}=0,t_{2,i}=1$，我们可以考虑能否让这个位置产生贡献，即：能不能让 $s_{2,i}=s_{1,i}$。具体地，我们看 $t_2$ 中的这一段是否还剩下至少一个 $s_{1,i}$，如果是，我们可以将这个东西移到 $i$ 位置，产生贡献。匹配完后，需要将这一段中 $s_{1,i}$ 的数量减一，否则往后继续匹配。$t_{1,i}=1,t_{2,i}=0$ 的做法类似。由于每个位置的贡献只能为 $0$ 或 $1$，所以直接将其移到当前位置的贪心是正确的。

现在，我们只需要考虑 $t_{1,i}=t_{2,i}=1$ 的情况（注意，考虑这种情况时，已经将其他三种情况考虑完，也就是说，这种情况需要另外使用一次循环完成），由于每个位置贡献至多为 $1$，所以我们直接看相应的两段是否能贡献出相同的元素（这个元素是任意的），若能贡献，则直接进行贡献，随后将两段减去这个元素。下面给出考场代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int T,n,cnt0[2][N],cnt1[2][N],num1,num2,id[2][N];
char s1[N],s2[N],t1[N],t2[N];
signed main(){
    cin>>T;
    while(T--){
        memset(cnt0,0,sizeof cnt0);
        memset(cnt1,0,sizeof cnt1);
        num1=num2=0;
        cin>>n>>s1+1>>s2+1>>t1+1>>t2+1;
        for(int i=1;i<=n;i++){
            if((i==1&&t1[i]=='1')||(t1[i]=='1'&&t1[i-1]=='0')){
                num1++;
            }
            if(t1[i]=='1'){
                id[0][i]=num1;
                if(s1[i]=='0')cnt0[0][num1]++;
                else cnt1[0][num1]++;
            }
            if((i==1&&t2[i]=='1')||(t2[i]=='1'&&t2[i-1]=='0')){
                num2++;
            }
            if(t2[i]=='1'){
                id[1][i]=num2;
                if(s2[i]=='0')cnt0[1][num2]++;
                else cnt1[1][num2]++;
            }
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            if(t1[i]=='0'&&t2[i]=='0'){
                ans+=(s1[i]==s2[i]);
            }
            if(t1[i]=='1'&&t2[i]=='0'){
                if(s2[i]=='0'){
                    if(cnt0[0][id[0][i]]){
                        cnt0[0][id[0][i]]--;
                        ans++;
                    }
                    else cnt1[0][id[0][i]]--;
                }
                else{
                    if(cnt1[0][id[0][i]]){
                        cnt1[0][id[0][i]]--;
                        ans++;
                    }
                    else cnt0[0][id[0][i]]--;
                }
            }
            if(t2[i]=='1'&&t1[i]=='0'){
                if(s1[i]=='0'){
                    if(cnt0[1][id[1][i]]){
                        cnt0[1][id[1][i]]--;
                        ans++;
                    }
                    else cnt1[1][id[1][i]]--;
                }
                else{
                    if(cnt1[1][id[1][i]]){
                        cnt1[1][id[1][i]]--;
                        ans++;
                    }
                    else cnt0[1][id[1][i]]--;
                }
            }
        }
        for(int i=1;i<=n;i++){
            if(t1[i]==t2[i]&&t1[i]=='1'){
                if(cnt0[0][id[0][i]]&&cnt0[1][id[1][i]]){
                    cnt0[0][id[0][i]]--;
                    cnt0[1][id[1][i]]--;
                    ans++;
                }
                else if(cnt1[0][id[0][i]]&&cnt1[1][id[1][i]]){
                    cnt1[0][id[0][i]]--;
                    cnt1[1][id[1][i]]--;
                    ans++;
                }
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：ThySecret (赞：4)

## Pre

怎么都说 T1 好想但难调啊，简单贪心 + 小模拟评蓝还是太高了，这里就给出一种好写又好调的并查集做法。

## Solution

根据题意可知，$t_{k, i} = 1(k \in \{ 1, 2\}, 1 \le i \le n)$ 的连续的 $i$ 所代表的 $s_{k, i}$ 之间可以任意互换，换句话说，字符串 $t_k$ 将 $s_k$ 分割成了若干个连通块，属于同一个连通块中的不同字符可以互换，但应当保持 $\{ 0, 1\}$ 的个数不变。然后一个贪心的思路呼之欲出了：

> 从左往右遍历到第 $i$ 个字符时，如果 $s_{1, i}$ 和 $s_{2, i}$ 所处的连通块中存在个数大于 $0$ 的字符 $0 / 1$ 时，就将匹配数加一，同时将该字符在连通块中的计数减少一；否则匹配数不变化，连通块中字符数量不为 $0$ 的计数减少一。

贪心比较显然，毕竟每个下标对于答案产生的贡献只有 $0$ 或 $1$ 两种，面临抉择时肯定是先选择后者。至于如果匹配失败删去两个连通块中剩余的字符个数，是因为此时两个连通块中一定存在一个字符数量为 $0$，而另一个不为 $0$，而这个位置必须有数，因此各删去一个。

关于并查集的具体做法：分别给 $s_1$ 和 $s_2$ 建一个并查集，维护好每一个连通块中 $0$ 和 $1$ 的数量。一旦有 $t_{k, i} = t_{k, i - 1} = 1 (k \in \{ 1, 2\}, 1 \lt i \le n)$，就将这两个字符所在连通块合并起来。

细节详见代码，单次时间复杂度为 $O(n \times \alpha(n) )$。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

// #define int long long
// #define x first
// #define y second
#define File(a) freopen(a".in", "r", stdin), freopen(a".out", "w", stdout)

inline void debug() { cerr << '\n'; }
template<typename Type, typename... Args>
inline void debug(const Type& x, const Args&... y) { cerr << x << ' ', debug(y...); }
#define DEBUG(a...) { cerr << "[" << #a << "] = ", debug(a); }

typedef long long LL;
typedef pair<int, int> PII;

const int N = 100010;
const int INF = 0x3f3f3f3f;

template<typename Type>
inline void read(Type& res)
{
    res = 0;
    int ch = getchar(), flag = 0;
    while (!isdigit(ch)) flag |= ch == '-', ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    res = flag ? -res : res;
}
template<typename Type, typename... Args>
inline void read(Type& res, Args&... y) { read(res), read(y...); }

int n;
char str[N];
int s[2][N], t[2][N];
int pre[2][N], cnt[2][N][2];

int rt(int k, int x) { return pre[k][x] == x ? x : pre[k][x] = rt(k, pre[k][x]); }

inline void merge(int k, int x, int y)
{
    int px = rt(k, x), py = rt(k, y);
    if (px == py) return;
    pre[k][py] = px, cnt[k][px][0] += cnt[k][py][0], cnt[k][px][1] += cnt[k][py][1];
}

void solve()
{
    for (int k = 0; k < 2; k ++)
        for (int i = 0; i < N; i ++)
            pre[k][i] = i, cnt[k][i][0] = cnt[k][i][1] = 0;

    read(n);
    for (int k = 0; k < 2; k ++)
    {
        scanf("%s", str + 1);
        for (int i = 1; i <= n; i ++)
        {
            s[k][i] = str[i] == '1';
            cnt[k][i][s[k][i]] = 1;
        }
    }
    for (int k = 0; k < 2; k ++)
    {
        scanf("%s", str + 1);
        for (int i = 1; i <= n; i ++)
        {
            t[k][i] = str[i] == '1';
            if (t[k][i] == 1 && t[k][i - 1] == 1)
                merge(k, i - 1, i);
        }
    }

    int ans = 0;
    for (int cur = 1, i = rt(0, cur), j = rt(1, cur); cur <= n; cur ++, i = rt(0, cur), j = rt(1, cur))
    {
        if (cnt[0][i][0] > 0 && cnt[1][j][0] > 0) ans ++, cnt[0][i][0] --, cnt[1][j][0] --;
        else if (cnt[0][i][1] > 0 && cnt[1][j][1] > 0) ans ++, cnt[0][i][1] --, cnt[1][j][1] --;
        else
        {
            if (cnt[0][i][0] > 0) cnt[0][i][0] --, cnt[1][j][1] --;
            else cnt[0][i][1] --, cnt[1][j][0] --;
        }
    }
    cout << ans << '\n';
}

signed main()
{
    File("edit");
    int T; read(T);
    while (T --) solve();
    return 0;
}
```

---

## 作者：wbh20090611 (赞：4)

### 主要思路

#### 算法

+ 贪心
+ 前缀和

#### 具体思路

- 以每个 `0` 作为端点分出区间。
- 在每个区间内做后缀和，相当于把区间内的所有数全部用交换堆到第一个数上，在一个一个放回来。
- 不难看出：在既可以放 `1` 也可以放 `0` 时，总贡献是一样的，因此，随便去一个即可。

### 代码实现

考场上写了 100 多行的代码，现在重新打过了：


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int T, n, cnt1[N][3], cnt2[N][3], a[3], b[3], ans;
char s1[N], s2[N], s3[N], s4[N];
int main()
{
	freopen("edit.in","r",stdin);
	freopen("edit.out","w",stdout);
	cin >> T;
	while(T--)
	{
		scanf("%d%s%s%s%s", &n, s1 + 1, s2 + 1, s3 + 1, s4 + 1);
		s3[0] = s4[0] = s3[n + 1] = s4[n + 1] = '0';
		// 记得清零 
		memset(cnt1, 0, sizeof cnt1);
		memset(cnt2, 0, sizeof cnt2);
		for (int i = 1; i <= n; i++) // 特判，要是左右都是零，自己自然也动不了 
		{
			if (s3[i - 1] == s3[i + 1] && s3[i - 1] == '0')
				s3[i] = '0';
			if (s4[i - 1] == s4[i + 1] && s4[i - 1] == '0')
				s4[i] = '0';
		}
		// 求每个连续 '1' 区间内的后缀和 
		for (int i = n; i > 0; i--)
		{
			if (s3[i] == '1')
				if (s3[i + 1] != '0')
					cnt1[i][0] = cnt1[i + 1][0],
					cnt1[i][1] = cnt1[i + 1][1],
					cnt1[i][s1[i] - '0']++;
				else
					cnt1[i][s1[i] - '0'] = 1;
			if (s4[i] == '1')
				if (s4[i + 1] != '0')
					cnt2[i][0] = cnt2[i + 1][0],
					cnt2[i][1] = cnt2[i + 1][1],
					cnt2[i][s2[i] - '0']++;
				else
					cnt2[i][s2[i] - '0'] = 1;
		} 
		a[0] = cnt1[1][0];
		a[1] = cnt1[1][1];
		b[1] = cnt2[1][1];
		b[0] = cnt2[1][0];
		ans = 0;
		// 使用计数器 a, b 记录后缀和 
		for (int i = 1; i <= n; i++)
		{
			if (s3[i] == '0' && s4[i] == '0') // 两个都是边界 
			{
				//直接把计数器 a, b 改成下一个点的后缀和 
				a[0] = cnt1[i + 1][0];
				a[1] = cnt1[i + 1][1];
				b[0] = cnt2[i + 1][0];
				b[1] = cnt2[i + 1][1];
				if (s1[i] == s2[i]) //相同就累计答案 
					ans++;
			}
			else if (s3[i] == '0')
			{
				a[0] = cnt1[i + 1][0];
				a[1] = cnt1[i + 1][1];
				if (b[s1[i] - '0'] > 0)
					b[s1[i] - '0']--, ans++;
			}
			else if (s4[i] == '0')
			{
				b[0] = cnt2[i + 1][0];
				b[1] = cnt2[i + 1][1];
				if (a[s2[i] - '0'] > 0)
					a[s2[i] - '0']--, ans++;
			}
			else
			{
				if (a[0] > 0 && b[0] > 0)
					ans++, a[0]--, b[0]--;
				else if (a[1] > 0 && b[1] > 0)
					ans++, a[1]--, b[1]--;
			}
		}
		printf("%d\n", ans);
	}
	fclose(stdin);
	fclose(stdout);
	return 0; // 这是个好习惯，特别是到了比赛的时候 
}
```

---

## 作者：guoziyang21 (赞：3)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P11361)

有两个长为 $ n $ 的`01`字符串 $ s_1,s_2 $，现在要对这两个字符串进行操作，每次可以交换相邻的两个字符，有一些位置的字符无法被操作。希望经过若干次操作后，对应位置字符相同的出现次数尽可能多，求出这个最多的出现次数。

# 思路

非常可惜这题在赛时想到了思路可是没写完（先去写T2了），回家后按照思路重写，已通过大样例和民间数据。

---

我们考虑无法被修改的本质：不就是把原字符串划分为三段吗？各段之间无法操作，但每段内可以随意操作。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9oe2ealz.png)

于是我们可以通过 $ t_1,t_2 $ 把 $ s_1,s_2 $ 划分为若干段。

注意：下文中会出现“段”，请留意“段”在此的定义，下文不做解释。

---

为帮助大家更好的看懂本题解，先在此声明一个事实（不做证明）：

> 任何两个长度相等`01`字符串，只要它们含有`0`和`1`的个数分别相等，那么他们可以只通过交换相邻字符的操作从一个变为另一个。

---

我们提出一个贪心策略：尽可能多地往前对齐字符。

形象化地，我们用样例来演示一遍（下文均默认字符串下标从 $ 0 $ 开始）：

1. 起始状态；

   ![](https://cdn.luogu.com.cn/upload/image_hosting/9w3nt7l4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
   
2. 将 $ s_1 $ 的 $ [0,2] $ 中挪一个`1`与 $ s_2 $ 的 $ [0,0] $ 对齐；
3. 将 $ s_1 $ 的 $ [1,2] $ 中挪一个`1`与 $ s_2 $ 的 $ [1,1] $ 对齐；

   ![](https://cdn.luogu.com.cn/upload/image_hosting/8ps01p3g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4. 将 $ s_2 $ 的 $ [2,3] $ 中挪一个`0`与 $ s_1 $ 的 $ [2,2] $ 对齐；
5. $ s_1 $ 和 $ s_2 $ 的 $ 3 $ 对齐，$ 4,5 $ 无法对齐，操作结束，答案为 $ 4 $。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/s9pgcgo5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

# 实现

我们用 $ a_i,b_i $ 表示 $ s_1 $ 中从 $ i $ 的位置到其所在段末尾`0`和`1`的个数，$ c_i,d_i $ 表示 $ s_2 $ 中从 $ i $ 的位置到其所在段末尾`0`和`1`的个数。

计算 $ a_i,b_i,c_i,d_i $ 的核心代码：

```cpp
for(int i=n-1;i>=0;--i){
	if(s1[i]=='0'){
		a[i]=a[i+1]*(t1[i]-'0')*(t1[i+1]-'0')+1;
		b[i]=b[i+1]*(t1[i]-'0')*(t1[i+1]-'0');
	}
	else{
		a[i]=a[i+1]*(t1[i]-'0')*(t1[i+1]-'0');
		b[i]=b[i+1]*(t1[i]-'0')*(t1[i+1]-'0')+1;
	}
	if(s2[i]=='0'){
		c[i]=c[i+1]*(t2[i]-'0')*(t2[i+1]-'0')+1;
		d[i]=d[i+1]*(t2[i]-'0')*(t2[i+1]-'0');
	}
	else{
		c[i]=c[i+1]*(t2[i]-'0')*(t2[i+1]-'0');
		d[i]=d[i+1]*(t2[i]-'0')*(t2[i+1]-'0')+1;
	}
}
```

接着进行贪心，我们设置一个指针 $ i $，然后将 $ i $ 以一定的跨度向后移动：

```cpp
int i=0;
while(i<n){
	//统计ans并移动i 
}
```

`while`内分三类进行讨论：

* $ a_i+b_i=c_i+d_i=k $：这其实就是特殊性质B。我们对区间 $ [i,i+k-1] $ 进行统计。不妨设 $ a_i\ge c_i $，经过适当的操作后，将会有 $ c_i $ 个`1`和 $ b_i $ 个`0`会对齐，此时 $ ans $ 增加 $ c_i+b_i $。一般地，不考虑 $ a_i $ 与 $ c_i $ 的大小关系，则 $ ans $ 会增加 $ k-|a_i-c_i| $。然后将指针 $ i $ 移动到 $ i+k $。
```cpp
if(a[i]+b[i]==c[i]+d[i]){
	ans+=a[i]+b[i]-abs(a[i]-c[i]);
	i+=a[i]+b[i];
}
```
* $ a_i+b_i>c_i+d_i=k $：对区间 $ [i,i+k-1] $ 进行统计。
  * $ a_i\ge c_i $ 且 $ b_i\ge d_i $：将 $ s_1 $ 的 $ [i,i+a_i+b_i-1] $ 的 $ a_i $ 个`0`中的 $ c_i $ 个和 $ b_i $ 个`1`中的 $ d_i $ 个移到 $ [i,i+k-1] $ 中。此时会有 $ c_i $ 个`0`和 $ d_i $ 个`1`对齐，$ ans $ 增加 $ k $，指针 $ i $ 移动到 $ i+k $。
  * $ a_i\ge c_i $ 且 $ b_i< d_i $：将 $ s_1 $ 的 $ [i,i+a_i+b_i-1] $ 的 $ a_i $ 个`0`中的 $ c_i+d_i-b_i $ 个和 $ b_i $ 个`1`移到 $ [i,i+k-1] $ 中。此时会有 $ c_i $ 个`0`和 $ b_i $ 个`1`对齐，$ ans $ 增加 $ c_i+b_i $，指针 $ i $ 移动到 $ i+k $。
  * $ a_i<c_i $ 且 $ b_i\ge d_i $：同上。
```cpp
if(a[i]+b[i]>c[i]+d[i]){
	tmp=i+c[i]+d[i];
	if(a[i]>=c[i]&&b[i]>=d[i]){
		ans+=c[i]+d[i];
		a[tmp]=a[i]-c[i];
		b[tmp]=b[i]-d[i];
	}
	else if(a[i]>=c[i]){
		ans+=c[i]+b[i];
		a[tmp]=a[i]-(c[i]+d[i]-b[i]);
		b[tmp]=0;
	}
	else if(b[i]>=d[i]){
		ans+=a[i]+d[i];
		b[tmp]=b[i]-(d[i]+c[i]-a[i]);
		a[tmp]=0;
	}
	i=tmp;
}
```
* $ k=a_i+b_i<c_i+d_i $：同上。
```cpp
if(a[i]+b[i]<c[i]+d[i]){
	tmp=i+a[i]+b[i];
	if(c[i]>=a[i]&&d[i]>=b[i]){
		ans+=a[i]+b[i];
		c[tmp]=c[i]-a[i];
		d[tmp]=d[i]-b[i];
	}
	else if(c[i]>=a[i]){
		ans+=a[i]+d[i];
		c[tmp]=c[i]-(a[i]+b[i]-d[i]);
		d[tmp]=0;
	}
	else if(d[i]>=b[i]){
		ans+=c[i]+b[i];
		d[tmp]=d[i]-(b[i]+a[i]-c[i]);
		c[tmp]=0;
	}
	i=tmp;
}
```
统计完后输出 $ ans $ 即可。

# 代码

```cpp
# include<iostream>
# include<string>
# include<cmath>
using namespace std;

const int N=1e5+2;
int t,n,a[N],b[N],c[N],d[N],ans,tmp;
string s1,s2,t1,t2;

void solve(){
	cin>>n>>s1>>s2>>t1>>t2;
	ans=a[n]=b[n]=c[n]=d[n]=0;
	for(int i=n-1;i>=0;--i){
		if(s1[i]=='0'){
			a[i]=a[i+1]*(t1[i]-'0')*(t1[i+1]-'0')+1;
			b[i]=b[i+1]*(t1[i]-'0')*(t1[i+1]-'0');
		}
		else{
			a[i]=a[i+1]*(t1[i]-'0')*(t1[i+1]-'0');
			b[i]=b[i+1]*(t1[i]-'0')*(t1[i+1]-'0')+1;
		}
		if(s2[i]=='0'){
			c[i]=c[i+1]*(t2[i]-'0')*(t2[i+1]-'0')+1;
			d[i]=d[i+1]*(t2[i]-'0')*(t2[i+1]-'0');
		}
		else{
			c[i]=c[i+1]*(t2[i]-'0')*(t2[i+1]-'0');
			d[i]=d[i+1]*(t2[i]-'0')*(t2[i+1]-'0')+1;
		}
	}
	int i=0;
	while(i<n){
		if(a[i]+b[i]==c[i]+d[i]){
			ans+=a[i]+b[i]-abs(a[i]-c[i]);
			i+=a[i]+b[i];
		}
		else if(a[i]+b[i]>c[i]+d[i]){
			tmp=i+c[i]+d[i];
			if(a[i]>=c[i]&&b[i]>=d[i]){
				ans+=c[i]+d[i];
				a[tmp]=a[i]-c[i];
				b[tmp]=b[i]-d[i];
			}
			else if(a[i]>=c[i]){
				ans+=c[i]+b[i];
				a[tmp]=a[i]-(c[i]+d[i]-b[i]);
				b[tmp]=0;
			}
			else if(b[i]>=d[i]){
				ans+=a[i]+d[i];
				b[tmp]=b[i]-(d[i]+c[i]-a[i]);
				a[tmp]=0;
			}
			i=tmp;
		}
		else{
			tmp=i+a[i]+b[i];
			if(c[i]>=a[i]&&d[i]>=b[i]){
				ans+=a[i]+b[i];
				c[tmp]=c[i]-a[i];
				d[tmp]=d[i]-b[i];
			}
			else if(c[i]>=a[i]){
				ans+=a[i]+d[i];
				c[tmp]=c[i]-(a[i]+b[i]-d[i]);
				d[tmp]=0;
			}
			else if(d[i]>=b[i]){
				ans+=c[i]+b[i];
				d[tmp]=d[i]-(b[i]+a[i]-c[i]);
				c[tmp]=0;
			}
			i=tmp;
		}
	}
	cout<<ans<<endl;
}

int main(){
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：Cure_Wing (赞：3)

[P11361 [NOIP2024] 编辑字符串](https://www.luogu.com.cn/problem/P11361)

### 解析

首先简单的一个转化，交换相邻的两个字符等价于一个区间内的字符任意重新排列。

那么我们考虑 $s_1,s_2$ 中第一个不能交换的位置 $i_1,i_2$。

当 $i_1=i_2$ 时，设两个字符串此时划到的 $0,1$ 个数分别为 $w_1,b_1,w_2,b_2$，那么这个区间的最大值就是 $t=\min(w_1,w_2)+\min(b_1,b_2)$。

当 $i_1<i_2$ 时，考虑将 $s_1$ 中 $1\sim i_1$ 的字符能够匹配的尽量匹配，即将 $t$ 依旧计入答案。如果前面的字符存在可以被匹配但是不匹配，那么 $s_2$ 中这个不去匹配的字符就要从 $s_1+1\sim n$ 中去找一个匹配 $s_{1,j}$，此时它的价值至多为 $1$。但是如果它在 $1\sim i_1$ 中完成了匹配，那么 $s_{1,j}$ 可能被另外一个字符所匹配，此时答案至少为 $1$，至多为 $2$，肯定不会更差。因此贪心策略就是对于每一个当前划到的区间，将较短区间的字符能匹配的尽量去匹配掉，匹配完后短区间的指针向右移。所以在这一段话第一句的条件下，下一步的操作就是让 $i_1$ 变成下一个 $s_{1,k}=0$ 的 $k$。这样继续匹配，直到所有的字符都有一个配对为止。

当 $i_2<i_1$ 时，处理方式同 $i_1<i_2$。

为了方便处理，可以在最后加一个字符 $s_{1,n+1}=s_{2,n+1}=0$，输出时减掉即可。

时间复杂度 $O(Tn)$，空间复杂度 $O(n)$。

[代码](https://www.luogu.com.cn/paste/45qjlmhc)。

---

## 作者：CaiZi (赞：3)

### 思路分析
首先，可以交换相邻两个字符，等价于可以任意将一段区间内的 $0/1$ 重排。考虑处理出 $t_1,t_2$ 的每个长度大于等于 $2$ 且全为 $1$ 的区间；然后处理出每个这样的区间内，对应的 $s_1,s_2$ 的 $0/1$ 的个数。其实只需要四个选三个记录就好了，但是为了方便我们全部记录。

然后考虑贪心，因为一个数最多只能被匹配一次，且同时每个相同数字匹配时都是相同的（不是废话），所以考虑贪心。对于某一个位，我们能匹配就尽量匹配，一定是最优的。感性的证明一下，如果你当前匹配的某一个数要转移到其他后面的位置去匹配，说明后面的 $0/1$ 已经不够用了，放到后面时该位就不再匹配，答案不变。
### 代码展示
时间复杂度 $O(Tn)$。代码有点大坨。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,f,g;
};
int t,n,x,y,z;
string a,b,c,d;
vector<node>u,v;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t;
	while(t--){
		x=y=z=0;
		u.clear();
		v.clear();
		cin>>n>>a>>b>>c>>d;
		a=' '+a;
		b=' '+b;
		c=' '+c;
		d=' '+d;
		for(int i=1;i<=n;i++){
			if(z==0&&c[i]=='1'){
				z=i;
			}
			if(z!=0&&c[i]=='0'){
				if(i-z>=2){
					u.push_back(node{z,i-1,0,0});
				}
				z=0;
			}
		}
		if(z!=0){
			if(n-z>=1){
				u.push_back(node{z,n,0,0});
			}
			z=0;
		}
		for(int i=1;i<=n;i++){
			if(z==0&&d[i]=='1'){
				z=i;
			}
			if(z!=0&&d[i]=='0'){
				if(i-z>=2){
					v.push_back(node{z,i-1,0,0});
				}
				z=0;
			}
		}
		if(z!=0){
			if(n-z>=1){
				v.push_back(node{z,n,0,0});
			}
			z=0;
		}
		for(node& i:u){
			for(int j=i.l;j<=i.r;j++){
				if(a[j]=='0'){
					i.f++;
				}
				else{
					i.g++;
				}
			}
		}
		u.push_back(node{INT_MAX,INT_MAX,0,0});
		for(node& i:v){
			for(int j=i.l;j<=i.r;j++){
				if(b[j]=='0'){
					i.f++;
				}
				else{
					i.g++;
				}
			}
		}
		v.push_back(node{INT_MAX,INT_MAX,0,0});
		for(int i=1;i<=n;i++){
			if(i>u[x].r){
				x++;
			}
			if(i>v[y].r){
				y++;
			}
			if(u[x].l<=i&&v[y].l<=i){
				if(u[x].f!=0&&v[y].f!=0){
					z++;
					u[x].f--;
					v[y].f--;
				}
				else if(u[x].g!=0&&v[y].g!=0){
					z++;
					u[x].g--;
					v[y].g--;
				}
			}
			else if(u[x].l<=i){
				if(b[i]=='0'&&u[x].f!=0){
					z++;
					u[x].f--;
				}
				else if(b[i]=='1'&&u[x].g!=0){
					z++;
					u[x].g--;
				}
			}
			else if(v[y].l<=i){
				if(a[i]=='0'&&v[y].f!=0){
					z++;
					v[y].f--;
				}
				else if(a[i]=='1'&&v[y].g!=0){
					z++;
					v[y].g--;
				}
			}
			else{
				if(a[i]==b[i]){
					z++;
				}
			}
		}
		cout<<z<<'\n';
	}
	return 0;
}
```

---

## 作者：high_sky (赞：2)

## 赛时思路

注意到：在不改变原有贡献的位置下，交换可以使得答案不劣于交换原有贡献的位置。

我们可以想到用区间大的去配对区间小的。

考虑用 $pos_1$ 表示第一个字符串不可移动的点的第几个，$pos_2$ 同理。并用 $d_1$ 表示第一个字符串不可移动的点的集合，$d_2$ 同理。

那么我们先令 $pos_1=pos_2=1$，那么有以下三种情况：

- $d_{1_{pos_1}}<d_{2_{pos_2}}$，这种情况用区间大的给区间小的配对，这个是简单的，统计当前区间的 $1$ 和 $0$ 的个数取最小值即可。然后 $pos_2+1$ 并且让大区间的左端点为 $d_{2_{pos_2}}$，小区间（这里指第二个字符串的）的更新。具体的，使得其区间为 $d_{2_{pos_2}}+1$ 到 $d_{2_{pos_2+1}}-1$，注意不要与不移动的点重合，**不移动的点单独考虑即可，但区间包括的可以统计其中。**
- $d_{1_{pos_1}}=d_{2_{pos_2}}$，跟上述情况类似，就是不可移动的点重合了，需要单独考虑。
- $d_{1_{pos_1}}>d_{2_{pos_2}}$，与第一种情况类似，不过多赘述，最后令 $pos_1+1$ 即可。

于是这道题就做完了，但是细节非常多，很考验代码能力，也是大家要锻炼的题目。

赛时代码应该没有什么问题，有了再放吧。

---

## 作者：chenxi2009 (赞：1)

**Upd 2024.12.7：更改 AC 代码**
# 思路
我们不妨先假设所有的位置都能匹配上，再计算不能匹配到的位置。

转换一下题意：有几个不能移动的点阻碍了移动，相当于两个字符串各自被分割成了数个区间，每个区间内部的 01 字符可以互换位置，但区间之间不能交换字符（不能移动的点相当于长度为一的区间）。


从左往右扫，假设扫到某个位置时，有 A 区间包含 B 区间。


显然 A 区间的字符可以匹配上 B 区间的每个字符的话，就尽管匹配，反正每个字符最多贡献一次在这里贡献了肯定不劣；如果 A 区间缺少了一种字符，那只能用另外一种字符填补了。采用这样的策略扫一遍全部区间，就可以得到答案。时间复杂度 $O(Tn)$。

# 代码
**非考场代码，思路过程相同，暂时无法通过此题，仅供参考。**
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num0,num1;
	int l,r;
}; 
int T,n,ans,l,cnt[2],it;
char s[3][200000],t[3][200000];
vector<node>v[3];
int main(){
	scanf("%d",&T);
	while(T --){
		it = cnt[0] = cnt[1] = ans = 0,l = 1;
		v[1].clear(),v[2].clear(); 
		scanf("%d%s%s%s%s",&n,s[1] + 1,s[2] + 1,t[1] + 1,t[2] + 1);
		for(int i = 1;i <= n;i ++){
			if(t[1][i] == '0'){
				if(l != i) v[1].push_back({cnt[0],cnt[1],l,i - 1});
				if(s[1][i] == '1') v[1].push_back({0,1,i,i});
				else v[1].push_back({1,0,i,i});
				l = i + 1;
				cnt[0] = cnt[1] = 0;
			}
			else cnt[s[1][i] - '0'] ++;
		}
		if(l <= n) v[1].push_back({cnt[0],cnt[1],l,n});
		cnt[0] = cnt[1] = 0,l = 1;
		for(int i = 1;i <= n;i ++){
			if(t[2][i] == '0'){
				if(l != i) v[2].push_back({cnt[0],cnt[1],l,i - 1});
				if(s[2][i] == '1') v[2].push_back({0,1,i,i});
				else v[2].push_back({1,0,i,i});
				l = i + 1;
				cnt[0] = cnt[1] = 0;
			}
			else cnt[s[2][i] - '0'] ++;
		}
		if(l <= n) v[2].push_back({cnt[0],cnt[1],l,n});
		//至此字符串转变为区间结构体的形式保存，{区间左端点,区间右端点,0 的数量,1 的数量} 
		for(int i = 0;i < v[1].size();i ++){
			node tmp = v[1][i];
			while(it < v[2].size() && v[2][it].l <= tmp.r){
				if(v[2][it].r <= tmp.r){ 
					tmp.num0 -= v[2][it].num0;
					tmp.num1 -= v[2][it].num1;
					ans += v[2][it].num0 + v[2][it].num1; 
					if(tmp.num0 < 0) ans += tmp.num0,tmp.num1 += tmp.num0,tmp.num0 = 0;
					if(tmp.num1 < 0) ans += tmp.num1,tmp.num0 += tmp.num1,tmp.num1 = 0;
					it ++;
				}
				else{
					v[2][it].num0 -= tmp.num0;
					v[2][it].num1 -= tmp.num1;
					ans += tmp.num0 + tmp.num1; 
					if(v[2][it].num0 < 0) ans += v[2][it].num0,v[2][it].num1 += v[2][it].num0,v[2][it].num0 = 0;
					if(v[2][it].num1 < 0) ans += v[2][it].num1,v[2][it].num0 += v[2][it].num1,v[2][it].num1 = 0;
					break; 
				}
			}
			v[1][i] = tmp;
		}
		
		
		printf("%d\n",ans);
	}
	return 0;
}
```

---


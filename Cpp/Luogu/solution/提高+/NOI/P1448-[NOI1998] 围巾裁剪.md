# [NOI1998] 围巾裁剪

## 题目背景

NOI1998 Day2 T1

## 题目描述

裁缝有一块非常珍贵的丝绸围巾。可惜的是，围巾的某些部分已经被蛀虫给咬坏了。裁缝当然不愿意就这么把围巾给丢了，于是，他想把围巾给裁成两块小围巾送给他的两个女儿。自然，两块小围巾的面积之和越大越好。

这块围巾是一个正三角形，三条边被均匀地分成了 $N$ 段，即这个正三角形被均匀地分成了 $N^2$ 个单元，每个单元是一个面积为 $1$ 的正三角形。

如图所示为一个 $N=5$ 的围巾，图中带阴影的单元表示被蛀虫咬坏的部分。  
从上往下看，围巾被分成了 $N$ 行：
- 第一行有 $1$ 个单元。
- 第二行有 $3$ 个单元，其中有 $2$ 个是形如 $\Delta$ 的，有 $1$ 个是形如 $\nabla$ 的（这两种三角形我们认为是形状相同的）。
- 第三行有 $5$ 个单元，其中有 $3$ 个是形如 $\Delta$ 的，有 $2$ 个是形如 $\nabla$ 的……

用坐标 $(X,Y)$ 给每个单元定位，第一行的单元的坐标为 $(1,1)$；第二行从左到右的三个单元的坐标依次为 $(2,1)$、$(2,2)$、$(2,3)$；……

![](https://cdn.luogu.com.cn/upload/image_hosting/rwklebsy.png)

围巾的剪裁条件如下：  
  1. 裁成的两块小围巾形状与原来的大围巾完全相同，都是正三角形；
  2. 每一块小围巾里都不存在被蛀虫咬坏的部分；
  3. 裁剪时必须沿着单元的边界裁剪；
  4. 要求两块小围巾的面积的总和最大。

图中，最优的裁剪方法已经用粗线画了出来，面积和为 $4+9=13$。  
现在需要你编一个程序来帮助裁缝解决这个问题。

## 说明/提示

**【样例解释】**

如「题目描述」中图所示，两块小围巾面积总和的最大值为 $4+9=13$。

**【数据范围】**

- 对于 $50\%$ 的数据，$1\leq N\leq50$；
- 对于 $100\%$ 的数据，$1\leq N\leq100$，$0\leq M\leq N^2-2$，$1\leq X\leq N$，$1\leq Y\leq 2\times N-1$。

本题数据为 Windows（CRLF）格式。

## 样例 #1

### 输入

```
5
5
3 2
4 1
4 4
5 4
5 2```

### 输出

```
13```

# 题解

## 作者：diamond_153 (赞：10)

 # P1448 [NOI1998] 围巾裁剪 题解

看到这个题面，大家应该可以想到 $dp$。

我们先用 $a[i][j]$ 存储点 $(i,j)$ 是否被蛀虫咬坏，是为 $0$，不是为 $1$。

下一步我们设 $a[i][j](2\nmid j)$ 表示从点 $(i,j)$ 开始，最多可以向下延伸出一个没有任何小三角形被蛀虫咬坏，边长为 $a[i][j]$ 的正三角形。我们可以得到：
$$
a[i][j]=\begin{cases}
0 &(a[i][j]\text{的原值为}0)\\
1 &(a[i+1][j+1]=0)\\
\min\{a[i+1][j+2],a[i+1][j]\}+1 &(a[i+1][j+1]\ne0)\\
\end{cases}
$$
以此类推，$a[i][j](2\mid j)$ 表示从点 $(i,j)$ 开始，最多可以向上延伸出一个没有任何小三角形被蛀虫咬坏，边长为 $a[i][j]$ 的正三角形。我们可以得到：
$$
a[i][j]=\begin{cases}
0 &(a[i][j]\text{的原值为}0)\\
1 &(a[i-1][j-1]=0)\\
\min\{a[i-1][j-2],a[i-1][j]\}+1 &(a[i-1][j-1]\ne0)\\
\end{cases}
$$
由此，我们可以写出这一部分的代码：

```cpp
for(int i=n-1;i;i--)
	for(int j=1;j<=i;j++)
		if(a[i][(j<<1)-1]&&a[i+1][(j<<1)-1]
				&&a[i+1][j<<1]&&a[i+1][(j<<1)+1]){
			a[i][(j<<1)-1]=min(a[i+1][(j<<1)-1],
					a[i+1][(j<<1)+1])+1;
		}
for(int i=2;i<=n;i++)
	for(int j=2;j<i-1;j++)
		if(a[i][j<<1]&&a[i-1][(j<<1)-2]
				&&a[i-1][(j<<1)-1]&&a[i-1][j<<1]){
			a[i][j<<1]=min(a[i-1][(j<<1)-2],
					a[i-1][j<<1])+1;
		}
```

下一步，我们枚举一条分割线 $i$，将围巾分成两个部分：一个为顶点在最上方且边长为 $i$ 的正三角形，一个为剩余部分，使最终割下来的两个三角形一个在第一部分，一个在第二部分。然后就可以去枚举两个值 $x,y$，$x$ 为第一个三角形的最大面积；$y$ 为第二个三角形的最大面积。

我们就能通过枚举，得到每个分割线上下三角形面积和的最大值，代码如下：

```cpp
int x=0,y=0;
for(int i=1;i<=n;i++){
	x=y=0;
	for(int j=1;j<=i;j++){
		for(int k=1;k<=j;k++)
			x=max(x,min(i-j+1,a[j][(k<<1)-1]));
		for(int k=1;k<j;k++)
			x=max(x,a[j][k<<1]);
	}
	for(int j=i+1;j<=n;j++){
		for(int k=1;k<=j;k++)
			y=max(y,a[j][(k<<1)-1]);
		for(int k=1;k<j;k++)
			y=max(y,min(j-i,a[j][k<<1]));
	}
	if(x&&y)ans=max(ans,x*x+y*y); //注意，x和y必须不为0
}
```

但是，这题我们还没做完，因为我们还没有考虑到下面这个情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/b87rpb4e.png)

注：棕色为最大选取部分。

所以，我们应该把这个围巾旋转 $120°$，再继续 $dp$，当我们把三种情况都考虑完时，这个题目就做完了。

旋转部分代码：

```cpp
void rotate(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++)
			temp[n-i+j][((n-i)<<1)+1]=a[i][(j<<1)-1]?1:0; //旋转尖端朝上的小三角形
		for(int j=1;j<i;j++)
			temp[n-i+j+1][(n-i+1)<<1]=a[i][j<<1]?1:0; //旋转尖端朝下的小三角形
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=(i<<1)-1;j++)
			a[i][j]=temp[i][j]; //将旋转后的围巾拷贝到a里
}
```

完整代码：

```cpp
#include<iostream>
using namespace std;
int n,m,ans=0;
int a[110][210]={0},temp[110][210]={0};
void calculate(){
	for(int i=n-1;i;i--)
		for(int j=1;j<=i;j++)
			if(a[i][(j<<1)-1]&&a[i+1][(j<<1)-1]
					&&a[i+1][j<<1]&&a[i+1][(j<<1)+1]){
				a[i][(j<<1)-1]=min(a[i+1][(j<<1)-1],
						a[i+1][(j<<1)+1])+1;
			}
	for(int i=2;i<=n;i++)
		for(int j=2;j<i-1;j++)
			if(a[i][j<<1]&&a[i-1][(j<<1)-2]
					&&a[i-1][(j<<1)-1]&&a[i-1][j<<1]){
				a[i][j<<1]=min(a[i-1][(j<<1)-2],
						a[i-1][j<<1])+1;
			}
	int x=0,y=0;
	for(int i=1;i<=n;i++){
		x=y=0;
		for(int j=1;j<=i;j++){
			for(int k=1;k<=j;k++)
				x=max(x,min(i-j+1,a[j][(k<<1)-1]));
			for(int k=1;k<j;k++)
				x=max(x,a[j][k<<1]);
		}
		for(int j=i+1;j<=n;j++){
			for(int k=1;k<=j;k++)
				y=max(y,a[j][(k<<1)-1]);
			for(int k=1;k<j;k++)
				y=max(y,min(j-i,a[j][k<<1]));
		}
		if(x&&y)ans=max(ans,x*x+y*y);
	}
}
void rotate(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++)
			temp[n-i+j][((n-i)<<1)+1]=a[i][(j<<1)-1]?1:0;
		for(int j=1;j<i;j++)
			temp[n-i+j+1][(n-i+1)<<1]=a[i][j<<1]?1:0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=(i<<1)-1;j++)
			a[i][j]=temp[i][j];
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=(i<<1)-1;j++)
			a[i][j]=1;
	for(int i=0,x,y;i<m;i++){
		cin>>x>>y;
		a[x][y]=0;
	}
	for(int i=0;i<3;i++){
		calculate();
		if(i!=2)rotate();
	}
	cout<<ans;
}
```

注： `a<<1` 是在 `a` 为整数时，`a*2` 的等价形式。

---

## 作者：0xyz (赞：6)

怎么全是 $O(n^3+m)$ 的题解呢？这题明显有 $O(n^2+m)$ 的做法吧。

首先不难发现，任意两个不相交的正三角形之间都有至少 $1$ 条平行于大三角形的直线。我们对于这条线可能的 $3$ 个方向，我们考虑将大三角形转 $2$ 次，每次转 $120\degree$，然后分别求出这 $3$ 次的答案。

对于旋转的部分，我们手算一下 $n=5$ 的情况，有：

|$(1,1)$|||||||||
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$(2,1)$|$(2,2)$|$(2,3)$|||||||
|$(3,1)$|$(3,2)$|$(3,3)$|$(3,4)$|$(3,5)$|||||
|$(4,1)$|$(4,2)$|$(4,3)$|$(4,4)$|$(4,5)$|$(4,6)$|$(4,7)$|||
|$(5,1)$|$(5,2)$|$(5,3)$|$(5,4)$|$(5,5)$|$(5,6)$|$(5,7)$|$(5,8)$|$(5,9)$|

变为

|$(5,1)$|||||||||
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$(5,3)$|$(5,2)$|$(4,1)$|||||||
|$(5,5)$|$(5,4)$|$(4,3)$|$(4,2)$|$(3,1)$|||||
|$(5,7)$|$(5,6)$|$(4,5)$|$(4,4)$|$(3,3)$|$(3,2)$|$(2,1)$|||
|$(5,9)$|$(5,8)$|$(4,7)$|$(4,6)$|$(3,5)$|$(3,4)$|$(2,3)$|$(2,2)$|$(1,1)$|

注意到第 $2i-1$ 列是原来第 $n+1-i$ 行的奇数，从小到大，靠着下面；第 $2i$ 列是原来第 $n+1-i$ 行的偶数，从小到大，靠着下面。于是可以得到旋转大三角形部分的程序。

```cpp
b[n][2*n-1]=a[1][1];
for(ll i=2;i<=n;i++){
	for(ll j=1;j<i;j++)b[n-j+1][2*n-2*i+2]=a[i][2*i-2*j];
	for(ll j=1;j<=i;j++)b[n-j+1][2*n-2*i+1]=a[i][2*i-2*j+1];
}
for(ll i=1;i<=n;i++)
	for(ll j=1;j<2*i;j++)a[i][j]=b[i][j];
```

然后考虑怎么求答案。由于我们旋转了大三角形，不妨钦定分割线是水平的。那么我们考虑 DP 分别求出分割线上下的最大正三角形。
我们以分割线往上的部分为例，假设

$$f_{i,j}=\begin{cases}\text{以 (i,j) 为左下角的向上正三角形边长的最大值}&\text{(i,j)是向上正三角形}\\\text{以 (i,j) 为下顶点的向下正三角形边长的最大值}&\text{(i,j)是向下正三角形}\end{cases}$$

那么我们可以预处理出 $(i,j)$ 向右、向上的不被虫蛀的连续小三角形数量 $r_{i,j}$ 和 $u_{i,j}$，然后可以利用 $(i,j)$ 左上角的正三角形转移：

$$f_{i,j}=\begin{cases}\min(f_{i-1,j},\lfloor\frac{r_{i,j}-1}{2}\rfloor)+1&j\equiv 1\pmod 2\\\min(f_{i-1,j-2},\min(u_{i-1,j-1},u_{i-1,j}))+1&j\equiv 0\pmod 2\end{cases}$$

分割线以下的部分同理，假设

$$f_{i,j}=\begin{cases}\text{以 (i,j) 为左上角的向下正三角形边长的最大值}&\text{(i,j)是向下正三角形}\\\text{以 (i,j) 为上顶点的向上正三角形边长的最大值}&\text{(i,j)是向上正三角形}\end{cases}$$

同时也假设 $d_{i,j}$ 是 $(i,j)$ 向下不被虫蛀的连续小三角形数量，有

$$f_{i,j}=\begin{cases}\min(f_{i+1,j+2},\min(u_{i+1,j+1},u_{i+1,j}))+1&j\equiv 1\pmod 2\\\min(f_{i+1,j+2},\lfloor\frac{r_{i,j}-1}{2}\rfloor)+1&j\equiv 0\pmod 2\end{cases}$$

最后统计答案就用一个 $p_i$ 表示前 $i$ 行的最大正三角形面积，从后往前扫，同时用 $q$ 表示 $i$ 和后面这些行的最大正三角形面积，注意只有 $p_{i-1}$ 和 $q$ 都不等于 $0$ 才可以更新答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=505;
ll n,m,ans,a[_][_],b[_][_],d[_][_],u[_][_],r[_][_],f[_][_],p[_],q;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<2*i;j++)a[i][j]=1;
	for(ll i=1,x,y;i<=m;i++)cin>>x>>y,a[x][y]=0;
	for(ll tn=0;tn<3;tn++,q=0){
		memset(d,0,sizeof(d));
		memset(f,0,sizeof(f));
		memset(r,0,sizeof(r));
		memset(u,0,sizeof(u));
		for(ll i=n;i;i--)
			for(ll j=2*i-1;j;j--)
				if(a[i][j])d[i][j]=d[i+1][j]+1,r[i][j]=r[i][j+1]+1;
		for(ll i=1;i<=n;i++){
			p[i]=p[i-1];
			for(ll j=1;j<=2*i-1;j++)
				if(a[i][j]){
					u[i][j]=u[i-1][j]+1;
					if(j&1)f[i][j]=min(f[i-1][j],(r[i][j]-1)/2)+1;
					else f[i][j]=min(f[i-1][j-2],min(u[i-1][j-1],u[i-1][j]))+1;
					p[i]=max(p[i],f[i][j]*f[i][j]);
				}
		}
		memset(f,0,sizeof(f));
		for(ll i=n;i;i--)
			for(ll j=2*i-1;j;j--)
				if(a[i][j]){
					if(j&1)f[i][j]=min(f[i+1][j+2],min(d[i+1][j+1],d[i+1][j]))+1;
					else f[i][j]=min(f[i+1][j+2],(r[i][j]-1)/2)+1;
					q=max(q,f[i][j]*f[i][j]);
					if(p[i-1]&&q)ans=max(ans,p[i-1]+q);
				}
		b[n][2*n-1]=a[1][1];
		for(ll i=2;i<=n;i++){
			for(ll j=1;j<i;j++)b[n-j+1][2*n-2*i+2]=a[i][2*i-2*j];
			for(ll j=1;j<=i;j++)b[n-j+1][2*n-2*i+1]=a[i][2*i-2*j+1];
		}
		for(ll i=1;i<=n;i++)
			for(ll j=1;j<2*i;j++)a[i][j]=b[i][j];
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Dehydration (赞：1)

### 前言：

题意很简单，就是给出一个正三角形分割成 $n^2$ 份(详见题目)，有不能算的，即蛀虫部分。要让我们求出两个最大的正三角形(和)。

### 思路：
这是一道远古**模拟**题，不过我们可以用枚举加上 `dp` 水过此题。

我们要求两个最大面积正三角形，可以简化成求两次最大三角形（将一个标为蛀虫即可），用 `dp` 解决。

因为倒着和正着不一样（显然）我们需要求倒着和正着两种，用两个变量，不过状态转移方程都是大同小异：

```
（F[i,j]未正，G[i,j]为反）

	0; //(i,j)被标记为不可用
	1; //(i+1,j) (i+1,j+1) (i+1,j+2) 至少有一个不在界限内或者被标记为不可用
	F[i,j]=Min { F[i+1,j] , F[i+1,j+2] } + 1; //不符合以上两个情况
        G[i,j]=Min { G[i-1,j] , G[i-1,j-2] } + 1; //不符合以上两个情况
```
考虑找两个和最大三角形，没有局部最优策略可供利用，不能直接动态规划。于是可以想到枚举分割线，把图形分成一个小三角形和一个梯形，但后分别在两个区域内动态规划，求出两个区域内的值的和的最大值即可。

分割线枚举有三个方向，要 $\Theta(N)$ 次枚举分割，所以总的时间复杂度为 $\Theta(N^3)$。

以上即可，不过要注意正反都要求且要 $3$ 个方向枚举分割线。



---


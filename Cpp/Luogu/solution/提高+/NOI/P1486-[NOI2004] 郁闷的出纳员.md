# [NOI2004] 郁闷的出纳员

## 题目描述

OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。

工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。

老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 $k$ 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。

好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？

如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- `I` 命令的条数不超过 $10^5$；
- `A` 和 `S` 命令的总条数不超过 $100$；
- `F` 命令的条数不超过 $10^5$；
- 每次工资调整的调整量不超过 $10^3$；
- 新员工的工资不超过 $10^5$。
- $0 \leq n \leq 3 \times 10^5$，$0 \leq \text{min} \leq 10^9$，输入的所有数字均在 $32$ 位带符号整形范围内。

## 样例 #1

### 输入

```
9 10
I 60
I 70
S 50
F 2
I 30
S 15
A 5
F 1
F 2
```

### 输出

```
10
20
-1
2
```

# 题解

## 作者：浅色调 (赞：107)

### **最近比较懒惰，然后学了一波pb_ds。于是，本题就可以用pb_ds中的rb_tree做了，普通平衡树那题也用pb_ds水了一波ac。（noi赛制下pb_ds是可以用的，联赛貌似不行不过用来对拍是蛮不错的选择，splay还是得掌握的。）** 
## 所需声明及头文件：
```cpp
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
typedef tree<pt,null_type,less< pt >,rb_tree_tag,tree_order_statistics_node_update> rbtree;
```
## 解释及用途：
### int 关键字类型
### null_type无映射(低版本g++为null_mapped_type)
### less<int>从小到大排序
### rb_tree_tag 红黑树（splay_tree_tag）
### tree_order_statistics_node_update结点更新
### 插入t.insert();
### 删除t.erase();
### Rank:t.order_of_key();
### 第K值:t.find_by_order();
### 前驱:t.lower_bound();
### 后继t.upper_bound();
### a.join(b)b并入a 前提是两棵树的key的取值范围不相交
### a.split(v,b)key小于等于v的元素属于a，其余的属于b
### T.lower_bound(x)   >=x的min的迭代器
### T.upper_bound((x)  >x的min的迭代器
### T.find_by_order(k) 有k个数比它小的数
## 代码：
 ```
#include<cstdio>  
#include<iostream>  
#include<ext/pb_ds/assoc_container.hpp>  
#include<ext/pb_ds/tree_policy.hpp>  
using namespace __gnu_pbds;  
using namespace std;  
struct node{  
    int v,id;  
    node(int a,int b){v=a;id=b;}  
    bool operator >(node b) const  
    {return v==b.v?id>b.id:v>b.v;}  
};  
tree<node,null_type,greater<node>,rb_tree_tag,tree_order_statistics_node_update> T,TE;  
int main(){  
    int n,m,k,s=0,q,ans=0;  
    char c[10];  
    scanf("%d%d",&n,&m);  
    while(n--){  
        cin>>c[0];scanf("%d",&k);  
        if(*c=='I') {k+=s;if(k>=m) T.insert(node(k,n));}  
        else if(*c=='A') m-=k,s-=k;  
        else if(*c=='S'){  
            m+=k,s+=k;  
            T.split(node(m,-1),TE);  
            ans+=TE.size();  
        }  
        else if(*c=='F')      
            printf(k>T.size()?"-1\n":"%d\n",T.find_by_order(k-1)->v-s);  
    }  
    printf("%d\n",ans);  
    return 0;  
}  
```

---

## 作者：abs001 (赞：58)

蒟蒻不会Treap,于是有了一个线段树写法。

首先建一个权值线段树，里面维护每个工资出现的次数，用来求第k大。

对于修改工资的操作就可以用修改min的值来代替

在用一个变量b表示已经修改的工资的总量，每次加入员工时将k减去b

为了防止减到负数，于是可以将所有的值都加上len

注意：如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内


代码：

```cpp
#include<bits/stdc++.h>
#define N 400001
#define len 200000
using namespace std;

int n, m, la, mi, b, ans, lm;
int a[N], tree[N << 2], tag[N << 2];
char s[10];

void pushup(int rt)
{
    tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
}

void change(int rt, int l, int r, int x, int y)//单点修改
{
    if(l == r)
    {
        tree[rt] += y;
        return;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) change(rt << 1, l, mid, x, y);
    else change(rt << 1 | 1, mid + 1, r, x, y);
    pushup(rt);
}

int query(int rt, int l, int r, int x, int y)//求值域内的数量
{
    if(x <= l && r <= y) return tree[rt];
    int mid = (l + r) >> 1, res = 0;
    if(x <= mid) res += query(rt << 1, l, mid, x, y);
    if(y > mid) res += query(rt << 1 | 1, mid + 1, r, x, y);
    return res;
}

int js(int rt, int l, int r, int x)//求第k大
{
    if(l == r) return l;
    int mid = (l + r) >> 1, l1 = -1, r1 = -1;
    if(mi < l) l1 = tree[rt << 1];
    else if(l <= mi && mi <= mid) l1 = query(rt << 1, l, mid, mi, mid);
    else if(mid < mi && mi <= r) r1 = query(rt << 1 | 1, mid + 1, r, mi, r);
    else r1 = tree[rt << 1 | 1];
    //左边数量与右边数量
    if(r1 == -1) r1 = tree[rt] - l1;
    l1 = tree[rt] - r1;
    if(r1 >= x) return js(rt << 1 | 1, mid + 1, r, x);
    else return js(rt << 1, l, mid, x - r1);
}

void ql(int rt, int l, int r, int x, int y)//清零操作
{
    if(l == r)
    {
        tree[rt] = 0;
        return;
    }
    int mid = (l + r) >> 1;
    if(x <= mid && tree[rt << 1]) ql(rt << 1, l, mid, x, y);
    if(y > mid && tree[rt << 1 | 1]) ql(rt << 1 | 1, mid + 1, r, x, y);
    pushup(rt);
}

int main()
{
    scanf("%d%d", &n, &m), lm = m, m += len;
    for(int i = 1; i <= n; i++)
    {
        int x;
        scanf("%s%d", s, &x);
        if(s[0] == 'I')
        {
            if(x < lm) continue;
            change(1, 0, N - 1, x - b + len, 1);//加入员工
        }
        else if(s[0] == 'A') m -= x, b += x;//增加工资
        else if(s[0] == 'S')
        {
            m += x, b -= x;
            if(m >= 1 && query(1, 0, N - 1, 0, m - 1) > 0) ans += query(1, 0, N - 1, 0, m - 1), ql(1, 0, N - 1, 0, m - 1);//踢出员工
        }
        else
        {
            if(x > query(1, 1, N - 1, m, N - 1)) puts("-1");//工资大于k的数量
            else printf("%d\n", js(1, 0, N - 1, x) + b - len);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：AFOier (赞：52)

**对我来说，这大概是一题$treap$模板**

**人话题意：**

给出两个整数：$n$和$min$

你需要写一种数据结构，并维护以下$n$个操作$(k$已给出$)$：

$(I$命令$)1.$输入$k,$ 若$k>=min,$ 则插入$k.$

$(A$命令$)2.$将每个数加上$k.$

$(S$命令$)3.$将每个数减去$k,$并删除所有$<min$的数$.$

$(F$命令$)4.$查询第$k$大的数$($注意不是第$k$小$)$

最后输出有几个数被删除了$($要加上$I$命令中没有插入的数$)$

很显然，这些操作都是$treap$可以维护的$,$ 接下来我们逐个操作来分析$:$

首先，我们建立一个$sum$变量来统计数字的加减幅度，作用见下$.$

$I$命令$:$常规$insert$操作

$A$命令$:$将$min$减去$k,$ 将$sum$加上$k,$ 因为每个数都加$k$，而我们通过每个数要求的是第$k$大

（不影响）以及是否$<min,$ 所以如此操作

$S$命令$:$将$min$加上$k,$ 将$sum$减去$k($理由与$A$命令相同$),$ 然后进行一遍$while$循环$,$ 只

要当前有小于$min$的数字，就删掉$(pre$和$delete$操作$)$

$ps: pre$ 操作要考虑等于$min$的数也要删除的情况 

$F$命令$:$常规$find-rank$操作

上代码之前几点提醒$:$

$1.$ 最后一行输出跳槽的人的个数而不是剩下人的个数

$2.$ 有人初始工资相同，所以要改动$pre$函数

$3. F$ 操作是求第$k$大的数不是第$k$小

代码$:$
```
#include <cstdlib>
#include <iostream>
using namespace std;
int n,minn,x,tot,root,INF=0x7fffffff,num,sum,s;
//n,minn为输入，opt为操作种类，x=题面中的k
//tot为插入中用到的,root=树根(-INF)
//s=进入公司的总人数,num=最后留在公司的人数 
char opt;
struct treap
{
	int l,r,cnt,siz,val,dat;
}a[100001];
void update(int p)
{
	a[p].siz=a[p].cnt+a[a[p].l].siz+a[a[p].r].siz;
}
int New(int val)
{
	a[++tot].val=val;
	a[tot].dat=rand();
	a[tot].cnt=a[tot].siz=1;
	return tot;
}
void build()
{
	New(-INF);New(INF);
	root=1;a[1].r=2;
	update(root);
}
void zig(int &p)
{
	int q=a[p].l;
	a[p].l=a[q].r;
	a[q].r=p;p=q;
	update(a[p].r);update(p);
}//right rotate
void zag(int &p)
{
	int q=a[p].r;
	a[p].r=a[q].l;
	a[q].l=p;p=q;
	update(a[p].l);update(p);
}//left rotate
void ins(int &p,int val)
{
	if(p==0)
	{
		p=New(val);
		update(p);
		return;
	}
	if(val==a[p].val)
	{
		a[p].cnt++;
		update(p);
		return;
	}
	if(val<a[p].val)
	{
		ins(a[p].l,val);
		if(a[p].dat<a[a[p].l].dat)zig(p);//right rotate
	}
	if(val>a[p].val)
	{
		ins(a[p].r,val);
		if(a[p].dat<a[a[p].r].dat)zag(p);//left rotate 
	}
	update(p);
}//插入操作 
void del(int &p,int val)
{
	if(p==0)return;
	if(a[p].val==val)
	{
		if(a[p].cnt>1){a[p].cnt--;update(p);return;}
		if(a[p].l!=0||a[p].r!=0)
		{
			if(a[p].r==0||a[a[p].l].dat>a[a[p].r].dat){zig(p);del(a[p].r,val);}
			else{zag(p);del(a[p].l,val);}
			update(p);
		}
		else p=0;
		return;
	}
	if(val<a[p].val)del(a[p].l,val);
	else del(a[p].r,val);
	update(p);
}//删除操作 
int find_rank(int p,int val)
{
	if(p==0)return -1;
	if(a[a[p].l].siz>=val)return find_rank(a[p].l,val);
	if(a[a[p].l].siz+a[p].cnt>=val)return a[p].val;
	return find_rank(a[p].r,val-a[p].cnt-a[a[p].l].siz);
}//查找操作 
int pre(int val)
{
    int p=root,ans=1;
    while(p!=0)
    {
    	if(a[p].val==val)
    	{
			ans=p;
    		break;
    	}
    	if(a[p].val<val&&a[p].val>a[ans].val)ans=p;
    	if(a[p].val<val)p=a[p].r;
    	else p=a[p].l;
    }
    return a[ans].val;
}//求前驱 
int main()
{
	cin>>n>>minn;build();
	for(int i=1;i<=n;i++)
	{
		cin>>opt>>x;
		if(opt=='I')if(x-sum>=minn)ins(root,x-sum),num++,s++;
		if(opt=='F')
		{
			if(num<x)cout<<-1<<endl;
			else cout<<find_rank(root,num-x+2)+sum<<endl;
		}
		if(opt=='A')minn-=x,sum+=x;
		if(opt=='S')
		{
			minn+=x;sum-=x;
			int a1=minn-1,a2;
			while(pre(a1)!=-INF)
			{
				a2=a1;a1=pre(a1);
				del(root,pre(a2));
				num--;
			}
		}
	}
	cout<<s-num<<endl;
} 
```

---

## 作者：lijianyangyf (赞：47)

这道题是一道比较棒的treap模版题,于是我就用fhq-treap A了。⊙﹏⊙b汗

思路：
1, I 操作，单点插入，不过要判断能否加入，低于工资的最低值时，直接淘汰掉。  
  
2,这里我们把 A,S,F 操作一起讲;  
  
我们可以用一个delta把工资的调整记录下来。  
  
那么当我们添加一个新节点时添加的就不是x,而是x-delta，这样我们就可以直接利用delta进行S操作了。
  
S操作时，我们调整delta后，我们就要把小于minn-delta的员工全部删掉，我们把树分裂后直接删掉左子树即可。   
  
F操作要注意的只有查询后要输出val[x]+delta，这样才可以输出现在的值  
  
下面我们放一下代码（含注释）：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define maxn 110000
using namespace std;
int ch[maxn][2];//左右儿子 
int val[maxn];//原本的值 
int pri[maxn];//随机值 
int size[maxn];//以当前节点为跟的树的大小 
int sz;//没太大卵用，只是为了新建节点不重复而已 
void update(int x){size[x]=1+size[ch[x][0]]+size[ch[x][1]];}//更新 
int new_node(int v)//新建节点 
{
    size[++sz]=1;
    val[sz]=v;
    pri[sz]=rand();
    return sz;
}
int merge(int x,int y)//合并 
{
    if(!x||!y)return x+y;
    if(pri[x]<pri[y])
    {
        ch[x][1]=merge(ch[x][1],y);
        update(x);
        return x;
    }
    else
    {
        ch[y][0]=merge(x,ch[y][0]);
        update(y);
        return y;
    }
}
void split(int now,int k,int&x,int&y)//分裂 
{
    if(!now)x=y=0;
    else
    {
        if(val[now]<=k)
            x=now,split(ch[now][1],k,ch[now][1],y);
        else
            y=now,split(ch[now][0],k,x,ch[now][0]);
        update(now);
    }
}
int kth(int now,int k)//找第k名 
{
    while(1)
    {
        if(k<=size[ch[now][0]])
            now=ch[now][0];
        else if(k==size[ch[now][0]]+1)
            return now;
        else k-=size[ch[now][0]]+1,now=ch[now][1];
    }
}
int main()
{
    srand(99);
    int n,minn;scanf("%d%d",&n,&minn);
    int root=0,x,y,z;
    int delta=0,leave=0;
    for(int i=1;i<=n;i++)
    {
        char st[2];scanf("%s",st);
        int a;scanf("%d",&a);
        if(st[0]=='I')
        {
        	if(a>=minn)//没有到达工资底线的直接叫他走开，以免影响的leave的答案 
        	{
        		a-=delta;//要减去delta，这样才能方便以后的查询 
        		split(root,a,x,y);
        		root=merge(x,merge(new_node(a),y));
			}
		}
		else if(st[0]=='A')delta+=a;
		else if(st[0]=='S')
		{
			delta-=a;
			split(root,minn-delta-1,x,y);//minn-delta-1代表小于minn-delta的数 
			root=y;//直接舍弃左子树 
			leave+=size[x];//加上被删去的节点数量 
		}
        else if(st[0]=='F')
        {
        	if(size[root]<a)printf("-1\n");//如果节点总数比a还小的话，就直接输出-1 
        	else printf("%d\n",val[kth(root,size[root]-a+1)]+delta);
			//记得加上delta，不然就不是修改之后的值了 
			//第k大就是找排名第size[root]-a+1(总数-a+1)的数 
		}
    }
    printf("%d\n",leave);
}
```

---

## 作者：秋日私语 (赞：42)

更好的阅读体验点[这里](https://blog.csdn.net/A_Comme_Amour/article/details/79718898)
题目
-

[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)

题解
-

这道题还是比较好的

平衡树第一题，所以代码打的并不熟练

题目要求使用一种支持点的插入、删除，求名次的数据结构，平衡树当然是首选
题目中的加减操作都是对于所有员工的，我们不可能对所有的点进行修改，于是我们在开一个变量**delta**，用来记录所有的员工的工资的变化量，那么某个员工的实际工资就是x+delta；

然而我们考虑新加入的员工，对她加上历史的delta显然是不合适的；我们可以这样处理：

在平衡树提前插入inf和-inf

**I命令：加入一个员工** 我们在平衡树中加入k-minn

**A命令：把每位员工的工资加上k** delta加k即可

**S命令：把每位员工的工资扣除k**  此时我们就需要考虑会不会导致一大批员工离开；我们插入minn-delta，然后使小于minn-delta的点一起移动到根的右子树的左子树，一举消灭；

**F命令：查询第k多的工资** 注意是第k多，Splay操作；
还有一些小细节需要注意，+2-2等等；

代码
-

```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn=1000001;
const int inf=1e9;

int n,minn,delta,f[maxn],ch[maxn][2],cnt[maxn],size[maxn],key[maxn],rt,sz;

int read()
{
	char ch=getchar(); int now=0,f=1;
	while (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0' && ch<='9')
	{
		now=(now<<1)+(now<<3)+ch-'0';
		ch=getchar();
	}
	return now*f;
}

void clear(int x)
{
	f[x]=ch[x][0]=ch[x][1]=cnt[x]=key[x]=size[x]=0;
}
bool get(int x) {return ch[f[x]][1]==x;}

void pushup(int x)
{
	if (!x) return;
	size[x]=cnt[x];
	if (ch[x][0]) size[x]+=size[ch[x][0]];
	if (ch[x][1]) size[x]+=size[ch[x][1]];
}

void rotate(int x)
{
	int old=f[x],oldf=f[old],which=get(x);
	ch[old][which]=ch[x][which^1]; f[ch[x][which^1]]=old;
	ch[x][which^1]=old; f[old]=x;
	f[x]=oldf;
	if (oldf) ch[oldf][ch[oldf][1]==old] = x;
	pushup(x); pushup(old);
}

void splay(int x,int goal)
{
	for (int fa; (fa=f[x])!=goal; rotate(x))//这里是不等于 
		if (f[fa]!=goal)
			rotate(get(x)==get(fa)?fa:x);
	if (goal==0) rt=x;
}

void insert(int x)
{
	if (rt==0)
	{
		sz++; key[sz]=x; rt=sz;
		cnt[rt]=size[rt]=1;
		f[rt]=ch[rt][0]=ch[rt][1]=0;
		return;
	}
	int now=rt,fa=0;
	while (1)
	{
		if (x==key[now])
		{
			cnt[now]++; pushup(fa); pushup(now); splay(now,0); return;
		}
		fa=now; now=ch[now][x>key[now]];
		if (now==0)
		{
			sz++; key[sz]=x;
			size[sz]=cnt[sz]=1;
			f[sz]=fa;
			ch[sz][0]=ch[sz][1]=0;
			ch[fa][x>key[fa]]=sz;
			pushup(fa); splay(sz,0); return;//这里错了 
		}
	}
}

int id(int x)//查询x的编号 
{
	int now=rt;
	while (1)
	{
		if (x==key[now]) return now;
		else
		{
			if (x<key[now]) now=ch[now][0];
			else now=ch[now][1];
		}
	}
}

int rnk(int x)//查询x的排名
{
	int now=rt,ans=0;
	while (1)
	{
		if (x<key[now]) now=ch[now][0];
		else
		{
			ans+=size[ch[now][0]];
			if (x==key[now])
			{
				splay(now,0); return ans+1;//找出x的排名并将其旋转到根
			}
			ans+=cnt[now];
			now=ch[now][1];
		}
	}
}

int kth(int x)//查询排名为x的数
{
	int now=rt;
	while (1)
	{
		if (ch[now][0] && x<=size[ch[now][0]])
			now=ch[now][0];
		else
		{
			int tmp=size[ch[now][0]]+cnt[now];
			if (x<=tmp) return key[now];
			x-=tmp; now=ch[now][1];
		}
	}
}

int pre()
{
	int now=ch[rt][0];
	while (ch[now][1]) now=ch[now][1];
	return now;
}
int next()
{
	int now=ch[rt][1];
	while (ch[now][0]) now=ch[now][0];
	return now;
}

void del(int x)
{
	rnk(x);//将x旋转到根
	if (cnt[rt]>1) {cnt[rt]--; pushup(rt); return;}//
	if (!ch[rt][0] && !ch[rt][1]) {clear(rt); rt=0; return;}//这里的rt和x写混了，有浪费时间 
	if (!ch[rt][0]) {
		int oldrt=rt; rt=ch[rt][1]; f[rt]=0; clear(oldrt); return;
	}
	if (!ch[rt][1]) {
		int oldrt=rt; rt=ch[rt][0]; f[rt]=0; clear(oldrt); return;
	}
	int oldrt=rt; int leftbig=pre();
	splay(leftbig,0);
	ch[rt][1]=ch[oldrt][1];
	f[ch[oldrt][1]]=rt;
	clear(oldrt);
	pushup(rt);
}

int main()
{
 	n=read(); minn=read();
	int totadd=0,totnow=0,ans=0;
 	char opt[10]; int k;
	insert(inf); insert(-inf);
 	for (int i=1; i<=n; i++)
 	{
 		scanf("%s%d",opt,&k);
 		if (opt[0]=='I')
		{
			if (k<minn) continue;
			insert(k-delta);
			totadd++;
		} 
 		if (opt[0]=='A') delta+=k;
		if (opt[0]=='S')
		{
			delta-=k;
			insert(minn-delta);
			int a=id(-inf); int b=id(minn-delta);
			splay(a,0);
			splay(b,a);
			ch[ ch[rt][1] ][0]=0;
			del(minn-delta);
		}
		if (opt[0]=='F')
		{
			totnow=rnk(inf)-2;
			if (totnow<k) {printf("-1\n"); continue;}
			int ans=kth(totnow+2-k);
			printf("%d\n",ans+delta);//最后再加上累加值delta
		}
	}
	totnow=rnk(inf)-2;
	ans=totadd-totnow;
	printf("%d",ans);
 	return 0;
}
```

总结
-

积累Splay的操作：查询区间内小于某个数的点一起删掉；
加入+-inf作为根也可以查询平衡树中元素个数的思想；

“线下”维护差值的思想；

---

## 作者：程就未来 (赞：29)

### 这道题要求能够支持插入、修改、求第K大的数据结构，首选的数据结构当然是平衡树.

### 本蒟蒻是用Splay做的，但我的思路似乎和楼下的几位dalao不一样。

## 对于下列几个操作：

#### 1. I命令 I_k 新建一个工资档案，初始工资为k。如果某员工的初始工资低于工资下界，他将立刻离开公司。

这个操作就是Splay中普通的插入（Insert）
    ```
    void Insert(int x)
    {
        if(x < m) return ;//如果插入的节点的权值小于下界，则不用插入
        int rt = root, p = 0;
        while(t[rt].val != x && rt) p = rt , rt = t[rt].ch[x > t[rt].val];//不停地往下找，p为父亲节点
        if(rt) t[rt].cnt ++;//如果已经有这个数，则副本数＋1
        else//否则新建节点
        {
            rt = ++ tot;
            if(p) t[p].ch[x > t[p].val] = rt;
            t[rt].par = p;
            t[rt].ch[0] = t[rt].ch[1] = 0;
            t[rt].size = t[rt].cnt = 1;
            t[rt].val = x; 
        }
        Splay(rt);
    }
    ```

#### 2.A命令 A_k 把每位员工的工资加上k 

此操作只需要暴力地修改树中每一个节点的权值（val）
    
   ```
    void add(int x) {for(int i = 1 ; i <= tot ; i ++) t[i].val += x;}
    
    ```
 
    
#### 3.S命令 S_k 把每位员工的工资扣除k
	
对于这个操作，需要找到第一个扣工资后达到工资下界的人，将他Splay到根节点，删除根节点的左子树即可。最后别忘了减去每个节点的val。（代码中的m为工资下界）
    
   ##### 这里还要注意一个细节：有可能扣工资后所有人都要离开公司，所以一开始要插入一个工资为无穷大的节点
   ```
        void find(int x)//查找最大的小于等于x的节点并旋转到根
        {
            int rt = root;
            while(x != t[rt].val && t[rt].ch[x > t[rt].val]) rt = t[rt].ch[x > t[rt].val];
            Splay(rt);
        }
        void sub(int x) //扣每个人的工资
        {
            for(int i = 1 ; i <= tot ; i ++) t[i].val -= x;
        }
        int get_next(int x)//查找最小的大于等于x的数
        {
            find(x);
            if(t[root].val >= x) return root;
            int rt = t[root].ch[1];
            while(t[rt].ch[0]) rt = t[rt].ch[0];
            return rt;
        }
       	void Remove(int x)
        {
            int rt = get_next(x + m);
            Splay(rt);
            ans += t[t[rt].ch[0]].size;//根节点的左子树的大小即为删除的人数
            t[rt].ch[0] = 0;//删除左子树
            pushup(rt);//更新rt的大小
            sub(x);
        }
        
        ```
        
#### 4.F命令 F_k 查询第k多的工资

  普通的查询操作，注意因为先前插入的无穷大节点，所以要查询第k+1大的节点
  ```
        
    int Kth(int k)
    {
        if(k >= t[root].size) return -1;
        k++;//因为先前插入的无穷大节点，所以要查询第k+1大的节点
        int rt = root;
        while(1)
        {
            if(t[rt].ch[1] && k <= t[t[rt].ch[1]].size) rt = t[rt].ch[1];
            else if(k > t[t[rt].ch[1]].size + t[rt].cnt)
            {
                k = k - t[t[rt].ch[1]].size - t[rt].cnt;
                rt = t[rt].ch[0];
            }
            else return t[rt].val;
        }
    }
    ```
    
#### 最后附上AC代码
#####   开O2 : 302ms
#####    不开O2：570ms
##### 你可以在最优解第8页中找到我

    ```
    
    #include<bits/stdc++.h>
    using namespace std;
    const int N = 1000009 , INF = 1547483647;//INF不能太大，否则爆int
    struct Splay{int ch[2] , par , cnt , size , val;} t[N];
    /*ch[2]分别表示左右儿子
      par表示父亲
      cnt为副本数
      size为树的大小
      val为节点权值（每个人的工资）
    */
    int n  , m , tot = 0 , root , ans = 0 ;
    //m为工资下界，root为根节点编号，ans为离开公司的人数
    int read()//快读不解释
    {
        int s = 0 , w = 1;char ch = getchar();
        while(ch <'0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
        while(ch >= '0' && ch <= '9'){s = (s << 1) + (s << 3) + (ch ^ 48);ch = getchar();}
        return s * w;
    } 
    char read_char()
    {
        char ch = getchar();
        while(ch != 'I' && ch != 'S' && ch != 'F' && ch != 'A') ch = getchar();
        return ch;
    }
    bool chk(int rt){return t[t[rt].par].ch[1] == rt;} //判断rt是父亲的那个儿子
    void pushup(int rt){ t[rt].size = t[t[rt].ch[0]].size + t[t[rt].ch[1]].size + t[rt].cnt;}
    //更新操作
    void rotate(int rt)//旋转操作
    {
        int f = t[rt].par , gf = t[f].par , d = chk(rt) , son = t[rt].ch[d ^ 1];
        t[f].ch[d] = son; t[son].par = f;
        t[gf].ch[chk(f)] = rt; t[rt].par = gf;
        t[rt].ch[d ^ 1] = f; t[f].par = rt;
        pushup(f) , pushup(rt); 
    }
    void Splay(int rt , int goal = 0)//将rt旋转到指定节点的儿子，若调用时不输入goal，则默认为0（即旋转到根节点）
    {
        while(t[rt].par != goal)
        {
            int f = t[rt].par ;int  gf = t[f].par;
            if(gf != goal)
            {
                if(chk(rt) == chk(f)) rotate(f);
                else rotate(rt);
            }
            rotate(rt);
        }
        if(!goal) root = rt;
    }
    void Insert(int x)//插入
    {
        if(x < m) return ;
        int rt = root, p = 0;
        while(t[rt].val != x && rt) p = rt , rt = t[rt].ch[x > t[rt].val];
        if(rt) t[rt].cnt ++;
        else
        {
            rt = ++ tot;
            if(p) t[p].ch[x > t[p].val] = rt;
            t[rt].par = p;
            t[rt].ch[0] = t[rt].ch[1] = 0;
            t[rt].size = t[rt].cnt = 1;
            t[rt].val = x; 
        }
        Splay(rt);
    }
    void find(int x)//查找最大的小于等于x的节点并旋转到根
    {
        int rt = root;
        while(x != t[rt].val && t[rt].ch[x > t[rt].val]) rt = t[rt].ch[x > t[rt].val];
        Splay(rt);
    }
    void add(int x) {for(int i = 1 ; i <= tot ; i ++) t[i].val += x;}//＋每个人的工资

    void sub(int x) {for(int i = 1 ; i <= tot ; i ++) t[i].val -= x;} //扣每个人的工资

    int get_next(int x)//查找最小的大于等于x的数
    {
        find(x);
        if(t[root].val >= x) return root;
        int rt = t[root].ch[1];
        while(t[rt].ch[0]) rt = t[rt].ch[0];
        return rt;
    }
    void Remove(int x)//让工资低于下界的人离开
    {
        int rt = get_next(x + m);
        Splay(rt);
        ans += t[t[rt].ch[0]].size;
        t[rt].ch[0] = 0;
        pushup(rt);
        sub(x);
    }

    int Kth(int k)//求第k大
    {
        if(k >= t[root].size) return -1; k++;
        int rt = root;
        while(1)
        {
            if(t[rt].ch[1] && k <= t[t[rt].ch[1]].size) rt = t[rt].ch[1];
            else if(k > t[t[rt].ch[1]].size + t[rt].cnt)
            {
                k = k - t[t[rt].ch[1]].size - t[rt].cnt;
                rt = t[rt].ch[0];
            }
            else return t[rt].val;
        }
    }

    int main()
    {
        n = read(); m = read();Insert(INF);
        while(n --)
        {
            char opt = read_char();
            int x = read();
            if(opt == 'I') Insert(x);
            if(opt == 'A') add(x);
            if(opt == 'S') Remove(x);
            if(opt == 'F') printf("%d\n",Kth(x));
        }
        cout << ans << endl;
        return 0;
}

```

#### 本蒟蒻第一次写题解，求管理员大大给过。

	


---

## 作者：Creeper_LKF (赞：16)

这里给出大牛上目前跑的最快(180ms)的代码以及条平衡树的反思。

首先这里使用了带旋转的Treap，然后发现这玩意真好用。

然后这道题只调了半个小时左右吧，于是十分高兴，总结了写和调平衡树蒟蒻的经验：

1. 对于平衡树，平常的对拍所写的的暴力就只能检查一下数据的答案，如果更好的也可以用暴力检查每一步的答案（然而不是所有题都能做得到）

2. 然后在写平衡树的时候，有一些操作并不需要强行把基础操作组合在一起，否则常数会非常大。例如某份代码在进行S操作的时候，把所有点都遍历了一遍，然后中间还有两次复杂度高log的操作，于是最坏复杂度nlogn，还好操作次数少。于是我们有优化：

```cpp
    inline void Delete_Lower_Bound(int tar, int &node){
            if(!node) return ;
            if(num[node] < tar){
                Delete_Tree(lc);//删除子树
                Delete_Lower_Bound(tar, rc);//仿STL
                Delete(num[node], node);//删除节点
            } else if(num[node] >= tar) Delete_Lower_Bound(tar, lc);
            Updata(node);
        }
```
在这种情况下，由于删除子树的时候只要更改值，所以其实可以直接O(1)的断开链接即可（在下面的代码中还是递归），然后Lower\_Bound操作log的，Delete由于已经确定了num[node]，而且左儿子已经删完了，所以操作都是O(1)的，总复杂度O(log)。
代码如下：

    
    
    
    
    
    
```cpp
    #include <cstdio>
    #include <cctype>
    using namespace std;
    #define LL long long
    #define MAXN 2000005
    #define INF 0x3f3f3f3f
    const LL MODS = 5371321, PRI = 832211;
    inline char get_char(){
        static char buf[5000001], *p1 = buf, *p2 = buf;
        return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 5000000, stdin), p1 == p2) ? EOF : *p1 ++;
    }
    inline int read(){
        int num = 0;
        char c;
        while (isspace(c = get_char()));
        while (num = num * 10 + c - 48, isdigit(c = get_char()));
        return num;
    }
    inline char get_ch(){
        char c;
        while(isspace(c = get_char()));
        return c;
    }
    inline void upmax(int &a, const int &b){
        if(a < b) a = b;
    }
    int m, min_m, loc, ans;
    int cnt, tot;
    int tree[MAXN][2], size[MAXN], wv[MAXN], num[MAXN];
    #define lc tree[node][0]
    #define rc tree[node][1]
    inline int rand(){
        static int sed = 15;
        return sed = (LL)(sed * PRI) % MODS;
    }
    namespace Treap{
        inline void Updata(int node){
            if(node) size[node] = size[tree[node][0]] + size[tree[node][1]] + 1;
        }
        inline void Rotate(int &node, int son){
            int tmp = tree[node][son];
            tree[node][son] = tree[tmp][!son], tree[tmp][!son] = node;
            Updata(node), Updata(tmp);
            node = tmp;
        }
        inline void Insert(int tar, int &node){
            if(!node) node = ++cnt, size[node] = 1, wv[node] = rand(), num[node] = tar;
            else {
                size[node]++;
                if(tar <= num[node]){
                    Insert(tar, lc);
                    if(wv[lc] < wv[node]) Rotate(node, 0);
                } else {
                    Insert(tar, rc);
                    if(wv[rc] < wv[node]) Rotate(node, 1);
                }
            }
        }
        inline void Delete(int tar, int &node){
            if(num[node] == tar){
                ans++;
                if(!(lc * rc)){
                    node = lc | rc;
                    return ;
                }
                if(num[lc] > num[rc]) Rotate(node, 1), Delete(tar, lc);
                else Rotate(node, 0), Delete(tar, rc);
            } else {
                if(num[node] > tar) Delete(tar, lc); else Delete(tar, rc);
            }
            Updata(node);
        }
        inline void Delete_Tree(int &node){
            if(!node) return;
            if(lc) Delete_Tree(lc);
            if(rc) Delete_Tree(rc);
            Updata(node);
            node = 0, ans++;
        }
        inline void Delete_Lower_Bound(int tar, int &node){
            if(!node) return ;
            if(num[node] < tar){
                Delete_Tree(lc);
                Delete_Lower_Bound(tar, rc);
                Delete(num[node], node);
            } else if(num[node] >= tar) Delete_Lower_Bound(tar, lc);
            Updata(node);
        }
        inline int Get_Kth(int k, int node){
            if(size[lc] == k - 1) return num[node];
            if(size[lc] >= k) return Get_Kth(k, lc);
            return Get_Kth(k - size[lc] - 1, rc);
        }
    }
    int main(){
        m = read(), min_m = read();
        for(int i = 1; i <= m; i++){
            char cons = get_ch();
            int tar = read();
            if(cons == 'I'){
                if(tar >= min_m) Treap::Insert(tar - loc, tot);
            }
            else if(cons == 'A') loc += tar;
            else if(cons == 'S'){
                loc -= tar;
                int tmp = loc - min_m;
                Treap::Delete_Lower_Bound(-tmp, tot);
            } else {
                printf("%d\n", size[tot] >= tar ? Treap::Get_Kth(size[tot] - tar + 1, tot) + loc : -1);
            }
        }
        printf("%d", ans);
        return 0;
    }
（可能luogu格式会抽）......
```

---

## 作者：liangs333 (赞：14)

### 既然这是一道平衡树裸题，那么我们打完平衡树之后，不妨考虑一下能不能大力线段树。事实告诉我们，这个操作是资瓷的。
首先，对于加工资和减工资操作，显然移动区间并不是那么科学，于是我们考虑维护一个偏移量。即将每一次加/减的工资记录下来，默认我们数据结构中存储的人的工资是没有被所有加/减操作影响之前的值。注意对于一个后插入的人，在他之前的加减也会对他造成影响。


例如我们进行三个操作，插入工资为20的人，加工资50，插入工资为60的人。具体执行的时候，我们现在数据结构中插入一个20，然后将偏移量+50，然后再插入一个60-偏移量，既插入10。

考虑加工资不会对人数产生影响，我们直接维护偏移量即可。

对于扣工资操作，由于，可能会需要让一段工资区间内的人集体辞职，我们还需要在线段树上维护一个区间删除标记。常规维护即可。

总的来说，我们对于工资建立一棵权值线段树，维护区间删除标记、区间元素个数，需要支持单点插入，区间删除。同时维护一个偏移量，对于新插入的人进行偏移后插入至线段树中即可。由于权值范围较大，故考虑离散化或者动态开点。在这里我采用的是后者。

详见代码。

``` c++
#include<bits/stdc++.h>
#define ls(k) a[k].ch[0]
#define rs(k) a[k].ch[1]
using namespace std;
struct node { 
	int l,r,ch[2];
	int cnt;
	bool del;
}; node a[640000];

const int L=-150000000,R=150000000;
int cnt=1;
int n,lim,delta;
char ch[2];int val;
int out,num,num2;

inline void make(int k) { 
	int l=a[k].l,r=a[k].r,mid=l+r>>1;
	ls(k)=++cnt,a[cnt].l=l,a[cnt].r=mid;
	rs(k)=++cnt,a[cnt].l=mid+1,a[cnt].r=r;
} 

inline void update(int k) { 
	a[k].cnt=a[ls(k)].cnt+a[rs(k)].cnt;
} 

inline void pushdown(int k) { 
	if(a[k].del) { 
		if(1ll*ls(k)*rs(k)!=0) { 
			a[ls(k)].del=a[rs(k)].del=1;
			a[ls(k)].cnt=a[rs(k)].cnt=0;
		} 
		a[k].del=0;
	} 
} 

void ins(int k,int val) { 
	if(a[k].l==a[k].r) return a[k].cnt++,void();
	if(1ll*ls(k)*rs(k)==0) make(k);
	pushdown(k);
	int mid=a[k].l+a[k].r>>1;
	if(val<=mid) ins(ls(k),val);
	else ins(rs(k),val);
	update(k);
} 

void del(int k,int l,int r) { 
	if(k==0) return;
	if(a[k].l==l&&a[k].r==r) return a[k].del=1,a[k].cnt=0,void();
	int mid=a[k].l+a[k].r>>1;
	pushdown(k);
	if(r<=mid) del(ls(k),l,r);
	else if(l>mid) del(rs(k),l,r);
	else del(ls(k),l,mid),del(rs(k),mid+1,r);
	update(k);
} 

int query(int k,int val) { 
	if(a[k].l==a[k].r) return a[k].l;
	pushdown(k);
	int lsi=a[ls(k)].cnt;
	if(val<=lsi) return query(ls(k),val);
	else return query(rs(k),val-lsi);
} 

inline void prit(int k) { 
	printf("%2d %2d %2d %2d %2d %2d %2d\n",k,ls(k),rs(k),a[k].l,a[k].r,a[k].cnt,a[k].del);
	if(ls(k)) prit(ls(k));
	if(rs(k)) prit(rs(k));
} 

int main() { 
	scanf("%d%d",&n,&lim);
	a[1].l=L,a[1].r=R;
	for(int i=1;i<=n;++i) { 
		scanf("%s%d",ch,&val);
		if(ch[0]=='I') { 
			val-=delta;
			if(val<lim) out++,num++,num2++;
			else ins(1,val),num++;
		} 
		if(ch[0]=='A') { 
			delta+=val;
			lim-=val;
		} 
		if(ch[0]=='S') { 
			int nw=a[1].cnt;
			delta-=val,lim+=val;
			del(1,L,lim-1);
			out+=nw-a[1].cnt;
		} 
		if(ch[0]=='F') { 
			if(val>(num-out)) printf("-1\n");
			else printf("%d\n",query(1,(num-out)-val+1)+delta);
		} 
	} 
	printf("%d",out-num2);
	return 0;
} 
```

---

## 作者：qwqqqq (赞：13)

看了一圈，这个题还没有用stl划水的题解，那蒟蒻就来分享一下我的做法。

stl里的vector本身就支持插入，删除操作。结合lower_bound()可以在插入时做到每一次插入的元素都有序排列。由于这个题目对元素的加减是针对整个数列的，所以在整体减过以后数列的有序性不变，也就减少了很多维护的工作量。~~也使得vector可以卡卡常就水过去。~~

下面是代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
vector<int>v;
inline int read()
{
	char ch=getchar();
	int x=0,f=1;
	for(;!isdigit(ch);ch=getchar())
		if(ch=='-')
			f=-1;
	for(;isdigit(ch);ch=getchar())
		x=x*10+ch-'0';
	return x*f;
}
int main()
{
	register int n,minn=0,tot=0;
	n=read(),minn=read();
	v.reserve(1000010);
	for(register int i=1;i<=n;i++)
	{
		char ch;
		cin>>ch;
		register int k=read();
		if(ch=='I')
		{
			if(k<minn)
				continue;
			v.insert(lower_bound(v.begin(),v.end(),k),k); 
		}
		if(ch=='A')
		{
			register int s=v.size();
			for(register int i=0;i<s;i++)
				v[i]+=k;
		}
		if(ch=='S')
		{
			register int s=v.size();
			for(register int i=0;i<s;i++)
			{
				v[i]-=k;
				if(v[i]<minn)
					v.erase(lower_bound(v.begin(),v.end(),v[i])),i--,tot++,s--;
			}
		}
		if(ch=='F')
		{
			register int s=v.size();
			if(k>s)
				cout<<-1<<"\n";
			else
				cout<<v[s-k]<<"\n";
		}
	}
	cout<<tot;
	return 0;
}
```

---

## 作者：k，火魂 (赞：12)

都是平衡树，但是我却想到了一个线段树（~~我不会平衡树~~）。

区间k小让我想到的主席树（虽然主席树好像不可做），对于叶子节点，t[p].l代表数值，t[p].sum代表数值为t[p].l的数的个数。

难点在于如果每个人的工资都加或减，整个线段树就要平移，怎么移？

（~~我当然不会平移啦~~）

对于每次涨工资，直接拆掉线段树重建。（是的，不会爆时间，以为A和S操作都比较小，而且每个人的工资必定不会超过2e5，所以乘起来不会爆掉）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e6+10;
struct rec{
	int l,r,sum;
}t[N*4];
int n,m,size,sum,k;
int a[N];
char s[2];

inline void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].sum=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	t[p].sum=t[p<<1].sum+t[p<<1|1].sum;
}

inline void set(int p){
	if(t[p].l==t[p].r){
		if(t[p].l+k>=m){
			a[t[p].l+k]=t[p].sum;
		}
		else{
			sum+=t[p].sum;
		}
		t[p].sum=0;	
		return;
	}
	set(p<<1);set(p<<1|1);
}

inline void insert(int p,int v){
	if(t[p].l==t[p].r){
		t[p].sum++;
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(v<=mid)insert(p<<1,v);
	else insert(p<<1|1,v);
	t[p].sum=t[p<<1].sum+t[p<<1|1].sum;
}

inline int query(int p,int k){
	if(t[p].sum<k)return -1;
	if(t[p].l==t[p].r){
		return t[p].l;
	}
	int lc=p<<1,rc=lc+1;
	if(t[lc].sum>=k)return query(lc,k);
	else return query(rc,k-t[lc].sum);
}

int main()
{
	scanf("%d%d",&n,&m);
	build(1,m,2e5);
	for(int i=1;i<=n;i++){
		scanf("%s%d",s+1,&k);
		if(s[1]=='I'){
			if(k<m){
				continue;
			}
			insert(1,k);
			size++;
		}
		if(s[1]=='A'||s[1]=='S'){
			if(s[1]=='S')k=-k;
			memset(a,0,sizeof(a));
			set(1);
			build(1,m,2e5);
		}
		if(s[1]=='F'){
			if(k>size-sum)printf("-1\n");
			else printf("%d\n",query(1,size-sum-k+1));
		}
	}
	printf("%d\n",sum);
	return 0;
}
```


---

## 作者：Drifterming (赞：10)

```cpp
//让这道板子题难死我。。。调了一天了 
//换了有四五种思路，最后发现我并没有想错，就是这么写 
//犯了一个很sb的错误，原因是想的方法太多了，没改过来，保持了上一种写法的样子 
//但是我感觉貌似并没影响啊。。。但是它就是WA了 
//一个遗漏的小细节，浪费了一下午的时间 
//但是   因为绞尽脑汁地A掉这道题，所以我又学会了一些骚操作
// 但是依然感觉很亏啊    好好的时间，就这么流走了

//    思路：
//正常的treap操作，删除的时候暴力枚举删除(/滑稽)，不用担心TLE
//本来想加个并查集维护一下删除操作，但是做出这道题来之后已经完全没心情了
//如果一个人跳槽了，就给他打个标记，下次涨工资或者减工资的时候就continue掉
//别的就和板子一个样了

//我犯的几个zz错误：
//1、注意题目中说一开始工资不够离开的不加入答案 （我并没犯这个错误）
//2、询问的是工资第k大的人的工资是多少，不是问第k大的工资是多少！！！——>这个很重点，就是因为这个，我换了一种思路写的代码
//3、如果你写的是左儿子比右儿子大的treap，那么查找的时候找的是(在职人数-x+1)，因为你的查询查询的是第k小
//		如果是右儿子比左儿子小的，直接查找x就行了。 
//5、删除的时候要让root->size-=删除的那个工资的人数，不是 --root->size 
//4、可能会有职工的工资是一样的，所以要记录相同工资的人数。 ->第2条和第5条的原因

//忠告：慎用指针！  虽然功能强大，但是太难调试，而且一些操作并不能像数组一样那么灵活的去执行。
//		本人不会用指针    如果是指针大佬。就当我没说。 

#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1e5+5;
const int INF=599518803;

int n,minn;
int opt,x;
int tim,sum_peo,leave_peo;
int add[N],sub[N];
struct Node
{
    Node *son[2];	//左右儿子，son[0]是左儿子，son[1]是右儿子 
    int key;	//权值 
    int heap_key;	//维护堆的权值 
    int key_cnt;	//节点的重量 
    int size;	//子树的节点个数 
    int tim;	//进公司的时间 
    bool flag;	//是否跳槽 
}node[N];

typedef Node* Tree;
Tree now_node,root,null;

int read()
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar())
        switch(c)
        {
            case 'I':return 1;
            case 'A':return 2;
            case 'S':return 3;
            case 'F':return 4;
            case '-':f=-1;
            default:
                break;
        }
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num*f;
}

void init()
{
    srand(INF);		//随机种子 
    tim=1;
    node->flag=1;
    node->son[0]=node->son[1]=node;		//null的左右儿子指向null 
    now_node=root=null=node;
}

Tree newNode(int key)	//申请新节点 
{
    //++sum_peo;
    ++now_node;
    now_node->key=key;
    now_node->key_cnt=1;
    now_node->heap_key=rand();
    now_node->size=1;
    now_node->flag=0;
    now_node->son[0]=now_node->son[1]=null;
    now_node->tim=tim;
    return now_node;
}

void rotate(Tree &root,bool flag)	//旋转，flag==0是左旋，==1是右旋 
{
    Tree tmp=root->son[!flag];
    root->son[!flag]=tmp->son[flag];
    tmp->son[flag]=root;
    root->size=root->son[0]->size+root->son[1]->size+root->key_cnt;
    tmp->size=tmp->son[0]->size+tmp->son[1]->size+tmp->key_cnt;
    root=tmp;
}

void insert(Tree &root,int key)
{
    if(root==null)		//开新的工资档案 
        root=newNode(key);
    else if(key==root->key)		//相同工资人数++ 
    {
        ++root->key_cnt,++root->size;
    }
    else
    {
        bool flag=key<root->key;
        insert(root->son[flag],key);
        ++root->size;
        if(root->heap_key<root->son[flag]->heap_key)
            rotate(root,!flag);
    }
}

void erase(Tree &root,int key,int num)		//num个员工跳槽 
{
    if(root==null)
        return;
    if(key!=root->key)
    {
        bool flag=key<root->key;
        erase(root->son[flag],key,num);
        root->size-=num;
    }
    else
    {
        if(root->son[0]==null)
        {
            //change=root;
            //printf("A:  change:%d  root:%d\n",change,root);
            root=root->son[1];
            //printf("B:  change:%d  root:%d\n",change,root);
        }
        else if(root->son[1]==null)
        {
            //change=root;
            root=root->son[0];
        }
        else
        {
            bool flag=root->son[0]->heap_key>root->son[1]->heap_key;
            rotate(root,flag);
            erase(root->son[flag],key,num);
            root->size-=num;
        }
    }
}

int query_num(Tree root,int k)		//询问第k大 
{
    if(root==null)
        return 0;
    if(k<=root->son[0]->size)
        return query_num(root->son[0],k);
    if(k>root->son[0]->size+root->key_cnt)
        return query_num(root->son[1],k-root->son[0]->size-root->key_cnt);
    return root->key;
}
//
//Tree find(Tree x)
//{
//	return x->fa==x?x:x->fa=find(x->fa);
//}

int main()
{
    //freopen("233.in","r",stdin);
    //freopen("233.out","w",stdout);
    init();		//别忘调用初始化函数 
    n=read(),minn=read();
    while(n--)
    {
        opt=read(),x=read();
        switch(opt)
        {
            case 1:
                if(x>=minn)
                    ++sum_peo,		//在职员工人数++ 
                    insert(root,x);
                break;
            case 2:
                for(Tree i=node+1;i<=now_node;++i)
                {
                    if(i->flag==1)	//跳槽了 
                        continue;
                    i->key+=x;		//涨工资 
                }
                break;
            case 3:
                //printf("be:  %d\n",sum_peo);
                for(Tree i=node+1;i<=now_node;++i)
                {
                    if(i->flag==1)		//已经跳槽了 
                        continue;
                    i->key-=x;	//扣工资 
                    if(i->key<minn)
                    {
                        //Tree change=null;
                        //printf("C: change: %d\n",change);
                        erase(root,i->key,i->key_cnt);
                        sum_peo-=i->key_cnt;	//减去这个工资的人数 
                        leave_peo+=i->key_cnt;	//跳槽人数 
                        i->flag=1;	//标记一下已经跳槽 
                        //printf("D: change: %d\n",change);
                        //change=null;
                        //printf("E: change: %d\n",change);
                    }
                }
                //printf("af:  %d\n",sum_peo);
                break;
            default:
                //printf("peo: %d\n",sum_peo);
                if(x>sum_peo)
                    printf("-1\n");
                else printf("%d\n",query_num(root,x));
        }
    }
    printf("%d",leave_peo);
    return 0;
}
```

---

## 作者：Wei_taming (赞：9)

实现方式短+压行的炒好背 $fhq \space treap$

本题只要支持两种操作

所以难度上应该比平衡树模板要低

关键在于灵活运用一个tag变量处理加减工资的问题

加了工资就直接加到tag上

减了工资在tag上减去，然后依据题意删除工资低于下限的员工的档案

关于这个删除我们要找的是那些满足

$$ k+tag<min $$
的员工，稍作移项便可得到只与员工初始工资$k$有关的不等式：
$$k<min-tag$$
由于在树中点的权值就是员工的初始工资，我们便可以根据这个不等式，结合$fhq\space treap$的按权值分裂操作，轻松地把整棵树划分成权值小于 $min-tag$和权值大于等于 $min-tag$的两部分，把小于的那部分的节点数目统计入答案，之后我们只要保留大于等于的那部分即可

对于查询第k大，就是平衡树的基本操作喽~~  但是我写的时候脑子一抽，写成了查第k小......稍微一想发现问题不大，显然的是，一个数在n个数中排第k大，那它一定也是第$n-k+1$小喽~~

另外一点细节，加入新的员工时，由于之前的工资加减不涉及这名新员工，所以我们把他的初始工资减去tag再插入即可。输出第k大时一定不要忘了再加上tag。

下面给出代码：

```cpp
#include <cstdio>
#include <cctype>
#include <ctime>
#include <cstdlib>
#include <iostream>

#define N 100100
#define L(n) node[(n)].l
#define R(n) node[(n)].r

int n, minn;

int root, cnt, tag;

struct Node
{
	int k, rd, size;
	int l, r;
	Node(int k = 0) : k(k), rd(rand()), size(1), l(0), r(0){}
} node[N];

inline void update(int n)
{
	node[n].size = (L(n) ? node[L(n)].size : 0) + (R(n) ? node[R(n)].size : 0) + 1;
}

void split(int n, int k, int &x, int &y)
{
	if(!n)x = y = 0;
	else if(node[n].k >= k)split(L(n), k, x, y), L(n) = y, update(y = n);
	else split(R(n), k, x, y), R(n) = x, update(x = n);
}

int merge(int x, int y)
{
	if(!x || !y)return x + y;
	if(node[x].rd <= node[y].rd)return R(x) = merge(R(x), y), update(x), x;
	else return L(y) = merge(x, L(y)), update(y), y;
}

inline void insert(int k)
{
	int x, y;
	split(root, k, x, y);
	node[++ cnt] = Node(k);
	root = merge(merge(x, cnt), y);
}

inline int search(int n, int r)
{
	int rank = (L(n) ? node[L(n)].size : 0) + 1; 
	if(r == rank)return node[n].k;
	else if(r < rank)return search(L(n), r);
	else return search(R(n), r - rank);
}

int ln;

int leave()
{
	int x, y;
	split(root, minn - tag, x, y);
	ln += node[x].size;
	root = y;
}

int main()
{
	node[0].size = 0;
	
	scanf("%d %d", &n, &minn);
	
	for(int i = 1; i <= n; i ++)
	{
		char c[3]; int k;
		scanf("%s%d", c, &k);
		if(c[0] == 'I' && k >= minn)insert(k - tag);
		else if(c[0] == 'A')tag += k;
		else if(c[0] == 'S')tag -= k, leave();
		else if(c[0] == 'F')
		{
			if(k > node[root].size)puts("-1");
			else printf("%d\n", search(root, node[root].size - k + 1) + tag);
		}
	}
	
	printf("%d", ln);
	
	return 0;
}
```

---

## 作者：why_always_china (赞：6)

我放一个Splay的。

平衡树裸题。

可以记录一个全局变量表示员工工资改变量，插入时注意修改新员工工资使其同样具有此改变量。

删除时类似于二分查找，找到不被删除的最低工资员工，转到根，删除左子树。

找第K大和线段树差不多，我们可以观察当前点是第几大，然后向左/右下降，也是经典操作。

对于重复工资员工，我们可以在节点上记录一个time表示出现次数。

注意维护每个子树的size，旋转时见机而行更新其值。

虽然跑得不快但是比较好写!

```cpp
#include<cstdio>
#define maxn 100009
using namespace std;
struct splay{
    int l, r, fa, size, v, time;
}node[maxn];
int root = 0, cnt = 0, change = 0, p = 0, n, small;
inline void update(int x){node[x].size = node[node[x].l].size + node[node[x].r].size + node[x].time;}
void zig(int x){
    int F = node[x].fa, G = node[F].fa;
    if (G){
        if (node[G].l == F) node[G].l = x;
        else node[G].r = x;
    }
    node[x].fa = G;
    node[F].l = node[x].r;
    if (node[x].r) node[node[x].r].fa = F;
    node[F].fa = x;
    node[x].r = F;
}
void zag(int x){
    int F = node[x].fa, G = node[F].fa;
    if (G){
        if (node[G].l == F) node[G].l = x;
        else node[G].r = x;
    }
    node[x].fa = G;
    node[F].r = node[x].l;
    if (node[x].l) node[node[x].l].fa = F;
    node[F].fa = x;
    node[x].l = F;
}
void Splay(int x, int s = 0){
    while (node[x].fa != s){
        int F = node[x].fa, G = node[F].fa;
        if (G == s){
            if (node[F].l == x) zig(x); else zag(x);
            update(F);
            break;
        }
        else{
            if (node[F].l == x){
                if (node[G].l == F){zig(F); zig(x);}
                else{zig(x);zag(x);}
            }
            else{
                if (node[G].r == F){zag(F); zag(x);}
                else{zag(x); zig(x);}
            }
            update(G);
            update(F);
        }
    }
    update(x);
    if (!s) root = x;
}
int find(int x){
    int p = root;
    while (p && node[p].v != x){
    if (x > node[p].v) p = node[p].r; else p = node[p].l;
    }
    if (p) Splay(p);
    return p;
}
void insert(int x){
    if (!root){node[++cnt] = (splay){0, 0, 0, 1, x, 1}; root = cnt; return;}
    int p = root, p2;
    while (p){
        if (x == node[p].v) {++node[p].time;update(p); Splay(p);break;}
        else if (x > node[p].v) p2 = node[p].r;
        else p2 = node[p].l;
        if (!p2){
            node[++cnt] = (splay){0, 0, p, 1, x, 1};
            if (x > node[p].v) node[p].r = cnt;
            else node[p].l = cnt;
            update(p);
            Splay(cnt);
            break;
        }
        p = p2;
    }
}
int getKth(int k){
    int p = root;
    while (k){
        int size = node[node[p].l].size, time = node[p].time;
        if (size + time < k) {p = node[p].r; k -= size + time;}
        else if (size >= k) p =  node[p].l;
        else return node[p].v;
    }
}
void del(){
    int p = root, p2 = root, ch = small - change;
    while(p){
        if (node[p].v < ch) p = node[p].r;
        else{p2 = p; p = node[p].l;}
    }
    if (node[p2].v < ch) {root = 0;return;}
    Splay(p2);
    node[p2].l = 0;
    update(p2);
}
int read(){
    char c;
    while (c = getchar(), c < '0' || c > '9');
    int x = c - '0';
    while (c = getchar(), c >= '0' && c <= '9') x = x * 10 + c - '0';
    return x;
}
int main(){
    char c; int x;
    node[0] = (splay){0, 0, 0, 0, 0, 0};
    n = read(); small = read();
    while(n--){
        while (c = getchar(), !(c >= 'A' && c <= 'Z'));
        x = read();
        switch(c){
            case 'I':if (x >= small) {++p;insert(x - change);};break;
            case 'A':change += x;break;
            case 'S':change -= x; del();break;
            case 'F':if (x > node[root].size) printf("-1\n");
            else printf("%d\n", getKth(node[root].size - x + 1) + change);break;
        }
    }
    printf("%d\n", p - node[root].size);
    return 0;
}
```

---

## 作者：zhzh2001 (赞：5)

## 声明


刚开始学平衡树，~~并不会写~~。而且这题可以用`pb\_ds`通过，这里给出这种版本。


## 代码


```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
//extc++.h与stdc++.h类似，后者包含标准C++的头文件，而前者提供扩展
using namespace std;
using namespace __gnu_pbds;
//pb_ds所需的namespace
const int M=100005;
typedef pair<int,int> pii;
//first存工资，second存id（可能有重复的工资，需要区分）
typedef tree<pii,null_type,greater<pii>,rb_tree_tag,tree_order_statistics_node_update> tree_t;
//使用tree_order_statistics_node_update来获取find_by_order方法
tree_t T,TE;
//TE为无用的树
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int delta=0,ans=0,id=0;
      //delta保存全局工资偏移
    while(n--)
    {
        char opt;
        for(opt=getchar();isspace(opt);opt=getchar());
          //跳过空白
        int x;
        scanf("%d",&x);
        switch(opt)
        {
            case 'I':
                if(x>=m)
                    T.insert(make_pair(x-delta,++id));
                    //插入时需考虑偏移
                break;
            case 'A':
                delta+=x;
                break;
            case 'S':
                delta-=x;
                T.split(make_pair(m-delta,0),TE);
                //清空TE，并把T中工资小于最低标准的移动到TE中
                ans+=TE.size();
                break;
            case 'F':
                tree_t::iterator i=T.find_by_order(x-1);
                //注意find_by_order是从0开始的
                if(i==T.end())
                    puts("-1");
                else
                    printf("%d\n",i->first+delta);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

## 奇怪的I/O问题


用`cin/cout`会超时，这很正常；但是当我试图用


```cpp
scanf("%1s%d",&opt,&x);
```

输入`opt`时出现了问题：主站40分，大牛0分，用`%s`也不行。也许是这样有问题，欢迎反馈。


> 修正：使用`scanf()`输入字符串数组大小至少为strlen+1。
>
> 正确方法：
>
> ```c
> char opt[2];
> scanf("%1s",opt);
> ```


## 总结


合理使用`pb\_ds`能简化代码，但`pb\_ds`也有很多缺点：


- 常数大（虽然比`STL`小）


- 相比手写数据结构局限


- 在比赛中用不安全？


- 不同版本的兼容性问题，如`null\_type`和`null\_mapped\_type`（旧版）


- ~~调试不方便~~


当我试图`(gdb)print`一个`tree`时，出现一堆乱七八糟的内容。这里提供一个简单的调试方法：


```cpp
void debug(const tree_t& T)
{
    for(tree_t::iterator i=T.begin();i!=T.end();i++)
        cout<<i->first<<' '<<i->second<<endl;
}
```

或者`C++11`


```cpp
void debug(const tree_t& T)
{
    for(auto i:T)
        cout<<i.first<<' '<<i.second<<endl;
}
```

这样只要执行类似`(gdb)p debug(T)`就能打印出来


---

## 作者：_YPC (赞：4)

# Luogu1486 【[NOI2004]郁闷的出纳员】题解

---

## 0.前言

感觉写替罪羊树的人好少啊（难道dalao全部去写朝鲜树了吗？[滑稽]）……

于是蒟蒻打算来写一波替罪羊树的题解

## 1.解题思路

这题目一看就知道是平衡树（？？？），插入操作、删除操作以及查询第K大元素都应该是平衡树的拿手好戏。

**工资变动**：工资变动其实十分简单，笨蛋的想法就是每次工资变动后，把每个节点全部加上或减去变动的值。但是呢，我们其实仔细思考就可以发现，其实只需要用一个变量来记一下工资变动总量就行了，到时候输出的时候就加上相应的变动总量就行了。

**插入操作**：插入操作其实比较简单，令*money*为当前总的工资变动量，*x*为当前员工的初始工资，那么我们要向树中插入一个值为*x-money*的节点。为什么？因为我们在插入这个工资之前已经有*money*的工资总量了，如果后面要输出这个员工的工资就要输出*该员工的工资+money*，那么为了出去之前的money的影响，所以事先要给这个员工的工资减去*money*，这样输出的时候就是真正的这个员工的目前的工资了（实在无法理解的想想容斥吧）。有一点需要注意，如果这个员工的初始工资小于最小工资的话，那么就直接**continue**。

**删除操作**：删除操作依然十分简单……直接从根开始遍历，把树上的工资小于最低工资的员工直接删了就可以了，因为我每次实在*S x*这个操作后开始删除的，而*S x*这个操作又十分少，所以不用担心超时。当然呢，其实还有一种更快的做法，那就是直接删了某一个小于最低工资的员工左子树的根和这个员工就行了。

**查询操作**：如果有不会的请左转至Luogu3369做一下平衡树的模板题……

## 2.代码

```
#include<cstdio>
#define alpha 0.75
#define qmid(L,R) L+((R-L)>>1)
#define INF 0x7fffffff
using namespace std;
inline int read(){
	int ret=0,flg=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-')flg=-1;ch=getchar();}
	while (ch>='0'&&ch<='9')ret=ret*10+ch-48,ch=getchar();
	return ret*flg;
}
struct ypc{
	int val,fa,son[2];
	double size;
}t[100010];
int n,sum,cur[100010],tot,root,min,money,tot_leave;
inline bool balance(int id){
	return t[t[id].son[0]].size<=t[id].size*alpha&&t[t[id].son[1]].size<=t[id].size*alpha;
}
inline void dfs(int id){
	if (!id)return;
	dfs(t[id].son[0]);
	cur[++sum]=id;
	dfs(t[id].son[1]);
}
inline int build(int L,int R){
	if (L>R)return 0;
	int mid=qmid(L,R),id=cur[mid],ls=build(L,mid-1),rs=build(mid+1,R);
	t[id].son[0]=ls,t[id].son[1]=rs;
	t[ls].fa=id,t[rs].fa=id;
	t[id].size=t[ls].size+t[rs].size+1;
	return id;
}
inline bool get_lr(int id){
	return t[t[id].fa].son[1]==id;
}
inline void rebuild(int id){
	sum=0,dfs(id);
	int fa=t[id].fa,opt=get_lr(id),new_son=build(1,sum);
	t[fa].son[opt]=new_son,t[new_son].fa=fa;
	if (root==id)root=new_son;
}
inline void insert(int x){
	if (!root){if (!tot)tot=1;root=tot,t[root].val=x,t[root].size=1,t[root].fa=0;return;}
	int tmp=root;
	while (tmp){
		t[tmp].size++;
		int fa=tmp,opt=(x>=t[tmp].val);tmp=t[tmp].son[opt];
		if (!tmp){
			t[fa].son[opt]=++tot,t[tot].fa=fa,t[tot].val=x,t[tot].size=1;
			break;
		}
	}
	int flg=0;
	for (int i=tot;i;i=t[i].fa)if (!balance(i))flg=i;
	if (flg)rebuild(flg);
}
inline void erase(int id){
	if (t[id].son[1]&&t[id].son[0]){
		int tmp=t[id].son[0];
		while (t[tmp].son[1])tmp=t[tmp].son[1];
		t[id].val=t[tmp].val,id=tmp;
	}
	int fa=t[id].fa,son=t[id].son[0]?t[id].son[0]:t[id].son[1],opt=get_lr(id);
	t[son].fa=fa,t[fa].son[opt]=son;
	for (int i=fa;i;i=t[i].fa)t[i].size--;
	if (root==id)root=son;
}
inline int erase_val(int x){
//	printf("---------\n");
	int tmp=root;
	while (tmp){
//		printf("%d %d\n",tmp,t[tmp].val+money);
		if (x>t[tmp].val+money){
			sum=0,dfs(t[tmp].son[0]),cur[++sum]=tmp;
			tot_leave+=sum;
			for (int i=1;i<=sum;i++)erase(cur[i]);
			tmp=t[tmp].son[1];
		}else tmp=t[tmp].son[0];
	}
//	printf("---------\n");
}
inline int get_xth(int x){
	int tmp=root;
	while (tmp){
		if (t[t[tmp].son[0]].size==x-1)return t[tmp].val+money;
		if (t[t[tmp].son[0]].size>=x)tmp=t[tmp].son[0];else x-=t[t[tmp].son[0]].size+1,tmp=t[tmp].son[1];
	}
}
int main(){
// 	freopen("Luogu1486.in","r",stdin);
// 	freopen("Luogu1486.out","w",stdout);
	n=read(),min=read();
	root=0;
	for (int i=1;i<=n;i++){
		char tpe[2];
		scanf("%s",tpe);
		int x=read();
		if (tpe[0]=='I'&&x>=min)insert(x-money);
		if (tpe[0]=='A')money+=x;
		if (tpe[0]=='S')money-=x,erase_val(min)/*,printf("tot_leave=%d\n",tot_leave)*/;
		if (tpe[0]=='F')printf("%d\n",t[root].size>=x?get_xth(t[root].size-x+1):-1);
	}
	printf("%d\n",tot_leave);
	return 0;
}
```

---

## 作者：wanxiang_zx (赞：3)

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=401000;
int n,m,s=0,base=200020,add=0;
struct node{
       int l,r,sum,v;
}a[4*maxn];
void create(int rt,int x,int y)
{
     a[rt].l=x;
     a[rt].r=y;
     a[rt].sum=0;
     a[rt].v=0;
     if(x==y)
       return;
     int mid=(x+y)>>1;
     create(2*rt,x,mid);
     create(2*rt+1,mid+1,y);
}
//建树， sum表示工资从 a[rt].l到 a[rt].r这个区间有多少个人
//v为懒惰标记，表示这个区间已经被清零，但没有做它的子节点 
void pushd(int p)
{
     if(a[p].v==0) 
       return;
     else{
		a[p].v=0;
		a[p*2].v=1,a[p*2+1].v=1;
		a[p*2].sum=a[p*2+1].sum=0;
	 }
}
//把自己懒惰标记取消，标记左右子，清空左右子 
void pushup(int rt)
{
     a[rt].sum=a[2*rt].sum+a[2*rt+1].sum;
}
//把自己的个数赋为左右子个数之和 
void ins(int rt,int x)
{
      if(a[rt].l==a[rt].r)
      {
        if(a[rt].l==x)
          a[rt].sum++;
        //只把叶节点的员工数增加 
        return;
      }
      pushd(rt);
      int mid=(a[rt].l+a[rt].r)>>1;
      if(x<=mid) 
        ins(2*rt,x);
      else
        ins(2*rt+1,x);
      pushup(rt);
}
int dfs(int rt,int x) //查找第x小的员工工资是多少 
{
     if(a[rt].l==a[rt].r)
       return a[rt].l;
     //如果做到叶节点,就返回叶节点的员工数 
     pushd(rt);
     if(a[2*rt].sum<x)
       return dfs(2*rt+1,x-a[2*rt].sum);
       //如果左子节点的员工数之和小于你要查询的第x小
       //那你要寻找的第x小在右子结点 
     return dfs(2*rt,x);
}
void change(int rt,int x) //我来踢人了 
{
     if(a[rt].r<x)
     {
       //如果该结点的工资右界都低于x   走人+懒惰标记 
       a[rt].sum=0;
       a[rt].v=1;
       return;
     }
     if(a[rt].l==a[rt].r)
     {
		if(a[rt].r<x) 
          a[rt].sum=0;
          //如果叶结点的工资低于x   走人
		return;
	 }
	 int mid=(a[rt].l+a[rt].r)>>1;
	 //mid为区间工资平均值，也是左右子的分割点 
	 pushd(rt);
	 if(x<=mid) 
        change(rt*2,x);
	 else
     {
		change(rt*2,x);
		change(rt*2+1,x);
		//如果mid<=x 既要踢左边的所有人又要踢右边的一部分人 
	 } 
     pushup(rt);
}
int main()
{
    scanf("%d%d",&n,&m);
    create(1,0,400100);
    for(int i=1;i<=n;i++)
    {
      char ch;
      int x;
      cin>>ch;
      scanf("%d",&x);
      if(ch=='I')
      {
        
        if(x<m)
          continue;
        s++;
        ins(1,x-add+base);
        //add为历史增量，因为线段树中储存的都是去掉增量的工资，为防止出现负数
        //给每个数增加base
      }
      if(ch=='A')
        add+=x;
      if(ch=='S')
      {
        add-=x;
        change(1,m-add+base);
        //将工资低于下限m的员工裁掉;
      }
      if(ch=='F')
      {
        //a[1].sum为第一个结点（整个区间） 的员工数，也就是当前公司的员工数 
        if(x>a[1].sum)
          printf("-1\n");
        else
          printf("%d\n",dfs(1,a[1].sum-x+1)+add-base);
          //查找第x大的员工工资是多少
          //相当于查找第a[1].sum-x+1小的员工工资是多少
          //又因为线段树中储存的都是去掉增量的工资，加上增量再减去base即为此时实际工资 
      }
    }
    printf("%d\n",s-a[1].sum);
    system("pause");
    return 0;
}

```


---

## 作者：Sol1 (赞：3)

主要用到Treap。建议一些刚刚学Treap的同学来做一下这道题，还是蛮经典的。

在此推销一下自己的Treap学习笔记：[这里](https://www.luogu.org/blog/xiezihan123456789/treap-xue-xi-bi-ji)

这道题如何用Treap呢？

### 操作1：新建一个档案。

这个操作应该说是和模板一样的。注意插入的时候要将插入值减去increase（这个变量的意思见下），复杂度$O(logN)$

### 操作2：所有员工加工资。

用一个变量increase来记录这个值，这里直接increase +k就可以了。复杂度$O(1)$。

### 操作3：所有员工减工资。

还是要更新increase，然后在Treap上遍历：

如果当前节点的$val+increase-k<$最低工资，则将这个节点的左子树和这个节点整体删除，然后将这个节点的指针直接指导右子树上面，然后在右子树上递归。

否则，在左子树上和右子树上递归。注意参数要用引用传递和这种情况下需要执行的旋转。复杂度$O(logN)$。

### 操作4：查询。

首先判断-1：如果要查询的x大于treap当前的大小，直接输出-1。

否则，在Treap上用模板的方法进行查询，注意最后查询出的结果要加上increase。复杂度$O(logN)$。

贴代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <ctime>
#include <algorithm>
using namespace std;

int leave, increase, minSal;
struct Node {
    int val, cnt, siz, pro, l, r;
    Node() {
        val = cnt = siz = pro = l = r = 0;
    }
};
struct Treap {
    Node nd[400005];
    int top, _root;

    inline void Update(int &idx) {
        if (idx == 0) {
            return;
        }
        nd[idx].siz = nd[idx].cnt + nd[nd[idx].l].siz + nd[nd[idx].r].siz;
    }

    inline int New(int val) {
        nd[++top].val = val;
        nd[top].cnt = nd[top].siz = 1;
        nd[top].pro = rand();
        return top;
    }

    Treap() {
        top = 0;
        _root = New(0x3f3f3f3f);
    }

    void RotateR(int &idx) {
        if (idx == 0 || nd[idx].l == 0) {
            return;
        }
        int q = nd[idx].l;
        nd[idx].l = nd[q].r;
        nd[q].r = idx;
        idx = q;
        Update(nd[idx].r);
        Update(idx);
    }

    void RotateL(int &idx) {
        if (idx == 0 || nd[idx].r == 0) {
            return;
        }
        int q = nd[idx].r;
        nd[idx].r = nd[q].l;
        nd[q].l = idx;
        idx = q;
        Update(nd[idx].l);
        Update(idx);
    }

    void Insert(int &idx, int val) {
        if (idx == 0) {
            idx = New(val);
            return;
        }
        if (nd[idx].val == val) {
            nd[idx].cnt++;
            Update(idx);
            return;
        }
        if (nd[idx].val > val) {
            Insert(nd[idx].l, val);
            if (nd[idx].pro < nd[nd[idx].l].pro) {
                RotateR(idx);
            }
        } else {
            Insert(nd[idx].r, val);
            if (nd[idx].pro < nd[nd[idx].r].pro) {
                RotateL(idx);
            }
        }
        Update(idx);
    }

    void Decrease(int &idx, int k) {
    	if (idx == 0) {
    		return;
    	}
        if (nd[idx].val + increase - k < minSal) {
            leave += nd[nd[idx].l].siz + nd[idx].cnt;
            idx = nd[idx].r;
            Decrease(idx, k);
        } else {
            Decrease(nd[idx].l, k);
            if (nd[idx].pro < nd[nd[idx].l].pro) {
                RotateR(idx);
            } else if (nd[idx].pro < nd[nd[idx].r].pro) {
                RotateL(idx);
            }
            Decrease(nd[idx].r, k);
            if (nd[idx].pro < nd[nd[idx].l].pro) {
                RotateR(idx);
            } else if (nd[idx].pro < nd[nd[idx].r].pro) {
                RotateL(idx);
            }
        }
        Update(idx);
    }

    int GetValByRank(int idx, int rnk) {
        if (nd[nd[idx].l].siz >= rnk) {
            return GetValByRank(nd[idx].l, rnk);
        } else if (nd[nd[idx].l].siz + nd[idx].cnt >= rnk) {
            return nd[idx].val;
        } else {
            return GetValByRank(nd[idx].r, rnk - nd[nd[idx].l].siz - nd[idx].cnt);
        }
    }
};

Treap tr;

inline char ReadChar() {
	char c = getchar();
	while (c < 'A' || c > 'Z') {
		c = getchar();
	}
	return c;
}

inline int ReadInt() {
	char c = getchar();
	int x = 0;
	while (c < '0' || c > '9') {
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - 48;
		c = getchar();
	}
	return x;
}

void Solve() {
	srand(unsigned(time(NULL)));
	int q = ReadInt();
	minSal = ReadInt();
	for (int i = 1;i <= q;i++) {
		char opt = ReadChar();
		int x = ReadInt();
		switch (opt) {
			case 'I':
				if (x < minSal) {
					//leave++;
				} else {
					tr.Insert(tr._root, x - increase);
				}
				break;
			case 'A':
				increase += x;
				break;
			case 'S':
				tr.Decrease(tr._root, x);
				increase -= x;
				break;
			case 'F':
				//printf("siz=%d\n", tr.nd[tr._root].siz);
				if (tr.nd[tr._root].siz - 1 < x) {
					printf("-1\n");
					break;
				}
				int tmp = tr.GetValByRank(tr._root, tr.nd[tr._root].siz - x);
				if (tmp < 0x3f3f3f3f && tmp > -0x3f3f3f3f) {
					printf("%d\n", tmp + increase);
				} else {
					printf("-1\n");
				}
				break;
		}
	}
	printf("%d", leave);
}

int main() {
	Solve();
    return 0;
}
```
代码：`189line,4.2K。`
测评：`Accepted 100 862ms 10240KB`

---

## 作者：crashed (赞：3)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P1486)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近乎平衡树的模板题，不过这道题有一些处理的小技巧。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于所有员工同时加工资或者减工资的操作，我们可以用一个变量$\Delta$存储整体的变化量。也就是说，假如最开始一个人在档案里面工资为$k$，那么他的真实工资就是$k$；但现在，他的真实工资为$\Delta+k$。反过来也是，真实工资是$k$，那么档案工资就是$k-\Delta$。不难发现，$\Delta$最初应该是$0$。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且可以发现此时的最低工资标准就变成了$min+\Delta$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，每次$S$操作，先对$\Delta$进行修改。然后所有$<\Delta+min$的人都会离开。然后就可以用平衡树操作了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一些小细节。比如$F$求的是**第$k$大**而不是第$k$小。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用的是非旋$Treap$。
# 题目
```cpp
#include <cstdio>
#include <cstdlib>

#define random myRandom

const int MAXN = 100005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s < '0' || '9' < s ){ if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int ch[MAXN][2], val[MAXN], aux[MAXN], siz[MAXN], cnt[MAXN];
int N, rt, base, mn, nsiz;

void srd() { int a, *aa = &a; srand( ( unsigned long long ) aa ); }
int random() { return rand() * rand(); }
int newNode( const int nVal ) { val[++ nsiz] = nVal, aux[nsiz] = random(), siz[nsiz] = cnt[nsiz] = 1; return nsiz; }

void upt( const int u ) { siz[u] = siz[ch[u][0]] + siz[ch[u][1]] + cnt[u]; }

void splitVal( const int u, const int k, int &x, int & y )
{
	if( ! u ) { x = y = 0; return ; }
	if( val[u] <= k ) x = u, splitVal( ch[u][1], k, ch[u][1], y );
	else y = u, splitVal( ch[u][0], k, x, ch[u][0] );
	upt( u );
}

int merg( const int u, const int v )
{
	if( ! u || ! v ) return u + v;
	if( aux[u] < aux[v] ) { ch[u][1] = merg( ch[u][1], v ), upt( u ); return u; }
	else { ch[v][0] = merg( u, ch[v][0] ), upt( v ); return v; } 
}

void insert( const int nVal )
{
	int x, y, z;
	splitVal( rt, nVal - 1, x, y ), splitVal( y, nVal, z, y );
	if( z ) ++ cnt[z], upt( z ); else z = newNode( nVal );
	rt = merg( merg( x, z ), y );
}

int Kth( int k )
{
	for( int u = rt ; ; )
	{
		if( k <= siz[ch[u][0]] ) u = ch[u][0];
		else if( k <= siz[ch[u][0]] + cnt[u] ) return val[u];
		else k -= siz[ch[u][0]] + cnt[u], u = ch[u][1];
	}
}

int main()
{
	char op[5]; int x, left = 0, icnt = 0, u, v;
	read( N ), read( mn );
	while( N -- )
	{
		scanf( "%s%d", op, &x );
		if( op[0] == 'I' ) 
		{
			if( x < mn ) { continue; }
			icnt ++, insert( x - base );
		}
		if( op[0] == 'A' ) base += x;
		if( op[0] == 'S' )
		{
			base -= x;
			splitVal( rt, mn - base - 1, u, v );
			rt = v, left += siz[u]; 
		}
		if( op[0] == 'F' ) write( icnt - left < x ? -1 : ( Kth( icnt - left - x + 1 ) + base ) ), putchar( '\n' );
	}
	write( left ), putchar( '\n' );
	return 0;
}
```

---

## 作者：LiGuanlin1124 (赞：3)

这题坑死我了。

**最后一句话的意思是工资不够直接退。**

自我感觉代码和别人的不太一样。

    #include<ctime>
    #include<cstdio>
    #include<cstdlib>
    #include<algorithm>
    using namespace std;
    #define N 100050
    int n,m,rt,tot;
    char ch[2];
    struct Treap
    {
        int ls,rs;
        int vl,rnd,siz,w;
    }tr[N];
    void update(int u)
    {
        tr[u].siz = tr[tr[u].ls].siz+tr[tr[u].rs].siz+tr[u].w;
    }
    void lturn(int &x)
    {
        int y = tr[x].rs;
        tr[x].rs=tr[y].ls;
        tr[y].ls=x;
        tr[y].siz=tr[x].siz;
        update(x);
        x = y;
    }
    void rturn(int &x)
    {
        int y = tr[x].ls;
        tr[x].ls =tr[y].rs;
        tr[y].rs = x;
        tr[y].siz = tr[x].siz;
        update(x);
        x = y;
    }
    void insert(int &k,int x)
    {
        if(!k)
        {
            k=++tot;
            tr[k].vl = x;
            tr[k].rnd = rand();
            tr[k].siz = tr[k].w = 1;
            return ;
        }
        tr[k].siz++;
        if(tr[k].vl==x)
        {
            tr[k].w++;
        }else if(x>tr[k].vl)
        {
            insert(tr[k].rs,x);
            if(tr[tr[k].rs].rnd<tr[k].rnd)lturn(k);
        }else
        {
            insert(tr[k].ls,x);
            if(tr[tr[k].ls].rnd<tr[k].rnd)rturn(k);
        }
    }
    int cnt;
    void deal(int &k)//特殊操作，非普通删除
    {
        if(!k)return ;
        if(tr[k].vl>=m)//若当前点权值不小于m则找左子树
        {
            deal(tr[k].ls);
            update(k);
            return ;
        }
        cnt+=(tr[tr[k].ls].siz+tr[k].w);//先删左子树和当前点
        k = tr[k].rs;//将其父亲的儿子k改为k的右儿子
        deal(k);
        update(k);
    }
    int query(int u,int k)
    {
        int t = tr[tr[u].rs].siz;
        if(t>=k)return  query(tr[u].rs,k);
        else if(k<=t+tr[u].w)return tr[u].vl;
        else return query(tr[u].ls,k-t-tr[u].w);
    }
    int main()
    {
        srand(time(NULL));
        scanf("%d%d",&n,&m);
        int m0  = m;
        for(int x,i=1;i<=n;i++)
        {
            scanf("%s%d",ch,&x);
            if(ch[0]=='I')
            {
                if(x<m0)continue;
                insert(rt,x+m-m0);
            }else if(ch[0]=='A')//这里的A和S是反向操作
            {
                m-=x;
            }else if(ch[0]=='S')
            {
                m+=x;
                deal(rt);
            }else if(ch[0]=='F')
            {
                if(tr[rt].siz<x)
                {
                    printf("-1\n");
                    continue;
                }
                printf("%d\n",query(rt,x)+(m0-m));
            }
        }
        printf("%d\n",cnt);
        return 0;
    }


---

## 作者：noiplao (赞：2)

# 权值线段树的做法

其实这题题解里线段树已经泛滥了......我也是冲着练线段树来的

然后写了三个小时 ~~我太弱了~~

线段树的思路想必大家都会了

这里就给大家讲一些恶心的细节：

1. $\color{red}\text{线段树的板子不能打错}$ （蒟蒻边界条件写错差点去世）

2. 刚进来就走的人是不算在离开的人的里面的！（40pts的线段树党注意了）
```
题目描述：
如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内
```
3. 线段树大小开八倍（权值有正负，值域要开正负maxn）

4. 进来出去的边界条件非常恶心不要写错！

然后就可以

$\color{green}\text{AC}$

~~markdown颜色好丑的说~~

附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1600010;//八倍
const int maxN=150010;//虽然理论是200000但实测150000可以过
int c[N],lson[N],rson[N],cnt=0,root;
int n,bnd,delta=0;
inline void upd(int x)
{
	c[x]=c[lson[x]]+c[rson[x]];
}
inline void ins(int &x,int p,int add,int l,int r)
{
	if(!x)
		x=++cnt;
	if(l==r)
	{
		c[x]+=add;
		return; 
	}
	int mid=(l+r)>>1;
	if(p<=mid)
		ins(lson[x],p,add,l,mid);
	else
		ins(rson[x],p,add,mid+1,r);
	upd(x);
}
inline int ask(int x,int p,int l,int r)
{
	if(r<bnd)
		return -1;
	if(l==r)
		return l;
	int mid=(l+r)>>1;
	if(c[rson[x]]>=p)
		return ask(rson[x],p,mid+1,r);
	else
		return ask(lson[x],p-c[rson[x]],l,mid);
}
inline void mod(int x,int l1,int r1,int l,int r)
{
	if(!x)return;
	if(l>r1||r<l1)return; //边界条件不要写错
	if(l==r)
	{
		c[x]=0;
		return;
	}
	int mid=(l+r)>>1;
	mod(lson[x],l1,r1,l,mid);
	mod(rson[x],l1,r1,mid+1,r);
	upd(x);
}
inline int query(int x,int l1,int r1,int l,int r)
{
	if(!x)return 0;
	if(l>r1||r<l1)
		return 0;
	if(l>=l1&&r<=r1)
		return c[x];
	int mid=(l+r)>>1;
	return query(lson[x],l1,r1,l,mid)+query(rson[x],l1,r1,mid+1,r);	
} 
int main()
{	
//	freopen("testdata.in","r",stdin);
//	freopen("testdata2.out","w",stdout);
	memset(c,0,sizeof(c));
	memset(lson,0,sizeof(lson));
	memset(rson,0,sizeof(rson)); 
	int t1,ans=0;
	char ch;
	scanf("%d%d",&n,&bnd);
	for(int i=1;i<=n;i++)
	{
		scanf(" %c",&ch);
		scanf("%d",&t1); 
		switch(ch)
		{
			case'I':
			if(t1-delta>=bnd)
				ins(root,t1-delta,1,-maxN,maxN);
//			else
//				ans++;//加了就会去世
			break;
			case'A':delta+=t1;
			bnd-=t1;
			break;
			case'S':delta-=t1;bnd+=t1;
			ans+=query(root,bnd-t1,bnd-1,-maxN,maxN);
			mod(root,bnd-t1,bnd-1,-maxN,maxN);
			break;
			case'F':int temp=ask(root,t1,-maxN,maxN);
			printf("%d\n",temp==-1?-1:(temp+delta));//特判-1
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：Mosher (赞：2)

#### 第一次被玄学怕了，调了几天，QAQ

**正文：**
1. 目测：不难看出是一道平衡树的题，于是我就码上了Splay（对于这道题简单，但难调，因为不会Treap）

2. 思路：插入一个delta变量，树中的数皆为相对delta的值，当然加入边界INT_MAX，防出错

   即：
```cpp
	I命令：插入x-delta
	A命令：delta+x
	S命令：delta-x，并且低于下限mini的踢出，对于此可以插入一个mini-delta，一举处理完，但不要忘记及时更新
	F命令：正常查询，但注意+1，-1之类的
```
3. 代码不长但也请细致理解（我会将不同调试，修改的代码发上链接，你们可以比较AC与90、80的不同）

PS：[80](https://www.luogu.org/paste/fiulpphe)，[90](https://www.luogu.org/paste/8a9n4l2y)（当然感谢[亲爱的同桌：秦岭秋风大佬](https://www.luogu.org/space/show?uid=109396)，帮我调了80,90的码，虽然调到90跑了，最后还是第二天，我又改改，重写，才AC的，QAQ）

**Code（AC）：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
const int maxn=1e5+5;
int delta,n,mini,ncnt,tot,retot,rt;
int cnt[maxn],sz[maxn],val[maxn],son[maxn][2],f[maxn],tot_now;

il int read(){
	int x=0,f=1;char a=getchar();
	while(!isdigit(a)) {if(a=='-') f=-1;a=getchar();}
	while(isdigit(a)) {x=x*10+a-'0';a=getchar();}
	return x*f;
}

il bool chk(int x){
	return son[f[x]][1]==x;
}

il void pushup(int x){
	sz[x]=sz[son[x][0]]+sz[son[x][1]]+cnt[x];
}

il void rotate(int x){
	int y=f[x],z=f[y],k=chk(x),w=son[x][k^1];
	son[y][k]=w;f[w]=y;
	son[z][chk(y)]=x;f[x]=z;
	son[x][k^1]=y;f[y]=x;
	pushup(y);pushup(x);
}

il void splay(int x,int goal=0){
	while(f[x]!=goal){
		int y=f[x],z=f[y];
		if(z!=goal){
			if(chk(x)==chk(y)) rotate(y);
			else rotate(x);
		}
		rotate(x);
	}
	if(!goal) rt=x;
}

il void find(int x){
	int cur=rt;
	while(son[cur][x>val[cur]]&&x!=val[cur]) cur=son[cur][x>val[cur]];
	splay(cur);
}

il void insert(int x){
	int cur=rt,p=0;
	while(cur&&x!=val[cur]){
		p=cur;
		cur=son[cur][x>val[cur]];
	}
	if(cur) cnt[cur]++;
	else{
		cur=++ncnt;
		if(p) son[p][x>val[p]]=cur;
		son[cur][0]=son[cur][1]=0;
		f[cur]=p;val[cur]=x;
		cnt[cur]=sz[cur]=1;
	}
	splay(cur);
}

il int kth(int k){
	int cur=rt;
	while(1){
		if(k<=sz[son[cur][0]]) cur=son[cur][0];
		else if(k>sz[son[cur][0]]+cnt[cur]) k-=sz[son[cur][0]]+cnt[cur],cur=son[cur][1];
		else return cur;
	}
}

char op[3];
int main(){
	//freopen("in.txt","r",stdin);
	n=read();mini=read();
	insert(INT_MAX);//边界
	for(int i=1,x;i<=n;++i){
		scanf("%s",op);
		if(op[0]=='I'){
			x=read();
			if(x<mini)continue;
			insert(x-delta);tot++;
		}
		if(op[0]=='A'){
			x=read();delta+=x;
		}
		if(op[0]=='S'){
			x=read();
			delta-=x;
			find(mini-delta);//find的最后出来的可能是前驱，后继
			if(val[rt]<mini-delta) cnt[rt]=0;//若本身是前驱，自然也要踢出
			sz[son[rt][0]]=0;
			son[rt][0]=0;
			pushup(rt);//以上3行保证维护的及时以及正确
		}
		if(op[0]=='F'){
			x=read();
			find(INT_MAX);//保证正确，以免有地方更新有误，或不及时
			tot_now=sz[rt]-1;//有个不算的INT_MAX
			if(x>tot_now) {puts("-1");continue;}
			else printf("%d\n",val[kth(tot_now-x+1)]+delta);
		}
	}
	tot_now=sz[rt]-1;//上方影响的地方已修正，这里不必再find浪费时间
	printf("%d",tot-tot_now);
	return 0;
}
```

**写平衡树的题一定要注意准确性以及严谨性（敲黑板），不然玄学加身，陷入万劫不复之地（雾）**

rp++

---

## 作者：斯德哥尔摩 (赞：2)

经典平衡树问题，Treap,Splay,都可以做，寡人用了Treap。。。

只想说一句话：结构体指针怎么这么容易 RE 。。。

寡人调了2天 RE，终于过了，激动。。。

于是给后人一个参考。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,m,ans=0;//ans是离开公司的人数
struct node{
    node* son[2];//儿子节点
    int v,w,s,flag;
    node(){//初始化
        son[0]=son[1]=NULL;
        w=rand();
        v=0;
        s=flag=1;
    }
};
node* rt;//根节点
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
void maintain(node* &u){//上传
    u->s=u->flag;
    if(u->son[0]!=NULL)u->s+=u->son[0]->s;
    if(u->son[1]!=NULL)u->s+=u->son[1]->s;
}
void turn(node* &u,int f){//旋转，正常
    node* t=u->son[f^1];
    u->son[f^1]=t->son[f];
    t->son[f]=u;
    maintain(u);
    maintain(t);
    u=t;
}
void insert(node* &u,int x){//插入,正常
    if(u==NULL){
        u=new node;
        u->v=x;
        maintain(u);
        return;
    }
    int y=x>=u->v?1:0;
    insert(u->son[y],x);
    if(u->son[y]->w>u->w)turn(u,y^1);
    else maintain(u);
}
void remove(node* &u){//删除，这是改进版，建议重点理解
    if(u==NULL)return;
    if(u->v>=m)remove(u->son[0]);
    else{//就是这。。。
        if(u->son[0]!=NULL)ans+=u->son[0]->s;
        ans++;//根节点自己也要被删除
        u=u->son[1];//连上来
        remove(u);//递归下去
    }
    if(u!=NULL)maintain(u);
}
int sum(node* u,int k){//求 kth，也是改进版，因为比根小的值在左
    int rsons=0;//右子树大小
    if(u->son[1]!=NULL)rsons=u->son[1]->s;
    if(k>=rsons+1&&k<=u->flag+rsons)return u->v;
    if(k<=rsons)return sum(u->son[1],k);
    else return sum(u->son[0],k-u->flag-rsons);
}
void add(node* &u,int x){//暴力加（因为我懒到不想用 懒惰标记。。。）
    if(u==NULL)return;
    u->v+=x;
    if(u->son[0]!=NULL)add(u->son[0],x);
    if(u->son[1]!=NULL)add(u->son[1],x);//因为老是 RE，于是想出了这么个办(bao)法(li)
    return;
}
int main(){
    srand(987);//随机种子别忘了。。。
    char ch[2];
    int x;
    n=read();m=read();
    for(int cases=1;cases<=n;cases++){
        scanf("%s",ch);x=read();
        if(ch[0]=='I'){
            if(x>=m)
            insert(rt,x);
        }
        if(ch[0]=='A'){
            add(rt,x);//添加就直接加
        }
        if(ch[0]=='S'){
            add(rt,-x);//减就变成相反数，再删除
            remove(rt);
        }
        if(ch[0]=='F'){
            if(rt==NULL)printf("-1\n");//调了半天，只能乱搞。。。
            else if(x>rt->s||x<=0)printf("-1\n");
            else printf("%d\n",sum(rt,x));
        }
    }
    printf("%d\n",ans);//输出人数
    return 0;
}

```

---

## 作者：_Atyou (赞：2)

## 算法： 平衡树

------------

一棵左儿子大，右儿子小的平衡树

具体比较麻烦的操作是降工资，因为涉及到跳槽问题

先讲一下工资的处理方式：

大概就是弄一个量记录工资的变化量

因为新进公司的人前面工资加减与他无关，进平衡树时减去公司已有的工资变化量即可

然后就是略麻烦的降工资操作

其实蛮好想到的 加一个工资标准的节点

根据Splay的性质每次操作的节点会变成根节点

自然形成根的左子树大于工资标准，右子树小于工资标准

把右子树删掉就行

~~（果然还是太菜了）~~


代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
const int N = 300000 + 5, inf=0x3f3f3f3f;

int n, val[N], cnt[N], ch[N][2], size[N], f[N], rt, tot;

void clear(int x) {
    val[x]=cnt[x]=size[x]=f[x]=ch[x][0]=ch[x][1]=0;
}

int get(int x) {
    return ch[f[x]][1]==x;
}

void pushup(int x) {
    if (x) {
        size[x]=cnt[x];
        if (ch[x][0]) size[x]+=size[ch[x][0]];
        if (ch[x][1]) size[x]+=size[ch[x][1]];
    }
}

void rotate(int x) {
    int fa=f[x], gfa=f[fa], k=get(x);
    ch[fa][k]=ch[x][k^1]; f[ch[fa][k]]=fa;
    ch[x][k^1]=fa; f[fa]=x; f[x]=gfa;
    if (gfa) ch[gfa][ch[gfa][1]==fa]=x;
    pushup(fa); pushup(x); 
}

void splay(int x, int goal=0) {
    for (int fa; (fa=f[x])!=goal; rotate(x))
        if (f[fa]!=goal) rotate(get(x)==get(fa)?fa:x);
    if (!goal) rt=x;
}

void insert(int x) {
    if (!rt) { rt=++tot; val[tot]=x; cnt[tot]=size[tot]=1; f[tot]=ch[tot][0]=ch[tot][1]=0; return; }
    int p=rt, fa=0;
    while (1) {
        if (x==val[p]) { ++cnt[p], pushup(p), pushup(fa), splay(p); return; }
        fa=p; p=ch[p][x<val[p]];
        if (!p) { ++tot; val[tot]=x; cnt[tot]=size[tot]=1; f[tot]=fa; ch[tot][0]=ch[tot][1]=0; ch[fa][x<val[fa]]=tot; pushup(fa); splay(tot); return; }
    }
}

int rank(int x) {
    int p=rt, ans=0;
    while (1) {
        if (x>val[p]) p=ch[p][0];
        else {
             ans+=size[ch[p][0]];
             if (x==val[p]) { splay(p); return ans+1; }
             ans+=cnt[p]; p=ch[p][1];
        }
    }
}

int kth(int x) {
    int p=rt;
    while (1) {
        if (ch[p][0] && x<=size[ch[p][0]]) p=ch[p][0];
        else {
            int t=size[ch[p][0]]+cnt[p];
            if (x<=t) return val[p];
            x-=t; p=ch[p][1];
        }
    }
}

int pre() { int p=ch[rt][0]; while (ch[p][1]) p=ch[p][1]; return p; } 
int nxt() { int p=ch[rt][1]; while (ch[p][0]) p=ch[p][0]; return p; }

void del(int x) {
    rank(x);
    if (cnt[rt]>1) { --cnt[rt]; pushup(rt); return; }
    if (!ch[rt][0] && !ch[rt][1]) { clear(rt); rt=0; return; }
    if (!ch[rt][0]) { int ort=rt; rt=ch[rt][1]; f[rt]=0; clear(ort); return; }
    else if (!ch[rt][1]) { int ort=rt; rt=ch[rt][0]; f[rt]=0; clear(ort); return; }
    int ort=rt; int nrt=pre();
    splay(nrt);
    ch[rt][1]=ch[ort][1]; f[ch[rt][1]]=rt; clear(ort);
    pushup(rt);
}

int delta, low, leftnum; char opt[2];

int main() {
    scanf("%d%d", &n, &low);
    for (reg int i=1; i<=n; ++i) {
        int k;
        scanf("%s %d", opt, &k);
        if (opt[0]=='I') {
            if (k<low) continue;
            insert(k-delta); continue;
        }
        if (opt[0]=='A') { delta+=k; continue; }
        if (opt[0]=='S') {
            delta-=k;
            int x=low-delta;
            insert(x); leftnum+=size[ch[rt][1]];
            ch[rt][1]=0;
            pushup(rt);
            del(x); continue;
        }
        if (opt[0]=='F') {
            int x=size[rt];
            if (x<k) { printf("-1\n"); continue; }
            printf("%d\n", kth(k)+delta); continue;
        }
    }
    printf("%d\n", leftnum);
    return 0;
}

```

这题如果会FHQ—Treap的话推荐用FHQ-Treap来写，因为FHQ-Treap实现删子树的操作是相当直观的

如果会pb_ds的大佬用pb_ds代码更简洁了。初学者不建议用这种东西偷懒，毕竟学会算法比AC更重要


---

## 作者：墨尔 (赞：2)

不会写平衡树，这题用线段树打过的orz看到没有线段树的题解就来贡献一波。

注意到员工工资最多200000，可以维护一个[-200000,200000]的区间，每个数看成一个桶，一个工资为i的员工扔到一个下标为i的桶里，查询[min,200000]的区间，当工资增的时候，相当于把查询的区间整体左移，减的时候同理，但要注意把[-200000,min-p]清空（p是偏移量），统计清除人数。注意的是初始工资低于min直接走掉的人不计入答案……我也不知道为什么……

```cpp
#include<cstdio>
int tag[1600005],n,p,ans,tot,min,s,t,L=-200005,R=200000,f[1600005],k;
char c[3];
void modify(int l,int r,int id)
{
    f[id]++;
    if(l==r)return;
    if(tag[id])
     tag[id<<1]=tag[id<<1|1]=1,tag[id]=0,
     f[id<<1]=f[id<<1|1]=0;
    int mid=(l+r)>>1;
    if(s<=mid)modify(l,mid,id<<1);else modify(mid+1,r,id<<1|1);
}
void modify1(int l,int r,int id)
{
    if(s<=l&&r<=t){ans+=f[id];f[id]=0;tag[id]=1;return;}
    if(tag[id])
     tag[id<<1]=tag[id<<1|1]=1,tag[id]=0,
     f[id<<1]=f[id<<1|1]=0;
    int mid=(l+r)>>1;
    if(s<=mid)modify1(l,mid,id<<1);
    if(t>mid)modify1(mid+1,r,id<<1|1);
    f[id]=f[id<<1]+f[id<<1|1];
}
int query(int l,int r,int id)
{
    if(f[id]<k)return -1;
    if(l==r)return l+p;
    if(tag[id])
     tag[id<<1]=tag[id<<1|1]=1,tag[id]=0,
     f[id<<1]=f[id<<1|1]=0;
    int mid=(l+r)>>1;
    if(k<=f[id<<1|1])return query(mid+1,r,id<<1|1);
    k-=f[id<<1|1];return query(l,mid,id<<1);
}
int main()
{
    scanf("%d%d",&n,&min);
    for(int i=1;i<=n;i++)
    {
        scanf("%s%d",c,&k);
        if(c[0]=='I'&&k>=min)s=k-p,modify(L,R,1);else
        if(c[0]=='A')p+=k;else
        if(c[0]=='S')p-=k,s=L,t=min-p-1,modify1(L,R,1);else
        if(c[0]=='F')printf("%d\n",query(L,R,1));
    }
    printf("%d\n",ans);
} 
```

---

## 作者：first_fan (赞：1)

利用最近学的数据结构SBT过了此题，故来讲讲节点大小平衡树的做法。[[戳我了解Size-Balanced-Tree](https://www.luogu.org/blog/firstfan/size-balanced-tree)]

这道题考察了大部分平衡树的操作，如插入、删除、查第k大元素等，所以可以视为弱化版的模板。

此题特别的一点就是要用一个变量统计一下所有成员的工资，一个比较妙的操作是：在员工加入后直接存储他与最低工资的差值即可

简析一下四种操作怎么处理：

```cpp
1.插入权值为k-min的结点

2.把SBT上所有结点的值加k

3.把SBT上所有结点的值减k，减完后把低于min的结点删除。

4.查询SBT第k大，可以转化为SBT第(siz-k)小。如果范围越树尺寸输出-1就好。
```

最后，请注意一个**坑点**：在加入新成员的时候，要注意如果他一来就不符合条件，就直接~~劝退~~不insert即可。

此处未对SBT进行封装，简洁明了，便于理解。

```cpp
#include <bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;

int read()
{
	int num=0;
	int flg=1;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
		{
			flg=-1;
		}
		c=getchar();
	}
	while(isdigit(c))
	{
		num=(num<<1)+(num<<3)+(c^48);
		c=getchar();
	}
	return num*flg;
}

const int maxn=1e6+7;

#define ls(x) (t[x].l)
#define rs(x) (t[x].r)
struct SBT
{
	int val;
	int l;
	int r;
	int siz;
} t[maxn];

int rt=0;
int cnt=0;

void lrot(int &x)
{
	int y=rs(x);
	rs(x)=ls(y);
	ls(y)=x;
	t[y].siz=t[x].siz;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	x=y;
}

void rrot(int &x)
{
	int y=ls(x);
	ls(x)=rs(y);
	rs(y)=x;
	t[y].siz=t[x].siz;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	x=y;
}

void maintain(int &x,bool lr)
{
	if(!lr)
	{
		if(t[ls(ls(x))].siz>t[rs(x)].siz)
		{
			rrot(x);
		}
		else if(t[rs(ls(x))].siz>t[rs(x)].siz)
		{
			lrot(ls(x));
			rrot(x);
		}
		else
		{
			return ;
		}
	}
	else
	{
		if(t[rs(rs(x))].siz>t[ls(x)].siz)
		{
			lrot(x);
		}
		else if(t[ls(rs(x))].siz>t[ls(x)].siz)
		{
			rrot(rs(x));
			lrot(x);
		}
		else
		{
			return ;
		}
	}
	maintain(ls(x),0);
	maintain(rs(x),1);
	maintain(x,1);
	maintain(x,0);
}

void insert(int &x,int val)
{
	if(!x)
	{
		x=++cnt;
		t[x].val=val;
		t[x].siz=1;
		return ;
	}
	t[x].siz++;
	if(val<t[x].val)
	{
		insert(ls(x),val);
	}
	else
	{
		insert(rs(x),val);
	}
	maintain(x,val>=t[x].val);
}

int del(int &x,int val)
{
	t[x].siz--;
	int res=0;
	if(val==t[x].val||(val<t[x].val&&!ls(x))||(val>t[x].val&&!rs(x)))
	{
		res=t[x].val;
		if(!ls(x)||!rs(x))
		{
			x=ls(x)+rs(x);
		}
		else
		{
			t[x].val=del(ls(x),t[x].val+1);
		}
		return res;
	}
	if(val<t[x].val)
	{
		res=del(ls(x),val);
	}
	else
	{
		res=del(rs(x),val);
	}
	return res;
}

int kth(int &x,int val)
{
	if(val==t[ls(x)].siz+1)
	{
		return t[x].val;
	}
	else if(val<=t[ls(x)].siz)
	{
		return kth(ls(x),val);
	}
	else
	{
		return kth(rs(x),val-t[ls(x)].siz-1);
	}
}

int main()
{
	int n=read();
	int lim=read();
	int ans=0;
	int tot=0;
	int add=0;
	rt=0;
	int tt=0;
	t[0].siz=0;
	for(ri i=1; i<=n; i++)
	{
		string s;
		cin>>s;
		int k=read();
		if(s[0]=='I'&&k>=lim)
		{
			insert(rt,k-add);
			++tot;
		}
		if(s[0]=='A')
		{
			add+=k;
		}
		if(s[0]=='S')
		{
			int j;
			add-=k;
			while(tot&&(j=kth(rt,1))+add<lim)
			{
				del(rt,j);
				--tot;
				++ans;
			}
		}
		if(s[0]=='F')
		{
			if(k>tot)
			{
				puts("-1");
			}
			else
			{
				printf("%d\n",kth(rt,tot-k+1)+add);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Treaker (赞：1)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 平衡树（Splay）
这里我用了Splay，好像FHQ（防火墙）更方便。但是我能插入inf节点啊啊

这里我们肯定不能全部加上或减去，所以我们开一个delta变量来记录整体情况。

手玩一下，你就知道插入一个新节点应该加delta还是减delta了

这里查询的是第K大（大大大），不是第K小，但是我们可以用总的减去k，得到他是第几小。就可以用了。。。

考虑，只有减工资时会有人离开，所以我们不断找最低工资的前驱，删除，重复。

指针大法吼啊！！！

完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int inf = 2147483647;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , delta , sum = 1;
struct Splay
{
	struct node
	{
		node *ch[2] , *fa;
		int val , size;
		node(node *fa = NULL,int val = 0) : fa(fa) , val(val) {ch[0] = ch[1] = NULL;size = 1;}
		inline bool isr() {return this == fa -> ch[1];}
		inline int rk() {return 1 + (ch[0] ? ch[0] -> size : 0);}
		inline void up() {size = 1 + (ch[0] ? ch[0] -> size : 0) + (ch[1] ? ch[1] -> size : 0);}
	}*root;
	Splay() {root = NULL;}
	inline void rot(node *x)
	{
		bool k = x -> isr();
		node *y = x -> fa , *z = y -> fa , *w = x -> ch[!k];
		if(y == root) root = x;
		else z -> ch[y -> isr()] = x;
		x -> fa = z; y -> fa = x;
		x -> ch[!k] = y; y -> ch[k] = w;
		if(w) w -> fa = y;
		y -> up(); x -> up();
	}
	inline void splay(node *x)
	{
		while(x != root)
		{
			if(x -> fa != root) rot(x -> isr() ^ x -> fa -> isr() ? x : x -> fa);
			rot(x);
		}
	}
	node* merge(node *x,node *y,node *fa)
	{
		if(x) x -> fa = fa;
		if(y) y -> fa = fa;
		if(!x || !y) return x ? x : y;
		return x -> ch[1] = merge(x -> ch[1],y,x) , x -> up() , x;
	}
	inline void insert(int val)
	{
		if(!root) return (void)(root = new node(NULL,val));
		node *p = root , *fa = NULL;
		while(p)
		{
			fa = p;
			p = p -> ch[val > p -> val];
		}
		p = new node(fa,val);
		fa -> ch[val > fa -> val] = p;
		splay(p);
	}
	inline void del(int val)
	{
		node *p = root;
		while(p && val != p -> val) p = p -> ch[val > p -> val];
		if(!p) return;
		splay(p); root = merge(p -> ch[0],p -> ch[1],NULL);
	}
	inline int rank(int val)
	{
		node *p = root , *lst = NULL; int res = 0;
		while(p)
		{
			lst = p;
			if(val <= p -> val)	p = p -> ch[0];
			else res += p -> rk() , p = p -> ch[1];
		}
		splay(lst);
		return res + 1;
	}
	inline int kth(int k)
	{
		node *p = root;
		while(p && p -> rk() != k)
		{
			if(k <= p -> rk()) p = p -> ch[0];
			else k -= p -> rk() , p = p -> ch[1];
		}
		splay(p);
		return p -> val;
	}
	inline int pre(int val)
	{
		node *p = root , *lst = NULL;
		while(p)
		{
			if(val > p -> val) lst = p , p = p -> ch[1];
			else p = p -> ch[0];
		}
		if(lst) return splay(lst) , lst -> val;
		return -2147483647;
	}
	inline void LOL()
	{
		n = read(); m = read();
		insert(inf);
		for(int i = 1 , k;i <= n;i ++)
		{
			char ch; cin >> ch; k = read();
			if(ch == 'I') if(k >= m) insert(k - delta) , sum ++;
			if(ch == 'A') delta += k;
			if(ch == 'S') {delta -= k;while(pre(m - delta) != -inf) del(pre(m - delta));}
			if(ch == 'F')
			{
				if(k > rank(inf) - 1) printf("-1\n");
				else printf("%d\n",kth(rank(inf) - k) + delta);
			}
		}
		printf("%d\n",sum - rank(inf));
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}

```


---

## 作者：G我就是菜G (赞：1)

## 本题 $FHQ\;Treap$ 写法

题面很裸，就是四个操作

1. 插入一个数（如果低于下限就不插入）
1. 当前存在的所有数加上一个值
3. 当前存在的数减去一个值，如果有低于下限值得数则删除
4. 查询当前**第 $k$ 大**的数（注意是**第 $k$ 大**）

最后还要输出删除了多少数

我们发现 $1,4$ 操作平衡树都能在 $\log$ 的时间复杂度中解决

至于 $2,3$ 操作，我们用一般方法做要遍历所有数字，复杂度为 $O(n)$

**思考：是否能运用 $lazytag$ 的思想**

用一个 $delta$ 变量储存其变化量，插入数字时判断是否低于下限，如果低于则不插入，否则插入 $x-delta$

判断时与 $min-delta$ 比较大小，同时我们发现 $t[x]<min-delta$ 时，可以直接删除 $son[x][0]$（节点 $x$ 的左子树），$ans$ 加上 $size[son[x][0]]+1$

查找时找 $size[root]-x$ 就行了（由于一开始插入了一个 $INT\_MAX$，所以查找的是 $size[root]-x-1+1$）

其余的用平衡树搞就行了

### 代码如下

```cpp
#include <bits/stdc++.h>
#define random(x) rand()*rand()%x
#define INF random(30000010)+10000010
#define N 4000010
using namespace std;

int size[N],t[N],heap[N],son[N][2];
int n,x,cnt,root,ans,_min,delta;
char c;

void add(int val){t[++cnt]=val;size[cnt]=1;heap[cnt]=random(INF);}

void update(int x)
{
    size[x]=size[son[x][0]]+size[son[x][1]]+1;
}

void split(int now,int &a,int &b,int val)
{
    if (!now) {a=0,b=0;return;}
    if (t[now]<=val) a=now,split(son[now][1],son[a][1],b,val);
    else b=now,split(son[now][0],a,son[b][0],val);
    update(now);
}

void merge(int &now,int a,int b)
{
    if (a==0 || b==0) {now=a+b;return;}
    if (heap[a]<heap[b]) now=a,merge(son[now][1],son[a][1],b);
    else now=b,merge(son[now][0],a,son[b][0]);
    update(now);
}

void insert(int val)
{
    int x=0,y=0;
    split(root,x,y,val);
    add(val);
    int o=cnt;
    merge(x,x,o);merge(root,x,y);
}

int findnum(int now,int x)
{
    if (size[son[now][0]]+1==x) return t[now];
    if (size[son[now][0]]>=x) return findnum(son[now][0],x);
    else return findnum(son[now][1],x-size[son[now][0]]-1);
}

void check()
{
    int x=0,y=0;
    split(root,x,y,_min-delta-1);  //直接将树按 min-delta-1 劈成两棵，将以 x 为根的树直接删除
    ans+=size[x];
    root=y;
}

int main()
{
    scanf("%d%d",&n,&_min);
    add(INT_MAX);root=1;heap[root]=-INT_MAX;
    for (int i=1;i<=n;i++)
    {
        c=getchar();
        while (c<'A' || c>'Z') c=getchar();
        scanf("%d",&x);
        if (c=='I') if (x>=_min) insert(x-delta);
        if (c=='A') delta+=x;
        if (c=='S') delta-=x,check();
        if (c=='F') if (size[root]<=x) printf("-1\n");
                    else printf("%d\n",findnum(root,size[root]-x)+delta);
    }
    printf("%d\n",ans);
    return 0;
}    \\代码其他部分上面说的很清楚了，这里不做赘述
```

---

## 作者：arfa (赞：1)

[$\texttt{ARFA cnblogs}$](https://www.cnblogs.com/FibonacciHeap/articles/10599600.html)

$\texttt{NOI2004}$ 老贼丧天良!!!!

先说一下思路。首先我们记录一个 $money$ 代表我们现在的工资起伏状况 (很显然是一个全局的标记)。我们要知道,前面的员工的工资被减了,后面的是不会减的,所以我们插入的时候插入一个 $val-money$,提取的时候用 $tree_x+money$ 就可以了。

写的是 $\texttt{FHQTreap}$,所以删除的时候直接把小于底线的子树抛弃。

您需要注意的是 :

- ``if (tree[now]+money)<val then`` 您是否写成了 ``<=``
- ``Insert`` 中的 ``Split(root,x,y,val+money);`` 您是否写成了 ``Split(root,x,y,val);`` (如果是,你可能会看到 $7$ 的左右儿子都是 $6$ 的神奇情况)
- ``Delete`` 中的 ``Split(root,x,y,val);`` 您是否写成了 ``Split(root,x,y,val-1);``。
- `` if k>=border then Insert(k-money); `` 您是否写成了 `` if k<border then inc(outsize) else Insert(k-money); ``,请认真阅读最后一句话。
- ``Query`` 中的 ``if k<=0 then exit(-1);`` 加了没有。

(这东西是显然可以 [$\texttt{AYH}$](https://www.luogu.org/blog/acking/guan-yu-pu-tong-ping-heng-shu-di-jun-tan-fu-za-du-di-you-hua) 优化的,那位说自己跑得飞快的同学要注意了)

```pascal
// luogu-judger-enable-o2
// FHQ Treap

Uses math;

Const
    total=100010 << 1;
    RP=23333;

var
    size,tree,heap:array[-1..total] of longint;
    son:array[-1..total,-1..2] of longint;
    i,j,m,n,k,root,money,border,outside:longint;
    order:char;

procedure Add(val:longint); begin inc(n); size[n]:=1; tree[n]:=val; heap[n]:=random(RP); end;

procedure Split(now:longint;var a,b:longint;val:longint);
begin
    if now=0 then begin a:=0; b:=0; exit; end;
    if (tree[now]+money)<val then
    begin a:=now; Split(son[now,1],son[a,1],b,val); end
    else begin b:=now; Split(son[now,0],a,son[b,0],val); end;
    size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;

procedure Merge(var now:longint;a,b:longint);
begin
    if (a=0)or(b=0) then begin now:=a+b; exit; end;
    if (heap[a]<heap[b]) then
    begin now:=a; Merge(son[now,1],son[a,1],b); end
    else begin now:=b; Merge(son[now,0],a,son[b,0]); end;
    size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;

procedure Insert(val:longint);
var x,y,o:longint;
begin
    x:=0; y:=0; Add(val); o:=n;
    Split(root,x,y,val+money); Merge(x,x,o); Merge(root,x,y);
end;

procedure Delete(val:longint);
var x,y:longint;
begin
    x:=0; y:=0; Split(root,x,y,val);
    inc(outside,size[x]); root:=y;
end;

function Query(now,k:longint):longint;
begin
    if k<=0 then exit(-1); Query:=0;
    if size[son[now,0]]+1=k then exit(tree[now]+money);
    if size[son[now,0]]>=k then Query:=Query(son[now,0],k) else
    Query:=Query(son[now,1],k-size[son[now,0]]-1);
end;

begin
    randomize; root:=1; Add(maxlongint div 843); heap[root]:=-maxlongint;
    readln(m,border); money:=0;
    for i:=1 to m do
    begin
        readln(order,k);
        if (order='I') then if k>=border then Insert(k-money); 
        if (order='A') then inc(money,k);
        if (order='S') then begin dec(money,k); Delete(border); end;
        if (order='F') then writeln(Query(root,size[root]-k));
    end;
    writeln(outside);
end.
```

---

## 作者：Isonan (赞：1)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P1486)

~~害的我去学了一下Fhq treap~~

这题首先一看就是平衡树

这个题要求删除所有值$\le min$的节点，很容易想到Fhq treap的split操作，每次减工资的时候split一下就行了，异常简单。

代码：

```cpp
#include <cstdio>
#include <cstdlib>

int val[200001],ch[200001][2],size[200001],pri[200001],tag,n,min,opt,x,y,tem,root,cnt,ans;
char cha;
void get(){cha=getchar();while(cha<'A'||cha>'Z')cha=getchar();}
void pushup(int x){size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}
int New(int x){
	val[++cnt]=x;
	pri[cnt]=rand()%1000000;
	size[cnt]=1;
	return cnt;
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(pri[x]<pri[y]){
		ch[x][1]=merge(ch[x][1],y);
		pushup(x);
		return x;
	}
	else{
		ch[y][0]=merge(x,ch[y][0]);
		pushup(y);
		return y;
	}
}
void split(int now,int k,int &x,int &y){
	if(!now)x=y=0;
	else{
		if(val[now]<=k)x=now,split(ch[now][1],k,ch[now][1],y);
		else y=now,split(ch[now][0],k,x,ch[now][0]);
		pushup(now);
	}
}
int findKth(int x){
	int u=root;
	while(size[ch[u][1]]!=x-1)
		if(size[ch[u][1]]>=x)u=ch[u][1];
		else x=x-size[ch[u][1]]-1,u=ch[u][0];
	return u;
}
int main(){
	srand(43278432); 
	scanf("%d%d",&n,&min);
	for(int i=1;i<=n;i++){
		get();
		scanf("%d",&tem);
		if(cha=='I'){
			if(tem<min)continue;
			split(root,tem-tag,x,y);
			root=merge(merge(x,New(tem-tag)),y);
		}
		else if(cha=='A')tag+=tem;
		else if(cha=='S')tag-=tem,split(root,min-tag-1,x,y),root=y,ans+=size[x];
		else size[root]<tem ? puts("-1") : printf("%d\n",val[findKth(tem)]+tag);
	}
	printf("%d\n",ans);
}
```

---

## 作者：bztMinamoto (赞：1)

发一篇splay的题解好了

四个操作

对于A和S操作，如果一个个更改工资，时间复杂度是O（n）的，绝对T。我们可以换个思路，与其更改工资，不如更改最低工资下限。记一个原工资下限和现工资下限，只要保证更改后工资-原工资下限=原工资-现工资下限就可以了（具体实现看代码）

另外，降工资的时候，记得把工资低于下限的删除（反正总共就n个节点，一个一个删也不会T）

插入新员工的时候，记得把新员工工资带进上面的式子，便于存储

询问时，根据上面式子，现工资=原工资-现工资下限+原工资下限，找一找再算一算

ps：为了方便，可以把平衡树调成左大右小的结构，因为查找的是第k大，即降序排列后的第k个

pps：我之前左小右大的时候一堆玄学错误……下载了数据发现和答案死都对不上……拿了个题解拍了一下发现下载的数据都是错的……

上代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
using namespace std;
const int N=100050,inf=0x3f3f3f3f;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
char buf[1<<15],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
int n,mn,k,ans;
struct Splay{
    struct node{
        int v,father,ch[2];
        int sum,recy;
    } e[N];
    int cnt,root;
    void pushup(int x){
        e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
    }
    int identify(int x){
        return e[e[x].father].ch[1]==x;
    }
    void connect(int x,int f,int son){
        e[x].father=f,e[f].ch[son]=x;
    }
    void rotate(int x){
        int y=e[x].father,z=e[y].father;
        int yson=identify(x),zson=identify(y);
        int b=e[x].ch[yson^1];
        connect(b,y,yson),connect(y,x,(yson^1)),connect(x,z,zson);
        pushup(y),pushup(x);
    }
    void splay(int x,int goal){
        while(e[x].father!=goal){
            int y=e[x].father,z=e[y].father;
            if(z!=goal)
            (identify(x)^identify(y))?rotate(x):rotate(y);
            rotate(x);
        }
        if(goal==0) root=x;
    }
    void push(int v){
        int now=root,f=0;
        while(now&&e[now].v!=v){
            f=now;
            now=e[now].ch[v<e[now].v];
        }
        if(now) e[now].recy++;
        else{
            now=++cnt;
            if(f) e[f].ch[v<e[f].v]=now;
            e[cnt].ch[0]=e[cnt].ch[1]=0;
            e[cnt].father=f,e[cnt].v=v;
            e[cnt].recy=e[cnt].sum=1;
        }
        splay(now,0);
    }
    void find(int v){
        int now=root;
        if(!now) return;
        while(e[now].ch[v<e[now].v]&&v!=e[now].v)
        now=e[now].ch[v<e[now].v];
        splay(now,0);
    }
    int Next(int v,int f){
        find(v);
        int now=root;
        if((e[now].v<v&&f)||(e[now].v>v&&!f)) return now;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return now;
    }
    void pop(int v){
        int lower=Next(v,1);
        int upper=Next(v,0);
        splay(upper,0),splay(lower,upper);
        e[lower].ch[0]=0;
        pushup(lower),pushup(upper);
    }
    int get(int v){
        int now=root;
        while(true){
            int y=e[now].ch[0];
            if(v>e[y].sum+e[now].recy){
                v-=e[y].sum+e[now].recy;
                now=e[now].ch[1];
            }
            else if(e[y].sum>=v) now=y;
            else return e[now].v;
        }
    }
    void insert(int v){
    	if(v<mn) return;
    	v+=k-mn;
    	push(v);
	}
	void add(int v){
		k-=v;
	}
	void sub(int v){
		k+=v;
		int lower;
		while(e[(lower=Next(k,1))].v!=-inf)
		ans+=e[lower].recy,pop(e[lower].v);
	}
	void query(int v){
		++v;
		if(v>=e[root].sum) puts("-1");
		else{
			printf("%d\n",get(v)-k+mn);
		}
	}
    void init(){
    	cnt=root=0,push(inf),push(-inf);
    }
}F;
int main(){
    //freopen("testdata.in","r",stdin);
    //freopen("testdata.out","w",stdout);
    n=read(),mn=k=read(),F.init();
    while(n--){
    	char c;int v;
    	while(!isupper(c=getc()));
    	v=read();
    	switch(c){
    		case 'I':F.insert(v);break;
    		case 'A':F.add(v);break;
    		case 'S':F.sub(v);break;
    		case 'F':F.query(v);break;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Hades18 (赞：1)

-------------


在下使用的是splay，namespace中除了delete都是板子


---------------

这道题其实就是一个splay的板子题，适合于平衡树的新手练习。

我们注意到一个特性：标记都是全局的。此时我们就可以将全局标记打在splay的外面，splay中就不用打标记了！~~（亏我写了半天打标记的splay）~~

那min的限制怎么实现呢？我们在插入时可以先判一下，全局减时将累加上全局标记小于min的所有点都删掉。

树外-标记=树内，树内+标记=树外，由于我事先插了+inf与-inf，所以涉及size是会有些变化的。

**PS：如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内！！！**

**PS：如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内！！！**

**PS：如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内！！！**


Delete详解：

```cpp
//由于我们是要删除一段区间，我们可以将区间最小值的前驱旋至根，此时右子树恒大于区间最小值的前驱，我们再将区间最大值的后继旋至右子树根，此时右子树的左子树恒小于区间最大值的后继，此时右子树的左子树全都是我们要删的点，然后断开指针连接就行了。
inline void Del(int x)
{
    Nex(x,1);/*后继*/R int p=pos;
    Fin(-1e9);/*前驱*/Spl(p,rt);
    sum+=p[son][0][siz];
    son[p][0]=0;
    PU(p);PU(rt);/*更新size*/
}
```
总代码：

```cpp
//声明：a[b]等同于b[a],本文中有很多类似写法,查询的答案都为pos指向的点;
//如siz[son[son[rt][0]][1]]->rt[son][0][son][1][siz];
#include<cstdio>
#define N 500100
namespace Splay
{
    #define R register
    static int son[N][2],fat[N],key[N],val[N],siz[N],rt,tot,pos,sum;
    inline void PU(int x){siz[x]=son[x][0][siz]+son[x][1][siz]+val[x];}
    inline void Rot(int x)
    {
        R int y=fat[x],z=fat[y],k=son[y][0]==x;
        son[z][son[z][1]==y]=x;fat[x]=z;
        son[y][!k]=son[x][k];son[x][k][fat]=y;
        son[x][k]=y;fat[y]=x;PU(y);
    }
    inline void Spl(int x,int goal)
    {
        for(;fat[x]!=goal;Rot(x))
        {
            R int y=fat[x],z=fat[y];
            if(z!=goal)(son[y][0]==x)^(son[z][0]==y)?Rot(x):Rot(y);
        }PU(x);if(!goal)rt=x;
    }
    inline void Fin(int x)
    {for(pos=rt;son[pos][x>key[pos]]&&x!=key[pos];pos=son[pos][x>key[pos]]);Spl(pos,0);}
    inline void Nex(int x,int k)
    {
        Fin(x);if(!(key[pos]>x&&k||key[pos]<x&&!k))
        for(pos=son[pos][k];son[pos][!k];pos=son[pos][!k]);
    }
    inline void Ins(int x)
    {
        R int fa=0;
        for(pos=rt;pos&&key[pos]!=x;pos=son[pos][x>key[pos]])fa=pos;
        if(pos)++val[pos];else
        {
            pos=++tot;
            son[fa][x>key[fa]]=pos;
            son[pos][0]=son[pos][1]=0;
            fat[pos]=fa;key[pos]=x;val[pos]=siz[pos]=1;
        }Spl(pos,0);
    }
    inline void Del(int x)
    {
        Nex(x,1);R int p=pos;
        Fin(-1e9);Spl(p,rt);
        sum+=p[son][0][siz];
        son[p][0]=0;
        PU(p);PU(rt);
    }
    inline int Kth(int k)
    {
        if(k<2||k+1>siz[rt])return 0;//无解;
        for(pos=rt;;)
        {
            R int y=son[pos][0];
            if(k>siz[y]+val[pos])
            {
                k-=siz[y]+val[pos];
                pos=son[pos][1];
            }else
            if(siz[y]<k)return 1;
            else pos=y;
        }
    }
}using namespace Splay;
inline int read(){int x=0,f=0;register char ch=getchar();for(;ch<48||ch>57;ch=getchar())f|=ch=='-';for(;ch>47&&ch<58;ch=getchar())x=(x<<1)+(x<<3)+(ch^48);return f?-x:x;}
int main()
{
    char s[5];int now=0;
    Ins(-1e9);Ins(+1e9);
    int n=read(),minn=read();
    for(int i=0;i<n;++i)
    {
        scanf("%s",s);int k=read();
        switch(s[0])
        {
            case 'I':if(k>=minn)Ins(k-now);break;
            case 'A':now+=k;break;
            case 'S':now-=k;Del(minn-now-1);break;
            case 'F':printf("%d\n",Kth(siz[rt]-k)?key[pos]+now:-1);break;
        }
    }printf("%d\n",sum);
}
```

---

## 作者：chtomede (赞：1)

**做法：权值线段树**	~~有点慢，dalao可能看不上~~

题面有坑！！！新员工立即离开公司不被计算！！

权值线段树长度L~R维护L~R的工资

调整工资时，在权值线段树上整体移动数值显然不现实，所以得另辟蹊径：

由于调整工资是整体调整，而且每次操作后都只用删除工资低于下界的信息，所以考虑把下界min值进行反向调整，用一个变量shf记录工资的正向调整值的和，在输出的时候把查询的反回值加上shf即可。

为防止溢出，我们将搜索下届MIN与上界MAX设为-0x7fffffff/2与0x7fffffff/2

附上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAX=0x7fffffff/2,MIN=-0x7fffffff/2;
int n,imin,shf;
struct node
{
	node *lc,*rc;
	int cnt;
	node(){
		lc=rc=NULL;
		cnt=0;
	}
};
struct Segtree
{
	node *root;
	int tot;
	Segtree()
	{
		root=NULL;
		tot=0;
	}
	void ins(node *&k,int l,int r,int key)
	{
		if(k==NULL)	k=new node;
		if(l==r){
			k->cnt++;
			return;
		}
		int mid=(l+r)>>1;
		if(key<=mid)	ins(k->lc,l,mid,key);
		else	ins(k->rc,mid+1,r,key);
		k->cnt=0;
		if(k->lc)	k->cnt+=k->lc->cnt;
		if(k->rc)	k->cnt+=k->rc->cnt;
	}
	void del(node *&k,int l,int r)
	{
		if(!k)	return;
		int mid=(l+r)>>1;
		if(imin>mid)
		{
			if(k->lc)
			{
				tot+=k->lc->cnt;
				k->lc->cnt=0;
				k->lc=NULL;
			}
			if(imin>mid+1) del(k->rc,mid+1,r);
		}
		else del(k->lc,l,mid);
		k->cnt=0;
		if(k->lc)	k->cnt+=k->lc->cnt;
		if(k->rc)	k->cnt+=k->rc->cnt;
	}
	int ser(node *&k,int l,int r,int key)
	{
		if(!k||key>k->cnt)	return MIN;
		if(l==r)	return l;
		int mid=(l+r)>>1;
		if(k->rc)
		{
			if(k->rc->cnt>=key)	return ser(k->rc,mid+1,r,key);
			else	return ser(k->lc,l,mid,key-k->rc->cnt);
		}
		else	return ser(k->lc,l,mid,key);
	}
}T;
int main()
{
//	freopen("pay.in","r",stdin);
//	freopen("pay.out","w",stdout);
	T=Segtree();
	cin>>n>>imin;
	for(int i=1;i<=n;i++)
	{
		char op;
		int key;
		cin>>op>>key;
		if(op=='I')
		{
			if(key-shf>=imin)T.ins(T.root,MIN,MAX,key-shf);
		}
		if(op=='A')	shf+=key,imin-=key;
		if(op=='S')	shf-=key,imin+=key;
		if(op=='F')	
		{
			int x=T.ser(T.root,MIN,MAX,key);
			if(x!=MIN)	cout<<x+shf<<endl;
			else	cout<<-1<<endl;
		}
		T.del(T.root,MIN,MAX);
	}
	cout<<T.tot<<endl;
	return 0;
}
```

---

## 作者：lrqcs (赞：0)

考场上看出来这是平衡树弱化版，但我不会平衡树，不会 pb\_ds，也不想卡 vector 碰运气，所以想出来了这个 $O(n\log^2n+nS\log n)$ 的二分套树状数组写法（$S$ 为 `S` 操作总数）。
## soltion

注意到工资及其变动范围较小，所以我们为每个工资开一个桶，如果新加/减了几个人可以 $O(1)$ 修改。

注意到有 `S/A` 操作，所以要加偏移量。

注意到 `A` 操作不会走人，所以改一下偏移量就行。

注意到 `S` 操作很少，所以改完偏移量后我们暴力枚举每个人，能走就走。

注意到员工在公司时其相对其他老员工的工资差异不变，所以我们可以对于查询第 $k$ 大，插入每个人后用树状数组区间修改其后面的所有人的排名（加一），二分加单点查询排名确定最后答案。

效率还可以，最慢点 88ms/2.68MB；码量也较短，核心只有 43 行。
## code
```cpp
#include<stdio.h>
#include<vector>
#include<algorithm>
#define ci const int
#define int long long
#define getchar getchar_unlocked
#define N 300000
#define M 100000
inline ci re();const char getch();void pr(ci x);
void prs(ci x);void prn(ci x);
int n,mi,ad,lft,t[N+20],rnk[N+20];
std::vector<int>v;
inline void add(int x,ci w){for(;x<=N;x+=x&-x)rnk[x]+=w;}
inline ci qry(int x){int w=0;for(;x;x-=x&-x)w+=rnk[x];return w;}
void work(){
	n=re(),mi=re();
	char c;
	for(int i=1,k;i<=n;++i){
		c=getch(),k=re();
		if(c=='I'){
			if(k<mi)continue;
			if(!t[k-ad+M])v.push_back(k-ad+M);/*注意到加减偏移量时可能产生负数，所以要用1e5的偏移来将其改为非负*/
			++t[k-ad+M];add(k-ad+M,1);
		}else if(c=='A')ad+=k;
		else if(c=='S'){
			ad-=k;
			std::sort(v.begin(),v.end());
			int i,sz,p;
			for(i=0,sz=v.size(),p;i<sz;++i)
				if(p=v[i],p+ad<mi+M)
					lft+=t[p],add(p,-t[p]),t[p]=0;
				else break;
			if(!i)continue;
			for(int j=0;i<sz;++i,++j)
				v[j]=v[i],v[i]=0;
			while(!v.empty()&&!v.back())v.pop_back();
		}else{
			if(k>qry(N))prn(-1);
			else{
				k=qry(N)-k+1;/*树状数组上存的排名与实际求的方向相反*/
				int l=1,r=N,mid;
				while(l<r){
					mid=l+r>>1;
					if(k>qry(mid))l=mid+1;
					else r=mid-1;
				}
				while(k<=qry(mid))--mid;
				while(k>qry(mid))++mid;/*怕二分写挂的微调*/
				prn(ad+mid-M);
			}
		}
	}prn(lft);
}
signed main(){
	for(int T=1||re();T--;)work();
}
void pri(ci x){if(x>9)pri(x/10);putchar(x%10^48);}
void pr(ci x){if(x<0)putchar('-'),pri(-x);else pri(x);}
void prs(ci x){pr(x);putchar(32);}
void prn(ci x){pr(x);putchar(10);}
const char getch(){
	char c=getchar();
	while(!(c>47&&c<58||c>96&&c<122||c>64&&c<91))c=getchar();
	return c;
}
inline ci re(){
	int x=0;char c=getchar(),f=0;
	while(c<48||c>57)f|=(c=='-'),c=getchar();
	while(c>47&&c<58)x=x*10+(c^48),c=getchar();
	return f?-x:x;
}
```

---

## 作者：monstersqwq (赞：0)

### 题意：

需要维护一个初始为空的集合，给出一个下界 $min$，支持四种操作：

- 插入一个数，若小于下界则不插入
- 把集合中所有的数都加上同一个数
- 把集合中所有的数都减去同一个数，并删除所有操作后小于下界的数
- 查询集合中第 $k$ 大的数

### 思路：

这种不带区间翻转的整体第 $k$ 大/小通常可以使用树状数组代替平衡树来完成。

插入查询都很好办，但是如果还要全局加减就不太好搞，考虑转换思路为：全局加就是降低下界，全局减就是增高下界，记会被修改的下界为 $nowmin$，那么插入时就插入 $k-min+nowmin$，查询时就输出 $ans-nowmin+min$。

有一个比较大的问题就是增高下界时需要删除一些元素，我们知道理论上每个元素最多被删除一次，只要能够每次快速的找到需要删除的元素即可做到删除的整体 $O(n\times \text{单次删除复杂度})$。为了达成上面的条件，考虑使用优先队列完成，优先队列里存储当前在集合中的元素的编号，每次增高下界时，不停提取出队头删除直到队头对应的数字大于等于下界。这种方法还可以顺利解决第二问。

现在我们把问题转换为了插入，删除，查询第 $k$ 大的数据结构，可以使用 BIT 完成，做法如下：

首先看到数据范围不小且支持离线，于是 sort+unique+map 离散化一下，建立一棵权值 BIT，维护集合中某数字（其实是离散化后的编号）的个数，插入和删除直接可以照着普通 BIT 完成，查询第 $k$ 大采用类似倍增的思想实现，这里贴下部分代码：

```cpp
int findkth(int k)
{
	int res=0,ans=0;//ans存储当前res下有多少个数小于等于它
	for(int i=20;i>=0;i--)
	{
		res+=(1<<i);
		if(res>cnt||ans+c[res]>=k) res-=(1<<i);
		else ans+=c[res];//c即BIT
	}
	res++;
	return res;
}
```

三个操作都是单次 $O(\log n)$。

分析下复杂度：优先队列最多对每个数字操作两次，为 $O(n \log n)$，离散化 $O(n \log n)$，删除刚才分析过是 $O(n \log n)$，其他 BIT 操作是 $O(n \log n)$，于是总体还是 $O(n\log n)$，可以通过，并且不需要依赖增高和降低下界的特殊数据范围。

至此基本完成了该题，若还是没有明白权值 BIT 的做法，可以到[这里](https://www.luogu.com.cn/blog/Chanis/super-BIT2)来查看。

可能说的不是很清楚，也可以结合代码查看：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
int m;
ll lk,nowk;//注：这里lk存的是min，nowk存的是nowmin
int cnt,tmpcnt;//cnt存离散化后有多少不同的元素，tmpcnt存当前集合中有多少元素，查第k大时要用
struct ask
{
	string opt;
	ll k;
}que[300005];
ll peo[300005],b[300005];//离散化用（其实可以省掉peo，它没有什么用）
map<ll,int> mp;
priority_queue<int> q;
int c[300005],ansl;//ansl存第二问答案
bool cmp(ll qaq,ll qwq)
{
	return qaq>qwq;
}
int lowbit(int x)
{
	return x&-x;
}
void addd(int x,int k)//插入删除
{
	while(x<=cnt)
	{
		c[x]+=k;
		x+=lowbit(x);
	}
	return;
}
int findkth(int k)//查询第k小的编号（离散化时大数在前面）
{
	int res=0,ans=0;
	for(int i=20;i>=0;i--)
	{
		res+=(1<<i);
		if(res>cnt||ans+c[res]>=k) res-=(1<<i);
		else ans+=c[res];
	}
	res++;
	return res;
}
int main()
{
	cin>>m>>lk;
    nowk=lk;
	for(int i=1;i<=m;i++)
	{
		cin>>que[i].opt>>que[i].k;
		if(que[i].opt=="I"&&que[i].k>=lk)
		{
			cnt++;
			peo[cnt]=que[i].k-lk+nowk;
		}
		if(que[i].opt=="A")
		{
			nowk-=que[i].k;
		}
		if(que[i].opt=="S")
		{
			nowk+=que[i].k;
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		b[i]=peo[i];
	}
	nowk=lk;
	sort(b+1,b+cnt+1,cmp);
	cnt=unique(b+1,b+cnt+1)-b;
    cnt--;
    for(int i=1;i<=cnt;i++)
    {
    	mp[b[i]]=i;
	}
	for(int i=1;i<=m;i++)
	{
		if(que[i].opt=="I")
		{
			if(que[i].k<lk) continue;
			addd(mp[que[i].k-lk+nowk],1);//插入
			tmpcnt++;
			q.push(mp[que[i].k-lk+nowk]); //push进优先队列
		}
		if(que[i].opt=="A")
		{
			nowk-=que[i].k;
		}
		if(que[i].opt=="F")
		{
			if(tmpcnt<que[i].k)
			{
				cout<<"-1"<<endl;
				continue;
			}
			cout<<b[findkth(que[i].k)]-nowk+lk<<endl;
		}
		if(que[i].opt=="S")
		{
			nowk+=que[i].k;
			while(!q.empty())
			{
				int tmp=q.top();
				if(b[tmp]<nowk)//需要删除，进行操作
				{
					addd(tmp,-1);//删除
					q.pop();//从队列里删除
                    tmpcnt--;
                    ansl++;
				}
				else//大于等于nowmin，直接break
				{
					break;
				}
			}
		}
	}
    cout<<ansl<<endl;
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：0)

本题的主要部分为整体 $k$ 小值的查询和对所有现有值的变动。  
整体 $k$ 小值的解法还是很多的,像平衡树什么的都可以罢。窝打了个权值线段树,这样子可以很方便地实现在扣钱的时候离开公司的操作,用线段树的区间推平操作就好了。  
对于整体的加减,这里当然是用懒惰法。用一个标记记录下树中所有元素的修改量。相应地, $min$ 值也发生改变。新插入元素时由于没有经历过这些修改所以要在插入前扣掉这个修改量。  
为了防止线段树下标为负,我们对初始的树做一次"扣钱"操作,值为可能出现的扣钱的最小值的绝对值。该操作没有现实意义,只是为了防止线段树是下标为负。(也可以理解为对所有钱的值加上一个常数)  
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int SUM = 123456, SU = 110000;

int dat[SUM<<3], tag[SUM << 3];
inline void update(int p) {
	dat[p] = dat[p<<1] + dat[p<<1|1];
}
inline void spread(int p) {
	dat[p<<1] = dat[p<<1|1] = tag[p<<1] = tag[p<<1|1] = 0;
	tag[p] = -1;
}
void insert(int p, int lp, int rp, int x) {
	if(lp == rp) {
		++dat[p];
		return ;
	}
	int mid = (lp + rp) >> 1;
	if(~tag[p]) spread(p);
	if(x <= mid) insert(p<<1, lp, mid, x);
	else insert(p<<1|1, mid + 1, rp, x);
	update(p);
}
void modify(int p, int lp, int rp, int l, int r) {
	if(l <= lp && rp <= r) {
		tag[p] = 0; dat[p] = 0;
		return ;
	}
	if(~tag[p]) spread(p);
	int mid = (lp + rp) >> 1;
	if(l <= mid) modify(p<<1, lp, mid, l, r);
	if(r > mid) modify(p<<1|1, mid + 1, rp, l, r);
	update(p); 
}
int qry(int p, int lp, int rp, int l, int r) {
	if(l <= lp && rp <= r) return dat[p];
	int mid=  (lp + rp) >> 1, ans = 0;
	if(~tag[p]) spread(p);
	if(l <= mid) ans = qry(p<<1, lp, mid, l, r);
	if(r > mid) ans += qry(p<<1|1, mid + 1, rp, l, r);
	return ans;
}
int findkth(int p, int lp, int rp, int k) {
	if(lp == rp) return lp;
	int mid = (lp + rp) >> 1;
	if(~tag[p]) spread(p);
	if(dat[p<<1] >= k) return findkth(p<<1, lp, mid, k);
	return findkth(p<<1|1, mid + 1, rp, k - dat[p<<1]);
}

int main() {
	memset(tag, -1, sizeof(tag));
	const int n = (SU<<1) + 10;
	int q, mini, tmp, dlt = 0, cnt = 0;
	scanf("%d %d", &q, &mini);
	char ch[2];
	dlt -= SU; mini += SU;
	while(q--) {
		scanf("%s %d", ch, &tmp);
		if(ch[0] == 'I') {
			tmp -= dlt;
			if(tmp >= mini) insert(1, 1, n, tmp);
		} else if(ch[0] == 'F') {
			if(tmp > dat[1]) printf("-1\n");
			else printf("%d\n", findkth(1, 1, n, dat[1] - tmp + 1) + dlt);
		} else if(ch[0] == 'S') {
			dlt -= tmp; mini += tmp;
				cnt += qry(1, 1, n, 1, mini - 1);
				modify(1, 1, n, 1, mini - 1);
		} else if(ch[0] == 'A') {
			dlt += tmp; mini -= tmp;
		}
	}
	printf("%d\n", cnt);
	return 0;
}
```

---

## 作者：ZBHRuaRua (赞：0)

## 模拟赛被爆虐，只能来写水题找自信

说回这道题，此题看题面，要支持加点删点，查找第K大，很容易想到平衡树，然后看看这个区间加区间减，感觉用平衡树不好办。

一看数据范围

### I命令的条数不超过100000 
### A命令和S命令的总条数不超过100

哈哈 直接暴力枚举每个员工不就完了嘛

然后再判断一下每个人是否减完小于下限，如果小于就删点，并且打上标记（避免下次再删）

所以这下用平衡树就可以轻松解决了，随便打打半小时内很轻松就搞定，用什么平衡树因人而异，我用的FHQ-Treap（太好用了，香香香）

下面上代码：
```
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<iomanip>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m;
int x,y,z;
int val[100050];
int son[100050][2];
int siz[100050];
int cnt;
int rnd[100050];
int root;
bool bj[100050];
int sum;
inline void update(int now)
{
	siz[now]=siz[son[now][0]]+siz[son[now][1]]+1;
}
inline int newnode(int w)
{
	cnt++;
	val[cnt]=w;
	rnd[cnt]=rand();
	siz[cnt]=1;
	return cnt;
}
inline void split(int now,int k,int &x,int &y)
{
	if(!now)
	{
		x=y=0;
		return;
	}
	if(val[now]<=k)
	{
		x=now;
		split(son[now][1],k,son[now][1],y);
	}
	else
	{
		y=now;
		split(son[now][0],k,x,son[now][0]);
	}
	update(now);
}
inline int merge(int a,int b)
{
	if(!a||!b) return a+b;
	if(rnd[a]<rnd[b])
	{
		son[a][1]=merge(son[a][1],b);
		update(a);
		return a;
	}
	else
	{
		son[b][0]=merge(a,son[b][0]);
		update(b);
		return b;
	}
}
inline int findk(int now,int k)
{
	if(!now) return -1;
	if(k<=siz[son[now][0]])
	{
		return findk(son[now][0],k);
	}
	else if(k==siz[son[now][0]]+1) return now;
	else
	{
		return findk(son[now][1],k-siz[son[now][0]]-1);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	while(n--)
	{
		char type;
		cin>>type;
		if(type=='I')
		{
			int k;
			scanf("%d",&k);
			if(k<m) continue;
			split(root,k-1,x,y);
			root=merge(x,merge(newnode(k),y));
		}
		else if(type=='A')
		{
			int k;
			scanf("%d",&k);
			for(int i=1;i<=cnt;i++)
			{
				val[i]+=k;
			}
		}
		else if(type=='S')
		{
			int k;
			scanf("%d",&k);
			for(int i=1;i<=cnt;i++)
			{
				if(val[i]-k<m&&!bj[i])
				{
					bj[i]=1;
					split(root,val[i],x,y);
					split(x,val[i]-1,x,z);
					z=merge(son[z][0],son[z][1]);
					root=merge(merge(x,z),y);
					sum++;
				}
			}
			for(int i=1;i<=cnt;i++)
			{
				val[i]-=k;
			}
		}
		else if(type=='F')
		{
			int k;
			scanf("%d",&k);
			k=siz[root]-k+1;
			int ans=findk(root,k);
			if(ans==-1)
			printf("%d\n",ans);
			else
			{
				ans=val[ans];
				printf("%d\n",ans);
			}
		}
	}
	printf("%d\n",sum);
	return 0;
}

```


---

## 作者：Starlight237 (赞：0)

看见没有WeightBalancedLeafyTree的题解，赶紧水一发。

本题核心思想参考其他题解。

关于WBLT，欢迎来到[OI wiki](https://oi-wiki.org/ds/wblt/)或luogu日报学习。也可以参考原论文，可以在[此处](https://github.com/enkerewpo/OI-Public-Library/tree/master/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E8%AE%BA%E6%96%871999-2019)找到。

简单地介绍一下：

对于$n$个数，WBLT 会建立$2n$个节点，每个节点的权值为其右儿子的权值，且右儿子的权值大于等于左儿子。

插入时，逐次向下交换并向上$pushup$更新即可，删除也是同理。

然后这样显然会退化。我们可以用$maintain$操作（加权平衡），如果一个儿子比另一个儿子的大小大很多（大某个常数倍），那么将左儿子的右儿子合并到右儿子去。采用这种策略的LeafyTree称为WBLT。

其他操作还是很好理解的，参见代码。

垃圾回收细节略多。
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 1000000
extern "C"{
namespace io{
	static char in[IOSIZE],*p=in,*pp=in,out[IOSIZE],*q=out,ch[20],*t=ch;
	inline char gc(){return p==pp&&(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?EOF:*p++;}
	inline int read(){
		reg int x=0;reg char ch,f=0;
		while(!isdigit(ch=gc()))f|=ch=='-';
		while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();
		return f?-x:x;
	}
	inline void write(int x){
		!x&&(*q++=48),x<0&&(*q++='-',x=-x);
		while(x)*t++=x%10+48,x/=10;
		while(t!=ch)*q++=*--t;
		*q++='\n';
	}
	inline char Gc(){reg char ch;while(isspace(ch=gc()));return ch;}
	inline void flush(){fwrite(out,1,q-out,stdout);}
}}
#define rd io::read
#define wt io::write
const int rat=4,maxn=100001;
static int n,tot,inf=2147483647,ent,kep,minn,delta;
static struct Node{
	int siz,val;
	Node *ls,*rs;
	Node(){}
	Node(int siz,int val,Node *ls,Node *rs):siz(siz),val(val),ls(ls),rs(rs){}
}*null,*root,tr[maxn<<1],*pl[maxn<<1];
#define newNode(a,b,c,d) (&(*pl[tot++]=Node(a,b,c,d)))
inline void pushup(Node *cur){
	cur->ls->siz&&(cur->siz=cur->ls->siz+cur->rs->siz,cur->val=cur->rs->val);
}
inline Node *merge(Node *a,Node *b){return newNode(a->siz+b->siz,b->val,a,b);}
inline void maintain(Node *cur){
	cur->ls->siz>cur->rs->siz*rat&&(
		cur->rs=merge(cur->ls->rs,cur->rs),pl[--tot]=cur->ls,cur->ls=cur->ls->ls
	),
	cur->rs->siz>cur->ls->siz*rat&&(
		cur->ls=merge(cur->ls,cur->rs->ls),pl[--tot]=cur->rs,cur->rs=cur->rs->rs
	);
}
void ins(Node *cur,int val){
	cur->siz==1?
		cur->ls=newNode(1,min(val,cur->val),null,null),
		cur->rs=newNode(1,max(val,cur->val),null,null),0
	:(ins(val>cur->ls->val?cur->rs:cur->ls,val),0);
	pushup(cur),maintain(cur);
}
void del(Node *cur,int val){
	cur->ls->siz==1&&cur->ls->val==val?
		--kep,pl[--tot]=cur->ls,pl[--tot]=cur->rs,*cur=*cur->rs,0
	:cur->rs->siz==1&&cur->rs->val==val?
		--kep,pl[--tot]=cur->rs,pl[--tot]=cur->ls,*cur=*cur->ls,0
	:(del(val>cur->ls->val?cur->rs:cur->ls,val),0);
	pushup(cur),maintain(cur);
}
int Find(Node *cur,int k){
	return cur->siz==1?cur->val:
	k>cur->ls->siz?Find(cur->rs,k-cur->ls->siz):Find(cur->ls,k);
}
int Rank(Node *cur,int val){
	return cur->siz==1?1:
	val>cur->ls->val?cur->ls->siz+Rank(cur->rs,val):Rank(cur->ls,val);
}
inline int Pre(int val){return Find(root,Rank(root,val)-1);}
int main(){
	n=rd(),minn=rd();
	null=new Node(0,0,NULL,NULL);
	root=new Node(1,inf,null,null);
	for(reg int i=0;i<(maxn<<1);++i)pl[i]=&tr[i];
	ins(root,-inf);
	for(reg int x,i=0;i<n;++i){
		char c=io::Gc();x=rd();
		int val,tmp,pr;
		switch(c){
			case 'I':
				x>=minn&&(ins(root,x-delta),++ent,++kep);
				break;
			case 'A':delta+=x;break;
			case 'S':
				delta-=x;
				val=minn-delta;
				while(pr=Pre(val),pr!=-inf){
					tmp=val,val=pr;
					do del(root,pr);while(Find(root,Rank(root,pr))==pr);
				}
				break;
			case 'F':
				wt(kep<x?-1:Find(root,kep-x+2)+delta);
				break;
		}
	}wt(ent-kep);
	io::flush();
	return 0;
}
```

---

## 作者：αnonymous (赞：0)

朴实无华的平衡树~~(其实是作为蒟蒻的我还没学splay和treap)~~

## 这里最重要的是记录一个S与A的总值~~（我设为total）~~，而不用一个一个数修改

调试了n遍的我，**发现I操作中k-total有可能要插入到小于0的位置**，而我设置的左边界为1,故只得了40分，个位初学平衡树的大佬一定要注意啦！！！

AC代码：
```cpp
#include <iostream>
using namespace std;
long long n,mini,a[20000001],total=-100000,al[20000001],ar[20000001],an=1,ans;
/*
a表示区间内员工的总数,a[1]的左边界为1,右边界为300000,有效防止k-total超出边界
total表示加减工资的总值,total开始时定为-100000是为了防止k-total为负数导致构造平衡树时出错
al表示左子树在a中的位置,如果没有左子树则指向0
ar表示右子树在a中的位置,如果没有右子树则指向0
an表示a现在的个数
ans代表离开公司的人数
*/
void pushup(int k){
	a[k]=a[al[k]]+a[ar[k]];//每次a区间内有员工的变动，便重新计算
}
void pushdown(int k){//将区间及左右子树内的员工全部炒鱿鱼
	if(a[al[k]])//小小的剪枝,左子树中有员工才向下走
		pushdown(al[k]);
	if(a[ar[k]])
		pushdown(ar[k]);
	a[k]=0;
}
void add(int l,int r,int k,int m){//构造平衡树
	if(l==r)//注意是++，同一工资的员工有可能不只一个人
		a[k]++;
	else{
		int mid=(l+r)>>1;
		if(mid>=m){
			if(!al[k])//如果还没有左子树,分配一个位置（空间上比直接往k*2和k*2+1走会略微优化）
				al[k]=++an;
			add(l,mid,al[k],m);
		}
		else{
			if(!ar[k])
				ar[k]=++an;
			add(mid+1,r,ar[k],m);
		}
		pushup(k);//更新现在区间内员工个数
	}
}
void query(int l,int r,int k,int m){
	if(l==r)
		cout<<l+total<<endl;//输出现在的工资
	else{
		int mid=(l+r)>>1;
		if(a[ar[k]]>=m)//如果第m个在右子树中
			query(mid+1,r,ar[k],m);
		else
			query(l,mid,al[k],m-a[ar[k]]);//注意，m要减a[ar[k]]
            					      //举个栗子:左右子树各有1个数，现在查找第2大的数,则向左走时应查找左子树中第1大的数
	}
}
void check(int l,int r,int k){
	if(r+total<mini){//如果整个区间的工资都小于mini
		if(a[k]){
			ans+=a[k];//注意：只需加一次，a[k]包括左子树和右子树所有员工的个数
			pushdown(k);
		}
	}
	else{
		int mid=(l+r)>>1;
		if(l+total<mini&&a[al[k]])//左边界小于mini,且左子树中有员工
			check(l,mid,al[k]);
		if(mid+1+total<mini&&a[ar[k]])//注意右子树是从mid+1开始,不是mid
			check(mid+1,r,ar[k]);
		pushup(k);
	}
}
int main(){
	int i,j,k;
	char c;
	cin>>n>>mini;
	while(n--){
		cin>>c>>k;
		switch(c){
			case 'A':
				total+=k;//工资加k，记录在total中
				break;
			case 'S':
				total-=k;
				check(1,300000,1);
				break;
			case 'F':
				if(k>a[1])//a[1]可以直接表示整个区间内所有员工个数
					cout<<-1<<endl;
				else
					query(1,300000,1,k);
				break;
			case 'I':
				if(k>=mini)//k<mini时不用记录在离开公司的人数中
					add(1,300000,1,k-total);
				break;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
在此，对使用多次评测资源表示抱歉~~（汗~~

此题感慨较深,望管理大大过了

---

## 作者：rediserver (赞：0)

# P1486 [NOI2004]郁闷的出纳员
[原题地址](https://www.luogu.org/problemnew/show/P1486)

[GitHub题解](https://github.com/jerrykcode/luogu)

## 思路

使用通过size维护平衡的SBT树。用工资作为搜索树排序的依据。

对于4种命令：

* I k  插入新结点
* A k  遍历SBT，把每个结点的工资加上k
* S k  遍历SBT，把每个结点的工资减少k，若低于min，则将其从SBT中删除
* F k  设SBT的结点数量为size，查询一个结点，有(size - k)个结点的工资小于该结点的工资，输出这个结点的工资。size < k 则输出-1

详细见代码注释

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

class Cashier {
public:

	Cashier(int min);
	~Cashier();

	void insert(int salary); //I
	void increase(int salary_increment); //A 
	void decrease(int salary_decrement); //S
	int select(int k); //F

private:
	//SBT树
	typedef struct TNode {
		int key; //BST按key值排序，在此题中key为工资
		struct TNode * left;
		struct TNode * right;
		size_t size; //结点数量，SBT根据size维护平衡
		TNode(int key) : key(key), left(NULL), right(NULL), size(1) {}
	} *Tree;

	size_t getSize(Tree tree) {
		return tree ? tree->size : 0;
	}

	Tree leftRotate(Tree tree); //左旋
	Tree rightRotate(Tree tree); //右旋

	Tree maintain(Tree tree); //维护平衡
	Tree maintainLeft(Tree tree); //维护平衡--左子树的孩子的size大于右子树的size
	Tree maintainRight(Tree tree); //维护平衡--右子树的孩子的size大于左子树的size

	Tree insert(Tree tree, int key); //插入
	int select(Tree tree, int rank); //在tree中找到排名rank的结点，即有rank个结点的key小于该结点的key，返回该结点的key
	Tree remove(Tree tree, int key); //删除结点

	void deleteTree(Tree tree); //删除树

private:
	Tree tree; //平衡树
	size_t remove_num; //离开的员工数，即tree中删除的结点数
	int min; //最小工资
	queue<Tree> q; //队列
};

Cashier::Cashier(int min) : tree(NULL), remove_num(0), min(min) {

}

Cashier::~Cashier() {
	deleteTree(tree);
	queue<Tree>().swap(q);
	printf("%d\n", remove_num); //输出离开的员工数
}

void Cashier::insert(int salary) {
	if (salary >= min) 
		tree = insert(tree, salary);
	//else remove_num++; // "如果某个员工的初始工资低于最低工资标准,那么将不计入最后的答案内"
}

void Cashier::increase(int salary_increment) {
	//遍历tree，每个结点增加工资
	if (tree == NULL) return;
	q.push(tree);
	while (!q.empty()) {
		Tree t = q.front();
		q.pop();
		t->key += salary_increment;
		if (t->left) q.push(t->left);
		if (t->right) q.push(t->right);
	}
}

void Cashier::decrease(int salary_decrement) {
	//遍历tree，每个结点减少工资，若减少后的工资低于min，则用vector记录，并在最后删除
	if (tree == NULL) return;
	vector<int> v;
	q.push(tree);
	while (!q.empty()) {
		Tree t = q.front();
		q.pop();
		t->key -= salary_decrement;
		if (t->key < min) {
			v.push_back(t->key);
		}
		if (t->left) q.push(t->left);
		if (t->right) q.push(t->right);
	}
	for (int key : v) {
		tree = remove(tree, key); //删除结点
	}
	remove_num += v.size(); //离开员工数量增加
	v.clear();
}

int Cashier::select(int k) {
	//查询第k多
	if (tree == NULL) return -1;
	if (tree->size >= k)
		return select(tree, tree->size - k); //查询有(tree->size - k)个结点比它小的结点
	else return -1;
}

/*-------------------------SBT树-------------------------*/

Cashier::Tree Cashier::leftRotate(Tree tree) {
	Tree k = tree->right;
	tree->right = k->left;
	k->left = tree;
	tree->size = getSize(tree->left) + getSize(tree->right) + 1;
	k->size =tree->size + getSize(k->right) + 1;
	return k;
}

Cashier::Tree Cashier::rightRotate(Tree tree) {
	Tree k = tree->left;
	tree->left = k->right;
	k->right = tree;
	tree->size = getSize(tree->left) + getSize(tree->right) + 1;
	k->size = getSize(k->left)+ tree->size + 1;
	return k;
}

Cashier::Tree Cashier::maintain(Tree tree) {
	tree = maintainLeft(tree);
	return maintainRight(tree);
}

Cashier::Tree Cashier::maintainLeft(Tree tree) {
	if (tree == NULL || tree->left == NULL) return tree;
	if (tree->left->left && tree->left->left->size > getSize(tree->right)) {
		//左子树的左子树的size大于右子树的size
		tree = rightRotate(tree);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	else if (tree->left->right && tree->left->right->size > getSize(tree->right)) {
		//左子树的右子树的size大于右子树的size
		tree->left = leftRotate(tree->left);
		tree = rightRotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	return tree;
}

Cashier::Tree Cashier::maintainRight(Tree tree) {
	if (tree == NULL || tree->right == NULL) return tree;
	if (tree->right->right && tree->right->right->size > getSize(tree->left)) {
		//右子树的右子树的size大于左子树的size
		tree = leftRotate(tree);
		tree->left = maintain(tree->left);
		tree = maintain(tree);
	}
	else if (tree->right->left && tree->right->left->size > getSize(tree->left)) {
		//右子树的左子树的size大于左子树的size
		tree->right = rightRotate(tree->right);
		tree = leftRotate(tree);
		tree->left = maintain(tree->left);
		tree->right = maintain(tree->right);
		tree = maintain(tree);
	}
	return tree;
}

Cashier::Tree Cashier::insert(Tree tree, int key) {
	if (tree == NULL) {
		return new TNode(key);
	}
	tree->size++;
	if (key < tree->key) {
		tree->left = insert(tree->left, key);
		tree = maintainLeft(tree); //插入左子树后，需要判断左子树的孩子的size是否大于右子树的size
	}
	else {
		tree->right = insert(tree->right, key);
		tree = maintainRight(tree); //插入右子树后，需要判断右子树的孩子的size是否大于左子树的size
	}
	return tree;
}

int Cashier::select(Tree tree, int rank) {
	if (tree == NULL) return 0;
	size_t left_size = getSize(tree->left);
	if (rank == left_size) {
		return tree->key;
	}
	else if (rank < left_size) {
		return select(tree->left, rank);
	}
	else {
		return select(tree->right, rank - left_size - 1);
	}
}

Cashier::Tree Cashier::remove(Tree tree, int key) {
	if (tree == NULL) return NULL;
	tree->size--;
	if (key == tree->key) {
		if (tree->left && tree->right) { //左右子树都不为NULL
			//用左子树种最大的代替tree
			Tree left_max = tree->left;
			while (left_max->right) left_max = left_max->right;
			tree->key = left_max->key;
			tree->left = remove(tree->left, left_max->key);
			tree = maintainRight(tree); //在左子树中删除结点后，需要判断右子树的孩子的size是否大于左子树的size
		}
		else {
			Tree tmp = tree;
			tree = tree->left ? tree->left : tree->right;
			delete tmp;
		}
	}
	else if (key < tree->key) {
		tree->left = remove(tree->left, key);
		tree = maintainRight(tree); //在左子树中删除结点后，需要判断右子树的孩子的size是否大于左子树的size
	}
	else {
		tree->right = remove(tree->right, key);
		tree = maintainLeft(tree); //在右子树中删除结点后，需要判断左子树的孩子的size是否大于右子树的size
	}
	return tree;
}

void Cashier::deleteTree(Tree tree) {
	if (tree == NULL) return;
	//递归删除
	deleteTree(tree->left);
	deleteTree(tree->right);
	delete tree;
}

int main() {
	int n, min;
	scanf("%d %d", &n, &min);
	Cashier cashier(min);
	char cmd; int k;
	for (int i = 0; i < n * 2; i++) { //循环n*2次才能输入所有数据
		scanf("%c", &cmd);
		scanf("%d", &k);
		switch (cmd) {
		case 'I' : cashier.insert(k); break;
		case 'A': cashier.increase(k); break;
		case 'S': cashier.decrease(k); break;
		case 'F': {
			int salary = cashier.select(k);
			printf("%d\n", salary);
			break;
		}
		default: break;
		}
	}
	//在析构函数里输出离开的员工数量
	return 0;
}
```





---

## 作者：laduiw (赞：0)

# 这是一篇不需要平衡树的题解
### 众所周知vector+二分可以取代许多操作，下面开始正题
此题难点在于当A,S操作时，你不能对所有存活的人都操作一遍于是我们联想到蚯蚓那题，维护一个d，保证v[x]+d=real[x]

v是我们维护的，移项得v[x]=real[x]-d,每次来新人插入real-d,要加减工资直接在d上加减，这样就成功将a,s操作变成O(1)了。

然后考虑如何删除<min的和求第k大

我们只需要保证v是单调递增的即可 每次插入时，二分一个最大的小于real-d的位置，然后insert, 删除同理，因为min也是真实值，所以在v数组中就是min-d,二分一个最靠后的位置，把前面的数都删掉，erase的复杂度是O(删除长度),每个数只会被删一次，所以复杂度很优越。

具体过程可以手膜样例，体会一下d的妙处

Code
```cpp
#include<bits/stdc++.h>
using namespace std;
vector <int> v;
int n,T,mi,d=0,ans=0;
int read()
{
	char ch=getchar();
	int s=0,f=1;
	while (ch<'0' || ch>'9') {if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0' && ch<='9') s=s*10+ch-48,ch=getchar();
	return s*f;
}

int cha(int x) // 查找最靠后的小于x的位置 
{
	if (v.size()==0 || v[0]>=x) return -1;//如果不判空会非法访问
	int l=0,r=v.size()-1;
	while (l<r) 
	{
		int mid=(l+r+1)>>1;//加1防止死循环，比如l=4,r=5
		if (v[mid]<x) l=mid;
			else r=mid-1;
	}
	return r;
}
//因为vector 下标从0开始，insert和erase最好测试一下从第几个数开始删除或加入，要不要+1，-1什么的
int main()
{
	T=read();mi=read();
	while (T--)
	{
		char ch=getchar();
		while (ch!='I' && ch!='A' && ch!='F' && ch!='S') ch=getchar();
		int x=read();
		if (ch=='I') {
			int p=cha(x-d);
			if (x>=mi) v.insert(v.begin()+p+1,x-d);
		}
		else {
			if (ch=='A') d+=x;
			if (ch=='S') {
				d-=x;
				int p=cha(mi-d);
				if (p==-1) continue;
				v.erase(v.begin(),v.begin()+p+1);
				ans+=p+1;
			}
			if (ch=='F') {
				if (x>v.size()) printf("-1\n");
					else printf("%d\n",v[v.size()-x]+d);//这里是第k小。。
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：lcjqwq (赞：0)

### Description
给出一个下限 $m$ ，要求维护以下操作
1.  插入一个数（如果小于下限就不加）
2.  给每个数加上一个数
3.  给每个数减去一个数，并且删除掉 $< m$ 的所有数
4.  求目前第 $k$ 大的数（注意是第 $k$ 大！**从大到小**排序后第 $k$ 个）

最后还要输出所有 3 操作一共删掉了多少个数
$n \leq 10^5$
### Solution
fhqtreap大法吼！

由于修改操作是全体操作，可以用一个 $delta$ 记录修改总量

对于 1 操作插入权值 $x - delta$（如果 x <= m 就算了

对于 2 操作直接把 $delta += x$ 

对于 3 操作，先把 $delta -= x$ ，然后把小于 $m - delta$ 的全部删掉

具体实现可以 split 出来两个子树，然后直接让 root = 右子树，最后要输出的 ans += 左子树的 siz

对于 4 操作，split一下就行了

### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10196800.html)

---

## 作者：Vozeo (赞：0)

很久没写题解了。做完后看题解发现大家都写了各种平衡树，线段树，代码很长。

对于同一道题，代码越长越容易写错，且调试起来更困难，考场上的时间也很有限。所以为什么不用虽然有点慢但是复杂度正确且能过的方法呢？

那就是：$STL$！

可以用$vector$维护单调的工资序列，有三种操作：插入，删除，修改。

插入：用`upper_bound`查找，时间复杂度$O(\log n)$。

删除：在降低工资后，用`erase`把低于最低工资的部分删除，累加计数。时间复杂度$O(n)$。

修改：暴力修改。时间复杂度$O(n)$。但注意到修改次数不超过**100**次，是能够通过的。

有几个值得注意之处，在代码中标注了。
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cctype>
using namespace std;

vector<int> a;
char c;
int k, n, mn, cur = 0, sum = 0;

int main()
{
    scanf("%d%d", &n, &mn);
    while (n--)
    {
        while (!isalpha(c = getchar())); //直接用scanf输入会把换行符也读进去
        scanf("%d", &k);
        if (c == 'I')
        {
            if (k >= mn) //如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内！
                a.insert(upper_bound(a.begin(), a.end(), k), k);
        }
        else if (c == 'A')
            for (int i = 0; i < (int)a.size(); ++i)
                a[i] += k; //暴力加
        else if (c == 'S')
        {
            for (int i = 0; i < (int)a.size(); ++i)
                a[i] -= k; //暴力减
            for (int i = 0; i <= (int)a.size(); ++i)
                if (a[i] >= mn || i == (int)a.size()) //这样写可能不太优美，因为蒟蒻技艺不精，但是能过
                {
                    a.erase(a.begin(), a.begin() + i);
                    sum += i;
                    break;
                }
        }
        else
        {
            if (k > (int)a.size())
                printf("-1\n");
            else
                printf("%d\n", *(a.end() - k)); //由于我维护的是递增序列，需要从后向前的第k个
        }
    }
    printf("%d\n", sum);
    return 0;
}
```

---

## 作者：halfrot (赞：0)

对于维护平衡树中的重复元素，我们可以使用懒惰删除，这样可以提高代码可读性，减小程序常数，所以接下来我放一个没有使用懒惰删除的。

我们可以通过**传递参数**来改变相同元素在子树中的**相对位置**。这样就可以把想要的区间放在根节点的左子树或右子树，这样就很利于操作了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=1e5+5;
void outint(int x){
    if(x>=10) outint(x/10);
    putchar(x%10+'0');
}
int ch[MAXN][2],key[MAXN],size[MAXN],fa[MAXN],Rt=0,cnt=0;
void inline rot(int x,int p){
    int y=fa[x];
    fa[ch[x][!p]]=fa[x],ch[y][p]=ch[x][!p];
    fa[x]=fa[y];if(fa[y]) ch[fa[y]][ch[fa[y]][1]==y]=x;
    fa[y]=x,ch[x][!p]=y;
    size[y]=size[ch[y][0]]+size[ch[y][1]]+1;
    size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
}
void inline splay(int x,int T){
    while(fa[x]!=T){
        if(fa[fa[x]]==T) rot(x,ch[fa[x]][1]==x);
        else{
            int y=fa[x],z=fa[y],p=ch[z][1]==y;
            if(ch[y][p]==x) rot(y,p),rot(x,p);
            else rot(x,!p),rot(x,p);
        }
    }
    if(!T) Rt=x;
}
int getkth(int);
void insert(int k,bool flag){
    int pos=Rt,x=Rt;
    while(pos) x=pos,pos=ch[pos][flag?k>=key[pos]:k>key[pos]];
    fa[++cnt]=x,key[cnt]=k,size[cnt]=1,ch[x][flag?k>=key[x]:k>key[x]]=cnt;
    splay(cnt,0);
}
int getkth(int k){
    int pos=Rt;
    while(pos&&size[ch[pos][1]]+1!=k){
        if(size[ch[pos][1]]+1<k){
            k-=size[ch[pos][1]]+1;
            pos=ch[pos][0];
        }
        else pos=ch[pos][1];
    }
    splay(pos,0);
    return key[pos];
}
int suc(int &x){
    int pos=ch[x][1];
    while(ch[pos][0]) pos=ch[pos][0];
    return pos;
}
void delrt(){
    int s=suc(Rt);
    if(s){
        int pos=fa[s];
        while(pos) size[pos]--,pos=fa[pos];
        if(fa[s]==Rt) fa[ch[s][1]]=Rt,ch[Rt][1]=ch[s][1];
        else fa[ch[s][1]]=fa[s],ch[fa[s]][0]=ch[s][1];
        key[Rt]=key[s];
    }
    else Rt=0;
}
int deltree(){
    int pos=Rt,tot;
    while(key[ch[pos][0]]==key[Rt]) pos=ch[pos][0];
    tot=size[ch[pos][0]],ch[pos][0]=0;
    while(pos) size[pos]-=tot,pos=fa[pos];
    return tot;
}
int main(){
    int n,Minpay,delta=0,ans=0;
    scanf("%d%d",&n,&Minpay);
    for(int i=1;i<=n;i++){
        char c;
        int temp;
        scanf("\n%c %d",&c,&temp);
        if(c=='I') if(temp>=Minpay) insert(temp-delta,true);else continue;
        else if(c=='A') delta+=temp;
        else if(c=='S'){
            delta-=temp;
            insert(Minpay-delta,false);
            size[Rt]-=size[ch[Rt][0]];
            ans+=size[ch[Rt][0]];
            ch[Rt][0]=0;
            delrt();
        }
        else{
            if(temp>size[Rt]) putchar('-'),putchar('1');
            else outint(getkth(temp)+delta);
            putchar('\n');
        }
    }
    outint(ans);
}
```

---

## 作者：UIai (赞：0)

一道裸的二叉平衡树，可用各类平衡树求解（再加上maintain()实现名次数以回应k询问，当然也更好统计离开人数）。只不过注意几个细节：1.允许有重复元素 2.遇到小于m值时，删除时砍掉左子树 。 3便于操作，相同节点放右子树。 4.如果员工，进入公司时工资小于m则不算入离开公司人数（这公司有病。。。）。以下为treap实现

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<ctime>
long n,m,count(0);
struct Node{
    long cash;
    Node *ch[2];
    long r;
    int size;
    int cmp(long x)
    {return x<cash ? 0:1;}
    void maintain()
    {size=1;if(ch[0]!=NULL) size+=ch[0]->size;if(ch[1]!=NULL) size+=ch[1]->size;return ;}
};
void rotate(Node* &o,int d)//rotate to right when d equals 1
{Node *k=o->ch[1-d];o->ch[1-d]=k->ch[d];k->ch[d]=o;o->maintain();k->maintain();o=k;return ;}
void insert(Node* &o,long v)
{
    if(o==NULL) {o=(Node *)malloc(sizeof(Node));o->cash=v;o->ch[0]=o->ch[1]=NULL;o->r=(long)(rand()*rand()%100007);o->size=1;}
    
   else{ int d=o->cmp(v);
    insert(o->ch[d],v);
   if(o->r < o->ch[d]->r)
       rotate(o,1-d);
    o->maintain();}
    return ;
}
void remove(Node *&o)
{
    if(o==NULL)
        return ;
    //printf("%ld %ld",o->cash,o->ch[1]->cash);
    if(o->cash>=m) remove(o->ch[0]);
    else{
            if(o->ch[0])
                count+=o->ch[0]->size;
            count++;
            o=o->ch[1];
            remove(o);
    }
    if(o!=NULL)
      o->maintain();
    return;
}
void plus(Node* &o,long x)
{
    if(o==NULL)
        return ;
    o->cash+=x;
    plus(o->ch[0],x);
    plus(o->ch[1],x);
    return ;
}
long kth(Node *o,long k)
{
    long f;
    if(o->ch[1]==NULL)
        f=0;
    else f=o->ch[1]->size;
    if(f+1==k)
        return o->cash;
    if(f<k)
        return kth(o->ch[0],k-f-1);
    else return kth(o->ch[1],k);
    return 0;
}
int main()
{
    char s;
    long order;
    srand(time(NULL));
    Node *root;
    root=NULL;
    std::cin>>n>>m;
    getchar();
    for(long i=0;i<n;i++)
    {
        scanf("%c %ld",&s,&order);
        getchar();
        if(s== 'I') {if(order>=m)
            insert(root,order);}
        else if(s== 'F'){
            if( !root || order>root->size || order<=0)
                printf("-1\n");
           else printf("%ld\n",kth(root,order));
     }
        else if(s== 'S') {plus(root,-order);remove(root);}
       else plus(root,order);
    }
    printf("%ld\n",count);
    return 0;
}


```

---


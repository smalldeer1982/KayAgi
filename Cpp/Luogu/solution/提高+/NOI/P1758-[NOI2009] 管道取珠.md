# [NOI2009] 管道取珠

## 题目描述

管道取珠是小 X 很喜欢的一款游戏。在本题中，我们将考虑该游戏的一个简单改版。游戏画面如图 1 所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p4r2ip9.png)

游戏初始时，左侧上下两个管道分别有一定数量的小球（有深色球和浅色球两种类型），而右侧输出管道为空。每一次操作，可以从左侧选择一个管道，并将该管道中最右侧的球推入右边输出管道。

例如：我们首先从下管道中移一个球到输出管道中，将得到图 2 所示的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/xj1kay44.png)

假设上管道中有 $n$ 个球, 下管道中有 $m$ 个球，则整个游戏过程需要进行 $n+m$ 次操作，即将所有左侧管道中的球移入输出管道。最终 $n+m$ 个球在输出管道中从右到左形成输出序列。

爱好数学的小 X 知道，他共有 $\dbinom{n+m}{m}$ 种不同的操作方式，而不同的操作方式可能导致相同的输出序列。举个例子，对于图 3 所示的游戏情形：

![](https://cdn.luogu.com.cn/upload/image_hosting/0m1t5d3h.png)

我们用 A 表示浅色球，B 表示深色球。并设移动上管道右侧球的操作为 U，移动下管道右侧球的操作为 D，则共有 $\binom{2+1}{1}=3$ 种不同的操作方式，分别为 UUD，UDU，DUU；最终在输出管道中形成的输出序列（从右到左）分别为 BAB，BBA，BBA。可以发现后两种操作方式将得到同样的输出序列。

假设最终可能产生的不同种类的输出序列共有 $K$ 种，其中：第 $i$ 种输出序列的产生方式（即不同的操作方式数目）有 $a_i$ 个。聪明的小 X 早已知道，

$$
\sum a_i=\binom{n+m}{m}
$$

因此，小 X 希望计算得到：

$$
\sum a_i^2
$$

你能帮助他计算这个值么？由于这个值可能很大，因此只需要输出该值对 $1024523$ 取模后的结果。


## 说明/提示

### 样例解释

样例对应图 3。

共有两种不同的输出序列形式，序列 BAB 有 $1$ 种产生方式，而序列 BBA 有 $2$ 种产生方式，因此答案为 $5$。

### 数据范围

- 对于 $30\%$ 的数据，满足 $m,n \leq 12$；
- 对于 $100\%$ 的数据，满足 $1 \leq m,n \leq 500$。

## 样例 #1

### 输入

```
2 1
AB
B
```

### 输出

```
5```

# 题解

## 作者：ModestCoder_ (赞：39)

首先转化问题

$\sum a_i^2$可以换一种理解方式

两个人在两个独立的装置里取球，输出队列相同的方案数

因为对于每一种输出队列，第一个人有$a_i$种方案，第二个人有$a_i$种方案

那么两个人输出队列相同的方案总数就是$a_i^2$

然后就是一个很简单的dp题目了

$dp_{k,i,j}$表示两个人到目前为止都各取了$k$个球，第一个人在第一根管道取了$i$个球，第二个人在第一根管道取了$j$个球，两个人的输出队列相同的方案数
然后已知答案就是$dp_{n+m,n,n}$

然后思考如何转状态转移，根据dp状态的定义，当目前两个人取的球的个数相同才可能发生转移，然后讨论两个人当前从那根管道取的球

 - $a_i=a_j:dp_{k,i,j}<-dp_{k-1,i-1,j-1}$
 - $a_i=b_{k-j}:dp_{k,i,j}<-dp_{k-1,i-1,j}$
 - $b_{k-i}=a_j:dp_{k,i,j}<-dp_{k-1,i,j-1}$
 - $b_{k-i}=b_{k-j}:dp_{k,i,j}<-dp_{k-1,i,j}$

注意一下细节就行了

最后考虑时空间的复杂度，时间上$O(n^3)$没毛病

空间上有那么一点问题，但是看到第一维可以滚动掉，放心了

Code：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define maxn 510
using namespace std;
const int qy = 1024523;
int n, m, a[maxn], b[maxn], dp[2][maxn][maxn];

int get(){
	char c = getchar();
	for (; c != 'A' && c != 'B'; c = getchar());
	return c == 'A';
}

void upd(int &x, int y){ if ((x += y) >= qy) x -= qy; }

int main(){
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) a[i] = get();
	for (int i = 1; i <= m; ++i) b[i] = get();
	reverse(a + 1, a + 1 + n);
	reverse(b + 1, b + 1 + m);
	dp[0][0][0] = 1;
	for (int k = 1; k <= n + m; ++k){
		int now = k & 1, pre = now ^ 1;
		for (int i = 0; i <= n; ++i)
			for (int j = 0; j <= n; ++j) dp[now][i][j] = 0;
		for (int i = max(0, k - m); i <= min(n, k); ++i)
			for (int j = max(0, k - m); j <= min(n, k); ++j){
				if (i && j && a[i] == a[j]) upd(dp[now][i][j], dp[pre][i - 1][j - 1]);
				if (i && k - j && a[i] == b[k - j]) upd(dp[now][i][j], dp[pre][i - 1][j]);
				if (j && k - i && b[k - i] == a[j]) upd(dp[now][i][j], dp[pre][i][j - 1]);
				if (k - i && k - j && b[k - i] == b[k - j]) upd(dp[now][i][j], dp[pre][i][j]);
			}
	}
	printf("%d\n", dp[(n + m) & 1][n][n]);
	return 0;
}
```


---

## 作者：「QQ红包」 (赞：34)

由于是 $∑A_i^2$ ,可以看成取两次得到了相同的串的方案数。(想一想,为什么)


$f [i][j][k][l]$ 表示第一次取A串中的前 $i$ 个,取B串中的前 $j$ 个,第二次取A串中的前 $k$ 个,B串中的前 $l$ 个的方案数

因为 $k+l=i+j$ 最后一维可以省了

转移方程就很好推了,见代码


然后用滚动数组就好了

注意:本站会tle,大牛分站可以ac

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
int n,m;
char a[510],b[510];
int f[5][510][510],t;//滚动数组
inline void add(int A,int &B)
{
    B+=A;
    if (B>1024523) B-=1024523;//取膜
}
int cur=0;
int main()
{
    n=read();m=read();
    scanf("%s",a+1);
    scanf("%s",b+1);
    f[0][0][0]=1;
    for (int i=0;i<=n;i++,cur^=1)
        for (int j=0;j<=m;j++)
            for (int k=0;k<=n;k++)
            {
                t=f[cur][j][k];
                if (i+j-k>m||i+j-k<0) continue;//越界退出
                if (a[i+1]==a[k+1]) add(t,f[cur^1][j][k+1]);//状态转移
                if (b[j+1]==b[i+j-k+1]) add(t,f[cur][j+1][k]);
                if (a[i+1]==b[i+j-k+1]) add(t,f[cur^1][j][k]);
                if (b[j+1]==a[k+1]) add(t,f[cur][j+1][k+1]);
                f[cur][j][k]=0;//清掉
            }
    printf("%d",f[cur][m][n]);
    return 0;
}
```

---

## 作者：pkh68 (赞：10)


感觉今晚有点浮躁，写篇题解静静心吧，离noip还有20天了，希望有个好成绩吧。

### 解析

首先考虑此题式子的实际意义，发现 $\sum{ai}^2$ 的意义就是两次取球序列一样的方案数，因此考虑计数，设状态 $f(i,j,k,l)$ 表示第 $1$ 次取球上面取到了第 $i$ 个，下面取到了第 $j$ 个,第 $2$ 次取球上面取到了第 $k$ 个，下面取到了第 $l$ 个。我们发现可以去掉 $l$ 这一维，然后转移即可（~~记得用滚动数组，不然会炸空间~~）。

### 代码如下

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define re register
#define N 505
using namespace std;
const int Mod=1024523;
int n,m,f[2][N][N];
char s1[N],s2[N];
int main(){
	scanf("%d%d",&n,&m);
	scanf("%s",s1+1); scanf("%s",s2+1);
	f[0][0][0]=1;
	for(re int i=0;i<=n;++i){
		int ni=i&1;
		memset(f[ni^1],0,sizeof(f[ni^1]));
		for(re int j=0;j<=m;++j){
			for(re int k=0;k<=i+j;++k){
				int l=i+j-k;
				if(s1[i+1]==s1[k+1]) (f[ni^1][j][k+1]+=f[ni][j][k])%=Mod;
				if(s1[i+1]==s2[l+1]) (f[ni^1][j][k]+=f[ni][j][k])%=Mod;
				if(s2[j+1]==s1[k+1]) (f[ni][j+1][k+1]+=f[ni][j][k])%=Mod;
				if(s2[j+1]==s2[l+1]) (f[ni][j+1][k]+=f[ni][j][k])%=Mod;
			}
		}
	}
	printf("%d\n",f[n&1][m][n]);
	return 0;
}

```

---

## 作者：Y142857 (赞：8)

这是一道DP神题,直到我写下这句题解时也没有想明白……

首先，这道题要我们求所有（不同输出序列的方案数）的平方和，于是我们当然就想到求所有不同输出序列的方案数……（大雾） 。这道题一个巧妙的地方就在于对问题的转化。（以下摘自BYVoid大神的题解）

假设同时有两个人X & Y在玩这个游戏，设X从up取了i个珠子（不一定连续），从down取了j个珠子，取出来的珠子组成的序列为Q，操作序列为x，Y从up取了k个珠子，从down取了l个珠子，取出来的珠子组成的序列也为Q，操作序列为y，那么我们就得到了一个有序对（x，y），f[i][j][k][l]即表示有序对（x，y）的数量。两个有序对不相同当且仅当x和y不同时相同。

下面证明f[i][j][k][l]即为所求。

已知：取出珠子的序列为Q，x和y分别为一种取珠方法（可相同），    取出Q的方案数为a；

求证：有序对（x，y）的数量等于a^2。

因为取出Q的方案数为a，所以x & y都有a种取值，且x & y彼此独立，故对于x的每一个取值，y都有a种取值，故有序对（x，y）的数量为a^2，命题得证。

博主是个超级大傻\*，连空间优化到n^2都不会，请各路大神指教。（然而这道题不优化洛谷过不了，n^3的空间bzoj能过）

[bzojAC代码点这里](http://www.cnblogs.com/y142857/p/7197649.html)


---

## 作者：Aftglw (赞：6)

## 算法分析
 $a_i^2$ 可以看作有两个相同管道得到的序列相同的方案数。第一个管道得到相同序列有 $a_i^2$ 种，第二个管道得到的相同序列有ai种，两个管道得到的相同序列有 $a_i^2$ 种。

因此，设状态 $f(i,j,x,y)$ 表示第一个管道上方取 $i$ 个，下方取 $j$ 个，第二个管道上方 $x$ 个，下方取 $y$ 个得到相同序列的方案数。

因为 $i+j=x+y$ ，所以就有 $y=i+j-z$ ，可以省掉一维，为 $f(i,j,x)$ 。

设上管道使用数组 $a$ 存放，下管道使用数组 $b$ 存放，考虑取 $a(i+1)$ ，$a(j+1)$ ，$a(x+1)$ ，$a(y+1)$ 的情况。

```cpp
if(a[i+1]==a[x+1]) f[cnt^1][j][x+1]+=t,Mod(f[cnt^1][j][x+1]);
if(a[i+1]==b[y+1]) f[cnt^1][j][x]+=t,Mod(f[cnt^1][j][x]);
if(b[j+1]==a[x+1]) f[cnt][j+1][x+1]+=t,Mod(f[cnt][j+1][x+1]);
if(b[j+1]==b[y+1]) f[cnt][j+1][x]+=t,Mod(f[cnt][j+1][x]);
```


又因为 $n,m$ 最大为500，三维数组是无法存下的。通过观察状态转移方程，对于 $i+1$ 的相关状态只与 $i$ 的状态有关，可以使用滚动数组实现。

初始值 $f(0,0,0)=1$ 。

## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
const int P=1024523;
char a[N],b[N];
int n,m;
int f[2][N][N]; //滚动数组
void Mod(int &x)//取模，这样会比正常的取模运算(%)快一点
{
	if(x>P) x-=P;
}
int main()
{
	scanf("%d%d %s%s",&n,&m,a+1,b+1); 
	int cnt=0;
	f[0][0][0]=1;
	for(int i=0;i<=n;i++,cnt^=1)
	{
          for(int j=0;j<=m;j++)
          {
              for(int x=0;x<=n;x++)
                  {
                      int y=i+j-x;
                      int t=f[cnt][j][x];
                      if(!t) continue;
                      if(y<0||y>m) continue;
                      if(a[i+1]==a[x+1]) f[cnt^1][j][x+1]+=t,Mod(f[cnt^1][j][x+1]);
                      if(a[i+1]==b[y+1]) f[cnt^1][j][x]+=t,Mod(f[cnt^1][j][x]);
                      if(b[j+1]==a[x+1]) f[cnt][j+1][x+1]+=t,Mod(f[cnt][j+1][x+1]);
                      if(b[j+1]==b[y+1]) f[cnt][j+1][x]+=t,Mod(f[cnt][j+1][x]);
                      f[cnt][j][x]=0;
                  //	cout<<f[cnt^1][j][x+1]<<" "<<f[cnt^1][j][x]<<" "<<f[cnt][j+1] [x+1]<<" "<<f[cnt][j+1][x]<<endl;
                  }
              }
	}
	printf("%d\n",f[cnt][m][n]%P);
    	return 0;
}
```


---

## 作者：peterwuyihong (赞：2)

不会 dp，于是来写一个 dp 记录。

题意：有两个栈，一个长为 $n$，一个长为 $m$，里面装了很多黑猪和白猪，你可以任意地选一个栈并将栈顶的猪扔入答案栈中，那么答案栈里就会出现很多种黑白猪相间的情况，假设 $i$ 情况的操作方案有 $a_i$ 个，显然 $\sum a_i=\dbinom{n+m}n$，求出 $\sum{a_i^2}$。

首先来一波人类智慧的操作，就是把 $a_i^2$ 看成操作两次都出现 $i$ 情况的情况数。

然后你 dp，你用 $f[i][j][k]$ 表示当前第 $i$ 轮，第一个人取了上面 $j$ 个球，第二个人取了上面 $k$ 个球，那么你就可以得到一个转移。

$$f[i][j][k]\leftarrow[a[j]=a[k]]f[i-1][j-1][k-1]$$
$$f[i][j][k]\leftarrow[a[j]=b[i-k]]f[i-1][j-1][k]$$
$$f[i][j][k]\leftarrow[b[i-j]=a[k]]f[i-1][j][k-1]$$
$$f[i][j][k]\leftarrow[b[i-j]=b[i-k]]f[i-1][j][k]$$

然后滚掉第一维就行了。


```cpp
#define maxn 510
const int p=1024523;
int n,m;
char a[maxn],b[maxn];
void add(int &x,int y){
	((x+=y)>=p)&&(x-=p);
}
int f[2][maxn][maxn];
signed main(){
	cin>>n>>m;
	cin>>a+1>>b+1;
	reverse(a+1,a+n+1);
	reverse(b+1,b+m+1);
	f[0][0][0]=1;
	rep(i,1,n+m){
		rep(j,0,n)rep(k,0,n)f[i&1][j][k]=0;
		rep(j,0,n)
		rep(k,0,n){
			if(j&&k&&a[j]==a[k])add(f[i&1][j][k],f[(i&1)^1][j-1][k-1]);
			if(i-k>=1&&j&&a[j]==b[i-k])add(f[i&1][j][k],f[(i&1)^1][j-1][k]);
			if(i-j>=1&&k&&a[k]==b[i-j])add(f[i&1][j][k],f[(i&1)^1][j][k-1]);
			if(i-j>=1&&i-k>=1&&b[i-j]==b[i-k])add(f[i&1][j][k],f[(i&1)^1][j][k]);
		}		
	}
	cout<<f[(n+m)&1][n][n];
/*
cmll02推荐的好题
现在是 21:51，我看我什么时候写完。
现在是 22:06，我写完了。
*/
}
```
上界调错了，$114514$ 了好久。。。

---

## 作者：Fa1thful (赞：2)

上来没思路怎么办！当然搜索啊！

### Part1：搜索
#### 算法思路：

枚举所有的情况，得到所有的$a_i$值，累加平方和，用二进制处理状态，开散列保存状态。

#### 时间复杂度：

每一步是$2$种可能，一共$m+n$步，于是时间复杂度为$O(2^{n+m})$
#### 备注：
对于题目数据:

$30$% 的数据，满足 $m,n≤12$；

$100$% 的数据，满足 $1≤m,n≤500$。

我们的搜索已经可以拿到$30$分左右了。

#### 代码：
```cpp
# include <bits/stdc++.h>
#define ll long long
#define MOD 1024523
#define MAX 555
using namespace std;
const int NR = 1 << 24;
int a[NR];
int n, m, ans;
char S1[MAX], S2[MAX];
void add(int &x, int y)
{
	x += y;
	if (x >= MOD) x -= MOD;
}
void dfs(int n, int m, int S)
{
	if (!n && !m)
	{
		a[S]++;
		return;
	}
	if(n) dfs(n - 1, m, (S << 1) | (S1[n] - 'A'));
	if(m) dfs(n, m - 1, (S << 1) | (S2[m] - 'A'));
}
int main()
{
	scanf("%d%d", &n, &m);
	scanf("%s", S1 + 1);
	scanf("%s", S2 + 1);
	dfs(n, m, 0);
	for (int i = 0; i < NR; i++)
	{
		add(ans, 1ll * a[i] * a[i] % MOD);
	}
	printf("%d\n", ans);
	return 0;
}
```
### Part2：动态规划
为了拿到满分，我们总是想尽一切办法......
#### 算法思路：

 题目中设$a_i$为最终序列的某种方案数，而让我们求解的却是$(a_i)^2$，很明显我们需要找出两者的关系.

 假设我们有两个完全相同且独立的系统，两个人同时进行操作，不难证明，对于某个最终序列 F，两个人操作完成后得到的序列都与 F 相同的方案数即为$(a_i)^2$


 我们设$dp[i][j][k][l]$为第一个人从管道一取了 $i$ 个球，第一个人从管道二取了 $j$ 个球，第二个人从管道一取了 $k$ 个球，第二个人从管道二取了 $l$ 个球，且当前所构成序列相同的方案数.

 但是，这样的状态表示时空都会爆掉滴. 由于两个序列相同，那么 $i + j = k + l$，所以我们可以省略一维，除此之外对第一维进行滚动优化，这样就可以 AC 啦！
 
####  转移方程：
```cpp
if (s[i + 1] == s[k + 1]) f[p ^ 1][j][k + 1] = (f[p ^ 1][j][k + 1] + f[p][j][k]) % mod;
if (s[i + 1] == t[l + 1]) f[p ^ 1][j][k] = (f[p ^ 1][j][k] + f[p][j][k]) % mod;
if (t[j + 1] == s[k + 1]) f[p][j + 1][k + 1] = (f[p][j + 1][k + 1] + f[p][j][k]) % mod;
if (t[j + 1] == t[l + 1]) f[p][j + 1][k] = (f[p][j + 1][k] + f[p][j][k]) % mod;
```
#### 代码实现：

```cpp
# include <bits/stdc++.h>
using namespace std;
const int M = 5e2;
const int mod = 1024523;
const int inf = 0x3f3f3f3f;
const double eps = 1e-8;
int n, m;
char s[M + 5], t[M + 5];
int f[2][M + 5][M + 5];
int main()
{
    scanf("%d %d", &n, &m);
    scanf("%s %s", s + 1, t + 1);
    reverse(s + 1, s + n + 1); 
	reverse(t + 1, t + m + 1);
    f[0][0][0] = 1; //dp初始值 
    for (int i = 0, p = 0; i <= n; i++, p ^= 1)
    {
        for (int j = 0; j <= m; j++)
        {
            for (int k = 0; k <= n; k++)
            {
                int l = i + j - k;
                if (l < 0 || l > m) continue;
                if (!f[p][j][k]) continue;
                if (s[i + 1] == s[k + 1]) f[p ^ 1][j][k + 1] = (f[p ^ 1][j][k + 1] + f[p][j][k]) % mod;
                if (s[i + 1] == t[l + 1]) f[p ^ 1][j][k] = (f[p ^ 1][j][k] + f[p][j][k]) % mod;                   //转移方程 
                if (t[j + 1] == s[k + 1]) f[p][j + 1][k + 1] = (f[p][j + 1][k + 1] + f[p][j][k]) % mod;
                if (t[j + 1] == t[l + 1]) f[p][j + 1][k] = (f[p][j + 1][k] + f[p][j][k]) % mod;
                f[p][j][k] = 0;
            }
        }
    }
    printf("%d\n", f[(n + 1) & 1][m][n]); 
    return 0;
}
```



---

## 作者：Pro_Rexxar (赞：2)

[题目](https://www.luogu.org/problem/P1758)

本来觉得应该是一道数学找规律的题目

但是看到 $n$ 和 $m$ 只有500，感觉应该不是找规律

~~（如果是找规律的话就太水了）~~

考虑如何将 $\sum a^2_i$ 转化

可以看成对于第 $i$ 种序列，一个人可以取 $a_i$ 种方案，另一个人也可以取 $a_i$ 种方案

那么 $a^2_i$ 就可以表示两个人各自都取，两个人都取出第 $i$ 种序列的方案数

那么用 $dp$ 转移一下，就好嘞

某wrt大佬说冗长的式子取地址会快，我就用了

```
#include <bits/stdc++.h>
#define MAXN 507
#define Mod 1024523
using namespace std;
int n,m,a[MAXN],b[MAXN],f[2][MAXN][MAXN];
char s[MAXN];
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",s);
	for (int i=0;i<=n-1;i++)
		a[n-i]=s[i]-'A';
	scanf("%s",s);
	for (int i=0;i<=m-1;i++)
		b[m-i]=s[i]-'A';
	f[0][0][0]=1;
	for (int k=1;k<=n+m;k++)
	{
		int lower = max(0, k - m), upper = min(n, k);
		for (int i=lower;i<=upper;i++)
			for (int j=lower;j<=upper;j++)
			{
				int &t = f[k & 1][i][j];
				if (k&&i&&j&&a[i]==a[j]) (t+=f[(k+1)&1][i-1][j-1])%=Mod;
				if (k&&b[k-i]==b[k-j]) (t+=f[(k+1)&1][i][j])%=Mod;
				if (k&&i&&a[i]==b[k-j]) (t+=f[(k+1)&1][i-1][j])%=Mod;
				if (k&&j&&a[j]==b[k-i]) (t+=f[(k+1)&1][i][j-1])%=Mod;
			}
		memset(f[(k+1)%2],0,sizeof(f[(k+1)%2]));
	}
	printf("%d\n",f[(n+m)%2][n][n]);
	return 0;
}
```

---

## 作者：nosta (赞：2)

sum a\[i\]\*a\[i\]可以理解为两个独立但同时进行的游戏得到同一个输出序列的方案数。

设f\[l,i,j\]为每个游戏都已经推出了l个珠子时，第一个游戏里上边儿的管道已经推出了i个，第二个游戏中上边儿管道推出了j个的方案数。

考虑到若要推出序列相同，那么对于每个阶段l，两个游戏的推出序列应始终相等。这样，跑跑计数dp就好了

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=507;
const int P=1024523;

int n,m;
char a[N],b[N];
int f[2][N][N];

inline void add(int&x,int y) {
	if((x+=y)>=P) x-=P;
}

int main() {
	scanf("%d%d%s%s",&n,&m,a+1,b+1);
	f[0][0][0]=1;
	int now=0, nxt=1;
	for(int l=0; l<n+m; ++l) {
		for(int i=0; i<=l && i<=n; ++i) {
			for(int j=0; j<=l && j<=n; ++j) {
				if(!f[now][i][j]) continue;
				if(a[i+1]==a[j+1]) add(f[nxt][i+1][j+1],f[now][i][j]);
				if(a[i+1]==b[l-j+1]) add(f[nxt][i+1][j],f[now][i][j]);
				if(b[l-i+1]==a[j+1]) add(f[nxt][i][j+1],f[now][i][j]);
				if(b[l-i+1]==b[l-j+1]) add(f[nxt][i][j],f[now][i][j]);
				f[now][i][j]=0;
			}
		}
		now=nxt, nxt^=1;
	}
	printf("%d\n",f[now][n][n]);
}
```


---

## 作者：Agakiss (赞：2)

### Description
[[NOI2009]管道取珠](https://www.luogu.org/problem/P1758)
### Solution
对于$\sum a[i]^2$

我们不如把它理解成

一个取珠游戏A和一个取珠游戏B同时举行，当A中的任意一个结果和B中的任意一个结果相同时，我们把它加进方案

f[i][j]表示A游戏中上管道取了i个球，B游戏中上管道取了j个球(一个循环枚举k，所以A游戏中下管道取了k-i个球，B游戏中下管道取了k-j个球)

于是便非常的简单了
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define MAXN 610
#define MOD 1024523
int n, m;
int a[MAXN], b[MAXN], f[MAXN][MAXN], c[MAXN][MAXN];
inline int read() {
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
int main() {
	n = read(), m = read();
	for (register int i = 1; i <= n; i++)
		a[n + 1 - i] = getchar() - 'A';
	getchar();
	for (register int i = 1; i <= m; i++)
		b[m + 1 - i] = getchar() - 'A';
	f[0][0] = 1;
	for (register int k = 1; k <= n + m; k++) {
		for (register int i = max(0, k - m); i <= min(k, n); i++)
			for (register int j = max(0, k - m); j <= min(k, n); j++) {
				c[i][j] = 0;
				if (a[i] == a[j] && i && j)
					(c[i][j] += f[i - 1][j - 1]) %= MOD;
				if (a[i] == b[k - j] && i)
					(c[i][j] += f[i - 1][j]) %= MOD;
				if (b[k - i] == a[j] && j)
					(c[i][j] += f[i][j - 1]) %= MOD;
				if (b[k - i] == b[k - j])
					(c[i][j] += f[i][j]) %= MOD;
			}
		for (register int i = 0; i <= min(k, n); i++)
			for (register int j = 0; j <= min(k, n); j++)
				f[i][j] = c[i][j];
	}
	printf("%d", f[n][n]);
	return 0;
}
```

---

## 作者：Zxsoul (赞：0)

**前言**

>第一次做 NOI 的题，居然能拿 $60$ ，饭太死忒可！

**思路**

先对答案进行分析 $\sum a_i^2$，我们看成两个人玩，然后两个人分别取到序列 $T_i$ 的方案数，其中一个人取到 $T_i$ 的方案数有 $a_i$ 个，两个人取数互不影响，因此 $a_i^2$ 也就表示二人取出相同序列的所有方案数，即二者乘积

所以题目转化为：二人分别取珠，最后得到的序列相同的方案数

在我们了解的几个基础序列DP题目中，可以猜想到我们必然**需要多种状态**，而且可以**省去几维**，同时我们设定的状态还必须**准确**，如炮车中的三种棋子个数，三种颜色的最后位置……因此这里我们也需要知道一些有用的信息作为限制转移的条件，

这里不妨设二人长度都为 $i$ ，并且从上管道去了 $j,k$ 个，即 $f[i][j][k]$，
转移有：
$$
f[i][j][k]= \begin{cases}
    f_{i-1,j-1,k-1}&\lfloor  a_j=a_k \rfloor\\
    f_{i-1,j-1,k}&\lfloor a_j=b_{i-k}\rfloor\\
    f_{i-1,j,k-1}&\lfloor a_k=b_{i-j} \rfloor\\
    f_{i-1,j,k}&\lfloor b_{i-j}=b_{i-k} \rfloor\\
\end{cases}
$$
$O(N^3)$

然后完美的得到了令人赛艇的 $60$ 分，然后考虑删维数，但是发现维数已经不可以在删了，所以考虑滚动，我们发现 $f_i$ 只由 $f_{i-1}$ 转移且只会转移给 $f_{i+1}$ 我觉着可以滚动，就是我的滚动方法和大家的略有不同，是一位同房大佬教我的方法

**注/:** 转移时防止负数的产生

**后言**
> 这题让我学到蛮多的，开始时我的答案总是出现负数，而且答案都有漏，我发现部分转移都是 $0$，所以我开始从小数据手模，得到所有的初始化。我觉着如果初始化不会找的话，手模也是一个不错的选择，很高兴可以在NOI类题目中通过下我的题解

```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int n,m;
char a[510],b[510];
int f[2][510][510];

int main()
{
	n=read(),m=read();
	for (int i=n;i>=1;i--) cin>>a[i];
	for (int i=m;i>=1;i--) cin>>b[i];
	
	f[0][0][0]=1;
	
	for (int i=1;i<=m+n;i++)
	{
		for (int j=0;j<=min(i,n);++j)
			for (int k=0;k<=min(i,n);++k)
				f[i&1][j][k]=0;
				
		for (int j=0;j<=min(i,n);++j)
			for (int k=0;k<=min(i,n);++k)
			{
				if (a[j]==a[k] && j>=1 && k>=1) (f[i&1][j][k]+=f[i+1&1][j-1][k-1])%=mod;
				if (a[j]==b[i-k] && j>=1) (f[i&1][j][k]+=f[i+1&1][j-1][k])%=mod;
				if (a[k]==b[i-j] && k>=1) (f[i&1][j][k]+=f[i+1&1][j][k-1])%=mod;
				if (b[i-j]==b[i-k]) (f[i&1][j][k]+=f[(i+1)&1][j][k])%=mod;
			}
	}
	printf("%d",f[(n+m) & 1][n][n]);
	return 0;	
}


```

---

## 作者：Kiloio (赞：0)

# DP  
先设一波状态，$f[a][b][c][d]$表示：  
1. 在**第$1$个管道**中，第$1$次取了$a$个，第$2$次取了$c$个。  
1. 在**第$2$个管道**中，第$1$次取了$b$个，第$2$次取了$d$个。  
  
### 然后优化。  
1. 首先可以用**滚动数组**

2. 其次可以省**略最后一维**。因为$a+b$是等于$c+d$的，知道$a$、$b$、$c$就可算出$d$。  
  
接下来就枚举总次数，**再细化**到$2$个管道的次数。根据$4$种情况（详见代码）写。

没了。  
  
代码：  
```
#include <bits/stdc++.h>
using namespace std;
int n,m,f[3][501][501];
char a[501],b[501];
const int mod=1024523;
int main(){
	cin>>n>>m;
	scanf("%s%s",a+1,b+1);
	f[0][0][0]=1;
	int now=0,next_=1;
	for(int op=0; op<n+m; op++) {
		for(int i=0; i<=n && i<=op; i++) {
			for(int j=0; j<=n && j<=op; j++) {
				
				if(f[now][i][j]==0){//要优化一下，不然会超时 
					continue;
				}
				
				//四种情况： 				
				if(a[i+1]==a[j+1]){
					f[next_][i+1][j+1]+=f[now][i][j];
					f[next_][i+1][j+1]%=mod;
				}
				
				if(b[op-i+1]==b[op-j+1]){
					f[next_][i][j]+=f[now][i][j];
					f[next_][i][j]%=mod;
				} 
				
				if(a[i+1]==b[op-j+1]){
					f[next_][i+1][j]+=f[now][i][j];
					f[next_][i+1][j]%=mod;
				}
				
				if(a[j+1]==b[op-i+1]){
					f[next_][i][j+1]+=f[now][i][j];
					f[next_][i][j+1]%=mod;
				}	
							
				f[now][i][j]=0;
			}
		}
		now=next_,next_^=1;
	}
	cout<<f[now][n][n];
}
```


---


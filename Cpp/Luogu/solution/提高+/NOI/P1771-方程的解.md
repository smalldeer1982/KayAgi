# 方程的解

## 题目描述

佳佳碰到了一个难题，请你来帮忙解决。对于不定方程 $a_1+a_2+\cdots +a_{k-1}+a_k=g(x)$，其中 $k\ge 2$ 且 $k\in \mathbb{N}^*$，$x$ 是正整数，$g(x)=x^x \bmod 1000$（即 $x^x$ 除以 $1000$ 的余数），$x,k$ 是给定的数。我们要求的是这个不定方程的正整数解组数。

举例来说，当 $k=3,x=2$ 时，方程的解分别为：
$$\begin{cases} a_1=1\\ a_2=1\\ a_3=2 \end{cases}$$
$$\begin{cases} a_1=1\\ a_2=2\\ a_3=1 \end{cases}$$
$$\begin{cases} a_1=2\\ a_2=1\\ a_3=1 \end{cases}$$

## 说明/提示

- 对于 $40\%$ 的数据，$\mathit{ans} \le 10^{16}$；
- 对于 $100\%$ 的数据，$k \le 100$，$x \le 2^{31}-1$，$k \le g(x)$。

NOI导刊2010提高（01）


## 样例 #1

### 输入

```
3 2```

### 输出

```
3```

# 题解

## 作者：w (赞：111)

其实嘛 这道题就是求杨辉三角形第(x^x) % 1000行的第k个 实现上要用高精度和快速幂


---

## 作者：DPair (赞：23)

## python题解，不喜勿喷
## 【推理】
首先，对于$x^x~mod~1000$这个式子，用快速幂求得不用解释吧。。。
这样，我们等于是把题意转换成了这样

求不定方程
$$a_1 + a_2 + a_3 + ...... + a_k = g(x)$$
的正整数解数。

其中
$$k <= 100,~g(x) <= 1000$$

楼下很多巨佬都想到了组合数，用插空法可以证明。

## 【证明】

首先，我们设有$g(x)$个物品。

等于说，我们要得到把这么多物品分成$k$份的方法数。

例如，样例中的$k = 3,~g(x)=4$

我们就理解成把$4$个物体分成$3$份，由于题目中明确$(1, 1, 2)(1, 2, 1)(2, 1, 1)$不同，我们考虑不直接从物体入手，而从**空**入手。

如图![](https://cdn.luogu.com.cn/upload/pic/59135.png)
为4个物品，我们考虑把它分成$3$份的方式，就是在空隙中插入$3-1=2$块隔板，分成$3$个部分。

由于$(1, 1, 2)(1, 2, 1)(2, 1, 1)$不同，所以对于![](https://cdn.luogu.com.cn/upload/pic/59136.png)

![](https://cdn.luogu.com.cn/upload/pic/59137.png)

![](https://cdn.luogu.com.cn/upload/pic/59138.png)

是不同的

根据这幅图，我们不难看出，$g(x)$个物品有$g(x)-1$个空隙，而$k$个数看做$k-1$个隔板。

因此，把$g(x)$个物品分为$k$个数有
$$C_{g(x)-1}^{k-1}$$
种方法。

然后，这么写就可以了，组合数不用我讲吧。。。
## 【代码】

### 但是！

由于$g(x)<=1000$，所以我们要使用高精度。

懒得写高精的我写了个$python$，居然$500ms$水过了。。。

```python
def ksm(x, y):
    ret = int(1)
    tmp = int(y)
    while tmp > 0:
        if (tmp % 2) == 1:
            ret = (ret * x) 
            ret = ret % 1000
        tmp = tmp // 2
        x = (x * x)
        x = x % 1000
    ret %= 1000
    return ret

n, k = map(int, input().split())
fac = [0] * 1010
fac[0] = 1
for i in range(1, 1001):
    fac[i] = fac[i - 1] * i
k = ksm(k, k)
n = n - 1
k = k - 1
if k >= n:
    c = fac[k]
    c = c // fac[n]
    c = c // fac[k - n]
    print(c)
else :
    print(0)
```

---

## 作者：doby (赞：18)

我应该是本题第一个cpp题解……

首先，观察样例后可以发现这是一个组合数

用插板法(吗？)可以得出答案为C(k,x^x%1000)

然后就是写快速幂和高精度了……

```cpp
#include<cstdio>
using namespace std;
int b,a,ans,x,y,c[760]={1,1};
int pow(int b,int p,int k)//快速幂
{
    ans=1;
    while(p)
    {
        if(p&1){ans=(ans*b)%k;}
        b=b*b%k,p>>=1;
    }
    return ans;
}
void print(int p[])//输出
{
    printf("%d",p[p[0]]);//这里压了四位，所以输出也不一样
    for(int i=p[0]-1;i>=1;i--){printf("%d%d%d%d",p[i]/1000,p[i]/100%10,p[i]/10%10,p[i]%10);}
    return;
}
void comb(int n,int m)//组合数
{
    for(int k=1;k<=m;k++)
    {
        for(int i=1;i<=c[0];i++){c[i]*=(n-k+1);}
        for(int i=1;i<=c[0];i++){c[i+1]+=c[i]/10000,c[i]%=10000;}//乘+进位
        while(c[c[0]+1]){c[0]++;}//更新位数
        for(int i=c[0],y=0;i>=1;i--){y=y*10000+c[i],c[i]=y/k,y%=k;}
        while(!c[c[0]]){c[0]--;}//除+退位
    }
}
int main()
{
    scanf("%d%d",&b,&a);
    a%=1000,a=pow(a,a,1000)-1,b--;
    comb(a,b);
    print(c);
    return 0;
}
```

---

## 作者：21002tyj (赞：5)

对于40%的数据 ans <= 10^16； 对于100%的数据 k <= 100，x <= Maxlongint， 且 k <= G(x); 求G(x)不难，二分求幂就可以，但对于求答案，我的第一反应是深搜。虽然注意到了数据范围，但仍然值得尝试。结果发现当k=5时就已经慢的无法忍受了。 然后发现，这题需要用高精度。于是又码了高精。k=4的时候就非常吃力了。 然后我居然想到了动态规划。f[i,j]表示A1+A2+..+Ai = j 时解的个数。于是f[i,j] = sum{f[i-1,k]} (i-1<=k<j)此时Ai = j-k。 那么空间又不够了，考虑滚动数组，将空间复杂度减小至G(x) ，于是拿了40分，似乎跟不用高精一样。。。 其实这题是一个盒子装小球模型。一共有G(x)个小球装k-1个格子。那么答案就是C(G(x)-1,k-1)。对于N!可以这样处理：

    
求出1000以内的素数；


    
对于每一个n进行循环；


    
循环到的每一个i分解质因数，将分解的结果只保存次数


    
全部结束之后在用高精度乘出来。


于是乎AC


---

## 作者：冒泡ioa (赞：3)

首先呢，$g(x)$我们是可以求解的，我们设$n=g(x)$  
我们可以先写出$n$个1，我们发现它们之间有$n-1$个空隙，而我们的任务是寻找k个数，使k个数的和等于$n$，于是我们就可以将问题转化成在$n-1$个空隙中选出$k-1$个空隙放挡板，形成的$k$个数的和正好就是$n$。  
换句话说，我们要求$C_{n-1}^{k-1}$  
对于样例的画图辅助理解  
![](https://s1.ax1x.com/2018/08/15/PRdr7Q.png)
## 代码
```c++
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const int MAXN = 100, mod = 1000, inf = 1000000;
ll k, x, n;
ll sum[MAXN], cnt = 1;

ll qpow(ll a, ll b) {
    ll ans = 1;
    while (b) {
        if (b & 1)ans = ans * a%mod;
        a = a * a%mod;
        b >>= 1;
    }
    return ans;
}

void c(ll n, ll m) {
    sum[1] = 1, cnt = 1;
    for (int i = m; i >= m - n + 1; i--) {//对组合数公式进行了化简
        for (int j = 1; j<MAXN; j++) {
            sum[j] *= i;
        }
        for (int j = 1; j<MAXN; j++) {
            if (sum[j] >= inf) {
                sum[j + 1] += sum[j] / inf;
                sum[j] %= inf;
            }
        }
    }
    for (int i = 2; i <= n; i++) {
        for (int j = MAXN-1; j >= 1; j--) {
            if (sum[j] == 0)   continue;
            if (sum[j] >= i) {
                sum[j - 1] += sum[j] % i*inf;
                sum[j] /= i;
            }
            else sum[j - 1] += sum[j] * inf, sum[j] = 0;
        }
    }
}

int main() {
    ll k, x;
    cin >> k >> x;
    n = qpow(x, x);
    if (k - 1 <= 0 || n - 1 <= 0) {
        printf("0");
        return 0;
    }
    c(k - 1, n - 1);//总共有n-1个间隙，要插k-1个隔板；
    int id;
    for (int i = MAXN - 1; i >= 1; i--) {
        if (sum[i]) {
            id = i;
            break;
        }
    }
    printf("%lld", sum[id]);
    for (int i = id-1; i >= 1; i--) {
        printf("%06lld", sum[i]);
    }
    return 0;
}
```

---

## 作者：荣一鸣 (赞：3)

~~一看就是数论~~

# 知道是数论也不会做！！！

x^x%1000可以用快速幂做

没做过的可以走这里[快速幂](https://www.luogu.org/problemnew/show/P1226)

所以就是关于**将n分为k份并求求其全排列**的问题，其实也就是**从n个物品里取k个的组合数**

说到这里相信就都明白了，公式就是n!/k!/(n-k)!

这里用高精度计算就行了

```
#include<iostream>
#include<cstdio>
using namespace std;
int k,x;
int mod=1000;
int a[10100];

int mulm(int a,int b){//快速模幂
	if(b==1) return a;
	int t=mulm(a,b>>1);
	t*=t;
	t%=mod;
	if(b%2==1){
		t*=a;
		t%=mod;
	}
	return t;
}

void comb(int n,int m){//求组合
	a[1]=1;
	a[0]=1;
	for(int i=m+1;i<=n;i++){
		for(int j=1;j<=a[0];j++){
			a[j]*=i;
		}
		int tmp=0;
		for(int j=1;j<=a[0];j++){
			tmp+=a[j];
			a[j]=tmp%10;
			tmp/=10;
		}
		while(tmp){
			a[++a[0]]=tmp%10;
			tmp/=10;
		}
	}
	for(int i=2;i<=n-m;i++){
		int tmp=0;
		for(int j=a[0];j>=1;j--){
			tmp*=10;
			tmp+=a[j];
			a[j]=0;
			if(tmp>i){
				a[j]=tmp/i;
				tmp%=i;
			}
		}
		while(a[a[0]]==0) a[0]--;
	}
}

int main(){
	cin>>k>>x>>mod;
	x%=mod;//别忘了先模一下，不然可能会炸
	x=mulm(x,x);
	comb(x-1,k-1);
	for(int i=a[0];i>=1;i--) cout<<a[i];
	return 0;
}
```

---

## 作者：龙·海流 (赞：2)

标签好歹有DP，来一发DP的思路。。。

（在我没有提到高精的时候，暂时不用考虑高精）

题目大意：求a1+...+ak=g（x）%1000的所有a的解的方案数。。。

状态：设a[i][j]表示前i个数和为j的方案数，假设k=3，g(x)=4，那么a[1][1]表示前1个数和为1的情况，显然，a[1][1到4]的方案数都为1。

转移：有了状态了，怎么考虑转移呢？
a[1][1]表示前1个数和为1的方案，如果第2个数是1，那么a[2][2]就可以由a[1][1]转移而来，同理，a[2][3],a[2][4],也可以由a[1][1]转移而来。。。

![](https://cdn.luogu.com.cn/upload/pic/74201.png )
```cpp
//方程1：
for(int i=1;i<k;++i)
for(int j=1;j<=g(x);++j)//枚举前i项的和
for(int k=1;j+k<=g(x);++k)//枚举第i+1项的值
a[i+1][j+k]+=a[i][j];
```
如果我们换个角度考虑，a[3][4]可以由a[2][3],a[2][2]转移而来，考虑到a[2][1]为0，那么实际上a[3][4]就是a[2][1到3]的和，即a[i][j]=sum(a[i-1][1]...a[i-1][j-1])。那要怎么写方程呢？

观察：

a[2][2]=a[1][1];

a[2][3]=a[1][1]+a[1][2];

a[2][4]=a[1][1]+a[1][2]+a[1][3];

显然，前3项和=前2项和+第3项和；

所以对上述式子进行化简：

a[2][2]=a[2][1]（即0）+a[1][1];

a[2][3]=a[2][2]+a[1][2];

a[2][4]=a[2][3]+a[1][3];

由此得第二个方程：
```cpp
for(int i=1;i<=k;++i)
for(int j=i;j<=n;++j)
a[i][j]=a[i][j-1]+a[i-1][j-1];
```
第二行j是从i开始的，为啥？比如a[3][2]=0，因为3个正整数凑不出2，三个正整数凑出的最小值是3，所以从j=i开始枚举；

到这里基本上可以做题了，不过就是把a数组多加一维进行高精+，细节我会注释在代码中；

但是，有没有感觉这个方程很熟悉，@空江百叶 大佬一眼看出这就是杨辉三角的递推式，
不信？你可以看看a数组的值
![](https://cdn.luogu.com.cn/upload/pic/74209.png )
好吧，其实答案就是C(g(x)-1,k-1),然而我写了一下午的高精乘只过了小数据的40分，于是考虑DP，~~结果被大佬一眼识破组合数~~
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long k,x,n=1;
int a[105][1000][200];//千万注意空间
void fz(int i,int j,int x,int y)
{
	a[i][j][0]=a[x][y][0];
	for(int o=1;o<=a[i][j][0];++o) a[i][j][o]=a[x][y][o];
}
void jia(int i,int j,int x,int y)
{
	int l=max(a[i][j][0],a[x][y][0]);
	for(int o=1;o<=l;++o) a[i][j][o]+=a[x][y][o];
	for(int o=1;o<l;++o) 
	while(a[i][j][o]>9)//高精＋的进位数很小，所以可以用循环－模拟，节省时间，
	{
		a[i][j][o+1]++;
		a[i][j][o]-=10;
	}
	while(a[i][j][l]>0)
	{
		while(a[i][j][l]>9)
		{
			a[i][j][l+1]++;
			a[i][j][l]-=10;
		}
		++l;
	}
	while(a[i][j][l]==0) --l;//避免前导0
	a[i][j][0]=l;
}
int main()
{
//	freopen("equation.in","r",stdin);
//	freopen("equation.out","w",stdout);
	scanf("%lld%lld",&k,&x);
	unsigned long long b=x;
	x=x%1000;
	while(b)
	{
		if(b&1) n=n*x%1000;
		b>>=1;
		x=x*x%1000;
	}
	a[1][0][0]=1,a[1][0][1]=1;
	for(int i=1;i<=k;++i)
	for(int j=i;j<=n;++j)
	{
		fz(i,j,i,j-1);//由于初始a[i][j]为0，所以直接把a[i][j-1]赋值给a[i][j]
		jia(i,j,i-1,j-1);
	}
	for(int i=a[k][n][0];i>0;--i)cout<<a[k][n][i];
	return 0;
}
```


---

## 作者：夏色祭 (赞：2)

#没有人发代码，我来补一发

#为什么要用dp，这不应该是题数论题吗？？？真的是假的吧。。。

#而且dp慢到爆炸，而数论0ms。。。

对于x^x mod 1000，我们用快速幂就行了。

对于把这x^x mod 1000分成为k个数，蒟蒻的我推出的公式是C(x^x mod 1000-1,k-1)（似乎是杨辉三角的通向公式）

然后分解质因数（1000以内的素数就行了，因为x^x模了1000），约分，再用高精度相乘计算

##妖怪吧

丑陋的代码，非丑陋之人不得欣（fu）赏（zhi）：

```cpp
const
  p=1000;
var
  b:array[0..1001]of boolean;
  a,ans,c:array[0..1001]of longint;
  n,m,x,xx,i,j:longint;
function power(x,y:longint):longint;
var
  t:longint;
begin
  if y=1 then exit(x);
  t:=power(x,y div 2) mod p;
  t:=(t*t) mod p;
  if odd(y) then t:=(t*x) mod p;
  exit(t); 
end; //快速幂
procedure zz(x,y:longint);
var
  i:longint;
begin
  while x<>1 do 
    begin
      if not b[x] then 
        begin
          inc(ans[x],y);
          exit;
        end;
      for i:=1 to m do 
        if x mod a[i]=0 then begin inc(ans[a[i]],y);x:=x div a[i];break; end;
    end;
end;//分解质因数
procedure mul(tt:longint);
var
  i,x:longint;
begin
  x:=0;
  for i:=1 to 1000 do 
    begin
      c[i]:=c[i]*tt+x;
      x:=c[i] div 10;
      c[i]:=c[i] mod 10;
    end;
end;//高精度乘
begin
  readln(n,x);
  xx:=power(x mod p,x);
  for i:=2 to p do
    if not b[i] then  
      for j:=2 to p div i do 
        b[i*j]:=true;
  for i:=2 to 1000 do 
    if not b[i] then 
      begin
        inc(m);
        a[m]:=i;
      end;//筛法求素数
  dec(xx); dec(n);
  for i:=xx-n+1 to xx do zz(i,1);
  for i:=2 to n do zz(i,-1);//分解质因数再约分
  c[1]:=1;
  for i:=2 to p do 
    while ans[i]>0 do 
      begin
        dec(ans[i]);
        mul(i);
      end;//最后把约分剩下的乘起来
  j:=1000;
  while (c[j]=0)and(j>1) do dec(j);
  for i:=j downto 1 do write(c[i]);//输出
end.
```

---

## 作者：suxxsfe (赞：1)

[P1771 方程的解](https://www.luogu.com.cn/problem/P1771)
都知道这个题可以用隔板法做  
把这个$g(x)$想象为.....$g(x)$个苹果？  
因为解是正整数，所以给这些“苹果”分组的时候每组最少有一个  
然后我们在这$g(x)$个苹果形成的$g(x)-1$个空隙中插入$k-1$个板就把它分成了$k$组  
所以答案是$\binom{g(x)-1}{k-1}$  
然而组合数要用到除法，这题又要高精  
~~不过高精除低精好像也没有很难，莫名恐惧~~  
我们可以给每个数质因数分解，记录每个质因数出现次数，乘法时加一，除法时减一就行了~~然而这样并没有啥用~~  
不过这种方法可以运用在答案要模一个数，但模数不是质数不能求逆元的情况下  
要提前筛质数，一开始我居然认为$n$的质因数最大不超过$\sqrt{n}$，直接手打质数表，~~结果一直WA~~  
```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int p[1006],notp[1006];
int num[1006],a[10005];
inline void getprime(int n){
	for(reg int i=2;i<=n;i++){
		if(notp[i]) continue;
		p[++p[0]]=i;
		for(reg int j=i+i;j<=n;j+=i) notp[j]=1;
	}
}
inline int power(int a,int b){
	reg int ret=1;
	while(b){
		if(b&1) ret=(ret*a)%1000;
		a=(a*a)%1000;b>>=1;
	}
	return ret;
}
inline void fen(int x,int k){
	for(reg int i=1;i<=p[0]&&x>1;i++){
		for(;!(x%p[i]);x/=p[i])
			num[i]+=k;
	}
}
inline void mul(int x){
	for(reg int i=1;i<=a[0];i++) a[i]*=x;
	for(reg int i=1;i<a[0];i++) a[i+1]+=a[i]/10,a[i]%=10;
	for(;a[a[0]]>9;a[0]++) a[a[0]+1]+=a[a[0]]/10,a[a[0]]%=10;
}
int main(){
	int k=read()-1,x=read()%1000;
	x=power(x,x)-1;
//		std::printf("%d %d\n",k,x);
	getprime(std::max(k,x));
	a[0]=a[1]=1;
	for(reg int i=k+1;i<=x;i++) fen(i,1);
	for(reg int i=2;i<=x-k;i++) fen(i,-1);
	for(reg int i=1;i<=p[0];i++){
		for(reg int j=1;j<=num[i];j++) mul(p[i]);
	}
	for(reg int i=a[0];i;i--) std::printf("%d",a[i]);
	return 0;
}
```

---

## 作者：一只小兵 (赞：1)

emmm... 一道数论

## 思路

先用快速幂求出$g(x)$的值,问题就可以转化为一道求解不定方程:$a_{1} + a_{2} + \cdot \cdot \cdot + a_{k} = g(x)$ 的解。

---------------

## 主要过程

对于一个方程,解的个数满足:$ C^{k-1}_{g[x]-1}$ 

### 证明过程

先来观察题目中的样例:$a_{1}+a_{2}+a_{3}= 4$

就是将给g(x)进行拆分分成 $3$ 个正整数.

#### 考虑使用隔板法

![最初](https://cdn.luogu.com.cn/upload/pic/75104.png)

![然后](https://cdn.luogu.com.cn/upload/pic/75092.png)

从三个位置中选取两个位置可以等效为排列组合问题,即 $ C_{3}^{2} = 3 $所以最终的答案就是 $3$

    然后对于任意一个组合,都可以采用隔板法的思路.将其变为一个排列组合问题.

### 注意事项

1. 只有对于40%的数据答案范围在long long范围以内,需要高精乘法和高精除法(可以不用除法)
2. 注意无论是g(x)还是k都需要减1在进行计算

-----------

## 核心代码

1. 高精度乘法(这个可能都会)

~~~cpp
	for(register int i = m ; i > n ; i--){//从n+1乘到m
		for(register int j = cnt ; j >= 1 ; --j){//每一位都乘上i
			ans[j] *= i;
			if(ans[j] >= 10000 ) ans[j+1] += (ans[j]/10000);
			ans[j] %= 10000;
		}
		if(ans[cnt+1] > 0) cnt++;//高精度位数增加
	}
~~~

2. 高精度除法(这个可能会的不多)
~~~cpp
	for(register int i = 2 ; i <= m-n ; i++){//从2除到m-n
		for(register int j = cnt ; j >= 1 ; --j){//每一高精度位都除i
			if(ans[j] % i){
				long long k = ans[j]%i;//找余数
				ans[j] -= k;//减去余数
				ans[j-1] += (k*10000);//后一位加上余数
			}
			ans[j] /= i;//当前一位一定可以整除了
		}
		if(ans[cnt] == 0) cnt--;//位数减少
	}
~~~ 

#### 关于高精度除法的说明

对于一个数$\overline{abcde}$用高精度储存则为:$\overline{ab} \times 1000 + \overline{bcd}$

那么$\overline{abcde} \div \overline{k} $ 就可以转化为:$(\overline{ab} \times 1000 + \overline{bcd})\div \overline{k}$

设$ \overline{ab} \div \overline{k} = n \cdots m$ , 那么$(\overline{ab} \times 1000 + \overline{bcd})\div \overline{k} = \overline{n} \times 1000 + ( \overline{mcde} \div \overline{k} ) $

对于每一位都往后加,就可以进行高精度除法了
_______

## 最后附上AC代码

~~~cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int mod = 1e3;
long long read(){//快读
	char ch = getchar();
	bool flag = true;
	while(ch < '0' || ch > '9'){
		if(ch == '-') flag = false;
		ch = getchar();
	}
	long long k = ch - '0';
	while(ch = getchar(),ch <= '9' && ch >= '0' ){
		k = (k<<1)+(k<<3);
		k += (ch-'0');
	}
	return flag ? k : -k;
} 
long long kuai(long long num , long long k){//快速幂
	if(k == 1) return num%mod;
	if(k & 1){//奇数
		--k;
		long long now = kuai(num,k>>1)%mod;
		return now*now%mod*num%mod;
	}
	else {//偶数
		long long now = kuai(num,k>>1)%mod;
		return now*now%mod;
	}
}
long long ans[1000],cnt=1;//cnt表示位数
int main(){
	long long k=read(),x=read();
	long long g = kuai(x%mod,x);
	long long n = k-1,m=g-1,w=m-n;
	ans[1]=1;
	for(register int i = m ; i > n ; i--){//由n+1乘到m
		for(register int j = cnt ; j >= 1 ; --j){//每一位都乘上i
			ans[j] *= i;
			if(ans[j] >= 10000 ) ans[j+1] += (ans[j]/10000);//若大于10000 大于部分移动至下一个高精位
			ans[j] %= 10000;
		}
		if(ans[cnt+1] > 0) cnt++;//位数增加
	}
	for(register int i = 2 ; i <= m-n ; i++){//从2除到m-n
		for(register int j = cnt ; j >= 1 ; --j){//将每一位都除i
			if(ans[j] % i){
				long long k = ans[j]%i;
				ans[j] -= k;
				ans[j-1] += (k*10000);//将余数移动至下一个高精位
			}
			ans[j] /= i;
		}
		if(ans[cnt] == 0) cnt--;//位数减少
	}
	printf("%lld",ans[cnt]);//前一段单独输出（第一段不含0即不能为0004）
	for(int t = cnt-1 ; t >= 1 ; t--)
		printf("%04lld",ans[t]);//这里存的是4位
	return 0;
} 
~~~




---

## 作者：CrazyDance (赞：1)

## [~~传送门~~](https://www.luogu.org/problem/P1771)

## 草率审题

看到这种题目，读入两个数，输出一个数，显然是~~打表~~找规律！

但是，我们通过打表，没有发现什么规律。

于是我们可以想想数论方面的东西。

## 分析

我们先对着题目盯上个一分钟，肯定能发现什么蹊跷。

其实题目就是求$k$个正整数的和是$g(x)$的方案数嘛。

我们假设，现场有$g(x)$个苹果，你要分成$k$份……

这不就是一个典型的插板问题么？

所以我们这$g(x)$个苹果之间，就有了$g(x)-1$个空隙。

我们要把苹果分成$k$个部分，所以就要用上$k-1$个空隙。

所以……答案就是$\textrm{C}_{x^x \mod 1000-1}^{k-1}$

## 解法

我们再看看数据范围 $k \leq 100$

那么$k!$一定会炸掉，所以我们就要高精度！

然后组合数学公式又涉及到了除法，所以我们可以用高精除单精的方法。

当然，我们也是可以分解质因数的。

## 代码
```cpp
#include<cstdio>
#define inf 1000
#define ll long long
ll n,m,s[1000],t;
ll ksm(ll k,ll t)//快速幂，不解释 
{
	ll s=1;
	for (;t;)
	{
		if (t%2==1) s*=k,s%=inf;
		k*=k%inf,k%=inf,t/=2;
	}
	return s%inf;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	m%=inf,m=ksm(m,m)-1,n--;//数字的初始化 
	t=s[1]=1;//高精度初始化 
	for (int i=m;i>m-n;i--)//高精乘 
	{
		int x=0;//保存进位 
		for (int j=1;j<=t;j++) s[j]=i*s[j]+x,x=s[j]/10,s[j]%=10;//逐位相乘 
		for (;x;) s[++t]=x%10,x/=10;//进位 
	}
	for (int i=2;i<=n;i++)//高精除单精 
	{
		int x=0;//保存计算中的余数 
		for (int j=t;j;j--)//逐位相除 
		{
			int r=s[j]+x*10;
			s[j]=r/i;
			x=r%i;
		}
		for (;!s[t];t--);//把多余的位数删掉 
	}
	for (int i=t;i;i--) printf("%lld",s[i]);
	return 0;
}
```

---

## 作者：香风智乃 (赞：1)

（没有重载的话.....我来补一发吧）

按题意用快速幂把$g(x)$求出来

发现这不就是个组合数入门题吗！

$k$个人分$g(x)$个苹果，每人最少分$1$个，有几种方法？

根据插板法，显然答案为$C(g(x)-1,k-1)$

蓝后写个高精度。（我曾经十分天真地认为$ans<=10^{50}$）

这里用**压位+结构体重载**高精。可以应对$ans<=10^{24*7}$的数据。

结构体重载的好处是你可以先写个暴力，重载高精时几乎不用改动主程序。

update：存在$x,P,x^x\%P!=x\%P^{x\%P}\%P$

[juruo's blog](https://www.cnblogs.com/kafuuchino/p/9903446.html)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define re register
using namespace std;
int max(int a,int b){return a>b?a:b;}
const int W=10000000;//压7位
int x,k;
struct bigsum{
    int a[25],len;
    bigsum(){memset(a,0,sizeof(a));len=0;}
    bigsum operator + (const bigsum &tmp) const{
        bigsum c; int x=0;
        c.len=max(len,tmp.len);
        for(int i=1;i<=c.len;++i){
            c.a[i]=a[i]+tmp.a[i]+x;
            x=c.a[i]/W;c.a[i]%=W;
        }
        for(;x;x/=W) c.a[++c.len]=x%W;
        return c;
    }
    void print(){//注意压位高精输出时每一位的前导0
        printf("%d",a[len]);
        for(int i=len-1;i>=1;--i){
            for(int j=10;a[i]*j<W;j*=10) putchar(48);
            printf("%d",a[i]);
        }
    }
}C[1001][1001];
int Pow(int x,int y){
    int res=1;
    for(;y;y>>=1,x=1ll*x*x%1000)
        if(y&1) res=1ll*res*x%1000;
    return res;
}
int main(){
    scanf("%d%d",&k,&x); x=Pow(x%1000,x);
    if(!x){puts("0");return 0;} 
    for(int i=0;i<x;++i)
        for(int j=0;j<=i;++j){
            if(!j||j==i) C[i][j].a[C[i][j].len=1]=1;
            else C[i][j]=C[i-1][j]+C[i-1][j-1];
        }//杨辉三角递推
    C[x-1][k-1].print();
    return 0;
}
```

---

## 作者：localhost (赞：0)

$\sum_{i=1}^k a_i = x^x \mod 1000  (a_i \in \N^*)$

$\because$ 总和一定为$x^x \mod 1000$,并且分为$k$个数,

设$n = x^x \mod 1000$

这样相当于在$n-1$个空位中插$k-1$块隔板

$\therefore ans = C(n-1,k-1)$

$\because k \le 100,n\le 1000$

$\therefore$我们用杨辉三角(用滚动数组，否则可能re)就可以了，但是要高精度

当然如果直接计算组合数更快

杨辉三角版:

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define il __inline__ __attribute__ ((always_inline))
#define Fur(i,x,y) for(int i=x;i<=y;i++)
#define clr(x,y) memset(x,y,sizeof(x))
using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 1011
int k,t;
il int pw(int x,int p){
    int ans=1;
    while(p){
        if(p&1)ans=1ll*ans*x%1000;
        p>>=1;x=1ll*x*x%1000;
    }
    return ans;
}
#define M 1000
struct node{
    node(){clr(a,0);len=0;};
    unsigned short a[M],len;
    void operator = (int x){
        while(x){
            a[++len]=x%10;
            x/=10;
        }
        reverse(a+1,a+len+1);
    }
    il void op(){
        Fdr(i,len,1)out<<a[i];
        out<<ln;
    }
}c[2][101];
node operator + (node a,node b){
    node c;
    int len=MAX(a.len,b.len);
    Fur(i,1,len)
        c.a[i]=a.a[i]+b.a[i];
    Fur(i,1,len-1)
        if(c.a[i]>9)c.a[i+1]+=c.a[i]/10,c.a[i]%=10;
    while(c.a[len]>9){
        c.a[len+1]+=c.a[len]/10;
        c.a[len]%=10;
        ++len;
    }
    c.len=len;
    return c;
}
void work(int n,int m){
    c[0][0]=1;
    c[1][0]=1;
    Fur(i,1,n)
        Fur(j,1,m)
        c[i&1][j]=c[!(i&1)][j-1]+c[!(i&1)][j];
    c[n&1][m].op();
}
int main(){
    in>>k>>t;t%=1000;
    t=pw(t,t);
    work(t-1,k-1);
}
```

组合数版：

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define il __inline__ __attribute__ ((always_inline))
#define Fur(i,x,y) for(int i=x;i<=y;++i)
#define Fdr(i,x,y) for(int i=x;i>=y;--i)
#define clr(x,y) memset(x,y,sizeof(x))
using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 1011
int k,t;
il int pw(int x,int p){
    int ans=1;
    while(p){
        if(p&1)ans=1ll*ans*x%1000;
        p>>=1;x=1ll*x*x%1000;
    }
    return ans;
}
int len=1,c[1000];
void work(int n,int m){
    len=1;c[1]=1;
    Fur(t,1,m){
        Fur(i,1,len)c[i]*=(n-t+1);
        Fur(i,1,len-1)c[i+1]+=c[i]/10,c[i]%=10;
        while(c[len]>9)c[len+1]+=c[len]/10,c[len]%=10,++len;
        
        int y=0;
        Fdr(i,len,1){
            y=y*10+c[i];
            c[i]=y/t,y%=t;
        }
        while(!c[len]&&len>1)--len;
    }
    Fdr(i,len,1)out<<c[i];out<<ln;
}
int main(){
    in>>k>>t;t%=1000;
    t=pw(t,t);
    work(t-1,k-1);
}
```

---

## 作者：Frost_Delay (赞：0)

前缀知识 [快速幂](https://www.luogu.org/problem/P1226)，[高精度加法](https://www.luogu.org/problem/P1601)

看到这道题时，我蒙了一会儿，想打个暴力交上去却发现暴力也不好打；

于是，我开始了~~颓废~~手玩；

由于 $k<=g(x)$,

我开始了推算；

先不管 $x^x$%1000

就先推将X分成K个数有多少种方案；

![](https://cdn.luogu.com.cn/upload/pic/74489.png)


显然，这是一个杨辉三角，我们只需要做$k-1$次前缀和就能得到第$k$列的值；

注意，最后输出的是$f[x-k+1]$

由于这个X很大，写个快速幂会快很多；

于是就有了第一个代码
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
using namespace std;
inline long long read()
{
	long long x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
long long xx,k;
inline long long poww(long long x,long long i)
{
	long long ans=1;
	while(i)
	{
		if(i&1)ans=(ans*x)%1000;
		i>>=1;
		x=(x*x)%1000;
	}
	return ans%1000;
}
unsigned long long f[1001];
int main()
{
	k=read();xx=read();
	xx=poww(xx%1000,xx);
	for(int i=1;i<=xx;i++)f[i]=1;
	for(int i=1;i<k;i++)
	for(int j=1;j<=xx;j++)f[j]+=f[j-1];
	cout<<f[xx+1-k]<<endl;
	return 0;
}
```
但是，它会爆！

于是不得不写高精；

我们把$f[]$拓展一维，保存数值

AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
using namespace std;
inline long long read()//快读
{
	long long x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
long long xx,k;
inline long long poww(long long x,long long i)//快速幂
{
	long long ans=1;
	while(i)
	{
		if(i&1)ans=(ans*x)%1000;
		i>>=1;
		x=(x*x)%1000;
	}
	return ans%1000;
}
long long f[1010][1010];
inline void jia(int x,int y)
{
	for(int i=1;i<=max(f[x][0],f[y][0]);i++)
	f[x][i]+=f[y][i];
	for(int i=1;i<=max(f[x][0],f[y][0]);i++)
	{
		if(f[x][i]>=100000000)//压位高精更快一点
		{
			long long temp=f[x][i]/100000000;
			f[x][i]%=100000000;
			f[x][i+1]+=temp;
		}
	}
	if(f[x][f[x][0]+1])f[x][0]++;
}
int main()
{
	k=read();xx=read();
	xx=poww(xx%1000,xx);
	for(int i=1;i<=xx-k+1;i++)f[i][0]=f[i][1]=1;//初始化第一列
	for(int i=1;i<k;i++)
	{
		for(int j=1;j<=xx-k+1;j++)//前缀和
		jia(j,j-1);
	}
	int l=xx+1-k;
	printf("%lld",f[l][f[l][0]]);//压位高精的输出
	for(int i=f[l][0]-1;i>=1;i--)
	{
		printf("%lld",f[l][i]/10000000);
		printf("%lld",f[l][i]/1000000%10);
		printf("%lld",f[l][i]/100000%10);
		printf("%lld",f[l][i]/10000%10);
		printf("%lld",f[l][i]/1000%10);
		printf("%lld",f[l][i]/100%10);
		printf("%lld",f[l][i]/10%10);
		printf("%lld",f[l][i]%10);
	}
	return 0;
}
```

你以为这就完了吗，~~我也以为完了~~

经过我~~百度~~查找资料

杨辉三角第N行第M个数可以直接求！

第n行的m个数可表示为$C(n-1,m-1)$，即为从n-1个不同元素中取m-1个元素的组合数。
 
                                                -----百度百科

但我组合数学没学过，这个代码咕了。

---


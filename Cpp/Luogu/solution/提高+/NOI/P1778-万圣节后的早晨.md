# 万圣节后的早晨

## 题目描述

要求你写一个程序，在一个地图中，找到最小步数将每个鬼移动到他们指定的位置。地图包含一些小方格。每格要么是墙（鬼不能进入），要么是走廊（鬼能进入）。

每一步里，你可以同时移动任意数量的鬼。每个鬼要么待在原地不动，要么移动到相邻的格子里（相邻的格子有公共边），如果移动满足下列条件，则移动是可行的。

1. 没有一个以上的鬼在同一个格子里；
2. 没有一对鬼在一步里交换了位置。

例如，假设鬼的位置是如右上图所示的，其中sharp(#)表示墙，空格表示走廊，a,b,c表示鬼：

```plain
####
 ab#
#c##
####
```
经过一步移动后，地图可以变成如下的样子：

```plain
####     ####     ####       ####
 ab#     a b#     acb#       ab #
#c##     #c##     # ##       #c##   
####     ####     ####       ####
```

## 样例 #1

### 输入

```
5 5 2
#####
#A#B#
#   #
#b#a#
#####
16 4 3
################
## ########## ##
#    ABCcba    #
################
16 16 3
################
### ##    #   ##
##  #  ##   # c#
#  ## ########b#
# ##  # #   #  #
#  # ##   # # ##
##  a#  # # #  #
### ## #### ## #
##   #   #  #  #
#  ##### # ## ##
####   #B# #   #
##  C#   #   ###
#  # # ####### #
# ######  A##  #
#        #     #
################
0 0 0```

### 输出

```
7
36
77```

# 题解

## 作者：baiABC (赞：6)

题面可以看[这里](https://onlinejudge.org/external/16/p1601.pdf)
## 思路：
- 由题意可知我们不用判断迷宫的边界，因为外围都是障碍物。

- “Any 2 × 2 area on any map has at least one sharp.”就是说有许多格子都是障碍物，所以我们可以把所有的空格提出来建一张图，能大大节约时间。

- 建图时可以让额外的结点形成自环，让我们每次都有三个鬼，方便处理。

- 现在普通 BFS 已可以通过本题，但还可以继续优化，如用双向 BFS、A\* 等算法。

***
### 代码：
普通 BFS:
```cpp
#include <bits/stdc++.h>
using namespace std;
int G[150][5], deg[150], st[3], ed[3], d[150][150][150];
//deg: 每个结点的出度（最大为 5，四个方向和原地不动）
//d: 每个状态到起点状态的距离
int mm(int a, int b, int c) {return (a<<16) | (b<<8) | c;}// 二进制状态压缩
bool ct(int a, int b, int x, int y){return b == y || (a == y && b == x);}
// 返回 a -> b 的鬼和 x -> y 的鬼路线是否冲突
int bfs()
{
    memset(&d[0][0][0], -1, sizeof d);
    queue <int> q;
    q.push(mm(st[0], st[1], st[2]));
    d[st[0]][st[1]][st[2]] = 0;
    while(!q.empty())
    {
        int x = q.front(), a = x >> 16, b = (x >> 8) & 0xff, c = x & 0xff;
        q.pop();
        if(a == ed[0] && b == ed[1] && c == ed[2]) return d[a][b][c];
        for(int i = 0; i < deg[a]; ++i)
            for(int j = 0; j < deg[b]; ++j)
            {
                if(ct(a, G[a][i], b, G[b][j])) continue;
                for(int k = 0; k < deg[c]; ++k)
                {
                    if(ct(a, G[a][i], c, G[c][k]) || ct(b, G[b][j], c, G[c][k]) || d[G[a][i]][G[b][j]][G[c][k]] != -1) continue;
                    d[G[a][i]][G[b][j]][G[c][k]] = d[a][b][c]+1;
                    q.push(mm(G[a][i], G[b][j], G[c][k]));
                }
            }
    }
    return -1;
}
int main()
{
    int w, h, n;
    char s[20][20];
    while(scanf("%d%d%d", &w, &h, &n), w || h || n)
    {
        int cnt = 0, id[20][20]; // id: 空格在图中结点编号
        memset(deg, 0, sizeof deg);
        for(int i = 0; i < h; ++i)
        { // 处理好输入，顺便建图
            scanf(" ");
            for(int j = 0; j < w; ++j)
            {
                s[i][j] = getchar();
                if(s[i][j] != '#')
                {
                    id[i][j] = ++cnt;
                    G[cnt][deg[cnt]++] = cnt;
                    if(s[i-1][j] != '#'){G[cnt][deg[cnt]++] = id[i-1][j]; G[id[i-1][j]][deg[id[i-1][j]]++] = cnt;}
                    if(s[i][j-1] != '#'){G[cnt][deg[cnt]++] = id[i][j-1]; G[id[i][j-1]][deg[id[i][j-1]]++] = cnt;}
                    if(islower(s[i][j])) st[s[i][j]-'a'] = cnt;
                    else if(isupper(s[i][j])) ed[s[i][j]-'A'] = cnt;
                }
            }
        }
        /* 虚拟结点 */
        if(n <= 2) {deg[++cnt] = 1; G[cnt][0] = cnt; st[2] = ed[2] = cnt;}
        if(n == 1) {deg[++cnt] = 1; G[cnt][0] = cnt; st[1] = ed[1] = cnt;} 
        printf("%d\n", bfs());
    }
    return 0;
}
```
双向 BFS:
```cpp
#include <bits/stdc++.h>
using namespace std;
int G[150][5], deg[150], st[3], ed[3], d1[150][150][150], d2[150][150][150];
int mm(int a, int b, int c) {return (a<<16) | (b<<8) | c;}
bool ct(int a, int b, int x, int y){return b == y || (a == y && b == x);}
int bfs()
{
    memset(&d1[0][0][0], -1, sizeof d1);
    memset(&d2[0][0][0], -1, sizeof d2);
    queue <int> q1, q2;
    q1.push(mm(st[0], st[1], st[2]));
    d1[st[0]][st[1]][st[2]] = 0;
    q2.push(mm(ed[0], ed[1], ed[2]));
    int n1, n2, x1, x2;
    n2 = n1 = 1;
    x1 = x2 = 0;
    do {
        if(!n2 || x1 < x2)
        {
            int x = q1.front(), a = x >> 16, b = (x >> 8) & 0xff, c = x & 0xff;
            q1.pop(); --n1;
            if(d2[a][b][c] != -1) return d1[a][b][c] + d2[a][b][c];
            if(d1[a][b][c] > x1){++x1; q1.push(x); ++n1; continue;}
            for(int i = 0; i < deg[a]; ++i)
                for(int j = 0; j < deg[b]; ++j)
                {
                    if(ct(a, G[a][i], b, G[b][j])) continue;
                    for(int k = 0; k < deg[c]; ++k)
                    {
                        if(ct(a, G[a][i], c, G[c][k]) || ct(b, G[b][j], c, G[c][k]) || d1[G[a][i]][G[b][j]][G[c][k]] != -1) continue;
                        d1[G[a][i]][G[b][j]][G[c][k]] = d1[a][b][c]+1;
                        q1.push(mm(G[a][i], G[b][j], G[c][k]));
                        ++n1;
                    }
                }
        }
        else
        {
            int x = q2.front(), a = x >> 16, b = (x >> 8) & 0xff, c = x & 0xff;
            q2.pop(); --n2;
            if(d1[a][b][c] != -1) return d1[a][b][c] + d2[a][b][c];
            if(d2[a][b][c] > x2){++x2; q2.push(x); ++n2; continue;}
            for(int i = 0; i < deg[a]; ++i)
                for(int j = 0; j < deg[b]; ++j)
                {
                    if(ct(a, G[a][i], b, G[b][j])) continue;
                    for(int k = 0; k < deg[c]; ++k)
                    {
                        if(ct(a, G[a][i], c, G[c][k]) || ct(b, G[b][j], c, G[c][k]) || d2[G[a][i]][G[b][j]][G[c][k]] != -1) continue;
                        d2[G[a][i]][G[b][j]][G[c][k]] = d2[a][b][c]+1;
                        q2.push(mm(G[a][i], G[b][j], G[c][k]));
                        ++n2;
                    }
                }
        }
    } while(n1 || n2);
    return -1;
}
int main()
{
    int w, h, n;
    char s[20][20];
    while(scanf("%d%d%d", &w, &h, &n), w || h || n)
    {
        int cnt = 0, id[20][20];
        memset(deg, 0, sizeof deg);
        for(int i = 0; i < h; ++i)
        {
            scanf(" ");
            for(int j = 0; j < w; ++j)
            {
                s[i][j] = getchar();
                if(s[i][j] != '#')
                {
                    id[i][j] = ++cnt;
                    G[cnt][deg[cnt]++] = cnt;
                    if(s[i-1][j] != '#'){G[cnt][deg[cnt]++] = id[i-1][j]; G[id[i-1][j]][deg[id[i-1][j]]++] = cnt;}
                    if(s[i][j-1] != '#'){G[cnt][deg[cnt]++] = id[i][j-1]; G[id[i][j-1]][deg[id[i][j-1]]++] = cnt;}
                    if(islower(s[i][j])) st[s[i][j]-'a'] = cnt;
                    else if(isupper(s[i][j])) ed[s[i][j]-'A'] = cnt;
                }
            }
        }
        if(n <= 2) {deg[++cnt] = 1; G[cnt][0] = cnt; st[2] = ed[2] = cnt;}
        if(n == 1) {deg[++cnt] = 1; G[cnt][0] = cnt; st[1] = ed[1] = cnt;}
        printf("%d\n", bfs());
    }
    return 0;
}
```
---
双倍经验：[UVA1601](https://www.luogu.com.cn/problem/UVA1601)。

---

## 作者：ANJHZ (赞：3)

本题可以抽象成一个图论问题。
我们假设地图上有3个鬼，那么三个鬼分别所在的行数nowx1,nowx2,nowx3以及分别所在的列数 nowy1,nowy2,nowy3这六个值可以作为隐式图上的节点存储。
题中已给出初始的状态，那么我们从初始状态对应的节点出发，寻找到达最终状态（三个鬼都到达最终位置）所对应的节点的最短路径。
注意到节点之间的边权相同（都是一步），使用宽度优先搜索寻找路径。

需注意的几个细节：
1.恶心的带空格读入
2.多组数据
3.bfs队列空间需求较大，考虑使用循环队列


贴代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#include <map>
using namespace std;
int num;
int n,m;
int stx[4],sty[4],edx[4],edy[4];
int a[21][21];
short vis[17][17][17][17][17][17];
struct qu
{
    int sx1,sx2,sx3,sy1,sy2,sy3;
    int step;
} q[1000001];
int head,tail;
int dx[5]= {1,-1,0,0,0};
int dy[5]= {0,0,1,-1,0};
char tmp;
int max(int p,int q){return p>q?p:q;}
int min(int p,int q){return p<q?p:q;}
int check(int nowx1,int nowy1,int nowx2,int nowy2,int nowx3,int nowy3)
{
    if(nowx1==edx[1]&&nowy1==edy[1]&&nowx2==edx[2]&&nowy2==edy[2]&&nowx3==edx[3]&&nowy3==edy[3]) return 1;
    return 0;
}
int ans;
void bfs()
{
    memset(vis,0,sizeof vis);
    int i,j,k;
    int nex1,ney1,nex2,ney2,nex3,ney3;
    int nowx1,nowx2,nowx3,nowy1,nowy2,nowy3;
    head=tail=0;
    q[++tail].sx1=stx[1];q[tail].sx2=stx[2];q[tail].sx3=stx[3];
    q[tail].sy1=sty[1];q[tail].sy2=sty[2];q[tail].sy3=sty[3];
    vis[stx[1]][sty[1]][stx[2]][sty[2]][stx[3]][sty[3]]=1;
    q[tail].step=0;
    while(head!=tail)
    {
        head++;
        head%=1000000;
        nowx1=q[head].sx1;nowx2=q[head].sx2;nowx3=q[head].sx3;
        nowy1=q[head].sy1;nowy2=q[head].sy2;nowy3=q[head].sy3;
        //if(head>900000) cout<<head<<endl;
        if(check(nowx1,nowy1,nowx2,nowy2,nowx3,nowy3))
        {
            ans=q[head].step;
            return;
        }
        for(i=0; i<=4; i++)
        {
            nex1=nowx1+dx[i];
            ney1=nowy1+dy[i];
            if(nex1<0||nex1>n||ney1<1||ney1>m) continue;
            if(a[nex1][ney1]) continue;
            for(j=0; j<=4; j++)
            {
                nex2=nowx2+dx[j];
                ney2=nowy2+dy[j];
                if(nex2<0||nex2>n||ney2<1||ney2>m) continue;
                if(a[nex2][ney2]) continue;
                if(nex1==nowx2&&ney1==nowy2&&nex2==nowx1&&ney2==nowy1) continue;
                if(nex1==nex2&&ney1==ney2) continue;
                for(k=0; k<=4; k++)
                {
                    nex3=nowx3+dx[k];
                    ney3=nowy3+dy[k];
                    if(nex3<0||nex3>n||ney3<1||ney3>m) continue;
                    if(a[nex3][ney3]) continue;
                    if(nex1==nowx3&&ney1==nowy3&&nex3==nowx1&&ney3==nowy1) continue;
                    if(nex2==nowx3&&ney2==nowy3&&nex3==nowx2&&ney3==nowy2) continue;
                    if(nex1==nex2&&ney1==ney2||nex1==nex3&&ney1==ney3||nex2==nex3&&ney2==ney3) continue;
                    if(vis[nex1][ney1][nex2][ney2][nex3][ney3]) continue;
                    vis[nex1][ney1][nex2][ney2][nex3][ney3]=1;
                    tail=(tail+1)%1000000;
                    q[tail].sx1=nex1;q[tail].sx2=nex2;q[tail].sx3=nex3;
                    q[tail].sy1=ney1;q[tail].sy2=ney2;q[tail].sy3=ney3;
                    q[tail].step=q[head].step+1;
                    if(check(nex1,ney1,nex2,ney2,nex3,ney3))
                    {
                        ans=q[tail].step;
                        return;
                    }
                }
            }
        }
    }

}
int main()
{
    int i,j;
    while(scanf("%d%d%d",&m,&n,&num)!=EOF)
    {
        if(n+m+num==0) break;
        ans=1e9;
        memset(stx,0,sizeof stx);
        memset(edx,0,sizeof edx);
        memset(a,0,sizeof a);
        sty[1]=edy[1]=1;
        sty[2]=edy[2]=2;
        sty[3]=edy[3]=3;
        for(i=1; i<=n; i++)
        {
            for(j=1; j<=m; j++)
            {
                tmp=getchar();
                while(tmp=='\r'||tmp=='\n') tmp=getchar();
                if(tmp=='#')a[i][j]=1;
                else a[i][j]=0;
                if(tmp=='a') stx[1]=i,sty[1]=j;
                if(tmp=='b') stx[2]=i,sty[2]=j;
                if(tmp=='c') stx[3]=i,sty[3]=j;
                if(tmp=='A') edx[1]=i,edy[1]=j;
                if(tmp=='B') edx[2]=i,edy[2]=j;
                if(tmp=='C') edx[3]=i,edy[3]=j;
            }
        }
        bfs();
        printf("%d\n",ans);
    }
    return 0;
}

```


---

## 作者：Aurelia_Veil (赞：1)

# 题解：P1778 万圣节后的早晨

怎么说呢，思路一分钟，代码半小时，调题五小时。

这道题很容易想到搜索，相信你多半想到的都是双向 BFS，因为符合可逆性，也确定起点和终点。

然后，发现直接超时，为什么，因为缺少优化，我的优化如下。

## 一、路径枚举优化（时间优化）

注意到题目说在每一个 $2 \times 2$ 的矩阵内都会有一个墙，因此每一条路径宽度只会为 $1$，因此，用图来存储会非常方便，减少在搜索时的遍历，但怎么让鬼停止在这里？可以让每一个点**自环**。

## 二、路径存储优化（时间常数优化、空间优化）

既然每一个路径都是空格处，我们就可以给空格重新编号，减少存储空间大小。

## 三、“补充鬼” 优化（代码复杂度优化、时间常数优化）

既然可能不足 $3$ 个，我们可以将不足的几个鬼补充进来，将他们的起点变为自己定义的自环的点（虚拟的点），让他们能够参与循环，也不改变答案，就可以减少一点时间和代码复杂度。

## 四、其他优化

- 不要使用 `map` 存储，会将时间复杂度乘 $O(\log n)$。
- 能用 `short` 用 `short`，减小常数（~~俗称卡常~~）。
- 请使用较快的输入方式。

---

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=21;
const int M=7e6+111;
bool a[N][N];
int t[N][N];
int unt[N+10];
int n,m,k;
short f[M];
short ans[M];
int fx[]={1,-1,0,0};
int fy[]={0,0,1,-1};
struct pai{
    int now[5];
};
map<int,vector<int> >g;
int tik(pai x){
    int tpi=1;
    int sum=0;
    for(int i=1;i<=k;i++){
        sum+=tpi*x.now[i];
        tpi*=192;
    }
    return sum;
}
int bfs(pai begi,pai en){
    fill(f,f+M,0);
    fill(ans,ans+M,0);
    queue<pair<pai,short> >q;
    q.push(make_pair(begi,1));
    f[tik(begi)]=1;
    ans[tik(begi)]=0;
    q.push(make_pair(en,2));
    f[tik(en)]=2;
    ans[tik(en)]=0;
    while(!q.empty()){
        pai u=q.front().first;
        int col=q.front().second;
         // cerr<<u.now[1]<<" "<<u.now[2]<<" "<<u.now[3]<<" "<<col<<"\n";
        // cerr<<ans[tik(u)]<<" "<<col<<"\n";
        q.pop();
        pai v=u;
        int ux1=u.now[1];
        int ux2=u.now[2];
        int ux3=u.now[3];
        int len1=g[ux1].size();
        int len2=g[ux2].size();
        int len3=g[ux3].size();
        for(int i=0;i<len1;i++){
            v.now[1]=g[ux1][i];
            for(int j=0;j<len2;j++){
                v.now[2]=g[ux2][j];
                if(v.now[1]==v.now[2]&&k>=2){
                	continue;
				}
                if(u.now[1]==v.now[2]&&u.now[2]==v.now[1]&&k>=2){
                	continue;
				}
                for(int h=0;h<len3;h++){
                    v.now[3]=g[ux3][h];
                    if((v.now[1]==v.now[3]||v.now[2]==v.now[3])&&k==3){
                        continue;
                    }
                    if(((u.now[1]==v.now[3]&&u.now[3]==v.now[1])||(u.now[3]==v.now[2]&&u.now[2]==v.now[3]))&&k==3){
                        continue;
                    }
                    if(f[tik(v)]==col){
                        continue;
                    }
                    if(f[tik(v)]==3-col){
                        return ans[tik(u)]+ans[tik(v)]+1;
                    }
                    ans[tik(v)]=ans[tik(u)]+1;
                    f[tik(v)]=col;
                    q.push(make_pair(v,col));
                }
            }
        }
    }
    return 0;
}
int main(){
    while(1){
        fill(unt,unt+N+10,0);
        pai begi,en;
        scanf("%d%d%d",&m,&n,&k);
        if(n==0&&m==0&&k==0){
            break;
        }
        char input;
        int ctt=0,ctn=0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                while(1){
                    scanf("%c",&input);
                    if(input!='\n'&&input!='\r'){
                        break;
                    }
                }
                if(input=='#'){
                    a[i][j]=1;
                }else{
                	ctt++;
                	t[i][j]=ctt;
                    a[i][j]=0;
                }
                if(input>='a'&&input<='z'){
                	if(unt[int(input-'a')]==0){
                		ctn++;
                		unt[int(input-'a')]=ctn;
					}
                    begi.now[unt[int(input-'a')]]=t[i][j];
                    a[i][j]=0;
                }
                if(input>='A'&&input<='Z'){
                	if(unt[int(input-'A')]==0){
                		ctn++;
                		unt[int(input-'A')]=ctn;
					}
                    en.now[unt[int(input-'A')]]=t[i][j];
                    a[i][j]=0;
                }
            }
        }
        if(k<2){
            begi.now[2]=0;
		}
        if(k<3){
        	begi.now[3]=0;
			g[0].push_back(0);
		}
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                g[t[i][j]].push_back(t[i][j]);
                if(a[i][j]==1){
                    continue;
                }
                for(int h=0;h<4;h++){
                    int vx=i+fx[h];
                    int vy=j+fy[h];
                    if(vx<=0||vx>n||vy<=0||vy>m){
                        continue;
                    }
                    if(a[vx][vy]==1){
                        continue;
                    }
                    g[t[i][j]].push_back(t[vx][vy]);
                }
            }
        }
		printf("%d\n",bfs(begi,en));
		g[0].clear();
        for(int i=1;i<=n;i++){
        	for(int j=1;j<=m;j++){
        		if(a[i][j]==1){
        			continue;
				}
        		g[t[i][j]].clear();
			}
		}
    }
    return 0;
}
```

---

## 作者：Kobe_Bryant824 (赞：1)

## 思路及部分代码
**1.先读图；**
```cpp
while (cin >> w >> h >> n && n)
{
    char c = getchar();
    while (c != '\n')
        c = getchar();
    for (int i = 1; i <= h; i++)
        fgets(M[i] + 1, 20, stdin);
    cnt = 0;
```


**2.找到鬼的位置并且存储（这里详见代码，用了特殊方法存储）；**
```cpp
int x[MAXM + 10], y[MAXM + 10];
    for (int i = 1; i <= h; i++)
    for (int j = 1; j <= w; j++)
    if (M[i][j] != '#')
    {
        id[i][j] = ++cnt;
        x[cnt] = i;
        y[cnt] = j;
        if ('a' <= M[i][j] && M[i][j] <= 'c')
            st[M[i][j] - 'a'] = cnt;
        if ('A' <= M[i][j] && M[i][j] <= 'C')
            ed[M[i][j] - 'A'] = cnt;
    }
    for (int i = 1; i <= cnt; i++)
    {
        edge[i] = 0;
        for (int j = 0; j < 5; j++)
        {
            int xx = x[i] + cx[j];
            int yy = y[i] + cy[j];
            if (M[xx][yy] != '#')
                G[i][++edge[i]] = id[xx][yy];
        }
    }

```


**3.找出出鬼的最短到达终点的路（这里用 bfs ）；**
```cpp
void bfs()
{
 queue <int> q;
  memset(d, -1, sizeof(d));
 q.push(getnum(st[0], st[1], st[2]));
	d[st[0]][st[1]][st[2]] = 0;
	while (!q.empty())
{
    int u = q.front(); q.pop();
    int a = (u >> 16) & 255, b = (u >> 8) & 255, c = u & 255;
    if (a == ed[0] && b == ed[1] && c == ed[2])
        return;
    for (int i = 1; i <= edge[a]; i++)
    {
        int a1 = G[a][i];
        for (int j = 1; j <= edge[b]; j++)
        {
            int b1 = G[b][j];
            if (ok(a, b, a1, b1))
                continue;
            for (int k = 1; k <= edge[c]; k++)
            {
                int c1 = G[c][k];
                if (ok(a, c, a1, c1))
                continue;
                if (ok(b, c, b1, c1))
                continue;
                if (d[a1][b1][c1] == -1)
                {
                    d[a1][b1][c1] = d[a][b][c] + 1;
                    q.push(getnum(a1, b1, c1));
                }
            }
        }
    }
}
}
```


**4.处理如果只有 1 个或 2 个鬼的情况；**
```cpp
if (n <= 2)
    {
        edge[++cnt] = 1;
        G[cnt][1] = cnt;
        st[2] = ed[2] = cnt;
    }
    if (n <= 1)
    {
        edge[++cnt] = 1;
        G[cnt][1] = cnt;
        st[1] = ed[1] = cnt;
    }
```


**5.计算并输出。**
```cpp
bfs();
cout << d[ed[0]][ed[1]][ed[2]] << endl ;
```


---

## 作者：Xu_brezza (赞：1)

## 题意：

给你 $n$ 个小鬼，不超过 $3$ 个还有一个 $h \times w$ 的地图，给定起点终点以及不能走的点，每一步可以移动任意个小鬼，但不能重合，求最少步数。

## 分析：
更好的 [题面](https://onlinejudge.org/external/16/p1601.pdf) 阅读体验

这题我们可以使用 BFS ，但是会超时，所以我们考虑使用双端 BFS 因为题中给出了明确起止位置，我们可以用两端一起扩展的方式来达到大大减小搜索树的目的，当出现重合的情况时就是我们要求的答案。对于本题还可以有一个优化，因为题中给出了每一个 $2\times 2 $ 的范围内至少有一个障碍，所以我们可以考虑将可以走的部分连成图，大大减少不必要的扩展，别忘了可以不动，所以要添加自环。小鬼可能不足三个，所以不足的要补上， BFS 的过程中不动他即可。

详见代码吧。

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
#include<vector>
#include<string>
using namespace std;
int w,h,n;
char s[25][25];
const int N = 155;
int dis[N][N][N],vis[N][N][N],id[N][N];//距离 是否访问 点的编号 
const int dx[] = {0,1,0,-1,0};//添加了自环 
const int dy[] = {1,0,-1,0,0};
int cnt,st[5],ed[5];
vector<int>e[155];
inline void init(){
	cnt = 0;
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
}
inline int check(int a,int b,int x,int y){
	return (b == y) || (a == y && b == x);//两个小鬼目标结点相同或者是 一个是（i,j) 一个是(j,i) 也就是说他们的目标点是对方的起点，这也是不行的 
}
struct qwq{//这是到时候bfs用的，存储三个小鬼的位置 
	int a,b,c;
	qwq(int x,int y,int z) : a(x),b(y),c(z) {} 
};
struct point{//存图的点 
	int x,y;
	//point(int a,int b) : x(a),y(b) {}	
}node[N];
inline void read(){
	char ch = getchar();
	while(ch != '\n')ch = getchar();
	for(register int i=1;i<=h;++i){
		fgets(s[i]+1,20,stdin);//阴间读入。。。
		for(register int j=1;j<=w;++j){
			if(s[i][j] != '#'){
				id[i][j] = ++cnt;
				node[cnt] = (point){i,j};//该点可走，存进来 
				if(s[i][j] >= 'a' && s[i][j] <= 'z')
					st[s[i][j] - 'a'] = id[i][j];//起点 
				else if(s[i][j] >= 'A' && s[i][j] <= 'Z')
					ed[s[i][j] - 'A'] = id[i][j];//终点 
			}
		}
		
	}
}
inline void build(){
	for(register int i=1;i<=cnt;++i){
		e[i].clear();
		for(int j=0;j<5;++j)
			if(s[node[i].x + dx[j]][node[i].y + dy[j]] != '#')
				e[i].push_back(id[node[i].x + dx[j]][node[i].y + dy[j]]);//连接出边 
	}
	if(n <= 2){
		++cnt;
		e[cnt].push_back(cnt);
		st[2] = ed[2] = cnt;	
	}//这两个特判是特判小鬼不够3个 不够就补上，因为他没有边，所以不用担心什么 
	if(n <= 1){
		++cnt;
		e[cnt].push_back(cnt);
		st[1] = ed[1] = cnt;	
	}
}
inline int bfs(){
	queue<qwq>q[2];
	dis[st[0]][st[1]][st[2]] = 0;
	dis[ed[0]][ed[1]][ed[2]] = 0;
	vis[st[0]][st[1]][st[2]] = 1;//1代表正向搜索的访问标记 
	vis[ed[0]][ed[1]][ed[2]] = 2;//2代表反向搜索的访问标记 
	q[0].push(qwq(st[0],st[1],st[2]));//q[0]是正向搜 
	q[1].push(qwq(ed[0],ed[1],ed[2]));//q[1]是反向搜 从终点开始 
	while(!q[0].empty() || !q[1].empty()){
		int l[2],pos;
		l[0] = q[0].size(),l[1] = q[1].size();//每次取出当前的这一"层"且取完。 
		for(pos = 0;pos < 2;++pos)//正反都来 
			while(l[pos]--){//这一层 
				qwq now = q[pos].front();	
				q[pos].pop();
				int a = now.a,b = now.b,c = now.c;
				for(int a1 : e[a])//三个小鬼从当前位置可以走到的结点 
					for(int b1 : e[b]){
						if(check(a,a1,b,b1))continue;//矛盾 
						for(int c1 : e[c]){
							if(check(a,a1,c,c1) || check(b,b1,c,c1))continue;//矛盾 
							if(!vis[a1][b1][c1]){//没访问过 
								dis[a1][b1][c1] = dis[a][b][c] + 1;
								vis[a1][b1][c1] = pos + 1;
								q[pos].push(qwq(a1,b1,c1));	
							}
							else if(vis[a1][b1][c1] == 2 - pos)//有另一个非零标记出现过，证明搜索树相交，结束bfs 
								return dis[a][b][c] + 1 + dis[a1][b1][c1];//步数就是正向的步数加上反向的，由于肯定有一个还没加一，所以加上 
						}
					}
			}
	}
}
int main(){
	while(scanf("%d%d%d",&w,&h,&n) && (w || h || n)){
		read();
		build();//建图 
		printf("%d\n",bfs());
		init();//初始化 
	}
}
```


---

## 作者：__Accepted_ZYF__ (赞：0)

首先我们看原题面文件，有重要的东西。

![](https://cdn.luogu.com.cn/upload/image_hosting/kosn8hha.png)

这句话的意思是：在一个 $2\times 2$ 的格子中，至少有一个是障碍物。

那么我们的棋盘空格数就从预期的 $wh$ 降到了 $\frac{wh}{4}$，这样我们动态开点的访问记录数组就从 $w^3h^3$ 降到了 $\frac{w^3h^3}{64}$，不会爆空间。

这里提几个细节：

1. 换行符可能是 `\n` 或 `\r` 所以读入时要判定，直到读入一个不为 `\n` 或 `\r` 的字符再存储。
2. 鬼可以不动。
3. 注意读题：两鬼不能交换。但是两个不存在的鬼可以相同位置也可以交换！
4. 空间不要用太多。

其他没什么细节了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25,M=155;
int h,w,n,dot,sa,sb,sc,ea,eb,ec;
int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
char a[N][N];
int idm[N][N];
bool vis[M][M][M];
vector<int>e[N*N];
queue<array<int,4>>q;
int main(){
	while(cin>>w>>h>>n){
		if(w==0&&h==0&&n==0)break;
		memset(vis,0,sizeof(vis));
		dot=sa=sb=sc=ea=eb=ec=0;
		e[0].push_back(0);
		for(int i=1;i<=h;i++){
			for(int j=1;j<=w;j++){
				a[i][j]=getchar();
				while(a[i][j]=='\r'||a[i][j]=='\n')a[i][j]=getchar(); // 读入处理
				if(a[i][j]!='#'){
					idm[i][j]=++dot; // 动态开点
					e[dot].clear();
					e[dot].push_back(dot); // 鬼可以不动
					if(a[i][j]=='a')sa=dot;
					if(a[i][j]=='A')ea=dot;
					if(a[i][j]=='b')sb=dot;
					if(a[i][j]=='B')eb=dot;
					if(a[i][j]=='c')sc=dot;
					if(a[i][j]=='C')ec=dot;
				}else idm[i][j]=0; // 注意清空方式
			}
		}
		for(int i=1;i<=h;i++)
			for(int j=1;j<=w;j++)if(a[i][j]!='#')
				for(int d=0;d<4;d++){
					int nx=i+dx[d],ny=j+dy[d];
					if(nx<1||ny<1||nx>h||ny>w||!idm[nx][ny])continue;
					e[idm[i][j]].push_back(idm[nx][ny]); // 建图
				}
		while(q.size())q.pop();
		q.push({sa,sb,sc,0});
		vis[sa][sb][sc]=1;
		while(q.size()){
			auto f=q.front();
			q.pop();
			if(f[0]==ea&&f[1]==eb&&f[2]==ec){
				cout<<f[3]<<"\n";
				break;
			}
			for(auto v0:e[f[0]])for(auto v1:e[f[1]])for(auto v2:e[f[2]]){
				if(v0&&v1&&((v0==f[1]&&v1==f[0])||(v0==v1)))continue;
				if(v0&&v2&&((v0==f[2]&&v2==f[0])||(v0==v2)))continue;
				if(v1&&v2&&((v1==f[2]&&v2==f[1])||(v1==v2)))continue;
				if(vis[v0][v1][v2])continue;
				vis[v0][v1][v2]=1;
				q.push({v0,v1,v2,f[3]+1});
			}
		}
	}
	return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：0)

感觉这是一道偏模拟的题。

我们考虑广搜，每次我们移动鬼，我们可以假定有三个鬼，这样更好操作。然后判断是否满足要求，要求是没有点交换位置，且没移动到墙。最后判断一下是否是目标状态就行了。

这就是简短的思路题解，细节与各种套路可以让大家自己积累，这样应该帮助更大。


```cpp
#include <bits/stdc++.h>
using namespace std;
char c[311][311];
int fx[6]={0,1,-1,0,0,0},fy[6]={0,0,0,1,-1,0},mi[6];
struct node{
	int a[2],b[2],c[2];
	int Num;
}Fir;
bool T[18000005];
inline int get_hash(node aa){
	return aa.a[0]*mi[5]+aa.a[1]*mi[4]+aa.b[0]*mi[3]+aa.b[1]*mi[2]+aa.c[0]*mi[1]+aa.c[1]*mi[0];
}
queue<node> q;
int n,m;
bool check(node aa){
	if((aa.a[0]<=0||c[aa.a[0]][aa.a[1]]=='A') && (aa.b[0]<=0||c[aa.b[0]][aa.b[1]]=='B') && (aa.c[0]==30||c[aa.c[0]][aa.c[1]]=='C')){
		return 1;
	}
	return 0;
}
void BFS(){
	Fir.a[0]=0;
	Fir.a[1]=0;
	Fir.b[0]=0;
	Fir.b[1]=0;
	Fir.c[0]=30;
	Fir.c[1]=30;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(c[i][j]=='a'){
				Fir.a[0]=i;
				Fir.a[1]=j;
			}
			if(c[i][j]=='b'){
				Fir.b[0]=i;
				Fir.b[1]=j;
			} 
			if(c[i][j]=='c'){
				Fir.c[0]=i;
				Fir.c[1]=j;
			}
		}
	}
	while(!q.empty()){
		q.pop();
	}
	Fir.Num=0;
	q.push(Fir);
	while(!q.empty()){
		node Now=q.front();
		q.pop();
//		cout<<get_hash(Now)<<"\n";
		if(T[get_hash(Now)]){
			continue;
		}
//	cout<<"SS";
//		cout<<Now.a[0]<<' '<<Now.a[1]<<' '<<Now.b[0]<<' '<<Now.b[1]<<' '<<Now.c[0]<<' '<<Now.c[1]<<endl;
		T[get_hash(Now)]=1;
		if(check(Now)){
			cout<<Now.Num<<"\n";
			return;
		}
		for(int i=1;i<=5;i++){
			if(Now.a[0]==0 && i!=5){
				continue;
			}
			int A[2]={Now.a[0]+fx[i],Now.a[1]+fy[i]};
			if(c[A[0]][A[1]]=='#'){
				continue;
			}
			for(int j=1;j<=5;j++){
				if(Now.b[0]==0 && j!=5){
					continue;
				}
				int B[2]={Now.b[0]+fx[j],Now.b[1]+fy[j]};
				if(c[B[0]][B[1]]=='#'){
					continue;
				}
				for(int k=1;k<=5;k++){
					int C[2]={Now.c[0]+fx[k],Now.c[1]+fy[k]};
					if(Now.c[0]==30 && k!=5){
						continue;
					}
					if(c[C[0]][C[1]]=='#'){
						continue;
					}
//					cout<<A[0]<<' '<<A[1]<<' '<<B[0]<<' '<<B[1]<<' '<<C[0]<<' '<<C[1]<<"\n";
					if((A[0]==B[0] && A[1]==B[1]) || (A[0]==C[0] && A[1]==C[1]) || (B[0]==C[0] && B[1]==C[1])){
						continue;
					}
					if((A[0]==Now.b[0] && A[1]==Now.b[1] && B[0]==Now.a[0] && B[1]==Now.a[1])){
						continue;
					}
					if((A[0]==Now.c[0] && A[1]==Now.c[1] && C[0]==Now.a[0] && C[1]==Now.a[1])){
						continue;
					}
					if((B[0]==Now.c[0] && B[1]==Now.c[1] && C[0]==Now.b[0] && C[1]==Now.b[1])){
						continue;
					}
					node Nxt;
					Nxt.a[0]=A[0];
					Nxt.a[1]=A[1];
					Nxt.b[0]=B[0];
					Nxt.c[0]=C[0];
					Nxt.b[1]=B[1];
					Nxt.c[1]=C[1];
					Nxt.Num=Now.Num+1;
					if(T[get_hash(Nxt)]){
						continue;
					}
					q.push(Nxt);
				}
			}
		}
	}
}
int main(){
	mi[0]=1;
	for(int i=1;i<=5;i++){
		mi[i]=mi[i-1]*16;
	}
	int ghost;
	while(cin>>m>>n>>ghost){
		if(m==0 && n==0 && ghost==0){
			break;
		}
		memset(T,0,sizeof(T));
			string sa;
			getline(cin,sa);
		for(int i=1;i<=n;i++){
			string s;
			getline(cin,s);
			s=" "+s;
			for(int j=1;j<=m;j++){
				c[i][j]=s[j];
//				cout<<i<<' '<<j<<" "<<s[j]<<endl;;
			}
		}
//		cout<<"SB";
		BFS();
	}
	return 0;
}
```

---


# 电影投票

## 题目描述

有一个投票系统可以给电影评分，规定每票都必须投 $1$ 到 $10$ 的整数。现在希望投尽量少的票让一个电影的平均分数低于某个值。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1\le N \le 100$，$1\le T \le 100$；
- 对于 $100\%$ 的数据，$1\le T \le 10^4$，$X,Y\in[1,10]$，$1\le N \le 10^6$。

### 注意事项

保留一位小数采取四舍五入保留法。实数可能会有精度误差。

## 样例 #1

### 输入

```
9.5 2.0 12 
4.4 3.4 12478   
10 3.4 23577```

### 输出

```
86   
5094   
63033```

# 题解

## 作者：Math_rad_round (赞：14)

原题  _[P1818](https://www.luogu.com.cn/problem/P1818)_ 

简要翻译

N个可取1-10的整数的平均数四舍五入保留一位小数是A，现在要你再放上x个整数使平均数四舍五入保留一位小数降至B，给你X,Y,N，求x最小值

这道题既然范围很大(n>1000000,T>10000)，很明显就不能硬模拟，要数学推导

我们既然要将平均数降至Y，那么肯定只有全放1才可以更好地降低平均数 ~~否则把高的改成1肯定平均更小~~

首先先忽略精度问题，列出算式，设仍要投x张票可以达到目的的话

原先数的总和就是AN,而新的数总和为x，最后就一共有N+x个数。这些数平均数要小于等于B，那么算式就是

$$\frac{AN+x}{N+x} \leq B$$

两边乘N+x，因为都是正数，所以不用变号

$$AN+x\leq BN+Bx$$

移项合并，得

$$(1-B)x\leq BN-AN$$

所以两边除1-B，得到以下式子（因为1-B恒负，所以变号）

$$x\geq\frac{BN-AN}{1-B}$$

因为x为整数，所以ceil向上取整即可


------------

现在讨论精度问题，最坏情况下，真实的平均数是A+0.0499999......（这样初始分数最大）最后目标是B+0.049999999......（同理，因为四舍五入，这样就可以达到平均数）

所以上式中的A要用输入值加上0.0499999......，B也同理

这就是为什么1-B恒负而不会出现0的原因（本来就B≥1,加上0.0499999......后必定>1）

但是这题有坑，因为N个数中每个数都是整数，所以AN也是整数，必须先取整

另外，0.49999999......中9的数目多了会当成0.05，少了不准，在这可以用12个9

此外，A和B因为不可能超过10，所以都要对10取min

再之后，A可能小于等于B,这时要回答0

------------

求解原式的过程是O(1)，所以T组数据复杂度是O(T)比二分更快

上AC代码

```cpp
#include<iostream>
#include<cmath>
#define LL long long 
#define LD long double 
using namespace std;

int main(){
	LD a,b;
	LL n;
	while(cin>>a>>b>>n){
		if(a<=b){
			cout<<"0"<<endl;
			continue;
		}
		a=a+(LD)0.04999999999999;
		a=min((LD)10.0,a);
		b=b+(LD)0.04999999999999;
		b=min((LD)10.0,b);
		
		LL f=a*n;
		LD d=((LD)(b*n-f)/((LD)1-b));
		
		cout<<(LL)ceil(d)<<endl;
	}
   return 0;
} 

```


~~数学推导就是好~~





---

## 作者：luyifan091120 (赞：4)

数学题。

题目地址：[P1818](https://www.luogu.com.cn/problem/P1818)。

## 题目简述：

现在有一个人 XP 想拉低一场电影的平均分，请问他最少要投几票。

即：现在有 $N$ 个数的平均数**保留一位小数**为 $X$，现在想要添加 $t$ 个数，使得平均数**保留一位小数**为 $Y$。

## 简要计算：

我们可以通过数学推导的方式得到答案：

首先，要添加的数应该越小越好，在本题中，添加的数应为 $1$。

于是我们就有：$\dfrac{XN+t}{N+t}\ge Y$。

解这个不等式：

$XN+t\ge YN+Yt$；

得到 $t$ 的范围：$t\ge\dfrac{XN-YN}{Y-1}$。

于是我们就有：$t$ 在 $Y=X$ 时为 $0$，要不然为大于等于 $\dfrac{XN-YN}{Y-1}$ 的最小整数。

## 坑点分析：

注意，在最坏情况下， $X$ 应尽可能大，又因为平均得分四舍五入保留一位为 $X$ ，故 $X$ 应加上 $0.049999999999$。

再分析一下，XP 要使 $t$ 最小，$Y$ 应靠近 $X$，故 $Y$ 也应加上 $0.049999999999$。

且注意，$X$ 和 $Y$ 均小于 $10$。

同时，$X\times N$ 的值为整数，所以要取整。

算出 $t$ 后，再取 `ceil` 即可。

最后贴上 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
double x,y;
int main(){
	while(cin>>x>>y>>n){
		if(y==x) cout<<0<<endl;
		else{
			x=min((double)10,x+0.049999999999);
			y=min((double)10,y+0.049999999999);//此处9的个数不要太多，不然爆精度
			cout<<(long long)ceil(((long long)(x*(double)n)-y*(double)n)/(y-1.0))<<endl;//注意细节处理！
		}
	}
	return 0;
}
```

---

## 作者：_Diu_ (赞：4)

题目[传送门](https://www.luogu.com.cn/problem/P1818)

这道题其实就是用柿子~~乱搞~~推导就行了。

## 贪心推柿子

我们用贪心的思想就是：

我们投的每一张票都只有 $1$ 分。

假设我们投了$a$ 票，

那么平均分就是 $\dfrac{xn+a}{n+a}$。

所以得到不等式 $\dfrac{xn+a}{n+a}\le y$。

然后就是推柿子了：

$xn+a\le yn+ya$

$xn-yn\le (y-1)a$

$a\ge \dfrac{xn-yn}{y-1}$

这里 $a$ 应该向上取整。

## ~~一点也不~~愉快的精度问题

这里我们要考虑最坏情况：

就是如果平均数是 $x+0.499999999…$，

那么四舍五入后也是 $x$。

所以 $x$ 要加上 $0.49999999999$（不用太多，$10$ 个差不多）

同理，为了使票数最小，$y$ 也要加上。

其次，我们投的票数是要保证是整数的，所以 $xn$ 的部分要向下取整。

（这里我 WA 了好几次 qwq）

#### 还有一件事

$x,y$ 最大为 $10$。

#### 还有一件事

如果 $x\le y$，那就一票都不用投，坐收成果。

#### ~~好像没事了~~

## code

上代码

```cpp
#include<bits/stdc++.h>
#define ld long double
#define ll long long 
#define min(x,y) ((x)<(y)?(x):(y))
using namespace std;
ll n;
ld x,y;
const ld ch=0.049999999999999;
int main(){
	while(cin>>x>>y>>n){
		if(x<=y){puts("0");continue;}
		x=min((ld)10.0,x+ch);
		y=min((ld)10.0,y+ch);
		printf("%lld\n",(ll)ceil((((ll)(x*(ld)n)-(ld)y*(ld)n)/(y-(ld)1.0))));
	}
}
```

---

## 作者：时光 (赞：4)

#### 算法分析：

~~数据范围有点大啊~~

看看题面，马上就找到了二分的题眼：最坏情况，让平均得分<=Y

最小中的最大->二分

效率O（T log（N））

二分 get！

#### 细节：

常言道：细节决定成败

1. 最坏情况

这也是讨论中大家所疑惑的

4.4->4.449  3.4->3.5

2. 可能你根本不用投

这个坑了我N次。。。

 
#### 实现：

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#define rep(x,a,b) for (int x=int(a);x<=(int)(b);x++)
#define drp(x,a,b) for (int x=int(a);x>=(int)(b);x--)
#define cross(x,a) for (int x=hd[a];~x;x=nx[x])
#define ll long long
using namespace std;
ll x,y,n,ans,m,l,r;
double xx,yy;
/*int round_(double number)
{
    return (number > 0.0) ? floor(number + 0.5) : ceil(number - 0.5);
}手写round*/
int main()
{
    while (scanf("%lf%lf%lld",&xx,&yy,&n)!=EOF)
    {
        x=round(xx*10000),y=round(yy*10000);
        if (x!=100000)//判断是否为十分
        {
            x+=500;//消除精度问题
            x*=n;
            if (x%10000==0) x-=10000;
              else x-=x%10000;
        }
        else x*=n;//十分没有误差
           //处理精度
        l=0,r=100000000000;//二分边界定大点，放心不会超
        ans=0;
        do 
        {
            m=(l+r)>>1;
            if (x+m*10000<((y+500)*(n+m))) ans=m,r=m;//每次加一分平均分下落肯定最快
              else l=m;
        }while (l+1<r);//好像我的二分不是很规范啊。。。
        if (xx<=yy) ans=0;//判断初始情况
        printf("%lld\n",ans);
    }
}
```
蒟蒻的题解，如果有什么不足，欢迎指出。


---

## 作者：BetterGodPig (赞：3)

观察到答案具有单调性，因为你可以投更多的低分使得总平均分变得更低，那么久可以考虑二分答案，二分新投的票数，注意这里可以贪心，即每次新投的都是一分的票，最后注意一下精度的处理，因为题目说的是四舍五入后的一位小数。

---

## 作者：RioFutaba (赞：1)

## 解法
设要投 $A$ 票才能达到目的。显然，我们每票都得投成 $1$ 分。

我们可以列出一个式子：
$$
\dfrac{XN+A}{X+A} \le Y
$$
$XN+A$ 表示投了 $A$ 票后的总分。

两边乘上 $X+A$，得到：
$$
XN+A \le XY+AY
$$

移项，得到：
$$
(1-Y)A \ge XY-XN
$$

注意这里因为平均分数不可能 $>1$，所以要变号。

最后得到：

$$
A \ge \cfrac{XY-XN}{1-Y}
$$

所以 $A$ 取 $\lceil \frac{XY-XN}{1-Y} \rceil$ 即可。

但是我们直接这么写的话会发现有精度问题。因为 $X$ 四舍五入过了，所以可能 $X$ 原本是 $X+0.499999999 \dots$，所以把 $X$ 改为 $X+0.499999999 \dots$。

$Y$ 也有可能是 $Y+0.499999999 \dots$，所以为了使 $1-Y$ 更小（即让 $A$ 更小），把 $Y$ 改为 $Y+0.499999999 \dots$。

同时观察到因为每一票都只能投整数，所以总票数不可能是小数，所以计算时 $XN$ 要取整。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ld long double
#define ll long long
int T;
ll n;
ld x,y;
int main(){
	while(cin >> x >> y >> n){
		if(x<=y){
			cout << "0\n";
			continue;
		}
		x+=(ld)0.04999999999999;
		y+=(ld)0.04999999999999;
		x=min(x,(ld)10.0);
		y=min(y,(ld)10.0);
		ll k=x*n;
		cout << (ll)ceil((ld)(n*y-k)/(ld)(1-y)) << "\n";	
	}
	return 0;
}
```

---

## 作者：forever516 (赞：1)

[原题 P1818](https://www.luogu.com.cn/problem/P1818)。
参考大佬：@Math_rad_round @时光。
# 题意简述。
$N$ 个可取 $1-10$ 的整数的平均数四舍五入保留一位小数是  $A$，现在要你再放上 $x$ 个整数使平均数四舍五入保留一位小数降至 $B$，给你 $X,Y,N$，求 $x$ 最小值。
# 做法。
看看题面，感觉很像二分，看了一下题解区的写法，就写了一下。二分由来：最坏情况，让平均得分小于等于 $Y$。因此可用左开右闭模型。
详见代码：
```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const int mod=100000000000;
ll x,y,n,ans,m,l,r;//ans计数， 
double X,Y;//两个浮点数 
int main() {
	while (cin>>X>>Y>>n) {
		x=round(X*10000);
		y=round(Y*10000);
		if (x!=100000) { //判断是否为十分
			x+=500;//消除精度
			x*=n;
			if (x%10000==0) x-=10000;
			else x-=x%10000;
		} else x*=n;
		l=0,r=mod;//二分边界要很大 ，防止溢出 
		ans=0;
		while (l+1<r){//这二分是典型的左开右闭模型
			m=(l+r)>>1;
			if (x+m*10000<((y+500)*(n+m))){
				ans=m;
				r=m;	
			}else l=m;
		}
		if (X<=Y) ans=0;//判断答案情况
		cout<<ans<<"\n";
		//printf("%lld\n",&ans); 
	}
	return 0;//个人习惯 
}
```
蒟蒻的题解，如果有什么不足，欢迎指出。

最后，附上其他大佬们分享的误区。可能出现根本不用投的情况。

---

## 作者：Furina_Saikou (赞：0)

这道题精度卡的特别死，调了半天。

# 思路

首先很明显如果 $x\le y$，那么直接输出 $0$。否则我们要全部投 $1$ 分的票来让平均分快速下降，设还要 $m$ 张 $1$ 分，则我们可以列不等式：

$$
\cfrac {nx+m}{n+m}\le y
$$

其中 $x,y,n$ 的意义如题目所述。以上不等式最终可化简为：

$$
m\ge \cfrac {ny-nx}{1-y}
$$

注意，因为给出的 $x,y$ 为四舍五入后的结果，所以在最坏情况下我们还要加上 $0.04999...$，因为平均分最高位 $10$ 所以要对 $10$ 取最小值，因为总分一定是整数，所以算出来的 $nx$ 要取整。

# 警钟撅烂

- 我说过这题精度卡得死，所以如果你死了，可以试着小数后多加几个 $9$。
- 如果直接以浮点数的形式输出，在数过大时电脑会自动改输出形式，所以记得转整形后输出。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const long double TEN=10.0,ONE=1.0;
long double x,y,n;
signed main()
{
	while(cin>>x>>y>>n)
	{
		if(x<=y)
		{
			cout<<"0\n";
			continue;
		}
		x+=0.04999999999;
		x=min(TEN,x);
		y+=0.04999999999;
		y=min(TEN,y);
		cout<<(long long)ceil((long double)(n*y-(long long)(n*x))/(ONE-y))<<"\n";
	}
}
```

---

## 作者：kingho11 (赞：0)

一道比较简单的推式子题，需要你找到一个 $ans$ 使得 $\frac{NX+ans}{N+ans} \le Y$。

那么就很简单了，只需要移一下项即可。

不等号两边都乘上 $N+ans$，得 $NX+ans \le YN+Yans$。

然后简单移一下项后得 $ans-Yans \ge YN-NX$，为什么要改变不等号方向呢，是因为根据题目意思理解一下，$Y$ 一定会 $\ge 1$，因为就算所有票都是 $1$，$Y$ 也才能变为 $1$，这个根据题目意思理解会好一些。

接下来，运用一下分配律可以得到 $(1-Y)ans \ge YN-NX$。

然后再移项一下得，$ans \ge \frac{YN-NX}{1-Y}$。

那么这个时候就可以直接算出 $ans$ 了。

## AC CODE:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
double x,y;
int n;
void solve()
{
	if(x==y)
	{
		cout<<0<<"\n";
		return ;
	}
	x+=(long double)0.04999999999999;
	y+=(long double)0.04999999999999;
	x=min(10.0,x),y=min(10.0,y);
	long long nsum=x*(n*1.0);
	cout<<(long long)ceil((y*(n*1.0)-nsum)/(1.0-y))<<"\n";
}
signed main()
{
	while(cin>>x>>y>>n)
	{
		solve();
	}
}
```

---


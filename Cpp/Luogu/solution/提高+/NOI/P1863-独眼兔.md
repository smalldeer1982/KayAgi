# 独眼兔

## 题目描述

太郎有一只特殊的兔子，它只有一只左眼，所以当它移动时是不能向右转弯的。一天，太郎跟独眼兔做一个游戏，太郎在平面内放了 $n$ 个萝卜，每个萝卜有个位置 $(x_i,y_i)$，且任意两个萝卜的 $x_i$，$y_i$ 都是不相同的，独眼兔要去吃这些萝卜。设萝卜 $A(x_i,y_i)$ 是所有萝卜中最小的，那独眼兔会从 $(0,y_i)$ 出发，走向萝卜 $A$，然后开始吃萝卜。当它吃完一个萝卜后，独眼兔会确定下一个萝卜作为目标，然后径直向萝卜走去，当然当它移动的时候是不能向右转弯的。独眼兔还有一个特点，它走过的路径上会留下特殊的气味，所以独眼兔不希望它将要走的路与前面它走过的路相交。太郎想知道独眼兔如何才能吃到最多的萝卜。

## 说明/提示

- $40\%$ 的数据，$n\le100$；
- $100\%$ 的数据，$n\le1000$，$0\lt x_i\le10^4$，$0\lt y_i\le10^4$。

## 样例 #1

### 输入

```
10
4 5
9 8
5 9
1 7
3 2
6 3
10 10
8 1
2 4
7 6
```

### 输出

```
10 8 7 3 4 9 5 6 2 1 10```

# 题解

## 作者：Leap_Frog (赞：7)

# P1863独眼兔（题解）

[题目传送门](https://www.luogu.org/problem/P1863)  

## PS
此题是计算几何的入门好提，但是我却拖了大概两个月才把它搞定。。。  
心情十分激动，于是来写一篇题解纪念一下QwQ。  

**楼上的那一篇题解都用蒟蒻我看不懂的虚数，所以这篇题解很少用用STL的东西**

## 1.向量是什么
![图炸了，请自行百度百科](https://cdn.luogu.com.cn/upload/pic/65916.png)
## 2.向量怎么表示
![图炸了，请自行百度百科](https://cdn.luogu.com.cn/upload/pic/65918.png)
## 3.向量的产生
设$\texttt{A(x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{)\ B(x}_\texttt{2}\texttt{,y}_\texttt{2}\texttt{)}$  
则$\overrightarrow{\texttt{AB}}=\texttt{(x}_\texttt{2}\texttt{-x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{-y}_\texttt{2}\texttt{)}$
## 4.向量的叉积
设$\overrightarrow{\texttt{a}}\texttt{=(x}_\texttt{1}\texttt{,y}_\texttt{1}\texttt{)}\overrightarrow{\texttt{b}}\texttt{\ =(x}_\texttt{2}\texttt{,y}_\texttt{2}\texttt{)}$  
$\texttt{|}\overrightarrow{\texttt{a}}\times\overrightarrow{\texttt{b}}\texttt{|=}\sin\texttt{<a,b>}\times\texttt{|a|}\times\texttt{|b|}$
$\texttt{=x}_\texttt{\texttt{1}}\texttt{y}_\texttt{2}\texttt{-x}_\texttt{2}\texttt{y}_\texttt{1}$  
$\boxed{\color{white}\colorbox{red}{注意：向量的叉积是一个向量，但是由于它飞出了平面，我们只考虑它的模长。}}$  
由于$\texttt{|}\overrightarrow{\texttt{a}}\times\overrightarrow{\texttt{b}}\texttt{|=}\sin\texttt{<a,b>}\times\texttt{|a|}\times\texttt{|b|}$，所以向量的叉积的绝对值可以表示两个向量所夹的三角形面积，向量的叉积的正负可以表示两个向量的旋转的方向。
## 5.此题
终于开始讲此题了。。。
#### 一、样例解释
![图挂了，这里略](https://cdn.luogu.com.cn/upload/pic/65926.png)
#### 二、 真正的题解
总体思路是：
1. 首先应该先找出最下面的点。
2. 然后一个一个的去找点，找到最优的点。
3. 最后输出答案。

但是如何去找到最优的点呢？

1. 首先如果这个点从上一个点来需要向右旋转，那肯定不可能，这里需要用向量叉积的正负性。
2. 然后用贪心的思想，尽量找到旋转角度最小的点，这里需要用向量叉积的模长。

所以代码出世了
### 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1000000005;
struct vec
{
	int x,y;
	inline vec operator+(vec &b) const {return (vec){x+b.x,y+b.y};}		//向量加
	inline vec operator-(vec &b) const {return (vec){x-b.x,y-b.y};}		//向量减
};			//向量结构体
inline int operator*(vec a,vec b) {return a.x*b.y-a.y*b.x;}	//向量的叉积
struct point
{
	int x,y;
	inline vec operator-(point &b) const {return (vec){x-b.x,y-b.y};}	//向量产生
	inline double operator/(point &b) const {return sqrt((x-b.x)*(x-b.y)+(y-b.y)*(y-b.y));}	//两点之间的距离
}a[1005];//平面上的一个点
int n,w=0,vis[1005];	//vis表示此处的萝卜是否被吃掉了
vector<int>v;			//v表示答案数组
int main()
{
	scanf("%d",&n),a[0].x=a[0].y=INF;		//第一个点设置为无穷大，是为了方便下一行处理
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y),w=(a[i].y<a[w].y)?i:w;
	memset(vis,0,sizeof(vis));
	vis[w]=1,v.push_back(w);	//最下面的点入队
	point lst1=(point){0,a[w].y},lst2=a[w];	//lst1表示上一个点，lst2表示前面的第二个点
	for(int i=1,mw=-1;i<n;i++,mw=-1)
	{
		for(int j=1;j<=n;j++)
			if(!vis[j]&&(lst2-lst1)*(a[j]-lst1)>=0)		//这个点没有来过且不需要享有旋转
			{
				if(mw==-1) {mw=j;continue;}
				int t=(a[mw]-lst2)*(a[j]-lst2);		//用贪心的思想，要尽量的找到与上一个面积最小
				if(t<0||(t==0&&(a[j]/lst2)<(a[mw]/lst2))) mw=j;
			}
		if(mw==-1) break;
		v.push_back(mw),vis[mw]=1,lst1=lst2,lst2=a[mw];		//加入答案序列，标位已访问
	}
	printf("%d ",n);
	for(int i=0;i<(int)v.size();i++) printf("%d ",v[i]);	//输出
	return puts(""),0;
}
```

---

## 作者：little_gift (赞：4)

因为吃完萝卜之后必须径直走向下一个萝卜

那么如果某一个时刻一个萝卜在你“右后方”你就再也吃不到它了

所以每次都选一个当前看来最靠右的但又不朝右拐的萝卜吃即可

这个用叉积判一下即可，注意共线（应该有共线吧）

事实上所有萝卜都是可以吃掉的(```assert(ans.size()==n)```)

意会：因为刚开始那个萝卜是"lowest-then-leftmost"，所以肯定在凸包上面

然后每吃掉一个就删一个点，一直沿着凸包走就可以了

~~当然其实这道题跟凸包没什么关系~~

代码里好像没有判leftmost只判了lowest不过数据好像没卡这个？

代码还有其他锅的话欢迎来评论区指正qwq

```cpp
#include <iostream>
#include <complex>
#include <vector>
#include <bitset>
#include <cassert>
typedef std::complex<int> P, V;
P a[1001];
std::bitset<1001> vis;
inline int det(const V& a, const V& b) {
	return (conj(a)*b).imag();
}
inline double dis(const P& a, const P& b) {
	return abs(b - a);
}
std::ostream& operator<<(std::ostream& os, const P& z) {
	std::cout<<"("<<z.real()<<","<<z.imag()<<")";
	return os;
}
std::vector<int> ans;
int main() {
	std::ios::sync_with_stdio(0); std::cin.tie(0);
	int n; std::cin >> n;
	int pos = 1;
	for (int i = 1; i <= n; ++i) {
		int x, y; std::cin >> x >> y;
		a[i] = P(x, y);
		if (a[i].imag() < a[pos].imag()) pos = i;
	}
	ans.push_back(pos); vis.set(pos);
	P l1(0, a[pos].imag()), l2(a[pos]);
	for (int i = 1; i < n; ++i) {
		int pos = -1;
		for (int j = 1; j <= n; ++j) if (!vis.test(j) && det(l2 - l1, a[j] - l1) >= 0) {
			if (!~pos) { pos = j; continue; }
			int _det = det(a[pos] - l2, a[j] - l2);
			if (_det < 0 || (_det == 0 && dis(a[j], l2) < dis(a[pos], l2))) pos = j;
		}
		if (!~pos) break;
		ans.push_back(pos); vis.set(pos);
		l1 = l2; l2 = a[pos];
	}
	assert(ans.size() == n);
	std::cout << ans.size();
	for (auto x : ans) std::cout << ' ' << x;
	std::cout << std::endl;
}
```

---

## 作者：JoeJoeWang (赞：2)

 [题目链接](https://www.luogu.com.cn/problem/P1863)

[在博客中查看](https://www.luogu.com.cn/blog/JoeJoeWang/solution-p1863)

看了楼上两位大佬的题解，讲的都是向量什么的，像我这样的蒟蒻根本就看不懂，因此本蒟蒻就来写一篇多数人都能看懂的题解吧，~~顺便也纪念一下我通过的第一道蓝题~~

### 前置知识

两点间距离公式：设点 $A(x_1,y_1),B(x_2,y_2)$ ，则 $AB=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

余弦定理：已知 $\triangle ABC$ 的三边分别为 $a,b,c$ , 则 $ cosA=\frac{b^2+c^2-a^2}{2bc}$

对等式两边取反三角函数，就可以求得 $\angle A$ 的度数（当然是弧度制的）

对称点：点 $A(x_1,y_1)$ 关于点 $B(x_2,y_2)$ 的对称点 $C(2x_2-x_1,2y_2-y_1)$

### 思路分析

#### 主要思路：贪心

这道题考的似乎是数学知识，但还是要用到贪心算法的。

首先我们要明确的是每一个点其实都可以走到，在这里就不详细说明了。

一开始我们要找到独眼兔走到的第一个点，只需按照题意简单判断即可。同时我们可以依照题意设出第零个点。

然后我们依次寻找独眼兔下一个要走的点。

我们可以很容易地发现贪心策略：每次向左的偏转尽可能小。

假设独眼兔刚从点 $A$ 走到点 $B$ 这时我们要依次判断所有独眼兔还没有走过的点，看哪个点向左偏转程度最小。我们记下一个需要判断的点为点 $C$ 。

显然， $\angle ACB$ 的补角表示向左偏转程度，但是想求补角还缺少一个点坐标的条件，怎么办呢？

我们只需要求出点 $A$ 关于点 $B$ 的对称点点 $D$ ，$\angle DCB$ 即为补角。

用刚才说到的余弦定理的方法求出这个角的值就好了，求出所有未被独眼兔走过的点的角度值，将所有的值进行比较，值最小的点就是独眼兔下一个要走的点。

最后还要判断一下共线的情况，要取与上一个点距离较短的那个点。要注意的是判断几个点是否共线时不是这些点对应的角度全部相等，因为可能会存在少量误差，因此角度之差的绝对值小于等于 $10^{-5}$ 就可以认为是共线的。

AC代码：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
struct pos{
	double x;
	double y;
};
double dis(pos a,pos b)//求两点间距离
{
	double x=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
	return x;
}
double angle(pos a,pos b,pos c)//求角度
{
	double ab=dis(a,b);
	double bc=dis(b,c);
	double ac=dis(a,c);
	return acos((ab*ab+ac*ac-bc*bc)/(2*ab*ac));
}
pos p[1005];
int b[1005],num[1005],n=1;
int main()
{
	int n,min=1;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].x>>p[i].y;
		if(p[i].y<p[min].y)min=i;
		if(p[i].y==p[min].y&&p[i].x<p[min].x)min=i;
	}
	p[0].x=0;
	p[0].y=p[min].y;//第零个点
	num[0]=0;
	num[1]=min;
	b[min]=1;
	for(int i=2;i<=n;i++)
	{
		min=0;
		pos temp;
		temp.x=2*p[num[i-1]].x-p[num[i-2]].x;
		temp.y=2*p[num[i-1]].y-p[num[i-2]].y;//计算对称后点坐标
		for(int j=1;j<=n;j++)
		{
			if(b[j]==0)
			{
				if(min==0)min=j;
				if(abs(angle(p[num[i-1]],temp,p[j])-angle(p[num[i-1]],temp,p[min]))<=0.00001)//处理共线情况
				{
					if(dis(p[num[i-1]],p[j])<dis(p[num[i-1]],p[min]))min=j;
				}
				else if(angle(p[num[i-1]],temp,p[j])<angle(p[num[i-1]],temp,p[min]))min=j;//处理一般情况
			}
		}
		b[min]=1;
		num[i]=min;
	}
	cout<<n<<" ";
	for(int i=1;i<=n;i++)cout<<num[i]<<" ";//输出
	return 0;
}
```

---

## 作者：scp020 (赞：0)

# P1863 独眼兔 题解

没有造纵坐标都是最小但是横坐标不同的数据，怎么这么不毒瘤。

## 解法

如果把题目名称改成瑞士卷，相信大家就已经知道怎么做了。

题中说只能左转或直行，并且路径不能交叉重叠，所以起点一定是纵坐标最小的点。如果有多个纵坐标最小的点，那就选择横坐标最小的点，但是这题数据没有在这里设坑。

只能左转，那就贪心的选择最靠右的那个点走过去。因为如果不选择最靠右的点，这个点就再也不能被选到了。因为轨迹不能右转，也不能从起点下面绕过去。这里的正确性类似凸包，逆时针遍历凸包的话所有点都一直在轨迹的左侧。

如果出现三点共线的情况，那就选距离当前点最近的点，因为不能走回头路。

以上均通过向量叉积实现，不熟悉叉积的可以去凸包模板题题解区学一下。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
    /**
     * 没啥用的东西
    */
};
using namespace fast_IO;
struct point
{
    int x,y;
    point(){x=y=0x3f3f3f3f;}
    point(int x,int y){this->x=x,this->y=y;}
    inline point operator-(const point &rhs) const{return point(x-rhs.x,y-rhs.y);}
    inline int operator*(const point &rhs) const{return x*rhs.y-y*rhs.x;}
    inline bool operator==(const point &rhs) const{return x==rhs.x && y==rhs.y;}
    inline friend int dis(const point lhs,const point rhs)
    {
        return sqrt((lhs.x-rhs.x)*(lhs.x-rhs.x)+(lhs.y-rhs.y)*(lhs.y-rhs.y));
    }
};
int n,st,ed,vis[1010],cnt=1;
point a[1010];
int main()
{
    in>>n,out<<n<<' ';
    for(int i=1,mini=0x3f3f3f3f;i<=n;i++) in>>a[i].x>>a[i].y,st=a[i].y<mini?i:st,mini=std::min(mini,a[i].y);
    vis[st]=1,out<<st<<' ';
    while(cnt<n)
    {
        for(int i=1;i<=n;i++)
            if(!vis[i])
            {
                ed=i;
                break;
            }
        for(int i=1;i<=n;i++)
            if(i!=ed && !vis[i] && ((a[i]-a[st])*(a[ed]-a[st])>0 || 
            (a[i]-a[st])*(a[ed]-a[st])==0 && abs((a[i]-a[st]).x)<abs((a[ed]-a[st]).x))) ed=i;
        vis[ed]=1,st=ed,out<<st<<' ';
        cnt++;
    }
    fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
    return 0;
}
```

---


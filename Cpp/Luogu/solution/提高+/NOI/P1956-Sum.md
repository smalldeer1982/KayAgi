# Sum

## 题目描述

给出一个数列  $a_1,a_2,\cdots,a_n$ 和  $k,p$；

设  $S_{i,j}=\sum\limits_{k=i}^ja_k$，则：
 $$\mathit{Answer}=\min\{S_{i,j}\bmod p\ |\ S_{i,j}\bmod p\ge k\}$$
其中， $i\le j, \{S_{i,j}\bmod p\ |\ S_{i,j}\bmod p\ge k\}\ne\varnothing$。

## 说明/提示

### 数据范围

对于 $100\%$ 的数据， $1\le n\le10^5$，$1\le k,p,a_i\le10^{18}$。

## 样例 #1

### 输入

```
7 2 17
12
13
15
11
16
26
11```

### 输出

```
2```

# 题解

## 作者：Leap_Frog (赞：12)

### P.S.
此题应该挺经典的，但是我还是不会。  

### Problem.
给定一个序列，找出在所有子串和对$p$取模意义下的大于等于$k$的最小值。  

### Solution.
首先，我们有一个很显然的暴力做法，复杂度为$O(N^3)$（废话。  
即我们枚举所有子串和，找到最小值，对于本题很显然超时。  

这题也有一个很显然的优化思路，即用前缀和。  
记$s[i]=\sum_{j=1}^ia[i]$，则$a[i]+...+a[j]=s[j]-s[i-1]$。（废话。  
所以这样可以$O(1)$计算连续子串和，复杂度降为了$O(N^2)$。

我们来仔细分析以下这个暴力慢在哪里了。  
对于一个节点，以其为结尾的子串只需要找到那个子串和最接近。  
即要找到一个$s[j]$最接近$s[i]-k$的，而且要小于$s[i]-k$的。  

那么此题思路就很清晰了。  
我们可以用`set`来维护所有$s[j](j\le i)$，对于每个序列，直接查找不大于$s[i]-k$的最大值就好了。  
而查找可以用`upper_bound`，引入了一个`set`，复杂度变成了$O(N\times \log N)$。  

完结撒花，无耻求赞。

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,p,ans=1e9,s[100005];set<int>e;//定义
int main()
{
	scanf("%d%d%d",&n,&k,&p),s[0]=0,e.insert(0);//读入，初始化
	for(int i=1,x;i<=n;i++) scanf("%d",&x),s[i]=(s[i-1]+x)%p;//求前缀和
	for(int i=1;i<=n;i++)
	{//求的是%p意义下的小于，要分情况讨论
		if(s[i]>=k) ans=min(ans,s[i]-(*--e.upper_bound(s[i]-k)));
		else ans=min(ans,s[i]+p-(*--e.upper_bound(s[i]-k+p)));
		e.insert(s[i]);//插入新来的s[i]
	}
	return printf("%d\n",ans),0;//输出答案，完结撒花
}```

---

## 作者：Hisaishi_Kanade (赞：7)

水题，甚至比我做的很多绿都简单。也许是比较典？

套路的，设数组 $b$ 满足 $b_i =a_i\bmod p$。相当于求 $b$ 的在模 $p$ 意义下最小大于 $k$ 子段和。

更加套路的，我们有前缀和优化的 $n^2$ 做法：枚举左右端点。

但是显然在 $n\le 10^5$ 时这做法寄了。

我们换个思路：如果只要求大于 $k$ 的值，那么是否一些枚举是不必要的？

没错确实有很多不必要的枚举。我们枚举右端点 $r$，寻找一个最大的 $l$ 使得这个区间满足要求。这样直接一路 $O(n)$ 扫过去就可以了。

但是怎么找呢？把前缀和丢进 `set` 就行了。

总复杂度 $O(n\log n)$。

然后这道题就基本做完了。

小心两个坑点：

1. 别忘了 `long long`。
2. 直接减会出负数。

```cpp
#include <set>
#include <stdio.h>
#include <algorithm>
#define int long long
using std::min;
std::set<int> q;
int s[100005];
signed main()
{q.insert(0);
	int n,k,p,i,x,res=1ll<<60;scanf("%lld %lld %lld",&n,&k,&p);
	for(i=1;i<=n;++i)
	{
		scanf("%lld",&x);
		s[i]=(s[i-1]+x)%p;
	}
	for(i=1;i<=n;++i)
	{
		res=min(res,s[i]+(s[i]<k?p:0)-(*--q.upper_bound((s[i]+p-k)%p)));
		q.insert(s[i]);
	}
	printf("%lld",res);
	return 0;
}
```

---

## 作者：nosta (赞：6)

将数列求得模意义下的前缀和s\[0,1...,n\]， 按套路枚举s\[j\] (0<=j<i) 满足 (s[i]-s[j]+p)%p>=k。

分情况， 若存在s\[j\]使得s[i]-s[j]>=k，则s\[j\]<=s\[i\]-k且0<=s[i]-k；

若存在s\[j\]使得s\[i\]-s\[j\]<0但s[i]-s[j]+p>=k，则s[j]<=s[i]-k+p

（注意，上述两种情况不一定包含所有s[j]）

将s\[0,1,...,i-1\]插入平衡树，每次分类查找然后更新答案。应该没有问题吧。

```cpp
int n,k,p;
int s[100010];
set<int> d;

int main() {
	d.insert(0);
	int ans=2e9;
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1; i<=n; ++i) {
		scanf("%d",&s[i]);
		s[i]=(s[i-1]+s[i])%p;
		if(s[i]>=k) {
			int h=*--d.upper_bound(s[i]-k);
			ans=min(ans,s[i]-h);
		}
		int h=*--d.upper_bound(s[i]+p-k);
		ans=min(ans,s[i]-h+p);
		d.insert(s[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：qwaszx (赞：6)

数据水炸的一道题

以至于我拿一个卡时的暴力过掉了还拿了rk1???

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int s[200000],a[200000],ans=1e9+7,kkk=0,n,k,p;
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int rem(int a,int b)
{
	a-=b;
	if(a<0)a+=p;
	return a;
} 
int main()
{
	n=getin(),k=getin(),p=getin();
	for(int i=1;i<=n;i++)a[i]=getin()%p,s[i]=(s[i-1]+a[i])%p;
	for(int i=0;i<n&&kkk<=4500000;i++)
		for(int j=i+1;j<=n;j++)
		{
			int d=rem(s[j],s[i]);
			if(d>=k&&d<ans)ans=d;
			kkk++;
		}
	cout<<ans<<endl;
} 
```
最终版本的卡时~~肯定有大爷能卡进100ms~~

还是来说(可能的~~不过我觉得补星~~)正解

首先前缀和一下顺便取模

然后可以发现我们要求的就是$s_j-s_i$或者$s_j-s_i+p$(以下省略后者，式子肯定都会化,取个min就行了)

因为要不小于k，所以减去一个k变成

$min\{s_j-s_i-k|s_j-s_i-k>=0,j>i\}$

假设已知$s_j$,那么就是要找一个最大的$s_i$使$s_j>=s_i+k$

这个东西看起来就是一个前驱的样子了

所以可以二叉查找树解决

为什么不用平衡树？

因为~~不好写~~随机数据显然二叉查找树的复杂度可以保证~~不然暴力怎么能过~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int ch[200000][2],f[200000],rt,id,w[200000]={1e9+7},m,opt,x,ans=1e9+7,s[200000],n,k,p;
int prep(int x)
{
	int lst=0,o=rt;
	while(o)
	{
		if(x>w[o])lst=o,o=ch[o][1];
		else o=ch[o][0];
	} 
	return w[lst];
}
void ins(int x)
{
	if(!rt){w[++id]=x,rt=id;return;}
	int o=rt,lst;
	while(o)
	{
		lst=o;
		if(x>w[o])o=ch[o][1];
		else if(x<w[o])o=ch[o][0];
		else break;
	}
	if(!o)
	{
		w[o=++id]=x;
		f[id]=lst,ch[lst][x>w[lst]]=id;
	}
}
int getin()
{
	int x=0,f=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x*f;
}
int main()
{
	n=getin(),k=getin(),p=getin();
	for(int i=1;i<=n;i++)s[i]=(s[i-1]+getin())%p;
	ins(s[1]+k);
	for(int i=2;i<=n;i++)
	{
		ans=min(ans,(s[i]-min(prep(s[i]+1),prep(s[i]+p+1))+k+p)%p);
		ins(s[i]+k);
	}
	cout<<ans<<endl;
}
```

---

## 作者：神眷之樱花 (赞：4)

# 题意
找出满足子段和在膜 $p$ 意义下大于等于 $k$ 的最小子段和。
# 题解
根据膜法的性质，我们在膜 $p$ 意义下，进行前缀和操作是可以的。那么我们就优化了找子段和这一步骤。

那么现在剩下的问题就是找哪一段子段和。

$n ^ {2}$ 暴力找是显然不能过的，考虑优化，直接可能成为最优解的子段。

因为前缀和都膜了 $p$，所以所有的前缀和都是在 $0$ ~ $p - 1$ 内的。

那么对于右端点 $i$， 当子段和大于等于 $k$ 的时候，满足条件的左端点 $j$， 满足如下性质。
$$sum[i] - sum[j] \geq k(sum[i]> sum[j])$$
$$sum[i] - sum[j] + p \geq k(sum[i]\leq sum[j])$$

稍作变形之后，就得到了如下柿子：
$$sum[j] \leq sum[i] - k(sum[i]> sum[j])$$
$$sum[j] \leq sum[i] + mod - k(sum[i]\leq sum[j])$$

我们得到了满足条件的 $j$ 的柿子，那么我们为了答案最优，我们就要找到其中最大的 $sum[j]$。

所以引用数据结构来优化。

因为原数组不是单调的，普通的二分查找肯定是不行的。

不难发现平衡树是满足我们的需要的，但是懒得手打，于是可以用 set。

因为 set 只有大于等于和大于，所以可以把上柿同时取反，然后枚举 $i$， 查找 $j$，就行了。

# 代码
```cpp
#include<cstdio>
#include<cctype>
#include<set>
#include<iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 5;

LL a[N], sum[N], mod, k, n, ans = 1e18, x1, x2;

set < LL > s;

inline LL read() {
	LL x = 0; int f = 1, c = getchar();
	for(; !isdigit(c); c = getchar())
		if(c == '-')
			f = -1;
	for(; isdigit(c); c = getchar())
		x = x * 10 + c - 48;
	return x * f;
}

int main() {
	n = read(), k = read(), mod = read();
	for(int i = 1; i <= n; i++) {
		a[i] = read();
		if(a[i] >= mod) a[i] %= mod;
	}
	for(int i = 1; i <= n; i++) {
		sum[i] = (1ull * sum[i - 1] + a[i]) % mod;
		s.insert(-sum[i]);
	}
	for(int i = 1; i <= n; i++) {
		x1 = *s.lower_bound(k - sum[i]);
		x2 = *s.lower_bound(k - sum[i] - mod);
		x1 = (sum[i] + x1) % mod;
		x2 = (sum[i] + x2) % mod;
		if(x1 < 0) x1 += mod;
		if(x2 < 0) x2 += mod;
		if(x1 >= k) ans = min(ans, x1);
		if(x2 >= k) ans = min(ans, x2);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题目描述

求区间和在模 $p$ 下，大于等于 $k$ 的最小值。

## 思路

考虑前缀和优化。

$$(sum[i]-sum[j])\bmod p\geq k$$

由此得到。

$$sum[i]-sum[j]\geq k$$
$$sum[i]-sum[j]+p\geq k$$

将已知的放到一边，得到。

$$k-sum[i]\leq -sum[j]$$
$$k-sum[i]-p\leq -sum[j]$$

为了快速求出对于每一个 $i$ 对应的最优的解，我们使用 set 动态插入并查询。

## 代码展示

```cpp
#include<cstdio>
#include<set>
#define LL long long
using namespace std;

const int MAXN = 1e5 + 5;

int n; LL k, p;
LL a[MAXN], sum[MAXN];
set<LL> s;

int main() {
	scanf("%d%lld%lld",&n, &k, &p);
	for(int i = 1; i <= n; i++)
	 scanf("%lld",&a[i]), sum[i] = (sum[i - 1] + a[i]) % p;
	LL res = 5e18; s.insert(0);
	for(int i = 1; i <= n; i++) {
		LL val = *s.lower_bound(k - sum[i]);
		LL now = ((sum[i] + val) % p + p) % p;
		if(now >= k) res = min(res, now);
		val = *s.lower_bound(k - sum[i] - p);
		now = ((sum[i] + val) % p + p) % p;
		if(now >= k) res = min(res, now);
		s.insert(-sum[i]);
	}
	printf("%lld\n",res);
	return 0;
}
```


---

## 作者：Kexi_ (赞：0)

这道题就是取模有点烦人，其他都还好。

是前缀和优化的题，我们转化一下题意。

设 $sum_i = \sum_{j = 1} ^ i a_j$，求

$$sum_i - sum_j \equiv k \pmod p$$

那你就整一个集合来二分答案呗，把之前的 $sum$ 都存一下，然后二分找小于等于 $sum_i - k$ 的最大值。

然后你在过程中要确保一下你算的答案一直是正数。

复杂度 $O(n \log n)$ 跑的飞快，目前第四优解。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N = 1e5 + 7;
int target , n , k , p , ans = 2e18 , sum[N];
set<int> s;
inline int mod(int a, int b) {
	__int128 y = ((__int128)1 << 64) / b;
	return a - ((__int128)a * y >> 64) * b;
}//小优化，就等同于正常取模 a % b
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
signed main() {
	n = read() , k = read() , p = read();
	s.insert(0);
	for(register int i = 1; i <= n; ++i) {
		sum[i] = read();
		sum[i] = mod(sum[i - 1] + sum[i] , p);
		target = mod(sum[i] - k + p , p);
		int ans1 = mod(sum[i] - * --s.upper_bound(target) + p , p);//你找到第一个严格大于target的数，地址
往前一个就是小于等于target的最大值
		if(ans1 >= k) {ans = min(ans ,  ans1);}//这个判断要注意一下
		s.insert(sum[i]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：analysis (赞：0)

又是随机跳题的一天，调了好久才从 `60pts` 调到 `100pts`。

## 题解

易想到区间问题转前缀和，问题即求（$S$ 为原数组前缀和）：

最小的 $(S_i - S_{j-1}) \bmod p$ 满足 $(S_i - S_{j-1}) \bmod p \geq k$。

对于 $(S_i - S_{j-1}) \bmod p \geq k$，我们解出一个 $(S_i - S_{j-1})  \equiv k \pmod{p}$，然后取小于等于的即可。

$$(S_i - S_{j-1})  \equiv k $$

$$S_{j-1}  \equiv S_i - k $$

$$\therefore S_{j-1} \leq (S_i - k) \bmod p$$

所以使用 `set` 维护。

但还要注意特判：当 $S_i < k$ 时，不能计算答案。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int x[100005];
int n, k, p;
set<int> l;
int be;
signed main()
{
    cin >> n >> k >> p;
    x[0] = 0;
    for (int i = 1,sum=0; i <= n; i++)
    {
        cin >> x[i];
        if(sum < k)
        {
            be = i;
            sum += x[i];
        }
        x[i] = (x[i - 1] + x[i]) % p;
    }
    int ans = LONG_LONG_MAX;
    for (int i = 1; i <= n; i++)
    {
        l.insert(x[i - 1]);
        if(i < be)continue;
        int tp = (*--l.upper_bound((x[i] + p - k) % p));
        ans = min(
            ans,
            ((x[i] - tp) % p + p) % p
        );
    }
    cout << ans;
}
```

---


# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# 题解

## 作者：panyf (赞：19)

本人太弱，~~不会DP~~，于是就有了这个**只用DFS**的题解

首先，我们会想到暴力做法，时间复杂度约为O(C(n,r)C(m,c)rc)，可以得到60分，代码就不提供了

暴力做法之所以慢，是因为进行了重复的计算，而且缺少剪枝。

矩阵的分值包含两部分，**一是同一行两个数差的绝对值，二是同一列两个数差的绝对值**。如果我们先搜索行再搜索列，第二种分值就可以在搜索行时计算，而第一种分值在搜索列时边搜索边计算。

我们还可以加上搜索常用的最优性剪枝，就是当此时矩阵的分值已经大于等于当前最优答案，那么就退出搜索

代码如下：
```cpp
void dfsl(ci&x,ci&y,ci&z){//const类型传参，卡常数必备，x为上一列，y为已搜索的列数，z为当前答案
	if(y==c){
		s=z;//更新答案
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;//register类型卡常数，en为搜索终止位置
	for(;i<en;++i){
		zz=z+p[i];//p数组存储第二种分值
		if(zz>=s)continue;//剪枝
		if(x!=0){
			for(j=0;j<r;++j){
				zz+=abs(v[e[j]][i]-v[e[j]][x]);//累加第一种分值
			}
		}
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){//搜索行
	if(y==r){
		dfsl(0,0,0);//搜完则搜索列
		return;
	}
	register int i=x+1,en=y+n-r+2,j,q[19];//q数组必须在dfsh函数内定义，用于回溯
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				q[j]=abs(v[x][j]-v[i][j]),p[j]+=q[j];
			}
		}
		e[y]=i,dfsh(i,y+1);//e数组保存取出的行
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=q[j];//回溯
		}
	}
}
```
80分，超时，需要继续优化

我们会发现abs进行调用的次数很多，因此可以预处理所有分值，减少重复计算

代码如下：
```cpp
for(i=1;i<n;++i){//预处理第二种分值
		for(j=i+1;j<=n;++j){
			for(k=1;k<=m;++k){
				g[i][j][k]=abs(v[i][k]-v[j][k]);
			}
		}
	}
	for(i=1;i<m;++i){//预处理第一种分值
		for(j=i+1;j<=m;++j){
			for(k=1;k<=n;++k){
				h[i][j][k]=abs(v[k][i]-v[k][j]);
			}
		}
	}
```
同时相应修改DFS函数：
```cpp
void dfsl(ci&x,ci&y,ci&z){
	if(y==c){
		s=z;
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;
	for(;i<en;++i){
		zz=z+p[i];
		if(zz>=s)continue;
		if(x!=0){
			for(j=0;j<r;++j){
				zz+=h[x][i][e[j]];//累加第一种分值
			}
		}
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){
	if(y==r){
		dfsl(0,0,0);
		return;
	}
	register int i=x+1,en=y+n-r+2,j;
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				p[j]+=g[x][i][j];//第二种分值
			}
		}
		e[y]=i,dfsh(i,y+1);
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=g[x][i][j];//回溯
		}
	}
}
```
依然是80分，但是速度相比之前略快，需要继续剪枝

我们可以考虑将累加第一种分值在dfsh函数中进行，因为dfsh调用次数少于dfsl，因此可以减少重复计算

代码如下：
```cpp
void dfsl(ci&x,ci&y,ci&z){
	if(y==c){
		s=z;
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;
	for(;i<en;++i){
		zz=z+p[i]+w[x][i];//可以一次性求出两种分值之和
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){
	if(y==r){
		dfsl(0,0,0);
		return;
	}
	register int i=x+1,en=y+n-r+2,j,k;
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				p[j]+=g[x][i][j];
			}
		}
		for(j=1;j<m;++j){
			for(k=j+1;k<=m;++k){
				w[j][k]+=h[j][k][i];//用w数组保存第一种分值
			}
		}
		e[y]=i,dfsh(i,y+1);
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=g[x][i][j];
		}
		for(j=1;j<m;++j){
			for(k=j+1;k<=m;++k){
				w[j][k]-=h[j][k][i];//注意w数组也要回溯
			}
		}
	}
}
```
这样就可以得到[100分](https://www.luogu.com.cn/record/24211528)了

---

## 作者：lizh (赞：6)

题目要求在n行m列中选择r行c列，交叉部分构成一个新矩阵。

暴力的做法就是枚举列和行，共有$C_n^r*C_m^c$种情况，计算统计答案。

然后可以dp进行优化，在枚举完行和列的其中一个变量后，剩下的另一个变量就不需要继续暴力枚举，而可以采用dp优化的方式进行统计最优解。

假设我们先dfs来枚举每一种列的选择方式，然后我们设一个变量$f[i][j]$表示前$i$行选了$j$列的最优解。

转移方程$f[i][j]=min(f[i][j],f[k][j-1]+tot)$，其中$k∈[1,i-1]$，$tot$表示选了第$i$行且上一行是第$k$行时对答案的贡献值.

然后是$tot$的计算方法，我们在dfs列时，对枚举到的列打上标记，之后在计算中,对有标记的地方进行计算就行。

初始化时要注意的是，i要从2开始枚举，否则k无法进入循环，因此初始化时我们要对全部$f[i][1]$进行初始化，而因$f[i][1]$对答案无影响，我们直接初始化为第$i$行的横向相邻数的总值。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

int lr[100],f[100][100],a[100][100],d[100][100];
int n,m,r,c,ans=1e9;

void search(int x,int num)
{
	if(num==c)
	{
		for(int i=0;i<=17;i++)
		{
			for(int j=0;j<=17;j++)
			{
				d[i][j]=1e9;
			}
		}
		memset(f,0x3f,sizeof(f));
		for(int i=0;i<=n;i++) f[i][0]=0;
		for(int i=1;i<=n;i++)
		{
			f[i][1]=0;
			int last=0;
			for(int j=1;j<=m;j++)
			{
				if(lr[j])
				{
					if(last)
					{
						f[i][1]+=abs(a[i][j]-last);
					}
					last=a[i][j];
				}
			}
		}
		for(int j=2;j<=r;j++)
		{
			for(int i=j;i<=n;i++)
			{
				for(int k=1;k<i;k++)
				{
					int tot=0,last=0;
					for(int l=1;l<=m;l++)
					{
						if(lr[l])
						{
							tot+=abs(a[i][l]-a[k][l]);
							if(last)
							{
								tot+=abs(a[i][l]-last);
								last=a[i][l];
							}
							else last=a[i][l];
						}
					}
					f[i][j]=min(f[i][j],f[k][j-1]+tot);
//					cout<<i<<" "<<j<<" "<<f[i][j]<<" "<<tot<<endl;
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			ans=min(ans,f[i][r]);
		}
//		cout<<ans<<endl;
		return ;
	}
	for(int i=x+1;i<=m;i++)
	{
		lr[i]=1;
		search(i,num+1);
		lr[i]=0;
	}
	return ;
}

int main()
{
//	freopen("submatrix.in","r",stdin);
//	freopen("submatrix.out","w",stdout);
	scanf("%d%d%d%d",&n,&m,&r,&c);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	search(0,0);
	cout<<ans;
	return 0;
 }
```


---

## 作者：Proxima_Centauri (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P2258)
# 题意
首先给了两个定义：
- 子矩阵——**某些行某些列**交出来的那些格子组成的矩阵。（不必连续）
- 分值：一个矩阵的相邻元素**差的绝对值之和**。
 
让我们最小化子矩阵的分值。
# 分析
## 暴力
这个简单，枚举行和列选不选然后暴力计算。复杂度 $O(2^{n + m})$。
## 优化
事实上我们没必要行和列都枚举。

为方便陈述，我们规定：**同一列**的数对分值的贡献叫做**列贡献**，同一行的叫做**行贡献**。

如果我们枚举选了哪些行：

1. 那么每一列的列贡献，$O(n \cdot m)$ 可以算出。
2. 每两列之间的行贡献，$O(m^2 \cdot n)$ 也可以算出。

有了这两个东西我们不妨考虑 DP：设状态 $f_{i, j}$ 表示前 $i$ 列（**第 $i$ 列必选**），共选了 $j$ 列的答案。

转移很好看出了，枚举上一个选的哪一列：
$$f_{i, j} = \min\{f_{k, j - 1} + dis_{i, k} + sum_i\}$$ 
其中 $sum$ 是列贡献，$dis$ 代表两列之间的行贡献。

因为没有必要选第 $n$ 列，所以最后答案是 $\min f_{i, c}$。

初值的话，全是无穷大，$f_{i, 0} = 0$。

需要注意的是，尽管上述的有些状态没有意义（因为状态定义的是最后一列必选），但是我们附上初值 $0$ 以后**转移会方便**很多。

具体 DP 的细节请移步代码~
# AC code
使用搜索来枚举每一行选不选（其实也可以状压）。
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int a[20][20];
int f[20][20];
int n, m, r, c;
bool chose[20];
int sum[20];
int dis[20][20];
int ans = 1e9;
void dfs(int nowr, int i)
{
	if (nowr > r) return;
	if (nowr + n - i < r) return;
  // 小剪枝
	if (i == n && nowr == r)
	{
		for (int j = 1; j <= m; j++)
		{
			sum[j] = 0;
			int lst = 0;
			for (int i = 1; i <= n; i++) 
			{
				if (!chose[i]) continue;
				if (lst) sum[j] += abs(a[i][j] - a[lst][j]);
				lst = i;
			}
		}
		for (int i = 1; i <= m; i++)
			for (int j = i + 1; j <= m; j++)
			{
				dis[i][j] = 0;
				for (int k = 1; k <= n; k++)
					if (chose[k]) dis[i][j] += abs(a[k][i] - a[k][j]);
			}
		memset(f, 0x3f, sizeof(f));
		for (int i = 0; i <= m; i++) f[i][0] = 0;
		for (int i = 1; i <= m; i++)
			for (int j = 1; j <= c; j++)
				for (int k = 0; k <= i - 1; k++)
					f[i][j] = min(f[i][j], f[k][j - 1] + sum[i] + dis[k][i]);
		for (int i = 1; i <= m; i++) ans = min(ans, f[i][c]);
		return;
	}
	chose[i + 1] = true;
	nowr++;
	dfs(nowr, i + 1);
	chose[i + 1] = false;
	nowr--;
	dfs(nowr, i + 1);
	// 别忘了回溯
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> r >> c;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
	dfs(0, 0);
	cout << ans << "\n";
	return 0;
}
```
# 总结
很好的 DP 题，最后的复杂度 $O(n^3 \cdot 2^n)$，可以通过。（由于 $n, m$ 一个量级，复杂度中 $m$ 用 $n$ 代替了。

完结撒花~

---

## 作者：RikoHere (赞：4)

在矩阵中求解最优情况，其中$n \leq 16$

假设现在已经得到保留的行与列的编号，递推矩阵分值的复杂度是$O(n^2)$遍历一遍就ok

50pts 假设行列全部枚举全排列的话，枚举次数在最坏情况下是$(C_{12}^6)^2=924^2$,在加上求分值的复杂度则总复杂度还是勉强可以接受的?

直接看100pts解法,仍然枚举一次行的全排列，复杂度是$O(C_m^c)$，这个时候我们得到的其实是一行数列，数列上的每个数有选择和不选择两种状态，选择每个数会增加分值，分别是：

 - 自身的分数(该列上下数字差值绝对值和)
 
 - 相对左侧(右侧)的分数,左侧和右侧的选择都会影响这种相对分数
 
 那么提前预处理出数列上每个数两两之间相对的分数和自身的分数，因为要枚举$m$的原因，所以复杂度是$O(n^3)$
 
 进行dp，设$f[i][l]$为已选择到数列上第$i$个数，已选择$l$个数的最大值，很明显$f[i][l]=min(f[k][l-1]+sum[k][i])$ 其中$k \subseteq[1,i-1]$，不需要太多优化，只要枚举$i,k,l$就可以在$O(n^3)$之内解决问题，该种方法总复杂度$O(C_m^c n^3)$可以通过$n=16$的数据


```
//2019/7/19->Riko->AtNCU->luoguP2258
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;

bool digit (int ch) { return (ch <= '9' and ch >= '0');}
inline int in () {
    int x = 0, ch = getchar(), base = 1;
    while (!digit(ch)) {
    	if (base == '-') base = -1;
        ch = getchar();
    }
    while (digit(ch)) x = x*10+ch-'0', ch = getchar();
    return x*base;
}
template <typename T> inline void smin (T& x, T y) { if (x > y) x = y;}
inline int abs (int x) { return (x < 0) ? -x : x;}

const int N = 24;
int n, m, r, c, ans, cnt;
int f[N][N], a[N][N], sum[N][N], suml[N], bol[N];

void work () {
    memset(sum, 0, sizeof(sum));
    memset(suml, 0, sizeof(suml));
    memset(f, 0x3f, sizeof(f));
    for (int i = 1; i <= n; ++i) {
        for (int j = i+1; j <= n; ++j) {
            int seg = 0;
            for (int l = 1; l <= m; ++l) {
                if (bol[l]) seg += abs(a[i][l]-a[j][l]);
            }
            sum[i][j] = sum[j][i] = seg;
        }
        int last = 0;
        for (int l = 1; l <= m; ++l) {
            if (bol[l]) {
                if (last) suml[i] += abs(a[i][l]-last);
                last = a[i][l];
            }
        }
    }
    for (int i = 1; i <= n; ++i) { f[i][1] = suml[i];}
    for (int i = 1; i <= n; ++i) {
        for (int l = 2; l <= r; ++l) {
            int Min = f[0][0];
            for (int j = 1; j < i; ++j) {
                smin(Min, f[j][l-1]+sum[j][i]);
            }
            f[i][l] = Min+suml[i];
        }
    }
    for (int i = 1; i <= n; ++i) { smin(ans, f[i][r]);}
}
void dfs (int idx, int num) {
    if (num == c) {
        work();
        return;
    }
    for (int i = idx; i <= m; ++i) {
        bol[i] = true;
        dfs(i+1, num+1);
        bol[i] = false;
    }
}
void prepare () {
    n = in(); m = in();
    r = in(); c = in();
    ans = 999999999;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            a[i][j] = in();
        }
    }
    dfs(1, 0);
    printf("%d", ans);
} int main () { prepare();}
```


---

## 作者：lkjlkjlkj2012 (赞：2)

强调：**一定要仔细读题**~~，我一开始以为是子矩阵和最小……~~

首先，我们可以考虑枚举选了哪些行，可以使用二进制枚举。  
之后预处理 $s_1, s_2$。$s_1$ 表示对于每一列，相邻行之差的绝对值之和，$s_2$ 表示对于每一行，指定两行之差的绝对值之和，具体见图。
![](https://cdn.luogu.com.cn/upload/image_hosting/45vjyt5j.png)
然后定义 $f_{i,j}$ 为选了 $j$ 列，最后一列是第 $i$ 列，转移为 $f_{i,j}=\min{(f_{i,j},f_{k,j-1}+{s_1}_i+{s_2}_{k,i})}$。  
最后求出答案就可以啦。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,r,c,a[17][17],ans=0x3f3f3f3f,cc[17],s1[17],s2[17][17],f[17][17];
int main()
{
    cin>>n>>m>>r>>c;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int jj=0;jj<(1<<n);jj++)
    {
        int cnt=0;
        for(int i=0;i<=n;i++)
            if(jj&(1<<i))
            {
                cc[cnt]=i+1;
                cnt++;
            }
        if(cnt!=r)
            continue;
        for(int i=1;i<=m;i++)
        {
            s1[i]=0;
            for(int j=0;j<cnt-1;j++)
                s1[i]+=abs(a[cc[j]][i]-a[cc[j+1]][i]);
            for(int k=i+1;k<=m;k++)
            {
                s2[i][k]=0;
                for(int j=0;j<cnt;j++)
                    s2[i][k]+=abs(a[cc[j]][i]-a[cc[j]][k]);
            }
        }
        for(int i=1;i<=m;i++)
            for(int j=1;j<=c;j++)
                f[i][j]=0x3f3f3f3f;
        f[0][0]=0;
        for(int i=1;i<=m;i++)
        {
            f[i][1]=s1[i];
            for(int j=2;j<=c;j++)
                for(int k=1;k<i;k++)
                    f[i][j]=min(f[i][j],f[k][j-1]+s1[i]+s2[k][i]);
            ans=min(ans,f[i][c]);
        }
    }
    cout<<ans;
}
```

---

## 作者：我梦见一片焦土 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P2258)

---


# 思路：

这道题就是将题目所给你的矩阵进行“选取”行与列的操作，从而得到所求的最大值的集合，但是重要的是我们不知道题目所给的行和列的值是多少，因此我们可以对此进行一个循环中的判断操作，在选出来这个行之后再去考虑列的情况，从而得出最优决策。

这个地方还有一个降维操作，就是我们在一个 $r\times m$（事先以及决定了选取那几行，该去考虑列的问题时）的矩阵中选取 $c$ 列，这个时候我们可以把二维降低到一维，（因为这其中行已经有了判断的标准，我们只需要进行列的操作就足够了）。

下面开始讲 DP 过程：

我们设 $f_{i,j}$ 表示在这个 $r\times m$ 的矩阵中，在其前 $i$ 列中选择 $j$ 列（且选的列中包括第 $i$ 列），组成的子矩阵中，最小值（即其相邻元素的差的绝对值的和的最小值（之后的值等表达也是指的这个东西，即题目要求求出的值））是多少。

这样，推出状态转移方程如下：$f_{i,j} = \min (f_{k,{j-1}} + hc_{i,k} + lc_i)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=20;
const int INF=0x3f3f3f3f;
int n,m,r,c,w[N][N],rows[N],cw[N],rw[N][N],f[N][N],ans=INF;
void dp(){
    for(int i=1;i<=m;i++){
        int res=0;
        for(int j=2;j<=r;j++){
            res+=abs(w[rows[j]][i]-w[rows[j-1]][i]);
        }
        cw[i]=res;
    }
    for(int i=1;i<m;i++){
        for(int j=i+1;j<=m;j++){
            int res=0;
            for(int k=1;k<=r;k++){
                res+=abs(w[rows[k]][i]-w[rows[k]][j]);
            }
            rw[i][j]=res;
        }
    }
    memset(f,0x3f,sizeof f);
    for(int i=1;i<=m;i++){
        f[i][1]=cw[i];
        for(int j=2;j<=c;j++){
            for(int k=1;k<=i-1;k++){
                f[i][j]=min(f[i][j],f[k][j-1]+cw[i]+rw[k][i]);
            }
        }
        ans=min(ans,f[i][c]);
    }
}
void dfs_r(int k){
    if(k>r){
        dp();
        return;
    }
    int start=1;
    if(k>1){
        start=rows[k-1]+1;
    }
    for(int i=start;i<=n;i++){
        rows[k]=i;
        dfs_r(k+1);
    }

}
signed main(){
    cin>>n>>m>>r>>c;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>w[i][j];
        }
    }
    dfs_r(1);
    cout<<ans<<endl;
    return 0;
}
```
完结撒花

---

## 作者：tony0530 (赞：1)

### solution

------

#### 题目

[传送门](https://www.luogu.com.cn/problem/P2258)

给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列交叉而成的子矩阵，使得这个子矩阵的矩阵中每一对相邻元素(四联通)之差的绝对值之和最小，并输出这个值。

-------

#### 算法一

时间复杂度：${O(C_n^r \times C_m^c)}$。

~dfs+玄学剪枝应该能过,我没试过不确定。~

------

#### 算法二

考虑 DP
- **状态** $f_{i,j}$ 表示在前 $i$ 行选 $j$ 列的最小，$g_{i,j}$ 表示选了第 $i$ 行并且上一行是第 $j$ 的最小值。
- **转移** $f_{i,1} = 1$，$ \underset{1 \le k < i}{\min}f_{k, j-1}+g_{i,k}$。

------

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int n, m, r, c;
int matrix[N][N];
int f[N][N];
int cw[N], rw[N][N];
int q[N];

int count1(int x)
{
    int res = 0;
    for(int i = 0 ; i < n ; i ++ ) res += x >> i & 1;
    return res;
}
int main()
{
    cin >> n >> m >> r >> c;
    for(int i = 0 ; i < n ; i ++ )
        for(int j = 0 ; j < m ; j ++ )
            cin >> matrix[i][j];
    
    int res = INF;
    for(int state = 0; state < 1 << n; state ++ )
        if(count1(state) == r)
        {
            for(int i = 0, j = 0 ; i < n ; i ++ )
                if(state >> i & 1)
                    q[j ++ ] = i;
            for(int i = 0 ; i < m ; i ++ )
            {
                cw[i] = 0;
                for(int j = 1 ; j < r ; j ++ )
                    cw[i] += abs(matrix[q[j]][i] - matrix[q[j - 1]][i]);
            }
            for(int i = 0 ; i < m ; i ++ )
                for(int j = i + 1 ; j < m ; j ++ )
                {
                    rw[i][j] = 0 ;
                    for(int k = 0 ; k < r ; k ++ )
                        rw[i][j] += abs(matrix[q[k]][i] - matrix[q[k]][j]);
                }
            for(int i = 0 ; i < m ; i ++ )
            {
                f[i][1] = cw[i];
                for(int j = 2 ; j <= c ; j ++ )
                {
                    f[i][j] = INF;
                    for(int k = 0 ; k < i ; k ++ )
                        f[i][j] = min(f[i][j], f[k][j - 1] + cw[i] + rw[k][i]);
                }
                res = min(res, f[i][c]);
            }
        }
    cout << res;
    return 0;
}
```

---

## 作者：xmy201315 (赞：1)

这道题一定要好好读题！~~我就被坑了~~

这道题是一道模拟+dp 的题目。

首先我们一个个枚举行选出了哪些行，接着我们 dp 列，令 $f_{i,j}$ 为前 $i$ 列选了 $j$ 列，并且选了第 $i$ 列，再令前面选的一个是 $k$，那么转移是 $f_{i,j} = \min(f_{k,j-1}+s1_{i}+s2_{k,i})$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e1stzf3w.png)
那么这道题就能做出来啦！（细节详看代码）

**AC code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 20;
const int inf = (1 << 29);
int n, m, r, c, ans = inf;
int a[N][N], row[N], s1[N], s2[N][N], dp[N][N];
int main() {
	scanf("%d%d%d%d", &n, &m, &r, &c);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	for (int S = 0; S < (1 << n); S++) {
		int cnt = 0;
		for (int i = 0; i < n; i++)
			if (S & (1 << i)) {
				row[cnt] = i + 1;
				cnt++;
			}
		if (cnt != r)continue;
		for (int i = 1; i <= m; i++) {
			s1[i] = 0;
			for (int j = 0; j < cnt - 1; j++)
				s1[i] += abs(a[row[j]][i] - a[row[j + 1]][i]);
			for (int k = i + 1; k <= m; k++) {
				s2[i][k] = 0;
				for (int j = 0; j < cnt; j++)
					s2[i][k] += abs(a[row[j]][i] - a[row[j]][k]);
			}
		}
		for (int i = 0; i <= m; i++)for (int j = 0; j <= c; j++)
				dp[i][j] = inf;
		dp[0][0] = 0;
		for (int i = 1; i <= m; i++) {
			dp[i][1] = s1[i];
			for(int j = 2; j <= c;j++)
				for (int k = 1; k < i; k++)
					dp[i][j] = min(dp[i][j], dp[k][j - 1] + s1[i] + s2[k][i]);
			ans = min(ans,dp[i][c]);
		}
	}
	printf("%d",ans);
}
```

完结撒花！

---

## 作者：ZHR100102 (赞：0)

[Blog](https://www.cnblogs.com/zhr0102/p/18876515)


简单枚举加背包 DP，用到了枚举矩阵首行 / 首列的套路。

注意到 $n,m$ 很小，考虑**暴力**，$O(C_{n}^{r})$ 枚举出所选的行后，如果再继续枚举列，时间复杂度就是 $O(C_{n}^{r}C_{m}^{c})$ 的，由于 $n=16,r=8$ 时单个组合数有极值 $12870$，故剪枝后可以轻松通过。

但本题还有一个性质：**在确定子矩阵的首行后，对后续所选的列的决策是容易的**。

于是定义 $dp_{i,j}$ 表示**确定了子矩阵的行后**，目前选到第 $i$ 列，前面一共选了 $j$ 列的最小价值。把这个 DP 看做一个背包，每一列看做一个物品，**枚举每一列前面接到的列**转移即可。时间复杂度 $O(C_{n}^{r}m^3)$。

注意列之间的代价和某一列内的代价需要**预处理**出来才可以做到单次 DP $O(m^3)$ 的复杂度。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=20;
int n,m,r,c,a[N][N],dp[N][N],w[N][N],ans=0x3f3f3f3f;
void check(int st)
{
    int popc=0;
    for(int i=0;i<n;i++)popc+=((st>>i)&1);
    if(popc!=r)return;
    memset(w,0,sizeof(w));
    for(int i=1;i<=m;i++)
    {
        int lst=-1;
        for(int j=1;j<=n;j++)
            if((st>>(j-1))&1)
            {
                if(lst!=-1)
                    w[i][i]+=abs(a[j][i]-lst);
                lst=a[j][i];
            }
        for(int j=i-1;j>=1;j--)
            for(int k=1;k<=n;k++)
                if((st>>(k-1))&1)
                    w[j][i]+=abs(a[k][i]-a[k][j]);
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i<=m;i++)dp[i][1]=w[i][i];
    for(int lv=2;lv<=c;lv++)
        for(int i=1;i<=m;i++)
            for(int j=1;j<i;j++)
                dp[i][lv]=min(dp[i][lv],dp[j][lv-1]+w[i][i]+w[j][i]);
    for(int i=1;i<=m;i++)ans=min(ans,dp[i][c]);
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>r>>c;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int i=0;i<(1<<n);i++)check(i);
    cout<<ans;
    return 0;
}
```

---

## 作者：JingchenBian (赞：0)

## 思路一——深搜
本题 DFS 的时间复杂度为 $O(C_m^c\times C_n^r)$。

加一些剪枝可能能玄学过。~~我没试过不确定。~~
## 思路二——DP 优化
在 DFS 时可以用动态规划求解，不必使用搜索。

下面是 DP 部分。
### 状态
$f[i][j]$ 表示前 $i$ 行选择 $j$ 列的最优答案。
### 边界
$f[i][1]=1$。
### 转移
$f[i][j]=\min{(f[i][j],f[k][j-1]+res)}$。

其中 $k\in [1,i-1]$，$res$ 表示选了第 $i$ 行且上一行是第 $k$ 行时对答案的贡献值。

---

## 作者：algo_h (赞：0)

本题解在枚举行的组合，利用动态规划优化列的组合的框架下，尝试给出一种尽量减少重复计算的方案。

首先借助递归以增序枚举行的组合。在此过程中，维护两个变量：

* 每列（$j$）取当前选中的所有行作为子矩阵，因元素上下相邻而产生的分数（对应代码中的 $\mathrm{dp}[0][j]$）
* 每两列（$i$，$j$）取当前选中的所有行作为子矩阵，因元素左右相邻而产生的分数（对应代码中的 $\mathrm{inc}[i][j]$）

以上两个变量可以在递归枚举的过程中进行增量更新，且可以在递归退回时进行回溯。行的组合方案固定后，列的组合方案便可从列数为 $1$ 开始，根据子矩阵最优必有子矩阵去除最后一列后在可选范围内仍然最优的性质，以子矩阵列数和最后一列在原矩阵中的下标构成的二元组为状态，利用动态规划进行优化，逐步扩展到列数为 $c$ 的最优解。完整代码实现如下：

```c++
#include <algorithm>
#include <iostream>

using namespace std;

int n, m, r, c;
int M[16][16];
int R[16];  // 保存已选中行的下标

int min_score = 0x3fffffff;
int dp[16][16];   // [i, j] -> 选择 i + 1 列，以 j 为终点的最小分数
int inc[16][16];  // [i, j] -> 在第 i 列后增加第 j 列，因元素左右相邻而增加的分数

// 已知 dp[0] 和 inc，优化列的选择方案
void solve()
{
  // 动态规划，从选择 1 列开始，逐步扩展到选择 c 列时的最优解
  for(int i = 1; i < c; ++i) {    // 从选择 i 列扩展到选择 i + 1 列
    for(int j = i; j < m; ++j) {  // 枚举当前列的选择
      // 因元素上下相邻而增加的分数固定为 dp[0][j]，只需优化左右相邻贡献的分数
      dp[i][j] = dp[i - 1][i - 1] + inc[i - 1][j];
      for(int k = i; k < j; ++k) dp[i][j] = min(dp[i][j], dp[i - 1][k] + inc[k][j]);
      dp[i][j] += dp[0][j];
    }
  }
  int score = *min_element(&dp[c - 1][c - 1], &dp[c - 1][m]);
  min_score = min(min_score, score);
}

// 递归枚举行的组合，将选中的行填入 R 中
// 当前选择子矩阵的第 i 行，在原矩阵中至少为第 rmin 行
void solve(int i, int rmin)
{
  if(i == r) return solve();
  R[i] = rmin;

  // 新增一行，更新 dp[0] 和 inc
  for(int j = 0; i && j < m; ++j) dp[0][j] += abs(M[R[i]][j] - M[R[i - 1]][j]);
  for(int j = 0; j < m - 1; ++j) {
    for(int k = j + 1; k < m; ++k) inc[j][k] += abs(M[R[i]][j] - M[R[i]][k]);
  }

  solve(i + 1, rmin + 1);

  // 回溯
  for(int j = 0; j < m - 1; ++j) {
    for(int k = j + 1; k < m; ++k) inc[j][k] -= abs(M[R[i]][j] - M[R[i]][k]);
  }
  for(int j = 0; i && j < m; ++j) dp[0][j] -= abs(M[R[i]][j] - M[R[i - 1]][j]);

  if(n - (rmin + 1) >= r - i) solve(i, rmin + 1);
}

int main()
{
  cin >> n >> m >> r >> c;
  for(int i = 0; i < n; ++i) {
    for(int j = 0; j < m; ++j) cin >> M[i][j];
  }
  solve(0, 0);
  cout << min_score << endl;
  return 0;
}
```

总的复杂度为 $O(\mathrm C_n^r(2 + c)m^2)$，主要体现为常数优化，相比对每个行的组合方案独立预处理的复杂度 $O(\mathrm C_n^r(r + c)m^2)$ 可减少约一半的计算量，实测用时 $126\ \mathrm{ms} / 166\ \mathrm{ms}$（包含大小样例）。此外，注意到转置矩阵并相应交换行、列参数不会改变答案，故如果这一操作可以带来运算次数的显著减少，也可以作为一种独立的优化方案。

---

参考用时来源：

* https://www.luogu.com.cn/record/197498062
* https://www.luogu.com.cn/record/197490552

---

## 作者：ty_mxzhn (赞：0)

好题，怎么现在才发现。

## 算法 1

直接暴力，复杂度 $O(C_n^rC_m^c)$。

不知道加入减枝是否能够通过。

## 算法 2

考虑先枚举行的选取情况，这一部分时间复杂度为 $O(C_{n}^r)$。

然后考虑使用动态规划求解列的选取方案。设计 $f_{i,j}$ 表示前 $i$ 列选了包含第 $i$ 列的 $j$ 列作为子矩阵。

转移的时候枚举上一次选的列，时间复杂度 $O(C_{n}^r m^3)$ 足以通过。

---


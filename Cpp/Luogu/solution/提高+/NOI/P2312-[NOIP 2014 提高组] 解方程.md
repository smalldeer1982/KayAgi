# [NOIP 2014 提高组] 解方程

## 题目背景

NOIP2014 提高组 D2T3

## 题目描述

已知多项式方程：

$$a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$$ 

求这个方程在 $[1,m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。

## 说明/提示

对于 $30\%$ 的数据：$0<n\le 2,|a_i|\le 100,a_n≠0,m<100$。  

对于 $50\%$ 的数据：$0<n\le 100,|a_i|\le 10^{100},a_n≠0,m<100$。  

对于 $70\%$ 的数据：$0<n\le 100,|a_i|\le 10^{10000},a_n≠0,m<10^4$。  

对于 $100\%$ 的数据：$0<n\le 100,|a_i|\le 10^{10000},a_n≠0,m<10^6$。

## 样例 #1

### 输入

```
2 10 
1
-2
1```

### 输出

```
1
1```

## 样例 #2

### 输入

```
2 10
2
-3
1```

### 输出

```
2
1
2```

## 样例 #3

### 输入

```
2 10
1
3
2```

### 输出

```
0```

# 题解

## 作者：Mingoal (赞：47)

首先要知道的是高次方程无求根公式，所以解这个方程没有公式，套公式只能过30%的数据

一种方法是枚举1到m的正整数，判断行不行。

若用高精度则只能能拿50分，那如何优化呢？取模！

设f(x)=a0+a1\*x+a2\*x^2+..+an\*x^n

若f(x)=0则f(x) mod p=0（p为任意非0实数）

随意试几个p，若f(x) mod p都是0，那x很有可能就是方程的解

但有几点要注意：

1。p最好是质数             2。p试得越多，p越大正确率越高，但也会慢一点点，根据实际情况自己调节

如果光是这样，理论上只能过70%的数据，可能是因为洛谷评测机快吧，这样也能过

我提供一个好一点的算法

注意到当f(x) mod p=0时f(x+k\*p) mod p=0（k为整数）

这样可以避免枚举很多无用的解

秦九韶算法我默认你们都会的，毕竟连读入优化都要用到这个

下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p=10007,q=100000007;
int n,m,i,cnt,ans[1000003],v[p],y;
ll a[103],b[103],aa,bb;
char c;
inline char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
    int x=0,fl=1;char ch=gc();
    for (;ch<48||ch>57;ch=gc())if(ch=='-')fl=-1;
    for (;48<=ch&&ch<=57;ch=gc())x=(x<<3)+(x<<1)+(ch^48);
    return x*fl;
}
inline bool f(int p,int M,ll *t){//把p代入方程，判断模M是否为0
    ll x=t[n];
    for (int i=n-1;i>=0;i--) x=(x*p+t[i])%M;
    return x==0;
}
inline void wri(int a){if(a<0)a=-a,putchar('-');if(a>=10)wri(a/10);putchar(a%10|48);}
inline void wln(int a){wri(a);puts("");}
int main(){
    n=read();m=read();
    for (i=0;i<=n;i++){//读入优化
        aa=0,bb=0;
        for (c=gc(),y=0;c<48 || 57<c;c=gc()) if (c=='-') y=1;
        for (;48<=c && c<=57;c=gc()) aa=((aa<<3)+(aa<<1)+(c^48))%p,bb=((bb<<3)+(bb<<1)+(c^48))%q;
        a[i]=y?p-aa:aa;
        b[i]=y?q-bb:bb;
    }
    for (i=0;i<p;i++)
        if (f(i,p,a)) v[i]=1;
    for (i=1;i<=m;i++)
        if (v[i%p] && f(i,q,b)) ans[cnt++]=i;
    wln(cnt);
    for (i=0;i<cnt;i++) wln(ans[i]);
}
```
我原来的程序好像被@中二攻子hack了，虽然我本机运行出来还是对的（可能我编译器出锅了），但是我还是发现了我程序的bug，已修改

---

## 作者：mcmahaoran (赞：21)

## 题外话
@[DX3906_ourstar](https://www.luogu.com.cn/user/1268524) （下文简称 DX）被本题卡了一下午，所以决定发篇题解纪念一下。

DX 的专栏[被禁了](https://www.luogu.com.cn/discuss/1043138)，所以用的小号。

## 题意

求下面这个 $1$ 元 $n$ 次方程的不大于 $m$ 正整数解：

$$a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$$ 

## 思考

可能很多同学看到这里就跃跃欲试了：直接套求根公式！

很遗憾，高次方程没有求根公式。

看来要另辟蹊径了。我们可以先对等号左边的式子进行化简、变形，看看能否有所帮助。为表述方便，我们将它简写为 $f(x)$，而我们的任务就是确保它为零。

不妨尝试提公因式，一次提出一个 $x$。则有：

$$\begin{aligned}
{} & f(x)\\
= & a_0+a_1x+a_2x^2+\cdots+a_nx^n\\
= & a_0+x(a_1+a_2x+a_3x^2+\cdots+a_nx^{n-1})\\
= & a_0+x(a_1+x(a_2+a_3x+a_4x^2\cdots+a_nx^{n-2}))\\
= & a_0+x(a_1+x(a_2+x(a_3+a_4x+a_5x^2+\cdots+a_nx^{n-3})))\\

= & \cdots\\

= & a_0+x(a_1+x(a_2+\cdots+x(a_{n-1}+a_nx)))\\
= & 0
\end{aligned}$$

**而这，就是我们解决本题的关键所在。**

既然 $f(x)=0$，那么就有下面的等式：

$$f(x) \bmod p=0$$

其中，$p$ 为一个很大的质数。显然，这个式子成立时，$f(x)$ 不一定为 $0$。它可以为 $2p,3p,4p\cdots$但感性认知一下，只要 $p$ 的取值恰当，那 $f(x)$ 就有极大的可能是 $0$，足够我们通过此题。

## 代码

接下来，我们就需要结合上面推出的等式，用代码来表示 $f(x) \bmod p$ 了。试看下面这段代码：

```
ll sum=0;//十年 OI 一场空，______见祖宗。 
for(int i=n;i>=1;--i){
	sum=((a[i]+sum)*x)%p;//也就是我们推出的式子。
} 
sum=(a[0]+sum)%p; 
```
其中，`ll` 即为 `long long`，`sum` 即为等号左边的运算结果。把这段代码封装到一个 `bool` 型的函数里，便可用于判断某个 $x$ 的值是否可令 $f(x) \bmod p$ 为 $0$，也就是像下面这样：


```
inline bool check(int x){
	/*这部分代码略*/
	return sum==0;
}
```

那么剩下的工作就非常简单了。$m$ 并不是一个非常大的数，其取值范围允许我们一一枚举 $x \in [1,m]$。我们只需要挨个判断，最后进行输出即可。

多说无益，直接上完整代码！


```
#include<iostream>
#include<queue>
#define ll long long
#define p 998244353377//学长说这是一个很棒的模数，不知道为甚，有巨佬能解答一下吗。 
using namespace std;

namespace OIfast{//一个快读快写的板子，曾被 @jerry1717 吐槽慢的一批 
	
	inline ll read(){
		int n=0,f=1;
		char c=getchar();
		while(c<'0'||c>'9'){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9')n=n*10+c-'0',c=getchar();
		return n*f;
	}
	
	inline void print(ll n){
		if(n<0)putchar('-'),n=-n;
		if(n>=10)print(n/10);
		putchar(n%10+'0');
		return ;
	}
	
	inline void write(ll n,char c){
		print(n),putchar(c);
		return ;
	}
	
}using namespace OIfast;

const int N=1e6+5;

int n,m;
ll a[N];
queue<ll> q;

inline bool check(int x){
	ll sum=0;
	for(int i=n;i>=1;--i)sum=((a[i]+sum)*x)%p;
	sum=(a[0]+sum)%p;
	return sum==0;
}

signed main(){
	n=read(),m=read();
	for(int i=0;i<=n;++i)a[i]=read();
	for(int x=1;x<=m;++x){//枚举解。 
		if(check(x))q.push(x);//成立，则入队。 
	}
	write(q.size(),'\n');//使用队列就无需单独记录解的数量。 
	while(!q.empty())write(q.front(),'\n'),q.pop();//最喜欢用队列了。 
	return 0;
}
```

然后就可以愉快地 AC 了——[吗？](https://www.luogu.com.cn/record/list?pid=P2312&user=1268524&status=14&page=1)

## 敲黑板——几个坑点

~~下面的抽象错误卡了 DX 一整个下午，真心希望同学们不要重蹈覆辙。~~

### 坑点一：`long long` 开了，但没完全开

注意 Ln10：`int n=0,f=1;`，这是 DX 快读打魔怔了，不看数据规模的结果。可以发现，这里的 $n$ 开的是 `int`，稳炸。

修改措施：把 `int` 改成 `ll` 即可。

### 坑点二：开了 `long long` 也并非不会炸

注意数据规模：$|a_i|\le10^{10000}$，再来看看快读里，开的不过是普通的 `long long`，稳炸。

我们又不可能再写一个高精吧……

但我们可以更充分地利用模数。我们可以把 Ln16 后面加上这句话：`n%=p`。这就确保了 $|n|\le998244353377$，不会再爆炸。

## 总结

本题恶狠狠地给 DX 上了一课。这同时也告诫大家注意细节，不要忽略任何一个可能出错的地方！

---

## 作者：_Calmly_ (赞：11)

# Solution

## 思路

首先枚举可能的解，然后判断是否是想要的解。为了判断，需要我们求方程左边的值，如果直接套公式的话，时间会不够~~QAQ~~。所以在求值之前，需要把方程左边通过提公因式化简：

$$
a_0 +a_1x +a_2x^2 + … + a_nx^n = a_0+x(a_1+x(a_2+…+x(a_{n-1}+a_nx)…))
$$

这时求值，就需要找规律，我是先把 $ans$ 赋值成 $a_n$ ，则 $ans = ans \times x +a_{n-j}$ ，其中的 $j$ 从 $1$ 累加至 $n$ 。当然也可以有其他观察方法。

伪代码：


```cpp
long long ans=a[n],num;
for(long long j=1;j<=n;j++) ans=ans*i+a[n-j];
if(ans==0) x[++num]=i;
```
如果仅仅这样，那就完了，因为在求值时， $ans$ 随时都可能超过长整型，如果用高精度只能拿50分。这时，使用取模，无需迟疑。

伪代码：

```cpp
long long ans=a[n],num;
for(long long j=1;j<=n;j++) ans=(ans*i%mod+a[n-j])%mod;
if(ans==0) x[++num]=i;
```

还要注意 $|a_i| \le 10^{10000}$ ，已经超过了长整型，所以读入必须手写，才可以取模。

伪代码：


```cpp
long long read(){
	char c=getchar();
	long long f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' and c<='9'){
		x=(x*10+c-'0')%mod;//一定要取模QAQ
		c=getchar();
	}
	return x*f;
}
```
##### ~~还有一点，读入 $a_i$ 时 $i$ 要从 $0$ 开始。QAQ~~

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

const int mod=1e9+9;
ll n,m,a[105],x[100005],num;

ll read(){
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' and c<='9'){
		x=(x*10+c-'0')%mod;
		c=getchar();
	}
	return x*f;
}

int main(){
	n=read();
	m=read();
	for(ll i=0;i<=n;i++) a[i]=read();
	for(ll i=1;i<=m;i++){
		ll ans=a[n];
		for(ll j=1;j<=n;j++) ans=(x*i%mod+a[n-j])%mod;
		if(ans==0) x[++num]=i;
	}
	cout<<num<<endl;
	for(ll i=1;i<=num;i++) cout<<x[i]<<endl;
	return 0;
}
```

# 完结撒花

---

## 作者：chu_yh (赞：9)

### 题目大意

**在 $1$ 到 $10^6$ 的范围内**解一个~~看起来很吓人~~的方程。

### 分析

> 对于 $100\%$ 的数据：$0<n\le 100,|a_i|\le 10^{10000},a_n≠0,m<10^6$ 。

相信你一眼就看到了 $|a_i|\le 10^{10000}$ 的离谱范围，但 $m$ 的范围却相对较小。这是，就会~~自然而然的~~想到枚举 $x$，来逗答案（四川方言，意为挨个试出答案）。

问题来了，怎么逗？

首先，我问先来表示出题干所给的函数值：
$$
f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_2 x^2+ a_1x+a_0
$$
显然，**若 $f(x)=0$，则 $x$ 为正确答案**。

我们来简化一下 $f(x)$：
$$
f(x)=a_n x^n+a_{n-1} x^{n-1}+\cdots+a_2 x^2 +a_1x+a_0\\
= (a_nx^{n-1}+a_{n-1}x^{n-2}+\cdots+a_2x+a_1)x+a_0\\
=((a_nx^{n-2}+a_{n-1}x^{n-3}+\cdots+a_2)x+a_1)x+a_0\\
\cdots\\\
=(\cdots((a_nx+a_{n-1})x+\cdots+a_2)x+a_1)x+a_0
$$

- 若 $f(x)\%mod=0$，那 $f(x)$ 就**有可能**为 $0$。
- 若 $f(x)\%mod=0$，$f(x)\%Mod=0$，且 $mod\ne Mod$，那 $f(x)$ 就**很有可能**为 $0$。

我们就可以用 $f(x)$ 分别对两个数（绝对不能有倍数关系，最好都是质数）取模，看是否为 $0$。于是，我们就能通过下面的代码来检验 $x$ 是否为正确答案：

```cpp
bool f(int x0,int M,long long *t){//m是模数，t是对应的a数组
	long long res=t[n];
	for(int i=n-1;i>=0;i--) res=(res*x0+t[i])%M;
	return res==0;
}
```

推到这里，我们就不得不面对 $|a_i|\le10^{10000}$ 的离谱数据。

数值这么大，自然不能用直接读入。我们可以对其进行哈希，利用快读的思想，就能对其进行取模：

```cpp
for(int i=0;i<=n;i++){//快读应该都会吧？
	long long x=0,X=0;	bool F=false;	char c=getchar();
	while(c<'0'||'9'<c){if(c=='-') F=true;c=getchar();}
	while('0'<=c&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0',X=(X<<3)+(X<<1)+c-'0';
		x%=mod,X%=Mod;//边乘边取模
		c=getchar();
	}
	a[i]=F?mod-x:x,A[i]=F?Mod-X:X;//这里一定要小心，不要直接拿负数取模！
}
```

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10007,Mod=1e9+7;
int n,m,cnt,ans[100001];
long long a[102],A[102];
bool vis[mod];

bool f(int x0,int M,long long *t){
	long long res=t[n];
	for(int i=n-1;i>=0;i--) res=(res*x0+t[i])%M;
	return res==0;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++){
		long long x=0,X=0;	bool F=false;	char c=getchar();
		while(c<'0'||'9'<c){if(c=='-') F=true;c=getchar();}
		while('0'<=c&&c<='9'){
			x=(x<<3)+(x<<1)+c-'0',X=(X<<3)+(X<<1)+c-'0';
			x%=mod,X%=Mod;
			c=getchar();
		}
		a[i]=F?mod-x:x,A[i]=F?Mod-X:X;
	}
	for(int i=0;i<mod;i++) if(f(i,mod,a)) vis[i]=true;
	for(int i=1;i<=m;i++) if(vis[i%mod]&&f(i,Mod,A)) ans[++cnt]=i;
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Thinking (赞：8)

注：为了叙述方便，把题中所给的关于x的多项式称为f(x)	
首先看到题目，便想到这样的思路：在[1,m]中枚举x，再判断f(x)是否为0即可，可惜，在这样的数据规模下，TLE是必然的。	
那么怎么办呢？我们注意到，若f(x)=0，则对于任意数p，f(x) mod p=0。因此，我们考虑在输入时就对一个大质数取模（数字越大，判断错误的概率越小），计算过程也是如此，于是就可以通过此题了。
可是，这样的复杂度依然较高，有TLE的风险，有没有O(m)的方法呢？	
对于一个x和模数p，我们设x=kp+b，则x≡b(mod p)，同时f(x)≡f(b)(mod p)。因此，我们得出如下结论：	
**在模p的情况下，f(x)=0的充分必要条件是f(x mod p)=0。**	
于是，我们可以在预处理时处理出f(0)~f(p-1),然后直接查表即可。	
但是，这样的话，为了预处理的效率，p不能很大，出错的风险会比较大，所以，要多选几个p防止出错。（我程序中选了3个，怕WA的话可以再多选几个）	
另外，这个方法还有一个好处：中间结果不会溢出。~~（和long long说再见）~~	
code:
```cpp
#include<cstdio>
#define GC() getchar()
#define PC(A) putchar(A)
#define rgi register int
#define p1
#define p2
#define p3
//p1,p2,p3的值自己选，在10000左右就可以了
inline void rd(int &a,int &b,int &c){
    char ch=GC();
    bool f=0;
    for(;ch<'0'||ch>'9';ch=GC())if(ch=='-')f=1;
    a=b=c=ch^48;
    for(ch=GC();ch>='0'&&ch<='9';ch=GC()){
        a=((a<<3)+(a<<1)+(ch^48))%p1;
        b=((b<<3)+(b<<1)+(ch^48))%p2;
        c=((c<<3)+(c<<1)+(ch^48))%p3;
    }
    if(f){a=-a;b=-b;c=-c;}
}
short buf[15];
inline void wt(int x){
    int l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    PC(x|48);
    while(l>=0)PC(buf[l--]|48);
    PC('\n');
}  //I/O优化
int a[105],b[105],c[105],s[1000050],n;  //a,b,c存系数，s存答案
bool f1[p1],f2[p2],f3[p3];
inline bool check(int x,int p,int *a){
    int s=a[n];
    for(rgi i=n-1;i>=0;i--)s=(s*x+a[i])%p;
    return !s;
}  //检查f(x)在模p意义下是否等于0
inline void work(int p,bool *f,int *a){
    f[0]=!a[0];
    for(rgi i=1;i<p;i++)f[i]=check(i,p,a);
}  //预处理
int main(){
    int m,ans=0;
    scanf("%d%d",&n,&m);
    for(rgi i=0;i<=n;i++)rd(a[i],b[i],c[i]);
    work(p1,f1,a);
    work(p2,f2,b);
    work(p3,f3,c);
    for(rgi i=0;i<=m;i++)if(f1[i%p1]&&f2[i%p2]&&f3[i%p3])s[ans++]=i;
    wt(ans);
    for(rgi i=0;i<ans;i++)wt(s[i]);
    return 0;
}
```

---

## 作者：Bearbrother18 (赞：7)

## 题意


---


 ![](https://cdn.luogu.com.cn/upload/image_hosting/kqfae0ov.png)

第一眼看见这串方程时是不是有点头晕。这里简单化简一下就可以得出下面的式子。

$$
a_0+x(a_1+x(a_2+…+x(a_{n-1}+a_nx)…))
$$ 
 
## 思路


---


通过公式我们不难发现这么长一串可以用一个循环来实现。

但是值得注意的是这个值得注意的需要注意的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/vtywmqvk.png)

$10^{10000}$。这下直接让爆搜的梦想破灭了。有人会说用高精度不就行了。这就说的很对，恭喜你成功拿到了五十分。如果想要剩下的五十分，就要用哈希来解决了。

于是就有了下面的代码。
 
```cpp
for(ll i=1; i<=m; i++){ 
		ll x=a[n];
		for(ll j=1; j<=n; j++) {
		    x=(x*i+a[n-j]);
		}
		if(x==0){
		    ans[++num]=i;
		} 
	}
```

可是我们依然发现，还是会炸。

怎么办。

在讲下面的知识前先讲一下取模。

设一个数为 $t$。如果 $t=0$ 则有 $t\bmod p=0$。但是如果 $t\bmod p=0$，则 $t=0$ 不一定成立。

于是我们可以将 $p$ 取一个较大的质数来防炸。具体的不多阐述，不懂的点击[这里](https://oi-wiki.org/string/hash/)。给出核心代码：

```cpp
for(ll i=1; i<=m; i++){
		ll x=a[n];
		for(ll j=1; j<=n; j++) {
		    x=(x*i%p+a[n-j])%p; //p=1e9+7
		}
		if(x==0){
		    ans[++num]=i;
		} 
	}
```

光是这样还不够。在快读中预先处理每个数让每个数先模一个 $p$ 才能算大功告成。

```cpp
ll read(){
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-') {
      f=-1;
    }
		c=getchar();
	}
	while(c>='0' and c<='9'){
		x=(x*10+c-'0')%p;
		c=getchar();
	}
	return x*f;
}
```

## 代码


---

这里给出完整代码，~~马蜂较稠不喜就喷~~。

```cpp
#include<bits/stdc++.h>//万能头

using namespace std;

#define ll long long//宏定义

const int p=1e9+7;//p取"较大"的质数
ll n,m,a[105],ans[100005],num;

ll read(){ //快读
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-'){
      f=-1;
    } 
		c=getchar();
	}
	while(c>='0' and c<='9'){
		x=(x*10+c-'0')%p;//预处理每个数
		c=getchar();
	}
	return x*f;
}

int main(){
	cin >> n >> m;
	for(ll i=0; i<=n; i++){
	    a[i]=read();
	} 
	for(ll i=1; i<=m; i++){
		ll x=a[n];
		for(ll j=1; j<=n; j++) {
		    x=(x*i%p+a[n-j])%p;//mod一个p防炸
		}
		if(x==0){
		    ans[++num]=i;
		} 
	}
	cout << num << endl;
	for(ll i=1; i<=num; i++) {
	    cout << ans[i] << endl;
	}

	return 0;//好习惯
}
```

---

## 作者：FREEH (赞：6)

### 【题目/题目大意】
- ![题目/题目大意](https://cdn.luogu.com.cn/upload/pic/27512.png)

### 【解题思路】
- 30%解法：暴力枚举
- 50%解法：在暴力枚举的基础上加一个高精度


------------

# 100%解法：
- 本题的精髓在于哈希思想：取mod。
- 如果f(x)=0，则f(x)%P=0（但注意这不是逆定理）。
- 所以只要用类似于快速读入的方法，把系数读入的同时%P，最后暴力枚举解x，暴力判断即可（也就是类似于各位大佬所说的“秦九韶公式”）。
- 但是当f(x)%P=0时，f(x)不一定等于0（如f(x)=P）。为了减少出现这种情况导致出错的概率，有几种解决方案：
    1. 使P是素数
    - 使P很大
    - 多找几个P。
- 通过计算，一个P的时间复杂度已经接近$10^8$，所以方法3十分危险，只能找多一两个素数。所以要在WA和TLE之间艰难选择……
- 与其这样，不如找一个好一点的素数，如$10^8+9$之类的。
- 但安全起见，还是多找几个素数吧。

### 【解题反思】

- 当遇到读入的数很大的题时，就要想到mod一个数。

### 【参考程序】
```cpp
#include<cstdio>
#define P 1000000009
typedef long long LL;
#define int LL
int n,m,sum;
int a[105],Ans[1000005];
int Read()
{
    char ch;
    int fh=1;
    scanf("%c",&ch);
    while (ch<'0'||ch>'9')
    {
        if (ch=='-') fh=-1;
        scanf("%c",&ch);
    }
    int num=0;
    while (ch>='0'&&ch<='9')
    {
        num=num*10+ch-'0';
        num%=P;
        scanf("%c",&ch);
    }
    num*=fh;
    return num;
}
signed main()
{
    scanf("%d%d",&n,&m);
    for (int i=0;i<=n;i++)
    {
        a[i]=Read();
    }
    
    for (int x=1;x<=m;x++)
    {
        int ans=0;
        for (int i=n;i>=1;i--)
        {
            ans=((ans+a[i])*x)%P;
        }
        if ((ans+a[0])%P==0)
        {
            Ans[++sum]=x;
        }
    }
    printf("%d\n",sum);
    for (int i=1;i<=sum;i++)
        printf("%d\n",Ans[i]);
    return 0;
}

```

---

## 作者：DX3906_ourstar (赞：4)

本篇题解不再给出完整代码，想要的同学可以看[这篇](https://www.luogu.com.cn/article/jvctltlo)，里面详细讲解了整道题的思路和代码可能出现的坑点。

回到这里。令等号左边的式子为 $f(x)$，则当 $x \in [1,m]$ 为解时，有 $f(x)=0$，也就必然有 $f(x) \bmod p=0$，其中 $p$ 为我们选取的模数。

反过来，当 $f(x) \bmod p=0$ 时，不一定有 $f(x)=0$。我们只有尽可能地选取合适的模数，来降低出错的概率。这就有几分玄学的意味了——我们得祈祷出题人不卡我们使用的模数！

那么，存不存在一种方式，使得时间复杂度不大幅提升的同时，正确率大幅提高呢？

有的，这就是我们今天要介绍的另一种写法——**双模数**。

首先，我们得明白为什么选取单一模数容易被卡。原因在于，出题人可以很方便地令 $f(x)=np$，其中 $n \in N$。在这种情况下，$f(x) \bmod p=0$，但 $f(x) \neq 0$。

接下来，我们考虑如何改善这种状况。他出题人能卡一个模数，那两个呢？三个？四个……只要我选取的多个模数有一个没有被卡，我就可以确保正确。感性认知一下，这样做的正确率要远高于单一模数。

然而，模数太多也会有一个问题——**常数大了**。所以，在解决实际问题时，我们往往选取两个模数而非更多，这样既可以提高正确率，又不至于让常数复杂度太大。

具体地，我们应当选取两个不同的模数 $p1,p2$，检查某一 $x$ 是否为解时，应当检查 $f(x) \bmod p1$ 和 $f(x) \bmod p2$ 是否同时为 $0$。

---

## 作者：JayJessy (赞：4)

~~难道有人看题解不点赞的吗？~~

别看这道题是蓝题，其实~~很简单~~。  
当我下滑看到数据范围，先是一高兴。欸！$O(nm)$ 能过！  
紧接着便泄了气，救命啊，$|a_i|\le 10^{10000}$！！  
随后便写了 $30$ 分暴力……  
然后就默默地点开了题解……
## 题目解析
- 我们先解决 $a_i$ 很大的问题，可以使用~~阴间版~~快读，使用一个 $mod=998244353$ 来取模。不过，保险起见，也可以用两个甚至更多模数。
```cpp
ll read() {
	ll f=1,x=0;
	char c=getchar();
	while(c<'0' || c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9') {
		x=(x*10+c-'0')%mod;
		c=getchar();
	}
	return x*f;
}
```
- 接下来我们枚举 $x$，算出 $a_0+a_1x+a_2x^2+\cdots+a_nx^n$ 的值。  
这个过程我们可以使用[秦九韶算法](https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196)。
```cpp
ll sum=0;
for(ll i=n; i>=1; i--) sum=(sum+a[i])*x%mod;
sum=(sum+a[0])%mod;
if(!sum) ans[++cnt]=x;
```
好啦，这道题就这么多，下面是——
## AC 代码
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=110,mod=998244353;
ll n,m,cnt,a[N],ans[N];
ll read() {
	ll f=1,x=0;
	char c=getchar();
	while(c<'0' || c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9') {
		x=(x*10+c-'0')%mod;
		c=getchar();
	}
	return x*f;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	n=read(),m=read();
	for(ll i=0; i<=n; i++) a[i]=read();
	for(ll x=1; x<=m; x++) {
		ll sum=0;
		for(ll i=n; i>=1; i--) sum=(sum+a[i])*x%mod;
		sum=(sum+a[0])%mod;
		if(!sum) ans[++cnt]=x;
	}
	cout<<cnt<<"\n";
	for(ll i=1; i<=cnt; i++) cout<<ans[i]<<"\n";
	return 0;
}
```
完结撒花~~

---

## 作者：diqiuyi (赞：3)

我们考虑先枚举 $x$，并判断它是否是一个解。

显然 $100$ 次方程没有求根公式，且 $|a_i|$ 很大，高精度运算的复杂度无法接受。

所以我们考虑哈希，显然 $f(i)=0$ 则 $f(i)\equiv 0 \pmod p$，我们考虑只算出 $f(i)\bmod p$ 的结果。

在随机数据下我们被卡的概率只有 $\frac{m}{p}$。为了防止被卡，$p$ 取一个质数会更保险一些。

此时我们只要知道 $a_i\bmod p$ 和 $x^i \bmod p$ 即可，前者可以写个快读状物，后者可以递推计算。时间复杂度为 $O(nm)$，已经可以通过。

但是我们可以做得更好。

注意到在模 $p$ 意义下，$f(i)$ 和 $f(i+kp)$ 的值是相同的。所以我们考虑取 $c$ 个质数 $p_i$，然后对于每个 $p_i$，我们找到 $f(i)\equiv 0\pmod {p_i}$ 的所有根（显然不超过 $n$ 个），然后枚举 $x$ 时可以先判断它模 $p_i$ 是否合法。我们不妨让 $p_i$ 大于 $n$。记 $\prod p_i=B$，这样我们的复杂度是 $O(m+(\sum p_i+c\log a_i)n)$。显然 $p_i$ 的值要尽可能接近，所以时间复杂度为 $O(m+cn(\log a_i+p_i))$，所以把 $p_i$ 的值取的和 $\log a_i$ 差不多大就对完了。出现错误的概率是 $O(\frac{m}{B})$。但是注意如果 $p_i$ 取得太小容易被卡。我取了 $3$ 个 $10^4$ 左右的质数就过了。

#### code
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define uint unsigned int
#define pii pair<int,int>
#define io ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
const int p[3]={10007,10009,10039};
int n,m,ans[105],cnt,b[105];
string a[105];
bitset<11005> vis[3];
int main(){
	io;
	cin>>n>>m;
	for(int i=0;i<=n;i++) cin>>a[i];
	for(int i=0;i<3;i++){
		for(int j=0;j<=n;j++){
			b[j]=0;bool op=0;
			for(char k:a[j])
				if(k=='-') op=1;
				else b[j]=(b[j]*10+k-'0')%p[i];
			if(op) b[j]=-b[j];
		}
		for(int j=0;j<p[i];j++){
			int res=0;
			for(int k=0,pw=1;k<=n;k++)
				res=(res+b[k]*pw)%p[i],pw=pw*j%p[i];
			vis[i][j]=!res;
		}
	}
	for(int i=1;i<=m;i++){
		bool flg=1;
		for(int j=0;j<3&&flg;j++)
			if(!vis[j][i%p[j]])
				flg=0;
		if(flg) ans[++cnt]=i;
	}
	cout<<cnt<<'\n';
	for(int i=1;i<=cnt;i++)
		cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：xfrvq (赞：3)

摘要：本文介绍了 $O(nm)$ 正解，秦九韶公式，$O\left(\dfrac{n^2m}C+nC\right)$ 更优做法。

---

题目看起来无处下手。但注意到高次方程没有求根公式，且题目只求整数解。我们不妨考虑**将 $x=1,\cdots,m$ 一一代入方程验证是否是解。**

此时又有一个问题：$a_i\le10^{10000},m^n\le10^{600}$。都是天文数字，高精度计算会超时。于是考虑**哈希**，设一个大数 $P$，求出原式模 $P$ 的值。**原式为 $0$ 的必要条件是原式模 $P$ 余数为 $0$**。

于是我们只需要用到 $a_0\bmod P,\cdots,a_n\bmod P$ 和 $x\bmod P,\cdots,x^n\bmod P$ 的值就可以计算了。前者直接在读入时处理，后者可以对每个 $x$ 递推一遍。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 1e2 + 5,M = 1e6 + 5;
const ll P = 1e9 + 9; // 一个大质数（这里不能取 1e9 + 7 会被卡）

int n,m,tot;
ll a[N],b[N];
bool ans[M];

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 0;i <= n;++i){
		char c = getchar();
		bool flg = 0;
		for(;!isdigit(c);c = getchar()) flg |= c == '-';
		for(;isdigit(c);c = getchar()) a[i] = (a[i] * 10 + (c - '0')) % P; // 读入时预处理取模后结果
		if(flg) a[i] = P - a[i];
	}
	for(int i = 0;i <= m;++i){
		b[0] = 1;
		for(int j = 1;j <= n;++j) b[j] = b[j - 1] * i % P; // 计算 b[j] = i 的 j 次方结果
		ll f = 0;
		for(int j = 0;j <= n;++j) (f += a[j] * b[j] % P) %= P; // 计算原多项式取模结果
		if(f == 0) ans[i] = 1,++tot; // 存入答案
	}
	printf("%d\n",tot);
	for(int i = 1;i <= m;++i) if(ans[i]) printf("%d\n",i);
	return 0;
}
```

## Bonus：秦九韶公式

我们发现预处理 $x,x^2,\cdots,x^n$ 的值有点鸡肋，考虑优化多项式求值的方法。

$$
\begin{aligned}
&a_0+a_1x+a_2x^2+a_3x^3+\cdots+a_nx^n\\
=&a_0+x(a_1+a_2x+a_3x^2+\cdots+a_nx^{n-1})\\
=&a_0+x(a_1+x(a_2+a_3x+\cdots+a_nx^{n-2}))\\
&\cdots\\
=&a_0+x(a_1+x(a_2+x(a_3+\cdots+a_nx)))
\end{aligned}
$$

于是我们从括号内往外求和：倒序枚举 $i=n,\cdots,0$，维护当前和 $s$。初始 $s=0$，之后不断 $s\gets s\times x+a_i$ 即可。

更改后的求和部分代码：

```cpp
for(int i = 0;i <= m;++i){
	ll f = 0;
	for(int j = n;j >= 0;--j) f = (f * i + a[j]) % P;
	if(f == 0) ans[i] = 1,++tot;
}
```

## Bonus：更优复杂度做法

我们不再枚举 $1,\cdots,m$ 代入，而是另设一个数 $C$，**代入 $0,\cdots,C-1$ 计算多项式模 $C$ 的结果，设其为 $f_0,\cdots,f_{C-1}$**。

注意到一件事：代入 $x=1,C+1$ 时，在模 $C$ 意义下多项式值相同。原因很简单：$1\equiv C+1\pmod C$。由于 $1\sim C$ 都已处理，**$[1,m]$ 每个数在模 $C$ 意义下多项式值 $g_i$ 都已解出来了：$g_i=f_{i\bmod C}$**。

这时我们再枚举 $i=1,\cdots,m$，如果 $g_i\ne 0$，那么 $i$ 作为根的可能就已经被排除了，我们再验证那些未被排除的。

这样做的复杂度是多少呢？

注意到方程根至多有 $n$ 个。故 $f_0,\cdots,f_C$ 中至多有 $n$ 个 $f_i=0$。我们最后只验证了 $O\left(\dfrac{nm}C\right)$ 个数，总复杂度 $O\left(\dfrac{n^2m}C+Cn\right)$。

将 $C$ 取到 $O(n^2)$ 级别，该算法优于 $O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

const int N = 1e2 + 5,M = 1e6 + 5;
const ll m1 = 1e9 + 9,m2 = 99929; // m1 是刚刚的 P, m2 是 C 

int n,m,tot;
ll a1[N],a2[N]; // a1: a 数组模 m1 意义下结果，a2：模 m2 意义下结果 
bool vis[m2],ans[M];

int main(){
	scanf("%d%d",&n,&m);
	for(int i = 0;i <= n;++i){
		char c = getchar(); bool f = 0;
		for(;!isdigit(c);c = getchar()) f |= c == '-';
		for(;isdigit(c);c = getchar())
			a1[i] = (a1[i] * 10 + (c - '0')) % m1,
			a2[i] = (a2[i] * 10 + (c - '0')) % m2;
		if(f) a1[i] = -a1[i],a2[i] = -a2[i];
	}
	for(int i = 0;i < m2;++i){ // 枚举 0 ~ C-1 
		ll k = 0;
		for(int j = n;j >= 0;--j) k = (k * i + a2[j]) % m2;
		vis[i] = k; // vis[i]: 模 C 余 i 的数是否被排除 
	}
	for(int i = 0;i <= m;++i) if(!vis[i % m2]){ // 没排除的数再暴力验证 
		ll f = 0;
		for(int j = n;j >= 0;--j) f = (f * i + a1[j]) % m1;
		if(f == 0) ans[i] = 1,++tot;
	}
	printf("%d\n",tot);
	for(int i = 1;i <= m;++i) if(ans[i]) printf("%d\n",i);
	return 0;
}
```

---

## 作者：CaiZi (赞：2)

首先我们知道高于 $4$ 次的方程没有求根公式，因此本题显然只能枚举所有在范围内的整数解。但是我们现在如果直接这么做，然后再暴力计算 $x^n$，时间复杂度是 $O(n^2m)$ 的，无法通过。

考虑使用秦九韶公式：
$$\begin{aligned}\sum_{i=0}^na_ix^i&=a_0+x\sum_{i=1}^na_ix^{i-1}\\&=a_0+x(a_1+x\sum_{i=2}^{n}a_ix^{i-2})\\&=a_0+x(a_1+x(a_2+x\sum_{i=3}^{n}a_ix^{i-3}))\\&=a_0+x(a_1+\dots+x(a_{n-2}+x(a_{n-1}+xa_n))\dots)\end{aligned}$$
计算时，我们记录一个值初始为 $a_n$，从括号最里面（即 $a_{n-1}$）开始算，然后不断将这个值乘 $x$，再加 $a_i$。一直加到 $a_0$ 即可。

但是这样还不够，我们发现 $a_i$ 非常大，而加上高精度的时间复杂度后，无法通过本题。我们考虑使用类似于哈希的思想，将这个方程左边对一个数取模。那么根据取模的性质，可以将每个 $a_i$ 都模上这个数（注意需要边读入边取模），并且在计算过程中可以不断对算出来的那个值模上这个数，这样就可以使用 `long long` 存储左边的多项式的值。

除此之外，还有一些提升正确性的方法：
- 使用较大的数作为模数。
- 使用质数作为模数。
- 使用多个模数，一个解只有在每个模数下都满足条件才可以算作合法。

这里使用单个模数，模数为 $10^9+7$，如果为了保险可以多用几个，例如 $998244353,10007$ 等。

时间复杂度 $O(nm)$。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int n,m,a[101],b;
char s;
bool t;
vector<int>g;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++){
		t=false;
		s=getchar();
		while(!isdigit(s)){
			if(s=='-'){
				t=true;
			}
			s=getchar();
		}
		while(isdigit(s)){
			a[i]=(a[i]*10+s-'0')%mod;
			s=getchar();
		}
		if(t){
			a[i]=mod-a[i];
		}
	}
	for(int i=1;i<=m;i++){
		b=0;
		for(int j=n;j>=1;j--){
			b=(a[j]+b)*i%mod;
		}
		b=(b+a[0])%mod;
		if(b==0){
			g.push_back(i);
		}
	}
	printf("%d\n",g.size());
	for(int i:g){
		printf("%d\n",i);
	}
	return 0;
}
```

---

## 作者：dasxxx (赞：2)

## 第三题 解方程 （equation）
### 题目概括
		给出以下方程：

$a_0+a_1*x^1+a_2*x^2+a_3*x^3+...a_n*x^n=0$

		现给出所有a，求在1到m里面有多少解。
### 解析
- **一道非常巧妙的数学题**。

- 首先根据**秦九韶公式**（不懂请自行百度），可以将原方程化为

$a_0+x*(a_1+x*(a_2+....x*(a_{n-1}+x*a_n)))=0$


- 由于该方程里**只有加法与乘法**，可以用一点哈希的思想，对**每一次加乘操作都进行取mo**（-1s）。若最终结果等于0，则中间不管怎么取mo都会为0。

- 所以这里可以**枚举1到m的每一个数**，对其进行操作，若算出的结果为0则可能为解。

- 当然这里**不排除某些数取mo为0但不为解的情况**（除非你取的数字非常玄妙），也为了优化整个算法的时间复杂度，可以考虑使用多个质数进行取mo。

- **若对某个数x操作用质数p取mo后其余数不等于0，那么所有x+k*p一定都不是解，这里就可以将大部分无用数字筛掉，再递进操作。**

- **若x为方程的解，对任意质数取mo一定都为0。所以不论质数有多少多都一定会留在答案中（然而为了时间更短所取的每个质数都要非常非常非常玄妙！！！！！）**

- 还需要注意的是本题时间只有1s，所以需要尽量优化，**快速读入**是必不可少的。

### ac程序
```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
#define int long long
const int MOD=1000000007ll;
const int MOD1=233333ll;
int n,m,ans[1000010];
int a[101][2],sum,sum1,flag;
char c;
void read(int ord){
	sum=0ll,flag=1ll,sum1=0ll;
	c=getchar();
	while (c<'0'||c>'9'){
		if(c=='-') flag=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		sum=((sum*10)+c-'0')%MOD;
		sum1=((sum1*10)+c-'0')%MOD1;
		c=getchar();
	}
	a[ord][0]=sum*flag;
	a[ord][1]=sum1*flag;
}
inline bool check(int k,int mod,int oo){
	sum=0ll;
	for(int i=n;i>=1;i--)
		sum=((a[i][oo]+sum)*k)%mod;
	sum=(sum+a[0][oo])%mod;
	return (sum==0);
}
signed main(){
	#ifndef LOCAL
	freopen("equation.in","r",stdin);
	freopen("equation.out","w",stdout);
	#endif
	scanf("%d%d",&n,&m);
	register int i,cnt=0,j;
	for (i=0;i<=n;i++)
		read(i);
	for(i=1;i<=MOD1;i++){
		if(check(i,MOD1,1)){
			for (j=i;j<=m;j+=MOD1)
				if (check(j,MOD,0))
					ans[++cnt]=j;
		}
	}
	sort(ans+1,ans+cnt+1);
	int t=unique(ans+1,ans+cnt+1)-ans;
	printf("%d\n",t-1);
	for(i=1;i<t;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：wsm52 (赞：1)

# 前言
这道题虽然算法标签有**高精度**，但实际上高精度也拿不了满分，需要一点技巧。
# 思路
首先，在 $\lbrack1,m\rbrack$ 中，我们可以一个一个代入计算，但这样时间复杂度是 $O(n^2m)$，而且 $\lvert a_i\rvert \le 10^{10000}$，也是一大难题。这时我们需要引入一个模数 $p$。对于 $ax \bmod p$ （$a$ 可理解为 $a_i$，$x$ 可理解为 $x^i$）有以下推导过程。

$\begin{aligned}
  ax\bmod p &= (\lfloor\frac{a}{p}\rfloor\times p+a-\lfloor\frac{a}{p}\rfloor\times p)\times x\bmod p \\
&=(\lfloor\frac{a}{p}\rfloor\times p \bmod p+a\bmod p-\lfloor\frac{a}{p}\rfloor\times p \bmod p)\times x \bmod p \\
&=(a \bmod p)\times x \bmod p
\end{aligned}$

**注意**：此方法是运用了哈希，有可能会被卡，概率是 $\frac{m}{p}$，所以 $p$ 要尽量取大一点，而且是个质数（作者取了 $10^9+7$）。

知道 $a_i$ 如何化简后，我们还需要一个优化技巧——**秦九韶公式**。

$\begin{aligned}
\sum_{i=0}^{n}a_i x^i &= a_0+\sum_{i=1}^{n}a_i x^i \\
&=a_0+x(a_1+\sum_{i=2}^{n}a_i x^{i-1})\\
&=a_0+x(a_1+x(a_2+\sum_{i=3}^{n}a_i x^{i-2}))\\
&=a_0+x(a_1+x(a_2+\dots +x(a_{n-1}+xa_n))\dots)
\end{aligned}$

知道了这两个优化技巧，就可以把时间复杂度压到 $O(nm)$ 了。
# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;//不开long long见祖宗
const int mod=1000000007;
int a[110],n,m;
vector<int> p;
LL read(){//运用快读来进行取模
	LL sum=0,fg=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') fg=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		sum=(sum*10+(c-'0'))%mod;
		c=getchar();
	}
	return sum*fg;
}
bool check(int x){//秦九韶公式
	LL sum=0;
	for(int i=n;i>0;i--) sum=(LL)((a[i]+sum)*x)%mod;
	sum=(a[0]+sum)%mod;
	return !sum;
}
int main(){
	n=read();
	m=read();
	for(int i=0;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++) if(check(i)) p.push_back(i);
	printf("%d\n",p.size());
	for(auto i:p) printf("%d\n",i);
	return 0;
}
```
# 结尾
此题 $O(nm)$ 的复杂度比较蓟县了，还有更好的优化方法，可以把复杂度压到 $O(\frac{n^2m}{c}+nc)$（$c$ 为质数个数），但本蒟蒻不会 qwq。

---

## 作者：JXR_Kalcium (赞：0)

## 题目大意

给定 $a_0,a_1,\cdots,a_n$，求 $a_0+a_1x+a_2x^2+\cdots+a_nx^n=0$ 在 $[1,m]$ 范围内的解，数据范围 $|a_i|\le 10^{10000}$。

## 解题思路

注意到这个方程是**秦九韶公式**的模板（秦九韶公式可专门解决这类问题），过程如下：

$$
\begin{aligned}a_0+a_1x+a_2x^2+\cdots+a_nx^n&=0\\a_0+x(a_1+a_2x+a_3x^2+\cdots+a_nx^{n-1})&=0\\a_0+x\left(a_1+x(a_2+a_3x+a_4x^2\cdots+a_nx^{n-2})\right)&=0\\\cdots\\a_0+x\left(a_1+x\left(\cdots(a_{n-1}+a_nx)\right)\right)&=0\end{aligned}
$$

这时只需要设 $f_1=a_{n-1}+a_nx$，即可得到 $f_i=f_{i-1}x+a_{n-i}$，最后 $f_n$ 即为结果，这样可拿 $50$ 分。因为数据范围中有个~~很恶心的~~ $10^{10000}$，高精度太麻烦，于是考虑哈希（因为我们并不关心 $f_n$ 到底是什么数，只关心它是不是 $0$），读入和计算 $f_i$ 的时候都模上一个大质数（最好是 $10^9+7$）即可（读入时的模可用快读）。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

const ll mod=1e9+7;

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=((x<<1)+(x<<3)+c-48)%mod, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,m,a[101],f[101],ans[1000001],cnt;

int main()
{
    n=read(); m=read();
    for(R int i=0; i<=n; ++i) a[i]=read();

    for(R int i=1; i<=m; ++i)
    {
        f[1]=(a[n]*i+a[n-1])%mod;
        for(R int j=2; j<=n; ++j) f[j]=(f[j-1]*i+a[n-j])%mod;
        if(!f[n]) ans[++cnt]=i;
    }

    write(cnt); endl;
    for(int i=1; i<=cnt; ++i) write(ans[i]), endl;
    return 0;
}
```

---

## 作者：lihl (赞：0)

### 题意

求满足使关于 $x$ 的方程 $f(x) = \sum_{i=0}^n a_i x^i = 0$ 成立的不大于 $m$ 的解。保证系数 $a_i$ 非零。
### 分析

首先，看到如上方程形式考虑秦九韶。

注意到数据范围 $a_i$ 是 $10^{10000}$ 范围的，为了维护需要高精度对一个质数 $p$ 取模，可以快读维护。

于是 $x$ 是原方程的解的必要条件是 $f(x)\equiv 0 \pmod p$。由于系数非常大，可以多取 $p$ 或者取大 $p$ 即可。多试两到三个 $x$ 或取大 $p$ 来避免错误。时间复杂度约为 $O(nm)$，常数略大。

### Note
- 2025.1.22 感谢 @[_xm_](https://www.luogu.com.cn/user/821481) 勘误。
- 2025.1.22 勘误。

---


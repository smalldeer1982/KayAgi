# [NOI2014] 随机数生成器

## 题目描述

小 H 最近在研究随机算法。随机算法往往需要通过调用随机数生成函数（例如 Pascal 中的 random 和 C/C++中的 rand）来获得随机性。事实上，随机数生成函数也并不是真正的“随机”，其一般都是利用某个算法计算得来的。

比如，下面这个二次多项式递推算法就是一个常用算法：

算法选定非负整数 $x_0,a,b,c,d$ 作为随机种子，并采用如下递推公式进行计算。

对于任意 $i ≥ 1,x_i=(a \times x_{i-1}^2+b \times x_{i-1}+c)\mod d$ 这样可以得到一个任意长度的非负整数数列$\{x_i\},i \ge 1$，一般来说，我们认为这个数列是随机的。

利用随机序列 ${xi},i≥1$，我们还可以采用如下算法来产生一个 $1$ 到 $K$ 的随机排列$ \{ Ti \},i=1 ... k$：

1. 初始设 $T$ 为 $1$ 到 $K$ 的递增序列；
2. 对 $T$ 进行 $K$ 次交换，第 $i$ 次交换，交换 $T_i$ 和 $T_{(x_i \bmod i) + 1}$ 的值。

此外，小 H 在这 $K$ 次交换的基础上，又额外进行了 $Q$ 次交换操作，对于第i 次额外交换，小 H 会选定两个下标 $u_i$ 和 $v_i$，并交换 $T_{u_i}$ 和 $T_{v_i}$ 的值。

为了检验这个随机排列生成算法的实用性，小 H 设计了如下问题：

小 H 有一个 $N$ 行 $M$ 列的棋盘，她首先按照上述过程，通过 $N \times M + Q$ 次交换操作，生成了一个 $1\sim N \times M$ 的随机排列 $\{Ti\},i=1 ... N \times M$，然后将这 $N \times M$ 个数逐行逐列依次填入这个棋盘：也就是第 $i$ 行第 $j$ 列的格子上所填入的数应为 $ T_{(i-1) \times M+j} $。

接着小 H 希望从棋盘的左上角，也就是第一行第一列的格子出发，每次向右走或者向下走，在不走出棋盘的前提下，走到棋盘的右下角，也就是第 $N$ 行第 $M$ 列的格子。

小 H 把所经过格子上的数字都记录了下来，并从小到大排序，这样，对于任何一条合法的移动路径，小 H 都可以得到一个长度为 $N + M - 1$ 的升序序列，我们称之为路径序列。

小 H 想知道，她可能得到的字典序最小的路径序列应该是怎样的呢？

## 说明/提示

对于样例 1，根据输入的随机种子，小 H 所得到的前 12 个随机数xi为：

9 5 30 11 64 42 36 22 1 9 5 30

根据这 12 个随机数，小 H 在进行初始的 12 次交换操作后得到的排列为：

6 9 1 4 5 11 12 2 7 10 3 8

在进行额外的 3 次交换操作之后，小 H 得到的最终的随机排列为：

12 9 1 7 5 11 6 2 4 10 3 8


```cpp
12 9 1 7 
5 11 6 2 
4 10 3 8
```

最优路径依次经过的数字为 ：12-9-1-6-28。

![](https://cdn.luogu.com.cn/upload/pic/2590.png)


## 样例 #1

### 输入

```
1 3 5 1 71 
3 4 3 
1 7 
9 9 
4 9 ```

### 输出

```
1 2 6 8 9 12 ```

## 样例 #2

### 输入

```
654321 209 111 23 70000001 
10 10 0 ```

### 输出

```
1 3 7 10 14 15 16 21 23 30 44 52 55 70 72 88 94 95 97```

## 样例 #3

### 输入

```
123456 137 701 101 10000007 
20 20 0 ```

### 输出

```
1 10 12 14 16 26 32 38 44 46 61 81 84 101 126 128 135 140 152 156 201 206 237 242 243 253 259 269 278 279 291 298 338 345 347 352 354 383 395 
```

# 题解

## 作者：ImmortalWatcher (赞：19)

**说在前面**

做之前：$NOI2014$？？不应该黑题吗？？

做之后：好吧，还真应该降为紫题。

**Description**

题目好像说这么多没啥用，还是简化一下。

给你五个数 $x0,a,b,c,d$,让你构造两个序列。

$X_i=(a\times X_{i-1}^2+b\times X_{i-1}+c)\mod d$

$T_i=i$

输入 $n,m$。

然后你要对 $T_1$~$T_{n\times m}$ 做以下事情。

交换 $T_i$ 和 $T_{X_i\mod i}$。

最后输入 $q$。

输入$q$ 个 $u,v$，交换 $T_u$ 和 $T_v$。

接着把 $T$ 数组按照从左到右，从上到下的顺序放入一个 $n\times m$ 的棋盘。

问：

从左上角走到右下角组成的序列排序后最小字典序的序列是什么？

**Solution**

其实不要被紫题所迷惑，其实这就是一道简单的贪心题。

由于要求字典序最小，所以我们肯定能走最小就走最小。

我们可以预处理出 $1$ ~ $n\times m$ 的数在哪个位置，然后判断一下这个数是否在可以选的范围内。

如果能选，就要修改相应不能选的位置：

设 $l_i,r_i$ 表示第i行能选的范围是 $l_i$~$r_i$，然后如果我们选了   $(x,y)$ 这个位置的数，那么红色位置的数就不能选。

![](https://cdn.luogu.com.cn/upload/image_hosting/d0ldhu2g.png)

因为从(x,y)不可能再走到红色区域。然后依次修改l，r即可。

**Code**

```cpp
#include<cstdio>
#include<algorithm>
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
using namespace std;
int n,m,q,x[25000001],t[25000001],u,v,l[5001],r[5001],tot;
long long a,b,c,d;
int main()
{
	scanf("%d%lld%lld%lld%lld",&x[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	for (int i=1;i<=n*m;i++)
		x[i]=(x[i-1]*(a*x[i-1]+b)+c)%d,t[i]=i;
	for (int i=1;i<=n*m;i++)
		swap(t[i],t[x[i]%i+1]);
	for (int i=1;i<=q;i++)
	{
		scanf("%d%d",&u,&v);
		swap(t[u],t[v]);
	}
	for (int i=1;i<=n*m;i++)
		x[t[i]]=i;
	for (int i=1;i<=n;i++)
		l[i]=1,r[i]=m;
	for (int i=1;i<=n*m;i++)
	{
		int xx,yy;
		if (x[i]%m==0) xx=x[i]/m;
		else xx=x[i]/m+1;
		yy=x[i]%m;
		if (!yy) yy=m;
		if (yy>=l[xx]&&yy<=r[xx])
		{
			++tot;
			printf("%d ",i);
			if (tot==n+m-1) return 0;
			for (int j=1;j<=n;j++)
				if (j<xx) r[j]=min(r[j],yy);
				else if (j>xx) l[j]=max(l[j],yy);
		}
	}
	return 0;
}
```
最后注意一下空间，可以把 $X$ 数组循环用，这样就不用担心空超了。

祝大家早日 $AC$!

---

## 作者：SuperCowHorse (赞：11)

### 题目大意
给定一个 $n \times m$ 的棋盘，需要从左上角走到右下角，且只能向下或向右走，共走过 $n+m-1$ 为“路径序列”。求排序后字典序最小的路径序列。
### 题目分析
首先，我们需要通过随机数生成的规则生成出这个棋盘。

- 生成 $x$ 序列与 $t$ 的初始序列

根据输入的 $a$，$b$，$c$，$d$，直接模拟序列即可。
``` cpp
for(int i=1;i<=n*m;++i){
	x[i]=(a*x[i-1]*x[i-1]+b*x[i-1]+c)%d;
	t[i]=i;
}
```
- 将 $t$ 进行 $k$ 次交换和 $q$ 次交换。

也是同样的思路，直接交换即可。
``` cpp
for(int i=1;i<=n*m;++i)
	swap(t[i],t[x[i]%i+1]);//k次交换
while(q--){//q次交换
	scanf("%d%d",&u,&v);
	swap(t[u],t[v]);
}
for(int i=1;i<=n*m;++i)//初始化棋盘
	x[t[i]]=i;
```
然后就是本题的重点：找字典序最小的路径序列。

如何找呢？

以样例 #1 为例（以下棋盘中未着色表示不选，着色表示可以选）：

首先，起点和终点可以选，那么他们两点构成的矩形中的所有点都可以选。

![](https://cdn.luogu.com.cn/upload/image_hosting/4jrkhyya.png)

其次，由于排序后字典序最小，按照贪心的原则，找到可以选的最小的点（$a_{1,3}$ $=$ $1$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ik34ipz.png)

由此可以看出，$a_{1,1}$ 与 $a_{1,3}$ 构成的矩形中的数可以选，$a_{1,3}$ 与 $a_{3,4}$ 构成的矩形中的数也可以选。

然后，选可以选的数中最的数（$a_{2,4}$ $=$ $2$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/lck5jc2y.png)

和刚才一样，$a_{1,1}$ 与 $a_{1,3}$ 构成的矩形中的数可以选，$a_{1,3}$ 与 $a_{2,4}$ 构成的矩形中的数可以选，$a_{2,4}$ 与 $a_{3,4}$ 构成的矩形中的数可以选。

最后，找剩下可以选的数中最小的数（$a_{2,3}$ $=$ $6$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/zcwgpv5y.png)

$a_{1,1}$ 与 $a_{1,3}$ 构成的矩形中的数可以选，$a_{1,3}$ 与 $a_{2,3}$ 构成的矩形中的数可以选，$a_{2,3}$ 与 $a_{2,4}$ 构成的矩形中的数可以选，$a_{2,4}$ 与 $a_{3,4}$ 构成的矩形中的数可以选。

到此，可以选的数的个数等于 $n+m-1$，至此，结束。
``` cpp
for(int i=1;i<=n;++i)//l,r表示能选的区间
	e[i].l=1,e[i].r=m;
for(int i=1;i<=n*m;++i){
	int nx,ny;
	if(x[i]%m==0) nx=x[i]/m;
	else nx=x[i]/m+1;
	ny=x[i]%m;
	if(!ny) ny=m;
	if(ny>=e[nx].l&&ny<=e[nx].r){
		++cnt;
		printf("%d ",i);
		if(cnt==n+m-1) return;
		for(int j=1;j<=n;j++){
			if(j<nx) e[j].r=min(e[j].r,ny);
			else if(j>nx) e[j].l=max(e[j].l,ny);
		}	
	}
}
```
还有一点，出题人卡内存~~不讲武德~~，建议少开数组，别开`long long`。

最后贴个~~高清~~无注释代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
long long a,b,c,d;
int q,m,n,u,v,cnt;
int x[maxn*maxn],t[maxn*maxn];
struct node{
	int l,r;
}e[maxn];
void init(){
	for(int i=1;i<=n*m;++i){
		x[i]=(a*x[i-1]*x[i-1]+b*x[i-1]+c)%d;
		t[i]=i;
	}
	for(int i=1;i<=n*m;++i)
		swap(t[i],t[x[i]%i+1]);
	while(q--){
		scanf("%d%d",&u,&v);
		swap(t[u],t[v]);
	}
	for(int i=1;i<=n*m;++i)
		x[t[i]]=i;
	for(int i=1;i<=n;++i)
		e[i].l=1,e[i].r=m;
}
void work(){
	for(int i=1;i<=n*m;++i){
		int nx,ny;
		if(x[i]%m==0) nx=x[i]/m;
		else nx=x[i]/m+1;
		ny=x[i]%m;
		if(!ny) ny=m;
		if(ny>=e[nx].l&&ny<=e[nx].r){
			++cnt;
			printf("%d ",i);
			if(cnt==n+m-1) return;
			for(int j=1;j<=n;j++){
				if(j<nx) e[j].r=min(e[j].r,ny);
				else if(j>nx) e[j].l=max(e[j].l,ny);
			}	
		}
	}
}
signed main(){
	scanf("%d%lld%lld%lld%lld%d%d%d",&x[0],&a,&b,&c,&d,&n,&m,&q);
	init();
	work();
	return 0;
}
```

---

## 作者：pantw (赞：5)

这个题有毒emmm 卡常数真是难受QAQ


首先我们按照题目的方式产生随机数，然后按照题目描述的方式打乱即可。


接下来我们维护每一行的可行区域，贪心地寻找路径即可。


关于卡时间：

1. 拿个数组把随机数存起来比现生成现用来得快，我也不知道为什么

2. 注意到可行区域的边界坐标有单调性，及时退出循环可以减少运行时间。

3. %能省则省。

4. ~~开个O2~~


```cpp
extern "C" {
    int scanf(const char*,...);
    int printf(const char*,...);
}
#define maxn 25000010
#define Lovelive long long
int T[maxn], P[maxn], L[5010], R[5010];
int main() {
    Lovelive l;
    int a, b, c, d;
    int n, m, q, t, u, v, x = 0, y = 0, sqr;
    scanf("%lld%d%d%d%d%d%d%d", &l, &a, &b, &c, &d, &n, &m, &q);
    sqr = n * m;
    for(register int i = 0; i != sqr; ++i) T[i] = i, l = P[i] = ((a * l + b) * l + c) % d;
    for(register int i = 0; i != sqr; ++i) l = P[i] % (i+1), t = T[l], T[l] = T[i], T[i] = t;
    for(int i = 0; i != q; ++i) scanf("%d%d", &u, &v), t = T[u-1], T[u-1] = T[v-1], T[v-1] = t;
    for(register int i = 0; i != sqr; ++i) P[T[i]] = i;
    for(int i = 0; i != n; ++i) R[i] = m - 1;
    for(register int i = 0; i != sqr; ++i) {
        x = P[i] / m, y = P[i] - x * m; 
        if(L[x] <= y && y <= R[x]) {
            printf("%d ", i + 1);
            for(int k = x-1; k >= 0; --k) {
                if(y < R[k]) R[k] = y;
                else break;
            }
            for(int k = x+1; k != n; ++k) {
                if(y > L[k]) L[k] = y;
                else break;
            }
        }
    }
    return 0;
}
```

---

## 作者：MnZnOIer (赞：3)

本题评蓝实在是有点水了，但是也不乏思维含量。
### 题目大意
按照给定规则构造一个矩阵（也可以说是一个序列），只能往右或下走，求排序后最小字典序路径。

### 解题思路
先按照题意模拟，构造出 $T_i$。

再确定贪心策略：既然路径会排序，肯定要先选当前能选的中最小的那个。

现在的难点就在于，如何知道一个数字在当前状态下能不能选。

```
12 9 1 7 
5 11 6 2 
4 10 3 8
```

观察样例 1，当前可选的最小值为 $1$，选完 $1$ 之后，就会有一些数字不能选了。（图中的空位就是不能选了的数字）
```
12 9 1 7 
     6 2 
     3 8
```

继续观察，当前可选的最小值为 $2$，选完 $2$ 之后状态如下：
```
12 9 1 7 
     6 2 
       8
```

当前可选的最小值为 $6$，选完 $6$ 之后状态如下：
```
12 9 1   
     6 2 
       8
```

现在只剩下 $n+m-1$ 个数字，就是最终答案。通过分析样例，可以发现，每选一个数字他的左下角和右上角就不能选了，所以我们可以用一个数组记录每一行可选数字的区间。这个区间是唯一的，因为如果当前位置不能选，那么它左或右边的数字也一定不能选了。

### 细节处理
1. 本题卡空间，需要利用原来的 $x_i$ 来记录 $t_i$ 的位置。

2. 变量开 `long long`，数组开 `int`。

其实其他的也没有了。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define INF 114514114514114514
using namespace std;
const int M = 5e3 * 5e3 + 5, N = 5e3 + 5;
long long a, b, c, d, n, m, q, cnt;
int x[M], t[M], l[N], r[N];
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> x[0] >> a >> b >> c >> d >> n >> m >> q;
	for (int i = 1; i <= n * m; ++ i)t[i] = i, x[i] = (a * x[i - 1] * x[i - 1] + b * x[i - 1] + c) % d;
	for (int i = 1; i <= n * m; ++ i)swap (t[i], t[(x[i] % i) + 1]);
	for (int i = 1, u, v; i <= q; ++ i){cin >> u >> v;swap (t[u], t[v]);}
    //正常模拟计算出 t 数组。
	for (int i = 1; i <= n * m; ++ i)x[t[i]] = i;//节省空间
	for (int i = 1; i <= n; ++ i)l[i] = 1, r[i] = m;
	for (int i = 1; i <= n * m; ++ i)//从小到大
	{
		int X = x[i] / m + 1 - (x[i] % m == 0), Y = (x[i] - 1) % m + 1;
		if (l[X] <= Y && Y <= r[X])//是否可选
		{
			++ cnt;
			cout << i << ' ';
			if (cnt + 1 == n + m)break;
			for (int j = 1; j <= n; ++ j)//再把左下角和右上角移出范围
			{
				if (j < X)r[j] = min (r[j], Y);//一定要取 min 和 max，因为不能恢复区间
				else if (j > X)l[j] = max (l[j], Y);
			}
		}
	}
	return 0;
}
```

---

## 作者：JoyJoyGang (赞：2)

首先按照他给出的方法构造出矩阵，然而我感觉这道题就是难在这。

之前开长整形就一直空间爆炸，只能开整形并且数组反复利用。

因此我们一定要算准空间，否则直接满分变为六十分真的很可惜。

现在构造完矩阵了，因为他要找到一条字典序最小的路径。我们很显然的就想到从小到大枚举矩阵里面的数，看当前枚举数是否可以在之前点构成的路径框架里面。

而为了达到上述目的，我们记录每一行最左可以到哪，最右可以到哪。而更新就是每行成功选取一个数之后，行编号比他小的更新最右可以到哪，行编号比他大的更新最右可以到哪。因为只能向下和向右走。这两个操作都是暴力修改即可。

虽然很暴力，可是还是满分了。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MA=5002;
int n,m,Q,t[MA*MA],zuo[MA],you[MA],x[MA*MA];
ll aa,b,c,d;
signed main()
{
	scanf("%d%lld%lld%lld%lld",&x[0],&aa,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&Q);
	for(int i=1;i<=n*m;i++){
		x[i]=(x[i-1]*(aa*x[i-1]+b)%d+c)%d;t[i]=i;
	}		
	for(int i=1;i<=n*m;i++){
		swap(t[i],t[(x[i]%i)+1]);
	}
	while(Q>0){
		--Q;int x,y;scanf("%d%d",&x,&y);swap(t[x],t[y]);
	}
	for(int i=1;i<=n*m;i++){
		int he=t[i];x[he]=i;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		zuo[i]=MA;you[i]=0;
	}
	for(int i=1;i<=n*m;i++){
		if(ans==n+m-1){break;}
		int qi=(x[i]/m)+1,ji=x[i]%m;
		if(ji==0){
			ji+=m;qi-=1;
		}
		int pan=zuo[qi],duan=you[qi];
		if(ji<=pan&&ji>=duan){
			++ans;printf("%d ",i);
		}
		else{
			continue;
		}
		for(int j=1;j<qi;j++){
			zuo[j]=min(zuo[j],ji);
		}
		for(int j=qi+1;j<=n;j++){
			you[j]=max(you[j],ji);
		}		
	}
	return 0;
}
```


---

## 作者：401rk8 (赞：2)

提供一个极劣但与现有题解不同的做法。

---

预处理出棋盘和每个值所在的位置（后者采用 `pair<short,short>`），大约需要 $200$MB 空间。

考虑贪心：从小到大枚举数值，能走过就必须走。判断是否“能走过”可以用一个 `set` 维护当前“必须走”的点，`lower_bound` 出若要走当前点，上一个/下一个“必须走”的点 $l,r$，判断当前点是否在 $l,r$ 形成的矩形内即可。  
时间复杂度 $O(n^{2}\log n)$，勉强能过。

[code](https://uoj.ac/submission/558452)

---

## 作者：Blizzard (赞：2)

这道题。。。很明显的贪心+暴力，说实话前面balabala那一大堆也没什么用，按题目要求做初始化完全不会TLE

构造出来方阵后，由于是一个排列，不存在重复，可以大力贪心。

貌似除了卡内存没别的问题了吧。。

UP，DOWN记录一下每一行的可行区间，扫一遍即可

AC代码奉上

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll x0, a, b, c, d;
int n, m, q, T[25000010], X[25000010], tmpa, tmpb, Up[5010], Down[5010];
int main()
{
    scanf("%lld%lld%lld%lld%lld%d%d%d", &x0, &a, &b, &c, &d, &n, &m, &q); 
    for(int i = 0; i < n * m; i++) x0 = (a * x0 * x0 + b * x0 + c) % d, X[i] = (int) x0;
    for(int i = 0; i < n * m; i++) T[i] = i;
    for(int i = 0; i < n * m; i++) swap(T[i], T[X[i] % (i + 1)]);
    while(q--) scanf("%d%d", &tmpa, &tmpb), swap(T[tmpa - 1], T[tmpb - 1]); //初始化T[i]数组
    for(int i = 0; i < n * m; i++) X[T[i]] = i;                             //
    for(int i = 0; i < m; i++) Up[i] = 0, Down[i] = n - 1;
    for(int i = 0; i < n * m; i++)
        if(Up[X[i] % m] <= X[i] / m && Down[X[i] % m] >= X[i] / m)
        {
            printf("%d ", i + 1);
            for(int j = X[i] % m + 1; j < m; j++) Up[j] = max(Up[j], X[i] / m);
            for(int j = 0; j < X[i] % m; j++) Down[j] = min(Down[j], X[i] / m);
        }
    return 0;
}
```

---

## 作者：ZHR100102 (赞：0)

[Blog](https://www.cnblogs.com/zhr0102/p/18876932)

简单贪心加上均摊复杂度分析。

首先理解题意，容易发现我们**依次尝试钦定值为 $1,2,3,4,\dots$ 的格子在路径中**，能满足的就优先满足，这样选一定是最优的。

考虑如何快速查询某个格子能否出现在路径中。观察可知，如果一个格子被选择，那么**其左下角和右上角的部分便不能被选择了**，因为人只能往右边和下边走。因此问题被转化为了一个**矩形覆盖**问题。

直接用线段树实现是显然不可过的，常数太大了。

于是继续观察：发现从某个格子向下走，**如果遇到一个格子是不能被选择的，那么它下面的其他格子也都不能被选择了**；向上走也是同理。

这样的**单调性**与**总格子数为 $n^2$** 的限制，启发我们可以让**每次覆盖操作都精准覆盖到某一个未曾覆盖的格子上**，这样就可以用均摊复杂度完成矩形覆盖。实现上，可以维护一行中的左右端点，每次覆盖向上和向下走，遇到不能选择的就停下即可。

由于每个格子最多只被覆盖一次，所以均摊时间复杂度为 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
using pi=pair<short,short>;
ll x,a,b,c,d,n,m,q;
int t[25000005];
pi pos[25000005];
int l[5005],r[5005];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>x>>a>>b>>c>>d>>n>>m>>q;
	for(int i=1;i<=n*m;i++)t[i]=i;
	for(int i=1;i<=n*m;i++)
	{
		x=(a*x%d*x%d+b*x%d+c)%d;
		swap(t[i],t[x%i+1]);
	}
	while(q--)
	{
		int u,v;
		cin>>u>>v;
		swap(t[u],t[v]);
	}
	int id=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			pos[t[++id]]={i,j};
		}
	}
	for(int i=1;i<=n;i++)r[i]=0x3f3f3f3f;
	for(int i=1;i<=n*m;i++)
	{
		int nx=pos[i].fi,ny=pos[i].se;
		if(ny>l[nx]&&ny<r[nx])
		{
			cout<<i<<" ";
			for(int j=nx+1;j<=n;j++)
			{
				if(l[j]>=ny-1)break;
				l[j]=ny-1;
			}
			for(int j=nx-1;j>=1;j--)
			{
				if(r[j]<=ny+1)break;
				r[j]=ny+1;
			}
		}
	}
	return 0;
}
```

---

## 作者：lllyyykkk (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P2354)
## 思路
对于前面的数据生成部分，直接按题意模拟即可。  
对于后半段的构造序列，字典序最小就意味着这是一个贪心。

我们枚举从 $1$ 到 $n$ 各个数所在的位置，能选则选，所构造的字典序一定是最小的。  
在选取的同时，我们把所选位置的左上角和右下角矩阵都标记掉，直到选出序列所经过的 $n+m-1$ 个数。
## 关于空间
都说这题出题人毒瘤卡空间，毕竟两个数组就要 $5000\times5000\times2=5\times10^7$ 的大小，如果全开成 `long long` 就要 $4\times10^8B\approx381.5MB$，所以数组应当开 `int`。

注：如把所有变量都开为 `int`，计算随机数列时要注意对 $a,b,c$ 取模。
## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e3+10;
int a,b,c,d,n,m,T,cnt;
int x[N*N],t[N*N];
int l[N],r[N];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>x[0]>>a>>b>>c>>d>>n>>m>>T;
	for(int i=1;i<=n*m;i++) x[i]=(1ll*a%d*x[i-1]%d*x[i-1]%d+1ll*b%d*x[i-1]%d+c%d)%d,t[i]=i;
	for(int i=1;i<=n*m;i++) swap(t[i],t[x[i]%i+1]);
	for(int i=1,u,v;i<=T;i++) cin>>u>>v,swap(t[u],t[v]);
	for(int i=1;i<=n*m;i++) x[t[i]]=i;
	for(int i=1;i<=n;i++) l[i]=1,r[i]=m;
	for(int i=1,xx,yy;i<=n*m;i++){
		xx=x[i]/m+(x[i]%m!=0),yy=x[i]%m?x[i]%m:m;
		if(yy>=l[xx]&&yy<=r[xx]){
			cnt++;
			cout <<i<<' ';
			if(cnt==n+m-1) return 0;
			for(int j=1;j<=n;j++){
				if(j<xx) r[j]=min(r[j],yy);
				if(j>xx) l[j]=max(l[j],yy);
			}
		}
	}
	return 0;
}
``````

---

## 作者：_segmenttree (赞：0)

## 思路

随机数列我们直接按题目要求模拟即可。

接下来的选数由于要求字典序最小，我们显而易见可以用贪心，从小往大枚举，判断是否能选，再对范围进行改变。为了快速求得值为 $i$ 的所在位置，我们先预处理一下每个值对应位置。题目说了是向右向下走，假设我们选的在第 $x$ 行，那么所以比 $x$ 小的行都要考虑右边界范围，所以比 $x$ 大的行都要考虑左边界范围。

## 坑点

此题非常卡空间，我们要对大范围数组重复使用加谨慎选择数据类型才可通过。

## 代码

```cpp
#include<bits/stdc++.h>
#define N 25000001
#define NN 5001
using namespace std;
int m,st[N],js,n,dy[N];//st填数数列，dy随机数列+填数数列的值对应的位置（卡空间） 
struct lj{
	int l,r;
}w[NN];//维护每行可选范围 
signed main() {
    int a,q;
	long long b,c,mo;
	scanf("%d%d%lld%lld%lld%d%d%d",&dy[0],&a,&b,&c,&mo,&n,&m,&q);
	for(int i=1;i<=n*m;i++)
	    dy[i]=(1ll*dy[i-1]*dy[i-1]*a+dy[i-1]*b+c)%mo;
	for(int i=1;i<=n*m;i++)
	    st[i]=i;
	for(int i=1;i<=n*m;i++)
	    swap(st[i],st[dy[i]%i+1]);
	while(q--) {
		int u,v;
		scanf("%d%d",&u,&v);
		swap(st[u],st[v]);
	}
	for(int i=1;i<=n*m;i++) 
	    dy[st[i]]=i; 
	int js=0;
	for(int i=1;i<=n;i++)
	    w[i].l=1,w[i].r=m;
	for(int i=1;i<=n*m;i++) {
		int x=dy[i]/m+1,y=dy[i]%m;
		if(y==0) y=m;
		if(dy[i]%m==0) x--;
	    if(w[x].l<=y&&y<=w[x].r) {
	    	js++;
	    	if(js>n+m-1) break ;
	    	for(int j=1;j<=n;j++) {
	    		if(j>x) w[j].l=max(w[j].l,y);
	    		if(j<x) w[j].r=min(w[j].r,y);
			}
	    	printf("%d ",i);
		}
	}	
	return 0;
}

---

## 作者：Aw顿顿 (赞：0)

顺着贪心的标签来的，结果发现重头戏是模拟。

## 分析

前半部分跟着它走就行了。

首先根据给出的 $x_0,a,b,c,d$ 构造随机数列 $x$，满足递推式 $i ≥ 1,x_i=(a \times x_{i-1}^2+b \times x_{i-1}+c)\mod d$。这我们可以用线性的更新做出来。然后我们可以顺便初始化一下 $t$ 数列，使得在初始情况存在 $t_i=i$。

然后接着循环 $n\times m$ 次交换，每次交换 $t_i$ 和 $t_{(x_i\bmod i)+1}$，这样形成了一定的随机。然后接着读入 $q$ 组的 $u,v$，每次交换 $t_u,t_v$ 就可以了。至此，我们已经完成了随机数的初始化，接下来是贪心的部分。

因为要求字典序最小，所以我们肯定能走最小就走最小，当前这一步最小一定带来字典序最小，这是容易证明的。如果当前走了一个在该位置并非最小的格子，那么之后的序列就无需进行比对了，因为目前比较字典序实际上是从高位到低位顺序比较的。

用 $l,r$ 表示能够选取的范围，然后随着移动的进行，可以更新这两个数组。关于这道题卡常的问题，实际上你可以随便塞几个快读快输手写函数之类的卡过去时间，然后空间上你可以重复利用数组，并且没用的 `long long` 不要开，只有 $x_0,a,b,c,d$ 是需要 `long long` 的。

## 代码

调试完毕后压了个行，仅供对拍请勿抄袭。

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define MAXN 25000001
#define MAXM 5001
using namespace std;
long long a,b,c,d,x0;
int right_num[MAXM],cnt_tot,n,m,ques,x[MAXN],t[MAXN],u,v;
inline void swap(int &x,int &y){int t=y;y=x;x=t;}
int main(){
	scanf("%lld%lld%lld%lld%lld%d%d%d",&x0,&a,&b,&c,&d,&n,&m,&ques);x[1]=(x0*(a*x0+b)+c)%d,t[1]=1;
	for(register int i=2;i<=n*m;i+=1)x[i]=(x[i-1]*(a*x[i-1]+b)+c)%d,t[i]=i;
	for(register int i=1;i<=n*m;i+=1)swap(t[i],t[x[i]%i+1]);
	for(register int i=1;i<=ques;i+=1)scanf("%d%d",&u,&v),swap(t[u],t[v]);
	for(register int i=1;i<=n*m;i+=1)x[t[i]]=i;
	for(register int i=1;i<=n;i+=1)t[i]=1,right_num[i]=m;
	for(int i=1;i<=n*m;i+=1){
		int xx=(x[i]%m)?x[i]/m+1:x[i]/m,yy=(x[i]%m)?x[i]%m:m;
		if(yy>=t[xx]&&yy<=right_num[xx]){
			++cnt_tot;printf("%d ",i);
			if(cnt_tot==n+m-1)return 0;
			for(register int j=1;j<=n;j++)
				if(j<xx)right_num[j]=min(right_num[j],yy);
				else if(j>xx)t[j]=max(t[j],yy);
		}
	}return 0;
}
```

---

## 作者：jiangtaizhe001 (赞：0)

原题网址：
[bzoj P3671](https://www.lydsy.com/JudgeOnline/problem.php?id=3671)  
[洛谷 P2354](https://www.luogu.com.cn/problem/P2354)  
原博客地址：[https://blog.csdn.net/jiangtaizhe/article/details/103953613](https://blog.csdn.net/jiangtaizhe/article/details/103953613)
# 题解内容
~~终于把题目写完了，markdown写了半个多小时~~
前面blablabla讲了~~一大堆废话~~  
一句话讲，就是教你怎么生成一个随机函数，代码直接按照它的做法写下来，注意数据范围，要加$long long$不然会直接RE就像我一样：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200113111043541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW5ndGFpemhl,size_16,color_FFFFFF,t_70)  
炸$int$了，所以加上$long long$强制转换，就可以了~~~~~~  
```cpp
    scanf("%d%d%d%d%d",&x[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	int s=n*m;
	int i,j,tmp,tmps;
    for(i=1;i<=s+1;i++)
        x[i]=((long long)a*x[i-1]*x[i-1]+(long long)b*x[i-1]+c)%d;
    for(i=1;i<=s;i++) t[i]=i;//注意这里的(longlong)，不加会炸掉的
    for(i=1;i<=s;i++){
    	tmps=x[i]%i+1;
    	tmp=t[i];
    	t[i]=t[tmps];
		t[tmps]=tmp;
	}
    for(i=1;i<=q;i++){
    	scanf("%d%d",&a,&b);
    	tmp=t[a];
    	t[a]=t[b];
    	t[b]=tmp;
	}
```
重头戏在后面，明显是一道贪心，优先考虑1，然后是2，明显最外层的循环是：
```cpp
for(int i=1;i<=n*m;i++)
```
当然，~~register加不加都可以的~~
然后就是空间上了，这题的空间开两个$5000\times5000$的数组是足够的，但是，建议使用一维数组，同时，如果需要三个这样的数组，可以把另一个不需要的数组拿来用，记得清空。  

我的做法是先开一个数组来记录总每个数字的编码，位置编码如下：  
| 1 | 2 | 3 | 4 |
| - | - | - | -|
| **5** | **6** | **7** | **8** |
| **9** | **10** | **11** | **12** |
用数组$x_i$来表示第$i$个数的位置，然后建立两个数组down和up，如果取了一个数，就在上面做标记。比如说当6号位被取之后，那么9号位、3号位、4号位就不能取了，其中，$up_i,down_i$表示第$i$列可行的区间即可。每次枚举的时候就可以判定，如果可以，就更新，如果不可以就直接跳过。
这道题目需要很多的细节，所以，经过**反复调试**，终于，推出了  
$AC_{AC}^{AC}$AC**AC**==AC==_AC_^AC^~AC~代码
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#define maxn 5000*5000+39
using namespace std;
int t[maxn],x[maxn];
int up[5039],down[5039];
int a,b,c,d,n,m,q;
int main(){
	scanf("%d%d%d%d%d",&x[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	int s=n*m;
	int i,j,tmp,tmps;
    for(i=1;i<=s+1;i++)
        x[i]=((long long)a*x[i-1]*x[i-1]+(long long)b*x[i-1]+c)%d;
    for(i=1;i<=s;i++) t[i]=i;
    for(i=1;i<=s;i++){
    	tmps=x[i]%i+1;
    	tmp=t[i];
    	t[i]=t[tmps];
		t[tmps]=tmp;
	}
    for(i=1;i<=q;i++){
    	scanf("%d%d",&a,&b);
    	tmp=t[a];
    	t[a]=t[b];
    	t[b]=tmp;
	}//Insize t
	for(i=1;i<=s;i++)
	    x[t[i]]=i;
	for(i=1;i<=m;i++)
	    up[i]=0,down[i]=n+1;//Insize up and down
	int line,row;
	for(i=1;i<=s;i++){
		line=ceil(1.0*x[i]/m);
		if(x[i]%m==0)
		    row=m;
		else row=x[i]%m;//line  行 row 列 
		if(up[row]<line&&line<down[row]){
			printf("%d ",i);
			for(j=1;j<=row-1;j++)
			    down[j]=min(down[j],line+1);
			for(j=row+1;j<=m;j++)
			    up[j]=max(line-1,up[j]);
		}
	}
	return 0;
}
```

---

## 作者：Mooncrying (赞：0)

这道题难点在于读懂那个题面。

那个题面……我只能说一言难尽。

虽然读懂这种题面对大家也有帮助，但……

我还是简化一下吧。

### 题目大意 

- 给定五个种子 $x_0,a,b,c,d$，以及 $N, M$ 和 $Q$，要求你按照函数 $x_{i} = (a \cdot x_{i - 1}^2 + b \cdot x_{i - 1} + c) \mod d$ 构造出一组随机数序列 $x$。

	（显然根据后面的交换，我们需要构造 $N \times M$ 个随机数。）

- 然后你有一串从 $1$ 到 $N \times M$ 按顺序排列的一组数 $T$，对其进行 $N \times M$ 次交换，第 $i$ 次交换 $T_{i}$ 和 $T_{(x_{i} \mod i) + 1}$，随后再进行 $Q$ 次交换，每次给出两个数 $u, v$，交换 $T_{u}$ 和 $T_{v}$。

- 将交换得到的新数列 $T$ 依次填入一个 $N \times M$ 的棋盘（把 $T_{(i - 1) \cdot M + j}$ 填入第 $i$ 行第 $j$ 个位置）。

- 然后从左上角走到右下角，规定只能向下或向右走且不走出棋盘。显然在棋盘上会经过 $M + N - 1$ 个数（包括起点和终点）。将经过的数从小到大排序，输出排序后字典序最小的 $M + N - 1$ 个数。

- $2 \le M,N \le 5000$。

### 分析

- 首先我们按题意要求进行模拟得到填入棋盘的数列 $T$，记录 $T$ 中 $1$ 到 $M \times N$ 每一个数的位置。

- 接下来考虑如何走使字典序最小。

	因为路径会经过排序，那么我们肯定会先找 $1$ 所在的位置，因为如果不经过 $1$ 字典序肯定不是最小对吧。
    
    然后我们通过之前的记录找到了 $1$ 的位置为 $(x, y)$，然后我们就会发现：
    
    ![1](https://cdn.luogu.com.cn/upload/image_hosting/yk1ta2oh.png)
    
	因为规定只能向右或向下走，于是我们的活动范围变成了红色和黄色的区域，而显然白色的区域我们不能去，不然就走不到 $(x, y)$ 了。
    
    别的数同理。我们从小到大找每个数的位置，看该数是否在红色的区域内。如果在红色区域，则说明该数可到，直接输出即可，接着按照上图的标准对可到的区域重新进行约束；否则跳过，继续找下一个数。
    
    约束的话开一个 $l,r$ 数组对每列（或行）的两边界进行限制即可。
    
- 于是本题结束。

	时间复杂度为 $O(NM + (N + M)\cdot N)$，题目所给时间完全能跑下来。 
    
- 最后就是注意空间优化。

	该题的空间给的不是很理想，$x, T$ 两个数组就占去了大约 $200$ MB 的空间，不够再开一个数组记录每个数的位置。
    
    由于 $x$ 数组在交换过后不再使用，我们可以用其记录每个数的位置，这样就不会爆空间了。
    
### 下面是代码：
    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2.5e7 + 5, M = 5e3 + 5;
int x[N], T[N], l[M], r[M], Q, n, m, cnt;
long long a, b, c, d;
int max(int x, int y) { return x > y ? x : y; }
int min(int x, int y) { return x < y ? x : y; }
template <typename T> void read(T &x) {
	T f = 1; x = 0; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); } 
	while(ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
	x *= f;
}
template <typename T> void write(T x, char ch) {
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10, 0); putchar(x % 10 + '0');
	if(ch == ' ') putchar(' '); 
}
int main() {
	read(x[0]); read(a); read(b); read(c); read(d); read(n); read(m); read(Q);
    
	for(int i = 1; i <= n * m; ++i) 
		x[i] = (a * x[i - 1] * x[i - 1] + b * x[i - 1] + c) % d, T[i] = i;
        
	for(int i = 1; i <= n * m; ++i) 
		swap(T[i], T[x[i] % i + 1]);
        
	for(int i = 1, u, v; i <= Q; ++i) 
		read(u), read(v), swap(T[u], T[v]);
        
	for(int i = 1; i <= n * m; ++i) 
		x[T[i]] = i;
        
	for(int i = 1; i <= n; ++i) 
		l[i] = 1, r[i] = m;
        
	for(int i = 1, X, Y; i <= n * m; ++i) {
		X = x[i] % m == 0 ? x[i] / m : x[i] / m + 1;
		Y = x[i] % m == 0 ? m : x[i] % m;
		if (Y >= l[X] && Y <= r[X]) {
			printf("%d ",i);
			if(++cnt == n + m - 1) return 0;
			for(int j = 1; j <= n;j++)
				if(j < X) r[j] = min(r[j], Y);
				else if(j > X) l[j] = max(l[j], Y);
		}
	}
}
```


---

## 作者：不存在之人 (赞：0)

题干教我们用 n∗m+q 的时间求出一个矩阵 

要求我们在矩阵上走一条路径 使得路径排序后字典序最小 
那么 就很显然了 

采用贪心的思想 依次考虑每个数字 

每个数字需要一个“来路”和“去路” 

最后记录一下可行的答案即可
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define oo 2139062143
#define sqr(x) ((x)*(x))
#define lowbit(x) ((x)&(-x))
#define abs(x) (((x)>=0)?(x):(-(x)))
#define max(x,y) (((x)>(y))?(x):(y))
#define min(x,y) (((x)<(y))?(x):(y))
#define divi(x,y) (((x)%(y))?((x)/(y)):(((x)/(y)))-1)
#define fo(i,x,y) for (int i = (x);i <= (y);++ i)
#define fd(i,x,y) for (int i = (x);i >= (y);-- i)
using namespace std;
typedef double db;
typedef long long ll;
const int N = 5050,M = 5050,NM = N * M;
ll a,b,c,d;
int n,m,q,nm,tot;
int t[NM],x[NM],upp[N],low[N],ans[N * 2];
void ins(int a,int b)
{
    fo(i,1,n)
    if (i < a) upp[i] = min(b,upp[i]); else
    if (i > a) low[i] = max(b,low[i]);
}
int main()
{
    scanf("%d%lld%lld%lld%lld", &x[0], &a, &b, &c, &d);
    scanf("%d%d%d", &n, &m, &q); nm = n * m;
    memset(upp,127,sizeof upp);
    fo(i,1,nm) x[i] = (x[i - 1] * (a * x[i - 1] + b) + c) % d,t[i] = i;
    fo(i,1,nm) swap(t[i],t[(x[i] % i) + 1]);
    fo(i,1,q)
    {
        int x,y;
        scanf("%d%d", &x, &y);
        swap(t[x],t[y]);
    }
    fo(i,1,nm) x[t[i]] = i;
    fo(i,1,nm)
    {
        int a,b;
        if (x[i] % m) a = x[i] / m + 1; 
        else a = x[i] / m;  
        b = x[i] % m;
        if (!b) b += m;        
        if (b <= upp[a] && b >= low[a])
        {
            ins(a,b);
            ans[++ tot] = i;
            if (tot == n + m - 1) break;
        }
    }
    fo(i,1,tot) printf("%d ", ans[i]);
}
```

---


# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# 题解

## 作者：Orion545 (赞：233)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8900494.html)

# 更新现场（建议先看“思路”开始的部分）

鉴于评论区的大家对代码中的$ans$提出的疑惑，我再重新细讲一遍

考虑$kmp$过程中求出的$next$数组，也就是我的代码里面的$fail$

实际上这些$fail$作为边的话，它们构成了一个树形结构。这个树形结构就是**KMP自动机的$fail$树**（关于$fail$树的概念可以参考$AC$自动机，这里实际上$KMP$自动机就是在$AC$自动机只插入了一个字符串的情况下建立的自动机，同理它也拥有$fail$树）（同时也要注明，实际上此处使用的应该是$MP$算法而不是$KMP$算法，所以称之为$MP$自动机更合适）

那么理解了这个以后，就可以轻松意识到，代码里面的$ans$实际上是这个节点在$fail$树上的深度

应当意识到，由于对于前缀$i$而言，$next[i]$、$next[next[i]]$、$next[next[next[i]]]$等等都是它的公共前后缀，**所以节点$i$在该字符串的$KMP$自动机的$fail$树上的深度就是前缀$[1,i]$的公共前后缀个数**

在后面的递归求解过程中，如果把这个过程放到$fail$树上理解，同样会好理解很多：$j$也就是在$fail$树上往前跳的过程中用于记录的一个指针，它会每次跳到直到$j\ast 2>i$为止

# 思路

首先，这题最好的一个地方，在于它给出的关于$next$的讲解实在是妙极......甚至可以说我的kmp是过了这道题以后才脱胎换骨的

然后是正文：

### 如何求$num$数组？

这道题的输入有1e6个字符，显然需要$O\left(n\right)$左右级别的算法来解

先看到$num$的定义：不互相重叠的公共前后缀**个数**

这说明什么？

说明$num$不同于$next$记录的是一个最大值，它记录的是一个和值

而这个和值，是可以推出来的

考虑一个前缀$i$的$next[i]$，它长这样：

![](http://images.cnblogs.com/cnblogs_com/dedicatus545/1199264/o_NOI2014%20p1.png)

其中，$next[i]$，$next[next[i]]$，$next[next[next[i]]]$......都是这个前缀串i的公共前后缀，而且只有它们是公共前后缀

那么，我们其实只要在求$next$的过程中，顺便把这个公共前后缀的数量递推一下，就得到了一个弱化版的$num$数组：可以重叠的公共前后缀数量，我们称之为$ans$

### 如何去除有重叠的？

还是看上面那张图

首先$next$数组有一个性质：$next[i] < i$

也就是说，一旦有一个递归了n层的next，比原前缀i的长度的一半要小，那么这个next的递推出的答案$ans$就是i的$num$了

### 一个问题

假如我们拿到的串是1e6个'a'，那么上面那个算法就会被卡成$O\left(n^2\right)$，道理的话大家可以想一想（每一次递归都只会把next[i]变小1）

那么我们需要做一个优化，来解决这个问题，而解决问题的核心就是：减少重复递归

减少重复递归......有没有想到什么？

没错，就是如同求$next$时一样的方法！

我们将递归用的变量$j$的值不更新，这样，求完了$i$的答案以后，$j$的位置一定在$\frac i2$的左边，也就是它已经满足要求了

这时再递归求解，总时间效率是$O\left(n\right)$的

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const ll MOD=1e9+7;
int n,fail[1000010],ans[1000010];ll cnt;char a[1000010];
int main(){
    int T,i,j;scanf("%d",&T);
    while(T--){
        scanf("%s",a);n=strlen(a);
        memset(fail,0,sizeof(fail));
        j=0;ans[0]=0;ans[1]=1;
        
        for(i=1;i<n;i++){//求解next
            while(j&&(a[i]!=a[j])) j=fail[j];
            j+=(a[i]==a[j]);fail[i+1]=j;ans[i+1]=ans[j]+1;//递推记录ans
        }
        
        j=0;cnt=1;
        for(i=1;i<n;i++){//求解num
            while(j&&(a[i]!=a[j])) j=fail[j];
            j+=(a[i]==a[j]);
            while((j<<1)>(i+1)) j=fail[j];
            cnt=(cnt*(ll)(ans[j]+1))%MOD;//记得+1
        }
        printf("%lld\n",cnt);
    }
}
```

---

## 作者：nofind (赞：182)

## [题意](https://www.luogu.org/problemnew/show/P2375)

首先我们比对一下$nxt$数组和$num$数组

$nxt$：S串前$i$个字符最长公共前后缀

$num$：S串前$i$个字符不重叠的公共前后缀数量

首先发现一个性质：

对于$[1,i]$：$nxt[i],nxt[nxt[i]],nxt[nxt[nxt[i]]]...$表示了$[1,i]$所有的公共前后缀

![](https://cdn.luogu.com.cn/upload/pic/62593.png)

如图：绿色的部分是相同的

于是问题就变成了先暴力跳$nxt$直到$j<=i/2$，$num[i]$就是之后能跳几步

我们记录$i$能跳$nxt$直到$nxt=0$的次数，记为$num[i]$(有的思路说这是不考虑不重叠的num数组)

等到跳到$j<=i/2$,让$ans*(num[j]+1)$ 即可

code：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000010;
const int mod=1e9+7;
int n,T;
int nxt[maxn],num[maxn];
long long ans;
char s[maxn];
void getnxt()
{
    for(int i=2,j=0;i<=n;i++)
    {
        while(j&&s[i]!=s[j+1]) j=nxt[j];
        if(s[i]==s[j+1]) j++;
        nxt[i]=j;num[i]=num[j]+1;
    }
}
void getnum()
{
    for(int i=2,j=0;i<=n;i++)
    {
        while(j&&s[i]!=s[j+1]) j=nxt[j];
        if(s[i]==s[j+1])j++;
        while((j<<1)>i) j=nxt[j];
        ans=(ans*(long long)(num[j]+1))%mod;
    }
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        ans=1;num[1]=1;
        scanf("%s",s+1);n=strlen(s+1);
        getnxt();getnum();
        printf("%lld\n",ans);
    }
    return 0;
}
```


---

## 作者：yybyyb (赞：89)

神TM阅读理解题

看完题目之后


暴力：每次暴跳$next$数组

太慢啦


优化一下暴力：

搞个倍增数组来跳$next$

每次倍增跳$next$

复杂度$O(Tnlogn)$

算一下，感觉复杂度差不多呀

很果断的交了一发

然后$80$分。。。


暴力代码送上：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MOD 1000000007
char s[1200000];
int nt[1200000];
int jp[1200000][21];
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",s+1);
        nt[1]=0;
        int l=strlen(s+1);
        for(int i=2;i<=l;++i)
        {
            int j=nt[i-1];
            while(j&&s[i]!=s[j+1])j=nt[j];
            if(s[i]==s[j+1])nt[i]=j+1;
            else nt[i]=0;
            jp[i][0]=nt[i];
        }
        for(int j=1;j<20;++j)
            for(int i=1;i<=l;++i)
                jp[i][j]=jp[jp[i][j-1]][j-1];
        int ans=1;
        for(int i=2;i<=l;++i)
        {
            int tt=i;
            for(int j=19;j>=0;--j)
                if(jp[tt][j]*2>i)tt=jp[tt][j];
            int gg=0;
            for(int j=19;j>=0;--j)
                if(jp[tt][j])gg+=1<<j,tt=jp[tt][j];
            ans=1ll*ans*(gg+1)%MOD;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

然后我很不爽

把倍增数组的两维反了过来，防止反复横跳

然后我就$AC$了？？？

~~又一次感受到玄学强大的力量~~


这个$O(Tnlogn)$的复杂度果然很对呀。。。

暴力能AC？？？：

（BZOJ上都能AC？？？）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MOD 1000000007
char s[1200000];
int nt[1200000];
int jp[21][1200000];
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%s",s+1);
        nt[1]=0;
        int l=strlen(s+1);
        for(int i=2;i<=l;++i)
        {
            int j=nt[i-1];
            while(j&&s[i]!=s[j+1])j=nt[j];
            if(s[i]==s[j+1])nt[i]=j+1;
            else nt[i]=0;
            jp[0][i]=nt[i];
        }
        for(int j=1;j<20;++j)
            for(int i=1;i<=l;++i)
                jp[j][i]=jp[j-1][jp[j-1][i]];
        int ans=1;
        for(int i=2;i<=l;++i)
        {
            int tt=i;
            for(int j=19;j>=0;--j)
                if(jp[j][tt]*2>i)tt=jp[j][tt];
            int gg=0;
            for(int j=19;j>=0;--j)
                if(jp[j][tt])gg+=1<<j,tt=jp[j][tt];
            ans=1ll*ans*(gg+1)%MOD;
        }
        printf("%d\n",ans);
    }
    return 0;
}

```

~~我的复杂度还是太弱了~~


~~这是一篇来自蒟蒻的题解~~


---

## 作者：Wow_Goodjob (赞：51)

~~动物园是个好地方~~

在做题之前，请大家注意一个事情：字符型数组数不可以通过$memset$函数清0的，
因为即使只是把内存清空，也会引起翻车，（详见本人第一次提交的代码）

------------
然后我们来看题，这道题，乍一看还以为是~~看毛片~~KMP裸题，但计算了一下时间复杂度就可以发现如果我们枚举每一个$i$然后让$next$数组（失配函数）一直向前跑，然后暴力统计$num$数组一直向前跑，就会TLE。 

**不会KMP的童鞋看这里**:
[KMP算法](http://www.matrix67.com/blog/archives/115)matrix67的文章，写的很好


所以这么做肯定不行，因此我们需要使用更优秀的算法

我们从暴力开始一点一点的优化**我们发现，这个题目的关键是前后两个字符串（前缀与后缀）不可以重合**那么我们不妨先忽略掉这一个条件，求出有交叉的$num1$数组，那么显而易见的$num$数组
就是num[i]=num[j]（j是小于i的一半的那个数）

那么本题的重点便到了求出$num1$数组了，然而显而易见的只要在求KMP的时候顺便**递推**求出便可以了，其中要注意的是num数组的初值**下标为0的是0，下标为一的为1**还有就是字符串的下标是从一开是的，这个相信大家都知道了，如果您想把下标改为从一开始的话不妨试试这个
**scanf("%s",s+1);**非常好用。

如图
```cpp
void kmp()
{
	j=0;
	for(int i=1;i<la;i++)
	{
		while(j&&a[j]!=a[i])  j=next[j];
		if(a[j]==a[i])  j++;
		next[i+1]=j;num1[i+1]=num1[j]+1;
	}
}
```

然后由于$num$数组用了就扔，**所以就根本不用求出来！！**

只需要让我们记录答案的那个数直接乘上求出的数就好了（一定要开long long ）
不然小心爆炸**~~（BOOM）~~**

具体代码如下
```cpp
for(int i=1;i<la;i++)
		{
			while(a[j]!=a[i]&&j) j=next[j];
			if(a[i]==a[j]) j++;
			while((j<<1)>i+1)   j=next[j];
			ans*=(num1[j]+1);
			ans%=mod;
		}
```


最后，再把AC代码毫不吝啬地奉献出来！！(时间复杂度O(n)，请放心阅读)
```cpp
#include <bits/stdc++.h>
using namespace std;

const long long mod=1000000007;

int n;
char a[1000010]={};
int la;
int next[1000010]={};
long long num1[1000010]={};
int j;

void kmp()
{
	j=0;
	for(int i=1;i<la;i++)
	{
		while(j&&a[j]!=a[i])  j=next[j];
		if(a[j]==a[i])  j++;
		next[i+1]=j;num1[i+1]=num1[j]+1;
	}
}

int main()
{
	scanf("%d",&n);
	while(n--)
	{
//		memset(num1,0,sizeof(num1));
		memset(next,0,sizeof(next));
//		memset(a,0,sizeof(a));//翻车现场
		scanf("%s",a);
		la=strlen(a);
		num1[0]=0;
		num1[1]=1;
		kmp();
		j=0;
		long long ans=1;
		for(int i=1;i<la;i++)
		{
			while(a[j]!=a[i]&&j) j=next[j];
			if(a[i]==a[j]) j++;
			while((j<<1)>i+1)   j=next[j];
			ans*=(num1[j]+1);
			ans%=mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：fanfan (赞：23)

贴一个z-box做法的题解。

我们用z-box算法求出每个后缀与原串的lcp，然后很轻松的利用差分统计答案即可。
z-box算法可以在O(N)的时间内求出每个后缀与原串的lcp，他类似于马拉车算法，也是递推地求解。

假设我们要求第i个后缀的lcp，我们已经求出来前i-1个，维护匹配lcp一个最右端的指针，记此时的后缀为pos，原串为s。pos+lcp[pos]-1是max(j+lcp[j]-1) {j<i}
那么我们可以发现i如果位于pos+lcp[pos]-1的左面的话，我们可以利用之前的结果更新当前的lcp，然后再暴力扩展，随时更新一下指针，和马拉车其实是一个道理。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
const int mod=1e9+7;
char s[N];
int r,pos,lcp[N],t[N];
int main()
{
	int T;scanf("%d",&T);
	while(T--)
	{
		memset(lcp,0,sizeof lcp);
		memset(t,0,sizeof t);
		pos=r=0;
		scanf("%s",s+1);
		int len=strlen(s+1);
		for(int i=2;i<=len;++i)
		{
			if(pos==0)
			{
				int p=1;
				while(s[p+lcp[i]]==s[i+lcp[i]]) ++lcp[i];
				if(lcp[i]) r=i+lcp[i]-1,pos=i;
				continue;
			}
			if(i>r)
			{
				int p=1;
				while(s[p+lcp[i]]==s[i+lcp[i]]) ++lcp[i];
				if(lcp[i]) r=i+lcp[i]-1,pos=i;
				continue;
			}
			int npos=i-pos+1;
			lcp[i]=min(lcp[npos],r-i+1);
			while(s[lcp[i]+1]==s[i+lcp[i]]) ++lcp[i];
			if(i+lcp[i]-1>r) r=i+lcp[i]-1,pos=i;
		}
		for(int i=2;i<=len;++i)
		if(lcp[i])
		t[i]++,t[min(2*(i-1),min(len,i+lcp[i]-1))+1]--;
		for(int i=1;i<=len;++i)
		t[i]+=t[i-1];
		long long ans=1;
		for(int i=1;i<=len;++i)
		ans=ans*(t[i]+1)%mod;
		printf("%lld\n",ans);
	}
	
}
```

---

## 作者：zmx_wzx_JY (赞：21)

## 本题的~~指纹~~hash解法

---

博客链接[这里](https://blog.csdn.net/avenLJY/article/details/104668783)

----
作者由于只有CSPJ水平，所以根本想不出KMP或者什么自动机解法。只会hash+二分

虽然该算法复杂度为 $O(Tnlogn)$,但是常数小，可以通过。。

--------

考虑 $j>i$，如果 $i-j$ 这个字符串同时是串 $1--j$ 的前缀和后缀，那么我们可以认为位置 $i$ 对 $num[j]$ 做出了1的贡献。

然后我们枚举 $i$，看它可以对哪些 $num[j]$ 产生贡献。容易发现如果 $k<j$ 且 $i$对 $num[j]$ 产生了贡献，那么 $i$ 也一定会对$num[k]$ 产生贡献。因此我们可以二分出一个 $x$，使得 $i$ 对 $num[i]--num[k]$ 产生贡献，且不会对 $num[k+1]--num[n]$ 产生贡献。

然后考虑二分过程中如何 $check$ $i$是否对当前的 $mid$ （我设的 $mid$ 是 $j--i+1$ 的值即前/后缀的长度）产生贡献：用hash判断一下字符 $1--mid$ 组成的字符串和字符 $x--x+mid-1$组成的字符串是否相同就可以了。然后统计答案就用差分数组乱搞一下就好了。

枚举 $i$ 是 $O(n)$ 的，二分是 $(logn)$ 的，所以总复杂度为 $O(Tnlogn)$，因为常数小可以通过。

---
上文中的--可以理解为~，因为作者对markdown太不了解所以只能这么写了。

排版很丑，表述很垃圾，代码也丑，希望轻喷。

---
code:

```
#include<bits/stdc++.h> 
using namespace std;
const int N=1e6+5,mod=1e9+7,md=19260817;char c[N];int hash[N],n,pre[N],pows[N];
inline void work(int x){
	if(c[x]!=c[1])return ;int l=1,r=min(x-1,n-x+1);
	while(l<r){int mid=l+r+1>>1; 
		if((hash[x+mid-1]-(long long)hash[x-1]*(long long)pows[mid]%md+md)%md==hash[mid])l=mid;else r=mid-1;
	}++pre[x];--pre[x+l];
}
signed main(){
	int t;scanf("%d",&t);while(t--){
		scanf("%s",c+1);n=strlen(c+1);pows[0]=1;memset(pre,0,sizeof(pre)); 
		for(int i=1;i<=n;++i)hash[i]=(hash[i-1]*26+c[i]-'a')%md,pows[i]=pows[i-1]*26%md;
		for(int i=2;i<=n;++i)work(i);for(int i=1;i<=n;++i)pre[i]+=pre[i-1];
		long long ans=1;for(int i=2;i<=n;++i)ans=ans*((long long)pre[i]+1ll)%mod;
		printf("%lld\n",ans);
	}return 0; 
} 
```
代码中的hash就是hash值，pow[i]是26的i次方。然后pre是num的差分数组。个人认为代码很好理解。

---

## 作者：skylee (赞：16)

一开始先写了一个裸的KMP，在求next数组（f数组）的时候加了一个判断j<<1是否>i+1（若大于则说明有重叠部分），后来发现并不能这样做。因为这样会影响到后面next数组的求值。后来看了一个题解，里面的思路是重新做一遍求next的过程，同时再判断是否超过一半。

重点是在num数组，用来存储失配的次数。算是一个比较巧妙的地方吧。

程序参考了一个博客：http://blog.csdn.net/zhaoyh2000/article/details/54866734

```cpp
#define maxl 1000000+1
#define mod 1000000007
#include<string>
#include<iostream>
using namespace std;
int n,f[maxl],num[maxl];
string s;
int main() {
    ios::sync_with_stdio(false);
    cin>>n;
    while(n--) {
        cin>>s;
        f[0]=-1;
        f[1]=0;
        num[0]=0;
        num[1]=1;
        int j=0;
        unsigned long long ans=1ull;
        for(int i=1;i<(int)s.length();i++) {
            while(j>=0&&s[i]!=s[j]) j=f[j];
            f[i+1]=++j;
            num[i+1]=num[j]+1;
        }
        j=0;
        for(int i=1;i<(int)s.length();i++) {
            while(j>=0&&s[i]!=s[j]) j=f[j];
            j++;
            while((j<<1)>(i+1)) j=f[j];
            ans*=(unsigned long long)num[j]+1;
            ans%=mod;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：yingjz (赞：13)

## 题意

原题请看 <https://www.luogu.org/problemnew/show/P2375>

### 题目大意

给出一个字符串 $S$， 求 $\sum (num_i+1)$ ，其中对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $num_i$ 

## 题解

根据 $KMP$ 算法的相关知识，我们可以发现，对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀的串的集合就是 $A = \{next_i, next_{next_i}, \dots 0\}$. 

那么如果不考虑**不重叠**这个限制，我们可以得到一个 $cnt_i = |A|$，$cnt_i$ 可以通过 $cnt_i = cnt_{next_i} + 1$ 在线性时间复杂度内递推求出. 那么如何考虑这个限制呢?

我们可以发现，$Next_i$ 就相当于表示了点 $i$ 的父亲， 也就是说，所有 $Next_i$ 形成了一棵树（$Next_i$ 表示点 $i$ 的父亲），而我们要求的 $ans_i$ 就相当于点 $i$ 到根的路径上满足深度 $\leq \lfloor {i \over 2} \rfloor$的点的个数.  

那么就可以考虑**倍增后二分**，具体来说，就是对于每个点 $i$，找到 $pos = max\{x \in A \, | \, x \leq \lfloor {i \over 2}\rfloor\}$ ，那么 $num_i = cnt_{pos} - 1$，这个求解最大值的方法可以利用类似求 $LCA$ 的方法通过倍增来实现 $O(\log n)$ 的二分，具体实现可以看代码。这样总的时间复杂度就是 $O(n \log n)$ . 这个算法是**能够通过**的，但是需要一些卡常的技巧，比如……

> 倍增的数组可以是这样的：$fa[N][LOGN]$，也可以是这样的：$fa[LOGN][N]$
>
> 但是前者比后者慢**很多**！！！这点在 $N$ 比较大的时候尤为明显.
>
> **测试信息**
>
> 本人由于太懒，不想使用 $NOI \ Linux$，所以就用了**洛谷**。总计 $5$ 组数据，每组数据都是 $5$ 个长度为 $10^6$ 的全 $a$ 串。可以看到，时间相差了**接近 $3$ 倍**。
>
> ![https://cdn.luogu.com.cn/upload/pic/47252.png](https://cdn.luogu.com.cn/upload/pic/47252.png)

------

这样虽然可以卡过，但是不够优秀，这道题是有 $O(n)$ 的算法的. 可是优化的动机在哪里呢？

其实上面的算法中，倍增本质上是用来优化一个从点 $i$ 往上跳的过程，一个暴力往上跳的过程；如果这道题中这棵树就是普通的树（*指没有其它性质，节点编号也是乱的*），我们发现是很难优化到 $O(n)$ 的，也就是说，我们需要考虑一些 $Next_i$ 数组的特殊性质。

而我们要利用的性质，是一个非常显然而简单的性质：$Next_i \lt i$，这个性质由 $Next_i$ 的定义保证；这个性质在树上的表现是什么呢？就是**父亲节点的编号一定比其儿子节点的编号要小**，那么我们就可以这样做：

> 我们深搜树的同时，维护一个栈，中间有一个指针，它指向的数是栈中二倍不超过x的最大值。由于这个栈是单调递增的，所以指针只要左右移动。$ans_i$ 就是加入 $i$ 的那一刻，指针左边的数（包括指针所指的数）的个数+1.
>
> 参考 <https://www.luogu.org/blog/user31435/solution-p2375>, 写的非常好，用 $DFA$ 来分析此题

由于刚才那个性质我们可以保证中间那个指针只会向右移动，那么就可以做到在 $O(n)$ 时间复杂度内得到答案。



---

## 作者：WjNaG (赞：12)

## 题目描述：
输入N组数据，每组数据包含一个字符串S,对于每个S,求出它的num数组。

num数组的定义是：字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。

为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出所有(num[i]+1)的乘积，对1,000,000,007取模的结果即可。

## 题解：
这是一道很经典的KMP。还不会KMP的同学可以先看一下这篇[博客](https://blog.csdn.net/WjNaG/article/details/99238903)，这里就不重复介绍了

那么这道题与普通的KMP有什么不同点呢？

我们发现最大的不同点有两个，一个是原来的next[i]表示的是字符串前i位的最长相同前后缀，而num[i]却要求出相同前后缀的总数。第二个是，这里要求后缀和前缀不重叠。

发现了不同点，那么就只要在原来的KMP代码上对于这两个点分别改动一下就行了

大家都知道(next[i]>0)表示字符串前i位有相同前后缀（如果next[i]=0就表示没有），而它的值就是最长的一个前缀的结尾。

OK，那么第一个点就迎刃而解了

第2长的公共前后缀一定比最长的短吧

那它一定包含在S[0]-S[next[i]]里面吧

那么这里面最长的是哪个？

**next[next[i]]**

以此类推，next[i],next[next[i]],next[next[next[next[i]]].....都是相同前缀的结尾，只要它们不是0，就代表num[i]多一个，那么把num[i]++就行了
是不是感觉和manacher有点像？

这样能解决第一个点，但不能解决第二个，因为这样求出来的前后缀可能会有重叠

现在解决第二个点就很简单啦，找到第一个小于一半的num，
```cpp
while(k*2>j+1){
	k=next[k];
}
```
其它就和普通的KMP一样

完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
const long long mod=1e9+7;
int next[maxn],num[maxn];
int main(){
	int n;
	cin>>n;
	
	for(int i=0;i<n;i++){
		memset(next,0,sizeof(next));
		memset(num,0,sizeof(num));
		string s;
		cin>>s;
		int len=s.size();
		int k=0;
		num[1]=1; 
		for(int j=1;j<len;j++){
			while(k>0&&s[j]!=s[k]){
				k=next[k];
			}
			if(s[j]==s[k]) k++;
			next[j+1]=k;
			num[j+1]=num[k]+1;
		}
		k=0;
		long long int ans=1;
		for(int j=1;j<len;j++){
			while(k>0&&s[j]!=s[k]){
				k=next[k];
			}
			if(s[j]==s[k]) k++;
			while(k*2>j+1){
				k=next[k];
			}
			ans=ans*(num[k]+1)%mod;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```




#### 写作时间：
2019-8-17

---

## 作者：hwk0518 (赞：9)

有限状态自动机。

假设一个字符串长度为n，有点0,1,...,n，如果读入s[i]，就能从点i走到点i+1，这样读入一个字符串的某个子串，就能从某个点走到另一个点。

从next[i]向i连单向边，这样形成了一张图。除了点0的入度为0外，其余所有点的入度均为1.也就是说，这张图是以0为根的一棵树。

有一个串abacaba，我们知道next[3]=1，而读入子串a既能从0走到1，又能从2走到3.同样的，next[7]=3，而读入子串aba既能从0走到3，又能从4走到7.经观察，我们发现，next[next[7]]=1，而
从0走到1和从6走到7要经过相同的字符。

从以上经验出发，可以证明，如果从点i出发能走到x，原串的长度为x的前缀代表的字符串中，长度为i的前缀都和长度为i的后缀恰好相等。

这样，能使num[x]增加1的点必须满足两个条件：

<1>在树上，它是x的祖先。

<2>它的二倍不超过x。

我们深搜树的同时，维护一个栈，中间有一个指针，它指向的数是栈中二倍不超过x的最大值。由于这个栈是单调递增的，所以指针只要左右移动。num[x]就是加入x的那一刻，指针左边的数（包括指针所指的数）的个数+1.

可以证明，这个算法的复杂度是O(n)。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const long long mod=1e9+7;
int T,n;
int E,ot[2000005],ne[2000005],g[1000005],fa[1000005];
int stack[1000005],ltl,rtl;
long long ans;
char s[10000005];

void clear()
{
	int i;
	for(i=0;i<=n;++i) g[i]=0;
	E=0,ans=1;
}

void add(int u,int v)
{
	ot[++E]=v;
	ne[E]=g[u];
	g[u]=E;
}

void build()
{
	int i,j;
	fa[1]=0;
	add(0,1),add(1,0);
	for(i=1,j=0;i<n;++i)
	{
		while(j&&s[i]!=s[j]) j=fa[j];
		if(s[i]==s[j]) ++j;
		fa[i+1]=j;
		add(i+1,j),add(j,i+1);
	}
}

void dfs(int x,int fath)
{
	int p,to;
	if(x)
	{
		stack[++rtl]=x;
		while((stack[ltl]<<1)<=x) ++ltl;
		while((stack[ltl]<<1)>x) --ltl;
		ans*=ltl;
		ans%=mod;
	}
	for(p=g[x];p;p=ne[p])
	{
		to=ot[p];
		if(to==fath) continue;
		dfs(to,x);
	}
	--rtl;
}

int main()
{
	int i;
	scanf("%d",&T);
	while(T--)
	{
		clear();
		scanf("%s",&s);
		n=strlen(s);
		build();
		ltl=rtl=1,stack[ltl]=0;
		dfs(0,-1);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：灵乌路空 (赞：8)

更好的阅读体验：[My Blog](https://www.cnblogs.com/luckyblock/p/14250205.html)。

原题面：[「NOI2014」动物园](https://loj.ac/p/2246)。

>$n$ 组数据，每次给定一字符串 $s$。  
>定义 $\operatorname{num}_i$ 表示是 $s[1:i]$ 的前后缀，且长度不大于 $\left\lfloor\frac{i}{2}\right\rfloor$ 的字符串的个数。  
>求：  
>$$\prod_{i=1}^{n}\left(\operatorname{num}_i + 1\right)\pmod {10^9 + 7}$$
>$1\le n\le 5$，$1\le |s|\le 10^6$。  
>1S，512MB。

做法是自己 YY 的，效率被爆踩但是能过（  
记 $\mathbf{B}(i)$ 表示满足既是前缀 $s[1:i]$ 的真前缀，又是其真后缀的字符串组成的集合。  

先不考虑长度不大于 $\left\lfloor\frac{i}{2}\right\rfloor$ 这一限制，对于前缀 $s[1:i]$，显然 $\operatorname{num}_i$ 的值为 $|\mathbf{B}(i)|$。则显然有 $\operatorname{num}_{i} = \operatorname{num}_{\operatorname{fail}_i} + 1$，表示在 $\operatorname{num}_i$ 的基础上计入 $s[1:i]$ 的 $\operatorname{border}$ 的贡献。$\operatorname{num}$ 可在 KMP 算法中顺便求得。  
再考虑限制，若前缀 $s[1:i]$ 的 $\operatorname{border}$ 的长度大于 $\left\lfloor\frac{i}{2}\right\rfloor$，则需要不断跳 $\operatorname{fail}$，跳到**第一个**满足长度合法的位置 $j\in \mathbf{B}(i)$，再统计其贡献 $\operatorname{num}_j$。  
暴跳实现可以获得 50pts 的好成绩。

---

考虑优化，发现跳 $\operatorname{fail}$ 过程中对应的字符串长度会缩短（废话），考虑倒序枚举各位置 $i$，使得 $\left\lfloor\frac{i}{2}\right\rfloor$ 也呈现递减的状态。  
考虑暴跳过程，显然是由于某些 $\operatorname{fail}$ 的转移被重复统计，导致暴跳效率较低。考虑并查集的思路，将重复的转移进行路径压缩。  
设 $\operatorname{pos}_{i}$ 表示前缀 $s[1:i]$ 在跳 $\operatorname{fail}$ 之后对应的最大的**第一个**满足长度合法的 $\mathbf{B}$ 中的元素，初始值为 $\operatorname{pos}_i = i$。在暴力跳 $\operatorname{fail}$ 时，更新沿途遍历到的 $\operatorname{pos}$ 即可。  

这个路径压缩的复杂度我并不会证，但是感觉跑的还蛮快的= =  

```cpp
//知识点：KMP
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int kN = 1e6 + 10;
const int mod = 1e9 + 7;
//=============================================================
int n, ans, next[kN], num[kN], pos[kN];
char s[kN];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Init() {
  ans = 1;
  scanf("%s", s + 1);
  n = strlen(s + 1);
}
void KMP() {
  for (int i = 2, j = 0; i <= n; ++ i) {
    while (j > 0 && s[i] != s[j + 1]) j = next[j];
    if (s[i] == s[j + 1]) ++ j;
    next[i] = j;
    if (! j) continue ;
    pos[j] = j; //初始化
    num[j] = 1ll * (num[next[j]] + 1ll) % mod;
  }
}
int Find(int x_, int lth_) {
  if (pos[x_] <= lth_ / 2) return pos[x_];
  return pos[x_] = Find(next[pos[x_]], lth_); //路径压缩
}
//=============================================================
int main() {
  int t = read();
  while (t --) {
    Init(); KMP();
    for (int i = n; i >= 2; -- i) {
      pos[next[i]] = Find(next[i], i); //找到贡献位置
      if (! pos[next[i]]) continue ; //特判无贡献情况
      ans = 1ll * ans * (num[pos[next[i]]] + 1) % mod;
    }
    printf("%d\n", ans); 
  }
  return 0;
}
```

---

## 作者：exCat (赞：5)

## 前置知识

Border Theory ，KMP 。  

## 思路

1. 看到小于等于 ${|s|\over2}$ 的 border 个数，如果你学过 Border Theory，一定会想起一个定理，

   **$s$的所有长度大于 $\left \lfloor {|s|\over2} \right \rfloor $ 的 border 长度与  $|S|$  构成一个等差数列** 。 

2. 考虑有人没学过，我们可以严谨证明一下。证明这个定理之前需要先证明另一个定理。

   **若  $p,q$ 均为 $s$ 的周期，且 $p+q \le |s|$ ，则  $ \gcd(p,q)$ 也是  $s$ 的周期 。**（如果 $\forall i\le |s|-T,s_i=s_{i+T}$，则称 $T$ 为 $s$ 的周期。） 

   看起来很抽象其实证明比较简单，我们先设 $p>q$ 。

   当 $i\le q$ 时 ，$s_i=s_{i+p}=s_{i+p-q}$ 即 $s_i=s_{i+(p-q)}$ 。

   当 $i>q$ 时 ，$s_i=s_{i-q}=s_{i-q+p}$  即 $s_i=s_{i+(p-q)}$ 。

   上面都是根据周期的定义直接得到的，所以我们证到了 $p-q$ 也是  $s$ 的周期。根据辗转相减法可以知道 $\gcd(p,q)$ 也是 $s$ 的周期。（就是一直套娃，套到 $\gcd$ 中有一个为零时，另一个数就是 $\gcd$ 同时也是被证明的周期）

3. 好回到一开始的定理，我们先假设最长 border 长度为 $n-p$ ,另有一长度为 $n-q$  的 border 。那么 $p,q$ 是周期，且 $p,q\le {n\over 2}$ ,所以 $p+q\le n$ ,根据刚才证的定理可以知道 $\gcd(p,q)$ 也是周期，那么 $n-\gcd(p,q)$ 就是 border。又因为 $n-p$ 是最长 border，所以  $p\le \gcd(p,q)$ ，就可以直接得到 $p=\gcd(p,q)$ 也就是 $p\mid q$ ，这告诉我们所有可能的 $q$ 都是 $p$ 的倍数。由于限制只有长度大于 ${n\over 2}$ ，所以一定是连续存在的，就构成了一个等差数列。

4. 有了这个结论，回到这道题。我们只要找到小于等于 ${n\over 2}$ 的最长的 border 就可以快速算答案了（预处理出 border 的个数）。然后根据等差数列的性质，先用原长和最长 border 求出公差，就可以列式快速算了。这种写法的时间复杂就非常好理解是 $O(n)$ 的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10,mod=1e9+7;
char s[N];
int nxt[N],num[N],ans,jg[N];
void solve()
{
	cin>>(s+1);
	int n=strlen(s+1);
	num[1]=nxt[1]=0;
	for(int i=2,j=0;i<=n;i++)
	{
		while(s[j+1]!=s[i]&&j)j=nxt[j];
		if(s[j+1]==s[i])j++;
		nxt[i]=j;
        num[i]=num[j]+(j?1:0); 
	}
	ans=1;
	for(int i=2;i<=n;i++)
	{
		int k1=nxt[i],d=i-k1;	
		if(k1*2<=i){jg[i]=num[k1]+(k1?1:0),ans=ans*(jg[i]+1)%mod;continue;}//特判最长的小于等于n/2的情况
		int x=(2*k1-i)/(2*d),k2=k1-x*d;
		if(x*(2*d)!=2*k1-i)k2=nxt[k2];
		jg[i]=num[k2]+(k2?1:0);
		ans=ans*(jg[i]+1)%mod;
	}
	cout<<ans<<'\n';
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int t;cin>>t;
	while(t--)solve();
}
```

---

## 作者：bobble (赞：5)

[戳连接食用](http://www.cnblogs.com/tonylim/p/6919212.html)


感谢 [@ 某沙茶的OI代码库 ](http://my.csdn.net/qpswwww)   写的题解，主要思路(引用部分)来自[[省选前题目整理][BZOJ 3670][NOI 2014]动物园(KMP)](http://blog.csdn.net/qpswwww/article/details/44937169)


我们可以先用kmp求出next数组，然后我们构造一个cnt数组，

>cnt[i]=为满足既是前缀i的前缀，又是前缀i的后缀的子串个数(包括前缀i本身)，这个数组可以通过递推在O(n)时间内得出：


>然后我们可以通过cnt[]和next[]数组求得num[]数组。具体做法是，对于每个i>=2(i=1时显然num[i]=0)，通过沿着next[]指针向前走找到最大的j,j满足前缀j既是前缀i的前缀，也是它的后缀，且2j<=i(即题面中所限制的前缀和后缀不重叠)，那么num[i]=cnt[j]

//注意：前缀i指的是前i个字符组成的字符串

cnt[1]=1  //前缀1只有本身

cnt[i]=cnt[next[i]]+1(1<i<=len) //前缀i的最长匹配next[i]+他自身

胡弄一番证明——:

∵当前缀i的前缀j和他长度为j的后缀不重叠

∴前缀j的长度为u后缀=前缀i的长度为u的后缀   //当1<=u<=cnt[j]

又∵前缀j的长度为u后缀=前缀j的长度为u前缀=前缀i的长度为u的前缀

∴前缀i的长度为u的前缀=前缀i的长度为u的后缀=前缀j的长度为u前缀(这个的种数也就是cnt[j])=前缀j的长度为u后缀

又∵我们找到的j满足2j<=i

∴num[i]=cnt[j]


然后我们就得到了一个50分的做法with TLE(注意ans为int64)


```pascal

program no;
const
  m=1000000007;
var
  b:ansistring;
  ans:int64;
  n,p,i,j,l,num:Longint;
  next,cnt:array[0..1000001] of longint;

procedure get_next_and_cnt;
begin
     j:=0;
    next[1]:=0;  cnt[1]:=1;
    for i:= 2 to l do
    begin
      while (j>0) and (b[j+1]<>b[i]) do j:=next[j];
      if b[j+1]=b[i] then inc(j);
      next[i]:=j;              //kmp计算next
      cnt[i]:=cnt[next[i]]+1;  //顺带计算cnt
    end;
end;

procedure cal;
begin
    ans:=1;
    for i:= 2 to l do
      begin
          j:=next[i];
          while 2*j>i do j:=next[j];  //查找最大的符合条件的J
          num:=cnt[j];
          ans:=((ans mod m)*((num+1) mod m)) mod m;
      end;
end;

begin
   //assign(input,'1.in'); assign(output,'1.out');
   reset(input); rewrite(output);

   readln(n);
   for p:= 1 to n do
   begin
     readln(b);   l:=length(b);

     get_next_and_cnt();
     cal();

     writeln(ans);
   end;

   close(input);  close(output);
end.

```

于是下面是100分的做法：

我们可以把查找最大的符合条件的J的部分改为像kmp中的一样：


 ```pascal

 while(j<>0) and (b[j+1]<>b[i]) do j:=next[j];
            if(b[j+1]=b[i]) then inc(j);

```

我们在循环到i时当前的j是不是可以重前一次的最长的不重叠的j得到呢？

答案是肯定的,要么小于等于上一次的j，要么等于上一次的j+1

===
猜想：会不会是j+2或更大呢？


不，可以用反证法

假设第i−1次循环得到j为j,这次(第i次)最终得到的为j+2

那么可以发现前缀i的前缀j+2=他长度为j+2的后缀

那么前缀j+2=前缀i的长度为j+2的后缀的长度为j+1的前缀(结束为i−1)

又因为我们得到的j+2满足不重叠，那么j+1自然也不会重叠

那么我们可以得到前缀i−1的的最优j为j+1

这样就冲突啦，于是这是不可能的

=====
然后我们每次求j的操作就接近O(1),那cal()也就接近O(n)啦！











```cpp
program no;
const
  m=1000000007;
var
  b:ansistring;
  ans:int64;
  n,p,i,j,l,num:Longint;
  next,cnt:array[0..1000001] of longint;
procedure get_next_and_cnt;
begin
     j:=0;
    next[1]:=0;  cnt[1]:=1;
    for i:= 2 to l do
    begin
      while (j>0) and (b[j+1]<>b[i]) do j:=next[j];
      if b[j+1]=b[i] then inc(j);
      next[i]:=j;
      cnt[i]:=cnt[next[i]]+1;
    end;
end;
procedure cal;
begin
    ans:=1;j:=0;
    for i:= 2 to l do
      begin
        while(j<>0) and (b[j+1]<>b[i]) do j:=next[j];
            if(b[j+1]=b[i]) then inc(j);            //修改的地方
          while 2*j>i do j:=next[j];
          num:=cnt[j];
          ans:=((ans mod m)*((num+1) mod m)) mod m;
      end;
end;
begin
  // assign(input,'1.in'); assign(output,'1.out');
   reset(input); rewrite(output);
   readln(n);
   for p:= 1 to n do
   begin
     readln(b);   l:=length(b);
     get_next_and_cnt();
     cal();
     writeln(ans);
   end;
   close(input);  close(output);
end.
```

---

## 作者：liaoy14866 (赞：5)

# 其实这题可以用扩展KMP #
学了扩展KMP想找一道模板题，发现在luogu搜索，并没有扩展KMP的标签。随便点了一个KMP的，结果发现可以做……

有兴趣的同学可以参考这个博客：[扩展KMP](https://www.cnblogs.com/dilthey/p/8620119.html)
（并不是我的博客/逃）

扩展KMP可以求出$extend$数组，其中$extend[i]$表示模式串$S$与主串$T$的后缀$T[i..lenT]$的最长公共前缀。
$$extend[i]=lcp(S,T[i..lenT])$$
求$extend$数组的过程会引入一个$next$数组（类似于KMP，但是这个$next$数组与KMP的next数组不同），他表示$S$与$S$的后缀$S[i..lenS]$的最长公共前缀。
$$next[i]=lcp(S,S[i..lenS])$$
# 我们只需要$next$数组就好了。 #

对于每一个位置$i$，我们考虑计算：以 $i$ 作为  $num$数组计数规则里的那个后缀 的起点位置 时 对答案的贡献。

很简单，取$len=min(i-1,next[i])$（以1为字符串起始下标）也就是$i$位置能对$num$数组贡献到的长度，那么$num[i..i+len-1]$都要+1。

因此我们只需要做$O(n)$次区间+1，最后得到原数组。这个可以用差分数组解决。

exkmp代码如下：

```cpp
void exkmp() {
	//next[i]表示a[i..lena]与a的最长公共前缀
	int vi,vj;
	ne[1]=lena;
	for(vi=1; an[vi]==an[vi+1]&&vi<lena; vi++);
	ne[2]=vi-1;
	int po=2;
	for(vi=3; vi<=lena; vi++)
		if(vi+ne[vi-po+1]<po+ne[po])ne[vi]=ne[vi-po+1];
		else {
			vj=po+ne[po]-vi>=1?po+ne[po]-vi+1:1;
			for(; an[vj]==an[vi+vj-1]&&vi+vj-1<=lena; vj++);
			ne[vi]=vj-1;
			po=vi;
		}
}
```

本题核心代码：
```cpp
int num[1000010];
void ADD(int l,int r){
	num[l]++;
	num[r+1]--;
}
void work() {
	int vi;
	exkmp();
	int tmp;
	for(vi=2;vi<=lena;vi++){
		tmp=min(vi-1,ne[vi]);
		ADD(vi,vi+tmp-1);
	}
	for(vi=1;vi<=lena;vi++)num[vi]+=num[vi-1];
	LL ans=1;
	for(vi=1;vi<=lena;vi++)ans=ans*(num[vi]+1)%intp;
	printf("%lld\n",ans);
}
```

以上。

---

## 作者：Drinkkk (赞：4)

【题目描述】

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解KMP算法。

园长：“对于一个字符串S，它的长度为L。我们可以在O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？”

熊猫：“对于字符串S的前i个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例S为abcababc，则next[5]=2。因为S的前5个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0，next[4] = next[6] = 1，next[7] = 2，next[8] = 3。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)的时间内求出next数组。

下课前，园长提出了一个问题：“KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。例如S为aaaaa，则num[4] = 2。这是因为S的前4个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出num数组呢？

特别地，为了避免大量的输出，你不需要输出num[i]分别是多少，你只需要输出所有num[i]的乘积，对1,000,000,007取模的结果即可。

【输入输出格式】

- 输入格式

第1行仅包含一个正整数n ，表示测试数据的组数。随后n行，每行描述一组测试数据。每组测试数据仅含有一个字符串S，S的定义详见题目描述。数据保证S 中仅含小写字母。输入文件中不会包含多余的空行，行末不会存在多余的空格。

- 输出格式

包含 n 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,007 取模的结果。输出文件中不应包含多余的空行。

【输入输出样例】

- 输入样例
```
3
aaaaa
ab
abcababc
```

- 输出样例
```
36
1
32
```

$100$分（满分）思路：

既然题目里提到了KMP算法，那么我们就来讲讲什么是KMP算法。

> KMP（Knuth Morris Pratt）算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。如果我们将一个长度为$n$的字符串和一个长度为$m$的字符串相匹配的话，时间复杂度为$O(n+m)$。

上面的引用部分的内容摘自[百度百科](https://baike.baidu.com/)和[@fstqwq](https://www.luogu.org/space/show?uid=12621)的讲义。

下面将给出一个例子：

利用信息？
```
ABCEABCDABEABCDABCDABDE
ABCDABD
```
继续匹配：
```
ABCEABCDABEABCDABCDABDE
    ABCDABD
```
再继续匹配：
```
ABCEABCDABEABCDABCDABDE
        ABCDABD
```
接着匹配：
```
ABCEABCDABEABCDABCDABDE
           ABCDABD
```
发现最佳匹配~
```
ABCEABCDABEABCDABCDABDE
               ABCDABD
```

上面的例子摘自洛谷讲义，作者为洛谷网校的讲师[@fstqwq](https://www.luogu.org/space/show?uid=12621)。

我们用$next[i]$来表示有字符串中的第$1$个字符到第$i$个字符所组成的子串中前缀与后缀完全相同的最大长度（不包含它本身）。

例如对于字符串$abcdaba$，$next[1]=next[2]=next[3]=next[4]=0$，$next[5]=next[7]=1$，$next[6]=2$。

你可以在[这里](https://www.luogu.org/problemnew/show/P3375)检验你的KMP算法的正确性。

下面我将给出KMP算法的模板。

```cpp
#include <cstdio>
#include <cstring>
char sta[1000001],stb[1000001];
int next[1000001];
int main()
{
	scanf("%s %s",sta+1,stb+1);
	next[1]=0;
	int lena=strlen(sta+1),lenb=strlen(stb+1);
	int k=0;
	for(int i=2;i<=lenb;i++)
	{
		while(k!=0 && stb[i]!=stb[k+1])
		{
			k=next[k];
		}
		if(stb[i]==stb[k+1])
		{
			k++;
		}
		next[i]=k;
	}
	k=0;
	for(int i=1;i<=lena;i++)
	{
		while(k!=0 && sta[i]!=stb[k+1])
		{
			k=next[k];
		}
		if(sta[i]==stb[k+1])
		{
			k++;
		}
		if(k==lenb)
		{
			k=next[k];
			printf("%d\n",i-lenb+1);
		}
	}
	for(int i=1;i<=lenb;i++)
	{
		printf("%d ",next[i]);
	}
	return 0;
}
```
$100$分代码：
```cpp
#include <cstdio>
#include <cstring>
long long next[1000001],num[1000001];
char sta[1000001];
int main()
{
	long long now=1,t=0;
	scanf("%lld",&t);
	while(now<=t)
	{
		scanf("%s",sta);
		long long lena=strlen(sta),k=0;
		next[0]=-1,next[1]=0;
		num[0]=0,num[1]=1;
		long long ans=1;
		for(long long i=1;i<=lena-1;i++)
		{
			while(k>=0 && sta[i]!=sta[k])
			{
				k=next[k];
			}
			next[i+1]=++k;
			num[i+1]=num[k]+1;
		}
		k=0;
		for(long long i=1;i<=lena-1;i++)
		{
			while(k>=0 && sta[i]!=sta[k])
			{
				k=next[k];
			}
			k++;
			while((k*2)>(i+1))
			{
				k=next[k];
			}
			ans*=num[k]+1;
			ans%=1000000007;
		}
		printf("%lld",ans);
		if(now<=t-1)
		{
			printf("\n");
		}
		now++;
	}
	return 0;
}
```

---

## 作者：假装思考 (赞：2)

【题意】

定义Num[i]为字符串S的前缀S[1~i]中不重叠的相同前后缀的个数。给定S，求所有(Num[i]+1)的乘积。L<=10^6

【分析】

这题是对KMP的深入理解了。首先我们先明确一下Next数组的含义，Next[i]数组的意思是字符串S的前缀S[1~i]中的最长的相同前后缀的长度（前缀位置不等于后缀），然后我们用KMP求Next数组的方法其实是利用已有信息减少重复判断，对于每一个字符来说，Next[i]是它最长的相同前后缀的长度，Next[Next[i]]则是它次长的相同前后缀的长度。求当前Next的时候每次用Next往前跳的每一个都可以保证到上一位为止前缀等于后缀，并且我们的一个j是一个类似于全局的变量，它保存的是当前上一位的后缀的最大匹配的前缀长度，然后我们只是要用j尽早找到一个，也就是最长的那一个来使得当前位满足，所以我们跳到的第一个能满足当前位置的就是最佳答案。更加本质的是，其实如果我们继续往前跳，是有可能找到另一个更短的相同前后缀的。然后对于本题而言，我们先求出Next数组，然后有多少个迭代的Next我们就相当于是有多少个相同的前后缀，所以我们可以在求Next的同时求出每个前缀可以重叠的前缀后缀的数量（前缀位置不等于后缀），不妨称其为Cnt[i]。然后我们其实只要找等于后缀的一个前缀中不超过前缀长度一半的那个，它的Cnt就是我们这个前缀的Num。本质就是，字符串S的前缀中等于S某个后缀的那个前缀的后缀也是S的一个前缀等于后缀的后缀，并且所有都是。

【代码】
```
#include <bits/stdc++.h>
#define For(i, a, b) for(int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for(int i = (a); i >= (b); --i)
#define mem(A, Pos) memset(A, Pos, sizeof(A))
#define LL long long
#define MaxN 2000001
#define Mod 1000000007
using namespace std;
LL Ans = 1;
int N, T, Next[MaxN], Cnt[MaxN];
char S[MaxN];
int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%s", S + 1); N = strlen(S + 1);
        Cnt[1] = 1; 
        for(int i = 2, j = 0; i <= N; ++i) {
            while(j > 0 && S[i] != S[j + 1]) j = Next[j];
            if(S[i] == S[j + 1]) ++j;
            Next[i] = j;
            Cnt[i] = Cnt[j] + 1;
        }
        Ans = 1;
        for(int i = 1, j = 0; i <= N; ++i) {
            while(j > 0 && S[i] != S[j + 1]) j = Next[j];
            if(S[i] == S[j + 1]) ++j;
            while((j << 1) > i) j = Next[j];
            Ans = (1ll * Ans * (Cnt[j] + 1)) % Mod;
        }
        printf("%lld\n", Ans);
    }
    return 0;
}
```

---

## 作者：caidzh (赞：0)

~~各种做法大集合~~

考虑$\text{KMP}$过程中$\text{next}$数组的意义：

$next_i$表示原串中$[1,i]$中的最长的前缀，使其等于$[1,i]$的后缀

所以如果我们把一个点$i$连向$next_i$所指的位置，那么如果我们不考虑不重叠条件的话，一个点的答案就是它在这个$\text{KMP}$自动机中的深度

为什么说深度呢？由于我们一个点指向比它长度更小的前缀连边，所以这东西其实是一棵树

讲道理这个自动机就是$\text{AC}$自动机只有一个格式串时的情况，我们上面连的边是$\text{AC}$自动机的$fail$指针，这都是好理解的

如果考虑重叠条件的话，我们要在一个点$i$到根的链上，找到最深的点$j$，使得$j<\lfloor\frac{i}{2}\rfloor$

一种暴力的想法是搜进自动机的时候用一个树状数组，然后查询前缀和，这样子会带一个$log$，不一定跑得过去

或者你考虑沿着父边跳上去一个个$check$，然后用倍增优化一下，当然这个复杂度也不大对

注意到一个点子树内的答案肯定是大于等于这个点的，也就是单调的，因此也可以用一个栈来记录这个点到根的路径，用一个指针移动一下记录答案，这也是对的，复杂度就是线性的了

当然还有一种更好写的做法就是考虑求$next$数组时记录不考虑不重叠条件时的答案，然后再做一遍求$next$数组的操作，并且保证指针不超过当前处理前缀的一半的位置，这样子也是对的，复杂度证明的话类似$\text{KMP}$

~~于是代码就是那个好写的做法了~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=1000010,mod=1e9+7;
int T,n,num[maxn],ans,nxt[maxn];char str[maxn];
int main()
{
	T=read();
	while(T--){
		scanf("%s",str+1);n=strlen(str+1);int pl=0;num[1]=1;
		for(int i=2;i<=n;i++){
			while(pl&&str[pl+1]!=str[i])pl=nxt[pl];
			if(str[pl+1]==str[i])pl++;nxt[i]=pl;num[i]=num[pl]+1;
		}ans=1;pl=0;
		for(int i=2;i<=n;i++){
			while(pl&&str[pl+1]!=str[i])pl=nxt[pl];
			if(str[pl+1]==str[i])pl++;
			while((pl<<1)>i)pl=nxt[pl];
			ans=1ll*ans*(num[pl]+1)%mod;
		}cout<<ans<<endl;
	}return 0;
}
```


---


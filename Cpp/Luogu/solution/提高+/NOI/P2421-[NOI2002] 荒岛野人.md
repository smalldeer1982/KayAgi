# [NOI2002] 荒岛野人

## 题目描述

克里特岛以野人群居而著称。岛上有排列成环行的 $m$ 个山洞。这些山洞顺时针编号为 $1,2,\dots ,m$ 。岛上住着 $n$ 个野人，一开始依次住在山洞 $C_1,C_2,\dots ,C_n$中，以后每年，第 $i$ 个野人会沿顺时针向前走 $P_i$ 个洞住下来。

每个野人 $i$ 有一个寿命值 $L_i$，即生存的年数。

下面四幅图描述了一个有 $6$ 个山洞，住有三个野人的岛上前四年的情况。三个野人初始的洞穴编号依次为 $1,2,3$；每年要走过的洞穴数依次为 $3,7,2$；寿命值依次为 $4,3,1$。

![](https://cdn.luogu.com.cn/upload/pic/15476.png)

奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？

## 说明/提示

$1\leq N\leq 15$，$1\leq C_i,P_i\leq 100$，$0\leq L_i\leq 10^6$  

保证 $M\leq 10^6$  




## 样例 #1

### 输入

```
3
1 3 4
2 7 3
3 2 1```

### 输出

```
6```

# 题解

## 作者：Siyuan (赞：52)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-NOI-2002-Savage/)

---

## Description

> 题目链接：[Luogu 2421](https://www.luogu.org/problemnew/show/P2421)

克里特岛以野人群居而著称。岛上有排列成环行的 $M$ 个山洞。这些山洞顺时针编号为 $1,2,\dots,M$。岛上住着 $n$ 个野人，一开始依次住在山洞 $C_1,C_2,\dots,C_n$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $P_i$ 个洞住下来。每个野人i有一个寿命值 $L_i$，即生存的年数。

奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？数据保证有解，$M$ 的值不大于 $10^6$。

数据范围：$1\le n\le 15$，$1\le C_i,P_i\le 100$，$0\le L_i\le 10^6$

------

## Solution

我们形象化地描述题意： 

求最小的 $M$ 使得对于任意的 $i,j$ 使得如下同余方程无解：
$$C_i+xP_i\equiv C_j+xP_j\pmod M\quad (x>\min(L_i,L_j))$$
我们发现题目中保证 $M\le 10^6$，那么我们可以考虑枚举 $M$ 并对这 $n^2$ 个同余方程利用 $\text{exgcd}$ 来求解并判断。

**时间复杂度**：$O(Mn^2\log C_i)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=20;
int n,s[N],p[N],l[N];

int exgcd(int a,int b,int &x,int &y) {
	if(!b) {x=1,y=0;return a;}
	int d=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return d;
}
bool check(int m) {
	for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) {
		int a=p[i]-p[j],b=m,c=s[j]-s[i],x,y;
		int d=exgcd(a,b,x,y);
		if(c%d) continue;
		a/=d,b/=d,c/=d;
		if(b<0) b=-b;
		x=(x*c%b+b)%b;
		if(x<=l[i]&&x<=l[j]) return 0;
	}
	return 1;
}
int main() {
	scanf("%d",&n);
	int mx=0;
	for(int i=1;i<=n;++i) scanf("%d%d%d",&s[i],&p[i],&l[i]),mx=std::max(mx,s[i]);
	for(int i=mx;;++i) if(check(i)) return printf("%d\n",i),0;
	return 0;
}

```



---

## 作者：lcjqwq (赞：35)

[洛谷题目链接](https://www.luogu.org/problemnew/show/P2421)

[bzoj题目链接](https://www.lydsy.com/JudgeOnline/problem.php?id=1407)

[博客同题题解](https://www.cnblogs.com/acfunction/p/8858577.html)

------------
**题目大意**：给定$n$组$ C_i, P_i, L_i $，求最小的$M$使得对于任意的$i,j (1 \leq i, j \leq n)$
$$C_i + P_i \times x \equiv C_j + P_j \times x \pmod M$$

不成立

其中$x$为正整数（就是走了$x$天相遇）

（这里的不成立指的是无解或者解出来的 $x<\min(L_i,L_j)$,即相遇之前有一人死掉。）

**分析**

从小到大枚举$M$（**注意没有单调性不能二分**）

原式可变形为
$$C_i + P_i \times x = C_j + P_j \times x +M \times y$$
$$(P_i-P_j)\times x - M \times y = C_j-C_i $$
若无解，则此时的$M$为所求

若有解，用扩展欧几里得解出该方程的最小解$x_{min}$。
如果$x_{min}>\min(L_i,L_j)$，问题解决；否则继续枚举

[代码戳这里](https://www.cnblogs.com/acfunction/p/8858577.html)

---

## 作者：BinDir0 (赞：11)

本题珂以转换成一个式子

即求Ci + Pi × x ≡ Cj
+
Pj
× x (mod M)
的最小答案是否大于寿命最小值

以人数为最小值开始枚举山洞数，用扩展欧几里得计算最优答案是否大于寿命

若不大于则山洞数+1

P . S .若该式无解则当最优解大于寿命处理
```cpp
#include<bits/stdc++.h>
using namespace std;
bool f;
int c[20],p[20],l[20],n,x,y,x0,x1,maxx,anss;
int gcd(int a,int b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
void exgcd(long long a,long long b)
{
    if(b==0)
    {
        x0=1;
        x1=0;
        return;
    }
    exgcd(b,a%b);
    int v=x0;
    x0=x1;
    x1=v-(a/b)*x1;
    return;
}
bool check(int m)
{
    for(register int i=1;i<n;i++)
    {
        for(register int j=i+1;j<=n;j++)
        {
            int v=p[j]-p[i],s=c[i]-c[j];
            if(v<0)
            {
                s=-s;
                v=-v;
            }
            int g=gcd(v,m);
            if(s%g!=0)
            continue;
            exgcd(v,m);
            int mm=m/g;
            anss=((x0*(s/g))%mm+mm)%mm;
            if(anss<=l[i]&&anss<=l[j])
            return false;
        }
    }
    return true;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>c[i]>>p[i]>>l[i];
        maxx=max(maxx,c[i]);
    }
    for(register int m=maxx;;m++)
    {
        if(check(m))
        {
            cout<<m;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：云岁月书 (赞：8)

# P2421 [NOI2002]荒岛野人



先将题面转换成具体数学题目，即：

 $\text{定义野人初始山洞的集合}\ \mathrm{C}\ \text{,野人一年走过山洞数量的集合}\ \mathrm{P}\ \text{,野人寿命的集合}\ \mathrm{L}\ \text{。}$

$$\text{求一个最小的}\ M\ \text{满足对}\ \forall \ x_i,x_j\in \mathrm{C},p_i,p_j\in \mathrm{P},L_i,L_j\in\mathrm{L},a\in \left[0,min\left(L_i,L_j\right)\right]\ \text{均有}\  x_i+ap_i\neq x_j+ap_j\pmod M\ \text{。}$$

观察这个方程，我们发现其并不好处理，我们移项处理一下能得到：

$$\boxed{\Large a(p_i-p_j) \neq (x_j-x_i) \pmod{M}\ a\in \left[0,min\left(L_i,L_j\right)\right]}$$

对于任意两野人，若 $M$ 满足在这个式子中无解，则 $M$ 即可以满足这两个人永远不相遇。

这个方程长得很像 $Exgcd$ ，而它事实上如果中间是一个等号的话也确实是一个 $Exgcd$。

但是怎么解出 $M$ ？

先忽略一下 $a$ 的取值限制，我们进一步把它化为如下式子：

$$\Large a(p_i-p_j)+bM \neq (x_j-x_i)$$

我们又有：

$$\Large ax+by = k*gcd(a,b),k\in\mathrm{Z}$$

证明：由 $\large gcd(a,b)|ax,gcd(a,b)|by$  故 $\large gcd(a,b)|(ax+by)$ 。~~其实就是裴蜀定理。~~

综上既若 $\large gcd(p_i-p_j,M)|(x_i-x_j)\ (1)$ ，则 $\large M$ 不合法。

仔细考虑一下，可以发现即使 $a$ 有限制时，若式子不满足 $(1)$ ,$M$ 也一定是合法的。

若式子满足 $(1)$ 我们就要检验一下,我们将其化为：

$$\Large {a(p_i-p_j)}+{bM}={(x_j-x_i)}$$

于是我们可以愉快地使用 $Exgcd$ 解这个方程了，若 $a$ 的最小正整数解大于 $min\left(L_i,L_j\right)$ ，则其解合法，否则不合法。

综上我们从 $n$ 开始枚举，一直到 $M$,并检验，就可以得到答案所要求的解。

时间复杂度 $\Theta(n^2M\log{p_i})$ 。

$AC$ 代码:

~~~c++
# include <cstdio>
# include <algorithm>
# define reg register

typedef long long LL;

inline int Read()
{
	int x = 0;char ch = getchar();
	
	while(ch < '0' || ch > '9') ch = getchar();
	
	while(ch <= '9' && ch >= '0'){x = x*10 + (ch ^ 48);ch = getchar();}
	
	return x;
}

inline int exgcd(int a,int b,int& x,int& y)//我们可以在求Exgcd的同时求出其gcd
{
	if(b == 0){x = 1;y = 0;return a;}
	
	int d = exgcd(b,a % b,y,x);
	
	y -= a / b * x;
	
	return d;
}

inline int ABS(const int x){return x < 0 ? -x : x;}
inline int Min(const int x,const int y){return x < y ? x : y;}
inline int Max(const int x,const int y){return x > y ? x : y;}

int c[42],p[42],L[42],n,st;

inline bool check(const int M)
{
	int a,b;
	
	for(reg int i = 1; i <= n ; ++i)
		for(reg int j = i+1; j <= n ; ++j)
		{
			int pij = p[i]-p[j],m = M,xji = c[j]-c[i];
			
			int d = exgcd(pij,m,a,b);
			
			if(xji%d) continue;
			
			xji /= d;m = ABS(m/d);//要特别注意这里可能是负数。 
			
			a = (a*xji%m + m) % m;//将a还原成最小正整数解
			
			if(a <= Min(L[i],L[j])) return false;
		}
		
	return true;
}

int main()
{
	n = Read();
	
	for(reg int i = 1; i <= n ; ++i) {st = Max(c[i] = Read(),st);p[i] = Read();L[i] = Read();}
	
	for(reg int i = st;  ; ++i) if(check(i)) {printf("%d\n",i);break;}
	
	return 0;
}
~~~







---

## 作者：chuzhitairan (赞：6)

## 思路
***
***
看一下数据范围，发现小得可怜，以至于我们可以枚举$m$时再枚举每对野人。于是这个题就变成了处理$n^2m$次[P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)，只用每次判断一下，如果有两个野人可以活着相遇的话，就说明这个$m$不合适；如果没有，输出$m$就行了。  
  
下面是AC代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,C[20],P[20],L[20];
int e_gcd(int a,int b,int& x,int& y)
{
	if(!b) {x=1,y=0;return a;}
	int ans=e_gcd(b,a%b,x,y);
	int t=x;x=y;y=t-(a/b)*y;
	return ans;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>C[i]>>P[i]>>L[i];
	for(int i=C[n];i<=1000000;i++)
	{
		int flag=0;
		for(int j=1;j<n;j++)
		{
			for(int k=j+1;k<=n;k++)
			{
				int a=P[k]-P[j],b=i,c=C[j]-C[k],x,y,gcd,minx;
				if(a<0) a=-a,c=-c;
				gcd=e_gcd(a,b,x,y);
				if(c%gcd!=0) continue;
				minx=((x*(c/gcd))%(b/gcd)+(b/gcd))%(b/gcd);
				if(minx<=min(L[j],L[k])) {flag=1;break;}
			}
			if(flag) break;
		}
		if(!flag) {printf("%d",i);break;}
	} 
}
```  
## 接下来是对刚学的扩展欧几里得的一点整理
***  
***
以这题为例,我们首先从基本问题出发：判断两个野人$i$和$j$何时相遇（能否相遇），其实就是求解方程  
$$
(C_i+tP_i)-(C_j+tP_j)=km
$$
其中$t$为时间。也就是说在环形跑道上，相遇就是距离差为跑道周长的倍数时。把这个方程稍微变形一下得到  
$$
t(P_j-P_i)+km=C_i-C_j
$$
如果我们设未知数$t$和$k$分别为$x$和$y$，常数$(P_j-P_i)$为$a$，$m$为$b$，$(C_i-C_j)$为$c$的话，可以发现这就是一个二元一次的不定方程，即
$$
ax+by=c
$$
那么要解决这题，我们需要知道这个方程：  
* **是否有整数解**
* **如果有，最小非负整数解是多少**  
  
### 我们先来看第一个问题
***
如果有整数解，那么
$$
\begin{aligned}
c &= ax+by\\
  &= \gcd(a,b)\cdot(a_1x+b_1y)
\end{aligned}
$$
说明$c$是$\gcd(a,b)$的倍数。注意这里是有整数解的充分条件，即要有整数解$c$就必须是$\gcd(a,b)$的倍数。那我们干脆把$c$替换成$\gcd(a,b)$，解出来$x$和$y$后再扩倍。然后接下来的过程就十分的神奇，首先我们把$a$换成$b$，$b$换成$a\mod b$，即$a-(a/b) \cdot b$（这里的除号“/”表示结果向下取整），得到新的方程
$$
bx+(a-(a/b) \cdot b)y=\gcd(a,b)
$$
变形一下
$$
ay+b(x-(a/b) \cdot y)=\gcd(a,b)
$$
对比一下原来的方程，我们惊讶地发现因为常数都一样，所以我们可以**由现在方程的解推导出原方程的解**，而如果继续这个过程，这不就是辗转相除嘛！辗转相除的结果大家都知道，是$a$变成$\gcd(a,b)$，$b$变成$0$，而方程
$$
\gcd(a,b) \cdot x+0 \cdot y=\gcd(a,b) 
$$
的解就很显然了，是
$$
\begin{cases}
x=1\\
y=0
\end{cases}
$$
根据这个解，我们就可以，也肯定可以倒推出原方程的解了。现在再看这段代码  
```cpp
int e_gcd(int a,int b,int& x,int& y)
{
	if(!b) {x=1,y=0;return a;}
	int ans=e_gcd(b,a%b,x,y);
	int t=x;x=y;y=t-(a/b)*y;
	return ans;
}
```
其实就是求$\gcd(a,b)$以及方程的一组特解的函数。当然最后别忘了乘上$\dfrac{c}{\gcd(a,b)}$。而如果$c$不是$\gcd(a,b)$的倍数，也就说明方程无整数解。
### 再来看第二个问题
***
求出了一组特解，再如何找到最小非负整数解呢？假设我们有
$$
\begin{cases}
ax_0+by_0=c\\
ax\ \ +by\,\,=c
\end{cases}
$$
一式减二式，得
$$
\begin{aligned}
a(x_0-x)+b(y_0-y)&=0\\
a(x_0-x)&=-b(y_0-y)\\
\dfrac{a}{\gcd(a,b)}(x_0-x)&=-\dfrac{b}{\gcd(a,b)}(y_0-y)
\end{aligned}
$$
注意到$\dfrac{a}{\gcd(a,b)}$与$\dfrac{b}{\gcd(a,b)}$互质，所以$(x_0-x)$是$\dfrac{b}{\gcd(a,b)}$的倍数，即
$$
\begin{aligned}
x_0-x&=k\dfrac{b}{\gcd(a,b)}\\
x_0&=k\dfrac{b}{\gcd(a,b)}+x
\end{aligned}
$$
那么$x$的**最小非负整数解**就是特解$x_0 \mod \dfrac{b}{\gcd(a,b)}$了。当然因为$x_0$可能是负数，所以代码里就长这样子  
```cpp
minx=((x*(c/gcd))%(b/gcd)+(b/gcd))%(b/gcd);
```
最后一点要注意的，欧几里得算法求最大公约数只能针对两个非负整数，所以有了这句  
```cpp
if(a<0) a=-a,c=-c;\\b绝对是正数
```
***
至此，我学到的扩展欧几里得算是梳理完了（欢迎大佬来补充），当然这个算法还有更多的应用，如乘法逆元、线性同余方程等，解不定方程算是最基础的一种了，必须牢牢掌握ヾ(•ω•`)o

---

## 作者：YoungNeal (赞：6)

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9251301.html)效果更佳哦~

## Solution

注意到答案不大于 $10^6$，考虑从小到大枚举答案。

对于枚举的一个答案 $ans$，我们希望对于每个满足 $c_i+k\times p_i\equiv c_j+k\times p_j\;(mod\;ans)$ 的 $k$ ,都要 
$k>\min(l[i],l[j])$

于是可以 $\mathcal {O(n^2)}$ 的枚举点对判断。

如何判断呢？再推一下式子：

$$c_i+k\times p_i=c_j+k\times p_j+m\times ans$$

$$k\times(p_i-p_j)+m\times ans=c_j-c_i$$

于是式子就愉快的变成了 $exgcd$ 标准形式。

然后求 $k$ 就好了。

ps：注意如果无解并不代表不满足情况，反而是满足情况。因为无解就是这俩货这辈子都碰不上面，显然合法。

## Code

```cpp
#include<cstdio>
#include<cctype>
#define N 20
#define min(A,B) ((A)<(B)?(A):(B))
#define max(A,B) ((A)>(B)?(A):(B))

int n;
int c[N],p[N],l[N];

int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1;y=0;
		return a;
	}
	int d=exgcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*y;
	return d;
}

signed main(){
	scanf("%d",&n);int mx=0;
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&c[i],&p[i],&l[i]);
		mx=max(mx,c[i]);
	}
	for(int ans=mx;;ans++){
		bool flag=0;
		for(int i=1;i<=n;i++){
			for(int j=i+1;j<=n;j++){
				int x,y;
				int k=p[i]-p[j]; k=(k%ans+ans)%ans;
				int g=exgcd(k,ans,x,y);
				if((c[j]-c[i])%g)
					continue;
				x*=(c[j]-c[i])/g;
				int mo=ans/g;
				x=(x%mo+mo)%mo;
				if(x<=min(l[i],l[j])){
					flag=1;
					break;
				}
			}
			if(flag)
				break;
		}
		if(flag)
			continue;
		printf("%d",ans);
		return 0;
	}
}
```



---

## 作者：When (赞：3)

#### 算法

暴力枚举+拓欧检查

#### 思路

两个野人$i$与$j$会相遇，当且仅当方程$c_i + xp_i \equiv c_j + xp_j(mod M)$有正整数解且该解$\leq min(l_i,l_j)$。

又发现题目中保证 $M \leq 1e6$，于是就可以愉快的暴力枚举了。

而上面的方程可以化为$x(p_i - p_j) \equiv c_j - c_i(mod M)$，即求不定方程$(p_i - p_j)x + My = c_j-c_i$的正整数解，可以使用拓展欧几里得定理。

复杂度：$O(Mn^2logC_i)$。

#### Tips

+ $M$是不单调的，所以**不能二分！**
+ $M$不能从$1$开始枚举，而要从$max(c_i)$开始，~~毕竟每个野人都得有地方住~~。
+ 要是不会拓欧的，可以康康[这篇博客](https://www.cnblogs.com/whenc/p/13973504.html)。

#### 参考代码

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

int n,ans;
struct Peo{
    int c,p,l;
}p[20];

bool cmp(Peo x, Peo y){return x.p > y.p;}

int ex_gcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return a;
    }
    int tmp = ex_gcd(b, a % b, x, y);
    int ret = x - (a / b) * y;
    x = y, y = ret;
    return tmp;
}

int main(){
    int Max = 0;
    scanf("%d", &n);
    for(int i = 1; i <= n; ++ i)
        scanf("%d%d%d", &p[i].c, &p[i].p, &p[i].l), Max = max(Max, p[i].c);
    sort(p + 1, p + 1 + n, cmp);
    for(ans = Max; ans <= ((int)1e6 + 10); ++ ans){
        int flag = 1;
        for(int i = 1; i < n; ++ i){
            for(int j = i + 1; j <= n; ++ j){
                int a = p[i].p - p[j].p, b = ans, c = p[j].c - p[i].c, x = 0, y = 0;
                int val = ex_gcd(a, b, x, y);
                if(c % val != 0) continue;
                int minn = (c / val * x % (b / val) + b / val) % (b / val);
                if(minn <= min(p[i].l, p[j].l)){
                    flag = 0;
                    break;
                } 
            }
            if(!flag) break;
        }
        if(flag) return printf("%d\n", ans), 0;
    }
    return 0;
}
```



---

## 作者：试试事实上吗 (赞：3)

我的第一道数论紫题

首先，我们先看两个野人，他们相遇的充要条件是

$C_i+P_i\times k\equiv C_j+P_j\times k\;(mod\;M)$  其中$k$是第几年，且$k\ge L_i\;and\;L_j$

这个式子还是没有办法直接求解，我们对它进行如下变形

$C_i+P_i\times k-C_j-P_j\times k=bM$

$k\times(P_j-P_i)+bM=C_i-C_j$

令$a=P_j-P_i,c=C_i-C_j$

转化为$ak+bM=c$

用扩展欧几里得求解~~这个应该都知道吧~~

其中$k,M$是变量

我们对于每一个$M$,只需要枚举每两个野人,只有他们对应的$k$都符合要求时，这个$M$便是可行的。

由于$M\le10^6$直接枚举即可$AC$

$Code$

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn=20,maxm=1e6;
int l[maxn],p[maxn],c[maxn];
int n,m;
int exgcd(int a,int b,int &x,int &y)
{
    if(!b) {x=1;y=0;return a;}
    int ans=exgcd(b,a%b,x,y),t=x;
    x=y;y=t-a/b*y;
    return ans;
}

bool check(int i,int j,int b)
{
    int a=p[j]-p[i],d=c[i]-c[j],x,y;
    if(a<0) a=-a,d=-d;
    int gcd=exgcd(a,b,x,y);
    if(d%gcd) return 1;
    return ((x*(d/gcd)%(b/gcd)+(b/gcd))%(b/gcd))>min(l[i],l[j]);
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",c+i,p+i,l+i),m=max(m,c[i]);
    for(int i=m;i<=maxm;i++)
    {
        bool fg=1;
        for(int j=1;j<=n&&fg;j++)
            for(int k=1;k<=n&&fg;k++)
                if(k!=j) if(!check(j,k,i)) fg=0;
        if(fg)
        {
            printf("%d\n",i);
            break;
        }
    }
    return 0;
}
```


---

## 作者：Rainy_chen (赞：3)

### 题意
找到一个最小的$M$，使得所有$N$个野人在有生之年互不相遇。

### 题解
考虑到$M$并不满足单调性，当$M$变大或变小时，其并不一定依然是或依然不是可行解，而$M$的取值并不大，只有$10^6$，于是可以暴力枚举答案。

$N$很小，只有15，所以判断$M$是否可行可以直接去枚举任意一对野人是否会相遇。

也就是说只要同余方程
$$ C_i+xP_i\equiv C_j+xP_j(\rm mod~M)$$
满足$x<=min(L_i,L_j)$的情况下有解即可。

很显然原式可以化简为
$$x(P_i-P_j)\equiv C_j-C_i(\rm mod~M)$$
于是可以直接套用exgcd和裴蜀定理。

具体来说，先套用裴蜀定理求出是否存在解，若存在解则exgcd求出最小正整数解。

复杂度$\rm O(MN^2logC)$  
~~并不理解为什么这个复杂度能过 还跑的挺快~~

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long int_t;

int_t gcd(int_t a,int_t b){
    return b ? gcd(b, a % b) : a;
}

void exgcd(int_t a,int_t b, int_t &x,int_t &y){
    if(!b)x = 1,y = 0;
    else exgcd(b,a % b,y,x), y -= x * (a / b);
}

int_t C[22],P[22],L[22];

int main(){
    int_t N,tp = 0;cin>>N;
    for(int_t i=1;i<=N;i++){
        cin>>C[i]>>P[i]>>L[i];
        tp = max(tp,C[i]);
    }
    for(int_t i=tp;i<=1000000;i++){
        bool ok = true;
        for(int_t j=1;j<=N;j++){
            if(!ok) continue;
            for(int_t k=j+1;k<=N;k++){
                int_t ta = (P[j] - P[k]) % i + i,tb = (C[k] - C[j]) % i,aa,bb,g = gcd(ta,i);
                if(tb % g) continue;
                exgcd(ta,i,aa,bb);
                if((aa * (tb / g) % (i/g) + (i/g)) % (i/g) <= min(L[j],L[k])){ok = false; break;}
            }
        }
        if(!ok) continue;
        printf("%lld",i);
        break;
    }
}
```

~~听这题的讲课和做这题差了快一年半了。。。~~

---

## 作者：aiyougege (赞：3)

#### Solution
有一道类似的题目[青蛙的约会](https://www.luogu.org/problemnew/show/P1516), 
建议做一下.

　　不妨将洞穴另编号为$0,1,\cdots,m-1$.这样一共有m个洞穴.这样如果两个编号为$i,j$的野人在时间 $t$ 相遇, 其起点的洞穴分别为$c_i,c_j$, 其终点相同满足$$c_i+tp_i\equiv c_j+tp_j\mod m$$.将式子变形为$t(p_i-p_j)\equiv c_j-c_i\mod m$的形式.我们可以发现这正好是一个$ax\equiv c\mod b$的形式.

　　这个方程有**固定的解法**, 可以参考[青蛙的约会](https://www.luogu.org/problemnew/show/P1516).通过**扩展欧几里得算法**可以得到方程的特解, 进而得到使得方程成立的**最小正整数解**, 也就是两个野人第一次相遇的时间, 将其和野人的寿命从而判定两野人**有生之年能否相遇**.

　　这样我们就能判定在洞穴数为m的情况下两个野人能否相遇了.

　　然而m不超过$10^6$, 于是可以枚举每一个m, 判定m个洞穴的情况下任意两个野人能否相遇, 从而得到答案.

---

## 作者：lemir3 (赞：2)

## 题目分析

发现$n \leq 15$,考虑直接枚举山洞数,然后两两枚举野人是否会碰面来判断.

枚举山洞数$m_i$,两两枚举野人i和j,解如下同余方程:

> $c_i + p_i*x \equiv c_j +p_j*x ~ (mod ~ m_i)$

转化成不定方程,得到:

>   $c_i + p_i*x - c_j - p_j *x = k*m_i ~ , ~ k \in Z$
>
>   $\Rightarrow x*(p_i - p_j) + k*(-m_i) = c_j - c_i ~ , ~ k \in Z$

现已知$p_i-p_j$,$-m_i$,求出x和k,考虑使用exgcd求解.

先求出$gcd(p_i-p_j,-m_i)$,如果不能整除$c_j-c_i$则一定无解,参考exgcd求解同余方程的解法.

设$d=gcd(p_i-p_j,-m_i)$,由exgcd知一定有:

>   $x_0*(p_i - p_j) + k_0*(-m_i) = d ~,~ k\in Z$

解出$x_0$,则$x_1=x_0 * \frac{c_j-c_i}{d}$为原方程的一个特解,方程的通解为$x = x_1 + k*\frac{-m_i}{d} ~,~ k \in Z$,根据这个得到最小通解.

之后判断一下在求得的这个天数之前野人会不会去世就可以了.

需要注意的是必须有$m_i > c_{max}$.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cmath"
#include "cctype"
#include "iomanip"
#include "algorithm"
#include "set"
#include "queue"
#include "stack"
#include "deque"
#include "vector"
#include "map"
#include "time.h"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=20;
lxl n,ans,max_;
lxl c[maxn],p[maxn],l[maxn];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
lxl GetGCD(lxl x,lxl y)
{
	return !y?x:GetGCD(y,x%y);
}
lxl exGCD(lxl a,lxl b,lxl &x,lxl &y)
{
	if(!b){x=1,y=0;return a;}
	lxl tmp=exGCD(b,a%b,x,y),t=x;
	x=y,y=t-a/b*y;
	return tmp;
}
int main(void)
{
	n=read();
	for(R int i(1);i<=n;++i)c[i]=read(),p[i]=read(),l[i]=read(),max_=std::max(c[i],max_);
	while(++ans)
	{
		bool falg=false;
		for(R int i(1);i<=n;++i)
		{
			if(falg)break;
			for(R int j(i+1);j<=n;++j)
			{
				lxl d=GetGCD(p[i]-p[j],-ans);
				if((c[j]-c[i])%d)continue;
				lxl k,b,cur;
				exGCD(p[i]-p[j],-ans,k,b);
				cur=((c[j]-c[i])/d)*k;
				cur%=(-ans)/d;
				while(cur<0)cur+=(-ans)/d;
				if(cur<=std::min(l[i],l[j])){falg=true;break;}
			}
		}
		if(!falg&&ans>=max_)
		{
			printf("%lld\n",ans);
			return 0;
		}
	}
	return 0;
} 
```


---

## 作者：xryjr233 (赞：2)

考虑枚举山洞数量,问题变为判断一定数量的山洞是否合法。

设山洞数量为$k$,即使得对于任意$i,j$,满足

$C_i+P_ix\equiv C_j+P_jx(mod\ k)$

的最小正整数解(即两者相遇的最小天数)不存在或大于$min(L_i,L_j)$。

化简方程

$C_i+P_ix\equiv C_j+P_jx(mod\ k)$

$(P_i-P_j)x\equiv P_j-P_i(mod\ k)$

$(P_i-P_j)x+ky\equiv P_j-P_i$

扩展欧几里得求解即可。

(注:需要将$P_i-P_j$变为不影响答案的正整数,即$((P_i-P_j)mod\ k+k)mod\ k$)

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[20],p[20],l[20],mnn,sv,mnv,tmp;
int exgcd(int a,int b,int &solx,int &soly){//a*solx+b*soly=sv
	if(!b){
		if(sv%a)return 0;
		solx=sv/a;
		soly=0;
		return a;
	}
	int sx,sy,t=exgcd(b,a%b,sx,sy);
	if(t){
		solx=sy;
		soly=sx-(a/b)*sy;
		return t;
	}else return 0;
}
bool Solve(int d){
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			sv=c[j]-c[i];
			int t=exgcd(((p[i]-p[j])%d+d)%d,d,mnv,tmp);
			if(!t)continue;
			int mod=d/t;
			mnv=(mnv%mod+mod)%mod;
			if(!mnv)mnv+=mod;
			if(mnv<=min(l[i],l[j]))return false;
		}
	}
	return true;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d%d",&c[i],&p[i],&l[i]),mnn=max(mnn,c[i]);
	for(int i=mnn;i<=1000000;i++)if(Solve(i))return printf("%d",i),0;
	return 0;
}
```

---

## 作者：chzhc (赞：2)

可以去[我的博客](https://www.cnblogs.com/chzhc-/p/13557186.html)查看，体验可能会更好。

首先根据题意，我们可以发现，两个野人 $i, j$ 会处在一个山洞当且仅当存在 $x$ 满足 $C_i+xP_i\equiv C_j+xP_j \ (\bmod M)$ （$M$ 为山顶数，$x$ 为年数）当然，野人在 $L_i$ 年后会死亡，故当最小正整数解 $x > L_i$ 且 $x > L_j$ 时，其实是不满足两个野人处在一个山洞的。那么本题要求的是没有两个野人会处在同一个山洞，即要找到最小的 $M$ 满足对于任意的 $i, j$，要么满足 $C_i+xP_i\equiv C_j+xP_j \ (\bmod M)$ 无解，要么满足 $C_i+xP_i\equiv C_j+xP_j \ (\bmod M)$ 的最小解 $> \min\{L_i, L_j\}$。



我们现在的问题就是解决 $C_i+xP_i\equiv C_j+xP_j \ (\bmod M)$ 这个式子，我们考虑把式子变换一下，$xP_i-xP_j\equiv C_j-C_i \ (\bmod M)$，$x(P_i-P_j)\equiv C_j-C_i \ (\bmod M)$，$x(P_i-P_j)+yM=C_j-C_i$。



这个是非常经典的问题，我们考虑使用扩展欧几里得来解决。

不会可以看 [我的博客](https://www.cnblogs.com/chzhc-/p/13541993.html)。

题目说明了**输入数据保证有解，且 $M$ 不大于$10^6$**。故我们考虑暴力枚举 $M$ 然后 $n^2$ 暴力枚举 $i, j$ 判断是否成立。最后最坏复杂度：$O(10^6\times n^2 \times \log(\max\{P_i, M\})$，但是考虑到根本卡不满，所以可以过。



还有一个小坑就是 $M$ 一定 $\geq max\{C_i\}$。



[code](https://paste.ubuntu.com/p/8F4R9h22yw/)

---

## 作者：eee_hoho (赞：2)

根据题目，设$x$为相遇天数，可以得到式子

$$c_{i}+p_{i}\times x\equiv c_{j}+p_{j}\times x(mod\ M)\ (1\le i,j\le N)$$

我们要保证对于每一对$(i,j)$，这个式子都要**无解**或者求出来的$x>min(l[i],[j])$，即在两个人有一个人死了之后相遇

把这个式子化一下，就变成了

$$(p_i-p_j)\times x\equiv c_j-c_i(mod\ M)$$

写成方程的形式

$$(p_i-p_j)\times x+M\times y=c_j-c_i$$

怎么解呢，我们不妨设$a=p_i-p_j,b=M,c=c_i-c_j$

方程就成了
$$ax+by=c$$

设$g=gcd(a,b)$，当$g|c$时，设$a'=a/g,b'=b/g,c'=c/g$

我们可以用$exgcd$，即扩展欧几里得算发求出$a'x'+b'y'=1$的一组解$x',y'$

两边乘$c'$，得到$a'c'x'+b'c'y'=c'$

两边乘$g$，得到$a'gc'x'+b'gc'y'=c'g$

化简得到$ac'x'+bc'y'=c$

于是我们得到了方程一组解$x_0=x'c',y_0=y'c'$

因为$M$最大到$10^6$，所以从$Max_{i=1}^{n}c_i-10^6$枚举$M$，如果方程都无解或者$x>min(l[i],[j])$，那这个$M$就是答案了

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#define N 1000000
#define int long long
using namespace std;
int n,d[500],p[500],l[500],mm;
int gcd(int x,int y)
{
	if (!y)return x;
	return gcd(y,x%y);
}
void exgcd(int a,int b,int &x,int &y)
{
	if (!b)x=1,y=0;
	else
	{
		exgcd(b,a%b,x,y);
		int t=x;
		x=y;
		y=t-a/b*y;
	}
}
int check(int m)
{
	for (int i=1;i<n;i++)
		for (int j=i+1;j<=n;j++)
		{
			int a=p[i]-p[j],b=m,c=d[j]-d[i],g=gcd(a,b),x,y;
			if (c%g!=0)continue;
			a/=g,b/=g,c/=g;	
			exgcd(a,b,x,y);
			if (b<0)b=-b;			
			x=(x*c%b+b)%b;
			if (x<=min(l[i],l[j]))return 0;
		}
	return 1;
}
signed main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
		cin>>d[i]>>p[i]>>l[i],mm=max(mm,d[i]);
	for (int i=mm;i<=N;i++)
	{
		if (check(i))
		{
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：yf最qhhh (赞：1)

2020/11/17 给出了代码，修改了一些我的口误。

------------

这道题让我想起了一道很毒瘤的题[青蛙的约会](https://www.luogu.com.cn/problem/P1516)

~~另外，这是本蒟蒻第一道紫题题解qwq~~

------------

首先呢，题目的意思是 $n$ 个猎人住在 $m$ 个山洞中，一开始，对于第 $i$ 个猎人，他住在第 $Ci$ 个洞，每年他会向前（顺时针）走 $Pi$ 个洞，他的寿命是 $Li$（这里要看作猎人的寿命从 $0$ 开始，比如一个猎人的寿命是 $1$，那他会在走 $1$ 轮后死掉），我们要找一个 $m$ 的最小值，使得每年任意两个猎人都不会呆在同一个洞里。

所以我们先设过了 $x$ 年，那么对于第 $i$ 和第 $j$ 号猎人，我们能得到的同余方程为：

$\qquad \qquad Ci+xPi\equiv Ci+xPj\qquad (mod\ M)\qquad (x\ge min(Li,Lj))$

当然了，这是猎人在同一个洞的方程，如何让猎人不呆在同一个洞呢？

很简单，让它无解即可，即其中一个猎人在他们还没相遇之前就死掉了：$(x<min(Li,Lj))$。

既然这道题是用 $exgcd$ 做的，所以我们先将方程变形：

$\qquad \qquad \qquad (Pi-Pj)x-My=Cj-Ci$

那么我们需不需要考虑优化呢？

数据范围：$M\le 10^6$

所以不需要优化嘛。

代码如下：
```cpp
#include<iostream>
#include<algorithm>//不知道为什么洛谷上这样写好像会错
#define ll long long
#define rll register long long
using namespace std;
ll C[20],P[20],L[20];范围15，开20
inline ll exgcd(rll a,rll b,rll &x,rll &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int g=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return g;
}//模板，不多说
int main(){
	rll n,i,j,maxx=INT_MIN,tmp=0;
	bool flag=1;//flag的作用是记录目前的状态
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
		scanf("%lld%lld%lld",&C[i],&P[i],&L[i]);
		maxx=max(C[i],maxx);//这里先把野人最大的洞的编号记录，不然会有野人没洞住。
	}
	while(++tmp){//tmp为洞的个数，因为是从零开始遍历，所以找到的第一个解即最优解。
		flag=1;//flag每次都需要初始化一次qwq，这个错误害我找了半个小时。
		for(i=1;i<n&&flag;i++)
			for(j=i+1;j<=n&&flag;j++){
				rll g,cmp=C[j]-C[i],x,y;
				g=exgcd(P[i]-P[j],tmp,x,y);//exgcd模板
				if(cmp%g!=0){
					continue;
				}
				cmp/=g;
				x*=cmp;
				ll Mod=abs(tmp/g);
				if((x%Mod+Mod)%Mod<=min(L[i],L[j])){//必须加一个Mod再来取模，不然会爆
					flag=0;//还没达到要求
				}
			}
		if(flag){
			break;//如果找到了最优解就马上跳出循环。
		}
	}
	printf("%lld",maxx>tmp?maxx:tmp);//这里比较大小是因为第一要求是满足每个野人都有洞住!!!
	return >.<;
}
```



---

## 作者：Caicz (赞：0)

首先对于每一对野人，我们可以得到
> $C_a+P_a*\sum_{i=0}^{min(La,Lb)}\equiv C_b+P_b*\sum_{i=0}^{min(La,Lb)}(mod M)$

可以转换为
> $(C_a-C_b)+(P_a-P_b)*\sum_{i=0}^{min(La,Lb)}=k*M(k\in Z)$

进行移项以后，可以变为

>> $(P_a-P_b)*\sum_{i=0}^{min(La,Lb)}-k*M=C_b-C_a(k\in Z)$

鉴于$M\le1e6$我们可以,直接暴力枚举山洞个数，
这样,我们设 满足以上式子的$\sum_{i=0}^{min(La,Lb)}$为 $X$,$P_a-P_b$为$A$, $C_b-C_a$为$C$

那么就变成了
> $A*X-k*M=C(k\in Z)$

整个式子就是一个标准的exgcd模型，我们现在只需要利用exgcd求出满足条件的正整数$X$的最小值并与$min(L_a,L_b)$比较，判断在有生之年以内是否可以走到一起

> **_talk is cheap,show you the code_**

```cpp
#include<stdio.h>
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
struct node
{
	ll life,start,speed;
}c[30];
ll n,Minn;

inline void exgcd(int a,int b,int &tmp,int &k,int &z)
{
	if(b==0)
	{
		tmp=a;
		k=1,z=0;
		return;
	}
	exgcd(b,a%b,tmp,k,z);
	int t=k;
	k=z;z=t-a/b*z;
}

inline bool check(int x,int y,int L)
{
	int tmp,k,z;
	exgcd(c[x].speed-c[y].speed,-L,tmp,k,z);
	if((c[y].start-c[x].start)%tmp)return false;
	int ans=(k*((c[y].start-c[x].start)/tmp)%((-L)/tmp)+((-L)/tmp))%((-L)/tmp);
	if(ans>min(c[x].life,c[y].life))return false;
	return true;
} 

signed main(void)
{
	cin>>n;
	for(register int i=1;i<=n;++i)
	{
		cin>>c[i].start>>c[i].speed>>c[i].life;
		Minn=max(c[i].start,Minn);
	}
	for(register int flag,i=Minn;i<=1e6;++i)
	{
		flag=1;
		for(register int j=1;j<=n;++j)
		{
			for(register int k=j+1;k<=n;++k)
				if(check(j,k,i))
				{
					flag=0;
					break;
				}
			if(!flag)break;
		}
		if(flag)
		{
			printf("%d",i);
			break;
		}
	}
	return 0;
}

```



---

## 作者：GoPoux4 (赞：0)

~~初学数论，来水一篇题解。~~

---

首先很容易看出来，当一共有 $m$ 个山洞，两个野人在第 $x$ 天同时住在一个山洞时，满足下式：

$$C_i+x \cdot P_i \equiv C_j+x \cdot P_j  \ ({\rm {mod}} \ m) \ (x \leq {\rm {min}}(L_i,L_j))$$

变化一下，得到下式：

$$(P_i-P_j) \cdot x+m \cdot y=C_j-C_i \ (x \leq {\rm {min}}(L_i,L_j),y \in {\rm {Z}})$$

用扩展欧几里德算法搞一搞，如果有解，且最小的 $x$ 满足限制，则此时的 $m$ 不满足要求。

这道题数据范围比较小并且答案不满足单调性，枚举答案即可。

---

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define lxl long long
using namespace std;

inline lxl exgcd(lxl a,lxl b,lxl &x,lxl &y)
{
	if(!b) {x=1,y=0;return a;}
	lxl k=exgcd(b,a%b,x,y);
	lxl z=x;x=y,y=z-a/b*y;
	return k;
}

lxl n,x,y;
lxl C[20],P[20],L[20];

inline bool check(int a,int b,lxl m)
{
	lxl A=P[a]-P[b],B=C[b]-C[a];
	if(A<0) A=-A,B=-B;
	lxl ans=exgcd(A,m,x,y),k=(x*(B/ans)%(m/ans)+(m/ans))%(m/ans);
	return !(B%ans)&&k<=min(L[a],L[b]);//true
}

int main()
{
	//freopen("P2421.in","r",stdin);
	scanf("%lld",&n);
	lxl up=0;//答案肯定不会小于初始时野人所在的山洞最大编号
	for(int i=1;i<=n;up=max(up,C[i++]))
		scanf("%lld%lld%lld",&C[i],&P[i],&L[i]);
	for(lxl i=up;i<=1000000;i++)
	{
		bool flag=false;
		for(int j=1;j<=n&&!flag;j++)
			for(int k=j+1;k<=n&&!flag;k++)
				if(check(j,k,i)) flag=true;//in the same cave
		if(!flag) {printf("%lld\n",i);return 0;}
	}
	return 0;
}

```


---

## 作者：ShineEternal (赞：0)

[如有显示不完整请查看这里](https://blog.csdn.net/kkkksc03/article/details/101865848)


## description：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019100121190070.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tra2tzYzAz,size_16,color_FFFFFF,t_70)

## solution：

观察到答案并不会很大，于是我们可以枚举答案（这里不满足单调性，不能二分）

对于任意的i,j，原式可变形 为$(Pi −Pj)*x −M *y = Cj −Ci$

于是这就是一个exgcd的模型

最后求出如果x不存在或者超过了野人的寿命m就是答案，否则就继续找。

## code:
```cpp
#include<cstdio>
using namespace std;
int exgcd(int a,int b,int &x,int &y)
{
	if(b==0)
	{
		x=1;
		y=0;
		return a;
	}
	int d=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return d;
}
int n;
int c[17],p[17],l[17];
int check(int m)
{
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			int A=p[i]-p[j];
			int B=m;
			int C=c[j]-c[i];
			int x,y;
			int ans=exgcd(A,B,x,y); 
			if(C%ans)continue;
			A/=ans;
			B/=ans;
			C/=ans;
			if(B<0)B=-B;
			x=(x*C%B+B)%B;
			if(x<=l[i]&&x<=l[j])return 0;
		}
	}
	return 1;
}
int max(int x,int y)
{
	if(x>=y)return x;
	return y;
}
int main()
{
	scanf("%d",&n);
	int start=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&c[i],&p[i],&l[i]);
		start=max(start,c[i]);
	}
	for(int i=start;i;i++)
	{
		if(check(i))
		{
			printf("%d\n",i);
			return 0;
		}
	}
} 
```



---


# [NOI2008] 设计路线

## 题目描述

Z 国坐落于遥远而又神奇的东方半岛上，在小 Z 的统治时代公路成为这里主要的交通手段。Z 国共有 $N$ 座城市，一些城市之间由双向的公路所连接。非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。Z 国的首都是 Z 国政治经济文化旅游的中心，每天都有成千上万的人从 Z 国的其他城市涌向首都。

为了使 Z 国的交通更加便利顺畅，小 Z 决定在 Z 国的公路系统中确定若干条规划路线，将其中的公路全部改建为铁路。

我们定义每条规划路线为一个长度大于 $1$ 的城市序列，每个城市在该序列中最多出现一次，序列中相邻的城市之间由公路直接相连（待改建为铁路）。并且，每个城市最多只能出现在一条规划路线中，也就是说，任意两条规划路线不能有公共部分。

当然在一般情况下是不可能将所有的公路修建为铁路的，因此从有些城市出发去往首都依然需要通过乘坐长途汽车，而长途汽车只往返于公路连接的相邻的城市之间，因此从某个城市出发可能需要不断地换乘长途汽车和火车才能到达首都。

我们定义一个城市的“不便利值”为从它出发到首都需要乘坐的长途汽车的次数，而 Z 国的交通系统的“不便利值”为所有城市的不便利值的最大值，很明显首都的“不便利值”为 $0$。小 Z 想知道如何确定规划路线修建铁路使得 Z 国的交通系统的“不便利值”最小，以及有多少种不同的规划路线的选择方案使得“不便利值”达到最小。当然方案总数可能非常大，小 Z 只关心这个天文数字 $\bmod\ Q$ 后的值。

注意：规划路线 $1-2-3$ 和规划路线 $3-2-1$ 是等价的，即将一条规划路线翻转，依然认为是等价的。两个方案不同当且仅当其中一个方案中存在一条规划路线不属于另一个方案。



## 说明/提示

对于 $20 \%$ 的数据，$1 \le N,M \le 10$。

对于 $50 \%$ 的数据，$1 \le N,M \le 200$。

对于 $60 \%$ 的数据，$1 \le N,M \le 5000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$，$1 \le Q \le 1.2 \times 10 ^ 8$。

## 样例 #1

### 输入

```
5 4 100 
1 2 
4 5 
1 3 
4 1```

### 输出

```
1 
10```

# 题解

## 作者：Sooke (赞：18)

### 解题思路

先来看一句至关重要的题意：

> Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。

解读一下，就是点 $i$ 要么向 $[1,\ i-1]$ 中的某一点连边，要么不连。言下之意，Z 国是个**森林**。那么：

> 如果某个城市无法到达首都，则输出两行 -1。

就很好判断了，只有**树**才是连通的森林，而树必定有 $n - 1$ 条边，故先判掉 $m \neq n - 1$ 。

于是乎，我们的问题就放在了一棵树上，大致的题意就是：

> 给树路径剖分，使根出发路径经过轻边的最大值最小，求最小值和合法剖分方案数。

---

第一问格外符合树形 dp 的模型，怎么设计这个 dp 呢？

容易想到，用 $f_{i,\,u}$ 表示点 $u$ 往**不超过** $i$ 个儿子的边修成了铁路，子树内结点不便利值的最大值，显然 $i \in [0,\,2]$ 。直接算不超过 $i$ 不好算，注意下面是先算出**等于** $i$ 的，然后前缀 $\min$ 转换。

树形 dp 最经典的转移方式：扫过每个儿子，一个一个计算贡献。设计算儿子 $v$ 的贡献前，$f_{i,\,u}$ 的值是 $f'_{i,\,u}$ 。

从易到难，首先是 $i = 0$ 的转移：

$$f_{0,\,u} = \max\{f'_{0,\,u},\ f_{2,\,v} + 1\}$$

原理：既然不修建铁路，子树 $v$ 里面怎么修铁路就管不着了，所以引用的是 $f_{2,\,v}$ ，并且不便利值也会因为这条轻边整体 $+ 1$ 。

然后是 $i = 1$ 的转移：

$$f_{1,\,u} = \min\{\max\{f'_{1,\,u},\ f_{2,\,v} + 1\},\ \max\{f'_{0,\,u},\ f_{1,\,v}\}\}$$

原理：不修建铁路的原理和上一个转移是一样的，这里多了一个修建铁路，所以 $u,\,v$ 两边都得少一条，轻边都修成了重边，$+ 1$ 扔掉。

$i = 2$ 的转移和 $i = 1$ 是类似的，不妨自己去写写。

$$f_{2,\,u} = \min\{\max\{f'_{2,\,u},\ f_{2,\,v} + 1\},\ \max\{f'_{1,\,u},\ f_{1,\,v}\}\}$$

整理一下:

$$\text{边界} \begin{cases}f_{0,\,u} =0\\f_{1,\,u}=f_{2,\,u}=\infty\end{cases}$$

$$\text{转移} \begin{cases}f_{0,\,u} = \max\{f'_{0,\,u},\ f_{2,\,v} + 1\} \\f_{1,\,u} = \min\{\max\{f'_{1,\,u},\ f_{2,\,v} + 1\},\ \max\{f'_{0,\,u},\ f_{1,\,v}\}\} \\f_{2,\,u} = \min\{\max\{f'_{2,\,u},\ f_{2,\,v} + 1\},\ \max\{f'_{1,\,u},\ f_{1,\,v}\}\}\end{cases}$$

直接 dfs 一遍求出 $f$ ，不要忘了前缀 $\min$，第一问就做完了。

---

接着做第二问，你会发现与第一问有异曲同工之妙，它仍然是这个树形 dp，但没那么简单了。

大力设一波状态，令 $g_{i,\,j,\,u}$ 表示点 $u$ 往**不超过** $i$ 个儿子的边修成了铁路，子树内结点不便利值都**不超过** $j$ 的方案数。

也许你会问：$i,\,j$ 都是 $n$ 级的，这一乘就 $O(n^2)$ 了，真的不会 MLE？

神奇的是，这个 $j$ 啊，以及我们第一问的答案，不超过 $\log_3n$（极限数据下 $< 11$）。感性理解下，为什么树链剖分根出发路径经过轻边数不超过 $\log_2 n$ （提示：用子树大小证明）？但树链剖分的链是直的，而非 V 字形，这题是 V 字形的路径剖分，然后仔细想想差异就明白最初的结论了。

数组开得下了，如何转移呢？

直接算不超过 $i$ 还是不好算，先算出**等于** $i$ 的，然后前缀和转换。`（异曲同工 1）`

依旧从易到难，看 $i = 0$ 的转移式，和 $f$ 的是不是有点类似？`（异曲同工 2）`

$$g_{0,\,j,\,u} = g'_{0,\,j,\,u} \times g_{2,\,j-1,\,v}$$

原理很简单，不赘述了。$i \geqslant 1$ 的转移式就更像了：

$$g_{1,\,j,\,u} = g'_{1,\,j,\,u} \times \ g_{2,\,j-1,\,v} + g'_{0,\,j,\,u} \times g_{1,\,j,\,v}$$

$$g_{2,\,j,\,u} = g'_{2,\,j,\,u} \times \ g_{2,\,j-1,\,v} + g'_{1,\,j,\,u} \times g_{1,\,j,\,v}$$

发现没有？原本的 $+ 1$ 变成 $- 1$ 藏在下标里了，$\min$ 变成了 $+$ ，$\max$ 变成了 $\times$ ！建议想想为什么。


附上边界整理整理，其实边界不过是把 $f$ 的 $0$ 换成了 $1$ ，$\infty$ 换成了 $0$ ：`（异曲同工 3）`

$$\text{边界} \begin{cases}g_{0,\,j,\,u} =1\\g_{1,\,j,\,u}=g_{2,j,\,u}=0\end{cases}$$

$$\text{转移} \begin{cases}g_{0,\,j,\,u} = g'_{0,\,j,\,u} \times g_{2,\,j-1,\,v}\\g_{1,\,j,\,u} = g'_{1,\,j,\,u} \times \ g_{2,\,j-1,\,v} + g'_{0,\,j,\,u} \times g_{1,\,j,\,v}\\g_{2,\,j,\,u} = g'_{2,\,j,\,u} \times \ g_{2,\,j-1,\,v} + g'_{1,\,j,\,u} \times g_{1,\,j,\,v}\end{cases}$$

同样 dfs 求 $g$ 。求完之后答案就十分明朗了。

---

### 代码实现

具体实现中注意两点（针对我的代码）：

> 1. $g$ 的转移式中可能出现负下标，负下标的 $g$ 值当然是 $0$ 。据此，我的代码中 $f$ 的值和 $g$ 的 $j$ 下标都比现实多 $1$ ，以免负下标的出现同时使得代码整洁美观。

> 2. 转移式的顺序是先 $2$ 再 $1$ 最后 $0$ ，因为 $f_{2,\,u}$ 引用了 $f_{1,\,u}$ ，$f_{1,\,u}$ 引用了 $f_{0,\,u}$ ，$g$ 同理。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>

inline int read() {
    char c = getchar(); int x = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { x = (x << 1) + (x << 3) + (c & 15); c = getchar(); }
    return x;
}

const int maxN = 100005, maxR = 12;

int n, m, p, f[3][maxN], g[3][maxR][maxN];

struct List {
    int len, fst[maxN], nxt[maxN << 1], to[maxN << 1];

    List() { memset(fst, -1, sizeof(fst)); }
    inline void insert(int u, int v) { nxt[len] = fst[u]; to[len] = v; fst[u] = len++; }
    inline void link(int u, int v) { insert(u, v); insert(v, u); }
} e;

inline int add(int x, int y) { x += y; return x >= p ? x - p : x; }
inline int mul(int x, int y) { return (long long) x * y % p; }

void dfs1(int u, int fa) {
    f[0][u] = 1; f[1][u] = f[2][u] = 1e9;
    for (int i = e.fst[u], v; ~i; i = e.nxt[i]) {
        v = e.to[i];
        if (v == fa) { continue; } dfs1(v, u);
        f[2][u] = std::min(std::max(f[2][u], f[2][v] + 1), std::max(f[1][u], f[1][v]));
        f[1][u] = std::min(std::max(f[1][u], f[2][v] + 1), std::max(f[0][u], f[1][v]));
        f[0][u] = std::max(f[0][u], f[2][v] + 1);
    }
    f[1][u] = std::min(f[0][u], f[1][u]); f[2][u] = std::min(f[1][u], f[2][u]);
}
void dfs2(int u, int fa) {
    for (int i = 1; i <= f[2][1]; i++) { g[0][i][u] = 1; }
    for (int i = e.fst[u], v; ~i; i = e.nxt[i]) {
        v = e.to[i];
        if (v == fa) { continue; } dfs2(v, u);
        for (int i = 1; i <= f[2][1]; i++) {
            g[2][i][u] = add(mul(g[2][i][u], g[2][i - 1][v]), mul(g[1][i][u], g[1][i][v]));
            g[1][i][u] = add(mul(g[1][i][u], g[2][i - 1][v]), mul(g[0][i][u], g[1][i][v]));
            g[0][i][u] = mul(g[0][i][u], g[2][i - 1][v]);
        }
    }
    for (int i = 1; i <= f[2][1]; i++) { g[1][i][u] = add(g[0][i][u], g[1][i][u]); g[2][i][u] = add(g[1][i][u], g[2][i][u]); }
}

int main() {
    n = read(); m = read(); p = read();
    if (m != n - 1) { printf("-1\n-1\n"); return 0; }
    for (int i = 1; i <= m; i++) { e.link(read(), read()); }
    dfs1(1, 0); dfs2(1, 0);
    printf("%d\n%d\n", f[2][1] - 1, g[2][f[2][1]][1]);
    return 0;
}
```

---

## 作者：Aly_ (赞：9)

**树上背包 + Max 卷积**

#### 题意简述

​	给一棵树，要求在其上划出若干条点不相交路径（以下称为 “ 好链 ” ，对应地，称未被划分到任意一条好链的边为不好的边），使得所有点到根路径上的极长不好子链条数的最大值最小，并求出达到这个最小值的方案数。

#### 分析

​	首先最小值肯定是 $O(\log n)$ 级别的。

​	因为树的重链剖分显然是一组合法的好链划分，而轻边个数是 $\log n$ 条。

​	现在考虑同时求出两问的答案。

​	设 $f_{u,k,x}$ 表示：在 $u$ 的子树内作划分，和 $u$ 相连的好边有 $k$ 条，子树内最大答案为 $x$ 的方案数。根据题意，有 $k\in \{0,1,2\},x\le \log n$。设 $s_i$ 表示 $u$ 的儿子。有转移
$$
f_{u,0,x}=\sum_{\max\{y_i\}=x-1}\prod_{s_i}(f_{s_i,0,y_i}+f_{s_i,1,y_i}+f_{s_i,2,y_i})$$
$$
f_{u,1,x}=\sum_{s_p\in\{s_i\}}\sum_{\max(\{y_i+1\},y_p)=x}(f_{s_p,0,y_p}+f_{s_p,1,y_p})\prod_{s_i}(f_{s_i,0,y_i}+f_{s_i,1,y_i}+f_{s_i,2,y_i})$$
$$f_{u,2,x}=\sum_{s_p,s_q\in\{s_i\}}\sum_{\max(\{y_i+1\},y_p,y_q)=x}(f_{s_p,0,y_p}+f_{s_p,1,y_p})(f_{s_q,0,y_q}+f_{s_q,1,y_q})\prod_{s_i}(f_{s_i,0,y_i}+f_{s_i,1,y_i}+f_{s_i,2,y_i})
$$
​	一个树上背包的形式，类似于 “ 选取 $K$ 条不相交路径权值最大 ” 的套路。区别在于：和卷积换成了 max 卷积。

​	最终最小值为最小的 $x$ 使得 $f_{1,k,x}$ 不为 $0$。

#### 单次 max 卷积求解

​	考虑如下问题：给定 $\{A_i\},\{B_i\}$，求
$$
F_n=\sum_{\max(i,j)=n}A_iB_j
$$
​	方法是：先把 $A,B$ 进行前缀和变换，再进行点积（对应位置相乘），最后把得到的 $F$ 做差分变换。考虑这是为什么：前缀和后点积，所得的第 $n$ 项中会包含所有 $\max(i,j)\le n$ 的 $A_iB_j$ 之和，差分就是进行容斥。前缀和 / 差分变换在这里起到了 DFT 的作用，即，把卷积变为了点积运算。

#### 树上背包

​	现考虑把子树一个一个加进去。

​	加入一个子树时，枚举它是否到当前节点有连边，发现可作如下转移：
$$
f_{u,0,x}\rightarrow f_{u,1,x},f_{u,1,x}\rightarrow f_{u,2,x},f_{u,0,x}\rightarrow f_{u,0,x},f_{u,1,x}\rightarrow f_{u,1,x},f_{u,2,x}\rightarrow f_{u,2,x}
$$
​	顺着转移，每次作 max 卷积即可。

​	总复杂度 $O(n\log n)$。

#### 题外话

​	**有一个巨坑的点在于模数选取可能会正好使答案为 $0$，这个时候用 $f$ 一个数组无法找到最小值，解决方法是自己再找一个大模数先算一遍找到最小值再用原来的模数输出方案。后人切记后人切记后人切记**



---

## 作者：foreverlasting (赞：4)

[题面](https://www.luogu.org/problemnew/show/P4201)

DP。

这题也太坑了吧，看起来代码短，感觉好难写和想啊。

首先要看到题目中一个条件：**非常神奇的是Z国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的 城市直接通过公路相连**。这句话也太隐蔽了一点吧，正是这句话才引出后面的三叉。看到一个$m$，其实是不用理会的，因为我们仅仅需要$n-1$条变成一棵树就够了，多余的边全是公路，都是没有用的。所以终于，我们将这道题的图转换成了一棵三叉树。

开始考虑一个$DP$。$dp[i][j][k]$表示第$i$个节点，到这个节点经过的公路数目为$j$，当前这个点向儿子连了$k$条边的方案数。这个$k$是小于等于3的，这没有问题。问题就在于这个$j$，我们该怎么处理。事实上，根据轻重链剖分的思想，一棵树被分成的链数是不超过$logk(n)$的，$k$指的是$k$叉树。因此，$j$最多不到10，那么就可以枚举$j$，开始转移了。

转移方程：

初始化：$dp[x][j][0]=1$

$dp[x][0][2]=dp[x][0][1]*(dp[tox][0][0]+dp[tox][0][1])$

$dp[x][0][1]=dp[x][0][0]*(dp[tox][0][0]+dp[tox][0][1])$

$dp[x][0][0]=0$

$dp[x][j][2]=dp[x][j][2]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])+dp[x][j][1]*(dp[tox][j][0]+dp[tox][j][1])$

$dp[x][j][1]=dp[x][j][1]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])+dp[x][j][0]*(dp[tox][j][0]+dp[tox][j][1])$

$dp[x][j][0]=dp[x][j][0]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])$

然后就做好了。

code:
```
//2018.10.15 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register LL
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline LL read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline LL _abs(const res &x){
    return x>0?x:-x;
}
inline LL _max(const res &x,const res &y){
    return x>y?x:y;
}
inline LL _min(const res &x,const res &y){
    return x<y?x:y;
}
const LL N=1e5+10;
namespace MAIN{
    LL n,m,kcz;
    struct E{
        int next,to;
        E() {}
        E(res next,res to):next(next),to(to) {}
    }edge[N<<1];
    LL head[N],cnt;
    inline void addedge(const res &u,const res &v){
        edge[++cnt]=E(head[u],v),head[u]=cnt;
        edge[++cnt]=E(head[v],u),head[v]=cnt;
    }
    LL dp[N][13][5];
    LL lim;
    void dfs(const res &x,const res &fax){
        for(res i=head[x];~i;i=edge[i].next){
            res tox=edge[i].to;
            if(tox==fax)continue;
            dfs(tox,x);
        }
        for(res i=0;i<=lim;i++)dp[x][i][0]=1;
        for(res i=head[x];~i;i=edge[i].next){
            res tox=edge[i].to;
            if(tox==fax)continue;
            dp[x][0][2]=dp[x][0][1]*(dp[tox][0][0]+dp[tox][0][1])%kcz;
            dp[x][0][1]=dp[x][0][0]*(dp[tox][0][0]+dp[tox][0][1])%kcz;
            dp[x][0][0]=0;
            for(res j=1;j<=lim;j++){
                dp[x][j][2]=((dp[x][j][2]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])-1)%kcz+1+(dp[x][j][1]*(dp[tox][j][0]+dp[tox][j][1])-1)%kcz+1-1)%kcz+1;
                dp[x][j][1]=((dp[x][j][1]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])-1)%kcz+1+(dp[x][j][0]*(dp[tox][j][0]+dp[tox][j][1])-1)%kcz+1-1)%kcz+1;
                dp[x][j][0]=(dp[x][j][0]*(dp[tox][j-1][0]+dp[tox][j-1][1]+dp[tox][j-1][2])-1)%kcz+1;
            }
        }
    }
    inline void MAIN(){
        memset(head,-1,sizeof(head));
        n=read(),m=read(),kcz=read();
        for(res i=1;i<=m;i++){
            res u=read(),v=read();
            addedge(u,v);
        }
        if(m<n-1){puts("-1"),puts("-1");return;}
        lim=10;
        dfs(1,0);
        for(res i=0;i<=lim;i++)
            if(dp[1][i][0]+dp[1][i][1]+dp[1][i][2]){printf("%lld\n%lld\n",i,(dp[1][i][0]+dp[1][i][1]+dp[1][i][2])%kcz);return;}
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

事实上，这道题是真的坑。**不能直接模$kcz$**，出现了$0$的话就会在最后输出答案的时候出错，所以只能减$1$再取模。

---

## 作者：shinzanmono (赞：3)

# NOI 2008 设计路线

拿到题首先看题目限制：

> 非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。

说明了给定的路径图是森林，众所周知，树是一种特殊的森林，题意要求原图必须连通，即 $|V|=|E|+1$，故可以判掉无解情况。

然后我们考虑剩下的情况。根据题意，一个节点 $u$ 最多只能向子树连两条边。

然后又考虑最小不便利值，发现轻重链剖分后最多只有 $\log_2 n$ 个轻边，如果把重边看做是一条规划路径，则 $\log_2 n$ 为不便利值，可以证明，最小不便利值的上界是 $\log_2 n$。

然后我们考虑树上 dp。由于我们知道了答案的上界是 $\log_2 n$，所以我们把这个值放进 dp 数组里。

定义 $f_{u,i,0/1/2}$ 表示当前的最小不便利值为 $i-1$，点 $u$ 向子节点连接了**不超过** $0/1/2$ 条边（注意不是子树）。

根据题意，我们可以在每次遍历完 $u$ 的子节点 $v$ 后进行转移：

```cpp
for(int i=1;i<=ans+1;i++){
    f[u][i][2]=(f[u][i][2]*f[v][i-1][2]+f[u][i][1]*f[v][i][1]-1)%q+1;
    f[u][i][1]=(f[u][i][1]*f[v][i-1][2]+f[u][i][0]*f[v][i][1]-1)%q+1;
    f[u][i][0]=(f[u][i][0]*f[v][i-1][2]-1)%q+1;
}
```

其中 `f[u][i][x=0/1/2]*f[v][i-1][2]` 表示当前遍历到 $v$ 结点已经连了 $x$ 条边，无法再从 $u$ 连接到 $v$，所以在 $v$ 子树中可以随意的进行连边。`f[u][i][x-1]*f[v][i][1]` 表示当前遍历到 $v$ 结点已经连了 $x-1$ 条边，可以向 $v$ 连边，然后可推得 $v$ 最多连 $1$ 条边。

由于转移时 $f_{u,i,2}$ 需要用到 $f_{u,i,1}$ 且 $f_{u,i,1}$ 需要用到 $f_{u,i,0}$，所以要按照上面代码块的顺序进行转移。

对于取模，由于我们要统计的是对于满足 $f_{1,i,2}\not=0$ 最小的 $i$，如果你直接取模，会导致取模后方案数可能是 $0$ 但实际上这种方案是可行的，于是我们改变取模方式以保证答案的正确性。

由于我们的状态定义的是 $f_{u,i,0/1/2}$ 表示当前的最小不便利值为 $i$，点 $u$ 向子节点连接了**不超过** $0/1/2$ 条边，所以我们要在转移后对其进行前缀和（$0/1/2$ 一维）。

最后我们统计答案输出即可。

附 AC 代码：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
const int sz=1e5+10;
const int lgsz=std::__lg(sz)+1;
std::vector<int>graph[sz];
int size[sz],hson[sz],ans,n,m,q;
long long f[sz][lgsz][3];
void buildDFS(int u,int fau){
    size[u]=1;
    for(int v:graph[u]){
        if(v==fau)continue;
        buildDFS(v,u);
        size[u]+=size[v];
        if(size[v]>size[hson[u]])hson[u]=v;
    }
}
void chainDFS(int u,int fau,int d){
    ans=std::max(ans,d);
    if(hson[u]==0)return;
    chainDFS(hson[u],u,d);
    for(int v:graph[u]){
        if(v==fau||v==hson[u])continue;
        chainDFS(v,u,d+1);
    }
}
void dpDFS(int u,int fau){
    for(int i=1;i<=ans+1;i++)f[u][i][0]=1;
    for(int v:graph[u]){
        if(v==fau)continue;
        dpDFS(v,u);
        for(int i=1;i<=ans+1;i++){
            f[u][i][2]=(f[u][i][2]*f[v][i-1][2]+f[u][i][1]*f[v][i][1]-1)%q+1;
            f[u][i][1]=(f[u][i][1]*f[v][i-1][2]+f[u][i][0]*f[v][i][1]-1)%q+1;
            f[u][i][0]=(f[u][i][0]*f[v][i-1][2]-1)%q+1;
        }
    }
    for(int i=1;i<=ans+1;i++){
        f[u][i][1]=(f[u][i][1]+f[u][i][0]-1)%q+1;
        f[u][i][2]=(f[u][i][2]+f[u][i][1]-1)%q+1;
    }
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n>>m>>q;
    if(m<n-1)std::cout<<"-1\n-1",exit(0);
    for(int i=1,u,v;i<=m;i++)
        std::cin>>u>>v,graph[u].push_back(v),graph[v].push_back(u);
    buildDFS(1,0);
    chainDFS(1,0,0);
    // 树剖求答案上限
    dpDFS(1,0);
    // dp 求解
    for(int i=1;i<=ans+1;i++){
        if(f[1][i][2]!=0){
            std::cout<<i-1<<"\n"<<f[1][i][2]%q<<"\n";
            break;
            // 统计答案
        }
    }
    return 0;
}
```

后记：本题码量不算太大，只是具有一些思维难度，可以好好的想一想。

---

## 作者：251Sec (赞：1)

本文参考了 [这篇博客](https://www.luogu.com.cn/blog/Sooke/solution-p4201)，拜谢神犇。

> Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。

之前没看到这句话，想了半天一般图上的情况怎么处理，乐。

这句话意味着给定的图是个森林，又因为题目要求图连通（不连通直接输出两行 `-1`），所以给的图是个树，考虑树上 DP。

注意到直接对树进行轻重链剖分也是一种合法方案，所以第一问的答案是 $\log$ 级别的，这启示我们把第一问答案写进状态。

设 $f_{i,j,u}$ 代表以节点 $u$ 为根的子树内，$u$ 往**不超过** $i$ 个儿子修了铁路，并且子树内所有节点不便利度不超过 $j$ 的方案数。

考虑转移，发现直接转移不太方便，我们可以先求出修铁路数量**恰好等于** $i$ 的，然后再作前缀和。下面的转移方程中，左侧出现的 $f$ 代表恰好等于的情况，右侧代表不超过 $i$ 的情况。

设 $v$ 为当前遍历到的 $u$ 的儿子。

如果 $i=0$，那么子树里想怎么修就怎么修，但是不便利度要加一，所以：$f_{0,j,u} \gets f_{0,j,u} \times f_{2,j-1,v}$。（注意不便利度的「加一」体现在了 $j-1$ 上）

如果 $i=1$，除了子树里随便修以外，还可以往 $v$ 这里修一条边。这样 $v$ 这棵子树的不便利度就不用加一，所以 $f_{1,j,u} \gets f_{1,j,u} \times f_{2,j-1,v}+f_{0,j,u} \times f_{1,j,v}$。

如果 $i=2$，类似地，$f_{2,j,u} \gets f_{2,j,u} \times f_{2,j-1,v} + f_{1,j,u} \times f_{1,j,v}$。

边界条件是 $f_{0,j,u}=1$。注意转移之后要作前缀和。

然后这题有一个坑点，就是方案数取模之后可能为 $0$，这样我们就判不出来！

解决方案是取模时写成 `a = (a - 1) % p + 1; ` 的形式。

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, p;
ll f[3][16][100005];
struct Edge {
    int to, next;
} e[200005];
int head[100005], len;
void Insert(int u, int v) {
    e[++len].to = v;
    e[len].next = head[u];
    head[u] = len;
}
void dfs(int u, int prt) {
    for (int i = 1; i <= 15; i++) f[0][i][u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (v == prt) continue;
        dfs(v, u);
        for (int j = 1; j <= 15; j++) {
            f[2][j][u] = ((f[2][j][u] * f[2][j - 1][v] + f[1][j][u] * f[1][j][v]) - 1) % p + 1;
            f[1][j][u] = ((f[1][j][u] * f[2][j - 1][v] + f[0][j][u] * f[1][j][v]) - 1) % p + 1;
            f[0][j][u] = (f[0][j][u] * f[2][j - 1][v] - 1) % p + 1;
        }
    }
    for (int j = 1; j <= 15; j++) {
        f[1][j][u] = (f[1][j][u] + f[0][j][u] - 1) % p + 1;
        f[2][j][u] = (f[2][j][u] + f[1][j][u] - 1) % p + 1;
    }
}
int main() {
    scanf("%d%d%d", &n, &m, &p);
    if (m != n - 1) {
        printf("-1\n-1\n");
        return 0;
    }
    for (int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        Insert(u, v);
        Insert(v, u);
    }
    dfs(1, 0);
    for (int i = 1; i <= 15; i++) {
        if (f[2][i][1]) {
            printf("%lld\n%lld", i - 1, f[2][i][1] % p);
            return 0;
        }
    }
    return 0;   
}
```

---

## 作者：Xiphi (赞：0)

刚开始看成是图了，导致虚空瞎想。注意到题面中的这句话：`并且最多只和一个位于它东边的城市直接通过公路相连。`也就是说这是一个森林。

首先特判掉有两颗树的情况，这种情况显然是输出 `-1`。

将原题转化一下，在树上找若干条不相交的链使得，称被这些链覆盖的边为“链边”，Z 国的交通系统的“不便利值”即为“所有点走到根节点走的‘非链边'的最小值”的最大值。

首先发现这个就是某种意义上的树剖，想到经典结论向上跳时经过的轻边不超过 $O(\log n)$，于是答案上界不超过 $O(\log n)$，这个结论在第 $2$ 问中很有用。

这是一个经典的树上 dp 板子。设 $f_{i,j}$ 表示以 $i$ 为根的子树中，且 $i$ 的儿子向其连了 $j(j=0/1/2)$ 条铁路的最小不便利值。又有以下转移（其中 $v \in son(i)$）：

$$\begin{array}{l} 
  \left\{\begin{matrix} 
  f_{i,0} = \max(f_{i,0},f_{v,2})\\ 
  f_{i,1} = \min(\max(f_{i,1},f_{v,2}+1),\max(f_{i,0},f_{v,1})) \\ 
  f_{i,2}=\min(\max(f_{i,2},f_{v,2}+1),\max(f_{i,1},f_{v,1}))
\end{matrix}\right.    
\end{array} $$

分别解释一下。第一个式子意思是，$i$ 点跟儿子完全没有关系，所以不便利值就是儿子的最小不便利值的最大值。

第二个式子意思中，第一个 $\max$ 就是说不跟 $v$ 连边，第二个则是跟 $v$ 连边。

第三个式子也是同理，可以自行理解。注意转移顺序，因为 $j$ 小的会影响大的，所以要倒着（$j=2/1/0$）转移。

最后转移后注意要取一个前缀 $\min$，也就是说 $f_{i,1}=\min(f_{i,0},f_{i,1}),f_{i,2}=\min(f_{i,0},f_{i,1},f_{i,2})$。

然后其中初始值为 $f_{i,0}=1,f_{i,1/2}=\infty$。

然后第一问就解决了，很自然的，对于第二问的计数，我们设 $g_{i,j,k}$ 表示以 $i$ 为根的子树中，目前不便利值最小为 $j$，且 $i$ 的儿子向其连了 $k(j=0/1/2)$ 条铁路的方案数。


根据第一问的转移方程，易得 $g$ 数组的转移方程如下，$v$ 定义同上：

$$\begin{array}{l} 
  \left\{\begin{matrix} 
  g_{i,j,0} = g_{i,j,0}\times g_{i,j,2}\\ 
  g_{i,j,1} = g_{i,j,1}\times g_{v,j-1,2}+g_{i,j,0}\times g_{v,j,1} \\ 
  g_{i,j,2}=g_{i,j,2}\times g_{v,j-1,2}+g_{i,j,1}\times g_{v,j,1}
\end{matrix}\right.    
\end{array} $$

这个和上面差不多，建议自行理解一下。其中 $g_{i,j,0}$ 初始为 $1$，其他为 $0$。

代码中，有些地方需要特判 $j$ 是否为 $0$，为了简化可以都挪 $1$ 位。

```cpp
#include<bits/stdc++.h>
#define _for(i,x,y) for(int i=x;i<=y;++i)
#define _forp(i,x,y,z) for(int i=x;i<=y;i+=z)
#define _rep(i,x,y) for(int i=x;i<y;++i)
using namespace std;
#define int long long
int n,m,p;
int f[100005][3],g[100005][17][3];
vector<int> Adj[100005];
const int INF=0x3f3f3f3f;
void dfs(int x,int fa){
	f[x][0]=0;
	f[x][1]=f[x][2]=INF;
	for(auto i:Adj[x]){
		if(i==fa) continue;
		dfs(i,x);
		f[x][2]=min(max(f[x][1],f[i][1]),max(f[x][2],f[i][2]+1));
		f[x][1]=min(max(f[x][0],f[i][1]),max(f[x][1],f[i][2]+1));
		f[x][0]=max(f[x][0],1+f[i][2]);
	}
	f[x][1]=min(f[x][1],f[x][0]);
	f[x][2]=min(f[x][1],f[x][2]);
}
void dfs1(int x,int fa){
	_for(j,1,1+f[1][2]) g[x][j][0]=1;
	for(auto i:Adj[x]){
		if(i==fa) continue;
		dfs1(i,x);
		_for(j,1,1+f[1][2]){
			g[x][j][2]=(g[x][j][2]*g[i][j-1][2]%p+g[x][j][1]*g[i][j][1])%p;
			g[x][j][1]=(g[x][j][1]*g[i][j-1][2]%p+g[x][j][0]*g[i][j][1])%p;
			g[x][j][0]=(g[x][j][0]*g[i][j-1][2])%p;
		}
	}
	_for(j,1,1+f[1][2]){
		g[x][j][1]+=g[x][j][0];
		g[x][j][2]+=g[x][j][1];
		g[x][j][2]%=p;g[x][j][1]%=p;
	}
}
signed main(){
//	freopen("*.in","r",stdin);
//	freopen("*.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>m>>p;
    if(m!=n-1){
    	cout<<"-1\n-1",exit(0);
    }
    _for(i,1,m){
    	int u,v;
    	cin>>u>>v;
    	Adj[u].push_back(v);
    	Adj[v].push_back(u);
    }
    dfs(1,0);
    dfs1(1,0);
	cout<<f[1][2]<<'\n'<<g[1][f[1][2]+1][2];
	return 0;
}
```

---

## 作者：daniEl_lElE (赞：0)

容易发现，最多只和一个位于它东边的城市直接通过公路相连等价于形成一棵树。

原题等价于把树剖成若干条链，使得链不交，求所有点到根经过链外的边的最大值的最小值，以及取到最小值的方案。

这个模型和树剖一样，于是可以使用树剖经典结论：一个点只需要经过 $O(\log n)$ 条轻链就可以到达根，于是第一问答案不超过 $O(\log n)$。

接下来可以考虑一个 $dp_{i,j,0/1/2}$ 表示 $i$ 号点，子树内最多经过轻链数为 $j$，目前点往下接了 $0/1/2$ 条链。接了 $0/1$ 条链可以继续连接父亲，而 $2$ 条链不可以。

找到第一个 $dp_{1,j,0/1/2}$ 不为零的 $j$ 输出，这样只能得 $90$ 分。原因是有一个 $Q=2$。于是考虑新加一个 $vis_{i,j,0/1/2}$ 表示有没有方案即可。

总复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define s(i,j) ((i-1)*n+j)
#define mid ((l+r)>>1)
#define add(i,j) ((i+j)>=mod?i+j-mod:i+j)
using namespace std;
vector<int> vc[100005];
int mod;
int dp[100005][21][3],vis[100005][21][3];
void dfs(int now,int fa){
	for(int i=0;i<=20;i++) dp[now][i][0]=vis[now][i][0]=1;
	for(auto v:vc[now]){
		if(v==fa) continue;
		dfs(v,now);
		for(int i=0;i<=20;i++){
			int tmp0=0,tmp1=0,tmp2=0;
			(tmp1+=dp[now][i][0]*(dp[v][i][0]+dp[v][i][1]))%=mod;
			(tmp2+=dp[now][i][1]*(dp[v][i][0]+dp[v][i][1]))%=mod;
			if(i!=0){
				(tmp0+=dp[now][i][0]*(dp[v][i-1][0]+dp[v][i-1][1]+dp[v][i-1][2]))%=mod;
				(tmp1+=dp[now][i][1]*(dp[v][i-1][0]+dp[v][i-1][1]+dp[v][i-1][2]))%=mod;
				(tmp2+=dp[now][i][2]*(dp[v][i-1][0]+dp[v][i-1][1]+dp[v][i-1][2]))%=mod;
			}
			dp[now][i][0]=tmp0,dp[now][i][1]=tmp1,dp[now][i][2]=tmp2;
			tmp0=0,tmp1=0,tmp2=0;
			tmp1|=vis[now][i][0]&(vis[v][i][0]|vis[v][i][1]);
			tmp2|=vis[now][i][1]&(vis[v][i][0]|vis[v][i][1]);
			if(i!=0){
				tmp0|=vis[now][i][0]&(vis[v][i-1][0]|vis[v][i-1][1]|vis[v][i-1][2]);
				tmp1|=vis[now][i][1]&(vis[v][i-1][0]|vis[v][i-1][1]|vis[v][i-1][2]);
				tmp2|=vis[now][i][2]&(vis[v][i-1][0]|vis[v][i-1][1]|vis[v][i-1][2]);
			}
			vis[now][i][0]=tmp0,vis[now][i][1]=tmp1,vis[now][i][2]=tmp2;
		}
	}
}
signed main(){
	int n,m; cin>>n>>m>>mod;
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		vc[u].push_back(v);
		vc[v].push_back(u);
	}
	if(m!=n-1){
		cout<<"-1\n-1";
		return 0;
	}
	dfs(1,0);
	for(int i=0;i<=20;i++){
		if(vis[1][i][0]|vis[1][i][1]|vis[1][i][2]){
			cout<<i<<"\n"<<(dp[1][i][0]+dp[1][i][1]+dp[1][i][2])%mod;
			break;
		}
	}
	return 0; 
}
```

---

## 作者：DaiRuiChen007 (赞：0)

# P4201 题解

[Problem Links](https://www.luogu.com.cn/problem/P4201)

## **题目大意**

> 给个 $n$ 个点 $m$ 条边的图，保证每个 $u$ 向 $1\sim u-1$ 中的点至多连一条边，边权初始为 $1$，可以选若干点不交的路径，将这些路径上的边权设为 $0$。
>
> 这样一个方案的权值定义为 $1$ 到其他节点的最大距离，无解输出 $-1$，求可能最小的权值以及相应的方案数。
>
> 数据范围：$n,m\le 10^5$。

## **思路分析**

容易发现原图是一个森林，且如果原图不是树则无解，故只有树的情况需要处理。

很容易想到重链剖分的操作，因此可以证明答案的上界是 $\mathcal O(\log n)$ 级别的。

先考虑只有祖先 $\to$ 后代链的情况，可以设计一个简单的 dp，设 $dp_{u,i}$ 表示在 $u$ 的子树里操作使得到 $u$ 的距离至多为 $i$ 的方案数。

然后考虑树上路径的情况，容易发现问题在于无法区分路径 LCA 和中间点，因此加一维 $j$ 表示当前点选择路径的度数限制，显然 $j\in \{0,1,2\}$，先考虑度数恰好为 $j$ 的情况，最后再做前缀和优化。

容易写出如下转移：
$$
\begin{aligned}
dp_{u,i,0}&\gets dp_{u,i,0}\times dp_{v,i-1,2}\\
dp_{u,i,1}&\gets dp_{u,i,1}\times dp_{v,i-1,2}+dp_{u,i,0}\times dp_{v,i,1}\\
dp_{u,i,2}&\gets dp_{u,i,2}\times dp_{v,i-1,2}+dp_{u,i,1}\times dp_{v,i,1}
\end{aligned}
$$
边界条件为 $dp_{u,0\sim k,0}=1$，$k$ 为答案上界。

第一问可以在做第二问的时候顺便求出，也可以用类似的做法设计一个单独的 dp 提前求好。

时间复杂度 $\mathcal O(n\log n)$。

## **代码呈现**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e5+5,INF=1e9;
int n,m,MOD,k,f[MAXN][3];
int dp[MAXN][20][3],tmp[20][3];
vector <int> G[MAXN];
inline void dfs0(int u,int fa) {
    f[u][0]=0,f[u][1]=f[u][2]=INF;
    for(int v:G[u]) if(v^fa) {
        dfs0(v,u);
        int g[3]={0,0,0};
        g[0]=max(f[u][0],f[v][2]+1);
        g[1]=min(max(f[u][1],f[v][2]+1),max(f[u][0],f[v][1]));
        g[2]=min(max(f[u][2],f[v][2]+1),max(f[u][1],f[v][1]));
        f[u][0]=g[0],f[u][1]=g[1],f[u][2]=g[2];
    }
    f[u][1]=min(f[u][0],f[u][1]),f[u][2]=min(f[u][1],f[u][2]);
}
inline void dfs1(int u,int fa) {
    for(int i=0;i<=k;++i) dp[u][i][0]=1;
    auto add=[&](int &x,int y) { x=(x+y>=MOD)?x+y-MOD:x+y; };
    for(int v:G[u]) if(v^fa) {
        dfs1(v,u);
        memset(tmp,0,sizeof(tmp));
        for(int i=0;i<=k;++i) {
            if(i>0) add(tmp[i][0],dp[u][i][0]*dp[v][i-1][2]%MOD);
            if(i>0) add(tmp[i][1],dp[u][i][1]*dp[v][i-1][2]%MOD);
            if(i>0) add(tmp[i][2],dp[u][i][2]*dp[v][i-1][2]%MOD);
            add(tmp[i][1],dp[u][i][0]*dp[v][i][1]%MOD);
            add(tmp[i][2],dp[u][i][1]*dp[v][i][1]%MOD);
        }
        memcpy(dp[u],tmp,sizeof(dp[u]));
    }
    for(int i=0;i<=k;++i) add(dp[u][i][1],dp[u][i][0]),add(dp[u][i][2],dp[u][i][1]);
}
signed main() {
    freopen("design.in","r",stdin);
    freopen("design.out","w",stdout);
    scanf("%lld%lld%lld",&n,&m,&MOD);
    if(m<n-1) return puts("-1\n-1"),0;
    for(int i=1,u,v;i<n;++i) {
        scanf("%lld%lld",&u,&v);
        G[v].push_back(u),G[u].push_back(v);
    }
    dfs0(1,0),k=f[1][2],dfs1(1,0);
    printf("%lld\n%lld\n",k,dp[1][k][2]);
    return 0;
}
```



---


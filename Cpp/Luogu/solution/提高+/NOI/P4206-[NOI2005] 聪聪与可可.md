# [NOI2005] 聪聪与可可

## 题目描述

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。

一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。

当聪聪得到 GPS 时，可可正在景点 $M$（$M \le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。

我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。

灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。

## 说明/提示

【样例说明 1】 

开始时，聪聪和可可分别在景点 1 和景点 4。 

第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 

可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。
 
第二种是停在景点 4，不被吃掉。概率为 $0.5$。

到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\times 1/2 + 2\times 1/2 =1.5$ 步。

【样例说明 2】

森林如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)

对于 50%的数据，$1≤N≤50$。  
对于所有的数据，$1≤N,E≤1000$。 

## 样例 #1

### 输入

```
4 3 
1 4 
1 2 
2 3 
3 4```

### 输出

```
1.500 
```

## 样例 #2

### 输入

```
9 9 
9 3 
1 2 
2 3 
3 4 
4 5 
3 6 
4 6 
4 7 
7 8 
8 9```

### 输出

```
2.167```

# 题解

## 作者：FREEH (赞：49)

### 【题目】
![题目描述](https://cdn.luogu.com.cn/upload/pic/28782.png)

### 【解题思路】
- 分析题目，找出一些细节：
	- 猫可以走一步或两步；
    - 老鼠可以不动；
    - 猫必须走到离老鼠最近的点，如距离有相同，则选编号最小的点。
- 预处理：
	- 由于猫的走位过于神奇，无论使用什么算法都会很麻烦，因此只好进行预处理。预处理出猫在点i，老鼠在点j，猫的下一个走位$nxt[i][j]$。
    - 然而需要预处理出这个就还需要使用$SPFA$预处理出猫在点i到达所有点最短路径$dis[i][j]$，接下来才能预处理出猫的走位。
- 考虑使用概率DP，用$f[i][j]$表示猫在点i，老鼠在点j，猫抓到老鼠的期望步数是多少。
- 对于$f[i][j]$，我们进行分类讨论：
	- 如果猫和老鼠同点，即$i=j$，则$f[i][j]=0$；
	- 如果猫走一步或两步可以到达j，$f[i][j]=1$；
	- 否则$f[i][j]=sum(f[sec][k]/(p[j]+1))+1$（其中，sec表示猫走两步所到达的位置（因为走两步只算一次费用），k表示老鼠可到达的位置（含原地），p[j]表示点j的出度数（即不包含原地））。
- 这个过程可以使用记忆化搜索完成。
- 最终答案是$f[s][t]$。
    
### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<iostream>
using namespace std;
int cur,n,m,s,t;
int head[1005],p[1005];
int dis[1005][1005],nxt[1005][1005];
bool vis[1005],visit[1005][1005];
double f[1005][1005];
struct EDGE{
	int t,next;
}e[2005];
#define INF 0x3f3f3f3f

void add(int a,int b)
{
	cur++;
	e[cur].t=b;
	e[cur].next=head[a];
	head[a]=cur;
}

queue < int > q;
void SPFA(int *dis,int *nxt,int s)
{
	dis[s]=0;
	q.push(s);
	while (!q.empty())
	{
		int u=q.front();q.pop();
		vis[u]=false;
		for (int h=head[u];h!=-1;h=e[h].next)
		{
			int v=e[h].t;
			if (dis[u]+1<dis[v])
			{
				dis[v]=dis[u]+1;
				if (!vis[v])
				{
					vis[v]=true;
					q.push(v);
				}
			}
		}
	}
}
double DFS(int u,int v)
{
	if (visit[u][v]) return f[u][v];
	if (u==v) return 0;
	int fir=nxt[u][v];
	int sec=nxt[fir][v];
	if (fir==v||sec==v) return 1;
	f[u][v]=1;
	for (int h=head[v];h!=-1;h=e[h].next)
	{
		int w=e[h].t;
		f[u][v]+=DFS(sec,w)/(p[v]+1);
	}
	f[u][v]+=DFS(sec,v)/(p[v]+1);
	visit[u][v]=true;
	return f[u][v];
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	memset(head,-1,sizeof head);
	for (int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
		p[a]++;p[b]++;
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
			dis[i][j]=nxt[i][j]=INF;
	}
	for (int i=1;i<=n;i++)
	{
		SPFA(dis[i],nxt[i],i);
	}
	for (int i=1;i<=n;i++)
		for (int h=head[i];h!=-1;h=e[h].next)
		{
			int t=e[h].t;
			for (int j=1;j<=n;j++)
				if (dis[i][j]-1==dis[t][j])
				{
					nxt[i][j]=min(nxt[i][j],t);
				}
		}
	/*for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
			printf("%d ", nxt[i][j]);
		printf("\n");
	}*/
	printf("%.3lf",DFS(s,t));
	return 0;
} 
```

---

## 作者：SuperJvRuo (赞：16)

经典的期望题，用记忆化搜索解决
```
#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;

int degree[1005], x[1005][1005], dis[1005][1005];
double f[1005][1005];
//degree记录每个点的度，x[i][j]代表聪聪在i，可可在j时聪聪的下一步
//dis[i][j]代表i、j距离

struct Edge
{
	int to, next;
}edge[2005];
int first[1005], size_of_edge;

void Add_edge(int from, int to)
{
	edge[++size_of_edge] = (Edge) { to, first[from] };
	first[from] = size_of_edge;
	edge[++size_of_edge] = (Edge) { from, first[to] };
	first[to] = size_of_edge;
	++degree[from], ++degree[to];
}

double dp(int i, int j)
{
	if (f[i][j] != -1.0)//已经算过
		return f[i][j];
	if (i == j)//已经抓到
		return f[i][j] = 0;
	if (x[i][j] == j)//再走一步
		return f[i][j] = 1.0;
	if (x[x[i][j]][j] == j)//走两步
		return f[i][j] = 1.0;
	
	f[i][j] = 0.0;
	for (int k = first[j]; k; k = edge[k].next)//枚举下一步
		f[i][j] += dp(x[x[i][j]][j], edge[k].to);
	f[i][j] = (f[i][j] + dp(x[x[i][j]][j], j)) / (double)(degree[j] + 1) + 1;
	return f[i][j];
}

int main()
{
	int n, e, c, m, from, to;
	scanf("%d%d%d%d", &n, &e, &c, &m);
	while (e--)
	{
		scanf("%d%d", &from, &to);
		Add_edge(from, to);
	}
    //链式前向星存图
	for (int i = 0; i < n + 1; ++i)
		for (int j = 0; j < n + 1; ++j)
			f[i][j] = -1.0;
    //初始化答案数组
			
	memset(dis, -1, sizeof(dis));
	for (int i = 1; i <= n; ++i)
	{
		queue<int> que;
		que.push(i);
		dis[i][i] = 0;
		while (!que.empty())
		{
			from = que.front();
			que.pop();
			for (int j = first[from]; j; j = edge[j].next)
			{
				to = edge[j].to;
				if (dis[i][to] == -1)
				{
					dis[i][to] = dis[i][from] + 1;
					que.push(to);
				}
			}
		}
	}
    //BFS遍历求出图中所有点对的距离

	memset(x, 0x7f, sizeof x);
    //因为聪聪会选择编号小的点，因此把x初始化为maxint
	for (int from = 1; from <= n; ++from)
	{
		for (int k = first[from]; k; k = edge[k].next)
		{
			for (int j = 1; j <= n; ++j)
			{
				if (dis[from][j] == dis[edge[k].to][j] + 1 && x[from][j]>edge[k].to)
				{
					x[from][j] = edge[k].to;
				}
			}
		}
	}
    //预处理聪聪的下一步
    
	printf("%.3f\n", dp(c, m));
	return 0;
}
```

---

## 作者：Booksnow (赞：13)

# 概率与期望

## 题目大意

给你一张图，再给你两个位置，这两个位置上有两个人，分别是A和B。A知道B的位置且**每次都是他先走**，A每次能走两步(由于他知道位置，所以每次都是向**离B更近**的点走，若距离相同，走**标号最小**的点)，B每次**随机**走向下一个地点。求A和B到达**同一个位置**的**期望**。

## 解决方案

我们设$f[i][j]$为聪聪在$i$点、可可在$j$点，聪聪抓到可可的**期望时间**。

### 聪聪

首先，从题面里我们能够知道，聪聪每次走到的点是**固定**的，因此我们可以把它**预处理**出来。

设$step[i][j]$表示当可可在j位置聪聪在i位置时聪聪的选择。我们可以直接**枚举每个点**，当成可可的位置进行**BFS**，然后就能求得$step$数组，具体过程参考代码进行理解(注意这里求解的是**走一步**的情况)：

```cpp
for(int i=1;i<=n;i++)    //枚举每个点,当成可可的位置进行BFS,求解step数组 
	Get_Step(i);
```
```cpp
void Get_Step(int point)        //step[i][j]表示当可可在j位置聪聪在i位置时聪聪的选择 
{
    memset(vis,0,sizeof(vis));
    memset(deep,127,sizeof(deep));
    q.push(point);
    vis[point]=1;
    deep[point]=0;
    while(!q.empty()){ 
        int x=q.front();
        vis[x]=0; 
        for(int i=first[x];i!=-1;i=nex[i]){
            int to=road[i].v;
            if(!vis[to]&&deep[to]>deep[x]+1){	
                deep[to]=deep[x]+1;			//更新深度 
                step[to][point]=x;		//记录目标点 
                q.push(to);		//由于深度发生变化，重新入队 
                vis[to]=1;		//标记为已入队 
            }
            else{
                if(deep[to]==deep[x]+1)		
                    if(x<step[to][point]) step[to][point]=x;	//更新为下标更小的点 
            }
        }
        q.pop();
    }
}
```
若是聪聪**已经**和可可在**同一个位置**，说明已经抓到，此时的期望为$0$。如果聪聪能够在**两步内**抓到可可，只需要经过$1$个单位时间，此时的**期望为1**。

```cpp
if(x==y) return 0.0;        //已经抓到，期望为0 
if(step[x][y]==y||step[step[x][y]][y]==y) return 1.0;   //下一步即可捉到，期望为1 
```

由于聪聪走一步的位置我们知道，那我他走两步的位置其实就是他**走到下一步时再走一步**，由step的定义我们易知为：$step[step[x][y]][y]$

### 可可

如果聪聪**不能**在两步内抓到可可，那么聪聪要多久才能抓住可可就**和可可的选择有关**了。

我们就要**枚举**可可走过的**每种可能**，和聪聪走到的位置**一起进入下一状态**，求得每个状态的权值。即为：

```cpp
double sum=DFS(step[step[x][y]][y],y);	//原地不动 
for(int i=first[y];i!=-1;i=nex[i])
	sum+=DFS(step[step[x][y]][y],road[i].v);	//枚举选择
```
最后**根据期望的定义**我们知道他将会乘可可做出每种选择的概率，我们选择**在最后除以选择的总数**。

我们可以在输入的时候**统计每个点的出度**，可可**还可以原地不动**，则出度加1即为选择的总数。

```
return f[x][y]=sum/(out[y]+1.0)+1.0;        //可可可以不动
```
最后看到这个式子，~~相信很多同学的疑惑在于~~，最后为什么会加上一个$1$。我们会发现，前面我们计算的都是每一个**点的权值**转移，但是我们并**没有计算转移的代价**。由于每转移一次是**一个单位时间**，我们将代价定为1，最后可可可能走的所有边的概率**乘1再加起来**，就等于$1$。而这个$1$是我们**没有计算**的，所以要在最后加上$1$。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2010;
const double eps=1e-8;
struct edge{
    int u,v;
}road[N];
int n,m,st,en;
int tot,first[N],nex[N],out[N];
int deep[N],vis[N],step[N][N];
double f[N][N];
queue <int> q;
void Add(int x,int y)
{
    nex[++tot]=first[x];
    first[x]=tot;
    road[tot].u=x;
    road[tot].v=y;
}
 
double DFS(int x,int y)     //记忆化搜索即可 
{
    if(x==y) return 0.0;        //已经抓到，期望为0 
    if(step[x][y]==y||step[step[x][y]][y]==y) return 1.0;   //下一步即可捉到，期望为1 
    if(!(fabs(f[x][y])<eps)) return f[x][y];     //已经算过 
    double sum=DFS(step[step[x][y]][y],y);	//原地不动 
    for(int i=first[y];i!=-1;i=nex[i])
        sum+=DFS(step[step[x][y]][y],road[i].v);	//枚举选择 
    return f[x][y]=sum/(out[y]+1.0)+1.0;        //可可可以不动,最后加1与扑克同理可证 
}
 
void Get_Step(int point)        //step[i][j]表示当可可在j位置聪聪在i位置时聪聪的选择 
{
    memset(vis,0,sizeof(vis));
    memset(deep,127,sizeof(deep));
    q.push(point);
    vis[point]=1;
    deep[point]=0;
    while(!q.empty()){ 
        int x=q.front();
        vis[x]=0; 
        for(int i=first[x];i!=-1;i=nex[i]){
            int to=road[i].v;
            if(!vis[to]&&deep[to]>deep[x]+1){	
                deep[to]=deep[x]+1;			//更新深度 
                step[to][point]=x;		//记录目标点 
                q.push(to);		//由于深度发生变化，重新入对 
                vis[to]=1;		//标记为已入队 
            }
            else{
                if(deep[to]==deep[x]+1)		
                    if(x<step[to][point]) step[to][point]=x;	//更新为下标更小的点 
            }
        }
        q.pop();
    }
}
 
int main()
{
    memset(first,-1,sizeof(first));
    scanf("%d%d",&n,&m);
    scanf("%d%d",&st,&en);
    int x,y;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        Add(x,y); Add(y,x); 
        out[x]++; out[y]++; //统计出度 
    }
    for(int i=1;i<=n;i++)    //枚举每个点,当成可可的位置进行BFS,求解step数组 
        Get_Step(i);
    printf("%.3lf",DFS(st,en));     //记忆化搜索答案易得 
    return 0;
} 
```


---

## 作者：钱逸凡 (赞：8)

 _预处理_ ：
根据题目要求聪聪会向可可不断靠近，且边无权，所以先进行N次广度优先搜索，预处理出p[i, j]表示顶点i到顶点j的最短路上与顶点i相邻且编号最小的顶点编号。即聪聪在景点i，可可在景点j时，聪聪第1步会走到的景点编号。 设f [i, j]来表示聪聪在顶点i，可可在顶点j时聪聪抓住可可的平均步数。令w[i, j]表示与顶点i相邻的j个点编号，而用t[i]表示顶点i的度

------------

 _思路_ ：
可以确定聪聪下一步所在的顶点即p[p[i, j], j]，可可下一步在顶点w[i, j]，概率为1/(1+t[j])，下一步这个情况下的期望f [p[p[i, j], j], w[i, j]]已经计算出，那么就是比f [p[p[i, j], j], w[i, j]]多出一步。可可在原地停留的情况则类似。
当然，f [i, i] = 0，因为聪聪和可可已经在同一个点。若p[p[i, j], j] = j 或p[i, j] = j 则说明在这一时间单位内聪聪即可吃掉可可，那么f [i, j]=1。 用记忆化搜索即可解决
c++AC代码
```
#include<iostream>
#include<cstring>
#include<math.h>
#include<queue>
#include<cstdio>
#include<algorithm>
using namespace std;
int p[1010][1010];//聪聪在i可可在j，聪聪下一步会到达的点为p[i][j] 
double f[1005][1005];//聪聪在i可可在j，抓到步数的期望
int w[1010][1010];
int t[1010];//每个点的度 
int n,e,c,m;
int dist[1010][1010];
int inque[1010];
queue <int > q;
struct Node{
	int v;
	int next;
}node[2010];
int top=0;
int head[1010];
void addedge(int u,int v){
	node[++top].v=v;
	node[top].next=head[u];
	head[u]=top;
}
void spfa(int s) {
	memset(dist[s],0x3f,sizeof(dist[s]));
	dist[s][s]=0;
	int i;
	q.push(s);
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		inque[u]=0;
		for(i=head[u];i;i=node[i].next) {
			if(dist[s][node[i].v]>dist[s][u]+1) {
				dist[s][node[i].v]=dist[s][u]+1;
				if(inque[node[i].v]==0) {
					inque[node[i].v]=1;
					q.push(node[i].v);
				}
			}
		}
	}
}
double dfs(int i,int j) {
	if(f[i][j]!=0) {
		return f[i][j];
	}
	if(i==j)return f[i][j]=0.0;
	if(p[p[i][j]][j]==j)return f[i][j]=1.0;
	if(p[i][j]==j)return f[i][j]=1.0;
	for(int k=1; k<=t[j]; k++) {
		f[i][j]+=dfs(p[p[i][j]][j],w[j][k]);//可可乱走的所有情况 
	}
	f[i][j]=(f[i][j]+dfs(p[p[i][j]][j],j))/(double)(t[j]+1)+1;//停留在原地的情况，除以概率，加上本步所用的时间 
	return f[i][j];
}
int main() {
	scanf("%d%d%d%d",&n,&e,&c,&m);
	int i,j,a,b;
	for(i=1; i<=e; i++) {
		scanf("%d%d",&a,&b);
		addedge(a,b);
		addedge(b,a);
		t[a]++;
		t[b]++;
		w[a][t[a]]=b;
		w[b][t[b]]=a;
	}
	int k;
	for(i=1; i<=n; i++) p[i][i]=0, spfa(i);//求出任意两点间的距离 
	memset(p,0x7f,sizeof(p));
	for(i=1; i<=n; i++) {
		for(j=1; j<=t[i]; j++) {
			for(k=1; k<=n; k++) {
				if(dist[i][k]==dist[w[i][j]][k]+1&&p[i][k]>w[i][j]) {
					p[i][k]=w[i][j];
				}
			}
		}
	}
	printf("%.3lf",dfs(c,m));
	return 0;
}
```


---

## 作者：小塘空明 (赞：6)

**（1）：**首先我们发现关于确定的两个点x，y，假设x为猫，y为鼠，那么x接下来的移动步骤是确定的，我们可以用bfs进行预处理。

**（2）：**预处理记录p[s][x]时，对于每个新的节点y，它能被p[s][x]更新，仅当s到x的最短路+1即s到它的最短路且p[s][x]比p[s][y]编号要小。

**（3）：**对于记忆化搜索的每一步，假设p[x][y]==y或p[p[x][y]][y]==y，那么只差一步就能到。鼠每一步的行动可能是不动也可能走到相邻节点，可能性即为y的度数+1.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<queue>
using namespace std;
typedef long long ll;
const int maxn=1e3+10,size=1e5+10;
int n,m,tot,a,b,d[maxn];
int head[maxn],ver[size],next[size];
int dis[maxn][maxn],p[maxn][maxn];
double f[maxn][maxn];
queue<int> q;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
void add(int x,int y){
	ver[++tot]=y;next[tot]=head[x];head[x]=tot;d[y]++;
}
double dp(int x,int y){
	if(f[x][y]) return f[x][y];
	if(x==y) return 0;
	if(p[x][y]==y||p[p[x][y]][y]==y) return f[x][y]=1.0;
	double cnt=dp(p[p[x][y]][y],y);
	for(int i=head[y];i;i=next[i]){
		int z=ver[i];
		cnt+=dp(p[p[x][y]][y],z);
	}
	return f[x][y]=cnt/(d[y]+1)+1;
}
void bfs(int s){
	while(q.size()) q.pop();
	dis[s][s]=0;q.push(s);
	while(q.size()){
		int x=q.front();q.pop();
		int tmp=p[s][x];
		for(int i=head[x];i;i=next[i]){
			int y=ver[i];
			if(dis[s][y]==-1||(dis[s][x]+1==dis[s][y]&&tmp<p[s][y])){
				dis[s][y]=dis[s][x]+1;p[s][y]=tmp;
				if(!tmp) p[s][y]=y;
				q.push(y);
			}
		}
	}
}
int main(){
	memset(dis,-1,sizeof(dis));
	n=read();m=read();a=read();b=read();
	for(int i=1;i<=m;i++){
		int x,y;x=read();y=read();add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++) bfs(i);
	printf("%.3lf",dp(a,b));
	return 0;
}
```

---

## 作者：nofind (赞：3)

题意:https://www.luogu.org/problem/P4206

方便起见,管聪聪叫A,可可叫B

设$f[x][y]$表示当前A在x,B在y,A吃到B的期望步数,$nxt[x][y]$表示当前A在x,B在y,A下一步会到哪里

求$nxt[x][y]$:求出$dis[x][y]$表示从x到y的最短路,之后枚举取最小即可

求$f[x][y]$可以记忆化搜索,边界为当$x=y$时$f[x][y]=0$,当$x$下一步或两步能到$y$时,$f[x][y]=1$

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1010;
const int maxm=1010;
int n,m,st,ed,cnt;
int head[maxn],deg[maxn];
int dis[maxn][maxn],nxt[maxn][maxn];
double f[maxn][maxn];
bool vis1[maxn];
bool vis[maxn][maxn];
struct edge{int to,nxt;}e[maxm<<1];
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
inline void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	deg[v]++;
}
inline void spfa(int s)
{
	memset(dis[s],0x3f,sizeof(dis[s]));dis[s][s]=0;
	queue<int>q;q.push(s);vis1[s]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();vis1[x]=0;
		for(int i=head[x];i;i=e[i].nxt)
		{
			int y=e[i].to;
			if(dis[s][y]>dis[s][x]+1)
			{
				dis[s][y]=dis[s][x]+1;
				if(!vis1[y])vis1[y]=1,q.push(y);
			}
		}
	}
}
double dfs(int x,int y)
{
	if(vis[x][y])return f[x][y];
	vis[x][y]=1;
	if(x==y)return f[x][y]=0;
	int u=nxt[x][y],v=nxt[u][y];
	if(u==y||v==y)return f[x][y]=1;
	f[x][y]=1;
	for(int i=head[y];i;i=e[i].nxt)
	{
		int z=e[i].to;
		f[x][y]+=dfs(v,z)/(deg[y]+1);
	}
	f[x][y]+=dfs(v,y)/(deg[y]+1);
	return f[x][y];
}
int main()
{
	n=read(),m=read(),st=read(),ed=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		add(u,v);add(v,u);
	}
	for(int i=1;i<=n;i++)spfa(i);
	memset(nxt,0x3f,sizeof(nxt));
	for(int x=1;x<=n;x++)
		for(int i=head[x],y=e[i].to;i;i=e[i].nxt,y=e[i].to)
			for(int z=1;z<=n;z++)
				if(dis[x][z]==1+dis[y][z])
					nxt[x][z]=min(nxt[x][z],y);
	printf("%.3lf",dfs(st,ed));
	return 0;
}
```


---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4206)

## 题意

- 给定一个无向图，以及 $\text{A}$ $\text{B}$ 初始位置。

- $\text{A}$ 向 $\text{B}$ 连续走两次（若效果相同则走**序号**小的）。

- $\text{B}$ 等概率向相邻点移动一次或不动。

- 每次 $\text{A}$ 比 $\text{B}$ 先走。

- 问 $\text{A}$ 追上 $\text{B}$ 的期望时间。

## Sol

期望类题目。

首先看这个 $n \le 1000$ 发现（大概）可以 $n^3$。

那么我们不妨先暴力跑出 $p_{i,j}$ 代表 $\text{A}$ 在 $i$，$\text{B}$ 在 $j$ 时 $\text{A}$ 下次应该走到的位置。

可以用 $\texttt{Dijkstra}$ 求出任意两点之间最短路，然后枚举两点及边暴力跑出 $p_{i,j}$。

由于边数小，离 $n^3$ 还很远，完全能跑过。（

我们以 $t_i$ 表示 $i$ 点的度数，$w_i$ 表示与 $i$ 相邻的点集，$f_{i,j}$ 表示 $\text{A}$ 在 $i$，$\text{B}$ 在 $j$ 的期望步数。

可得对于 $\forall i$ $f_{i,i}=0$。

同时若 $p_{i,j}==j$ 或 $p_{p_{i,j},j}==j$ $f_{i,j}=1$。

分析每次暴力往下跑后，可得通项 $f_{i,j}=1+\dfrac{\sum\limits_{k=1}^{t_k}f_{p_{p_{i,j},j},w_{j,k}}+f_{p_{p_{i,j},j},j}}{t_i+1}$。

显然可以**记忆化搜索**。

于是便能完成问题。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e3+5;
const double eps=1e-5;
ll n,e,c,m,p[N][N],dis[N][N];
double f[N][N];
vector<ll> w[N];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
double dp(ll u,ll v){
	if(u==v) return f[u][v]=0.0;
	if(p[u][v]==v||p[p[u][v]][v]==v) return f[u][v]=1.0;
	if(f[u][v]!=0.0) return f[u][v];
	for(ll k=0;k<w[v].size();k++) f[u][v]+=dp(p[p[u][v]][v],w[v][k]);f[u][v]+=dp(p[p[u][v]][v],v);
	f[u][v]/=(double)(w[v].size()+1);f[u][v]+=1.0;
	return f[u][v];
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(e);rd(c);rd(m);
	for(ll i=0,u,v;i<e;i++) rd(u),rd(v),w[u].push_back(v),w[v].push_back(u);
	memset(dis,-1,sizeof(dis));
	for(ll i=1;i<=n;i++){
		queue<ll> q;q.push(i);dis[i][i]=0;
		while(!q.empty()){
			ll u=q.front();q.pop();
			for(ll j=0;j<w[u].size();j++)
				if(dis[i][w[u][j]]==-1) dis[i][w[u][j]]=dis[i][u]+1,q.push(w[u][j]);
		}
	}
	memset(p,0x3f,sizeof(p));
	for(ll i=1;i<=n;i++)
		for(ll k=0;k<w[i].size();k++)
			for(ll j=1;j<=n;j++)
				if(dis[i][j]==dis[w[i][k]][j]+1) p[i][j]=min(p[i][j],w[i][k]);
	cout<<fixed<<setprecision(3)<<dp(c,m);puts("");
	return 0;
}
```

---

## 作者：花里心爱 (赞：2)

一道期望DP题。

考虑可以DP的条件，由于老鼠在同一个点的时候猫不会走回头路，所以状态无后效性。

由于我们不知道转移的顺序，所以我们可以用记忆化搜索实现。考虑猫在点$st$，老鼠在点$ed$的情况，可以分为3种：

1. 当$st = ed$时，猫已经捉到老鼠了，直接返回0
2. 当$st$的下一步为$ed$，或者$st$的下一步再下一步为$ed$（也就是走2步）时，猫在花费一段时间就可以捉到老鼠，返回1
3. 否则还需要再走几步，继续搜索

然后考虑如何预处理猫下一步的位置。由于边权均为1，所以可以直接bfs求两点之间的最短路。然后枚举$i$可以到达的点，如果这个点是最短路径上的点并且编号较小，直接更新。

下面上代码：
```
#include <cstdio>
#include <cctype>
#include <cstring>
#define maxn 1005
inline int read() {
    int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}

int n, e, c, m, u, v, deg[maxn];
int head[maxn], ver[maxn<<1], nxt[maxn<<1], tot;
double f[maxn][maxn];
int g[maxn][maxn];
int dis[maxn][maxn];
int q[maxn], he, ta;

double dfs(int st, int ed) {
    if(f[st][ed] != -1) return f[st][ed];
    if(st == ed) return f[st][ed] = 0.0; // 已经到达目标点
    if(g[st][ed] == ed || g[g[st][ed]][ed] == ed) return f[st][ed] = 1.0; // 再走一步即可到达目标点
    f[st][ed] = dfs(g[g[st][ed]][ed], ed); // 老鼠原地不动
    for(int p = head[ed]; p; p = nxt[p])
        f[st][ed] += dfs(g[g[st][ed]][ed], ver[p]); // 老鼠走一步
    f[st][ed] /= (deg[ed]+1); // 情况的总数为点ed的度+1
    return ++f[st][ed]; // 猫走了一步，所以答案+1
}

int main() {
    n = read(), e = read(), c = read(), m = read();
    for(int i = 1; i <= e; ++i) {
        u = read(), v = read();
        ver[++tot] = v, nxt[tot] = head[u], head[u] = tot;
        ver[++tot] = u, nxt[tot] = head[v], head[v] = tot;
        ++deg[u], ++deg[v];
    }
    
    memset(dis, -1, sizeof(dis));
    for(int i = 1; i <= n; ++i) {
        dis[i][i] = 0;
        he = ta = 0;
        q[0] = i;
        while(he <= ta) {
            u = q[he++];
            for(int p = head[u]; p; p = nxt[p]) {
                v = ver[p];
                if(dis[i][v] == -1) {
                    dis[i][v] = dis[i][u] + 1;
                    q[++ta] = v;
                }
            }
        }
    }
    
    memset(g, 0x3f, sizeof(g));
    for(int i = 1; i <= n; ++i)
    for(int p = head[i]; p; p = nxt[p])
    for(int j = 1; j <= n; ++j)
        if(dis[i][j] == dis[ver[p]][j] + 1 && ver[p] < g[i][j])
            g[i][j] = ver[p];
    
    for(int i = 1; i <= n; ++i)
    for(int j = 1; j <= n; ++j)
        f[i][j] = -1; // 初始化dp数组
    dfs(c, m);
    printf("%.3lf", f[c][m]);
    return 0;
}
```

---

## 作者：不存在之人 (赞：1)

【分析】 
spfa预处理+期望dp+记忆化搜索

首先用spfa搞出来next[u][v]表示猫在u，老鼠在v时猫的下一步要走哪里。 

然后搜一下就好了…边界条件是如果u走一步或者两步能走到v，那么dp[u][v]=1 

还有dp[i][i]=0(这个好像没什么卵用)
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define ll long long
#define inf 1e9+7
#define M(a) memset(a,0,sizeof a)
#define fo(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
queue <int> q;
const int mxn=1005;
int n,m,c,e,cnt;
bool vis[mxn],mark[mxn][mxn];
double dp[mxn][mxn];
int p[mxn],dis[mxn],head[mxn],next[mxn][mxn];  //猫在u，老鼠在v时老鼠应该往哪里走捏 
struct edge {int to,next;} f[mxn<<2]; 
inline void add(int u,int v)
{
    f[++cnt].to=v,f[cnt].next=head[u],head[u]=cnt;
}
inline void spfa(int s)
{
    memset(vis,0,sizeof vis);
    memset(dis,0x3f,sizeof dis);
    q.push(s);
    dis[s]=0;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=f[i].next)
        {
            int v=f[i].to;
            if(dis[v]>dis[u]+1)
            {
                dis[v]=dis[u]+1;
                if(!vis[v]) vis[v]=1,q.push(v);
            }
        }
    }
    fo(u,1,n) if(u!=s)  //枚举猫在哪个点(老鼠在s点) 
    {
        int mn=inf;
        for(int i=head[u];i;i=f[i].next)  //扎心了老铁 
        {
            int v=f[i].to;
            if(dis[v]<mn)
              mn=dis[v],next[u][s]=v;
            else if(dis[v]==mn && v<next[u][s])
              next[u][s]=v;
        }
    }
}
inline double dfs(int u,int v)  //猫在u，老鼠在v时的期望步数
{
    if(mark[u][v]) return dp[u][v];
    if(u==v) return 0;
    int fir=next[u][v],sec=next[fir][v];
    if(fir==v || sec==v) return 1;
    for(int i=head[v];i;i=f[i].next)
    {
        int kv=f[i].to;
        dp[u][v]+=(dfs(sec,kv)+1)/(p[v]+1);
    }
    dp[u][v]+=(dfs(sec,v)+1)/(p[v]+1);
    mark[u][v]=1;
    return dp[u][v];
}
int main()
{
    scanf("%d%d%d%d",&n,&e,&c,&m);
    fo(i,1,e)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v),add(v,u);
        p[u]++,p[v]++;
    }
//  fo(i,1,n) printf("du[%d]=%d\n",);
    fo(i,1,n) spfa(i);
    printf("%.3lf\n",dfs(c,m));
    return 0;
}
```

---

## 作者：lory1608 (赞：1)

显然原题可以进行转换，转换成$dp$模型，首先对于聪聪他走路的方式是确定的，但可可他走路的方式是随机的，那么我们显然可以定义状态，$dp[j][k]$，聪聪在$j$位置，可可在$k$位置所用的时间。

那么可以根据题意进行转移。对于转移，我们需要维护一个最靠近可可的景点并且标号最小的景点，我们需要进行预处理，用$bfs$，求出最短路，并且维护他是从哪里转移过来的。

但是注意到这样不好维护，所以我们可以用一个数据结构把这些$dp$数组存起来。

复杂度$\Theta(n^2\log n+n^2)$。

50分代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#define ll long long
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
using namespace std;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline int getint()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
struct dp
{
	int times;
	int s,t;
	double expc;
	dp(int tim=0,int ss=0,int tt=0,double ee=0){times=tim,s=ss,t=tt,expc=ee;}
};
const int maxn=1e3+5;
int n,m,s,t;
int p[maxn],dis[maxn][maxn],cho[maxn][maxn],sz,ind[maxn];
queue<dp>q;
double ans;
struct edge
{
	int v,nxt;
	edge(int vv=0,int nn=0){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
inline void bfs(int u)
{
	queue<int>q;
	q.push(u);
	dis[u][u]=0;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		for(int i=p[now];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[u][v]>dis[u][now]+1)
			{
				dis[u][v]=dis[u][now]+1;
				cho[u][v]=now;
				q.push(v);
			}
			else if(dis[u][v]==dis[u][now]+1&&now<cho[u][v])
			{
				cho[u][v]=now;
			}
		}
	}
}
int main()
{
	freopen("cchkk.in","r",stdin);
	freopen("cchkk.out","w",stdout);
	memset(p,-1,sizeof(p));
	n=getint(),m=getint();
	s=getint(),t=getint();///s is congcong t is keke
	q.push(dp(0,s,t,1.0));
	FOR(i,1,m)
	{
		int u=getint(),v=getint();
		ind[u]++,ind[v]++;
		add(u,v),add(v,u);
	}
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=n;++i)
	{
		bfs(i);
	}
	while(!q.empty())
	{
		dp now=q.front();
		q.pop();
		now.times++;
		int temp=now.s;
		int cnt=0;
		bool ok=false;
		while(cnt<2)
		{
			temp=cho[now.t][temp];
			if(temp==now.t)
			{
				ans+=now.times*now.expc;
				ok=true;
				break;
			}
			cnt++;
		}
		if(ok)continue;
		now.s=temp;
		double pro=now.expc/(double)(ind[now.t]+1);
		for(int i=p[now.t];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			if(v==now.s)
			{
				ans+=pro*now.times;
			}
			else
			{
				q.push(dp(now.times,now.s,v,pro));
			}
		}
		q.push(dp(now.times,now.s,now.t,pro));
	}
	printf("%.3lf",ans);
	return 0;
}
```

100分代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<map>
#define ll long long
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
using namespace std;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
inline int getint()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
struct dp
{
	int times;
	int s,t;
	dp(int tim=0,int ss=0,int tt=0){times=tim,s=ss,t=tt;}
	inline bool operator<(const dp &b)const
	{
		if(times==b.times)
		{
			if(s!=b.s)return s<b.s;
			else return t<b.t;
		}
		else return times<b.times;
	}
};
const int maxn=1e3+5;
int n,m,ss,t;
int p[maxn],dis[maxn][maxn],cho[maxn][maxn],sz,ind[maxn];
double ans;
struct edge
{
	int v,nxt;
	edge(int vv=0,int nn=0){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
inline void bfs(int u)
{
	queue<int>q;
	q.push(u);
	dis[u][u]=0;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		for(int i=p[now];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[u][v]>dis[u][now]+1)
			{
				dis[u][v]=dis[u][now]+1;
				cho[u][v]=now;
				q.push(v);
			}
			else if(dis[u][v]==dis[u][now]+1&&now<cho[u][v])
			{
				cho[u][v]=now;
			}
		}
	}
}
map<dp,double>s;
int main()
{
	freopen("cchkk.in","r",stdin);
	freopen("cchkk.out","w",stdout);
	memset(p,-1,sizeof(p));
	n=getint(),m=getint();
	ss=getint(),t=getint();///s is congcong t is keke
	FOR(i,1,m)
	{
		int u=getint(),v=getint();
		ind[u]++,ind[v]++;
		add(u,v),add(v,u);
	}
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=n;++i)
	{
		bfs(i);
	}
	s[dp(0,ss,t)]=1;
	while(!s.empty())
	{
		map<dp,double>::iterator it=s.begin();
		it=s.begin();
		dp now=it->first;
		double expc=it->second;
		s.erase(it);
		now.times++;
		int temp=now.s;
		int cnt=0;
		bool ok=false;
		while(cnt<2)
		{
			temp=cho[now.t][temp];
			if(temp==now.t)
			{
				ans+=now.times*expc;
				ok=true;
				break;
			}
			cnt++;
		}
		if(ok)continue;
		now.s=temp;
		double pro=expc/(double)(ind[now.t]+1);
		for(int i=p[now.t];i!=-1;i=e[i].nxt)
		{
			int v=e[i].v;
			if(v==now.s)
			{
				ans+=pro*now.times;
			}
			else
			{
				s[dp(now.times,now.s,v)]+=pro;
			}
		}
		s[dp(now.times,now.s,now.t)]+=pro;
	}
	printf("%.3lf",ans);
	return 0;
}
```



---

## 作者：我杀文化课 (赞：0)

## 题意：
猫吃老鼠，猫初始为c点，老鼠初始为m点，猫先走，鼠后走，若猫走一步无法吃到老鼠，则可以再走一步，消耗时间相同。鼠可以走可以不走，概率相等，求猫迟到鼠的期望步数。

## 思考：
题目要求求出猫吃到老鼠的期望，我们先分析每一种情况（假设猫在$i$，鼠在$j$）

1. 猫在一步或者两步内可以吃到鼠，期望步数为1。

2. 猫无法在一步或两步内吃到鼠，那么先让猫走到离老鼠最近的点（记为$nxt[i][j]$），然后枚举老鼠走的每一个点（记为$v$），那么我们重复这两个步骤求出这两个点的期望。


其实以上两个步骤就是我们动态规划的过程，非常显然可以发现用记忆化搜索非常好实现。


在这里，我们定义$f[i][j]$表示猫在$i$，鼠在$j$时猫吃到鼠的期望概率。


答案也很明了，就是$f[c][m]$。


但是还有个大问题，怎么求出$nxt[i][j]$？


有两种：


较快的方法是跑n遍bfs，时间复杂度$O(n^2)$。


较慢的是跑n遍最短路(dijkstra)，时间复杂度$O(n(n+m)logm)$。


具体见代码：

```cpp
#pragma GCC optimize(2)
#include<cstdio>
#include<queue>
using namespace std;
int k,n,E,dism[2010][2010],nxt[2010][2010],c,m,head[4010],t[2010][2010],du[2010];
double f[2010][2010];
struct llk
{
	int to,nxt;
}e[4010];
struct lxwy
{
	int w,p;
	bool friend operator<(lxwy a,lxwy b)
	{
		return a.w>b.w;
	}
};
void adde(int u,int v)
{
	e[++k].to=v;
	e[k].nxt=head[u];
	head[u]=k;
}
void dij(int s)
{
    priority_queue<lxwy> q;
	for(int i=1;i<=n;i++) dism[s][i]=2e9;
    dism[s][s]=0;
    q.push((lxwy){0,s});
    while(!q.empty())
    {
        int u=q.top().p;
        q.pop();
        if(t[s][u]) continue;
        t[s][u]=1;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(dism[s][v]>dism[s][u]+1)
                dism[s][v]=dism[s][u]+1;
            q.push((lxwy){dism[s][v],v});
        }
    }
}//在这里，我跑的是dijkstra。
int s(int st,int en)
{
	int minn,mins=2e9;
	for(int i=head[st];i;i=e[i].nxt)
	{
		if(dism[e[i].to][en]<mins) minn=e[i].to,mins=dism[e[i].to][en];
		else if(dism[e[i].to][en]==mins&&e[i].to<minn) minn=e[i].to; 
	}//走一步
	if(minn==en) return minn;//吃不吃得到，可以的话就跳出，否则走两步
	mins=2e9;
	for(int i=head[minn];i;i=e[i].nxt)
	{
		if(dism[e[i].to][en]<mins) minn=e[i].to,mins=dism[e[i].to][en];
		else if(dism[e[i].to][en]==mins&&e[i].to<minn) minn=e[i].to;//要更新编号更小的点 
	}//第二步
	return minn;
}//这个是求nxt的函数
double dfs(int st,int en)
{
	if(f[st][en]) return f[st][en];
	if(st==en) return 0;//猫鼠在一起，一步都不走
	else if(nxt[st][en]==en) return 1;//走一或两步可以吃到
		 else 
		 {
			 f[st][en]=1;
			 for(int i=head[en];i;i=e[i].nxt) 
			 	f[st][en]=f[st][en]+dfs(nxt[st][en],e[i].to)/(du[en]+1);//鼠要走
			f[st][en]=f[st][en]+(dfs(nxt[st][en],en))/(du[en]+1);//鼠不走，就在原地
		 }	
	return f[st][en];
}
int main()
{
	scanf("%d%d%d%d",&n,&E,&c,&m);
	for(int i=1,u,v;i<=E;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v); adde(v,u);
		du[u]++;du[v]++;//算概率的时候要用
	}
	for(int i=1;i<=n;i++) dij(i);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++) nxt[i][j]=s(i,j);//求出nxt
	printf("%.3lf",dfs(c,m));
}
```


---


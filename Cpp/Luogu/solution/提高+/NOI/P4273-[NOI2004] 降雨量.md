# [NOI2004] 降雨量

## 题目描述

M 国是个多雨的国家，尤其是 P 城，频繁的降雨给人们的出行带来了不少麻烦。为了方便行人雨天过马路，有关部门在每处人行横道的上空都安装了一种名为“自动伞”的装置。（如图 $1$ 所示）
![](https://cdn.luogu.com.cn/upload/image_hosting/109hsm74.png)
每把自动伞都可以近似地看作一块长方形的板，厚度不计。这种伞有相当出色的吸水能力，落到上面的雨水都会完全被伞顶的小孔吸入，并通过管道运走。不下雨时，这些伞闲置着。一旦下雨，它们便立刻开始作匀速率直线往返运动：从马路的一边以固定的速率移动到另一边，再从另一边以相同的速率返回，如此往复，直到雨停为止。任何时刻自动伞都不会越过马路的边界。有了自动伞，下雨天没带伞的行人只要躲在伞下行走，就不会被雨淋着了。

由于自动伞的大小有限，当需要使用自动伞过马路的人比较多时，一把自动伞显然是不够的，所以有关部门在几处主要的人行横道上空安装了多把自动伞。每把自动伞的宽度都等于人行横道的宽度，高度各不相同，长度不一定相同，移动速率也不一定相同。

现在已知一处人行横道的详细情况，请你计算从开始下雨到 $T$ 秒钟后的这段时间内，一共有多少体积的雨水降落到人行横道上。

## 说明/提示

【约定】

○ 雨点均匀地匀速竖直下落

○ 自动伞和马路两者都是水平的

○ 自动伞的宽度和人行横道的宽度相等，都等于 $1$

○ $N \leq 10$

○ $W \leq 100$

○ $T \leq 100$

○ $V \leq 50$

○ 所有自动伞的往返次数之和不超过 $250$，一来一回算一个往返。


## 样例 #1

### 输入

```
2 4 3 10
0 1 1
3 1 -1```

### 输出

```
65.00```

# 题解

## 作者：传奇英雄 (赞：5)

听说是计算几何？看这数据范围，N<=10,T<=100，一股模拟的味道~

我用模拟A了哈哈哈哈

但是，不建议大家用模拟完成此题。很容易被卡。（此篇题解不作为标算，但是确实暴力压标算了。）

模拟的思路：将1秒拆成若干秒，然后模拟雨伞的移动。最后将雨伞位置的左右端点存入pair，排序，求出每一时刻挡住雨的体积。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int g=12;
int n,w,t,v,type;
double x[g],y[g],z[g],m,r,ans,d;
pair<double,double> a[g];

int main()
{
	//freopen("in","r",stdin);
	scanf("%d%d%d%d",&n,&w,&t,&v);
	type=n*t;//很容易卡精度！所以要根据数据范围选择不同的d
	if(type>500) d=0.00005;
	else
		if(type>200) d=0.000025;
		else d=0.000005;//将1秒拆成若干个d秒
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%lf",&x[i],&y[i],&z[i]);
		if(!x[i]&&y[i]==w)
		{
			printf("0.00");
			return 0;
		}
		y[i]+=x[i];//x，y是雨伞的左右端点
		z[i]*=d;//z是速度，这里乘d，计算出d秒的走过的路程
	}
	for(double k=0;k<t;k+=d)//总共要走完t秒
	{
		for(int i=1;i<=n;i++)
		{
			x[i]+=z[i];
			y[i]+=z[i];//改变左右端点
			if(x[i]<0)
			{
				x[i]=-x[i];
				y[i]+=x[i]*2;
				z[i]=-z[i];//碰到左边界要返回
			}
			if(y[i]>w)
			{
				m=(y[i]-w)*2;//超出边界的距离要退回去
				y[i]-=m;
				x[i]-=m;
				z[i]=-z[i];//碰到右边界要返回
			}
			a[i].first=x[i];
			a[i].second=y[i];//左右端点存入pair
		}
		sort(a+1,a+n+1);
		m=r=0;//这里m为此刻能挡的雨的体积
		for(int i=1;i<=n;i++)
		{//排序后扫描一遍即可算出m
			if(a[i].first>r)
				r=a[i].first;
			if(a[i].second>r)
			{
				m+=a[i].second-r;
				r=a[i].second;
			}
		}
		ans+=m;//累计答案
	}
	printf("%.2f",v*(w*t-ans*d));//要求的答案是落在马路上的雨
	return 0;
}
```
最后强调！模拟不是本题正解！很容易卡！如果用模拟通过了这个题，建议用计算几何重写一遍。

---

## 作者：Hadtsti (赞：3)

### 题意简述

宽为 $W$ 的街道上有 $n$ 块在街道两侧之间来回移动的伞。给定伞的初始位置 $x$、速度 $v$ 和长度 $l$ 以及单位面积单位时间降雨量 $V$，求 $T$ 个单位时间内落在路面上的雨体积。

$N \leq 10,W \leq 100,T \leq 100,V \leq 50$。
特别地，所有伞的折返次数之和不多于 $250$ 次。

### 题目分析

~~给个不那么乱搞的题解~~

如果以时间为横轴，位置为纵轴建立坐标系，则伞本身可以看作一段竖直的线段，其轨迹则是一些连在一起的平行四边形。那么我们只需要求出这些图形的并的面积，用总面积减去后乘上 $V$ 就可以了。样例对应的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/62p1ps8j.png)

阴影面积为 $5.5$，则空白面积为 $3\times 4-5.5=6.5$，乘 $V$ 即可得到答案。

那么如何求阴影部分面积并呢？矩形面积并那个题使用了扫描线，本题也可以类比。具体地，从左到右扫描线，注意到我们可以把图形分段，使得每一段都是由同高的若干个梯形组成。设上底为 $a$，下底为 $b$，高为 $h$，则梯形的面积是 $\frac{h(a+b)}{2}$。那么对于高均为 $h$ 的 $m$ 个梯形，设其上底为 $a_1\sim a_m$，下底为 $b_1\sim b_m$，则其面积之和为 $\displaystyle\sum_{i=1}^m\frac{h(a_i+b_i)}{2}=\frac{h}2\sum_{i=1}^m(a_i+b_i)=\frac{h}2(\sum_{i=1}^ma_i+\sum_{i=1}^mb_i)$。即我们只需要求出图形每一段左右两侧分别的线段覆盖长度就可以简单地求出该段面积。

现在的问题是如何分段。事实上，有以下两种情况使得原来全由同高梯形构成的一段被破坏：

- 线段端点碰到边界（即道路两侧）

- 两个线段端点重合

我们只需要预处理出对应时间点，就可以简单地分段算了。仍以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/fqgnn6dp.png)

线段端点碰到边界的时间是好处理的，端点重合情况只需要枚举每两个线段，将其碰到边界时间合并排序，在每一段内算出直线解析式并判断是否相交统计即可。详细细节看代码。

关于复杂度，设往返次数和为 $k$，则时间点数量为 $O(nk)$ 级别，则排序复杂度为 $O(nk\log nk)$，每个时间点算线段长度并的复杂度为 $O(n)$，则总复杂度为 $O(nk(n+\log nk))$，可以通过本题。~~感觉常数很大但是目前最优解。~~

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
double eps=1e-8;
int n,num[15],cnt2,cnt=1;
bool kd[15][260];
double w,t,v,a[15],b[15],c[15],pos[15][260],B[30010],ans,ls;
vector<pair<double,double> >vec;
struct node
{
	double pos;
	int kd;//标记要改什么 
	friend bool operator <(node a,node b)
	{
		return a.pos<b.pos;
	}
}P[260];
void add(int p,int q)
{
	cnt2=0;
	for(int i=1;i<=num[p];i++)
		P[++cnt2]=node{pos[p][i],kd[p][i]};
	for(int i=1;i<=num[q];i++)
		P[++cnt2]=node{pos[q][i],kd[q][i]+2};
	P[++cnt2]=node{t,-1};
	sort(P+1,P+cnt2+1);
	double K1=c[p],B1=a[p],K2=c[q],B2=a[q];
	if(fabs(K1)<eps&&fabs(K2)<eps)//如果平行则要么不交要么一直重合，不用管了
		return;
	for(int i=1;i<=cnt2;i++)
	{
		if(fabs(K1-K2)>eps)
			for(int j=0;j<2;j++)
				for(int k=0;k<2;k++)//枚举端点
				{
					double x=(B2+j*b[q]-B1-k*b[p])/(K1-K2);
					if(x<P[i].pos+eps&&x>P[i-1].pos-eps)
						B[++cnt]=x;
				}
		if(P[i].kd<2)
			K1=-K1,B1=2.0*P[i].kd*(w-b[p])-B1;
		else
			K2=-K2,B2=2.0*(P[i].kd-2)*(w-b[q])-B2;//改解析式
	}
}
int main()
{
	scanf("%d%lf%lf%lf",&n,&w,&t,&v);
	B[1]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%lf",&a[i],&b[i],&c[i]);
		if(b[i]>w-eps)//特判一个伞覆盖全部 
		{
			printf("0.00");
			return 0;
		}
		if(fabs(c[i])<eps)//静止则要么不碰要么重合，不用管
			continue;
		double fs=(c[i]>eps)?(w-b[i]-a[i])/c[i]:-a[i]/c[i],d=(c[i]>eps)?(w-b[i])/c[i]:(b[i]-w)/c[i];//正速度先碰上边界，反之碰下边界 
		bool fg=c[i]>eps;
		while(fs<t+eps)
		{
			pos[i][++num[i]]=fs;
			B[++cnt]=fs;
			kd[i][num[i]]=fg;
			fg^=1;
			fs+=d; 
		}
		for(int j=1;j<i;j++)
			add(i,j);
	}
	B[++cnt]=t;
	sort(B+1,B+cnt+1);//这里加上离散化会快一点，但没必要 
	for(int i=1;i<=cnt;i++)
	{
		double T=B[i],sum=0;
		vec.clear();
		for(int j=1;j<=n;j++)
		{
			double L=T*c[j]+a[j];
			L-=floor(L/2.0/(w-b[j]))*2.0*(w-b[j]);
			L=min(L,2*(w-b[j])-L);
			vec.push_back({L,L+b[j]});
		}//所有线段 
		sort(vec.begin(),vec.end());
		double L=-1e10,R=-1e10;
		for(auto j:vec)
		{
			if(j.first>R+eps)
			{
				sum+=R-L;
				L=j.first;
			}
			R=max(R,j.second);
		}
		sum+=R-L;//算出线段长度并 
		ans+=0.5*(B[i]-B[i-1])*(sum+ls);//更新答案 
		ls=sum;
	}
	printf("%.2lf",v*(t*w-ans));
	return 0;
}
```

---


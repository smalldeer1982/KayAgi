# [NOI2002] 贪吃的九头龙

## 题目背景

传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是 说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的 总数会远大于九，当然也会有旧头因衰老而自己脱落。 

## 题目描述

有一天，有 $M$ 个脑袋的九头龙看到一棵长有 $N$ 个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把 $N$ 个果子分成 $M$ 组，每组至少有一个果子，让每个头吃一组。

这 $M$ 个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好 $K$ 个果子，而且 $K$ 个果子中理所当然地应该包括唯一的一个最大的果子。果子由 $N-1$ 根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。

对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。

九头龙希望它的“难受值”尽量小，你能帮它算算吗？

例如图 $1$ 所示的例子中，果树包含 $8$ 个果子，$7$ 段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉 $4$ 个果子，其中必须包含最大的果子。即 $N=8$，$M=2$，$K=4$：

![](https://cdn.luogu.com.cn/upload/pic/16595.png )

图一描述了果树的形态，图二描述了最优策略。 

## 说明/提示

该样例对应于题目描述中的例子。 

## 样例 #1

### 输入

```
8 2 4 
1 2 20 
1 3 4 
1 4 13 
2 5 10 
2 6 12 
3 7 15 
3 8 5 ```

### 输出

```
4```

# 题解

## 作者：cunzai_zsy0531 (赞：45)

## P4362 [NOI2002]贪吃的九头龙-题解  --zsy

[传送门](https://www.luogu.com.cn/problem/P4362)

这个题显然是一个树形dp。我们先来总结一下树形dp的套路：

1. 定义f数组意义，注意要考虑到题目的一些特殊要求（比如本题的大头），还要考虑到如何输出结果。

2. 思考如何将一个点的所有f值由这个点的儿子节点转移过来，即我们常说的状态转移方程。

3. 将方程放到dfs深搜中更新f值，最终输出答案。

所以，我们先来考虑这个题怎么样定义f数组来处理特殊要求。

一、 关于**大头**？

我们整理题目可以发现，关于大头，本题大概有这样两个限制：

1. 大头必须吃掉1号节点

2. 大头必须吃掉k个节点

所以，我们大可以用f[i][j]表示对于i号节点，它与它的儿子们一共有j个节点被**大头**吃掉了。

这样有什么好处呢？我们可以发现，最后我们只需要输出f[1][k]就万事大吉了——等等，第一个限制是不是还没考虑？

这样，我们可以再把f开一维[0/1]，用f[i][j][0/1]表示i号节点有没有被**大头**吃掉，0表示不是**大头**吃的，1表示是**大头**吃的。现在我们可以输出f[1][k][1]，就完完全全考虑完了**大头**的限制啦！

二、转移方程？

对于每一个节点u来说，我们需要把f[u][0-k][0/1]全部更新才算更新完了所有状态。考虑什么情况下会增加难受值——如果有3个或以上的头，虽然可能有的边连的两个点都没有被**大头**吃掉，但是一定可以通过剩下的头让这条边不被吃掉（这个应该很显然吧）。但是如果只有两个头，我们会发现，如果这两个点都没被**大头**吃掉，那它们一定被另一个头吃了。所以，我们在判断的时候要格外注意m=2的情况。

对于**大头**不吃u点的情况，可能由v,u**大头**都不吃和吃v不吃u两种情况转移过来；吃u点同理。dp方程大概长这样，反正就是考虑一下各种可能就好啦。

$f_{u,j,0}=min(f_{u,j,0},min(f_{v,t,0}+f_{u,j-t,0}+[m==2]* w,f_{v,t,1}+f_{u,j-t,0}))$

$f_{u,j,1}=min(f_{u,j,1},min(f_{v,t,1}+f_{u,j-t,1}+w,f_{v,t,0}+f_{u,j-t,1}))$

(u,v,w指的是一条边的父亲，儿子和边难受值)

这样我们就可以把它放在dfs里得出答案啦！

```cpp
for(int j=0;j<=k;++j){
	for(int t=0;t<=j;++t){
		f[u][j][0]=min(f[u][j][0],min(f[v][t][0]+f[u][j-t][0]+(m==2)*w,f[v][t][1]+f[u][j-t][0]));
		f[u][j][1]=min(f[u][j][1],min(f[v][t][1]+f[u][j-t][1]+w,f[v][t][0]+f[u][j-t][1]));
	}
}
```

然而它挂了……我们思考一下为什么呢？原来，这题在更新f[u][j]的时候会被f[u][j-t]更新，所以这个东西就开始自己~~搞~~自己了……所以我们要用一个数组先去记录一下f[u]，然后就可以放心做dp了。

完了吗？还是没有……我就是卡在了-1上。我们思考一下，什么情况下会无解呢？注意到题目中的一个条件——每个组都要有果子，也就是每个头都要吃到果子。如果**大头**吃剩下的比剩下的头数要少，是不是就无解了？所以我们只需要判断$n-k<m-1$就可以判掉无解情况了。

## Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1000+4;
struct Edge{int v,w,nxt;}e[N<<1];
int h[N],f[N][N][2],tmp[N][2];
int tot,m,n,k;
inline void add(int u,int v,int w){
	e[++tot]=(Edge){v,w,h[u]};
	h[u]=tot;
}
void dfs(int u,int fa){
	f[u][0][0]=f[u][1][1]=0;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v==fa) continue;
		dfs(v,u);
		memcpy(tmp,f[u],sizeof(f[u]));
		memset(f[u],0x3f,sizeof(f[u]));
		for(int j=0;j<=k;++j){
			for(int t=0;t<=j;++t){
				f[u][j][0]=min(f[u][j][0],min(f[v][t][0]+tmp[j-t][0]+(m==2)*w,f[v][t][1]+tmp[j-t][0]));
				f[u][j][1]=min(f[u][j][1],min(f[v][t][1]+tmp[j-t][1]+w,f[v][t][0]+tmp[j-t][1]));
			}
		}
	}
}
int main(){
	memset(f,0x3f,sizeof(f));
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1,u,v,w;i<n;++i){
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w),add(v,u,w);
	}
	if(n-k<m-1){printf("-1\n");return 0;}
	dfs(1,0);
	printf("%d\n",f[1][k][1]);
	return 0;
}
```
 # 完结撒花！

---

## 作者：龙神哈迪斯 (赞：42)

Sol
===
题目大意
有一棵树，你需要将N个点染成M种颜色，且需满足一下两种条件

1.一号点必须是一号颜色，且一号颜色必须包含K个点

2.每种颜色必须包含至少一个点

代价为若一条边连接的颜色相同则得付出该边的代价
求满足以上两种情况下的代价之和

题解
===
其实在我动笔写题解之前，这里还是一篇题解都没用的，然后调了好久，在常规课的压迫下终于在今天把$Sol$写完了

~~而且自认为应该比上一篇博客写的好些吧~~

首先，一眼看出是道树dp题

然后日常套路，设$f[u][j]$表示以$u$为子树包含$j$种一号颜色下的最小代价，然后发现无法判断两个点之间是否颜色相同，于是再加一维$f[u][j][0/1]$表示在$u$号点上是否染为一号颜色

然后开始最重要的yy

如果`M==2`的话，一条边连接的两个点只有一个为1一个不为1的情况下才不会付出代价

如果`M>2`的话，一条边连接的两个点只要不是都为1就不会付出代价

为什么呢？

显然可以通过奇偶性来强制两个点颜色不同，这样就不用付出边的代价了，且满足条件
然后dp方程就是

f[u][j][0]=min(f[u][j][0],min(f[v][t][0]+f[u][j-t][0]+(M==2)*e[i].w,f[v][t][1]+f[u][j-t][0]));

f[u][j][1]=min(f[u][j][1],min(f[v][t][1]+f[u][j-t][1]+e[i].w,f[v][t][0]+f[u][j-t][1]));

然后惊奇的发现其实我们连样例都过不了(~~尴尬~~)

于是重新审视dp方程

我们需要每次dp前将之前的f数组备份下来，不然的话f值在dp中会越来越小(当然如果N也很小的话其实也没什么影响)

所以我们用tmp[j][0/1]来存f[u]数组的值

f[u][j][0]=min(f[u][j][0],min(f[v][t][0]+tmp[j-t][0]+(M==2)*e[i].w,f[v][t][1]+tmp[j-t][0]));

f[u][j][1]=min(f[u][j][1],min(f[v][t][1]+tmp[j-t][1]+e[i].w,f[v][t][0]+tmp[j-t][1]));

然后就能愉快的AC了
				
好了，上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int _=305;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int N,M,K,f[_][_][2],tmp[_][2];
struct hand{int to,next,w;}e[_<<1];
int cnt,head[_];
void link(int u,int v,int w)
{
	e[++cnt]=(hand){v,head[u],w};
	head[u]=cnt;
}
void dfs(int u,int fa)
{
	f[u][0][0]=f[u][1][1]=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
		memcpy(tmp,f[u],sizeof(tmp));
		memset(f[u],63,sizeof(f[u]));
		for(int j=0;j<=K;++j)
		{
			for(int t=0;t<=j;++t)
			{
				f[u][j][0]=min(f[u][j][0],min(f[v][t][0]+tmp[j-t][0]+(M==2)*e[i].w,f[v][t][1]+tmp[j-t][0]));
				f[u][j][1]=min(f[u][j][1],min(f[v][t][1]+tmp[j-t][1]+e[i].w,f[v][t][0]+tmp[j-t][1]));
			}
		}
	}
}
int main()
{
	N=read();M=read();K=read();
	if(N-K<M-1){puts("-1");return 0;}
	for(int i=1;i<N;++i)
	{
		int x=read(),y=read(),z=read();
		link(x,y,z);link(y,x,z);
	}
	memset(f,63,sizeof(f));
	dfs(1,1);
	printf("%d\n",f[1][K][1]);
	return 0;
}

```


---

## 作者：lytqwq (赞：13)

设 $f_{i,j,0}$ 表示 当前在 $i$ 号节点，让大头吃 $j$ 个，最后是**小头**吃了 $i$ 节点 的最小难受值。

设 $f_{i,j,1}$ 表示 当前在 $i$ 号节点，让大头吃 $j$ 个，最后是**大头**吃了 $i$ 节点 的最小难受值。

显然，如果我们有多于 $1$ 个的小头，那么就不可能会出现小头吃树枝的情况，因为我们可以让小头交替存在

但是如果现在是大头或者只有一个小头，如果父节点和子节点的是同一种头吃的，这段树枝就会被算作难受值。

把大头吃的数量看作背包容量，这就是个类似背包的问题，注意对于父节点来说，子节点的情况必须要选一个，我们先提前选一个情况再转移即可

对于父节点的每个儿子，状态转移方程就是：

$v$ 是 $i$ 的一个儿子

$$
f_{i,j,k}=\min\{f_{i,j-p,k}+\min(f_{v,p,k\oplus1},f_{v,p,k}+[k=1|m=2]W_{i,v})\} (0\le p\le j)
$$

时间复杂度是 $O(n^3)$

代码很短，跑了 $71ms$

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=610;
int n,m,k,cnt,Hd[N],Ne[N],V[N],W[N],f[N][N][2];
void add(int u,int v,int w){V[cnt]=v;W[cnt]=w;Ne[cnt]=Hd[u];Hd[u]=cnt++;}
void dfs(int u,int fa){
	f[u][0][0]=0;f[u][1][1]=0;
	for(int i=Hd[u];i!=-1;i=Ne[i]){
		int v=V[i];
		if(v!=fa){
			dfs(v,u);
			for(int j=k;j>=0;j--)for(int o=0;o<2;o++){
				f[u][j][o]=f[u][j][o]+f[v][0][0];
				if(o==0&&m==2)f[u][j][o]+=W[i];
				for(int p=0;p<=j;p++)f[u][j][o]=min(f[u][j-p][o]+min(f[v][p][o^1],f[v][p][o]+(o==1||m==2)*W[i]),f[u][j][o]);
			}
		}
	}
}
int main(){
	memset(Hd,-1,sizeof(Hd));
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n-1;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	memset(f,0x3f,sizeof(f));
	dfs(1,0);
	printf("%d\n",n-k-m+1<0?-1:f[1][k][1]);
}
```
















---

## 作者：不存在之人 (赞：12)

题目简述：

将一棵树中的节点染成M种颜色，每个节点有且只有一种颜色，在满足以下条件下使得两端颜色相同的边的权值和最小，所有边权均非负。

（1）必须有K个1号颜色的点；

（2）1号节点必须是1号颜色；

（3）每种颜色必须至少有一个节点。如无解，输-1。

无解的情况很明显，当且仅当N-K<M-1时无解。

 

考虑用动态规划来解决。

如果以一棵子树作为一个子结构，分析需要考虑的状态：

（1）根节点的颜色。

（2）1号颜色的个数。

（3）树中颜色的分配情况，如何保证每种颜色都有节点。

 

初步分析可以得到一种四维的状态:

f[i][j][k][w]，表示在以i为根的子树中，有j个1号节点，根染k号颜色，树中已有的颜色用w表示（w是一个二进制数）的状态下最小的权值和。

首先，这个方程用到了状态压缩w，因此对于本题300的数据范围是不现实的，需要继续思考。

假设这样一个问题，仍然是对树染色，可以任意染色，那么只要2种颜色，就可以保证任意一条边两端的颜色不同，联想到这道题，因为1号颜色比较特殊，因此单独处理，而余下的颜色如果大于等于2种，那么无论1号颜色如何染色，都可以保证一条边两边不会出现相同的非1号颜色的情况，换言之，如果M>=3，对答案有贡献的只有1号颜色节点之间的边。这样当M>=3时，可以直接按3处理，这样状态压缩是可以承受的。既然有了这样的优化，k也可以只用0,1来表示，1表示1号颜色，0表示非1号颜色。而M=2时就更简单了，0,1就直接把颜色分开了。

初步分析下来，得到了一个状态数为O(N*K*2*2³)，转移为O(K*2*2³)，总复杂度为O(N*K²*256)。由于N,K≤300，理论分析是会超时，但实际操作中可以不用循环到K，因为循环的上限可以设为min(K,子树i的总节点数)。这样的话，这个复杂度还是可以承受的。

本题还有优化吗？答案是肯定的。

如果要优化状态，前3维似乎是无法优化的，考虑第4维。之所以一开始要加入这一维，就是担心会存在有一些颜色无法染上的问题，经过后来的分析，发现除了1号颜色会对答案有贡献之外，其他颜色其实是可以被忽略的，因为我们可以保证它们不会对答案造成影响，那么只要有足够多的节点来染除1外的颜色，就可以确保每一种颜色都可以被染上，至于到底在哪里，其实并不重要。这样想，就会发现其实第四维是完全多余的，可以直接略去。

最终状态:

f[i][j][k], 表示在以i为根的子树中，有j个1号节点，根染k号颜色的状态下最小的权值和。

注意：在具体转移时，要先将原来的f[i]复制一份，然后将f[i]清为无穷大，然后用备份的f[i]结合上述方程来计算f[i]的值。因为计算儿子没计算完时的状态是不能保留的，因为他们没有考虑完所有的情况，严格来讲，可以在上述方程中加上1维，表示计算到当前根的第几个儿子，每一次都是有上一次的状态和儿子的最终状态合并。这样就可以用滚动数组或辅助数组的方式来实现。

设y是i的一个儿子。

f[i][j][1]=min{f[i][j][1],f[y][k][1]+ pref[i][j-k]
[1]+value[i][y],f[y][k][0]+ pref[i][j-k][1]}

f[i][j][0]=min

{f[i][j][0],

f[y][k][0]+ pref[i][j-k][0]+ value[i][y] |if m=2

f[y][k][0]+ pref[i][j-k][0]+ value[i][y] , f[y][k][1]+ pref[i][j-k][0]| if m≠2

}

初始值，对于每一个i，f[i][0][0]=f[i][1][1]=0.

答案为f[1][K][1]。

AC代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define N 305
struct node{
    int v,w,next;
}e[N<<1];
int tot,head[N<<1];
int n,m,K;
int sum[N],tmp[N][2],f[N][N][2];
inline void MIN(int &x,int y,int z){
    if(x>y) x=y;
    if(x>z) x=z;
}
inline void add(int x,int y,int z){
    e[++tot].v=y;
    e[tot].w=z;
    e[tot].next=head[x];
    head[x]=tot;
}
void dp(int x,int from){
    f[x][1][1]=f[x][0][0]=0;sum[x]=1;
    int i,j,k,y,t;
    for(i=head[x];i;i=e[i].next){
        if((y=e[i].v)!=from){
            dp(y,x);
            sum[x]+=sum[y];
            t=(m==2?e[i].w:0);
            //MIN(f[i][j][1],f[y][k][1]+pref[i][j-k][1]+val[i][y],f[y][k][0]+pref[i][j-k][1]);
            //MIN(f[i][j][0],f[y][k][0]+pref[i][j-k][0]+val[i][y]{m=2},f[y][k][1]+pref[i][j-k][0]{m!=2});
            memcpy(tmp,f[x],sizeof f[x]);
            memset(f[x],127/3,sizeof f[x]);
            for(j=sum[x];j+1;j--){
                if(j)
                for(k=j-1;k+1;k--) MIN(f[x][j][1],tmp[j-k][1]+f[y][k][0],tmp[j-k][1]+f[y][k][1]+e[i].w);
                for(k=j;k+1;k--) MIN(f[x][j][0],tmp[j-k][0]+f[y][k][0]+t,tmp[j-k][0]+f[y][k][1]);
            }
        }
    }
}
int main(){
    memset(f,127/3,sizeof f);
    scanf("%d%d%d",&n,&m,&K);
    if(n-K<m-1){puts("-1");return 0;}
    for(int i=1,x,y,z;i<n;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,z);
    }
    dp(1,0);
    printf("%d\n",f[1][K][1]);
    return 0;
}
```

---

## 作者：vectorwyx (赞：11)

大头所吃掉的果子一定会将原树分割成若干棵子树，若小头的数量 $m-1$ 等于 $2$，对分割出来的子树进行黑白染色，一定存在一种方案使得每一对相邻的点颜色不同，因此小头与小头之间的边不会对答案产生贡献。若 $m-1>2$，我们只需要从这些子树上随便选出 $m-3$ 个点与任意 $m-3$ 个小头一一对应，再对其余的点进行黑白染色，这样的话就与前面一样了。

综上，若 $m\ge 3$，那么小头与小头之间的边一定不会产生贡献。把 $1$ 作为根结点，问题就转化成在原树上取包括根结点在内的 $k$ 个点使得难受值最小，令 $dp_{i,j,0/1}$ 表示从以 $i$ 为根的子树中取不包含/包含 $i$ 的 $j$ 个点所能达到的最小难受值，转移可以参考树形背包，即再做一个合并子树的 $dp$，令 $f_{i,j}$ 表示不选根结点时前 $i$ 棵子树选 $j$ 个的最小难受值。转移方程为 $f_{i,j}=\min(f_{i-1,q}+\min(dp_{p,j-q,0},dp_{p,j-q,1}))$，其中 $0\le j,q\le siz$，$p$ 为第 $i$ 棵子树的跟结点，$siz$ 为整棵树的结点个数。选根结点时的转移方程同理。最终 $dp_{1,k,1}$ 就是我们所求的答案。

若 $m=2$，那小头与小头之间的边一定会产生贡献，对转移方程稍作修改即可。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=305;
struct Edge{
	int to,next,val;
}e[N<<1];
int head[N],tot,n,m,k,dp[N][N][2],f0[N],f1[N],siz[N];

void connect(int x,int y,int v){
	e[++tot]=(Edge){y,head[x],v};
	head[x]=tot; 
}

void dfs(int now,int from){
	for(int i=head[now];i;i=e[i].next){
		int p=e[i].to;
		if(p==from) continue;
		dfs(p,now);
	}
	memset(f0,0x3f,sizeof f0);
	memset(f1,0x3f,sizeof f1);
	siz[now]=1;
	f0[0]=f1[0]=0; 
	for(int i=head[now];i;i=e[i].next){
		int p=e[i].to;
		if(p==from) continue;
		siz[now]+=siz[p];
		fo(w,0,siz[p]) f0[siz[now]]=min(f0[siz[now]],f0[siz[now]-w]+min(dp[p][w][0]+(m==2)*e[i].val,dp[p][w][1]));
		go(j,siz[now]-1,0){
			f0[j]=f0[j]+(m==2)*e[i].val+dp[p][0][0];
			f1[j]=f1[j]+dp[p][0][0];
			fo(w,1,min(j,siz[p])){
				int q=j-w;
				f0[j]=min(f0[j],f0[q]+min(dp[p][w][0]+(m==2)*e[i].val,dp[p][w][1]));
				f1[j]=min(f1[j],f1[q]+min(dp[p][w][0],dp[p][w][1]+e[i].val));
			}			
		}
	}
	dp[now][0][0]=f0[0];
	fo(i,1,siz[now]) dp[now][i][0]=f0[i],dp[now][i][1]=f1[i-1];
}

int main(){
	cin>>n>>m>>k;
	if(k+m-1>n){
		cout<<-1;
		return 0;
	}
	fo(i,1,n-1){
		int x=read(),y=read(),v=read();
		connect(x,y,v);
		connect(y,x,v);
	}
	dfs(1,0);
	cout<<dp[1][k][1];
	return 0;
}
```
点个赞再走吧QAQ，谢谢！

---

## 作者：zhangjiacheng (赞：5)

## 好像又没有pascal题解。。。
### 思路：本题树形dp，然后还有dfs。
##### 代码如下
```pascal
var
  f:array[0..301,0..301,0..1] of longint;
  a:Array[0..301] of longint;
  lc,rc,data:array[0..301] of longint;
  ans,n,m,p:longint;
function Find(x:longint):longint;
begin
  if x=0 then exit(0);
  a[x]:=1;
  inc(a[x] , Find(rc[x]) + Find(lc[x]) );
  exit(a[x]);
end;
function fmin(x,y:longint):longint;
begin
  if x<y then exit(x)
  else exit(y);
end;
procedure init;
var
  x,y,d,i:longint;
begin
  readln(n,m,p);
  for i:=1 to n-1 do
    begin
      readln(x,y,d);
      rc[y]:=lc[x];//多叉转二叉
      lc[x]:=y;
      data[y]:=d;
    end;
  a[1]:=Find(1);//预处理第i个点向下有多少个节点,包含自己
end;
function dfs(x,k,col:longint):longint;
var
  temp,i,t1,t2:longint;
begin
  if k<0 then exit(123456789);//状态不成立
  if(x=0)and(k=0)then//特判一下
     begin
       f[x,k,col]:=0;
       exit(0);
     end;
  if f[x,k,col]>=0 then exit(f[x,k,col]);//记忆化
  if f[x,k,col]=-1 then f[x,k,col]:=123456789;
  for i:=0 to fmin(k , a[x]) do//枚举
    begin
      t1:=dfs(lc[x],i-1,0)+ord(col=0)*data[x];
      t2:=dfs(lc[x],i,1)+ord(m=2)*ord(col=1)*data[x];
      temp:=fmin(t1 , t2);
      inc( temp , dfs(rc[x],k-i,col) );//向兄弟分担大头吃k-i个果子
      f[x,k,col]:=fmin(f[x,k,col] , temp);
    end;
  exit(f[x,k,col]);
end;
procedure main;
var
  i,j,k:longint;
begin
  if n-p<m-1 then//特判一下，果子不够吃
     begin
       writeln(-1);
       exit;
     end;
  fillchar(f,sizeof(f),255);
  ans:=dfs(lc[1],p-1,0);//大头必须要吃第一个果子
  writeln(ans);
end;
begin
  init;
  main; 
end.
```

---

## 作者：吾王美如画 (赞：4)

唔姆，突然想写一篇九头龙的题解。~~其实我也不会做~~

first,我们可以很轻松地判断无解的情况：N<K+M-1；否则就至少有一组解。

接着，我们发现，当m=2时，只有一个小头，那么如果一个树枝两头的果子都是大头吃或者都不是大头吃，我们都要吃掉这段树枝。

当M>=3的时候，小头至少有两个。所以只有当一段树枝的两边的果子都是大头吃的，我们才要吃掉这段树枝。（因为我们可以把其他的果子按高度的奇偶性分成两份，让一个头吃高度为奇数的，另一个吃高度为偶数的，这样就不会吃树枝了）~~其实我当时是猜的~~

OK，这样我们就想的差不多了。这道题很明显是道树型dp，只不过要把多叉转一下二叉（反正各位大佬都会）我们用f[i][j][k]表示以i的父结点为根的子树中有j个果子分给大头的最小的蓝瘦值。k=0表示**i的父结点**给小头吃，k=1表示**i的父结点**给大头吃。

于是，X1和X2之间的转移就是f[i][j][k]=min(f[X1][j1][1]+f[X2][j-j2-2][k]+d[k][1]*cost[i][fa[i]],f[X1][j1][0]+f[X2][j-j1][k]+d[k][0]*cost[i][fa[i]])

ps:d定义为d[i][j]=1(i=1&&j=1) d[i][j]=1(i=0&&j=0&&M=2) 其他情况就是0啦

and 觉得把这个子树的值保存下来，就如楼上大佬说的，不保存会很尴尬

算法理论复杂度应该是O(NK^2)但实际上应该快的多QAQ

贴上蒟蒻的炒鸡难看的代码QAQ
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m,k,son[1000],brother[1000],cost[1000],cnt=0,dp[305][305][2],tmp[305][2],father[305];
void lian(int a,int b,int w){
     son[++cnt]=b;
     brother[cnt]=father[a];
     cost[cnt]=w;
     father[a]=cnt;
}
void dfs(int a,int b){
     dp[a][0][0]=dp[a][1][1]=0;
     for(int i=father[a];i;i=brother[i]){
             if (son[i]==b)continue;
             dfs(son[i],a);
             memcpy(tmp,dp[a],sizeof(tmp));
             memset(dp[a],-1000,sizeof(dp[a]));
             for(int j=0;j<=k;j++){
                     for(int q=0;q<=j;q++){
                             dp[a][j][0]=min(dp[a][j][0],min(dp[son[i]][q][0]+tmp[j-q][0]+(m==2)*cost[i],dp[son[i]][q][1]+tmp[j-q][0]));
                             dp[a][j][1]=min(dp[a][j][1],min(dp[son[i]][q][1]+tmp[j-q][1]+cost[i],dp[son[i]][q][0]+tmp[j-q][1]));
                     }
             }       
     }
}
int main(){
    cin>>n>>m>>k;
    if (n-k+1<m){cout<<-1;return 0;};
    for(int i=1;i<n;i++){
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            lian(a,b,c);lian(b,a,c);
    }
    memset(dp,-1000,sizeof(dp));
    dfs(1,1);
    cout<<dp[1][k][1];
    return 0;
}

```
~~orz wlq~~

---

## 作者：秋日私语 (赞：3)

[树形动态规划](https://blog.csdn.net/a_comme_amour/article/details/78456630)树形动态规划

分析：
首先，当小头大于一个时，都让小头来吃，肯定不会有难受值。因为小头可以隔一个分一个。（当时为什么没有分析出来呢？）。这样我们就把问题转化成了
m==2时 大头+小头
m>2时 只需要考虑大头吃k个
无解，不够吃的：K+M-1>N;
f[i][j][k]:表示以i为根的子树选出j个果子（包括自身）时最小的难受值（k=1表示他爸爸被大头吃，k=0表示他爸爸被小头吃）

	int t1=dfs(node[root].lc,i,0)+(m==2)*(flag==0)*node[root].dis;
	int t2=dfs(node[root].lc,i-1,1)+(flag==1)*node[root].dis;
	int t3=dfs(node[root].rc,k-i,flag);
	f[root][k][flag]=min(f[root][k][flag],min(t1,t2)+t3);
这些细节都要注意。 还有多叉树转二叉树的方法。
还是要看题解

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=301;
const int INF=100000000;//原来是INF开的太大了 
int n,m,k,x,y,z,f[MAXN][MAXN][2],sum[MAXN];
struct Tree{
	int lc,rc,dis;
}node[MAXN];

int dfs(int root,int k,bool flag)
{
	if (k<0) return INF;//这里return的是INF而不是0 
	if (f[root][k][flag]>=0) return f[root][k][flag];
	if (!root&&!k) return f[root][k][flag]=0;
	
	f[root][k][flag]=INF;
	for (int i=0; i<=min(k,sum[root]); i++)//可以取0，各种边界和细节 
	{
		int t1=dfs(node[root].lc,i,0)+(m==2)*(flag==0)*node[root].dis;
		int t2=dfs(node[root].lc,i-1,1)+(flag==1)*node[root].dis;
		int t3=dfs(node[root].rc,k-i,flag);
		f[root][k][flag]=min(f[root][k][flag],min(t1,t2)+t3);
	}
//	printf("%d\n",f[root][k][flag]);
	return f[root][k][flag];
}

void find_son(int root)//包括根节点本身 
{
	if (!root) return;
	find_son(node[root].lc);
	find_son(node[root].rc);
	sum[root]=sum[node[root].lc]+sum[node[root].rc]+1;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	memset(f,255,sizeof(f));
//	f[0][0][0]=0; f[0][0][1]=0;
	
	for (int i=1; i<=n-1; i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		node[y].rc=node[x].lc;
		node[x].lc=y;
		node[y].dis=z;
	}
	if (k+m-1>n) {printf("-1\n"); return 0;}
	find_son(1);
//	for (int i=1; i<=n; i++)	printf("i:%d l:%d r:%d dis:%d\n",i,node[i].lc,node[i].rc,node[i].dis);
//	for (int i=1; i<=n; i++)	printf("%d ",sum[i]);
	printf("%d",dfs(node[1].lc,k-1,1));
	return 0;
}
```

---

## 作者：vеctorwyx (赞：3)

读题找到无解的情况：大头吃掉的$K$个果子后，剩下的$N - K$个果子不够其他的$M-1$个头分，即$N-K<M-1$

题目中只限制除了大头外的头要吃至少一个果子，也就是说一段树枝相连的两个果子若被同一个头吃掉，则只会被大头吃掉，否则不是最优（$M=2$的情况除外）。

证明（
~~口胡~~）：

如果出现树枝相连的两个果子被同一个非大头吃掉，则可以把其中一个换成另一个非大头，修改后没有改变大头吃的果子数，但使难受值变小了，所以“树枝相连的两个果子被同一个非大头吃掉”一定不是最优解。

考虑DP:

设$\large dp_{i, j, k}$表示在以$i$为根节点的子树中有$j$个果子归大头吃，$k=0$表示点$i$不归大头吃，$k=1$表示点$i$归大头吃。

然后就产生了一个类似于树上背包的DP， 注意特殊处理$M = 2$的情况。

转移时只需注意分类讨论：

> 两个都不归大头吃，只有m=2时算入难受；

> 只有子节点归大头吃，不算入难受值；

> 只有根节点归大头吃， 不算入难受值；

> 都归大头吃， 算入难受值。

转移方程：


$$dp[x][j + l][0] = \min_{j\le tot, l\le size_y}(dp[y][l][1] + dp[x][j][0], dp[y][l][0] + dp[x][j][0] + [m=2] \times e[i].dat );$$


$$dp[x][j + l + 1][1] = \min_{j\le tot, l\le size_y}(dp[y][l][1] + dp[x][j + 1][1] + e[i].dat, dp[y][l][0] + dp[x][j + 1][1]);$$

转移会产生覆盖，需要另开一个数组来记录答案。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n, m, k;
struct node{
	int to, dat, nxt;
}e[610];
int h[1010], cnt;
void add(int x, int y, int z){
	e[++cnt].to = y;
	e[cnt].dat = z;
	e[cnt].nxt = h[x];
	h[x] = cnt;
}
int dp[310][310][2];
int f[310], size[310];
void dfs(int x, int fa){
	f[x] = fa;
	size[x] = 1;
	for(int i = h[x]; i; i = e[i].nxt){
		int y = e[i].to;
		if(y != fa)
			dfs(y, x), size[x] += size[y];
	}
}
int pp[310][2];
void dfss(int x, int fa){
	int tot = 0;//注意tot不包括x本身
	dp[x][0][0] = 0;//初始化
	dp[x][1][1] = 0;
	for(int i = h[x]; i; i = e[i].nxt){
		int y = e[i].to;
		if(y == fa)
			continue;
		dfss(y, x);
		memset(pp, 0x3f, sizeof(pp));//用于转移记录答案， 防止覆盖。
		for(int j = min(tot, k); j >= 0; j--){
			for(int l = min(size[y], k - j); l >= 0; l--){
				if(j + l > k)
					continue;pp[j + l + 1][1] = min(pp[j + l + 1][1], dp[y][l][0] + dp[x][j + 1][1]);
					if(l >= 1)
						pp[j + l + 1][1] = min(pp[j + l + 1][1], dp[y][l][1] + dp[x][j + 1][1] + e[i].dat);
           //以下为核心转移---------------------------
				pp[j + l][0] = min(pp[j + l][0], dp[y][l][0] + dp[x][j][0] + (m == 2 ? e[i].dat : 0));//两个都不归大头吃，只有m=2时算入难受值
				pp[j + l][0] = min(pp[j + l][0], dp[y][l][1] + dp[x][j][0]);//只有子节点归大头吃，不算入难受值。
				if(j + l <= min(tot + size[y], k)){
					pp[j + l + 1][1] = min(pp[j + l + 1][1], dp[y][l][0] + dp[x][j + 1][1]);//只有根节点归大头吃， 不算入难受值
					if(l >= 1)
						pp[j + l + 1][1] = min(pp[j + l + 1][1], dp[y][l][1] + dp[x][j + 1][1] + e[i].dat);//都归大头吃， 算入难受值
           //以上为核心转移---------------------------
				}
			}
		}
		tot += size[y];//扩大子树大小
		for(int qsqsq = 0; qsqsq <= tot + 1; qsqsq++){//重新赋值
			dp[x][qsqsq][0] = pp[qsqsq][0];
			dp[x][qsqsq][1] = pp[qsqsq][1];
		}
	}
}
signed main(){
	memset(dp, 0x3f, sizeof(dp));
	scanf("%d%d%d", &n, &m, &k);
	if(n - k < m - 1){
		puts("-1");
		return 0;
	}
	for(int i = 1; i < n; i++){
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		add(x, y, z);
		add(y, x, z);
	}
	dfs(1, 0);
	dfss(1, 0);
	else
		cout <<dp[1][k][1] <<"\n";
	
}
```

能跑到[32ms](https://www.luogu.com.cn/record/44876601)，~~但为什么我的代码这么长啊~~。

---

## 作者：MD_17L (赞：2)

## 树形DP
- f[x][y][p]表示以x为根的子树大头吃y个果子,p为x的父节点
- f[x][y][p]=min(min(f[t[x].l][i][0],f[t[x].l][i-1][1])+f[t[x].r][y-i][p]);
- 当p为0时,x的父节点被小头吃,当p为1时,x的父节点被大头吃
- 判断无解情况,当m+k-1>n时,无法满足要求
 
 最后,附上代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=1000000000;
 struct ss
{
	int l,r,s,w;
}t[305];
int n,m,k,u[305],v[305],w[305],c[2],f[305][305][2];

 void build(int x)//多叉树转二叉树
{
	int y;
	t[x].s=1;
	for (int i=1; i<n; i++)
	{
		if (u[i]!=x&&v[i]!=x) continue;
		if (u[i]==x) y=v[i];
		else y=u[i];
		if (t[x].l==0) t[x].l=y;
		else//右子树
		{
			int r=t[x].l;
			while (t[r].r>0) r=t[r].r;
			t[r].r=y;
		} 
		t[y].w=w[i]; u[i]=v[i]=0;
		build(y); t[x].s+=t[y].s; 
	}
}
 void init()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1; i<n; i++) scanf("%d%d%d",&u[i],&v[i],&w[i]);
	build(1);
	c[1]=1;//c[0],c[1]小头,大头是否吃树枝
	if (m==2) c[0]=1;
	else c[0]=0;
} 
 int js(int x,int y,int p)
{
	if (x==0||y<0) 
		if (x==0&&y==0) return 0;
		else return N;
	if (f[x][y][p]>-1) return f[x][y][p];
	f[x][y][p]=N;
	int a,b,left,num,res;
	num=min(t[x].s,y); left=t[x].l;
	for (int i=0; i<=num; i++)
	{
		a=js(left,i,0);//x小头吃
		b=js(left,i-1,1);//x结点如果大头吃,子节点的大头只需i-1个既可
		if (p==0) a+=c[p]*t[x].w;
		else b+=c[p]*t[x].w;
		res=min(a,b)+js(t[x].r,y-i,p);
		if (res<f[x][y][p]) f[x][y][p]=res;
	}
	return f[x][y][p];
}
 void destroy()
{
	int ans;
	memset(f,-1,sizeof(f));
	if (m+k-1>n) ans=-1;
	else ans=js(t[1].l,k-1,1);
	printf("%d\n",ans);
}

 int main()
{
	init(); destroy(); 
	return 0;
}
```



---

## 作者：Illusory_dimes (赞：1)

# 大致题意
有一个带权值的“无向树”~~说是图不太对~~。

（因为没有实际上的父与子，两个点都可以互相到达彼此）。

然后在 N 个点上染出 M 类颜色。

再然后它要满足每种颜色至少有一个点。

再再然后它要满足必须有 K 个点是一种颜色（要包括开始的点）。

最后若两个连通的点颜色一样，就要付出其边权的代价。

最最后，题目要求给出满足以上条件的最小代价。

~~好啰嗦呀，但我只有这个水平，谁叫我语文没上过105呢~~。

（~~啊啊啊啊我太难了~~）。

# 解题过程
## 简要分析
题目中的图（~~实际上是树~~）提示了我们要写跟树有关的代码。

这时，我们可以简单地就着样例算一下，发现可能性忒多，直接硬算不现实，而且时间多半承受不住（~~虽然我没想过~~）。

于是我们考虑（~~与树有关的~~）树形 DP 。

## 特殊情况
N 个果子，一种头占 k 个果子，剩 n-k 个果子， m-1 个头。

如果剩下的果子不够分剩下的头，就输出 -1 ，然后散花。

## 设DP
其实，设 DP 是个很~~有趣~~麻烦的过程（~~尤其是树形 DP~~）。

一般来说，树形 DP 总有一维跟以某个点为根下的子树有关系，那我们就有一个 $ dp[k] $ 表示以 k 为根下的子树。

当然，一维肯定不够，因为这道题跟谁吃有极大关系，于是我们有了第二维—— $ dp[j] $ 表示包括 j 个开始的颜色。

但是，两个点的颜色就搞不清了，我就没思路了，就缓缓打开题解，看到[这位大佬](https://www.luogu.com.cn/user/47901)的题解，我仿佛懂辽，就继续思考辽。

我们用 0/1 表示 k 点**否是**为开始的颜色（~~我说的应该对叭，说**是否**就反了~~）。

于是，最后我们得到 $ dp[k][j][0/1] $ 表示以k为根下的子树包括j个开始的颜色然后k点否是为开始的颜色的最小代价。

## 推状态转移方程
设有 l 表示 k 点下包括 l 个开始的颜色，所以 $ 0\leq l\leq j $ 。

所以很自然的想到了——

$ dp[k][j][0/1]=dp[to[i]][l][0/1]+dp[k][j-l][0/1] $

**bu特**

颜色一样要加边权。

于是，改动后有——

$ dp[k][j][1]=\min(dp[to[i]][l][0]+dp[k][j-l][1],dp[to[i]][l][1]+dp[k][j-l][1]+val[i]) $

**bu特特**

若 k 点和 $ to[i] $ 点都不染，不知道颜色一不一样（但其它颜色一定不会重复，因为可以换颜色），但只有两个头时，我们可以直接确定，于是又有——

$ dp[k][j][0]=\min(dp[to[i]][l][0]+dp[k][j-l][0]+val[i]*(m==2),dp[to[i]][l][1]+dp[k][j-l][0]) $

**方程就推完了，**
### 可是你以为就这么完了吗？
当我们观察了两下，发现在更新当前值时，会用到前面的值，然而它们已经被更新了。于是，我们更新值前，先保存着（新式子就不写了，其实差不多）。

但我这么写，它给我输出了忒大一个数，于是我把 $ dp[k][j-l][0/1] $ 提出来（因为每个式子每一个都有），然后，就 A 了。

（至于为什么，我也是一脸懵，~~不过不要管这些小细节啦~~！）

## 实现
因为是“无向树”，我们采用我们敲有用~~但快用烦~~的 DFS 。

~~应该蛮好打的吧。~~

于是，我们就交流电（ **A**lternating **C**urrent ）辽。

最后，给出我码风清奇的代码。

```cpp
#include<bits/stdc++.h>
#define N 306
#define M 606
using namespace std;
typedef long long ll;
ll n,m,num,a,b,c,fst[N],t;
ll dp[N][N][2],f[N][2];
ll nxt[M],to[M],val[M];
void add(ll x,ll y,ll w)
{
    nxt[++t]=fst[x];
    to[t]=y;val[t]=w;
    fst[x]=t;
}
void ljzz2(ll k,ll fth)
{
    dp[k][0][0]=dp[k][1][1]=0;
    for(ll i=fst[k];i;i=nxt[i])
    {
        if(to[i]==fth)continue;
        ljzz2(to[i],k);
        memcpy(f,dp[k],sizeof(f));
        memset(dp[k],0x3f,sizeof(dp[k]));
        for(ll j=0;j<=num;j++)
        for(ll l=0;l<=j;l++)
        {
            dp[k][j][0]=min(dp[k][j][0],min(dp[to[i]][l][0]+val[i],dp[to[i]][l][1])+f[j-l][0]);
            dp[k][j][1]=min(dp[k][j][1],min(dp[to[i]][l][1]+val[i],dp[to[i]][l][0])+f[j-l][1]);
        }
    }
}
void ljzz(ll k,ll fth)
{
    dp[k][0][0]=dp[k][1][1]=0;
    for(ll i=fst[k];i;i=nxt[i])
    {
        if(to[i]==fth)continue;
        ljzz(to[i],k);
        memcpy(f,dp[k],sizeof(f));
        memset(dp[k],0x3f,sizeof(dp[k]));
        for(ll j=0;j<=num;j++)
        for(ll l=0;l<=j;l++)
        {
            dp[k][j][0]=min(dp[k][j][0],min(dp[to[i]][l][0],dp[to[i]][l][1])+f[j-l][0]);
            dp[k][j][1]=min(dp[k][j][1],min(dp[to[i]][l][1]+val[i],dp[to[i]][l][0])+f[j-l][1]);
        }
    }
}
int main()
{
    scanf("%lld%lld%lld",&n,&m,&num);
    for(ll i=1;i<n;i++)
    {
        scanf("%lld%lld%lld",&a,&b,&c);
        add(a,b,c),add(b,a,c);
    }
    if(m-1>n-num){printf("-1");return 0;}
    memset(dp,0x3f,sizeof(dp));
    if(m==2)ljzz2(1,1);
    else ljzz(1,1);
    printf("%lld",dp[1][num][1]);
    return 0;
}
```
莫辽 $ \cdots $ 

---

## 作者：盧鋅 (赞：0)

$DP$都是考虑状态的设计和转移。

考虑怎么设计状态：

- 首先他是一个树形背包的模型，所以我们对于每个点需要记录一个大小为节点数的数组，表示选了多少个果子。

- 然后因为边会产生贡献（也因为最后的答案需要记录），所以我们需要转移的时候需要判断边的两个端点，所以再开一个维度0/1表示，当前节点是大头还是小头就好了。

总结一下，我们开$f[N][2]$的数组,$f[k][0/1]$表示以**当前节点**为根的子树中选了$k$个果子，当前节点不是/是大头吃的最小代价。

考虑怎么转移：（假如没办法转移我们考虑继续增加状态）。
- 假如当前节点是大头吃
	- 假如当前节点和儿子节点都是大头吃，那么需要多付出边的代价
	- 假如当前节点是大头吃，儿子节点是小头吃，不需付出边的代价
- 假如当前节点是小头吃
	- 假如当前节点和儿子节点都是小头吃，那么则需要讨论一下代价
    - 假如当前节点是小头吃，儿子节点是大头吃，不需付出边的代价

关于代价的讨论：
- 假如小头大于1个，我们可以钦定某一层由哪几个小头吃，这样层与层之间的连边就不会有代价，
- 假如小头只有1个，那么相邻的两层就是同一个小头吃了，所以会产生边的代价。

现在状态和转移都考虑了，然后就是边界的问题：
- 初始化：我们因为求的是最小代价，所以设置初始为极大值表示不存在这个状态就好了。
- 边界条件：
	- 假如我们让大头吃了这个点，则有$f[1][1]=0$
	- 假如我们不让大头吃这个点，则有$f[0][0]=0$
- 还有讨论一下，节点够不够大头吃k个，每个小头最小一个，特判一下。
    
下面是AC的code了：

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int node_size = 3.3e2;
struct edge { int v,n; } e[node_size<<1];
int n,m,k,head[node_size],E[node_size][node_size],cnt;
void add(int u,int v,int w) { E[u][v]=w,e[++cnt]={v,head[u]},head[u]=cnt; }
struct node
{
    int f[node_size][2],siz,id;
    int *operator[](int k) { return f[k]; }
    node() { memset(f,0x3f,sizeof(f)),siz=1;}
    void init(int _id) { f[0][0]=f[1][1]=0,id=_id ;}
};
node operator +(node a,node b)
{
    node res; res.siz=a.siz+b.siz; res.id=a.id;
    for(int i=0;i<=a.siz;++i) for(int j=0;j<=b.siz;++j)
    {
        res[i+j][0]=min(res[i+j][0],a[i][0]+b[j][0]+(m==2)*E[a.id][b.id]);
        res[i+j][0]=min(res[i+j][0],a[i][0]+b[j][1]);
        res[i+j][1]=min(res[i+j][1],a[i][1]+b[j][0]);
        res[i+j][1]=min(res[i+j][1],a[i][1]+b[j][1]+E[a.id][b.id]);
    }
    return res;
}
#define trav(u) for(int i=head[u],v;(v=e[i].v),i;i=e[i].n)
node dfs(int u,int fa)
{
    node res;  res.init(u);
    trav(u) if(v!=fa) res=res+dfs(v,u);
    return res;
}
signed main()
{
    scanf("%d %d %d",&n,&m,&k);
    if(n-k<m-1) return puts("-1"),0;
    for(int i=1,x,y,z;i<n;++i)
        scanf("%d %d %d",&x,&y,&z),
        add(x,y,z),add(y,x,z);
    return printf("%d\n",dfs(1,0)[k][1]),0;
}
~~~

~~结构体写这种是真的好玩，而且也不是太慢，至少现在开了O2，他是最优解（胜之不武）~~

---


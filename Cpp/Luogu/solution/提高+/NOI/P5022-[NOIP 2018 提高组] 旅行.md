# [NOIP 2018 提高组] 旅行

## 题目背景

NOIP2018 提高组 D2T1

## 题目描述

小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。 
  
小 Y 了解到，X 国的 $n$ 个城市之间有 $m$ 条双向道路。每条双向道路连接两个城市。不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且，从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些道路从一个城市前往另一个城市。

小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。

为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将它的编号记录下来。她知道这样会形成一个长度为 $n$ 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？对于两个长度均为 $n$ 的序列 $A$ 和 $B$，当且仅当存在一个正整数 $x$，满足以下条件时，我们说序列 $A$ 的字典序小于 $B$。

- 对于任意正整数 $1 \le i < x$，序列 $A$ 的第 $i$ 个元素 $A_i$ 和序列 $B$ 的第 $i$ 个元素 $B_i$ 相同。
- 序列 $A$ 的第 $x$ 个元素的值小于序列 $B$ 的第 $x$ 个元素的值。

## 说明/提示

【数据规模与约定】   

对于 $100\%$ 的数据和所有样例， $1 \le n \le 5000 $ 且 $m = n - 1$ 或 $m = n$ 。

对于不同的测试点，我们约定数据的规模如下：

![](https://cdn.luogu.com.cn/upload/pic/43271.png)

## 样例 #1

### 输入

```
6 5 
1 3 
2 3 
2 5 
3 4 
4 6```

### 输出

```
1 3 2 5 4 6```

## 样例 #2

### 输入

```
6 6 
1 3 
2 3 
2 5 
3 4 
4 5 
4 6```

### 输出

```
1 3 2 4 5 6```

# 题解

## 作者：fysbb (赞：88)

这里来说明一个时间复杂度为 $O(n \log n)$ 的算法，这个算法还能通过此题的加强版！~~双倍经验~~

------------
显然 DFS 路径 $O(n)$ 的复杂度是无法优化的，所以具体要提高效率就得从断边入手。将原来的暴力，改为通过一次搜索来确定应该断的是哪条边。

如何找环，搜索路径，这里就不在赘述，我们具体分析如何断边：

比如这样的图

![](https://cdn.luogu.com.cn/upload/pic/45609.png)

## 处理方法：

### 1.先找到环和环的入点（红色，橙色部分）

![](https://cdn.luogu.com.cn/upload/pic/45610.png )

### 2.对环上的每个点预处理，找出其最大的子节点，**入点不用处理**（蓝色部分）

![](https://cdn.luogu.com.cn/upload/pic/45611.png)

### 3.遍历整个环进行断边

设 $tmax[i]$ 为 $i$ **节点**的最大**子节点**， $next[i]$ 为 $i$ 的后一个**节点**， $cut[i]$ 为 $i$ 的前一个有**子节点**的**节点**，该**节点**比 $i$ 大的**子节点**中最小的那一个**子节点**（此处所说的**节点**都为环上的节点，**子节点**都不是环上的节点）

#### first. 首先判断**入点**的两个叶节点，选择较小的进入环

![](https://cdn.luogu.com.cn/upload/pic/45614.png )

#### second. 若 $next[i] < tmax[i]$ ,则可以扩展到后一个节点

![](  https://cdn.luogu.com.cn/upload/pic/45618.png)

#### third. 若 $next[i] > tmax[i]$ 但是 $next[i] < cut[i]$ ,也可以扩展到后一个节点。

![](https://cdn.luogu.com.cn/upload/pic/45620.png )

#### fourth. 若同时不满足second和third的条件，或 $next[i]$ 为入点，则不能继续扩展，并断开 $i$ 和 $next[i]$ 之间的边

![](https://cdn.luogu.com.cn/upload/pic/45621.png )

### 4. DFS搜索路径

![](  https://cdn.luogu.com.cn/upload/pic/45622.png)

只要在断边后的图（一棵树）中用DFS搜索路径即可

### 5.时间复杂度

给边排序 $O(n \log n)$

找环 $O(n)$

断边 $O(n)$

搜索路径 $O(n)$

所以**总时间复杂度接近 $O(n \log n)$** ，可以通过此体。

### 6.程序（pascal）

```pas
program project1;
var
   r,path,father,son,tmax:array[0..500005]of longint;
   ttf:array[0..500005]of boolean;
   l,v,x,y:array[0..1000005]of longint;
   n,m,p,k,fat,nox,noy:longint;

function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;

function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;

procedure sc(f,fa:longint);
var i:longint;
begin
  i:=r[f];
  while i<>0 do begin
    if (v[i]<>fa) and not((f=nox) and (v[i]=noy)) and not((f=noy) and (v[i]=nox)) then begin
      inc(k);
      path[k]:=v[i];
      sc(v[i],f);
    end;
    i:=l[i];
  end;
end;

function sc2(f,fa:longint):boolean;
var i:longint;
begin
  sc2:=false;
  i:=r[f];
  while i<>0 do begin
    if v[i]<>fa then begin
      if father[v[i]]=0 then father[v[i]]:=f
        else begin
          p:=v[i];
          fat:=father[v[i]];
          father[v[i]]:=f;
          son[f]:=v[i];
          exit(true);
        end;
      if sc2(v[i],f)=true then begin
        son[f]:=v[i];
        ttf[v[i]]:=true;
        exit(true)
      end;
    end;
    i:=l[i];
  end;
end;

procedure sc3;
var i,j:longint;
begin
  i:=p;
  while father[i]<>p do begin
    i:=father[i];
    j:=r[i];
    while j<>0 do begin
      if (v[j]<>son[i]) and (v[j]<>father[i]) then tmax[i]:=max(tmax[i],v[j]);
      j:=l[j];
    end;
  end;
end;

function mmax(k,p,o:longint):longint;
var i:longint;
begin
  mmax:=10000000;
  i:=r[p];
  while i<>0 do begin
    if (v[i]<>o) and (v[i]>k) then mmax:=min(mmax,v[i]);
    i:=l[i];
  end;
end;

function cut:longint;
var i,x,y,q,s:longint;
begin
  cut:=0;
  if father[p]<son[p] then begin
    i:=father[p];
    cut:=mmax(i,p,fat);
    while ((father[i]<tmax[i]) or ((father[i]>tmax[i]) and (father[i]<cut))) and (father[i]<>p) do begin
      i:=father[i];
      s:=mmax(i,son[i],son[son[i]]);
      if s<>10000000 then cut:=s;
    end;
    nox:=i;
    noy:=father[i];
  end else begin
    i:=son[p];
    cut:=mmax(i,p,fat);
    while ((son[i]<tmax[i]) or ((son[i]>tmax[i]) and (son[i]<cut))) and (son[i]<>p) do begin
      i:=son[i];
      s:=mmax(i,father[i],father[father[i]]);
      if s<>10000000 then cut:=s;
    end;
    nox:=i;
    noy:=son[i];
  end;
end;

procedure qsort(l,r:longint);
var i,j,mid,t:longint;
begin
  i:=l;
  j:=r;
  mid:=y[(i+j) div 2];
  repeat
    while y[i]>mid do inc(i);
    while y[j]<mid do dec(j);
    if i<=j then begin
      t:=y[i];
      y[i]:=y[j];
      y[j]:=t;
      t:=x[i];
      x[i]:=x[j];
      x[j]:=t;
      inc(i);
      dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;

procedure re;
var i,t,xx,yy:longint;
begin
  for i:=1 to m do begin
    read(xx,yy);
    t:=2*i;
    x[t]:=xx;
    y[t]:=yy;
    x[t-1]:=yy;
    y[t-1]:=xx;
  end;
  qsort(1,2*m);
  for i:=1 to 2*m do begin
    l[i]:=r[x[i]];
    r[x[i]]:=i;
    v[i]:=y[i];
  end;
end;

procedure main;
var i:longint;
begin
  k:=0;
  inc(k);
  path[k]:=1;
  father[1]:=1;
  if m=n then begin
    sc2(1,0);
    sc3;
    cut;
  end;
  sc(1,0);
  for i:=1 to k do write(path[i],' ');  writeln;
end;

begin
  fillchar(r,sizeof(r),0);
  fillchar(l,sizeof(l),0);
  read(n,m);
  re;
  main;
end.
```

---

## 作者：Orzalpha (赞：47)

$Upd$ $2019/11/17$:

很抱歉之前的代码有锅，缺少一个判断条件会导致如果一口气走完整个环的话还会再从另一边进入环中，已经修复，现在本题解把N改为$500001$后可以通过数据加强版。

感谢@FuzeTheHostage 大佬提供的Hack数据，以及同样发现问题的@拟泪咸阳 大佬。

------------

本题的基本思路是$dfs$+堆。

起点是$1$，这个信息可以一眼看出来，否则一定不是字典序最小的。

### 对于$m=n-1$的情况：

显然这是一个树形的结构。由于每次只能是前进到一个没有去过的城市，或者往回倒，说明你不能再一个链的中间的时候往回倒，只能选定一个链一直走到头，然后倒车回去。

由于要求字典序最小，每当我们处在一个岔路的时候，我们可以存下这个点所有的出边，然后用一个小根堆堆存下需要去的点，然后我们每次取堆顶的点进行遍历，一边遍历一遍输出序列就可以了，拿到$60$分。

### 对于$m=n$的情况：

显然这是一个基环树形的情况，这意味着当你处在环的内部的时候，你是可以掉头返回的，剩下的点可以从环的另一个方向遍历到。
在这种情况下，不在环上的点依然是树形的结构，遍历的方法和上面基本一致。但是对于在环上的点，我们还需要确定到底是在哪个位置掉头。

由于是字典序最小，那么很明显可以不做$dp$（反正我懒得拆环做$dp$），因为我们要求的只是即将到达的下一个新城市的编号越小越好，而不用去管别的，显然就是贪心嘛。

但是需要注意，如果一棵基环树的某个环上的点，它的还连接着一棵树，那么这棵树也是必须要遍历的，不能掉头不去管。

#### 如果遍历这棵树比沿着环走更优的话，那么必须先走一遍这棵树。

打个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/cuoqjn0r.png)

从$1$出发后沿着环走到$2$ $3$。

在$3$的位置接上了一棵树。

这个时候，发现先走树更优，于是先走一遍树：$4$ $11$ $13$ $14$ $15$ $12$ $16$ $17$。

#### 当然，$1$不一定总是在环上，我们需要找到一个从$1$开始遍历时进入环的突破口$st$。

打个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/q6ymbbh0.png)

找环的时候遍历顺序不要紧。

从$1$开始$dfs$，依次找到：$2$ $3$ $5$ $8$ $7$ $6$ $4$。

发现从$4$能够找到之前找过的$2$并且$2$不是$4$的直接父亲，那么$2$就是进入环的突破口。

直接打标记一层层返回，把环上的点都标记一下。

这样就可以处理出$st$和环上的点来。

如果我们在遍历的过程中到达了$st$，那么这就进环了。

进入环中之后就需要时刻考虑能不能掉头的问题了，那么能否掉头的关键在于什么呢？

#### 如果这个基环树是个秃环，问题就变得很简单。

打个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/tj7c1x8p.png)

从$1$开始，走到$2$ $3$。

然后发现如果从$3$走到$5$，不如掉头去走4来的更好。

那就掉头，走$4$ $7$ $6$ $5$。

对于秃环的情况，我们可以直接记录st上连接的两个环点，较小的那一个直接拿来遍历，较大的那一个记录为$another$。

如果在遍历的过程中发现前方的点比$another$要大，掉头回到$st$，然后沿着环的另一侧继续走。

这个时候需要注意，如果我们在环上已经掉过一次头了，那么剩下的就不能在随便掉头了，相当于又变成了一棵树。

#### 在这里，$another$给了我们一个启发：对于并非秃环的基环树，如果我们记录下在环上的这个点如果回头，下一步是什么东西的话，就可以判断了。如果这个环点所需要经过的下一个环点比如果回头需要经过的点要大，那么回头就可以了。

那么如何判断如果回头下一步是什么点呢？

打个例子：
![](https://cdn.luogu.com.cn/upload/image_hosting/bguv6xdt.png)

我们把环上的点叫做环点，定义$another[x]$表示如果在环点x除掉头下一个到达的之前没有到达过的点。

对于一个环点（除$st$外，因为$st$不能回头），它回头之后是回到前一个环点，那么前一个环点该怎么走，它回头之后就怎么走。

第一类比如$5$，如果从这里掉头，是回到$3$，回到$3$之后会接着遍历$6$所在的树，所以$anothe[5]=6$，实际上就是$5$的下一个兄弟。

第一类比如$3$，掉头之后回到$2$，而到$2$之后还是掉头往回走，所以有$another[3]=another[2]$，对于没有兄弟的环点，它的$another$就是它的父亲的$another$。特别地，$17$虽然有兄弟节点，但是$17$的兄弟早在经过$17$之前就被遍历过了，$17$是没有比它大的兄弟的，所以也按照没有兄弟处理。

#### 这样，每当我们从一个环点x要到下一个环点$p$去的时候，先判断$p$和$another[p]$的大小关系：如果$p$比$another[p]$要小，那么继续沿着$p$走，否则就跳过$p$，相当于删除$x$和$p$之间的边，掉头回去。$another$数组就是我们判断拆环位置的关键。

有了$another$数组之后，我们第一次进入环的时候，就要对路径上的每个点记录$another$，一旦发现下一个环点比$another$大就及时拆掉这条边然后回头就可以了。

代码贴在下面：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define N 500001
using namespace std;
int n,m,fir[N],tot;
bool v[N],u[N];
struct edge{int nxt,pnt;}e[N*2];
void ins(int a,int b)
{tot++;e[tot].nxt=fir[a];e[tot].pnt=b;fir[a]=tot;}
void dfs_tree(int x)        //如果是树就直接dfs嘛，60分先拿到手
{
	printf("%d ",x);v[x]=1;
	priority_queue<int,vector<int>,greater<int> > q;        //小根堆存要跑的点
	for(int i=fir[x];i;i=e[i].nxt)
	{
		int p=e[i].pnt;
		if(v[p]) continue;
		q.push(p);
	}
	while(!q.empty())       //从小到大拿出来
	{
		dfs_tree(q.top());
		q.pop();
	}
	return;
}
int st;
bool flag,tag;      //flag表示是否已经找到了环，tag表示当前的点是否为环点
void search_circle(int x,int pre)       //找环
{
	v[x]=1;
	for(int i=fir[x];i;i=e[i].nxt)
	{
		int p=e[i].pnt;
		if(p==pre) continue;
		if(!v[p]) {
			search_circle(p,x);
			if(flag) {
				u[x]=tag;
				if(x==st) tag=0;
				return;
			}
		}
		else {u[x]=1;flag=tag=1;st=p;return;}
	}
	return;
}
int another[N];     //玄学掉头another数组
void dfs_circle_tree(int x)     //在基环树上奇技淫巧dfs
{
	printf("%d ",x);v[x]=1;
	priority_queue<int,vector<int>,greater<int> > q;
	for(int i=fir[x];i;i=e[i].nxt)
	{
		int p=e[i].pnt;
		if(v[p]) continue;
		q.push(p);
	}
	if(!u[x]||(x!=st&&u[x]&&flag==0))       //如果是非环点或者是已经拆过环了并且还不能是st
	{
		while(!q.empty())
		{
			dfs_circle_tree(q.top());
			q.pop();
		}
		return;
	}
	else
	{
		if(x==st)       //由此进入环中
		{
			while(!q.empty())
			{
				int p=q.top();
				q.pop();
				if(!u[p]) dfs_circle_tree(p);
				if(u[p]&&flag==0)
				{
					another[p]=q.top();
					flag=1;
					dfs_circle_tree(p);
					continue;
				}
				if(u[p]&&flag==1)       //如果进入环中后再一次回到st，并且开始跑另一个环点的时候，说明之前已经掉过头了，这个时候就可以取消标记然后当成树来对待。
				{flag=0;if(!v[p]) dfs_circle_tree(p);}
			}
			return;
		}
		if(flag==1)         //如果是第1遍跑环，这个时候是可以回头的
		{
			while(!q.empty())
			{
				int p=q.top();
				q.pop();
				if(!u[p]) dfs_circle_tree(p);
				else {
					if(!q.empty()) another[p]=q.top();
					else another[p]=another[x];
					if(p<another[p]) dfs_circle_tree(p);
					else continue;      //跳过环点，玄学掉头
				}
			}
			return;
		}
	}
}
int main()
{
	int a,b;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		ins(a,b);ins(b,a);
	}
	if(m==n-1) {dfs_tree(1);return 0;}
	if(m==n)
	{
		search_circle(1,0);
		memset(v,0,sizeof(v));
		flag=0;
		dfs_circle_tree(1);
	}
	return 0;
}
/*    想变强，先压行！    ——制杖	  */
```


---

## 作者：YHASDY (赞：30)

　　发现大部分题解都是O(n^2)的复杂度，这里分享一个O(n)复杂度的方法。
  
  （更好的阅读体验，请前往洛谷博客或[我的另一个博客](https://www.cnblogs.com/InductiveSorting-QYF/p/11740479.html)）
　　
 
 首先前60%的情况，图是一棵无根树，只要从1开始DFS，每次贪心走点的编号最小的点就行了。（为什么？因为当走到一个点u时，若不把以它为根的子树的所有点都遍历一遍的话，回溯到u的父亲后，就再也没可能遍历u的没有遍历过的儿子了。）

再看剩下40%的情况，由于题目保证图是一个无向连通图，当 边数 等于 点数减一 时图必为树，在此基础上再多加一条边，就在一棵树的基础上形成一个环（为了方便，后文仍会提到树，而后文的树指的是图没有第n条边时形成的树）。有了环会发生什么？发现有了环后第一种情况的贪心+DFS解法的依据就不成立了，即走到一个点u时，即使不把以它为根的子树的所有点都遍历一遍，当回溯到u的父亲后，也有可能会通过环的一部分到达u节点剩下的没有遍历过的儿子。显然不能再无脑贪心了。　　

　　仔细思考一下两种情况的不同，发现若一棵子树中没有环，也没有点能直接连向环，那这棵子树就可以用第一种情况的贪心+DFS的方法处理。若一个点u及它的儿子v都在环上，那么若要u走到v，既可以直接走u到v的连边(u,v)，也可以从u开始反方向绕环一圈走到v；若u和v至少有一个点不在环上，那么从u到v只能通过边(u,v)，即只有一个到达方法。这就说明，若一对父子都在环上，那他们之间有两种到达方法；否则就只有一种到达方法。

　　这时两种情况的不同就明确了：同样的是：对于一个与环没有什么关系的子树（没有关系指不与环的任何一个边相交。若与环共用最多一个点，也没事。），用贪心+DFS做就好，因为当父亲回溯后未被遍历的儿子就不能再被遍历到了；不同的是，第二种情况多了父子都在环上的情况，这时父亲回溯一次后，儿子仍能被遍历。但因为“小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。”，所以每个父亲最多也只能回溯一次。

　　所以我们只要搞清楚第一次环上的回溯何时发生就行了，只要发生了一次环上的回溯，第二种情况就可以当第一种情况做了（一旦环上的某个点u回溯了，那么它的儿子与它的连边就不会再用了，也相当于没有这条边，此时图只有n-1条边，就是棵树）。“环上的回溯”显然只会发生在环上（毕竟名字都说是“环上的”了）,这其实就相当于在第一次环上的回溯发生前，环上的点可以“主动”发起回溯，即就算它的儿子还没有都被遍历完，它也可以回溯，不过那个没有被遍历的儿子只能是环上的点。

　　思考为什么要主动回溯。我们各种乱搞，不就是为了最后的字典序最小吗？而为了达成这个目标，我们只要保证能遍历到所有点的同时，时刻最小化当前的字典序，即每次都遍历可行的编号最小的点。于是我们可以记录一下主动回溯后可以得到的最小字典序就行啦。先跑一边tarjan找到环。从第一次进入环开始就记录主动回溯后可以得到的最小字典序（sec变量），若当前点u在环上，且只剩一个同在环上的儿子了，并且儿子的编号还大于sec，那就主动回溯；不然就正常dfs就行。

具体实现看注释过的代码吧：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>

#define min(a,b) ((a)>(b)?(b):(a))

using namespace std;

const int N=5005;

int n,m,x,vis[N],lst[N],xu[N],cntxu,nxt[N<<1],to[N<<1],cnt;
int dfn[N],dfss,low[N],huan[N],sta[N],top;

char ch;

inline int read()
{
	x=0;
	ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++dfss;
	sta[++top]=u;
	int Top=top;
	vis[u]=1;
	int t;
	for(int e=lst[u];e;e=nxt[e])
	{
		if(!dfn[t=to[e]])
		{
			tarjan(t,u);
			low[u]=min(low[t],low[u]);
		}
		else
		{
			if(t!=fa&&vis[t])
				low[u]=min(low[t],low[u]);
		}
	}
	if(dfn[u]==low[u])
	{
		if(Top==top)
			vis[sta[top--]]=0;
		for(int i=Top;i<=top;++i)
		{
			huan[sta[i]]=1;//是环 
			vis[sta[i]]=0;
		}
		top=Top-1;
	}
}

int fir;//有没有进过环 
int sec=-1;//-1标记意义为还没有进入过环 

void dfs(int u)
{
	if(vis[u]) return;
	priority_queue<int,vector<int>,greater<int> >hep;//用堆维护当前要dfs的最小值。由于每个节点的儿子都很少，所以时间复杂度为几乎可以忽略的常数 
	xu[++cntxu]=u;//记录答案序列 
	vis[u]=1;
	for(int e=lst[u];e;e=nxt[e])
		if(!vis[to[e]])
			hep.push(to[e]);
	int head;
	if(huan[u]&&!fir)
	{
		fir=1;
		while(!hep.empty())
		{
			head=hep.top();
			hep.pop();
			if(!huan[head]) dfs(head);//不在环上的点正常贪心DFS。 
			else
			{
				if(!vis[head]&&sec==-1)
				{
					sec=hep.top();
					dfs(head);
				}
				else//第一次环上回溯发生后，都正常贪心DFS 
				dfs(head);
			}
		}
	}
	else
	{
		if(!huan[u]||(huan[u]&&sec==-2))
		{
			while(!hep.empty())
			{
				if(!vis[hep.top()])
					dfs(hep.top());
				hep.pop();
			}
		}
		else
		{
			while(!hep.empty())
			{
				head=hep.top();
				hep.pop();
				if(!huan[head])
					dfs(head);
				else
				{
					if(head<=sec)
					{
						if(!hep.empty())
							sec=hep.top();
						dfs(head);
					}
					else
					{
						if(hep.empty())
						{
							sec=-2;//主动回溯，并把sec设成-2标记第一次环上的回溯已经结束了 
							return;
						}
						else//在环上的点，要没有 不在环上的儿子 时才能考虑主动回溯
						{
							sec=hep.top();
							dfs(head);
							while(!hep.empty())
							{
								dfs(hep.top());
								hep.pop();
							}
						}
						
					}
				}
			}
		}
	}
}

inline void addedge(int u,int v)
{
	nxt[++cnt]=lst[u];
	lst[u]=cnt;
	to[cnt]=v;
}

int main()
{
	n=read(),m=read();
	int u,v;
	for(int i=1;i<=m;++i)
	{
		u=read(),v=read();
		addedge(u,v);
		addedge(v,u);
	}
	tarjan(1,0);
	dfs(1);
	for(int i=1;i<=n;++i)
		printf("%d ",xu[i]);
	return 0;
}
```
（讲了这么多，应该能讲明白了吧）

（如果懂了的话，就点个赞，让更多人看到吧！如果没懂的话，直接评论区问就好啦）

---

## 作者：VenusM1nT (赞：9)

首先考虑前 60 分，即一棵树的做法。  
由于要求字典序最小，我们很容易想到的就是贪心的做法，即从 1 号节点开始，每次走编号最小的一条，易证这样的字典序是最小的，那么代码实现时我们如果还用链式前向星的话，写起来就会非常的麻烦。  
于是考虑 vector 存图，对于每个点把所有和它连结的点的编号从小到大排序。  
因为我们在使用 vector 时，代码是这么写的：

```cpp
    for(int i=0;i<v[u].size();i++)
```

所以可以保证每次往最小的一边走，然后我们从1号节点出发，跑**一遍** Dfs 就可以得到答案了。  
代码如下（15/25 60分做法）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[5005],tot,a[5005],lat[5005],sum;
vector <int> v[5005];
bool Check()
{
    for(int i=1;i<=n;i++) if(!a[i]) return 0;
    for(int i=1;i<=n;i++) if(a[i]!=ans[i]) return ans[i]>a[i];
}
void Dfs(int u,int faz)
{
    if(sum>n) return;
    a[sum]=u;
    for(int i=0;i<v[u].size();i++)
    {
        if(v[u][i]==faz) continue;
        sum++;
        Dfs(v[u][i],u);
    }
}
int main()
{
    memset(ans,60,sizeof(ans));
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        v[x].push_back(y);
        v[y].push_back(x);
    }
    for(int i=1;i<=n;i++) sort(v[i].begin(),v[i].end());
    sum=1;
    Dfs(1,0);
    memcpy(ans,a,sizeof(a));
    for(int i=1;i<=n;i++) printf("%d ",ans[i]);
    return 0;
}
```

那还有剩下的 40 分呢？其实也不难，我们可以枚举删除一条边，再按原来的办法跑 Dfs 就行。  
但为什么这样可行呢？因为如果一个图里有环的话（$n\leq m$ 在没有重边自环的情况下是肯定有环的），这一个环里**肯定有一条边是用不到的**，正确性显而易见，因为我们下一步只能往没走过的地方走，或者是朝上一个地方走，在这种情况下我们能走的点是 $n$，而能经过的边只有 $n-1$ 条，对于一个 $x$ 个点 $x$ 个边的环来说，肯定是有一条边用不到的（基环树嘛），所以我们就枚举这条用不到的边，然后跑 Dfs 即可。  
但事实证明如果直接枚举所有边在洛谷数据会超时，T 了最后两个点，开 `O2` 是可以过，但还有一种我脑补的优化方法，就是先跑一遍 Dfs，找到环，然后**只删环上的边**，为什么呢？因为我们可以想到，如果你删的边不是在环上而在别的地方，如果**1号节点还能走到环上，时间复杂度是会跑满的**（这也是为什么我在程序里用了一个 `cir` 的布尔变量），这样就很容易超时了。  
这种写法就交给各位了，这里附上我的代码：  
（23/25 92 做法，`O2` 25/25 100）

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[5005],tot,a[5005],lat[5005],sum,fr[5005],to[5005],del;
vector <int> v[5005];
bool cir;
bool Check()
{
    for(int i=1;i<=n;i++) if(!a[i]) return 0;
    for(int i=1;i<=n;i++) if(a[i]!=ans[i]) return ans[i]>a[i];
}
void Dfs(int u,int faz)
{
    if(sum>n)
    {
        cir=1;
        return;
    }
    a[sum]=u;
    for(int i=0;i<v[u].size();i++)
    {
        if((u==fr[del] && v[u][i]==to[del]) || (v[u][i]==fr[del] && u==to[del]) || v[u][i]==faz) continue;
        sum++;
        Dfs(v[u][i],u);
    }
}
int main()
{
    memset(ans,60,sizeof(ans));
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        v[x].push_back(y);
        v[y].push_back(x);
        fr[i]=x;
        to[i]=y;
    }
    for(int i=1;i<=n;i++) sort(v[i].begin(),v[i].end());
    if(m==n-1)
    {
        sum=1;
        Dfs(1,0);
        memcpy(ans,a,sizeof(a));
    }
    else if(n==m)
    {
        for(int i=1;i<=m;i++)
        {
            memset(a,0,sizeof(a));
            del=i;
            sum=1;
            cir=0;
            Dfs(1,0);
            if(!cir && Check()) memcpy(ans,a,sizeof(a));
        }
    }
    for(int i=1;i<=n;i++) printf("%d ",ans[i]);
    return 0;
}
```

---

## 作者：suzhikz (赞：4)

这题还是太牛了。

首先有个很明显的贪心，先给边排序。

然后树的情况就可以直接做了。

考虑基环树的情况，环上一定有一条边无法经过。为什么呢？显然的，如果都经过了，那么一定有一个点遍历了两次，我们就错完了。

这样我们就可以在 $O(n^2)$ 的时间复杂度下做完了。

然后我们考虑[加强版](https://www.luogu.com.cn/problem/P5049)。

我们的 $n$ 变得很大我们原题的瓶颈主要在搜索上，如何优化这个搜索呢？

我们先抛开正确性不谈，来一个假的贪心，直接按照排序后的边一直走（注意如果点在环上优先遍历不在环上的点），不能走了再回溯。

考虑错误的情况什么时候会出现。

出现错误答案一定是因为我们在环上走的时候，先走环的边比先走另一颗树更优（把环脱离后每个环上的点的子树），那我们就先走环然后把环再回溯扫这颗子树。这样子每个点只会遍历到一次，搜索复杂度为 $O(n)$，瓶颈在于排序。

---

## 作者：_ayaka_ (赞：3)

### 思路

纯纯的暴力，甚至是分讨，但能过。

对于 $m=n-1$，这是一棵树，因此所有点想从起点到达都只有一条路径。由此可得类似于“先不访问这个点，以后从别的点再来”这种想法是不行的，毕竟离开这个点，他的儿子就再也不会被访问到了。那我们能做文章的就只有访问儿子的顺序。我所采取的是排序来贪字典序最小的儿子。

然后对于 $m=n$，这是一棵基环树，一棵有一个环的树。基环树很显然的是拆掉环上的一条边就可以变成一棵树。那既然如此，我就可以依次拆掉环上的边进行暴力跑，这样的复杂度也只有 $O(n^2)$，是可以勉强过的。

然后就做完了。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, h[20005], cnt, x, y, tot, ans[20005], circle[20005], num, vis[20005], res[20005];
struct node {
	int to, next, pass;
} t[20005];
void addedge(int u, int v) {
	t[++cnt] = {v, h[u],0};
	h[u] = cnt;
}
multiset<int>s[20005];//可以用预处理排序来消掉这里的复杂度
void dfs(int u, int fa) {
	s[u].clear();
	ans[++tot] = u;
	for (int i = h[u]; i; i = t[i].next) {
		if (t[i].to == fa || t[i].pass) continue;
		s[u].insert(t[i].to);
	}
	while (!s[u].empty()) {
		dfs(*s[u].begin(), u);
		s[u].erase(*s[u].begin());
	}
}
int find(int u, int fa) {
	vis[u] = 1;
	for (int i = h[u]; i; i = t[i].next) {
		int v = t[i].to;
		if (vis[v]) {
			if (v == fa) continue;
			else {
				circle[++num] = i;
				return v;
			}
		}
		int x = find(v, u);
		if (x) {
			if (x != -1) circle[++num] = i;
			if (x != u) return x;
			else return -1;
		}
	}
	return 0;
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> x >> y;
		addedge(x, y);
		addedge(y, x);
	}
	if (find(1, 0)) {
		for (int i = 1; i <= n; i++) res[i] = 0x3f3f3f3f;
		for (int i = 1; i <= num; i++) {
			x = circle[i];
			if (x % 2 == 1) y = x + 1;
			else y = x - 1;
			t[x].pass = t[y].pass = 1;
			dfs(1, 0);
			for (int j = 1; j <= tot; j++) {
				if (ans[j] < res[j]) {
					for (int k = j; k <= tot; k++) res[k] = ans[k];
					break;
				} else if (ans[j] > res[j]) break;
			}
			t[x].pass = t[y].pass = 0;
			memset(ans, 0, sizeof(ans));
			tot = 0;
		}
		for (int i = 1; i <= n; i++) cout << res[i] << " ";
	} else {
		dfs(1, 0);
		for (int i = 1; i <= tot; i++) cout << ans[i] << " ";
	}
	return 0;
}
```

---

## 作者：LHW_Cosset_Idiot (赞：3)

个人认为难度应该在绿题...

### 理解题意：

一个图，求第一次去到每个点的编号顺序。（字典序最小）

很简单，真的。

### 解题思路：

- 只要读了题，就知道一定要贪心的从 $1$ 号点开始，这是绝对最优的！
- 可以先分类讨论，前 $60$ 分，和后 $40$ 分。一个是没有环的情况，另一个有。（最好理解为树，有环断完后还是树）
- 没环的话直接深搜，给出示例程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> b[5001];
bool vis[5001];
int n,m,x,y;
void dfs(int pos){
	if(vis[pos]){
		return ;
	}
	vis[pos]=true;
	cout<<pos<<" ";
	for(int i=0; i<=(int)(b[pos].size()-1); i++){
		dfs(b[pos][i]);
	}
	return ;
}
int main()
{
//	freopen("travel.in","r",stdin);
//	freopen("travel.out","w",stdout);
	cin>>n>>m;
	for(int i=1; i<=m; i++){
		cin>>x>>y;
		b[y].push_back(x);
		b[x].push_back(y);
	}
	for(int i=1; i<=n; i++){
		sort(&b[i][0],&b[i][b[i].size()]);
	}
	dfs(1);
	return 0;
}
```
当然，只有 $60$ 分。
- 接下来考虑有环的情况，我的想法是直接断边，其实很好理解。简单来说，你可以先拿一个单纯的环，没有其他枝叶。用它来模拟，这时你会发现，你第一次选择调头的位置，就是断边位置，断完之后当讨论一做，这个问题很好解决。

就是这么简单，自律点，自己写，这里不给出满分程序。

---

## 作者：yy0707 (赞：2)

### 题目大意：

给你一棵树或者一棵基环树，然你求出字典序最小的遍历顺序。

### Solution:

首先我们将所有点的出边排序，然后对于树的情况，我们直接从节点 1 开始遍历。

对于基环树的情况，我们枚举每一条边，然后删掉它，然后继续从点 1 开始遍历，再从所有遍历的结果中取个字典序最小的。

然后就做完了，时间复杂度 $O(n^2)$，卡卡常勉强能过。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,cnt,res[5001],ans[5001];
bitset<5001>bz;
vector<int>g[5001];
inline void dfs(int u){
	bz[u]=1,res[++cnt]=u;
	for(auto v:g[u])if(!((u==x&&v==y)||(u==y&&v==x)||bz[v]))dfs(v);
}signed main(){
	// freopen("travel.in","r",stdin);freopen("travel.out","w",stdout);
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}for(int i=1;i<=n;i++)sort(g[i].begin(),g[i].end());
	if(m==n-1){
		dfs(1);
		for(int i=1;i<=n;i++)cout<<res[i]<<' ';
	}else{
		for(x=1;x<=n;x++){
			for(auto v:g[x]){
				bz.reset(),y=v,
				cnt=0,dfs(1);
				if(cnt==n){
					for(int i=1;i<=n;i++){
						if(!ans[i]||res[i]<ans[i]){
							for(int j=1;j<=n;j++){
								ans[j]=res[j];
							}break;
						}if(res[i]>ans[i])break;
					}
				}
			}
		}for(int i=1;i<=n;i++)cout<<ans[i]<<' ';
	}
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

首先考虑是一颗树的情况。

注意到若在点 $u$ **反悔**往回走，则 $u$ 子树内其他点就都访问不了了；故不能**反悔**，每次按照儿子的编号从小到大深搜即可。

然后考虑 $m = n$ 的情况，是**基环树**；直接枚举一条边断开，然后按照上面树的做法做即可。

时间复杂度为 $O(N \log N + N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5050;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, m, u, v, now;
int f[N];
vector<int> ans, p;
vector<pair<int, int>> E[N];
inline void add(int u, int v, int id){
	E[u].push_back({v, id});
	E[v].push_back({u, id});
}
inline void dfs(int u, int fa){
	if(f[u] == now)
	  return ;
	f[u] = now;
	ans.push_back(u);
	for(auto t : E[u]){
		int v = t.fi, id = t.se;
		if(v == fa || id == now)
		  continue;
		dfs(v, u);
	}
}
bool End;
int main(){
	n = read(), m = read();
	for(int i = 1; i <= m; ++i){
		u = read(), v = read();
		add(u, v, i);
	}
	for(int i = 1; i <= n; ++i){
		f[i] = -1;
		sort(E[i].begin(), E[i].end());
	}
	if(m == n - 1){
		dfs(1, 1);
		for(auto v : ans){
			write(v);
			putchar(' ');
		}
		exit(0);
	}
	for(int i = 1; i <= m; ++i){
		now = i;
		ans.clear();
		dfs(1, 1);
		if((int)ans.size() != n)
		  continue;
		if(p.empty() || ans < p)
		  p = ans;
	}
	for(auto v : p){
		write(v);
		putchar(' ');
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：complete_binary_tree (赞：1)

经典基环树题，但是细节有点多。

---

考虑是树的情况，此时仅需要**往叶子节点中编号最小的走**即可，走完了就直接回溯。因为走更大的节点字典序肯定更大。

考虑基环树。

基环树带有一个环，这个环可以**从两边走**，也就是说如果从这一侧推进时遇到了不优的点，可以回溯到入环点（第一次进入环的点，下同），从另一侧进入环。

那么剩下的就简单了：直接贪，遇到环点（环上的点，下同）和往另一边走的环点比大小，如果另一边更小就回溯走过去。然后交上去发现你 `WA` 了一车点。

发生什么了？有可能之前的点还有儿子，这个儿子比往前继续走环还小，就可以回溯回去，走这个点。

这种回溯有个性质：由于回溯以后不能再回来，所以必须**要把所有（非环点）儿子都走完才能回溯**。所以回溯到的点只能是上一个**还有儿子**的点。

此时记录上一个还有儿子的点的最小儿子为 $x$，当前节点为 $u$，找到当前 $u$ 的最小儿子 $v$：

- $v < x$：直接继续贪即可，没有影响。

- $v > x$：

  此时需要继续分讨。

  - 如果剩余节点有非环点：那么只能把这些非环点点走完再回溯。
 
  - 如果没有非环点：此时 $v$ 为唯一环点。如果此时 $u$ 在环上（防止没进入环）且没有回溯过（只能回溯一次）即可回溯。
 
所以回溯的条件是**该点只剩一个大于 $x$ 的儿子、该儿子是环点、没回溯过、该点在环上**。

该题数据较弱，可以暴力枚举最小儿子做到 $O(n^2+m)$。[出门左转](https://www.luogu.com.cn/problem/P5049)有加强版，可以使用 `priority_queue` 来存储儿子和寻找最小儿子做到 $O(n \log n+m)$。下展示加强版代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5;
#define pq priority_queue<int, vector<int>, greater<int>>

vector<int> e[N];
int n, m;
bool cir[N], vis[N], can;

void findcir( int u, int fa ) {
    vis[u] = 1;
    for( auto v : e[u] ) {
        if( v == fa ) continue;
        if( vis[v] ) {
            cir[u] = cir[v] = 1;
            can = 1;
            return ;
        }
        findcir( v, u );
        if( cir[v] && can ) {
            if( cir[u] ) can = 0;
            cir[u] = 1;
            return ;
        }
    }
}

void dfs( int u, int lst ) {
    if( vis[u] ) return ;
    vis[u] = 1;
    printf( "%d ", u );
    pq q; int cnt = 0;
    for( auto v : e[u] ) 
        if( !vis[v] ){
            q.push( v );
            cnt += (cir[v] ^ 1);
        }
    while( !q.empty() ) {
        int v = q.top(); q.pop();
        if( vis[v] ) continue;
        if( can == 0 && !cnt && v > lst && !vis[lst] ) {
            can = 1;
            return;
        }
        cnt -= (cir[v] ^ 1);
        dfs( v, ( q.empty() || !cir[u] ) ? lst : q.top() );
    }
}

int main() {
    scanf( "%d%d", &n, &m );
    while( m-- ) {
        int u, v;
        scanf( "%d%d", &u, &v );
        e[u].push_back( v ), e[v].push_back( u );
    }
    findcir( 1, 0 );
    memset( vis, 0, sizeof vis );
    dfs( 1, 1e9 );
    return 0;
}
```

---

## 作者：Shunpower (赞：1)

介绍一下本题最原始的 $\mathcal O(n^2)$ 做法。

--------------

考虑数据分治：我们先做 $m=n-1$ 的树的情况。

注意到小 Y 的旅行方案本质上是一个 DFS 整张图的过程（每次只能走向一个没走过的点或者回溯），所以事实上我们就是要确定一个字典序最小的 DFS 序。

考虑字典序的好处是具有局部最优性：我们只要每次选择最好的就是全局最好的。所以我们第一步肯定是选择从 $1$ 开始 DFS，之后每次需要选择没有走过的边中连向的点最小的一个走下去。在 DFS 过程中记录一下方案就可以了。

直接每次回到一个点都重新枚举所有边是 $\mathcal O(n^2)$ 的。但是显然我们只要把一个点上的边从小到大排好序，按照顺序 DFS 就等价于我们这个过程。

这样做是 $\mathcal O(n\log n+n)$ 的。

然后考虑 $m=n$ 的基环树。因为 DFS 走过的边总是可以构成一棵树，所以实际上答案的走法和原基环树就只有一条边不走的区别。我们可以枚举这条不走的边把它删掉（实现上就是在 DFS 的时候特判一下），然后再同样做 $m=n-1$ 的做法就可以了。

发现我们可以提前排好序。这样做就是 $\mathcal O(n\log n+n^2)$ 的。

----------------

因为可能会写得常数比较大，可能还需要一些卡常技巧：

- 答案不够优秀时直接换下一条边。
- 只枚举环上的边。
- 减少 `vector` 使用。

我写的只枚举环边：

```cpp
int n,m;
vector <int> p[N];
vector <int> rans;
vector <int> ans;
vector <pii> ok;
pii lt;
int ins[N];
bool vis[N];
void dfs(int x){
    ans.pb(x);
    vis[x]=1;
    fv(i,p[x]){
        int y=p[x][i];
        if(vis[y]||mp(x,y)==lt||mp(y,x)==lt){
            continue;
        }
        dfs(p[x][i]);
    }
}
int main(){
#ifdef Griffin
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    cin>>n>>m;
    if(m==n-1){
        fr1(i,1,m){
            int u,v;
            cin>>u>>v;
            p[u].pb(v);
            p[v].pb(u);
        }
        fr1(i,1,n){
            sort(p[i].begin(),p[i].end());
        }
        dfs(1);
        fv(i,ans){
            cout<<ans[i]<<" ";
        }
        cout<<'\n';
        ET;
    }
    fr1(i,1,m){
        int u,v;
        cin>>u>>v;
        ins[u]++,ins[v]++;
        p[u].pb(v);
        p[v].pb(u);
    }
    fr1(i,1,n){
        sort(p[i].begin(),p[i].end());
    }
    queue <int> q;
    fr1(i,1,n){
        if(ins[i]==1){
            q.push(i);
        }
    }
    while(!q.empty()){
        int x=q.front();
        q.pop();
        fv(i,p[x]){
            ins[p[x][i]]--;
            if(ins[p[x][i]]==1){
                q.push(p[x][i]);
            }
        }
    }
    fr1(i,1,n){
        fv(j,p[i]){
            if(ins[i]!=1&&ins[p[i][j]]!=1&&i>p[i][j]){
                ok.pb(mp(i,p[i][j]));
            }
        }
    }
    fv(i,ok){
        ans.clear();
        fr1(j,1,n){
            vis[j]=0;
        }
        lt=ok[i];
        dfs(1);
        if(rans.empty()){
            rans=ans;
        }
        else{
            if(ans<rans){
                rans=ans;
            }
        }
    }
    fv(i,rans){
        cout<<rans[i]<<" ";
    }
    cout<<'\n';
    ET;
}
```

---

## 作者：yijan (赞：1)

我比较沙雕，qwq但是看到没人写这种做法就来水一下。。

考场上看到这题先是懵逼。。看到边和点数量相等就知道这题不难了。。

对于树的情况，贪心是很显然的。但是如果不是树呢？

既然边和点相等，那么显然只会有一条**返祖边**。

在加边的时候可以考虑用一个并查集来维护边，这样就可以在输入的时候找到这条返祖边。我们暂时不把这条边加入这课树，贪心跑一次dfs得到当前的答案curans。

接下来考虑删除一条边。肯定是返祖边两端、以及它们LCA这三个点组成的环上的一条边。由于本题题目范围5000，可以考虑（好像也只能考虑）用朴素算法——两个点一层一层往上跳。

每跳一层考虑删一个边重新跑一次dfs。

luogu271ms,不算快

代码有点长，但思路很清晰：
```cpp
/*Heroes Never Die!
 But For Price.*/
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<set>
#define merge(u,v) fa[find(u)] = fa[find(v)]
// 暴力出奇迹
using namespace std;
#define MAXN 5005
bool cut[MAXN][MAXN];
vector<int> e[MAXN]; vector<int> curans[2];
int dep[MAXN] , pre[MAXN] , n , m ;
void dfs(int u,int fa,int w,int t) {
    curans[w].push_back(u);
    for(int i = 0 ; i < e[u].size(); ++i) {
        int v = e[u][i];
        if(v == fa || cut[u][v]) continue;
        if(!t) dep[v] = dep[u] + 1 , pre[v] = u;
        dfs(v,u,w,t);
    }
}
int fa[MAXN];
int find(int u ) {
    return u == fa[u] ? u : fa[u] = find(fa[u]);
}
int U , V;
int main() {
    //freopen("13.in","r",stdin);
    //freopen("travel.out","w",stdout);
    cin >> n >> m;
    if( m == n - 1 ) {
        for(int i = 0,u,v ; i < m ; ++ i) 
            scanf("%d%d",&u,&v),e[u].push_back(v) , e[v].push_back(u);
        for(int i = 1 ; i <= n ; ++ i) sort(e[i].begin(),e[i].end());
        dfs(1,1,0,1);
        for(int i = 0 ; i < curans[0].size() ; ++ i) printf("%d ",curans[0][i]);
        return 0;puts("rua~");
    }
    else {
        for(int i = 1 ; i <= n ; ++ i) fa[i] = i;
        for(int i = 0,u,v ; i < m ; ++ i) {
            scanf("%d%d",&u,&v);
            if(find(u) != find(v))
                e[u].push_back(v) , e[v].push_back(u), merge(u,v);
            else U = u , V = v;
        }
        for(int i = 1 ; i <= n ; ++ i) sort(e[i].begin(),e[i].end());
        dfs(1,1,0,0);
        int curmin = 0 , uu = U , vv = V;
        e[uu].push_back(vv) , e[vv].push_back(uu) , sort(e[uu].begin(),e[uu].end()) ,sort(e[vv].begin(),e[vv].end());
        if(dep[U] < dep[V]) swap(U,V);
        while(dep[U] > dep[V]) {
            cut[U][pre[U]] = cut[pre[U]][U] = true , curans[curmin^1].clear();
            dfs(1,1,curmin^1,1);
            for(int i = 0 ; i < curans[0].size() ; ++i)  
                if(curans[curmin][i] != curans[curmin^1][i]) {
                    if(curans[curmin][i] > curans[curmin^1][i]) curmin ^= 1;
                    break;
                }
            cut[U][pre[U]] = cut[pre[U]][U] = false;
            U = pre[U];
        }
        while(U != V) {
            cut[U][pre[U]] = cut[pre[U]][U] = true , curans[curmin^1].clear();
            dfs(1,1,curmin^1,1);
            for(int i = 0 ; i < curans[0].size() ; ++i)  
                if(curans[curmin][i] != curans[curmin^1][i]) {
                    if(curans[curmin][i] > curans[curmin^1][i]) curmin ^= 1;
                    break;
                }
            cut[U][pre[U]] = cut[pre[U]][U] = false;
            U = pre[U];
            swap(U,V);
            cut[U][pre[U]] = cut[pre[U]][U] = true, curans[curmin^1].clear();
            dfs(1,1,curmin^1,1);
            for(int i = 0 ; i < curans[0].size() ; ++i)  
                if(curans[curmin][i] != curans[curmin^1][i]) {
                    if(curans[curmin][i] > curans[curmin^1][i]) curmin ^= 1;
                    break;
                }
            cut[U][pre[U]] = cut[pre[U]][U] = false;
            U = pre[U];
        }
        for(int i = 0 ; i < curans[curmin].size() ; ++ i) printf("%d ",curans[curmin][i]);
    }
} 
```

---

## 作者：Wei_ch (赞：0)

这题的要求是给定一个无向连通图，从任意起点出发，遍历所有城市，并使得遍历路径的字典序最小。

这道题的遍历方法肯定是**深度优先搜索**，因为我们可以按照字典序优先访问节点，保证路径的字典序最小。

这道题其实可以分为两个部分：
1. $ m = n-1 $（图是树）：树是无环的图，可以直接用简单的 DFS 按字典序遍历所有节点，按字典序优先访问节点即可。按字典序对邻接表排序，再从节点 $ 1 $ 开始，遍历节点，记录路径。
1. $ m = n $（图是连通图且有一个环）：图中有一个环，DFS 可能会重复访问某些节点，导致路径字典序不符合要求。我们需要尝试删除每条边并判断是否能保持图的连通性。如果发现删除某条边后图仍然连通，就在删除后用 DFS 构造路径，更新最优路径。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5000 + 5;

int n, m;                         // 节点数和边数
vector<int> graph[MAXN];          // 邻接表存储图
vector<int> path;                 // 当前路径
bool visited[MAXN];               // 节点访问标记

// DFS 遍历，记录路径
void dfs(int node) {
    visited[node] = true;
    path.push_back(node);
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
}

// 判断连通性（不删除边时）
bool is_connected() {
    memset(visited, false, sizeof(visited));
    path.clear();
    dfs(1);
    return path.size() == n;
}

// 主函数
int main() {
    cin >> n >> m;

    vector<pair<int, int>> edges; // 存储所有边
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
        edges.emplace_back(u, v);
    }

    // 对邻接表中的节点按字典序排序
    for (int i = 1; i <= n; i++) {
        sort(graph[i].begin(), graph[i].end());
    }

    if (m == n - 1) {
        // 情况 1：树
        dfs(1);
    } else {
        // 情况 2：有环
        vector<int> best_path; // 字典序最小的路径

        for (auto [u, v] : edges) {
            // 尝试删除边 (u, v)
            graph[u].erase(find(graph[u].begin(), graph[u].end(), v));
            graph[v].erase(find(graph[v].begin(), graph[v].end(), u));

            if (is_connected()) {
                // 如果删除该边后图仍然连通，比较路径字典序
                if (best_path.empty() || path < best_path) {
                    best_path = path;
                }
            }

            // 还原边 (u, v)
            graph[u].push_back(v);
            graph[v].push_back(u);
            sort(graph[u].begin(), graph[u].end());
            sort(graph[v].begin(), graph[v].end());
        }

        path = best_path;
    }

    // 输出结果路径
    for (int i = 0; i < path.size(); i++) {
        if (i > 0) cout << " ";
        cout << path[i];
    }
    cout << endl;

    return 0;
}
```
[记录](https://www.luogu.com.cn/record/195958637)

---

## 作者：Nephren_Sakura (赞：0)

思路：贪心+暴力。

首先注意到数据范围有一个很重要的性质：$n-1 \le m \le n$。

又因为图是一个联通图，结合上这条性质，也就是原图为一颗树或一颗基环树。

我们首先考虑一颗树的情况，注意到当你使用走回到上一个点的操作时，由于树的性质，这颗子树里面的其他点不再能被走到。

又因为题目要求走过所有点，也就是你必须遍历完**整颗子树**才可以往回退，那么这就是让我们找到一个最小的 dfs 序。

还有编号互不相同的性质在，我们意识到可以直接贪心的每次选当前点的编号最小的儿子。因为字典序的前面如果比另一个小，后面就没有任何用处了。

于是我们发现对于一颗树，我们可以 $O(n \log n)$ 的时间复杂度内求出答案。

那么对于一颗基环树呢？这东西和树的唯一区别是多了个环，考虑枚举环上的一条边把他断开然后再跑，可以做到 $O(n^2 \log n)$。

然后这个做法我们每次都排序感觉很浪费，我们可以提前排序预处理优化到 $O(n^2)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,ans[1000005],nw[1000005],cnt;
bool vis[1000005];
struct node{
	int x;
	int id;
};
vector<node> v[5005];
bool f[5005];
bool cmp(node x,node y){
	return x.x<y.x;
}
void dfs1(int cur,int fa){
	cout<<cur<<' ';
	for(int i=0; i<v[cur].size(); i++)
		if(v[cur][i].x!=fa)
			dfs1(v[cur][i].x,cur);
	return;
}
void dfs(int cur){
	nw[++cnt]=cur;
	f[cur]=true;
	for(int i=0; i<v[cur].size(); i++)
		if(vis[v[cur][i].id]==false&&f[v[cur][i].x]==false)
			dfs(v[cur][i].x);
	return;
}
bool check(){
	for(int i=1; i<=n; i++){
		if(ans[i]>nw[i])
			return true;
		else if(ans[i]<nw[i])
			return false;
	}
	return true;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1; i<=m; i++){
		int x,y;
		cin>>x>>y;
		v[x].push_back(node{y,i});
		v[y].push_back(node{x,i});
	}
	for(int i=1; i<=n; i++)
		sort(v[i].begin(),v[i].end(),cmp);
	if(m==n-1)
		dfs1(1,0);
	else{
		memset(ans,0x3f,sizeof ans);
		for(int i=1; i<=m; i++){
			memset(f,false,sizeof f);
			cnt=0;
			vis[i]=true;
			dfs(1);
			if(cnt==n&&check()==true)
				for(int i=1; i<=n; i++)
					ans[i]=nw[i];
			vis[i]=false;
		}
		for(int i=1; i<=n; i++)
			cout<<ans[i]<<' ';
	}
	return 0;
}
```

---


# [NOI1999] 钉子和小球

## 题目描述

有一个三角形木板,竖直立放，上面钉着 $ \frac{ n (n+1) } { 2 } $ 颗钉子，还有 ($n+1$) 个格子 （当 $n=5$ 时如图 1 ） 。每颗钉子和周围的钉子的距离都等于 $d$ ，每个格子的宽度也都等于 $d$ ，且除了最左端和最右端的格子外每个格子都正对着最下面一排钉子的间隙。

让一个直径略小于 $d$ 的小球中心正对着最上面的钉子在板上自由滚落，小球每碰到一个钉子都可能落向左边或右边 （概率各 $1/2$ ） ，且球的中心还会正对着下一颗将要碰上的钉子。例如图2 就是小球一条可能的路径。

我们知道小球落在第 $i$ 个格子中的概率 $p_i$ = $ \frac{C_n^i}{2^n}$ = $ \frac{ n! }{ 2^n i! (n-i)! } $ ，其中 $i$ 为格子的编号，从左至右依次为 $ 0 , 1 , ... , n $.
 
现在的问题是计算拔掉某些钉子后，小球落在编号为 $m$ 的格子中的概率 $p_m$ 。假定最下面一排钉子不会被拔掉。例如图3 是某些钉子被拔掉后小球一条可能的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/ntaygrw7.png)

 图1  $\qquad$ $\qquad$ $\quad$ $\quad$  图2    $\quad$ $\qquad$ $\qquad$ $\quad$                       图3 

## 样例 #1

### 输入

```
5 2
    *    
   * .
  * * *
 * . * *
* * * * *
```

### 输出

```
7/16
```

# 题解

## 作者：fzwfzwfzw (赞：12)

我们来看一下这道题：

如果所有钉子都还在，那么

小球落在第 $i$ 个格子中的概率为

## $p_i$ = $ \frac{C_n^i}{2^n}$ = $ \frac{ n! }{ 2^n i! (n-i)! } $ 

其实这道题是一个dp，我们发现 $n$ （$ 2 \leq n \leq  50 $）所以，我们可以n方暴力做

![](https://cdn.luogu.com.cn/upload/image_hosting/52aylxfi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们设一个个的小格子中的概率为$f$

因为我们要求的为一个最简分数，所以

### $f[i][j].a$表示分子，$f[i][j].b$表示分子，这是个既约分数

我们可以发现

![](https://cdn.luogu.com.cn/upload/image_hosting/refrt631.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

落在这个位置的小球概率为1，所以

### $f[0][1].a=1,f[0][1].b=1$

![](https://cdn.luogu.com.cn/upload/image_hosting/s0zs10yn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

### 我们通过观察法可以得到，如果在$f[i][j]$的正下方

# 有

### 钉子，那么

### $f[i][j]$ 有 $ \frac{1}{2}$的概率落在 $f[i+1][j]$ 上，

### 有 $ \frac{1}{2}$的概率落在 $f[i+1][j+1]$ 上

但是如果我们拔掉一个钉子

![](https://cdn.luogu.com.cn/upload/image_hosting/st2kxfum.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

### $f[0][1]$就只有可能落在$f[2][2]$上面，所以我们得到

### 如果在$f[i][j]$的正下方

# 没有

### 钉子，那么

### $f[i][j]$ 落在 $f[i+2][j+1]$ 上

所以dp方程就出来了，初始值为

### $f[0][1].a=1,f[0][1].b=1$

$c[i][j]$表示$i-1,j$是否有钉子

### 若$c[i][j]==1$则$f[i][j]+=\frac{f[i-1][j]}{2},f[i][j+1]+=\frac{f[i-1][j]}{2}$

### 若$c[i][j]==0$则$f[i+1][j+1]+=f[i-1][j]$



如果有不理解的地方可以私信我！

下面是代码时间！！！

注意，要写一个分数类出来（就是重载一下运算符代码里面有解释）！

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
long long gcd(long long a,long long b)//欧几里得算法
{
	return b==0?a:gcd(b,a%b);
}
struct node
{
	long long a,b;
	void huajian()//让该分数成为既约分数
	{
		long long w=gcd(a,b);
		a=a/w;
		b/=w;
	}
	node operator /(const long long y)const//一个分数除以一个整数
	{
        node t = *this;
        t.b *= y,t.huajian();
        return t;
	}
	node operator +(node y)const//一个分数加上另外一个分数
	{
		if(a==0)
		{
			y.huajian();
			return y;
		}
		node o=*this;
		if(y.a==0)
		{
			o.huajian();
			return o;
		}
		long long p=gcd(o.b,y.b);
		o.a*=(y.b/p);o.a+=y.a*(o.b/p);o.b*=(y.b/p);
		o.huajian();
		return o;
	}
}f[1005][1005];//其实只要开50就够了！
int n,m;
int c[1005][1005];
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			char w;
			while((w=getchar())!='*'&&w!='.');
			if(w=='*')c[i][j]=1;
		}
	}
	f[0][1].a=1;//初始化
	f[0][1].b=1;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=1;j<=n+1;j++)
		{
			f[i][j].b=1;//注意要吧所有分数初始化一下，不然除以0化简时会RE
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(c[i][j])
			{
				node p=f[i-1][j];//有钉子的时候
				p=p/2;
				f[i][j]=f[i][j]+p;
				f[i][j+1]=f[i][j+1]+p;
			}
			else 
			{
				f[i+1][j+1]=f[i+1][j+1]+f[i-1][j];//没有钉子的时候
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i+1;j++)
		{
			f[i][j].huajian();//记得要化简哟！！！
		}
	f[n][m+1].huajian();
	cout<<f[n][m+1].a<<"/"<<f[n][m+1].b<<endl;//cout大发好
	return 0;
}
```
## 祝大家好运！

---

## 作者：青丘杨哲 (赞：5)

# $Solution$

本题是一道很经典也很基础的概率$DP$题。虽然当时并不存在概率$DP$这一类问题，甚至连$DP$的概念都很模糊，但我们亦可从中忆昔窥见$OI$当初朴素的身影。

题目不难，但是对于一些关键处还是要多加解释。题目中从上到下、从左到右都是从$0$开始编号，我们将其调整为从$1$开始.

首先对于行、列、钉子、块的位置关系要有正确的理解。定义未拆除钉子前钉子中间的空隙位置称作块。最容易确定的是钉子，为方便起见，设$(i,j)$表示第$i$行的第$j$个钉子。因为小球是从第一个钉子上方出发的，我们不妨规定第$1$个钉子上方的块为第$1$行的唯一一个块，那么第$1$行唯一一个钉子下方、第$2$行上方的两个块就是第二行的两个块。以此类推，第$n-1$行的钉子下方、第$n$行的钉子上方的块就是第$n$行的块。再对每行的块从左到右进行标号即可。易知，加上最下方的的格子，全图共有$n+1$行块，第$i$行第$j$个块记为$[i,j]$。

注意对于钉子和块，行和列的指向性是不同的。定义后，我们要求的就是第$n+1$行第$m+1$个块被小球落到的概率。（原本的列也是从$0$开始编号）

容易理解，小球落在一个格子中的概率，就是有$p$个小球落下时，该格子中落到的小球数量的期望除以$p$。因为小球的下落状况最多有$2^n$种可能，我们不妨假定有$2^n$个小球下落，并求每个块的期望。

设$f_{i,j}$表示块$[i,j]$所落到的小球数量的期望。

![avatar](https://cdn.luogu.com.cn/upload/image_hosting/31s0zhgk.png)

如果一个钉子尚未被拔去，那么小球显然有相等的期望滚到两个分叉的块去，即$[i+1,j]$和$[i+1,j+1]$。此时有方程：

$$f_{i+1,j} = f_{i+1,j} + \frac{f_{i,j}}{2}$$

$$f_{i+1,j+1} = f_{i+1,j+1}+\frac{f_{i,j}}{2}$$

如果一个钉子被拔去，那么我们的直觉是它会下落到第$i+1$行的块中。然而由于小球是垂直下落的，每两行之间的块又是交错分布，小球在第$i+1$行并不能找到相应位置的块，因此只能继续下落到第$i+2$行，而第$i+2$行的第$j+1$个块恰好在水平方向上和它位置一致，因此第$i+2$行的第$j+1$个块可以接收块$[i,j]$的全部期望。此时有方程：

$$f_{i+2,j+1} = f_{i+2,j+1} + f_{i,j}$$

最后所求格子的期望就是$f_{n+1,m+1}$，故概率为$\dfrac{f_{n+1,m+1}}{2^n}$。但是由于题目要求输出既约分数，我们最终要求的$A,B$计算方式如下：

$$A=\frac{f_{n+1,m+1}}{\gcd (f_{n+1,m+1},2^n)}$$

$$B=\frac{2^n}{\gcd(f_{n+1,m+1},2^n)}$$

至此题目完美解决。

---

## 作者：巴菲特 (赞：3)

概率DP。

状态转移和前两行有关。

为了便于计算，令$f[i][j]$表示球落到$[i][j]$的概率乘上$2^{n+1}$。$f[1][1] = 2^{n + 1}$。开$long long$足矣。

如果$[i][j]$这个位置没有钉子，那么球就不会从$[i][j]$落到$[i + 1][j]$和$[i + 1][j + 1]$，而会直接落到$[i + 2][j + 1]$。

如果$[i][j]$这个位置有钉子，那么球有一般概率从$[i][j]$落到$[i + 1][j]$，一般概率从$[i][j]$落到$[i + 1][j + 1]$。

初始化$f[1][1]$和$f[2][1]$和$f[2][2]$。

```cpp

#include<set>
#include<map>
#include<cmath>
#include<ctime>
#include<stack>
#include<queue>
#include<vector>
#include<bitset>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define LL long long
using namespace std;
inline void Read(int &x){
	int f=1;
	char c=getchar();
	x=0;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	x*=f;
}

LL f[51][51];
bool ext[51][51];
int n, m;
char c;
LL qp(LL a, LL b){
	LL res = 1;
	while(b){
		if(b & 1)	res *= a;
		a *= a;
		b >>= 1; 
	}
	return res;
}

LL gcd(LL a, LL b){
	return b == 0 ? a : gcd(b, a % b);
}
signed main()
{
	Read(n); Read(m); m += 1;
	f[1][1] = qp(2, 0ll + n + 1);
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= i; ++j){
			cin >> c;
			if(c == '*')	ext[i][j] = 1;
		}
	}

	if(ext[1][1]){
		f[2][1] = f[1][1] / 2;
		f[2][2] = f[1][1] / 2;		
	}

	for(int i = 3; i <= n + 1; ++i){
		for(int j = 1; j <= i; ++j){
				f[i][j] = f[i - 1][j - 1] / 2 * ext[i - 1][j - 1] + f[i - 1][j] / 2 * ext[i - 1][j] + f[i - 2][j - 1] * (!ext[i - 2][j - 1]);
		}
	}

	LL g = gcd(f[n + 1][m], f[1][1]);
	printf("%lld/%lld\n", f[n + 1][m] / g, f[1][1] / g);
}


```

---

## 作者：_anll_ (赞：1)

~~没想到这道水蓝还能写题解！~~

### 题目大意
题面写的很清楚，就不再赘述了，唯一难理解的点可能就是拔掉钉子后对应的小球会**垂直落在它正下方**的那个钉子上。

### 大体思路
令 $dp[i][j]$ 为落在第 $i$ 行第 $j$ 个钉子上的概率，之后也默认以 $dp[i][j]$ 为单位进行表述。因为题目需要按照分数的方式输出，所以我们拆分一下，令 $dp[i][j][0]$ 为分子，$dp[i][j][1]$ 为分母。

于是考虑状态转移方程，不妨就着样例模拟：

因为初始时小球正对着最上面的钉子，所以我们将 $(1,1)$ 设为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/tevwmevc.png)

进行第一次降落：

![](https://cdn.luogu.com.cn/upload/image_hosting/f9d3omqt.png)

很容易想到，如果有钉子，小球会落向钉子的左边或右边，体现在这张图上就是 $(1,1)$ 的概率平分到 $(2,1)$ 和 $(2,2)$上。于是得出结论：当 $(x,y)$ 有钉子时，$dp[x][y]$ 的值会被 $dp[x+1][y]$ 和 $dp[x+1][y+1]$ 平均继承。

如果没有钉子，小球会落向缺位的正下方，如本样例中的 $(2,2)$，属于它的值落在了 $(4,3)$ 上，如果不理解为什么落在这建议与题面中的图 $3$ 对视两分半。于是得出结论：当 $(x,y)$ 缺位，$dp[x][y]$ 的值会被 $dp[x+2][y+1]$ 全部继承。

知道这些之后就可以开始写代码了，注意不开 `long long` 见祖宗！

剩下的模拟步骤如下，如果对前面得到结论的过程有疑问可以参考：

第二层掉到第三层：

![](https://cdn.luogu.com.cn/upload/image_hosting/08enk4lw.png)

第三层掉到第四层：

![](https://cdn.luogu.com.cn/upload/image_hosting/gkbu3b3r.png)

第四层掉到第五层：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1375qy9.png)

第五层掉到格子：

![](https://cdn.luogu.com.cn/upload/image_hosting/dt1ac2o3.png)

### 代码演示
大体思路就是这样，如果有不清晰的地方可以结合代码理解。
```cpp
#include<iostream>
#include<cmath>
#define int long long
#define nowa dp[i][j][0]
#define nowb dp[i][j][1]
using namespace std;
int n,m,dp[55][55][2];
int gcd(int a,int b){
	if(!a&&!b) return 1;
	if(!b) return a;
	return gcd(b,a%b);
}
void add(int i,int j,int a,int b){
	if(!a||!b) return;
	if(!nowa&&!nowb){nowa=a,nowb=b;return;}
	if(nowb==b){nowa+=a;return;}
	int awa=nowb/gcd(nowb,b)*b;
	nowa*=(awa/nowb),a*=(awa/b);
	nowa+=a,nowb=awa;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;m+=1;
	dp[1][1][0]=dp[1][1][1]=1;
	string ss;getline(cin,ss);
	for(int i=1;i<=n;i++){
		string s;getline(cin,s);s='6'+s;int j=0;
		for(int k=1;k<s.size();k++){
			if(s[k]==' ') continue;
			j+=1;
			int awa=gcd(nowa,nowb);
			nowa/=awa,nowb/=awa;
			if(s[k]=='*'){
				int a,b;
				if(nowa&&nowa%2==0) a=nowa/2,b=nowb;
				else a=nowa,b=nowb*2;
				add(i+1,j,a,b);
				add(i+1,j+1,a,b);
			}
			else{
				add(i+2,j+1,nowa,nowb);
				nowa=nowb=0;
			}
		}
	} 
	int i=n+1,j=m,awa=gcd(nowa,nowb);
	nowa/=awa,nowb/=awa;
	cout<<nowa<<"/"<<nowb<<endl;
	return 0;
}
```

---

## 作者：PigNotFound (赞：0)

概率 dp 题。

首先分析题目，可以发现对于每个格子，如果有针，则球等概率往两边走。否则会走到两排后的格子。

如图：
![有针](https://cdn.luogu.com.cn/upload/image_hosting/enbkd87w.png)

![没针](https://cdn.luogu.com.cn/upload/image_hosting/27tvr0sy.png)

定义 $f_{i,j}$ 表示球到达位置 $i,j$ 的上面的概率。
如果有针，则 $\frac{f_{i,j}}{2}\xRightarrow{+}f_{i+1,j}$，$\frac{f_{i,j}}{2}\xRightarrow{+}f_{i+1,j+1}$
否则$f_{i,j}\xRightarrow{+}f_{i+2,j+1}$

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Pig = 60;
struct frac {
    ll up, down;
    frac() : up(0), down(1) {}
    frac(ll u_, ll d_) : up(u_), down(d_) {}
    frac operator+(frac a) const {
        ll d = lcm(down, a.down), u = up * (d / down) + a.up * (d / a.down), g = gcd(u, d);
        return {u / g, d / g};
    }
    frac operator/(ll n) const {
        return {up, down * n};
    }
};
frac f[Pig][Pig];
ll n, m;
bitset<Pig> nails[Pig];
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (ll j = 0; j <= i; j++) {
            char c;
            cin >> c;
            nails[i][j] = (c == '*' ? 1 : 0);
        }
    }
    f[0][0] = {1, 1};
    for (ll i = 0; i < n; i++) {
        for (ll j = 0; j <= i; j++) {
            if (nails[i][j]) {
                f[i + 1][j] = f[i + 1][j] + (f[i][j] / 2);
                f[i + 1][j + 1] = f[i + 1][j + 1] + (f[i][j] / 2);
            } else {
                f[i + 2][j + 1] = f[i + 2][j + 1] + f[i][j];
            }
        }
    }
    cout << f[n][m].up << "/" << f[n][m].down;
    return 0;
}
```

---

## 作者：100Accepted (赞：0)

设 $(i,j)$ 为小球所在的位置，$f[i][j]$ 表示小球掉到 $(i,j)$ 的概率,结构体中 $a$ 为分子，$b$ 为分母。

当 $(i,j)$ 为空时，小球直接掉到正下方即 $(i+2，j+1)$ 处，小球掉到 $(i+2，j+1)$ 时的概率加上掉到 $(i,j)$ 时的概率。

当 $(i,j)$ 不为空时，小球有 $\frac{1}{2}$ 概率掉到 $(i+1,j)$ 处，另有 $\frac{1}{2}$ 概率掉到 $(i+1，j+1)$ 处。小球掉到 $(i+1，j)$ 时的概率加上掉到 $(i,j)$ 时概率的一半，小球掉到 $(i+1，j+1)$ 时的概率加上掉到 $(i,j)$ 时概率的一半。

Code: 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
struct st{
	ll a,b;
}f[111][111];
char p;
ll n,m,i,j,c[111][111],k,l;
ll ld(ll a,ll b){
	if(b==0)return a;
	if(b==1)return 1;
	return ld(b,a%b);
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=n;i++){
		for(j=1;j<=i;j++){
			cin>>p;
			if(p=='*')c[i][j]=1;
			else c[i][j]=0;
		}
	}
	for(i=0;i<=n+1;i++){
		for(j=0;j<=i+1;j++){
			f[i][j].a=0;f[i][j].b=1; //初始化
		}
	}
	f[1][1].a=1;f[1][1].b=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=i;j++){
			if(f[i][j].a==0&&f[i][j].b==1)continue;
			if(c[i][j]==1){
				f[i][j].b*=2;
				k=ld(f[i][j].b,f[i+1][j].b);
				if(k>0){
					l=f[i][j].b/k*f[i+1][j].b; // 注意：先除再乘，否则会爆 
					f[i+1][j].a=l/f[i+1][j].b*f[i+1][j].a+l/f[i][j].b*f[i][j].a;
					f[i+1][j].b=l;
				}
				k=ld(f[i][j].b,f[i+1][j+1].b);
				if(k>0){
					l=f[i][j].b/k*f[i+1][j+1].b;
					f[i+1][j+1].a=l/f[i+1][j+1].b*f[i+1][j+1].a+l/f[i][j].b*f[i][j].a;
					f[i+1][j+1].b=l;
				}
				f[i][j].b/=2;
			}
			else{
				k=ld(f[i][j].b,f[i+2][j+1].b);
				if(k>0){
					l=f[i][j].b/k*f[i+2][j+1].b;
					f[i+2][j+1].a=l/f[i+2][j+1].b*f[i+2][j+1].a+l/f[i][j].b*f[i][j].a;
					f[i+2][j+1].b=l;
				}
			}
		}
	}
	k=ld(f[n+1][m+1].a,f[n+1][m+1].b);  //计算所求格子的概率 
	if(k!=0){
		f[n+1][m+1].a/=k;f[n+1][m+1].b/=k;
	}
	printf("%lld/%lld",f[n+1][m+1].a,f[n+1][m+1].b);
	return 0;
}
```

---

## 作者：Hanx16Kira (赞：0)

# [NOI1999] 钉子和小球

[Luogu P5750](https://www.luogu.com.cn/problem/P5750)

## Solution

这是蓝题？绿题都算高估它了。

这种跟数字三角形一样的题肯定就是动态规划了（实际上也确实和数字三角形差不了多少）。

先将输入数据处理一下，方便存储和处理（以样例为例）：

```
O
O X
O O O
O X O O
O O O O O
```

设 $f[i][j]$ 表示上图中小球落到 $i$ 行 $j$ 列的钉子的概率。那么不难发现 $f[i][j]$ 可以从自己的正上方的 `O` 和左上方 `O` 转移过来，同样也可以从 $(i-2,j-1)$ 的 `X` 转移过来。对于正上方和左上方的 `O`，显然各自掉到当前点的概率都是 $\displaystyle \frac 1 2$，而如果是 $(i-2,j-1)$ 处的 `X` 则是一定会掉到当前点。因此推出 $f[i][j]$ 的转移方式：

$$
f[i][j] = p_1 \cdot f[i-1][j] \cdot \frac 1 2 + p_2 \cdot f[i-1][j-1]
\cdot \frac 1 2 + p_3 \cdot f[i-2][j-1]
$$

其中 $p_1$ 表示 $(i-1,j)$ 是否为 `O`，$p_2$ 表示 $(i-1,j-1)$ 是否为 `O`，$p_3$ 表示 $(i-2,j-1)$ 是否为 `X`。

边界条件为 $f[1][1] = 1$。

所以就这么简单的转移能叫蓝题？

### Code

对于这道题的最大难点，就是分数的加法可能会出现爆 `long long` 的情况，因此需要一些特殊处理，其他都很简单。

对于分数加法的处理，可以把

$$
\frac b a + \frac d c = \frac {bc + ad}{ac}
$$

转化为

$$
\frac b a + \frac d c = \frac{\frac{\text{lcm}(a,c)}{c}\cdot b + \frac{\text{lcm}(a,c)}{a}\cdot d}{\text{lcm}(a,c)}
$$

这样就不会爆 `long long` 了 ~~（话说这才是这道题最大的难点吧）~~。

为了方便，把分数的处理封装到一个结构体里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
char getchar_no_space() { // 貌似直接用 cin 也行，用处是处理掉空格和换行
	char c = getchar();
	while (isspace(c)) c = getchar();
	return c;
}
constexpr int _SIZE = 50;
int n, m;
bool gra[_SIZE + 5][_SIZE + 5];
struct FRAC{ // 分数
	long long x, y;
	FRAC(int a = 0, int b = 1) {x = a, y = b;}
	FRAC operator + (const FRAC &a) const {
		FRAC ans;
		long long lcm = y / __gcd(y, a.y) * a.y; // 先求 lcm
		ans.x = lcm / y * x + lcm / a.y * a.x; // 用 lcm 计算答案
		ans.y = lcm;
		return ans;
	}
	FRAC operator * (const FRAC &a) const { // 乘法因为只会乘 1/2 所以不管
		FRAC ans;
		ans.x = x * a.x;
		ans.y = y * a.y;
		int GCD = __gcd(ans.x, ans.y);
		ans.x /= GCD, ans.y /= GCD;
		return ans;
	}
	void print(char c) {
		printf("%lld/%lld%c", x, y, c);
	}
}f[_SIZE + 5][_SIZE + 5];
FRAC half; // 1/2
signed main() {
	half.x = 1, half.y = 2;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			char cur = getchar_no_space();
			gra[i][j] = cur == '*';
		}
	}
	for (int i = 0; i <= n + 2; i++)
		for (int j = 0; j <= i + 1; j++)
			f[i][j] = FRAC(0, 1);
	f[1][1] = FRAC(1, 1); // 初始化	
	for (int i = 2; i <= n + 1; i++) {
		for (int j = 1; j <= n; j++) { // 转移
			if (gra[i - 1][j]) f[i][j] = f[i][j] + f[i - 1][j] * half;
			if (gra[i - 1][j - 1]) f[i][j] = f[i][j] + f[i - 1][j - 1] * half;
			if (i > 2 && j > 1 && j - 1 <= i - 2 && !gra[i - 2][j - 1]) f[i][j] = f[i][j] + f[i - 2][j - 1];
		}
	}
	f[n + 1][m + 1].print('\n');
	return 0;
}
```

---

## 作者：George_Je (赞：0)

设 $f[i][j]$ 表示小球落到第 $i$ 行、第 $j$ 列的概率。则：

- 若第 $i$ 行、第 $j$ 列有钉子，那么 $f[i][j]$ 可以对 $f[i+1][j]$ 和 $f[i+1][j+1]$ 分别产生 $\frac 1 2 f[i][j]$ 的贡献。

- 若第 $i$ 行、第 $j$ 列无钉子，那么 $f[i][j]$ 只能对 $f[i+2][j+1]$ 产生 $f[i][j]$ 的贡献。

答案即为 $f[n+1][m+1]$。

**由于题目要求答案用分数呈现，所以在做分数加法时需要先取分母的 $lcm$ 再运算，以免爆 ```long long```。**

------------

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N = 50, MAX_N = N + 3;
struct frac {
	int a, b;
	frac (int _a = 0, int _b = 1): a (_a), b (_b) {}
	inline void cut () {
		int gcd = __gcd (a, b);
		if (!gcd) return;
		a /= gcd;
		b /= gcd;
	}
	friend frac operator * (frac x, frac y) {
		frac z = {x.a * y.a, x.b * y.b};
		z.cut ();
		return z;
	}
	friend frac operator + (frac x, frac y) {
		int lcm = x.b / __gcd (x.b, y.b) * y.b;
		frac z = {lcm / x.b * x.a + lcm / y.b * y.a, lcm};
		return z;
	}
	void print () {cout << a << '/' << b;}
} k = frac (1, 2);
char gra [MAX_N] [MAX_N];
frac f [MAX_N] [MAX_N];
signed main () {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= i; ++j)
			cin >> gra [i] [j];
	f [1] [1] = frac (1);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= i; ++j)
			if (gra [i] [j] == '*') {
				f [i + 1] [j] = f [i + 1] [j] + k * f [i] [j];
				f [i + 1] [j + 1] = f [i + 1] [j + 1] + k * f [i] [j];
			}
			else f [i + 2] [j + 1] = f [i + 2] [j + 1] + f [i] [j];
	f [n + 1] [m + 1].print ();
}
```


---


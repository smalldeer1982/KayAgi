# [NOIP2020] 字符串匹配

## 题目描述

小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。

对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：

$S = ABC$，$S = ABABC$，$S = ABAB \ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。

更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \texttt{aab}$，$B = \texttt{ab}$，则 $AB = \texttt{aabab}$。

并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \ge 2$ 且为正整数）。例如 $A = \texttt{abb}$，则 $A^3=\texttt{abbabbabb}$。

则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。

小 C 并不会做这道题，只好向你求助，请你帮帮他。

## 说明/提示

**【样例 #1 解释】**

对于第一组数据，所有的方案为

1. $A=\texttt{n}$，$B=\texttt{nr}$，$C=\texttt{nnr}$。
2. $A=\texttt{n}$，$B=\texttt{nrn}$，$C=\texttt{nr}$。
3. $A=\texttt{n}$，$B=\texttt{nrnn}$，$C=\texttt{r}$。
4. $A=\texttt{nn}$，$B=\texttt{r}$，$C=\texttt{nnr}$。
5. $A=\texttt{nn}$，$B=\texttt{rn}$，$C=\texttt{nr}$。
6. $A=\texttt{nn}$，$B=\texttt{rnn}$，$C=\texttt{r}$。
7. $A=\texttt{nnr}$，$B=\texttt{n}$，$C=\texttt{nr}$。
8. $A=\texttt{nnr}$，$B=\texttt{nn}$，$C=\texttt{r}$。

**【数据范围】**

| 测试点编号 | $\lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | 无 |
| $5 \sim 8$ | $100$ | 无 |
| $9 \sim 12$ | $1000$ | 无 |
| $13 \sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |
| $15 \sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |
| $18 \sim 21$ | $2^{17}$ | 无 |
| $22 \sim 25$ | $2^{20}$ | 无 |

对于所有测试点，保证 $1 \le T \le 5$，$1 \le |S| \le 2^{20}$。 

## 样例 #1

### 输入

```
3
nnrnnr
zzzaab
mmlmmlo
```

### 输出

```
8
9
16
```

## 样例 #2

### 输入

```
5
kkkkkkkkkkkkkkkkkkkk
lllllllllllllrrlllrr
cccccccccccccxcxxxcc
ccccccccccccccaababa
ggggggggggggggbaabab
```

### 输出

```
156
138
138
147
194
```

## 样例 #3

### 输入

```
见附件中的 string/string3.in```

### 输出

```
见附件中的 string/string3.ans```

## 样例 #4

### 输入

```
见附件中的 string/string4.in```

### 输出

```
见附件中的 string/string4.ans```

# 题解

## 作者：泥土笨笨 (赞：179)

我有个梦想，我想写一篇多图的，讲解细的，注释多的，$O(nlog26)$复杂度的题解。

# 前置知识
1. 树状数组 这个相信能参加NOIP的同学都会。
2. 扩展KMP算法 模板题：[P5410 【模板】扩展 KMP（Z 函数）](https://www.luogu.com.cn/problem/P5410) 这道题我也写了[题解](https://www.luogu.com.cn/blog/nitubenben/solution-p5410)，欢迎评论点赞围观。这道模板题是紫色的，其实一点也不难，我觉得难度有点虚标了，相信你看了我的题解很快就可以学会的。

如果你不会扩展KMP算法，其实也不影响你阅读本文，只需知道这个算法提供了一个z函数的计算方式。

不妨设输入的字符串是$s$，下标从$0$开始，长度是$n$。用$s[i,j]$表示$s$中从下标$i$位置到下标$j$位置的子串，包括$i$和$j$。那么$z[i]$表示$s[i,n-1]$与$s$本身的最长公共前缀的长度。

比如$z[0]$表示$s$与$s$的公共子串的长度，那么$z[0]=n$

$z[1]$表示$s$去掉开头第一个字符以后，和自己的最长公共前缀的长度，依次类推。扩展KMP算法可以在$O(n)$时间内求出$z$数组的所有位置。

# 枚举循环节长度

先不考虑题中的出现奇数次这个条件。先考虑把$s$拆成$(AB)^kC$的方案数，其中$AB$合起来是一个循环节，我们先考虑一个循环节有多长。

不妨设循环节长度为$i$，第一个发现是，只要满足$2 \leq i \leq n-1$都可以。因为$A$和$B$都不能为空，所以循环节长度至少是$2$。循环节长度最多是$n-1$，因为$C$也不能为空。

当循环节长度是$i$的时候，至少$k$可以取到$1$，就是只循环一次，后面剩下的都给$C$。除此之外，k还可以取多少呢？不妨以$i=3$为例，画一个图看看

![](https://cdn.luogu.com.cn/upload/image_hosting/16k5feoc.png)

假设$z[3]=7$，也就是说，字符串从$3$位置开始，连续$7$个长度的子串，和字符串刚开头的$7$个字符相等。那么我们把$s$再画一遍，去掉前$3$个位置，抄在下面，如图所示，那么画蓝线的部分是相等的。

现在考虑长度为$3$的循环节，首先红色的$3$个位置，和下面橙色的三个位置肯定是相等的，因为它们都是蓝线部分开头的$3$个。而橙色的部分上下是对应相等的，于是红色和橙色相等。

同理，由于橙色和绿色相等，那么红，橙，绿都相等，也就是说长度为3的循环节，至少可以循环3次。这里可以看出，蓝线的长度，除以循环节的长度再加1，就可以算出来最多可以循环几次，如果不能整除，向下取整。这个例子里面就是$\lfloor 7/3 \rfloor +1$，那么$k$可以取$3$种。

那么第一个结论就出来了，枚举一下循环节的长度i，总的方案数就是

$$\lfloor \frac{z[i]}{i} \rfloor +1$$

之和。

# 考虑字符出现的次数

题目中还有一个条件我们没有考虑，为了说话方便，我们定义$f(i,j)$表示$s[i,j]$中出现奇数次的字符的个数。

假设现在枚举到循环节长度为$i$，此时根据前面的结论，我们算出来$k$的方案数有$t$种。其中一半$k$是奇数，一半$k$是偶数。当然奇数可能比偶数多一个。不妨设$k$是奇数的取值方案数是$tj$，那么有$tj = t-t/2$，同理设偶数的$k$的个数是$to$，有$to = t/2$

考虑$k$的取值。如果$k$的值是奇数:

![](https://cdn.luogu.com.cn/upload/image_hosting/iv72qpb3.png)

如图所示，$k=1$时候，$C$的长度是从$i$开头的后缀的长度。$k=3$的时候，$C$是更短的红线表示的范围。这两种情况下，$C$当中出现次数为奇数的字符的个数是一样多的，因为如果循环节多出现了两次，相当于循环节里面的每个字符都出现了偶数次，不影响$C$当中出现次数为奇数次的字符的个数。

所以，当$k$是奇数的时候，我们只需计算出来，以$i$为开头的后缀当中出现奇数次的字符的个数就行了。然后在长度为i的子串的前缀$s[0,j]$当中，找出来满足：

$$f(0,j) \leq f(i,n-1)$$

的$j$的个数，记为$t1$。而对于每个合法的$j$，我们发现，只要是奇数的$k$，都可以是一种合法方案，所以这里要乘法原理一下，把$t1$和$tj$的个数相乘。

再来考虑k是偶数的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/6pxq01fv.png)

跟前面情况类似，当k是偶数的时候，后缀C里面的只出现奇数次的字符的个数，和整个串里面只出现奇数次的字符个数是相等的。在长度为i的子串的前缀$s[0,j]$当中，找出来满足：

$$f(0,j) \leq f(0,n-1)$$

的$j$的个数，记为$t2$。那么这种情况下的方案数，就是$t2$和$to$相乘。

# 具体实现

首先前面的算法中用到了$f(0,n-1)$，这个好办，直接预处理算出来就行了。

在从左往右扫字符串$s$的过程中，假设我们目前枚举到位置$i$，此时我们计算循环节长度为$i+1$的情况，此时$A$最远可以取到$i-1$位置，把$i$位置留着给$B$，保证$B$不为空。我们可以用一个桶，维护$i+1$开头的后缀里面每个字母出现的次数，当$i$向右循环的时候，每次只改一个字符，所以在桶的对应位置减$1$，然后看看出现奇数次的字符数量如何变化就行了。

不妨设这个桶叫$after$，一共有$26$个格，分别表示每个字符出现的次数。起始的时候，先扫一遍s，把整个字符串都统计一遍，这时候可以顺手求出整个串里面只出现奇数次的字符的个数，记到$all$变量里面。然后当后面循环的时候，循环到$i$位置，就把$after[s[i]-'a']$位置减$1$。设变量$suf$表示$f[i+1,n-1]$，如果在$after[s[i]-'a']$减1之前，$suf$是奇数，那么减完以后，后缀里面的奇数就会少一个，那么$suf$减$1$，否则$suf$加一。这样每次$i$移动，$suf$都可以$O(1)$维护。

那么循环节里面的每个前缀中出现奇数次的字符个数，可以放到一个树状数组里面，这样这个树状数组一共有$26$个位置，每个位置$p$保存出现奇数次的字符有$p$个的前缀有多少个。$i$每向右循环$1$位，就在计算完结果以后，把当前前缀扔到树状数组里面。

其他细节可以参考代码

# 代码时间

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
const int MAXN = (1 << 20) + 5;
char s[MAXN];//输入的字符串
int n, z[MAXN];//字符串长度，以及z函数的值
int before[30], after[30];//两个桶，分别统计当前枚举到的位置左侧和右侧每个字符出现的频次
int pre, suf, all;//当前枚举到的位置的前缀、后缀、整个串里面出现奇数次的字符的个数

//树状数组，对于s的某个前缀si，如果它里面出现奇数次的字符有m个，则在树状数组m+1位置+1
int c[30];

inline int lbt(int x) {
    return x & -x;
}

void update(int x) {
    while (x <= 27) {
        c[x]++;
        x += lbt(x);
    }
}

int sum(int x) {
    int r = 0;
    while (x > 0) {
        r += c[x];
        x -= lbt(x);
    }
    return r;
}

//扩展KMP算法，计算z函数的值
//可以参考良心博客 https://www.luogu.com.cn/blog/nitubenben/solution-p5410
void Z() {
    z[0] = n;
    int now = 0;
    while (now + 1 < n && s[now] == s[now + 1]) {
        now++;
    }
    z[1] = now;
    int p0 = 1;
    for (int i = 2; i < n; ++i) {
        if (i + z[i - p0] < p0 + z[p0]) {
            z[i] = z[i - p0];
        } else {
            now = p0 + z[p0] - i;
            now = max(now, 0);
            while (now + i < n && s[now] == s[now + i]) {
                now++;
            }
            z[i] = now;
            p0 = i;
        }
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        cin >> s;
        n = strlen(s);
        memset(before, 0, sizeof(before));
        memset(after, 0, sizeof(after));
        memset(c, 0, sizeof(c));
        all = pre = suf = 0;
        Z();
        //如果发现循环节可以到结尾，减1，空至少一个位置给C
        for (int i = 0; i < n; ++i) {
            if (i + z[i] == n) z[i]--;
        }
        //先把字符串过一遍，频次统计到after数组里面
        for (int i = 0; i < n; ++i) {
            after[s[i] - 'a']++;
        }
        //扫一下每个字母，计算整个串中出现奇数次的字符的个数
        for (int i = 0; i < 26; ++i) {
            if (after[i] & 1) {
                all++;
            }
        }
        suf = all;//后缀中的值暂时和整个串一致
        long long ans = 0;
        for (int i = 0; i < n; ++i) {
            //再扫一次字符串，当循环到i位置的时候，循环节长度是i+1
            //s[i]要从右边去掉，维护after数组和suf变量
            if (after[s[i] - 'a'] & 1) {
                //之前是奇数，现在变成偶数了
                suf--;
            } else {
                suf++;
            }
            after[s[i] - 'a']--;
            //s[i]加到左边，维护before和pre变量
            if (before[s[i] - 'a'] & 1) {
                pre--;
            } else {
                pre++;
            }
            before[s[i] - 'a']++;
            if (i != 0 && i != n - 1) {
                //循环节大于1,才能对答案有贡献，因为题中说ABC都不为空
                int t = z[i + 1] / (i + 1) + 1;
                ans += 1LL * (t / 2) * sum(all + 1) + 1LL * (t - t / 2) * sum(suf + 1);
            }
            update(pre + 1);
        }
        cout << ans << endl;
    }
    return 0;
}
```


---

## 作者：zjcOvO (赞：121)

（纪念我在NOIp2020考场上唯一过掉的题）

### 题面与思路

先读题：本题要求 $S=(AB)^iC$ 使得 $A$ 中出现奇数次的字符数量 ≤ $C$ 中出现奇数次的字符数量。

很容易想到一种做法：把 $(AB)$ 结合为一个字符串，判断 $(AB)^i$ 是否是 $S$ 的前缀，并用借助预处理统计答案。

### 具体实现

#### $(AB)^i$ 判断

这里有一些关于周期的事，想到 KMP算法 中的 fail 数组（或者叫 next 数组）。

此时我们想到一个结论：

> 字符串A的最短周期 $=|A|-fail[A]$

于是我们从二开始枚举 $i$ ，只要 $S_{|(AB)^i|}$ 的最短周期是 $|AB|$ 的约数，则 $(AB)^i$ 一定是 $S$ 的前缀。

预处理出 fail 数组即可

#### 答案统计

需要预处理出 $S$ 每个后缀中出现奇数次字符数量即可确定 $C$ 中出现奇数次的字符数量。

统计答案同时更新到每一位时出现奇数次的字符数量 ≤ $x(x\in [0,26])$ 的 $A$ 的数量。

#### 复杂度分析

首先，对于随机生成的字符串，这种算法时间复杂度为 $O(n)$

对于形如 $a^nC$ 或 $a^n$ （ $a$ 是单个字符）的字符串，算法的时间复杂度 $O( n *  \sum\limits_{i=1}^n\frac{1}{i}) = O(n\log n)$

复杂度肯定不如题解区里的其他大佬的，但能过CCF

洛谷评测机状态好的时候不开O2也能卡过去，但状态不好时会92~96。开了O2肯定是可以过的。

### 代码

（请原谅我丑陋的码风）

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long ll;
char str[(1<<20)+2]; 
int n,kmp[(1<<20)+2],cir[(1<<20)+2],tms[30],suf[(1<<20)+2],pre[(1<<21)+2],per[27];ll ans;
void deal(){
	char c=getchar();ans=0ll;
	memset(kmp,0,sizeof(kmp));									//<初始化>
	memset(cir,0,sizeof(cir));
	memset(tms,0,sizeof(tms));
	memset(suf,0,sizeof(suf));
	memset(pre,0,sizeof(pre));
	memset(per,0,sizeof(per));									//</初始化>
	while(c>'z'||c<'a')	c=getchar();n=0;int last;				//<读入> 
	while(c<='z'&&c>='a'){str[++n]=c;c=getchar();}				//</读入> 
	for(int i=2;i<=n;i++){last=kmp[i-1];						//<预处理fail数组>（kmp数组即为 fail数组） 
		while(str[i]!=str[last+1]&&last!=0)last=kmp[last];
		if(str[i]==str[last+1])kmp[i]=last+1;else kmp[i]=0;		//</预处理fail数组>
	}int cnt=0;for(int i=1;i<=26;i++)tms[i]=0;					//<预处理后缀>
	for(int i=n;i>=1;i--){
		tms[str[i]-'a'+1]++;
		if(tms[str[i]-'a'+1]&1)
			suf[i]=suf[i+1]+1;
		else	suf[i]=suf[i+1]-1;								//</预处理后缀>
	}for(int i=1;i<=26;i++)tms[i]=0;							//<预处理前缀>（其实这一段可以画到后面一段里，数组就可以开的小一些） 
	for(int i=1;i<=n;i++){
		tms[str[i]-'a'+1]++;
		if(tms[str[i]-'a'+1]&1)
			pre[i]=pre[i-1]+1;
		else	pre[i]=pre[i-1]-1;
	}															//</预处理前缀>
	for(int i=1;i<n;i++){										//处理 
		if(i>=2){												//|AB|>=2 此时有解 
			ans+=per[suf[i+1]];									//更新答案 
			for(int j=i+i;j<n;j+=i){ 
				if(((i%(j-kmp[j]))==0)&&((j/(j-kmp[j]))>1)){
					ans+=ll(per[suf[j+1]]);						//更新周期串答案 
				}else break;
			}
		}
//		printf("*>. seq on %d , cur ans is %lld\n",i,ans);
		for(int j=1;j<pre[i];j++)per[j]=per[j];					//<更新A中出现j个奇数次数字符时可行的A的数量> 
		for(int j=pre[i];j<=26;j++){
			per[j]=per[j]+1;
		}														//</更新A中出现j个奇数次数字符时可行的A的数量>
	}
//	for(int i=1;i<=n;i++)printf("%d ",pre[i]);printf("\n");//
	printf("%lld\n",ans);
}
int main(){

freopen("string.in","r",stdin);									//文件输入输出 
freopen("string.out","w",stdout);								//文件输入输出

int T;scanf("%d\n",&T);for(;T>0;T--){deal();}return 0;}			//多组数据 
```
----------

大概…………那就这样？

---

## 作者：xtx1092515503 (赞：85)

严格 $O(n)$ 的解法出来了。

------------

首先，我们必须知道一个事实：

如果一个长度为 $n$ 的字符串有长度为 $m$ 的循环节，那么，其前 $n-m$ 位与后 $n-m$ 位相同是充分必要条件。

具体可以通过看一张图直观理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/h3b0egnj.png)

然后，我们考虑Z算法（即[【模板】扩展 KMP（Z 函数）](https://www.luogu.com.cn/problem/P5410)）。

对于位置 $i$，其 $Z$ 数组 $Z_i$ 的定义是从位置 $i$ 起始的后缀与整个串的LCP长度。具体应该怎样求出可以参照该题题解，此处不讲述。

回到本题。我们考虑枚举 $AB$ 串的长度 $i$，并计算有多少前缀可以被表示成 $(AB)^k$ 的形式。明显此前缀的长度必然为 $ik$ 。

则依据我们刚才的循环节理论，假如其可以被表示成 $(AB)^k$ 形式，必有 $s_{[i,ik-1]}=s_{[0,i(k-1)-1]}$，其中 $s_{[a,b]}$ 表示原串从 $a$ 到 $b$ 的子串，下标自 $0$ 开始。即，从 $i$ 开始长度为 $i(k-1)$ 的子串，必定等于长度为 $i(k-1)$ 的前缀。

考虑 $s_{[i,ik-1]}$ 即为原串中自第 $i$ 位起始的后缀的前缀；则如果有 $ik-i\leq Z_i$，即该前缀的长度不大于 $Z_i$ 的大小，则依据 $Z$ 数组的意义，有 $s_{[i,ik-1]}=s_{[0,i(k-1)-1]}$（因为 $Z$ 表示的是公共前缀的长度）。

于是，只有 $ik-i\leq Z_i$ 的长度为 $ik$ 的前缀 $(AB)^k$，才有长度为 $i$ 的循环节 $AB$。上式可以被等价表述为 $k\leq\dfrac{Z_i}{i}+1$，即对于一个位置 $i$，共有 $\dfrac{Z_i}{i}+1$ 个合法的 $k$。当然，合法的 $k$，其后缀必然不为空，这意味着 $Z_i$ 应与 $n-i-1$ 取 $\min$。

在下文中，定义“奇偶性”为某个串中出现奇数次的字符数量。

考虑截去长度为 $ik$ 的前缀后剩下的后缀，则该后缀则为 $C$。明显，当 $k$ 是奇数和 $k$ 是偶数时，$C$ 的奇偶性只有两种可能。

更准确地说，$k$ 是奇数时，有其奇偶性全部等价于起始于 $i$ 的后缀的奇偶性；$k$ 是偶数时，其奇偶性全部等价于起始于 $2i$ 的后缀的奇偶性；但是因为 $2i$ 本身相当于 $i$ 出现两次，出现两次的串的奇偶性必为 $0$，故其实际上就相当于整个串的奇偶性。

于是，我们会发现，共有 $\left\lceil\dfrac{\dfrac{Z_i}{i}+1}{2}\right\rceil$ 个后缀是和 $i$ 开头的后缀同奇偶的，共有 $\left\lfloor\dfrac{\dfrac{Z_i}{i}+1}{2}\right\rfloor$ 个后缀是和整个串同奇偶的（分别对应着 $k$ 为奇和 $k$ 为偶两种情形）。

我们下面考虑有多少个合法的 $A$ 串。明显它必须是 $AB$ 串的某个前缀，也即整个串的前缀。

于是，我们要考虑的，就是 $i$ 之前的前缀中，共有多少个的奇偶性不大于 $i$ 开头的后缀的奇偶性，即 $k$ 为奇数时合法 $A$ 的数量；共有多少个的奇偶性不大于整个串的奇偶性，即 $k$ 为偶数时合法 $A$ 的数量；然后此为奇为偶时的 $A$ 的数量，再分别乘上我们刚才求出的为奇为偶时的 $C$ 的数量，就是 $AB$ 长度为 $i$ 的合法拆分的数量。

我们可以先考虑使用桶进行维护所有前缀中各奇偶性的出现次数，每次暴力扫过桶处理。则目前的复杂度是 $O(26n)$ 的。 

先贴出考场代码（会TLE）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int T,n,Z[2001000],mas[2001000],sum[30],CN,BN;
ll res;
char s[2001000];
int COUNT(int ip){
	int ret=0;
	while(ip)ret+=ip&1,ip>>=1;
	return ret;
}
int main(){
	freopen("string.in","r",stdin);
	freopen("string.out","w",stdout);
	scanf("%d",&T);
	while(T--){
		scanf("%s",s),n=strlen(s),memset(sum,0,sizeof(sum)),res=CN=BN=0;
		mas[0]=1<<(s[0]-'a');
		for(int i=1;i<n;i++)mas[i]=mas[i-1]^(1<<(s[i]-'a'));
		CN=COUNT(mas[n-1]);
		int Centre=-1,Rpos=-1;
		for(int i=1;i<n;i++){
			if(i<=Rpos)Z[i]=min(Z[i-Centre],Rpos-i+1);
			else Z[i]=0;
			while(i+Z[i]<n&&s[Z[i]]==s[i+Z[i]])Z[i]++;
			if(i+Z[i]>Rpos)Centre=i,Rpos=i+Z[i]-1;
		}
//		for(int i=1;i<n;i++)printf("%d ",Z[i]);puts("");
		for(int i=1;i<n;i++){
			int C1=mas[n-1]^mas[i-1];
			C1=COUNT(C1);
			int tot=min(Z[i],n-i-1)/i+1;
			int N1=(tot+1)>>1,N2=(tot)>>1;
//			printf("%d:%d %d\n",tot,N1,N2);
			for(int j=0;j<=C1;j++)res+=1ll*sum[j]*N1;
			sum[COUNT(mas[i-1])]++;
			res+=1ll*BN*N2;
			if(COUNT(mas[i-1])<=CN)BN++;
		}
		printf("%lld\n",res);
	}
	return 0;
}
```

下面考虑优化。

首先，上述程序统计奇偶性时，是使用了一个状压来统计——但这本身就有一个 $26$ 的常数。换成桶来统计，即可做到 $O(n)$ 来处理。

然后，观察到随着 $i$ 每次增加 $1$，长度为 $i$ 的后缀的奇偶性最多只会变化 $1$。这意味着我们可以直接在前一位统计的基础上，直接加上或减去有所变动的那一个桶里的值即可。

这两个优化加上，即可把复杂度优化到严格 $O(n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int T,n,Z[2001000],cnt1[30],cnt2[30],sum[30],CN,BN,nown,sumn,nown2;
ll res;
char s[2001000];
int main(){
//	freopen("string.in","r",stdin);
//	freopen("string.out","w",stdout);
	scanf("%d",&T);
	while(T--){
		scanf("%s",s),n=strlen(s),memset(sum,0,sizeof(sum)),memset(cnt1,0,sizeof(cnt1)),memset(cnt2,0,sizeof(cnt2)),res=CN=BN=0;
		for(int i=0;i<n;i++)cnt1[s[i]-'a']^=1;
		for(int i=0;i<26;i++)CN+=cnt1[i];
		int Centre=-1,Rpos=-1;
		for(int i=1;i<n;i++){
			if(i<=Rpos)Z[i]=min(Z[i-Centre],Rpos-i+1);
			else Z[i]=0;
			while(i+Z[i]<n&&s[Z[i]]==s[i+Z[i]])Z[i]++;
			if(i+Z[i]>Rpos)Centre=i,Rpos=i+Z[i]-1;
		}
//		for(int i=1;i<n;i++)printf("%d ",Z[i]);puts("");
		nown=CN,nown2=sumn=0;
		for(int i=1;i<n;i++){
			if(cnt1[s[i-1]-'a'])sumn-=sum[nown--];
			else sumn+=sum[++nown];
			cnt1[s[i-1]-'a']^=1;
			int tot=min(Z[i],n-i-1)/i+1;
			int N1=(tot+1)>>1,N2=(tot)>>1;
//			printf("%d:%d %d\n",tot,N1,N2);
			res+=1ll*sumn*N1;
			if(cnt2[s[i-1]-'a'])nown2--;
			else nown2++;
			cnt2[s[i-1]-'a']^=1;
			sum[nown2]++;
			if(nown2<=nown)sumn++;
			res+=1ll*BN*N2;
			if(nown2<=CN)BN++;
		}
		printf("%lld\n",res);
	}
	return 0;
}
```

---

## 作者：Ryo_Yamada (赞：73)

闲话：NOIp 前一天，我刚刚奶了一口：“往年 NOIp 没考过 KMP，不 用 复 习 了。”

然后。T2 开幕雷击 ~~虽然是扩展 KMP 我也不会。~~

回到正轨。

### 做法一

按照题意枚举 $A,\,B,\,C$，再判断是否符合条件。其中，$A$ 一定是 $S$ 的一个前缀，$C$ 一定是 $S$ 的一个后缀，$B$ 是中间的一个子串。枚举复杂度 $O(n^3)$，判断复杂度 $O(n)$，整体复杂度 $O(n^4)$，预计得分 $16pts$。

实际上稍加优化就能达到 $O(n^3)$ 复杂度，方法不少，预计得分 $32pts$。

### 做法二

预处理 $S$ 中所有前缀字符串和后缀字符串出现奇数个字符的个数。

枚举 $(AB)$ 的总长度，然后枚举 $(AB)$ 重复的次数 $i$，直到 $AB$ 不再重复或者已经达到 $S$ 的总长度。由于 $S=(AB)^iC$，所有剩下的部分就是 $C$。

讨论满足条件的 $A$ 的个数，由于预处理过，每次判断复杂度为 $O(1)$。

总复杂度 $O(n^2+|S|)$，预计得分 $48pts$。

#### 特殊性质一

$S$ 中只包含一种字符。

枚举 $C$ 的长度，假设剩下的长度为 $l$，则 $(AB)$ 的长度一定是 $l$ 的一个非 $1$ 因数。

- 如果 $C$ 的长度为奇数，那么 $A$ 的长度随意。
- 如果 $C$ 的长度为偶数，那么 $A$ 的长度也为偶数。

每次 $O(1)$ 计算，总复杂度 $O(n)$。结合 $O(n^2)$ 做法，期望得分 $56pts$。

#### 特殊性质二

$S$ 中只包含两种字符。

结合特殊性质，出现奇数次字符的个数只可能是 $0,\,1$ 或 $2$。枚举 $(AB)$ 的总长度，可以用字符串哈希快速求出 $(AB)$ 最多重复多少次。

枚举 $(AB)$ 重复的次数 $i$ 相当于调和级数求和，最终复杂度 $O(n \log n)$。结合做法二和特殊性质一，期望得分 $68pts$。

### 做法三

特殊性质二统计有多少 $A$ 符合条件只需考虑 $0,\,1$ 和 $2$ 三种奇数个字符个数的情况。我们发现，需要考虑的最多奇数个字符的个数是 $26$ 个。用树状数组维护即可。

时间复杂度 $O(n \log n \log 26)$，期望得分 $84pts$。

### 正解

继续分析发现，对于固定的 $(AB)$，根据重复次数的奇偶性，其对应的 $C$ 中出现奇数次的字符个数只有两种可能。

直接统计每种可能对答案的贡献即可。复杂度 $O(n \log 26)$，期望得分 $100pts$。

---

## 作者：tongyf (赞：55)

[题面](https://www.luogu.com.cn/problem/P7114)

前言：

当时在考场上我想到这个做法的时候内心是十分激动的，毕竟会两个题了。但是由于常数过大，被卡到和$O(tn\sqrt n)$甚至$O(tn\sqrt nlogn)$同分。

思路：

一种暴力是直接枚举$AB$和$C$，考虑如何优化这个暴力。

发现如果我们知道了$(AB)^i$，那么$C$已经确定了。

所以我们只需要枚举$|AB|$以及$i$了。

如何判断长为$|AB|^i$的前缀是不是$(AB)^i$？用哈希。

开一个桶记录每种出现奇数次的字母出现次数有几个前缀，枚举$i$的时候把桶的前缀和累加到对应位置，前缀和暴力维护即可。

时间复杂度$O(t(nlogn+26n))$。

先贴一下考场代码（除了没有$freopen$其余真完全一致）：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
const int base=131;
int t,n,sum[1050005][30],a[1050005],b[1050005],v[1050005],ans=0,vis[30],l[1050005],r[30],tot=0;
char s[1050005];
signed main(){
	cin>>t;
	while(t--){
		scanf("%s",s+1);
		n=strlen(s+1);
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(v,0,sizeof(v));
		memset(l,0,sizeof(l));
		memset(vis,0,sizeof(vis));
		memset(r,0,sizeof(r));
		ans=0;tot=0;
		for(int i=1;i<=n;i++){
			if(!r[s[i]-'a'+1]){
				tot++;
				r[s[i]-'a'+1]=1;
			}
			for(int j=1;j<=26;j++){
				sum[i][j]=sum[i-1][j]+(j==(s[i]-'a'+1));
				if(sum[i][j]%2==1) a[i]++;
			}
		}
		for(int i=n;i>=1;i--){
			for(int j=1;j<=26;j++){
				if((sum[n][j]-sum[i-1][j])%2==1) b[i]++;
			}
		}
		for(int i=1;i<=n;i++){
			v[i]=(base*v[i-1]%mod+(s[i]-'a'+1))%mod;
		}
		l[0]=1;
		for(int i=1;i<=n;i++){
			l[i]=l[i-1]*base%mod;
		}
		for(int i=2;i<=n;i++){
			for(int j=a[i-1];j<=26;j++){
				vis[j]++;
			}
			for(int j=i;j<=n;j+=i){
				if(v[i]==(((v[j]-(v[j-i]*l[i]%mod))%mod)+mod)%mod){
					if(j<n) ans+=vis[b[j+1]];
				}
				else break;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=0;j<=26;j++){
				sum[i][j]=0;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

如何优化这个被卡成84的代码？我在这里分享一下考后为了通过这个题我用到的一些卡常技巧：

1.对于可以用$short$的数组用$short$。

2.尽量少$memset$。

3.哈希用自然溢出，实测比膜$10^9+7$快不少。

4.上面的代码是记$sum(i,j)$为$[1,i]$中$j$出现次数，维护这个是为了求前缀有几个数出现了奇数次。我们可以去掉第二维，用桶记录每个字母出现次数的奇偶性然后维护。

优化后的代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
using namespace std;
const ull base=131;
int t,n,ans=0,vis[30],r[30],tot=0;
short a[1050005],b[1050005],c[1050005],sum[1050005],sum1[1050005];
ull v[1050005],l[1050005];
char s[1050005];
signed main(){
	scanf("%lld",&t);
	l[0]=1;
	for(int i=1;i<=1050000;i++) l[i]=l[i-1]*base;
	while(t--){
		scanf("%s",s+1);
		n=strlen(s+1);
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(r,0,sizeof(r));
		memset(vis,0,sizeof(vis));
		memset(sum1,0,sizeof(sum1));
		ans=0;tot=0;
		for(int i=1;i<=n;i++){
			c[i]=s[i]-'a'+1;
			r[c[i]]^=1;
			if(r[c[i]]) sum[i]=sum[i-1]+1;
			else sum[i]=sum[i-1]-1;
			a[i]=sum[i];
		}
		memset(r,0,sizeof(r));
		for(int i=n;i>=1;i--){
			r[c[i]]^=1;
			if(r[c[i]]) sum1[i]=sum1[i+1]+1;
			else sum1[i]=sum1[i+1]-1;
			b[i]=sum1[i];
		}
		for(int i=1;i<=n;i++) v[i]=base*v[i-1]+1ull*c[i];
		for(int i=2;i<=n;i++){
			for(int j=a[i-1];j<=26;j++) vis[j]++;
			for(int j=i;j<n&&v[i]==v[j]-v[j-i]*l[i];j+=i) ans+=vis[b[j+1]];
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：滑稽的小宫 (赞：39)

## 一种不用扩展KMP的方法

~~当然KMP还是一定要用到的~~

### 预处理

根据题意，我们先做两个预处理：

设字符串长度为n

`pre[i][j]` 表示i位置及以前”有小于等于j个字符出现次数为奇数的位置”的数量

`sub[i]` 表示从i位置到n位置有多少个字符出现次数为奇数（即题中函数F）

为什么要求这两个数组？因为我们发现AB可以看做一个整体，如果确定了AB和重复次数，那么C也就确定了

相当于我们枚举如何把字符串分割为 $(AB)^i$ 和 $C$ 两部分，如果确定了C部分和AB部分的右端点，那么A的右端点就可以用 `pre` 数组得到

例如我钦定B部分的右端点为 `i`，C部分的左端点为 `j`，那么最终A可选择的位置数就是 `pre[i-1][sub[j]]`（注意还得给B至少留一个位置）

pre和sub数组的初始化方法如下：

```cpp
int odd=0,cnt=0;//odd状压记录，0为偶，1为奇，cnt记录数量
for(int i=1;i<=n;i++){
	if(odd&(1<<a[i]))cnt--;
	else cnt++;
	odd^=(1<<a[i]);
	for(int j=0;j<=26;j++)pre[i][j]=pre[i-1][j]+(j>=cnt);//每次的cnt都会对大于等于它的j有影响，见pre的定义
}odd=cnt=0;
for(int i=n;i>=1;i--){
	if(odd&(1<<a[i]))cnt--;
	else cnt++;
	sub[i]=cnt;//后缀记录
	odd^=(1<<a[i]);
}
```

### 计算每个循环节的贡献

现在我们考虑一下如何计算贡献

一个直观的想法是：我们可以把字符串每一个前缀尝试当一次 $AB$，计算这个前缀的Hash值，然后用倍增找这段最多能往后扩展多少个循环节

待会再考虑KMP优化，不妨先看看如果找到了循环节数量以后该怎么做：

假设我们枚举作为 $AB$ 的前缀为 $P=S_{1,i}$（即1到i的前缀），而且往后一共可以扩展 $sz$ 个循环节（包括P本身），如何计算贡献？

首先对于P自身，如果 $sz=1$，那么就可以直接向答案中累加 `ans+=pre[i-1][sub[i+1]]`（给B留至少一个位置所以减一，C从下一个位置开始看所以加一）

而如果 $sz=2$ ，那么显然我们不仅要算 $(AB)^1$ 的贡献 `pre[i-1][sub[i+1]]`，还要加上 $(AB)^2$ 的贡献 `pre[i-1][sub[i*2+1]]` (AB的长度没变，A能选的位置也没变，但C往后减少了一个AB循环节)

因此我们相当于需要计算：

`for(int k=1;k<=sz;k++)ans+=pre[i-1][sub[i*k+1]]`

但是在出现很多相同的数的数据里面， $sz$ 的值显然很大，我们能不能考虑另外的方法呢？

注意到在P固定而k增大的过程中，A可选的范围一直是 $[1,i-1]$，但C会不断减去 $P$，考虑一下C的sub值的变化：

首先，有以下两个结论：(F为题中函数)

- $F(P^2)=0$ 

- $F(AP^2)=F(A)$

1成立是因为两个相同字符串相接每个字符的出现次数一定都是偶数（*2了），2成立是因为奇数+偶数=奇数，偶数+偶数=偶数，不会改变奇偶性

推理到本题上就是：

$F(P^{sz}C)=F(P^{sz-2}C)$

所以不难发现：

当上面那个for循环中k为奇数时，对答案的贡献相同，都等于 `pre[i-1][sub[i+1]]`。

k为偶数时，对答案的贡献相同，都等于 `pre[i-1][sub[2*i+1]]`


经过试验，发现 $[1,sz]$ 中为偶数的数的个数为 $\lfloor \frac{sz}{2}\rfloor$ ，为奇数的数的个数为 $\lceil \frac{sz}{2}\rceil$

因此我们可以用以下式子直接计算当前前缀P对答案的贡献：

```cpp
int valodd=pre[i-1][sub[i+1]];
int valeven=sz>1?pre[i-1][sub[i*2+1]]:0;//特判一下防止下标越界
ans+=(ll)(((sz-1)>>1)+1)*valodd;//奇数情况（上取整）
ans+=(ll)(sz>>1)*valeven;//偶数情况（下取整）
```

好了，现在如果配套hash+倍增，就可以得到一个 $O(n\log n)$ 的算法，可是还是过不去qwq

因此我们有必要请出主角——KMP算法了：

### KMP 求循环节

KMP求循环节本身比较简单（请先掌握KMP算法的模板再看接下来的内容）：

由于KMP中的 `next[i]` 表示：$S_{1,next_i}=S_{i-next_i+1,i}$

因此如果 $i-next_i$ 能整除 $i$ ，那么相当于有如下的一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vqxb82fm.png)

这里面 $i=12,next_i=9$，那么前三个数不属于相同的那段后缀，但属于前缀的前三个，那么相同的那段长度为9的后缀的前三个也和前缀的前三个相同，这样一步一步往后推，如果正好整除，说明存在一个循环节为3，重复了 $\frac{i}{i-next_i}=4$ 次

实际上由于 $next_i$ 保证是小于i的最大的，因此找到的就是最小循环节。

代码：KMP找最小循环节：

```cpp
for(int i=2,j=0;i<n;i++){
	while(j&&a[j+1]!=a[i])j=nxt[j];
	if(a[j+1]==a[i])nxt[i]=++j;
	if(nxt[i]&&i%(i-nxt[i])==0)//找到了一个循环节，do sth.
}
```

但是这道题还不太一样，这道题中我们需要找到每一个前缀是否能往后构成循环节，如何转化呢？

我们不妨记录一下每个最小循环节最多能够往后推多少次，即用一个数组 `ma[i]`，表示长度为i的前缀作为最小循环节，最多可以往后推到什么位置

那么我们用上面的代码，在do sth的位置加上一句 `ma[i-nxt[i]]=i` 即可求出（i是递增的，不用写max）

然后考虑某一个最小循环节为前缀 $P_{1,i}$ 时：（sz函数代表它可以往后复制多少次（最高幂次））

$sz(P^k)=\frac{ma_i}{i\cdot k}$

意思就是说，既然P是最小循环节，那么所有能被这个最小循环节表示的前缀（P的k次方）也一定可以往后面推几个（P的k次方的）循环节（当然也有可能只能推1次）

所以就可以直接考虑新的 $sz$，然后套用上面第二步的公式即可：

```cpp
for(int i=2,j=0;i<n;i++){//n位置要留给C，不能算
	while(j&&a[j+1]!=a[i])j=nxt[j];
	if(a[j+1]==a[i])nxt[i]=++j;
	if(nxt[i]&&i%(i-nxt[i])==0)ma[i-nxt[i]]=i;//记录ma数组
}for(int i=2;i<n;i++){
	if(ma[i]/*自身就是最小循环节*/||(nxt[i]&&i%(i-nxt[i])==0&&ma[i-nxt[i]])/*能被某个最小循环节表示*/){
		int sz=(ma[i]?ma[i]:ma[i-nxt[i]])/i,valodd=pre[i-1][sub[i+1]];//这里的sz表示当前前缀还能往后拓展多少次,valodd和valeven意义同第二步
		int valeven=sz>1?pre[i-1][sub[i*2+1]]:0;
        //第二步的公式
		ans+=(ll)(((sz-1)>>1)+1)*valodd;
		ans+=(ll)(sz>>1)*valeven;
	}else ans+=pre[i-1][sub[i+1]];//如果不能被某个最小循环节表示，那么就按照sz=1的情况来算贡献。
}
```
最终的ans就是答案了。

时间复杂度：预处理 $O(NC)$，KMP和算贡献 $O(N)$，总的时间复杂度 $O(NC)$ （C为字符集大小）


---

## 作者：George1123 (赞：23)

更逊的体验 $\to $ [`George1123`](https://www.cnblogs.com/George1123/p/14092005.html)

---

## 题面

> [洛谷P7114 字符串匹配](https://www.luogu.com.cn/problem/P7114)

> $T$ 组测试数据。给定字符串 $S$，问有多少不同的非空字符串 $A$，$B$，$C$ 满足 $S=ABABAB...ABC$ 且 $A$ 中出现奇数次的字符数不多于 $C$。

> 数据范围：$1\le T\le 5$，$1\le |S|\le 2^{20}$。

---

这估计是我场上唯一做出来的题目了，[NOIP2020 游记](https://www.cnblogs.com/George1123/p/14091922.html) 也不放洛谷博客里了。

---

提供一个 $\Theta(n)$ 的做法，下标从 $0$ 开始。

求出 $S$ 的 `Z` 数组，$ze_i$ 表示满足 $s[0,ze_i)=s[i,i+ze_i)$ 的最大值。

根据 $s[0,ze_i)=s[i,i+ze_i)$ 可以推出 $s[i,ze_i)=s[2i,i+ze_i)$。

所以可以枚举 $AB$ 的长度 $i$，易得这个串在前缀重复了 $\lfloor\frac{ze_i}{i}\rfloor+1$ 次。

然后解决关于出现奇数次的字符的限制。

维护一个树状数组，表示每个 $j<i$ 的前缀出现奇数次字符数的集合。

计算前缀出现奇数次字符数可以 $\Theta(1)$，值域为字符集的树状数组时间复杂度也是 $\Theta(1)$ 的。

考虑对于当前的所有 $ABAB...AB$ 对应的 $C$ 中出现奇数次字符数：只有两种可能。

一种是当前后缀出现奇数次字符数，一种是全局出现奇数次字符数。先预处理后者，前者可以 $\Theta(1)$ 维护。

因为 $ABAB$ 中出现奇数次字符数肯定为 $0$，所以对于 $\lfloor\frac {\lfloor\frac{ze_i}{i}\rfloor+1}{2}\rfloor$ 的肯定是全局次数，$\lceil\frac {\lfloor\frac{ze_i}{i}\rfloor+1}{2}\rceil$ 的肯定是后缀次数。

然后对于两种情况，答案加上树状数组查询前缀满足条件的 $A$ 的数量乘以出现次数即可。

所以总时间复杂度 $\Theta(n)$。

---

## 代码

回家手敲的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
#define x first
#define y second
#define bg begin()
#define ed end()
#define pb push_back
#define mp make_pair
#define sz(a) int((a).size())
#define R(i,n) for(int i(0);i<(n);++i)
#define L(i,n) for(int i((n)-1);i>=0;--i)
const int iinf=0x3f3f3f3f;
const ll linf=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1<<20,C=26;
int n,all,last,now,tot[C],cnt[C];
string str;

//FenwickTree
int fen[C|1];
void add(int i,int v){for(;i<C+1;i|=i+1) fen[i]+=v;}
int sum(int i,int v=0){for(;i>=0;(i&=i+1)--) v+=fen[i]; return v;}

//Zebra
int ze[N];
void zebra(){
    int l=0;
    R(i,n) ze[i]=0;
    R(i,n)if(i){
        if(l+ze[l]>i) ze[i]=min(l+ze[l]-i,ze[i-l]);
        while(i+ze[i]<n&&str[ze[i]]==str[i+ze[i]]) ze[i]++;
        if(i+ze[i]>l+ze[l]) l=i;
    }
}

//Main
void Main(){
    cin>>str,n=sz(str),zebra();
    R(i,n)if(i+ze[i]==n) ze[i]--;
    ll ns=all=last=now=fen[C]=0;
    R(c,C) tot[c]=cnt[c]=fen[c]=0;
    R(i,n) tot[str[i]-'a']++;
    R(c,C) all+=(tot[c]&1); last=all;
    R(i,n){
        if(tot[str[i]-'a']&1) last--; else last++;
        if(cnt[str[i]-'a']&1) now--; else now++;
        tot[str[i]-'a']--,cnt[str[i]-'a']++;
        if(i&&i<n-1){
            int t=ze[i+1]/(i+1)+1;
            // cout<<"i="<<i<<" t="<<t<<'\n';
            ns+=1ll*(t/2)*sum(all)+1ll*(t-t/2)*sum(last);
        }
        // cout<<"now="<<now<<" last="<<last<<" all="<<all<<'\n';
        add(now,1);
    }
    cout<<ns<<'\n';
}
int main(){
    //freopen("string.in","r",stdin);
    //freopen("string.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int T; cin>>T;
    while(T--) Main();
    return 0;
}
```

---

**祝大家学习愉快！**

---

## 作者：derta (赞：22)

首先考虑暴力：令 $T=AB$，从小到大枚举 $T$ 的长度，找到**最短的** $C_1$，枚举有多少个 $T$ 的真前缀 $A$ 满足 $F(A) \leqslant F(C_1)$，之后令 $C_2=ABC$，再令 $C_3=ABABC$……以此类推

然后我们发现 $F(S)$ 比较~~诡异~~特殊，考虑从它来优化。结合上面的暴力分析，容易想到 $F(C_k)$ 的前面的所有 $ABAB$ 均不会对其产生贡献，故有 $F(C_{2n-1})=F(C_1)$，$F(C_{2n})=F(C_2)$

所以，$A,B,C$ 是一组解就意味着 $A,B,ABABC$ 也是一组解（如果 $AB$ 的重复次数 $\geqslant 3$），那么我们无需枚举所有的 $C_k$，而只需计算 $C_1$ 与 $C_2$ 解的数量，再分别乘上有多少 $C_k$ 与其相同即可

最后我们发现时间复杂度的瓶颈在于找到最短的 $C$，看出这个问题本质是求 $T$ 的最大重复次数，使用字符串 Hash 即可

此算法是 $n (\ln n+\log_2 26)$ 的

具体实现还有一（很）些（多）细节，参见代码

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
typedef unsigned long long ULL;
const ULL MAXN = (1 << 20) + 5, BASE = 2017;
char s[MAXN]; // 读入的字符串 
int t, len; // t为数据组数，len为字符串长度 
ULL h[MAXN]; // h[i]表示   长度为i的前缀 的Hash值 
int jcnt, djcnt[MAXN]; // jcnt表示F(T)，djcnt[i]表示 F(S_i至S_n组成的字符串) 
bool isj[30], disj[30]; // （i从0开始）isj[i]表示第i个字母出现奇数次是true/false，disj[i]意义与isj[i]相同，但为倒序更新 
ULL ans; // 答案 
//int cnt[30]; // cnt[i]表示有i个字母出现奇数次的T的真前缀的数量 
int bit[30]; // 表示由cnt[i]构成的树状数组 

inline int lowbit(int x)
{ return x & (-x); }

void update(int x) {
	++x; //树状数组不能处理下标为0的情况，故“平移”一位 
	while(x <= 27) {
		++bit[x];
		x += lowbit(x);
	}
}

int sum(int x) {
	++x;
	int s = 0;
	while(x >= 1) {
		s += bit[x];
		x -= lowbit(x);
	}
	return s;
}
// 手写读入，返回读入字符串的长度
// （但好像并没有什么卵用 
int input(char* s) {
	char c = getchar();
	int i = 0;
	while(!islower(c))
		c = getchar();
	while(islower(c)) {
		s[++i] = c;
		c = getchar();
	}
	return i;
}

int main() {
//	freopen("string.in", "r", stdin);
//	freopen("string.out", "w", stdout);
	scanf("%d", &t);
	while(t--) {
		len = input(s);
		djcnt[len] = 1; // 最后一个字符重复了一次（奇数次） 
		disj[s[len] - 'a'] = 1; // 最后一个字符出现奇数次=true 
		for(int i = len - 1; i >= 1; --i) //预处理djcnt[i]以快速计算C 
			djcnt[i] = djcnt[i + 1] + ((disj[s[i] - 'a'] = !disj[s[i] - 'a']) == 1 ? 1 : -1);
		h[1] = s[1] - 'a'; // 第1个字符的Hash值 
		for(int i = 2; i <= len; ++i) // 递推计算Hash值 
			h[i] = h[i - 1]*BASE + s[i] - 'a';
		ULL a = BASE*BASE;
		update(1); // 第一个字符重复了一次（奇数次） 
		isj[s[1] - 'a'] = 1; // 第一个字符出现奇数次=true 
		jcnt = 1; // 有一个字符出现奇数次 
		for(int i = 2; i < len; ++i) { // 循环从2开始（否则A,B中必有一空串）到len-1结束（否则C为空串） 
			int x = 1; // T的循环次数 
			for(int j = (i << 1); j <= len; j += i) {
				/* e.g.
				 * h[i]: abc
				 * h[j - i]:          abcabc
				 * h[j]:              abcabc???
				 * h[j - i]*a:        ---abcabc
				 * h[j] - h[j - i]*a: abc
				 * 容易发现只有???=abc才有h[j] - h[j - i]*a == h[i] 
				 */
				if(h[j] - h[j - i]*a == h[i])
					++x;
				else
					break;
			}
			// 后面四行是计算A,B,C的情况 
			if(x*i == len) //此时x*i+1=len+1，由于我没有清空djcnt所以不能把djcnt[len+1]视为0，故不能沿用else情况的代码 
				ans += 1ULL*bit[1]*((x - 1) >> 1); // C不能是空串，故比else的情况少一个C 
			else
				ans += 1ULL*sum(djcnt[x*i + 1])*((x + 1) >> 1); // C_1,C_3,...,C_k（k为奇数且<=x）都可以 
			// 后面一行是计算A,B,ABC的情况 
			ans += 1ULL*sum(djcnt[(x - 1)*i + 1])*(x >> 1); // C_2,C_4,...,C_k（k为奇数且<=x）都可以 
			update((isj[s[i] - 'a'] = !isj[s[i] - 'a']) ? ++jcnt : --jcnt); // 注意这里要在计算后更新，否则B可能会为空串 
			a *= BASE; //T的长度增加，a也要随之增加 
		}
		printf("%llu\n", ans);
		memset(disj, 0, sizeof(disj));
		memset(isj, 0, sizeof(isj));
		memset(bit, 0, sizeof(bit));
		ans = 0;
	}
	return 0;
}
```

---

## 作者：ZCETHAN (赞：15)

[题目传送门](https://www.luogu.com.cn/problem/P7114)
# 分析
题目要求原字符串可以分解成多少种$(AB)^iC$的形式，该式子的意义见题面。

如果不考虑那个奇怪的奇偶限制，那么应该怎么做?

首先有两种想法，肯定是先枚举一部分，然后通过一些~~奇怪的~~优化来解决。
比较方便的做法，就是枚举$AB$，这样可以在之后找循环节来解决，然后确定$C$，而接下来的问题就是我需要知道循环节。
于是正解用$exKMP$，于是……
>大炮打蚊子---by xinjun

于是参照了字符串的题目，想到哈希。
我可以预处理出到每个位置的哈希值，然后用前缀和的方式将它求出每一段的哈希值，可以$O(1)$比较两段字符串是否相等。可以快速地找循环节。
比如我当前枚举的$AB$，那么在$AB$后面的等长的哈希值判一判就可以了。

解决上述问题后，可以来看奇偶的限制了。

首先很简单可以得出：$A$是整个串的前缀，$C$是整个串的后缀，可以预处理出每个位置前后缀的奇偶，然后进行判断。
看似好像解决了吼，但是！会遇到这种情况：有多个循环节，但是我可以把最后一个循环节算成$C$，这似乎也是可以的。如果不考虑奇偶，就是循环节的个数，但是考虑了奇偶之后就显得麻烦了。（这里添一嘴，我一开始想过为什么不要考虑把循环节合并后又是几个循环节的情况，但是我枚举的是循环节的长度，两个或者几个合并就不在当前的枚举范围内，之后会算进去的）

那么我们不妨将之情形展示一下，比如，我当前判断$(AB)^iC$合法，奇偶也合法，那么$(AB)^{i-1}ABC$是否合法呢？不知道，因为$B$的奇偶性我不知道，之前的判定是依靠前缀的奇偶来解决$A$的奇偶，如果再判$B$的显然会超时，那怎么办？(你可能会说可以用从最后一个$A$的后缀情况解决，但是可以试试，这也是需要枚举的，在没有下面的结论之前，是无法很好地解决的。)

别急，继续拆一个，$(AB)^{i-2}ABABC$是否合法？合法，并且一定合法(这是建立在$(AB)^iC$已经合法的基础上的。)。为什么？因为$ABAB$一定每个字母都出现偶数次，对后缀的奇偶不产生影响。

所以定义函数$odl(S)$表示$S$的奇偶性，则$odl(S)=odl(AAS)$。
所以只要判断后缀就可以推广至全部了。

最后一个问题，枚举了$AB$后，无法确定$A,B$的分割点。确切地说，枚举了一个串$S$，但是这个$S$可以有很多种方式拆成$A$和$B$的形式，因此我们需要枚举$A$，然后判断是否合法。
结果超时了。那么结果怎么办？诶发现字母是只有26个的，我可以存一下到目前为止，每个出现奇数次字母个数相等的前缀个数，即用$t[i]$表示前几个前缀中有多少个出现奇数次字母个数是$i$个的。然后对于每个后缀，都枚举一遍比它小的个数，直接加在$ans$中即可。

# 代码
$\color{Red}{PS}$:本代码可能存在姿势不好等问题，OJ不稳定的时候可能会$\color{Red}{TLE}$，希望各位自己写，仅仅提供参考。

~~或者趁OJ不注意，卡过去，我就是这么在luogu上过的233，以后发誓再(yi)也(ding)不(yao)卡评测。~~

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
using namespace std;
const int MAXN=(1<<20)+100;
const int B=499;
char s[MAXN];

ull h[MAXN],base[MAXN];//ull自动溢出
ull geth(int l,int r){return h[r]-h[l-1];}

int odp[MAXN],odl[MAXN],cnt[30],t[30];
//odp是前缀奇数个数odd_pre
//同理odd_last
int main()
{
//	freopen("string.in","r",stdin);
//	freopen("string.out","w",stdout);
	int T,len;
	scanf("%d",&T);
	while(T--){
		scanf("%s",s+1);
		len=strlen(s+1);
		
		base[1]=1;h[0]=0;
		for(int i=1;i<=len;i++){
			h[i]=base[i]*s[i]+h[i-1];
			base[i+1]=base[i]*B;
		}
		
		memset(cnt,0,sizeof(cnt));
		odp[0]=0;
		for(int i=1;i<=len;i++){
			odp[i]=odp[i-1];
			if(cnt[s[i]-'a']&1) odp[i]--;
			else odp[i]++;
			cnt[s[i]-'a']++;
		}
		memset(cnt,0,sizeof(cnt));
		odl[len+1]=0;
		for(int i=len;i>=1;i--){
			odl[i]=odl[i+1];
			if(cnt[s[i]-'a']&1) odl[i]--;
			else odl[i]++;
			cnt[s[i]-'a']++;
		}
		
		memset(t,0,sizeof(t));
		ll ans=0;t[1]=1;
		for(int x=2;x<len;x++){
			int tm=0,st=0;
			ull cur=geth(1,x);
			while(geth(st+1,st+x)==cur*base[st+1]&&st+x<len) tm++,st+=x;//不断向后找
			st-=x;
			for(int i=odl[st+x+1];i>=0;i--) ans+=((tm+1)/2)*t[i];
			for(int i=odl[st+1];i>=0;i--) ans+=(tm/2)*t[i];
			t[odp[x]]++;
		}printf("%lld\n",ans);
	}
}
```
# END
大家可以去你谷上看看卡常技巧，毕竟不是正解。
不过这题这样的思维是真心不错！！

---

## 作者：FZzzz (赞：12)

~~2020 年 12 月 5 日……学习字符串……30min……折戟沉沙……以前的我！（大雾）~~

昨天躺床上无聊想出来这题的一个巨大扭曲做法，丢上来分享一下。

------------
首先如果你考虑枚举 $C$ 那你一开始就走偏了，我们枚举 $AB$……诶我偏不，咱就枚举 $C$ 试一下？

枚举 $C$ 就相当于枚举了 $(AB)^k$，可能的 $AB$ 都是这个串的整循环节。根据 border 理论那一套（这里就不给证明了），$m$ 是 border 代表 $n-m$ 是周期，而一个整循环串的最小周期必然是最小整周期。那么可以 kmp 求出每个前缀的最小整周期。又有弱周期定理（WPL），若 $a$ 和 $b$ 都是周期且 $a+b\le n$ 则 $\gcd(a,b)$ 是周期。那么可以推知所有周期都是这个最小周期的倍数，否则导出更小的周期。

那么设最小循环节长度为 $x$，考虑若有一个合法的 $A$，$x(i-1)\le|A|<xi$，那么合法的 $AB$ 个数即为 $k$ 的倍数中不小于 $i$ 的个数。而发现对于一个 $i$，这样合法的 $A$ 的个数只与 $i$ 的奇偶性有关，那么可以对 $i$ 的两种奇偶性分别树状数组 $O(n\log|\Sigma|)$ 算出这样合法的 $A$ 的个数，严格 $O(n)$ 也是可以的其他题解说过这个事情我就不讨论了。

那么考虑对两种 $i$ 的奇偶性分别计算所有 $A$ 对应的合法 $AB$ 的总个数。考虑 $k$ 的每个因数 $d$，若 $d$ 是偶数则 $d$ 被计算了 $\dfrac12d$ 次，否则若 $i$ 是奇数则是 $\dfrac12d+\dfrac12$，若 $i$ 是偶数则是 $\dfrac12d-\dfrac12$ 次。那么发现我们只需要计算每个数的约数个数，约数和，奇约数个数。前两者容易线性筛，后者其实就是 $d(n)-[2|n]d(\dfrac12n)$，$d$ 这里代表约数个数函数。

最后在 $1$ 是奇数且 $|A|=x(i-1)$ 时 $A$ 是空串需要特判一下，特判的式子跟上面差不多不写出来了。然后你发现这题就做完了，复杂度还是 $O(n\log|\Sigma|)$ 或者 $O(n)$。

线性筛太折磨了写了个调和级数筛日过去了……
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll readint(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=(1<<20)+5;
int d0[maxn],dd[maxn];
ll d1[maxn];
int n;
char s[maxn];
int nxt[maxn];
int cnt[26];
struct qr{
	int x;
	ll k;
};
vector<qr> q[maxn];
inline int lowbit(int x){
	return x&-x;
}
int c[27];
void modify(int x,int k){
	while(x<=26){
		c[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x){
	int s=0;
	while(x){
		s+=c[x];
		x-=lowbit(x);
	}
	return s;
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	for(int i=1;i<maxn;i++) for(int j=1;i*j<maxn;j++){
		d0[i*j]++;
		d1[i*j]+=i;
	}
	for(int i=1;i<maxn;i++) dd[i]=d0[i]-(i%2==0?d0[i/2]:0);
	int T=readint();
	while(T--){
		scanf("%s",s+1);
		n=strlen(s+1);
		int u=0;
		for(int i=2;i<=n;i++){
			while(u&&s[u+1]!=s[i]) u=nxt[u];
			if(s[u+1]==s[i]) u++;
			nxt[i]=u;
		}
		int cnt2=0;
		for(int i=1;i<=n;i++) vector<qr>().swap(q[i]);
		ll ans=0;
		memset(cnt,0,sizeof(cnt));
		for(int i=n-1;i>0;i--){
			cnt[s[i+1]-'a']++;
			cnt2+=cnt[s[i+1]-'a']%2==1?1:-1;
			int x=i%(i-nxt[i])==0?i-nxt[i]:i;
			q[x-1].push_back({cnt2,(d1[i/x]+dd[i/x])/2});
			if(x!=i){
				q[x-1].push_back({cnt2,(dd[i/x]-d1[i/x])/2});
				q[x*2-1].push_back({cnt2,(d1[i/x]-dd[i/x])/2});
				ans+=(d1[i/x]-dd[i/x])/2-d0[i/x]+dd[i/x];
			}
		}
		memset(cnt,0,sizeof(cnt));
		memset(c,0,sizeof(c));
		cnt2=0;
		for(int i=1;i<n;i++){
			cnt[s[i]-'a']++;
			cnt2+=cnt[s[i]-'a']%2==1?1:-1;
			modify(cnt2+1,1);
			for(qr x:q[i]) ans+=1ll*query(x.x+1)*x.k;
		}
		printf("%lld\n",ans);
	}
	#ifdef LOCAL
	fprintf(stderr,"%d\n",(int)clock());
	#endif
	return 0;
}
```
我感觉这个做法巨大扭曲，不知道为什么混进来一点数论内容。直觉上整循环次数的约数应该有更优美的性质，有没有好一点的做法把这玩意去掉啊。

~~有 没 有 老 哥 教 教 我 啊~~

~~感觉是第一万次说这句话了，蒋队这样真正的强者都是自己搞清楚两个牛逼做法的联系的。~~

---

## 作者：囧仙 (赞：12)

## 题目大意

- $T$ 组数据。每组数据给出一个字符串 $S$ ，询问它可以表示成多少种形如 $(AB)^kC$ 的形式，满足 $A$ 中出现**奇数次**的字符个数小于 $C$ 中出现**奇数次**的字符个数。

- 其中 $(AB)^k=\underbrace{AB\cdots AB}_{k \text{个}}$ 。要求 $k\ge 1$ ，且 $A,B,C$ **非空**。

## 题解

> $\rm upd.2020.12.6$ 新增了一个亚 $\log$ 做法，最大的点只需要 $270\text{ms}$ 了。

先想一个 $\mathcal O(tnH(n)+tn|\Sigma|)$ 的做法（其中 $H(n)$ 为调和级数， $H(n)=\sum_{i=1}^n \frac{1}{i}$ 。）

由于题面上给出的形式可以简要拆成两块 $AB,C$ ，所以我们可以枚举其中一部分。

- 观察到， $AB$ 必然是 $S$ 的前缀。我们考虑将 $AB$ 作为整体枚举它的长度 $i$ ，并枚举它的循环节数 $k$ 。

- 显然，我们可以用字符串哈希判断同一个字符串的两个字串是否相等。具体而言，我们设 $T_i=T_{i-1}\times P+S_i$ ，那么满足如下条件时，我们认为两个子串 $S_{a..b},S_{s..t}$ 相等：

$$\frac{T_b-T_{a-1}}{P^{a-1}}=\frac{T_t-T_{s-1}}{P^{s-1}}\Leftrightarrow (T_b-T_{a-1})\times P^{s}=(T_t-T_{s-1})\times P^a$$

枚举完了所有的 $AB$ 以及 $k$ ，我们能够计算出相对应的 $C$ 。现在考虑处理 $AB$ 中的 $A$ 。

- 显然，我们只关心 $A$ 中出现奇数次的字符的个数，而不需要考虑它里面有哪些字符。所以我们能用数组 $N_x$ 存储出现 $x$ 次奇数字符的 $A$ 的个数。由于我们从小到大枚举 $AB$ 的长度 $i$ ，因此第 $i$ 个 $N_x$ 就是在 $i-1$ 的基础上增加了 $S_{1..i-1}$ 这样一种可能的 $A$ 。

- 我们刚刚已经枚举出了所有的 $C$ 。这时统计一下 $C$ 中奇数字符的个数 $t$ ，答案加上 $\sum_{j=1}^k N_j$ 就行了。

如何统计一个字符串中的奇数次字符的数量？

- 事实上，由于字符集 $|\Sigma|=26$ ，所以我们可以用**二进制压缩**的方法，将每个字符看作一位。这样子新增加字符，就相当于**异或**上了它所对应的二进制位（因为偶数次的 $1$ 异或后为 $0$ ，奇数次为 $1$ ）。出现奇数次的字符个数就是为 $1$ 的二进制位的个数。

- 此外，由于 $\text{CCF}$ 不能用 $\text{C++11}$ 新增的 $\verb!<bit>!  $ ，所以我们要手写 $\verb!pop_count!$ 函数（用于统计二进制位中 $1$ 的个数）。一种简便的做法如下：

  - 先计算出 $0\sim 255$ 的每个数字的 $1$ 的个数 $T_i$ 。（显然，有递推式 $T_i=T_{\lfloor i\div 2\rfloor}+(i \operatorname{and} 1)$ ）。
  
  - 每个 $32$ 位整数可以用位运算拆成 $4$ 段（具体可以看代码），分别统计再求和即可。复杂度约为 $\mathcal O(4)$ 。

当然，我们还可以用一些优化。

- 显然，枚举的 $C$ 的数量可能比较多（最多 $\left\lfloor\dfrac{n}{i}\right\rfloor$ 个），所以我们用 $N_x$ 的前缀和 $M_x$ 进行优化。复杂度降至 $\mathcal O(tnH(n)+tn|\Sigma|)$ 。

- 输入量较大，建议用 $\verb!getchar!$ 之类。
  
要记得最大数据 $|S|\le 2^{20}$ 而不是 $10^6$ ，不要开小空间。可能这个做法有点卡常（在机器上极限数据要 $1.5s$ ，洛谷要 $0.7\sim 0.9s$ 左右），注意常数大小。
  
---
  
什么？你担心 $\mathcal O(tnH(n))$ 做法不够块，会被卡常？这里提供一个更块的做法。
  
观察到，上述做法的瓶颈就在于循环节的查询。事实上，我们能够**倍增优化**。
  
- 假如我们已经发现了循环次数至少为 $k$ 。那么我们只要比较 $S_{1..i\times k}$ 与 $S_{i\times k+1..i\times 2\times k}$ 就能判断循环次数能否达到 $2\times k$ 。
  
- 对于不是 $2$ 的次幂的循环次数，我们也能如法炮制。先找到最大的 $k_m=2^s$ 使得循环节长度不小于 $k_m$ 。从 $k_m$ 枚举，每次折半，判断接下来 $i\times k$ 个字符与字符串开头的 $i\times k$ 的字符相同（使用字符串哈希）。这样复杂度就更低了。
  
- 搜寻长度为 $i$ 的 $AB$ 出现了多少次，从 $\mathcal O(\frac{n}{i})$ 优化到了 $\mathcal O(\log\frac{n}{i})$ 。

此外，前缀和部分可以用树状数组优化。从单次 $\mathcal O(|\Sigma|)$ 优化到 $\mathcal O(\log |\Sigma|)$ 。

复杂度比较玄学，大概长这样：
  
$$t\times \left(\sum_{i=1}^n \log\left\lfloor\frac{n}{i}\right\rfloor+n\log|\Sigma|\right)$$
  
显然，它是可以通过极限数据的。
  
## 参考代码
  
```cpp
//第一版
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef unsigned int u32;
typedef long long    i64;
typedef unsigned long long u64;
i64 qread(){
	i64 r=0,w=1; char c;
	while(!isdigit(c=getchar())) w=(c=='-'?-1:1); r=c-'0';
	while( isdigit(c=getchar())) r=r*10+c-'0';
	return r*w;
}
const int MAXN =(1<<20)+3,P=13331;
u64 H[MAXN],T[MAXN],N[30],ans; int C[256+3],W[MAXN],n,m=MAXN-1,t,c; char S[MAXN];
int ppc(int x){	//pop_count
	return C[(x>>24)&255]+C[(x>>16)&255]+C[(x>>8)&255]+C[x&255];
}
int main(){
	up(0,255,i) C[i]=C[i>>1]+(i&1); T[0]=1; up(1,m,i) T[i]=T[i-1]*P;
	dn(qread(),1,TTT){
		while(!isalpha(c=getchar())); S[++n]=c;
		while( isalpha(c=getchar()))  S[++n]=c;
		up(1,n,i) W[i]=W[i-1]^(1<<(S[i]-'a')),H[i]=H[i-1]*P+S[i];
		t=ppc(W[n]);
		up(1,n-1,i){
			int w=W[i],_w=W[n]^W[i],a=ppc(_w),b=t;
			if(i>1) for(int j=1;i*j<n;++j){
				if(H[i*j]-H[i*j-i]==H[i]*T[i*j-i]) ans=ans+N[(j&1)?a:b];
				else break;
			}
			up(ppc(w),26,j) ++N[j];
		}
		printf("%llu\n",ans),ans=n=0;
		memset(N,0,sizeof(N));
	}
	return 0;
}
//优化版
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef unsigned int u32;
typedef long long    i64;
typedef unsigned long long u64;
i64 qread(){
    i64 r=0,w=1; char c;
    while(!isdigit(c=getchar())) w=(c=='-'?-1:1); r=c-'0';
    while( isdigit(c=getchar())) r=r*10+c-'0';
    return r*w;
}
const int MAXN =(1<<20)+3,P=13331,MAXM=26+3;
u64 H[MAXN],T[MAXN],ans; int C[256+3],W[MAXN],n,m=MAXN-1,t,c; char S[MAXN];
int ppc(int x){ //pop_count
    return C[(x>>24)&255]+C[(x>>16)&255]+C[(x>>8)&255]+C[x&255];
}
u64 O[MAXM];
void add(int x){++x; while(x<MAXM) ++O[x],x+=x&-x;}
int  qry(int x){++x; int r=0; while(x) r+=O[x],x-=x&-x; return r;}
int main(){
    up(0,255,i) C[i]=C[i>>1]+(i&1); T[0]=1; up(1,m,i) T[i]=T[i-1]*P;
    dn(qread(),1,TTT){
        while(!isalpha(c=getchar())); S[++n]=c;
        while( isalpha(c=getchar()))  S[++n]=c;
        up(1,n,i) W[i]=W[i-1]^(1<<(S[i]-'a')),H[i]=H[i-1]*P+S[i];
        t=ppc(W[n]);
        up(1,n-1,i){
            int w=W[i],_w=W[n]^W[i],a=ppc(_w),b=t,k,p;
            for(k=1; ;k<<=1) if(i*k*2>=n||H[i*2*k]-H[i*k]!=H[i*k]*T[i*k])  break;
            for(p=k;k;k>>=1) if(i*(p+k)<n&&H[i*(p+k)]-H[i*p]==H[i*k]*T[i*p]) p+=k;
            ans=ans+(p+1)/2*qry(a)+p/2*qry(b),add(ppc(w));
        }
        printf("%llu\n",ans),ans=n=0;
        memset(O,0,sizeof(O));
    }
    return 0;
}
```

---

## 作者：Leap_Frog (赞：10)

UPD : 补充一份考场代码
### Description.
给定 $S$ 求 $S=(A+B)^i+C$ 且 $F(A)\le F(C)$ 的方案数。  
$F(s)$ 表示 $s$ 中出现次数为奇数的字符数量。  

### Solution1（84pts？
暴力枚举 $C$ 的长度，然后我们设 $X=A+B$，我们需要求出 $X^i+C=S$ 的方案数。  
也就是找出一个字符串的最小循环节。  
这是经典问题，直接 Hash + 枚举因数就好了，具体可以看[这里](https://www.luogu.com.cn/blog/daniu/solution-p3538)  
然后我们需要求出把 $X$ 拆分成一个 $A+B$ 。  
因为 $A$ 肯定是一个 $S$ 的前缀，所以我们可以直接暴力预处理出 $F_{i,j}$  
（设 $F_{i,j}$ 表示 $1$ 到 $i$ 中的所有前缀出现次数为奇数的字符数量，这个东西显然可以二维前缀和，复杂度 $O(26\times N)$  
上面的最小循环节是 $O(N\log N)$ 的，而我们又需要对于每个 $C$ 枚举 $i$。  
而此时 $i$ 必须满足 $mxlen_X\ |\ i\ |\ len_X$ （ $mxlen_X$ 表示字符串 $X$ 的最小循环节。  
所以我们最终复杂度是 $\sum_{i=1}^{N}\sum_{j|i}1$ 的。  
这个东西应该是 $O(N\log N)$ 的。  
总复杂度 $O(N\times (\log N+26))$ 的。  
如果写棵树状数组的话应该可以 $O(N\log N\log 26)$  
~~话说我在考场上甚至忘了这个怎么算，直接打了个大爆搜发现是 1e7 左右~~  
贴一个考场 84 分代码。  
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<48||c>57;c=getchar()) if(!(c^45)) f=1;
	for(;c>=48&&c<=57;c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x:0;
}
const int N=1048585;
struct Hash
{
	typedef unsigned long long ull;ull has1,has2;
	inline bool operator==(Hash b) const {return has1==b.has1&&has2==b.has2;}
	inline Hash operator+(Hash b) const {return(Hash){has1+b.has1,has2+b.has2};}
	inline Hash operator-(Hash b) const {return(Hash){has1-b.has1,has2-b.has2};}
	inline Hash operator*(Hash b) const {return(Hash){has1*b.has1,has2*b.has2};}
	inline Hash operator*(ull x) const {return(Hash){has1*x,has2*x};}
	inline Hash operator+(ull x) const {return(Hash){has1+x,has2+x};}
}B={149ull,1145141ull},has[N],bas[N];int qwq[1005],qaq[1005],qwqt=0;
int Q,n,pc,p[N],ls[N],st[N],tp,f[N][26];char v[N],a[N];
inline void AllInit()
{
	v[0]=v[1]=1,ls[1]=1;
	for(int i=2;i<N;i++)
	{
		if(!v[i]) p[++pc]=i,ls[i]=i;
		for(int j=1;j<=pc&&p[j]*i<N;j++) {v[i*p[j]]=1,ls[i*p[j]]=p[j];if(i%p[j]==0) break;}
	}
}
inline Hash geths(int l,int r) {return has[r]-bas[r-l+1]*has[l-1];}
inline int getmn(int l,int r)//最小循环节
{
	int len=r-l+1;tp=0;
	while(len!=1) st[++tp]=ls[len],len/=ls[len];
	len=r-l+1;for(int i=1;i<=tp;i++)
	{
		int nxt=len/st[i];
		if(geths(l,r-nxt)==geths(l+nxt,r)) len=nxt;
	}
	return len;
}
inline void InitHash()
{
	bas[0]=(Hash){1ull,1ull},has[0]=(Hash){0ull,0ull};
	for(int i=1;i<=n;i++) bas[i]=bas[i-1]*B,has[i]=has[i-1]*B+a[i];
}
inline void InitF()
{
	int now=0,bit=0;memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)
	{
		if(bit&(1<<(a[i]-'a'))) now--;else now++;
		bit^=(1<<(a[i]-'a')),f[i][now]=1;
	}
	for(int i=1,j=0;i<=n;i++) f[i][j]+=f[i-1][j];
	for(int i=1;i<=n;i++) for(int j=1;j<26;j++) f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
}
inline void ChaiFen(int now,int ggg,long long &x,int hzlim,int tims)
{
	if(now==qwqt+1) return(void)(x+=f[tims*ggg-1][hzlim]);//,printf("F %d %d\n",tims*ggg-1,hzlim)
	for(int i=0;i<=qaq[now];i++) ChaiFen(now+1,ggg,x,hzlim,tims),ggg*=qwq[now];
}
inline void solve()
{
	scanf("%s",a+1),n=strlen(a+1),InitHash(),InitF();
	int bit=0,now=0;long long res=0;
	for(int i=n;i>2;i--)
	{
		if(bit&(1<<(a[i]-'a'))) now--;else now++;
		bit^=(1<<(a[i]-'a'));int nown=i-1,nowlen=getmn(1,nown);
		tp=0;int bf=nown/nowlen;
		while(bf!=1) st[++tp]=ls[bf],bf/=ls[bf];
		sort(st+1,st+tp+1),qwqt=0;
		for(int j=1;j<=tp;j++) if(st[j]!=st[j-1]) qwq[++qwqt]=st[j],qaq[qwqt]=1;else qaq[qwqt]++;
//		for(int j=1;j<=qwqt;j++) printf("<%d,%d>%c",qwq[j],qaq[j],j==qwqt?'\n':' ');
		ChaiFen(1,1,res,now,nowlen);
//		printf("%d : %lld\n",i,res);
	}
	printf("%lld\n",res);
}
int main()
{
	freopen("string.in","r",stdin);
	freopen("string.out","w",stdout);
	AllInit();
	for(read(Q);Q--;) solve();
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```
### Solution2（84pts？
首先，这个出现次数为奇数这个条件很烦人，所以我们观察一下它有没有特殊性质。  
首先，我们思考一下，一个串 $XX$ 它不会影响出现次数为奇数的个数。  
所以，我们发现 $XXXC=S$ 和 $XC=S$ 的把 $X$ 拆分成 $A+B$ 的方案数是一样呢的。  
那么我们可以奇偶分开讨论，把上面的那个 $\times log26$ 或 $+26$ 去掉了。  
复杂度 $O(N\ln N)$
### Solution3（100pts？
鸣谢神仙 $\color{black}\text{h}\color{red}\text{ehezhou}$。  
首先我们暴力枚举 $X$ 的长度 （$X=A+B$  
然后对于每个长度，我们二分它 $i$ 能取到的最大值。  
因为长度越长这个字符串越不可能循环，所以具有单调性。  
上面的东西是 $\sum_{i=1}^{N}\log\left(\frac{N}{i}\right)$ 的。  
据神仙 $\color{black}\text{h}\color{red}\text{ehezhou}$ 说是 $O(N)$ 的。  
我们获得了每个 $X$ 所能取到的最大 $i$ 的长度。  
同时，当 $X$ 固定时，当 $i\in\{1,3,5...\}$ 或 $i\in\{2,4,6...\}$ 时，把 $X$ 拆成 $A$ 和 $B$ 的方案数是一样的，所以我们可以 $O(1)$ 统计贡献。  
然后枚举 $X$，在 $X$ 改变时只需要计算增加的那个 $X$ 的贡献就好了。  
复杂度均摊 $O(N\log 26)$。  
***
**upd:**
感谢 神仙 $\color{black}\text{h}\color{red}\text{ehezhou}$ 指出，在统计 $X$ 时必须要 $\log26$，所以复杂度还是 $O(N\log 26)$ 的，已改正。  
**upd:**
艹，神仙 $\color{black}\text{h}\color{red}\text{ehezhou}$ 要加强 T2 和 T4，把 T2 字符集开成 $O(n)$，T4 用复杂度为 $nk\log^2$ 的多项式。  


完结撒花，反正笔者只会 solution1，还不知道有没有打挂

---

## 作者：Azazеl (赞：8)

闲话：考场上想到了 $\texttt{100pts}$ 的思路，然后自己想多了加了个不必要的优化然后 WA 到样例过不了无奈改暴力。（在T2上用了正解的时间，得到了暴力<可能都没有>的分数） 

---

#### 题意

$~~~~$ ~~我觉得已经很清晰了，而且自己概括不出来~~

---

#### 题解

$~~~~$首先，我们枚举 $AB$ 的长度，然后我们可以通过 $\texttt{Hash}$ 在 $\Theta(\sum_{i=2}^{len-1} \dfrac{len}{i})$ 的时间复杂度内算出每次重复了多少次。而且这个东西非常大概率跑不满。

$~~~~$ 然后我们假设 $AB$ 重复了 $k$ 次，那么可以有 $0\backsim(k-1)$ 次 $AB$ 的重复放在后面的 $C$ 字符串里，而且我们发现 $AB$ 重复奇数次和偶数次对于 $C$ 的奇数次出现的字符数的贡献是相同的，而这个次数我们可以 $\mathcal{O(n)}$ 预处理后每次 $\mathcal{O(1)}$ 得到。

$~~~~$ 最后我们对于某一个重复奇数次的字符数量，我们可以用维护 $\leq$ 某个出现次数的 $AB$ 划分方案，那么这显然是一个动态前缀和，用树状数组，那么这部分的时间复杂度是 $\mathcal{O(\log 26)}$ ，每次动态更新时由于只多了一个字符，所以也只用更新一个 $\mathcal{O(\log 26)}$ 的时间复杂度。

$~~~~$ 以下是笔者的废话。

$~~~~$ 到这里这道题已经做完了，然后我考场上认为上面一个一个跳太低效了，而且数据范围给出的是 $|S|$ 在某个 $2$ 的幂以内，但却没有用到 $\mathcal{O(\log n)}$ （~~更主要的原因是我不会算第一个式子~~）所以我想到 倍增/二分出重复次数，那么对于一个某个字符串 $S$ ，设其 $\texttt{HASH}$ 值为 $h$ ，$base^{|S|}=p$ ，则其重复 $k$ 次的 $\texttt{HASH}$ 值应为 $\sum_{i=0}^{k-1} h\times p^i$ 然后一波等比数列求和可以算出来。事实上这是没有问题的，但我们要考虑到 $\texttt{Hash}$ 是由自然溢出/取模的，只是平时都不太容易溢出/取模次数不同步，但我们对大数作乘方运算后，它容易溢出不同步，然后因为精度原因 WA 掉。

$~~~~$ ~~然后我就改成 $len^2$ 暴力亲手送掉1= QAQ~~

#### 代码

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#define ll long long
#define ull unsigned long long
using namespace std;
const ull base=13331;
int cnt[1500000],t[30];
char s[1500000];
ull Hash[1500000],p[1500000]; 
ll len;
ll tr[30];
ull Get_Hash(ll l,ll r)
{
	return Hash[r]-Hash[l-1]*p[r-l+1];
}
inline ll lowbit(ll x){return x&(-x);}
void clearTr(){memset(tr,0,sizeof(tr));}
void add(ll x,ll val){for(;x<=26;x+=lowbit(x))tr[x]+=val;}
ll query(ll x){ll ret=0;for(;x;x-=lowbit(x)) ret+=tr[x];return ret;}
int main() {
//	freopen("data25.in","r",stdin);
//	freopen("data25.out","w",stdout);
	ll T;
	scanf("%lld",&T);
	while(T--)
	{
		memset(Hash,0,sizeof(Hash));
		memset(cnt,0,sizeof(cnt));
		clearTr();
		for(ll i=0;i<=26;i++) t[i]=0;
		scanf("%s",s+1);
		len=strlen(s+1);
		p[0]=1;
		for(ll i=1;i<=len;i++)
		{
			Hash[i]=Hash[i-1]*base+s[i]-'a'+1;
			p[i]=p[i-1]*base;
		}
		for(ll i=0;i<=26;i++) t[i]=0;
		for(ll i=len;i>=1;i--)
		{
			t[s[i]-'a']++;
			if(t[s[i]-'a']&1) cnt[i]=cnt[i+1]+1;
			else cnt[i]=cnt[i+1]-1;
		}
		for(ll i=0;i<=26;i++) t[i]=0;
		t[s[1]-'a']++;
		add(2ll,1ll);//The position that can let the odd number of letters <= a number 
		ll ans=0,last=1;
		for(ll i=2;i<len;i++)//The length of AB 
		{
			ll now=1;
			ull tmp=Get_Hash(1,i);
			ll Sta=i+1,End=2*i;
			while(1)
			{
				if(Get_Hash(Sta,End)!=tmp||End>=len) break;
				else Sta+=i,End+=i,now++;
			}
//			if(End>len) now--;
//			if(now==0) now=1;
			ll K=now-1;
			if(K&1)
			{
				ans+=(1+(K-1)/2)*query(cnt[i*now+1]+1);
				ans+=(K+1)/2*query(cnt[i*(now-1)+1]+1);
			}
			else
			{
				ans+=(K/2+1)*query(cnt[i*now+1]+1);
				ans+=K/2*query(cnt[i*(now-1)+1]+1);
			}
			t[s[i]-'a']++;
			if(t[s[i]-'a']&1) last++;
			else last--;
			add(last+1,1);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```



 

---

## 作者：Calculatelove (赞：7)

## 算法一

> 特殊性质：$n \leq 2^{17}$。

一个较为简单的做法，基本不用怎么思考。

注意到答案是要求将字符串划分成 $S = (AB)^iC$ 的形式。

记 $F(S)$ 的表示字符串 $S$ 中出现奇数次的字符的数量。   
需要先预处理出：

- 每一个前缀 $S_{1 .. i}$ 出现奇数次的字符的数量，即 $F(S_{1..i})$。
- 每一个后缀 $S_{i .. n}$ 出现奇数次的字符的数量，即 $F(S_{i .. n})$。

考虑枚举 $T = (AB)$，那相当于是枚举一个前缀。  
在此基础上，再从小到大枚举一个 $i$，使用 hash 判断子串是否完全相等。

此时整个字符串的划分结构就已经是确定的了。  
$F(C)$ 已经预处理好了，那这种情况对答案的贡献，相当于要在 $T$ 里数出有多少个 $A$ 满足 $F(A) \leq F(C)$。

注意到每一个 $A$ 在 $T$ 中是**真前缀**，那直接用树状数组动态维护一下即可。

时间复杂度 $\mathcal{O}(n \ln n + n \log |\sum|)$。  
其中 $\sum$ 表示字符集。

期望得分 $84 \sim 100$。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2000000;
const unsigned long long P = 13331;

int n;
char S[N];

// suf & pre

bool exist[30];
int num;

int suf[N];
int pre[N];
int c[N][30];

// hash

unsigned long long power[N];
unsigned long long hash[N];

unsigned long long H(int l, int r) {
	return hash[r] - hash[l - 1] * power[r - l + 1];
}

void work() {
	scanf("%s", S + 1);
	n = strlen(S + 1);

// suf

	for (int i = 0; i < 26; i ++)
		exist[i] = 0;

	num = 0;
	for (int i = n; i >= 1; i --) {
		int ch = S[i] - 'a';

		exist[ch] ^= 1;

		if (exist[ch]) num ++;
		else num --;

		suf[i] = num;
	}

// pre

	for (int i = 0; i < 26; i ++)
		exist[i] = 0;

	num = 0;
	for (int i = 1; i <= n; i ++) {
		int ch = S[i] - 'a';

		exist[ch] ^= 1;

		if (exist[ch]) num ++;
		else num --;

		pre[i] = num;
	}

	for (int i = 1; i <= n; i ++) {
		for (int j = 0; j <= 26; j ++)
			c[i][j] = c[i - 1][j];
		for (int j = pre[i]; j <= 26; j ++)
			c[i][j] ++;
	}

// hash

	for (int i = 1; i <= n; i ++)
		hash[i] = hash[i - 1] * P + (S[i] - 'a');

// work

	long long ans = 0;

	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= n / i; j ++) {
			int l = (j - 1) * i + 1, r = j * i;

			if (H(1, i) != H(l, r)) break;
			if (r + 1 > n) break;

			ans += c[i - 1][suf[r + 1]];
		}
	}

	printf("%lld\n", ans);
}

int main() {
	power[0] = 1;
	for (int i = 1; i <= 1500000; i ++) power[i] = power[i - 1] * P;

	int T; scanf("%d", &T);

	while (T --)    work();

	return 0;
}

// I hope changle_cyx can pray for me.
```

## 算法二

> 特殊性质：$n \leq 2^{20}$。

「算法一」没有怎么用到题目中的一些性质。

还是考虑枚举 $T = (AB) = S_{1 .. x}$。

对于当前枚举到的一个 $x$。  
考虑计算出一个最大的 $i$，使得 $S$ 可以被划分成 $(AB)^iC$ 的形式，记这个量为 $k$。

首先有一个结论是：若一个长度为 $n$ 的字符串 $S$ 的前 $n - m$ 位和后 $n - m$ 是相等的且 $m \mid n$，则 $S$ 有一个长度为 $m$ 的整除循环节。

根据该结论，考虑求出字符串 $S$ 的 $Z$ 函数，其中 $Z_i$ 表示：后缀 $S_{i .. n}$ 与 $S$ 的最长公共前缀（LCP）的长度。  
~~至于 Z 算法大家懂得都懂。~~

注意到若 $S$ 可以被划分成 $(AB)^iC$ 的形式，则必满足 $x(i - 1) \leq Z_{x + 1}$ 且 $xi < n$。

解得 $i \leq \frac{Z_{x + 1}}{x}+ 1$ 且 $i < \frac{n}{x}$，则 $k = \min \left\{ \left\lfloor \frac{Z_{x + 1}}{x}  \right\rfloor + 1, \left\lceil \frac{n}{x} \right\rceil - 1 \right\}$。

接下来考虑 $F\left((AB)^i\right)$ 的一些性质（重复性），注意到：

- 当 $i$ 为奇数时，有 $F\left( (AB)^i \right)$ 均相等，即 $F\left(AB\right) = F\left( (AB)^3 \right) = F\left( (AB)^5 \right) = \cdots$。  
  那么可以推出，当 $i$ 为奇数时，对于每个 $(AB)^i$ 划分出来的 $C$，都有 $F(C) = F(S_{x + 1 .. n})$。

- 当 $i$ 为偶数时，有 $F\left( (AB)^i \right) = 0$。  
  那么可以推出，当 $i$ 为偶数时，对于每个 $(AB)^i$ 划分出来的 $C$，都有 $F(C) = F(S)$。

那么我们可以知道，划分出来的 $F(C)$ 的也就只有两种情况，要么是 $F(S_{x + 1 .. n})$ 要么是 $F(S)$。   
并且，有 $\left\lceil \frac{k}{2} \right\rceil$ 个 $i$ 为奇数，有 $\left\lfloor \frac{k}{2} \right\rfloor$ 个 $i$ 为偶数。

$F(S_{x + 1 .. n})$ 在枚举 $x$ 的时候顺便处理一下即可，$F(S)$ 直接处理即可。

那么现在就是要分别数出 $T$ 中有多少个真前缀 $A$ 满足 $F(A) \leq F(S_{x + 1 .. n})$，$F(A) \leq F(S)$。

可以用树状数组做到 $\mathcal{O}(n \log |\sum|)$。

注意到 $F(S)$ 是不变的，那么在枚举的时候直接判断一下即可。  
至于 $F(S_{x + 1 .. n})$，当 $x$ 加 $1$ 的时候也只会导致 $F(S_{x + 1 .. n})$ 变化 $1$，稍微判断一下补补贡献即可。 

时间复杂度 $\mathcal{O}(n)$。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = (1 << 20) + 1000;

int T;

int n;
char s[N];

int Z[N];

void Z_algorithm() {
	for (int i = 1; i <= n; i ++) Z[i] = 0;
	for (int i = 2, l = 0, r = 0; i <= n; i ++) {
		if (i <= r) Z[i] = min(Z[i - l + 1], r - i + 1);
		while (i + Z[i] <= n && s[1 + Z[i]] == s[i + Z[i]])
			Z[i] ++;
		if (i + Z[i] - 1 > r)
			l = i, r = i + Z[i] - 1;
	}
}

int pre, suf, Fs;
int cnt[26];
bool flag1[26], flag2[26];

int cur1, cur2;
long long ans;

void work() {
	scanf("%s", s + 1);
	n = strlen(s + 1);

	Z_algorithm();

	memset(flag1, 0, sizeof(flag1));
	memset(flag2, 0, sizeof(flag2));
	for (int i = 1; i <= n; i ++) {
		int ch = s[i] - 'a';
		flag2[ch] ^= 1;
	}

	Fs = 0;
	for (int i = 0; i < 26; i ++)
		if (flag2[i]) Fs ++;

	pre = 0, suf = Fs;
	ans = 0, cur1 = cur2 = 0;
	memset(cnt, 0, sizeof(cnt));

	for (int i = 1; i < n; i ++) {
		int ch = s[i] - 'a';

		flag1[ch] ^= 1, flag2[ch] ^= 1;

		if (flag1[ch]) pre ++;
		else pre --;

		if (flag2[ch]) suf ++, cur1 += cnt[suf];
		else cur1 -= cnt[suf], suf --;

		int k = min((Z[i + 1] / i) + 1, (n - 1) / i);
		int odd = (k + 1) / 2, even = k / 2;

		ans += 1ll * odd * cur1;
		ans += 1ll * even * cur2;

		cnt[pre] ++;
		if (pre <= suf) cur1 ++;
		if (pre <= Fs) cur2 ++;
	}

	printf("%lld\n", ans);
}

int main() {
	scanf("%d", &T);

	while (T --)    work();

	return 0;
}

// I hope changle_cyx can pray for me.
```

---

## 作者：ykzzldz (赞：5)

这是一篇只需要哈希的题解。

拿到题目，我们有一个非常暴力的想法：枚举 $|AB|$ 和 $i$，此时 $C$ 是确定的。

接下来，考虑如何判断前 $|(AB)^i|$ 个字符所构成的字符串是否为 $(AB)^i$。这个地方可以使用哈希，这里不多赘述。

最后，还需满足 $F(A)\le F(C)$。其中，$F(C)$ 可以 $O(1)$ 求。我们需要统计长度为 $|AB|-1$ 的前缀中，出现奇数次的字符数量小于等于 $F(C)$ 的串的数量。对此，我们可以维护一个大小为 $26$ 的桶，第 $i$ 个位置维护前缀里出现奇数次的字符数量小于等于 $i$ 的串的个数 $num_i$，查询 $num_{F(C)}$ 即可。总复杂度 $O(Tn(\log n+26))$。

---

## 作者：x7103 (赞：4)

## 题目描述

给定一个字符串，求满足 $S=(AB)^iC$，要求 $A,B,C$ 均不为空串，且 $F(A)\le F(C)$，其中 $F(A)$ 表示 $A$ 中出现奇数次的字符数量。

**数据范围：**$\vert S\vert\le2^{20}$。

**时间范围：**$1000\operatorname{ms}$。

## Solution
 > stO[HXP](https://www.luogu.com.cn/user/56701)Orz
 
 > $\Theta(\infty)\sim\Theta(n\sqrt n)$ 的就不说了。
 
 > 主要是补充一下[这篇题解](https://www.luogu.com.cn/blog/BreezeEnderqwq/NOIp2020-T2)。
 
 > 太菜了没想到/kk
 

把[这篇题解](https://www.luogu.com.cn/blog/BreezeEnderqwq/NOIp2020-T2)概括一遍：

 - 由于用到子串匹配，考虑字符串哈希。（后缀数组也不是不可以）


 - 考虑如何满足 $F(A)\le F(C)$。
 可以发现，当 $AB$ 的长度固定时，我们可以通过枚举倍数来达到枚举 $F(C)$ 的目的，可以开树状数组维护 $F(A)$（想写值域分块、$01\operatorname{Trie}$ 或者平衡树也不拦你）。
时间复杂度为 $\Theta(n\ln n\log 26)$，期望得分 $84\operatorname{pts}$。


 - 再观察亿下，可以发现对于同一个 $AB$ 循环的若干倍，$F(C)$ 只有两个取值，可以快速求出循环次数，然后分类讨论。


那么问题来了：**怎么快速求出循环次数？**

从高到低枚举，处理 $i$ 的循环次数时可以用 $2i$ 的循环次数来处理，然后判断下一个循环节是否相同。

时间复杂度为 $\Theta(n\log 26)$，期望得分 $100\operatorname{pts}$。
## Code
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1200000;
const unsigned MLY=133;
template<class T>inline T Max(const T &a,const T &b){return a>b?a:b;}
char s[maxn];
int n;
struct TreeArray{
	int tr[28];
	#define lowbit(x) (x&-x)
	inline void add(int x,int d){
		++x;while(x<=27)tr[x]+=d,x+=lowbit(x);
	}
	inline int ask(int x){
		++x;
		int ans=0;
		while(x)ans+=tr[x],x-=lowbit(x);
		return ans;
	}
	inline void clear(){
		memset(tr,0,sizeof(tr));
	}
}BIT;
struct StringHash{
	unsigned long long hash[maxn],base[maxn];
	inline StringHash(){
		base[0]=1;for(int i=1;i<maxn;++i)base[i]=base[i-1]*MLY;
	}
	inline void Init(){
		for(int i=1;i<=n;++i)hash[i]=hash[i-1]*MLY+s[i];
	}
	inline unsigned long long ask(int l,int r){
		return hash[r]-hash[l-1]*base[r-l+1];
	}
}Hash;
int pre[maxn],suf[maxn],cnt[300],rep[maxn];
bool vis[27];
int stk[27],top;
int main(){
	FILE *fin=stdin;
	FILE *fout=stdout;
	int T;
	fscanf(fin,"%d",&T);
	while(T--){
		memset(pre,0,sizeof(pre));
		memset(suf,0,sizeof(suf));
		fscanf(fin,"%s",s+1);
		n=strlen(s+1);
		Hash.Init();BIT.clear();
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;++i)pre[i]=pre[i-1]+(((++cnt[s[i]])&1)?1:-1);
		memset(cnt,0,sizeof(cnt));
		for(int i=n;i;--i)suf[i]=suf[i+1]+(((++cnt[s[i]])&1)?1:-1);
		long long ans=0;
		for(int i=n-1;i;--i){
			if(i*2>=n)rep[i]=1;
			else if(Hash.ask(1,i)!=Hash.ask(i+1,i*2))rep[i]=1;
			else{
				rep[i]=rep[i*2]*2;
				if(i*(rep[i]+1)<n&&Hash.ask(1,i)==Hash.ask(i*rep[i]+1,i*(rep[i]+1)))++rep[i];
			}
		}
		for(int i=1;i<n;++i){
			if(rep[i]==1){
				ans+=BIT.ask(suf[i+1]);
			}
			else{
				ans+=(rep[i]+1)/2ll*BIT.ask(suf[i+1]);
				ans+=rep[i]/2ll*BIT.ask(suf[i*2+1]);
			}
			BIT.add(pre[i],1);
		}
		fprintf(fout,"%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：chenxia25 (赞：4)

首先想要把这题 A 掉是很容易的，我们现在追求线性做法。

一个很自然的想法是枚举 $AB$ 以及当前 $AB$ 所对应的 $i$。这显然是一个调和级数复杂度，至于如何判断对于某个前缀，它是否可以分成 $i$ 个相等的段即 $AB$，这个哈希 / Z / KMP 都可以，Z 我最熟悉就写它了。这里说一下 KMP，若 $kmp_i\mid i$ 则 $i-kmp_i$ 是最小循环节，判一下整除就可以了。

然后问题是对于一个 $AB$ 和 $C$ 如何求出满足 $F(A)\leq F(C)$ 的将 $AB$ 一刀两断的方案数？我们考虑预处理出前后缀 $F$ 值，容易线性。然后在 $AB$ 长度递增的同时，一边推一边把新的 $A$ 的 $F$ 值扔到前缀和桶里（大小为 $26$），然后对 $F(C)$ 查值即可。[这](https://www.luogu.com.cn/paste/kyxx80uo)是我的考场代码。

那么这样是 $\mathrm O\!\left(Tn(26+\log n)\right)$，稍卡常可以过。离线性的距离在于 $26$ 和 $\log$，我们要把它们都去掉。接下来来找性质。

注意到，$(AB)^x$ 和 $(AB)^{x+2}$ 的 $F$ 值是一样的，那么它们对应的 $C$ 的 $F$ 值显然也是一样的。也就是说对于每轮枚举的 $AB$，$i$ 的贡献仅分为两种，算一下计量数然后对于每种单独算即可，至此去掉了调和级数的 $\log$。

接下来发现，相邻两次枚举的长度相差 $1$ 的 $AB$，它们的 $F$ 值的差是常数级别。然后 $(AB)^2$ 也同理。于是我们可以放弃维护前缀和桶，直接维护桶，然后放个指针在里面游走，这样每次 $AB$ 更新的复杂度是常数。也就成功线性了。

**_[code](https://www.luogu.com.cn/paste/yscef5tx)_**（在原来代码上魔改的）

---

## 作者：Piwry (赞：2)

## 解析

将 $AB$ 视为一个串 $T$。考虑一种最暴力的做法，枚举 $T$，再枚举 $T$ 重复的次数 $i$，再枚举 $A$ 串

规定串 $s$ 奇数次出现的字符数为 $cnt(s)$（即题面中的 $F(s)$）

观察可以发现，奇数 $i$ 和偶数 $i$ 各自对应的 $C$ 串的 $cnt(C)$ 都是一样的，后者其实还是整个串的 $cnt(.)$。于是我们只需计算 $T$ 重复一次和两次（如果存在）时的贡献，再根据 $T$ 最多能重复的次数，就能立即得到 $T$ 的贡献

这样关于 $T$（或者认为是 $C$）的枚举次数就为 $\Theta(n)$ 的了，我们还需考虑优化枚举 $i$ 和枚举 $A$ 部分的复杂度

考虑计算出 $S$ 的 `z[.]`，具体即 `z[i]` 表示最大的 $l$ 满足 $S[0..(l-1)]=S[i..(i+l-1)]$。对于前缀 $T_i=S[0..i]$，容易证明 $S[0..(i+\texttt{z[}i+1\texttt{]})]$ 是 $(T_i)^k$ 的前缀（由错位相等），其中 $k$ 是任意大的正整数；这即代表 $T_i$ 最大的重复次数为 $\lfloor\frac {(i+\texttt{z[}i+1\texttt{]})+1} {|T_i|}\rfloor$（另外为了避免 $C$ 串为空，分母还要和 $(n-1)$ 取个 $\min$）。这样枚举 $i$ 部分的复杂度优化到了 $\Theta(n)$

对于每种 $C_i=S[(i+1)..(n-1)]$ 的查询，相当于询问 $A_i=S[0..i], i\in [0, i-1]$ 中有多少个 $A_i$ 满足 $cnt(A_i)\leq cnt(C_i)$。这显然可以用数据结构或直接开桶维护，单次询问复杂度分别为 $\Theta(\log |\Sigma|)$ 和 $\Theta(|\Sigma|)$。这样枚举 $A$ 部分的复杂度优化到了 $O(n\log |\Sigma|)$ 或 $\Theta(n|\Sigma|)$，前者其实已经足够通过此题

但我们还可以发现枚举 $i$ 时，$cnt(C_i)$ 的变化不会超过 $1$，即询问的值的变化不会超过 $1$。于是可以考虑直接类似桶上指针的方法维护即可。这样枚举 $A$ 部分的复杂度就优化到了 $\Theta(n)$，总复杂度也做到了 $\Theta(n)$

## CODE

```cpp
#include <cstdio>
#include <vector>
using std::vector;
using std::min;

const int MAXN =(1<<20)+20, MAXV ='z'-'a'+1;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return (f) ? -x : x;
}

struct string{
	char data[MAXN];
	int len;
	
	int size() const{
		return len;
	}
	
	char & operator [] (const int &index){
		return data[index];
	}
	char operator [] (const int &index) const{
		return data[index];
	}
};

void read_string(string &s){
	#define CHECK (\
		(ch >= 'a' && ch <= 'z')\
	)
	char ch =getchar();
	while(!CHECK)
		ch =getchar();
	s.len =0;
	while(CHECK)
		s[s.len++] =ch, ch =getchar();
	#undef CHECK
}

/*------------------------------Z-Algorithm------------------------------*/

vector<int> z_algorithm(const string &s1, const string &s2, const vector<int> &z_s2_init =vector<int>(1, -1)){
	const int n1 =s1.size(), n2 =s2.size();
	vector<int> z(n1, 0);
	const vector<int> &z_s2 =(z_s2_init[0] != -1) ? z_s2_init : z;
	while(z[0] < n2 && s1[z[0]] == s2[z[0]])
		++z[0];
	for(int i =1, l =0, r =0; i < n1; ++i){
		if(i < r)
			z[i] =min(r-i, z_s2[i-l]);
		while(z[i] < n2 && i+z[i] < n1 && s1[i+z[i]] == s2[z[i]])
			++z[i];
		if(r < i+z[i])
			l =i, r =i+z[i];
	}
	return z;
}

/*------------------------------Main------------------------------*/

int main(){
	string s;
	for(int tt =0, T =read(); tt < T; ++tt){
		read_string(s);
		vector<int> z =z_algorithm(s, s);
		const int n =s.size();
		
		int cnt_all =0;
		vector<int> ch_pre(MAXV, 0), ch_suf(MAXV, 0);
		vector<int> sum_cnt_pre(MAXV+1, 0);
		int cnt_pre =0, cnt_suf =cnt_all;
		int ctrb_suf_0 =0, ctrb_suf_1 =0;
		/**
		 *  cnt_all: 整个串的奇数次出现的字符数 //
		 *  ch_pre: 当前的前缀的各字符出现次数的奇偶性 //
		 *  ch_suf: 当前的后缀的各字符出现次数的奇偶性 //
		 *  sum_cnt_pre: 设奇数次出现的字符数为 x 的串的类型为 x //
		 *				 储存统计过的每种类型的前缀的出现次数 //
		 *  cnt_pre: 当前前缀的奇数次出现的字符数 //
		 *  cnt_suf: 当前后缀的奇数次出现的字符数 //
		 *  ctrb_suf_0: 当前后缀 (C) 和 S 组成方案，S 出现奇数次，每种 C 的方案数 //
		 *  ctrb_suf_1: 当前后缀 (C) 和 S 组成方案，S 出现偶数次，每种 C 的方案数 //
		**/
		for(int i =0; i < n; ++i)
			cnt_all +=((ch_suf[s[i]-'a'] ^=1) ? 1 : -1);
		cnt_suf =cnt_all;
		auto mov =[&](const char &ch, const char &typ){
			int &cnt_ =(typ == 'p') ? cnt_pre : cnt_suf;
			vector<int> &ch_ =(typ == 'p') ? ch_pre : ch_suf;
			
			const bool Flg =(ch_[ch-'a'] ^=1);
			cnt_ +=(Flg ? 1 : -1);
			
			if(typ == 'p'){
				++sum_cnt_pre[cnt_];
				if(cnt_ <= cnt_suf)
					++ctrb_suf_0;
				if(cnt_ <= cnt_all)
					++ctrb_suf_1;
			}
			else{
				if(Flg)
					ctrb_suf_0 +=sum_cnt_pre[cnt_];
				else
					ctrb_suf_0 -=sum_cnt_pre[cnt_+1];
			}
		};
		
		long long ans =0;
		auto div_floor =[&](const int &a, const int &b){
			return a/b;
		};
		auto div_ceil =[&](const int &a, const int &b){
			return a/b+(a%b);
		};
		for(int i =0; i < n-1; ++i){
			mov(s[i], 's');
			const int rep =min(n-1, (i+1)+z[i+1])/(i+1);
			ans +=1ll*div_ceil(rep, 2)*ctrb_suf_0+1ll*div_floor(rep, 2)*ctrb_suf_1;
			mov(s[i], 'p');
			/* ^- 向前缀添加字符放在计算贡献的后面是因为 B 不能为空 */
		}
		printf("%lld\n", ans);
	}
}
```

---

## 作者：yuantc (赞：1)

# 分析：
先枚举单个 $AB$ 的总长度，由于时间要求，编写一个函数求出 $AB$ 的个数 $k$，注意时间要求不超过 $O(1)$ 可以预处理出串的前缀的奇偶个数和后缀的奇偶个数。然后再确定的奇偶性情况，其实只有 $ABC=C$ 和 $C=C$ 两种情况，所以要分类讨论。最后确定 $A$ 的奇偶性，可以用树状数组来找，先把前缀的奇数个数放进树状数组里面，然后铜锅 $C$ 的奇数个数来找出有几种情况。记得分类一下，当 $ABC=C$ 时，有 $\frac{k}{2}$ 种奇数个数的情况；当 $C=C$ 时，有 $\frac{k+1}{2}$ 种奇数个数的情况，乘上 $A$ 的情况数就能过了。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) ((x)&(-x))
using namespace std;
const int yuantc=1145141,INF=1e20;
int a,n,tree[35];
void upd(int x){while(x<=30){tree[x]++;x+=lowbit(x);}}
int ask(int x){int res=0;while(x){res+=tree[x];x-=lowbit(x);}return res;}
char t[yuantc];
int z[yuantc];
void yuan()
{
  z[1]=n;
  for(int i=2,l=0,r=0;i<=n;i++)
  {
    if(i<=r) z[i]=min(z[i-l+1],r-i+1);
    while(i+z[i]<=n&&t[i+z[i]]==t[z[i]+1]) ++z[i];
    if(i+z[i]-1>r) l=i,r=i+z[i]-1;
  }
}
int pree[yuantc],pos[yuantc],cnt[26];
void tc()
{
  for(int i=0;i<26;i++) cnt[i]=0;
  for(int i=1;i<=n;i++)
  {
    ++cnt[t[i]-'a'];
    if(cnt[t[i]-'a']&1) pree[i]=pree[i-1]+1;
    else pree[i]=pree[i-1]-1;
  }
  for(int i=0;i<26;i++) cnt[i]=0;
  for(int i=n;i>=1;i--)
  {
    ++cnt[t[i]-'a'];
    if(cnt[t[i]-'a']&1) pos[i]=pos[i+1]+1;
    else pos[i]=pos[i+1]-1;
  }
}
int main()
{
  cin>>a;
  while(a--)
  {
    cin>>t+1;
    n=strlen(t+1);
    memset(tree,0,sizeof(tree));
    memset(z,0,sizeof(z));
    memset(pos,0,sizeof(pos));
    memset(pree,0,sizeof(pree));
    yuan();
    tc();
    long long res=0;
    for(int i=2;i<n;i++)
    {
      int k=min(z[i+1]+i,n-1)/i;
      upd(pree[i-1]+1);
      res+=1ll*ask(pos[k*i+1]+1)*((k+1)/2);
      res+=1ll*ask(pos[k*i+1-i]+1)*(k/2);
    }
    printf("%lld\n",res);
  }
  return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

很好的题，给一个单 $\log$ 做法。

考虑枚举 $i$ 表示 $AB$ 是 $S$ 的前 $i$ 个字符。

我们需要找到最大的 $k$ 使得 $(AB)^k$ 是 $S$ 的前缀。

考虑哈希与倍增，设 $p_i$ 表示 $S$ 的前 $i$ 个字符组成的字符串的哈希值，$h_{j, i}$ 表示将 $S$ 的前 $i$ 个字符复制 $2^j$ 遍后的字符串的哈希值。

初始有 $h_{0, i} = p_i$，转移方程易得是：

$$\begin{aligned} h_{j, i} &= h_{j - 1, i} \times base^{i 2^{j - 1}} + h_{j - 1, i} \\ &= h_{j - 1, i} \times (base^{i2^{j - 1}} + 1)\end{aligned}$$

然后可以倍增二分法，从高位往低位贪心，若加上 $2^ji$ 后长度 $<n$ 且是 $S$ 的前缀的话就贪。

设 $Pre_i, Suf_i$ 表示 $S$ 的前 $i$ 位字符串和后 $i$ 位字符串。

当 $AB = Pre_i$ 时，$k$ 是最大满足 $(AB)^k$ 是前缀的数；则可能的 $C$ 只能是以下集合：

$$\{C | C = Suf_{ij + 1}(1 \le j \le k)\}$$

注意到题目还有 $F(A) \le F(C)$ 这个条件，看起来很不好做的样子。

设 $pre_i, suf_i$ 表示 $Pre_i, Suf_i$ 中出现奇数次的字符的数量，可以发现一个很强的性质：

- $suf_{i + 1} = suf_{(2m + 1)i + 1}$。

- $suf_{2i + 1} = suf_{2mi + 1}$。

证明显然：对于 $sum$ 表示每个字符的出现次数，同时减去/加上一个偶数，其奇偶性是不变的。

故考虑求出满足 $pre_j \le suf_{i + 1}, pre_j \le suf_{2i + 1}(j < i)$ 分别的数量为 $A, B$，在线可以主席树做，离线的话扫一遍，树状数组即可。

故贡献是 $s_1 \lfloor \frac{k + 1}{2} \rfloor + s_2 \lfloor \frac{k}{2} \rfloor$。

时间复杂度为 $O(N \log N)$。

这个 $\log$ 是倍增与树状数组的，常数特别小。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = (1 << 20) + 10, M = 21;
const ull base = 127;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll ans;
int T, n;
int len[N], pre[N], suf[N], sum[26];
ull p[N], poww[N], h[M][N];
char s[N];
vector<pair<int, int>> Q[N];
inline void init(){
	poww[0] = 1;
	for(int i = 1; i < N; ++i)
	  poww[i] = poww[i - 1] * base;
}
inline void getinit(){
	for(int i = 1; i <= n; ++i)
	  p[i] = p[i - 1] * base + s[i];
}
namespace Tree{
	int a[N];
	inline void init(){
		for(int i = 1; i <= n + 1; ++i)
		  a[i] = 0;
	}
	inline void add(int x){
		++x;
		for(int i = x; i <= n; i += lowbit(i))
		  ++a[i];
	}
	inline int query(int x){
		++x;
		int ans = 0;
		for(int i = x; i; i -= lowbit(i))
		  ans += a[i];
		return ans;
	}
}
inline void solve(){
	ans = 0;
	scanf("%s", s + 1);
	n = strlen(s + 1);
	getinit();
	for(int i = 1; i <= n; ++i){
		int lim = 0;
		len[i] = 0;
		h[0][i] = p[i];
		for(int j = 1; i * (1 << j) < n; ++j){
			h[j][i] = h[j - 1][i] * poww[i * (1 << (j - 1))] + h[j - 1][i];
			lim = j;
		}
		ull now = 0;
		for(int j = lim; j >= 0; --j){
			ull nxt = now * poww[i * (1 << j)] + h[j][i];
			if(nxt == p[len[i] + (i * (1 << j))] && len[i] + (i * (1 << j)) < n){
				now = nxt;
				len[i] += i * (1 << j);
			}
		}
	}
	memset(sum, 0, sizeof(sum));
	for(int now = 0, i = 1; i <= n; ++i){
		if(sum[s[i] - 'a'] & 1)
		  --now;
		else
		  ++now;
		++sum[s[i] - 'a'];
		pre[i] = now;
	}
	memset(sum, 0, sizeof(sum));
	for(int now = 0, i = n; i >= 1; --i){
		if(sum[s[i] - 'a'] & 1)
		  --now;
		else
		  ++now;
		++sum[s[i] - 'a'];
		suf[i] = now;
	}
	Tree::init();
	for(int i = 2; i < n; ++i){
		Tree::add(pre[i - 1]);
		int t = len[i] / i;
		ans += 1ll * Tree::query(suf[i + 1]) * ((t + 1) >> 1) + 1ll * Tree::query(suf[i << 1 | 1]) * (t >> 1); 
//		cerr << ans << '\n';
	}
	write(ans);
	putchar('\n');
}
bool End;
int main(){
	init();
	T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：_lbw_ (赞：1)

一个理论复杂度比 $\mathcal{O}(n(26+\ln n))$ 快，但是实际不开 O2 变慢的做法（

首先你第一眼肯定是枚举 $AB$ 和循环几次是吧。

然后这个可以哈希 + 调和 $n \ln n$ 快速维护 。

枚举完就有了 $C$ , 然后其实是求 $F(B $的前缀$)<F(C)$ 的方案数。

然后就变成一个 $n \ln n$ 次查询前缀和，$n$ 次修改一个长度为 $26$ 的数组。

普通前缀和修改其实就是 $\mathcal{O}(n(26+\ln n))$ ，然后我们发现东西肯定不能乘在 $\ln n$ 上，否则时间就变大了。。。

然后我们思考到有个东西叫值域分块是吧，将这个东西加上去就可了。

具体就是每次修改将这块这个点后面的 $+1$，然后这个块后面的给块的标记 $+1$.

查询就把两个加一下就可以了。

然后就是 $\mathcal{O}(n(\sqrt{26}+\ln n))$

哦，还有如果不开 O2 想过的话记得加 register，并且将 $AB$ 的哈希预处理出来。

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll int
using namespace std;
#define seed 20090119
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define mem(x,val)memset(x,val,sizeof x)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
const int maxn = 2e6+5;
char s[maxn];
ll T,pre[maxn],suf[maxn],sumk[8],sumt[30],w[30],B,l[8],r[8],siz,t[30],n,x,ww;
long long ans;unsigned int hsh[maxn],po10[maxn],xx;
inline unsigned int fashu(ll x,ll y){return hsh[y]-hsh[x-1]*po10[y-x+1];}
int main(){
	T=read();siz=6;B=ceil(1.0*26/siz);F(i,1,26)w[i]=(i-1)/siz+1;
	F(i,1,B)l[i]=r[i-1]+1,r[i]=i*siz;r[B]=n;
	while(T--){
		scanf("%s",s+1);n=strlen(s+1);ans=0;suf[n+1]=0;
		mem(sumk,0);mem(sumt,0);
		mem(t,0);F(i,1,n)pre[i]=pre[i-1]+(++t[s[i]-'a']%2)*2-1;
		mem(t,0);D(i,n,1)suf[i]=suf[i+1]+(++t[s[i]-'a']%2)*2-1;
		F(i,1,n)hsh[i]=hsh[i-1]*seed+s[i]-'a'+1;
		po10[0]=1;F(i,1,n)po10[i]=po10[i-1]*seed;
		mem(t,0);
		F(i,1,n){
			xx=fashu(1,i);
			F(j,1,(n-1)/i){
				if(xx!=fashu((j-1)*i+1,i*j))break;
				ans+=t[suf[i*j+1]];
			}
			F(j,pre[i],26)t[j]++;
		}
	}
	return 0;
}
```


---

## 作者：lylcpp (赞：0)

## 思路

我们先对每一个字符串进行哈希，接着处理每个字符串从前往后和从后往前出现奇数次字符的个数。

其中：$a$ 是从前往后，$b$ 是从后往前。

```cpp
a[0] = 0;
for (int i = 1; i <= n; i++) {
    cnt[s[i]]++;
  	if (cnt[s[i]] & 1) a[i] = a[i-1] + 1;
  	else a[i] = a[i-1] - 1;
} 
b[n+1] = 0;
memset(cnt, 0, sizeof(cnt));
for (int i = n; i >= 1; i--) {
    cnt[s[i]]++;
    if (cnt[s[i]] & 1) b[i] = b[i+1] + 1;
    else b[i] = b[i+1] - 1;
}
``````

接下来枚举 $AB$ 的长度，然后统计 $S$ 的前 $|AB|$ 位，看看当前这个位数有多少符合条件的字符串个数。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

#define ull unsigned long long
const int N = (1 << 20) + 9, B = 131;
int T, n, a[N], b[N], cnt[128];
long long ans = 0;
ull e[N] = {1}, h[N];
string s;

void solve() {
	cin >> s; n = s.size(); s = " " + s; ans = 0;
	for (int i = 1; i <= n; i++) h[i] = h[i-1] * B + s[i]; 
	memset(cnt, 0, sizeof(cnt));
	a[0] = 0;
	for (int i = 1; i <= n; i++) {
		cnt[s[i]]++;
		if (cnt[s[i]] & 1) a[i] = a[i-1] + 1;
		else a[i] = a[i-1] - 1;
	} 
	b[n+1] = 0;
	memset(cnt, 0, sizeof(cnt));
	for (int i = n; i >= 1; i--) {
		cnt[s[i]]++;
		if (cnt[s[i]] & 1) b[i] = b[i+1] + 1;
		else b[i] = b[i+1] - 1;
	}
	int w[128] = {};
	for (int i = 2; i <= n; i++) { // i = |AB|
		for (int j = a[i-1]; j <= 26; j++) w[j]++;
		int j = i;
		while (j < n && h[j] - h[j - i] * e[i] == h[i]) {
			ans += w[b[j + 1]];
			j += i;
		} 
	}
	printf("%lld\n", ans);
}

int main() {
	for (int i = 1; i <= (1 << 20); i++) 
		e[i] = e[i-1] * B;
	scanf("%d", &T);
	while (T--) solve();
	return 0;
}
``````

---

## 作者：PDAST (赞：0)

>温馨提示，本题解并介绍的是一种比较玄学的卡常做法，虽然复杂度正确，但常数巨大，在评测机是老爷机且不允许吸氧时容易超时，想学常数更小且不用卡常的做法的同学请移步其他题解。
## 题目大意
给你一个字符串 $S$，定义如下：

+ $AB$ 表示将字符串 $B$ 接到字符串 $A$ 后面；

+ $(A)^{i}$ 表示将字符串 $A$ 重复 $i$ 遍。

求使得 $(AB)^{i}C = S$ 的方案数，使得 $A$ 中出现奇数次的字母个数不超过 $C$ 中出现奇数次的字母个数。
## 思路
对于第二个要求，我们只需要对字符串进行前缀和和后缀和进行判断即可。

而对于第一个要求，我们需要枚举循环的次数与长度并用哈希判断是否与前面的形成循环。

而对于上面两个要求，相信前、后缀和大家都会，除此之外，我们发现了三个问题：如何常数复杂度判断？如何优化？取模运算耗时长难进行大规模的哈希怎么办？

对于判断，我们可以先预处理出每一位对应的哈希值，我们设前 $i$ 位的哈希值为 $h_{i}$，第 $i$ 位的权值为 $p_{i}$，容易发现，前 $i$ 位的哈希值 $h1$ 为 $h_{i}$，~~废话对吧~~，第 $i+1$ 位到第 $i+k$ 位哈希值 $h2$ 为 $h_{(k+1)*i}-h_{k*i}*p_{i}$，当 $h1$ 与 $h2$ 相等时，循环就出现了，不止是 $1$ 到 $i$，其他的也同理。

为了节省时间，我们可以使用 unsigned 的自然溢出代替取模，而模数我们就选择比 $26$ 大一点的 $31$，这样在避免发生哈希冲突的前提下还能降低常数，一举两得。

对于优化，我们可以在发现有满足条件的循环时，对下一位进行提前处理，比如你发现 `AB` 能够循环 $k$ 次，那么 `ABAB` 就只能循环 $\lfloor \frac{k}{2} \rfloor$ 次。

然后……这题就做完了，思路简单，码量小，且不用 KMP，~~才不是因为我不会呢~~。
## 代码
~~~cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int N=(1<<20)+5;
int suma[N],sumb[N],t[27],flag[N<<1],cnt[27],h[N],p[N];
signed main(){
//	freopen("string.in","r",stdin);
//	freopen("string.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	p[0]=1;
	for(register int i=1;i<N;i++)p[i]=p[i-1]*29;
	int n,ans=0,T;
	cin>>T;
	while(T--){
		string s;
		cin>>s;
		n=s.size(),s=" "+s,suma[0]=h[0]=ans=0,sumb[n+1]=0;
		for(register int i=0;i<27;i++)t[i]=cnt[i]=0;
		for(register int i=1;i<=n;i++)h[i]=h[i-1]*29+s[i]-'a'+1,flag[i]=0;
		for(register int i=n;i>0;--i){
			++cnt[s[i]-'a'];
			if(cnt[s[i]-'a']&1)sumb[i]=sumb[i+1]+1;
			else sumb[i]=sumb[i+1]-1;
		}
		for(register int i=0;i<26;i++)cnt[i]=0;
		for(register int i=1;i<n;i++){
			int k=1;
			if(i>1){
				if(flag[i])k=flag[i],flag[i*2]=k/2;//呐呐呐，优化在这
				else{
					while((k+1)*i<n&&h[(k+1)*i]-h[k*i]*p[i]==h[i])k++;
					flag[i]=k,flag[i*2]=k/2; 
				}
				for(register int j=1;j<=k;j++)ans+=t[sumb[j*i+1]];
			}
			cnt[s[i]-'a']++;
			if((cnt[s[i]-'a']&1))suma[i]=suma[i-1]+1;
			else suma[i]=suma[i-1]-1;
			for(register int j=0;j<27;j++)if(suma[i]<=j)t[j]++;
		} 
		cout<<ans<<"\n";
	}
}
~~~

---

## 作者：AKPC (赞：0)

因为求的是 $s$ 对应 $(AB)^iC$ 的个数，所以可以把 $(AB)^i$ 和 $C$ 分别看作一个整体。

考虑枚举 $AB$，显然，$AB$ 作为字符串 $s$ 的前缀，所以直接枚举每个前缀。而后再枚举 $C$，显然 $C$ 是 $s$ 的后缀。注意 $AB,C$ 不能有交，枚举次数为 $n^2$ 级别。

因为如果 $AB,i$ 分别被固定，则 $C$ 也被固定，所以变为枚举 $AB,i$。枚举 $i$ 是调和级数级别，所以枚举次数为 $n\ln n$ 级别。

检查合法性的过程需要用到字符串哈希处理，有些卡常，具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
#define fr first
#define sc second
inline int read(){
    int res=0,f=1;char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') {res=res*10+(c-'0');c=getchar();}
    return res*f;
}
inline string readstr(){
	string rs="";
	char ch=getchar();
	while (ch<'a'||ch>'z') ch=getchar();
	while (ch>='a'&&ch<='z') rs+=ch,ch=getchar();
	return rs;
}
const int N=(1ll<<20)+5,B=131;
int n,p[N],hsh[N],pre[N],sum[N][27],suf[N],c[27];
void solve(string s){
	n=s.size(),s=' '+s;
	for (int i=1;i<=n;i++){
		hsh[i]=(hsh[i-1]+p[i]*(s[i]-'a'+1));
		if ((++c[s[i]-'a'])&1) pre[i]=pre[i-1]+1;
		else pre[i]=pre[i-1]-1;
		sum[i][pre[i]]++;
	}
	for (int i=1;i<=n;i++){
		for (int j=1;j<=26;j++)
			sum[i][j]+=sum[i][j-1];
		for (int j=0;j<=26;j++)
			sum[i][j]+=sum[i-1][j];
	}
	for (int i=0;i<26;i++)
		c[i]=0;
	for (int i=n;i>=1;i--){
		if ((++c[s[i]-'a'])&1) suf[i]=suf[i+1]+1;
		else suf[i]=suf[i+1]-1;
	}
	int rs=0;
	for (int i=2;i<=n;i++)//枚举 AB
		for (int j=i+1;j<=n;j+=i){//枚举 C
			rs+=sum[i-1][suf[j]];
			if (hsh[i]*p[j-1]!=hsh[j+i-1]-hsh[j-1])
				break;
		}
	for (int i=0;i<26;i++)
		c[i]=0;
	for (int i=1;i<=n;i++){
		pre[i]=suf[i]=0;
		for (int j=0;j<=26;j++)
			sum[i][j]=0;
	}
	cout<<rs<<'\n';
}
signed main(){
	int T=read();
	p[0]=1;
	for (int i=1;i<N;i++)
		p[i]=p[i-1]*B;
	while (T--){
		string s=readstr();
		solve(s);
	}
	return 0;
}
```

---


# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# 题解

## 作者：RikoHere (赞：168)

如果你初学搜索，如何一步一步无伤A掉搜索真题？

让我们以初学者的角度走进改题;

警告：本篇题解**面向初学者**非最优解或非常规解法，神犇请绕道

做一道题首先需要的是逐步分析:

1. 题目给定了一棵树， 树的节点 **n <= 300** ,同理的变数p = n - 1; 
或许是搜索？

2. 从节点1开始传染，所谓切断一条路径， 不难转换为标记其中一颗子树

3. 每个传染阶段为每一个已被标记“得病”的节点向下传染，传染次数在最坏情况下刚好为叶节点到1节点的距离; 或许是拓扑？

要寻找正确的解题方法总要进行不断的思考

首先先思考拓扑相关， 从末节点倒推是否是一种可行的方法？

事实证明这种方法在题目限制下是几乎不可行的；

（事实证明可以用来进行一定量的预处理）

那么对我来说就只有搜索一条路可以走；

然后是要求输出当传染人数最少的情况下的人数；

同理为未被传染人数最多时传染人数；

那么首先我们要建立相关的**代码框架**，

1.先从输入开始：

值得一提的是输入的边并没有说明是父节点指向子节点或子节点指向父节点

应该想方法处理

2.dfs函数

不难得到，一个节点若要被传染，那么**传染到该节点的第x个传染阶段一定是该节点到1节点的距离**；

接下来是我个人的想法：

显然以节点下标作为dfs传入参数来进行相关处理不太可行；

那么不如我们以**距离1节点的距离x为传入参数**

然后对所有距离1节点距离为x的节点进行处理

即为选择一颗子树进行切除， 然后进行下一层dfs

切除该子树要进行的操作为**标记所有该子树上的节点并统计节点数量**；

同时要保证该子树的父节点为在前几层的递归中未被切除；

当无子树可以切除时dfs函数变走到尽头

然后进行思考一下回溯， 这个是较简单的，同理与标记

```
int clean(int i){
    bol[i] = true;
    int num = 1;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        num += clean(f[i][j]);
    }
    return num;
}
void reclean(int i){
    bol[i] = false;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        reclean(f[i][j]);
    }
}
```

每次进行一次切除就要便利一遍全部子节点显然缺乏效率；

但对于本题的数据范围来说还是可以接受的；

上文代码中用到了一个vector， 里面存的是该节点的子节点

那么回到题目头， 我们该如何处理保证f数组里面都为该节点的子节点呢？

用另外一个数组存入输入的所有边

简单套用一个最短路模板统计距离

然后将所有合法的边push入f即可；

为了要保证可以正常处理距离节点1距离为x的全部节点

也要进行简单的统计

```
void resolve(int i, int cen){
    b[cen][cnt[cen]] = i;
    ++cnt[cen];
    int p = k[i].size();
    for (int j = 0; j < p; ++j){
        if (dis[k[i][j]] == dis[i]+1){
            resolve(k[i][j], cen+1);
            f[i].push_back(k[i][j]);
        }
    }
}
```

最后统计得未被传染人数最多时的人数

输出节点总数减未被传染人数获得正解;

具体细节详见代码

本人AC代码：(327ms)

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<queue>
#define LL long long
using namespace std;
int n, p, t1, t2, b[305][305], cnt[305], maxx, dis[305];
bool bol[305], vis[305];
vector <int> k[305], f[305];
struct node{
    int x, quan;
    node (int a, int b) : x(a), quan(b){
    }
    friend bool operator < (node a, node b){
        return a.quan > b.quan;
    }
};
int clean(int i){
    bol[i] = true;
    int num = 1;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        num += clean(f[i][j]);
    }
    return num;
} //标记部分
void reclean(int i){
    bol[i] = false;
    int p = f[i].size();
    for (int j = 0; j < p; ++j){
        reclean(f[i][j]);
    }
} //回溯部分
void dfs(int cen, int tot){
    maxx = max(maxx, tot);
    for (int i = 0; i < cnt[cen]; ++i){
        if (!bol[b[cen][i]]){
            int num = clean(b[cen][i]);
            tot += num;
            dfs(cen+1, tot);
            reclean(b[cen][i]);
            tot -= num;
        }
    }
} //dfs核心函数
void resolve(int i, int cen){
    b[cen][cnt[cen]] = i;
    ++cnt[cen];
    int p = k[i].size();
    for (int j = 0; j < p; ++j){
        if (dis[k[i][j]] == dis[i]+1){
            resolve(k[i][j], cen+1);
            f[i].push_back(k[i][j]);
        }
    }
} //预处理第二部分
void solve(){
    priority_queue <node> que;
    for (int i = 0; i <= n; ++i) dis[i] = 999;
    dis[1] = 0;
    que.push(node(1, 0));
    while (!que.empty()){
        node temp = que.top();
        que.pop();
        int x = temp.x;
        int p = k[x].size();
        for (int j = 0; j < p; ++j){
            if (dis[k[x][j]] > dis[x]+1){
                dis[k[x][j]] = dis[x]+1;
                que.push(node(k[x][j], dis[k[x][j]]));
            }
        }
    }
    resolve(1, 0);
} //最短路算法进行预处理
//实际上以节点0开始进行拓扑排序效率更高
int main(){
    scanf("%d %d", &n, &p);
    for (int i = 0; i < p; ++i){
        scanf("%d %d", &t1, &t2);
        k[t1].push_back(t2);
        k[t2].push_back(t1);
    }
    solve();
    dfs(1, 0);
    printf("%d", n-maxx);
    //本人代码量命名较随意见谅pu~
}
```

那么，这道题就用最暴力却细腻的处理解决了；

代码亮点在哪里？要怎么写？

1. 分模块处理，即使只是简单的处理或回溯也不妨单独多出来一个函数方便进行相关的调试

2. 理解题意并尽快找到dfs函数所需要传入的参数（例如本题就要尽快从常规方法将节点序号作为传入参数中脱离出来寻找新的做法

3. 如果无法找到相关的关系，不妨进行一定量的预处理（例如本题中输入边未指明是父节点连向子节点或子节点连向父节点，而我只需要父节点连向子节点的相关边，就需要进行预处理即为单源最短路

4. 提高思维的深度， 拓宽思维的宽度

---

## 作者：山水一程_ (赞：11)

开始想到的算法是贪心

开一个数组g，g[i]表示如果这次不处理i这个节点而是传染到它的子节点再处理，这个子树最少感染多少人

一开始试了几个图都可以

然而我画出了这个图

假设第三层从左数前三个节点每个都有无数个子结点

那么正解显而易见是从左到右依次切断

然而因为他们的结构都是一个子结点巨多的结点上面挂了一个链

所以他们的g[i]都是1

然而按照我的贪心办法先处理右边第一个


但是左边的三个已经阻止不了它传播到最下层了
所以要重新考虑算法

然后又想到了dp，但是每个子树切断几次，什么时候切断，可能先切断一次过几次再切断，所以很难分状态
然后搜索？

然而搜索感染多少人显然是不好实现的

所以我突然想到了可以倒着求解

切断一个结点上面的那条路就能把这条结点以及子树上的结点全部保护

所以我们可以求出最多能保护多少个结点

然后想到这问题就解决一半了！

先建树

然后用sum数组存储每个结点的子树和
m为最深的层数

然后还有保存每一层的结点是哪些

f[i]表示i结点上面的那条边是不是被切断了

然后把根节点1作为第一层

从第二层开始搜索

切断第i个结点就把f[i]改为true(i结点位于该层)

然而一开始我的想法是如果搜索到这个节点，这个节点的父节点如果f为true那么它的f也变成true

但是我发现这样很难回溯

所以就增加一个神似并茶几的fin找爹函数

如果它到树根的路上有f为true的点

说明当前状态下它已经被保护了，就跳过它

然后没有被保护的结点就保护住

再搜索下一层

搜到第m+1层就退出

记住一定要边搜索边更新最优答案因为可能搜不到最后一层所有的结点就都被保护了（比如一条链）

最后的答案即为结点数-最大能保护的节点数

# 上代码！！！！！！！
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int sum[500],dep[500],m,n,a[500][500],fa[500],num[500],p,map[500][500],maxx;
bool f[500];
bool fin(int x) 
{
	if (x==1) return false;
	if (f[x]) return true;
	return fin(fa[x]);
}
void build(int x,int depth) 
{
	int i;
	dep[x]=depth;
	num[depth]++;
	m=max(m,depth);
	a[depth][num[depth]]=x;
	    sum[x]=1;
	for (i=1; i<=map[x][0]; i++)
		if (fa[x]!=map[x][i]) 
		{
			fa[map[x][i]]=x;
			build(map[x][i],depth+1);
			sum[x]+=sum[map[x][i]];
		}
}
void dfs(int depth,int ans) 
{
	if (depth==m+1)
		return;
	int n1=num[depth],i,x;
	for (i=1; i<=n1; i++) 
	{
		x=a[depth][i];
		  if (fin(x))
			  continue;
		f[x]=true;
		maxx=max(maxx,ans+sum[x]);
		dfs(depth+1,ans+sum[x]);
		f[x]=false;
	}
}
int main() 
{
	scanf("%d %d",&n,&p);
	int i,x,y;
	for (i=1; i<=p; i++) 
	{
		scanf("%d %d",&x,&y);
		map[x][0]++;
		map[x][map[x][0]]=y;
		map[y][0]++;
		map[y][map[y][0]]=x;
	}
	build(1,1);
	dfs(2,0);
	printf("%d",n-maxx);
}
```


---

## 作者：清尘 (赞：5)

[在我的博客查看](https://www.cnblogs.com/whx666/p/11344478.html)

其实题目说的就是在一颗树中的每个深度找出一些不重合的子树，使所有子树的大小之和最大。


直接暴力dfs（枚举）方案，好像想不到特别有用的剪枝，就打了朴素的搜索，结果就过了（数据范围小）

先从根节点 dfs 遍历整棵树，把会用到的信息都记录下来（节点的深度，每个节点的子树大小)

为了后面搜索方案时方便，我还记录了每个深度的点集

因为子树不能重合，所以又开了一个数组记录当前可以选择作为根节点的点集，每次用上一个深度的可用点拓展出这个深度的可用点

避免子树重合的方法：不拓展已选节点的子树

数组变量声明： v 记录与每个节点有连边的点，sum 记录以每个点为根节点的子树大小，deep 记录节点深度，k 记录每个深度的所有节点，q 记录当前每个深度的可用节点。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 310;
int n, m, a, b, maxn;
int v[N][N], cntv[N], sum[N], deep[N], k[N][N], cntk[N], q[N][N], cntq[N];
inline void Go (int p, int fa, int d) {     //遍历整棵树，记录信息 
	deep[p] = d, sum[p] = 1, k[d][++cntk[d]] = p;
	for (int i = 1; i <= cntv[p]; i++) 
	  if (v[p][i] != fa)  Go (v[p][i], p, d + 1), sum[p] += sum[v[p][i]];
}
inline void Do (int d, int s, int last) {     //搜索方案 
	maxn = max (maxn, s);
	for (int i = 1; i <= cntq[d-1]; i++) 
	  if (q[d-1][i] != last)   //如果这个点不是上一次选中点，拓展子节点为可用节点 
	    for (int j = 1; j <= cntv[q[d-1][i]]; j++) 
		  if (deep[v[q[d-1][i]][j]] == d)  q[d][++cntq[d]] = v[q[d-1][i]][j]; 
	//if判断避免加入这个点的父节点 
	for (int i = 1; i <= cntq[d]; i++)
	   Do (d + 1, s + sum[q[d][i]], q[d][i]), cntq[d+1] = 0;
}
int main() {
	scanf ("%d %d", &n, &m); 
	for (int i = 1; i <= m; i++) {
		scanf ("%d %d", &a, &b);
	    v[a][++cntv[a]] = b, v[b][++cntv[b]] = a;
	}
	q[1][1] = 1, cntq[1] = 1;
	Go (1, 0, 1), Do (2, 0, 0);
	printf ("%d", n - maxn);
	return 0;
}
```

---

## 作者：ljcljc (赞：3)

### 【算法分析】
算法：深搜$DFS$

1. 题意：将每一个节点按照到根的距离来分层，然后从每一层中选择一个节点，并删掉以该节点为根的子树。问最后剩下的节点个数最少是多少？

2. 因为此题的数据范围较弱，因此我们不难想出用**暴搜**求出所有切割方案，最后保留最小值。

3. 首先预处理出每一层的节点集合，以及每棵子树的大小。

	然后从第一层开始，依次枚举每一层中删除的子树，枚举之后通过深度优先遍历，将整棵子树中的边全部标记为不可选，再递归到下一层继续枚举。递归结束时需要再次深度优先遍历整棵子树，将每条边的状态恢复为可选。

	当枚举到最后一层时，更新最小值。

4. 优化：$DFS$ 过程中，我们可以维护当前已经删除的节点总数，来优化时间复杂度

### 【代码】

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;
const int N = 310, M = N * 2;
int n, m;
int h[N], e[M], ne[M], idx;
vector<int> level[N];
int c[M], cnt[N];
int ans = N;

void add(int u, int v)
{
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}

int dfs_level(int u, int d, int fa)
{
    cnt[u] = 1;
    for (int i=h[u]; ~i; i=ne[i])
    {
        int j = e[i];
        if (j == fa)
            continue;
        cnt[u] += dfs_level(j, d + 1, u);
        level[d].push_back(i);
    }
    return cnt[u];
}

void dfs_draw(int j, int color)
{
    c[j] = color;
    for (int i=h[e[j]]; ~i; i=ne[i])
        if (i != (j ^ 1))   // i不是j的反向边
            dfs_draw(i, color);
}

void dfs(int u, int s)
{
    ans = min(ans, s);
    for (int i=0; i<level[u].size(); i++ )
    {
        int j = level[u][i];
        if (!c[j])
        {
            dfs_draw(j, 1);
            dfs(u + 1, s - cnt[e[j]]);
            dfs_draw(j, 0);
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for(int i=1; i<=m; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(v, u), add(u, v);
    }
    dfs_level(1, 0, -1);
    dfs(0, n);
    printf("%d\n", ans);
    return 0;
}

```


---

## 作者：zi小眼聚光 (赞：3)

看到题第一眼当然是爆搜啦
~~(其实是第二眼才看出来的)~~

做法：A*

首先看题可以发现是个树形结构，然后就可以把问题抽象成在树的每两层直接断一条边，求从1号节点可以走到的点总数最小的情况，从而转化成整棵树的节点数切掉点的最小数，于是就只需要求可以切掉的最大点数

dfs的话复杂度我没证 ~~（其实是不会）~~ 但感觉会t，考虑剪枝

A* 估价函数：从当前深度及以下的每一层中选出最大的子树切除。

我们发现，如果一棵子树的根的祖先已经被切除了，那么按理说这棵子树就不用再切除了，但A* 的估价函数是什么？就是最乐观情况啊，所以我们根本不用考虑他有没有被切除过，贪就完了。

至于怎么知道这个点的祖先有没有被切掉呢？开个数组vis表示它有没有被切掉，然后在切祖先的时候暴力向下dfs修改就行了！

整理下思路：预处理出每一层有哪些节点，每一层以该层节点为根的子树的最大节点数，然后跑dfs

AC代码：

```cpp
//by xyjg
#include<cstdio>
#include<algorithm>
#define N 305
using namespace std;
int n,p,uu,vv,ans;//输入的参数和一些辅助变量 

int h[N],nxt[N<<1],to[N<<1],size[N],f[N],dep[N],cnt;//这些数组是存树的，这里用邻接表存图 

int ddd[N][N],pre[N];
/*
这是要预处理的东西，ddd[i][j]表示深度为i的第j个点，
ddd[i][0]表示深度为i的点有几个，ddd[0][0]表示深度
最大为多少，因为用到了第ddd[0][],所以这棵树的根的
深度从1开始算 
至于pre[]，这个是从上到下每一层能切掉的最大子树节
点数的前缀和，用于算估价函数 
*/ 

bool vis[N];//用来表示这个点是不是已经被切掉了 

inline void add(){//建边不解释 
	cnt++;
	nxt[cnt]=h[uu];h[uu]=cnt;to[cnt]=vv;
	cnt++;
	nxt[cnt]=h[vv];h[vv]=cnt;to[cnt]=uu;
	return ;
}

int dfs1(int u,int fa,int d){//用来统计每一层节点数和以每个节点为根的子树的节点数 
	dep[u]=d;
	if(!ddd[d][0])ddd[0][0]++;
	ddd[d][++ddd[d][0]]=u;
	++size[u];
	for(int i=h[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		f[v]=u;
		size[u]+=dfs1(v,u,d+1);
	}
	return size[u];
}

void del(int u,int fa){//将一棵树切除 
	vis[u]=1;
	for(int i=h[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		del(v,u);
	}
	return ;
}

void redel(int u,int fa){//将一棵树恢复 
	vis[u]=0;
	for(int i=h[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		redel(v,u);
	}
	return ;
}

void dfs(int d,int cur){//深搜主体 d表示当前深度，cur表示已经切了多少点 
	if(d==ddd[0][0]+1){//边界条件1 
		ans=max(ans,cur);
		return ;
	}
	if(cur+pre[ddd[0][0]]-pre[d-1]<ans)return ;//A* 剪枝 
	for(int i=1;i<=ddd[d][0];i++){//遍历这一深度的所有点 
		if(!vis[ddd[d][i]]){
			del(ddd[d][i],f[ddd[d][i]]);
			dfs(d+1,cur+size[ddd[d][i]]);
			redel(ddd[d][i],f[ddd[d][i]]);
		}
		else ans=max(ans,cur);//为什么要加这一句？自己画个链模拟一下就行了 
	}
	return ;
}

int main(){
	scanf("%d%d",&n,&p);
	for(int i=1;i<=p;i++){
		scanf("%d%d",&uu,&vv);
		add();
	}
	dfs1(1,0,1);
	for(int i=1;i<=ddd[0][0];i++){//这个循环是用来处理上面提到的前缀和的 
		uu=0;
		for(int j=1;j<=ddd[i][0];j++){
			uu=max(uu,size[ddd[i][j]]);
		}
		pre[i]=pre[i-1]+uu;
	}
	dfs(2,0);//深度为1的点不能切掉，所以从第二层开始 
	printf("%d",size[1]-ans);//所有人减去未患病人就是患病人了 
	return 0;
}
```


---

## 作者：hbzfome14ban (赞：2)

[题目P1041](https://www.luogu.com.cn/problem/P1041)

经典的 NOIP 老题。

### 题目分析

看完题目后可看出：如果按一棵树的形式搜索下去，状态太难记录了。改变思路，搜索当前层数。

### 算法思路

先建好树， DFS 当前深度，在同深度的可能被感染的人中选一个，阻断路径，然后感染其他可能被感染的人，进入下一层。到达最深层后记录答案，回溯。

先选人再感染其他人也麻烦，可以等价于先感染所有当前层可以感染的人，再选一个人治好。

实际操作时，可以每次在当前层处理下一层的感染情况，会快一点。上面那样可能会 TLE 。

这种解法挺暴力的，好在数据不大。

### 代码实现

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
const int mxn=480;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,p;
int ans=1e9;
vector<int>e[mxn];
int dep[mxn],num[mxn];
bool ill[mxn];
void Ncount(int u,int fa){
    num[u]++;
    for(int i=0;i<e[u].size();i++){
        int v=e[u][i];if(v==fa)continue;
        dep[v]=dep[u]+1;
        Ncount(v,u);
        num[u]+=num[v];
    }
//    printf("node:%d  num:%d\n",u,num[u]);
    return;
}
void DFS(int d,int cnt){
    if(cnt>=ans)return;//最优性剪枝
    bool flag=1;
    int i,j;
    for(i=1;i<=n;i++)//向深层传染
        if(dep[i]==d && ill[i]){
            for(j=0;j<e[i].size();j++){
                int v=e[i][j];
                if(dep[v]<dep[i])continue;
                flag=0;
                ill[v]=1;
                ++cnt;
            }
        }

    --cnt;
    for(i=1;i<=n;i++){
        if(dep[i]==d+1 && ill[i]){//阻断传播
            ill[i]=0;
            DFS(d+1,cnt);
            ill[i]=1;
        }
    }
    ++cnt;
    for(i=1;i<=n;i++)//回溯
        if(dep[i]==d && ill[i]){
            for(j=0;j<e[i].size();j++){
                int v=e[i][j];
                if(dep[v]<dep[i])continue;
                ill[e[i][j]]=0;
                --cnt;
            }
        }
    if(flag){//传到了底层
//        printf("dep:%d\n",d);
        ans=min(ans,cnt);
        return;
    }
}
//
int main(){
    int i,j;
    n=read();p=read();
    int u,v;
    for(i=1;i<=p;i++){
        u=read();v=read();
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dep[1]=1;
    Ncount(1,0);
    ill[1]=1;
    DFS(1,1);
    printf("%d\n",ans);
    return 0;
}
```

来源：博客园。

感谢观看与支持！

---

## 作者：henry_y (赞：2)

同步于[个人博客](https://www.cnblogs.com/henry-1202/p/10371500.html)

## 题目地址
[题目链接](https://www.luogu.org/problemnew/show/P1041)

## 题解
这里讲一个**非正解**——贪心+**随机化**。


贪心的想法是什么？

我们dfs一遍处理出每个节点子树内的节点数量，记为$siz$。
贪心的砍掉$siz$最大的那个子树，在树的形态比较正常的情况下是可以得到最优解的。

如何hack掉这种贪心？

**构造一条链，在中间的地方放一个“很胖”的分支，可以只分两层，每层的节点构造多一些（注意要使这个分支的节点数量小于链下半部分的节点数量）**

这样子我们按照上述贪心，将会得到错误的结果，更优的做法是把这个分支直接砍
掉（因为链上每次传染只会增加一个被传染的人）

当然，实际构造可以更加复杂，这只是最极端的情况。

不过，这种错误的贪心已经可以得到90分了。

如何得到满分？

要对答案产生影响，那么需要的那个分支的大小就不会太小（因为实际情况下一般是不会像上面那样子构造的~~，毒瘤出题人除外~~）

我们采用**随机化**的思想（实际上下面这个随机化的方法并不好，不过数据水也就水过去了）。

我们定义一种判定规则，如果某个节点恰好符合这个判定规则（一般是随机的），那么就改变原本的贪心策略，换用另外一个策略。

这里用的判定规则是rand出来的结果对233取模是否为0.

如果符合这个判定规则的话，我们就选择子树大小第二大（这个使用优先队列实现）的子树砍掉。

**当然，这很不靠谱。**

通常的做法是在不TLE的情况下尽量跑多次（能多少次就多少次），对所有结果取min。

所以随机化能水过去一般靠大量的尝试，尽量靠谱的判定规则，以及另外一个策略靠不靠谱。。。

**注意，在此题中，需要使判定成功的可能性尽可能低，当然也不能太低**

下面给出代码，注意，因为代码里只跑了200次进行尝试，不保证一定能ac，可以自行调大次数，或者多交几次（我交了2发才过）。
```cpp
#include <bits/stdc++.h>

#define ll long long
#define inf 0x3f3f3f3f
#define il inline

namespace io {

    #define in(a) a=read()
    #define out(a) write(a)
    #define outn(a) out(a),putchar('\n')

    #define I_int ll
    inline I_int read() {
        I_int x = 0 , f = 1 ; char c = getchar() ;
        while( c < '0' || c > '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; }
        while( c >= '0' && c <= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; }
        return x * f ;
    }
    char F[ 200 ] ;
    inline void write( I_int x ) {
        if( x == 0 ) { putchar( '0' ) ; return ; }
        I_int tmp = x > 0 ? x : -x ;
        if( x < 0 ) putchar( '-' ) ;
        int cnt = 0 ;
        while( tmp > 0 ) {
            F[ cnt ++ ] = tmp % 10 + '0' ;
            tmp /= 10 ;
        }
        while( cnt > 0 ) putchar( F[ -- cnt ] ) ;
    }
    #undef I_int

}
using namespace io ;

using namespace std ;

#define N 310

int n, m, f[N];
int cnt, head[N], siz[N], fa[N];
struct edge {
	int to, nxt;
}e[N<<1];

void ins(int u, int v) {
	e[++cnt] = (edge) {v, head[u]};
	head[u] = cnt;
}

void dfs(int u) {
	siz[u] = 1;
	for(int i = head[u]; i; i = e[i].nxt) {
		if(e[i].to == fa[u]) continue;
		fa[e[i].to] = u;
		dfs(e[i].to);
		siz[u] += siz[e[i].to];
	}
}

struct Node {
    int val;
};
priority_queue<Node> q, t;

bool operator < (Node a, Node b) {
    return siz[a.val] < siz[b.val];
}

int solve() {
    while(!q.empty()) q.pop();
    int ans = 0;
    q.push((Node){1});
    while(!q.empty()) {
        int cur = 0;
        while(!t.empty()) t.pop();
        while(!q.empty()) {
            int u = q.top().val; ++ans;
            for(int i = head[u]; i; i = e[i].nxt) {
                if(e[i].to == fa[u]) continue;
                t.push((Node){e[i].to});
                f[++cur] = e[i].to;
            }
            q.pop();
        }
        int num;
        if(!t.empty()) {
            int u = t.top().val; t.pop();
            if(!t.empty() && rand() % 233 == 0) {
                num = t.top().val; t.pop();
            } else num = u;
        }
        for(int i = 1; i <= cur; ++i) {
            if(f[i] == num) continue;
            q.push((Node){f[i]});
        }
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("1.in", "r", stdin);
#endif
    srand((unsigned)time(0));
	n = read(), m = read();
	for(int i = 1; i <= m; ++i) {
		int u = read(), v = read();
		ins(u, v); ins(v, u);
	}
	dfs(1);
    int ans = 1000000;
	for(int i = 1; i <= 200; ++i) {
        ans = min(ans, solve());
    }
    printf("%d\n", ans);
}

```

---

## 作者：chenhanzheapple (赞：1)

# [传送门](https://www.luogu.com.cn/problem/P1041)

# 思路

暴力 dfs 切除子树。

## 第一步

预处理出这棵以 $1$ 为根的树的所有节点的子树的大小、深度和父节点。

```cpp
void dfs2(int x){
    sz[x] = 1;//子树大小初始化
    for(auto y:v[x]){//邻接表存树（图）
        if(y==fa[x]){//如果当前节点是父节点
            continue;//跳过
        }
        fa[y] = x;//计算父节点
        de[y] = de[x]+1;//计算深度（从1开始）
        dfs2(y);//继续递归
        sz[x]+=sz[y];//计算子树大小
    }
}
```

# 第二步

`dfs(d,z)` 表示传染了 $d$ 轮，还剩 $z$ 个节点时，对于所有根节点深度为 $d$ 的子树，枚举要切除哪棵。

同时，如果该子树在之前的对于其父亲节点子树的切除中已经被切除，那么不用枚举切除这棵子树的情况。

在切除后，给被切除的子树的所有节点打上标记，如果一个子树的根节点被打上标记，表示这棵子树已经被切除，不能重复切除。

为了方便标记节点和回溯时去除节点，需要额外增加 `cover(x)` 和 `erase(x)` 两个函数，分别表示给 $x$ 的子树的所有节点打上标记和给 $x$ 的子树的所有节点删除标记。


```cpp
void cover(int x){//打标记
    vis[x] = 1;//给x节点打上标记
    for(auto y:v[x]){//遍历x的所有儿子
        if(y==fa[x]){//如果y是x的父亲
            continue;//跳过
        }
        cover(y);//递归处理x的儿子y
    }
}
void erase(int x){//去除标记
    vis[x] = 0;//给x节点去除标记
    for(auto y:v[x]){//遍历x的所有儿子
        if(y==fa[x]){//如果y是x的父亲
            continue;//跳过
        }
        erase(y);//递归处理x的儿子y
    }
}
void dfs(int d,int z){//枚举切除子树
    if(d==dep+1){//如果所有未被切除的节点都被传染
        ans = min(ans,z);//更新答案
        return;//返回
    }
    vector<int> a;//存储深度为d的所有节点
    for(int i=1;i<=n;i++){//找出深度为d的所有节点
        if(de[i]==d){//判断i节点深度是否为d
            a.push_back(i);//如果是，插入
        }
    }
    bool flag = 0;//标记是否没有子树可以删除
    for(auto x:a){//枚举所有深度为d的节点
        if(!vis[x]){//如果没有被打上标记（没有被切除）
            flag = 1;//标记有子树可以删除
            cover(x);//打上标记
            dfs(d+1,z-sz[x]);//继续递归d+1轮，剪去了该子树的情况
            erase(x);//回溯，去除标记
        }
    }
    if(!flag){//如果没有子树可以删除
        ans = min(ans,z);//更新答案
    }
}
```

# 代码


```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
int n,m,ans = INT_MAX,dep;
int sz[305],fa[305],de[305];
bool vis[305];
vector<int> v[305];
void dfs2(int x){
    sz[x] = 1;//子树大小初始化
    for(auto y:v[x]){//邻接表存树（图）
        if(y==fa[x]){//如果当前节点是父节点
            continue;//跳过
        }
        fa[y] = x;//计算父节点
        de[y] = de[x]+1;//计算深度（从1开始）
        dfs2(y);//继续递归
        sz[x]+=sz[y];//计算子树大小
    }
}
void cover(int x){//打标记
    vis[x] = 1;//给x节点打上标记
    for(auto y:v[x]){//遍历x的所有儿子
        if(y==fa[x]){//如果y是x的父亲
            continue;//跳过
        }
        cover(y);//递归处理x的儿子y
    }
}
void erase(int x){//去除标记
    vis[x] = 0;//给x节点去除标记
    for(auto y:v[x]){//遍历x的所有儿子
        if(y==fa[x]){//如果y是x的父亲
            continue;//跳过
        }
        erase(y);//递归处理x的儿子y
    }
}
void dfs(int d,int z){//枚举切除子树
    if(d==dep+1){//如果所有未被切除的节点都被传染
        ans = min(ans,z);//更新答案
        return;//返回
    }
    vector<int> a;//存储深度为d的所有节点
    for(int i=1;i<=n;i++){//找出深度为d的所有节点
        if(de[i]==d){//判断i节点深度是否为d
            a.push_back(i);//如果是，插入
        }
    }
    bool flag = 0;//标记是否没有子树可以删除
    for(auto x:a){//枚举所有深度为d的节点
        if(!vis[x]){//如果没有被打上标记（没有被切除）
            flag = 1;//标记有子树可以删除
            cover(x);//打上标记
            dfs(d+1,z-sz[x]);//继续递归d+1轮，剪去了该子树的情况
            erase(x);//回溯，去除标记
        }
    }
    if(!flag){//如果没有子树可以删除
        ans = min(ans,z);//更新答案
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i=1;i<=m;i++){
        int x,y;
        cin >> x >> y;
        v[x].push_back(y);//存图
        v[y].push_back(x);//存双向边
    }
    de[1] = 1;//初始化深度
    dfs2(1);
    for(int i=1;i<=n;i++){//计算树的高度
        dep = max(dep,de[i]);
    }
    dfs(2,n);
    cout << ans;
    return 0;
}

```

---

## 作者：潘德理2010 (赞：1)

**简化题意：**

有一棵根为 $1$ 的树，你可以切断每一深度的各一条边，使从 $1$ 出发可以到达的点的数量最小化。

**题目解法：**

根据这题背景里的“错题”标识和数据范围 $n\le 300$ 可以想到这应该是一道搜索题。

因此我们直接搜索即可。但是这题是蓝，并且是 NOIP 提高的题，应该不能用纯搜索过去，需要剪枝（因为要进行下面的最优性优化，所以应该用 dfs 而非 bfs）：

- 显然，当前感染人数已经大于等于最优情况下的总感染人数时，可以直接剪掉。

- 为了使更多情况被剪掉，我们应先搜索最可能得到最优解（或较优解）的部分。为此，我们在决定先搜索切断到哪一点的边时，对当前下一步到达的点进行排序，优先尝试搜索切断到子树较大的点的边的情况，以便尽快获得最优解（或较优解）。

另外，在搜索题中，如果使用了第二种方法却仍然超时，可以在运行时间即将达到时间限制时，输出当前已经搜到的最优解并结束程序。（但这题这两个优化已经足够 AC，所以代码里没有使用这一操作）

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int sz[330],st[330],md[330],fa[330],de[330];//sz 子树大小 st 儿子个数 md 子树最深深度 fa 父节点 de 深度 
inline bool cmp1(int a,int b){// 从大到小 
	//这里将子树大小作为第一关键字，儿子个数作为第二关键字，子树中最深节点深度作为第三关键字排序 
	if(sz[a]!=sz[b]) return sz[a]>sz[b];
	if(st[a]!=st[b]) return st[a]>st[b];
	return md[a]>md[b];
}
int n,a,b;
vector<int> e[330],s[330];// e用于存边，s用于存儿子 
bitset<310> t;
int ans=1<<30;
void dfs1(int u,int f){
	fa[u]=f;
	de[u]=de[f]+1;
	md[u]=de[u];
	sz[u]=1;
	for(int i=0;i<int(e[u].size());i++){
		int v=e[u][i];
		if(v==f) continue;
		dfs1(v,u);
		sz[u]+=sz[v];
		st[u]++;
		md[u]=max(md[u],md[v]);
	}
}
void dfs(int tot,bitset<310> r){
	//用 bitset 传是为了降低空间复杂度，防止爆栈 
	//bitset 中为 1 的元素在当前一轮中被感染 
	vector<int> re;
	bitset<310> nw;
	for(int i=1;i<=n;i++){
		if(r[i]){
			for(int j=0;j<int(s[i].size());j++){
				int u=s[i][j];
				re.push_back(u);
				nw[u]=1;
			}
		}
	}
	sort(re.begin(),re.end(),cmp1);
	if(re.size()!=0) tot+=re.size()-1;//减 1 是因为要删掉一个 
	if(re.size()<=1){
		ans=min(ans,tot);
		return;
	}
	for(int i=0;i<int(re.size());i++){
		int u=re[i];
		nw[u]=0;
		if(tot>=ans) break;
		dfs(tot,nw);
		nw[u]=1;
	}
}
int main(){
	scanf("%d%d",&n,&a);
	for(int i=2;i<=n;i++){
		scanf("%d%d",&a,&b);
		e[a].push_back(b);
		e[b].push_back(a);
	}
	dfs1(1,0);
	for(int i=1;i<=n;i++){
		int u=fa[i];
		s[u].push_back(i);
	}
	for(int i=1;i<=n;i++){
		sort(s[i].begin(),s[i].end(),cmp1);
	}
	t[1]=1;
	dfs(1,t);
	printf("%d\n",ans);
}
```

---

## 作者：CRH_Beijingzhan (赞：0)

[P1041 [NOIP 2003 提高组] 传染病控制](https://www.luogu.com.cn/problem/P1041)

## 思路

题目给出一棵树。第 $i$ 步拆的一定是第 $i$ 层与第 $i+1$ 层之间的连边，否则不是最优（自行证明即可），所以可以暴力枚举每一次拆哪一个节点与上一个节点的连边。

把所有节点所在的层数存下来，一号点在第 1 层，枚举每一层的每个节点（由于 1 号节点已经被感染，从第二层开始搜索就可以了）。

大概可分为以下几步：

- 存好一整棵树。
- 把每一层的节点都存在一个数组里面。
- 标记以 $i$ 号节点为根节点的子树的节点个数。
- 标记与回溯。
- 暴力搜索。

## 细节精讲

### 树的储存
关于多叉树的存储，这里介绍一种简单有效的方法。考虑如下代码：


```
struct Node
{
	int father;
	int child[MAXN];
}tree[MAXN];
```

```tree[i]``` 存 $i$ 节点的所有信息：

$father$ 存父亲（在这题里没用）；$child[]$ 存它所有孩子；$child[0]$ 是它孩子的个数。

由于数据范围很小，我们不用担心造成空间过多的浪费。

结构体构建完成之后，我们就可以在读入的同时把整棵树存好。


```
n=read();p=read();
for(int i=1;i<=p;i++)
{
	int x=read(),y=read();
	if(x>y)swap(x,y);
	tree[y].father=x;
	tree[x].child[++tree[x].child[0]]=y;
}
```

### 标记深度

如果能够理解，标记深度是比较简单的。

![](https://cdn.luogu.org/upload/pic/44843.png)

如图：我们令 1 号节点的深度为 1，则 2，3 节点深度为 2，4,5,6,7 节点深度为 3，8 节点的深度为 4，这棵树一共有 4 层。

代码 ```deep[i][j]``` 存第 $i$ 层第 $j$ 个节点的编号。```deep[i][0]``` 是第 $i$ 层一共的节点数。

```
inline void getdeep(int now,int Nowdeep)//当前的节点标号是 now，层数是 Nowdeep
{
	maxdeep=max(maxdeep,Nowdeep);//标记一共有几层
	for(int i=1;i<=tree[now].child[0];i++)
	{
		deep[Nowdeep][++deep[Nowdeep][0]]=tree[now].child[i];//把这个节点放到第i层的数组中
		getdeep(tree[now].child[i],Nowdeep+1);//以这个点为父节点继续标记它的儿子。每个节点的深度等于它父节点的深度+1
	}
}

```

### 切断问题

我们知道，只要一个点与上层点的传播途径被切断，即这个点不会得传染病，那么以这个点为根节点的整个子树都应该被标记为安全。

这一段代码用来标记 $now$ 这个节点为根节点的子树一共有多少节点，存在 $num[]$ 中。

```
inline int getnum(int now)
{
	for(int i=1;i<=tree[now].child[0];i++)
		num[now]+=getnum(tree[now].child[i]);
	return num[now];
}
```

### 回溯

接下来，我们切断了这个节点，相应地，以这个点为根节点的子树都应该被标记。（$tag=1$ 表示标记，$tag=0$ 表示删去标记，用于回溯）。

```
inline void work(int now,bool tag)
{
	vis[now]=tag;
	for(int i=1;i<=tree[now].child[0];i++)
	{
		vis[tree[now].child[i]]=tag;
		work(tree[now].child[i],tag);
	}
}

```

### 搜索

做完上面这些铺垫操作之后，我们可以开始整个代码的核心：搜索了。

首先可以想到如下代码：
```
inline void DFS(int now,int cnt)
{
	if((now==maxdeep))
	{
		ans=min(ans,cnt);
		return;
	}
	for(int i=1;i<=deep[now][0];i++)
	{
		if(vis[deep[now][i]])
			continue;
		work(deep[now][i],1);
		DFS(now+1,cnt-num[deep[now][i]]);
		work(deep[now][i],0);
	}
}
```

但是提交这段代码的话只能得 80 分。为什么呢？

我们可以考虑这样一棵树：

![](https://cdn.luogu.org/upload/pic/44848.png)

它是一条链。我们第一次只能切断 1 号节点和 2 号节点之间的连边，这样第三层所有的节点就都被标记了。那么问题是什么呢？根本就搜不到最后一层的节点，导致答案根本没有更新！

于是我们优化一下搜索代码：

```
inline void DFS(int now,int cnt)
{
	int tot=0;//记录总数
	if((now==maxdeep))
	{
		ans=min(ans,cnt);
		return;
	}
	for(int i=1;i<=deep[now][0];i++)
	{
		if(vis[deep[now][i]])
		{
			tot++;
			continue;
		}
		work(deep[now][i],1);
		DFS(now+1,cnt-num[deep[now][i]]);
		work(deep[now][i],0);
	}
	if(tot==deep[now][0])//如果全部都被访问过了，那么直接更新答案
		ans=min(ans,cnt);
}

```

## 全部代码

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=300+10;
int n,p;
struct Node
{
	int father;
	int child[MAXN];
}tree[MAXN];
int num[MAXN];
int deep[MAXN][MAXN];
int maxdeep=0;
bool vis[MAXN];
int ans=0x3f3f3f3f;
inline int read()
{
	int tot=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		tot=(tot<<1)+(tot<<3)+c-'0';
		c=getchar();
	}
	return tot;
}
inline void getdeep(int now,int Nowdeep)
{
	maxdeep=max(maxdeep,Nowdeep);
	for(int i=1;i<=tree[now].child[0];i++)
	{
		deep[Nowdeep][++deep[Nowdeep][0]]=tree[now].child[i];
		getdeep(tree[now].child[i],Nowdeep+1);
	}
}
inline int getnum(int now)
{
	for(int i=1;i<=tree[now].child[0];i++)
		num[now]+=getnum(tree[now].child[i]);
	return num[now];
}
inline void work(int now,bool tag)
{
	vis[now]=tag;
	for(int i=1;i<=tree[now].child[0];i++)
	{
		vis[tree[now].child[i]]=tag;
		work(tree[now].child[i],tag);
	}
}
inline void DFS(int now,int cnt)
{
	int tot=0;
	if((now==maxdeep))
	{
		ans=min(ans,cnt);
		return;
	}
	for(int i=1;i<=deep[now][0];i++)
	{
		if(vis[deep[now][i]])
		{
			tot++;
			continue;
		}
		work(deep[now][i],1);
		DFS(now+1,cnt-num[deep[now][i]]);
		work(deep[now][i],0);
	}
	if(tot==deep[now][0])
		ans=min(ans,cnt);
}
int main()
{
	n=read();p=read();
	fill(num+1,num+1+n,1);
	for(int i=1;i<=p;i++)
	{
		int x=read(),y=read();
		if(x>y)swap(x,y);
		tree[y].father=x;
		tree[x].child[++tree[x].child[0]]=y;
	}
	/*for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=tree[i].child[0];i++)cout<<tree[i].child[j]<<" ";
		cout<<endl;
	}*/
	getdeep(1,2);
	/*for(int i=2;i<=maxdeep;i++)
	{
		for(int j=1;j<=deep[i][0];j++)cout<<deep[i][j]<<" ";
		cout<<endl;
	}*/
	getnum(1);
	DFS(2,n);
	printf("%d\n",ans);
	return 0;
}
```

---


# [NOIP 2011 提高组] 观光公交

## 题目背景

感谢 @Transhumanist 提供的一组 Hack 数据

## 题目描述

风景迷人的小城 Y 市，拥有 $n$ 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 $0$ 分钟出现在 $1$ 号景点，随后依次前往 $2,3,4,\cdots,n$ 号景点。从第 $i$ 号景点开到第 $i+1$ 号景点需要 $D_i$ 分钟。任意时刻，公交车只能往前开，或在景点处等待。

设共有 $m$ 个游客，每位游客需要乘车 $1$ 次从一个景点到达另一个景点，第 $i$ 位游客在 $T_i$ 分钟来到景点 $A_i$，希望乘车前往景点 $B_i$（$A_i<B_i$）。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。

假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机 ZZ 给公交车安装了 $k$ 个氮气加速器，每使用一个加速器，可以使其中一个 $D_i-1$。对于同一个 $D_i$ 可以重复使用加速器，但是必须保证使用后 $D_i\ge0$。

那么 ZZ 该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？

## 说明/提示

**【输入输出样例说明】**

对 $D_2$ 使用 $2$ 个加速器，从 $2$ 号景点到 $3$ 号景点时间变为 $2$ 分钟。

公交车在第 $1$ 分钟从 $1$ 号景点出发，第 $2$ 分钟到达 $2$ 号景点，第 $5$ 分钟从 $2$ 号景点出发，第 $7$ 分钟到达 $3$ 号景点。

第 $1$ 个旅客旅行时间 $7-0=7$ 分钟。

第 $2$ 个旅客旅行时间 $2-1=1$ 分钟。

第 $3$ 个旅客旅行时间 $7-5=2$ 分钟。

总时间 $7+1+2=10$ 分钟。

**【数据范围】**

对于 $10\%$ 的数据，$k=0$。

对于 $20\%$ 的数据，$k=1$。

对于 $40\%$ 的数据，$2 \le n \le 50$，$1 \le m \le 10^3$，$0 \le k \le 20$，$0 \le D_i \le 10$，$0 \le T_i \le 500$。

对于 $60\%$ 的数据，$1 \le n \le 100$，$1 \le m \le 10^3$，$0 \le k \le 100$，$0 \le D_i \le 100$，$0 \le T_i \le 10^4$。

对于 $100\%$ 的数据，$1 \le n \le 10^3$，$1 \le m \le 10^4$，$0 \le k \le 10^5$，$0 \le D_i \le 100$，$0 \le T_i \le 10^5$。

## 样例 #1

### 输入

```
3 3 2
1 4
0 1 3
1 1 2
5 2 3```

### 输出

```
10
```

# 题解

## 作者：tth37 (赞：173)

2024/6/10: 很久以前写的题解不知为什么被打回了。。

---

**立志写一篇明明白白且老少咸宜的贪心题解**

本题的思维含量特别大，蒟蒻作者和同学讨论了好几天才把这道题整明白...

首先看题。题目内容特别冗长，认真读题后，可以发现对本题的处理可分以下几个步骤：

1. 读入数据

2. 规划出**不用氮气加速时**公交车的行驶过程

3. 找一段区间，使得在这个区间使用氮气加速时，能使**最多的乘客旅行时间缩短**；本步骤重复 $k$ 次

4. 输出答案

本题的规划过程比较复杂。现对步骤 2 进行叙述。

对于第一个景点，我们已经知道了公交车抵达第一个景点的时间（即第 $0$ 分钟）。按照题意，公交车必须等到从第一个景点上车的最后一个乘客到达后才能从第一个景点离开。记 $Latest_i$ 为第i个景点最后一名乘客抵达该站点的时间。如果 $Latest_1\le0$，那么离开第一个景点的时间就是 $0$；如果 $Latest_1>0$，离开第一个景点的时间就是 $Latest_1$。

那么，对于第二个景点，抵达第二个景点的时间就是离开第一个景点的时间加 $D_1$。按照第一个景点递推的方式，我们可以规划出公交车初始的行驶过程。

![](https://cdn.luogu.com.cn/upload/pic/46704.png)

假如公交车到达第 $i$ 个景点时，仍有乘客尚未到达第 $i$ 个景点，此时公交车将留在第 $i$ 个景点，直到最后一个乘客上车。如果到达第 $i$ 个景点时已不再是“车等人”而是“人等车”，此时公交车可以直接离开第 $i$ 个景点。

在递推到每个景点时，记录到达第 $i$ 个景点的时间为 $Arrive_i$。

```
int time=0;
for(register int i=1;i<=N;++i)
{
    Arrive=time;
    time=max(time,Latest[i]);
    time+=D[i];
}
```

进行完预处理，即可枚举所有的区间，并找出在每个区间使用氮气加速**可以惠及多少乘客**。不难发现，如果到达第 $i$ 个景点的时间提前（即从第 $i-1$ 个景点出发的时间提前），那么从第 $i$ 个景点下车的乘客旅行时间都将减一。但关键点是，如果到达第 $i$ 个景点的时间提前，也有可能对到达第 $i+1$ 个景点的时间产生影响。

![](https://cdn.luogu.com.cn/upload/pic/46709.png)

那么我们可以分情况讨论。如果 $Arrive_i>Latest_i$，并且在 $D_i$ 区间使用氮气加速，$Arrive_i$ 将减少 $1$，离开第 $i$ 个景点的时间也将减 $1$，继续进行下一个景点的讨论；如果 $Arrive_i\le Latest_i$，$Arrive_i$ 将减少 $1$，此时为了照顾最后一名乘客，离开第 $i$ 个景点的时间不变，因此也不必对后面的景点进行讨论。每讨论到一个景点 $i$，表示到达第 $i$ 个景点的时间将减 $1$，那么惠及的总人数便要加上从第 $i$ 个景点下车的人数。

简单总结一下：如果在当前 $Arrive$ 值减一后，出现“**人等车**”的情况，则说明下一个 $Arrive$ 值也将减小，继续循环；如出现“**车等人**”的情况，则说明离开当前景点的时间不会更新，后续的 $Arrive$ 值均不受影响，故跳出循环。

像这样枚举每个区间后，记录惠及人数最多的区间位置。

```
max_num=0;
for(register int i=2;i<=N;++i)
{
   	if(!D[i-1]) continue;
   	tmp_num=0;
   	for(register int j=i;j<=N;++j)
   	{
   		tmp_num+=Leave[j];
   		if(Arrive[j]<=Latest[j]) break;
   	}
   	if(tmp_num>max_num)
   	{
   		max_num=tmp_num;
  		max_pos=i;
   	}
}
```

记录下位置后，便可以对 $Arrive$ 和 $D$ 数组进行更新。更新方式与枚举区间方式类似，请自行体会。

```
D[max_pos-1]--;
for(register int i=max_pos;i<=N;++i)
{
	Arrive[i]--;
	if(Arrive[i]<Latest[i]) break;
}
```

将以上两段操作重复 $k$ 次，便得到更新后的 $Arrive$ 数组。根据每一个乘客旅行开始的时间和下车的景点，计算出 $ans$ 即可。

标程如下：

```
#include<bits/stdc++.h>
using namespace std;

int N,M,K;
struct passenger
{
	int start,end;
}pas[100005];
struct station
{
	int off,latest,arrive;
}sta[1005];
int Dist[1005];

int main()
{
    scanf("%d%d%d",&N,&M,&K);
    for(register int i=1;i<N;++i) scanf("%d",&Dist[i]);
    int t;
    for(register int i=1;i<=M;++i)
    {
    	scanf("%d%d%d",&pas[i].start,&t,&pas[i].end);
    	sta[t].latest=max(sta[t].latest,pas[i].start);
    	sta[pas[i].end].off++;
    }
    int time=0;
    for(register int i=1;i<=N;++i)
    {
        sta[i].arrive=time;
        time=max(time,sta[i].latest);
        time+=Dist[i];
    }
    int max_num,max_pos,tmp_num;
    while(K--)
    {
		max_num=0;
    	for(register int i=2;i<=N;++i)
    	{
    		if(!Dist[i-1]) continue;
    		tmp_num=0;
    		for(register int j=i;j<=N;++j)
    		{
    			tmp_num+=sta[j].off;
    			if(sta[j].arrive<=sta[j].latest) break;
    		}
    		if(tmp_num>max_num)
    		{
    			max_num=tmp_num;
    			max_pos=i;
    		}
    	}
    	Dist[max_pos-1]--;
    	for(register int i=max_pos;i<=N;++i)
    	{
    		sta[i].arrive--;
    		if(sta[i].arrive<sta[i].latest) break;
    	}
    }
    int ans=0;
    for(register int i=1;i<=M;++i)
    	ans+=sta[pas[i].end].arrive-pas[i].start;
    printf("%d",ans);
 	return 0;
}
```

---

## 作者：CalvinJin (赞：120)

对方并不想和你说话并向你扔了一个费用流233


变量名：$tim_i$到一个点的时间 $Mx_i$一个点乘客最晚到达时间 $down_i$一个点下车人数

首先构建模型

不难发现在一个点使用加速器造成的效果是阶段性的

即在一个阶段后区间会被劈开

考虑这个劈开的条件

当前面使用的加速器超过$max(tim_i-Mx_i,0)$时就不能对后面的产生影响了

把使用加速器个数作为流量

每个点都会被分配到至多$D_i$的加速器


建立$S$、$S'$、$T$三个点

连边$S\rightarrow S'$ 容量为$K$ 费用为$0$ 起到限制总个数的作用

把所有点$i$分为$i'$和$i''$

连边$i'\rightarrow i''$ 容量为$max(tim_i-Mx_i,0)$ 费用为$0$ 限制前面使用的加速器对后面的影响

连边$S'\rightarrow i''$ 容量为$D_i$ 费用为$0$ 分配加速器

连边$i''\rightarrow (i+1)'$ 容量为$INF$ 费用为$-down_{i+1}$ 累计费用以及传递影响

连边$i'\rightarrow T$ 容量为$INF$ 费用为$0$

显然$1'$和$n''$是没有用的 可以在建图时舍去

然后就可以愉快的套模板了

最坏复杂度$O(k*n*log(n))$(Dijkstra)或$O(k*n^2)$(SPFA)

比贪心慢= =

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1010
#define M 10010
#define INF (0x3f3f3f3f)
struct peo{
    int t,l,r;
}a[M];
struct edge{
    int nxt,to,cap,cost;
}e[N<<3];
int head[N<<1],edge_cnt;
void add_edge(int x,int y,int z,int w){
    e[edge_cnt]=(edge){head[x],y,z,w};
    head[x]=edge_cnt++;
    e[edge_cnt]=(edge){head[y],x,0,-w};
    head[y]=edge_cnt++;
}
int D[N],Mx[N],down[N],tim[N],S,T;
struct MinCostMaxFlow{
    int d[N<<1],fa[N<<1],Mn[N<<1];
    bool vis[N<<1];
    queue<int>Q;
    int calc(){
        int i,res=0;
        while (1){
            memset(d,63,sizeof(d));
            d[S]=0;
            Q.push(S);
            Mn[S]=INF;
            while (!Q.empty()){
                int x=Q.front(); Q.pop();
                vis[x]=0;
                for (i=head[x];~i;i=e[i].nxt){
                    int To=e[i].to;
                    if (!e[i].cap || d[To]<=d[x]+e[i].cost) continue;
                    d[To]=d[x]+e[i].cost;
                    fa[To]=i;
                    Mn[To]=min(Mn[x],e[i].cap);
                    if (!vis[To]){
                        vis[To]=1;
                        Q.push(To);
                    }
                }
            }
            if (d[T]==INF) return res;
            res+=Mn[T]*d[T];
            int p=T;
            while (p!=S){
                e[fa[p]].cap-=Mn[T];
                e[fa[p]^1].cap+=Mn[T];
                p=e[fa[p]^1].to;
            }
        }
    }
}MCMF;
int main(){
    memset(head,-1,sizeof(head));
    int n,m,K,i,ans=0;
    scanf("%d%d%d",&n,&m,&K);
    for (i=1;i<n;i++) scanf("%d",&D[i]);
    for (i=1;i<=m;i++){
        scanf("%d%d%d",&a[i].t,&a[i].l,&a[i].r);
        down[a[i].r]++;
        Mx[a[i].l]=max(Mx[a[i].l],a[i].t);
    }
    for (i=1;i<n;i++) tim[i+1]=max(tim[i],Mx[i])+D[i];
    for (i=1;i<=m;i++) ans+=tim[a[i].r]-a[i].t;
    
    S=n*2+1; T=n*2+3;
    int S1=n*2+2;
    add_edge(S,S1,K,0);
    for (i=1;i<n;i++){
        add_edge(i,i+n,max(tim[i]-Mx[i],0),0);
        add_edge(i+n,i+1,INF,-down[i+1]);
        add_edge(S1,i+n,D[i],0);
        add_edge(i+1,T,INF,0);
    }
    printf("%d\n",ans+MCMF.calc());
    return 0;
}
```


---

## 作者：lucario (赞：28)

> $O(nlog(n))$的做法真是清奇无比，~~目前已花8h+的时间。。。~~ 9h成功AC

主要是写心得，而且可能是我在luogu的第一篇&最后一篇题解了

加强版可以在LOJ上找到

对于 $100\%$ 的数据，$n,m\le 10^5$，$k\le5\times10^6$，$D_i\le 1000$。 

-----------------
# 开题

拿到题后有一个“显而易见”的贪心：一条道路不能加速次数过多而导致车等人，所以加速有一个范围，同时每次加速选择一条人数最多的路（我知道这个东西错的很凶）

所以线段树区间修改，区间查询最大值，同时把过短的边赋为$- \infty$

复杂度$O(klog(n))$。~~美滋滋~~

然后我就挂了

## 错因一：

**不考虑一条边会对后面连续的一些边产生影响**

也就是说区间查询最大值不是最优的决策了

也就是说要开始推公式了

分析后可得

$$ans=\sum_{i=2}^nTim_i*cnt_i-\sum T_i$$

这个式子很重要也很有用！

其中$Tim_i$表示公交车到达第$i$号景点的时间，$cnt_i$表示在$i$景点下车的人数

显然的，如果我们设$Begin_i$为从$i$号景点发车的时间，那么有

$$Tim_i=Begin_{i-1}+D_{i-1}$$

所以分析一波$Begin$的式子

首先我们设$i$号景点最晚到的旅客的时间为$Maxn_i$
$$Begin_i=max\left(Maxn_i,Begin_{i-1}+D_{i-1} \right)$$
发现这是一个递推式，尝试把它拆开

$$
Begin_i=max\left(Maxn_i,max(Maxn_{i-1}+D_{i-1},Begin_{i-2}+D_{i-2}+D_{i-1})\right)
$$

像这样一直拆下去，就得到了这样一个奇妙的式子

$$
Begin_i=max\left(Maxn_i,\underset{1\le j<i}{max}\begin{Bmatrix}Maxn_j+D_{j\to i}\end{Bmatrix}\right)
$$

把$D_{j\to i}$拆成前缀和形式$pre_i-pre_j$,再稍稍变一下形，就有：

$$
Begin_i=max\left(Maxn_i,\underset{1\le j<i}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}+pre_i\right)
$$
$$
=max\left(Maxn_i-pre_i,\underset{1\le j<i}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}\right)+pre_i
$$

合并后完成变形：

$$
Begin_i=\underset{1\le j\le i}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}+pre_i
$$

这时再回过头来看答案，可以推一波

$$
\sum_{i=2}^nTim_i* cnt_i-\sum T_i
$$

$$
=\sum_{i=2}^n(Begin_{i-1}+D_{i-1})* cnt_i-\sum T_i
$$

$$
=\sum_{i=2}^n\left(\underset{1\le j\le i-1}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}+pre_{i-1}+D_{i-1}\right)* cnt_i-\sum T_i
$$

$pre_{i-1}+D_{i-1}$就是$pre_i$，那么我们就维护一下${max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}$就好了，线段树解决

至此脑子烧糊，想不出怎么贪心了

于是去瞟了网上唯一一份题解，受了很大的启发

设$S_i$表示景点$i$公交到达时间和游客最晚时间之差，显然如果$S_i>0$就有提速的余地
于是推一波这个东西

$$
S_i=Tim_i-Maxn_i
$$

$$
=Begin_{i-1}+D_{i-1}-Maxn_i
$$

$$
=\underset{1\le j\le i-1}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}+pre_{i-1}+D_{i-1}-Maxn_i
$$

$$
=\underset{1\le j\le i-1}{max}\begin{Bmatrix}Maxn_j-pre_j\end{Bmatrix}-(Maxn_i-pre_i)
$$

通俗点讲，如果$i$号点前面有比它大的点，那么那个点可以对$i$号点产生影响

那么现在就很清楚了：一个点能影响后面连续一段比它小的点，把这个点的管辖范围框成一个区间，一个点是否优秀取决于它区间内除它以外的点的$cnt$总和（因为减小$1$的$D_i$权值就减小了$\sum\limits_{i=l+1}^rcnt_i$的答案）
所以把所有区间丢进堆里，权值为$\sum cnt$

现在考虑修改答案（我要吐了md）

如果我们修改$D_i$，它会让它后面所有的$pre$减小，也就是在线段树上的区间加操作，同时在$k>0$不断加速的过程中，总会有一个点与左端点一样大，那么就从这个点分割区间，由于最多操作$2n$个区间，总复杂度$O(nlog(n))$。~~美滋滋~~

然后我又挂了

## 错因二：

**没有考虑$D_i$减成负数的情况**

此时$D_i=0$，区间变成$l+1\to r$

艹

完成以上工作LOJ 60分（黑线）

## 错因三：
**没有考虑$cnt_{r+1}$对区间l~r的贡献**
用人话就是：如果公交可能提前到站，仍会产生贡献，因为会有人在这一站下车，所以说区间最小长度为1

可是怎么还是60分？

## 错因四：
**处理$D_i\to 0$的过程有锅**

不知道读者发现没有

因为我们默认区在间内左端点最大，而上面的过程显然没有保证。
不慌，分析一下$S_i$的式子，可以知道需要存一个旧区间的“左端点”值，与当前左端点值取$max$（相当于旧左端点仍然管辖，只是不能直接减小$D_i$了）

还是60分，心态有点小崩

## 错因五
wtcl

不能直接存旧左端点值，因为可能这个值会被修改。所以我们存旧左端点的位置，取$max$时查询一下就好了

至此收获$\color{green}{Accepted}$

附上最终代码
```
#include<bits/stdc++.h>
using namespace std;
inline char nc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
//#define nc getchar
inline int read(){
	int x=0,f=1;
	char ch=nc();
	for(;!isdigit(ch);ch=nc())if(ch=='-')f=-1;
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=nc();}
	return x*f;
}
typedef long long ll;
const int N=1e5+3;
struct tree{
	int l,r;
	long long maxn,maxpos,lazy;
	inline tree friend operator +(tree l,tree r){
		tree ret={0,0,0,0,0};ret.l=l.l;ret.r=r.r;
		if(l.maxn>=r.maxn)ret.maxpos=l.maxpos;
		else ret.maxpos=r.maxpos;
		ret.maxn=max(l.maxn,r.maxn);return ret;
	}
}t[N<<2];
int cnt[N],maxn[N],sum[N],pre[N],d[N];
//#define lim(i) (maxn[i+1]-maxn[i])
struct tour{
	int tim,l,r;
}p[N*10];
inline bool cmp(tour a,tour b){
	if(a.l==b.l)return a.tim<b.tim;
	return a.l<b.l;
}
int n,m,k;ll T;
#define lc (p<<1)
#define rc ((p<<1)|1)
inline void pushup(int p){
	if(t[lc].maxn>=t[rc].maxn)t[p].maxpos=t[lc].maxpos;
	else t[p].maxpos=t[rc].maxpos;
	t[p].maxn=max(t[lc].maxn,t[rc].maxn);
}
inline void pushnow(int p,int w){
	t[p].maxn+=w;t[p].lazy+=w;
}
inline void pushdown(int p){
	if(t[p].lazy!=0){
		pushnow(lc,t[p].lazy);pushnow(rc,t[p].lazy);t[p].lazy=0;
	}
}
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;t[p].lazy=0;
	if(l==r){t[p].maxn=maxn[l]-pre[l],t[p].maxpos=l;return;}
	int mid=(l+r)>>1;
	build(lc,l,mid);build(rc,mid+1,r);
	pushup(p);
}
void lmy(int p,int pl,int pr,int w){
	int l=t[p].l,r=t[p].r;
	if(pl<=l&&r<=pr){pushnow(p,w);return;}
	int mid=(l+r)>>1;pushdown(p);
	if(pl<=mid)lmy(lc,pl,pr,w);
	if(pr>mid)lmy(rc,pl,pr,w);
	pushup(p);
}
tree glf(int p,int pl,int pr){
	int l=t[p].l,r=t[p].r;
	if(pl<=l&&r<=pr){return t[p];}
	pushdown(p);int mid=(l+r)>>1;
	if(pl<=mid&&pr>mid)return glf(lc,pl,pr)+glf(rc,pl,pr);
	else if(pl<=mid)return glf(lc,pl,pr);
	else return glf(rc,pl,pr);
}
struct segment{
	int l,r;ll sum, vis;
	segment(int _l=0,int _r=0,ll _sum=0,ll _vis=0):l(_l),r(_r),sum(_sum),vis(_vis){}
	const bool operator <(const segment &b)const{
		return sum<b.sum;
	}
};
priority_queue<segment>q;

int main(){
	n=read();m=read();k=read();
	for(int i=1;i<n;i++)d[i]=read(),pre[i+1]=pre[i]+d[i];
	for(int i=1;i<=m;i++){
		p[i].tim=read();p[i].l=read();p[i].r=read();T+=p[i].tim;
		maxn[p[i].l]=max(maxn[p[i].l],p[i].tim);cnt[p[i].r]++;
	}
	build(1,1,n);
	for(int i=1;i<=n+1;i++)sum[i]=sum[i-1]+cnt[i];
	for(int i=2,last=1,lastval=maxn[1]-pre[1];i<=n;i++){
		if(maxn[i]-pre[i]>=lastval)q.push(segment(last,i-1,sum[i]-sum[last],last)),last=i,lastval=maxn[i]-pre[i];
		if(i==n&&last!=n)q.push(segment(last,i,sum[i]-sum[last],last));
	}
	while(k&&!q.empty()){
		segment now=q.top();q.pop();
		if(now.l==now.r){
			if(k<=d[now.l])lmy(1,now.l+1,n,k),d[now.l]-=k,k=0;
			else k-=d[now.l],lmy(1,now.l+1,n,d[now.l]),d[now.l]=0;
			continue;
		}
		int x=glf(1,now.l+1,now.r).maxn,lmaxn=max(glf(1,now.l,now.l).maxn,glf(1,now.vis,now.vis).maxn);
		if(k<=min(d[now.l],lmaxn-x)){lmy(1,now.l+1,n,k);d[now.l]-=k;k=0;}
		else{
			if(lmaxn-x>=d[now.l]){
				lmy(1,now.l+1,n,d[now.l]);k-=d[now.l];d[now.l]=0;
				if(now.l+1>now.r)continue;
				if(now.l+1<=now.r)q.push(segment(now.l+1,now.r,sum[now.r+1]-sum[now.l+1],now.vis));
			}else{
				lmy(1,now.l+1,n,lmaxn-x);k-=lmaxn-x;d[now.l]-=lmaxn-x;
				if(now.l+1>now.r)continue;
				int pos=0;
				pos=glf(1,now.l+1,now.r).maxpos;
				if(now.l<=pos-1)q.push(segment(now.l,pos-1,sum[pos]-sum[now.l],now.vis));
				if(pos<=now.r)q.push(segment(pos,now.r,sum[now.r+1]-sum[pos],pos));
			}
			
		}
	}
	for(int i=1;i<n;i++)pre[i+1]=pre[i]+d[i];
	ll ans=-T;
	for(int i=2;i<=n;i++)ans+=cnt[i]*(glf(1,1,i-1).maxn+pre[i]);
	printf("%lld",ans);
	return 0;
}
```


$\color{orange}{FIN}$



---

## 作者：a2956331800 (赞：8)

# 暴力枚举与剪枝

这个题并没有想到费用流做法，题解里“在这个点用加速器影响的范围”看着也比较懵，就暴力加优化A了这题

首先**_贪心_**地使用加速器，每次给能减少耗时最多的一段路使用。计算耗时的方法是求出到达每个点的时间和离开的时间，对每个人求**到达时间-出现时间**求和即可。贪心时**枚举每个区间**，求出使用一个加速器能减少最多时间的区间，然后对它使用一个加速器。重复这个过程直到用完为止。

算一下复杂度：k个加速器，每个加速器要枚举n个区间，计算耗时复杂度$O(m)$，总复杂度$O(nmk)$T飞了

------------

先考虑优化**计算耗时**

计算耗时时代码大概长这个样：
```cpp
long long x=1,ret=0;
for(long long i=1;i<=n;i++)
{
    arr[i]=leave[i-1]+t[i-1];//arr[i]到达时间
    leave[i]=arr[i];//leave[i]离开时间
    while(h[x].a<i&&x<=m)
      x++;
    while(h[x].a==i&&x<=m)
      leave[i]=max(leave[i],h[x].t),x++;
}
for(long long i=1;i<=m;i++)
  ret+=arr[h[i].b]-h[i].t;//h[i].t这个人出现的时间
return ret;
```
首先发现$leave[i]$每次都是对相同的数取max，所以把这些数的max预处理出来，存在另一个数字$lea[i]$里，代码就变成了
```cpp
for(long long i=1;i<=n;i++)
  arr[i]=leave[i-1]+t[i-1],leave[i]=max(arr[i],lea[i]);
```

------------


但是现在下面还有一个$O(m)$的循环，总复杂度还是$O(m)$

再观察下面的循环

$h[i].t$也是不变的，同样预处理出来，每次直接减去即可；$h[i].b$也不变，那就预处理一个sum数组，记录arr数组中每个数被加了几次，最后$O(n)$枚举区间，算$\sum arr[i]\times arr[i]$即可

------------

预处理代码（包括上面的lea）长这样
```cpp
for(long long i=1;i<=m;i++)
      d+=h[i].t,sum[h[i].b]++,lea[h[i].a]=max(lea[h[i].a],h[i].t);
```

预处理完就可以愉快地把计算耗时优化成$O(n)$了
```cpp
long long ret=0;
    for(long long i=1;i<=n;i++)
    	arr[i]=leave[i-1]+t[i-1],leave[i]=max(arr[i],lea[i]);
    for(long long i=1;i<=n;i++)
      ret+=arr[i]*sum[i];
    return ret-d;
```

------------

现在复杂度是$O(n^2k)$

~~好像还是T飞啊~~

------------

回想一下为什么可以贪心：使用加速器的效果随加速器的使用是单调不增的。可以再用这个性质优化找最优区间和使用加速器的过程

### 优化1：

由于加速器效果不增，所以如果用完一个加速器后，再在同一个区间使用加速器时效果没有降低，那这个区间仍是最优的

怎么操作：每次找出最优区间后，**二分**在这个区间上使用几个加速器**！！！注意二分上界是$min(k,t[x])$，即** $min($剩余加速器个数，这个区间用时$)$ **以免减成负数！！！**，如果求出一次使用多个加速器时的减少量$=$用一个的减少量$\times$使用的个数，那当前数量就能保证每次使用都是最优的，按这个二分即可

代码
```cpp
long long L=1,R=min(k,t[p]),mid;
x=count();//计算这次使用之前的耗时，count()为计算耗时
while(L<R)
{
	mid=(L+R+1)>>1;
	t[p]-=mid;
	if((x-count())==mid*(x-mn))//即每次使用效果都是最优效果
	  L=mid;
	else R=mid-1;
	t[p]+=mid;
}
t[p]-=L;k-=L;
```

加上这个优化之后，开O2已经可以通过，但是不开还是T成80

~~O2水过去就可以跑了~~继续优化

------------

### 优化2：

同样是根据贪心的那个性质，不过这次是优化找最优区间的过程

第一次求最优区间时，把每个点的效果存下来，求完之后按效果排序，然后按效果数组的编号顺序更新效果**！！！注意如果一个区间已经被加速到用时0，就应该把这个区间的效果设为0！！！**，如果算完一个区间的效果后，发现它的效果比（按效果数组中 点的顺序）下一个效果（这个还没有更新）优或二者相等，就不用继续计算了，因为效果单调不增，后面的点的效果不可能超过这个点的效果。注意跑完之后要再把效果数组排序一次

加上之后最慢的点不超过100ms，~~比其他题解慢了好多~~，对一个暴力做法来说不错了

------------
完整代码（虽然加了fread，但是实测没有什么用，cin都可以）
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
struct node
{
    long long t,a,b;
    bool operator <(const node&x)const
    {
        return a<x.a;
    }
};
node h[10005];

struct node2
{
    long long id,val;
    bool operator <(const node2&x)const
    {
        return val>x.val;
    }
};
node2 a[1005];
bool cmp(node2 a,node2 b)
{
    return a.id<b.id;
}

char Getchar()
{
    static const int len=1000000;
    static char space[len],*p=space,*t=space;
    if(p==t)
      t=space+fread(p=space,sizeof(char),len,stdin);
    return *(p++);
}
char rc;int flag;
void read(long long &x)
{
    x=0;rc=Getchar();flag=1;
    while(rc<'0'||rc>'9')
      flag=(rc=='-'?-1:1),rc=Getchar();
    while(rc>='0'&&rc<='9')
      x=x*10+rc-'0',rc=Getchar();
    x*=flag;
}

long long sum[1005],t[1005],arr[1005],leave[1005],n,m,k,i,j,x,d,lea[1005],de[1005];

long long count()
{
    long long ret=0;
    for(long long i=1;i<=n;i++)
    	arr[i]=leave[i-1]+t[i-1],leave[i]=max(arr[i],lea[i]);
    for(long long i=1;i<=n;i++)
      ret+=arr[i]*sum[i];
    return ret-d;
}

int main()
{
    cin>>n>>m>>k;
    for(i=1;i<n;i++)
      read(t[i]),a[i].id=i;
    for(i=1;i<=m;i++)
      read(h[i].t),read(h[i].a),read(h[i].b);
    sort(h+1,h+1+m);
    for(long long i=1;i<=m;i++)
      d+=h[i].t,sum[h[i].b]++,lea[h[i].a]=max(lea[h[i].a],h[i].t);
    int fi=1;
    while(k)
    {
        long long mn=0x7fffffff,p=-1,mx=count();
        for(j=1;j<n;j++)
          if(t[a[j].id]>=1)
          {
          	  t[a[j].id]--;
          	  x=count();
          	  a[j].val=mx-x;
          	  if(x<mn)
          	    mn=x,p=a[j].id;
          	  t[a[j].id]++;
          	  if(a[j].val>=a[j+1].val&&!fi)
          	    break;
          }
          else a[j].val=0;
        fi=0;
        sort(a+1,a+n);
        if(p==-1)
          break;
        long long L=1,R=min(k,t[p]),mid;
        x=count();
        while(L<R)
        {
            mid=(L+R+1)>>1;
            t[p]-=mid;
            if((x-count())==mid*(x-mn))
              L=mid;
            else R=mid-1;
            t[p]+=mid;
        }
        t[p]-=L;k-=L;
    }
    cout<<count();
    return 0;
}
```

---

## 作者：Hope2075 (赞：5)

这篇题解主要是证明贪心正确性~~（考场上这不是重点）~~

对具体实现不多做解释，可以参考其它题解

贪心算法就是取出优化最多的点进行优化

证明：令每一步只用一个，这样方便证明

按每个点时间限制和到达时间画图，大概是这样

![](https://cdn.luogu.com.cn/upload/pic/32186.png)

首先定义几个用到的概念

断点：到达时间小于等于时间限制的点，即图中蓝色点

有效区间：两个断点之间区域

先证最优决策每一步都是优化断点后面的一小段

如果某一步不选这一段，则选的这一段之后一直到下一个断点之间的点都会被优化

但选该区间断点后面的一小段则优化更大范围，且重合部分效果相同

之后对每一步效果造成影响的只能是多优化的这一段

而且不会导致变差

所以最优决策每一步都是优化断点后面的一小段

下一步考虑每个有效区间

使用后可能导致区间分裂

这样可以形成树，满足孩子节点权值（优化量）的和不大于父节点

大概是这样（与上图无关）

（也可能是多棵树）

![](https://cdn.luogu.com.cn/upload/pic/32187.png)

这时只要每步取最大的即可

取到的恰好时最大的n个

因为每一步取最大的点时，不需要保证任何比它小的点被取

证明算法正确性

假设存在某个最优决策存在某个点不是最大的n个

设未取到的点中最大的是a，取到的点中最小的是b

则b是已取部分的某个叶子节点，否则与该树的性质矛盾

a是根或某个已取点的孩子，且这个点不是b

很明显它的后代都未取

而且它的父节点已取，否则与选取a的过程矛盾

这时可以把b换成a，权值和只可能增大

所以不存在某个最优决策存在某个点不是最大的n个

证毕

~~（语言描述也许难懂，请谅解）~~

实现就看代码或其它题解吧

另外实现时不需要每次取一个，树上一条链可以直接全取（必须权值相同，也就是不会导致分裂）

小心一些细节

~~另外欢迎hack~~

```cpp
#include<iostream>
#include<queue>
using namespace std;
struct range{
    int l,r,people;
};
bool operator<(range a,range b){
    return a.people<b.people;
}
priority_queue<range> heap;
int d[1024],maxt[1024],delay[1024],amt[1024];
int t,a,b,n,m,k,ans;
int main(){
    cin>>n>>m>>k;
    for(int i=2;i<=n;i++){
        cin>>d[i];
    }
    for(;m;m--){
        cin>>t>>a>>b;
        ans-=t;
        maxt[a]=max(maxt[a],t);
        amt[b]++;
    }
    for(int i=2;i<=n;i++){
        maxt[i]=max(maxt[i],maxt[i-1]);
        ans+=maxt[i]*amt[i];
    }
    for(int i=2;i<=n;i++){
        maxt[i]=max(maxt[i],maxt[i-1]);
    } 
    maxt[n+1]=0x7fffffff; 
    amt[n+1]=0;
    ;
    for(int i=2,now=maxt[1];i<=n;i++){
        now+=d[i];
        delay[i]=now-maxt[i];
        if(now<maxt[i]){
            now=maxt[i];
        }
            
        
    }
    range now;
    now.l=1;now.r=n+1;
    now.people=0;
    for(int i=2;i<=n;i++){
        now.people+=amt[i];
    }
    heap.push(now);
    while(k&& !heap.empty()){
        
        now=heap.top();
        heap.pop();
        if(now.l==now.r) continue;
        int mind=0x7fffffff,mindid=0;
        for(int i=now.l;i<now.r;i++){
            if(delay[i]<mind){
                mind=delay[i];
                mindid=i;
            }
        }
        
        mind=max(min(k,mind),0);
        for(int i=now.l;i<=now.r;i++){
            delay[i]-=mind;
        }
        k-=mind;
        range a;
        a.l=now.l;
        a.r=mindid;
        a.people=0;
        for(int i=a.l;i<=a.r;i++){
            a.people+=amt[i];
        }
        heap.push(a);
        a.l=mindid+1;
        a.r=now.r;
        a.people=0;
        for(int i=a.l;i<=a.r;i++){
            a.people+=amt[i];
        }
        heap.push(a);
    }
    for(int i=2;i<=n;i++){
        ans+=amt[i]*delay[i];
    }
    cout<<ans;
}
```

复杂度是O(n^2)

~~这道题有一种2b写法：平衡树实现区间减操作和堆~~

~~瞬间O(n log n)~~

---

## 作者：天泽龟 (赞：4)


## **题面：**

有n个景点，相邻景点需要花费$D_i$时间，一辆巴士$t=0$时停在一号位置，有m个乘客在$t_i$时候到达$a_i$景点并前往$b_i$，可以在任意时候缩短1秒，可用k次。问乘客总等待时间？

## **题解：**

一道贪心题成功被玩成了费用流，真的难以置信。。感觉我所缺乏的正是大佬的这种开拓的思维，只知道一昧的抄题解是没有好下场的。。

回归正题，由于博客$TOP1$的大佬仅叙述了如何建模而没提他的思维过程。**这篇题解的目的就是帮助大家更好地理解本题的建模。**
希望大家看完题解后会有一种~~惶然~~恍然大悟之感。

---

我们首先考虑不用任何加速器得到的最终时间为多少，易知这是一个定值，且可由一下递推关系得到：

$$T[i]=\max(T[i-1],L[i-1])+d[i]$$

$T[i]$即为所得，其中$L[i]$为在第i景点最晚的上车时间，还是很好理解的。

那么，问题就转化为了：给你k个加速器，使总等待时间最大可以缩短多少？对于这个问题，我们可以通过建模，对于`加速器的个数`这一变量使用**费用流**求解。
其实，与其说是费用，我更认为这里应该叫作**贡献**，我们所有的操作都应该围绕当前流量的加速器会对答案产生多大的贡献来连边。

我们先定义超源$S^{*},S$，超汇$T$。
 
1. 为了限制条件`仅由k个加速器`，我们将$S^{*}$连边至$S$，容量$k$，无费用

2. 我们知道，对于任何第i景点，$L[i]$都是一个无法加速的时间段，所以实际上加速器真正有贡献的仅有$L[i]-T[i]$这一段时间。为了限制这一条件，我们将每一个景点进行**拆点操作**，分为$i,i+n$两个点，中间用容量为$max(L[i]-T[i],0)$进行限制，无费用。

特殊地，若容量为0，可以理解为由于为了等待新的乘客上车，之前所用的加速器也报废了，所以这些加速器也失去了对之后再产生贡献的机会。

3. 对于之前拆成的两点，也可以考虑成“到达景点i”以及“离开景点i”两个事件发生点。若是如此，对于加速器使用部分很显然应该由$S$连到$i+n$点，容量即为$d[i]$；对于$i$，应有连至$T$的边，容量$inf$，无费用，表示`将 不再有贡献的加速器 扔掉`这么一个事件。

4. 最后也是最重要的，对于`离开景点i`以及`到达i+1`l两点也应该连边，容量$inf$表示可以有若干个加速器对此过程仍有贡献（因为加速器将会直接贡献到乘客，只要乘客不下车，就还会存在贡献），费用即为$-dw[i]$，表示在第i景点下车的乘客，此时的贡献即为**作用在这几位乘客身上的总缩短时间**（由于乘客总会下车，可以保证所有贡献都会被计算到），而这贡献主要来源于新使用的加速器(第三操作)以及之前仍产生贡献的加速器（第二操作）。

然后就没有啦，上我丑陋的代码:
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#define inf 2147483647
using namespace std;

const int ax=30010,s0=20001,S=20002,T=20003;
struct ed{
	int u,nex,w,f;
}e[4*ax];
int n,m,k,dis[ax],t[ax],a[ax],b[ax];
int tx[ax],mx[ax],dw[ax];
int st=-1,ans,fir[ax],c[ax],d[ax],val; bool v[ax];
queue<int> q;

void add(int x,int y,int w,int f)
{
	e[++st].u=y; e[st].nex=fir[x]; e[fir[x]=st].w=w; e[st].f=f;
	e[++st].u=x; e[st].nex=fir[y]; e[fir[y]=st].w=0; e[st].f=-f;
}

bool spfa()
{
	memset(d,0x3f,sizeof(d)); memset(v,0,sizeof(v)); memcpy(c,fir,sizeof(fir));
	q.push(s0); v[s0]=1; d[s0]=0;
	while (!q.empty())
	{
		int k=q.front(); q.pop(); v[k]=0;
		for (int i=fir[k];i!=-1;i=e[i].nex)
		{
			int u=e[i].u,w=e[i].f;
			if (e[i].w&&d[u]>d[k]+w)
			{
				d[u]=d[k]+w; if (!v[u]) v[u]=1,q.push(u);
			}
		}
	}
	return (d[T]<200000);
}

int dfs(int p,int now)
{
	if (p==T) {
		v[T]=1; ans+=now; return now;
	}
	int mw=0,used=0; v[p]=1;
	for (int i=c[p];i!=-1;i=e[i].nex)
	{
		c[p]=i; int u=e[i].u,w=e[i].f;
		if ((!v[u]||u==T)&&e[i].w&&d[u]==d[p]+w)
		{
			if (mw=dfs(u,min(e[i].w,now-used))){
				val+=w*mw; e[i].w-=mw; e[i^1].w+=mw;
				used+=mw; if (now==used) break;
			}
		}
	}
	return used;
}

void dinic()
{
	while (spfa())
	{ 
		v[T]=1; while (v[T]){
			memset(v,0,sizeof(v)); dfs(s0,inf/2);
		}
	
	}
}

int main()
{
	cin>>n>>m>>k; int ans0=0; memset(fir,-1,sizeof(fir));
	for (int i=1;i<=n-1;i++) cin>>dis[i];
	for (int i=1;i<=m;i++) {
		cin>>t[i]>>a[i]>>b[i];
		mx[a[i]]=max(mx[a[i]],t[i]);
		dw[b[i]]++;
	} tx[1]=0;
	for (int i=2;i<=n;i++) 
		tx[i]=max(tx[i-1],mx[i-1])+dis[i-1];
	for (int i=1;i<=m;i++) ans0+=tx[b[i]]-t[i];
//readin~~~~~

	add(s0,S,k,0);
	for (int i=1;i<=n;i++)
	{
		if (i>1) add(i,i+n,max(tx[i]-mx[i],0),0),add(i,T,inf/2,0);
//		when step.i , only (t-mx) can be valued
		if (i<n) add(S,i+n,dis[i],0),add(i+n,i+1,inf/2,-dw[i+1]);
//		d[i] speed_ups can be used
		
//		if flow is limited , it turns to T
	} 
	dinic(); 
	cout<<ans0+val<<endl;
}
```

---

## 作者：Onsin (赞：3)

## **贪心，最终复杂度是 $O(kn)$**
一点题外话：当时写题时我还担心 $O(kn)$ 过不了呢，结果交完发现别的题解最坏 $O(kn^2)$ 都过了，~~数据还是比较随和的。~~


### **分析题意**
其实我们可以分三步考虑这个问题：
1. 不接乘客公交车开过全程。
2. 要接完乘客开过全程。
3. 加速后开过全程。

**第一种情况**只需要知道景点之间的距离 $dis[i]$ 就可以做了，我们用 $arrive$ 数组表示公交车到该点时的绝对时间，$arrive$ 数组的值我们用折线图表示。（数据不重要，随便标）
![arrive折线图](https://cdn.luogu.com.cn/upload/image_hosting/sas0ycex.png)
**第二种情况**我们要注意，在当前景点的所有人到齐上车之前，车是不能开走的。容易想到用 $threshold$ 数组储存每个景点的最晚到达乘客的到达时间，并表现在图上。  
并且很明显 $arrive$ 出发点不能低于 $threshold$ 时间，所以我们需要抬升该出发点。这一做法又会影响后续所有点的 $arrive$。如图：  
![加入threshold](https://cdn.luogu.com.cn/upload/image_hosting/nnjuezeb.png)  
我们可以看到折线因此不再连续，我们把不连续的位置称为切断点（其满足 $threshold_{i} \ge arrive_{i}$ ），用 $cutPoint$ 储存，折线图最后变成这样：
![最终折线图](https://cdn.luogu.com.cn/upload/image_hosting/hhey4y7j.png)
**最后一种情况**最为复杂，我们要使用加速器在最好的那条路上。哪条路最好呢？我们考虑以下过程：（$t$ 为该乘客旅行用时）  
$t_{i} \gets arrive_{B_{i}}-T_{i}$  
可以看到其实乘客的旅行时间只取决于其旅行终点的到达时间（$T_{i}$ 恒定），所以我们只需要尽量减少旅行终点的 $arrive$ 即可。我们可以用 $welfare$ 数组记下每个景点是多少乘客的旅行终点，即这个景点的 $arrive$ 减少后能造福多少乘客。  
由于减少一条路的 $dis$ 会减少后面一系列景点的 $arrive$，我们要知道的就是这一个减少区间的 $welfare$ 总和。减少区间有什么特点呢？我们看图：  
![dis--](https://cdn.luogu.com.cn/upload/image_hosting/rq39gw69.png)  
可以看到，$arrive$ 减少的传递最多只能到达下一个切断点。这张图同样也能告诉我们一个贪心点——在两个切断点之间夹着的一个区间里，加速器越早用越好。显然用在这个区间的无论哪一条路上所产生的 $arrive$ 影响都一定能传递到区间末尾。所以我们可以遍历 $cutPoint$ 然后从那里开始求区间 $welfare$ 和（这里遍历一遍就可以了），最后取最优解。把这个步骤循环 $k$ 次，就可以用完所有的加速器了。每一次用加速器至多把每个景点遍历一遍，故复杂度最坏 $O(kn)$  
**但是**还有一个点要注意，每一条路 $dis \ge 0$ ，所以如果 $cutPoint$ 后面的那条路不能使用加速器的话，我们要找到其后面第一个 $dis \ge 0$ 的点。（或者直到下一个切断点，这说明这个区间不可被加速）  
### 我们结合代码把整个过程再过一遍：
首先，我们要从乘客数据中获取每个景点的 $threshold$ 和 $welfare$
```cpp
int T[N] , A[N] , B[N];
for( rint i=1; i <= m; ++i ){
	scanf("%d%d%d", T+i , A+i , B+i );
	threshold[ A[i] ] = max( threshold[ A[i] ] , T[i] );
	++ welfare[ B[i] ];
}
```
其次，我们跑一遍获得初始 $arrive$ 和 $cutPoint$

```cpp
for( rint i=1; i <= n; ++i ){
	arrive[i] = max( arrive[i-1] , threshold[i-1] ) + dis[i-1];
	if( arrive[i] <= threshold[i] )	cutPoint[++p] = i;
}
```
最后，我们套 $k$ 循环，先找到最适区间，再使用加速器。

```cpp
while( k-- ){//挂加速器
	int maxn=-1 , tar=0;
	for( rint i=1; i <= p; ++i ){//找到最合适的切断点 
		int pos = cutPoint[i];
		while( !dis[pos] ){//该点不可用加速，找该点后一个 
			++pos;
			if( arrive[pos]<=threshold[pos] || pos>=n ){//已经找到下一个切断点了，不属于本次循环的范畴 
				pos = -1;
				break;
			}	
		}	
		if( pos == -1 )	continue; //本区间不可加速，尝试下一个切断点 
		
		int decline=0;//该区间用加速器可以造福多少人（减少多少时间） 
		int ls = pos;//记一下在哪里用的加速器 
		while( ++pos ){//若把加速器用在该点后，能造福多少游客 
			decline += welfare[pos];
			if( arrive[pos]<=threshold[pos] || pos>=n )	break;
		}
		if( maxn < decline )	maxn = decline , tar = ls;//取最大造福点
	}
	-- dis[tar];//确定使用加速器
	while( ++tar ){ 
		-- arrive[tar];
		if( arrive[tar] == threshold[tar] )	cutPoint[++p] = tar;//造出了一个切断点 
		else if( arrive[tar] < threshold[tar] )	break;//本就存在的切断点，即查找时的终止点
	}
}
```
求出答案，完结。

```cpp
for( rint i=1; i <= m; ++i )	ans += arrive[ B[i] ]-T[i]; 
```
最后是完整的代码。
```cpp
#include <bits/stdc++.h>
#define N 10002
#define rint register int//有没有不影响 
using namespace std;
int n , m , k;
int dis[N] , arrive[N] , welfare[N] , threshold[N];
int cutPoint[N] , p=1;
long long ans; 

int main(){
	scanf("%d%d%d", &n , &m , &k );
	for( rint i=1; i < n; ++i )	scanf("%d", dis+i );//输入dis 
	int T[N] , A[N] , B[N];
	for( rint i=1; i <= m; ++i ){//输入、预处理乘客数据 
		scanf("%d%d%d", T+i , A+i , B+i );
		threshold[ A[i] ] = max( threshold[ A[i] ] , T[i] );
		++ welfare[ B[i] ];
	}
	for( rint i=1; i <= n; ++i ){//预处理arrive并且找到切断点 
		arrive[i] = max( arrive[i-1] , threshold[i-1] ) + dis[i-1];
		if( arrive[i] <= threshold[i] )	cutPoint[++p] = i;
	}
	while( k-- ){//挂加速器
		int maxn=-1 , tar=0;
		for( rint i=1; i <= p; ++i ){//找到最合适的切断点 
			int pos = cutPoint[i];
			while( !dis[pos] ){//该点不可用加速，找该点后一个 
				++pos;
				if( arrive[pos]<=threshold[pos] || pos>=n ){//已经找到下一个切断点了，不属于本次循环的范畴 
					pos = -1;
					break;
				}	
			}	
			if( pos == -1 )	continue; //本区间不可加速，尝试下一个切断点 
			
			int decline=0;	int ls = pos;//记一下在哪里用的加速器 
			while( ++pos ){//若把加速器用在该点后，能造福多少游客 
				decline += welfare[pos];
				if( arrive[pos]<=threshold[pos] || pos>=n )	break;
			}
			if( maxn < decline )	maxn = decline , tar = ls;//取最大造福点
		}
		-- dis[tar];//确定使用加速器
		while( ++tar ){ 
			-- arrive[tar];
			if( arrive[tar] == threshold[tar] )	cutPoint[++p] = tar;//造出了一个切断点 
			else if( arrive[tar] < threshold[tar] )	break;//本就存在的切断点 ，即查找时的终止点
		}
	}
	for( rint i=1; i <= m; ++i )	ans += arrive[ B[i] ]-T[i]; //获得总时间 
	printf("%lld", ans );//完结撒花 
	return 0;
}
```

---

## 作者：Zyj6 (赞：3)

## 做法

考虑贪心，每一个景点的出发时间肯定为最晚到这个景点的时间的人与车到这的时间的最小值，但如果正常贪心会有后效性，但可以解决这个后效性。

**结论**：在一个路段用一个加速器的景点的到达时间，有两种可能：

* 加完速后，到达下一个景点，出现**车等人**，这是只有这个景点的人受到影响。

* 加完速后，到达下一个景点，出现**人等车**，后面的景点的人的时间也受到影响，则继续找下一个景点，直到出现情况1，则这个景点才是能影响到的最后面的景点。

首先，我们将没有用过加速器的答案跑一边，顺便统计每个景点与每个景点之间受影响的人（前缀和），再统计车到达每一个景点的时间。

接着，跑 $k$ 遍，每一遍将一个加速器用在一个地方，定一个 $g$ 数组，统计 $i$ 道路能影响到的最远景点（用结论），在跑每条边，在i道路用一个加速器，仅当 $g_i$ 与 $i$ 之间能影响到的人的数目最大，且这条路的长度不为 $0$。

即 $\min(sum_{g_i}-sum_i)$（解释：$sum$ 统计 $1$ 到 $i$ 之间下车的人数，所以 $sum_{g_i}-sum_i$ 为 $i$ 到 $g_i$ 间的下车人数，为什么有些明明也是在这段区间内的人没有统计呢？因为 $g_i$ 表示 $i$ 道路能影响到的最远景点，而在 $g_i$ 之外下车的人就没有影响了）。

最后，记录 $i$ 道路，将其减 $1$，答案也减掉能影响到的人，重新统计一边车到达每一个景点的时间。

## CODE
```c
#include<bits/stdc++.h>
using namespace std;
int a[1005],g[1005],sum[1005];
//sum[i]到达i站点的总人数
//所以sum[i]-s[j]表示i--(j-1)这段中的影响人数 
struct ren
{
	int t,s,e;
}r[10005];
struct zhan
{
	int lk;//最后一个人到i站点的时间 
	int dd;//到k站点的时间 
}s[1005];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&r[i].t,&r[i].s,&r[i].e);
		s[r[i].s].lk=max(s[r[i].s].lk,r[i].t);
		sum[r[i].e]++;
	}
	for(int i=1;i<=n;i++) sum[i]+=sum[i-1];
	int tim=0;
	for(int i=1;i<=n;i++)
	{
		s[i].dd=tim;
		tim=max(s[i].lk,tim);
		tim+=a[i];
	}
	int ans=0;
	for(int i=1;i<=m;i++) ans+=(s[r[i].e].dd-r[i].t);//统计答案
	while(k--)
	{
		g[n-1]=n;
		for(int i=n-2;i>=1;i--)
		{
			if(s[i+1].dd<=s[i+1].lk) g[i]=i+1;
			else g[i]=g[i+1];
		}
		int cnt,maxn=0;
		for(int i=1;i<n;i++)
		{
			int yxr=sum[g[i]]-sum[i];
			if(maxn<yxr&&a[i]>0)
			{
				maxn=yxr;
				cnt=i;
			}
		}
		a[cnt]--;
		ans-=maxn;//直接减
		int tim=0;//重新统计到达时间
		for(int i=1;i<=n;i++)
		{
			s[i].dd=tim;
			tim=max(s[i].lk,tim);
			tim+=a[i];
		}
	}
	printf("%d",ans);
 } 
```

---

## 作者：我梦见一片焦土 (赞：1)

贪心经典题。

很容易就可以想到，贪心策略就是每次选择人数最多的站点使用氮气加速。

我们先求出没有任何氮气加速时的答案（$k=0$），可以使用递推求解。

然后，循环 $k$ 次，每次找到经过人数最多的站点，并且将到达后面的站点的时间 $-1$。

最后统计答案输出即可。

分析一下复杂度：

循环 $k$ 次，每次循环需要 $n^2$，找到人数最多的站点，复杂度为 $O(k\times n^2)$，可以通过 $60\%$ 的数据点。

想办法优化。

我们注意到，每到达一个站点，公交车都会等人来了再走。

于是，我们直接在出现车等人的情况时就 ```break```，虽然这样的时间复杂度依然是 $O(k\times n^2)$，但是远远达不到这个上界。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,k,d[N],wt,ans;
struct node{
	int ks,cf,dd;
}a[N];
struct node1{
	int dd,zw,p;
}b[N];
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<n;i++){
        cin>>d[i];
    }
	for(int i=1;i<=m;i++){
		cin>>a[i].ks>>a[i].cf>>a[i].dd;
		b[a[i].dd].p++;
		b[a[i].cf].zw=max(b[a[i].cf].zw,a[i].ks);
	}
	for(int i=1;i<=n;i++){
		b[i].dd=wt;
		wt=max(wt,b[i].zw)+d[i];
	}
	while(k--){
		int mp=0,mp1=0;
		for(int i=2;i<=n;i++){
			if(!d[i-1]){
                continue;
            }
			int np=0;
			for(int j=i;j<=n;j++){
				np+=b[j].p;
				if(b[j].dd<=b[j].zw){
                    break;
                }
			}
			if(np>mp){
				mp=np;
				mp1=i;
			}
		}
		d[mp1-1]--;
		for(int i=mp1;i<=n;i++){
			b[i].dd--;
			if(b[i].dd<b[i].zw){
                break;
            }
		}
	}
	for(int i=1;i<=m;i++){
		ans+=b[a[i].dd].dd-a[i].ks;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

**【问题分析】**

我首先想到了是贪心算法，肯定把氮气放在人多的时候用，但是考虑到车要等人之类的因素，觉得无法证明其正确性，所以没有采用，那么现在我们来说明一下这个神奇的正确性 ps 显然大法好。。。

首先我们可以得到这样一个性质，即氮气的使用满足最优子结构。无论有几个氮气加速器，第一个的使用都是一样的，所以我们可以对每个加速器进行单独分析，即可采用贪心策略。那么该如何贪心呢？显然，应该讲氮气使用在公交车上面人数较多的时刻上面。那么这个加速器会对多少人造成影响呢？

公交车到一个站之后，可能需要等人，也可能不需要等人，直接开往下一站。那么如果公交车等人了，那么使用氮气加速后也没有效果，所以加速器的作用区间为从使用的那一站开始一直到某一站公交车需要等人为止，这个区间内的所有旅客都可以受益，所以一个氮气加速器的作用应该是这一段区间的和。

**【AC 代码】**
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<vector>
using namespace std;
const int mxn=100010;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,k;
int d[mxn];//路程
int smm[mxn];
int st[mxn];//每站最早出发时间
int dn[mxn];//在某站下车的人数
int ct[mxn],to[mxn];//乘客开始等待时间，目的地
void solve(){
    int i,j;
    while(k--){
        for(i=1;i<n;++i)smm[i+1]=max(smm[i],st[i])+d[i];
        int pos=0,mx=0;
        int tmp;
        for(i=1;i<n;++i){
            if(d[i]<=0)continue;
            tmp=0;
            for(j=i+1;j<=n;j++){
                tmp+=dn[j];
                if(smm[j]<=st[j])break;
            }
            if(tmp>mx){
                mx=tmp;pos=i;
            }
        }
        if(!pos)return;
        d[pos]--;
    }
    return;
}
int main(){
    n=read();m=read();k=read();
    int i,j;
    for(i=1;i<n;++i)d[i]=read();
    int s,x,y;
    for(i=1;i<=m;++i){
        ct[i]=read();x=read();to[i]=read();
        st[x]=max(st[x],ct[i]);
        dn[to[i]]++;
    }
    solve();
    for(i=1;i<n;i++){
        smm[i+1]=max(smm[i],st[i])+d[i];
    }
    int ans=0;
    for(i=1;i<=m;++i){
        ans+=smm[to[i]]-ct[i];
    }
    printf("%d\n",ans);
    return 0;
}

```

---


# [NOIP 2010 提高组] 引水入城

## 题目背景

NOIP2010 提高组 T4

## 题目描述

在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 $N$ 行 $M$ 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。

![](https://cdn.luogu.com.cn/upload/image_hosting/rcqfo04b.png)



为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。

因此，只有与湖泊毗邻的第 $1$ 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第 $N$ 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。


## 说明/提示

**样例 1 说明**

只需要在海拔为 $9$ 的那座城市中建造蓄水厂，即可满足要求。

**样例 2 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/qoz3f0lv.png)

上图中，在 $3 $ 个粗线框出的城市中建造蓄水厂，可以满足要求。以这 $3 $ 个蓄水厂为源头在干旱区中建造的输水站分别用 $3$ 种颜色标出。当然，建造方法可能不唯一。

**数据范围**

本题有 10 个测试数据，每个数据的范围如下表所示：

| 测试数据编号 | 能否满足要求 | $N\le$ | $M\le$ |
| :----------: | :----------: | :----------: | :----------: |
| 1 | 不能 | $10$ | $10$ |
| 2 | 不能 | $100$ | $100$ |
| 3 | 不能 | $500$ | $500$ |
| 4 | 能 | $1$ | $10$ |
| 5 | 能 | $10$ | $10$ |
| 6 | 能 | $100$ | $20$ |
| 7 | 能 | $100$ | $50$ |
| 8 | 能 | $100$ | $100$ |
| 9 | 能 | $200$ | $200$ |
| 10 | 能 | $500$ | $500$ |

对于所有 10 个数据，每座城市的海拔高度都不超过 $10^6$。

## 样例 #1

### 输入

```
2 5
9 1 5 4 3
8 7 6 1 2
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
3 6
8 4 5 6 4 4
7 3 4 3 3 3
3 2 2 1 1 2```

### 输出

```
1
3```

# 题解

## 作者：ctq1999 (赞：153)

[传送门](https://www.luogu.org/problem/P1514)

这题有个证明比较难想（其他题解都没看懂），其他还好。

## 题面简述

有一个矩形。矩形上的格子有不同高度。你可以在第一行（x = 1）的任意多个格子放水，水会沿低的格子一直落下来。

要求能否使最后一行（x = n）所有格子有水。

## 思路

前置知识： 搜索

对于水流的过程的搜索就不多阐述了

对于最后一行没有标记的格子直接统计并输出即可

对于有解（最后一行全部覆盖）的最少统计：

经过思考可以发现一个水流到最后一行的覆盖必是一个连续的线段

---

#### 证明：

**前提：有解**

假设有一条水流是这样的

![图片.png](https://i.loli.net/2019/10/27/7TLJNF3rh1mg4xC.png)

若有解，则必定有另一条水流流到图中蓝色区域

![图片.png](https://i.loli.net/2019/10/27/VZAz2wqTIRk8tKa.png)

则棕线（第二条水流）必与黑线有交点

![图片.png](https://i.loli.net/2019/10/27/CoNBg1i5bYtTdse.png)

棕线流到蓝色区域，黑线也可从红点处流入蓝色区域

与假设矛盾，所以有解时，一条水流必定有连续区间

再不懂看这个

你的水流可以长这样（蓝色是不能流到的区域）

![图片.png](https://i.loli.net/2019/10/27/Hg1ZwlJzVdSrhqO.png)

但这样的话

![图片.png](https://i.loli.net/2019/10/27/VZAz2wqTIRk8tKa.png)

别的水一定流过不去了呀（否则它自己也过去了），所以这样一定无解

---

于是我们可以在最后一行贪心，从(n, 1)开始，不断找一个左端点在上一个右端点之内，右端点最远的区间。不要说着说着忘记统计区间了（笑

更多细节看程序

懂的话尽量自己写，否则没什么收获的

```cpp
#include <bits/stdc++.h>

#define MAXN 1010

using namespace std;

int n, m;

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};//方向数组 方便搜 

int vis[MAXN][MAXN];

int h[MAXN][MAXN], l[MAXN][MAXN], r[MAXN][MAXN];

void dfs(int x, int y) {
	vis[x][y] = 1;
	for (int i = 0; i < 4; i++) {
		int x1 = x + dx[i];
		int y1 = y + dy[i];
		if (x1 < 1 || x1 > n || y1 < 1 || y1 > m || h[x][y] <= h[x1][y1]) continue;
		if (!vis[x1][y1]) dfs(x1, y1);
		//注意  若(x1, y1)格子已经过就不用搜了
		//但    l和r还是要更新的 
		l[x][y] = min(l[x][y], l[x1][y1]);
		r[x][y] = max(r[x][y], r[x1][y1]);
	}
}

int main() {
	scanf("%d%d", &n, &m);
	memset(l, 21000000, sizeof(l));
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", &h[i][j]);
			if (i == n) l[i][j] = r[i][j] = j;//最后一行初始化 
		}
	}	
	
	for (int i = 1; i <= m; i++) {
		if (!vis[1][i]) dfs(1, i);//若这格已经搜过了就不用搜了 
	}
	
	bool check = true;
	int ans = 0;
	
	for (int i = 1; i <= m; i++) {
		if (!vis[n][i]) {
			check = false;
			ans++;		
		}
	}
	
	if (!check) {
		cout << 0 << endl << ans << endl;
		return 0;
	}
	
	int left = 1, right = r[1][1];
	
	//统计区间数 
	while (left <= m) {
		for (int i = 1; i <= m; i++) {
			if (l[1][i] <= left) {
				right = max(right, r[1][i]);
			}
		}
		
		left = right + 1;
		ans++;
	}
	
	cout << 1 << endl << ans << endl;
	return 0;
} 
```

> 日拱一卒，功不唐捐

---

## 作者：天上一颗蛋 (赞：103)

思路各位大佬讲的都很明白了

蒟蒻就补个证明帮大家理理思路吧

[摘自 ~~大大大蒟蒻~~我の博客](https://www.cnblogs.com/Tony-Double-Sky/p/9871976.html)

---

欲证： 对于第一行的每个水库 $x_{i}$ 流出的水， 他能覆盖的最后一行情况必然是一个**连续的区间**

反证法：

假设存在一种情况使得覆盖情况如下， 覆盖不连续：
![](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fwp8b23bjrj30rs0qodkf.jpg)
假设蓝色覆盖路线如下：
![](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fwp8devhi8j30rs0qodkx.jpg)
因为右边红色被覆盖了， 所以从红色水库到下方必然有一条路径
![](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fwp8hycydfj30rs0qo0y4.jpg)
发现路径必有交（紫色部分）， 所以红色水库的水也会流入蓝色那部分， 假设不成立

故一座水库能覆盖的最后一行必然是一个**连续的区间**

证毕。

[全文](https://www.cnblogs.com/Tony-Double-Sky/p/9871976.html)

### upd 2019.11.11

我已经退役啦， 看到评论说的的， 证明确实有不足， 这里进行补充

引用评论区@Asurudo：（感谢这位小伙伴）

@Asurudo ：“如果蓝色那部分干旱区很高，没有水流可以流到，则红色的水流可分叉。有一个样例就是这种情况，如果用这个结论去把区间当作连续的做，则红色可以流到本来流不到的地方。所以用此结论的前提是干旱区都能流到，否则不能用！”

---

S9咱又夺冠啦！希望我高考也能顺利哈。

---

## 作者：_std_O2 (赞：20)

# P1514 [NOIP2010 提高组] 引水入城题解
## 简要题意
在第 $1$ 行的城市中放最少的蓄水厂，（水向低处流）使第 $n$ 行的城市中全都有水流到。
## 特殊性分析

证明如果满足第 $n$ 行的城市中全都有水流到时，对于每个蓄水厂的水流到第 $n$ 行的城市中覆盖的范围是一个区间。

在下图的第 $4$ 行第 $3$ 列中没有水覆盖。

![](https://s21.ax1x.com/2025/01/19/pEkcLqK.png)

而因为在满足第 $n$ 行的城市中全都有水流到的这个条件，所以肯定有另几个蓄水厂能将水运到第 $4$ 行第 $3$ 列。
而另几个蓄水厂运水的路线**肯定要穿过蓝色的路线**（如下图）。

![](https://s21.ax1x.com/2025/01/19/pEkcjaD.png)

所以蓝色经过的路线就可以在蓝色与红色的交点处转弯，走红色的部分到达（如下图）。

![](https://s21.ax1x.com/2025/01/19/pEkcXVO.png)

所以猜想成立

## 思路
将每个蓄水厂所能覆盖到第 $n$ 行的区间记录下来（尝试在第 $1$ 行的每个位置都放蓄水厂），也就等同于记录在第 $n$ 行的每个城市能接收到哪几个蓄水厂的水。

因为我们需要最小化蓄水厂的数量，所以考虑贪心。

### 贪心方案：
对于在第 $n$ 行的每个城市来说，如果他能接收到的几个城市的蓄水厂中有已经确定要建蓄水厂的城市了那就不管他，否则建造**从它开始覆盖长度最长的那个蓄水厂**。

### 正确性证明：
如果已经可以收到确定建造的蓄水厂的水了，如果这时再建新的蓄水厂，这时的答案肯定更劣。

对于建造**从它开始覆盖长度最长的那个蓄水厂**的原因肯定就是显而易见的了。

## code
如果你还是不明白，那就看下代码吧！

最终时间复杂度 $O(nm^{2})$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=501;
vector<int> water[N];//在第 n 行第 i 列的城市有哪些在第 1 行蓄水厂的水可以到达。
//也就是在第 n 行第 i 列的城市能接收到水的蓄水厂编号的集合。
//例如 water[3]={1,2,4} 就表示在第 n 行第 3 列的城市能接收到在第 1 行第 1,2,4 列城市所建的蓄水厂的水
int mp[N][N],n,m,last[N];
bool vis[N][N],flag[N];
//flag[i] 表示第 1 行的第 i 列的城市是否确定要放蓄水厂 
struct node{
	int x,y,h;
};
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
    	if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
queue<node> q;
void bfs(int x){
	memset(vis,0,sizeof(vis));
	q.push({1,x,mp[1][x]});
	while(!q.empty()){
		int nx=q.front().x,ny=q.front().y,nh=q.front().h;
		q.pop();
        if(vis[nx][ny]) continue;
		vis[nx][ny]=1;
		if(nx==n) water[ny].push_back(x);//如果流到第 n 行了就记录这个城市可以收到哪些蓄水厂的水 
		if(nx+1<=n && mp[nx+1][ny]<nh) q.push({nx+1,ny,mp[nx+1][ny]}); //bfs 模拟水流。
		if(ny+1<=m && mp[nx][ny+1]<nh) q.push({nx,ny+1,mp[nx][ny+1]});
		if(nx-1>=1 && mp[nx-1][ny]<nh) q.push({nx-1,ny,mp[nx-1][ny]});
		if(ny-1>=1 && mp[nx][ny-1]<nh) q.push({nx,ny-1,mp[nx][ny-1]});
	}
}

int main(){
	cin>>n>>m;
	int ans=0,op_ans=1,ans2=0;
	for(register int i=1;i<=n;i++) for(int j=1;j<=m;j++) mp[i][j]=read();
	for(register int i=1;i<=m;i++) bfs(i);//尝试在第 1 行的第 i 列的城市上放蓄水厂 
	for(register int i=1;i<=m;i++) if(!water[i].size()) op_ans=0,ans2++;//如果在第 n 行有城市不能收到水就无解 
	if(!op_ans){
		cout<<0<<endl<<ans2;
		return 0;
	}
	for(register int i=1;i<=m;i++) for(int j=0;j<water[i].size();j++)last[water[i][j]]=i;//记录最后一次出现来判断覆盖的区间是否最大 
	for(register int i=1;i<=m;i++){
		bool flag2=0;
		for(register int j=0;j<water[i].size();j++)if(flag[water[i][j]]==1){flag2=1;break;}//已经有确定建造的了。
		if(flag2==0){//如果不包含确定建造的蓄水厂 
			ans++;
			int max_last=0,maxj=0;
			for(register int j=0;j<water[i].size();j++) if(last[water[i][j]]>max_last) max_last=last[water[i][j]],maxj=j;
			flag[water[i][maxj]]=1;//选择覆盖的区间最大的蓄水厂来建。
		}
	}
	cout<<1<<endl<<ans;
	return 0;
}
```
码字不易，给个赞吧QwQ。

---

## 作者：niuzh (赞：8)

### 思路

首先考虑问题一，只用将上面每个点都当做起点进行 dfs 即可。

如果有沙漠边的城市无法到达，则直接统计可以到达的个数。

如果都可以到达，考虑第二问。

根据样例解释进行合理猜测：每个可以建造蓄水厂的城市所能给供水的城市刚好是一个区间。

假设目前某个蓄水厂能给某些城市供水。

![](https://cdn.luogu.com.cn/upload/image_hosting/o2nt1t9q.png?x-oss-process=image/resize,m_lfit,h_850,w_1125)

证也能给橙色的城市供水。

由于当前每个靠近沙漠的城市都可以由蓄水厂供水，则必有某个蓄水厂能给橙色城市供水。

![](https://cdn.luogu.com.cn/upload/image_hosting/p187thgj.png?x-oss-process=image/resize,m_lfit,h_850,w_1125)

此时可以发现，这个线路与蓝色蓄水厂可搭建的线路重合，则蓝色蓄水厂肯定沿着绿色线路可以给橙色城市供水。

![](https://cdn.luogu.com.cn/upload/image_hosting/2oxbcovz.png?x-oss-process=image/resize,m_lfit,h_850,w_1125)

所以每个可以建造蓄水厂的城市所能给供水的城市刚好是一个区间。

只用在第一次搜索中求出区间并找最少多少个区间能覆盖所有靠近沙漠的城市即可。

### 代码

```cpp
/*
 * @FilePath: test.cpp
 * @Author: niu-zh
 */
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+10,dx[]={-1,0,1,0},dy[]={0,1,0,-1};
int n,m,h[N][N],l[N][N],r[N][N];
bool vis[N][N];
void dfs(int x,int y)
{
	for (int i=0; i<4; i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if (nx<1||nx>n||ny<1||ny>m||h[x][y]<=h[nx][ny])
		{
			continue;
		}
		if (!vis[nx][ny])
		{
			vis[nx][ny]=1;
			dfs(nx,ny);
		}
		l[x][y]=min(l[x][y],l[nx][ny]);
		r[x][y]=max(r[x][y],r[nx][ny]);
	}
}
int main()
{
	cin>>n>>m;
	memset(l,0x3f,sizeof(l));
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			cin>>h[i][j];
			if (i==n)
			{
				l[i][j]=r[i][j]=j;
			}
		}
	}
	for (int i=1;i<=m;i++)
	{
		if (!vis[1][i])
		{
			vis[1][i]=1;
			dfs(1,i);
		}
	}
	bool flag=0;
	int ans=0;
	for (int i=1;i<=m;i++)
	{
		if (!vis[n][i])
		{
			flag=1;
			ans++;
		}
	}
	if (flag)
	{
		cout<<0<<'\n'<<ans;
		return 0;
	}
	int idx=1,maxx=0;
	while (idx<=m)
	{
		for (int i=1;i<=m;i++)
		{
			if (l[1][i]<=idx)
			{
				maxx=max(maxx,r[1][i]);
			}
		}
		idx=maxx+1;
		ans++;
	}
	cout<<1<<'\n'<<ans;
	return 0;
}
```

---

## 作者：崔泽禹 (赞：4)

# [P1514 NOIP2010 提高组 引水入城](https://www.luogu.com.cn/problem/solution/P1514)题解

## 解题思路

* 判断最后一行是否全部都能流到，枚举、深搜（或广搜）第一行蓄水厂，边判断、边记录**每一个蓄水厂在最后一行能流到的区间**，这里注意：**如果最后一行全部都能流到，那么每一个蓄水厂在最后一行能流到的区间一定是连续的**，稍后证明。

* 既然说一个每一个蓄水厂在最后一行能流到的区间一定是连续的，那么在这个区间最少用的蓄水站个数就是 $1$，于是就可以看作为**区间动态规划**，稍后推导。

## 证明推导

1. 对于“如果最后一行全部都能流到，那么每一个蓄水厂在最后一行能流到的区间一定是连续的”的证明：

    使用反证法，**如果最后一行全部都能流到，假设每一个蓄水厂在最后一行能流到的区间不是是连续的**，既在不连续的部分没有水流到，也就是这个没有水的部分高度一定比“左”、“上”、“右”高，**那么不可能有水能够流到这个部分，与假设矛盾，所以结论成立**。

    示例一，周围高度逐渐降低：

    ![example-1](https://cdn.luogu.com.cn/upload/image_hosting/sf3lpp9o.png)

    不可能有水流到达被标红色的位置。

    示例二，存在“往回走”的情况，在样例一的基础上更改一个数据：

    ![example-2](https://cdn.luogu.com.cn/upload/image_hosting/szmyl20w.png)

    不可能有水流到达被标红色的位置。

    也就是说，不可能存在“交叉水道”。

2. 区间动态规划的使用：

    用 $dp_{i,j}$ 表示从 $i$ 到 $j$ 所需要的最少蓄水厂，答案为 $dp_{1,m}$。既然已经记录了每个蓄水厂在最后一行能流到的区间 $pl$ 与 $pr$，即：

    $$dp_{pl,pr} \gets 1$$

    并且其中的每个子区间赋值为 $1$，用来初始化，也就是：

    $$dp_{i,j} \gets 1, \quad \forall (i,j) \in [pl, pr] \times [pl,pr].$$

    区间动态规划的转移方程：

    $$dp_{i,j}=\min(dp_{i,k},dp_{k+1,j}), \quad i,j\in{[1,m]}$$

## 完整代码

```cpp
#include <bits/stdc++.h>
#define pl p[i].l
#define pr p[i].r
using namespace std;
const int N = 505, M = 505;
struct Node {
    int l, r;
};
Node p[M];
bool vis[N][M];
bool flow[M];
int n, m;
int h[N][M];
int tl, tr;
int cnt = 0;
int tmp;
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
int dp[M][M]; 
bool in(int x, int y) {
    return x >= 1 && x <= n && y >= 1 && y <= m;
}
void check(int x, int y) {
    vis[x][y] = true;
    for (int i = 0; i < 4; i++) {
        int tx = x + dx[i];
        int ty = y + dy[i];
        if (!vis[tx][ty] && in(tx, ty) && h[x][y] > h[tx][ty]) {
            check(tx, ty);
        }
    }
    return;
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> h[i][j];
        }
    }
    for (int i = 1; i <= m; i++) {
        memset(vis, 0, sizeof(vis));
        check(1, i);
        tmp = 0;
        for (int j = 1; j <= m; j++) {
            flow[j] += vis[n][j];
            tmp += vis[n][j];
        }
        if (tmp) {
            tl = 0;
            while (!vis[n][tl]) {
                tl++;
            }
            tr = tl;
            while (vis[n][tr]) {
                tr++;
            }
            pl = tl;		//（包含 l） 
            pr = tr - 1;	//（包含 r） 
        } else {
            pl = 0;
            pr = -1;
        }
    }
    for (int i = 1; i <= m; i++) {
        if (!flow[i]) {
            cnt++;
        }
    }
    if (cnt) {
        cout << 0 << endl;
        cout << cnt;
    } else {
        memset(dp, 0x3f, sizeof(dp));
        for (int i = 1; i <= m; i++) {
            for (int il = pl; il <= pr; il++) {
                for (int ir = il; ir <= pr; ir++) {
                    dp[il][ir] = 1;
                }
            }
        }
        for (int len = 1; len <= m; len++) {
            for (int i = 1, j; i <= m - len + 1; i++) {
                j = i + len - 1; 
                for (int k = i; k <= j; k++) {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                }
            }
        }
        cout << 1 << endl;
        cout << dp[1][m];
    }
    return 0;
}
```

---

## 视频讲解

![video](bilibili:BV1y3411Z7UQ)

---

## 作者：IGA_Indigo (赞：2)

## 题目大意
有一个 $n\times m$ 的格子，第一行可以建造蓄水池，最后一行是沙漠，询问最少建造多少个蓄水池可以滋润到所有的沙漠土地，如果不能滋润到所有的沙漠土地，就输出有多少个沙漠土地不能被灌溉。
## 大体思路
### just 避雷
这里有个比较典型的错误思路，注意不要掉进坑里，就是**不要**从蓄水池行贪心找最大值，这看上去很对，但是我们一旦找一个例子你就傻了。

![](https://cdn.luogu.com.cn/upload/image_hosting/z2th0xck.png)

我们其实选择 $6$ 这个点就可以灌溉所有的沙漠块，但是选择 $7$ 只能灌溉一个，原因是被相同点数的块卡住了。

这种方式或许在无论什么块都需要滋润的题中有效，但在这个题中是不行的。
### 正确思路
首先我们先从每一个蓄水区开始深搜，由于题目数据比较小，我们无需进行一些记忆化的操作，用 $sf$ 数组记录每一个沙漠块能否被灌溉到，用 $edge$ 二维数组记录当前蓄水池能否灌溉到对应沙漠块（像一条条边一样的，能否连接）。当然了，我们这里还可以记录左端点右端点来优化，但还是由于题目数据较小，我们可以朴素的写连边的方式。

这样 DFS 后，我们就判断能不能全部滋润，如果不能就赶紧给出不能的答案，前面我们已经处理过了。

观察可以得到（看到题解区都有所证明，我就不进行证明了），每一个蓄水池在沙漠块的灌溉是一个连通块，没错是连续的，这样引诱着我们想到一个做法——从沙漠块开始贪心。

我的方法是，先找到灌溉最长的从第一个沙漠块开始的蓄水池，并选择他，记录他能滋润到的最远沙漠块，然后进入循环。

在循环中，我们从能滋润到的最远沙漠块的后一个块从后向前开始询问，选择它能够滋润到的最远沙漠块是哪里，记录最大值，并选择，就这样循环一直到最后一个块被滋润。

这里就有各种实现方式可以选择，我比较喜欢朴素的实现方式，如果实在想不到实现方式的，可以看下面的代码及每一步的优化建议。
## Code
题解区题解各有所长，方法也不尽相同，为了不显得那么平平无奇，我的长处就是朴素且详细注释的代码！力求每一个新手都能看得懂。

（以及优化建议）
``` cpp
#include<bits/stdc++.h>
using namespace std;
long long read(){
	long long x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
void write(long long x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return ;
}
int n,m;
int tu[505][505];
bool vis[505][505];//当前蓄水池的遍历有没有走过这个点 
bool sf[505];//标记这个点是否能被滋润
bool edge[505][505];//第一维是蓄水池，第二维是沙漠，连接表示该蓄水池能滋润对应沙漠 
int xx;
void dfs(int x,int y){//深搜找每个沙漠地带会被哪几个蓄水厂滋润到 
	vis[x][y]=1;//打上标记，这一次遍历中不会再来了 
	if(x==n){
		sf[y]=1;
		edge[xx][y]=1;
	}
	
	if(x-1>=1&&y>=1&&!vis[x-1][y]&&tu[x-1][y]<tu[x][y]){//可以向四个方向搜索 
		dfs(x-1,y);
	}
	if(x>=1&&y-1>=1&&!vis[x][y-1]&&tu[x][y-1]<tu[x][y]){
		dfs(x,y-1);
	}
	if(x>=1&&y+1<=m&&!vis[x][y+1]&&tu[x][y+1]<tu[x][y]){
		dfs(x,y+1);
	}
	if(x+1<=n&&y>=1&&!vis[x+1][y]&&tu[x+1][y]<tu[x][y]){
		dfs(x+1,y);
	}
}
void pans(){//找一片净土来累加答案吧（全写循环里真的太丑了） 
	int sum=0;
	for(int i=1;i<=m;i++){
		if(!sf[i]){
			sum++;
		}
	}
	write(sum);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			tu[i][j]=read();
		}
	}
	for(int i=1;i<=m;i++){
		xx=i;
		dfs(1,i);//时间给的足，我们并不需要记忆化 
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				vis[j][k]=0;//下一次遍历我们仍需记录，所以还得去 
			}
		}
	}
	for(int i=1;i<=m;i++){
		if(!sf[i]){
			puts("0");
			pans();//不可以全部滋润就直接输出答案（译为puts ans(?)） ，可以优化 
			return 0;
		}
	}
	xx=1;//没用的变量重复使用一下吧，记录一下现在在的点坐标
	for(int v=1;v<=m;v++){//时间给的足，不需要提前记录 
		if(!edge[v][1]){
			continue ;
		}
		for(int i=2;i<=m;i++){
			if(edge[v][i]){
				xx=max(xx,i);
			}
			else{
				break ;
			}
		}
	}
	int ans=1;//我们已经选了上一个了，ans初始化为 1 
	while(xx<m){//时间给的足，不需要提前预处理左端点和右端点 
		int xxnext=xx;
		for(int i=xx+1;i>=1;i--){
			for(int k=1;k<=m;k++){//暴力的询问每一个蓄水池是否能到达当前沙漠块（可以优化） 
				if(edge[k][i]){
					for(int j=xxnext+1;j<=m;j++){//我们优化掉无法更新答案的情况 
						if(edge[k][j]){
							xxnext=j;//我们保证小于xxnext的j进不去循环，就能优化更新 
						}
						else{
							break ;
						}
					}			
				}
			}
		}
		xx=xxnext;//前进！ 
		ans++; 
	}//如果已经可以灌溉到最后一寸土地了，那么就跳出循环 
	puts("1");
	write(ans);
	return 0;//程序中所谓“时间给的足”都是可以优化的点，比较简单，这里不在过多说明，本道题也不必要 
}
```
## The End!

---

## 作者：all_for_god (赞：2)

题意：[P1514 \[NOIP 2010 提高组\] 引水入城](https://www.luogu.com.cn/problem/P1514)有点复杂，自己看吧。

## 思路

这里提供一个好像没见过的纯 DP 做法，不需要神秘的证明以及任何脑子，直接顺着思路做即可。

首先判断正确性就是从第一行的每一个点开始暴力搜索，看最后一行有没有点没被走到。最坏情况下第一行的每个点都会遍历以它自己为矩形左上角，地图右下角为右下角的整个矩形（类似于一个地图后缀）。因此搜索总复杂度为 $O(mn^2)$。

在搜索的同时，我们发现我们可以记下从第一行的每个格子能够到达哪些最后一行的格子。这个东西是类比于建图的，我们用邻接矩阵存下来。我们这里设 $bian_{i,j}=0/1$ 表示第一行的某个点 $i$ 可以到达最后一行的某个点 $j$。

然后就是 DP 了。我们设 $f_{i,j}$ 表示在水能填满最后一行前 $i$ 个格子的前提下，仅能使用第一行前 $j$ 个格子建造蓄水厂的最小数量。

由于每一步都要保证最后一行前 $i$ 个格子是被填满的，因此直接暴力枚举从最后一行什么地方转移即可，设转移的地方为 $k$。但是我么还要保证从 $k+1$ 到 $i$ 的这些最后一行的格子一定会被填满，因此要么是 $j-1$ 及其以前的第一行的点就已经可以填满前 $i$ 个格子了，要么是当前这个点 $j$ 可以填满 $k+1$ 到 $i$ 之间的所有格子，从 $f_{k,j-1}$ 转移过来。

具体而言，转移方程如下：

$$
f_{i,j}=\min 
\left\{\begin{matrix} 
 f_{i,j-1} &\\
 f_{k,j-1}+1 &,k\in [0,i-1]\wedge [k+1,i]\text{都可以被} j\text{完全覆盖} 
\end{matrix}\right.
$$

再次强调一下这里的 $i,k$ 是最后一行上的点，$j$ 是第一行上的点。
边界条件即为 $f_{0,i}=0$，答案为 $f_{m,m}$。（不得不说 ccf 数据真的水，我刚开始只把 $f_{0,0}$ 赋值为零得了 90 分，意味着只有一个测试点不在第一行第一个点上建蓄水厂）

然后 DP 枚举了 $i,j,k$ 三个变量，复杂度 $m^3$。由于 $n,m$ 同阶，因此总复杂度 $n^3$ 大概可以过。

## code

实现细节上在 $f_{i,j}$ 从 $k$ 处转移时取了个巧。我们将 $k$ 倒序枚举使得当 $bian_{j,k+1}$ 不为 1 的时候直接 break 即可。（注意我们始终保持的都是 $[k+1,i] \text{都可以被} j \text{完全覆盖}$）

最后代码很短，好写好调。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=505;
int n,m,mp[N][N],sign[N],lx[5]={0,0,1,-1},ly[5]={1,-1,0,0},bian[N][N],f[N][N],dfn[N][N];
void dfs1(int u,int x,int y){
	if(dfn[x][y]) return ;dfn[x][y]=1;
	if(x==n) bian[u][y]=1,sign[y]=1;
	for(int i=0;i<4;i++) if(x+lx[i]>=1&&x+lx[i]<=n&&y+ly[i]>=1&&y+ly[i]<=m&&mp[x][y]>mp[x+lx[i]][y+ly[i]]) dfs1(u,x+lx[i],y+ly[i]);
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>mp[i][j];
	for(int i=1;i<=m;i++) memset(dfn,0,sizeof(dfn)),dfs1(i,1,i);
	int cnt=0;
	for(int i=1;i<=m;i++) if(!sign[i]){cnt++;}
	if(cnt){cout<<"0\n";cout<<cnt<<'\n';return 0;}
	memset(f,0x3f3f,sizeof(f));
	for(int i=0;i<=m;i++) f[0][i]=0;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			for(int k=i-1;k>=0;k--) f[i][j]=min(f[i][j],f[i][j-1]);
			for(int k=i-1;k>=0;k--){
				if(!bian[j][k+1]) break;
				f[i][j]=min({f[i][j],f[k][j-1]+1});
			}
		}
	}
	cout<<"1\n"<<f[m][m]<<'\n';
	return 0;
}
```

---

## 作者：liketaem (赞：2)

# 思路
## 一 · 建输水厂
在越高的地方水能输的地方越多（这个是众所周知的）。然后用一个大根堆把与湖泊毗邻的第 $1$ 行的城市由高到低排序，由高到低建输水厂。
## 二 · 建输水管
输水方向有四种（向上，向左，向下，向右），而且城市高度要依次递减才可以输水。而向上可以不做计算原因如图:

![](https://cdn.luogu.com.cn/upload/image_hosting/312wuaoj.png)

图中 $h_1>h_3>h_4>h_2$ ，因为 $h_1>h_2$ ，所以可以从 $1$ 输水到 $2$ ，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3ejwydl5.png)

现在只需要向三个方向（向左，向下，向右）去枚举，然后比较高度看能不能往这个方向输水。
## 三 · 判断结果
### 1 . 可以输水的每一个干旱区的城市
在枚举每个输水厂输水范围是，标记哪些城市有水。只要第 $n$ 行的每一个城市都有水，那么就可以直接输出答案。
### 2 . 不可以输水的每一个干旱区的城市
在枚举完每一个与湖泊毗邻的城市时，第 $n$ 行还有城市没有水，那么枚举第 $n$ 行所有城市，把没有水的城市总数记录下来，输出答案。
# 代码
```cpp
#include<bits/stdc++.h>
const int N=1010;
using namespace std;
int n,m,dx[5]={-1,0,1,0},dy[5]={0,1,0,-1},vis[N][N],h[N][N],l[N][N],r[N][N];
void dfs(int x,int y){
	vis[x][y]=1;
	for(int i=0;i<4;i++){
		int x1=x+dx[i],y1=y+dy[i];
		if(x1<1||x1>n||y1<1||y1>m||h[x][y]<=h[x1][y1]) continue;
		if(!vis[x1][y1]) dfs(x1,y1);
		l[x][y]=min(l[x][y],l[x1][y1]);
		r[x][y]=max(r[x][y],r[x1][y1]);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	memset(l,21000000,sizeof l);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&h[i][j]);
			if(i==n) l[i][j]=r[i][j]=j;
		}
	}
	for(int i=1;i<=m;i++) if(!vis[1][i]) dfs(1,i);
	bool check=true;
	int ans=0;
	for(int i=1;i<=m;i++){
		if(!vis[n][i]){
			check=false;
			ans++;
		}
	}
	if(!check){
		cout<<0<<endl<<ans<<endl;
		return 0;
	}
	int left=1,right=r[1][1];
	while(left<=m){
		for(int i=1;i<=m;i++) if(l[1][i]<=left) right=max(right,r[1][i]);
		left=right+1;
		ans++;
	}
	cout<<1<<endl<<ans<<endl;
	return 0;
}
```

---

## 作者：hexuchen (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1514)

[更好的阅读体验？](https://www.luogu.com.cn/article/2p5ahopa)

## 题目大意

一个国家可以看做是一个 $N \times M$ 的矩阵，每一个格子就是一个城市。现在要在第 $1$ 行的城市中建蓄水厂，将水输送到第 $N$ 行的每一个城市。水只能从海拔高的地方流向海拔低的地方。求最少要建造几个蓄水厂。

## 思路分析

对于每一个在第 $1$ 行的城市，采用广度优先搜索，搜索如果在这里建蓄水厂，水能流向哪几个在第 $N$ 行的城市，用标记数组记录。如果有在第 $N$ 行的城市没办法收到水，则输出 $0$ 和缺水城市的数量。

但是如果每一座城市都能收到水，至少该建几个蓄水厂呢？

---

### 定理

在有解的情况下，每个蓄水厂流到的第 $N$ 行城市是个区间。

### 证明

![](https://cdn.luogu.com.cn/upload/image_hosting/mu5werx8.png)

假设图上绿色的城市建造蓄水厂，水从蓝色的路线流向最后一行的黄色城市。其中橙色城市没有收到水。此时，第 $N$ 行城市中覆盖的范围不是个区间。

![](https://cdn.luogu.com.cn/upload/image_hosting/ywvsaa7p.png)

因为要保证题目一定有解，所以一定有第 $1$ 行的一座城市能给橙色城市供水。图中红色城市能给橙色城市供水。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsr24y4z.png)

此时，绿色城市的供水路线与红色城市的供水路线存在着重叠，即图中深蓝色路线。而显然地，既然红色城市供的水能从深蓝色路线流向橙色城市，那么绿色城市供的水也可以。

![](https://cdn.luogu.com.cn/upload/image_hosting/rvpsh751.png)

因此，每个蓄水厂流到的第 $N$ 行城市是个区间。

证毕。

---

既然每个蓄水厂流到的第 $N$ 行城市是个区间，接下来就可以使用线段覆盖的方法解题。下文把 $M$ 座城市看做一条长度为 $M$ 的线段，每个蓄水厂流向的区间看做是一条条线段。

思路很简单，采用贪心，先设一个变量记录最大左端点，遍历每条线段的左端点与右端点。在左端点小于等于最大左端点的线段中选择右端点最大的一条线段，将最大左端点更新为这条线段的右端点，以此往复，直到最大左端点大于等于 $M$ 即可。最后输出的线段数即为答案。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct city{ //蓄水厂，有水流向沙漠城市的左端点和右端点
	int st,en;
}cities[510];
int n,m,s[510][510],L=1,ans=0;
int dh[5]={0,-1,0,1,0};
int dl[5]={0,0,1,0,-1};
bool f[510][510][510],p[510];
void bfs(int r,int c,int j){ //广搜，搜索水能流向那几座城市
	queue<int> qx,qy;
	qx.push(r);
	qy.push(c);
	f[j][r][c]=true;
	if(n==1){
		p[c]=true;
	}
	while(!qx.empty()){
		int x=qx.front(),y=qy.front();
		qx.pop();
		qy.pop();
		for(int i=1;i<=4;i++){
			int dx=x+dh[i],dy=y+dl[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=m){
				if(!f[j][dx][dy] && s[dx][dy]<s[x][y]){
					f[j][dx][dy]=true;
					qx.push(dx);
					qy.push(dy);
					if(dx==n){
						p[dy]=true; //标记数组，记录是不是每座沙漠城市都有水
						cities[j].st=min(cities[j].st,dy); //因为一定是一个区间，所以直接统计左右端点
						cities[j].en=max(cities[j].en,dy);
					}
				}
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=m;i++){
		cities[i].st=i;
		cities[i].en=i;
	}
	for(int i=1;i<=m;i++){
		bfs(1,i,i);
	}
	int city_num=0;
	for(int i=1;i<=m;i++){
		if(!p[i]){
			city_num++;
		}
	}
	if(city_num){ //有沙漠城市没有水
		cout<<"0\n"<<city_num;
		return 0;
	}
	cout<<"1\n";
	while(L<=m){ //线段覆盖
		int maxa=-1,maxn=-1e9;
		for(int i=1;i<=m;i++){
			if(cities[i].st<=L){
				if(cities[i].en>maxn){
					maxa=i;
					maxn=cities[i].en;
				}
			}
		}
		L=cities[maxa].en+1;
		ans++;
	}
	cout<<ans; //输出答案
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：1)

### 题目意思
就是在一个矩形上倒水，只能从最上方的那一排中的某一格开始倒水，每一格都有一个高度，且水遵循从高处往低处流的规律，问将这些水引到最后一行的所有格子，最少要往几个格子倒水。
### 题目思路
看到这道题，我们可以想到暴力搜索，搜出**从最上方的某个格子倒水它能将水引到最底下的哪些格子**。题目范围较小，可行。

给出搜索代码：
数组作用已给出，见注释。
```cpp
for(int i=1;i<=m;i++)
{
		memset(v,0,sizeof(v));
		if(a[1][i-1]<=a[1][i]&&a[1][i+1]<=a[1][i]) dfs(1,i,i);
}
void dfs(int x,int y,int o)
{
	v[x][y]=1;
	if(x==n) 
	{
		q[y]=1;//标记当前格子是否能被引水
		l[o]=min(l[o],y);
		r[o]=max(r[o],y);//l,r数组表示顶上的格子o能将水引到哪些底下格子的连续区间的左端点和右端点，为什么能这样做，下面会讲
	}
	if(x+1<=n&&a[x+1][y]<a[x][y]&&v[x+1][y]==0) dfs(x+1,y,o);
	if(y+1<=m&&a[x][y+1]<a[x][y]&&v[x][y+1]==0) dfs(x,y+1,o);
	if(x-1>=1&&a[x-1][y]<a[x][y]&&v[x-1][y]==0) dfs(x-1,y,o);
	if(y-1>=1&&a[x][y-1]<a[x][y]&&v[x][y-1]==0) dfs(x,y-1,o);
}
```
这时，你们应该会很疑惑，当水能到底下所有格子时，为什么某个格子引的水最后一定会在**一段连续的格子**内呢？

### 接下来我们来证明一下。
反证法：

当满足条件（水能到达底下所有格子）时。

我们假设有这样一条这样的水路（红线表示水路）。

![](https://cdn.luogu.com.cn/upload/image_hosting/cdh87eo2.png)
则因为要满足条件，第三个格子必须要被其它水路到达。
我们假设这条水路是这样的（用蓝色表示）。
![](https://cdn.luogu.com.cn/upload/image_hosting/cuks9dr0.png)
我们可以发现，图中，红线与蓝线有一个交点（用黄圈表示）。
![](https://cdn.luogu.com.cn/upload/image_hosting/h0ky2mmk.png)
这时我们神奇的发现，如果**蓝线能经过黄圈所表示的点，然后顺利的到达第三个格子，则红色这条水路也必能由黄圈这格，到达第三格**。
#### 此时发生矛盾，所以，猜想成立。
这时，我们已经证明了格子引出的水必在一段格子内，接下来，我们想一种贪心策略，使得我们能选出最少的格子，从而满足条件。

最直接的方式无非就是**找出能将水抵达底下格子最多的顶上格子，并每次将重复的格子删去，重新找最大**，这样的方案应该是可行的，但太麻烦了。~所以我根本没写~。

而我的方法则是用一个变量标记出已经找过的最大格子编号，**判断每一个顶部格子所延申的区间的左端点是否小于等于此变量加一**，如果它是，则找右端点最大的，并更新，最后每次统计次数加一，当到达了临界值的时候，退出。

### 下面给出我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ma,id,sum,ans,cnt;
int a[505][505],v[505][505],num[5005];
int l[10005],r[10005],q[10005];
void dfs(int x,int y,int o)
{
	v[x][y]=1;
	if(x==n) 
	{
		q[y]=1;
		l[o]=min(l[o],y);
		r[o]=max(r[o],y);
	}
	if(x+1<=n&&a[x+1][y]<a[x][y]&&v[x+1][y]==0) dfs(x+1,y,o);
	if(y+1<=m&&a[x][y+1]<a[x][y]&&v[x][y+1]==0) dfs(x,y+1,o);
	if(x-1>=1&&a[x-1][y]<a[x][y]&&v[x-1][y]==0) dfs(x-1,y,o);
	if(y-1>=1&&a[x][y-1]<a[x][y]&&v[x][y-1]==0) dfs(x,y-1,o);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	}
	for(int i=1;i<=m;i++) l[i]=1e8;
	for(int i=1;i<=m;i++)
	{
		memset(v,0,sizeof(v));
		if(a[1][i-1]<=a[1][i]&&a[1][i+1]<=a[1][i]) dfs(1,i,i);//dfs，不多说了 
	}
	for(int i=1;i<=m;i++)
	{
		if(q[i]==0) cnt++;
	}
	if(cnt>0)//判断条件是否符合。 
	{
		printf("%d\n",0);
		printf("%d",cnt);
		return 0;
	}
	while(1)
	{
		ma=0;
		for(int i=1;i<=m;i++)
		{
			if(l[i]<=1+ans&&r[i]>ma)//当l[i]<=1+ans时，说明此区间会容下ans+1，则取最大值。 
			{
				ma=r[i];
			}
		}
		ans=ma;//更新 
		cnt++;//累加 
		if(ans>=m) break;//判断	
	}
	printf("%d\n",1);
	printf("%d",cnt);
	return 0;
}
```

---


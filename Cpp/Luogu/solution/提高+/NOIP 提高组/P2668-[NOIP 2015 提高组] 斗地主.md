# [NOIP 2015 提高组] 斗地主

## 题目背景

NOIP2015 Day1T3

## 题目描述

牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\text{小王}<\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。

现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。

需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：

 ![](https://cdn.luogu.com.cn/upload/pic/1827.png) 

**本题数据随机，不支持hack，要hack或强力数据请点击[这里](https://www.luogu.org/problem/P2540)**。


## 说明/提示

**样例 1 说明**

共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$以及方片 $A$）在 $3$ 次内打光。

对于不同的测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：

| 测试点编号 | $T=$ | $n=$ |
| :------: | :----: | :----: |
|  1       |  $100$   |  $2$  |
|  2       |  $100$   |  $2$  |
|  3       |  $100$   |  $3$  |
|  4       |  $100$   |  $3$  |
|  5       |  $100$   |  $4$  |
|  6       |  $100$   |  $4$  |
|  7       |  $100$   |  $10$  |
|  8       |  $100$   |  $11$  |
|  9       |  $100$   |  $12$  |
|  10       |  $100$   |  $13$  |
|  11       |  $100$   |  $14$  |
|  12       |  $100$   |  $15$  |
|  13       |  $10$   |  $16$  |
|  14       |  $10$   |  $17$  |
|  15       |  $10$   |  $18$  |
|  16       |  $10$   |  $19$  |
|  17       |  $10$   |  $20$  |
|  18       |  $10$   |  $21$  |
|  19       |  $10$   |  $22$  |
|  20       |  $10$   |  $23$  |

数据保证：所有的手牌都是随机生成的。


## 样例 #1

### 输入

```
1 8
7 4
8 4
9 1
10 4
11 1
5 1
1 4
1 1```

### 输出

```
3
```

## 样例 #2

### 输入

```
1 17
12 3
4 3
2 3
5 4
10 2
3 3
12 2
0 1
1 3
10 1
6 2
12 1
11 3
5 2
12 4
2 2
7 2
```

### 输出

```
6
```

# 题解

## 作者：Mathison (赞：242)

这道题的核心是 ~~暴力模拟~~ ! !

这是搜索的顺序

![](https://cdn.luogu.com.cn/upload/pic/32162.png)

特别注意：**大小王**牌值不同，**不能算一对 ! ! ! ! ! ! ! ! **   只有做**火箭**才能一起出

具体内容看代码

代码较长但是很容易懂，注释很多

```
#include<bits/stdc++.h>
using namespace std;
int T,n,ans,sum[25];
void dfs(int x)//x为出牌次数
{
	if (x>=ans) return;
	//顺子
	int k=0;//单顺子
	for (int i=3;i<=14;i++)//注意2和大小王不能考虑
	{
		if(sum[i]==0) k=0;//顺子断了
		else
		{
			k++;//顺子长度增加
			if(k>=5)//单顺子达到五张
			{
				for(int j=i;j>=i-k+1;j--) sum[j]--;//出牌
				dfs(x+1);//继续搜
				for(int j=i;j>=i-k+1;j--) sum[j]++;//回溯
			}
		}
	}
	k=0;//双顺子
	for(int i=3;i<=14;i++)
	{
		if(sum[i]<=1) k=0;
		else 
		{
			k++;
			if(k>=3)//双顺子达到三组
			{
				for(int j=i;j>=i-k+1;j--) sum[j]-=2;//出牌
				dfs(x+1);
				for(int j=i;j>=i-k+1;j--) sum[j]+=2;//回溯
			}
		}
	}
	k=0;//三顺子    //以下同理
	for(int i=3;i<=14;i++)
	{
		if(sum[i]<=2) k=0;
		else 
		{
			k++;
			if(k>=2)//三顺子达到两组
			{
				for(int j=i;j>=i-k+1;j--) sum[j]-=3;
				dfs(x+1);
				for(int j=i;j>=i-k+1;j--) sum[j]+=3;
			}
		}
	}
	//带牌
	for(int i=2;i<=14;i++)//枚举有3张或4张的牌（这样才能带牌）
	{
		if(sum[i]<=3)
		{
			if(sum[i]<=2) continue;//三张以下（不含三张）不能带牌
			sum[i]-=3;//出掉用来带别人的牌
			for(int j=2;j<=15;j++)//带单张
			{
				if(sum[j]<=0||j==i) continue;//没有牌怎么带？？
				sum[j]--;//出掉被带的单张
				dfs(x+1);
				sum[j]++;//回溯
			}
			for(int j=2;j<=14;j++)//带一对
			{
				if(sum[j]<=1||j==i) continue;//没有一对怎么带？
				sum[j]-=2;//出掉被带的一对
				dfs(x+1);
				sum[j]+=2;//回溯
			}
			sum[i]+=3;//回溯
		} 
		else//大于3可以4带别的也可以3带别的
		{
			sum[i]-=3;//先用3张带别的
			for(int j=2;j<=15;j++) //带单张  //以下原理同上
			{
				if(sum[j]<=0||j==i) continue;
				sum[j]--;
				dfs(x+1);
				sum[j]++;
			}
			for(int j=2;j<=14;j++) //带一对
			{
				if(sum[j]<=1||j==i) continue;
				sum[j]-=2;
				dfs(x+1);
				sum[j]+=2;
			}
			sum[i]+=3;
			
			sum[i]-=4; //再用4张带别的 
			for(int j=2;j<=15;j++) //带2个单张
            {
				if(sum[j]<=0||j==i) continue;//自己不能带自己喽
				sum[j]--;//出被带的第一张单张牌
				for (int k=2;k<=15;k++)//找第二张单张
				{
					if(sum[k]<=0||j==k) continue;
					sum[k]--;//出被带的第二张单张牌
					dfs(x+1);
					sum[k]++;//回溯
				}
				sum[j]++;//回溯
			}
			for(int j=2;j<=14;j++)//带2个对儿
			{
				if(sum[j]<=1||j==i) continue;
				sum[j]-=2;//出被带的第一对牌
				for(int k=2;k<=14;k++) 
				{
					if(sum[k]<=1||j==k) continue;
					sum[k]-=2;//出被带的第二对牌
					dfs(x+1);
					sum[k]+=2;//回溯
				}
				sum[j]+=2;//回溯
			}
			sum[i]+=4;//回溯
		}
	}
	//把剩下的牌出完
	for(int i=2;i<=15;i++) if(sum[i]) x++;
	ans=min(ans,x);
}
int main() 
{
	scanf("%d%d",&T,&n);
	while(T--)
	{
		ans=0x7fffffff;//搞大一点
		int x,y;
		memset(sum,0,sizeof sum);//多次询问，记得清零
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&x,&y);
			if (x==0) sum[15]++;//把两张王存在一起（但是带牌的时候注意不要做对儿）
			else if(x==1) sum[14]++;//由于A的牌值大所以往后放
		    else sum[x]++;//其他牌存在相应位置
		}
		dfs(0);//开始暴搜
		printf("%d\n",ans);
	}
}
```

---

## 作者：Luan_233 (赞：96)

## Solution

### 这是我的处女作题解，有什么不当之处还望大家指出。

+ 相信这道题的解法许多斗地主大神兼OI巨佬也已经指出了，核心就在于暴力地去搜顺子，每搜完一层以后就贪心地出散牌。

+ 无论怎样来说，搜顺子有利于我们快速而轻松的打出5张甚至以上的牌，其余的东西，就留到最后慢慢打出就好了。

+ NOIP的搜索题以搜索为辅，核心在于模拟（几乎全是模拟）。所以说: **细节很重要！！！**

+ 最好把每一种打牌的方式分拆开来，按照贪心的顺序自上至下排列，搜索时只搜三种顺子，万万不可将打散牌也放进搜索里去（就是这样我连样例二都出不来。。）。

+ 我的做法是每搜新的一层时，统计牌张数的数目，这样有利于减少枚举量（细节见dfs主程序以及打散牌的函数）。

+ 在枚举顺子时，一定不可把2、小王、大王统计进去，但是在打散牌时，小王、大王当做一对来出，当做单牌或者与3张4张一起打出（虽说斗地主里王往往都在最后出，但你在这里是没有对手的）。

+ 四带二不仅可以带两张单牌，带一对牌或带两对牌都是可以的！

** _有了这些细节，做这道题还有什么好怕的呢？_ ** 

## Code
```
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
int t,n,card[15],c,d,ans;
inline void init(){
	memset(card,0,sizeof(card));
	for(int i=1;i<=n;i++){
		scanf("%d%d",&d,&c);
		if((d>=3)&&(d<=13)) card[d-2]++;
		if(d==0) card[14]++;
		if(d==1) card[12]++;
		if(d==2) card[13]++;
	}
	ans=n;
}
inline int sanpai(){
	int cnt[5],temp[14],ret=0;
	memset(cnt,0,sizeof(cnt));
	for(int i=1;i<=14;i++) cnt[card[i]]++;
	for(int i=1;i<=14;i++) temp[i]=card[i];
	if(cnt[4]&&(cnt[2]>2||cnt[3]>2)){
		for(int i=1;i<=14;i++){
			if(temp[i]==4){
				for(int j=1;j<=14;j++){
					if((j==i)||(temp[j]!=2)) continue;
					if(temp[i]<4) break;
					for(int k=1;k<=14;k++){
						if((k==j)||(k==i)) continue;
						if(temp[k]==2){
							temp[i]-=4; temp[j]-=2; temp[k]-=2;
							cnt[4]--; ret++; break; 
						}
					}
				}
			}
		}
	}//四带两对
	if(cnt[4]&&(cnt[2]||cnt[3]||(cnt[1]))){
		for(int i=1;i<=14;i++){
			if(temp[i]==4){
				for(int j=1;j<=14;j++){
					if((j==i)||(temp[j]!=1)) continue;
					if(temp[i]!=4) break;
					for(int k=1;k<=14;k++){
						if((k==j)||(k==i)) continue;
						if(temp[k]==1){
							temp[i]-=4; temp[j]--; temp[k]--;
							ret++; break;
						}
					}
				}
			}
		}
	}//四带二（不重牌）
	if(cnt[4]&&(cnt[2]||cnt[3])){
		for(int i=1;i<=14;i++){
			if(temp[i]==4){
				for(int j=1;j<=14;j++){
					if(j==i) continue;
					if(temp[j]==2){
						temp[i]-=4; ret++;
						temp[j]-=2; cnt[4]--;
						break;
					}
				}
			}
		}
	}//四带一对
	for(int i=1;i<=14;i++){
		if(temp[i]>=3){
			for(int j=1;j<=14;j++){
				if(j==i) continue;
				if(temp[j]==2){
					temp[i]-=3; temp[j]-=2; ret++;
					break; 
				}
				if(temp[j]==1){
					temp[i]-=3; temp[j]--; ret++;
					break;
				}
			}
		}
	}//三带二&&三带一
	for(int i=1;i<=14;i++){
		if(temp[i]==4) temp[i]-=4,ret++;
		else if(temp[i]==3) temp[i]-=3,ret++;
		else if(temp[i]==2) temp[i]-=2,ret++;
		else if(temp[i]) temp[i]--,ret++;
	}//散牌
	return ret;
} 
inline void dfs(int deep){
	if(deep>=ans) return ;
	for(int i=1;i<=14;i++){
		if(card[i]) break;
		if(i==14){
			ans=deep; return ;
		}
	}
	int temp=sanpai();
	if(temp+deep<ans) ans=temp+deep;
	int cnt[5];
	memset(cnt,0,sizeof(cnt));
	for(int i=1;i<=14;i++) cnt[card[i]]++;
	if(cnt[3]>=3){
		for(int i=1;i<=10;i++){
			for(int l=2;l<=12;l++){
				for(int p=i;p<=l+i;p++){
					if((card[p]<3)||(p>12)) break;
					else{
						if(p==l+i){
							for(int q=p-l;q<=p;q++) card[q]-=3;
							cnt[3]-=l+1; dfs(deep+1); cnt[3]+=l+1;
							for(int q=p-l;q<=p;q++) card[q]+=3;
						}
					}
				}
			}
		}
	}//三顺子
	if(cnt[2]>=3){
		for(int i=1;i<=10;i++){
			for(int l=2;l<=12;l++){
				for(int p=i;p<=l+i;p++){
					if((card[p]<2)||(p>12)) break;
					else{
						if(p==l+i){
							for(int q=p-l;q<=p;q++) card[q]-=2;
							cnt[2]-=l+1; dfs(deep+1); cnt[2]+=l+1;
							for(int q=p-l;q<=p;q++) card[q]+=2;
						}
					}
				}
			}
		}
	}//双顺子
	if(cnt[1]+cnt[2]+cnt[3]>5){
		for(int i=1;i<=10;i++){
			for(int l=4;l<=12;l++){
				for(int p=i;p<=i+l;p++){
					if((!card[p])||(p>12)) break;
					else{
						if(p==l+i){
							for(int q=p-l;q<=p;q++) card[q]--;
							dfs(deep+1);
							for(int q=p-l;q<=p;q++) card[q]++;
						}
					}
				}
			}
		}
	}//单顺子
}
int main(){
	scanf("%d%d",&t,&n);
	while(t--){
		init();
		dfs(0);
		printf("%d\n",ans);
	}
	return 0;
}
```

+ 非常感谢讨论区里的hack数据，我感到十分抱歉。但是上半部分的码仅仅针对于NOIP原题数据，不考虑拆牌组牌情况，若要考虑真正的拆牌情况，可以移步增强版。（可以吐槽我的码非常的丑）。

+ 对于hack数据，顺子依然要爆搜，但原有的贪心换用DP对其进行优化。对应状态就是牌数为多少的牌有多少种，再套上一个双王的数目（可以没有），打完这些牌所需的最小步数。考虑拆牌的情况，四张拆一张与三张，或是两个两张，或是两张加一对，三张拆成一张加一对，或是三张单牌。套在记搜内直接讨论即可。对牌和单牌直接出就好。下面奉上我斗地主增强版的代码。欢迎各位吐槽。

## Code

```
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define INF 1061109567
#define Re register

using namespace std;

int t,n,f[25][25][25][25][5],cnt[5],card[25],num,ans;

inline int dfs2(int on,int tw,int th,int fl,int w){
    if(f[on][tw][th][fl][w]<INF){
        return f[on][tw][th][fl][w];
    }
    f[on][tw][th][fl][w]=on+tw+th+fl+w;
    int &now=f[on][tw][th][fl][w];
    if(w==2)  now=min(now,dfs2(on,tw,th,fl,0)+1);
    if(fl){
        if(tw>=2) now=min(now,dfs2(on,tw-2,th,fl-1,w)+1);
        //直接四带二对
        if(tw) now=min(now,dfs2(on,tw-1,th,fl-1,w)+1);
        //四带两张一样的 
        if(w==2) now=min(now,dfs2(on,tw,th,fl-1,0)+1);
        //王炸组四带二张 
        if(w&&on) now=min(now,dfs2(on-1,tw,th,fl-1,w-1)+1);
        //单王加单牌组四带二 
        if(on>=2) now=min(now,dfs2(on-2,tw,th,fl-1,w)+1);
        //直接四带二张 
        now=min(now,dfs2(on+1,tw,th+1,fl-1,w));
        //拆成三与一 
        now=min(now,dfs2(on,tw+2,th,fl-1,w));
        //拆成两对 
        now=min(now,dfs2(on+2,tw+1,th,fl-1,w));
        //拆成一对加两张 
    }
    if(th){
        if(tw) now=min(now,dfs2(on,tw-1,th-1,fl,w)+1);
        //直接三带二 
        if(w) now=min(now,dfs2(on,tw,th-1,fl,w-1)+1);
        //三带一王 
        if(on) now=min(now,dfs2(on-1,tw,th-1,fl,w)+1);
        //三带一单 
        now=min(now,dfs2(on+1,tw+1,th-1,fl,w));
        //拆牌成一单一对 
        now=min(now,dfs2(on+3,tw,th-1,fl,w));
        //拆牌成三张单 
    }
    return f[on][tw][th][fl][w];
}

inline int get(){
    memset(cnt,0,sizeof(cnt));
    for(Re int i=1;i<=13;i++) cnt[card[i]]++;
    return dfs2(cnt[1],cnt[2],cnt[3],cnt[4],card[14]);
}

inline void dfs1(int step){
    ans=min(ans,step+get());
    bool flag;
    for(Re int i=1;i<=11;i++){
        for(Re int j=2;j<=12;j++){
            if(i+j-1>12) break;
            flag=true;
            for(Re int k=0;k<=j-1;k++){
                if(card[i+k]<3) flag=false;
            }
            if(!flag) break;
            for(Re int k=0;k<=j-1;k++) card[i+k]-=3;
            dfs1(step+1);
            for(Re int k=0;k<=j-1;k++) card[i+k]+=3;
        }
    }
    for(Re int i=1;i<=10;i++){
        for(Re int j=3;j<=12;j++){
            if(i+j-1>12) break;
            flag=true;
            for(Re int k=0;k<=j-1;k++){
                if(card[i+k]<2) flag=false;
            }
            if(!flag) break;
            for(Re int k=0;k<=j-1;k++) card[i+k]-=2;
            dfs1(step+1);
            for(Re int k=0;k<=j-1;k++) card[i+k]+=2;
        }
    }
    for(Re int i=1;i<=8;i++){
        for(Re int j=5;j<=12;j++){
            if(i+j-1>12) break;
            flag=true;
            for(Re int k=0;k<=j-1;k++){
                if(!card[i+k]) flag=false;
            }
            if(!flag) break;
            for(Re int k=0;k<=j-1;k++) card[i+k]-=1;
            dfs1(step+1);
            for(Re int k=0;k<=j-1;k++) card[i+k]+=1;
        }
    }
}

inline void solve(){
    memset(card,0,sizeof(card));
    for(int i=1;i<=n;i++){
        int type,col;
        cin>>type>>col;
        if(type==0) type=14;
        else if(type==1||type==2) type+=11;
        else if(type>=3&&type<=13) type-=2;
        card[type]++;
    }
    num=0,ans=n;
    dfs1(0);
    cout<<ans<<endl;
}

int main(){
    ios::sync_with_stdio(false);
    memset(f,63,sizeof(f));
    cin>>t>>n;
    for(int i=1;i<=t;i++) solve();
    return 0;
}
```

---

## 作者：岸芷汀兰 (赞：6)

# 一、题目：

[洛谷原题](https://www.luogu.org/problemnew/show/P2668)

# 二、思路：

一看这数据范围，显然是搜索。但是此题无论从代码难度还是思维难度来说都很有挑战性（大佬勿喷）。

那么我们来想一想怎么搜索才能通过此题。

## 1. 搜什么？

仔细想想后能发现，出顺子的顺序不同能影响本题的答案。所以我们以顺子为搜索对象进行搜索。

## 2. 怎么搜？

暴力搜索当前出了几个顺子now，然后可以运用一点贪心的思想，算出剩余牌出散牌所需步数step。用now+step更新答案。

（好像这种思路有反例可以卡掉，我不是很懂。）

## 3. 细节

- 不能最优性剪枝！！！
- 按照三顺子、双顺子、单顺子的顺序枚举顺子。
- 计算上文所说step是按照各种散牌张数从大到小的顺序贪心。
- 四张牌可以带两对牌。（仔细看题中表格）

# 三、代码：

```cpp
//巨丑无比的代码
#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>1
#include<cstring>

#define mem(s,v) memset(s,v,sizeof(s))

using namespace std;
inline int read(void) {
	int x = 0, f = 1; char ch = getchar();
	while (ch<'0' || ch>'9') { if (ch == '-')f = -1; ch = getchar(); }
	while (ch >= '0'&&ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return f * x;
}

const int maxn = 30;

int n, cnt[maxn], ans = 0x3f3f3f3f, mmp[maxn];

inline void clear(void) {
	mem(cnt, 0);
	ans = 0x3f3f3f3f;
	mem(mmp, 0);
}

inline int find_san_pai(void) {
	memcpy(mmp, cnt, sizeof(cnt));
	int ret = 0;
	for (register int i = 1; i <= 13; ++i) {//四带四（四带两对）
		if (mmp[i] != 4)continue;
		mmp[i] -= 4;
		bool be_found1 = false, be_found2 = false;
		int pos1 = 0, pos2 = 0;
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 2) {
				pos1 = j; ----mmp[j]; be_found1 = true; break;
			}
		}
		if (!be_found1) { mmp[i] += 4; break; }
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 2) {
				pos2 = j; ----mmp[j]; be_found2 = true; break;
			}
		}
		if (!be_found2) { mmp[pos1] += 2; mmp[i] += 4; break; }
		++ret;
	}
	for (register int i = 1; i <= 13; ++i) {//四带二
		if (mmp[i] != 4)continue;
		mmp[i] -= 4;
		bool be_found1 = false, be_found2 = false;
		int pos1 = 0, pos2 = 0;
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 1) { pos1 = j; --mmp[j]; be_found1 = true; break; }
		}
		if (!be_found1) { mmp[i] += 4; break; }
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 1) { pos2 = j; --mmp[j]; be_found2 = true; break; }
		}
		if (!be_found2) { mmp[pos1]++; mmp[i] += 4; break; }
		++ret;
	}
	for (register int i = 1; i <= 13; ++i) {
		if (mmp[i] != 4)continue;
		mmp[i] -= 4;
		bool be_found = false;
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 2) { ----mmp[j]; be_found = true; break; }
		}
		if (!be_found) { mmp[i] += 4; break; }
		++ret;
	}
	for (register int i = 1; i <= 13; ++i) {//三带二
		if (mmp[i] != 3)continue;
		mmp[i] -= 3;
		bool be_found = false;
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 2) { ----mmp[j]; be_found = true; break; }
		}
		if (!be_found) { mmp[i] += 3; break; }
		++ret;
	}
	for (register int i = 1; i <= 13; ++i) {//三带一
		if (mmp[i] != 3)continue;
		mmp[i] -= 3;
		bool be_found = false;
		for (register int j = 1; j <= 14; ++j) {
			if (mmp[j] == 1) { --mmp[j]; be_found = true; break; }
		}
		if (!be_found) { mmp[i] += 3; break; }
		++ret;
	}
	for (register int i = 1; i <= 13; ++i) {
		if (mmp[i] == 4) {
			mmp[i] -= 4; ++ret;
		}
	}
	for (register int i = 1; i <= 13; ++i) {
		if (mmp[i] == 3) {
			mmp[i] -= 3; ++ret;
		}
	}
	for (register int i = 1; i <= 14; ++i) {
		if (mmp[i] == 2) {
			mmp[i] -= 2; ++ret;
		}
	}
	for (register int i = 1; i <= 14; ++i) {
		if (mmp[i] == 1) {
			--mmp[i]; ++ret;
		}
	}
	return ret;

}

inline void dfs(int now) {
	int tmp = find_san_pai();
	ans = min(ans, tmp + now);
	for (register int l = 2; l <= n; ++l) {//三顺子
		for (register int i = 1; i <= 11; ++i) {
			bool flag = true;
			for (register int j = i; j <= i + l - 1; ++j) {
				if (j >= 13) { flag = false; break; }
				if (cnt[j] < 3) { flag = false; break; }
			}
			if (flag) {
				for (register int j = i; j <= i + l - 1; ++j)cnt[j] -= 3;
				dfs(now + 1);
				for (register int j = i; j <= i + l - 1; ++j)cnt[j] += 3;
			}
		}
	}
	for (register int l = 3; l <= n; ++l) {//双顺子
		for (register int i = 1; i <= 10; ++i) {
			bool flag = true;
			for (register int j = i; j <= i + l - 1; ++j) {
				if (j >= 13) { flag = false; break; }
				if (cnt[j] < 2) { flag = false; break; }
			}
			if (flag) {
				for (register int j = i; j <= i + l - 1; ++j)cnt[j] -= 2;
				dfs(now + 1);
				for (register int j = i; j <= i + l - 1; ++j)cnt[j] += 2;
			}
		}
	}
	for (register int l = 5; l <= n; ++l) {
		for (register int i = 1; i <= 8; ++i) {
			bool flag = true;
			for (register int j = i; j <= i + l - 1; ++j) {
				if (j >= 13) { flag = false; break; }
				if (cnt[j] < 1) { flag = false; break; }
			}
			if (flag) {
				for (register int j = i; j <= i + l - 1; ++j)--cnt[j];
				dfs(now + 1);
				for (register int j = i; j <= i + l - 1; ++j)++cnt[j];
			}
		}
	}

}

int main() {
	/*freopen("data.in", "r", stdin);
	freopen("data.out", "w", stdout);*/
	int T = read(); n = read();
	while (T--) {
		clear();
		for (register int step = 1; step <= n; ++step) {
			int a, b; scanf("%d%d", &a, &b);
			if (a == 1)a = 12;
			else if (a == 2)a = 13;
			else if (!a)a = 14;
			else a -= 2;
			++cnt[a];
		}
		dfs(0);
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：Gorun (赞：3)

# 斗地主 题解

总所周知，这一道题用不了dp（状态无法简单地表示），用不了其他高端的算法。那么我们可以回到最初的时代：写暴力搜索。

话说我一开始的时候还不太清楚怎么写，“顺子判断器”接连出现问题……

但是实质上就是暴力，暴力枚举可以从以下几种情况考虑：

#### 对于当前的这一次出牌机会，有：

1. 出单顺子：当且仅当存在连续的五个点数牌都有至少一张牌
2. 出双顺子：当且仅当存在连续的三个点数牌都有至少两张牌
3. 出三顺子：当且仅当存在连续的两个点数牌都有至少三张牌
4. 出三带一：当且仅当存在某一个点数有至少三张牌和另外的一张牌
5. 出三带二：同上
6. 出四带二：当且仅当存在某一个点数有四张牌接有另外的两张牌
7. 出四带两対：同上
8. 出简单牌： 无论当前的点数剩下几张牌，都可以一次出完

深搜解决一切！

**题目非常复杂，做题的时候要把题目的信息提取出来，再打代码：**

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN=20;
int t,n,ans;
int sum[MAXN];
void dfs(int x)
{
	if (x>ans) return;
	int k;
	
	k=0;
	for (int i=3;i<=14;i++)
	{
		if (sum[i]==0) k=0;
		else k++;
		if (k>=5)
		{
			for (int j=i;j>=i-k+1;j--)
				sum[j]--;
			dfs(x+1);
			for (int j=i;j>=i-k+1;j--)
				sum[j]++;
		}
	}
	
	k=0;
	for (int i=3;i<=14;i++)
	{
		if (sum[i]<=1) k=0;
		else k++;
		if (k>=3)
		{
			for (int j=i;j>=i-k+1;j--)
				sum[j]-=2;
			dfs(x+1);
			for (int j=i;j>=i-k+1;j--)
				sum[j]+=2;
		}
	}
	
	k=0;
	for (int i=3;i<=14;i++)
	{
		if (sum[i]<=2) k=0;
		else k++;
		if (k>=2)
		{
			for (int j=i;j>=i-k+1;j--)
				sum[j]-=3;
			dfs(x+1);
			for (int j=i;j>=i-k+1;j--)
				sum[j]+=3;
		}
	}
	
	for (int i=2;i<=14;i++)
	{
		if (sum[i]<=2) continue;
		sum[i]-=3;
		for (int j=2;j<=15;j++)
		{
			if (sum[j]==0||j==i) continue;
			sum[j]--;
			dfs(x+1);
			sum[j]++;
		}
		for (int j=2;j<=14;j++)
		{
			if (sum[j]<=1||j==i) continue;
			sum[j]-=2;
			dfs(x+1);
			sum[j]+=2;
		}
		sum[i]+=3;
	}
	
	for (int i=2;i<=14;i++)
	{
		if (sum[i]<=3) continue;
		sum[i]-=4;
		for (int a=2;a<=15;a++)
		{
			if (sum[a]==0) continue;
			for (int b=2;b<=15;b++)
			{
				if (sum[b]==0) continue;
				sum[a]--; sum[b]--;
				dfs(x+1);
				sum[a]++; sum[b]++;
			}
		}
		for (int a=2;a<=14;a++)
		{
			if (sum[a]<=1) continue;
			for (int b=2;b<=14;b++)
			{
				if (sum[b]<=1) continue;
				sum[a]-=2; sum[b]-=2;
				dfs(x+1);
				sum[a]+=2; sum[b]+=2;
			}
		}
		sum[i]+=4;
	}
		
	k=0;
	for (int i=2;i<=15;i++)
		if (sum[i])
			k++;
	ans=min(x+k,ans);
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	scanf("%d%d",&t,&n);
	while (t--)
	{
		ans=0x3f3f3f3f;
		memset(sum,0,sizeof(sum));
		for (int i=1,d,p;i<=n;i++)
		{
			scanf("%d%d",&d,&p);
			if (d==0) sum[15]++;
			else if (d==1) sum[14]++;
			else sum[d]++;
		}
		dfs(0);
		printf("%d\n",ans);
	}
}
```


---

## 作者：DeepSeekR1 (赞：2)

因为最后总是要把牌出完的，所以只有顺序不同的情况可以被认为是同一种方法，这会减少很多情况。

于是我们规定每次出牌必须带上现在剩下的所有牌中的最小的那张，枚举其他的牌，这样就优化完了。

不过因为一定要出最小那张的原因，需要更多的分类讨论。假设最小的是 `3`, 那么 `3334` 和 `3444` 这两种情况是要分开讨论的。

那么模拟部分就分这几类：

单牌，也就是出的所有牌都是最小的：单，对，三，炸。

2\. 顺子：单顺子，双顺子，三顺子。

到带这里就要分类了

3.1. 最小的出一张的：`(1+4+1)`，`(1+3)`

3.2. 最小的出两张的：`(2+4+2)`，`(2+3)`，`(2+4)`

3.3. 最小的出三张的：`(3+1)`，`(3+2)`

3.4. 最小的出四张的：`(4+2+2)`，`(4+1+1)`

4\. 最小的是小王时特判一下王炸即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ans;
int a[20000];
void prt () {
	for (int i = 2;i <= 16;i++) {
		cout << a[i] << ' ';
	}
	cout << endl;
	return;
}
void dfs(int d) {
//	cout << d << ' ';
//	prt();
	if (d >= ans) {
		return;
	}
	int x = 0;
	for (int i = 2;i <= 16;i++) {
		if (a[i] > 0) {
			x = i;
			break;
		}
	}
	if (x == 0) {
		ans = min(ans,d);
		return;
	}
	if (3 <= x && x <= 13) {//三顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 3) {
				break;
			}
			l = i;
		}
		if (l < 2) {
			goto s3;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 3;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 2) {
				a[j] += 3;
				continue;
			}
			dfs(d + 1);
			a[j] += 3;
		}
	}
	s3:
	if (3 <= x && x <= 12) {//双顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 2) {
				break;
			}
			l = i;
		}
		if (l < 3) {
			goto s2;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 2;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 3) {
				a[j] += 2;
				continue;
			}
			dfs(d + 1);
			a[j] += 2;
		}
	}
	s2:
	if (3 <= x && x <= 10) {//单顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 1) {
				break;
			}
			l = i;
		}
		if (l < 5) {
			goto s1;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 1;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 5) {
				a[j] += 1;
				continue;
			}
			dfs(d + 1);
			a[j] += 1;
		}
	}
	s1:
	if (a[x] >= 1) {//1带 
		if (true) {//x=1,1+4+1
			a[x]--;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 4) {
					continue;
				}
				a[i] -= 4;
				for (int j = 2;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 1) {
						a[j]--;
						dfs(d + 1);
						a[j]++;
					}
				}
				a[i] += 4;
			}
			a[x]++;
		}
		if (true) {//x=1,1+3
			a[x]--;
			for (int i = 2;i <= 16;i++) {
				if (x == i) {
					continue;
				} 
				if (a[i] >= 3) {
					a[i] -= 3;
					dfs(d + 1);
					a[i] += 3;
				}
			}
			a[x]++;
		} 
	}
	if (a[x] >= 2) {//2带 
		if (true) {//x=2,2+4+2
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 4) {
					continue;
				}
				a[i] -= 4;
				for (int j = 2;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 2) {
						a[j] -= 2;
						dfs(d + 1);
						a[j] += 2;
					}
				}
				a[i] += 4;
			}
			a[x] += 2;
		}
		if (true) {//x=2,2+4
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 4) {
					a[i] -= 4;
					dfs(d + 1);
					a[i] += 4;
				}
			}
			a[x] += 2;
		}
		if (true) {//x=2,2+3
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 3) {
					a[i] -= 3;
					dfs(d + 1);
					a[i] += 3;
				}
			}
			a[x] += 2;
		}
	}
	if (a[x] >= 3) {//3带 
		if (true) {//x=3,3+2
			a[x] -= 3;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 2) {
					a[i] -= 2;
					dfs(d + 1);
					a[i] += 2;
				}
			}
			a[x] += 3;
		}
		if (true) {//x=3,3+1
			a[x] -= 3;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 1) {
					a[i] -= 1;
					dfs(d + 1);
					a[i] += 1;
				}
			}
			a[x] += 3;
		}
	}
	if (a[x] >= 4) {//4带
		if (true) {//x=4,4+2+2
			a[x] -= 4;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 2) {
					continue;
				}
				a[i] -= 2;
				for (int j = i;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 2) {
						a[j] -= 2;
						dfs(d + 1);
						a[j] += 2;
					}
				}
				a[i] += 2;
			}
			a[x] += 4;
		}
		if (true) {//x=4,4+1+1
			a[x] -= 4;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 1) {
					continue;
				}
				a[i]--;
				for (int j = i;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 1) {
						a[j]--;
						dfs(d + 1);
						a[j]++;
					}
				}
				a[i]++;
			}
			a[x] += 4;
		}
	}
	if (a[x] >= 4) {//4
		a[x] -= 4;
		dfs(d + 1);
		a[x] += 4;
	}
	if (a[x] >= 3) {//3
		a[x] -= 3;
		dfs(d + 1);
		a[x] += 3;
	}
	if (a[x] >= 2) {//2
		a[x] -= 2;
		dfs(d + 1);
		a[x] += 2;
	}
	if (a[x] >= 1) {//1
		a[x]--;
		dfs(d + 1);
		a[x]++;
	}
	if (x == 15) {//王炸 
		if (a[15] > 0 && a[16] > 0) {
			a[15]--,a[16]--;
			dfs(d + 1);
			a[15]++,a[16]++;
		}
	}
	return;
}
int t,n,x,y;
inline void mian () {
	for (int i = 1;i <= n;i++) {
		cin >> x >> y;
		if (x) {
			if (x == 1) {
				a[14]++;
			} else {
				a[x]++;
			}
		} else {
			a[14 + y]++;
		}
	}
	dfs(0);
	cout << ans << endl;
	return;
}
inline void init () {
	ans = 2147483647;
	memset(a,0,sizeof(a));
}
signed main () {
	cin >> t >> n;
	while (t--) {
		init();
		mian();
	}
	fclose(stdout);
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：1)

### 题目意思
题目一看上去，特别难懂，但只要明白了，其实就**只有十一种出牌方式**，这里不过多叙述。
### 题目思路
看到这道题，我们肯定能想到搜索。但怎么搜索呢？
我们其实只需要**考虑除单牌与对子外的其他出牌方式，最后剩下来的必定为单或对**，我们只需要最后统计有哪些牌没出完就行了。接下来考虑其他出牌方式。这里肯定会有个疑问，我们应该按什么**顺序**来出牌。根据贪心思想，因为题目要求求的是最小的出牌次数，所以我们应该**优先用打的牌较多的出牌方式**。

所以这里给出我的打牌顺序：顺子，三带，炸弹。

#### 那接下来我们来考虑出牌方式的处理：
### 一，顺子
对于顺子，分三类，这三类大体是一样的，所以这里只给出三顺子的处理思想，其他顺子类似思想。

对于一个三顺子，我们必能保证它是连续的，所以我们只需从**一个点数出现次数大于等于三的牌开始往后找点数小于三的牌，并标记其位置**。当大于等于三的牌数至少有两张，我们就标记其可行。

给出三顺子核心代码：

```cpp
for(int i=3;i<=14;i++)
	{
		int o=15;
		for(int j=i;j<=14;j++)
		{
			if(a[j]<3)
			{
				o=j;
				break;
			}
		}
		if(o-i>=2)
		{
			for(int j=i;j<o;j++) a[j]-=3;
			dfs(x+1);
			for(int j=i;j<o;j++) a[j]+=3;
		}
	}
```

### 二，炸弹与三带
炸弹与三带类似，这里只讨论三带。

讨论三带，三带分三种，不带，带一个，带两个。
三种类似，这里只讲带两个的。

我们枚举一种点数出现次数大于等于三的，**这里注意，大于等于三的，包括四，四张一样的也可以用作三带！**
然后接着枚举点数出现大于等于二的，视为找到，然后记录找到。

给出炸弹与三带核心代码：

```cpp
for(int i=1;i<=14;i++)
	{
		if(a[i]>=3)
		{
			for(int j=0;j<=15;j++)
			{
				if(a[j]>=1)
				{
					a[i]-=3;
					a[j]--;
					dfs(x+1);
					a[j]++;
					a[i]+=3;
				}
				if(a[j]>=2)
				{
					a[i]-=3;
					a[j]-=2;
					dfs(x+1);
					a[j]+=2;
					a[i]+=3; 
				}
			}
		}
		if(a[i]==4)
		{
			for(int j=0;j<=15;j++)
			{
				if(a[j]>=1)
				{
					for(int k=0;k<=15;k++)
					{
						if(k!=j&&k!=i&&a[k]>=1)
						{
							a[j]--;
							a[k]--;
							a[i]=0;
							dfs(x+1);
							a[j]++;
							a[k]++;
							a[i]=4;
						}
					}
				}
				if(a[j]>=2)
				{
					for(int k=0;k<=15;k++)
					{
						if(k!=j&&k!=i&&a[k]>=2)
						{
							a[j]-=2;
							a[k]-=2;
							a[i]=0;
							dfs(x+1);
							a[j]+=2;
							a[k]+=2;
							a[i]=4;
						}
					}
				}
			}
		}
	}
```
最后讨论剩下来的对子与单牌，只要当前点数有出现过，就统计一次，最后**记得特判大小王的情况**。
给出此题所有代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans=1e8,a[105],b,c;
void dfs(int x)
{
	for(int i=3;i<=14;i++)
	{
		int o=15;
		for(int j=i;j<=14;j++)
		{
			if(a[j]<3)
			{
				o=j;
				break;
			}
		}
		if(o-i>=2)
		{
			for(int j=i;j<o;j++) a[j]-=3;
			dfs(x+1);
			for(int j=i;j<o;j++) a[j]+=3;
		}
	}
	for(int i=3;i<=14;i++)
	{
		int o=15;
		for(int j=i;j<=14;j++)
		{
			if(a[j]<2)
			{
				o=j;
				break;
			}
		}
		if(o-i>=3)
		{
			for(int j=i;j<o;j++) a[j]-=2;
			dfs(x+1);
			for(int j=i;j<o;j++) a[j]+=2;
		}
	}
	for(int i=3;i<=14;i++)
	{
		int o=15;
		for(int j=i;j<=14;j++)
		{
			if(a[j]==0)
			{
				o=j;
				break;
			}
		}
		if(o-i>=5)
		{
			for(int j=i;j<o;j++) a[j]--;
			dfs(x+1);
			for(int j=i;j<o;j++) a[j]++;
		}
	}
	for(int i=1;i<=14;i++)
	{
		if(a[i]>=3)
		{
			for(int j=0;j<=15;j++)
			{
				if(a[j]>=1)
				{
					a[i]-=3;
					a[j]--;
					dfs(x+1);
					a[j]++;
					a[i]+=3;
				}
				if(a[j]>=2)
				{
					a[i]-=3;
					a[j]-=2;
					dfs(x+1);
					a[j]+=2;
					a[i]+=3; 
				}
			}
		}
		if(a[i]==4)
		{
			for(int j=0;j<=15;j++)
			{
				if(a[j]>=1)
				{
					for(int k=0;k<=15;k++)
					{
						if(k!=j&&k!=i&&a[k]>=1)
						{
							a[j]--;
							a[k]--;
							a[i]=0;
							dfs(x+1);
							a[j]++;
							a[k]++;
							a[i]=4;
						}
					}
				}
				if(a[j]>=2)
				{
					for(int k=0;k<=15;k++)
					{
						if(k!=j&&k!=i&&a[k]>=2)
						{
							a[j]-=2;
							a[k]-=2;
							a[i]=0;
							dfs(x+1);
							a[j]+=2;
							a[k]+=2;
							a[i]=4;
						}
					}
				}
			}
		}
	}
	int summ=0;
	if(a[0]==1&&a[15]==1) summ=-1;
	for(int i=0;i<=15;i++)
	{
		if(a[i]>0) summ++;
	}
	ans=min(ans,x+summ);
	return;
}
int main()
{
	cin>>t;
	cin>>n;
	while(t--)
	{
		ans=1e8;
		int nums=0;	
		for(int i=0;i<=16;i++) a[i]=0;
		for(int i=1;i<=n;i++)
		{
			cin>>c>>b;
			if(c==1) a[14]++;
			if(c==0&&b==2) a[15]++;
			if(c>1) a[c]++;
			if(c==0&&b==1) a[0]++;
		}
		dfs(0);
		cout<<ans<<endl;
	}
	return 0;
} 
```

---

## 作者：ZHR100102 (赞：1)

一步一步推性质就能做出来的剪枝题。

这题思路和小木棒的剪枝思路极其相似，剪枝的角度都差不多。

其实大部分搜索剪枝题都是先观察性质，列出性质后选择几个比较关键且代码好写的性质进行剪枝，特别要注意避免重复搜索相同状态的剪枝。同时注意想好了之后再写代码。

并且大部分搜索题会把正向的搜索树 hack 得很大，当被卡的时候不妨试试倒着搜索，可能有奇效。

# 思路

观察题目，我们可以发现如下几点性质：
- 出牌的顺序不影响最终的结果，先出某一组牌和后出某一组牌本质是一样的。
- 最后只剩下单牌、对子、三张牌、炸弹和王炸的时候，我们可以贪心地扫一遍统计至少存在一张牌的码数的个数，特判掉大小王得出答案。
- 在顺子和带牌中，顺子打出的方案数一般比带牌的方案数更少。

因此，我们可以设计出如下剪枝方案：
- 将搜索阶段拆解为 $6$ 步，依次完成。分别是三顺子、双顺子、单顺子、四带二、三带一和二、最后剩下的统一出掉，大王小王绑一起出。
- 记录下当前的搜索阶段 $p$，以及上一次在同阶段最后搜索到的牌 $lst$。每次接着 $lst$ 后面来搜索，避免搜到重复状态。
- 把三顺子、双顺子、单顺子、四带二、三带一和二全部出完之后，我们可以线性扫一遍算出最终的答案，避免了搜索多余状态。

实现的时候对每个搜索阶段分步实现，代码在写顺子和带牌内部时可以稍作修改之后重复利用。

时间复杂度玄学，但是除非对着卡很难 hack 掉。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
using pi=pair<int,int>;
/*
三顺子 1
双顺子 2
单顺子 3
四带二 4
三带一、二 5
最后剩下的统一出掉，大王小王绑一起出。 
1~11 3~K
12 A
13 2
14 little
15 big
*/
int tot[20],ans=0x3f3f3f3f,now=0,n;
void dfs(int p,int lst)
{
	if(p>=6)
	{
		int cur=0;
		for(int i=1;i<=15;i++)if(tot[i])cur++;
		if(tot[14]&&tot[15])cur--;
		ans=min(ans,now+cur);
		return;
	}
	if(p==1)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=3)pre++;
			else pre=0;
			if(pre>=2&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=3;
				for(int j=2;j<=pre;j++)
				{
					tot[i-j+1]-=3;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;
	}
	if(p==2)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=2)pre++;
			else pre=0;
			if(pre>=3&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=2;
				tot[i-1]-=2;
				for(int j=3;j<=pre;j++)
				{
					tot[i-j+1]-=2;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;		
	}
	if(p==3)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=1)pre++;
			else pre=0;
			if(pre>=5&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=1;
				tot[i-1]-=1;
				tot[i-2]-=1;
				tot[i-3]-=1;
				for(int j=5;j<=pre&&i-j+1>=1;j++)
				{
					tot[i-j+1]-=1;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;		
	}
	if(p==4)
	{
		for(int i=1;i<=13;i++)
		{
			if(tot[i]>=4)
			{
				tot[i]-=4;
				for(int j=1;j<=15;j++)
				{
					if(tot[j]<=0)continue;
					for(int k=1;k<=15;k++)
					{
						if(tot[k]<=0)continue;
						if(tot[j]&&tot[k]&&(j!=k||tot[j]>=2))
						{
							tot[j]--;
							tot[k]--;
							now++;
							dfs(p,i);
							tot[j]++;
							tot[k]++;
							now--;
						}
						if(tot[j]>=2&&tot[k]>=2&&(j!=k||tot[j]>=4))
						{
							tot[j]-=2;
							tot[k]-=2;
							now++;
							dfs(p,i);
							tot[j]+=2;
							tot[k]+=2;
							now--;
						}			
					}
				}
				tot[i]+=4;
			}
		}
		dfs(p+1,1);
		return;
	}
	if(p==5)
	{
		for(int i=1;i<=13;i++)
		{
			if(tot[i]>=3)
			{
				tot[i]-=3;
				for(int j=1;j<=15;j++)
				{
					if(tot[j]>=1)
					{
						tot[j]--;
						now++;
						dfs(p,i);
						tot[j]++;
						now--;
					}
					if(tot[j]>=2)
					{
						tot[j]-=2;
						now++;
						dfs(p,i);
						tot[j]+=2;
						now--;
					}
				}
				tot[i]+=3;
			}
		}
		dfs(p+1,1);
		return;
	}
}
void solve()
{
	memset(tot,0,sizeof(tot));
	ans=0x3f3f3f3f;
	now=0;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		if(3<=a&&a<=13)tot[a-2]++;
		else if(a<3&&a>0)tot[a+11]++;
		else tot[b+13]++;
	}
	dfs(1,1);
	cout<<ans<<'\n';
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t>>n;
	while(t--)solve();
	return 0;
}
```

---

## 作者：S_S_H (赞：1)

一道搜索+恶心的DP---毒瘤题

...如果没有zqy大佬思路提示基本想不出来

### 考虑暴力搜顺子，DP出散牌

为什么这样是对的呢？因为只有顺子与点数相连有关（必须连着），而散牌（几带几）与号码相连无关

暴力搜索顺子可以接受吧...注意细节长度必须大于5，3，2就行。

重点是DP打散牌部分（蒟蒻不会贪心）

由于散牌与号码（点数）无关，所以设DP[ a ][ b ][ c ][ d  ][ e ]为有a张单牌，b张对,c对三连，d个炸弹，e张王的手牌状态

单张，对子和三张牌就不说了，转移道理很简单

先考虑三带一：普通牌由[ a-1 ][ c-1 ]的状态转移过来

别忘了王也可以带，由[ c-1 ][ e-1 ]转移过来

同理有四带二：可以由任意一个炸弹和两张单牌或两对牌组成

本题中王不算对子，也就是我们在[ d-1 ]的基础上可以有

1.对子算两张单牌，[ b-1 ]

2.对子正常算[ b-2 ]

3.两张王，[ e-2 ]

4.炸弹拆成两对，直接[ d-2 ]

5.正常两单牌，[ a-2 ]

6.一单牌一王，[ a-1 ][ e-1 ]

三带二二只能是对，只有[ c-1 ][ b-1 ]

火箭（王炸）两张王，[ e-2 ]

这样就完事了吗？不，考虑c和d号码相同可以拆牌

于是有：[ a+1 ][ b+1 ][ c-1 ]和[ a+1 ][ c+1 ][ d-1 ]两种拆法

这里拆牌，才是本题这种解法的关键

读到这里，可能会有两个问题

1.为什么拆牌可能会更新最小值？

2.为什么只能拆c和d，不能拆b?

3.为什么不能成拆更多的牌，如[ c-2 ]？

答案1:其实反着想并不好想，但我们应考虑这样一个问题：

比如现在我们有111333444。按照正常DP出的话，不能是顺子，出散牌的话只能三个三张牌，出三次

但显然我们可以1113+44433三带一+三带二两次出出去

所以我们这里就相当与将一套三张牌拆成一张一对，更新了最小值

答案2：额，成套的散牌只有三带一，三带一对，四带二和四带一对

观察发现，几带几都是可以有对的，不需要拆呀。。。

而且对只能拆两张单，直接出一对肯定定比出两张单好，次数少1嘛

答案3：这个问题其实不难想，

因为若有[ a+2 ][ b+2 ][ c-2 ] (另一种一样)，它会被[ a+1 ][ b+1 ][ c-1 ]

转移时直接考虑到，已转移过，不需再转移

好了说了这么多，下面给出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<memory.h>
#include<algorithm>
using namespace std;
int t,n,ans;
int dp[30][30][30][30][5],sum[20],cnt[10],ml[4];
void init(){
	ml[1]=5;ml[2]=3;ml[3]=2;
	memset(dp,0x3f,sizeof(dp));
	dp[0][0][0][0][0]=0;
	for(int d=0;d<=25;d++){
		for(int c=0;c<=25;c++){
			for(int a=0;a<=25;a++){
				for(int b=0;b<=25;b++){
					for(int e=0;e<=2;e++){
					int minn=0x3f;
					if(a>0) minn=min(minn,dp[a-1][b][c][d][e]+1);
					if(b>0) minn=min(minn,dp[a][b-1][c][d][e]+1);
					if(c>0) minn=min(minn,dp[a][b][c-1][d][e]+1);
					if(d>0) minn=min(minn,dp[a][b][c][d-1][e]+1);
					if(e>0) minn=min(minn,dp[a][b][c][d][e-1]+1);
					//单张
					if(b>0&&d>0) minn=min(minn,dp[a][b-1][c][d-1][e]+1);
					if(d>0&&e>1) minn=min(minn,dp[a][b][c][d-1][e-2]+1);
					if(b>1&&d>0) minn=min(minn,dp[a][b-2][c][d-1][e]+1);
					if(d>1) minn=min(minn,dp[a][b][c][d-2][e]+1);
					if(a>1&&d>0) minn=min(minn,dp[a-2][b][c][d-1][e]+1);
					if(a>0&&d>0&&e>0) minn=min(minn,dp[a-1][b][c][d-1][e-1]+1);
					//四带二
					if(c>0&&e>0) minn=min(minn,dp[a][b][c-1][d][e-1]+1);
					if(a>0&&c>0) minn=min(minn,dp[a-1][b][c-1][d][e]+1);
					//三带一
					if(b>0&&c>0) minn=min(minn,dp[a][b-1][c-1][d][e]+1);
					//三带二
					if(c>0) minn=min(minn,dp[a+1][b+1][c-1][d][e]);
					if(d>0) minn=min(minn,dp[a+1][b][c+1][d-1][e]);
					//拆牌
					if(e>1) minn=min(minn,dp[a][b][c][d][e-2]+1);
					//王炸
					dp[a][b][c][d][e]=min(dp[a][b][c][d][e],minn); 
					}
				}
			}
		}
	}		
}
void dfs(int step){
	if(step>=ans) return;
	int len;
	for(int k=1;k<=3;k++){
		for(int st=1;st<=12;st++){
			len=0;
			while(sum[st+len]>=k&&st+len<=12) len++;
			for(int s=len;s>=ml[k];s--){
				int end=st+s-1;
				for(int i=st;i<=end;i++) sum[i]-=k;
				dfs(step+1);//搜顺子真的很暴力
				for(int i=st;i<=end;i++) sum[i]+=k;
			}
		} 
	}
	cnt[1]=cnt[2]=cnt[3]=cnt[4]=cnt[5]=0;
	for(int i=1;i<=13;i++) cnt[sum[i]]++;cnt[5]=sum[14];
	ans=min(ans,step+dp[cnt[1]][cnt[2]][cnt[3]][cnt[4]][cnt[5]]);
}
int main(){
	scanf("%d%d",&t,&n);
    init();    
	while(t--){
    	memset(sum,0,sizeof(sum));
		ans=n;
    	for(int i=1;i<=n;i++){
    		int num,col;
			scanf("%d%d",&num,&col);
    		if(num==0) sum[14]++;
    		else if(num>=3) sum[num-2]++;
    		else if(num==1) sum[12]++;
    		else if(num==2) sum[13]++;
		}
		dfs(0);
		printf("%d\n",ans);
	}
	return 0;
}
```

### 最后祝大家CSP NOI XXXOI RP++! ! !

---

## 作者：双管荧光灯 (赞：1)

此题可以状压dp，设状态dp[i][j]表示出到第i小的牌，已出牌的集合为j，最少还要多少次才能出完

首先把牌的大小(345678910JQK12王，大小王算同一种牌)用桶排序(花色没用)，然后分情况讨论各种出牌方式

直接做可能会TLE，所以有以下两个优化：
1. 可以从按顺序选，因为目前最小的牌最后都是应该出掉的，那我们就可以最先出掉它
2. 对于同一种牌i，要按顺序存储，例如如果它选了2张，那么就把它所代表位置最前面2个置为1(如果已经有1了，就要往后移，比如：有5张牌3 4 4 4 5，j为11001如果要选一个4，j就变为11101

对于1，由于可以在最小牌在之后找一个三张凑成三带一(或四带二等情况)，要多讨论很多情况，可以暂时跳过，但之后i不会因此减小，即跳过之后只能靠三带一四带二来出它

另外，由于数组十分大，每次都memset会超时,所以做完之后还要一遍dfs来清0

Code：
```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
using namespace std;
int t,n,i,a,b,f[25],dp[15][10000005],s[25],tf[25];
int dfs(int t,int p)
{
	while(f[t]==0&&t<=14)
		t++;
	if(t>14)
		if(p==(1<<n)-1)//判断是否出完了 
			return 0;
		else
			return 1<<30;
	if(dp[t][p]!=0)
		return dp[t][p];
	int i,j;
	int m=1<<30;
	if(f[t]==4)
	{
		f[t]=0;
		for(i=1;i<=14;i++)
			for(j=i;j<=14;j++)
			{
				f[i]--;
				f[j]--;
				if(f[i]>=0&&f[j]>=0)
					if(i==j)
						m=min(m,dfs(t+1,p|(3<<s[i-1]+tf[i]-f[i]-2)|(15<<s[t-1]))+1);//四带两张相同牌 
					else
						m=min(m,dfs(t+1,p|(1<<s[i-1]+tf[i]-f[i]-1)|(1<<s[j-1]+tf[j]-f[j]-1)|(15<<s[t-1]))+1);//四带两张不同牌 
				f[i]++;
				f[j]++;
				f[i]-=2;
				f[j]-=2;
				if(f[i]>=0&&f[j]>=0&&i!=14&&j!=14)
					if(i==j)
						m=min(m,dfs(t+1,p|(15<<s[i-1])|(15<<s[t-1]))+1);//四带两对相同牌 
					else
						m=min(m,dfs(t+1,p|(3<<s[i-1]+tf[i]-f[i]-2)|(15<<s[t-1])|(3<<s[j-1]+tf[j]-f[j]-2))+1);//四带两对不同牌 
				f[i]+=2;
				f[j]+=2;
			}
		m=min(m,dfs(t+1,p|(15<<s[t-1]))+1);//出四张 
		f[t]=4;
	}
	if(f[t]>=3)
	{
		f[t]-=3;
		for(i=1;i<=14;i++)
		{
			if(f[i]>=1)
			{
				f[i]--;
				m=min(m,dfs(t,p|(7<<s[t-1]+tf[t]-f[t]-3)|(1<<s[i-1]+tf[i]-f[i]-1))+1);//三带一 
				f[i]++;
			}
			if(f[i]>=2&&i!=14)
			{
				f[i]-=2;
				m=min(m,dfs(t,p|(7<<s[t-1]+tf[t]-f[t]-3)|(3<<s[i-1]+tf[i]-f[i]-2))+1);//三带二 
				f[i]+=2;
			}
		}
		m=min(m,dfs(t,p|(7<<s[t-1]+tf[t]-f[t]-3))+1);//出三张 
		int pp=p|(7<<s[t-1]+tf[t]-f[t]-3);
		for(i=t+1;i<=12;i++)
			if(f[i]>=3)
			{
				f[i]-=3;
				pp|=7<<s[i-1]+tf[i]-f[i]-3;
				m=min(m,dfs(t,pp)+1);//出三顺子 
			}
			else
				break;
		for(i--;i>=t;i--)
			f[i]+=3;
	}
	if(f[t]>=2)
	{
		f[t]-=2;
		int pp=p|(3<<s[t-1]+tf[t]-f[t]-2);
		if(f[t+1]>=2)
		{
			f[t+1]-=2;
			pp|=3<<s[t]+tf[t+1]-f[t+1]-2;
			for(i=t+2;i<=12;i++)
			if(f[i]>=2)
			{
				f[i]-=2;
				pp|=3<<s[i-1]+tf[i]-f[i]-2;
				m=min(m,dfs(t,pp)+1);//出双顺 
			}
			else
				break;
			for(i--;i>t;i--)
				f[i]+=2;
		}
		m=min(m,dfs(t,p|(3<<s[t-1]+tf[t]-f[t]-2))+1);//出对子 
		f[t]+=2;
	}
	f[t]--;
	int pp=p|(1<<s[t-1]+tf[t]-f[t]-1);
	if(f[t+1]>=1&&f[t+2]>=1&&f[t+3]>=1)
	{
		f[t+1]--;f[t+2]--;f[t+3]--;
		pp|=(1<<s[t]+tf[t+1]-f[t+1]-1)|(1<<s[t+1]+tf[t+2]-f[t+2]-1)|(1<<s[t+2]+tf[t+3]-f[t+3]-1);
		for(i=t+4;i<=12;i++)
			if(f[i]>=1)
			{
				f[i]--;
				pp|=1<<s[i-1]+tf[i]-f[i]-1;
				m=min(m,dfs(t,pp)+1);//出顺子 
			}
			else
				break;
		for(i--;i>t;i--)
			f[i]++;
	}
	m=min(m,dfs(t,p|(1<<s[t-1]+tf[t]-f[t]-1))+1);//出单张 
	f[t]++;
	m=min(m,dfs(t+1,p));//跳过 
	dp[t][p]=m;
	return m;
}
void mem(int t,int p)//清空dp数组 
{
	while(f[t]==0&&t<=14)
		t++;
	if(t>14)
		return;
	if(dp[t][p]==0)
		return;
	dp[t][p]=0;
	int i,j;
	if(f[t]==4)
	{
		f[t]=0;
		for(i=1;i<=14;i++)
			for(j=i;j<=14;j++)
			{
				f[i]--;
				f[j]--;
				if(f[i]>=0&&f[j]>=0)
					if(i==j)
						mem(t+1,p|(3<<s[i-1]+tf[i]-f[i]-2)|(15<<s[t-1]));
					else
						mem(t+1,p|(1<<s[i-1]+tf[i]-f[i]-1)|(1<<s[j-1]+tf[j]-f[j]-1)|(15<<s[t-1]));
				f[i]++;
				f[j]++;
				f[i]-=2;
				f[j]-=2;
				if(f[i]>=0&&f[j]>=0&&i!=14&&j!=14)
					if(i==j)
						mem(t+1,p|(15<<s[i-1])|(15<<s[t-1]));
					else
						mem(t+1,p|(3<<s[i-1]+tf[i]-f[i]-2)|(15<<s[t-1])|(3<<s[j-1]+tf[j]-f[j]-2));
				f[i]+=2;
				f[j]+=2;
			}
		mem(t+1,p|(15<<s[t-1]));
		f[t]=4;
	}
	if(f[t]>=3)
	{
		f[t]-=3;
		for(i=1;i<=14;i++)
		{
			if(f[i]>=1)
			{
				f[i]--;
				mem(t,p|(7<<s[t-1]+tf[t]-f[t]-3)|(1<<s[i-1]+tf[i]-f[i]-1));
				f[i]++;
			}
			if(f[i]>=2&&i!=14)
			{
				f[i]-=2;
				mem(t,p|(7<<s[t-1]+tf[t]-f[t]-3)|(3<<s[i-1]+tf[i]-f[i]-2));
				f[i]+=2;
			}
		}
		mem(t,p|(7<<s[t-1]+tf[t]-f[t]-3));
		int pp=p|(7<<s[t-1]+tf[t]-f[t]-3);
		for(i=t+1;i<=12;i++)
			if(f[i]>=3)
			{
				f[i]-=3;
				pp|=7<<s[i-1]+tf[i]-f[i]-3;
				mem(t,pp);
			}
			else
				break;
		for(i--;i>=t;i--)
			f[i]+=3;
	}
	if(f[t]>=2)
	{
		f[t]-=2;
		int pp=p|(3<<s[t-1]+tf[t]-f[t]-2);
		if(f[t+1]>=2)
		{
			f[t+1]-=2;
			pp|=3<<s[t]+tf[t+1]-f[t+1]-2;
			for(i=t+2;i<=12;i++)
			if(f[i]>=2)
			{
				f[i]-=2;
				pp|=3<<s[i-1]+tf[i]-f[i]-2;
				mem(t,pp);
			}
			else
				break;
			for(i--;i>t;i--)
				f[i]+=2;
		}
		mem(t,p|(3<<s[t-1]+tf[t]-f[t]-2));
		f[t]+=2;
	}
	f[t]--;
	int pp=p|(1<<s[t-1]+tf[t]-f[t]-1);
	if(f[t+1]>=1&&f[t+2]>=1&&f[t+3]>=1)
	{
		f[t+1]--;f[t+2]--;f[t+3]--;
		pp|=(1<<s[t]+tf[t+1]-f[t+1]-1)|(1<<s[t+1]+tf[t+2]-f[t+2]-1)|(1<<s[t+2]+tf[t+3]-f[t+3]-1);
		for(i=t+4;i<=12;i++)
			if(f[i]>=1)
			{
				f[i]--;
				pp|=1<<s[i-1]+tf[i]-f[i]-1;
				mem(t,pp);
			}
			else
				break;
		for(i--;i>t;i--)
			f[i]++;
	}
	mem(t,p|(1<<s[t-1]+tf[t]-f[t]-1));
	f[t]++;
	mem(t+1,p);
	return;
}
int main()
{
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
	scanf("%d %d",&t,&n);
	while(t--)
	{
		memset(f,0,sizeof(f));
		for(i=1;i<=n;i++)
		{
			scanf("%d %d",&a,&b);
			if(a==0)//桶排,注意：按牌的大小，而不是数码 
				f[14]++;
			else
				if(a<=2)
					f[a+11]++;
				else
					f[a-2]++;
		}
		for(i=1;i<=14;i++)
			tf[i]=f[i];
		for(i=1;i<=14;i++)
			s[i]=s[i-1]+f[i];
		printf("%d\n",dfs(1,0));
		mem(1,0);
	}
}

```

---

## 作者：cyntmeay (赞：1)

#### 题目大意
就是有 $n$ 张牌，然后按题目的要求打出，问最少要出多少次才能将这 $n$ 张牌全部出完。
#### 算法分析
发现题目中 $n$ 的范围比较小并且出牌的方式较为复杂所以不难想到本题可以使用搜索来做。
#### 如何实现
1. 火箭与对子牌其实可以看成同一种。
2. 从题目来看三种顺子的使用价值从此题看来是比较大的，所以在搜索时应优先考虑这几种情况。
3. 最后将这几种情况分开处理即可通过本题。
4. 四带二时可以带两对牌。

知道了这些细节，这个题就能做出来了。
#### 献上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int n;
int a[20];
int ans;
void dfs(int z){//计算出牌方案
	if(z>=ans){
		return ;
	}
	int s=0;
	for(int i=3; i<=14; i++){
		if(a[i]==0){
			s=0;
		}
		else{
			s++;
		}
		if(s>=5){
			for(int j=i-s+1; j<=i; j++){
				a[j]--;
			}
			dfs(z+1);
			for(int j=i-s+1; j<=i; j++){
				a[j]++;
			}
		}
	}
	s=0;
	for(int i=3; i<=14; i++){
		if(a[i]<2){
			s=0;
		}
		else{
			s++;
		}
		if(s>=3){
			for(int j=i-s+1; j<=i; j++){
				a[j]-=2;
			}
			dfs(z+1);
			for(int j=i-s+1; j<=i; j++){
				a[j]+=2;
			}
		}
	}
	s=0;
	for(int i=3; i<=14; i++){
		if(a[i]<3){
			s=0;
		}
		else{
			s++;
		}
		if(s>=2){
			for(int j=i-s+1; j<=i; j++){
				a[j]-=3;
			}
			dfs(z+1);
			for(int j=i-s+1; j<=i; j++){
				a[j]+=3;
			}
		}
	}
	s=0;
	for(int i=2; i<=14; i++){
		if(a[i]<3){
			continue;
		}
		a[i]-=3;
		for(int j=2; j<=15; j++){
			if(a[j]==0||i==j){
				continue;
			}
			a[j]--;
			dfs(z+1);
			a[j]++;
		}
		for(int j=2; j<=14; j++){
			if(a[j]<2||i==j){
				continue;
			}
			a[j]-=2;
			dfs(z+1);
			a[j]+=2;
		}
		a[i]+=3;
	}
	for(int i=2; i<=14; i++){
		if(a[i]<4){
			continue;
		}
		a[i]-=4;
		for(int j=2; j<=15; j++){
			if(a[j]==0||i==j){
				continue;
			}
			a[j]--;
			for(int j1=2; j1<=15; j1++){
				if(a[j1]==0||i==j1||j==j1){
					continue;
				}
				a[j1]--;
				dfs(z+1);
				a[j1]++; 
			}
			a[j]++;
		}
		for(int j=2; j<=14; j++){
			if(a[j]<2||i==j){
				continue;
			}
			a[j]-=2;
			for(int j1=2; j1<=14; j1++){
				if(a[j1]<2||i==j1||j==j1){
					continue;
				}
				a[j1]-=2;
				dfs(z+1);
				a[j1]+=2;
			}
			a[j]+=2;
		}
		a[i]+=4;
	}
	for(int i=2; i<=15; i++){
		if(a[i]!=0){
			z++;
		}
	}
	ans=min(ans,z);
}
int main(){
	scanf("%d%d",&t,&n);
	while(t--){
		int x,y;
		memset(a,0,sizeof(a));
		ans=1e8;
		for(int i=1; i<=n; i++){
			scanf("%d%d",&x,&y);
			if(x==0){
				a[15]++;
			}
			else{
				if(x==1){
					a[14]++;
				}
				else{
					a[x]++;
				}
			}
		}
		dfs(0);
		printf("%d\n",ans);
	}
	return 0;
}
```
#### 题目总结
这道题的整体思路较为简单，只用注意代码的实现问题就不大了。

---

## 作者：yzht (赞：0)

## 题目大意
现在手里有 $n$ 张牌，现在要按如下规则打出，问的问题最少要打都少次。
![P2668打牌规则](https://cdn.luogu.com.cn/upload/pic/1827.png)
## 题目分析
根据数据范围可以发现题目中 $n \le 23$，看到这个数据范围很容易让人想到爆搜。实际上也确实如此，这个题按照先顺子，再处理其他的牌即可。
## 注意事项
四带二时可以带两队牌！！！
## 小优化
也没有什么，只是发现火箭和对子牌是等价的。
## 给出代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int n;
int a[20];
int ans;
void dfs(int z){//计算出牌方案
	if (z >= ans) {
		return ;//递归返回 
	}
	int s = 0;
	for (int i = 3; i <= 14; i++) {
		if (a[i] == 0) {
			s = 0;
		}
		else {
			s++;
		}
		if (s >= 5) {
			for (int j = i- s+ 1; j <= i; j++) {
				a[j]--;
			}
			dfs(z+1);
			for (int j = i - s + 1; j <= i; j++) {
				a[j]++;
			}
		}
	}
	s = 0;
	for (int i = 3; i <= 14; i++) {
		if (a[i] < 2) {
			s = 0;
		}
		else {
			s++;
		}
		if (s >= 3) {
			for (int j = i - s + 1; j <= i; j++) {
				a[j] -= 2;
			}
			dfs(z + 1);
			for (int j = i - s + 1; j <= i; j++) {
				a[j] += 2;
			}
		}
	}
	s = 0;
	for (int i = 3; i <= 14; i++) {
		if (a[i] < 3) {
			s = 0;
		}
		else {
			s++;
		}
		if (s >= 2) {
			for (int j = i - s + 1; j <=i; j++) {
				a[j] -= 3;
			}
			dfs(z + 1);
			for (int j = i - s + 1; j <= i; j++){
				a[j] += 3;
			}
		}
	}
	s = 0;
	for (int i = 2; i <= 14; i++){
		if (a[i] < 3){
			continue;
		}
		a[i] -= 3;
		for (int j = 2; j <= 15; j++) {
			if (a[j] == 0||i == j) {
				continue;
			}
			a[j]--;
			dfs(z + 1);
			a[j]++;
		}
		for (int j = 2; j <= 14; j++) {
			if (a[j] < 2 || i == j) {
				continue;
			}
			a[j] -= 2;
			dfs(z + 1);
			a[j] += 2;
		}
		a[i] += 3;
	}
	for (int i = 2; i <= 14; i++) {
		if(a[i] < 4){
			continue;
		}
		a[i] -= 4;
		for (int j = 2; j <= 15; j++) {
			if(a[j] == 0 || i == j) {
				continue;
			}
			a[j]--;
			for (int j1 = 2; j1 <= 15; j1++) {
				if (a[j1] == 0 || i == j1 || j == j1) {
					continue;
				}
				a[j1]--;
				dfs(z + 1);
				a[j1]++; 
			}
			a[j]++;
		}
		for (int j = 2; j <= 14; j++) {
			if(a[j] < 2 || i == j) {
				continue;
			}
			a[j]-=2;
			for(int j1=2; j1<=14; j1++){
				if(a[j1]<2||i==j1||j==j1){
					continue;
				}
				a[j1] -= 2;
				dfs(z + 1);
				a[j1] += 2;
			}
			a[j] += 2;
		}
		a[i] += 4;
	}
	for (int i = 2; i <= 15; i++) {
		if (a[i] != 0) {
			z++;
		}
	}
	ans = min(ans,z);
}
int main(){
	scanf("%d%d",&t,&n);
	while (t--) {
		int x,y;
		memset(a,0,sizeof(a));
		ans = 1e8;
		for (int i = 1; i <= n; i++) {
			scanf("%d%d",&x,&y);
			if (x == 0) {
				a[15]++;
			}
			else{
				if (x == 1) {
					a[14]++;
				}
				else{
					a[x]++;
				}
			}
		}
		dfs(0);
		printf("%d\n",ans);
	}
	return 0;
}
```
## 题目总结
像这种只是代码复杂的题只要仔细一点就应该没问题了。


住：本蒟蒻借鉴了[大佬](https://www.luogu.com.cn/user/836804)的代码，此大佬题解已经过审，本蒟蒻一开始也不会做。本蒟蒻的第一篇题解，求过审。

---


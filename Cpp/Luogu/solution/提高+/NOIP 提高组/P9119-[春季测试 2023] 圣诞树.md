# [春季测试 2023] 圣诞树

## 题目描述

众所周知，3202 年的圣诞节快要到了，因此小 Ω 买了一棵圣诞树和一根挂满了彩灯的电线，并打算把这根电线缠绕在圣诞树上。

圣诞树可以视作一个二维平面上有 $n$ 个顶点的**凸多边形**。这 $n$ 个顶点可以用于固定电线，且按**逆时针顺序**依次编号为 $1, \ldots, n$。其中第 $i$ 个顶点的坐标为 $(x_i, y_i)$，记其中 **$y$ 坐标最大**的顶点的编号为 $k$（若有多个满足条件的顶点，则取**编号最小**的）。不保证编号为 $1$ 的顶点的 $x$ 坐标最小。

下图左侧展示了一棵圣诞树的轮廓，其中 **$y$ 坐标最大**的顶点的编号为 $k = 5$。

![图 2：一棵圣诞树及一种可能的挂电线的方案](https://cdn.luogu.com.cn/upload/image_hosting/ayjegrhj.png)

小 Ω 希望用挂满了彩灯的电线装饰这棵圣诞树。出于美观性考虑，她希望这根电线**经过所有顶点恰好一次**；为了连接电源，这根电线需要**从 $(x_k, y_k)$ 出发**。形式化地，她需要决定一个 $1, \cdots, n$ 的**排列** $p_1, \cdots, p_n$，满足 $p_1 = k$，随后这根电线从 $(x_{p_1}, y_{p_1})$ 出发，依次经过 $(x_{p_2}, y_{p_2}), \cdots, (x_{p_n}, y_{p_n})$。此时，电线长度为 $\sum_{i=1}^{n-1}{\operatorname{d}((x_{p_i}, y_{p_i}), (x_{p_{i+1}}, y_{p_{i+1}}))}$。

- 其中 $\operatorname{d}$ 为平面上的**欧几里得距离**，即 $\operatorname{d}((x, y), (x', y')) = \sqrt{(x - x')^2 + (y - y')^2}$。

上图右侧展示了一种可能的方案，此时对应的排列为 $5, 4, 8, 6, 3, 9, 1, 7, 2$。

为了节省成本，她希望你能在所有可能的方案中，给出一种使电线长度**最短**的方案。如果使电线长度最短的方案不唯一，你只需要求出其中**任意**一种。

**考虑到浮点数产生的误差，你输出的方案与最优方案的线段长度的相对误差或绝对误差不超过 $10^{-10}$ 时即认为答案正确**。


## 说明/提示

**【样例 1 解释】**

这一样例中只有下图所示的两种方案，对应排列分别为 $3, 1, 2$ 或 $3, 2, 1$，电线长度分别为 $3 + \sqrt{2}$ 和 $3 + \sqrt{5}$，而 $3 + \sqrt{2} < 3 + \sqrt{5}$。

因此答案对应的排列为 $3, 1, 2$。

![图 3：样例 1 的全部两种可能的方案](https://cdn.luogu.com.cn/upload/image_hosting/tcwvp72y.png)

**【数据范围】**

对于所有数据，保证 $3 \le n \le 1000$；$|x_i|, |y_i| \le 10^7$。

|测试点编号|$n \le$|特殊性质|
|:-:|:-:|:-:|
|1, 2|$4$|无|
|3, 4, 5, 6|$9$|无|
|7, 8, 9, 10, 11, 12|$18$|无|
|13, 14|$10^3$|A|
|15, 16|$10^3$|B|
|17, 18, 19, 20|$10^3$|无|

特殊性质 A：保证存在正整数 $m \ge n$，使得输入的 $n$ 个顶点对应正 $m$ 边形中连续的一段顶点。

特殊性质 B：保证 $x_1 < x_2 < \cdots < x_n$，且 $y_1 > y_2 > \cdots > y_n$。


## 样例 #1

### 输入

```
3
0.000000000 0.000000000
3.000000000 0.000000000
1.000000000 1.000000000
```

### 输出

```
3 1 2
```

# 题解

## 作者：Grow2011 (赞：24)

区间 DP 的思路各位大佬已经讲得很清楚了，我就不多说了，但有几个点大佬们并没有讲，我来~~水篇题解~~给大家讲一下。

1. 关于为什么交叉比不交叉更优的证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/qygtblxx.png?x-oss-process=image/resize,m_lfit,h_300,w_300)

$\because$ 三角形中两边之和大于第三边。

$\therefore  DE+CE>CD,AE+BE>AB$。

$\therefore  DE+CE+AE+BE>AB+CD$。

$\therefore  BD+AC>AB+CD$。

$\therefore  BD+AC+BC>AB+CD+BC$。

综上，走交叉的路一定比走不交叉的路路程长。

2. 如何根据结果来反推方案：

这个可能是蒟蒻们最关心的，但其实没有那么难。

我们只需要在每次计算完记录一下当前最优的上一步是从哪里推过来的，储存在 last 数组中，最后只需要找到最小的答案，再一步一步往上推，在中途压入栈，最后输出即可。

3. DP 的初始值：

这不是讲 DP 初始值该赋什么，而是讲另一件事：

**double 型变量不可以使用 memset 初始化！！！**

我在这里调了好久(悲)。

注意：统计 $y$ 坐标时，maxx 的初始值一定要设为 $-10^9$ ，否则就 90，本人就在这里卡了好几个小时（可能是我太蒟了）：
[90分记录](https://www.luogu.com.cn/record/117441489)&&
[AC记录](https://www.luogu.com.cn/record/117441884)。

附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,id;
}last[2005][2005][2];
int n,id,al,bl,fl;
double x[2005],y[2005],maxn=-1e9,dp[2005][2005][2],ans = 1e9;//maxn一定记得设成-1e9！！！
double wok(int i,int j){
	double a = pow((x[i]-x[j]),2);
	double b = pow((y[i]-y[j]),2);
    return sqrt(a+b);
}//计算两点之间的距离
signed main(){
    cin >> n;
    for(int i = 1;i<=n;i++){
    	cin >> x[i] >> y[i];
    	if(maxn<y[i]){
    		maxn=y[i];
    		id = i;
		}
		//求y坐标最大值
    }
    for(int i = 1;i<=n*2;i++){
    	for(int j = i;j<=n*2;j++){
    		dp[i][j][0]=dp[i][j][1]=1e9;//初始化，一定不要用memset!!!
		}
	}
    dp[id][id][0]=dp[id][id][1]=0;
    dp[id+n][id+n][0]=dp[id+n][id+n][1]=0;//对最高点进行初始化
    for(int i = 1;i<=n;i++)x[i+n]=x[i],y[i+n]=y[i];//序列倍增
    for(int len = 2;len<=n;len++){
    	for(int i = 1;i+len-1<=n*2;i++){
    		int j = i+len-1;
    		double a = dp[i+1][j][0]+wok(i,i+1);
    		double b = dp[i+1][j][1]+wok(i,j);
    		if(a>b)dp[i][j][0]=b,last[i][j][0].l=i+1,last[i][j][0].r=j,last[i][j][0].id=1;
    		else dp[i][j][0]=a,last[i][j][0].l=i+1,last[i][j][0].r=j,last[i][j][0].id=0;
    		a = dp[i][j-1][1]+wok(j-1,j);
    		b = dp[i][j-1][0]+wok(i,j);
    		if(a>b)dp[i][j][1]=b,last[i][j][1].l=i,last[i][j][1].r=j-1,last[i][j][1].id=0;
    		else dp[i][j][1]=a,last[i][j][1].l=i,last[i][j][1].r=j-1,last[i][j][1].id=1;
    		//转移
		}
	}//求DP和last的值，其中last表示当前最优的上一步是从哪里推过来的
	for(int i = 1;i+n-1<=n*2;i++){
		int j = i+n-1;
		if(ans>dp[i][j][1]){
			al = i;
			bl = j;
			fl = 1;
			ans = dp[i][j][1];
		}
		if(ans>dp[i][j][0]){
			al = i;
			bl = j;
			fl = 0;
			ans = dp[i][j][0];
		}
	}//寻找最小值的DP位置
	stack<int>st;
	if(fl == 1)st.push(bl%n);
	else st.push(al%n);
	for(int i = 1;i<n-1;i++){
		int l = last[al][bl][fl].l;
		int r = last[al][bl][fl].r;
		int idd = last[al][bl][fl].id;
		al = l;
		bl = r;
		fl = idd;
		//更新当前位置
		if(fl == 1)st.push(bl%n);
		else st.push(al%n);
		//将上一步的位置压入栈
	}
	cout << id << " ";
	while(!st.empty()){
		if(st.top()==0)cout << n << " ";
		else cout << st.top() << " ";
		//输出答案
		st.pop();
		//一定要pop，不然会死循环
	}
    return 0;
}
```

---

## 作者：ncwzdlsd (赞：18)

区间 DP。

设计状态 $f(l,r,0/1)$ 表示经过区间 $[l,r]$ 内的点，当前位置在左/右时的最小花费。

思路是根据已有的区间向外扩展，转移方程

$$
\begin{cases}
f(l,r,0)=\min(f(l+1,r,0)+dis(l,l+1),f(l+1,r,1)+dis(l,r))\\
f(l,r,1)=\min(f(l,r-1,0)+dis(l,r),f(l,r-1,1)+dis(r-1,r))
\end{cases}
$$

对于输出方案，转移时记录前驱即可。

时间复杂度 $O(n^2)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1005;
struct node{double x,y;int id;}a[maxn],tmp[maxn];
double f[maxn][maxn][2];
int pre[maxn][maxn][2];

double dis(int i,int j){return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));}

void print(int l,int r,int op)
{
    if(l==r) return cout<<a[l].id<<' ',void();
    if(op) cout<<a[r].id<<' ',print(l,r-1,pre[l][r][op]);
    else cout<<a[l].id<<' ',print(l+1,r,pre[l][r][op]);
}

int main()
{
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y,a[i].id=i,tmp[i]=a[i];
    int k=1;
    for(int i=2;i<=n;i++) if(a[i].y>a[k].y) k=i;
    for(int i=1;i<=k;i++) a[i+n-k]=tmp[i];
    for(int i=k+1;i<=n;i++) a[i-k]=tmp[i];
    for(int len=2;len<n;len++)
        for(int i=1,j=len;j<n;i++,j++)
        {
            f[i][j][0]=f[i][j][1]=1e18;
            if(f[i][j][0]>f[i+1][j][0]+dis(i,i+1)) f[i][j][0]=f[i+1][j][0]+dis(i,i+1),pre[i][j][0]=0;
            if(f[i][j][0]>f[i+1][j][1]+dis(i,j)) f[i][j][0]=f[i+1][j][1]+dis(i,j),pre[i][j][0]=1;
            if(f[i][j][1]>f[i][j-1][0]+dis(j,i)) f[i][j][1]=f[i][j-1][0]+dis(i,j),pre[i][j][1]=0;
            if(f[i][j][1]>f[i][j-1][1]+dis(j,j-1)) f[i][j][1]=f[i][j-1][1]+dis(j,j-1),pre[i][j][1]=1;
        }
    cout<<a[n].id<<' ';
    if(f[1][n-1][0]+dis(1,n)>f[1][n-1][1]+dis(n-1,n)) print(1,n-1,1);
    else print(1,n-1,0);
    return 0;
}
```

---

## 作者：Leasier (赞：13)

首先我们需要注意到如下结论：

- 最优方案中没有两条线段相交。

证明：考虑两条路径 $A \to B \to C \to D, A \to C \to B \to D$，若 $AC, BD$ 相交（设交于 $P$）但 $AB, CD$ 不交，则 $(AB + BC + CD) - (AC + CB + BD) = AB + CD - AC - BD = (AB - AP - BP) + (CD - CP - DP) < 0$，即不交更优。

于是我们倍长序列后区间 dp 即可。状态中需要记录区间与上一次选的左边还是右边。

时间复杂度为 $O(n^2)$。

代码：
```cpp
#include <stdio.h>
#include <math.h>

int pre[2007][2007][7], ans[1007];
double x[2007], y[2007], dp[2007][2007][7];

inline double sqr(double n){
	return n * n;
}

inline double get_dis(int a, int b){
	return sqrt(sqr(x[a] - x[b]) + sqr(y[a] - y[b]));
}

int main(){
	int n, m, k = -1, k_, pos1, pos2;
	double val = 1e18;
	scanf("%d", &n);
	m = n * 2;
	for (int i = 1; i <= n; i++){
		scanf("%lf %lf", &x[i], &y[i]);
		if (k == -1 || y[k] < y[i]) k = i;
	}
	k_ = k + n;
	for (int i = n + 1; i <= m; i++){
		int i_ = i - n;
		x[i] = x[i_];
		y[i] = y[i_];
	}
	for (int i = 1; i <= m; i++){
		for (int j = i; j <= m; j++){
			dp[i][j][0] = dp[i][j][1] = 1e18;
		}
	}
	dp[k][k][0] = dp[k_][k_][0] = 0.0;
	for (int i = 2; i <= n; i++){
		for (int j = 1, x = i; x <= m; j++, x++){
			double p = dp[j + 1][x][0] + get_dis(j, j + 1), q = dp[j + 1][x][1] + get_dis(j, x);
			if (p < q){
				dp[j][x][0] = p;
				pre[j][x][0] = 0;
			} else {
				dp[j][x][0] = q;
				pre[j][x][0] = 1;
			}
			p = dp[j][x - 1][0] + get_dis(x, j);
			q = dp[j][x - 1][1] + get_dis(x, x - 1);
			if (p < q){
				dp[j][x][1] = p;
				pre[j][x][1] = 0;
			} else {
				dp[j][x][1] = q;
				pre[j][x][1] = 1;
			}
		}
	}
	for (int i = 1, j = n; i <= n; i++, j++){
		if (val > dp[i][j][0]){
			val = dp[i][j][0];
			pos1 = i;
			pos2 = 0;
		}
		if (val > dp[i][j][1]){
			val = dp[i][j][1];
			pos1 = i;
			pos2 = 1;
		}
	}
	for (int i = n, j = pos1, x = pos1 + n - 1, y = pos2; i >= 1; i--){
		int t = pre[j][x][y];
		if (y == 0){
			ans[i] = j <= n ? j : j - n;
			j++;
		} else {
			ans[i] = x <= n ? x : x - n;
			x--;
		}
		y = t;
	}
	for (int i = 1; i <= n; i++){
		printf("%d ", ans[i]);
	}
	return 0;
}
```

---

## 作者：EricWan (赞：10)

~~本人考试时候竟然没有 A 此题~~

这题非正解分很高，使用暴力加减枝~~卡常~~、还有数据点分治就有 80 分，不再多说。

## 正解：区间 DP

我们发现，题目给出的是一个凸多边形，观察发现（自己画，不要被那个~~画得又长又臭~~题目中的图误导）现在选取的点集一定是一段连续的点（换句话说，不可能出现 $i$,$j$ 使得中间的点都选了，而 $i$ 前面的和 $j$ 后面的点没有选，然而顶点不再 $i$,$j$ 之间），这样就可以使用区间 DP 了。

定义 $dp_{i,j,k}$ 为已经走了 $i$,$j$ 之间的点了，最后停在了 $i$（$k=0$），还是 $j$（$k=1$）。

为什么这个题目我调试了好几个月呢？因为要记录路径。

这里定义 $bfr_{i,j,k}$，用于记录谁转换到了 $dp_{i,j,k}$，因为只有 $4$ 种可能来转换到一个点，所以可以用一个 $bfr$ 数组记录，最后按着 $bfr$ “回溯” 就可以了。

四种转移方法：
```
   ----------
     i     j
0：  -------!
1：        -!
2： !-
3： !-------
```

核心代码（半伪代码）：
```cpp
for (int i : T~T+1)
{
    for (int j = T~T-1)
    {
        dp[T][T][0] = dp[T][T][1] = 0;
        double now_0 = dp[i][j][0] + len(i,nxt(j));
        double now_1 = dp[i][j][1] + len(j,nxt(j));
        double now_2 = dp[i][j][0] + len(i,bf(i));
        double now_3 = dp[i][j][1] + len(j,bf(i));
        if (i == T && j != T)
        {
            now_0 = now_2 = inf;
        }
        if (j == T && i != T)
        {
            now_1 = now_3 = inf;
        }
        if (dp[i][nxt(j)][1] > now_0)
        {
            //更新
            bfr[i][nxt(j)][1] = 0;
        }
        if (dp[i][nxt(j)][1] > now_1)
        {
            //更新
            bfr[i][nxt(j)][1] = 1;
        }
        if (dp[bf(i)][j][0] > now_2)
        {
            //更新
            bfr[bf(i)][j][0] = 2;
        }
        if (dp[bf(i)][j][0] > now_3)
        {
            //更新
            bfr[bf(i)][j][0] = 3;
        }
    }
}
```

---

## 作者：Tsawke (赞：9)

# [LG-P9119 [春季测试 2023] 圣诞树](https://www.luogu.com.cn/problem/P9119) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P9119-Solution)

## [游记戳此进入](https://www.luogu.com.cn/blog/tsawke/spring-test)

### 题面

给定平面内凸包，最小化从其最高点开始的任意哈密尔顿路径（认为任意两点之间均可到达）的欧几里得距离，输出最小化的方案。存在 SPJ。

### Solution

首先对于 $ n \le 18 $，不难发现其为经典的 TSP 问题，状压后简单转移一下即可。对于性质 B，顺序输出即可。对于性质 A，目前没想到什么正确的思路。

考虑正解，发现对于任意两条路径一定不相交，证明是显然的，考虑任意四个点：

![2023_03_06_1](https://cdn.luogu.com.cn/upload/image_hosting/wr84lzfd.png)

显然由于三角形两边之和大于第三边，前者一定优于后者。

所以对于逆时针给定的若干个点，当处于 $ i $ 时，最优决策一定只能是下一步到 $ i - 1 $ 或 $ i + 1 $，否则将会存在一个点被隔离，导致最终去往该点时一定形成交叉路径。

于是此时问题显然地转化为了区间 DP，考虑将原序列倍长，设状态 $ dp(l, r, 0/1) $ 表示当前已经走过了 $ [l, r] $ 的点，且最后停在了 $ l $ 或 $ r $ 的最小的总距离，则显然对于起点 $ s $ 有 $ dp(s, s, 0) = 0, dp(s, s, 1) = 0 $。

转移也十分显然，与 [[ABC273F] Hammer 2](https://www.luogu.com.cn/problem/AT_abc273_f) 类似，即：
$$
dp(l, r, 0) = \min(dp(l + 1, r, 0) + dis(l + 1, l), dp(l + 1, r, 1) + dis(r, l)
$$

$$
dp(l, r, 1) = \min(dp(l, r - 1, 0) + dis(l, r), dp(l, r - 1, 1) + dis(r - 1, r))
$$

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

template < typename T = int >
inline T read(void);

int N;
pair < ld, ld > pts[2100];
ld dis[2100][2100];
ld dp[2100][2100][2];
tuple < int, int, int > frm[2100][2100][2];
int top(-1); ld topy(-1e8);

int main(){
    auto CalDis = [](pair < ld, ld > a, pair < ld, ld > b)->ld{
        return sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));
    };
    auto Update = [](int l, int r, int k, int sl, int sr, int sk, int dl, int dr)->void{
        if(dp[sl][sr][sk] >= 1e12)return;
        if(dp[sl][sr][sk] + dis[dl][dr] < dp[l][r][k])
            dp[l][r][k] = dp[sl][sr][sk] + dis[dl][dr], frm[l][r][k] = {sl, sr, sk};
    };

    for(int i = 0; i <= 2010; ++i)for(int j = 0; j <= 2010; ++j)for(int k = 0; k <= 1; ++k)dp[i][j][k] = 1e12;
    N = read();
    for(int i = 1; i <= N; ++i){
        scanf("%Lf%Lf", &pts[i].first, &pts[i].second);
        pts[i + N] = pts[i];
        if(pts[i].second > topy)topy = pts[i].second, top = i;
    }
    for(int i = 1; i <= N; ++i)for(int j = 1; j <= N; ++j)
        dis[i][j] = dis[i + N][j] = dis[i][j + N] = dis[i + N][j + N] = CalDis(pts[i], pts[j]);
    dp[top][top][0] = dp[top][top][1] = dp[top + N][top + N][0] = dp[top + N][top + N][1] = 0.0;
    for(int len = 2; len <= N; ++len)
        for(int l = 1; l <= (N << 1) - len + 1; ++l){
            int r = l + len - 1;
            Update(l, r, 0, l + 1, r, 0, l + 1, l);
            Update(l, r, 0, l + 1, r, 1, r, l);
            Update(l, r, 1, l, r - 1, 0, l, r);
            Update(l, r, 1, l, r - 1, 1, r - 1, r);
        }
    ld ansv(1e12); tuple < int, int, int > curp(0, 0, 0);
    for(int l = 1; l < N; ++l){
        int r = l + N - 1;
        if(dp[l][r][0] < ansv)ansv = dp[l][r][0], curp = {l, r, 0};
        if(dp[l][r][1] < ansv)ansv = dp[l][r][1], curp = {l, r, 1};
    }
    basic_string < int > rans;
    auto [l, r, k] = curp;
    auto lst = curp; curp = frm[l][r][k];
    while(get < 0 >(curp)){
        auto [l, r, k] = lst;
        auto [cl, cr, ck] = curp;
        if(l != cl)rans += l;
        else rans += r;
        lst = curp;
        curp = frm[cl][cr][ck];
    }rans += get < 0 >(lst);
    for_each(rans.rbegin(), rans.rend(), [rans](auto val)->void{printf("%d%c", val > N ? val - N : val, val == *prev(rans.rend()) ? '\n' : ' ');});
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2023_03_06 初稿

---

## 作者：cyffff (赞：8)

[$\text{Link}$](https://www.luogu.com.cn/problem/P9119)

## 题意
给你一个平面上的 $n$ 个点的凸包，求 TSP 路线，即从最高点出发并遍历所有点的最短的路径。

$n\le 1000$。
## 思路
结论：路线不会交叉。

证明：因为凸四边形对角线长度和一定大于一组对边的长度和，所以如果 $(i,j)$ 与 $(a,b)$ 交叉，我们将这两条分别更换为 $(i,a)$ 和 $(j,b)$ 答案一定变小。

对于随意一条路径，我们使用调整法，每次随便选一组交叉的边调整至不交叉，一定可以调整到整条路径不交叉。因为每次调整都会使路径长度变短，所以调整次数有限并不会调整回之前的状态。

我们从最高点开始按顺时针给每个点重新编号，为了方便，$0$ 号和 $n$ 号点都是最高点。由于路线不会交叉，所以时时刻刻没有被遍历过的结点的新编号都是一段连续的区间。

考虑设计 dp，令 $f_{l,r,0/1}$ 表示 $[l+1,r-1]$ 还没有被遍历，上一个遍历的结点是 $l/r$ 时的最短路径。

初始状态 $f_{0,n,0}=f_{0,n,1}=0$，一次转移就是 $f_{l,r,0}=\min(f_{l-1,r,0}+\text{dis}(l-1,l),f_{l-1,r,1}+\text{dis}(l,r))$，$f_{l,r,1}=\min(f_{l,r+1,0}+\text{dis}(l,r),f_{l,r+1,1}+\text{dis}(r,r+1))$。

要输出方案就记录一下决策就好了。

时间复杂度 $O(n^2)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
namespace IO{//by cyffff
	
}
const int N=1e3+10;
const ld INF=1e18;
int n,k,g[N][N][2],p[N];
ld px[N],py[N],f[N][N][2];
inline ld sqr(ld x){
	return x*x;
}
inline ld dis(int x,int y){
	return sqrt(sqr(px[p[x]]-px[p[y]])+sqr(py[p[x]]-py[p[y]]));
}
inline void answer(int l,int r,int t){
	if(l<0||r>n) return ;
	if(t==0){
		if(g[l][r][0]) answer(l-1,r,1);
		else answer(l-1,r,0);
	}else{
		if(g[l][r][1]) answer(l,r+1,1);
		else answer(l,r+1,0);
	}
	write(t?p[r]:p[l]),putc(' ');
}
int main(){
	scanf("%d",&n);
	ld tmp=-INF;
	for(int i=1;i<=n;i++){
		scanf("%Lf %Lf",px+i,py+i);
		if(py[i]>tmp) tmp=py[i],k=i;
	}
	for(int i=k;i<=n;i++)
		p[i-k]=i;
	for(int i=1;i<=k;i++)
		p[i+n-k]=i;
	for(int l=0;l<=n;l++)
		for(int r=l;r<=n;r++)
			f[l][r][0]=f[l][r][1]=INF;
	f[0][n][0]=f[0][n][1]=0;
	for(int l=0;l<=n;l++)
		for(int r=n;r>l+1;r--){
			ld LL=f[l][r][0]+dis(l,l+1),LR=f[l][r][1]+dis(r,l+1);
			if(LL<LR) f[l+1][r][0]=LL;
			else f[l+1][r][0]=LR,g[l+1][r][0]=1;
			ld RL=f[l][r][0]+dis(l,r-1),RR=f[l][r][1]+dis(r,r-1);
			if(RL<RR) f[l][r-1][1]=RL;
			else f[l][r-1][1]=RR,g[l][r-1][1]=1;
		}
	ld ans=INF;
	int pos=0,qwq=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<=1;j++){
			if(f[i][i+1][j]<ans){
				ans=f[i][i+1][j];
				pos=i,qwq=j;
			}
		}
	answer(pos,pos+1,qwq);
	flush();
}
```


---

## 作者：听取MLE声一片 (赞：8)

简要题意：在凸包上构造一条从最高点 $k$ 出发遍历每个点的路径。

凸包可以看做一个环，在环上处理。为了方便，把环上从 $k$ 开始的左边记为“左”，右边记为“右”，所以一个位置左边的点的标号可能比这个点大。

观察一下题目中给的图，可以发现：对于一个从一边下来的点，不能原路返回的上去。换成环上的表述，即为向左移动来的不能向右走，向右移动来的不能向左走。

为什么？因为如果原路返回一定会增加无意义损耗。

比较显然的走法为向左走的点向左走，向右走的点向右走。

我们设当前往左走到标号 $L$ 的点，往右走到标号 $R$ 的点，其中 $L$ 到 $R$ 之间的点都被走过。

如果有没有被走过的点，那么一定会回去，额外增加无意义损耗。

观察发现还有两个走法，是从 $L$ 走到 $R$ 以及从 $R$ 走到 $L$。

这两个走法也要满足上述要求，因为如果中间空了一些点一定是要走回去的，也会增加无意义损耗。

总结一下，路径中不能出现交点，如果出现交点一定不是最优的。

证明是四边形对角线加一条边的和肯定大于三条边的和。

考虑 dp，因为不能走回头路，确保了无后效性。

定义 dp 数组 $f_{i,j,k=0/1}$ 其中 $i$ 表示 $L$，$j$ 表示 $R$，$k$ 维表示当前在的点是左边还是右边，$0$ 为左边 $1$ 为右边

转移就按照上面所说的四个走法暴力转移即可，注意初值要设为无穷大。

为了保证无后效性，采用类似区间 dp 的转移形式。即最外层循环枚举当前一共走了多少步，然后再枚举左右点。

这里需要记录方案，在新转移比当前转移更优的时候记录下从哪里转移，最后从最优结束状态往前推即可输出方案。

为了保证代码清晰，建议把转移封装到函数里面。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1010;
const long double inf=1e18;
int n,k,L[N][N][2],R[N][N][2],P[N][N][2],id[N][N][2];
long double a[N],b[N],f[N][N][2];
stack<int>st;
long double dis(int x,int y){
	return sqrt((a[x]-a[y])*(a[x]-a[y])+(b[x]-b[y])*(b[x]-b[y]));
}
int ls(int x){
	return (x-2+n)%n+1;
}
int rs(int x){
	return x%n+1;
}
int Ls(int x,int k){
	return (x-k-1+n)%n+1;
}
int Rs(int x,int k){
	return (x+k-1)%n+1;
}
void get(int x,int y,int z,int u,int v,int w){
	L[x][y][z]=u;
	R[x][y][z]=v;
	P[x][y][z]=w;
	if(z==0)
		id[x][y][z]=x;
	else id[x][y][z]=y;
}
void push(int x,int y,int z,int u,int v,int w){
	int p=0,q=0;
	if(z==0)
		p=x;
	else p=y;
	if(w==0)
		q=u;
	else q=v;
	if(u!=k||v!=k){
		if(p==k||q==k)
			return;
	}
	if(f[x][y][z]<=f[u][v][w]+dis(p,q))
		return;
	f[x][y][z]=f[u][v][w]+dis(p,q);
	get(x,y,z,u,v,w);
}
signed main()
{
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	long double res=-inf;
	for(int i=1;i<=n;i++)
		if(b[i]>res){
			k=i;
			res=b[i];
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j][0]=f[i][j][1]=inf;
	f[k][k][0]=f[k][k][1]=0;
	push(ls(k),k,0,k,k,0);
	push(k,rs(k),1,k,k,0);
	for(int len=2;len<n;len++)
		for(int p=0;p<=len;p++){
			int q=len-p;
			int x=Ls(k,p),y=Rs(k,q);
			if(p)push(x,y,0,rs(x),y,0);
			if(p)push(x,y,0,rs(x),y,1);
			if(q)push(x,y,1,x,ls(y),0);
			if(q)push(x,y,1,x,ls(y),1);
		}
	int u=0,v=0,w=0;
	int len=n-1;
	res=inf;
	for(int p=0;p<=len;p++){
		int q=len-p;
		int i=Ls(k,p),j=Rs(k,q);
		if(f[i][j][0]<res){
			res=f[i][j][0];
			u=i,v=j,w=0;
		}
		if(f[i][j][1]<res){
			res=f[i][j][1];
			u=i,v=j,w=1;
		}
	}
	while(1){
		if(u==k&&v==k)
			break;
		st.push(id[u][v][w]);
		int x=L[u][v][w],y=R[u][v][w],z=P[u][v][w];
		u=x,v=y,w=z;
	}
	cout<<k<<' ';
	while(!st.empty()){
		cout<<st.top()<<' ';
		st.pop();
	}
	return 0;
}
```

---

## 作者：__ZTY__ (赞：2)

![](https://cdn.luogu.com.cn/upload/image_hosting/6ts9ojot.png)

## 分析
不难发现，选择不交叉比选择交叉更优。

所以以顶点为分界，左边和右边分别应该是按顺序的。

那么我们就可以设置状态 $dp(i,j,k)$ 表示最短距离。

其中，$i$ 表示顶点左边选择的第 $i$ 个点，$j$ 表示顶点右边选择的第 $j$ 个点，也可以理解为选择区间 $[i,j]$ 中的点，$k$ 表示现在位于左边还是右边。

则转移方程为：

$dp(i,j,0)=\min(dp(i+1,j,0)+dis(i+1,j),dp(i+1,j,1)+dis(i,j))$

$dp(i,j,1)=\min(dp(i,j-1,0)+dis(i,j),dp(i,j-1,1)+dis(i-1,j))$

需要注意的是，本题询问的是方案而非距离，应在转移时纪录方案。

---

## 作者：Timmy_ (赞：1)

# 前言

春测砸了…… 

T2 用 __int128 输出一个没注意一分不得。 ~~（不过好像注意了也得不了几分）~~ 

T3 T4 直接骗的分，荣获二等奖一个。（考这么烂还能二等奖就离谱）

# 切入点

赛后回顾发现唯一我真的想不到的一点就是怎么证明交叉大于不交叉的特点。


后来发现是一个很简单的证明……

因为这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/xa72zutz.png)

始终优于这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/6pc3kpap.png)

（易证）

# 思路

那么这个题的思路就很明朗了，除了区间 dp 就只能是区间 dp 了。

因为给出的点符合凸多边行的性质，并且为了保证没有交叉，我们就会推出一个特别有趣的结论

如果 $i \sim j$ 已经被连接了，下一个连接的只能是 $i-1$ 或者 $j+1$ 了

$ dp_{i,j} \rightarrow dp_{i-1,j},dp_{i,j+1}$

由这个转移方程我们还知道当前电线要么只能在 $i$ 或者 $j$，因为只能转移到这里。

但由于不知道当前电线到底在 $i$ 还是在 $j$ 所以还得再加上一维。

0 代表在 $i$，1 代表在 $j$。

$dp_{i,j,0/1} \rightarrow dp_{i-1,j,0},dp_{i,j+1,1}$

至于具体去怎么转移我就不多说了，其实就是把当前状态所在点和转移的状态的所在点求个距离，再取个最小值就行了。

**注意：这里需要采用环形数组，因为点满足凸多边形性质，所以 $$1 是可以转移到 $n$，$n$ 也是可以转移到 $1$ 的。**

# 倒推

由于问题问的是这条路线是怎么走出来的，而不是这条路线的最短距离所以我们还得通过倒推的方式找出路径。

其实过程很简单，找到最小的结果状态之后，进行倒推：考虑当前状态可能从哪个状态转移，如果发现哪个状态转移过来的值正好是当前状态的值，那么就跳到那个状态，继续进行倒推，知道倒推到一个状态，而那一个点一定是初始状态，因为所有状态都是从那个点推过来的。

# AC CODE

请鉴赏本蒟蒻丑陋的代码

```cpp
#include <iostream>
#include <cmath>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1e3+5;
const long double eps=1e-18;
int n; 
struct node
{
	long double x,y;
	int id;
}p[N],L[N],R[N];
int cntL,cntR,cnt;
long double dp[N][N][2];
int vis[N][N][2];
int ans[N];
long double dis(int a,int b)
{
	return sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));
}
void bfs()
{
	queue< pair< pair<int,int>, int> > q;
	dp[0][0][0]=dp[0][0][1]=0;
	q.push(make_pair(make_pair(0,0),0));
	q.push(make_pair(make_pair(0,0),1));
	while(!q.empty())
	{
		int a=q.front().first.first,b=q.front().first.second;
		int p=q.front().second;
		int temp;
		if(p==0)
			temp=L[a].id;
		else
			temp=R[b].id;
		q.pop();
		if(a+b==n-1) 
			continue;
		dp[a+1][b][0]=min(dp[a+1][b][0],dp[a][b][p]+dis(L[a+1].id,temp));
		if(vis[a+1][b][0]==0)
			vis[a+1][b][0]=1,q.push(make_pair(make_pair(a+1,b),0));
		dp[a][b+1][1]=min(dp[a][b+1][1],dp[a][b][p]+dis(R[b+1].id,temp));
		if(vis[a][b+1][1]==0)
			vis[a][b+1][1]=1,q.push(make_pair(make_pair(a,b+1),1));
	}
	return;
}
void goback(int a,int b,int p)
{
	if(a==0 && b==0)
		return;
	int temp;
	if(p==0)
		temp=L[a].id;
	else
		temp=R[b].id;
	ans[cnt]=temp;
	cnt--;
	if(a>0 && p==0)
	{
		if(abs(dp[a-1][b][0]+dis(L[a-1].id,temp)-dp[a][b][p])<eps)
			goback(a-1,b,0);
		else if(abs(dp[a-1][b][1]+dis(R[b].id,temp)-dp[a][b][p])<eps)
			goback(a-1,b,1);
	}
	else if(b>0 && p==1)
	{
		if(abs(dp[a][b-1][1]+dis(R[b-1].id,temp)-dp[a][b][p])<eps)
			goback(a,b-1,1);
		else if(abs(dp[a][b-1][0]+dis(L[a].id,temp)-dp[a][b][p])<eps)
			goback(a,b-1,0);
	}
	return;
}
int main()
{
	int i,j;
	scanf("%d",&n);
	for(i=1; i<=n; i++)
		scanf("%Lf%Lf",&p[i].x,&p[i].y),p[i].id=i;
	long double maxn=-1e15;
	int mk;
	for(i=1; i<=n; i++)
		if(p[i].y>maxn+eps)
			maxn=p[i].y,mk=i;
	for(i=mk-1; i>=1; i--)
		L[++cntL]=p[i];
	for(i=n; i>mk; i--)
		L[++cntL]=p[i];
	for(i=mk+1; i<=n; i++) 
		R[++cntR]=p[i];
	for(i=1; i<mk; i++)
		R[++cntR]=p[i];
	L[0]=R[0]=p[mk];
	for(i=0; i<=cntL; i++)
		for(j=0; j<=cntR; j++)
			dp[i][j][0]=dp[i][j][1]=1e15;
	bfs();
	cnt=n;
	long double minx=1e15;
	int MK0,MK1; 
	for(i=0; i<n; i++)
	{
		if(dp[i][n-i-1][0]<minx)
			minx=dp[i][n-i-1][0],MK0=i,MK1=0;
		if(dp[i][n-i-1][1]<minx)
			minx=dp[i][n-i-1][1],MK0=i,MK1=1;
	}
	goback(MK0,n-MK0-1,MK1);
	ans[1]=mk;
	for(i=1; i<=n; i++)
		printf("%d ",ans[i]);
	/*
	long double sum=0;
	for(i=1; i<n; i++)	
		sum+=dis(ans[i],ans[i+1]);
	cout<<sum<<endl;
	sum=0;
	ans[1]=0,ans[2]=6,ans[3]=5,ans[4]=7,ans[5]=8,ans[6]=9,ans[7]=1,ans[8]=2,ans[9]=3,ans[10]=4;
	for(i=1; i<n; i++)	
		sum+=dis(ans[i],ans[i+1]);
	cout<<sum;
	*/
	return 0;
}
/*
9
-9684715.193871729 -2491237.573858629
-7528435.637345666 -6581992.794171578
-4691417.760190858 -8831226.722433006
3793736.002502969 -9252434.459664606
2611562.156340404 9652965.326002229
513008.006488999 9986832.054957768
-6680826.432385527 7440869.947429749
-7459972.428380551 6659489.761156298
-9251184.581778957 3796783.631937882
*/
```
~~注释没删，代码也没压行，凑合着看吧~~



---


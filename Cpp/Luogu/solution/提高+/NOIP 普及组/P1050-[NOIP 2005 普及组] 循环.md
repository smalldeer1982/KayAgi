# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# 题解

## 作者：_Life_ (赞：156)

### 题意
给定两整数 $n,k$，求 $n$ 的正整数次幂的最后 $k$ 位的循环长度，若循环不存在输出 $-1$。

$1\le n\le 10^{100},1\le k \le 100$

### 题解
**这篇题解是对[最高赞题解](https://www.luogu.com.cn/blog/user277/solution-p1050)的补充与说明**

在看最高赞题解的时候，因为没有放上计算过程，我对着题解手玩了好久才弄明白![kk](https://xn--9zr.tk/kk)，所以就有了这篇附上计算过程的题解。

手玩数据 `198123 4`，因为要求只取后 4 位，所以将其截取成 `8123`。

我们逐位进行处理：
- 先处理最后一位的循环节：最后一位是 `3`，循环节长度为 4。所以后两位的循环节长度一定为 4 的倍数，为了加快计算，我们可以将乘数变为 `8123^4` ，取后 4 位变成 `0641`。
- 再处理后两位：后两位是 `23` ，在乘了 5 次 `0641` 后出现了循环，循环节长度为 4*5=20。同样为了加快计算，乘数变为 `8123^20=0641^5`，取后 4 位变成 `9201`。之后就按照这样的方法处理即可。
- 后三位：后三位是 `123` ，乘了 5 次 `9201` 后出现循环，循环节长度为 20*5=100 ，乘数变为 `9201^5%(10^4)=6001`
- 后四位：后四位是 `8123` ，乘了 5 次 `6001` 后出现循环，循环节长度为 100*5=500，500 就是最终的答案。

记得判断无解的情况：如果在处理某一位时，乘了乘数 10 次，还是没有出现循环，无解。

```
8123               1
8123*8123=65983129 2
3129*8123=25416867 3
6867*8123=55780641 4
0641*8123=05206843 #
8123^4=4353773312630641

8123               1
8123*0641=05206843 2
6843*0641=04386363 3
6363*0641=04078683 4
8683*0641=05565803 5
5803*0641=03719723 #
0641^5=108215668739201

8123               1
8123*9201=74739723 2
9723*9201=89461323 3
1323*9201=12172923 4
2923*9201=26894523 5
4523*9201=41616123 #
9201^5=65943979755726446001

8123               1
8123*6001=48746123 2
6123*6001=36744123 3
4123*6001=24742123 4
2123*6001=12740123 5
0123*6001=00738123 #

ans=4*5*5*5=500
```
### 代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int k;
char str[205];
struct bignum
{
	int x[205];
	bignum(){memset(x,0,sizeof(x));}
}n,tmp,mul,ans;
bignum operator *(bignum a,bignum b)//特化过的高精乘 只取后k位
{
	bignum ans;
	for(int i=0;i<k;i++)
		for(int j=0;j<k;j++)
			ans.x[i+j]+=a.x[i]*b.x[j];
	for(int i=0;i<k;i++)ans.x[i+1]+=ans.x[i]/10,ans.x[i]%=10;
	for(int i=k;i<205;i++)ans.x[i]=0;
	return ans;
}
bignum operator *(bignum a,int b)//这个高精乘低精是ans专用的233
{
	for(int i=0;i<=200;i++)a.x[i]*=b;
	for(int i=0;i<=200;i++)a.x[i+1]+=a.x[i]/10,a.x[i]%=10;
	return a;
}
int main()
{
	scanf("%s %d",str,&k);
	ans.x[0]=1;
	int len=strlen(str);
	for(int i=0;i<k;i++)
		n.x[i]=str[len-i-1]-'0';
	mul=n;
	for(int i=0;i<k;i++)
	{
		bignum tmp=n;
		int j=1,flag=1;
		for(j=1;j<=10;j++)
		{
			tmp=tmp*mul;
			if(tmp.x[i]==n.x[i])
			{
				ans=ans*j;
				flag=0;
				break;
			}
		}
		if(flag)
			return puts("-1"),0;
		tmp=mul;
		for(int k=1;k<j;k++)
			mul=mul*tmp;
	}
	len=200;
	while(ans.x[len]==0&&len>=1)len--;
	for(;len>=0;len--)putchar(ans.x[len]+'0');
}
```

---

## 作者：MyukiyoMekya (赞：75)

翻遍了这里洛谷的所有题解都没找到用欧拉定理做的

欧拉定理：
$$
a^{\varphi(n)} \equiv 1 (\bmod n),\gcd(a,n)=1
$$
欧拉定理有一种推广：
$$
A^B\bmod C=A^{B\%\varphi(C)+\varphi(C)} \bmod C , B\ge \varphi(C)
$$
也就是说，本题中循环长度**可以**为 $\varphi(10^k)$

很可惜，这个循环长度并不是题目所要求的最小

但是，显然最小的循环长度一定是任意一种合法的循环长度的因子

比如 $2^i (\bmod 7)$ 为 

```
2 4 1 2 4 1 2 4 1 ...
```

我用欧拉定理求出来循环节为 $\varphi(7)=6$，而最小循环节为 $3$ ，$3$ 是 $6$ 的因子

那么我们通过打表可以发现
$$
\varphi(10^k)=4\times 10^{k-1}=2^{k+1}\times 5^{k-1}
$$
那么我们就可以通过枚举质因子 2 和 5 的个数来枚举所有 $\varphi(10^k)$ 的因子，然后对每一个因子 $n^{2^i\times 5^j}$ 进行快速幂检测是否合法，若合法就更新一下答案

这时候计算一下复杂度，枚举因子 $k^2$，快速幂最多做 $\log_2(10^{100})=332$ 次乘法，设 $N$ 为 $n$ 的位数，每次乘法最多是 $N^2$ 的复杂度

总时间复杂度为 $O(k^2\times N^2 \times 332)$，好像不太行的亚子呢

我们发现瓶颈出在快速幂上面，我们要搞出一种快速求 $n^{2^i\times 5^j}$ 的算法

设 $dp_{i,j}=n^{2^i\times 5^j}$ 

边界条件：$dp_{0,0}=n$

那么我们先把 $j=0$ 的一遍递推求出

$dp_{i,0}=dp_{i-1,0}^2$

因为显然，$n^{2^i}=n^{2^{i-1}+2^{i-1}}=n^{2^{i-1}}\times n^{2^{i-1}}$

然后，$dp_{i,j}=dp_{i,j-1}^5$

因为，$n^{2^i\times 5^j}=n^{5\times (2^i\times 5^{j-1})}=(n^{2^i\times 5^{j-1}})^5$

我们就可以得到一个非常优秀的 $O(k^2\times N^2 \times 5)$

~~看上去还是得 TLE~~

高精压8位把 $N$ 变成 $\frac n 8$

这样总时间复杂度为 $O(k^2\times N^2\times 5+k^2\times N^2\times 3)$

忽略常数那就是 $O(k^2\times N^2)$

~~常数实在太大以至于要开Ofast才能过但还是450ms真菜~~

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
#define reg register
#define int long long
using namespace std;
const int MaxN=150;
const int base=100000000;
const int pow10[]={1,10,100,1000,10000,100000,1000000,10000000,100000000};
int s[MaxN],k;
struct Bigint
{
	int a[MaxN],n;
	inline void clear()
	{
		memset(a,0,sizeof a);
		n=1;
		return;
	}
	inline void work()
	{
		while(n>1&&!a[n])
			--n;
		return;
	}
	inline Bigint read()
	{
		memset(s,0,sizeof s);
		clear();
		reg int cnt=0;
		reg char c=getchar();
		while(!isdigit(c))
			c=getchar();
		while(isdigit(c))
			s[++cnt]=c^'0',c=getchar();
		for(int i=1;i<=(cnt>>1);++i)
			swap(s[i],s[cnt-i+1]);
		n=0;
		for(int i=1;i<=cnt;i+=8)
		{
			++n;
			a[n]+=s[i+7]*10000000;
			a[n]+=s[i+6]*1000000;
			a[n]+=s[i+5]*100000;
			a[n]+=s[i+4]*10000;
			a[n]+=s[i+3]*1000;
			a[n]+=s[i+2]*100;
			a[n]+=s[i+1]*10;
			a[n]+=s[i+0]*1;
		}
		work();
		return *this;
	}
	inline void write() const
	{
		printf("%lld",a[n]);
		for(int i=n-1;i;--i)
			printf("%08lld",a[i]);
		puts("");
		return;
	}
	inline Bigint operator * (const Bigint &nt) const
	{
		Bigint res;res.clear();
		res.n=min(105ll,n+nt.n);
		for(int i=1;i<=n;++i)
			for(int j=1;j<=nt.n;++j)
				if(i+j-1<=k)
					res.a[i+j-1]+=a[i]*nt.a[j];
		for(int i=1;i<=res.n;++i)
			res.a[i+1]+=res.a[i]/base,res.a[i]%=base;
		res.work();
		return res;
	}
	inline bool operator < (const Bigint &nt) const
	{
		if(n!=nt.n)
			return n<nt.n;
		for(int i=n;i;--i)
			if(a[i]!=nt.a[i])
				return a[i]<nt.a[i];
		return false;
	}
};
template <class t> inline void read(t &s)
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
inline bool issame(const Bigint &a,const Bigint &b)
{
	int T=k/8;
	for(int i=1;i<=T;++i)
		if(a.a[i]!=b.a[i])
			return false;
	reg int lim=pow10[k-T*8];
	return a.a[T+1]%lim==b.a[T+1]%lim;
}
inline Bigint fastpow(Bigint a,int b)
{
	reg Bigint res;res.clear();
	res.a[1]=1;
	for(;b;b>>=1,a=a*a)
		if(b&1)
			res=res*a;
	return res;
}
Bigint A,B,t,two,five;
Bigint ans;
Bigint fivepow[150],twopow[150];
Bigint dp[150][150];
signed main(void)
{
	A.read();
	read(k);
	if(A.a[1]==1&&A.n==1)
	{
		puts("0");
		return 0;
	}
	if(A.a[1]==0&&A.n==1)
	{
		puts("0");
		return 0;
	}
	if(issame(A*A,A))
	{
		puts("1");
		return 0;
	}
	two.clear();
	five.clear();
	ans.clear();
	ans.a[1]=-1;
	two.a[1]=2;
	five.a[1]=5;
	{
		for(int i=0;i<k;++i)
			fivepow[i].clear();
		fivepow[0].a[1]=1;
		for(int i=1;i<k;++i)
			fivepow[i]=fivepow[i-1]*five;
	}
	{
		for(int i=0;i<=k+1;++i)
			twopow[i].clear();
		twopow[0].a[1]=1;
		for(int i=1;i<=k+1;++i)
			twopow[i]=twopow[i-1]*two;
	}
	{
		for(int i=0;i<=k+1;++i)
			for(int j=0;j<k;++j)
				dp[i][j].clear();
		dp[0][0]=A;
		for(int i=1;i<=k+1;++i)
			dp[i][0]=dp[i-1][0]*dp[i-1][0];
		for(int i=0;i<=k+1;++i)
			for(int j=1;j<k;++j)
				dp[i][j]=dp[i][j-1]*dp[i][j-1]*dp[i][j-1]*dp[i][j-1]*dp[i][j-1];
//				dp[i][j]=fastpow(dp[i][j-1],5);
	}
	for(int i=0;i<=k+1;++i)
	{
		for(int j=0;j<k;++j)
		{
			if(!i&&!j)
				continue;
			B=twopow[i]*fivepow[j];
			t=dp[i][j]*A;
			if(issame(t,A))
			{
				if(ans.a[1]==-1||B<ans)
					ans=B;
			}
		}
	}
	ans.write();
	return 0;
}
// phi(10^k) = 4*10^(k-1)
```



---

## 作者：Shadow_Soldier (赞：18)

# 提前说的话
本文中：  
所有 $\mid$ 符号（$a \mid b$）表示 $a$ 整除 $b$（即：存在一个 $c \in \Z$，使 $b = ac$）；  
所有提到“位”（进制位）的地方都指十进制下的进制位。而位的编号从右往左依次 $1$、$2$、$3$、……，后 $x$ 位表示编号为 $1$ ~ $x$ 的进制位，第 $x$ 位表示编号为 $x$ 的进制位；
# 题意简化
问：$n$ 的正整数次幂（在十进制下）的最后 $k$ 位的循环长度。如果循环不存在，输出 $-1$。  
形式化的讲：给定 $n,k \in \N^*$，求最小的 $L \in \N^*$，使对于任意的 $a \in \N^*$，都有 $n^a \equiv n^{a+L} \pmod {10^k}$。若不存在，则输出 $-1$。如果想看题目的话，就点击右边：[P1050 [NOIP2005 普及组] 循环](https://www.luogu.com.cn/problem/P1050)。
# 暴力（30pts）
根据同余（取模）的性质，有：  
$$
\tag{*} ((x \bmod p) \cdot (y \bmod p)) \equiv (x \cdot y) \pmod {p}
$$
将 $x = n^m(m \in \N)$，$y = n$，$p = 10^k$ 代入$(*)$ 式，得：$((n^m \bmod 10^k) \cdot (n \bmod 10^k)) \equiv n^m \cdot n \pmod {10^k}$。所以，已知 $n^m \bmod 10^k$，乘上 $n$（这里也可以提前将 $n$ 对 $10^k$ 取模，可以利用 $(*)$ 式在刚开始就一边一位一位地输入一边对 $10^k$ 取模）后再对 $10^k$ 取模，即可得到 $n^{m+1} \bmod 10^k$。  
所以，让 $i$ 从 $1$ 到一个很大的数循环，当第一次出现满足 $n^{i + 1} \equiv n \pmod {10^k}$ 的 $i$ 时，答案 $L$ 就是 $i$，可以直接输出并结束运行。问题就是：如何判断无解呢？因为总共有 $10^k$ 种模 $10^k$ 的结果，所以考虑最极端的情况，前 $10^k - 1$ 个 $i$（即：$i \le 10^k - 1$）时，都有 $n^{i+1} \text{ } {\equiv}\mathllap{/\,} \text{ } n \pmod {10^k}$。则若存在循环，必有 $n^{10^k + 1} \equiv n \pmod {10^k}$，即：在上面最极端的情况成立的情况下需要存在循环，在 $i = 10^k$ 时，必有 $n^{i+1} \equiv n \pmod {10^k}$。即：最多只需要循环 $10^k$ 次，仍然没有结束运行的话，就是无解，输出 $-1$。  
这里给出一个代码片段：  
```cpp
while(k--) m *= 10;
n %= m;
s = n;
for(int i = 1; i <= m; i ++) {
    s = s * n % m;
    if(s == n) {
        cout << i;
        return 0;
    }
}
cout << -1;
return 0;
``````
当然，这样只有 30pts。
# 正解（递推法）
令 $l_i(i \in \N)$ 表示后 $i$ 位的 __最小__ 循环长度（设 $l_0 = 1$，若后 $i$ 位不存在循环，则令 $l_i = 0$（方便日后计算、描述））。  
问：若现已知 $l_{i-1}(i \in \N^*)$，是否能够求出 $l_i$？

引理 1：若 $l_i \ne 0(i \in \N^*)$，则必有 $l_{i - 1} \mid l_i$。  
证明：  
因为 $l_i \ne 0$，所以存在后 $i$ 位长度为 $l_i$ 的长度最小循环。因此，后 $i - 1$ 位也存在一个长度为 $l_i$ 的循环（__不一定是最小__），即：后 $i - 1$ 位存在循环，即：$l_{i - 1} \ne 0$。  
又因为后 $i - 1$ 存在长度为 $l_{i - 1}$ 的长度最小循环，而后 $i - 1$ 位的所有循环长度必定是 $l_{i - 1}$ 的正整数倍，且后 $i - 1$ 位存在一个长度为 $l_i$ 的循环。所以 $l_{i - 1} \mid l_i$。

既然有了引理 1，我们就会想：当 $i \in \N^*$，$l_i \ne 0$ 时，$l_i$ 是 $l_{i - 1}$ 的多少倍呢？  
令 $f(i)(i \in \N^*)$，满足 $l_{i - 1} \cdot f(i) = l_i$（由引理 1，当 $l_i \ne 0$ 时，$f(i) = \frac{l_i}{l_{i - 1}}$；而当 $l_i = 0$ 时，$f(i) = 0$（这一点更重要）。而 $f(i)$ 是一定唯一的），则有 $\forall i \in \N^*$，$f(i) \in \N^*$。所以，只要能够求出 $f(i)$，就能够求出 $l_i$ 了。  
那么，如何求出 $f(i)$ 呢？当然 $f(i)$ 可能为 $0$，此时代表无解。能否暴力枚举呢？那我们需要一个界限，我们来计算一下 $f(i)$ 的最大值是多少。  
注意到，在考虑后 $i$ 位时，长为 $l_i$ 的循环节中的后 $l_{i-1}$ 位将长为 $l_{i-1}$ 的循环节重复 $f(i)$。所以，要确定 $f(i)$ 的上界，第 $i$ 位肯定是关键。即：当出现第一个（最小的）$j(j \in \N^*)$，使 $n^{j \cdot l_{i - 1} + 1}$ 的第 $i$ 位与 $n$ 的第 $i$ 位相等时，$f(i) = j$。要求 $f(i)$ 的上限，即求 $l_i > 0$ 时，$j$ 的最大值。  
同【暴力】，因为一位上一共只有 $0$ ~ $9$ 十种可能，所以考虑最极端的情况。前 $9$ 个 $j$（$j \le 9$）时，都有：$n^{j \cdot l_{i - 1} + 1}$ 的第 $i$ 位与 $n$ 的第 $i$ 位不相等。则若 $l_i \ne 0$，当 $j = 10$ 时，必有：$n^{j \cdot l_{i - 1} + 1}$ 的第 $i$ 位与 $n$ 的第 $i$ 位相等。即：$l_i > 0$ 时，$j$ 的最大值为 $10$。即：$f(i)$ 的最大值为 $10$。  
所以，枚举 $f(i)$，从 $1$ 到 $10$，判断是否满足 $n^{j \cdot l_{i - 1} + 1}$ 的第 $i$ 位与 $n$ 的第 $i$ 位相等。若相等，则退出循环；若直至循环结束都没有一个在枚举范围内的满足条件的 $f(i)$，则 $f(i) = 0$。  
而 $l_i = (\prod_{j=1}^{i} f(j)) \cdot l_0 = \prod_{j=1}^{i} f(j)$，所以此时将 $i = k$ 代入这个式子，就可以求出所求的 $l_k$ 了。  
当 $l_k = 0$ 时，就输出 $-1$，否则输出 $l_k$。  
当然，$l_k = 0$ 当且仅当存在一个 $i \in \N^*$，且 $1 \le i \le k$，满足 $f(i) = 0$ 时才成立。所以，如果在计算时已经遇到了 $f(i) = 0$ 的情况，可以直接输出 $-1$ 并结束运行，如果计算完后，程序仍没有结束运行，则输出 $\prod_{i=1}^{k} f(i)$（可以在循环中进行求和）。  
不过，上面的思路还是比较“粗”，就是没有明确如何去细化、实现，只能说是一个大纲吧，有很多地方都还没有细化。所以，接下来就细化上面的思路。关于中间求 $n^{j \cdot l_{i - 1} + 1}(j \in \N^*,j \le 10)$ 的第 $k$ 位的部分，肯定是不能直接求的。然而，我们注意到，这里的 $j$ 是从 $1$ 到 $10$ 进行枚举的，即：$j$ 是递增的。所以，就可以根据前一个 $j$ 时的情况来推出现在的 $j$ 时的情况。根据同余（取模）的性质，$n^{j \cdot l_{i - 1} + 1} \equiv (n^{(j - 1) \cdot l_{i - 1} + 1} \bmod 10^i) \cdot (n^{l_{i-1}} \bmod 10^i) \pmod {10^i}$。所以，可以每次求出 $n^{l_{i-1}} \bmod 10^i$，并在枚举 $j$ 时计算即可。然而，这样做并不是最优的，可以进一步优化。注意到，在递推求解的时候，外层的 $i$ 是从 $1$ 到 $k$ 进行递推的，也就是说，$i$ 跟 $j$ 一样，都是递增的。所以，可以用类似于 $j$ 的方法，保留上次的 $f$ 函数结果，因为 $n^{j \cdot l_{i - 1} + 1} = n^{j \cdot l_{i - 2} \cdot f(i - 1) + 1} = n \cdot ((n^{l_{i - 2}})^{f(i - 1)})^j$（可以令 $f(0) = l_{-1} = 1$）。所以，可以在开始内层循环之前就预处理出 $(n^{l_{i - 2}})^{f(i - 1)}$，在内层循环（枚举 $j$）里就不断地去乘它就可以了。但是，注意到前文说要对 $10^i$ 取模，那么模数就不能通用了。所以，我们对 $10^k$ 取模（因为 $i \le k$）即可。  
但是，这道题的数据范围很惊人，达到了 $n \le 10^{100}$，这就意味着，我们必须要用高精度了。那么，在运行过程中，要用到哪些运算呢？可以发现，只有两种：高精乘高精和高精乘低精（都要取模）。那么，在写高精度的时候，就需要写这两种运算了。  
好了，来估计一下时间复杂度。外层 $i$ 从 $1$ 到 $k$，内层先是 $f(i - 1)$ 次高精乘高精，再是最大 $10$ 次的高精乘高精以及判断，又是一个特判，最后是一次高精乘低精。而一次高精乘高精的时间复杂度是 $\Omicron(k^2)$，一次高精乘低精的时间复杂度是 $\Omicron(k)$，$f(i - 1) \le 10$，所以整体的时间复杂度大约就是 $\Omicron(10 k^3)$，能过了。  
# 代码实现
上面就是思路了，下面上代码。  
```cpp
#include <bits/stdc++.h>
using namespace std;
int k, f[110];
struct Number {
    int l, a[210];
    void Clear() {
        l = 0;
        memset(a, 0, sizeof(a));
    }
    void Resize() {
        if(l > k) l = k;
    }
    void In() {
        string str;
        cin >> str;
        Clear();
        for(int i = str.size() - 1; i >= 0; i --) {
            a[++l] = (str[i] - '0');
        }
    }
    void Out() {
        for(int i = l; i >= 1; i --) {
            cout << a[i];
        }
    }
    void InInt(int x) {
        Clear();
        while(x) {
            a[++l] = x % 10;
            x /= 10;
        }
        Resize();
    }
}n, u, v, w, ans;
Number operator * (Number p, Number q) {
    Number rhs;
    rhs.Clear();
    for(int i = 1; i <= p.l; i ++) {
        for(int j = 1; j <= q.l; j ++) {
            rhs.a[i + j - 1] += (p.a[i] * q.a[j]);
            rhs.a[i + j] += (rhs.a[i + j - 1] / 10);
            rhs.a[i + j - 1] %= 10;
        }
    }
    if(rhs.a[p.l + q.l]) rhs.l = p.l + q.l;
    else rhs.l = p.l + q.l - 1;
    rhs.Resize();
    return rhs;
}
int main() {
    n.In();
    cin >> k;
    n.Resize();
    f[0] = 1;
    v = n;
    ans.InInt(1);
    for(int i = 1; i <= k; i ++) {
        u.InInt(1);
        for(int j = 1; j <= f[i - 1]; j ++) {
            u = u * v;
        }
        v = u;
        w = n;
        for(int j = 1; j <= 10; j ++) {
            w = w * u;
            if(w.a[i] == n.a[i]) {
                f[i] = j;
                break;
            }
        }
        if(!f[i]) {
            cout << -1;
            return 0;
        }
        w.InInt(f[i]);
        ans = ans * w;
    }
    ans.Out();
    return 0;
}
``````
代码仅供参考，不喜勿喷。  
# 数据通过情况
[数据通过情况](https://www.luogu.com.cn/record/199523206)
# 最后的话
这道题主要考到了：递推和高精度。关于代码，还是自己写，不要抄！最后的最后，写篇文章不容易，可否来个赞？

---

## 作者：ljh0727 (赞：12)

# P1050循环

题目传送门：[题目](https://www.luogu.com.cn/problem/P1050)

### 模拟法

直接反复乘 $n$，对后 $k$ 位进行比较，一旦与初始相等，输出循环长度，否则超过一定次数还找不到，输出 $-1$。

模拟法最大的问题就是超时，那怎么样才能不超时，可以用递推来解决。

### 递推

模拟法主要原因就是要枚举 $n$ 的每一次幂才行，有没有更简洁的方式呢。

可以假设后 $k - 1$ 位的循环长度已经计算出来，设为 $t$，即 $n * n^t % 10^(k - 1)$ 和 $n % (k - 1)$ 相同。

对于后 $k$ 位如果要相同，必须有后 $k - 1$ 位相同，因此后 $k$ 位的循环长度一定是 $t$ 的倍数。

所以，$n * n^t$，$n * n^{2t}$，$n * n^{3t}$ 等等某一个的后 $k$ 位与 $n$ 的后 $k$ 位相同，又因为后 $k - 1$ 已经相同，所以只需要判断第 $k$ 位是否相同。

而第 $k$ 位要相同，最多只需要 $10$ 次枚举，因为整数只有 $0$ 到 $9$，如果超过 $10$ 次还没有相同，则不存在循环。

综上所述，可以从最后 $1$ 位，$2$ 位，$3$ 位的循环长度一直推出 $k$ 位的循环长度。

### 代码

模拟法。


```cpp
#include<iostream>
#include<cstdio>
#include<vector>



using namespace std;

vector<int> n;
int k;

vector<int> mul(vector<int> a,vector<int> b){
    vector<int> res(a.size()+b.size());
    for(int i=0;i<k;i++){
        for(int j=0;j<k;j++){
            if(i+j<k){
                res[i+j]+=a[i]*b[j];
                res[i+j+1]+=res[i+j]/10;
                res[i+j]%=10;
            }
        }
    }
    return res;
}

int main(){
    string str;
    cin>>str>>k;
    for(int i=0;i<str.size();i++)
        n.push_back(str[str.size()-1-i]-'0');

    int cnt=0;
    int x=1;
    for(int i=1;i<=k;i++)
		x*=10;
    vector<int> st(n),ed(n);
    int times=10000;
    while(times--){
        cnt++;
        ed=mul(ed,n);
        bool yes=true;
        for(int i=0;i<k;i++){
            if(ed[i]!=st[i]){
                yes=false;
                break;
            }
        }
        if(yes){
            printf("%d",cnt); 
            return 0;
        } 
    }
    printf("-1");
    return 0;
}
```


递推法。


```cpp
#include<iostream>
#include<cstdio>
#include<vector>


using namespace std;

const int N=105;

vector<int> n;
int t[N];
int k;

vector<int> f1(vector<int> a,vector<int> b){
    a.resize(k);
    b.resize(k);
    vector<int> r(a.size()+b.size());
    for(int i=0;i<k;i++){
        for(int j=0;j<k;j++){
            if(i+j<k){
                r[i+j]+=a[i]*b[j];
                r[i+j+1]+=r[i+j]/10;
                r[i+j]%=10;
            }   
        }
    }
    r.resize(k);
    return r;
}

vector<int> f2(vector<int> a,int b){
    vector<int> r;
    int t=0;
    for(int i=0;i<a.size()||t;i++){
        if(i<a.size())
			t+=a[i]*b;
        r.push_back(t%10);
        t/=10;
    }
    return r;
}


int main(){
    string str;
    cin>>str>>k;
    for(int i=0;i<str.size();i++)
        n.push_back(str[str.size()-1-i]-'0');

    t[0]=1;
    vector<int> p(n);
    
    for(int i=1;i<=k;i++){
        vector<int> q(1,1);
        for(int j=1;j<=t[i-1];j++) 
			q=f1(q,p);
        p=q;
       
        vector<int> r(n);
        for(int j=1;j<=10;j++){
            r=f1(r,q);
            if(r[i-1]==n[i-1]){
                t[i]=j;
                break;
            }
        }
        if(t[i]==0){
            printf("-1"); 
            return 0;
        }
    }
    
    vector<int> ans(1,1);
    for(int i=1;i<=k;i++)
		ans=f2(ans,t[i]);
    for(int i=ans.size()-1;i>=0;i--)
    	printf("%d",ans[i]);
    
    return 0;
}

```

---

## 作者：vectorwyx (赞：9)

这题还是相当有思维含量的，它的核心思想其实就涉及到一点：

> 已知后 $w$ 位的循环节长度，如何快速地求出后 $w+1$ 位的循环节长度？

形式化讲，给定正整数 $n,w$，已知 $x$ 是最小的满足  $n^{x}\equiv n (mod\ 10^{w})$ 且 $x\ge 2$ 的正整数（这里假设 $x$ 一定存在）。我们需要求出方程 $n^{y}\equiv n(mod\ 10^{w+1}),y\ge2$ 的最小正整数解。

首先我们可以发现，既然$n^{y}\equiv n(mod\ 10^{w+1})$，那么一定有 $n^{y}\equiv n(mod\ 10^{w})$，又由于 $x$ 是最小的满足 $n^{x}\equiv n (mod\ 10^{w})$ 的正整数，所以 $y\ge x$。同时，又由于对于任意正整数 $a\ge x$，$n^{a}=n^{a-x}\cdot n^{x}\equiv n^{a-x+1}(mod\ 10^{w})$，所以 $n^{y}\equiv n^{y-x+1}\equiv n^{y-2(x-1)}\equiv n^{y-3(x-1)}……$，这相当于每次从 $y$ 中“消去”一个 $x-1$，那这个式子的尽头在哪里呢？不难看出， $y$ 最终会小于等于 $x$，而由于 $x$ 已经是最小的解，所以 $y$ 最终一定等于 $x$。也就是说 $y$ 一定能表示成 $x+k(x-1)$ 的形式，所以 $(x-1)|(y-1)$（感谢 rqy 神仙的指点）。$x-1$ 和 $y-1$ 其实就是后 $w$ 位和后 $w+1$ 位的循环节长度，所以后 $w+1$ 位的循环节长度一定是后 $w$ 位的循环节长度的倍数。

还有一种角度可以证明，我们把 $n^{1},n^{2},……n^{k}$在模  $10^{w+1}$ 和模 $10^{w}$ 意义下的值看做点，相邻的元素连边，这显然会形成环（因为那两个方程一定有解）。考虑将第一个环上的点映射到第二个环的点上，即把 $n^{k}\ mod \ 10^{w+1}$ 映射到 $n^{k}\ mod\ 10^{w}$ 上。那我们在第一个环上走一圈回到起点，在它的像上也就是第二个环上也会回到起点，这意味着我们在第二个环上也走了整数圈，那么第一个环的长度一定是第二个环的长度的整数倍，所以后 $w+1$ 位的循环节长度一定是后 $w$ 位的循环节长度的倍数（感谢UOJ群里另一位神仙的指点）。

------------
得出的这个结论有什么用呢？想一想，如果$y-1=k(x-1)$，$k$ 的范围应该是多少呢？显然 $1\le k\le10$。因为  $n^{k(x-1)}$ 的后 $w$ 位已经确定，而它的从后往前数第 $w+1$ 位只可能有 $10$ 种取值，所以 $k$ 取 $1$ ~ $10$ 就一定会出现循环。这同时也能帮助我们确定是否有解，如果 $k$ 从 $1$ 取到 $10$ 都没有与 $n$ 同余的值，说明产生的循环不包含 $n$ 这个值，因此必定无解。这样，对于后 $w+1$位，我们可以用最多 $10$ 次高精乘法递推出它的循环节长度，总时间复杂度为 $O(10kp)$，$p$ 为进行一次高精乘法的常数，可以通过本题。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;

int k;
struct num{
	int len,a[105];
	num(){len=0;memset(a,0,sizeof a);} 
	num(string s){
		len=s.size();
		go(i,len,1) a[i]=s[len-i]-'0';
	}
	num operator*(const num &x) const{
		num ret;
		fo(i,1,len)
			fo(j,1,min(x.len,k-i+1)) ret.a[i+j-1]+=a[i]*x.a[j];
		ret.len=min(k,len+x.len-1);
		fo(i,1,ret.len) ret.a[i+1]+=ret.a[i]/10,ret.a[i]%=10;
		if(ret.a[ret.len+1]) ret.len=min(ret.len+1,k);
		return ret;
	}
	void outit(){
		go(i,len,1) printf("%d",a[i]);puts("");
	}
}n,last,ans,t,tt,_last;

int main(){
	string s;
	cin>>s;
	n=num(s);
	cin>>k;
	t=last=n;
	ans.len=ans.a[1]=1;
	fo(i,1,k){
		_last.len=_last.a[1]=1;
		bool flag=0;
		fo(j,1,10){
			//printf("%d:\n",j);
			n=n*last;
			_last=_last*last;
			//n.outit(),_last.outit(),last.outit();
			fo(k,1,i) if(n.a[k]!=t.a[k]) goto H;
			s="";
			if(j<10) s+='0'+j;
			else s="10";
			tt=num(s);
			ans=ans*tt;
			flag=1;
			break;
			H:;
		}
		if(!flag){
			cout<<-1;
			return 0;
		}
		n=t;
		last=_last;
	}
	go(i,ans.len,1) printf("%d",ans.a[i]);
	return 0;
}
/*
-------------------------------------------------
*/
```



---

## 作者：cwxcplh (赞：5)

这是道很有思维挑战性的一道题。

题目简化：给定一个数，求这个数的后 $k$ 位是否有循环节，没有输出 $-1$，有输出循环长度。

我首先想到的是暴力跑一遍，直到跑到循环节为止，但这种方法有个很明显的漏洞：你不知道这个数的后 $k$ 位有没有循环，万一提前终止了呢？而且这种方法的时间复杂度不明，应该很大。

然后我看到要求方案数，我立即想到的是排列组合，具体怎么实现？

我们先把每一位分开看，那么总的循环数应该就是每一位的循环数之积，也就是这个公式：

$$ans=\prod^{k}_{i=1}num[i]$$

但是现在每一位之间都是有联系的，一乘起来就会涉及到进位等一系列复杂的操作，因此这个数的各个数位我们要连在一起看。

这里就会有一种很巧妙的方法：我的本质是要算每一位的循环数之积，这个本质是不会变的，只是关于每一位是会有进位的，那我们就从最简单的（即不进位的那一位，也就是最后一位）开始分析。

因为不太好讲，我们举个例子：`147513` 和 `4` 吧。

首先看最后一位 `3`。它没有进位，所以它的循环数有多少个就有多少个，即当前的答案为 $4$。

其次由于进位原因，我们需要将后两位一起看，即 `13`。这里我们要探究关于第二位的循环，因此最后一位不能动，我们知道了最后一位的循环数为 $4$，所以我们只需要让最后一位跑一遍循环再取最后两位（因为只与最后两位有关）就行了，即 $3^4\bmod 100=81$。此时这个数再乘上 $81$ 的话最后一位就相当于乘了一个循环，所以并没有变，而第二位就会一直接收后一位的进位。最后可以算出一共有 $5$ 次，所以此时的答案就等于 $4\times 5=20$。

接着按照上面的步骤继续循环下去，最后的答案就是正确答案。

最后还有个问题：怎么判断有没有循环节呢？很简单，只需要看看某一位的循环长度是否超过了 $10$，如果是，那就肯定没有。因为以为数最多只有 $10$ 个，一旦超过了 $10$ 个，就说明所有的数跑完了都找不到循环，自然就没有循环了。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201312136)

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct bign{
	int len,x[206];
	bign();
	void anscs();
};
bign::bign()//装逼写法
{
	memset(x,0,sizeof(x));
	len=0;
}
void bign::anscs()
{
	x[1]=1;
	len=1;
}
bign fixx(bign a,int y)//进行进位、取后几位的操作
{
	for(int i=1;i<=a.len;i++)
	{
		a.x[i+1]+=a.x[i]/10;
		a.x[i]%=10;
	}
	while(a.x[a.len]==0&&a.len>1)
	{
		a.len--;
	}
	bign b;
	b.len=y;
	for(int i=1;i<=y;i++)
	{
		b.x[i]=a.x[i];
	}
	return b;
}
bign operator * (bign a,bign b)//运算符重载一：两个高精度数相乘
{
	bign c;
	c.len=a.len+b.len;
	for(int i=1;i<=a.len;i++)
	{
		for(int j=1;j<=a.len;j++)
		{
			c.x[i+j-1]+=a.x[i]*b.x[j];
		}
	}
	return fixx(c,a.len);
}
bign fix(bign a)//进行进位操作
{
	for(int i=1;i<a.len;i++)
	{
		a.x[i+1]+=a.x[i]/10;
		a.x[i]%=10;
	}
	while(a.x[a.len]>=10)
	{
		a.x[a.len+1]+=a.x[a.len]/10;
		a.x[a.len]%=10;
		a.len++;
	}
	while(a.x[a.len]==0&&a.len>1)
	{
		a.len--;
	}
	return a;
}
bign operator * (bign a,int b)//运算符重载二：高精度数乘以低精度数
{
	for(int i=1;i<=a.len;i++)
	{
		a.x[i]*=b;
	}
	return fix(a);
}
bign a,b,c,ans;
bool check(int y)//判断是否有循环了
{
	for(int i=1;i<=y;i++)
	{
		if(c.x[i]!=a.x[i])
		{
			return false;
		}
	}
	return true;
}
int k,m;
string s,ss;
signed main()
{
	ans.anscs();
	cin>>s>>k;
	int n=s.size();
	for(int i=0;i<k;i++)
	{
		s[i]=s[i+n-k];
	}
	for(int i=k-1;i>=0;i--)
	{
		b.x[++b.len]=s[i]-'0';
	}
	n=k;
	for(int i=1;i<=k;i++)
	{
		c.x[++c.len]=s[k-i]-'0';
		a=c;
		bool flag=false;
		int sum=0;
		for(int j=1;j<=10;j++)
		{
			a=a*b;
			sum++;
			if(check(a.len))
			{
				flag=true;
				break;
			}
		}
		if(!flag)
		{
			cout<<"-1";
			return 0;
		}
		ans=ans*sum;
		if(i==k)
		{
			break;
		}
		bign d;
		d=b;
		for(int j=1;j<sum;j++)
		{
			b=b*d;
		}
	}
	for(int i=ans.len;i>=1;i--)//记住：答案要用高精度保存
	{
		cout<<ans.x[i];
	}
	return 0;
}
```

---

## 作者：LeavingAC (赞：3)

**begin**

[P1050 [NOIP 2005 普及组] 循环](https://www.luogu.com.cn/problem/P1050)

# 前言

注意数据范围：$1\le n \le 10^{100} $，$1\le k \le 100$。

所以这题要写高精……吗？

那么既然我都这么问了，那么答案肯定是否定的，所以本片题解是一篇 Python 题解，但是思路应该是差不多的。

# 题目大意

给定 $n $，$k$，求 $n$ 的正整数次幂后 $k$ 位的循环节长度。若无解输出 $-1$。

# 思路

有一种思路大家肯定都能想到，就是一直翻倍直到找到循环节，如果超出了一定限度就判定为无解。

咱们姑且不说最大限度定为多少，就这个思路写出来包 T 飞的。

我们考虑一下如何进行优化。

我们思考一下如何在确定后 $k$ 位循环节的情况下快速找出后 $k+1$ 位的循环节。

我们发现，后 $k+1$ 的循环节的位数必定是后 $k$ 位的循环节的位数的倍数，因为题目中提到了这样一句话：

>如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。

我们既然想要后 $k+1$ 位都相同，那么前提是后 $k$ 位必须相同，那也就是必须保证未知循环节的位数是原循环节位数的倍数，因为只有后 $k$ 位一样，后 $k+1$ 位才有可能一样。

# 实践操作

我知道光看着文字叙述可能还是一头雾水地感觉很绕（~~事实上我写这篇题解的时候也是这么觉得的~~）。

不过没关系，我们来手搓一组数据就明白了。

（如果听懂了的话就可以略过这部分去看代码了。）

数据：

```
input:
123456(n) 4(k)

output:
125(ans)

explain:
123456%10^4=3456
(10^4->mod)

Part 1(6):
3456                       1
3456*3456=11943936->393{6} #
3456^1=3436->3456

Part 2(56):
3456                       1
3456*3456=11943936->3936   2
3936*3456=13602816->2816   3
2816*3456=9732096->2096    4
2096*3456=7243776->3776    5
3776*3456=13049856->98{56} #
3456^5=493024690386763776->3776 (a)

Part 3(456):               (3->i)
3456 (m)                   1
3456*3776=13049856->9856   2
9856*3776=37216256->6256   3 (j)
6256*3776=23622656->2656   4
2656*3776=10029056->2656   5
9056*3776=34195456->5{456} #
3776^5=767644120830181376->1376 (q)

Part END(3456):
3456                       1
3456*1376=4755456->5456    2
5456*1376=7507456->7456    3
7456*1376=10259456->9456   4
9456*1376=13011456->1456   5
1456*1376=2003456->{3456}  #

ans=1*5*5*5=125
```


# Code

```python
# 这里面各种变量名都在上面的数据解释中有所体现。
n,k=map(int,input().split())
ans=1
mod=10**k
n%=mod
m=0
a=n
for i in range(1,k+1):
    flag=True # 判断是否有解
    m=n
    q=1
    for j in range(1,11): # 这里只用循环十次是因为最多只有 0~9 一共 10 个整数，超出就意味着无解。
        m*=a
        m%=mod
        q*=a
        q%=mod
        if m%10**i==n%10**i:
            ans*=j
            a=q
            flag=False
            break
    if flag:
        print(-1)
        exit(0)
print(ans)
```
时间复杂度 $O(10k)$。

**end**

---

## 作者：luwanning (赞：2)

## 题目大意
给定整数 $n$ 和 $k$，问 $n$ 的正整数次幂的后 $k$ 位是否会发生循环，若发生循环则求出循环节长度。
## Solution
**递推**+**高精度**。

一位一位考虑，从后 $1$ 位到后 $k$ 位。

- 后 $1$ 位：设最后一位循环节长度为 $t_1$。为了加速计算，把乘数变为 $n^{t_1}$ 的末 $k$ 位，表示为 $r_1$。
- 后 $2$ 位：设 $n$ 的后两位乘了 $t_2$ 次 $r_1$ 出现循环。为了加速计算，把乘数变为 $r_1^{t_2}$ 的末 $k$ 位，表示为 $r_2$。

  
  $\vdots$
  
  $\vdots$


- 后 $k-1$ 位：设 $n$ 的后 $k-1$ 位乘了 $t_{k-1}$ 次 $r_{k-2}$ 出现循环。为了加速计算，把乘数变为 $r_{k-2}^{t_{k-1}}$ 的末 $k$ 位，表示为 $r_{k-1}$。
- 后 $k$ 位：设 $n$ 的后 $k$ 位乘了 $t_k$ 次 $r_{k-1}$ 出现循环。

那么最后答案就是 $t_1t_2...t_{k-1}t_k$（注意要用高精度！！！）。
如果在某一位乘 $r_i$ 超过十次还是没有出现循环，则无解。

样例模拟：
```
32 2
2           1
2*2=4       2
4*2=8       3
8*2=6       4
6*2=2       出现循环

r1=32^4=76

32          1
32*76=32    出现循环

ans=4*1=4
```
总结一下，核心思路是递推，逐位考虑。分析一下时间复杂度，枚举位数 $\Theta(k)$ 和高精度 $\Theta(k^2)$，总的时间复杂度为 $\Theta(k^3)$。

---

代码：
```
#include <bits/stdc++.h>
using namespace std;

const int N = 110;
int n[N], p[N], q[N], r[N], l[N], k, tmp[N];
char s[111];

void mul(int a[], int b) {
	for (int i = 0; i < k; i++)
		a[i] *= b;
	for (int i = 0; i < k; i++) {
		a[i + 1] += a[i] / 10;
		a[i] %= 10;
	}
}// 高精乘单精

void mul(int a[], int b[]) {
	for (int i = 0; i < k; i++) tmp[i] = 0;
	for (int i = 0; i < k; i++)
		for (int j = 0; j < k; j++)
			if (i + j < k)
				tmp[i + j] += a[i] * b[j];
	for (int i = 0; i < k; i++) {
		tmp[i + 1] += tmp[i] / 10;
		tmp[i] %= 10;
		a[i] = tmp[i];
	}
}// 高精乘高精

int main() {
	scanf("%s%d", s, &k);
	int m = strlen(s);
	for (int i = 0; i < m; i++)	n[i] = s[m - i - 1] - '0';
	l[0] = 1;
	for (int j = 0; j < k; j++) q[j] = n[j];
	for (int i = 1; i <= k; i++) {
		for (int j = 0; j < k; j++) p[j] = n[j];
		for (int j = 0; j < k; j++) r[j] = 0;
		r[0] = 1;
		bool flag = false;
		for (int j = 1; j <= 10; j++) {
			mul(p, q);
			mul(r, q);// 更新乘数
			if (p[i - 1] == n[i - 1]) {
				mul(l, j);// 记答案
				for (int b = 0; b < k; b++) q[b] = r[b];// 更新乘数
				flag = true;
				break;
			}
		}
		if (!flag) {
			printf("-1\n");// 无解
			return 0;
		}
	}
	m = k - 1;
	while (!l[m]) --m;
	for (int j = m; j >= 0; j--)
		printf("%d", l[j]);
}
```

---

## 作者：我梦见一片焦土 (赞：1)

首先，看到数据规模，此题肯定是高精度。

其次，如果直接采用模拟法，进行 $n^2$，取后 $k$ 位，高精度乘法的复杂度是 $10000$，判断后 $k$ 位是否相等复杂度 $100$，如果循环长度大于 $100$，则会超时。

最后，一定要找到某种规律，不能直接模拟法，才能解得此题。

1. 模拟法-非高精度:

   直接反复乘 $n$，对后 $k$ 位进行比较，一旦与初始相等，输出循环长度，否则超过一定次数还找不到，输出 ```-1```。

2. 加上高精度，会不会多得一些分呢？

   事实证明，在调整循环次数的情况下，艰难的多得了一分，没有比第一种好多少！

3. 第二种方法的唯一问题是超时，主要原因就是要枚举 $n$ 的每一次幂才行，有没有更简洁的方式呢？

   可以假设后 $k-1$ 位的循环长度已经计算出来，设为 $t$，即 $n\times n^t\bmod10^{k-1}$ 和 $n\bmod (k-1)$ 相同。

   对于后 $k$ 位如果要相同，必须有后 $k-1$ 位相同，因此后k位的循环长度一定是 $t$ 的倍数，有可能是 $1、2、3\dots s$ 倍。

   即，$n \times n^t,n \times n^{2t},n \times n^{3t}\dots$ 某一个的后 $k$ 位与 $n$ 的后 $k$ 位相同，又因为后 $k-1$ 已经相同，所以只需要判断第 $k$ 位是否相同。

   而第 $k$ 位要相同，最多只需要 $10$ 次枚举，因为整数只有 $0$ 到 $9$，如果超过 $10$ 次还没有相同，则不存在循环。

   根据以上分析，可以从最后 $1$ 位、$2$ 位、$3$ 位的循环长度一直推出 $k$ 位的循环长度。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int k,n[N],a[N],b[N],c[N],l[N]={1,1};
char s[N];
void numcpy(int a[],int b[]){
    for(int i=0;i<=b[0];i++){
        a[i]=b[i];
    }
}
void Multiply(int a[],int b[],int r[]){
    for(int i=1;i<=a[0];i++){
        int c=0;
        for(int j=1;j<=b[0];j++){
            r[i+j-1]+=a[i]*b[j]+c;
            c=r[i+j-1]/10;
            r[i+j-1]%=10;
        }
        r[i+b[0]]+=c;
    }
    int ri=a[0]+b[0];
    while(r[ri]==0&&ri>1){
        ri--;
    }
    r[0]=ri;
    if(r[0]>k){
        r[0]=k;
    }
}
void Multiply(int a[],int b[]){
    int r[N]={};
    Multiply(a,b,r);
    numcpy(a,r);
}
void Multiply(int a[],int b){
    int c=0,i;
    for(i=1;i<=a[0];i++){
        a[i]=a[i]*b+c;
        c=a[i]/10;
        a[i]%=10;
    }
    while(c>0){
        a[i]=c%10;
        c/=10;
        i++;
    }
    while(a[i]==0&&i>1){
        i--;
    }
    a[0]=i;
}
void tonum(int a[],char s[]){
    int len=strlen(s);
    for(int i=1;i<=len;i++){
        a[i]=s[len-i]-'0';
    }
    a[0]=len;
}
signed main(){
    cin>>s>>k;
    tonum(n,s);
    numcpy(a,n);
    for(int i=1;i<=k;i++){
        bool flag=false;
        c[0]=c[1]=1;
        for(int j=1;j<=10;j++){
            Multiply(c,a);
            memset(b,0,sizeof b);
            Multiply(c,n,b);
            if(b[i]==n[i]){
                Multiply(l,j);
                flag=true;
                break;
            }
        }
        if(flag==false){
            cout<<-1;
            return 0;
        }
        numcpy(a,c);
    }
    for(int i=l[0];i>=1;i--){
        cout<<l[i];
    }
    return 0;
}
```

---


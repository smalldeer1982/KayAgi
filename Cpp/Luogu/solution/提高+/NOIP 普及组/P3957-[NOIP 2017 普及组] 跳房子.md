# [NOIP 2017 普及组] 跳房子

## 题目背景

NOIP2017 普及组 T4

## 题目描述

跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。

跳房子的游戏规则如下：

在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：

玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。

现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。

现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。

## 说明/提示

**样例 1 说明**

花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。

**样例 2 说明**

由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。

**数据规模与约定**

本题共 10 组测试数据，每组数据等分。

对于全部的数据满足 $1 \le n \le 5\times10^5$，$1 \le d \le2\times10^3$，$1 \le x_i, k \le 10^9$，$|s_i| < 10^5$。

对于第 $1, 2$ 组测试数据，保证 $n\le 10$。

对于第 $3, 4, 5$ 组测试数据，保证 $n \le 500$。

对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。

## 样例 #1

### 输入

```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7 4 20
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2```

### 输出

```
-1```

# 题解

## 作者：Tweetuzki (赞：286)

这题是第四题，对于我这种蒟蒻来讲是不可能 AC 的，所以先想着骗分。什么时候不能得到目标分数呢？如果所有正数分数都加起来还小于目标分数，那就得不到目标分数。所以先特判 $-1$。

再看看这一题，我想起了 NOIP2015 提高组的“跳石头”，那题不是二分吗？这题也好像啊……于是果断使用二分求解。确定下来二分了，那么就来考虑，怎样判断二分的这个答案可不可以，显然使用动态规划。

$dp[i]$ 表示跳到第 $i$ 个格子时所能得到的分数最大值，若跳不到该格，则 $dp[i]=-\infty$。为了动规方便，再加入起点的格子，显然，起点格子离原点的距离为 $0$，格子上的值也为 $0$。状态转移方程：设 $max(l,r)$ 表示 $[l,r]$ 区间内能跳到的格子中的最大值，则 $dp[i]=\max($点 $i$ 到原点的距离 $-mid$,点 $i$ 到原点的距离 $+mid)$。

用没有优化的 DP，时间复杂度是二维的，对于 $50\%$ 的数据可以过，但是对于另外 $50\%$ 的数据 $n=500000$，即使两秒的时限也是超得不爱超了。怎么优化 DP 呢？

有一个叫单调队列的东西，专门取区间内的最大最小值。在 POJ 上，有一题叫做[Sliding Window](http://poj.org/problem?id=2823)，就是单调队列的模板题。单调队列要想优化 DP，必须得保证 $l$ 和 $r$ 是单调递增或递减的。而在本题中，在向右 DP 时，上述的状态转移方程在 $dp[i]=\max($点 $i$ 到原点的距离 $-mid$,点 $i$ 到原点的距离 $+mid)$ 的 $mid$ 不变的情况下，随着 $i$ 离原点越来越远，$l$ 和 $r$ 越来越大，所以也是单调递增的。这样一优化，DP 的时间复杂度就降至一维，对于最大的 $n=500000$，就能在 2 秒的时限内轻松通过了。

upt: 感谢各位指正，现以修复代码中原有的 bug。我原来犯的错误有：

1. dp 数组初始值不能设为 $-1$，应该设为 $-\infty$，在代码中体现为 $\text{0x8080808080808080}$。
2. 二分的右边界应该取 $d$ 与第 $n$ 个格子到原点的距离的较大值，因为 $d$ 与第一个格子间距离可能大于第 $n$ 个格子到原点的距离。（感谢 @Bartholomew 的 Hack 数据 `1 42 14 20 23 `）

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn=500000;
const long long neInf=0x8080808080808080;
struct gezi {
    int juli;
    int zhi;
} a[maxn+1];
long long dp[maxn+1];
int q[maxn+1];
int n,d,k,lbound,rbound,ans=-1;
long long sum;

void kuaidu(int &p) {
    char c;
    int f=1;
    p=0;
    do {
        c=getchar();
        if (c=='-')
            f=-1;
    } while (c<'0'||c>'9');
    do p=p*10+c-'0', c=getchar();
    while (c>='0'&&c<='9');
    p=p*f;
}

void init() {
    cin>>n>>d>>k;
    for (int i=1; i<=n; i++) {
        kuaidu(a[i].juli);
        kuaidu(a[i].zhi);
        if (a[i].zhi>0)
            sum+=a[i].zhi;
    }
    rbound=max(a[n].juli,d);
}

long long dynamic_programming(int zuo, int you) {
    memset(dp,0x80,sizeof(dp));
    dp[0]=0;
    memset(q,0,sizeof(q));
    int tou=1, wei=0, j=0;
    /*for (int i=1; i<=n; i++)
        for (int j=0; j<i; j++)
            if (a[i].juli-a[j].juli>=zuo&&a[i].juli-a[j].juli<=you&&dp[j]!=neInf)
                dp[i]=max(dp[i],dp[j]+a[i].zhi);*/
    for (int i=1; i<=n; i++) {
        while (a[i].juli-a[j].juli>=zuo&&j<i) {
            if (dp[j]!=neInf) {
                while (tou<=wei&&dp[q[wei]]<=dp[j])
                    wei--;
                q[++wei]=j;
            }
            j++;
        }
        while (tou<=wei&&a[i].juli-a[q[tou]].juli>you)
            tou++;
        if (tou<=wei)
            dp[i]=dp[q[tou]]+a[i].zhi;
    }
    long long num=neInf;
    for (int i=1; i<=n; i++)
        if (dp[i]>num)
            num=dp[i];
    return num;
}

int main() {
    //freopen("jump.in","r",stdin);
    //freopen("jump.out","w",stdout);
    init();
    if (sum<k) {
        cout<<"-1"<<endl;
        return 0;
    }
    while (lbound<=rbound) {
        int mid=(lbound+rbound)/2;
        int zuobianjie=max(1,d-mid);
        int youbianjie=d+mid;
        long long num=dynamic_programming(zuobianjie,youbianjie);
        if (num<k)
            lbound=mid+1;
        else {
            ans=mid;
            rbound=mid-1;
        }
    }
    cout<<ans<<endl;
    //fclose (stdin);
    //fclose (stdout);
    return 0;
}
```

---

## 作者：Gorenstein (赞：67)

[原题链接：P3957 跳房子](https://www.luogu.com.cn/problem/P3957)

### 题目大意

- 直线的正方向上有 $n$ 个点，他们到原点的距离为 $x_i$，第 $i$ 个点有一个权值 $s_i$。**权值可能为负**。
- 从原点开始向右跳。假设原点为第 $0$ 个点，每次能跳到  $\left[s_i+d-g,s_i+d+g\right]$ 中**在第 $i$ 个点右边**的任意一个点，并获得对应的权值。
- 给定 $d,k$，现在想要在获得的权值之和大于等于 $k$ 的前提下，最小化 $g$。
- $1\leq n\leq 5\times 10^5,1\leq d\leq 2000,1\leq x_i,k\leq 10^9,∣s_i∣<10^5$。

### 分析

容易发现，花费的金币越多，则跳跃距离的灵活度也更大。故而当金币增加时，最大得分是不降的。因此最大得分对金币数具有单调性，故二分判定 $g$ 。

```
//二分判定mid（假设单调上升） 
l=0,r=100005;
while(l<r){
	long long mid=l+r>>1;
	if(check(mid))r=mid;
	else l=mid+1;
}
```

然后思考如何实现判定。容易发现这是一个基本的线性 DP 问题。

每一个点都需要从它左边的点跳过来，并且后面的跳法不受前面如何条约影响。同时，一个点的最大得分，是从能跳到这个点的前面所有点中选取最优的一个。

我们设 $f_i$ 表示以 $i$ 结尾的所有跳跃路线获得的权值中的最大值，并令 $f_0=0$。容易写出转移方程

$$
f_i=\max\limits_{\{j:0\leq j<i\}}\{f_j+s_i\} \quad{}_{(d-g\leq x_i-x_j\leq d+g)}.
$$

若发现一个 $f_i$ 大于等于 $k$，直接返回 `true`，否则判定失败。时间复杂度 $O(n^2\log n)$。

```cpp
//38 lines of AC_code
long long n,d,k,f[500005],a[500005][2];
bool check(int g){
    memset(f,-127,sizeof(f)); 
    long long x=max(d-g,(long long)1),s=d+g;
    f[0]=0;
    //外层循环枚举阶段i 
    for(long long i=1;i<=n;i++){
    	//内层循环对决策点j进行转移 
    	for(long long j=i-1;j>=0;j--){
    		if(a[i][0]-a[j][0]<x)continue;
    		if(a[i][0]-a[j][0]>s)break;
    		//实行状态转移方程 
    		f[i]=max(f[i],f[j]+a[i][1]);
    		if(f[i]>=k)return true;
        }
    }
    return false;
}
int main(){
	cin>>n>>d>>k;
	for(long long i=1;i<=n;i++)
		cin>>a[i][0]>>a[i][1];
	l=0,r=100005;
	//二分判定花费mid是否可行 
	while(l<r){
		long long mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	if(l==100005)cout<<-1;
	else cout<<l;
	return 0;
}
```

### 单调队列优化

我们还能继续进行优化。

继续思考，容易发现，当 $i$ 增大时，候选集合在整体的向右移。因此，此题实际上是一个**移动区间求最值**的问题，可用单调队列来实现。

单调队列中的元素维护的值满足单调性，并且每个元素对应在原序列中的顺序必须单调递增。每一次区间的移动，队首就是最优解。

建立单调队列 $q$，执行以下步骤：
1. 对于每个阶段 $i$，将决策候选集合中的元素 $j$ 从队尾插入单调队列。此题中是区间最大值，所以队首应为未过时的所有决策中最大值。内部决策单调递减；
2. 检查队首，排除过时决策；
3. 直接取队首作为当前状态的最优决策，实行转移；
4. 转移过后，判断分数是否已经大于 $k$，如果是，返回判定成功。

所有 $j$ 的取值最多进队和出队一次，因此单次判定的是线性的。总时间复杂度为 $O(n\log n)$。

```cpp
//38 lines of AC_code
long long n,d,k,f[500005],a[500005][2],q[500005],l=0,r=100005;
bool check(int g){
    memset(f,-,sizeof(f));
    memset(q,0,sizeof(q));
    long long x=max(d-g,(long long)1),s=d+g;
	long long head=1,tail=0,j=0;
	f[0]=0;
	//依次转移每个i 
    for(long long i=1;i<=n;i++){  
    	//决策候选集合  
    	while(a[i][0]-a[j][0]>=x&&j<i){
    		if(f[j]>-99999999){
    			//检查队尾单调性 
    			while(f[q[tail]]<=f[j]&&head<=tail)tail--;
    			q[++tail]=j;//符合单调性后，插入决策j
			}
    		j++;
		}
		//检查队头是否过时 
    	while(a[i][0]-a[q[head]][0]>s&&head<=tail)head++;
    	if(head<=tail)f[i]=f[q[head]]+a[i][1];//实行决策 
    	if(f[i]>=k)return true;
	}
    return false;
}
int main(){
	cin>>n>>d>>k;
	for(long long i=1;i<=n;i++)cin>>a[i][0]>>a[i][1]; 
	//二分判定花费mid个金币是否可行 
	while(l<r){
		long long mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	if(l==100005)cout<<-1;
	else cout<<l;
	return 0;
}
```

---

## 作者：JayJessy (赞：22)

~~难道有人看题解不点赞的吗？~~
## 题目解析
这道题可以使用二分+动态规划，二分要花的金币数。  
$l$ 初始值为 $0$，$r$ 初始值为 $10^9$。  
每次二分有弹跳距离的下界和上界：  
$mn=\max(1,d-mid)$  
$mx=d+mid$
### 50pts：
简单的 $ok$ 函数：
```cpp
bool ok(ll g) {
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	ll ans=0;
	for(ll i=1; i<=n; i++) {
		for(ll j=i-1; j>=0; j--) {
			if(x[i]-x[j]>d+g) break;
			if(x[i]-x[j]>=max(1ll,d-g)) dp[i]=max(dp[i],dp[j]+s[i]);
		}
		ans=max(ans,dp[i]);
	}
	return ans>=k;
}
```
然后就发现程序超时，只有 $50$ 分。
### 100pts：
很明显需要优化 $ok$ 函数。  
可以发现对于 $dp_i$ 需要维护 $[i-mn,i+mx]$ 的最大值。  
欸，这不就是**单调队列**吗？    
对于 $dp_i$：
- 先将所有满足 $j\lt i$ 且 $x_i-x_j \ge mn$ 的 $j$ 加进队尾。
```cpp
while(j<i && x[i]-x[j]>=mn) {
	if(dp[j]>-1e18) {
		while(!q.empty() && dp[q.back()]<=dp[j]) q.pop_back();
		q.push_back(j);
	}
	j++;
}
```  
- 接下来将队头 $x_i-x_{q.front()} \gt mx$ 的元素删去。  
```cpp
while(!q.empty() && x[i]-x[q.front()]>mx) q.pop_front();
```
- 最后将 $dp_i$ 赋值为 $x_{q.front()}+s_i$ 并算出答案。
```cpp
if(!q.empty()) dp[i]=dp[q.front()]+s[i];
ans=max(ans,dp[i]);
```
呼，该说的都说完了，接下来就是……  
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
deque<ll> q;
ll n,d,k,l,r=1e9,x[N],s[N],dp[N];
bool ok(ll g) {
	q=deque<ll>();
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	ll mn=max(1ll,d-g),mx=d+g,j=0,ans=0;
	for(ll i=1; i<=n; i++) {
		while(j<i && x[i]-x[j]>=mn) {
			if(dp[j]>-1e18) {
				while(!q.empty() && dp[q.back()]<=dp[j]) q.pop_back();
				q.push_back(j);
			}
			j++;
		}
		while(!q.empty() && x[i]-x[q.front()]>mx) q.pop_front();
		if(!q.empty()) dp[i]=dp[q.front()]+s[i];
		ans=max(ans,dp[i]);
	}
	return ans>=k;
}
int main() {
	freopen("jump.in","r",stdin);
	freopen("jump.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>d>>k;
	for(ll i=1; i<=n; i++) cin>>x[i]>>s[i];
	while(l<r) {
		ll mid=(l+r)>>1;
		if(ok(mid)) r=mid;
		else l=mid+1;
	}
	if(l>=1e9) cout<<-1;
	else cout<<l;
	return 0;
}
```
完结撒花~~

---

## 作者：Frozencode (赞：18)

蒟蒻不会单调队列，怎么办？另类方法，一样**AC**

题目要我们求最小的$g$，这看上去就不太好直接求。怎么办？

一个常见的想法，将原问题转换成判定性问题:给定弹跳距离的范围，能否获得至少$k$分。(**注意**:玩家可以在任意时刻结束游戏，所以只要出现一个时刻的分数$x_i$满足$x_i>=k$即可）

一个朴素的想法:可以**DP**!

每次找前面合法状态(即符合弹跳距离)中当前分数最大的状态转移。

$1≤n≤500000$，朴素的枚举好像会挂。怎么优化？

注意到每次事实上有用的只有分数最大的那个状态，想到了啥？

**RMQ**?**优先队列**？(~~我也不知道为啥想到的不是单调队列而是优先队列~~)

想到这里那么这一题已经基本做完了。

用优先队列维护所有合法状态，每次取出堆顶转移即可。

实测不开O2可以[AC](https://www.luogu.org/record/21983224)

看了一圈题解发现大家基本都是单调队列做法。

~~也许我的做法比较平易近人~~

```cpp
/*
	Author:Frozencode
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 500010;
const ll INF = 2147483647;
struct node{
	ll pos,pts;
}a[maxn];//pts为该点得分。
struct tem{
	ll pos,sum;
	bool operator < (const tem &a)const//结构体优先队列必备之重载运算符。
	{
		return sum < a.sum;
	}
};//sum为当前的分数。
priority_queue<tem>q;
priority_queue<tem>iq;
tem cur;
ll n,d,k,l,r,res;
void init(ll i,ll x){
	while(!q.empty()){
		cur = q.top();
		if(a[i].pos - cur.pos > d + x){q.pop();}//剔除不合法状态
		else if(a[i].pos - cur.pos < max(1ll * 1,d - x)){
			iq.push(q.top());
			q.pop();
		}//对于当前状态此状态不合法，但是以后的状态可能会用到，得先留着。
		else break;//发现最大值，转移走起。
	}
	return;
}
bool check(ll x){
	while(!q.empty())q.pop();
	while(!iq.empty())iq.pop();
	cur.pos = 0;
	cur.sum = 0;
	q.push(cur);//以上为初始化。
	for(int i = 1;i <= n;i++){
		init(i,x);
        if(q.empty())
		{
			while(!iq.empty()){
			q.push(iq.top());
			iq.pop();
			}
			continue;//没法转移，此状态拜拜~ 还原现场。
		}
		cur.pos = a[i].pos;
		cur.sum = cur.sum + a[i].pts;
		if(cur.sum >= k)return true;//符合条件 成功！
		q.push(cur);//添加新状态。
        while(!iq.empty()){
			q.push(iq.top());
			iq.pop();
		}还原现场。
	}
	return false;//失败 T_T
}
int main()
{ 
	ios::sync_with_stdio(false);
	cin>>n>>d>>k;
	for(int i = 1;i <= n;i++){
		cin>>a[i].pos>>a[i].pts;
		r = max(r,a[i].pos);
	}
	l = res = -1;//如果答案一次都没更新到说明无论如何都没法达到k分。输出-1。
	++r;
	while(l < r - 1){
		ll mid = (l + r)>>1;
		if(check(mid)){
			r = mid;
			res = r;//更新答案。
		}
		else l = mid;
	}//二分没啥好说的。
	cout<<res;
	return 0;
}
```


---

## 作者：GZXUEXUE (赞：10)

### 思路

观察到我们要求的最小的 $g$ 满足单调性（当 $g$ 不断增加时，容易发现能获得的最大得分单调不降），考虑使用二分求 $g$。

那么 `check()` 怎么写呢？容易发现，我们可以通过当前枚举到的的 $g$ 求最大得分，然后与 $k$ 相比较，从而判定当前枚举到的 $g$ 是否合法，故考虑使用线性 dp 计算。

我们设 $f_i$ 表示以 $i$ 结尾的所有跳房子方法能获得的的最大分数，易得动态转移方程为：

$$
f_i = \max({f_j + s_i}) \hspace{0.5cm} \operatorname{if} \hspace{0.1cm} \max(0,i-g-d) < j < i \hspace{0.1cm} \operatorname{and} \hspace{0.1cm} x_j + \max(d-g,1) \le x_i \le x_j + (d+g)
$$

其中 $s_i$ 表示第 $i$ 个格子的分数，$x_i$ 表示第 $i$ 个格子的位置。

### 实现

```cpp
# include <iostream>
# define int long long
using namespace std;
int n,d,k,score[500005][2],f[500005];
bool check(int g){
	for (int i = 1;i <= n;i++) f[i] = -1e18;
	f[0] = 0;
	for (int i = 1;i <= n;i++){
		for (int j = i - 1;j >= 0;j--){
			if (score[i][0] - score[j][0] > (d + g)) break;
			if (score[i][0] - score[j][0] < max(d - g,1ll)) continue;
			f[i] = max(f[i],f[j] + score[i][1]);
			if (f[i] >= k) return true; // 如果当前能获得的最大分数已经比k大就直接返回true，不用再判断了
		}
	}return false;
}signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> d >> k;
	for (int i = 1;i <= n;i++) cin >> score[i][0] >> score[i][1];
	int l = 0,r = 1e5 + 5;
	while (l < r){
		int mid = (l + r) >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}if (l == 1e5 + 5) cout << -1; // 如果无解输出-1
	else cout << l;
	return 0;
}
```

---

## 作者：Jadonyzx (赞：6)

### **大家好，我非常喜欢暴力数据结构，于是我就~~吸氧~~用分块过了这道题。**

首先考虑无解的情况，显然当所有不为负的得分之和小于 $k$ 时无解，其他情况显然有解。

显然可以二分答案，然后里面跑动态规划。

不妨设 $dp_i$ 表示跳到第 $i$ 个点的最大得分，若不能跳到则设为负无穷。

有转移方程：$dp_i=\max_{j \in [\max(0,x_i-g-d),x_i+d+g]}dp_j+s_i$。

判一下是否存在一个 $dp_i$ 满足 $dp_i>k$ 即可。

显然可以单调队列优化，然后劣化成线段树，最后劣化成分块！

code：


```cpp
#include<bits/stdc++.h>
#define maxn 500005
#define int long long
using namespace std;
int n,d,k,dp[maxn],l,r,pts[maxn],x[maxn],ans,head,tail,q[maxn],maxx,point;
inline bool check(int coins){
    for(int i=1;i<=n;++i)dp[i]=-1e18;
    dp[0]=0;l=max(d-coins,1ll);r=d+coins;head=1;tail=0;
    point=0;x[0]=0;memset(q,0,sizeof q);q[++tail]=0;
    int start=1;
    while(!(x[start]>=l&&x[start]<=r) && start<=n)start++;point=1;
    for(int i=start;i<=n;++i){
        // for(int j=0;j<i;++j){
        //     if(x[j]>=x[i]-r&&x[j]<=x[i]-l){
        //         dp[i]=max(dp[i],dp[j]+pts[i]);
        //     }
        // }
        while(x[point]<=x[i]-l){
            while(head<=tail&&dp[q[tail]]<=dp[point])tail--;
            q[++tail]=point++;
        }
        while(head<=tail&&x[q[head]]<x[i]-r)head++;
        if(head>tail)continue;
        int j=q[head];dp[i]=dp[j]+pts[i];
        if(dp[i]>=k)return 1;
    }
    return 0;
}
signed main(){
	cin>>n>>d>>k;
    for(int i=1;i<=n;++i)cin>>x[i]>>pts[i],maxx+=(pts[i]>0)?pts[i]:0;
    if(maxx<k){
        cout<<-1;
        return 0;
    }
    int L=0,R=1e9,mid;
    while(L<=R){
        mid=(L+R)>>1;
        if(check(mid))ans=mid,R=mid-1;
        else L=mid+1;
    }
    cout<<ans;
	return 0;
}
```


改成线段树后：


```cpp
#include<bits/stdc++.h>
#define maxn 500005
#define int long long
using namespace std;
int n,d,k,dp[maxn],l,r,pts[maxn],x[maxn],ans,maxx;
int tree[maxn*4];
inline void build(int id,int l,int r){
    tree[id]=-1e18;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(id<<1,l,mid);build(id<<1|1,mid+1,r);
    return;
}
inline void update(int id,int l,int r,int x,int val){
    if(l==r){
        tree[id]=max(tree[id],val);
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid)update(id<<1,l,mid,x,val);
    else update(id<<1|1,mid+1,r,x,val);
    tree[id]=max(tree[id<<1],tree[id<<1|1]);
    return;
}
inline int query(int id,int l,int r,int tol,int tor){
    if(tol>r||tor<l)return -1e18;
    if(tol<=l&&r<=tor)return tree[id];
    int mid=(l+r)>>1;
    return max(query(id<<1,l,mid,tol,tor),query(id<<1|1,mid+1,r,tol,tor));
}
inline bool check(int coins){
    build(1,1,n+1);
    for(int i=1;i<=n;++i)dp[i]=-1e18;
    dp[0]=0;l=max(d-coins,1ll);r=d+coins;
    update(1,1,n+1,1,0);
    for(int i=1;i<=n;++i){
        int lll=-1,rrr=-1;
        int lef=0,rig=i-1,mid;
        while(lef<=rig){
            mid=(lef+rig)>>1;
            if(x[mid]>=x[i]-r)lll=mid,rig=mid-1;
            else lef=mid+1;
        }
        lef=0;rig=i-1;
        while(lef<=rig){
            mid=(lef+rig)>>1;
            if(x[mid]<=x[i]-l)rrr=mid,lef=mid+1;
            else rig=mid-1;
        }
        if(lll>rrr)continue;
        if(lll==-1||rrr==-1)continue;
        dp[i]=query(1,1,n+1,lll+1,rrr+1)+pts[i];
        if(dp[i]>=k)return 1;
        update(1,1,n+1,i+1,dp[i]);
    }
    return 0;
}
signed main(){
	cin>>n>>d>>k;
    for(int i=1;i<=n;++i)cin>>x[i]>>pts[i],maxx+=(pts[i]>0)?pts[i]:0;
    if(maxx<k){
        cout<<-1;
        return 0;
    }
    int L=0,R=1e9,mid;
    while(L<=R){
        mid=(L+R)>>1;
        if(check(mid))ans=mid,R=mid-1;
        else L=mid+1;
    }
    cout<<ans;
	return 0;
}
```


最后改成分块：


```cpp
#include<bits/stdc++.h>
#define maxn 500005
#define int long long
using namespace std;
int n,d,k,dp[maxn],l,r,pts[maxn],x[maxn],ans,maxx;
int block,blol[maxn],blor[maxn],BLO[maxn],blo[maxn],val[maxn];
inline void update(int x,int Val){
    val[x]=Val;BLO[blo[x]]=-1e18;
    for(int i=blol[blo[x]];i<=blor[blo[x]];++i)BLO[blo[x]]=max(BLO[blo[x]],val[i]);
    return;
}
inline int query(int l,int r){
    int ans=-1e18;
    for(int i=blo[l]+1;i<=blo[r]-1;++i)ans=max(ans,BLO[i]);
    for(int i=l;i<=min(r,blor[blo[l]]);++i)ans=max(ans,val[i]);
    for(int i=max(l,blol[blo[r]]);i<=r;++i)ans=max(ans,val[i]);
    return ans;
}

inline bool check(int coins){
    for(int i=1;i<=n;++i)dp[i]=val[i+1]=-1e18;
    for(int i=1;i<=blo[n+1];++i)BLO[i]=-1e18;
    for(int i=1;i<=n;++i)BLO[blo[i+1]]=max(BLO[blo[i+1]],dp[i]);
    BLO[blo[1]]=0;
    dp[0]=0;l=max(d-coins,1ll);r=d+coins;
    update(1,0);
    for(int i=1;i<=n;++i){
        int lll=-1,rrr=-1;
        int lef=0,rig=i-1,mid;
        while(lef<=rig){
            mid=(lef+rig)>>1;
            if(x[mid]>=x[i]-r)lll=mid,rig=mid-1;
            else lef=mid+1;
        }
        lef=0;rig=i-1;
        while(lef<=rig){
            mid=(lef+rig)>>1;
            if(x[mid]<=x[i]-l)rrr=mid,lef=mid+1;
            else rig=mid-1;
        }
        if(lll>rrr)continue;
        if(lll==-1||rrr==-1)continue;
        dp[i]=query(lll+1,rrr+1)+pts[i];
        if(dp[i]>=k)return 1;
        update(i+1,dp[i]);
    }
    return 0;
}
signed main(){
	cin>>n>>d>>k;block=sqrt(n+1)/3;
    for(int i=1;i<=n+1;++i){
        blo[i]=(i-1)/block+1;
        if(!blol[blo[i]])blol[blo[i]]=i;
        blor[blo[i]]=i;
    }
    for(int i=1;i<=n;++i)cin>>x[i]>>pts[i],maxx+=(pts[i]>0)?pts[i]:0;
    if(maxx<k){
        cout<<-1;
        return 0;
    }
    int L=0,R=1e9,mid;
    while(L<=R){
        mid=(L+R)>>1;
        if(check(mid))ans=mid,R=mid-1;
        else L=mid+1;
    }
    cout<<ans;
	return 0;
}
```

---

## 作者：yuruilin2026 (赞：4)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)。\
我这个蒟蒻直到今天才 AC 这道题。
## 初步分析：
一个很明显的性质：\
若花费金币数为 $g$ 时可以获得 $k$ 分，那么花费金币数为 $g+1$ 时也可以获得 $k$ 分。\
~~这简直是一句废话。~~\
但这就满足了二分的单调性质，可以使用二分求解。\
令 $dp_i$ 表示走到 $i$ 时获得的最大分数，然后就能写出这样一段代码：
```cpp
for(long long i = 1;i <= n;i++){
	for(long long j = 0;j < i;j++){
		if(d+g >= x[i] - x[j] && x[i] - x[j] >= max(1ll,d-g)){//满足题目要求。
			dp[i] = max(dp[i],dp[j]+s[i]);//若 j 能走到 i,就用 j 转移。
		}
	}
}
```
其中 $d,g,x_i$ 的含义与题目一致。\
这是我在某场团队模拟赛中写出的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,d,k,x[514514],s[514514],l = 1,r = 1e9,mid,dp[514514];
bool check(int g){
	for(long long i = 1;i <= n;i++) dp[i] = -(INT_MAX-1);
	for(long long i = 1;i <= n;i++){
		for(long long j = 0;j < i;j++){
			if(d+g >= x[i] - x[j] && x[i] - x[j] >= max(1ll,d-g)){
				dp[i] = max(dp[i],dp[j]+s[i]);
			}
		}
	}
	for(long long i = 1;i <= n;i++){
		if(dp[i] >= k) return 1;
	}
	return 0;
}
int main(){
	cin.tie(0);
	cin >> n >> d >> k;
	for(long long i = 1;i <= n;i++){
		cin >> x[i] >> s[i];
	}
	while(l < r){
		//cout << l << " " << r << endl;
		mid = (l+r)/2;
		if(check(mid)){
			r = mid;
		}
		else{
			l = mid+1;
		}
	}
	if(!check(r)) cout << -1;
	else cout << r;
	return 0;
}
```
然后就炸了。\
肯定需要优化。
## 优化分析：
在原来的 DP 方程式的基础上进行修改。\
考虑以下性质：$x_j < x_{j+1}$。\
那么在枚举到 $i$ 时，如果 $x_i - x_{j+1} > d+g$，则 $x_i - x_j > d+g$。\
所以考虑倒序枚举 $j$，如果 $x_i - x_j > d+g$，就可以不用继续枚举。
## AC 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,d,k,x[514514],s[514514],l = 1,r = 3e5+2,mid,dp[514514];
#define max(a,b) (a>b?a:b)
bool check(int g){
	for(long long i = 1;i <= n;i++) dp[i] = -(LLONG_MAX-INT_MAX);
	for(long long i = 1;i <= n;i++){
		for(long long j = i-1;j >= 0;j--){
			if(x[i] - x[j] > d+g) break;
			if(x[i] - x[j] < max(1ll,d-g)) continue;
			dp[i] = max(dp[i],dp[j]+s[i]);
			if(dp[i] >= k) return 1;
		}
	}
	return 0;
}
int main(){
	cin.tie(0);
	cin >> n >> d >> k;
	for(long long i = 1;i <= n;i++){
		cin >> x[i] >> s[i];
	}
	while(l < r){
		mid = (l+r)/2;
		if(check(mid)){
			r = mid;
		}
		else{
			l = mid+1;
		}
	}
	if(!check(r)) cout << -1;
	else cout << r;
	return 0;
}
```

---

## 作者：Swordmaker (赞：4)

# P3957 [NOIP 2017 普及组] 跳房子

# 前置知识

本题需要一定的**动态规划**思想，且需要掌握**二分**和**单调队列**等。

# 思路分析

题目中需要求一个最小的 $g$ 使得总得分不小于 $k$ 分。于是可以对 $g$ 进行二分。

原因是因为本题有这么一个性质：

对于当前的 $g$，如果在当前的情况下最大可以获得 $s$ 分，则对于一个不小于 $g$ 的 $h$，其获得的最大分数也不会小于 $s$ 分。因为当每次跳的范围变大时，总可以存在一种跳法，让其获得此前小范围的分数。

所以，对于 $g$，满足单调性质：随着 $g$ 的增大，获得的分数一定不会下降。

# 初步思路

思路分析好了，接下来可以敲代码了。

一开始，我们很容易想到这样的动态规划做法：
```
//复杂度：n^2
for(int i=1;i<=n;i++)
	{
		for(int j=i-1;j>=0;j--)
		{		
			if((x[i]-x[j])<pos||(x[i]-x[j])>d+now) continue;
			dp[i]=max(dp[i],dp[j]+s[i]);
			if(dp[i]>=k) return true;
		}
	}
```
然后：时间超限。

因为其复杂度肉眼可见。

# 优化

对于动态规划的优化有许多方法，这里介绍其中的一种：单调队列。

在二分的判断函数中，可以使用一个单调队列来维护，每次选取一个最优的决策并更新数组，能够做到线性复杂度。

其余解释看代码了：

# code
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,d,k,sum=0,ans=-1;//ans一开始设为-1，有利于无解情况的输出 
int x[500005],s[500005],dp[500005];
bool check(int now)
{
	int q[500005]={};//单调队列 
	int h=1,t=0,j=0;//初始化头尾指针 
	memset(dp,-0x3f,sizeof(dp));
	int pos=max(1ll,d-now);//跳跃的最少格子是1和d-now的较大值 
	dp[0]=0;//设置边界 
	for(int i=1;i<=n;i++)
	{
		while(i>j&&x[i]-x[j]>=pos)//如果是向右跳并且在范围内 
		{
			if(dp[j]!=-0x3f)//如果dp[j]被访问过了 
			{
				while(h<=t&&dp[q[t]]<=dp[j]) t--;//队尾具有单调性 
				q[++t]=j;//当前格子选择入队 
			}
			j++;
		}
		while(h<=t&&x[i]-x[q[h]]>(d+now)) h++;//如果队首没有过期 
		if(h<=t) dp[i]=dp[q[h]]+s[i];//更新dp数组 
		if(dp[i]>=k) return true;//如果当前的得分已经超过了k，返回true 
	}
	return false;//在任何一个时刻都不存在dp[i]>=k，返回false 
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++)//输入部分 
	{
		cin>>x[i]>>s[i];
		if(s[i]>0) sum+=s[i];//记录所有正数的和 
	}
	if(sum<k)//（可能没用的）优化：如果格子中所有正数加起来还没有达到k，则不可能获得k分，直接输出-1 
	{
		cout<<-1<<"\n";
		return 0;
	}
	int l=0,r=1e6+1;//二分小技巧：将l和r设置为两个取不到的值，避免二分时出现一些奇奇怪怪的bug
	while(l<=r)//二分，求最小的能使得分到达k分的g 
	{
		//二分板子有很多写法，这里只是展示了其中的一种 
		int mid=(l+r)>>1;
		if(check(mid))//如果当前的g满足得分可能达到k的条件 
		{
			r=mid-1;//尝试寻找更小的g，寻找更优的答案 
			ans=mid;
		}
		else l=mid+1;//否则，将限制扩大，寻找答案 
	}
	cout<<ans<<"\n";//输出答案 
	return 0;
}
```

---

## 作者：wandereman (赞：4)

## 开头
我们可以先敲出一个暴力 dp，再进行优化。
## 50 pts 思路
先敲出 $O(n^2)$ 的动态规划转移方程，分成两种情况，上界和下界，就可以轻松写出以下分类式和转移式：
```cpp
if(x[i]-x[j]>d+g){
	break;
}
dp[i]=max(dp[i],dp[j]+s[i]);
```
## 50 pts code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
ll dp[MAXN],n,d,k,x[MAXN],s[MAXN];
//dp[i]表示到第i格的最大分数 
bool solve(ll g){
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	ll ans=0,i,j;
	for(i=1;i<=n;i++){
		for(j=i-1;j>=0;j--){
			if(x[i]-x[j]>d+g){
				break;
			}
			if(x[i]-x[j]>=max(1ll,d-g)){
				dp[i]=max(dp[i],dp[j]+s[i]);
			}
		}
		ans=max(ans,dp[i]);
	}
	return ans>=k;
}
int main(){
	ll i;
	cin>>n>>d>>k;
	for(i=1;i<=n;i++){
		cin>>x[i]>>s[i];
	}
	for(i=1;;i++){
		if(solve(i)){
			cout<<i<<endl;
			break;
		}
	}
	return 0;
} 
```
## 优化方法及思路
在上面的 DP 式子中，我们可以列一下每一个区间由哪里得出，就可以发现，不管是区间的哪一端，都按照单调递增排列，由此我们可以想到利用以下方法来优化。
### 二分
问题答案具有二段性和单调性，可以进行二分答案，二分 $g$，得到最优方案时的 $g$。
### 单调队列
在一个 $[l,r]$ 均单调不减的区间 $[l,r]$ 上找最小值，可以用单调队列维护（参考例题：[P1886](https://www.luogu.com.cn/problem/P1886)）。

最后的时间复杂度为 $O(n \log n)$。
## 100 pts code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAXN=1e9+10;
deque<ll>q;
ll n,d,k,l,r=1e9,x[MAXN],s[MAXN],dp[MAXN];
bool p=0;
//dp[i]表示到第i格的最大分数 
bool solve(ll g){
	ll i;
	q=deque<ll>();
	memset(dp,-0x3f,sizeof(dp));
	dp[0]=0;
	ll mn=max(1ll,d-g),mx=d+g,j=0,ans=0;
	for(ll i=1;i<=n;i++){
		while(j<i&&x[i]-x[j]>=mn){
			if(dp[j]>-1e18){
				while(!q.empty()&&dp[q.back()]<=dp[j]){
					q.pop_back();
				}
				q.push_back(j);
			}
			j++;
		}
		while(!q.empty()&&x[i]-x[q.front()]>mx){
			q.pop_front();
		}
		if(!q.empty()){
			dp[i]=dp[q.front()]+s[i];
		}
		ans=max(ans,dp[i]);
	}
	return ans>=k,p=1;
}
int main(){
	cin>>n>>d>>k;
	ll i;
	for(i=1;i<=n;i++){
		cin>>x[i]>>s[i];
	}
	while(l<r){
		ll mid=(l+r)>>1;
		if(solve(mid)){
			r=mid;
		}else{
			l=mid+1;
		}
	}
	if(p==1){
		cout<<-1;
	}else{
		cout<<l;
	}
	return 0;
}
```

---

## 作者：AuZeb (赞：3)

## 题意

设 $f_i=\max(f_i,f_j+s_i)(\max(1,d-g)\le x_i-x_j\le d+g)$，求最小的 $g$ 使得 $k\le \max(f_i)(1\le i\le n)$。

## 思路

因为 $g$ 越大，能取得的范围越大，所以 $\max(f_i)(1\le i\le n)$ 随着 $g$ 的增大只增不降，为找到的最小的 $\max(f_i)(1\le i\le n)$ 大于等于 $k$，那么可以使用二分答案来枚举 $g$ 的大小。

因为 $n\le 5\times 10^5$，考虑使用单调队列来优化。

但是需要重点考虑的是以下这种情况，感谢 [popossible 大佬](https://www.luogu.com.cn/user/579857) 指出：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ei6vngy.png)

枚举到第二个点时，如果我们立刻将它入队，因为它的值大于第一个点，所以会将第一个点弹出。但是当我们枚举到第三个点时，就会发现第二个点距离不够，但第一个点却被弹出了，此时第三个点无法更新，答案就是错误的。

$50$ 分错误示范如下：

```cpp
bool sol(int m){
	memset(f,-0x3f,sizeof(f)),f[0]=0;
	int res=0,l=1,r=0; q[++r]=0;
	for(int i=1;i<=n;i++){
		while(l<=r&&x[i]-x[q[l]]>d+m) l++;
		if(l<=r&&x[i]-x[q[l]]>=max(d-m,1LL)) f[i]=f[q[l]]+s[i];
		res=max(res,f[i]);
		while(l<=r&&f[q[r]]<=f[i]) r--;
		q[++r]=i;
	}
	return res>=k;
}
```

那如何解决呢？考虑设一个 $la$ 指针，在循环每个点时，将他前面距离大于最小限制的点入队，这样就可以完美的维护这个区间了，具体代码解释如下。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 500005
using namespace std;
int n,d,k,x[maxn],s[maxn],q[maxn],f[maxn];
bool sol(int m){
	memset(f,-0x3f,sizeof(f)),f[0]=0;
	int res=0,l=1,r=0,la=0;
	for(int i=1;i<=n;i++){
		while(la<i) if(x[i]-x[la]>=max(d-m,1LL)){ // 将前面达到最小距离的点入队。
			while(l<=r&&f[q[r]]<=f[la]) r--; // 维护单调递减的队列，保证答案在头上。
			q[++r]=la,la++;
		} else break;
		while(l<=r&&x[i]-x[q[l]]>d+m) l++; // 弹出超过最大距离的点。
		if(l<=r) f[i]=f[q[l]]+s[i]; // 更新答案。
		res=max(res,f[i]);
	}
	return res>=k;
}
signed main(){
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++) cin>>x[i]>>s[i];
	int l=0,r=x[n],ans=-1;
	while(l<=r){
		int m=(l+r)/2;
		if(sol(m)) ans=m,r=m-1;
		else l=m+1;
	}
	cout<<ans; return 0;
}
```

---

## 作者：DrDuck (赞：3)

### 前置芝士：动态规划、单调队列、二分答案 ###

读完题目，和我曾经做过的[这道题](https://www.luogu.com.cn/problem/P1725)很像，此次的优化方案也和这道题大同小异。

首先，如果格子内所有正数之和都比 $k$ 小，那么可以直接输出 `-1`。~~虽然直接输出-1一分也没。~~

让我们求至少要花多少金币，可以利用二分答案求，关键是 `check` 函数的设计。

记 $l = max(1, d - g)$，$r = d + g$， $f_i$ 为跳到第 $i$ 个格子能拿到的最大分数，假设机器人从点 $i$ 出发，能移动到的区间为 $[x_i + l, x_i + r]$，要最大化所经过的数字和。可以写出朴素的状态转移方程：
$$
f_i = s_i + max_{l \le x_j - x_i \le r, j < i}f_j
$$
光单次查询时间复杂度就来到了 $O(n^2)$，考虑优化。

我们不难发现，求 $max_{l \le x_j - x_i \le r, j < i}f_j$ 的过程相当于在一个区间内求最大值，又有 $x_i$ 单调递增，相当于一个滑动窗口，可以用单调队列解决。不过与 [P1725](https://www.luogu.com.cn/problem/P1725) 不同的是，此处格子的距离不等同于格子的下标，需要注意。

最后，再判断一下能获得最大总分数（不是 $f_n$，因为机器人可以随时停下来）和 $k$ 的大小，就把 `check` 函数写完啦！
# CODE #

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 5e+5 + 5;
const int inf = 1145141919810;
int n, d, k, ans, mxx, sum, head, tail;
int x[maxn], s[maxn], f[maxn], q[maxn], lst[maxn];
bool check(int mid)
{
    memset(f, -0x3f3f, sizeof(f));
    memset(q, 0, sizeof(q));
    head = tail = 0;
    int l = max(1ll, d - mid);
    int r = d + mid;
    int cnt = -inf;
    f[0] = 0;
    int lstin = 0;
    q[tail] = 0;
    tail++;
    for (int i = 1; i <= n; i++)
    {
        if (x[i] - l < 0)
        {
            continue;
        }
        for (; x[i] - x[lstin] >= l && lstin < i; lstin++)
        {
            while (head < tail && f[q[tail - 1]] <= f[lstin])
            {
                tail--;
            }
            q[tail] = lstin;
            tail++;
        }
        while (head < tail && x[q[head]] + r < x[i])
        {
            head++;
        }
        if (head < tail)
        {
            f[i] = f[q[head]] + s[i];
            cnt = max(cnt, f[i]);
        }
    }
    if (cnt >= k)
    {
        return true;
    }
    else
    {
        return false;
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> d >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> x[i] >> s[i];
        if (s[i] > 0)
        {
            sum += s[i];
        }
    }
    if (sum < k)
    {
        cout << -1;
        return 0;
    }
    int l = 0, r = max(x[n], d);
    while (l <= r)
    {
        int mid = (l + r) / 2;
        if (check(mid))
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    cout << ans;
    return 0;
}
```
拒绝抄袭！

---

## 作者：shuqiang (赞：3)

### 50pts

考虑 dp，观察到答案比较大，无法放到状态里，又发现答案具有单调性，也就是当答案越来越大时，得分是不降的，所以可以二分答案。

设 $f_i$ 为跳到第 $i$ 个格子能得到的最大得分，$d$ 是二分到的答案，依题意可得转移方程为 $f_i=\max{f_j}+s_i$，其中 $j$ 满足 $\max(g-d,1) \le x_i-x_j \le g+d$，时间复杂度 $\mathcal{O}(n^2 \log V)$，其中 $V$ 是 $x_i$ 的值域。


```cpp
#include<iostream>

using namespace std;
typedef long long ll; 

const int N = 5e5 + 10, inf = 1e9;
int n, d, k, x[N], s[N], l, r, ans = -1;
ll f[N], c;

int dis(int u, int v){
	return x[v] - x[u];
}

bool check(int x){
	for(int i = 1; i <= n; i++) f[i] = -inf; f[0] = 0;
	int l = max(d - x, 1), r = d + x; c = -inf;
	for(int i = 1; i <= n; i++){
		for(int j = 0; j < i; j++){
			if(dis(j, i) >= l && dis(j, i) <= r){
				f[i] = max(f[i], f[j] + s[i]);
				c = max(f[i], c);
			}
		}
	}
	return c >= k;
}

int main(){
	cin >> n >> d >> k;
	for(int i = 1; i <= n; i++) cin >> x[i] >> s[i];
	l = 0, r = 1e9;
	while(l <= r){
		int mid = (l + r) / 2;
		if(check(mid)){
			r = mid - 1;
			ans = mid;
		}
		else{
			l = mid + 1;
		}
	}
	cout << ans;
	return 0;
} 
```

### 100pts

考虑优化 dp，观察式子 $f_i=\max{f_j}+s_i$，发现我们只需要求出 $\max{f_j}$ 就可以求出 $f_i$，又因为 $j$ 满足 $\max(g-d,1) \le x_i-x_j \le g+d$，所以 $j$ 是在一个范围内的，且这个范围是一直往右的，所以可以使用[单调队列](https://www.luogu.com.cn/problem/P1886)维护，时间复杂度 $\mathcal{O}(n \log V)$，可以通过。

```cpp
#include<iostream>
#include<queue>

using namespace std;
typedef long long ll; 

const int N = 5e5 + 10; const ll inf = 1e18;
int n, d, k, x[N], s[N], l, r, ans = -1;
ll f[N], c; deque<int> q;

int dis(int u, int v){
	return x[v] - x[u];
}

bool check(int x){
	for(int i = 1; i <= n; i++) f[i] = -inf; f[0] = 0;
	int l = max(d - x, 1), r = d + x, j = 0; c = -inf;
	for(int i = 1; i <= n; i++){
		while(j <= n && dis(j, i) >= l){
			while(q.size() && f[q.back()] < f[j]) q.pop_back();
			q.push_back(j++);
		}
		while(q.size() && dis(q.front(), i) > r) q.pop_front();
		if(q.size()) f[i] = max(f[i], f[q.front()] + s[i]);
		c = max(c, f[i]);
	}
	return c >= k;
}

int main(){
	cin >> n >> d >> k;
	for(int i = 1; i <= n; i++) cin >> x[i] >> s[i];
	l = 0, r = 1e9;
	while(l <= r){
		int mid = (l + r) / 2;
		if(check(mid)){
			r = mid - 1;
			ans = mid;
		}
		else{
			l = mid + 1;
		}
	}
	cout << ans;
	return 0;
} 
```

---

## 作者：Barewalk (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3957)

### Solution

注意到，若花费变多，则弹跳距离的范围变大且包含原范围，因此最大得分关于花费单调不降。而题目要求最小花费使得最大得分不小于 $k$，故考虑二分答案。

这里有个小优化：若所有正权格子都取到，得分仍然小于 $k$，那么肯定无解。因此上界 $r$ 最大取到刚好可以走到所有正权格子，即 $\max(d-r,1)=minn$，$d+r=maxn$，其中 $minn$，$maxn$ 指最小和最大相邻正权格子距离，即 $r=\max(d-minn,maxn-d)$。

考虑 `check` 函数。容易想到 dp，用 $dp_i$ 表示以第 $i$ 个格子为结尾的最大得分，则转移方程为:

$$dp_i=\max\limits_{0\le j<i,\max(d-g,1)\le x_i-x_j\le d+g}\{dp_j\}+s_i$$

边界为 $dp_0=0$，即起点位置。

然而 dp 复杂度为 $O(n^2)$，过不了本题。我们发现，当 $i$ 右移时，决策区间也会整体右移，这满足单调队列优化 dp 的特征：决策取值范围上下界均单调变化，因此可以用单调队列优化成 $O(1)$ 转移，dp 复杂度优化成 $O(n)$，即可通过本题。

对于单调队列写法，注意维护队首合法性和队尾单调性，具体见注释。

注意本题要开 long long。

### Code

```cpp
#include<cstdio>
#include<queue>

#define SIZE 500100
#define ll long long

#define _rep(i,s,t) for(int i=s;i<=t;i++)
#define rep_(i,s,t) for(int i=s;i>=t;i--)

using namespace std;

int read(){
    int x=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        w=ch=='-'?-1:1,
        ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+ch-'0',
        ch=getchar();
    return x*w;
}

int n,d,k;
int x[SIZE],s[SIZE];

ll dp[SIZE];
int q[SIZE];

bool check(int mid){
    int l=max(d-mid,1),r=d+mid;
    int head=1,tail=0,p=0;
    //初始化单调队列，注意 head 等于 1 不等于 0 才表示队列为空
    //p 为决策区间上界
    dp[0]=0;
    _rep(i,1,n){
        while(p<i&&x[i]-x[p]>=l){
            //将候选集合插入队列
            while(head<=tail&&dp[p]>=dp[q[tail]])
                --tail;
                //维护队尾单调性
            q[++tail]=p++;
            //插入新决策
        }
        while(head<=tail&&x[i]-x[q[head]]>r)
            ++head;
            //排除队首过时决策
        if(head<=tail)
            dp[i]=dp[q[head]]+s[i];
            //实施决策
        else
            dp[i]=-2e18;
            //队列为空则该点无法走到
        if(dp[i]>=k)
            return 1;
    }
    return 0;
}

int main(){
    n=read(),d=read(),k=read();
    int maxn=0,minn=2e9,lst=0;
    _rep(i,1,n){
        x[i]=read(),s[i]=read();
        if(s[i]>0)
            maxn=max(maxn,x[i]-lst),
            minn=min(minn,x[i]-lst),
            lst=x[i];
    }
    int ans=-1;
    //二分模版
    int l=0,r=max(d-minn,maxn-d);
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid))
            ans=mid,
            r=mid-1;
        else
            l=mid+1;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：CaiZi (赞：3)

我们可以发现，使用的金币越多，跳跃范围就越大，且这个范围包含了使用的金币更少的跳跃范围。所以使用的金币越多，可以获得的分数就越多（或不变），这引导我们二分 $g$，其中 $g$ 的下界为 $0$，上界为 $\max x_i$。

然后我们确定了 $g$，需要判断在该情况下的最大得分是否大于等于 $k$。令 $x_0=0$，同时令 $f_{i}$ 表示到达第 $i$ 个格子的最大得分，那么有：
$$f_{i}=\max_{\max\{d-g,1\}\le x_i-x_j\le d+g}\{f_j\}+s_i$$
这个式子转移是 $O(n)$ 的，如果使用单调队列优化，可以均摊 $O(1)$ 转移。这题的单调队列优化比较麻烦，因为每次转移时不一定是右端点为 $i-1$ 的区间，因此需要额外维护一个指针，指向当前需要入队的节点，等到可以入队时再入队。其他地方与普通单调队列优化 DP 无异。

时间复杂度 $O(n\log V)$，其中 $V=\max x_i$。

记得开 `long long`。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,d,k,x[500001],y[500001],z,l,r,g,j,f[500001];
bool t;
deque<int>q;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		z=max(z,x[i]);
	}
	r=z;
	while(l<=r){
		g=l+r>>1;
		j=0;
		t=false;
		while(!q.empty()){
			q.pop_back();
		}
		for(int i=1;i<=n;i++){
			while(j<=i-1&&x[i]-x[j]>=max(d-g,1ll)){
				while(!q.empty()&&f[j]>=f[q.back()]){
					q.pop_back();
				}
				q.push_back(j);
				j++;
			}
			while(!q.empty()&&x[i]-x[q.front()]>=d+g+1){
				q.pop_front();
			}
			if(q.empty()){
				f[i]=LONG_LONG_MIN>>2;
			}
			else{
				f[i]=f[q.front()]+y[i];
				if(f[i]>=k){
					t=true;
					break;
				}
			}
		}
		if(t){
			r=g-1;
		}
		else{
			l=g+1;
		}
	}
	if(l==z+1){
		cout<<"-1";
	}
	else{
		cout<<r+1;
	}
	return 0;
}
```

---

## 作者：Aryper (赞：3)

跳房子

一开始的思路没有毛病，但在理解起点这个格子如何加入队列这一方面理解有误，结果死活 50pts ，我谔谔。

首先要想到的是**二分**，主要是查看 $g$ 的**可二分性**，**显然 $g$ 越大，可能得到的分数一定会越大**，所以 $g$ 是可以二分的。

我们把二分答案时的 $r$ 上调 1 ，如果最后的答案 $\ge r$ ，就说明**无解**。 

想到了二分 $g$ 的思路，我们来着手考虑如何**判定答案**的可行性。

如果我们知道了跳跃距离的范围，显然这玩意可以用动态规划解决啊。

定义状态 $f_i$ ，表示跳跃到第 $i$ 个格子的最大分数。

状态转移方程：

$$f_i=\max_{x_i-\max\{1,(d-g)\}\le x_j\le x_i-(d+g)}\{f_j\}+s_i$$

这个方法的时间复杂度是 $O(n^2\log x_n)$ 的，原地爆炸。

于是我们再仔细地盯一眼状态转移方程，做过单调队列优化 DP 都会发现，这个**转移方程可以用单调队列优化**。

这里我说一下自己对单调队列优化的理解。

单调队列优化 DP 基本上转移方程都是**在一个移动的区间取一个最值更新下一个状态**，这个区间就像单调队列模板题的**滑动窗口**一样，这个窗口所包含的数就是我们要取的数，从中找最大值，就是**单调队列的队首**。

这里的单调队列优化，我采用的方法是使用两个队列进行更新，这两个队列，一个是**单调递减队列**，一个是**待进入单调队列元素的队列**。

这两个队列的用处就是**保证单调队列内的值都是合法的值**。

比如下面这幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5z2w41vh.png)

我们的 $f_i$ 要在**红框**的状态中选一个**最大的数**来更新自己，可是 $f_i$ **前面还有一坨数**，这些数**在后面的状态转移时可能会用到**，所以我们**暂时不加入单调队列**，而是加入这个**待进入单调队列元素的队列**，等到后面这些个元素进入红框的范围内时再加入单调队列。

但我们需要注意的是起点的格子需要加入进去，我们**要把起点加入待进入单调队列元素的队列**，**而不是单调队列**，因为起点可能不在 $f_1$ 的红框里，而在后面的 $f_i$ 的红框里，不能贸然断定起点一定在 $f_1$ 的红框。

至此，我们完成了**状态转移**，只要存在 $f_i\ge k$ ，我们就可以判定 $g$ 是可行的。

单调队列优化后，时间复杂度 $O(n\log x_n)$ 。

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<vector>
#include<bitset>
using namespace std;

const int inf=2147483647;

int n,d,k,l,r,mid,edge;

int x[500005],s[500005],f[500005],q[500005],pos[500005],qq[500005];

bool check(int g) {
	int bot=max(d-g,1),top=d+g;
	for(int i=1;i<=n;i++) f[i]=-inf;
	int h=1,t=0,hh=1,tt=0;
	qq[++tt]=0;
	for(int i=1;i<=n;i++) {
		while(x[i]-x[qq[hh]]>top&&hh<=tt) hh++;
		while(x[i]-x[qq[hh]]>=bot&&x[i]-x[qq[hh]]<=top&&hh<=tt) {
			while(f[qq[hh]]>=q[t]&&h<=t) t--;
			q[++t]=f[qq[hh]];pos[t]=qq[hh];hh++;
		}
		while(x[i]-x[pos[h]]>top&&h<=t) h++;
		if(h<=t) {qq[++tt]=i;f[i]=max(f[i],q[h]+s[i]);if(f[i]>=k)return 1;}
	}
	return 0;
}

inline int read() {
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') {ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
	return ret*f;
}

void write(int x) {
	if(x<0) {putchar('-');x=-x;}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int main() {
	
	n=read();d=read();k=read();
	
	for(int i=1;i<=n;i++) {x[i]=read();s[i]=read();}
	
	r=x[n]+1;edge=r;
	while(l<r) {
		mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	
	if(l<edge) write(l);
	else printf("-1");
	
	return 0;
}
```

---

## 作者：luwanning (赞：2)

# 题目思路

---



直接讲 **100pts** 的做法。

这道题可以用**二分+动态规划**。

先说怎么二分。这道题要二分花费的金币数 $g$，左端点 $L$ 就是 $0$，右端点 $R$ 赋值为 $10^{9}$。

二分：

```
int L = 0, R = mx_int;
while (L + 1 < R) {
	int M = (L + R) >> 1;
	if (calc(M))
		R = M;
	else
		L = M;
}
```


---


重点就是怎么写 $\operatorname{calc}$ 函数。每次二分都会固定机器人向右跳的距离的范围:

-  下限 $l=\max(1,d-g)$ 
-  上限 $r=d+g$ 

这里先大致讲一下思路，详见代码。核心思想是~~我怎么都做不对的~~  **DP**。

状态：$dp_i$ 表示跳到第 $i$ 格得到的最大分数。

显然，转移方程就是 $dp_i=\max_{l\le{j}\le{r}}(dp_j)+s_i$。
直接枚举？时间复杂度为 $\operatorname{O}(n^2\hspace{1mm}\operatorname{log}\hspace{1mm}n)$。成功超时！要优化。

## 优化：

维护一个双端队列 $q$ 储存第 $i$ 格可以到达的格子。这样，队列 $q$ 的队首就是我们需要找的能使分数最大的点。
细节处理见代码。

下面就是 $\operatorname{calc}$ 函数：
```
bool calc(int g) {
	int l = max(1, d - g), r = d + g;
	ll ma = inf;
	memset(dp, 128, sizeof(dp));
	dp[0] = 0;
	while (!q.empty())
		q.pop_front();
	int j = 0;
	for (int i = 1; i <= n; i++) {
		for ( ; j < i && x[i] - x[j] >= l; j++)//枚举第i个格子前所有花费g个金币能达到的格子
			if (dp[j] > inf) {//dp[i]已被赋值
				while (!q.empty() && dp[q.back()] <= dp[j])//分数为负数的格子出队使最后分数最大
					q.pop_back();
				q.push_back(j);
			}
		while (!q.empty() && x[i] - x[q.front()] > r)//所有与第i个格子距离大于r的出队
			q.pop_front();
		if (!q.empty())
			dp[i] = 0LL + dp[q.front()] + s[i];
		ma = max(ma, dp[i]);
		if (ma >= k)//当前分数符合要求，直接退出
			return 1;
	}
	return 0;//所有分数均不大于k
}
```

---

### **完整代码**：

```
#include <cstdio>
#include <queue>
#include <cstring>

using namespace std;

typedef long long ll;

const int N = (int)5e5 + 1, mx_int = (int)1e9;
const ll inf = -9187201950435737472;
int n, d, k, x[N], s[N];
ll dp[N];
deque<int> q;

bool calc(int g) {
	int l = max(1, d - g), r = d + g;
	ll ma = inf;
	memset(dp, 128, sizeof(dp));
	dp[0] = 0;
	while (!q.empty())
		q.pop_front();
	int j = 0;
	for (int i = 1; i <= n; i++) {
		for ( ; j < i && x[i] - x[j] >= l; j++)
			if (dp[j] > inf) {
				while (!q.empty() && dp[q.back()] <= dp[j])
					q.pop_back();
				q.push_back(j);
			}
		while (!q.empty() && x[i] - x[q.front()] > r)
			q.pop_front();
		if (!q.empty())
			dp[i] = 0LL + dp[q.front()] + s[i];
		ma = max(ma, dp[i]);
		if (ma >= k)
			return 1;
	}
	return 0;
}

int main() {
	scanf("%d%d%d", &n, &d, &k);
	for (int i = 1; i <= n; i++)
		scanf("%d%d", &x[i], &s[i]);
	int L = 0, R = mx_int;
	while (L + 1 < R) {
		int M = (L + R) >> 1;
		if (calc(M))
			R = M;
		else
			L = M;
	}
	if (R >= mx_int)
		printf("-1\n");
	else
		printf("%d\n", R);
	return 0;
}
//时间复杂度为O(n log n)
```
 
此题完美解决！

---

## 作者：jinminghao (赞：2)

## 分析

我们不难发现，因为我们花越多的金币去改造机器人，获得的分数就越多，因此我们花的金币数所获得的分数具有单调性。

所以我们可以去二分我们花的金币数。

那么 check 函数里的问题就是：给你机器人能跳的距离范围，求机器人最多能获得多少分。

很明显，这个问题可以使用 DP 来求解：

设 $f_i$ 表示当机器人跳到第 $i$ 个格子时，能得到的分数最大值。

那么**状态转移方程**就是：

$f_i=\underset{j\in [\max(1,x_i - d - g),x_i + d + g]}{\max(f_j + s_i)}$

check 函数代码：

```cpp
bool check(int mid){
	memset(f,-INF,sizeof f);
	f[0]=0;
	for(int i=1;i<=n;i++){
		for(int j=i-1;j>=0;j--){
			if(w[i]-w[j]>=max(d-mid,1)&&w[i]-w[j]<=d+mid){
				f[i]=max(f[i],f[j]);
			}
		}
		f[i]+=a[i];
	}
	return f[n]>=k;
}
```

但是上面的代码加上主函数总时间复杂度是 $O( n^2 \times \log n )$，在本题的数据范围肯定会超时，于是考虑优化。

## 单调队列优化

我们可以发现，在求 $\underset{j\in [\max(1,x_i - d - g),x_i + d + g]}{\max(f_j + s_i)}$ 的时候实际上就是在求固定长度的区间最大值，于是可以使用[单调队列](http://oi-wiki.com/ds/monotonous-queue/)来维护。

这样总时间复杂度就降到了 $O( n \times \log n)$。

代码：

```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) (a>b?a:b)
using namespace std;
typedef long long LL;
const int N=5e5+10,INF=0x7f7f7f7f;
int w[N],a[N],n,d,k,hh,tt=-1;
LL f[N],q[N<<1];
bool check(int mid){
	memset(f,-INF,sizeof f);
	memset(q,0,sizeof q);
	f[0]=0;
	hh=0,tt=-1;
	int j=0;
	for(int i=1;i<=n;i++){	
		while(w[i]-w[j]>=max(d-mid,1)&&j<i){
			while(hh<=tt&&f[q[tt]]<f[j]) tt--;
			q[++tt]=j++;
		}
		while(hh<=tt&&w[i]-w[q[hh]]>d+mid) hh++;
		if(hh<=tt)f[i]=f[q[hh]]+(LL)a[i];
		if(f[i]>=k) return true;
	}
	return false;
}
int main(){
	scanf("%d%d%d",&n,&d,&k);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&w[i],&a[i]);
	}
	int l=0,r=1e9,ans=-1;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：sea_bird (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3957)。

老师、学长在讲 DP 的优化，同时我觉得题解区一些题解讲的不太清楚，因此来说一下个人的理解。

**如有不足，欢迎指出**。

## 什么是动态规划

> 动态规划是一种通过把原问题分解为相对简单的**子问题**的方式求解复杂问题的方法。划分出的每个子问题，通过一个公式，也就是**状态转移方程**联系起来，最后得到全局最优解。

# 题目分析

## 基本思路

根据题目的描述，发现**很难用贪心与搜索**实现，考虑用**动态规划**来实现，~~标签都说了~~。

一开始做的时候，对于金币的使用，我很是困惑，但是仔细想金币的作用，无非是**扩大了跳跃的范围**使机器人能够达到的范围更广，而求最小金币无非是枚举范围内的金币，看何时用最小金币满足条件（不一定要得到最高分数）。

## 暴力

虽然可以直接讲正解，但是还是讲讲暴力的做法来方便理解一下~~学长也是先让我们打暴力~~。

既然已经知道这是一道动态规划题目，写动态规划类的题目关键是**设出状态**，求出**状态转移方程**。

设 $f_i$ 为跳到第 $i$ 个点的最大分数。

状态设完，就是求出状态转移方程了，金币如何并不会直接影响到 $f_i$ 的值，影响到当前 $f_i$ 的值的因素仅仅是跳到上一个格子的值与当前第 $i$ 个格子 $s_i$ 的值，也就能得到状态转移方程 $f_i= \max {f_j}+s_i$（$f_i$ 为当前格子，$f_j$ 为上一个格子），而金币则是用来延长条约距离，获得能到达的更远的格子，那么求出最小的金币数直接枚举范围内的金币数即可，顺序枚举，看当前数量的金币是否能满足条件。当然**金币能延长的距离是有限的**，由于有枚举顺序，那么如果第 $j$ 格子与格子 $i$ 的距离大于最远能跳到的距离，那么之后的那些格子也跳不了，也就是求完了当前金币数量下所能跳到的格子，因此可以直接 `break;`。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+10;
ll n,d,k,l=0,r=N,mid;
//假设当前格子为i
ll f[N],x[N],s[N];//跳到第i个点的最大分数 第i个格子的距离 第i个格子的分数

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
bool find(int g){//查看金币是否能满足条件 
	memset(f,-N,sizeof(f));//初始化 由于可以为负数 
	f[0]=0;//一开始在0点 
	for(int i=1;i<=n;i++){
		for(int j=i-1;j>=0;j--){
			if(x[i]-x[j]>d+g){//如果超出范围
				break;//停止循环 
			}//优化
			 
			if(x[i]-x[j]<max(ll(1),(d-g))){//注意类型 不能直接写 1 
				continue; 
			}
			f[i]=max(f[i],f[j]+s[i]);//状态转移方程 
			if(f[i]>=k){//满足条件 
				return true;
			}	
		}
	}
	return false;
}
int main(){
	ll maxn=0;
	n=read(),d=read(),k=read();//快读输入
	for(int i=1;i<=n;i++){
		x[i]=read(),s[i]=read();
		maxn=max(maxn,x[i]);
	}
	ll g=2;//金币数从0开始枚举 
	while(g+d<maxn){//范围内 
		if(find(g)){
			cout<<g<<'\n'; 
			return 0;
		}
		g++;
	}
	cout<<-1<<endl;
	return 0; 
}
```

暴力代码大概只能过一半测试点，剩下的都超时了。

## 优化

作为 T4 肯定不会那么容易让你做出来的。刚刚的代码大概是 $O(n^2)$ 的时间复杂度，看数据范围 $n \le 10^5$，因此如果暴力做法会超时。

那么就是考虑优化了，看动态规划部分似乎没有什么可以改的了，那枚举金币的呢？

可以发现，由于金币数量是有序的，那么即可用二分查找来解决，对范围内的金币数进行二分查找，假如已经满足，将缩小金币数范围，减小金币数量，继续查找。假如还不能满足，则缩小金币数范围，增大金币数量使能到达的格子更多。

附上 AC 代码 ↓。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+10;
ll n,d,k,l=0,r=N,mid;
//假设当前格子为i
ll f[N],x[N],s[N];//跳到第i个点的最大分数 第i个格子的距离 第i个格子的分数

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
bool find(int g){//查看金币是否能满足条件 
	memset(f,-N,sizeof(f));//初始化 由于可以为负数 
	f[0]=0;//一开始在0点 
	for(int i=1;i<=n;i++){
		for(int j=i-1;j>=0;j--){
			if(x[i]-x[j]>d+g){//如果超出范围
				break;//停止循环
			}//优化
			 
			if(x[i]-x[j]<max(ll(1),(d-g))){//注意类型 不能直接写1 如果距离为负按1来算
				continue;
			}
			f[i]=max(f[i],f[j]+s[i]);//状态转移方程
			if(f[i]>=k){//满足条件
				return true;
			}	
		}
	}
	return false;
}
int main(){
	n=read(),d=read(),k=read();//快读输入
	for(int i=1;i<=n;i++){
		x[i]=read(),s[i]=read();
	}
		
	while(l<r){//由于是单调的序列可以使用二分
		mid=(l+r)>>1;//直接平均可能会溢出
		if(find(mid)){//看是否每个硬币都能做到
			r=mid;
		}
		else{//不能满足
			l=mid+1;//用更多金币尝试
		}
	}
	if(l==N){//无法满足分数
		cout<<-1;
	}
	else{//满足输出长度
		cout<<l;
	}	
	return 0;
}
```

---

## 作者：a202401006 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3957)
## 解析
### 题意：
每一次跳能过 $d$ 的距离，如果花一些金币，则可在一个范围内跳任意距离。希望得到 $k$ 分，求得花多少金币才能达到。
### 考点：
本题考查二分、动态规划、单调队列。
### 解析：
依题可得，如果付的钱越大,可跳跃的范围就越大。总结：能得的分数越多，跳得越远，所以可以通过二分前来判断能否得到目标的分，如果可以就减少，以达到最小；如果不行增加，直到到达目标的分。设置数据，然后用二分，接着进行以上操作。详见代码。
## 代码

```cpp
/*依题可得，如果付的钱越大,可跳跃的范围就越大。总结：能得的分数越多，跳得越远，所以可以通过二分前来判断能否得到目标的分，如果可以就减少，以达到最小；如果不行增加，直到到达目标的分。*/ 
#include<bits/stdc++.h>
using namespace std;
const long long bb=511500;
int n,d,k,left2=1,right2=1e10,sum=-1,x[bb],s[bb];
long long ls2[bb];/*数据见下，同时根据题目使用科学计数法,注意数据大小*/ 
inline bool check(int a)//inline用于加速 
{
    int left2=max(d-a,1),right2=d+a,j=0;
    memset(ls2,-10086100861,sizeof(ls2));/*初始化*/ 
	ls2[0]=0;
	deque<int> ls;/*给容器赋值，跟vector差不多*/ 
    for(int i=1;i<=n;i++)
    {
        while(x[j]+left2<=x[i])/*left2是左，x[j]表示前一格距离。x[i]是什么？见题目。*/ 
		{
			while(!ls.empty()&&ls2[ls.back()]<=ls2[j])/*如果ls不是空的，ls.back返回队列尾元素的值，但不删除该元素。表示当前能跳到最大的位置（其实就是ls2[ls]，只是这样会编译错误）小于*/ 
			{
				ls.pop_back();//尾部删除 
			}
			ls.push_back(j); //尾部插入 
			j++;//j要增加 
		}
        while(!ls.empty()&&x[ls.front()]+right2<x[i]) /*ls这一位不是空的。x是什么？见题目。right2是右*/ 
			ls.pop_front();//头部删除
        if(!ls.empty())//判断是否为空
			ls2[i]=ls2[ls.front()]+s[i];//ls2[i]表示分数，取队列的第一个数值，也就是取ls，但由于是数组，所以会编译错误，加上 
        if(ls2[i]>=k)//如果到达了希望得到的分，则返回，否则继续。 
			return 1;
    }
    return 0;
}

int main()
{
    scanf("%d%d%d",&n,&d,&k);
    for(int i=1;i<=n;i++)
    {
		scanf("%d%d",&x[i],&s[i]);/*输入*/ 
	}
    while(left2<=right2)/*left2是左，right22是右,运用二分*/ 
    {
	    int mid=(left2+right2)>>1;/*二分的mid,>>1是除以2*/ 
	    if(check(mid)) 
			sum=mid,right2=mid-1;/*详见一开始的注释*/ 
        else 
			left2=mid+1;/*详见一开始注释*/ 
    }
    printf("%lld",sum);//输出 
    return 0;
}

---

## 作者：yuantc (赞：2)

# 题目大意：
有 $n$ 个格子，每个格子有不同的距离和分数，每次可跳距离为 $d$，用 $g$ 金币后可跳距离范围可以变成 $[\max(d-g,1),d+g]$，求最小的 $g$，使得可跳跃得分不少于 $k$。

# 分析：
如果 $g$ 越大，可跳跃的范围就越大，理论上能得的分数越多，因此可以通过二分 $g$，来判断是否能得到 $k$ 分。如可以则继续减少 $g$，如果不行则增加 $g$。
# 80pts
```cpp
#include<bits/stdc++.h>
#define yuantc 500001
using namespace std;
typedef bool yuan;
typedef int tc;
typedef long long ll;
tc n,d,k,x[yuantc],s[yuantc];
ll f[yuantc];
yuan check(int a)
{
 int len=max(d-a,1),r=d+a; 
 memset(f,-0x3f,sizeof(f)),f[0]=0; 
 for(int i=1;i<=n;i++) 
 { 
    for(int j=i-1;j>=0;j--) 
	{ 
	    if(x[j]+len>x[i]) 
		    { 
			    continue; 
			} 
		if(x[j]+r<x[i]) 
		{ 
		    break; 
		} 	
			f[i]=max(f[i],f[j]+s[i]); 
			if(f[i]>= k) return true; 
	} 
 }  return false; 
}
int main()
{
    cin>>n>>d>>k;
    for(int i=1;i<=n;i++) cin>>x[i]>>s[i];
    int l=1,r=1e9,ans=-1;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid))ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout << ans;
    return 0;
}
```
如果数据增强，$O(n^2*logn)$ 是无法通过的，需要用单调队列优化。根据转移方程 $f[i]=max(f[j] + w[i])$ 可以通过单调队列得到 $i$ 之前有效范围内的最大 $f[j]$。 
# 100pts

```cpp
#include <bits/stdc++.h>
#define yuantc 511451
using namespace std;
typedef long long yuan;
typedef bool ok;
int n, d, k;
int x[yuantc], s[yuantc];
yuan f[yuantc];
ok check(int a)
{
    int l=max(d-a,1),r=d+a,j=0;
    memset(f,-0x3f,sizeof(f)),f[0]=0;
	deque<int> q;
    for(int i=1;i<=n;i++)
    {
        while(x[j]+l<=x[i]){ while(!q.empty()&&f[q.back()]<=f[j])q.pop_back(); q.push_back(j); j++; }
        while(!q.empty() && x[q.front()] + r < x[i]) q.pop_front();
        if(!q.empty()) f[i] = f[q.front()] + s[i];
        if(f[i] >= k) return true;
    }
    return false;
}

int main()
{
    cin >> n >> d >> k;
    for(int i = 1; i <= n; i++) cin >> x[i] >> s[i];
    int l = 1, r = 1e9, ans = -1;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(check(mid)) ans = mid, r = mid - 1;
        else l=mid + 1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：chrispang (赞：2)

### 题目大意

- 直线的正方向上有 $n$ 个点，他们到原点的距离为 $x_i$，第 $i$ 个点有一个权值 $s_i$。**权值可能为负**。
- 从原点开始向右跳。假设原点为第 $0$ 个点，每次能跳到 $[s_i+d−g,s_i+d+g]$ 中**在第 $i$ 个点右边**的任意一个点，并获得对应的权值。
- 给定 $d,k$ 现在想要在获得的权值之和大于等于 $k$ 的前提下，最小化 $g$。
- $1\le n\le 500000,1\le d\le 2000,1\le x_i,k\le 10^9,|s_i|\le 10^5$。

### 题目思路

貌似与[这道题](https://www.luogu.com.cn/problem/P2678)差不多，都需要用到二分答案，不过在 `check` 函数上有改变。

----

先说如何二分答案。二分左边界很好想，就是不用金币，即为 $0$。而右边界设成最大值 $10^9$ 就好了。

而`check`函数怎么写呢？我们如果使用贪心会错，因此使用`DP`：

1. 状态：定义一个一维数组 `f`，`f[i]` 表示从第 $i$ 个格子向右跳能获得的最大分值。
2. 状态转移方程：考虑从后往前推，我们的`f[i]` 需要跳到后面的某个`f[j]`，而到底需要跳到哪个`f[j]`呢？ 这里就可以直接暴力枚举了（其实是我不会单调队列优化），还需要注意 $j$ 的距离是要求在范围之内的，因此可得 `f[i] = max(f[j] + a[i].s)`
3. 初始化：可以不与后面的进行连接，`f[i] = a[i].s`
4. 答案：由于我们要求从起点 $0$ 出发之后的最大分值，所以答案为 `f[0]`。

如果答案的分值 $\ge k$，则说明成功了，记录答案，去找更小的答案；否则只能去找更大的答案。

上代码：

```cpp
#include <bits/stdc++.h>
#define maxn 500010
#define int long long //不开long long见祖宗
using namespace std;

int n, d, k, f[maxn];
struct node {
	int x, s;
}a[maxn];

bool check(int x) {
	for (int i = n; i >= 0; i--) { //注意要枚举到0
		f[i] = a[i].s; //初始化
		for (int j = i + 1; a[j].x - a[i].x <= d + x && j <= n; j++) //不能越界
			if(a[j].x - a[i].x >= d - x && f[j] + a[i].s > f[i]) f[i] = f[j] + a[i].s; //如果能更新则更新
	}
	return f[0] >= k; //答案如果满足条件
}

signed main() {
	scanf("%lld%lld%lld", &n, &d, &k);
	for (int i = 1; i <= n; i++)
		scanf("%lld%lld", &a[i].x, &a[i].s);
	int l = 0, r = 1000000000, ans = 1000000000; //初始化
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) ans = mid, r = mid - 1; //找到答案，记录答案，缩小r
		else l = mid + 1; //否则放大l
	}
	if(ans != 1000000000) printf("%lld\n", ans); //如果找到了答案，则输出答案
	else puts("-1"); //否则输出-1
	return 0;
}
```

可惜只能拿 $50$ 分...

----

那么如何优化呢？`check`函数的部分肯定是不能再优化了（都说了不会单调队列优化），所以只能在二分上下手了。

有人表示二分有啥好下手呢？$\log_2 (5\times10^{10})$ 最多就为 $35$，进行优化也就是个常数级别的优化，有啥用。

其实有的时候常数是能决定很多事情的，就比如这道题。我们其实可以考虑缩短二分边界进行常熟优化。

但左边界是不可能改动的了（毕竟有的时候不需要花费金币），所以只能在右边界上进行改动了。

观察样例，我们可以发现，我们其实可以只选出分值为正整数的数，求出这些数中相隔最远的**距离值**，就作为我们的右边界。举个例子：

```cpp
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2
```

其中分值为正整数的有：

```cpp
2 6
10 3
13 1
17 6
20 2
```

那么其中相隔最远的**距离值**为 $10-2=8$，所以二分边界为 $8$，根本不需要什么 $10^9$。

还需要注意一个点，如果其中所有为正整数的**分值**的和 $<k$，则输出 $-1$（虽说此题根本没有 $-1$ 这种情况）。

上代码：

```cpp
#include <bits/stdc++.h>
#define maxn 500010
#define int long long //不开long long见祖宗 
using namespace std;

int n, d, k, sum, f[maxn];
int l = 0, r, ans = 1000000000;
struct node {
	int x, s;
}a[maxn];

bool check(int x) {
	for (int i = n; i >= 0; i--) { //注意要枚举到0
		f[i] = a[i].s; //初始化
		for (int j = i + 1; a[j].x - a[i].x <= d + x && j <= n; j++) //不能越界
			if(a[j].x - a[i].x >= d - x && f[j] + a[i].s > f[i]) f[i] = f[j] + a[i].s; //如果能更新则更新
	}
	return f[0] >= k; //答案如果满足条件
}

signed main() {
	scanf("%lld%lld%lld", &n, &d, &k);
	for (int i = 1, last = 0; i <= n; i++) {
		scanf("%lld%lld", &a[i].x, &a[i].s);
		if(a[i].s > 0) sum += a[i].s, r = max(a[i].x - last, r), last = a[i].x; //记录两个正整数分值之间的距离值的距离（伦敦大雾），取其中最大的 
	}
	if(sum < k) { //如果所有正整数的分值的和<k，说明没有方法 
		puts("-1");
		return 0;
	}
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) ans = mid, r = mid - 1; //找到答案，记录答案，缩小r
		else l = mid + 1; //否则放大l
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Elma_ (赞：2)

> [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)

首先可以很明显地看出来灵活性 $g$ 满足单调性，因此可以去二分这个 $g$，然后 check 的时候用 dp 判断。

考虑如何 dp。设 $f_i$ 为跳到第 $i$ 个格子时的最大得分，根据定义推出状态转移方程为：
$$f_i = \max_{0 \leq j < i}\{f_j\} + s_i$$

其中 $j$ 还需满足 $\max\{1,d-g\}\leq x_i-x_j \leq d+g$。每转移完一个状态就立刻判断是否满足要求，这样比全部转移完再去判断 $f_n$ 是否满足要求更节省时间。

但是上面的 dp 若不加任何优化的话时间复杂度为 $O(n^2)$，显然无法通过此题。考虑如何优化这个 dp。

观察上面 dp 转移式中 $j$ 需满足的条件，会发现，显然对于每一个 $i$，$j$ 的取值范围都是一个区间。有着丰富经验的选手应该可以一眼看出，随着 $i$ 不断变大，这个区间的 $l,r$ 也是不断递增的，于是我们就可以用单调队列来优化这个 dp 了。

优化后每次 dp 的时间复杂度为 $O(n)$，加上二分的复杂度，总时间复杂度为 $O(n\log x_n)$，足以通过此题。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
#define maxn 500005
using namespace std;

inline int read()
{
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}

int n, d, k, l, r, tmp;
int x[maxn], s[maxn], q[maxn];ll f[maxn];

inline bool check(int g)
{
	int mind = max(1, d - g), maxd = d + g;
	int l = 0, r = -1, head = 1, tail = 0;
	for (int i = 1;i <= n;i++)
	{
		f[i] = -2e18;
		while (r + 1 < i && x[i] - x[r + 1] >= mind)
		{
			while (head <= tail && f[q[tail]] <= f[r + 1]) tail--;
			q[++tail] = ++r;
		}
		while (head <= tail && x[i] - x[q[head]] > maxd) head++;
		if (head <= tail) f[i] = f[q[head]] + s[i];
		if (f[i] >= k) return true;
	}
	return false;
}

int main(void)
{
	n = read(), d = read(), k = read();
	for (int i = 1;i <= n;i++)
		x[i] = read(), s[i] = read();
    r = x[n] + 1, tmp = r;
	while (l <= r)
	{
		int mid = (l + r) >> 1;
		if (check(mid)) r = mid - 1;
		else l = mid + 1;
	}
	printf("%d\n", l >= tmp ? -1 : l);
	return 0;
}
```


---

## 作者：qhr2023 (赞：1)

## solution

二分加单调队列优化 dp。

答案有单调性，用二分。

对于检查当前 $g$ 值是否合法，即求此时的最大分数，这是一个简单的线性 dp，设 $f_i$ 表示跳到第 $i$ 格子的最大分数，在题目规定的范围内枚举 $j$，易得转移 $f_i=\max(f_j)+s_i$。

这个复杂度似乎最坏 $O(n^2 \log n)$，实际上和 $d$ 有关，当 $d$ 很小时，枚举 $j$ 范围会变小，所以可以通过 $n \le 500$ 和 $d=1$ 的部分，拿到 80 分。

考虑优化 dp。发现我们枚举的 $j$ 的范围也是单调的，就是从左到右求 $f_i$ 时，对应的 $j$ 的范围也在从左往右移，那么实际上我们要求的是一个单调区间最大值问题，这是经典的 $m$ 区间最值[问题](https://www.luogu.com.cn/problem/P1886)，用单调队列解决。

单调队列优化的过程一般如下。

* 加入所需元素：向单调队列重复加入元素直到当前元素达到所求区间的右边界，这样就能保证所需元素都在单调队列中。
* 弹出越界队首：单调队列本质上是维护的是所有已插入元素的最值，但我们想要的往往是一个区间最值。于是我们弹出在左边界外的元素，以保证单调队列中的元素都在所求区间中。
* 获取最值：直接取队首作为答案即可。

每个元素只会入队一次，所以单调队列是线性的，总复杂度 $O(n \log n)$。

## code

不加单调队列优化的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+5;
long long n, d, k, x[N], s[N], f[N], ans=-1;
bool check (long long g) {
	memset(f, -0x3f, sizeof f);
	f[0]=0;
	for (int i=1; i<=n; f[i]+=s[i], ++i) 
		for (int j=i-1; j>=0; --j) {
			if (x[i]-x[j]<max(d-g, 1ll))
				continue;
			if (x[i]-x[j]>d+g) 
				break;
			f[i]=max(f[i], f[j]);
			if (f[i]>=k) 
				return 1;
		}
	return 0;
}
int main () {
	cin >> n >> d >> k;
	for (int i=1; i<=n; ++i)
		cin >> x[i] >> s[i];
	long long l=0, r=1e15, mid;
	while (l<=r) {
		mid=(l+r)>>1;
		if (check(mid))
			r=mid-1, 
			ans=mid;
		else
			l=mid+1;
	}
	cout << ans;
	return 0;
}
```


加上单调队列优化的代码。

```
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+5;
long long n, d, k, x[N], s[N], f[N], q[N], ans=-1;
bool check (long long g) {
	memset(f, -0x3f, sizeof f);
	memset(q, 0, sizeof q);
	f[0]=0;
    for (int i=1, hd=1, tl=0, j=0; i<=n; ++i) {  
    	for ( ; x[i]-x[j]>=max(d-g, 1ll)&&j<i; ++j)
    		if (f[j]>-0x3f3f3f3f) {
    			while (f[q[tl]]<=f[j]&&hd<=tl) tl--;
    			q[++tl]=j;
			}
    	while (x[i]-x[q[hd]]>d+g&&hd<=tl) hd++;
    	if (hd<=tl) f[i]=f[q[hd]]+s[i];
    	if (f[i]>=k) return 1;
	}
	return 0;
}
int main () {
	cin >> n >> d >> k;
	for (int i=1; i<=n; ++i)
		cin >> x[i] >> s[i];
	long long l=0, r=1e15, mid;
	while (l<=r) {
		mid=(l+r)>>1;
		if (check(mid))
			r=mid-1, 
			ans=mid;
		else
			l=mid+1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：LeavingAC (赞：1)

**begin**

[P3957 [NOIP 2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)

# 前言

本文包含卡常小技巧和正解，可放心食用。

# 思路

这个题二分和 dp 的思路应该是挺明显的。

我们令 $dp_i$ 为跳到第 $i$ 个格子的最大分数。

我们假定通过 $g$ 个金币的改造，机器人能从 $j$ 跳到 $i$，那么不难想出：

$$dp_i=\max(dp_i,dp_j+s_i) $$

由此我们便得到了 Code 1.0 版本（[AC 1\~5，TLE 6\~10](https://www.luogu.com.cn/record/204226461)）。

时间复杂度：$O(n^2\log n)$

# Code 1.0

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
struct node
{
    ll x,s;
}a[500010];
ll n,d,k,dp[500010],l,r,mid,ans;
bool check(ll g)
{
	for (ll i=1;i<=n;i++) dp[i]=-1e10;
	for (ll i=1;i<=n;i++)
    {
		for (ll j=0;j<i;j++)
        {
			if (a[i].x-a[j].x>d+g)
            {
                continue;
            }
			if (a[i].x-a[j].x<max(d-g,1LL))
            {
                break;
            }
			dp[i]=max(dp[i],dp[j]+a[i].s);
            if (dp[i]>=k) return 1; // 省掉多余的循环，缩短时间。
		}
	}
    return 0;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>d>>k;
    for (ll i=1;i<=n;i++) cin>>a[i].x>>a[i].s;
    l=0,r=1e6,ans=-1;
    while (l<=r)
    {
        mid=(l+r)>>1;
        if (check(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else
        {
            l=mid+1;
        }
    }
    cout<<ans;
	return 0;
}
```

### 卡常小技巧（选修）
---
我们充分发扬人类的智慧：

我们知道 `break` 是一个卡常的好东西。我们通过读题可知（可知=可以感知）到超出 $d+g$ 可能比超出 $\max(d-g,1)$ 的可能性更大。

所以，我们可以将代码的 check 部分改成这样：

#### Code 1.14514

```cpp
bool check(ll g)
{
	for (ll i=1;i<=n;i++) dp[i]=-1e10;
	dp[0]=0;
	for (ll i=1;i<=n;i++)
    {
		for (ll j=i-1;j>=0;j--) // 倒着枚举
        {
			if (a[i].x-a[j].x>d+g)
            {
                break;
            }
			if (a[i].x-a[j].x<max(d-g,1LL))
            {
                continue;
            }
			dp[i]=max(dp[i],dp[j]+a[i].s);
            if (dp[i]>=k) return 1;
		}
	}
    return 0;
}
```

这样一来，快到起飞，[仅用时 200ms](https://www.luogu.com.cn/record/204222500)！！

# 优化

ok，不整活了，接下来想想正解。

如果我们想让用的金币尽可能少，那么我们的得分就要尽可能高，也就是 $dp_i$ 尽可能大，那么对应的 $dp_j$ 也要尽可能大，也就是求 $\max(d-g,1) \sim d+g$ 区间的最大 $dp_j$，但是时间还不能超。

那么我们可以想到有一个东西完美符合所有的条件，那就是~~标签中的~~——单调队列！

由此，我们的 dp 就从二维优化到了线性的。

总时间复杂度：$O(n \log n)$

那么接下来，有请：

# Code.END

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc() getchar()
#define pc(a) putchar(a)
#define sqrt(a) __builtin_sqrt(a)
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) a/__gcd(a,b)*b
#define y1 fuck_cmath
using namespace std;
const int M=5e5+10;
ll n,d,k,x[M],s[M],dp[M],q[M],l,r,mid,ans=-1;
bool check(ll g)
{
    ll j=0,head=1,tail=0;
    for (ll i=1;i<=n;i++) dp[i]=-1e10;
    for (ll i=1;i<=n;i++)
    {
        while (j<i && x[i]-x[j]>=max(1LL,d-g))
        {
            while (head<=tail && dp[q[tail]]<=dp[j]) tail--; // 弹队尾
            q[++tail]=j++; // 进队尾
        }
        while (head<=tail && x[i]-x[q[head]]>d+g) head++; // 弹队首
        if (head<=tail) dp[i]=dp[q[head]]+s[i]; // 取队首
        if (dp[i]>=k) return 1;
    }
    return 0;
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>d>>k;
    for (ll i=1;i<=n;i++) cin>>x[i]>>s[i];
    l=0,r=M;
    while (l<=r)
    {
        mid=(l+r)>>1;
        if (check(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    cout<<ans;
    return 0;
}
```

~~不要问马蜂为什么不一样，因为没加优化的代码是之前写的。~~

**end**

---

## 作者：Jerrycyx (赞：1)

### 前言

和[\[NOIP2005 提高组\] 过河](https://www.luogu.com.cn/problem/P1052)有点像，也许能够启发一些思路。

最开始以为没有格子的位置也能跳，实际上每次只能从一个格子跳到另一个格子，不能踩空。

Update: 修改了部分错别字和笔误；根据评论添加了一处注意事项；为代码加上了注释.

-----

### 思路 & 解析

#### 二分

问题答案具有二段性：设所需最少金币为 $g_0$，若金币数量 $g<g_0$，则在最优策略下所得分数一定小于 $k$；若金币数量 $g>g_0$，则在最优策略下所得分数一定大于等于 $k$。故可以**二分答案**求解，二分的条件判断便是**对于某个 $g$，得到最优策略下所得分数**。

#### 动态规划

这是一个经典的**动态规划**问题。设 $f_i$ 表示走到第 $i$ 个格子的最大得分，那么显然有：

$$f_i = s_i + \max_{a_j \in [a_i-d-g,a_i-d+g]} f_{j}$$

总时间复杂度 $O(n^2 \log n)$，可得 $50$ 分，我们需要优化。

#### 单调队列

显然，使 $a_j \in [a_i-d-g,a_i-d+g]$ 成立的 $j$ 一定是连续的，设它的范围是 $[l,r]$。当 $i$ 不断增加，即 $a_i$ 单调不减的时候，$a_i-d-g,a_i-d+g$ 也单调不减，$l,r$ 自然同样单调不减。

在一个 $l,r$ 均单调不减的区间 $[l,r]$ 上找最小值，可以用**单调队列**维护（参考例题：[滑动窗口](https://www.luogu.com.cn/problem/P1886)）。使单调队列内元素单调递减，每次 $i$ 右移的时候，在其中加入新的 $a_j \le a_i-d+g$ 的 $j$（可能不止一个）；然后弹出 $a_j < a_i-d-g$ 的 $j$，最后队首元素即为所求的 $\max f_j$。

**上面两种操作顺序不能改变**，因为可能出现新加入的 $j$ 不合法的情况（满足 $a_j \le a_i-d+g$ 却不满足 $a_j \ge a_i-d-g$），这样加入后无法立即弹出，非法的答案就进入到队列当中了。这也解答了[这个帖子](https://www.luogu.com.cn/discuss/1008697)中提出的问题。

时间复杂度 $O(n \log n)$，可以[通过](https://www.luogu.com.cn/record/199034919)。

-----

### 代码 & 细节

这道题细节还是蛮多的，在这里列出：

+ 答案最小为 $0$，此时一步都不跳就结束游戏；
+ 计算边界应取 $a_i - \max\{d-g,1\}$，因为不能向后跳；
+ 上面已经提到过的，单调队列压入和弹出的顺序不可改变；
+ 更新答案时需要判断点是否可达，即判断此时队列是否为空；
+ 注意 $f$ 及其相关变量需要开 `long long`；
+ 二分右端点应为 $10^9$，此时每一步可以跳到任意点。
+ $f$ 初始化如果赋值太小（如 `LLONG_MIN`）可能会 WA，因为优先队列中可能存在不可达点（正常情况下不影响答案计算），但是在更新 $f_i$ 的时候，对应值极小的队首若再加上负的 $s_i$ 就可能爆范围。

  解决方法：将 $f$ 初始值设大一点（如 $-10^{18}$），或在入队时额外判断该点是否可达（[参考代码](https://www.luogu.com.cn/record/199349391)）。

[代码](https://www.luogu.com.cn/record/199350404)（变量名与题目描述略有不同，具体请对照代码输入部分和题目输入格式）：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;

const int N=5e5+5,X=1e9;
const LL INF=1e18;
int n,d,p;
int a[N],b[N];

LL f[N];
int q[N],head,tail;
bool check(int flex)
{
	for(int i=head;i<=tail;i++)
		q[i]=0;
	head=1,tail=0; //清空队列
	fill(f+1,f+n+1,-INF); //初始化f
	LL pts=f[0]=0;
	int pos=0; //当前加到了哪个点
	for(int i=1;i<=n;i++)
	{
		//队列注意随时判空
		while(a[i]-a[pos]>=max(d-flex,1)) //加点
		{
			while(head<=tail && f[q[tail]]<=f[pos])
				q[tail--]=0;
			q[++tail]=pos;
			//以上三行可添加判断f[pos]不是负无穷的条件
			//以避免f初值过小而导致下方加负数而越界
			pos++;
		}
		while(head<=tail && a[q[head]]+d+flex<a[i]) //删点
			q[head++]=0;
		if(head<=tail) f[i]=b[i]+f[q[head]];
		pts=max(pts,f[i]);
	}
	return pts>=p;
}

int main()
{
	scanf("%d%d%d",&n,&d,&p);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]);
	int l=-1,r=X+1;
	while(l+1<r)
	{
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid;
	}
	printf("%d\n",r>X?-1:r);
	return 0;
}
```

---

## 作者：kind_Ygg (赞：1)

# 题解：P3957 [NOIP2017 普及组] 跳房子
谁能告诉我为什么当年普及组会出现 dp 优化的题目。
## 题目大意
个人认为题目已经解释地很清楚啦，只是要注意，可以在任意格子上停下，所以最后要对 dp 数组取 $\max$ 统计。
## 思路
很明显，这是一道单调队列优化 dp 的好题，我们在用二分去寻找最小满足条件的 $g$，初步统计时间复杂度为 $O(n \log x_n)$。

其次，定义 $dp_i$ 为前 $i$ 个格子可以获取的最大分值。

然后，题目中有一点和其他题不一样的是，单调队列的区间并不是 $[i-\max(2g,g+d),i-1]$，而可能为 $[i-g-d,i-g+d]$，所以还要开一个普通队列 $q$，其中保存的是在目前区间后面的点。
## Code

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=5e5+5;
int n,d,k;
int dp[N];
struct node
{
	int x,s;
}sqa[N];
deque<int> dq;
queue<int> q;
int maxnlen=-1;
bool solve(int g)
{
	int maxn=LLONG_MIN;
	while(dq.size()) dq.pop_front();
	while(q.size()) q.pop();
	memset(dp,0,sizeof dp);
	q.push(0);
	for(int i=1;i<=n;i++)
	{
		int l,r;
		if(g<d)
			l=sqa[i].x-(d+g),r=sqa[i].x-(d-g);
		else l=sqa[i].x-(d+g),r=sqa[i].x-1;
		while(dq.size() and sqa[dq.front()].x<l)
			dq.pop_front();
		while(q.size() and sqa[q.front()].x<l) q.pop();
		while(q.size() and sqa[q.front()].x<=r)
		{
			int now=q.front();
			q.pop();
			while(dq.size() and dp[dq.back()]<dp[now])
				dq.pop_back();
			dq.push_back(now);
		}
		if(dq.size())
		{
			dp[i]=dp[dq.front()]+sqa[i].s;
			q.push(i);
		}
		else dp[i]=LLONG_MIN;
		maxn=max(maxn,dp[i]);
	}
	if(maxn>=k)
		return 1;
	return 0;
}
signed main()
{
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++)
		cin>>sqa[i].x>>sqa[i].s;
	int l=0,r=sqa[n].x+1;
	while(l+1<r)
	{
		int mid=r+l>>1;
		if(solve(mid))
			r=mid;
		else 
			l=mid;
	}
	if(r==sqa[n].x+1) cout<<-1;
	else cout<<r;
	return 0;
}
```
## 注意
本题有许多细节，建议大家自己去寻找调试，能有效提升自己的代码能力。

---

## 作者：lusq (赞：1)

# [P3957 [NOIP2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)

## 思路

题目大意：给出所有格子的得分、机器人弹跳距离 $d$ 和最小得分 $k$，找到最小的 $g$，使得机器人从起点开始往右跳若干次 $[\max \{1,d - g \},d + g]$ 中任意距离，且所有跳到格子的得分和达到 $k$。

特判 $-1$ 比较简单，因为只要 $g$ 足够大，你就可以只跳所有分数是正数的格子，这样获得的得分是最大的。所以，如果所有分数是正数的格子分数之和还没有达到 $k$，那么总得分一定无法达到 $k$；反之，如果所有分数是正数的格子分数之和达到 $k$，那么一定存在一种方法使得总得分达到 $k$。

显然，当 $g$ 增加时，我们完全可以按照 $g$ 增加之前的方式跳，因此当 $g$ 增加时，可以获得的最大得分只增不减。

因此，我们可以用二分找到最小的 $g$。

同样显然，当 $g \ge d$ 并且 $d + g \ge x_n$ 的时候，跳一次便可以到达所有格子，此时再增加 $g$ 已经没有效果，因此 $g$ 最大值便是 $\max \{d,x_n-d \}$。

接下来就是判断对于每个 $g$，获得的最大得分有没有达到 $k$。

考虑使用 DP，设 $dp_i$ 表示从起点到达第 $i$ 个点所得分数的最大值。

我们可以存下来所有可以跳一步到达当前格子的格子，然后求最大分数，并加上当前格子的分数，就是当前格子的最大分数。

但是，当 $g$ 特别大时，几乎所有前面的格都可以到达当前格子，那么计算最大值就会特别慢。

于是，我们需要使用单调队列来优化代码。

很明显，如果存在 $i , j$ 两个格子都可以到达当前格子，并且满足 $i < j , dp_i \le dp_j$ 那么第 $i$ 个格子就不需要了。因为当前格子以及后面的格子，如果能由第 $i$ 个格子一步跳到，就一定能由第 $j$ 个格子一步跳到，但是由 $i$ 跳到一定不会比由 $j$ 跳到更优。

如果用了单调队列，你会发现队列里的格子对应的 $dp$ 值是单调下降的，所以我们只需要取队头来计算当前格子的 $dp$ 值，也就是最大得分。

这样，我们就能算出对于每个 $g$ 获得的最大得分，对 $k$ 进行比较便可。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,d,k,num,x[500005],s[500005],dp[500005];
bool check(int g){
	deque<int>q;
	memset(dp,-0x7f,sizeof(dp));
	int l=max((int)1,d-g),r=d+g;
	int w=0;//待入队格子下标
	for(int i=0;i<n;i++){//从起点跳第一步
		if(x[i]>r){
			break;
		}else if(x[i]<l){
			continue;
		}else{
			dp[i]=s[i];
		}
	}
	for(int i=0;i<n;i++){
		while(!q.empty() && x[q.front()]<x[i]-r){
			q.pop_front();//队头已经到不了当前格子，就出队
		}
		while(x[w]<=x[i]-l){//将能跳到当前格子的格子入队
			w++;
			if(dp[w-1]==-0x7f7f7f7f){
				continue;
			}
			if(x[w-1]<x[i]-r){
				continue;
			}
			while(q.size() && dp[q.back()]<=dp[w-1]){
				q.pop_back();//前面的格子不会比后面的更优，就出队
			}
			q.push_back(w-1);
		}
		if(!q.empty()){
			dp[i]=max(dp[i],dp[q.front()]+s[i]);
			if(dp[i]>=k){
				return 1;
			}
		}
	}
	return 0;
}
void main1(){
	cin>>n>>d>>k;
	for(int i=0;i<n;i++){
		cin>>x[i]>>s[i];
		if(s[i]>0){
			num+=s[i];//计算所有正数得分之和
		}
	}
	if(num<k){//正数得分之和没有达到 k
		cout<<-1;
		return;
	}
	int l=0,r=max(d,x[n-1]-d),mid;
	while(l<=r){//二分答案
		mid=(l+r)/2;
		if(check(mid)){
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	cout<<l;
	return;
}
signed main(){
	int t=1;
	//cin>>t;
	while(t--){
		main1();
	}
	return 0;
}
```

## 时间复杂度分析

二分的时间复杂度是 $\mathcal{O}(\log_2 n)$ 的，重点就是 $check()$ 函数。

对于每个格子，都最多会入队一次，也最多会出队一次，同样只会计算一次最大分数，因此 $check()$ 函数的时间复杂度是 $\mathcal{O}(n)$。

整个算法的时间复杂度为 $\mathcal{O}(n \log_2 n)$。

---

## 作者：CommandSR (赞：0)

## 题意简述

给定 $n$ 个格子，机器人从起点出发，每次向右跳跃 $1$ 到 $d+g$ 的距离（$d$ 为给定常数，$g$ 为改造金币数），经过的格子分数和需至少为 $k$。求最小的 $g$，若无法达到输出 $-1$。

## 基本思路

### Part1 二分答案

注意到所花的金币越多，能够获得的分数也就越大，满足单调性。

不难想到二分答案。

接下来的问题转化为 check 函数中给定所花的金币数，即确定了跳的区间为 $[d-g, d+g]$，求最大得分是否大于等于 $k$。

### Part2 朴素 DP

令 $f_i$ 为跳到第 $i$ 个房子的最大得分，则可以得出状态转移方程：

```cpp
if (a[i].x - a[j].x >= d-x && a[i].x - a[j].x <= d+x)
{
    f[i] = max(f[i], f[j] + a[i].y);
}
// a[i].y 为当前格子得分
```


不难得出如下代码：

```cpp
bool check(int x) {
	F(i, 0, N-2) f[i] = -inf;
	f[0] = 0;
	int mx = 0;
	F(i, 1, n) {
		F(j, 0, i-1) {
			if (a[i].x - a[j].x >= d-x && a[i].x - a[j].x <= d+x)
				f[i] = max(f[i], f[j] + a[i].y);
		}
		mx = max(mx, f[i]);
	}
	return mx >= k;
}
```

### Part3 单调队列优化

上述 dp 时间复杂度为 $O(n^2)$，考虑优化。

注意到 $f_i$ 由一个固定区间 $d-x \le x_i-x_j \le d+x$ 内的所有 $f_j$ 中的最大值转移得来，这样的类似滑动窗口取最大值的转移可以使用单调队列优化。

维护一个单调递减的队列，每次取出队首转移 $f_i$。

每次枚举到一个新的 $i$，尝试向右扩大 $j$ 指针，一直到 $d-x \le x_i-x_j$ 不成立。

如果当前队尾对应的 dp 值比当前新加入队列的元素更劣，删除队尾元素。

如果当前队首不满足 $x_i-x_j \le d+x$，即“过期了”，就弹出队首。

```cpp
bool check(int x) {
	F(i, 0, N-2) f[i] = -inf;
	f[0] = 0;
	int ff = 1, e = 0, mx = 0, j = 0;
	F(i, 1, n) {	
		while (j < i && a[i].x - a[j].x >= d-x) {
			while (ff <= e && f[j] >= f[q[e]]) --e;
			q[++e] = j;
			++j;
		}
		while (ff <= e && a[i].x - a[q[ff]].x > d+x) ++ff;
		if (ff <= e) f[i] = max(f[i], f[q[ff]] + a[i].y);
		mx = max(mx, f[i]);
	}
	return mx >= k;
}
```

## AC Code

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define int long long
#define F(i, a, b) for (int i = a; i <= b; i++)
#define _F(i, a, b) for (int i = a; i >= b; i--)
using namespace std;
const int N = 5e5 + 5, inf = 1e14;
int n, d, k;
struct node {int x, y;} a[N];
int rd() {
	int p = 0, f = 1;
	char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
int f[N], q[N];
bool check(int x) {
	F(i, 0, N-2) f[i] = -inf;
	f[0] = 0;
	int ff = 1, e = 0, mx = 0, j = 0;
	F(i, 1, n) {	
		while (j < i && a[i].x - a[j].x >= d-x) {
			while (ff <= e && f[j] >= f[q[e]]) --e;
			q[++e] = j;
			++j;
		}
		while (ff <= e && a[i].x - a[q[ff]].x > d+x) ++ff;
		if (ff <= e) f[i] = max(f[i], f[q[ff]] + a[i].y);
		mx = max(mx, f[i]);
	}
	return mx >= k;
}
signed main() {
	n = rd(), d = rd(), k = rd();
	F(i, 1, n) a[i].x = rd(), a[i].y = rd();	
	int l = 0, r = 1e9, mid, ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) r = mid - 1, ans = mid;
		else l = mid + 1;
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：ymx2009 (赞：0)

# 题目大意
有 $n$ 个节点，每个节点有一个权值，给定一个 $d$，可以花费代价 $g$ 使得每一次每次移动可以往后移动 $[\max(d-g,1),d+g]$，求至少获得权值和为 $k$ 时最小的 $d$。

# 思路分析
当 $g$ 确定时，很明显当前的答案是由一个区间转移而来的，答案由区间转移而来且答案是和的形式，可以想到使用单调队列优化 dp。  
那么只需要二分 $g$ 的值，然后用单调队列优化 dp 求出这个 $g$ 是否合法。

# Solution
$dp_i$ 为当前这个节点能获得的最大的权值和，可得状态转移方程：
$$
dp_i=\max(dp_{i-x})+v_i,(\max(1,d-g)\le x\le d+g)
$$
这个形式可以看出应该使用单调队优化。  
如果存在有 $dp_i>k$ 那么这个 $g$ 一定是合法的，就无需往下继续计算到 $dp_n$ 了，这是一个小剪枝。

---


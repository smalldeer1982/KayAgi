# 高手过招

## 题目描述

AKN 玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是 wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个 $n \times 20$ 的棋盘，以及棋盘上有若干个棋子，问谁赢？akn 先手！

游戏规则是这样的：

对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。

## 说明/提示

$10\%$ 的数据 $T \leq 1,n \leq 1$。

另外 $10\%$ 的数据 $m \leq 1$。

$100\%$ 的数据 $T \leq 100$，$n \leq  1000$，$m \leq 20$，$1 \leq p_j \leq 20$。

## 样例 #1

### 输入

```
2
1
2 19 20
2
1 19
1 18
```

### 输出

```
NO
YES
```

# 题解

## 作者：VinstaG173 (赞：61)

一道优秀的阶梯Nim+SG定理。

首先，我们在整个序列前面加上一个空格（设此时空格个数为$C+1$），然后从右到左将所有空格编号为$0$至$C$。令第$i$级阶梯上的棋子数为编号为$i$的空格右边的连续棋子个数。

以下用■表示棋子，□表示空格。则对于这个场景：

(□)□■□□□□□□□□□□□□□□□□■■（样例第一组数据）

有第$0$至$17$级阶梯（容易数出有$18$个空格）棋子个数分别是$\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\}$。

将一个棋子移至右边第一个空格时，相当于将其与其右边相邻的所有棋子移到下一级阶梯。如这样：

(□)□■□□□□□□□□□□□□□□□□■■变成

(□)□□■□□□□□□□□□□□□□□□■■时相当于

$\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\}$变成

$\{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0\}$（第$16$层一颗棋子下移一级阶梯），又如：

(□)■■■□□■变成

(□)■□■■□■时相当于

$\{1,0,3\}$变成

$\{1,2,1\}$（第$2$层两颗棋子下移一级阶梯）。

我们发现，当所有棋子都在第$0$级阶梯时，先手无法操作，必败。

### 这不是典型的阶梯Nim吗？

于是我们处理一下，用阶梯Nim的解法（SG函数为奇数位异或和）再加一个SG定理处理多行即可。

$Code:$

```cpp
#include<cstdio>
#include<cstring>
int T,N,K,cnt,tot,x,ans1,ans2;
bool hv[23];//hv[i]==true表示i位置有石子
int main()
{
	scanf(" %d",&T);
	while(T--)
	{
		scanf(" %d",&N);ans2=0;//整个数据的SG值用ans2储存
		while(N--)
		{
			scanf(" %d",&K);
			memset(hv,false,sizeof(hv));cnt=20-K+1;tot=0;ans1=0;//cnt即C,tot储存当前阶梯棋子个数，ans1储存本行SG值
			while(K--)
			{
				scanf(" %d",&x);
				hv[x]=true;//标记有石子
			}
			for(int i=1;i<=20;++i)
			{
				if(!hv[i])
				{
					if((--cnt)&1)ans1^=tot;//奇数级阶梯，异或
					tot=0;
				}
				else ++tot;//加棋子到阶梯上
			}
			ans2^=ans1;//SG定理应用
		}
		if(ans2)printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

---

## 作者：Mingoal (赞：50)

理论的部分@worcher都讲过了，我就不多讲了，这里讲讲怎么实现求sg函数的过程。

刚开始我想出一种方法，时间复杂度是2^20\*20，觉得太慢，但又想不出别的方法，结果就这么写了一个提交，竟然过了。

我们先考虑一行的棋盘。

假设以x为棋盘的状态，二进制中0为该位无棋子，1为有棋子。

首先，如果棋子都聚集在棋盘最右边，则任何一个棋子都不能动，所以sg[x]=0。

设x=(00...00111..11)2

其中有a个1，则x=2^0+2^1+...+2^(a-1)=2^a-1

这些状态我们可以预处理出。

然后，若x不是这个状态，则要删去右边的不可以移动的棋子。

若x=(100101011...111..11)2，前面部分是随意的，后面部分都是1，那最后的连续的1都不是可以移动的棋子

把x加1得到(100101011...1000..00)2，只要去掉最后一个1就可以了

所以x等价于(x+1)-lb(x+1)，其中lb是求x最后一个1的状态的函数

最后的才是重点：

每次找最右边的没有计算过的一颗棋子，求出它的后继状态，这很容易。设t=x，每计算一次最右边的棋子，t中就减去这个棋子。设k=lb(t)，从左到右枚举k，找到第一个空位并把原来的棋子放在这个位置上就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
int sg[1048576],i,T,n,m,ans,s,x,a[21],j;
int lb(int x){
    return x&(-x);
}
int dfs(int x){
    if (sg[x]!=-1) return sg[x];
    int t=(x+1)-lb(x+1),k=lb(t),cnt=0,tmp;
    while (k){//边界条件是棋盘上还有可以移动且没被计算过的棋子
        t^=k;tmp=k;
        for (;(x^k)<x;k>>=1);//找没有棋子的位置
        a[cnt++]=dfs(x^k^tmp);//异或tmp是拿掉原来位置上的棋子相当于减，异或k是放到空位上，相当于加
        k=lb(t);
    }
    sort(a,a+cnt);
    if (a[0]) return sg[x]=0;
    for (int i=1;i<cnt;i++)
        if (a[i]-a[i-1]>1) return sg[x]=a[i-1]+1;
    return sg[x]=a[cnt-1]+1;
}
int main(){
    memset(sg,-1,sizeof(sg));
    for (i=0;i<=20;i++) sg[(1<<i)-1]=0;
    for (i=0;i<(1<<20);i++)
        if (sg[i]==-1) sg[i]=dfs(i);
    cin>>T;
    while (T--){
        scanf("%d",&n);
        ans=0;
        for (i=0;i<n;i++){
            scanf("%d",&m);
            s=0;
            for (j=0;j<m;j++) scanf("%d",&x),s|=(1<<20-x);
            ans^=sg[s];
        }
        printf("%s\n",ans?"YES":"NO");
    }
}
```
可能是语文不好或是其他原因，这篇题解写了半小时还是难以理解，我尽力了，有问题的可以私信我


---

## 作者：worcher (赞：49)

简单博弈论


首先我们知道一个状态为必败态，当且仅当它能到达的所有状态都是必胜态。一个状态为必胜态，当且仅当它能到达的所有状态中有一个必败态


然后我们就能递推出所有状态下是必胜或必败


我们将一行棋盘看成一个二进制数，然后就显然易见的能递推出所有状态的必胜必败态


然后对于一个大棋盘，我们考虑将每一行的棋局存入sg数组，最后将每一行的sg值异或一下，为0则先手必败，否则必胜


---

## 作者：Cgod (赞：22)

没必要那么麻烦，O(20Tn)足以。。。

128ms等你来虐（没开O2，用的cin）

考虑阶梯Nim，每次可以把一个石堆的任意个棋子移到下一级阶梯。

那么显然就是奇数层的SG异或起来

因为偶数层的操作后手可以做对称的操作

那么考虑这题，发现棋子间会互相影响，不好表示，所有自然而然的可以想到转换模型，发现空格的个数是不会变的，可以看作阶梯Nim。

每两个空格间的（可以说是东西？？？）看作阶梯，石子个数为硬币个数，然后扫一遍就可以了QAQ

代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int SG[30],a[30],fz[1000];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    int t,n;cin>>t;int a[30],cnt[30];
    while(t--)
    {
        cin>>n;
        int ans=0;
        for(int i=1;i<=n;++i)
        {
            int len;
            memset(cnt,0,sizeof cnt);
            cin>>len;
            for(int i=1;i<=len;++i)
                cin>>a[i],cnt[a[i]]++;
            int tot=0,i=20,fg=0;
//			for(int i=1;i<=20;++i)printf("cnt=%d\n",cnt[i]);
            while(cnt[i])--i;
            for(;i;--i)
            {
//				printf("tot=%d\n",tot);
                if(!cnt[i])ans^=(fg?tot:0),fg^=1,tot=0;
                else ++tot;
//				printf("ans=%d i=%d tot=%d\n",ans,i,tot);
            }
            ans^=(fg?tot:0);
        }
        cout<<(ans?"YES":"NO")<<endl;
    }
    return 0;
}

```

update:
又交了一遍，没快多少。。。

---

## 作者：3493441984zz (赞：15)

# 博弈论

感觉前面$dalao$并没有讲清怎么转换为阶梯$nim$，所以希望我能讲清$qwq$


------------
# 思路：

首先我们要找到阶梯分界,也就是区分每一堆的分界线，那么我们当然得找一个不变量，而我们发现，不管怎么移动，空格的数量是不变的~~（废话）~~，那么我们就以白格子为阶梯分界，来区分每一堆

例如下图就可以分为两个阶梯：

![](https://i.loli.net/2019/02/13/5c63f29488448.png)

那么假如我们把第二个黑棋向右移动，就是下图：

![](https://i.loli.net/2019/02/13/5c63f33d7622c.png)

原先的地方变为了空格，那么不就是相当于从$2$阶梯移了一颗棋子到$1$阶梯吗，这不就是裸地阶梯$nim$吗？话不多说，直接上模板$qwq$

下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 27
using namespace std;
int T,n;
bool vis[N];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		int ans=0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
		{
			int now=0,num;
			memset(vis,0,sizeof(vis));
			scanf("%d",&num);
			for(int j=1;j<=num;++j)
			{
				int in;
				scanf("%d",&in);
				vis[in]=1;
			}
			int cnt=0,tot=0;
			for(int j=20;j>=0;--j)
			{
				if(!vis[j])
				{
					if(tot)
					{
						ans^=tot;
						tot=0;
					}
					cnt^=1;
				}
				else
					if(cnt)
						++tot;
			}
			if(tot)
				ans^=tot;
		}
		printf("%s\n",ans?"YES":"NO");
	}
	return 0;
}
/*
1
2
5 5 10 12 13 14
6 1 2 6 7 8 9

*/
~~~

---

## 作者：wth2026 (赞：11)

# 题目思路
非常好的一道博弈论。

前置知识：博弈论[（不会的戳这里）](https://www.luogu.com.cn/article/ncq550o0)。

这道题直接做，肯定是没办法的，所以我们要考虑给它变形。

由于 SG 定理，可得总问题的答案为每个单个问题的答案的 Nim 和（异或和），所以我们只需要先考虑单个问题即可。

让我们先手玩一个例子：
```
1
1
6 7 8 11 12 13 19
```

对应的图是这个样子：

![图片1](https://cdn.luogu.com.cn/upload/image_hosting/hnguop6p.png)

假设我们移动绿色的棋子，就相当于把所有绿色和蓝色的棋子都向右移动了一格。

![图片2](https://cdn.luogu.com.cn/upload/image_hosting/13l7yhcb.png)

同理，移动黄色相当于黄色和紫色都一起移动，移动青色相当于移动他自己。

![图片3](https://cdn.luogu.com.cn/upload/image_hosting/4s7khzr7.png)

而如果移动深灰色，就相当于移动了深灰色和浅灰色。

![图片4](https://cdn.luogu.com.cn/upload/image_hosting/g96z677o.png)

所以我们可以把相邻的有棋子的格子合并为一个格子，上面放了很多个棋子。

想一想，很多格，每个很多棋子，可以向右移动。让你想到了什么？

**阶梯 Nim！！！**

从右往左给合并后的格子从 $0$ 开始编号，将奇数格的格子上的棋子数异或起来，就是单个起始状态的 SG 函数值（这节有点神金，可以简单理解为得到了一行的答案）。

然后根据 SG 定理，将所有行的答案异或起来就是总的答案了。

代码实现详见注释。

# AC Code
```cpp
#include <bits/stdc++.h>

#define endl '\n'
#define int long long
#define mod 998244353
#define inf 0x3f3f3f3f
#define lnf 0x3f3f3f3f3f3f3f3f

using namespace std;

namespace WTH {
	const int N = 1000 + 5;
	
	int n;
	int x, y;
	int a[N][25];
	int cnt, num[25];
	int _Ans;
	
	void Main () {
		memset (a, 0, sizeof (a));
		_Ans = 0;
		cin >> n;
		
		for (register int i = 1; i <= n; ++ i) {
			cin >> x;
			
			while (x --) {
				cin >> y;
				++ a[i][y];
			}
		}
		
		for (register int i = 1; i <= n; ++ i) {
			memset (num, 0, sizeof (num));
			cnt = 0;
			
			for (register int j = 20; j; -- j) {
				if (! a[i][j]) {//合并+记录数量
					++ cnt;
				} else {
					++ num[cnt];
				}
			}
			
			for (register int i = 1; i <= cnt; i += 2) {
				_Ans ^= num[i];//这里偷了个懒，既然每一行的答案是单个异或，每一个询问的答案是单行异或，所以可以直接把单个的答案异或到总答案里面去
			}
		}
		
		if (_Ans) {
			cout << "YES" << endl;
		} else {
			cout << "NO" << endl;
		}
	}
}

signed main () {
	ios :: sync_with_stdio (false);
	cin.tie (0);
	cout.tie (0);
	
	int T = 1;
	cin >> T;
	
	while (T --) {
		WTH :: Main ();
	}
	
	return 0;
}
```

---

## 作者：littleming (赞：5)

出题人说这题提高组第一题难度

```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x;
}
int t,n,m,p,tmp,nxt,ans;
int sg[1<<20];
bool vis[28];
inline void solve(int x)
{
	memset(vis,0,sizeof(vis));
	tmp=1;nxt=0;
	for(int i=1;i<=20;++i){
		if(x&tmp){//第i位上有棋子 
			if((x|(tmp>>1))!=x){//第i+1位上没有棋子且不是第一位
				vis[sg[x^tmp^(tmp>>1)]]=1;//第i位棋子向右移的状态
			}
			else if(nxt){//能跳 
				vis[sg[x^tmp^(1<<(nxt-1))]]=1;//第i位棋子向右跳的状态
			}
		}
		else{
			nxt=i;
		}
		tmp<<=1;
	}
	tmp=0;
	while(vis[tmp]){
		++tmp;
	}
	sg[x]=tmp;//mex
}
int main()
{
	for(int i=0;i<=(1<<20)-1;++i){
		solve(i);//预处理每个状态的sg 
	}
	t=read();
	while(t--){
		ans=0;
		n=read();
		for(int i=1;i<=n;++i){
			tmp=0;
			m=read();
			for(int j=1;j<=m;++j){
				p=read();
				tmp+=(1<<(20-p));//算出本行的状态 
			}
			ans^=sg[tmp];
		}
		if(ans)	puts("YES");
		else	puts("NO");
	}
	return 0;
}
```

---

## 作者：derta (赞：4)

[Link](https://www.luogu.com.cn/problem/P2575)

前置知识：[浅谈公平组合游戏](https://www.luogu.com.cn/blog/225734/easy-ICG)

先考虑一行的情况

首先，考虑一个例子，如下图所示

![](https://ftp.bmp.ovh/imgs/2021/06/22fbbabaf78441cf.jpg)

我们可以将第一格的棋子向右移一格，如下图所示

![](https://ftp.bmp.ovh/imgs/2021/06/1ce1d6397cafa1cc.jpg)

也可以再将第四格的棋子移到倒数第二格，如下图所示

![](https://ftp.bmp.ovh/imgs/2021/06/723d36f890fda371.jpg)

但是，如果只看图，你会如何定义这个操作？

我想应该是

> 取出一段连续的棋子，向右平移一格

要是让你说出这个操作的特点呢？

> 一段段棋子的分裂与合并

细致一点？

> 在某个一整段连续的棋子中，取出一段，向右平移一格，与左边的棋子分开，与右边的棋子合并，移动最后一枚棋子至最右面一段者胜

这和哪个模型匹配？

这是一个比较难的点，请读者先自行思考一段时间

---

> 在某个台阶的石子中，取出一部分，向下移动一级台阶，与上面的棋子分开，与下面的棋子合并，移动最后一个石子至地面者胜

答案是阶梯 Nim

与上面的描述对应，我们可以看出：

一整段连续的石子代表一层台阶

两段连续的石子中间的空格数 - 1 代表 两层台阶之间石子数为 0 的台阶层数

将一段石子平移一格 代表 取出一部分石子放入下一层台阶

然后单行的情况就解决了，多行只需考虑 SG 定理，将每一行的答案异或起来即可

代码很好写，就不放了

---

## 作者：high_sky (赞：2)

# P2575 高手过招 题目分析

[题目链接](https://www.luogu.com.cn/problem/P2575)

## 分析题目性质

我们发现每个行之间是**互不干预的**，因此可以分开处理。

又注意到：$m\leq 20.$

我们不难由此想到用**状态压缩**来表示 $SG$ 函数。

于是问题就迎刃而解了。

## 思路

根据上述我们预处理出 $SG$ 函数，然后对于第 $i$ 个数据的第 $j$ 行对其状态的 $SG$ 值进行异或，判断是否为 $0$ 就能确定答案。

## 细节

对于实现 $SG$ 函数，我们可以考虑枚举状态，然后枚举哪一个位置有石头并将其移动。

于是就有：
$$
SG_{i}=\text{mex}_{k\in S}\{SG_{k}\}
$$
其中 $S$ 表示为进行变化过后的状态。

代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stdlib.h>
#include <cstring>
#include <vector>
#define N 1005
#define M 1500005
using namespace std;
const int m = 20;
int T,n,sg[M],len[N],p[N];// SG代表了这个状态的必胜必败态 
int b[25],cnt;
bool vis[M];
signed main(){
	cin >> T;
	for (int i = 1;i < m;i ++) sg[(1 << i) - 1] = 0;
	sg[0] = 1;
	for (int i = 2;i < (1 << m);i ++) {
		int cnt = 0;
		for (int j = 0;j < m && (1 << j) <= i;j ++)
			if ((i >> j) & 1) {
				int t = (i ^ (1 << j));
				int k;
				for (k = j - 1;((i >> k) & 1) && k > 0;k --);
				if (k < 0) continue;
				if (k == 0 && ((i >> k) & 1)) continue;
				vis[sg[t | (1 << k)]] = 1;
				b[++cnt] = sg[t | (1 << k)];
			}
		for (int j = 0;;j ++)
			if (!vis[j]) {
				sg[i] = j;
				break;
			}
		for (int i = 1;i <= cnt;i ++)
			vis[b[i]] = 0;
	}		
	for (;T--;) {
		scanf("%d",&n);
		for (int i = 1;i <= n;i ++) {
			scanf("%d",&len[i]);
			p[i] = 0;
			for (int j = 1;j <= len[i];j ++) {
				int x;
				scanf("%d",&x);
				int t = m - x;
				p[i] |= (1 << t);
			}
		}
		int ans = 0;
		for (int i = 1;i <= n;i ++) ans ^= sg[p[i]]; 
		if (ans) puts("YES");
		else puts("NO");
	} 
	return 0;
}
/*
2
1
2 19 20
2
1 19
1 18

不难发现每一行都是独立的。
因此答案应该是每一行的 SG 相互异或。
考虑到 m <= 20，所以可以联想到状态压缩。 
*/
```

---

## 作者：yyewenh (赞：2)

不知道阶梯nim看过来
------------

根据大佬们所说，这是一道阶梯nim。

~~在这之前我根本不知道什么是阶梯nim~~。

就敲了这个样例分的代码。（~~代码太丑不贴了~~）

阶梯nim的形式一般是：有n个位置1...n，每个位置上有ai个石子。

有两个人轮流操作。操作步骤是：挑选1...n中任一一个存在石子的位置i，将至少1个石子移动至i−1位置（也就是最后所有石子都堆在在0这个位置）。

谁不能操作谁输。求先手必胜还是必败。

这种问题可以转换成只能取奇数石堆石头的nim游戏。

------------

证明：

取走奇数石堆上的石头相当于将奇数石堆上的石头移动到偶数石堆上。

如果双方都只取奇数堆上的石头那么这就是一个nim游戏。

但是当一方打破这个局面而取了偶数堆上的n块石头，下家依旧可以通过取走这n块石头到下一个奇数堆上（因为偶数堆必然不是最后一堆）。

这样先手就可以逼迫后手进行nim游戏，后手必赢情况同理，后手也可以通过一样的方法逼迫先手进行nim游戏。

------------

这道题目可以通过把0当做是分界线，将棋子作为阶梯上的石子个数，第1篇题解讲的比较详细这里就不作赘述了。
代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,m,c,sum,ans,anss;
bool pd[21];
int main() {
	scanf("%d",&t);
	while(t--) {
		anss=0;
		scanf("%d",&n);
		for(int i=1; i<=n; i++) {
			scanf("%d",&m);
			memset(pd,0,sizeof(pd));
			c=20-m;ans=0;sum=0;
			for(int j=1; j<=m; j++) {
				int x;
				scanf("%d",&x);
				pd[x]=1;
			}
			for(int j=1; j<=20; j++) {
				if(!pd[j]) {
					if((c--)%2)
						ans^=sum;
					sum=0;
				} else sum++;
			}
			anss^=ans;
		}
		if(anss)printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```
[本题解参考博客](https://www.cnblogs.com/RogerDTZ/p/9439540.html)

---

## 作者：ttt_TTT (赞：2)

我们将一行棋盘看成一个二进制数，然后就显然易见的能递推出所有状态的必胜必败态 
然后对于一个大棋盘，我们考虑将每一行的棋局存入sg数组，最后将每一行的sg值异或一下，为0则先手必败，否则必胜 
刚开始我想出一种方法，时间复杂度是2^20*20，觉得太慢，但又想不出别的方法，结果就这么写了一个提交，竟然过了。 
我们先考虑一行的棋盘。 
假设以x为棋盘的状态，二进制中0为该位无棋子，1为有棋子。 
首先，如果棋子都聚集在棋盘最右边，则任何一个棋子都不能动，所以sg[x]=0。 
设x=(00…00111..11)2 
其中有a个1，则x=2^0+2^1+…+2^(a-1)=2^a-1 
这些状态我们可以预处理出。 
然后，若x不是这个状态，则要删去右边的不可以移动的棋子。 
若x=(100101011…111..11)2，前面部分是随意的，后面部分都是1，那最后的连续的1都不是可以移动的棋子 
把x加1得到(100101011…1000..00)2，只要去掉最后一个1就可以了 
所以x等价于(x+1)-lb(x+1)，其中lb是求x最后一个1的状态的函数 
最后：每次找最右边的没有计算过的一颗棋子，求出它的后继状态，这很容易。设t=x，每计算一次最右边的棋子，t中就减去这个棋子。设k=lb(t)，从左到右枚举k，找到第一个空位并把原来的棋子放在这个位置上就行。

```
#include<bits/stdc++.h>
using namespace std;
int sg[1048576],i,T,n,m,ans,s,x,a[21],j;
int lb(int x){
    return x&(-x);
}
int dfs(int x){
    if (sg[x]!=-1) return sg[x];
    int t=(x+1)-lb(x+1),k=lb(t),cnt=0,tmp;
    while (k){//边界条件是棋盘上还有可以移动且没被计算过的棋子
        t^=k;tmp=k;
        for (;(x^k)<x;k>>=1);//找没有棋子的位置
        a[cnt++]=dfs(x^k^tmp);//异或tmp是拿掉原来位置上的棋子相当于减，异或k是放到空位上，相当于加
        k=lb(t);
    }
    sort(a,a+cnt);
    if (a[0]) return sg[x]=0;
    for (int i=1;i<cnt;i++)
        if (a[i]-a[i-1]>1) return sg[x]=a[i-1]+1;
    return sg[x]=a[cnt-1]+1;
}
int main(){
    memset(sg,-1,sizeof(sg));
    for (i=0;i<=20;i++) sg[(1<<i)-1]=0;
    for (i=0;i<(1<<20);i++)
        if (sg[i]==-1) sg[i]=dfs(i);
    cin>>T;
    while (T--){
        scanf("%d",&n);
        ans=0;
        for (i=0;i<n;i++){
            scanf("%d",&m);
            s=0;
            for (j=0;j<m;j++) scanf("%d",&x),s|=(1<<20-x);
            ans^=sg[s];
        }
        printf("%s\n",ans?"YES":"NO");
    }
}
```

---

## 作者：whx2009 (赞：1)

## 本题思路：
我们可以把每一层看做一个独立的游戏，因为本题的列数不是很多，我们就可以用 $2^{20}$ 来枚举每一次棋子摆放的状态，然后每一个状态的 SG 函数是很好求的，直接枚举移动的棋子，然后取 mex 就可以了。

针对多行，我们直接给每一行的答案做 Nim 游戏就完成了。
## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int sg[(1<<20)];
vector<int>s[(1<<20)];
signed main(){
	for(int i=(1<<20)-1;i>=0;i--){
		if(s[i].size()==0) sg[i]=0;
		else{
			int l=0;sort(s[i].begin(),s[i].end());
			for(int j=0;j<s[i].size();j++){
				if(s[i][j]==l) l++;
				if(s[i][j]>l) break;
			}
			sg[i]=l;
		}s[i].clear();
		int op=-1;
		for(int j=0;j<20;j++){
			if(!(i&(1<<j))) op=j;
			else{
				if(op==-1) continue;
				s[((i^(1<<j))^(1<<op))].push_back(sg[i]);
			}
		}
	}
	int t;cin>>t;
	while(t--){
		int sum=0,n;cin>>n;
		for(int i=1;i<=n;i++){
			int num=0,m;cin>>m;
			for(int j=1;j<=m;j++){
				int x;cin>>x;
				num=num+(1<<(x-1));
			}
			sum^=sg[num];
		}
		if(sum) cout<<"YES"<<'\n';
		else cout<<"NO"<<'\n';
	}
	return 0;
}
```

---

## 作者：Wanderer_01 (赞：1)

## 题意：

题目传送门。

[P2575](https://www.luogu.com.cn/problem/P2575)

## 思路：

#### 省流（题意转换）：

棋盘大小为 $n\times 20$，其中每一个棋子向右单向移动，故每行间互不影响，可以看成 $n$ 个子游戏。

对于每一个子游戏，棋子单向移动，是一个典型的阶梯博弈。

所以只需单独处理每一行的阶梯 Nim，最后用处理一个 SG 函数即可。

#### 阶梯 Nim：

在一个阶梯上，每一级上有一些石子，每次只能选择以个棋子向下移动一格，无法移动者输，问先手是否有必胜策略。

对于这个问题，若石子在偶数级上，先手移动后，后手可以模仿，对答案无影响；若石子在奇数级上，先手动后变为偶数级，对后手来说无影响。

所以，对于这类问题的答案 $ans_i$ 为所有奇数级上的石子的异或和。

若 $ans$ 为 $0$，则先手无必胜策略，反之，先手有。

#### SG 函数：

[例题P1247](https://www.luogu.com.cn/problem/P1247)

若要继续了解，[P3185](https://www.luogu.com.cn/problem/P3185) 也算例题。

由于 $n$ 行之间是互不影响的，且每一行都是整个博弈的子任务。

所以最终答案 $ans$ 为每行的 $ans_i$ 的异或和。

## CODE：

以下为完整的代码。

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||'9'<ch){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
	return f*x;
}
bool b[25];
void solve(){
	int ans=0,n=read();				//多测记得初始化，清空ans
	for(int i=1; i<=n; i++){
		int m=read(),tag=0,tot=0;		//tag记录是奇数级还是偶数级，而tot记录同级上的棋子个数
		for(int j=1; j<=m; j++) b[read()]=1;
		for(int j=20; j>=0; j--)
			if(!b[j]){
				if(tag) ans^=tot;
				tot=0,tag^=1;		//打标记
			}else tot++,b[j]=0;		//记录同级的棋子个数加初始化
	}
	if(ans) printf("YES\n");
	else printf("NO\n");
}
signed main(){
	int T=read();
	while(T--) solve();
}
~~~

---

## 作者：_Life_ (赞：1)

### 前置知识
SG函数/定理&阶梯Nim
[不会的可以到这里学qwqq](https://www.luogu.com.cn/blog/ZLY/Game-Theory)

### 题意
有一张 $n\times 20$ 的棋盘，上面摆放了一些棋子。对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。

### 题解
我们发现各行的状态是互相独立的，所以整个游戏由各行的子游戏组成，可以用 $\operatorname{SG}$ 定理瞎搞，所以只要搞出子游戏的 $\operatorname{SG}$ 函数这题就做完了。

我们发现，在一行（一个子游戏）中，空格的数量始终不变。把空格看成阶梯的分界，两个空格之间间隔的棋子看成石子，然后你会发现这东西转换成了阶梯Nim，把奇数层上的石子个数异或起来就好了。

### 代码
```cpp
#include<cstdio>
using namespace std;
int SG()
{
	int x[25]={0},m,val=0,tot=0,tot2=0;
	//val：SG值
	//tot：当前层石子的个数
	//tot2：当前第几层
	scanf("%d",&m);
	for(int i=1,k;i<=m;i++)scanf("%d",&k),x[k]=1;
	for(int i=20;i>=0;i--)//为了处理最后一层的石子，所以循环到0
		if(x[i])
			tot++;
		else
		{
			if(tot2&1)
				val^=tot;
			tot=0;
			tot2++;
		}
	return val;
}
int main()
{
	int T,n,val;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		val=0;
		while(n--)
			val^=SG();
		puts(val?"YES":"NO");
	}
}
```

---

## 作者：pengyule (赞：1)

答案的 SG 值就是每一排 SG 值的异或和，因为可看作每次选取一排的游戏作为子游戏操作。

考虑单排的 SG 值。假如把第一个空格前的棋子个数看成 $b_k$，第一、二个空格间的棋子数看成 $b_{k-1}$，……，倒数第二个空格和最后一个空格间的棋子个数看成 $b_1$，将 $b_{1,2,\cdots,k}$ 看成 $k$ 级阶梯上的石子数（$b_x$ 可以为零），则游戏转化为一个阶梯博弈。考虑将操作一（棋子 $p$ 向右移动一格，无阻碍），操作二（棋子 $p$ 向右跳，有阻碍）看成下图中的两情况。

![图片.png](https://i.loli.net/2021/02/10/OdrGnUFX7fx8IH6.png)

在考虑以下边界情况就好了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[25],ocp[25],b[25];
int main()
{
	int T;
	cin>>T;
	while(T--){
		int n,m,ans=0;
		cin>>n;
		while(n--){
			memset(ocp,0,sizeof(ocp));
			cin>>m;
			for(int i=1;i<=m;i++){
				cin>>a[i];
				ocp[a[i]]=1;
			}
			int num=-1,res=0,pre;
			for(int i=20;i>=1;i--) if(!ocp[i]){
				if(num<0){
					num++;
					pre=i;
					continue;
				}
				b[++num]=pre-i-1;
				pre=i;
			}
			b[++num]=pre-1;
			for(int i=1;i<=num;i+=2) res^=b[i];
			ans^=res;
		}
		if(ans>0) cout<<"YES\n";
		else cout<<"NO\n";
	}
}
```

---


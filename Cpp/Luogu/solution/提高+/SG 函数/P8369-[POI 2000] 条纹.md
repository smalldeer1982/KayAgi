# [POI 2000] 条纹

## 题目描述

条纹游戏是一个双人的游戏。所需要的物品有一个棋盘以及三种颜色的长方形条纹，这三种颜色分别是红色、绿色和蓝色。所有的红色条纹的尺寸是 $c \times 1$，所有的绿色条纹的尺寸是 $z \times 1$，所有的蓝色条纹的尺寸是 $n \times 1$，这里 $c,z,n$ 是正整数。每种颜色的条纹每个游戏者都拥有无限多个。

一个棋盘是一个尺寸为 $p \times 1$ 的长方形，由 $p$ 个 $1 \times 1$ 的方格组成。

游戏者轮流走，每一步都是由一个游戏者任选一种长方形条纹覆盖到棋盘上，并要求遵循以下规则：

1. 条纹不能伸出棋盘之外。
2. 不能覆盖在已有的条纹之上（即使部分也不行）。
3. 条纹的边缘必须与棋盘方格的边缘相重叠。谁不能再走，谁就输了。

先手是指在游戏中第一个走的游戏者。那么是否不管后手怎么走，先手都有必胜策略呢？

请你编写一个程序：

1. 读入条纹的尺寸以及至少一个棋盘的尺寸。
2. 对每一个给出的棋盘判断先手是否必胜。
3. 将结果输出。

## 说明/提示

对于 $100$ % 的数据： $1 \le c,z,n,m,p \le 1000$。

## 样例 #1

### 输入

```
1 5 1
3
1
5
6```

### 输出

```
1
1
2```

# 题解

## 作者：VinstaG173 (赞：11)

考虑计算 SG 函数。

根据题目描述，$i$ 的所有可能的后继状态为 $(j,i-c-j)$，$(j,i-z-j)$，$(j,i-n-j)$。故
$$\operatorname{SG}(i)=\operatorname{mex}\left\{\bigcup_{j}\{\operatorname{SG}(j)\oplus\operatorname{SG}(i-c-j),\operatorname{SG}(j)\oplus\operatorname{SG}(i-z-j),\operatorname{SG}(j)\oplus\operatorname{SG}(i-n-j)\}\right\}.$$
$O(n^2)$ 递推即可。

Code:
```cpp
#include<cstdio>
#define rg register
int c,z,n,m,p,sg[1003],v[1073];int main(){
	scanf(" %d %d %d",&c,&z,&n);
	for(rg int i=1;i<=1e3;++i){
		for(rg int j=0;j<=1024;++j)v[j]=0;
		for(rg int j=0;j<=i-c;++j)
			v[sg[j]^sg[i-c-j]]=1;
		for(rg int j=0;j<=i-z;++j)
			v[sg[j]^sg[i-z-j]]=1;
		for(rg int j=0;j<=i-n;++j)
			v[sg[j]^sg[i-n-j]]=1;
		for(sg[i]=0;v[sg[i]];++sg[i]);
	}scanf(" %d",&m);while(m--){
		scanf(" %d",&p);printf("%d\n",\
		(sg[p])?1:2);}return 0;
}
```

---

## 作者：SunsetSamsara (赞：5)

## 题意

两个人轮流用 $c \times 1$、$z \times 1$、$n \times 1$ 的小长方形覆盖一个 $p \times 1$ 的长方形，谁不能走谁就输，判断先手是否有必胜策略。

## 分析

这题可以从覆盖操作看起。覆盖操作会把长方形分成 $3$ 部分：用于覆盖的长方形的左侧、用于覆盖的长方形、用于覆盖的长方形右侧。

因为被覆盖的部分不能再覆盖了，所以可以把中间的部分删去。

于是，覆盖一个地方相当于拿走一些格子后把剩余的格子分成任意数量的两堆格子（可以为空）。我们会发现，要是不分成两部分的话，这就是一个普通的 $\operatorname{SG}$ 游戏。而一旦添加了进行分割的操作，它就变成了一个 $\operatorname{Multi-SG}$ 游戏。

由 $\operatorname{Multi-SG}$ 游戏的 $SG$ 递推式可以得到，$SG_x=\operatorname{Mex}(\{SG_j \oplus SG_{x-c-j}, SG_j \oplus SG_{x-z-j},SG_j \oplus SG_{x-n-j}\})$

## 代码

```cpp
#include <stdio.h>
#include <string.h>
int c, z, n, m, p;
int SG[1010];
bool vis[1010];
int main() {
	scanf("%d%d%d%d", &c, &z, &n, &m);
	for (int i = 1; i <= 1000; ++ i) {
		memset(vis, 0, sizeof(vis));
		if (i >= c) for (int j = 0; j + c <= i; ++ j) vis[SG[j] ^ SG[i - j - c]] = 1;// printf("%d\n", SG[j] ^ SG[i - j - c]);
		if (i >= z) for (int j = 0; j + z <= i; ++ j) vis[SG[j] ^ SG[i - j - z]] = 1;// printf("%d\n", SG[j] ^ SG[i - j - z]);
		if (i >= n) for (int j = 0; j + n <= i; ++ j) vis[SG[j] ^ SG[i - j - n]] = 1;// printf("%d\n", SG[j] ^ SG[i - j - n]);
		for (int j = 0; ; ++ j)
			if (!vis[j]) {
				//printf("%d %d\n", i, j);
				SG[i] = j; // Mex
				break;
			}
		// SG值（见上） 
	}
	for (; m --; ) {
		scanf("%d", &p);
		puts(SG[p] ? "1" : "2");
	}
}
```

---

## 作者：vicky2048_2 (赞：3)

### $\operatorname{Description}$

给定一段长度为 $n$ 的线段。现有两人轮流进行操作，每次在线段中移除连续的一段，且移除线段的长度只能为 $c,z,n$ 中的任意一个。

现给出多条线段，问对于长度为 $len_i$ 的线段，先手是否有必胜策略。

### $\operatorname{Solution}$

易发现该游戏符合 $ICG$ 的所有性质，于是考虑使用 $SG$ 函数计算。

我们设 $SG(i)$ 表示长度为 $i$ 的线段对于先手而言是否有必胜策略。

显然有 $SG(0)=0$。

对于一条长度为 $len$ 的线段而言，设对其进行一次操作取走的长度为 $w$，取走的那一段区间左区间长度为 $left$，那么当前长度为 $len$ 的线段就被我们分成了三部分：

- 被取走的那段长度为 $w$ 的线段，我们取走该部分之后该部分的状态变为 $SG(0)$。
- 被取走区间左边的区间，即长度为 $left$ 的一段线段，在我们进行操作之后其状态就是 $SG(left)$。
- 被取走区间右边的区间，即长度为 $len-w-left$ 的一段线段，我们进行操作之后其状态为 $SG(len-w-left)$。

因为被取走的区间 $SG$ 值变为 $0$，在异或时并不会对结果产生任何影响。

所以我们每进行一次操作，实际上就是将当前局面分成左右区间两个子局面。

递推 $O(n^2)$ 求 $SG$，然后 $O(1)$ 回答询问即可。

时间复杂度 $O(n^2)$。

### $\operatorname{Code}$

```
#include<bits/stdc++.h>
#define M 2005
using namespace std;
int a[4],t,n,sg[M];
int main(){
    scanf("%d%d%d%d",&a[1],&a[2],&a[3],&t);
    for(int i=1;i<=1000;i++){
        set<int>s;
        for(int j=0;j<=i-a[1];j++) s.insert(sg[j]^sg[i-j-a[1]]);
        for(int j=0;j<=i-a[2];j++) s.insert(sg[j]^sg[i-j-a[2]]);
        for(int j=0;j<=i-a[3];j++) s.insert(sg[j]^sg[i-j-a[3]]);
        int fl=0;
        while(s.count(fl)) ++fl;
        sg[i]=fl;
    }
    while(t--){
        scanf("%d",&n);
        printf("%c\n",sg[n]?'1':'2');
    }
    return 0;
}
```


---

## 作者：XYstarabyss (赞：0)

# Solution

首先，我们可以发现这是一个公平组合游戏（Impartial Game）。

其定义如下：

1. 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息。
2. 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。
3. 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

对照题意易知确实如此。那么它是一个公平组合游戏有什么用呢？

接下来介绍一下公平组合游戏的一些性质：

首先，由定义可知对于游戏中的各种状态只可能存在两种：以该状态开始先手必胜与以该状态开始先手必败。为了方便，下面简称为 W 状态和 L 状态。

其次，没有后继状态（从该状态开始进行一次操作后的状态）的状态一定是 L 状态，因为此时无法操作，该玩家也就输了。

然后，一个状态为 W 状态当且仅当其至少有一个后继状态为 L 状态。显然，你给对手留下 L 状态相当于你获得了胜利。

最后，一个状态为 L 状态需要它的所有后继状态都为 W 状态。这样，无论你怎么操作，都会给对手留下 W 状态，相当于你输了。

我们还需要三个定义：函数 $\operatorname{mex}$、SG 函数和SG 定理。

定义 $\operatorname{mex}$ 函数的值为不属于集合 S 中的最小非负整数，即：


$$\operatorname{mex}(S)=\min\{x\}~~~~(x \notin S, x \in N)$$

例如 $\operatorname{mex}(\{1,3,4,7,8\}) = 0$，$\operatorname{mex}(\{0,1,3,4,7\}) = 2$。

定义 SG 函数：对于状态 $x$ 与其后继状态 $y_1,y_2,y_3,\dots,y_n$，有

$$
\operatorname{SG}(x) = \operatorname{mex}(\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \dots, \operatorname{SG}(y_n)\})
$$

而对于一个公平组合游戏，设其起点为 $s$，则 **当 $\operatorname{SG}(s) \not= 0$ 时，先手必胜**。

若有多个起点 $s_1,s_2,s_3,\dots,s_k$ 则当 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \dots \oplus \operatorname{SG}(s_k) \not= 0$ 时，先手必胜。同时，该组合游戏的 $\operatorname{SG}$ 值也为 $\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \dots \oplus \operatorname{SG}(s_k)$。

为什么呢？可以用 **数学归纳法** 证明。读者自证不难，也可以移步 oi-wiki，这里不再赘述。

接下来着重讲一下这道题该怎么想。

首先我们举一个 $15 \times 1$ 大小的棋盘，取 $c = 4,z = 5,n = 3$ 为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/ogibeq3f.png)

我们可以先试着放一个 $4 \times 1$ 大小的红块进去试一试。

![](https://cdn.luogu.com.cn/upload/image_hosting/4syalb2p.png)

然后……我们就会发现这个红块把棋盘的剩余部分分成了两分，这两分可以分别看作 $3 \times 1$ 大小的棋盘和 $8 \times 1$ 大小的棋盘。

由上文可知这一个后继状态的 $\operatorname{SG}$ 值为 $\operatorname{SG}(3) ~\oplus~\operatorname{SG}(8)$。

如此这般，我们就可以把较大的问题转化为较小的子问题。

由此，更一般地，对于一个大小为 $i \times 1$ 的棋盘，只考虑大小为 $c \times 1$ 的红块的放置导致的后继状态的 $\operatorname{SG}$ 值为

$$\operatorname{SG}(0) ~\oplus~\operatorname{SG}(i - c),\operatorname{SG}(1) ~\oplus~\operatorname{SG}(i - c - 1),\operatorname{SG}(2) ~\oplus~\operatorname{SG}(i - c - 2),\dots,\operatorname{SG}(i - c) ~\oplus~\operatorname{SG}(0)$$

打包为集合就是

$$\bigcup_{j = 0}^{i - c}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - c - j)\}$$

蓝块和绿块亦同理。所以对于一个大小为 $i \times 1$ 的棋盘，其所有后继状态的 $\operatorname{SG}$ 值所组成的集合就是

$$\bigcup_{j = 0}^{i - c}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - c - j)\} ~~\bigcup ~~
\bigcup_{j = 0}^{i - z}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - z - j)\}~~\bigcup~~\bigcup_{j = 0}^{i - n}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - n - j)\}$$

所以

$$\operatorname{SG}(i) = \operatorname{mex}(\bigcup_{j = 0}^{i - c}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - c - j)\} ~~\bigcup ~~
\bigcup_{j = 0}^{i - z}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - z - j)\}~~\bigcup~~\bigcup_{j = 0}^{i - n}\{\operatorname{SG}(j) ~\oplus~\operatorname{SG}(i - n - j)\})$$

然后从 $1$ 到 $1000$ 把 $\operatorname{SG}$ 值算出来就可以了。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(n,m,i) for (register int i(n);i <= m;++ i)
#define fc(n,m,i) for (register int i(n);i >= m;-- i)
#define dbug(x) cerr<<(#x)<<':'<<x<<' ';
#define ent cerr<<'\n';
#define C ios::sync_with_stdio(false),cin.tie(0),cout.tie(0),cerr.tie(0);
#define ll long long
int c[3],m,x,sg[1005];
bool pd[1005];
int main(){ C
    cin >> c[0] >> c[1] >> c[2];
    f(1,1000,i){
        f(0,1000,j)     pd[j] = false;
        f(0,2,k)
            f(0,i - c[k],j)
                pd[sg[j] ^ sg[i - c[k] - j]] = true;//把每一个后继状态的SG值算出来，标记对应的数
        while (pd[sg[i]]) ++ sg[i];//算mex，从0开始不断+1找第一个未被标记的数
    }
    cin >> m;
    while (m --){
        cin >> x;
        cout << ((sg[x]) ? (1) : (2)) << '\n';//SG(x)=0说明先手输，否则先手赢
    }
    return 0;
}
```

# 参考资料

https://oi-wiki.org/math/game-theory/impartial-game/

---


# [THUPC 2023 决赛] 巧克力

## 题目描述

上回你帮小 I 在开火车上薄纱小 J 后，小 J 十分不服气，决定拉上小 I 再玩玩别的游戏。这次小 J 找到了他家珍藏的巧克力。

小 J 准备了 $(N + 1)$ 条巧克力，其中除了第 $(N + 1)$ 条巧克力有 $M$ 块外，其他第 $i$ 条巧克力恰好有 $i$ 块。

游戏由小 I 先手，双方轮流操作，每次操作方可以进行如下操作：

- 选择一条巧克力，将其分成左中右有序的三段，其中**每段必须有整数块，中间一段不能为空，左右两段可以为空**；
- 将中间一段吃掉，左右两段放回游戏。

当某个人操作时没有巧克力了，那个人就输了。

游戏开始，小 I 还没来得及算好最优策略小 J 就连忙催促，于是小 I 只好**在所有的合法操作中等概率随机选择一个进行操作**。小 J 自然是有备而来，每次操作都是最优的；而在这次随机操作之后，小 I 也终于是算清楚了游戏策略，之后的每次操作都是最优的。

小 I 想知道，第一次的随机操作中，有多少种操作能够让他取得游戏胜利。答案可能很大，你只需要输出其对 $(10^9+7)$ 取模的结果。

认为两个操作不同当且仅当选择的巧克力不同或巧克力分成的有序的三段的块数有一段不同。

## 说明/提示

#### 样例解释

- 对于第一组测试数据，容易证明先手必败，所以无论怎么操作小 I 都会输。
- 对于第二组测试数据，有以下四种操作：
  - 将第一条巧克力分成 $(0,1,0)$ 三段，将中间一段吃掉；
  - 将第四条巧克力分成 $(0,1,0)$ 三段，将中间一段吃掉；
  - 将第三条巧克力分为 $(0,1,2)$ 三段，将中间一段吃掉；
  - 将第三条巧克力分为 $(2,1,0)$ 三段，将中间一段吃掉。
- 对于第三组测试数据，所有的合法操作都是将第四条巧克力分成三段，其中左右两段长度相同。
- 对于第四组测试数据，游戏只是个幌子罢了，小 J 只是想小 I 输。

#### 数据范围

本题仅有一个 $T = 5 \times 10^4$ 的测试点，对于每组测试数据 $0 \le N,M \le 10^{18}$。

#### 后记

“下次能继续和你玩游戏吗……”

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
4
3 0
3 1
3 12345678987654321
0 0
```

### 输出

```
0
4
450617288
0
```

# 题解

## 作者：IdnadRev (赞：5)

不会数位 dp 怎么办？

显然是公平组合游戏，打表知 $SG(x)=x$，证明不难。

令 $f(s,x)=\sum_{i+j<x}[i\oplus j\oplus s\oplus x=0]$，令 $s=1\oplus 2\oplus \cdots\oplus n\oplus m$，那么答案就是（$s$ 的计算只需发现异或前缀和根据 $n\bmod 4$ 分类有简单的规律）：

$$\sum_{i=1}^nf(s,i)+f(s,m)$$

对 $f(s,x)$ 打表观察可知其服从以下规律：

令 $A_n$ 为 $0\leqslant s,x<2^n$ 对应的答案表，那么有：

$$A_{n+1}=\begin{bmatrix}A_n&2A_n\\0&2^n-T(a_n)\end{bmatrix}$$

（$T(M)$ 表示矩阵 $M$ 旋转 $180\degree$，常数 $C$ 表示由 $C$ 平铺形成的矩阵）

考虑如何计算 $f(s,x)$：讨论 $(s,x)$ 在矩阵中的方位，左下是平凡的，其余都可以递归进边长除二的矩阵内解决。

我们还需计算 $f$ 一行的前缀和：类似线段树可以将其拆分成 $\log V$ 个矩阵的完整行求和，每一个问题都可以类似上面在 $\log V$ 次递归中解决。

代码很好写，复杂度 $O(T\log^2V)$。

---

## 作者：wgyhm (赞：2)

## Description

https://www.luogu.com.cn/problem/P9387

## Solution

首先推一下必胜情况的充要条件。

本图是有向无环图，公平的两人游戏，考虑用 sg 函数。

令当前操作的巧克力长度为 $x$，实际上 $SG(x)=x$。

* 如果 $x\not = 1$ ，显然可以先分为 $(0,x-1,1),...,(0,1,x-1)$，这样取 $\text{mex}$ 之后 sg 值已经为 $x$，所以有 $SG(x)\ge x$。
* 如果分为 $(a,b,c),a+b+c=x,b>0$ 。原问题拆成两个独立的的子博弈 $a$ 和 $c$，又有 $a\bigoplus c\le a+c$，所以这里不会对 $SG$ 值有影响。

首先要全局的 $SG$ 异或和不为 $0$，保证先手不可能必败。令全局初始的异或和为 $N$。

再用令要把 $x$ 拆分为 $(a,b,c),a+b+c=x,b>0$，若操作完以后先手必败（这时候是后手先手）应该有：
$$
a\bigoplus c\bigoplus x\bigoplus N=0
$$
即现在的 $SG$ 的异或和为 $0$。

移个项为：
$$
a\bigoplus c\bigoplus(a+b+c)=N
$$
我们要求的是 $a+b+c\le n$ 或者 $a+b+c=m$ 的方案数，令 $\le n$ 的方案数为 $F(n)$，那么答案为 $F(n)+F(m)-F(m-1)$。

考虑数位 dp。一种的做法选择是从低位到高位 dp。记录当前在第 $i$ 位，低位到第 $i$ 进了 $j$ 位， $b$ 是否等于 $0$，$a+b+c$ 的后 $i$ 位是否大于 $N$ 的后 $i$ 位的方案数。

另一种大概是从高到低位 dp。记录当前在第 $i$ 位，向低位借了 $j$ ，$b$ 是否为 $0$，是否大于 $N$。（这种是口胡的）。

实现是第一种。

```cpp
#define int long long
int f[65][4][2][2];
int stat[65],p[65];
int cnt;
void add(int &x,int y) {x=(x+y)%mod;}
int get(int n) {
	if (n==0) return 0;
	memset(f,0,sizeof(f));	
	memset(p,0,sizeof(p));
	int tot=0;
	while (n) p[++tot]=n%2,n/=2;
	f[0][0][1][0]=1;
	int i,j,k,l,a,b,c;
	for (i=0;i<=60;i++) {
		for (j=0;j<=3;j++) {
			for (k=0;k<=1;k++) {
				for (l=0;l<=1;l++) {
					for (a=0;a<=1;a++)
						for (b=0;b<=1;b++)
							for (c=0;c<=1;c++) {
								int s=((a+b+c+j))%2;
								if ((s^a^c)==stat[i+1]) {
									int pus=0;
									if (s>p[i+1]||(l&&s==p[i+1])) pus=1;
									add(f[i+1][(j+a+b+c)/2][k&(b==0)][pus],f[i][j][k][l]);
								}
							}
				}
			}
		}
	}
	return f[60][0][0][0];
}
void solve(void) {
	int i,n,m,s=0;
	read(n);read(m);
	memset(stat,0,sizeof(stat));
	s=m;
	if (n%4==0) s^=n;
	else if (n%4==1) s^=n^(n-1);
	else if (n%4==2) s^=n^(n-1)^(n-2);
	if (s==0) return puts("0"),void();
	cnt=0;
	while (s) stat[++cnt]=s%2,s/=2;
	int tmp1,tmp2;
	printf("%lld\n",(get(n)+get(m)-get(m-1)+mod)%mod);
}
signed main(void){
	int T;
	read(T);while (T--) solve();
	return 0;
}
```

没卡常之前不太能过。卡常就跟另外一篇题解一样循环展开之类的，效果很明显。

---

## 作者：registerGen (赞：0)

[在 cnblogs 中查看](https://www.cnblogs.com/registergen/p/p9387_solution.html)

这篇题解会只讲怎么 dp，所以我们这里跳过博弈论的部分。

Let's rephrase the problem statement as follows:

> 给定 $n,m$，设 $x=1\oplus 2\oplus\cdots\oplus n\oplus m$。求有多少个有序三元组 $(a,b,c)$ 满足：
>
> - $a+b+c\le n$ 或 $a+b+c=m$（如果都满足需要算两遍）。
> - $(a+b+c)\oplus a\oplus c=x$。
> - $a,c\ge 0,b\gt 0$。
>
> 答案对 $10^9+7$ 取模。

注意到 $\forall y,y\oplus(y+1)\oplus(y+2)\oplus(y+3)=0$，这样 $x$ 就可以快速计算了。

首先我们显然只需要解决 $a+b+c\le n$ 的问题。

对于这种涉及到二进制的计数 dp。我们一般采取 **从低位到高位** 的顺序 dp，并同时记录进了多少位。另一个经典例题：NOIP 数列。

设 $f_{i,j,k,l}$ 表示：考虑了 $a,b,c$ 的最低 $i$ 位，第 $i$ 位往第 $i+1$ 位进位了 $j$，$b$ 的低 $i$ 位是否是 $0$，$a+b+c$ 的低 $i$ 位是否大于 $n$ 的低 $i$ 位。转移时枚举 $a,b,c$ 的第 $i$ 位是什么即可。答案是 $f_{60,0,1,0}$。

代码：

```cpp
auto dp = [&](ll n) {
  if (n < 0) return 0;
  memset(f, 0, sizeof(f));
  f[0][0][0][0] = 1;
  for (int i = 0; i < N; i++)
    for (int j = 0; j <= 2; j++)
      for (int k = 0; k <= 1; k++)
        for (int l = 0; l <= 1; l++) {
          for (int a = 0; a <= 1; a++)
            for (int b = 0; b <= 1; b++)
              for (int c = 0; c <= 1; c++) {
                int s = (j + a + b + c) & 1; // 计算 (a + b + c) 的第 i 位
                if ((s ^ a ^ c) != ((x >> i) & 1)) continue;
                int nl = (s > ((n >> i) & 1)) || (l && (s == ((n >> i) & 1)));
                add(f[i + 1][(j + a + b + c) / 2][k || b][nl], f[i][j][k][l]);
              }
        }
  return f[N][0][1][0];
};
```

但是这么写会 T 掉，我们需要将枚举 $a,b,c$ 的循环展开。这里可以写一个生成代码的程序，然后手动合并能合并的代码。结果如下（没有任何可读性……所以我把两份代码都放到这里了）：

```cpp
auto dp = [&](ll n) {
  if (n < 0) return 0;
  memset(f, 0, sizeof(f));
  f[0][0][0][0] = 1;
  for (int i = 0; i < N; i++)
    for (int j = 0; j <= 2; j++)
      for (int k = 0; k <= 1; k++)
        for (int l = 0; l <= 1; l++) {
          int s, nl;

          s = (j + 0) & 1;
          nl = (s > ((n >> i) & 1)) || (l && (s == ((n >> i) & 1)));
          if ((s ^ 0) == ((x >> i) & 1)) {
            add(f[i + 1][(j + 0) >> 1][k][nl], f[i][j][k][l]);
            add(f[i + 1][(j + 2) >> 1][k][nl], f[i][j][k][l]);
          } else {
            add(f[i + 1][(j + 2) >> 1][1][nl], f[i][j][k][l]);
            add(f[i + 1][(j + 2) >> 1][1][nl], f[i][j][k][l]);
          }

          s = (j + 1) & 1;
          nl = (s > ((n >> i) & 1)) || (l && (s == ((n >> i) & 1)));
          if ((s ^ 0) == ((x >> i) & 1)) {
            add(f[i + 1][(j + 1) >> 1][1][nl], f[i][j][k][l]);
            add(f[i + 1][(j + 3) >> 1][1][nl], f[i][j][k][l]);
          } else {
            add(f[i + 1][(j + 1) >> 1][k][nl], f[i][j][k][l]);
            add(f[i + 1][(j + 1) >> 1][k][nl], f[i][j][k][l]);
          }
        }
  return f[N][0][1][0];
};
```

时间复杂度 $\mathcal O(\log n)$。

---


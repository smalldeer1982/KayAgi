# [ROIR 2022] 礼物 (Day 2)

## 题目背景

翻译自 [ROIR 2022 D2T4](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day2.pdf)。

圣诞老人让沃瓦选择一个礼物。

在沃瓦面前有 $n$ 个礼物排成一行。每个礼物给沃瓦带来的快乐程度值用一个整数表示，第 $i$ 个礼物的值为 $a_i$。快乐程度可以是正数、负数或零。

圣诞老人让沃瓦选择两个整数 $l$ 和 $r$，满足 $1 \le l \le r \le n$。沃瓦需要选择从 $l$ 到 $r$ 之间的所有礼物。然而，在所选的礼物中，沃瓦必须把具有前 $k$ 大快乐程度值的 $k$ 个礼物给他的妹妹玛莎。

## 题目描述

帮助沃瓦选择 $l$ 和 $r$，使得 $1 \le l \le r \le n,r - l + 1 \ge k$，并且他得到的礼物的总快乐程度最大化（不包括给妹妹的礼物）。

## 说明/提示

在样例 $1$ 中，沃瓦不需要给玛莎任何礼物，因此他将选择 $l = 3, r = 5$，并且所选礼物的总快乐程度为 $5 + (−1) + 7 = 11$。

在样例 $2$ 中，沃瓦将需要将带来最大快乐程度的礼物给玛莎。然后，他仍然会选择 $l = 3, r = 5$，但总共的快乐程度是 $5 + (−1) = 4$。

在样例 $3$ 中，沃瓦需要给玛莎快乐值前二大的礼物。这种情况下，不难发现实际上沃瓦最好的选择方式是只选择两个礼物，然后全部给妹妹玛莎。一个最佳选择是选择 $l = 1, r = 2$。此时总快乐程度为 $0$。

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $7$ | $n\le200$ |
| $2$ | $8$ | $n\le1000$ |
| $3$ | $10$ | $n\le6000$ |
| $4$ | $8$ | $k=0$ |
| $5$ | $14$ | $k=1$ |
| $6$ | $39$ | $n\le80000$ |
| $7$ | $14$ | 无 |

对于 $100\%$ 的数据，$1 \le n \le 200000, 0 \le k \le \min(100, n),−10^9 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
5 0
2 -4 5 -1 7```

### 输出

```
11```

## 样例 #2

### 输入

```
5 1
2 -4 5 -1 7```

### 输出

```
4```

## 样例 #3

### 输入

```
5 2
2 -4 5 -1 7```

### 输出

```
0```

# 题解

## 作者：Reunite (赞：7)

这题应该有紫了吧。

## 一
---

考虑钦定第 $k$ 大为 $x$，定义序列 $b_i=[a_i\ge x]$，则所有合法区间 $[l,r]$ 的条件为 $\sum_{i=l}^rb_i=k$，把全 $0$ 的段缩一下，则总共合法的区间数量只有 $nk$。则转化为，有 $nk$ 个子问题，形如 
$$l \in[x_i,y_i],r \in [p_i,q_i],\max(\sum_{i=l}^{r}a_i-\sum_{i=y_i+1}^{p_i-1}a_ib_i)$$

稍微画一下，就是要求一段区间的前缀后缀最大和。这个可以用 ST 表做到 $O(n\log_2n)-O(1)$，然后确定这些区间段，可以用 set 和链表维护。

## 二
---

时间复杂度 $O(n\log_2n+nk)$，空间 $O(n\log_2n)$。

没人放代码啊，那为放一下：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
#define int long long
using namespace std;

int n,k;
int a[200005];
int b[200005];
int c[200005];
int s[200005];
int lf[200005];
int rt[200005];
int lg[200005];
set <int> st;

struct ST{
	int a[200005];
	int s[200005];
	int ms[21][200005];
	inline void init(){
		for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i],ms[0][i]=a[i];
		for(int j=1;j<=lg[n];j++)
			for(int i=1;i+(1<<j)-1<=n;i++){
				int l=i,r=i+(1<<(j-1))-1;
				ms[j][i]=max(ms[j-1][i],s[r]-s[l-1]+ms[j-1][i+(1<<(j-1))]);
			}
		return ;
	}
	inline int ask(int l,int r){
		if(l>r) return 0;
		int len=lg[r-l+1];
		return max(ms[len][l],ms[len][r-(1<<len)+1]+s[r-(1<<len)]-s[l-1]);
	}
}t1,t2;

inline void in(int &n){
	n=0;
	char c=getchar();bool ok=c=='-';
	while(c<'0' || c>'9') c=getchar(),ok|=c=='-';
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	n=(ok?-n:n);
	return ;
}

inline void relink(int pos){
	auto it=st.insert(pos).first,ti=it;
	ti--;
	it++;
	int x=*ti,y=*it;
	lf[pos]=x,rt[pos]=y;
	rt[x]=pos,lf[y]=pos;
	return ;
}

signed main(){
	in(n),in(k);
	for(int i=1;i<=n;i++){
		in(a[b[i]=i]);
		s[i]=s[i-1]+a[i];
		t1.a[i]=t2.a[n-i+1]=a[i];
		c[i]=a[i];
	}
	if(k==0){
		int s=0,ans=-1e18;
		for(int i=1;i<=n;i++){
			s=max(0ll,s)+a[i];
			ans=max(ans,s);
		}
		printf("%lld\n",ans);
		return 0;
	}
	rt[0]=n+1;
	lf[n+1]=0;
	rt[n+1]=n+1;
	st.insert(0);
	st.insert(n+1);
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	t1.init(),t2.init();
	sort(b+1,b+1+n,[](int x,int y){return a[x]>a[y];});
	int ans=-1e18;
	for(int j=1;j<=n;j++){
		int i=b[j],cc=0,sum=a[i],u=i;
		relink(i);
		c[++cc]=i,sum=a[i];
		while(rt[u]<=n&&cc<k) c[++cc]=rt[u],sum+=a[rt[u]],u=rt[u];
		u=i;
		int ccc=cc;
		while(cc<k&&lf[u]) sum+=a[lf[u]],u=lf[u],cc++;
		if(cc<k) continue;
		cc=ccc;
		while(u&&cc){
			int v=c[cc--];
			int ss=s[v]-s[u-1]-sum;
			ss+=max(0ll,t2.ask(n-u+2,n-lf[u]));
			ss+=max(0ll,t1.ask(v+1,rt[v]-1));
			ans=max(ans,ss);
			sum-=a[v];
			u=lf[u];
			sum+=a[u];
		}
	}
	printf("%lld\n",ans);

	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：7)

这个题是恶评的吧，一眼就会的紫题？

考虑枚举第 $k$ 大值是第 $x$ 个位置，记一个辅助序列 $b_i\in\lbrace0,1\rbrace$，那么 $b_i=1$ 当且仅当 $a_i>a_x$ 或 $a_i=a_x,i>x$。

这个区间 $[l,r]$ 是可以被选出的当且仅当有 $k$ 个 $1$ 存在，只需要寻找前面的 $k$ 个 $1$ 和后面的 $k$ 个 $1$，暴力枚举在这之中恰好有 $k$ 个 $1$ 的子区间，此时 这个区间两端的 $1$ 的位置确定，但是实际的 $l,r$ 可以变动，写个 ST 表查询前缀和最大值最小值即可。

对 $a_i$ 从小到大值域扫描线，可以链表维护上一个 $1$ 的位置以及下一个 $1$。

时间复杂度 $O(nk+n\log n)$.

---

## 作者：Xy_top (赞：3)

这个题是恶评的吧，$120$ 行代码的蓝题？细节还这么多。

先考虑第 $k$ 大的套路，在此题中，观察到 $k$ 很小，容易想到枚举第 $k$ 大。

将所有数字从大到小排序后依次插入，当插入的数字数量 $\geq k+1$ 时，可以钦定当前插入的数字 $x$ 为第 $k+1$ 大。在这个数字的左侧选择 $L$ 个连续且比 $x$ 大的数 $p_1...p_L$，右侧同理选择 $R$ 个，为 $q_1...q_R$，使得 $L+R=k$ ，这样当前数字就是第 $k+1$ 大。然后从 $p_1$ 左侧选取一个连续段，但不要包含大于 $x$ 的，右侧同理，该过程可以通过 前缀和 以及 ``ST 表`` 实现。

为了方便找到左右侧连续比 $x$ 大的数，可以采用链表。维护链表可以采用 ``set``。

卡常建议：``ST`` 表 $2$ 的 $n$ 次方那一项一定要放在前面，不要用 ``cin cout``，再开 ``O2``。

``talk is cheap, show me the code``：


```cpp
#include <bits/stdc++.h>
#define int long long
#define For(i, a, b) for (int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (int i = (a); i >= (b); i --)
using namespace std;
struct Node {int val, loc;}a[200005];
bool cmp (Node n1, Node n2) {return n1.val > n2.val;}
set <pair <int, int> > s;
int n, k, cnt = 1;
int lst[200005], nxt[200005], lis[200005][2];
int lg[200005], pre[18], mi[18][200005], mx[18][200005];
void initst () {
	For (j, 1, 17) {
		for (int i = 0; i + pre[j] - 1 <= n + 1; i ++) {
			mi[j][i] = min (mi[j - 1][i], mi[j - 1][i + pre[j - 1] ]);
			mx[j][i] = max (mx[j - 1][i], mx[j - 1][i + pre[j - 1] ]);
		}
	}
}
int qmin (int x, int y) {
	if (x > y) return 0;
	int l = lg[y - x + 1];
	return min (mi[l][x], mi[l][y - pre[l] + 1]);
}
int qmax (int x, int y) {
	if (x > y) return 0;
	int l = lg[y - x + 1];
	return max (mx[l][x], mx[l][y - pre[l] + 1]);
}
int qsum (int x, int y) {
	return mx[0][y] - mi[0][x - 1];
}
void solve () {
	lg[1] = 0;
	For (i, 0, 17) pre[i] = 1 << i;
	For (i, 2, 200000) lg[i] = lg[i / 2] + 1;
	scanf ("%lld%lld", &n, &k);
	For (i, 1, n) {
		scanf ("%lld", &a[i].val);
		mi[0][i] = mi[0][i - 1] + a[i].val;
		mx[0][i] = mx[0][i - 1] + a[i].val;
		a[i].loc = i;
	}
	mi[0][n + 1] = mi[0][n];
	mx[0][n + 1] = mx[0][n];
	if (k == 0) {
		int mx = -1000000000, ans = 0, sum = 0;
		For (i, 1, n) {
			sum += a[i].val;
			mx = max (mx, a[i].val);
			sum = max (sum, 0LL);
			ans = max (ans, sum);
		}
		if (mx < 0) printf ("%lld", mx);
		else printf ("%lld", ans);
		return;
	}
	initst ();
	sort (a + 1, a + n + 1, cmp);
	For (i, 1, n) {
		lis[i][0] = a[i].val;
		lis[i][1] = a[i].loc;
	}
	s.insert (make_pair (a[1].loc, 1LL) );
	int ans = 0;
	For (i, 2, n) {
		++ cnt;
		s.insert (make_pair (a[i].loc, i) );
		auto it = s.find (make_pair (a[i].loc, i) );
		if (it != s.begin () ) {
			-- it;
			int x = (it -> second);
			lst[i] = x;
			nxt[x] = i;
			++ it;
		}
		++ it;
		if (it != s.end () ) {
			int x = (it -> second);
			nxt[i] = x;
			lst[x] = i;
		}
 		if (i >= k + 1) {
			int l = i, lcnt = 0, r = i, rcnt = 0, s = 0;
			while (lst[l] && lcnt < k) {
				l = lst[l];
				s += lis[l][0];
				++ lcnt;
			}
			while (nxt[r] && lcnt + rcnt < k) {
				r = nxt[r];
				s += lis[r][0];
				++ rcnt;
			}
			int x = lis[l][1], y = lis[r][1];
			ans = max (ans, qsum (x, y) + mi[0][x - 1] - qmin ( (!lst[l] ? 0LL : lis[lst[l] ][1]), x - 1) + qmax (y, (!nxt[r] ? n + 1 : lis[nxt[r] ][1] - 1) ) - mx[0][y] - s);
			while (nxt[r]) {
				s -= lis[l][0];
				l = nxt[l];
				r = nxt[r];
				s += lis[r][0];
				int x = lis[l][1], y = lis[r][1];
				ans = max (ans, qsum (x, y) + mi[0][x - 1] - qmin (lis[lst[l] ][1], x - 1) + qmax (y, (!nxt[r] ? n : lis[nxt[r] ][1] - 1) ) - mx[0][y] - s);
				if (l == i) break;
			}
		}
	}
	printf ("%lld", ans);
}
signed main () {
	int _ = 1;
//	cin >> _;
	while (_ --) {
		solve ();
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：苏联小渣 (赞：3)

upd：修改了一下表述，之前讲得不太清楚。

相当于选出一个区间使得区间和减去前 $k$ 大之和最大。

考虑 $k$ 大值的技巧，包括超级钢琴、二分等等，但是同时还有枚举第 $k$ 大值。

假设我们枚举第 $k$ 大值，那么我们只需要找到一个包含它的区间，使得在这个区间它是第 $k$ 大就好了。

如果我们从大往小加入每个数，每次加到一个数时，考虑它作为第 $k$ 大值的贡献。假如当前加入的数按照原数组下标排序分别是 $a_{p_1},...,a_{p_m}$，那么对于当前加入的数 $a_{p_x}$，我们只需要找到 $l \le x \le r$ 使得 $r-l+1=k$，然后在 $(p_{l-1},p_l]$ 中找一个数作为左端点，在 $[p_r,p_{r+1})$ 中找一个数作为右端点，使得区间和减去前 $k$ 大值最大。

换句话说，我们对于每一个数 $a_x$，考虑它作为第 $k$ 大值的贡献，容易发现，我们只需要在 $x$ 左边找到 $L$ 个 $\ge a_x$ 的数，在 $x$ 的右边找到 $R$ 个 $\ge a_x$ 的数，满足 $L+R+1=k$。设左边第 $L$ 个的位置为 $p_0$，第 $L+1$ 个位置为 $p_1$；右边第 $R$ 个位置为 $q_0$，第 $R+1$ 个位置为 $q_1$，我们只需要在 $(p_0,p_1]$ 中找一个左端点，在 $[q_0,q_1)$ 中找一个右端点，使得和最大即可。

注意到此时前 $k$ 大之和变成了定值，所以问题变成了在两个区间中找两个数分别使得前缀和最大、最小，用 ST 表可以做到 $O(1)$ 查询。对于找到左右边若干个比它大的数，将原数组从大到小排序后，用 set 维护位置再用链表模拟即可。时间复杂度 $O(nk+n \log n)$。

---

## 作者：P2441M (赞：2)

## 题意简述
给定 $k$ 和一个长度为 $n$ 的序列 $a$，定义一个区间 $[l,r](l\leq r\land r-l+1\geq k)$ 的权值为 $a[l,r]$ 中除去前 $k$ 大的元素和。求出最大权值。

对于所有数据，$1\leq n\leq 2\times 10^5$，$0\leq k\leq \min(100,n)$，$-10^9\leq a_i\leq 10^9$。

## 题解
有点乱炖的意思了。

对这种权值的一类刻画方式就是枚举某个特定的值。在本题中，容易想到枚举第 $k$ 大 $a_p$。

思考怎样的区间 $l\leq p\leq r$ 会使得 $a_p$ 为该区间的第 $k$ 大。对于排序网络相关的问题，考虑构造 $0/1$ 序列。具体来说，构造 $0/1$ 序列 $b_i=[a_i\geq a_p]$，那么区间 $[l,r]$ 合法的充要条件就是 $\sum_{i=l}^r b_i=k$。并且容易注意到，一个区间的权值，转化为了**所有为 $0$ 的位置对应的元素和**。

注意到 $k$ 很小，考虑从这里入手去做一些偏暴力的东西。一个自然的想法就是分别找到 $a_p$ 左右侧的 $k-1$ 个 $1$，得到最多 $2k-1$ 个 $1$，那么我们就可以 $O(k)$ 地枚举出区间和为 $k$ 的所有合法区间。

假装我们已经可以找到这些 $1$，然后正在枚举某个区间和为 $k$ 且两端都是 $1$ 的区间 $[l,r]$，这时候我们肯定是保证区间和不变的基础上，尝试拓展区间的两端到 $[l',r']$。 显然可以贪心，以左端点为例，设 $l$ 前面最近的 $1$ 的位置为 $l_1$，那么我们就要求出

$$
\begin{align*}
& \min_{l'=l_1+1}^l\sum_{i=l'}^l a_i \\
=& \min_{l'=l_1+1}^l\{s_l-s_{l'-1}\} \\
=& s_l-\min_{l'=l_1+1}^l\{s_{l'-1}\}
\end{align*}
$$

其中 $s$ 为 $a$ 的前缀和序列。对 $s$ 建立 ST 表即可 $O(1)$ 求出上面的东西，右端点同理。还有一部分是 $[l,r]$ 中 $0$ 的位置对应的元素和，这个直接枚举区间的过程中存一下就行了。把这些值全部加起来就是这个区间能得到的最大权值，和答案取 $\max$ 即可。

最后就是怎么找到 $a_p$ 左右侧的 $k-1$ 个 $1$。这个也很典。对 $a$ 建立一个链表，然后从小到大扫每个元素，直接在链表上分别跳 $k-1$ 次前驱和后继就是我们要找的 $1$，最后在链表中把当前元素删掉即可。

时间复杂度为 $O(n\log{n}+nk)$。

## 实现 & 代码
细节还是有点多的。

首先把 $k=0$ 特判掉，枚举端点，用建出来的 ST 表就可以做，注意这种 case **答案不能和 $0$ 取 $\max$**，因为 $l\leq r$，我们不能不选。

$k>0$ 的情况在枚举区间时可能会有一些边界问题，改成左右各找 $k$ 个 $1$ 可以实现得更优雅一些。

应该没啥了，贴个代码。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 2e5 + 5, LOGN = 18 + 5, K = 205;
const ll INF = 1e16;

int n, k, a[N], lg2[N];
int szc, c[K];
int top, stk[K];
pii b[N];
ll ans = -INF, s[N];

struct ST {
	ll mx[LOGN][N], mn[LOGN][N];
	void init() {
		for (int i = 0; i <= n; ++i) mx[0][i] = mn[0][i] = s[i];
		for (int i = 1; i <= lg2[n + 1]; ++i)
			for (int j = 0; j <= n - (1 << i) + 1; ++j)
				mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << (i - 1))]),
				mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 << (i - 1))]);
	}
	ll query_mx(int l, int r) {
		int k = lg2[r - l + 1];
		return max(mx[k][l], mx[k][r - (1 << k) + 1]);
	}
	ll query_mn(int l, int r) {
		int k = lg2[r - l + 1];
		return min(mn[k][l], mn[k][r - (1 << k) + 1]);
	}
} st;

int pos[N], id[N];
struct List {
	int tot, head, tail, prv[N], nxt[N], val[N];
	void init() {
		head = 1, tail = 2; tot = 2;
		nxt[head] = tail, prv[tail] = head;
		id[head] = 0, id[tail] = n + 1;
	}
	void insert(int p, int v) {
		int q = ++tot; val[q] = v;
		nxt[q] = nxt[p], prv[nxt[p]] = q;
		prv[q] = p, nxt[p] = q;
	}
	void del(int p) { prv[nxt[p]] = prv[p], nxt[prv[p]] = nxt[p]; }
} lt;

void preproc() {
	lg2[1] = 0;
	for (int i = 2; i <= n + 1; ++i) lg2[i] = lg2[i >> 1] + 1;
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> k; lt.init();
	int last = lt.head;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i]; b[i] = { a[i], i };
		s[i] = s[i - 1] + a[i];
		lt.insert(last, a[i]), last = pos[i] = lt.tot, id[lt.tot] = i;
	}
	preproc(), st.init();
	sort(b + 1, b + n + 1);
	for (int i = 1; i <= n; ++i) {
		if (!k) { chk_max(ans, s[i] - st.query_mn(0, i - 1)); continue; }
		int p = pos[b[i].second];
		stk[++top] = p, p = lt.prv[p];
		for (int cnt = 1; cnt <= k && p; ++cnt, p = lt.prv[p]) stk[++top] = p;
		szc = -1;
		while (top) c[++szc] = stk[top--];
		p = lt.nxt[pos[b[i].second]];
		for (int cnt = 1; cnt <= k && p; ++cnt, p = lt.nxt[p]) c[++szc] = p;
		--szc;
		ll sum = 0;
		for (int j = 1; j <= k; ++j) sum += a[id[c[j]]];
		for (int j = 1; j <= szc - k + 1; ++j) {
			int l = id[c[j - 1]], r = id[c[j]] - 1;
			ll lmx = s[r] - st.query_mn(l, r);
			l = id[c[j + k - 1]], r = id[c[j + k]] - 1;
			ll rmx = st.query_mx(l, r) - s[l];
			ll md = s[id[c[j + k - 1]]] - s[id[c[j]] - 1] - sum;
			chk_max(ans, lmx + rmx + md);
			sum += a[id[c[j + k]]] - a[id[c[j]]];
		}
		lt.del(pos[b[i].second]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：寄风 (赞：1)

神秘乱搞申请出战！！1

省流：一点都不对的乱搞。

首先定义下文的答案区间为最后你选择的那个区间。

然后你要会算固定区间的答案。具体的，就是你开一个堆维护前 $k$ 大就可以算了。

就你首先算一下样例，发现了一个非常厉害的事情，就是样例的答案区间其实就是原序列的最大子段和区间！！

但是你写一发发现这是错的。

然后你考虑对于每个点求出以这个点结尾的所有子段里面和最大的那个，这个你直接按照最大子段和求法 dp 一下就可以做。

然后你考虑从这个里面取子段和前 $100$ 大的子段拿出来算答案，通过直觉感受一下答案区间距离这个子段不是很多，所以你对每个提出来的子段左右扰动 $3$ 个点去算答案。

然后你就可以 $47$ 分了，并且只错了很少的点。

那么你观察到前 $100$ 大的子段里其实有很多子段是无效的，所以你考虑再对于每个点向后扫 $10$ 个点计算答案，最后将两个答案取较大值即可。

然后这个很没道理的东西就过了。

```cpp
#include <bits/stdc++.h>

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using i128 = __int128;
using u128 = unsigned __int128;

#define int i64

constexpr int N = 2e5 + 5;

int n, k, l, r, a[N], dp[N], id[N], s[N];
std::tuple<int, int, int> nw[N];

inline int calc(int l, int r) {
    if (!l || r > n) return 0;
    std::priority_queue<int, std::vector<int>, std::greater<int> > q;

    int s = 0, ss = 0;

    for (int i = l; i <= r; i++) {
        if (q.size() < k) {
            q.push(a[i]);
            s += a[i];
        } else {
            int xx = q.top();
            if (xx < a[i]) {
                s -= xx;
                q.pop();
                q.push(a[i]);
                s += a[i];
            }
        }
        ss += a[i];
    }

    return ss - s;
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    std::cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
        id[i] = i + 1;
        s[i] = a[i];
    }

    for (int i = 1; i <= n; i++) {
        if (dp[i - 1] > 0) {
            id[i] = id[i - 1];
            dp[i] = dp[i - 1];
        } else {
            id[i] = i;
            dp[i] = 0;
        }
        dp[i] += a[i];
        s[i] = s[i - 1] + a[i];
    }
    
    if (!k) {
        std::cout << (*std::max_element(dp + 1, dp + n + 1)) << '\n';
        return 0;
    } 

    // int maxn = -1e9;

    for (int i = 1; i <= n; i++) {
        // if (maxn < dp[i] && i - id[i] + 1 >= k) {
        //     maxn = dp[i];
        //     l = id[i];
        //     r = i;
        // }
        nw[i] = std::make_tuple(dp[i], id[i], i);
    }

    std::sort(nw + 1, nw + n + 1, std::greater<std::tuple<int, int, int>>());

    int ct = 0, i = 1;
    int maxn = 0;
    while (i <= n && ct <= 100) {
        while (i <= n && std::get<2> (nw[i]) - std::get<1> (nw[i]) + 1 < k) i++;
        if (i > n) break;
        maxn = std::max(maxn, calc(std::get<1> (nw[i]), std::get<2> (nw[i])));
        for (int kk = 1; kk <= 3; kk++) {
            maxn = std::max(maxn, calc(std::get<1> (nw[i]) - kk, std::get<2> (nw[i])));
            maxn = std::max(maxn, calc(std::get<1> (nw[i]), std::get<2> (nw[i]) + kk));
            maxn = std::max(maxn, calc(std::get<1> (nw[i]) - kk, std::get<2> (nw[i]) + kk));
        }
        ct++;
    }
    int ans = maxn;
    for (int i = 1; i <= n; i++) {
        std::priority_queue<int, std::vector<int>, std::greater<int> > q;

        int rs = 0;

        for (int j = i; j <= std::min(n, i + 10); j++) {
            if (q.size() < k) {
                q.push(a[j]);
                rs += a[j];
            } else {
                int xx = q.top();
                if (xx < a[j]) {
                    rs -= xx;
                    q.pop();
                    q.push(a[j]);
                    rs += a[j];
                }
            }
            if (q.size() >= k) ans = std::max(ans, s[j] - s[i - 1] - rs);
        }
    }
    maxn = ans;

    std::cout << maxn;

    return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

先特判 $k=0$。

可以从大到小枚举数，然后把数字变成 $0$，显然变成 $0$ 的数字是负数是不优的，因为剩下的也是负数。

因为变成 $0$ 的数是正数，因此只关注有 $k$ 个删除位置的区间，可以发现一个点删除之后影响了 $k$ 个区间，于是有 $\mathcal{O}(nk\log n)$ 的做法。多的 $\log$ 在于每次都重新求前缀、后缀最大值等。

发现我们关注的是一段区间的前缀最大值、后缀最大值、总和。然后扫 $\mathcal{O}(k)$ 个点即可。于是 $\mathcal{O}(nk+n\log n)$。

corner case : $k=0$ 的时候所有数字是负数的情况。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid (l + r >> 1)
using namespace std;
const int N = 2e5 + 5;
int n, k, a[N], id[N], nxt[N], pre[N], ans;
int x, cnt, y, sum, maxn = -0x3f3f3f3f3f3f3f3f;
set<int> s;
struct node{
    int lmax, rmax, maxn, sum;
}t[N << 2], aa[N];
inline node operator + (node x, node y){
    node z;
    z.lmax = max(x.lmax, x.sum + y.lmax);
    z.rmax = max(x.rmax + y.sum, y.rmax);
    z.maxn = max(max(x.maxn, y.maxn), x.rmax + y.lmax);
    z.sum = x.sum + y.sum;
    return z;
}
inline void build(int p, int l, int r){
    if(l == r){
        t[p].lmax = t[p].rmax = t[p].maxn = max(a[l], 0ll);
        t[p].sum = a[l];
        return ;
    }
    build(ls, l, mid);
    build(rs, mid + 1, r);
    t[p] = t[ls] + t[rs];
}
inline void upd(int p, int l, int r, int x, int v){
    if(l == r){
        t[p].lmax = t[p].rmax = t[p].maxn = max(v, 0ll);
        t[p].sum = v;
        return ;
    }
    if(mid >= x) upd(ls, l, mid, x, v);
    else upd(rs, mid + 1, r, x, v);
    t[p] = t[ls] + t[rs];
}
inline node query(int p, int l, int r, int x, int y){
    if(x <= l && r <= y) return t[p];
    if(mid >= x && mid < y){
        return query(ls, l, mid, x, y) + query(rs, mid + 1, r, x, y);
    }
    if(mid >= x) return query(ls, l, mid, x, y);
    return query(rs, mid + 1, r, x, y);
}
inline void ins(int l, int x, int r){
    nxt[x] = r, pre[x] = l;
    nxt[l] = x, pre[r] = x;
    upd(1, 1, n, x, 0ll);
    aa[l] = query(1, 1, n, l + 1, x);
    aa[x] = query(1, 1, n, x, r - 1);
    s.insert(x);
}
inline void chkmax(int &x, int y){
    if(x < y) x = y;
}
signed main(){
    // freopen("cute.in", "r", stdin);
    // freopen("cute.out", "w", stdout);
    scanf("%lld%lld", &n, &k);
    for(int i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
        maxn = max(maxn, a[i]);
    }
    for(int i = 1; i <= n; i++) id[i] = i;
    sort(id + 1, id + n + 1, [&](int x, int y){
        return a[x] > a[y];
    });
    build(1, 1, n);
    aa[0] = query(1, 1, n, 1, n);
    if(k == 0){
        if(maxn < 0) printf("%lld\n", maxn);
        else printf("%lld\n", t[1].maxn);
        return 0;
    }
    nxt[0] = n + 1, pre[n + 1] = 0;
    s.insert(0), s.insert(n + 1);
    for(int i = 1; i < k; i++){
        auto it = s.lower_bound(id[i]);
        ins(*(prev(it)), id[i], *it);
        // cerr << (*prev(it)) << ' ' << id[i] << ' ' << (*it) << endl;
    }
    for(int I = k; I <= n; I++){
        if(a[id[I]] < 0) break ;
        auto it = s.lower_bound(id[I]);
        ins(*(prev(it)), id[I], *it);
        for(x = id[I], cnt = 1; cnt <= k; cnt++, x = pre[x]);
        y = x;
        for(int i = 1; i <= k; i++) y = nxt[y];
        sum = 0ll;
        for(int i = nxt[x]; i ^ y; i = nxt[i]) sum += aa[i].sum;
        chkmax(ans, sum + aa[x].rmax + aa[y].lmax);
        for(int i = nxt[x], j = nxt[y]; (j ^ (n + 1)) && i <= id[I]; i = nxt[i], j = nxt[j]){
            sum -= aa[i].sum, sum += aa[pre[j]].sum;
            chkmax(ans, sum + aa[i].rmax + aa[j].lmax);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：dAniel_lele (赞：1)

考虑钦定前 $k$ 大中最小的 $a_i$。

从大往小往一个集合内加入 $a_i$，不妨设 $a_i$ 是前 $k$ 大中最小的。考虑将目前已经加入的位置中 $i$ 周围的 $2k$ 个（左边 $k$ 的，右边 $k$ 个），不妨设为 $pos_1<pos_2<\dots<pos_{k+1}=i<\dots<pos_{2k+1}$。此时，所有 $l\in(pos_{i-1},pos_i],r\in[pos_{i+k-1},pos_{i+k})$ 的 $[l,r]$ 区间扣减的量均已经确定（为 $\sum_{j=i}^{i+k-1}a_{pos_j}$）。考虑将这些区间统一计算。

于是，我们将题目转化为以下两个问题：

* 动态加入数求周围 $2k$ 个数。
* 求一个区间所有前缀/后缀中和最大的。

动态加入数求周围 $2k$ 个数是容易的，考虑使用 `set` 维护已经存在的点，链表求周围 $2k$ 个数，这样做复杂度是 $O(nk+n\log n)$ 的。

求一个区间所有前缀/后缀中和最大的时可以考虑倍增预处理。以前缀为例，先求出所有 $[i,i+2^k)$ 的答案 $f_{i,k}$。对于求 $[l,r]$ 的答案，可以找出最大的 $2^k\leq r-l+1$，答案即为 $\max(f_{l,k},f_{r-2^k+1,k}+\sum_{i=l}^{r-2^k}a_i)$。这样做预处理 $O(n\log n)$，单次询问 $O(1)$。

总复杂度 $O(n\log n+nk)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
set<int> st;
int lst[200005],nxt[200005];
int a[200005],pre[200005];
int f[200005][20],g[200005][20],lg2[200005];
int qryl(int l,int r){
	int k=lg2[r-l+1];
	return max(f[l][k],f[r-(1<<k)+1][k]+pre[r-(1<<k)]-pre[l-1]);
}
int qryr(int l,int r){
	int k=lg2[r-l+1];
	return max(g[r][k],g[l+(1<<k)-1][k]+pre[r]-pre[l+(1<<k)-1]);
} 
int tmp[215];
int rpre[215];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	for(int i=2;i<=200000;i++) lg2[i]=lg2[i/2]+1;
	int n,k; cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],pre[i]=pre[i-1]+a[i];
	if(k==0){
		int sum=0,maxv=-1e18;
		for(int i=1;i<=n;i++){
			sum+=a[i];
			maxv=max(maxv,sum);
			if(sum<0) sum=0;
		}
		cout<<maxv;
		return 0;
	}
	for(int i=1;i<=n;i++) f[i][0]=a[i],g[i][0]=a[i];
	for(int j=1;j<=19;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]+pre[i+(1<<(j-1))-1]-pre[i-1]);
			g[i+(1<<j)-1][j]=max(g[i+(1<<j)-1][j-1],g[i+(1<<(j-1))-1][j-1]+pre[i+(1<<j)-1]-pre[i+(1<<(j-1))-1]);
		}
	}
	vector<pair<int,int>> vc;
	for(int i=1;i<=n;i++) vc.push_back(make_pair(a[i],i));
	sort(vc.begin(),vc.end());
	reverse(vc.begin(),vc.end());
//	cout<<"OK"<<endl;
	int ans=0;
	for(auto v:vc){
		int pos=v.second;
//		cout<<v.first<<" "<<v.second<<"\n";
		auto p=st.lower_bound(pos);
		if(p!=st.end()){
			nxt[pos]=*p;
			lst[*p]=pos;
		}
		else nxt[pos]=n+1;
		if(p!=st.begin()){
			p=prev(p);
			lst[pos]=*p;
			nxt[*p]=pos; 
		}
		else lst[pos]=0;
		st.insert(v.second);
//		cout<<v.first<<" "<<v.second<<endl;
		int l=101,r=103,now;
		tmp[102]=pos;
		for(now=lst[pos];l>=102-k-1&&now!=0;l--,now=lst[now]) tmp[l]=now;
		if(now==0) tmp[l]=0;
		else l++;
		for(now=nxt[pos];r<=102+k+1&&now!=n+1;r++,now=nxt[now]) tmp[r]=now;
		if(now==n+1) tmp[r]=n+1;
		else r--;
		rpre[l]=0;
		for(int i=l+1;i<=r;i++) rpre[i]=rpre[i-1]+a[tmp[i]];
		for(int i=l+1,j=l+k;j<r;i++,j++){
			int ext=pre[tmp[j]-1]-pre[tmp[i]]-(rpre[j]-rpre[i-1]);
			ans=max(ans,qryl(tmp[j],tmp[j+1]-1)+qryr(tmp[i-1]+1,tmp[i])+ext);
		}
	}
    cout<<ans;
	return 0;
}
```

---


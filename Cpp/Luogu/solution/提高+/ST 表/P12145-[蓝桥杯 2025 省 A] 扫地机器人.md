# [蓝桥杯 2025 省 A] 扫地机器人

## 题目描述

在一个含有 $n$ 个点 $n$ 条边的无重边无自环的连通无向图中，有一个扫地机器人在执行清扫作业。其中结点 $i$ 的标记 $t_i \in \{0,1\}$：如果为 $1$，则说明该结点需要进行清扫，扫地机器人在到达这个结点时会顺便进行清扫工作。机器人想知道，如果选定任意结点出发，每条边只能经过一次的话，最多能清扫多少个待清扫结点？

## 说明/提示

### 样例说明
其中一种可行路线：$3 \rightarrow 1 \rightarrow 4 \rightarrow 6 \rightarrow 7$，清扫结点 $3, 1, 6, 7$（共 $4$ 个）。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 500000$，$t_i \in \{0,1\}$，$1 \leq u_i, v_i \leq n$。

## 样例 #1

### 输入

```
9
1 0 1 0 0 1 1 0 1
2 8
2 9
2 5
1 5
1 3
1 4
4 5
4 6
6 7```

### 输出

```
4```

# 题解

## 作者：Clclclcl (赞：12)

这题和这 [Island](https://www.luogu.com.cn/problem/P4381) 这题类似，是基环树直径的板子，不过这题是边权改成点权罢了，因为题目规定是每条边只能经过一次，没有规定点只能走一次且权值在点上，所以存在一种特殊情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/jsj61nar.png)
这种可以从环上一个子树内出发绕过环回到该子树，这明显不是基环树的直径，即**环上权值和+某棵子树的根节点最长路径+该棵子树根节点的次长路径**。特判完这种情况剩下的就是基环树直径板子了。

接下来考虑基环树直径怎么求？首先基环树最经典的思路是把环上每个点当成一棵子树的根，将基环树拆成若干子树再进行分析。
![](https://cdn.luogu.com.cn/upload/image_hosting/jvo1abc0.png)
如上图，基环树直径分俩种情况，一种是挂在某一棵子树上，一种是经过某一棵子树的最长链再经过环走到另一棵子树的最长链。

对于第一种情况就是求树的直径的经典求法，不会的同学可以做[树的直径](https://www.luogu.com.cn/problem/B4016)这题。不过我们需要先找到基环树的环对环上每个点当根求树的直径，预处理出每个节点当根的最长链（这我们后面考虑第二种情况需要用到），对于找环拓扑排序即可很容易求得。

第二种情况就稍微麻烦，需要用到单调队列优化环上 DP。设 $f[i]$ 为以 $i$ 为根的最长链，设环上 $i$,$j$ 俩点的距离为 $dist$,$w[i]$ 为点权，那么俩棵子树最大距离为 $f[i] - w[i] + dist + f[j] - w[j]$。

环上问题最经典的操作是破环成链，将环拆开复制一遍接到后面，设 $dist[i]$ 为 $[1,i]$ 的路径点权前缀和，$f[i]$ 为减去 $i$ 点点权的最长链，减去点权因为会和 $dist$ 数组重复计算该值。
那么式子应该为：$dist[i] - dist[j - 1] + f[i] + f[j]$ 可以发现要使得该值最大需要 $(f[j] - dist[j - 1])$ 最大，设环长为 $cnt$ ,则应该取区间 $[\max(1,i - cnt + 1),i - 1]$ 的最大值，很明显可以使用单调队列优化这一过程，单调队列维护 $f[i] - dist[i - 1]$ 的最大值转移即可。下面是具体代码细节。

```cpp
# include <bits/stdc++.h>

using namespace std;
# define pb push_back
# define fi first
# define se second
typedef pair<int,int> PII;
int n, m,k;

void solve() {
    cin >> n;
    vector <vector<int>> g(n + 1);
    vector<int> d(n + 1,0),w(n + 1,0);
    for(int i = 1;i <= n;i ++ ) cin >> w[i];
    for(int i = 1;i <= n;i ++ ){
    	int l,r;
    	cin >> l >> r;
    	g[r].pb(l);
    	g[l].pb(r);
    	d[r] ++;
    	d[l] ++;
    }
    vector<int> st(n + 1,0);
    vector<int> f1(2 * n + 2,0),f2(2 * n + 1,0); // f1 为子树内最长链,f2 为次长。
    vector<int> vis(n + 1,0);
    auto work = [&] (int root) ->int{
    	int ans = 0;
    	queue <int> q1; 
    	for(int i = 1;i <= n;i ++){
    		st[i] = 1;
    		if(d[i] == 1){
    			q1.push(i);
    		}
    	}
    	while(q1.size()){
    		auto u = q1.front();
    		q1.pop();
    		vis[u] = 1;// topsort 标记环。
    		for(auto l : g[u]){
    			if( -- d[l] == 1) q1.push(l);
    		}
    	}

    	auto dfs = [&] (auto dfs,int u,int fa) -> void{
            f1[u] = w[u],f2[u] = w[u];
    		for(auto l : g[u]){
    			if(!vis[l] || l == fa) continue;
    			dfs(dfs,l,u);
    			if(f1[l] + w[u] > f1[u]){
    				f2[u] = f1[u];
    				f1[u] = f1[l] + w[u];
    			}
    			else f2[u] = max(f2[u],f1[l] + w[u]);
    		}
    		ans = max(ans,f1[u] + f2[u] - w[u]); //这是第一种情况。
    	};
    	int st = 0,cnt = 0;
    	for(int u = 1;u <= n;u ++ ){
    		if(!vis[u]){ // 拆环,对于环上每个点当 root 跑树的直径。
    			st = u;
    			++ cnt; // 累计环长。
    			dfs(dfs,u,0);
    		}
    	}
        // 对于环上点重新赋值下标方便破环成链。
    	vector<int> dp(2 * cnt + 2,0),dist(2 * cnt + 2,0),dp1(2 * cnt + 1,0);
    	int id = 0;
    	int pre = 0;
    	auto dfs1 = [&] (auto dfs1,int u,int fa) ->void{
    		dp[++ id] = f1[u] - w[u]; // 环上每个点重新赋 id,减去点权因为会和 dist 数组重复计算。
            dp1[id] = f2[u] - w[u];
            dist[id] = w[u];
    		vis[u] = 1;
    		for(auto l : g[u]){
    			if(l == fa || vis[l]) continue;
    			dfs1(dfs1,l,u);
    		}
    	};
    	dfs1(dfs1,st,0);

        // 破环成链，复制一遍。
    	for(int i = 1;i <= cnt;i ++ ) dp[i + cnt] = dp[i],dist[i + cnt] = dist[i];
    	for(int i = 1;i <= 2 * cnt;i ++ ) dist[i] += dist[i - 1];//环上前缀和。
        // 这是这一题的坑点,需要特判环上点权之和加上某一棵子树根的最长链加次长链。
        for(int i = 1;i <= cnt;i ++ ) ans = max(ans,dist[cnt] + dp[i] + dp1[i]);
        deque <PII> q;
    	for(int i = 1;i <= 2 * cnt;i ++ ){
    		while(q.size() && i - q.front().fi + 1 > cnt) q.pop_front(); // 保证区间不超过环长
    		if(q.size()){
    			ans = max(ans,dp[i] + q.front().se + dist[i]);
    		}
    		while(q.size() && q.back().se < dp[i] - dist[i - 1]) q.pop_back(); // 维护队列单调。
    		q.pb({i,dp[i] - dist[i - 1]});
    	}

    	return ans;
    };
    
    int res = 0;
    for(int i = 1;i <= n;i ++ ){ // 该题不是基环树森林可不必枚举每个点。
    	if(!st[i]){
    		st[i] = 1;
    		res += work(i);
    	}
    }
    cout << res << endl;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int _ = 1;
    //cin >> _ ;
    while( _ -- )
    {
        solve();
    }
    return 0;
}
```

---

## 作者：未来姚班zyl (赞：8)

第一眼：什么野鸡比赛，压轴题是基环树直径板子？

交上去 WA 了：我是什么野鸡？

仔细研究后：什么野鸡比赛，OI 赛制 Corner Case 没有样例？

基环树直径板子，不经过环上的边则直接树形 dp 求直径的方法即可，经过环上的可以单调队列优化一下。获得 $50$ 分。

为啥？因为是每条边最多经过一次，所以可以从环上一个点的子树出发，绕过整个环，再走回去，特判一下即可。

我认为，就这种题，配这种大样例，还是纯 OI 赛制，应该比大部分紫题都难场切。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
#define OK y^fa&&!in[y]
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
#define yy return puts("Yes"),void()
#define nn return puts("No"),void()
#define YY puts("Yes"),exit(0)
#define NN puts("No"),exit(0) 
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=5e5+5,M=1e6+5,inf=(1LL<<31)-1,mod=1e9+7;
const ll llf=1e18;
int n,h[N],to[N<<1],nxt[N<<1],cnt=1;
inline void add_(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
int a[N],f[N],s[N<<1],tp,ans,g[N<<1];
bool v[N],in[N];
inline int dfs(int x,int fr){
	v[x]=1;
	e(x)if(i^fr^1){
		if(!v[y]){
			int w=dfs(y,i);
			if(w==0)continue;
			if(w==-1)return -1;
			s[++tp]=y,in[y]=1;
			if(w==x)return -1;
			return w;
		}else return s[++tp]=y,in[y]=1,y;
	}
	return 0;
}
int pr[N<<1];
inline void dfs_(int x,int fa){
	f[x]=a[x],g[x]=a[x];
	e(x)if(OK){
		dfs_(y,x);
		g[x]=max(g[x],f[x]+f[y]);
		ans=max(ans,f[x]+f[y]),f[x]=max(f[x],a[x]+f[y]);
	}
	ans=max(ans,f[x]);
}
int q[N<<1];
inline void Main(){
	n=read();
	repn(i)a[i]=read();
	repn(i){
		int x=read(),y=read();
		add_(x,y),add_(y,x);
	}
	dfs(1,0);
	rep(i,1,tp)s[i+tp]=s[i];
	rep(i,1,tp<<1)pr[i]=pr[i-1]+a[s[i]];
	rep(i,1,tp)dfs_(s[i],0),f[s[i]]-=a[s[i]];
	int h=1,t=0;
	rep(i,1,tp<<1){
		while(h<=t&&q[h]<=i-tp)h++;
		if(h<=t)ans=max(ans,f[s[i]]+f[s[q[h]]]+pr[i]-pr[q[h]-1]);
		while(h<=t&&f[s[i]]-pr[i-1]>=f[s[q[t]]]-pr[q[t]-1])t--;
		q[++t]=i;
	}
	rep(i,1,tp)ans=max(ans,g[s[i]]+pr[tp]-a[s[i]]);
	cout <<ans;
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}

```

---

## 作者：arrow_king (赞：0)

基环树直径模板题，但是考验选手眼力。

常规的基环树直径是有两种情况：小树的直径，或者是两棵小树最大权根叶链 + 两侧环路径的最大值。但是这题只要求边不能重复经过，没说点不能重复经过，因此当小树的根有 $>$ 两个儿子的时候有第三种情况，即从一个叶子走到根，绕着环走一圈走到这个点再向下走到一个叶子。

第一种和第三种情况都较为简单，求出每棵小树的直径以及从根节点向下的最大链与次大链即可。第二种情况中我们只需要小树的根到叶子的最大链。不妨断环成链，并记 $s_i$ 表示链上前 $1\sim i$ 的权值和，$f_i$ 表示链上第 $i$ 个点对应小树的最大链权值，那么答案就是
$$
\max_{\substack{1\le i<j\le 2L-1\\j-i<L}}\{f_i+f_j+s_{j-1}-s_i\}
$$
由于断环成链，原环长为 $L$，则链长度为 $2L-1$。由于不能绕环走多圈，因此要限制两个下标的距离小于 $L$。这里只讨论了沿着环的一个方向运动的情况，另一种是完全对称的，处理方式相同。

设 $a_i=f_i-s_i$，$b_i=f_i+s_{i-1}$，那么对于某个 $j$，以其为右端点的答案就是
$$
b_j+\max_{j-L<i<j}\{a_i\}
$$
容易发现这是一个滑动窗口问题，使用单调队列优化就可以在 $O(L)$ 内解决。

最终的答案是这三种情况的最大值，复杂度 $O(n)$。代码中展示的是比较难写的第二种情况。

```cpp lines=1-1
il int Calc(int pos) {return F[bin[pos]]-sum[pos];} //下方代码中 Calc 函数的定义


for(int i=tot+1;i<=2*tot;++i) bin[i]=bin[i-tot];
for(int i=1;i<=2*tot;++i) sum[i]=sum[i-1]+a[bin[i]];
head=1,tail=1;que[head]=1,dp[1]=a[1];
for(int i=2;i<=2*tot;++i) {
	while(head<=tail&&i-que[head]>=tot) ++head;
	dp[i]=Calc(que[head])+sum[i-1]+F[bin[i]];
	while(head<=tail&&Calc(que[tail])<Calc(i)) --tail;
	que[++tail]=i;
	ans=max(ans,dp[i]);
}
reverse(bin+1,bin+tot+1);
//...  和上面的处理方式完全相同
printf("%d\n",ans);
}
```

::::info[Fun Fact]
校内模拟赛搬这个题，非常好地模拟了原题中第三种情况 OI 赛制不放大样例、不判第三种情况只能得到 $50$ 分的优良特性。
::::

---


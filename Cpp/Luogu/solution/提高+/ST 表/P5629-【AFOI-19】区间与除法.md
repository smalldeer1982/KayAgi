# 【AFOI-19】区间与除法

## 题目背景

SY 好不容易才解出QM给她的数学题，在恰午饭的时候，QM 向她的脑洞里塞了个幻想的泡泡……SY 戳开一看，又是长长的一串数字!

SY 实在是不想思考了，她决定用小学的除法消灭她脑洞里的数字.

## 题目描述

定义 $op$ 操作意义为将当前数除以 $d$ 并向下取整.

SY 现在有 $m$ 个“原数”，若一个数经过若干次 $op$ 操作(包括 $0$ 次)后能变为这个“原数”，那么这个数是可以被这个“原数”所消灭的。注意，“原数”是不会被消耗的.

现在 SY 想问你,对于一个区间 $[l,r]$，在消灭最多个数的前提下最少需要多少个“原数”？

## 说明/提示

#### 样例解释：

**#样例1** ： $20$ 经过一次 $op$ 操作（除以 $3$ 向下取整）可以变成 $6$，而 $0$ 不能经过若干次 $op$ 操作变成 $6$ 。

所以区间 $[1,1]$ 最多消灭 $0$ 个数，消灭最多数前提下最少需要 $0$ 个 "原数"，区间 $[1,2],[2,2]$ 最多消灭 $1$ 个数，消灭最多数前提下最少需要 $1$ 个 "原数" 。

**#样例2** ： $2$ 能消灭 $\{6,19,7\}$ ， $5$ 能消灭 $\{5,15\}$ ， $10$ 能消灭 $\{10\}$ ， 所以区间 $[1,6],[1,4]$ 最少能用所有 "原数" 全部消灭，区间 $[4,6]$ 能用 $2,5$ 全部消灭。

#### 数据范围：

对于 $30\%$ 的数据：$n\le100,m\leq10, d=2, q\le 10$

对于 $100\%$ 的数据：$n\le5\times 10^{5},m\leq60,2\leq d\leq10,q\le10^{6},0\le a_i,b_i\le 2^{63}$

![](https://cdn.luogu.com.cn/upload/image_hosting/t7pn0p1n.png)

特殊性质：数据经过构造。

## 样例 #1

### 输入

```
2 3 3 3
0 20
6 6 6
1 1
2 2
1 2
```

### 输出

```
0
1
1
```

## 样例 #2

### 输入

```
6 3 3 3
6 5 10 15 19 7
2 5 10
1 6
1 4
4 6
```

### 输出

```
3
3
2
```

# 题解

## 作者：冰糖鸽子 (赞：14)

为什么题解全是状压 ST 表什么的捏。

来一个前缀和题解。

----

## Part 1：处理原数

设 $b$ 数组存储的是这 $m$ 个原数。

原数可能会有重复（比如样例 $1$），所以先把 $b$ 去重。由于 $m$ 很小所以可以暴力 $\operatorname{O}(m^2)$ 实现。

注意到每个原数也可能可以被其他原数消灭，设 $b_i$ 可以被 $b_j$ 消灭（$i \ne j$）。

每个能被 $b_i$ 消灭的数，由于其被除到 $b_i$ 后一定能被除到 $b_j$，所以一定也能被 $b_j$ 消灭。

有结论：**若 $x$ 能被 $y$ 消灭且 $y$ 能被 $z$ 消灭，则 $x$ 能被 $z$ 消灭。**

当 $b_i$ 可以被 $b_j$ 消灭时，$b_i$ 可以消灭的数集 是  $b_j$ 可以消灭的数集 的子集。于是 $b_i$ 就能被 $b_j$ 代替。

所以我们二次处理 $b$ 数组，对所有 $b_i$，如果能找到一个可以消灭 $b_i$ 的 $b_j$（$i \ne j$），则删去 $b_i$。

处理过后，每个 $a_i$ 只能被 $0$ 或 $1$ 个原数消灭，$\operatorname{O}(m\log a_i)$ 求出这个原数 $c_i$（因为 $d$ 的值有变等原因并跑不满）。

这一部分总复杂度 $\operatorname{O}(m^2+m^2\log V+mn\log V) = \operatorname{O}(mn\log V)$ （$V$ 为 $a_i,b_i$ 上界）。

----

## Part 2：处理询问

经过 $\text{Part 1}$ 的处理，得到了 $c$ 数组，而询问就变成了区间数颜色，并且颜色数 $\leq60$。

则有一个显然的做法：枚举每个原数，判断区间中原数是否存在，存在则答案加一。

可以先前缀和一遍，$sum_{i,j}$ 表示 $c$ 的前 $i$ 个元素中第 $j$ 个原数出现的次数。然后 $\operatorname{O}(1)$ 实现判断区间中原数是否存在。

最后输出答案即可。

这一部分复杂度为 $\operatorname{O}(qm)$。

----

## 坑点：

- map 存原数可能会比枚举原数更慢。

- $sum$ 数组如果是 `long long` 类型会 MLE。

----

## AC代码：

```cpp

// Problem: P5629 【AFOI-19】区间与除法
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5629
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// Powered by CP Editor (https://cpeditor.org)
// Auther: Sugar_Pigeon(227728)

#include <bits/stdc++.h>
using namespace std;
#define M 1000006
#define INT long long
INT n,m,ox,oy,nm,d,q,a[M],nd[M],b[M],ans,c[M],hav0;
int sum[M][65];
void calc(INT x) {
	INT y=a[x];
	if(hav0) {nd[x]=0;return;}
	while(y) {
		for(INT i=1;i<=m;i++) {
			if(b[i]==y) {
				nd[x]=y;
				return;
			}
		}
		y/=d;
	}
	if(!nd[x]) nd[x]=-1;
	return;
}
bool dop(INT x) {
	while(x)
	{
		x/=d;
		for(INT i=1;i<=m;i++)
			if(b[i]==x)
				return 1;
	}
	return 0;
}
signed main() {
	scanf("%lld%lld%lld%lld",&n,&m,&d,&q);
	for(INT i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(INT i=1;i<=m;i++) {
		scanf("%lld",&b[i]);
		for(INT j=1;j<i;j++) {
			if(b[j]==b[i]) {
				m--,i--;
				break;
			}
		}
	}
	sort(b+1,b+m+1);
	for(INT i=m;i>=1;i--) {
		if(!dop(b[i])) {
			c[++nm]=b[i];
		}
	}
	m=nm;
	for(INT i=1;i<=m;i++)
		b[i]=c[i],hav0=((hav0||!b[i])?1:0);
	for(INT i=1;i<=n;i++)
		calc(i);
	for(INT i=1;i<=n;i++)
		for(INT j=1;j<=m;j++)
			sum[i][j]=sum[i-1][j]+(nd[i]==b[j]?1:0);
	for(INT Q=1;Q<=q;Q++) {
		scanf("%lld%lld",&ox,&oy);
		ans=0;
		for(INT i=1;i<=m;i++)
			if(sum[oy][i]-sum[ox-1][i])
				ans++;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：saxiy (赞：13)

#### 题目分析：

写这道题前$30$%数据的暴力会对写正解有启发哦。

#### 前 30pts：

暴力枚举每个数和 "原数"，记录每个 "原数" 可以消灭哪些数，对于每个询问暴力枚举 "原数" 子集，能完全覆盖询问区间的子集中取元素最少的作为答案，复杂度大概是 $O(nm\log_d\text{maxval}+q3^mn)$ （具体取决于实现方式）。

~~真是纯纯的暴力啊~~

#### All 100pts：

- 匹配的过程

在处理 30pts 时（$d=2$），数与 "原数" 的匹配大概是这样的（实现方式不唯一）：

```cpp
for(int i = 1;i <= n;i++)
	for(int j = 1;j <= m;j++) {
		ll tmp = a[i];
		while(tmp) {
			if(tmp == b[j]) {//可以变成这个"原数"
				bs[j].push_back(i);//记录
				break;
			}
			tmp >>= 1;//除2向下取整
		}
	}
```

注意到 `tmp >>= 1` 这句话的本质，就是去掉 `tmp` 二进制下的最后一位。

那么更一般的，将一个数除以 `d` 并向下取整的本质就是去掉这个数在 `d` 进制下的最后一位。

再来考虑这个匹配的过程，就是将两个数 `d` 进制下的最高位对齐，看 "原数" 是否是这个数的前缀，很容易想到用 $trie$ 树完成这个匹配的过程。

- 回答询问

对于每个数，如果有多个 "原数" 匹配它，换句话说，有多个 "原数" 为它的前缀，一定是取较短的前缀能消灭更多的数，所以对于 "原数" 内部，如果存在一个 "原数" 为另一个 "原数" 的前缀，那么后者是完全可以被前者替代的，换句话说，我选了前者一定不会多此一举选后者。

经过上述处理后，对于一个数，最多有一个 "原数" 来消灭它，这个可由反证法证得。

由于 $q\leq 10^6$ 次询问的无情轰炸，加上 $m\leq 60$ 的友好条件，考虑将区间的 **最大覆盖最小费用** 压缩到一个 `long long` 内（每个 bit 位代表是否使用某个 "原数"，`1` 的个数即为花费），不同的区间就可以通过 **按位或** 运算合并答案，对于无情询问套 $ST$ 板子即可。

#### 代码实现：

```cpp
#include <bits/stdc++.h>
#define N 500005
#define LOG_N 23
#define M 10005
using namespace std;
typedef long long ll;

int n, m, d, q, lg[N], stk[70], top;
int trie[M][12], ed[M], cnt = 2;
ll a[N], b[65], f[N][LOG_N];

void fj(ll x) {//分解一个数的d进制位
	for(top = 0;x;x /= d) stk[++top] = x % d;
}

void addtrie(ll x, int id) {//将"原数"加入trie
	fj(x);
	int now = 1;
	for(int i = top;i;i--) {
		int ch = stk[i];
		if(!trie[now][ch]) trie[now][ch] = cnt++;
		now = trie[now][ch];
		if(ed[now]) return;//存在一个"原数"为这个"原数"前缀，抛弃这个"原数"。
	}
	ed[now] = id;//记录编号
}

int find(ll a) {//查找是否有"原数"为其前缀
	fj(a);
	int now = 1;
	for(int i = top;i;i--) {
		int ch = stk[i];
		if(!trie[now][ch]) break;
		now = trie[now][ch];
		if(ed[now]) return ed[now];//返回编号
	}
	return -1;//没找到
}

int get(ll x) {//统计二进制位1的个数
	static int res;
	for(res = 0;x;x >>= 1)
		if(x & 1) res++;
	return res;
}

int main() {
	scanf("%d%d%d%d", &n, &m, &d, &q);
	for(int i = 1;i <= n;i++) scanf("%lld", a + i);
	for(int i = 1;i <= m;i++) scanf("%lld", b + i);
	sort(b + 1, b + m + 1);//先加小的，方便筛选（不必要）。
	for(int i = 1;i <= m;i++)
		addtrie(b[i], i);
	int l, r, k;
	for(int i = 1;i <= n;i++) {
		k = find(a[i]);
		if(~k) f[i][0] = 1LL << k;
		//否则（没找到）f[i][0]为0（消灭不了，没花费）。
	}
	//预处理log2向下取整的值（ST相关）
	for(int i = 2;i <= n;i++) lg[i] = lg[i >> 1] + 1;
	for(int i = 1;i <= lg[n];i++)//ST板子
		for(int j = 1;j + (1 << i) - 1 <= n;j++)
			f[j][i] = f[j][i - 1] | f[j + (1 << (i - 1))][i - 1];
	while(q--) {
		scanf("%d%d", &l, &r);
		k = lg[r - l + 1];
		printf("%d\n", get(f[l][k] | f[r - (1 << k) + 1][k]));
	}
	return 0;
}
```

---

## 作者：MuYC (赞：8)

#### 线段树/ST表好题
这道题目需要观察题目性质。

机房考试的时候想出来了一个不用位运算的Tle做法，结果因为没开longlong直接见祖宗爆0了

#### 思路:

不难发现，这道题的$m$给得很小，于是我们可以在给定的“原数”上下功夫。

对于一个“原数”，我们假设一个数变为“原数”后，假设这个“原数”是$p$，继续除以$d$能变为另外一个“原数”$q$，那我们第一次得到的那个“原数”$p$显然没有继续除以$d$得到的那个“原数”$q$"优"，因为我们可以简单的知道，能够还原成“原数”$p$的数一定可以还原成“原数”$q$。

我们这样消除后一些“原数”后，发现对于每一个数，要么它就不能被除成“原数”，要么就可以被除成唯一一个对应的“原数”，因为如果它可以得到两个及以上“原数”，根据上面提到的更小的“原数”更"优"，那些大的“原数”都会被消除掉。

我们可以预处理出每一个数可以被消成哪一个“原数”，因为$d$ >= 2，对于每一个数处理的时间复杂度是$log$ (数的大小)的，所以可以暴力预处理，时间复杂度为:O($nlog(n)$)

然后我们发现$m$ <= 60 种，根据一开始的消除后会更小。

于是我们想到状态压缩。但是我放了许多个不同版本的，可供参考

题解里面都是ST表，这里放线段树

#### 没有状态压缩的线段树,开O2过去了(不开会被卡成70pts)

用时
7.59s(最慢的一个点是2.18s)

内存
85.33MB
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500005;
long long n,m,d,p;
long long a[MAXN] ,c[65], b[65],ss[65],Ans[65];
int color[MAXN];

struct tree {
	bool book[61];
	int l,r;
} T[MAXN * 4];

void Get(int x,int l,int r)
{
	if(T[x].l >= l && T[x].r <= r)
	{
		for(int i = 1 ; i <= m ; i ++)Ans[i] |= T[x].book[i];
		return ;
	}
	int mid = ( T[x].l + T[x].r ) >> 1;
	if(l <= mid)Get(x << 1 , l , r);
	if(r  > mid)Get(x << 1 | 1 ,l , r );
	return ;
}

void build(int x,int l,int r)
{
	T[x].l = l , T[x].r = r ;
	if(l == r){T[x].book[color[l]] = 1;return ;}
	int mid = (l + r) >> 1;
	build(x << 1 , l , mid);
	build(x << 1 | 1 , mid + 1 , r);
	for(int i = 1 ; i <= m ; i ++)
		if(T[x << 1].book[i] || T[x << 1 | 1].book[i])
		T[x].book[i] = 1 ;
	return ;
}

inline long long read()
{
	long long x = 0, flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar());
	for( ; ch >= '0' && ch <= '9'; ch = getchar())x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

inline void write(int x)
{
	if(!x){putchar('0'),putchar('\n');return ;}
	char W[30];
	int R = 0;
	while(x)
		R ++ , W[R] = x % 10 + '0',x = x / 10;
	for(int i = R ; i >= 1 ; i --)
		putchar(W[i]);
	putchar('\n');
	return ;
}

signed main()
{
	//freopen("purify.in","r",stdin);
	//freopen("purify.out","w",stdout);
	n = read() , m = read() , d = read() , p = read();
	for(int i = 1 ; i <= n ; i ++)a[i] = read();
	for(int i = 1 ; i <= m ; i ++)b[i] = read(),c[i] = 1;
	sort(b + 1 , b + 1 + m);
	for(int i = m ; i >= 1 ; i --)
	{
		long long t = b[i];
		while(c[i] == 1)
		{
			for(int j = i - 1 ; j >= 1 ; j --)
			if(b[j] == t)c[i] = 0;
            if(t == 0)break;
			t /= d;
		}
	}
	int R = 0;
	for(int i = 1 ; i <= m ; i ++)
		if(c[i])R ++, ss[R] = b[i];//将消除后得到的"原数"拷贝
	m = R;
	for(int i = 1 ; i <= m ; i ++)
		b[i] = ss[i];
	for(int i = 1 ; i <= n ; i ++)
	{
		long long t = a[i],flag = 0;
		while(1)
		{
			for(int j = 1 ; j <= m ; j ++)
			if(t == b[j]){flag = 1 ; color[i] = j ;break;}
            if(t == 0)break;
			t /= d;
		}
	}
	build(1 , 1 , n);
	while(p)
	{
		long long l,r,ans = 0;
		l = read() , r = read();
		for(int i = 1 ; i <= m ; i ++)Ans[i] = 0;
		Get(1,l,r);
		for(int i = 1 ; i <= m ; i ++)
			if(Ans[i] == 1)ans ++;
		write(ans);
		p --;
	}
	return 0;
}
```

然而，后来我想到了用bitset来搞

用时
3.89s

内存
36.86MB

还是开了O2才过，内存以及时间上有了极大优化，不开被卡成80pts,因为据万神说，bitset有一个大常数

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500005;
long long n,m,d,p;
long long a[MAXN] ,c[65], b[65],ss[65];
bitset <61> Ans;
int color[MAXN];

struct tree {
	bitset <61> book;
	int l,r;
} T[MAXN * 4];

void Get(int x,int l,int r)
{
	if(T[x].l >= l && T[x].r <= r)
	{
		Ans |= T[x].book;
		return ;
	}
	int mid = ( T[x].l + T[x].r ) >> 1;
	if(l <= mid)Get(x << 1 , l , r);
	if(r  > mid)Get(x << 1 | 1 ,l , r );
	return ;
}

void build(int x,int l,int r)
{
	T[x].l = l , T[x].r = r ;
	if(l == r){T[x].book[color[l]] = 1;return ;}
	int mid = (l + r) >> 1;
	build(x << 1 , l , mid);
	build(x << 1 | 1 , mid + 1 , r);
	T[x].book = T[x << 1].book | T[x << 1 | 1].book;
	return ;
}

inline long long read()
{
	long long x = 0, flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar());
	for( ; ch >= '0' && ch <= '9'; ch = getchar())x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

inline void write(int x)
{
	if(!x){putchar('0'),putchar('\n');return ;}
	char W[30];
	int R = 0;
	while(x)
		R ++ , W[R] = x % 10 + '0',x = x / 10;
	for(int i = R ; i >= 1 ; i --)
		putchar(W[i]);
	putchar('\n');
	return ;
}

signed main()
{
	//freopen("purify.in","r",stdin);
	//freopen("purify.out","w",stdout);
	n = read() , m = read() , d = read() , p = read();
	for(int i = 1 ; i <= n ; i ++)a[i] = read();
	for(int i = 1 ; i <= m ; i ++)b[i] = read(),c[i] = 1;
	sort(b + 1 , b + 1 + m);
	for(int i = m ; i >= 1 ; i --)
	{
		long long t = b[i];
		while(c[i] == 1)
		{
			for(int j = i - 1 ; j >= 1 ; j --)
			if(b[j] == t)c[i] = 0;
            if(t == 0)break;
			t /= d;
		}
	}
	int R = 0;
	for(int i = 1 ; i <= m ; i ++)
		if(c[i])R ++, ss[R] = b[i];
	m = R;
	for(int i = 1 ; i <= m ; i ++)
		b[i] = ss[i];
	for(int i = 1 ; i <= n ; i ++)
	{
		long long t = a[i],flag = 0;
		while(1)
		{
			for(int j = 1 ; j <= m ; j ++)
			if(t == b[j]){flag = 1 ; color[i] = j ;break;}
            if(t == 0)break;
			t /= d;
		}
	}
	build(1 , 1 , n);
	while(p)
	{
		long long l,r,ans = 0;
		l = read() , r = read();
		for(int i = 1 ; i <= m ; i ++)Ans[i] = 0;
		Get(1,l,r);
		for(int i = 1 ; i <= m ; i ++)
			if(Ans[i] == 1)ans ++;
		write(ans);
		p --;
	}
	return 0;
}
```

#### 最后放上不开O2也能过的状态压缩版

用时

7.52s

内存

24.13MB

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500005;
long long n,m,d,p;
long long a[MAXN] ,c[65], b[65],ss[65];
long long Ans;
int color[MAXN];

struct tree {
	long long book;
	int l,r;
} T[MAXN * 4];

void Get(int x,int l,int r)
{
	if(T[x].l >= l && T[x].r <= r)
	{
		Ans |= T[x].book;
		return ;
	}
	int mid = ( T[x].l + T[x].r ) >> 1;
	if(l <= mid)Get(x << 1 , l , r);
	if(r  > mid)Get(x << 1 | 1 ,l , r );
	return ;
}

void build(int x,int l,int r)
{
	T[x].l = l , T[x].r = r ;
	if(l == r){
		if(color[l])
		T[x].book |= (1ll << color[l]);
		return ;
	}
	int mid = (l + r) >> 1;
	build(x << 1 , l , mid);
	build(x << 1 | 1 , mid + 1 , r);
	T[x].book = T[x << 1].book | T[x << 1 | 1].book;
	return ;
}

inline long long read()
{
	long long x = 0, flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar());
	for( ; ch >= '0' && ch <= '9'; ch = getchar())x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

inline void write(int x)
{
	if(!x){putchar('0'),putchar('\n');return ;}
	char W[30];
	int R = 0;
	while(x)
		R ++ , W[R] = x % 10 + '0',x = x / 10;
	for(int i = R ; i >= 1 ; i --)
		putchar(W[i]);
	putchar('\n');
	return ;
}

signed main()
{
	//freopen("purify.in","r",stdin);
	//freopen("purify.out","w",stdout);
	n = read() , m = read() , d = read() , p = read();
	for(int i = 1 ; i <= n ; i ++)a[i] = read();
	for(int i = 1 ; i <= m ; i ++)b[i] = read(),c[i] = 1;
	sort(b + 1 , b + 1 + m);
	for(int i = m ; i >= 1 ; i --)
	{
		long long t = b[i];
		while(c[i] == 1)
		{
			for(int j = i - 1 ; j >= 1 ; j --)
			if(b[j] == t)c[i] = 0;
			if(t == 0)break;
			t /= d;
		}
	}
	int R = 0;
	for(int i = 1 ; i <= m ; i ++)
		if(c[i])R ++, ss[R] = b[i];
	m = R;
	for(int i = 1 ; i <= m ; i ++)
		b[i] = ss[i];
	for(int i = 1 ; i <= n ; i ++)
	{
		long long t = a[i],flag = 0;
		while(1)
		{
			for(int j = 1 ; j <= m ; j ++)
			if(t == b[j]){flag = 1 ; color[i] = j ;break;}
			if(t == 0)break;
			t /= d;
		}
	}
	build(1 , 1 , n);
	while(p)
	{
		long long l,r,ans = 0;
		l = read() , r = read();
		Ans = 0;
		Get(1,l,r);
		while(Ans)
		{
			ans++;
			Ans-=(Ans&-Ans);
		}
		write(ans);
		p --;
	}
	return 0;
}
```


---

## 作者：tommymio (赞：5)

这题乍一看很不好做的样子，事实上我们想一下，这题有一个性质：**能够被多个原数消灭的数，只选择能消灭它的最小原数来消灭它是最优的**.

为什么这样一定是对的呢？我们想一想对于一个能消除当前数 $a_i$ 的原数集合 $c$，令 $c_1 > c_2 > ... c_{|c|} $.那么 $a_i$ 一定能通过题目给出的变换变成 $c$ 集合中的任意一个数，并且会按照 $c_1->c_2->...->c_{|c|}$ 的顺序变换，也就是说只要能够变成 $c_1$，最终就一定能够变成 $c_{|c|}$，那我们将 $c_{|c|}$ 作为这一集合的代表元，每次只记录能够消灭数 $a_i$ 的 $c$ 集合的代表元，由于 $|c| \leq 60$，故可以二进制状压。那么一个区间内的**最大消除最小原数集合**为这个区间内所有能够消除 $a_i$ 的 $c$ 集合 的代表元的并，在查询的时候直接查询这一区间内**最大消除最小原数集合**的集合大小即可.

注：**最大消除最小原数个数集合** 为能够消除最多数的最小的原数集合.

由于求集合的并，在位运算上表示为或运算，线段树和 $ST$ 均可，由于询问过多，单次查询为 $O(1)$ 的 $ST$ 表显然更加优秀.

时间复杂度上界为 $O(n \log num+T*m)$ 或 $O(n \log num+n \log n+T*m)$，其中 $num$ 为 $\max\{a_i\}$.

**需要注意的是，对于 $2^{32}$及以上，需使用 $\text{long long}$**. 

**Show the Code**
```cpp
#include<cstdio>
#include<algorithm>
#include<unordered_map>
//f[i][j] i~i+2^j-1
typedef long long ll;
int lg[500005];
ll f[500005][25],a[500005],b[65];
std::unordered_map<ll,int> id;
inline ll read() {
	register ll x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
int main() {
	int n=read(),m=read(),d=read(),T=read();
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int i=1;i<=m;++i) b[i]=read();
	std::sort(b+1,b+1+m);
	m=std::unique(b+1,b+1+m)-b-1;
	for(register int i=1;i<=m;++i) id[b[i]]=i;
	for(register int i=1;i<=n;++i) {
		for(register ll x=a[i];x;x/=d) {if(id.find(x)!=id.end()) f[i][0]=1ll<<(id[x]-1);}
		if(!b[1]) f[i][0]=1; 
	}
	for(register int i=n;i>=1;--i) {
		for(register int j=1;i+(1<<j)-1<=n;++j) {
			f[i][j]=f[i][j-1]|f[i+(1<<(j-1))][j-1];
		}	
	}
	lg[0]=-1;
	for(register int i=1;i<=n;++i) lg[i]=lg[i>>1]+1;
	while(T--) {
		//l+len-1<=r len<=r-l+1
		int l=read(),r=read(),ans=0,tb=lg[r-l+1];
		ll res=f[l][tb]|f[r-(1<<tb)+1][tb];
		for(;res;res-=res&(-res)) ++ans;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：kradcigam (赞：4)

这题我们可以想到将每个数字变成 $d$ 进制的数，消灭数可以看成是 $d$ 进制下原数是这个数 $d$ 进制下的一段前缀。

于是可以使用 $Trie$ 来实现这个过程，于是可以先将这 $m$ 个原数 insert，然后再去查询。

一个数有多个前缀，我们可以选择其中最短的一个，因为这样是最优秀的，可以理解为越短的串延伸出来的串就越多，而越长的串则通用性就越差。

于是我们就可以求出是每个数会选择哪个原数进行消灭，我们可以将状态存在一个 long long 里面，需要做到的就是区间或。

无修改，只有区间或，可以想到使用倍增（ST表）来求，因为或有着跟 $\min$ 和 $\max$ 一样好的性质。

code（目前的最优解）:

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define LL long long
#define pb push_back
#define mp make_pair
#define SZ(x) ((int)x.size()-1)
#define ms(a,b) memset(a,b,sizeof a)
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define DF(i,a,b) for(int i=(a);i>=(b);--i)
#define debug(b,a) cerr<<"D:";F(i,1,b-1)cerr<<"   ";cerr<<" "<<#a<<" => "<<(a)<<"  <="<<__LINE__<<"L"<<endl
using namespace std;
inline LL read(){char ch=getchar(); LL w=1,c=0;
	for(;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;
	for(;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);
	return w*c;
}
const int N=5e5+10,M=65;
int cnt,n,m,d,q,pos[15][M*65],tot,vis[M*25],lg2[N],tmp[N];
LL a[N],b[M];
LL f[25][N];
void insert(LL x,int y){
	int tot=0;
	for(;x;x/=d)tmp[++tot]=x%d;
	int num=0;
	DF(i,tot,1){
		if(vis[num])return;
		if(!pos[tmp[i]][num])pos[tmp[i]][num]=++cnt;
		num=pos[tmp[i]][num];
	}vis[num]=y;
}
int query(LL x){
	int tot=0;
	for(;x;x/=d)tmp[++tot]=x%d;
	int num=0;
	DF(i,tot,1){
		if(vis[num])return vis[num];
		if(!pos[tmp[i]][num])return -1;
		num=pos[tmp[i]][num];
	}return vis[num]?vis[num]:-1;
}
signed main(){
	n=read(),m=read(),d=read(),q=read();
	F(i,2,n)lg2[i]=lg2[i>>1]+1;
	F(i,1,n)a[i]=read();
	F(i,1,m)b[i]=read();
	sort(b+1,b+m+1);
	F(i,1,m)
		insert(b[i],i);
	F(i,1,n){
		int c=query(a[i]);
		if(~c)f[0][i]=(1ll<<c);
	}
	F(i,1,lg2[n])
		F(j,1,n)
			f[i][j]=f[i-1][j]|f[i-1][j+(1<<(i-1))];
	while(q--){
		int l=read(),r=read(),ans=0;
		int dist=(r-l+1);
		LL z=f[lg2[dist]][l]|f[lg2[dist]][r-(1<<lg2[dist])+1];
		for(;z;z&=(z-1))ans++;
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：3)

首先，若 $b_i$ 能消灭 $b_j$ 且 $b_j$ 能消灭 $a_k$，则 $b_i$ 可以消灭 $a_k$。~~这要是不会证明还请先去做红题。~~我们可以利用这个性质消去一些“原数”，使得每个 $a_i$ 能且仅能被一个“原数消灭”。

那么我们枚举每个 $a_i$ 能被哪个原数消灭。若 $a_i$ 能被 $b_j$ 消灭，则把 $f_{i,j}$ 设为 $1$。然后对 $f$ 数组做一遍前缀和或者 ST 表。查询时我们 $O(m)$ 扫一遍判断每个原数是否被用到即可。

时间复杂度 $O(n+m+m^2+nm+qm)$，因为 $m$ 比较小，大约是 $O(nm+qm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d,q;
long long a[114514<<3],b[11<<3];
int ans[114514<<3],qz[114514<<3][61];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>d>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int j=1;j<=m;j++)cin>>b[j];
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++){
			long long tp=b[i],ttp=b[j];
			while(tp<ttp){
				ttp/=d;
				if(tp==ttp)b[j]=b[i];//覆盖 
			}
		}
	sort(b+1,b+1+m);
	m=unique(b+1,b+1+m)-b-1;//去重
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){//枚举能被哪个数消灭
			long long tp=a[i],tp2=b[j];
			if(tp<tp2)continue;
			while(tp>tp2)tp/=d;
			if(tp==tp2){
			//	cout<<i<<" "<<j<<"\n";
				ans[i]=j;
				break;
			}
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){//前缀和
			if(j==ans[i])qz[i][j]=qz[i-1][j]+1;
			else qz[i][j]=qz[i-1][j];
		}
	while(q--){
		int l,r,cnt=0;
		cin>>l>>r;
		for(int i=1;i<=m;i++)
			if(qz[r][i]-qz[l-1][i]>0)cnt++;
		cout<<cnt<<"\n";
	}	
}
```

---

## 作者：梧桐灯 (赞：2)

先来谈一谈我做这一题的心路历程

区间查询？线段树！

m<=60？肯定要状压一下！

然后看到每次除d最多除log次就结束了，就想到了预处理。

然后对于每个区间就是取一个原数集合使得所有能化简成原数的数都成立。

问题是如何找。

正常想法（我一开始的想法）就是如果这个数能化成第i个原数则二进制第i位是1，否则是0.

但是区间合并却无法实现……

后来在[@Binary_Search_Tree](https://www.luogu.org/user/40985)dalao的提醒下发现了一个**优美**的性质：

**对于每个数我们只需记录最小的能化成的原数即可。**

为什么呢~~感性理解~~，我们发现，若一个大一点的原数能化简成一个更小的原数的话，那么这个大的数是没有用的，换句话说，只要我们记录了最小的原数，肯定不会漏掉大的原数。因为大的原数如果可以被a数组化简成的话，一定可以再化成小的。

听着很难理解，我举个例子：

若d=3, 原数组为2 6 7 21。

显然如果一个数能化简成21那么肯定能成为7，肯定不能成为2和6，故我们只需记录最小的即可。

有了这个结论，我们的问题转换成区间二进制数或的1的个数。

由于询问数很大，线段树可能被卡，所以我用了st表实现（顺带用了fread加速（捂脸））

代码：
```
#include <cstdio>
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

namespace io {
	#define getc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    const int SIZ = 1 << 21 | 1;
    char* iS, * iT, ibuff[SIZ], obuff[SIZ], * oS = obuff, * oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void out() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
        return ;
    }
    inline void putc (const char x) {
    	*oS++ = x;
    	out ();
    	return ;
    }
    template<typename Type>
    inline void read(Type& s) {
        s = 0; int f = 0;
        c = getc (); while (c < '0' || c > '9') {if (c == '-') f = 1; c = getc ();}
        while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getc ();
        s = f ? -s : s; return ;
    }
    template<typename Type>
    inline void Write(Type x) {
        if (x < 0)
            * oS++ = '-', x = -x;
        if (!x)
            * oS++ = '0';
        while (x)
            fu[++fr] = x % 10 + '0', x /= 10;
        while (fr)
            * oS++ = fu[fr--];
        out();
    }
    inline void put(const char x[]) {
        for (register int i = 0; x[i]; ++i)
            * oS++ = x[i];
        out();
    }
}

using io :: read;
using io :: putc;
using io :: Write;

const int N = 500003;
int n, m, d, Q, lg[N];
ll k[19][N], a[N], b[63];

int main () {
	read (n), read (m), read (d), read (Q);
	for (register int i = 1; i <= n; ++i) read (a[i]);
	for (register int i = 1; i <= m; ++i) read (b[i]);
	sort (b + 1, b + m + 1);
	for (register int i = 1; i <= n; ++i) {
		while (a[i]) {
			int x = lower_bound (b + 1, b + m + 1, a[i]) - b;
			if (b[x] == a[i]) k[0][i] = 1ll << x - 1;
			a[i] /= d;
		} //我们只需要最小的原数
		if (!b[1]) k[0][i] = 1; //有0的话肯定能化成0
	}
	for (register int j = 1; j <= 18; ++j) {
		const int p = (1 << j) - 1;
		for (register int i = 1; i + p <= n; ++i) k[j][i] = k[j - 1][i] | k[j - 1][i + (1 << j - 1)];
	}
	for (register int j = 0, i = 1; i <= n; ++i) {
		if (1 << j + 1 == i) ++j;
		lg[i] = j;
	} //st表预处理
	int x, y; while (Q--) {
		read (x), read (y);
		const int d = lg[y - x + 1];
		ll t = k[d][x] | k[d][y - (1 << d) + 1];
		int s = 0; //询问
		while (t) s += t & 1, t >>= 1; //这里其实可以用lowbit做的更快一点
		Write (s), putc ('\n');
	}
	return 0;
}
```


---

## 作者：under_the_time (赞：1)

## 题意

> 如果一个数在经过若干次或 $0$ 次除以 $d$ 并向下取整后与一个被称作“原数”的数相等，则说这个数能被这个原数消除。
>
> 给定 $n$ 个数 $a$、$m$ 个原数 $b$、$d$ 和 $q$ 组形如 $l,r$ 的询问，求在用原数尽可能多的消除 $a_l,a_{l+1},\dots,a_r$ 的情况下最少需要几个原数。原数可以重复使用且不会变化。

## 解法

题目中 $m$ 只有 $60$，这提示我们可以把原数的使用信息用一个 `long long` 存起来。对于第 $i$ 个原数 $b_i$，如果二进制下第 $i$ 位为 $1$ 则表示决定使用 $b_i$ 去消除，为 $0$ 则表示不决定使用。如果我们知道 $a$ 中每个数使用了哪个原数消除，就可以用一个 `st` 表快速预处理出消灭 $[i,i+2^j)$ 中的数用了哪些原数去消除尽可能多的元素，最后也就可以 $O(1)$ 回答了。

考虑如何快速判断 $x$ 可以被什么原数消除。题目的数据范围中给到了一个 $30\%$ 的部分分：

> 对于 $30\%$ 的数据：$\dots,d=2,\dots$

所以我们先考虑 $d=2$，尝试从它推出其余情况。

以十进制中的 $11$ 为例，它在二进制中表示为 $(1011)_2$，即 $2^3\times1+2^2\times0+2^1\times1+2^0\times1$。将其除以 $2$ 并向下取整：
$$
\begin{aligned}
{} &\ \lfloor11÷2\rfloor &\\
= &\ \lfloor(2^3\times1+2^2\times0+2^1\times1+2^0\times1)÷2\rfloor &\\
= &\ \lfloor2^2\times1+2^1\times0+2^0\times1+\frac{1}{2}\rfloor&\\
= &\ 2^2\times1+2^1\times0+2^0\times1&\\
= &\ (101)_2
\end{aligned}
$$
通过归纳可以推出：一个数除以 $2$ 并向下取整，相当于在其二进制中整体向右移一位，舍弃最低位。~~想必大家早就知道了~~

如果我们把 $2$ 进制推广到 $d$ 进制，这个规则同样适用：一个数除以 $d$ 并向下取整，相当于在其 $d$ 进制中整体向右移一位，舍弃最低位。此时我们发现，如果一个原数与 $x$ 在 $d$ 进制表示下的某一段前缀相同，则 $x$ 就可以被这个原数消灭。

所以我们只需判断 $x$ 在 $d$ 进制表示下，是否有一段前缀是某个在 $d$ 进制表示下的原数即可。

显然 $d$ 进制下位数越少的原数，它能消除的数越多。所以我们总是贪心的选择位数少的原数。

## 实现

对于快速判断前缀是否相同，`Trie` 树是很理想的数据结构。我们把所有的原数按照 $d$ 进制下高位在前、低位在后，插入一棵 `Trie` 里，并标记每个原数在 `Trie` 中的末端节点。

这里有一个小优化：将原数从小到大插入 `Trie`，如果在插入过程中发现了一个原数的结尾，即有一个原数在 $d$ 进制下为自己的前缀，则后面的求解中肯定会使用前者而不是自己，此时就可以直接退出了。

设 $f_{i,j}$ 表示在尽可能消灭 $[i,i+2^j)$ 的情况下原数的使用信息，$f_{i,j}$ 在二进制下第 $x$ 位为 $0$ 表示不使用 $b_x$，为 $1$ 则表示使用。对于第 $i$ 个数 $a_i$，如果在 `Trie` 树中找到了 $d$ 进制下能找到的长度最短的原数 $b_k$，则将 $f_{i,0}$ 设为 $2^{k-1}$（因为 $2^x$ 表示二进制的第 $(x-1)$ 位为 $1$），表示消灭 $a_i$ 使用了 $b_k$；如果找不到则默认 $f_{i,0}=0$。

在求 $f$ 全体值的时候，从小到大枚举 $j$。设当前枚举到 $i$，则 $f_{i,j-1}\ \text{or}\ f_{i+2^{j-1},j-1}\to f_{i,j}$。其中 $\text{or}$ 表示按位或，即 `|`，表示用 $[i,i+2^{j-1}),[i+2^{j-1},i+2^j)$ 的信息合并出 $[i,i+2^j)$ 的信息。

最后对于一组询问 $(l,r)$，令 $k=\lfloor\log_2(r-l+1)\rfloor$，则最终的原数使用信息 $ans=f_{l,k}\ \text{or}\ f_{r-2^k,k}$。输出 $ans$ 在二进制上有几个 $1$ 即为答案。

个人感觉这部分倍增实现可以参考 `RMQ`，两者因为有 $x\ \text{or}\ x=x$ 或 $\max(x,x)=\min(x,x)=x$ 的性质，才可以用两段有重复部分的区间信息合并出大区间的信息。也就是说，它们都可以用相交的两区间的并，推出大区间。而像加法、乘法等 $x+x≠x,x^2≠x$ 的运算就不能这么做。

时间复杂度：`Trie` 树部分时间复杂度约为 $O(n\log_dA)$，其中 $A$ 是原数最大值；倍增部分预处理 $O(n\log n)$，总查询复杂度 $O(q)$，总时间复杂度约为 $O(n\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define lowbit(x) ((x) & (-(x)))
using namespace std;
const int maxn = 5e5 + 5;
const int maxd = 10;
int Trie[maxn][maxd],cnt = 1,d;
int tail[maxn],b[maxn];
void insert(ll x,int i) {
    int now = 1,tot = 0;
    while (x > 0) b[++ tot] = x % d, x /= d;
    while (tot) {
        int nxt = b[tot --];
        if (!Trie[now][nxt]) Trie[now][nxt] = ++ cnt;
        now = Trie[now][nxt];
        if (tail[now]) return ; // 已经发现有更优的原数能替代自己，直接退出。
    }
    tail[now] = i;
}
int query(ll x) {
    int now = 1, tot = 0;
    while (x > 0) b[++ tot] = x % d, x /= d;
    while (tot) {
        int nxt = b[tot --];
        if (!Trie[now][nxt]) return -1;
        now = Trie[now][nxt];
        if (tail[now]) return tail[now];
    }
    return -1;
}
int bitcount(ll x) { // 数出二进制上有几个1，即使用了几个原数。
    int res = 0;
    while (x > 0)
        res += x & 1, x >>= 1;
    return res;
}
int n,m,Q;
ll a[maxn],f[maxn][30];
int main() {
    scanf("%d%d%d%d",&n,&m,&d,&Q);
    for (int i = 1;i <= n;i ++) scanf("%lld",&a[i]);
    for (int i = 1;i <= m;i ++) {
        ll yuan; scanf("%lld",&yuan);
        insert(yuan,i);
    }
    for (int i = 1,pos;i <= n;i ++) 
        if ((pos = query(a[i])) != -1)
            f[i][0] = 1ll << (pos - 1);
    for (int i = 1;i <= 20;i ++)
        for (int j = 1;j + (1 << i) - 1 <= n;j ++)
            f[j][i] = f[j][i - 1] | f[j + (1 << (i - 1))][i - 1];
    for (int i = 1,l,r,k;i <= Q;i ++) {
        scanf("%d%d",&l,&r);
        k = log2(r - l + 1);
        printf("%d\n",bitcount(f[l][k] | f[r - (1 << k) + 1][k]));
    }
    return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

~~（为什么这题卡 map 啊 QAQ）~~

### 前言（不知道会不会当作无意义内容，不想看可以直接跳）

自从 hhx 巨佬让我去学 st 表后，已经有半个月了，一直在刷 st 表的题，这一篇题解算是对这一段学习的一个总结吧。

st 表，模板中就可以知道，用于处理 **静态区间最值**，但是这道题也让我意识到，原来 st 表能够处理的不止最值问题，而是 **两个区间交融后不会对答案产生误差** 的问题。~~（没有听懂没有关系，后面有解题思路）~~

### 解题思路

原数要去重这个问题都已经讲得很透彻了，我一开始想用 [map](https://www.luogu.com.cn/record/110626817) 来实现，但显然 TLE 了几个点。于是，在百般无奈下，我 ~~打开标签页~~ 发现这题有一个 trie 树的标签。然后就是恍然大悟：

我们知道，一个数用 $d$ 进制表示，除以 $d$ 向下取整就是将其最后一位抹去。自己可以去试，这里就不放了。很容易试出来的。~~其实是懒得打 latex，真的想看的话翻评论区。我加几个推导（？）~~

显然对于一个原数，如果多次抹去最后一位能和另一个原数相等，就可以去掉。即，**如果有原数的前缀是另一个原数，就可以删去这个原数**。不难得知，这个操作可以用 trie 树来完成。

接下来，看见 $m$ 的取值范围，就能够想到用状态压缩来存取。这里可以用到 st 表来预处理。

为什么呢？st 表处理的是一段区间需要的原数位置状态压缩后的结果，将两个区间进行并（二进制或）操作，可以得到一大段的区间需要的原数。而两个区间如果都能被一个原数处理，合并后还是被这一个原数处理，不会发生任何关系到答案的变化。（解决前言未解决的问题）

输出正常地化解状态压缩就好了。

### [trie 树代码：](https://www.luogu.com.cn/record/110627246)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=500005;

inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}

ll n,m,d,q,a[N],b[65],lg[N],st[N][30],l,r,tmp;
int c[65],trie[N][15],id=0,en[N];

inline void insert(ll x,ll pos){
	int p=0,len=0;
	for(;x!=0;x/=d)c[++len]=x%d;//化成d进制
	for(int i=len;i>=1;i--){//转化进制要记得从后往前
		if(trie[p][c[i]]==0)trie[p][c[i]]=++id;//加点
		p=trie[p][c[i]];
		if(en[p]!=0)return;//如果有数是前缀了
	}
	en[p]=pos;//这里有个trick，直接记录对应的位置，方便查询
}

inline int find(ll x){
	int p=0,len=0;
	for(;x!=0;x/=d)c[++len]=x%d;
	for(int i=len;i>=1;i--){
		if(trie[p][c[i]]==0)return 0;//如果往下走不会被删掉了，这个数将不会被去掉，返回0
		p=trie[p][c[i]];
		if(en[p]!=0)return en[p];
	}
}

inline int query(ll x){
	int ret=0;
	for(;x!=0;x>>=1ll)ret+=x%2;
	return ret;//解状态压缩
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	n=read();m=read();d=read();q=read(); 
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(b+1,b+m+1);
	for(int i=1;i<=m;i++)insert(b[i],i);//先排序再插入可以保证能当它前缀的数都被录进树里了
	for(int i=1;i<=n;i++){
		tmp=find(a[i]);
		if(tmp==0)st[i][0]=0;//不能被消除就不要标记成1
		else st[i][0]=(1ll<<(tmp-1));//减不减一无所谓
	}
	for(int i=2;i<=n;i++)lg[i]=lg[(i>>1)]+1;
	for(int j=1;j<=lg[n];j++)for(int i=1;i<=n-(1ll<<j)+1;i++)st[i][j]=st[i][j-1]|st[i+(1ll<<(j-1))][j-1];//正常预处理，小压行轻喷
	while(q--){
		l=read();r=read();
		tmp=lg[r-l+1];
		cout<<query(st[l][tmp]|st[r-(1ll<<tmp)+1][tmp])<<'\n';//处理询问，st表正常操作
	}
	return 0;
}
```
### [暴力去除 AC 代码：](https://www.luogu.com.cn/record/110627992)

~~暴力暴踩过去但是 map 会 TLE 我是真没想到的 QAQ。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=500005;

inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}

ll n,M,m,d,q,a[N],b[65],lg[N],st[N][30],l,r,tmp,num[N];

inline bool ok(ll x){
	while(x!=0){
		x/=d;
		for(int i=1;i<=m;i++){//在自己之前的新数组中找，排完序之后能消除自己的一定在新数组里面
			if(num[i]==x)return false;
		}
	}
	return true;
}

inline int query(ll x){
	int ret=0;
	for(;x!=0;x>>=1ll)ret+=x%2;
	return ret;
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	n=read();M=read();d=read();q=read(); 
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=M;i++){
		b[i]=read();
		for(int j=1;j<i;j++){
			if(b[i]==b[j]){
				i--;
				M--;
				break;
			}//有相等的直接不要了
		}
	}
	sort(b+1,b+M+1);
	for(int i=1;i<=M;i++){
		if(ok(b[i])){
			num[++m]=b[i];
		}
	}//排序是为了比它小的录入了新数组
	for(int i=1;i<=n;i++){
		while(a[i]!=0){
			for(int j=1;j<=m;j++){
				if(a[i]==num[j]){
					a[i]=0;
					st[i][0]=(1ll<<(j-1));
					break;
				}
			}
			a[i]/=d;
		}
	}//找原数
  	//下面的代码一样就不多述了
	for(int i=2;i<=n;i++)lg[i]=lg[(i>>1)]+1;
	for(int j=1;j<=lg[n];j++)for(int i=1;i<=n-(1ll<<j)+1;i++)st[i][j]=st[i][j-1]|st[i+(1ll<<(j-1))][j-1];
	while(q--){
		l=read();r=read();
		tmp=lg[r-l+1];
		cout<<query(st[l][tmp]|st[r-(1ll<<tmp)+1][tmp])<<'\n';
	}
	return 0;
}
```
当然显然 trie 树时间更优，自行选择。~~为什么我觉得 trie 树还简单些。~~

---

## 作者：N0_1 (赞：0)

对于 $a_{i}$，若能被某个 $b_{i}$ 消灭，则说明在 $d$ 进制下，$b_{i}$ 是 $a_{i}$ 的前缀。

例如：$20$ 在 $3$ 进制下的形式为 $202_{3}$，$6$ 在 $3$ 进制下的形式为 $20_{3}$，$20$ 能被 $6$ 消除。

tips：除以 $d$ 下取整**等价于**抹掉该数 $d$ 进制下的最后一位。
 
考虑建立一棵 Trie 树，将 $m$ 个原数插入。令查询 $a_{i}$ 的结果为 $b_{i}$ 对应的下标，从 $1$ 开始。

或运算：有 $1$ 为 $1$。

考虑到 $m$ 最大不超过 $60$，使用二进制的每一位存储 $a_{i}$ 的查询结果。

例如：查询 $a_{i}$ 的结果为 $k$，则存储其结果为 $2$ 的 $k$ 次。

对于每次询问，区间或结果中 $1$ 的个数（二进制下）即为答案。

考虑到该处或运算有着和 $\max$ 一样的良好性质(可传递性？)。

所以建立一个 ST 表查询区间答案即可。

（目前最优解）[提交记录](https://www.luogu.com.cn/record/196336989)

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N = 5e5 + 10, M = 70;

int trie[12][N], vis[N], cal_num[M], LOG[N], n, m, d, q, tot = 0, len = 0;
LL dp[25][N], a[N];
//转换进制
void cal(LL num) {
	len = 0;
	for (; num; num /= d) cal_num[++len] = num % d;
}

void addTrie(LL num, int k) {
	cal(num);
	int rt = 0;
	for (int i = len; i >= 1; i--) {
		if (!trie[cal_num[i]][rt]) trie[cal_num[i]][rt] = ++tot;
		rt = trie[cal_num[i]][rt];
		
		if (vis[rt]) return ; // 可不需要,if(vis[rt]) 说明已有该前缀，无需继续往后新建节点了
	}
	vis[rt] = k;
}
// 返回下标，不存在返回0
int queryTrie(LL num) {
	cal(num);
	int rt = 0;
	for (int i = len; i >= 1; i--) {
		if (!trie[cal_num[i]][rt]) return 0;
		rt = trie[cal_num[i]][rt];
		
		if (vis[rt]) return vis[rt];
	}
	return 0;
}

void init() {
	LOG[0] = -1;
	for (int i = 1; i <= n; i++) {
    // (res | 1) - 1 就不用特判不存在的情况啦
		dp[0][i] = ((1LL << queryTrie(a[i])) | 1) - 1;
		LOG[i] = LOG[i >> 1] + 1;
	}
}

void ST() {
	init();
	for (int j = 1; j <= LOG[n]; j++) {
		for (int i = 1; i + (1 << j) - 1 <= n; i++) {
			dp[j][i] = dp[j - 1][i] | dp[j - 1][i + (1 << (j - 1))];
		}
	}
}

LL querySt(int L, int R) {
	int k = LOG[R - L + 1];
	
	return dp[k][L] | dp[k][R - (1 << k) + 1];
}

int calAns(LL num) {
	int ans = 0;
	for (; num; num &= (num - 1)) ans ++;
	return ans;
}

int solve(int L, int R) {
	return calAns(querySt(L, R));
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	
	cin >> n >> m >> d >> q;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) {
		LL num; cin >> num;
		addTrie(num, i);
	}
	ST();
	
	while (q --) {
		int L, R; cin >> L >> R;
		cout << solve(L, R) << "\n";
	}
	return 0;
}

---

## 作者：Yoimiyamwf (赞：0)

# 分析
设 $b$ 数组为原数数组。

首先显然有结论：**如果一个数能被 $b_i$ 消灭且 $b_i$ 能被 $b_j$ 消灭，那么该数可被 $b_j$ 消灭**，这启示我们可以只考虑数列 ${a}$ 中每个数可被其消灭的最小原数，这一步通过~~暴力的~~预处理即可得到。预处理时每个数 $a_i$ 都被 $d$ 除了 $\log_d{a_i}$次，故这一步复杂度为 $O(n\log{a_{max}})$。

接下来，注意到 $m\le60$，所以可以将消灭一个区间内所有数的最小原数的集合用一个 `long long` 进行状压表示出来，并用一个 st 表或线段树维护，通过按位或运算即可合并。由于本题不存在修改操作~~而且线段树又长又难调~~，所以 st 表会更好，这一步预处理复杂度为 $O(n\log n)$，由于查询时要求 $1$ 的个数，该数至多有 $m$ 位，故查询总复杂度为 $O(qm)$。

查询时，直接套 st 表板子，然后求一下二进制下 $1$ 的个数即可。总复杂度为 $O(n\log{a_{max}}+n\log n+qm)$，属于$O(n\log n)$ 级别，可以通过本题。

# 代码
```cpp
#include <bits/stdc++.h>
#define in inline
#define rint register int
#define r(a) runtimerror(a)
#define w(a) wronganswer(a)
#define wl(a) wronganswer(a),putchar('\n')
#define ws(a) wronganswer(a),putchar(' ')
using namespace std;
typedef long long ll;
int n,m,d,q,l,r,logn[500010];
ll a[500010],b,f[25][500010];
unordered_map <ll,int> id;
template <typename t> in void runtimerror(t &a){
	t x=1,f=0;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') x=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		f=(f<<3)+(f<<1)+(ch^48);
		ch=getchar();
	}
	a=x*f;
}
template <typename t> void wronganswer(t a){
	if(a<0) a=-a,putchar('-');
	if(a>9) wronganswer(a/10);
	putchar(a%10^48);
}
in void init(){
	for(rint i=1;i<=n;i++){
		while(a[i]){
			if(id.find(a[i])!=id.end()) f[0][i]=1ll<<(id[a[i]]-1);
			a[i]/=d;
		}
	}
	for(rint i=1;i<=20;i++){
		for(rint j=1;j<=n;j++){
			f[i][j]=f[i-1][j]|f[i-1][j+(1<<i-1)];
		}
	}
}
in int popcount(ll x){ //编译器自带的__builtin_popcount函数传参类型为unsigned int，本题数据范围会爆，所以需要自己写统计函数
	int ans=0;
	while(x){
		ans+=x&1;
		x>>=1;
	}
	return ans;
}
in int query(int l,int r){
	int x=log2(r-l+1);
	return popcount(f[x][l]|f[x][r-(1<<x)+1]);
}
int main(){
	r(n),r(m),r(d),r(q);
	for(rint i=1;i<=n;i++){
		r(a[i]);
	}
	for(rint i=1;i<=m;i++){
		r(b);
		if(id.find(a[i])==id.end()) id[b]=i;
	}
	init();
	while(q--){
		r(l),r(r);
		wl(query(l,r));
	}
	return 0;
}
```

# 后记
这两种写法的速度差距大的有点离谱（）

`if(id[a[i]]) f[0][i]=1ll<<(id[a[i]]-1);`

`if(id.find(a[i])!=id.end()) f[0][i]=1ll<<(id[a[i]]-1);`

[上面第一种写法](https://www.luogu.com.cn/record/128288183)总耗时不仅高达 $12.35s$ 甚至还 T 了一个点，而[第二种写法](https://www.luogu.com.cn/record/128290580)却快了整整 $10s$...

---

## 作者：船酱魔王 (赞：0)

# P5629 【AFOI-19】区间与除法

## 题意回顾

我们定义一个数 $ x $ 能被转化为 $ y $，当且仅当 $ \exists i \in N $ 满足 $ \lfloor \frac{x}{d^i} \rfloor = y $。每次询问能将长度为 $ n $ 的 $ a $ 数组区间 $ [l,r] $ 中尽可能多的数转化为数集 $ C $ 中一个数且 $ C \in B $（$ B $ 被给定）的 $ |C|_{min} $。

$ n \le 5 \times 10^5 $，$ |B| \le 60 $，$ q \le 10^6 $，所有数在 ```long long``` 范围内。


## 分析

我们发现，把一个数转化为更小的数更优，因为当一个数能够被转化为 $ x,y (x < y)$ 时，意味着 $ y $ 能转化为 $ x $，但是 $ x $ 无法转化为 $ y $，所以能转化为 $ y $ 的数一定能被转化为 $ x $，但反之不然，所以应该把每个数转化得尽可能小。

所以我们定义 $ c_i $ 为 $ a_i $ 转化为的数的编号（或无法转化），定义 $ s_{i,j} $ 为前 $ i $ 个数的转化为第 $ j $ 个数的个数，每次算出区间内有哪些数需要被转化到，即为答案。

注意开 ```long long```，注意不能转化为任何数的标记与处理。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
const int N = 5e5 + 5;
int n, m, x, q; 
long long a[N];
long long b1[61];
int dp[N][61];
map<long long, int> b;
int main() {
	cin >> n >> m >> x >> q;
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	for(int i = 1; i <= m; i++) {
		scanf("%lld", &b1[i]);
	}
	sort(b1 + 1, b1 + m + 1);
	for(int i = 1; i <= m; i++) {
		b[b1[i]] = i;
	}
	long long tmp;
	for(int i = 1; i <= n; i++) {
		tmp = a[i];
		a[i] = 114514; 
		while(true) {
			if(b.find(tmp) != b.end()) {
				a[i] = b[tmp];
			}
			if(tmp == 0) {
				break;
			}
			tmp /= x;
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i] == j) {
				dp[i][j] = dp[i - 1][j] + 1;
			} else {
				dp[i][j] = dp[i - 1][j];
			}
		}
	}
	int l, r;
	int ans = 0;
	for(int i = 1; i <= q; i++) {
		scanf("%d%d", &l, &r);
		ans = 0;
		for(int i = 1; i <= m; i++) {
			if(dp[r][i] > dp[l - 1][i]) {
				ans++;
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：TLEWA (赞：0)

有一条显而易见的结论：

一个可以被其它数消灭的数，他的可消灭数必定是那个数可消灭数的子集。

根据这个结论，我们给原数去一下重，就可以保证一个数至多只会被一个去重后的原数整除了，同时这样也是最简的。然后对于每次询问，前缀和查询即可（标签骗人的）。

设 $a_i,b_i$ 上界为 $x$，则时间复杂度 $O(nm \log{x} + qm)$。

AC 代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m,d,q;
unsigned long long arr[500050],ms[65];
unsigned long long news[65],p;
int qian[65][500050];
bool flag;

bool check(unsigned long long y,unsigned long long z) {
	if(y==0) return 0;
	while(z>y) {
		z/=d;
	}
	return ((bool)(z==y));
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	
	cin >> n >> m >> d >> q;
	
	for(int i=1;i<=n;++i) cin >> arr[i]; //输入需要被消灭的数列 
	for(int i=1;i<=m;++i) cin >> ms[i]; //输入原数 
	
	sort(ms,ms+m);
	
	for(int i=1;i<=m;++i) {
		flag=true;
		for(int j=i-1;j;--j) { 
			if(check(ms[j],ms[i])) { //判断 
				flag=false;
				break; 
			}
		}
		if(flag) news[p++]=ms[i];
	}
	
	for(int i=1;i<=n;++i) {
		for(int j=0;j<p;++j) qian[j][i]=qian[j][i-1]; //求前缀和 
		for(int j=0;j<p;++j) {
			if(check(news[j],arr[i])) {
				++qian[j][i];
				break;
			}
		}
	}
	
	int l,r,ans;
	
	for(int i=1;i<=q;++i) {
		cin >> l >> r;
		ans=0;
		for(int j=0;j<p;++j) {
			if(qian[j][r]-qian[j][l-1]) {
				++ans;
			}
		}
		cout << ans << endl;
	}
	
	return 0;
}
```

注意这题卡空间，不需要开 ll 的就不要开。

---


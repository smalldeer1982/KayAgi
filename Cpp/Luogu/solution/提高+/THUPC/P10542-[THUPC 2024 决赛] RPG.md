# [THUPC 2024 决赛] RPG

## 题目描述

小 I 正在打一款回合制 RPG 的最终 boss 战。这一战中，主角和 TA 的 $(n-1)$ 个队友（也就是总共 $n$ 个人）会按照固定的顺序依次行动，目标是对 boss 产生尽可能高的总伤害。

游戏设定中共有 $x$ 种攻击模式，第 $i (1 \le i \le x)$ 种攻击模式会对 boss 产生 $d_i$ 的基础伤害。

在行动过程中可以对 boss 附着异常状态。异常状态共 $y$ 种，同一时刻 boss 不会陷入两种异常状态。当 boss 陷入特定的异常状态时，使用特定的攻击模式会触发暴击，产生更大的伤害。暴击的规则由 $m$ 个三元组 $(p_j, q_j, c_j)$ 给出，表示在附着第 $p_j (1 \le p_j \le y)$ 种异常状态时使用第 $q_j (1 \le q_j \le x)$ 种攻击模式会**额外**产生 $c_j$ 的伤害。

对战开始时，boss 没有陷入任何的异常状态。按照行动顺序，第 $i (1 \le i \le n)$ 个人可以进行以下三种行动：

- 使用法术使 boss 陷入第 $a_i$ 种异常状态，若 boss 之前陷入了其他异常状态，则之前的异常状态被移除。
- 使用第 $b_i$ 种攻击模式对 boss 进行攻击，无论是否触发暴击，在产生伤害之后 **boss 的异常状态被移除**。
- 摸鱼，即什么都不做，此时 boss 的异常状态被保留。

作为剧情党，小 I 自然是不想自己算最优策略，于是他把问题丢给了你。于是你需要求出 $n$ 次行动内总共能产生最多多少伤害。


## 说明/提示

样例中共有两种攻击模式和两种异常状态，其中第一种攻击模式会造成 $10$ 的基础伤害，第二种攻击模式会造成 $1$ 的基础伤害。暴击规则仅有一条：在第二种异常状态下进行第二种攻击会额外造成 $10^9$ 的伤害。

最优的行动策略如下：

- 第一个人使用法术使 boss 陷入第二种异常状态；
- 第二个人摸鱼，boss 仍然陷入第二种异常状态；
- 第三个人使用第二种攻击模式，产生 $1$ 的基础伤害和 $10^9$ 的暴击伤害，boss 的异常状态被清除；
- 第四个人使用第二种攻击模式，产生 $1$ 的基础伤害。

总伤害量为 $1 + 10^9 + 1 = 10^9+2$。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
4 1 2 2
10 1
2 1
1 1
1 2
2 2
2 2 1000000000
```

### 输出

```
1000000002
```

# 题解

## 作者：是青白呀 (赞：2)

首先有一个比较显然的 dp：设 $dp_i$ 表示第 $i$ 个人操作结束后的最大伤害总量，转移为 $dp_i=dp_j+d_{b_i}+val_{j+1,i}$，其中 $val_{x,y}$ 表示在 $x$ 处触发异常状态，在 $y$ 处发动攻击，中间的其他位置都不操作的**额外伤害**。

一个显然的发现是，对于所有 $val_{j+1,i}=0$ 的转移点 $j$，$j=i-1$ 的情况是最优的。因而对于其它情况，我们只需要考虑和 $b_i$ 能触发暴击的 $a_j$ 即可。

由于暴击规则只有 $m$ 条，考虑根号分治。对于有超过 $\sqrt m$ 条暴击规则的 $b_i$，我们维护一个 $maxa_{b_i}$ 表示能转移到攻击模式 $b_i$ 的最大 $dp_j+c_{a_{j+1},b_i}$ 的值，其中 $c_{x,y}$ 表示异常状态 $x$ 和攻击模式 $y$ 对应的暴击的额外伤害，每次可以直接转移；对于不超过 $\sqrt m$ 条暴击规则的 $b_i$，我们维护一个 $maxs_{x}$ 表示到目前为止，异常状态 $x$ 对应的最大的 $dp$ 值，每次枚举和 $b_i$ 有关的所有暴击规则来转移。

更新完 $dp_i$ 的值之后，我们假设在 $i$ 处触发异常状态，用 $dp_{i-1}$ 更新 $maxs_{a_i}$，并枚举所有规则数大于 $\sqrt m$ 的 $b_x$，用 $dp_{i-1}+c_{a_i,b_x}$ 更新 $maxa_{b_x}$ 的值即可。

总时间复杂度 $O(n\sqrt m)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=2e5+5,S=(1<<20)+5,mo=1e9+7,inf=(ll)1e18+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,x,y;
int d[N],a[N],b[N];
struct rule{
	int x,y,c;
}r[N];
int dp[N],cnt[N],upp;
vector<pii>atk[N],sit[N];
int maxs[N],maxa[N];
signed main(){
	read(n),read(m),read(x),read(y),upp=sqrt(m);
	rep(i,1,x)
	    read(d[i]);
	rep(i,1,n)
	    read(a[i]),read(b[i]);
	rep(i,1,m){
		read(r[i].x),read(r[i].y),read(r[i].c);
		cnt[r[i].y]++;
	}
	rep(i,1,m){
		if(cnt[r[i].y]>upp)sit[r[i].x].push_back(mp(r[i].y,r[i].c));
		else atk[r[i].y].push_back(mp(r[i].x,r[i].c));
	}
	rep(i,1,x)
	    maxa[i]=-inf;
	rep(i,1,y)
	    maxs[i]=-inf;
	rep(i,1,n){
		dp[i]=dp[i-1]+d[b[i]];
		if(cnt[b[i]]>upp)dp[i]=max(dp[i],maxa[b[i]]+d[b[i]]);
		else{
			for(auto j:atk[b[i]])
				dp[i]=max(dp[i],maxs[j.fir]+j.sec+d[b[i]]);
		}
		maxs[a[i]]=max(maxs[a[i]],dp[i-1]);
		for(auto j:sit[a[i]])
		    maxa[j.fir]=max(maxa[j.fir],dp[i-1]+j.sec);
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

---

## 作者：Claire0918 (赞：0)

问题具有显著的阶段性，考虑 DP，设 $f_i$ 表示前 $i$ 个人操作后造成的最大伤害。

首先有直接攻击的转移 $f_i \gets f_{i - 1} + d_{b_i}$。在此之外，我们还可以找到一个 $(p_j, q_j, c_j)$，并且找到一个 $k < i$，使得 $a_k = p_j, b_i = q_j$，转移为 $f_i \gets f_{k - 1} + c_j + d_{b_i}$。

考虑记 $s_{q_j} = \{(p_j, c_j)\}, u_{p_j} = \max_{a_k = p_j} \{f_{k - 1}\}$，每次枚举 $(p_j, c_j) \in s_{b_i}$ 并转移 $f_i \gets u_{p_j} + c_j + d_{b_i}$ 即可。$\mathcal{O}(1)$ 维护 $u_{p_j}$ 是简单的。时间复杂度 $\mathcal{O}(|s_i| + 1)$，可以达到 $\mathcal{O}(m)$，不能通过。

我们注意到满足 $|s_{q_j}| > B$ 的 $q_j$ 一定不超过 $\frac{n}{B}$ 个。考虑仅在 $\{s_i\}$ 中保留 $|s_{q_j}| \leq B$ 的 $s_{q_j}$，这时上述转移复杂度降到 $\mathcal{O}(B)$；而对于剩下的 $(p_j, q_j, c_j)$ 记 $t_{p_j} = \{(q_j, c_j)\}$，那么一定有 $|t_i| \leq \frac{n}{B}$。

仅对于在 $t_{p_j}$ 中的 $(p_j, q_j, c_j)$ 设 $v_{q_j} = \max_{(p_j, q_j, c_j), a_k = p_j} \{f_{k - 1} + c_j\}$，转移时直接 $f_i \gets v_{b_i} + d_{b_i}$ 即可。维护 $v_{q_j}$ 可以枚举 $(q_j, c_j) \in t_{a_i}$，有 $v_{q_j} \gets f_{i - 1} + c_j$，时间复杂度 $\mathcal{O}(|t_i|) = \mathcal{O}(\frac{m}{B})$。总时间复杂度 $\mathcal{O}(1 + \frac{m}{B}) = \mathcal{O}(\frac{m}{B})$。

综上，时间复杂度为 $\mathcal{O}(n(B + \frac{m}{B}))$，显然 $B = \sqrt m$ 时取得最小值 $\mathcal{O}(n\sqrt m)$。

这一方法是一种似乎并不常见的动态规划优化，称为根号分治优化 DP，有较高的思维难度。

Code：
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a))

using namespace std;

const int maxn = 2e5 + 10, maxm = 2e5 + 10, maxx = 2e5 + 10, maxy = 2e5 + 10, gap = 5e2;

int n, m, x, y;
int d[maxx], a[maxn], b[maxn], p[maxm], q[maxm], c[maxm], cnt[maxx];
long long u[maxy], v[maxx], f[maxn];
vector<pair<int, int> > s[maxx], t[maxy];

int main(){
    scanf("%d %d %d %d", &n, &m, &x, &y);
    for (int i = 1; i <= x; i++){
        scanf("%d", &d[i]);
    }
    for (int i = 1; i <= n; i++){
        scanf("%d %d", &a[i], &b[i]);
    }
    for (int i = 1; i <= m; i++){
        scanf("%d %d %d", &p[i], &q[i], &c[i]);
        cnt[q[i]]++;
    }
    for (int i = 1; i <= m; i++){
        if (cnt[q[i]] > gap){
            t[p[i]].emplace_back(q[i], c[i]);
        }else{
            s[q[i]].emplace_back(p[i], c[i]);
        }
    }
    mem(u, -0x3f), mem(v, -0x3f);
    for (int i = 1; i <= n; i++){
        f[i] = f[i - 1] + d[b[i]];
        if (cnt[b[i]] > gap){
            f[i] = max(f[i], v[b[i]] + d[b[i]]);
        }else{
            for (auto x: s[b[i]]){
                f[i] = max(f[i], u[x.first] + x.second + d[b[i]]);
            }
        }
        u[a[i]] = max(u[a[i]], f[i - 1]);
        for (auto x: t[a[i]]){
            v[x.first] = max(v[x.first], f[i - 1] + x.second);
        }
    }
    printf("%lld", f[n]);

return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：0)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18224725)

### [P10542 [THUPC2024] RPG](https://www.luogu.com.cn/problem/P10542)

一个有配合的“状态加攻击”一定是一个连续段，段内都在摸鱼。所以设 $f_i$ 表示考虑了前 $i$ 个人的最大收益：

$$
f_i=\begin{cases}
f_{i-1}+d_{b_i}\\
\max_{(x,y,z)\in \mathbb{E},y=b_i}g_x+z+d_{b_i}
\end{cases}
$$

其中 $g_i$ 表示满足 $a_j=i$ 的最大的 $f_{j-1}$。暴力做是 $n^2$ 的，原因在于一个 $y$ 对应的 $x$ 可能会过多。

然后第二个式子只和 $y$ 有关。所以考虑根号分治，对于一种 $y$，如果其入度过多，将其单独处理（每转移一位统计存在 $x=a_i$ 的 $y$）。取阈值为 $\sqrt n$ 可以做到 $\mathcal O(n\sqrt n)$。实现不能太烂（有点卡常）。

```cpp
	int n,m,X,Y,d[200010],a[200010],b[200010];
	int val[200010],now[200010],f[200010];
	vector<pii> ve[200010];
	vector<pii> nex[200010];
	vi tmp;
	const int B=700;
	inline void mian()
	{
		read(n,m,X,Y);int x,y,z;
		for(int i=1;i<=X;++i)read(d[i]);
		for(int i=1;i<=n;++i)read(a[i],b[i]);
		while(m--)read(x,y,z),ve[y].eb(mp(x,z));
		memset(val,128,sizeof(val)),memset(now,128,sizeof(now));
		for(int i=1;i<=X;++i)if(ve[i].size()>B)
		for(auto p:ve[i])nex[p.fi].eb(mp(i,p.se));
		for(int i=1;i<=n;++i)
		{
			f[i]=f[i-1]+d[b[i]];
			if(ve[b[i]].size()<=B)
			{
				for(auto p:ve[b[i]])
				Mmax(f[i],val[p.fi]+p.se+d[b[i]]);
			}
			else Mmax(f[i],now[b[i]]+d[b[i]]);
			Mmax(val[a[i]],f[i-1]);
			for(auto p:nex[a[i]])Mmax(now[p.fi],p.se+f[i-1]);
		}
		write(f[n]);
	}
```

---


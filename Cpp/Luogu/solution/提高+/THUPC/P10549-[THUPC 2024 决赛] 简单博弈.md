# [THUPC 2024 决赛] 简单博弈

## 题目描述

有 $k$ 个棋盘。每个棋盘大小为 $n\times m$ ，上面有 $3$ 个位置是 $0$，其他是 $1$。

现在 A 和 B 轮流操作，每次操作需要指定一个棋盘，在该棋盘上选定一行或者选定一列或者选定一行一列，将其全部变成 $0$。但是要保证操作前后棋盘至少一个格子数字变了。

不能操作就输了。问是否先手必胜。


## 说明/提示

一开始棋盘为：

```
011
001
```

先手只需要选中第 1 行第 2 列即可全部清零，从而后手无法操作，先手获胜。



**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
1
2 3
1 1
2 1
2 2
```

### 输出

```
OvO```

## 样例 #2

### 输入

```
1
4 4
1 1
1 2
4 2
```

### 输出

```
QAQ```

# 题解

## 作者：Jsxts_ (赞：3)

非常无聊的题。

看到多个局面同时可操作只有 SG 函数能做。

然后发现因为行与行、列与列之间的地位相同，所以可以任意平移这些行列，将所有的 $0$ 平移到左上后最后本质不同的情况只有 $4$ 种：

```
000
111
111

001
011
111

001
110
111

011
101
110
```

考虑之间递推这 $4$ 种情况的 SG 函数。那么由于操作为删掉行列，还会引出下面 $4$ 种情况：

```
111
111
111

011
111
111

011
101
111

001
111
111
```

全部递推出来即可。

```cpp
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef long long ll;
const int inf = 1e9;
const ll INF = 1e15;
const int N = 500;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
const int mod = 998244353;
int getmod(int x) {
	return x - (x >= mod) * mod;
}
int qpow(int a,int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % mod;
		b >>= 1, a = 1ll * a * a % mod;
	}
	return res;
}
struct edge {
	int v,nxt;
}ed[N * 2 + 10];
int head[N + 10],cnt;
void add(int u,int v) {
	ed[++cnt] = {v,head[u]};
	head[u] = cnt;
}
int sg[8][N + 10][N + 10],vis[20];
pair<int,int> t[3];
/*
0:
000
111
111
1:
001
011
111
2:
001
110
111
3:
011
101
110
4:
111
111
111
5:
011
111
111
6:
011
101
111
7:
001
111
111
*/
int imp = 19;
int main() {
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[4][i - 1][j]] = vis[sg[4][i][j - 1]] = vis[sg[4][i - 1][j - 1]] = 1;
			for (;vis[sg[4][i][j]] == 1;sg[4][i][j] ++ );
			vis[sg[4][i - 1][j]] = vis[sg[4][i][j - 1]] = vis[sg[4][i - 1][j - 1]] = 0;
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[5][i - 1][j]] = vis[sg[5][i][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[4][i - 1][j - 1]] = vis[sg[4][i][j - 1]] = vis[sg[4][i - 1][j]] = 1;
			for (;vis[sg[5][i][j]] == 1;sg[5][i][j] ++ );
			vis[sg[5][i - 1][j]] = vis[sg[5][i][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[4][i - 1][j - 1]] = vis[sg[4][i][j - 1]] = vis[sg[4][i - 1][j]] = 0;
			if (i == 1) sg[5][i][j] = sg[4][i][j - 1];
			if (j == 1) sg[5][i][j] = sg[4][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[6][i - 1][j]] = vis[sg[6][i][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[5][i][j - 1]] = vis[sg[5][i - 1][j]] = vis[sg[4][i - 1][j - 1]] = 1;
			for (;vis[sg[6][i][j]] == 1;sg[6][i][j] ++ );
			vis[sg[6][i - 1][j]] = vis[sg[6][i][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[5][i][j - 1]] = vis[sg[5][i - 1][j]] = vis[sg[4][i - 1][j - 1]] = 0;
			if (i == 1) sg[6][i][j] = sg[4][i][j - 1];
			if (j == 1) sg[6][i][j] = sg[4][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[7][i - 1][j]] = vis[sg[7][i][j - 1]] = vis[sg[7][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[5][i][j - 1]] = vis[sg[4][i - 1][j - 1]] = vis[sg[4][i - 1][j]] = 1;
			for (;vis[sg[7][i][j]] == 1;sg[7][i][j] ++ );
			vis[sg[7][i - 1][j]] = vis[sg[7][i][j - 1]] = vis[sg[7][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[5][i][j - 1]] = vis[sg[4][i - 1][j - 1]] = vis[sg[4][i - 1][j]] = 0;
			if (i == 1) sg[7][i][j] = sg[4][i][max(0,j - 2)];
			if (j <= 2) sg[7][i][j] = sg[4][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[4][i - 1][j - 1]] = vis[sg[0][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = 1;
			vis[sg[0][i][j - 1]] = vis[sg[7][i][j - 1]] = 1;
			vis[sg[0][i - 1][j]] = vis[sg[4][i - 1][j]] = 1;
			for (;vis[sg[0][i][j]] == 1;sg[0][i][j] ++ );
			vis[sg[4][i - 1][j - 1]] = vis[sg[0][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = 0;
			vis[sg[0][i][j - 1]] = vis[sg[7][i][j - 1]] = 0;
			vis[sg[0][i - 1][j]] = vis[sg[4][i - 1][j]] = 0;
			if (i == 1) sg[0][i][j] = sg[4][i][max(0,j - 3)];
			if (j <= 3) sg[0][i][j] = sg[4][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[4][i - 1][j - 1]] = vis[sg[1][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[7][j - 1][i - 1]] = 1;
			vis[sg[1][i][j - 1]] = vis[sg[7][j - 1][i]] = vis[sg[5][i][j - 1]] = 1;
			vis[sg[1][i - 1][j]] = vis[sg[7][i - 1][j]] = vis[sg[5][i - 1][j]] = 1;
			for (;vis[sg[1][i][j]] == 1;sg[1][i][j] ++ );
			vis[sg[4][i - 1][j - 1]] = vis[sg[1][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[7][j - 1][i - 1]] = 0;
			vis[sg[1][i][j - 1]] = vis[sg[7][j - 1][i]] = vis[sg[5][i][j - 1]] = 0;
			vis[sg[1][i - 1][j]] = vis[sg[7][i - 1][j]] = vis[sg[5][i - 1][j]] = 0;
			if (i <= 2) sg[1][i][j] = sg[5][i][j - 1];
			if (j <= 2) sg[1][i][j] = sg[5][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[4][i - 1][j - 1]] = vis[sg[2][i - 1][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = 1;
			vis[sg[7][i][j - 1]] = vis[sg[6][i][j - 1]] = vis[sg[2][i][j - 1]] = 1;
			vis[sg[2][i - 1][j]] = vis[sg[7][i - 1][j]] = vis[sg[5][i - 1][j]] = 1;
			for (;vis[sg[2][i][j]] == 1;sg[2][i][j] ++ );
			vis[sg[4][i - 1][j - 1]] = vis[sg[2][i - 1][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[5][i - 1][j - 1]] = vis[sg[7][i - 1][j - 1]] = 0;
			vis[sg[7][i][j - 1]] = vis[sg[6][i][j - 1]] = vis[sg[2][i][j - 1]] = 0;
			vis[sg[2][i - 1][j]] = vis[sg[7][i - 1][j]] = vis[sg[5][i - 1][j]] = 0;
			if (i == 1) sg[2][i][j] = sg[4][i][max(j - 2,0)];
			if (j <= 2) sg[2][i][j] = sg[4][i - 1][j];
		}
	for (int i = 1;i <= N;i ++ )
		for (int j = 1;j <= N;j ++ ) {
			vis[sg[5][i - 1][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[3][i - 1][j - 1]] = 1;
			vis[sg[3][i][j - 1]] = vis[sg[6][i][j - 1]] = 1;
			vis[sg[3][i - 1][j]] = vis[sg[6][i - 1][j]] = 1;
			for (;vis[sg[3][i][j]] == 1;sg[3][i][j] ++ );
			vis[sg[5][i - 1][j - 1]] = vis[sg[6][i - 1][j - 1]] = vis[sg[3][i - 1][j - 1]] = 0;
			vis[sg[3][i][j - 1]] = vis[sg[6][i][j - 1]] = 0;
			vis[sg[3][i - 1][j]] = vis[sg[6][i - 1][j]] = 0;
			if (i < 3 || j < 3) sg[3][i][j] = sg[6][i][j];
		}
	int res = 0;
	int k = read();
	while (k -- ) {
		int n = read(),m = read();
		for (int j = 0;j < 3;j ++ ) t[j].x = read(), t[j].y = read();
		sort(t,t + 3);
		if (t[0].x == t[1].x && t[1].x == t[2].x) res ^= sg[0][n][m];
		else if (t[0].x == t[1].x && (t[2].y == t[0].y || t[2].y == t[1].y)) res ^= sg[1][n][m];
		else if (t[1].x == t[2].x && (t[2].y == t[0].y || t[0].y == t[1].y)) res ^= sg[1][n][m];
		else if (t[0].x == t[1].x && (t[2].y != t[0].y && t[2].y != t[1].y)) res ^= sg[2][n][m];
		else if (t[1].x == t[2].x && (t[2].y != t[0].y && t[0].y != t[1].y)) res ^= sg[2][n][m];
		else if (t[1].x != t[2].x && t[1].x != t[0].x && t[1].y != t[2].y && t[1].y != t[0].y && t[2].y != t[0].y) res ^= sg[3][n][m];
		else {
			sort(t,t + 3,[](pair<int,int> x,pair<int,int> y){return x.y < y.y;});
			if (t[0].y == t[1].y && t[1].y == t[2].y) res ^= sg[0][m][n];
			else if (t[0].y == t[1].y && (t[2].x != t[0].x && t[2].x != t[1].x)) res ^= sg[2][m][n];
			else if (t[1].y == t[2].y && (t[2].x != t[0].x && t[0].x != t[1].x)) res ^= sg[2][m][n];
		}
	}
	puts(res ? "OvO" : "QAQ");
	return 0;
}
```

---

## 作者：aimat (赞：1)

有 $k$ 个棋盘可以操作，且操作没有顺序，那么这个题明显只能用 SG 函数做。

考虑单个棋盘的 SG 函数值，容易发现两个行或两个列交换后与原棋盘等价，那么我们一定可以将 $0$ 平移到左上角 $3\times3$ 的区域内。发现将棋盘转置也没有影响，于是发现初始等价类只有 $4$ 种。分别为：
```
0:
000
111
111
1:
001
011
111
2:
011
101
110
3:
001
110
111
```
发现进行转移时还会有其他等价类，可以发现还有以下几种：
```
4:
001
111
111
5:
011
111
111
6:
011
101
111
7:
111
111
111
```
一个状态的 SG 函数只与当前行列数和类型有关，那么直接对 $SG_{n,m,o}$ 分讨转移即可，采用记搜会好写一点（可能吧）。边界非常多，注意分讨精细。因为发现转移不会超过 $11$ 种，那么 SG 函数值不超过 $11$，计算 $\operatorname{mex}$ 可以用位运算写，时空复杂度比较小。

总时间复杂度为巨大（约 $60$ 倍）常数的 $O(nm+k)$。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef unsigned char uc;
char *p1,*p2,buf[100010];
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read(){
	int x=0;
	char c=gc();
    while(c<48)c=gc();
	while(47<c)x=(x<<3)+(x<<1)+(c&15),c=gc();
	return x;
}
const size_t S=4095;
uc SG[510][510][8],vs[510][510][8];
/*
0:
000
1:
00
0
2:
0
 0
  0
3:
00
  0
4:
00
5:
0
6:
0
 0
7:
1
*/
void add(size_t&x,uc y){
	x&=1<<y^S;
}
uc solve(int n,int m,uc o){
	if(!n||!m)return 0;
	if(vs[n][m][o])return SG[n][m][o];
	vs[n][m][o]=1;
	if(n==1){
		if(m==3&&!o)return SG[n][m][o];
		if(m==2&&o==4)return SG[n][m][o];
		if(m==1&&o==5)return SG[n][m][o];
	}
	size_t ans=S;
	switch(o){
		case 5:
			if(m!=1)add(ans,solve(n-1,m,7));
			if(n!=1)add(ans,solve(n,m-1,7));
			add(ans,solve(n-1,m-1,7));
		case 7:
			add(ans,solve(n-1,m-1,o));
			add(ans,solve(n-1,m,o));
			add(ans,solve(n,m-1,o));
			break;
		case 6:
			if(n!=2)add(ans,solve(n-1,m,o));
			if(m!=2)add(ans,solve(n,m-1,o));
			if(n!=2&&m!=2)add(ans,solve(n-1,m-1,o));
			add(ans,solve(n-1,m,5));
			add(ans,solve(n,m-1,5));
			add(ans,solve(n-1,m-1,5));
			add(ans,solve(n-1,m-1,7));
			break;
		case 4:
			add(ans,solve(n-1,m,o));
			if(m!=2){
				add(ans,solve(n-1,m-1,o));
				add(ans,solve(n,m-1,o));
			}
			if(n!=1)add(ans,solve(n,m-1,5));
			if(m!=2)add(ans,solve(n-1,m,7));
			add(ans,solve(n-1,m-1,5));
			add(ans,solve(n-1,m-1,7));
			break;
		case 3:
			if(n!=2){
				add(ans,solve(n-1,m,o));
				add(ans,solve(n-1,m-1,6));
			}
			if(m!=3)add(ans,solve(n,m-1,o));
			if(n!=2&&m!=3)add(ans,solve(n-1,m-1,o));
			add(ans,solve(n-1,m,4));
			add(ans,solve(n-1,m,5));
			add(ans,solve(n,m-1,6));
			add(ans,solve(n,m-1,4));
			add(ans,solve(n-1,m-1,4));
			add(ans,solve(n-1,m-1,7));
			add(ans,solve(n-1,m-1,5));
			break;
		case 2:
			if(n!=3)add(ans,solve(n-1,m,o));
			if(m!=3)add(ans,solve(n,m-1,o));
			if(n!=3&&m!=3)add(ans,solve(n-1,m-1,o));
			add(ans,solve(n-1,m,6));
			add(ans,solve(n,m-1,6));
			add(ans,solve(n-1,m-1,6));
			add(ans,solve(n-1,m-1,5));
			break;
		case 1:
			if(n!=2){
				add(ans,solve(n-1,m,o));
				add(ans,solve(n,m-1,5));
				add(ans,solve(m-1,n-1,4));
			}
			if(m!=2){
				add(ans,solve(n,m-1,o));
				add(ans,solve(n-1,m,5));
				add(ans,solve(n-1,m-1,4));
			}
			if(n!=2&&m!=2)add(ans,solve(n-1,m-1,o));
			if(n!=2||m!=2)add(ans,solve(n-1,m-1,7));
			add(ans,solve(n-1,m,4));
			add(ans,solve(m-1,n,4));
			add(ans,solve(n-1,m-1,5));
			break;
		default:
			add(ans,solve(n-1,m,o));
			if(m!=3){
				add(ans,solve(n,m-1,o));
				add(ans,solve(n-1,m-1,o));
				add(ans,solve(n-1,m,7));
			}
			if(n!=1)add(ans,solve(n,m-1,4));
			add(ans,solve(n-1,m-1,4));
			add(ans,solve(n-1,m-1,7));
	}
	return SG[n][m][o]=__builtin_ctz(ans);
}
int main(){
	int k=read(),n,m,x1,x2,x3,y1,y2,y3;
	uc ans=0;
	while(k--){
		n=read();
		m=read();
		x1=read();
		y1=read();
		x2=read();
		y2=read();
		x3=read();
		y3=read();
		if(x1==x2&&x2==x3)ans^=solve(n,m,0);
		else if(y1==y2&&y2==y3)ans^=solve(m,n,0);
		else if(x1!=x2&&x1!=x3&&x2!=x3)
			if(y1!=y2&&y2!=y3&&y1!=y3)ans^=solve(n,m,2);
			else ans^=solve(m,n,3);
		else if(y1!=y2&&y1!=y3&&y2!=y3)ans^=solve(n,m,3);
		else ans^=solve(n,m,1);
	}
	puts(ans?"OvO":"QAQ");
	return 0;
}
```

---


# [THUPC 2024 决赛] 贸易

## 题目描述

小 Z 生活的学校就像是一条链，直径很长，宽度很窄。

具体来说，这里有一个长度为 $n$ 的序列，每个位置有一个属性 $a_i\in \{0/1\}$ 和一个类型 $c_i$，在这里有一些贸易事件会发生。

小 Z 从左往右通过这个序列，若当前遇到一个 $0$ 属性的节点，则小 Z 可以购入至多一个 $c_i$ 类型的物品，若当前遇到一个 $1$ 属性的节点，则小 Z 可以卖出至多一个 $c_i$ 类型的物品，显然，在小 Z 没有这种类型的物品时是不能卖出的。

一次合法的交易定义为从某个节点买入，并在某个节点卖出，注意，你需要保证在最后小 Z 手里不存在任何东西。

给出 $q$ 次询问，每次小 Z 从 $l_i$ 顺序走到 $r_i$，问：最大合法交易次数是多少。

## 说明/提示

对于所有数据，满足 $1\le n,q\le5\times 10^5,1\le c_i\le n,1\le l_i\le r_i\le n,a_i\in\{0,1\}$。

请注意输入输出效率。


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
10 5
1 1 0 0 0 0 0 1 1 1 
1 1 1 1 1 1 1 1 1 1 
4 6
2 4
2 6
7 10
4 7
```

### 输出

```
0
0
0
1
0
```

# 题解

## 作者：win114514 (赞：10)

正式场上拿了这题的首 $A$，让队伍不至于无奖而返。

### 思路

容易发现题目的买入卖出过程形似一个括号匹配。

那么我们可以对每一种类型的物品做括号匹配。

若是一个匹配的括号在询问区间内则可以记入答案。

就变成了一个二维数点问题。

离线树状树组即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define fro(i, x, y) for (int i = (x); i <= (y); i++)
#define pre(i, x, y) for (int i = (x); i >= (y); i--)

const int N = 5e5 + 10;

int n, q, a[N], c[N], p[N], t[N], l[N], r[N], ans[N];
vector<int> d[N];
vector<int> o[N];

inline void upd(int x) { while (x) t[x]++, x -= (x & (-x)); }
inline auto ask(int x) { int r = 0; while (x <= n) r += t[x], x += (x & (-x)); return r; }

signed main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> q;
  fro(i, 1, n) cin >> a[i];
  fro(i, 1, n) cin >> c[i];
  fro(i, 1, n) {
    if (a[i] == 0) d[c[i]].push_back(i);
    if (a[i] == 1) if (!d[c[i]].empty()) p[i] = d[c[i]].back(), d[c[i]].pop_back();
  }
  fro(i, 1, q) cin >> l[i] >> r[i], o[r[i]].push_back(i);
  fro(i, 1, n) {
    if (p[i]) upd(p[i]);
    for (auto j : o[i]) {
      ans[j] = ask(l[j]);
    }
  }
  fro(i, 1, q) cout << ans[i] << "\n";
  return 0;
}
```

---

## 作者：Masterwei (赞：7)

贪心好题。想着想着发现了此题的妙处，然后就很简单了。

### 思路

考虑贪心。对于每一个卖出点 $j$，我们贪心地去找与它最近的一个买入点 $i$，定义其为 $(i,j)$，然后将这个这两个点从序列中删去。询问区间 $[l,r]$ 的时候，就只用算有多少对 $(i,j)$ 满足 $i\in[l,r],j\in[l,r]$。

为什么是对的呢？因为如果存在一个买入点 $i$，两个卖出点 $j,k$，满足 $i<j<k$，$i,k$ 匹配肯定 $i,j$ 也可以匹配，那么匹配 $i,j$ 肯定是不劣于匹配 $i,k$ 的。

所以此问题被转化为一个二维数点，离线后用树状数组即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
  int x=0;bool f=0;char ch=getchar();
  while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
  while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
  return f?-x:x;
}
const int Maxn=5e5+5;
int n,q,b[Maxn],ans[Maxn];
struct node{int op,c;}a[Maxn];
struct Query{int l,id;};
vector<Query>Q[Maxn];
stack<int>stk[Maxn];
int t[Maxn];
inline void add(int x){
	for(;x<=n;x+=x&-x)t[x]++;
}
inline int query(int x){
	int res=0;
	for(;x;x-=x&-x)res+=t[x];
	return res;
}
int main(){
//	freopen("P10550_2.in","r",stdin);
//	freopen("P10550.out","w",stdout);
	n=read();q=read();
	for(int i=1;i<=n;i++)a[i].op=read();
	for(int i=1;i<=n;i++){
		a[i].c=read();
		if(a[i].op==0)stk[a[i].c].push(i);
		else if(stk[a[i].c].size())b[i]=stk[a[i].c].top(),stk[a[i].c].pop();
	}
	for(int i=1;i<=q;i++){
		int l=read(),r=read();
		Q[r].push_back({l,i});
	}
	for(int i=1;i<=n;i++){
		if(b[i])add(b[i]);
		for(int j=0;j<Q[i].size();j++)
			ans[Q[i][j].id]=query(n)-query(Q[i][j].l-1);
	}
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：_AyachiNene (赞：6)

# 思路：
这道题看着就长得像扫描线，直接往扫描线上想。考虑以 $r$ 为扫描线，新加进来的物品对答案的影响，假设当前点只能卖，如果要想完成一次交易就要在前面找一个买入点和它匹配，这是就有一个问题，那就是到底选前面的哪一个点买入。很容易想到一个贪心，就是直接和最后一个买入点匹配。原因很好想，在扫描线时，一个点在更后面更容易产生贡献，而每次查询时，只和左端点有关，所以一个点产生的贡献是与右端点无关的，要想早算到这个点的贡献，就先把它加进来就行了。所以只用根据类型开几个栈，每次如果是买入就压栈，否则就把栈顶加到数据结构里，查询就区间查就行了。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
	if(x<0){putchar('-');x=-x;}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,m;
stack<int>stk[500005];
struct que
{
	int l,r,id;
}q[500005];
bool cmp(que x,que y){return x.r<y.r;}
int a[500005],b[500005];
int ans[500005];
namespace Elaina
{
	int t[500005];
	inline int lowbit(int x){return x&-x;}
	inline void add(int x,int v){for(;x<=n;x+=lowbit(x)) t[x]+=v;}
	inline int Query(int x){int res=0;for(;x;x-=lowbit(x)) res+=t[x];return res;}
	inline int query(int x,int y){return Query(y)-Query(x-1);}
}
using namespace Elaina;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read();
	for(int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].id=i;
	sort(q+1,q+m+1,cmp);
	int cur=1;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==0) stk[b[i]].push(i);
		else if(a[i]==1&&stk[b[i]].size()) add(stk[b[i]].top(),1),stk[b[i]].pop();
		while(q[cur].r==i&&cur<=m)
		{
			ans[q[cur].id]=query(q[cur].l,i);
			++cur;
		}
	}
	for(int i=1;i<=m;i++) write(ans[i]),puts("");
	return 0;
}
```

---

## 作者：Perta (赞：5)

一个显然的贪心是，越晚购买的物品越早卖，否则晚买的物品可以把早买的替换掉，并对左端点更靠右的区间有贡献。

那么对每种类型的物品开一个栈，栈内为还未卖出的物品节点，每次遇到一个可以卖出的节点就弹栈。设栈顶元素为 $L$，卖出节点为 $R$，则询问 $[l_i,r_i]$ 的答案为满足 $[L,R]\subseteq[l_i,r_i]$ 的二元组 $(L,R)$ 的个数。

离线扫描线即可，时间复杂度 $O(n\log n)$。

[Code](https://www.luogu.com.cn/paste/93d2ze5g)

---

## 作者：WrongAnswer_90 (赞：4)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18224757)

### [P10550 [THUPC2024] 贸易](https://www.luogu.com.cn/problem/P10550)

首先可以观察到，对于每种颜色，括号匹配（把 $0$ 看成左括号，$1$ 看成右括号）一定是最优的。所以可以先找出所有匹配 $[x,y]$，然后问题变成给定 $[l,r]$，求有多少个 $[x,y]\subseteq[l,r]$，离线做一遍扫描线，树状数组维护即可。

```cpp
	int n,m,a[500010],ans[500010],pre[500010];
	vector<pii> ve[500010];
	stack<int> st[500010];
	namespace BIT
	{
		int t[500010];
		inline void add(int x){for(;x;x-=x&-x)++t[x];}
		inline int ask(int x){int s=0;for(;x<=n;x+=x&-x)s+=t[x];return s;}
	}
	using namespace BIT;
	inline void mian()
	{
		read(n,m);int x,y;
		for(int i=1;i<=n;++i)read(a[i]);
		for(int i=1;i<=n;++i)
		{
			read(x);
			if(a[i])
			{
				if(st[x].size())pre[i]=st[x].top(),st[x].pop();
			}
			else st[x].e(i);
		}
		for(int i=1;i<=m;++i)read(x,y),ve[y].eb(mp(x,i));
		for(int i=1;i<=n;++i)
		{
			add(pre[i]);
			for(auto p:ve[i])ans[p.se]=ask(p.fi);
		}
		for(int i=1;i<=m;++i)write(ans[i],'\n');
	}
```

---

## 作者：是青白呀 (赞：3)

由于一次合法交易需要有完整的买入和卖出操作，因而最终手里没有东西的限制其实是没有意义的。于是可以考虑贪心地能买就买，能卖就卖。

于是我们可以刻画出每件物品在手上的停留区间。为了便于处理区间询问，当手上有多个同种商品时，我们默认卖出的是最后一次买入的那个商品。于是不难用 $n$ 个栈求出每个可以卖出商品的位置，卖出的是哪个位置买入的商品。我们可以用若干个区间 $[l,r]$ 表示一件商品在 $l$ 处被买入，然后在 $r$ 处卖出。

此时，一个询问 $(L,R)$，就等价于询问区间 $[L,R]$ 中完全包含了多少个表示商品的区间，也即完全覆盖了多少条线段。一个简单的实现方法是将询问离线后按 $R$ 排序，并将每个表示商品的区间挂在右端点 $r$ 上。每次询问区间从 $R\to R+1$ 时，就把 $R+1$ 上挂的所有区间的左端点插入树状数组，然后对每个询问根据其左端点进行区间查询即可。

复杂度 $O(n+q\log n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=5e5+5,S=(1<<20)+5,mo=1e9+7,inf=1e9+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,cntq;
struct qu{
	int l,r,id;
	friend bool operator<(qu x,qu y){
		return x.r<y.r;
	}
}q[N];
int op[N],a[N],c[N],mch[N],ans[N];
vector<int>g[N];
struct BIT{
	int t[N];
	void add(int x,int v){
		for(int i=x;i<=n;i+=lowbit(i))
		    t[i]+=v;
	}
	int query(int x){
		int res=0;
		for(int i=x;i;i-=lowbit(i))
		    res+=t[i];
		return res;
	}
}T;
int main(){
	read(n),read(cntq);
	rep(i,1,n)
	    read(a[i]);
	rep(i,1,n)
	    read(c[i]);
	rep(i,1,n){
		if(a[i]){
			if(!g[c[i]].size())continue;
			mch[i]=g[c[i]].back(),g[c[i]].pop_back(); 
		}
		else g[c[i]].push_back(i);
	}
	rep(i,1,cntq)
	    read(q[i].l),read(q[i].r),q[i].id=i;
	sort(q+1,q+cntq+1);
	int nw=1;
	rep(i,1,cntq){
		while(nw<=q[i].r){
			if(mch[nw])T.add(mch[nw],1);
			nw++;
		}
		ans[q[i].id]=T.query(q[i].r)-T.query(q[i].l-1);
	}
	rep(i,1,cntq)
	    printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Contemplative (赞：2)

# 分析
第一眼就可以看出是关于括号匹配的，贪心的想，右括号肯定是离自己最近的那个未匹配的左括号是最优的。

因为如果一对答案都没有在询问下区间内，那么比他更远的也根本不可能了，即使在此区间这一对内，也不能保证比他更远的一定能匹配。

所以开 $n$ 个栈，来记录下最近的此颜色的左括号，离线处理。

枚举的时候，左括号插入，右括号查询并删除离的最近的左括号。

枚举第 $i$ 个位置，并将能匹配的左括 $+1$ 后再算出以 $i$ 结尾的询问区间的答案，用树状数组就可以，本人甚聪慧将线段树的超大常数加以利用。
# 时间复杂度

$ O((n+q)\log n) $,

排序 $O(n\log n)$,

枚举 $O(n)$,

每次查询 $O(\log n)$。 

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
#define lson (i << 1)
#define rson ((i << 1) | 1)
#define mid ((t[i].l + t[i].r) >> 1)
const int N = 5e5 + 5;
int n, m, l = 1, a[N], c[N], ans[N];
struct tree {
	int l;
	int r;
	int sum;
}t[N << 2];
struct node {
	int l;
	int r;
	int id;
	bool operator < (node &a) const {
		return r < a.r;
	}
}q[N];
void pushup(int i) {
	t[i].sum = t[lson].sum + t[rson].sum;
	return ;
}
void build(int i, int l, int r) {
	t[i].l = l,t[i].r = r;
	if (l == r) {
		t[i].sum = 0;
		return ;
	}
	build(lson, l, mid);
	build(rson, mid + 1, r);
	return ;
}
void update(int i, int l, int k) {
	if (t[i].l == t[i].r) {
		t[i].sum += k;
		return ;
	}
	if (l <= mid) update(lson, l, k);
	else update(rson, l, k);
	pushup(i);
	return ;
}
int query(int i, int l, int r) {
	if (t[i].l >= l && t[i].r <= r) return t[i].sum;
	int ans = 0;
	if (l <= mid) ans += query(lson, l, r);
	if(r > mid) ans += query(rson, l, r);
	return ans; 
}
stack<int> stk[N];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	build(1, 1, n);
	for (int i = 1; i <= n; ++i) cin >> a[i];
	for (int i = 1; i <= n; ++i) cin >> c[i];
	for (int i = 1; i <= m; ++i) {
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
	}
	sort(q + 1, q + m + 1);
	for (int i = 1; i <= n; ++i) {
		if(a[i] == 0) stk[c[i]].push(i);
		else if(a[i] == 1 && stk[c[i]].size()) update(1, stk[c[i]].top(), 1), stk[c[i]].pop();
		while (q[l].r == i&& l <= m) {
			ans[q[l].id] = query(1, q[l].l, q[l].r);
			l++;
		}
	}
	for (int i = 1; i <= m; ++i) cout << ans[i] << "\n";
	return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：1)

好的如你所见，这道题有一个贪心策略：每次找到一个**最近的未匹配**同色点，计入答案。

然后我们定义当前点为 $x$，然后 $l_{x}$ 为上述满足条件的点啊。

很显然，我们需要求解 $i$ 区间为 $(i,l_{i})$ 在 $(l,r)$ 询问范围内的点。

这个就是典型的[二维数点问题](https://blog.csdn.net/qq_30320171/article/details/129787418)。

具体的离线，枚举 $r$，然后依次插入对应的 $l_{x}$，统计区间 $sum_{l,r}$ 即可。

因为对于 $r$，我们能够严格限制目前集合内右端点都小于等于它，然后就是 CDQ 分治的套路了，这个过程实际上就是个类似 CDQ 的过程。

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long//<--烂习惯 
const int N=5e5+5;
struct Point{
	int l,r,id;
}wt[N];
int n,q,a[N],b[N],c[N],ans[N];
stack <int> tlh[N];
bool cmp(Point x,Point y){
	return x.r<y.r;
}
void insert(int x){
	for(;x<=n;x+=x&(-x))c[x]++;
}
int query(int x){
	int ans=0;
	for(;x;x-=x&(-x))ans+=c[x];
	return ans;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> q;
	for(int i = 1;i <= n;i++)cin >> a[i];
	for(int i = 1;i <= n;i++)cin >> b[i];
	for(int i = 1;i <= q;i++){
		cin >> wt[i].l >> wt[i].r;
		wt[i].id=i;
	}
	sort(wt+1,wt+1+q,cmp);
	int l=1;
	for(int i = 1;i <= n;i++){
		if(!a[i])tlh[b[i]].push(i);
		else if(tlh[b[i]].size()>0){
			insert(tlh[b[i]].top());
			tlh[b[i]].pop();
		}
		while(wt[l].r==i&&l<=q){
			ans[wt[l].id]=query(wt[l].r)-query(wt[l].l-1);
			l++;
		}
	}
	for(int i = 1;i <= q;i++)cout << ans[i] << "\n";
	return 0;
}
```

---

## 作者：liyifan202201 (赞：1)

## 闲话
~~巨佬 @[man_8_24](https://www.luogu.com.cn/user/1359984) 让我帮他改改题解，我优化了**亿点点**...~~ 求管理大大过审吧。
## 思路
这题一看就是贪心，购买时间越晚的物品越早卖，否则时间晚买的物品可以把时间早买的给换掉，并对左端点更靠右的物品有贡献

那么对每种类型的物品开一个栈，栈内为还未卖出的物品节点，每次遇到一个可以卖出的节点就弹栈。设栈顶元素为 $L$，卖出节点为 $R$，则询问 $[l_i,r_i]$ 的答案为满足 $[L,R] \subseteq [li,ri]$ 的二元组 $(L,R)$ 的个数。

时间复杂度: $O(\log n)$。

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x;
}
int stk[10],tp;
inline void write(int x)
{
    if(!x) return puts("0"),void();
    tp=0;
    while(x) stk[++tp]=x%10,x/=10;
    while(tp) putchar(stk[tp--]^48);
    putchar('\n');
}
const int N=5e5+10;
struct ok{
    int l,id;
};
int n,q,a[N],c[N],Tr[N],ans[N];
vector<int>Q[N];
vector<ok>ask[N];
void add(int x) {for(;x;x-=(x&-x)) ++Tr[x];}
int query(int x,int res=0) {for(;x<=n;x+=(x&-x)) res+=Tr[x];return res;}
int main()
{
    n=read(),q=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1,x;i<=n;i++)
    {
        x=read();
        if(a[i]&&!Q[x].empty()) c[i]=Q[x].back(),Q[x].pop_back();
        if(!a[i]) Q[x].push_back(i);
    }
    for(int i=1,l,r;i<=q;i++)
        l=read(),r=read(),ask[r].push_back((ok){l,i});
    for(int i=1;i<=n;i++)
    {
        add(c[i]);
        for(ok x:ask[i]) ans[x.id]=query(x.l);
    }
    for(int i=1;i<=q;i++) write(ans[i]);
    return n&0;
}

---

## 作者：可爱的小棉羊 (赞：1)

这道题还是挺常规的，但是没想出来，题刷少了。

首先很显然的一件事是，

我们相当于在跑**有颜色**的括号对，那么我们先整体跑一下括号对，对于每组括号对，我们可以记为 $(l,r)$ 表示这组贡献。

那么每对询问就是在询问有多少个 $(l,r)$，包含在整个区间当中。

这就是老套路二维数点问题，具体过程如下：

将问题离线，按 $r$ 排序，对于每个询问 $(ql,qr)$。

我们就可以动态地维护所有 $r<qr$ 的 $l$。

每个询问已经确定了 $r$，我们用权值树状数组来维护就可以了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
struct node{
	int l,r;
}num[500005];
struct Node{
	int ans;
	int id,l,r;
}qu[500005];
int n,q,cnt;
bool f[500005];
stack<int>st[500005];
//void cmp(node x,node y){
//	return x.l<y.l;
//}
bool Cmp(Node x,Node y){
	return x.r<y.r;
}
bool Cmp2(Node x,Node y){
	return x.id<y.id;
}
int sum[500005];
int lowbit(int x){
	return x&(-x);
}
void add(int x){
//	cout<<x<<endl;
	for(int i=x;i<=n;i+=lowbit(i))sum[i]++;
}
int get(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i))ans+=sum[i];
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>f[i];
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		if(f[i]==0){
//			cout<<"push "<<i<<endl;
			st[x].push(i);
			continue;
		}
		if(!st[x].empty()){
			node p;
			p.l=st[x].top();
			p.r=i;
//			cout<<"pop "<<i<<endl;
			st[x].pop();
//			cout<<p.l<<" "<<p.r<<endl;
			num[++cnt]=p;
		}
	}
//	sort(num+1,num+cnt+1,cmp);
	int pos=1;
	for(int i=1;i<=q;i++){
		cin>>qu[i].l>>qu[i].r;
		qu[i].id=i;
	}
	sort(qu+1,qu+q+1,Cmp);
	for(int i=1;i<=q;i++){
//		cout<<qu[i].l<<" "<<qu[i].r<<"\n\n";
		while(pos<=cnt&&num[pos].r<=qu[i].r){
			add(num[pos].l);
//			cout<<num[pos].l<<" "<<num[pos].r<<endl;
			pos++;
		}
		qu[i].ans+=get(n)-get(qu[i].l-1);
	}
	sort(qu+1,qu+q+1,Cmp2);
	for(int i=1;i<=q;i++)cout<<qu[i].ans<<endl;
} 
```

---

## 作者：kkxacj (赞：1)

#### 思路

考虑转化此题，容易发现对于每一个 $a_i = 0$ 的找它**前面离它最近**且**未被使用**然后又要满足 $a_j=1,b_j=b_i$ 的点，这样做肯定是最优的。

简单证明如下：

假设 $a_i = 0$，且存在一个 $j$ 满足上述条件，那么如果询问 $l > j$，显然 $l$ 到 $i$ 的那些 $a_z=1,b_z=a_i$ 的点都已经匹配了，否则 $j$ 就会变大，它如果匹配了 $l$ 到 $i$ 的那么一定会有其它的无法匹配，那跟它不匹配答案是一样的，

若 $l \le j$ 肯定也选 $j$，因为就算有其它满足情况的，匹配后加的贡献不变，所以选 $j$ 匹配更好。

证毕。

那么我们就把题目转化了，也就是有若干个二元组 $\left (l_i,r_i  \right )$，问 $L$ 到 $R$ 中有多少个 $i$ 满足 $L \le l_i,r_i \le R$。

然后直接按左端点排序，满足前一个条件后树状数组维护最后一个条件即可。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
const int N = 5e5+10;
int n,q,a[N],b[N],id[N],d[N],e[N],l,cnt,ans[N];
struct w
{
	int l,r,id;
}c[N];
struct w2
{
	int l,r,id;
}f[N];
vector<int>w1[N];
inline bool cmp(w x,w y){return x.l<y.l;}
inline bool cmp1(w2 x,w2 y){return x.l<y.l;}
inline void add(int x,int y){while(x<=n) e[x]+=y,x+=x&-x;}
inline int query(int x){int ans = 0;while(x) ans+=e[x],x-=x&-x;return ans;}
int main()
{
	read(n),read(q);
	for(int i = 1;i <= n;i++) read(a[i]);
	for(int i = 1;i <= n;i++) 
	{
		read(b[i]);
		if(a[i] == 0) w1[b[i]].push_back(0); 
	}
	for(int i = 1;i <= q;i++) read(c[i].l),read(c[i].r),c[i].id = i;
	sort(c+1,c+1+q,cmp);
	for(int i = 1;i <= n;i++)
	{
		if(a[i] == 0) w1[b[i]][id[b[i]]] = i,id[b[i]]++; 
		else if(id[b[i]]) f[++cnt].l=w1[b[i]][--id[b[i]]],f[cnt].r=i;
	}
	sort(f+1,f+1+cnt,cmp1); l = 1;
	for(int i = 1;i <= cnt;i++) add(f[i].r,1);
	for(int i = 1;i <= q;i++)
	{
		while(l <= cnt && c[i].l > f[l].l) add(f[l].r,-1),l++;
		ans[c[i].id] = query(c[i].r);
	}
	for(int i = 1;i <= q;i++) print(ans[i]),pc('\n');
	flush();
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

询问相当于求一个区间内有多少对匹配的括号。

考虑对于每一种类型的物品做一遍括号匹配，即开 $n$ 个栈，记录一下每次成功匹配的左端点和右端点 $l_i,r_i$。

转化为求一个区间内有多少条线段，直接扫描线即可。

时间复杂度为 $O((N+Q) \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
const ll N=5e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,q,l,r,sum;
ll a[N],c[N],ans[N];
vector<ll> E[N];
vector<pair<ll,ll>> G[N];
stack<ll> T[N];
class Tree{
public:
	ll a[N];
	void add(ll x,ll v){
		for(int i=x;i<=n;i+=lowbit(i))
		  a[i]+=v;
	}
	ll query(ll x){
		ll ans=0;
		for(int i=x;i;i-=lowbit(i))
		  ans+=a[i];
		return ans;
	}
}H;
int main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++)
	  a[i]=read();
	for(int i=1;i<=n;i++)
	  c[i]=read();	
	for(int i=1;i<=n;i++){
		if(!a[i])
		  T[c[i]].push(i);
		else{
			if(T[c[i]].empty())
			  continue;
			E[i].push_back(T[c[i]].top());
			T[c[i]].pop();
		}
	}  
	for(int i=1;i<=q;i++){
		l=read(),r=read();
		G[r].push_back({l,i}); 
	}
	for(int i=1;i<=n;i++){
		for(auto v:E[i]){
			H.add(v,1);
			sum++;
		}
		for(auto t:G[i]){
			ll v=t.first,id=t.second;
			ans[id]=sum-H.query(v-1);
		}
	}
	for(int i=1;i<=q;i++){
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```

---


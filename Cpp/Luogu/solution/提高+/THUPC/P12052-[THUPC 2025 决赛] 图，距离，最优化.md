# [THUPC 2025 决赛] 图，距离，最优化

## 题目描述

给定 $n$ 个非负整数 $x_1,x_2,\dots,x_n$。

对于任意 $n$ 个节点的无向连通图 $G$，将其节点由 $1$ 至 $n$ 标号，则其分数定义为：

$$\text{score}(G) = \sum_{i=1}^n \sum_{j=i+1}^n \text{dist}_G(i, j)x_ix_j$$

其中 $\text{dist}_G(i,j)$ 表示图 $G$ 上 $i$ 到 $j$ 的最短路径长度。

你的任务是输出所有 $n$ 个节点的无向连通图中分数的最大值。

## 说明/提示

### 样例 #1 解释

对于第一组测试数据，只有一种合法方案 $G = \{(1,2)\}$。

对于第二组测试数据，一个最优方案为 $G = \{(1,2),(2,3),(2,4)\}$。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
3
2
1 2
4
1 0 1 1
7
1 2 3 4 5 6 7
```

### 输出

```
2
6
1044
```

# 题解

## 作者：fish_love_cat (赞：9)

首先答案与给出的节点顺序无关，考虑降序排序。

---

我们猜想 $G$ 最优时一定是一棵树。

证明：

如果说 $G$ 已经是一棵树了，再加一条边一定会多一条路径，那么最短路径一定不会变长，相反可能变的更加不优秀。

于是最优情况下 $G$ 一定是树。

---

进一步猜想 $G$ 最优时一定是一条链。

证明：

如果说 $G$ 已经是一条链了，我们把其中一段截出来接在某个度已经为 $2$ 的点上使其成为一个树，距离显然是会变小的，与其这样做令该点试图贪两头贡献，不如尽可能延长距离最大化答案。

于是最优情况下 $G$ 一定是链。

---

现在可以直接当序列来做了。

于是想到把最大值放两头贪心构造序列，但是这连样例都过不了。

为了最大化距离，我们对于大的数字放在左右两头显然是比放中间优秀的。

发现只用分讨两种情况，所以我们大力 dp 即可。

---

注意极小值要足够小，不然会出现[这种东西](https://www.luogu.com.cn/record/213720771)。

答案很大要开 `long long`。

**多测清空。**

做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[305],b[2][600005];
bool cmp(int x,int y){
    return x>y;
}
void solve(){
    int n;
    cin>>n;
    a[0]=0;//多测清空多测清空多测清空多测清空多测清空
    for(int i=1;i<=n;i++)
        cin>>a[i],a[0]+=a[i];
    sort(a+1,a+1+n,cmp);
    for(int i=0;i<=a[0];i++)
        b[0][i]=b[1][i]=-114514;
    b[0][0]=0;
    b[1][0]=0;
    int m=0;
    for(int i=1;i<=n;i++){
        m+=a[i];
        for(int j=0;j<=m;j++){
            int ret=m-j-a[i];
            ret=b[(i+1)&1][j]+ret*(a[0]-ret);
            if(j>=a[i])ret=max(ret,b[(i+1)&1][j-a[i]]+j*(a[0]-j));
            b[(i)&1][j]=ret;
        }
    }
    int ans=0;
    for(int i=0;i<=a[0];i++)
        ans=max(ans,b[n&1][i]);
    cout<<ans<<'\n';
}
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：mango2011 (赞：2)

vp 的时候拿下了。

根据题目的这个柿子，可以发现肯定是构造成一棵树。因为环只会导致最短路变短，肯定不优。进一步发现应该构造成一条链，同样调整法易证。柿子可以变成 $\displaystyle\sum_{i=1}^{n}\displaystyle\sum_{j=i+1}^{n}(j-i)x_ix_j=\displaystyle\sum_{i=1}^{n-1}(x_1+x_2+\dots+x_i)(x_{i+1}+x_{i+2}+\dots+x_n)$。考虑从大到小把数放进去。观察到肯定是放左或右的第一个空位，还是调整法易证。因此就可以设计如下 dp：

$f_{i,j}$ 表示前 $i$ 个数，前缀的和为 $j$，当前已知位置的贡献和的最大值。这样设计是因为前 $i$ 个数的和一定，知道前缀的和就可以知道后缀的和，转移的时候分类讨论是放在左边还是右边就可以了。

代码写得非常丑，仅供参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int long long
const int maxn=305;
const ll inf=1e18;
void solve(){
	int n,sum=0;cin>>n;
	vector<int>a(n+5);
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
	sort(a.begin()+1,a.begin()+1+n,greater<int>());
	vector<ll>f(sum+5,-inf),g(sum+5,-inf);
	g[0]=0;
	int pre=0;
	for(int i=1;i<=n;i++){
		pre+=a[i];
		for(int j=0;j<=pre;j++){
			f[j]=g[j]+(pre-j-a[i])*(sum-(pre-j-a[i]));
			if(j>=a[i]) f[j]=max(f[j],g[j-a[i]]+j*(sum-j));
		}
		for(int j=0;j<=pre;j++) g[j]=f[j],f[j]=-inf;
	}
	ll ans=0;
	for(int i=0;i<=sum;i++) ans=max(ans,g[i]);
	cout<<ans<<"\n";
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(0);
	int T;cin>>T;
	while(T--) solve();
	return 0;
}
```

---


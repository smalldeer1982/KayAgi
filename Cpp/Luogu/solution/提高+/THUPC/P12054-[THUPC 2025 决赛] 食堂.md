# [THUPC 2025 决赛] 食堂

## 题目背景

……所以为什么会有两道食堂题？

## 题目描述


有一个位于第一象限的食堂。

食堂被划分为若干个 $1\times 1$ 的区域，区域 $(x,y)$ 为以 $(x,y),(x,y+1),(x+1,y),(x+1,y+1)$ 为顶点的正方形。称两个区域 $(x_1,y_1)$ 和 $(x_2,y_2)$ **相邻**当且仅当 $|x_1-x_2|+|y_1-y_2|=1$。

区域有两种类型，一种是可供顾客自由走动的过道，另一种是可供顾客坐下用餐的座位。食堂里的座位非常多，而且排布得很有规律：所有满足 $x\bmod 3\ne 0$ 且 $y\bmod 3\ne 0$ 的区域 $(x,y)$ 是座位，其他区域都是过道。四个相连的座位构成一张餐桌。

从上空俯瞰，食堂中座位的排布方式如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lbsgpuuw.png)


在过道上，顾客可以自由移动。具体地，如果顾客当前位于过道 $(x,y)$，他可以走一步，移动到相邻的区域。如果顾客移动到了座位，他就会在此坐下。

顾客对座位的偏好可以用容忍度 $o\in\{0,1,2\}$ 来描述，其中：

- $o=0$ 的顾客只愿意坐到对应**餐桌**没有人的**空座位**上吃饭。

- $o=1$ 的顾客只愿意坐到相邻**座位**没有人的**空座位**上吃饭。

- $o=2$ 的顾客愿意坐在任何**空座位**上吃饭。

当一个顾客坐下之后，他就会专注地吃饭，就算有其他顾客出现，导致当前的座位变成他不愿意坐的座位，他也不会因此离开。

最开始的时候，餐厅里一个顾客也没有。接下来**依次**发生了 $q$ 个事件，每个事件是以下两种之一：

- 第一种事件：具有某个容忍度 $o$ 的顾客从区域 $(0,0)$ 进入餐厅，他会寻找移动步数最少的、他愿意坐的座位坐下，如果这样的座位有多个，顾客会选择 $x$ 坐标最小的，如果还有多个则会选择 $y$ 坐标最小的。
- 第二种事件：座位 $(x,y)$ 的状态发生了变化，如果原来有顾客坐在这里，这个顾客会立刻离开餐厅；如果原来这个座位上没有顾客，则会出现一个顾客坐在这里。

你需要对于第一种事件求出顾客选择的座位，对于第二种事件求出是有人离开还是有人坐下。


## 说明/提示

### 样例 #1 解释


以下图片展示了每一步操作影响的位置。数字标识了操作的编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/6b57o2dl.png)



### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
10
1 0
1 0
2 1 1
2 2 2
1 0
1 1
1 2
1 2
1 2
1 1
```

### 输出

```
1 1
1 4
out
in
4 1
1 1
1 2
2 1
1 5
1 7
```

# 题解

## 作者：myee (赞：2)

### 前言

出题人题解。

如你所见这是在你清食堂吃饭的真实经历……

原本是命题会上发现缺一个模拟，于是我就掏出了一个这个，大家一致通过后就选上了。

应该算是近几年 THUPC 最简单的几道模拟之一了？

本题的 [CF ver.](https://www.luogu.com.cn/problem/CF2090C) 是一个弱化版本，可以进一步优化到不带 $\log$。

### 思路

观察到性质：当座位同样可选时，优先级是确定的。我们不妨先对此进行排序。这部分使用 BFS 或者数学方法 $d(x,y)=x+y+2[x\bmod3=y\bmod3=2]$ 容易做到线性。

那么我们的目标每次就是要找到一个编号尽可能小的符合某种要求的可选座位，或者翻转某个座位的状态。

观察到找到可选座位的过程只可能涉及 $O(\sqrt q)$ 坐标范围内的桌子（是一个 $3000$ 左右的上界），我们不妨把坐标范围不在指定范围内的翻转操作单独用一个哈希表来处理。

这样为了维护第一种操作，我们只用考虑 $O(q)$ 级别的信息了。

注意到，“找到编号尽可能小”本身是一个常用**堆**维护的结构。而这里我们每次翻转一个座位的状态时，对应的四个格子的可行性都可能发生改变，于是有相应的插入或者删除操作。

也即，我们需要用**可删堆**维护每种忍受度的可行编号集合，具体可以使用 `set` 或者两个 `priority_queue` 来快速实现。

总复杂度 $O(n\log n)$。

### Code

为了写的尽可能简单一点，std 没有加一些优化。如果加了的话应该能快一倍？

最终 std 不到 2kb。

```cpp
// キミは泣いた後 笑えるはずだから って言ったんだ
// 仆らの旅 忘れたりしないよ
// 失くさないよう魔法かけて さよならを伝えない
// 歩き出すよ またいつか

#include <bits/stdc++.h>

using uint = unsigned;
using bol = bool;

const uint W=10001;
const uint T=3031;
const uint R=2000000;

bol G[T*T];
uint Id[T*T],Ord[R+5];

uint Nxt(uint p,uint o)
{
    uint x=p/T,y=p%T;
    if(o&1)y=y/3*3+3-y%3;
    if(o&2)x=x/3*3+3-x%3;
    return x*T+y;
}

std::set<uint>P[3],Q;

bol flip(uint x,uint y)
{
    if(x>=T||y>=T)
    {
        if(Q.count(x*W+y))return Q.erase(x*W+y),0;
        return Q.insert(x*W+y),1;
    }
    uint p[4]={0,0,0,0};for(uint i=0;i<4;i++)p[i]=Nxt(x*T+y,i);
    if(G[p[0]])
    {
        G[p[0]]=0;
        for(uint o=0;o<4;o++)if(~Id[p[o]])
        {
            if(!G[p[o]]&&!o)P[2].erase(Id[p[o]]);
            if(!G[p[o]]||!G[p[o^1]]||!G[p[o^2]])P[1].erase(Id[p[o]]);
            P[0].erase(Id[p[o]]);
        }
        return 1;
    }
    else
    {
        G[p[0]]=1;
        for(uint o=0;o<4;o++)if(~Id[p[o]])
        {
            if(G[p[o]])
            {
                if(!o)P[2].insert(Id[p[o]]);
                if(G[p[o^1]]&&G[p[o^2]])
                {
                    if(o!=3)P[1].insert(Id[p[o]]);
                    if(G[p[o^3]])P[0].insert(Id[p[o]]);
                }
            }
        }
        return 0;
    }
}

int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    freopen("QAQ.out","w",stdout);
#endif
    G[0]=true;
    for(auto&s:Id)s=-1;
    for(uint tp=0,c=1;tp<R;)
    {
        static uint Now[50005],Next[50005];
        uint t=0;
        for(uint j=0;j<c;j++)
        {
            uint p=Now[j];
            if(p%T&&!G[p-1])G[p-1]=true,Next[t++]=p-1;
            if(p/T&&!G[p-T])G[p-T]=true,Next[t++]=p-T;
            if(p%T+1<T&&!G[p+1])G[p+1]=true,Next[t++]=p+1;
            if(p/T+1<T&&!G[p+T])G[p+T]=true,Next[t++]=p+T;
        }
        std::sort(Next,Next+t),c=0;
        for(uint j=0;j<t;j++)if(Next[j]/T%3&&Next[j]%T%3){if(tp<R)Ord[Id[Next[j]]=tp++]=Next[j];}else Now[c++]=Next[j];
    }
    for(auto&s:G)s=1;
    for(uint i=0;i<R;i++)P[0].insert(i);
    P[1]=P[2]=P[0];
    uint q;scanf("%u",&q);
    while(q--)
    {
        uint t;scanf("%u",&t);
        if(t==1)
        {
            scanf("%u",&t);t=Ord[*P[t].begin()];
            uint x=t/T,y=t%T;printf("%u %u\n",x,y),flip(x,y);
        }
        else
        {
            uint x,y;scanf("%u%u",&x,&y);puts(flip(x,y)?"in":"out");
        }
    }
    return 0;
}
```

---


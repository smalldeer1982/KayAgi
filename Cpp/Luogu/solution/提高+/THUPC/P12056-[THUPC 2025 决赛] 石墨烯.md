# [THUPC 2025 决赛] 石墨烯

## 题目描述

Ecrade_ 看着食堂里来回游走等位的人们陷入了沉思，于是他想到了这样一个问题。

食堂中共有 $n$ 个区域，在食堂即将开门时，第 $i$ 个区域中有 $a_i$ 名正在等位的学生和 $b_i$ 个空位。保证 $\sum\limits_{i=1}^{n}a_i\le \sum\limits_{i=1}^{n}b_i$。

食堂开门后的每个时刻，都会**依次**发生如下两个事件：

1. 每个区域中当前正在等位的学生都会尽可能地坐到该区域的空位上。具体而言，假设第 $i$ 个区域中当前有 $x_i$ 名正在等位的学生和 $y_i$ 个空位。

     - 若 $x_i\le y_i$，那么所有正在等位的学生都会坐到空位上，此时第 $i$ 个区域中没有正在等位的学生，且会剩下 $y_i-x_i$ 个空位；
     - 若 $x_i>y_i$，那么会有恰好 $y_i$ 名正在等位的学生坐到所有空位上，此时第 $i$ 个区域中剩下 $x_i-y_i$ 名正在等位的学生，且没有剩余的空位。
2. 每个区域中当前正在等位的所有学生都会**同时**移动到下一个区域中。具体而言，第 $i$ 个区域中所有正在等位的学生都会移动到第 $(i\bmod n) +1$ 个区域中。


在这群学生中，有恰好 $k$ 名学生因为赶时间上课，在食堂开门的瞬间就打包离开了。而 Ecrade_ 并不清楚这 $k$ 名学生都在哪些区域，所以他想知道，在这 $k$ 名学生所有可能的分布情况中，在食堂开门后，最少经过多少个时刻，就能够使得每个区域中都没有正在等位的学生。


## 说明/提示

### 样例 #1 解释

为方便表述，下直接用数组 $a,b$ 表示每个时刻后每个区域中正在等位的学生数以及剩余空位数。

对于第一组测试数据，没有学生会离开食堂：

- 第一个时刻后，$a=[0,0,0],b=[4,0,0]$。

对于第二组测试数据，没有学生会离开食堂：

- 第一个时刻后，$a=[3,0,0,1],b=[3,1,0,0]$；
- 第二个时刻后，$a=[1,0,0,0],b=[0,1,0,0]$；
- 第三个时刻后，$a=[0,1,0,0],b=[0,1,0,0]$；
- 第四个时刻后，$a=[0,0,0,0],b=[0,0,0,0]$。

对于第三组测试数据，所有学生都会离开食堂。

对于第四组测试数据，仅有一名学生会离开食堂：

- 若这名学生在第 $1$ 个区域，则 $a$ 会变为 $[0,2,3,4]$：
  - 第一个时刻后，$a=[3,0,0,1],b=[4,1,0,0]$；
  - 第二个时刻后，$a=[1,0,0,0],b=[1,1,0,0]$；
  - 第三个时刻后，$a=[0,0,0,0],b=[0,1,0,0]$。
- 若这名学生在第 $2$ 个区域，则 $a$ 会变为 $[1,1,3,4]$：
  - 第一个时刻后，$a=[3,0,0,1],b=[3,2,0,0]$；
  - 第二个时刻后，$a=[1,0,0,0],b=[0,2,0,0]$；
  - 第三个时刻后，$a=[0,1,0,0],b=[0,2,0,0]$；
  - 第四个时刻后，$a=[0,0,0,0],b=[0,1,0,0]$。
- 若这名学生在第 $3$ 个区域，则 $a$ 会变为 $[1,2,2,4]$：
  - 第一个时刻后，$a=[3,0,0,0],b=[3,1,0,0]$；
  - 第二个时刻后，$a=[0,0,0,0],b=[0,1,0,0]$。
- 若这名学生在第 $4$ 个区域，则 $a$ 会变为 $[1,2,3,3]$：
  - 第一个时刻后，$a=[2,0,0,1],b=[3,1,0,0]$；
  - 第二个时刻后，$a=[1,0,0,0],b=[1,1,0,0]$；
  - 第三个时刻后，$a=[0,0,0,0],b=[0,1,0,0]$。
- 因此，当这名学生在第 $3$ 个区域时，最少经过 $2$ 个时刻，就能够使得每个区域中都没有正在等位的学生。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
4
3 0
1 1 4
5 1 4
4 0
1 2 3 4
4 3 2 1
3 6
1 1 4
5 1 4
4 1
1 2 3 4
4 3 2 1
```

### 输出

```
1
4
0
2
```

# 题解

## 作者：meyi (赞：0)

简单题，考虑二分答案。

假设当前二分的答案为 $x$，那么等价于在**环形数组**上，$b_i$ 可以依次与 $a_i,a_{i-1},\cdots,a_{i-x+1}$ 匹配，直接模拟即可，$x$ 合法等价于所有匹配完成后有 $\sum a\le k$。由于每次匹配必定会让 $a$ 或 $b$ 中的某个数变为 $0$，因此匹配次数是 $\mathcal O(n)$ 的，总时间复杂度 $\mathcal O(n\log n)$。

为什么不考虑同时移动而这样贪心是对的？因为在这种贪心方式下，满足 $j<i$ 的 $a_j$ 必定会先于 $a_i$ 去和 $a_j,a_{j-1},\cdots,a_{i-x+1}$ 匹配，$j>i$ 时同理，$a_i$ 必定会先于 $a_j$ 去和 $a_i,a_{i-1},\cdots,a_{j-x+1}$ 匹配，也就是说我们并没有破坏同时移动的匹配顺序。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
int main(){
    int t_case=1;
    scanf("%d",&t_case);
    while(t_case--){
        ll m;
        int n;
        scanf("%d%lld",&n,&m);
        V<int>a(n);
        for(int &i:a)scanf("%d",&i);
        V<int>b(n);
        for(int &i:b)scanf("%d",&i);
        auto check=[&](int k){
            V<int>c=a,d=b;
            deque<int>q;
            For(i,n){
                q.pb(i);
                int &x=d[i];
                while(q.size()&&x>=c[q.back()]&&i-q.back()<k)x-=c[q.back()],c[q.back()]=0,q.qb();
                if(q.size()&&i-q.back()<k)c[q.back()]-=x,x=0;
            }
            For(i,k){
                int &x=d[i];
                while(q.size()&&x>=c[q.back()]&&n+i-q.back()<k)x-=c[q.back()],c[q.back()]=0,q.qb();
                if(q.size()&&n+i-q.back()<k)c[q.back()]-=x,x=0;
            }
            ll y=0;
            for(int i:q)y+=c[i];
            return y<=m;
        };
        int ans=-1,l=0,r=n;
        while(l<=r){
            int mid=l+r>>1;
            if(check(mid))ans=mid,r=mid-1;
            else l=mid+1;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：_lmh_ (赞：0)

发现关键性质：只要模拟过程中剩余人数 $\le k$，那么一开始去掉这些人就一定能够最小化时间。

这些人一直没有找到位置，所以在循环移位的过程中去掉他们，剩下的人也能填满路过的所有位置。因此，他们不会对前面的过程产生任何影响。

同时我们需要证明不存在任何更优秀的方案。如果这个方案存在，那么存在一个更优的时间，此时所有人都找到了位置，但如果一开始不去掉任何一个人，那么此时剩下的人数 $>k$。

把剩下的 $m>k$ 个人找出来。如果更优的方案存在，那么此时他们一定都找到了位置。

如果一开始去掉的 $k$ 个人都是这 $m$ 个人当中的，那么显然不可能。否则，这个去掉的人会在序列中形成一个空位，并且我们不妨假设有人填进了这个空位里面（否则不去掉这个人也没有影响）。那么我们发现，去掉这个人和去掉补进他留下的空位里的那个人等价，并且后者找到位置的时间更晚。

所以最后我们一定能把所有去掉的人要么对应 $m$ 个人当中的一个，要么对不上任何一个人，而只有配对上的人能找到位置，与 $m>k$ 矛盾。

所以只需要一直模拟直到剩下 $\le k$ 个人即可。注意到如果 $a_i,b_i>0$，那么这次匹配必定将一个变成 $0$，因此只有 $O(n)$ 次有效匹配。

使用优先队列维护正在找位置的人，并查集维护下一个有效的 $b_i$。

实际上这么做会有一点问题——如果一波人把 $b_i$ 填满了，但是前面的人已经开始往 $i$ 这个位置走，那么会额外出现很多无效匹配——但这玩意似乎是 $O(n)$ 或者 $O(n\log n)$ 的，总之可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=500007;
ll T,n,k,sum,a[N],b[N],fa[N],ans;
struct node{
	ll t,a,x;
};
bool operator <(const node& a,const node& b){return a.t>b.t;}
priority_queue<node> pq;
int getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}
ll dis(ll x,ll y){return (x<y?y-x:y+n-x);}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		while(!pq.empty()) pq.pop();
		cin>>n>>k;sum=ans=0;
		for (int i=1;i<=n;++i){
			cin>>a[i];sum+=a[i];fa[i]=i;
			pq.push((node){1,a[i],i});
		}
		for (int i=1;i<=n;++i) cin>>b[i];
		while(sum>k){
			auto p=pq.top();pq.pop();
			ll x=p.x,a=p.a,t=p.t;
			ans=t;
			ll tmp=min(a,b[x]);
			b[x]-=tmp;a-=tmp;sum-=tmp;
			if (b[x]==0) fa[getfa(x)]=getfa(x%n+1);
			if (a){
				int y=getfa(x%n+1);
				pq.push((node){t+dis(x,y),a,y});
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


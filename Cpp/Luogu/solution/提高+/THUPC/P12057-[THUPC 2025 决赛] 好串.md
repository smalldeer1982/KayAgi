# [THUPC 2025 决赛] 好串

## 题目描述

对于三个长度为 $n$ 的 01 字符串 $s_1,s_2,s_3$，称长度为 $n$ 的 01 字符串 $t$ 是**好的**当且仅当 $\forall 1 \le i,j \le n, \exists k \in \{1,2,3\}, s_{k,i} = t_i, s_{k,j} = t_j$。设 $f(s_1,s_2,s_3)$ 为这样的好的串的数量。

现在我们有三个长度为 $n$ 的随机 01 字符串 $s_1,s_2,s_3$，其中 $s_i (1 \le i \le 3)$ 的第 $j (1 \le j \le n)$ 个字符有 $\frac{p_{i,j}}{9}$ 的概率为 `1`，$\left(1 - \frac{p_{i,j}}{9}\right)$ 的概率为 `0`，其中 $p_{i,j}$ 是一个 $0$ 至 $9$ 的整数。所有的随机事件是独立的。你需要求 $f(s_1,s_2,s_3)$ 的期望，对 $998244353$ 取模。

## 说明/提示

### 样例 #1 解释

在该组样例中，$s_1, s_2, s_3$ 分别为 `100`, `010`, `001`，四种方案分别为 `100`、`010`、`001`、`000`。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
3
900
090
009
```

### 输出

```
4
```

## 样例 #2

### 输入

```
3
999
999
999
```

### 输出

```
1
```

## 样例 #3

### 输入

```
10
0123456789
1234567890
2345678901
```

### 输出

```
612360617
```

# 题解

## 作者：happybob (赞：0)

考虑给定 $s_1,s_2,s_3$，如何计算 $f(s_1,s_2,s_3)$。

从前往后考虑每个 $t_i$ 是多少，发现若 $t_i$ 为 $s_{1/2/3,i}$ 中出现次数最大的那个，则相当于对后面的字符有一些限制，这些限制只和这次出现次数较大的那些串是什么而与其他无关，若 $t_i$ 为出现次数少的那个，则 $t$ 之后的值必然是对应的 $s$ 后面的值。

于是可以从前往后进行 DP，记 $f_{i,S}$ 表示已经填了 $[1,i]$，之前每次取的都是出现次数较大的字符，$(1,2),(1,3),(2,3)$是否作为过出现次数最大的两个时的概率，转移 $2^3$ 枚举所有可能情况即可。

---

## 作者：mango2011 (赞：0)

vp 的时候没有做出来，第一步结论看了题解。

结论就是好串的集合是 $\{s_1,s_2,s_3,t\}$，其中 $t_i$ 为 $s_{1,i}$，$s_{2,i}$ 和 $s_{3,i}$  的众数。$t$ 的充分性显然；必要性是因为否则可以找到某个 $s_{x,y}$ 使得 $t_x=s_{x,y}$ 且不是第 $x$ 位的众数。那么取任意的 
$z\not=y$，都有 $s_{x,z}=t_z$，从而得到 $t=s_x$，没有意义。

然后就开始进行分类讨论：

+ $s_1,s_2,s_3,t$ 中只有一种，那么全相等，每一位的概率撑起来就好了。
+ $s_1,s_2,s_3,t$ 中恰有两种，那么一定是 $s_i=s_j=t\not=s_k$。这是容易的。枚举相同的两个串，容斥一下就好了。
+ $s_1,s_2,s_3,t$ 中恰有三种，那么一定是 $s_1=t$，且 $t\not=s_2$，$t\not=s_3$，要不然会导致有三个相同。还是可以容斥。
+ $s_1,s_2,s_3,t$ 全部不同，那么可以用 $1$ 减去剩下的那些。

这道题的容斥系数有点难算，所以笔者直接暴力枚举的，随便找了一组出来（实际上都是本质相同的）。代码又一次写唐了，仅供参考（相较于上面，代码里全部 $\times9$，最后除以 $9^{3n}$）：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e5+10,mod=998244353;
int a[4][maxn];
int qp(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=res*a%mod;
		a=a*a%mod,b>>=1; 
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(0);
	int n;cin>>n;
	for(int i=1;i<=3;i++){
		string s;cin>>s;
		for(int j=1;j<=n;j++) a[i][j]=s[j-1]-'0';
	}
	int three=1;
	for(int i=1;i<=n;i++) (three*=(a[1][i]*a[2][i]*a[3][i]+(9-a[1][i])*(9-a[2][i])*(9-a[3][i])))%=mod;
	int two=0,_=0;
	for(int x=1;x<=3;x++){
		for(int y=x+1;y<=3;y++){
			int tmp=1;
			for(int i=1;i<=n;i++) (tmp*=(a[x][i]*a[y][i]*9+(9-a[x][i])*(9-a[y][i])*9))%=mod;
			(two+=tmp)%=mod;
		}
	}
	two=(two-3*three+3*mod)%mod;
	for(int x=1;x<=3;x++){
		int tmp=1;
		for(int i=1;i<=n;i++){
			int tt=0;
			for(int y=1;y<=3;y++) if(x^y) tt+=a[x][i]*a[y][i]*9+(9-a[x][i])*(9-a[y][i])*9;
			tt-=a[1][i]*a[2][i]*a[3][i];tt-=(9-a[1][i])*(9-a[2][i])*(9-a[3][i]),(tmp*=tt)%=mod;
		}
		(_+=tmp)%=mod;
	}
	int one=(_-6*two-7*three+50*mod)%mod;
	int none=(qp(9,3*n)-one-2*two-2*three+50*mod)%mod;
	int tot=(none*4+one*3+two*2+three)%mod;
	cout<<tot*qp(qp(9,3*n),mod-2)%mod<<"\n";
	return 0;
}
```

---

## 作者：ForwardStar (赞：0)

我们可以先从这个性质入手，考虑如果我们如果有确定的三个字符串，如何构造好串。  
  
第一是可以分别全等于三个串。  
其次还可以存在一个不全等于 $s_1,s_2,s_3$ 的字符串 $t$，满足对于所有的 $i$， $t_i=s_{1,i},t_i=s_{2,i},t_i=s_{3,i}$ 至少满足两个。 
   
如何证明呢，可以利用反证法，如果存在一个 $i$，使得 $t_i\neq s_{1,i}$ 且 $t_i\neq s_{2,i}$，那么这个位置只能在 $s_3$ 上匹配，又 $t\neq s_3$，所以必定存在 $j$ 使得 $t_j\neq s_{3,j}$，即 $t$ 同时也无法在 $s_3$ 上匹配。  

既然已经知道了这个性质，我们还可以继续推出，这样构造出的 $t$ 至多有一个。证明也很简单，参考构造过程，我们对于每一位，必须选择三个串中出现次数多的那个数字，才能满足上述性质，每次选择都是唯一的。  

综上，得知答案不超过 $4$。于是继续分类讨论。

### 当三个串全部全等时  
显然答案为 $1$。统计这种情况的概率也比较简单。
### 当存在两个串全等且第三个串不同时  
$t$ 可以为全等的两个串或不同的那个串，显然通过构造出的串会和全等的那两个串重复，于是答案为 $2$。概率统计方法也很直接，分别求三组，两个全等的概率减去三个全等的概率即可。  
### 当三个串全不全等，且构造出的串与其中一个串全等时
显然答案为 $3$，问题是如何统计概率。可以钦定 $t=s_1$，那么对于所有 $i$ 都要满足 $s_{1,i}=s_{2,i}$ 或 $s_{1,i}=s_{3,i}$（可以由前文的构造方法证明出），求出满足此条件的概率。由于还需要保证三个串互不全等，还要分别减去满足 $s_1=s_2\neq s_3,s_1=s_3\neq s_2$ 以及 $s_1=s_2=s_3$ 的概率。分别求出三组即可。
### 当三个串全不全等，且构造出的串与任意一个串不全等时 
显然答案为 $4$，并且观察到全部四种情况构成全集，用 $1$ 减去其他情况的概率即可。  

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 3e5 + 55, MOD = 998244353;
int n, inv;
char a[4][N];
int tsx[5];
int add(int x, int y) {
	return ((x + y) % MOD + MOD) % MOD;
}
int mol(int x, int y) {
	return (x * y) % MOD;
}
int get_inv(int x) {
	if (x == 1) return 1;
	return mol(-(MOD / x), get_inv(MOD % x)); 
}
int p(int x, int y) {
	return mol(a[x][y] - '0', inv);
}
int q(int x, int y) {
	return add(1, -p(x, y));
}
int nxt(int x) {
	return (x + 1) % 3;
}
int lst(int x) {
	return (x + 2) % 3;
}
signed main() {
	inv = get_inv(9);
	scanf("%lld", &n);
	for (int i = 0; i < 3; i++) scanf("%s", a[i] + 1);
	int ans = 0, as = 1, df = 1;
	for (int i = 1; i <= n; i++) {
		int tmp = 1, tmp2 = 1;
		for (int j = 0; j < 3; j++) tmp = mol(tmp, p(j, i));
		for (int j = 0; j < 3; j++) tmp2 = mol(tmp2, q(j, i));
		as = mol(as, add(tmp, tmp2));
	} 
	ans = as;
	for (int x = 0; x < 3; x++) {
		tsx[x] = 1;
		for (int i = 1; i <= n; i++) {
			tsx[x] = mol(tsx[x], add(mol(p(x, i), p(nxt(x), i)), mol(q(x, i), q(nxt(x), i))));
		}
		tsx[x] = add(tsx[x], -as);
		df = add(df, -tsx[x]);
		ans = add(ans, mol(tsx[x], 2));
	}
	df = add(df, -as);	
	for (int x = 0; x < 3; x++) {
		int tmp = 1;
		for (int i = 1; i <= n; i++) {
			int tmp2 = add(mol(p(x, i), add(1, -mol(q(nxt(x), i), q(lst(x), i)))), 
				mol(q(x, i), add(1, -mol(p(nxt(x), i), p(lst(x), i)))));
			tmp = mol(tmp, tmp2);
		}
		tmp = add(tmp, -tsx[x]);
		tmp = add(tmp, -tsx[lst(x)]);
		tmp = add(tmp, -as);
		df = add(df, -tmp);
		ans = add(ans, mol(tmp, 3));
	}
	ans = add(ans, mol(df, 4));
	printf("%lld\n", ans);
	return 0;
}
```

---


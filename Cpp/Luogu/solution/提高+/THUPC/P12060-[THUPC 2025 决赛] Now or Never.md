# [THUPC 2025 决赛] Now or Never

## 题目描述


对于一个长度为 $l$ 的 01 串 $w=w_1w_2\dots w_l$，定义其**支撑序列** $\mathrm{supp}(w)$ 为 $[1, 2, \dots, l]$ 的一个子序列，其中 $i\in \mathrm{supp}(w)$ 当且仅当 $w_i = 1$。例如，$\mathrm{supp}(001100110) = [3, 4, 7, 8]$。特别地，全零串的支撑序列为空序列 $\varepsilon$。

给定一个 01 串集合 $S$，其中包含 $n$ 个长度为 $m$ 的 01 串 $s_1, s_2, \dots, s_n$。再给定 $q$ 组询问，第 $i$ 组询问给出一个长度为 $m$ 的 01 串 $t_i$。你需要输出一个长度为 $m$ 的 01 串 $u_i$ 满足以下条件：

1. 存在一个 $S$ 的子集 $T$，其中 $T$ 可以为空也可以为 $S$ 本身，满足 $u_i = t_i \oplus \bigoplus_{v \in T} v$，其中 $\oplus$ 表示按位异或操作，即 $u_i$ 为 $t_i$ 与 $T$ 中所有 01 串的异或和；
2. 在以上条件的基础之上，$u_i$ 的支撑序列的字典序尽可能小。

对于两个序列 $A, B$，称 $A$ 的字典序小于 $B$，当且仅当 $A$ 是 $B$ 的一个真前缀，或者 $A$ 和 $B$ 在第一个相异的位置 $p$ 上满足 $A_p < B_p$。

## 说明/提示

### 样例 #1 解释


对于第一组测试数据，满足第一个条件的串有 `010` 和 `100`。二者支撑序列分别为 $\mathrm{supp}(010) = [2]$，$\mathrm{supp}(100) = [1]$，其中字典序更小的是 $[1]$。

对于第二组测试数据，满足第一个条件的串有 `101` 和 `011`。二者支撑序列分别为 $\mathrm{supp}(101) = [1, 3]$，$\mathrm{supp}(011) = [2, 3]$，其中字典序更小的是 $[1, 3]$。

### 样例 #2 解释


对于第一组测试数据，满足第一个条件的串有 `1000`、`0100`、`0010` 和 `1110`，其中字典序最小的支撑序列是 $\mathrm{supp}(1000) = [1]$。

对于第二组测试数据，满足第一个条件的串有 `0001`、`1101`、`1011` 和 `0111`，其中字典序最小的支撑序列是 $\mathrm{supp}(1101) = [1, 2, 4]$。

对于第三组测试数据，满足第一个条件的串有 `0110`、`1010`、`1100` 和 `0000`，其中字典序最小的支撑序列是 $\mathrm{supp}(0000) = \varepsilon$，也即空序列。

对于第四组测试数据，满足第一个条件的串有`0011`、`1111`、`1001` 和 `0101`，其中字典序最小的支撑序列是 $\mathrm{supp}(1111) = [1, 2, 3, 4]$。

### 提示

题目名称是什么意思？


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
1 3 2
110
010
101
```

### 输出

```
100
101
```

## 样例 #2

### 输入

```
2 4 4
1100
1010
1000
0001
0110
0011
```

### 输出

```
1000
1101
0000
1111
```

## 样例 #3

### 输入

```
3 9 7
011001111
101110001
110010100
010110110
101010100
000101101
001011100
100011111
100111000
001000101
```

### 输出

```
111101101
110110001
110111001
111100010
111111010
111110111
111111011
```

## 样例 #4

### 输入

```
9 24 9
100001011101000000000000
100011001100100001000000
010101000010100111110100
101110000010101110110010
100110110010011100000000
111111000010100101111011
000010110001001011010101
010101100111000010100111
111001111111000000000000
111000110110110000000000
011100101000100001000000
101001101000111011001100
100011100011110001000000
100001001011000000000000
101110110001111100000000
100011100101100010110000
101001001100101011000000
100101100110100111000000
```

### 输出

```
111111111100001001010011
111111101111001101010101
111111101100001011000101
111111101101110101111011
111111111111000010111011
111111111111110101011010
111111101110101001001101
111111101101111110011010
111111111110100001000000
```

# 题解

## 作者：紊莫 (赞：1)

首先利用 ``bitset`` 建立线性基，对于一个查询，我们有如下贪心：

设当前位为 $i$，如果 $[i,m)$ 这些位都可以消成 $0$，那么退出，否则尽可能把 $i$ 这个位变成 $1$，然后 $i\gets i+1$。

正确性显然，暴力做复杂度是 $O(\frac{nm^2+qm^3}{\omega})$ 的。

[暴力代码。](https://www.luogu.com.cn/paste/w9uqh645)

称线性基中能被我们随意操作的位为关键位。

那么我们只需要把线性基消元成关键位独立的形式就可以预处理所有后缀的关键位上的基中元素的异或和。

[正解代码。](https://www.luogu.com.cn/paste/k061cz4d)

复杂度是 $O(\frac{nm^2+qm^2}{\omega})$。

---

## 作者：wrkwrkwrk (赞：0)

考虑字典序的定义：在一个字前缀相同的情况下，如果后面有一个空，则空的小，否则后面小的小。

对应到原来上，那就是：如果后面可以是空，则尽量是空，否则使得下一个尽可能在前面。

异或操作启示线性基，也启示 bitset，考虑我们需要做啥：判断后侧能不能全是 $0$，考虑这一位能不能是 $1$。

后侧启示线性基代表后缀。

考虑对线性基进行如下处理使得前面的决策不会影响后面决策：从右向左边处理，对每个使得左边还没处理的线性基不存在这一位。

这样对于一个后缀我们能够判断是否存在情况使得后面全空：从右向左，直接对存在赋 $0$。这是独立的。

剩下的直接贪心处理即可，啥时候后面处理的和现在后面的一样了，直接后面全 $0$，退出即可。

时间复杂度 $O(\frac{nmq}{\omega})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<2003>x[2003];
bitset<2003>w[2003];
bitset<2003>hp[2003];
bool ue[2003];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char c;
            cin>>c;
            x[i][j]=c-'0';
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(x[i][j]){
                if(ue[j]){
                    x[i]^=w[j];
                }else{
                    ue[j]=1;
                    w[j]=x[i];
                    break;
                }
            }
        }
    }
    for(int i=m;i>=1;i--)if(ue[i]){
        for(int j=i-1;j>=1;j--)if(ue[j]){
            if(w[j][i]){
                w[j]^=w[i];
            }
        }
    }
    while(q--){
        bitset<2003>inp;
        for(int i=1;i<=m;i++){
            char c;
            cin>>c;
            inp[i]=c-'0';
        }
        for(int i=m;i>=1;i--){
            hp[i]=hp[i+1];
            if(inp[i]&&ue[i]){
                hp[i]^=w[i];
            }
        }
        bitset<2003>nc=inp;
        bitset<2003>ma;
        for(int i=1;i<=m;i++)ma[i]=1;
        for(int i=0;i<=m;i++){
            if(i){
                if(nc[i]==0&&ue[i]){
                    nc^=w[i];
                }
            }
            if((nc&ma)==hp[i+1]){
                nc^=hp[i+1];
                break;
            }
            ma[i+1]=0;
        }
        for(int j=1;j<=m;j++){
            cout<<nc[j];
        }
        cout<<'\n';
    }
    return 0;
}
```

---


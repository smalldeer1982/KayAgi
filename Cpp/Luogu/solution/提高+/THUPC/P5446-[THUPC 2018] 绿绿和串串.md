# [THUPC 2018] 绿绿和串串

## 题目背景

绿绿和 Yazid 是好朋友。他们在一起做串串游戏。

## 题目描述

绿绿有一个由小写字母组成的非空字符串 $R$，但 Yazid 不知道它具体是什么。

我们定义**翻转**的操作：把一个串以最后一个字符作对称轴进行翻转复制。形式化地描述就是，如果他翻转的串为 $R$，那么他会将前 $\left| R\right|-1$ 个字符倒序排列后，插入到串的最后。

举例而言，串`abcd`进行翻转操作后，将得到`abcdcba`；串`qw`连续进行 **$2$ 次**翻转操作后，将得到`qwqwq`；串`z`无论进行多少次翻转操作，都不会被改变。

贪玩的绿绿进行了若干次（可能为 $0$ 次）翻转操作。

淘气的绿绿又展示出了一个非空串 $S$，并表示 $S$ 是**最终**的串 $R$ 的前缀。现在，他想考考 Yazid，**初始**的串 $R$ 的长度可能是多少。

Yazid 找到了正在参加清华校赛的你，请你来帮他解决这个问题。但聪明的 Yazid 发现，所有超过 $\left| S\right|$ 的整数都一定是 $R$ 的可能长度，因此你只需要告诉他不超过的 $\left| S\right|$ 的 $R$ 的可能长度即可。

为了帮助你理解问题，Yazid 还将对一些概念和记号做出解释：

- 对于一个串 $S$，$\left| S\right|$ 表示的是该串的长度。
- 对于一个串 $S$，我们定义串 $T$ 是它的前缀，当且仅当 $\left| T\right|\leq\left| S\right|$，且对于任意整数 $i$ 满足 $1\leq i\leq\left| T\right|$，都有 $T$ 的左起第 $i$ 个字符与 $S$ 的左起第 $i$ 个字符相同。（形象地理解，即 $T$ 在 $S$ 的前部出现）
  - 如：`abc`是`abcdefg`的前缀，`aba`**不**为`abba`的前缀，`z`为`z`的前缀，空串为任意一个串的前缀。

## 说明/提示

### 数据范围

保证 $\left| S\right|\leq 10^6$，$\sum\left| S\right|\leq 5\times 10^6$。

$\sum\left| S\right|$ 表示的是单个测试点中所有数据 $\left| S\right|$ 的总和。

### 提示

* 读入规模较大，请注意读入效率。

* 样例中的最后一个字符串是什么意思呢？

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
4
abcdcb
qwqwq
qaqaqqq
carnation```

### 输出

```
4 6
2 3 4 5
6 7
9```

# 题解

## 作者：pldzy (赞：47)

## Update

- 2024年8月7日：回复 @hzoi_Shadow 的问题“为啥最后判的是i+len[i]-2 而不是 i+len[i]-1”。
- 2025年1月26日：感谢 @small_cabbage 指出文章部分内容叙述有所缺漏，并回复 @small_cabbage 的问题“观察可以发现是怎么观察到的？能否给出严谨证明？”。

由于回复篇幅过长，具体问题和回复内容放在文章末尾。

## 思路

### 1

题目给出的字符串可以是由一个子串 a 翻转而得；

而 a 也可以是由一个子串 b 翻转而得；

而 b 可以是由一个子串 c 翻转而得；

……

最终得到一个无法再翻转下去的子串 x。

而字符串本身、子串 a、子串 b、子串 c……子串 x 各自的长度就是我们要的答案。

------------


例如：给出字符串 `qwqwq` ，

它可以是由子串 `qwqw` 翻转而得的；

而 `qwqw` 是由子串 `qwq` 翻转而得的；

而 `qwq` 是由子串 `qw` 翻转而得的；

然而， `qw` 无法由它的子串翻转而得。

即最终答案输出： `2 3 4 5` 。

### 2

那么如何求每个字符串的最长翻转子串（此处不考虑字符串本身）呢？

拿例子来说：

已得 `qwqwq` 的最长翻转子串是 `qwqw` 。

`qwqw` 的翻转中心是最后一个的 `w` ，回看原串，可以发现一个由同一个 `w` 为翻转中心的**回文串** `qwq` 。

再多举几个例子，就可以发现，**一个字符串的最长翻转子串就是它自己去掉最短末尾回文串的一半**。

还是举例子说明：

`qwqw` 的最短末尾回文串为 `wqw` ，

根据上文所说，我们去掉该回文串的后半部分 `w` ，

然后再拿剩下的和前面组合，就可以得到 `qwqw` 的最长翻转子串为：

`q` + `wq` = `qwq` 。

现在，我们的问题就转化为求出字符串中的每一个回文串了。

### 3

仍存在一个值得注意的细节。

我们不妨重新定义一下“翻转”这个词。

- **“全翻转”**：指完全按照题目定义所描述，以字符串 b 的末尾字符为对称中心，将 b 除去末尾字符之外的字符 **全部翻转并接到** b 的末尾。
- **“半翻转”**：指先将字符串 a 进行“全翻转”操作，再**从 a 的末尾砍掉若干字符**，保证最后得到的新串长度严格大于 a 串长度。

-----

不难发现，在第二部分中我们所求的、所描述的一直是“如何求每个字符串的**最长半翻转子串**？”。

如何求每个字符串 S 的**最长全翻转子串**呢？这个就非常简单啦，由“全翻转”的定义可知，其最长全翻转子串至多只有一个，而且长度必须是 $\left\lfloor\frac{|S|}{2}\right\rfloor$，且 $|S|$ 必须是奇数。所以只需要验证一下是否合法即可。

-----

那么“全翻转”和“半翻转”在第一部分有什么体现呢？

不难发现，如果这个字符串 x 想要一步翻转成 S，那么它就可以是“全翻转”，也可以是“半翻转”；但如果这个字符串 x 无法一步翻转成 S，只能翻转到另一个翻转子串 y，那么 x **只能是“半翻转”**。

原因是只有在最后一次翻转我们可以砍掉末尾，其他情况下翻转得到的串我们都是要全盘接受的。

### 4

求回文串？~~就很简单~~能想到是 Manacher 算法了。

不会 Manacher 就可以先看看这道题：[P3805 【模板】manacher 算法](https://www.luogu.com.cn/problem/P3805)。

在 Manacher 求出了每一个回文串的基础上，我们从后面往前面找每个最长翻转子串。

具体代码作用见注释。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

#define re register 
const int maxn = 1000005;
char st[maxn * 2];
int len[maxn * 2], cnt;
int vis[maxn * 2];
int T;
int mx, po;

inline void input ()
{
	char ch = getchar ();
	st[0] = '~', st[cnt = 1] = '#';
	while (ch < 'a' or ch > 'z') ch = getchar ();
	while (ch >= 'a' and ch <= 'z') st[++cnt] = ch, st[++cnt] = '#', ch = getchar (); 
    st[cnt + 1] = '%';
}

int main ()
{
	scanf ("%d", &T);
	while (T--)
	{
		cnt = mx = po = 0;
		memset (vis, 0, sizeof vis);
		memset (len, 0, sizeof len);
		input ();
		for (re int i (1); i <= cnt; ++i)//Manacher 模板 
		{
			if (i <= mx) len[i] = min (mx - i, len[po * 2 - i]);
			while (st[i + len[i]] == st[i - len[i]]) len[i]++;
			if (i + len[i] > mx) mx = i + len[i] - 1, po = i;
		}
		for (re int i (cnt); i >= 1; --i)
		{
			if (i + len[i] - 1 == cnt) vis[i] = 1;//如果能一次翻转成 
			else if (vis[i + len[i] - 2] and i == len[i]) vis[i] = 1;//如果它能翻转成某个最长翻转子串，如 qwqwq 的 qwqw 的 qw ，且不会越界 
		}
		for (re int i (1); i <= cnt; ++i) if (st[i] >= 'a' and st[i] <= 'z' and vis[i]) printf ("%d ", i / 2);
			//Manacher 处理后的字符串转化成原字符串，长度直接除以 2 就可以得到原字符串的长度 
		printf ("\n");
	}
	return 0;
}
```

感谢阅读，~~求赞~~。

### 5

回复。

- 回复 @hzoi_Shadow 的问题“为啥最后判的是i+len[i]-2 而不是 i+len[i]-1”。

  $vis_i$ 定义为 i 作为翻转中心是否合法，且 $S_{i+len_i-1}$ 是特殊字符，所以判的时候判 $vis_{i+len_i-2}$。

- 回复 @small_cabbage 的问题“观察可以发现是怎么观察到的？能否给出严谨证明？”。

  读者自证不难。

  - 命题：一个字符串的半翻转子串是它自己去掉末尾回文串的一半得到。
  - 子命题：一个字符串的最长半翻转子串就是它自己去掉最短末尾回文串的一半。
  - 充分性：显然。可以通过上述举例进行理解。“它自己去掉最短末尾回文串的一半”一定能通过“半翻转”操作得到“它自己”。
  - 必要性：显然。如果这个串 S 能被串 a 通过“半翻转”得到，那么 S-a 这个串一定是 a 除去末尾字符得到的串 a' 的某个真后缀。而也恰恰说明这构成了一个回文串。
  
  综上所述，一个字符串的半翻转子串是它自己去掉末尾回文串的一半得到，故命题“一个字符串的最长半翻转子串就是它自己去掉最短末尾回文串的一半”成立。

---

## 作者：jdsb (赞：15)

## 题意

定义一种字符串操作翻转，即将字符串 $S$ 的前 $|S|-1$ 位复制一份，并翻转，然后放到字符串的末尾，如 `abc` 翻转后得到 `abcba`。

现在给定一个字符串 $S$，问有多少种长度的初始字符串 $R$，使得 $S$ 是 $R$ 翻转若干次后的前缀，显然，当 $|R|>|S|$ 时一定存在答案，所以只要求出 $|R|\le|S|$ 的方案。

## 分析

因为 $R$ 经过若干次翻转后的前缀为 $S$，所以 $R$ 一定是 $S$ 的前缀。

我们先考虑一种简单的情况，只经过一次翻转就能使得 $S$ 是这个串的前缀的答案，我们记 $p_i$ 为以 $i$ 为回文中心的最大回文半径，可以发现，当长度 $i$ 合法，当且仅当 $i+p_i=|S|$，上张图理解一下

![](https://cdn.luogu.com.cn/upload/image_hosting/7mlvnxum.png)

绿色的部分是以 $i$ 为回文中心的回文串，因为这部分回文，所以前缀 $i$ 经过翻转后能有前缀 $S$。

接着考虑多次翻转后能合法的前缀 $i$，要满足的条件很简单，即 $i-p_i=1$ 并且 $i+p_i$ 合法。

最后考虑怎么实现，我们可以用 manacher 预处理出每个点的最大回文半径 $p_i$，然后从后往前依次判断，如果这个长度合法，就用个 `vis` 数组标记，方便之后的点判断。

## 代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define rint register int
using namespace std;
const int N=1e6+5;
inline void write(int x){
	int q[105],t=0;
	while(x) q[++t]=x%10,x/=10;
	while(t) putchar(q[t--]^'0');
	putchar(' ');
}
char s[N];
int n,p[N];
inline int min(const int x,const int y) { return x<y?x:y; }
inline void manacher(){
	n=strlen(s+1);
	s[0]='@',s[n+1]='#';
	for(rint i=1,mid=0,mx=0;i<=n;++i){
		p[i]=0;
		if(i<mx) p[i]=min(mx-i,p[2*mid-i]);
		while(s[i+p[i]+1]==s[i-p[i]-1]) p[i]++;
		if(i+p[i]>mx) mx=i+p[i],mid=i;
	}
}
int vis[N];
inline void solve(){
	cin>>(s+1);
	manacher();
	for(rint i=n;i>=1;--i){ 
		vis[i]=0;
		if(i+p[i]==n) vis[i]=1;
		else if(vis[i+p[i]]&&i-p[i]==1) vis[i]=1;
	}
	for(rint i=1;i<=n;++i) if(vis[i]) write(i);puts("");
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);
	int T;
	cin>>T;
	while(T--) solve();
	return 0;
}
```


---

## 作者：SpeMars (赞：9)

~~这道题其实只要学会马拉车算法( manacher )就 ok 了~~

如果你还没有了解马拉车算法这边建议你先去别的博客学习一下

[luogu模板题](https://www.luogu.com.cn/problem/P3805)

[个人觉得很不错的一篇manacher算法详解博客](https://www.cnblogs.com/cloudplankroader/p/10988844.html)

好，那么进入正题

本题要求一个串 $R$ 使得它的前缀为 $S$ ，串 $R$ 可以进行任意次翻折

但是翻折点不会重叠

eg:  $R$ = "ab"  翻折一次后 $R$ = "aba" 而非 $R$ = "abba" 

那么我们枚举每个点$i$的最大回文半径

情况一:

如果当前位置回文后正好到$S$串的末尾，则这是可行的

注:$|S|$为字符串$S$的长度

eg: $S$ = "abcdcb", $i$ = $4$ 

 $r[4]$ = $2$ 且 $i$ + $r[4]$= $|S|$

所以我们直接把 $i$ 当做 $R$ 翻折后的回文中心就可以了

对于例子来讲即:

$R_0$ = "abcd"

$R_1$ = "abcdcba"

情况二:

如果 $i$ 位置回文后的位置可以为 $R$ 的回文中心且回文半径刚好延伸到 $S$ 的开头，

则可以在当前位置翻折到达$R$的回文中心再进行下一次翻折

eg:$S$ = "acbcac", $i$ = $3$

显然当 $i$ = $5$时符合情况一

且 $r[3]$ = $2$, $3$ + $r[3]$ = $5$

正好够到 $S$ 的开头且够到 $R$ 的可行回文中心

$R_0$ = "acb"

$R_1$ = "acbca"

$R_2$ = "acbcacbca"

CODE:

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
const int N=2e7+10;
int t;
bool ans[N];
string S;
char s[N];
int r[N];
int manacher(string str){
	int len=str.size()*2+1;
	memset(ans,false,sizeof(ans));
	memset(r,0,sizeof(r));
	str=' '+str;
	int id=0,C=0,R=0,maxd=-1;
	for(int i=1;i<=len;++i)s[i]=(i&1)?'*':str[++id];
	for(int i=1;i<=len;++i){ 
		r[i]=i<R?min(R-i,r[2*C-i]):1;
		for(;i+r[i]<=len&&i-r[i]>=1;){
			if(s[i+r[i]]==s[i-r[i]])++r[i];
			else break;
		}
		if(i+r[i]>R){
			R=i+r[i];
			C=i;
		}
		maxd=max(maxd,r[i]);
	}
	return len;
}
int main(){
	scanf("%d",&t);
	for(;t--;){
		cin>>S;
		int len=manacher(S),lens=S.size();
		for(int i=lens;i>=1;--i){
			int ri=r[i*2];
			if(ri>1){//如果原串的最大回文子串长度(不包括自己)>0 
				ri/=2,--ri;//计算这个回文中心在原串里的真正回文半径(不含本身) 
				//如果把当前位置回文正好到S串的最左端,那么这个点就是R串的回文中心 
				if(i+ri==lens)ans[i]=true;
				//如果当前位置回文后的位置可以为R的回文中心且回文半径刚好延伸到S串的开头，则可以在当前位置翻折到达R点再进行下一次翻折
				if(ans[i+ri]&&i-ri==1)ans[i]=true;
			}
		}
		for(int i=1;i<=lens;++i)if(ans[i])printf("%d ",i);
		puts("");
	}
	return 0;
}
/*
4
abcdcb
qwqwq
qaqaqqq
carnation
*/ 
```

---

## 作者：feecle6418 (赞：8)

紫题太过了吧，可能绿题差不多。

设 $S[l,r]$ 表示字符串 $S$ 第 $l\sim r$ 位形成的子串（若 $l>r$ 表示 $S[r,l]$ 的反串）。若 $S[1,i]$ 可以通过多次翻转，使得给出的字符串是其前缀，我们就称 $i$ 是好的。

从后往前推，则 $i$ 好，当且仅当：

- $2i-1>n$，且 $S[i,n]=S[i,2i-n]$；
- $2i-1\le n$，$2i-1$ 是好的，且 $S[i,2i-1]=S[i,1]$。

用哈希判断字符串相等就行了。

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#define mod 1000000009ll
using namespace std;
int n,can[1000005];
long long hsh[2000005],bc[2000005]= {1};
char a[2000005];
long long GetHash(int l,int r) {
	if(l>r)return GetHash(2*n+1-l,2*n+1-r);
	return (hsh[r]-hsh[l-1]*bc[r-l+1]%mod+mod)%mod;
}
int main() {
	int T;
	scanf("%d",&T);
	for(int i=1; i<=2000000; i++)bc[i]=bc[i-1]*29%mod;
	while(T--) {
		scanf("%s",a+1);
		n=strlen(a+1);
		for(int i=1;i<=n;i++)a[2*n+1-i]=a[i];
		for(int j=1; j<=2*n; j++)hsh[j]=(hsh[j-1]*29+a[j]-'a'+1)%mod;
		for(int i=1;i<n;i++)can[i]=0;
		can[n]=1;
		for(int i=n-1;i>=1;i--){
			if(i*2-1>=n){
				if(GetHash(i,n)==GetHash(i,2*i-n))can[i]=1;
			}
			else {
				if(can[2*i-1]&&GetHash(i,2*i-1)==GetHash(i,1))can[i]=1;
			}
		}
		for(int i=1;i<=n;i++)if(can[i])printf("%d ",i);
		puts("");
	}
	return 0;
}
```

---

## 作者：谁是鸽王 (赞：7)

## 【题解】P5446 [THUPC2018]绿绿和串串(manacher)

考虑对于一个串进行$f$操作，就是让他变成一个以最后一个节点为回文中心的回文串。

那么对于某个位置$p$，假如它是一个合法的位置，那么它一直倍增一直倍增当长度大于这个原串的时候就使得$T$出现过一次了。

- 倍长一次就大于原串了，此时$p$是一个回文中心，且$p$的回文半径到达了$|T|$
- 倍长两次才大于原串，此时$S$倍增一次后的那个点$p'$是一个回文中心，且$p'$的回文半径到达了$|T|$。但为了保证第一次倍增的合法性，此时原$p$这个位置的回文半径要顶着$1$节点。
- 倍长三次...

递归地思考，一个位置合法当且仅当**这个位置是回文半径顶到右边界，或者他的右边界合法且自己的会问半径顶到边界。**

用manacher实现即可，注意一个细节，就是马拉车对于每个非辅助字符的字符，他为中心的回文串的回文边界一定是个辅助字符，要减去$1$以达到效果。

复杂度$O(2\sum |S|)$

[代码](https://www.cnblogs.com/winlere/p/11598697.html)

---

## 作者：Neutralized (赞：5)

[多半不会更好的阅读体验（雾](https://www.cnblogs.com/suitlie/p/15864180.html)  

学校字符串考试的题，唯一一道 $100\,pts$ 的，于是就来写TJ了（ 


## 1.题意  
给定一个字符串 $S$ ，判断 $S$ 的前缀中有哪些长度满足将其以尾字符为轴翻转若干次后可以覆盖 $S$ 并输出.  

举个粒子，标红的字符为翻转轴：  
对于串 $S= \tt aabaaab$ 的前缀 $\tt aab$ ，经过第一次翻转： $\tt aa\color{red}b\color{black}aa$ ，不能覆盖 $S$ ，再将这个串翻转，得到 $\tt aaba\color{red}a\color{black}abaa$ ，这时发现它覆盖了 $S$ ，所以长度 $3$ 是合法的.  
## 2.解析  
看到翻转，马上想到这是考回文串的  
看到回文串，马上想到了 $\tt Manacher$   
但是，怎么利用 $\tt Manacher$ ？  
不难发现，以某个字符为轴翻转后，就形成了一个以它为轴的回文串，而以某个字符为轴的回文串的长度正好就是 $\tt Manacher$ 要求的东西.  

怎么判断它翻转过后是合法的呢？  
考虑 $\tt Manacher$ 求得回文串长时的结束条件: 指针指向的两个字符不相等，  
也就是说，以某个位置为轴将左边的字符串（反向）和右边的字符串匹配时，在两个指针分别指向的位置失配了.  
这个又有什么用呢？我们可以拿它来判断翻转过后是否合法！  
合法的情况只有一种，就是这两个指针中的一个指向了空位置.而空位置只有两个： $S$ 左边界的左边和 $S$ 右边界的右边.  
也就是说，只有回文左边界等于 $S$ 左边界或者回文右边界等于 $S$ 右边界的位置可能构成答案.  
然后，我们要做的就是判断这些位置是否可以构成答案.  

我们这里先假定字符串下标从 $1$ 开始.  
对于前缀 $S_{1,x}$ ，分以下两种情况：  
- 1.将它进行 $1$ 次翻转后就可以覆盖 $S$ .  
这种情况下，它在 $\tt Manacher$ 中跑出的回文串右边界**一定等于** $S$ 的右边界.因为这说明，在它的回文左边界更左边的字符，对称过后一定在 $S$ 整个串的右边，可以忽略；而其它的字符构成以 $x$ 为轴的回文串，所以对它做 $1$ 次翻转就可以覆盖 $S$ .  
- 2.将它进行 $1$ 次翻转后不能覆盖 $S$ .  
这种情况很好办，如果回文左边界不是 $S$ 左边界，那么它就一定不能满足条件，直接否决它.  
如果回文左边界是 $S$ 左边界，那么我们可以直接跳跃到它的回文右边界，然后再进行判断，直到满足情况 $1$ 或是被否决.  

整体做法就是上面这样.  

（如果您看到这里已经有了思路，您可以跳过以下内容）  
有些同志可能对回文左/右边界比较迷惑，~~因为我考场上思考的时候比较乱，所以选定的回文边界比较奇特~~  
这里作一点解释:  
$\tt Manacher$ 算法中，我们首先把要处理的字符串变成一个添加了无关字符的长串，然后再求解每个位置为轴的回文串长度.  
那么，对于每个位置，我们就求得了以它为轴的回文串的左边界和右边界.  
注意这里的左边界和右边界并不是我们的回文左/右边界！回文左/右边界是左（右）边界的右（左）边一个的位置，因为左右边界对应的字符一定是 $\tt \#$ （或者其它添加的无关字符），所以我们把它们往左右推进一位，得到对应着原串 $S$ 中字符的边界.  
对应到代码中就是：  
```cpp
x的回文左边界: x-Rel[x]+2
x的回文右边界: x+Rel[x]-2
```
那么上面的思路也就~~不难理解了~~  

## 3.Code  
其实是考场代码，删除了~~奇奇怪怪的~~注释,对代码作用写了一点注释，并且做了一点点可读化处理.

```cpp
#include <bits/stdc++.h>
#define ri register int
#define MAXN 3000001 //Manacher记得开两倍……
#define ll long long
using namespace std;

int T,lens;
string s;
int Rel[MAXN];

inline void Sync(){
	ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
}

inline void Manacher(){
    lens=s.length();
    string buf="%#";
    for(ri i=0;i<lens;i++)
    buf+=s[i],buf+="#";
    lens=buf.length();
    ri ind=0,Mxr=0;
    for(ri i=2,j;i<lens;i+=2){
        j=(ind<<1)-i;
        Rel[i]=(i<Mxr?min(Rel[j],Mxr-i):1);
        while(buf[i+Rel[i]]==buf[i-Rel[i]])
        ++Rel[i];
        if(i+Rel[i]>Mxr)
        Mxr=i+Rel[i],ind=i;
    }
} //就是普通的Manacher，跳的时候跳2个就行

#define reset(x,i) memset(x,i,sizeof(x))
int main()
{
    Sync(); //Sync With Me !
    cin>>T;
    while(T--){
        reset(Rel,0); //清空Manacher数组 
        cin>>s;
        Manacher(); //跑Manacher 
        for(ri i=2;i<lens-2;i+=2){ //lens-2是最后一个非'#'字符 
            register bool f=0;
            for(ri j=i;Rel[j]>2&&j+Rel[j]<=lens;j+=Rel[j]-2){ //Rel[j]>2限制了回文串长度必须大于1 
                if(j+Rel[j]==lens){ //对应情况1：回文右边界和串右边界相等 
                    f=1; //标记答案 
					break; //直接退出去输出 
				}
                if(j-Rel[j]>2&&j+Rel[j]<lens) //如果对称后不匹配 
				break; //直接退出 
            }
			if(f) //有答案，输出 
			cout<<i/2<<" "; //Manacher串中下标为i，对应S中下标为i/2 
        } cout<<s.length()<<endl; //别忘了所有的S都可以作为初始串 
    }
    return 0;
}
```  
然后就做完辣！  

---

## 作者：Aisaka_Taiga (赞：4)

一开始我只想出了判断经过一次翻转的处理，然后看到了[这篇题解](https://www.luogu.com.cn/blog/469672/solution-p5446)。

感觉大佬讲的不是很清晰，希望我能帮助各位理解。

设给出的前缀串为 $s$。

从题目来看就可以知道分为两种情况：

1. 当前的串经过一次翻转得到的字符串，$s$ 是此串的前缀；

2. 当前的串经过多次翻转得到的字符串，$s$ 是此串的前缀。

对于第一种情况，我们看下面这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/o2perh2j.png)

蓝红两条竖线分别为以 $i$ 为中心的最大回文串的左右端点，可以发现，如果要是当前的串以 $i$ 为末尾进行折叠的话，就会产生一个串，而这个串的前缀里面就有给出的 $s$，因为 $p[i]$ 是在 $s$ 串中求得的，所以如果要是 $i+p[i]-1=cnt$ 的话，翻转过来的时候，得到的新串 $a$ 中的 $a[i]$ ~ $a[i+p[i]-1]$ 一定是与 $s[i]$ ~ $s[cnt]$ 的部分是完全一样的，只有这种情况以 $i$ 为末尾翻转一次是可以的，这个时候我们用 $g$ 数组来标记一下。

对于第二种情况，不好用图来解释，我们用样例中的 `qwqwq` 来解释：我们从样例的输出得知，`qw` 是可以经过两次翻转得到一个字符串 $a$，$s$ 是 $a$ 的前缀的，而我们发现，我们可以发现 `qw` 翻转一次是 `qwq`，`qwq` 是可以经过一次翻转就得到 `qwqwq` 的！也就是说，我们可以利用之前翻转一次就可以的点来寻找需要翻转两次，三次等等才能得到目标串的！那么我们翻转一次后再翻转一次能得到答案的标志是什么？就是我们翻转后的右端点的 $g$ 数组是被标记过的！也就是说 $g[i+p[i]-2]=1$，为什么下标是 $i+p[i]-2$ 嘞？因为我们知道 manacher 算法是要插入字符的，而这时求的回文串是有插入的特殊字符的，再向左移一位才是真正的回文串的结尾的字符。这个时候还需要注意的一点就是因为我们的串要翻转多次才能达到目标串，可以看出当前的最大回文半径是 $i$，也就是说 $i=p[i]$ 才行（因为要整个翻转过来嘛）。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000100
using namespace std;
int T,n,p[N<<1],g[N<<1],cnt;
char s[N<<1];
inline void qk()
{
	for(int i=1;i<=cnt;i++)
	  p[i]=g[i]=0;
}
signed main()
{
	cin>>T;
	while(T--)
	{
		cnt=0;
		char c=getchar();
		s[0]='!';s[++cnt]='%';
		while(c<'a'||c>'z')c=getchar();
		while(c>='a'&&c<='z')s[++cnt]=c,s[++cnt]='%',c=getchar();
		s[cnt+1]='#';
		qk();
		int j=0,mid=0;
		for(int i=1;i<=cnt;i++)
		{
			if(i<=j)p[i]=min(p[2*mid-i],j-i+1);
			while(s[i+p[i]]==s[i-p[i]])p[i]++;
			if(i+p[i]>j)j=p[i]+i-1,mid=i;
		}
//		for(int i=2;i<=cnt;i+=2)
//		  cout<<p[i]-1<<" ";
//		cout<<endl;
		for(int i=cnt-1;i>=1;i-=2)
		{
			if(i+p[i]-1>=cnt)g[i]=1; 
			else if(g[i+p[i]-2]&&i==p[i])g[i]=1;
			else continue;
		}
		for(int i=2;i<=cnt;i+=2)
			if(g[i])cout<<i/2<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：4)

没人用 PAM，但我~~又不会~~又不想写 manacher，于是交一发 PAM 的题解。

题意不多说了，发现用 Hash 做的反而讲的更好。（指 @[_Enthalpy](https://www.luogu.com.cn/user/42156)）

若 $S_{1,i}$ 能通过多次翻转，使得给出的字符串是其前缀，则 $i$ 合法。

那么我们从后往前推，若 $i$ 合法，当且仅当：

- $2i-1>n$ 时：$S_{2i-n,n}$ 是回文串。

- $2i-1\le n$ 时：$2i-1$ 合法且 $S_{1,2i-1}$ 是回文串。

由于 PAM 是增量构造的，到 $i$ 时看它最长回文长度自然知道 $S_{1,i}$ 是不是回文串。

而 $S_{2i-n,n}$ 都是以 $n$ 结尾的回文串，把 $n$ 的后缀回文暴力取出来标记即可。

代码：

```
const int Mx=1e6;
namespace PAM
{
	int cnt,lst,tot,chr[Mx+5],len[Mx+5],fil[Mx+5],nxt[Mx+5][26];
	inline int New(int x)
	{
		return fil[cnt]=0,len[cnt]=x,memset(nxt[cnt],0,sizeof(nxt[cnt])),cnt++;
	}
	inline void Clr()
	{
		cnt=lst=tot=0;
		New(0);New(-1);
		chr[0]=-1;fil[0]=1;
	}
	inline int Get(int x)
	{
		for(;chr[tot]^chr[tot-len[x]-1];x=fil[x]);
		return x;
	}
	inline int Ins(int c)
	{
		int p,nw;
		chr[++tot]=c;
		if(!nxt[p=Get(lst)][c])
		{
			nw=New(len[p]+2);
			fil[nw]=nxt[Get(fil[p])][c];
			nxt[p][c]=nw;
		}
		lst=nxt[p][c];
		return len[lst]==tot;
	}
	inline void Cov(int ps,int *ck)
	{
		for(;lst;lst=fil[lst])if(len[lst]&1)ck[ps-(len[lst]>>1)]=1;
	}
}
int TT,len,vst[Mx+5],chk[Mx+5];
signed main()
{
	#ifndef ONLINE_JUDGE
	freopen("_.in","r",stdin);
//	freopen("_.out","w",stdout);
	#endif
	int i;
	char ch;
	for(TT=read();TT;TT--)
	{
		PAM::Clr();
		for(len=0,ch=gt();ck(ch);ch=gc())
		{
			vst[++len]=PAM::Ins(ck(ch)-1);
			chk[len]=0;
		}
		PAM::Cov(len,chk);
		for(i=len;i;i--)
		{
			if((i<<1)-1<=len)
			{
				if(chk[(i<<1)-1]&&vst[(i<<1)-1])chk[i]=1;
			}
		}
		for(i=1;i<=len;i++)if(chk[i])writenum(i,32);
		pc(10);
	}
	return output;
}
```

---

## 作者：lg_zhou (赞：3)

裸的  _manacher_ 算法。

很直观的一点是：如果以当前位置 $i$ 为中心的最长回文串是 $S$ 的后缀， 那么再进行一次翻转就一定满足题意。

否则它要进行多次翻转，那么进行一次翻转还能和 $S$ 匹配的条件是以当前位置 $i$ 为中心的最长回文串是 $S$ 的前缀。

那我们可以把 $d$ 数组求出来后，倒着扫一遍，如果是后缀，就直接可行，如果是前缀，那么就看它翻一次行不行就 ok 了。

上代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 1e6+6;
int d[maxn], pan[maxn];
int main(){
	//freopen("a.in","r",stdin);
	int t;
	cin >> t;
	int lst = 0;
	while(t--){
		for (int i = 0; i <= lst; i++) d[i] = 0, pan[i] = 0;
		string s;
		cin >> s;
		int l,r;
		l = 0, r = -1;
		for (int i = 0; i < s.length(); i++){
			if (i < r) d[i] = min(d[l+r-i], r-i+1);
			while(i+d[i] < s.length() && i-d[i] >= 0 && s[i+d[i]] == s[i-d[i]]) d[i]++;
			if (i+d[i]-1 > r) l = i-d[i]+1, r = i+d[i]-1;
		}
		for (int i = s.length()-1; i >= 0; i--){
			if(i+d[i]-1 == s.length()-1) pan[i] = 1;//后缀
			if (i-d[i]+1 == 0) pan[i] = pan[i+d[i]-1];//前缀，翻一次 
		}
		for (int i = 0; i < s.length(); i++){
			if (pan[i]) cout << i+1 << " ";
		}
		cout << endl;
		lst = s.length();
	} 
	return 0;
}
```


---

## 作者：CG__HeavenHealer (赞：2)


其实本题的 Hash 解法应该更好想。

### 题意：

题意非常诡异：求出给定字符串的长度为 $x$ 的一个前缀是否满足它的一个前缀翻转过来的前缀能和这个串的后缀匹配，能的话输出 $x$。

~~听起来完全听不懂~~

比如，对于这个串：$abcdcb$，$4$ 合法是因为再 $abcd$ 这个前缀中，有一个长度为 $3$ 的前缀 $abc$，反转后为 $cba$，前两个字符可以匹配原串的后两个字符。

考虑一个暴力~~还有问题~~的算法：处理出原串正和反的哈希之后，$n^2$ 扫描前缀以及前缀的前缀，之后 $\Theta(1)$ 匹配反转后的前缀和原串的后缀。

这样就有问题了：因为这个串的前缀可以无限次反转拼接，所以像这样的一个串 $qwq$，可以得到 $qwqwq,qwqwqwq\ldots$，直接判断它可能并不能得到合法方案。

所以我们把正着扫改成倒着扫：

- 如果扫的位置在字符串的后一半，它是不可能有循环节的，直接判断即可。注意这里的长度上限是 $n-i+1$，因为只有前缀加上前缀的前缀的长度大于等于原串的长度时才有可能匹配成功，所以长度上限应该以原串为准；

  另外要注意，由于我们预处理的是正着的和反着的哈希值，所以考虑前缀时应该倒着考虑，即把 $n$ 看成 $1$，把 $i$ 看成 $n-i+1$，那么需要处理的区间设为 $[1,l]$，由对称关系得到 $\dfrac{l+1}{2}=n-i+1$，解出 $l=2n-2i+1$，所以判断的条件就是 $Hash(i,n)=reverseHash(n-i+1,2n-2i+1)$。

- 而如果扫的位置在前一半，考虑他反转过去，对应点是否合法；如果合法的话，再比较一下 $Hash(i,2i-1)$ 是否等于 $reverseHash(n-i+1,n)$，目的是判断是否满足回文。显然，关于 $i$ 回文的话，在 $2i-1$ 和 $i$ 这两个位置的合法性应该是相同的。比如 $degede$ 这个串，在 $3$ 和 $5$ 两个位置取到的合法前缀都应该是 $de$。如果 $2i-1$ 这个位置合法，$i$ 也会合法。倒推也可以避免统计不到循环反转了好几次才合法的情况。

```cpp
#include <bits/stdc++.h> 
using namespace std;
#define int long long
using ull = unsigned long long;
#define ri register int
const int N = 5e6 + 10;
const ull base = 13331;
inline int read() {
	ri x = 0, f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar())
		if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	return f * x;
}
char s[N], rs[N];
ull hsh1[N], hsh2[N], pw[N];
bool vis[N];
inline ull Hash(int l, int r) {
    return hsh1[r] - hsh1[l - 1] * pw[r - l + 1];
}
inline ull rHash(int l, int r) {
	return hsh2[r] - hsh2[l - 1] * pw[r - l + 1];
}
inline void init() {
	memset(rs, 0, sizeof(rs));
	memset(vis, false, sizeof(vis));
	memset(hsh1, 0, sizeof(hsh1));
	memset(hsh2, 0, sizeof(hsh2));
}
signed main() {
	pw[0] = 1;
	for (ri i = 1; i < N; i++) pw[i] = pw[i - 1] * base;
	for (ri T = read(); T--; init()) {
		scanf("%s", s + 1);
		int n = strlen(s + 1);
		for (ri i = 1; i <= n; i++) rs[i] = s[i];
		reverse(rs + 1, rs + n + 1);
		for (ri i = 1; i <= n; i++) 
			hsh1[i] = hsh1[i - 1] * base + (ull)s[i], 
			hsh2[i] = hsh2[i - 1] * base + (ull)rs[i];
		vis[n] = true;
		for (ri i = n - 1; i; i--) {
			if (2 * i - 1 >= n) { 
 				if (Hash(i, n) == rHash(n - i + 1, n * 2 - 2 * i + 1)) vis[i] = true;
			} else {
				if (vis[2 * i - 1] && Hash(i, 2 * i - 1) == rHash(n - i + 1, n)) 
					vis[i] = true; 
			}
		}
		for (ri i = 1; i <= n; i++) 
			if (vis[i]) printf("%lld ", i);
		putchar(10);
	}
	return 0;
}
/*
3
abcdcb
qwqwq
qaqaqqq
*/
```



---

## 作者：Lamorak (赞：2)

作为学校字符串考试得分最高，~~做的最容易~~的一道题，发篇题解纪念一下

用 manacher + dfs 可以 AC ，但跑得是真心慢
如果您不知道什么是 manacher ，建议先做[P3805](https://www.luogu.com.cn/problem/P3805)和[P4555](https://www.luogu.com.cn/problem/P4555)


------------


### 思路

   看见回文串首先想到 manacher ，所以先打个表

| a | b | c | d | c | b |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 | 1 | 5 | 1 | 1 |

简单分析一下不难想到，$rl[i] = 1$ 时，$i$ 不可能满足要求。

对于答案节点我们可以用跳跃的方法来处理，例如

 $\texttt{gilgamesh}$ ，如果 $a$ 为答案节点；

$\texttt{gilga} \to \texttt{gilgaglig}$，翻转一下就等于了字符串长度。

对于 $\texttt{gilgaglig}$ 这个字符串，$rl[a]=9$，向右跳跃的最远距离为4，即 $rl[a] \div 2$，跳到了 $g$ 节点，$g$   已经是末节点了，所以 $a$ 可以。

那如果 $g$ 不是末节点呢，再按 $rl[g] \div 2$ 跳，直到跳到末节点或者把跳跃次数用完。


------------

### 怎么求跳跃次数

```
while(j<=len){
	deep++;
	j=j*2-1;
}
```
如果 $j$ 点为答案节点，那么一次翻转可以到达 $j \times 2-1$ 处，第二次翻转可到达 $2 \times (j \times 2-1)-1$ 处……直到超越字符串长度。

接下来就可以用搜索来一步一步向右跳跃了。

贴上蒟蒻代码~~大佬勿喷~~：
```
#include<bits/stdc++.h>
using namespace std;
const int N=2*1e6+90;
int rl[N],maxr,pos,t;
int q[N],len;
string a;

inline void manacher(){//模板
	string s="@#";
	for(register int i=0;i<len;i++){
		s+=a[i];
		s+="#";
	}
	for(register int i=1;i<s.size();i++){
		rl[i]=maxr>i?min(maxr-i,rl[pos*2-i]):1;
		while(s[i+rl[i]]==s[i-rl[i]]) rl[i]++;
		if(rl[i]+i>maxr){
			maxr=rl[i]+i;
			pos=i;
		}
	}
	for(register int i=2;i<s.size();i+=2){
		q[i/2]=rl[i]-1;//方便使用
	}
}

inline int dfs(int x,int deep){
	if(x>=len) return 1;//如果跳到了尽头
	if(q[x]==1) return -1;//q[]即rl[]数组，如果为一，则不能向右跳跃，不加次句会死循环
	if(deep==0) return -1;//如果次数用完了
	return dfs(q[x]/2+x,deep-1);//以当前节点向右跳跃
}
inline void clear(){
	memset(rl,0,sizeof(rl));
	memset(q,0,sizeof(q));
	maxr=0;
	pos=0;
}
		
int main(){
	scanf("%d",&t);
	while(t--){
		cin>>a;
		clear();
		len=a.size();
		if(len==1){//特判，若长度为1，可直接输出，不然下面不能处理
			printf("1\n");
			continue;
		} 
		manacher();
		for(register int i=1;i<len;i++){//若长度不为1，可直接跳过0号，从1号开始
			int deep=0,j=i+1;
			if(j==len){//特判，末节点一定满足要求
				printf("%d\n",j);
				break;
			}
			while(j<=len){
				deep++;
				j=j*2-1;
			}
			int ans=dfs(i+1,deep);
			if(ans==1) printf("%d ",i+1);
		}
	}
	return 0;
}
```
最后，给大家推荐另外几道 manacher 的题

[P1659](https://www.luogu.com.cn/problem/P1659)
[P3501](https://www.luogu.com.cn/problem/P3501)

---

## 作者：lqhsr (赞：2)

### **清华的题当然要写题解** 

那我就来做好事啦 ~~希望我能进清华~~

感觉这题大概蓝题左右不应该是紫的 ~~可能是头衔比较重~~

--------------------------------------------------正事分割线--------------------------------------------------

一句话题意:每次给你一个串S，要求你找出所有可能的串长度$|R|$，使S是R经过多次翻转之后的前缀。

读完题我们就知道**这题要求的是所有可能的串长** ~~废话~~

看完对称方式我们可以很快想到**回文串**

其实题目要求的就是回文串的半径**我们称之为回文半径**

再往下想 **该用什么求回文半径呢**

## 那当然是manacher啦

**~~这时你离清华近了一大步~~**

还要考虑答案怎么统计

### 考虑两种情况

1.R的左端点达到了S的左端点

2.R的右端点达到了合法的左端短点（所以代码里ans是倒序）

具体解释其他大佬也说的很清晰了就不再解释

不多说了上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int len,t,r[10000005],ans[10000005];
char s[10000005],ss[10000005];
void manacher(){
	int maxr=0,pos=0;
	for(int i=1;i<=len;i++){
		if(i<maxr)r[i]=min(r[(pos<<1)-i],maxr-i);
		else r[i]=1;
		for(;s[i-r[i]]==s[i+r[i]];++r[i]);
		if(maxr<r[i]+i)maxr=r[i]+i,pos=i;
	}
}
signed main(){
	scanf("%d",&t);
	while(t--){
		memset(r,0,sizeof(r));
		memset(ans,0,sizeof(ans));
		memset(s,0,sizeof(s));
		memset(ss,0,sizeof(ss));
		scanf("%s",ss+1);
		int lens=strlen(ss+1),ji;
		s[0]=s[1]='#';ji=1;
		for(int i=1;i<=lens;i++)s[++ji]=ss[i],s[++ji]='#';
		len=strlen(s);
		manacher();
		for(int i=1;i<=len;i++)--r[i];
		for(int i=lens;i>=1;i--){
			int ri=r[i*2];
			if(ri){
				ri>>=1;
				if(i+ri==lens)ans[i]=1;
				if(ans[i+ri]&&i-ri==1)ans[i]=1;
			}
		}
		for(int i=1;i<=lens;i++)if(ans[i])printf("%d ",i);puts("");
	}
}
```

---

## 作者：¶凉笙 (赞：1)

## [题解] P5446 [THUPC2018]绿绿和串串

> 这里有一个不用 manacher 的题解！
>
> [不一定更好的阅读体验](https://www.cnblogs.com/Liang-sheng/p/15223332.html)

### 字符串哈希

手动模拟一下初始串 $R$ 变为 $R'$ 的过程，可以发现是这样递归进行的：对于当前过程中的串，以结尾作为对称轴翻转前 $|R|-1$ 个字符。

因为要求是 $S$，是 $R'$ 的一个前缀，所以最后的 $R'$ 保留前 $|S|$ 位和 $S$ 相等就是一个合法的 $R$。

> 本题的核心解法

不管对称变换几次，每一次都是要对一个前缀进行翻折，所以说，**如果一个字符串是一个合法的 $R$，那么这个字符串也是 $S$ 的一个前缀**，这是不难发现的。

更重要的是，一个 $S$ 的前缀 $S_{1,i}$ 合法的**必要条件**是：**$i$ 是一个回文半径为 $i-1$ 的字符串的回文中心**。

比如说对于 $qwqwq$ 这个字符串，位置 $2,3$ 都是满足上述条件的。

而对于这个回文串的右端点，可以作为一个新的对称轴进行前 $2i-2$ 个字符的又一次翻折。

这样就可以用**并查集维护序列**，对于每一次翻折形成的一个新的回文串的右端点 $r$，把它们用并查集并起来。

那么这样向右翻折到什么时候才能判断充分性呢？

对于当前的一次翻折，新的回文串已经覆盖掉了 $S$ 的所有字符，往前推回去，这个回文中心就是合法的。

比如对于 $qwqwq$ 的第一个 $w$，翻折一次形成了 $qwq$，再翻折一次形成了 $qwqwq$，那第 $2$ 个位置就是一个合法的回文中心，而 $qaqaqqq$ 的第一个 $a$ 就是非法的。

不难发现，如果右端点 $r$ 已经翻折到了 $\geq \lfloor\frac{n}{2}+1\rfloor$ 的位置，那么如果是一个回文中心，往前推之前翻折到这里的回文中心就可以了，而并查集就起到了这样的作用。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
template <typename T>
inline T read(){
	T x=0;char ch=getchar();bool fl=false;
	while(!isdigit(ch)){if(ch=='-')fl=true;ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);ch=getchar();
	}
	return fl?-x:x;
}
#include <vector>
#define ull unsigned long long
const ull P = 13331;
const int maxn = 1e6 + 10;
int T,fa[maxn];
bool vis[maxn];
char s[maxn];
inline int find(int x){
	while(x!=fa[x])x=fa[x]=fa[fa[x]];
	return x;
}
ull Hash1[maxn],Hash2[maxn],power[maxn];
inline ull get1(int l,int r){
	return Hash1[r]-Hash1[l-1]*power[r-l+1];
}
inline ull get2(int l,int r){
	return Hash2[l]-Hash2[r+1]*power[r-l+1];
}
inline void merge(int x,int y){
	x=find(x);y=find(y);
	if(x!=y)fa[x]=y;
}
#define Pair pair<int,int>
#define mp make_pair
vector<Pair> tmp;
int main(){
	T=read<int>();
	while(T--){
		scanf("%s",s+1);int n=strlen(s+1);
		tmp.clear();
		power[0]=1;
		for(int i=1;i<=n;i++){
			vis[i]=false;fa[i]=i;
			Hash1[i]=Hash1[i-1]*P+s[i]-'a'+1;
			power[i]=power[i-1]*P;
		}
		for(int i=n;i>=1;i--){
			Hash2[i]=Hash2[i+1]*P+s[i]-'a'+1;
		}
		int n1=n/2+1;
		for(int i=1;i<=n;i++){
			int len;
			if(i<n1)len=i;
			else len=n-i+1;
			if(get1(i-len+1,i)==get2(i,i+len-1))vis[i]=true,tmp.push_back(mp(i,len));
		}
		for(auto p:tmp){
			int pos=p.first,len=p.second;
			if(vis[pos+len-1])merge(pos,pos+len-1);
		}
		for(int i=1;i<=n;i++){
			int x=find(i);
			if(x>=n1 && vis[x])printf("%d ",i);
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：SoyTony (赞：0)

简单题，仔细思考一下回文的性质。

假设我们枚举每个前缀，那么什么时候是合法的？

如果这个前缀进行一次翻转复制后，长度不小于 $|S|$，那么我们只需要保证在 $|S|$ 内的部分是回文的，例如 `abcdc` 中，的 `d`，我们只需要保证两个 `c` 是满足回文的即可。

而问题是，不能枚举每个位置再构造出翻转一次后的串，那么超出的部分，可以直接设为通配符 `?`，这样一次 $\text{Manacher}$ 之后就初步求出了答案。

接下来，显然不合法的是回文半径无法到达字符串开头的（根本无法作为一个前缀开始翻转）。

考虑 $i+d_i-1=j$ 而 $j$ 这个前缀是一个合法前缀，也就是说通过一次翻转复制，$i$ 变成了 $j$，剩下的就都一致了。

倒序枚举位置，判断一次操作是否起码填满 $S$ 或一次操作后的前缀是否合法。

```cpp
int t;
int n;
char s[maxn];
int d[maxn];
bool mark[maxn];
inline void Manacher(){
    memset(d,0,sizeof(d));
    for(int i=1,l=0,r=-1;i<=n;++i){
        int j=l+r-i,k;
        if(i>r) k=1;
        else k=min(d[j],r-i+1);
        while(i-k+1>=1&&i+k-1<=2*n-1&&(s[i-k+1]==s[i+k-1]||s[i+k-1]=='?')) d[i]=k++;
        if(i+d[i]-1>r) l=i-d[i]+1,r=i+d[i]-1;
    }
}
int main(){
    t=read();
    while(t--){
        scanf("%s",s+1);
        n=strlen(s+1);
        for(int i=n+1;i<=2*n-1;++i) s[i]='?';
        Manacher(); 
        for(int i=1;i<=n;++i) mark[i]=0;
        for(int i=n;i>=1;--i){
            if(d[i]!=i) continue;
            if(i+d[i]-1>=n) mark[i]=1;
            else if(mark[i+d[i]-1]) mark[i]=1;
        }
        for(int i=1;i<=n;++i){
            if(mark[i]) printf("%d ",i);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P5446)

题目中提到的“翻转”让我们联想到回文串。确实，这题和回文串有关。

首先我们思考 $R$ 需要哪些字符才能使得翻转后合法。

很明显这个字符串需要有 $S$ 的所有字符并且每次翻转后的 $R$ 一定是 $S$ 的前缀。

那我们可以想办法找出所有的 $i$ 使得 $S[1\sim i]$ 能成为 $R$。

先考虑一种简单的情况：$S[2i-n\sim n]$ 是一个回文串，也就是说后 $2(n-i)+1$ 位是一个回文。

那么此时的 $i$ 是可行的，因为此时的前缀只需要翻转一次就能填充后面 $n-i$ 位，而 $2i-n$ 前面的并不影响，因为长度超过了 $|S|$。

比如有一个 $S$：

```
gyyyyxabcba
```

明显后面 $3$ 个字符组成的串是一个回文串。

那开头到回文串的中心也就是 $S[8]$ 就是一个合法的 $R$。

像这样：

```
gyyyyxabc
```

翻转一次之后变成：

```
gyyyyxabcbcxyyyyg
```

显然 $S$ 就是这个串的前缀。

那么如果我们将 $S[1\sim i]$ 给提取出来，变成一个新串，那我们又可以重新判断像上面那样判断更多的。

我们如果一直这样操作，提取合法的前缀，那么到提取到某个串前的操作次数就是这个串翻转到合法的次数。

举一个栗子：

```
S=acbcac
```

我们将前 $6$ 为提取出来（因为后 $3$ 位是回文串）。

```
R1=acbca
```

而这个串就是一个回文串，如果在提取一次：

```
R2=acb
```

手动验算一下就知道是合法的了。

但需要注意的，后面提取出来的串（$R2,R3...$）一定要是回文串，也就是某个前缀是回文串才能提取。

因为翻转超过 $1$ 次之后如果要继续翻转，那前面的字符都会对整个串产生影响，也就是可能不符合 $S$ 为它的前缀这个条件。

我们可以用一个递推的方式，设 $vis_i$ 表示 $S[1\sim i]$ 是否是合法的 $R$。

那么 $vis_i=[i+p_i-1=n]\ or\ ([vis[i+p_i-1]=1]\ and\ [i-p_i+1=1])$，分别对应的以上两种情况。

其中的 $p_i$ 分别表示以 $i$ 为中心的回文串的最长长度，那我们的任务就变成了求 $p_i$。

显然可以用一个 $\text{Manacher}$ 求。

代码：

```cpp
#include<bits/stdc++.h>
#define N 2000005
using namespace std;
int T,s[N],p[N],cnt;
inline void get(){
    char c(getchar());
    while(c<'a'||c>'z') c=getchar();
    s[0]=-1;s[cnt=1]=-2;
    while(c>='a'&&c<='z'){
        s[++cnt]=c;
        s[++cnt]=-2;
        c=getchar();
    }
    s[cnt+1]=-3;
}
bool vis[N];
int main(){
    scanf("%d",&T);
    while(T--){
        get();
        memset(p,0,sizeof(p));
        for(int i(1),c(0),r(0);i<=cnt;++i){
            if(i<=r) p[i]=min(p[(c<<1)-i],r-i+1);
            while(s[i-p[i]]==s[i+p[i]]) ++p[i];
            if(i+p[i]>r) r=i+p[i]-1,c=i;
        }
        memset(vis,0,sizeof(vis));
        for(int i(cnt);i;--i){
            if(i+p[i]-1==cnt) vis[i]=1;
            else if(vis[i+p[i]-2]&&i==p[i]) vis[i]=1;
        }
        for(int i(2);i<=cnt;i+=2) if(vis[i]) printf("%d ",(i>>1));puts("");
    }
    return 0;
}
```

接着会发现好像长度为偶数的回文串都没有用，仔细想一下，确实，需要用到的回文串一定有一个字符在中心，那可以直接改一下。

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int T,s[N],p[N],cnt;
inline void get(){
    char c(getchar());cnt=0;
    while(c<'a'||c>'z') c=getchar();
    while(c>='a'&&c<='z'){
        s[++cnt]=c;
        c=getchar();
    }
    s[0]=-1;s[cnt+1]=-2;
}
bool vis[N];
int main(){
    scanf("%d",&T);
    while(T--){
        get();
        memset(p,0,sizeof(p));
        for(int i(1),c(0),r(0);i<=cnt;++i){
            if(i<=r) p[i]=min(p[(c<<1)-i],r-i+1);
            while(s[i-p[i]]==s[i+p[i]]) ++p[i];
            if(i+p[i]>r) r=i+p[i]-1,c=i;
        }
        memset(vis,0,sizeof(vis));
        for(int i(cnt);i;--i){
            if(i+p[i]-1==cnt) vis[i]=1;
            else if(vis[i+p[i]-1]&&i==p[i]) vis[i]=1;
        }
        for(int i(1);i<=cnt;++i) if(vis[i]) printf("%d ",i);puts("");
    }
    return 0;
}
```

速度快了一倍！！！

---

## 作者：Supor__Shoep (赞：0)

一小时前才自学了 Manacher 算法，现在一做竟然过了！

首先，我们根据回文串看出，这道题需要利用 Manacher 算法求出以每一个节点为中心位置，长度为奇数的回文串最大长度（这里就是一个模板）：

在 Manacher 算法中，我们定义 $d_i$ 为以 $s_i$ 为中心的回文串的最大半径，并且维护一个最大的回文串的左右端点，我们可以根据前面得到的 $d_j$ 反向推导出 $d_i$ 的最小值。假设现在维护的左右端点是 $l$ 和 $r$，则如果 $i$ 处于 $[l,r]$ 之间的话，我们可以得到公式：

$$d_i=\min(d_{l+r-i},r-i+1)$$

其解释也在 [WIKI](https://oi.wiki/string/manacher/#_2) 中说明了，我就不再过多解释。

而 $i>r$ 的时候，我们只用将其设为 $1$，即只包括它本身的串。

Manacher 算法计算长度为奇数的回文串的代码如下：

```cpp
for(int i=0,l=0,r=-1;i<len;i++)
{
	int k=(i>r)?(1):(min(d1[l+r-i],r-i+1));
	while(i-k>=0&&i+k<len&&s[i-k]==s[i+k])	k++;
	d1[i]=k--;
	if(i+k>r)
	{
		l=i-k;
		r=i+k;
	}
}
```
然后就是本题的难点，该怎么判断一个串可以通过多次翻转得到目标串？

这个其实非常简单，以 qwqwq 为例，假设我们已经求出了 qwq 是一个答案，那么我们再将 qwq 设为目标串，根据观察，qw 可以通过一次翻转得到 qwq，那么同样的，qw 可以通过两次翻转得到 qwqwq。想到这里，我们就可以定义一个数组判断 $[1,i]$ 的串是否可以翻转成目标串，然后从大到小进行操作，这样可以保证可以查询到后面符合条件的目标串。

而判断长度大的子串能否翻转成目标串，我们可以推一下式子，也就是其子串末尾节点的下标加上回文串的半径 $d_i$，如果它达到 $len-1$，就说明子串可以翻转成目标串。

对于通过多次翻转的子串，我们可以用同样的方式，更换目标串，然后套用同样的式子进行判断。

然后就可以切掉了！

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int d1[MAXN],d2[MAXN];
char s[MAXN];
bool vis[MAXN];
int maxx=-1;
int len;
int main()
{
	int T;
	scanf("%d\n",&T);
	while(T--)
	{
		len=0;
		memset(vis,0,sizeof(vis));
		char ch;
		while(ch=getchar())
		{
			if(ch=='\n')	break;
			s[len++]=ch;
		}
		for(int i=0,l=0,r=-1;i<len;i++)
		{
			int k=(i>r)?(1):(min(d1[l+r-i],r-i+1));
			while(i-k>=0&&i+k<len&&s[i-k]==s[i+k])	k++;
			d1[i]=k--;
			if(i+k>r)
			{
				l=i-k;
				r=i+k;
			}
		}
		for(int i=len-1;i>=0;i--)
		{
			if(i+d1[i]-1==len-1)	vis[i]=1;
			else if(vis[i+d1[i]-1]&&i+1==d1[i])	vis[i]=1;
		}
		for(int i=0;i<len;i++)
		{
			if(vis[i])	printf("%d ",i+1);
		}
		puts("");
	}
	return 0;
}
```

---


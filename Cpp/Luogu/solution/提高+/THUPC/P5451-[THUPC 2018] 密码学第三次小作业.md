# [THUPC 2018] 密码学第三次小作业

## 题目背景

1977年，罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）提出了RSA 加密算法。RSA 加密算法是一种非对称加密算法，其可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。

RSA 的基本原理如下：

- 公钥与私钥的产生
  1. 随机选择两个不同大质数 $p$ 和 $q$，计算 $N=p\times q$
  2. 根据欧拉函数性质，求得 $r=\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
  3. 选择一个小于 $r$ 的正整数 $e$，使 $e$ 和 $r$ 互质。并求得 $e$ 关于 $r$ 的乘法逆元 $d$，有 $ed\equiv 1 \pmod r$
  4. 将 $p$ 和 $q$ 的记录销毁。此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。
- 消息加密：首先需要将消息 $m$ 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $n$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：

$$
n^{e}\equiv c\pmod N
$$

- 消息解密：利用密钥 $d$ 进行解密

$$
c^{d}\equiv n\pmod N
$$

## 题目描述

现在有两个用户由于巧合，拥有了相同的模数 $N$，但是私钥不同。设两个用户的公钥分别为 $e_1$ 和 $e_2$，**且两者互质**。明文消息为 $m$，密文分别为：

$$\begin{matrix}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{matrix}$$

现在，一个攻击者截获了 $c_1$ ，$c_2$，$e_1$，$e_2$，$N$，请帮助他恢复出明文 $m$ 。

## 说明/提示

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
1
1502992813 2511821915 653507 57809 2638352023```

### 输出

```
19260817```

# 题解

## 作者：Aw顿顿 (赞：25)

## 题意概括

实际上，题目背景和所求并没有很强的相关性，现摘录简化版题目要求：

> 现有相同的模数 $N$ 与不同的私钥。设两公钥分别为 $e_1,e_2$ 且 $\gcd(e_1,e_2)=1$。明文消息为 $m$，密文分别为：
> 
> $$\begin{matrix}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{matrix}$$
> 
> 已知 $c_1,c_2,e_1,e_2,N$，求 $m$。

## 寻找突破口

重点应该在 $e_1,e_2$ 互质，也就是说 $\gcd(e_1,e_2)=1$，这是突破口。

于是我们可以发现应当有整数 $s,t$ 使得下列式子成立：

$$s\cdot e_1+t\cdot e_2=\gcd(e_1,e_2)=1$$

我们发现，式子的右边是 $1$，这个 $1$ 必须成为连接答案和题设的桥梁。如何让这个 $1$ 把两者连接起来呢？一个比较朴素的想法是将 $1$ 与 $m$ 相乘，但是这是徒劳的。

## 推导式子

我们会发现，在题目所给的式子中：

> $$\begin{matrix}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{matrix}$$

$e_1,e_2$ 都是以指数的形态出现，也就是说如果我们能够把 $1$ 作为指数和这个式子放在一起，可能会有转机。那么我们试着在模 $N$ 意义下处理：

$$m\equiv m^1\equiv m^{s\cdot e_1+t\cdot e_2}\pmod N$$

如果我们利用幂的性质，将指数上不大好处理的 $+$ 变成乘号，就能够得到一个式子：

$$m\equiv m^{s\cdot e_1}\times m^{t\cdot e_2}\pmod N$$

这时候我们注意到一件事情，在式子中独立出现了 $m^{e_1}$ 和 $m^{e_2}$，回归到题目所给的式子：

> $$\begin{matrix}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{matrix}$$

我们会发现这里实际上可以进行一个替换，也就是说我们可以在模 $N$ 的意义下把 $m^{e_1}$ 和 $m^{e_2}$ 用 $c_1$ 和 $c_2$ 替换，得到了一个式子如下：
：

$$m \equiv c_1^sc_2^t \pmod N$$

## 求解方法

对于题解开头的那个式子，我们可以很轻松地使用 $\rm Exgcd$ 求得 $s,t$ 的值，而现在的问题仅仅存在于答案的计算。我们很自然的会想到这是一个使用快速幂的好机会，但是我们不能想到一件事：如果 $s,t<0$ 怎么办？

其实还真的不难处理，我们只需要将 $s=-1\times -s$ 就行了，如果把它放在原来的式子当中（在模 $N$ 意义下讨论），就可以得到 $c^{-1}\times c^{-s}$。此时后半部分由于 $s$ 是负数，指数就是正数可以用快速幂计算，而前半部分只要在模 $N$ 意义下求取逆元即可，但是因为不可抗力不能使用 Fermat Little Theorem，于是你可以使用 Exgcd 求解。

记得要开 `long long`，并且有些点爆了还得单独特殊处理，由于处理不善，所以龟速乘部分采自神 GoPoux4
 的代码，其余部分按照文章推导进行处理即可，具体见代码。

## 代码实现

```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
int c1,c2,e1,e2,N,T;
int gsc(int a,int b){
	int ans=0;
	while(b>0){
		if(b&1) ans=(ans+a)%N;
		a=(a+a)%N;
		b>>=1;
	}return ans;
}int ksm(int a,int b){
	int ans=1;
	a%=N;
	while(b>0){
		if(b&1)ans=gsc(ans,a);
		a=gsc(a,a);
		b>>=1;
	}return ans%N;
}int exgcd(int a,int b,int &x,int &y){
	if(!b) {x=1,y=0;return a;}
	int k=exgcd(b,a%b,x,y);
	int z=x;x=y,y=z-a/b*y;
	return k;
}int inv(int a,int b){
	int x,y;
	int g=exgcd(a,b,x,y);
	return g==1?(x%b+b)%b:-1;
}signed main(){
	cin>>T;
	while(T--){
		cin>>c1>>c2>>e1>>e2>>N; 
		int s,t,g=exgcd(e1,e2,s,t);
		if(s<0)c1=inv(c1,N),s=-s;
		if(t<0)c2=inv(c2,N),t=-t;
		cout<<gsc(ksm(c1,s),ksm(c2,t))<<endl;
	}return 0;
}
```

---

## 作者：GoPoux4 (赞：8)

校内测试考了这道题，当时按照题目背景瞎搞了搞，把样例水过了，结果爆零/kk

开始还以为正解要从题目背景中推出来，搞了一个多小时。考完发现背景和题目没什么关系啊！~~再也不看题目背景了~~

---

首先题面用粗体强调了：**$e_1$ 与 $e_2$ 互素**。也就是说,有整数 $s,t$，满足：

$$s*e_1+t*e_2= {\rm{gcd}}(e_1,e_2)=1$$

突破口一定是这个式子。

再看题目中 $m$ 是以 $m^{e_1},m^{e_2}$ 出现的，上面的那个式子可能要放到指数上。

这个 $"1"$ 就很巧妙啊，可以代换到很多地方，比如代进指数的位子上去，并不影响原值。

则答案

$$m \equiv m^1 \equiv m^{s*e_1+t*e_2} \ ({\rm {mod}} \ N)$$

这个式子又可以写成：

$$m \equiv (m^{e_1})^s(m^{e_2})^t \ ({\rm {mod}} \ N)$$

把题中所给的 $c_1,c_2$ 代入得：

$$m \equiv c_1^sc_2^t \ ({\rm {mod}} \ N)$$

$s,t$显然可以用扩展欧几里得算法求得，所以答案即为 $c_1^sc_2^t \ {\rm {mod}} \ N$。

极大数求幂显然要用到快速，所以幂取模，而 $s,t$ **可能为负数**，快速幂就没法求了。所以我们需要把指数转变为正数求解。

运用所学~~初中~~知识：

$$c^x=(c^{-1})^{-x}$$

使用扩展欧几里得算法求解逆元即可。

---

另外，快速幂和计算 $c_1^sc_2^t$ 时要用龟速乘，否则第二个点爆 long long

---

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define lxl long long
#define debug(x) printf("debug : %lld\n", x)
using namespace std;

inline lxl fti(lxl a,lxl b,lxl p)
{
	lxl ans=0;
	while(b>0)
	{
		if(b&1) ans=(ans+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return ans;
}

inline lxl fmi(lxl a,lxl b,lxl p)
{
	lxl ans=1;
	a%=p;
	while(b>0)
	{
		if(b&1) ans=fti(ans,a,p);
		a=fti(a,a,p);
		b>>=1;
	}
	return ans%p;
}

inline lxl exgcd(lxl a,lxl b,lxl &x,lxl &y)
{
	if(!b) {x=1,y=0;return a;}
	lxl k=exgcd(b,a%b,x,y);
	lxl z=x;x=y,y=z-a/b*y;
	return k;
}

inline lxl inv(lxl a,lxl b)
{
	lxl x,y;
	lxl g=exgcd(a,b,x,y);
	return g==1?(x%b+b)%b:-1;
}

lxl c1,c2,e1,e2,N;

int main()
{
	//freopen("P5451.in","r",stdin);
	int t;scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%lld%lld%lld%lld",&c1,&c2,&e1,&e2,&N);
		lxl s,t,g=exgcd(e1,e2,s,t);
		if(s<0) c1=inv(c1,N),s=-s;
		if(t<0) c2=inv(c2,N),t=-t;
		printf("%lld\n",fti(fmi(c1,s,N),fmi(c2,t,N),N));
	}
	return 0;
}
```


---

## 作者：lemir3 (赞：6)

## 题目分析

今天上午考了这道题,然而我校oj并没有把题目背景和题目描述分开(口吐芬芳),我以为是连在一起的,按照背景推了个同余方程,然后和题目描述里的方程联立求出了m,不但过了样例,回带入加密过程还都是对的,于是直接爆零...

重新来看,发现题目中e1和e2互素,于是有:

>$p*e_1+q*e_2 =1 $

根据扩展欧几里得定理,以上不定方程一定有解,而且容易看出p和q一定为一正一负,这里取q为负.

然后我们有:

> $m \equiv m^1 \equiv m^{p*e_1+q*e_2} (mod ~ N)$

又因为有:

> $m^{e_1} ~ mod ~ N = c_1$
>
> $m^{e_2} ~ mod ~ N = c_2$

所以原式变为:

> $m \equiv c_1^pc_2^q ~ (mod ~ N)$

p和q前面已经通过exgcd求出,不过需要注意的是q为负数,没法计算.

考虑转化一下,因为是在模N的意义下,很明显有:

> $(c_2^{-1})^{-q}=c_2^q ~ (mod ~ N)$

所以求出c2的逆元就可以计算了.

提醒一下快速幂里打龟速乘,不然第二个点爆long long.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cmath"
#include "cctype"
#include "iomanip"
#include "algorithm"
#include "time.h"
#include "set"
#include "queue"
#include "map"
#include "stack"
#include "vector"
#include "deque"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
lxl T,c1,c2,e1,e2,n;
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
lxl exGCD(lxl a,lxl b,lxl &x,lxl &y)
{
	if(!b){x=1,y=0;return a;}
	lxl tmp=exGCD(b,a%b,x,y),t=x;
	x=y,y=t-a/b*y;
	return tmp;
}
inline lxl FastMul(lxl a,lxl b,lxl mod)
{
	lxl sum=0;
	for(;b;b>>=1,a=(a+a)%mod)(b&1)&&(sum=(sum+a)%mod);
	return sum;
}
inline lxl FastPow(lxl a,lxl b,lxl mod)
{
	lxl sum=1;
	for(;b;b>>=1,a=FastMul(a,a,mod))(b&1)&&(sum=FastMul(sum,a,mod));
	return sum;
}
int main(void)
{
	T=read();
	while(T--)
	{
		c1=read(),c2=read(),e1=read(),e2=read(),n=read();
		lxl p,q;
		exGCD(e1,e2,p,q);
		p%=e2,q%=e1;
		while(p<0)p+=e2;
		while(q>0)q-=e1;
		lxl inv,y;
		exGCD(c2,n,inv,y);
		inv=(inv%n+n)%n;
		q*=-1;
		printf("%lld\n",FastMul(FastPow(c1,p,n),FastPow(inv,q,n),n));
	}
	return 0;
}
```

---

## 作者：dottle (赞：4)

update:修了下括号

---
题中给出了$m^{e1}$与$m^{e2}$的值，我们可以轻易求出$m^{e1-e2}$的值，即
$$m^{e1-e2}=m^{e1}/m^{e2}$$
更进一步地，有
$$m^{e1\%e2}=m^{e1}/(m^{e2})^{\lfloor e1/e2 \rfloor}$$
从而，与求gcd结构类似地，我们可以通过辗转相除法求出$m^1$，即$m$。因为$e1,e2$互质，他们的gcd为$1$，故我们最终求出的$m$的指数为$1$

对于同余除法，求出其逆元再相乘即可。

此题范围达到了$2^{64}$，需要使用龟速乘。还有几个细节我将在注释中说明。

---

```cpp
#include<bits/stdc++.h>
#define int long long
#define U unsigned
using namespace std;
int a,b,x,y,c1,c2,e1,e2,mod,inv,t,o,c3,n=1;
void exgcd(int &x,int &y,int a,int b){
	if(!b){
		x=1,y=0;
	}
	else{
		int p,q;
		exgcd(q,p,b,a%b);
		x=p,y=q-a/b*p;
	}
}//使用exgcd求逆元存在负数，不可使用unsigned

U int smul(int x,int y){
	U int ans=0,a=(U int)x,b=(U int)y;
	while(b){
		if(b&1)ans=(ans+a)%mod;
		b>>=1,a=(a+a)%mod;
	}
	return ans;
}//龟速乘中加法也会超出longlong范围，使用unsigend

int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=smul(ans,a);
		b>>=1,a=smul(a,a);
	}
	return ans;
}


signed main(){
	cin>>n;
	while(n--){
		cin>>c1>>c2>>e1>>e2>>mod;
		if(e1<e2)swap(e1,e2),swap(c1,c2);
		while(e2!=1){
			exgcd(x,y,c2,mod),t=e1/e2,o=e1%e2;
			x=(x%mod+mod)%mod;//x为e2逆元，所以除以e2等同于乘x
			c3=smul(c1,qpow(x,t))%mod;//快速幂防超时
			c1=c2,c2=c3,e1=e2,e2=o;
		}
		cout<<c2<<endl;
	}
	return 0;
}
```
该算法的复杂度上限为$log^3n$（即辗转相除，快速幂幂和龟速乘复杂度相乘）。跑不满，因为当辗转相除复杂度增加时，快速幂复杂度会下去；并且实际上辗转相除的复杂度是达不到log的。所以正常的复杂度是低于$log^2n$的，可以通过此题。




---

## 作者：ForgetOIDuck (赞：1)

### 题意

给定 $c_1,c_2,e_1,e_2,N$，满足
$$
c_1\equiv m^{e_1}\pmod N\\

c_2\equiv m^{e_2}\pmod N\\
$$
且 $(e_1,e_2)=1$，$N$ 有且只有两个质因子，求 $m$。

### 思路

也就是说我们要用 $m^{e_1}$ 和 $m^{e_2}$ 凑出 $m^1$。

看到 $(e_1,e_2)=1$ 这个性质，所以我们可以求出一个方程 $e_1k_1+e_2k_2=1$ 的整数解 $k_1,k_2$，这样就可以用 $s_1^{k_1}\times s_2^{k_2}$ 凑出 $m^1$。这可以用扩展欧几里得算法求出。

然而我们发现 $k_1$ 与 $k_2$ 可能有一个为负数，假设 $k_1$ 为负数。那么我们需要求出 $s^{-1 \times |k_1|}$ 即 $(s^{|k_1|})^{-1}$，也就是 $s^{|k_1|}$ 在模 $N$ 意义下的逆元。

但是 $N$ 并不为质数，若使用欧拉定理的话需要找到其质因数会爆炸，所以我们再次使用扩展欧几里得算法：

发现 $(s^{|k_1|})^{-1}\times s^{|k_1|}\equiv 1\pmod N$，于是有 $s^{|k_1|}\times(s^{|k_1|})^{-1}+N\times b=1 $，可以求出一组整数解 $(s^{|k_1|})^{-1}, b$。注意此时求出的逆元并不一定是正整数，注意取模。

你也许需要使用 `__int128` 或者龟速乘。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
ll s1, s2, k1, k2, c, T, p[100002], len, m;
bitset<10000002> f;
ll qmi(ll x, ll y, ll z) {
	x %= z;
	ll res = 1 % z;
	while (y) res = res * (y & 1 ? x : 1) % z, x = x * x % z, y >>= 1;
	return res;
}
ll exgcd(ll a, ll b, ll &x, ll &y) {
	if (b == 0) return x = 1, y = 0, a;
	ll d = exgcd(b, a % b, x, y), z = x;
	x = y, y = z - y * (a / b);
	return d;
}
int main() {
    long long tt;
    cin >> tt, T = tt;
	while (T -- ) {
        cin >> tt, s1 = tt;
        cin >> tt, s2 = tt;
        cin >> tt, k1 = tt;
        cin >> tt, k2 = tt;
        cin >> tt, c = tt;
		ll c1, c2, t;
		exgcd(k1, k2, c1, c2);
		if (c1 < 0) {
			c1 = -c1;
			s1 = qmi(s1, c1, c);
			exgcd(s1, c, s1, t);
			s1 = (s1 % c + c) % c;
		}
		else s1 = qmi(s1, c1, c);
		if (c2 < 0) {
			c2 = -c2;
			s2 = qmi(s2, c2, c);
			exgcd(s2, c, s2, t);
			s2 = (s2 % c + c) % c;
		}
		else s2 = qmi(s2, c2, c);
        tt = s1 * s2 % c;
		cout << tt << "\n";
	}
}
```

---

## 作者：peterwuyihong (赞：1)

题意：给定满足 $c_1=m^{e_1}\bmod N,c_2=m^{e_2}\bmod N$ 的 $c_1,c_2,e_1,e_2,N$，反过来求解 $m$，保证 $\gcd(e_1,e_2)=1$。

多测 $10000$ 组，$2^8<N<2^{63}$。

这个互质就很灵性，所以假设有 $xe_1+ye_2=1$

那么 $m^{xe_1+ye_2}=c_1^xc_2^y$，然后 $x,y\in \mathbb{Z}$，用模数不是质数的 Exgcd 求逆元即可。

现在是 $8:14$，我开始写这个题

现在是 $8:25$，我写完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=(k);i++)
#define per(i,j,k) for(int i=j;i>=(k);i--)
#define all(x) x.begin(),x.end()
using i64 = long long;
using i128 = __int128;
i128 exgcd(i128 a,i128 b,i128&x,i128&y){
  if(!b){
    x=1,y=0;
    return a;
  }
  int d=exgcd(b,a%b,y,x);
  y-=a/b*x;
  return d;
}
i128 inv(i128 a,i128 p){
  i128 x,y;
  exgcd(a,p,x,y);
  x=(x+p)%p;
  return x;
}
void solve(){
  i128 c1,c2,e1,e2,N;
  i64 g;
  cin>>g;c1=g;
  cin>>g;c2=g;
  cin>>g;e1=g;
  cin>>g;e2=g;
  cin>>g;N=g;
  i128 x,y;
  exgcd(e1,e2,x,y);
  auto ksm=[&](i128 a,i128 b,i128 p){
    i128 ans=1;
    for(;b;b>>=1,a=a*a%p)
    if(b&1)ans=ans*a%p;
    return ans;
  };
  if(x<0)x=-x,c1=inv(c1,N);
  if(y<0)y=-y,c2=inv(c2,N);
  cout<<(i64)(ksm(c1,x,N)*ksm(c2,y,N)%N)<<endl;
}
signed main(){
  ios::sync_with_stdio(NULL);
  int T;cin>>T;
  while(T--)solve();
}
```

---

## 作者：koreyoshi_lemon (赞：1)

### 绝对是本题保姆级教学


------------

先简述下题意：

$1.$ $c_1\equiv m^{e_1}\pmod{N}$

$2.$ $c_2\equiv m^{e_2}\pmod{N}$

$3.$ $\gcd(e1,e2)=1$

已知 $c_1,c_2,e_1,e_2,N$，求 $m$。

------------

首先，根据 [裴蜀定理](https://www.luogu.com.cn/problem/P4549) 可知：

不定方程 $ax+by=c$ 有整数解，当且仅当 $\gcd(a,b)\mid c$。

我们不禁要考虑，是不是可以把 $1$ 当作 $c$，利用 $\gcd(e_1,e_2)=1$ 的条件？

于是，我们迈出了第一步：构造方程。

$s \cdot e_1+t \cdot e_2 = 1$

显然可以用**扩欧**来求出 $s$ 与  $t$。

不知道扩欧的小伙伴可以戳 [这里](https://www.luogu.com.cn/problem/P5656)。



------------
继续思考，如何利用求出的 $s$ 与 $t$。

回归原始，发现原式中 $e_1,e_2$ 均出现在指数的位置。那我们就把 $s,t$ 放在指数的位置咯。

$ m^{s \cdot e_1}=c_1^s $ 

$ m^{t \cdot e_2}=c_1^t $

如何出现 $s\cdot e_1+t\cdot e_2$ 呢？两式相乘即可。

$m^{s\cdot e_1+t\cdot e_2}=m=c_1^s\cdot c_2^t$



------------

终于到了最后一个点：

按照扩欧来求解时，$s$ 和 $t$ 可能是负数。

其实只要把 $c_1,c_2$ 转化为分别转化为其**乘法逆元**即可。

但是 $N$ 的范围好像有点不对劲，而且没有说是质数，费马小定理貌似用不了，欧拉函数又算不出来，那该咋办嘞？？其实扩欧同样可以求解逆元。回归逆元的本质：

$a x\equiv 1\pmod{N}$

$a  x=1+kN$

$ax-kN=1$

这不就是 Exgcd 模板吗？ 如果还是不懂，可以戳 [这里](https://www.luogu.com.cn/problem/P1082)。

别跟我说快速幂没学过，算了算了，还是 [放一下吧](https://www.luogu.com.cn/problem/P1226)。



------------

本来以为 __int128 可以水一水，但不知道为啥 WA 了。

~~可能是我太菜了，只能龟速乘，硬生生添一个 log.。。~~

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int c1,c2,e1,e2,n,T;
int exgcd(int& x,int& y,int a,int b)
{
	if(!b)	{
		x=1,y=0;
		return a;
	}
	int d=exgcd(x,y,b,a%b);
	int z=x;x=y;y=z-(a/b)*y;
	return d;
}
inline int inv(int x)	{
	int t1=0,t2=0;
	exgcd(t1,t2,x,n);
	return (t1%n+n)%n;
}
inline int mul(int a,int t)	{
	int ans=0;
	while(t)	{
		if(t&1) ans+=a,ans%=n;
		a<<=1,a%=n;
		t>>=1;
	}
	return ans%n;
}
inline int Qpow(int a,int t)	{
	int ans=1;
	while(t)	{
		if(t&1) ans=mul(ans,a);
		a=mul(a,a);
		t>>=1;
	}
	return ans%n;
}
signed main(void)
{
	scanf("%lld",&T);
	while(T--)	{
		scanf("%lld%lld",&c1,&c2);
		scanf("%lld%lld%lld",&e1,&e2,&n);
		int x=0,y=0;
		exgcd(x,y,e1,e2);
		if(x<0)
			x=-x,c1=inv(c1);
		if(y<0)
			y=-y,c2=inv(c2);
		printf("%lld\n",mul(Qpow(c1,x),Qpow(c2,y))%n);
	}
	return 0;
}
```



---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

现已知 $c_1\equiv m^{e_1}\pmod N,c_2\equiv m^{e_2}\pmod N$，对于给定 $c_1,c_2,e_1,e_2,N$，求 $m$。

### 2. 思路

注意到题目中有 $\gcd(e_1,e_2)=1$，于是自然想到裴蜀定理，因而应有 $a$，$b$ 使得 $a\times e_1+b\times e_2=\gcd(e_1,e_2)=1$。

而题目中给出 $c_1\equiv m^{e_1}\pmod N,c_2\equiv m^{e_2}\pmod N$。

不难联想到 $a^n\times a^m=a^{n+m},(a^n)^m=a^{n\times m}$。

因而有 $c_1^a\equiv m^{a\times e_1}\pmod N,c_2^b\equiv m^{b\times e_2}\pmod N$。

两式相乘有 $c_1^ac_2^b\equiv m^{a\times e_1+b\times e_2}\equiv m\pmod N$。

因而我们可以使用扩欧求出 $a$，$b$ 然后使用快速幂求出 $m$。

问题又来了：如果 $a$ 或 $b$ 为偶数怎么办？

可以发现 $e_1^a=e_1^{-1}\times e_1^{-a}$，此时 $-a>0$，则可以使用快速幂，而 $e_1^{-1}$ 可以使用扩欧求逆元。

另外记得使用龟速乘不然第二个点会爆。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int c1,c2,e1,e2,N,T;
int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	else{
		int ans=exgcd(b,a%b,x,y);
		int z=x;
		x=y,y=z-a/b*y;
		return ans;
	}
}
int inv(int a,int b){
	int x,y,p=exgcd(a,b,x,y);
	if(p==1){
		return(x%b+b)%b;
	}
	else{
		return -1;
	}
}
int smul(int a,int b){
	int ans=0;
	a%=N;
	while(b){
		if(b&1) ans=(ans+a)%N;
		a=(a+a)%N;
		b>>=1;
	}
	return ans;
}
int qpow(int a,int b){
	int ans=1;
	a%=N;
	while(b){
		if(b&1){
			ans=smul(ans,a)%N;
		}
		a=smul(a,a)%N;
		b>>=1;
	}
	return ans;
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld%lld%lld",&c1,&c2,&e1,&e2,&N);
		int x,y,p=exgcd(e1,e2,x,y);
		if(x<0){
			c1=inv(c1,N),x*=-1;
		}
		if(y<0){
			c2=inv(c2,N),y*=-1;
		}
		printf("%lld\n",smul(qpow(c1,x),qpow(c2,y))%N);
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：0)

## 思路

观察题目，题目特地加粗了 $e_1,e_2$ 互质。这意味着一定存在一组 $s,t$，使得 $se_1+te_2=1$。那么 $m\equiv m^1\equiv m^{se_1+te_2}\pmod N$，可以进一步变为 $m\equiv m^{se_1}\times m^{te_2}\equiv c_1^s\times c_2^t\pmod N$。

而 $s,t$ 不一定是正数，得先进行一步转化，例如 $c_1^s=c_1^{-1}\times c_1^{-s}$，先把 $c_1$ 的逆元求出来，后面指数就可以转正了。

还有一个问题，直接用快速幂第二个点会爆，要使用龟速乘。

## 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,ca,cb,ea,eb,n,x,y;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void exgcd(int a,int b){
	if(!b){
		x=1;y=0;return;
	}
	exgcd(b,a%b);
	int t=x;
	x=y;
	y=t-(a/b)*y;
}
int inv(int a,int b){
	x=0;y=0;
	if(__gcd(a,b)!=1)return -1;
	exgcd(a,b);
	return (x%b+b)%b;
}
int mul(int a,int b){
	int ans=0;
	while(b){
		if(b&1)ans+=a,ans%=n;
		a=a+a;a%=n;
		b>>=1;
	}
	return ans;
}
int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=mul(ans,a);
		a=mul(a,a);
		b>>=1;
	}
	return ans;
}
signed main(){
	//freopen("std.in","r",stdin);
	T=read();
	while(T--){
		ca=read();cb=read();ea=read();eb=read();n=read();
		//m=(c1)^x*(c2)^y
		x=0;y=0;
		exgcd(ea,eb);
		int s=x,t=y;
		//cout<<x<<" "<<y<<endl;
		if(s<0)ca=inv(ca,n),s=-s;
		if(t<0)cb=inv(cb,n),t=-t;
		//cout<<s<<" "<<t<<endl;
		printf("%lld\n",mul(qpow(ca,s),qpow(cb,t))%n);
	}
	return 0;
}


```


---

## 作者：chihik (赞：0)

如果你做过 [P4358 [CQOI2016]密钥破解](https://www.luogu.com.cn/problem/P4358) ，那么你基本上就凉了。

这道题跟背景没有任何关系。

注意到二元不定方程： $xe1+ye2=(e1,e2)=1$

又因为 $m = m^1 = m^{xe1+ye2}= (m^{e1})^x(m^{e2})^y={c_1}^x{c_2}^y$

那么:

$$m\equiv{c_1}^x{c_2}^y \mod N$$

可以用扩欧求出一组特解 $(x',y')$。

当指数小于零时用逆元代替。

```cpp
#include <cstdio>
using namespace std; 
#define LL long long

template<typename _T>
void Read( _T &x ) {
	x = 0; int f = 1;
	char s = getchar( );
	for( ; s < '0' || s > '9' ; s = getchar( ) ) f = s == '-' ? -f : f;
	for( ; s >= '0' && s <= '9' ; s = getchar( ) ) x = x * 10 + s - '0';
	x *= f;
}
template<typename _T>
void Write( _T x ) {
	if( x < 0 ) putchar( '-' ) , x = -x;
	if( x >= 10 ) Write( x / 10 );
	putchar( x % 10 + '0' );
}

LL N , c1 , c2 , e1 , e2;
LL x , y;

LL Exgcd( LL a , LL b , LL &x , LL &y ) {
	if( !b ) {
		x = 1 , y = 0;
		return a;
	}
	LL r = Exgcd( b , a % b , y , x );
	y -= ( a / b ) * x;
	return r; 
} 
LL Inv( LL x , LL p ) {
	LL u , v;
	Exgcd( x , p , u , v );
	return ( u % p + p ) % p;
}
LL Quick_mul( LL x , LL po , LL Mod ) {
	LL Ans = 0;
	for( ; po ; po >>= 1 , x = ( x + x ) % Mod )
		if( po & 1 ) Ans = ( Ans + x ) % Mod;
	return Ans;	
}
LL Quick_pow( LL x , LL po , LL Mod ) {
	if( po < 0 ) x = Inv( x , Mod ) , po = -po;
	
	LL Ans = 1;
	for( ; po ; po >>= 1 , x = Quick_mul( x , x , Mod ) )
		if( po & 1 ) Ans = Quick_mul( Ans , x , Mod );
	return Ans;
}


int main( ) {
//	freopen("D.in","r",stdin);
//	freopen("D.out","w",stdout);

	int t; Read( t );
	while( t -- ) {
		Read( c1 ) , Read( c2 ) , Read( e1 ) , Read( e2 ) , Read( N );
		Exgcd( e1 , e2 , x , y );
		Write( Quick_mul( Quick_pow( c1 , x , N ) , Quick_pow( c2 , y , N ) , N ) ) , putchar('\n');
	}
	return 0;
}
```


---

## 作者：寒冰大大 (赞：0)

大意，给定$c_1,c_2,e_1,e_2,N$求$m$

$c_1,c_2$与$N$互质

$\begin{cases}c_1 \equiv m^{e_1} ~mod~ N \\ c_2 \equiv m^{e_2}~mod~N\end{cases}$

我们现在合并成一个式子

$c_1*c_2\equiv m^{e_1+e_2}~mod~N$

好像并不能发现什么，来试试$c_1,c_2$来个几次方

$c_1^x*c_2^y\equiv m^{xe_1+ye_2}~mod~N$

从互质这个地方出发

$gcd(c1,N)=gcd(c2,N)=1$

一想到互质，就可以来解$xe_1+ye_2=1$这个不定方程

那么就可以求出m了

但是$x,y$不一定都大于1

$c^{-x}=({c^{-1})}^x$

所以我们只需要找到它的模$N$意义下的逆元就行了，由于N不是质数，所以用EXGCD

另外还要注意到N很大，所以要不用龟速乘要不就用高精或者快速模

```cpp
inline ll mul(ll x,ll y,ll p){
  return ((x*y-(ll)(((long double)x*y+0.5)/p)*p)%p+p)%p;
}
```

```cpp
#include<touwenjian.h>

#define int long long

using namespace std;

int x,y,n;
int c1,c2,e1,e2;

int exgcd(int a,int b,int &x,int &y)
{
	if(b==0) 
	{
		x=1,y=0; return a;
	}
	int tmp=exgcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*y;
	return tmp;
}

int gsc(int x,int y,int modp)
{
	int ans=0;
	while(y)
	{
		if(y&1) ans=(ans+x)%modp;
		x=(x+x)%modp;
		y>>=1;
	}
	return ans;
} 

int ksm(int x,int y,int modp)
{
	int ans=1;
	while(y)
	{
		if(y&1) ans=gsc(x,ans,modp);
		x=gsc(x,x,modp);
		y>>=1;
	}
	return ans;
} 

int inv(int x,int modp)
{
	int a,b;
	exgcd(x,modp,a,b);
	return (a+modp)%modp; 
}

signed main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	int t;
	cin>>t;
	while(t--)
	{
		cin>>c1>>c2>>e1>>e2>>n;
		exgcd(e1,e2,x,y);
		if(x<0) x=-x,c1=inv(c1,n);
		if(y<0) y=-y,c2=inv(c2,n);
		cout<<gsc(ksm(c1,x,n),ksm(c2,y,n),n)<<endl;
	}
}

```



---

## 作者：starseven (赞：0)

[题面](https://www.luogu.com.cn/problem/P5451)

现在的题面都很长，可是我们要仔细分析。在考场上一定要想出题人的意图，我们看看题目:


$$ c_1 = m^{e_1}mod N $$

$$ c_2 =m^{e_2}mod N $$

考场上仔细想一想就知道，出题人难道是白痴吗，告诉你

**如果找到可以快速分解大整数的方法，密码安全性就收到威胁**

然后就可以在考场上叫你打一个很多人听都没听过的算法？！QwQ

所以我在考场上思考了一会儿，就注意到上面的东西（我再展示一次）

$$ c_1 = m^{e_1}\mod N $$

$$ c_2 =m^{e_2}\mod N $$


很显然，出题人给了你两个等式，我们的切入点就应该在两个等式的关系上入口。

我们再看题目：

### 设两个用户的公钥分别为e1 和e2，且两者互质。 ##

所以根据我们要（~~四声~~）求的m，我们就会联想到指数，m的指数为1，这个时候学过欧几里得算法的人们就会警惕，诶，我们在学扩展欧几里得的时候不是见到过这个等式吗：

$$ e1\times x +e2\times y=gcd(e1,e2) $$

由于我们校内检测是刚学了数论考的，所以我很容易联想到，但这也是AC这道题的基本素养。

因为两者互质，所以我们明显可以先将两个等式的指数变为只相差一的式子，然后相除（就是逆元）就可以AC了。

对于一些数论还不熟悉的同学（我在很长时间内也是），我现在讲一下为什么可以转化。

自己想：

$$ x\; mod\;N=g$$

那么

$$ x^{n}\;mod\;N=g^{n} $$

这是其一；

然后就是上方展示的扩展欧几里得的公式了

代码如下

```
#include<cstdio>
#include<iostream>
#define ll long long
#define Starseven main
using namespace std;
ll read();
void write(ll);
ll c1,c2,e1,e2,N;

ll Multi(ll a,ll b,ll p){
	ll re=0;
	while(b){
		if(b&1) re=(re+a)%p;
		b>>=1;
		a=(a*2)%p;
	}
	return re%p;
}

ll Get_exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1,y=0;return a;
	}
	ll temp=Get_exgcd(b,a%b,x,y);
	ll t=x;x=y;y=t-a/b*y;
	return temp;
}

ll Power(ll a,ll b,ll p){
	ll re=1;
	while(b){
		if(b&1) re=Multi(re,a,p);
		b>>=1;
		a=Multi(a,a,p);
	}
	return re%p;
}

int Starseven(void){
	int t=read();
	while(t--){
		c1=read(),c2=read(),e1=read(),e2=read(),N=read();
		//cout<<c1<<" "<<c2<<" "<<e1<<" "<<e2<<" "<<N<<endl; 
		ll x,y;
		ll judge=Get_exgcd(e1,e2,x,y); 
		while(x<0){
			x+=e2,y-=e1;
		}
		ll a=Power(c1,x,N),b=Power(c2,-y,N); 
		ll f,g;
		ll hh=Get_exgcd(b,N,f,g);
		ll ans=Multi(f,a,N);
		ans=(ans+N)%N;
		write(ans);
		puts("");
	}
	return 0;
} 

ll read(){
	char ch=getchar();
	ll re=0,op=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') op=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		re=re*10+ch-'0';
		ch=getchar();
	}
	return re*op;
}

void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
	return ;
}
```


---

## 作者：Karry5307 (赞：0)

### 题意

有$T$组数据，对于每组数据，给定$c_1,c_2,e_1,e_2,N$，求出$m$使得

$\begin{cases}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{cases}$

保证$e_1,e_2$互质。

$\texttt{Data Range:}1\leq T\leq 10^4,2^8\leq c_1,c_2,e_1,e_2,N\leq 2^{63}$

### 题解

题目中明确黑体加粗说了$e_1,e_2$互质（我们生物老师说黑体加粗的字一定要好好看！），肯定考虑在这里~~乱搞~~，所以说存在一组$p,q$使得

$e_1p+e_2q\equiv 1\pmod N$

而且，因为$e_1,e_2$为正整数，所以$p,q$一正一负。

所以说对$m$乱搞一下，有

$m\equiv m^1\equiv m^{e_1p+e_2q}\equiv c_1^pc_2^q\pmod N$

$p,q$可以用拓欧求出来。

可是之前说了，$p,q$有一个是负的，所以怎么办呢？

假设$p$是负的，那么

$e_1^p=e_1^{-1\times-p}=(e_1^{-1})^{-p}$

于是这样就可以$\color{#5eb95e}\texttt{AC}$啦qwq

但是，还有一点，就是求逆元的时候不能用费马小定理！会出问题！

### 代码

```cpp#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
typedef __int128 li;
ll test;
ll c1,c2,e1,e2,mod,p,q,r,s,res;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent,ll mod)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%mod;
        }
        base=(li)base*base%mod,exponent>>=1;
    }
    return res;
}
inline void exgcd(ll x,ll y,ll &p,ll &q)
{
    if(!y)
    {
        p=1,q=0;
        return;
    }
    exgcd(y,x%y,q,p),q=q-p*(x/y);
}
int main()
{
    test=read();
    for(register int i=0;i<test;i++)
    {
        c1=read(),c2=read(),e1=read(),e2=read(),mod=read();
        exgcd(e1,e2,p,q);
        if(p<0)
        {
            p=-p,exgcd(c1,mod,r,s);
            c1=(r%mod+mod)%mod;
        }
        if(q<0)
        {
            q=-q,exgcd(c2,mod,r,s);
            c2=(r%mod+mod)%mod;
        }
        res=(li)qpow(c1,p,mod)*qpow(c2,q,mod)%mod;
        printf("%lld\n",res);
    }
}
```

---


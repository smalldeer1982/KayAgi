# [THUPC 2018] 城市地铁规划

## 题目描述

经过选拔，Kiana成为了可乐城的市长，为了兑现选举承诺，她决定在可乐城的 $n$ 个重要地标之间修建地铁。

可乐城的交通状况并不复杂，在任意两个地标之间修建一条地铁轨道都是可行的，但是地铁轨道并不是越多越好，如果有太多地铁从一个地标处经过，该地标的拥堵程度将大幅增加。为此，Kiana决定给每个地标一个便利度来衡量拥堵程度，如果有 $d$ 条地铁轨道经过了某个地标，那么该地标的便利度为 $f(d)\mod 59393$，其中 $f(x)=\sum_{i=0}^{k}a_ix^i$ 是Kiana指定的一个 $k$ 次多项式。

因为修建地铁有一定的成本，所以Kiana希望新建的地铁轨道尽可能少，但任意两座地标之间都需要能通过地铁相互到达。Kiana想知道在给定的条件下，什么样的修建方案可以使得地标的便利度之和最大。由于她不会做，所以希望你来告诉她答案。

## 说明/提示

### 备注

本题因为一些原因只保留了后 $50$ 组数据。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
4 2
0 0 1```

### 输出

```
3 12
1 2
1 3
1 4```

## 样例 #2

### 输入

```
10 9
10 9 8 7 6 5 4 3 2 1```

### 输出

```
9 177454
4 5
4 6
3 4
3 7
2 3
2 8
1 2
1 9
1 10```

# 题解

## 作者：墨舞灵纯 (赞：12)

为什么$prufer$序的好题现存的题解里面没提到$prufer$序的作用啊。。那我来造福社会。。

根据$prufer$序的性质，对于一个度数为 $x$ 的点肯定在$prufer$序中出现了 $x-1$ 次。

考虑 $dp$ 设$f[i]$表示总度数为 $i$ 可以得到的最大价值，则相当于体积为 $x-1$ ，价值为 $d(x)$ 的物品做完全背包。

但是我们考虑体积为 $0$ 的它也有价值，于是考虑先把所有 $0$ 体积的扔进背包里面，然后做的时候替换掉这些体积为 $0$ 的，其实相当于把 $d(x)-d(1)$ 当成新权值来搞就行了。

这个$dp$是$O(n^2)$的。

然后就是输出方案，在$dp$的时候记一下这个方案是由哪个方案转移过来的，然后既然知道每个结点度数那就肯定能根据$prufer$序还原出来原来的树，贪心构树即可，理论上可以做到$O(nlogn)$。

代码也不难写，讲一下实现过程：

1 . 预处理对于每个$x$对应的 $d(x)$ 

2 . $f[0]=n \times d[1]$，表示总度数和为$0$的最大价值

3 . 更新的时候直接用完全背包更新并且记录这个状态是由前面的哪个状态得来的

4 . 从$n-2$开始一个个跳前驱把所有的可能度数记下来并且排序

5 . $dfs$一下$prufer$序构树的过程顺便输出

不贴代码了，看了这个实现过程还不会写的。。~~请D我吧是我讲的不好对不起~~


---

## 作者：ziye (赞：6)

读完题可以发现，所有站点联通且轨道数最小的时候整个图是一棵树，那么边的数量显然是n-1条。每存在一条边便有两个点被经过了一次，故所有点被经过的数量是2n-2。

考虑到图是联通的，所以每个点至少被经过一次。问题就变成了将2n-2个物品放入n个容器中，每个容器至少放一个且每个容器的权值和里面的物品数量有关，求权值之和最大的方案。使用背包dp可以以n^2的时间求出。

难点在于如何将每个点被经过的次数转换为图。使用prufer序可以以nlogn的时间完成，但是由于dp已经使用了n^2的时间，使用prufer序意义不大
~~其实是我太弱了不会~~。

考虑枚举每条边的端点，每次将其连边并将经过次数-1。但是这样操作可能会导致最终图变为森林，所以我们随便选一个点为根，记录一下枚举的点与根的联通性，这样就可以保证最终图是一颗树。最终时间复杂度为O(n^2)。

代码：
```
#include<stdio.h>
#include<algorithm>
#define mo 59393
#define int long long
using namespace std;
int n,k,A[123465],f[1203456],ff[3005],ru[3005],cnt,rd[3005],cc,mk[3005];
struct node{
	int x,y;
}ans[123456];
int max(int a,int b){
	return a>b?a:b;
}
bool cmp(int a,int b){
	return a>b;
}
main(){
	scanf("%lld%lld",&n,&k);
	for(int i=0;i<=k;i++){
		scanf("%lld",&A[i]);
	}
	if(n==1){
		printf("0 %lld",A[0]);return 0;
	}
	for(int i=0;i<=300000;i++){
		int a=1;
		for(int j=0;j<=k;j++){
			f[i]=(f[i]+a*A[j]%mo)%mo;
			a=a*i%mo;
		}
	}
	for(int i=1;i<=n-2;i++){
		for(int j=0;j<i;j++){
			if(ff[i]<ff[j]+f[i-j+1]-f[1]){
				ff[i]=ff[j]+f[i-j+1]-f[1];
				ru[i]=j;
			}
		}
	}
	printf("%lld %lld\n",n-1,ff[n-2]+n*f[1]);
	int it=n-2,kk=0;
	//rd[++kk]=n-2-ru[n-2];
	while(it){
		rd[++kk]=it-ru[it];
		it=ru[it];
	}
	//sort(rd+1,rd+1+n,cmp);
	//for(int i=1;i<=n;i++)printf("%d\n",rd[i]);
	mk[1]=1;
	for(int i=1;i<=n;i++){
		if(!mk[i]){
			for(int j=1;j<=n;j++){
				if(mk[j]&&rd[j]>=0&&rd[i]>=0){
					ans[++cc].x=i;ans[cc].y=j;
					rd[i]--;rd[j]--;mk[i]=1;
					break;
				}
			}
		}
		for(int j=1;j<=n;j++){
			if(i==j||rd[i]<0||rd[j]<0||mk[j])continue;
			ans[++cc].x=i;ans[cc].y=j;
			rd[i]--;rd[j]--;mk[j]=1;
		}
	}
	for(int i=1;i<=cc;i++){
		printf("%lld %lld\n",ans[i].x,ans[i].y);
	}
}
```

---

## 作者：PNNNN (赞：3)

### 思路：

#### step 1.
> 因为修建地铁有一定的成本，所以Kiana希望新建的地铁轨道尽可能少，但任意两座地标之间都需要能通过地铁相互到达。 

看到这句话，我们就可以知道，这是让我们建一棵树。

#### step 2.
> Kiana想知道在给定的条件下，什么样的修建方案可以使得地标的便利度之和最大。

再看到这句话，我们就可以知道，这是让我们分配每个地标经过的地铁轨道数，也就是树上每个点的度数（记点 $i$ 的度数为 $in_i$），使得 $\sum_{i=1}^n [f(in_i) \bmod 59393]$ 最大，且 $\sum_{i=1}^n in_i=2\times(n-1)$。看到这种问题，我们第一时间想到背包，而这道题显然为完全背包，此时分配度数就转化为在 $1,2,\dots,n-1$ 这 $n-1$ 个盒子里放入 $2\times(n-1)$ 个物品。同时，我们还要记录每个 $dp_{i\in[0,2\times(n-1)]}$ 是从哪个状态转移过来的，便于我们后面得知我们选择了哪些度数（记为 $pre_i$）。然后我们就写出了我们背包的第一份代码：
```cpp
for(int i=1;i<=n-1;i++){
	for(int j=i;j<=2*(n-1);j++){
		if(dp[j-i]+f(i)>dp[j]){
			dp[j]=dp[j-i]+f(i),pre[j]=j-i;
		}
	}
}
```
但是一测样例发现，诶，怎么不对？输出选择的度数后会发现，有些度数为 $0$！怎么办，那我们应该先将每个点的度数先设为 $1$，并将 $dp_i$ 重新定义为在每个点的度数都先设为 $1$ 后，再增加 $i$ 个度数的 $\sum_{i=1}^n [f(in_i) \bmod 59393]$ 最大值？

因此，我们在错误的代码上，先将 $dp_0$ 初始化为 $n\times f(1)$，因为每个点一开始度数都为 $1$；外层循环要改成
```for(int i=1;i<=n-2;i++)```，因为每个点的度数最多再增加 $n-2$；内层循环要改成```for(int j=i;j<=n-2;j++)```，因为每个点的度数都已经为 $1$ 了，要在原度数和上再减去 $n$；最后，```dp[j-i]+f(i)```要改为```dp[j-i]+f(i+1)-f(1)```，因为此时 $i+1$ 才是真正的度数，且我们一开始就将 $dp_0$ 初始化成了 $n\times f(1)$，真正的贡献是 $f(i+1)$ 还要再减去 $f(1)$。随后，我们便得到了我们的正常背包代码：
```cpp
dp[0]=n*f(1);
for(int i=1;i<=n-2;i++){
	for(int j=i;j<=n-2;j++){
		if(dp[j-i]+f(i+1)-f(1)>dp[j]){
			dp[j]=dp[j-i]+f(i+1)-f(1),pre[j]=j-i;
		}
	}
}
```


1.那这样是否没考虑到将一个度数 $1+x$ 变为 $1+x+y$ 的情况？此时的效果等同外层循环在循环到 $i=x+y$ 时，因此不会。

2.那会不会出现在算贡献时多减了几个 $f(1)$ 的情况？可知，我们最多减去 $(n-2)/1=n-2$ 个 $f(1)$，而我们初始化了 $n$ 个 $f(1)$，因此不会。

#### step 3.
在分配完度数之后，我们该如何建树？这里引入 Prufer 序列，它能在知道了度数的分配且不在乎编号和顺序的情况下建出一棵树。这里我们只需要构造一个满足我们度数分配的 Prufer 序列(什么顺序都行)，并转化成树即可。（不会 Prufer 序列的点[这里](https://www.luogu.com.cn/problem/P6086)。）

#### 关于pre
我们设一个变量 $tmp=n-2$，此时 $tmp-pre_{tmp}$ 就为从 $dp_{pre_{tmp}}$ 转移到 $dp_{tmp}$ 时增加的度数。再重复执行 $tmp=pre_{tmp}$ 和上句话操作即可得到每一次增加的度数。（因为 $pre_0=0$，所以即使不特判也没事，喜）。

#### 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int mod=59393;

int n,k,A[15],dp[3005],pre[3005],p[3005],in[3005],tot,len;

inline int f(int x){
	int base=1,res=0;
	for(int i=0;i<=k;i++){
		res=(res+A[i]*base%mod)%mod;
		base=base*x%mod;
	}return res;
}

inline void to_tree(){
	int now,cur;
	for(int i=1;i<=n;i++){
		if(in[i]==1){cur=i;break;}
	}now=cur;
	for(int i=1;i<=n-2;i++){
		cout<<p[i]<<' '<<now<<'\n';
		in[p[i]]--,in[now]--;
		if(in[p[i]]==1&&p[i]<cur){
			now=p[i];continue;
		}while(in[cur]!=1)cur++;
		now=cur;
	}cout<<now<<' '<<n;return;
}

inline int read(){
	register int x(0),t(0);
	static char ch=getchar();
	while(!isdigit(ch)){t|=(ch=='-'),ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48),ch=getchar();}
	return t?-x:x;
}

signed main(){
	n=read(),k=read();
	for(int i=0;i<=k;i++){
		A[i]=read();
	}dp[0]=n*f(1);
	for(int i=1;i<=n-2;i++){
		for(int j=i;j<=n-2;j++){
			if(dp[j-i]+f(i+1)-f(1)>dp[j]){
				dp[j]=dp[j-i]+f(i+1)-f(1),pre[j]=j-i;
			}
		}
	}cout<<n-1<<' '<<dp[tot=n-2]<<'\n';
	for(int i=1;i<=n;i++){
		in[i]=1;
		for(int j=1;j<=tot-pre[tot];j++){
			p[++len]=i,in[i]++;
		}tot=pre[tot];
	}to_tree();
	return 0;
}
```

完结撒花！

---

## 作者：比利♂海灵顿 (赞：2)

# THUPC2018 城市地铁规划

本题解和别的题解有两个不同。一个是 DP 采用了决策单调性，复杂度 $O(n^2\ln n)$，劣于别人的 $O(n^2)$。另一个是根据度数构造树采用 `set`，$O(n \log n)$，也劣于别人的 $O(n)$，但是能过。

[传送门](https://loj.ac/p/6395)

## 题目大意

> 便于写代码，记号有改动。

给 $n$ 个点，每个点 $i$ 的权值和它的度 $De_i$ 有关，为 $\sum_{j = 0}^{m}a_j{De_i}^j \pmod{59393}$。我们需要给这些点之间连尽可能少的边，使整个图连通，并且使所有点权和尽可能大。

## 题目分析

显然这个题需要连 $n - 1$ 条边，连成一棵树。每连一条边，都可以给点的度数总和增加 $2$，树有 $n - 1$ 条边, 所以总度数是 $2(n - 1)$。首先所有点的度数至少是 $1$，这样我们需要把 $n - 2$ 个度分给 $n$ 个点，然后 DP 求出最大的权值。

## 假设已知度数

假设已经求出了每个点度数大于等于 $1$ 的度数分配。我们一定可以通过下面的方法构造出合法的连边方式。

对于 $n = 1$ 的情况，无需连边，注意特判。对于 $n = 2$ 的情况，直接连接两个点即可得到正确连边构造。

主要考虑 $n > 2$ 的情况。因为一个合法的分配是 $n$ 个点加 $2n - 2$ 个度，只要 $n > 2$，一定有 $2n - 2 > n$。根据抽屉原理一定存在度数大于 $1$ 的点。然后知道任何情况下 $2n - 2 < 2n$，因此一定存在度数小于 $2$ 的点。规定了分配中每个点度数最小为 $1$，所以也就是度数为 $1$ 的点一定存在。

找出任意度数大于 $1$ 的点 $x$，假设它的度为 $De_x$。那么这个时候任选一个度数为 $1$ 的点和自己相连，两个点就合并成了一个度数为 $De_x - 1$ 的新点。这样就把原问题转化为一个仍然具备上面性质的新的子问题。因为每次 $n$ 都会减少 $1$，所以 $n - 2$ 轮后会得到 $n' = 2$ 的问题，这是问题的边界，只要连接这两个点即可完成构造。

我是用 `set` 查找和维护点和它们的度数，如果得到的度数序列单调 (我们确实实现了所求的度数序列单调)，也可以用双指针实现线性构造。但是因为 DP 的复杂度是瓶颈，所以这个优化无所谓有或没有。

## 求度数

前面没有说如何 DP，设计状态 $f_{i, j}$ 表示决定了 $i$ 个点，可分配的 $n - 2$ 个度已经分配了 $j$ 个，前 $i$ 个点的权值和的最大值。转移就是枚举这个点选多少个度。状态 $O(n^2)$，转移 $O(n)$，复杂度 $O(n^3)$。

$$
f_{i, j} = max_{k = 0}^{j} (f_{i - 1, j - k} + ((\sum_{l = 0}^{m}a_lx^l) \% 59393))
$$

但是每个点本质相同，我们这样会导致重复的情况被考虑。我们强制要求每个点的度数不比上一个点大，也不会漏掉想要的情况，只要记录每个状态的决策 $Ch_{i, j}$，我们就能减少很多的枚举。何况这个题目本来就需要我们记录决策。

## 复杂度分析

经过推导证明，这样的转移复杂度总和应该是 $O(n^2\ln n)$ 的。我每次转移完 $f_{i, j}$，下一次的转移需要枚举的 $k$ 的范围就变成了 $[0, min(Ch_{i, j}, n - 2 - j)]$。

因为规定了决策单调不增，所以对于 $f_{i, j}$ 转移到别的状态的情况，它的决策不会超过 $\frac {j}{i}$。因此需要枚举 $k$ 的数量 $min(Ch_{i, j}, n - 2 - j)$ 也不会超过 $\frac {j}{i}$。对于 $i$ 等于 $0$ 的情况，这个数字是 $n - 2$。所以所有 $O(n^2)$ 的状态的转移总复杂度就是:

$$
\begin{aligned}
& O(n(n - 2) + \sum_{i = 1}^{n}\sum_{j = 0}^{n - 2} \frac{j}{i})\\
=& O(n^2 + \sum_{j = 0}^{n - 2}j\sum_{i = 1}^n\frac 1i)\\
=& O(n^2 + \sum_{j = 0}^{n - 2}\ln n)\\
=& O(n^2 + (n - 2)(n - 1)\ln n)\\
=& O(n^2(1 + \ln n))\\
=& O(n^2\ln n))\\
\end{aligned}
$$

然后看了几篇题解发现这个题就是一个完全背包，直接 $O(n^2)$ 就能做。

## 代码实现

代码省略了缺省源。

```cpp
const unsigned Mod(59393);
unsigned a[15], g[3005], f[3005][3005], Ch[3005][3005], m, n;
unsigned Way[3005];
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
set<pair<unsigned, unsigned> > S;
signed main() {
  n = RD(), m = RD();
  for (unsigned i(0); i <= m; ++i) a[i] = RD();
  for (unsigned i(0); i <= n; ++i) {
    g[i] = 0;
    for (unsigned j(0), k(1); j <= m; ++j) g[i] = (g[i] + k * a[j]) % Mod, k = k * i % Mod;
  }
  if (n == 1) { printf("%u %u\n", 0, g[0]); return 0; }
  Ch[0][0] = n - 2;
  for (unsigned i(0); i < n; ++i)  for (unsigned j(n - 2); ~j; --j) {
    for (unsigned k(0); (k <= Ch[i][j]) && (j + k <= n - 2); ++k) {
      unsigned Des(f[i][j] + g[k + 1]);
      if (f[i + 1][j + k] < Des) f[i + 1][j + k] = Des, Ch[i + 1][j + k] = k;
    }
  }
  for (unsigned i(n), j(n - 2); i; --i) Way[i] = 1 + Ch[i][j], j -= Ch[i][j];
  printf("%u %u\n", n - 1, f[n][n - 2]);
  for (unsigned i(1); i <= n; ++i) S.insert(make_pair(Way[i], i));
  for (unsigned i(1); i < n; ++i) {
    unsigned Nu((S.rbegin())->second), No((S.rbegin())->first);
    S.erase(make_pair(No, Nu));
    unsigned Num((S.begin())->second), Now((S.begin())->first);
    S.erase(S.begin());
    printf("%u %u\n", Num, Nu);
    if (No > 1) S.insert(make_pair(No - 1, Nu));
  }
  return Wild_Donkey;
}
```


---

## 作者：Kun_9 (赞：1)

### prufer 序列 + 完全背包
题意就是求一个 $K_n$ 阶完全图的“最大权生成树”，使用 prufer 序列解决。

考虑到 prufer 序列中**度数等于出现次数 $+1$** 的性质，那么一个节点就可以表示成（prufer 序列中的出现次数，度数）的二元组，这样就有一个完全背包的思路：把 prufer 序列中的出现次数作为重量，便利度作为权值，把上面的每个二元组作为物品做一次完全背包就能求出最大的便利度。

这样做有一个问题，每个节点都必须在生成树中，但是度数为 $1$ 的节点并不会出现在 prufer 序列中，所以先把他们的权值塞进背包里，具体来说就是 dp 的初值要设成 $f(1)\times n$。

最后是输出方案，不少题解中都构建出了 prufer 序列，但是这是不必要的，可以在 dp 的过程中维护出度数序列，最后用两个指针，一个指向在生成树中的节点，另一个指向不在生成树中的节点，每次给两个指针的度数 $-1$ 并加入生成树，如果度数减为 $0$ 就往后跳，这样做复杂度是 $O(n)$ 的，因为指针的跳跃是单调不降的，并且每个节点最多只会被指向两次。

哦对了，还有特判 $n=1$ 和 $n=2$ 的情况，因为这时候建不出 prufer 序列。

```cpp
#include <bits/stdc++.h>

#define AC true
#define int long long
#define dub double
#define mar(x) for(int i = head[x]; i; i = e[i].nxt)
#define car(a) memset(a, 0, sizeof(a))
#define cap(a, b) memcpy(a, b, sizeof(b))
constexpr int inf = 1e9 + 7;
constexpr int MAXN = 5e5;
constexpr dub eps = 1e-5;
constexpr int mod = 59393;

using namespace std;

void cmi(int &x, int y){x > y && (x = y);}
void cmx(int &x, int y){x < y && (x = y);}
inline int read( ){
    int x = 0 ; short w = 0 ; char ch = 0;
    while( !isdigit(ch) ) { w|=ch=='-';ch=getchar();}
    while( isdigit(ch) ) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w ? -x : x;
}
int a[MAXN], dp[MAXN];
int n, k;
int F[MAXN], d[MAXN], vis[MAXN];
int pre[MAXN];
int f(int x){
	if(F[x] != -1) return F[x];
	int res = 0;
	for(int i = k; i >= 0; i--)
		res = (res * x + a[i]) % mod;
	return F[x] = res;
}
signed main( ){
	memset(F, -1, sizeof(F));
	n = read( ); k = read( );
	for(int i = 0; i <= k; i++) a[i] = read( );
	dp[0] = f(1) * n;
	for(int i = 1; i <= n - 2; i++){//出现次数为i，度数为 f(i+1)
		for(int j = i; j <= n - 2; j++){//序列长度为 j
			if(dp[j-i] + f(i + 1) - f(1) > dp[j]){
				dp[j] = dp[j-i] + f(i + 1) - f(1);
				pre[j] = j - i;
			}
		}
	}
	if(n == 1) return printf("0 0\n"), 0;
	if(n == 2) return printf("1 %lld",f(1)*2), 0;
	printf("%lld %lld\n",n-1,dp[n-2]);
	for(int i = 1; i <= n; i++) d[i] = 1;
	int cur = 0;
	for(int i = n - 2; i; i = pre[i]) d[++cur] = i - pre[i] + 1;
	for(int i = cur + 1; i <= n; i++) d[i] = 1;
	int now = 1, ed = 2; vis[1] = 1;
	while(1){
		printf("%lld %lld\n",now, ed);
		d[now]--; d[ed]--;
		vis[now] = vis[ed] = 1;
		while((!d[ed] or vis[ed]) and ed <= n) ed++;
		while((!d[now] or !vis[now]) and now <= n) now++;
		if(now > n or ed > n) break;
	}
	return (0-0);
}
```

---

## 作者：ql12345 (赞：1)

# purfer序列+dp好题

首先看到这题实际上求出每个点度数答案就唯一确定了，而根据度数生成树又提示我们要用purfer序列

确定度数显然可以想一波dp：

$f[i][j]$表示前i个点，总度数为j，最大便利度

转移方程：$f[i][j]=f[i-1][j-k]+g[k]$

目标：$f[n][2n-2]$

这不就是背包！于是时间复杂度可以做到$O(n^2)$，空间复杂度$O(n)$

但是本题还有一个很妙的地方，就是你光这样做是不能保证每个点都有度数的，如果一个点度数为0，那图不连通，不符合题意

所以，为了保证每个点都有度数，我们默认每个点基础度数为1，转移方程中的“度数”为这个点真实度数-1，每个点体积就要-1（因为对于度数为i的点，它在dp中占的体积减小了1，而价值表示的还是真实度数对应的价值）

以上一段在代码中表现为$v[i]=i-1$，目标为$f[n][n-2]$

dp时记录方案（很套路的东西）

最后统计度数，将purfer序列构造出，然后构造出father序列

**注意：**

因为上面我们在dp中将每个点的度数减了1，这里直接算出的每个物品的体积实际上等于这个点在purfer序列中出现的次数，因为点和点都相同，任意匹配度数与点即可

又因为度数之和一个点在purfer序列中出现次数有关，所以造出的purfer序列的顺序也随便

n-1个fa[]，对应输出n-1条边

当然，purfer序列一般都要特判n==1和n==2两种情况

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=59393;
int n,k,a[11],v[3001],w[3001];//init
int f[6001],pre[6001];//dp,makepurfer
int p[3001],fa[3001],d[3001];//purfer2tree
void init(){
	for(int i=0;i<=n;++i) v[i]=i-1;
	for(int i=0;i<=n;++i)
		for(int j=k;j>=0;--j)
			w[i]=(w[i]*i%mod+a[j])%mod;
}
bool tp(){
	if(n==1){
		printf("%d %d",0,w[0]);
		return 1;
	}
	if(n==2){
		printf("%d %d\n1 2",1,w[1]*2);
		return 1;
	}
	return 0;
}
void dp(){
	f[0]=n*w[1];
	for(int i=2;i<=n;++i)
		for(int j=i-1;j<=n-2;++j)
			if(f[j-i+1]+w[i]-w[1]>f[j]){
				f[j]=f[j-i+1]+w[i]-w[1];
				pre[j]=j-i+1;
			}
}
void makepurfer(){
	for(int i=n-2;i;i=pre[i]) d[++d[0]]=i-pre[i];
	for(int i=1,j=1;i<=d[0];++i)
		while(d[i]--)p[j++]=i;//这里有个坑点（与我个人写法有关），就是这里d[i]会最后减为-1（最后一次判断时d[i]已经等于0），所以下面要将d数组清空
}
void purfer2tree(){
	for(int i=1;i<=n;++i) d[i]=0;
	for(int i=1;i<=n-2;++i) ++d[p[i]];
	p[n-1]=n;
	for(int i=1,j=1;i<=n-1;++i,++j){
		while(d[j])++j;
		fa[j]=p[i];
		while(i<n-1&&--d[p[i]]==0&&p[i]<j) ++i,fa[p[i-1]]=p[i];
	}
	printf("%d %d\n",n-1,f[n-2]);
	for(int i=1;i<=n-1;++i) printf("%d %d\n",i,fa[i]);
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=0;i<=k;++i) scanf("%d",a+i);
	init();
	if(tp())return 0;//特判
	dp();
	makepurfer();
	purfer2tree();
	return 0;
}
```

---

## 作者：AKPC (赞：0)

题意：

>知 $f(x)=(\sum_{i=0}^ka_ix^i)\bmod 59393$。  
你需要构造一棵 $n$ 个节点的树，定义每个节点度数为 $d_{1\sim n}$。  
你需要使得你构造的树的 $\sum_{i=1}^nf(d_i)$ 可以达到最大值。  
在求构造方案的同时，你也要求出这个最大值。

那我们首先要求最大值，容易发现，这个最大值仅仅跟节点入度有关，跟树的形态没有大的关系，所以求一下入度即可。

从拆掉 $f$ 函数的角度是不好做的，所以可以从入度的角度入手。

发现入度的性质就是 $\sum_{i=1}^nd_i=2n-2$，而我们要使 $\sum_{i=1}^nf(d_i)$ 最大，这显然是完全背包问题，如果不会请右转疯狂的采药这个板子题。

设定状态，我们令 $dp[i]$ 表示分配了度数和为 $i$ 的最大权值。

因为每个节点最小度数只能是 $1$，所以初始的时候就把所有节点度数设为 $1$，否则可能出现度数为 $0$ 的情况。所以 $dp[i]$ 应为先把所有节点度数设为 $1$ 之后再加上 $i$ 的度数的最大值。

初始化 $dp[0]=f(1)\times n$，因为这个时候所有节点的度数都是只能为 $1$。

容易得到状态转移方程：$dp[i]=\max\{dp[i],dp[i-j]+f(i-j+1)-f(1)\}$，至于为啥有 $-f(1)$，是因为你最初的时候已经把节点度数设为 $1$ 了，所以你要把原定 $f$ 值去掉。

转移的时候，$i$ 从 $1$ 枚举到 $n-2$ 即可（入度最高 $n+n-2$），$j$ 从 $0$ 枚举到 $i-1$（显然）。

分配完度数，可以考虑用 Prüfer 序列构造树了。树只要满足上面的度数分配，可以随意建。

不过你怎么得到这些度数呢？记录一个 $pre$ 数组，令在转移的时候，如果 $dp[i]<dp[i-j]+f(i-j+1)-f[i]$，我们便把 $pre[i]$ 设为 $j$。

设变量 $lst=n-2,now=pre[n-2]$，不断用 $lst-now$ 来得到 $dp[now]$ 到 $dp[lst]$ 的时候增加的度数，然后将 $lst$ 改成 $now$，$now$ 再接着搜到下一个 $pre[now]$ 不断求得这些度数。

然后根据入度，你就可以乱搞 Prüfer 序列了。

[code](/paste/4p0c9672)

---

## 作者：_ZHONGZIJIE0608_ (赞：0)

给定点数 $n$ 与度数和权值的关系，构造一张任意两点可连通的边最少的图使得权值和最大，求边数，最大权值和与一种可能的连边情况。


显然是构造一棵树。树有 $n-1$ 条边，总度数为 $2n-2$。Prufer 序列的长度为 $n-2$，由于权值和点的编号无关，考虑 DP。

令 $f_{i}$ 表示 Prufer 序列中分配完 $i$ 位可获得的最大权值和。由于 Prufer 序列出现次数为度数减 $1$，有状态转移方程：

$$f_{j}=\max({f_{j-i+1}+F(i)-F(1)})$$
$$f_0=n \times F(1)$$

初始值设置是因为 Prufer 序列中有未出现的点，先给一个值，统计到一个就删除一个。

记录每个状态的前驱，构造 Prufer 序列并转化为树即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3010;
const int mod=59393;
int f[N<<1],a[11],n,k,d[N],pre[N];
inline int qpow(int a,int b){
	int s=1;a%=mod;
	while(b){
		if(b&1ll)s=s*a%mod;
		a=a*a%mod;b>>=1ll;
	}
	return s%mod;
}
inline int val(int x){
	int s=0;
	for(int i=0;i<=k;++i)s=(s+(a[i]*qpow(x,i)))%mod; 
	return s%mod;
}
int c[N];
int deg[N],prufer[N],fa[N];
inline void To_Tree(){
	for(int i=1;i<=n;++i)deg[i]=1;
	for(int i=1;i<=n;++i)++deg[prufer[i]];
	int cur;
	for(int i=1;i<=n;++i){if(deg[i]==1){cur=i;break;}}
	int leaf=cur;
	for(int i=1;i<=n-2;++i){
		int f=fa[leaf]=prufer[i];--deg[f];
		if(deg[f]==1&&f<cur){leaf=f;continue;}
		++cur;while(deg[cur]!=1)++cur;leaf=cur;
	}
	fa[leaf]=n;return;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=0;i<=k;++i)cin>>a[i];
	for(int i=1;i<=n;++i)d[i]=val(i);
	f[0]=n*d[1];
	for(int i=2;i<=n;++i)for(int j=i-1;j<=n-2;++j)if(f[j-i+1]+d[i]-d[1]>f[j])f[j]=f[j-i+1]+d[i]-d[1],pre[j]=j-i+1;
	for(int i=n-2;i;i=pre[i])c[++c[0]]=i-pre[i];
	for(int i=1,j=1;i<=c[0];++i)while(c[i]--)prufer[j++]=i;
	To_Tree();
	cout<<n-1<<" "<<f[n-2]<<'\n'; 
	for(int i=1;i<=n;++i)if(fa[i])cout<<i<<" "<<fa[i]<<'\n';
	return 0;
}
```

~~地铁，启动！~~


---

## 作者：wangyibo201026 (赞：0)

## 思路

首先根据 Prufer 序列所有点的总度数是 $2 \times n - 2$，Prufer 序列的长度是 $n - 2$ 的，由于代价与点的编号无关，所以我们可以考虑在这个上面去进行 DP。

$f_i$ 表示我的 Prufer 序列已经被分配完 $i$ 位的最大代价，由于 Prufer 序列出现次数为度数减一，所以状态转移方程如下：

$$f_i = \max(f_j + F(i - j + 1) - F(1))$$
$$f_0 = n \times F(1)$$

为什么要将 $f_0$ 设计为这个值？因为有些点是没有在 Prufer 序列上出现过的，在刚开始全加上，后面出现一个就减掉一个。

然后我们发现可以将点的编号分成一段一段的，然后根据 Prufer 序列重构树就好了。

## 代码

代码：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 2e5 + 5;

int n, m, k, mod, ans = 1;
int fa[N], p[N], d[N], siz[N];
bool vis[N];

int head[N], tot;

struct Graph {
	int to, next;
} edges[N << 1];

void add ( int u, int v ) {
	tot ++;
	edges[tot].to = v;
	edges[tot].next = head[u];
	head[u] = tot;
}

int fast_pow ( int a, int b ) {
	int res = 1ll;
	while ( b ) {
		if ( b & 1 ) {
			res = res * a;
			res %= mod;
		}
		b /= 2ll;
		a = a * a;
		a %= mod;
	}
	return res;
}

void Prufer () {
	int pos;
	for ( int i = 1; i <= n; i ++ ) {
		if ( d[i] == 1 ) {
			pos = i;
			break;
		}
	}
	int leaf = pos;
	for ( int i = 1; i <= n - 2; i ++ ) {
		p[i] = fa[leaf];
		d[fa[leaf]] --;
		if ( d[fa[leaf]] == 1 && fa[leaf] < pos ) {
			leaf = fa[leaf];
			continue;
		}
		pos ++;
		while ( d[pos] != 1 ) {
			pos ++;
		}
		leaf = pos;
	}
}

void unPrufer () {
	int pos;
	for ( int i = 1; i <= n - 2; i ++ ) {
		d[p[i]] ++;
	}
	for ( int i = 1; i <= n; i ++ ) {
		d[i] ++;
	}
	for ( int i = 1; i <= n; i ++ ) {
		if ( d[i] == 1 ) {
			pos = i;
			break;
		}
	}
	int leaf = pos;
	for ( int i = 1; i <= n - 2; i ++ ) {
		fa[leaf] = p[i];
		d[fa[leaf]] --;
		if ( d[fa[leaf]] == 1 && fa[leaf] < pos ) {
			leaf = fa[leaf];
			continue;
		}
		pos ++;
		while ( d[pos] != 1 ) {
			pos ++;
		}
		leaf = pos;
	}
	for ( int i = 1; i < n; i ++ ) {
		if ( !fa[i] ) {
			fa[i] = n;
		}
	}
}

void dfs ( int x ) {
	vis[x] = true;
	siz[k] ++;
	for ( int i = head[x]; i; i = edges[i].next ) {
		if ( !vis[edges[i].to] ) {
			dfs ( edges[i].to );
		}
	}
}

signed main () {
	ios :: sync_with_stdio ( false );
	cin.tie ( 0 ), cout.tie ( 0 );
	cin >> n >> m >> mod;
	for ( int i = 1; i <= m; i ++ ) {
		int u, v;
		cin >> u >> v;
		add ( u, v ), add ( v, u );
	}
	for ( int i = 1; i <= n; i ++ ) {
		if ( !vis[i] ) {
			k ++;
			dfs ( i );
			ans *= siz[k];
			ans %= mod;
		}
	}
	if ( k == 1 ) {
		cout << 1 % mod;
		return 0;
	}
	cout << ans * fast_pow ( n, k - 2 ) % mod;
	return 0;
}


// 2n - 2
```

---

## 作者：_Ch1F4N_ (赞：0)

不难发现你要构造一棵权值最大的树。

考虑到每个点其实都是等价的，真正与答案有关的是度数的划分情况。

又因为你要还原整棵树，所以考虑对 Prüfer 序列进行 dp，具体而言，考虑一个长度为 $i$ 的序列最大权值为 $dp_{i}$，先默认每个点度数为 $1$，当一个点的度数增加时将原先的贡献减去再加上新的，那么有 $dp_{i} = \max(dp_{j}+f(i-j+1)-f(1))$，考虑直接 $O(n^2)$ 处理即可。

记下转移前驱，求出 Prüfer 序列之后直接转化成树即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 3114;
const int mod = 59393;
int qpow(int a,int b){
	if(b==0) return 1;
	if(b==1) return a%mod;
	int res=qpow(a,b/2);
	res=res*res%mod;
	if(b%2==1) res=res*(a%mod)%mod;
	return res;
}
int dp[maxn],pre[maxn],d[maxn],fa[maxn];
int a[11],n,k;
int f(int x){
	int res=0;
	for(int i=0;i<=k;i++){
		res=(res+a[i]*qpow(x,i)%mod)%mod;
	}
	return res;
}
vector<int> vec;
int P[maxn],p;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=0;i<=k;i++) cin>>a[i];
	cout<<n-1<<' ';
	for(int i=1;i<=n;i++) dp[0]+=f(1);
	for(int i=1;i<=n-2;i++){
		for(int j=0;j<i;j++){
			int tmp=f(i-j+1)-f(1);
			if(dp[j]+tmp>=dp[i]){
				dp[i]=dp[j]+tmp;
				pre[i]=j;
			}
		}
		//cout<<i<<' '<<dp[i]<<'\n';
	}
	cout<<dp[n-2]<<'\n';
	int now=pre[n-2],lst=n-2;
	while(now!=0){
		vec.push_back(lst-now);
		lst=now;
		now=pre[now];
	}
	vec.push_back(lst-now);
	int tot=0,col=0;
	for(int x:vec){
		col++;
		for(int i=1;i<=x;i++) P[++tot]=col;
	}
	//for(int i=1;i<=n-2;i++) cout<<P[i]<<' ';
	//cout<<'\n';
	p=0;
	for(int i=1;i<=n-2;i++) d[P[i]]++;
	for(int i=1;i<=n;i++) d[i]++;
	//for(int i=1;i<=n;i++) cout<<d[i]<<' ';
	//cout<<'\n';
	tot=0;
	for(int i=1;i<=n;i++){
		if(d[i]==1){
			p=i;
			break;
		}
	} 
	while(tot<=n-2){
		fa[p]=P[++tot];
		d[p]--;
		d[fa[p]]--;
		int u=fa[p];
		while(u<p&&d[u]==1){
			fa[u]=P[++tot];
			d[u]--;
			d[fa[u]]--;
			u=fa[u];
		}
		while(d[p]!=1&&p<=n) p++;
	}
	for(int i=1;i<n;i++) if(fa[i]==0) fa[i]=n;
	for(int i=1;i<n;i++) cout<<i<<' '<<fa[i]<<'\n';
	return 0;
}
```

顺便提一嘴，$k=1$ 时可以李超做到 $O(n \log n)$。

---

## 作者：pitiless0514 (赞：0)

## 题目大意
给定 $n$ 个点要求构造一棵树，每个点的价值是一个关于点度数的 $k$ 次多项式，系数均为给定的 $a_0,a_1,a_2, \dots, a_k$ ，求最
大价值。

$\text{Data Range : } 1 \le n \le 3000, 1 \le k\le 10$ 。

------
考虑 $\text{prufer}$ 序列。

一棵树对应唯一确定 $\text{prufer}$ 序列， 因此构造一棵树可以视作为构造一个 $\text{prufer}$ 序列。

一个度数为 $x$ 的点在 $\text{prufer}$ 序列中的出现次数为 $x-1$ 次， 序列总长为 $n-2$ 。 

可以把这个看成一个背包，容积为 $n-2$ ，现在往里面放物品，体积为 $x-1$ ， 价值为 $g(x)$  的物品有无数种。

因为度数为 $0$ 也有贡献，所以一开始设初值为 $n \times g(1)$ ， 这样后面放东西等价于是替换一个物品。

$g(x)$ 可以在一开始进行预处理出来，这部分时间复杂度为 $n^2$ 。

然后同时记录一下这个背包每次被哪些物品更新，之后从后往前跑，然后可以将 $\text{prufer}$ 序列构建出来。

然后将 $\text{prufer}$ 序列转成树输出即可。

需要特判掉 $n \le 2$ 的数据点

```cpp
// 德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱德丽莎你好可爱
// 德丽莎的可爱在于德丽莎很可爱，德丽莎为什么很可爱呢，这是因为德丽莎很可爱！
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4, mod = 59393;
int n, k, f[N], dp[N], g[N], pre[N];
int num, tot, p[N], deg[N], fa[N];
signed main () {
  ios :: sync_with_stdio( 0 );
  cin.tie( 0 ), cout.tie( 0 );
  cin >> n >> k;  k++;
  for(int i = 0; i <= k; i++) cin >> f[i];
  for(int i = 0; i <= n; i++) {
    int now = 1;
    for(int j = 0; j <= k; j++) {
      g[i] = (g[i] + f[j] * now) % mod;
      now = now * i % mod;
    }
  }
  if(n == 1) {
    cout << "0 " << g[0] << "\n";
    return 0;
  }
  if(n == 2) {
    cout << "1 " << 2 * g[1] << "\n";
    cout << "1 2 \n";
    return 0;
  }
  dp[0] = n * g[1];
  for(int i = 1; i <= n - 2; i++) {
    for(int j = 1; j <= i; j++) {
      if(dp[i - j] + g[j + 1] - g[1] > dp[i]) {
        dp[i] = dp[i - j] + g[j + 1] - g[1];
        pre[i] = j;
      }
    }
  }
  int u = n - 2;
  while(u) {
    deg[++num] = pre[u];
    for(int i = 1; i <= pre[u]; i++) p[++tot] = num;
    u -= pre[u];
  }
  p[++tot] = n;
  for(int i = 1, j = 1; i < tot; ++i, ++j) {
    while( deg[j] ) ++j; fa[j] = p[i];
    while( i < n && !--deg[p[i]] && p[i] < j) fa[p[i]] = p[i + 1], ++i;  
  }
  cout << n - 1 << " " << dp[n - 2] << "\n";
  for(int i = 1; i < n; i++) {
    cout << i << " " << fa[i] << "\n";
  }
  return 0;
}
```





---

## 作者：feecle6418 (赞：0)

有一个比较伞兵的 $O(n^2\log n)$ 做法。

容易把题目转化为：给出 $n-1$ 个物品，每种有无限个，第 $i$ 个体积为 $i$，价值为 $a_i$，请你选出恰好 $n$ 个物品，体积和为 $2n-2$，且价值和最大。

注意到 $\max,+$ 卷积有结合律，设 $F=(-\inf,a_1,\dots,a_{n-1})$，就是要在 $\max,+$ 卷积的意义下求 $F^n$。因此直接快速幂即可做到 $O(n^2\log n)$。

输出方案需要在快速幂的每一层都记录下从哪里转移过来的。实际实现上并不算麻烦。

至于如何根据方案构造树，每次选一个叶子，随便连到任何一个非叶子的点上即可。归纳一下就能发现这样一定有解。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=59393;
vector<int> d;
int n,K,a[12],v[6005],f[15][6005],g[15][6005],h[15][6005],u[15][6005],b[15];
void Append(int x,int y){
	if(x==0)return d.push_back(y);
	Append(x-1,g[x][y]),Append(x-1,y-g[x][y]);
}
int main(){
	cin>>n>>K,memset(f,0xc0,sizeof(f)),memset(h,0xc0,sizeof(h)),memset(v,0xc0,sizeof(v));
	for(int i=0;i<=K;i++)cin>>a[i];
	if(n==1)return cout<<0<<' '<<a[0]<<'\n',0;
	for(int i=1;i<n;i++){
		v[i]=0;
		for(int j=K;j>=0;j--)v[i]=(1ll*v[i]*i+a[j])%mod;
	}
	for(int i=0;i<=2*n;i++)f[0][i]=v[i];
	for(int i=1;i<=11;i++)
		for(int j=0;j<=2*n;j++)
			for(int k=0;k<=j;k++){
				if(f[i-1][j-k]+f[i-1][k]>f[i][j]){
					f[i][j]=f[i-1][j-k]+f[i-1][k];
					g[i][j]=k;
				}
			}
	int tot=0;
	h[0][0]=0;
	for(int i=0;i<=11;i++){
		if(!(n&(1<<i)))continue;
		b[++tot]=i;
		for(int j=0;j<=2*n;j++)
			for(int k=0;k<=j;k++){
				if(h[tot-1][j-k]+f[i][k]>h[tot][j]){
					h[tot][j]=h[tot-1][j-k]+f[i][k];
					u[tot][j]=k;
				}
			}
	}
	cout<<n-1<<' '<<h[tot][2*n-2]<<'\n';
	int A=tot,B=2*n-2;
	while(A)Append(b[A],u[A][B]),B-=u[A][B],A--;
	sort(d.begin(),d.end());
	for(int i=0,j=0;i<d.size();i++){
		while(j<d.size()&&d[j]==1)j++;
		if(j==d.size())return cout<<i+1<<' '<<j,0;
		cout<<i+1<<' '<<j+1<<'\n',d[j]--;
	}
}
```

---


# [THUPC 2018] 生生不息

## 题目描述

生命游戏是一个经典的零玩家游戏。

游戏在一块 $n \times m$ 的方格棋盘上进行，初始时，棋盘上的一些格子中有生命，另一些格子中没有生命。

在新的一天开始时，如果一个格子周围的 $8$ 个（边界上的格子也许不到 $8$ 个）格子中，在前一天有恰好$2$个或$3$个格子中有生命，则这个格子上的生命可以继续生存，如果周围的格子中恰好有$3$个格子在前一天有生命且这个格子中前一天没有生命，则会在这个格子中诞生新的生命。在其他情况下，该格子中原有的生命则会死去且不会产生新的生命。

如果在某一天，棋盘上所有的格子里都没有生命，显然，在接下来的时间里，所有的格子中再也不会有生命了，我们就说这些生命灭绝了。

现在，牛牛希望让菲菲来决定游戏开始时棋盘上的每个格子中是否有生命。

而他想知道，在游戏开始时，菲菲有多少种不同的方法使得棋盘上的生命永远也不会灭绝。

## 说明/提示

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
2
2 2
3 3```

### 输出

```
5
150```

# 题解

## 作者：Karry5307 (赞：7)

### 题意

给定一个$n\times m$的格子作为生命游戏的棋盘，问有多少种初始状态使得生命不会灭绝。

$\texttt{Data Range:}n,m\leq 5$
### 题解

看到这个数据范围，让我想起了填数游戏，所以说正解肯定是打表啦qwq。

但是怎么生成这个表呢？

爆搜每种状态，看每种状态是否可行。

可是“可行”的定义又是什么呢？需要繁衍到多少代才被判定为可行呢？

据统计（其实是我随便定了一个上界爆搜过了），在$5\times5$的棋盘上的，最长寿（但会死）的生命的寿命不超过$60$。

那就好了，于是可以知道每种状态是否可行了，也就是说对这个初始局面繁衍$60$代，看有没有死光光。于是就可以写出代码了qwq

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=15;
ll size,lived;
map<ll,ll>mp;
char x[MAXN][MAXN],y[MAXN][MAXN],k[MAXN][MAXN];
ll vx[8]={-1,-1,0,1,1,1,0,-1},vy[8]={0,1,1,1,0,-1,-1,-1};
inline ll read()
{
	register int num=0,neg=1;
	register char ch=getchar();
	while(!isdigit(ch)&&ch!='-')
    {
		ch=getchar();
    }
	if(ch=='-')
    {
		neg=-1;
		ch=getchar();
    }
	while(isdigit(ch))
	{
		num=(num<<3)+(num<<1)+(ch-'0');
		ch=getchar();
	}
	return num*neg;
}
inline bool isin(ll num,ll minn,ll maxn)
{
	return num>=minn&&num<=maxn;
}
inline ll getN(ll x_,ll y_)
{
	ll res=0;
	for(register int i=0;i<8;i++)
	{
		ll xx=x_+vx[i],yy=y_+vy[i];
		if(isin(xx,0,size-1)&&isin(yy,0,size-1))
		{
			res+=(x[xx][yy]=='*');
		}
	}
	return res;
}
inline void getNxt()
{
	for(register int i=0;i<size;i++)
	{
		for(register int j=0;j<size;j++)
		{
			ll n=getN(i,j);
			if(x[i][j]=='*')
			{
				y[i][j]=(n==2||n==3)?'*':'.';
			}
			if(x[i][j]=='.')
			{
				y[i][j]=(n==3)?'*':'.';
			}
		}
	}
	for(register int i=0;i<size;i++)
	{
		for(register int j=0;j<size;j++)
		{
			x[i][j]=y[i][j];
		}
	}
}
inline void test()
{
	ll xt=1;
	while(xt<60)
	{	
		xt++,getNxt();
		
		ll k=0;
		for(register int i=0;i<size;i++)
		{
			for(register int j=0;j<size;j++)
			{
				if(x[i][j]=='*')
				{
					k=1;
				}
			}
		}
		if(!k)
		{
			// printf("The life died at generation %d\n",xt);
			return;
		}
	}
	//puts("The life will never die!");
	lived++;
}
inline void dfs(ll x_,ll y_)
{
	if(x_==size&&!y_)
	{
		for(register int i=0;i<size;i++)
		{
			for(register int j=0;j<size;j++)
			{
				x[i][j]=k[i][j];
			}
		}
		test();
		return;
	}
	ll xx=x_,yy=y_+1;
	if(yy==size)
	{
		xx++,yy=0;
	}
	k[x_][y_]='.',dfs(xx,yy);
	k[x_][y_]='*',dfs(xx,yy);
}
int main()
{
	size=read();
	dfs(0,0);
	printf("%d\n",lived);
}
```
可是这样$5\times 5$的半个小时都跑不完。所以，怎么优化呢？？

考虑到如果有一个状态繁衍过后已经被证明是死的，那么这个状态也肯定是死的。

为什么呢？因为生命游戏的一种状态繁衍后只会得到一个后继状态，所以说这肯定是成立的。

同理，如果一个状态繁衍过后被证明是活的，那么这个状态也是活的。

所以可以用状压的方法把一个局面压缩成一个不超过$2^{25}$的数，开两个$\texttt{map}$来存已被证明是死的和活的的状态。

在判定可行的时候，如果到这一代已经被证明是死的，那么原来的状态肯定就是死的，把原来的状态加入到被证明是死的的状态的集合里。

同理，如果这一代被证明是活的，那么原来的状态肯定也是活的，把它加入到被证明是活的的集合里。

到这里，我们就不用对每一个状态都去繁衍$60$代或者繁衍到死，时间优化了很多，$5\times 5$十分钟就能跑完了。

于是一个一个尝试，就会出现这样一个表：

$$\begin{matrix}0&0&0&0&0\\0&5&18&73&267\\0&18&150&1533&11398\\0&73&1533&31828&469972\\0&267&11398&469972&12785753\end{matrix}$$

代码的话就不放出来了，这里把表的$\texttt{generator}$放出来

### 代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=15;
ll length,width,lived;
unordered_map<ll,ll>mp,mp2;
char x[MAXN][MAXN],y[MAXN][MAXN],k[MAXN][MAXN];
ll vx[8]={-1,-1,0,1,1,1,0,-1},vy[8]={0,1,1,1,0,-1,-1,-1};
inline ll read()
{
	register int num=0,neg=1;
	register char ch=getchar();
	while(!isdigit(ch)&&ch!='-')
    {
		ch=getchar();
    }
	if(ch=='-')
    {
		neg=-1;
		ch=getchar();
    }
	while(isdigit(ch))
	{
		num=(num<<3)+(num<<1)+(ch-'0');
		ch=getchar();
	}
	return num*neg;
}
inline bool isin(ll num,ll minn,ll maxn)
{
	return num>=minn&&num<=maxn;
}
inline ll getN(ll x_,ll y_)
{
	ll res=0;
	for(register int i=0;i<8;i++)
	{
		ll xx=x_+vx[i],yy=y_+vy[i];
		if(isin(xx,0,length-1)&&isin(yy,0,width-1))
		{
			res+=(x[xx][yy]=='*');
		}
	}
	return res;
}
inline void getNxt()
{
	for(register int i=0;i<length;i++)
	{
		for(register int j=0;j<width;j++)
		{
			ll n=getN(i,j);
			if(x[i][j]=='*')
			{
				y[i][j]=(n==2||n==3)?'*':'.';
			}
			if(x[i][j]=='.')
			{
				y[i][j]=(n==3)?'*':'.';
			}
		}
	}
	for(register int i=0;i<length;i++)
	{
		for(register int j=0;j<width;j++)
		{
			x[i][j]=y[i][j];
		}
	}
}
inline void test()
{
	ll xt=1,num=0;
	while(xt<60)
	{	
		xt++,getNxt(),num=0;
		for(register int i=0;i<length;i++)
		{
			for(register int j=0;j<width;j++)
			{
				num=(num<<1)+(x[i][j]=='*');
			}
		}
		if(mp2.find(num)!=mp2.end())
		{
			num=0;
			for(register int i=0;i<length;i++)
			{
				for(register int j=0;j<width;j++)
				{
					num=(num<<1)+(k[i][j]=='*');
				}
			}
			mp2[num]=1,lived++;
			return;
		}
		if(mp.find(num)!=mp.end())
		{
			// printf("The life died at generation %d\n",xt);
			num=0;
			for(register int i=0;i<length;i++)
			{
				for(register int j=0;j<width;j++)
				{
					num=(num<<1)+(k[i][j]=='*');
				}
			}
			mp[num]=1;
			return;
		}
	}
	//puts("The life will never die!");
	num=0;
	for(register int i=0;i<length;i++)
	{
		for(register int j=0;j<width;j++)
		{
			num=(num<<1)+(k[i][j]=='*');
		}
	}
	mp2[num]=1,lived++;
}
inline void dfs(ll x_,ll y_)
{
	if(x_==length&&!y_)
	{
		for(register int i=0;i<length;i++)
		{
			for(register int j=0;j<width;j++)
			{
				x[i][j]=k[i][j];
			}
		}
		test();
		return;
	}
	ll xx=x_,yy=y_+1;
	if(yy==width)
	{
		xx++,yy=0;
	}
	k[x_][y_]='.',dfs(xx,yy);
	k[x_][y_]='*',dfs(xx,yy);
}
int main()
{
	length=read(),width=read();
	mp[0]=1,dfs(0,0);
	printf("%d\n",lived);
}
```

---

## 作者：lllyyykkk (赞：6)

## [题目传送门](https://www.luogu.com.cn/problem/P5457)
这是一道关于生命游戏的题目。
~~可以点击[此处](https://playgameoflife.com/)试玩。~~
## 思路
因为 $n,m \le 5$，且只是输入 $n$ 与 $m$，考虑直接进行打表。
一个细胞在最好情况下的存活轮数应该不超过 $60$ 轮，所以可以以 $60$ 为上界。
但是 $O(2^{nm})$ 就是挂机也跑不出来，考虑进行优化。

显然，如果一个状态确定了是否合法，那么它前一个状态
和它就一定是一样的。
所以下一次遍历到这个状态就不必进行模拟了。

这显然可以用记忆化搜索实现。

用 map 压缩所有的状态，当一个状态被判定为是否合法后，将他的所有前置都判定掉，就可以了。

一个小优化：如果一次在压缩后和上次没有差别，就不用继续了。

## 打表代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ans[6][6]={};
bool flag[6][6],vis[6][6];
int ssum[60];
int dx[8]={1,0,-1,0,1,1,-1,-1},dy[8]={0,-1,0,1,1,-1,1,-1};
map<int,int>mp;
inline int num(int x,int y){
	int sum=0;
	for(int i=1;i<=x;i++) for(int j=1;j<=y;j++) sum=sum*2+vis[i][j];
	return sum;
}
inline bool check(int x,int y){
	int cnt=0;
	for(int i=1;i<=x;i++) for(int j=1;j<=y;j++) vis[i][j]=flag[i][j];
	bool vvis[6][6];
	while(cnt<=60){
		bool dead=1;
		ssum[++cnt]=num(x,y);
		if(ssum[cnt]==ssum[cnt-1]&&cnt>1) return 1;
		if(mp[ssum[cnt]]==1){
			for(int i=cnt-1;i>=1;i--) mp[ssum[cnt]]=1;
			return 0;
		}
		if(mp[ssum[cnt]]==2){
			for(int i=cnt-1;i>=1;i--) mp[ssum[cnt]]=2;
			return 1;
		}
		for(int i=1;i<=x;i++){
			for(int j=1;j<=y;j++){
				int s=0;
				for(int d=0;d<8;d++){
					int xx=i+dx[d],yy=j+dy[d];
					if(xx<1||yy<1||xx>x||yy>y) continue;
					s+=vis[xx][yy];
				}
				if(((s==2||s==3)&&vis[i][j])||((s==3)&&!vis[i][j])) vvis[i][j]=1,dead=0;
				else vvis[i][j]=0;
			}
		}
		if(dead){
			for(int i=cnt-1;i>=1;i--) mp[ssum[cnt]]=1;
			return 0;
		}
		for(int i=1;i<=x;i++) for(int j=1;j<=y;j++) vis[i][j]=vvis[i][j];
	}
	for(int i=cnt-1;i>=1;i--) mp[ssum[cnt]]=2;
	return 1;
}
void dfs(int pos,int x,int y){
	if(pos==x*y+1){
		int s=check(x,y);
		ans[x][y]+=s;	
		return;
	}
	int xx=pos/y+(pos%y?1:0),yy=pos%y;
	if(!yy) yy=y;
	flag[xx][yy]=0;
	dfs(pos+1,x,y);
	flag[xx][yy]=1;
	dfs(pos+1,x,y);
}
signed main(){
//  dfs(1,5,5);
	for(int i=1;i<=5;i++) for(int j=1;j<=5;j++) if(i!=5||j!=5) dfs(1,i,j),mp.clear();
	for(int i=1;i<=5;i++){
		cout <<'{'<<ans[i][1];
		for(int j=2;j<=5;j++) cout <<','<<ans[i][j];
		cout <<"},";
	}
    return 0;
}
``````

---

## 作者：AThousandSuns (赞：2)

在我的博客园看效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/11173116.html)

本来觉得就一 SB 题没必要写题解的，但是看见唯一一篇题解的打表代码那么慢，还是写一发吧。

首先 $n,m\le 5$，这是可以打表的。

本地怎么对于一个 $n,m$ 求答案？此时虽然复杂度不需要太优，但是还是得够快。

一个想法是枚举每个初始状态，不停模拟。因为总状态数只有 $O(2^{nm})$ 种，所以会出现周期。

 如果压缩状态，复杂度是 $O(4^{nm}nm)$。太大了。

但是，虽然一个状态的周期可能很长，但是如果一起考虑所有状态呢？

对于每个状态 $S$，直接模拟它下一轮会变成啥（设为 $T$）。那么连一条 $S\rightarrow T$ 的边。

那么就是问有多少个边走不到 $0$。

可以建反图，计算从 $0$ 能走到多少个点。

复杂度 $O(2^{nm}nm)$。除了 $n=m=5$ 的点大概要跑 10s，其它的都可以 1s 出。（那位要跑 10min……换成我根本就不想等了……）

代码就没必要放了。

---

## 作者：Remake_ (赞：0)

$\mathbb{THUPC}$初赛前写一篇题解以求$\texttt{rp++}$

初见题目：这完全没有规律可循啊qaq，换一题吧（

看见数据范围：懂了，离线跑答案然后打表

写完暴力后：等了$\texttt{5 min}$还没跑出来

于是换了个思路~~打表~~就过了


我们知道对于一个01矩阵$\texttt{e}$来说，它经过一次变换后的$\texttt{e'}$是唯一确定的，所以我们可以**反向建边**，连一条$\texttt{e'}\to\texttt{e}$的边，这样的话我们知道一种矩阵如果最终灭绝了那么最后它肯定归于虚无（废话），所以我们最终统计时从虚无矩阵开始搜索，记录搜索中经过了哪些点，这些点显然是最终会归于虚无的，所以我们用矩阵总数减去搜索经过的点总数就是我们所求的答案了。

考虑优化：

朴素的方法是写矩阵$\texttt{hash}$或者开$\texttt{map}$，但是这样的话会让时间复杂度多一个$\log$，~~您很有可能等不及~~，所以我们考虑二进制状压把整个矩阵压进去，由于矩阵中的每个点只有两种情况，所以总情况数只有$2^{nm}$种，空间开的下。

所以本题就做完了，$\texttt{Generator}$复杂度$O(2^{nm}nm)$，$n=m=5$的点也很快就能跑完$(20s)$：

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> v[(1 << 25) + 5];
int now[6][6], ans[6][6], n, m, cnt;
bool vis[(1 << 25) + 5];
int to(int x) {
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            now[i][j] = (bool)(x & (1 << ((i - 1) * m + j - 1)));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            int tmp = now[i - 1][j] + now[i - 1][j - 1] + now[i - 1][j + 1] +
                      now[i][j + 1] + now[i][j - 1] + now[i + 1][j] +
                      now[i + 1][j - 1] + now[i + 1][j + 1];
            ans[i][j] = now[i][j];
            if (now[i][j])
                if (!(tmp == 2 || tmp == 3)) ans[i][j] = 0;
            if (!now[i][j])
                if (tmp == 3) ans[i][j] = 1;
        }
    int ANS = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            ANS += ans[i][j] * (1 << ((i - 1) * m + j - 1));
    return ANS;
}
void dfs(int dep) {
    if (vis[dep]) return;
    ++cnt;
    vis[dep] = 1;
    for (int i = 0; i < v[dep].size(); i++) dfs(v[dep][i]);
}
int main() {
    cin >> n >> m;
    for (int i = 1; i < (1 << (n * m)); i++) v[to(i)].push_back(i);
    dfs(0);
    cout << (1 << (n * m)) - cnt;
}
```

AC程序：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T, n, m;
int main() {
    cin >> T;
    while (T--) {
        cin >> n >> m;
        if (n == 1 && m == 1) cout << "0\n";
        if (n == 1 && m == 2) cout << "0\n";
        if (n == 1 && m == 3) cout << "0\n";
        if (n == 1 && m == 4) cout << "0\n";
        if (n == 1 && m == 5) cout << "0\n";
        if (n == 2 && m == 1) cout << "0\n";
        if (n == 3 && m == 1) cout << "0\n";
        if (n == 4 && m == 1) cout << "0\n";
        if (n == 5 && m == 1) cout << "0\n";
        if (n == 2 && m == 2) cout << "5\n";
        if (n == 2 && m == 3) cout << "18\n";
        if (n == 2 && m == 4) cout << "73\n";
        if (n == 2 && m == 5) cout << "267\n";
        if (n == 3 && m == 2) cout << "18\n";
        if (n == 3 && m == 3) cout << "150\n";
        if (n == 3 && m == 4) cout << "1533\n";
        if (n == 3 && m == 5) cout << "11398\n";
        if (n == 4 && m == 2) cout << "73\n";
        if (n == 4 && m == 3) cout << "1533\n";
        if (n == 4 && m == 4) cout << "31828\n";
        if (n == 4 && m == 5) cout << "469972\n";
        if (n == 5 && m == 2) cout << "267\n";
        if (n == 5 && m == 3) cout << "11398\n";
        if (n == 5 && m == 4) cout << "469972\n";
        if (n == 5 && m == 5) cout << "12785753\n";
    }
}
```


---


# [THUPC 2021 初赛] 切切糕

## 题目描述

Kiana 喜欢吃甜点，某天她从商店中买回来 $N$ 块切糕与 Tinytree 共同分享，其中第 $i$ 块切糕的大小用一个数 $A_i$ 来表示。

因为每块切糕的风味都不同，所以 Kiana 和 Tinytree 决定将每块切糕都切成两份，两人各选一份品尝。但切切糕是一个自古以来的大难题，经过商议，Kiana 打算执刀来切切糕，而 Tinytree 有 $M$ 次“优先选糕权”，可以获得一些切糕切开后的优先选择权，具体来说，两人按照如下流程进行操作：

步骤一：Kiana 从还没切的切糕中按自己的想法选一块出来，并将其切成两份，其中**每份切糕的大小可以是任意正实数，也可以是 $\mathbf{0}$，且两份切糕的大小之和与切之前的大小相同**。

步骤二：Tinytree 观察完 Kiana 切出的两份切糕大小后，如果还有“优先选糕权”次数剩余，则可以决定是否消耗 $1$ 次“优先选糕权”来进行优先选择。

步骤三：如果 Tinytree 选择使用“优先选糕权”，则她可以从两份切糕中任选一份，另一份则归 Kiana，如果 Tinytree 选择不使用或者已经用完了 $M$ 次“优先选糕权”，则 Kiana 从两份切糕中任选一份，另一份则归 Tinytree，然后两人回到步骤一，直到所有的切糕都切完。

假设 Kiana 和 Tinytree 都足够聪明，在自己可以操作时总是想办法**让自己最终获得的切糕总大小尽可能大**，且开始切第一块切糕之前 $N$ 块切糕的大小是两人都已知的，“优先选糕权”不要求全部用完。现在 Kiana 想知道，自己能获得的切糕总大小是多少，由于 Kiana 自己不会算，所以希望你能够帮助她。

## 说明/提示

**【样例解释 #1】**

在这个样例中总共有 $4$ 块切糕，大小分别为 $4,3,2,1$，Tinytree 的“优先选糕权”一共有三次，两人可以按照如下顺序和方式来分配切糕：

第一块：Kiana 选择大小为 $3$ 的切糕，将其切成大小为 $1.25$ 和 $1.75$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1.75$ 的部分，Kiana 目前总共获得大小 $1.25$ 的切糕。

第二块：Kiana 选择大小为 $1$ 的切糕，将其切成大小为 $0$ 和 $1$ 的两部分，Tinytree 不使用“优先选糕权”，Kiana 独得此糕，目前总共获得大小 $2.25$ 的切糕。

第三块：Kiana 选择大小为 $2$ 的切糕，将其切成大小为 $1$ 和 $1$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1$ 的部分，Kiana 目前总共获得大小 $3.25$ 的切糕。

第四块：Kiana 选择大小为 $4$ 的切糕，将其切成大小为 $2$ 和 $2$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $2$ 的部分，Kiana 目前总共获得大小 $5.25$ 的切糕。

综上所述，该样例输出 $5.250000$，且可以证明在这个方案中如果任意一人改变自己的策略，其获得的切糕总大小不可能变得更大。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
4 3
4 3 2 1
```

### 输出

```
5.250000
```

# 题解

## 作者：decoqwq (赞：7)

直接算 Kiana 可以拿到的切糕不好算，考虑算 Tinytree 能拿到的最多的蛋糕。

令 $dp[i][j]$ 表示选了前 $i$ 个切糕，用了 $j$ 次优先选择权后 Tinytree 能拿到的最多的切糕，那么显然 $dp[i][0]=0$，$dp[i][i]=\frac{\sum_{j=1}^i a[j]}{2}$。

考虑转移，考虑当前位置为 $i$，则 Kiana 会想一种办法使得把 $a[i]$ 分成两部分 $x,y(x<y)$ 后，$\max\{x+dp[i-1][j],y+dp[i-1][j-1]\}$ 尽量小(因为 $dp[i-1][j-1]\leq dp[i-1][j]$)。

那么显然只需要让他们相等就行了，还要判断如果此时算出来的答案小于 $dp[i-1][j]$ 肯定是不对的，要和前者取个 $\max$。

~~感性理解一下，如果先选大的可以逼迫对面做出选择，先选小的给了他更多选择机会就会劣一些所以要先排序~~

复杂度 $O(nm)$

```cpp
#include <bits/stdc++.h>
using namespace std;
double dp[2510][2510];
int n,m,a[50010];
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1,cmp);
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		sum+=a[i];
		dp[i][0]=0.0;
		for(int j=1;j<=min(i,m);j++)
		{
			if(j==i)
			{
				dp[i][j]=(1.0*sum/2);
			}
			else
			{
				dp[i][j]=max(dp[i-1][j],(dp[i-1][j-1]+dp[i-1][j]+a[i])/2);
			}
		}
	}
	dp[n][m]=(1.0*sum-dp[n][m]);
	printf("%.6lf",dp[n][m]);
}
```

---

## 作者：vectorwyx (赞：6)

先考虑 $m=1$ ，也就是对手只有一次优先选择权的情况。有个优秀的策略是从小到大切，除了最大的那块均分成两半，其余切糕都切成 $(A_i,0)$ 。这启发我们，$m\ge1$ 时最优策略应当也是从小到大切，感性理解一下，这样会使得对手更加为难，因为使用一次优先选择权可能会失去对后面更大的切糕的争夺力。

确定顺序后不妨 dp。令 $f_{i,j}$ 表示决策完 $[1,i-1]$ 这段前缀，对手剩余 $j$ 次优先选择权，在接下来 $[i,n]$ 这段的博弈时己方可获得的最大权值。令第 $i$ 块切出的两份切糕中更大的那份大小为 $x$，那么对手有两种决策：使用优先选择权，或不使用。前者对应的转移为 $A_i-x+f_{i,j-1}$，后者则为 $x+f_{i,j}$。由于双方均采用最优策略，因此对手会选择更小的那个转移，即若 $A_i-x+f_{i,j-1}<x+f_{i,j}$ 则使用优先选择权，否则不使用。这给出了 $x$ 的一个界：$\frac{A+f_{i,j-1}-f_{i,j}}{2}$，转移时分类讨论一下即可。时间复杂度 $O(nm)$

代码如下：

```cpp
//author:望远星
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define ull unsigned long long
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=2505;
const db eps=1e-7;
db f[N][N],a[N];
int n,m;

bool cmp(db x,db y){
	if(fabs(x-y)<=eps) return 0;
	return x<y;
}

signed main(){
	cin>>n>>m;
	fo(i,1,n) a[i]=read();
	sort(a+1,a+1+n);
	f[n][0]=a[n];fo(i,1,m) f[n][i]=a[n]/2;
	go(i,n-1,1){
		f[i][0]=a[i]+f[i+1][0];
		fo(j,1,m){
			db x=(f[i+1][j-1]-f[i+1][j]+a[i])/2;
			if(cmp(x,a[i]/2)) f[i][j]=a[i]-x+f[i+1][j-1];
			else{
				if(!cmp(a[i],x)) f[i][j]=max(x+f[i+1][j],a[i]-x+f[i+1][j-1]);
				else f[i][j]=a[i]+f[i+1][j];
			}
		}
	}
	printf("%.10f",f[1][m]);   
	return 0;
}
/*
-------------------------------------------------
*/
```



---

## 作者：_Ch1F4N_ (赞：2)

很有意思的好题啊。

假若已经确定了选蛋糕顺序，那么不妨倒着 dp，具体而言，设计 $f_{i,j}$ 表示考虑第 $i$ 块蛋糕到第 $n$ 块蛋糕，还剩下 $j$ 次选蛋糕机会下，Tinytree 所能得到的蛋糕数量，显然 $f_{i,j} = \min_{0 \leq x \leq \frac{a_i}{2}}(\max(f_{i-1,j-1}+a_i-x,f_{i-1,j}+x))$。

里面的 $\max$ 考虑直接拆开，具体而言，$f_{i-1,j-1}+a_i-x > f_{i-1,j}+x$ 时 $x$ 的范围可以算出来，那么再在 $x$ 的不同范围中求出对应的 $\max$ 值的最小值即可。

还有一个问题，选蛋糕顺序怎么办，打表发现从小往大最优，感性理解下是因为这样 Tinytree 在决策当前要不要选蛋糕时需要考虑把当前的操作放到后面是不是更优，所以 Tinytree 的决策限制更多更为难。


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
//#define lowbit(x) (x&(-x))
//#define bp push_back
//#define sz size
//#define cl clear
const int maxn = 2514;
long double dp[maxn][maxn];
int n,m;
long double a[maxn];
long double sum;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
	sort(a+1,a+n+1);
	for(int i=n;i>=1;i--){
		for(int j=m;j>=0;j--){
			if(j==0){
				dp[i][j]=dp[i+1][j];
			}else{
				long double lim=(dp[i+1][j-1]-dp[i+1][j]+a[i])/2;
				if(lim>a[i]/2){
					dp[i][j]=dp[i+1][j-1]+a[i]/2;
				}else{
					if(lim<0){
						dp[i][j]=dp[i+1][j];
					}else{
						dp[i][j]=min(dp[i+1][j-1]+a[i]-lim,dp[i+1][j]+lim);
					}					
				}
			}
		}
	}
	printf("%.8Lf",sum-dp[1][m]);
	return 0;
}

```

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7137)

# 前置知识

[博弈论](https://oi-wiki.org/math/game-theory/intro/)

# 解法

由于本题是 [CF1628D1 Game on Sum (Easy Version)](https://www.luogu.com.cn/problem/CF1628D1) 的扩展，故先从 [CF1628D1 Game on Sum (Easy Version)](https://www.luogu.com.cn/problem/CF1628D1) 讲解。

## [CF1628D1 Game on Sum (Easy Version)](https://www.luogu.com.cn/problem/CF1628D1)

设 $x_{i}$ 表示第 $i$ 轮时 ``Alice`` 选择的数。

设 $f_{i,j}$ 表示已经进行了 $i$ 轮，且使用了 $j$ 次加法时的最大得分，状态转移方程为 $f_{i,j}= \max \{ \min(f_{i-1,j}-x_{i},f_{i-1,j-1}+x_{i}) \}=\frac{f_{i-1,j}+f_{i-1,j-1}}{2}$，边界为 $\begin{cases} f_{i,0 \sim \infty}=0 & i=0 \\ f_{i,0}=0, f_{i,i}=i \times k & i \ne 0 \end{cases}$。
  - 由于 ``Bob`` 想让结果尽可能小，所以有 $f_{i,j}= \min(f_{i-1,j}-x_{i},f_{i-1,j-1}+x_{i})$。
  - 由于 ``Alice`` 想让结果尽可能大，所以会让 $\min(f_{i-1,j}-x_{i},f_{i-1,j-1}+x_{i})$ 取到最大值，即 $f_{i-1,j}-x_{i}=f_{i-1,j-1}+x_{i}$ 时，解得 $x_{i}= \frac{f_{i-1,j}-f_{i-1,j-1}}{2}$，代入原式有 $f_{i,j}=\frac{f_{i-1,j}+f_{i-1,j-1}}{2}$。

由于 ``Bob`` 想让结果尽可能小，所以至多使用 $m$ 次加法，故最终 $f_{n,m}$ 即为所求。

另外，由于求解 $f_{n,m}$ 的过程中只有加法和 $\times \frac{1}{2}$ 运算，故可以将 $k$ 缩小至 $1$ 进行预处理 $f_{n,m}$，询问时再扩大到 $k$，即 $f_{n,m} \times k$。
        
        
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
const ll p=1000000007;
ll f[2010][2010];
ll qpow(ll a,ll b,ll p)
{
    ll ans=1;
    while(b>0)
    {
        if(b&1)
        {
            ans=ans*a%p;
        }
        b>>=1;
        a=a*a%p;
    }
    return ans;
}
int main()
{
    ll t,n,m,k,i,j;
    cin>>t;
    for(i=1;i<=2000;i++)
    {
        f[i][0]=0;
        f[i][i]=i;
        for(j=1;j<=i-1;j++)
        {
            f[i][j]=((f[i-1][j]+f[i-1][j-1])%p)*qpow(2,p-2,p)%p;
        }
    }
    for(i=1;i<=t;i++)
    {
        cin>>n>>m>>k;
        cout<<f[n][m]*k%p<<endl;
    }
    return 0;
}
```
## [luogu P7137 [THUPC2021 初赛] 切切糕](https://www.luogu.com.cn/problem/P7137)

从贪心的角度分析， ``Tinytree`` 的“优先选糕权”要尽量留给 $a_{i}$ 较大的切糕，故需要先将 $a$ 按照降序排序。

设第 $i$ 块切糕 ``Kiana`` 切成的切糕大小为 $x_{i}$ 和 $a_{i}-x_{i}$，规定有 $x_{i} \ge a_{i}-x_{i}$。

设 $f_{i,j}$ 表示已经切了 $i$ 块切糕，且使用了 $j$ 次“优先选糕权”时 ``Tinytree`` 的最大总大小，状态转移方程为 $f_{i,j}= \max \{ \min(f_{i-1,j}+a_{i}-x_{i},f_{i-1,j-1}+x_{i}),f_{i-1,j} \}=\max(\frac{f_{i-1,j}+f_{i-1,j-1}+a_{i}}{2},f_{i-1,j})$，边界为 $\begin{cases} f_{i,0 \sim \infty}=0 & i=0 \\ f_{i,0}=0, f_{i,i}=\frac{\sum_{j=1}^{i}a_{j}}{2} & i \ne 0 \end{cases}$。    
  - $x_{i}$ 的求解同 [CF1628D1 Game on Sum (Easy Version)](https://www.luogu.com.cn/problem/CF1628D1) 。
  - 由于算出的 $x_{i}$ 可能使 $a_{i}-x_{i}<0$ 成立，故最后需要与 $f_{i-1,j}$ 取 $\max$。

由于 ``Tinytree`` 想让 ``Kiana`` 的总大小尽可能小，所以一定会使用 $m$ 次“优先选糕权”，使自己的总大小尽可能大，故最终 $\sum\limits_{i=1}^{n}a_{i}-f_{n,m}$ 即为所求。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll a[2510],sum[2510];
double f[2510][2510];
int main()
{
    ll n,m,i,j;
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+1+n,greater<ll>());
    for(i=1;i<=n;i++)
    {
        sum[i]=sum[i-1]+a[i];
    }
    for(i=1;i<=n;i++)
    {
        f[i][0]=0;
        f[i][i]=1.0*sum[i]/2;
        for(j=1;j<=i-1;j++)
        {
            f[i][j]=max((f[i-1][j]+f[i-1][j-1]+1.0*a[i])/2,f[i-1][j]);
        }
    }
    printf("%.6lf",sum[n]-f[n][m]);
    return 0;
}
```

---

## 作者：xishanmeigao (赞：0)

（[题目传送门](https://www.luogu.com.cn/problem/P7137)）

根据博弈论 dp 的基本套路从后往前 dp，设 $f_{i,j}$ 表示还剩 $i$ 个切糕，$j$ 次优先选择权，Kiana 能获得的最大切糕大小。转移即考虑当前将这个切糕切成两份 $x,y$，满足 $x\leq y$ 且 $x+y=a_{cur}$（$a_{cur}$ 表示这一轮选的切糕），则 $f_{i,j}=\min(x+f_{i-1,j-1},y+f_{i-1,j})$。当 $x=\dfrac{a_i-f_{i-1,j-1}+f_{i-1,j}}{2}$，$y=\dfrac{a_i+f_{i-1,j-1}-f_{i-1,j}}{2}$ 时 $f_{i,j}$ 取到最大值 $\dfrac{f_{i-1,j-1}+f_{i-1,j}+a_{cur}}{2}$ 。

但是并不是所有情况都能取到等号，

- 当 $y<x$ 时，交换 $x,y$ 即可。
- 当 $x<0,y>a_{cur}$ 时，令 $x\leftarrow0,y\leftarrow a_{cur}$。

最后输出 $f_{n,m}$（为了最优 Tinytree 肯定会用完所有的“优先选择权”）。

现在还有个问题，应该怎样选择切糕的顺序？

猜测是从小到大切，因为这样 Kiana 能给对手更多的抉择，因为如果在当前使用“优先选择权”到了后面更大的可能就选不到了。

```cpp
#include<bits/stdc++.h>
#define db double
using namespace std;

const int N=2510;
const db eps=1e-12;

int n,m,a[N],suf[N];
db f[N][N];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
		scanf("%d",&a[i]);

	sort(a+1,a+1+n);

	f[0][0]=0;
	for(int i=1; i<=n; i++)
	{
		int cur=n-i+1;
		f[i][0]=(db)a[cur]+f[i-1][0];
		f[i][i]=(db)a[cur]/2.000000+f[i-1][i-1];
		for(int j=1; j<=min(i-1,m); j++)
		{
			db x=((db)a[cur]-(f[i-1][j-1]-f[i-1][j]))/2.000000;
			db y=(db)a[cur]-x;
			if(y<x)
				f[i][j]=min(x+f[i-1][j-1],y+f[i-1][j]);
			else
			{
				if((db)x>=0)
					f[i][j]=(f[i-1][j-1]+f[i-1][j]+(db)a[cur])/2.000000;
				else
					f[i][j]=min(f[i-1][j-1],f[i-1][j]+(db)a[cur]);
			}
		}

	}
	
	printf("%.6lf\n",f[n][m]);

	return 0;
}
```





---

## 作者：haohao_com (赞：0)

## 前置知识：
[博弈论](https://oi-wiki.org/math/game-theory/intro/)
## [P7137](https://www.luogu.com.cn/problem/P7137)

### 从贪心的角度分析
```Tinytree``` 的“优先选糕权”要尽量留给 $a_i$ 较大的切糕，故需要先将 $a$ 按照降序排序。\
设第 $i$ 块切糕 ```Kiana``` 切成的切糕大小为 $x_i$ 和 $a_i-x_i$，规定有 $x_i \ge a_i - x_i$。

设 $f_{i,j}$ 表示已经切了 $i$ 块切糕，且使用了 $j$ 次“优先选糕权”时 ```Tinytree``` 的最大总大小
状态转移方程为
$$\begin{cases}f_{i,0\sim\infty}=0&i=0\\ f_{i,0}=0,f_{i,i}=\frac{\sum^i_{j=1}a_j}{2}&i\neq0\end{cases}$$

- $x_i$ 的求解同 [CF1628D1 Game on Sum (Easy Version)](https://www.luogu.com.cn/problem/CF1628D1)。
- 由于算出的 $x_i$ 可能使 $a_i-x_i<0$ 成立，故最后需要与 $f_{i-1,j}$ 取 $\tt max$。

由于 ```Tinytree``` 想让 ```Kiana``` 的总大小尽可能小，所以一定会使用 $m$ 次“优先选糕权”，使自己的总大小尽可能大，故最终 $$\sum^n_{i=1}a_i-f_{n,m}$$ 即为所求。

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll a[2510],sum[2510];
double f[2510][2510];
int main(){
    ll n,m,i,j;
    cin>>n>>m;
    for(i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+1+n,greater<ll>());
    for(i=1;i<=n;i++){
        sum[i]=sum[i-1]+a[i];
    }
    for(i=1;i<=n;i++){
        f[i][0]=0;
        f[i][i]=1.0*sum[i]/2;
        for(j=1;j<=i-1;j++){
            f[i][j]=max((f[i-1][j]+f[i-1][j-1]+1.0*a[i])/2,f[i-1][j]);
        }
    }
    printf("%.6lf",sum[n]-f[n][m]);
    return 0;
}
```

---


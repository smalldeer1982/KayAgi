# [THUPC 2021 初赛] 区间矩阵乘法

## 题目描述

给定长度为 $n$ 的序列 $a_1, a_2, \dots, a_n$；共 $m$ 组询问，每次询问给出 $d,p_1,p_2$，求

$$ \sum_{i=0}^{d-1} \sum_{j=0}^{d-1} \sum_{k=0}^{d-1} a_{p_1+d\cdot i+j} a_{p_2 + d\cdot j + k} $$

## 说明/提示

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
5
2 2 1 2 1
4
1 5 4
2 2 1
2 1 1
1 5 5
```

### 输出

```
2
22
24
1
```

# 题解

## 作者：Miko35 (赞：7)

题意清晰思路简单码量少好评，卡常一万年 -9 差评。

成为了相同题目数量下罚时（可能）最长的队伍，顺便水一水题解。

似乎是目前的最优解，但估计马上就不是了（

题意很简单就是给一个序列， 每次询问给出 $d,p_1,p_2$，让你求这个玩意：

$$\sum_{i=0}^{d-1}\sum_{j=0}^{d-1}\sum_{k=0}^{d-1}a_{p_1+d\cdot i+j}\times a_{p_2+d\cdot j+k}$$

(第一遍看成了 $a_{p_1}+d\cdot i+ja_{p_2}+d\cdot j+k$，然后愣了三秒（笑

首先是发现 $k$ 与 $a_{p_1+d\cdot i+j}$ 无关，然后就可以把式子变成这个形式：

$$\sum_{i=0}^{d-1}\sum_{j=0}^{d-1}a_{p_1+d\cdot i+j}\times \sum_{k=0}^{d-1}a_{p_2+d\cdot j+k}$$

然后维护一个前缀和 $sum$，式子就变成了：

$$\sum_{i=0}^{d-1}\sum_{j=0}^{d-1}a_{p_1+d\cdot i+j}\times (sum_{p2+d(j+1)-1}-sum_{p2+d\cdot j-1})$$

然后做到这里发现很难再继续化简，爬回去重新读题，发现询问保证 $a$ 的下标在 $[1,n]$ 内，而不是多余的下标不予计算。

这样的话，当 $j=k=d-1$ 时，$a_{p_2+d\cdot j+k}=a_{p_2+d(d-1)+d-1}=a_{p_2+d^2}$；当 $j=k=0$ 时，$a_{p_2+d\cdot j+k}=a_{p_2}$。然后又保证了下标在 $[1,n]$ 内，所以 $p_2+d^2∈[1,n]$，$p_2∈[1,n]$。所以 $d∈[1,\sqrt{n-1}]$（所有数值为 $[1,{10}^9]$ 以内的整数）。

所以维护一个 $s_{i,j}$ 表示：

$$s_{i,j}=\sum_{k=0}^{\lfloor \frac{j-1}{i} \rfloor}a_{j-ki}$$

意义通俗一点说就是，从 $j$ 到 $1$ 的“隔 $i$ 个的”前缀和。

显然，这个 $s$ 递推的话就是：

$$s_{i,j}=\begin{cases}
a_j&1 \leq j\leq i\\
s_{i,j-i}&i< j \leq n 
\end{cases}$$

这样的话这个式子继续化简，发现只有 $a_{p_1+d\cdot i+j}$ 含有 $i$ 这一项，用同样的套路把它提出来：

$$\sum_{j=0}^{d-1}(sum_{p_2+d(j+1)-1}-sum_{p_2+d\cdot j-1})\times \sum_{i=0}^{d-1}a_{p_1+d\cdot i+j}$$

然后用维护的 $s_{i,j}$ 改写一下：

$$\sum_{j=0}^{d-1}(sum_{p_2+d(j+1)-1}-sum_{p_2+d\cdot j-1})(s_{d,p_1+d(d-1)+j}-s_{d,p_1+j}+a_{p_1+j})$$

这样单次询问直接暴力枚举 $j$，做到 $\mathcal{O}(d)$ 的复杂度。这种做法的时间复杂度为 $\mathcal{O}(m \sqrt{n})$，可以通过本题。

```cpp
#include <bits/stdc++.h>
#define rgi register int
using namespace std;
namespace IO{
#define getchar() (P1_==P2_&&(P2_=(P1_=Ibuf)+fread(Ibuf,1,1<<21,stdin),P1_==P2_)?EOF:*P1_++)
#define putchar(c) (O-Obuf<8388608)?(*O++=c):(fwrite(Obuf,O-Obuf,1,stdout),O=Obuf,*O++=c)
	char Ibuf[8388608],*P1_=Ibuf,*P2_=Ibuf,Obuf[8388608],*O=Obuf;
	int f,ch,Onum[32],Ohd;long long K_;
	template<typename T>inline void read(T&x){
		x=f=ch=0;while(!isdigit(ch))f|=(ch=='-'),ch=getchar();
		while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
		f&&(x=-x);
	}
	template<typename T>inline void write(T x){
		if(x==0)return putchar('0'),void();
		if(x<0)putchar('-'),x=-x;
		while(x>0)K_=x/10,Onum[++Ohd]=(x-(K_<<1)-(K_<<3))^'0',x=K_;
		while(Ohd>0)putchar(Onum[Ohd]),--Ohd;
	}
	inline void _Exit0(){
		fwrite(Obuf,O-Obuf,1,stdout),exit(0);
	}
}using namespace IO;
int Block,n,m,p1,p2,d;
unsigned int a[200010],ans;
unsigned int s[450][200010],sum[200010];
int main(){
	read(n),Block=sqrt(n);
	for(rgi i=1;i<=n;++i)read(a[i]),sum[i]=sum[i-1]+a[i];
	for(rgi i=1;i<=Block;++i){
		for(rgi j=1;j<=i;++j)s[i][j]=a[j];
		for(rgi j=i+1;j<=n;++j)s[i][j]=s[i][j-i]+a[j];
	}
	read(m);
	for(rgi t=1;t<=m;++t){
		read(d),read(p1),read(p2),ans=0;
		for(rgi j=0;j<d;++j)ans+=(s[d][p1+(d-1)*d+j]-s[d][p1+j]+a[p1+j])*(sum[p2+d*(j+1)-1]-sum[p2+d*j-1]);
		write(ans),putchar('\n');
	}
	_Exit0();
}
```



---

## 作者：cirnovsky (赞：2)

$$
\sum_{i=0}^{d-1}\sum_{j=0}^{d-1}\sum_{k=0}^{d-1}a(p+di+j)a(q+dj+k) \\
\begin{aligned}
&=\sum_{i=0}^{d-1}\sum_{j=0}^{d-1}a(p+di+j)\sum_{k=0}^{d-1}a(q+dj+k) \\
&=\sum_{j=0}^{d-1}\left(\sum_{i=0}^{d-1}a(p+di+j)\right)\left(\sum_{k=0}^{d-1}a(q+dj+k)\right) \\
&=\sum_{j=0}^{d-1}\left(\sum_{i=0}^{d-1}a(p+di+j)\right)\left(pre(q+dj+d-1)-pre(q+dj-1)\right) \\
\end{aligned}
$$
由题意，$q+dj+k\le n$，也就是说 $q+d(d-1)+d(-1)=q+d^{2}\le n$，$q_{\min}=1$，所以 $d$ 是根号规模。

那么就可以直接来了，设 $s(i,j)$ 为前缀 $i$ 的间隔 $j$ 前缀和。比如 $\color{red}\texttt{1 2 3 4 5 6}$ 的 $s(6,2)=12$，也就是 $\color{red}\texttt{1}\color{blue}\texttt{ 2}\color{red}\texttt{ 3}\color{blue}\texttt{ 4}\color{red}\texttt{ 5}\color{blue}\texttt{ 6}$，蓝色表示被计入贡献，这个东西显然可以递推。

然后把这个带进式子
$$
\sum_{j=0}^{d-1}\left(\sum_{i=0}^{d-1}a(p+di+j)\right)\left(pre(q+dj+d-1)-pre(q+dj-1)\right) \\
\begin{aligned}
&=\sum_{j=0}^{d-1}\left(s(p+j+d(d-1),d)-s(p+j,d)+a(p+j)\right)\left(pre(q+dj+d-1)-pre(q+dj-1)\right) \\
\end{aligned}
$$
然后就可以直接算了。

然后你会发现你被卡常了，于是把 $s(i,j)$ 换成 $s(j,i)$，前面是根号大小寻址更快，就可以无压力过掉了。

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P7140)

## 题意

- 对于 $m$ 个询问，每次询问给出 $d$ $p1$ $p2$，求 $\sum\limits_{i=0}^{d-1} \sum\limits_{j=0}^{d-1} \sum\limits_{k=0}^{d-1} a_{p_1+d\cdot i+j} a_{p_2 + d\cdot j + k}$。

## Sol

原式显然相当于 $\sum\limits_{j=0}^{d-1}( \sum\limits_{i=0}^{d-1}  a_{p_1+d\cdot i+j} )(\sum\limits_{k=0}^{d-1}a_{p_2 + d\cdot j + k})$

显然是两个前缀和，前面那个可以用下面这个东西解决。

然后枚举 $j$ 即可。

---

对于前面一个前缀和计算。

建议先阅读 [哈希冲突 题解](https://www.luogu.com.cn/blog/danieljiang/ha-xi-chong-tu-ti-xie-gen-hao-ke-ji)

我们用到的是最后那个东西。

- 给定一个序列，每次询问给定 $x$，$y$，问 $y+kx(k \in N)$ 的位置上的和。

- 不保证 $y\le x$

$x \ge \sqrt n$ 时暴力跑。

$x < \sqrt n$ 时，用 $f_{i,j}$ 表示 $x=i$，$y=j$ 的答案。

对于每个 $x$，从后往前更新即可。

然而题目保证无下边越界，那么 $d\le\sqrt n$。

先用 $f_{i,j}$ 记录即可。

### $\text{Code}$

```cpp
// wish to get better qwq

#include<bits/stdc++.h>
#define re register int
#define pb push_back
#define int unsigned int

using namespace std;
typedef long long ll;

template <typename T> void rd(T &x){
	int fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(int x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}

// ---------- IO ---------- //

const int N=2e5+5,SQ=460;
int n,m,a[N],d,p1,p2,s1[SQ][N],s2[N],len;

// ----------  ---------- //

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);len=(int)sqrt(n);
	for(re i=1;i<=n;i++) rd(a[i]),s2[i]=s2[i-1]+a[i];
	for(re i=n+1;i<N;i++) s2[i]=s2[i-1];
	for(re i=1;i<=len;i++)
		for(re j=n;j>0;j--) s1[i][j]=s1[i][j+i]+a[j];
	rd(m);
	while(m--){
		rd(d);rd(p1);rd(p2);
		int ans=0;
		for(re j=0;j<d;j++){
			if(p1+j+d*(d-1)+d>n&&p2+d*j+d-1>n) ans+=s1[d][p1+j]*(s2[n]-s2[p2+d*j-1]);
			else if(p1+j+d*(d-1)+d>n) ans+=s1[d][p1+j]*(s2[p2+d*j+d-1]-s2[p2+d*j-1]);
			else if(p2+d*j+d-1>n) ans+=(s1[d][p1+j]-s1[d][p1+j+d*(d-1)+d])*(s2[n]-s2[p2+d*j-1]);
			else ans+=(s1[d][p1+j]-s1[d][p1+j+d*(d-1)+d])*(s2[p2+d*j+d-1]-s2[p2+d*j-1]);
		}
		wr(ans);puts("");
	}
	return 0;
}

// ---------- Main ---------- //
```

~~为啥 THUPC 时没 MLE 你谷上就 MLE 了啊/dk~~

~~害的把越界判掉数组开小/dk~~

---

## 作者：MoYuFang (赞：0)

[P7140 [THUPC2021 初赛] 区间矩阵乘法](https://www.luogu.com.cn/problem/P7140)

难度应该绿吧。

$$
ans(d,p,q)=\sum_{j=0}^{d-1}\left(\sum_{i=0}^{d-1}a(p+j+d\cdot i)\right)\cdot\left(\sum_{k=0}^{d-1}a(q+d\cdot j+k)\right)
$$

由于 $1\leq d \leq \sqrt{n}$，每次询问可以暴力枚举 $j$ 求出，后半部分比较容易，前缀和作差就行了，前半部分可以离线求。

离线的具体操作，将 $d$ 相同的询问分成一个组。

对于每个组 $d$，定义：

$$
f(x)=\left\{\begin{aligned}
	&f(x-d)+a(x) &(x>d)\\
	&a(x) &(1 \leq x \leq d)\\
   &0 &(x \leq 0)
\end{aligned}\right.
$$

显然每次的 $f$ 可以 $O(n)$ 求出。

于是有：
$$
\sum_{i=0}^{d-1}a(p+j+d\cdot i)=f(p+j+d^2-d)-f(p+j-d)
$$

总时间复杂度为 $O((n+m)\sqrt n)$，空间复杂度为 $O(n)$。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <vector>
#include <assert.h>
#include <cmath>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ui unsigned int
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])
#define inf 0x7fffffff
#define maxn 200005
#define maxs 700

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

ui	a[maxn],
	s[maxn],
	f[maxn],
	ans[maxn];
struct Qry{ int p, q, id; };
vector<Qry> Q[maxs];

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	freopen("sample.out", "w", stdout);
	#endif

	re int n = rdnt(), m;
	_rfor(i, 1, n) s[i] = (a[i] = rdnt()) + s[i-1];
	m = rdnt();
	_rfor(i, 1, m){
		re int d = rdnt(), p = rdnt(), q = rdnt();
		Q[d].push_back({p, q, i});
	}
	_rfor(d, 1, (int)sqrt(n)+1){
		_rfor(i, 1, n) f[i] = i > d ? f[i-d] + a[i] : a[i];
		for(auto qry : Q[d]){
			re ui p = qry.p, q = qry.q, as = 0;
			_for(j, 0, d){
				as += (
					f[p+j+d*(d-1)] - (p+j > d ? f[p+j-d] : 0)
					)*(
					s[q+d*j+d-1] - s[q+d*j-1]
				);
			}
			ans[qry.id] = as;
		}
	}
	_rfor(i, 1, m) pf("%u\n", ans[i]);

	return 0;
}
```


---


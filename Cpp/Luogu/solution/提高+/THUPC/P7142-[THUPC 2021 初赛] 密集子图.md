# [THUPC 2021 初赛] 密集子图

## 题目描述

有一天，魔法师小 L 看到了一个有向完全图。

图中所有边的长度都是 $1$，且所有边都是白色的。

现在小 L 要对这个图施展魔法，图中每条有向边分别都有一定概率变成黑色。

小 L 认为一个图是“密集的”，当且仅当只经过黑色边时，点 $1$ 到其余所有点的最短路径长度都不超过 $k$（特别地，若两个点不连通则它们之间最短路径的长度视为 $+ \infty$）。

小 L 想要知道，此时这个有向完全图有多大的概率是“密集的”呢？请你输出此概率对 $998,244,353$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

这个有向完全图是“密集的”，当且仅当点 $1$ 到点 $2$ 的有向边和点 $1$ 到点 $3$ 的有向边同时变成黑色，这种情况出现的概率 $= \frac{1}{2} \times \frac{1}{3} = \frac{1}{6}$，$\frac{1}{6} \bmod 998,244,353 = 6^{998,244,351} \bmod 998,244,353 = 166,374,059$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
3 1
1 2 1 2
2 1 1 2
1 3 1 3
3 1 2 3
2 3 3 4
3 2 2 5
```

### 输出

```
166374059
```

# 题解

## 作者：FZzzz (赞：7)

考虑最短路树，对于深度为 $i$ 的某个点，深度小于 $i-1$ 的点不能向其连边，至少有一个深度为 $i-1$ 的点向其连边，对于其他点连向它的边没有限制。

这启发我们分层状压 dp。设 $f_{d,s_1,s_2}$ 为，深度为 $d$ 的点的集合为 $s_1$，深度小于等于 $d$ 的点的集合为 $s_2$，只考虑连向深度大于 $d$ 的点的边的限制，时，图满足条件的概率。

考虑转移。枚举深度为 $d+1$ 的点的集合 $s_3$，则 $s_1-s_2$ 内的点都不能向 $s_3$ 内的点连边，且对于 $s_3$ 内的每一个点，$s_2$ 内至少有一个点需要向其连边。dp 值即为每个这样的 $s_3$ 符合条件的概率之和。

直接实现即可做到 $O(\operatorname{poly}(n)4^n)$ 的复杂度，因为这个 dp 实际上相当于枚举子集的子集。

对于每个 $s_1$ 和 $s_2$，预处理 $s_1$ 内的点都不向 $s_2$ 内的点连边的概率，和对于每个 $s_2$ 内的点 $s_1$ 内的点至少有一个向其连边的概率。这部分可以在 $O(3^n)$ 至 $O(n4^n)$ 不等的时间内完成。预处理后每次转移的复杂度降为 $O(1)$，总时间复杂度为 $O(n4^n)$。

需要进行一些卡常卡空间。

下面是我的最终代码，使用了滚动数组进行优化，空间 $O(4^n)$。理论上最好可以做到 $O(3^n)$ 空间。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=12;
int n,k;
const int mod=998244353;
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b%2==1) ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		b/=2;
	}
	return ans;
}
inline void mul(int& x,int y){
	x=1ll*x*y%mod;
}
int p[maxn+5][maxn+5];
int f[2][(1<<maxn)+5][(1<<maxn)+5];
int g[(1<<maxn)+5][(1<<maxn)+5],h[(1<<maxn)+5][(1<<maxn)+5];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	k=readint();
	for(int i=0;i<n*(n-1);i++){
		int x,y;
		x=readint()-1;
		y=readint()-1;
		p[x][y]=readint();
		mul(p[x][y],ksm(readint(),mod-2));
	}
	int all=(1<<n)-1;
	for(int s1=0;s1<=all;s1++){
		for(int i=0;i<n;i++) if(!(s1>>i&1)){
			g[s1][1<<i]=1;
			for(int j=0;j<n;j++) if(s1>>j&1) mul(g[s1][1<<i],(1-p[j][i]+mod)%mod);
		}
		for(int s2=all^s1;s2;s2=(s2-1)&(all^s1)) if((s2&-s2)!=s2){
			g[s1][s2]=1;
			for(int i=0;i<n;i++) if(s2>>i&1) mul(g[s1][s2],g[s1][1<<i]);
		}
	}
	for(int s1=0;s1<=all;s1++){
		for(int i=0;i<n;i++) if(!(s1>>i&1)) h[s1][1<<i]=(1-g[s1][1<<i]+mod)%mod;
		for(int s2=all^s1;s2;s2=(s2-1)&(all^s1)) if((s2&-s2)!=s2){
			h[s1][s2]=1;
			for(int i=0;i<n;i++) if(s2>>i&1) mul(h[s1][s2],h[s1][1<<i]);
		}
	}
	f[(k+1)%2][all][0]=1;
	for(int d=k;d>=0;d--) for(int s1=1;s1<=all;s1++){
		f[d%2][s1][0]=s1==all;
		for(int s2=s1;s2;s2=(s2-1)&s1){
			long long res=s1==all;
			for(int s3=all^s1;s3;s3=(s3-1)&(all^s1))
				res+=1ll*f[!(d%2)][s1|s3][s3]*g[s1^s2][s3]%mod*h[s2][s3]%mod;
			f[d%2][s1][s2]=res%mod;
		}
	}
	printf("%d\n",f[0][1][1]);
	return 0;
}
```

---

## 作者：zzw4257 (赞：6)

>你有一个$n$点的竞赛图，初始每条边是不存在的，现在每条边$i$(注意是双向的)有$p_i$的概率存在，求从$1$出发到所有点的最短路径都不超过$k$的概率

### 前言

今天终于拿到代码了,这里是[考试时提交](https://thupc2021.thusaac.com/#!/contest/2/detail/5536)

给一个好看的三进制状压$dp$，关于复杂度~~我不知道~~

另外附一句，关于[这道题](https://blog.csdn.net/mys_c_k/article/details/89336055)，你可以"不小心"搜到

在这里强调一点由于我脑子比较奇怪，下面二进制点集表示的状态和三进制点的选取状态通常是一个字符$S$表示，请注意

### 正文

这题我们反其道而行，递推求恰好$i(i\in[1,k])$条的再求和就可以了

发现这个过程本质是在建一棵最短路径$\mathrm{DAG}$,于是我们便状压这个过程

整体思路是我们发现点分为两类，最短路径$\mathrm{DAG}$上的点，不在最短路径$\mathrm{DAG}$上的点

而最短路径$\mathrm{DAG}$上的点又分为最前沿的——待扩展的$i$层点，与落后的$[1,i)$层点

设$f_{i,S}$表示建到第$i$层，点的选择状态为$S$的概率

$0$表示未选，$1$表示在扩展层(就是刚好第$i$层)，$2$表示扩展结束($<i$层点)

先预处理一些东西

$all_{S,x}$表示$S$**点集**到$x$点不存在一条出边的概率

$part_{S,x}$表示$S$**点集**到$x$点存在至少一条出边的概率

这样你就可以**动态的**(是在转移中动态知道的$S$与$T$)处理出

对已经定的贡献出点的**点集**$S$

对贡献入点的**点集**$T$的每个子集$T'$

$p0_{T'}$求出$S$到$T'$没有一条出边的概率

$p1_{T'}$表示$S$到$T'$至少有一条出边的概率

我实现的时候因为不会正序枚举子集所以是取出来再reverse的

另外一些自己实现的细节

$s_S$表示$S$这个点集整体在三进制下平移的差量

$S=\sum 2^{a_i},$则$s_S=\sum 3^{a_i}$

然后我们就可以转移了

对一个有值的状态$(i,S)$

我们取出为$0$(要**被**扩展)的点集$S_0$,为$1$(要扩展)的点集$S_1$

然后枚举$S_0$中被加入到这一层的点集$T$

以$S_1$为出点集合处理以$S_0$为入点集合的$p_0,p_1$

那么$f_{i,S}\cdot p1_{T}\cdot p0_{S\oplus T}\to f_{i+1,S+s_{T}+s_{S_1}}$

跑得莫名很快？？


```cpp
#include<bits/stdc++.h>
#define N 13
#define STA 531442
#define mod 998244353
using namespace std;
int n,K,lg[1<<12],d[STA][13],p[N][N],s[1<<12],all[1<<12][N],part[1<<12][N],_[STA],f[N][STA],pw[N],ans,p0[STA],p1[STA];
inline int Mod(int x){return x>=mod?x-mod:x;}
inline int qpow(int a,int b){int res=1;while(b){if(b&1)res=1ll*res*a%mod;a=1ll*a*a%mod;b>>=1;}return res;}
inline void Div(int x){int t=x,tot=0;while(t)d[x][tot++]=t%3,t/=3;}
signed main(void){
	int i,k,x,y,a,b,S,T,S0,S1,_S;scanf("%d%d",&n,&K);
	T=n*(n-1);while(T--)scanf("%d%d%d%d",&x,&y,&a,&b),--x,--y,p[x][y]=1ll*a*qpow(b,mod-2)%mod;
	for(*pw=i=1;i<=n;++i)pw[i]=3ll*pw[i-1]%mod;
	for(i=2;i<1<<n;++i)lg[i]=lg[i>>1]+1;
	for(S=0;S<pw[n];++S)Div(S);
	for(S=0;S<(1<<n);++S){
		for(i=0;i<n;++i)if((S>>i)&1)s[S]=Mod(s[S]+pw[i]);
		for(x=0;x<n;++x){for(all[S][x]=1,i=S;i;i-=i&-i)y=lg[i&-i],all[S][x]=1ll*all[S][x]*(1ll-p[y][x]+mod)%mod;part[S][x]=Mod(1-all[S][x]+mod);
		}
	}
	for(f[0][1]=1,k=0;k<=K;++k){
		for(S=0;S<pw[n];++S)if(f[k][S]){
			for(S0=S1=i=0;i<n;++i)if(d[S][i]<2){(!d[S][i])?S0^=(1<<i):S1^=(1<<i);}
			if(!S0){ans=Mod(ans+f[k][S]);continue;}
			for(*_=0,T=S0;T;T=(T-1)&S0)_[++*_]=T;
			reverse(_+1,_+*_+1);
			for(*p0=*p1=i=1;i<=*_;++i)T=_[i],p0[T]=1ll*p0[T-(T&-T)]*all[S1][lg[T&-T]]%mod,p1[T]=1ll*p1[T-(T&-T)]*part[S1][lg[T&-T]]%mod;
			for(_S=S+s[S1],T=S0;T;T=(T-1)&S0)f[k+1][_S+s[T]]=(f[k+1][_S+s[T]]+1ll*f[k][S]*p1[T]%mod*p0[S0^T])%mod;
		}
	}printf("%d\n",ans);
	return 0;
}
```

---

## 作者：OoXiao_QioO (赞：3)

我们考虑设 $f_{d,S_1,S_2}$ 表示 $S_1$ 中的点到 $1$ 的距离小于 $d$，$S_2$ 中的点到 $1$ 的距离等于 $d$。然后枚举到 $1$ 的距离等于 $d + 1$ 的点集，这一部分复杂度是
$O(n\times 3^n)$，预处理一下不同情况的答案即可。

---

## 作者：Unnamed114514 (赞：0)

状压 dp。

定义 $dp_{L,state}$ 表示当前已经找完了深度为 $L$ 的点，此时状态为 $state$。

$state$ 定义如下：

- $0$：没有找到过。

- $1$：找到过且深度为 $L$。

- $2$：找到过且深度小于 $L$。

我们用二进制把为 $0$ 的状态提取出来枚举子集。

子集中的每一个都至少有一个 $1$ 向它连边，非自己不能有 $1$ 向它连边，这些都是可以 $O(n4^n)$ 初始化好的。

两个部分时间复杂度都是 $O(n4^n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,k,res1[1<<12][1<<12],res2[1<<12][1<<12],w[12][12],upd[1<<12],p[12],dp[12][531441];
int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1) s=s*a%mod;
		a=a*a%mod,b>>=1;
	}
	return s;
}
bool check(int state){
	for(int i=1;i<=n;++i){
		if(!(state%3)) return 0;
		state/=3;
	}
	return 1;
}
int dfs(int state,int lenth){
    if(check(state)) return 1;
    if(lenth==k) return 0;
	if(~dp[lenth][state]) return dp[lenth][state];
	dp[lenth][state]=0;
	int s1=0,s2=0,t=state;
	for(int i=0;i<n;++i){
		if(!(t%3)) s1|=(1<<i);
		if(t%3==1) s2|=(1<<i);
		t/=3;
	}
	t=s1;
	while(t){
		dp[lenth][state]=(dp[lenth][state]+dfs(state+upd[s2]+upd[t],lenth+1)*res1[s2][t]%mod*res2[s2][t^s1])%mod;
		t=(t-1)&s1;
	}
	return dp[lenth][state];
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1,u,v,x,y;i<=n*(n-1);++i){
		cin>>u>>v>>x>>y,--u,--v;
		w[u][v]=x*qpow(y,mod-2)%mod;
	}
	p[0]=1;
	for(int i=1;i<n;++i) p[i]=p[i-1]*3%mod;
	for(int i=0;i<(1<<n);++i) for(int j=0;j<(1<<n);++j){
		if(i&j) continue;
		res1[i][j]=1;
		for(int y=0;y<n;++y){
			if(!((j>>y)&1)) continue;
			int s=1;
			for(int x=0;x<n;++x){
				if(!((i>>x)&1)) continue;
				s=s*(1-w[x][y]+mod)%mod;
			}
			res1[i][j]=res1[i][j]*(1-s+mod)%mod;
		}
	}
	for(int i=0;i<(1<<n);++i) for(int j=0;j<(1<<n);++j){
		if(i&j) continue;
		res2[i][j]=1;
		for(int x=0;x<n;++x){
			if(!((i>>x)&1)) continue;
			for(int y=0;y<n;++y){
				if(!((j>>y)&1)) continue;
				res2[i][j]=res2[i][j]*(1-w[x][y]+mod)%mod;
			}
		}
	}
	for(int i=0;i<(1<<n);++i) for(int j=0;j<n;++j) if((i>>j)&1) upd[i]+=p[j];
	memset(dp,-1,sizeof(dp));
	cout<<dfs(1,0)<<endl;
	return 0;
}
```

---


# [THUPC 2021 初赛] 线段树

## 题目描述

线段树是小 L 最喜欢的数据结构，它能高效地解决许多实际问题。

给定一个正整数 $n$，小 L 构建出一棵下标属于整数区间 $[1, n]$ 的线段树：

- 初始线段树只有一个结点 $[1, n]$。
- 对于结点 $[L, R]$，若 $L < R$，则令 $mid = \left[ \frac{L + R}{2} \right]$（$[x]$ 表示不超过 $x$ 的最大整数），小 L 对这个结点建出两个子结点 $[L, mid]$、$[mid + 1, R]$。

小 L 定义了一个函数 $cover(a, b)$（$1 \le a \le b \le n$），表示用若干个线段树结点不重不漏地覆盖区间 $[a, b]$，则使用的线段树结点个数的最小值。

小 L 尝试使用这棵线段树解决某个复杂问题，并想要粗略地评估这棵线段树的性能。

具体来说，区间 $[1, n]$ 有 $\frac{n (n + 1)}{2}$ 个不同的子区间，如果小 L 从这 $\frac{n (n + 1)}{2}$ 个子区间中等概率随机地选取一个，将其记为 $[A, B]$，则小 L 认为 $cover(A, B)$ 的期望值可用于评估此线段树的性能。

小 L 想请你帮他计算出 $cover(A, B)$ 的期望值与 $\frac{n (n + 1)}{2}$ 的乘积对 $1, 000, 000, 007$ 取模的结果，可以发现此结果一定是一个整数。

## 说明/提示

**【样例解释 #1】**

$cover(1, 1) = 1$，$cover(2, 2) = 1$，$cover(3, 3) = 1$，$cover(1, 2) = 1$，$cover(2, 3) = 2$，$cover(1, 3) = 1$，故 $cover(A, B)$ 的期望 $= \frac{1 + 1 + 1 + 1 + 2 + 1}{6} = \frac{7}{6}$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
1
3
```

### 输出

```
7
```

# 题解

## 作者：xh39 (赞：12)

注:正解为暴力的优化,请先看暴力。

本篇题解中的时间复杂度均为一组数据中的时间复杂度,所以最终复杂度还要乘数据组数$t$。

## ?

> 小 L 想请你帮他计算出$cover(A,B)$的期望值与$\frac{n(n+1)}{2}$
  的乘积对$ 1, 000, 000, 007$ 取模的结果，可以发现此结果一定是一个整数。

为什么是整数?遇到乘...一定是整数先思考为什么,大部分时候都有利于做题。

任意选两种情况总共有$C_{n}^{2}=\frac{n(n+1)}{2}$种方案,所以题目就是要求$sum\{cover(i,j)\}(0<i<=j<=n)$,即所有cover的和。

## 暴力O(n)

貌似直接算答案时间复杂度为$O(n^2\times log_2(n))$,所以肯定不行。

于是想到了算贡献.可是怎么算贡献呢?

设f[n]为长度为n的线段树的贡献。left为左子树,right右子树。

我们可以来模拟一下转移的过程,转移的过程是一种类似点分治而非点分治的过程。

```cpp
        1,7
       /   \
     1,4    5,7
    / \     /  \
 1,2 3,4  5,6  7
 /\  /\   /\
1 2 3 4  5 6
(节点数为7的线段树)
```
首先,按照点分治的思路,先算子树内的贡献:$f[left]+f[right]$

然后算跨两子树间的贡献:$[1,7]$这个区间需从$[1,4]$选出一部分,$[5,7]$选出一部分,由于两个部分互不干扰,所以可以相加。

$[1,4]$的贡献将被裂开为两个区间$[1,4]和[5,r](r>=5)$,因为此贡献要跨两子树,所以r一定位于右子树。又因为$r$一定要在这棵树内,所以$r<=7$,所以$r$一共有$7-5+1=3(种)$取值。而不管r取哪一个,对左区间$[1,4]$不会构成影响,所以左子树的贡献为$3$。

同理,右子树贡献为$4$。那么我们可以得出结论:左子树将会被贡献$size[right]$次,右子树将会被贡献$size[left]$次。

那是不是$f[left]\times size[right]+f[right] \times size[left]$就是跨两子树的贡献了呢?

看起来似乎很正确,但模拟几组小数据会发现实际上大了。

我们多算了哪些呢?原来是在裂开$[1,7]$时,裂开成了$[1,4]和[5,7]$,而$cover(1,4)$包括了$[1,2]$的贡献。而我们在计算时就变成了$[1,2]和[5,7]$,显然区间不连续。

那怎么办呢?怎么避免不连续的区间?直接加工f肯定不行(至少我想了几种方向都不行),那我们就多设状态。

观察$[1,4]与[5,7]$如何才能构成一个连续的区间?先讨论左子树$[1,4]$的贡献。肯定区间$[1.4]$取出来的一段子区间必须右端点是$4$。换个说法:这个子区间必须是$[1,4]$的后缀,$[1,4],[2,4],[3,4]或[4,4]$。而右子树$[5,7]$的贡献一定是$[5,5],[5,6]或[5,7]$。

所以需增加2个状态:$fl[n]$表示长度为$n$的线段树的后缀区间的$cover和$(即$sum\{cover(i,n)\}(0<i<=n)$)。$fr[n]$表示后缀区间cover和。

至于这两个状态如何转移,应该很容易,这里就不再解释了。看下面的式子应该能看懂。不懂就画一棵线段树手动推一下。

$fl[n]=fl[left]+(fl[right]+right)-1$ 

注:+left的原因是每个右子树的前缀区间都需要左儿子来覆盖,即加left个1。

-1的原因是覆盖整个区间时会用左儿子和右儿子2个结点覆盖,事实上直接选用根节点就可以了。

同理,就不列$fr$了,具体见代码。

得出$f[n]=(f[left]+f[right])+(fr[left]\times size[right]+fl[right]\times size[left])$//注:这里加分间打括号的原因是区分子树内和跨两子树。

关于如何求left和right,就看你的线段树基础了。$size[left]=(size[root])/2向上取整,size[right]=size[root]/2向下取整$,~~至于怎么证,我也不知道。~~

暴力代码(由于反正会tle,就没开long long和取模了):
```cpp
#include<iostream>
using namespace std;
int fl(int n){
	if(n==1){ //边界条件。当只有1个结点时3个状态都为1。
		return 1;
	}
	int left,right=n>>1;
	left=n-right; //向上取整=n-向下取整。
	return fl(left)+fl(right)+right-1;
}
int fr(int n){
	if(n==1){
		return 1;
	}
	int left,right=n>>1;
	left=n-right;
	return fr(left)+left+fr(right)-1;
}
int fm(int n){
	if(n==1){
		return 1;
	}
	int left,right=n>>1;
	left=n-right;
	return fm(left)+fm(right)+fr(left)*(right)+fl(right)*(left)-1;
}
int main(){
	int t,n,i;
	cin>>t;
	for(i=0;i<t;i++){
		scanf("%d",&n);
		cout<<fm(n)<<"	"<<fl(n)<<"	"<<fr(n)<<endl;
	}
}
```
# 正解$O(log_{2}(n))$
发现递归查询了很多相同的状态,很容易想到记忆化。但是有$n<=10^{18}$,那么多状态数组存不下。这里有3种办法。

1.哈希。(状态较多时容易被卡,不推荐,除非是在没别的办法)

2.map。(时间复杂度变为$O(log_2(n)^{2}$),可能tle。(注意本题多组数据,需要乘$t=1000$,而map常数较大,递归常数也大,不冒这个风险,除非实在没别的办法)

3.本题解的方法,后面介绍。

观察我们需要用到哪些状态。

为方便,$(n+a)/b$表示为$n+a/b$,即先算加法。上节点为左子树。

$n<^{n+1/2<^{n+3/4}_{n+1/4}}_{n+0/2<^{n+2/4^{............}}_{n+0/4}}$

再画多一点节点(由于latex的一些性质,这里只画了3层),就会发现,第$i$层的节点只会是$n+a/(2^{i})(a为0至2^i的全排列)$

为什么a为全排列呢?可以用二进制解释。

一个第$i$层节点数为$n+a/b$的结点,左结点一定是$n+(a+2^i)/b$。右节点也为$n+a/b$。那么左节点即为二进制第$i$位为$1$。否则为$0$。

那么左右子树的二进制序列就变成了全排列。

那知道了$a$为$n+a/(2^i)$全排列。那么就可以得出一个性质:第$i$层子树大小要么为$(n/2^i)$,要么为$(n/2^i+1)$。

然后就得出了一个性质:同一层只有$2$种节点,且相差为$1$,这让我们想到了奇偶性讨论。那我们可以这样设状态。

$f[step][odd]$表示在第$step$层的节点为(奇/偶)的子树的f值。

然后这道题就解决了。代码不长,看起来有60行左右的原因是很多都是复制的。所以实际只有几个递推式是核心内容。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
long long l[60][2],r[60][2],m[60][2];
#define mod 1000000007
long long fl(long long n,int step){
	if(l[step][n&1ll]){
		return l[step][n&1ll];
	}
	if(n==1ll){
		return 1ll;
	}
	long long left,right=n>>1ll;
	left=n-right;
	l[step][n&1ll]=(fl(left,step+1)+fl(right,step+1ll)+right-1ll)%mod;
	return l[step][n&1ll];
}
long long fr(long long n,int step){
	if(r[step][n&1ll]){
		return r[step][n&1ll];
	}
	if(n==1ll){
		return 1ll;
	}
	long long left,right=n>>1ll;
	left=n-right;
	r[step][n&1ll]=(fr(left,step+1)+left+fr(right,step+1)-1ll)%mod; 
	return r[step][n&1ll];
}
long long fm(long long n,int step){
	if(m[step][n&1ll]){
		return m[step][n&1ll];
	}
	if(n==1ll){
		return 1ll;
	}
	long long left,right=n>>1ll;
	left=n-right;
	m[step][n&1ll]=(fm(left,step+1)+fm(right,step+1)+fr(left,step+1)*(right%mod)+fl(right,step+1)*(left%mod)-1ll)%mod;//left,right在做乘法时一定要先模mod,因为它们可能很大。
	return m[step][n&1ll];
}
int main(){
	long long t,i,n,t1,t2,t3;
	cin>>t;
	for(i=0;i<t;i++){
		memset(l,0,sizeof(l)); //与普通记忆化不同的是,一定要清空,因为对于不同的n,f[step][odd]的含义不一样了。
		memset(r,0,sizeof(r));
		memset(m,0,sizeof(m));
		scanf("%lld",&n);
		cout<<fm(n,0)<<endl;
	}
}
```
## 一些题外话
官方题解讲得有那么一定的清楚,本人只看懂了"算贡献"3个字。于是照着这3个字思考了一周。所以题解中有我的思考过程,可能会很啰嗦。

$\color{green}\text{Happy new year!}$

---

## 作者：Time_tears (赞：7)

因为能够影响答案的只有长度，所以不妨考虑设 $f_i$ 表示长度为 $i$ 时的答案，所以答案就为 $f_n$ 。

然后我们发现答案有 $4$ 种贡献 左儿子，右儿子，跨区间左儿子对右儿子，跨区间右儿子对左儿子的贡献，前两种就是 $f$ ,后两种可以维护出 $fl,fr$ 表示前缀，后缀的和，然后就可以递推了。

然后因为 $n$ 是1e18 的级别，自然不能 $O(n)$ 递推，一个比较好写的方法是记忆化，每次递归左右儿子，可以证明不同的长度只有 $O(\log n)$ 种。

```cpp
#include<bits/stdc++.h>
#define N 100005
#define mod 1000000007
using namespace std;
map<long long,long long>f,hz,qz;
inline long long read() {
	long long s=0,f=0;
	char ch=getchar();
	while(ch<48||ch>57)f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
void F(long long x) {
	if(f.find(x)!=f.end())return;
	long long mid=(1+x)>>1;
	F(mid),F(x-mid);
	f[x]=(f[mid]+f[x-mid]+mid%mod*qz[x-mid]+(x-mid)%mod*hz[mid]-1)%mod;
	qz[x]=(qz[mid]+x-mid+qz[x-mid]-1)%mod;
	hz[x]=(hz[x-mid]+mid+hz[mid]-1)%mod;
}
int main() {
	qz[1]=hz[1]=f[1]=1;
	qz[2]=hz[2]=2,f[2]=3;
	long long T=read(),x;
	while(T--)F(x=read()),printf("%lld\n",f[x]);
	return 0;
}
```



---

## 作者：littleKtian (赞：6)

题目让我们求所有 $cover(A,B)$ 的和。

考虑反过来算每个线段树结点的贡献。

然后就会想到[这道题](https://www.luogu.com.cn/problem/P6630)。

设结点 $P$ 表示区间为 $\left[l,r\right]$，记 $f(P)=l\times(n-r+1)$，即包含 $P$ 表示区间的区间个数。

容易发现每个结点 $i$ 的贡献即为 $f(i)-f(fa_i)$，其中 $fa_i$ 表示 $i$ 的父亲结点。特别的，根节点 $rt$ 的贡献即为 $f(rt)$。

稍微整理一下就能发现结果就是 $\sum\limits_{i\text{是叶}\atop \text{子结点}}f(i)-\sum\limits_{i\text{不是叶}\atop \text{子结点}}f(i)$。

注意到如果用 $l,r$ 来表示 $f(i)$ 难以将这么多结点统一起来，于是又想到了[这题](https://www.luogu.com.cn/problem/P2609)。

考虑用 $l$ 和结点表示区间的长度 $len$ 来代替 $r$，于是 $f(i)=l\times(n-(l+len-1)+1)=-l^2+(n-len+2)\times l$。

根据上面给的那题容易发现线段树每层最多只有两种不同区间长度的结点，只需要维护每层两种区间长度结点的 $l^2$ 和 $l$ 之和就能快速求出两者各自的 $f(i)$ 之和（维护这两个东西之前还需要维护对应结点个数）。至于是不是叶子结点直接判 $len$ 是否为 $1$ 即可。

复杂度 $O(t\log n)$。

核心代码
```cpp
void getans(LL le,int sl,int sf){ans=(ans+(le==1ll?1:-1)*((n-le+2)%p*sl-sf)%p+p)%p;}
void slo(LL le,int ln,int ll,int lf,int rn,int rl,int rf)
{
	getans(le,ll,lf),getans(le+1,rl,rf);
	if(le==1)
	{
		int tl=(2ll*rl+rn)%p,tf=(2ll*rf+2ll*rl+rn)%p;
		getans(1ll,tl,tf);
		return;
	}
	LL ne=le>>1;
	int nle=ne%p,lle=(ne+1)%p;
	int nef=1ll*nle*nle%p,lef=1ll*lle*lle%p;
	int nln,nll,nlf,nrn,nrl,nrf;
	if(le&1)
	{
		nln=ln,nrn=(ln+2ll*rn)%p;
		nll=(ll+1ll*ln*lle)%p,nrl=(ll+2ll*rl+1ll*rn*lle)%p;
		nlf=(lf+2ll*ll*lle+1ll*ln*lef)%p,nrf=(lf+2ll*rf+2ll*rl*lle+1ll*rn*lef)%p;
	}
	else
	{
		nln=(2ll*ln+rn)%p,nrn=rn;
		nll=(2ll*ll+1ll*ln*nle+rl+1ll*rn*lle)%p,nrl=rl;
		nlf=(2*lf+2ll*ll*nle+1ll*ln*nef+rf+2ll*rl*lle+1ll*rn*lef)%p,nrf=rf;
	}
	slo(ne,nln,nll,nlf,nrn,nrl,nrf);
}
```


---

## 作者：ix35 (赞：5)

似乎是不太一样的想法呢。

有一个熟知结论：区间 $[l,r]$ 在线段树上的区间定位数等于 $2\times (r-l+1)-|S|$，其中 $|S|$ 表示线段树上包含于 $[l,r]$ 的区间个数，这个结论使用森林中点边连通块的关系以及完满二叉树的叶结点与非叶结点关系容易得到。

接下来：

$$\sum\limits_{l=1}^n\sum\limits_{r=l}^n2\times (r-l+1)=2\times\sum\limits_{len=1}^nlen\times(n-len+1)$$

令 $s_i(n)$ 表示 $\sum\limits_{j=1}^n j^i$，那么上式等于：

$$2\times \Big((n+1)\times s_1(n)-s_2(n)\Big)$$

后面这个 $|S|$，设线段树结点集合为 $V$，点 $x$ 的左右端点为 $l_x,r_x$，那么：

$$\sum |S|=\sum\limits_{x\in V}l_x\times (n-r_x+1)$$

设 $c(n),sl(n),sr(n),slr(n)$ 分别表示 $[1,n]$ 线段树中的点数，左端点和，右端点和，左端点乘右端点之和，那么：

$$\sum |S|=(n+1)\times sl(n)-slr(n)$$

考虑分治，用左边加上右边加上根即可，注意右边需要有个将所有 $l,r$ 平移的过程，但是这个操作可以通过我们已有的信息和平移量直接得出。

然后使用记忆化搜索即可。



---

## 作者：Demoe (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P7143)

## 题意

- 对于一个有 $n$ 个点的线段树，求 $[1,n]$ 所有子区间在线段树上组成区间数的总和。

- 多次询问，对 $10^9+7$ 取模。

## 题解

考虑对区间 $[1,n]$ 求贡献。

令 $[1,n]$ 的左子结点为 $[1,l]$，右子结点为 $[l+1,n]$,$r=n-l$。

首先贡献包含 $[1,l]$ 和 $[l+1,n]$ 内的贡献，这个以此类推记忆化搜索即可。

---

重点是求左右都涉及的区间的贡献。

此时左子结点包含了 $l$，右子结点包含了 $l+1$。

我们令 $[1,n]$ 内包含 $1$ 的区间贡献为 $l_n$，包含 $n$ 的区间的贡献为 $r_n$。

那么易得左右都涉及的区间的贡献为 $r_l\times r+l_r\times l-1$。

这里 $-1$ 是因为 $[1,n]$ 区间在两次都计算到了。

---

接下来问题转化到如何求 $l_n$ 和 $r_n$。

以下阐述 $l_n$ 的求法，$r_n$ 以此类推。

将 $l_n$ 的贡献分成两部分。

第一部分相当于 $l_l$。

第二部分包含了左子结点，在右子结点上相当于 $l_r$。

那么 $l_n=l_l+l_r+r-1$。

这里 $-1$ 是因为把 $[1,n]$ 当成了 $[1,l]$ 和 $[l+1,n]$ 两个区间计算，实际上贡献为 $1$。

类似地，$r_n=r_r+r_l+l-1$。

---

综上，有 $sum_n=sum_l+sum_r+r_l\times r+l_r\times l-1$。

记忆化搜索即可。

可以用 Hash, map 等东西记录。

时间复杂度 $O(T\log n \times k)$。（其中 $O(k)$ 是记录的复杂度）

---

## 代码

```cpp
const ll mod=1e9+7;
int T;ll n;
struct node{ll l,r,sum;};
map<ll,node> f; 

inline void dfs(ll x){
	if(f[x].sum) return ;
	ll l=x/2ll,r=x-l;
	dfs(l),dfs(r);
	f[x]=(node){(f[l].l+f[r].l+r-1ll+mod)%mod,(f[r].r+f[l].r+l-1ll+mod)%mod,((f[l].sum+f[r].sum+r%mod*f[l].r%mod+l%mod*f[r].l%mod-1ll+mod)%mod+mod)%mod};
}

// ---------- dfs ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(T);
	f[1]=(node){1,1,1};
	while(T--){
		rd(n);dfs(n);
		wr(f[n].sum);puts("");
	}
	return 0;
}
```

---

## 作者：不知名用户 (赞：3)

题意：给定一棵总长度为 $n$，线段 $[L,R]$ 分成 $[L,\lfloor\frac{L+R}{2}\rfloor],[\lfloor\frac{L+R}{2}+1\rfloor,R]$ 的线段树，求覆盖 $C_n^2$ 每个区间所需最小线段数和。

根据线段树的性质易分析到：

对于一个区间包含在一个线段树上的线段中

- 如果是整个线段，那么只用一个线段即可

- 如果只在该线段的两个子线段的左/右中一个，递归到左/右子线段即可

- 否则横跨左右子线段，对于左/右子线段的后缀/前缀处理即可

~~容易发现~~线段树上所有子线段的长度集合的大小为 $\log_2^n$ 等级的。记搜即可，维护所有子区间所需覆盖线段的数量和，覆盖前缀/后缀区间所需线段数量和即可，细节见代码注释，复杂度为线段个数 $\Theta(\log_2^n)$：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
map<int,int>f,p,s;
//总线段个数，前缀线段数和，后缀线段个数和 
void dp(int x)
{
	if(f.count(x)) return;
	int mid = 1 + x >> 1;
	//分成了长度为 mid 和 x-mid 的两个区间 
	dp(mid), dp(x-mid);
	//分治处理，容易发现做记搜的次数是 log2(n) 级别的 
	f[x] = (f[mid] + f[x-mid] + (x - mid) % mod * s[mid] + mid % mod * p[x-mid] - 1) % mod;
	//分只在左边或右边；跨过左右
	//乘 x-mid,mid 是因为统计一个右边区间的时候左端点可以取多个
	//最后 -1 是因为整个区间只用一个线段，不用分左右两个线段 
	p[x] = (p[mid] + x - mid + p[x-mid] - 1) % mod;
	//只在左边；跨过左边的时候长度为 mid 的线段被统计了 x-mid 次 
	//最后 -1 是因为整个区间只用一个线段，不用分左右两个线段 
	s[x] = (s[x-mid] + mid + s[mid] - 1) % mod;
	//只在右边；跨过左边的时候长度为 x-mid 的线段被统计了 mid 次 
	//最后 -1 是因为整个区间只用一个线段，不用分左右两个线段 
}
signed main()
{
	f[1] = p[1] = s[1] = 1, f[2] = 3, p[2] = s[2] = 2;
	//预处理 
	int t, x;cin>>t;
	while(t--) cin>>x, dp(x), cout<<(f[x]+mod)%mod<<'\n';
	return 0;
}
```

---

## 作者：Little09 (赞：3)

当时比赛时居然被我做出来了，感觉挺舒服的。

按照题意会发现是要求所有 $cover$ 的和。我们定义 $ans[n]$ 表示一个下标属于整数区间 $[1, n]$ 的线段树的答案。

观察线段树的构造法，考虑分治。把长度为 $n$ 的线段树分成两个线段树计算再合并。关键在于合并。

发现只记录 $ans$ 的话难以合并，考虑定义 $l[n]$ 表示区间 $[1,n]$ 的线段树的 $cover(1,i)$ $(1\le i\le n)$，意思是左端点为 $1$ 的答案。$r[n]$ 同理表示右端点为 $n$。

于是发现分治的 $ans$ 合并可以实现。大线段树的答案可以分为三部分：

1. cover 范围在左线段树内
2. cover 范围在右线段树内
3. cover 范围横跨左、右线段树

于是就可以分治做了。处理 $l,r$ 也不难。

我这里采用记忆化，用 map 存储答案，复杂度是 $O(T\times \log^2 n)$，显然能过。两个 $\log$ 分别是分治和 map。

注意溢出问题。当时我 WA 了很多发。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n;
const long long mod=1000000007;
struct pp
{
	long long ans,l,r;
};
map<long long,pp>dp;
void f(long long x)
{
	if (dp[x].ans>0) return;
	long long l=x/2ll,r=x-l;
	f(l),f(r);
	long long ans1,l1,r1;
	l1=(dp[l].l+dp[r].l+r+mod-1ll)%mod;
	r1=(dp[r].r+dp[l].r+l+mod-1ll)%mod;
	ans1=((dp[l].r*(r%mod)+((dp[r].l*(l%mod))%mod+mod-1ll)%mod+dp[l].ans)%mod+dp[r].ans)%mod;
	dp[x].l=(l1+mod)%mod,dp[x].r=(r1+mod)%mod,dp[x].ans=(ans1+mod)%mod;
	return;
}
int main()
{
	cin >> T;
	dp[1].ans=1ll,dp[1].l=1ll,dp[1].r=1ll;
	while (T--)
	{
		cin >> n;
		f(n);
		cout << dp[n].ans << endl;
	}
	return 0;
}
```


---

## 作者：RainWetPeopleStart (赞：1)

一种较劣的解法。

首先，先考虑分治，记 $f_x$ 表示当前考虑的结点长度为 $x$ 的答案，发现这样不好转移。

再记 $p_x$ 表示长度为 $x$ 的结点只考虑所有前缀的答案，类似的，记 $s_x$ 表示所有后缀的答案。

考虑转移，记 $l_x$，$r_x$ 分别表示长度为 $x$ 的结点的左右儿子的长度。

此时，有 $p_x=p_{l_x}+p_{r_x}+r_x-1$，$s_x=s_{l_x}+s_{r_x}+l_x-1$。

依此，可推得 $f_x=f_{l_x}+f_{r_x}+p_{r_x}l_x+s_{l_x}r_x-1$。

直接记忆化搜索即可，复杂度 $O(T\log^2n)$。

代码：


```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define mk make_pair
#define fi first
#define se second
#define ll long long
using namespace std;
const int mod=1e9+7;
map<ll,ll> f,pre,suf,vis;
void dfs(ll p){
    if(vis[p]) return;
    vis[p]=1;
    if(p==1){
        pre[p]=1,suf[p]=1,f[p]=1;
        return ;
    }
    dfs((p+1)/2);dfs(p/2);
    ll L=(p+1)/2,R=p/2;
    pre[p]=(pre[L]+pre[R]+R+mod-1)%mod;
    suf[p]=(suf[L]+suf[R]+L+mod-1)%mod;
    f[p]=(f[L]+f[R]+pre[R]*(L%mod)%mod+suf[L]*(R%mod)%mod+mod-1)%mod;
}
int main(){
    int t;cin>>t;
    while(t--){
        ll x;cin>>x;f.clear(),pre.clear(),suf.clear(),vis.clear();
        dfs(x);
        cout<<f[x]<<endl;
    }
    return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7143)

# 思路：

1. 计算点的贡献：

    考虑一个区间对应的节点个数，就是把这个区间扔到线段树上时，节点裂开的次数 $+1$（显然一次裂开会增加一个点，$+1$ 是因为最初有一个点）。

    所以我们考虑计算每个点裂开的方案数，这就等价于求有多少个区间跨越这个节点的中点且不完全包含这个节点。

2. 动态规划:

    假设一个节点在原序列中对应区间的左边有 $l$ 个位置，右边有 $r$ 个位置，并设这个点两个儿子对应区间大小分别为 $ls$ 和 $rs$。

    那么能使得这个点裂开的区间可以分成三类：被这个点包含、完全包含左儿子、完全包含右儿子。

    总计算式就应该是 $(ls\times rs-1)+l\times (rs-1)+r\times (ls-1)$。

    现在我们想 dp 这玩意，$ls$ 和 $rs$ 是可以根据当前节点对应区间大小 $n$ 直接计算的，且由于这是一棵标准线段树，可能的区间大小只有 $O(\log n)$ 种，可以计入状态。但如果我们把 $l$ 和 $r$ 一同维护进状态里显然爆炸。

    但根据我们之前总计算式的形式，发现一个点的贡献可以表示为 $a+l\times b+r\times c$。

    所以我们设 $F_n,L_n,R_n$ 表示一个大小为 $n$ 的节点整棵子树的贡献为 $F_n+l\times L_n+r\times R_n$。

    从左子节点向上转移的贡献为 $F_{ls}+l\times L_{ls}+(r+rs)\times R_{ls}$，即 $(F_{ls}+rs\times R_{ls})+l\times L_{ls}+r\times R_{ls}$，依然可以保持这个形式不变，右子节点向上转移同理。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
const int mod=1000000007;
int T,n;
map<int,int> F,L,R;
void solve(const int& n){
	if(F.count(n)){
		return;
	}
	int ls=n+1>>1,rs=n-ls;
	Solve(ls);
	Solve(rs);
	F[n]=(F[ls]+F[rs]+rs%mod*R[ls]+ls%mod*L[rs]+(ls%mod)*(rs%mod)-1)%mod;
	L[n]=(L[ls]+L[rs]+rs-1)%mod;
	R[n]=(R[ls]+R[rs]+ls-1)%mod;
}
signed main(){
	cin>>T;
	F[1]=L[1]=R[1]=0;
	while(T--){
		cin>>n;
		solve(n);
		cout<<(F[n]+(n%mod)*(n%mod+1)/2)%mod<<endl;
	}
	return 0;
}
```

---

## 作者：cosf (赞：0)

## [P7143](https://www.luogu.com.cn/problem/P7143)

这里只讲单次询问。

其实本题求的就是 $\sum_{l = 1}^n\sum_{r = l}^ncover(l, r)$。

二次分治。一次分治答案，一次分治前缀。

先讲分治答案。

显然，假设当前我们处理的区间为 $[1, n]$，令 $mid = \lfloor\frac{n + 1}{2}\rfloor$。则，所有区间可以分为：两个端点都在 $[1, mid]$ 内的、两个端点都在 $[mid + 1, n]$ 内的、两个端点分别在 $[1, mid]$ 和 $[mid + 1, n]$ 内的。

前两种是子问题，后面一种则需要讨论。显然，$mid$ 和 $mid + 1$ 一定不在同一个节点当中（除了 $[1, n]$）。那么，所有这样的区间可以描述为 $[1, mid]$ 的一个后缀和 $[mid + 1, n]$ 的一个前缀。那么，所有这样区间的 $cover$ 和就等于 $[1, mid]$ 的所有后缀的 $cover$ 和**乘以** $[mid + 1, n]$ 的所有前缀的 $cover$ 和。这就引出了第二个分治。

前缀和后缀处理方式相似，这里只说说前缀。

假设处理的区间还是 $[1, n]$。显然，前缀分两种：长度大于一半的和长度小于一半的。大于一半的相当于小于一半的多了一个覆盖区间（前半段）。所以，求前缀就被划分为了两个子问题，继续分治。

那么，最后来讨论一下一共会分治几次。

对于区间长度 $n$，如果它是偶数就递归 $\lfloor\frac{n}{2}\rfloor$，奇数就递归 $\lfloor\frac{n}{2}\rfloor$ 和 $\lfloor\frac{n}{2}\rfloor + 1$。

可以证明，所有能递归到的区间长度一定是 $\lfloor\frac{n}{2^k}\rfloor$ 或 $\lfloor\frac{n}{2^k}\rfloor + 1$ 之一，一共 $2\log n$ 个，用数组存即可。

因为前缀和后缀本质还是稍有差距的，所以最终应该是有 $6$ 倍常数，时间复杂度为 $O(\log n)$。

有一个比较玄学的东西：假设所有关于前缀和后缀的需要分治的东西都计算完了，即可以 $O(1)$ 求，那么完全不记忆化地暴力地分治答案是 $O(\sqrt{n})$ 的。不会证，反正是对的，也过不了此题。

大概可能是 $n$ 是形如 $(101010\dots)_2$ 的时候可以达到 $O(\sqrt{n})$，其他时候一定不行吧。


---


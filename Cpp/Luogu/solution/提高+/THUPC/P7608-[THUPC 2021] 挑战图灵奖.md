# [THUPC 2021] 挑战图灵奖

## 题目背景

图染色问题是这样的——给定一个 $n$ 个点，$m$ 条边的图，要求将每个点染上一种颜色，满足任意有边相连的两个点颜色不同，问最少需要多少种颜色。众所周知，图染色是 NPC 问题之一，如果有人能在多项式时间内解决图染色问题，那就相当于证明了 P = NP，恭喜你，下一位图灵奖得主非你莫属！

## 题目描述

今天，你的好朋友——敏珂找到了你，宣称他证明了半个图染色问题，希望你帮他看看他的做法对不对，如果你能帮他验证，他会考虑与你分享图灵奖的奖金。敏珂宣称自己解决的问题是这样的：对于一个 $n$ 个点的无向图，图上所有节点编号为  $1,2,\ldots, n$，两点之间有连边，当且仅当两点编号在模 $n$ 意义下相差不超过 $k$，即 $(x,y)$ 之间有一条无向边，当且仅当 $x \neq y$ 且存在 $i$ 满足 $1 \le i \le k$，

$$(x+i) \equiv y \pmod n$$ 

或 

$$(y+i) \equiv x \pmod n $$

，他能够快速求出这个图的染色数。作为评审，你只需要解决一个判定性问题——对于每组数据，敏珂会给出三个正整数 $n$，$k$ 和 $x$，表示在给定 $n$ 和 $k$ 时（$n, k$ 的意义如上文所述），他认为这个图的**染色数**是 $x$，你需要判断他的答案是否正确。

如果你认为他的答案是**正确**的，输出一行 `Correct, but it doesn't necessarily mean that you can win the Turing Award.`；如果你认为他的答案是**错误**的，在第一行输出 `Wrong, don't cheat me, you are too far away from the Turing Award.`。为了让你的答案更有信服力，你还需要在第二行输出一个字符 `0` 或 `1`，`0` 表示你认为敏珂的答案小于这个图的实际染色数，`1` 表示你认为他的答案大于这个图的实际染色数；如果你认为这个问题**以当下计算机算力无法作出准确判断**，输出一行 `The problem is unsolvable, please stop cheating me, Mr.Minke.`。

## 说明/提示

**【样例解释】**

很显然，给 $1 \sim 6$ 号点分别染色为 $1, 2, 3, 1, 2, 3$ 是可行的，所以 $n = 6$，$k = 2$ 情况下对应的染色数为 $3$。

**【提示】**

1. 如果没有 idea，请再次阅读题面给的数据范围，也许能对解题有一些帮助。

2. Hint 1 可能没有用。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_1/tree/master](https://github.com/yylidiw/thupc_1/tree/master) 查看。

## 样例 #1

### 输入

```
6 2 4
```

### 输出

```
Wrong, don't cheat me, you are too far away from the Turing Award.
1
```

# 题解

## 作者：Time_tears (赞：8)

原题等价于给 $n$ 个点的环染色，不能有连续 $k+1$ 个点的中颜色存在 $2$ 个相同。

考虑当 $n$ 很大的时候此时答案不是 $k+1$ 就是 $k+2$，因为可以用 $k+1,k+2$ 去凑出 $n$。

当 $n$ 不大的时候暴力枚举 $ans$ 从 $k+1$ 到 $2k$，当能用这些数凑出 $n$ 时，此时就是最小的答案。

算出答案后与 $x$ 比较即可。

```cpp
#include<bits/stdc++.h>
#define Mx 1000005
using namespace std;
char N[Mx],X[Mx];
int n,k,x;
void Check(int a,int b) {
	if(a==b)puts("Correct, but it doesn't necessarily mean that you can win the Turing Award.");
	if(a<b)puts("Wrong, don't cheat me, you are too far away from the Turing Award.\n1");
	if(a>b)puts("Wrong, don't cheat me, you are too far away from the Turing Award.\n0");exit(0);
}
int main() {
	scanf("%s%d%s",N+1,&k,X+1);
	if(strlen(X+1)>=4)return puts("Wrong, don't cheat me, you are too far away from the Turing Award.\n1"),0;
	for(int i=1,len=strlen(X+1); i<=len; ++i)x=x*10+X[i]-'0';
	if(strlen(N+1)>5) {
		for(int i=1,len=strlen(N+1); i<=len; ++i)n=(n*10+N[i]-'0')%(k+1);
		if(n==0)Check(k+1,x);else Check(k+2,x);
	} else {
		for(int i=1,len=strlen(N+1); i<=len; ++i)n=n*10+N[i]-'0';
		if(n<k+1)Check(n,x);
		int tmp=n/(k+1),tt=n%(k+1);
		for(int ans=0; 1; ++ans)if(tmp*ans>=tt)Check(k+1+ans,x);
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 思路

实现如果 $n \ge 10^{100}$ 那么很显然计算机无法解决，但是在本题就不一样了，所以实际上无解的情况没有用啊。

我们现在来考虑怎么样连边（因为我们不可能暴力去连边的）。别看题目中什么模不摸的，实际上就是把 $1\sim n$ 连成一个环，对于每个点，与左侧和右侧各 $k$ 个最近的点有连边。画图之后会发现对称美（bushi）。

其实换一种说法就是在环上连续的长度为 $k+1$ 的任意区间不能有两个相同的颜色罢了。这种情况太特殊了，甚至连半个染色也算不上吧。

为了让长度为 $k+1$ 的任意区间不能有两个相同的颜色，很显然答案最少是 $k+1$。那么答案有没有可能更大呢？还是有可能的。


出现这种情况是本质问题就是事实上在上面的图中每个点和相邻 $4$ 个点都有连边。因为本题的 $k$ 不大，并且与 $n$ 有一定的差距，所以为了降低思维难度，我们可以在 $k$ 与 $n$ 差距不大时暴力枚举答案，或者二分也可，在差距较大时，我们判定一下 $k+1,k+2\dots$ 即可，事实上，如果 $n$ 是 $k+1$ 的倍数，那么答案就是 $k+1$，否则就是 $k+2$。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=1e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,m,p,q,T,s[N],ans,k,x;

struct node{
	int n;
	string s;
}nn,xx;

void cmp(int a) {
	if(a==x)cout<<"Correct, but it doesn't necessarily mean that you can win the Turing Award.";
	else if(a<x)cout<<"Wrong, don't cheat me, you are too far away from the Turing Award.\n1";
	else cout<<"Wrong, don't cheat me, you are too far away from the Turing Award.\n0";
}

signed main(){
	cin>>nn.s>>k>>xx.s;

	if(xx.s.size()>100000){
		cout<<"Wrong, don't cheat me, you are too far away from the Turing Award.\n1";
		return 0;
	}
	for(int i=0;i<xx.s.size();i++)xx.n=(xx.n*10+xx.s[i]-'0');
	x=xx.n;
	
	if(nn.s.size()>100000) {//区别对待
		for(int i=0;i<nn.s.size();i++)nn.n=(nn.n*10+nn.s[i]-'0')%(k+1);
		if(nn.n==0)cmp(k+1);
		else cmp(k+2);
	} else {
		for(int i=0;i<nn.s.size();i++)nn.n=(nn.n*10+nn.s[i]-'0');
		
		if(nn.n<k+1){
			cmp(nn.n);
			return 0;
		}
      
		int tmp=nn.n/(k+1);
		int ans=0;
		while(tmp*ans<nn.n%(k+1))ans++;
		cmp(k+1+ans);
	}
	
	return 0;
}

```




---


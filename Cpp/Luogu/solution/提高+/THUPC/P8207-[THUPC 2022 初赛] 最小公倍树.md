# [THUPC 2022 初赛] 最小公倍树

## 题目背景

听说有人嫌题面描述都太长了。

## 题目描述

对于任意 $V\subset\mathbb{N}^*$，$|V|<+\infty$，构造一张无向完全图 $G=(V,E)$，其中 $(u, v)$ 的边权为 $u,v$ 的最小公倍数 $\mathrm{lcm}(u, v)$。称 $G$ 的最小生成树为 $V$ 的最小公倍树（LCT, Lowest Common Tree）。

现在给出 $L, R$，请你求出 $V={L, L+1, \cdots, R}$ 的最小公倍树 $LCT(V)$。

## 说明/提示

【样例解释】

其中一种最小公倍树上的边为 $(3, 4), (3, 5), (3, 6), (3, 7), (4, 8), (3, 9), (5, 10), (3, 11), (3, 12)$。

【数据范围】

对于 $100%$ 的数据，保证 $1\le L\le R\le 10^6$，且 $R-L\le 10^5$。

## 样例 #1

### 输入

```
3 12```

### 输出

```
126```

## 样例 #2

### 输入

```
6022 14076```

### 输出

```
66140507445```

## 样例 #3

### 输入

```
13063 77883```

### 输出

```
3692727018161```

## 样例 #4

### 输入

```
325735 425533```

### 输出

```
1483175252352926```

# 题解

## 作者：Doubeecat (赞：20)

> [THUPC2022 初赛 A.最小公倍树](https://thupc2022.thusaac.com/#!/contest/2/problem/0)
>
> 给定一个点编号在 $[L,R]$ 范围内的完全图，边 $(u,v)$ 的权值为 $\mathrm{lcm}(u, v)$，请你求出这张图的最小生成树权值和。
>
> $L,R \leq 10^6,R - L \leq 10^5$

<!--more-->

## 解题思路：

Kruskal 优化建图。

观察到如果直接建图的时间复杂度是 $\mathcal{O}((R-L)^2	)$ 的，无法接受。但是发现在这个过程中，有很多边实际上是可以省略的，接下来来发掘一下这些边的性质。

首先我们有 
$$
\mathrm{lcm}(u, v) = \frac{u\times v}{\mathrm{gcd}(u,v)}
$$
这实际上启发了我们从 $\mathrm{gcd}(u,v)$ 的角度进行思考，我们发现，如果将两个有共同因子的点连边，这条边的权值是较小的。观察到 $L,R \leq 10^6$，这启发我们去枚举这个因子。同时我们发现，如果对于一个因子 $x$ 来说，在 $[L,R]$ 里的数都满足 $kx,(k+1)x\dots (k+p)x$ 这样的形式，显然对于 $(k+1)x$ 及后面的数，向 $kx$ 连边是最优秀的，这样我们对于一个因子最多建边数量为 $\lfloor\frac{R-L}{x}\rfloor$ 的。

而我们可以枚举因子，因子的范围是 $[2,R]$ ，最后我们建边的数量就应该是 $\lfloor\frac{R-L}{2}\rfloor + \lfloor\frac{R-L}{3}\rfloor  + \dots + \lfloor\frac{R-L}{R}\rfloor$ 根据调和级数，这个东西的边数是 $\mathcal{O}((R-L) \log R)$ 的，实际上这个上界很松，具体数据会更小，极限数据大概是 $10^5$ 左右的，建出边后跑 Kruskal 就过了。

时间复杂度  $\mathcal{O}((R-L) \log ^2(R-L))$ 。

## 代码：

```cpp
const int N = 1e6 + 10;

int l,r,f[N],buc[N];
bool vis[N];

ll gcd(ll a,ll b) {
    return !b ? a : gcd(b,a%b);
}

ll lcm(ll a,ll b) {
    return a / gcd(a,b) * b;
}

int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}

struct node {
    int l,r;
    ll w;
    friend inline bool operator < (const node &a,const node &b) {
        return a.w < b.w;
    }
};

vector <node> edge;

void Kruskal() {
    sort(edge.begin(),edge.end());
    int cnt = 0;
    ll ans = 0;
    for (auto e : edge) {
        int x = e.l,y = e.r;ll w = e.w;
        if (find(x) != find(y)) {
            //printf("%d %d %lld\n",x,y,w);
            f[max(find(x),find(y))] = min(find(x),find(y));
            ans += w;
        }
    }
    printf("%lld\n",ans);
}

signed main() {
    read(l,r);
    ll ans = 0;
    for (int i = l;i <= r;++i) f[i] = i,buc[i] = 1;
    for (int i = 2;i <= r;++i) {
        //if (vis[i]) continue;
        int cnt = 0,fis = 0;
        
        for (int j = i;j <= r;j += i) {
            if (buc[j] && !fis) fis = j;
            if (buc[j]) edge.push_back((node){fis,j,lcm(fis,j)});
            vis[j] = 1;
        }

        if (i >= l) edge.push_back((node){fis,l,lcm(fis,l)});
    }
    Kruskal();
	return 0;
}

```

---

## 作者：Pekemetier (赞：8)

考虑 Kruskal ，我们需要动态维护当前最小的边。但是维护所有边肯定是不行的，我们考虑通过 $\text{lcm}$ 的性质进行优化。

首先我们注意到，我们不是只能维护所有最小公倍数，还可以维护那些不是最小，但是是公倍数的数，因为它们显然不会是最优的。

其次注意到对于一个公因子 $k$ ，它所产生的（当前可能被选到的）连边，一定是 $k$ 的倍数中最小的两个不在同一集合的数。更具体地，一个数一定是大于等于 $l$ 的第一个 $k$ 的倍数，另一个数一定是最小的不与它同一集合的 $k$ 的倍数。（这里由上面的性质，先不管 $k$ 是不是它们的最大公约数）

根据这个性质，每个 $k$ 最多只会建立 $\frac{R-L+1}k-1$ 条边，因为每条边一定有一个端点是大于等于 $l$ 的第一个 $k$ 的倍数。

因此我们只需要维护这些边就可以了。显然这些边只有 $O(n\log n)$ 个（$n=R-L+1$）。

一种方法是直接维护所有这些边，使用 `std::sort` 排序，并用并查集维护联通。

还有一种节约空间的方法是对于 $1$ 到 $R-L$ 的每一个 $k$ ，维护它建的边的右端点已经跑到了哪个倍数。由第二个性质可知，右端点不可能越过一个还没有选的数就去选后面更大的数，因此只需要在当前所有 $k$ 第一个还未跑到的数中，选一个最小的即可。可以使用 `std::priority_queue` 维护。这种方法理论上会更快些，但具体速度取决于 `priority_queue` 的速度。

我这里采用的是第二种写法。

Code：
```cpp
typedef long long ll;
int l,r,fa[1000001];
ll ans;
struct node{
	int x,pl,pr;
	ll val;
	bool operator<(const node&y)const{
		return val>y.val;
	}
};
priority_queue<node>q;
int find(int x)
{
	if(fa[x])return fa[x]=find(fa[x]);
	return x;
}
int main()
{
	scanf("%d%d",&l,&r);
	for(int i=1;i<r-l+1;++i)
	{
		int pl=(l+i-1)/i*i,pr=pl+i;
		if(pr<=r)
			q.push((node){i,pl,pr,(ll)pl*pr/i});
	}
	for(int num=1;num<=r-l;++num)
	{
		node x=q.top();q.pop();
		while(find(x.pl)==find(x.pr))
		{
			x.pr+=x.x;
			if(x.pr<=r)
			{
				x.val=(ll)x.pl*x.pr/x.x;
				q.push(x);
			}
			x=q.top();q.pop();
		}
		ans+=x.val;
		fa[find(x.pl)]=find(x.pr);
		x.pr+=x.x;
		if(x.pr<=r)
		{
			x.val=(ll)x.pl*x.pr/x.x;
			q.push(x);
		}
	}
	printf("%lld",ans);
}
```


---

## 作者：_Ch1F4N_ (赞：7)

考虑下怎么减少边数。去掉无效边。

首先连两条边 $x,y$ 的代价是 $\frac{x \times y}{\gcd(x,y)}$，考虑枚举 $\gcd(x,y) = w$ 后对于 $w \times i,w \times j$ 以 $w \times i \times j$ 的代价连边，这样包含了一些不优边和所有优秀边（$w = \gcd(x,y)$ 的 $x,y$），所以对正确性无影响。

不妨令 $mi$ 为 $[L,R]$ 中 $w$ 的最小倍数除以 $w$ 的结果，在 $w \times i,w \times j$ 连边前，你发现 $w \times i,w \times j$ 都会已经与 $w \times mi$ 联通（kruskal 贪心地从小往大加边），所以只用考虑所有 $wi$ 连出的边即可，因此总边数是 $O((R-L) \log (R-L))$ 的，再跑一遍 kruskal 即可做到 $O((R-L) \log^2 (R-L))$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn =4e6+100;
int tot;
struct node{
    int u,v,w;
}edge[maxn];
bool cmp(node a,node b){
    return a.w<b.w;
}
int fa[maxn];
int found(int u){
    if(fa[u]==u){
        return u;
    }
    else{
        return fa[u]=found(fa[u]);
    }
}
int res=0;   hg
signed main(){
    int l,r;
    cin>>l>>r;
    for(int i=l;i<=r;i++) fa[i]=i;
    for(int i=1;i<=r;i++){
        int v=ceil(l*1.0/i)*i;
        for(int j=ceil(l*1.0/i)*i;j<=r;j+=i){
            if(v!=j){
                edge[++tot].u=v;
                edge[tot].v=j;
                edge[tot].w=v*j/__gcd(v,j);
            }
        }
    }
    sort(edge+1,edge+tot+1,cmp);
    for(int i=1;i<=tot;i++){
        int u=edge[i].u;
        int v=edge[i].v;
        int w=edge[i].w;
        if(found(u)!=found(v)){
            //cout<<u<<' '<<v<<' '<<w<<'\n';
            fa[found(u)]=found(v);
            res+=w;
        }
    }
    cout<<res;
}

```

---

## 作者：断清秋 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P8207)

嗯……我赛时就过了这一个题，纪念一下。

题意就是给你 $r-l+1$ 个点，点从 $l \sim r$ 编号，边 $(u,v)$ 的边权为 $\operatorname{lcm}(u,v)$，求这些点构成的无向完全图的最小生成树。

为复杂度记录方便，令 $n=r-l$。

首先暴力连边肯定是 $O(n^2 \log n)$ 的。

然后考虑优化，因为只需要找一棵树，发现有一些边肯定用不上，比如 $\operatorname{lcm}(u,v)=u \times v$，那这条边肯定是比较失败的。

众所周知 $\operatorname{lcm}(u,v)=\dfrac{uv}{\gcd(u,v)}$，所以应该连边的时候让 $\gcd(u,v)$ 尽可能大。

然后你可以发现这个 $l,r \le 10^6$，于是考虑枚举约数。设枚举的约数为 $x$，然后所有在 $[l,r]$ 内形如 $kx,(k+1)x,(k+2)x$ 的数都可以互相连边。

但是这样边的数量太多了，考虑优化，发现 $(k+1)x$ 及之后的数都可以只向 $kx$ 连边，这样显然不劣于全部连边。

于是只需要枚举 $x$，找出第一个在 $[l,r]$ 内的 $x$ 的倍数即可。然后为了保证联通，所有数都要再跟 $l$ 连边。

然后这样就处理出一张图，直接上 Kruskal 即可。

复杂度分析：首先根据调和级数，建边的数量肯定是 $n \log n$ 级别的，所以 Kruskal 的复杂度就是 $O(n \log (n \log n))=O(n \log n)$

然后看枚举约数的复杂度，这个根据调和级数是 $O(r \log n)$。

所以总时间复杂度是 $O(r \log n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define back return
#define ri register int
#define ull unsigned ll
using namespace std;
ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	back x*f;
}
ll gcd(ll a,ll b)
{
	if(!b)
		back a;
	back gcd(b,a%b);
}
ll l,r,ans;
int fa[1000005];
ll find(ll x)
{
	if(fa[x]==x)
		back x;
	back fa[x]=find(fa[x]);
}
struct node
{
	ll x,y,t;
}a[10000005];
bool cmp(node a,node b)
{
	back a.t<b.t;
}
int main()
{
	l=read(),r=read();
	for(ri i=l;i<=r;i++)
		fa[i]=i;
	int cnt=0;
	for(ri i=1;i<=r-l+1;i++)
	{
		ll f=0;
		for(ri j=1;j*i<=r;j++)
			if(j*i>=l)
			{
				if(!f)
				{
					f=j*i;
					a[++cnt].x=l,a[cnt].y=f,a[cnt].t=l*f/gcd(l,f);
				}		
				else
					a[++cnt].x=f,a[cnt].y=j*i,a[cnt].t=f*j*i/gcd(f,j*i);
			}
	}
	sort(a+1,a+cnt+1,cmp);
	for(ri i=1;i<=cnt;i++)
	{
		if(find(a[i].x)==find(a[i].y))
			continue;
		fa[find(a[i].x)]=find(a[i].y);
		ans+=a[i].t;
	}
	cout<<ans<<"\n";
	back 0;
}
```

---

## 作者：Jairon314 (赞：4)

> [题目链接](https://www.luogu.com.cn/problem/P8207)

$$Solution$$

------------

赛时以为这题过不了, 结果调了调抱着试一试的心态交了一发就过了？

上来首先想到的是先连倍数. 发现连倍数肯定是优的, 先对所有的 $i\in [l,r]$ 都与 $\forall i|j, j\in [l,r]$ 连边, 然后考虑把剩下的图连成一棵树.

想着想着发现前面这个结论没用, 优化不大.

但是这个思路确确实实对之后的贪心建图有一定的指导意义.

我们考虑对 $i$ 和 $j$ 连边, 边权为 $lcm(i,j)$，也就是$\frac{ij}{\gcd(i,j)}$.

~~看到 $\gcd$ 就想到数论~~

那么可以考虑一种贪心. 进行数论的机械化操作, 首先我们枚举 $d=\gcd(i,j)$, 那么注意到子集 $\{ x; \; d|x,x \in [l,r] \}$, 目的是考虑建一些边把这个集合连成一个连通块.

由于固定了 $d=\gcd(i,j)$, 所以为了使得 $\sum \frac{i,j}{\gcd(i,j)}$ 最小, 贪心策略就是确定一个最小的 $i$, 使得 $d|i$ 且 $i\in[l,r]$, 然后对于剩下的所有 $j$, 使得 $d|j$ 且 $j\in[l,r]$, 都向 $i$ 连边.

1. 显然最小公倍树上的边一定是这些边中的子集。

2. 且这些边组成了一个连通图$^{(*)}$。

因此, 对这个图跑一遍最小生成树就可以了.

设 $m$ 等于 $(R-L)$, 边数为 $m \log m$, $Kruskal$ 过程中有对边排序的过程, 所以复杂度 $O(m\log(m\log m)) = O(m (\log m+\log\log m))$, 相当于 $O(m\log m)$ 可以通过此题.

$(*)$ - 注意 $\gcd(i,j)$ 的范围是 $[1,r]$, 由于肯定会枚举到 $\gcd(i,j)=1$, 所以可以保证最后的图是连通的.

最后是代码：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#include <cmath>
#include <map>
using namespace std;

//#define int long long
#define lint long long

/***** Fast_IO *****/

using std::cin;
using std::cout;
using vii = std::vector<int> ;
using pii = std::pair<int,int> ;
 
namespace IO{
	char buf[(1<<21)],*p1=buf,*p2=buf,buf1[(1<<21)]; int _=0;
 
	inline char gc (){
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,(1<<21),stdin),p1==p2)?EOF:*p1++;
	}
 
	#define gc getchar
	#define pc putchar
	#define ONLINE_JUDGE OJ
 
	template<class I>
	inline I read(I &x){
		x=0; I f=1; char c=gc(); if(c==EOF){ return -1; }
		while(c<'0'||c>'9'){ if(c=='-'){ f=f*(-1); } c=gc(); }
		while(c>='0'&&c<='9'){ x=(x<<1)+(x<<3)+(c^48); c=gc(); }
		return x=x*f;
	}
 
	template<typename I,typename ...Args>
	inline void read(I &a, Args &...args){
		read(a),read(args...);
	}
 
	template<class I>
	inline void write(I x){
		if(x==0){ pc('0'); return; }
		I tmp=x>0?x:(-x),cnt=0;
		if(x<0){ pc('-'); }
		while(tmp){ buf[cnt++]=(tmp%10)+'0'; tmp/=10; }
		while(cnt){ pc(buf[--cnt]); }
		return;
	}
	
	template<class I>
	inline void chmax(I &x,I y){ return x=max(x,y),void(); }
	
	template<class I>
	inline void chmin(I &x,I y){ return x=min(x,y),void(); }
 
	#define out(x) write(x),pc(' ')
	#define outn(x) write(x),pc('\n')
	#define assi() pc('\t')
	#define FOR(i,a,b) for(int i(a);i<=(b);++i)
	#define ROF(i,a,b) for(int i(a);i>=(b);--i)
	#define FORs(i,a,b,s) for(int i(a);i<=(b);i+=(s))
	#define ROFs(i,a,b,s) for(int i(a);i>=(b);i-=(s))
	#define next(i,now) for(int i(link[now]);i;i=edge[i].nexty)
	#define each(i,v) for(auto &i:v)
	#define all(v) v.begin(),v.end()
	#define sqr(k) ((k)*(k))
	#define inf 0x3f3f3f3f
	#define pb push_back
	#define mp make_pair
	#define DB double
	#define fir first
	#define sec second
}using namespace IO;

/***** Fast_IO *****/

#define maxn 1000010
#define SIZE 3010

lint gcd(lint a,lint b){ return b?gcd(b,a%b):a; }
lint lcm(lint a,lint b){ return a/gcd(a,b)*b; }

int L,R;
lint ans=0;
bool vis[maxn];
vii fac;

struct dsu{
	vii par,siz;
	dsu(int N):par(N+1),siz(N+1){ FOR(i,1,N){ par[i]=i,siz[i]=1; } }
	int find(int x){ return (par[x]==x)?x:par[x]=find(par[x]); }
	bool same(int x,int y){ return find(x)==find(y); }
	int count(int x){ return siz[find(x)]; }

	void unite(int x,int y){
		x=find(x),y=find(y);
		if(x==y){ return; }
		if(siz[x]<siz[y]){ swap(x,y); }
		par[y]=x,siz[x]+=siz[y];
		return;
	}
};

namespace GRA{
	struct Edge{ int start,end; lint val; int nexty; }edge[maxn<<2];

	int link[maxn],edge_cnt;

	void add_edge(int u,int v,lint w){
		edge[++edge_cnt]=(Edge){ u,v,w,link[u] };
		link[u]=edge_cnt;
	}
}using namespace GRA;

namespace MST{
	lint Kruskal(){
		lint ans=0;
		int tot=0;
		dsu uf(R);
		int sz=(int)fac.size()-1;
		sort(edge+1,edge+edge_cnt+1,[&](Edge a,Edge b){ return a.val<b.val; });
		FOR(i,1,edge_cnt){
			int u=uf.find(edge[i].start);
			int v=uf.find(edge[i].end);
			if(u==v){ continue; }
			uf.par[u]=v; ans+=edge[i].val;
			// out(edge[i].start),outn(edge[i].end);
			if(++tot==sz){ break; }
		} return ans;
	}
}using namespace MST;

// set<int> Set[maxn];
// map< int,map<int,int> > Map;

bool Use[maxn];

vii Vec[maxn];

signed main(){
	read(L,R);
	FOR(i,L,R){
		if(vis[i]){ continue; }
		int cur=i+i;
		// while(cur<=R){
		// 	if(vis[cur]){ cur+=i; continue; }
		// 	// out(i),outn(cur);
		// 	vis[cur]=1;
		// 	ans+=cur;
		// 	cur+=i;
		// }
	} FOR(i,L,R){ if(!vis[i]){ fac.pb(i); } }
	// each(ver,fac){ out(ver); } pc('\n');
	each(ver,fac){
		// factor(ver,ver);
		for(int i=1;i*i<=ver;i++){
			if(ver%i==0){
				if(i<=R/2)
				Vec[i].pb(ver);
				if(ver/i<=R/2)
				Vec[ver/i].pb(ver);
				// Set[i].insert(ver);
				// Set[ver/i].insert(ver);
			}
		}
	}
	// dsu uf(R+1);
	ROF(i,R/2,1){
		if(!(int)Vec[i].size()){ continue; }
		// sort(all(Vec[i]));
		// if(Vec[i].size()>1){ outn(i); }
		// outn(i);
		// assi(); each(ver,Set[i]){ out(ver); }
		// pc('\n');
		int cur=*Vec[i].begin();
		// Vec[i].erase(cur);
		// if(!(int)Vec[i].size()){ continue; }
		each(ver,Vec[i]){
			if(ver==cur){ continue; }
			// if(Use[ver]){ continue; }
			// out(ver),outn(cur);
			// Use[ver]=1;
			// ans+=lcm(ver,cur);

			// int u=uf.find(ver);
			// int v=uf.find(cur);
			// if(u==v){
			// 	int tmp=lcm(ver,cur);
			// 	if(tmp<Map[ver][cur]){
			// 		ans-=Map[ver][cur];
			// 		Map[ver][cur]=tmp;
			// 		Map[cur][ver]=tmp;
			// 		ans+=Map[ver][cur];
			// 	}
			// 	continue;
			// }
			// int tmp=lcm(ver,cur);
			// Map[ver][cur]=Map[cur][ver]=tmp;
			// ans+=tmp;
			// uf.par[u]=v;

			add_edge(ver,cur,1ll*ver/i*cur);
		}
	} // outn(edge_cnt);
	ans+=Kruskal();
	outn(ans);
	return 0;
}
```


---

## 作者：LinkyChristian (赞：3)

~~虽然在赛场上不是我写的，但我还是想写题解~~

本题三种做法：

# Kruskal

普遍做法，但是出题人和验题人都没想到。

做法是对于每个数 $d$ ，找到 $p_d$ 为 $d$ 大于等于 $l$ 的最小倍数，将 $d$ 在 $l \sim r$ 的除了 $p_d$ 的其余倍数与 $p_d$ 连边。然后把边排序跑kruskal即可。边数为调和级数，复杂度约为 $O(N log^2 N)$

连通性证明： $d=1$ 时所有数都会和 $l$ 连边，因此一定能构建出最小生成树。 

正确性证明（有可能假，看看就好）：对于没选中的一条边 $(x,y)$，设$gcd(x,y)=d$ ,一定能在选中的边中找到两条路径 $(x,p_d)$ 和 $(y,p_d)$ 使得在保证 $x,y$ 连通的前提下最大边权比取 $(x,y)$ 时更小。

 _upd2022/3/24: 严格证明已经有了，可以看[我的这篇题解](https://lookcatbox.blog.luogu.org/solution-at3611)_ 

代码最好写的一种做法。

代码来源：[Qzong](https://www.luogu.com.cn/user/135425)

```cpp
#include<bits/stdc++.h>
const int N=1000010;
int st[N],tot,L,R,tp,l,r;
struct edge{
	int u,v;
	long long w;
}e[N*30];
int p[N];
void init(){
	p[1]=l;
	for(int i=2;i<=r;i++)
		for(int j=i;j<=r;j+=i)
			if(j>=l) {p[i]=j;break;}
	for(int i=r;i>=1;i--)
		for(int j=p[i]+i;j<=r;j+=i)
			e[++tp]=(edge){p[i],j,1ll*p[i]*j/i};
}
bool cmp(edge a,edge b) {return a.w<b.w;}
int f[N];
int find(int x){
	while(x!=f[x])x=f[x]=f[f[x]];
	return x;
}
int main() {
	scanf("%d%d",&l,&r);
	init();
	int cnt=0;
	long long ans=0;
	for(int i=l;i<=r;i++)f[i]=i;
	sort(e+1,e+tp+1,cmp);
	for(int i=1;i<=tp;i++){
		int a=find(e[i].u),b=find(e[i].v);
		if(a==b)continue;
		f[a]=b,cnt++,ans+=e[i].w;
		if(cnt==R-L) break;
	}
	printf("%lld\n",ans);
	return 0;
}
```

# Prim

对于每个因数 $d$ ，用set维护在已选中集合中 $d$ 的倍数的最小值以及在未选中集合中 $d$ 的倍数的最小值 $val_d$。

对所有 $val_d$ 取最小值，使用单次修改 $O(log)$ ，查询 $O(1)$ 的数据结构维护。复杂度对每个 $d$ 维护 $val_d$ 为调和级数级别，数据结构维护为 $O(log)$ 级别，总复杂度 $O(Nlog^2N)$

代码：还没贺到。

# Boruvka

~~u上面应该带个圈，但是我打不出来~~

鉴于我没学过，且大部分人可能不知道这个算法~~或者说就我一个不知道~~
，因此这里贴一下官方题解：

- 一开始每个点属于一个集合。
- 每轮迭代，对每个集合 $S$ 查询 $S$ 与其他集合连边中最小的那条 $e_S$ ，将 $e_S$ 加入最小生成树。
- 如果边权互不相同，保证加入的边不会连成环。

- 查询时枚举每个点 $x$ ，枚举 $x$ 的因数 $d$ ，此时 $x$ 向其他集合连边要么是全局 $d$ 的最小值 $v_d$ ，要么是与 $v_d$ 处于不同集合中的 $d$ 的最小值 $v_d'$ （此时 $x$ 与 $v_d$ 属于同一集合）。

代码来源：[NesrayChan](https://www.luogu.com.cn/user/254629)

```cpp
#include<bits/stdc++.h>
#define IL inline
#define reg register
#define ll long long
#define N 1000100
#define pll std::pair<ll,ll>
#define mk std::make_pair
#define oo (1ll<<60)
IL int read()
{
	reg int x=0;reg char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x;
}

int L,R,id[N],buc[N],cnt;
std::vector<int>vec[N],p[N];
std::vector<int>::iterator it,t;

IL int merge(reg int x,reg int y)
{
	if(vec[x].size()<vec[y].size())x^=y^=x^=y;
	for(it=vec[y].begin();it<vec[y].end();++it)id[*it]=x,vec[x].push_back(*it);
	return vec[y].clear(),x;
}

ll ans;
pll f[N],g[N],v;

int main()
{
	L=read(),R=read();
	for(reg int i=L;i<=R;++i)id[i]=i,vec[i].push_back(i);
	for(reg int i=L,d;i<=R;++i)for(d=1;d*d<=i;++d)if(i%d==0)
	{
		p[i].push_back(d);
		if(d*d<i)p[i].push_back(i/d);
	}
	while(cnt<R-L)
	{
		memset(buc+1,0,R<<2);
		for(reg int i=L;i<=R;++i)f[i]=mk(oo,0ll);
		for(reg int i=L;i<=R;++i)if(id[i]==i)
		{
			for(it=vec[i].begin();it<vec[i].end();++it)for(t=p[*it].begin();t<p[*it].end();++t)
				if(buc[*t]&&(v=mk(1ll*buc[*t]*(*it)/(*t),1ll*buc[*t]))<f[*it])f[*it]=v;	
			for(it=vec[i].begin();it<vec[i].end();++it)for(t=p[*it].begin();t<p[*it].end();++t)
				if(!buc[*t]||buc[*t]>*it)buc[*t]=*it;
		}		
		memset(buc+1,0,R<<2);
		for(reg int i=L;i<=R;++i)g[i]=mk(oo,0ll);
		for(reg int i=R;i>=L;--i)if(id[i]==i)
		{
			for(it=vec[i].begin();it<vec[i].end();++it)for(t=p[*it].begin();t<p[*it].end();++t)
				if(buc[*t]&&(v=mk(1ll*buc[*t]*(*it)/(*t),1ll*buc[*t]))<g[*it])g[*it]=v;
			for(it=vec[i].begin();it<vec[i].end();++it)for(t=p[*it].begin();t<p[*it].end();++t)
				if(!buc[*t]||buc[*t]>*it)buc[*t]=*it;
		}	
		for(reg int i=L;i<=R;++i)if(g[i]<f[i])f[i]=g[i];
		for(reg int i=L;i<=R;++i)if(f[i]<f[id[i]])f[id[i]]=f[i];
		for(reg int i=L,j;i<=R;++i)if(id[i]==i&&id[i]!=id[j=f[i].second])
			id[i]=id[j]=merge(id[i],id[j]),++cnt,ans+=f[i].first;
	}
	return printf("%lld",ans),0;
}
```


---

## 作者：Cry_For_theMoon (赞：3)

这个做法应该是很慢的，因为在赛场上 TLE on 11 死活没有卡出来，欢迎大家来叉我/cy

但是我很想知道都是 ```-O2 -std=c++14```，cf极限数据跑 500ms，洛谷 ide 跑 600ms ，为什么 thupc 的机子会比 1s 还慢呢/yiw

------------

题意不多解释了。

考虑用 boruvka 算法求解最小生成树。那么我们要快速地解决这个问题 $O(\log n)$ 次：

$n=r-l+1$ 个点被划分成了若干个连通块，对于每个连通块，找到最小的一条边 $(u,v)$ 使得 $u$ 在这个连通块中而 $v$ 不在。

我们知道 $lcm(u,v)=\frac{u\times v}{\gcd(u,v)}$。我们可以暴力枚举当前连通块的每一个数字 $u$，然后枚举 $u$ 的所有约数 $d$，考虑 $d$ 就是 $\gcd(u,v)$。那么我们需要找到 $n$ 个点去掉当前连通块的点后，最小的是 $d$ 的倍数的数。

考虑对所有的 $d$ 维护一个 set，存储 $[l,r]$ 中所有是 $d$ 的倍数的数。当我们计算一个连通块的时候，暴力枚举该连通块的每个数字 $num$，枚举 $num$ 的所有约数 $d$，从数 $d$ 的 set 里删除 $num$；当我们计算完连通块的时候，再把这些数重新插入进去。这样，当我们枚举了 $d$ 以后，直接查询数 $d$ 的 set 的最小值即可。

我们来分析一下复杂度：设 $\tau(i)$ 是 $i$ 的约数个数，我们要找到 $\tau(1)\sim \tau(10^6)$ 中，长度为 $10^5$ 的所有连续段中，和最大的那个，记作 $\omega$，不难用程序算出 $\omega=1491899$。

那么复杂度是 $O(\omega \log^2 n)$ 的，非常显然这是过不去的。

boruvka 的一个 $\log$ 我们砍不掉，考虑能不能把这个 set 给改进一下。

这里有一个和回滚莫队类似的思想，就是我们考虑，如果只有从 set 中删除，而没有加入，是可以优化的。而为了让 set 中没有加入操作。我们每轮对每个连通块找最小出边的时候，正着遍历一遍，遍历完以后不重新插入；然后倒着再遍历一遍，这样就不用处理插入的事情了。（但是这样会有一个 $2$ 倍常数，目前我还没有想到可以改进的方法。）

那么只删除的情况怎么优化呢，首先，我们把 $[l,r]$ 中所有 $d$ 的倍数升序排序，这个你调和级数枚举的过程中就可以做到了吧。然后我们只关心当前时刻最开头的元素。我们可以利用懒惰删除的思想：对每个 $d$，维护一个指针变量 $cur$，最开始 $cur$ 指向数组的开头。然后我们对 $[l,r]$ 的每个数维护一个 $tag$，当删除数 $num$ 的时候，$tag_{num}\leftarrow 1$。当我们对于一个 $d$，查询现存的最小的 $d$ 的倍数的时候，我们检查 $cur$ 指向的数的 $tag$ 是否非 $1$，如果不是，说明这个数被删除了，让 $cur$ 指向下一个位置即可。重复这个过程，直到当前的 $tag$ 为 $0$ 了，或者越界（那么就是当前不存在 $d$ 的倍数了）。

此时时间复杂度为 $O(\omega \log n)$ 的，按理说这个复杂度，不是应该 1s 随便跑qwq...

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
using namespace std;
const ll MAXN=1e5+10,MAXM=1e6+10,INF=1e18;
int l,r,d[MAXN][500],sz[MAXN],dfn;
int fa[MAXN],szcnt[MAXN];
int to[MAXN],edge;
ll val[MAXN];
int arr[MAXN],tag[MAXN];
vector<int>pt[MAXN];
ll ans;
int Find(int x){
    if(fa[x]==x)return x;
    return fa[x]=Find(fa[x]);
}
void Merge(int x,int y){
    int p=Find(x),q=Find(y);
    if(p==q)return;
    fa[p]=q;
}
struct SET{
    vector<int>info;
    int cur;
    void add(int x){info.push_back(x);}
    int qry(){
        int sz=info.size();
        while(cur<sz&&tag[info[cur]-l+1]==dfn)cur++;
        if(cur>=sz)return -1;
        return info[cur];
    }
}occ[MAXM];
void Add(int x){
    rep(i,1,sz[x-l+1]){occ[d[x-l+1][i]].add(x);}
}
bool cmp(int x,int y){
    return val[x]<val[y];
}
void solve(){
    int n=r-l+1;
    rep(i,1,n)fa[i]=i;
    rep(i,1,r){
        rep(j,l/i,r){
            if(i*j>r)break;
            if(i*j<l)continue;
            d[i*j-l+1][++sz[i*j-l+1]]=i;
        }
    }
    rep(i,l,r){Add(i);}
    while(edge<n-1){
        rep(i,1,n)pt[i].clear();
        rep(i,1,n)pt[Find(i)].push_back(i+l-1);
        int tot=0;
        dfn++;
        rep(i,1,r)occ[i].cur=0;
        rep(i,1,n){
            if(Find(i)!=i)continue;
            arr[++tot]=i;to[i]=0,val[i]=INF;
            for(auto u:pt[i])tag[u-l+1]=dfn;
            ll num=occ[1].qry(),u=pt[i][0];
            if(num!=-1){
                if(num*u<val[i]){
                    val[i]=num*u;to[i]=num-l+1;
                }
            }
            for(auto u:pt[i]){
                rep(j,2,sz[u-l+1]){
                    int g=d[u-l+1][j];
                    ll num=occ[g].qry();
                    if(num==-1)continue;
                    if(num*u/g<val[i]){
                        val[i]=num*u/g;to[i]=num-l+1;
                    }
                }
            }
        }
        dfn++;
        rep(i,1,r)occ[i].cur=0;
        per(i,n,1){
            if(Find(i)!=i)continue;
            for(auto u:pt[i])tag[u-l+1]=dfn;
            ll num=occ[1].qry(),u=pt[i][0];
            if(num!=-1){
                if(num*u<val[i]){
                    val[i]=num*u;to[i]=num-l+1;
                }
            }
            for(auto u:pt[i]){
                rep(j,2,sz[u-l+1]){
                    int g=d[u-l+1][j];
                    ll num=occ[g].qry();
                    if(num==-1)continue;
                    if(num*u/g<val[i]){
                        val[i]=num*u/g;to[i]=num-l+1;
                    }
                }
            }
        }
        rep(i,1,tot){
            int u=arr[i];
            int v=to[u];
            ll w=val[u];
            if(Find(u)!=Find(v)){
                Merge(u,v);ans+=w;
                edge++;
            }
        }
    }
}
int main(){
    
    cin>>l>>r;
    solve();
    cout<<ans;
    return 0;
}
```

---

## 作者：MicroSun (赞：2)

是一类常用技巧吗？

---

瞪眼一下，可以发现本题完全图中的大量边是没有用的。

如果点对 $(kx,ky)$ 满足 $x<y,x\perp y$ 且 $x\ne 1$，则 $\{kx,ky\}$ 这条边是没有用的。

证明考虑 Kruskal。首先有显然的结论 $\operatorname{lcm}(k,kx),\operatorname{lcm}(k,ky)\le\operatorname{lcm}(kx,ky)$，因为 $\{k,kx\}$ 和 $\{k,ky\}$ 的边权较小，所以会被算法优先考虑，在这之后 $k,kx,ky$ 三点必然在同一个连通块中，$\{kx,ky\}$ 这条边自然也没有存在的必要了。

于是发现有用的边只有 $\{k,kx\}$ 这类。我们枚举每一个 $k$，再算出在 $[L,R]$ 范围内的 $kx$ 并与 $k$ 连边即可。虽然这样也会带来一些多余的枚举，但是 $\Omicron(n\log^2 n)$ 的边量已经足够通过本题了。

加完边后正常跑一遍 Kruskal 即可。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int N=1e6+10;

ll f[N];
struct _{int u,v;ll w;};
int find(int u){return u==f[u]?u:f[u]=find(f[u]);}
void solve(){
	ll l,r;
	cin>>l>>r;
	iota(f+l,f+1+r,l);
	vector<_> e;
	rep(i,1,r){
		ll L=ceil((double)(l)/i),R=floor((double)(r)/i),s=L*i;
		rep(j,L+1,R) e.pb({s,j*i,lcm(j*i,s)});
	}
	sort(begin(e),end(e),[](_ a,_ b){return a.w<b.w;});
	ll ans=0;
	for(auto [u,v,w]:e){
		int fx=find(u),fy=find(v);
		if(fx!=fy){
			f[fx]=fy;
			ans+=w;
		}
	}
	cout<<ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--) solve();
    return 0;
}
```

---

## 作者：under_the_time (赞：2)

## 题意

> 令连接 $u,v$ 的边的边权为 $\text{lcm}(u,v)$。给定 $L,R$，求 $[L,R]$ 内的点所构成的无向图的最小生成树中边的边权和。
>
> $L,R\leq 10^6,R-L\leq10^5$。

## 解法

直接 $O(n^2)$ 两两建边显然不行，考虑优化建边。

对于两个点 $u,v$，$(u,v)$ 的边权为 $\text{lcm}(u,v)=\cfrac{u\times v}{\gcd(u,v)}$，显然应该选择 $\gcd(u,v)$ 尽可能大的点对连边，也就是说 $u,v$ 的公因子越多越好。

因为 $L,R\leq10^6$，于是考虑枚举这个公因子。对于一个因子 $x$，如果 $kx$ 在 $[L,R]$ 中，则 $(k+1)x,(k+2)x,\dots$ 这些点向 $kx$ 连边是较优的。所以我们可以找到这个最小的 $kx$ 作为起点连边。最后跑最小生成树即可。

## 实现

枚举的因子范围是 $[2,R]$ 的，对于一个因子 $x$，在发现第一个 $L\leq kx\leq R$ 的时候将 $kx$ 标记为起点，向之后在 $[L,R]$ 内的 $(k+1)x,(k+2)x,\dots$ 连边。为确保连通，还需要连一条 $(L,kx)$ 的边。

设点数为 $n$，边数为 $m$，根据调和级数，最后边的数量 $m$ 大约是 $O(n\log n)$ 级别的，`Kruskal`最小生成树 $O(m\log m)$，总时间复杂度大约在 $O(n\log^2n)$ 左右。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e6 + 5;
int L,R;
struct Edge {
	int u,v,w;
};
vector<Edge> e;
int fa[maxn];
int find(int x) {
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}
signed main() {
	scanf("%lld%lld",&L,&R);
	for (int i = 2,st = 0;i <= R;i ++,st = 0) {
		for (int j = i;j <= R;j += i) 
			if (j >= L) {
				if (st == 0) st = j;
				e.push_back(Edge{st,j,st / __gcd(st,j) * j});
			}
		if (i >= L)
			e.push_back(Edge{st,L,st / __gcd(st,L) * L});
	}
	for (int i = L;i <= R;i ++) fa[i] = i;
	sort(e.begin(),e.end(),[&](const Edge &x,const Edge &y) {
		return x.w < y.w;
	});
	int ans = 0;
	for (auto E : e) {
		int u = find(E.u), v = find(E.v), w = E.w;
		if (u == v) continue;
		ans += w, fa[u] = v;
	}
	printf("%lld",ans);
}
```



---

## 作者：happybob (赞：1)

## 题意

给定 $l, r$，有一张无向完全图 $G=(V,E)$，其中 $V=\{l,l+1,\cdots,r\}$。两点 $u,v$ 之间有边，边权为 $\operatorname{lcm}(u,v)$。求这张图的最小生成树。

$1 \leq l \leq r \leq 10^6$。

## 做法

考虑暴力建边，设 $n = r - l + 1$，则复杂度 $O(n^2 \log n^2)$，显然复杂度不对。

考虑 $\operatorname{lcm}(u,v) = \dfrac{u \cdot v}{\gcd(u,v)}$，可以枚举 $\gcd(u,v)$。

假设当前枚举到的公因数为 $i$，设 $p_i$ 为 $\geq l$ 且最小的是 $i$ 的倍数的数。那么可以将 $p_i$ 和 $p_i + i, p_i + 2i, p_i + 3i, \cdots$ 连边，直到 $p+ki > r$ 时停止。

时间复杂度 $O(n \log^2 n$)。

---

## 作者：minVan (赞：1)

**解题思路**

首先如果全建边的话，那么总边数达到 ${(10^5)}^2=10^{10}$，无法忍受。

所以考虑删去一些边权很大，不可能在最小生成树上的边。

由 $\operatorname{lcm}(x,y)=x\times y\div\operatorname{gcd}(x,y)$ 可以知道，如果两数的最大公约数越大，它们的最小公倍数就越较小。所以我们可以枚举公约数 $i$，范围是 $2\sim r$，那么 $x,y$ 就只能是 $s=\left\lceil l\div i\right\rceil\times i,p\times i$，其中 $s,pi\in[l,r]$。

特殊的，$s$ 与 $l$ 需要建一条边。

最后跑一遍最小生成树即可。

渐变时间复杂度为 $\mathcal{O}\left(\sum\limits_{i=2}^r\left\lfloor\dfrac{r}i\right\rfloor\right)\le\mathcal{O}(r\log_2 r)$，大约 $10^8$ 左右，稳过。

**AC 代码，请勿抄袭。**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e6 + 5;
struct node { int u, v, w; } e[N];
bool operator < (node a, node b) {
  return a.w < b.w;
}
inline int gcd(int x, int y) {
  return !y ? x : gcd(y, x % y);
}
inline int lcm(int x, int y) {
  return x * y / gcd(x, y);
}
int l, r, f[N], m;
inline int Find(int x) {
  return x == f[x] ? x : f[x] = Find(f[x]);
}
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> l >> r;
  for(int i = l; i <= r; i++) { f[i] = i; }
  for(int i = 2; i <= r; i++) {
    int k = ceil(1.0 * l / i) * i, j = k;
    while(j <= r) {
      e[++m] = {k, j, lcm(k, j)};
      j += i;
    }
    if(i >= l) { e[++m] = {k, l, lcm(k, l)}; }
  }
  sort(e + 1, e + m + 1);
  int ans = 0;
  for(int i = 1; i <= m; i++) {
    int x = Find(e[i].u), y = Find(e[i].v);
    if(x == y) { continue; }
    f[x] = y;
    ans += e[i].w;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：yzysdTNT (赞：0)

## 思路
题目说是某一个图的**最小生成树**，考虑 kruskal 处理图；
看一眼数据范围，$R - L \le 10^5$，显然不能将每个点连边，$10^{10}$ 会炸掉。  
考虑优化掉不可能进入最小生成树的边，只考虑更优的边。题中边权为节点的最小公倍数，即 $\frac{u \times v}{\gcd(u,v)}$。我们考虑使 $\gcd(u,v)$ 尽可能大，看数据范围，考虑枚举这个公因数，设其为 $x$,最小的数为 $kx$,则后面的 $(k + 1)x$ 等的最优连边都是连向 $kx$ 的。接着跑 kruskal 处理即可。

记得开 long long。
## [CODE](https://www.luogu.com.cn/record/163323094)
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int l,r,p[N],t;
struct node{
	int x,y,val;
	friend bool operator < (node a,node b){
		 return a.val < b.val;
	}
}a[N * 2];

int gcd(int x,int y){
	if(!y) return x;
	return gcd(y,x % y);
}

int lcm(int x,int y){
	return x / gcd(x,y) * y;
}

int find(int x){
	return (p[x] == x) ? x : p[x] = find(p[x]);
}

signed main(){
	cin >> l >> r;
	for(int i = l;i <= r;i++) p[i] = i;
	for(int i = 1;i <= r - l + 1;i++){
		int tmp = 0;
		for(int j = 1;j * i <= r;j++){
			if(j * i < l) continue;
			if(!tmp){
				tmp = j * i;
				a[++t] = {l,tmp,lcm(l,tmp)};
			}
			else{
				a[++t] = {tmp,j * i,lcm(tmp,j * i)};
			}
		}
	}
	sort(a + 1,a + 1 + t);
	int cnt = 0,sum = 0;
	for(int i = 1;i <= t;i++){
		if(find(a[i].x) != find(a[i].y)){
			p[find(a[i].x)] = find(a[i].y);
			sum += a[i].val;
			++cnt;
		}
		if(cnt == t - 1) break;
	}
	cout << sum;
	return 0;
}
```

---

## 作者：Xiphi (赞：0)

### P8207

最初的想法是，因为 $\operatorname{lcm}(u,v)=\frac{u\times v}{\gcd(u,v)}$。所以考虑枚举 $\gcd$，然后连接 $\gcd(u,v)$ 相等的所有边，之后跑 Kruskal。显然这样边数过多。

考虑优化，想到“超级原的思路”，钦定 $\gcd(u,v)$ 为超级源，用超级源连接所有 $\gcd(u,v)$  的倍数。显然这样不劣于两两暴力连边。 

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int tot=0,l,r;
int vis[2000005];
struct Node{
	int f,t,v;
}a[2000002];
bool cmp(Node a,Node b){
	return a.v<b.v;
}
int n,m,ans,f[2000005],cnt,bu[2000005];
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
void build(void){
    for(int i=l;i<=r;++i) f[i]=i,bu[i]=1;
}
void add(int u,int v,int w){
	a[++tot].f=u;
	a[tot].t=v;
	a[tot].v=w;
}
int gcd(int a, int b) {
    if(a%b==0) return b;
    else return gcd(b,a%b);
}
int lcm(int a, int b) {
    return a*b/gcd(a, b);
}
signed main(){
	cin>>l>>r;
	build();
	for(int i=2;i<=r;++i){
		int pos=0;
		for(int j=i;j<=r;j+=i){
			if(!pos&&bu[j]) pos=j;
			if(bu[j]) add(pos,j,lcm(pos,j));
			vis[j]=1;
		}
		if(i>=l) add(pos,l,lcm(pos,l));
	}
	sort(a+1,a+tot+1,cmp);
	int T=0;
	long long ans=0;
	for(int i=1;i<=tot;++i){
		if(find(a[i].f)!=find(a[i].t)) f[find(a[i].f)]=f[find(a[i].t)],T++,ans+=a[i].v;
	}
	cout<<ans;
	return 0;
}
```

---


# [THUPC 2022 初赛] 画图

## 题目描述

一年两度的THUPC又要来了，小C和小Z作为参赛无数届的老选手，自然也要来凑一番热闹。不过因为已经是老年人了，参赛自然是免谈了，但是他们对THUPC几年不换的logo产生了审美疲劳，为了更好地吸引大家报名，他们打算重画一个更花里胡哨的。

笑死，你怎么可能指望两个宅男码农有丝毫的艺术细菌？

他们深知这件事不在自己的能力范围之内，于是打算写一个人工智障来帮自己来画logo！

经过不懈的努力，他们的人工智障终于能跑起来了，不过他们很快就发现这个人工智障比自己还没有艺术细菌——它只会在平面上画水平和竖直的线段来拼成“THUPC”字样！

不过程序写都写了，不用白不用。小C和小Z针对程序的这一特性进行深入研究后制定了这样的规则：

对于每一条水平线段，设其横坐标区间为 $[l_i,r_i]$ ，纵坐标为 $y_i$； 对于每一条竖直线段，设其纵坐标区间为 $[d_i,u_i]$ ，横坐标为 $x_i$ 。上述所有数值均为整数，且满足$r_i > l_i,u_i > d_i$。

“THUPC”字样应当由 $15$ 条线段拼成，设其编号为 $1 \thicksim 15$ 。对于每一个字母，规则如下：

字母"T"由 $1$ 号水平线段和 $2$ 号竖直线段组成，满足 $d_2<y_1=u_2,l_1<x_2<r_1$ 。

字母"H"由 $3$ 号竖直线段、$4$ 号水平线段和 $5$ 号竖直线段组成，满足 $d_3=d_5<y_4<u_3=u_5,x_3=l_4<r_4=x_5$ 。

字母"U"由 $6$ 号竖直线段、$7$ 号水平线段和 $8$ 号竖直线段组成，满足 $d_6=d_8=y_7<u_6=u_8,x_6=l_7<r_7=x_8$ 。

字母"P"由 $9$ 号竖直线段、$10$ 号水平线段、$11$ 号水平线段和 $12$ 号竖直线段组成，满足 $d_9<y_{11}=d_{12}<u_9=y_{10}=u_{12},x_9=l_{10}=l_{11}<r_{10}=r_{11}=x_{12}$ 。

字母"C"由 $13$ 号竖直线段、$14$ 号水平线段和 $15$ 号水平线段组成，满足 $d_{13}=y_{15}<u_{13}=y_{14},x_{13}=l_{14}=l_{15}<r_{14}=r_{15}$ 。

生成的这 $5$ 个字母可以排布在平面的任何地方而无需从左到右排列，但是组成任意两个不同字母的任意两条线段不得相交。

需要注意的是，人工智障给出的线段顺序可能并不按照上述编号顺序；另外，给出的线段可能出现同方向线段的首尾相连、重叠或包含，此时应将其视为连续的一整条线段。

只有生成的线段在连接和排序后符合上述规范，才认为人工智障生成了一幅正确的logo；否则，如果出现多余的线段、缺少某条线段或坐标不满足要求等情况均为不正确的。

最后，小C和小Z要写一个程序来检验人工智障的每一份输出结果是否符合上述规范，不过熬夜连肝三天的他们终于累得爬不起来了，于是他们请你来帮忙。

## 说明/提示

【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/oomfukad.png)

这组样例中，字母 `T` 的水平线段和 `C` 的竖直线段分别是由两条线段拼成的。

## 样例 #1

### 输入

```
17
1 0 5 2
0 0 3 5
0 3 4 5
1 2 7 7
1 2 7 10
0 7 10 4
0 11 13 1
1 1 7 11
1 1 7 13
1 0 6 15
0 15 16 5
0 15 16 6
1 5 6 16
1 3 6 18
1 4 7 18
0 18 21 3
0 18 21 7```

### 输出

```
Yes```

# 题解

## 作者：Dantal10n (赞：9)

随便写了一发，交上来看一圈提交记录发现是最短解，看一圈题解区，怎么全是搜相交线段联通块，我不理解。所以来点无脑好写做法。

读题不需要理解题目给的那一大段条件是什么，先跳过。发现题目要求合并同向有交线段，两种方向可以只写一遍调用两次。为了可读性，分类型写。

注意到最后必然留下 $7$ 条水平线和 $8$ 条竖直线否则无解。于是考虑计算量为 $7!\cdot8!\cdot O(chk)$ 的枚举全排列做法。发现将两个方向的线段分别重标号会好写很多，把题目的判断条件拉下来手改。最后还有个非同一字母不能有线段交的限制，直接统计总交点数与字母内交点数的差是否为零。

写完发现样例跑了 5s，于是将竖直线段之间单独的条件判断放在外面，用时直降到 100ms-。直接过了。

思考+编码时间：1.25h（花了 0.5h 考虑类型转化怎么写的简单点/qd ）   
代码长度：1.81K 主播码风本来就这样没有刻意压行。  
看不惯可以左转：[LOJ 格式化 ver.](https://loj.ac/s/1943925)

```cpp
#include<bits/stdc++.h>
#define N 100005
#define F for(int i=1;i<=ns;i++)
using namespace std;
int n,nh,nv,ns,ih[N],iv[N];
struct hr{int l,r,y;}a[N];
struct vt{int d,u,x;}b[N];
struct sg{int s,t,p;}c[N];
bool operator<(const sg &a,const sg &b){if(a.p^b.p)return a.p<b.p;
	if(a.s^b.s)return a.s<b.s;return a.t>b.t;}
int s(){stable_sort(c+1,c+1+ns);int t=1;
	F if(c[i].p^c[t].p||c[i].s>c[t].t)c[++t]=c[i];
	else c[t].t=max(c[t].t,c[i].t);return t;}
int l[9],r[9],d[9],u[9],x[9],y[9];
int crs(int i,int j){return d[j]<=y[i]&&y[i]<=u[j]
&&l[i]<=x[j]&&x[j]<=r[i];}
int C(int lh,int rh,int lv,int rv){int c=0;for(int i=lh;i<=rh;i++)
	for(int j=lv;j<=rv;j++)c+=crs(i,j);return c;}
signed main(){ios::sync_with_stdio(0),cin.tie(0),cin>>n;
	for(int i=1,s;i<=n;i++){cin>>s;
		if(!s)++nh,cin>>a[nh].l>>a[nh].r>>a[nh].y;
		else ++nv,cin>>b[nv].d>>b[nv].u>>b[nv].x;}
	ns=nh;F c[i]=(sg){a[i].l,a[i].r,a[i].y};nh=s();F a[i]=(hr){c[i].s,c[i].t,c[i].p};
	ns=nv;F c[i]=(sg){b[i].d,b[i].u,b[i].x};nv=s();F b[i]=(vt){c[i].s,c[i].t,c[i].p};
	if(nh^7||nv^8)cout<<"No\n",exit(0);
	for(int i=1;i<=8;i++)ih[i]=iv[i]=i;
	do{
		for(int i=1;i<9;i++)
			d[i]=b[iv[i]].d,u[i]=b[iv[i]].u,x[i]=b[iv[i]].x;
		if(d[2]^d[3]||u[2]^u[3]||d[4]^d[5]||u[4]^u[5])continue;
		do{
		for(int i=1;i<8;i++)
		l[i]=a[ih[i]].l,r[i]=a[ih[i]].r,y[i]=a[ih[i]].y;
		if(y[1]==u[1]&&l[1]<x[1]&&x[1]<r[1]
		&&d[3]<y[2]&&y[2]<u[2]&&x[2]==l[2]&&r[2]==x[3]
		&&d[5]==y[3]&&x[4]==l[3]&&r[3]==x[5]&&d[6]<y[5]
		&&y[5]==d[7]&&u[6]==y[4]&&y[4]==u[7]&&x[6]==l[4]
		&&l[4]==l[5]&&r[4]==r[5]&&r[5]==x[7]&&d[8]==y[7]
		&&u[8]==y[6]&&x[8]==l[6]&&l[6]==l[7]&&r[6]==r[7]
		&&!(C(1,7,1,8)-C(1,1,1,1)-C(2,2,2,3)-C(3,3,4,5)
		-C(4,5,6,7)-C(6,7,8,8)))cout<<"Yes\n",exit(0);
		}while(next_permutation(ih+1,ih+8));}
	while(next_permutation(iv+1,iv+9));
	cout<<"No\n",exit(0);
	return 0;
}
```

---

## 作者：enucai (赞：7)

## Preface

难点：发现这是一道可做题。

## Analysis

题意很简单，给你一些**横平竖直**的线段，问你能否用她们拼出互不相交的五个字母：$\texttt{T H U P C}$。

首先考虑将给的 $n$ 条线段合并。具体地，将两条或更多条 $x$（对于竖线） 或 $y$（对于横线）相同，且相交的线段合并成一条更大的线段。这样，如果答案是 `Yes`，那么横线段数量一定是 $7$，竖线段数量一定是 $8$。如果不满足该条件，则为 `No`。

接下来就只剩横竖共 $15$ 条线段了。我们用 Dfs 即可轻松将连通块求出（染色）。如果连通块数量不为 $5$，则答案为 `No`。

最后，我们对 $5$ 个连通块分别暴力判断是否为 $\texttt{T H U P C}$ 中的一个，并判断 $5$ 个连通块是否分别是 $\texttt{T H U P C}$。如果是，则答案为 `Yes`，否则为 `No`。

总体思路不用动脑子，但是代码打起来很烧头发（~~尤其是在游戏声中~~）。

具体实现看代码。

## Code

**Talk is cheap, show me the code.**

$842$ ms，$16.64$ MB。

```cpp
// And in that light, I find deliverance.
#define int long long
int n,litot=0,rotot=0,tot=0;
struct node{
	int x,l,r,col;
	bool operator<(const node &p)const{
		return x<p.x;
	}
}line[100010],row[100010];
map<int,vector<pii> > li,ro;
void dfs(int now,int type){
	if(type==0) line[now].col=tot;
	else row[now].col=tot;
	if(type==1){
		For(i,1,7) if(!line[i].col){
			if(row[now].l<=line[i].x&&line[i].x<=row[now].r&&line[i].l<=row[now].x&&row[now].x<=line[i].r) dfs(i,0);
		}
	}else{
		For(i,1,8) if(!row[i].col){
			if(line[now].l<=row[i].x&&row[i].x<=line[now].r&&row[i].l<=line[now].x&&line[now].x<=row[i].r) dfs(i,1);
		}
	}
}
vector<node> heng,shu;
bool cT(int id){
	heng.clear(),shu.clear();
	int cnt=0;
	For(i,1,7) if(line[i].col==id) cnt++,heng.pb(line[i]);
	For(i,1,8) if(row[i].col==id) cnt++,shu.pb(row[i]);
	if(!(heng.size()==1&&shu.size()==1)) return 0;
	if(heng[0].l<shu[0].x&&shu[0].x<heng[0].r&&shu[0].r==heng[0].x) return 1;
	return 0;
}
bool cH(int id){
	heng.clear(),shu.clear();
	int cnt=0;
	For(i,1,7) if(line[i].col==id) cnt++,heng.pb(line[i]);
	For(i,1,8) if(row[i].col==id) cnt++,shu.pb(row[i]);
	if(!(heng.size()==1&&shu.size()==2)) return 0;
	sort(shu.begin(),shu.end());
	if(shu[0].x==heng[0].l&&heng[0].r==shu[1].x&&shu[0].l==shu[1].l&&shu[0].r==shu[1].r&&shu[0].r>heng[0].x&&heng[0].x>shu[0].l) return 1;
	return 0;
}
bool cU(int id){
	heng.clear(),shu.clear();
	int cnt=0;
	For(i,1,7) if(line[i].col==id) cnt++,heng.pb(line[i]);
	For(i,1,8) if(row[i].col==id) cnt++,shu.pb(row[i]);
	if(!(heng.size()==1&&shu.size()==2)) return 0;
	sort(shu.begin(),shu.end());
	if(shu[0].x==heng[0].l&&heng[0].r==shu[1].x&&shu[0].l==shu[1].l&&shu[0].r==shu[1].r&&shu[0].r>heng[0].x&&heng[0].x==shu[0].l) return 1;
	return 0;
}
bool cP(int id){
	heng.clear(),shu.clear();
	int cnt=0;
	For(i,1,7) if(line[i].col==id) cnt++,heng.pb(line[i]);
	For(i,1,8) if(row[i].col==id) cnt++,shu.pb(row[i]);
	if(!(heng.size()==2&&shu.size()==2)) return 0;
	sort(shu.begin(),shu.end());
	sort(heng.begin(),heng.end());
	if(heng[0].l==heng[1].l&&heng[0].r==heng[1].r&&shu[0].r==shu[1].r&&shu[0].l<shu[1].l&&heng[0].l==shu[0].x&&heng[0].r==shu[1].x&&heng[1].x==shu[1].r&&heng[0].x==shu[1].l&&heng[1].x==shu[0].r) return 1;
	return 0;
}
bool cC(int id){
	heng.clear(),shu.clear();
	int cnt=0;
	For(i,1,7) if(line[i].col==id) cnt++,heng.pb(line[i]);
	For(i,1,8) if(row[i].col==id) cnt++,shu.pb(row[i]);
	if(!(heng.size()==2&&shu.size()==1)) return 0;
	sort(heng.begin(),heng.end());
	if(heng[0].l==heng[1].l&&heng[0].r==heng[1].r&&heng[0].x==shu[0].l&&heng[1].x==shu[0].r&&shu[0].x==heng[0].l) return 1;
	return 0;
}
signed main(){
	read(n);
	For(i,1,n){
		int op,l,r,x;
		read(op,l,r,x);
		if(op==0) li[x].eb(min(l,r),max(l,r));
		else ro[x].eb(min(l,r),max(l,r));
	}
	for(auto p:li){
		vector<pii> tmp=p.sec;
		int x=p.fir;
		sort(tmp.begin(),tmp.end());
		int l=-1e16,r=-1e16;
		for(auto now:tmp){
			if(now.fir<=r) ckmax(r,now.sec);
			else{
				if(l!=-1e16){
					litot++;
					line[litot]=(node){x,l,r};
				}
				l=now.fir,r=now.sec;
			}
		}
		if(l!=-1e16){
			litot++;
			line[litot]=(node){x,l,r};
		}
	}
	for(auto p:ro){
		vector<pii> tmp=p.sec;
		int x=p.fir;
		sort(tmp.begin(),tmp.end());
		int l=-1e16,r=-1e16;
		for(auto now:tmp){
			if(now.fir<=r) ckmax(r,now.sec);
			else{
				if(l!=-1e16){
					rotot++;
					row[rotot]=(node){x,l,r};
				}
				l=now.fir,r=now.sec;
			}
		}
		if(l!=-1e16){
			rotot++;
			row[rotot]=(node){x,l,r};
		}
	}
	if(litot!=7) {puts("No");return 0;}
	if(rotot!=8) {puts("No");return 0;}
	For(i,1,7) line[i].col=0;
	For(i,1,8) row[i].col=0;
	For(i,1,7) if(!line[i].col){
		tot++;
		dfs(i,0);
	}
	For(i,1,8) if(!row[i].col) {puts("No");return 0;}
	if(tot!=5) {puts("No");return 0;}
	bool T=0,H=0,U=0,P=0,C=0;
	For(i,1,5){
		if(cT(i)&&!T) T=1;
		else if(cH(i)&&!H) H=1;
		else if(cU(i)&&!U) U=1;
		else if(cP(i)&&!P) P=1;
		else if(cC(i)&&!C) C=1;
		else {puts("No");return 0;}
	}
	puts("Yes");
}
```

## Postscript

考场上最后 $2$ hour 两位队友说都贡献了 AC 于是开始颓废，蒟蒻在最后 $40$ min 发现了这道可做的恶心题，于是开始在旁边两位的泰拉游戏声中写代码。赛后 $2$ min 调完了代码，交不上去了。$5$ 天后，数据出来了，AC。不免有些遗憾，对于一支初中队伍，rank $200$ 内外差距还是很大的。作此篇，兼~~发泄情绪~~纪念。

---

## 作者：rui_er (赞：3)

大模拟，应该还算大模拟里面偏简单的。

~~正如官方题解说的，本题难点在于注意到这道题是可做题。~~

首先，一开始有 $10^5$ 条线段，而 `THUPC` 只有 $15$ 条，我们需要按照题意将“出现同方向线段的首尾相连、重叠或包含”，合并成一条线段。

这部分比较好处理，以方向为第一关键字，然后 $x$ 或者 $y$ 为第二关键字，最后 $l$ 或者 $d$ 为第三关键字排序。然后按顺序枚举线段，方向不同必然是新的线段，如果 $x$ 或者 $y$ 不同也是，否则根据 $l,r$ 或者 $u,d$ 判断是否“首尾相连、重叠或包含”，进行处理即可。

之后如果不是恰好 $15$ 条线段，那么就是 `No`。

然后数据规模缩小到了 $15$，属于是咋做都行了。我们跑一遍洪水填充，把每个连通块标记出来，看一眼是不是恰好 $5$ 个连通块，不是就是 `No`。

接着判断这 $5$ 个连通块的大小是不是 $2,3,3,3,4$（顺序可打乱），如果不是也是 `No`。

继续判断就需要抓特征。可以先判断大小为 $2$ 的连通块是不是 `T`，然后判断大小为 $4$ 的连通块是不是 `P`。我们还观察到，剩余的连通块里只有 `C` 有两条横向线段。这些都可以根据题目的要求判掉。最后剩下的 `U` 和 `H` 类似判一下，拿 bool 变量存一下就好了。

如果恰好是 `THUPC`，就 `Yes`；否则 `No`。

赛时代码：

```cpp
//By: Luogu@rui_er(122461) & registerGen(242702)
//Team: 世一大附中老同志
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 1e5+5;

int n, vis[N], sz[N];
#define No do{return puts("No")&0;}while(0)
#define Yes do{return puts("Yes")&0;}while(0)
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Segment {
	int op, l, r, u, d;
	Segment(int op=0, int a=0, int b=0, int c=0, int d=0) : op(op), l(a), r(b), u(c), d(d) {}
	~Segment() {}
	friend bool operator < (const Segment& a, const Segment& b) {
		if(a.op != b.op) return a.op < b.op;
		if(!a.op) {
			if(a.u != b.u) return a.u < b.u;
			return a.l < b.l;
		}
		else {
			if(a.l != b.l) return a.l < b.l;
			return a.d < b.d;
		}
	}
}a[N], b[N];
bool intersect(Segment a, Segment b) {
	if(a.op == b.op) return 0;
	if(a.op > b.op) swap(a, b);
	if(b.l < a.l || b.l > a.r) return 0;
	if(a.u > b.u || a.u < b.d) return 0;
	return 1;
}
void dfs_floodfill(int u, int c) {
	vis[u] = c;
	++sz[c];
	rep(i, 1, 15) {
		if(i == u || vis[i]) continue;
		if(intersect(b[i], b[u])) {
			dfs_floodfill(i, c);
		}
	}
}

int main() {
	scanf("%d", &n);
	rep(i, 1, n) {
		int op, A, B, C;
		scanf("%d%d%d%d", &op, &A, &B, &C);
		if(!op) a[i] = Segment(op, A, B, C, C);
		else a[i] = Segment(op, C, C, B, A);
	}
	sort(a+1, a+1+n);
	int tot = 1;
	b[1] = a[1];
	rep(i, 2, n) {
		if(a[i].op != b[tot].op) b[++tot] = a[i];
		else if(!a[i].op) {
			if(a[i].u == b[tot].u) {
				if(b[tot].r >= a[i].l) chkmax(b[tot].r, a[i].r);
				else b[++tot] = a[i];
			}
			else b[++tot] = a[i];
		}
		else {
			if(a[i].l == b[tot].l) {
				if(b[tot].u >= a[i].d) chkmax(b[tot].u, a[i].u);
				else b[++tot] = a[i];
			}
			else b[++tot] = a[i];
		}
	}
//	rep(i, 1, tot) printf("%d %d %d %d %d\n", b[i].op, b[i].l, b[i].r, b[i].u, b[i].d);
	if(tot != 15) No;
	int totc = 0;
	rep(i, 1, 15) {
		if(!vis[i]) dfs_floodfill(i, ++totc);
	}
	if(totc != 5) No;
	int buc[5] = {0, 0, 0, 0, 0};
	rep(i, 1, 5) {
		if(sz[i] < 2 || sz[i] > 4) No;
		++buc[sz[i]];
	}
	if(buc[2] != 1 || buc[3] != 3 || buc[4] != 1) No;
	int H = 0, U = 0;
	rep(i, 1, 5) {
//		printf("COLOR %d: ", i);
		if(sz[i] == 2) { // T
			int ok = 0;
			rep(j, 1, 15) { // - 1
				if(vis[j] != i || b[j].op) continue;
				rep(k, 1, 15) { // | 2
					if(vis[k] != i || !b[k].op) continue;
					if(b[k].d < b[j].u
					 && b[j].u == b[k].u
					 && b[j].l < b[k].l
					 && b[k].l < b[j].r)
						ok = 1;
				}
			}
			if(!ok) No;
//			puts("T");
		}
		else if(sz[i] == 4) { // P
			int ok = 0;
			rep(j, 1, 15) { // | long 9
				if(vis[j] != i || !b[j].op) continue;
				rep(k, 1, 15) { // | short 12
					if(vis[k] != i || !b[k].op) continue;
					if(j == k || b[j].u - b[j].d <= b[k].u - b[k].d) continue;
					rep(l, 1, 15) { // - up 10
						if(vis[l] != i || b[l].op) continue;
						rep(m, 1, 15) { // - down 11
							if(l == m || vis[m] != i || b[m].op) continue;
							if(b[j].d < b[m].d
							 && b[m].d == b[k].d
							 && b[k].d < b[j].u
							 && b[j].u == b[l].u
							 && b[l].u == b[k].u
							 && b[j].l == b[l].l
							 && b[l].l == b[m].l
							 && b[m].l < b[l].r
							 && b[l].r == b[m].r
							 && b[m].r == b[k].l)
								ok = 1;
						}
					}
				}
			}
			if(!ok) No;
//			puts("P");
		}
		else { // H | U | C
			int _ = 0; // -
			rep(j, 1, 15) {
				if(!b[j].op && vis[j] == i) {
					++_;
				}
			}
			if(_ == 2) { // C
				int ok = 0;
				rep(j, 1, 15) { // | 13
					if(vis[j] != i || !b[j].op) continue;
					rep(k, 1, 15) { // - up 14
						if(vis[k] != i || b[k].op) continue;
						rep(l, 1, 15) { // - down 15
							if(k == l || vis[l] != i || b[l].op) continue;
							if(b[l].d >= b[k].d) continue;
							if(b[j].d == b[l].d
							 && b[l].d < b[j].u
							 && b[j].u == b[k].d
							 && b[j].l == b[k].l
							 && b[k].l == b[l].l
							 && b[l].l < b[k].r
							 && b[k].r == b[l].r)
								ok = 1;
						}
					}
				}
				if(!ok) No;
//				puts("C");
			}
			else {
				// H
				int okH = 0;
				rep(j, 1, 15) { // | left 3
					if(vis[j] != i || !b[j].op) continue;
					rep(k, 1, 15) { // - 4
						if(vis[k] != i || b[k].op) continue;
						rep(l, 1, 15) { // | right 5
							if(j == l || vis[l] != i || !b[l].op) continue;
							if(b[l].l <= b[j].l) continue;
							if(b[j].d == b[l].d
							 && b[l].d < b[k].d
							 && b[k].d < b[j].u
							 && b[j].u == b[l].u
							 && b[j].l == b[k].l
							 && b[k].l < b[k].r
							 && b[k].r == b[l].l)
								okH = 1;
						}
					}
				}
				// U
				int okU = 0;
				rep(j, 1, 15) { // | left 6
					if(vis[j] != i || !b[j].op) continue;
					rep(k, 1, 15) { // - 7
						if(vis[k] != i || b[k].op) continue;
						rep(l, 1, 15) { // | right 8
							if(j == l || vis[l] != i || !b[l].op) continue;
							if(b[l].l <= b[j].l) continue;
							if(b[j].d == b[l].d
							 && b[l].d == b[k].d
							 && b[k].d < b[j].u
							 && b[j].u == b[l].u
							 && b[j].l == b[k].l
							 && b[k].l < b[k].r
							 && b[k].r == b[l].l)
								okU = 1;
						}
					}
				}
				H |= okH;
				U |= okU;
//				if(okH) puts("H");
//				if(okU) puts("U");
			}
		}
	}
	if(H && U) Yes;
	else No;
	return 0;
}
```

---

## 作者：FallingFYC_ (赞：1)

[原题](https://www.luogu.com.cn/problem/P8216)

调题时的~~心态炸裂~~快乐~

---
### 分析

分三步完成：

1. 合并线段
2. dfs 搜线段的连通块
3. 判断是否满足条件

~~PS：合并线段重构了 3 次，dfs 重构了 2 次，我太弱了awa~~

一步一步来说：

1. 合并线段

	用 sort 最方便，建议用 sort。
    
    输入后以 $x$ 和 $y$ 作为第一关键字，以 $l$ 和 $d$ 作为第二关键字，以 $r$ 和 $u$ 作为第三关键字排序，在判断相邻的两条线段是否重叠，重叠就合并成一条即可。
    
    **注意：最好不要边输入边判重叠，很容易挂！（WA 原因 1）**。
    
    代码：
    
    ```cpp
    bool cmp(Line a , Line b)
	{
        if (a.p != b.p) return a.p < b.p;
        if (a.l == b.l) return a.r < b.r;
        return a.l < b.l;
	}
    ```
    
    ```cpp
    vector<Line> tlx = lx , tly = ly;
    lx.clear(); ly.clear();
    sort(tlx.begin() , tlx.end() , cmp);
    sort(tly.begin() , tly.end() , cmp);
    for (auto i : tlx)
    {
        Line llx = lx.back();
        if (lx.empty()) {lx.push_back(i); continue;}
        if (llx.p == i.p && llx.r >= i.l) {lx.back().l = min(lx.back().l , i.l); lx.back().r = max(lx.back().r , i.r);}
        else lx.push_back(i);
    }
    for (auto i : tly)
    {
        Line lly = ly.back();
        if (ly.empty()) {ly.push_back(i); continue;}
        if (lly.p == i.p && lly.r >= i.l) {ly.back().l = min(ly.back().l , i.l); ly.back().r = max(ly.back().r , i.r);}
        else ly.push_back(i);
    }
    ```
    之后需要判断线段数量是否与题目相符，即横向线段 $7$ 条，纵向线段 $8$ 条。
    
2. dfs 搜线段的连通块

	漫水填充法实现。dfs 时一并判断连通块大小是否合规。**注意递归条件别写错！（WA 原因 2）**。
    
    代码：
    
    ```cpp
    bool check(Line a , Line b) //a:横向线段 b:纵向线段 
	{
		return (a.l <= b.p && b.p <= a.r && b.l <= a.p && a.p <= b.r);
	}
    ```
    不难发现，只有互相垂直的两条线段才能算一个连通块，如上代码是判断垂直的。
    ```cpp
    void dfs(bool t , Line nl , int nc , int sum)
  	{
        c[nc].push_back(make_pair(t , nl));
        if (sum > 4) wrong();

        if (!t) //横向
        {
            for (int i = 0 ; i < 8 ; i++)
                if (!bookly[i] && check(nl , ly[i]))
                {
                    bookly[i] = true; usedly[i] = true;
                    dfs(!t , ly[i] , nc , sum + 1);
                }
        }
        else //纵向
        {
            for (int i = 0 ; i < 7 ; i++)
                if (!booklx[i] && check(lx[i] , nl))
                {
                    booklx[i] = true; usedlx[i] = true;
                    dfs(!t , lx[i] , nc , sum + 1);
                }
        }
        return;
  	}
	```
    
    之后判断连通块数量是否为 $5$。
    
3. 判断是否满足条件
	
    直接按题目中的条件判断即可，用一个数组记录每个字母是否出现过，**注意题目中线段的位置顺序（从左往右，从上往下）！（WA 原因 3）**
    
    代码：
    
    ```cpp
    for (int i = 0 ; i < cnt ; i++)
    {
        int lxsum = 0 , lysum = 0;
        Line lx1 , lx2 , ly1 , ly2;
        lx1 = lx2 = ly1 = ly2 = (Line){-(INF + 5) , INF + 5 , INF + 5};
        for (auto j : c[i])
        {
            if (j.first == 0) {(lx1.r > INF ? lx1 : lx2) = j.second; ++lxsum;}
            else {(ly1.r > INF ? ly1 : ly2) = j.second; ++lysum;}
        }
        if (ly1.p > ly2.p && lysum == 2) swap(ly1 , ly2);
        if (lx1.p < lx2.p && lxsum == 2) swap(lx1 , lx2);
        if (lxsum == 1 && lysum == 1 && ly1.l < lx1.p && lx1.p == ly1.r && lx1.l < ly1.p && ly1.p < lx1.r) bookc[1] = true;
        else if (lxsum == 1 && lysum == 2 && ly1.l == ly2.l && ly2.l < lx1.p && lx1.p < ly1.r && ly1.r == ly2.r && ly1.p == lx1.l && lx1.l < lx1.r && lx1.r == ly2.p) bookc[2] = true;
        else if (lxsum == 1 && lysum == 2 && ly1.l == ly2.l && ly2.l == lx1.p && lx1.p < ly1.r && ly1.r == ly2.r && ly1.p == lx1.l && lx1.l < lx1.r && lx1.r == ly2.p) bookc[3] = true;
        else if (lxsum == 2 && lysum == 2 && ly1.l < lx2.p && lx2.p == ly2.l && ly2.l < ly1.r && ly1.r == lx1.p && lx1.p == ly2.r && ly1.p == lx1.l && lx1.l == lx2.l && lx2.l < lx1.r && lx1.r == lx2.r && lx2.r == ly2.p) bookc[4] = true;
        else if (lxsum == 2 && lysum == 1 && ly1.l == lx2.p && lx2.p < ly1.r && ly1.r == lx1.p && ly1.p == lx1.l && lx1.l == lx2.l && lx2.l < lx1.r && lx1.r == lx2.r) bookc[5] = true;
    }
    ```
    
    ~~幸好这里没炸……~~
    
    最后判断是否每种字母都出现了一遍。
    
---
### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
const int INF = 1e9;
using namespace std;
struct Line
{
    int l , r , p;
};
int n , op , l , r , y , d , u , x , lxsum , lysum , cnt;
vector<Line> lx , ly;
vector<pair<bool , Line>> c[20];
bool booklx[10] , bookly[10] , usedlx[10] , usedly[10] , bookc[10];

int max(int a , int b) {return (a > b ? a : b);}

int min(int a , int b) {return (a < b ? a : b);}

bool cmp(Line a , Line b)
{
    if (a.p != b.p) return a.p < b.p;
    if (a.l == b.l) return a.r < b.r;
    return a.l < b.l;
}

void wrong() {cout << "No"; exit(0);}

bool check(Line a , Line b) //a:横向线段 b:纵向线段 
{
	return (a.l <= b.p && b.p <= a.r && b.l <= a.p && a.p <= b.r);
}

void dfs(bool t , Line nl , int nc , int sum)
{
    c[nc].push_back(make_pair(t , nl));
    if (sum > 4) wrong();
    
    if (!t) //横向
    {
        for (int i = 0 ; i < 8 ; i++)
        {
            if (!bookly[i] && check(nl , ly[i]))
            {
                bookly[i] = true; usedly[i] = true;
				dfs(!t , ly[i] , nc , sum + 1);
            }
        }
    }
    else
    {
        for (int i = 0 ; i < 7 ; i++)
            if (!booklx[i] && check(lx[i] , nl))
            {
                booklx[i] = true; usedlx[i] = true;
				dfs(!t , lx[i] , nc , sum + 1);
            }
    }
    return;
}

signed main()
{
    cin >> n;
    while (n--)
    {
        cin >> op;
        if (!op)
        {
            cin >> l >> r >> y;
            lx.push_back((Line){l , r , y});
        }
        else
        {
            cin >> d >> u >> x;
            ly.push_back((Line){d , u , x});
        }
    }

    vector<Line> tlx = lx , tly = ly;
    lx.clear(); ly.clear();
    sort(tlx.begin() , tlx.end() , cmp);
    sort(tly.begin() , tly.end() , cmp);
    for (auto i : tlx)
    {
        Line llx = lx.back();
        if (lx.empty()) {lx.push_back(i); continue;}
        if (llx.p == i.p && llx.r >= i.l) {lx.back().l = min(lx.back().l , i.l); lx.back().r = max(lx.back().r , i.r);}
        else lx.push_back(i);
    }
    for (auto i : tly)
    {
        Line lly = ly.back();
        if (ly.empty()) {ly.push_back(i); continue;}
        if (lly.p == i.p && lly.r >= i.l) {ly.back().l = min(ly.back().l , i.l); ly.back().r = max(ly.back().r , i.r);}
        else ly.push_back(i);
    }
    lxsum = lx.size(); lysum = ly.size();
    if (lxsum != 7 || lysum != 8) wrong();

    for (int i = 0 ; i < 7 ; i++)
        if (!usedlx[i])
		{
			memset(booklx , 0 , sizeof(booklx)); 
			memset(bookly , 0 , sizeof(bookly));
			booklx[i] = true; usedlx[i] = true;
			dfs(0 , lx[i] , cnt++ , 0);
		}
    for (int i = 0 ; i < 8; i++)
        if (!usedly[i])
		{
			memset(booklx , 0 , sizeof(booklx)); 
			memset(bookly , 0 , sizeof(bookly));
			bookly[i] = true; usedly[i] = true;
			dfs(1 , ly[i] , cnt++ , 0);
		}
    if (cnt != 5) wrong();

    for (int i = 0 ; i < cnt ; i++)
    {
        int lxsum = 0 , lysum = 0;
        Line lx1 , lx2 , ly1 , ly2;
        lx1 = lx2 = ly1 = ly2 = (Line){-(INF + 5) , INF + 5 , INF + 5};
        for (auto j : c[i])
        {
            if (j.first == 0) {(lx1.r > INF ? lx1 : lx2) = j.second; ++lxsum;}
            else {(ly1.r > INF ? ly1 : ly2) = j.second; ++lysum;}
        }
        if (ly1.p > ly2.p && lysum == 2) swap(ly1 , ly2);
        if (lx1.p < lx2.p && lxsum == 2) swap(lx1 , lx2);
        if (lxsum == 1 && lysum == 1 && ly1.l < lx1.p && lx1.p == ly1.r && lx1.l < ly1.p && ly1.p < lx1.r) bookc[1] = true;
        else if (lxsum == 1 && lysum == 2 && ly1.l == ly2.l && ly2.l < lx1.p && lx1.p < ly1.r && ly1.r == ly2.r && ly1.p == lx1.l && lx1.l < lx1.r && lx1.r == ly2.p) bookc[2] = true;
        else if (lxsum == 1 && lysum == 2 && ly1.l == ly2.l && ly2.l == lx1.p && lx1.p < ly1.r && ly1.r == ly2.r && ly1.p == lx1.l && lx1.l < lx1.r && lx1.r == ly2.p) bookc[3] = true;
        else if (lxsum == 2 && lysum == 2 && ly1.l < lx2.p && lx2.p == ly2.l && ly2.l < ly1.r && ly1.r == lx1.p && lx1.p == ly2.r && ly1.p == lx1.l && lx1.l == lx2.l && lx2.l < lx1.r && lx1.r == lx2.r && lx2.r == ly2.p) bookc[4] = true;
        else if (lxsum == 2 && lysum == 1 && ly1.l == lx2.p && lx2.p < ly1.r && ly1.r == lx1.p && ly1.p == lx1.l && lx1.l == lx2.l && lx2.l < lx1.r && lx1.r == lx2.r) bookc[5] = true;
    }
    for (int i = 1 ; i <= 5 ; i++)
        if (!bookc[i]) wrong();
    cout << "Yes";
    return 0; 
}
```

---

## 作者：yshpdyt (赞：0)

## 题意
给定平面上若干条竖直或水平线段，判断线段是否可以构成 `THUPC` 的字样，详细规则如下（各个字母公式版描述看题目，或者看图很简单任意就能推出来）：

1. **重叠，相交，首尾相连**的**同向**线段应视为**同一条**线段。
2. 所有线段都被利用，不存在**多余的游离线段**。
3. `THUPC` 的各个字母可以**无序地排布在平面的任何地方**，但是不可以存在**重叠相交**。 
4. 对于字母 `T`，竖直线段上端点位于水平线段上，不与任意端点重叠，下端点低于水平线段。
5. 对于字母 `H`，两条竖直线段只有水平位置不同，水平线段两端点各位于一条竖直线段上，且不与任意端点重叠。
6. 对于字母 `U`，两条竖直线段只有水平位置不同，水平线段两端点分别只与一条垂直线段下端点相交。
7. 对于字母 `P`，两条水平线段只有高度不同，右边竖直线段两端点分别只与一条水平线段右端点相交，左边竖直线段上端点与较高水平线段左端点相交，下端点比较低水平线段还低。
8. 对于字母 `C`，两条水平线段只有高度不同，竖直线段两端点分别只与一条水平线段左端点相交。

输入数据保证所有线段的最小长度为 $1$，且均为整数。


![](https://cdn.luogu.com.cn/upload/image_hosting/oomfukad.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
## Sol
带模拟，难点在于认真读题不漏条件并发现可做，其实读完题意应该已经非常可做了，下面介绍具体的做法。

### Part 1 合并线段
根据题意，首先把重合的线段合并，这里以水平线段为例。

设第 $i$ 条水平线段高度，也就是 $y$ 坐标 为 $y_i$，左右端点横坐标为 $l_i,r_i$。

按照高度为第一关键字，左端点坐标为第二关键字升序排序。两条水平线段重叠需要满足如下条件：

1. $y_i = y_j$
2. $r_i \ge l_j$

从左往右扫，遇到可以合并线段就合并，也就是扩大右端点，直到无法合并，新增一条线段，然后重复操作。

竖直线段同理。

这部分的代码如下：
```cpp
void mergea(){
    a[++n]={inf,inf,inf};//额外结算以下下最后一条线段
    sort(a+1,a+n+1,cmpa);
    ll nowl=-inf,nowr=-inf,nowy=-inf;
    for(int i=1;i<=n;i++){
        if(a[i].y!=nowy){
            if(i!=1)f[++cntn]={nowl,nowr,nowy};
            nowl=a[i].l;
            nowr=a[i].r;
            nowy=a[i].y;
            continue;
        }
        if(a[i].l>nowr){
            if(i!=1)f[++cntn]={nowl,nowr,nowy};
            nowl=a[i].l;
            nowr=a[i].r;
            nowy=a[i].y;
        }
        nowr=max(nowr,a[i].r);//真正的合并部分，上面在判是否重叠
    }
    n=cntn;
    if(n!=7){
        cout<<"No\n";
        exit(0);
    }
}
void mergeb(){
    b[++m]={inf,inf,inf};
    sort(b+1,b+m+1,cmpb);
    ll nowl=-inf,nowr=-inf,nowx=-inf;
    for(int i=1;i<=m;i++){
        if(b[i].x!=nowx){
            if(i!=1)g[++cntm]={nowl,nowr,nowx};
            nowl=b[i].l;
            nowr=b[i].r;
            nowx=b[i].x;
            continue;
        }
        if(b[i].l>nowr){
            if(i!=1)g[++cntm]={nowl,nowr,nowx};
            nowl=b[i].l;
            nowr=b[i].r;
            nowx=b[i].x;
        }
        nowr=max(nowr,b[i].r);
    }
    m=cntm;
    if(m!=8){
        cout<<"No\n";
        exit(0);
    }
}
```
构成 `THUSC` 恰好需要 $7$ 条水平线段，$8$ 条竖直线段，题目不允许有多余，同时缺少线段一定无法构成，所以如果合并完线段的数量对不上，一定无解。。
### Part 2 匹配线段
$n=7,m=8$ 的数据可以很暴力了。

我们可以枚举水平线段与字母对应线段的匹配，对于每种匹配方式判断是否存在对应的竖直线段与之对应。


深搜时可以先匹配 `P` 和 `C`，因为他们由两条水平线段构成，如果匹配到的两个线段 $l,r$ 不同可以跳过匹配，减少匹配结果数，~~虽然不这么做应该也可以过~~。

具体来说，开一个栈维护当前线段顺序，从栈底到栈顶各位置标记为 $1 \sim 7$ ，规定 $1,2$ 位置为 `P` 的两条线段， $3,4$ 位置为 `C` 的两条线段，$5$ 位置为 `T` 的线段，$6$ 位置为 `H` 的线段，$7$ 位置为 `U` 的线段。

```cpp
void dfs(ll step){
    if(step==n){
        if(check2()){
            cout<<"Yes\n";
            exit(0);
        }
        return ;
    }
    for(int i=1;i<=n;i++){
        if(vis[i])continue;
        if(step==3||step==1){
            ll t=q[tp];
            if(f[t].l!=f[i].l)continue;
            if(f[t].r!=f[i].r)continue;
        }
        q[++tp]=i;
        vis[i]=1;
        dfs(step+1);
        tp--;
        vis[i]=0;
    }
}
```
### Part 3 判断合法部分

这部分其实还可以再分，先进行水平线段与竖直线段是否存在合法匹配，然后判断是否相交。

与竖直线段匹配没什么好说的，暴力查找，对着相应的条件写即可。个人感觉按照 `UPCTH` 的顺序最好找，找的时候标记每条竖直线段属于的字母。
``` cpp
bool check2(){
    //U H T  c   p
    //7 6 5 4 3 2 1
    for(int i=1;i<=m;i++)fl[i]=0;
    //UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
    ll t=q[7];//u
    ll fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l==f[t].y&&g[i].x==f[t].l){
            fll=1;
            fl[i]=7;
        }
        if(g[i].l==f[t].y&&g[i].x==f[t].r){
            flr=1;
            fl[i]=7;
        }
    }
    if(!fll||!flr)return 0;

    //cout<<"u\n";
    //PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
    ll t1=q[1],t2=q[2];//p
    if(f[t1].y>f[t2].y)swap(t1,t2);
    fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l<f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].l){
            fll=1;
            fl[i]=1;
        }
        if(g[i].l==f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].r){
            flr=1;
            fl[i]=1;
        }
    }
    if(!fll||!flr)return 0;
    
    //cout<<"up\n";
    //CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    t1=q[3],t2=q[4];//c
    if(f[t1].y>f[t2].y)swap(t1,t2);
    fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l==f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].l){
            fll=1;
            fl[i]=3;
        }
    }
    if(!fll)return 0;
    //cout<<"upc\n";

    //TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
    t=q[5];//t
    fll=flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l<f[t].y&&g[i].r==f[t].y&&g[i].x<f[t].r&&g[i].x>f[t].l){
            fll=1;
            fl[i]=5;
        }
    }
    if(!fll)return 0;
    //cout<<"tupc\n";

    //HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
    t=q[6];
    t1=0;
    t2=0;
    fll=0;
    flr=0;
    for(int i=1;i<=m;i++){
        if(!fl[i]){
            if(t1)t2=i;
            else t1=i;
            fl[i]=6;
        }
    }
    if(!t1||!t2)return 0;
    if(g[t1].x>g[t2].x)swap(t1,t2);
    if(g[t1].l!=g[t2].l)return 0;
    if(g[t1].r!=g[t2].r)return 0;
    if(g[t1].x!=f[t].l)return 0;
    if(g[t2].x!=f[t].r)return 0;
    if(g[t1].l>=f[t].y)return 0;
    if(g[t1].r<=f[t].y)return 0;
    //cout<<"thupc\n";
    return check1();
}
```
然后是判断字母之间相交的问题，同向线段之间肯定不会相交，与异向线段判断是否相交即可，注意如果两条线段属于同一字母，则可以相交。
```cpp
bool check1(){
    for(int i=1;i<=n;i++){
        ll k=i;
        if(i==2)k=1;
        if(i==4)k=3;
        for(int j=1;j<=m;j++){
            if(fl[j]==k)continue;
            ll t=q[i];
            if(f[t].l<=g[j].x&&f[t].r>=g[j].x&&g[j].l<=f[t].y&&g[j].r>=f[t].y)return 0;
        }
    }
    return 1;
}
```

然后这道题就处理完了，代码有点长但很好理解，很多细节问题都被题目的约束砍掉了，正如一开始所说，这道题的难点在于发现这是一道可做题，我们想到的过多细节其实是虚的。

时间复杂度~~大抵是~~ $O(N\log N+ nm\times (n!) )$，随便过了。

## Code

再来一遍整体的代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 200005
#define endl "\n" 
#define fi first
#define se second
using namespace std;
const ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
struct a1{
    ll l,r,y;
}a[N],f[N];//-
struct b1{
    ll l,r,x;
}b[N],g[N];//|
ll n,m,cntn,cntm;
bool cmpa(a1 x,a1 y){
    if(x.y==y.y){
        if(x.l==y.l)return x.r<y.r; 
        return x.l<y.l;
    }
    return x.y<y.y;
}
bool cmpb(b1 x,b1 y){
    if(x.x==y.x){
        if(x.l==y.l)return x.r<y.r; 
        return x.l<y.l;
    }
    return x.x<y.x;
}
bool vis[N];
ll fl[N];
// pcthu
ll q[N],tp;
bool check1(){
    for(int i=1;i<=n;i++){
        ll k=i;
        if(i==2)k=1;
        if(i==4)k=3;
        for(int j=1;j<=m;j++){
            if(fl[j]==k)continue;
            ll t=q[i];
            if(f[t].l<=g[j].x&&f[t].r>=g[j].x&&g[j].l<=f[t].y&&g[j].r>=f[t].y)return 0;
        }
    }
    return 1;
}
bool check2(){
    //U H T  c   p
    //7 6 5 4 3 2 1
    for(int i=1;i<=m;i++)fl[i]=0;
    //UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
    ll t=q[7];//u
    ll fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l==f[t].y&&g[i].x==f[t].l){
            fll=1;
            fl[i]=7;
        }
        if(g[i].l==f[t].y&&g[i].x==f[t].r){
            flr=1;
            fl[i]=7;
        }
    }
    if(!fll||!flr)return 0;

    //cout<<"u\n";
    //PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
    ll t1=q[1],t2=q[2];//p
    if(f[t1].y>f[t2].y)swap(t1,t2);
    fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l<f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].l){
            fll=1;
            fl[i]=1;
        }
        if(g[i].l==f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].r){
            flr=1;
            fl[i]=1;
        }
    }
    if(!fll||!flr)return 0;
    
    //cout<<"up\n";
    //CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    t1=q[3],t2=q[4];//c
    if(f[t1].y>f[t2].y)swap(t1,t2);
    fll=0,flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l==f[t1].y&&g[i].r==f[t2].y&&g[i].x==f[t1].l){
            fll=1;
            fl[i]=3;
        }
    }
    if(!fll)return 0;
    //cout<<"upc\n";

    //TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
    t=q[5];//t
    fll=flr=0;
    for(int i=1;i<=m;i++){
        if(fl[i])continue;
        if(g[i].l<f[t].y&&g[i].r==f[t].y&&g[i].x<f[t].r&&g[i].x>f[t].l){
            fll=1;
            fl[i]=5;
        }
    }
    if(!fll)return 0;
    //cout<<"tupc\n";

    //HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
    t=q[6];
    t1=0;
    t2=0;
    fll=0;
    flr=0;
    for(int i=1;i<=m;i++){
        if(!fl[i]){
            if(t1)t2=i;
            else t1=i;
            fl[i]=6;
        }
    }
    if(!t1||!t2)return 0;
    if(g[t1].x>g[t2].x)swap(t1,t2);
    if(g[t1].l!=g[t2].l)return 0;
    if(g[t1].r!=g[t2].r)return 0;
    if(g[t1].x!=f[t].l)return 0;
    if(g[t2].x!=f[t].r)return 0;
    if(g[t1].l>=f[t].y)return 0;
    if(g[t1].r<=f[t].y)return 0;
    //cout<<"thupc\n";
    return check1();
}
void dfs(ll step){
    if(step==n){
        if(check2()){
            cout<<"Yes\n";
            exit(0);
        }
        return ;
    }
    for(int i=1;i<=n;i++){
        if(vis[i])continue;
        if(step==3||step==1){
            ll t=q[tp];
            if(f[t].l!=f[i].l)continue;
            if(f[t].r!=f[i].r)continue;
        }
        q[++tp]=i;
        vis[i]=1;
        dfs(step+1);
        tp--;
        vis[i]=0;
    }
}
void mergea(){
    a[++n]={inf,inf,inf};//额外结算以下下最后一条线段
    sort(a+1,a+n+1,cmpa);
    ll nowl=-inf,nowr=-inf,nowy=-inf;
    for(int i=1;i<=n;i++){
        if(a[i].y!=nowy){
            if(i!=1)f[++cntn]={nowl,nowr,nowy};
            nowl=a[i].l;
            nowr=a[i].r;
            nowy=a[i].y;
            continue;
        }
        if(a[i].l>nowr){
            if(i!=1)f[++cntn]={nowl,nowr,nowy};
            nowl=a[i].l;
            nowr=a[i].r;
            nowy=a[i].y;
        }
        nowr=max(nowr,a[i].r);//真正的合并部分，上面在判是否重叠
    }
    n=cntn;
    if(n!=7){
        cout<<"No\n";
        exit(0);
    }
}
void mergeb(){
    b[++m]={inf,inf,inf};
    sort(b+1,b+m+1,cmpb);
    ll nowl=-inf,nowr=-inf,nowx=-inf;
    for(int i=1;i<=m;i++){
        if(b[i].x!=nowx){
            if(i!=1)g[++cntm]={nowl,nowr,nowx};
            nowl=b[i].l;
            nowr=b[i].r;
            nowx=b[i].x;
            continue;
        }
        if(b[i].l>nowr){
            if(i!=1)g[++cntm]={nowl,nowr,nowx};
            nowl=b[i].l;
            nowr=b[i].r;
            nowx=b[i].x;
        }
        nowr=max(nowr,b[i].r);
    }
    m=cntm;
    if(m!=8){
        cout<<"No\n";
        exit(0);
    }
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    ll ttt;
    cin>>ttt;
    while(ttt--){
        ll op,l,r,h;
        cin>>op>>l>>r>>h;
        if(op==0)a[++n]={l,r,h};
        if(op==1)b[++m]={l,r,h};
    }
    mergea();
    mergeb();
    dfs(0);
    cout<<"No\n";
    return 0;
}

```

---

## 作者：mRXxy0o0 (赞：0)

考虑优雅地去实现这道模拟题（代码 $2.5KB$）。

# 分析

最大的难点真的就是记住每一个限制（读错题导致差点写了线段树）。这里提取最关键的两个：**有交且同向的线段会合并、每个字母的组成线段不能有交**。

首先，合并一下线段，三关键字排序即可。这里可以复用原数组减少空间及码量。合并完判断一下，应该刚好 $15$ 条线段，其中 $7$ 横 $8$ 竖。

其次，利用一下第二个限制，可以得到：线段间有交的必然在同一个字母。这里用一个并查集简单地去维护。注意要记录一下每个联通块的大小，方便后面判断。

最后，按照边数分类，依次判断能否组成指定字母即可。

思路比较清晰，唯一难点可能是在最后一步的判断上，作为本篇题解唯一暴力模拟的地方，照着题面慢慢敲式子就好~~（赞美良心出题人）~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int N=1e5+10,rx[6]={0,1,1,1,2,2},ry[6]={0,1,2,2,2,1};
int n,tot,cx,cy,num,fa[N],cnt[N];
bool fg[N];
vector<pii>hav;
struct node{
	int op,l,r,x;
}a[N],lx[N],ly[N];
inline bool cmp(node x,node y){
	return x.op==y.op?(x.x==y.x?x.l<y.l:x.x<y.x):x.op<y.op;
}
inline int gf(int x){
	return fa[x]==x?x:fa[x]=gf(fa[x]);
}
inline bool check(int p,int tp){
	cx=cy=0;
	for(int i=1;i<=n;++i){
		if(gf(i)==hav[p].second){
			if(a[i].op) ly[++cy]=a[i];
			else lx[++cx]=a[i];
		}
	}
	if(cx!=rx[tp]||cy!=ry[tp]) return 0;
	switch (tp){
		case 1:
			return ly[1].l<lx[1].x&&lx[1].x==ly[1].r&&lx[1].l<ly[1].x&&ly[1].x<lx[1].r;
		case 2:
			return ly[1].l==ly[2].l&&ly[2].l<lx[1].x&&lx[1].x<ly[1].r&&ly[1].r==ly[2].r&&ly[1].x==lx[1].l&&lx[1].l<lx[1].r&&lx[1].r==ly[2].x;
		case 3:
			return ly[1].l==ly[2].l&&ly[2].l==lx[1].x&&lx[1].x<ly[1].r&&ly[1].r==ly[2].r&&ly[1].x==lx[1].l&&lx[1].l<lx[1].r&&lx[1].r==ly[2].x;
		case 4:
			return ly[1].l<lx[1].x&&lx[1].x==ly[2].l&&ly[2].l<ly[1].r&&ly[1].r==ly[2].r&&ly[2].r==lx[2].x&&ly[1].x==lx[1].l&&lx[1].l==lx[2].l&&lx[2].l<lx[2].r&&lx[2].r==lx[1].r&&lx[1].r==ly[2].x;
		case 5:
			return ly[1].l==lx[1].x&&lx[1].x<ly[1].r&&ly[1].r==lx[2].x&&ly[1].x==lx[1].l&&ly[1].x==lx[2].l&&lx[2].l<lx[2].r&&lx[2].r==lx[1].r;
	}
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d%d%d",&a[i].op,&a[i].l,&a[i].r,&a[i].x);
	}
	sort(a+1,a+1+n,cmp);
	tot=1;
	for(int i=1;i<=n;++i){
		if(a[i].op!=a[tot].op||a[i].x!=a[tot].x||a[i].l>a[tot].r) a[++tot]=a[i];
		else a[tot].r=max(a[tot].r,a[i].r);
	}
	if(tot!=15) return puts("No"),0;
	n=tot;
	for(int i=1;i<=n;++i){
		if(!a[i].op) ++cx;
		else ++cy;
		fa[i]=i;
		cnt[i]=1;
	}
	if(cx!=7||cy!=8) return puts("No"),0;
	for(int i=1;i<=cx;++i){
		for(int j=cx+1;j<=n;++j){
			if(a[i].l<=a[j].x&&a[j].x<=a[i].r&&a[j].l<=a[i].x&&a[i].x<=a[j].r){
				int fx=gf(i),fy=gf(j);
				if(fx!=fy){
					fa[fx]=fy;
					cnt[fy]+=cnt[fx];
				}
			}
		}
	}
	for(int i=1;i<=n;++i){
		if(gf(i)==i) hav.push_back({cnt[i],i});
	}
	sort(hav.begin(),hav.end());
	if(hav.size()!=5||hav[0].first!=2||hav[1].first!=3||hav[2].first!=3||hav[3].first!=3||hav[4].first!=4) return puts("No"),0;
	if(check(0,1)&&check(4,4)&&((check(1,2)&&check(2,3)&&check(3,5))||(check(1,2)&&check(3,3)&&check(2,5))||(check(2,2)&&check(1,3)&&check(3,5))||(check(2,2)&&check(3,3)&&check(1,5))||(check(3,2)&&check(1,3)&&check(2,5))||(check(3,2)&&check(2,3)&&check(1,5)))) puts("Yes");
	else puts("No");
	return 0;
}
```


---

## 作者：donghanwen1225 (赞：0)

写题解的原因：赛时写这题，30min 时就只有一处小 bug（合并线段的时候没考虑重叠），结果直到比赛结束也没找出来，赛后 7min 的时候发现的，之后出数据一发就过了。

------------

大模拟。

首先把能首尾相接的线段全部拼接起来。**注意：线段可以重叠！！！**

拼接完成后，可以发现水平线段应当有 $7$ 条，竖直线段应当有 $8$ 条。不满足该条件则直接判定无解。

若满足了该条件，则需要去寻找 `T H U P C` 五个字母。因为这五个字母各有其特殊之处，无论按什么顺序去寻找都不影响正确性（也就是说，如果符合要求那么无论如何也能找出来，不符合要求无论如何也找不出来），所以我们直接暴力寻找每一个字母即可。

我在实现这一过程时，用的是多重循环枚举，然后暴力判断。最终如果五个字母全部找到则输出 `YES`，否则输出 `NO` 即可。

code：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ok=1,cnt1,cnt2,e1,e2,bj1[21],bj2[21];
struct seg
{
	int l,r,x;
} s1[1000001],s2[1000001],n1[1000001],n2[1000001];
bool cmpp(seg a1,seg a2){return a1.x<a2.x;}
bool cmp(seg a1,seg a2){return a1.l<a2.l;}
bool check(int op1,seg s1,int op2,seg s2)
{
	// s1 是纵向线段，s2 是横向线段 
	// 可以发现这个 op1 和 op2 是没用的
	if(s1.x<s2.l||s1.x>s2.r) return 0;
	if(s2.x<s1.l||s2.x>s1.r) return 0;
	return 1;
}
void findt()
{
	if(!ok) return;
	for(int i=1;i<=7;i++)
		for(int j=1;j<=8;j++)
			if(n2[j].r==n1[i].x&&n1[i].l<n2[j].x&&n1[i].r>n2[j].x)
			{
				int flag=1;
				for(int ii=1;ii<=7;ii++)
					if(ii!=i)
						if(check(2,n2[j],1,n1[ii])){flag=0;break;}
				for(int ii=1;ii<=8;ii++)
					if(ii!=j)
						if(check(2,n2[ii],1,n1[i])){flag=0;break;}
				if(flag){bj1[i]=1;bj2[j]=1;return;}
			}
	ok=0;
//	printf("#1\n");
}
void findh()
{
	if(!ok) return;
	for(int i=1;i<=7;i++)
		for(int j1=1;j1<=8;j1++)
			for(int j2=1;j2<=8;j2++)
			{
				if(bj1[i]||bj2[j1]||bj2[j2]) continue;
				if(j1==j2) continue;
				if(n2[j1].l!=n2[j2].l||n2[j1].r!=n2[j2].r||n2[j1].x==n2[j2].x) continue;
				if(n1[i].l==min(n2[j1].x,n2[j2].x)&&n1[i].r==max(n2[j1].x,n2[j2].x)&&n2[j1].l<n1[i].x&&n1[i].x<n2[j1].r)
				{
					int flag=1;
					for(int ii=1;ii<=7;ii++)
						if(ii!=i)
							if(check(2,n2[j1],1,n1[ii])||check(2,n2[j2],1,n1[ii])){flag=0;break;}
					for(int ii=1;ii<=8;ii++)
						if(ii!=j1&&ii!=j2)
							if(check(2,n2[ii],1,n1[i])){flag=0;break;}
					if(flag){bj1[i]=1;bj2[j1]=1;bj2[j2]=1;return;}
				}
			}
	ok=0;
//	printf("#2\n");
}
void findu()
{
	if(!ok) return;
	for(int i=1;i<=7;i++)
		for(int j1=1;j1<=8;j1++)
			for(int j2=1;j2<=8;j2++)
			{
				if(bj1[i]||bj2[j1]||bj2[j2]) continue;
				if(j1==j2) continue;
				if(n2[j1].l!=n2[j2].l||n2[j1].r!=n2[j2].r||n2[j1].x==n2[j2].x) continue;
				if(n1[i].l==min(n2[j1].x,n2[j2].x)&&n1[i].r==max(n2[j1].x,n2[j2].x)&&n2[j1].l==n1[i].x)
				{
					int flag=1;
					for(int ii=1;ii<=7;ii++)
						if(ii!=i)
							if(check(2,n2[j1],1,n1[ii])||check(2,n2[j2],1,n1[ii])){flag=0;break;}
					for(int ii=1;ii<=8;ii++)
						if(ii!=j1&&ii!=j2)
							if(check(2,n2[ii],1,n1[i])){flag=0;break;}
					if(flag){bj1[i]=1;bj2[j1]=1;bj2[j2]=1;return;}
				}
			}
	ok=0;
//	printf("#3\n");
}
void findc()
{
	if(!ok) return;
	for(int i1=1;i1<=7;i1++)
		for(int i2=1;i2<=7;i2++)
			for(int j=1;j<=8;j++)
			{
				if(bj1[i1]||bj1[i2]||bj2[j]) continue;
				if(i1==i2) continue;
				if(n1[i1].l!=n1[i2].l||n1[i1].r!=n1[i2].r||n1[i1].x==n1[i2].x) continue;
				if(n2[j].l==min(n1[i1].x,n1[i2].x)&&n2[j].r==max(n1[i1].x,n1[i2].x)&&n1[i1].l==n2[j].x)
				{
					int flag=1;
					for(int ii=1;ii<=7;ii++)
						if(ii!=i1&&ii!=i2)
							if(check(2,n2[j],1,n1[ii])){flag=0;break;}
					for(int ii=1;ii<=8;ii++)
						if(ii!=j)
							if(check(2,n2[ii],1,n1[i1])||check(2,n2[ii],1,n1[i2])){flag=0;break;}
					if(flag){bj1[i1]=1;bj1[i2]=1;bj2[j]=1;return;}
				}
			}
	ok=0;
//	printf("#4\n");
}
void findp()
{
	if(!ok) return;
	for(int i1=1;i1<=7;i1++)
		for(int i2=1;i2<=7;i2++)
			for(int j1=1;j1<=8;j1++)
				for(int j2=1;j2<=8;j2++)
				{
					if(bj1[i1]||bj1[i2]||bj2[j1]||bj2[j2]) continue;
					if(i1==i2||j1==j2) continue;
					if(n1[i1].l!=n1[i2].l||n1[i1].r!=n1[i2].r||n1[i1].x==n1[i2].x) continue;
					if(n2[j1].r!=n2[j2].r||n2[j1].l==n2[j2].l||n2[j1].x==n2[j2].x) continue;
					if(min(n2[j1].x,n2[j2].x)==n1[i1].l&&max(n2[j1].x,n2[j2].x)==n1[i1].r&&max(n1[i1].x,n1[i2].x)==n2[j1].r)
					{
						seg S1=n1[i1],S2=n1[i2],S3=n2[j1],S4=n2[j2];
						if(S1.x>S2.x) swap(S1,S2);
						if(S3.x>S4.x) swap(S3,S4);
						if(S3.l<S4.l&&S1.x==S4.l)
						{
							int flag=1;
							for(int ii=1;ii<=7;ii++)
								if(ii!=i1&&ii!=i2)
									if(check(2,n2[j1],1,n1[ii])||check(2,n2[j2],1,n1[ii])){flag=0;break;}
							for(int ii=1;ii<=8;ii++)
								if(ii!=j1&&ii!=j2)
									if(check(2,n2[ii],1,n1[i1])||check(2,n2[ii],1,n1[i2])){flag=0;break;}
							if(flag){bj1[i1]=1;bj1[i2]=1;bj2[j1]=1;bj2[j2]=1;return;}
						}
					}
				}
	ok=0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int op,l,r,x;
		cin>>op>>l>>r>>x;
		if(op==0) s1[++cnt1]={l,r,x};
		else s2[++cnt2]={l,r,x};
	}
	sort(s1+1,s1+1+cnt1,cmpp);sort(s2+1,s2+1+cnt2,cmpp);
	for(int l=1,r=1;r<=cnt1;l=r+1)
	{
		r=l;
		while(s1[r+1].x==s1[l].x&&r+1<=cnt1) r++;
		sort(s1+l,s1+1+r,cmp);
		seg cur=s1[l];
		for(int j=l+1;j<=r;j++)
		{
			if(s1[j].l<=cur.r)
				cur.r=max(cur.r,s1[j].r);
			else
			{
				n1[++e1]=cur;
				cur=s1[j];
			}
		}
		n1[++e1]=cur;
		if(r==cnt1) break;
	}
	for(int l=1,r=1;r<=cnt2;l=r+1)
	{
		r=l;
		while(s2[r+1].x==s2[l].x&&r+1<=cnt2) r++;
		sort(s2+l,s2+1+r,cmp);
		seg cur=s2[l];
		for(int j=l+1;j<=r;j++)
		{
			if(s2[j].l<=cur.r)
				cur.r=max(cur.r,s2[j].r);
			else
			{
				n2[++e2]=cur;
				cur=s2[j];
			}
		}
		n2[++e2]=cur;
		if(r==cnt2) break;
	}
	if(e1!=7||e2!=8) ok=0;
	findc();findp();findu();findh();findt();
	cout<<(ok==1?"Yes":"No");
	return 0;
}
/*
17
0 1 2 100
0 1 2 -100
0 2 9 90
1 75 90 5
1 65 70 4
1 65 70 6
0 4 6 68
1 50 60 8
1 50 60 20
0 8 20 50
1 52 58 12
1 54 58 16
0 12 16 58
0 12 16 54
1 -100 -99 1
1 -99 -89 1
1 -95 100 1

YES
*/
```

---

## 作者：GIFBMP (赞：0)

#### 正题

首先我们把所有线段分成水平和竖直两类排序，对于有交且类型相同的线段合并即可。

然后判断剩下的线段是否只有 $15$ 条，如果没有直接判断无解，否则直接跑一遍 dfs，依题意模拟并判断即可。记得每搜索一个图形，就要判断一次，否则最坏理论时间复杂度可能会超时。

有几个需要注意的点：

1. 不要把题目描述中的 $y$ 和输入中的 $y$ 搞混；
2. `puts()` 函数的返回值不一定是 $0$，因此不能直接 `return puts("") ;`，可能会导致 `RE`（当时在考场上我因为这个给我们队贡献了 $18$ 发罚时）；
3. 记得每加入一条线段就要判断是否和之前的图形相交；

如果有不懂的地方可以看代码理解。

时间复杂度比较玄学，但是可以稳稳跑过。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std ;
const int MAXN = 1e6 + 10 ;
struct node {
	long long opt , l , r , y ;
	bool operator < (const node &x) const {
		return y == x.y ? l < x.l : y < x.y ;
	}
} a[MAXN] , b[MAXN] , c[MAXN] ;
node st[MAXN] , ans[MAXN] ;
int n , c1 , c2 , tp , tot ;
bool vis[MAXN] ;
bool dd[20] = {0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0} ;
bool ck (node x , node y) {
	if (x.opt == y.opt) return 0 ;
	if (x.y >= y.l && x.y <= y.r && y.y >= x.l && y.y <= x.r) return 1 ;
	return 0 ;
}
int K;
int check (int x) {
	if (x == 2) {
		if (ans[2].l >= ans[1].y || ans[1].y != ans[2].r) return 0 ;
		if (ans[1].l >= ans[2].y || ans[2].y >= ans[1].r) return 0 ;
		return 1 ;
	}
	if (x == 5) {	
		if (ans[3].l != ans[5].l || ans[5].l >= ans[4].y || ans[4].y >= ans[3].r || ans[3].r != ans[5].r) return 0 ;
		if (ans[3].y != ans[4].l || ans[4].l >= ans[4].r || ans[4].r != ans[5].y) return 0 ;
		for (int i = 1 ; i < 3 ; i++)
			for (int j = 3 ; j < 6 ; j++)
				if (ck (ans[i] , ans[j])) return 0 ;
		return 1 ;
	}
	if (x == 8) {
		for (int i = 1 ; i < 6 ; i++)
			for (int j = 6 ; j < 9 ; j++)
				if (ck (ans[i] , ans[j])) return 0 ;
		if (ans[6].l != ans[8].l || ans[8].l != ans[7].y || ans[7].y >= ans[6].r || ans[6].r != ans[8].r) return 0 ;
		if (ans[6].y != ans[7].l || ans[7].l >= ans[7].r || ans[7].r != ans[8].y) return 0 ;
		return 1 ;
	}
	if (x == 12) {
		for (int i = 1 ; i < 9 ; i++)
			for (int j = 9 ; j < 13 ; j++)
				if (ck (ans[i] , ans[j])) return 0 ;
		if (ans[9].l >= ans[11].y || ans[11].y != ans[12].l || ans[12].l >= ans[9].r || ans[9].r != ans[10].y || ans[10].y != ans[12].r) return 0 ;
		if (ans[9].y != ans[10].l || ans[10].l != ans[11].l || ans[11].l >= ans[10].r || ans[10].r != ans[11].r || ans[11].r != ans[12].y) return 0 ;
		return 1 ;
	}
	if (x == 15) {
		for (int i = 1 ; i < 13 ; i++)
			for (int j = 14 ; j < 16 ; j++)
				if (ck (ans[i] , ans[j])) return 0 ;
		if (ans[13].l != ans[15].y || ans[15].y >= ans[13].r || ans[13].r != ans[14].y) return 0 ;
		if (ans[13].y != ans[14].l || ans[14].l != ans[15].l || ans[15].l >= ans[14].r || ans[14].r != ans[15].r) return 0 ;
		return 1 ;
	}
	return 1 ;
}
bool flag = 0 ;
int pp = 0 ;
void dfs (int x) {
	if (x > tot) {
		puts ("Yes") ;
		flag = 1 ;
		return ;
	}
	for (int i = 1 ; i <= tot ; i++) {
		if (vis[i]) continue ;
		if (c[i].opt != dd[x]) continue ;
		ans[x] = c[i] ;
		if (!check (x)) continue ;
		vis[i] = 1 ;
		dfs (x + 1) ;
		if (flag) return ;
		vis[i] = 0 ;
	}
}
int main () {
	scanf ("%d" , &n) ;
	for (int i = 1 , op ; i <= n ; i++) {
		scanf ("%d" , &op) ;
		if (!op) c1++ , scanf ("%lld%lld%lld" , &a[c1].l , &a[c1].r , &a[c1].y) ;
		else c2++ , scanf ("%lld%lld%lld" , &b[c2].l , &b[c2].r , &b[c2].y) ;
	}
	sort (a + 1 , a + c1 + 1) ;
	sort (b + 1 , b + c2 + 1) ;
	for (int i = 1 ; i <= c1 ; i++) {
		if (i == 1 || a[i].y != a[i - 1].y) st[++tp] = a[i] ;
		else {
			if (a[i].l <= st[tp].r) st[tp].r = max (st[tp].r , a[i].r) ;
			else st[++tp] = a[i] ;
		}
	}
	c1 = tp ;
	for (int i = 1 ; i <= c1 ; i++) a[i] = st[i] ;
	tp = 0 ;
	for (int i = 1 ; i <= c2 ; i++) {
		if (i == 1 || b[i].y != b[i - 1].y) st[++tp] = b[i] ;
		else {
			if (b[i].l <= st[tp].r) st[tp].r = max (st[tp].r , b[i].r) ;
			else st[++tp] = b[i] ;
		}
	}
	c2 = tp ;
	for (int i = 1 ; i <= c2 ; i++) b[i] = st[i] ;
	if (c1 + c2 != 15 || c2 != 8 || c1 != 7) {
	    puts ("No") ;
	    return 0 ;
	}
	for (int i = 1 ; i <= c1 + c2 ; i++)
		c[i] = (i <= c1 ? a[i] : b[i - c1]) , c[i].opt = (i <= c1 ? 0 : 1) ;
	tot = c1 + c2 ;
//	printf ("%d\n" , tot) ;
//	for (int i = 1 ; i <= tot ; i++)
//		printf ("%d %d %d %d\n" , c[i].opt , c[i].l , c[i].r , c[i].y) ;
	dfs (1) ;
	if (!flag) puts ("No") ;
	return 0 ;
}
```

---


# [THUPC 2023 决赛] 百合

## 题目背景

葡萄藤上开不出百合花。

## 题目描述

你落在一个巨大的葡萄架上，上面一共有 $2^k$ 朵百合花和 $m$ 条葡萄藤。其中，百合花编号为 $0$ 到 $2^k-1$ 的整数，第 $i$ 条葡萄藤连接了编号为 $x_i, y_i$ 的百合花。

你可以花费 $c_i$ 的时间通过第 $i$ 条葡萄藤，也就是从 $x_i$ 走到 $y_i$，或者反过来；还可以花费 $a_k$ 的时间从 $x$ 闪现到 $y$，其中 $x, y$ 是任意两朵百合花，$k$ 是它们在二进制表示下不同的比特数。例如，$3$ 的二进制表示是 $011$，$5$ 的二进制表示是 $101$，它们有两位不同，因此从 $3$ 闪现到 $5$ 花费的时间是 $a_2$。

假设你恰好落在编号为 $s$ 的百合花上，求从 $s$ 出发到每一朵百合花所需要的最短时间。

## 说明/提示

**【数据范围】**

对于所有测试数据，$1 \le k \leq 17$，$1 \le m \leq 2 \times 10^5$，$0 \leq s,x_i,y_i \leq 2^k - 1$，$0 \le a_i, c_i \leq 2^{30} - 1$。

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3 6 2
17 14 11 
0 2 3
4 2 9
2 2 1
2 2 6
7 0 5
4 2 9
```

### 输出

```
3 14 0 17 9 11 17 8
```

# 题解

## 作者：EuphoricStar (赞：10)

复读官方题解。

考虑除了原图的 $2^k$ 个点，再建一些辅助点，$(u, i, j)$ 表示前 $i$ 位中修改了 $j$ 位得到 $u$。那么除了原图的 $m$ 条边，我们还有下面这些边：

- $u \xrightarrow{0} (u, 0, 0)$；
- $\forall i < k, (u, i, j) \xrightarrow{0} (u, i + 1, j)$；
- $\forall i < k, (u, i, j) \xrightarrow{0} (u \oplus 2^i, i + 1, j + 1)$；
- $(u, k, j) \xrightarrow{a_j} u$。

到这里可以做 $O(2^k k^3)$，但是还不够。

观察这个图，发现非 $0$ 边仅有 $O(2^k k)$ 条，于是我们在外层 Dijkstra 的同时，内层对 $u$ 能到达的所有辅助点跑一遍 BFS，给每个辅助点打上是否被访问过的标记，于是每个辅助点只会被访问一次，又因为非 $0$ 边仅有 $O(2^k k)$ 条，所以外层的堆也只会被 push 这么多次。所以时间复杂度就是 $O(2^k k^2)$，空间复杂度也是 $O(2^k k^2)$。

[code](https://loj.ac/s/1954661)

---

## 作者：Albert_van (赞：3)

容易想到加辅助点建图直接最短路。稍微做一些尝试，发现只加 $n=2^k$ 甚至 $k$ 个点是无法满足要求的。考虑加 $nk$ 个点，$(u,j)$ 表示当前在 $u$，这一次传送已经修改了 $j$ 位。保留原图 $m$ 条边，连边 $u\to (u,0),(u,j)\to (u\oplus 2^i,j+1)$（边权均为 $0$），$(u,j)\to u$ 边权 $a_j$。问题来了，一个位置 $i$ 可能被修改两次。

考虑再阔一点，直接加 $nk^2$ 个辅助点，$(u,i,j)$ 表示当前在 $u$，现在考虑第 $i$ 位，这一次传送已经修改了 $j$ 位。这允许我们不重复地枚举 $i$。连边

- $u\to(u,0,0)$
- $(u,i,j)\to(u\oplus 2^i,i+1,j+1)$
- $(u,i,j)\to(u,i+1,j)$
- $(u,k,j)\to u$，边权 $a_j$

加原图 $m$ 条边跑最短路即可。然而该图边数 $\mathcal O(nk^2)$，Dij 复杂度 $\mathcal O(nk^3)$ 无法接受。

考虑边权不为 $0$ 的边只有 $\mathcal O(nk)$ 条。这启发我们对辅助点部分的求解过程做出优化。具体地，对于原图点 $u$，暴力搜出它能**不经过其它原图点**到达的所有辅助点，拿 $f_u+a_j$ 直接更新接下来的原图点即可。搜的过程中对辅助点做上标记，遇到标记过的点就不继续搜。正确性显然，dij 是基于贪心的。

于是复杂度降为 $\mathcal O(nk\log(nk)+nk^2)=\mathcal O(nk^2)$。

```cpp
void dij(int s){
	memset(f,63,sizeof(f));
	q.push((nod){s,f[s]=0});
	while(!q.empty()){
		int now=q.top().x;q.pop();if(vis[now]) continue;
		vis[now]=1;for(auto[v,w]:vc[now]) if(f[now]+w<f[v]) q.push((nod){v,f[v]=f[now]+w});
		qx.push((xzr){now,0,0});while(!qx.empty()){
			auto[u,i,j]=qx.front();qx.pop();
			vix[i][j][u]=1;if(i==k){
				if(f[now]+a[j]<f[u]) q.push((nod){u,f[u]=f[now]+a[j]});
				continue;
			}
			if(!vix[i+1][j][u]) qx.push((xzr){u,i+1,j});
			if(!vix[i+1][j+1][u^(1<<i)]) qx.push((xzr){u^(1<<i),i+1,j+1});
		}
	}
}
```



---

## 作者：Phartial (赞：2)

很难直接建出原图，“从 $x$ 中取出 $k$ 位并取反”这件事也很难直接描述，考虑每次只决策一位，设计辅助状态 $(x,i,j)$ 表示已经决策了前 $i$ 位，取反了其中 $j$ 位后得到的值是 $x$，描述建边是不难的：

- 对给定的每条边 $(x,y,c)$，建边 $(x,0,0)\stackrel{c}{\longleftrightarrow}(y,0,0)$；
- 对状态 $(x,i,j)$（$i<k$），建边 $(x,i,j)\stackrel{0}{\longrightarrow}(x,i+1,j)$；
- 对状态 $(x,i,j)$（$i<k$），建边 $(x,i,j)\stackrel{0}{\longrightarrow}(x\oplus2^i,i+1,j+1)$，其中 $\oplus$ 是按位异或；
- 对状态 $(x,k,j)$，建边 $(x,k,j)\stackrel{a_j}{\longrightarrow}(x,0,0)$。

这张图的点数是 $N=2^kk^2$，边数是 $M=\mathcal{O}(m+2^kk^2)$，于是直接在上面跑 Dijkstra 的时间复杂度是 $\mathcal{O}((M+N)\log N)=\mathcal{O}(mk+2^kk^3)$ 的，不太能过。

注意到这张图里其实有很多 $0$ 权边。假设我们正在松弛状态 $u$ 的出边，则对其 $0$ 权出边与到达的未确定最短路的点 $v$，$v$ 的最短路一定会被更新成 $u$ 的最短路，并在下一轮松弛中被立即处理。

于是我们可以把这个过程单独提出来：松弛一个状态 $u$ 时立即更新并松弛其所有 $0$ 权出点 $v$，这是一个类似 BFS 的过程（当然写成 DFS 也行），可以线性地完成。

于是只有在松弛非 $0$ 权边时我们需要对维护的数据结构（比如优先队列）进行操作，而非 $0$ 权边只有 $M'=m+2^kk$ 条，于是总时间复杂度是 $\mathcal{O}((M'+N)\log N)=\mathcal{O}(mk+2^kk^2)$ 的，可以通过。

最后就是这个东西空间有点紧，但是事实上我们只要维护形如 $(x,0,0)$ 的状态的最短路，精细实现一下就开得下了。

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;
using LL = long long;
using Pli = pair<LL, int>;

const int kK = 18, kN = (1 << kK - 1);

struct S {
  int x, i, j;
} q[kN * 2];
int k, n, m, s, qh, qt, a[kK];
LL d[kN];
bool v[kN][kK][kK];
vector<pair<int, int>> e[kN];
priority_queue<Pli, vector<Pli>, greater<Pli>> pq;

void R(int x, LL _d) {
  if (_d < d[x]) {
    d[x] = _d, pq.emplace(_d, x);
  }
}
void R(int x, int i, int j) {
  if (!v[x][i][j]) {
    v[x][i][j] = 1, q[++qt] = {x, i, j};
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> k >> m >> s, n = (1 << k);
  for (int i = 1; i <= k; ++i) {
    cin >> a[i];
  }
  for (int i = 1, x, y, w; i <= m; ++i) {
    cin >> x >> y >> w;
    e[x].emplace_back(y, w);
    e[y].emplace_back(x, w);
  }
  fill_n(d, n, 1e18);
  for (R(s, 0); !pq.empty();) {
    int x = pq.top().second;
    pq.pop();
    for (auto i : e[x]) {
      R(i.first, d[x] + i.second);
    }
    qh = 1, qt = 0;
    for (R(x, 0, 0); qh <= qt; ++qh) {
      S y = q[qh];
      if (y.i < k) {
        R(y.x, y.i + 1, y.j);
        R(y.x ^ (1 << y.i), y.i + 1, y.j + 1);
      } else {
        R(y.x, d[x] + a[y.j]);
      }
    }
  }
  for (int i = 0; i < n; ++i) {
    cout << d[i] << ' ';
  }
  return 0;
}
```

---

## 作者：GI录像机 (赞：1)

## 题解：

这是一个乱搞做法，但达到了你谷最优解第一页，最慢点650ms。

考虑 dijkstra，直接建闪现边的话需要 $O(2^{2k})$ 条边，显然是不优的。在 dijkstra 过程中，如果一个点被 $a_i<=a_j$ 的 $a_i$ 尝试更新过，那它显然不需要再被 $a_j$更新，这是因为先前算完的点 $dis$ 一定小于当前点的 $dis$。

故而建立 $k$ 个 vector，第 $i$ 个 vector 里存已经被 $a_i$ 尝试更新过的点的集合。

然后 dijkstra 时，算完每个点的 $dis$ 后，对于每个 $i\le k$ 向堆中添加权值为 $dis+a_i$ 的点，用这些点去更新所有 $a_j>a_i$ 的集合 $j$ 中的点，把集合 $j$ 中满足 $\operatorname{\_\_builtin\_popcount}(u\bigoplus pos)=i$，的点扔进集合 $i$。

但是 $i=1$ 的情况下，遍历一次 $O(n)$ 的复杂度却至多只能将 $k$ 个点放到 $a$ 更小的集合，显然不够优秀。

所以对于 $i\le 2$ 或 $i\ge k-2$ 的情况，我们直接枚举它们的 $C(i,k)$ 个后继状态更新即可。

然后就通过此题了

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c > '9' || c < '0') {
		if(c == '-')f = -f;
		c = getchar();
	}
	while(c <= '9' && c >= '0') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
void write(int x) {
	if(x < 0) {
		putchar('-');
		x = -x;
	} if(x > 9)write(x / 10);
	putchar((x % 10) + '0');
}
const int N = (1 << 17) + 10, INF = 1 << 30, M = 2e5 + 10, PP = 1e6;
int k, m, s, a[20], head[N], tot, n, dis[N], rem[N];
bool vis[N];
vector<int>vt[20], tmp;
priority_queue<pair<int, int> >q;
struct Edge {
	int to, nxt, w;
}e[M << 1];
void add(int u, int v, int w) {
	e[++tot].to = v;
	e[tot].w = w;
	e[tot].nxt = head[u];
	head[u] = tot;
}
int calc(int i, int j) {
	return __builtin_popcount(i ^ j);
}
bool update(int fr, int to, int w) {
	if(dis[to] > dis[fr] + w) {
		dis[to] = dis[fr] + w;
		q.push({-dis[to], to});
		return 1;
	} return 0;
}
void dijkstra() {
	while(!q.empty()) {
		int pos = q.top().second;
		q.pop();
		if(pos <= n) {
			if(vis[pos])continue;
			vis[pos] = 1;
			for(int i = head[pos]; i; i = e[i].nxt) {
				if(vis[e[i].to])continue;
				update(pos, e[i].to, e[i].w);
			}
			for(int i = 1; i <= k; i++)q.push({-dis[pos] - a[i], pos + i * PP});
		} else {
			pos = pos;
			int id = pos / PP, to;
			pos %= PP;
			if(id <= 2 || id >= k - 2) {
				if(id == k) {
					to = pos ^ (n - 1);
					if(update(pos, to, a[id])) {
						rem[to] = id;
						vt[id].push_back(to);
					}
				} else if(id == k - 1 || id == 1) {
					if(id == k - 1)to = pos ^ (n - 1);
					else to = pos;
					for(int i = 1; i <= k; i++) {
						to ^= (1 << (i - 1));
						if(update(pos, to, a[id])) {
							rem[to] = id;
							vt[id].push_back(to);
						}
						to ^= (1 << (i - 1));
					}
				} else if(id == k - 2 || id == 2){
					if(id == k - 2)to = pos ^ (n - 1);
					else to = pos;
					for(int i = 1; i <= k; i++) {
						to ^= (1 << (i - 1));
						for(int j = i + 1; j <= k; j++) {
							to ^= (1 << (j - 1));
							if(update(pos, to, a[id])) {
								rem[to] = id;
								vt[id].push_back(to);
							}
							to ^= (1 << (j - 1));
						}
						to ^= (1 << (i - 1));
					}
				}
			} else {
				for(int i = 1; i <= k; i++) {
					if(a[id] >= a[i])continue;
					for(int j = 0; j < vt[i].size(); j++) {
						int to = vt[i][j];
						if(rem[to] != i)continue;
						if(calc(pos, to) == id) {
							update(pos, to, a[id]);
							vt[id].push_back(to);
						} else tmp.push_back(to);
					}	
					swap(tmp, vt[i]);
					tmp.clear();
				}
			}
		}
	}
}
signed main() {
	//freopen("path.in", "r", stdin);
	//freopen("path.out", "w", stdout);
	k = read(), m = read(), s = read(), n = (1 << k);
	for(int i = 1; i <= k; i++)a[i] = read();
	for(int i = 0; i < n; i++)vt[calc(i, s)].push_back(i), dis[i] = a[calc(i, s)], rem[i] = calc(i, s), q.push({-dis[i], i});
	for(int i = 1; i <= m; i++) {
		int u = read(), v = read(), w = read();
		add(u, v, w), add(v, u, w);
	}
	dijkstra();
	for(int i = 0; i < n; i++) {
		write(dis[i]);
		putchar(' ');
	}
	return 0;
}
```

---

## 作者：Targanzqq (赞：1)

这题确实是好题。

我们记录状态 $(u,i,j)$ 表示某个点的后 $i$ 位修改了 $j$ 位走到 $u$ 的状态。我们不用管是那个点走过来的，因为只要能走过来的点可以更新这个点就没问题。

按照标准的 dijkstra 算法流程，我们从小根堆里面取出对顶，这时候堆顶的状态是 $(u,0,0)$。我们先按照原来图上的边转移，转移后再考虑更新**能更新到且还没更新的 $(v,i,j)$**。

因为我们从当前点到新点之间需要记录不同的 $1$ 数量，且转移在这个新图上是相同的，因此我们可以走到以后按照是否让这一位不一样走向 **未更新的** $(v,i+1,j)$ 和 **未更新的** $(v\oplus 2^i,i+1,j+1)$ 两个状态，直到 $i=k$ 的时候用 $a_j$ 更新 $dis_v$ 。我们考虑到新图上每条直接转移的边都用于 $bfs$，有权值的边会放到优先队列里面，而对于有权值的边，一部分是原来的，还有一部分是 $(v,k,j)$ 连过来的，这部分由 $v$ 和 $j$ 决定，因此共有 $m+k2^k$ 条，加上优先队列的 $\log n$ 即 $k$，时间复杂度 $O(mk+k^22^k)$。

源代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mp make_pair
#define fi first
#define se second
#define lb lower_bound
#define fr front()
#define pii pair<int,int>
#define INF 1145141919810
using namespace std;

int n,m,k,s,dis[200005],a[20];
int vis[200005][18][18];
vector<pii> t[200005];
struct node{
	int u,dis;
	friend bool operator<(node a,node b){
		return a.dis>b.dis;
	}
};
struct node2{
	int u,i,j;
};
priority_queue<node> q;
queue<node2> qx;

void dijkstra(){
	q.push({s,0});
	while(!q.empty()){
		int u=q.top().u;q.pop();
		if(vis[u][0][0])continue;
		for(auto i:t[u]){
			if(vis[i.fi][0][0])continue;
			if(dis[i.fi]>dis[u]+i.se){
				dis[i.fi]=dis[u]+i.se;
				q.push({i.fi,dis[i.fi]});
			}
		}
		qx.push({u,0,0});
		while(!qx.empty()){
			int now=qx.fr.u,i=qx.fr.i,j=qx.fr.j;qx.pop();
			//cout<<now<<"\n";
			vis[now][i][j]=1;
			if(i==k){
				if(dis[now]>dis[u]+a[j])
					dis[now]=dis[u]+a[j],q.push({now,dis[now]});
				continue;
			}
			if(!vis[now][i+1][j])qx.push({now,i+1,j});
			if(!vis[now^(1<<i)][i+1][j+1])qx.push({now^(1<<i),i+1,j+1});
		}
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin>>k>>m>>s;n=(1<<k)-1;
	for(int i=1;i<=k;i++)cin>>a[i];
	for(int i=1;i<=m;i++){
		int u,v,c;cin>>u>>v>>c;
		t[u].push_back(mp(v,c));
		t[v].push_back(mp(u,c));
	}
	for(int i=0;i<=n;i++)dis[i]=INF;
	dis[s]=0;
	dijkstra();
	for(int i=0;i<=n;i++)cout<<dis[i]<<" ";
}

---

## 作者：_Weslie_ (赞：0)

MX 盖世计划青岛 C 班 Day 11 T3 原题。

这次难度比上次下了一个台阶，变成了黄绿蓝紫。

## Solution P9377

### Idea

显然原图直接最短路就炸了。

考虑加点辅助。设 $(u,i,j)$ 表示前 $i$ 位修改了 $j$ 个，当前状态是 $u$。

那么考虑加边（注：下文中单个 $u$ 表示 $u$ 的原点，而 $(u,i,j)$ 为辅助点：

- 对于每条输入的边 $(u,v)$，连 $u$ 和 $v$ 之间的双向边，边权为 $w$。我们称为一类边。
- 从 $(u,i,j)$ 连到 $(u,i+1,j)$，边权为 $0$。我们称为二类边。
- 从 $(u,i,j)$ 连到 $(u\oplus 2^i,i+1,j+1)$，边权为 $0$。我们称为三类边。
- 从 $(u,k,j)$ 连到 $u$，边权为 $a_j$。我们称为四类边。

这样复杂度就是 $\operatorname{O}(nk^3)$ 的了，但是还是过不了。

考虑优化。

不难发现，复杂度瓶颈在优先队列的 $\log n$（就是 $k$）上，而四类边只有区区 $nk$ 条，如果把所有边都扔进优先队列，实在是太浪费了。

所以我们对边分治：

- 对于一类边，优先队列维护正常跑 dijstkra。
- 对于二三类边，由于它们边权是 $0$，所以扔进优先队列之后一定会最先被处理。所以直接开一个普通队列扔这些边，在处理到 $u$ 时，先把这些普通边都处理完了，再去处理一四类边。
- 对于四类边，也是丢进优先队列。

具体到代码实现上，就是在每一次 dijstkra 时新建一个队列，然后从 $(u,0,0)$ 开始 bfs，每次加边直接扔进去。如果遇到了 $(v,k,j)$ 的情况且 $dis_v>dis_u+a_j$，就把 $v$ 丢进优先队列里。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=131073;
#define ll long long
int n,m,k,s;
ll dis[N],a[N];
bool g[N][18][18],vis[N];
struct node{
	int pos;
	ll dis;
	friend bool operator <(node _,node __){
		return _.dis>__.dis;
	}
};
struct rrat{
	int u,i,j;
};
priority_queue<node>pq;
node make_node(int pos,ll dis){
	node nn;
	nn.pos=pos;
	nn.dis=dis;
	return nn;
}
rrat rrat176(int u,int i,int j){
	rrat cmwx; 
	cmwx.u=u;
	cmwx.i=i;
	cmwx.j=j;
	return cmwx;
}
struct edge{
	int u,v,nxt;
	ll w;
}e[N<<3];
int head[N],cnt;
void add(int u,int v,ll w) {
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int main(){
	scanf("%d%d%d",&k,&m,&s);;
	n=(1<<k);
	for(int i=1;i<=k;i++){
		scanf("%lld",&a[i]);
	} 
	ll w=0;
	for(int u,v;m;m--){
		scanf("%d%d%lld",&u,&v,&w);
		add(u,v,w);
		add(v,u,w);
	}
	memset(dis,0x3f,sizeof dis);
	dis[s]=0;
	pq.push(make_node(s,0));
	while(!pq.empty()){
		int u=pq.top().pos;
		pq.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u],v;i;i=e[i].nxt){
			v=e[i].v;
			ll d=e[i].w;
			if(dis[v]>dis[u]+d){
				dis[v]=dis[u]+d;
				if(!vis[v]){
					pq.push(make_node(v,dis[v]));
				}
			}
		}
		
		queue<rrat>q;
		q.emplace(rrat176(u,0,0));
		g[u][0][0]=1;
		while(!q.empty()){
			int v=q.front().u,i=q.front().i,j=q.front().j;
			q.pop();
			if(i==k&&dis[v]>dis[u]+a[j]){
				dis[v]=dis[u]+a[j];
				pq.push(make_node(v,dis[v]));
			}
			if(i<k){
				if(!g[v][i+1][j]){
					g[v][i+1][j]=1;
					q.push(rrat176(v,i+1,j));
				}
				if(!g[v^(1<<i)][i+1][j+1]){
					g[v^(1<<i)][i+1][j+1]=1;
					q.push(rrat176(v^(1<<i),i+1,j+1));
				}
			}
		}
	}
	for(int i=0;i<n;i++)printf("%lld ",dis[i]);
}
```

---


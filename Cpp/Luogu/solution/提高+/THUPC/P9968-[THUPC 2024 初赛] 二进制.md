# [THUPC 2024 初赛] 二进制

## 题目描述

今天也是喜欢二进制串的一天，小 F 开始玩二进制串的游戏。

小 F 给出了一个这里有一个长为 $n$ 的二进制串 $s$，下标从 $1$ 到 $n$，且 $\forall i\in[1,n],s_i\in \{0,1\}$，他想要删除若干二进制子串。

具体的，小 F 做出了 $n$ 次尝试。

在第 $i\in[1,n]$ 次尝试中，他会先写出正整数 $i$ 的二进制串表示 $t$（无前导零，左侧为高位，例如 $10$ 可以写为 $1010$）。

随后找到这个二进制表示 $t$ 在 $s$ 中从左到右 **第一次** 出现的位置，并删除这个串。

注意，删除后左右部分的串会拼接在一起 **形成一个新的串**，请注意新串下标的改变。

若当前 $t$ 不在 $s$ 中存在，则小 F 对串 $s$ 不作出改变。

你需要回答每一次尝试中，$t$ 在 $s$ 中第一次出现的位置的左端点以及 $t$ 在 $s$ 中出现了多少次。

定义两次出现不同当且仅当出现的位置的左端点不同。

请注意输入输出效率。

## 说明/提示

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
20
01001101101101110010
```

### 输出

```
2 11
5 5
4 5
11 1
4 2
7 1
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
-1 0
```

# 题解

## 作者：monstersqwq (赞：13)

### 标算

标算是 $O(n\log^2 n)$，考虑维护每一个数的所有出现位置，每次进行删除操作，把附近的 $O(\log n)$ 个被影响的 bit 重新计算，维护出现位置（支持插入删除查询最小值和集合大小）使用 set，由于删除次数不超过 $O(\frac{n}{\log n})$，总复杂度 $O(n\log^2 n)$。

### 能不能再给力一点啊？

我们实际不需要维护每一个数的出现位置，可以只维护当前长度的所有二进制数的出现位置，每次长度变化的时候重构整个串，由于长度变化仅有 $O(\log n)$ 次，每次只需要线性建 set 即可，删除的复杂度由于只维护了当前长度，变为 $O(n\log n)$。

### 你再想想？

以下为赛时做法。

设当前询问长度为 $k$。

可以把 set 直接换成 vector，只需要维护当前所有长度为 $k$ 的子串的值，每次查询时直接遍历整个 vector，由于每次插入只会被枚举一次，此时查询并删除的部分复杂度降至 $O(n)$。

### 能不能再给力一点啊？

建出 01trie，问题转化为叶子上插入删除，按照 bfs 序查询某个子树的 $mn,sz$。

设阈值 $B$，设 $T=\log n-k$。

当 $T>B$ 时，操作次数至多 $2^{\log n-B}$，使用任意的 $\log $ 数据结构维护上述操作，复杂度 $O(\frac{n\log^2n}{2^B})$。

当 $T\le B$ 时，使用上述的重构整串的方法，复杂度 $O(nB)$。

取 $B=c\log\log n$，总复杂度 $O(n\log\log n)$。

### 能不能再给力一点啊？

我并没有得到线性的做法，但若每次只需统计 $i$ 的出现次数，并给定一个 $i$ 的出现位置将其删除，可以做到与上述做法无关的 $O(n)$。

初始时，以层数为 $\frac{\log n}{2}$ 的所有节点作为关键点，维护每个叶子属于的关键点，以及每个关键点所属的 $k$ 层点，将贡献记录在叶子所属关键点以及关键点所属 $k$ 层点上。每次 $k$ 变化时重构第二类所属关系并重新维护子树大小，$k$ 超过 $\frac{\log n}{2}$ 时类似地重构关键点设置，而第一类所属关系可以位运算得出。

复杂度为 $O(\sum n^{\frac{2^k-1}{2^k}}\times \frac{1}{2^k}\log n)=O(n)$。

如果有整个题目线性的做法，教一下教一下教一下谢谢喵

---

## 作者：jr_linys (赞：10)

**[P9968 [THUPC 2024 初赛] 二进制](https://www.luogu.com.cn/problem/P9968)**

更新  
2023/12/23 时间复杂度不是 $O(n\log_2^2 n)$，是 $O(n\log_2 n)$。  
2024/2/24 更改了时间复杂度分析。
- - -

可见删除的长度为 $\log_2 x$，可以暴力删除。   
然后对于二进制位数相同的数字一起处理。

用可求排名、加入删除的数据结构，对于一个字符，维护：
- 初始不变的 字符 最初的标号
- 以这个字符为结尾在当前长度下的值

当然还要有查找，用可求极值、加入删除的数据结构找到该值可删除的最靠前的位置。

我赛时前者用了 `pb_ds` 的 `tree`，后者用 `set`，果不其然，寄了（甚至不做特殊处理还会 MLE）。
~~LOJ 上就能过，是机子太拉了。~~

常数主要问题在于一百万个 `set`，换成可删除堆就快得起飞。还要改的话可以把 `tree` 换成链表+树状数组。

算法流程：
- 对于不同位数的删除分组
- 初始遍历一遍字符，更新值，把位置扔堆里
- 删数时，把删掉的数从堆中删除。
- 然后还要更新后面长度个字符，记得先清除以前的在堆中的记录

之前的数的堆会乱，但不用管它（`set` 还会 MLE...）。  
对了，堆要开到 $2^{\lceil \log_2 N \rceil}$。

初次建 `tree`、每层进行重构都是 $O(n\log_2 n)$。总共会更改 $O(n)$ 次单个位置，每次更改 $O(\log_2 n)$。  
总时间复杂度 $O(n\log_2 n)$。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
const int N=1100000;
struct Ch{
	int id,c;//初始排名 字符
	mutable int s;//以该字符为结尾的值
	bool operator()(const Ch &a,const Ch &b)const{
		return a.id<b.id;
	}
};tree<Ch, null_type, Ch, rb_tree_tag, tree_order_statistics_node_update> t;//pb_ds 的 tree
struct del_queue{//可删除堆
	priority_queue<int,vector<int>,greater<int> > q,d;
	void push(int x){q.push(x);}
	void erase(int x){d.push(x);}
	int size(){return q.size()-d.size();}
	int top(){
		while(!d.empty()&&q.top()==d.top()) q.pop(),d.pop();
		return q.top();
	}
};
del_queue del[N];
int n;
string str;

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>str;
	for(int i=0;i<n;++i) t.insert({i,str[i]-'0',0});
	for(int lg=0;lg<=__lg(n);++lg){
		int S=(1<<(lg+1))-1,sum=0;
		for(auto &x:t)
			del[sum=x.s=((sum<<1)|x.c)&S].push(x.id);
		for(int i=1<<(lg),ed=i<<1;i<ed&&i<=n;++i)
			if(del[i].size()==0) cout<<"-1 0\n";
			else{
				int pm=t.order_of_key({del[i].top(),0,0});//查找该元素的排名，从0开始
				auto itr=++t.find_by_order(pm),itl=t.find_by_order(pm-lg);//查找该排名对应的元素迭代器，从0开始
				cout<<t.order_of_key(*itl)+1<<' '<<del[i].size()<<'\n';/////////
				for(;itl!=itr;itl=t.erase(itl)) del[itl->s].erase(itl->id);
				if(itr==t.begin()) sum=0;//继承前面的值
				else sum=(--itl)->s;
				for(int j=1;j<=lg&&itr!=t.end();++j,++itr)
					del[itr->s].erase(itr->id),//记得删掉以前的记录
					del[sum=itr->s=((sum<<1)|itr->c)&S].push(itr->id);
			}
	}
}
```

---

## 作者：一念之间、、 (赞：3)

来一份官方题解

## 题意简述

01串，顺序枚举数 i 然后作为二进制串，在原串中找到并删除，需要返回是否可行以及可行时出现次数。

$n\le 10^6$

## 题解

观察到当前过程形如你需要每次维护使得可以查找某些子串出现次数与位置，尝试观察询问，注意到查找子串的长度不会超过 $\log_2 (n)$. 

我们对于每个二进制数都维护这个数在原串中的出现位置，注意到当前形如只需要检查原串的长度为 $\log_2(n)$ 的子串. 

每次删除后我们需要重新检查删除这一段和前后 $\log_2(n)$ 个元素，每次检查加插入总复杂度为 $\log_2^3(n)$. 

注意到，执行删除操作的次数不会超过 $\frac n{\log_2(n)}$ 有总复杂度在 $n\log_2^2(n)$ 级别. 

由于常数极小，所以可以直接通过。

## 代码
```cpp
#include<bits/stdc++.h>
namespace ifzw{
#define ll long long 
#define dd double 
#define ull unsigned ll
#define LL __int128
#define siz(A) ((int)A.size())
using namespace std;
char gc(){static char buf[1<<16],*s,*t;if(s==t){t=(s=buf)+fread(buf,1,1<<16,stdin);if(s==t)return EOF;}return *s++;}
#define getchar gc
ll read()
{
	char c;
	ll w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	ll ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
void pc(char c,int op)
{
	static char buf[1<<16],*s=buf,*t=(buf+(1<<16));
	(op||((*s++=c)&&(s==t)))&&(fwrite(buf,1,s-buf,stdout),s=buf);
}
void wt(int x)
{
	if(x>9)wt(x/10);
	pc('0'+x%10,0);
}
void wts(int x,char op)
{
	if(x<0)pc('-',0),x=-x;
	wt(x),pc(op,0);
}
char ST;
//2e6 125357
//2^{17}=131072
// 0~16 。 
//980000 
//65345 
//哎，艹了 
const int xx=1e6+5;
int n,sum[xx],a[xx],b[xx],pos[xx];
int lb(int x){return x&-x;}
void add(int x,int y){for(;x<xx;x+=lb(x))sum[x]+=y;}
int ask(int x){int ans=0;for(;x;x-=lb(x))ans+=sum[x];return ans;}
int kth(int k)
{
	int S=0,id=0;
	for(int i=20;i>=0;i--)
		if(id+(1<<i)<xx&&S+sum[id+(1<<i)]<k)id+=(1<<i),S+=sum[id];
	assert(id+1<=n);
	return id+1;
}
const int D=19;
int ct;
struct st
{
	priority_queue<int,vector<int>,greater<int> >A,B;
	int size(){return siz(A)-siz(B);}
	void clear(){while(siz(A)&&siz(B)&&A.top()==B.top())A.pop(),B.pop();}
	int top()
	{
		assert(size()),clear();
		return A.top();
	}
	void ins(int x){++ct,A.push(x);}
	void era(int x){B.push(x);}
}s[(1<<(D+1))+10];
int len,now;
void get(int x,int op)
{
	if(b[x]==0)return;
	int cur=0;
	for(int i=0;i<=D;i++)
	{
		if(x+i<=len)
		{
			cur<<=1,cur|=b[x+i];
//			if(cur>165345)cerr<<cur<<"%\n";
//			assert(cur<=(1<<(D+1))+10);
			if(cur>=now)
			{
				if(op==1)s[cur].ins(pos[x]);
				else s[cur].era(pos[x]);
			}
		}
		else break;
	}
}
//下标应该存绝对下标。 
char ED;
int main(){
	cerr<<abs(&ST-&ED)/1024.0/1024<<"\n";
//	freopen("a.in","r",stdin);
//	freopen("binary.in","r",stdin);
//	freopen("binary.out","w",stdout);
	n=len=read();
	for(int i=1;i<=n;i++)
	{
		char c;
		while((c=getchar())!='0'&&c!='1');
		a[i]=c-'0';
	}
	for(int i=1;i<=n;i++)b[i]=a[i];
	for(int i=1;i<=n;i++)add(i,1),pos[i]=i;
	for(int i=1;i<=n;i++)get(i,1);
//	return 0;
//		if(i>(1<<(D+1)))
//		{
//			puts("-1 0");
//			continue;
//		}
	
	for(int i=1;i<=n;i++)
	{
		now=i;
		if(!siz(s[i]))
		{
			puts("-1 0");
			continue;
		}
		int A=ask(s[i].top()),tl=__lg(i)+1,L=max(1,A-D),R=min(A+tl-1+D,len);
		cout<<A<<" "<<siz(s[i])<<"\n";
		for(int j=L;j<=R;j++)pos[j]=kth(j),b[j]=a[pos[j]];
		for(int j=L;j<=A+tl-1;j++)get(j,-1);
		for(int j=A;j<=A+tl-1;j++)add(pos[j],-1);
		len-=tl;
		for(int j=A+tl;j<=R;j++)b[j-tl]=b[j];
		for(int j=L;j<A;j++)get(j,1);
//		if(i>65345)cerr<<len<<"$$\n"; 
//		if(i%10000==0)cerr<<ct<<"#\n";
	}
//	int res=0;
//	for(int i=1;i;i++)
//	{
//		res+=(__lg(i)+1);
//		if(res>980000)
//		{
//			cout<<i<<"#\n";
//			exit(0);
//		}
//	}
//	
	pc('1',1);
	return 0;
}


}signed main(){return ifzw::main();}
```


---

## 作者：hikariyo_ (赞：2)

首先，对于一个数字 $n$，它的二进制位数是 $\lfloor \log_2 n\rfloor + 1$，为了方便阅读，下文用 $\log n$ 代替。

我们每次删除的都是 $1\sim n$ 的二进制串，因此它的长度应该小于等于 $\log n$，所以我们对于原串 $s$ 的每位 $i$ 都向后 $\log n$ 个字符都扫描一遍，假设获得到的数字是 $v$，那么就添加一个 $v\to i$ 的映射关系。

删除的时候就在这个位置的前 $\log n$，后 $\log v$ 都更新一下。这样更新的原因是后 $\log v$ 个元素是被删除掉的，所以需要删掉对应的映射关系；前 $\log n$ 个向后关系有所改变，所以需要重新更新。

考虑如何处理坐标的变化，肯定是不能在映射里面修改的，这样复杂度太大了，所以用记录偏移量的方式，每次删除相当于在一个位置的后面的真实坐标都要减去 $\log v$，所以这里开一个树状数组就可以了。

然后考虑这个映射关系如何维护，由于 $v$ 于 $n$ 数量级相同，所以可以直接开数组，然后这个数组内需要一个支持动态 `add,delete,min,size` 的数据结构，所以用可删堆来实现，相较于 `std::set` 常数要小一些。

删除之后再次访问的时候需要跳过删除掉的地方，这个操作可以用链表实现。由于更新的时候需要向前走，所以是双链表。

复杂度分析：删除的时候每次更新 $O(\log n)$ 个元素，每次更新的复杂度是 $O(\log^2 n)$，所以删除的复杂度是 $O(\log^3 n)$。

但是一共只会执行 $O(\frac{n}{\log n})$ 次删除，所以最终的复杂度是 $O(n\log^2 n)$。

代码比较丑陋，轻喷/kel

```cpp
#include <bits/stdc++.h>
using namespace std;

#define lowbit(x) ((x)&(-x))
const int N = 1200010;

struct RemovableHeap {
    priority_queue<int, vector<int>, greater<int>> v, d;
    void remove(int x) {
        d.push(x);
    }

    int top() {
        while (d.size() && v.top() == d.top()) v.pop(), d.pop();
        return v.top();
    }

    void push(int x) {
        v.push(x);
    }

    int size() {
        return v.size() - d.size();
    }
} heap[N];

int n, a[N], lg2[N], nxt[N], pre[N], lg2n;

struct BIT {
    int tr[N];

    int query(int p) {
        int res = 0;
        for (; p; p -= lowbit(p)) res += tr[p];
        return res;
    }

    void add(int p, int k) {
        for (; p < N; p += lowbit(p)) tr[p] += k;
    }
} bit;

void update(int s, bool add = true) {
    if (a[s] == 0) return;

    for (int i = s, now = 0, cnt = 0; i && cnt < lg2n; i = nxt[i], cnt++) {
        now = now << 1 | a[i];
        if (add) heap[now].push(s);
        else heap[now].remove(s);
    }
}

void remove(int s, int bits) {
    int ne = s, raws = s;
    bit.add(s, -bits);
    for (int i = 0; i < bits; i++) {
        update(ne, false);
        ne = nxt[ne];
    }

    pre[ne] = pre[s];
    for (int i = 0; s && i < lg2n; i++) {
        s = pre[s];
        update(s, false);
    }
    s = raws;
    if (pre[s]) nxt[pre[s]] = ne;
    for (int i = 0; s && i < lg2n; i++) {
        s = pre[s];
        update(s);
    }
}

int main() {
    static char s[N];
    scanf("%d%s", &n, s+1);
    for (int i = 1; i <= n; i++) a[i] = s[i] ^ 48;
    // lg2[i] 表示 floor(log2(i)) + 1
    lg2[1] = 0;
    for (int i = 2; i <= n; i++) lg2[i] = lg2[i>>1] + 1;

    for (int i = 1; i <= n; i++) lg2[i]++, nxt[i] = i+1, pre[i] = i-1;
    nxt[n] = 0, lg2n = lg2[n];

    for (int i = 1; i <= n; i++) update(i);
    for (int i = 1; i <= n; i++) {
        if (heap[i].size() == 0) puts("-1 0");
        else {
            int p = heap[i].top(), sz = heap[i].size();
            printf("%d %d\n", p + bit.query(p), sz);
            remove(p, lg2[i]);
        }
    }

    return 0;
}
```


---

## 作者：Register_int (赞：2)

很好暴力题啊，十分甚至九分的好。

首先暴力把每个数的出现位置搞出来。要枚举的区间长度为 $O(\log n)$，之后插入 set 维护，时间复杂度 $O(n\log^2 n)$。要维护下标，用树状数组维护前面被删了几个，用链表维护相对位置即可。

然后考虑询问。我们分成三部分：

- 修改所有会被这个删除操作影响的区间，区间总数 $O(\log^2 n)$，复杂度 $O(\log^3 n)$。
- 删除区间并在树状数组上修改，时间复杂度 $O(\log^2 n)$。
- 处理两端合并后的区间的贡献，区间总数 $O(\log n)$，时间复杂度 $O(\log^2 n)$。

单次复杂度为 $O(\log^3 n)$。实际上，只有 $O\left(\dfrac{n}{\log n}\right)$ 个询问的答案不是 $-1$，所以复杂度为 $O(n\log^2 n)$。

那么实际上复杂度已经对了，但是交上去你会发现寄在很前面的点。本地测一下，1e6 会跑 12.3s，其中 10s 是由前面的预处理贡献的！

那么还是 set 的插入太慢了。加一个玄学优化：把 set 换成 vector，vector 的从后端插入常数是 set 的 0.1 倍，而且任意插入删除的时间与 set 差不多！并且，将 set 的元素均摊到每个位置上，set 的大小也会很小。此时，vector 全方位碾压 set，极限数据能卡到 1.8s。然后就能过了。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;

int n, c[MAXN]; char s[MAXN];

inline 
void add(int k) {
	for (int i = k; i <= n; i += i & -i) c[i]++;
}

inline 
int ask(int k) {
	int res = 0;
	for (int i = k; i; i &= i - 1) res += c[i];
	return res;
}

vector<int> p[MAXN]; bool del[MAXN];

int pre[MAXN], nxt[MAXN], cnt;

int main() {
	scanf("%d%s", &n, s + 1);
	for (int i = 0; i < n; i++) nxt[i] = i + 1;
	for (int i = 2; i <= n + 1; i++) pre[i] = i - 1;
	for (int i = 1; i <= n; i++) {
		if (s[i] == '0') continue;
		for (int j = i, x = 0; j <= n; j++) {
			x = x << 1 | (s[j] == '1');
			if (x > n) break; p[x].emplace_back(i);
		}
	}
	for (int i = 1; i <= n; i++) {
		if (p[i].empty()) { puts("-1 0"); continue; }
		int x = *p[i].begin(), len = __lg(i) + 1, h = x, t = x;
		printf("%d %u\n", x - ask(x), p[i].size());
		for (int j = 0; pre[h] && j <= 30; h = pre[h], j++);
		for (int j = 0; j < len; t = nxt[t], j++) del[t] = 1;
		for (int j = h, f; j != t; j = nxt[j]) {
			if (s[j] == '0') continue; f = 0;
			for (int k = j, x = 0; k; k = nxt[k]) {
				f |= del[k], x = x << 1 | (s[k] == '1');
				if (x > n) break; if (x > i && f) {
					auto it = lower_bound(p[x].begin(), p[x].end(), j);
					if (it != p[x].end() && *it == j) p[x].erase(it);
				}
			}
		}
		for (int j = x; j != t; j = nxt[j]) {
			add(j), nxt[pre[j]] = nxt[j], pre[nxt[j]] = pre[j];
		}
		if (del[h]) continue;
		for (int j = h; j != t; j = nxt[j]) {
			if (s[j] == '0') continue;
			for (int k = j, x = 0; k; k = nxt[k]) {
				x = x << 1 | (s[k] == '1');
				if (x > n) break; if (x > i) {
					auto it = lower_bound(p[x].begin(), p[x].end(), j);
					if (it == p[x].end() || *it != j) p[x].insert(it, j);
				}
			}
		} 
	}
}
```

---

## 作者：Gao_yc (赞：1)

# Solution：

发现每个左端点总共出现次数是 $\log n$。

考虑暴力处理每次尝试时，字符串出现的位置的数组，具体地，对于 $i$ 的答案数组，可以通过遍历 $\left \lfloor \frac{i}{2} \right \rfloor$ 的答案数组，找到下一位为 $i\bmod 2$ 的所有位置。

还有一个问题，就是每次找到后要把第一个串给删除。  
删除后会有 $\mathcal{O}(\log n)$ 个位置需要改变，也可以暴力重构。  
还有就是要注意处理，删除串后，新串下标的改变，可以通过一个简单的树状数组解决。

时间复杂度 $\mathcal{O}(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10;
int n,nxt[N],pre[N],lg[N],s[N];
char S[N];
int t[N];
bool de[N];
int lowbit(int x){return x&-x;}
void add(int x,int k){for(;x<=n;x+=lowbit(x)) t[x]+=k;}
int ask(int x){int res=0;for(;x;x-=lowbit(x)) res+=t[x];return res;}
vector<pair<int,int> > pos[N],tmp;
int a[N];
void print(int id){
    if(pos[id].empty()) {puts("-1 0");return;}
    int x,xx=pos[id][0].first;
    for(auto I:pos[id]) xx=min(xx,I.first);
    x=xx;
    printf("%d %d\n",ask(x),pos[id].size());
    int tot=0;
    for(int i=1,nx=pre[xx];i<lg[id]&&nx;++i,nx=pre[nx]) a[++tot]=nx;
    reverse(a+1,a+tot+1);
    for(int i=0,nx;i<lg[id];++i){
        nx=nxt[x];
        nxt[pre[x]]=nxt[x];pre[nxt[x]]=pre[x];
        pre[x]=nxt[x]=0;add(x,-1);de[x]=1;
        x=nx;
    }
    for(int i=1;i<lg[id]&&x;++i,x=nxt[x]) a[++tot]=x;
    int val=0;
    if(tot<lg[id]) return;
    for(int i=1;i<lg[id];++i) val=(val<<1)|s[a[i]];
    for(int i=1,j;i+lg[id]-1<=tot;++i){
        j=i+lg[id]-1;
        if(s[a[i]]) pos[val].emplace_back(a[i],a[j-1]);
        val=(val<<1)|s[a[j]];
        if(s[a[i]]) pos[val].emplace_back(a[i],a[j]);
        val&=((1<<(lg[id]-1))-1);
    }
}
bool vis[N];
int main(){
    scanf("%d%s",&n,S+1);
    for(int i=1;i<n;++i) nxt[i]=i+1,pre[i+1]=i;
    lg[0]=0;	
    for(int i=1;i<=n;++i){
        lg[i]=lg[i>>1]+1;s[i]=S[i]-'0';
        add(i,1);
        if(s[i]) pos[1].emplace_back(i,i);
    }print(1);
    for(int i=2;i<=n;++i){
        tmp.clear();swap(pos[i],tmp);
        for(auto I:tmp) if(!de[I.first]&&!de[I.second]&&(!vis[I.first])) pos[i].push_back(I),vis[I.first]=1;
        for(auto I:pos[i>>1])
            if(!de[I.first]&&nxt[I.second]&&s[nxt[I.second]]==(i&1)&&(!vis[I.first]))
                pos[i].emplace_back(I.first,nxt[I.second]),vis[I.first]=1;
        for(auto I:pos[i]) vis[I.first]=0;
        print(i);
    }
    return 0;
}

```


---

## 作者：Jsxts_ (赞：1)

发现所有询问串长度都是 $\log$ 级别的，考虑在每个位置预处理出从这个位置开始长为 $1\sim 20$ 的所有数，并用 set 存储每个数出现的所有位置。

删除可以用链表实现，具体地，删除 $[l,r]$ 一段之前先将 $[l-20,r+20]$ 拿出来将贡献消去，删完后再用上面区间剩下的字符来重新计算贡献。set 中维护的是每个数的原始位置，需要用树状数组计算出前缀被删的长度。

然后发现 set 跑的飞慢，但是发现只需要支持加删以及求最小值，换成可删除堆就过了。

赛时写了 2h。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1.2e6;
const int inf = 1e9;
const ll INF = 1e18;
int read() {
    int s = 0,f = 1;char ch = getchar();
    while (!isdigit(ch)) f = ch == '-'? -1 : 1, ch = getchar();
    while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();
    return s * f;
}
char s[N + 10];
struct ds {
    priority_queue<int,vector<int>,greater<int> > q1,q2;
    void push(int x) {
        q1.push(x);
    }
    void pop(int x) {
        q2.push(x);
    }
    int size() {
        return q1.size() - q2.size();
    }
    int top() {
        while (q2.size() && q1.top() == q2.top()) q1.pop(), q2.pop();
        return q1.top();
    }
}S[N + 10];
int c[N + 10],n;
void upd(int x,int s) {
    for (;x <= n;x += (x & -x)) c[x] += s;
}
int getsum(int x) {
    int res = 0;
    for (;x;x -= (x & -x)) res += c[x];
    return res;
}
int pre[N + 10],nxt[N + 10],pos[N + 10];
void del(int x) {
    pre[nxt[x]] = pre[x];
    nxt[pre[x]] = nxt[x];
}
int main() {
    n = read();
    scanf("%s",s + 1);
    pre[0] = -1;
    nxt[0] = 1;
    for (int i = 1;i <= n;i ++ ) nxt[i] = i + 1, pre[i] = i - 1;
    nxt[n] = -1;
    for (int i = 1;i <= n;i ++ ) {
        if (s[i] == '0') continue;
        int c = 0;
        for (int j = 1;j <= 20 && i + j - 1 <= n;j ++ ) {
            c = c * 2 + s[i + j - 1] - '0';
            if (c && c <= n) S[c].push(i);
        }
    }
    for (int i = 1;i <= n;i ++ ) {
        if (!S[i].size()) {
            puts("-1 0");
            continue;
        }
        int p = S[i].top(),ws = __lg(i),tp = p;
        printf("%d %d\n",p - getsum(p),S[i].size());
        string tt = "",ft = "";
        int ct = 0;
        for (int j = pre[p],k = 1;j && k <= 20;k ++ , j = pre[j]) ft += s[j], pos[ct++] = j;//, cout << "?" << j << endl;
        int st = pos[ct - 1],ed;
        reverse(pos,pos + ct);
        for (int j = p,k = 1;k <= ws + 20 && ~j;k ++, j = nxt[j]) tt += s[j], pos[ct++] = j;
        ed = pos[ct - 1];
        reverse(ft.begin(),ft.end());
        ft += tt;
        for (int j = 0;j < ft.size();j ++ ) {
            if (ft[j] == '0') continue;
            int c = 0;
            for (int k = 1;k <= 20 && j + k - 1 < ft.size();k ++ ) {
                c = c * 2 + ft[j + k - 1] - '0';
                if (c <= n && c > i) S[c].pop(pos[j]);
            }
        }
        upd(tp,ws + 1);
        int pr = pre[p];
        for (int j = 1;j <= ws + 1;j ++ ) del(nxt[pr]);
        ct = 0;
        if (!st) st = nxt[st];
        tt = "";
        for (int j = st;j != nxt[ed];j = nxt[j]) pos[ct++] = j, tt += s[j];
        for (int j = 0;j < tt.size();j ++ ) {
            int c = 0;
            if (tt[j] == '0') continue;
            for (int k = 1;k <= 20 && j + k - 1 < tt.size();k ++ ) {
                c = c * 2 + tt[j + k - 1] - '0';
                if (c > i && c <= n) S[c].push(pos[j]);
            }
        }
    }
    return 0;
}

```


---

## 作者：0xyz (赞：0)

比赛的时候 WBL 在做这道题，但是很可惜他最后也没调出来，总是在第 31 个点 TLE 或者 WA。我赛后自己做出，调了一个下午，在洛谷被卡常，又调了一下午。对于消去子串造成的下标的变化，我们可以对于每一次删去子串，都对一个后缀的下标集体减去删去的子串长度，这个可以用树状数组维护，在输出的时候查询即可。下面假设消去子串不会造成下标的变化。

我们考虑快速查询，由于查询的串 $\le 10^6$，所以可以开 $10^6$ 个 `set`，$a_i$ 记录串 $i$ 在 $s$ 中出现的所有开头的下标。

枚举目前串的长度 $i$，对于目前的 $s$ 的所有长度为 $i$ 的子串，记录 $v_j$ 代表开头的下标为 $j$ 的长度为 $i$ 的子串的值。每次枚举当前处理的子串的值 $h$，如果 $a_h$ 为空，$s$ 就没有子串 $h$，否则答案就是 $a_h$ 的最小数对应的真实下标以及 $a_h$ 的大小。

为了方便删除子串，我们可以用双向链表维护。在删除一个子串的时候，要在 $a$ 中删除其它包含这个子串中的元素的子串的贡献，然后在 $a$ 中加上删除这个子串后两边的元素拼成的子串的贡献。最后要更新链表的前后缀。

注意不需要将所有贡献扔进 $a$，只有恰好是 $i$ 位的贡献才要放进去，我的代码不这样的话会 TLE,RE,MLE。

查询失败的时间复杂度 $O(1)$，查询成功并消去子串的时间复杂度 $O(\log^2 n)$。由于消去子串最多 $O(\frac{n}{\log n})$，所以总时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。[代码](https://loj.ac/s/1961470)。

但是这样在洛谷上开 O2 之后也几乎没办法 AC，所以考虑卡常。

注意到每一个 `set` 只会查询一次。所以可以用 `vector` $a$ 和 $b$ 来处理，`insert` 塞进 $a$ 里，`erase` 塞进 $b$ 里，查询的时候先排序，然后遍历到的第一个在 $a$ 里不在 $b$ 里的数就是答案。时间复杂度虽然还是 $O(n\log n)$，但是常数远小于 `set`。[代码](https://loj.ac/s/1961568)。


---

## 作者：namelessgugugu (赞：0)

#### 题意

给定长度为 $n$ 的 01 字符串 $s$，进行 $n$ 次操作：

第 $i$ 次操作中，将 $i$ 的二进制表示写成无前导零的 01 字符串 $t_i$（高位在前），找到 $t_i$ 在当前的 $s$ 中所有作为子串出现的位置，选择最靠前的一个删掉，如果找不到这样的子串，则什么都不做。

对于每次操作，求出删去的 $t_i$ 的位置（若没有成功删去则输出 $-1$）以及操作前 $s$ 有几个子串等于 $t_i$。

$1 \leq n \leq 10^6$。

#### 题解

由于 $|t_i| \leq \log n$，只需要维护串的长度不超过 $\log n$ 的 $O(n \log n)$ 个子串，每次删除操作会分别增删 $O(\log^2 n)$ 个子串。

又注意到 $\sum\limits_{i=1}^k \log i = O(k \log k)$，故若进行了 $k$ 次删除操作，则 $k = O(\frac{n}{\log n})$，所以总共的子串变化数应该为 $O(n \log n)$。

如果暴力用数据结构维护这 $O(n \log n)$ 次子串的变化可以做到 $O(n \log^2 n)$，如果用的是比较快的数据结构已经可以通过，但实际上还可以更快。

注意到要求的只有对于每个 $t_i$ 求出其第一次出现的位置和出现次数。后者是好求的，只要开个变量记录数量即可，而前者的问题在于，即使现在出现了一个靠前的 $t_i$，也可能在之后被删掉，所以不太好直接维护最小值。

考虑用 `vector` 按时间顺序存下某个 $t_i$ 的每次出现 / 消失的位置，然后倒序遍历该 `vector`，记录一个桶 $b_j$ 表示在当前考虑的这段后缀中，以第 $j$ 个位置为开头的 $t_i$ 串被删去了几次，遍历到一次消失事件则令对应的 $b_j \gets b_j + 1$，出现事件则令 $b_j \gets b_j - 1$，如果某次操作后 $b_j < 0$，则说明 $j$ 这个位置上的 $t_i$ 串直到最后都没有被删除，于是可以将所有这样的 $j$ 取 $\min$ 得到 $t_i$ 第一次出现的位置。

注意清空桶的时候需要再遍历一遍 `vector` 而不是直接 `memset`。

这样做的复杂度为 $O(n \log n)$，去掉了数据结构带的 $\log$。

#### 代码

与上文表述有点不同的是代码里我把操作按 $|t_i|$ 分类，每次重构一下，不影响复杂度，`buc[j]` 实际上是 $-b_j$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#include <vector>
#include <array>
#define FILEIO(filename) (freopen(filename ".in", "r", stdin), freopen(filename ".out", "w", stdout))
typedef long long ll;
typedef unsigned long long ull;
using std::pair, std::vector, std::array;
const int N = (1 << 20) + 5;
int n;
char s[N];
int pre[N], nxt[N];
struct BiT
{
    int t[N];
    inline void update(int x, int v)
    {
        for (; x <= n;x += x & -x)
            t[x] += v;
        return;
    }
    inline int query(int x)
    {
        int res = 0;
        for (; x;x &= x - 1)
            res += t[x];
        return res;
    }
} Id;
vector<int> vec[N];
int rfir[N], rcnt[N];
int buc[N];
void erase(int x)
{
    pre[nxt[x]] = pre[x];
    nxt[pre[x]] = nxt[x];
    Id.update(x, -1);
    return;
}
void update(vector<int> self, vector<int> el, vector<int> er)
{
    int k = self.size() - 1;
    vector<int> pv[2], sv[2];
    sv[0].resize(el.size() + 1);
    for (int i = 0; i < (int)el.size();++i)
        sv[0][i + 1] = sv[0][i] | ((s[el[el.size() - i - 1]] - '0') << i);
    sv[1].resize(self.size() + 1);
    for (int i = 0; i < (int)self.size();++i)
        sv[1][i + 1] = sv[1][i] | ((s[self[self.size() - i - 1]] - '0') << i);
    pv[0].resize(self.size() + 1);
    for (int i = 0; i < (int)self.size();++i)
        pv[0][i + 1] = (pv[0][i] << 1) | (s[self[i]] - '0');
    pv[1].resize(er.size() + 1);
    for (int i = 0; i < (int)er.size();++i)
        pv[1][i + 1] = (pv[1][i] << 1) | (s[er[i]] - '0');
    for (int i = 1; i <= k;++i)
        if((int)el.size() >= i)
        {
            int v = (sv[0][i] << (k - i + 1)) | pv[0][k - i + 1];
            if(v >= (1 << k) && v <= n)
                vec[v].push_back(-el[el.size() - i]);
        }
    for (int i = 1; i <= k;++i)
        if((int)er.size() >= k - i + 1)
        {
            int v = (sv[1][i] << (k - i + 1)) | pv[1][k - i + 1];
            if(v >= (1 << k) && v <= n)
                vec[v].push_back(-self[self.size() - i]);
        }
    for (int i = 1; i <= k;++i)
        if((int)el.size() >= i && (int)er.size() >= k - i + 1)
        {
            int v = (sv[0][i] << (k - i + 1)) | pv[1][k - i + 1];
            if(v >= (1 << k) && v <= n)
                vec[v].push_back(el[el.size() - i]);
        }
    return;
}
void solve(void)
{
    memset(rfir, 0xff, sizeof(rfir));
    for (int i = 1; i <= n; ++i)
        Id.update(i, 1);
    nxt[0] = 1, pre[n + 1] = n;
    for (int i = 1; i <= n; ++i)
        pre[i] = i - 1, nxt[i] = i + 1;
    for (int k = 0; n >> k; ++k)
    {
        int len = Id.query(n);
        if(len <= k)
            return;
        int now = 0;
        int pt = 0;
        for (int i = 0; i < k; ++i)
            pt = nxt[pt], now = (now << 1) | (s[pt] - '0');
        for (int i = nxt[0];; i = nxt[i])
        {
            pt = nxt[pt];
            if (pt == n + 1)
                break;
            now = ((now << 1) | (s[pt] - '0')) & ((1 << (k + 1)) - 1);
            if (now >= (1 << k) && now <= n)
                vec[now].push_back(i);
        }
        for (int i = (1 << k); i <= std::min(n, (1 << (k + 1)) - 1); ++i)
        {
            std::reverse(vec[i].begin(), vec[i].end());
            int mn = n + 1, cnt = 0;
            for (int x : vec[i])
                if (x < 0)
                    --buc[-x], --cnt;
                else
                {
                    ++buc[x], ++cnt;
                    if (buc[x] > 0)
                        mn = std::min(mn, x);
                }
            for (int x : vec[i])
                if (x < 0)
                    ++buc[-x];
                else
                    --buc[x];
            if (mn == n + 1)
                continue;
            rfir[i] = Id.query(mn), rcnt[i] = cnt;
            vector<int> self, ext[2];
            self.reserve(k + 1);
            ext[0].reserve(k);
            ext[1].reserve(k);
            int mx = mn;
            self.push_back(mn);
            for (int j = 0; j < k; ++j)
                mx = nxt[mx], self.push_back(mx);
            for (int j = pre[mn]; (int)ext[0].size() < k && j != 0;j = pre[j])
                ext[0].push_back(j);
            std::reverse(ext[0].begin(), ext[0].end());
            for (int j = nxt[mx]; (int)ext[1].size() < k && j != n + 1;j = nxt[j])
                ext[1].push_back(j);
            update(self, ext[0], ext[1]);
            for(int x : self)
                erase(x);
        }
    }
    return;
}
int main(void)
{
    scanf("%d%s", &n, s + 1);
    solve();
    for (int i = 1; i <= n;++i)
        printf("%d %d\n", rfir[i], rcnt[i]);
    return 0;
}
```

---


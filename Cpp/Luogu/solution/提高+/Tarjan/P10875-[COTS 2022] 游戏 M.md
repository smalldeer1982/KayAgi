# [COTS 2022] 游戏 M

## 题目背景

译自 [Izborne Pripreme 2022 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2022/) D2T2。$\texttt{3s,0.5G}$。

## 题目描述


有一张 $N$ 个节点的无向图，依次向图中添加 $M$ 条边。

有 $Q$ 个询问，每次询问给定 $u,v$，问：至少添加前多少条边，才能使得 $u,v$ 间没有割边（换言之，割去任意一条边，都不影响 $u,v$ 的连通性）。特别地，如果 $u,v$ 始终不连通或者始终有割边，则输出 $-1$。


## 说明/提示


对于 $100\%$ 的数据，保证：

- $2\le N \le 3\times 10^5$，$0\le M\le 3\times 10^5$，$1\le Q\le 3\times 10^5$；
- $s_i\neq t_i$，$u\neq v$；
- $1\le u,v,s_i,t_i\le N$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $10$  | $Q=1$  |
| $2$  | $20$  | $2\mid M$，$(s_{2i-1},t_{2i-1})=(s_{2i},t_{2i})$  |
| $3$  | $30$  | $N,M\le 5\, 000$ |
| $4$  | $40$  | 无额外约束 |

## 样例 #1

### 输入

```
3 3
1 2
2 3
3 1
1
1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 4
1 2
1 2
2 3
2 3
3
1 2
2 3
3 1```

### 输出

```
2
4
4```

## 样例 #3

### 输入

```
6 7
1 2
2 3
3 4
2 5
3 5
4 5
1 3
5
1 3
2 3
4 5
1 4
2 6```

### 输出

```
7
5
6
7
-1```

# 题解

## 作者：_Yonder_ (赞：6)

这题翻译有点问题，实际上有多张图。

给出一种无脑做法。

显然环绝对没有割边，所以求出生成树后连剩余边找环。判断当前答案是否合法就是判断是否都在一个环上。

看到这你还想不到啥吗，是的，分块下这题就没了。大概是离线然后逐块处理，维护上述操作，确定答案所在块后再精确位置。

时间复杂度 $O(m\sqrt m)$。

---

## 作者：Reunite (赞：4)

题解区都是很厉害的做法，但是我太菜了。

考虑直接用并查集维护边双，先拉出一棵 MST 出来，然后把树边全扬了，接下来就是一些非树边，我们考虑用这些边去做链覆盖，显然地，如果两个点之间每一条边都被覆盖了，那此时一定在一个点双内。用并查集维护一下就没了。

但是我们还要查询，直接把询问 $(u,v)$ 挂在 $u,v$ 两个点上，同时开一个 vector 存一个边双里面所有的询问，每次上面做一次有效覆盖的时候，就相当于连通两个边双，启发式合并同时处理跨这两个边双的询问即可，正确性显然。

因为每个询问最多被启发式合并 $\log n$ 次，所以复杂度 $O(q\log q)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

int n,m,q,tm;
int uu[300005];
int vv[300005];
int ff[300005];
int fa[300005];
bool mp[300005];
int dfn[300005];
int out[300005];
int ans[300005];
vector <int> e[300005];
struct node{int u,v,id;};
vector <node> g[300005];

inline int Find(int x){return fa[x]==x?x:fa[x]=Find(fa[x]);}

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void dfs(int u,int f){
	ff[u]=f;
	dfn[u]=++tm;
	for(int v:e[u]) if(v^f) dfs(v,u);
	out[u]=tm;
	return ;
}

inline void merge(int u,int v,int k){
	if(g[v].size()<g[u].size()) swap(g[u],g[v]);
	for(auto tmp:g[u]){
		int uu=Find(tmp.u),vv=Find(tmp.v);
		if((uu==u&&vv==v)||(uu==v&&vv==u)) ans[tmp.id]=k;
		else g[v].emplace_back(tmp);
	}
	return ;
}

inline void Cover(int u,int v,int k){
	int l=min(dfn[u],dfn[v]),r=max(out[u],out[v]);
	int pos=Find(u);
	while(dfn[pos]>l||out[pos]<r){
		merge(pos,Find(ff[pos]),k);
		fa[pos]=Find(ff[pos]);
		pos=Find(ff[pos]);
	}
	pos=Find(v);
	while(dfn[pos]>l||out[pos]<r){
		merge(pos,Find(ff[pos]),k);
		fa[pos]=Find(ff[pos]);
		pos=Find(ff[pos]);
	}
	return ;
}

int main(){
	in(n),in(m);
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++) in(uu[i]),in(vv[i]);
	for(int i=1;i<=m;i++){
		int u=Find(uu[i]),v=Find(vv[i]);
		if(u==v) mp[i]=1;
		else{
			e[uu[i]].emplace_back(vv[i]);
			e[vv[i]].emplace_back(uu[i]);
			fa[u]=v;
		}
	}
	for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i,0);
	in(q);
	for(int i=1;i<=q;i++){
		ans[i]=-1;
		int u,v;
		in(u),in(v);
		g[u].push_back({u,v,i});
		g[v].push_back({u,v,i});
	}
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		if(!mp[i]) continue;
		Cover(uu[i],vv[i],i);
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);

	return 0;
}
```

---

## 作者：MadokaKaname (赞：4)

## 鲜花

圆从军训中逃了出来，并写了这个题（

但是圆很笨，不会 LCT，于是圆就开始乱搞了（

## Solution

要求最早时刻使得两个点在同一个边双内，看起来就很像瓶颈路。

于是先建出重构树，考虑其他边加进去之后什么时候某一块形成边双，发现**实际上每次都是在暴力合并一条树上的链，并将链上所有的点合并到 lca 的位置。**

由于一个点最多被并进去一次，所以跳链直接暴力。

于是只需要维护深度，随便使用线段树维护即可 $O(n \log n)$。

考虑查询怎么做。

在合并的时候从 lca 往所有被合并的点连边，边权为本次操作的编号，这样可以保证在最后查询的时候答案就是这一条路径上的边权最大值。

时间复杂度 $O(n \log n)$。

[code](https://www.luogu.com.cn/paste/bgx8ogo4)

---

## 作者：Eltaos_xingyu (赞：1)

看到这个题，求的是至少加多少边使得这两个询问到的点在一个边双里面。有一股很大的整体二分味儿啊！

所以直接整体二分，现在考虑如何维护边双。我们首先扫一遍边集，忽视掉会产生环的边来建树。不难发现如果现在有一条边连到树上产生了环，我们就把这个环上的点全部缩成一个点，代表这些点在一个边双里面。因为一个点只会被缩一次，所以我们可以暴力跳父亲去缩。

一种比较简易的实现是把路径上的所有点的父亲全部更新为一个虚点，然后用并查集维护边双。我们最后只需要更新虚点的父亲为路径 LCA 处的父亲。不过这种写法的常数比较大。

这样复杂度乍一看是 $O(m\log^2 m)$ 的（把并查集复杂度视作 $O(1)$），但是实际上我们可以预处理 LCA，然后整体二分的时候用 `vector` 储存信息，这样复杂度就是 $O(m\log m)$ 的了。

但是实测 `vector` 跑不过每一层 `sort` 一遍询问。

AC 记录给的是每层 `sort` 版本的。

[AC 记录](https://www.luogu.com.cn/record/187053892)

---

## 作者：xiezheyuan (赞：1)

## 简要题意

有一个 $n$ 个点的无向图，初始时都是散点。有 $m$ 条边，在第 $i$ 个时刻加入第 $i$ 条边。

有 $q$ 次询问，每次询问给出 $u,v$，询问最早在第几个时刻末，$u,v$ 位于同一个边双连通分量中，或指出不存在这样的时刻。

$2\leq n\leq 3\times10^5,0\leq m\leq 3\times10^5,1\leq q\leq 3\times10^5$

## 思路

首先考虑我们维护一个原图的某一个生成树（准确来说应该是生成森林），然后依次考虑每一条边：

- 如果这条边是树边，那么直接连接。
- 如果这条边是非树边（返祖边或横叉边） $(u,v)$，则此处构成了一个环。考虑生成树上的路径 $(u,v)$，每条边记录一个时间戳表示这条边最早位于一个环（即边双连通分量）内的时刻，则相当于对这条路径上所有没有时间戳的边加上一个时间戳。

最后回答询问的时候，我们只需要先判断 $u,v$ 是否连通或生成树上路径 $(u,v)$ 存在没有时间戳的边，然后求出路径上每条边的时间戳最大值。

考虑我们选用怎样的 DS 去维护这个信息。不难发现可以用重链剖分，考虑修改，我们相当于对一段区间所有 $\geq x$ 的元素推平为 $x$（假设没有时间戳的边，钦定一个时间戳 $+\infty$）。这是难以维护的，不过发现我们的 $x$ 是递增的，所以可以写一个暴力线段树的做法，在线段树上 dfs，如果遇到的节点代指的区间内都 $\lt x$，那么不必向下搜索，否则继续向下搜索。

容易发现这样的时间复杂度均摊是 $O(\log n)$ 的，可以接受。

整体时间复杂度 $O((m+q)\log^2 n)$ 可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
#define ls (i << 1)
#define rs (i << 1 | 1)
#define mid ((l + r) >> 1)
using namespace std;

const int N = 3e5 + 5;
int n, m, q, fa[N];
vector<int> g[N];
struct edge{ int u, v; } e[N];

int find(int x){ return fa[x] == x ? x : fa[x] = find(fa[x]); }
void merge(int x, int y){ fa[find(x)] = find(y); }

int dep[N], father[N], top[N], son[N], seg[N];

int dfs1(int u, int fa){
    int siz = 1, sonsiz = 0;
    dep[u] = dep[fa] + 1;
    father[u] = fa;
    for(auto v : g[u]){
        if(v == fa) continue;
        int vsiz = dfs1(v, u);
        siz += vsiz;
        if(vsiz > sonsiz) son[u] = v, sonsiz = vsiz;
    }
    return siz;
}

void dfs2(int u, int fa){
    if(son[u]){
        top[son[u]] = top[u];
        seg[son[u]] = ++seg[0];
        dfs2(son[u], u);
    }
    for(auto v : g[u]){
        if(v == fa || v == son[u]) continue;
        top[v] = v;
        seg[v] = ++seg[0];
        dfs2(v, u);
    }
}

int maxt[N << 2];

void build(int i, int l, int r){
    maxt[i] = INT_MAX;
    if(l == r) return;
    build(ls, l, mid);
    build(rs, mid + 1, r);
    maxt[i] = max(maxt[ls], maxt[rs]);
}

void update(int ql, int qr, int v, int i, int l, int r){
    if(ql > qr) return;
    if(maxt[i] < v) return;
    if(l == r){
        maxt[i] = v;
        return;
    }
    if(ql <= mid) update(ql, qr, v, ls, l, mid);
    if(qr > mid) update(ql, qr, v, rs, mid + 1, r);
    maxt[i] = max(maxt[ls], maxt[rs]);
}

int qmax(int ql, int qr, int i, int l, int r){
    if(ql > qr) return INT_MIN;
    if(ql <= l && r <= qr) return maxt[i];
    int res = INT_MIN;
    if(ql <= mid) res = max(res, qmax(ql, qr, ls, l, mid));
    if(qr > mid) res = max(res, qmax(ql, qr, rs, mid + 1, r));
    return res;
}

void UpdatePath(int x,int y,int v){
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		update(seg[top[x]], seg[x], v, 1, 1, seg[0]);
		x=father[top[x]];
	}
	if(dep[x] > dep[y]) swap(x,y);
	update(seg[x] + 1, seg[y], v, 1, 1, seg[0]);
}

int QueryMax(int x,int y){
    int ans = INT_MIN;
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		ans = max(qmax(seg[top[x]], seg[x], 1, 1, seg[0]), ans);
		x = father[top[x]];
	}
	if(dep[x] > dep[y]) swap(x, y);
	ans = max(ans, qmax(seg[x] + 1, seg[y], 1, 1, seg[0]));
	return ans;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    iota(fa + 1, fa + n + 1, 1);
    for(int i=1;i<=m;i++){
        cin >> e[i].u >> e[i].v;
        if(find(e[i].u) == find(e[i].v)) continue;
        merge(e[i].u, e[i].v);
        g[e[i].u].push_back(e[i].v);
        g[e[i].v].push_back(e[i].u);
    }
    for(int i=1;i<=n;i++){
        if(!dep[i]){
            seg[i] = ++seg[0];
            top[i] = i;
            dfs1(i, 0);
            dfs2(i, 0);
        }
    }
    build(1, 1, seg[0]);
    iota(fa + 1, fa + n + 1, 1);
    for(int i=1;i<=m;i++){
        int u = e[i].u, v = e[i].v;
        if(find(u) != find(v)) merge(u, v);
        else UpdatePath(u, v, i);
    }
    cin >> q;
    while(q--){
        int x, y;
        cin >> x >> y;
        if(find(x) != find(y)){
            cout << -1 << '\n';
            continue;
        }
        int ret = QueryMax(x, y);
        cout << (ret > m ? -1 : ret) << '\n';
    }
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：xzy_AK_IOI (赞：0)

### 思路分析
似乎这题并没有用到 tarjan。

拿到这题，第一眼看肯定是边双，于是想着去用 tarjan 维护，可这题是动态加边，很明显 tarjan 无法维护。再想一下，考虑怎样两点之间才能没有割边。

发现我们可以维护这样一张动态图，初始所有点之间都没有边，每加一条边，若边的两端点已经联通，便将两点路径上所有边打个标记。若两端点没有联通，则将它们之间连一条边。

那怎么判断两点之间有无割边呢？其实很简单，若两点联通且路径中所有边都被打过标记，那么无割边，否则一定有割边。

正确性显然，可以通过画图得到结论。

在考虑这张动态图如何维护，可以用 LCT，但太复杂了，~这是蓝题~，提供一种树剖的方法。

将所有边读入后先建好树，具体来说只要将不连通的两点连边即可。再次遍历边打标记，这里记得重置判联通用的并查集，具体方法上面有。

再次回到本题，本题有多个询问，显然不能每个询问都重新建树，考虑在打标记上优化，我们将一条边的标记定义为后来加入的边第一次覆盖这条边的时刻，这样就很好做了。可以发现，两点之间第一次没有割边的时刻就是这两点之间路径上标记的最大值，显然这是对的。然后就可以写代码了。

代码具体来说维护两颗线段树，第一颗线段树维护标记的最小值，第二颗线段树在标记打完后重新建树维护最大值，当然这里也可以用 ST 表。注意到第一颗线段树可以使用标记持久化，因为只有单点查询。

时间复杂度 $O(n\log^2 n)$。
### 完整代码

附注释

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db long double
#define F(i,k,n) for (int i=k;i<=n;i++)
#define R(i,k,n) for (int i=k;i>=n;i--)
#define mpr make_pair
#define pu push_back
inline int ls(int x){return x<<1;}
inline int rs(int x){return x<<1|1;} 
inline int read(){
	int x=0;
	bool flag=1;
	char c=getchar_unlocked();
	while(c<'0'||c>'9'){
		if(c=='-')
			flag=0;
		c=getchar_unlocked();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar_unlocked();
	}
	return (flag?x:~(x-1));
}//快读
const int N=3e5+10;
const int inf=1e9;
struct segtree{
	int l,r,num;
}tr[N<<3];
struct segtree2{
	int l,r,num;
}tr2[N<<3];
vector<int>T[N];
int p[N];
int top[N],son[N],sz[N],dfn[N],fa[N],dep[N],rdfn[N];
bool isroot[N];
int w[N];
int n,m,a[N],b[N],tot,q,l,r;
inline int find(int x){
	return p[x]==x?x:p[x]=find(p[x]);//并查集
}
inline void build(int l,int r,int p){
	tr[p].l=l;tr[p].r=r;tr[p].num=inf;
	if (l==r) return;
	int mid=(l+r)>>1;
	build(l,mid,ls(p));//第一颗线段树
	build(mid+1,r,rs(p));
}
inline void build2(int l,int r,int p){
	tr2[p].l=l;tr2[p].r=r;
	if (l==r){
		if (isroot[rdfn[l]]) tr2[p].num=0;
		else tr2[p].num=w[l];
		return;
	}
	int mid=(l+r)>>1;
	build2(l,mid,ls(p));
	build2(mid+1,r,rs(p));
	tr2[p].num=max(tr2[ls(p)].num,tr2[rs(p)].num);//第二颗线段树
}
inline void update(int l,int r,int p,int d){
	if (l<=tr[p].l && tr[p].r<=r){
		tr[p].num=min(tr[p].num,d);
		return;
	}
	int mid=(tr[p].l+tr[p].r)>>1;
	if (l<=mid) update(l,r,ls(p),d);
	if (mid+1<=r) update(l,r,rs(p),d);//区间修改+标记持久化
}
inline int query(int pos,int p){
	if (tr[p].l==tr[p].r) return tr[p].num;
	int mid=(tr[p].l+tr[p].r)>>1,ans=tr[p].num;
	if (pos<=mid) ans=min(ans,query(pos,ls(p)));
	else ans=min(ans,query(pos,rs(p)));
	return ans;//用于询问每条边最后的标记值
}
inline int query2(int l,int r,int p){
	if (l<=tr2[p].l && tr2[p].r<=r) return tr2[p].num;
	int mid=(tr2[p].l+tr2[p].r)>>1,ans=-inf;
	if (l<=mid) ans=max(ans,query2(l,r,ls(p)));
	if (mid+1<=r) ans=max(ans,query2(l,r,rs(p)));
	return ans;
}
inline void dfs1(int u){
	sz[u]=1;
	dep[u]=dep[fa[u]]+1;
	F(i,0,(int)T[u].size()-1){
		int v=T[u][i];
		if (v==fa[u]) continue;
		fa[v]=u;
		dfs1(v);
		if (sz[v]>sz[son[u]]) son[u]=v;
		sz[u]+=sz[v]; 
	}
}
inline void dfs2(int u,int h){
	top[u]=h;
	tot++;
	dfn[u]=tot;
	rdfn[tot]=u;
	if (son[u]) dfs2(son[u],h);
	F(i,0,(int)T[u].size()-1){
		int v=T[u][i];
		if (v==fa[u] || v==son[u]) continue;
		dfs2(v,v);
	}
}//以上为树剖初始化
inline void updatepath(int x,int y,int d){
	while (top[x]!=top[y]){
		if (dep[top[x]]>dep[top[y]]) swap(x,y);
		update(dfn[top[y]],dfn[y],1,d);
		y=fa[top[y]];
	}
	if (dep[x]>dep[y]) swap(x,y);
	if (x!=y) update(dfn[son[x]],dfn[y],1,d);
}//更改路径中所有边的标记
inline int querypath(int x,int y){
	int ans=-inf;
	while (top[x]!=top[y]){
		if (dep[top[x]]>dep[top[y]]) swap(x,y);
		ans=max(ans,query2(dfn[top[y]],dfn[y],1));
		y=fa[top[y]];
	}
	if (dep[x]>dep[y]) swap(x,y);
	if (x!=y) ans=max(ans,query2(dfn[son[x]],dfn[y],1));
	return ans;
}//查询路径中所有边的标记的最大值
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
    n=read();
    m=read();
	F(i,1,n) p[i]=i;//并查集初始化
	build(1,n,1);
	F(i,1,m){
	    a[i]=read();b[i]=read();
		if (find(a[i])==find(b[i])) continue;
		p[find(a[i])]=find(b[i]);
		T[a[i]].pu(b[i]);
		T[b[i]].pu(a[i]);
	}//先建好树
	F(i,1,n) p[i]=i;//并查集初始化
	F(i,1,n){
		if (dfn[i]) continue;
		isroot[i]=1;
		dfs1(i);
		dfs2(i,i);//注意原图不一定联通
	}
	F(i,1,m){
		if (find(a[i])==find(b[i])) updatepath(a[i],b[i],i);//修改
		else p[find(a[i])]=find(b[i]);
	}
	F(i,1,n){
		w[i]=query(i,1);
	}
	build2(1,n,1);//将修改后每条边的标记值拎出来并用于第二颗线段树建树
	q=read();
	while (q--){
    	l=read();
        r=read();
		if (find(l)!=find(r)){
			cout<<-1<<'\n';
			continue;//特判不连通
		}
		int ans=querypath(l,r);//查询
		if (ans>m) cout<<-1<<'\n';
		else cout<<ans<<'\n';
	}
	return 0;
}
```


[AC 记录](https://www.luogu.com.cn/record/230538120)

---

## 作者：Unnamed114514 (赞：0)

超牛 3log 做法，荣获效率垫底。

先以每条边是第几个出现拉出 MST。

然后考虑每条非树边。

容易发现每条非树边可以将 MST 对应链上的搞到同一个边双里面，也就是一个链上点合并的过程。

但是这个时候仍然不是很好搞，于是考虑把点的问题转化为边的问题。

然后你会发现，这个点的合并就等价于把路径上所有边覆盖，然后查询就等价于路径上所有边是否被覆盖。

这个问题显然可以直接维护区间最小值，树剖 $O(n\log^2n)$ 处理即可。

每次查询的话，发现满足可二分性，如果直接二分+可持久化的话，时空都是 $O(n\log^2n)$ 的，但是空间过不去，所以考虑整体二分，时间 $O(n\log^3n)$，空间 $O(n)$。

你会发现操作都是先推后撤销，所以标记永久化之后如果 $tag>0$ 就一定可以，加上这个剪枝就过了。

---

## 作者：北文 (赞：0)

这是一道比较综合的题目。   
我们需要求出每一对 $u,v$ 第一次成为**边双**的时刻。如果你学过 LCT，你会知道 LCT 可以动态维护边双连通分量。  
具体的，动态加边，维护当前的树。若当前加入的边与原来的树形成了环，那么这个环上的边都不会是割边，只需将该环暴力全部缩成一个点即可，这个操作可以用并查集维护。   
我们从头到尾扫一遍，一个显然的想法是，当合并两个连通块统计该连通块合并时新增的点双的答案。我们可以将一个询问 $u,v$ 分别挂在 $u$ 点上，然后合并 $x,y$ 的时候，查询 $x$ 的询问集合中，有哪些询问在 $y$ 集合中，这些询问最早在当前时刻成为点双，若未满足，则挂到合并后的新点上。  
但是这样子，时间复杂度就没有保障。合并两个集合，若想要正确的时间复杂度，很自然的想到**启发式合并**，我们需要将元素个数较少的集合合并到元素个数较大的集合上。  
所以，我们将询问 $u,v$ 分别在 $u$ 和 $v$ 上各挂一个，这样子合并的时候，能保证每个询问都被访问。  
并查集的路径压缩，和启发式合并就比较套路了。  

代码是粘贴了P2542 [AHOI2005] 航线规划的 LCT，比较丑陋，这里就不放了。

---


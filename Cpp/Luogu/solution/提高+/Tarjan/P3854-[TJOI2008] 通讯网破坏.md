# [TJOI2008] 通讯网破坏

## 题目背景

由于争夺资源引起的矛盾冲突，$A$ 国和 $B$ 国进入了战争一触即发的状态。现在 $A$ 国的间谍机构设法得到了 $B$ 国的通讯网络布置情况，其中每个城市可以看作一个点，在某些点之间有无向边，表示这些城市之间可以进行双向的直接通讯。$A$ 国打算先发制人，通过核武器毁灭某个中间城市 $M$，一举切断B国某两个重要城市 $S$ , $T$ 之间的联系，即从图中删除掉 $M$ 点之后，$S$ 和 $T$ 变得不连通。但是由于 $B$ 国的防御力量也很强大，这样的核打击只能成功进行一次且只能毁灭一个城市。


## 题目描述

现在 $A$ 国的首脑提出了很多种作战策略，作为 $A$ 国的首席计算机科学家，你的任务是编写一个程序决定这些策略可行与否。


## 说明/提示

对于 $30\%$ 的数据，$1 \leq N \leq 100,1 \leq Q \leq 100$。

对于 $100\%$ 的数据，$1 \leq N \leq 20000,1\leq M\leq 100000,1 \leq Q \leq 100000$。

输入数据保证原图的任意两点是连通的。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
3 4
3 5
4 5
3
1 5 3
1 5 4
4 5 3
```

### 输出

```
yes
no
no
```

# 题解

## 作者：llxsmy_forever (赞：11)

看到题解大多是用圆方树做的，~~圆方树是什么~~，于是蒟蒻来发一篇用点双的题解。

## 题目描述
给定一张无向连通图，多组询问，每组询问给出点 $X,Y,D$ ，在删除点 $D$ 之后，判断点 $X,Y$ 是否连通。

## Solution
对于每组询问，我们分情况讨论。

$\bullet$ 如果 $D$ 点不是割点，那么去掉这个点后这张图显然还是联通的，$X$ 和 $Y$ 当然也是联通的，输出 no。

$\bullet$ 如果点 $X$ 和 $Y$ 处于同一个点双之内，那么不管删除哪一个点， $X$ 和 $Y$ 显然还是联通的，输出 no。

$\bullet$ 最后一种情况，就是 $X$ 和 $Y$ 不在同一个点双之内并且 $D$ 点是割点，这时我们先缩点，此时这张图变成一棵树，设 $tx$ 为 $X$ 所在的点双，$ty$ 为 $Y$ 所在的点双，我们只需判断 $D$ 点是否在 $tx$ 到 $ty$ 的路径上就可以了，在则输出 yes，否则输出 no。

如何判断树上的一个点 $D$ 是否在另两个点 $X$ 和 $Y$ 的路径上呢，我们只需要判断 $dist(X,D)$ 加上 $dist(Y,D)$ 是否等于 $dist(X,Y)$ 就可以了。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+100,M=1e5+100;
struct edge{int y,pre;}a[M<<1];int alen,last[N];
void ins(int x,int y){alen++;a[alen]={y,last[x]};last[x]=alen;}
int dfn[N],low[N],id,dcc;
int sta[N],top,vis[N],New[N],c[N];
vector<int> q[N];
void tarjan(int x){
	dfn[x]=low[x]=++id;
	sta[++top]=x;
	int cnt=0;
	for(int k=last[x];k;k=a[k].pre){
		int y=a[k].y;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
			if(dfn[x]<=low[y]){
				cnt++;
				if(x>1||cnt>1)vis[x]=1;
				int tmp;dcc++;
				do{
					tmp=sta[top--];
					q[dcc].push_back(tmp);
				}while(tmp!=y);
				q[dcc].push_back(x);
			}
		}
		else low[x]=min(low[x],dfn[y]);
	}
}
int dep[N],par[N][21];
void prepare(int x,int fa){
	dep[x]=dep[fa]+1;par[x][0]=fa;
	for(int i=1;i<=19;i++)par[x][i]=par[par[x][i-1]][i-1];
	for(int k=last[x];k;k=a[k].pre){
		int y=a[k].y;
		if(y!=fa)prepare(y,x);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=19;i>=0;i--){
		if(dep[par[x][i]]>=dep[y])x=par[x][i];
	}
	if(x==y)return y;
	for(int i=19;i>=0;i--){
		if(par[x][i]!=par[y][i]){
			x=par[x][i],y=par[y][i];
		}
	}
	return par[x][0];
}
int dist(int x,int y,int lca){
	return dep[x]+dep[y]-dep[lca]*2;
}
int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;scanf("%d%d",&x,&y);
		ins(x,y);ins(y,x);
	}
	tarjan(1);
	int sum=dcc;
	for(int i=1;i<=n;i++){
		if(vis[i])New[i]=++sum;
	}
	alen=0;memset(last,0,sizeof(last));
	for(int i=1;i<=dcc;i++){
		for(int j=0;j<q[i].size();j++){
			int x=q[i][j];
			if(vis[x])ins(New[x],i),ins(i,New[x]);
			else c[x]=i;
		}
	}
	prepare(1,0);
	int q;scanf("%d",&q);
	while(q--){
		int x,y,d;scanf("%d%d%d",&x,&y,&d);
		x=vis[x]?New[x]:c[x];
		y=vis[y]?New[y]:c[y];
		if(x==y||!vis[d]){
			puts("no");
			continue;
		}
		d=New[d];
		int lca1=LCA(x,y),lca2=LCA(x,d),lca3=LCA(y,d);
		if(dist(x,y,lca1)==dist(x,d,lca2)+dist(y,d,lca3))puts("yes");
		else puts("no");
	}
	return 0;
}
```


---

## 作者：kbzcz (赞：4)

一开始我看这题，感觉很水，不就是无向图中两点路径的必经边吗，大水题！于是就打了缩点和 $\text{lca}$，但我看题解区好像都是建圆方树，于是水一发题解，~~为 csp 初赛攒 rp~~。

---
### 思路

先把原图的点双连通分量求出并缩点，使原图成为一棵树，再预处理 $\text{lca}$。对于询问，如果毁灭的不是割点，显然不可能成功。否则判断这个割点在不在 $s$ 和 $t$ 所在的点双连通分量的简单路径上，如果在，根据割点定义，说明这个点是 $s$ 和 $t$ 路径上的必经点，可以成功，反之不能成功。

判断树上一个点在不在其他两个点的路径上，先看看两个点的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/af6ekj94.png)
很明显，就是两个节点到他们的 lca 的路径并在一起，而在他们路径上的节点 $p$ 都必须满足：$LCA(p,LCA(s,t)=LCA(s,t)$，且 $LCA(p,s)=p$ 或 $LCA(p,t)=p$。至此，题目就解决了。

---
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e4+5,M=1e5+5;
int n,m,Q;
struct edge {
	int x,y,pre;
}a[M*2],b[M*2];int alen,last[N],blen,nxt[N];
int dfn[N],low[N],sta[N],new_id[N],col[N];
bool cut[N];
int tsp,root,top,cnt;
vector<int> dcc[N];
int dep[N],par[N][21];
void ins(int x,int y) {
	alen++;a[alen]={x,y,last[x]};
	last[x]=alen;
}
void add(int x,int y) {
	blen++;b[blen]={x,y,nxt[x]};
	nxt[x]=blen;
}
void tarjan(int x) {
	dfn[x]=low[x]=++tsp;
	sta[++top]=x;
	int flag=0;
	for(int k=last[x];k;k=a[k].pre) {
		int y=a[k].y;
		if(!dfn[y]) {
			tarjan(y);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x]) {
				flag++;
				if(flag>1||x!=root) cut[x]=1;
				cnt++;
				int z;
				do {
					z=sta[top--];
					dcc[cnt].push_back(z);
				}while(z!=y);
				dcc[cnt].push_back(x);
			} 
		}
		else low[x]=min(low[x],dfn[y]);
	}
}
void dfs(int x,int fa) {
	dep[x]=dep[fa]+1;
	par[x][0]=fa;
	for(int i=1;i<=20;i++) par[x][i]=par[par[x][i-1]][i-1];
	for(int k=last[x];k;k=a[k].pre) {
		int y=a[k].y;
		if(y!=fa) dfs(y,x);
	}
}
int LCA(int x,int y) {
	if(dep[x]>dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) {
		if(dep[par[y][i]]>=dep[x]) y=par[y][i];
	}
	if(x==y) return x;
	for(int i=20;i>=0;i--) {
		if(par[x][i]!=par[y][i]) {
			x=par[x][i];
			y=par[y][i];
		}
	}
	return par[x][0];
}
bool check(int x,int y,int p,int lca) {
	if(LCA(lca,p)!=lca) return 0;
	if(LCA(x,p)!=p&&LCA(y,p)!=p) return 0;
	return 1;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		ins(x,y);
		ins(y,x);
	}
	for(int i=1;i<=n;i++) {
		if(!dfn[i]) root=i,tarjan(i);
	}
	int num=cnt;
	for(int i=1;i<=n;i++) {
		if(cut[i]) {
			new_id[i]=++num;
		}
	}
	for(int i=1;i<=cnt;i++) {
		for(auto x:dcc[i]) {
			if(cut[x]) {
				add(new_id[x],i);
				add(i,new_id[x]);
			}
			else col[x]=i;
		}
	}
	memcpy(a,b,sizeof(a));
	memcpy(last,nxt,sizeof(last));
	n=num;
	dfs(1,0);
	scanf("%d",&Q);
	while(Q--) {
		int s,t,p;
		scanf("%d%d%d",&s,&t,&p);
		if(!cut[p]) puts("no");
		else {
			if(cut[s]) s=new_id[s];
			else s=col[s];
			if(cut[t]) t=new_id[t];
			else t=col[t];
			p=new_id[p];
			int lca=LCA(s,t);
			if(check(s,t,p,lca)) puts("yes");
			else puts("no");
		}
	}
}
```


---

## 作者：agicy (赞：4)

点此食用更佳[$\huge{\texttt{My Blog}}$](https://www.lu-anlai.com/oi/solution/tjoi2008-d1t1/)

一道 Tarjan 的好题，或者说 圆方树 的入门题？

题目链接：[Luogu P3854](https://www.luogu.com.cn/problem/P3854)/TJOI2008 D1T1。

# 题目

## 题目描述

$n$ 个点 $m$ 条边的无向连通图，$Q$ 次询问，求出删去编号为 $M_i$ 的点后 $S_i,T_i$ 是否连通。

## 数据范围

$$1\leq n\leq 2\times 10^4$$
$$1\leq m\leq 10^5$$
$$1\leq Q\leq 10^5$$

## 时空限制

|题目|时间限制|空间限制|
|:-:|:-:|:-:|
|[Luogu P3854](https://www.luogu.com.cn/problem/P3854)|$$2\text{s}$$|$$125\text{MiB}$$|
|TJOI2008 D1T1|$$?\text{s}$$|$$?\text{MiB}$$|

# 题解

## 思路

先考虑 $S_i,T_i,M_i$ 的分布情况。

- $M_i$ 在一个环上
	无论删不删都不会影响整个图的连通性。
- $M_i$ 在普通的边上
	$S_i,T_i$ 在同侧，则连通。
	否则不连通。

当年的正解好像是这么做的（我一开始也是这么想的），但这样考虑太麻烦，于是神仙们发明了**圆方树**~~（对，元芳树）~~。

把每个大小不为 $1$ 的点双连通分量进行转化，将每个点都与一个虚拟的节点连接，然后断开所有点双连通分量上原有的边，就在保留了上述性质的同时把图简化成了一颗树。

举个例子：

下面这个图：

![](https://www.lu-anlai.com/wp-content/uploads/2020/03/TJOI2008-D1T1-Z1.png)

转化后就变成了（虚线表示删掉的边）。

![](https://www.lu-anlai.com/wp-content/uploads/2020/03/TJOI2008-D1T1-Z2.png)

求点双连通分量的过程比较毒瘤，大家自己留意代码。

转化后只需要判断 $M_i$ 在不在 $S_i$ 到 $T_i$ 的路径上即可，我用的是树链剖分，标记整段路径，再单点查询（因为我懒）。

## 代码

代码的渐进时间复杂度为 $\Theta(Q\log_2^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline int read(void){
	reg bool f=false;
	reg char ch=getchar();
	reg int res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return f?-res:res;
}

const int MAXN=20000+5;
const int MAXM=100000+5;

inline void Read(void);
inline void Work(void);

int main(void){
	Read();
	Work();
	return 0;
}

int n,m;
int c[MAXM],d[MAXM];
vector<int> V[MAXN<<1];

inline void Add_Tube(int u,int v){
	V[u].push_back(v);
	V[v].push_back(u);
	return;
}

inline void Read(void){
	n=read(),m=read();
	for(reg int i=1;i<=m;++i){
		c[i]=read(),d[i]=read();
		Add_Tube(c[i],d[i]);
	}
	return;
}

int tim,dfn[MAXN<<1],low[MAXN<<1];
stack<int> S;
int fa[MAXN<<1];
int Tarjan_cnt;
vector<int> BCC[MAXN];

inline void Tarjan(int ID,int father){
	dfn[ID]=low[ID]=++tim;
	S.push(ID);
	for(reg int i=0,size=V[ID].size();i<size;++i)
		if(V[ID][i]!=father){
			if(!dfn[V[ID][i]]){
				Tarjan(V[ID][i],ID);
				low[ID]=min(low[ID],low[V[ID][i]]);
				if(low[V[ID][i]]>=dfn[ID]){
					++Tarjan_cnt;
					while(S.top()!=V[ID][i]){
						BCC[Tarjan_cnt].push_back(S.top());
						S.pop();
					}
					BCC[Tarjan_cnt].push_back(S.top());
					S.pop();
					BCC[Tarjan_cnt].push_back(ID);
				}
			}
			else
				low[ID]=min(low[ID],dfn[V[ID][i]]);
		}
	return;
}

int dep[MAXN<<1];
int size[MAXN<<1],son[MAXN<<1];

inline void DFS1(reg int ID,reg int father){
	size[ID]=1;
	fa[ID]=father;
	dep[ID]=dep[father]+1;
	for(reg int i=0;i<(int)V[ID].size();++i)
		if(V[ID][i]!=father){
			DFS1(V[ID][i],ID);
			size[ID]+=size[V[ID][i]];
			if(size[V[ID][i]]>size[son[ID]])
				son[ID]=V[ID][i];
		}
	return;
}

int top[MAXN<<1];

inline void DFS2(reg int ID,reg int father,reg int topf){
	dfn[ID]=++tim;
	top[ID]=topf;
	if(son[ID])
		DFS2(son[ID],ID,topf);
	for(reg int i=0,size=V[ID].size();i<size;++i){
		if(V[ID][i]!=father&&V[ID][i]!=son[ID]){
			DFS2(V[ID][i],ID,V[ID][i]);
		}
	}
	return;
}

struct SegmentTree{
	#define lson ( (k) << 1 )
	#define rson ( (k) << 1 | 1 )
	#define mid ( ( (l) + (r) ) >> 1 )
	struct Node{
		int val,tag;
	};
	Node unit[MAXN<<3];
	inline void pushup(reg int k){
		unit[k].val=unit[lson].val+unit[rson].val;
		return;
	}
	inline void Add(reg int k,reg int l,reg int r,reg int val){
		unit[k].val+=(r-l+1)*val;
		unit[k].tag+=val;
		return;
	}
	inline void pushdown(reg int k,reg int l,reg int r){
		if(unit[k].tag){
			Add(lson,l,mid,unit[k].tag);
			Add(rson,mid+1,r,unit[k].tag);
			unit[k].tag=0;
		}
		return;
	}
	inline void Update(reg int k,reg int l,reg int r,reg int L,reg int R,reg int val){
		if(L<=l&&r<=R){
			Add(k,l,r,val);
			return;
		}
		pushdown(k,l,r);
		if(L<=mid)
			Update(lson,l,mid,L,R,val);
		if(R>mid)
			Update(rson,mid+1,r,L,R,val);
		pushup(k);
		return;
	}
	inline int Query(reg int k,reg int l,reg int r,reg int pos){
		if(l==r&&l==pos){
			return unit[k].val;
		}
		pushdown(k,l,r);
		reg int res=0;
		if(pos<=mid)
			res=Query(lson,l,mid,pos);
		if(pos>mid)
			res=Query(rson,mid+1,r,pos);
		return res;
	}
	#undef lson
	#undef rson
	#undef mid
};

SegmentTree T;

inline void Update(int x,int y,reg int val){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		T.Update(1,1,n+Tarjan_cnt,dfn[top[x]],dfn[x],val);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])
		swap(x,y);
	T.Update(1,1,n+Tarjan_cnt,dfn[x],dfn[y],val);
	return;
}

inline int Query(reg int x){
	return T.Query(1,1,n+Tarjan_cnt,dfn[x]);
}

inline void Work(void){
	Tarjan(1,0);
	for(reg int i=1;i<=n;++i)
		V[i].clear();
	for(reg int i=1;i<=Tarjan_cnt;++i)
		for(reg int j=0;j<(int)BCC[i].size();++j)
			Add_Tube(n+i,BCC[i][j]);
	DFS1(1,0);
	tim=0;
	DFS2(1,0,1);
	reg int Q=read();
	while(Q--){
		static int s,t,m;
		s=read(),t=read(),m=read();
		Update(s,t,1);
		reg int ans=Query(m);
		puts(ans?"yes":"no");
		Update(s,t,-1);
	}
	return;
}
```

---

## 作者：BitByBit (赞：3)

# 题意
给定无向图中三个点 $x,y,z$，求去除 $z$ 后 $x,y$ 是否连通。
# 分析
此题求点双缩点然后分讨一下就好了。显然按点双缩点后是一颗树。
* 若 $x,y$ 在同一点双中或 $z$ 不是割点那 $x,y$ 显然连通。
* 否则判断 $z$ 是否在 $x,y$ 缩点后树上的路径上。$z$ 在 $x,y$ 等价于 $dis(x,z)+dis(y,z)=dis(x,y)$。求树上距离可以用 lca，求 lca 可以用树剖。
# 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 20010
int n,m,dfn,tdfn,top,cnt,root;
basic_string<int>G[N],Gt[N];//玄学basic string存图
int Dfn[N],Low[N],Stk[N];
bool Cut[N];
vector<int>Scc[N];
int Fa[N],Dep[N],Size[N],hSon[N],tDfn[N],Rank[N],Top[N];
int Col[N];
void Tarjan(int x)//Tarjan求点双
{
	Dfn[x]=Low[x]=++dfn;
	Stk[++top]=x;
	if(x==root&&G[x].empty())
	{
		Scc[++cnt].push_back(x);
		return;
	}
	int child=0;
	for(int y:G[x])
	{
		if(!Dfn[y])
		{
			Tarjan(y);
			Low[x]=min(Low[x],Low[y]);
			if(Low[y]>=Dfn[x])
			{
				if(++child>1||x!=root)Cut[x]=1;
				cnt++;
				do Scc[cnt].push_back(Stk[top--]);
				while(Stk[top+1]!=y);
				Scc[cnt].push_back(x);
			}
		}
		else Low[x]=min(Low[x],Dfn[y]);
	}
}
void dfs1(int x,int f)//两遍dfs重链剖分
{
	Fa[x]=f;
	Dep[x]=Dep[f]+1;
	Size[x]=1;
	hSon[x]=-1;
	for(int y:Gt[x])
	{
		if(y==f)continue;
		dfs1(y,x);
		Size[x]+=Size[y];
		if(hSon[x]==-1||Size[y]>Size[hSon[x]])
			hSon[x]=y;
	}
}
void dfs2(int x,int f)
{
	tDfn[x]=++tdfn;
	Rank[dfn]=x;
	Top[x]=f;
	if(hSon[x]==-1)return;
	dfs2(hSon[x],f);
	for(int y:Gt[x])
	{
		if(y==Fa[x]||y==hSon[x])continue;
		dfs2(y,y);
	}
}
int lca(int x,int y)//树剖求lca
{
	while(Top[x]!=Top[y])
	{
		if(Dep[Top[x]]<Dep[Top[y]])swap(x,y);
		x=Fa[Top[x]];
	}
	if(Dep[x]>Dep[y])swap(x,y);
	return x;
}
int dis(int x,int y)//lca求距离
{
	return Dep[x]+Dep[y]-(Dep[lca(x,y)]<<1); 
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		G[x]+=y;
		G[y]+=x;
	}
	for(int i=1;i<=n;i++)
		if(!Dfn[i])
		{
			root=i;
			Tarjan(i);
		}
	int cnt1=cnt;
	for(int i=1;i<=n;i++)
		if(Cut[i])
			Col[i]=++cnt1;
	for(int i=1;i<=cnt;i++)//Tarjan后按点双缩点
		for(int j:Scc[i])
		{
			if(Cut[j])
			{
				Gt[i].push_back(Col[j]);
				Gt[Col[j]].push_back(i);
			}
			else Col[j]=i;
		}
	dfs1(1,0);
	dfs2(1,1);//树剖
	int q;
	cin>>q;
	while(q--)
	{
		int x,y,z;
		cin>>x>>y>>z;
		x=Col[x];
		y=Col[y];
		if(x==y||!Cut[z])
		{
			cout<<"no\n";
			continue;
		}
		z=Col[z];
		cout<<(dis(x,z)+dis(z,y)==dis(x,y)?"yes\n":"no\n");
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：3)

提取题目有效信息后，就是问第三个点是否是前两点路径的必经点。我们考虑利用圆方树来解决这个问题(尽管这个东西在$2018$年冬令营才出来)。

建出圆方树后，问题转换为第三个点是否在前两个点在圆方树上的路径上。利用树剖或者倍增可以在$O(Q\log n)$的复杂度解决问题。注意圆方树要预开2倍空间。

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=4e4+7;

static int n,m;

vector<int>ed[MAXN],p[MAXN];

inline void init()
{
	read(n);read(m);
	static int u,v;
	Rep(i,1,m)read(u),read(v),ed[u].pb(v),ed[v].pb(u);
}

static int dfn[MAXN],low[MAXN],fa[15][MAXN],e,sta[MAXN],tp,tt;

void tarjan(int u,int pre)
{
	dfn[u]=low[u]=++e;sta[++tp]=u;
	for(register int v:ed[u])if(v^pre)
	{
		if(!dfn[v])
		{
			tarjan(v,u),Chkmin(low[u],low[v]);
			if(low[v]>=dfn[u])
			{
				fa[0][++n]=u;p[u].pb(n);
				do{p[n].pb(sta[tp]),fa[0][sta[tp--]]=n;}while(sta[tp+1]^v);
			}
		}
		else Chkmin(low[u],dfn[v]);
	}
}

static int dep[MAXN];

void getdep(int u)
{
	dep[u]=dep[fa[0][u]]+1;
	for(register int v:p[u])getdep(v);
}

inline int getlca(int u,int v)
{
	if(dep[u]<dep[v])swap(u,v);
	Repe(i,14,0)if(dep[u]-dep[v]>=(1<<i))u=fa[i][u];
	if(u==v)return u;
	Repe(i,14,0)if(fa[i][u]^fa[i][v])u=fa[i][u],v=fa[i][v];
	return fa[0][u];
}

static int Q;

inline void solve()
{
	tarjan(1,0);getdep(1);
	Rep(j,1,14)Rep(i,1,n)fa[j][i]=fa[j-1][fa[j-1][i]];
	read(Q);
	static int x,y,z,lc;
	Rep(i,1,Q)
	{
		read(x);read(y);read(z);
		lc=getlca(x,y);
		if(dep[z]<dep[lc]){puts("no");continue;}
		Repe(i,14,0)if(dep[x]-dep[z]>=(1<<i))x=fa[i][x];
		if(x==z){puts("yes");continue;}
		Repe(i,14,0)if(dep[y]-dep[z]>=(1<<i))y=fa[i][y];
		if(y==z){puts("yes");continue;}
		puts("no");
	}
}

int main()
{
    file();
    init();
    solve();
    return 0;
}
```

---

## 作者：ny_WYR (赞：1)

## **题意**
给定一个有向图，每次询问 $S$，$T$，$M$，在删除点 $M$ 后 $S$ 和 $T$ 是否不连通。  
## **Solution**
首先，在一个点双连通分量（以下简称“点双”）内，删除任意一个点都不会使得这个点双中其他的两个点不连通，所以先缩点。缩完点后重新建的图由于没有环必定是一棵树，于是问题转化为 $id[M]$ （缩完点后 $M$ 所在的新点的编号）是否在 $id[S]$ 到 $id[T]$ 的简单路径上且 $M$ 是否为割点。  

那么如何判断 $id[M]$ 是否在 $id[S]$ 到 $id[T]$ 的简单路径上呢？这里提供一种新的思路：先把$id[S]$ 到 $id[T]$ 的路径染色，然后判断 $id[M]$ 是否被染到，判断完再把 $id[S]$ 到 $id[T]$ 的路径上的染色去掉。

动态修改树上的一条路径用什么呢？嗯——树链剖分。由于这次是区间修改，单点查询，于是用树状数组。  

还有一个小点要注意一下：点双的数量+割点的数量有可能大于原来的点数 $n$ ~~（我因为这个卡了好久）~~。
## **AC Code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=2e4+5;
int const M=1e5+5;
int h[N],h2[N];
struct edge{
	int t,next;
}e[M<<1],e2[M<<1];
int n,m,idx,q;
void init(int x,int h[]){
	for(int i=1;i<=x;i++) h[i]=-1;
}
void add(int f,int t,edge e[],int h[]){
	e[idx].t=t;
	e[idx].next=h[f];
	h[f]=idx++;
}
int dfn[N],low[N],tot;
int stk[N],tp;
int id[N];
vector<int> dcc[N];
bool cut[N];
int cnt;
int root;
int res;
void tarjan(int u){
	dfn[u]=low[u]=++tot;
	stk[++tp]=u;
	int son=0;
	for(int i=h[u];~i;i=e[i].next){
		int v=e[i].t;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				son++;
				if((u!=root||son>1)&&!cut[u]){
					cut[u]=true;
					res++;
				}
				cnt++;
				while(1){
					int p=stk[tp--];
					dcc[cnt].push_back(p);
					if(p==v) break;
				}
				dcc[cnt].push_back(u);
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
}
int sz[N],dep[N],fa[N],son[N],top[N];

void dfs(int u,int p){
	fa[u]=p;
	sz[u]=1;
	dep[u]=dep[p]+1;
	for(int i=h2[u];~i;i=e2[i].next){
		int v=e2[i].t;
		if(v==p) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		if(sz[v]>sz[son[u]]){
			son[u]=v;
		}
	}
}
void DFS(int u,int p,int tp){
	dfn[u]=++tot;
	top[u]=tp;
	if(son[u]) DFS(son[u],u,tp);
	for(int i=h2[u];~i;i=e2[i].next){
		int v=e2[i].t;
		if(v==p||v==son[u]) continue;
		DFS(v,u,v);
	}
}
int c[N];
int lowbit(int x){
	return x&(-x);
}
void update(int x,int k){
	for(int i=x;i<=res+cnt
	;i+=lowbit(i))
		c[i]+=k;
}
int getsum(int x){
	int sum=0;
	for(int i=x;i>0;i-=lowbit(i)){
		sum+=c[i];
	}
	return sum;
}
void modify(int x,int y,int d){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		update(dfn[top[x]],d);
		update(dfn[x]+1,-d);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	update(dfn[y],d);
	update(dfn[x]+1,-d);
}
signed main(){
	scanf("%d%d",&n,&m);
	init(n,h);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v,e,h);
		add(v,u,e,h);
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]){
			root=i;
			tarjan(i);
		}
	}
	int num=cnt;
	init(cnt+res,h2);
	idx=0;
	for(int i=1;i<=cnt;i++){
		for(auto v:dcc[i]){
			if(cut[v]){
				if(!id[v]) id[v]=++num;
				add(id[v],i,e2,h2);
				add(i,id[v],e2,h2);
			}
			else id[v]=i;
		}
	}
	tot=0;
	memset(dfn,0,sizeof dfn);
	dfs(1,0);
	DFS(1,0,1);
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		int x,y,f;
		scanf("%d%d%d",&x,&y,&f);
		x=id[x]; y=id[y];
		modify(x,y,1);
		if(getsum(dfn[id[f]])&&cut[f]) printf("yes\n");
		else printf("no\n");
		modify(x,y,-1);
	}
	return 0;
}
```

---

## 作者：david0911 (赞：1)

一道圆方树的入门题。

## 题意

给出一张无向连通图，多次询问删去一点 $M$ 后点 $S$ 与点 $T$ 是否连通。

## 分析

考虑一个弱化版的问题：多次询问删去 **一条边** 后两点是否连通。显然对于弱化版的问题可以对原图进行边双连通分量的缩点。

而此题将 **删边** 改为 **删点**，我们不能简单地对点双连通分量（下文简称点双）进行缩点（因为一个割点属于多个点双连通分量），所以考虑对点双进行处理的 **圆方树**。这里我们定义一个点双连通图为 **不存在割点的图**，一个点双为 **极大点双连通子图**。

### 对圆方树的简单介绍

在圆方树中，原图的每一个点对应一个圆点，每一个点双对应一个方点。对于原图的每一个点双，将其对应的方点与点双内的每一个点连边。这样就将原图转换为一棵树，完成了圆方树的构建。

根据上述过程，我们可以在求出点双的过程中构建圆方树。

**注意**：由于割点数量小于 $n$，所以圆方树的结点数量小于 $2n$，数组大小要开 $2$ 倍。

建树部分代码如下：

```cpp
bool cut[maxn];//记录原图中的一个点是否为割点。
vector<int> e[maxn];//记录原图。
vector<int> g[maxn<<1];//记录新图，即圆方树。

void tarjan(int u){
	low[u]=dfn[u]=++dfc;
	stk[++tp]=u;
	int len=e[u].size();
	for(int i=0;i<len;++i){
		int v=e[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]==dfn[u]){
				cut[u]=true;
				++tot;
				while(stk[tp+1]!=v){
					g[tot].push_back(stk[tp]);
					g[stk[tp]].push_back(tot);
					tp--;
				}
				g[tot].push_back(u);
				g[u].push_back(tot);
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
}
```

## 做法

容易发现，在原图上删点与在圆方树上删点对于其他点连通性的影响是等价的。于是原问题转换成：在原图的圆方树上多次查询一个点 $M$ 是否在点 $S$ 到点 $T$ 的简单路径上。

记 $dis_{u,v}$ 表示在圆方树上点 $u$ 到点 $v$ 的简单路径的长度，这里令树上的边权为 $1$。对于转换后的问题，一个等价的问题是：在圆方树上，是否有 $dis_{S,T} = dis_{S,M} + dis_{M,T}$。这一问题通过求解树上两点的最近公共祖先，进而求出树上两点间距离可以轻易解决。

至此，本题得到解决。

**AC Code**

```cpp
#include<bits/stdc++.h>

using namespace std;

const int maxn=2e4+10;
int n,m,q,dfc=0,tp=0,tot=0,stk[maxn],low[maxn],dfn[maxn],tpp[maxn<<1],dep[maxn<<1],fa[maxn<<1],son[maxn<<1],siz[maxn<<1];
bool cut[maxn];
vector<int> e[maxn];
vector<int> g[maxn<<1];

void tarjan(int u){
	low[u]=dfn[u]=++dfc;
	stk[++tp]=u;
	int len=e[u].size();
	for(int i=0;i<len;++i){
		int v=e[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]==dfn[u]){
				cut[u]=true;
				++tot;
				while(stk[tp+1]!=v){
					g[tot].push_back(stk[tp]);
					g[stk[tp]].push_back(tot);
					tp--;
				}
				g[tot].push_back(u);
				g[u].push_back(tot);
			}
		}
		else low[u]=min(low[u],dfn[v]);
	}
}

void dfs1(int u,int f,int d){
	fa[u]=f;
	dep[u]=d;
	siz[u]=1;
	son[u]=-1;
	int len=g[u].size();
	for(int i=0;i<len;++i){
		int v=g[u][i];
		if(v==f) continue;
		dfs1(v,u,d+1);
		siz[u]+=siz[v];
		if(son[u]==-1||siz[son[u]]<siz[v]) son[u]=v;
	}
}

void dfs2(int u,int p){
	tpp[u]=p;
	if(son[u]==-1) return;
	dfs2(son[u],p);
	int len=g[u].size();
	for(int i=0;i<len;++i){
		int v=g[u][i];
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}

int lca(int u,int v){
	while(tpp[u]!=tpp[v]){
		if(dep[tpp[u]]<dep[tpp[v]]) v=fa[tpp[v]];
		else u=fa[tpp[u]];
	}
	return dep[u]<dep[v]?u:v;
}

int main(){
	scanf("%d%d",&n,&m);
	tot=n;
	for(int i=1,c,d;i<=m;++i){
		scanf("%d%d",&c,&d);
		e[c].push_back(d);
		e[d].push_back(c);
	}
	for(int i=1;i<=n;++i){
		if(!dfn[i]){
			tp=0;
			tarjan(i);
		}
	}
	dfs1(1,0,1);
	dfs2(1,1);
	scanf("%d",&q);
	for(int i=1,s,t,c;i<=q;++i){
		scanf("%d%d%d",&s,&t,&c);
		int a=lca(s,t),b=lca(c,s),d=lca(c,t);
		if(dep[s]+dep[t]-2*dep[a]!=dep[c]+dep[s]-2*dep[b]+dep[c]+dep[t]-2*dep[d]){
        		puts("no");
            }
		else puts("yes"); 
	}
	return 0;
}
```

---

## 作者：Phobia (赞：1)

这道题可以从分治的角度出发解决。

类似于 [CF19E](https://www.luogu.com.cn/problem/CF19E) 的做法，分治编号在 $[L,R]$ 之外的点都加入图中。

判断两点是否联通即判断两点是否在一个并查集中，删边开个栈用可撤销并查集撤销连边即可。

时间复杂度 $O(m\log n\log m)$。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 20005;

int n, m, q;

struct edge
{
    int x, y;
} E[maxn];

struct query
{
    int id, x, y;
};

int fa[maxn], siz[maxn], top;

vector<int> G[maxn];

vector<query> Q[maxn];

bool ans[100005];


int read()
{
    int ret = 0, ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        ;
    for (; isdigit(ch); ch = getchar())
        ret = (ret << 3) + (ret << 1) + (ch & 15);
    return ret;
}

void add_edge(int x, int y)
{
    G[x].push_back(y);
    G[y].push_back(x);
}

int getfa(int x)
{
    return fa[x] == x ? x : getfa(fa[x]);
}

void merge(int x, int y)
{
    x = getfa(x), y = getfa(y);
    if (x != y)
    {
        if (siz[x] > siz[y])
            swap(x, y);
        E[++top] = (edge){ x, y };
        fa[x] = y, siz[y] += siz[x];
    }
}

void recover(int x, int y)
{
    fa[x] = x, siz[y] -= siz[x];
}

void solve(int l, int r)
{
    if (l == r)
    {
        for (auto it : Q[l])
            ans[it.id] = (getfa(it.x) != getfa(it.y));
        return;
    }
    int mid = l + r >> 1, now = top;
    for (int i = mid + 1; i <= r; ++i)
    {
        for (int j = 0; j < G[i].size() && G[i][j] < l; ++j) // 这一步是保证在合法区间内连边，下同。
            merge(i, G[i][j]);
        for (int j = G[i].size() - 1; j >= 0 && G[i][j] > mid; --j)
            merge(i, G[i][j]);
    }
    solve(l, mid);
    for (; top > now; --top)
        recover(E[top].x, E[top].y);
    for (int i = l; i <= mid; ++i)
    {
        for (int j = 0; j < G[i].size() && G[i][j] <= mid; ++j)
            merge(i, G[i][j]);
        for (int j = G[i].size() - 1; j >= 0 && G[i][j] > r; --j)
            merge(i, G[i][j]);
    }
    solve(mid + 1, r);
    for (; top > now; --top)
        recover(E[top].x, E[top].y);

}

int main()
{
    n = read(), m = read();
    for (int i = 1; i <= m; ++i)
        add_edge(read(), read());
    q = read();
    for (int i = 1; i <= q; ++i)
    {
        int s = read(), t = read(), m = read();
        Q[m].push_back((query) { i, s, t });
    }
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i, siz[i] = 1;
        sort(G[i].begin(), G[i].end());
    }
    solve(1, n);
    for (int i = 1; i <= q; ++i)
        puts(ans[i] ? "yes" : "no");
    return 0;
}
~~~

---

## 作者：andy88888 (赞：1)

---
## 前言
本题就是一个~~大水题~~，基本等同于模板题加起来，那么废话不多说，直接开讲。
## 思路
直接看，首先先点双，之后，如果炸毁的这个点不是割点，那么肯定不对，如果是割点，要达到效果的两个点的距离，等于一个点到割点的距离加上另外一点到割点的距离，就达到效果了，因为这个点在这两个点的路径之中(因为点双后的图一定是树)，这里可以用到最近公共祖先。  
这里只讲倍增做法，先把两个点爬到同一层，然后开始倍增找公共祖先，注意为了更快，我们可以从大到小，如果没找到公共祖先,那么先更新两个节点，接着如果找到公共祖先，那么 $i$ 会变小，这样求出来的结果一定是最近公共祖先的一个儿子，再算一次即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int low[400005];
int dfn[400005];
int cut[400005];
int times;
stack<int>s;
int n,m;
vector<int>a[400005];
vector<int>g[400005];
vector<int>ans[400005];
int huan[400005];
int d[400005];
int go[400005][23];
int id[400005];
int cnt;
void tarjan(int u,int root){
    dfn[u]=low[u]=++times;
    s.push(u);
    int child=0;
    for(int i=0;i<a[u].size();i++){
        int v=a[u][i];
        if(dfn[v]==0){
            child++;
            tarjan(v,root);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                cnt++;
                ans[cnt].push_back(u);
                while(s.top()!=v){
                    ans[cnt].push_back(s.top());
                    s.pop();
                }
                ans[cnt].push_back(v);
                ans[cnt].push_back(u);
				cut[u]=1;
                s.pop();
            }
        }else low[u]=min(low[u],dfn[v]);
    }
    if(u==root&&child==0) ans[++cnt].push_back(u);
}//标准的点双！
void yuchuli(int u,int fa){
    d[u]=d[fa]+1;
    go[u][0]=fa;
    for(int i=1;(1<<i)<=d[u];i++){
        go[u][i]=go[go[u][i-1]][i-1];
    }
    for(int i=0;i<g[u].size();i++){
        int v=g[u][i];
        if(v==fa) continue;
        yuchuli(v,u);
    }
}
int LCA(int u,int v){
    if(d[u]>d[v]) swap(u,v);
    for(int i=22;i>=0;i--){
        if(d[u]<=d[v]-(1<<i)) 
            v=go[v][i];
    }
    if(u==v) return v;
    for(int i=22;i>=0;i--){
        if(go[u][i]!=go[v][i]){
            u=go[u][i];
            v=go[v][i];
        }
    }
    return go[u][0];
}
int dist(int u,int v,int lca){
    return d[u]+d[v]-2*d[lca];
}//计算距离的公式
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        a[u].push_back(v);
        a[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]){
            tarjan(i,i);
        }
    }
    int sum=cnt;
    for(int i=1;i<=n;i++){
        if(cut[i]) id[i]=++sum;
    }
    for(int i=1;i<=cnt;i++){
        for(int j=0;j<ans[i].size();j++){
            int v=ans[i][j];
            if(cut[v]){
                g[id[v]].push_back(i);
                g[i].push_back(id[v]);
            }else huan[v]=i;
        }
    }
    for(int i=1;i<=sum;i++){
        if(d[i]==0) yuchuli(i,0);
    }
    int T;
    cin>>T;
    while(T--){
        int u,v,k;
        cin>>u>>v>>k;
        if(u==v||!cut[k]){
            cout<<"no\n";
            continue;
        }//如果不是割点，那还判个蛋~~

        if(cut[u]) u=id[u];
        else u=huan[u];
        if(cut[v]) v=id[v];
        else v=huan[v];
        k=id[k];
        int A=dist(u,k,LCA(u,k));
        int B=dist(v,k,LCA(v,k));
        int C=dist(u,v,LCA(u,v));//如果我到割点的距离+割点到你的距离=我到你的距离，说明这个割点在我们两个的必经之路（因为这是一棵树）
        if(A+B==C){
            cout<<"yes\n";
        }else{
            cout<<"no\n";
        }
    }
    return 0;
}
``````
练练模板吧！一道水蓝！~~虽然我交了至少20次~~~~~~

---

## 作者：Wind_love (赞：0)

## 思路
显然，用点双联通分量。  
首先考虑 $M$ 点不是割点的情况。若 $M$ 非割点，则删除该点后，图仍联通，显然不行。  
另一种情况是点 $S$ 与点 $T$ 在同一个点双联通分量中，则删除任何割点都不能断开两点联系，非割点亦然。  
接着我们考虑其他情况，题中的图是可能有环的，所以我们进行缩点操作。  
对于该题，显然是将每个点双联通分量缩成一个点，这样图就变成了一棵树，我们需要解决的问题就变成 $M$ 点是否在 $S$ 到 $T$ 的路径上。  
一个简单的方法是断掉该点及其所连边，看从 $S$ 点能否到达 $T$ 点，但是显然过慢。  
解决方案是看 $S$ 到 $M$ 的距离加 $M$ 到 $T$ 的距离是否等于 $S$ 到 $T$ 的距离。  
具体求距离的方法是 lca 加上预处理每个点的深度，这样我们就解决了这个题。

---

## 作者：Chenyichen0420 (赞：0)

## 题目大意：

给你一张图，问你删掉点 $m$ 后 $s$ 和 $t$ 是否可达。

## 思路分析

首先，如果 $s$ 和 $t$ 在同一个点双当中的话，那么无论你怎么删他们都一定会仍旧联通。

其次，如果 $m$ 不是割点，那么删去 $m$ 后整张图仍然联通，即 $s$ 和 $t$ 仍然可达。

以上两种情况对应代码第 $57$ 行。

最后，我们将所有的点双缩成一个点，原图就会变成一棵树。我们要判断的就是 $d$ 是否在 $s$ 到 $t$ 的路径上。一种常用的方法是判断 $s$ 到 $t$ 的距离是否等于 $s$ 到 $d$ 的距离加上 $d$ 到 $t$ 的距离。如果相等那么 $d$ 在 $s$ 到 $t$ 的路径上。反之不是。

对应代码第 $58$ 行。

综上，此题可解。

前两种情况，你需要预处理出每个点属于哪个点双以及每个点是不是割点，以及为这个割点单独建的点编号。

对应代码中的 $7$ 至 $25$ 行和 $46$ 至 $54$ 行。

最后一种情况，你需要能够求出新树上的最近公共祖先。

对应代码中的 $26$ 至 $38$ 行。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>son[20005], dc[20005];
int dfn[20005], low[20005], cntt, dcc, q, n, m;
int nid[20005], idc[20005], l, r, d; bool is[20005];
int dep[20005], ft[20005][19]; stack<int>s;
inline void tmin(int& l, const int& r) { (l > r) && (l = r); }
#define sp son[p][i]
void tarjan(int p) {
	dfn[p] = low[p] = ++cntt; s.push(p); int cnt = 0;
	for (int i = 0; i ^ son[p].size(); ++i)
		if (!dfn[sp]) {
			tarjan(sp); tmin(low[p], low[sp]);
			if (dfn[p] <= low[sp]) {
				cnt++; int tmp; dcc++;
				is[p] |= (p != 1 || cnt != 1);
				do
					tmp = s.top(), s.pop(),
					dc[dcc].push_back(tmp);
				while (tmp != sp);
				dc[dcc].push_back(p);
			}
		}
		else tmin(low[p], dfn[sp]);
}
void dfs(int p, int fa) {
	dep[p] = dep[fa] + 1; ft[p][0] = fa;
	for (int i = 1; i <= 18; i++) ft[p][i] = ft[ft[p][i - 1]][i - 1];
	for (int i = 0; i != son[p].size(); ++i) if (sp != fa) dfs(son[p][i], p);
}
inline int getlca(int l, int r) {
	if (dep[l] < dep[r])l ^= r ^= l ^= r;
	for (int i = 18; i >= 0; i--) if (dep[ft[l][i]] >= dep[r])l = ft[l][i];
	if (l == r)return r;
	for (int i = 18; i >= 0; i--) if (ft[l][i] != ft[r][i]) l = ft[l][i], r = ft[r][i];
	return ft[l][0];
}
#define dis(l, r, mp) (dep[l] + dep[r] - dep[mp] * 2)
int main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
		cin >> l >> r,
		son[l].emplace_back(r),
		son[r].emplace_back(l);
	tarjan(1); int tps = dcc;
	for (int i = 1; i <= n; i++) if (is[i]) nid[i] = ++tps;
	for (int i = 1; i <= n; ++i) son[i].clear();
	for (int i = 1; i <= dcc; i++)
		for (int j = 0; j < dc[i].size(); j++)
			if (is[dc[i][j]])
				son[nid[dc[i][j]]].emplace_back(i),
				son[i].emplace_back(nid[dc[i][j]]);
			else idc[dc[i][j]] = i;
	dfs(1, 0); cin >> q;
	while (q--)
		if (cin >> l >> r >> d, (l = (is[l] ? nid[l] : idc[l])) == (r = (is[r] ? nid[r] : idc[r])) || !is[d]) puts("no");
		else if (d = nid[d], dis(l, r, getlca(l, r)) == dis(l, d, getlca(l, d)) + dis(r, d, getlca(r, d))) puts("yes"); else puts("no");
	return 0;
}
```

---

## 作者：sgl654321 (赞：0)

### 写在前面
纪念第 200 道水蓝的诞生。

## 题目大意
- 给定一个无向连通图，$q$ 次询问。
- 每次给定三个点 $x,y,z$，问去掉点 $z$ 及其相邻的所有边之后，$x,y$ 是否会变得不连通。

## 解题思路
无向图上出现了**去掉点 $z$ 及其相邻的所有边**的字眼，马上想到**割点**或者**点双连通分量**。

点双连通分量有一个特殊的点是，一个点可能处于多个点双连通分量中。因此我们不能对它直接缩点，我们有一种特殊的结构可以处理这类问题。

### 圆方树

具体地，建立圆方树的步骤为：

1. 求出所有点双联通分量，并摧毁原图。

见模板 [P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435)。

2. 对于每一个点双连通分量，新建一个节点 $x$。然后我们把 $x$ 向这个点双中所有的点连接一条无向边。 

3. 为了分清楚哪个是新建的点，哪个是原图中的点，我们称原图中的点为**圆点**，新建的点为**方点**，因此得名圆方树。

例如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/scm9y2zt.png)

我们发现圆方树有如下性质：

1. 这是一棵树，我们设原图有 $n$ 个节点，$d$ 个点双连通分量，那么圆方树中的节点个数为 $n+d$。
2. 任意两个圆点之间的路径上，至少有一个方点。进一步地，设路径上有 $x$ 个圆点，则有 $x-1$ 个方点。
3. 同一个点双连通分量中的任意两点，在圆方树的路径上有且只有一个方点。进一步地，设 $u,v$ 在圆方树的路径上经过的圆点集合为 $\{A\}$，则切断任意一个 $A_i$，都会使得 $u,v$ 在原图上不连通。


建立出圆方树后就变得非常直观了。由性质 $3$，我们只需要判断切断的点 $z$ 是否在 $x,y$ 在圆方树上的路径上即可。

### 判断点 $z$ 是否在树上两点 $x,y$ 的路径上

这个，我们可以参考 [P3398 仓鼠找 sugar](https://www.luogu.com.cn/problem/P3398) 的后半部分。

我们设 $x,y$ 在圆方树上的最近公共祖先为 $\text{lca}(x,y)=lc$。那么 $x,y$ 的路径就拆分成了两块：$(x,lc)+(y,lc)$。

显然，如果 $dep_{lc}>dep_z$，即点 $z$ 在他们最近公共祖先的上方，那么这个点 $z$ 一定不在 $x,y$ 的路径上。

另外，我们只需要满足下面两个条件的其中一个就行了。

1. $\text{lca}(z,x)=z$
2. $\text{lca}(z,y)=z$

正确性是显然的，大家画几个图就能看出来。

因此这题就用时间复杂度为 $O(n+m+q\log n)$ 的算法解决了！

## 参考代码
我承认我图论写的非常丑。代码放在[这里](https://www.luogu.com.cn/paste/y1qx6zz9)。


---


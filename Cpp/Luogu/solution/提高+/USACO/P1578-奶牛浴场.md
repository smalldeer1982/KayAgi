# 奶牛浴场

## 题目描述

由于 John 建造了牛场围栏，激起了奶牛的愤怒，奶牛的产奶量急剧减少。为了讨好奶牛，John 决定在牛场中建造一个大型浴场。但是 John 的奶牛有一个奇怪的习惯，每头奶牛都必须在牛场中的一个固定的位置产奶，而奶牛显然不能在浴场中产奶，于是，John 希望所建造的浴场不覆盖这些产奶点。这回，他又要求助于 Clevow 了。你还能帮助 Clevow 吗？

John 的牛场和规划的浴场都是矩形。浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。浴场不能覆盖任何产奶点，但是产奶点可以位于浴场的轮廓上。

Clevow 当然希望浴场的面积尽可能大了，所以你的任务就是帮她计算浴场的最大面积。

## 说明/提示

对于所有数据，$0 \le n \le 5 \times 10^3$，$1 \le L,W \le 3 \times 10^4$。

Winter Camp 2002

感谢 @凯瑟琳98 提供了 4 组 hack 数据。

## 样例 #1

### 输入

```
10 10
4
1 1
9 1
1 9
9 9```

### 输出

```
80```

# 题解

## 作者：WKAHPM (赞：81)

### 0.问题类型

这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》

这篇论文介绍了两种求最大子矩形的思路，分别是通过障碍点找子矩形和通过悬线找子矩形，本题的数据范围适合使用第一种方法

### 1.算法思路

定义极大子矩形为$4$条边都不能向外拓展的有效子矩形（这里的有效即子矩形内不包括障碍点)。

可以得到最大子矩形是所有极大子矩形中最大的，所以只要枚举最大的子矩形，求出其中最大的即可

### 2.算法实现

怎么找极大子矩形？根据极大子矩形的定义，我们可以得出极大子矩形的$4$条边一定覆盖障碍点（或边界）

为了方便讨论，我们先将整个牛场的4个顶点设为障碍点。

例如

10 10

4

1 1

3 4 

6 3

9 8

### 1.从左往右搜
将障碍点按横坐标排序（左右顺序）后得到如下编号。

(作者画画不是那么好qwq)

![TIM截图20191008223603.png](https://i.loli.net/2019/10/08/MTs4woRkLn2DqP3.png)


一开始从$1$号障碍点开始，从左往右找极大子矩形。

一开始的极大子矩形上下边界$up,low$为整个牛场的上下边界

$1$号障碍点往右找，到$2$号障碍点，如图

![1.png](https://i.loli.net/2019/10/08/3KxzmUQvLoM8keN.png)

可以得到一个极大子矩形，它的面积就是障碍点$2$的横坐标减去障碍点$1$的横坐标乘以上边界减去下边界。

接下来需要对上下边界做一些修改，否则之后的极大子矩形可能会包括障碍点。因为$2$的纵坐标大于$1$的纵坐标，所以修改上边界，修改为$2$的纵坐标。

接下来到$3$，同理可以得到如下极大子矩形

![2.png](https://i.loli.net/2019/10/08/yLZbSluAH1JU3aw.png)

它的面积就是$3$的横坐标减去$1$的横坐标乘以上边界（$2$的纵坐标）减去下边界

之后的$4$也同理。

然后从$2$开始往右找，从$3$开始往右找,从$4$开始往右找，跟从$1$开始找都是一样的。

### 2.从右往左搜

从左往右搜后我们会发现有一些遗漏的情况，就是极大子矩形的左边界是牛场的左边界，右边界覆盖一个障碍点的情况，如图

![3.png](https://i.loli.net/2019/10/08/CIW8PVt9zjrKyOX.png)

解决方法很简单，把从左往右搜倒过来从右往左搜一遍即可

### 3.特殊情况

在从左往右搜和从右往左搜后我们发现还有一种情况没有考虑到，就是极大子矩形的左右边界分别是牛场的左右边界，如图

![4.png](https://i.loli.net/2019/10/08/OxDvByJqsWYUiTw.png)

解决方法是，再将障碍点按纵坐标排序，如图

![5.png](https://i.loli.net/2019/10/08/i8UIqVrj5BEhCFT.png)

可以得到这类极大子矩形的面积就是相邻两个障碍点（按纵坐标排序后）纵坐标之差乘以牛场的长

时间复杂度$O(N^2)$，$N$为障碍点数

### 3.代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int read()//快读
{
	int sum = 0 , f = 1;
	char c = getchar();
	while(c < '0' or c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' and c <= '9')
	{
		sum = (sum << 1) + (sum << 3) + c - '0';
		c = getchar();
	}
	return sum * f;
}

struct S{//存放障碍点信息
	int x , y;
}s[5010];

bool cmp1(S a , S b)//按横坐标排序
{
	if(a.x != b.x) return a.x < b.x;
	else return a.y < b.y; 
}

bool cmp2(S a , S b)//按纵坐标排序
{
	if(a.y != b.y) return a.y < b.y;
	else return a.x < b.x ; 
}

int l , w , n , ans; 

int main()
{
    l = read() , w = read() , n = read();   
    for(int i = 1; i <= n; i ++) s[i].x = read() , s[i].y = read();
    s[++ n].x = 0 , s[n].y = 0;//将四个顶点设为障碍点
	s[++ n].x = 0 , s[n].y = w;
	s[++ n].x = l , s[n].y = 0;
	s[++ n].x = l , s[n].y = w;
    int x1 , x2 , y1 , y2;//x1为左边界，x2为右边界,y1为下边界，y2为上边界
    //从左往右搜
    sort(s + 1 , s + n + 1 , cmp1);
    for(int i = 1; i <= n; i ++)
    {
    	x1 = s[i].x , y1 = 0 , y2 = w;
    	for(int j = i + 1; j <= n; j ++)
    	{
				x2 = s[j].x;
				ans = max(ans , (x2 - x1) * (y2 - y1));
	    		if(s[j].y < s[i].y) y1 = max(y1 , s[j].y);//更新上下边界
	    	    else y2 = min(y2 , s[j].y); 
		}
	}
    //从右往左搜  
    for(int i = n; i >= 1; i --)
    {
    	x1 = s[i].x , y1 = 0 , y2 = w;
    	for(int j = i - 1; j >= 1; j --)
    	{
	    		x2 = s[j].x;
				ans = max(ans , (x1 - x2) * (y2 - y1));
				if(s[j].y < s[i].y) y1 = max(y1 , s[j].y);
	    	    else y2 = min(y2 , s[j].y); 
		}
	}

	//处理特殊情况
	sort(s + 1 , s + n + 1 , cmp2); 
	for(int i = 1; i <= n - 1; i ++)
	{
		ans = max(ans , l * (s[i + 1].y - s[i].y));
	}
	
	printf("%d" , ans);
	return 0;
}
```



---

## 作者：Ofnoname (赞：20)

@I_AM_HelloWord 这位dalao的题解点醒了我，但是还可以说的更详细。

1. 这道题不是P4147，P1169那种普通悬线法。因为30000*30000的数组开不下。而障碍物数量较少，应该将枚举障碍物作为边界。



2. （感谢@JZ_lover5 dalao）一个点默认只能向右到达最靠右的点而到不了右边界。所以还应该考虑这个点直接往右边界走的情况。即直接用这个点横坐标乘以剩余的高度（`h1 - h2`）。

3. 向右枚举是以每个点作为起点的，这样就漏掉了以左边界开头的情况。所以每个点还要向左枚举，才能得到到达左边界的情况。虽然会有很多重复，但本题并不卡时限。另外跟2一样，也要考虑一个点直接往左走的情况。

4. 无论向左向右都是用点开头的，还少了左右边界分别作为矩形两端的情况。做法是特判：按Y排序后，用相邻的y值差作为宽乘上地图总长，相当于只以这两个点加上地图左右作为边界。

5. X坐标相同，Y坐标不同的点每个都要枚举。他们看似会得出相同结果，但是对于后面的点B来说，他在A1的下方，但如果是同列的A2，可能就在A2的上方了。可以在@I_AM_HelloWord 的样例点1下方增加一个点体会这个过程。

6. 这里的剪枝是算出枚举的边界点向左（或向右）能走的最大距离（即走到边界）。如果这个距离乘上当前高已经小于当前答案就放弃。因为往后走时宽和高都只会越来越小。

7. 向左（或右）枚举时遇到同高度的点时，貌似既可以降低上边界，也可以提高下边界，都可以继续往后，以A1,A2作为上或下边界。但是这两个矩形在以后枚举A2向左走的情况时还会被考虑到，所以为了避免分支就直接放弃，同时也不用再考虑走到边界。可以在点1右方加入一个点体会这个过程。这一点@I_AM_HelloWord dalao 貌似说错了。

8. 最后可以试一下能否处理`K = 0`的情况，可以特判，也可以在四个角加上四个点。

```cpp
#include <bits/stdc++.h>
#define MAX (5000+7)
using namespace std;

struct Node{int x,y;} a[MAX];
int N,M,K,ans;

inline int cmp1(Node a,Node b){return a.x!=b.x ? a.x<b.x : a.y<b.y;}
inline int cmp2(Node a,Node b){return a.y < b.y;}

int main()
{
	scanf("%d%d%d",&N,&M,&K);
	for (int i=1; i<=K; i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	a[++K] = Node{N,0}; a[++K] = Node{N,M};
	a[++K] = Node{0,M}; a[++K] = Node{0,0};//8
	sort(a+1,a+K+1,cmp1);
	
	for (int i=1; i<=K; i++)
	{
		int h1 = M, h2 = 0, v = N - a[i].x, fa = 0;
		for (int j=i+1; j<=K; j++)
			if (a[j].y<=h1 && a[i].y>=h2)
			{
				if (v * (h1 - h2) <= ans) break;//6
				ans = max(ans, (h1-h2) * (a[j].x-a[i].x));
				if (a[j].y == a[i].y)
				{
					fa = 1;//7，此时退出则不用再考虑走到边界 
					break;
				}
				if (a[j].y > a[i].y) h1 = min(h1,a[j].y);
				else h2 = max(h2,a[j].y);
			}
		if (!fa) ans = max(ans, v*(h1 - h2));//2
		h1 = M, h2 = 0, v = a[i].x, fa = 0;
		for (int j=i-1; j>=1; j--)//3，再来一遍考虑往左走 
			if (a[j].y<=h1 && a[i].y>=h2)
			{
				if (v * (h1 - h2) <= ans) break;//6
				ans = max(ans, (h1-h2) * (a[i].x-a[j].x));
				if (a[j].y == a[i].y)
				{
					fa = 1;//7，此时退出则不用再考虑走到边界
					break;
				}
				if (a[j].y > a[i].y) h1 = min(h1,a[j].y);
				else h2 = max(h2,a[j].y);
			}
		if (!fa) ans = max(ans, v*(h1 - h2));//2
	}
	
	sort(a+1,a+K+1,cmp2);//4，考虑两端都是边界 
	for (int i=1; i<K; i++)
		ans = max(ans, (a[i+1].y-a[i].y) * N);
	printf("%d\n",ans);
}
```


---

## 作者：狂丿Kurumi (赞：7)

本蒟蒻喜欢打lol，所以有些变量用qwer等等，多多见谅。
    下面来说一下这个题，我觉得，就是个极大的思想，想想一下把每个点，或每多个点框住的矩形来算最大，从左到右来一遍，比最大，在从上到下来一编看看有没有漏的，之后就A掉了一个看似dp很难的题
谢谢
    本蒟蒻能力不够所以代码比较水，多多见谅。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int l,w,n;
struct qw
{
	int x,y;
}e[5005];
bool cmp1(qw a,qw b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
bool cmp2(qw a,qw b)
{
	if(a.y==b.y)return a.x<b.x;
	return a.y>b.y;
}
int main()
{
	cin>>l>>w>>n;
	if(!n)
	{
		cout<<l*w;
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>e[i].x>>e[i].y;
	}
	sort(e+1,e+n+1,cmp1);
	int ans=-1;
	for(int i=1;i<=n;i++)
	{
		int r=w,q=0;
		for(int j=i+1;j<=n;j++)
		{
			ans=max(ans,(e[j].x-e[i].x)*(r-q));
			if(e[j].y>=e[i].y)r=min(r,e[j].y);
            if(e[j].y<=e[i].y)q=max(q,e[j].y);
		}
		ans=max(ans,(l-e[i].x)*(r-q));
	}//一遍zy
	for(int i=n;i>=1;i--)
    {
        int r=w,q=0;
        for(int j=i-1;j>=1;j--)
        {
            ans=max(ans,(e[i].x-e[j].x)*(r-q));
            if(e[j].y>=e[i].y)r=min(r,e[j].y);
            if(e[j].y<=e[i].y)q=max(q,e[j].y); 
        }
        ans=max(ans,e[i].x*(r-q)); 
    }//一遍sx
	sort(e+1,e+1+n,cmp2);
	for(int i=1;i<n;i++)
	{
		ans=max(ans,(e[i].y-e[i+1].y)*l);
	}
	ans=max(ans,(w-e[1].y)*l);
	ans=max(ans,e[n].y*l);//以上的可以有简化自己想想
	cout<<ans;//AC OK
}

```

---

## 作者：EternalEpic (赞：6)

这是一道经典好题，相信大家是为了做最大子矩形系列题而来的吧。

如果你读过王知昆dalao的论文，相信你一定知道极大子矩形和最大子矩形的定义概念。

本题由于数据原因，不适合悬线法解决问题，而是用枚举障碍边界的方式来求的。

其实就是横竖各扫一遍，以枚举x坐标为例。

将节点排序（按照x坐标从大致小），枚举矩形左边界，再扩展求极大子矩形，统计答案。

枚举y坐标同理，最后将两者答案取最大值即可。

有些人的程序有bug，因为她们没有枚举全部的极大子矩形。如：相邻两个点的纵坐标为上下边界，左右边界与整个矩形的左右边界重合的矩形。

不多废话，上代码。

```cpp
const int Maxn = 6005;
struct Node {
	int x, y;
	Node(int X = 0, int Y = 0) : x(X), y(Y) {}
	inline void Scanner(void) { read(x), read(y); }
} p[6005]; int L, W, n;

inline bool cmpx(const Node&a, const Node&b) { return a.x < b.x; }
inline bool cmpy(const Node&a, const Node&b) { return a.y < b.y; }

signed main(void) {
//	file("");
	read(L), read(W), read(n);
	for (int i = 1; i <= n; i++) p[i].Scanner();
	p[n + 2].y = p[n + 4].y = W;
	p[n + 1].x = p[n + 4].x = L; n += 4;
	sort(p + 1, p + n + 1, cmpx);
	int ans = 0, down, up, v;
	for (int i = 1; i <= n; i++) {
		up = 0, down = W, v = L - p[i].x;
		for (int j = i + 1; j <= n; j++) {
			if (v * (down - up) <= ans) break;
			chkmax(ans, (down - up) * (p[j].x - p[i].x));
			if (p[j].y >= p[i].y) chkmin(down, p[j].y);
			else chkmax(up, p[j].y);
		}
	} sort(p + 1, p + n + 1, cmpy);
	int l = 0, r = L;
	for (int i = 1; i <= n; i++) {
		l = 0, r = L, v = W - p[i].y;
		for (int j = i + 1; j <= n; j++) {
			if (v * (r - l) <= ans) break;
			chkmax(ans, (r - l) * (p[j].y - p[i].y));
			if (p[j].x >= p[i].x) chkmin(r, p[j].x);
			else chkmax(l, p[j].x);
		}
	} writeln(ans);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：Warriorszx (赞：6)

思路前几篇题解都已经讲的非常详细了，也说出了很多特殊情况，然而前两篇题解还是有错的地方了。

一定要特判极大子矩形的边界能不能是大矩形边界的情况

提供一组hack前一篇的题解的数据：

6 4

4

1 2

4 1

4 3

2 1

ans=10

这里的一组数据就用到了极大子矩形是矩形的边界的情况。

```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int L,H,n;
struct node
{
	int x,y;
}a[5010];
inline bool cmp1(node A,node B)
{
	if(A.x!=B.x)
	{
		return A.x<B.x;
	}
	else
	{
		return A.y<B.y;
	}
}
inline bool cmp2(node A,node B)
{
	if(A.y!=B.y)
	{
		return A.y<B.y;
	}
	else
	{
		return A.x<B.x;
	}
}
int main()
{
	scanf("%d%d%d",&L,&H,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	a[++n].x=0,a[n].y=0;
	a[++n].x=0,a[n].y=H;
	a[++n].x=L,a[n].y=0;
	a[++n].x=L,a[n].y=H;
	sort(a+1,a+1+n,cmp1);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int l=0,h=H,maxl=L-a[i].x;
		for(int j=i+1;j<=n;j++)
		{
			if(j==n)//特判右边界
			{
				ans=max(ans,maxl*(h-l));
			}
			else
			{
				if(a[j].y<=h&&a[j].y>=l)
				{
					if(maxl*(h-l)<=ans)
					{
						break;
					}
					ans=max(ans,(a[j].x-a[i].x)*(h-l));
					if(a[j].y==a[i].y)
					{
						break;
					}
					if(a[j].y>a[i].y)
					{
						h=min(h,a[j].y);
					}
					else
					{
						l=max(l,a[j].y);
					}
				}
			}
		}
		l=0,h=H,maxl=a[i].x;
		for(int j=i-1;j>=1;j--)
		{
			if(a[j].y<=h&&a[j].y>=l)
			{
				if(maxl*(h-l)<=ans)
				{
					break;
				}
				ans=max(ans,(a[i].x-a[j].x)*(h-l));
				if(a[j].y==a[i].y)
				{
					break;
				}
				if(a[j].y>a[i].y)
				{
					h=min(h,a[j].y);
				}
				else
				{
					l=max(l,a[j].y);
				}
			}
			if(j==1)//特判左边界
			{
				ans=max(ans,maxl*(h-l));
			}
		}
	}
	sort(a+1,a+1+n,cmp2);
	for(int i=1;i<n;i++)
	{
		ans=max(ans,(a[i+1].y-a[i].y)*L);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：寒冰大大 (赞：5)

原来的题解误导了好多人。
hack数据有一个就是专门针对原来的题解的。


原来题解有两个地方：
```cpp
1 if(q[j].r<=r && q[j].r>=l)

2 if (a[j].y>a[i].y)r=min(r,a[j].y);
            else l=max(l,a[j].y);
```
乍一看是没什么问题

但是
比如这么一组数据

>6 4

>4

>1 2

>4 1

>4 3

>2 1

画图后大概是这个样子
![](https://cdn.luogu.com.cn/upload/pic/75282.png)

然后进行模拟，发现有了if输出9

![](https://cdn.luogu.com.cn/upload/pic/75283.png)

然而实际最大的矩形面积是10

![](https://cdn.luogu.com.cn/upload/pic/75284.png)

就像这张图，(4,3)这个点就被漏了，所以输出了9

因此只需要把这个错误的剪枝删去即可。

这种问题第一篇题解就有。


```cpp
#include<头文件自己想>

using namespace std;

int n,m,s;

struct que{
	int x,y;
}q[10010];

int cmp1(que a,que b)
{
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

int cmp2(que a,que b)
{
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}

int main()
{
	int i,j;
	scanf("%d %d",&n,&m);
	scanf("%d",&s);
	for(i=1;i<=s;i++)
	{
		scanf("%d %d",&q[i].x,&q[i].y);
	}
	q[++s].x=0;
	q[++s].x=n,q[s].y=0;
	q[++s].x=0,q[s].y=m;
	q[++s].x=n,q[s].y=m;
	int ans=0;  //加上四个边界，不用在dp特判边界情况
	sort(q+1,q+s+1,cmp1);//从左到右排序
	for(i=1;i<=s;i++)
	{
		int r=m,l=0,h=n-q[i].x;
		for(j=i+1;j<=s;j++)
		{
				if(h*(r-l)<=ans) break;
				ans=max(ans,(q[j].x-q[i].x)*(r-l));
				if(q[i].y==q[j].y) break;
				if(q[j].y>q[i].y) r=min(r,q[j].y);
				if(q[j].y<q[i].y) l=max(l,q[j].y);
		}
		r=m,l=0,h=q[i].x;
		for(j=i-1;j>=1;j--)
		{
				if(h*(r-l)<=ans) break;
				ans=max(ans,(q[i].x-q[j].x)*(r-l));
				if(q[i].y==q[j].y) break;
				if(q[j].y>q[i].y) r=min(r,q[j].y);
				if(q[j].y<q[i].y) l=max(l,q[j].y);
		}
	}
	sort(q+1,q+s+1,cmp2);  //从右向左在排序，不用向第一个dp那样的原因是已经覆盖了原来左右边界在矩形边上的情况
	for(i=1;i<s;i++) ans=max(ans,(q[i+1].y-q[i].y)*n);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：hs_black (赞：5)

博客食用效果更佳 [hs-black](https://www.luogu.org/blog/hs-black/)
- ## 定义：

**有效子矩形：** 内部（不包含边界）没有障碍点的子矩形（四边均与坐标轴平行）

**极大有效子矩形**：不被任何一个有效子矩形包含（除本身）

**最大有效子矩形**：最大的有效子矩形

- ###   小性质 ： 

### 1. 极大有效子矩形的四条边无法向四边拓展， 也就是说四条边都存在障碍点或与大矩形边界重合

### 2.存在一个障碍点的矩形中最大有效子矩形一定是极大有效子矩形

- 【证明】：若最大有效子矩形不是极大有效子矩形，那么一定存在一个有效子矩形包括它，这与它的最大性相违背

  

- ## 解决问题：

1.思想一：枚举所有的极大有效子矩形

2.思想二：垂线法（见博客）

## 算法一  O($s^2$)：

由思想一我们可以得知，我们要枚举极大有效子矩形，尽量不枚举无效的，不是极大的子矩形

而由性质一得知，极大子矩形边界中必含障碍点

所以我们将所有障碍点按横坐标排序， 枚举障碍点所在纵线（与y轴平行的线）为极大有效子矩形的左边界（关于左边界是矩形边界下文讨论），再从左到右的扫描障碍点，更新答案后再更新上下边界

- 更新答案：ans = max ( (上边界 - 下边界）* 横坐标之差 ， ans）

- 边界初始化：up = 0， down = 矩形纵长

- 更新边界： 如果新点在左边界点的上方，up = min(up,  其纵坐标)；否则 down = max（down， 其纵坐标）；

- ### bug & 改bug ：

bug在于枚举过程中忽略了两类情况，一种是左边界在矩形左边界或右边界在矩形右边界的极大有效子矩形，另一种是左右边界都在矩形边界上（王知昆大佬的分类）。解决方法：将大矩形的四个顶点加入点集，然后横坐标排序跑一遍，纵坐标排序再跑一遍。横坐标跑的时候可以解决右边界问题，纵坐标跑时可以解决剩下问题（就像跑横坐标时可以解决上边界与下边界问题一样）

最后贴一下代码：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N = 6005;
struct node{
	int x, y;
}a[N];
int L, W;
bool cmp1(node i,node j) {
	return i.x < j.x;
}
bool cmp2(node i,node j) {
	return i.y < j.y;
}
int n;
int main() {
	cin >> L >> W >> n;
	for (int i = 1;i <= n; i++) 
	scanf ("%d %d", &a[i].x, &a[i].y);
	a[n+1].y = a[n+1].x = a[n+2].x = a[n+3].y = 0;
	a[n+2].y = a[n+4].y = W;
	a[n+3].x = a[n+4].x = L;
	n += 4; //加入矩形的四个顶点
	sort(a + 1, a + n + 1, cmp1);
	int ans = 0, up, down, v;
	for (int i = 1;i <= n; i++) {
		up = 0, down = W, v = L - a[i].x;
		for (int j = i + 1;j <= n; j++) {
			if (v * (down - up) <= ans) break; //剪枝
			ans = max(ans, (down - up) * (a[j].x - a[i].x));
			if (a[j].y >= a[i].y) down = min(down, a[j].y);
			else up = max(up, a[j].y);
		}
	}
	sort(a + 1, a + n + 1, cmp2);
	int l = 0, r = L;
	for (int i = 1;i <= n; i++) {
		l = 0, r = L, v = W - a[i].y;
		for (int j = i + 1;j <= n; j++) {
			if (v * (r - l) <= ans) break;
			ans = max(ans, (r - l) * (a[j].y - a[i].y));
			if (a[j].x >= a[i].x) r = min(r, a[j].x);
			else l = max(l, a[j].x);
		}
	}
	cout << ans << endl;
	return 0;
}
```



这是王知昆大佬的论文：[浅谈用极大化思想解决最大子矩阵问题](https://blog.csdn.net/clover_hxy/article/details/50532289?locationNum=1&fps=1)


---

## 作者：Piwry (赞：4)

其它的题解都没怎么看懂...于是就自己 yy 了一个做法

## 解析

思考一个极大矩形会满足什么条件

我们可以证明它的每条边上（**不含顶点**）一定有一个障碍点或者这条边和边界重合

因为如果一条边不满足上述条件，我们一定可以移动这条边并获得更大的矩形

并且我们还发现，极大矩形的边上至少有一个障碍点，除非整张图没有障碍点（这个要特判）

于是我们就可以枚举障碍点作为极大矩形边上的点，然后在按坐标排序（具体看枚举的边和哪个坐标轴平行），一点点限制矩形边界，求出当前限制下矩形的最大可能面积再取个 $\text{max}$ 即可。

&nbsp;

具体的实现方式可能各有差异，这里解释一种可能的实现

（下面的 $y$ 坐标即题目输入的 `y`（`W`，宽），$x$ 坐标同）

我们枚举极大矩形的左右边（和 $y$ 轴平行，为什么不枚举上下边见下文）。每次枚举一个点 $A$ 作为极大矩形左/右边时，按 $x$ 坐标排序并从近到远加入 $x$ 坐标大于/小于该点的障碍点；每加入一个点，如果其 $y$ 坐标小于当前点，就上移矩形下边，如果大于就下移矩形上边（为了让 $A$ 仍在矩形边上），如果等于就停止枚举；此时将已枚举障碍点之间最大的 $x$ 坐标差作为矩形底长，上下边 $y$ 坐标差作为高，就是一种可能的答案。

因为这里实现的特性，我直接将边界矩形的四个顶点作为障碍点直接带入算法，但不将这四个点枚举作为初始矩形左/右边上的点（具体见代码），这样就可以不特判极大矩形左右边在边界的情况。根据具体实现可能需要其它的方式处理这个问题

另外，我们最后还要枚举遗漏的极大矩形**左右边都在边界上**的特殊情况。可以想到，设此时极大矩形上边的 $y$ 坐标 $a$，下边的 $y$ 坐标 $b$，肯定没有 $y$ 坐标在 $(a, b)$ 这个区间内的障碍点；否则矩形左右边就不可能都在边界上。这个将障碍点按 $y$ 坐标排序后 $O(n)$ 枚举 $y$ 坐标相邻的障碍点作为高即可

## CODE

对于 $x$ 坐标相同的障碍点需要一些特判，具体见代码以及 [这个](https://www.luogu.com.cn/discuss/show/242023) 帖子

```cpp
#include <cstdio>
#include <algorithm>
using std::max;
using std::min;
using std::sort;

const int MAXN =5000+50;

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int L, W;/*长 宽 ( 列 行 )*/
struct milk{
	int x, y, typ;
}block[MAXN];

bool cmp1(milk A, milk B){
	return A.x < B.x;
}

bool cmp2(milk A, milk B){
	return A.x > B.x;
}

bool cmp3(milk A, milk B){
	return A.y < B.y;
}

inline int abs(int x){ return (x < 0) ? -x : x; }

int main(){
	L =read(), W =read();
	int n =read();
	if(n == 0)
		return printf("%d", L*W) && 0;
	for(int i =0; i < n; ++i)
		block[i].x =read(), block[i].y =read();
	block[n].x =0, block[n].y =0, block[n].typ =1;
	block[n+1].x =L, block[n+1].y =0, block[n+1].typ =1;
	block[n+2].x =0, block[n+2].y =W, block[n+2].typ =1;
	block[n+3].x =L, block[n+3].y =W, block[n+3].typ =1;
	
	int ANS =0;
	/*使得当前障碍点在矩形边界上*/
	for(int k =0; k < 2; ++k){
		if(k == 0)
			sort(block, block+n+4, cmp1);
		else
			sort(block, block+n+4, cmp2);
		for(int i =0; i < n+4; ++i){
			if(block[i].typ == 1)
				continue;
			int up =0, down =W, l =0;
			for(int j =i+1; j < n+4; ++j){
				if(block[j].x == block[i].x)/*注意这里的特判*/
					continue;
				l =abs(block[j].x-block[i].x);
				ANS =max(ANS, (down-up)*l);
				if(block[j].y == block[i].y)
					break;
				if(block[j].y < block[i].y)
					up =max(up, block[j].y);
				else
					down =min(down, block[j].y);
			}
		}
	}
	sort(block, block+n+4, cmp3);
	for(int i =0; i < n+4-1; ++i)
		ANS =max(ANS, (block[i+1].y-block[i].y)*L);
	printf("%d", ANS);
}
```

---

## 作者：Adove (赞：4)

这题有一种思维难度比较小的处理方法

关于那位dalao所提的情况，我们可以从左往右扫一遍，再从上往下扫一遍，这样就能扫到每个贡献最大的矩形了。

另外，对于从上往下扫和基准点同一行，从左往右扫和基准点同一列的，我们直接跳过它们并从后面更新矩形即可。

对于从左往右扫和基准点同一行，从右往左扫和基准点同一列的，我们分类讨论，扫两遍即可。

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=5005;

int L,W,n,ans;
struct rpg{
	int x,y;
}a[MAXN];

bool cmp1(rpg a,rpg b){return a.x==b.x?a.y<b.y:a.x<b.x;}
bool cmp2(rpg a,rpg b){return a.y==b.y?a.x<b.x:a.y<b.y;}

int main()
{
	scanf("%d%d%d",&L,&W,&n);
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i].x,&a[i].y);
	a[n+1]=(rpg){0,0},a[n+2]=(rpg){0,W},a[n+3]=(rpg){L,0},a[n+4]=(rpg){L,W};
	sort(a+1,a+n+5,cmp1);
	for(int i=1;i<=n+4;){
		int le=0,ri=W,cnt=i+1;
		while(a[cnt].x==a[i].x) ++cnt;
		int j=cnt;
		while(j<=n+4){
			ans=max(ans,(a[j].x-a[i].x)*(ri-le));
			if(a[j].y<=a[i].y) le=max(le,a[j].y);
			else if(a[j].y>a[i].y) ri=min(ri,a[j].y);
			++j;
		}j=cnt;le=0,ri=W;
		while(j<=n+4){
			ans=max(ans,(a[j].x-a[i].x)*(ri-le));
			if(a[j].y<a[i].y) le=max(le,a[j].y);
			else if(a[j].y>=a[i].y) ri=min(ri,a[j].y);
			++j;
		}i=cnt;
	}sort(a+1,a+n+5,cmp2);
	for(int i=1;i<=n+4;){
		int le=0,ri=L,cnt=i+1;
		while(a[cnt].y==a[i].y) ++cnt;
		int j=cnt;
		while(j<=n+4){
			ans=max(ans,(a[j].y-a[i].y)*(ri-le));
			if(a[j].x<=a[i].x) le=max(le,a[j].x);
			else if(a[j].x>a[i].x) ri=min(ri,a[j].x);
			++j;
		}j=cnt;le=0,ri=L;
		while(j<=n+4){
			ans=max(ans,(a[j].y-a[i].y)*(ri-le));
			if(a[j].x<a[i].x) le=max(le,a[j].x);
			else if(a[j].x>=a[i].x) ri=min(ri,a[j].x);
			++j;
		}i=cnt;
	}printf("%d\n",ans);
	return 0;
}
```

上面这代码是错的，被我自己构造的数据卡了

数据如下

```
IN
10 10
6
1 2
3 2
6 2
2 1
2 3
2 5

STD.OUT
64

MY.OUT
56
```

果然还是只能在约束时跳过第一关键字相同的障碍

基准点一定要每个点都跑一遍啊QwQ

真·标程：

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=5005;

int L,W,n,ans;
struct rpg{
	int x,y;
}a[MAXN];

bool cmp1(rpg a,rpg b){return a.x==b.x?a.y<b.y:a.x<b.x;}
bool cmp2(rpg a,rpg b){return a.y==b.y?a.x<b.x:a.y<b.y;}

int main()
{
	scanf("%d%d%d",&L,&W,&n);
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i].x,&a[i].y);
	a[n+1]=(rpg){0,0},a[n+2]=(rpg){0,W},a[n+3]=(rpg){L,0},a[n+4]=(rpg){L,W};
	sort(a+1,a+n+5,cmp1);
	for(int i=1;i<=n+4;++i){
		int le=0,ri=W,cnt=i+1;
		while(a[cnt].x==a[i].x) ++cnt;
		int j=cnt;
		while(j<=n+4){
			ans=max(ans,(a[j].x-a[i].x)*(ri-le));
			if(a[j].y<=a[i].y) le=max(le,a[j].y);
			else if(a[j].y>a[i].y) ri=min(ri,a[j].y);
			++j;
		}j=cnt;le=0,ri=W;
		while(j<=n+4){
			ans=max(ans,(a[j].x-a[i].x)*(ri-le));
			if(a[j].y<a[i].y) le=max(le,a[j].y);
			else if(a[j].y>=a[i].y) ri=min(ri,a[j].y);
			++j;
		}
	}sort(a+1,a+n+5,cmp2);
	for(int i=1;i<=n+4;++i){
		int le=0,ri=L,cnt=i+1;
		while(a[cnt].y==a[i].y) ++cnt;
		int j=cnt;
		while(j<=n+4){
			ans=max(ans,(a[j].y-a[i].y)*(ri-le));
			if(a[j].x<=a[i].x) le=max(le,a[j].x);
			else if(a[j].x>a[i].x) ri=min(ri,a[j].x);
			++j;
		}j=cnt;le=0,ri=L;
		while(j<=n+4){
			ans=max(ans,(a[j].y-a[i].y)*(ri-le));
			if(a[j].x<a[i].x) le=max(le,a[j].x);
			else if(a[j].x>=a[i].x) ri=min(ri,a[j].x);
			++j;
		}
	}printf("%d\n",ans);
	return 0;
}
```

---


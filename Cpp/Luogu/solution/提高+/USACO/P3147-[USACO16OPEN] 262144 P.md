# [USACO16OPEN] 262144 P

## 题目描述

贝西喜欢在手机上下载游戏来玩，尽管她确实觉得对于自己巨大的蹄子来说，小小的触摸屏用起来相当笨拙。

她对当前正在玩的这个游戏特别感兴趣。游戏开始时给定一个包含 $N$ 个正整数的序列（$2 \leq N \leq 262,144$），每个数的范围在 $1 \ldots 40$ 之间。在一次操作中，贝西可以选择两个相邻且相等的数，将它们替换为一个比原数大 1 的数（例如，她可以将两个相邻的 7 替换为一个 8）。游戏的目标是最大化最终序列中的最大数值。请帮助贝西获得尽可能高的分数！

## 说明/提示

在示例中，贝西首先合并第二个和第三个 1，得到序列 1 2 2，然后将两个 2 合并为 3。注意，合并前两个 1 并不是最优策略。

## 样例 #1

### 输入

```
4
1
1
1
2```

### 输出

```
3```

# 题解

## 作者：3493441984zz (赞：305)

# 动态规划

其实这题很简单，但是我就是看了题解。。。

这篇题解的思路和其他$dalao$的大同小异，但是这篇主要解释了$58$这个神奇的数字，以及状态转移方程的意思
****
# 状态

我们定义$f[i][j]$,里面存的值是左端点为$j$，能合并出$i$这个数字的右端点的位置

那么状态转移方程如下:

$$f[i][j]=f[i-1][f[i-1][j]]$$

为什么呢？

其实这就有点倍增的味道了，我们首先（没有图，自行脑补或者参考其他人的题解$qwq$）

我们先在脑海中画一个数轴$qwq$

然后最左边的一个点位置为$j$

那么我们可以求出$f[i-1][j]$，也就是从$j$往后一直合并到哪个位置，可以最终合并出$i-1$，这个位置其实就是$f[i-1][j]$

那么我们接下来呢？

我们从这个位置继续向后，看看到哪个位置又能合并出一个$i-1$，那么找到这个点，其实就是$f[i-1][f[i-1][j]]$,我们合并到这里的时候，就会合并出两个相邻的$i-1$，那么不就可以合并出一个$i$了吗？

所以，状态转移就是$$f[i][j]=f[i-1][f[i-1][j]]$$

#### 接下来是美滋滋的代码时间~~~
~~~cpp
#include<iostream>
#include<cstdio>
#define N 61
#define M 270007
using namespace std;
int n,ans;
int f[N][M];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
	{
		int in;
		scanf("%d",&in);
		f[in][i]=i+1;
	}
    for(int i=2;i<=58;++i)//58?????
        for(int j=1;j<=n;++j)
        {
            if(!f[i][j]) 
				f[i][j]=f[i-1][f[i-1][j]];
            if(f[i][j]) 
				ans=i;
        }
    printf("%d",ans);
}
~~~

### 那么上面这个神奇的$58$呢？

其实就跟数据范围有关

我们看到$2≤N≤262144$，而我们像倍增一样合并，那么因为$2^{18}=262144$

而数字的大小在$1-40$之间，那么产生的数最多也就是$40+18=58$啦
****
### 如果有错误，请私信我或者评论留言~~（而我不会看）~~

---

## 作者：曹老师 (赞：38)

**知识点：DP**

**状态转移方程：f[i][j]=f[i-1][f[i-1][j]]**

**f[i][j]表示以j为左端点合并出i时的右端点**

(好难推的~~至少我认为是酱~~ 于是我还是画图来说吧

![](https://i.loli.net/2018/06/09/5b1b9dff4eb78.png)

画出图来大概就明白了 ~~我逃了~~

（哦对了 58可以根据数据范围求出

**时间复杂度：O(58n)**

```pascal
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<set>
#define MAXN 100005
#define LL long long
#define INF 2147483647
#define MOD 1000000007
#define free(s) freopen("s.txt","r",stdin);
#define lowbit(x) ((x&(-x))) 
#define debug(x) cout<<x<<endl;
using namespace std;
const int L=1005;
int n,f[60][262145],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int t;
		scanf("%d",&t);
		f[t][i]=i+1;
	}
	for(int i=2;i<=58;i++)
		for(int j=1;j<=n;j++)
		{
			if(!f[i][j])
				f[i][j]=f[i-1][f[i-1][j]];
			if(f[i][j])
				ans=i;
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Orion_Rigel (赞：22)

这道题其实十分有趣。

f[i][j]表示从j开始合并到i这个数字序列的末尾的下表是什么。

那么因为合并的总是一段连续的区间，就有f[i][j]=f[i-1][f[i-1][j]];

第一次数组开反了WA了三次。

···
```cpp
#include <cstdio>
#define max(a,b) a>b?a:b
int x,n,ans=0;
int f[60][270000];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
        scanf("%d",&x),f[x][i]=i+1;
    for (int i=2;i<=58;++i)
        for (int j=1;j<=n;++j)
        {
            if (!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
            if (f[i][j]) ans=i;
        }
    printf("%d\n",ans);
}
···
```

---

## 作者：Push_Y (赞：19)

 _这道题是智能推荐给推的_ 
 
如果你是通过找 _区间dp_ 标签找到这道题的话，你可能一时想不出方法。

官方题单里的区间dp题基本是在区间[i,j]里枚举中间点k。


------------

接下来我通过dp的基本策略来讲下。

### 表示所求值

目标是使得最大的数最大，我先想到转化成求最多能连续合并多少个。那转化后的这个问题就和官方题单里的常规区间dp题非常像了。但是，如果初始一个数非常大，但是没有经历一次合并，这个转化就马上出了问题。再多想一步，如何结合两者呢？

由于刚复习完LCA，我联想到了倍增。用 $f[i][j]$ 表示以 $i$ 为左端点，合并出 $j$ 的数字的右端点。怎么理解呢？把这个 $f$ 数组看成线段或者说是区间， $f[i][j]=0$ 的时候就代表了不存在这样的一个区间。如果存在这个区间，那这个 $j$ 就是一个得到的数，最终的答案就是最大的 $j$。

tip:之所以这个讲这么久，是因为看到大部分题解里就用一句话带过了，我个人感觉这个是有思考含量的。

### 状态转移方程

~~这题也可以选择dfs，不过我觉得这题用dfs不大方便~~

$f[i][j]=f[f[i][j-1]][j-1]$

利用了倍增思想，$2^j={s^{j-1}}^{j-1}$

### 关于58

其他题解讲的很透彻，我不再做重复。~~其实挺好想的~~。

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){//快读
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=270000;
int n,ans=0,f[N][60];

int main(){
	n=gin();
	for(int i=1;i<=n;i++){
		int x=gin();
		f[i][x]=i+1;//预处理
	}
	for(int j=2;j<=58;j++)
		for(int i=1;i<=n;i++){
			if(!f[i][j])//如果没有，我们让它有
				f[i][j]=f[f[i][j-1]][j-1];//状态转移
			if(f[i][j])ans=j;//最终答案，由于j是递增的，所以直接赋值j
		}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：Cripple_Abyss (赞：16)

- [题目传送门](https://www.luogu.com.cn/problem/P3147)

本题与[这道题](https://www.luogu.com.cn/problem/P3146)做法类似，可以说是双倍经验QwQ

为什么这两题一个是绿题，而另一个是蓝题？

## 言归正传
这题其实是一道**区间DP**的题目

$DP$三步法：

1. 状态定义：$f[i][j]$表示以$j$为起点，能合成数$i$的区间长度



1. 状态转移方程：$f[i][j]=f[i-1][f[i-1][j]]$

1. 状态初值：$f[t][i]=i+1$， $ t$ 为输入的数.


## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[65][300005],t,n,ans;
int main() {
	cin>>n;
	for (int i=1; i<=n; i++) {
		cin>>t;
		f[t][i]=i+1;
	}
	for (int i=2; i<=58; i++) //202144=2^18 题目明确最大范围是40 40+18=58
		for (int j=1; j<=n; j++) {
			if (!f[i][j])
				f[i][j]=f[i-1][f[i-1][j]];
			if (f[i][j])
				ans=i;
		}
	cout<<ans;
	return 0;
}
```


都看到这了，点个赞呗QwQ

---

## 作者：DOFY (赞：15)

只有我是鬼畜的分治做法吗。。。

先形象的理解，假如某一个很小的数孤零零的在那里，它阻断了左右两边的合并，导致问题可以被分治解决

考虑从小的数字往大的数字合并，若有一2\*k长度的相同数字块，我们可以直接将数字加一而长度变为k，若有一2\*k+1长度的，则必定会阻断左右，则要分合并后的k个分给左边和右边两种情况讨论。

solve(l,r,b)表示把l到r的中的b元素全部合并所能的到的最大值。用双向链表维护上述数字块的前后关系，每合并一种数字b会导致一些块被阻断（奇数个时），分治即可。注意当奇数个且大于1时，要有两个节点（都表示k个）（就再新建一个），来分给两个子问题。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=270000;
int n,pre[maxn],suc[maxn];
struct node
{
    int t,num;
}a[maxn];
void update(int l,int r)
{
    for(int i=l;i<=r;i=suc[i])
    {
        if(i!=l&&a[pre[i]].t==a[i].t) 
                    {
                        a[pre[i]].num+=a[i].num;
                        suc[pre[i]]=suc[i];
                        pre[suc[i]]=pre[i];
                    }
    }
}
int solve(int l,int r,int b)
{
    if(l>r||b>60) return 0;
    update(l,r);
    int last=l,re=0,minb=(maxn<<1);
    for(int i=l;i<=r;i=suc[i])
    {
        re=max(re,a[i].t);
        if(a[i].t==b) 
            {
                if(a[i].num==1)
                {
                    re=max(re,solve(last,pre[i],minb));minb=(maxn<<1);
                    last=suc[i];
                    continue;
                }
                int pd=(a[i].num&1);
                a[i].t++;a[i].num>>=1;minb=b+1;
                if(pd)
                {
                    int tmp=a[i].num;
                    suc[i+tmp]=suc[i];pre[i+tmp]=i;
                    suc[i]=i+tmp;pre[suc[i+tmp]]=i+tmp;
                    a[i+tmp]=a[i];
                    re=max(re,solve(last,i,minb));minb=(maxn<<1);
                    last=i+tmp;
                }
            }
            else minb=min(minb,a[i].t);
    }
    
    if(re<b) return re;
    re=max(re,solve(last,r,minb));
    return re;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i].t);
        a[i].num=1;
        suc[i]=i+1;
        pre[i]=i-1;
    }
    printf("%d",solve(1,n,1));
    return 0;
}
```

---

## 作者：Mr_Squre (赞：7)

这道题目的弱化版是允许有n^3的时间复杂度，那么也就是f[i][j]表示i-j这个区间合并完了之后的值是多少。容易发现，一个区间的值合并完了之后应该是一定的。因为对于i-j这个区间，如果它既可以合并成n,又可以合并成n+1。那样的话考虑最后合并的两个区间i~l1,l1+1~j和i~l2,l2+1,j。对于有重叠的两个部分（假设是i~l1与i~l2且l1<l2）那样的话必然有i~l1的值为n-1，同时l1+`~j的值也为n-1,但是l2+1~n的值为n,并且l2>l1，也就是说在一个总值为n-1的区间里面包含一个总值为n的区间，那么显然是不合法的。因为在合并的时候，要保证整个区间全都可以合并完成，那么合并的策略应该是大致相同的（意思是a[i]与a[i]合并），不应该出现不同解。然后枚举中间点进行区间dp就好了。

考虑数据范围到达1e5.从上面的性质出发，发现整体合并为i的区间最多有n个（因为区间没有包含的关系），那么就可以排序之后暴力的做一下合并，看一看那两个可以合成i+1.注意到合并过程中右端点单调，所以可以使用单调队列优化。最坏时间复杂度nlog^2n


    
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<cstdio>
#define LL long long 
const int N=5e4+9;
const LL inf=1e9+13;
using namespace std;
struct node{
    LL x,y;
}point[N];
LL n,minn1[N],maxx1[N],minn2[N],maxx2[N],ans;
int cmp1(node a,node b)
{
    return a.x<b.x;
}
int cmp2(node a,node b)
{
    return a.y<b.y;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        point[i].x=x;point[i].y=y;
//cout<<x<<"----------------"<<y<<endl;
    }
    sort(point+1,point+n+1,cmp1);
    minn1[0]=inf;maxx1[0]=-inf;
    for(int i=1;i<=n;++i)
    {
        minn1[i]=min(minn1[i-1],point[i].y);
        maxx1[i]=max(maxx1[i-1],point[i].y);
    }
    minn2[n+1]=inf;maxx2[n+1]=-inf;
    for(int i=n;i>=1;--i)
    {
        minn2[i]=min(minn2[i+1],point[i].y);
        maxx2[i]=max(maxx2[i+1],point[i].y);
    }
//for(int i=1;i<=n;++i)
 //printf("i:%d maxx1:%lld minn1:%lld maxx2:%lld minn2:%lld\n",i,maxx1[i],minn1[i],maxx2[i],minn2[i]);
    ans=(maxx2[1]-minn2[1])*(point[n].x-point[1].x);
//cout<<"ans:----"<<ans<<endl;
    for(int i=1;i<n;++i)        
    {
      ans=min(ans,(point[i].x-point[1].x)*(maxx1[i]-minn1[i])+(point[n].x-point[i+1].x)*(maxx2[i+1]-minn2[i+1]));
 //     if(i==3)
 //      printf("%lld %lld\n",(maxx1[i]-minn1[i]),(maxx2[i]-minn2[i]));
//cout<<"ans:----"<<ans<<endl;   
    }
    sort(point+1,point+n+1,cmp2);
    minn1[0]=inf;maxx1[0]=-inf;
    for(int i=1;i<=n;++i)
    {
        minn1[i]=min(minn1[i-1],point[i].x);
        maxx1[i]=max(maxx1[i-1],point[i].x);
    }
    minn2[n+1]=inf;maxx2[n+1]=-inf;
    for(int i=n;i>=1;--i)
    {
        minn2[i]=min(minn2[i+1],point[i].x);
        maxx2[i]=max(maxx2[i+1],point[i].x);
    }
    for(int i=1;i<n;++i)        
     ans=min(ans,(point[i].y-point[1].y)*(maxx1[i]-minn1[i])+(point[n].y-point[i+1].y)*(maxx2[i+1]-minn2[i+1]));  
 //   cout<<(maxx1[n]-minn1[n])*(point[n].y-point[1].y)<<endl;  
    cout<<(maxx1[n]-minn1[n])*(point[n].y-point[1].y)-ans<<endl;
    return 0;
}

```

---

## 作者：RikoHere (赞：6)

区间DP，题目十分类似2048的游戏，不过从二维的平面换成了数列

数据范围中 $N <= 2*10^5$

看来$O(N^2)$肯定是无法通过了，那么设计状态N只能添加到一维上
应该是类似于$O(NlogN)$的算法

再观察题目，可以提取三个关键变量，对于某个能合并成一个数的数列中的区间，有它的左边界，右边界和合成的数三个关键变量

那么设计状态就可以设$f(i,k)$表示右边界，以$i$为左边界，$k$为合成的数易得到$f(i,k+1)=f(f(i,k)+1,k)$

枚举$k$直到最大值就完事了，$k < 40+logN$ 设置一个常数为边界

注意一下特殊处理，如果不能合成任何数大于原数列最大值，那么输出原数列最大值，而非合成数的最大值


```
//2019/7/14->Riko->AtNCU->luogu3147
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long

bool digit (int x) { return (x <= '9' and x >= '0');}
int in () {
    int x = 0, ch = getchar();
    while (!digit(ch)) ch = getchar();
    while (digit(ch)) x = x*10+ch-'0', ch = getchar();
    return x;
}
void smax (int& x, int y) { if (x < y) x = y;}
void print (int x) { printf("debug:%d\n", x);}

const int TOP = 303000;
int n, ans;
int f[TOP][64], k[TOP];

void work () {
    for (int num = 1; num <= 64; ++num) {
        for (int i = 1; i < n; ++i) {
            //printf("i:%d num:%d f[i][num]:%d\n", i, num, f[i][num]);
            if (f[i][num] and f[f[i][num]+1][num]) {
                f[i][num+1] = f[f[i][num]+1][num];
                smax(ans, num+1);
            }
        }
    }
    printf("%d", ans);
}
void prepare () {
    n = in();
    for (int i = 1; i <= n; ++i) {
        k[i] = in();
        smax(ans, k[i]);
        f[i][k[i]] = i;
    }
} int main () { prepare(); work();}
```



---

## 作者：元夕 (赞：4)

## 一道很妙的dp。
状态量 : $f[i][j]$, 意思是以$j$为左端点的合并为$i$的右端点的右边一个的位置

则本题转化为求解:$i$最大且$f[i][j]$有值.

考虑dp方程，当	
	
$$f[i][j]!=false, f[i][f[i][j]]!=false$$

则
    
$$f[i + 1][j] != false$$ 
并且可以求出值。
进一步地， 

$$f[i][j = f[i - 1][f[i - 1][j]]$$

也可通过上面一步的过程得到。

最后，来讲讲58.

58， 是最极端的情况， 262144 个 40 和起来也不过是 58. 

~~所以我用了60~~

## 激动人心的cpp时间！
```cpp
#include <bits/stdc++.h>
const int maxn = 65;
const int maxm = 262150;
using namespace std;
int f[maxn][maxm], n, ans;
int main () {
	ios :: sync_with_stdio(false); 
	cin >> n;
	for(int i = 1, t;i <= n;i ++) 	
	{
		cin >> t;
		f[t][i] = i + 1;
	}
	for(int i = 1;i <= 60;i ++) 
	{
		for(int j = 1;j <= n;j ++) 
		{
			if(f[i][j] == 0) 
				f[i][j] = f[i - 1][f[i - 1][j]];
			if(f[i][j]) 
				ans = i;
		} 
	}
	cout << ans << endl;
	return 0;
} 
```

---

## 作者：k1saki (赞：4)

从[这题](https://www.luogu.org/problem/P3146)来的（~~双倍经验~~）  
那题范围只到248，只需要dp[i][j]表示i~j能凑出的最大数字即可  
但这题的范围2^18，很显然不可能过  
考虑dp[i][j]表示i开始，凑出j需要达到的位置  
若dp[i][j]和dp[dp[i][j]+1][j]都合法  
则dp[i][j+1]=dp[dp[i][j]+1][j]

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int maxn,dp[262145][65],n,a[262145];//dp[i][j] i第i位开始 j合成出j 所到的位置（闭区间）
int main()
{
	cin>>n;
	int INF=2147483647;
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		dp[i][a[i]]=i;
	}
	for (int j=1;j<=58;j++)//40+log2(262144)=58
	for (int i=1;i<=n;i++)
	{
		if (dp[i][j]==0) continue;
		maxn=j;
		if (dp[i][j]==n) continue;//已经到头则说明无法继续转移
		if (dp[dp[i][j]+1][j]==0) continue;
		dp[i][j+1]=dp[dp[i][j]+1][j];
		//cout<<i<<' '<<j<<endl;
	}
	cout<<maxn;
}
```

---

## 作者：大菜鸡fks (赞：4)

有趣的题目。。一开始思维被限制了。。觉得是区间dp。然而复杂度不太对。

f[i][j]表示以j为左端点合成i，右端点的位置。

f[i][j]=f[i-1][f[i-1][j]];

```cpp
#include<cstdio>
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=270005;
int n,f[60][N];
inline void init(){
	n=read();
	for (int i=1;i<=n;i++){
		int x=read();
		f[x][i]=i+1;
	}
}
int ans;
inline void solve(){
	for (int i=1;i<=58;i++){
		for (int j=1;j<=n;j++){
			if (!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
			if (f[i][j]) ans=i;
		}
	}
	printf("%d\n",ans);
}
int main(){
	init();
	solve();
	return 0;
} 
```

---

## 作者：Jiang_zi_chuan (赞：3)

# 解题思路

比较巧妙的dp，f[i][j]表示到了第j位，合成了i，此时的右端点 。初值f[a[i]][i] = i + 1，转移方程f[i][j] = f[i - 1][f[i - 1][j]] 

上代码：

```cpp
// luogu-judger-enable-o2
//#define LOCAL
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <bits/stdc++.h>

#define INF 0x3f
#define ull unsigned long long
#define ll long long
#define FOR(a, b, n) for(register int a = b; b >= n ? a >= n : a <= n; b >= n ? a-- : a++)
#define M(a, n) memset(a, n, sizeof(a));
#define S(n) scanf("%d", &n)
#define P(n) printf("%d", n)
#define G(n) getline(cin, n)
#define PI acos(-1.0)

using namespace std;

const int NR = 85;
const int MR = 262150;

const int MAXN = 262150; 
inline int read() { 
	int x = 0, f = 1;
	char ch = getchar(); 
	while(!isdigit(ch)) {
		f = ch == '-' ? - 1 : 1;
		ch = getchar();
	} 
	while(isdigit(ch)) {
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	} 
	return x * f; 
} 
int n, f[NR][MR], ans; //f[i][j]表示到了第j位，合成了i，此时的右端点 
int main() { 
	n = read(); 
	FOR(i, 1, n) {
		f[read()][i] = i + 1; 
	}
	FOR(i, 1, 60) {
		FOR(j, 1, n) { 
			if(!f[i][j]) f[i][j] = f[i - 1][f[i - 1][j]]; 
			if(f[i][j]) ans = i; 
		}
	}
	P(ans); 
	return 0; 
}
```

---

## 作者：Doveqise (赞：2)

这道题emmm是这道题→[P3146 [USACO16OPEN]248](https://www.luogu.org/problemnew/show/P3146)数据加强版emmm  
在这里主要介绍一下别人不太注意的数据范围问题...
我们注意到题中说2≤N≤262 144，那么这个262 144是多少呢？  
266 144=$2^{18}$,所以我们循环时就循环到40+18=58就好。  
细节见代码↓（不想用58系列）
```c++
#include<bits/stdc++.h>
using namespace std;
int f[60][262144+5],ans;
int main(){
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++){int t;scanf("%d",&t);f[t][i]=i+1;}
    for(int i=2;i<=60;i++) for(int j=1;j<=n;j++){
		if(!f[i][j]) f[i][j]=f[i-1][f[i-1][j]];
        if(f[i][j]) ans=i;}
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Shiloh (赞：1)

之前的题解都说的很清楚了，这里给出一种只用一个if语句的方法。
```cpp
#include<iostream>
using namespace std;

signed main(void)
{
    register int n, ans, in, f[61][270005];
    cin >> n;
    for(register int i = 1; i <= n; ++i)
    {
        cin >> in;
        f[in][i] = i + 1;
    }
    for(register int i = 2; i <= 58; ++i)
    {
        for(register int j = 1; j <= n; ++j)
        {
            if(!f[i][j] 
               && (f[i][j] = f[i-1][f[i-1][j]]) 
               && f[i][j]) //从左至右的短路求值是关键。
            {
                ans = i;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```


---


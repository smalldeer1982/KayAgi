# [USACO21FEB] Stone Game G

## 题目描述

Bessie 和 Elsie 正在用 $N$（$1\le N\le 10^5$）堆石子进行一个游戏，其中对于每个 $1\le i\le N$，第 $i$ 堆石子有 $a_i$ 个石子（$1\le a_i\le 10^6$）。两头奶牛交替行动，Bessie 先手。

 - 首先，Bessie 选择某个正整数 $s_1$ 并从至少包含 $s_1$ 个石子的某堆石子中取走 $s_1$ 个石子。
 - 然后 Elsie 选择某个正整数 $s_2$，使得 $s_1$ 整除 $s_2$，并从至少包含 $s_2$ 个石子的某堆石子中取走 $s_2$ 个石子。
 - 然后 Bessie 选择某个正整数 $s_3$，使得 $s_2$ 整除 $s_3$，并从至少包含 $s_3$ 个石子的某堆石子中取走 $s_3$ 个石子，以此类推。
 - 总的来说，第 $i$ 回合中取走的石子数量 $s_i$ 必须整除 $s_{i+1}$。

第一个无法在其回合中取走石子的奶牛为失败者。

计算可以令 Bessie 必胜（表示存在一种策略，无论 Elsie 如何行动，Bessie 均可获胜）的第一回合取石子的方法数。如果两种取石子的方法中取的石子数量不同或者取的石子堆不同，则认为是两种不同的取石子的方法。



## 说明/提示

#### 样例 1 解释：

当 Bessie 从唯一的一堆石子中取走 $4$、$5$、$6$ 或 $7$ 个石子时可以获胜。此时游戏会立刻结束。

#### 样例 2 解释：

当 Bessie 从任意一堆中取走 $2$ 或 $3$ 个石子时可以获胜。此后两头奶牛会交替取走相同数量的石子，而 Bessie 执行了最后一次操作。

#### 测试点性质：

 - 对于另外 $15\%$ 的数据，满足 $N=2$。
 - 对于另外 $25\%$ 的数据，满足 $N,a_i\le 100$。
 - 对于另外 $50\%$ 的数据，没有额外限制。

供题：Benjamin Qi

## 样例 #1

### 输入

```
1
7```

### 输出

```
4```

## 样例 #2

### 输入

```
6
3 2 3 2 3 1```

### 输出

```
8```

# 题解

## 作者：Meronri_Deng (赞：26)

由题意， $s_{i+1}$ 是$s_i$的倍数。  
枚举 $s_1$，假设每次都取走 $s_1$ 个石子，则第 $i$ 堆需要取 $\lfloor \frac{a_i}{s_1}\rfloor$ 次。  
设数组 $A=\lbrace2,4,6,8,10\rbrace$,$s_1=3$, 则所需操作次数集合$S=\lbrace0,1,2,2,3\rbrace$。
Bessie的第一回合操作，意味着在集合$B$中选择一个元素 $x$，使 $x$ 变为$x-1$。  
第$i$回合的操作，设 $s_i=k\ast s_1$ ，意味着在集合$B$中选择一个元素 $x$ ，使 $x$ 变为 $x-k$ ，同时忽略小于 $k$ 的元素 $x$  。  
若第$i$回合后，$\forall x \in S,x<k$，即下一回合的牛无法取石子，则当前取石子的牛获胜。  

---
Q:在什么条件下必胜？  
若操作完之后，任意元素 $x$ 均出现偶数次，则之后重复另一位玩家的操作即可。  

Q:要在第一回合使任意元素 $x$ 均出现偶数次，有什么条件？要如何操作？ 

- 若操作前任意元素 $x$ 均出现偶数次，则该次操作必然会导致存在某个元素$x$出现奇数次，此时 Bessie 先手必败。

- 若操作前有 $1$ 个元素 $x_1$ 出现奇数次，
	- 如果 $x_1>1$ ，
    	- 对 $x_1$ 进行操作会导致 $x_1-1$ 出现奇数次,此时 Bessie 先手必败；
      - 对 $x_1$ 以外的元素 $x$ 操作，导致 $x$ 出现奇数次,此时 Bessie 先手必败；
   - 如果 $x_1=1$ ，对 $x_1$ 操作，满足条件,此时 Bessie 先手必胜。
- 若操作前有 $2$ 个元素 $x_1,x_2$ 出现奇数次，设 $x_1<x_2$ ，
	- 如果 $x_1=x_2-1$ ,则对 $x_2$ 操作后, $x_1,x_2$均出现偶数次，此时 Bessie 先手必胜。
   - 如果 $x_1<x_2-1$ ,则对 $x_2/x_1$ 操作后, $x_1/x_2$出现奇数次，此时 Bessie 先手必败。
- 若操作前有 $M(M>2)$ 个元素出现奇数次，则无论怎么操作，都无法使所有元素均出现偶数次，此时 Bessie 先手必败。

---

Q:请问 Elsie 的后手必胜策略是怎样的？  
找到集合 $S$ 中最大的出现奇数次的元素 $x$ ，并把它变成 $0$ ，之后任意元素均出现偶数次。

Q:如何算出集合$S$中每个元素的出现次数？$O(\max(a_i)^2)$ 的时间复杂度显然不现实。
可以用前缀和维护。  
$sum_i$ 表示数组 $A$ 中有多少元素 $A_j$ 满足$1 \leq A_j\leq i$。  
想要求出 $s_1$ 对应的集合 $S$ 中 $x$ 元素出现的次数$t$，
借助前缀和即可。  
需取 $x$ 次的石子堆中，至少包含 $x \ast s_1$ 个石子,至多包含 $(x+1) \ast s_1-1$个石子。  
$t=sum_{(x+1) \ast s_1-1}-sum_{x \ast s_1-1}$。  

---

感谢阅读！

---

## 作者：pzc2004 (赞：10)

# 题目分析
题目要我们求的就是采取多少种操作使得当前局面是后手必胜的，所以我们应该思考一下满足何种性质的局面是后手必胜的。  
不难发现，如果一种局面，每种数字都出现了偶数次，那么当前局面一定是后手必胜的。因为后手只需要在先手操作完后对数目相同的另一个数做同样的操作，就一定能保证到最后是后手取走最后一颗石子。  
那如果存在数字，他的出现次数是奇数呢？我们可以把从大到小找到第一个出现次数是奇数的数字，然后取光当前数字，则当前数字的出现次数会变为偶数，同时以后所有小于该数的数都无法取了（因为以后取数时一定要被当前取走的数整除）。可以发现这时就成了后手必胜，所以取石子之前的局面是一个先手必胜。  
由此我们可以得出结论：如果所有数都出现了偶数次，则当前局面为后手必胜，否则为先手必胜。  
然后就好做了，我们直接枚举第一次要取的数，计算一下就好了（具体见代码），复杂度 $O(\frac{M}{1}+\frac{M}{2}+\cdots+\frac{M}{M})=O(M\ln{M})$（$M$ 为值域）。
# 代码：
``` cpp
#include <bits/stdc++.h>
using namespace std;
template <class T> inline void read(T &x) {
	x= 0;
	char c= getchar();
	while(!isdigit(c)) c= getchar();
	while(isdigit(c)) x= x * 10 + (c & 15), c= getchar();
}
#define N 100005
#define M 1000005
int n, a[N], cnt[M], sum[M], m, b[M];
long long ans;
signed main() {
	read(n);
	for(int i= 1; i <= n; i++) read(a[i]), ++cnt[a[i]], m= max(m, a[i]);
	for(int i= 1; i <= m; i++) sum[i]= sum[i - 1] + cnt[i];
	for(int i= 1; i <= m; i++) {
		int tot= m / i;
		for(int j= 1; j <= tot; j++) b[j]= sum[min((j + 1) * i - 1, m)] - sum[j * i - 1];
		int bb= 0;
		for(int j= 1; j <= tot; j++) bb+= b[j] & 1;
		if(bb > 2 || bb == 0) continue;
		if(bb == 1) {
			if(b[1] & 1) ans+= b[1];
		} else if(bb == 2) {
			for(int j= 2; j <= tot; j++)
				if((b[j] & 1) && (b[j - 1] & 1)) ans+= b[j];
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：ycw123 (赞：9)

## 理论分析：

>第 $i$ 回合中取走的石子数量 $s_i$ 必须整除 $s_{i+1}$。

即 $s_{i+1}$ 是 $s_i$ 的倍数。

枚举 $s_1$，假设每次都只取 $s_1$ 个石子，则第 $i$ 堆需要取 $\lfloor \frac{a_i}{s_1}\rfloor$ 次。

这是一道博弈论的题，所以我们先要考虑满足何种性质是后手必胜态，这样就可以将问题转化为：

>给定原始序列，求进行一次操作后使序列转化为后手必胜态的方案数

不难发现，如果序列中，每种数字都出现了偶数次，一定后手必胜。

因为后手只需要在先手操作完后对数目相同的另一个数做同样的操作，就一定能保证到最后是后手取走最后一颗石子。这样我们就有了初步的后手必胜态。

但我们很容易找出一组数据不满足上述性质，同时也能使后手必胜：$s_1=2,A=\{2,3,4,4,6,6\}$。

对于 ‘4’和‘6’，我们采取刚刚的后手必胜态。

对于‘2’和‘3’，当先手取‘2’时，后手取‘3’，此时‘3’变为‘1’，因为‘1’是取不到的，所以后手胜。反之先手取‘3’也是一样的道理。因此后手必胜。

为什么‘2’和‘3’可以组成一对呢？这是因为他们的可取次数（$\lfloor \frac{a_i}{s_1}\rfloor$）相同，我们用一个集合来表示每个数的可取次数：$cnt=\{1,1,2,2,3,3\}$。

显然，可取次数相同的可以组成一对，所以我们的后手必胜态就可以更新为：

>每种可取次数均出现偶数次

我们定义一个数组 $X$。

$X_i$ 表示可取次数为 $i$ 的堆数。

当满足

$$\sum_{i=1}^{tot} X_i \% 2=0 \text{（tot表示最大的可取次数）}$$

时，后手必胜。

成功找出后手必胜态后，我们考虑如何进行一次操作，使序列转化为后手必胜态。

第一回合操作，意味着在集合 $cnt$ 中选择一个元素 $p$，使 $p$ 变为 $p-1$。同时 `X[p]++,X[p-1]--`。

也就是说，第一回合的操作只对相邻两个 $X$ 产生影响，那么当有三种及以上可取次数出现奇数次时，我们一定无法保证一次操作后 $\sum_{i=1}^{tot} X_i \% 2=0$。

当有一种可取次数 $X_i$ 出现奇数次时：

- 如果 $X_i>1$ 

  - 对 $X_i$ 操作会使 $X_{i-1}$ 出现奇数次，先手必败。
  - 对除 $X_i$ 以外的数 $X_j$ 操作会使 $X_j$ 出现奇数次，先手必败。
- 如果 $X_i=1$。对 $X_i$ 操作满足条件，先手必胜方案数为 $X_1$。

当有两种可取次数 $X_i$ 出现奇数次时，当且仅当两种可取次数相邻时有解，若 $X_{p} \% 2=1$，且 $X_{p-1} \% 2=1$，则方案数是 $X_p$。

理论有了，如何实现？

## 实现方法

对于每一个 $s_1$ 显然我们不能枚举出它的 $cnt$ 集合，那样的时间复杂度是无法通过本题的。

我们考虑如何快速求出 $X$ 。

当一堆石子的个数 $a_i \in [q \cdot s_1,(q+1) \cdot s_1 )$ 时，这堆石子的可取次数一定为 $q$。

有了这个结论，我们就可以用前缀和的方法预处理出石子数小于等于 $i$ 的堆数。

这样，我们就有`x[j]=sum[min((j+1)*i-1,m)]-sum[j*i-1];`

至此，我们就能写出解决此题的完整代码啦。

### Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[100010];
ll sum[1000010],x[1000010],ans;
//a原始序列 
//sum[i] 表示石子数小于等于i的堆数 
//x[i] 表示可取次数为i的堆数 
int m=0;//最大一堆的石子个数 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[a[i]]++;
		m=max(m,a[i]);
	}
	for(int i=1;i<=m;i++) sum[i]+=sum[i-1];
		
	for(int i=1;i<=m;i++){
		int tot=m/i;//当 s1=i 时，最大的所需操作次数 
		ll cnt=0;
		
		for(int j=1;j<=tot;j++){
			x[j]=sum[min((j+1)*i-1,m)]-sum[j*i-1];
		}
		for(int j=1;j<=tot;j++) cnt+=x[j]%2;
		
		if(cnt>2||cnt==0) continue;
		if(cnt==1) {
			if(x[1]%2) ans+=x[1];
		} else if(cnt==2) {
			for(int j=2;j<=tot;j++)
				if((x[j]%2)&&(x[j-1]%2)) ans+=x[j];
		}
	}
	cout<<ans;
} 
```

---

## 作者：DengDuck (赞：7)

自我认为这题的结论是挺难想的。

首先需要转化，每选择一个 $s_i$，都要把所有的石子堆变成 $x\gets \lfloor \frac x {s_i}\rfloor$。

我们发现每种数字都出现偶数次时先手必败，因为后手完全可以模仿先手的行为，你咋走我就咋走，然后依然是每种数字都出现偶数次，知道先手啥也干不了。

反之先手必胜，先手可以选择最大的出现奇数次的，将其选完，可以变成先手必败的情况（更小的石子堆已经无法选择了）。

不过我们是求先手胜的方案数。

收到启发，我们可以快速判断一种选择的胜负，我们可以考虑枚举 $s_i$，然后统计转换后每种石子的数量。

接下来我们分类讨论：

- 如果没有数字数量是奇数，你输了。
- 如果有一个数字数量是奇数，这个数字是 $1$，可以消掉，把它全选就是唯一方案。
- 如果有一个数字数量是奇数，这个数字不是 $1$，不可以消掉，你操作会在产生一个奇数数量的，无解。
- 如果有两个数字数量是奇数，这两个数字相邻，可以消掉，把它俩选了就是唯一方案。
- 如果有两个数字数量是奇数，这两个数字不相邻，不可以消掉，无解。
- 一次操作显然只能影响相邻的两个数字，如果奇数数量数字数量超过 $2$，必定无解。

统计答案即可，就是你根据上面的讨论你是知道你该选啥的，你把这个数字的数量加答案里就行了。

时间复杂度是调和级数的 $\mathcal O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=2e6+5;
LL n,a[N],mx,b[N],sum[N],ans;
int main()
{
	scanf("%lld",&n);
	for(LL i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		sum[a[i]]++;
		mx=max(mx,a[i]);
	}
	for(int i=1;i<=mx;i++)
	{
		sum[i]+=sum[i-1];
	}
	for(int i=1;i<=mx;i++)
	{
		LL tot=mx/i;
		for(int j=1;j<=tot;j++)b[j]=sum[min(i*(j+1)-1ll,mx)]-sum[i*j-1];
		LL cnt=0;
		for(int j=1;j<=tot;j++)cnt+=b[j]&1;
		if(cnt==1)
		{
			if(b[1]&1)ans+=b[1];
		}
		if(cnt==2)
		{
			for(int j=2;j<=tot;j++)
			{
				if((b[j]&1)&&(b[j-1]&1))ans+=b[j];
			}
		}
	}
	printf("%lld",ans);
}
```

---

## 作者：Eibon (赞：3)

博弈论的题目，考虑必败状态与必胜状态。

往奇偶性的方向思考。

不难发现，如果当前每种元素均出现偶数次，那么一定为先手必败，因为在移动后，对方只需模仿自己即可。

考虑什么时候为必胜状态。

如果当前移动后成为必败状态，那这就是必胜状态。

发现一次操作只会对大小相邻的两个元素产生影响，即将 $X$ 变为 $X-1$。

进行分讨。

 - 所有数都是偶数，必败。
 - 一个数 $X$ 是奇数
   - 当它为 $1$ 时，取完不会对大小大于 $0$ 的数产生影响，必胜
   - 否则一定仍存在奇数，因为如果对 $X$ 操作，$X-1$ 会变为奇数，对 $X+1$ 操作会使 $X+1$ 变为奇数，这样是无法消去 $X$ 的影响的。至于其它操作，因为与 $X$ 无关，更是无法消去 $X$ 的影响的。
 - 两个数为奇数，显然，只有相邻时才有解。

考虑枚举 $s_{1}$，每个元素在第 $i$ 堆出现的最多次数为 $\left\lfloor\dfrac{a_{i}}{s_{1}}\right\rfloor$。

发现我们不能对每一个元素列举它的集合，这样会超时。

运用前缀和的思想，处理出 $sum_{i}$ 表示小于等于 $i$ 的堆数。

类似于数论分块，我们可以快速算出出现次数为 $x$ 的元素数量，即 $sum_{(x+1)\times s_{1}-1}-sum_{x\times s_{1}-1}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int T=1,n,ans,mx;
int a[maxn],sum[maxn],num[maxn];
void solve()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum[a[i]]++;
		mx=max(mx,a[i]);
	}
	for(int i=1;i<=mx;i++){
		sum[i]+=sum[i-1];
	}
	for(int i=1;i<=mx;i++){
		int res=0;
		for(int j=1;j<=mx/i;j++){
			num[j]=sum[min((j+1)*i-1,mx)]-sum[j*i-1];
			res+=num[j]%2;
		}
		if(res>2||!res){
			continue;
		}
		if(res==1&&(num[1]&1)){
			ans+=num[1];
		}
		else if(res==2){
			for(int j=2;j<=mx/i;j++){
				if((num[j]&1)&&(num[j-1]&1)){
					ans+=num[j];
					break;
				}
			}
		}
	}
	printf("%lld\n",ans);
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
//	scanf("%lld",&T);
	while(T--){
		solve();
	}
	return 0;
}
//dyyyyds
```

---

## 作者：Sol1 (赞：3)

《开局一道结论题，AC 全靠猜》

考虑到在第一步定下 $s$ 之后，相当于将所有数在值域上分段为 $[1,s)$，$[s+1,2s)$，以此类推。而局面转化为这样之后，加大 $s$ 的操作就相当于 **合并一些段**，而取走 $s$ 的操作就相当于 **从后面一段取一个数到前面一段**。考虑利用每一段中数的数量确定局面的胜负性。

首先，$[1,s)$ 段不会影响答案，故只考虑更靠后的段。

**观察 1：如果当前所有段里面都包含有偶数个数，则先手必败。**

证明：此时如果加大 $s$，只能合并一些段，而偶数加偶数还是偶数，所以只会引向另外一个局面使得所有段里面都有偶数个数；而此时先手不论如何取，后手只需要和先手从同一个段取即可。由于所有段都是偶数，所以先手可以取则后手必然可以取。只要重复下去，所有段保持为偶数，且可以取的必然越来越少。而全 $0$ 是所有段为偶数的局面，而且是必败局面，所以观察 1 正确。

**观察 2：如果当前有一段包含有奇数个数，则先手必胜。**

证明：考虑最靠后的有奇数个数的一段 $[ks,(k+1)s)$（必然存在这样一段，因为奇数段至少有 $1$ 个数，而没有无穷多个数），直接把 $s$ 加到 $ks$，然后从 $[ks,2ks)$ 取走一个，就变成一个全偶数局面，此时后手变为先手，由观察 1，后手必败，故先手必胜，故观察 2 正确。

所以求出原数组的 $\rm cnt$ 的前缀和，枚举第一次的 $s$，再枚举从哪一段取，可以通过判断这一段的奇偶性、前一段的奇偶性以及记录包含奇数个数的段的个数来 $O(1)$ 判断取完后是否所有段都变成偶数。如果所有段都变成偶数，则答案累加这一段的数的个数。

总复杂度 $O(a\ln a)$。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

int n, a[100005], cnt[2000005], m;

inline void Read() {
	n = qread();
	for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) m = Max(m, a[i]);
	for (int i = 1;i <= n;i++) cnt[a[i]]++;
	for (int i = 1;i <= 2 * m;i++) cnt[i] += cnt[i - 1];
}

inline void Solve() {
	long long ans = 0;
	for (int i = m;i >= 1;i--) {
		int oddcnt = 0;
		for (int j = i;j <= m;j += i) {
			if (cnt[j + i - 1] - cnt[j - 1] & 1) oddcnt++;
		}
		if (oddcnt >= 3) continue;
		if ((cnt[2 * i - 1] - cnt[i - 1] & 1) && oddcnt == 1) ans += cnt[2 * i - 1] - cnt[i - 1];
		for (int j = 2 * i;j <= m;j += i) {
			if ((cnt[j + i - 1] - cnt[j - 1] & 1) && (cnt[j - 1] - cnt[j - i - 1] & 1)) ans += cnt[j + i - 1] - cnt[j - 1];
		}
		//printf("%lld\n", ans);
	}
	printf("%lld", ans);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```

---

## 作者：markding (赞：0)

考虑 Bessie 选择的 $s_1$，会导致后面选的值都是它的倍数，这实际上会使得石子个数位于区间 $[ks_1,(k+1)s_1)$ 内的石子堆等价。

而取走 $s_1$ 个石子后，原来位于 $[ks_1,(k+1)s_1)$ 区间内的石子堆会落入 $[(k-1)s_1,ks_1)$ 内。

这启发我们将题目改写成如下形式：

>给定一个长为 $N$ 的数组 $\{a_i\}$，先后手轮流操作。\
每次操作选择一个正整数 $x$，将数组内所有 $a_i\gets\left\lfloor \dfrac{a_i}{x}\right\rfloor$，然后选择一个正整数 $a_i\gets a_i-1$。\
最后无法操作者判负。求使先手必胜的第一步决策的种类数。

我们发现，如果某一时刻数组 $\{a_i\}$ 内的所有正整数出现次数皆为偶数，那么接下来要操作的一方必败（定理 1）

证明：假设此时要操作的一方完成了操作，可以注意到不管他选择的 $x$ 是多少，数组内所有 $a_i\gets\left\lfloor \dfrac{a_i}{x}\right\rfloor$ 后，所有正整数出现次数仍皆为偶数。然后再选择一个正整数 $a_i\gets a_i-1$，此时会出现仅一个正整数出现了奇数次。

那么另一方可以选择 $x=1$ 并选择刚才选择的那个位置的 $a_i\gets a_i-1$。这样，所有正整数出现次数仍皆为偶数。最后总会有都取完的一刻（$0$ 也是偶数），故接下来要操作的一方必败。

进一步，如果某一时刻数组 $\{a_i\}$ 内的所有正整数出现次数有至少一个奇数，那么接下来要操作的一方必胜。（定理 2）

证明：我们一定能找到最大的一个 $a_i$，使得其出现的次数是奇数次。

此时选择 $x=a_i$，然后容易发现此时仅一个正整数出现了奇数次，将它减 $1$ 即可。此时转化为了定理 1 的内容，故接下来要操作的一方必胜。

具体实现时可以枚举 $s_1$ 的值，利用桶+前缀和优化。

```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=1000005;
int ans,n,mx,s[N],a[N];
signed main()
{
	cin>>n;
	for(int i=1,x;i<=n;i++)
		mx=max(mx,(cin>>x,x)),s[x]++;
	for(int i=1;i<=mx;i++)s[i]+=s[i-1];
	for(int i=1;i<=mx;i++)
	{
		for(int j=1;j<=mx/i;j++)
			a[j]=s[min((j+1)*i-1,mx)]-s[j*i-1];
		int cnt=0;
		for(int j=1;j<=mx/i;j++)cnt+=a[j]&1;
		if(cnt==1 && a[1]&1)ans+=a[1];
		if(cnt==2)for(int j=2;j<=mx/i;j++)
			if(a[j-1]&1 && a[j]&1)ans+=a[j];
	}
	cout<<ans;
}
```

---

## 作者：Unnamed114514 (赞：0)

ad hoc，如果使考场上的话估计要 GG。

以下为结论的推导：

考虑先求解一个 $s_1$ 的情况。

首先我们可以发现，$i$ 最多只能选 $\lfloor\dfrac{a_i}{s_1}\rfloor$。

然后我们把 $\lfloor\dfrac{a_i}{s_1}\rfloor$ 列成一个序列 $S$，那么相当于对 $S$ 进行减法操作和赋 $0$。如果序列中每个数的出现次数都是偶数，那么先手肯定是必败的，后手必胜策略：类似与阶梯博弈，如果先手减去一个数，那么后手可以减去一个和它相等的数减去一个相等的值。边界条件：全 $0$，先手必败。

注意到后手是可以取最大的一个出现次数为 $1$ 的数，这样的话，其它的出现次数为 $1$ 的数都不能被减，变成 $0$，但是后手是不一定可以的。

由此，易知：

> **若先手不能使所有出现次数为 $1$ 的数清空，那么先手必败；否则先手必胜。**

由此，对出现次数为 $1$ 的数的数量 $cnt$ 进行讨论：

- $cnt=0$ 已知，必败。

- 如果更改 $x$ 的奇偶性，那么 $x-1$ 的奇偶性也会更改，所以一次最多只能更改 $2$ 个数的奇偶性。那么当 $cnt>2$ 时，显然先手必败。

- 上述已经说过了，如果恰好只有 $x,x-1$ 出现次数为奇数，此时 $cnt=2$，那么直接改 $x$ 先手必胜，方案数为 $x$ 的出现次数；否则 $cnt=2$ 时不行。

- 那么只剩下 $cnt=1$ 的情况了，显然当且仅当 $x=1$ 时可以一次清空。

***

以下是实现部分。

令值域为 $V$。

注意枚举 $s_1$，枚举 $cnt$ 的复杂度是 $\dfrac{V}{1}+\dfrac{V}{2}+\cdots+\dfrac{V}{V}$，这是个调和级数，$O(V\log V)$ 级别，启发我们要 $\le O(\log V)$ 求解 $cnt$。

注意到对于 $s_1$，$cnt_i$ 的值相当于是 $a$ 中在 $[is_1,(i+1)s_1-1]$ 中的数的数量，那么直接打权值线段树即可。

实际测试 TLE 85，考虑优化：

- 玄学：$n$ 远小于 $V$，那么权值线段树的点，如果访问次数为 $0$，就不需要递归访问了。

- 正确：$V\log V$ 雷打不动，所以应该优化权值线段树的 $O(\log V)$，直接离散化即可，时间复杂度 $O(\log n)$，注意此时查询区间 $[l,r]$ 可能会出现 $l>r$ 的情况，此时答案显然为 $0$。

时间复杂度 $O(V\log V\log n)$。

~~不是最劣解。~~

UPD：犯智了，静态的，直接用桶，然后用树状数组的思路维护前缀和，$O(V\log V)$，而且最优解。

---


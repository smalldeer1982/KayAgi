# [图论与代数结构 501] 网络流_1

## 题目描述

给定 $n$ 个点， $m$ 条边，给定每条边的容量，求点 $s$ 到点 $t$ 的最大流。

**注意，图可能存在重边。**

## 说明/提示

对于所有数据，$1 \le n \le 30$，$1 \le m \le 200$，$0 \le c \le 2 ^ {31} - 1$，所有数据均为随机构造。

## 样例 #1

### 输入

```
7 14 1 7
1 2 5
1 3 6
1 4 5
2 3 2
2 5 3
3 2 2
3 4 3
3 5 3
3 6 7
4 6 5
5 6 1
6 5 1
5 7 8
6 7 7
```

### 输出

```
14```

## 样例 #2

### 输入

```
10 30 3 7
10 2 18652
8 9 2560
8 9 13734
5 6 23138
9 7 29606
5 8 21673
1 9 11596
3 2 9441
3 7 4829
5 8 24437
1 2 31111
4 10 26213
2 7 31808
1 9 10841
6 8 10758
3 5 11887
4 2 1362
4 1 18182
4 8 18156
10 6 11015
2 7 2640
10 6 27726
10 6 21615
5 1 5959
3 1 19857
5 4 1862
8 9 13830
3 10 22152
4 10 5221
5 2 24065
```

### 输出

```
68166```

## 样例 #3

### 输入

```
6 18 4 6
4 3 31298
4 5 25605
1 6 8332
1 6 1205
2 3 15950
4 3 1418
1 6 5329
1 6 29907
5 6 22281
1 2 12609
4 1 4033
1 2 12122
4 5 5997
5 6 19507
1 5 19306
2 6 978
5 6 26343
5 3 23224
```

### 输出

```
35635```

# 题解

## 作者：strcmp (赞：11)

看见没有 ISAP 的题解，蒟蒻刚学 ISAP 就贡献一个吧。

### 步入正题

**1.ISAP 算法是什么？**

是一种计算网络流的高效最短增广路算法，它其实是优化版的最短增广路算法，最短增广路算法即 EK 算法。

**2.Dinic 算法和 ISAP 算法的区别？**

Dinic 算法每次 DFS 后，会从源点 $s$ 到汇点 $t$ 进行一次 BFS 来维护层次图。但 ISAP 算法从始至终只进行一次从汇点 $t$ 到源点 $s$ 的 BFS，但 DFS 的时候要同时维护结点的深度。

**3.ISAP 算法具体有哪些步骤？**

1.首先，**从汇点 $t$ 到源点 $s$** 进行一次 BFS。

2.然后，每次沿着**深度连续**的结点进行增广，然后**更新路径上的结点深度**。

3.如果**某个深度不存在**或者**源点 $s$ 的深度大于等于结点个数 $n$ **时结束，否则**转步骤 2**（不是转步骤 1）

ISAP 的神奇之处在于它不用再进行 BFS 就能维护层次图。

首先是初始化历程，这里**使用链式前向星进行存图。**

```cpp
#define inf 1000000000000000
#define V 20010
#define E 500010
typedef long long int ll;
struct edge {
public:
	int to, next;
	ll capa;
};
int cnt = 0, head[V]; int n, m; vector<edge>node(E);
inline void add(int fir, int nxt, ll w) {
	node[cnt].to = nxt;
	node[cnt].capa = w;
	node[cnt].next = head[fir];
	head[fir] = cnt; ++cnt;
}
int s, t, dep[V], gap[V], cur[V]; queue<int>que; ll sum = 0;
inline void initing() {
	memset(dep, -1, (n + 1) * sizeof(int));
	memcpy(cur, head, (n + 1) * sizeof(int));
}
```

其中有三个新数组：分别是 $dep$, $gap$ 和 $cur$。

$cur$ 用于“当前弧优化”，将于后面介绍，那 $dep$ 和 $gap$ 是指什么呢？

在图 $G=(V,E)$ 中， $dep$ 可以对应于一个新函数 。
$$
\operatorname{dep}(u),u \in V
$$

它代表这个结点的**深度**。你先不要纠结深度是什么，下面会讲。

同样， $gap$ 也可以对应一个新函数。
$$
\operatorname{gap}(d),d \in \operatorname{deep(u)},u \in V
$$

它代表**这个深度对应的结点数**。

那它们有什么用呢？

先放图。

![](https://cdn.luogu.com.cn/upload/image_hosting/6306ndod.png)

因为工具的限制，反向弧以及结点 $v1$ 和 $v2$ 之间的重边无法正常展示。

ISAP 会先用 BFS 造层次图。注意是从汇点 $t$ 开始 BFS ，不是从源点 $s$ 开始的。

下面是 BFS 后图的状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/e3tznebx.png)

具体过程如下：

1.将汇点 $t$ 入队。

2.**遍历队首结点每个出边**，将边对应的结点入队，**入队的结点深度为队首结点深度 +$1$**

3.将队首结点出队，**如果队列不为空，转步骤 $2$，否则直接结束**

注意，这里有一个坑点：
```cpp
if (dep[ito] == -1)
```
BFS 的时候一定只通过深度判定是否遍历过，不能判定边权大小，因为初始反向边是没有边权的，而我们因为是从汇点 $t$ 开始 BFS 的，所以要通过反向边才能到达源点 $s$。

代码如下：

```cpp
void bfs() {
	int fro, i, ito;
	que.push(t); deep[t] = 0; ++gap[deep[t]];
	while (!que.empty()) {
		fro = que.front(); que.pop();
		for (i = head[fro]; i != -1; i = node[i].next) {
			ito = node[i].to;
			if (deep[ito] == -1) {//不要特判边权为 0
				deep[ito] = deep[fro] + 1;
				que.push(ito);
				++gap[deep[ito]];//别忘了给 gap 加 1
			}
		}
	}
}
```

有了这个深度有什么用呢？**能让我们找到的增广路一定是最短增广路。**

怎么走呢？

首先给 DFS 两个参数：“当前结点 $u$” 和 “从 $s$ 到 $u$ 增广路径上最小边权 $flow$”。再加上一个变量：“当前结点已经增广出去的流量 $used$ ”。

记住下面几个原则：

1.从源点 $s$ 开始 DFS。

2.只沿着**深度连续**的增广路径增广，只通过边权不为 $0$ 的边增广。

3.当 $used$ 等于 $flow$ 时及时停止。

4.当增广后 $used$ 小于 $flow$ 时将结点 $u$ 的深度 +$1$。

先看看代码感受一下。

```cpp
ll dfs(int u, ll flow) {
	if (u == t || flow == 0)return flow; ll used = 0;
	for (int i = cur[u]; i != -1; i = node[i].next;) {
		cur[u] = i;
		if (dep[u] == dep[node[i].to] + 1 && node[i].capa > 0) {
			ll wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei;
				node[i ^ 1].capa += wei;
				used += wei;
			}
		}
		if (used == flow)return used;
	}
	if (used > flow)used = flow;
	if (used < flow) {
		--gap[dep[u]];
		if (!gap[dep[u]])dep[s] = n + 1;
      ++gap[++dep[u]];
	}
        //这里的 if 语句才是与 Dinic 算法真正的不同之处
	return used;
}
```
你大概听说过一个与 ISAP 几乎一致的算法：“Dinic 算法”。

Dinic 算法与 ISAP 算法有一点不一样： Dinic 在 DFS 后直接暴力 BFS 维护层次图，但是 ISAP 却在 DFS 的时候也在维护层次图。这一点不同导致 ISAP 算法的运行速度往往比 Dinic 算法快上数倍。

ISAP 算法是这样维护层次图的：如果从上一个结点传过来的流量大于从这个结点增广出去的流量，那么将这个结点的深度 +$1$。

就是这么简洁。

你可能还想问：“为什么 ‘当增广后 $used$ 小于 $flow$ 时将结点 $u$ 的深度 +$1$’ 呢？”

请看：

```cpp
if (used < flow) {
		--gap[dep[u]];
		if (!gap[dep[u]])dep[s] = n + 1;
     		++gap[++dep[u]];
	}
```
ISAP 的思想在这短短的几行代码里表现得淋漓尽致。

为什么这是对的？

假设有一个结点 $u \in V$ 是当前 DFS 考虑的结点，并且我们知道汇点 $t$ 的深度是不变的，因为我们遇到了汇点 $t$ 就 ```return```，而源点 $s$ 的深度是每轮必变的，因为初始源点 $s$ 的 $flow$ 是 $\infty$。

这可以推导出一个很重要的结论：“**当前 DFS 找到的增广路径长度相等且都等于 $\operatorname{dep}(s)$**”。

这意味着如果有一个结点 $u \in V$， 从 $u$ 增广出去的流量小于增广路径上最小边权的容量，也就意味着**经过 $u$ 的所有长度等于 $\operatorname{dep}(s)$ 的增广路都已经被增广过了**，而且通过这个结论我们也可以证明，所有长度小于 $\operatorname{dep}(s)$ 的增广路都已经被增广完了。

**这时候将结点 $u$ 的深度提高，相当于通过结点 $u$ 的增广路径长度变长了，也就能增广其他比原本的增广路更长的增广路了。**

#### 结束条件， gap 优化以及当前弧优化
```cpp
while (dep[s] < n) {
		sum += dfs(s, inf);
		memcpy(cur, head, (n + 1) * sizeof(int));
	}
```
这是运行 ISAP 的核心代码之一。

可以看到结束条件是 ```dep[s]<n``` 。

为什么呢？因为增广路最长只有 $n$，```dep[s]``` 等于 $n$ 时增广路肯定都找完了。

那 gap 优化又是优化到那里了呢？
```cpp
if (used < flow) {
		--gap[dep[u]];
		if (!gap[dep[u]])dep[s] = n + 1;
     		++gap[++dep[u]];
	}
```
无比的合理，当一个深度对应的结点数目为 $0$ 的时候，那么就会形成断层，也就找不到增广路了，找不到增广路就说明已经是最大流了。这里利用 ```dep[s]=n+1``` 还能使程序少一个特判。

程序还使用了一个优化：“当前弧优化”。

当前弧优化的核心在这里：

```cpp
for (int i = cur[u]; i != -1; i=node[i].next) {
	cur[u] = i;
        ...
}

```
这里的作用是：当我们再次遍历到这个点时，前面的边肯定已经被增广完了，就没必要再走了，在这里进行一次剪枝，速度也极大提升。
#### ISAP 的正确性：

在图 $G=(V,E)$ 中，很显然源点 $s$ 的深度在每次 DFS 后都会提高，并且每次 DFS 都找的是最短增广路，如果一直没出现断层，定义函数 $\operatorname{dep}(U),U \in V$ 为结点 $U$ 的深度。 
最多会跑 $V-\operatorname{dep}(s)$ 次增广路，可以证明，当 $\operatorname{dep}(s) ≥ V$ 时必定出现断层，也就不存在增广路径，因此 ISAP 算法找出的一定是最大流。

#### 时间复杂度分析：
在图 $G=(V,E)$ 中，BFS 是 $\Theta(V+E)$ 的，几乎不影响总时间复杂度。显然，每次 DFS 后，源点 $s$ 到汇点 $t$ 的距离都会增加 $1$，最多进行 $V-\operatorname{dep}(s)$ 次 DFS，直观上看，$\operatorname{dep}(s)$ 比 $V$ 的阶小，因此共进行 $O(V)$ 次 DFS，每次构造出一个新的层次图，图上最多有 $O(E)$ 个增广路，寻找每个增广路的时间最多是 $O(V)$ 的，所以 ISAP 算法的时间复杂度上限为 $O(V^2E)$。

证毕。

ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 50010
#define E 1000010
typedef long long int ll;
struct edge {
public:
	int to, next;
	ll capa;
};
int cnt = 0, head[V]; int n, m; vector<edge>node(E);
inline void add(int fir, int nxt, ll w) {
	node[cnt].to = nxt;
	node[cnt].capa = w;
	node[cnt].next = head[fir];
	head[fir] = cnt; ++cnt;
}
int s, t, deep[V], gap[V], cur[V]; queue<int>que; ll sum = 0;
inline void initing() {
	memset(deep, -1, V * sizeof(int));
	memcpy(cur, head, (n+1)*sizeof(int));
}
inline void bfs() {
	int fro, ito;
	que.push(t); deep[t] = 0; ++gap[deep[t]];
	while (!que.empty()) {
		fro = que.front(); que.pop();
		for (register int i = head[fro]; i != -1; i = node[i].next) {
			ito = node[i].to;
			if (deep[ito] == -1) {
				deep[ito] = deep[fro] + 1;
				que.push(ito);
				++gap[deep[ito]];
			}
		}
	}
}
ll dfs(int u, ll flow) {
	if (u == t || flow == 0)return flow; ll used = 0,wei=0;
	for (int i = cur[u]; i != -1; i = node[i].next) {
		cur[u] = i;
		if (deep[u] == deep[node[i].to] + 1 && node[i].capa > 0) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei;
				node[i ^ 1].capa += wei;
				used += wei;
			}
		}
		if (used == flow)return used;
	}
	if (used < flow) {
		--gap[deep[u]];
		if (!gap[deep[u]])deep[s] = n + 1;
		++gap[++deep[u]];
	}
	return used;
}
ll ISAP() {
	initing(); bfs();
	while (deep[s] < n) {
		sum += dfs(s, inf);
		memcpy(cur, head, (n+1) * sizeof(int));
	}
	return sum;
}
int main() {
	ios::sync_with_stdio(0);
	memset(head, -1, V*sizeof(int));
	cin >> n >> m >> s >> t;
	int f, n; ll w;
	for (register int i = 0; i < m; i++) {
		cin >> f >> n >> w;
		add(f, n, w);
		add(n, f, 0);
	}
	cout << ISAP();
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：9)

裸的网络流模板题，用 Dinic 即可。

## 题目大意
给定一张 $n$ 个节点，$m$ 条边的网络，以及源点、汇点 $s,t$，求 $s$ 到 $t$ 的最大流。

## 大体思路
### 网络流概念
一个网络 $G=(V,E)$ 是一张有向图，每条边 $(x,y)$ 有一个权值 $c$，表示边的容量（capability)。图中有两个特殊节点 $s,t$，表示源点和汇点（source, sink)。

设流量函数为 $f(x,y),\ x,y\in V$，则满足
1. $f(x,y)\le c(x,y)$，即流量限制。
2. $f(x,y)=-f(y,x)$，即斜对称（反对称）。
3. $\forall x\neq S,x\neq T,\sum_{(u,x)\in E}f(u,x)=\sum_{(x,v)\in E}f(x,v)$，即流量守恒。

$(x,y)\in E$，称 $f(x,y)$ 表示该边的流量，$c(x,y)-f(x,y)$ 表示该边的剩余容量。

有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。最大流的常用算法有 EK, Dinic, ISAP, 其中前者复杂度为 $O(nm^2)$，后两者的理论复杂度上界为 $O(n^2m)$，但实际效率均远高于此。

### Dinic 与增广路
求解最大流之前，我们先认识以下增广路的概念。

**增广路** 指的是，从源点到汇点，只要有 $flow>0$ 流过去，这条路就是增广路。在一些最大流算法中，就是将这些路 **增广** （意思就是走掉这条路，带走的流量肯定就是这条路的最小流量）。

在任意时刻，网络中所有节点以及剩余容量大于 0 的边构成的子图称为 **残量网络**。

EK 算法每轮会遍历整个残量网络，但只找出一条增广路，因此可以进一步优化。由此便诞生了 Dinic。

BFS 中可以得到一个节点的层次 $d_x$，表示 $S\to x$ 经过的最少边数。在残量网络中，满足 $d_y=d_x+1$ 的边 $(x,y)$ 构成的子图是分层图，其显然是 DAG。

Dinic 算法是不断重复以下流程，直到 $S$ 在残量网络上无法达到 $T$：
1. 在残量网络上 BFS 得到分层图；
2. 在分层图上进行 DFS 寻找增广路，回溯时更新剩余容量（也就是说对于每条边只需记录剩余容量 $c_i$ 即可）。

在此过程中，有一些优化：
1. 多路增广：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。

2. 当前弧优化：增广时，一条边不可能被增广第二次，所以可以通过更新邻接表临时表头跳过这些边。

3. 满流剪枝：增广时，对于一条边增广失败，可以直接将对应节点的层数设置为 $-1$，这样不会再对这些边进行增广。

### 网络流与二分图匹配
网络流是求解二分图匹配问题的常用手段，也是一种通用手段。由于一组匹配是每个左部点出一条边，每个右部点入一条边，等价于建立超级源点和超级汇点 $s,t$，由 $s$ 向所有左部点连流量为 $1$ 的边，由所有右部点向 $t$ 连流量为 $1$ 的边，原图中边 $(x,y)$ 对应 $x$ 向 $y$ 连流量为 $1$ 的边，求最大流即为最大匹配。

特别地，Dinic 算法在求解上述二分图最大匹配问题时的复杂度上界为 $O(m\sqrt n)$，实际更快。

## 完整代码
```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
#define rep(ii,aa,bb) for(re int ii=aa;ii<=bb;ii++)
#define Rep(ii,aa,bb) for(re int ii=aa;ii>=bb;ii--)
typedef long long ll;
typedef unsigned long long ull;
const int maxn=1e4+5;
const ll inf=1ll<<60;
namespace IO_ReadWrite{
	#define re register
	#define gg (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
	char buf[1<<21],*p1=buf,*p2=buf;
	template <typename T>
	inline void read(T &x){
		x=0;re T f=1;re char c=gg;
		while(c>57||c<48){if(c=='-') f=-1;c=gg;}
		while(c>=48&&c<=57){x=(x<<1)+(x<<3)+(c^48);c=gg;}
		x*=f;return;
	}
	inline void ReadChar(char &c){
		c=gg;
		while(!isalpha(c)) c=gg;
	}
	template <typename T>
	inline void write(T x){
		if(x<0) putchar('-'),x=-x;
		if(x>9) write(x/10);
		putchar('0'+x%10);
	}
	template <typename T>
	inline void writeln(T x){write(x);putchar('\n');}
}
using namespace IO_ReadWrite;
int ver[maxn],head[maxn],nxt[maxn],c[maxn],tot=1;
inline void add(int u,int v,int w){
	ver[++tot]=v;c[tot]=w;nxt[tot]=head[u];head[u]=tot;
	ver[++tot]=u;c[tot]=0;nxt[tot]=head[v];head[v]=tot;
}
int d[maxn],cur[maxn],n,m,s,t;
inline bool bfs(){// BFS 进行分层 
	memset(d,-1,sizeof(d));
	queue<int> q;
	q.push(s);d[s]=1;cur[s]=head[s];
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=nxt[i]){
			int v=ver[i];
			if(c[i]&&d[v]==-1){
				d[v]=d[u]+1;q.push(v);
				cur[v]=head[v];
				if(v==t) return 1;
			}
		}
	}
	return 0;
}
inline int dfs(int u,int limit){// DFS 进行增广
	if(u==t||limit==0) return limit;
	int flow=0; // 多路增广
	for(int i=cur[u];i&&flow<limit;i=nxt[i]){
		cur[u]=i;// 当前弧优化
		int v=ver[i];
		if(d[v]==d[u]+1&&c[i]){
			int f=dfs(v,min(c[i],limit-flow));
			if(!f) d[v]=-1;// 满流剪枝
			flow+=f;c[i]-=f;c[i^1]+=f;
		}
	}
	return flow;
}
inline ll dinic(){ // 求最大流
	ll maxflow=0,flow=0;
	while(bfs()) while(flow=dfs(s,inf)) maxflow+=flow;
	return maxflow;
}
int main(){
	read(n);read(m);read(s);read(t);
	for(int i=1,u,v,w;i<=m;i++){
		read(u);read(v);read(w);
		add(u,v,w);
	}
	writeln(dinic());
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：4)

EK 算法是对 FF 算法的一种改进，这两种算法的思想是：每次对网络进行一次遍历，找出最小的残量（从源点到汇点），进行增广。

FF 算法核心代码：

```cpp
int dfs(int u,int in){
    if(u==t){
        ans+=in;
        flag=1;//找到增广路
        return in;
    }
    vis[x]=1;
    for(int i=fir[u];i;i=nxt[i]){
        int v=to[i];
        if(vis[v]||flow[i]==0) continue;
        int res=dfs(v,min(in,flow[i]));//流量受最小的边的限制
        if(flag){
            flow[i]-=res;
            flow[i^1]+=res;//反向边进行加，方便进行反悔操作
            return res;
        }
    }
    return 0;
}
void ff(){
    do{
        memset(vis,0,sizeof(vis));
        flag=0; 
        dfs(s,INF);
    }while(flag);
}
```
由于 FF 算法每次找到的增广路不是最短路径，这导致一条边成为关键边的最大次数为 $ \max \{c_1,c_2,c_3,... \ ,c_{m-1},c_m \} \div 2$ （ $m$ 为边数， $c_i$ 为第 $i$ 条边的流量）。这会被流量卡，复杂度很糟糕。

所以 EK 采用了 BFS 来寻找增广路，这确保了每次找到的增广路都是最短路径。使得复杂度下降。

复杂度分析：（定义关键边为：该边的残量为增广路的残量的边）

从边 $(u,v)$ 成为关键边到下一次成为关键边，原结点到 $u$ 的距离至少增加 $2$ 个单位。由于从源结点 $s$ 到结点 $u$ 的的最短路径中间结点不可能包括 $s,u,t$ ，从 $s$ 到 $u$ 的最短路径最长为 $n-2$ 。

一条边成为关键边的最大可能是 $(n-2) \div 2$ ，一共有 $m$ 条边，关键边总数为 $O(nm)$ ，BFS 复杂度为 $O(m)$ ，所以 EK 算法的复杂度上界是 $O(nm^2)$ 。


代码如下：
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
const int maxn=35;
const int inf=0x7fffffff;
int r[maxn][maxn],pre[maxn],m,n;
bool vis[maxn];
bool bfs(int s,int t) {
	int u;
	queue<int>q;
	memset(pre,0,sizeof(pre));
	memset(vis,0,sizeof(vis));
	pre[s]=s;
	vis[s]=true;
	q.push(s);
	while(!q.empty()) {
		u=q.front();
		q.pop();
		for(int i=1; i<=n; i++) {
			if(r[u][i]>0&&!vis[i]) {//有流量才能流 
				pre[i]=u;
				vis[i]=true;
				if(i==t) return true;
				q.push(i);
			}
		}
	}
	return false;
}
int ek(int s,int t) {
	int flow=0,d;
	while(bfs(s,t)) {
		d=inf;
		for(int i=t; i!=s; i=pre[i])
			d=(d<r[pre[i]][i]?d:r[pre[i]][i]);//残量取决于最小边的流量 
		for(int i=t; i!=s; i=pre[i]) {
			r[pre[i]][i]-=d;
			r[i][pre[i]]+=d;//反边添加流量，以进行反悔操作。 
		}
		flow+=d;
	}
	return flow;
}
signed main() {
	int s,t,u,v,w;
	scanf("%lld%lld%lld%lld",&n,&m,&s,&t);
	for(int i=1; i<=m; i++) {
		scanf("%lld%lld%lld",&u,&v,&w);
		r[u][v]+=w;//重边处理 
	}
	printf("%lld\n",ek(s,t));
	return 0;
}
```


---

## 作者：听取MLE声一片 (赞：2)

强烈推荐[网络流洛谷日报](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)（我就是从这学的）。

注：本篇题解不侧重于严谨的证明，更偏向于理解的方式。

我们先看一个实际例子（引用日报）：

> 我们想象一下自来水厂到你家的水管网是一个复杂的有向图，每一节水管都有一个最大承载流量。自来水厂不放水，你家就断水了。但是就算自来水厂拼命的往管网里面注水，你家收到的水流量也是上限（毕竟每根水管承载量有限）。你想知道你能够拿到多少水，这就是一种网络流问题。

我们从中可以提取到很多信息：

1.图中存在源点（自来水厂）和汇点（你家）。

2.每条边都有一个流量上限，所通过的流量不能超过上限。

3.你想知道从汇点最多能获得多少流量（你能获得多少水）。

## 最大流（EK算法）

如果你现在有一个网络流图，你想把它手玩出来，你应该怎么做？

先找到一条从源点到汇点的一条边的流量都不为 `0` 的路，它被称为 **增广路** ，这条增光路能通过的最大流量显然就是增光路所经过的流量的 **最小值** 。

而我们的 `EK` 算法就是根据增广路求解的，由此我们就可以设计出 `EK` 算法的雏形。

先写一个 `bfs` 使其能找到一条增广路，每次调用这个 `dfs` ，将求出的增广路累加答案（流量最小值），再把这条增广路上所有的流量 **减去** 这个最小值。

为什么要减去呢？因为流过去占用了一部分的流量，这些流量不能再次使用。

难道这就是全部的 `EK` 算法吗？

不，我们看这样一个例子（再次借鉴日报）
![](https://cdn.luogu.com.cn/upload/pic/24602.png)

如果第一次的增广路是：$s \rightarrow 3\rightarrow 5 \rightarrow t$流量显然是 `10`，第二次的增广路是 $s \rightarrow 4 \rightarrow 5 \rightarrow t$ 流量显然是`35`。

而这种方案显然不如：$s \rightarrow 4 \rightarrow 5 \rightarrow t$ 流量为 `45` ，$s \rightarrow 3 \rightarrow t$流量为 `10`。

这怎么处理呢？`dp` ? 高斯消元？

其实方法很简单，我们可以建 **反向边**。

为什么反向边可以解决这个问题呢？我们在建反向边的时候流量赋为 `0`，在累加答案的时候，普通边减去最小值，而反向边 **加上** 最小值。

这就可以支持我们进行**反悔**，之前的操作不够优秀，后面我们发现更优秀的操作就可以解决。

我们如何处理反向边与普通边的联系呢？这里用 `vector` 存边就会略显麻烦，所以我们用 **邻接表** 存边，而且普通边和反向边是成对存在的，我们就可以用**异或**来找反向边。

分析一下时间复杂度，我们最多需要找 `m` 次增广路，$dfs$ 找增广路时间为最多 $\mathcal{O}(nm)$，因为 $bfs$ 是广度的，一个图里面最多有 $nm$ 个增广路，所以时间复杂度就为 $nm^2$ 。

实际上，我们每次找的是长度最短的增广路，远远达不到 $nm$ ，增广次数也达不到 `m` 次，所以正常能处理 $10^3$ 到 $10^4$ 的图。

下面是代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#define ll long long 
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
using namespace std;
const ll inf=922337203685477587;
int n,m,s,t;
struct point{
    int v,next;
	ll val;
}a[200001];
int top=1,head[100001];
inline void add(int u,int v,ll w){
    a[++top].v=v;
    a[top].val=w;
    a[top].next=head[u];
    head[u]=top;
}
int book[101010];
struct Pre{
    int v,edge; 
}b[100001];
inline bool bfs(){
    queue<int> q;
    memset(book,0,sizeof(book));
    memset(b,-1,sizeof(b));
    book[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=a[i].next){
            int x=a[i].v;
            if(!book[x]&&a[i].val){
            	b[x].v=u;
            	b[x].edge=i;
            	if(x==t)
					return 1;
            	book[x]=1;
            	q.push(x);
            }
        }
    }
    return 0;
}
ll EK(){
    ll ans=0;
    while(bfs()){
        ll minn=inf;
        for(int i=t;i!=s;i=b[i].v)
            minn=min(minn,a[b[i].edge].val);
        for(int i=t;i!=s;i=b[i].v){
            a[b[i].edge].val-=minn;
            a[b[i].edge^1].val+=minn;
        }
    	ans+=minn;
	}
    return ans;
}
int main(){
    n=read(),m=read(),s=read(),t=read();
    for(int i=1;i<=m;i++){
    	int u,v;
		ll w;
    	u=read(),v=read();
    	cin>>w;
		add(u,v,w);
		add(v,u,0);	
	}
	cout<<EK();
    return 0;
}
```
谢谢大家！

---

## 作者：PragmaGCC (赞：2)

网络流板子，使用 Dinic 算法

## 定义

定义一个网络 $G$ 的**残量网络** $G'$ 为其所有节点和剩余流量 $> 0$ 的边构成的网络。

定义**增广路**为残量网络中的边。

## EK 算法

大体思路就是 BFS 寻找增广路，然后对其增广（走过这条边）。

在残量网络上，从源点出发进行 BFS 直到遇到汇点，然后增广。

注意到这里不一定一次找到最优解，我们在增广时建立**反向边**，目的是让我们有反悔的机会。

## Dinic 算法

Dinic 算法对 EK 进行了改进。

在每次寻找增广路前，我们使用 BFS 对图进行分层。随后我们使用 DFS 寻找增广路。显然，如果汇点的层数为 0 时增广结束。对于增广失败的边，可以在层数上打标记，使效率提升。

这样做的好处就是最多进行 $n-1$ 次增广即可得到答案。并且，由于我们每次增广了一条路后，就不可能再增广第二次，下一次增广可以直接跳过。这个优化叫做**当前弧优化**。

还有一个好处就是，我们可以充分利用剩余流量，找出其它的增广路。这被称为**多路增广**。

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cstring>
using namespace std;
#define int long long
const int N = 205, M = 5005, INF = 0x3f3f3f3f3f3f3f3f;
int st, ed, n, m;
struct Edge {
	int to, next;
	int weight;
} e[M << 1];
int head[N], ecnt = 1;
void addedge(int from, int to, int w) {
	e[++ecnt] = (Edge) { to, head[from], w };
	head[from] = ecnt; 
}
queue<int> q;
int flow[N], cur[N], dep[N];
bool bfs(int s) {
	memset(dep, 0, sizeof(dep));
	while (q.size()) q.pop();
	q.push(s);
	dep[s] = 1;
	while (!q.empty()) {
		const int x = q.front();
		q.pop();
		for (int i=head[x]; i; i=e[i].next) {
			const int y = e[i].to;
			if (!e[i].weight || dep[y]) continue;
			dep[y] = dep[x] + 1;
			q.push(y);
		}
	}
	if (dep[ed]) {
		for (int i=1; i<=n; i++) cur[i] = head[i];
		return 1;
	}
	return 0;
}
int dfs(int x, int f) {
	if (x == ed || !f) return f;
	int res = 0;
	for (int i=cur[x]; i; i=e[i].next) {
		const int y = e[i].to;
		cur[x] = i;
		if (dep[y] != dep[x] + 1) continue;
		int delta = dfs(y, min(f, e[i].weight));
		if (delta) {
			f -= delta, e[i].weight -= delta, e[i^1].weight += delta;
			res += delta;
			if (!f) break;
		}
	}
	return res;
}
int dinic() {
	int res = 0;
	while (bfs(st)) res += dfs(st, INF);
	return res;
}
signed main(void) {
	scanf("%lld%lld%lld%lld", &n, &m, &st, &ed);
	for (int i=1, u, v, w; i<=m; i++) {
		scanf("%lld%lld%lld", &u, &v, &w);
		addedge(u, v, w), addedge(v, u, 0);
	}
	printf("%lld\n", dinic());
	return 0;
}
```

---

## 作者：超级玛丽王子 (赞：1)

这是一道模板题。本题的数据范围很小，并不需要使用 Dinic, ISAP 甚至 HLPP 等高端的方法，只需要最朴素的 Edmonds-Karp 算法。（Ford-Fulkerson 没有进行测试，但是复杂度级别应该能过）。

# Ford-Fulkerson 算法

Ford-Fulkerson 算法其实是一个非常朴素的思想。其核心步骤是**寻找增广路**，其实就是搜索一条从源点 $s$ 到汇点 $t$ 的路径，使得途径的每一条边都能通过至少 $1$ 个流量。这样相当于把总的最大流增加了 $1$。

实际迭代的过程中，要在每一次搜索到路径后将这条边原本的最大容量减 $1$。获得的新图网络称为**残留网络**。之后的迭代就在残留网络上进行，不断更新，知道找不到新的增广路，则迭代结束，最大流被找到。

然而如果直接在原图上减，会得到错误的结论。这是因为，每一次迭代是**有后效性**的。如果这条增广路不是最大流经过的增广路，他就会占住正确的其他路径的流量。

怎样解决这个问题呢？我们需要对每条边补充一条**方向相反，流量为已用流量**的边。这样做的原理可以理解为：一条水沟虽然是单向的，但是由于搜到的增广路可能是错误的，需要反向的水流**借道**把错误占用的流量**抵消掉**。

这个算法的主要内容就是寻找增广路，时间复杂度的瓶颈也在于增广路。如果采用 DFS，可能会陷入长时间的无效迭代，导致极低的算法效率。

如果用 BFS 来实现，迭代次数将大大降低。

# Edmonds-Karp 算法

如果用 BFS 来实现 Ford-Fulkerson 算法，就是 Edmonds-Karp 算法。

时间复杂度：寻找增广路需要 $O(VE)$ 次迭代，而每次 BFS 复杂度是 $O(E)$，因此总复杂度是 $O(VE^2)$，可以解决 $V\le 50,E\le1000$ 的问题。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e17,N=250;
int n,m,s,t,g[N][N],pre[N];
inline int min(int x, int y) {
    return x<y?x:y;
}
inline int read() {
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    int x=0;
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}
int bfs()  {
	int flow[N];
	memset(pre,-1,sizeof(pre));
	flow[s]=inf;pre[s]=0;
	queue<int>Q; Q.push(s);
	while(!Q.empty()) {
		int u=Q.front();Q.pop();
		if(u==t) break;
		for(int i=1;i<=m;++i)
			if(i^s&&g[u][i]&&pre[i]==-1) {
				pre[i]=u,Q.push(i);
				flow[i]=min(flow[u],g[u][i]);
			}
	}
	if(pre[t]==-1) return -1;
	return flow[t];
}
int mflow() {
	int Mflow=0;
	while(true) {
		int f=bfs();
		if(f==-1) break;
		int cur=t;
		while(cur^s) {
			int fa=pre[cur];
			g[fa][cur]-=f;
			g[cur][fa]+=f;
			cur=fa;
		}
		Mflow+=f;
	}
	return Mflow;
}
signed main(void) {
	n=read(),m=read(),s=read(),t=read();
	for(int i=0;i<m;++i) {
		int u,v,w;
		u=read(),v=read(),w=read();
		g[u][v]+=w;
	}
	printf("%lld\n",mflow());
	return 0;
}
```

~~直接从主题库板子粘过来的 maxn 都没改~~

# 其它算法

求解最大流还可以用 Dinic 和 ISAP 算法。两种算法的时间复杂度都是 $O(V^2E)$，但是 ISAP 稍快一些。

此外还有 HLPP 算法，MPM 算法等等。

---


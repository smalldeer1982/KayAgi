# [图论与代数结构 502] 网络流_2

## 题目描述

给定 $n$ 个点， $m$ 条边，给定每条边的容量，求点 $s$ 到点 $t$ 的最大流。

**注意，图可能存在重边。**


## 说明/提示

对于所有数据，$1 \le n \le 100$，$1 \le m \le 5000$，$0 \le c \le 2 ^ {31} - 1$。

## 样例 #1

### 输入

```
7 14 1 7
1 2 5
1 3 6
1 4 5
2 3 2
2 5 3
3 2 2
3 4 3
3 5 3
3 6 7
4 6 5
5 6 1
6 5 1
5 7 8
6 7 7
```

### 输出

```
14```

## 样例 #2

### 输入

```
10 30 3 7
10 2 18652
8 9 2560
8 9 13734
5 6 23138
9 7 29606
5 8 21673
1 9 11596
3 2 9441
3 7 4829
5 8 24437
1 2 31111
4 10 26213
2 7 31808
1 9 10841
6 8 10758
3 5 11887
4 2 1362
4 1 18182
4 8 18156
10 6 11015
2 7 2640
10 6 27726
10 6 21615
5 1 5959
3 1 19857
5 4 1862
8 9 13830
3 10 22152
4 10 5221
5 2 24065
```

### 输出

```
68166```

## 样例 #3

### 输入

```
6 18 4 6
4 3 31298
4 5 25605
1 6 8332
1 6 1205
2 3 15950
4 3 1418
1 6 5329
1 6 29907
5 6 22281
1 2 12609
4 1 4033
1 2 12122
4 5 5997
5 6 19507
1 5 19306
2 6 978
5 6 26343
5 3 23224
```

### 输出

```
35635```

# 题解

## 作者：Legitimity (赞：15)

~~来一个 HLPP 的题解~~

HLPP （最高标号预流推进）应该是常见最大流算法里效率最高的，最差复杂度为 $O(n^2\sqrt m)$（然而随机数据下跑的没 dinic 快），虽然裸的 HLPP 很容易被卡到这个上界，但是经过一些优化的 HLPP 还是基本能做到平均速度和 dinic 持平。

------------

### 基本思想

EK、FF、dinic、ISAP 等算法都属于**增广路算法**。而 HLPP 是一种**推送-重贴标签**算法（又称预流推进）。现在效率最高的几种最大流算法几乎都是推送-重贴标签算法。推送-重贴标签算法在算法过程中并不满足网络的流量守恒性质，即存在流入一个节点的流量大于流出该节点流量的情况，因为在执行过程中，推送-重贴标签算法始终维护着一个函数**预流**（preflow）。

众所周知，网络的流量守恒性质是：在网络 $G(E,V)$ 中，对于 $u\in V-\{s,t\}$ 有：

$$\sum_{v\in V}f(v,u)-\sum_{v\in V}f(u,v)=0$$

而在推送-重贴标签算法过程中，则弱化了这个条件：

$$\sum_{v\in V}f(v,u)-\sum_{v\in V}f(u,v)\geq0$$

即每个节点可以暂时储存一定的流量（但不能透支），而我们称：

$$e(u)=\sum_{v\in V}f(v,u)-\sum_{v\in V}f(u,v)$$

为 $u$ 的**超额流**（excess flow）。

不难发现，在最大化流量且 $u\in V-\{s,t\}$ 的 $e(u)$ 都为 $0$ 时，$e(t)$ 即为整张网络的最大流。

那么我们的目标就是不断推送流量，且保证最终 $e(u)$ 为 $0$。



------------

### 算法流程
大家可能就立刻会想到一种做法：

每个节点都把流向自己的边流满，多余的流量作为超额流暂时储存，一旦有机会就马上推向周围的节点；因为有反向边的存在，从 $s$ 流出的多余流量最终一定也会回到 $s$，那么最终整张网络也能平衡。

但是，设想一种情况：如果 $u$ 把超额流推给了 $v$，但 $v$ 不讲武德，接化发把流量原封不动的还了回去，然后 $u$ 再推，$v$ 再还……一直推到 TLE。

那么我们就考虑和 dinic 差不多，将整张网络进行分层，每一层节点的超额流只能推给下一层节点。

令 $h(u)$ 为高度函数，表示节点 $u$ 的高度（height），预流推进的操作只允许推给 $v\in V$ 且 $h(v)=h(u)-1$ 的节点，那么流量就不会来回推了， $h(s)$ 设为最高。

但是，这样又会有另一种情况：在流量推来推去的过程中，有个节点 $u$ 特别惨，满足 $v\in V$ 且 $h(v)=h(u)-1$ 的边 $(u,v)$ 要么就没有，要么已经满流了，而此时她上一层的节点又推给她很多超额流，而这些超额流在她手里无论如何都推不出去了。

怎么办？

我们的算法叫推送-**重贴标签**算法。

那就强行把她抬起来，把流量推回去。

（你可以想象一个场面，一个盆地或一个断层被顶出，变成一座山）

每次遇到流不动的情况，那么就找到一个最低的高度，让她恰好能流掉自己的超额流。

这就是重贴标签（relabel）的过程

然后呢？没有然后了。

------------
### 关于 HLPP 的细节

上面的都是推送-重贴标签算法的基础模型，如果不加优化可以轻松的达到 $O(n^2m)$ 的~~优秀~~复杂度，距离我们 HLPP 的 $O(n^2\sqrt m)$ 还有一段距离。

那么还要注意什么？

1. 关于 $h$ 函数初值的处理。

如何给 $h$ 赋一个合适的初值？可以直接将 $h(s)\gets n$ ，其它的都是 $0$，在重贴标签的过程中不断调整。

但这样不够优秀，在初始时可以像 dinic 一样 bfs 一遍，将分层图的层次作为 $h$。这样可以节省大量时间

2. 关于怎么让流量从高处向低处流？

这个问题由 R·E·Tarjan （怎么又是他）在 1986 年解决，这也是 HLPP 名字的由来。bfs 可以有层次的处理信息。我们可以建立一个以 $h$ 为键值的优先队列，每次取最高的节点进行预流推进。因为其它节点都比当前节点矮，不会被重贴标签，处理起来方便；而且这样能保证每个点入队的次数最少，因为矮的节点会在队列中被反复推进，而不是出队又进队。

3. 关于重贴标签的 gap 优化。

学过 ISAP 的人大概都知道 gap 优化，HLPP 的 gap 优化和 ISAP 有点像。假设我们给 $u$ 重贴标签的过程中，$h(u)$ 这一高度没有其它节点了，由于只有满足 $h(v)=h(u)-1$ 的边 $(u,v)$ 的边才会被预流推进，那么高度为 $h(u)+1$ 就永远无法把自己的超额流向下推了，以此类推，所有 $h(v)>h(u)$ 的节点的超额流都流不动了，这些节点未来都需要重贴标签，不知情的节点还会互相推流量，然而这些流量都流不动。那么还不如现在就重贴。把她们的高度设为 $n+1$ ，这样一来，她们的流量就可以直接还给 $s$ 节点。

代码（细节比较多，可以对照查看）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define ll long long
#define ull unsigned ll
#define inf 0x7f7f7f7f
#define sit set<int>::iterator
inline void file(){
	freopen("test.in","r",stdin);
}
char buf[1<<21],*p1=buf,*p2=buf;
inline int getc(){
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
}
inline ll read(){
	rg ll ret=0,f=0;char ch=getc();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getc();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getc();}
    return f?-ret:ret;
}
struct node{
	int nex,to;
	ll val;
}e[500005<<1];
int n,m,u,v,w,s,t,cnt=1,head[50005];
int h[50005],gap[50005];  //h 表示高度，gap 表示该高度的节点数。 
bool vis[50005];  //vis 表示是否在队中。 
ll maxflow,excess[50005];  //excess 表示超额流 
inline void add(int u,int v,ll w){
	e[++cnt].nex=head[u];
	e[cnt].to=v;
	e[cnt].val=w;
	head[u]=cnt;
}
bool init(){  //初始 bfs 给图分层，注意是从 t 倒着搜。 
	queue<int> q; 
	memset(h,0x7f,sizeof(h));
	h[t]=0; q.push(t);
	while(!q.empty()){
		int now=q.front(); q.pop();
		for(rg int i=head[now];i;i=e[i].nex){
			if(e[i^1].val&&h[e[i].to]-1>h[now]){
				q.push(e[i].to);
				h[e[i].to]=h[now]+1;
			}
		}
	}
	return h[s]!=inf;
}
struct ty{
	int v;
	bool operator<(const ty& __)const{
		return h[v]<h[__.v]; 
	}
};
inline ty make(int x){
	return (ty){x};
}
priority_queue<ty> pq;  //以 h 为键值的优先队列。 
inline void push(int x){  //预流推进操作。 
	for(rg int i=head[x];i;i=e[i].nex){
		if(!excess[x]) break;  //推完了。 
		if(!e[i].val||h[e[i].to]!=h[x]-1) continue;  //不能推。 
		ll tmp=min(e[i].val,excess[x]);  //尽可能的推。 
		e[i].val-=tmp;
		e[i^1].val+=tmp;
		excess[x]-=tmp;
		excess[e[i].to]+=tmp;
		if(e[i].to!=s&&e[i].to!=t&&!vis[e[i].to]){  //被推的节点自己也会超额，入队等待推别人的机会。 
			vis[e[i].to]=1;
			pq.push(make(e[i].to));
		}
	}
}
inline void relabel(int x){
	h[x]=inf;
	for(rg int i=head[x];i;i=e[i].nex)
		if(e[i].val&&h[e[i].to]<h[x]-1)
			h[x]=h[e[i].to]+1;  //找到最矮的能推别人的位置。 
}
void HLPP(){
	if(!init())  //不连通。 
		return maxflow=0,void();
	h[s]=n;
	for(rg int i=1;i<=n;++i)
		if(h[i]!=inf) ++gap[h[i]];
	for(rg int i=head[s];i;i=e[i].nex){
		if(!e[i].val||h[e[i].to]==inf) continue;
		ll tmp=e[i].val;
		e[i].val-=tmp; 
		e[i^1].val+=tmp;
		excess[s]-=tmp;
		excess[e[i].to]+=tmp;
		if(e[i].to!=s&&e[i].to!=t&&!vis[e[i].to]){  
			vis[e[i].to]=1;
			pq.push(make(e[i].to));
		}
	} //同 push 函数，对于 s 的 push 特殊处理。 
	while(!pq.empty()){
		int now=pq.top().v; pq.pop();
		vis[now]=0;
		push(now);
		if(!excess[now]) continue; //超额流推完了。 
		if(!--gap[h[now]])  //gap 优化。 
			for(rg int i=1;i<=n;++i)
				if(i!=s&&i!=t&&h[i]>h[now]&&h[i]<n+1)
					h[i]=n+1;
		relabel(now); 
		++gap[h[now]];  //重贴标签。 
		vis[now]=1;
		pq.push(make(now)); //没推完，入队继续等待推别人的机会。 
	}
	maxflow=excess[t];
}
int main(){
    n=read(); m=read(); s=read(); t=read();
    for(rg int i=1;i<=m;++i){
    	u=read(); v=read(); w=read(); 
    	add(u,v,w);
    	add(v,u,0);
	}
	HLPP();
	printf("%lld",maxflow);
    return 0;
}
//If you're gonna replace me,at least have the audacity to kill me thoroughly.
```


---

## 作者：Mars_Dingdang (赞：5)

裸的网络流模板题，用 Dinic 即可。

## 题目大意
给定一张 $n$ 个节点，$m$ 条边的网络，以及源点、汇点 $s,t$，求 $s$ 到 $t$ 的最大流。

## 大体思路
### 网络流概念
一个网络 $G=(V,E)$ 是一张有向图，每条边 $(x,y)$ 有一个权值 $c$，表示边的容量（capability)。图中有两个特殊节点 $s,t$，表示源点和汇点（source, sink)。

设流量函数为 $f(x,y),\ x,y\in V$，则满足
1. $f(x,y)\le c(x,y)$，即流量限制。
2. $f(x,y)=-f(y,x)$，即斜对称（反对称）。
3. $\forall x\neq S,x\neq T,\sum_{(u,x)\in E}f(u,x)=\sum_{(x,v)\in E}f(x,v)$，即流量守恒。

$(x,y)\in E$，称 $f(x,y)$ 表示该边的流量，$c(x,y)-f(x,y)$ 表示该边的剩余容量。

有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点），就是我们的最大流问题。最大流的常用算法有 EK, Dinic, ISAP, 其中前者复杂度为 $O(nm^2)$，后两者的理论复杂度上界为 $O(n^2m)$，但实际效率均远高于此。

### Dinic 与增广路
求解最大流之前，我们先认识以下增广路的概念。

**增广路** 指的是，从源点到汇点，只要有 $flow>0$ 流过去，这条路就是增广路。在一些最大流算法中，就是将这些路 **增广** （意思就是走掉这条路，带走的流量肯定就是这条路的最小流量）。

在任意时刻，网络中所有节点以及剩余容量大于 0 的边构成的子图称为 **残量网络**。

EK 算法每轮会遍历整个残量网络，但只找出一条增广路，因此可以进一步优化。由此便诞生了 Dinic。

BFS 中可以得到一个节点的层次 $d_x$，表示 $S\to x$ 经过的最少边数。在残量网络中，满足 $d_y=d_x+1$ 的边 $(x,y)$ 构成的子图是分层图，其显然是 DAG。

Dinic 算法是不断重复以下流程，直到 $S$ 在残量网络上无法达到 $T$：
1. 在残量网络上 BFS 得到分层图；
2. 在分层图上进行 DFS 寻找增广路，回溯时更新剩余容量（也就是说对于每条边只需记录剩余容量 $c_i$ 即可）。

在此过程中，有一些优化：
1. 多路增广：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。

2. 当前弧优化：增广时，一条边不可能被增广第二次，所以可以通过更新邻接表临时表头跳过这些边。

3. 满流剪枝：增广时，对于一条边增广失败，可以直接将对应节点的层数设置为 $-1$，这样不会再对这些边进行增广。

### 网络流与二分图匹配
网络流是求解二分图匹配问题的常用手段，也是一种通用手段。由于一组匹配是每个左部点出一条边，每个右部点入一条边，等价于建立超级源点和超级汇点 $s,t$，由 $s$ 向所有左部点连流量为 $1$ 的边，由所有右部点向 $t$ 连流量为 $1$ 的边，原图中边 $(x,y)$ 对应 $x$ 向 $y$ 连流量为 $1$ 的边，求最大流即为最大匹配。

特别地，Dinic 算法在求解上述二分图最大匹配问题时的复杂度上界为 $O(m\sqrt n)$，实际更快。

## 完整代码
```cpp
#include<cstdio>
#include<queue>
using namespace std;
#define rep(ii,aa,bb) for(re int ii=aa;ii<=bb;ii++)
#define Rep(ii,aa,bb) for(re int ii=aa;ii>=bb;ii--)
typedef long long ll;
typedef unsigned long long ull;
const int maxn=1e4+5;
const ll inf=1ll<<60;
namespace IO_ReadWrite{
	#define re register
	#define gg (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
	char buf[1<<21],*p1=buf,*p2=buf;
	template <typename T>
	inline void read(T &x){
		x=0;re T f=1;re char c=gg;
		while(c>57||c<48){if(c=='-') f=-1;c=gg;}
		while(c>=48&&c<=57){x=(x<<1)+(x<<3)+(c^48);c=gg;}
		x*=f;return;
	}
	inline void ReadChar(char &c){
		c=gg;
		while(!isalpha(c)) c=gg;
	}
	template <typename T>
	inline void write(T x){
		if(x<0) putchar('-'),x=-x;
		if(x>9) write(x/10);
		putchar('0'+x%10);
	}
	template <typename T>
	inline void writeln(T x){write(x);putchar('\n');}
}
using namespace IO_ReadWrite;
int ver[maxn],head[maxn],nxt[maxn],c[maxn],tot=1;
inline void add(int u,int v,int w){
	ver[++tot]=v;c[tot]=w;nxt[tot]=head[u];head[u]=tot;
	ver[++tot]=u;c[tot]=0;nxt[tot]=head[v];head[v]=tot;
}
int d[maxn],cur[maxn],n,m,s,t;
inline bool bfs(){// BFS 进行分层 
	memset(d,-1,sizeof(d));
	queue<int> q;
	q.push(s);d[s]=1;cur[s]=head[s];
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=nxt[i]){
			int v=ver[i];
			if(c[i]&&d[v]==-1){
				d[v]=d[u]+1;q.push(v);
				cur[v]=head[v];
				if(v==t) return 1;
			}
		}
	}
	return 0;
}
inline int dfs(int u,int limit){// DFS 进行增广
	if(u==t||limit==0) return limit;
	int flow=0; // 多路增广
	for(int i=cur[u];i&&flow<limit;i=nxt[i]){
		cur[u]=i;// 当前弧优化
		int v=ver[i];
		if(d[v]==d[u]+1&&c[i]){
			int f=dfs(v,min(c[i],limit-flow));
			if(!f) d[v]=-1;// 满流剪枝
			flow+=f;c[i]-=f;c[i^1]+=f;
		}
	}
	return flow;
}
inline ll dinic(){ // 求最大流
	ll maxflow=0,flow=0;
	while(bfs()) while(flow=dfs(s,inf)) maxflow+=flow;
	return maxflow;
}
int main(){
	read(n);read(m);read(s);read(t);
	for(int i=1,u,v,w;i<=m;i++){
		read(u);read(v);read(w);
		add(u,v,w);
	}
	writeln(dinic());
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：4)

作为一道模板题，题解怎么可以没有 EK 算法呢？

EK 算法是对 FF 算法的一种改进，这两种算法的思想是：每次对网络进行一次遍历，找出最小的残量（从源点到汇点），进行增广。

FF 算法核心代码：

```cpp
int dfs(int u,int in){
    if(u==t){
        ans+=in;
        flag=1;//找到增广路
        return in;
    }
    vis[x]=1;
    for(int i=fir[u];i;i=nxt[i]){
        int v=to[i];
        if(vis[v]||flow[i]==0) continue;
        int res=dfs(v,min(in,flow[i]));//流量受最小的边的限制
        if(flag){
            flow[i]-=res;
            flow[i^1]+=res;//反向边进行加，方便进行反悔操作
            return res;
        }
    }
    return 0;
}
void ff(){
    do{
        memset(vis,0,sizeof(vis));
        flag=0; 
        dfs(s,INF);
    }while(flag);
}
```
由于 FF 算法每次找到的增广路不是最短路径，这导致一条边成为关键边的最大次数为 $ \max \{c_1,c_2,c_3,... \ ,c_{m-1},c_m \} \div 2$ （ $m$ 为边数， $c_i$ 为第 $i$ 条边的流量）。这会被流量卡，复杂度很糟糕。

所以 EK 采用了 BFS 来寻找增广路，这确保了每次找到的增广路都是最短路径。使得复杂度下降。

复杂度分析：（定义关键边为：该边的残量为增广路的残量的边）

从边 $(u,v)$ 成为关键边到下一次成为关键边，原结点到 $u$ 的距离至少增加 $2$ 个单位。由于从源结点 $s$ 到结点 $u$ 的的最短路径中间结点不可能包括 $s,u,t$ ，从 $s$ 到 $u$ 的最短路径最长为 $n-2$ 。

一条边成为关键边的最大可能是 $(n-2) \div 2$ ，一共有 $m$ 条边，关键边总数为 $O(nm)$ ，BFS 复杂度为 $O(m)$ ，所以 EK 算法的复杂度上界是 $O(nm^2)$ 。


代码如下：
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
const int maxn=105;
const int inf=0x7fffffff;
int r[maxn][maxn],pre[maxn],m,n;
bool vis[maxn];
bool bfs(int s,int t) {
	int u;
	queue<int>q;
	memset(pre,0,sizeof(pre));
	memset(vis,0,sizeof(vis));
	pre[s]=s;
	vis[s]=true;
	q.push(s);
	while(!q.empty()) {
		u=q.front();
		q.pop();
		for(int i=1; i<=n; i++) {
			if(r[u][i]>0&&!vis[i]) {//有流量才能流 
				pre[i]=u;
				vis[i]=true;
				if(i==t) return true;
				q.push(i);
			}
		}
	}
	return false;
}
int ek(int s,int t) {
	int flow=0,d;
	while(bfs(s,t)) {
		d=inf;
		for(int i=t; i!=s; i=pre[i])
			d=(d<r[pre[i]][i]?d:r[pre[i]][i]);//残量取决于最小边的流量 
		for(int i=t; i!=s; i=pre[i]) {
			r[pre[i]][i]-=d;
			r[i][pre[i]]+=d;//反边添加流量，以进行反悔操作。 
		}
		flow+=d;
	}
	return flow;
}
signed main() {
	int s,t,u,v,w;
	scanf("%lld%lld%lld%lld",&n,&m,&s,&t);
	for(int i=1; i<=m; i++) {
		scanf("%lld%lld%lld",&u,&v,&w);
		r[u][v]+=w;//重边处理 
	}
	printf("%lld\n",ek(s,t));
	return 0;
}
```


---

## 作者：HerikoDeltana (赞：4)

# B3607 网络流 2

这是一篇 ISAP 题解。

## ISAP 

何为 ISAP？

ISAP 算法和 EK、FF、dinic 这些算法一样，都属于增广路算法。也就是说其实她们本身的思路基本是一致的，只不过实现不同。

ISAP 的全名为 Improved Shortest Augumenting Path，这个 Improved 就体现在她相比于 Dinic，只需要一次 BFS。

这里就不再展开关于 Dinic 的过程描述，但由于下文涉及到 Dinic，这里仍建议大家在学习 ISAP 之前先保证已经学过了 Dinic 的流程，并且已经自己写过了一遍代码，下面的叙述中我就假定大家都会 Dinic 罢。

这里给出 [Oi-Wiki](https://oi-wiki.net/graph/flow/max-flow/#dinic) 以供大家先复习一下 Dinic 。

## ISAP 的过程

1. 从汇点 $t$ 到源点 $s$ 跑**一次** BFS 进行深度标记

2. 从源点 $s$ 开始跑 DFS 

第一步，和 Dinic 的从 $s$ 到 $t$ 跑正好相反。这样做是为了不再去反复的通过 BFS 对图进行分层。

于是我们只需要把 Dinic 的代码进行一定的修改就能完成 ISAP 的第一步：

```cpp
struct node
{
    LL to,nex,val;
}

r[MXX<<1];

LL head[NXX],cnt(1),dis[NXX],now[NXX],n,m,maxflow,s,t,gap[NXX];

queue<LL> qwq;

I void BFS()
{
    qwq.push(t);dis[t]=0;now[t]=head[t];gap[0]=1;
    while(qwq.size())
    {
        LL x=qwq.front();qwq.pop();
        for(R LL i=head[x];i;i=r[i].nex)
        {
            if(!dis[r[i].to] and r[i].to!=t)
            {
                LL y=r[i].to;
                qwq.push(y);
                now[y]=head[y];
                dis[y]=dis[x]+1;
                ++gap[dis[y]];
            }
        }
    }
}
```

这里有了一个新的数组 `gap[\ ]`，`gap[i]` 代表的意义是**深度为 $i$ 的结点的数量**，这是一个主要的优化。

因为第二步依然是 DFS 去走增广路，于是前面的部分和 Dinic 是一样的，只是最后稍有不同：

```cpp
LL ISAP(LL x,LL flow)
{
    if(x==t) Heriko flow;
    LL rst=flow,k,i,y,mindis=inf;
    for(i=now[x];i and rst;i=r[i].nex)
    {
        y=r[i].to;
        if(r[i].val>0)
        {
            mindis=Hmin(mindis,dis[y]);
            if(dis[y]+1==dis[x])
            {
                k=ISAP(y,Hmin(rst,r[i].val));
                r[i].val-=k;
                r[i^1].val+=k;
                rst-=k;
            }
        }
        
    }
    if(!rst) Heriko flow;
    //可以看到从这里往上的部分和 Dinic 的 DFS 基本一致
    --gap[dis[x]];
    if(!gap[dis[x]]) dis[s]=n+1;
    if(mindis==inf) dis[x]=n;
    else dis[x]=mindis+1;
    ++gap[dis[x]];
    Heriko flow-rst;
}
```
前半部分的 DFS 和 Dinic 基本是一致的，只不过对层级 `dis` 的判断从 `dis[x]+1==dis[y]` 改为了 `dis[y]+1==dis[x]`，这只是因为我们 BFS 分层的顺序不同了而已。

真正变化的就是 for 循环后面的一段（即上面代码中注释以下的部分）。

首先，既然程序能够运行到这里，说明本次 DFS 的起点 $x$ 相连的点**都已经走过了一遍并且流量还有剩余**。那么此时我们对 $x$ 的深度进行修改，然后更新 `gap[dis[x]]`。

因为 ISAP 的 DFS 是按照深度走的，所以路径上的点的深度一定是连续的才能到达深度为 0 的 $t$，如果中间有任意一层的点不存在，我们都无法到达 $t$。因此当修改后的 `gap[dis[x]]==0` 的时候说明这个深度已经没有点了，我们直接结束本次 DFS，这样能够有效的增加我们算法的效率。

这里给出一些图帮助理解：

![](https://pic.imgdb.cn/item/60e436b15132923bf8b70806.png)

ISAP 的那一次 BFS 会将此图分层（红色）：

![](https://pic.imgdb.cn/item/60e4372e5132923bf8b9174f.png)

显然我们只能走深度连续的下路：

![](https://pic.imgdb.cn/item/60e43ade5132923bf8c838e7.png)

然后我们更新结点的深度和边的容量，得到新图：

![](https://pic.imgdb.cn/item/60e43ade5132923bf8c838bd.png)

然后走上路：

![](https://pic.imgdb.cn/item/60e43ade5132923bf8c838ac.png)

然后我们更新深度信息和边的容量，发现此时这张图出现了断层，停止 DFS。

![](https://pic.imgdb.cn/item/60e43ade5132923bf8c8389e.png)

![](https://pic.imgdb.cn/item/60e43ae15132923bf8c84581.png)

ISAP 走这个过程非常简单，但是如果是 Dinic 就需要三遍 BFS，两遍 DFS！

也就是说 ISAP 利用深度更新少了整整两次分层过程！

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string.h>
#include <queue>
#define Heriko return
#define Deltana 0
#define Romanno 1
#define S signed
#define LL long long
#define R register
#define I inline
#define CI const LL
#define mst(a, b) memset(a, b, sizeof(a))
#define ON std::ios::sync_with_stdio(false)
using namespace std;

template<typename J>
I void fr(J &x)
{
    short f=1;
    char c=getchar();
    x=0;
    while(c<'0' or c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while (c>='0' and c<='9') 
    {
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    x*=f;
}

template<typename J>
I void fw(J x,bool k)
{
    if(x<0) putchar('-'),x=-x;
    static short stak[35];
    short top=0;
    do
    {
        stak[top++]=x%10;
        x/=10;
    }
    while(x);
    while(top) putchar(stak[--top]+'0');
    if(k) putchar('\n');
    else putchar(' ');
}

template<typename J>
I J Hmin(J x,J y) {Heriko x<y?x:y;}

template<typename J>
I void Clear(queue<J> &x) {while(x.size()) x.pop();}

CI inf=998244353,MXX=5005,NXX=205;

struct node
{
    LL to,nex,val;
}

r[MXX<<1];

LL head[NXX],cnt(1),dis[NXX],now[NXX],n,m,maxflow,s,t,gap[NXX];

queue<LL> qwq;

I void Ass_we_can(LL x,LL y,LL z)
{
    r[++cnt].to=y;r[cnt].nex=head[x];r[cnt].val=z;head[x]=cnt;
    r[++cnt].to=x;r[cnt].nex=head[y];r[cnt].val=0;head[y]=cnt;
}

I void BFS()
{
    qwq.push(t);dis[t]=0;now[t]=head[t];gap[0]=1;
    while(qwq.size())
    {
        LL x=qwq.front();qwq.pop();
        for(R LL i=head[x];i;i=r[i].nex)
        {
            if(!dis[r[i].to] and r[i].to!=t)
            {
                LL y=r[i].to;
                qwq.push(y);
                now[y]=head[y];
                dis[y]=dis[x]+1;
                ++gap[dis[y]];
            }
        }
    }
}

LL ISAP(LL x,LL flow)
{
    if(x==t) Heriko flow;
    LL rst=flow,k,i,y,mindis=inf;
    for(i=now[x];i and rst;i=r[i].nex)
    {
        y=r[i].to;
        if(r[i].val>0)
        {
            mindis=Hmin(mindis,dis[y]);
            if(dis[y]+1==dis[x])
            {
                k=ISAP(y,Hmin(rst,r[i].val));
                r[i].val-=k;
                r[i^1].val+=k;
                rst-=k;
            }
        }
    }
    if(!rst) Heriko flow;
    --gap[dis[x]];
    if(!gap[dis[x]]) dis[s]=n+1;
    if(mindis==inf) dis[x]=n;
    else dis[x]=mindis+1;
    ++gap[dis[x]];
    Heriko flow-rst;
}

LL z,y,x,flow;

S main()
{
    fr(n),fr(m),fr(s),fr(t);
    for(R LL i=1;i<=m;++i)
    {
        fr(z),fr(y),fr(x);
        Ass_we_can(z,y,x);
    }
    BFS();
    while(dis[s]<n)
    {
        for(R LL i=1;i<=n;++i) now[i]=head[i];
        maxflow+=ISAP(s,inf);
    }
    fw(maxflow,1);
    Heriko Deltana;
}

```

## 复杂度相关

ISAP 和 Dinic 的时间复杂度上界是一样的，都是 $O(n^2m)$，但是这个上界相对宽松，平均情况下达不到这个复杂度。

## End

本人可能描述欠佳，希望大家多多包涵。

第二次修改的时候题解交错了题，在这里对管理造成的麻烦致歉！！

第三次修改加入了一些图片以帮助理解。

第四、五次修改数学公式相关以符合题解排版格式，辛苦了管理大大这么认真审核

### 参考资料

* [究级的最大流算法：ISAP与HLPP](https://www.luogu.com.cn/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp) —— 钱逸凡

---


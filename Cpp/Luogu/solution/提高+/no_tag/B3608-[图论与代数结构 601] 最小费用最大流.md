# [图论与代数结构 601] 最小费用最大流

## 题目描述

给定 $n$ 个点，$m$  条边，给定每条边的容量和单位流量需要支付的费用，求点 $1$ 到点 $n$ 的最大流以及此时需要的最小费用。

**注意，图可能存在重边。**


## 说明/提示

对于所有数据，保证 $1 \le n \le 400$，$0 \le m \le 15000$，$0 \le w_i \le 2 ^ {31} - 1$，保证答案在 32 位有符号整数范围内。

本题数据较弱，不存在最小费用最大流的极限情况。

实现时，若使用 Bellman-Ford 算法可以考虑如下优化：若在某次迭代中所有 $\pi(i)$ 均保持不变，则不继续迭代。


## 样例 #1

### 输入

```
8 23
2 3 2147483647 1
1 3 1 1
2 4 2147483647 2
1 4 1 2
2 8 2 0
3 5 2147483647 3
1 5 1 3
3 6 2147483647 4
1 6 1 4
3 8 2 0
3 2 2147483647 0
4 6 2147483647 5
1 6 1 5
4 7 2147483647 6
1 7 1 6
4 8 2 0
4 2 2147483647 0
5 8 0 0
5 2 2147483647 0
6 8 0 0
6 2 2147483647 0
7 8 0 0
7 2 2147483647 0
```

### 输出

```
6 24```

## 样例 #2

### 输入

```
10 30
1 9 23 2
9 6 29 8
2 8 22 20
7 3 10 16
3 10 18 19
1 2 18 29
9 8 18 15
4 10 5 12
7 5 30 12
7 8 29 7
9 5 20 26
9 4 15 5
9 10 21 6
9 8 15 8
3 4 10 7
3 10 2 5
3 10 26 6
9 3 11 14
6 4 11 7
2 5 1 20
9 5 1 1
6 10 10 17
8 10 29 5
9 4 10 22
5 10 3 14
8 5 16 25
7 10 21 25
1 9 11 16
1 2 14 15
7 9 30 25
```

### 输出

```
57 1594```

## 样例 #3

### 输入

```
10 30
7 4 7 19
9 10 6 12
6 4 13 2
3 5 18 21
8 10 12 4
9 4 11 1
2 5 23 2
2 10 2 7
6 5 13 22
8 5 2 10
5 7 12 14
6 5 22 17
5 10 27 23
1 6 1 21
2 7 30 16
4 5 17 12
1 3 27 25
2 7 19 27
1 9 18 25
4 7 30 28
6 10 20 16
1 2 16 21
3 5 26 2
1 9 1 4
1 2 6 7
2 9 25 28
3 8 11 2
2 3 9 14
9 4 16 2
1 7 3 15
```

### 输出

```
47 1821```

# 题解

## 作者：听取MLE声一片 (赞：9)

这道题对 `EK+spfa` 算法不太友好，需要卡常才能通过。

（但是好歹卡过去了）

学习费用流（最小费用最大流）首先要学习网络流，可以看我的[题解](https://www.luogu.com.cn/blog/I-do-not-want-TLE/solution-b3606)，当然可以参考[经典日报](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)。

费用流和网络流的形态很类似，主体还是根据网络流。下面举一个例子（又是借鉴日报）。

假设 `s` 城有 `inf`个（穷）人想去 `t` 城，但是从 `s`到`t` 要经过一些城市才能到达，每条路有最大流量和权值（流量通过 `1` 所花费的代价），问最终最多能有多少人能到达 `t` 城。（由于是穷人）他们希望能在最多人到达 `t` 城的同时花最少的钱，问最少的钱是多少。

费用流就是在流量最大的情况下所花费的最小费用。

相较于网络流，费用流只是增加了权值，我们只需要解决权值问题即可。

这你想到了什么？代价最小？那就最短路！

因为有负权边，所以 `spfa` 是最方便的！而且需要进行多次 `spfa` 所以基本上不会全都卡成 $n^2$ 。

关于 `spfa` 它诈尸了！（大雾）

再详细一点，就是把 `bfs` 改成 `spfa` ,再松弛过程中记录路径即可。

这道板子题会卡一下 `EK+SPFA`，所以需要进行卡常。

下面是代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
namespace in{
    #ifdef faster
    char buf[1<<21],*p1=buf,*p2=buf;
    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    #else
    inline int getc(){return getchar();}
    #endif
    template <typename T>inline void read(T& t){
        t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
        while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
    }
    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
    char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
    inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
    inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
    template <typename T>void write(T x) {
        static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
        while (len>=0)putc(buf[len]),--len;
    }
}
const int inf=2147483647;
int maxn,cost;
int top=1,head[5001];
int dis[5001];
int n,m,s,t,book[5001];
int min(int a,int b){
	return a>b?b:a;
}
struct point{
    int v,w,val,next;
}a[100001];
struct b{
    int fa;
    int v;
}b[5001];
inline void add(int u,int v,int val,int w){
    a[++top].v=v;
    a[top].val=val;
    a[top].w=w;
    a[top].next=head[u];
    head[u]=top;
}
queue<int> q;
inline bool spfa(){
    for(register int i=1;i<=n;i++)
    	dis[i]=inf,b[i].fa=b[i].v=book[i]=0;
    dis[s]=0;
    q.push(s);
    book[s]=1;
    while(!q.empty()){
        int u=q.front();
        book[u]=0;
        q.pop();
        for(register int i=head[u];i;i=a[i].next){
            int v=a[i].v,w=a[i].w;
            if(a[i].val>0&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                b[v].fa=u,b[v].v=i;
                if(book[v]==0){
                    q.push(v);
                    book[v]=1;
                }
            }
        }
    }
    return dis[t]!=inf;
}
void EK(){
    while(spfa()){
        int minn=inf;
        for(register int i=t;i!=s;i=b[i].fa)
			minn=min(minn,a[b[i].v].val);
        for(register int i=t;i!=s;i=b[i].fa){
            a[b[i].v].val-=minn;
            a[b[i].v^1].val+=minn;
        }
        maxn+=minn;
        cost+=minn*dis[t];
    }
    return;
}
int main()
{
    in::read(n,m);
    s=1,t=n;
    int u,v,val,w;
    for(register int i=1;i<=m;i++){
        in::read(u,v,val,w);
        add(u,v,val,w);
        add(v,u,0,-w);
    }
    EK();
    printf("%d %d",maxn,cost);
    return 0;
}
```

---

## 作者：Usada_Pekora (赞：4)

本题属于模板题，可以用 dinic 费用流跑掉。

dinic 是一种比较高效的算法，是对 EK 算法的改进，其算法流程为：

1 、根据残量网络建立分层图（按到源点的最短距离分层，只有相邻的层之间有边）。

2 、在分层图中使用 DFS 进行增广直到不存在增广路。 

3 、重复以上步骤直到无法继续增广。

dinic 中需要用到反悔操作，反悔操作是将已经流出的流量流回去，具体方法为：对于 边 $i$ ，添加一条流量为 $0$ 的反向边 $i'$ ，每次从 $i$ 流出 $c$ 个单位流量后，则在 $i'$ 加上 $c$ 个单位的流量。

dinic 网络流代码：

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long
inline int read() {
	int x = 0, ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x;
}
const int N = 505, M = 10005;
inline int min(int x, int y) {
	return x < y ? x : y;
}
int n, m, s, t, f, r, maxf, q[N], dep[N], to[M], fir[N], cur[N], nxt[M], flow[M], cnt = 1;//边从1开始，这样 i ^ 1 对应的就是反向边
inline void add(int u, int v, int f) {
	to[++cnt] = v;
	flow[cnt] = f;
	nxt[cnt] = fir[u];
	fir[u] = cnt;
}
inline bool bfs() {
	q[f = r = 1] = s;
	memset(dep, 0, sizeof dep);
	dep[s] = 1;
	while(f <= r) {
		int u = q[f++];
		for(int i = fir[u]; i; i = nxt[i]) {
			if(!dep[to[i]] && flow[i]) {
				q[++r] = to[i];
				dep[to[i]] = dep[u] + 1;
			}
		}
	}
	return dep[t] != 0; //汇点非0则有增广路
}
inline int dfs(int u, int in) {
	if(u == t) return in;
	int res, out = 0;
	for(int i = cur[u]; i; i = nxt[i]) {
		cur[u] = i; //当前弧优化，已经走过的边不再走
		if(flow[i] && dep[to[i]] == dep[u] + 1) { //该条边是增广路中的边。
			res = dfs(to[i], min(flow[i], in)); //受增广路上最小流量的限制
			in -= res, out += res, flow[i] -= res, flow[i ^ 1] += res;
		}
	}
	if(out == 0) dep[u] = 0; //这个点没用
	return out;
}
inline void dinic() {
	while(bfs()) {
		memcpy(cur, fir, sizeof cur); 
		maxf += dfs(s, 0x7fffffff); //源点拥有无限的流量
	}
}
signed main() {
	n = read(), m = read(), s = read(), t = read();
	for(int i = 1, u, v, f; i <= m; i++) {
		u = read(), v = read(), f = read();
		add(u, v, f);
		add(v, u, 0);
	}
	dinic();
	printf("%lld", maxf);
	return 0;
}
```
复杂度分析：每次进行 BFS 分层时，层数是严格递增的，最多为 $n$ 层，所以 BFS 最多进行 $n$ 次；每条增广路之间的关键边（即该条增广路上流量最小的边）是互不相同的，可得增广路最大为 $m$ 条，对一条增广路 DFS 的复杂度为 $O(n)$ 。根据上述推论可得 dinic 算法的复杂度上界为 $O(n^2 m)$ ,实际运用中不会达到该上界，另外， dinic 在二分图中的复杂度约为 $O(m\sqrt n )$  。

网络流其实可以看作是一种所有边的费用都为 $1$ 的费用流，那么在费用流中也是类似的操作，只不过在求最大流的同时，走的都是费用最小的增广路，将建立分层图的 BFS 函数改成求最短路函数， 将判断中的 `dep[to[i]] == dep[u] + 1` 改成 ` dep[to[i]] == dep[u] + cost[i]` 即可。

另外，建边时添加的反向边，费用应为负（流回去的流量相当于没流，要把已经流过的钱给扣回来），因为费用存在负数，所以这里使用可以处理负权最短路的 spfa 最短路算法，当然用势函数处理过的 dijkstra 也是可以的。

至于时间复杂度呢，还是不变的 $O(n^2 m)$ ， 只是常数会稍大一些。

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
inline int read() {
	int x = 0, ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x;
}
inline int min(int a, int b) {
	return a < b ? a : b;
}
const int N = 405, M = 15005, INF = 2147483647;
int n, m, s, t, cnt = 1, fir[N], cur[N], nxt[M << 1], flow[M << 1], cost[M << 1], to[M << 1], dis[N], minc, maxf, q[N * M], f, r;
bool inq[N];
inline bool spfa() {//spfa最短路算法 
	memset(inq, 0, sizeof inq);
	memset(dis, 0x3f, sizeof dis);
	q[f = r = 1] = s;
	dis[s] = 0;
	inq[s] = true;
	int u;
	while(f <= r) {
		u = q[f++], inq[u] = false;
		for(int i = fir[u]; i; i = nxt[i]) {
			if(flow[i] && dis[to[i]] > dis[u] + cost[i]) {
				dis[to[i]] = dis[u] + cost[i];
				if(!inq[to[i]]) {
					q[++r] = to[i];
					inq[to[i]]=true;
				}
			}
		}
	}
	return dis[t] != 0x3f3f3f3f;//汇点可到达 
}
inline int dfs(int u, int in) {
	if(u == t) return in;
	int out = 0, res;
	inq[u] = true;//是否在搜索进程中 
	for(int i = cur[u]; i && in; i = nxt[i]) {
		cur[u] = i;//当前弧优化，已经走过的边不再走 
		if(!inq[to[i]] && flow[i] && dis[to[i]] == dis[u] + cost[i]) {
			res = dfs(to[i], min(in, flow[i])); //流量受一路上流量最小边的限制
			//正边流量流出，反向边加上相应的流量，方便流回 
			in -= res, out += res, flow[i] -= res, flow[i ^ 1] +=res, minc += cost[i] * res;//由于每次走的都是费用最小的增广路，所以在找出最大流的前提下，费用也是最小的 
		}
	}
	if(!out)dis[u] = 0x3f3f3f3f;//无法提供流量，则不再使用此点 
	inq[u] = false;
	return out;
}
inline void zkw_dinic() {
	while(spfa()) {
		memcpy(cur, fir, sizeof fir); 
		maxf += dfs(s, INF);
	}
}
inline void add(int u, int v, int f, int c) {//链式前向星存图 
	to[++cnt] = v;//去的点 
	flow[cnt] = f;//流量 
	cost[cnt] = c;//单位花费 
	nxt[cnt] = fir[u];
	fir[u] = cnt;
}
int main() {
	n = read(), m = read(), s = 1, t = n;
	for(int i = 1, u, v, f, c; i <= m; i++) {
		u = read(), v = read(), f = read(), c = read();
		add(u, v, f, c);//正边 
		add(v, u, 0, -c);//反向边的流量是 0 ，费用为负，方便流回 
	}
	zkw_dinic();
	printf("%d %d\n", maxf, minc);
	return 0;
}
```


---

## 作者：xvl_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B3608)

一道网络流题。

费用流板子题。费用流实际上是在给最大流套个最短路，而费用流一般边权会有负数，所以用 SPFA 算法，~~关于 SPFA，它复活了~~。

可以在最大流做 bfs 的时候将 SPFA 套上去。数据似乎比较凶残，建议使用 Dinic 来求最大流。

### Code

```cpp
#include <bits/stdc++.h>

namespace xvl_ { 
    #define ll long long
    #define IMAX 1e9
    #define LMAX 1e18
    void debug() { std :: cerr << "debug" << "\n"; } 
    template <typename T> inline T Max(T a, T b) { return a > b ? a : b; }
    template <typename T> inline T Min(T a, T b) { return a < b ? a : b; }
    template <typename T, typename... Args> inline T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }
    template <typename T, typename... Args> inline T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }
}
using namespace std;
using namespace xvl_;
struct Edge { ll to, r, c, cp; };
ll n, m, s, t, ans1, ans2;
ll dis[405], vis[405];
bool inq[405], isz[405];
vector <Edge> G[405];
void Add_Edge(ll u, ll v, ll c, ll w) {
    G[u].push_back({v, c, w, (int)(G[v].size())});
    G[v].push_back({u, 0, -w, (int)(G[u].size() - 1)});
}
bool check(ll s, ll t) { 
    queue <ll> q;
    fill(dis + 1, dis + 1 + 400, LMAX);
    dis[s] = 0, inq[s] = 1, q.push(s);
    while (!q.empty()) {
        ll cur = q.front();
        q.pop();
        inq[cur] = 0;
        for (auto v : G[cur]) {
            if (dis[cur] + v.c < dis[v.to] and v.r) {
                dis[v.to] = dis[cur] + v.c;
                if (!inq[v.to]) inq[v.to] = 1, q.push(v.to);
            }
        }
    }
    return dis[t] != LMAX;
}
ll aug(ll cur, ll now, ll& c) {
    ll flow = 0;
    if (cur == t) return now;
    isz[cur] = 1;
    for (ll& i = vis[cur]; i < G[cur].size(); i++) {
        Edge& v = G[cur][i];
        if (dis[v.to] != dis[cur] + v.c or isz[v.to] or !v.r) continue;
        int d = aug(v.to, Min(now - flow, v.r), c);
        v.r -= d, G[v.to][v.cp].r += d, flow += d, c += v.c * d;
        if (flow == now) break;
    }
    isz[cur] = 0;
    return flow;
}
int main() {
    /*
    freopen("InName.in", "r", stdin);
    freopen("OutName.out", "w", stdout);
    */
    ios :: sync_with_stdio(0);
    cin >> n >> m;
    s = 1, t = n;
    for (int i = 1; i <= m; i++) {
        ll u, v, c, w;
        cin >> u >> v >> c >> w;
        Add_Edge(u, v, c, w);
    }
    while (check(s, t)) {
        memset(vis, 0, sizeof vis);
        ans1 += aug(s, LMAX, ans2);
    }
    cout << ans1 << " " << ans2;
    return 0;
}
```


---

## 作者：Pwtking (赞：2)

经典模板题，有点卡常，所以我们使用 dinic 改的费用流。

因为费用流比最大流多的限制就是要求费用最小，所以我们可以跑最短路先实现费用最小，再跑最大流。

主要思想：将 dinic 的 bfs 部分换成 spfa。

为什么 dfs 部分需要 $vis$ 数组？

原 dinic 算法 bfs 将图进行分层，而 spfa 无法进行（和跑最大流意义一样的）分层，所以需 $vis$ 判重。

先上代码（使用当前弧优化）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x7fffffff
const ll maxn=100010;
ll n,m,s,t;
ll head[maxn],dis[maxn],vis[maxn];
ll inq[maxn];
struct edge {ll to,next,w,cost;}e[maxn];
ll cnte=1,cur[maxn];
ll Cost,ans;
inline void add(ll u,ll v,ll w,ll c) {
	e[++cnte].to=v,e[cnte].w=w,e[cnte].cost=c,e[cnte].next=head[u],head[u]=cnte;
	e[++cnte].to=u,e[cnte].w=0,e[cnte].cost=-c,e[cnte].next=head[v],head[v]=cnte;
}
inline bool spfa() {
	queue<ll> q;
	for (ll i=0;i<=n;++i) dis[i]=inf,cur[i]=head[i];
	q.push(s);
	dis[s]=0,inq[s]=1;
	while (!q.empty()) {
		ll u=q.front();
		q.pop();
		inq[u]=0;//加inq作用：优化运行效率
		for (ll i=head[u];i;i=e[i].next) {
			ll v=e[i].to;
			if (e[i].w>0&&dis[v]>dis[u]+e[i].cost) {
				dis[v]=dis[u]+e[i].cost;
				if (!inq[v]) q.push(v),inq[v]=1;
			}
		}
	}
	return (dis[t]!=inf);
}
inline ll dfs(ll u,ll sum) {
	vis[u]=1;
	if (u==t) return sum;
	ll tmp=0,used=0;
	for (ll i=cur[u];i;i=e[i].next) {
		cur[u]=i;
		ll v=e[i].to;
		if (e[i].w>0&&dis[v]==dis[u]+e[i].cost&&(!vis[v]||v==t)&&(tmp=dfs(v,min(e[i].w,sum-used)))) {
			e[i].w-=tmp,e[i^1].w+=tmp;
			Cost+=e[i].cost*tmp;
			used+=tmp;
			if (used>=sum) break;
		}
	}
	vis[u]=0;//小优化，加上之后快20ms
	return used;
}
inline void dinic() {
	ans=Cost=0;
	while (spfa()) ans+=dfs(s,inf);

//此处在不影响正确性情况下优化运行效率
}
inline ll in() {
    char a=getchar();
	ll t=0,f=1;
	while(a<'0'||a>'9') {if (a=='-') f=-1;a=getchar();}
    while(a>='0'&&a<='9') {t=(t<<1)+(t<<3)+a-'0';a=getchar();}
    return t*f;
}
signed main() {
	n=in(),m=in(),s=in(),t=in();
	for (ll i=1;i<=m;++i) {
		ll u=in(),v=in(),w=in(),c=in();
		add(u,v,w,c);
	}
	dinic();
	printf("%lld %lld",ans,Cost);
	return 0;
}
```


**注意！注意！注意！**

```cpp
while (spfa()) ans+=dfs(s,inf);
```
这一句只能在求单张图费用流使用，多张图的话需要在每次跑的时候加：
```cpp
memset(vis,0,sizeof(vis));
```

或者在 dinic 函数部分改为：

```cpp
while (spfa()) {
        ans+=dfs(s,inf);
        memset(vis,0,sizeof(vis));
		while (vis[t]);{
			memset(vis,0,sizeof(vis));
			ans+=dfs(s,inf);
		}
	}
    
   
```

警钟敲烂：因为 spfa 不能跑负环，所以这个算法不能跑带负环的图。



---

## 作者：yizhiming (赞：2)

题解数和通过率都少的可怜的入门与面试题，可见其毒瘤的卡常程度。

（题解好少，赶紧水一发，本文主要教卡常）。

## 题目大意

给定一个图，求最大流和最小费用最大流。

$1\leq n \leq 400,1\leq m \leq 15000$，保证答案在 int 范围内。

## 题目分析

既然是模板题，就不不分析了，我们考虑只求最大流时我们是怎么做的？使用 dinic 等算法，求最小费用也差不多，我们考虑将分层图改一下，设 $dis_i$ 为分层图的权值，那么直接跑 spfa 求出来最短路即可（按边权为费用跑），注意在网络流中 spfa 没死（证明我不会）。

具体做法还是建议看看其他人的学习笔记、题解。回到开头那句话，本文讲这道题怎么卡常。

- 快读快输
- 用循环赋值，不用 memset
- 源点汇点直接设为 $1,n$
- c++98
- 网络流双端队列优化

（为什么不加当前弧优化？因为不知道为什么我的代码加上是负优化）

加上这些优化我才艹过去这道题，可见此题有多毒瘤。

## Code

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
struct FastIO
{
    static const int S=1048576;char buf[S],*L,*R;int stk[20],Top;~FastIO(){clear();}
    inline char nc(){return L==R&&(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;}inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}
    inline void pc(char ch){Top==S&&(clear(),0);buf[Top++]=ch;}inline void endl(){pc('\n');}
    FastIO& operator >> (char&ch){while(ch=nc(),ch==' '||ch=='\n');return *this;}
    template<typename T>FastIO& operator >> (T&ret)
    {
        ret=0;int f=1;char ch=nc();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=nc();}
        while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=nc();}ret*=f;return *this;
    }
    FastIO& operator >> (char* s){int Len=0;char ch=nc();while(ch!='\n'){*(s+Len)=ch;Len++;ch=nc();}}
    template<typename T>FastIO& operator << (T x)
    {
        if(x<0){pc('-');x=-x;}do{stk[++stk[0]]=x%10;x/=10;}while(x);
        while(stk[0]) pc('0'+stk[stk[0]--]);return *this;
    }
    FastIO& operator << (char ch){pc(ch);return *this;}
    FastIO& operator << (string str){int Len=str.size()-1;for(stk[0]=0;Len>=0;Len--) stk[++stk[0]]=str[Len];while(stk[0]) pc(stk[stk[0]--]);return *this;}
}fin,fout;
const int N = 405;
const int M = 35005;
struct aa{
	int nxt,to,val,cost;
}edge[M];
int tot=1,head[N];
void add(int u,int v,int w,int x){
	edge[++tot].nxt = head[u];edge[tot].to = v;edge[tot].val = w;edge[tot].cost = x;head[u] = tot;
	edge[++tot].nxt = head[v];edge[tot].to = u;edge[tot].val = 0;edge[tot].cost =-x;head[v] = tot;
} 
int n,m,inf = 2147483647;
int ans,flow,S,T;
int dis[N];
deque<int>q;
bool vis[N];
bool spfa(){
	for(int i=S;i<=T;i++){
		dis[i] = inf;
		vis[i] = 0;
	}
	dis[S] = 0;
	q.push_back(S);
	vis[S] = 1;
	while(!q.empty()){
		if(q.size()>1&&(dis[q.front()]>dis[q.back()])){
			swap(q.front(),q.back());
		}
		int p = q.front();
		q.pop_front();
		vis[p] = 0;
		for(int i=head[p];i;i=edge[i].nxt){
			int now = edge[i].to;
			if(dis[now]>dis[p]+edge[i].cost&&edge[i].val){
				dis[now] = dis[p]+edge[i].cost;
				if(!vis[now]){
					if(!q.empty()&&dis[now]<dis[q.front()]){
						q.push_front(now);
					}else{
						q.push_back(now);
					}
					vis[now] = 1;
				}
			}
		}
	}
	return dis[T]<inf;
}
int dfs(int u,int f){
	if(u==T){
		return f;
	}
	vis[u] = 1;
	int used = 0;
	for(int i=head[u];i&&f;i=edge[i].nxt){
		int now = edge[i].to;
		if(!vis[now]&&dis[now]==dis[u]+edge[i].cost&&edge[i].val){
			int w = dfs(now,min(f,edge[i].val));
			ans+=w*edge[i].cost;
			edge[i].val-=w;edge[i^1].val+=w;
			used+=w;f-=w;
		}
	}
	vis[u] = 0;
	if(!used){
		dis[u] = inf;
	}
	return used;
}
void mcmf(){
	while(spfa()){
		for(int i=S;i<=T;i++){
			vis[i] = 0;
		}
		flow+=dfs(S,inf);
	}
}
int main(){
	fin>>n>>m;
	S = 1;T = n;
	int u,v,w,x;
	for(int i=1;i<=m;i++){
		fin>>u>>v>>w>>x;
		add(u,v,w,x);
	}
	mcmf();
	fout<<flow;fout<<' ';fout<<ans;
	return 0;
}
```

属实没想到模板题人这么少。

---

## 作者：郑朝曦zzx (赞：1)

## 算法讲解

这道题**略微卡常**，请使用快读，O2 优化。

------------

前置知识：最大流算法

普通的最大流问题其实也是一种特殊的费用流问题，每条边的费用为 $1$。我们知道 Dinic 算法是根据 BFS 分层图多路增广的，那么费用有了边权后，很自然的我们就会想到最短路 + 增广路。

可以证明，我们每次就贪心的找到路径最短的路径进行增广，直到图不连通，就能找到最小费用最大流。

由于反悔边的存在，如果对边权不进行转化，就会出现负权边，所以我们无法使用 Dijkstra 算法，只能退而使用 SPFA 算法。

- 建图细节：反悔边的费用是正向边的相反数。

## 代码演示
- EK 版本
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++) 
const int mxn = 5010, mxm = 50010;
int n, m, S, T, ecnt = 1, Maxflow, Mincost;
int head[mxn], pre[mxn], dis[mxn], lst[mxn], mflow[mxn];
struct edge
{
	int t, nxt, f, cost;
}e[mxm << 1];
inline int read()
{
    char c=getchar(); int x=0;
    while(c<'0'||c>'9') {c=getchar();}
    while(c>='0'&&c<= '9') { x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x;
}
void add(int f, int t, int fl, int cost)
{
	e[++ecnt] = (edge){t, head[f], fl, cost};
	head[f] = ecnt;
}
void addedge(int f, int t, int fl, int cost)
{
	add(f, t, fl, cost);
	add(t, f, 0, -cost);	
}
bool inq[mxn];
bool spfa()
{
	queue <int> q;
	while (!q.empty()) q.pop();
	memset(mflow, 0x3f, sizeof(mflow));
	memset(dis, 0x3f, sizeof(dis));
	q.push(S); dis[S] = 0; pre[T] = -1;
	while (!q.empty())
	{
		int node = q.front(); q.pop();
		inq[node] = 0;
		for (int i = head[node]; i; i = e[i].nxt)
		{
			int to = e[i].t;
			if (e[i].f > 0 && dis[to] > dis[node] + e[i].cost)
			{
				dis[to] = dis[node] + e[i].cost;
				pre[to] = node;
				lst[to] = i;
				mflow[to] = min(mflow[node], e[i].f);
				if (!inq[to])
				{
					inq[to] = 1;
					q.push(to);
				}
			}
		}
	}
	return pre[T] != -1;
}
void Flow()
{
	while (spfa())
	{
		int node = T;
		Maxflow += mflow[T];
		Mincost += mflow[T] * dis[T];
		while (node != S)
		{
			e[lst[node]].f -= mflow[T];
			e[lst[node] ^ 1].f += mflow[T];
			node = pre[node]; 
		}
	}
}
int main()
{
	n = read(); m = read();
	S = 1; T = n;
	for (int i = 1, u, v, w, c; i <= m; ++i)
	{
		u = read(); v = read(); w = read(); c = read();
		addedge(u, v, w, c);
	}
	Flow();
	printf("%d %d", Maxflow, Mincost);
	return 0;
}
```
- Dinic 版本
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
const int mxn = 5010, mxm = 50010;
int n, m, S, T, ecnt = 1, Maxflow, Mincost;
int head[mxn], dis[mxn], lst[mxn];
struct edge
{
	int t, nxt, f, cost;
}e[mxm << 1];
inline int read()
{
    char c=getchar(); int x=0;
    while(c<'0'||c>'9') {c=getchar();}
    while(c>='0'&&c<= '9') { x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x;
}
void add(int f, int t, int fl, int cost)
{
	e[++ecnt] = (edge){t, head[f], fl, cost};
	head[f] = ecnt;
}
void addedge(int f, int t, int fl, int cost)
{
	add(f, t, fl, cost);
	add(t, f, 0, -cost);	
}
bool inq[mxn];
bool spfa()
{
	queue <int> q;
	while (!q.empty()) q.pop();
	memset(dis, 0x3f, sizeof(dis));
	memset(inq, 0, sizeof(inq));
	q.push(S); dis[S] = 0;
	while (!q.empty())
	{
		int node = q.front(); q.pop();
		inq[node] = 0;
		lst[node] = head[node]; 
		for (int i = head[node]; i; i = e[i].nxt)
		{
			int to = e[i].t;
			if (e[i].f > 0 && dis[to] > dis[node] + e[i].cost)
			{
				dis[to] = dis[node] + e[i].cost;
				if (!inq[to])
				{
					inq[to] = 1;
					q.push(to);
				}
			}
		}
	}
	return dis[T] != 0x3f3f3f3f;
}
int Dinic(int node, int Limit)
{
	if (node == T) return Limit;
	int tmp = Limit;
	inq[node] = 1;
	for (int &i = lst[node]; i; i = e[i].nxt)
	{
		int to = e[i].t;
		if (dis[node] + e[i].cost == dis[to] && e[i].f && inq[to] == 0)
		{
			int a = Dinic(to, min(tmp, e[i].f));
			e[i].f -= a;
			e[i ^ 1].f += a;
			tmp -= a;
			Mincost += a * e[i].cost;
			if (tmp == 0) return Limit;
		}
	}
	inq[node] = 0;
	return Limit - tmp;
}
void Flow()
{
	while (spfa()) Maxflow += Dinic(S, 1e9);
}
int main()
{
	n = read(); m = read();// S = read(); T = read();
	S = 1; T = n;
	for (int i = 1, u, v, w, c; i <= m; ++i)
	{
		u = read(); v = read(); w = read(); c = read();
		addedge(u, v, w, c);
	}
	Flow();
	printf("%d %d", Maxflow, Mincost);
	return 0;
}
```


---

## 作者：strcmp (赞：1)

这道题似乎对于增广路算法都不太友好，然鹅 lz 太菜了只会 EK+SPFA 的单路增广，死活卡不进去，于是就学习了多路增广费用流这个听起来似乎很高级的东西。

普通的单路增广费用流每次都只能增广一条路径，增广之后都要用 SPFA 重新求最短路，每次 SPFA 的时间复杂度最高都是 $O(nm)$ 的，很显然每次的时间复杂度瓶颈就在这个 $O(nm)$ 的 SPFA 上。那么，我们设想，如果有一种算法，能够大量减少 SPFA 的次数，哪怕每次增广都要多做一点工作，那也是稳赚不亏的。

如何减少 SPFA 的次数？使用玄学的 Dinic 算法。

如果说单路增广费用流是 ```EK+SPFA```，那么多路增广费用流就是 ```Dinic+SPFA```。

具体要怎么做？

**把 BFS 换成 SPFA，每次增广时只走 $dep[v] + w_{ij}= dep[u]$ 的路径。**

时间复杂度：

每次 SPFA 的时间复杂度都是 $O(nm)$ 的，而 DFS 寻找增广路是严格 $\Theta(n+m)$
的，每次最少增广一条路径，最少增广一个单位的流量，故显然最坏时间复杂度是 $O(nmf)$ 的，虽然是伪多项式，但是实践中跑的很快，接近 $O(n^2m)$。

接下来是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 2147483647
#define V 405
#define E 30005
#pragma optimize(1)
#pragma optimize(2)
#pragma optimize(3,"Ofast","inline")
typedef long long int ll;
struct edge { int to, next, capa, cost; };
int cnt = 0, head[V], n, m; edge node[E];
inline void add(register int fir, register int nxt, register int w, register int c) {
    node[cnt].to = nxt,
        node[cnt].capa = w,
        node[cnt].cost = c,
        node[cnt].next = head[fir],
        head[fir] = cnt++;
}
int s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0, num = 0;
bool vis[V];
inline bool spfa() {
    for (register int i = 1; i <= n; ++i)dep[i] = inf;
    dep[s] = 0; que.push_back(s); register int u, v;
    while (!que.empty()) {
        v = que.front();
        while (dep[v] * que.size() > num)que.pop_front(), que.push_back(v), v = que.front();//SPFA 的 LLL优化
        que.pop_front();
        for (register int i = head[v]; i != -1; i = node[i].next) {
            u = node[i].to;
            if (node[i].capa && dep[v] + node[i].cost < dep[u]) {
                dep[u] = dep[v] + node[i].cost,num += dep[u];
                if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);
                else que.push_back(u);
                //SLF 优化
            }
        }
    }
    return !(dep[t] == inf);
}
ll dfs(register int v, register int flow) {
    if (!flow || v == t)return flow; register int used = 0, wei = 0; vis[v] = true;//及其玄学，这里吧判断条件调换顺序就会 TLE
    for (register int i = cur[v]; i != -1; i = node[i].next) {
        cur[v] = i;//当前弧优化
        if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {
            wei = dfs(node[i].to, min(flow - used, node[i].capa));
            if(wei)node[i].capa -= wei,node[i ^ 1].capa += wei,used += wei,cost += node[i].cost * wei;
        }
        if (used == flow)break;
    }
    vis[v] = false;
    return used;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(); cout.tie();
    memset(head, -1, V * sizeof(int));
    cin>>n>>m; s = 1, t = n;
    int f, l, w, c;
    for (register int i = 0; i < m; ++i) {
        cin>>f>>l>>w>>c;
        add(f, l, w, c);
        add(l, f, 0, -c);
    }
    while (spfa()) {
        memcpy(cur, head, (n + 1) * sizeof(int));
        sum += dfs(s, inf);
    }
    cout << sum << " " << cost;
    return 0;
}
```

代码经过了一定卡常，~~有可能在评测机不稳定的情况下 TLE~~。


---

## 作者：TachibanaKanade (赞：1)

经典模板题。写篇详细一些的题解造福社会。

所谓最小费用最大流，与最大流的不同点在于，即在同一个网络中，可能存在多个总流量相同的最大流 $f$ ，我们可以在计确保流量最大的前提下总费用最小，这样的最大流被称为 **最小费用最大流**。

对于费用流中的反向弧，应将剩余容量初始化为 $0$，费用设置为正向弧的相反数。

一种思路大致为先置网络初始流量为 $0$，之后不断以每条弧的单位流量费用为边权在当前的剩余网络上求出从 $S$ 到 $T$ 的最短增广路。如果不存在则算法结束，否则修改增广路上弧的流量并继续增广。

增广使用 `SPFA` 跑最短路即可。因为跑的次数多，所以 `SPFA` 很难全部退化为 $O(n^2)$，加之边存在负权，`SPFA` 无疑最佳选择。

写的比较简略，详细可参考[这篇日报](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)，讲的比我好很多，推荐一读。

---

说回此题。

这道题对时间要求很紧，所以需要卡常。

提供几种卡常方式。

1. 把输入输出换为快读快输。
2. 函数前加上 `inline`，变量前加上 `register`。
3. 尝试把 `memset` 换为循环初始化。

---

丢个一年前的丢人代码。

```
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 10005;
const int MAX_M = 100005;
const int inf = 0x7f;
namespace in{
    #ifdef faster
    char buf[1<<21],*p1=buf,*p2=buf;
    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
    #else
    inline int getc(){return getchar();}
    #endif
    template <typename T>inline void read(T& t){
        t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
        while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
    }
    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
    char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
    inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
    inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
    template <typename T>void write(T x) {
        static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
        while (len>=0)putc(buf[len]),--len;
    }
}
struct edge {
    int v, c, w, next;
} e[MAX_M];
int p[MAX_N], s, t, eid;
inline void init() {
    memset(p, -1, sizeof(p));
    eid = 0;
}
inline void insert(int u, int v, int c, int w) {
    e[eid].v = v;
    e[eid].c = c;
    e[eid].w = w;
    e[eid].next = p[u];
    p[u] = eid++;
}
inline void addedge(int u, int v, int c, int w) {
    insert(u, v, c, w);
    insert(v, u, 0, -w);
}
bool vis[MAX_N];
int d[MAX_N];
int pre[MAX_N];
int pre2[MAX_N];
int cf[MAX_N];
int n;
queue<int> q;
inline bool spfa() {
    for (int i = 0; i <= n; i++) vis[i] = 0, cf[i] = inf, pre2[i] = -1, d[i] = 1000000005;
    d[s] = 0;
    vis[s] = true;
    q.push(s);
    while (!q.empty()) {
        register int u = q.front();
        q.pop();
        vis[u] = false;
        for (register int i = p[u]; i != -1; i = e[i].next) {
            if(e[i].c) {
                register int v = e[i].v;
                if (d[u] + e[i].w < d[v]) {
                    d[v] = d[u] + e[i].w;
                    pre[v] = i;
                    pre2[v] = u;
                    cf[v] = min(cf[u], e[i].c);
                    if (!vis[v]) {
                        q.push(v);
                        vis[v] = true;
                    }
                }
            }
        }
    }
    return (pre2[t] != -1);
}
int ret2 = 0, ret;
inline void costflow() {
    while (spfa()) {
        int flow = cf[t];
        ret += flow * d[t];
        ret2 += flow;
        for (register int i = t; i != s; i = e[pre[i] ^ 1].v) {
            e[pre[i]].c -= flow;
            e[pre[i] ^ 1].c += flow;
        }
    }
}
signed main() {
    int m;
    init();
    in::read(n, m); s = 1, t = n;
    for (register int i = 0; i < m; ++i) {
        register int u, v, c, w;
        in::read(u, v, c, w);
        addedge(u, v, c, w);
    }
    costflow();
    printf("%d %d\n", ret2, ret);
    return 0;
}
```


---

## 作者：Eltaos_xingyu (赞：0)

**注意：本篇题解是来测试各种算法的效率的。如果还不会 SPFA 费用流的看看其他题解，不会 dijkstra 费用流的可以看看经典日报，不会 zkw 的先看 SPFA 费用流，然后看看 dinic 算法即可，下面要稍微讲讲。**

这里就直接贴上 SPFA 费用流代码和 dijkstra 费用流代码了（请无视输入输出长什么样子和 SPFA 是否加了优化）：

[dijkstra 多路增广](https://www.luogu.com.cn/paste/i2hpx5ac)

[dijkstra 单路增广](https://www.luogu.com.cn/paste/yn18aq4q)

[SPFA 单路增广](https://www.luogu.com.cn/paste/jrxcy61y)

SPFA 多路增广的代码就不放了，除了最短路算法不同基本上和 dijkstra 多路增广的代码一样。

如有哪些地方写错了请指出，谢谢！

然后，zkw 费用流是什么？

按个人理解讲，其实和上面的多路增广算法差不多，就是在多路增广的过程中不重复增广同一个节点，一直增广到按当前的最短路到不了汇点为止。这样做会有效节省求最短路的次数。

[zkw+SPFA](https://www.luogu.com.cn/paste/vb0oyfw8)

zkw+dijkstra 的代码也不放了，知道上面的算法原理之后这个很好实现。

那么，开始比较（测试程序的 SPFA 均未加优化）！

当为稀疏图（即 P3381）时：

|   [total]     | SPFA 单路增广 | dijkstra 多路增广 | dijkstra 单路增广 | SPFA 多路增广 | zkw+SPFA | zkw+dijkstra |
| :----: | :----------: | :--------------: | :--------------: | :----------: | :------: | :----------: |
| 不开 O2 |    1.65s     |      1.75s       |      2.15s       |    1.30s     |  1.46s   |    1.81s     |
| 开了 O2 |    1.25s     |      472ms       |      459ms       |    941ms     |  1.04s   |    450ms     |

可以看出在稀疏图中，不开 O2 时，SPFA 多路增广算法最优；开了 O2 时，dijkstra 算法家族差不多一样快，并且它们是最优的。

而在稠密图中（即 B3608）时：

| [max]  | SPFA 单路增广 | dijkstra 多路增广 | dijkstra 单路增广 | SPFA 多路增广 | zkw+SPFA | zkw+dijkstra |
| :----: | :----------: | :--------------: | :--------------: | :----------: | :------: | :----------: |
| 不开 O2 |  1.53s(TLE)  |   1.70s+(TLE)    |   1.70s+(TLE)    |    1.14s     |  1.26s   |  1.58s(TLE)  |
| 开了 O2 |    1.10s     |      565ms       |      717ms       |    803ms     |  935ms   |    688ms     |

显然，不开 O2 时，SPFA 多路增广算法的效率最高；开 O2 时，dijkstra 多路增广算法最快。

可能是常数原因，zkw 算法没有想象中优秀。

所以作者建议，如果比赛时不开 O2 最好用 SPFA 多路增广算法；如果开了 O2 最好用 dijkstra 多路增广算法。

# The End.

---

## 作者：AlicX (赞：0)

### 前言

本题考察算法：

- 最短路
- 分层图思想
- 网络流

这是费用流的板子题，唯一难点是本题卡常，其他都不难。

------------

### Solution

网络最大流相信大家都会了，费用流便是建立在此之上的一个算法。

与网络流不同的有两点：

1. 计算分层图时，要将搜索换成 `SPFA`，为什么要这样做？因为我们最后是需要一个最小费用，所以要跑一遍最短路，因为有负权边，所以选择 `SPFA`。

2. 在计算最大流时，遍历过的点不用再遍历，再次遍历会出错（费用会算重）。

注意：建反向边时，单位费用需要用负的。

其余的套上最大流板子就可以了。

### Code
```cpp
#include<bits/stdc++.h>
#define x first
#define y second
#pragma optimize(1)
#pragma optimize(2)
#pragma optimize(3,"Ofast","inline")
using namespace std;
typedef pair<int,int> pii;
const int N=410,M=15005,INF=INT_MAX;
int n,m;
int s,t;
int PKU=0;
bool st[N];
int h[N],idx=0,num;
int dis[N],now[N];
struct Node {
	int w,c;
	int to,ne;
} tr[M<<1];
inline void add(int u,int v,int w,int c) {
	tr[idx].w=w,tr[idx].c=c,tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;
}
inline bool SPFA() {
	deque<int> q;
	q.push_back(s);
	memset(st,false,sizeof st);
	st[s]=true;
	for(register int i=1; i<=n; i++) dis[i]=INF,now[i]=h[i];
	dis[s]=0;
	while(!q.empty()) {
		int u=q.front();
		q.pop_front();
		st[u]=false;
		while(dis[u]*q.size()>num) {
			q.pop_front();
			q.push_back(u);
			u=q.front();
		}
		for(register int i=h[u]; i!=-1; i=tr[i].ne) {
			int to=tr[i].to;
			if(!tr[i].w) continue;
			if(dis[to]>dis[u]+tr[i].c) {
				dis[to]=dis[u]+tr[i].c;
				if(!st[to]) st[to]=true,q.push_back(to);
				num+=dis[to];
			}
		}
	}
	return (dis[t]!=INF);
}
inline bool ss(){
	queue<int> q; q.push(s); 
	memset(st,false,sizeof st); st[s]=true;
	for(register int i=1;i<=n;i++) dis[i]=INF,now[i]=h[i]; dis[s]=0;
	while(!q.empty()){
		int u=q.front(); q.pop(); st[u]=false;
		for(register int i=h[u];i!=-1;i=tr[i].ne){
			int to=tr[i].to;
			if(!tr[i].w) continue;
			if(dis[to]>dis[u]+tr[i].c){
				dis[to]=dis[u]+tr[i].c;
				if(!st[to]) st[to]=true,q.push(to);
			}
		}
	} return (dis[t]!=INF);
}
inline int Dinic(int u,int sum) {
	if(u==t||sum==0) return sum;
	int ans=0;
	st[u]=true;
	for(register int i=now[u]; i!=-1; i=tr[i].ne) {
		int to=tr[i].to;
		now[u]=i;
		if(!tr[i].w) continue;
		if(!st[to]&&dis[to]==dis[u]+tr[i].c) {
			int x=Dinic(to,min(sum,tr[i].w));
			if(x==0) dis[to]=INF;
			tr[i].w-=x,tr[i^1].w+=x;
			ans+=x,sum-=x,PKU+=x*tr[i].c;
		}
		if(!sum) break;
	}
	return ans;
}
inline int dd(int u,int sum){
	int ans=0; 
	if(u==t) return sum; st[u]=true;
	for(register int i=now[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to; now[u]=i;
		if(!tr[i].w) continue;
		if(!st[to]&&dis[to]==dis[u]+tr[i].c){
			int x=Dinic(to,min(sum,tr[i].w));
			if(x==0) dis[to]=INF;
			tr[i].w-=x,tr[i^1].w+=x;
			ans+=x,sum-=x,PKU+=x*tr[i].c;
			if(!sum) break;
		}
	} return ans;
}
int main() {
	memset(h,-1,sizeof h);
	scanf("%d%d",&n,&m);
	s=1,t=n;
	if(n>=300) {
		while(m--) {
			int u,v,w,c;
			scanf("%d%d%d%d",&u,&v,&w,&c);
			add(u,v,w,c),add(v,u,0,-c);
		}
		int ans=0;
		while(SPFA()) memset(st,false,sizeof st),ans+=Dinic(s,INF);
		printf("%d %d\n",ans,PKU);
	} else {
		while(m--) {
			int u,v,w,c;
			scanf("%d%d%d%d",&u,&v,&w,&c);
			add(u,v,w,c),add(v,u,0,-c);
		}
		int ans=0;
		while(ss()) memset(st,false,sizeof st),ans+=dd(s,INF);
		printf("%d %d\n",ans,PKU);
	}
	return 0;
}
```



---


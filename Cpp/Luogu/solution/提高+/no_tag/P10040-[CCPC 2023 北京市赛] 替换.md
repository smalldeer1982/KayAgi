# [CCPC 2023 北京市赛] 替换

## 题目描述

给定一个长度为 $n$、字符集为 `01?` 的字符串 $s_1s_2 \cdots s_n$。

对于任意 $k \in [1,n]$，考察字符串 $T_k = t_1 t_2 \cdots t_n$，其中对于 $1 \le i \le n$，

- 若 $s_i \ne$ `?`，则 $t_i = s_i$；
- 否则，若 $i \le k$，$t_i =$ `0`；
- 否则 $t_i = t_{i-k}$，你可以通过递归地算出 $t_{i-k}$ 得到 $t_i$。

容易发现 $T_k$ 的字符集为 `01`。你需要对所有 $k \in [1,n]$ 求出 $T_k$ 中 `1` 的个数。

## 说明/提示

$T_1 =$ `10011`，$T_2 =$ `10111`，$T_3 =$ `10010`，$T_4 =$ `10011`，$T_5 =$ `10010`。

## 样例 #1

### 输入

```
5
10?1?```

### 输出

```
3
4
2
3
2```

# 题解

## 作者：Loser_Syx (赞：5)

很暴力的一道题。

你考虑 `bitset` 维护当前已经确定的答案，发现每次其实就是左移 $i$ 位，每轮 $n\div i$ 次，再维护一个 `?` 的答案，直接再看一下左移完 $i$ 位后是否存在新的交集然后更新即可。

复杂度显然是 $O(\frac{n^2\ln n}{\omega})$ 的，超时得很惨。

但是你可以考虑根号分治，前面 $i \leq \sqrt n$ 的数你可以直接暴力（因为让 `bitset` 搞每次次数 $\geq \sqrt n$），这么一段是 $O(n \sqrt n)$ 的复杂度，后面 $i > \sqrt n$ 的部分选择 `bitset`，复杂度退化为 $O(\frac{n^2 \ln \sqrt n}{\omega})$，总复杂度为两段之和，可以通过。

```cpp
const int N=1e5+19;
bitset<N> ans, maybe, now;
signed main() {
	int n; string s;
	cin >> n >> s;
	int sq=sqrt(n);
	s=" "+s;
	for (int i=1;i<=n;++i) {
		if (s[i]=='1') ans[i]=1;
		else if (s[i]=='?') maybe[i]=1;
	}
	for (int i=1;i<=n;++i) {
		now=ans;
		if (i <= sq) {
			for (int j=i+1;j<=n;++j) if (s[j]=='?'&&now[j-i]) now[j]=1;
		} else {
		for (int j=i;j<=n;j+=i) {
			now=now|((now<<i)&maybe);
		} }
		write(now.count(), '\n');
	}
	return 0;
}
```

---

## 作者：waauto (赞：4)

复杂度分析题。

首先有个很暴力的做法就是直接对于每个数递归，但是这样是很慢的。

考虑一种 bitset。

你可以先处理前 $k$ 个，这个可以 $O(1)$ 递推。

然后你每次往后推 $k$ 个，用 $1$ 位置或上前面 $1$ 位置与这里的未知位置就行。

单次复杂度是 $O(\frac{n}{k}\times \frac{n}{\omega})$。

你发现如果全部用后面这个做是 $\frac{n^2\log n}{\omega}$ 的，不太友好，于是你考虑在前面优秀的时候用前面的跑，后面优秀的时候用后面跑。

$$
n=\frac{n^2}{k\omega},k=\frac{n}{\omega}
$$

于是你复杂度就变成了 $O(\frac{n^2}{\omega}+\frac{n^2\log \frac{n}{\omega}}{\omega})$。

实际取 $k$ 稍微小一点点会更优。

贴一下代码。

```cpp
bitset<100001>B,tmp,now,make,C;
int n;
string s;
inline void mian(){
	cin>>n>>s;
	s=" "+s;
	for(int i=1;i<=n;i++)if(s[i]=='1')B[i]=1;
	for(int i=1;i<=n;i++)if(s[i]=='?')C[i]=1;
	for(int i=1;i<=n;i++){
		if(s[i]=='1')now[i]=1;
		make[i]=1;
		tmp=now;
		int place=i;
		if(i*128<=n){
			int ans=tmp.count();
			for(int j=i+1;j<=n;j++){
				if(tmp[j-i] and C[j])tmp[j]=1;
				if(B[j])tmp[j]=1;
				if(tmp[j])ans++;
			}
			cout<<ans<<'\n';
			continue;
		}
		while(place<n){
			tmp=B|((tmp<<i)&C);
			place+=i;
		}
		cout<<tmp.count()<<'\n';
	}
}
```

---

## 作者：约瑟夫用脑玩 (赞：3)

[正解](https://www.luogu.com.cn/paste/vopdr6tg)：$O(\dfrac{n^2}\omega)$

当 $k<\omega$ 跑暴力，避免后续算法的边界问题，以下讨论 $k\ge\omega$。

令 $a_i=[s_i=1],b_i=[s_i=$ `?` $],c_i=[s_i=0]$，当 $b_i=1$ 时默认 $t_i=0$，否则 $a_i=1$ 时默认 $t_i=1$，$c_i=1$ 时默认 $t_i=0$。

然后我们递归处理 $b_i=1$ 的 $t_i$ 更新，过程可以用简单的式子 $t_i\leftarrow b_i\land t_{i-k}$ 表示转移，更新为“或等于操作”，这样转化过程的好处是避免了判断从而有了优化的空间。

发现上述过程全是位运算且每次只涉及到单个的 01 字符，容易想到直接压位用 `unsigned long long` 直接转移 64（也即 $\omega$）个字符。

显然（使用 ULL）手写这个过程每次转移仍然是 $O(1)$ 的，但需要跑的次数减少到了 $\frac n\omega$ 次，故跑一次过程由暴力的 $O(n)$ 降到了现在的 $O(\dfrac n\omega)$，总共需要跑 $n$ 次（$k:1\to n$），综上总复杂度 $O(\dfrac{n^2}\omega)$。

------------

看似都是压位思想优化暴力，现有题解为什么清一色的 $O(\dfrac{n^2\ln n}\omega)$ 而非标解复杂度？（其他题解均为此式优化常数的形式）

现有题解使用了 bitset 导致每次位运算复杂度为 $\frac n\omega$，但由于 `bitset` 可以支持压位为 $n$ 位，故每次跑的次数不同，根据 $k$ 会有变化。

更具体的说，其总次数由调和级数有 $n\ln n$ 次，乘起来得到总复杂度。

回到我们的问题，都是压位，复杂度为什么不都是除以 $\omega$ 呢？原因是盲目使用 `bitset`。

每次转移需要的压位为 $k$，我们手写的做法相当于把 $k$ 拆成了 $\frac k{64}$ 份，一份一份的转移，复杂度自然减少了 $\omega$ 倍。

而使用 `bitset` 即便压位 $k$ 很小时仍需要 $\frac n\omega$ 的复杂度，只有当 $k$ 很大甚至接近于 $n$ 时压位的转移优化才完全有效。

这就是为什么复杂度更劣的原因，而其他题解意识到了这点采取 $k$ 较小时直接使用暴力来平衡常数，但并改变不了复杂度本质上多一个 $\ln$ 的事实，最后也需要卡常而非直接 `bitset` 压位优化过去。

也许常数足够优秀，$\ln$ 也只是一个稍大的常数呢？压位压的 $\omega$ 本身不也只是常数优化吗？你说得对但是标解手写压位（ULL） 300ms 就能轻而易举的跑过，滥用 `bitset` 虽然比暴力快但还是需要优化常数最后还在 1s/2s 徘徊。

正解并不难写，但也许 `bitset` 更好写吧。（有没有一种可能是这道题本身出的不好的问题？都 4202 年了不会还有人觉得裸暴力压位优化的题是啥好题吧）

---

## 作者：Sampson_YW (赞：1)

枚举 $k$，将序列按 $k$ 分块。那么一个块的状态就只和自己与上一个块的状态有关。

在当前块的第 $i$ 个位置，如果是 `1`，那它最终就是 `1`。如果等于 `?` 并且上一个块的第 $i$ 个位置是 `1`，那它最终是 `1`。

开长度为 $n$ 的 bitset 维护 `1` 和 `?` 的位置即可优化成单次 $O(\frac{n}{\omega})$ 计算一个块。一共要计算 $\sum \frac{n}{k}$ 次，因此计算量是 $n\sum\frac{n}{k\omega}$ 的。我们希望将分母中的 $n$ 改成 $k$（是 $n$ 的原因是 bitset 长度为 $n$），这样计算量就是 $n\sum\frac{k}{k\omega}=\frac{n^2}{\omega}$ 的。那直接开长度为 $k$ 的 bitset 就行了，吗？

由于一个 bitset 只能和长度相同的 bitset 做运算，并且无法修改一个 bitset 的长度（这里说的是 STL 自带的 bitset）。所以可以倍增地开一个大小为 $len=2^t$ 的 bitset，使得 $k\in[2^{t-1},2^t)$，然后将在 $[2^{t-1},2^t)$ 范围内的 $k$ 都求一遍答案。这样 bitset 的长度就不超过 $2k$。具体怎么开 bitset 可以看代码。

然后就是我们希望将序列按 $k$ 分块，但是我们的 bitset 长度是 $len$。因此要将序列按 $len$ 分块，每次提取一段区间，或者提取一段前缀和一段后缀拼起来。所以写起来很屎。

[code](https://www.luogu.com.cn/paste/jft2jxmv)

---

## 作者：Dream__Sky (赞：0)

本题相当于给你一个二进制串，按题意规则操作后，即对 $i>k$ 的 $a_i$ 按 $a_{i-k}$ 的值赋值，即相当于将该二进制串左移 $k$ 位后，与原二进制串中满足前文要求的 $a_i$ 进行或操作。注意，因为更新中需要遍历到二进制串中的每一位数，但每次左移只能对前面的 $k$ 位进行更新，那么需要 $\dfrac{n}{k}$ 轮。

看到这样的二进制操作，很容易能想到使用 `bitset` 维护。

但此时的复杂度是 $O(\dfrac{n^2\ln n}{w})$ 的，仍然无法接受。

我们可以考虑根号分分治，对于前 $\sqrt{n}$ 的 $k$，暴力复杂度为 $O(n\sqrt{n})$，`bitset` 为 $O(\dfrac{n^2\ln \sqrt{n}}{w})$，选择暴力。后半部分暴力复杂度变为 $O(n^2)$，`bitset` 不变，所以我们选择 `bitset`。

`bitset` 更新过程中不需要考虑 $i>k$ 的要求，因为我们的更新方式是左移，小于 $k$ 的地方显然更新不到。

---


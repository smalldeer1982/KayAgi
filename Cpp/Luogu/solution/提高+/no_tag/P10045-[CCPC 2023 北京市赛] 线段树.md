# [CCPC 2023 北京市赛] 线段树

## 题目描述

有一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，保证 $a_i$ 为**奇数**。

有两种操作：

1. 给定 $l,r,x$，将 $a_l,a_{l+1},\cdots,a_r$ 加上**偶数** $x$；

2. 给定 $l,r$，求 $a_l,a_{l+1},\cdots,a_r$ 的乘积，答案对 $2^{20}$ 取模；

## 样例 #1

### 输入

```
10 10
969575 741825 24903 1047319 450475 256145 1045323 479255 810659 768323 
1 5 6 3034
2 1 10
2 1 9
2 1 4
1 3 6 126904
2 5 5
2 9 9
1 7 7 853094
1 4 9 1025178
2 5 8```

### 输出

```
1045541
1012343
558151
580413
810659
527353```

# 题解

## 作者：buowen123 (赞：6)

## 题目大意

- 给你一个长度为 $n$ 的序列 $a$，要求维护区间加区间积，对 $2^{20}$ 取模。
- $1 \le n,q \le 2 \times 10^5$，保证任意时刻 $a$ 中的数均为奇数。

## 题目解决

区间加区间积看着就不是很可做，但是有一条特殊的性质：$a_i$ 恒为奇数。

设 $a_i=x_i+1$，于是 $2|x_i$。那么 $\prod_{i=l}^r a_i=\prod_{i=l}^r (x_i+1)$。

由于答案对 $2^{20}$ 取模，将原式展开，每一项都是不超过 $19$ 个 $x_i$ 的乘积。

那么我们可以线段树维护，对区间 $[l,r]$ 维护 $s_i$，其中 $s_i$ 表示在 $[l,r]$ 中选择 $i$ 个 $x$ 所得乘积之和，即 $\sum_{|S|=i}\prod_{p\in S}x_p$。

- 如何 pushup？

你在左儿子里边取 $j$ 个数相乘，右儿子里边取 $i-j$ 个数相乘，她们的乘积就等价于在整个区间内选 $i$ 个数相乘。

- 如何 pushdown/更新？

考虑你有 $k$ 个数并已知她们的 $f$ 值，对所有数加上 $v$ 之后 $f$ 的变化。

考虑 $f_{i}$ 的变化。考虑展开式

$$(x_1+v)(x_2+v)\dots(x_i+v)-x_1x_2\dots x_i\\=v^i+(x_1+x_2+\dots x_i)v^{i-1}+\dots +(x_1x_2\dots x_{i-1}+x_1x_2\dots x_{i-2}x_i+\dots x_2x_3\dots x_i)v$$

可以发现，在 $x_1$ 到 $x_i$ 中选 $j$ 个数相乘，将这些乘积求和，会为 $f_i'$ 带来 $C_{k-j}^{i-j} \times v^{i-j}$ 的贡献，所以

$$f_i'=\sum f_j\times C_{k-j}^{i-j} \times v^{i-j}$$

组合数是因为，你可以在未选择的 $k-j$ 个数中，再任选 $i-j$ 个数不计算乘积。

这么做时间复杂度是 $O(n \log n a^2)$，其中 $a=20$，卡常之后可以通过。

一些卡常技巧：
- 将 $v$ 取模 $2^{20}$，然后 $v^{i-j}$ 可以预处理。
- 将 int 改为 unsigned，可以减少取模次数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=2e5+3;
int n,q;
#define gc getchar
inline int read(){
	int x=0;
	char c=gc();
	while(c<48) c=gc();
	while(c>47) x=(x<<1)+(x<<3)+(c^48),c=gc();
	return x; 
}
unsigned a[maxn],c[maxn][21],pw[(1<<20)+5][20];
namespace Segtree{
	#define ls (pos<<1)
	#define rs (pos<<1|1)
	unsigned g[20];
	struct Seg{
		int l,r;
		unsigned f[20],add; 
		inline void upd(unsigned x){
			add+=x; x&=1048575;
			for(int i=0;i<20;i++){
				g[i]=0;
				for(int j=0;j<=min(i,r-l+1);j++)
					g[i]+=c[r-l+1-j][i-j]*f[j]*pw[x][i-j];
			}
			for(int i=0;i<20;i++) f[i]=g[i];
		}
	}tr[maxn<<2];
	#define mid ((tr[pos].l+tr[pos].r)>>1)
	inline void push_u(int pos){
		for(int i=0;i<20;i++){
			tr[pos].f[i]=0;
			for(int j=0;j<=i;j++){
				tr[pos].f[i]+=tr[ls].f[j]*tr[rs].f[i-j];
			}
		}
	}
	inline void push_d(int pos){
		if(tr[pos].add){ 
			tr[ls].upd(tr[pos].add);
			tr[rs].upd(tr[pos].add);
			tr[pos].add=0;
		}
	}
	void build(int pos,int l,int r){
		tr[pos].l=l,tr[pos].r=r;
		if(l==r){
			tr[pos].f[0]=1,tr[pos].f[1]=a[l];
			return;
		}
		build(ls,l,mid);
		build(rs,mid+1,r);
		push_u(pos);
	}
	void up_add(int pos,int l,int r,unsigned x){
		if(l<=tr[pos].l&&tr[pos].r<=r){
			tr[pos].upd(x);
			return;
		}
		push_d(pos);
		if(l<=mid) up_add(ls,l,r,x);
		if(mid<r) up_add(rs,l,r,x);
		push_u(pos);
	}
	unsigned qry(int pos,int l,int r){
		if(l<=tr[pos].l&&tr[pos].r<=r){
			unsigned cur=0;
			for(int i=0;i<20;i++)
				cur+=tr[pos].f[i];
			return cur;
		}
		unsigned cur=1;
		push_d(pos);
 		if(l<=mid) cur*=qry(ls,l,r);
		if(mid<r) cur*=qry(rs,l,r);
		return cur;
	}
}using namespace Segtree;
int main(){
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	double T=clock();
	n=read(),q=read();
	for(int i=1;i<=n;i++)
		a[i]=read()-1;
	c[0][0]=1;
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=1;j<=min(i,20);j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];
	}
	for(unsigned i=0;i<(1<<20);i++){
		pw[i][0]=1;
		for(int j=1;j<20;j++)
			pw[i][j]=pw[i][j-1]*i;
	}
	build(1,1,n);
	int op,l,r;
	unsigned x;
	for(int i=1;i<=q;i++){
		op=read(),l=read(),r=read();
		if(op==1){
			x=read();
			up_add(1,l,r,x);
		}
		else printf("%u\n",qry(1,l,r)&1048575);
	}
//	cerr<<clock()-T<<" ms\n";
	return 0;
}
```
如果有错误与不合理之处，欢迎大家批评指正。

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P10045)
## 题意
给你一个长为 $n$ 的序列 $a$，保证 $a_i$ 是奇数。有两种操作共 $q$ 次：
1. 给定 $l,r,x$，$\forall i\in[l,r],a_i\gets a_i+x$，保证 $x$ 是偶数；
2. 给定 $l,r$，求 $\prod_{i=l}^ra_i$，对 $2^{20}$ 取模。

数据范围： $n,q\le 2\times 10^5$，时限 4s。
## 思路
题外话：在 qoj vp 的时候没给时限，卡了好久常数才敢交。vp 完后几天在模拟赛上遇见相似套路直接秒了。

因为保证了 $a_i$ 时刻为奇数，所以不妨设 $a_i=2b_i+1$。

所求即为 $\displaystyle\prod_{i=l}^r(2b_i+1)$，而答案对 $2^{20}$ 取模，所以展开后不取 $1$ 的项数最多为 $19$。

那么我们建立线段树，对于一个区间 $[l,r]$，我们维护 $f_i$ 表示 $\displaystyle\sum_{S,|S|=i}\prod_{j\in S}b_j$，显然只有 $f_{0\sim 19}$ 可能有值。合并暴力即可。

考虑修改，考虑 $\displaystyle\sum_{S,|S|=i}\prod_{j\in S}(b_j+x)$，枚举选 $b$ 的子集 $T$，$\displaystyle\sum_{T}\binom{r-l+1-|T|}{|S|-|T|}x^{|S|-|T|}\prod_{j\in T}b_j$，即 $\displaystyle f'_i=\sum_{j=1}^if_jx^{i-j}\binom{r-l+1-j}{i-j}$，可以依此更新。

令 $t=20$，则时间复杂度 $O(nt^2\log n)$。

看起来很大，但其实合并和更新时带了 $1/2$ 的常数，再加个标记永久化，用 `unsigned` 代替取模，实际只用了 2.5s。

---

## 作者：waauto (赞：4)

时间限制很大，我们考虑分块。

由于一个偶数乘上个 $20$ 次就没啥用了，所以考虑每个块维护前 $20$ 个不选的答案。

具体来说你可以挨个插入每一个数。

转移柿子显然就是 $f_{i,j}=f_{i-1,j-1}+f_{i-1,j}\times a_i$ 其中 $i$ 表示考虑到第几个数 $j$ 表示有几个数没选。

根据[清华集训数列操作](https://www.luogu.com.cn/problem/P4247)这题的思想，你每次询问一整个块相当于：

$$
\sum_{i=0}^{20}f_i\times (tag)^i
$$

那么你整块打标记，散块用暴力再重构块，就做完了。

一些卡常的方式：```uint``` 自然溢出，如果 $tag$ 目前已经是模数的倍数就可以停止了。

时间复杂度 $O(n\sqrt{n}\log mod)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define S cerr << "SYT AK IOI" <<endl;
#define M cerr << "MKF AK IOI" <<endl;
#define CONNECT_BASE(x,y) x##y
#define CONNECT(x,y) CONNECT_BASE(x,y)
#define DEBUG_BASE(x) cerr<<#x<<'='<<x<<' '
#define DEB_1(x) DEBUG_BASE(x)
#define DEB_2(x,y) DEB_1(x),DEB_1(y)
#define DEB_3(x,y,z) DEB_1(x),DEB_2(y,z)
#define DEB_4(x,y,z,w) DEB_1(x),DEB_3(y,z,w)
#define DEB_5(a,b,c,d,e) DEB_1(a),DEB_4(b,c,d,e)
#define DEB_6(a,b,c,d,e,f) DEB_1(a),DEB_5(b,c,d,e,f)
#define COUNT_BASE(_1,_2,_3,_4,_5,_6,x,...) x
#define COUNT(...) COUNT_BASE(__VA_ARGS__,6,5,4,3,2,1,0)
#define D(...) std::cerr << "[In Line " << __LINE__ << "]: ",CONNECT(DEB_,COUNT(__VA_ARGS__))(__VA_ARGS__) , cerr << '\n'
using ll=long long;
using lll=__int128;
using pii=pair<int,int>;
using uint=unsigned int;
using ull=unsigned long long;
#define pb(x) push_back(x)
#define F(i,a,b) for(int i=(a),i##end=(b);i<=(i##end);++i)
#define UF(i,a,b) for(int i=(a),i##end=(b);i>=(i##end);--i)
int n,m;
const int N=2e5+5;
uint a[N];
uint mul[1145][21];
uint tag[1145];
const int mod=1<<20;
int len=314;
namespace BLK{
	inline int bl(int x){
		return (x-1)/len+1;
	}
	inline int L(int id){
		return len*(id-1)+1;
	}
	inline int R(int id){
		return min(n,len*id);
	}
	inline void rebuild(int id){
		F(i,1,18)mul[id][i]=0;
		mul[id][1]=1;
		F(i,L(id),R(id)){
			UF(j,18,1)mul[id][j]=mul[id][j]*a[i]+mul[id][j-1];
		}
	}
	inline void build(){
		F(i,1,n)if(bl(i)!=bl(i-1))rebuild(bl(i));
	}
	inline void push_down(int id){
		if(!tag[id])return;
		F(i,L(id),R(id))a[i]+=tag[id];
		tag[id]=0;
		rebuild(id);
	}
	inline void add(int l,int r,uint k){
		if(bl(l)==bl(r)){
			push_down(bl(l));
			F(i,l,r)a[i]+=k;
			rebuild(bl(l));
			return;
		}
		push_down(bl(l));
		F(i,l,R(bl(l)))a[i]+=k;
		rebuild(bl(l));
		push_down(bl(r));
		F(i,L(bl(r)),r)a[i]+=k;
		rebuild(bl(r));
		F(i,bl(l)+1,bl(r)-1)tag[i]+=k;
	}
	inline uint query(int l,int r){
		uint rt=1;
		if(bl(l)==bl(r)){
			push_down(bl(l));
			F(i,l,r)rt*=a[i];
			return rt;
		}
		push_down(bl(l));
		F(i,l,R(bl(l)))rt*=a[i];
		rebuild(bl(l));
		push_down(bl(r));
		F(i,L(bl(r)),r)rt*=a[i];
		F(i,bl(l)+1,bl(r)-1){
			uint tmp=1;
			uint ml=0,cnt=1;
			while(tmp%mod){
				ml=ml+tmp*mul[i][cnt];
				tmp*=tag[i];
				++cnt;
			}
			rt*=ml;
		}
		return rt;
	}
}
using namespace BLK;
int main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>m;
	F(i,1,n)cin>>a[i];
	build();
	F(i,1,m){
		int op;
		cin>>op;
		if(op==1){
			int l,r;uint k;
			cin>>l>>r>>k;
			add(l,r,k);
		}
		else {
			int l,r;
			cin>>l>>r;
			cout<<query(l,r)%mod<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Polarisx (赞：2)

[P10045](https://www.luogu.com.cn/problem/P10045)。

见过这个 trick。

## 思路

考虑线段树，每个点维护一个多项式，即 $\prod_{i=l}^r (a_i+x)\pmod {2^{20}}$，这部分的贡献就是 $[x^0]\prod_{i=l}^r (a_i+x)$。

考虑区间加 $k$ 怎么做，即求 $[x^0]\prod_{i=l}^r(a_i+k+x)$，由于 $k$ 是偶数，而模数为 $2^{20}$，那么我们可以枚举 $k$ 的贡献，$[x^0]\sum_{i=0}^{19}k^{i}\left( [x^{i}]\left( \prod_{j=l}^r (a_i+x) \right) \right)$，同理可求出 $[x^1],[x^2],\cdots,[x^{19}]$ 的数值，多项式项数最多为 $t=20$，那么时间复杂度就是 $\mathcal O(nt^2\log n)$，可以过。


```cpp
#include <bits/stdc++.h>
#define ll long long
#define poly vector<int>
using namespace std;

const int L=20;
const int Maxn=3e5+6;
const int Mod=(1<<20)-1;
int n,Q;
int a[Maxn];
ll C[50][50];

inline poly operator *(const poly x,const poly y){
	int xn=x.size(),yn=y.size();
	poly z(min(xn+yn-1,L));
	for(int i=0;i<xn;i++)
		for(int j=0;j<yn and i+j<L;j++)
			z[i+j]=(z[i+j]+1ll*x[i]*y[j])&Mod;
	return z;
}
struct TREE{
	int l,r;
	poly ret; ll tag;
}tree[Maxn<<2];

inline void pushup(int node){
	tree[node].ret=tree[node<<1].ret*tree[node<<1|1].ret;
}
void buildtree(int node,int l,int r){
	tree[node].l=l,tree[node].r=r;
	if(l==r){
		tree[node].ret.resize(2);
		tree[node].ret[0]=a[l];
		tree[node].ret[1]=1;
		return ;
	}
	int mid=l+r>>1;
	buildtree(node<<1,l,mid);
	buildtree(node<<1|1,mid+1,r);
	pushup(node);
}

inline void spread(int node,int k){
	int l=tree[node].ret.size();
	tree[node].tag+=k; poly z(l);
	for(int i=0;i<l;i++){
		ll pk=1; 
		for(int j=0;i+j<l;j++){
			z[i]=(((1ll*pk*tree[node].ret[i+j])&Mod)*C[i+j][j]+z[i])&Mod;
			pk=(pk*k)&Mod;
		}	
	}
	tree[node].ret=z;
}
inline void pushdown(int node){
	if(!tree[node].tag) return ;
	tree[node].tag&=Mod;
	spread(node<<1,tree[node].tag);
	spread(node<<1|1,tree[node].tag);
	tree[node].tag=0;
}

void modify(int node,int l,int r,int k){
	if(tree[node].l>=l and tree[node].r<=r){
		spread(node,k);
		return ;
	}
	pushdown(node);
	int mid=tree[node].l+tree[node].r>>1;
	if(l<=mid) modify(node<<1,l,r,k);
	if(r>mid) modify(node<<1|1,l,r,k);
	pushup(node);
}
ll query(int node,int l,int r){
	if(tree[node].l>=l and tree[node].r<=r) return tree[node].ret[0];
	pushdown(node);
	int mid=tree[node].l+tree[node].r>>1;ll prd=1;
	if(l<=mid) prd=(prd*query(node<<1,l,r))&Mod;
	if(r>mid) prd=(prd*query(node<<1|1,l,r))&Mod;
	return prd;
}

int main(){
	for(int i=0;i<=20;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mod;
	}

	scanf("%d%d",&n,&Q);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	buildtree(1,1,n);

	while(Q--){
		int opt,l,r,k;
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1){
			scanf("%d",&k);
			if(!k) continue;
			modify(1,l,r,k);
		}
		else{
			printf("%lld\n",query(1,l,r)&Mod);
		}
	}	

	return 0;
}
```

---

## 作者：wwwwwza (赞：2)

一个有意思的 trick 值得积累。

设 $x_i=a_i-1$，则 $\prod\limits_{i=l}^r a_i=\prod\limits_{i=l}^r (x_i+1)$。

因为 $x_i$ 为偶数，所以答案式子中项数不超过 $19$。

放到线段树上维护，设 $f_i$ 表示选择 $i$ 个 $x$ 的答案。

- 合并两个区间。

$f_{rt,i}=\sum\limits_{j=0}^i f_{rt\times 2,j}\times f_{rt\times 2+1,i-j}$。

- 一个区间的数集体增加 $k$。

思考一下 $f_{rt,j}$ 能对 $f_{rt,i}(j\leq i)$ 产生什么贡献。

设区间长度为 $3$，$i=2,j=1$。

$(x_1+k)(x_2+k)+(x_2+k)(x_3+k)+(x_1+k)(x_3+k)=(x_1+x_2)\times k+(x_2+x_3)\times k+(x_1+x_3)\times k+3\times k^2$。

考虑组合意义，每一个 $j$ 能从区间长度减 $j$ 个数中选 $i-j$ 个数，这样就能对 $i$ 产生贡献。

设区间长度为 $len$。

$f_i=\sum\limits_{j=0}^i f_j\times C_{len-j}^{i-j}\times k^{i-j}$。

需要预处理组合数和 $k^{i-j}$。

将 int 改为 unsigned 可以减少取模次数。

```cpp
#include <bits/stdc++.h>
#define int unsigned int
using namespace std;
const int N=2e5+5;
const int M=20;
const int mod=(1<<20)-1;
int n,q,a[N],opt,l,r,x;
int c[N][22],ksm[(1<<20)+5][20];
struct node{
	int f[20],tag;
}tree[N<<2];
void down(int rt,int d,int l,int r){
	tree[rt].tag+=d;
	d&=mod;
	tree[rt].f[0]=1;
	for(int i=19;i>=1;i--){
		int tot=0;
		for(int j=0;j<=min(i,r-l+1);j++){
			tot+=c[r-l+1-j][i-j]*tree[rt].f[j]*ksm[d][i-j];
		}
		tree[rt].f[i]=tot;
	}
}
void pushdown(int rt,int l,int r){
	if(tree[rt].tag){
		int mid=l+r>>1;
		down(rt*2,tree[rt].tag,l,mid);
		down(rt*2+1,tree[rt].tag,mid+1,r);
		tree[rt].tag=0;
	}
}
void pushup(int *a,int b[],int c[]){
	for(int i=0;i<=19;i++){
		a[i]=0;
		for(int j=0;j<=i;j++){
			a[i]+=b[j]*c[i-j];
		}
	}
}
void update(int rt,int l,int r,int x,int y,int d){
	if(x<=l&&r<=y){
		down(rt,d,l,r);
		return;
	}
	pushdown(rt,l,r);
	int mid=l+r>>1;
	if(x<=mid)update(rt*2,l,mid,x,y,d);
	if(y>mid)update(rt*2+1,mid+1,r,x,y,d);
	pushup(tree[rt].f,tree[rt*2].f,tree[rt*2+1].f);
}
int query(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y){
		int res=0;
		for(int i=0;i<=19;i++)res+=tree[rt].f[i];
		return res;
	}
	int mid=l+r>>1,res=1;
	pushdown(rt,l,r);
	if(x<=mid)res*=query(rt*2,l,mid,x,y);
	if(y>mid)res*=query(rt*2+1,mid+1,r,x,y);
	return res;
}
void build(int rt,int l,int r){
	if(l==r){
		tree[rt].f[0]=1;
		tree[rt].f[1]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(rt*2,l,mid);
	build(rt*2+1,mid+1,r);
	pushup(tree[rt].f,tree[rt*2].f,tree[rt*2+1].f);
}
inline int read(){
	int n=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}     
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)write(x/10);
	putchar((x%10)^48);
	return;
}
signed main(){
	n=read(),q=read();
	c[0][0]=1;
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=1;j<=min(i,M);j++){
			c[i][j]=(c[i-1][j]+c[i-1][j-1]);
		}
	}
	for(int i=0;i<=mod;i++){
		ksm[i][0]=1;
		for(int j=1;j<=19;j++){
			ksm[i][j]=ksm[i][j-1]*i;
		}
	}
	for(int i=1;i<=n;i++)a[i]=read()-1;
	build(1,1,n);
	while(q--){
		opt=read(),l=read(),r=read();
		if(opt==1){
			x=read();
			update(1,1,n,l,r,x);
		}else{
			write(query(1,1,n,l,r)&mod);
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：_JF_ (赞：1)

[P10045 [CCPC 2023 北京市赛] 线段树 ](https://www.luogu.com.cn/problem/P10045)

我是分块入门选手，所以我用分块写了这个题。尽可能呈现以下我的思考过程。

维护连乘？困难。应该是往推柿子的方法靠一靠。

考虑整块我们怎么做，不妨按照惯性想我们维护一个 $lzy$ 表示加了多少数到这个块上。

比如说当前块是 $\{x,y,z\}$，加上了 $p$，那么当前块的乘积表示成 $(x+p)\times (y+p) \times (z+p)$。

简单展开，是 $xyz+xyp+xpz+xpp+pyz+pyp+ppz+ppp$。

如果我用这样的方式表示，我们不难想到，展开式的每一项其实就是在一个 $()$ 中任选一项拼起来对吧。

所以我们把当前块里面的数和加上的数（标记）分开考虑。假设我们写成下面这张图的形式;

![](https://cdn.luogu.com.cn/upload/image_hosting/izjv2ti4.png)

红色 $p$ 是系数，$x,y,z$ 是块内的数。

我们显然有，如果选了 $a$ 个块内的数，那么我们就一定选了 $siz-a$ 个系数 $p$ 对吧。 

我们专心考虑这个黑色部分。

好的，那么我们现在的一个子问题是，我要求在块内选 $[1,siz]$ 个数，他们的乘积之和是多少。

~~其实这里我在想的时候的做法要用除法，是假的，~~ 这里直接讲正解，是递推。

考虑 $f_{i,j}$ 表示前 $i$ 个数里面**选** $j$ 个数的答案。

显然有：

$$f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\times a_i$$

但是，注意到如果我们这样去重构块的话时间是 $O(n)$ 的承受不了。

~~然后这里我也没观察出来~~，注意到加上的数都是偶数，即 $p$ 是**偶数**，说明，当我的部分超过 $20$ 个的时候（从右往左），都是没有意义的（因为这个系数取模就是 $0$了）。

所以这时候我们只用 $\sqrt n\times 20$ 的时间去重构这个块。

那么注意你选了 $a$ 个系数，你就要选 $siz-a$ 个块内的数，所以要设成 $f_{i,j}$ 表示前 $i$ 个**不选** $j$ 个的答案。

这样才能保证 $j$ 这一维范围是 $20$。

有：

$$f_{i,j}=f_{i-1,j-1}+f_{i-1,j}\times a_i$$


具体的，这时候我们选的是 $i-j$ 个，这下应该这个方程就不难理解了吧。

具体实现的时候 $i$ 这维用倒序枚举就能够滚掉。

然后就正常分块就做完了。其实也不用卡常，加个快读就擦着过去了，懒。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =4e5+10;
const long long mod=(1<<20);
#define int long long 
int n,lzy[N],tot,a[N],pos[N],q,U[640][640],T[640][640],Ex[640][640],l[N],r[N];
inline int read(){
	char c; c=getchar(); int sum=0;
	while(c<'0'||c>'9')	c=getchar();
	while(c>='0'&&c<='9')	sum=sum*10+(c-'0'),c=getchar();
	return sum;
}
void CG(int x){
	for(int i=1;i<=20;i++)	T[x][i]=0; 
	T[x][0]=1;
	for(int i=l[x];i<=r[x];i++)	
		for(int j=20;j>=0;j--){
			if(j!=0)	T[x][j]=((T[x][j]%mod*a[i]%mod)%mod+T[x][j-1])%mod;
			else	T[x][j]=(T[x][j]%mod*a[i]%mod)%mod;
		}
}
void Devide(){
	int len=sqrt(n),tot=n/len; if(len*len!=n)	tot++;
	for(int i=1;i<=tot;i++)	l[i]=(i-1)*len+1,r[i]=l[i]+len-1;
	r[tot]=n;
	for(int i=1;i<=tot;i++)	for(int j=l[i];j<=r[i];j++)	pos[j]=i;
	for(int i=1;i<=tot;i++)	CG(i);
//	cout<<"check"<<' '<<T[1][10]<<endl;
}
void update(int L,int R,int x){
	if(pos[L]==pos[R]){
		for(int i=L;i<=R;i++)	a[i]+=x,a[i]%=mod;
		CG(pos[L]);
		return ;
	}
	for(int i=L;i<=r[pos[L]];i++)	a[i]+=x,a[i]%=mod; CG(pos[L]);
	for(int i=l[pos[R]];i<=R;i++)	a[i]+=x,a[i]%=mod; CG(pos[R]);
	for(int i=pos[L]+1;i<=pos[R]-1;i++)	lzy[i]+=x,lzy[i]%=mod;
}
int Query(int L,int R){
	int ans=1;
	if(pos[L]==pos[R]){
		for(int i=L;i<=R;i++)	ans*=(a[i]+lzy[pos[L]])%mod,ans%=mod;
		return ans;
	}
	for(int i=L;i<=r[pos[L]];i++)	ans*=(a[i]+lzy[pos[L]])%mod,ans%=mod;
	for(int i=l[pos[R]];i<=R;i++)	ans*=(a[i]+lzy[pos[R]])%mod,ans%=mod;
	for(int i=pos[L]+1;i<=pos[R]-1;i++){
		int Sum=0,prs=20;
		int lst=min(prs,r[i]-l[i]+1);
		for(int j=1,p=0;p<=lst;p++,j=(j%mod*lzy[i]%mod)%mod)	Sum+=T[i][p]*j,Sum%=mod; // i block p jieduan 
		ans=ans*Sum; ans%=mod;	
	}
	return ans;
}
signed main(){
//	freopen("1.in","r",stdin); 
	n=read(),q=read();
	for(int i=1;i<=n;i++)	a[i]=read();
	Devide();
	while(q--){
		int op,l,r,x;
		op=read(),l=read(),r=read();
		if(op==1)	x=read(),update(l,r,x);
		else printf("%lld\n",Query(l,r));
	}
	return 0;
}
```

---

## 作者：yzq_yzq (赞：0)

命 $x=2$ 就是序列操作那个题的弱化版。

复述一下做法，维护 $f_i$ 为当前区间选 $i$ 个数时所有方案的乘积的和。对于加 $x$ 的 tag，命修改后的答案是 $f'$ 考虑把它展开过后，发现 $f'_i = \sum\limits_{j=0}^i f_j\times C_{len-j}^{i-j}\times x^{i-j}$ ，其中 $len$ 是区间长度。

这个题数据范围大一些，但是取模是模 $2^{20}$ ，用位运算会快一倍多。

---


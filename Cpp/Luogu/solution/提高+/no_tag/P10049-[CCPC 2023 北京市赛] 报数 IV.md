# [CCPC 2023 北京市赛] 报数 IV

## 题目背景

这是小 R 和小 Z 第四次玩报数游戏了，因此他们决定不再编冗长的题面了。你只需要知道，他们又编了一个奇怪的报数规则，然后想算一下有哪些数字可以报出来。

## 题目描述

对于任意正整数 $n$，定义函数 $f(n)$ 为 $n$ 在十进制下各个数位之和，如 $f(114514)=1+1+4+5+1+4=16$。显然 $f(n)$ 也是正整数，因此可以嵌套地考虑 $f(f(n)),f(f(f(n)))$ 等等。进而对于正整数 $n,k$ 可以定义 $g(n,k)=f(f(...f(n)))$（共有 $k$ 层 $f$）。

为了让报数游戏不再每局都是一模一样的，小 R 和小 Z 决定为每局游戏设置两个正整数 $k,m$，然后规定：在这一局游戏中，所有满足 $g(n,k)=m$ 的正整数 $n$ 都是不能报出的。

因为两人都是游戏高手，为防止游戏无限进行下去，每局游戏中还给出了一个正整数 $N$ 表示报数的上界。两人想知道：在不超过 $N$ 的正整数中，有多少是按这个规则不能报出的。

## 说明/提示

第一局游戏中，不能报出的数有 $5,14,23,32,41,50,104,113$。

## 样例 #1

### 输入

```
2
114 1 5
514 2 10```

### 输出

```
8
10```

# 题解

## 作者：mango2011 (赞：6)

这道题算是比较套路的一道题目吧，下面是我的方法：

$1.$ 由于 $k$ 的值巨大，所以不可能真的模拟，容易验证当 $k\ge4$ 时，最终的值一定是一位数（变成一位数之后不再改变），所以，如果 $k\ge4$，则令 $k=4$。

$2.$ 由于 $f(n)$ 的值下降迅速，而 $n$ 的值很大，所以考虑先进行一次操作，于是易知新的 $n'\le9000$，可以进行计算。

$3.$ 经过上面两步的转化，对于任意一个满足 $g(t,\min(4,k)-1)=m$ 的 $t$，答案都可以加上 $\le n$ 并且数位和为 $t$ 的数的个数。

$4.$ 由于 $3$，即把统计答案的过程分为两部分：

$1)$ 统计数位和为 $t(t\le9000)$ 的数的个数（非常简单的数位 $dp$）。

$2)$ 按照 $3$ 的思路统计答案。

$5.$ 时间复杂度正确，可以通过。

$6.$ 代码实现（码丑勿喷）：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int m,k,l,dp[1005][9005];
const int mod=1e9+7;
int o(int x)
{
    int res=0;
    while(x)
    {
        res+=x%10;
        x/=10;
    }
    return res;
}
bool pd(int x)
{
    int i;
    for(i=1;i<=k;i++)
    {
        x=o(x);
    }
    if(x==m)
    {
        return true;
    }
    return false;
}
void solve()
{
    int i,j,k,sum=s[0]-'0';
    memset(dp,0,sizeof(dp));
    for(i=0;i<s[0]-'0';i++)
    {
        dp[0][i]=1;
    }
    for(i=1;i<l;i++)
    {
        for(j=0;j<=9*(i+1);j++)
        {
            if(j-sum<s[i]-'0'&&j-sum>=0)
            {
                dp[i][j]++;
            }
            for(k=0;k<=9;k++)
            {
                if(k>j)
                {
                    break;
                }
                dp[i][j]+=dp[i-1][j-k];
                dp[i][j]%=mod;
            }
        }
        sum+=s[i]-'0';
    }
    dp[l-1][sum]++;
}
int main()
{
    ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);
    int T,ans,i;
    cin>>T;
    while(T--)
    {
        cin>>s>>k>>m;
        if(k>4)
        {
            k=4;
        }
        k--;
        l=s.size();
        solve();
        ans=0;
        for(i=1;i<=9000;i++)
        {
            if(pd(i))
            {
                ans+=dp[l-1][i];
                ans%=mod;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：冷却心 (赞：0)

简单数位 dp 题。

先考虑 $k=1$ 怎么做。一个简单的数位 dp，记 $f_{i,j}$ 表示 $i$ 个位置任意填入 $[0,9]$ 总和为 $j$ 的方案数，那么我们为了满足 $\le N$ 的限制，枚举前若干位和 $N$ 相同，当前位置小于 $N$ 对应位置，后面任意填入，求和就是方案数，注意统计原数的贡献。于是我们记 $\text{cnt}(n,y)$ 表示小于等于 $n$ 数位和恰为 $y$ 的数个数。

然后考虑任意情况。我们有一些观察：对于 $n \le 10^{1000}$，最大的数位和只有 $9000$，小于等于 $9000$ 最大的数位和只有 $35$，小于等于 $35$ 最大的数位和只有 $11$，最后再做一次就是个位数。也就是说 $k>4$ 只是诈骗，$k=4$ 以后 $g$ 的值不变。所以我们可以只讨论 $k\le 4$ 的情况。

- $k=1$：答案就是 $\text{cnt}(N,m)$。
- $k=2$：此时我们枚举上一次得到的数位和 $t$，范围为 $9000$，判断它的数位和是否等于 $m$，如果等于那么答案加上 $\text{cnt}(N,t)$。
- $k=3$：类似的，枚举 $1\le t \le 11$，判断数位和是否等于 $m$，如果等于那么同 $k=2$ 加入答案。
- $k=4$：同理。

然后做完了。预处理 $f$ 复杂度 $O(n^2)$，其中 $n$ 是 $N$ 的位数，每次求 $\text{cnt}(x,y)$ 的复杂度是 $O(n)$，单组数据显然至多询问 $9000$ 次（事实上远远跑不满）。


```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e3 + 10;
const int M = 9e3 + 10;
const int MOD = 1e9 + 7;
int F[N][M];
char S[N]; int len, K, m;

int Count(int n) {
	if (n > 9000) return 0;
	int res = 0, sum = 0;
	for (int i = 1; i <= len; i ++) {
		for (int j = 0; j < S[i] - '0'; j ++) if (sum + j <= n) {
			res = (res + F[len - i][n - sum - j]) % MOD;
		} sum += S[i] - '0';
	} 
	return (res + (sum == n)) % MOD;
}

vector<int> vec[N];

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	F[0][0] = 1;
	for (int i = 1; i <= 1000; i ++) for (int j = 0; j <= i * 9; j ++) {
		for (int k = 0; k <= min(j, 9); k ++) F[i][j] = (F[i][j] + F[i - 1][j - k]) % MOD; 
	}
	for (int i = 1; i <= 9000; i ++) {
		int c = 0, t = i;
		while (t) c += t % 10, t /= 10;
		vec[c].push_back(i);
	}
	int _; cin >> _;
	while (_ --) {
		cin >> (S + 1) >> K >> m; K = min(K, 4); len = strlen(S + 1);
		if (K == 1) { cout << Count(m) << "\n"; continue; }
		else if (K == 2) {
			if (m >= 50) { cout << "0\n"; continue; }
			int Ans = 0;
			for (int x : vec[m]) Ans = (Ans + Count(x)) % MOD;
			cout << Ans << "\n";
		} else if (K == 3) {
			int Ans = 0;
			for (int i = 1; i <= 50; i ++) if (i % 10 + i / 10 == m)
				for (int x : vec[i]) Ans = (Ans + Count(x)) % MOD;
			cout << Ans << "\n";
		} else {
			int Ans = 0;
			for (int i = 1; i <= 20; i ++) if (i % 10 + i / 10 == m) 
				for (int j = 1; j <= 50; j ++) if (j % 10 + j / 10 == i)
					for (int x : vec[j]) Ans = (Ans + Count(x)) % MOD;
			cout << Ans << "\n";
		}
	}
	return 0;
}
```

---


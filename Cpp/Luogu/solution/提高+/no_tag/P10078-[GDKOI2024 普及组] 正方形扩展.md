# [GDKOI2024 普及组] 正方形扩展

## 题目描述

现在，在笛卡尔坐标系（无限大二维平面）上有 $n$ 个种类互不相同的细菌，它们所在的坐标也互不相同。

随着时间的增加，细菌们不断繁殖，以正方形的形状、用相同的正方形扩张速度，同时扩张自己的领地。

具体来说对于任意时刻 $t$、平面上任意一点 $p$，假设该点 $p$ 上存在第 $i$ 种细菌，那么有以下两种情况：

- 如果以点 $p$ 为中心的任意正方形都含有其他种类的细菌，则该点的细菌将不会扩张（可以称之为“接触抑制”）。

- 如果存在一个以 $p$ 为中心的正方形不含有其他种类的细菌，则该点的细菌将会进行扩张。

注意，扩展出去的同种细菌也具备一样的扩展能力。

以下是一些简单的关于正方形扩展的例子：

若初始时，平面只有唯一的一个细菌位于 $(0, 0)$，那么过一个单位时间后，这一类细菌将占领 $(1, 1) (1, -1) (-1, -1) (-1, 1)$ 围成的正方形。

若初始时，平面有两个细菌分别位于 $(0, 0)$ 和 $(1, 0)$，那么最终 $(0.5, 0)$ 会成为他们领地的分界线，一开始位于 $(0, 0)$ 的细菌会占领 $(0.5, 0)$ 左侧的全部区域，位于 $(1, 0)$ 的细菌会占领 $(0.5, 0)$ 右侧的全部区域。

现在询问对于第 $i$ 种细菌，询问其占领面积能否趋于无穷大。

## 说明/提示

**【样例解释】**

在第二个样例，点 $(0, 0)$ 最终拥有的领地是直线 $x = -1$ 与 $x = 1$ 夹的中间部分，面积趋于无穷大。

**【数据范围】**

对于 $25\%$ 数据，$n \leq 10^2$。

对于 $50\%$ 数据，$n \leq 10^3$。

对于 $75\%$ 数据，$n \leq 10^5$。

对于 $100\%$ 数据，$1\leq n \leq 10^6$，$-10^9 \leq x_i, y_i \leq 10^9$。

## 样例 #1

### 输入

```
5
0 0
2 0
2 2
0 2
1 1```

### 输出

```
11110```

## 样例 #2

### 输入

```
3
-2 0
0 0
2 0```

### 输出

```
111```

## 样例 #3

### 输入

```
7
-7 -8
5 -9
1 -5
9 -4
-8 3
-2 -3
-4 -6```

### 输出

```
1101110```

# 题解

## 作者：sleepy66 (赞：5)

~~我是不会告诉你我赛时权值线段树被卡拿了 $75$ 分的。~~

考虑一个点怎样会被围住而无法扩展，显然是四面都被阻挡了。接着可以探究一下一个点在一个方向什么会被阻挡，有以下两种情况：

1. 被一个点挡住，当且仅当这两点平行于横轴或者纵轴。

![情况1](https://cdn.luogu.com.cn/upload/image_hosting/w0euhglz.png)

如图，红点的左侧被蓝点挡住，蓝点的右侧被红点挡住。

2. 被两个点一起卡住，当且仅当这两点在被堵住点的一个方向的两端，且三点不共线。

![情况2](https://cdn.luogu.com.cn/upload/image_hosting/hp02n93f.png)

如图，蓝点的右侧被红点和橙点卡住了，其中蓝点的右上角有红点，右下角有橙点。

首先情况 $1$ 很容易证，这两点所扩展的区域相交时，由于时间相同，所以相交时所接触的面也相同，所以它们会互相卡住，如下图的蓝点和红点互相挡住。

![证明1](https://cdn.luogu.com.cn/upload/image_hosting/t3wmnkyl.png)

情况 $2$ 比较麻烦，有很多细节。我们可以发现，任意一个点都会把另一个点的扩展向一个方向压缩，如左上图，所以当两个点把另一个点往相反的方向压缩，最后使被压缩的点的扩展空间越来越小，最后无限趋近于 $0$，如右上图，还有一种特殊情况是三点共线，此时中间的那个点无法被有效地在我们理想的方向压缩，如左下图。

![证明2](https://cdn.luogu.com.cn/upload/image_hosting/h65rqqpb.png)

由此，我们就知道了如何判断一个点是否能无限扩展。

我们可以直接排序和通过维护最值来判断一个区域是否有点，判断一个点的四边是否被挡住，具体实现见代码。

其实也可以用树套树或者权值线段树实现，但是会被卡掉一部分分。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define N 1000010
int n,maxn,minn,mxn[N],mnn[N];
bool f[N];
struct node{int x,y,id;}p[N];
bool cmpx(node a,node b){return a.x<b.x;}
bool cmpy(node a,node b){return a.y<b.y;}
void update(int x){
	maxn=max(maxn,x);
	minn=min(minn,x);
	return;
}
bool check(int x,int i){//判断是否会被挡住 
	if(mxn[i]>x&&minn<=x)return true;
	if(mnn[i]<x&&maxn>=x)return true;
	if(maxn>=x&&minn<=x)return true;
	return false;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>p[i].x>>p[i].y;
		p[i].id=i;
	}
	sort(p+1,p+n+1,cmpy);
	maxn=-1e18,minn=1e18;
	for(int i=1;i<=n;i++){//预处理y相等的情况 
		mxn[i]=mnn[i]=p[i].x;
		if(i>1&&p[i].y==p[i-1].y){
			mxn[i]=max(mxn[i],mxn[i-1]);
			mnn[i]=min(mnn[i],mnn[i-1]);
		}
	}
	for(int i=n-1;i>0;i--){
		if(p[i].y==p[i+1].y){
			mxn[i]=mxn[i+1];
			mnn[i]=mnn[i+1];
		}
	}
	for(int i=1;i<=n;i++){//下面 
		int l=i-1;
		while(l>0&&p[l].y==p[i-1].y&&p[l].y!=p[i].y){
			update(p[l].x);
			l--;
		}
		if(!check(p[i].x,i)){
			f[p[i].id]=true;
		}
	}
	maxn=-1e18,minn=1e18;
	for(int i=n;i>0;i--){//上面 
		int l=i+1;
		while(l<=n&&p[l].y==p[i+1].y&&p[l].y!=p[i].y){
			update(p[l].x);
			l++;
		}
		if(!check(p[i].x,i)){
			f[p[i].id]=true;
		}
	}
	sort(p+1,p+n+1,cmpx);
	for(int i=1;i<=n;i++){//预处理x相等的情况 
		mxn[i]=mnn[i]=p[i].y;
		if(i>1&&p[i].x==p[i-1].x){
			mxn[i]=max(mxn[i],mxn[i-1]);
			mnn[i]=min(mnn[i],mnn[i-1]);
		}
	}
	for(int i=n-1;i>0;i--){
		if(p[i].x==p[i+1].x){
			mxn[i]=mxn[i+1];
			mnn[i]=mnn[i+1];
		}
	}
	maxn=-1e18,minn=1e18;
	for(int i=1;i<=n;i++){//左侧 
		int l=i-1;
		while(l>0&&p[l].x==p[i-1].x&&p[l].x!=p[i].x){
			update(p[l].y);
			l--;
		}
		if(!check(p[i].y,i)){
			f[p[i].id]=true;
		}
	}
	maxn=-1e18,minn=1e18;
	for(int i=n;i>0;i--){//右侧 
		int l=i+1;
		while(l<=n&&p[l].x==p[i+1].x&&p[l].x!=p[i].x){
			update(p[l].y);
			l++;
		}
		if(!check(p[i].y,i)){
			f[p[i].id]=true;
		}
	}
	for(int i=1;i<=n;i++){
		if(f[i])cout<<'1';
		else cout<<'0';
	}
	return 0;
}

```
附赠一组测试样例：

```cpp
4
1 1
1 2
0 0
2 0
```


---

## 作者：gaozeju (赞：1)

### 前言
随机跳题跳到这题，发现题很熟悉，看标题发现是自己打过的比赛，发篇题解纪念一下。
### 正文  
看到这种有趣题面肯定先是手玩一下。  
在只有两个细菌的情况下，两个细菌的边界会有三种情况：
1. 相遇时两角相遇，形成一条斜线。
2. 相遇时两边相遇且完全重合，形成一条直线。
3. 相遇时两边相遇但不完全重合，形成一小段线段加两条斜射线。

根据这个规律可以猜想并证明：  

**一个细菌能够无限拓展，当且仅当它至少能在横向或竖向或 $45^\circ$ 斜向 上无限拓展。**

于是尝试分类讨论。

#### 横（竖）向
以向左为例，当且仅当它是最左边的点（之一）。  
充分性显然，必要性可以证明比它更靠左的点最终一定会把它挤掉。  
因此直接求最大/最小值并判断。
#### 斜向
以向左下为例，当且仅当其左下方（包括边界）没有任何点。如果这个点在坐标轴上的原点处，就相当于要求第三象限、$x$ 轴负半轴，$y$ 轴负半轴没有任何点。  
排序后进行判断。
### 代码
短。  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+7, inf = 1e9+7;
int n;
struct uct{
	int x, y;//坐标
	int id;//原下标
	bool operator <(const uct v)const{//重定义排序方式
		if(x == v.x) return y < v.y;
		return x < v.x;
	}
}a[N];
bool ans[N];//答案
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	a[0] = (uct){-inf, -inf, 0};//边界小处理，避免后面判断时出问题
	a[n+1] = (uct){inf, inf, 0};
	for(int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y, a[i].id = i;
	int maxn = -inf, minn = inf;
	for(int i = 1; i <= n; i++) maxn = max(maxn, a[i].x), minn = min(minn, a[i].x);
	for(int i = 1; i <= n; i++) ans[i] = ans[i]||(maxn == a[i].x)||(minn == a[i].x);//向左和向右判断
	maxn = -inf, minn = inf;
	for(int i = 1; i <= n; i++) maxn = max(maxn, a[i].y), minn = min(minn, a[i].y);
	for(int i = 1; i <= n; i++) ans[i] = ans[i]||(maxn == a[i].y)||(minn == a[i].y);//向上和向下判断
	sort(a+1, a+n+1);
	maxn = -inf, minn = inf;
	for(int i = 1; i <= n; i++){
		if((a[i].x != a[i-1].x && a[i].y < minn) || (a[i].x != a[i+1].x && a[i].y > maxn)) ans[a[i].id] = 1;//左下和左上判断，注意排序方式与这里的联系
		minn = min(minn, a[i].y), maxn = max(maxn, a[i].y);
	}
	maxn = -inf, minn = inf;
	for(int i = n; i >= 1; i--){
		if((a[i].x != a[i-1].x && a[i].y < minn) || (a[i].x != a[i+1].x && a[i].y > maxn)) ans[a[i].id] = 1;//右下和右上判断
		minn = min(minn, a[i].y), maxn = max(maxn, a[i].y);
	}
	for(int i = 1; i <= n; i++) cout << ans[i];
	return 0;
} 
```

---

## 作者：cqbzlym (赞：0)

关键词：**分类讨论**、**扫描线**。

理论上看懂了就是水题，可惜题面有点过于考验选手自动补全能力了。

就是说，一个点如果被染了某种颜色，并且以它为中心的边长为 $2$ 的正方形中没有其他颜色的点，就把这个正方形里的点都染成这个颜色，问每个颜色面积是否能达到无穷大。

考虑无法达到无穷大的原因，一定是因为向四个方向都无法延伸到无穷远。以右边为例，考虑点 $i$ 什么时候不能在 $x$ 轴正方向上延伸到无穷远：

- 对于 $\forall \, j,x_j\le x_i$，$j$ **不会**对 $i$ 向右的延伸带来任何影响——所有点的延伸速度相同。

- 对于 $x_j>x_i$ 且 $y_j=y_i$，$j$ 可以堵住 $i$。

  这时候不免产生疑问：$i$ 不能从上下「翻越」过 $j$ 的统治吗？

  显而易见地，由于延伸速度相同，$i$ 在某时刻能够在 $y$ 轴上到达的高度，$j$ 也能达到，所以 $j$ **能够**把 $i$ 堵死，参见样例二。

- 对于 $x_j>x_i$ 且 $y_j \ne y_i$，由上所述，$j$ 在 $y$ 轴下 / 上方向**无法**追上 $i$，$i$ 可以从该方向越过 $j$，在 $x$ 轴正方向上延伸到无穷远；但 $j$ 在自己所在的一侧（上 / 下）**可以**堵住 $i$。

- 对于 $x_j,x_k>x_i$ 且 $(y_j-y_i)(y_k-y_i)<0$（即二者分居 $i$ 点上下），$j$ 和 $k$ **可以**在两个方向分别拦截住 $i$。

  此时可能有疑问：$i$ 可不可以先越过 $j$ ，再越过 $k$ 呢？答案是否定的。由上，$j$ 和 $k$ 会分别在 $y$ 轴自身对应方向上堵住 $i$，在越过其中之一后无法从这一侧越过另一个点，所以 $i$ 会被两个点合作堵死。
- **特别地**，若 $j$ 和 $k$ **之一**的 $x=x_i$，和上一种情况其实是等价的，但这个等号很容易讨论漏。此时你将获得 75pts 的高分。

由此我们总结出，$i$ 能在 $x$ 轴正方向被拦截，当且仅当：

- 存在 $x_j>x_i$ 且 $y_j=y_i$；
- 抑或，存在 $x_j,x_k>x_i$ 且 $y_j\le y_i,y_k\ge y_i$ 且**两个等号不同时取到**。

那么可以从四个方向分别用扫描线求解。鉴于和实际坐标数值没有什么直接关系，可以离散化后树状数组以避免被卡常。

为了处理上面加粗的那种情况，实现的时候肯定是不太舒服（恶心）的。这里给一组好用的数据，来自 @vegetable_chili：

```plain
4
1 1
1 2
0 0
2 0
```

处理的时候觉得代码不太优美也不用担心，这个问题似乎确实没办法用优美的方法解决。

```cpp
#include <bits/stdc++.h>
const int maxn = 2e6 + 5;
int lim, bit[maxn];
int lowbit(int x) { return x & -x; };
void add(int x, int v) {
	for (; x <= lim; x += lowbit(x))
		bit[x] += v;
	return;
}
int ask(int x) {
	int res = 0;
    // printf("  # ask(%d) = ", x);
	for (; x; x -= lowbit(x))
		res += bit[x];
    // printf("%d\n", res);
	return res;
}
int ask(int l, int r) {
	return ask(r) - ask(l - 1);
}
int main() {
#ifdef ONLINE_JUDGE
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
	std::freopen(".in", "r", stdin);
	std::freopen(".out", "w", stdout);
#endif
	int n;
	std::cin >> n;
	struct _ { int x, y; };
	std::vector<int> l(1);
	std::vector<_> a(n + 1);
	for (int i = 1; i <= n; ++i) {
		std::cin >> a[i].x >> a[i].y;
		l.push_back(a[i].x), l.push_back(a[i].y);
	}
	std::sort(l.begin() + 1, l.end());
	l.erase(std::unique(l.begin() + 1, l.end()), l.end());
	lim = (int)l.size() - 1;
    std::vector<std::vector<std::pair<int, int> > > tx(lim + 1), ty(lim + 1);
	for (int i = 1; i <= n; ++i) {
		a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin();
		a[i].y = std::lower_bound(l.begin() + 1, l.end(), a[i].y) - l.begin();
        tx[a[i].x].emplace_back(a[i].y, i);
        ty[a[i].y].emplace_back(a[i].x, i);
	}
	std::vector<int> flag(n + 1);
	for (int i = 1; i <= lim; ++i) {
        std::sort(tx[i].begin(), tx[i].end());
        for (int j = 0; j < (int)tx[i].size(); ++j) {
            auto [y, id] = tx[i][j];
            if (flag[id]);
            else if (ask(y, y));
            else if (ask(1, y - 1) && ask(y + 1, lim));
            else if (j != 0 && ask(y + 1, lim));
            else if (j != (int)tx[i].size() - 1 && ask(1, y - 1));
            else
                flag[id] = 1;
        }
        for (auto [y, id] : tx[i])
            add(y, 1);
	}
	std::fill(bit + 1, bit + lim + 1, 0);
	for (int i = lim; i; --i) {
        for (int j = 0; j < (int)tx[i].size(); ++j) {
            auto [y, id] = tx[i][j];
            if (flag[id]);
            else if (ask(y, y));
            else if (ask(1, y - 1) && ask(y + 1, lim));
            else if (j != 0 && ask(y + 1, lim));
            else if (j != (int)tx[i].size() - 1 && ask(1, y - 1));
            else
                flag[id] = 1;
        }
        for (auto [y, id] : tx[i])
            add(y, 1);
    }
	std::fill(bit + 1, bit + lim + 1, 0);
	for (int i = 1; i <= lim; ++i) {
        std::sort(ty[i].begin(), ty[i].end());
        for (int j = 0; j < (int)ty[i].size(); ++j) {
            auto [x, id] = ty[i][j];
            if (flag[id]);
            else if (ask(x, x));
            else if (ask(1, x - 1) && ask(x + 1, lim));
            else if (j != 0 && ask(x + 1, lim));
            else if (j != (int)ty[i].size() - 1 && ask(1, x - 1));
            else
                flag[id] = 1;
        }
        for (auto [x, id] : ty[i])
            add(x, 1);
	}
	std::fill(bit + 1, bit + lim + 1, 0);
	for (int i = lim; i; --i) {
        for (int j = 0; j < (int)ty[i].size(); ++j) {
            auto [x, id] = ty[i][j];
            if (flag[id]);
            else if (ask(x, x));
            else if (ask(1, x - 1) && ask(x + 1, lim));
            else if (j != 0 && ask(x + 1, lim));
            else if (j != (int)ty[i].size() - 1 && ask(1, x - 1));
            else
                flag[id] = 1;
        }
        for (auto [x, id] : ty[i])
            add(x, 1);
    }
	for (int i = 1; i <= n; ++i)
		std::cout << flag[i];
	std::cout << '\n';
	return 0;
}
```

---

## 作者：Erotate (赞：0)

分类讨论好题。

我们考虑在某个方向上，出现什么情况才会使得一个点不能往这个方向一直延伸。以向上为例，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/y93zp82y.png)

红色的点由于夹在两个黑点中间，所以当红点向上延伸的同时，两个黑点同时向左、右延伸，导致红点延伸一定时间后，会被黑点挡住，无法继续延伸。

对于其他方向也是同理，那么我们知道对于一个点，在这个点的某个方向上存在两个点能把它“夹”在中间，那么这个点就不能往这个方向无限延伸。

我们只需要把 $n$ 个点按方向排 4 次序，每一次都扫一遍看看是否有点被拦住，如果一个点的 4 个方向都被拦住了，那么它就不能无限延伸，反之就可以。

最后，注意一个方向上可能存在多个点排成一条直线，所以每个方向要正反都扫一遍。


```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
typedef long long ll;
const int N=1e6+5;
struct node{
	int x,y,id;
}a[N];
int n,vis[N][4];
bool cmp1(node t1,node t2){
	 return t1.x==t2.x?t1.y<t2.y:t1.x<t2.x;
}
bool cmp2(node t1,node t2){
	return t1.y==t2.y?t1.x<t2.x:t1.y<t2.y;
}
bool cmp3(node t1,node t2){
	 return t1.x==t2.x?t1.y>t2.y:t1.x<t2.x;
}
bool cmp4(node t1,node t2){
	return t1.y==t2.y?t1.x>t2.x:t1.y<t2.y;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i].x>>a[i].y;
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp1);
	int mx=-1e9+1,mn=1e9+1;
	for(int i=1;i<=n;++i){
		if(mx>=a[i].y && mn<=a[i].y) vis[a[i].id][0]=1;
		mx=max(a[i].y,mx),mn=min(a[i].y,mn);
	}
	mx=-1e9+1,mn=1e9+1;
	for(int i=n;i>=1;--i){
		if(mx>=a[i].y && mn<=a[i].y) vis[a[i].id][1]=1;
		mx=max(a[i].y,mx),mn=min(a[i].y,mn);
	}
	sort(a+1,a+n+1,cmp2);
	mx=-1e9+1,mn=1e9+1;
	for(int i=1;i<=n;++i){
		if(mx>=a[i].x && mn<=a[i].x) vis[a[i].id][2]=1;
		mx=max(a[i].x,mx),mn=min(a[i].x,mn);
	}
	mx=-1e9+1,mn=1e9+1;
	for(int i=n;i>=1;--i){
		if(mx>=a[i].x && mn<=a[i].x) vis[a[i].id][3]=1;
		mx=max(a[i].x,mx),mn=min(a[i].x,mn);
	}
	sort(a+1,a+n+1,cmp3);
	mx=-1e9+1,mn=1e9+1;
	for(int i=1;i<=n;++i){
		if(mx>=a[i].y && mn<=a[i].y) vis[a[i].id][0]=1;
		mx=max(a[i].y,mx),mn=min(a[i].y,mn);
	}
	mx=-1e9+1,mn=1e9+1;
	for(int i=n;i>=1;--i){
		if(mx>=a[i].y && mn<=a[i].y) vis[a[i].id][1]=1;
		mx=max(a[i].y,mx),mn=min(a[i].y,mn);
	}
	sort(a+1,a+n+1,cmp4);
	mx=-1e9+1,mn=1e9+1;
	for(int i=1;i<=n;++i){
		if(mx>=a[i].x && mn<=a[i].x) vis[a[i].id][2]=1;
		mx=max(a[i].x,mx),mn=min(a[i].x,mn);
	}
	mx=-1e9+1,mn=1e9+1;
	for(int i=n;i>=1;--i){
		if(mx>=a[i].x && mn<=a[i].x) vis[a[i].id][3]=1;
		mx=max(a[i].x,mx),mn=min(a[i].x,mn);
	}
	for(int i=1;i<=n;++i){
		if(vis[i][0]+vis[i][1]+vis[i][2]+vis[i][3]==4) cout<<0;
		else cout<<1;
	}
	return 0;
}

```
PS ：

这题完全没有用任何算法，算是一道水题，我能赛时切掉完全是侥幸。

---


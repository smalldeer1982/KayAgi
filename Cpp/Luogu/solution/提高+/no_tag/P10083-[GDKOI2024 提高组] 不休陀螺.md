# [GDKOI2024 提高组] 不休陀螺

## 题目描述

有 $n$ 张牌组成一个序列，每张牌用一个二元组 $(a_i
, b_i)$ 表示，意味着打出这张牌需要消耗 $a_i$ 点费用，打出后可以获得 $b_i$ 点费用。

接下来你可以选择一个区间 $[l, r]$ 将这个区间中的卡取出来作为你的卡组。

开始时你的卡组会按照随机顺序排列并且你有 $E$ 点费用，然后你会依次从前往后打出这个排列中的卡。

当你打完这个排列中的卡后你的卡组又会重新随机排列然后你再依次打出，直到你无法再打出下一张牌（当前费用小于下一张牌需要消耗的费用）时停止。

如果一个卡组无论在什么情况下都能够无限打下去，我们则称这卡组可以“陀螺无限”。

现在求有多少个区间组成的卡组能够“陀螺无限”。

## 说明/提示

**本题使用子任务捆绑测试。**

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$0 \leq E, a_i, b_i \leq 10^9$。

- Subtask 1（20%）：$1 \leq n \leq 5000$。
- Subtask 2（10%）：$b_i \geq a_i$。
- Subtask 3（10%）：$E = 0$。
- Subtask 4（10%）：$0 \leq a_i, b_i \leq 1$。
- Subtask 5（20%）：$a_i \times b_i = 0$。
- Subtask 6（30%）：无特殊限制

## 样例 #1

### 输入

```
5 10
9 10 10 0 2
8 5 6 2 5```

### 输出

```
4```

## 样例 #2

### 输入

```
5 10
8 1 6 4 10
7 6 1 8 5```

### 输出

```
5```

# 题解

## 作者：shinzanmono (赞：8)

考虑一个区间是“陀螺无限”的充要条件。

首先，我们打完所有的牌不能有负收益，所以 $\sum_{i=l}^r(b_i-a_i)\geq0$。

其次，最差情况一定是先打负收益的牌，所以打正收益牌之前要保证第一张一定能打 $E-\sum_{i=l}^r\max(0,a_i-b_i)\geq\max_{i=l}^r{a_i[a_i<b_i]}$。

然后我们要打负收益的牌的时候保证每张都能打，所以 $E-\sum_{i=l}^r\max(0,a_i-b_i)\ge\max_{i=l}^rb_i[a_i>b_i]$。

化简一下可以得到 $E-\sum_{i=l}^r\max(0,a_i-b_i)\geq\max_{i=l}^r\min(a_i,b_i)$。

所以我们得到：$\left\{\begin{aligned}&\sum_{i=l}^r(b_i-a_i)\geq0\\&E-\sum_{i=l}^r\max(0,a_i-b_i)\geq\max_{i=l}^r\min(a_i,b_i) \end{aligned}\right.\Rightarrow$ 区间 $[l,r]$ 是“陀螺无限”的。

对于第一个不等式，令 $c_i=\sum_{j=1}^i(b_j-a_j)$，那么只需要满足 $c_r\geq c_{l-1}$。

对于第二的不等式，发现其在右端点单调不降，可以使用双指针解决。

具体地，每次拓展出最远的 $r$，将前缀和离散化后使用值域树状数组即可。

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=1e6+10;
const int lgsz=std::__lg(sz)+1;
int a[sz],b[sz],f[lgsz][sz],n;
ll c[sz],d[sz],e;
int qmax(int l,int r){
    if(l>r)return 0;
    int lg=std::__lg(r-l+1);
    return std::max(f[lg][l],f[lg][r-(1<<lg)+1]);
}
struct BIT{
    int sum[sz];
    int lowbit(int x){
        return x&-x;
    }
    void add(int p,int val){
        for(int i=p;i<=n+1;i+=lowbit(i))sum[i]+=val;
    }
    int query(int p){
        int res=0;
        for(int i=p;i>0;i-=lowbit(i))res+=sum[i];
        return res;
    }
}bit;
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n>>e;
    for(int i=1;i<=n;i++)std::cin>>a[i];
    for(int i=1;i<=n;i++)std::cin>>b[i];
    for(int i=1;i<=n;i++)c[i]=c[i-1]-a[i]+b[i],d[i]=c[i];
    std::sort(d,d+n+1);
    int len=std::unique(d,d+n+1)-d;
    for(int i=0;i<=n;i++)c[i]=std::lower_bound(d,d+len,c[i])-d+1;
    for(int i=1;i<=n;i++)f[0][i]=std::min(a[i],b[i]);
    for(int i=1;i<=std::__lg(n);i++)
    for(int j=1;j+(1<<i)-1<=n;j++)
    f[i][j]=std::max(f[i-1][j],f[i-1][j+(1<<i-1)]);
    long long ans=0;
    for(int l=1,r=1;l<=n;l++){
        while(r<=n&&qmax(l,r)<=e-std::max(a[r]-b[r],0))
            bit.add(c[r],1),e-=std::max(a[r]-b[r],0),r++;
        ans+=bit.query(n+1)-bit.query(c[l-1]-1);
        bit.add(c[l],-1),e+=std::max(a[l]-b[l],0);
    }
    std::cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：大眼仔Happy (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P10083)

## 前言

赛时感觉 6 道题唯一可以做出的题，但是赛后感觉除了三个黑题，其他也可以做一下的。看来是有场切蓝题的能力的 awa。

## 题解部分

考虑一个区间 $[l,r]$ 要满足什么性质才可以打出无限次：

- 打完一轮之后不能亏费。

- 最低的情况也需要保持 $\ge 0$。

对于第一种情况显然很好做，记录一个前缀和即可。对于第二种情况我们考虑如何快速的找到一个区间中最低的情况（找到谷）。对于 $a_i\ge b_i$ 的情况，全部选了肯定可以更低。选了这些之后，我们还可以再选择一个 $a_i$，或者在刚刚选择过的 $(a,b)$ 中，扔掉一个 $b$，就能达到最低点了。为了方便描述，前者记为 $d_i$（如果不选，则 $d_i=0$），后者记为 $p_i$，而区间 $[l,r]$ 的最低点 $pos=\displaystyle\sum_{i=l}^r d_i+\min_{i=l}^r p_i$。

时间复杂度为 $O(n^2)$，还需要优化。

可以发现，当 $r\to r+1$ 的时候，$pos$ 只会单调不增。那么就可以用双指针。这个时候就还有性质 1，用一个数据结构记录 $s$（前缀和）的权值，然后找到那些 $s_i\ge s_{l-1}$ 即可。左端点右移的时候 $\min$ 也要重新计算一次，也可以使用一个数据结构。时间复杂度为 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
#define ll long long
ll inline read()
{
    ll num=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='0')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
    return num*f;
}
int n;ll E,ans;
ll a[N],b[N],d[N],s[N],p[N],sd[N];
struct STable
{
    ll st[22][N];
    void build()
    {
        for(int i=1;i<=n;i++)st[0][i]=p[i];
        for(int i=1;(1<<i)<=n;i++)
            for(int j=1;j+(1<<i)-1<=n;j++)
                st[i][j]=min(st[i-1][j],st[i-1][j+(1<<i-1)]);
    }
    ll ask(int l,int r)
    {
        int t=__lg(r-l+1);
        return min(st[t][l],st[t][r-(1<<t)+1]);
    }
}ST;
#define lb (x&-x)
struct BIT
{
    int t[N];
    void add(int x,int v){while(x<=n+1)t[x]+=v,x+=lb;}
    int ask(int x){int res=0;while(x)res+=t[x],x-=lb;return res;}
}T;
ll c[N];
void discret(ll A[N])
{
    for(int i=0;i<=n;i++)c[i]=A[i];
    sort(c,c+1+n);int l=unique(c,c+1+n)-c-1;
    for(int i=0;i<=n;i++)A[i]=lower_bound(c,c+1+l,A[i])-c+1;
}
int main(){
    n=read();E=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)b[i]=read();
    for(int i=1;i<=n;i++)
    {
        d[i]=min(0ll,b[i]-a[i]);
        s[i]=s[i-1]+b[i]-a[i];
        p[i]=-a[i]-d[i];
        sd[i]=sd[i-1]+d[i];
    }
    discret(s);ST.build();
    for(int L=1,R=1;L<=n;L++)
    {
        ll sum=sd[R]-sd[L-1],mn=ST.ask(L,R);
        while(R<=n)
        {
            if(sum+mn+E>=0)T.add(s[R++],1),sum+=d[R],mn=min(mn,p[R]);
            else break;
        }
        ans+=R-L-T.ask(s[L-1]-1);
        if(L==R)R++;else T.add(s[L],-1);
    }
    printf("%lld",ans);
    return 0;
}
```


## My Stupid Mistake

赛时 $s_0$ 要离散化但是没做，发现了。双指针 $L>R$ 没有发现，导致 SubTask 4 获得 RE 而 SubTask 5 没炸，还以为被评测机针对了。

赛后再码一遍（没有原来代码了）有如下错误：

- `const int N=2e5+5;` 超好习惯。

- ST 表写挂了。

- `int ans;` 不开 long long 见祖宗。最简单的问题却总是在我发完帖才发现的。

---

## 作者：ran_qwq (赞：5)

好题。

upd on 1.22：题解重要结论写错，感谢@cyz2010 大佬指正。

---
首先，如果区间 $[l,r]$ 可行则必须满足 $\sum\limits_{i=l}^r(a_i-b_i)\le0$，记为第一个条件。否则每次打下去 $E$ 都会**变小**。

现在 $\sum\limits_{i=l}^r(a_i-b_i)\le0$，即如果第一个回合不停下来就可行。

考虑**贪心**，怎么尽量卡掉一个区间。

可以任意重排区间，让亏的（$a_i>b_i$，钦定 $a_i=b_i$ 为赚）的放前面，尽量把 $E$ 扣到负数。

因为是先消耗再恢复，所以现在有两种补刀的选择：

1. 把一张**亏**的牌的恢复减掉，这时候肯定减最大的。

1. 把一张**赚**的牌的消耗加上，这时候肯定也加最大的。

因为亏的 $a_i>b_i$，赚的 $a_i\le b_i$，所以贪心就等价于最大化 $\min(a_i,b_i)$。

固定左端点 $l$，$r$ 从左往右扫，同时维护所有**亏牌的** $a_i-b_i$ **之和** $sum=\sum\limits_{i=l}^r\max(a_i-b_i,0)$，以及**最大补刀伤害** $mx=\max\limits_{i=l}^r\min(a_i,b_i)$。

如果最大总伤害 $sum+mx\le E$，就能无限打下去，记为第二个条件。

对于所有 $sum+mx\le E$ 的 $[l,r]$，判断 $\sum\limits_{i=l}^r(a_i-b_i)$  是否 $\le0$。这样，就得到了一个 $O(n^2)$ 的算法，期望得分 $20$。

---
先看第二个条件。

不难发现，固定左端点 $l$，$r$ 越大，$sum$ 和 $mx$ 都具有单调性。

枚举左端点 $l$，**二分** / 用**双指针**维护右端点 $r$，判断 $sum+mx$ 和 $E$ 的大小关系。

$sum$ 可以预处理前缀和，$mx$ 可以用 **ST 表**或**线段树**。

当 $b_i\ge a_i$ 时，第一个条件恒成立，时间复杂度 $O(n\log n)$，期望得分 $30$。

赛后发现有简单得多的解法，但这种解法可以让你想到正解。

---
现在加上第一个条件。

记 $s_i=\sum\limits_{j=1}^i(a_j-b_j)$，即 $a_i-b_i$ 的**前缀和**。

则 $\sum\limits_{i=l}^r(a_i-b_i)=s_r-s_{l-1}\le0$，也就是求 $s_r\le s_{l-1}$ 的 $r$ 个数。

先把 $s$ **离散化**。双指针维护满足第一个条件最大的 $r$，同时 $s_r$ 丢到**树状数组**里，二维数点统计即可。

注意离散化、双指针、树状数组的细节。

[考场代码，写得可能有点乱。](https://www.luogu.com.cn/paste/wdr4ewm3)

---

## 作者：Luciylove (赞：4)

很经典的问题，可以参考一个比这个简单容易想的 *2500 的做法。

**先想判定条件再考虑怎么计数。**

因为少写了一个 case 导致 Au $\to$ Ag，有点难评。

不难想到记录 $c_i = b_i - a_i$。

我们考虑怎样才能无限下去：

- 卡牌打完之后的费用变化是正的，不然会一直变小，那么就是 $\sum c_i \geq 0$

考虑安排一张卡使得其付不出那么多的费用。

- 考虑全部先排负的，然后放一张正的 $a_i$ 的最大的，形式化后就是 $E + \sum \min\{c_i, 0\} < a_i (c_i > 0)$

- 考虑全部排负的中抽出一张卡使得其付不起，那么就是：$E + \sum\min\{c_i, 0\} - c_i < a_i (c_i < 0)$ 我们考虑移项，那么就是 $E + \sum\min\{c_i, 0\} < b_i (c_i < 0)$

不难发现这个就是所有的选择 hack 掉区间的方法，因为如果可以通过这三种手上的钱是会一直加的，所以更 hack 不掉了。

不难发现 $\sum \min\{c_i, 0\}$ 单调递减，满足条件的 $a_i$ 和 $b_i$ 单调递增，所以区间左端点对应的最大合法区间右端点具有单调性。我们可以双指针，也可以ST表二分来解决问题。

最后相当于数 $[l, r]$ 中 $sum_i \geq k$ 的个数，普通二维数点即可。

复杂度线性对数。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; i ++)
#define per(i, r, l) for (int i = r; i >= l; i --)

using namespace std;
typedef long long ll;
 
const int _ = 1e6 + 5;

int n, tn;
ll E;
int a[_], b[_], c[_], lg[_];
ll sum[_], sumd[_], tmp[_];
int st[_][21][2];
vector <pair<int, int> > qv[_];
ll ans = 0;

int tr[_];
void add (int x, int k) {
	for ( ; x <= tn; x += x & -x) tr[x] += k;
}
int query (int x) {
	int ret = 0;
	while(x) ret += tr[x], x -= x & -x;
	return ret;
}

/*
e + sc < mxa 
e + sc < bi
e + sc - ci < ai
*/
int querymx (int l, int r, int id) {
	int k = lg[r - l + 1];
	return max(st[l][k][id], st[r - (1 << k) + 1][k][id]);
}
bool check (int l, int r) {
	ll d = E + sumd[r] - sumd[l - 1];
//	cout << d << " " << l << " " << r << endl;
	if (d < querymx(l, r, 0) || d < querymx(l, r, 1)) return false;
	return true;
}
int main () {
	cin >> n >> E;
	lg[0] = -1, tmp[++ tn] = 0;
	rep(i, 1, n) lg[i] = lg[i >> 1] + 1, scanf("%d", & a[i]);
	rep(i, 1, n) {
		scanf("%d", & b[i]);
		c[i] = b[i] - a[i], sum[i] = sum[i - 1] + c[i];
		tmp[++ tn] = sum[i], sumd[i] = sumd[i - 1];
		if (c[i] < 0) {
			sumd[i] += c[i], st[i][0][1] = b[i];
		} else st[i][0][0] = a[i]; 
	}
	sort(tmp + 1, tmp + 1 + tn),
	tn = unique(tmp + 1, tmp + 1 + tn) - (tmp + 1);
	rep(i, 0, n) sum[i] = lower_bound(tmp + 1, tmp + 1 + tn, sum[i]) - tmp;
	rep(k, 1, 20) 
		rep(i, 1, n - (1 << k) + 1) rep(t, 0, 1) 
			st[i][k][t] = max(st[i][k - 1][t], st[i + (1 << k - 1)][k - 1][t]);
	rep(i, 1, n) {
		int l = i, r = n, retp = 0;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (check(i, mid)) l = mid + 1, retp = mid;
			else r = mid - 1;
		}
		if (retp) {
			qv[retp].push_back({sum[i - 1], 1});
			qv[i - 1].push_back({sum[i - 1], -1});
		}
	}
	rep(i, 1, n) {
		add(sum[i], 1);
		for (auto v : qv[i]) {
			int val = v.first, coef = v.second;
			ans += 1ll * (query(tn) - query(val - 1)) * coef;
		}
	}
	cout << ans;
	return 0;
} 
```


---

## 作者：听取MLE声一片 (赞：4)

首先令第 $i$ 张牌的价值为 $b_i-a_i$，代价为 $b_i$。

注意到需要无限打下去，费用不能越大越少，所以合法的第一个条件就是价值总和非负。

可以任意顺序打出牌，所以只需要考虑最坏情况。最差情况一定是先打出尽可能多的负价值牌，然后剩余费用不足以支付一张牌的代价。合法的第二个条件就是不出现这种情况。

这样又分成两类。第一类是把负价值牌全部打出去，剩余的费用小于非负价值牌中的最大代价；第二类是留下一张负价值牌，剩下的全部打出去，剩余的费用小于留下的那张牌的代价。

第一类可以简单维护，考虑第二类怎么做。设负价值总和为 $S$，留下的牌价值为 $x$，代价为 $y$，若不合法，则有 $E+S-x<y$，也就是 $E+S<x+y$。维护 $x+y$ 的最大值即可。

注意到第二类合法区间是有单调性的。因为可以以任意顺序打出牌，所以加入好的牌可以放到最后从而没有影响，而加入差的牌可以放在前面，因此长度越长就越不容易合法。

有单调性就可以用双指针求出每个左端点对应的右端点区间。

接下来考虑第一个条件，即为区间和非负。对价值做前缀和，区间 $[l,r]$ 的和即为 $sum_r-sum_{l-1}$，非负情况即为 $sum_r\ge sum_{l-1}$。对 $sum_i$ 排序并赋编号，双指针拓展时加入对应编号，双指针删除时删除对应编号，对于左端点为 $l$ 的区间查询小于 $l-1$ 对应编号的个数即可。可以用树状数组维护。

总时间复杂度 $O(n\log n)$，可以通过此题。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e6+10;
const int inf=2e9;
int n,k,ans,a[N],b[N],A[N],B[N],sum[N],pos[N],id[N];
int p,S;
int cmp(int x,int y){
	if(sum[x]==sum[y])return x>y;
	return sum[x]>sum[y];
}
struct Heap{
	priority_queue<int>q1,q2;
	void ins(int x){
		q1.push(x);
	}
	void del(int x){
		q2.push(x);
	}
	int qmax(){
		while(!q1.empty()&&!q2.empty()){
			if(q1.top()!=q2.top())
				return q1.top();
			q1.pop(),q2.pop();
		}
		if(!q1.empty())return q1.top();
		return 0;
	}
	void init(){
		while(!q1.empty())q1.pop();
		while(!q2.empty())q2.pop();
		q1.push(-inf);
		q2.push(-inf);
	}
}T1,T2;
int check(int p){
	if(k+S<b[p])return 0;
	if(a[p]<0){
		int x=k+S+a[p];
		if(x<T1.qmax())return 0;
		if(x<T2.qmax())return 0;	
	}
	return 1;
}
struct Tree{
	int a[N];
	inline void add(int x,int y){
		for(;x<=n+1;x+=x&(-x))
			a[x]+=y;
	}
	inline int sum(int x){
		int res=0;
		for(;x;x-=x&(-x))
			res+=a[x];
		return res;
	}
}T;
signed main()
{
	//freopen("top.in","r",stdin);
	//freopen("top.out","w",stdout);
	n=read(),k=read();
	for(int i=1;i<=n;i++)
		A[i]=read();
	for(int i=1;i<=n;i++)
		B[i]=read();
	for(int i=1;i<=n;i++){
		a[i]=B[i]-A[i];
		b[i]=A[i];
		sum[i]=sum[i-1]+a[i];
		pos[i]=i;
	}
	sort(pos,pos+n+1,cmp);
	for(int i=0;i<=n;i++)id[pos[i]]=i+1;
	T1.init();
	T2.init();
	for(int l=1;l<=n;l++){
		while(p<n&&check(p+1)){
			p++;
			T.add(id[p],1);
			if(a[p]<0){
				S+=a[p];
				T2.ins(a[p]+b[p]);
			}
			else T1.ins(b[p]);
		}
		if(p>=l){
			ans+=T.sum(id[l-1]);
			T.add(id[l],-1);
			if(a[l]<0){
				S-=a[l];
				T2.del(a[l]+b[l]);
			}
			else T1.del(b[l]);
		}
		else{
			p=l;
			S=0;
			T1.init();
			T2.init(); 
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：未来姚班zyl (赞：2)

~~好久没写题解了，来补一篇。~~

## 题目大意

你初始有 $E$ 点费用，同时有 $n$ 张牌，每张牌有代价 $a_i$，贡献 $b_i$。抽一张牌要先消耗 $a_i$ 的费用，然后获得 $b_i$ 的费用。

对于每个区间的牌，会不断重复以下步骤：

按照随机的顺序抽取每张牌各一次，如果在抽一张牌时当前费用小于这张牌的代价 $a_i$，就嘎了。

如果按照任意的顺序抽牌都不会嘎，这个区间就是好的，对好的区间计数。

## 题目分析

显然，如果想让你嘎，只有两种可能。

- 第一种，$\sum a_i>\sum b_i$，这样 $E$ 会不断减小，直到 $E<0$。

- 第二种，考虑贪心，钦定在抽 $i$ 号牌时会噶，则肯定先把其它牌中 $a_j>b_j$ 的牌 $j$ 先抽走，再来抽 $i$。

反过来，设 $a_i>b_i$ 的牌是 $A$ 类牌，剩下的是 $B$ 类牌，$A$ 类牌的总消耗 $\sum\limits_{i\in A} a_i-b_i=C$。一个区间是好的，，当且仅当：

- $\sum a_i\le\sum b_i$。

- $\forall i\in B,E-C\ge a_i$。

- $\forall i\in A,E-C+a_i-b_i\ge a_i$，即 $E-C\ge b_i$。

观察后两个式子，设每张牌有权值 $c_i$，其中对于 $A$ 类牌，$c_i=b_i$，对于 $B$ 类牌，$c_i=a_i$。后两个式子就能化为 $\forall i,E\ge C+c_i$，即 $E\ge C+\max (c_i)$。观察到右端点固定时，$C$ 和 $\max(c_i)$ 随着左端点左移单调不降，所以对每个右端点 $r$ 可以二分出最靠左的左端点 $l$，两个值分别用前缀和和 ST 表维护即可。

还有第一个式子，化为 $\sum b_i-a_i\ge 0$。对 $b_i-a_i$ 求后缀和，则统计相当于二维数点，离线树状数组即可，复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N =1e6+5;
int n,k,a[N],b[N];
int st[N][21];
inline void prep_st(){
    repn(i)st[i][0]=a[i]>b[i]?b[i]:a[i];
    rep(p,1,20)rep(i,1,n-(1<<p)+1)st[i][p]=max(st[i][p-1],st[i+(1<<p-1)][p-1]);
}
inline int getmx(int l,int r){
    int p=__lg(r-l+1);
    return max(st[l][p],st[r-(1<<p)+1][p]);
}
ll pr[N],ans;
inline ll get(int l,int r){
    return pr[r]-pr[l-1];
}
ll c[N];
int t[N];
inline void add_(int x){
    while(x<=n)t[x]++,x+=x&-x;
}
inline int query(int x){
    int ans=0;
    while(x)ans+=t[x],x-=x&-x;
    return ans;
}
int le[N];
inline bool cmp(int a,int b){
    return c[a]==c[b]?a<b:c[a]>c[b];
}
signed main(){
    n=read(),k=read();
    repn(i)a[i]=read();
    repn(i)b[i]=read();prep_st();
    repn(i)pr[i]=pr[i-1]+max(0,a[i]-b[i]);
    per(i,n,1)c[i]=c[i+1]+b[i]-a[i];
    repn(i){
        int l=1,r=i,as=i+1;
        while(l<=r)if(getmx(mid,i)+get(mid,i)<=k)as=mid,r=mid-1;
        else l=mid+1;
        le[i]=as;
    }
    rep(i,1,n+1)a[i]=i;
    sort(a+1,a+n+2,cmp);
    rep(i,1,n+1){
        add_(a[i]);
        if(a[i]!=1)ans+=query(a[i]-1)-query(le[a[i]-1]-1);
    }
    cout <<ans;
    return 0;
}
```


---

## 作者：Inui_Sana (赞：2)

现场做了，离散化数组没开 ll，被卡 au 线 $\to$ 卡线 ag。

因为代码是半个月前写的了，回忆做法时可能有点偏差，如果发现有误请联系我修改。:)

考虑怎么刻画题目所给条件。发现对于一个区间 $[l,r]$，可以钦定其中一个卡牌 $i$，使得这张卡牌是第一张无法打出的牌。然后考虑它前面放什么牌，会发现前面会放所有 $a_i>b_i$ 的牌。

然后用形式化语言刻画可以无限取下去的条件。设 $c_i=a_i-b_i$，则一个区间可行，可以分成两种情况。

- 钦定的牌 $a_i\leq b_i$ 时，$\not\exists i, E-\sum\limits_{j\in[l,r]\land c_j>0}c_j<a_i$。

- 否则，$\not\exists i,E-\sum\limits_{j\in[l,r]\land c_j>0}c_j+a_i-b_i<a_i$ 即 $E-\sum\limits_{j\in[l,r]\land c_j>0}c_j<b_i$。

- 任何情况下，$\sum\limits_{i\in[l,r]} c_i\ge 0$，否则一定无法无限取。

~~感性与理性并用地理解~~容易发现前面两个限制是满足单调性的，原因显然。于是想到固定右端点 $r$，二分 $l$。但是又有一个问题：因为 $c_i$ 不一定非负，所以**这些所有限制并不是满足单调性的**。于是考虑对于每个右端点，求出极大区间 $[L_i,R_i]$，再用前缀和 $s_i=\sum_{j\le i}c_j$ 转化一下第三个限制，则一个区间 $[l,r]$ 符合条件的限制条件变成：

$$L_r\le l\le R_r\land s_r\ge s_{l-1}$$

这显然是一个二维数点问题，扫描线解决。时间复杂度 $O(n\log n)$。

code：

```cpp
bool Mbe;
int n,m,a[N],b[N];
ll s[N],A[N],B[N],d[N];
vector<int> g[N];
struct STable{
	int st[2][N][23],lg[N],pw[107];
	void init(){
		rep(i,1,n){
			st[0][i][0]=st[1][i][0]=-inf;
			if(a[i]>b[i])st[0][i][0]=b[i];
			else st[1][i][0]=a[i];
		}
		rep(i,2,n)lg[i]=lg[i>>1]+1;
		rep(i,0,30)pw[i]=1<<i;
		rep(j,1,lg[n]){
			rep(i,1,n-pw[j]+1){
				rep(k,0,1)st[k][i][j]=max(st[k][i][j-1],st[k][i+pw[j-1]][j-1]);
			}
		}
	}
	il int qryMax(int l,int r,int p){
		int k=lg[r-l+1];
		return max(st[p][l][k],st[p][r-pw[k]+1][k]);
	}
}T;
struct BIT{
	int tr[N];
	#define lb(x) (x&(-x))
	il void upd(int x,int y){while(x<=n)tr[x]+=y,x+=lb(x);}
	il int qry(int x){int ret=0;while(x)ret+=tr[x],x-=lb(x);return ret;}
	#undef lb
}R;
il bool check(int l,int r){
	if(T.qryMax(l,r,1)>m-s[r]+s[l-1])return 0;
	if(T.qryMax(l,r,0)>m-s[r]+s[l-1])return 0;
	return 1;
}
void Yorushika(){
	scanf("%d%d",&n,&m);
	rep(i,1,n)a[i]=read(),A[i]=A[i-1]+a[i];
	rep(i,1,n)b[i]=read(),B[i]=B[i-1]+b[i];
	rep(i,1,n){
		s[i]=s[i-1];
		if(a[i]>b[i])s[i]+=a[i]-b[i];
	}
	T.init();
	rep(i,1,n)d[i]=A[i]-B[i];
	d[n+1]=0;
	sort(d+1,d+n+2);
	int k=unique(d+1,d+n+2)-d-1;
	rep(i,1,n){
		int l=1,r=i,res=i+1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(mid,i))r=(res=mid)-1;
			else l=mid+1;
		}
		int p=lower_bound(d+1,d+k+1,A[i]-B[i])-d;
		g[res-1].eb(p);
	}
	R.upd(lower_bound(d+1,d+k+1,0)-d,1);
	ll ans=0;
	rep(i,1,n){
		int p=lower_bound(d+1,d+k+1,A[i]-B[i])-d;
		for(int j:g[i])ans-=i-R.qry(j-1);
		ans+=i-R.qry(p-1),R.upd(p,1);
	}
	printf("%lld\n",ans);
}
bool Med;
signed main(){
	freopen("top.in","r",stdin);
	freopen("top.out","w",stdout);
	int t=1;
//	scanf("%d",&t);
	while(t--)Yorushika();
//	cerr<<1.*(&Mbe-&Med)/1024/1024;
}
```

---

## 作者：Purslane (赞：1)

# Solution

考虑研究每一张牌。它打出来之前，我们最低能让目前手上的费用降到 $E - \sum_{l \le i \le r,i \neq x} \max\{0,a_i-b_i\}$，如果它 $< a_x$ 就不合法。

所以这组牌合法等价于 $E - \sum_{l \le i \le r,i \neq x} \max\{0,a_i-b_i\} \ge a_x$ 恒成立。移项，等价于 $E \ge \sum_{l \le i \le r,i \neq x} \max \{0,a_i-b_i\} + a_x$。又 $a_x - \max\{0,a_x - b_x\} = \min\{a_x,b_x\}$，也就得到了 $E \ge \sum_{l \le i \le r} \max\{0,a_i - b_i\} + \min\{a_x,b_x\} $。

> 注：这一类运算的基本性质包括 $-\max\{a,b\} = \min \{-a,-b\}$，以及 $a + \max\{b,c\} = \max\{a+b,a+c\}$。

于是等价于 $E \ge \sum_{i=l}^r \max\{0,a_i-b_i\} + \max_{l \le i \le r} \min\{a_i,b_i\}$。

发现当 $r$ 变大的时候，右式单调不降，$l$ 增大时，单调不增，可以直接使用双指针优化对于每个 $l$ 找到这个 $r$。

不过我们上述的限制只能保证一轮下来不会有问题。当 $\sum_{i=l}^r b_i - a_i < 0$ 的时候，每一轮其实费用都在下降，总有一天会 $E < 0$ 就不合法了。于是你又多了一个限制。

你发现你造出了一个二维数点问题。可以用树状数组解决。

PS：我之前搞出了一个微扰排序的做法。但是太不优美了，于是一怒之下把他删了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10,MAXM=21;
int n,E,a[MAXN],b[MAXN],tval[MAXN],pre[MAXN],lsh[MAXN],st[MAXN][MAXM],tot,r[MAXN],tr[MAXN];
int calc_mx(int l,int r) {int k=log2(r-l+1);return max(st[l][k],st[r-(1<<k)+1][k]);}
int check(int l,int r) {return E>=tval[r]-tval[l-1]+calc_mx(l,r);}
void update(int pos,int v) {
	while(pos<=tot) tr[pos]+=v,pos+=pos&-pos;
	return ;	
}
int query(int pos) {
	int ans=0;
	while(pos) ans+=tr[pos],pos-=pos&-pos;
	return ans;	
}
vector<pair<int,int>> qr[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>E;
	ffor(i,1,n) cin>>a[i];
	ffor(i,1,n) cin>>b[i];
	ffor(i,1,n) tval[i]=tval[i-1]+max(0ll,a[i]-b[i]);
	ffor(i,1,n) st[i][0]=min(a[i],b[i]);
	ffor(i,1,20) for(int l=1,r=(1<<i);r<=n;l++,r++) st[l][i]=max(st[l][i-1],st[l+(1<<i-1)][i-1]);
	ffor(i,1,n) pre[i]=pre[i-1]+b[i]-a[i],lsh[++tot]=pre[i];
	lsh[++tot]=0;
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,0,n) pre[i]=lower_bound(lsh+1,lsh+tot+1,pre[i])-lsh;
	int pos=0;
	ffor(i,1,n) {
		pos=max(pos,i-1);
		while(pos<n&&check(i,pos+1)) pos++;
		r[i]=pos;
		if(r[i]>=i) qr[r[i]].push_back({pre[i-1],1}),qr[i-1].push_back({pre[i-1],-1});
	}
	int ans=0;
	ffor(i,1,n) {
		update(pre[i],1);	
		for(auto pr:qr[i]) ans+=(query(tot)-query(pr.first-1))*pr.second;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：CrTsIr400 (赞：1)

# GDKOI2024 D2A 题解

upd 2024/01/20：增加了一份代码实现。代码实现起来非常顺利，同时也相当简单。

---

简单题，自己赛后做得很顺。但是赛事卡在第 0 步和第 1.3 步了，非常悲伤，拿了三十就走人。

其实把 20 分做法的条件划出来一下我是完全可以 AC 的。

题意：有 $n$ 张牌，每张牌需要能量 $a_i$，增加能量 $b_i$。

定义一个区间为“合法”的，则需要对于任何一种这个区间内所有牌的排列，都满足：

+ 按这个排列的顺序出牌。初始能量为 $E$。
+ 打出一张牌，先给当前能量减去 $a_i$，再加上 $b_i$。
+ 若某个时刻能量为负，则这个排列不合法，即决定这个区间不合法。

求合法区间总数。$n\le 10^6$，目标复杂度 $O(n\log n)$。

---

0. 最基础最基础的观察：因为排列很自由，所以一个元素前面怎么排列，后面怎么排列，是自由的。
   1. 我们只需要构造一种最劣的情况使得它尽可能不满足，这个区间就不满足条件。
   2. 形象一点，抽丝剥茧，就是某个元素在最恶劣的情况下是否能把答案否决。
1. 我们想要构造最恶劣的情况，来满足答案的充分性、必要性。
   1. 时间复杂度暂时没有那么重要。先考虑对于整个序列怎么做这个题。
   2. 设 $c=a-b$ 简化思维。那么满足条件的充要条件就是：
      1. $\sum c\le 0$。设 $s$ 为 $\sum c_i[c_i>0]$。
      2. 若一个点 $c_i>0$，则需要满足 $s-c+a\le E$。则为 $s+b_i\le E$。
      3. 若一个点 $c_i\le 0$，则需要满足 $s+a_i\le E$。
   3. 暴力直接做就可以 $O(n^2)$，是挺稳的。比赛时其实没有化好充要条件。
   4. 观察一下这三个东西，好不好维护呢？我觉得是挺好的。
      1. 简化研究，不妨设 $sum$ 为 $c$ 的前缀和，$sc$ 为 $\max(c_i,0)$ 的前缀和。
      2. $sum[r]\le sum[l-1]$。这个感觉是**二维数的点**。枚举 $r$。
      3. 发现 $s$ 这个东西具有单调性，于是显然可以二分 $l$ 的可能下界。然后主席树搞搞就行了，时间复杂度 $O(n\log n)$。
         1. 如何快速判定区间 $l,r$ 的可行性？显然找出 $c_i>0$，区间 $b_i$ 的最大值，和 $c_i\le 0$，$a_i$ 的最大值就行了。
         2. 这个可以 rmq 维护，时空复杂度都是 $O(n\log n)$ 的，稍微卡卡就过了。
2. 总结：其实在 1.3 节的时候就走偏了，一个半小时是完全可以切的，痛失 $70$，悲伤。

---

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i(a),_ed(b);i<=_ed;++i)
using namespace std;using I=int;using LL=long long;using V=void;
const I N=1e6+5;
I n,a[N],b[N],c[N],E;LL s[N],sc[N];
I am[20][N],bm[20][N];
I rmqa(I l,I r){I k=__lg(r-l+1);
	return max(am[k][l],am[k][r-(1<<k)+1]);}
bool pd(I l,I r){
	return sc[r]-sc[l-1]+rmqa(l,r)<=E;
}
V lshs(){LL lsh[N],lsn=0;
	fo(i,0,n)lsh[++lsn]=s[i];
	sort(lsh+1,lsh+lsn+1);
	lsn=unique(lsh+1,lsh+lsn+1)-lsh-1;
	fo(i,0,n)s[i]=lower_bound(lsh+1,lsh+lsn+1,s[i])-lsh-1;}
I getR(I L){
	I l=L,r=n,ans=L-1;
	while(l<=r){
		I mid=l+r>>1;
		if(pd(L,mid))ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
const I SN=N*21;
I ls[SN],rs[SN],ss[SN],cnt,rt[N];
V ins(I&p,I q,I num,I l=0,I r=n){
	p=++cnt;ls[p]=ls[q];rs[p]=rs[q];ss[p]=ss[q]+1;
	if(l==r)return;
	I mid=l+r>>1;
	if(num<=mid)ins(ls[p],ls[q],num,l,mid);
	else ins(rs[p],rs[q],num,mid+1,r);
}
I sum(I p,I q,I k,I l=0,I r=n){
	if(r<=k)return ss[p]-ss[q];
	if(l>k)return 0;
	I mid=l+r>>1;
	return sum(ls[p],ls[q],k,l,mid)+sum(rs[p],rs[q],k,mid+1,r);}
I main(){ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>E;
	fo(i,1,n)cin>>a[i];
	fo(i,1,n)cin>>b[i];
	fo(i,1,n)c[i]=a[i]-b[i],s[i]=s[i-1]+c[i],sc[i]=sc[i-1]+max(0,c[i]);
	fo(i,1,n)if(c[i]<=0)am[0][i]=a[i];else am[0][i]=b[i];
	fo(k,1,19)
		for(I hlf=1<<(k-1),i=1;i+(1<<k)-1<=n;++i)
			am[k][i]=max(am[k-1][i],am[k-1][i+hlf]);
	lshs();
	LL ans=0;
	ins(rt[0],0,s[0]);
	fo(i,1,n)ins(rt[i],rt[i-1],s[i]);
	fo(i,1,n)if(a[i]<=E){
		I rp=getR(i);
		if(i>rp)continue;
		ans+=sum(rt[rp],rt[i-1],s[i-1]);
	}
	printf("%lld\n",ans);
	return 0;}

```

---

## 作者：Fire_flame (赞：1)

2.5h 场切，来签个到。

真的是好题啊，思维难度挺大的。

[题目传送门](https://www.luogu.com.cn/problem/P10083)

## $\mathtt{Solution}$

首先考虑你确定 $l,r$ 时，怎么判断这个区间行不行。

如果 $m+\sum\limits_{i=l}^{r} (b_i-a_i)<0$，那么一定不行。

容易发现把 $b_i\le a_i$ 的放在前面，$b_i> a_i$ 的放在后面最劣。

对于前半部分，肯定是打到最后一张牌前，$m$ 最小，也就是说，我们可以只考虑最后一张牌能不能打出。

如果 $(a_j,b_j)$ 是最后一个，那么 $(a_i,b_i)$ 与之交换的代价是 $b_i-b_j$。

于是，对于前半部分把 $b_i$ 最大的放在最后，看其能不能打出。

对于后半部分，发现 $m$ 单调递增，所以把 $a_i$ 最大的放在最前面，看其能不能打出。

总的来说，就是三个条件：

1. $m+\sum\limits_{i=l}^{r} b_i-a_i\ge 0$

2. 对于所有的 $b_i\le a_i$，$b_i$ 最大的放在最后，能够打出。

3. 对于所有的 $b_i> a_i$，$a_i$ 最大的放在最前，能够打出。

综上所述，可以得到 $20$ 分，时间复杂度 $O(n^2)$。

----

接下来考虑正解。

这看起来很像一个尺取法，可是手玩样例可以发现这并没有单调性。

问题的根源就在条件 $1$。

那么把条件 $1$ 抽出来，只考虑 $2,3$，条件 $1$ 再进行判断就行。

固定左端点 $r$，容易得到，如果 $2,3$ 条件不满足，那么 $l$ 再怎么减小都是不对的。
 
接着用一颗树状数组维护前缀和，区间 $[r-1,r]$，$[r-2,r]\dots[l,r]$ 中，有几个和大于等于 $0$ 即可。

有些人在这里写了主席树，小心被卡。

$2,3$ 条件就是对 $a_i,b_i$ 维护两个求最大值的 ST 表。

前缀和记得离散化，而且 $l=1$ 时，会用到 $s_0$，记得离散化的时候加上 $0$。

时间复杂度 $O(n\log n)$。

考场代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int s = 0, f = 1;char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')f = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9'){s = s * 10 + (ch - '0');ch = getchar();}
	return s * f;
}
void write(int x){
    if(x < 0){putchar('-'); x = -x;}
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const int MAXN = 2e6 + 5;
struct BIT{//权值树状数组 
	int c[MAXN];
	int lowbit(int x){return x & -x;}
	void add(int x, int y){
		for(int i = x;i < MAXN;i += lowbit(i))
			c[i] += y;
	}
	int count(int x){
		int res = 0;
		for(int i = x;i;i -= lowbit(i))
			res += c[i];
		return res;
	}
	int query(int l, int r){
		return count(r) - count(l - 1);
	}
}tr;
int n, m, k, ans, a[MAXN], b[MAXN], c[MAXN], st[MAXN][21], st2[MAXN][21], s[MAXN], lg[MAXN], sa[MAXN];
int query(int l, int r){//第一个ST表维护a[i] < b[i] 时 a[i] 最大值 
	int z = lg[r - l + 1];
	return max(st[l][z], st[r - (1 << z) + 1][z]);
}
int query2(int l, int r){
	int z = lg[r - l + 1];//第二个ST表维护a[i] >= b[i] 时 b[i] 最大值 
	return max(st2[l][z], st2[r - (1 << z) + 1][z]);
}
bool check(int l, int r){
	if(m - sa[r] + sa[l - 1] - query2(l, r) < 0)return false;//条件2 
	if(m - sa[r] + sa[l - 1] < query(l, r))return false;//条件3 
//	printf("%lld %lld %lld %lld\n", l, r, query(l, r), sa[r] - sa[l - 1]);
	return true;
}
signed main(){
	n = read(), m = read();
	for(int i = 1;i <= n;i ++)a[i] = read();
	for(int i = 1;i <= n;i ++)b[i] = read();
	for(int i = 2;i <= n;i ++)lg[i] = lg[i / 2] + 1;
	for(int i = 1;i <= n;i ++){
		c[i] = s[i] = s[i - 1] - a[i] + b[i];
		if(a[i] >= b[i])st2[i][0] = b[i], sa[i] += a[i] - b[i];
		else st[i][0] = a[i];
		sa[i] += sa[i - 1];
//		printf("%lld %lld\n", i, sa[i]);
	}
	sort(c + 1, c + n + 2);
	k = unique(c + 1, c + n + 2) - (c + 1);//离散化，记得加上0 
	for(int i = 1;i <= 20;i ++){
		for(int j = 1;j + (1 << i - 1) - 1 <= n;j ++){
			st[j][i] = max(st[j][i - 1], st[j + (1 << i - 1)][i - 1]);
			st2[j][i] = max(st2[j][i - 1], st2[j + (1 << i - 1)][i - 1]);
		}
	}
	int l = 1;
	for(int r = 1;r <= n;r ++){//固定右端点 
		int pos = lower_bound(c + 1, c + k + 1, s[r - 1]) - c;
		tr.add(pos, 1);
		while(l <= r && !check(l, r)){//左端点不符合 
			int h = lower_bound(c + 1, c + k + 1, s[l - 1]) - c;
			tr.add(h, -1);
			l ++;
		}
		pos = lower_bound(c + 1, c + k + 1, s[r]) - c;
		ans += tr.count(pos);//计算答案时把条件1加进去 
//		printf("%lld %lld\n", l, r);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Z1qqurat (赞：0)

首先通过特殊性质 Sub5（$a_i\times b_i=0$）不难想到将限制分为两部分：一部分就是用某种“最劣打牌序”能使得某次准备拿新牌的时候发现存在一张没打过的牌 $a_i>$ 当前的费用 $E'$；另一部分就是 $\sum\limits_{i=l}^r b_i-a_i<0$，也就是说打完一组之后获得了负的费用值，那么一定会在打了很多组之后费用为负。不难发现第一个限制具有某种**单调性**，因为如果 $[l,r]$ 有一个子区间可以被第一种限制 ban 掉，那么 $[l,r]$ 必然也是不合法的，直接把那个子区间的“最劣打牌序”打一遍就行了。于是我们对于每个右端点 $r$，求出 $L_r$ 表示 $[l,r]$ 能满足第一个限制的最小左端点 $l$，由于上述的单调性可以知道将 $L_r$ 左边的点作为左端点一定不合法，$l\in[L_r,r]$ 对于第一个限制合法。

于是我们可以考虑二分求 $L_r$，问题在于怎么快速 check。我们发现，贪心地构造一个“最劣打牌序”，将所有 $a_i>b_i$ 的打了会产生负费用的牌先打完，接下来选出剩下还没打的牌里面 $a$ 最大的，设其为 $x$，那么如果 $c(l,r)$ 表示 $[l,r]$ 内所有会产生负费用的牌的负费用 $a_i-b_i$ 之和，那么如果 $E-c(l,r)<a_x$，该区间就不合法了。$c(l,r),x$ 都可以简单维护（前者前缀和，后者 st 表，需要注意的是 **$c(l,r)$ 只记录产生负费用的牌，$x$ 只限于不产生负费用的牌**），然后就可以简单判断。

只有这个了吗？如果我们从负费用牌中选出一张让它先不打，而让它作为那一张 $a_i$ 大的牌，有可能吗？推一下式子，假如我们选择的牌是 $x$，那么就是 $E-[c(l,r)-(a_x-b_x)]<a_x\Rightarrow c(l,r)+b_x>E$，我们从产生负费用的牌中选出 $b_i$ 最大的即可。容易推出不存在别的情况了。

我们求出了 $L_r$ 后考虑对 $r$ 求答案。因为 $L_{1\sim n}$ 是单调不降的（由前文那个子区间包含的性质），所以我们将其转化为前缀和 $sum_i=\sum\limits_{j=1}^i b_j-a_j$ 形式，离散化后树状数组上做二维偏序，注意一下什么时候加入点什么时候删除点，然后 $sum_i$ 和 $c_i$ 没有任何关系！

[Submission.](https://qoj.ac/submission/306247)

---

## 作者：happybob (赞：0)

显然我们要解决的主要问题就是能“陀螺无限”的充要条件。我们坚信推出来后是可以维护的。

我们设我们要打出的这些牌的 $a,b$ 分别是 $a_1,a_2,\cdots,a_k$ 和 $b_1,b_2,\cdots,b_k$。

容易观察到一个必要条件是 $\sum \limits_{i=1}^k b_i-a_i \geq 0$，否则每打完一次能量总是降低，最终一定无法无限打下去。

但是这个条件不充分。反方向考虑什么时候打不完。如果存在一种方法使得无法无限打，那么一定是在第一局。因为在后面的局数中，能量总是不小于第一局的初始值，故不优。

那么如果存在 $a$ 和 $b$ 的一种排列，使得存在 $i$，$E+\sum \limits_{j=1}^{i-1} b_j-a_j < a_i$，就无法无限打下去。此时无法打出第 $i$ 张牌。

这时考虑反方，即不想让你打完的会怎么想。肯定是把 $b_i< a_i$ 的全都放在前面，然后放某个 $a$。记 $p = \sum \limits_{i=1}^k \max\{0,a_i-b_i\}$。

考虑任意一个 $i$，如果 $a_i \leq b_i$，那么这张牌没有被选过，此时需要判断 $E - p$ 与 $a_i$ 的关系。移项得 $E$ 与 $a_i +p$ 的关系。

如果 $a_i > b_i$，那么此时需要判断 $E-p+a_i-b_i$ 与 $a_i$ 的关系。移项得 $E$ 与 $b_i+p$ 的关系。

发现 $a_i \leq b_i$ 时是 $a_i + p$，$a_i > b_i$ 时是 $b_i+p$。所以是 $\min\{a_i,b_i\}+p$。

能无限打的充要条件是 $b-a$ 的和大于等于 $0$，且对于任意 $i$，有 $E\geq\min\{a_i,b_i\}+p$ 成立。

第一个条件不太好处理，先考虑第二个，一定是 $E \geq \max \limits_{i=1}^k (\min\{a_i,b_i\})+p$ 成立。

如果枚举左端点 $l$，二分 $r$。$p$ 随着 $r$ 增大而单调不降，$\max \limits_{i=1}^k (\min\{a_i,b_i\})$ 显然也是单调不降。所以右边式子有单调性，可以二分右端点求出每个 $l$ 对应的最大的 $r$。可以用 ST 表和前缀和处理这一部分。

但是还有一点在于上文提到的难以维护的限制，即 $b_i-a_i$ 的和大于等于 $0$。如果使用前缀和 $sumb_i = \sum \limits_{j=1}^i b_j,suma_i = \sum \limits_{j=1}^i a_j$。那么上面的限制等价于 $sumb_r-sumb_{l-1} \geq suma_r-suma_{l-1}$。注意到枚举左端点时，$suma_{l-1}$ 和 $sumb_{l-1}$ 是定值，进行上文的二分右端点后问题转化成区间 $[l,r]$ 中的 $sumb_r-suma_r$ 大于等于一个定值的问题。这是一个二维偏序，显然可以离线树状数组或者在线主席树维护。

于是问题在 $O(n \log n)$ 的时空复杂度内得以解决。

主席树代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;

int a[N], b[N];
long long sumc[N];
int n;
long long e;
int f[N][22], LG2[N];

void Init()
{
	for (int i = 2; i < N; i++) LG2[i] = LG2[i >> 1] + 1;
	for (int i = 1; i <= n; i++) f[i][0] = min(a[i], b[i]);
	for (int j = 1; j <= LG2[n]; j++)
	{
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
		{
			f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
		}
	}
}

int query(int l, int r)
{
	int p = LG2[r - l + 1];
	return max(f[l][p], f[r - (1 << p) + 1][p]);
}

int rt[N];

class Chariman_Tree
{
public:
	int idx;
	struct Node
	{
		int lson, rson, sum;
	}tr[N * 26];
	void pushup(int u)
	{
		tr[u].sum = tr[tr[u].lson].sum + tr[tr[u].rson].sum;
	}
	int ins(int p, int u, int v, int l, int r)
	{
		u = ++idx;
		tr[u] = tr[p];
		if (l == r)
		{
			tr[u].sum++;
			return u;
		}
		int mid = (l + r) >> 1;
		if (v <= mid) tr[u].lson = ins(tr[p].lson, tr[u].lson, v, l, mid);
		else tr[u].rson = ins(tr[p].rson, tr[u].rson, v, mid + 1, r);
		pushup(u);
		return u;
	}
	int query(int p, int q, int l, int r, int nl, int nr)
	{
		if (!p && !q) return 0;
		if (l >= nl && r <= nr) return tr[q].sum - tr[p].sum;
		int mid = (l + r) >> 1;
		int ans = 0;
		if (nl <= mid) ans = query(tr[p].lson, tr[q].lson, l, mid, nl, nr);
		if (nr > mid) ans += query(tr[p].rson, tr[q].rson, mid + 1, r, nl, nr);
		return ans;
	}
}sgt;

long long sumd[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> e;
	long long ans = 0LL;
	for (int i = 1; i <= n; i++) cin >> a[i];
	vector<long long> vv;
	for (int i = 1; i <= n; i++) 
	{
		cin >> b[i];
		sumc[i] = sumc[i - 1] + max(0LL, (long long)a[i] - b[i]);
		sumd[i] = sumd[i - 1] + b[i] - a[i];
		vv.emplace_back(sumd[i]);
	}
	vv.emplace_back(0);
	sort(vv.begin(), vv.end());
	vv.erase(unique(vv.begin(), vv.end()), vv.end());
	for (int i = 0; i <= n; i++) sumd[i] = lower_bound(vv.begin(), vv.end(), sumd[i]) - vv.begin() + 1;
	for (int i = 0; i <= n; i++) 
	{
		rt[i] = sgt.ins((i ? rt[i - 1] : 0), rt[i], sumd[i], 1, n + 1);
	}
	Init();
	for (int i = 1; i <= n; i++)
	{
		int l = i, r = n, place = -1;
		while (l <= r)
		{
			int mid = (l + r) >> 1;
			long long g = e - (sumc[mid] - sumc[i - 1]);
			if (query(i, mid) <= g) l = mid + 1, place = mid;
			else r = mid - 1;
		}
		if (place != -1) ans += sgt.query(rt[i - 1], rt[place], 1, n + 1, sumd[i - 1], n + 1);
		//cout << i << " " << place << "\n";
	}
	//cout << (double)(&st - &ed) / 1024.0 / 1024.0 << "\n";
	cout << ans << "\n";
	return 0;
}
```


---

## 作者：0x3F (赞：0)

首先考虑一个区间 $[l,r]$ 不合法的充要条件：

如果打完一轮以后，$E$ 减小了，也就是 $\sum\limits_{i=l}^{r}(b_i-a_i)<0$，那么只要足够多轮，一定会把 $E$ 用完。

如果打第一轮的过程中无法操作，那么假设现在取到（原序列中的）第 $x$ 张牌，极端情况是取这张牌之前，把所有满足 $a_i>b_i$ 的都取完了。

此时有 $\sum\limits_{i=l}^{r}([i\ne x]\max(a_i-b_i,0))+a_x>E$，整理一下得到 $\sum\limits_{i=l}^{r}\max(a_i-b_i,0)+\min(a_x,b_x)>E$。

综上，如果要区间 $[l,r]$ 合法，那么：

$$\begin{cases}\sum\limits_{i=l}^{r}(b_i-a_i)\ge0\\\sum\limits_{i=l}^{r}\max(a_i-b_i,0)+\max\limits_{i=l}^{r}\min(a_i,b_i)\le E\end{cases}$$

我们发现对于后面一个条件，如果固定 $r$，那么 $l$ 向左移动时，这个式子的值单调不减。因此对于某一个固定的 $r$，符合条件的 $l$ 如果存在，一定在区间 $[l_0,r]$ 中。

双指针对于每一个 $r$ 求出对应的 $l_0$，同时对 $b_i-a_i$ 的前缀和离散化，树状数组维护符合条件的 $l$ 即可。

时间复杂度为 $\mathcal{O}(n\log n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 1e6 + 10;
int n, m, e, a[_], b[_], v[_], l[_];
long long tmp, sum[_], vsum[_];
multiset<int> S;
#define y ((x)&(-(x)))
int bit[_];
inline void add(int x, int k) {
	while (x <= m) {
		bit[x] += k;
		x += y;
	}
}
inline int que(int x) {
	int k = 0;
	while (x) {
		k += bit[x];
		x -= y;
	}
	return k;
}
#undef y
long long ans; 
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> e;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> b[i];
	}
	l[0] = 1;
	for (int i = 1; i <= n; i++) {
		l[i] = l[i-1];
		tmp += max(a[i] - b[i], 0);
		S.insert(min(a[i], b[i]));
		while (l[i] <= i && tmp + (*S.rbegin()) > e) {
			tmp -= max(a[l[i]] - b[l[i]], 0);
			S.erase(S.find(min(a[l[i]], b[l[i]])));
			l[i]++;
		}
	}
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i-1] + b[i] - a[i];
		vsum[i] = sum[i];
	}
	vsum[n+1] = 0LL;
	sort(vsum+1, vsum+n+2);
	m = unique(vsum+1, vsum+n+2) - vsum - 1;
	for (int i = 0; i <= n; i++) {
		v[i] = lower_bound(vsum+1, vsum+m+1, sum[i]) - vsum;
	}
	add(v[0], 1);
	for (int i = 1; i <= n; i++) {
		for (int t = l[i-1] - 1; t <= l[i] - 2; t++) {
			add(v[t], -1);
		}
		ans += que(v[i]);
		add(v[i], 1);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：ZnPdCo (赞：0)

> 洛谷竟然也有 GDKOI 了！

考虑一个卡牌区间怎样才不是“陀螺无限”。

一个是费用在打到一半时费用就不够了。考虑构造一个卡牌序列使其尽量能够在打到一半时费用就不够，如何构造呢？

把 $a_i > b_i$ 的卡牌称作消耗型卡牌，其他叫做获得型卡牌。我们可以构造把消耗型卡牌全部放在前面，后面突然来个很大的 $a_i$ 就可以让你费用耗尽了。

但是我们不能贪心地选择，因为假如我们选择这个突然来的很大的 $a_i$ 也是一个很大的消耗型卡牌，如果把它作为“引火线”就会导致前面消耗的费用不够多，这个导火线也就导不了火。

其实我们可以储存 $E-a_i$ 表示在使用这张卡片前最多能够消耗的费用，假如一个区间其余的消耗型卡牌起作用使得 $E-a_i-\text{其他消耗型卡牌的消耗}<0$，那么这个区间就不是”陀螺无限“。这个可以拿线段树维护。

我们只需要枚举区间左端点，然后计算最大的右端点，这个区间内的所有卡牌区间就都是合法方案了，$O(n^2)$。 

我们会发现，左端点向右移动一位后，对区间内的影响是什么？

如果这个左端点是个消耗型卡牌，那么区间的消耗都会补回这个消耗，这个区间可能合法了，右端点可能可以往右移动；如果左端点是获得性卡牌，对区间没有任何影响。

这说明右端点是递增的，可以均摊 $O(n)$ 得到合法区间。

---

另外一个卡牌区间不是”陀螺无限“是这个区间的代价 $\sum b_i-\sum a_i<0$，这样就算打完一周后总费用也会减少，那么以此类推会越来越少。

这个比较简单，可以维护代价前缀和，也就是求 $s_i-s_{j-1}\ge0$ 区间个数，即 $s_i\ge s_{j-1}$，这个可以树状数组维护。

```c++
#include <cstdio>
#include <algorithm>
#define ll long long
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define N 1000010
using namespace std;
ll n, e, ans, len;
ll a[N], b[N], c[N];		// ci表示第i个会被扣掉多少 
ll s[N], ss[N], to[N];

ll t[4*N];	// 维护每个位置的数能扣多少 
ll lazy[4*N];

inline ll min(ll x, ll y) {
	return x > y ? y : x;
}
void pushup(ll pos) {
	t[pos] = min(t[ls(pos)], t[rs(pos)]);
}
void pushdown(ll pos) {
	t[ls(pos)] += lazy[pos];
	t[rs(pos)] += lazy[pos];
	lazy[ls(pos)] += lazy[pos];
	lazy[rs(pos)] += lazy[pos];
	lazy[pos] = 0;
}
void update(ll nl, ll nr, ll l, ll r, ll pos, ll k) {
	if(nl > nr) return;
	if(nl <= l && r <= nr) {
		t[pos] += k;		// 维护最小值 
		lazy[pos] += k;
		return;
	}
	if(lazy[pos]) {
		pushdown(pos);
	}
	
	ll mid = (l + r) >> 1;
	if(nl <= mid) {
		update(nl, nr, l, mid, ls(pos), k);
	}
	if(mid < nr) {
		update(nl, nr, mid+1, r, rs(pos), k);
	}
	
	pushup(pos);
}
ll query(ll nl, ll nr, ll l, ll r, ll pos) {
	if(nl <= l && r <= nr) {
		return t[pos];
	}
	if(lazy[pos]) {
		pushdown(pos);
	}
	
	ll mid = (l + r) >> 1;
	ll res = 1e15;
	if(nl <= mid) {
		res = min(res, query(nl, nr, l, mid, ls(pos)));
	}
	if(mid < nr) {
		res = min(res, query(nl, nr, mid+1, r, rs(pos)));
	}
	return res;
}

// 桶

ll tong[N];

inline ll lowbit(ll x) {
	return x & (-x);
} 

void update1(ll x, ll val) {
	while(x<=len) {
		tong[x] += val;
		x += lowbit(x);
	}
} 

ll query1(ll x) {
	ll res=0;
	while(x) {
		res += tong[x];
		x -= lowbit(x);
	}
	return res;
}

ll read() {
	ll x = 0;
	char c = '.';
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') {
		x = (x<<1)+(x<<3)+(c^'0');
		c = getchar();
	}
	return x;
}

int main() {
	freopen("top.in", "r", stdin);
	freopen("top.out", "w", stdout);
    
	n =read(),e=read();
	for(ll i = 1; i <= n; i++) a[i] = read();
	for(ll i = 1; i <= n; i++) b[i] = read();
	for(ll i = 1; i <= n; i++) c[i] = a[i] - b[i];	// 反过来好处理
	for(ll i = 1; i <= n; i++) {
		s[i] = s[i-1];
		s[i] -= c[i];
		ss[i+1] = s[i];	// 离散化使用 
	}
	
	// 离散化
	sort(ss+1, ss+1+n+1);  // 把0也离散化
	len = unique(ss+1, ss+1+n+1)-ss-1;
	for(ll i = 0; i <= n; i++) {
		ll l = 1, r = len;		// 考场上不会用lower_bound
		while(l <= r) {
			ll mid = (l + r) >> 1;
			if(ss[mid] < s[i]) l = mid+1;
			if(ss[mid] > s[i]) r = mid-1;
			if(ss[mid] == s[i]) {
				to[i] = mid;
				break;
			}
		}
	}
	
	ll r = 1;
	bool flag = 0;		// 表示已经加入过r了，不用再加入了 
	ll cost = 0;
	for(ll l = 1; l <= n; l++) {
		for(; r <= n; r++, flag=0) {
			if(!flag) {
				if(c[r] > 0) update(l, r-1, 1, n, 1, -c[r]);	// 因为加入了r，前面的数都要多扣一个r 
				
				update(r, r, 1, n, 1, e - a[r] - cost);
				
				if(c[r] > 0) cost += c[r];		// 把这一位加入cost 
				flag = true;
				update1(to[r], 1);
			}
			
			if(query(l, r, 1, n, 1) < 0) {					// 如果存在一种方式扣完，那就没了 
				break;
			}
//			printf("%lld %lld\n", l, r);
		}
		// 原本是求l到r内有多少个i使得 s[i]-s[l-1]>=0，也就是有多少个 s[i]>=s[l-1]
//		for(ll i = l; i < r; i++) {
//			if(s[i] - s[l-1] >= 0) {
//				ans++;
//				printf("%lld %lld\n", l, i); 
//			}
//		}
		if(r <= n) update1(to[r], -1);	// 第r位被剔除，所以第r位是不合法的
		ans += query1(len) - query1(to[l-1]-1); 
		if(r <= n) update1(to[r], 1);
		
		// 要剔除最左边那个cost 
		if(c[l] > 0) cost -= c[l]; 
		if(c[l] > 0) update(l+1, r, 1, n, 1, c[l]); 
		
		// 把这l踢出桶 
		update1(to[l], -1);
	}
	
	printf("%lld", ans);
}
```

---


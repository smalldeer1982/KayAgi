# [ROIR 2022] 回文数组 (Day 1)

## 题目背景

翻译自 [ROIR 2022 D1T4](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day1.pdf)。

有两个自然数数组 $A = [a_1, a_2, \dots , a_n]$ 和 $B = [b_1, b_2, \dots , b_m]$。

对每个数组，随机地去掉一个可能为空的前缀和一个可能为空的后缀，使得剩下的数组部分长度相等。我们将得到的数组记作 $A'$ 和 $B'$，它们的长度为 $k$。然后，对这两个数组的相应元素求和，结果数组记作 $C = [c_1, c_2, \dots , c_k]$。

例如，假设 $n = 5,A = [4, 3, 3, 2, 1],m = 6,B = [4, 1, 5, 1, 3, 2]$，从数组 $A$ 中去掉第一个和最后一个元素，从数组 $B$ 中去掉前三个元素，得到 $A' = [3, 3, 2],B' = [1, 3, 2]$，它们的相应元素求和结果为 $C = [4, 6, 4]$。  
假设 $n = 7,A = [1,9,1,9,8,1,0],m = 6,B = [1,1,4,5,1,4]$，从数组 $A$ 中去掉前两个元素和最后一个元素，从数组 $B$ 中去掉第一个和最后一个元素，得到 $A' = [1,9,8,1],B' = [1,4,5,1]$，它们的相应元素求和结果为 $C = [2,13,13,2]$。

## 题目描述

找到能够得到回文数组 $C$ 的最大长度 $k$。

## 说明/提示

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $13$ | $n,m\le300$ |
| $2$ | $33$ | $B$ 中所有数都相等 |
| $3$ | $16$ | $n\le500,m\le10^5$ |
| $4$ | $38$ | 无 |

对于所有数据，$1 \le n, m \le 100 000$，$1 \le a_i \le 100$，$1 \le b_i \le 100$。

## 样例 #1

### 输入

```
5 6
4 3 3 2 1
4 1 5 1 3 2```

### 输出

```
3```

# 题解

## 作者：CarroT1212 (赞：3)

~~这题的题号在我们学校信息队有着特殊的意义，所以前来写了一下。~~

------------

回文，但是在加起来之后。

Manacher 死透了，那剩下能快速判回文的方法就是哈希了，即回文串的前后两半的正反哈希相同。正好我们惊喜地发现只要底数够大（$>200$），哈希结果就是可以相加的！看起来非常符合本题要求。

发现由于回文性质，奇数答案和偶数答案是分别可以二分的。考虑对于奇数和偶数分别二分答案 $mid$，现在问题就变为怎么判断存不存在相加后长度为 $mid$ 的回文串。

钦定 $mid$ 是偶数。首先在 $A,B$ 中正着和反着求一遍所有长度为 $\frac{mid}{2}$ 的子串的哈希值。设串 $s$ 的正反哈希值分别为 $h_s,h'_s$。

然后如果存在合法回文串，$A,B$ 中就分别需要存在两个相邻的长度均为 $\frac{mid}{2}$ 的子串 $a_1,a_2$ 和 $b_1,b_2$，满足 $h_{a_1+b_1}=h'_{a_2+b_2}\implies h_{a_1}+h_{b_1}=h'_{a_2}+h'_{b_2}\implies h_{a_1}-h'_{a_2}=h'_{b_2}-h_{b_1}$。

你发现 $(a_1,a_2),(b_1,b_2)$ 都只有 $O(n)$ 对，所以直接预处理出所有可能的 $h_{a_1}-h'_{a_2}$ 和 $h'_{b_2}-h_{b_1}$ 的结果然后扔进 `map` 看一下有没有相等的即可。

$mid$ 是奇数同理，中间隔了一个而已。或许还可以用 Manacher 的技术在中间空位补几个数然后对奇数偶数一视同仁，但是不太确定 $A,B$ 会不会因为错位匹配挂掉。

复杂度 $O(n\log^2 n)$。有点小卡常，开 `unordered_map` 会好点。注意哈希值相减的时候[不要变成负数](https://www.luogu.com.cn/record/150787038)。

```cpp
const ll J=1e18,N=1e5+7,B[2]={211,213},P=1e9+9;
ll qp(ll x,ll y=P-2) { return y?(y&1?x:1)*qp(x*x%P,y>>1)%P:1; }
ll pw[N][2],pv[N][2];
ll n,m,a[N],b[N],ans;
ll af[N][2],ab[N][2],bf[N][2],bb[N][2];
bool chk(ll len,ll c) {
	unordered_map<ll,ll> mp;
	for (ll i=1;i+len*2+c<=n+1;i++) {
		ll ha[2],hb[2];
		for (ll o=0;o<2;o++)
			ha[o]=(af[i+len-1][o]+P-af[i-1][o]*pw[len][o]%P)%P,
			hb[o]=(ab[i+len+c][o]+P-ab[i+len*2+c][o]*pw[len][o]%P)%P;
		mp[(ha[0]+P-hb[0])%P*P+(ha[1]+P-hb[1])%P]=1;
	}
	for (ll i=1;i+len*2+c<=m+1;i++) {
		ll ha[2],hb[2];
		for (ll o=0;o<2;o++)
			ha[o]=(bf[i+len-1][o]+P-bf[i-1][o]*pw[len][o]%P)%P,
			hb[o]=(bb[i+len+c][o]+P-bb[i+len*2+c][o]*pw[len][o]%P)%P;
		if (mp.count((hb[0]+P-ha[0])%P*P+(hb[1]+P-ha[1])%P)) return 1;
	}
	return 0;
}
void mian() {
	for (ll o=0;o<2;o++) {
		pw[0][o]=1;
		for (ll i=1;i<N;i++) pw[i][o]=pw[i-1][o]*B[o]%P;
		for (ll i=0;i<N;i++) pv[i][o]=qp(pw[i][o]);
	}
	scanf("%lld%lld",&n,&m);
	for (ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	for (ll i=1;i<=m;i++) scanf("%lld",&b[i]);
	for (ll o=0;o<2;o++) {
		for (ll i=1;i<=n;i++) af[i][o]=(af[i-1][o]*B[o]+a[i])%P;
		for (ll i=n;i;i--) ab[i][o]=(ab[i+1][o]*B[o]+a[i])%P;
		for (ll i=1;i<=m;i++) bf[i][o]=(bf[i-1][o]*B[o]+b[i])%P;
		for (ll i=m;i;i--) bb[i][o]=(bb[i+1][o]*B[o]+b[i])%P;
	}
	for (ll c=0;c<2;c++) {
		ll l=0,r=min(n,m)/2,mid,res=0;
		while (l<=r) {
			mid=l+r>>1;
			if (chk(mid,c)) res=mid,l=mid+1;
			else r=mid-1;
		}
		ans=max(ans,res*2+c);
	}
	cout<<ans;
}
```

---

## 作者：ISTP (赞：0)

## Getting Start

备战 NOIP 查漏补缺 ~~（女娲补天（开天辟地））~~ 中。

很好的哈希练手题使我的代码常数旋转。

## 题意简述

[原题链接：https://www.luogu.com.cn/problem/P10089](https://www.luogu.com.cn/problem/P10089)

给定两个长度分别为 $n,m$ 的数组 $A,B$，在两个数组中各取一段长度相等的区间逐位相加，使得到的长为 $k$ 的数组 $C$ 回文。求 $k$ 的最大值。

## 思路

因为此题在某个哈希题单里，所以上来解法就往哈希靠了（），做都做了不妨想一下为什么。

随便手模两下可以发现回文串的优秀性质：长度为 $5$ 的回文串中一定包含长度为 $3$ 的回文串，长度为 $6$ 的一定包含长度为 $4$ 的，即**分奇偶性讨论**的话，**答案具有单调性**。

题目要求回文串的最大长度，容易想到**二分两次**这个长度 $k$，一次只二分偶数的 $k$， 一次二分奇数。

问题转化为在 $O(n)$ 的时间里判断是否可以组合出长度为 $k$ 的回文数组。

首先思考如何**判断一段区间回文**，一个基础的 trick 是把数组当成字符串做哈希，正着做一遍反着做一遍，比较前后两段一正一反的哈希值是否相等，可以做到 $O(1)$ 判断。

考虑字符串哈希的还有一个重要原因是它的哈希值拥有优秀的**可加性**。举个栗子，字符串 $\texttt{1234}$ 和 $\texttt{2345}$ 的哈希值之和等于 $\texttt{3579}$ 的哈希值。完美符合题目要将两个数组加起来的操作。原理看哈希值的计算式很好理解，或者去度娘看看证明。

设 $$ha,hb$$ 为数组 $A,B$ 字符串哈希得到的数组，$h_i$ 为 $ha,hb$ 中分别取长度相等的一段相加所得的区间 $i$ 的哈希值，根据可加性，以下式子是显然的：

$$$h_i = ha_i + hb_i$$$

那么当 $ha,hb$ 相加所得的两个区间 $i, j$ 完全相同时，下面式子成立：

$$$ha_i + hb_i = ha_j + hb_j$$$

若 $i,j$ 是相邻的两段区间，把区间 $j$ 倒过来，或者将 $ha_j + hb_j$ 换成倒序处理的哈希值，代入上式即可判断区间 $i + j$ 是否回文。（$i + j$ 的 $+$ 号表示字符串拼接）

移项得：

$$$ha_i - ha_j = hb_j - hb_i$$$

很好，我们二分出区间长度 $k$ 后，对于 $A$ 数组中每一个长度为 $k$ 的区间，把它对半分（$k$ 是奇数就把中间的字符取两次），前一半求出正着的哈希值 $r1$，后一半求出倒着的哈希值 $r2$，把 $r1 - r2$ 的值丢进一个 map 或 set 里面。

然后在 $B$ 数组求出每个区间的 $r2 - r1$，查一下有没有 $A$ 数组的区间求出过一样的值，有就是可以取到这个 $k$，没有就取不到。一次 check 是 $O(n)$ 的。

二分做下去就行了，时间复杂度 $O(n \log n)$。

## 代码实现

总结一下，我们要分别维护出 $A,B$ 数组的哈希值，和 $A,B$ 数组倒序的哈希值。

然后因为单哈希的碰撞概率是很高的，这里采用双哈希，一共维护了 $8$ 个哈希数组。

于是我们快乐地敲好代码，调过样例，发现如果没加快读/用了 map/开了很多 ```long long```/取模不当，很大概率喜提 TLE。

所以用以下算是**通用的卡常小技巧**把上述问题优化掉：

- 使用快读
- 改用 unordered_map，常数不小但是好写，比 map 少了一只 $\log$，如果还是差一两百毫秒卡不过去则考虑手写 hash_map
- 多取模，使得不必要的 ```long long``` 可以改成 ```int```
- 将因为溢出不超过一个模数而取模的操作改为减去模数

这些技巧一个不少全部用上的话，该题应该能一遍过。这边最慢的点跑了 920 ms。

代码，应该，还算能看？

~~感觉讲差不多了没必要看下面这坨丑陋的实现。~~

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn = 1e5 + 5;

int read();
void write(int);

int n, m;
int a[maxn], b[maxn];
void input();

struct _hash{

	const int M1 = 998244353, M2 = 1e9 + 9;
	const int D1 = 233, D2 = 2333;

	int h1[maxn], h2[maxn];
	int rh1[maxn], rh2[maxn];
	int p1[maxn], p2[maxn];

	void hash_get(int* a, int n){
		p1[0] = p2[0] = 1;
		for(int i = 1; i <= n; i ++){
			p1[i] = 1ll * p1[i - 1] * D1 % M1;
			p2[i] = 1ll * p2[i - 1] * D2 % M2;
		}
		for(int i = 1; i <= n; i ++){
			h1[i] = 1ll * h1[i - 1] * D1 % M1 + a[i];
			h2[i] = 1ll * h2[i - 1] * D2 % M2 + a[i];
            h1[i] -= (h1[i] >= M1? M1: 0), h2[i] -= (h2[i] >= M2? M2: 0);
			rh1[i] = 1ll * rh1[i - 1] * D1 % M1 + a[n - i + 1];
			rh2[i] = 1ll * rh2[i - 1] * D2 % M2 + a[n - i + 1];
            rh1[i] -= (rh1[i] >= M1? M1: 0), rh2[i] -= (rh2[i] >= M2? M2: 0);
		}
	}

	pair<int, int> hash_get(int lf, int rt){
		ll v1 = h1[rt] - 1ll * h1[lf - 1] * p1[rt - lf + 1] % M1 + M1;
		ll v2 = h2[rt] - 1ll * h2[lf - 1] * p2[rt - lf + 1] % M2 + M2;
        v1 -= (v1 >= M1? M1: 0), v2 -= (v2 >= M2? M2: 0);
		return {v1, v2};
	}
	pair<int, int> rhash_get(int lf, int rt){
		ll v1 = rh1[rt] - 1ll * rh1[lf - 1] * p1[rt - lf + 1] % M1 + M1;
		ll v2 = rh2[rt] - 1ll * rh2[lf - 1] * p2[rt - lf + 1] % M2 + M2;
        v1 -= (v1 >= M1? M1: 0), v2 -= (v2 >= M2? M2: 0);
		return {v1, v2};
	}
}ha, hb;

void solve();
int check(int);

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);

	input();
	solve();
	return 0;
}

void solve(){

	ha.hash_get(a, n), hb.hash_get(b, m);

	int lf = 0, rt = min(n, m), ans = 0;
	rt = (rt & 1? rt - 1: rt);
	while(lf <= rt){
		int mid = lf + rt >> 1;
		if(mid & 1) mid -= 1;
		if(check(mid)) ans = mid, lf = mid + 2;
		else rt = mid - 2;
	}

	int res = ans;

	lf = 1, rt = min(n, m), ans = 0;
	rt = (rt & 1? rt: rt - 1);
	while(lf <= rt){
		int mid = lf + rt >> 1;
		if(!(mid & 1)) mid -= 1;
		if(check(mid)) ans = mid, lf = mid + 2;
		else rt = mid - 2;
	}

	write(max(res, ans)), puts("");

	return ;
}

int xx = 1e9;

unordered_map<long long, int> mp;

int check(int mid){

	mp.clear();

	int k = mid >> 1;

	for(int i = 1; i + mid - 1 <= n; i ++){
		int lf = i, rt = i + (mid & 1? k: k - 1);
		pair<int, int> va = ha.hash_get(lf, rt);
		lf = i + k, rt = i + mid - 1;
		lf = n - lf + 1, rt = n - rt + 1;
		swap(lf, rt);
		pair<int, int> rva = ha.rhash_get(lf, rt);
		ll v1 = va.first - rva.first + ha.M1;
		ll v2 = va.second - rva.second + ha.M2;
        v1 -= (v1 >= ha.M1? ha.M1: 0), v2 -= (v2 >= ha.M2? ha.M2: 0);
		mp[v2 * xx + v1] = 1;
	}
	for(int i = 1; i + mid - 1 <= m; i ++){
		int lf = i, rt = i + (mid & 1? k: k - 1);
		pair<int, int> vb = hb.hash_get(lf, rt);
		lf = i + k, rt = i + mid - 1;
		lf = m - lf + 1, rt = m - rt + 1;
		swap(lf, rt);
		pair<int, int> rvb = hb.rhash_get(lf, rt);
		ll v1 = rvb.first - vb.first + hb.M1;
		ll v2 = rvb.second - vb.second + hb.M2;
        v1 -= (v1 >= hb.M1? hb.M1: 0), v2 -= (v2 >= hb.M2? hb.M2: 0);
		if(mp.count(v2 * xx + v1)) return 1;
	}

	return 0;
}

void input(){

    n = read(), m = read();
	for(int i = 1; i <= n; i ++)
		a[i] = read();
	for(int i = 1; i <= m; i ++)
		b[i] = read();
	return ;
}

int read(){
	int x = 0, w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9'){
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + (ch - '0');
        ch = getchar();
    }

    return x * w;
}
void write(int x){
	int st[35];
	int t = 0;
	while(x) st[++ t] = x % 10, x /= 10;
	while(t) putchar(st[t --] + '0');
	return ;
}
```

完结撒花。有解释不到位的地方欢迎评论区提出。

---

## 作者：huangrenheluogu (赞：0)

发现回文，不是很会，考察差分数组的性质。

如果知道了 $[2,l-1]$ 是回文的，那推断 $[1,l]$ 是回文的只需要 $a_2-a_1+b_2-b_1=-a_l+a_{l-1}-b_l+b_{l-1}$。

相当于是把差分数组对称相减之后要求相等。

于是可以二分答案，然后把 $a$ 的这个序列的哈希值放到 unordered_map 里，判断 $b$ 的序列的哈希值是否在这里即可。但是根据生日悖论，单哈希碰撞概率十分大，因此需要使用双哈希。

对于偶数的点，需要多维护一维表示中间的点的差，因为有额外的中间两个点相等的限制。

于是有 $\mathcal{O}(n\log ^2n)$ 的做法，但是需要卡常。

卡常技巧：

- 把 long long 换成 int。
- 可以选取不太大的模数，这样可以把一个二或者三维（看判断的是奇数还是偶数）的状态压缩成 long long，就可以使用 unordered_map 代替 map，省掉一只 $\log$。
- 可以只进行一次二分，奇数、偶数一起判断，加快速度。
- 因为我代码里先判断偶数，如果判断失败但是答案增大，说明下次不用判断偶数。
- 更改哈希值，多交几遍。

代码如下，即使使用了上面所有优化之后，仍然有较大概率 TLE。~~同时，代码中的模数是同学的生日。~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid (l + r >> 1)
using namespace std;
const int N = 1e5 + 5, bas = 131;
const int mod1 = 19491001, mod2 = 20090723;
int n, m, a[N], b[N], ans, l, r, buc[N];
ll val;
bool flg0, flg1;
struct pii{
    int fi, se;
};
pii pa[N], pb[N], sa[N], sb[N], qp[N];
unordered_map<ll, bool> f;
unordered_map<ll, bool> g;
pii tmp, tem;
inline void add(int &x, int y, int p){
    x += y;
    if(x >= p) x -= p;
}
inline int pls(int x, int y, int p){
    x += y;
    if(x >= p) x -= p;
    return x;
}
inline pii operator + (pii x, pii y){
    return {pls(x.fi, y.fi, mod1), pls(x.se, y.se, mod2)};
}
inline pii operator - (pii x, pii y){
    return {pls(x.fi, mod1 - y.fi, mod1), pls(x.se, mod2 - y.se, mod2)};
}
inline pii operator * (pii x, pii y){
    return {1ll * x.fi * y.fi % mod1, 1ll * x.se * y.se % mod2};
}
inline pii operator * (pii x, int y){
    return {1ll * x.fi * y % mod1, 1ll * x.se * y % mod2};
}
inline pii getpre(int l, int r, pii *a){
    return a[r] - a[l - 1] * qp[r - l + 1];
}
inline pii getsuf(int l, int r, pii *a){
    return a[l] - a[r + 1] * qp[r - l + 1];
}
inline bool checkodd(int stp){
    f.clear();
    for(int i = stp + 1; i <= n - stp; i++){
        tmp = getpre(i - stp + 1, i, pa);
        tem = getsuf(i, i + stp - 1, sa);
        tmp = tmp - tem;
        val = 1ll * tmp.fi * (mod2 + 1) + tmp.se;
        f[val] = 1;
    }
    for(int i = stp + 1; i <= m - stp; i++){
        tmp = getpre(i - stp + 1, i, pb);
        tem = getsuf(i, i + stp - 1, sb);
        tmp = tem - tmp;
        val = 1ll * tmp.fi * (mod2 + 1) + tmp.se;
        if(f[val]) return 1;
    }
    return 0;
}
inline bool checkeven(int stp){
    g.clear();
    for(int i = stp + 1; i <= n - stp - 1; i++){
        tmp = getpre(i - stp + 1, i, pa);
        tem = getsuf(i + 1, i + stp, sa);
        tmp = tmp - tem;
        val = 1ll * (1ll * tmp.fi * (mod2 + 1) + tmp.se) * 201 + a[i + 1] - a[i] + 100;
        g[val] = 1;
    }
    for(int i = stp + 1; i <= m - stp - 1; i++){
        tmp = getpre(i - stp + 1, i, pb);
        tem = getsuf(i + 1, i + stp, sb);
        tmp = tem - tmp;
        val = 1ll * (1ll * tmp.fi * (mod2 + 1) + tmp.se) * 201 + b[i] - b[i + 1] + 100;
        if(g[val]) return 1;
    }
    return 0;
}
inline void read(int &x){
    x = 0;
    char c = getchar_unlocked();
    while(c > '9' || c < '0') c = getchar_unlocked();
    while('0' <= c && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar_unlocked();
    }
}
signed main(){
    // freopen("ivy.in", "r", stdin);
    // freopen("ivy.out", "w", stdout);
    read(n), read(m);
    for(int i = 1; i <= n; i++){
        read(a[i]);
    }
    for(int i = 1; i <= m; i++){
        read(b[i]);
    }
    qp[0] = {1, 1};
    for(int i = 1; i <= n || i <= m; i++){
        qp[i] = qp[i - 1] * bas;
    }
    for(int i = 2; i <= n; i++){
        pa[i] = pa[i - 1] * bas + (pii){a[i] - a[i - 1], a[i] - a[i - 1]};
    }
    for(int i = n - 1; i; i--){
        sa[i] = sa[i + 1] * bas + (pii){a[i] - a[i + 1], a[i] - a[i + 1]};
    }
    for(int i = 2; i <= m; i++){
        pb[i] = pb[i - 1] * bas + (pii){b[i] - b[i - 1], b[i] - b[i - 1]};
    }
    for(int i = m - 1; i; i--){
        sb[i] = sb[i + 1] * bas + (pii){b[i] - b[i + 1], b[i] - b[i + 1]};
    }
    ans = 1;
    for(int i = 1; i < n; i++){
        buc[a[i + 1] - a[i] + 100] = 1;
    }
    for(int i = 1; i < m; i++){
        if(buc[b[i] - b[i + 1] + 100]) ans = 2;
    }
    l = 1, r = n / 2;
    flg0 = flg1 = 1;
    while(l <= r){
        if(flg0 && checkeven(mid)){
            ans = 2 * mid + 2;
            l = mid + 1;
        }
        else{
            if(checkodd(mid)){
                flg0 = 0;
                ans = 2 * mid + 1;
                l = mid + 1;
            }
            else r = mid - 1;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---


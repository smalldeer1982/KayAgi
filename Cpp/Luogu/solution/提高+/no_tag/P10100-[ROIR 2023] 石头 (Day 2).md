# [ROIR 2023] 石头 (Day 2)

## 题目背景

翻译自 [ROIR 2023 D2T3](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day2.pdf)。



## 题目描述

Bob 面前排列着 $n$ 个黑色石头，从 $1$ 到 $n$ 编号。第 $i$ 个石头上写有一个整数 $a_i$，$n$ 个石头上写的整数构成了一个排列。我们称第 $i$ 个石头的相邻石头为第 $(i-1)$ 个和第 $(i+1)$ 个石头（如果存在的话）。

Bob 按照以下步骤进行 $n$ 次操作：

- 在第一步，选择任意的 $i$（$1\le i\le n$），并将第 $i$ 个石头涂成白色。
- 在第 $2$ 到第 $n$ 步，选取相邻石头中至少有一个白色石头的黑色石头中的 $a_i$ 最小的石头 $j$（即，可能有很多个黑色石头满足它的相邻石头中至少有一个白色石头，但是要选取其中 $a_i$ 最小的那个），并将其涂成白色。

很容易看出，在执行完所有步骤后，$n$ 个石头都是白色的。

Alice 选择了 $q$ 对值 $p_j$ 和 $k_j$。对于每对 $p$ 和 $k$ 的值，她想知道有多少种不同的选择第一步时将哪块石头涂成白色的方式，使得第 $p$ 块石头在第 $k$ 步变成白色。

帮助 Bob 回答 Alice 的 $q$ 个查询。

## 说明/提示

下面的样例解释中加粗的数是被涂成白色的。

在第一个样例中：

- 如果第一步选择第 $1$ 块石头：
  - 第 $1$ 步：$[\bold1, \gray4, \gray6, \gray5, \gray2, \gray3]$；
  - 第 $2$ 步：$[\bold1, \bold4, \gray6, \gray5, \gray2, \gray3]$；
  - 第 $3$ 步：$[\bold1, \bold4, \bold6, \gray5, \gray2, \gray3]$；
  - 第 $4$ 步：$[\bold1, \bold4, \bold6, \bold5, \gray2, \gray3]$；
  - 第 $5$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \gray3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。
- 如果第一步选择第 $2$ 块石头：
  - 第 $1$ 步：$[\gray1, \bold4, \gray6, \gray5, \gray2, \gray3]$；
  - 第 $2$ 步：$[\bold1, \bold4, \gray6, \gray5, \gray2, \gray3]$；
  - 第 $3$ 步：$[\bold1, \bold4, \bold6, \gray5, \gray2, \gray3]$；
  - 第 $4$ 步：$[\bold1, \bold4, \bold6, \bold5, \gray2, \gray3]$；
  - 第 $5$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \gray3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。
- 如果第一步选择第 $3$ 块石头：
  - 第 $1$ 步：$[\gray1, \gray4, \bold6, \gray5, \gray2, \gray3]$；
  - 第 $2$ 步：$[\gray1, \bold4, \bold6, \gray5, \gray2, \gray3]$；
  - 第 $3$ 步：$[\bold1, \bold4, \bold6, \gray5, \gray2, \gray3]$；
  - 第 $4$ 步：$[\bold1, \bold4, \bold6, \bold5, \gray2, \gray3]$；
  - 第 $5$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \gray3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。
- 如果第一步选择第 $4$ 块石头：
  - 第 $1$ 步：$[\gray1, \gray4, \gray6, \bold5, \gray2, \gray3]$；
  - 第 $2$ 步：$[\gray1, \gray4, \gray6, \bold5, \bold2, \gray3]$；
  - 第 $3$ 步：$[\gray1, \gray4, \gray6, \bold5, \bold2, \bold3]$；
  - 第 $4$ 步：$[\gray1, \gray4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $5$ 步：$[\gray1, \bold4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。
- 如果第一步选择第 $5$ 块石头：
  - 第 $1$ 步：$[\gray1, \gray4, \gray6, \gray5, \bold2, \gray3]$；
  - 第 $2$ 步：$[\gray1, \gray4, \gray6, \gray5, \bold2, \bold3]$；
  - 第 $3$ 步：$[\gray1, \gray4, \gray6, \bold5, \bold2, \bold3]$；
  - 第 $4$ 步：$[\gray1, \gray4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $5$ 步：$[\gray1, \bold4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。
- 如果第一步选择第 $6$ 块石头：
  - 第 $1$ 步：$[\gray1, \gray4, \gray6, \gray5, \gray2, \bold3]$；
  - 第 $2$ 步：$[\gray1, \gray4, \gray6, \gray5, \bold2, \bold3]$；
  - 第 $3$ 步：$[\gray1, \gray4, \gray6, \bold5, \bold2, \bold3]$；
  - 第 $4$ 步：$[\gray1, \gray4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $5$ 步：$[\gray1, \bold4, \bold6, \bold5, \bold2, \bold3]$；
  - 第 $6$ 步：$[\bold1, \bold4, \bold6, \bold5, \bold2, \bold3]$。

本题使用捆绑测试。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $n,q\le300$ |
| $2$ | $17$ | $n\le3000$ |
| $3$ | $12$ | $n\le50000,q\le10$ |
| $4$ | $6$ | $a_i$ 的值递增 |
| $5$ | $16$ | 所有 $k_i$ 相等 |
| $6$ | $15$ | 所有 $p_i$ 相等 |
| $7$ | $14$ | 无特殊性质 |

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$1 \le q \le 10^5$，$1 \le a_i \le n$ 且所有 $a_i$ 互不相同，$1 \le p_j,k_j \le n$。

## 样例 #1

### 输入

```
6 4
1 4 6 5 2 3
3 1
2 2
6 3
4 3```

### 输出

```
1
2
1
2```

## 样例 #2

### 输入

```
5 3
5 2 3 4 1
2 3
4 4
3 2```

### 输出

```
0
1
1```

# 题解

## 作者：ykzzldz (赞：5)

先给出一个显然的结论，对于一次询问 $(p,k)$，若答案不为 $0$，则有 $[p-k+1,p]$ 或 $[p,p+k-1]$ 被取完。由于这两部分没有本质区别，我们只讨论右区间的情况。

首先，若 $a_{p+k}<a_p$，答案为 $0$，下面我们不再考虑这种情况。我们设 $[p,p+k-1]$ 的最大值位置为 $pos$，那么在 $pos$ 左边的数肯定是不能贡献答案的。

先考虑 $a_{p+k}>a_{pos}$ 的情况，若从 $pos$ 右侧开始染色，染色会在 $pos$ 位置被卡住，也就是说，会先染 $[pos+1,p+k-1]$ 这一段，所以这一段都能被贡献进答案中。单独考虑 $pos$ 位置，发现其能被贡献进答案当且仅当区间内 $pos$ 左侧有一个位置的值大于右侧的所有值，这样可以在这个左侧的位置被卡住。

再考虑 $a_{p+k}<a_{pos}$ 的情况，这种情况下只有 $pos$ 位置可能被贡献进答案。此时，应满足区间内 $pos$ 左侧有一个位置大于右侧的所有值且区间内除 $pos$ 位置外其他值都应该比 $a_{p+k}$ 小，这样才能被 $a_{p+k}$ 卡住。

---

## 作者：Missa (赞：5)

拆分询问，拆成 $\leq k$ 步到达 $p$。

不妨假设出发点 $x$ 位于 $p$，左侧的情况是对称的。

注意到 $x$ 只能位于 $[p, p+k-1]$ 中，并且不能拓展到超过 $p+k-1$ 的位置。也就是说，$x+1 \sim p+k$ 中需要有一个位置顶住，不能拓展到太右边。即，$p \sim x-1$ 的最大值不超过 $x+1 \sim p+k$ 的最大值。这显然具有可二分性，合法的 $x$ 是一段前缀。st 表维护即可。

```cpp
#include <bits/stdc++.h>

int main() {
  int n, q; scanf("%d %d", &n, &q);
  std::vector<int> a(n);
  for (int &x : a) scanf("%d", &x);
  int m = std::log2(n);
  std::vector<std::vector<int>> st(m + 1, std::vector<int>(n));
  st[0] = a;
  for (int i = 1; i <= m; i++)
    for (int j = 0; j + (1 << i) - 1 < n; j++) 
      st[i][j] = std::max(st[i - 1][j], st[i - 1][j + (1 << i-1)]);
  auto qry = [&](int l, int r) {
    if (l < 0 || l > r || r >= n) return (int)1e9;
    int t = std::log2(r - l + 1);
    return std::max(st[t][l], st[t][r - (1 << t) + 1]);
  };
  auto calc = [&](int p, int k) {
    if (k == 1) return 1;
    if (k == 0) return 0;
    int res = 0;
    int l = p + 1, r = std::min(n - 1, p + k - 1), ans = p;
    while (l <= r) {
      int mid = l + r >> 1;
      if (qry(p, mid - 1) < qry(mid + 1, p + k)) ans = mid, l = mid + 1;
      else r = mid - 1;
    }
    res += ans - p;
    l = std::max(0, p - k + 1), r = p - 1, ans = p;
    while (l <= r) {
      int mid = l + r >> 1;
      if (qry(mid + 1, p) < qry(p - k, mid - 1)) ans = mid, r = mid - 1;
      else l = mid + 1;
    }
    res += p - ans;
    return res + 1;
  };
  while (q--) {
    int p, k; scanf("%d %d", &p, &k); --p;
    printf("%d\n", calc(p, k) - calc(p, k - 1));
  }
}
```

---

## 作者：Taoran_01 (赞：2)

<!-- P10100 [ROIR 2023 Day 2] 石头 题解 -->

---
### 写在前面
这里提供一种 $O(n\log n+q\log n)$ 的单调栈做法，这个洛谷题解区和官方题解都没有提到。

---
### 从单调性到答案区间
首先发现一定步数的取石子只会取到连续的区间。设 $\text{cnt}_{x\rightarrow p}$ 表示从 $x$ 开始、恰好取到 $p$ 所需的取石子次数。

打表发现答案具有单调性，即 $\{x\mid\text{cnt}_{x\rightarrow p}=k\}$ 是两段连续的区间。

> 下图中，答案区间为两段，分布在 $p$ 的左右。
> 
> ![](https://cdn.luogu.com.cn/upload/image_hosting/hmkrwr8k.png)
> 
> 可以感性理解为，越远的所需步数越多，越近的所需步数越少，而步数恰好 $=k$ 的有两个区间 ($k=1$ 时可能并为一个)。严谨证明我不会。

我们可以先通过二分找出 $\{x\mid\text{cnt}_{x\rightarrow p}\le k\}$ 的区间 $[\text{lf}_1,\text{rt}_2]$ (即下图中红色的部分)，再从左端点向右二分找到 $\text{cnt}_{x\rightarrow p}=k$ 的最大的 $x=\text{rt}_1$、从右端点向左二分找到最小的 $x=\text{lf}_2$，即可完全确定这两个区间 $[\text{lf}_1,\text{rt}_1]$、$[\text{lf}_2,\text{rt}_2]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/vuqv73bp.png)

二分步骤确定了，接下来问题转化为“如何快速求得 $\text{cnt}_{x\rightarrow p}$”。

---
### 从步数求解到“第二较大后继”预处理
$p=x$ 时答案自然为 $1$。  
不妨**设 $p<x$ 进行讨论**，$p>x$ 只需翻转即可。

另，下文中，“比 xxx 大的第 xxx 个数”按**从左向右**的顺序，表示“xxx 的第 xxx 更大后继”。此处“xxx”**仅表示位置关系**，而非次序关系。(当然 $p>x$ 是从右向左，以此类推。)

#### 固定区间长度，探寻区间端点的条件
$x$ 会在第 $k$ 步取到 $p$，意味着 $x$ 在 $k$ 步内取了 $[l,r]$ 的一段区间，其中 $p=l$ 且 $r-l+1=k$。  
“$l$ 在第 $k$ 步被取到”的充要条件是 “$r+1$ 不会在前 $k$ 步内取到”，故只需保证 “$\forall i\in[l,x),\ a_i<a_{r+1}$” 即可。这里 $x$ 是开的，因为 $x$ 必选。

还有一种理解方式，就是 $x$ 扩展时**被 $r+1$ 挡住**，再**回头**才会取到 $l$。

#### 固定区间端点，求解对应的区间长度
由此，从 $x$ 取到 $p$ 所对应的“墙” $t$ 即为**区间 $(x,n]$ 中，比 $\max\limits_{i\in[p,x)}a_i$ 大的第一个数 $a_t$**。选择区间左右端点分别为 $l=p,\ r=t-1$，所需步数即为 $r-l+1$。

$\max\limits_{i\in[p,x)}a_i$ 对应的下标 $\text{mxidx}$ 可以使用 ST 表维护。  
问题转化为，如何快速求得 $\text{mxidx}$ 在区间 $(x,n]$ 中的“第一较大后继” $t$。

#### 固定最大下标，求解特定区间内“较大后继”
其它题解的思路都是使用“ST 表上二分”或“开线段树维护”解决，复杂度 $O(\log n)$，或离线做到 $O(1)$。下面讲单调栈维护做到 $O(1)$ 的方法。

考虑如果限制为 $[x,n]$，则 $a_t$：
> 区间 $[x,n]$ (原为 $(x,n]$) 中，比 $\max\limits_{i\in[p,x)}a_i$ 大的第一个数

等价于：(思考一下为什么)
> 比 $\max\limits_{i\in[p,x)}a_i$ 大的第一个数

> Hint:  
> 因为 $\max\limits_{i\in[p,x)}a_i$ 已为 $[p,x)$ 最大，且“下一个数”只能在 $[p,n]$ 取得。  
> 而答案限制在 $[x,n]$，恰为补集，故无需限制自然满足。

限制还原为 $(x,n]$，$a_t$ 等价于：(思考一下为什么)
> **刨去 $x$ 后的区间中**，比 $\max\limits_{i\in[p,x)}a_i$ 大的第一个数

进一步，$a_t$ 等价于：
> 比 $\max\limits_{i\in[p,x)}a_i$ 大的第一个数……
> 
> 如果此数不为 $a_x$，则答案就是这个数。
> 
> **如果此数为 $a_x$** (即若 $t=x$)，**答案为比 $\max\limits_{i\in[p,x)}a_i$ 大的第二个数**。  
> (请注意为“**第二个数**”，这等价于刨去作为“第一个数”的 $x$。)

由此，我们仅需要维护两个信息，即可求解 $t$：
1. $\forall i\in[1,n]$，比 $i$ 大的第一个数 (第一较大后继)；
2. $\forall i\in[1,n]$，比 $i$ 大的第二个数 (第二较大后继)。

---
### 单调栈维护的具体方法
这部分不着急看，**建议先搞清楚求解思路再细化求解方式！！**

#### 步骤
维护两个栈 $\text{stk}_1$ 和 $\text{stk}_2$，分别解决“第一个数” $\text{nxt}$ 和“第二个数” $\text{nxt}'$。

$\text{stk}_1$ 作普通单调栈，递增，维护大于 $a_i$ 的第一个数。唯一的不同点是，元素出栈后压入 $\text{stk}_2$。  
Tip: 出栈有两种，第一种为“维护单调性”，第二种为“结束后清空剩余元素”。

$\text{stk}_2$ 也为从栈底到栈顶单调递增的栈，栈的**唯一**元素来源是 $\text{stk}_1$ 弹出来的元素。

对于每次遍历到的元素 $a_i$，弹栈直到 $a_\text{top}>a_i$。使用 $a_i$ 对每次被弹掉的元素 $a_{\text{top}'}$ 更新答案 ${\text{nxt}'}_{\text{top}'}\leftarrow i$。这一步类似普通单调栈。  
弹栈停止后，**$a_i$ 不加入 $\text{stk}_2$**。

$a_n$ 处理结束、$\text{stk}_1$ 清空后，将 $\text{stk}_2$ 不断弹出元素直至清空，更新 ${\text{nxt}'}_{\text{top}'}\leftarrow n+1$。

#### 原理
$\text{stk}_2$ 存储 $\text{stk}_1$ 出栈元素。  
这些元素的 $\text{nxt}$ 已被求得，在 $\text{nxt}_x$ 之后第一个比 $a_x$ 大的数即为 ${\text{nxt}'}_x$。

$\text{stk}_2$ 使用循环遍历到的元素 $a_i$ 更新答案。  
元素 $a_x$ 被加入 $\text{stk}_2$，当且仅当 $\text{nxt}_x$ 处理完毕，故 $a_x$ 在 $\text{stk}_2$ 中遇到到的所有 $a_i$ 都是继 $a_{\text{nxt}_x}$ 之后遇到的。  
这时候就可以“肆无忌惮地”拿第一个大于 $a_\text{top}$ 的 $a_i$ 更新“第二个比 $a_\text{top}$ 大的数” ${\text{nxt}'}_\text{top}\leftarrow i$。

$a_i$ 不压入 $\text{stk}_2$，只有在 $\text{stk}_1$ 中“走过一遭”后才能进入 $\text{stk}_2$。  
维持 $\text{stk}_2$ 元素被更新的“时效性”，以确保答案的正确性。

最后，先弹 $\text{stk}_1$，再弹 $\text{stk}_2$，处理“不存在”的 $n+1$。  
完整维护所有数的 $\text{nxt}$ 和 $\text{nxt}'$，不遗漏。

#### 注意事项
1. $\text{stk}_1$ 和 $\text{stk}_2$ 一次遍历同时处理，原因看原理；
2. 为维护 $\text{stk}_2$ 单调性，元素弹出 $\text{stk}_1$ 的顺序需要颠倒才能进入 $\text{stk}_2$。为此可以先进一遍 $\text{stk}_3$ 再出来。

---
### 步骤总结
1. 单调栈预处理元素的“第一更大前驱”、“第二更大前驱”、“第一更大后继”、“第二更大后继” (第 xxx 指位置关系)；
2. 二分找到 $\text{cnt}_{x\rightarrow p}\le k$ 的大区间 $[\text{lf}_1,\text{rt}_2]$；
3. 二分找到 $\text{cnt}_{x\rightarrow p}=k$ 的两个小区间 $[\text{lf}_1,\text{rt}_1]$ 和 $[\text{lf}_2,\text{rt}_2]$；
4. 长度合并，统计答案。

注意二分起点和终点，做“不重不漏”：
1. $p$ 分配给一个区间，这里我做的是 $[\text{lf}_1,\text{rt}_1]\subseteq[1,p)$，$[\text{lf}_2,\text{rt}_2]\subseteq[p,n]$。
2. $\text{lf}_1\in[1,p)$，$\text{rt}_2\in[p,n]$。
3. $\text{rt}_1\in[\text{lf}_1,p)$，$\text{lf}_2\in[p,\text{rt}_2]$。

---
### 代码
[AC](https://www.luogu.com.cn/record/190712787) 12.10MB 738ms
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;

char buf[1<<20], *p1, *p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)

inline ll read() {
	ll x=0, f=1; char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	return x*f;
}

#define N 100010
#define INF 0x3f3f3f3f
int n, q;
int a[N], f[N][20];
int Log[N];
int stk1[N], stk2[N], stk3[N], top1, top2, top3;
int pre1[N], nxt1[N]; // 1st pos | a[pos] > a[i]
int pre2[N], nxt2[N]; // 2nd pos | a[pos] > a[i]

int query(int l, int r) {
	int &x1=f[l][Log[r-l+1]], &x2=f[r-(1<<Log[r-l+1])+1][Log[r-l+1]];
	return (a[x1]>=a[x2])?x1:x2;
}

int findL(int l, int x) {
	int mxidx=query(l, x-1);
	int t=nxt1[mxidx]; if (t==x) t=nxt2[mxidx];
	return (t-1)-l+1;
}
int findR(int x, int r) {
	int mxidx=query(x+1, r);
	int t=pre1[mxidx]; if (t==x) t=pre2[mxidx];
	return r-(t+1)+1;
}
int find(int x, int p) {if (x==p) return 1;return p<x?findL(p,x):findR(x,p);}
int chk1(int x, int k, int p) {return find(x,p)<=k;}
int chk2(int x, int k, int p) {return find(x,p)==k;}

signed main() {
	for (int i=2; i<N; ++i) Log[i]=Log[i>>1]+1;
	n=read(), q=read();
	for (int i=1; i<=n; ++i) a[i]=read(), f[i][0]=i;
	for (int i=n; i; --i) {
		while (top2&&a[stk2[top2]]<a[i]) pre2[stk2[top2--]]=i;
		while (top1&&a[stk1[top1]]<a[i]) 
			pre1[stk1[top1]]=i, stk3[++top3]=stk1[top1--];
		while (top3) stk2[++top2]=stk3[top3--];
		stk1[++top1]=i;
	} while (top1) pre1[stk1[top1]]=0, stk2[++top2]=stk1[top1--];
	while (top2) pre2[stk2[top2--]]=0;
	for (int i=1; i<=n; ++i) {
		while (top2&&a[stk2[top2]]<a[i]) nxt2[stk2[top2--]]=i;
		while (top1&&a[stk1[top1]]<a[i]) 
			nxt1[stk1[top1]]=i, stk3[++top3]=stk1[top1--];
		while (top3) stk2[++top2]=stk3[top3--];
		stk1[++top1]=i;
	} while (top1) nxt1[stk1[top1]]=n+1, stk2[++top2]=stk1[top1--];
	while (top2) nxt2[stk2[top2--]]=n+1;
	for (int j=1; j<=Log[n]; ++j) for (int i=1; i<=n-(1<<j)+1; ++i) {
		int &x1=f[i][j-1], &x2=f[i+(1<<(j-1))][j-1];
		f[i][j]=(a[x1]>=a[x2])?x1:x2;
	}
	while (q--) {
		int p=read(), k=read(), lf1=INF, rt1=-INF, lf2=INF, rt2=-INF, L, R, mid;
		L=1, R=p; while (L<R) {
			mid=(L+R)>>1;
			if (chk1(mid, k, p)) R=mid, lf1=mid;
			else L=mid+1;
		}
		L=p, R=n+1; while (L<R) {
			mid=(L+R)>>1;
			if (chk1(mid, k, p)) L=mid+1, rt2=mid;
			else R=mid;
		}
		L=lf1, R=p; while (L<R) {
			mid=(L+R)>>1;
			if (chk2(mid, k, p)) L=mid+1, rt1=mid;
			else R=mid;
		}
		L=p, R=rt2+1; while (L<R) {
			mid=(L+R)>>1;
			if (chk2(mid, k, p)) R=mid, lf2=mid;
			else L=mid+1;
		}
		printf("%d\n", max(rt1-lf1+1,0)+max(rt2-lf2+1,0));
	}
	return 0;
}

```

---
### 写在后面
考场上二分写挂了，沦为和暴力老哥一样的分数。

补题时，同学写的 $O(q\log^2\hspace{-0.1cm}n)$ 做法。他多带一个 $\log$ 是使用了二分求某数在区间内的“更大后继”，但是仍然跑得飞快。

我尝试使用单调栈做，边写代码边不断细化解法。中间突然发现单调栈无法处理“区间内”的限制，以为做法假了。最后同学 [$\texttt{TMC}$](https://www.luogu.com.cn/user/536743) @arrow_king 提醒“开两个栈维护”，一语点醒梦中人。过程坎坷，写题解以纪念。

[官方题解](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-solutions.pdf) (T7, Subtask 3,5,6) 有 $O(n+q)$ 的做法，挺详细的。感兴趣的可以看一下。

打完 NOIP2024 我可能就退役了。还有 5 天，祝各位选手 rp++！

---

## 作者：Lu_xZ (赞：2)

对于询问 $(p, k)$，要么 $[p + 1, p + k - 1]$ 被染色，要么 $[p - k + 1, p - 1]$ 被染色。

不妨考虑第一种。

假设起始点为 $s$，当前左右端点分别为 $i, j$。

我们需要循环往复执行一下操作：左移 $i$ 直至 $a_{i - 1} > a_{j + 1}$；右移 $j$ 直至 $a_{j + 1} > a_{i - 1}$。

称 $a_{j + 1}$ 和 $a_{i - 1}$ 为阈值，左右阈值都是单调上升的。

说的形象一点，设左边的阈值下标集合为 $A$，右边为 $B$（按访问顺序排序）:

+ $i \gets A_{k} + 1,\ k \gets k + 1$。
+ $j \gets B_l - 1,\ l \gets l + 1$。

$a_{p + k}$ 是阈值，因为 $p + k - 1$ 是一个连续段的末尾（连续往一个方向移动）。

左侧最大阈值必须小于 $a_{p + k}$，否则继续往右移动。

也就是说，$a_{p + k}$ 大于除 $s$ 外 $[p, p + k - 1]$ 的最大值。

左边最大阈值必须大于右边除 $a_{p + k}$ 外的最大阈值，即 $\max[p, s - 1] > \max[s + 1, s + k - 1]$。

否则左边比右边先走完。

现在找到了判断某个 $s$ 合法的条件，开始统计答案。

如果 $\max[p, p + k - 1] > a_{p + k}$，至多产生 $1$ 的贡献，判断 $s$ 为最大值的位置即可。

否则只需考虑 $\max[p, s - 1] > \max[s + 1, s + k - 1]$。

从右往左枚举 $s$，相当于往右式加一个元素，左式减一个元素，这是有单调性的，可以二分。

```cpp
#include<bits/stdc++.h>
#define eb emplace_back
#define ep emplace
using namespace std;

using ll = long long;
constexpr int N = 1e5 + 5;

struct T {
	int v, p;	
	friend T operator + (T a, T b) {
		return a.v > b.v ? a : b;
	}
} f[N][19];

T F(int l, int r) {
	if(l > r) return {0};
	int k = __lg(r - l + 1);
	return f[l][k] + f[r - (1 << k) + 1][k];
}
int n, q;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> q;
	for(int i = 1; i <= n; ++ i) {
		cin >> f[i][0].v;
		f[i][0].p = i;
	}
	for(int k = 1; k <= 18; ++ k) {
		for(int i = 1; i + (1 << k) - 1 <= n; ++ i) {
			f[i][k] = f[i][k - 1] + f[i + (1 << k - 1)][k - 1];
		}
	}
	f[n + 1][0] = f[0][0] = {N};
	while(q --) {
		int p, k, ans = 0; cin >> p >> k;
		if(k == 1) {
			cout << 1 << '\n';
			continue;
		}
		int L = p - k + 1, R = p + k - 1;
		if(R <= n) {
			auto ck = [&](int s) {
				return F(p, s - 1).v > F(s + 1, R).v;
			};
			if(F(p, R).v > f[R + 1][0].v) {
				int s = F(p, R).p;
				if(max(F(p, s - 1).v, F(s + 1, R).v) < f[R + 1][0].v && ck(s)) {
					++ ans;
				}
			}
			else {
				int l = p + 1, r = R;
				while(l < r) {
					int mid = l + r >> 1;
					ck(mid) ? r = mid : l = mid + 1;
				}
				ans += R - l + 1;
			}
		}
		if(L >= 1) {
			auto ck = [&](int s) {
				return F(s + 1, p).v > F(L, s - 1).v;
			};
			if(F(L, p).v > f[L - 1][0].v) {
				int s = F(L, p).p;
				if(max(F(s + 1, p).v, F(L, s - 1).v) < f[L - 1][0].v && ck(s)) {
					++ ans;
				}
			}
			else {
				int l = L, r = p - 1;
				while(l < r) {
					int mid = l + r + 1 >> 1;
					ck(mid) ? l = mid : r = mid - 1;
				}
				ans += l - L + 1;
			}
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：1)

有意思。

$O(n^3)$ 枚举每个起点判定。不再赘述。

我们发现，一旦我们选择了一个起点，那么整个流程就是确定的。并且我们还知道，要在第 $k$ 步取到 $p$，那么就需要先取完 $[p-k+1,p-1]$ 或者 $[p+1,p+k-1]$。当然如果有一个区间不足这么多数，那么这个区间内没有答案。又因为我们取的数一定是一个联通块，所以答案只能从 $[p-k+1,p+k-1]$ 中取。

我们分成左右两边来计算可能成为起点的位置的个数。下面以右区间 $[p+1,p+k-1]$ 为例。 

首先如果 $a_{p+k}<a_{p}$，那么铁定答案为 $0$，下面不再讨论。下面约定“区间”指的是 $[p,p+k-1]$。

那个 $a_i$ 单调递增的例子给了我们很大的启发，此时答案就是 $1$，即我们只能选择区间内的最大值作为起点。我们接着想，如果区间内不单调，又如何？我们会想到如果区间是一个上凸的，极值点下标为 $loc$，那么必然不可以选 $[p,loc-1]$。如果 $a_{p+k}>mx$，那么必然可以选 $[loc+1,p+k-1]$。另外两种情况下面讨论：

![https://cdn.luogu.com.cn/upload/image_hosting/esavbjav.png](https://cdn.luogu.com.cn/upload/image_hosting/esavbjav.png)

- 能否选 $loc$ 作为起点？那么就还是需要满足 $a_{p}$ 最后被染色了。之前选 $loc$ 右侧的点时，一定会先把 $loc$ 右侧都染完，然后向左染色，很无脑所以就没有在这里讨论。
如果选 $loc$，那么接下来可能向左也有可能向右。但是**归根结底**我们要满足 $a_p$ 最后被染色，总有一个时刻满足 $[q,p+k-1]$ 都被染色，然后向左染色，否则就是不合法的。
于是就容易发现当 $[p,loc-1]$ 的最大值 $lmx>[loc+1,p+k-1]$ 的最大值 $rmx$ 时存在 $q$ 满足条件。此时可以选 $loc$。

- $a_{p+k}<mx$ 时是否有点可以作为起点呢？下面这组数据就说明是有可能的。

```C++
5 1
3 1 5 2 4
1 4
```


  此时我们只有 $loc$ 可能是合法的起点。如果 $loc$ 合法，我们还是要满足 $2$ 个条件：$a_{p+k}>a_p$，并且应该存在一个 $q$ 点（定义见上）。



上面的所有情况可以推广到任意区间，将区间最大值视为上文的那个极值点即可。左区间做法雷同。可以用线段树维护区间最值的值和下标。



```C++
//SGT is missing and i'm gonna find it.

while(q--){
		int p=rd,k=rd;
		int ans=0;
		if(k==1){
			puts("1");
			continue;
		}
		
		if(p-k+1>0){
			
			auto res=query(1,1,n,p-k+1,p);//[mx,loc]
			
			int loc=res.ps;
			if(p-k<1||a[p-k]>res.pf){
				ans+=loc-1-(p-k);
				if(loc!=p){
					int rmx=query(1,1,n,loc+1,p).pf;
					int lmx=query(1,1,n,p-k+1,loc-1).pf;
					if(rmx>lmx)ans++;
				}
			}else if(loc==p-k+1){
				int rmx=query(1,1,n,loc+1,p).pf;
				if(rmx<a[p-k]){
					ans++;
				}
			}else if(loc!=p){
			// cdbg(q,'L',loc);
				int lmx=query(1,1,n,p-k+1,loc-1).pf;
				int rmx=query(1,1,n,loc+1,p).pf;
				int mx=max(lmx,rmx);
				if(mx<a[p-k]&&rmx>lmx)ans++;
			}
		}if(p+k-1<=n){
			auto res=query(1,1,n,p,p+k-1);
			
			int loc=res.ps;
			if(p+k>n||a[p+k]>res.pf){
				ans+=p+k-loc-1;
				if(loc!=p){
					int lmx=query(1,1,n,p,loc-1).pf;
					int rmx=query(1,1,n,loc+1,p+k-1).pf;
					if(lmx>rmx)ans++;
				}
			}else if(loc==p+k-1){
				int lmx=query(1,1,n,p,loc-1).pf;
				if(lmx<a[p+k])ans++;
			}else if(loc!=p){
				// cdbg(q,'R',loc);
				int lmx=query(1,1,n,p,loc-1).pf;
				int rmx=query(1,1,n,loc+1,p+k-1).pf;
				int mx=max(lmx,rmx);
				// cdbg(lmx,rmx,a[p-k]);
				if(mx<a[p+k]&&lmx>rmx)ans++;//Don't make fault when coping
			}
		}
		
		
		printf("%lld\n",ans);
	}
```

---

## 作者：IC0CI (赞：0)

# 题面分析

若点 $p$ 在第 $k$ 次操作中被选择，则 $[p + 1,p + k - 1]$ 或 $[p - k + 1,p - 1]$ 一定在前 $k - 1$ 次被选择。

左右两侧是相似的，这里考虑右侧。

在选择了 $[p + 1,p + k - 1]$ 之后只有 $a[p] < a[p + k]$ 时才会选择 $p$。

若点 $pos$ 为 $[p + 1,p + k - 1]$ 的最大值，那么对于 $[pos + 1,p + k - 1]$ 这段区间内的点的覆盖过程一定是先覆盖 $[pos + 1,p + k - 1]$。此时若 $a[pos] < a[p + k]$ 则 $[pos + 1,p + k - 1]$ 中的所有点为起始点时都是可行方案。如果 $a[pos] > a[p + 1]$ 则只有 $pos$ 为起始点且 $[p,pos - 1]$ 中存在一个点大于其右侧到 $p + k - 1$ 的所有点且小于 $a[p + k]$ 时 $pos$ 为可行方案，其他时候没有可行方案。

## 关于具体实现

用一个数据结构维护区间最大值就行了，这里用的是线段树。

## Code

复杂度 $\mathcal{O}(n \log_2{n})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pii pair<int,int>

int rd()
{
    int x = 0,w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * w;
}

const int N = 2e5 + 5;
const int inf = 0x7fffffff;
int n,q;
int a[N];

#define ls (p << 1)
#define rs (ls | 1)
#define mid ((pl + pr) >> 1)

pii t[N << 2];

void pu(int p) { t[p] = max(t[ls],t[rs]); }

void build(int p,int pl,int pr)
{
    if(pl == pr) return (void)(t[p] = {a[pl],pl});
    build(ls,pl,mid);
    build(rs,mid + 1,pr);
    pu(p);
}

pii qry(int p,int pl,int pr,int l,int r)
{
    if(l > r) return {0,0};
    if(l <= pl && pr <= r) return t[p];
    if(r <= mid) return qry(ls,pl,mid,l,r);
    if(l > mid) return qry(rs,mid + 1,pr,l,r);
    return max(qry(ls,pl,mid,l,r),qry(rs,mid + 1,pr,l,r));
}

signed main()
{
    n = rd(),q = rd();
    for(int i = 1;i <= n;i++) a[i] = rd();
    a[0] = inf,a[n + 1] = inf;
    build(1,1,n);
    while(q--)
    {
        int p = rd(),k = rd();
        if(k == 1)
        {
            cout << 1 << '\n';
            continue;
        }
        int pl = p,pr = p + k - 1,ans = 0;
        if(a[p] < a[pr + 1] && pr <= n)
        {
            int pos = qry(1,1,n,pl,pr).second;
            pii lmx = qry(1,1,n,p,pos - 1),rmx = qry(1,1,n,pos + 1,pr);
            if(a[pos] < a[pr + 1]) ans += pr - pos;
            if(lmx.first > rmx.first && max(lmx.first,rmx.first) < a[pr + 1]) ans++;
        }
        pl = p - k + 1,pr = p ;
        if(a[p] < a[pl - 1] && pl >= 1)
        {
            int pos = qry(1,1,n,pl,pr).second;
            pii rmx = qry(1,1,n,pos + 1,p),lmx = qry(1,1,n,pl,pos - 1);
            if(a[pos] < a[pl - 1]) ans += pos - pl;
            if(lmx.first < rmx.first && max(lmx.first,rmx.first) < a[pl - 1]) ans++;
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：iPhoneSX (赞：0)

## 题解
模拟赛场上想到了做法，可惜最后没有写完。题目非常好，代码实现细节很多。我的做法复杂度是 $O(n{\log^2\hspace{-0.1cm}n})$，可能不是最优，但是思路可以说是非常顺畅易懂的。

乍一看不知道怎么做？写暴力！拿一个数组 $num_{i,j}$ 记录第一步时将哪些石头涂成白色，可以使得第 $i$ 块石头在第 $j$ 步变成白色。 

暴力代码如下：
```cpp
	read(n,q);
	for(int i=1;i<=n;i++){
		read(a[i]);
	}
	a[0]=inf;
	a[n+1]=inf;
	for(int i=1;i<=n;i++){
		num[i][1].push_back(i);
		int fr=i-1,re=i+1;
		for(int j=2;j<=n;j++){
			if(a[fr]<a[re]){
				num[fr][j].push_back(i);
				fr--;
			}
			else{
				num[re][j].push_back(i);
				re++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<i<<" "<<j<<":";
			for(int l=0;l<num[i][j].size();l++){
				cout<<num[i][j][l]<<" ";
			}
			cout<<endl;
		}
	}
```````
通过暴力，发现正好 $j$ 次取到点 $i$ 的点一定分布在 $i$ 的两侧，且均为连续的区间。距离 $i$ 越远的点，它取到 $i$ 的次数一定是**单调不降**的。于是我们可以二分。对于每次询问的 $p,k$ ，（以右侧为例，左侧也是一样的），先二分找到取到 $p$ 的次数**大于** $k$ 的第一个点，再二分找到取到 $p$ 的次数**大于等于** $k$ 的第一个点，就能确定取到 $p$ 的次数等于 $k$ 的点的个数了。

于是问题变成了知道点 $x,y$，求第一个给 $y$ 染色时，需要多少次能取到 $x$？还是以 $y$ 在 $x$ 右侧为例，我们来看一个例子：
```cpp
1 4 6 2 3 9 7 8 5 10
``````
考虑第一个给第 $7$ 个点染色，求几次能取到第 $1$个点。显然 $1,4,6,2,3,9,7$ 这些左边的数一定会被取完，关键是右边会取哪些？这取决于前 $6$ 个点中的最大值（第 $6$ 个点，值为 $9$），因为向左取到这个最大值后，才能向右边取最多的点。只需要找到第 $7$ 个点右侧（不包括它本身）第一个比 $9$ 大的数（第 $10$ 个点，值为 $10$），前面的就都能取到。

于是又可以二分。先用 ST 表预处理出区间最大值，这样每次查询都是 $O(1)$ 的。二分找到右边第一个比左边最大值大的点即可。

对于左边也是完全一样的，总共要用到 $6$ 个二分。可以看代码再理解一下。

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<iomanip>
#include<iostream>
#include<list>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
#define ll long long
#define DBG(x) cout << #x << "=" << x << endl
#define inf 0x3f3f3f3f3f3f3f3f
#define mod 998244353
#define N 200005
using namespace std;
template <typename T>
void read(T& x) {
    x = 0;
    ll t = 1;
    char ch;
    ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            t = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    x *= t;
}
template <typename T, typename... Args>
void read(T& first, Args&... args) {
    read(first);
    read(args...);
}
template <typename T>
void write(T y) {
    T x = y;
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}
template <typename T, typename... Ts>
void write(T arg, Ts... args) {
    write(arg);
    if (sizeof...(args) != 0) {
        putchar(' ');
        write(args...);
    }
}
int n,q,p,k,a[N],st[N][30],lg2[N];
int mx(int x,int y){
	if(x>y){
		return x;
	}
	return y;
}
inline int query(int l,int r){
	int len=lg2[r-l+1];
	return mx(st[l][len],st[r-(1<<len)+1][len]);
}
inline int got1(int x,int L){//L在x左边时，第一个染x，取到L的次数
	int sum=0;
	sum=sum+(x-L+1);
	int maxx=query(L,x-1);
	int l=x+1,r=n,ans=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(query(x+1,mid)<maxx){
			ans=mid;
			l=mid+1;
		}
		else{
			r=mid-1;
		}
	}
	if(ans==0){
		return sum;
	}
	sum=sum+ans-x;
	return sum;
}
inline int got2(int x,int R){//R在x右边时，第一个染x，取到R的次数
	int sum=0;
	sum=sum+(R-x+1);
	int maxx=query(x+1,R);
	int l=0,r=x-1,ans=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(query(mid,x-1)<maxx){
			ans=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	if(ans==0){
		return sum;
	}
	sum=sum+x-ans;
	return sum;
}
signed main(){
	read(n,q);
	lg2[1]=0;
	for(register int i=2;i<=n+1;i++){
		lg2[i]=lg2[i>>1]+1;
	}
	for(register int i=1;i<=n;i++){
		read(a[i]);
		st[i][0]=a[i];
	}
	a[0]=inf;
	a[n+1]=inf;
	st[0][0]=inf;
	st[n+1][0]=inf;
	n++;
	for(register int j=1;j<=lg2[n]+1;j++){
		for(register int i=0;i+(1<<j)-1<=n;i++){
			st[i][j]=mx(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
	while(q--){
		read(p,k);
		if(k==1){
			putchar('1');
			putchar('\n');
			continue;
		}
		int l=p+1,r=p+k,ans1=0,ans2=0,ans=0;
		if(p+k<=n){
			while(l<=r){
				int mid=(l+r)/2;
				if(got1(mid,p)>k){
					ans1=mid;
					r=mid-1;
				}
				else{
					l=mid+1;
				}
			}
			l=p+1,r=p+k-1;
			while(l<=r){
				int mid=(l+r)/2;
				if(got1(mid,p)>=k){
					ans2=mid;
					r=mid-1;
				}
				else{
					l=mid+1;
				}
			}
		}
		if(ans1>=ans2){
			ans+=(ans1-ans2);
		}
		l=p-k,r=p-1,ans1=0,ans2=0;
		if(p-k>=0){
			while(l<=r){
				int mid=(l+r)/2;
				if(got2(mid,p)>k){
					ans1=mid;
					l=mid+1;
				}
				else{
					r=mid-1;
				}
			}
			l=p-k+1,r=p-1;
			while(l<=r){
				int mid=(l+r)/2;
				if(got2(mid,p)>=k){
					ans2=mid;
					l=mid+1;
				}
				else{
					r=mid-1;
				}
			}
		}
		if(ans1<=ans2){
			ans+=(ans2-ans1);
		}
		write(ans);
		putchar('\n');
	}
	return 0;
}
````````

---

## 作者：Purslane (赞：0)

## Solution

考虑给定起点，怎么计算一个人的排名。

不失一般性地，我们假设起点 $s$ 在所求位置 $p$ 的左侧。

显然 $\forall s+1 \le i \le p$，他们都是要被取出的。记 $v = \max_{s+1 \le i \le p} a_i$。对于 $s$ 左边的数，如果它小于 $v$ 就一定会被取出。所以我们要找到第一个大于 $v$ 的数。

模拟赛时写了一个双 $\log$ 做法：二分答案（显然 $s$ 离 $p$ 越远 $p$ 的排名越大），内部套一个线段树上二分求解第一个大于 $v$ 的数。以为能过了，结果成为小丑。 

其实优化很简单。$v$ 左侧第一个比它大的数，要么是 $s$，要么是我们这一轮要求的。所以我们本质上值有 $O(n)$ 个“找到某个数左边第一个大于某个数”的这样的询问。把他们全部离线下来即可做到 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,q,a[MAXN],st[MAXN][20],L[MAXN],R[MAXN],rev[MAXN],ll[MAXN],rr[MAXN];
int query(int l,int r) {
	int k=log2(r-l+1);
	return max(st[l][k],st[r-(1<<k)+1][k]);	
}
int calc_rnk(int st,int pos) {
	if(st==pos) return 1;
	int mx=-1,nxt;
	if(st<pos) {
		mx=query(st+1,pos);
		if(a[st]<mx) nxt=L[rev[mx]];
		else nxt=ll[rev[mx]];
		return pos-nxt;
	}
	else {
		mx=query(pos,st-1);
		if(a[st]<mx) nxt=R[rev[mx]];
		else nxt=rr[rev[mx]];
		return nxt-pos;
	}
}
#define mid (l+r>>1)
int calc(int p,int k) {
	if(!k) return 0;
	int bdl=p,bdr=p;
	int l=p+1,r=n;
	while(l<=r) {
		if(calc_rnk(mid,p)<=k) bdr=mid,l=mid+1;
		else r=mid-1;
	}
	l=1,r=p-1;
	while(l<=r) {
		if(calc_rnk(mid,p)<=k) bdl=mid,r=mid-1;
		else l=mid+1;	
	}
	return bdr-bdl+1;
}
namespace DS {
	int mx[MAXN<<2];
	#define lson (k<<1)
	#define rson (k<<1|1)
	void build(int k,int l,int r) {
		if(l==r) return mx[k]=a[l],void();
		build(lson,l,mid),build(rson,mid+1,r);
		return mx[k]=max(mx[lson],mx[rson]),void();	
	}
	int query(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return mx[k];
		if(y<=mid) return query(lson,l,mid,x,y);
		if(x>mid) return query(rson,mid+1,r,x,y);
		return max(query(lson,l,mid,x,y),query(rson,mid+1,r,x,y));	
	}
	int bfindr(int k,int l,int r,int lim,int v) {
		if(r<=lim||mx[k]<=v) return -1;
		if(l==r) return l;
		int tans=bfindr(lson,l,mid,lim,v);
		if(tans!=-1) return tans;
		return bfindr(rson,mid+1,r,lim,v);	
	}
	int bfindl(int k,int l,int r,int lim,int v) {
		if(l>=lim||mx[k]<=v) return -1;
		if(l==r) return l;
		int tans=bfindl(rson,mid+1,r,lim,v);
		if(tans!=-1) return tans;
		return bfindl(lson,l,mid,lim,v);	
	}	
}
int main() {
	freopen("stone.in","r",stdin);
	freopen("stone.out","w",stdout);
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q;
	ffor(i,1,n) cin>>a[i],st[i][0]=a[i],rev[a[i]]=i;
	ffor(j,1,19) for(int l=1,r=(1<<j);r<=n;l++,r++) st[l][j]=max(st[l][j-1],st[l+(1<<j-1)][j-1]);
	stack<int> st;
	DS::build(1,1,n);
	roff(i,n,1) {
		while(!st.empty()&&a[i]>a[st.top()]) st.pop();
		if(st.empty()) R[i]=n+1;
		else R[i]=st.top();
		st.push(i);
	}
	while(!st.empty()) st.pop();
	ffor(i,1,n) {
		while(!st.empty()&&a[i]>a[st.top()]) st.pop();
		if(st.empty()) L[i]=0;
		else L[i]=st.top();
		st.push(i);	
	}
	ffor(i,1,n) {
		if(L[i]) ll[i]=DS::bfindl(1,1,n,L[i],a[i]);
		if(ll[i]==-1) ll[i]=0;
	}
	ffor(i,1,n) {
		if(R[i]!=n+1) rr[i]=DS::bfindr(1,1,n,R[i],a[i]);
		if(rr[i]==-1) rr[i]=n+1;
	}
	ffor(i,1,q) {
		int p,k;
		cin>>p>>k;
		cout<<calc(p,k)-calc(p,k-1)<<'\n';	
	}
	return 0;
}
```

---

## 作者：MerlinLee (赞：0)

一道很好的题！

让我们一个一个来分析子任务。

对于子任务一，我们发现，在每次迭代中，许多涂成白色的石头是下一个部分。通过迭代起始位置 i 并根据问题条件移动段，如果段的当前长度为 k，并且第 $p$ 块石头是最后一颗被重新着色为白色的石头，我们将增加答案计数。

对于子任务二，在每个请求后重新运行区间扩展算法是没有意义的。我们将维护一个 $ans[p][k]$ 响应数组。提前为每个起始 i 运行算法并查看第 k 次迭代中最后添加的石头 $p$ 就足够了。换句话说，让我们提前移动所有起始位置的段，这样的预计算将适用于 $O(n^2)$ 的复杂度，并且对 $O(1)$ 请求的响应仅引用响应数组的必要单元格。

对于子任务四，只需注意我们几乎总是移动行的左边框就足够了（除非行的左边框已经到达数组的末尾）。通过对案例的简单分析，我们注意到当 $p+k-1<n$ 和 $p$ 添加到答案中时，如果 $p+1=k$ 的话，答案中添加了 1 这样一个性质。第一种情况对应于不断移动左边界的情况，第二种情况对应于我们无法再移动左边界的情况。

然后是子任务三，子任务五和子任务六，为了解决下一个子问题，如果第 k 个元素被添加到 $p$，让我们看看在执行 k 次操作之后的段。然后这个段的形式是 $[p-k+1,p]$ 或 $[p,p+k-1]$ 两种情况。由于这些情况是对称的，我们只用 $[p,p+k-1]$ 来描述这种情况。

所以让我们看看高点 $m$ 在这个部分的位置。让我们考虑三种情况。

第一种的话，起点是 $i < m$ 这样。换句话说，就是 i 位于 $m$ 的左侧。但我们知道 $a_m$ 是该段的最大元素。因此，数字为 $m$ 的元素将被添加到元素 $p$ 之后的扩展段中。我们得到，在这种情况下，$p$ 不能被添加到段 $k-m$ 中。

第二种的话，起点是 $i = m$ 这样。在这种情况下，检查 $p$ 是否是该段的第二个最大模拟，并且 $p + k$ 的添加时间晚于 $p$ 就足够了（换句话说，也就是 $a_p+k > a_p$）。如果满足这些条件，则 $p$ 将在第 k 次迭代中添加到区段中。

第三种的话，起点是 $i > m$ 这样。在这种情况下，如果 $a_p+k < a_m$，那么在将 p 添加到响应之前，我们将超出线段 $[p,p + k-1]$ 的边界。在 $a_p+k > a_m$ 的情况下，我们总是将 $a_p+k-1$ 添加到线段中，然后我们将在左边界的一侧添加元素，因为 $a_p+k$ 将是线段中所有元素中最大的。

所以，根据在长度为 k 的所有线段上求最大值和第二个最大值的方法的效率，我们获得了各种子问题的解。对于完整的解决方案，你需要以任何有效的方式在窗口中为段上的最大值使用足够有效的数据结构，例如条形树、稀疏表、窗口中的最大值。生成的复杂度就是 $O（n\log n +q）$ 或 $O（n+q)$ 视情况而定。

完结撒花！然后是代码。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define inl inline
using namespace std;
const ll N=1e5;
const ll INF=1e9+1e3;
pair<ll,ll>seg[N*4];
vector<ll>perm;
inl void upd(int v,int l,int r,int pos,int val) 
{
	if(l==r-1) 
	{
		seg[v]={val,pos};
	} 
	else 
	{
		int mid=(l+r)/2;
		if(pos<mid)
		{
			upd(v*2+1,l,mid,pos,val);
		} 
		else 
		{
			upd(v*2+2,mid,r,pos,val);
		}
		seg[v]=max(seg[v*2+1],seg[v*2+2]);
	}
}
inl pair<ll,ll> ask(int v,int l,int r,int askl,int askr) 
{
	if(l>=askr or r<=askl)
	  return {};
	if(askl<=l and r<=askr)
	  return seg[v];
	int mid=(l+r)/2;
	return max(ask(v*2+1,l,mid,askl,askr),ask(v*2+2,mid,r,askl,askr));
}
inl vector<pair<ll,ll>> ask(int n,int askl,int askr)
{
	vector<pair<ll,ll>> mx={ask(0,0,n,askl,askr)};
	ll p=mx[0].second;
	mx.push_back({-INF,-INF});
	if(askl!=p) 
	{
		mx.back()=max(mx.back(),ask(0,0,n,askl,p));
	}
	if(p+1!=askr) 
	{
		mx.back()=max(mx.back(),ask(0,0,n,p+1,askr));
	}
	if(mx.back().first==-INF)
	  mx.pop_back();
	return mx;
}
int main() 
{
//	freopen("stone.in","r",stdin);
//	freopen("stone.out","w",stdout);
	ios_base::sync_with_stdio(0); 
	cin.tie(0); 
	cout.tie(0);
	ll n,q;
	cin>>n>>q;
	perm.resize(n);
	for(int i=0;i<n;i++) 
	{
		cin>>perm[i];
		upd(0,0,n,i,perm[i]);
	}
	while(q--) 
	{
		ll t=1;
		if(t==1) 
		{
			ll p,k;
			cin>>p>>k;            
            if(k==1) 
			{
                cout<<"1"<<"\n";
                continue;
            }
			p--;
			ll ans=0;
			if(p+k<=n)
			{
				vector<pair<ll,ll>> mx=ask(n,p,p+k);
				if(p+k==n or mx[0].first<perm[p+k]) 
				{
					ans+=(p+k)-mx[0].second-1;
				}
				if(mx[1].second<mx[0].second and (p+k==n or mx[1].first<perm[p+k])) 
				{
					ans++;
				}
			}
			if(p-k+1>=0) 
			{
				vector<pair<ll,ll>> mx=ask(n,p-k+1,p+1);
				if(p-k<0 or mx[0].first<perm[p-k]) 
				{
					ans+=mx[0].second-(p-k+1);
				}
				if(mx[0].second<mx[1].second and (p-k<0 or mx[1].first<perm[p-k])) 
				{
					ans++;
				}
			}
			cout<<ans<<"\n";
		} 
		else 
		{
			ll u,v;
			cin>>u>>v;
			u--; 
			v--;
			swap(perm[u],perm[v]);
			upd(0,0,n,u,perm[u]);
			upd(0,0,n,u,perm[v]);
		}
	}
	return 0;
}
```

---

## 作者：To_our_starry_sea (赞：0)

### Solution

还不是因为我不够努力。

注意到在任何时候，所有被染成白色的石头必然构成了一个区间。考虑询问的位置为 $pos$，在第 $k$ 步被染成了白色，发现最终必然是 $[pos - k + 1, pos]$ 或者 $[pos, pos + k - 1]$ 中的所有石头都被染成了白色，且 $pos$ 位置的石头最后被染色。注意到这两种情况是对称的，因此我们只需要考虑对于区间 $[pos - k + 1, pos]$ 的情况。考虑若存在位于 $pos - k$ 的石头，则发现 $a_{pos - k}$ 必须大于 $\max\limits_{i = pos - k + 1}^{pos}[i \neq st]a_i$，其中 $st$ 表示初始时被染成白色的位置。注意，若 $a_{pos - k} < a_{st}$，则最多只有这个位置合法。同时，我们考虑在 $[pos - k + 1]$ 中的初始点 $st$，发现其合法的充要条件为 $\max\limits_{i = pos - k + 1}^{st - 1}a_i > \max\limits_{i = st + 1}^{pos}a_i$，因为位于 $pos$ 的石头必须最后被染色。容易发现在第一个限制满足之后，$st$ 的合法选择必为一个区间，因此我们可以 st 表预处理区间最大值，二分计算答案。时间复杂度为 $O((q + n) \log n)$。需要注意一些细节。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
int n, q, a[MAXN], LOG[MAXN], maxn[MAXN][20], id[MAXN][20];
inline int rmq(int l, int r) {
    if (l > r) return 0;
    int len = LOG[r - l + 1];
    return max(maxn[l][len], maxn[r - (1 << len) + 1][len]);
}
inline int find(int l, int r) {
    if (l > r) return 0;
    int len = LOG[r - l + 1];
    if (maxn[l][len] > maxn[r - (1 << len) + 1][len]) return id[l][len];
    else return id[r - (1 << len) + 1][len];
}
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
int main() {
    //freopen("stone.in", "r", stdin);
    //freopen("stone.out", "w", stdout);
    n = read(), q = read();
    for (int i = 1; i <= n; i++) a[i] = read(), maxn[i][0] = a[i], LOG[i] = (i == 1 ? 0 : LOG[i >> 1] + 1), id[i][0] = i;
    for (int j = 1; j <= 18; j++) {
        for (int i = 1; i <= n; i++) {
            maxn[i][j] = maxn[i][j - 1], id[i][j] = id[i][j - 1];
            if (i + (1 << (j - 1)) <= n) {
                if (maxn[i][j] < maxn[i + (1 << (j - 1))][j - 1]) maxn[i][j] = maxn[i + (1 << (j - 1))][j - 1], id[i][j] = id[i + (1 << (j - 1))][j - 1];
            }
        }
    }
    while (q--) {
        int pos = read(), k = read(), ans = 0;
        bool pd = false;
        if (k == 1) {
            puts("1");
            continue;
        }
        if (pos + k - 1 <= n) {
            if (pos + k <= n) {
                int l = pos, r = pos + k - 1;
                int maxx = rmq(l, r), way = find(l, r);
                if (maxx > a[pos + k]) {
                    if (max(rmq(l, way - 1), rmq(way + 1, r)) > a[pos + k]) {
                        ans = 0;
                        pd = true;
                    }
                    else if (rmq(l, way - 1) < rmq(way + 1, r)) {
                        ans = 0;
                        pd = true;
                    }
                    else {
                        ans = 1;
                        pd = true;
                    }
                }
            }
            if (!pd) {
                int l = pos, r = pos + k - 1, way = pos + k - 1;
                int L = l, R = r;
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (rmq(L, mid - 1) > rmq(mid + 1, R)) way = min(way, mid), r = mid - 1;
                    else l = mid + 1;
                }
                ans += R - way + 1;
            }
        }
        pd = false;
        if (pos - k + 1 >= 1) {
            if (pos - k >= 1) {
                int l = pos - k + 1, r = pos;
                int maxx = rmq(l, r), way = find(l, r);
                if (maxx > a[pos - k]) {
                    if (max(rmq(l, way - 1), rmq(way + 1, r)) > a[pos - k]) {
                        ans += 0;
                        pd = true;
                    }
                    else if (rmq(l, way - 1) > rmq(way + 1, r)) {
                        ans += 0;
                        pd = true;
                    }
                    else {
                        ans++;
                        pd = true;
                    }
                }
            }
            if (!pd) {
                int l = pos - k + 1, r = pos, way = pos - k + 1;
                int L = l, R = r;
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (rmq(mid + 1, R) > rmq(L, mid - 1)) way = max(way, mid), l = mid + 1;
                    else r = mid - 1;
                }
                ans += way - L + 1;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：forgotmyhandle (赞：0)

[洛谷传送门](https://www.luogu.com.cn/problem/P10100)

## 分析

发现最大值是特殊的，在最大值左边的东西会先把左边扩展完，然后挨个扩展右边。右边的同理。

于是可以考虑启发式分治，每次根据最大值递归，并考虑两边互相以及当前分治中心的贡献。

两边互相的贡献是容易统计的，右边的所有起始位置会向位置在左边的、满足特定条件的所有询问产生贡献。特定条件指的是 $k + p = C$ 或 $k - p = C$。左边向右边同理。

然后考虑当前分治中心对区间内所有询问的贡献。我们考虑枚举左右之中短的一边，则每次形如先走这一边的一个数，然后扩展另外一边的一段，然后再走这一边的一个数，以此类推。对于枚举的一边，由于是一个一个走过去的，所以可以知道走到每个位置的时间。因此这部分贡献是容易计算的，随便拿个什么东西记录即可。而对于位于另外一边的询问，我们考虑在每次扩展一段区间的时候向扩展的这一段区间产生贡献。则这里也相当于对位置在一段区间内的、满足 $k + p = C$ 或 $k - p = C$ 的所有询问产生贡献。所有贡献离线下来按横坐标升序枚举，过程中数组维护每个位置的值即可。注意加和减的限制要分开统计。


## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <cassert>
#include <map>
using namespace std;
int n, q;
int a[100005];
pair<int, int> mx[17][100005];
int lg2[100005];
int Qmax(int l, int r, int t) {
    assert(r >= l);
    int k = lg2[r - l + 1];
    pair<int, int> tmp = max(mx[k][l], mx[k][r - (1 << k) + 1]);
    return t ? tmp.second : tmp.first;
}
int p[100005], k[100005];
struct qquery {
    int x, y, v, id;
} qs1[500005], qs2[500005];
int ASDF[400005];
int ans[100005];
int *val = &ASDF[200002];
int qcnt1, qcnt2;
map<int, int> mp[100005];
void Solve(int l, int r) {
    if (l > r) 
        return;
    int x = Qmax(l, r, 1);
    if (x != r) {
        int a = r - x;
        qs1[++qcnt1] = (qquery) { l, a + x + 1, a, 0 };
        qs1[++qcnt1] = (qquery) { x + 1, a + x + 1, -a, 0 };
    }
    if (x != l) {
        int a = x - l;
        qs2[++qcnt2] = (qquery) { x, a - x + 1, a, 0 };
        qs2[++qcnt2] = (qquery) { r + 1, a - x + 1, -a, 0 };
    }
    if (r - x <= x - l) {
        for (int i = x, cur = 1, cl = x; i <= r; i++) {
            ++mp[i][cur];
            int ll = l, rr = cl - 1, mid, ans = cl;
            while (ll <= rr) {
                mid = (ll + rr) >> 1;
                if (Qmax(mid, cl - 1, 0) < a[i + 1]) 
                    ans = mid, rr = mid - 1;
                else 
                    ll = mid + 1;
            }
            if (ans != cl) {
                qs1[++qcnt1] = (qquery) { ans, cur + cl, 1, 0 };
                qs1[++qcnt1] = (qquery) { cl, cur + cl, -1, 0 };
            }
            cur += (cl - ans), cl = ans;
            ++cur;
        }
    } else {
        for (int i = x, cur = 1, cr = x; i >= l; i--) {
            ++mp[i][cur];
            int ll = cr + 1, rr = r, mid, ans = cr;
            while (ll <= rr) {
                mid = (ll + rr) >> 1;
                if (Qmax(cr + 1, mid, 0) < a[i - 1]) 
                    ans = mid, ll = mid + 1;
                else 
                    rr = mid - 1;
            }
            if (ans != cr) {
                qs2[++qcnt2] = (qquery) { cr + 1, cur - cr, 1, 0 };
                qs2[++qcnt2] = (qquery) { ans + 1, cur - cr, -1, 0 };
            }
            cur += (ans - cr), cr = ans;
            ++cur;
        }
    }
    Solve(l, x - 1);
    Solve(x + 1, r);
}
signed main() {
    cin >> n >> q;
    a[0] = a[n + 1] = 2147483647;
    lg2[0] = -1;
    for (int i = 1; i <= n; i++) cin >> a[i], mx[0][i] = make_pair(a[i], i), lg2[i] = lg2[i - 1] + ((i & (i - 1)) == 0);
    for (int i = 1; (1 << i) <= n; i++) {
        for (int j = 1; j + (1 << i) - 1 <= n; j++) 
            mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << (i - 1))]);
    }
    Solve(1, n);
    for (int i = 1; i <= q; i++) {
        cin >> p[i] >> k[i];
        qs1[++qcnt1] = (qquery) { p[i], k[i] + p[i], 0, i };
        qs2[++qcnt2] = (qquery) { p[i], k[i] - p[i], 0, i };
    }
    sort(qs1 + 1, qs1 + qcnt1 + 1, [](qquery a, qquery b) { return a.x == b.x ? (a.id < b.id) : (a.x < b.x); });
    for (int i = 1; i <= qcnt1; i++) {
        if (qs1[i].id) 
            ans[qs1[i].id] += val[qs1[i].y];
        else 
            val[qs1[i].y] += qs1[i].v;
    }

    memset(ASDF, 0, sizeof ASDF);
    sort(qs2 + 1, qs2 + qcnt2 + 1, [](qquery a, qquery b) { return a.x == b.x ? (a.id < b.id) : (a.x < b.x); });
    for (int i = 1; i <= qcnt2; i++) {
        if (qs2[i].id) 
            ans[qs2[i].id] += val[qs2[i].y];
        else 
            val[qs2[i].y] += qs2[i].v;
    }
    for (int i = 1; i <= q; i++) cout << ans[i] + mp[p[i]][k[i]] << "\n";
    return 0;
}
```

好像也可以不用这么麻烦来着的。但我反正也不会更简单的做法。

---


# [DTCPC 2024] 小方的疑惑 10

## 题目背景

小方一直有很多疑惑。

## 题目描述

小 C 在几年前的生日那天收到了一个礼物：一个长度为 $n$ 的只包含 $\text{(}$ 和 $\text{)}$ 的字符串，其中恰好有 $k$ 个子串为合法的括号序列。

由于小方很疑惑这个礼物长什么样，所以你要构造一个这样的字符串，或者输出 $-1$ 表示无解。

合法的括号序列满足以下条件：

- $\text{()}$ 是合法的括号序列。
- 若 $\text{A}$ 和 $\text{B}$ 是合法的括号序列，则 $\text{(A)}$ 和 $\text{AB}$ 是合法的括号序列。
- 其它序列均不是合法的括号序列。

小方有很多疑惑，所以他会询问你 $T$ 次。

## 样例 #1

### 输入

```
3
5 2
5 3
5 4
```

### 输出

```
(())(
()()(
-1```

# 题解

## 作者：Mr_Az (赞：6)

## Question 问题 [P10161 [DTCPC 2024] 小方的疑惑 10](https://www.luogu.com.cn/problem/P10161)

要求构造一个长度为 $n$ 的括号字符串，其中 $k$ 个子串为合法的括号序列。无法构造输出 $-1$。

## Analysis 分析

手玩一下可以发现最优情况有以下两种情况：

1. `()()...()` 如果有 $x$ 对括号，则有 $\frac{x(x+1)}{2}$ 个字串为合法的括号序列。
2. `(()()...())` 相当于在 $1$ 情况外边加一层，多出一个合法字串，并且让当前括号对数变为 $1$ 对。

以下令 $s(x)=\frac{x(x+1)}{2}$。

## Solution 构造

我们可以通过这样构造类似 $\texttt{\color{red}{(\color{blue}(\color{black}()()()\color{blue})()()\color{red})()()()}}$ 这样的括号序列，用颜色标记出来了。计算的话分三层分别是最里面的 $3$ 对，中间的 $2+1$ 对，最外层 $3+1$ 对（$+1$ 的原因是第 $2$ 种情况会使括号对变为 $1$，要加上）。最终总共的合法字串数为： $s(3)+s(3)+s(4)=22$ 对。

也就是说，我们相当于把这个构造的字符串分为 $m$ 层，每层填 $a_i$ 对括号，则总的合法括号字串数为 $\displaystyle \sum_{i=1}^{m} s(a_i)$ 。

其实这个问题相当于**完全背包**。

背包容量为 $k$，每个货物（也就是每一层填入的括号组数）的体积是 $s(x)$ ，价值是 $x$，每一件可以无限选。问填满背包的**最小**价值。

跑一遍完全背包，记录一下转移的路径，输出即可。无解即为最小值比 $n$ 大。

## Specific 细节

1. 如果有剩余的部分全部输出 `'('` 。
2. 除第一层外的每一层都有多一对括号对，输出时要注意
3. 输出答案我使用了一个抽象方法，详见代码。
4. 贪心找最大的 $s(x)$ 去填可以被卡，数据如下（但好像很少可以被卡掉）。

**input**

```
28 54
```

**output**

```
((()()()()()()()()())()())()
```

## Code 代码

```cpp
int T,n,m; 
int v[N],w[N],f[N],turn[N];
signed main(){
	read(T);
	for(rint i=1;i<=N-8;i++) w[i]=-(2*i),v[i]=(i+1)*i/2;//预处理货物的体积和价值
	for(rint i=1;i<=N-8;i++) f[i]=-inf; 
	for(rint i=1;i<=N-8;i++){
	    for(rint j=v[i];j<=N-8;j++){
		   	if(f[j]<f[j-v[i]]+w[i]) turn[j]=i/*记录转移路径*/,f[j]=f[j-v[i]]+w[i];
		}
	}//完全背包
	while(T--){
		read(n,m);
		if(-f[m]>n) puts("-1");
		else{
			//细节3：神奇输出方式
			//构造一个长度为两倍的字符串，记录左端点 l 和右端点 r，两个都在中间
			//这样就可以一边填括号，一边在外边套一层括号
			//最后输出 [l,r] 里的字符串 
			char s[200008]="";int l=100000,r=100000,now=m;
			for(rint i=turn[now];i;i=turn[now]){//沿着记录的路径倒推 
				for(rint j=1;j<=i-(now!=m)/*细节2*/;j++) s[r]='(',s[r+1]=')',r+=2;//往右填括号对 例：()()
				l--;s[l]='(';s[r]=')';r++;//外面包一层 例：(()())
				now=now-v[turn[now]];//沿着记录的路径倒推 
			}
			l++;r-=2;//会多包一层，删掉 
			for(rint i=l;i<=r;i++) putchar(s[i]);
			for(rint i=r-l+1;i<n;i++) putchar('(');puts("");//细节1：补充剩余的左括号 例：(()())(((( 
		}
	} 
	return 0;
}

```

## Proof 补充证明

为何如上的构造是消耗最小括号的构造方案？其实任意一种括号序列都可以转化为其上的方案。任意一种括号序列可以看作合法括号序列 $a_i$ 和非法括号序列 $b_i$ 相交织（$a_i$ 和 $b_i$ 可以是 $0$），也就是如下形式：

$$ 
b_1a_1b_2a_2...a_{m-1}b_m
$$

**Step 1** 扔掉最两边的 $b_1$ 和 $b_m$，不影响结果。转化后为：$a_1b_2a_2...a_{m-1}$

**Step 2** 我们发现每两个合法括号序列之间必有一非法括号序列相隔，我们可以把 $a_1$ 塞入 $a_2$ 的第一个括号里，然后把 $b_2$ 扔掉，合法字串数显然不变而消耗的括号减少了 $b_2$ 个。以此类推，把 $a_2$ 塞入 $a_3$，扔掉 $b_3$ 一直到 $a_{m-2}$ 塞入 $a_{m-1}$ 扔掉 $b_{m-1}$。最后出来的即为我们以上构造的方案。而长度较原先减少了 $\sum_{i=1}^m b_i$ 个括号，故为最短的构造方案。

模拟一下

原括号序列 $\texttt{)))(()()()(((()())(()()(((}$

**Step 1** $\texttt{)))( \color{#00BA00}()()() \color{black}(( \color{blue}(()())() \color{black}( \color{red}()() \color{black}(((}$

$~~~~~~~~~~\texttt{\color{#00BA00}()()() \color{black}(( \color{blue}(()())() \color{black}( \color{red}()()}$
      
**Step 2** $\texttt{\color{blue}((\color{#00BA00}()()()\color{blue})())() \color{black}( \color{red}()()}$

$~~~~~~~~~~\texttt{\color{red}(\color{blue}((\color{#00BA00}()()()\color{blue})())()\color{red})()}$
     
## 题外话

直接用 `string` 输出好像也没事？

---

## 作者：jr_inf (赞：4)

## 统计
首先考虑如何统计子串为合法括号序列的个数。假设我们构造了一个非常友好，没有任何一个无法匹配的括号的串，那么每对括号会且仅会和同层的括号产生贡献（匹配）。

举个例子：$\texttt{()()(())(())}$

它的答案为 $\frac{3\times4}{2}+2\times \frac{1\times2}{2}=6+2\times2=10$。怎么计算的？最外层的四个括号和两个内层的括号的贡献之和。

## 构造
- 此部分提到的 $n,k$ 与题意相同，且都是对于串的。

考虑用一种比例子更简单的构造方法来构造串。比如这个串：$\texttt{()()()((()))}$，它的答案（即合法序列数）和长度与例子都一样，但是**所有下一层的括号都在上一层的最后一对括号内**，明显好构造了许多。事实上，所有其它方案都可以用这种方式，在 $n,k$ 相同的情况下表示出来，因为不同括号对内的括号对互不影响，不同层的也是。

所以在上述的构造方法下，只需要知道**每层的括号对数量**，就可以知道这个串 $n,k$ 的值，并且一定可以构造出来。

设串的层数为 $m$，每层的括号对数量为 $a_1,a_2,\dots,a_m$，那么 $n=2\sum_{i=1}^m a_i,k=\sum_{i=1}^m \frac{a_i\times(a_i+1)}{2}$。为了防止误判，在 $k$ 相同时，我们要让 $n$ 尽量小，所以使用dp。

## 状态设计

- 此部分的 $n,k$ 与题意相同，为输入内容。

设 $dp_i$ 为当串的答案 $i$ 时串长的最小值，$p_i=\frac{i\times(i+1)}{2}$。易得 $dp_i=max_{j=1}^{p_j \leq i}dp_{i-p_j}+2j$，转移时记录路径即可求出 $a$，进而构造出串。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define mst(x,y) memset(x,y,sizeof(x))
#define int long long
using namespace std;
const int N=1e6+10;
int t,n,k,a[N],dp[N],lst[N];
void dfs(int x)
{
	if(!x)return;
	for(int i=1;i<lst[x];i++)putchar('('),putchar(')');
	putchar('(');
	dfs(x-a[lst[x]]);
	putchar(')');
}
signed main()
{
	mst(dp,127);
	dp[0]=0;
	for(int i=1;i<=1000;i++)a[i]=i*(i+1)/2;
	for(int i=1;i<=100000;i++)
	{
		for(int j=1;a[j]<=i;j++)
		{
			if(dp[i-a[j]]+j*2<dp[i])
			{
				dp[i]=dp[i-a[j]]+j*2,lst[i]=j;
			}
		}
	}
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld",&n,&k);
		if(dp[k]>n)puts("-1");
		else
		{
			dfs(k);
			for(int i=dp[k]+1;i<=n;i++)putchar('(');
			putchar('\n');
		}
	}
}
```


---

## 作者：Register_int (赞：4)

首 A 来报道了。（

首先我们考虑来刻画合法子串的个数。比较显然的一点是，设串 $s$ 有 $k$ 对括号在最外层，那么只在最外层选的合法子串个数为 $\binom{k+1}2$。这一点告诉我们，$k$ 在括号序列中被表示成了一些三角形数的形式。假设我们已经将 $k$ 拆开了，那么可以采取以下方法构造：

![](https://cdn.luogu.com.cn/upload/image_hosting/3bmpqjil.png)

这样可以在不浪费多余括号的情况下将几个括号串分层，从而区分开贡献。后面黑色的括号用于补足空位。

设 $dp_i$ 为构造出 $i$ 个子串所需的最小括号对数，那么有：

$$dp_i\to\min(dp_i,dp_{i-\binom{j+1}2}+j)$$

这部分可以预处理出来。若 $2dp_k>n$ 则说明无解，否则在 dp 数组上递归构造即可。时间复杂度 $O(n\sqrt n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

int dp[MAXN];

inline 
void init(int n) {
	*dp = 0;
	for (int i = 1; i <= n; i++) {
		dp[i] = 1e9;
		for (int j = 1; (ll)j * (j + 1) / 2 <= i; j++) {
			dp[i] = min(dp[i], dp[i - j * (j + 1) / 2] + j);
		}
	}
}

void print(int n) {
	if (!n) return ;
	int k = 0;
	for (int i = 1; (ll)i * (i + 1) / 2 <= n; i++) {
		if (dp[n - i * (i + 1) / 2] + i == dp[n]) { k = i; break; }
	}
	for (int i = 1; i < k; i++) printf("()");
	putchar('('), print(n - k * (k + 1) / 2), putchar(')');
}

int T, n, m;

int main() {
	for (scanf("%d", &T), init(1e5); T--;) {
		scanf("%d%d", &n, &m);
		if (dp[m] * 2 > n) { puts("-1"); continue; }
		print(m); for (int i = dp[m] * 2 + 1; i <= n; i++) putchar('('); puts("");
	}
}
```

---

## 作者：jiangxinyang2012 (赞：3)

考虑这样一个字符串如何计算它有多少个子串为合法的括号序列：

```
()(()()())((()))
```

答案为 $\frac{3 \times 4}{2} + \frac{3 \times 4}{2} + \frac{1 \times 2}{2} + \frac{1 \times 2}{2} = 14$。

这个时候，我们意识到一个重要结论：只有不在括号内或者在同一个括号内的括号，才能组合计算贡献。假设有 $n$ 个括号能组合计算贡献，它的贡献是 $\frac{n \times n+1}{2}$。

这很好理解，比如：
```
(()()())
```
中间的三对括号被包围在最外面的括号当中，它们三个的贡献之和为 $\frac{3 \times 2}{2} = 3$。

最外层的括号没有在任何括号内部，所以它的贡献就是 $\frac{1 \times 2}{2} = 1$。

知道了这个以后，直接和其他题解一样 dp 之后构造就好了，如果长度不够的话，直接在后面加右括号，显然不会对答案产生任何影响。

---

## 作者：lcfollower (赞：2)

好题，我不会，竟然是背包思想的 DP。

:::info[一个括号序列里的合法括号序列个数怎么算？]{open}

如果有 $x$ 对括号并列，比如 $\texttt{()()()()}$ 时 $x = 4$，那么有多少个合法的括号序列？

容易发现答案为 $4 + 3 + 2 + 1 = 10$，推广到 $x\in \mathbb{N^*}$，合法的括号序列个数即为 $\frac{x(x+1)}{2}$。

再考虑如果有括号嵌套，先来一种简单的：$\texttt{(()()()())}$，此时里面有 $x = 4$ 个括号并列，外层有 $1$ 个括号包裹，容易发现答案数量为 $10 + 1 = 11$，这个 $1$ 是整个括号序列，稍微手玩一下就会发现**不存在**任何前缀或者后缀（**除了整个括号序列**）使得组成的括号序列**合法**（左括号与右括号个数不等），这些真前缀和真后缀都是比 $\texttt{()()()()}$ 多出来的括号序列，所以可以直接证明。容易推广合法括号序列个数为 $\frac{x(x+1)}{2} + 1$，其中 $1$ 也可以写作 $\frac{1\times 2}{2}$。

然后还有 $\texttt{(()()()())()()()}$，容易发现是上面这种情况的推广，但是我们换一种角度，这是由 $x = 4$ 个“大”括号组成，其中一个“大”括号里面有  $y = 4$ 个小括号并列，同样可以计算多出来的合法括号序列个数，还是同上，可以发现总个数为 $20$（具体省略），容易推广个数为 $\frac{x(x+1)}{2} + \frac{y(y+1)}{2}$。

最后我们将上述的情况混合，比如 $\color{red}{(}\color{blue}{()()()()}\color{red}{)(}\color{green}{()()()}\color{red}{)}\color{purple}{()()()}$，可以发现合法的括号序列个数为红、蓝、绿、紫三种颜色的括号并列，它们的答案（就是 $\frac{x(x+1)}{2}$）之和。

:::

这样就很明确了，我们设 $a_i$ 为 $i$ 个括号并列时的合法括号序列个数（即 $\frac{i(i+1)}{2}$）。接着我们设 $f_i$ 为**恰好**存在 $i$ 个合法的括号序列的**最短**序列长度，初始化 $f_0 = 0$，$f_i = +\infty$（$1\le i\le 10^5$）。则转移如下：

$$f_i = \min\limits_{a_j\le i} f_{i - a_j} + 2\times j$$

我们发现这是一个背包模型，因此我们可以用背包的转移方式。

设我们需要预处理 $a$ 的长度为 $x$，因为 $\frac{x(x+1)}{2}\le 10^5$（不然肯定没有意义），因此得到 $x$ 的范围为 $2\times \sqrt{10^5}$ 左右，这样转移是 $\mathcal O(V\sqrt{V})$，其中 $V = 10^5$，不会超时。

然后对于询问 $(n ,k)$，如果 $f_k > n$ 则一定无解。

否则考虑怎么输出一个合法的括号序列，我们用 $lst_i$ 表示有 $i$ 个合法的括号序列，**最少**需要几对并列的括号。

在输出方案数的时候，我们用递归的形式输出，我们可以在**第一个括号**里面摆上剩下的括号，然后第 $2\sim lst_k$ 个括号里面不加东西，因为答案是和的形式嘛。

最后如果发现有多余长度**没有摆上任何括号**，剩下的我们直接输出 `(` 即可，这样构不成任何合法的括号序列。

分析到这应该明白为啥要最少了，这里留给读者自己思考。


:::info[代码]
```cpp
inline void print (int k){
    if (!k) return;//没有了就别输出了。
    putchar ('(');//第一个 () 的左括号，要在后面输出一点东西。
    print (k - a[lst[k]]);//剩下的括号递归输出。
    putchar (')');//第一个 () 的右括号，包裹起来。
    up (i ,2 ,lst[k]) putchar ('(') ,putchar (')');//余下的直接输出 ()()()...() 即可。
} inline void solve (){
    n = read () ,k = read ();
    if (f[k] > n) {puts ("-1") ; return ;}//无解。
    print (k);
    up (i ,f[k] + 1 ,n) putchar ('(');//存在剩余括号，全输出 ( 即可。
    puts ("");
} signed main() {
    up (i ,1 ,1e5) {
        if (i * (i + 1) / 2 <= 1e5) a[++ cnt] = i * (i + 1) / 2;//预处理所有可能的长度。
        else break;
    }
    memset (f ,0x3f ,sizeof f);
    f[0] = 0;//初始化。
    up (i ,1 ,cnt)//进行背包模型的转移。
        up (j ,a[i] ,1e5)
            if (f[j] > f[j - a[i]] + 2 * i) {
                f[j] = f[j - a[i]] + 2 * i ,lst[j] = i;//顺便记录 lst。
            }
    int T = read ();
    while (T --) solve ();
    return 0;
}
```
:::

---

## 作者：Night_sea_64 (赞：1)

第一次赛时切蓝题！

毫无疑问在长度相同时，$\texttt{()()}\cdots\texttt{()}$ 这样的形式，是括号序列的子串个数最多。设有 $m$ 个 $\texttt{()}$ 排成一排，是括号序列的子串个数为 $\dfrac{m(m+1)}2$。

并且当 $s$ 中的某个 $\texttt{()}$ 中插入一个括号序列 $t$ 时，$s$ 的答案会增加上 $t$ 的答案。

考虑一个 dp：$f_j$ 表示 $j$ 个子串为括号序列的最小长度。dp 时枚举当前使用的是几个 $\texttt{()}$ 排成一排，将其放入之前的一个 $\texttt{()}$ 中。这是一个完全背包。

因为长度不可能超过 $10^5$，所以完全背包的“物品”数量大约在 $\sqrt{10^5}$ 的级别。所以这个 dp 可以通过。

回答问题时，如果 $f_k>n$ 输出 $-1$，否则构造一种长度为 $f_k$ 的方案，后面再全部输出 `(` 即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,k,a[510],cur,f[100010],last[100010];
//f[j] 表示 j 个子串为括号序列的最小长度
void output(int x)
{
    if(!x)return;
    cout<<'(';
    output(x-a[last[x]]);
    cout<<')';
    for(int i=2;i<=last[x];i++)cout<<"()";
}
int main()
{
    scanf("%d",&t);
    for(int i=1;i<=1e5;i++)
    {
        a[++cur]=i*(i+1)/2;
        if(a[i]>1e5)break;
    }
    memset(f,999999,sizeof(f));
    f[0]=0;
    for(int i=1;i<=cur;i++)
        for(int j=a[i];j<=1e5;j++)
            if(f[j-a[i]]+2*i<f[j])
                f[j]=f[j-a[i]]+2*i,last[j]=i;
    while(t--)
    {
        scanf("%d%d",&n,&k);
        if(f[k]>n)
        {
            cout<<-1<<endl;
            continue;
        }
        output(k);
        for(int i=f[k]+1;i<=n;i++)cout<<'(';
        cout<<endl;
    }
    return 0;
}
```

Upd：修正了一处错误。

---

## 作者：yimuhua (赞：1)

首先发现连续 $n$ 个匹配括号可以得到 $\dfrac{n\times (n+1)}{2}$ 个合法子串。

因为 CF1928E 的惨痛教训，考虑 $dp$。设 $dp_i$ 表示构造 $i$ 个合法子串的最短长度，那么 $dp_i=\min_{j=1}^{\frac{j\times (j+1)}{2}\leq i}dp_{i-\frac{j\times (j+1)}{2}}+j$。

预处理出 $dp_k$，然后递归回答询问，若 $dp_i$ 由 $dp_j$ 转移过来，那么递归得到 $dp_j$ 的答案串，放在 $dp_i$ 连续括号的最后一个的里层。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, k, dp[100005];
void calc(int x) {
	if(!x)
		return;
	int p = 0;
	for(int i = 1; 1ll * i * (i + 1) / 2 <= x; i++)
		if(dp[x - i * (i + 1) / 2] + i == dp[x]) {
			p = i;
			break;
		}
	for(int i = 1; i < p; i++)
		cout << "()";
	cout << '(', calc(x - p * (p + 1) / 2), cout << ')';
	return;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> t, memset(dp, 0x3f, sizeof(dp)), dp[0] = 0;
	for(int i = 1; i < 100001; i++)
		for(int j = 1; 1ll * j * (j + 1) / 2 <= i; j++)
			dp[i] = min(dp[i], dp[i - j * (j + 1) / 2] + j);
	while(t--) {
		cin >> n >> k;
		if(dp[k] * 2 > n)
			cout << "-1\n";
		else {
			calc(k);
			for(int i = 2 * dp[k] + 1; i <= n; i++)
				cout << '(';
			cout << '\n';
		}
	}
	return 0;
}
```

---

## 作者：redfull66 (赞：0)

**[题目链接](https://www.luogu.com.cn/problem/P10161)**

设 $ S =\texttt{()()()} \dots \texttt{()()()}$
（由 $n$ 个 $\texttt{()}$ 组成），则有
 $\dfrac{n(n+1)}{2}$ 个子串为合法的括号序列。

注意到有两种构造字符串方式。

1. $S \texttt{()}$ 则由 $n+1$ 个 $\texttt{()}$ 组成，增加 $n+1$ 个合法字串。

2. $\texttt{(} S \texttt{)}$ 比 $S$ 多出一个合法字串，并将此视作 $\texttt{()}$。

考虑 dp（完全背包）。

预处理出每个货物（字符串括号组数）与价值（合法字串的总数），记录一下下一个货物的路径即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,a[1005],dp[100005],nxt[100005];
int read(int ans=0,char c=0){
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans;
}
void dfs(int step){
	if(step){
		for(int i=1;i<nxt[step];i++)putchar('('),putchar(')');
		putchar('('),dfs(step-a[nxt[step]]),putchar(')');
	}
}
int main(){
	memset(dp,0x3f3f3f,sizeof(dp)),dp[0]=0;
	for(int i=1;i<=1000;i++)a[i]=i*(i+1)/2;
	for(int i=1;i<=100000;i++)
	    for(int j=1;a[j]<=i;j++)
	        if(dp[i-a[j]]+2*j<dp[i])
	            dp[i]=dp[i-a[j]]+2*j,nxt[i]=j;
	T=read();         
	while(T--){
		n=read(),k=read();
		if(dp[k]>n)putchar('-'),putchar('1');
		else dfs(k);
		for(int i=dp[k]+1;i<=n;i++)putchar('(');
		putchar('\n');
	}
	return 0;
}

```

---

## 作者：I_will_AKIOI (赞：0)

这把月赛后面全在搞这题，贪心假了于是寄了，今天又看到这题，把贪心改为 dp 就过了，故写题解纪念。

首先注意到括号有两种连接方式。

+ 括号套括号：$\texttt{(())}$。

+ 括号连括号：$\texttt{()()}$。

方案一的合法括号序列数就是括号的层数。方案二设括号数为 $x$，根据组合数，得出合法括号序列数为 $\displaystyle\frac{x(x+1)}{2}$。

所以我们尝试选择一些方案二，并用方案一把他们套起来，假设括号有 $cnt$ 层，每层有 $a_i$ 对括号，那么答案为 $\displaystyle\sum_{i=1}^{cnt}\frac{a_i(a_i+1)}{2}$。

因此我们就是要找到一组 $a_i$，使得 $\displaystyle\sum_{i=1}^{cnt}\frac{a_i(a_i+1)}{2}=k$，且 $\displaystyle\sum_{i=1}^{cnt}a_i$ 最小，考虑 dp。设 $f_i$ 表示凑出答案 $i$ 最少需要的括号数，由于 $a_i$ 不要求互不相同，所以可以无限取，也就是完全背包。物品有 $i$ 个，第 $i$ 个物品空间为 $2i$，价值为 $\displaystyle\frac{i(i+1)}{2}$，跑一遍之后记录 $last_i$ 表示 $i$ 是由谁转移的，然后一直倒推就可以求出 $a_i$。这个完全背包不用担心超时，因为第 $i$ 个物品的价值是 $i^2$ 级别的，因此只有 $\sqrt{k}$ 个物品能被真正使用，时间复杂度是 $O(n\sqrt{k})$。

最后就到了输出阶段，如果 $f_k>n$ 那肯定无解，否则我们考虑使用 dfs 来解决，记录一个参数 $k$ 表示处理到了 $a_k$。如果 $k<cnt$ 就继续递归，在递归前输出一个左括号，递归后输出右括号用于分隔，最后在 dfs 末尾输出 $a_k$ 对括号，但是如果 $n>f_k$ 就会剩下一些括号没有使用，这个时候在答案末尾再输出一些右括号用于补位。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int t,n,m,f[N],a[N],b[N],last[N];
string res;
vector<int>v;
void dfs(int k)//dfs输出
{
  res+="(";
  if(k<v.size()-1) dfs(k+1);
  res+=')';
  for(int i=1;i<v[k];i++) res+="()";
  return;
}
void solve()
{
  cin>>n>>m;
  if(f[m]>n)//
  {
    cout<<-1<<"\n";
    return;
  }
  res="";
  v.clear();
  while(m)//不断往前跳求出ai
  {
    v.push_back(last[m]);
    m-=a[last[m]];
  }
  dfs(0);
  cout<<res;
  for(int i=1;i<=n-(int)res.size();i++) cout<<'(';//输出多余括号
  cout<<"\n";
  return;
}
signed main()
{
  ios::sync_with_stdio(0);
  for(int i=1;i<=100000;i++) a[i]=i*(i+1)/2,b[i]=i*2,f[i]=1e18;
  for(int i=1;i<=100000;i++)//完全背包求方案
    for(int j=a[i];j<=100000;j++)
      if(f[j-a[i]]+b[i]<f[j])
        last[j]=i,f[j]=f[j-a[i]]+b[i];
  int t;
  cin>>t;
  while(t--) solve();
  return 0;
}
```

---

## 作者：DerrickLo (赞：0)

我们定义对于一个合法的括号序列，第一层指不被任何括号所包含的所有括号，第二层指恰好被一个括号所包含的括号，以此类推。

例如 $\texttt{(())}$ 外面的括号就是第一层，里面的括号就是第二层。

我们考虑括号总数如何计算，容易想到不同层的括号是独立的，所以我们只需要把每一层的括号分别计算答案，然后加起来就是括号总数了。

显然括号放在一起会比分开放总数更大，假设现在某一层有 $i$ 个括号，那么这一层的括号总数就是 $\displaystyle{\frac{i\times(i+1)}{2}}$。

那么我们就可以先用 `dp` 预处理出每对于每个 $k$，一共需要最少多少对括号，我们可以得到转移方程：

$$dp_k=\min_{j}dp_{i-{\frac{j\times (j+1)}{2}}}+j$$

然后对于每次询问，若 $2\times dp_k>n$ 则无解，反之则可以将 `dp` 过程逆过来构造出解，剩余的地方用 $\texttt{(}$ 填充即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,k,dp[100005],a[100005],cnt;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	memset(dp,0x3f,sizeof dp);
	dp[0]=0;
	for(int i=1;i<=100000;i++){
		for(int j=1;j*(j+1)/2<=i;j++)dp[i]=min(dp[i],dp[i-j*(j+1)/2]+j);
	}
	while(t--){
		cin>>n>>k,cnt=0;
		if(dp[k]*2>n){
			cout<<"-1\n";
			continue;
		}
		int now=k;
		while(now){
			for(int j=1;j*(j+1)/2<=k;j++)if(dp[now]==dp[now-j*(j+1)/2]+j){
				a[++cnt]=j;
				now-=j*(j+1)/2;
				break;
			}
		}
		for(int i=1;i<=cnt;i++)cout<<"(";
		for(int i=1;i<=cnt;i++){
			cout<<")";
			for(int j=1;j<a[i];j++)cout<<"()";
		}
		for(int i=1;i<=n-dp[k]*2;i++)cout<<"(";
		cout<<"\n";
	}
}
```

---


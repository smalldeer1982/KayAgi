# [DTCPC 2024] 平方树

## 题目描述

给你一个森林，每条边有一个方向。

你可以进行两种操作：

- 新增一个点。

- 将两个点之间连一条有向边。

你要使得最后将所有有向边看成无向边后，图形成一棵树，且每个点的出度都是平方数。

给出一种新增点数最少的方案。

## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
2 2
1 4
1 5```

# 题解

## 作者：chenzhiyuAndy (赞：1)

# 题目大意

>  给定 $n$ 个点 $m$ 条边的有向图，满足边看成无向边后图是森林，增加若干点和有向边，使得每个点出度都是完全平方数，且边看成无向边后图是一棵树。（$1 \le m < n \le 10^5$）

# 思路

首先考虑使森林联通，定义一个合法的连通块是其中没有出度不为平方数的点的连通块。随便找一个连通块 $p$，对于所有不合法的连通块，在其中找到一个不合法点向 $p$ 连接，这样显然更优，因为可能可以消除一些不合法点。然后最多剩下一个不合法连通块，现在要将它与其他合法连通块合并。若有一个不合法连通块，从其中的不合法点向其余连通块连边；若一开始就没有或在合并过程中所有连通块都变得合法，可以发现每个连通块都有一个出度为 $0$ 的点（因为没有就构成了环）从该点向其他连通块连边。这样的话便只剩下一个连通块，新建点使其合法即可。

# 代码

你觉得我会这么良心吗？本来不想贴的。但是...
![](https://cdn.luogu.com.cn/upload/image_hosting/vj3px86p.png)所以为了估值...
![](https://cdn.luogu.com.cn/upload/image_hosting/24ihq6vu.png)

---

## 作者：yimuhua (赞：1)

首先考虑使森林联通，定义一个合法的连通块是其中没有出度不为平方数的点的连通块。随便找到一个连通块，设为 $p$，对于所有不合法的连通块，在其中找到一个不合法点向 $p$ 连接，这样显然优，因为可能可以消除一些不合法点。

然后至多剩下一个不合法连通块，现在要将其与其他合法连通块合并。

若有一个不合法连通块，从其中的不合法点向其余连通块连边；

若一开始就没有或在合并过程中所有连通块都变得合法，可以发现每个连通块都有一个出度为 $0$ 的点（因为如果没有就说明构成了环）从这个点向其他连通块连边。

此时只剩下一个连通块，新建点使其合法即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
	int x, y;
}a[100005];
bool vis[100005];
vector<node> ans;
vector<int> b, v[100005];
int n, m, p, res, d[100005], fa[100005];
int f(int x) {
	if(!x)
		return 0;
	int y = sqrt(x);
	while(y * y < x)
		y++;
	return y * y;
}
int find(int x) {
	if(fa[x] == x)
		return x;
	return fa[x] = find(fa[x]);
}
void merge(int x, int y) {
	if((x = find(x)) ^ (y = find(y))) {
		if(v[x].size() > v[y].size())
			swap(x, y);
		vis[fa[x] = y] |= vis[x];
		for(int i : v[x])
			v[y].push_back(i);
		v[x].clear();
	}
	return;
}
void add(int x, int y) {
	d[x]++, ans.push_back({x, y});
	return;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
		cin >> a[i].x >> a[i].y, d[a[i].x]++;
	for(int i = 1; i <= n; i++)
		v[fa[i] = i].push_back(i), vis[i] = f(d[i]) != d[i];
	for(int i = 1; i <= m; i++)
		merge(a[i].x, a[i].y);
	p = find(1);
	for(int i = 1; i <= n; i++)
		if(p != i && find(i) == i && vis[i])
			for(int j : v[i])
				if(f(d[j]) ^ d[j]) {
					add(j, p), vis[i] = 0;
					for(int k : v[i])
						vis[i] |= f(d[k]) != d[k];
					merge(i, p);
					break;
				}
	if(vis[p = find(p)]) {
		int k;
		for(k = 0; k < v[p].size() && f(d[v[p][k]]) == d[v[p][k]]; k++);
		for(int i = 1; i <= n; i++)
			if(i != p && find(i) == i) {
				if(k < v[p].size())
					for(add(v[p][k], i); k < v[p].size() && f(d[v[p][k]]) == d[v[p][k]]; k++);
				else
					for(int j : v[i])
						if(!d[j]) {
							add(j, p);
							break;
						}
			}
	}
	for(int i = 1; i <= n; i++)
		if(find(i) == i && vis[i])
			for(int j = 1; j <= n; j++)
				if(i != j && find(j) == j)
					merge(i, j);
	for(int i = 1; i <= n; i++)
		if(find(i) == i) {
			for(int j = 1; j <= n; j++)
				if(i != j && find(j) == j)
					for(int l : v[j])
						if(!d[l]) {
							add(l, i);
							break;
						}
			break;
		}
	for(int i = 1; i <= n; i++) {
		int x = f(d[i]);
		while(d[i] < x)
			add(i, n + ++res);
	}
	cout << res << ' ' << ans.size() << '\n';
	for(auto i : ans)
		cout << i.x << ' ' << i.y << '\n';
	return 0;
}
```

---

## 作者：CbrX (赞：1)

首先考虑要解决的两个事情：一个是使森林联通，也就是在连通块之间连边，另一个是使每个点出度是平方数。

设点 $u$ 的出度是 $d_u$，先分析森林本身就是一棵树的情况，显然这种情况下每次加边必须加点，$u\rightarrow v$ 后 $d_u\leftarrow d_u+1$ 。而使度数为平方数则需 $d_u$ 增加到 $\lceil \sqrt{d_u} \rceil^2$ 。 因此这种情况是简单的。

如果森林不是树，可以算出$y=x+n-m-1$ ，我们希望少增加点，也就是要将每个出度为非平方数的点尽量先连上已有的点。

我们可以先选择一个连通块使得每个点出度都为平方数（我们称之为合法的连通块）。如果没有则任意选择一个连通块，然后将所有不合法连通块选一个出度为非平方数的点连向这个被选中的连通块。这样就只剩至多一个不合法连通块，然后将这个不合法连通块直接连向合法连通块。

在此之前，每次连边都使一个出度非平方数的点度数 $+1$ ，所以连边数量最优。

这样就有两种情况，或者森林变成了一棵树，或者所有连通块都合法，前者就用树的做法，后者直接每个连通块选出一个度数为 $0$ 的点将它们串成一条链即可（显然每个连通块都有一个度数为 $0$ 的点）。

显然新增点数是较小的，因为 $x\le \sum{\lceil \sqrt{d_u} \rceil^2-d_u}\le \sum{2\sqrt{d_u}+1}\le \sum{2d_u+1}=3n$，所以时间复杂度为 $\mathcal{O}(n)$。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10163)

**题目大意**

> 给定 $n$ 个点 $m$ 条边的有向图，满足边看成无向边后图是森林，增加若干点和有向边，使得每个点出度都是完全平方数，且边看成无向边后图是一棵树。
>
> 数据范围：$n\le 10^5$。

**思路分析**

对每个点，计算出至少加多少出边后出度变成平方数，算出需要加的边数量总和 $k$，以及原图的联通块数 $c$。

如果 $k\ge c$，说明需要增加额外点和边，增加 $k-c+1$ 个额外点，然后每个点随便连一些出边即可。

具体构造的时候可以取出所有每个点都合法的连通块，每个点都连向其中的一个连通块，剩余的连通块每个点匹配一个即可。

如果 $k<c$，那么不需要增加额外点，我们用类似上面的构造把每个点的出度都调整成平方数，但图不一定联通。

注意到每个连通块中一定有出度为 $0$ 的点，将这些点连成链即可。

时间复杂度 $\mathcal O(n+m)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1.1e5+5,B=317;
int w[MAXN],d[MAXN],dsu[MAXN],id[MAXN];
bool typ[MAXN];
vector <int> P[MAXN];
int find(int x) { return x^dsu[x]?dsu[x]=find(dsu[x]):x; }
signed main() {
	for(int i=0,j=0;i<=B;++i) while(j<=i*i) w[j++]=i*i;
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i) dsu[i]=i;
	for(int i=1,u,v;i<=m;++i) cin>>u>>v,++d[u],dsu[find(u)]=find(v);
	int c=0,k=0;
	for(int i=1;i<=n;++i) c+=(dsu[i]==i),k+=w[d[i]]-d[i];
	if(!k&&c==1) return cout<<"0 0\n",0;
	if(k>=c) {
		cout<<k-c+1<<" "<<k<<"\n";
		for(int i=1;i<=n;++i) P[find(i)].push_back(i),typ[find(i)]|=(w[d[i]]>d[i]);
		vector <int> a,b;
		for(int i=1;i<=n;++i) if(dsu[i]==i) (typ[i]?a:b).push_back(i);
		for(int i=1;i<=k-c+1;++i) b.push_back(n+i);
		int o=1;
		for(int x:a) {
			bool f=0;
			for(int u:P[x]) if(w[d[u]]>d[u]) {
				int r=w[d[u]]-d[u];
				if(!f) cout<<u<<" "<<b[0]<<"\n",--r,f=1;
				while(r--) cout<<u<<" "<<b[o++]<<"\n";
			}
		}
	} else {
		cout<<"0 "<<c-1<<"\n";
		for(int i=1;i<=n;++i) P[find(i)].push_back(i),typ[find(i)]|=(w[d[i]]>d[i]);
		vector <int> a,b;
		for(int i=1;i<=n;++i) if(dsu[i]==i) (typ[i]?a:b).push_back(i);
		if(b.empty()) b.push_back(a.back()),a.pop_back();
		int o=1;
		for(int x:a) {
			bool f=0;
			for(int u:P[x]) if(w[d[u]]>d[u]) {
				int r=w[d[u]]-d[u];
				if(!f) cout<<u<<" "<<b[0]<<"\n",--r,f=1,++d[u],dsu[find(u)]=find(b[0]);
				while(r--) cout<<u<<" "<<b[o]<<"\n",++d[u],dsu[find(u)]=find(b[o++]);
			}
		}
		for(int i=1;i<=n;++i) if(!d[i]) id[find(i)]=i;
		vector <int> z;
		for(int i=1;i<=n;++i) if(dsu[i]==i) z.push_back(id[i]);
		for(int i=1;i<(int)z.size();++i) cout<<z[i-1]<<" "<<z[i]<<"\n";
	}
	return 0;
}
```

---


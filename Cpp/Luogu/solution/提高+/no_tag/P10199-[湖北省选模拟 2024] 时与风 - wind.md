# [湖北省选模拟 2024] 时与风 / wind

## 题目背景

风带来故事的种子，时间使之神话。

## 题目描述

你在 $N$ 个锚点间，沿着 $M$ 条有向航道，使用风之翼进行飞行。锚点依次编号为 $1,2,\cdots,N$，有向航道依次编号为 $1,2,\cdots,M$。第 $i$ 条航道的出发锚点为 $u_i$，到达锚点为 $v_i$。

由于巴巴斯托与时间存在神秘的联系，第 $i$ 条航道将在时刻 $O_i$ 开启，在时刻 $C_i$ **后**关闭。**也就是说，对于任意的 $O_i \le t \le C_i$，你可以在时刻 $t$ 由锚点 $u_i$ 进入航道 $i$。**进入航道后，空间上，你将直接到达锚点 $v_i$，时间上，时间将**等概率**的变化为 $[L_i,R_i]$ 中的一个实数对应的时刻。**注意到达一个锚点后，你必须在同一时刻立刻进入下一段航道，否则你必须在此结束飞行。**

你将从锚点 $S$ 出发，尝试访问锚点 $i(1\le i\le N)$，你需要对于锚点 $i$ 确定一条路径 $E_1,E_2,E_3,\cdots,E_k$，其中 $E_x(1\le x\le k)$ 表示一条航道。要求 $E_1$ 从锚点 $S$ 出发，$E_k$ 到达锚点 $i$，且对于 $1\le j<k$，满足 $E_j$ 的到达锚点与 $E_{j+1}$ 的出发锚点相同。一条路径是**稳定路径**，当且仅当无论每次通过航道后时间如何变化，都可以走完整条路径。一条**稳定路径的到达时间**是通过路径前往锚点 $i$ 时，**最晚的**可能到达锚点 $i$ 的时刻。访问**锚点 $i$ 的稳定到达时间 $T_i(i \neq S)$** 是所有到达 $i$ 的稳定路径中到达时间的**最小值**。你可以在任意非负时刻出发。**如果不存在访问锚点 $i$ 的稳定路径或 $i=S$，则 $T_i=0$。**

请你求出 $T_i(1\le i\le N)$ 的最大值。

## 说明/提示

### 样例解释 1

对于锚点 $1$，显然有 $T_1=0$。

对于锚点 $2$，沿路径 $1 \rightarrow 2$ ，$T_2=16065$。

对于锚点 $3$，沿路径 $1 \rightarrow 2 \rightarrow 3$ ，$T_3=26795$。

对于锚点 $4$，沿路径 $1 \rightarrow 4$ ，$T_4 = 10131$。

综上所述，答案 $\max T_i=T_3=26795$。

### 子任务

对于所有测试数据，保证 $1 \le N,M \le 5\times 10^5$，$1 \le O_i,L_i \le 20$，$1 \le O_i \le C_i \le 10^9$，$1 \le L_i \le R_i \le 10^9$，$1\le S \le N$。

| 测试点编号 | $N\le$ | $M\le$ | $C_i,R_i\le$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim 4$ | $20$ | $20$ | $10^9$ | 无 |
| $5\sim 8$ | $10^5$ | $10^3$ | $10^9$| 无 |
| $9\sim 10$ | $5\times 10^5$ | $5\times 10^5$ | $10^9$ | A |
| $11\sim 12$ | $10^5$ | $10^5$ | $20$ | 无 |
| $13\sim 14$ | $5\times 10^5$ | $5\times 10^5$ | $10^3$ | 无 |
| $15\sim 20$ | $5\times 10^5$ | $5\times 10^5$ | $10^9$ | 无 |


特殊性质 A：一个锚点连接的航道数不超过 $100$。

## 样例 #1

### 输入

```
4 10 1
4 2 6 20111 6 11900
2 4 2 10786 13 23576
2 1 3 5274 16 13903
2 1 2 17162 1 26120
1 2 1 42040 11 16065
2 1 4 23690 18 26541
2 3 9 18977 2 26795
4 1 4 51880 1 25060
1 4 13 17776 3 28236
1 4 1 19112 1 10131```

### 输出

```
26795```

## 样例 #2

### 输入

```
见选手目录下的 wind/wind2.in 与 wind/wind2.ans。```

### 输出

```
```

## 样例 #3

### 输入

```
见选手目录下的 wind/wind3.in 与 wind/wind3.ans。```

### 输出

```
```

## 样例 #4

### 输入

```
见选手目录下的 wind/wind4.in 与 wind/wind4.ans。```

### 输出

```
```

# 题解

## 作者：览遍千秋 (赞：15)

本题解为官方题解。

---

首先确定对于一条路径：$E_1,E_2,E_3,...,E_k$ ，判断其是否为稳定路径的方法是：对于任意的 $E_x$ 与 $E_{x+1}(1 \le x <k)$ ，满足 $L_x \ge  O_{x+1}$ 且 $R_x \le C_{x+1}$ ，即每条航道的到达时间区间必须被包含在下一条航道的开放时间区间内。
		
基于上面的结论，可以使用 BFS 的方法，在搜索过程中记录到达每个点的时间区间，再去寻找覆盖到达时间区间的出发航道，此过程是一个解决二维偏序的问题，可以使用暴力寻找二维偏序的方法做到 $O(n+m^2)$ 或 $O(n+md)$ ，其中 $d$ 为所有点的最大度数。

	
注意到题目还有另一个性质： $1 \le O_i,L_i \le 20$ ，可以使用多个 set 或单调栈的方法将二维偏序问题转化为一维偏序问题：对于每个点，将从该点出发的航道按照 $O_i$ 分别加入 $20$ 个以 $C_i$ 排序的 set 或单调栈中。在进行 BFS 的过程中，在经过一条航道 $k$ 后搜索下一条航道时，查询航道 $k$ 终点处所有 $O_i \le L_k$ 的数据结构中 $C_i \ge R_k$ 的航道，将它们全部取出数据结构并加入 BFS 的队列中即可。时间复杂度为 $O(m\log m)$ ，空间复杂度为 $O(20n + m)$，可以解决本题。

---

## 作者：Register_int (赞：12)

等概率是骗人的，最晚到达时间必定为其某个入边的 $R_i$，而可以通行的条件则是出边的区间覆盖入边的区间。

先来考虑对于一个中转点，怎么处理他的入边与出边。首先找到每条可以经过的入边的 $L_i,R_i$，对于每条出边，我们要找到所有的 $i$ 使得 $O_i,C_i$ 使得该区间包含入边里的某个区间。容易想到对左端点做扫描线，维护入边中左端点 $\ge l$ 的最小右端点 $r$，那么出边中左端点 $=l$ 且右端点 $\ge r$ 的都满足条件。之后更新这些出边对应的点的答案。

可以发现，这个做法可以动态插入入边。对每个左端点单独开一个堆，枚举时不断弹出右端点最大的来更新即可。

考虑用广搜不断对这张图进行“松弛”。若当前搜到点 $u$，其连向的点 $v$ 新增了一条可行入边，我们就对 $v$ 进行上述的插入操作，然后将所有它新增的可行出边加入 $v$ 的“代办列表”。当搜到 $v$ 时，再由 $v$ 对其“代办列表”的点继续进行“松弛”。

该做法的正确性是显然的，因为一个点的答案和他上一个点的答案无关。而只有在一个点多了能更新的出边，才会继续进行更新，所以总更新次数为 $O(m)$，时间复杂度为 $O((\max O,L)m+m\log m)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

// using fread
#define INPUT_OPTIMIZE

// using fwrite
// #define OUTPUT_OPTIMIZE

namespace IO {
//	by R_i.
}

using namespace IO;

using namespace std;

typedef long long ll;

const int MAXN = 5e5 + 10;

struct node {
	int v, a, b, c, d, id;
	bool operator < (const node &rhs) const { return b < rhs.b; }
}; vector<node> g[MAXN]; set<node> ts[MAXN];

int t[MAXN]; queue<int> q;

priority_queue<node> y[MAXN][21];

inline 
void upd(int u, int x) {
	if (!t[u]) t[u] = x;
	else t[u] = min(t[u], x);
}

inline 
void insert(int u, node p) {
	for (int i = p.c; i; i--) {
		for (; !y[u][i].empty() && y[u][i].top().b >= p.d;) {
			node tmp = y[u][i].top();
			q.push(tmp.v), ts[u].insert(tmp);
			upd(tmp.v, tmp.d), y[u][i].pop();
		}
	}
}

int n, m;

void solve(int S) {
	for (int i = 1; i <= n; i++) {
		for (node x : g[i]) y[i][x.a].push(x);
	}
	for (node x : g[S]) {
		upd(x.v, x.d);
		q.push(x.v), insert(x.v, x);
	}
	for (int u; !q.empty();) {
		u = q.front(), q.pop();
		if (!t[u]) continue;
		for (node p : ts[u]) insert(p.v, p);
		ts[u].clear();
	}
}

int S, ans;

int main() {
	read(n, m, S);
	for (int i = 1, u, v, a, b, c, d; i <= m; i++) {
		read(u, v, a, b, c, d);
		g[u].push_back({ v, a, b, c, d, i });
	}
	solve(S);
	for (int i = 1; i <= n; i++) ans = max(ans, t[i]);
	write(ans);
}
```

~~1e7 个 priority_queue 不会 MLE，1e6 个 deque 会 MLE，怎么回事呢？~~

---

## 作者：Liuxizai (赞：10)

[My Blog](https://liuxizai.ac.cn/archives/solution-lg10199.html)

## Description

给定 $n$ 个点 $m$ 条边的有向图，第 $i$ 条边有开放时间 $[O_i,C_i]$ 和到达时间 $[L_i,R_i]$，可以经过相邻的两条边 $i,j$ 当且仅当 $[L_i,R_i]\subseteq [O_j,C_j]$，给定起点 $S$，第一条边不受限制，求哪些边可达。

$1\le n,m\le 5\times10^5,1\le O_i\le C_i\le 10^9,1\le L_i\le R_i\le 10^9,{\color{red}1\le O_i,L_i\le 20}$

## Solution

题目询问我们边上的可达性，这个通过 dfs 或 bfs 即可解决。

难点在于，每次从某条边到达一个点 $u$，我们希望找出可行的下一条边，这需要做一个二维偏序，看起来并没有什么好的解决方案。如果遍历 $u$ 所有的出边，复杂度将达到 $O(m^2)$。如果你注意到了本题的关键性质 $1\le O_i,L_i\le 20$，很自然的会想到枚举可行的左端点，现在只需要解决 $C\ge R$。我们对 $u$ 的所有出边按照 $O$ 放进桶里，分别按 $C$ 排序，查询时从尾部弹出满足 $C\ge R$ 的边即可。每条边只会访问一次，总复杂度 $O(m\log m+\max\{O_i,L_i\}\cdot m)$。

问题来了，如果你像我一样在考场上没有看到 $1\le O_i,L_i\le 20$ 这一关键性质，这题还能做吗？

其实仍然可以，做法和 [CF198E Gripping Story](https://www.luogu.com.cn/problem/CF198E) 基本一致。

二维偏序是困难的，本题中搜索的优秀性质在于每个元素只需要访问一次，我们只要能快速定位到满足条件的元素并将其删除即可。具体来说，我们可以将之前提到的做法中的桶换成线段树，将出边按照 $O$ 放到线段树的叶子上，此外，线段树上的每个结点维护区间内所有出边 $C$ 的最大值，查询时根据最大值判断区间内是否存在可行的出边，若有则递归下去找到出边并更新信息，若没有则退出该结点。

我们仍然保证了每条边仅被访问一次，找到一条出边的代价是 $O(\log m)$（不离散化用动态开点则是 $O(\log V)$），总复杂度是优秀的 $O(m\log m)$。

## Code

考场代码，实现的是后面这种方法。

```cpp
namespace Main{
    const int N = 500005;
    int n, m, s, u[N], v[N], o[N], c[N], l[N], r[N];
    bool vis[N];
    vector<int> num[N], e[N], in[N];
    struct segtree{
        struct segtree_node{
            int l, r, mx;
        };
        vector<segtree_node> t;
        vector<vector<int>> buc;
#define ls p << 1
#define rs p << 1 | 1
        void resize(int siz){
            t.resize(4 * siz), buc.resize(siz);
        }
        void pushup(int p){
            t[p].mx = max(t[ls].mx, t[rs].mx);
        }
        void build(int p, int l, int r){
            t[p].l = l, t[p].r = r;
            if(l == r) { t[p].mx = buc[l].empty() ? 0 : c[buc[l].back()]; return; }
            int mid = l + r >> 1;
            build(ls, l, mid), build(rs, mid + 1, r);
            pushup(p);
        }
        void query(int p, int l, int r, int lim, vector<int> &res){
            if(t[p].mx < lim) return;
            if(t[p].l == t[p].r){
                int id = t[p].l;
                while(!buc[id].empty() && c[buc[id].back()] >= lim){
                    res.push_back(buc[id].back());
                    buc[id].pop_back();
                }
                t[p].mx = buc[id].empty() ? 0 : c[buc[id].back()];
                return;
            }
            int mid = t[p].l + t[p].r >> 1;
            if(mid >= l) query(ls, l, r, lim, res);
            if(mid < r) query(rs, l, r, lim, res);
            pushup(p);
        }
#undef ls
#undef rs
    }tree[N];
    void dfs(int p){
        vis[p] = true;
        vector<int> out;
        if(!tree[v[p]].t.empty()){
            int tmp = upper_bound(num[v[p]].begin(), num[v[p]].end(), l[p]) - num[v[p]].begin() - 1;
            if(tmp >= 0) tree[v[p]].query(1, 0, tmp, r[p], out);
        }
        for(int to: out) dfs(to);
    } 
    void Main(){
        input(n, m, s);
        for(int i = 1; i <= m; i++){
            input(u[i], v[i], o[i], c[i], l[i], r[i]);
            e[u[i]].push_back(i);
            num[u[i]].push_back(o[i]);
            in[v[i]].push_back(i);
        }
        for(int i = 1; i <= n; i++){
            if(num[i].empty() || i == s) continue;
            sort(num[i].begin(), num[i].end());
            num[i].erase(unique(num[i].begin(), num[i].end()), num[i].end());
            tree[i].resize(num[i].size());
            for(int j: e[i]){
                int p = lower_bound(num[i].begin(), num[i].end(), o[j]) - num[i].begin();
                tree[i].buc[p].push_back(j);
            }
            for(int j = 0; j < num[i].size(); j++){
                sort(tree[i].buc[j].begin(), tree[i].buc[j].end(), [](int x, int y){
                    return c[x] < c[y];
                });
            }
            tree[i].build(1, 0, num[i].size() - 1);
        }
        for(int st: e[s]) dfs(st);
        int ans = 0;
        for(int i = 1; i <= n; i++){
            if(i == s) continue;
            int tim = 2e9;
            for(int x: in[i]) if(vis[x]) tim = min(tim, r[x]);
            if(tim == 2e9) tim = 0;
            // cerr << i << ' ' << tim << endl;
            ans = max(ans, tim);
        }
        write(ans);
        return;
    }
} // namespace Main
```

---

## 作者：TianTian2008 (赞：2)

发现能走一条边 $(u,v,O_1,C_1,L_1,R_1)$，当且仅当上一条边 $(w,u,O_2,C_2,L_2,R_2)$ 满足 $[L_2,R_2]$ 被 $[O_1,C_1]$ 包含。这样的关系不好刻画，准确来说是没法直接比较优劣。

因为 $O,C\leq20$，所以可以对于每个点 $u$ 多开一维 $t$，记 $(u,t)$ 表示到达 $u$ 且最后一条边的 $L$ 是 $t$。在 $L$ 确定的情况下，$R$ 越小越可能被包含，即能经过更多的边，而且题目中要求的 $T_i$ 是到达点 $i$ 的最后一条边的 $R$ 的最小值。综上所述，在 $L$ 确定的情况下 $R$ 越小越优。

不妨设 $f_{u,t}$ 表示到达点 $u$ 且最后一条边的 $L$ 是 $t$ 的 $R$ 的最小值。好像可以直接跑类似最短路之类的，但仔细想想会发现有环时，可能会更新回自己，从而导致最短路退化成不可接受的时间复杂度。

找找这个问题和最短路的不同点，最短路中经过一条边是加上边权，而这里经过一条边是设为边权。这意味着一条边重复经过不会得到更优解，所以当 $f_{u,t}$ 被再次更新时，只需走那些原先没走过的边，这部分的总时间复杂度为 $O(M)$ 可以接受。

那如何能快速找出哪些边是原先没走过的呢？按 $C$ 从小往大排序，已经走过的边必然是一个后缀，在后缀的基础上继续找就行了。

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int,int> pr;
int n,m,s,top[500001][21],f[500001][21],ans;
bool vis[500001][21];
queue<pr>q;
struct edge {
	int v,c,l,r;
	inline friend bool operator<(edge e1,edge e2) {return e1.c<e2.c;}
};
vector<edge>g[500001][21];
int main() {
//	freopen("wind.in","r",stdin);
//	freopen("wind.out","w",stdout);
	scanf("%d%d%d",&n,&m,&s);
	int u,v,o,c,l,r;
	while(m--) {
		scanf("%d%d%d%d%d%d",&u,&v,&o,&c,&l,&r);
		g[u][o].push_back({v,c,l,r});
	}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=20;++j) {
			top[i][j]=g[i][j].size();
			sort(g[i][j].begin(),g[i][j].end());
			f[i][j]=1000000001;
		}
	for(int i=1;i<=20;++i) {
		f[s][i]=i;
		vis[s][i]=true;
		q.push({s,i});
	}
	int x,y;
	edge e;
	while(!q.empty()) {
		x=q.front().first;
		y=q.front().second;
		vis[x][y]=false;
		q.pop();
		for(int i=1;i<=y;++i)
			while(top[x][i]) {
				e=g[x][i][top[x][i]-1];
				if(e.c<f[x][y]) break;
				if(f[e.v][e.l]>e.r) {
					f[e.v][e.l]=e.r;
					if(!vis[e.v][e.l]) {
						vis[e.v][e.l]=true;
						q.push({e.v,e.l});
					}
				}
				--top[x][i];
			}
	}
	for(int i=1;i<=n;++i) {
		if(i==s) continue;
		int mn=1000000001;
		for(int j=1;j<=20;++j) mn=min(mn,f[i][j]); 
		if(mn!=1000000001) ans=max(ans,mn);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：FL_sleake (赞：2)

感觉中下位蓝，上位绿也不过分。

### 题意简述

你在 $N$ 个锚点间，沿着 $M$ 条有向航道，使用风之翼进行飞行。锚点依次编号为 $1,2,\cdots,N$，有向航道依次编号为 $1,2,\cdots,M$。第 $i$ 条航道的出发锚点为 $u_i$，到达锚点为 $v_i$。

由于巴巴斯托与时间存在神秘的联系，第 $i$ 条航道将在时刻 $O_i$ 开启，在时刻 $C_i$ **后**关闭。**也就是说，对于任意的 $O_i \le t \le C_i$，你可以在时刻 $t$ 由锚点 $u_i$ 进入航道 $i$。**进入航道后，空间上，你将直接到达锚点 $v_i$，时间上，时间将**等概率**的变化为 $[L_i,R_i]$ 中的一个实数对应的时刻。**注意到达一个锚点后，你必须在同一时刻立刻进入下一段航道，否则你必须在此结束飞行。**

你将从锚点 $S$ 出发，尝试访问锚点 $i(1\le i\le N)$，你需要对于锚点 $i$ 确定一条路径 $E_1,E_2,E_3,\cdots,E_k$，其中 $E_x(1\le x\le k)$ 表示一条航道。要求 $E_1$ 从锚点 $S$ 出发，$E_k$ 到达锚点 $i$，且对于 $1\le j<k$，满足 $E_j$ 的到达锚点与 $E_{j+1}$ 的出发锚点相同。一条路径是**稳定路径**，当且仅当无论每次通过航道后时间如何变化，都可以走完整条路径。一条**稳定路径的到达时间**是通过路径前往锚点 $i$ 时，**最晚的**可能到达锚点 $i$ 的时刻。访问**锚点 $i$ 的稳定到达时间 $T_i(i \neq S)$** 是所有到达 $i$ 的稳定路径中到达时间的**最小值**。你可以在任意非负时刻出发。**如果不存在访问锚点 $i$ 的稳定路径或 $i=S$，则 $T_i=0$。**

请你求出 $T_i(1\le i\le N)$ 的最大值。

### 解题思路

时间是等概率变化的，但是要求无论怎么变化都能进到下一条航道，那么只能是下一条航道的开启时间和结束时间完全包含当前航道传送后时间变化的范围。更准确地说，对于航道 $i,j$，若 $O_j \leq l_i$ 且 $r_i \leq C_j$ 且 $v_i=u_j$，则走 $i$ 航道后可以走 $j$ 航道。

上面这个东西实际上就是个二维偏序，由于 $O_i \leq 20$，所以可以对于每个点直接开 20 个 multiset，$s_{i,j}$ 存储以 $i$ 为起点，在 $j$ 时刻开启的航道的终止时刻及航道编号。这样的话对于每次走到的点，都可以扫一遍 20 个 multiset 进行转移。注意转移不仅要记录下来航道的编号，还要记录下来传送到这个点的时间范围，以便下次转移。

~~其实只是为官方题解加了个代码。~~

### 代码示例

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,S,u[500010],v[500010],o[500010],c[500010],l[500010],r[500010];
int vis[500010],dp[500010];
multiset<pair<int,int> > s[500010][25];
struct node{
	int x,tl,tr;
  //当前航道编号，到达的时间范围
};
signed main(){
	memset(vis,0,sizeof(vis));
	memset(dp,0x3f,sizeof(dp));
	cin>>n>>m>>S;
	dp[S]=0;
	for(int i=1;i<=m;i++) cin>>u[i]>>v[i]>>o[i]>>c[i]>>l[i]>>r[i];
	for(int i=1;i<=m;i++) s[u[i]][o[i]].insert({c[i],i});
	queue<node> q;
	for(int i=1;i<=m;i++){
		if(u[i]==S){
			vis[i]=1;
			q.push({i,0x3f3f3f3f3f3f3f3f,-0x3f3f3f3f3f3f3f3f});
          //时间范围之所以这样设计是为了使第一次转移可以转移到任何点
		}	
	}
	while(!q.empty()){
		node id=q.front();q.pop();
		//cout<<id.x<<endl;
      //注意 id.x是航道的编号
      //维护这个是因为知道了航道编号可以轻松知道起始点到达点以及时间等信息
		int to=v[id.x];
		dp[to]=min(dp[to],r[id.x]);
      //到达 to 的最晚时间是 r
		for(int i=1;i<=min(id.tl,20ll);i++){
			while(!s[to][i].empty()&&(*s[to][i].rbegin()).first>=id.tr){
              //只要完全包含就进行转移
				auto nxt=*s[to][i].rbegin();
				s[to][i].erase(s[to][i].find(nxt));
				if(vis[nxt.second]) continue;
				vis[nxt.second]=1;
              //每条航道只需走一次，因为多次走航道 i，x没变，tl没变，tr没变，则后续转移必定一样
				q.push({nxt.second,l[nxt.second],r[nxt.second]});
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++) if(dp[i]!=0x3f3f3f3f3f3f3f3f) ans=max(ans,dp[i]);
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Aiopr_2378 (赞：1)

solution of P10199 [湖北省选模拟 2024] 时与风 / wind

## 解题思路

不难发现在不同点之间旅行，只和相邻两条边的各个参数相关，基本和点无关，考虑发现边的性质。考虑两条相邻边 $u\to v,v\to k$，边的编号分别为 $i,j$，不难发现，这条路径是稳定的，当且仅当 $O_j\le L_i\le R_i\le C_j$。这是一个二维偏序关系。但直接维护这个东西并不好弄，考虑转化。

注意到相邻两条路径是否稳定，只与这两条路径有关，**与其他路径无关**；每个点 $T_i$ 也只**与到达这个点的最后一条路径有关**。不难发现，从一个已经被判定为能够稳定到达的节点 $u$ 开始扩展，走过一条边到达 $v$，这条边要与上一次到达 $u$ 的边满足上述偏序关系。如果满足，则走过这条边，**那么这条边在以后的决策中不会产生任何贡献**，可以直接删掉。这样，我们只需要从记录上一条走的边，并在这个点找到稳定的出边，走出去，删去这条边，即可。每条边只需要遍历一次，故时间复杂度为 $O(m)$。

## 参考代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define MAXN 500005
#define inf 0x3f3f3f3f
typedef long long ll;
int n,m,s;
struct node{
    int u,v,l,r,L,R;
}e[MAXN];
int t[MAXN],head[MAXN],nxt[MAXN],to[MAXN],link[MAXN],tot=1;
inline void add(int x,int y,int id){
    to[++tot]=y,link[tot]=id,nxt[tot]=head[x],head[x]=tot;
}
void dfs(int u,int L,int R){
    int lst=-1;
    for(int i=head[u];i;i=nxt[i]){
        int v=to[i];
        if(u==s||e[link[i]].l<=L&&e[link[i]].r>=R){
            t[v]=min(t[v],e[link[i]].R);
            if(lst==-1) head[u]=nxt[i];
            else nxt[lst]=nxt[i];
            dfs(v,e[link[i]].L,e[link[i]].R);
        }
        lst=i;
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>s;
    for(int i=1,u,v,l,r,L,R;i<=m;i++){
        cin>>u>>v>>l>>r>>L>>R;
        e[i]={u,v,l,r,L,R};
        add(u,v,i);
    }
    memset(t,0x3f,sizeof(t));
    t[s]=0;
    dfs(s,0,inf);
    int ans=0;
    for(int i=1;i<=n;i++) if(t[i]==inf) t[i]=0;
    for(int i=1;i<=n;i++) ans=max(ans,t[i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：pyiming (赞：0)

# P10199 [湖北省选模拟 2024] 时与风 / wind题解

[原题地址-Luogu](https://www.luogu.com.cn/problem/P10199)

## 题目大意

题目描述了一个有向图，包含 $n$ 个结点和 $m$ 条边。每条边 $i$ 从 $u_i$ 到 $v_i$，进入时间是 $[o_i, c_i]$，离开时间是 $[l_i, r_i]$。稳定路径的定义是对于所有路径 $E_j$（$1 \le j < k$），满足 $l_{j+1} \le o_j \le c_j \le r_{j+1}$ 且路径从 $s$ 开始，到 $i$ 结束。需要求所有访问 $i$（$1 \le i \le n$）的稳定路径到达时间 $r_k$ 的最小值。

## 思路

1. **贡献只与最后一条边的最晚到达时间有关**：稳定路径的到达时间取决于最后一条边的 $r_k$。
2. **边的可进入性**：并非所有边都能进入。我们需要标记可进入的边。
3. **遍历与更新**：使用队列存储可进入的边，遍历时更新到达时间和可进入的边。
4. **利用条件 $1 \le O_i, L_i \le 20$**：使用 `multiset` 记录每个结点的每个 $O_i$ 的出边，便于从后往前弹出。
5. **注意点**：使用 `set` 时，比较操作符要正确定义，避免第15个测试点WA。

时间复杂度为 $O(20m\log m)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=5e5;
struct query{
	int v,c,l,r;
	bool operator <(const query o) const{
		return c<o.c;
	}
};
int n,m,s;
multiset<query> edge[N+1][21];
void read(){
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++){
		int u,v,o,c,l,r;
		scanf("%d%d%d%d%d%d",&u,&v,&o,&c,&l,&r);
		edge[u][o].insert({v,c,l,r});
	}
}
queue<query> q;
bool flag[N+1];
int ans[N+1];
void renew(query x){
	int u=x.v,l=x.l,r=x.r;
	ans[u]=min(ans[u],r);
	flag[u]=1;
	for(int i=1;i<=l;i++) if(!edge[u][i].empty()){
		auto it=edge[u][i].end();
		it--;
		while(!edge[u][i].empty()&&it->c>=r){
			auto tit=it;
			q.push(*it);
			it--;
			edge[u][i].erase(tit);
			
		}
	}
}
void solve(){
	for(int i=1;i<=20;i++){
		if(edge[s][i].empty()) continue;
		auto it=edge[s][i].end();
		it--;
		while(!edge[s][i].empty()){
			auto tit=it;
			q.push(*it);
			it--;
			edge[s][i].erase(tit);
		}
	}
	while(!q.empty()){
		renew(q.front());
		q.pop();
	}
}
int main(){
//	freopen("wind4.in","r",stdin);
	read();
	for(int i=1;i<=n;i++) ans[i]=1e9;
	ans[s]=0;
	solve();
	int temp=0;
	for(int i=1;i<=n;i++){
		if(flag[i]) temp=max(temp,ans[i]);
	}
	printf("%d\n",temp);
	return 0;
}
```

---

## 作者：_llch_ (赞：0)

我们先来看一下这些边的性质，“时间将等概率的变化为 
$[L_i,R_i]$ 中的一个实数对应的时刻。”这是原题面，等概率不好做，但是发现题目要求的是稳定路径，所以转化为下一条边的 $O,C$ 和上一条边的 $L,R$ 满足 $O\leq L\leq R\leq C$，变成了维护区间的问题。

但是要求的最短路却是想不到怎么建模，原因是区间变为 $[L，R]$ 意味着只要我经过了这一条边，就与之前的状态没有关系了，这就意味着传统的最短路算法**应该**都不可行。

看到数据范围，发现 $O,L$ 都比较小，只有 $20$，这种时候一般要想办法把这个 $20$ 放进复杂度里，所以我们考虑枚举左端点，那么就先来考虑一下左端点固定的情况。

前面说过了，只要经过了这一条边，就与之前的状态没有关系了，那么容易想到，对于一条边，每次走完一定只会得到相同的状态。所以我们就应该尽可能的使一条边只会被访问一次。对于若干条 $O_i$ 相同的边，显然能走过 $C_i$ 较小的边就一定能走过 $C_i$ 较大的边，所以我们把边按照 $O_i$ 分开存储，$O_i$ 相同的再按 $C_i$ 从大到小排序。然后跑 bfs，遍历边的时候一定只能走放在最前面的边，而被走过的边毫无意义，所以我们做一个类似网络流中 dinic 的当前弧优化，具体就是记录已经走过哪些边，下次从未被走过的第一条边开始遍历。

关于复杂度，首先对边排序显然是 $\mathcal
{O}(m\log m)$ 的，然后是 bfs 部分，虽然点有可能会被经过多次，但是每条边只会被经过一次，而每个点则需要经过一条边才会进入队列，所以 bfs 的队列最多入队 $m$ 次，每个点需要枚举出边的 $O_i$，所以乘上一个 $\mathcal{O}(20)$ 的复杂度，所以总体复杂度是 $\mathcal{O}(m\log m+20m)$ 的。

下面是代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+5;
const int maxl=25;
int n,m,s;
int h[maxn][maxl],cur[maxn][maxl];
struct edge{
	int to,ed,l,r;
	bool operator<(edge x){
		return ed>x.ed;
	}
};
vector<edge>e[maxn][maxl];
struct node{
	int x,l,r;
};
int ans[maxn];
void bfs(){
	queue<node>q;
	for(int i=1;i<=n;i++)for(int j=1;j<=20;j++)cur[i][j]=0;
	for(int i=1;i<=n;i++)ans[i]=1e9;
	ans[s]=0;
	q.push({s,20,0});
	while(!q.empty()){
		int x=q.front().x,l=q.front().l,r=q.front().r;q.pop();
		ans[x]=min(ans[x],r);
		for(int i=1;i<=l;i++)for(int j=cur[x][i];j<e[x][i].size()&&e[x][i][j].ed>=r;cur[x][i]=++j)q.push({e[x][i][j].to,e[x][i][j].l,e[x][i][j].r});
	}
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>s;
	for(int i=1,x,y,bg,ed,l,r;i<=m;i++){
		cin>>x>>y>>bg>>ed>>l>>r;
		e[x][bg].push_back({y,ed,l,r});
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=20;j++)sort(e[i][j].begin(),e[i][j].end());
	bfs();
	int res=0;
	for(int i=1;i<=n;i++)if(ans[i]!=1e9)res=max(res,ans[i]);
	cout<<res;
	return 0;
}
```

---

## 作者：Lyz09 (赞：0)

考虑什么情况下一条边能够转移到另一条边，$i$ 边能转移到 $j$ 边仅当 $O_j\leq L_j\leq R_j\leq C_i$ 且 $v_i=u_j$。

直接计算包含是 $O(n^2)$ 的。如果固定 $L$ 或者 $R$ 再计算是简单的，同时发现 $O_i$ 和 $L_i$ 至多为 $20$，所以考虑枚举 $O_i$。

具体的，对于点 $u$，存下来以这个点的所有出边的 $C$，进行离散化。然后新建 $20$ 条链，第 $i$ 条链第 $j$ 个位置的可以转移到 $L=i$，$R$  在所有出边的 $R$ 中第 $j$ 大的出边。第 $i$ 条链可以转移到所有以这个点的所有出边中满足 $L=i$ 所有边。

假如某条边可以转移到这个点 $L=l,R=r$ 的出边，那么它也一定可以转移到 $L=l-1,R=r$ 或 $L=l,R=r+1$ 的边。所以第 $i$ 条链的第 $j$ 个点要有一条连向第 $i$ 条链的第 $j+1$ 个点的单向边，不同链之间则不需要连边。

对于每条边 $i$ 的 $v$，则先找出点 $v$ 的出边中的 $C$ 最小的大于等于 $R_i$ 的位置。再对于这个点的 $20$ 条链的这个位置连一条单向边。因为点 $u$ 中的链没有互相连边，所以需要在这里给每一条链连边。同时为了不让边的数量达到 $n^2$ 级别，我们需要建至少一个中转点，在这个中转点统计答案即可。

最后无脑遍历整张图，在中转点统计答案即可。

时间复杂度 $O(20m+n\log n)$，空间复杂度 $O(20m)$。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
#define N 500010
#define NN 4000010
int n,m,bg,tou[NN],tow[NN],now,ans[N];
bool wlvis[N][21],vis[NN];
vector<int> wr[N];
vector<pair<int,int> > wl[N];
vector<int> g[NN];
struct edge
{
	int u,v,o,c,l,r;
}e[N];
void dfs(int u)
{
	if(vis[u])
	 return;
	vis[u]=1;
	if(tou[u]!=0)
	{
		ans[tou[u]]=min(ans[tou[u]],tow[u]);
	}
	for(int v:g[u])
	 dfs(v);
}
int main()
{
//	freopen("wind.in","r",stdin);
//	freopen("wind.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>bg;
	for(int i=1;i<=m;i++)
	{
		cin>>e[i].u>>e[i].v>>e[i].o>>e[i].c>>e[i].l>>e[i].r;
		wr[e[i].u].push_back(e[i].c);
		wlvis[e[i].u][e[i].o]=1;//赛时注释了上一行和这一行，挂了75
	}
	for(int i=1;i<=n;i++)//离散化，我这里额外存了出现的 O
	{
		sort(wr[i].begin(),wr[i].end());
		wr[i].resize(unique(wr[i].begin(),wr[i].end())-wr[i].begin());
		int cnt=0;
		for(int j=1;j<=20;j++)
		if(wlvis[i][j])
		 cnt++;
		wl[i].resize(cnt);
		cnt=0;
		for(int j=1;j<=20;j++)
		if(wlvis[i][j])
		{
			wl[i][cnt]=make_pair(j,now+1);
			cnt++;
			for(int k=1;k<wr[i].size();k++)
			{
				g[now+k].push_back(now+k+1);
			}
			now+=wr[i].size();
		}
	}
	for(int i=1;i<=m;i++)//处理每一条边
	{//u->newu->newv->v
		int newu=++now;
		int newv=++now;
		pair<int,int> wo=(*lower_bound(wl[e[i].u].begin(),wl[e[i].u].end(),make_pair(e[i].o,-1)));
		auto itrc=upper_bound(wr[e[i].u].begin(),wr[e[i].u].end(),e[i].c);
		if(itrc!=wr[e[i].u].begin())
		{
			itrc--;	
			int pl1=itrc-wr[e[i].u].begin();
			g[wo.second+pl1].push_back(newu);
		}//处理 u
		g[newu].push_back(newv);
		tou[newv]=e[i].v;
		tow[newv]=e[i].r;
		auto itrr=lower_bound(wr[e[i].v].begin(),wr[e[i].v].end(),e[i].r);
		int pl2=itrr-wr[e[i].v].begin();
		for(pair<int,int> w:wl[e[i].v])
		if(w.first<=e[i].l)
		{
			g[newv].push_back(w.second+pl2);
		}
		else
		 break;//处理 v
	}
	for(int i=0;i<=n;i++)
	 ans[i]=2147483647;
	ans[bg]=0;
	for(pair<int,int> w:wl[bg])
	{
		dfs(w.second);
	}
	for(int i=1;i<=n;i++)
	if(ans[i]==ans[0])
	 ans[i]=0;
	int res=0;
	for(int i=1;i<=n;i++)
	 res=max(res,ans[i]);
	cout<<res<<endl;
}
```





---

## 作者：_Ch1F4N_ (赞：0)

没判不联通，大样例强度感人。

考虑对于每个点拆成 $20$ 个来刻画到这个点可能的最早时间，然后你发现你需要让最晚时间尽可能早来更有可能通过巷道，设计状态 $dp_{u}$ 表示到这个点的最早时间，然后转移是 $dp_{u} = \min(R)$ 满足 $dp_{u} \leq c$，因为这里一个点至多被每个入度更新一遍，所以直接用 SPFA 时间复杂度是 $O((n+m) \times \max L)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5+114;
int tot,n,m,S;
int pos[maxn][21];
int g[maxn*21];
int L[maxn*21];
int minR[maxn*21];
int vis[maxn*21];
struct e{
    int o,c,l,r;
};
vector< pair<int,e> > E[maxn];
void SPFA(){
    queue<int> q;
    for(int i=1;i<=20;i++) minR[pos[S][i]]=-INT_MAX,q.push(pos[S][i]),vis[pos[S][i]]=1;
    while(q.size()>0){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(pair<int,e> nxt:E[g[u]]){
            if(L[u]>=nxt.second.o&&minR[u]<=nxt.second.c){
                if(minR[pos[nxt.first][nxt.second.l]]>nxt.second.r){
                    minR[pos[nxt.first][nxt.second.l]]=nxt.second.r;
                    if(vis[pos[nxt.first][nxt.second.l]]==0){
                        vis[pos[nxt.first][nxt.second.l]]=1;
                        q.push(pos[nxt.first][nxt.second.l]);
                    }
                } 
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>S;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=20;j++) pos[i][j]=++tot,g[tot]=i,L[tot]=j,minR[tot]=INT_MAX;
    }
    for(int i=1;i<=m;i++){
        e edge;
        int u,v;
        cin>>u>>v;
        cin>>edge.o>>edge.c>>edge.l>>edge.r;
        E[u].push_back(make_pair(v,edge));
    }
    SPFA();
    int ans=0;
    for(int i=1;i<=n;i++){
        int Min=INT_MAX;
        bool flag=false;
        for(int j=1;j<=20;j++) if(minR[pos[i][j]]<INT_MAX) flag=true;
        for(int j=1;j<=20;j++) Min=min(Min,minR[pos[i][j]]);
        if(flag==true) ans=max(ans,Min);
    }
    cout<<ans<<'\n';
    return 0;
}
```


---


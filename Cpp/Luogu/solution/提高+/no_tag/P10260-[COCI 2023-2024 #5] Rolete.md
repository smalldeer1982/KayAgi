# [COCI 2023/2024 #5] Rolete

## 题目背景

**译自 [COCI 2023/2024 Contest #5](https://hsin.hr/coci/archive/2023_2024) T4「[Rolete](https://hsin.hr/coci/archive/2023_2024/contest5_tasks.pdf)」**

## 题目描述

一个周六的下午，Luka 从午睡中醒来，想起今天有 COCI！在比赛前，他只需要做一件事情：拉起窗帘。

卢卡的房间里有 $n$ 个窗帘，其中第 $i$ 个窗帘距离窗户顶部下降了 $a_i$ 厘米。他可以通过两种方式拉起窗帘：

- 他可以手动开始拉起任意一个窗帘。使用这种方法，他每拉起 $1$ 厘米需要 $t$ 秒钟。
- 他可以按下一个按钮，同时以相同的速度将所有窗帘同步拉起。

按下按钮时，窗帘的上升速度定义如下：如果所有窗帘都在上升，每个窗帘都会在 $s$ 秒内上升 $1$ 厘米。如果 $r$ 个窗帘已经完全升起，这会减慢系统的速度。那么剩余的窗帘每上升 $1$ 厘米需要 $s + k \cdot r$ 秒钟。

COCI 即将开始，Luka 希望尽快拉起他的窗帘。与此同时，他的兄弟 Marin 走进房间，问了他 $q$ 个问题：**为了使窗帘下降的最大高度不超过 $h$ 厘米，你需要的最短时间是多少**？Marin 对于每个问题都考虑窗帘的初始状态。

他们意识到在 COCI 之前没有足够的时间来考虑这个问题。幸运的是，这个问题也出现在这里！帮助他们解决它！

注意：Luka 总是将窗帘拉起一个整数值的厘米。

## 说明/提示

### 样例解释 1

为了使所有窗帘的下降高度最多为 $2$ 厘米，卢卡需要手动将第三个窗帘拉起 $2$ 厘米。最快的方法是手动拉起它，这将花费他 $4$ 秒钟。

如果所有窗帘都需要完全拉起，卢卡可以先手动将第三个窗帘拉起 $2$ 厘米。然后，他可以按下按钮，让所有窗帘同时上升 $2$ 厘米。总共需要的时间为 $4 + 10 = 14$ 秒。

类似地，如果窗帘的下降高度最多为 $1$ 厘米，卢卡会先手动将第三个窗帘拉起 $2$ 厘米，然后将所有窗帘一起上升 $1$ 厘米。拉起的总时间将为 $9$ 秒。

### 子任务

| Subtask | Points | Constraints |
| :--: | :--: | :--: |
| 1 | 16 | $n,q,a_i,h_i\le 100$ |
| 2 | 26 | $k=0$ |
| 3 | 32 | $q=1$ |
| 4 | 36 | 无额外限制 |

## 样例 #1

### 输入

```
3 2 5 1
2 2 4
3
2 0 1
```

### 输出

```
4 14 9
```

## 样例 #2

### 输入

```
2 3 4 0
3 1
3
3 2 0
```

### 输出

```
0 3 10
```

## 样例 #3

### 输入

```
4 3 10 3
2 4 5 6
3
4 3 0
```

### 输出

```
9 18 47
```

# 题解

## 作者：_determination_ (赞：6)

一件有趣的事情：教练给我们期中考试，考了两场 COCI 的整套题目。。。

---
抛开上面不谈，这道题的质量还是不赖的。首先显然要求出询问为任意值时的答案然后查询就好。我们通过大眼观察法可以得到一个贪心：求 $x$ 的答案，就在 $x+1$ 的最优方案基础上操作，把高出部分一个一个拉上去（称为操作 1）和整体下降（称为操作 2）的花费做一个比较，选代价更小的那个。

这题的难点其实并非贪心，而是思考这个看起来就很假的贪心的正确性。考虑反证法。

如果你 $x+1$ 的情况用这种方法得到了最优解，并且 $x$ 的时候用这种方法得不到最优解，那么你一定是因为调整上面的某一步操作会让之前的代价更大但是此时的代价最小。

显然如果会这样要么是之前用 1 代价更大但是如果用 1 可以减小本次使用 2 操作的代价，但是如果你之前用 2 现在用 1 的操作代价是一样的，所以你之前用 2 是不劣的。

或者是之前用 2 代价更大但是用 2 操作可以拉下去一些本来不需要拉的窗帘，让你 1 操作的代价更小。但是你之前用 1 这下用 2 肯定也是不劣的。

综上，你照这样贪心下去肯定是不劣的，那么代码也非常简单啊。

```cpp
#include<bits/stdc++.h>
#define int long long
 #define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=1e5+10,M=2e5+10;
const int m=1e5;
int n,t,s,k;
int a[N],ans[N],cnt[N];
int sl[N],sr[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >>n >> t >> s >> k;
	for ( int i = 1 ; i <= n ; i++ )cin >> a[i];
	for ( int i = 1 ; i <= n ; i++ )sl[a[i]]++,sr[a[i]]++;
	for ( int i = 1 ; i <= m ; i++ )sl[i]+=sl[i-1];
	for ( int i = m ; i >= 0 ; i-- )sr[i]+=sr[i+1];
	for ( int i = m-1 ; i >= 0 ; i-- )
	{
		int cost1=s+k*sl[cnt[i+1]];
		int cost2=sr[i+1+cnt[i+1]]*t;
		if(cost1<cost2)ans[i]=ans[i+1]+cost1,cnt[i]=cnt[i+1]+1;
		else ans[i]=ans[i+1]+cost2,cnt[i]=cnt[i+1];
	}
//	for ( int i = 0 ; i <= 6 ; i++ )
//		cout << ans[i] << " " << cnt[i] << endl;
	int q;cin >>q;
	while(q--){int x;cin >> x;cout << ans[x] << " ";}
	return 0;
}
```

---

## 作者：TemplateClass (赞：4)

下文中记

$$\#\{P\} = \sum _ {i = 1} ^ n [P]$$

不妨设我们先用机器拉 $x$ 厘米，那么我们可以把 $x$ 厘米的拉升看作 $x$ 次对耗时的增加，则第 $j$ 次增加的耗时为

$$s + k \times \#\{a _ i < j\}$$

累加下来 $x$ 次，一共就是

$$\begin{aligned} \sum _ {j = 1} ^ x (s + k \times \#\{a _ i < j\}) &= s \times x + k \times \sum _ {j = 1} ^ x \#\{a _ i < j\} \\ &= s \times x + k \times \sum _ {a _ i < x}(x - a _ i) \end{aligned}$$

然后我们还要再手动把窗帘拉上去，我们显然只需要拉 $a _ i > h + x$ 的那些窗帘，所以一共需要

$$t \times \sum _ {a _ i > h + x}(a _ i - h - x)$$

综合下来，我们得到函数

$$f(x) = s \times x + k \times \sum _ {a _ i < x}(x - a _ i) + t \times \sum _ {a _ i > h + x}(a _ i - h - x)$$

显然这个函数是凹的，可以三分，但是我不会。考虑到这个 $x$ 的取值是离散的（因为只能取整数），所以我们不妨设

$$\begin{aligned} \Delta(x) &= f(x + 1) - f(x) \\ &= s + k \times \#\{a _ i < x + 1\} - t \times \#\{a _ i > h + x\}\end{aligned}$$

然后在 $[0, \max \{ a _ i\} - h]$ 上二分第一个使得 $\Delta(x) \ge 0$ 的点即可，然后答案就是 $f(x)$。这里再推一下 $f(x)$ 的更好算的式子：

$$\begin{aligned} f(x) &= s \times x + k \times \sum _ {a _ i < x}(x - a _ i) + t \times \sum _ {a _ i > h + x}(a _ i - h - x) \\ &= s \times x + k \times \left(\#\{a _ i < x\} \times x  - \sum _ {a _ i < x} a _ i\right) + t \times \left[ \sum _ {a _ i > h + x} a _ i - \#\{a _ i > h + x\} \times (h + x)\right] \end{aligned}$$

然后你就会发现现在 $\Delta$ 和 $f$ 中的所有 $\#\{\cdots\!\,\}$ 都可以用二分求出，所有的 $\sum$ 都可以用前缀和求出。

于是每次二分再求 $\Delta$ 的时间复杂度为 $O(\log n \log V)$，求 $f$ 即为 $O(\log n)$。最初的前缀和 + 排序是 $O(n \log n)$ 的，所以总时间复杂度为 $O(n \log n + q \log n \log V)$。

```cpp
#include<iostream>
#include<algorithm>

typedef long long ll;
typedef unsigned long long ull;
constexpr int N = 1e5 + 1;

int n; ll s, k, t; int q, a[N]; ll S[N];

inline ll D(int x, int h) {
	ll c1 = std::lower_bound(a + 1, a + n + 1, x + 1) - a - 1;
	ll c2 = n - (std::upper_bound(a + 1, a + n + 1, h + x) - a) + 1;
	return s + k * c1 - t * c2;
}
inline ll f(int x, int h) {
	ll c1 = std::lower_bound(a + 1, a + n + 1, x + 1) - a - 1;
	ll c2 = n - (std::upper_bound(a + 1, a + n + 1, h + x) - a) + 1;
	ll s1 = S[c1], s2 = S[n] - S[n - c2];
	return s * x + k * (c1 * x - s1) + t * (s2 - c2 * (h + x));
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> n >> t >> s >> k;
	for(int i = 1; i <= n; ++i) std::cin >> a[i];
	std::sort(a + 1, a + n + 1); 
	for(int i = 1; i <= n; ++i) S[i] = S[i - 1] + a[i];
	std::cin >> q; while(q--) {
		int h; std::cin >> h;
		int l = 0, r = a[n] - h;
		while(l < r) {
			int mid = (l + r) >> 1;
			D(mid, h) >= 0 ? r = mid : l = mid + 1;
		}
		std::cout << f(l, h) << " ";
	}
	
	return 0;
}
```

---

## 作者：WaterSun (赞：4)

[更好的阅读体验](https://www.cnblogs.com/WaterSun/p/18947588)

信息学不是数学，所以乐子题解当乐子看看就行了 /lh

# 思路

大胆猜测，当查询的 $h$ 变小时，用按钮的次数一定不会减少，于是上决策单调性可以直接秒掉。

接下来尝试证明一下。设允许的最高高度为 $h$，令 $f(x)$ 表示按 $x$ 次按钮的代价，$g(h,x)$ 表示按 $x$ 次后还需要单独操作的贡献以达到 $h$，则当询问 $h$ 时先按 $x$ 次按钮的代价就是 $c(h,x) = f(x) + g(h,x)$。

把 $f(x),g(h,x)$ 表示出来，其中 $cnt_i$ 表示 $a$ 中 $\leq i$ 的元素数量，$sum_i$ 表示 $a$ 中 $\geq i$ 的元素之和，$s_i$ 表示 $a$ 中 $= i$ 的元素之和，$v_i$ 表示 $a$ 中 $= i$ 的元素数量：

$$
f(x) = f(x - 1) + s + k \times cnt_{x - 1}\\
g(h,x) = (sum_{h + x + 1} - (cnt_m - cnt_{h + x}) \times (x + h)) \times t
$$

考虑 $c(h,x)$ 与 $c(h,x + 1)$ 的增量 $\Delta c(h,x)$：

$$
\Delta c(h,x) = \Delta f(h,x) + \Delta g(h,x) = s + k \times cnt_{x - 1} + (v_{h + x + 1} - s_{h + x + 1}) \times t
$$

显然 $\Delta c(h,x)$ 随 $h$ 的增大而减小，且 $c(h,x)$ 是一个单谷函数。我们希望对于每一个询问每一次选择的 $c(h,x)$ 都尽量的小，因此我们的决策点 $p$ 一定为最小的满足 $\Delta c(h,x) \geq 0$ 的数。

由于 $\Delta c(h,x)$ 单调递减，因此对于一个较大的 $h$ 其决策点 $p$ 一定较小。于是满足决策单调性的定义，证毕！

# Code

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 2e5 + 10;
const int inf = (int)(1e18) + 10;
int n,t,s,k,q,m;
int arr[N],cnt[N],sum[N],cst[N],ans[N];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

inline void dfs(int l,int r,int vl,int vr){
    if (l > r) return;
    int mid = l + r >> 1;
    int Min = inf,pos = 0;
    for (re int i = vl;i <= vr;i++){
        int val = cst[i] + (sum[mid + i + 1] - (cnt[m] - cnt[mid + i]) * (i + mid)) * t;
        if (Min > val) Min = val,pos = i;
    } ans[mid] = Min;
    dfs(l,mid - 1,pos,vr); dfs(mid + 1,r,vl,pos);
}

signed main(){
    n = read(),t = read(),s = read(),k = read();
    for (re int i = 1;i <= n;i++){
        cnt[arr[i] = read()]++; sum[arr[i]] += arr[i];
    } m = *max_element(arr + 1,arr + n + 1);
    for (re int i = 1;i <= 2 * m;i++) cnt[i] += cnt[i - 1];
    for (re int i = m;~i;i--) sum[i] += sum[i + 1];
    for (re int i = 1;i <= m;i++) cst[i] = cst[i - 1] + s + k * cnt[i - 1];
    dfs(0,m,0,m); q = read();
    while (q--) printf("%lld ",ans[read()]);
    return 0;
}
```

---

## 作者：菲斯斯夫斯基 (赞：4)

# P10260 [COCI 2023/2024 #5] Rolete 题解

upd：无聊的时候发现并修改了一些细节错误。

## 前言

好题。教练把这场 COCI 当模拟赛了，记录一下做题经验。

这题可以从子任务一步步走向正解，下面也会对每个子任务进行讲解。

## 思路

注：便于描述，下面将题目中的「按下一个按钮，同时以相同的速度将所有窗帘同步拉起」称为「电动」。

首先读完题可以发现，先电动再手动应该是最优的做法。因为先手动可能导致某些窗帘**更早地被完全拉起**，这样是不优的。

### $\texttt{Subtask\ 1}$

比较好拿的一档部分分。注意到数据非常小，不难想到直接枚举电动升高多少，剩下还有超过 $h$ 的直接手动即可。时间复杂度 $\mathcal O(q\times nV)$，预期得分 16 pts。

代码是赛时打的，可能有些复杂。

注：以后的 $g$ 函数指在下面代码中求出：给定电动升高高度和目标高度后，完成任务所需的时间。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,t,s,k,q;
int a[N],f[N];
int g(int m,int h)//m是电动升高高度，h是目标高度
{
	int sum=0,r=s,ans=0;//sum是已经拉了多少，r是当前电动拉一厘米所需时间
	for(int i=1;i<=n;i++)
	{
		int x=a[i]-sum;//还有多少没拉
		if(x>m)sum+=m,ans+=m*r,x-=m,m=0,ans+=max(0ll,x-h)*t;//没拉到顶
		else ans+=x*r,m-=x,sum+=x,r+=k;//拉到顶了
	}
	return ans;
}
signed main()
{
	cin>>n>>t>>s>>k;
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	while(q--)
	{
		int h,ans=1e18;
		scanf("%lld",&h);
		for(int i=0;i<=a[n];i++)//枚举电动升高的高度
			ans=min(ans,g(i,h));
		printf("%lld ",ans);
	}
	return 0;
}
```

### $\texttt{Subtask\ 2}$

现在 $k=0$，也就是说电动的时间固定了，可以贪心一手。假设现在还剩 $x$ 个窗帘没有拉到 $h$：

1. 选择电动。用 $s$ 时间一共拉了 $x$ 长度。

2. 选择手动。拉 $x$ 长度的话需要 $x\times t$ 时间。

显然我们会在 $s$ 和 $x\times t$ 中选最小值。稍加转化，其实就是剩下 $\lfloor\frac{s}{t}\rfloor$ 个窗帘的时候会选择手动。

然后就好做了，找到**最大只用电动的窗帘的高度**，这样可以求出用电动的时间。找到最大的 $\lfloor\frac{s}{t}\rfloor$ 个窗帘，这些窗帘将会用手动处理剩下的部分。前缀和加二分优化一下即可。注意判断刚才的窗帘是否达到了 $h$ 高度。

时间复杂度 $\mathcal O(q\log n)$。

```cpp
signed main()
{
	cin>>n>>t>>s>>k;
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	if(k==0)
	{
		int c=max(0ll,n-s/t);
		for(int i=1;i<=n;i++)
			f[i]=f[i-1]+a[i];
		cin>>q;
		while(q--)
		{
			int h,ans=1e18;//最大只用电动的窗帘
			scanf("%lld",&h);
			if(a[n]<=h)
			{
				printf("0 ");
				continue;
			}
			if(a[c]<=h)
			{
				int id=upper_bound(a+1,a+1+n,h)-a;
				printf("%lld ",(f[n]-f[id-1]-(n-id+1)*h)*t);
			}
			else printf("%lld ",(f[n]-f[c-1]-(n-c+1)*a[c])*t+(a[c]-h)*s);
		}
		return 0;
	}
	return 0;
}
```

### $\texttt{Subtask\ 3}$

回看 $\texttt{Subtask\ 1}$ 的思路，$\mathcal O(nV)$ 也无法通过这个子任务。所以考虑优化哪一层。

在 $\texttt{Subtask\ 1}$ 的代码中，我们多次询问了 $g$ 函数，目的是为了找最小值。找最小值的过程容易联想到**二分答案**，是否能通过二分来找到最小值呢？

可惜的是，并没有单调性。但是，~~通过枚举~~可以发现这是一个**凸函数**，也就是说可以**三分**！

但是为什么是凸函数呢。可以结合 $\texttt{Subtask\ 2}$ 的思路进行理解。最开始时，拉到顶的窗帘较少。故 $\lfloor\frac{s}{t}\rfloor$ 数量较小，选择电动会更优。随着电动的高度不断增加，拉到顶的窗帘增多，$s$ 增大，$\lfloor\frac{s}{t}\rfloor$ 也会增大，选择手动会更优。感性理解一下，在枚举**电动升高的高度**增大时，首先会因为到顶的窗帘较少导致总时长也在减小；枚举到某个点达到总时长最小值，又会因为到顶的窗帘较多导致总时长不断增大。

时间复杂度约是 $\mathcal O(q\times n \log V)$，这个子任务里 $q=1$。

代码就不给了，在 $\texttt{Subtask 1}$ 的基础上加个三分就行。

### $\texttt{Subtask 4}$

解决完特殊性质，是时候结束这题了！刚才的 $\texttt{Subtask 3}$ 在 $\mathcal O(q\times n \log V)$ 的时间复杂度内解决了问题，但是仍然不够优秀。

剩下唯一可以优化的似乎只剩下 $g$ 函数了。回看 $\texttt{Subtask 2}$，似乎本质上就是对 $g$ 函数的一种优化。

仔细想想，其实我们需要计算出两个时间：电动所需时间和手动所需时间。

由于我们枚举了**电动升高的高度**，所以手动所需时间可以类似 $\texttt{Subtask 2}$ 使用二分加前缀和解决。

然后发现电动所需时间只需要预处理即可。怎么预处理呢？设 $p_i$ 为电动升高 $i$ 所需时间。首先 $p_0$ 为 $0$，然后怎么转移。$p_i$ 应从 $p_{i-1}$ 转移而来，多升高了 $1$ 厘米，新增的就是这 $1$ 厘米所需的时间。初始时时间为 $s$，后面每有一个窗帘到顶就增加 $k$。然后就结束了。

时间复杂度 $\mathcal O(q\times \log V \times \log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,t,s,k,q;
int a[N],f[N],p[N];
int g(int m,int h)
{
	if(a[n]<=m+h)return p[m];
	int id=upper_bound(a+1,a+1+n,h+m)-a;
	return ((f[n]-f[id-1])-(h+m)*(n-id+1))*t+p[m];//计算时间
}
signed main()
{
	cin>>n>>t>>s>>k;
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		f[i]=f[i-1]+a[i];
	int now=s,id=1;
	for(int i=1;i<N;i++)
	{
		while(id<=n&&a[id]==i-1)id++,now+=k;//窗帘到顶
		p[i]=p[i-1]+now;//转移
	}
	cin>>q;
	while(q--)
	{
		int h,ans=1e18;
		scanf("%lld",&h);
		int l=-1,r=a[n]+1;
		while(l+2<r)//三分
		{
			int mid1=l+(r-l)/3,mid2=r-(r-l)/3;
			if(g(mid1,h)<g(mid2,h))r=mid2;
			else l=mid1;
		}
		printf("%lld ",g(l+1,h));
	}
	return 0;
}
```

---

## 作者：lao_wang (赞：3)

## 前言

错误方法千千万，不看范围占一半。（$a_i$ 可以为 0）

## 正文

有题可得：若已知方式一与方式二的数量，则任意满足数量的方案排列均不会影响答案。

我们就可以假设先统一拉窗帘再单个拉窗帘。

所以现在需要解决的问题是：如何找到这两种方式的分界点。

令 $f(x)$ 表示统一拉了 $x$ 次窗帘后需要的贡献和，$g(x)$ 表示单独拉了所有不满足题意的窗帘 $\min(a_i-h,x)$ 次需要的贡献和，$sum_i$ 表示高度小于等于 $i$ 的高度和，$cnt_i$ 表示高度小于等于 $i$ 的数量和，当前高度限制为 $h$。

$\because$ $f(x)=f(x-1)+s+r \times k$ 中 $s$,$k$ 为常数，$r\times k$ 单调不降。

$\therefore$ $f(x)$ 单调递增，$f(x)-f(x-1)$ 单调不降。

$\because g(x)=g(x-1)+(sum_{\max a_i}-sum_{h+x}-(x-1)\times (cnt_{\max a_i}-cnt_{h+x}))\times t$，$sum_{\max {a_i}}-sum_{h+x}-(x-1)\times (cnt_{\max a_i}-cnt_{h+x})$ 单调递减。

$\therefore$ $g(x)$ 单调递增，$g(x)-g(x-1)$ 单调递减。

$\because f(x)$ 与 $g(x)$ 有单调性且 $sum_{\max {a_i}}-sum_{h+x}-(x-1)\times (cnt_{\max a_i}-cnt_{h+x})$ 单调递减，$r\times k$ 单调不降。

$\therefore$ 若 $f(x)$ 与 $g(x)$ 有交汇则必是一个点，后 $g(x)-g(x-1)$ 必优于 $f(x)-f(x-1)$。

交汇处就是两种方式的分界点。

二分斜率得到交汇处的函数值就可以得到答案了。

复杂度 $O(q \log V)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define N 1123451
#define mk(a,b) make_pair(a,b)
#define int __int128 
using namespace std ;
int n , t , s , k , sum[N] , a[N] , more[N] , q , ans , maxn , tr[N] ;
bool check(int x,int h){
	ans = min(ans,sum[x]+(tr[maxn]-tr[h+x]-(x+h)*(more[maxn]-more[h+x]))*t) ;
	return sum[x]-sum[x-1]<=(more[maxn]-more[x+h-1])*t ;
}
int read() {
	int x=0 ;
	char a=getchar() ;
	while(!(a>='0'&&a<='9')) a=getchar() ;
	while(a>='0'&&a<='9') {
		x *= 10 ;
		x += a-'0' ;
		a = getchar() ;
	}
	return x ;
}
void write(int x){
	if(x>9) write(x/10) ;
	putchar(x%10+'0') ;
}
signed main() {
	n = read() , t=read() , s=read() , k=read() ;
	for(int i=1; i<=n; i++) a[i]=read() , more[a[i]]++ , maxn = max(maxn,a[i]) , tr[a[i]] += a[i] ;
	s += more[0]*k ;
	for(int i=1; i<=maxn; i++) {
		sum[i] = sum[i-1]+s ;
		s += more[i]*k ;
	}
	for(int i=1;i<=maxn;i++) more[i] += more[i-1] , tr[i] += tr[i-1] ; 
	q = read() ;
	for(int i=1; i<=q; i++) {
		int h=read() ;
		ans = (tr[maxn]-tr[h]-h*(more[maxn]-more[h]))*t ;
		int l=1 , r=maxn-h ;
		while(l<=r){
			int mid=(l+r)>>1 ;
			if(check(mid,h)) l = mid+1 ;
			else r = mid-1 ;
		}
		if(ans<0) ans=0 ;
		write(ans) ;
		putchar(' ') ;
	}
	return 0 ;
}
```

## 修改

2025.4.24 修改 $g(x)$ 的定义。

2025.4.25 修改一处错误（函数和斜率代表的意思）。

---

## 作者：TheBian (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P10260)

考虑到在能一起向上拉的情况下单独拉是不优的，所以要先考虑一起拉再单独拉。

我们先将所有询问离线下来，根据需要拉的高度排序，高度高的放前面（题中是离顶部的距离，所以从小到大），我们考虑一起拉动的距离 $f$ ，当总体需要拉升的高度降低时（即到了下一个询问），不难发现 $f$ 是递减的，所以相当于 $O(n)$ 计算每一个 $f$。

对于每一个 $f$ ，考虑如何计算答案，答案就是一起拉的时间 $+$ 单独拉的时间，可以二分找到所有（一起拉后还没到达询问高度/一起拉的过程中有减慢贡献）的窗帘计算，时间复杂度 $O(\log n)$。

总体时间复杂度 $O(n\log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,s,k,T;
long long a[100005],ans[100005],sum[100005];
struct Node{
	long long h,id;
}q[100005];
bool cmp(Node x,Node y){
	return x.h<y.h;
}
long long check(long long h,long long x){//h表示需要到达的高度,x表示一起拉的次数 
	while(T>=1&&a[T]-x>=0) T--;//T表示一起拉的过程中会撞顶的个数 
	long long res=x*s+(T*x-sum[T])*k;
	long long l=T+1,r=n,mid=0,p=0;//二分找到需要单独拉的窗帘 
	while(l<=r){
		mid=(l+r)>>1;
		if(a[mid]-x>=h) p=mid,r=mid-1;
		else l=mid+1;
	}
	if(p!=0){
		res+=t*(sum[n]-sum[p-1]-(h+x)*(n-p+1));
	}
	return res;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>t>>s>>k;
	T=n;
	for(long long i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);//按高度排序 
	for(long long i=1;i<=n;i++){//前缀和方便计算 
		sum[i]=sum[i-1]+a[i];
	}
	long long Q;
	cin>>Q;
	for(long long i=1;i<=Q;i++){//离线 
		cin>>q[i].h;
		q[i].id=i;
	}
	sort(q+1,q+Q+1,cmp);//按需要拉的高度从小到大排序 
	long long f=a[n],minn;//一起拉的高度，当前耗费时间最小值 
	for(long long i=1;i<=Q;i++){
		minn=check(q[i].h,f);
		while(f>0){//枚举最优的f 
			int y=T;
			long long x=check(q[i].h,f-1);
			if(x>minn){
				T=y;
				break;
			}
			f--;
			minn=x;
		}
		ans[q[i].id]=minn;
	}
	for(long long i=1;i<=Q;i++){
		cout<<ans[i]<<' ';
	}
	return 0;
} 
```

---

## 作者：zhangshirui (赞：1)

显然，你如果想要最优，那么你每次手拉的一定是当前最长的。

然后就有：你在知道手拉和按钮拉的数量且只靠手拉不会让任何一个原来长于要求窗帘的长度降到**小于**要求从的情况下，你怎么按排顺序答案是一样的。因为你按按钮的次数只和最高的高度有关，那么你如何排序对它的次数都没有影响，并且你手拉肯定不会使卡死的变多，实在理解不了自己思考一下。

上面的结论有什么用呢？因为用按钮的次数只和最高的有关，所以我们考虑去枚举最高高度，然后把高于它的全部手拉了，剩余的用按钮，在知道手拉次数和目标高度时，答案显然可以在预处理之后 $O(1)$ 来计算的，计算方式见代码。但是你每个询问还要遍历高度实在太慢了，我们把他写成函数形式，$x$ 为手动拉之后最高高度且 $x\ge h$，$sum$ 为高度大于 $x$ 的高度和，$cnt$ 为高度大于 $x$ 的数量：$y=t\cdot(sum-cnt\cdot x )+f(x-h)$，其中 $f$ 为按若干次按钮的代价，不难发现这是个单谷函数，直接上三分找 $x$。

但是这还不是最优的解法,考虑优化找 $x$，还是根据上面的函数，不难发现当 $h$ 减小时，$y$ 的最优取值位置 $x$ 在不断增加，也就是说给 $h$ 从大到小排序和 $x$ 时单调不降的，那么我们不断考虑看让 $x$ 减一是否更优即可。

去掉排序时间复杂度 $O(n)$，但是这里值域与 $n$ 同阶，可以直接用桶，时间复杂度 $O(n)$

代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,t,s,k,a[100005],partans[100005],q,h[100005],id[100005],ans[100005],sum[100005],tong[100005],hd,pos;
ll getans(int len){//按len次按钮的答案 
	if(len<0)return 0;
	return partans[len];
}
template<typename T>
void tong_sort(ll* l,ll* r,T f){//桶排序，去掉排序的log，f表示基于什么，具体用法看下面 
	memset(tong,0,sizeof(tong));
	for(int i=0;i<r-l;i++)tong[f(l[i])]++;
	vector<ll> v(r-l);
	for(int i=1;i<=100000;i++)tong[i]+=tong[i-1];
	for(int i=0;i<r-l;i++)v[--tong[f(l[i])]]=l[i];
	for(int i=0;i<r-l;i++)l[i]=v[i];
}
void init(){//预处理出按钮拉若干次的答案 
	int pos=0;
	for(int len=1;len<=100000;len++){
		while(pos<n&&len>a[pos])pos++;//如果次数大于高度，那么就计入拉到底的数量 
		partans[len]=partans[len-1]+s+pos*k;//递推求值 
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>t>>s>>k;
	pos=n;//[pos,n)是被手动削平的 
	for(int i=0;i<n;i++)cin>>a[i];
	tong_sort(a,a+n,[](ll x){return x;});//对a排序，简化计算 
	for(int i=n-1;~i;i--)sum[i]=sum[i+1]+a[i];
	hd=a[n-1];//最开始手动拉完最高的就是当前最高的 
	init();//把按按钮的贡献预处理了 
	cin>>q;
	for(int i=0;i<q;i++)cin>>h[i],id[i]=i;
	tong_sort(id,id+q,[](ll x){return h[x];});//记录这个询问原来是第几个 
	tong_sort(h,h+q,[](ll x){return x;});//对h排序没说的 
	for(int i=q-1;~i;i--){
		if(h[i]>=a[n-1])continue;//没必要拉直接不处理 
		while(pos&&a[pos-1]>=hd)pos--;//把会被影响的部分更新 
		while(getans(hd-h[i])+(sum[pos]-hd*(n-pos))*t>getans(hd-h[i]-1)+(sum[pos]-(hd-1)*(n-pos))*t&&hd>0){//看减一之后和现在哪个更优 
			hd--;//如果更优则更新 
			while(pos&&a[pos-1]>=hd)pos--;//中途被拉的也要更新以免41行错误 
		}
		ans[id[i]]=getans(hd-h[i])+(sum[pos]-hd*(n-pos))*t;//记录答案 
	}
	for(int i=0;i<q;i++)cout<<ans[i]<<' ';//输出 
}
//完结撒花 
```

然后这题就做完了，撒花！

---

## 作者：ZHONGZIJIE0608 (赞：0)

考试考的，思路非常猎奇，但是最终手切了。  
首先考虑第一个部分分。看着类似 DP，考虑我们需要什么信息来作为一个「状态」。由于在后面（时间上）按下按钮的时候已经完全拉起的窗户的个数不少于前面（时间上）按下按钮的（因为窗帘只会被拉起而不会被放下），考虑首先按若干次按钮，后手动拉窗帘。设 $DP(i)$ 表示按下按钮的次数为 $i$ 次时的最小费用（仅仅计算按按钮锁贡献的费用）。依据题意即可转移。之后我们考虑在已经累加的按钮之后计算单独的贡献费用，对于每一个高度要分开计算费用。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
const int INF=1e13;
int dp[N],n,t,s,k,q,a[N],h[N],m,p[N];
signed main(){
    //freopen("data.in","r",stdin);
    //freopen("jury.out","w",stdout);
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>n>>t>>s>>k;
    for(int i=1;i<=n;++i)cin>>a[i],m=max(m,a[i]),p[i]=a[i];
    for(int i=0;i<=m;++i)h[i]=INF;
    for(int i=1;i<=m;++i){
        int tmp=0;
        for(int i=1;i<=n;++i)if(!a[i])++tmp;
        dp[i]=dp[i-1]+(s+tmp*k);
        for(int i=1;i<=n;++i)if(a[i])--a[i];
    }
    for(int i=1;i<=n;++i)a[i]=p[i];
    for(int i=0;i<=m;++i){
        for(int H=0;H<=m;++H){
            int tmp=0;
            for(int j=1;j<=n;++j)if(a[j]>H)tmp+=(a[j]-H)*t;
            h[H]=min(h[H],dp[i]+tmp);
        }
        for(int i=1;i<=n;++i)if(a[i])--a[i];
    }
    cin>>q;
    while(q--){
        int H;cin>>H;
        H=min(m,H);
        cout<<h[H]<<' ';
    }
    return 0;
}
```
令 $M$ 为最大的 $A_i$，则时间复杂度 $O(NM^2)$。

再来考虑第二个部分分。如果使用按钮不会因为具体的行内被删除完的个数作额外的费用，我们就可以对于每一行（同一高度）单独考虑其对答案的贡献。为了计算方便，我是首先从高度大的往小的考虑的。那么这一行里面高度存在（不低于当前高度）的窗帘的个数 $x$ 和 $t$ 的积就是我们单独处理这一行的值的贡献。而 $s$ 是我们同时处理这一行的贡献。发现我们只需要取 $\min(tx,s)$ 即可。$x$ 的计数可以通过排序后用一个指针去计数快速得到。总复杂度为 $O(n \log n)$，瓶颈在排序。

考虑第三个部分分。只有一组询问，考虑目标序列长什么样子。发现按照行单独处理这个思路是正确的。

考虑正解。我们发现对于每一行使用按钮所增加的费用是确定的。设这一行内有 $tmp$ 个元素**不存在**（因为排序计数时用这个更为方便），则这一行删除的费用是 $\min(s+k \times tmp,(n-tmp) \times t)$。

写完这一步，综合部分分二的顺序写完跑对拍，发现有问题。**由于高度为 $M$ 的最高的那一列要删除为高度为 $H$ 的需要删除恰好 $P=\max(0,M-H)$ 次，我们并不需要考虑具体的行的删除序列，因为每一行都可以直接删除，删除之后不会出现窗帘高度不能表示为直方图的情况**。所以我们只需要考虑把每一行的贡献排序求前缀和 $S_i$，每到求高度为 $H$ 的时候直接求 $S_P$ 即可。时间复杂度 $O(n \log n)$。

考试不给大样例（感觉不是很有道理），对着部分分一的代码跑 $1000$ 次对拍，没有任何问题。那么想必是过了吧。那么确实是过了。

但是即使给了大样例，也要对拍来 Hack 自己的解法。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
const int INF=1e13;
int dp[N],n,t,s,k,q,a[N],h[N],m,p[N];
signed main(){
   // freopen("curtain.in","r",stdin);
   // freopen("curtain.out","w",stdout);
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>n>>t>>s>>k;
    for(int i=1;i<=n;++i)cin>>a[i],m=max(m,a[i]),p[i]=a[i];
    sort(a+1,a+1+n);
    int tmp=0;a[n+1]=INF;
    for(int i=1;i<=m;++i){
        while(tmp<=n && a[tmp+1]<i)++tmp;
        h[i]=min(s+k*(tmp),(n-tmp)*t);
    }
    sort(h,h+1+m);
    for(int i=1;i<=m;++i)h[i]+=h[i-1];
    cin>>q;
    while(q--){
        int H;cin>>H;
        H=min(m,H);
        cout<<h[m-H]<<' ';
    }
    return 0;
}
/* 
3 2 5 1 2 2 4 3 2 0 1
*/
```

---

## 作者：huangrenheluogu (赞：0)

贪心考虑，如果先用手拉，然后按按钮，这样会导致有些更多的窗帘顶到。因此最优策略形如按下 $t_0$ 秒按钮，再逐个将没有达到的窗帘拉上去。

考虑第 $i+1$ 秒是否应该结束按按钮。$cnt_i$ 表示按 $i$ 秒按钮之后剩余没有拉到指定高度的窗帘数量，$T_i$ 表示第 $i+1$ 秒按按钮拉 $1$ 厘米的时间。显然应该比较 $T_i$ 与 $cnt_it$ 的大小关系，贪心选择。

这里随着 $i$ 的增大，$cnt_i$ 是不增的，而 $T_i$ 是不降的，可以二分出分界点解决。对于 $q$ 次询问，发现加了 $h$ 的限制之后 $cnt$ 会平移，$T$ 不变，仍然可以二分。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid (l + r >> 1)
using namespace std;
const int N = 1e5 + 5, maxn = 1e5;
int n, t, s, k, a[N], q, ans[N], d[N], f[N], l, r, pos;
int sd[N], sf[N], x;
signed main(){
    // freopen("curtain.in", "r", stdin);
    // freopen("curtain.out", "w", stdout);
    scanf("%lld%lld%lld%lld", &n, &t, &s, &k);
    for(int i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
        d[a[i]]++;
        f[0] += t;
        f[a[i]] -= t;
    }
    for(int i = 1; i <= maxn; i++){
        d[i] += d[i - 1];
        f[i] += f[i - 1];
    }
    d[0] = d[0] * k + s;
    sd[0] = d[0], sf[0] = f[0];
    for(int i = 1; i <= maxn; i++){
        d[i] = d[i] * k + s;
        sd[i] = sd[i - 1] + d[i];
        sf[i] = sf[i - 1] + f[i];
    }
    // for(int i = 0; i <= maxn; i++){
    //     printf("%lld %lld %lld\n", i, f[i], d[i]);
    // }
    for(int i = 0; i <= maxn; i++){
        if(f[i] <= d[0]){
            if(i == 0) ans[i] = sf[maxn];
            else ans[i] = sf[maxn] - sf[i - 1];
            // cerr << i << endl;
            continue ;
        }
        pos = 0, l = 1, r = maxn - i;
        while(l <= r){
            if(f[mid + i] <= d[mid]){
                r = mid - 1;
            }
            else pos = mid, l = mid + 1;
        }
        // cerr << i << ' ' << pos << endl;
        ans[i] = sd[pos] + sf[maxn] - sf[i + pos];
    }
    scanf("%lld", &q);
    while(q--){
        scanf("%lld", &x);
        printf("%lld ", ans[x]);
    }
    puts("");
    return 0;
}
```

---

## 作者：大眼仔Happy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10260)

## upd on  2024.5.16 : 更新了 $O(n)$ 做法

决策单调性（应该是），考场上瞎几把猜到的，但是不敢写，因为不太会。

~~目前的题解都是机房里的其他大佬，我相信他们在 5.4 的模拟赛都是随便切掉这道题的。~~

我们可以发现对于每一个询问的操作顺序不会影响时间，所以说先整体操作，再单体操作。于是就大胆猜想这个整体的操作的次数是具有单调性的，在 $h$ 变小的时候单调不降。

假设整体操作的次数是 $c$，目标高度是 $h$，我们通过预处理出一些东西来 $O(1)$ 求出来时间 $w(c,h)$，比如预处理出整体操作的时间 $f_i$，然后再预处理出超过 $i$ 的部分的数量和数的总和这种姿势就可以了，具体可看看代码。然后套路分治即可做到 $O(n\log n)$。

证明的话使用反证法，考虑到 $h$ 变小到 $h'$（就是要拉的更多），如果所需要的**最优**整体操作次数 $t_{h'}<t_h$，那么就会推出矛盾，这样会发现 $h$ 也拉 $t_{h'}$ 次更优。于是得证。

但是说的很没意思，不妨自己试试。

第一次学习决策单调性是因为 [ABC348G](https://www.luogu.com.cn/problem/AT_abc348_g)，这个也可以试一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
#define ll long long
ll inline read()
{
	ll num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
ll n,t,s,k,m,q,a[N];
ll sum[N],cnt[N],f[N],ans[N];
void solve(int l,int r,int tl,int tr)
{
	if(l>r)return;
	int mid=l+r>>1,tm;
	ll mn=9e18;
	for(int i=tl;i<=tr;i++) // 一起拉的次数为 i, 目的是 mid 
	{
		ll res=f[i]+(sum[i+mid]-cnt[i+mid]*(i+mid))*t;
		if(res<mn)mn=res,tm=i;
	}
	ans[mid]=mn;
	solve(l,mid-1,tm,tr);
	solve(mid+1,r,tl,tm);
}
int main(){
	n=read();t=read();s=read();k=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		m=max(m,a[i]);
		cnt[a[i]]++;
		sum[a[i]]+=a[i];
	}
	for(int i=1,num=cnt[0];i<=m;i++)
	{
		f[i]=f[i-1]+num*k+s;
		num+=cnt[i];
	}
	for(int i=m;i>=1;i--)
	{
		cnt[i-1]+=cnt[i];
		sum[i-1]+=sum[i];
	}
	solve(0,m,0,m);
	q=read();
	while(q--)printf("%lld ",ans[read()]);
	return 0;
}
/*
cnt[i] 表示大于等于 i 的数量
sum[i] 表示大于等于 i 的总和 
f[i] 表示拉低 i 的高度的时间 
*/
```

------------

受 [ABC143F](https://www.luogu.com.cn/problem/AT_abc143_f) 的启发，回来这里思考一下有没有 $O(n)$ 做法。其实还是分治学傻了。我们发现这个东西是一个凸函数，于是有些做法就用的是三分，或者二分斜率。而我们的决策单调性直接就扫下来即可。

~~感觉没有快多少是怎么一回事？~~ 但是目前是 rk 1。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
#define ll long long
ll inline read()
{
	ll num=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=(num<<3)+(num<<1)+(ch^48);ch=getchar();}
	return num*f;
}
ll n,t,s,k,m,q,a[N];
ll sum[N],cnt[N],f[N],ans[N];
ll calc(ll c,ll d){return f[c]+(sum[c+d]-cnt[c+d]*(c+d))*t;} // 一起拉的次数为 c, 目的是 d
int main(){
	n=read();t=read();s=read();k=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		m=max(m,a[i]);
		cnt[a[i]]++;
		sum[a[i]]+=a[i];
	}
	for(int i=1,num=cnt[0];i<=m;i++)
	{
		f[i]=f[i-1]+num*k+s;
		num+=cnt[i];
	}
	for(int i=m;i>=1;i--)
	{
		cnt[i-1]+=cnt[i];
		sum[i-1]+=sum[i];
	}
	for(int i=0,opt=m;i<=m;i++)
	{
		while(opt&&calc(opt-1,i)<calc(opt,i))opt--;
		ans[i]=calc(opt,i);
	}
	q=read();
	while(q--)printf("%lld ",ans[read()]);
	return 0;
}
```

---

## 作者：g1ove (赞：0)

首先要注意到一个贪心，先操作总体的，再操作单个的。

首先先预处理出按 $x$ 次按钮需要的时间。

根据直觉，我们观察到一个显然的贪心：如果在 $x$ 按了 $p_x$ 次，那么在 $x-1$ 按的次数 $p_{x-1}\ge p_x$。反证即可证明。

直接上决策单调性优化即可。
时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 100005
using namespace std;
int n,t,s,k,m;
int q;
int a[N];
ll tim[N],sum[N*2],cnt[N*2];
ll res,cur;
ll ans[N];
void solve(int l,int r,int al,int ar)
{
	if(l>r) return;
	int mid=(l+r)/2,pos;
	ll res=1e18;
	for(int i=al;i<=ar;i++)
	{
		ll v=tim[i]+1ll*(sum[i+mid]-1ll*cnt[i+mid]*(i+mid))*t;
		if(v<res) res=v,pos=i;
	}
	ans[mid]=res;
	solve(l,mid-1,pos,ar);
	solve(mid+1,r,al,pos);
}
int main()
{
	scanf("%d%d%d%d",&n,&t,&s,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),m=max(m,a[i]),cnt[a[i]]++,sum[a[i]]+=a[i];
	cur=cnt[0];
	for(int i=1;i<=m;i++)
	{
		res+=1ll*cur*k+s;
		cur+=cnt[i];
		tim[i]=res;
	}
	for(int i=m;i>=0;i--) cnt[i]+=cnt[i+1],sum[i]+=sum[i+1];
	solve(0,m,0,m);
	scanf("%d",&q);
	while(q--)
	{
		int x;
		scanf("%d",&x);
		printf("%lld ",ans[x]);
	}
	return 0;
}
```

---


# 漫长悄悄话

## 题目背景

> 故事从哪一页起始？
>
> 小石头，红土地，遥远的火。
>
> 摸索的轮廓，夜空之中，扑火的人。
>
> 手与手的相握，心与心碰触。
>
> 涌动在喉咙深沉，我温暖的火。 

## 题目描述

一些前置定义：

- $\text{Rev}(S):$ $S_{|S|},S_{|S|-1},\dots,S_1$ 顺次相连形成的字符串。即将 $S$ 翻转。

- $\text{lcp}(i,j):$ 第 $i$ 个位置开始的后缀与第 $j$ 个位置开始的后缀的最长公共前缀**对应的字符串**。

- $\text{lcs}(i,j):$ 第 $i$ 个位置结束的前缀与第 $j$ 个位置结束的前缀的最长公共后缀**对应的字符串**。

- $\text{LCP}(S,T):$ $S$ 和 $T$ 的最长公共前缀。
----

给出长度为 $n$ 的字符串 $S$，求：

$$\max\limits_{1 \le i < j \le n}\{\text{LCP}(\text{Rev}(\text{lcs}(i,j)),\text{lcp}(i,j))\}$$

## 说明/提示

### 样例一解释

$\text{lcp}(3,7):$ `bba`。

$\text{lcs}(3,7):$ `abb`。

$\text{LCP}(\text{Rev}(\texttt{\color{blue}abb}),\texttt{\color{blue}bba}):$ `bba`。

可以证明，没有比 $i=3,j=7$ 更优的方案。


### 数据范围与约束

对于 $30\%$ 的数据，$1 \le n \le 2\times 10^3$。

对于 $60\%$ 的数据，$1 \le n \le 10^5$。

对于另外 $10\%$ 的数据，$\forall 1 \le i \le n-2,S_{i}\not=S_{i+2}$。

对于 $100\%$ 的数据 $1 \le n \le 10^6$，输入均为整数和小写字母。

## 样例 #1

### 输入

```
9
abbbabbba```

### 输出

```
3```

# 题解

## 作者：L_zaa_L (赞：5)

## 分析
对于题目的限制，很容易想到如果是一个以这个位置为中点的回文串肯定是最好满足条件的，所以这个问题我们可以转换成找一个出现次数两次及以上的回文串的最大长度。

看到回文串，不难想到 manacher，我们可以对原串先跑一遍 manacher，然后现在我们需要判断有哪些回文串是相等的，我们发现长度有单调性，只要长的满足，短的也会满足，所以我们考虑二分长度，然后可以记录每个位置这个长度的 hash 值，然后再用 unordered map 就可以记录这个 hash 值是否出现过多次。

时间复杂度：$O(n\log n)$。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 2000005
using namespace std;
int n,p,mx,len[N];
int ans;
unsigned int f[N],Pow[N];//自然溢出
char a[N],b[N]; 
unordered_map<int,int> vis;
inline unsigned int g(int l,int r){
    return f[r]-f[l-1]*Pow[r-l+1];
}
inline bool check(int x){
    vis.clear();
    for(int i=1;i<=n;i++){
        if(x&1){
            if(len[i<<1]>=x){
                if(vis[g(i-(x>>1),i+(x>>1))]) return 1;
                vis[g(i-(x>>1),i+(x>>1))]=1;
            }
        }
        else{
            if(len[(i<<1)+1]){
                if(vis[g(i-(x>>1)+1,i+(x>>1))]) return 1;
                vis[g(i-(x>>1)+1,i+(x>>1))]=0;
            }
        }
    }
    return 0;
}
signed main(){
    scanf("%lld",&n);
	scanf("%s",a+1);
	for(int i=1;i<=n;i++){
		b[i<<1]=a[i];
		b[(i<<1)+1]='#';
	}
	b[0]='$';b[1]='#';b[n*2+2]='&';
	p=1,mx=1;
	for(int i=2;i<=2*n;i++){
		if(mx>=i) len[i]=min(len[2*p-i],mx-i);
		while(b[i+len[i]+1]==b[i-len[i]-1]) ++len[i];
		if(i+len[i]>mx) p=i,mx=i+len[i];
	}
	for(int i=1;i<=n;i++) f[i]=f[i-1]*131+(a[i]-'a');
    Pow[0]=1;
    for(int i=1;i<=n;i++) Pow[i]=Pow[i-1]*131;
    int l=0,r=n/2+1;
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid*2)) ans=mid*2,l=mid+1;
        else r=mid-1;
    }
    l=0,r=n/2+1;
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid*2+1)) ans=max(ans,mid*2+1),l=mid+1;
        else r=mid-1;
    }
    printf("%lld",(ans+1)/2);
	return 0;
}
```

---

## 作者：唐一文 (赞：2)

所求的就是最长的至少出现了两次的奇回文串：将 $i,j$ 看作回文中心即可。

用回文自动机容易解决，时间复杂度线性。[code](https://www.luogu.com.cn/paste/9s5aietk)

---

## 作者：xzf_200906 (赞：1)

不难发现，题目所求的答案相当于最长的出现至少两次的奇回文子串的回文半径。

考虑 Manacher，回忆 Manacher 算法的过程，对于一个中心所扩展出的回文半径，有两种来源：
1. 继承其对称点的回文半径，设继承的回文半径为 $r$，此时令答案 $ans\gets\max(ans,r)$。
2. 暴力扩展得到，将扩展出的回文串插入哈希表即可判断出现次数是否超过两次。

为什么这样做可以覆盖所有出现至少两次的奇回文子串？如果一个出现至少两次的奇回文子串没有在情况1中被统计，则其两次出现均是暴力扩展得到，并在情况2中被统计。

时间复杂度 $\mathcal{O}(n)$，似乎可以使用子序列自动机？

Code:

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int mod1=1000003,mod2=1000000007,p1=37,p2=31;
int head[1000050],nxt[1000000],val[1000000],tot=0;
bool insert(int h1,int h2){
	int p=head[h1];
	while(p){
		if(val[p]==h2) return 1;
		p=nxt[p];
	}
	nxt[++tot]=head[h1];
	val[tot]=h2;
	head[h1]=tot;
	return 0;
}
int hash1[1000005],hash2[1000005],pw1[1000005],pw2[1000005],w1[100],w2[100];
int getHash1(int l,int r){
	return (hash1[r]-1ll*hash1[l-1]*pw1[r-l+1]%mod1+mod1)%mod1;
}
int getHash2(int l,int r){
	return (hash2[r]-1ll*hash2[l-1]*pw2[r-l+1]%mod2+mod2)%mod2;
}
int rd[1000005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n,ans=0;
	string s;
	cin>>n>>s;
	s='@'+s+'#';
	pw1[0]=pw2[0]=1;
	mt19937 random(time(0));
	for(int i=1;i<=p1;i++) w1[i]=i;
	for(int i=1;i<=p2;i++) w2[i]=i;
	shuffle(w1+1,w1+p1+1,random);
	shuffle(w2+1,w2+p2+1,random);
	for(int i=1;i<=n;i++){
		hash1[i]=(1ll*hash1[i-1]*p1+w1[s[i]-'a'+1])%mod1;
		hash2[i]=(1ll*hash2[i-1]*p2+w2[s[i]-'a'+1])%mod2;
		pw1[i]=1ll*pw1[i-1]*p1%mod1;
		pw2[i]=1ll*pw2[i-1]*p2%mod2;
	}
	int p=0,mx=0;
	for(int i=1;i<=n;i++){
		if(mx>=i) rd[i]=min(rd[2*p-i],mx-i+1);
		ans=max(ans,rd[i]);
		while(s[i+rd[i]]==s[i-rd[i]]){
			if(insert(getHash1(i,i+rd[i]),getHash2(i,i+rd[i])))
				ans=max(ans,rd[i]+1);
			rd[i]++;
		}
		if(i+rd[i]-1>mx){
			mx=i+rd[i]-1;
			p=i;
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：sunkuangzheng (赞：1)

$\textbf{P10271}$

> - 定义 $f(i,j)$ 为后缀 $i,j$ 的最长公共前缀字符串，$g(i,j)$ 为前缀 $i,j$ 的最长公共后缀字符串，求 $\max\limits_{i < j}\{\operatorname{LCP}(f(i,j),g(i,j)^R)\}$。
> - $1 \le n \le 10^6$。

同一端点正串反串求 $\operatorname{LCP}$ 容易联想到回文。设 $p_i$ 表示位置 $i$ 为中心的回文半径，$\operatorname{LCP}(f(i,j),g(i,j)^R)$ 实际上就是 $\min(|f(i,j)|,p_i,p_j)$。

看到两个后缀的 $\operatorname{LCP}$ 很难不想到后缀数组。建出 $ht$ 数组，那么 $|f(sa_i,sa_j)| = \min\limits_{k=i+1}^j\{ht_i\}$。按排名从小到大加入后缀，考虑新加入的排名为 $i$ 的串时和前面后缀 $sa_j$ 的 $\operatorname{LCP}$ 的两种情况：$|f(sa_j,sa_i)| = ht_i$ 或 $|f(sa_j,sa_i)| < ht_i$，而这两种情况存在一个分界点 $k$，容易单调栈找出。

对于第一种情况，我们显然会贪心的选择 $k \sim i$ 中回文半径最大的一个。对于第二种情况，我们发现是一个子问题，可以对每个位置维护 $res_i$ 表示 $\max\limits_{j < i}\{\min(|f(sa_j,sa_i)|,p_j)\}$ 后直接得到。

时间复杂度 $\mathcal O(n \log n)$，瓶颈在第一种情况的 ST 表。

---

## 作者：modfish_ (赞：0)

## 思路
不妨令 $pre_i$ 表示以 $i$ 为结尾的前缀，$suf_i$ 表示以 $i$ 为开头的后缀。令 $\text{lcp},\text{lcs}$ 支持字符串运算，$\text{lcp}(a,b)$ 表示串 $a,b$ 的最长公共前缀，$\text{lcs}(a,b)$ 表示串 $a,b$ 的最长公共后缀。

题目即求：

$$
\begin{aligned}
&\max_{1\le i<j\le n}\{\text{LCP}(\text{Rev}(\text{lcs}(pre_i,pre_j)),\text{lcp}(suf_i,suf_j))\}\\
=&\max_{1\le i<j\le n}\{\text{LCP}(\text{lcp}(\text{Rev}(pre_i),\text{Rev}(pre_j)),\text{lcp}(suf_i,suf_j))\}\\
=&\max_{1\le i<j\le n}\{\text{LCP}(\text{lcp}(\text{Rev}(pre_i),suf_i),\text{lcp}(\text{Rev}(pre_j),suf_j))\}\\
\end{aligned}
$$

容易发现 $\text{lcp}(\text{Rev}(pre_i),suf_i)$ 就是以 $i$ 为中心的最长回文串。

所以，题目要求的就是一个最长的、出现了至少两次的回文串。

于是我们使用 PAM，每次遍历到的节点记一下，最后在后缀链接树上对子树求和，就得到了每个回文串的出现次数。时间复杂度 $O(n)$。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e6 + 5;

char s[maxn];
int ans = 0;

namespace PAM{
int now = 0, id = 0;
int tr[maxn][26], fail[maxn], len[maxn], tot = 1;
int d[maxn], sum[maxn];
char str[maxn];
vector<int> G[maxn];

void init(){
	len[0] = -1;
}
int getfail(int x){
	while(str[id - len[x] - 1] != str[id]) x = fail[x];
	return x;
}
void insert(char c){
	str[++ id] = c;
	int x = getfail(now);
	if(!tr[x][c - 'a']){
		tot ++;
		len[tot] = len[x] + 2;
		fail[tot] = tr[getfail(fail[x])][c - 'a'];
		tr[x][c - 'a'] = tot;
	}
	now = tr[x][c - 'a'];
	d[now] ++;
}
void build(){
	for(int i = 1; i <= tot; i ++) G[fail[i]].push_back(i);
}
void get(int x){
	sum[x] = d[x];
	for(int i = 0; i < G[x].size(); i ++){
		int j = G[x][i];
		get(j);
		sum[x] += sum[j];
	}
	if(sum[x] > 1 && len[x] & 1) ans = max(ans, (len[x] + 1) / 2);
}}

int main(){
	int n;
	scanf("%d", &n);
	scanf("%s", s + 1);
	PAM::init();
	for(int i = 1; i <= n; i ++) PAM::insert(s[i]);
	PAM::build();
	PAM::get(0);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Arghariza (赞：0)

先对每个 $i$ 求出回文半径，然后考虑对于任意一对 $(i,j)$，$\text{LCP}(\text{Rev}(\text{lcs}(i,j)),\text{lcp}(i,j))$ 其实就是以 $i$ 和 $j$ 为回文中心的最大子串的长度除以 $2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/k91oec28.png)

如上图，粉色部分相同，$S_i+S_i^R$ 和 $S_j+S_j^R$ 为以 $i$ 和 $j$ 为中心的最长回文串。

于是二分答案 $l$，先对每个回文半径 $\ge l$ 的 $i$ 求出 $[i-l+1,i+l-1]$ 子串的哈希值，然后判断有没有相同的即可。

复杂度 $O(n\log^2 n)$ 或者 $O(n\log n)$。

```cpp
// Problem: U395109 漫长悄悄话
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/U395109?contestId=155684
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define eb emplace_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

const int N = 1e6 + 100;
const ull B = 31;

int n, mr, len, md, ans, w[N], p[N << 1];
ull h[N], pw[N];
char s[N], t[N << 1];

ull hsh(int l, int r) {
	return h[r] - h[l - 1] * pw[r - l + 1];
}

bool chk(int x) {
	unordered_map<ull, bool> S;
	for (int i = x; i <= n - x + 1; i++) {
		if (w[i] >= x) {
			ull tp = hsh(i, i + x - 1);
			if (S.find(tp) != S.end()) return 1;
			S[tp] = 1;
		}
	}
	return 0;
}

void solve() {
	cin >> n >> (s + 1);
	pw[0] = 1, t[++len] = '~', t[++len] = '#';
	for (int i = 1; i <= n; i++) t[++len] = s[i], t[++len] = '#';
	t[++len] = '!';
	for (int i = 2; i <= len - 1; i++) {
		if (i <= mr) p[i] = min(p[2 * md - i], mr - i + 1);
		else p[i] = 1;
		while (t[i - p[i]] == t[i + p[i]]) p[i]++;
		if (p[i] + i > mr) mr = p[i] + i - 1, md = i;
		if (i & 1) w[i >> 1] = p[i] / 2;
	}
	for (int i = 1; i <= n; i++)
		pw[i] = pw[i - 1] * B, h[i] = h[i - 1] * B + (s[i] - 'a' + 1);
	int l = 1, r = n, res = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (chk(mid)) res = mid, l = mid + 1;
		else r = mid - 1;
	}
	cout << res << '\n';
}

bool Med;
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Med - &Mbe) / 1048576.0 << " MB\n";
	#ifdef FILE
		freopen(".in", "r", stdin);
		freopen(".out", "w", stdout);
	#endif
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：_lgh_ (赞：0)

感觉考场上脑子不够用了写个 PAM。

首先容易证明 $\text{Rev}(\text{lcs}(i,j))$ 和 $\text{lcp}(i,j)$ 肯定都是以 $i,j$ 为中心的回文串。那么这个就变成
求最长回文串半径使得这个回文串出现次数 $\ge 2$。这玩意直接用 manacher 求就是线性的。当然你也可以用 PAM 求，每次维护一下 endpos 就行。

感觉不卡线性对数还是太抽象了。

给一个赛时 PAM 代码。

```cpp
void solve() {
    rd(n);
    scanf("%s",s+1);
    for(int i=1; i<=n; i++) {
        ins(s[i]-'a',i);
        siz[epos]++;
    }
    for(int i=cnt; i; i--) siz[t[i].fail]+=siz[i];
    int res=0;
    for(int i=1; i<=cnt; i++) if(siz[i]>=2&&t[i].len&1)gmax(res,(t[i].len+1)/2);
    cout<<res<<'\n';
}
```

---

## 作者：rzh123 (赞：0)

提供一个不需要记性质的做法  
设 $F(i,j)=\text{LCP}(\text{Rev}(\text{lcs}(i,j)),\text{lcp}(i,j))$。  

![](https://cdn.luogu.com.cn/upload/image_hosting/1zammr87.png)
如果 $F(i,j)$ 是图中的 $|A|+1+|B|$，$|A|=|B|$，则 $A=\text{Rev}(B)$，所以 $A+S_i+B$ 是一个奇回文串。  

设 $p_i$ 为以 $i$ 为中心的最长回文半径，可以知道 $F(i,j)\le p_i$。  

先二分答案 $\text{lim}$，对于每个 $i$，如果 $p_i\lt \text{lim}$ 则不可能在 $i$ 处产生答案；$p_i\ge \text{lim}$ 时，$A+S_i+B$ 就是以 $i$ 为中心的半径为 $\text{lim}$ 的回文串，在图上可以发现，$j$ 合法当且仅当以 $j$ 为中心的半径为 $\text{lim}$ 的回文串也等于 $A+S_i+B$，即 $S_{[j-\text{lim}+1,j+\text{lim}-1]}=S_{[i-\text{lim}+1,i+\text{lim}-1]}$，只需要查询有没有这样的左端点 $(j-\text{lim}+1)$，它开头的后缀与 $(i-\text{lim}+1)$ 开头的后缀的 $\text{LCP}$ 大于等于 $(2\times \text{lim}-1)$，只需要查询后缀数组上与 $(i-\text{lim}+1)$ 相邻的两个后缀就可以。  

时间复杂度 $O(n\log n)$。  

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N=2e6+15;
int n,len,sa[N],rk[N],id[N],rkid[N],o[N],cnt[N],rrk[N],pal[N],h[N];
int tol[N],tor[N],rtol[N],rtor[N];
char s[N],s2[N];
void getsa(const char *s){
	int n=strlen(s+1),m{127},p{0};
	memset(cnt,0,(m+1)*sizeof(int));
	for(int i{1};i<=n;++i) ++cnt[rk[i]=s[i]];
	for(int i{1};i<=m;++i) cnt[i]+=cnt[i-1];
	for(int i{n};i>=1;--i) sa[cnt[rk[i]]--]=i;
	memcpy(o+1,rk+1,n*sizeof(int)),p=0;
	for(int i{1};i<=n;++i) rk[sa[i]]=(o[sa[i]]==o[sa[i-1]])?p:++p;
	for(int w{1};w<n;w<<=1,m=p){
		p=0;
		for(int i{n};i>n-w;--i) id[++p]=i;
		for(int i{1};i<=n;++i) if(sa[i]>w) id[++p]=sa[i]-w;
		memset(cnt,0,(m+1)*sizeof(int));
		for(int i{1};i<=n;++i) ++cnt[rkid[i]=rk[id[i]]];
		for(int i{1};i<=m;++i) cnt[i]+=cnt[i-1];
		for(int i{n};i>=1;--i) sa[cnt[rkid[i]]--]=id[i];
		memcpy(o+1,rk+1,n*sizeof(int)),p=0;
		auto c=[&w](int i){return o[sa[i]]==o[sa[i-1]]&&o[sa[i]+w]==o[sa[i-1]+w];};
		for(int i{1};i<=n;++i) rk[sa[i]]=c(i)?p:++p;
		if(p==n) break;
	}
	memset(o+1,0,n*sizeof(int));
    for(int i{1},j{0};i<=n;++i){
        if(rk[i]==1){h[rk[i]]=0;continue;}
        if(j) --j;
        while(s[i+j]==s[sa[rk[i]-1]+j]) ++j;
        h[rk[i]]=j;
    }
}
void manacher(const char *s){
	static int p[N];
   static char ss[N];
	int len{0};
	ss[0]='@';
	ss[++len]='|';
	for(int i{1};i<=n;++i) ss[++len]=s[i],ss[++len]='|';
	ss[len+1]=0;
	int mid{0},r{0};
	for(int i{1};i<=len;++i){
		if(i<=r) p[i]=min(p[mid*2-i],r-i+1);
		else p[i]=1;
		while(ss[i-p[i]]==ss[i+p[i]]) ++p[i];
		if(i+p[i]-1>r) r=i+p[i]-1,mid=i;
		if(ss[i]!='|') pal[(i+1)>>1]=(p[i]+1)/2;
	}
}
bool check(int val){
    if(!val) return true;
    for(int i{1};i<=n;++i){
        if(pal[i]>=val){
            int t{i-val+1};
            if(rk[t]>1&&h[rk[t]]>=2*val-1) return true;
            if(rk[t]<n&&h[rk[t]+1]>=2*val-1) return true;
        }
    }
    return false;
}
int main(){
    scanf("%d%s",&n,s+1);
    manacher(s);
    len=0;
    getsa(s);
    int l{0},r{n},mid;
    while(l<r){
        mid=(l+r+1)>>1;
        if(check(mid)) l=mid;
        else r=mid-1;
    }
    printf("%d\n",l);
    return 0;
}
```

---

## 作者：MaxBlazeResFire (赞：0)

仔细阅读复杂的题面，我们发现出题人简约地告诉我们，求原串中最长的出现了至少两次的奇回文串。

于是对原串建 SAM，然后跑一个 manacher，对所有本质不同的奇回文串放到 link 树上去倍增定位，看 endpos 集合大小是否 $\geq 2$ 即可。

复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAXN 2000005

int N = 0,lst = 1,nodecnt = 1,maxlen[MAXN] = {0},Link[MAXN] = {0},endpos[MAXN] = {0};
int nxt[MAXN][26] = {0},pos[MAXN] = {0};

char s[MAXN],t[MAXN];

inline void insert( int ch , int id ){
	int cur = ++nodecnt,p = lst; endpos[cur] = 1; pos[id] = cur;
	maxlen[cur] = maxlen[p] + 1;
	for( ; p && !nxt[p][ch] ; p = Link[p] ) nxt[p][ch] = cur;
	int q = nxt[p][ch];
	if( !q ) Link[cur] = 1;
	else if( maxlen[q] == maxlen[p] + 1 ) Link[cur] = q;
	else{
		int clone = ++nodecnt;
		maxlen[clone] = maxlen[p] + 1;
		memcpy( nxt[clone] , nxt[q] , sizeof( nxt[q] ) );
		for( int x = p ; x && nxt[x][ch] == q ; x = Link[x] ) nxt[x][ch] = clone;
		Link[clone] = Link[q],Link[q] = Link[cur] = clone;
	}
	lst = cur;
}

queue<int> Q;
int deg[MAXN] = {0},f[MAXN][18] = {0};
inline void topo(){
	for( int i = 1 ; i <= nodecnt ; i ++ ) if( Link[i] ) deg[Link[i]] ++;
	for( int i = 1 ; i <= nodecnt ; i ++ ) if( !deg[i] ) Q.push( i );
	while( !Q.empty() ){
		int u = Q.front(); Q.pop();
		endpos[Link[u]] += endpos[u];
		if( !--deg[Link[u]] ) Q.push( Link[u] );
	}
	for( int i = 1 ; i <= nodecnt ; i ++ ) f[i][0] = Link[i];
	for( int j = 1 ; j <= 17 ; j ++ )
		for( int i = 1 ; i <= nodecnt ; i ++ )
			f[i][j] = f[f[i][j - 1]][j - 1];
}

int r[MAXN] = {0},tlen = 0,mid = 0,rmax = 0,Ref[MAXN] = {0};
int Ans = 0;

inline void chk( int l , int r ){
	if( l < 1 || r > N ) return;
	int now = pos[r];
	for( int j = 17 ; j >= 0 ; j -- ){
		if( maxlen[f[now][j]] < r - l + 1 ) continue;
		now = f[now][j];
	}
	Ans = max( Ans , ( r - l + 1 ) * ( endpos[now] >= 2 ) );
}

signed main(){
	scanf("%d%s",&N,s + 1);
	for( int i = 1 ; i <= N ; i ++ ) insert( s[i] - 'a' , i ); topo();
	t[0] = '~';
	for( int i = 1 ; i <= N ; i ++ ) t[++tlen] = '#',t[++tlen] = s[i],Ref[tlen] = i;
	t[++tlen] = '#';
	for( int i = 1 ; i <= tlen ; i ++ ){
		if( i < rmax ) r[i] = min( r[mid * 2 - i] , rmax - i );
		chk( Ref[i - r[i]] , Ref[i + r[i]] );
		while( t[i - r[i] - 1] == t[i + r[i] + 1] ){
			r[i] ++;
			if( i % 2 == 0 ) chk( Ref[i - r[i]] , Ref[i + r[i]] );
		}
		if( i + r[i] > rmax ) rmax = r[i] + i,mid = i;
	}
	printf("%d\n",( Ans + 1 ) / 2);
	return 0;
}
```

---


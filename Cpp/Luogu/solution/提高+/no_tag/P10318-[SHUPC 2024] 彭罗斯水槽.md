# [SHUPC 2024] 彭罗斯水槽

## 题目描述

小 A 在上课时出现了幻觉，他幻想出了若干个水槽，它们环形排列，每一个水槽里的水都会流向下一个水槽（当然在现实里这是不可能的）。

于是小 A 开始思考这样一个问题：

有 $n$ 个水槽环形排列，每个水槽都有一个容量，初始时水都是满的。接下来每一秒，水槽 $i$ 的水全部转移到 $i+1$ （特殊的，第 $n$ 个水槽的水会转移到第 $1$ 个），如果转移的水超出了容量就会溢出。

现在他想知道，在接下来的 $1$ 至 $n$ 秒内，每一秒所有水槽的水量总和。

## 样例 #1

### 输入

```
5
3 2 5 4 3```

### 输出

```
14 12 11 10 10```

## 样例 #2

### 输入

```
6
171 814 2313 6676 196 897```

### 输出

```
3861 1719 1076 1051 1026 1026```

# 题解

## 作者：szh_AK_all (赞：37)

为什么楼下题解写的那么麻烦，我来一篇简单易懂的题解。

首先由于水槽是环形排列的，所以为了方便起见，将原序列复制一遍，这样便将环展开了。

### 部分代码
```cpp
int n;
cin >> n;
for (int i = 1; i <= n; i++)
	cin >> a[i];
for (int i = n + 1; i <= n + n; i++)
	a[i] = a[i - n];
```

接下来定义两个数组 $l,r$，其中 $l_i$ 表示左边第一个高度比 $a_i$ 小的水槽的位置，$r_i$ 表示右边第一个高度不比 $a_i$ 大的水槽的（这样定义的用处见下文可知，并且这样定义容易求出 $l,r$ 数组）。

考虑如何求得 $l$ 数组。

对于边界情况，即 $i=1$ 时，显然，由于 $i$ 左边没有水槽了，所以 $l_i=0$；那么对于 $i>1$ 的情况，首先可以得到如下暴力代码：
```cpp
for (int i = 2; i <= n; i++) {
  for (int j = i - 1; j >= 1; j--) {
    	if (a[j] < a[i]) {
          l[i] = j;
          break;
        }
  }
}
```
那么这种暴力方法的时间输在了哪里呢？假设水槽序列为 ```1 10000000 100000000 4 3 2```，那么在求答案过程中，第 $2,3$ 个位置会经过多次，但是显然，凭借肉眼观察也能得知，第 $2,3$ 个位置的水槽的高度太大了，对 $l$ 数组不会有贡献。

如上的例子便启发我们，可以尽量避开一些对答案不会有影响的位置。假设目前考虑到了第 $i-1$ 个位置的水槽的高度是否小于第 $i$ 个位置的水槽的高度，则分为两种情况：一、$a_{i-1}<a_{i}$，则直接更新 $l_i$ 即可；二、$a_{i-1}\ge a_{i}$，则开始考虑避开一些对答案不会有影响的位置。

反过头来看看 $l$ 的定义：$l_i$ 表示左边第一个高度比 $a_i$ 小的水槽的位置，那这是不是代表第 $i-1$ 至第 $l_i+1$ 个位置的水槽的高度都是不小于第 $i$ 个位置的水槽的高度？显然是的，又因为 $a_{i-1}\ge a_i$，所以 $a_k\ge a_i(i-1\ge k\ge a_{i-1})$，也就是说，第 $i-1$ 至第 $l_i+1$ 个位置的水槽对答案没有影响。那么可以一个个跳 $j$，若 $a_j<a_i$，则更新 $l_i$；否则，$j=l_j$。

求得 $r$ 数组的方法是类似的。

复杂度是均摊的。

部分代码：
```cpp
l[1] = 0;
for (int i = 2; i <= n + n; i++) {
	int x = i - 1;
	while (a[x] >= a[i] && x != 0)
		x = l[x];
	l[i] = x;
}//预处理左边第一个比a[i]小的
r[n + n] = n + n + 1;
for (int i = n + n - 1; i >= 1; i--) {
	int x = i + 1;
	while (a[x] > a[i] && x != 0 && x != n + n + 1)
		x = r[x];
	r[i] = x;
}//预处理右边第一个不比a[i]大的
```

接下来便是真正求答案的时刻了。

可以依次枚举每个位置对总答案产生的贡献，先来看个例子（也就是样例一）。
![](https://cdn.luogu.com.cn/upload/image_hosting/v1jj6ocu.png)

其中，黑色箭头指的是当前所考虑的 $i$ 为 $6$，黄色箭头指的是 $l_i=2$，蓝色箭头指的是 $r_i=7$，那么，可以发现，仅有绿色区域的水会在第 $r_i$ 个位置溢出，且这个绿色区域恰好是个矩形。那么，根据绿色区域的贡献，在第 $1$ 秒，水会溢出 $1$（也就是矩形的宽），在第 $2$ 秒水会再溢出 $1$，直到第 $4$（也就是矩形的长）秒，水一直会溢出 $1$。所以可以归纳出做法：

假设水溢出的值为其贡献值，则在计算每一秒所有水槽的水量总和时也就是用水起初的总量减去这一秒水的**总**贡献值。那么对于绿色区域，在第 $1$ 至第 $4$ 秒，水的**总**贡献值会逐渐增加一，这正好可以用二阶差分来处理。下面列出表格，方便观察差分数组（设 $c$ 为矩形的长，$k$ 为矩形的宽）。
| 数组/下标   |  $1$  |  $2$ | $\dots$ | $c$ | $c+1$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
|总贡献值变化数组     |$+k$ | $+2k$ | $\dots$ | $+ck$ | $+ck$ |
| 差分 $1$ | $+k$ | $+k$ |$+k$ | $+k$| $+0$|
|差分 $2$| $+k$ | $+0$| $+0$ |$+0$ | $-k$|

这样看便很直观了。

考虑如何求 $c,k$。

可以发现，矩形的长为 $r_i-l_i-1$（范围是 $l_i+1$ 至 $r_i-1$），那么宽呢（也可以看成是高）？观察图片可知，在绿色区域上方的 $3$ 格水并不会在 $r_i$ 这个位置溢出，也就是说，这个绿色区域的左右两边的高度应该是相同的（正好印证了绿色区域是个矩形），而绿色区域的宽则要最大化左右两边相同的高度（因为水可以溢出便一定会溢出）。

再来思考下 $l$ 数组的特性，在第 $l_i+1$ 至第 $i-1$ 个位置的水槽的高度不小与 $a_i$，而因为绿色区域的左边部分在 $l_i$ 的右上角，所以这也就代表了绿色区域的最低部分的高度高于 $a_{l_i}$；同理，对于 $r$ 数组，可以得知绿色区域的最低部分的高度高于 $a_{r_i}$。由于 $a_i$ 是在 $a_{l_{i}+1,l_{i}+2,\dots r_i-1}$ 中最小的，所以这代表绿色区域的最高部分不超过 $a_i$，由此，可以算出 $k$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[200005];
int l[200005], r[200005];
int ans[200005];

signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = n + 1; i <= n + n; i++)
		a[i] = a[i - n];
	l[1] = 0;
	for (int i = 2; i <= n + n; i++) {
		int x = i - 1;
		while (a[x] >= a[i] && x != 0)
			x = l[x];
		l[i] = x;
	}//预处理左边第一个比a[i]小的
	r[n + n] = n + n + 1;
	for (int i = n + n - 1; i >= 1; i--) {
		int x = i + 1;
		while (a[x] > a[i] && x != 0 && x != n + n + 1)
			x = r[x];
		r[i] = x;
	}//预处理右边第一个不比a[i]大的
	int tmp = 0;
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		if (a[i] < a[tmp] || tmp == 0)
			tmp = i;
		sum += a[i];
	}//找到高度最小的
	for (int i = tmp + 1; i <= tmp + n; i++) {
		if (a[i] == a[tmp])
			continue;
		//长方形的长：r[i]-l[i]-1；长方形的宽：a[i]-max(a[l[i]]+1,a[r[i]]+1)+1
		int chang = r[i] - l[i] - 1, kuan = a[i] - max(a[l[i]] + 1, a[r[i]] + 1) + 1;
		ans[1] += kuan;
		ans[chang + 1] -= kuan;
	}
	for (int i = 1; i <= n; i++)
		ans[i] += ans[i - 1];
	for (int i = 1; i <= n; i++)
		ans[i] += ans[i - 1];
	for (int i = 1; i <= n; i++)
		cout << sum - ans[i] << " ";
}
```
当然还有几个细节：
- 由于要计算每个水槽的贡献，所以应从长度为 $2n$ 的序列中截取长度为 $n$ 的子段。设子段的左端点是 $left$，右端点是 $left+n-1$，则应让 $a_{left-1}$ 最小，也代表着 $a_{left+n-1}$ 最小。使得遇到的 $r_i\le left\le 2n(a_i\ne a_{left-1})$，做到不错算贡献值。

- 若 $a_i=a_{left-1}$，则直接跳过该点。

路过的各位请给个赞吧！

---

## 作者：Dovish (赞：7)

## 题解
首先我们将环长度断成两倍长度的链。

然后很显然的一步转化就是对于第 $j$ 个点在第 $k$ 次后，还剩下 $\min_{j=i}^{i+k}a_j$ 的水。

我们就可以非常容易想到用 $f_j$ 表示从 $i$ 到 $j$ 的最小值，然后用单调栈转移到 $i-1$。

问题在于如何统计答案。

仔细分析一下，如果我们将每一个 $i$ 的求得的 $f$ 称为版本 $i$ 的 $f$。那我们要统计的答案大致如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/pmsqxv4o.png)

形式化为：$ans_k=\sum_{i=1}^{n}f_{i+k}$。

这个东西你要用数据结构维护就非常鬼畜。

注意到一个值在单调栈内的一次完整的入出可以在如上图的平面上构成一个矩形。而我们要求的就是这些矩形一个斜投影。

![](https://cdn.luogu.com.cn/upload/image_hosting/ktds3ha9.png)

如图，令矩形长宽为 $x$ 和 $y$，则对左下和右上角的答案区间内的贡献就是 $\min(x,y)$。余下的两坨的贡献是等差序列。

这两个东西都是可以用差分简单做的。

## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e18;
const int N=100010,M=100010;
struct query
{
	int tl,tr,xl,xr,val;
}q[N],z[N];
int pos=1,n,a[N];
int cf1[N],cf2[N],ans[N];
void get1(int l,int r,int t,int val)
{
	if(t==0||r==0)return;
	cf2[l]+=val;
	cf2[r+1]-=(t+1)*val;
	cf2[r+2]+=t*val;
}
void get2(int l,int r,int t,int val)
{
	if(t==0||r==0)return;
	cf2[r+2]+=val;
	cf2[l+1]-=(t+1)*val;
	cf2[l]+=t*val;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i+n]=a[i];
	}
	int base=a[n];
	z[1].xl=z[1].xr=n;
	z[1].tr=n;
	z[1].val=a[n];
	for(int i=1+n;i<=n*2;i++)
	if(a[i]<base)
	{
		pos++;
		z[pos].xl=i;
		z[pos].tr=n;
		z[pos].xr=i;
		z[pos].val=a[i];
		base=a[i];
	}
	else z[pos].xr=i;
	for(int i=1;i<=pos;i++)
	if(i>(pos-i+1))swap(z[i],z[pos-i+1]);
	int res=0;
	for(int i=n-1;i>=1;i--)
	{
		while(a[i]<z[pos].val)
		{
			z[pos].tl=i+1;
			q[++res]=z[pos];
			pos--;
		}
		pos++;
		z[pos].tr=i;
		z[pos].xl=i;
		z[pos].xr=z[pos-1].xl-1;
		z[pos].val=a[i];
	}
	while(pos)
	{
		z[pos].tl=1;
		q[++res]=z[pos];
		pos--;
	}
	for(int i=1;i<=res;i++)
	{
		int x=q[i].xr-q[i].tr,y=q[i].xl-q[i].tl;
		int lenth=min((q[i].xr-q[i].xl+1),(q[i].tr-q[i].tl+1));
		if(x>y)swap(x,y);
		if(y==0)continue;
		cf1[x]+=q[i].val*lenth;
		cf1[y+1]-=q[i].val*lenth;
		get1(x-lenth+1,x-1,lenth-1,q[i].val);
		get2(y+1,y+lenth-1,lenth-1,q[i].val);
	}
	for(int i=1;i<=n;i++)
	cf2[i]+=cf2[i-1];
	for(int i=0;i<=n;i++)cf1[i]+=cf2[i];
	for(int i=1;i<=n;i++)
	cf1[i]+=cf1[i-1]; 
	for(int i=1;i<=n;i++)
	cout<<cf1[i]<<'\n';
}
```

---

## 作者：TBSF_0207 (赞：2)

提供一种比较易懂但是常数大一点的**单调栈+二次差分**写法。

我们先破环成链，将序列自我复制一次。

形式化的，要求的答案 $ans_k=\sum_{i=1}^n \min_{j=i}^{i+k} a_j$。

发现如果每个区间贡献单独考虑好像不太可做，那么可以考虑每个 $a_j$ 对答案的贡献。

考虑在一个无限自我复制的序列中，有一个位置 $x$，它左侧最近且满足 $a_{L-1}\le a_x$ 的位置为 $L$，它右侧最近且满足 $a_{R+1}<a_x$ 的位置为 $R$，很显然两者都可以用单调栈维护。

然后我们记 $L_i\in [L,x]$。

然后考虑 $a_x$ 的贡献。我们将所有时间向后推一秒。显然地从一个 $j$ 到达 $i(i>j)$ 的时刻是 $i-j+1$。那么对于 $i$ 来说，$a_x$ 在时间轴上的贡献就相当于 $[x-L_i +1,R-L_i +1]$。

这样我们就得到了一个 $a_x$ 对时间的贡献，那就是在时间轴 $[x-L+1,R-L+1]$ 一直到 $[1,R-x+1]$ 的等长区间上每一个区间区间加上 $a_x$ 的结果。

这个东西怎么维护呢？对于一个静态区间加很容易想到差分，那若干个区间加就相当于在差分数组上再区间加。可以对差分数组再做一次差分，就相当于在每个区间开头分别加上一个值，在每个区间结尾 $+1$ 的位置分别减去一个值。那么直接在二次差分数组上维护即可。

最后是为什么 $L,R$ 的边界要这么设置，其实是为了防止重复。对于一个位置 $x$，如果有 $y<x,a_y=a_x$，那么 $y$ 前面的贡献一定被计算过了，$L=y+1$ 即可。

总体时间复杂度 $O(n)$。

在代码实现中，由于假想是无限自我复制的序列，所以需要自复制**三遍**然后在最中间的序列进行答案累加。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+5;
int n,a[3*N],L[3*N],R[3*N];
stack<int>stk;
LL ans[N*3];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=n+1;i<=3*n;i++)
		a[i]=a[i-n];
	for(int i=1;i<=n*3;i++){
		while(!stk.empty()&&a[stk.top()]>a[i])stk.pop();
		if(stk.empty())L[i]=1;
		else L[i]=stk.top()+1;
		stk.push(i);
	}
	while(!stk.empty())stk.pop();
	for(int i=n*3;i>=1;i--){
		while(!stk.empty()&&a[stk.top()]>=a[i])stk.pop();
		if(stk.empty())R[i]=n*3;
		else R[i]=stk.top()-1;
		stk.push(i);
	}
	for(int i=n+1;i<=2*n;i++){
		ans[1]+=a[i];
		ans[i-L[i]+2]-=a[i];
		ans[R[i]-i+2]-=a[i];
		ans[R[i]-L[i]+3]+=a[i];
	}
	for(int i=2;i<=n+1;i++)
		ans[i]+=ans[i-1];
	for(int i=2;i<=n+1;i++)
		ans[i]+=ans[i-1],cout<<ans[i]<<' ';
	return 0;
}
```

---

## 作者：__liujy (赞：1)

本题可以用单调栈和差分解答。

给出一个式子，对于第 $k$ 次操作，则 $ans=\sum^{n}_{i=1} \min^{i+k}_{j=i} a_{j}$，其中 $ans$ 为最终答案，我们围绕这个式子展开叙述。

暴力解这个式子能获得部分分，我们考虑正解。

令 $L$ 为最近满足 $a_{L-1} \le a_{i}$ 的位置；$R$ 为最近满足 $a_{R+1} < a_{i}$ 的位置。并且设 $l \in [L,i]$。

考虑 $a_{i}$ 对次数的贡献，把次数往后推一次，从 $i$ 到比 $i$ 大的 $j$ 时，需要 $j-i+1$ 次，因此 $a_{i}$ 的贡献就是 $[i-l+1,R-l+1]$。得到 $a_{i}$ 对次数的贡献后，就把与 $[x-L+1,R-L+1]$ 到 $[1,r-x+1]$ 等长的区间加 $a_{i}$。

这个过程要用单调栈和二次差分优化。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
typedef long long LL;
int n,a[N*3],l[N*3],r[N*3];
LL ans[N*3];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=(n<<1);i++) a[i+n]=a[i];
	stack<int> st;
	for(int i=1;i<=n*3;i++)
	{
		while(st.size()&&a[st.top()]>a[i]) st.pop();
		if(st.size()) l[i]=st.top()+1;
		else l[i]=1;
		st.push(i);
	}
	while(st.size()) st.pop();
	for(int i=n*3;i>=1;i--)
	{
		while(st.size()&&a[st.top()]>=a[i]) st.pop();
		if(st.size()) r[i]=st.top()-1;
		else r[i]=n*3;
		st.push(i);
	}
	for(int i=n+1;i<=(n<<1);i++)
	{
		ans[1]+=a[i];
		ans[i-l[i]+2]-=a[i];
		ans[r[i]-i+2]-=a[i];
		ans[r[i]-l[i]+3]+=a[i];
	}
	for(int i=1;i<=n+1;i++) ans[i]+=ans[i-1];
	for(int i=1;i<=n+1;i++) ans[i]+=ans[i-1];
	for(int i=2;i<=n+1;i++) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 题意简述
环形水槽每秒流水，超出容量则溢出，求每秒结束时所有水槽水量总和，共 $n$ 秒。
## 思路
对于任意一头水槽，其桶中的水量只会因为接收到来自上一头水槽的水而增加，或者因为传递给下一头水槽而减少。水槽的传递是循环的，因此我们可以将水槽看作一个环来处理。

我们可以发现，对于每个水槽 $i$，其桶中的水量最终会稳定在一个固定的值上，这个值取决于环中水槽的容量分布。使用单调栈可以帮助我们快速找到每头水槽最终稳定的水量。具体来说，我们可以利用单调递增栈来找到每头水槽左边和右边第一个比它容量小的水槽的位置。

通过单调栈，我们可以确定每段区间内水槽的最终稳定状态。对于每个区间，我们可以计算出该区间内水槽的总量，并减去因为超出容量而溢出的水量。最后，通过累加每分钟后的剩余水量，即可得到每一分钟后的总水量。

* 单调栈用于找到每头水槽左边和右边第一个比它容量小的水槽的位置。

* 差分数组用于高效计算每分钟后的水槽总量变化。

由于水槽是排成一个环的，因此我们需要将数组扩展一倍来处理环形传递。

以下是解题步骤：
1. 找到每头水槽左边和右边第一个比它容量小的水槽的位置。
2. 对于每个水槽，根据其左边和右边第一个比它容量小的水槽的位置，计算该水槽每分钟的水量变化。考虑水槽的容量限制，计算因超出容量而溢出的水量，并从总量中减去。
3. 通过累加差分数组，得到每一分钟后的总水量。
4. 输出每分钟后的总水量。
## Code（只给关键部分）
```cpp
cin>>n;
for(ll i=1;i<=n;i++) cin>>a[i],a[n+i]=a[i];//复制数组到后半部分
//预处理左边第一个比当前元素小的位置
l[1]=0;
for(ll i=2;i<=n*2;i++){
	ll x=i-1;
	while(a[x]>=a[i]&&x) x=l[x];
	l[i]=x; 
}
//预处理右边第一个不比当前元素大的位置
r[n*2]=n*2+1;
for(ll i=n*2-1;i;i--){
	ll x=i+1;
	while(a[x]>a[i]&&x&&x!=n*2+1) x=r[x];
	r[i]=x;
}
//找到数组中的最小值及其索引，并计算数组的总和（省略）
//计算每个元素作为最大值时可以减少的总量，并更新 ans 数组（省略）
//通过前缀和计算 ans 数组的累积值，并得到每个位置的最终答案（省略）
```
**十年 OI 一场空，不开`long long`见祖宗！**

**注意数组大小！**

---

## 作者：Wu_Qi_Tengteng (赞：1)

我们发现第 $i$ 时刻的答案就是环上所有长度为 $i+1$ 的区间的 $\min$ 之和。

这样就提示我们是否可以对于每个 $a_i$ 考虑其作为最小值的区间是哪些，然后统计对于这些区间的贡献。

我们设 $l_i$ 表示 $i$ 左边第一个小于他的值，$r_i$ 表示右边第一个小于等于它的值（之所以是大于等于是因为相同的元素之间会重复计算）。

可以用单调栈计算他们。

然后假设最终我们求出的左区间加上中间点的长度为 $ls$，右区间加上中间点的长度为 $rs$，能够贡献到的区间的长度为 $len$。

分类讨论一下：
$len\in[1,\min(ls,rs)]$：对于长度为 $i$ 的贡献为 $i\times a[i]$；

$len\in(\min(ls,rs),\max(ls,rs)]$：对于所有的贡献均为 $\min(ls,rs)\times a[i]$；

$len\in(\max(ls,rs),rs+ls-1]$：对于长度为 $i$ 的贡献为 $(rs+ls-i)\times a[i]$。

第二类就是一个区间加。而前后两类加的其实是一个等差数列，可以用[二阶差分](https://www.luogu.com.cn/article/5lwz5i9q)维护。

时间复杂度 $\mathcal{O}(n)$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6+5;
int d1[N],d2[N];
void upd(int l,int r,int fir,int d){
	if(r<l)return;
	d1[l]+=fir;
	d1[r+1]-=fir+(r-l)*d;
	d2[l+1]+=d;
	d2[r+1]-=d;
}
int n,a[N],l[N],r[N],sum;
stack<int> st;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		a[i+n]=a[i];
	}
	for(int i=1;i<=2*n;i++){
		while(!st.empty()&&a[st.top()]>=a[i])st.pop();
		if(st.empty())l[i]=0;
		else l[i]=st.top();
		st.push(i);
	}
	while(!st.empty())st.pop();
	for(int i=2*n;i>0;i--){
		while(!st.empty()&&a[st.top()]>a[i])st.pop();
		if(st.empty())r[i]=2*n+1;
		else r[i]=st.top();
		st.push(i);
	}
	for(int i=1;i<=n;i++){
		int ls=i+n-max(l[i+n],i),rs=min(r[i],i+n)-i;
		upd(1,min(ls,rs),a[i],a[i]);
		upd(min(ls,rs)+1,max(ls,rs),min(ls,rs)*a[i],0);
		upd(max(ls,rs)+1,rs+ls-1,(min(ls,rs)-1)*a[i],-a[i]);
	}
	for(int i=1;i<=n;i++){
		d2[i]+=d2[i-1];
		d1[i]+=d2[i];
	}
	for(int i=2;i<=n;i++)printf("%lld ",d1[i]+=d1[i-1]);
	printf("%lld",d1[n]);
	return 0;
} 
```

---

## 作者：Populus_euphratica (赞：1)

首先来处理环形排列的问题，这个只用把数组复制一遍即可。

接着，考虑如何求解。

先来看一种情况（如下图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/65ep6ny2.png)

黄色部分在箭头所指的位置贡献会消失。

正着考虑有多少贡献太难了，不如反着考虑在哪些时刻会有贡献消失。

考虑如何求出黄色的部分。

可以设一个数组 $l$ 表示左边第一个小于 $a_i$ 的位置，一个数组 $r$ 表示右边第一个小于 $a_i$ 的位置。

所以，就是 $l_{i + 1}$ 到 $r_{i - 1}$ 的贡献会在 $r_i$ 处消失。

那么黄色部分的长度就是 $r_i - l_i - 1$ 但是发现如果有 $a_i$ 相等的情况会算重，所以，考虑把 $r$ 的定义改为在 $i$ 的右边第一个小于等于 $a_i$ 的位置。

那么 $l$ 和 $r$ 数组怎么求？那个单调栈维护一下就行，时间复杂度是 $O(n)$ 的。

那么长度知道了，高度怎么求呢？

发现高度就是 $a_i - \max(a_{l_i}, a_{r_i})$，为什么呢？可以发现 $a_i$ 是这一段区间里最低的位置，最高处一定是 $a_i$，而如果前面的没有那么多，就贡献不到后面，后面也同理。可以画个图自己看看。所以要取最大值。

最后答案可以做两边前缀和得到。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int Maxn = 200010;
int n;
int Min, sum;
int ans[Maxn];
int a[Maxn], l[Maxn], r[Maxn];
int stk[Maxn], tot;
signed main(){
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i = 1 ; i <= n ; i++) cin >> a[i];
	for(int i = n + 1 ; i <= 2 * n ; i++) a[i] = a[i - n];
	for(int i = 1 ; i <= 2 * n ; i++){
		while(a[i] <= a[stk[tot]] && tot) tot--;
		l[i] = stk[tot];
		stk[++tot] = i;
	}
	tot = 0;
	for(int i = 2 * n ; i ; i--){
		while(a[i] < a[stk[tot]] && tot) tot--;
		r[i] = stk[tot];
		stk[++tot] = i;
	}
	a[Min] = 1e18;
	for(int i = 1 ; i <= n ; i++){
		if(a[i] < a[Min]) Min = i;
		sum += a[i];
	}
	for(int i = Min + 1 ; i <= Min + n ; i++){
		if(a[i] == a[Min]) continue;
		int x = r[i] - l[i] - 1;
		int y = a[i] - max(a[l[i]], a[r[i]]);
		// cout << i << " " << a[i] << " " << x << " " << y << '\n';
		ans[1] += y;
		ans[1 + x] -= y;
	}
	for(int i = 1 ; i <= n ; i++) ans[i] += ans[i - 1];
	for(int i = 1 ; i <= n ; i++) ans[i] += ans[i - 1];
	for(int i = 1 ; i <= n ; i++) cout << sum - ans[i] << " ";
	cout << '\n';
	return 0;
}
```

---

## 作者：Msents (赞：0)

思路答辩，代码以后再写的做法。

首先先把 $a$ 复制一份拼在它后面，断环成链，这个没啥好说的。

然后可以发现第 $i$ 秒的水量总和，其实就是 $a$ 中所有长度为 $i+1$ 的子数组的最小值的和。

考虑拆贡献，用单调栈处理每个元素离它左右边更小的元素距离。（实际实现中一个是严格小于，另一个是不大于，防止贡献算漏算重）

然后可以硬凸贡献式子，设 $f$ 是左边不比当前元素大的元素的间距，$g$ 是右边比当前元素小的元素的间距：

$$ans_j=\sum_{i=1}^n\max(0,\min(j,g_i+1)-\max(0,j-f_i-1))\times a_i$$

其中 $\max(0,\min(j,g_i+1)-\max(0,j-f_i-1))$ 的意义是 $a_i$ 为多少个长度为 $j$ 的子数组的最小值。

考虑这个式子的性质，通过脑补和嗯推，可以发现：

$$
\max(0,\min(j,g_i+1)-\max(0,j-f_i-1))=
  \begin{cases}
  j\space j\le\min(g_i+1,f_i+1)\\
  \min(g_i+1,f_i+1)\space \min(g_i+1,f_i+1)<j\le\max(g_i+1,f_i+1)\\
  \max(0,\min(g_i+1,f_i+1)-j+\max(g_i+1,f_i+1))\space j>\max(g_i+1,f_i+1)
  \end{cases}
$$

一坨答辩，但脑补一下可以认为 $a_i$ 对答案的贡献是一个平行四边形，左下角为四十五度。

用线段树或者离线算法均可维护。

答辩：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MaxN=1000000;
int n,a[MaxN*2+1];
int f[MaxN+1],g[MaxN+1];
struct Node{
	int add,tladd,tradd;
	int l,r;
	int len(){return r-l+1;}
}tree[MaxN*4+1];
int Left(int u){return u<<1;}
int Right(int u){return u<<1|1;}
void PushDown(int u){
	if(tree[u].add){
		tree[Left(u)].add+=tree[u].add;
		tree[Right(u)].add+=tree[u].add;
		tree[u].add=0;
	}
	if(tree[u].tladd){
		tree[Left(u)].tladd+=tree[u].tladd;
		tree[Right(u)].tladd+=tree[u].tladd;
		tree[Right(u)].add+=tree[u].tladd*tree[Left(u)].len();
		tree[u].tladd=0;
	}
	if(tree[u].tradd){
		tree[Left(u)].tradd+=tree[u].tradd;
		tree[Right(u)].tradd+=tree[u].tradd;
		tree[Left(u)].add+=tree[u].tradd*tree[Right(u)].len();
		tree[u].tradd=0;
	}
}
void Build(int u,int l,int r){
	tree[u].l=l,tree[u].r=r;
	if(l==r)return;
	int mid=(l+r)/2;
	Build(Left(u),l,mid);
	Build(Right(u),mid+1,r);
}
void Add(int u,int l,int r,int val){
	if(r<tree[u].l||tree[u].r<l)return;
	if(l<=tree[u].l&&tree[u].r<=r)return void(tree[u].add+=val);
	PushDown(u);
	Add(Left(u),l,r,val);
	Add(Right(u),l,r,val);
}
void TLAdd(int u,int l,int r,int val){
	if(r<tree[u].l||tree[u].r<l)return;
	if(l<=tree[u].l&&tree[u].r<=r){
		tree[u].add+=(tree[u].l-l)*val;
		tree[u].tladd+=val;
		return;
	}
	PushDown(u);
	TLAdd(Left(u),l,r,val);
	TLAdd(Right(u),l,r,val);
}
void TRAdd(int u,int l,int r,int val){
	if(r<tree[u].l||tree[u].r<l)return;
	if(l<=tree[u].l&&tree[u].r<=r){
		tree[u].add+=(r-tree[u].r)*val;
		tree[u].tradd+=val;
		return;
	}
	PushDown(u);
	TRAdd(Left(u),l,r,val);
	TRAdd(Right(u),l,r,val);
}
void DFS(int u){
	if(tree[u].l==tree[u].r){
		if(tree[u].l>1){
			cout<<tree[u].add+tree[u].tladd+tree[u].tradd<<' ';
			if(tree[u].l==n)cout<<tree[u].add+tree[u].tladd+tree[u].tradd<<' ';
		}
		return;
	}
	PushDown(u);
	DFS(Left(u));
	DFS(Right(u));
}
void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],a[i+n]=a[i];
	stack<int,vector<int> >stk;
	for(int i=1;i<=n*2;i++){
		while(stk.size()&&a[stk.top()]>a[i])stk.pop();
		if(i>n){
			if(stk.size())
				f[i-n]=i-stk.top()-1;
			else
				f[i-n]=n-1;
		}
		stk.push(i);
	}
	for(int i=n*2;i>=1;i--){
		while(stk.size()&&a[stk.top()]>=a[i])stk.pop();
		if(i<=n){
			if(stk.size())
				g[i]=stk.top()-i-1;
			else
				g[i]=n-1;
		}
		stk.push(i);
	}
	Build(1,1,n);
	for(int i=1;i<=n;i++){
		TLAdd(1,1,min(f[i]+1,g[i]+1),a[i]);
		Add(1,min(f[i]+1,g[i]+1)+1,max(g[i]+1,f[i]+1),a[i]*min(f[i]+1,g[i]+1));
		TRAdd(1,max(g[i]+1,f[i]+1)+1,min(f[i]+g[i]+1,n),a[i]);
	}
	DFS(1);
}
#undef int
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
  Solve();
	return 0;
}

```

---


# [UESTCPC 2024] 2-聚类算法

## 题目描述

Alice 和 Bob 是两只 $k$ 维空间中的生物。在他们生活的空间中，分布着 $2n$ 个特征点，其中第 $i$ 个特征点的坐标为 $(x_{i,1},x_{i,2},\ldots,x_{i,k})$。

在这个空间中，两点之间的距离被定义为它们之间的曼哈顿距离（即点 $i$ 与点 $j$ 之间的距离 $\text{dist}_{i,j}=\sum_{p=1}^{k}|x_{i,p}-x_{j,p}|$）。

Alice 和 Bob 需要收集这些特征点。他们轮流从这 $2n$ 个点中选走一个点，已经被选走的点不能被再次选走。Alice 先手。Alice 会将她选走的点放入集合 $S_1$，而 Bob 会将他选走的点放入集合 $S_2$。

设一个集合的价值 $\text{val}(S)$ 为其中两两点之间的距离之和。Alice 希望最大化 $\text{val}(S_1)-\text{val}(S_2)$，而 Bob 希望最小化 $\text{val}(S_1)-\text{val}(S_2)$。

若 Alice 和 Bob 都采取最优策略，请你求出最终 $\text{val}(S_1)-\text{val}(S_2)$ 的值会是多少？

## 样例 #1

### 输入

```
2 2
1 0
0 1
1 1
0 0```

### 输出

```
0```

# 题解

## 作者：Lu_xZ (赞：3)

官方题解做法。


$$
\begin{aligned}

& \sum_{i < j\in S_a} \text{dist}(p_i, p_j) - \sum_{i < j \in S_b} \text{dist}(p_i, p_j)\\
\\
=& \bigg(\sum_{i < j\in S_a} \text{dist}(p_i, p_j) + \sum_{i < j\in S_b} \text{dist}(p_i, p_j) + \sum_{i \in S_a, j\in S_b} \text{dist}(p_i, p_j) \bigg) - \bigg(\sum_{i < j \in S_b} \text{dist}(p_i, p_j) + \sum_{i > j\in S_b} \text{dist}(p_i, p_j) + \sum_{i \in S_a, j\in S_b} \text{dist}(p_i, p_j)\bigg)\\
\\
=& \sum_{i, j \in U} \text{dist}(p_i, p_j) -  \sum_{i \in U,\ j \in S_b} \text{dist}(p_i, p_j)
\end{aligned}
$$
前一项是定值，后一项只与 $S_b$ 有关。

对 $A$ 来说想让最大的点不计入贡献，对 $B$ 来说要尽可能选大的点。

因此每个人的决策就是取当前到所有点距离和最大的点。

```cpp
#include<bits/stdc++.h>
#define eb emplace_back
#define ep emplace
using namespace std;

using ll = long long;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	int N, K; cin >> N >> K;
	N *= 2;
	vector a(N, vector<int>(K));
	for(int i = 0; i < N; ++ i) {
		for(int j = 0; j < K; ++ j) {
			cin >> a[i][j];
		}
	}
	vector<ll> d(N);
	for(int k = 0; k < K; ++ k) {
		vector<int> id(N);
		iota(id.begin(), id.end(), 0);
		sort(id.begin(), id.end(), [&](int i, int j) {
			return a[i][k] < a[j][k];
		});
		ll sum = 0;
		for(int i = 0; i < N; ++ i) {
			int j = id[i];
			d[j] += ll(i) * a[j][k] - sum;
			sum += a[j][k]; 
		}
		reverse(id.begin(), id.end());
		sum = 0;
		for(int i = 0; i < N; ++ i) {
			int j = id[i];
			d[j] += sum - ll(i) * a[j][k];
			sum += a[j][k]; 
		}
	}
	sort(d.begin(), d.end(), [&](ll x, ll y) {
		return x > y;
	});
	ll ans = 0;
	for(int i = 0; i < N; ++ i) {
		ans += d[i];
	}
	ans /= 2;
	for(int i = 1; i < N; i += 2) ans -= d[i];
	cout << ans;
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：3)

## 思路

见过的套路。把一条边的边权同时挂在两个点上。如果这两个点被同一个人选了，那么这个人会获得双倍边权；如果没有，那么两个人的差不会受到影响。那么每个人的策略就是贪心选点权最大的点了。最后答案除以二即可。

现在要求每个点的点权。发现这 $k$ 维是独立的，分开做。排个序拆个绝对值就做完了。

## code

```cpp
#include<stdio.h>
#include<vector>
#include<algorithm>
#define N 200009
#define int long long
#define pr pair<int,int> 
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	bool t=0;char c=nc();for(;c<'0'||'9'<c;t|=c=='-',c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());if(t)x=-x;
}
int n,m,f[N],ans;vector<int>a[N];pr b[N];
main()
{
	read(n);n<<=1;read(m);
	for(int i=0;i<n;++i)
	{
		a[i].resize(m);
		for(int j=0;j<m;read(a[i][j++]));
	}
	for(int i=0;i<m;++i)
	{
		for(int j=0;j<n;++j)b[j]=(pr){a[j][i],j};
		sort(b,b+n);
		for(int j=0,s=0;j<n;++j)
			f[b[j].second]+=b[j].first*j-s,
			s+=b[j].first;
		for(int j=n-1,s=0;j>=0;--j)
			f[b[j].second]+=s-b[j].first*(n-j-1),
			s+=b[j].first;
	}
	sort(f,f+n);
	for(int i=0;i<n;++i)if(i&1)ans+=f[i];else ans-=f[i];
	printf("%lld",ans>>1);
}
```

---

## 作者：xcxxx_ (赞：2)

先考虑 $k=1$ 的情况怎么做，考虑将所有坐标排序，对每两个相邻的点之间的长度计算贡献，即这一段被 Alice 选的点覆盖的次数减去被 Bob 选的点覆盖的次数乘上他的长度，设 Alice 在前 $i$ 个点中选了 $t_i$ 个点，点 $i$ 到点 $i+1$ 的距离为 $d$，则这两个点间的线段对 $val(S_1)-val(S_2)$ 的贡献为
$$d\cdot (t_i\cdot (n-t_i)-(i-t_i)\cdot (n-i+t_i))=2t_i\cdot (n-i)+i^2-n\cdot i$$

后两项是固定的，于是我们只需要先给答案加上 $\sum\limits_{i=1}^{2n}i^2-n\cdot i$ 后考虑两人博弈后下面式子的值
$$2\sum\limits_{i=1}^{2n} t_i(x_{i+1}-x_i)(n-i)$$
Alice 选择一个点 $i$ 相当于给 $t$ 后缀 $+1$，并给 $val(S_1)-val(S_2)$ 产生这么多的贡献：
$$\sum\limits_{k=i}^{2n}(x_{k+1}-x_k)(n-k)$$ 
于是可以设一个点的点权 $v_i$ 为
$$v_i=\sum\limits_{k=i}^{2n}(x_{k+1}-x_k)(n-k)$$
Alice 会依次选择最大的为倍选择过的点以获得最大的答案，Bob 则会依次选择最大的为倍选择过的点以阻止 Alice 选择那个点，因此将 $v_i$ 从大到小排序后将答案加上 $\sum _{2\nmid i}v_i$ 即可。

接下来扩展到 $k$ 维，容易发现 $k$ 维的贡献互相独立，分别计算每个点的在所有维上的贡献计算即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
using namespace std;
int rd() {int x=0,f=1;char c=getchar();while(!isdigit(c))f=(c=='-'?-1:f),c=getchar();while(isdigit(c))x=x*10+c-'0',c=getchar();return x*f;}
const int N=200005;
int n,k,s[N],v[N],ans;
struct node {int x,id;};
bool operator<(node a,node b) {return a.x<b.x;}
vector<vector<node>> x;
signed main() {
    n=rd(),k=rd();
    x.resize(k+5);
    rep(d,1,k) x[d].resize(n*2+5);
    rep(i,1,2*n) rep(d,1,k) x[d][i].x=rd(),x[d][i].id=i;
    rep(d,1,k) sort(x[d].begin()+1,x[d].begin()+2*n+1);
    rep(d,1,k) {
        rep(i,1,n*2-1) ans+=(i*i-i*n)*(x[d][i+1].x-x[d][i].x);
        cerr<<ans<<endl;
        per(i,n*2-1,1) s[i]=s[i+1]+(n-i)*(x[d][i+1].x-x[d][i].x);
        rep(i,1,n*2) v[x[d][i].id]+=s[i];
    }
    sort(v+1,v+1+2*n,greater<int>());
    rep(i,1,n) ans+=2*v[i*2-1];
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：ktq_cpp (赞：1)

k 很大的时候不容易考虑，不妨先考虑 $k=1$ 的情况。

首先猜测两人必定从大到小选，但是很显然是不对的，可以被这组数据卡掉。

```
2 1
0
2
3
4
```

在这组数据中，第一个人如果不选择 0，那么第二个人选择 0 的话，无论后面如何操作第一个人答案都为负数。因此，第一个人必须选择 0。

沿着这组数据继续思考下去，第一个人如果选择 0，那么第二个人必须选择 4，否则第一个人就可以覆盖整个区间。于是我们再次大胆猜测：在排序之后，如果第一个人选择了 $i$ 个数，那么第二个人肯定会选择第 $n+n+1-i$ 个数。

~~但是这还是错的~~，我们再次考虑一组数据

```
3 1
0
0
0
1
100
200
```

如果两边一人各选一个，那么答案会是 398，具体策略是第一个人一直选右边的，第二个人一直选左边的。但是如果第二个人选择 100 的话，答案肯定不会到达 398 这样的级别。

观察给出的两个数据，我们以第 n 个数和第 n+1 个数之间作为分割线。分割线左边的点的点权为到它右边且在分割线左边的点的距离之和。分割线右边反过来就可以了。两个人轮流选点权最大的点即可。

拿第二个数据作为解释。令 $dis_{i,j}$ 表示 $i$ 和 $j$ 之间的距离，我们左边三个数的点权都为 0，右边三个数的点权分别为 $dis_{4,4}=0$，$dis_{4,5}+dis_{5,5}=99$，$dis_{4,6}+dis_{5,6}+dis_{6,6}=199$。

最后一步比较人类智慧。我们需要注意到这 k 维是相互独立的，我们只需要将第 i 维的每个坐标的点权加回原来的，然后两人轮流选最大的点。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
#define pb push_back
using namespace std;
int n,k;
const int N=1e5+5;
vector<pair<int,int>> X[N];
int sum[N<<1];
int dis[N<<1];
pair<int,int> x[N<<1];
priority_queue<int> q;
signed main(){
    scanf("%lld %lld",&n,&k);
    for(int i=1;i<=n+n;i++){
        for(int j=1,x;j<=k;j++){
            scanf("%lld",&x);
            X[j].pb({x,i});
        }
    }
    for(int i=1;i<=k;i++){
        sort(X[i].begin(),X[i].end());
        for(int _=1;_<=n+n;_++)x[_]=X[i][_-1];
        for(int i=1;i<=n+n;i++)sum[i]=sum[i-1]+x[i].first;
        for(int i=n+n;i>=n+1;i--){
            int val1=sum[i]-sum[n];
            dis[x[i].second]+=(i-n)*x[i].first-val1;
        }
        for(int i=1;i<=n;i++){
            int val1=sum[n]-sum[i-1];
            dis[x[i].second]+=val1-(n-i+1)*x[i].first;
        }
    }
    for(int i=n+n;i>=n+1;i--){
        q.push(dis[i]);
    }
    for(int i=1;i<=n;i++){
        q.push(dis[i]);
    }
    int ans=0;
    int op=1;
    while(!q.empty()){
        (ans+=op*q.top());
        q.pop();
        op=-op;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Robin_kool (赞：0)

很好的套路题。

记得曾经做过一道类似的图论题，最后的结论好像是选 $\lfloor \frac{n}{2} \rfloor$ 条边，前面忘了，后面忘了。

这两个题都用了相似的套路，我们可以一条边的价值算到两个点上（注意这样以后就不用做绝对值操作）。发现如果这两个点在同一个集合，正好价值乘上 $2$，如果在异侧，由于价值相同，可以抵消。

那就可以直接做了，计算每个点的贡献，并且注意到 $k$ 维之间并没有任何关系，当做 $1$ 维算即可。

最后排序一下，注意数组开 $2n$。

---


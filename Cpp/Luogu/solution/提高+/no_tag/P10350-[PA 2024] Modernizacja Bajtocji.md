# [PA 2024] Modernizacja Bajtocji

## 题目背景

PA 2024 1A

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 1 [Modernizacja Bajtocji](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/mod/)**

Byteland 正在走向现代化。最新的政府项目旨在为那些没有电脑的村镇居民提供电脑。Byteasar 正在监督该计划中的一个村庄——Bytetown——的现代化进程，目前那里没有一个居民拥有电脑。

Bytetown 有 $n$ 个居民，为了简单起见，Byteasar 将他们用 $1$ 到 $n$ 的整数编号。最初没有一个居民拥有电脑。Byteasar 的任务是处理三种形式的事件：

- $\texttt{+}\ a_i\ b_i$：将一台电脑送给 Bytetown 的居民。然而，Byteasar 并不知道电脑是送给了编号为 $a_i$ 还是 $b_i$ 的居民。可能会出现 $a_i = b_i$ 的情况——在这种情况下，电脑肯定送给了编号为 $a_i$ 的居民。可以确定的是，电脑被送到了目前还没有电脑的居民手中。
- $\texttt{-}\ c_i$：编号为 $c_i$ 的居民的电脑坏了。可以肯定的是，该居民曾经拥有一台电脑（但现在不再拥有，因此将来可能会收到一台新电脑）。
- $\texttt{?}\ d_i$：Byteasar 需要（利用**迄今为止**获得的所有信息）确定编号为 $d_i$ 的居民：肯定有电脑，肯定没有电脑，还是不确定他是否有电脑。

请编写一个程序，帮助 Byteasar 回答所提出的问题！

注：在居民的电脑坏掉的前一刻，Byteasar 不一定可以确定这个居民是否有电脑。换句话说，在某居民电脑坏掉之前，不一定可以从之前的事件中确定他是否有电脑。

## 说明/提示

最初没有人有电脑，所以第一个询问的答案为「否」，输出的第一个字符是 `0`。然后送出了两台电脑，我们又被问到另一位居民是否有电脑。有可能迄今为止送出的两台电脑中有一台是送给他的，但也有可能电脑是分别送给第一位和第三位居民的。因此，我们无法最终确定第二位居民是否有电脑，所以答案是 `?`。需要注意的是，在下一次送出之后，第二位居民肯定已经拥有了一台电脑，但在询问 Byteasar 时，他并不知道这一点。

## 样例 #1

### 输入

```
5 11
? 1
+ 1 2
+ 2 3
? 2
+ 3 1
- 2
? 1
? 2
? 3
+ 2 2
? 2
```

### 输出

```
0?1011
```

# 题解

## 作者：huangziqin (赞：11)

这道题目挺巧妙的 。

### 首先考虑什么情况下不能确定电脑的情况 。

```
+ 1 2
+ 1 3
+ 2 4
+ 3 5
```
形如这样的样例是无法确定具体的电脑给了谁 。 明显地 ， 这组样例中人与人的状态连边形成了一棵树 。 同时 ， 我们也能确定这个连通块中有且仅有一个人没有电脑 ， 但是不能确定这个人具体是谁 ， 所以无法确定每个人的状态。

再以此为基础考虑一下什么情况下可以确定每个人都有电脑 。

注意到这句话 ：  **“电脑被送到了目前还没有电脑的居民手中 。”** 所以如果出现了一个环 ， 则一定能确定这个环所在的连通块中每个人都有电脑 。

简单证明一下 ， 如果大小为 $n$ 的连通块中有 $n$ 条边 （ 出现环的充要条件 ）， 这意味着这 $n$ 个人被送了 $n$ 台电脑 ， 且每个人至多有一台电脑 ， 则每个人都有且仅有一台电脑 ， 得证。

### 再考虑一下电脑损坏的情况。

对于一个**树形**的连通块 ， 如果某个人的电脑损坏一定意味着他有过电脑 ， 分两种情况讨论一下：

1. $n=2$ 则我们一定能确定另一个人没有电脑 。
2. $n>2$ 则我们仍然不能确定这个连通块中哪一个人没有电脑 。

所以我们只用考虑这两种 corner case 即可 。

同时 ， 这个电脑被损坏的人又回到了原先的初始状态  ， 即与其他人没有连边 ， 本身没有电脑的情况 。 

### 最后考虑回答 。
考虑该点所在的连通块状态 。 
- 如果他是一个独立的点 （ 且没有自环 ） ， 则他一定没有电脑 。
- 如果他属于某个 $n>1$ 的连通块且其内部有环 ， 则他一定有电脑 。 
- 如果他属于某个 $n>1$ 的**树状**连通块 ， 则他不能确定是否拥有电脑 。

### 代码实现细节

综上 ， 我们需要维护这些操作 ：
1. 连通块之间的合并
2. 查找连通块内是否有环
3. 分裂出某一个点
4. 查找连通块状态

通过 1,2 两个操作可以非常敏锐地发现我们的算法 **并查集** 。

所以关键在于 3 操作如何维护 。

因为并查集的删除非常麻烦 ， 所以我们考虑不删除的做法 。

因为发现被删除的点即使留在联通块内也对答案没有任何影响 。

所以不妨对于每个**人**维护一个 **id** 代表这个人对应着 id 这个点 ， 每次删除只需要增加新的 id 并且把人对应这个新的 id 即可 。

### 代码
```
#include<bits/stdc++.h>
using namespace std;

const int N=13e5+7;
int n,m,f[N],id[N],cnt,x,sz[N],zt[N],y;
char opt;
//zt[]： 连通块的状态
int getf(int x)
{
	if(f[x]==x) return f[x];
	else return f[x]=getf(f[x]);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n+m;i++) f[i]=i;//并查集初始化
	for(int i=1;i<=n;i++) id[i]=i,sz[i]=1;//目前只有n个人
	cnt=n;//有用的 id 的个数
	for(int i=1,xx,yy;i<=m;i++)
	{
		cin>>opt;
		if(opt=='?')
		{
			scanf("%d",&x);
			x=id[x];
			xx=getf(x);
			if(sz[xx]==1) printf("%d",zt[xx]);// n=1 的情况
			else printf("%c",(zt[xx]?'1':'?'));
		}
		if(opt=='+')
		{
			scanf("%d%d",&x,&y);
			x=id[x]; y=id[y];
			xx=getf(x); yy=getf(y);
			if(xx==yy) zt[xx]=1; //联通块内成环
			else
			{
				sz[xx]+=sz[yy]; f[yy]=xx; zt[xx]|=zt[yy];// 合并连通块
			}
		}
		if(opt=='-')
		{
			scanf("%d",&x);
			xx=getf(id[x]); sz[xx]--; //删除
			id[x]=++cnt; sz[cnt]++; //增加新点
		}
	}
	return 0;
}
```

---

## 作者：yuanruiqi (赞：3)

对每次被赠送的两个居民连接边，考察一个连通块。

若连通块的边数为 $0$，则一定没有分到电脑，若点数和边数相等，则每个居民被分到了一台电脑，否则不能确定。

考虑第 $i$ 个居民电脑坏了的影响，相当于确定了该居民曾获得过电脑，可以等价的用 $d_i-1$ 条边连接 $d_i$ 个邻点，即将原连通块的边数和点数减一。并对 $i$ 建新的连通块。

这些操作都可以使用并查集维护，新建节点，可以使用更改该居民的编号代替。

---

## 作者：yeyou26 (赞：2)

# 洛谷 P10350
## Sol 
并查集维护一顿就好了。  
## 思路  
我们首先划定两种区域：**一般区**和**一定有（电脑）区**。  
分别考虑三种操作：  
### 加操作  
`+ u v`   
直接在 $u,v$ 之间连边。   
如果有环则把连通块所有点都丢到“一定有”区。  
### 减操作  
`- u `   
如果 $u$ 在"一定有区"，则单独把 $u$ 挪回到一般区；   
如果 $u$ 在"一般区"，则把 $u$ 从联通块内移出去。  
注意到并查集的删除不好维护，于是考虑**新建一个点**来管辖 $u$ 这个人，  
之前管辖 $u$ 的点作废就好。  
### 查询  
`? u `   
如果 $u$ 在"一定有区"，则 $u$ 一定有电脑；  
如果 $u$ 在"一般区"且是孤立点，则一定没有电脑；  
如果 $u$ 在"一般区"且不是孤立点，则不确定有没有电脑。  
## 实现  
实现上更为简单，  
具体地，先弄一个朴素启发式合并并查集，维护连通块大小和是否有环即可。  
```cpp
#include<bits/stdc++.h>
using std::cin;using std::cout;using std::cerr;using std::ios;using std::endl;
const int N = 1e6+6;
int n,be[N+N],siz[N+N],fa[N+N],gx[N+N],qcnt,idx;
int Find(int x) {return fa[x]==x ? x : fa[x]=Find(fa[x]);}
void Union(int x,int y)
{
    x=Find(x),y=Find(y);
    if(siz[x]<siz[y]) std::swap(x,y);
    fa[y]=x;
    siz[x]+=siz[y];
    be[x]|=be[y];
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    cin>>n>>qcnt; idx=n;
    for(int i=1;i<=n;i++) gx[i]=i;
    for(int i=1;i<=n+qcnt;i++) fa[i]=i;
    for(int i=1;i<=n+qcnt;i++) siz[i]=1;
    while(qcnt--)
    {
        char ch[2]; cin>>ch;
        if(ch[0]=='+')
        {
            int x,y; cin>>x>>y;
            x=gx[x],y=gx[y];
            if(Find(x)==Find(y)) be[Find(x)]=1;
            else Union(x,y);
        }
        else if(ch[0]=='-') 
        {
            int who,x; cin>>who; x=gx[who];
            siz[Find(x)]--;
            gx[who]=++idx;
        }
        else 
        {
            int x; cin>>x; x=gx[x];
            if(be[Find(x)]) cout<<1;
            else if(siz[Find(x)]==1) cout<<0;
            else cout<<'?';
        }
    }
    return 0;
}
```

---

## 作者：Shunpower (赞：1)

很精妙的一道智商题，没想出来。。。

-----------

一个显然的想法：考虑 $a_i,b_i$ 连边。然后就不会了。

观察一个大小为 $n$ 的连通块有没有什么高妙的性质。可以发现，这个连通块最少有 $n-1$ 条边，但最多也只有 $n$ 条边。因为每次连边意味着电脑送给了一个未曾有过电脑的人，而整个连通块里最多就 $n$ 个人有电脑，所以最多也只能送 $n$ 次，就是 $n$ 条边。

进一步容易发现，一个边数为 $n$ 的连通块（注意不一定是简单环，因为可能有自环）里的所有人一定都有电脑，而边数为 $n-1$ 的连通块（也就是一棵树）里恰好有一个人没有电脑，但是我们确定不了那个人是谁。

接下来考虑删点。

可以发现，这个操作包含两个部分，第一个是这个点曾经有电脑的信息，第二个是纯粹要从图里删掉这个点，把这个点单点变成一个新的连通块。

对于第二个部分，为了不影响其他点上已有的信息，我们把这个操作看成把这个点从它所在的连通块里复制一个新点出来，以后在用这个点的时候都用新点。

考虑这个点曾经有电脑的信息有没有什么用。对于 $n$ 条边的情况，显然没有用；对于 $n-1$ 条边的情况，显然如果只有两个点那么另一个点肯定没有电脑，但这个信息对于之后的操作没有用，而对于更多点的情况，由于我们不知道这个点是什么时候有了电脑，所以根本没办法推理任何信息，也就是说，其他点还是未知状态，这条信息没有用。

总而言之，这个信息只能在树状连通块且 $n=2$ 时产生影响，表示另一个点一定没有电脑。

那么查询的时候判断所在连通块中的边数为 $n$ 或 $n-1$，再特判 $n=2$ 树状连通块和 $n=1$ 即可。

使用并查集可以轻易维护以上所有内容。自环可以正常维护。需要注意删点会改变 $n$ 的大小。

---------

代码经过精巧实现并不难写：

```cpp
int n,q;
int fa[N*5],eg[N*5],siz[N*5];
int re[N];
int tot;
bool info[N];
int find(int x){
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
int opp[N];
int main(){
#ifdef ly
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>q;
    tot=n;
    fr1(i,1,n) fa[i]=re[i]=i,eg[i]=0,siz[i]=1;
    while(q--){
        char op;
        int x,y;
        cin>>op;
        if(op=='-'){
            cin>>x;
            siz[find(re[x])]--;
            eg[find(re[x])]--;
            tot++;
            re[x]=fa[tot]=tot;
            siz[tot]=1,eg[tot]=0;
        }
        else if(op=='+'){
            cin>>x>>y;
            int rx=re[x],ry=re[y];
            if(find(rx)==find(ry)) eg[find(rx)]++;
            else eg[find(rx)]+=eg[find(ry)]+1,siz[find(rx)]+=siz[find(ry)],fa[find(ry)]=find(rx);
        }
        else if(op=='?'){
            cin>>x;
            if(siz[find(re[x])]==1&&eg[find(re[x])]!=1) cout<<"0";
            else{
                if(siz[find(re[x])]==eg[find(re[x])]) cout<<"1";
                else cout<<"?";
            }
        }
    }
    ET;
}
```

---

## 作者：wYYSZLwSSY (赞：0)

哎，遇到这种题真的一点办法都没有，智商真不够。
## 题解
先不考虑电脑坏了的情况。考虑每一次给电脑的过程，我们不能确定谁有了电脑，但是可以确定整个村镇一定多了一个电脑。

考虑将给电脑的两个居民连边，实际上加强了上面的性质，也就是说每给一次电脑这个联通块中一定多了一个电脑。那么，如果这个联通块有联通块大小次给电脑的操作，那么一定可以确定整个联通块的每一个人都有了电脑。否则就不能确定，原因也很显然。整个过程可以用并查集来维护。

再考虑电脑坏了的情况。显然我们只需要考虑电脑坏了的人所在联通块有少于联通块大小（假设是 $n$）的边（也就是有 $n-1$ 条边）的情况。

电脑坏了提供的信息是某个人有过电脑。而如果我们要确定某个联通块有电脑的情况，我们要知道 $n-1$ 个有电脑的信息。所以知道一个人电脑坏了只能在 $n=2$ 时确定，这时等价于连了一个自环。这也不难用并查集维护。

可能有的一个问题是，如果我们在知道一个人电脑坏了时，就已经知道该联通块 $n-2(>0)$ 个有电脑的情况，那是不是就漏了这种情况？其实不会，因为树形联通块一个人有电脑的信息只能来源于一个人电脑坏了，而这时这个人已经没有电脑了，相当于从联通块中“掉”了下去，联通块大小也要减一，所以是没有问题的。

那么怎么维护“掉”下去的过程呢？发现并查集删边困难，考虑不删，给这个人新建一个节点，就解决了。

另外注意特判一下联通块大小为 $1$ 且没有连边的情况。

时间复杂度：$O(q\log q)$。

具体看代码吧。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,q,fa[1300005],t[300005];
char op;
int a,b,cnt,size[1300005];
bool bl[1300005];
int find(int x){
	return fa[x]==x?fa[x]:fa[x]=find(fa[x]);
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
// 	freopen("1.in","r",stdin) ;
	cin>>n>>q;
	for(int i=1;i<=n;++i)fa[i]=i,t[i]=i,size[i]=1;
	for(int i=1;i<=q;++i)fa[n+i]=n+i,size[i+n]=1;
	cnt=n;
	while(q--){
		cin>>op>>a;
		int ta=t[a];
		if(op=='+'){
			cin>>b;
			int tb=t[b];
			int fx=find(ta),fy=find(tb);
			if(fx==fy)bl[fx]=1;
			else {
				fa[fy]=fx;
				bl[fx]=(bl[fx] or bl[fy]);
				size[fx]+=size[fy];
			}
		}else if(op=='-'){
			int fx=find(ta);
			--size[fx];
			t[a]=++cnt;
		}else{
			int fx=find(ta);
			if(size[fx]==1)cout<<bl[fx];
			else cout<<(bl[fx]?'1':'?');
		}
	}
	cout<<'\n';
	return 0;
}
```

---


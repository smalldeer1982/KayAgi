# [PA 2024] Żelki

## 题目背景

PA 2024 3B

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 3 [Żelki](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/zel/)，感谢 Macaronlin 提供翻译**

共有 $n$ 种糖豆，有 $k$ 种颜色，第 $i$ 种糖豆颜色是 $k_i$，重量是 $m_i$，价格 $c_i$。现在要去购买糖豆，购买的糖豆需要包含所有 $k$ 种颜色，且每种颜色购买的数量相同。

问对于在区间 $[0,m-1]$ 的每个整数 $r$，满足购买的糖豆总重量对 $m$ 取模为 $r$ 的购买方案中最小花费是多少？如果不存在满足条件的购买方案，则输出 $-1$。

## 说明/提示

在第一组样例中：

- 为了使糖豆的总重量能被 $m = 6$ 整除，可以不买任何糖豆，这样就不用花钱了。
- 为了使糖豆的总重量除以 $6$ 的余数为 $1$，应购买一颗第一种糖豆，两颗第二种糖豆，一颗第三种糖豆。这样花费为 $10$，得到两种颜色各两颗的糖豆，总重量等于 $7$。
- 为了使糖豆总重量除以 $6$ 的余数等于 $5$，应该买两颗第一种糖豆、三颗第二种糖豆和一颗第三种糖豆。

第二个样例中没有第二种颜色的糖豆，所以唯一可行的方案是不买任何糖豆。

## 样例 #1

### 输入

```
3 2 6
1 2 1
2 2 2
1 1 5
```

### 输出

```
0
10
6
7
3
13
```

## 样例 #2

### 输入

```
2 3 3
1 1 1
3 1 1
```

### 输出

```
0
-1
-1
```

# 题解

## 作者：yuanruiqi (赞：2)

定义一组糖豆为每个颜色各一个的组合。则一个购买方案是一个组合的多重集。一个模 $m$ 意义下价值为 $x$ 的组合的最小花费 $f_x$ 容易 DP 得到。有了 $f_1\cdots f_{m-1}$ 后跑一次同余最短路得到答案。

---

## 作者：james1BadCreeper (赞：1)

先通过 DP 求出每种颜色的物品都买一个，凑出 $i$ 的体积（模 $m$ 意义下的最小代价），$O(nm)$ 可以完成。

最终要求的东西相当于体积模 $m$ 意义下的完全背包，直接跑同余最短路即可。时间复杂度 $O(nm)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64; 
const i64 INF = 1e18; 

inline void ckmin(i64 &x, i64 k) { x = (x < k ? x : k); }

int n, k, m; 
vector<pair<int, int>> a[7005]; 
i64 dp[7005][7005]; // 凑出 j 的体积需要的最小代价
i64 f[7005]; 

int main(void) {
    ios::sync_with_stdio(0); 
    cin >> n >> k >> m;    
    while (n--) {
        int ki, mi, ci; cin >> ki >> mi >> ci; mi %= m; 
        a[ki].emplace_back(mi, ci); 
    }
    memset(dp, 0x3f, sizeof dp); 
    dp[0][0] = 0; 
    for (int i = 1; i <= k; ++i)
        for (auto [w, v] : a[i])
            for (int j = 0; j < m; ++j)
                ckmin(dp[i][(j + w) % m], dp[i - 1][j] + v); 
    
    memset(f, 0x3f, sizeof f); f[0] = 0; 
    for (int i = 1; i < m; ++i)
        for (int j = 0, lim = __gcd(i, m); j < lim; ++j)
            for (int t = j, c = 0; c < 2; c += t == j) {
                int p = (t + i) % m; 
                ckmin(f[p], f[t] + dp[k][i]); t = p; 
            }

    for (int i = 0; i < m; ++i)
        cout << (f[i] < INF ? f[i] : -1) << "\n"; 
    return 0;
}
```

---

## 作者：迟暮天复明 (赞：0)

设 $f_i$ 是每种颜色各取一个，总重量之和 $\text{}\bmod m=i$ 的最小价格。不难发现这个东西是一个分组 01 背包问题。

然后有了这个东西之后就可以跑同余最短路求解了，使用朴素的 dijkstra 时间复杂度就是 $O(n^2+nm)$ 的。

---


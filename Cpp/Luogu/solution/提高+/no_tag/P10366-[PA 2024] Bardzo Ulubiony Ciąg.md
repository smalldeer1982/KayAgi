# [PA 2024] Bardzo Ulubiony Ciąg

## 题目背景

PA 2024 5C1

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 5 [Bardzo Ulubiony Ciąg](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/buc/)，感谢 Macaronlin 提供翻译**

给定长度为 $n$ 的整数数组 $a$，$a$ 的所有子区间和形成长度为 $\frac{n(n+1)}{2}$ 的数组 $b$，子区间和按区间开始下标的递增顺序排列，如果区间开始下标相同，则按区间结束递增顺序排列。

对于新形成的数组 $b$，求满足 $b_i+b_j+b_k=0\ (i<j<k)$ 的 $(i,j,k)$ 对数。

## 说明/提示

**样例解释 1**

数组 $b$ 为 $[7,3,1,-4,-6,-2]$，只有 $3,1,-4$ 这三个不同元素满足，所以答案为 $1$。

**样例解释 2**

数组 $b$ 为 $55$ 个 $0$，任选三个 $i<j<k$ 都满足和为 $0$，因此答案为 $26235$。

## 样例 #1

### 输入

```
3
7 -4 -2
```

### 输出

```
1
```

## 样例 #2

### 输入

```
10
0 0 0 0 0 0 0 0 0 0
```

### 输出

```
26235```

# 题解

## 作者：zjpwdyf (赞：21)

## 0. 前言

作为一道计数/优化枚举的题目，本题比 [[NOIP2022] 种花](https://www.luogu.com.cn/problem/P8865) 难不少，思维难度较大。

本题主要考察的知识点：前缀和、容斥、枚举。

## 1. 大致思路

（注：为了方便计算，接下来先抛去题目中 $i<j<k$ 的条件，最后输出时除以 $3!$ 即可。）

首先不考虑 “$3$ 个区间互不相同” 的条件（即区间可以重复），设方案数为 $A$。

接着考虑 $a$ 种总方案中，有多少种是不合法的（存在重复区间）。

第一类：三个区间均相同，设情况数为 $B$。

第二类：两个区间相同，第三个区间不同，设情况数为 $C$。

则最终答案为 $(A-B-C)/3!$。

## 2. 具体实现

先对数列 $a$ 做前缀和 $s$，这样可以做到 $O(1)$ 查询区间和。

下文设第 $i,j,k$ 个区间的和分别为 $t_1, t_2, t_3$。

### 计算 B：

由于三个区间全部相同，所以 $t_1=t_2=t_3$ 且 $t_1+t_2+t_3=0$，易得 $t_1=t_2=t_3=0$。

所以只需要统计 $a$ 数列有多少个子区间的和为 $0$ 即可，容易实现：

```cpp
for(int l = 1; l <= n; l++)
	for(int r = l; r <= n; r++)
		cnt[a[r] - a[l - 1] + mv]++;
B = cnt[mv];
```

（注：代码中的变量名等会在文章最后有解释，可先去看，再回来理解该段代码）。

---
### 计算 C：


不失一般性的，假设 $i=j$，则易得 $t_1=t_2$。

则由此可得 $t_3 = 0-t_1-t_2=-2\cdot t_1$。

所以只需要枚举和为 $t_1$（或 $t_2$）的区间，再用一个桶统计第三个区间的方案数即可，给出这部分的代码：

```cpp
for(int l = 1; l <= n; l++){
	for(int r = l; r <= n; r++){
		int sum = a[r] - a[l - 1];
		if(sum == 0) C += cnt[mv] - 1;
		else C += cnt[-2 * sum + mv];
	}
}
C *= 3;
```

Q1：当 $t_1=t_2=0$ 时，为什么方案数是 $cnt_0-1$？

A1：因为其中有 “三段区间均相同” 的一种情况，而该情况在 $B$ 中已经统计过了，所以在这里要把它去掉。

Q2：那为什么 $t_1 \ne 0$ 时，就不存在这种重复计算的可能呢：

A2：此时 $t_3=-2 \cdot t_1\ne t_1$，区间和都不相等，区间编号就更不可能相等啦~

Q3：为什么最后 $C$ 要乘以 $3$？

A3：在开头我们假设了 $i=j$。但实际上还有 $i=k$ 和 $j=k$ 这两种情况。

---

### 计算 A：

本题中最难，也是最巧妙的地方（前方高能！）。

不难想到枚举前两个区间，再根据 $t_3=-(t_1+t_2)$ 算出第三个区间的和，用桶加以统计。但是这样做的时间复杂度为 $O(n^4)$，需要优化。

这里给出教练 [noip_1](https://www.luogu.com.cn/user/739052) 的一种奇妙思路：

```cpp
memset(cnt, 0, sizeof cnt);
for(int i = 1; i <= n; i++){
	for(int j = 1; j <= n; j++)
		for(int k = j; k <= n; k++)
			cnt[a[k] - a[j - 1] - a[i - 1] + mv]++;
	for(int j = 1; j <= n; j++)
		for(int k = j; k <= n; k++)
			A += cnt[-(a[k] - a[j - 1] + a[i]) + mv];
}
```

以下记三个区间分别为 $[l_1, r_1], [l_2, r_2], [l_3, r_3]$。

回到题目本身：这三个区间要满足 $t_1+t_2+t_3=0$。把等式稍微变形一下：

$$t_1+t_2+t_3=0$$

$$\downarrow$$

$$(s_{r_1} - s_{l_1-1})+(s_{r_2}-s_{l_2-1})+(s_{r_3} - s_{l_3-1})=0$$

$$\downarrow$$

$$-(s_{r_1}-s_{l_1-1}+s_{r_2})=s_{r_3}-s_{l_3-1}-s_{l_2-1}$$

现在懂了吧！上面的代码所做的工作就是：将等式右边的 $s_{r_3}-s_{l_3-1}-s_{l_2-1}$ 存入桶中，然后枚举等式左边的 $l_1,r_1,r_2$，根据等式进行匹配计数。时间复杂度能做到 $O(n^3)$。

回顾一下暴力做法：将 $t_1+t_2$ 存入桶的时间复杂度为 $O(n^4)$，枚举 $t_3$ 的时间复杂度为 $O(n^2)$。由于没有平衡好两者的关系，所以时间复杂度较高。

## 3. 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 505, V = 4e7 + 5, mv = 2e7;
int n, a[N], cnt[V];
ll A, B, C, ans;
int main(){
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i], a[i] += a[i - 1];
	
	for(int l = 1; l <= n; l++)
		for(int r = l; r <= n; r++)
			cnt[a[r] - a[l - 1] + mv]++;
	B = cnt[mv];
	for(int l = 1; l <= n; l++){
		for(int r = l; r <= n; r++){
			int sum = a[r] - a[l - 1];
			if(sum == 0) C += cnt[mv] - 1;
			else C += cnt[-2 * sum + mv];
		}
	}
	C *= 3;
	memset(cnt, 0, sizeof cnt);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++)
			for(int k = j; k <= n; k++)
				cnt[a[k] - a[j - 1] - a[i - 1] + mv]++;
		for(int j = 1; j <= n; j++)
			for(int k = j; k <= n; k++)
				A += cnt[-(a[k] - a[j - 1] + a[i]) + mv];
	}
	ans = (A - B - C) / 6;
	cout << ans;
	return 0;
}
```

注：

- `cnt` 为计数数组。由于可能出现负数，所以在存入桶前，要加上一个大数（即代码中的 `mv`）。

- 代码中为了方便，直接将 `a` 数组作为了前缀和。

- 记得开 `long long`！

## 4. 后记

[这里](https://www.luogu.com.cn/training/510019) 是我整理的此类题型的题单，持续更新中，大家有好题也可以在评论区推荐给我。

如果您觉得这篇题解对您有帮助的话，请点个赞，感谢 qwq。

---

## 作者：LinkCatTree (赞：2)

[引流](https://linkcattree.github.io/posts/410536798/)。

一句话题意：从长度为 $n$ 的数组 $a$ 中取出三个不相同的区间，问有多少种不同的取法使区间和之和为零（无序）。

根据题意，$b_x+b_y+b_z=0$，假设 $b_x$ 对应的区间为 $a_{i'+1} \cdots a_i$，$b_y$ 对应 $a_{j'+1} \cdots a_j$，$b_z$ 对应 $a_{k'+1} \cdots a_k$。我们可以使用前缀和优化这个式子：$s_i-s_{i'}+s_j-s_{j'}+s_k-s_{k'}=0$，其中 $s_x=\sum_{i=1}^x a_i$。

但是我们发现枚举式子右侧的六个变量时间复杂度为 $\mathcal{O}(n^6)$，无法接受，那么我们可以把三项移到右侧，将式子变为：$s_i-s_{i'}+s_j=s_{j'}-s_k+s_{k'}$。这样对两边的枚举时间复杂度均降为 $\mathcal{O}(n^3)$，可以分开枚举（注意实现时要保证 $j'<j$，对此我们可以在计算 $j$ 前更新一遍 $j'$，这样可以在不破坏效率的情况下维护 $j'<j$，具体可见代码）

但我们发现以上算法有两个问题：

1. 无法保证 $x<y<z$，换句话说就是会重复计算。

2. 可能会统计到不合法的答案（如两个相同的区间）

我们重新观察式子，发现：

1. 当 $x,y,z$ 互不相等时，共会计算 $3!=6$ 次。

2. 当 $x,y,z$ 中有且仅有两数相等时（不合法），会计算 $2$ 次。

3. 当 $x=y=z$（不合法）时，会计算 $1$ 次。

于是我们可以再 $\mathcal{O}(n^2)$ 枚举相等的数，减掉不合法的情况；最终答案即为剩下的合法计数的 $\frac16$。如果对实现或思路有问题，可参考代码（作者太弱了讲不太清楚 QAQ）。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=505,Mx=3e7+5;
int n,a[N],sum[N],f[Mx],base;
map<int,int> g;

inline int id(int x) {return max(x-base+1,0);}

int main() {
	scanf("%d",&n);
	int tmp=0;
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]),sum[i]=sum[i-1]+a[i];
		base=max(base,sum[i]-tmp),tmp=min(tmp,sum[i]);
		for(int i_=0;i_<i;i_++) g[sum[i]-sum[i_]]++;
	}
	base=tmp-base;
	// s[i]-s[i']+s[j]=s[j']-s[k]+s[k']
	ll ans=0;
	for(int j=1;j<=n;j++) {
		int j_=j-1;
		for(int k=1;k<=n;k++)
			for(int k_=0;k_<k;k_++)
				f[id(sum[j_]-sum[k]+sum[k_])]++;
		for(int i=1;i<=n;i++)
			for(int i_=0;i_<i;i_++)
				ans+=(ll)f[id(sum[i]-sum[i_]+sum[j])];
	}
	for(int i=1;i<=n;i++)
		for(int i_=0;i_<i;i_++) {
			int s=sum[i]-sum[i_];
			ans-=3LL*g[-2*s];
			if(!s) ans+=2LL;
		}
	printf("%lld\n",ans/6LL);
	return 0;
}
```

---

## 作者：hyman00 (赞：2)

题目要求选出 $3$ 个不同的区间，不难想到容斥，变成选出任意 $3$ 个区间。

区间转前缀和，相当于选 $6$ 个端点，数据范围是 $500$，容易想到枚举其中 $3$ 个并扔进桶里再枚举另外 $3$ 个，但是这里多了 $l_1\le r_1,l_2\le r_2,l_3\le r_3$ 这三个额外要求。

重点是枚举哪三个量。

如果分别枚举左端点和右端点，这样就很难保证三个要求都满足，而且很难通过再次容斥减掉不合法的。

另一种方法，就是分别枚举一个区间和一个端点，这样你在两边枚举完后就直接有了 $l_1\le r_1,l_2\le r_2$，最后只需要求 $l_3\le r_3$，这实际上构成了一个一维的偏序，我们可以把它扔到时间的维度上，也就是先加入 $l_3=1$ 的，再查询 $r_3=1$​ 的，再加入 $l_3=2$ 的，再查询 $r_3=2$ 的……这样，每次查询的时候只有 $l_3\le r_3$ 的已经被加入了，就保证了正确性。 

最后，怎么容斥得到原题的答案？

记 $(s_1,s_2,s_3)$ 为满足条件的区间组，那么刚才求得的就是 $(s_1,s_2,s_3)$ 的个数，记作 $C$。

然后求 $(s_1,s_1,s_1)$ ，就是区间和为 $0$ 的个数，记作 $A$。

求 $(s_1,s_1,s_2)$ ，先把所有区间和都扔进桶里，枚举 $s_1$，记作 $B$。

求 $(s_1,s_1,s_2),s_1\ne s_2$ ，每一个 $A$ 都会有一次额外贡献，是 $B’=B-A$​。

求 $(s_1,s_1,s_2),s_1<s_2<s_3$ ，每一个 $A$ 都会有一次额外贡献，每一个 $B'$ 都会有三次额外贡献，且变成有序对要除以 $3!$，因此答案是 $C’=\frac{C-3B'-A}{6}$。

这样就在 $O(n^3)$ 的时间复杂度内解决本题。

---

## 作者：dongrunxuan (赞：2)

# P10366 题解　
## 前言
建议升蓝，因为细节很多，降时间复杂度的策略与容斥原理挺难想的。
## 思路
在 $b$ 数组中，任取三个元素，记为 $A$，$B$，$C$。即求满足 $A+B+C=0$ 的 $A$，$B$，$C$ 有多少组。

观察这个式子，发现可以转化为 $-(A+B)=C$，于是可以把任意区间 $C$ 放在计数数组中，枚举区间 $A$ 与 $B$，再判断是否存在区间 $C$，使得 $-(A+B)=C$。

但此算法时间复杂度为 $O(n^4)$，无法通过此题，所以在枚举区间 $A$ 与 $B$ 的过程中，我们可以将式子变形，成为 $-(A+B+x)=C-x$。这样，我们只需要将 $C-x$ 维护到计数数组中，再枚举是否存在区间 $A$ 与 $B+x$ 满足此式子即可。
而 $x$ 实际上就是维护的前缀和中每一个元素，$B+x$ 区间即为 $B$ 区间与 $x$ 合起来的区间，可以用前缀和数组中的元素表示，这样我们只需要一层循环即可枚举 $B+x$ 区间。时间复杂度为 $O(n^3)$，可以通过本题。

### 注意坑点
由容斥原理知，在任选的区间中，会选到两个相同的区间或三个相同的区间相加，需要排除这种干扰。三个相同的区间相加为零，则此区间为零，所以将零区间的个数先维护，最后减去即可。而两个相同的区间相加的情况，要分两种情况，一种是该区间为零，则剩余零区间都可以与它匹配。不为零时，只需要加上区间值为 $-2\times $ 此区间值的区间个数。但由全排列知，每一个两个相同的区间的情况会被选 $3$ 次，所以最后减去三倍该情况。不要忘记，区间有顺序，而我们选的时候无顺序，相当于每种情况计了六次。所以答案最后除以六。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=4e7+10,m=2e7;
int n;
long long ans,cnt3,cnt2;
int a[505],sum[505],mp[maxn];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
	}
	for(int l=1;l<=n;l++)
	{
		for(int r=l;r<=n;r++)
		{
			int val=sum[r]-sum[l-1];
			if(val==0)
			{
				cnt3++;
			}
			mp[val+m]++;
		}
	}
	for(int l=1;l<=n;l++)
	{
		for(int r=l;r<=n;r++)
		{
			int val=sum[r]-sum[l-1];
			if(val==0)
			{
				cnt2+=mp[m]-1;
			}
			else
			{
				cnt2+=mp[-2*val+m];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int l=1;l<=n;l++)
		{
			for(int r=l;r<=n;r++)
			{
				int val=sum[r]-sum[l-1]+sum[i];
				ans+=mp[-val+m];
			}
		}
		for(int l=1;l<=n;l++)
		{
			for(int r=l;r<=n;r++)
			{
				int val=sum[r]-sum[l-1]-sum[i];
				mp[val+m]++;
			}
		}
	}
	ans-=cnt3;
	ans-=3*cnt2;
	ans/=6;
	cout<<ans;
	return 0;
}
```

---

## 作者：yuanruiqi (赞：1)

$i\lt j\lt k$ 的限制是容易的，可以在最后除以 $6$。三个元素不同难以直接分类统计，可以考虑容斥。对于构成三元组的六个变量 $l_1,r_1,l_2,r_2,l_3,r_3$，可以拆成前三个和后三个两部分。对 $l_2$ 和 $r_2$ 扫描线，并枚举另 $4$ 个，桶维护即可。若存在相同的区间，可以将另一个区间存进桶，直接枚举相同的区间。

---


# 双端队列

## 题目描述

Sherry 现在碰到了一个棘手的问题，有 $N(1 \le N \le 200000)$ 个整数需要排序。

Sherry 手头能用的工具就是若干个双端队列。

她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：

1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；

2．将当前数放入已有的队列的头之前或者尾之后。

对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。

请你求出最少需要多少个双端序列。

## 样例 #1

### 输入

```
6
3
6
0
9
6
3```

### 输出

```
2```

# 题解

## 作者：GY程袁浩 (赞：10)

# Solution
因为一定有一个分界点是第一个进入新队列的，在整个队列中位于 $a$ 的位置一定是最前的，而分界点左边的数在 $a$ 中一定是由前到后的顺序，分界点右边同理。所以我们发现了**性质**。

**性质**：
双端队列中的数一定在 $a$ 中的位置（即数组 $a$ 中的下标号）呈**单谷**。（先下降在上升）这意味着，只要满足一个数列在 $a$ 中的位置呈单谷，就一定可以用题目中的操作，构造一个这样的双端队列。

接着由于是要求组合后的队列非严格单调递增，所以先将序列排序。如果考虑对于原序列进行划分，那么会发现很困难。所以考虑对排序的序列划分。那么就是把排序的序列分成几段，使得每个序列从左到右的数在 $a$ 中的位置呈单谷。


如果有了重复的数，就会使得重复的数在 $a$ 中的位置可以是任意一个与其相同的数的位置。

其实重复的数就相当于在排好序的数组中，我们可以任意改变重复数那一段每个数 $a$ 中位置的顺序。

假如目前的队列是在下降的，如果这一段数在 $a$ 中的最大位置小于队列的上个数，那我们就可以直接加入这一段，队列的最后一个数为最小数。如果不是，我们就认定队列开始上升了，队列的最后一个数为最大数。

假如我们目前的队列是在上升的，如果这一段数在 $a$ 中的最小位置大于队列的上个数，那我们就可以加入这一段而不增加一个队列，队列的最后一个数为最大数，否则我们就需要增加一个队列，并重新开始下降。队列的最后一个数为最小数。

我们这样安排重复的数在 $a$ 中的位置，使整体的变化上升下降次数最少，就可以得到需要的最少的队列数了，因为实际上使整体的变化上升下降次数最少的方案是可以包括那些不在策略中的上升或下降的不使目前答案变大的方案的，而使答案变大的方案，就浪费了队列，所以不可能优。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
pair<int,int> a[N];
int ans,n;
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].first,a[i].second=i;sort(a+1,a+1+n);
    ans=1;//先有一段 
    for(int i=1,value=-1,last=0x3f3f3f3f;i<=n;i++)
    {
        int j=i;
        while(j+1<=n&&a[i].first==a[j+1].first) j++;
        /*  pair<int,int> sort
            if(a[i].first==a[i+1].first)
              a[i].second<a[i+1].second  */
        if(value==-1)
            if(a[j].second<last) last=a[i].second;
            else value=1,last=a[j].second;
        else
            if(a[i].second>last) last=a[j].second;
            else ans++,value=-1,last=a[i].second;
        i=j;
        //i++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Moonlight_dreams (赞：7)

# [题目](https://www.luogu.com.cn/problem/P10465)

- 分析题目

  本题的意思翻译成人话其实是对给定的 $n$ 个整数进行排序，可使用的工具是若干个双端队列。处理这些整数时，有两种操作可供选择：一是创建一个新的双端队列，并把当前数作为该队列的唯一元素；二是将当前数添加到已有的双端队列的头部或者尾部。处理完所有数后，把这些队列按一定顺序连接起来，要形成一个非降序的序列，目标是求出最少需要的双端队列数量。

- 解题思路

  要让双端队列的数量最少，就需要让每个双端队列尽可能多地容纳元素。可以先对所有元素按值从小到大排序，若值相同则按原始位置从小到大排序。接着，在遍历排序后的元素时，尝试把它们依次添加到已有的双端队列中，若无法添加就创建新的双端队列。

## AC 代码如下

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
struct stu
{
	int ans , id;
}s[N];
bool cmp(stu x , stu y)
{
	if (x.ans != y.ans)
	{
		return x.ans < y.ans;
	}
	return x.id < y.id;
}
signed main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> s[i].ans;
		s[i].id = i;
	}
	sort (s + 1 , s + n + 1 , cmp);
	int flag = -1;
	int last = 2e9;
	int cnt = 1;
	for (int l = 1 , r = 1; l <= n; l = r)
	{
		while (r <= n && s[l].ans == s[r].ans)
		{
			r++;
		}
		int x = s[l].id , y = s[r - 1].id;
		if (flag == -1)
		{
			if (y < last)
			{
				last = x;
			}
			else
			{
				flag = 1;
				last = y;
			}
		}
		else
		{
			if (x > last)
			{
				last = y;
			}
			else
			{
				flag = -1;
				last = x;
				cnt++;
			}
		}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：Tenil (赞：7)

# Solution

这里是博客：[Tenil](https://www.cnblogs.com/tenil)，刚刚用上了 JS，不妨看看？

## 题意
[原题链接](https://www.luogu.com.cn/problem/P10465)

给定数列 $a_N$，按以下要求分为 $n$ 组：

1.  每组中的数单调不降。
2.  每组中的数**在原数列中的下标**单调递减/单调递增/先递减再递增。（思考一下双向队列插入值的过程显然有：越往两端的越后入队）
3.  存在一种方法，使所有分组拼接后整体单调不降。

求最小的 $n$。

## 分析

题目要求最终序列不降，所以断不可以按照输入顺序处理（所以 Sherry 才觉得棘手呢）。为什么呢？考虑一下样例：


```
3 6 0 9 6 3
```
如果直接按照输入顺序接，显然可以有分组方法： $[0,3,6,9],[3,6]$，不满足要求 $3$。其实就是在不知道所有数的情况下，可能把 $l,r,mid(l < mid < r)$ 的 $l,r$ 和 $mid$ 分在了两组，导致无解。

为了避免无解的情况，一个很明显的策略是把所有数读入不降序排序后再处理，于是要求 $1$ 和 $3$ 容易满足，接下来问题就在要求 $2$：为了满足下标的要求，在排序时记录下标，按排序后的顺序逐位验证要求 $2$，不满足则 $n\gets n+1$ 即可，数据处理流程如下：
```
3 6 0 9 6 3\\初始数据
```
```
0 3 3 6 6 9\\排序后
3 1 6 2 5 4\\下标，验证此数组计数
```

还需注意两个小问题：

1.  初始按照什么单调性来？

    一个完整的队列应是先递增再递减的，所以初始状态应为递减。
2.  相等的数怎么处理？

    相等的数是完全初下标外等价的，相当于可以任意交换，而且一定要放在一组（不然无解或可能不是最小），故相等的数下标自身须有序，即相等的数放在一起，排序后考虑。而内部有序，其实最终只需考虑端点值即可。

```
3 [1 6] [2 5] 4\\相等的数一起考虑
```

## 实现

全部读入，记录下标后升序排序，全部扫一遍，相等的放一起记录端点值，转化为拼接区间。变量记录当前单调性，拼接时：还满足则继续，不满足则反转单调性，当转为递减时队列数增加一。

## Code


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>

using namespace std;

typedef long long ll;

inline ll fr() {
	ll x=0,f=1;char c=getchar();
	while(!isdigit(c)) {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(isdigit(c)) {
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

const int maxn=2e5+1000;

struct node {
	ll x,tag;
}num[maxn];
struct intva{
	ll l=1145141919,r=-1145141919;//这个初始值还没炸过（笑）
}qu[maxn];
ll n,ans=1;
bool down=true;

inline bool cmp1(node n1,node n2) {return n1.x<n2.x;}

int main() {
	n=fr();
	for(register int i = 1; i <= n; i++) {num[i].x=fr();num[i].tag=i;}
	sort(num+1,num+1+n,cmp1);
	ll now=num[1].x,cnt=1;//记得初始化
	qu[1].l=num[1].tag;qu[1].r=num[1].tag;
	for(register int i = 2; i <= n; i++) {
		if(num[i].x!=now) {
			now=num[i].x;
			cnt++;
			i--;//就是换一个区间重新来
		}
		else {
			qu[cnt].l=min(qu[cnt].l,num[i].tag);
			qu[cnt].r=max(qu[cnt].r,num[i].tag);
		}
	}
	for(register int i = 2; i<= cnt; i++) {
		if(down) {
			if(qu[i-1].l<qu[i].r) {
				down=false;
			}
		}
		else {
			if(qu[i-1].r>qu[i].l) {
				down=true;
				ans++;
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
## 后话

感觉有用，还请点个赞吧！

---

## 作者：LJQ0808 (赞：7)

[传送门](https://www.luogu.com.cn/problem/P10465)

题解

题目中说将队列进行排序就可以获得一个非降的序列，那么各个队列中的元素有序、同时不同的队列之间也是有序的。

我们把原序列排序，每个双端队列必定对应一段连续的子序列，且这段子序列里面元素在原序列的位置应该是先递减后递增的。

那么我们用贪心的策略扫一遍，可以加入当前队列的就加入、更新信息，不行就新开一个队列。

有个需要特殊考虑的问题是相同的数。如果有多个相同的数，我们可以随意决定他们的顺序，所以我们只需记录它们中最小的位置和最大的位置。

AC code

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
struct Node1{
	int v,pos;
};
Node1 a[N];
struct Node2{
	int low,up;
};
Node2 b[N];
/*
a[i].v:值
a[i].pos:位置

b[i].low:最小的位置
b[i].up:最大的位置 

tips:b数组相当于题目中队列模拟 
*/
bool cmp(const Node1 x,const Node1 y){
	return x.v<y.v;
} 
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a[i]=(Node1){x,i};
	}
	sort(a+1,a+n+1,cmp);//排序(值) 
	int cnt=1;
	b[cnt]=(Node2){a[1].pos,a[1].pos};//初始化
	for(int i=2;i<=n;i++){
		if(a[i].v!=a[i-1].v){//排序了,不怕 
			b[++cnt].low=2e9;
		}
		b[cnt].low=min(b[cnt].low,a[i].pos);//求最小的位置
		b[cnt].up=max(b[cnt].up,a[i].pos);//求最大的位置
	}
	int ans=1;//答案至少为1  
	int last=2e9,v=0;//last为上一个值 
	for(int i=1;i<=cnt;i++){
		if(v){
			if(b[i].low>=last){//判断 最小的位置≥last 
				last=b[i].up;//last=最大的位置
			}
			else{
				ans++;
				last=b[i].low;//last=最小的位置
				v=0;
			}
		}
		else{
			if(b[i].up<=last){//判断 最大的位置≤last 
				last=b[i].low;//last=最小的位置
			}
			else{
				last=b[i].up;
				v=1; 
			} 
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```

 无注释版：
 
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
struct Node1{
	int v,pos;
};
Node1 a[N];
struct Node2{
	int low,up;
};
Node2 b[N];
bool cmp(const Node1 x,const Node1 y){
	return x.v<y.v;
} 
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a[i]=(Node1){x,i};
	}
	sort(a+1,a+n+1,cmp);
	int cnt=1;
	b[cnt]=(Node2){a[1].pos,a[1].pos};
	for(int i=2;i<=n;i++){
		if(a[i].v!=a[i-1].v){ 
			b[++cnt].low=2e9;
		}
		b[cnt].low=min(b[cnt].low,a[i].pos);
		b[cnt].up=max(b[cnt].up,a[i].pos);
	}
	int ans=1; 
	int last=2e9,v=0;
	for(int i=1;i<=cnt;i++){
		if(v){
			if(b[i].low>=last){ 
				last=b[i].up;
			}
			else{
				ans++;
				last=b[i].low;
				v=0;
			}
		}
		else{
			if(b[i].up<=last){
				last=b[i].low;
			}
			else{
				last=b[i].up;
				v=1; 
			} 
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```

thanks for "Driver_Lao"

---

## 作者：forever_nope (赞：5)

注意到，最后的双端队列只能按照一个顺序拼接，因此：

+ 最终的双端队列中的数，一定是单调递增的。

+ 最终的若干个双端队列，按照一定的顺序，一定是首位相接单调递增的。

我们考虑，这几个双端队列有什么性质。

注意到，我们把排序后的数组，分成若干段，这每一段：

+ 元素在原数组中的下标（用 $\mathit{id}$ 表示）一定是，先下降再上升的谷形。

那么，这个每一个谷，都可以用一个双端队列存储，问题转化为，

将排序好的数列，分为若干段，最小化段数，使得每一段的 $\mathit{id}$ 为谷形。

但是，注意到原数组中可能存在相同的数字，考虑如何处理，容易得出：

+ 原数组中，相同的数字，下标单调的存放，一定不劣。

因为，一次由上升转为下降，就需要多一段，这是我们不希望的。

于是，我们分类讨论，

+ 如果现在处于下降趋势，
	+ 如果当前段加入后，能维持下降，那么加入；
    + 否则，将趋势转为上升，然后加入。
+ 如果现在处于上升趋势，
	+ 如果当前段加入后，能维持上升，那么加入；
    + 否则，将趋势转为下降，加入后答案加一。

这里考虑到，如果不按照这个趋势来，那么后面的区间再加入，此时答案一定更大，

而后面的区间不会影响到其再后面的答案，因此贪心正确。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define range(x) (x).begin(), (x).end()

struct emm {
    int v, id;
    friend bool operator <(const emm &a, const emm &b) {
        return a.v == b.v ? a.id < b.id : a.v < b.v;
    }
};

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n; vector<emm> a(n);
    for (int i = 0; i < n; ++i) a[i].id = i + 1, cin >> a[i].v;
    sort(range(a));
    int cnt = 1, mx = 1e9, dir = -1;
    for (int l = 0, r = 0; l < n; l = r) {
        while (r < n && a[l].v == a[r].v) ++r;
        int u = a[l].id, v = a[r - 1].id;
        if (dir == -1) {
            if (v < mx) mx = u;
            else mx = v, dir = 1;
        }
        else if (dir == 1) {
            if (u > mx) mx = v;
            else mx = u, dir = -1, ++cnt;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

这里面用到了经典的将区间分为值相同的若干段的方法。

---

## 作者：ZMT_CN725qh (赞：3)

# 题解：P10465 双端队列

## 题意  
首先来看题目。其意思大概就是，要处理$\ N\ $个数，把它们存放在双端队列里面，这些队列能够按照一定顺序连起来得到一个**非降**的序列，最后输出最少需要多少个双端队列。  

题目有两个要求：新建一个双端队列，并且将输入的元素作为这个队列中的唯一的数；把输入的元素从已有队列的**队头**或**队尾**入队。

## 分析  
这个问题需要按照输入的顺序，把输入的元素放在双端队列里面。如果直接求解的话，就很容易出错，因为不知道后面元素的大小，这样会导致求出来的答案不是最优解。  

我们可以先用一个结构体数组$\ a\ $按照输入的顺序把所有元素存放好，再给每个元素编个序号，表示是第几个输入的，然后再给元素**从小到大**排序，因为题目说最后这些双端队列连在一起是一个**非降**的序列。  

我们可以用样例来举例。首先输入的元素放在$\ a\ $数组中依次为$\ [3,6,0,9,6,3]\ $，编号为$\ [1,2,3,4,5,6]\ $。对$\ a\ $数组元素排序，排序后的元素为$\ [0,3,3,6,6,9]\ $，编号变为$\ [3,1,6,2,5,4]\ $。

此时我们可以发现，对于第$\ i\ $个编号，如果它左边是**单调递减**，右边是**单调上升**，那么$\ a_i\ $就为该双端队列的第$\ 1\ $个元素。因为编号$\ i\ $左右两边的编号都比它大。  

我们还可以发现一个性质，数值相等的几个元素，最后必然挨在一起，所以我们不妨把这几个**重复元素**按照编号排序，然后放在同一个双端队列里面。  

因此我们对$\ a\ $的元素排完序以后，扫描它的编号序列，如果有左边**单调下降**，右边**单调上升**的元素，那么就要把它，以及它的左右两边的所有元素，放在同一个双端队列。最后统计用了几个双端队列。  

## 代码思路  
首先将输入的元素放在结构体数组$\ a\ $里面，给$\ a\ $的所有元素编上序号，然后按照$\ a\ $数组的元素数值大小排序，处理**重复**的元素放在一起。对于每个**重复**的元素组，可以用一个数组$\ in\ $记录这组元素的**最大值**和**最小值**，这样就不用管中间的元素。然后再用一个结构体变量$\ vi\ $，从最开始记录，此时新加入的重复元素组与之前队列末尾的元素，是**单调上升**还是**单调下降**。然后再记录队列末尾的元素数值。  

如果此时队列是**递增**的，那么新加入来的元素组就要用**最小值**和末尾的元素比较，来判断接下来是**递增**还是**递减**。反之，如果队列此时是**递减**的，就要用**最大值**和队列末尾元素比较。  

时间复杂度$O(N\ log\ N)$。

空间复杂度$O(N)$。
## Code  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200010;

struct nd_in{ // 记录每组重复元素的最大值和最小值
    int Max;
    int Min;
} in[N];

struct nd_a{
    int sum; // 数值
    int num; // 编号
} a[N];

struct nd_vi{ // 标记
    bool sox; // 此时是上升还是下降
    int res;  // 此时的数值
} vi;

bool cmp(nd_a x, nd_a y) { // 对 a 数组的 sum 排序
    return x.sum < y.sum || (x.sum == y.sum && x.num < y.num);
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i].sum);
        a[i].num = i;
    }
    
    sort(a + 1, a + n + 1, cmp); // 排序
    
    int k = 1;
    in[1].Min = a[1].num;
    in[1].Max = a[1].num;
    
    for (int i = 2; i <= n; i++) { // 扫描 a 数组
        if (a[i].sum == a[i - 1].sum) { // 相邻两个数相等
            in[k].Max = max(in[k].Max, a[i].num); // 更新 in[k] 的最大值和最小值
            in[k].Min = min(in[k].Min, a[i].num);
        } else {
            k++;
            in[k].Max = a[i].num; // 如果不相等，k++ 更新下一组重复的
            in[k].Min = a[i].num;
        }
    }
    
    vi.sox = true; // 这里记上升为 false，下降为 true
    vi.res = in[1].Max;
    int qu = 1; // 需要双端队列的列数
    
    for (int i = 2; i <= k; i++) { // 扫描 in 数组
        if (!vi.sox) { // 上升
            if (in[i].Min < vi.res) { // 无法继续上升
                vi.sox = true; // 转为下降
                vi.res = in[i].Min;
                qu++; // 每出现一个谷点就要增加一个双端队列
            } else {
                vi.res = in[i].Max; // 可以继续上升
            }
        } else { // 下降
            if (in[i].Max > vi.res) { // 无法继续下降
                vi.sox = false; // 转为下降
                vi.res = in[i].Max;
                // 因为下一组元素无论是上升还是下降，都可以和此时的这一组元素接在一起
                // 也就是说，下一组元素可以和这组元素放在同一个双端队列
                // 因此 qu 不用 ++
            } else {
                vi.res = in[i].Min; // 可以继续下降
            }
        }
    }
    
    printf("%d\n", qu);
    return 0;
}
```

## 最后  
本题的思路来源《算法竞赛进阶指南》。

代码写的感觉应该比较好理解，希望能帮到大家。

---

## 作者：zhenghuangzhe (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10465)

## 题目简述

Sherry 要对 $N$ 个整数进行排序，手头工具是若干双端队列。在依次处理数时，对于每个数可选择新建一个双端队列并将其作为队列中唯一的数，或者将其放入已有的队列头之前或尾之后。处理完所有数后，将队列按一定顺序连接起来得到非降序列，要求求出最少需要的双端队列数。

## 思考过程

如果没有任何思考过程，我们不妨分析一下样例：


```
3 6 0 9 6 3
```

因为最后的序列是一个非降序列，我们先还原最后的状态，也就是排序。

排序过后的结果：

```
0 3 3 6 6 9
```

但排完序后，每个数的下标会出现变化，所以得先记录一遍下标。

排序过后的下标，也就是最终状态：

```
3 1 6 2 5 4
```

接下来，我们用画图的方式模拟。

先看第一个数，肯定是直接进双端队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/4diyb89c.png)

第二个数，因为要保证每个双端队列内的数的下标成非降序列，比第一个数大，也直接进双端队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/46lxfyvo.png)

第三个数，也可以进双端队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/f44qyvds.png)

第四个数，由于下标不符合规律，所以得开第二个双端队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/n5obb9p4.png)

到第五个数，就有点意思了。

本来，如果第五个数进双端队列的话，第六个数又要开一个双向队列，但因为这两个数相等，我们可以**先进第五个数，再进第四个数**。这样就可以只开两个双端队列了。

这里详细解释一下：因为这两个数相等，我们可以灵活调整它们在双端队列中的插入顺序，使得它们能在同一个双端队列中且满足最终连接起来是有序的要求。

以当前情况为例，先插入第五个数（其下标为 5），再插入第四个数（其下标为 4），由于这两个数的值相等，这样的插入顺序不会影响最终连接成非降序列的结果，同时又能保证在一个双端队列中。

![](https://cdn.luogu.com.cn/upload/image_hosting/csb4mca9.png)

第六个数也可以直接进双端队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/01fmqyo5.png)

所以，本题的规律是：

1. 下标默认顺序为先下降后上升或直接上升。这里解释一下：在每个双端队列内，数的下标呈现这样的规律，是为了保证将双端队列连接起来后能形成非降序列。例如，如果下标顺序混乱，可能会导致连接后无法得到正确的非降序列。
2. 如果几个数相等，则可以调整顺序。因为相等的数在最终的非降序列中顺序是可以灵活调整的，所以在插入双端队列时，我们可以根据下标的情况来合理安排它们的插入顺序，以减少双端队列的数量。

知道规律了，便可以写出代码了。

## 参考代码


```cpp
#include<bits/stdc++.h>
using namespace std;
// 定义结构体，用于存储数的值和其对应的下标
struct point{
	int num, id;
}s[200010];
int n, ans = 1;
// 多关键字排序的比较函数
// 首先按数的值从小到大排序，如果值相等，则按下标从小到大排序
bool cmp(point x, point y)
{
	return x.num < y.num || x.num == y.num && x.id < y.id; 
}
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
	{
		scanf("%d", &s[i].num);
		s[i].id = i; // 记录每个数的原始下标
	}
    // 对结构体数组进行排序
	sort(s + 1, s + 1 + n, cmp);
	int f = -1, num = 1e9;
    // p 和 q 用于遍历排序后的数组，处理相同数值的数
	for(int p = 1, q = 1; p <= n; p = q)
	{
        // 找到与 s[p] 数值相等的数的最后一个位置
		while(q <= n && s[p].num == s[q].num) q++;
		int u = s[p].id, v = s[q - 1].id;
		if(f == -1)
		{
            // 如果 v 小于 num，更新 num 为 u，这里是为了记录当前处理的数的下标情况
			if(v < num) num = u;
			else
			{
				// 如果 v 大于等于 num，说明下标顺序开始变化，标记 f 为 1
				f = 1;
				num = v;
			}
		}
		else if(f == 1)
		{
            // 如果 u 大于 num，更新 num 为 v，继续维护下标顺序
			if(u > num) num = v;
			else
			{
                // 如果 u 小于等于 num，说明需要新开一个双端队列，更新 f 为 -1，更新 num 为 u，双端队列数量加 1
				f = -1;
				num = u;
				ans++;
			}
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：atomic_int (赞：3)

直接做不好做，于是考虑倒着做。

最后我们会得到一个非降的序列，由于题目中最终序列是由若干个双端序列拼成的，于是考虑排序后的序列最多能够划分成多少个双端队列，如果我们将排序后每个元素的原下标写出来，能够发现：对于一段上升、下降和先下降后上升的区间，可以构成一个双端队列，上升对应放入队尾，下降对应放入队首。例如：设原序列 $A = [3, 2, 5, 4, 1]$，排序后 $A' = [1, 2, 3, 4, 5]$，原下标序列为 $B = [5, 2, 1, 4, 3]$，为了使双端队列的数量最小化，我们要尽可能让区间满足第三种情况，划分后得到 $B' = \big[[5, 2, 1, 4], [3]\big]$，至少需要两个双端队列。

现在需要考虑，当序列中存在相同元素时，原下标该如何排序。

- 可以先把所有相同元素对应的区间记录下来，考虑进行合并。
- 设第一个区间为下降。
  - 这样答案不会更劣。如果存在一种情况第一个和第二个区间能够组成上升的区间，同样我们也可以让第一个和第二个区间组成先下降后上升的区间。
- 往后进行合并，记录当前区间末尾的状态：
  - 下降：与下一个区间最大值比较，看看是否能够拼接上，否则状态变成上升。
  - 上升：与下一个区间的最大值比较，看看是否能够拼接上，否则双端队列数量加 $1$，状态变成下降。

时间复杂度为 $O(N \log N)$。

```cpp
#include <bits/stdc++.h>

int N;
std::pair<int, int> arr[200005];
std::vector<std::pair<int, int>> seg;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin >> N;
    for (int i = 1; i <= N; i++) {
        std::cin >> arr[i].first;
        arr[i].second = i;
    }
    std::stable_sort(arr + 1, arr + N + 1, [&](auto lhs, auto rhs) {
        return lhs.first < rhs.first;
    });
    for (int i = 1; i <= N; i++) {
        int j = i;
        while (j < N && arr[j].first == arr[j + 1].first) j++;
        seg.push_back({i, j}), i = j;
    }
    int ans = 1;
    std::pair<int, int> state = {2e9, 0};
    for (auto &i : seg) {
        if (!state.second) {
            if (state.first > arr[i.second].second)
                state.first = arr[i.first].second;
            else
                state = {arr[i.second].second, 1};
        } else {
            if (state.first < arr[i.first].second)
                state.first = arr[i.second].second;
            else
                state = {arr[i.first].second, 0}, ans++;
        }
    }
    std::cout << ans << '\n';
    return 0;
}
```

---

## 作者：FZY_CZY (赞：1)

# 题意
1. 你有一个序列，里面有若干个数，你同时拥有若干个双端队列。
2. 你需要从前往后遍历每一个元素，对于每一个元素，你可选择一个双端队列，从前插入或从后插入。
3. 我们希望所有元素插入之后，所有双端队列顺次连接，构成一个单调不减的序列。
4. 请问所需要双端序列的最小值。

# 思路
## 窥得一隅
如果用最坏的方法，双端序列的个数等于元素个数，但是我们可以考虑合并。
考虑能否只用 $1$ 个双端序列，很明显，有一个数 $x$ 要插入队列 $q$，如果 $x\le q_1$，则 $x$ 可以插入队头，如果 $x\ge q_m$，则 $x$ 可以插入队尾。

显然这是对的，但是如果我们有一个 $x\in (q_1,q_m)$，就无法插入队头或者队尾了，但是我们最后需要一个单调不减的序列，所以很多情况下，$1$ 个双端队列不足以通过队头和队尾的插入来构建一个单调不减的序列。

那我们怎么办呢？
## 渐入佳境
虽然我们发现直接输出 $1$ 是错的，但是在刚刚那个错误的思路中，我们知道了元素插入双端队列的方式，也知道了问题，但是我们换一个角度，如果我们有 $k$ 个双端队列，那么，在我们插入的时候，对于每一个双端队列，是不是就是通过和队尾与队头的比较来插入，所以每个队列内部同样也是单调不减的 ~~废话~~，这个时候，我们就可以观察队列内部的元素在原始序列的编号有什么规律。

多次模拟后，不难发现，队列内部的标号呈现单谷的样子，其中又有什么奥妙呢？

可以假定，在最终的某个双端队列 $q$ 中，它最初的元素在第 $k$ 位，而 $q_k$ 表示这个元素的编号。

因为最初的元素是 $k$ 位，所以显然的，$q_k$ 是双端队列 $q$ 中的最小值，考虑剩下的数以及下标 $i$：
1. 考虑 $\forall i \in (k, m]$，因为 $q_i$ 比 $q_{i-1}$ 更后进入双端队列，所以 $q_i > q_{i-1}$。
2. 反之亦然。

所以，每个队列中是呈现单谷状的。
## 结论
既然每个队列中，每个元素的编号的排列是呈现单谷状的，而所有队列合并在一起等价于排序后的原序列，那么我们可以利用多关键字排序，考虑在排序后的原序列中，以每个元素原本的位置绘成函数图像，计算图像中有多少个区间内部是呈单谷状的，就是答案。

# 代码
结论可能有点小抽象，看一下代码（码风有点丑）。
```cpp
#include <bits/stdc++.h>
#define upp(a,x,y) for (int a=x;a<=y;a++)
#define dww(a,x,y) for (int a=x;a>=y;a--)
#define pb(x) push_back(x)
#define endl '\n'
#define x first
#define y second
using namespace std;
typedef pair<int,int>PII;
const int N=200010;
int n;
PII a[N];
int main(){
    cin>>n;
    upp(i,0,n-1)
    {
        cin>>a[i].x;
        a[i].y=i;
    }
    sort(a,a+n);
    int res=1,last=INT_MAX,dir=-1;
    int i=0;
    while (i<n)
    {
        int j=i;
        while (j<n&&a[j].x==a[i].x) j++;
        int minp=a[i].y,maxp=a[j-1].y;
        if (dir==-1)
        {
            if (last>maxp) last=minp;
            else dir=1,last=maxp;
        }
        else
        {
            if (last<minp) last=maxp;
            else dir=-1,last=minp,res++;
        }
        i=j;
    }
    cout<<res;
    return 0;
}
``````
完结撒花！！！

---

## 作者：Toorean (赞：1)

十分优美的一道思维题！

给出长度为 $n$ 的序列 ${a_i}$，求**至少**需要多少个双端队列可以使其首尾相连使原序列不降？

直接模拟着做是不好做的，我们考虑转化问题为如何划分**排序后**的序列成多个双端队列。

我们观察双端队列的性质：
假设我们依次将 $q_1,q_2\cdots,q_m$ 入队。在第 $i$ 次中，我们无论如何入队，$i$ 总是大于队列中**任何**元素的下标的。也就是说，双端队列中，以下标最小值为中心，这是向两边**递增**扩散的。我们称这种是**单谷**的。

其次，我们考虑相同元素的情况。实际上，相同元素的顺序使可以**随意交换**的。也就是说，这些相同元素，**必然**处于同一单谷内。

我们对当前处于阶段进行分类讨论。
- 若当前处于下降期，我们记录前面元素**最小**下标 $im$，若当前最大下标小于 $im$，那么说明可以继续下降；反之，需要改向上升期，并更新 $im$。
- 若当前处于上升期我们记录前面元素的**最大**下标 $jm$，若当前最小坐标大于 $jm$，那么说明可以继续上升；反正，需要改为下降期，并将答案更新。

综上，可以在 $\mathcal O(n\log n)$ 的复杂度解决问题。

---

## 作者：HuangTingFu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10465)

[前置知识](https://blog.csdn.net/qq_67693066/article/details/137949615)

观察题目,注意到数据范围 $n \le 200000$，排除暴力。

由于题目要求**非降序**，可以先使用
```cpp
sort(a+1,a+1+n,cmp);
```
排序。同时为了记录原来的下标，$a$ 数组要定义为结构体类型，存储下标和数值。
```cpp
struct point{
  int x,id;//a[i].x表示值，a[i].id表示下标
}a[200010];
```
为了保证稳定性，相同元素不改变先后顺序，cmp 函数如下：

```cpp
bool cmp(point x,point y)
{
  if(x.x!=y.x) return x.x<y.x;
  else return x.id<y.id;
}
```
~~我好像发现了让快排稳定的方法~~

思考：在什么样的情况下，元素能放进同一个双端队列，而不破坏单调性？手动模拟几组后发现，在每个双端队列中，元素的下标是一个**单谷**。

拿样例举例：先排序，得到序列

| 序号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 数值 | 0 | 3 | 3 | 6 | 6 | 9 |
| 下标 | 3 | 1 | 6 | 2 | 5 | 4 |

在这里，我们用变量 $ans$ 表示答案。  
先将最小的 0 入队，由于没有双端队列所以新建一个，$ans+1$。将第一个 3 进到 0 的左边，第二个 3 进到 0 的右边。这时，我们发现第一个 6 无法进队，只好在建一个双端队列，$ans+1$。注意，第二个 6 要进到它左边，不然 9 无法进到它右边。因此，我们在代码中要跳过相同的数字。
```cpp
while(q<=n&&a[p].x==a[q].x) q++;
```

## 代码实现（有注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=1;//ans存答案
struct p{
	int x,id;//a[i].x表示值，a[i].id表示下标
}a[200010];
bool cmp(p x,p y)
{
	if(x.x!=y.x) return x.x<y.x;
	return x.id<y.id;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].x;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);//排序
	int dir=-1;//dir表示当前方向，1是上升，-1是下降。
	int num=2e9;//num表示上一个数
	for(int p=1,q=1;p<=n;p=q)
	{
		while(q<=n&&a[p].x==a[q].x) q++;//跳过相同的数
		int u=a[p].id,v=a[q-1].id;
    //判断是否改变方向
		if(dir==-1)
		{
			if(v<num) num=u;
			else
			{
				dir=1;
				num=v;
			}
		}
		else
		{
			if(u>num) num=v;
			else
			{
				dir=-1;
				num=u;
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

第一篇题解求过QWQ

---

## 作者：Noob_Oler (赞：0)

# 题解：P10465 双端队列

## 题意
通过双端队列对长度为 $n$ 的序列排序。依次处理每个数，能进行以下操作：

$1.$ 新建一个双端队列，当前数字作为这个队列中的唯一值。

$2.$ 当前数字从已有双端队列的队首或队尾入队。

全部处理完后，已有的双端队列首尾相连，需要得到一个单调不降的长度为 $n$ 的序列。

至少需要多少个双端队列？

$n\le 2 \times 10^5$

## 思路
由于是按顺序处理的每一个值，所以我们对于任意双端队列，其元素的下标序列满足单谷性质。

可以对原始序列排序，求出排序后的下标序列（元素在原序列中的下标）。

随后，把这一序列以最少的段数分隔，每一段的元素值序列均为单谷状（先递减后递增）。

可用贪心思想求解。

第一个元素分到第一个段。

对于第 $i$ 个元素，若其和第 $i-1$ 个元素放到同一段时仍符合要求，则放到同一段。

否则，第 $i$ 个元素放到新的一段。

需要注意的细节：如何处理原序列中的相同元素？

排序后得到的下标序列，若其中某一段对应的初始值相等，则该段元素可以任意交换。

设上次所用的下标为 $last$。

设接下来连续 $d$ 个下标对应的原始值均相等，其中最小为 $l$ 最大为 $r$。

为了保证贪心策略的正确性，可以按如下方式操作：

+ 若当前在考虑下降的情况，若 $r<last$，则这 $d$ 个元素接在 $last$ 后面仍表示下降，同时令`last = l`否则，这 $d$ 个元素接在 $last$ 后面表示上升，同时令`last = r`。

+ 若当前在考虑上升的情况，若 $l>last$，则这 $d$ 个元素接在 $last$ 后面仍表示上升,同时令`last = r`否则，这 $d$ 个元素属于新的一段表示下降，同时令 `last = l`。

---


# [XJTUPC 2024] 最后一块石头的重量

## 题目描述

有一堆石头，用整数数组 $a$ 表示。其中 $a_i$ 表示第 $i$ 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x \le y$。那么粉碎的可能结果如下：

- 如果 $x = y$，那么两块石头都会被完全粉碎；
- 如果 $x \neq y$，那么重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头新重量为 $y-x$。

最后，**最多只会剩下一块**石头。输出此石头**最小的可能重量**。如果没有石头剩下，就输出 $0$。

## 样例 #1

### 输入

```
6
2 7 4 1 8 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5
31 26 33 21 40
```

### 输出

```
5
```

# 题解

## 作者：AFewSuns (赞：10)

背包板子，来水一篇题解。

### 题目大意

给定一个长度为 $n$ 的数组 $a$，每次可以选定两个数，若这两个数相同则同时删掉；否则将较小值删掉，然后将较大值修改为它们的差。问最后剩下的数的最小值。

$1 \leq n \leq 10000,1 \leq a_i \leq 5000$。

### 题目分析

先进行一些简单的转化。不妨允许存在负数，那么最终每个数的贡献都会是 $+1$ 或 $-1$，需要最小化的则是最后的和的绝对值。

具体而言，我们的操作可以看作是每次选择一个数 $y$ 去跟当前的数 $x$ 进行“抵消”。若 $x>0$ 则将 $x$ 减去 $y$；若 $x \leq 0$ 则将 $x$ 加上 $y$。

这乍一看会有加入顺序导致的 $\pm 1$ 限制，但其实我们完全可以将它看成任意选取 $\pm 1$ 的系数后最小化和的绝对值。这是为什么呢？

设 $S_{+}$ 为选取 $+1$ 的数的集合，$S_{-}$ 为选取 $-1$ 的数的集合，那么可以在当前数 $>0$ 的时候选取 $S_{-}$ 内的数进行减法，在当前数 $\leq 0$ 的时候选取 $S_{+}$ 内的数进行加法，就完全符合操作的限制了。

如果最后发现某个集合空了，不妨假设是 $S_{-}$ 空了，那么在当前 $>0$ 的时候就不得不使用 $S_{+}$ 的数了。但这显然不优，因为把这些数的系数换成 $-1$ 即可使得最后的绝对值减小。

---

设 $sum=\sum\limits_{i=1}^{n}{a_i}$，将整体加上 $sum$ 再除以二就变成了 $01$ 背包问题，需要在和 $\leq \frac{sum}{2}$ 的同时最大化和。

设 $a_i$ 最大值为 $V$，minstdfx 的做法是随机打乱后 bitset 优化 01 背包 $\mathcal O(\frac{n\sqrt{n}V}{\omega})$。

实际上有 $\mathcal O(nV)$ 的做法，[具体做法在这里](https://www.cnblogs.com/AFewSuns/p/knapsack.html#%E6%9B%B4%E4%BC%98%E7%A7%80%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A7%A3%E6%B3%95)，或者参考 [ABC221G 的题解](https://www.luogu.com.cn/problem/solution/AT_abc221_g)。

具体地，先贪心从前往后选取一段前缀的物品使得他们的和刚好 $\leq \frac{sum}{2}$，设选取的前缀为 $[1,pos]$，然后将序列分为 $\leq pos$ 和 $> pos$ 两部分。

考察最后选取的物品，一定是从当前的状态下，删去 $\leq pos$ 的一些物品，再加上 $>pos$ 的一些物品得到的。注意到可以通过合理安排顺序使得过程中的和始终在 $(\frac{sum}{2}-V,\frac{sum}{2}+V]$ 中间。

于是设 $f_{r,w}$ 表示最大的 $l$，使得仅操作 $[l,r]$ 内的数可以凑成 $w$。这里操作指的是删去 $[l,pos]$ 中的数或加入 $(pos,r]$ 中的数。

转移分为三类：

- $f_{r,w} \leftarrow f_{r-1,w}$，即从 $r-1$ 转移过来且不操作 $r$；

- $f_{r,w+a_r} \leftarrow f_{r-1,w}(w \leq \frac{sum}{2})$，即从 $r-1$ 转移过来且操作 $r$；

- $f_{r,w-a_l} \leftarrow l(w > \frac{sum}{2},l < f_{r,w})$，即从左边转移过来且操作 $l$。

注意第三步转移中，若 $l<f_{r-1,w}$，那么这种情况会在 $r-1$ 时被转移（之后通过第一步转移回来），所以只需要转移 $l \geq f_{r-1,w}$ 的部分，单次转移复杂度是 $\mathcal O(f_{r,w}-f_{r-1,w})$，所以总的复杂度是对的。由于第二维的范围在 $(\frac{sum}{2}-V,\frac{sum}{2}+V]$ 内，是 $\mathcal O(V)$ 的，所以总时间复杂度为 $\mathcal O(nV)$。

---

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using namespace my_std;
ll n,m,all=0,V=5000,a[10010],f[2][10010];
int main(){
	n=read();
	fr(i,1,n) a[i]=read();
	fr(i,1,n) all+=a[i];
	m=all/2;
	ll pos=0,sum=0;
	while(pos<n&&(sum+a[pos+1])<=m){
		pos++;
		sum+=a[pos];
	}
	f[pos&1][sum-m+V]=pos+1;
	fr(i,pos+1,n){
		ll o=i&1;
		fr(j,1,2*V) f[o][j]=0;
		fr(j,1,2*V) f[o][j]=max(f[o][j],f[o^1][j]);
		fr(j,1,V) f[o][j+a[i]]=max(f[o][j+a[i]],f[o^1][j]);
		pfr(j,2*V,V+1) fr(k,f[o^1][j],f[o][j]-1) f[o][j-a[k]]=max(f[o][j-a[k]],k);
	}
	pfr(i,V,1){
		if(f[n&1][i]){
			write(all-2*(m+i-V));
			return 0;
		}
	}
}
```

---

## 作者：hgckythgcfhk (赞：9)

鉴于大家对题解区现有的唯一一篇题解评价并不好，我决定写一篇详细的题解。

>注意到本题是一个背包。

这句话省略了很多东西，感觉和没说一样。

首先先说为什么是个背包，手搓样例 $2$ 可以发现，最优策略并不只是简简单单的大的和小的相互抵消，而是要利用大的和小的操作会使大的减小这个性质进行下一步。

具体的，我给一下样例 $2$ 的解释就很好理解了。

第一次操作：

```cpp
40 21 ->19
```

第二次操作：

```cpp
33 31 ->2
```

此时，我们剩下的石子的状态是：

```cpp
2 19 26
```

然后我们就可以简简单单的用小的消耗大的。

```cpp
26 19 ->7
```

```cpp
7 2 ->5
```
于是我们发现，我们有时候需要利用一个大的和一个小的制造一个相对中等的，然后用这个中等的去继续操作。

于是，我们不难想到用字母一般化这个过程，推一推式子，~~主要是实在想不出来该干点什么~~。

以 $5$ 个数 $a,b,c,d,e$ 为例，发现顺序不影响结果，于是我们默认有序，即 $a\le b\le c\le d\le e$。

样例 $2$ 的一般形式相当于：

$e,a\to e-a$

$d,c\to d-c$

到这里也许我说的是废话，但是下面就有用了。

$b,e-a\to b-(e-a)$

$b-(e-a),(d-c)\to b-(e-a)-(d-c)$

拆开括号：

$b-e+a-d+c$

这个不好看，换个顺序：

$a+b+c-d-e$

有没有发现，这些操作下来相当于把所有数分成两组，求两组的差的最小值。

当然这个东西可以用更复杂的例子去验证，自己动手并不麻烦，但会大幅度增加题解的篇幅，所以我不作展示，总是，这个结论的正确性是很好理解的。

于是我就想起来一个题，做法是随机打乱数组，然后用一种正确率还行的贪心，这样进行很多次取最小值，具体这个贪心怎么写不做赘述，感兴趣的看[这题](https://www.luogu.com.cn/problem/P1675)。

但是，这个正确率放在本题的数据范围下并不怎么样。

于是想到背包，具体的，状态转移方程如下：

$dp_{i+1,j+a_i}\gets dp_{i,j}$

$dp_{i+1,j-a_i}\gets dp_{i,j}$

时间复杂度 $O(n\sum a_i)$ 明显过不了。

于是考虑 ```bitset``` 优化，优化需要我们写成一个方便位运算的形式，首先得写成 $dp_{i,j}=\dots$ 的形式，于是整体带换一下，则有：

```dp[i]=(dp[i-1]<<a[i])|(dp[i-1]>>a[i])```

但是，我们还漏了一种情况，我们可以用新加进来的石子减前面的石子，于是有：

```cpp
for(int k=0;a[i];--a[i],++k)dp[f][k]=dp[f][k]|dp[f^1][a[i]];
```

这里加了滚动数组优化，否则会 MLE。

于是可以写出程序。

```cpp
signed main(){open;int n,a;cin>>n;dp[0][0]=1;
	for(int i=1;i<=n;++i){rg const bool f=i&1;cin>>a;
		dp[f]=(dp[f^1]<<a)|(dp[f^1]>>a);
		for(int k=0;a;--a,++k)dp[f][k]=dp[f][k]|dp[f^1][a];
	}for(int i=0;i<5001;++i)if(dp[n&1][i])return cout<<i,0;
}
```

这个程序会在 #4 出错，经过我大量实验发现，是因为 ```bitset``` 需要开的很大，但是我们开的不够大，正确的做法是随机打乱一下 $a$ 数组，具体很好实现，我就不写了。

---

## 作者：minstdfx (赞：6)

简单题。  

对 $U$ 的每一子集 $S$，设 $F(S)=|\sum_{x\in S}x-\sum_{x\in \complement_US}x|$，则答案是 $\min_{S\in U}F(S)$。接下来我们证明对于每一可能的子集 $S$，均存在一种构造方案使得答案为 $F(S)$。

给出一种考场上想出的构造方式：维护两个集合 $S,T$ 表示对应的子集和补集，每次任取 $S,T$ 中的两个元素 $a\in S,b\in T$，把它们从集合中删去，并将他们的差值 $|a-b|$ 加入 $a$ 和 $b$ 中较大的那个对应的集合中。  
接下来证明这么做是对的：考虑对于 $|S|\cdot|T|=0$ 的情况，正确性是显然的，每一步操作也不影响值 $|\sum_{x\in S}x-\sum_{x\in T}x|$，且由于每步必然有一个集合大小缩减 $1$，因此必然可以通过有限步操作到达 $|S||T|=0$ 的边界情况。至此我们得到了一种操作方案。

接下来我们考虑如何计算最小值。用 bitset 维护当前所有值域中的值是否可以作为一种方案的答案，即 $dp_{i,j}=[\exist S\subset \{a_1,a_2,\cdots,a_i\}(F(S)=j)]$，边界条件为 $dp_{0,i}=[i=0]$。对每个物品考虑是否放入 $S$ 中，则有 $dp_{i,j}=dp_{i-1,j+a_i} \operatorname{or}dp_{i-1,|j-a_i|}$。一部分可以 bitset 直接位移，另一部分不超过 $\max a_i$ 次更新，可以每次暴力维护。

但是值域达到了 $5\times 10^7$，只需要构造 $x-1$ 个 $x$ 和 $x$ 个 $x-1$ 就可以使得中途达到的最大值域卡到上界，可以打乱优化。这里不对打乱优化进行证明，相关证明参考[[THUPC2021] 混乱邪恶 题解区](https://www.luogu.com.cn/problem/solution/P7606)。

记得加滚动数组。

原题解供喷：
```
容易发现每次就是对 bitset 左移右移或一下然后暴力做不超过 $5000$ 的部分，再加上打乱优化+开小 bitset 即可通过。

具体地，每次 $dp_{i,j+a_i} = dp_{i,j+a_i} \operatorname{or} dp_{i-1,j}$ 直接维护，$dp_{i,|j-a_i|} = dp_{i,|j-a_i|} \operatorname{or} dp_{i-1,j}$ 拆成 $j\ge a_i$（直接 bitset 移位维护）和 $j<a_i$（不超过 $5000$，直接暴力）。
```
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int maxn=1e4+9;
int a[maxn],n;
bitset<(1<<20)> x[2]; 
int main()
{
    srand(time(0));
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",a+i);
	random_shuffle(a+1,a+n+1);
	x[0].set(0);
	for(int i=1;i<=n;++i)
	{
		x[i&1]=(x[~i&1]<<a[i])|(x[~i&1]>>a[i]);
		for(int j=a[i];j;--j)
			x[i&1][a[i]-j]=x[i&1][a[i]-j]|x[~i&1][j];
	}
	for(int i=0;i<(1<<20);++i)
		if(x[n&1][i]) printf("%d\n",i),exit(0);
	return 0;
}
```

---

## 作者：b6e0_ (赞：2)

本文主要对于关键性质给出一个更为严谨的证明。

对每个 $a_i$ 自由选择一个正负号，$\ge0$ 的最小的和就是答案。

我们尝试证明和最小的方案一定能被构造出来。

一个和为 $s$ 的方案是最小的当且仅当，在当前的正负号下，不存在一个 $a_i$ 的子集的和在 $(0,s)$ 中。理由的话，考虑当前方案与最小方案的差，即反转一些 $a_i$ 的正负号，可以使 $s$ 变化两倍当前子集的和，若子集和在 $(0,s)$ 中则变化后 $s$ 绝对值变小。

对 $n$ 运用归纳法，假设 $<n$ 时命题都成立。在和大于 $0$ 的真子集中取一个和最小的设为 $S$，设和为 $x$，有 $x\ge s$。设 $S$ 的补集为 $T$，和为 $s-x$。下面我们证明 $x$ 和 $x-s$ 都能被构造出来，最后将它们进行粉碎就能构造出 $s$。

根据 $x$ 的最小性，不存在 $S$ 的子集 $S'$ 满足和在 $(0,x)$ 中，即 $x$ 就是自由选择 $S$ 中 $a_i$ 的正负号得到的最小和。根据归纳假设，$x$ 可以被构造出来。

**假如**将 $T$ 中正负号取反（**实际上不取反**），和即变为 $x-s$，我们尝试证明这就是 $T$ 中和最小的方案，即不存在**当前** $T$ 的子集和在 $(s-x,0)$ 中。反证法，若存在子集 $T'\subseteq T$ 和为 $y$ 满足 $y\in(s-x,0)$，则 $S\cup T'$ 的和为 $x+y\in(s,x)$，与 $x$ 的最小性矛盾。

于是原命题得证。最后算法部分，本人的做法和 AFewSuns 的做法基本相同，参考他的题解即可，不再赘述。

---

## 作者：oyoham (赞：1)

### Problem
每次选择两个数并删去，然后插入两数之差，直至最后一个数，最小化这个数。  
### Solution
考虑分成两组，每次从两组中选择并将结果插入大的那一边，这样最后的答案即为两组之和的差值。

考虑设 $f_{i,j}$ 为分前 $i$ 个数，能否使差为 $j$，有 $f_{i,j}=f_{i-1,|j-a_i|}\vee f_{i-1,j+a_i}$，答案即为 $\min\limits_{f_{n_i}=1}^{}i$。

考虑第二维的长度为 $L$，时间复杂度为 $O(nL)$。

上述做法发现转移可以用 bitset 优化，时间复杂度可为 $O(\frac{nL}{w})$，但要注意细节！原本 $f_{i-1,|j-a_i|}$ 部分要分开来做，$j\le a_i$ 要另外转移。

但是这样是过不了的，因为可能出题人构造的数据中有一连串分到一组，导致正常做时 $L$ 要开的很大，我们可以考虑随机化原数组，这样两组元素分布较平均，让 $L$ 在一定范围内可过。

分析复杂度可知 $L$ 可以取 $3\times 10^6$ 左右，代码中取 $3.5\times10^6$ 并用滚动数组优化。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define aF(begin,end,step,name) for(int name=begin;name<=end;name+=step)
#define oF(B,E,N) aF(B,E,1,N)
#define af(B,E,S) aF(B,E,S,i)
#define of(B,E) af(B,E,1)
#define tF(E,N) oF(1,E,N)
#define tf(E) of(1,E)
#define nF(N) tf(n,N)
#define nf() tf(n)
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x<0ll) putchar(45),x=~x+1;
	if(x>9ll) write(x/10);
	putchar(x%10|48);
}
bitset<3500000>situ[2];
int n=read();
int a[114514];
signed main(){
	situ[0][0]=1;
	nf() a[i]=read();
	random_shuffle(a+1,a+n+1);//WA on #4 的注意了!!! 
	nf(){
		int v=a[i];
		situ[i&1]=(situ[i&1^1]<<v)|(situ[i&1^1]>>v);
		oF(0,v,j) situ[i&1][j]=situ[i&1][j]|situ[i&1^1][v-j];//另外转移
	}
	of(0,114514) if(situ[n&1][i]) return write(i),0;
}
```

---


# [XJTUPC 2024] 圣诞树

## 题目描述

有一棵 $n$ 个点的树，点的编号为 $1\sim n$，每个树的结点都有一个颜色，用 $col_i$ 表示。不同的 $col_i$ 代表不同的颜色。

小 L 要用这棵树制作很多棵圣诞树。一棵树能够被制作成圣诞树，当且仅当它有至少 $k$ ​种不同的颜色。小 L 要把树分成若干互不相交的联通块，并且取出满足条件的联通块制作圣诞树。

在给出这棵树的形态后，问最多能制作出多少棵圣诞树？

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
1 3
1 4
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 2
1 2 3 4
1 2
2 3
3 4
```

### 输出

```
2
```

# 题解

## 作者：喵仔牛奶 (赞：4)

# Solution

模仿 CF1946C 的做法，向下递归贪心，若当前连通块内颜色数 $\geq k$ 就切断与父亲的边，否则与父亲的连通块合并。由于连通块没有权值，所以这样做是对的。

至于维护连通块颜色数，使用 set 启发式合并即可。复杂度 $\mathcal{O}(n\log^2n)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5;
	int n, k, rs, u, v, c[N];
	vector<int> G[N]; set<int> s[N];
	void dfs(int u, int fa) {
		s[u].insert(c[u]);
		for (int v : G[u]) {
			if (v == fa) continue;
			dfs(v, u);
			if (s[u].size() < s[v].size()) s[u].swap(s[v]);
			for (int x : s[v]) s[u].insert(x);
		}
		if (s[u].size() >= k) s[u].clear(), rs ++;
	}
	int main() {
		cin >> n >> k;
		REP(i, 1, n) cin >> c[i];
		REP(i, 2, n) cin >> u >> v, G[u].pb(v), G[v].pb(u);
		dfs(1, 0);
		cout << rs << '\n';
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：Lyco_Reco (赞：1)

不难想到一个贪心：从叶子节点向上回溯，回溯过程中统计子树中不同颜色的结点个数，一旦发现总数大于 $k$ 就将子树砍掉。

具体地，对每一个节点开一个 set，维护以当前结点为根的子树中不同颜色的结点个数，在回溯的过程中将子节点信息合并到父节点，一旦发现总数大于 $k$ 就清空当前结点的 set，将答案加一。

使用启发式合并，时间复杂度 $O(n\log^{2}{n})$。
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
#include <iomanip>
#include <map>
#include <unordered_map>
#include <set>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 200010
int n,k,col[maxn],head[maxn],nxt[maxn<<1],to[maxn<<1],tot,ans;
set<int> s[maxn];
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void add(int u,int v){
		to[++tot]=v;
		nxt[tot]=head[u];
		head[u]=tot;
	}
	void dfs(int u,int fa){
		s[u].insert(col[u]);
		for(int i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(fa==v){
				continue;
			}
			dfs(v,u);
			if(s[u].size()<s[v].size()){
				s[u].swap(s[v]);
			}
		}
		for(int i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(fa==v){
				continue;
			}
			for(auto j:s[v]){
				s[u].insert(j);
			}
		}
		if(s[u].size()>=k){
			ans++;
			s[u].clear();
		}
	}
	void MAIN(){
		n=rd();
		k=rd();
		for(int i=1;i<=n;i++){
			col[i]=rd();
		}
		for(int i=1;i<n;i++){
			int u=rd(),v=rd();
			add(u,v);
			add(v,u);
		}
		dfs(1,0);
		wrt(ans);
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}
```

---

## 作者：Ripuka (赞：1)

# Solution

比较基础的树上启发式。

很容易想到贪心的思路：对于一颗自底向上构造的子树，只要满足构成“圣诞树”的条件，我们就可以立刻将它裁剪下来，形成一颗圣诞树。

可以发现，越早构成圣诞树，就可以剩余出更多的节点。这对于我们后续构造新的圣诞树是有利的。

我们只需要用一个 u_set 维护一下当前节点下剩余子树的 color 信息，接着模拟刚才说的过程即可。不要忘记，构造圣诞树的时候要把它的子树节点都去掉，防止对后续过程产生影响。

# Code
```cpp
#include<bits/stdc++.h>
#include<unordered_set>
using namespace std;
const int N = 2e5 + 10;
int n, k, ans;
int c[N];
vector<int>e[N];
int hs[N], l[N], r[N], tot;
int sz[N], id[N];
unordered_set<int>mp;
void dfs(int u, int fa)
{
    l[u] = ++tot;
    id[tot] = u;
    sz[u] = 1;
    hs[u] = -1;
    for (auto v : e[u])
    {
        if (v == fa)continue;
        dfs(v, u);
        if (hs[u] == -1 || sz[v] > sz[hs[u]])hs[u] = v;
    }
    r[u] = tot;
    sz[u] = r[u] - l[u] + 1;
}
void dfs(int u, int fa, bool kp)
{
    for (auto v : e[u])
    {
        if (v != fa && v != hs[u])dfs(v, u, 0);
    }
    if (hs[u] != -1)dfs(hs[u], u, 1);
    for (auto v : e[u])
    {
        if (v != fa && v != hs[u])
        {
            for (int i = l[v]; i <= r[v]; ++i)
            {
                if (c[id[i]] != -1)
                    mp.insert(c[id[i]]);
            }
        }
    }
    mp.insert(c[u]);
    if (mp.size() >= k)
    {
        ans++;
        for (int i = l[u]; i <= r[u]; ++i)
        {
            c[id[i]] = -1;
        }
        kp = 0;
    }
    if (!kp)
    {
        mp.clear();
    }
}
void solve()
{
    cin >> n >> k;
    for (int i = 1; i <= n; ++i)
    {
        cin >> c[i];
    }
    for (int i = 1; i < n; ++i)
    {
        int x, y;
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    ans = 0;
    dfs(1, 0);
    dfs(1, 0, 0);
    cout << ans << endl;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

---

## 作者：minstdfx (赞：1)

中档题，考虑贪心。  
自底而上每次把找到的满足至少有 $k$ 种颜色的子树拉出来形成一个连通块然后噶了，最后判断根所在连通块是否符合要求。

考虑证明这个贪心。
假设我们现在有了一个方案，这个方案里面含有一系列的点，表示 dfs 回溯的时候这些点去掉已经选出的子树之后颜色不少于 $k$ 种，并且其所有的子树均不满足条件。  
那么考虑如何调整，向上调整则会影响到它上面一个连通块，导致答案不会更优；向下调整则由于其所有的子树均不满足条件，答案不增。

至于怎么维护，随便线段树合并一下就可以过。
```cpp
#include <bits/stdc++.h>
struct st{
	int cnt;
	st* c[2];
	void MT(){
		cnt=c[0]->cnt+c[1]->cnt;
	}
}t[4444444],*nul=t+4444400,*root[222222],*pt=t+1;
st* insert(st* o,int v,int l,int r){
	++o->cnt;
	if(l==r){
		return o;
	}
	int mid=l+r>>1;
	if(v<=mid){
		o->c[0]=pt++;
		o->c[0]->c[0]=o->c[0]->c[1]=nul;
		insert(o->c[0],v,l,mid);
	}
	else{
		o->c[1]=pt++;
		o->c[1]->c[0]=o->c[1]->c[1]=nul;
		insert(o->c[1],v,mid+1,r);
	}
	return o;
}
st* merge(st* x,st* y,int l,int r){
	if(x==nul)return y;
	if(y==nul)return x;
	if(l==r){
		x->cnt|=y->cnt;
		return x;
	}
	int mid=l+r>>1;
	x->c[0]=merge(x->c[0],y->c[0],l,mid);
	x->c[1]=merge(x->c[1],y->c[1],mid+1,r);
	x->MT();
	return x;
}
int col[222222];
struct edge{
	int to;
	int next;
}e[666666];
int pe=222222;
void insert(int a,int to){
	e[pe]=(edge){to,e[a].next};
	e[a].next=pe++;
}
int n,k;
int ans=0;
void dfs(int o,int fa){
	for(int p=e[o].next;p;p=e[p].next){
		if(e[p].to!=fa){
			dfs(e[p].to,o);
			root[o]=merge(root[o],root[e[p].to],1,n);
		}
	}
	if(root[o]->cnt>=k){
		++ans;
		root[o]=pt++;
		root[o]->c[0]=root[o]->c[1]=nul;
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i){
		scanf("%d",col+i);
	}
	for(int i=1;i<n;++i){
		int x,y;
		scanf("%d %d",&x,&y);
		insert(x,y);
		insert(y,x);
	}
	for(int i=1;i<=n;++i){
		root[i]=pt++;
		root[i]->c[0]=root[i]->c[1]=nul;
		root[i]=insert(root[i],col[i],1,n);
	}
	dfs(1,0);
	printf("%d\n",ans);
}
```

---

## 作者：jdfz2251533 (赞：0)

## 题解：P10531 \[XJTUPC 2024] 圣诞树

## 题意

有一颗树，节点有色，问最多能取出来多少个颜色 $\ge k$ 种的联通块，联通块不重合。

## 解法

贪心，我们肯定是想要某个块的颜色种数尽量少而且符合要求。

从上往下搜索，记录一下每个节点的子树有几种颜色，回溯的时候更新父亲的信息。那就要快速求出子树有几种颜色，用 ``` set ``` 维护一下就好。

搜完 $u$ 的所有子树后，如果 $st_{u}.size() \ge k$，就应该切掉以 $u$ 为根的子树，答案加一。

## 细节

因为不知道输入的父子关系，所以连双向边。

因为根不一定是 $1$（题目没说），所以如果都从 $1$ 开始搜，需要注意：如果当前在 $u$，搜完它的儿子 $v$ 后发现 $v$ 的子树颜色种数反而多于 $u$，那就得交换一下 $st_{u}$ 和 $st_{v}$ 再合并，其实就是树上启发式合并。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;

struct node {
	int to, nxt;
} e[N << 1];
set<int> st[N];
int n, k, ans, c[N], h[N], tot, u, v;

void add(int u, int v) {
	e[++tot].nxt = h[u];
	e[tot].to = v;
	h[u] = tot;
}

void dfs(int u, int fa) {
	st[u].insert(c[u]);
	for (int i = h[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (v == fa) {
			continue;
		}
		dfs(v, u);
		if (st[u].size() < st[v].size()) {
			st[u].swap(st[v]);
		}
		for (int j : st[v]) {
			st[u].insert(j);
		}
	}
	if (st[u].size() >= k) {
		st[u].clear();
		ans++;
	}
}

int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
	}
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	dfs(1, -1);
	cout << ans;
	return 0;
}
```

---

## 作者：__builtin_orz (赞：0)

显然地，可以贪心地先切靠下的子树（如果下面的子树已经满足条件，则将其切为圣诞树可能可以使靠上的子树造成更多贡献）。

关于颜色的传递，可以使用标准库集合大力合并（记得按秩合并）。

```cpp
#include<algorithm>
#include<cstdio>
#include<set>
#include<vector>
#define _N_ 200005
int n,k,ans;
std::vector<int>to[_N_];
std::set<int>sub_col[_N_];
void dfs(int now,int last){
	for(int to:now[::to])if(to!=last){
		dfs(to,now);
		if(now[sub_col].size()<to[sub_col].size())std::swap(now[sub_col],to[sub_col]);
		for(int elem:to[sub_col])now[sub_col].insert(elem);
		to[sub_col].clear();
	}
	if(now[sub_col].size()>=k){
		now[sub_col].clear();
		ans++;
		return;
	}
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		sub_col[i].insert(x);
	}
	for(int i=2;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		x[to].push_back(y);
		y[to].push_back(x);
	}
	dfs(1,1);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10531)

**题目大意**

> $n$ 个点的树选出最多的个不相交连通块，使得每个连通块内颜色数 $\ge k$。
>
> 数据范围：$n\le 2\times 10^5$。

**思路分析**

考虑自底向上贪心，如果一个子树颜色数 $\ge k$，那么肯定把这个子树到父亲的边断掉最优。

维护每个子树剩余的颜色数直接用 `std::unordered_set` 启发式合并即可。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int n,k,c[MAXN],ans=0;
vector <int> G[MAXN];
unordered_set <int> f[MAXN];
void dfs(int u,int fz) {
	f[u].insert(c[u]);
	for(int v:G[u]) if(v^fz) {
		dfs(v,u);
		if(f[u].size()<f[v].size()) swap(f[u],f[v]);
		for(int x:f[v]) f[u].insert(x);
	}
	if((int)f[u].size()>=k) ++ans,f[u].clear();
}
signed main() {
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i) scanf("%d",&c[i]);
	for(int i=1,u,v;i<n;++i) scanf("%d%d",&u,&v),G[u].push_back(v),G[v].push_back(u);
	dfs(1,0),printf("%d\n",ans);
	return 0;
}
```

---

## 作者：CaoSheng_zzz (赞：0)

### 题目大意

一个有 $ n $ 个节点的树，对于任意一个点 $ v $ 为根的子树如果树上的颜色 $ \ge k $ 那么就把 $ v $ 为根的子树删去答案就加一。

### 思路

这个地方我们第一个就会想到贪心当一颗子树颜色 $ \ge k $ 时就立马删掉这一颗树答案加一，在操作时用 set 来维护就行了。

在这我介绍一下 set：

set 是 C++ 标准库中的一个容器，属于关联容器的一种。

它是一个有序集合，其中的元素是唯一的，即每个元素只能在集合中出现一次。

set 是基于红黑树实现的合并一次的时间复杂度为 $ \Omicron(n\log n) $ 所以这道题的总时间复杂度为 $ \Omicron(n\log^2 n) $。

当你了解 set 后就可以去写代码了。代码量极少~~这题代码量和思路与 CF 的一道题好像啊~~。

#### 注意！
1. 如果你直接去写代码会发现 MLE 所以我们需要加一个判断当 $ u $ 的儿子 $ v $ 的颜色大于 $ u $ 那么交换一下他两的颜色统计数组，但是也不能在 $ u $ 添加完 $ v $ 子树的颜色后将 $ v $ 清空因为这样会超时。

2. 记得开 `long long`。

3. 记得存双边因为是树。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#include <map>
#include <set>
#define sc(ppt) scanf("%lld" , &ppt)
#define ll long long
#define prt printf
using namespace std;

const ll maxn = 2e5 + 1;
struct edge{
	ll next , to;
}e[maxn << 1]; 
ll n , k , ans = 0 , col[maxn] , h[maxn] , cnt = 0;
set<ll> Size[maxn];

inline void add_edge(ll u , ll v){
	++ cnt;
	e[cnt].next = h[u] ;
	e[cnt].to = v;
	h[u] = cnt;
} //链式前向心 

void dfs(ll u , ll fa){ // 爬树板子 
	Size[u].insert(col[u]); 
	for(ll i=h[u] ; i ; i=e[i].next){
		ll v = e[i].to;
		if(v == fa) continue;
		dfs(v , u);
		if(Size[u].size() < Size[v].size()) Size[u].swap(Size[v]); //如果v的颜色大与u颜色的数量那么就swap不然内存会超出限制而且v为子树的颜色数量也没有达到k的要求所以可以换 
		for(auto j : Size[v]){
			Size[u].insert(j);
		}
	}
	ll Sz = Size[u].size();
	if(Sz >= k){
		Size[u].clear();
		++ ans;
	}
}

signed main(){
	sc(n) ; sc(k) ;
	for(ll i=1 ; i<=n ; i++) sc(col[i]);
	for(ll i=1 ; i<n ; i++){
		ll u , v ; sc(u) ; sc(v) ;
		add_edge(u , v);
		add_edge(v , u);
	}
	dfs(1 , -1);
	prt("%lld" , ans);
	return 0;
}
```

---


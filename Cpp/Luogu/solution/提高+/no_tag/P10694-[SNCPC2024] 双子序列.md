# [SNCPC2024] 双子序列

## 题目描述

小 L 看到不喜欢的字符串就很难受！看到它作为子序列出现也是！

给定一个长字符串 $S$ 表示小 L 要阅读的文本，以及恰好两个短字符串 $s_1$，$s_2$ 表示小 L 不想看到的字符串，三个字符串均由小写字母组成。 

小 L 很反感这两个字符串作为子序列在文本内同时出现，他认为，一个字符串 $T$ 的反感度为：$s_1$ 作为 $T$ 的子序列的出现次数，和 $s_2$ 作为 $T$ 的子序列的出现次数之积。

由于他要读 $S$ 的每个子串，所以现在需要你求出 $S$ 的所有子串的反感度值之和。由于答案可能过大，你只需要输出对 $998244353$ 取模的结果。

定义一个字符串 $H$ 是 $T$ 的子串，当且仅当 $H$ 由 $T$ 删除最前面的若干字符和最后面的若干字符获得（前缀后缀可以一个字符都不删除，也可以把整个串全删除得到空串）。

定义一个字符串 $H$ 是 $T$ 的子序列，当且仅当 $H$ 由 $T$ 删除若干字符后获得（可以一个字符都不删除，也可以全删除后得到空子序列）。

## 说明/提示

| 子串起始位置 | 子串终止位置 |  icpc 次数  | ccpc 次数 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | 5 | 2 | 1 |
| 1 | 6 | 2 | 1 |
| 1 | 7 | 4 | 2 |
| 1 | 8 | 4 | 2 |
| 1 | 9 | 11 | 9 |
| 2 | 5 | 0 | 1 |
| 2 | 6 | 0 | 1 |
| 2 | 7 | 0 | 2 |
| 2 | 8 | 0 | 2 |
| 2 | 9 | 1 | 9 |
| 3 | 9 | 1 | 3 |
| 4 | 9 | 1 | 1 |
| 5 | 9 | 1 | 1 |
| 6 | 9 | 1 | 0 |


在其余的子串内，两个字符串作为子序列的出现次数均为 $0$。

答案为 $(2\times 1) \times 2 + (4\times 2) \times 2 + 11\times 9 + (0\times 1)\times 2 + (0\times 2)\times 2 + 1\times 9 + 1\times 3+ (1\times 1)\times 2 + 1\times 0=133$。

## 样例 #1

### 输入

```
iccpcicpc
icpc
ccpc
```

### 输出

```
133
```

# 题解

## 作者：_LiWenX_ (赞：11)

看完题，感觉这个子序列有点难直接做的，至少直接算出每一个区间的贡献估计是没有前途，所以我们考虑拆贡献。

乘法形式拆贡献有经典 trick，使用乘法分配律，发现对于一对子序列 $l_1,l_2$，设他们第一个出现位置最小值是 $L$，最后一个出现位置最大值为 $R$，这对子序列贡献为 $L(n-R+1)$。那么答案改写为 $\sum\limits_{l_1,l_2}L(n-R+1)$。

这个形式已经足够 dp 了，具体来说，我们考虑枚举 $R$，dp 计算 $\sum L$ 的值，然后可以设出状态 $f_{i,j,k}$ 表示考虑到了 $s$ 的第 $i$ 位，匹配到了 $s1$ 的第 $j$ 位，$s2$ 的第 $k$ 位，左端点的和。那么答案就是 $\sum\limits_{i=1}^nf_{i,|s1|,|s2|}(n-i+1)$。

考虑转移，这是相当简单的，$f_{i,j,k}=\sum\limits_{p=1}^{i-1}([s1_j=s_i]f_{p,j-1,k})+([s2_k=s_if_{p,j,k-1}])+([s1_j=s_i \land s2_k=s_i]f_{p,j-1,k-1})$ 特判这是左端点再加上 $i$ 即可。

使用前缀和优化可以做到 $O(|s||s1||s2|)$。

最开始答案没取模罚了一发/fn。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
string s,s1,s2;
int f[100005][21][21];
int sum[21][21];
int n,l1,l2;
void rtt(int x){
	for(int i=0;i<=l1;i++){
		for(int j=0;j<=l2;j++){
			sum[i][j]+=f[x][i][j];
			if(sum[i][j]>=mod) sum[i][j]-=mod; 
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>s>>s1>>s2;
	n=s.size(),l1=s1.size(),l2=s2.size();
	s='#'+s;
	s1='#'+s1;
	s2='#'+s2;
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=l1;j++){
			for(int k=0;k<=l2;k++){
				if(s1[j]!=s[i]&&s2[k]!=s[i]) continue;
				if(s1[j]==s[i]){
					f[i][j][k]+=sum[j-1][k]+(j==1&&k==0)*i;
					if(f[i][j][k]>=mod) f[i][j][k]-=mod;
				}
				if(s2[k]==s[i]){
					f[i][j][k]+=sum[j][k-1]+(j==0&&k==1)*i;
					if(f[i][j][k]>=mod) f[i][j][k]-=mod;
				}
				if(s1[j]==s[i]&&s2[k]==s[i]){
					f[i][j][k]+=sum[j-1][k-1]+(j==1&&k==1)*i;
					if(f[i][j][k]>=mod) f[i][j][k]-=mod;
				}
			}
		}
		ans+=f[i][l1][l2]*(n-i+1)%mod;
		rtt(i);
	}
	cout<<ans%mod;
}
```

---

## 作者：newwzl (赞：1)

# 思路
事先说明：$n$ 表示 $S$ 长度，$n_1$ 和 $n_2$ 分别是 $s_1$ 和 $s_2$ 的长度。

对于每个区间，定义 $a_i$ 表示该区间有多少个子序列是 $s_1[1\dots i]$，$b_i$ 是 $s_2[1\dots i]$。这个区间的贡献就是 $a_{n_1}\times b_{n_2}$。

假定一个区间的右端点右移了一位，如果新加入的字符在 $s_1$ 中的 $x$ 处出现了，相当于让 $a_x$ 加上了 $a_{x-1}$。如果在 $s_2$（此处同上，略）。所以我们可以定义一个 $f_{i,j,k}$ 表示所有右端点在 $i$ 的区间的 $\sum{a_j\times b_k}$ 的值，转移因为过于简单，放到代码里。发现这个 DP 式子存储的时候可以把 $i$ 给消掉看着更简洁，所以最终时间复杂度 $O(n\times n_1\times n_2)$，空间复杂度 $O(n)$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10,M=22,mod=998244353;
int n,n1,n2;
char a[N],s1[M],s2[M];
string s;
int f[M][M],ans;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);
	//没用的输入部分
	cin>>s;n=s.size();for(int i=1;i<=n;i++)a[i]=s[i-1];
	cin>>s;n1=s.size();for(int i=1;i<=n1;i++)s1[i]=s[i-1];
	cin>>s;n2=s.size();for(int i=1;i<=n2;i++)s2[i]=s[i-1];
	//有用的转移部分
	for(int i=1;i<=n;i++){
		f[0][0]++;//我们认为一个区间只有一个子序列是空串
		for(int j=n1;j>=1;j--){//从大到枚举的原因 同01背包
			if(s1[j]==a[i]){
				for(int k=0;k<=n2;k++)f[j][k]=(f[j][k]+f[j-1][k])%mod;
			}
		}
		for(int k=n2;k>=1;k--){
			if(s2[k]==a[i]){
				for(int j=0;j<=n1;j++)f[j][k]=(f[j][k]+f[j][k-1])%mod;
			}
		}
		ans=(ans+f[n1][n2])%mod;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：迟暮天复明 (赞：0)

这题怎么没有题解 /yiw

去年七月，我打洛谷上的重现赛的时候对这题一筹莫展。而且线下赛这个题也没有人做。洛谷上做出这道题的中学生们，都认为这题的 trick 非常简单，暴论此题是签到题。我当时对于他们进行了严重的攻击，认为他们太厉害了，目中无人，根本不关心一般选手的感受。

不过，我现在郑重的宣布，这题就是一道签到题。@minstdfx 你赛时怎么这都不会做你是不是菜。

考虑答案的组合意义。考虑一对子序列，起止位置分别是 $(l_1,r_1)$ 与 $(l_2,r_2)$，那么对答案的贡献就是 $\max\{l_1,l_2\}\times\max\{n-r_1+1,n-r_2+1\}$，所以只和两个子序列的最初位置的和最末位置有关。

然后注意到一个显然的 dp，设 $f_{i,j,k}$ 表示原串做到第 $i$ 位，两个子序列分别匹配到 $j,k$ 位时对答案产生的贡献。这个转移很简单吧！就直接匹配上某一位就转移即可，写成式子就是 
$$f_{i,j,k
}= f_{i-1,j-1,k}[txt_i=s1_j]+f_{i-1,j,k-1}[txt_i=s2_k]+f_{i-1,j-1,k-1}[\dots]$$

省略号里不想写了。

唯一的转移特例就是 $f_{i,0,0}$ 转移出去的时候要乘 $i$，转移进入 $f_{i,sx,sy}$ 要乘 $n-i+1$。这个前面已经说明了。

使用滚动数组即可做到时间复杂度 $O(|S||S_1||S_2|)$，空间复杂度 $O(|S_1||S_2|)$。

代码：

```cpp
rep(i,0,ls-1){
  rep(j,0,lx)rep(k,0,ly){
    if(j!=lx&&s[i]==x[j]){
      if(j==0&&k==0)g[j+1][k]+=f[j][k]*(i+1);
      else if(j==lx-1&&k==ly)g[j+1][k]+=f[j][k]*(ls-i);
      else g[j+1][k]+=f[j][k];
    }
    if(k!=ly&&s[i]==y[k]){
      if(j==0&&k==0)g[j][k+1]+=f[j][k]*(i+1);
      else if(j==lx&&k==ly-1)g[j][k+1]+=f[j][k]*(ls-i);
      else g[j][k+1]+=f[j][k];
    }
    if(j!=lx&&s[i]==x[j]&&k!=ly&&s[i]==y[k]){
      if(j==0&&k==0)g[j+1][k+1]+=f[j][k]*(i+1);
      else if(j==lx-1&&k==ly-1)g[j+1][k+1]+=f[j][k]*(ls-i);
      else g[j+1][k+1]+=f[j][k];
    }
  }
  rep(j,0,lx)rep(k,0,ly)f[j][k]=g[j][k]%mod,g[j][k]=f[j][k];
}
print(f[lx][ly],'\n');
```

这题很简单吧！

---


# [CEOI 2024] 洒水器

## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T3「[Sprinklers](https://ceoi2024.fi.muni.cz/page/tasks/statements/sprinklers.pdf)」**

瓦茨拉夫有一个美丽的花园，花园里种了一排 $M$ 朵花。在这一排上，瓦茨拉夫还放置了 $N$ 个洒水器来浇花。

洒水器的位置由数字 $s_1, s_2, \ldots , s_N$ 给出。花的位置由数字 $f_1, f_2, \ldots , f_M$ 给出。两者都是非递减顺序，即：
- $s_1 \leq s_2 \leq \ldots \leq s_N$
- $f_1 \leq f_2 \leq \ldots \leq f_M$

瓦茨拉夫很快就要去参加 CEOI 了。他想确保在他离开期间所有的花都能得到适当的浇水。为此，他可以单独将每个洒水器向左或向右旋转，并设置它们的喷水强度——所有洒水器共享同一个水管，因此喷射距离相同。

如果喷水强度为 $K$，并且第 $i$ 个洒水器向左旋转，它将浇灌位置在 $s_i - K$ 到 $s_i$ 之间的所有花。类似地，如果第 $j$ 个洒水器向右旋转，它将浇灌位置在 $s_j$ 到 $s_j+K$ 之间的所有花。单个洒水器可以浇灌多朵花，一朵花也可以被多个洒水器浇灌。

你的任务是决定是否可以浇灌所有的花。如果是，你应该找到最小的足够喷水强度，以及相应的洒水器配置。如果存在多个具有最小喷水强度的有效配置，输出其中任何一个。

## 说明/提示

**样例解释 1**

每朵花至少被一个洒水器浇水。喷水强度低于 $6$ 是不可能的，因为位置 $16$ 的花离最近的洒水器有 $6$ 个单位距离。

**样例解释 2**

无论洒水器的方向如何，一次最多只能浇灌一朵花。

对于所有输入数据，满足：
- $1 \leq N,M \leq 10^5$
- $0 \leq s_{i} \leq 10^9\ (1 \leq i \leq N)$
- $0 \leq f_{i} \leq 10^9\ (1 \leq i \leq M)$
- $s_{i} \leq s_{j}\ (i \leq j)$
- $f_{i} \leq f_{j}\ (i \leq j)$

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N = 1$ | $3$  |
|  $2$  | $N = 3x$，$x$ 是一个整数，$s_{3i+1}=s_{3i+2}=s_{3i+3}\ (0 \leq i \leq x-1)$（即洒水器总是成组放置三个）| $6$ |
|  $3$  | $N \leq 10, M \leq 1\,000$| $17$ |
|  $4$  | $K\leq 8$（即在所有测试数据中，存在一种洒水器配置，使得喷水强度最多为 $8$ 就足以浇灌所有的花） | $27$ |
|  $5$  | 无附加限制| $47$ |

## 样例 #1

### 输入

```
3 3
10 10 10
5 11 16```

### 输出

```
6
LLR```

## 样例 #2

### 输入

```
1 2
1000
1 2000```

### 输出

```
-1```

# 题解

## 作者：佬头 (赞：8)

## Description
现有 $N$ 个洒水器和 $M$ 朵花排成一排，洒水器位于 $s_1,s_2,\ldots,s_N~(s_1\le s_2\le\ldots\le s_N)$，花位于 $f_1,f_2,\ldots,f_M~(f_1\le f_2\le\ldots\le f_M)$。洒水器的喷水强度均为 $K$：
- 若第 $i$ 个洒水器向左旋转，它可以浇灌位于 $s_i-K$ 到 $s_i$ 之间的所有花；
- 若第 $i$ 个洒水器向右旋转，它可以浇灌位于 $s_i$ 到 $s_i+K$ 之间的所有花。

问这些洒水器能否浇灌到所有的花。若能，求此时 $K$ 的最小值及其对应的任意一种洒水器配置。

## Solution
既然题目已经给我们排序好了，那我们第一眼看到的就是“**最小值**”，想到**二分**出最小 $K$，那么问题就在于 `check()` 部分如何写了。

- 先进行**初步分类讨论**（默认**从左往右**遍历洒水器），若某洒水器左侧的花已全部灌溉，则将其向右旋转；否则向左旋转。代码如下（删去了有关洒水器配置的部分）：
```cpp
bool check(int &k){ //二分出的k
	int j = 1;
	for(int i = 1; i <= n; ++ i)
		if(j <= m && f[j] < s[i])
			if(f[j] < s[i] - k) return 0;
			else while(j <= m && f[j] <= s[i]) ++ j;
		else while(j <= m && f[j] <= s[i] + k) ++ j;
	return j > m;
}
```
结果只有 $9$ 分，需要进一步讨论，向右旋转在上述条件下已是最优选择，问题就出在向左旋转，给朕上图！
![](https://cdn.luogu.com.cn/upload/image_hosting/q2n6mt8i.png)
图中，由于洒水器 $2$ 必然向左旋转，从而灌溉了花 $1,2$，导致洒水器 $1$ 未起到实际效益，而花 $3$ 又空着，因此需要洒水器 $1$ 向右旋转。

- 那么对于两个连续的向左旋转的洒水器 $i,i+1$，若洒水器 $i+1$ 导致洒水器 $i$ 未起到**实际效益**，就将 $i$ 向右旋转。于是就有了进阶版的 `check()`：
```cpp
bool check(int &k){
	int j = 1;
	for(int i = 1; i <= n; ++ i)
		if(j <= m && f[j] < s[i])
			if(f[j] < s[i] - k) return 0;
			else{
				int fp = f[j];
				while(j <= m && f[j] <= s[i]) ++ j;
				if(j <= m && i < n && f[j] < s[i + 1] && fp >= s[i + 1] - k){
					while(j <= m && f[j] <= s[i] + k) ++ j;
					++ i;
				}
			}
		else while(j <= m && f[j] <= s[i] + k) ++ j;
	return j > m;
}
```
获得了 $73$ 分（仅 _**UKE**_ 了一个点），接着上图！
![](https://cdn.luogu.com.cn/upload/image_hosting/1btieytu.png)
这张图是前一张图的衍生版。有了前车之鉴，我们不难想到洒水器 $2$ 需要向右旋转，并且前一张图的配置方式不能延用。

那么问题来了——这显然与代码的逻辑相悖。再尝试几次之后可以发现，每次某一个洒水器的向左旋转都有可能导致前面**所有的**洒水器的朝向**反转**。

- 因而对于 $A$ 个连续的向左旋转的洒水器，这种反转可能会出现 $\left(A-1\right)$ 次，且最终结果取决于最后一次，那么我们只要将每次会反转的洒水器打好**标记**，再**从右到左**反转一遍即可，具体看下方代码。

- 注意这题的 $K,s_i,f_i$ 都可以取到 $0$。

代码时间复杂度 $\mathcal O\left((N+M)\log T\right)$，其中 $T$ 为 $K$ 的值域。

## Code
```cpp
#include <iostream>
using namespace std;
const int N = 100005;
int n, m, s[N], sp[N], f[N], lft = 0, rt = 1e9, ans = -1;
bool c[N];
string out, plan;
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
bool check(int &k){
	plan = "";
	int j = 1;
	for(int i = 1; i <= n; ++ i)
		if(j <= m && f[j] < s[i])
			if(f[j] < s[i] - k) return 0;
			else{
				sp[i] = f[j];
				while(j <= m && f[j] <= s[i]) ++ j;
				if(plan.back() == 'L' && sp[i - 1] >= s[i] - k){
					c[i] = 1;
					while(j <= m && f[j] <= s[i - 1] + k) ++ j;
				}
				plan.push_back('L');
			}
		else{
			while(j <= m && f[j] <= s[i] + k) ++ j;
			plan.push_back('R');
		}
	if(j <= m) return 0;
	out = plan;
	for(int i = n; i >= 1; i --) if(c[i]) c[i] = c[i - 1] = 0, out[i - 2] = 'R';
	return 1;
}
int main(){
	n = read(), m = read();
	for(int i = 1; i <= n; ++ i) s[i] = read(); //洒水器
	for(int i = 1; i <= m; ++ i) f[i] = read(); //花
	while(lft <= rt){
		int mid = (lft + rt) >> 1;
		if(check(mid)) rt = mid - 1, ans = mid;
		else lft = mid + 1;
	}
	if(ans == -1) return fputs("-1", stdout), 0;
	write(ans), putchar('\n');
	fputs(out.c_str(), stdout);
	return 0;
}
```

---

## 作者：pldzy (赞：2)

题解区贪心题解看不明白啊。

## Solution

先二分，最优性转可行性。判定是否可行。经典问题模型，左摆或右摆判断能否覆盖完整个区间。在经典模型中，每个花洒（或灯）的覆盖的长度可能不同。

这个经典问题的 dp 思路是，顺序考虑每个花洒（或灯），它向左扫能覆盖 $[l,p_i]$，那么找到最小的 $j$，使得前 $j$ 个花洒能覆盖 $[1,l)$，然后贪心地让 $k\in (j,i)$ 的花洒 $k$ 全部向右摆。对于每个花洒我们都只考虑它向左扫的贡献，因为它向右扫的贡献一定会在后面某一次向左扫的时候统计到（末尾特判一下）。

但这道题简单之处在于，所有花洒的覆盖范围是相同的，也即二分的 $mid$。也就是说，上面的过程，$k\in (j,i)$ 的最优的 $k$ 一定是 $k=i-1$。

那么思路就很明了了。记 $g_i$ 表示用前 $i$ 个花洒最多能够覆盖编号 $[1,g_i]$ 的花。注意，是连续覆盖，即全部覆盖了，没有空缺。转移分为两种。一种是直接贪心向左/右摆，如果前面 $i-1$ 个花洒能够覆盖超过 $s_i$，那 $i$ 就可以贪心地向右摆，否则它必须向左摆，填满中间的空缺。这里填不满就报告不可行。另一种转移就是上面说的，让 $i$ 向左摆，然后让 $i-1$ 向右摆，此时调用 $g_{i-2}$ 辅助转移即可。

复杂度 $O(n\log^2n)$，但思路会比直接贪心来得更有道理一些？

## Code

````cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)

const int maxn = 1e5 + 5;

int n, m, s[maxn], f[maxn];
int g[maxn], pre[maxn], nw[maxn], suf[maxn];
char Plan[maxn];

inline bool chck(int k){
	rep(i, 1, n) 
		suf[i] = upper_bound(f + 1, f + m + 1, s[i] + k) - f - 1;
		
	g[0] = 0;
	rep(i, 1, n) g[i] = pre[i] = 0;
	rep(i, 1, n){
		if(g[i - 1] == m){ g[i] = g[i - 1], pre[i] = -2; continue;} 
		if(f[g[i - 1] + 1] < s[i] - k) return 0;
		
		if(f[g[i - 1] + 1] < s[i]) g[i] = nw[i], pre[i] = -1;
		else g[i] = suf[i], pre[i] = -2;
		
		if(i > 1 and f[g[i - 2] + 1] >= s[i] - k){
			if(suf[i - 1] > g[i])
				g[i] = suf[i - 1], pre[i] = 1;
		}
	}
	
	if(g[n] < m) return 0; 
	
	int x = n;
	while(x){
		if(pre[x] < 0){
			if(pre[x] == -1) Plan[x] = 'L';
			else Plan[x] = 'R';
			--x;
		} else{
			Plan[x] = 'L', Plan[x - 1] = 'R';
			--x; --x;
		}
	}
	return 1;
}

int main(){
//	freopen("P10806_24.in", "r", stdin);
	
	ios_base::sync_with_stdio(0);
	cin.tie(NULL), cout.tie(NULL);
	
	cin >> n >> m;
	rep(i, 1, n) cin >> s[i];
	rep(i, 1, m) cin >> f[i];
	
	if(n == 1){
		if(s[1] <= f[1]){
			cout << f[m] - s[1] << '\n';
			cout << "R" << '\n';
		} else if(s[1] >= f[m]){
			cout << s[1] - f[1] << '\n';
			cout << "L" << '\n';
		} else cout << -1 << '\n';
		return 0;
	}
	
	rep(i, 1, n)
		nw[i] = upper_bound(f + 1, f + m + 1, s[i]) - f - 1;

	int l = 0, r = 1e9, ans = -1;
	while(l <= r){
		int mid = l + r >> 1, tmp = chck(mid);
		if(tmp) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	
	cout << ans << '\n';
	rep(i, 1, n) cout << Plan[i]; cout << '\n';
	return 0;
}
````

---

## 作者：Fracture_Dream (赞：2)

## 前言
怎么题解区全是贪心的做法？来贡献一篇 $dp$ 做法的题解。

"膜拜"同机房巨佬 @TTpandas 试图通过复杂度和正确性都错误的奇技淫巧通过此题。
## 题目大意

一个数轴上有 $n$ 个洒水器和 $m$ 个花盆，洒水器的强度为 $k$。  

一个洒水器可以浇灌位于 $[s_i-k,s_i]$ 或者 $[s_i,s_i+k]$ 中的花朵，现在请你求出最小的 $k$，使得 $m$ 朵话都至少被一个洒水器浇灌到，要求**输出方案**。

## 思路
首先一眼二分答案，考虑如何 check。

如果你做过 [CF1476F](https://www.luogu.com.cn/problem/CF1476F)，那么这道题就很简单了，因为你会发现这就是个经典的前缀覆盖问题。

令 $dp_i$ 表示考虑完前 $i$ 个洒水器，能够覆盖的最长花盆前缀。  

令 $lasR_i$ 表示最大的 $j$ 满足 $f_j < s_i$，即洒水器往右旋转不能覆盖到的最靠左的花盆。  

令 $lasL_i$ 表示最大的 $j$ 满足 $f_j \le s_i \wedge f_j \ge s_i-k$，即洒水器向左旋转可覆盖到的最靠右的花盆。 

令 $L_i$ 表示最大的 $j$ 满足 $f_j < s_i - k$，即洒水器向左旋转仍无法覆盖到的最靠右的花盆。  

令 $R_i$ 表示最大的 $j$ 满足 $f_j \le s_i - k \wedge f_j \ge s_i$，即洒水器向右旋转可覆盖到的最靠右的花盆。

显然这些值是很好求的，重点在于 $dp$ 数组的转移。

有如下三种转移：

- $dp_i \leftarrow dp_{i-1}$，这是显然的。
- 若 $dp_{i-1} \ge lasR_i$，当前洒水器右旋，那么 $dp_i \leftarrow \max\{R_i,LasL_i\}$。
- 找到最小的 $l$ 满足 $dp_l \ge L_i$，当前洒水器左旋，显然将 $[l+1,i-1]$ 中的洒水器右旋。那么

$$dp_i \leftarrow \max\{\max_{l < j < i}\{R_j\} , LasL_i\}$$

最后判断一下 $dp_n \ge m$ 即可。

注意 $dp$ 的时候记录一下转移路径，输出方案是容易的。

# 代码
时间复杂度 $n\log^2n$，但其实精细实现可做到 $n\log n$，不过没有这个必要，因为不卡常。

这里只给出 check 的核心代码。


```cpp
bool check(int mid) {
	for (int i = 1 ; i <= n ; i ++) {
		int k = lower_bound(f + 1 , f + m + 1 , s[i] - mid) - f - 1;
		if (f[k] < s[i] - mid) L[i] = k;
		else L[i] = 0;
	}
	for (int i = 1 ; i <= n ; i ++) {
		int k = upper_bound(f + 1 , f + m + 1 , s[i] + mid) - f - 1;
		if (f[k] >= s[i] && f[k] <= s[i] + mid) R[i] = k;
		else R[i] = 0;
	}
	for (int i = 1 ; i <= n ; i ++) {
		int k = upper_bound(f + 1 , f + m + 1 , s[i]) - f - 1;
		if (f[k] >= s[i] - mid && f[k] <= s[i]) lasL[i] = k;
		else lasL[i] = 0;
		lasR[i] = lower_bound(f + 1 , f + m + 1 , s[i]) - f - 1;
	}
	for (int i = 1 ; i <= n ; i ++) Max[i][0] = R[i];
	for (int j = 1 ; j <= 17 ; j ++) {
		for (int i = 1 ; i + (1 << j) - 1 <= n ; i ++) {
			Max[i][j] = max(Max[i][j - 1] , Max[i + (1 << j - 1)][j - 1]);
		}
	}
	for (int i = 1 ; i <= n ; i ++) {
		dp[i] = dp[i - 1] , pre[i] = i - 1 , dir[i] = -1;
		if (dp[i - 1] >= lasR[i]) {
			if  (max(R[i] , lasL[i]) > dp[i]) {
				dp[i] = max(R[i] , lasL[i]) , dir[i] = 1 , pre[i] = i - 1;
			}
		}
		int l = 0 , r = i - 1;
		while(l < r) {
			int mid = l + r >> 1;
			if (dp[mid] >= L[i]) r = mid;
			else l = mid + 1;
		}
		if (dp[l] >= L[i]) {
			if (max(GetMax(l + 1 , i - 1) , lasL[i]) > dp[i]) {
				dp[i] = max(GetMax(l + 1 , i - 1) , lasL[i]);
				pre[i] = l , dir[i] = -1;
			}
		}
	}
	return (dp[n] >= m);
}
```

---

## 作者：_Ch1F4N_ (赞：1)

$O(n \log n)$ 的 dp 做法。

考虑二分一个答案 $mid$，然后从前往后考虑所有洒水器，我们希望这个考虑顺序构成了对问题的划分，也就是一个前缀的洒水器负责一个前缀的花盆。

考虑什么时候我们的这个希望可以成立，不难发现当一个洒水器向左边洒水时，如果这个洒水器代表的前缀没有覆盖一个前缀花盆，后面的洒水器也不可能弥补这个洒水器没有覆盖的前面的花盆，故此时覆盖的花盆必然是一个前缀。还有一种情形就是当出现连续两个洒水器向右，紧接着下一个洒水器向左时，第一个向右的洒水器实际上没有发挥任何意义，因此如果我们认为操作是使得一个洒水器向左，使得一个洒水器向右，与使得一个洒水器向右并使得紧接着下一个洒水器向左，将一个前缀的洒水器划分为若干个操作后可以保证覆盖的花盆是一个前缀才有意义，因此可以用 $dp_i$ 记录下这个前缀最长的情形，转移过程可以暴力扩展 dp 值，复杂度是 $O(\sum dp_i - dp_{i-1} + \sum dp_i - dp_{i-2})$，由于 $dp_n$ 至多为 $m$，所以复杂度是 $O((n+m) \log V)$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e5+114;
int dp[maxn];
int s[maxn],f[maxn],n,m;
int lst[maxn];
bool check(int K){
    dp[0]=0;
    for(int i=1;i<=n;i++){
        //向前倒
        int mx=0;
        int u=dp[i-1];
        while(u<m&&f[u+1]>=s[i]-K&&f[u+1]<=s[i]) u++;
        mx=max(mx,u);
        if(mx==u) lst[i]=1;
        //向后倒
        u=dp[i-1];
        while(u<m&&f[u+1]>=s[i]&&f[u+1]<=s[i]+K) u++;
        mx=max(mx,u);
        if(mx==u) lst[i]=2;
        u=dp[i-1];
        if(i>=2&&s[i-1]+K>=s[i]-K){
            u=dp[i-2];
            while(u<m&&f[u+1]>=s[i]-K&&f[u+1]<=s[i-1]+K) u++;
            mx=max(mx,u);
            if(mx==u) lst[i]=3;
        }
        dp[i]=mx;
    }
    return dp[n]==m;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>s[i];
    for(int i=1;i<=m;i++) cin>>f[i];
    int l=-1,r=1e9+114;
    while(l+1<r){
        int mid=(l+r)>>1;
        if(check(mid)==true) r=mid;
        else l=mid;
    }
    if(r==1e9+114){
        cout<<"-1\n";
        return 0;
    }else{
        cout<<r<<"\n";
        check(r);
        vector<char> ans;
        int u=n;
        while(u!=0){
            if(lst[u]==1){
                ans.push_back('L');
                u--;
            }else if(lst[u]==2){
                ans.push_back('R');
                u--;
            }else{
                ans.push_back('L');
                ans.push_back('R');
                u-=2;
            }
        }
        reverse(ans.begin(),ans.end());
        for(char x:ans) cout<<x;
    }
    return 0;
}
```

---

## 作者：ZHONGZIJIE0608 (赞：1)

首先，花的位置和喷水器的位置都排了序，发现射程极大时一定合法，射程很小时一定不合法，从而可以二分求最小值。

考虑怎么写 check。首先，很朴素地想，如果左边有没射到的花就往左边射，否则往右边射。

但这是错误的。我们发现如果很多喷水器同时往左射但是有的喷水器的左边射的范围被其他喷水器全部覆盖，但是往右边射就不会的话，喷水器往左射就会造成价值浪费。

不过由此可知，在喷水器射程没有被后面的全部覆盖的情况下，其他喷水器“疯狂地往左”一定不劣。

所以我们先预设喷水器往左。开一个指针变量维护当前最右边射到了哪一朵花。如果左边的花没射满且在射程外，就是不合法的（右边的喷水器就更不能射到了）。在射程内，则把该喷水器往左，维护射到的指针。如果左边都射满了就往右射。

但是，如果上一个喷水器往左且其喷射范围被当前喷水器覆盖就直接把那个喷水器往右射（给**当前**喷射器打标记）。

考虑到打算往右射的喷水器可能还在影响其他喷射器，我们给这些喷射器打标记统一翻转。

如果还有花没射到就不合法。

最后从 $N$ 到 $1$ 遍历喷射器，如果当前喷射器打了标记就把当前喷射器和上一个喷射器一起取消标记然后把**上一个**喷射器改成向右。

注意左端点的问题。可能射程为 $0$。

---

## 作者：ELECTRODE_kaf (赞：1)

二分射程作为答案。

判断某个射程是否合法时，贪心地构造一组洒水器方向的方案。

从左到右依次考虑每个洒水器，如果该洒水器的左侧有花朵尚未被浇灌，那么把当前洒水器的方向设为 $L$，否则设为 $R$。

如果当前未被浇灌的花朵中位置最靠左的一朵与当前洒水器的距离超过当前射程则无解。

维护已被浇灌的花朵中位置最靠右的一朵的位置，每次将一个洒水器的方向设为 $R$ 时向右推进。

遍历完所有洒水器后，若仍有花朵未被浇灌也无解。

如果两个方向为 $L$ 的洒水器所浇灌的花朵相同，那么靠左的那个是没有意义的，因此将其方向修改成 $R$。

同理，如果一个方向为 $L$ 的洒水器所浇灌的所有花朵都可以被前后的洒水器浇灌到，那么它也是无意义的，改 $R$。

为了避免反复修改洒水器的方向，维护每个洒水器是否翻转，最后从后往前遍历修改即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,x,y) for(ll i=(x);i<=(y);i++)
#define db double
#define pb push_back
#define pause system("pause")
#define fir first
#define sec second
#define ls(x) x<<1
#define rs(x) x<<1|1
#define IL inline
#define pll pair<ll,ll>

const ll N = 1e5+10;
ll n, m, s[N], sp[N], f[N], ans = -1;
bool b[N];
string plan;

bool check(ll k) {
	string newplan = "";
	ll j = 1;

	rep(i,1,n) {
		if(j <= m && f[j] < s[i]) {
			if(f[j] < s[i] - k) return 0;

			sp[i] = f[j];

			while(j <= m && f[j] <= s[i]) j++;

			if(newplan.back() == 'L' && sp[i - 1] >= s[i] - k) {
				b[i-1] = 1;

				while(j <= m && f[j] <= s[i - 1] + k) j ++;
			}

			newplan+='L';
		} else {
			while(j <= m && f[j] <= s[i] + k) j ++;

			newplan+='R';
		}
	}

	if(j <= m) return 0;

	for(ll i = n; i >= 1; i --) {
		if(b[i]) {
			b[i] = b[i - 1] = 0;
			newplan[i - 1] = 'R';
		}
	}

	plan=newplan;
	return 1;
}

void bs(ll l,ll r) {
	if(l>r)return;

	ll mid = l + r >> 1;

	if(check(mid)) {
		ans=mid;
		bs(l,mid-1);
	} else bs(mid+1,r);
}

signed main() {

	cin>>n>>m;

	rep(i,1,n) cin>>s[i];

	rep(i,1,m) cin>>f[i];

	bs(0,1e9);
	cout<<ans<<'\n';

	if(ans != -1) cout<<plan;
}
```

---

## 作者：__FL__ (赞：0)

## Solution
观察题目，$K$ 的取值显然具有单调性，容易想到二分。

考虑设计判断函数。有一种显然的贪心思路：对于前几个洒水器，我们希望它们第一个不能覆盖到的花越往右越好。但是有一种额外的情况，即两个洒水器组合在一起，左边的朝右，右边的朝左，这种情况我们单独考虑。

设计 $\operatorname{dp}$ 状态 $f_{i,0/1}$ 表示对于前 $i$ 个洒水器，第 $i$ 个洒水器朝左或朝右时，第一个未被覆盖到的花的位置。可以二分出某个位置以后第一个未被覆盖到的花的位置。具体可见代码。

方案是好构造的。开一个前驱数组存储一个位置是从哪里转移过来的即可。

时间复杂度 $O(n\log^2n)$。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 100005;
int n,m,s[N],f[N],dp[N][2],nxt[N];
pair<int,int>pre[N][2];
bool check(int k)
{
	dp[0][0] = dp[0][1] = 1;
	for (int i = 1; i <= n; i++)
	{
		dp[i][0] = dp[i][1] = 0;
		if (f[dp[i-1][0]] >= s[i]-k) dp[i][0] = nxt[i],pre[i][0] = {i-1,0};
		if (i > 1)
		{
			if (s[i-1] > s[i]-k)
			{
				if (f[dp[i-2][0]] >= s[i]-k)
					dp[i][0] = upper_bound(f+1,f+m+1,s[i-1]+k)-f,pre[i][0] = {i-2,0};
				else if (f[dp[i-2][1]] >= s[i]-k)
					dp[i][0] = upper_bound(f+1,f+m+1,s[i-1]+k)-f,pre[i][0] = {i-2,1};
			}
			else
			{
				if (f[dp[i-1][1]] >= s[i]-k && nxt[i] > dp[i][0])
					dp[i][0] = nxt[i],pre[i][0] = {i-1,1};
			}
		}
		if (f[dp[i-1][0]] >= s[i]) dp[i][1] = upper_bound(f+1,f+m+1,s[i]+k)-f,pre[i][1] = {i-1,0};
		else if (f[dp[i-1][1]] >= s[i]) dp[i][1] = upper_bound(f+1,f+m+1,s[i]+k)-f,pre[i][1] = {i-1,1};
	}
	if (dp[n][0] == m+1 || dp[n][1] == m+1) return 1;
	return 0;
}
signed main()
{
	ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> s[i];
	for (int i = 1; i <= m; i++)
		cin >> f[i];
	f[m+1] = 1599999999;
	for (int i = 1; i <= n; i++)
		nxt[i] = upper_bound(f+1,f+m+1,s[i])-f;
	int l = 0,r = max(s[n],f[m]);
	while (l < r)
	{
		int mid = (l+r)/2;
		if (check(mid)) r = mid;
		else l = mid+1;
	}
	bool t = check(l);
	if (!t)
	{
		cout << -1;
		return 0;
	}
	pair<int,int>k;
	if (dp[n][0] == m+1) k = {n,0};
	else k = {n,1};
	stack<char>ans;
	cout << l << '\n';
	for (; k.first; k = pre[k.first][k.second])
	{
		if (pre[k.first][k.second].first == k.first-2) ans.push('L'),ans.push('R');
		else if (k.second == 0) ans.push('L');
		else ans.push('R');
	}
	while (!ans.empty()) cout << ans.top(),ans.pop();
	return 0;
}
```

---

## 作者：729hao (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P10806)

~~荣获最劣解。~~ 做法相较于其他题解略显复杂，慎看。

---

## Part 1 思路
首先二分答案 $k$。考虑如何 check，于是不难想到 DP。

首先先想如何暴力 check，不难想到有如下的 $O(NM)$ 做法：

令 $dp_{i,j}$ 表示是否存在一种方案，使得只考虑前 $i$ 个洒水器，最靠左的没被洒到的花为第 $j$ 朵；令 $N(x)$ 表示坐标 $\ge x$ 的最靠左的花编号，**注意不是题目中的 $N$**。

这是一个**可行性 DP**，每个 DP 值都只有 $0$ 和 $1$ 两种情况。答案显然是 $dp_{N,M+1}$。

转移的时候考虑 $dp_{i-1,j}$ 会对 $dp_i$ 造成哪些影响，分 $3$ 种情况：

### 1. $f_j>s_i$

如果我们决定将 $i$ 往左洒，那么一定洒不到第 $j$ 朵花，故有 $dp_{i,j} \gets dp_{i-1,j}$。

如果我们决定往右洒，此时显然有 $dp_{i,\max(N(s_i+k+1),j)} \gets dp_{i-1,j}$。

### 2. $f_j=s_i$
注意到无论向哪个方向洒都会洒到第 $j$ 朵花。

显然往左洒有 $dp_{i,N(s_i+1)} \gets dp_{i-1,j}$。

往右洒有 $dp_{i,N(s_i+k+1)} \gets dp_{i-1,j}$。

### 3. $f_j<s_i$
重头戏来了。

往右洒很简单，肯定洒不到第 $j$ 朵，有 $dp_{i,j} \gets dp_{i-1,j}$。

那向左呢？

如果 $f_j<s_i-k$，那确实洒不到 $j$，跟上面一样。

如果 $f_j>s_i-k$，这个时候因为我们并不知道第 $i-1$ 个洒水器是怎么洒的，就又要分讨了：

#### （1） $f_j<s_{i-1}$
即上一个洒水器一定是向右洒的。

> 有人可能会问：万一上一个确实是向左洒的，只是洒不到呢？
> 
> 显然，这种情况只有当 $f_j<s_{i-1}-k$ 的时候成立，但是由于我们讨论的前提是 $f_j>s_i-k$，且一定有 $s_i-k \ge s_{i-1}-k$，故这种情况不存在。

那么就有 $dp_{i,N(\max(s_{i-1}+k+1,s_i+1))} \gets dp_{i-1,j}$。

#### （2） $s_{i-1}<f_j \le s_{i-1}+k$
即上一个洒水器一定是向左洒的。

那么就有 $dp_{i,N(s_i+1)} \gets dp_{i-1,j}$。

#### （3） $f_j>s_{i-1}+k$
这个时候上一个洒水器向左向右已经不重要了。

那么就有 $dp_{i,N(s_i+1)} \gets dp_{i-1,j}$。

---
综上，分讨完毕。

容易发现单次转移是 $O(1)$ 的，于是就有了 $O(NM\log V)$ 的做法。

## Part 2 优化
如何优化？

不妨把上面的转移列成一张表，表示 $dp_{i-1,j}$ 可能对 $dp_i$ 的哪些位置造成影响。（图有点小，建议单开一个窗口看）  
![](https://cdn.luogu.com.cn/upload/image_hosting/7d0gyhvb.png)

观察这张表，我们发现除了 $f_j=s_i$ 的情况，其余都一定存在一种方案使得 $dp_{i-1,j}$ 可以转移到 $dp_{i,j}$。

接着观察，我们发现对于左边五种情况，要么从 $j$ 转移到 $j$，要么和 $j$ 没关系。

然后我们发现如果把最右边这种情况拆成 $N(s_i+k+1) < j$ 和 $N(s_i+k+1) \ge j$ 两种。这样，所有情况都变成了“要么从 $j$ 转移到 $j$，要么和 $j$ 没关系”。

稍微思考我们可以发现，对于所有满足 $dp_{i-1,j}=1$ 的 $j$，一定有 $N(s_i+k+1) \ge j$，因为 $s_{i-1}+k \le s_i+k$。

于是最后一种情况就变成了：


|$f_j>s_i$|
|:-:|
|$j$|
|$N(s_i+k+1)$|

于是你可以随便拿一个什么数据结构维护一下，转移的时候看对应的区间是否**不全为 $0$**，如果是的话就更新。对于 $f_j=s_i$ 的情况特殊处理一下就行。

然后你就会 $O(N\log M \log V)$ 求 $K$ 了。接下来考虑怎么求方案。

因为根据上面的表，你可以知道每一种转移分别对应第 $i$ 个洒水器的哪一种朝向，所以本质上就是在求 $dp_{N,M+1}$ 是由谁转移过来的，然后这个值又是由谁转移过来的……以此类推。

但是我们有上面这张表啊！根据上面的表，你很容易得到 $dp_{i,j}$ 是由哪个区间转移的，那么从这个区间里随便找一个值为 $1$ 的都可以当它的前驱。

于是随便拿一个什么数据结构维护一下，做完了。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace cs{
	#define LL long long
	#define fir first
	#define sec second
	typedef pair<int,int> PII;
	const int N=1e5;
	const int INF=1e9;
	int n,m,s[N+5],f[N+5],ansf[N+5];
	int Next(int c){return lower_bound(f+1,f+m+1,c)-f;}
	int b[N+5][7];
	int BIt[N+5],dp[N+5];
	struct Segment{
		int l,r;
		int sum,mi;//mi：区间内第一个值为1的位置
		void init(int L,int R){
			l=L;r=R;
			sum=0;mi=0;
		}
	}Tree[4*N+5];
	void Pushup(int id){
		Tree[id].sum=Tree[id<<1].sum+Tree[id<<1|1].sum;
		if(Tree[id<<1].mi) Tree[id].mi=Tree[id<<1].mi;
		else Tree[id].mi=Tree[id<<1|1].mi;
	}
	void Build(int id,int L,int R){
		Tree[id].init(L,R);
		if(L==R) return;
		int mid=L+R>>1;
		Build(id<<1,L,mid);
		Build(id<<1|1,mid+1,R);
	}
	void Modify(int id,int x,int d){
		if(Tree[id].l==Tree[id].r){
			if(Tree[id].sum!=d) Tree[id].sum=d;
			if(Tree[id].sum!=0) Tree[id].mi=Tree[id].l;
			return;
		}
		if(Tree[id<<1].r>=x) Modify(id<<1,x,d);
		else Modify(id<<1|1,x,d);
		Pushup(id);
	}
	int Query(int id,int L,int R){
		if(Tree[id].l>R||Tree[id].r<L) return 0;
		if(Tree[id].l>=L&&Tree[id].r<=R) return Tree[id].mi;
		int rtn=Query(id<<1,L,R);
		if(rtn) return rtn;
		return Query(id<<1|1,L,R);
	}
	void init(){
		Build(1,1,m+1);
	}
	void Set(int x,int d){//把 dp[i][x] 赋值为 d
		Modify(1,x,d);
	}
	void h1(int l,int r,int& t){//把区间内第一个值赋值给t
		if(l>r||t!=0) return;
		t=Query(1,l,r);
	}
	bool check(int k){
		init();
		Set(1,1);
		int pos;
		for(int i=1;i<=n;i++){
			b[i][0]=b[i][1]=b[i][2]=b[i][3]=b[i][4]=b[i][5]=b[i][6]=0;
            //其中b[3]表示是否有f[j]=s[i]，其余六个变量分别对应表中六种j不转移到j的情况，是从哪里转移来的
			h1(Next(s[i]-k),Next(s[i-1])-1,b[i][0]);
			h1(Next(max(s[i-1]+1,s[i]-k)),Next(min(s[i-1]+k+1,s[i]))-1,b[i][1]);
			h1(Next(max(s[i-1]+k+1,s[i]-k)),Next(s[i])-1,b[i][2]);
			pos=Next(s[i]);
			if(f[pos]==s[i]){
				b[i][3]=1;
				h1(pos,pos,b[i][4]);
				h1(pos,pos,b[i][5]);
			}
			h1(Next(s[i]+1),m+1,b[i][6]);
			if(b[i][3]) Set(pos,0);
			if(b[i][0]) Set(Next(max(s[i-1]+k+1,s[i]+1)),1);
			if(b[i][1]) Set(Next(s[i]+1),1);
			if(b[i][2]) Set(Next(s[i]+1),1);
			if(b[i][4]) Set(Next(s[i]+1),1);
			if(b[i][5]) Set(Next(s[i]+k+1),1);
			if(b[i][6]) Set(Next(s[i]+k+1),1);
		}
		int rtn=0;
		h1(m+1,m+1,rtn);
		if(rtn==0) return false;
		int nowj=m+1;
		for(int i=n;i>=1;i--){//不停找前驱求方案
			if(b[i][6]&&nowj==Next(s[i]+k+1)){
				nowj=b[i][6];
				ansf[i]=1;
				continue;
			}
			if(b[i][5]&&nowj==Next(s[i]+k+1)){
				nowj=b[i][5];
				ansf[i]=1;
				continue;
			}
			if(b[i][4]&&nowj==Next(s[i]+1)){
				nowj=b[i][4];
				ansf[i]=0;
				continue;
			}
			if(b[i][2]&&nowj==Next(s[i]+1)){
				nowj=b[i][2];
				ansf[i]=0;
				continue;
			}
			if(b[i][1]&&nowj==Next(s[i]+1)){
				nowj=b[i][1];
				ansf[i]=0;
				continue;
			}
			if(b[i][0]&&nowj==Next(max(s[i-1]+k+1,s[i]+1))){
				nowj=b[i][0];
				ansf[i]=0;
				continue;
			}
			if(f[nowj]>s[i]) ansf[i]=0;
			else ansf[i]=1;
		}
		return true;
	}
	int main(){
		ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
		cin>>n>>m;
		s[0]=-INF-1;
		for(int i=1;i<=n;i++){
			cin>>s[i];
		}
		for(int i=1;i<=m;i++){
			cin>>f[i];
		}
		int l=0,r=INF,mid,ans=-1;
		while(l<=r){//二分答案
			mid=l+r>>1;
			if(check(mid)){
				r=mid-1;
				ans=mid;
			}
			else l=mid+1;
		}
		cout<<ans<<"\n";
		if(ans==-1) return 0;
		for(int i=1;i<=n;i++){
			if(ansf[i]) cout<<"R";
			else cout<<"L";
		}
		return 0;
	}
}
int main(){
	cs::main();
	return 0;
}
/*
input:
7 2
15 18 20 31 44 61 83 
48 68
output:7
input:
8 8
4 38 41 48 50 56 66 82 
2 6 9 24 29 72 79 85
output:32
*/
```
注：如上的代码因为常数过于巨大需要卡常才能在洛谷上通过。

时间复杂度 $O(N \log M \log V)$，空间复杂度 $O(N+M)$。

---


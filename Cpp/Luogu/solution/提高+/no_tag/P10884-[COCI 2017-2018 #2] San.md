# [COCI 2017/2018 #2] San

## 题目描述

你是否曾经梦见自己是电脑游戏中的主角？这个故事的主角 Branimir 正在做这样的梦。

在 Branimir 的梦中，世界由 $N$ 座从左到右排列的摩天大楼组成。对于第 $i$ 座摩天大楼，我们知道其高度 $H_i$ 和屋顶上的金币数量 $G_i$。游戏开始时，可以跳到任意一座摩天大楼上，并由此开始多个步骤。在每一步中，Branimir 可以跳到右边的一座摩天大楼上（也可以跳过几座），但前提是它的高度不低于当前所在的摩天大楼。在每座摩天大楼的屋顶上，Branimir 将收集所有的金币。Branimir 可以在任意步数后结束游戏（包括零步），但他必须至少收集 $K$ 个金币才能晋级到下一个关卡。

Branimir 想知道有多少种不同的方式可以玩这个游戏以晋级到下一个关卡。如果在一个游戏中访问了某座摩天大楼，而在另一个游戏中没有访问，则这两个游戏的玩法不同。

## 说明/提示

#### 示例输出 1 的解释

以下三种游戏方式可以让 Branimir 晋级到下一个关卡（数字表示他访问的摩天大楼的编号）：{1, 2, 3}，{1, 4} 和 {4}。

#### 评分

在总分的 40% 的测试用例中，将满足 $N\leq 20$。（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
4 6
2 1
6 3
7 2
5 6```

### 输出

```
3```

## 样例 #2

### 输入

```
2 7
4 6
3 5```

### 输出

```
0```

## 样例 #3

### 输入

```
4 15
5 5
5 12
6 10
2 1```

### 输出

```
4```

# 题解

## 作者：xiaoliebao1115 (赞：3)

小清新双向搜索题，难度比卖瓜稍难吧。
## idea
### 双向搜索
看到 $n\le 40$，很容易想到把整个序列分成两半进行搜索。

对于左半边搜索，每个点枚举经过和不经过。搜索到最后记录这次搜索的总金币数以及最后一个经过的位置的高度 $h_i$。

对于右半边搜索，记录的是第一个经过的位置的高度 $h_j$，其他和左半边搜索一样。

我们把左半边搜索的总金币数记为 $g_i$，右边记为 $g_j$。
### 二维偏序

根据题目要求的限制可以得出：$h_i\le h_j$，还有 $k\le g_i+g_j$，可以化为 $k-g_i\le g_j$，明显变成了一个二维偏序的形式，使用树状数组求解即可。

具体的，把所有搜索得到的结果都存入一个结构体数组中，先对 $k-g_i$ 和 $g_j$ 进行离散化，再按照 $h_i$ 排序。

对于左边搜到的，将 $k-g_i$ 加入树状数组，否则答案加上树状数组中所有小于等于 $g_j$ 的数的数量即可。

## code

```cpp
const int nn=41,mm=(1<<20)+5,kk=1e9,hyf=1<<21;//膜拜hhhyyyfff大佬
int n,h[nn],cnt;
ll g[nn],k,ans;
int tree[mm<<1];
inline void add(int x){//树状数组
	for(int i=x;i<=hyf;i+=i&(-i)) tree[i]++;
}
inline int query(int x){
	int tot=0;
	for(int i=x;i>=1;i-=i&(-i)) tot+=tree[i];
	return tot;
}
struct node{
	int h,tp;
	ll g;
};
node x[mm<<1];
inline bool cmp(node l1,node l2){
	return l1.g<l2.g;
}
inline bool cmp2(node l1,node l2){
	if(l1.h==l2.h) return l1.tp<l2.tp;
	return l1.h<l2.h;
}
inline void dfs(int wz,ll sum,int lst){
	if(wz>n/2){
		cnt++;
		x[cnt].h=lst,x[cnt].g=k-sum>0?k-sum:0;
		return ;
	}
	if(lst<=h[wz]) dfs(wz+1,sum+g[wz],h[wz]);
	dfs(wz+1,sum,lst);
}//搜索左边
inline void dfs2(int wz,ll sum,int lst){
	if(wz<=n/2){
		cnt++;
		x[cnt].h=lst,x[cnt].g=sum,x[cnt].tp=1;
		return ;
	}
	if(lst>=h[wz]) dfs2(wz-1,sum+g[wz],h[wz]);
	dfs2(wz-1,sum,lst);
}//搜索右边
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>h[i]>>g[i];
	dfs(1,0,0);
	dfs2(n,0,kk);
	sort(x+1,x+cnt+1,cmp);
	int mzhxi=0;
	ll prvg=-1,bfg;
	for(int i=1;i<=cnt;i++){
		bfg=x[i].g;
		if(x[i].g==prvg) x[i].g=mzhxi;
		else x[i].g=++mzhxi;
		prvg=bfg;//离散化
	}
	sort(x+1,x+cnt+1,cmp2);
	for(int i=1;i<=cnt;i++){
		if(x[i].tp){
			ll sum=query(x[i].g);
			ans+=sum;
		}
		else add(x[i].g);
	}
	cout<<ans<<endl;
	return 0;
}
```
时间复杂度 $O(2^{\frac n 2}\log2^{\frac n 2})$。

---

## 作者：Stone_Xz (赞：2)

## [传送门：P10884](https://www.luogu.com.cn/problem/P10884)

## 题意

> 给你 $n$ 栋楼，以及一个整数 $k$。每栋楼有一个高度 $h_i$ 和一个金币数 $g_i$。你可以从任何一栋楼开始，向右跳到任意不低于当前高度的楼上，并获得这栋楼的金币。你可以在任何时候结束，一条合法的路径必须满足：你拿到的总金币数（包括起点的金币） $\ge k$。问：一共有多少条满足条件的路径。

## 分析

 - 双向 dfs。

1. 直接暴力，时间复杂度 $O(2 ^ {n})$，时间爆炸。

2. 发现路径可以双向 dfs。首先暴力求 $1$ 到 $mid$ 的所有路径，求出它们的终点 $l$ 以及总金币数 $sum$，表示**以 $l$ 为终点**所有的路径方案。然后**反着**求 $n$ 到 $mid + 1$ 的所有路径，这时我们记录的终点 $l$ 其实是一条路径的起点，同样求出这条路径的总金币数，表示**以 $l$ 为起点**的所有路径方案。

3. 我们称正着跑出来的路径是路径 $a$，反着跑出来的路径是路径 $b$。每求出来一条新的 $b$ 路径，我们就尝试让它与所有的 $a$ 路径连接。两条路径能拼在一起要满足：两条路径的 $sum$ 相加 $\ge k$，且 $a$ 路径的终点 $l_1$ 的高度 $h_{l_1}$ 要 $\le$ $b$ 路径的起点 $l_2$ 的高度 $h_{l_2}$。

4. 对于一条 $b$ 路径，它不一定要经过前半段。所以我们虚拟一个点 $0$，$h_0 = 0$，$g_0 = 0$。在正着找路径时从点 $0$ 开始，那么就会有一条终点为 $0$ 且总金币数为 $0$ 的 $a$ 路径，与任何 $b$ 路径都能拼接（仅限于高度的限制），且不会对 $b$ 路径的 $sum$ 造成影响。等价于这条 $b$ 路径没有拼接。

5. 对于一条 $a$ 路径，它也不一定要经过后半段。同理，我们虚拟一个点 $n + 1$，$h_{n + 1} = \inf$，$g_{n + 1} = 0$。在反着找路径时从点 $n + 1$ 开始，就会有一条起点为 $n + 1$ 且总金币数为 $0$ 的 $b$ 路径，他在选择 $a$ 路径拼接时，能选择所有 $a$ 路径（仅限于高度的限制），拼接后等价于这条 $a$ 路径没变。

6. 最后一点，对于一条 $b$ 路径，如何找到能与它拼接的 $a$ 路径？定义一个动态数组 $a$，$a_i$ 存储所有可能的终点为 $i$ 的 $a$ 路径的 $sum$。新找到一条 $b$ 路径时，枚举 $a$ 路径的终点 $i$，如果 $h_i \le$ 当前 $b$ 路径的 $sum$，说明符合高度限制。同时在求出 $a$ 数组后，对每一个 $a_i$ 都排个序，拼接时二分求出 $a_i$ 中 $(\text{a 路径的} sum) \ge k - (\text{b 路径的 sum)}$ 的元素个数 $x$，方案数 $ + x$。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 45;

int n, k, h[N], g[N], mid, ans;

vector<int> a[N];

void dfs1(int cur, int sum, int l)
{
	if(cur == mid + 1)
	{
		a[l].push_back(sum);
		return ;
	}
	if(h[cur] >= h[l])
		dfs1(cur + 1, sum + g[cur], cur);
	dfs1(cur + 1, sum, l);
}

void dfs2(int cur, int sum, int l)
{
	if(cur == mid)
	{
		for(int i = 0; i <= mid; i++)
		{
			if(h[i] > h[l]) continue;
			int tmp = lower_bound(a[i].begin(), a[i].end(), k - sum) - a[i].begin();
			tmp ++;
			ans += a[i].size() - tmp + 1;
		}
		return ;
	}
	if(h[cur] <= h[l])
		dfs2(cur - 1, sum + g[cur], cur);
	dfs2(cur - 1, sum, l);
}

signed main()
{
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
		cin >> h[i] >> g[i];
	h[n + 1] = 2e9;
	mid = n >> 1;
	dfs1(1, 0, 0);
	for(int i = 1; i <= mid; i++)
		sort(a[i].begin(), a[i].end());
	dfs2(n, 0, n + 1);
	cout << ans;
	return 0;
}
```

---

## 作者：ZPB2011 (赞：1)

# [San](https://www.luogu.com.cn/problem/P10884)

## 前言

讲个笑话，笔者一开始差点以为 $N \le 20$，后面才看到 $N \le 40$ 以为很水~~虽然确实比较水~~。

## 思路

看到 $N \le 40$ 应该就能想到这是一个 meet in middle 的题目。

可以先写个 `dfs` 算前半段用一个数组存下来，对这个数组进行排序，方便后面二分。

然后再写一个 `dfs` 把后半段算出来，如果到了中间那个点就枚举每个点的值，二分找出 `k-sum`，然后最后方案就可以加上这个点的总方案减掉 `k-sum` 前面的数的数量。

## AC code

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define int long long
using namespace std;

const int N = 45;

int n, k, s, h[N], g[N];
vector<int> ans[N];

void dfs(int x, int sum, int lst, int high) {//dfs前半段
	if(x == n / 2 + 1) {
		ans[lst].push_back(sum);//记录下每个点（注意不是x，而是上一个落脚的点）的值
		return;
	}
	if(h[x] >= high) dfs(x + 1, sum + g[x], x, h[x]);
	dfs(x + 1, sum, lst, high);
}

void dfs2(int x, int sum, int high) {
	if(x == n / 2) {
		for(int i = 0; i <= n / 2; i++) {
			if(h[i] <= high) {
				int pos = lower_bound(ans[i].begin(), ans[i].end(), k - sum) - ans[i].begin();//二分找出位置
				s += ans[i].size() - pos;//答案加上这个点的方案数
			}
		}
		return;
	}
	if(h[x] <= high) dfs2(x - 1, sum + g[x], h[x]);
	dfs2(x - 1, sum, high);
}

signed main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++) cin >> h[i] >> g[i];
	dfs(1, 0, 0, 0);
	for(int i = 1; i <= n; i++) sort(ans[i].begin(), ans[i].end());//排序方便后面二分搜索
	dfs2(n, 0, 1e18);//第n+1个取极大值
	cout << s << endl;
	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

模拟赛考的简单题，但是那场模拟赛给我整破防了。

---

回归题解。给个稍微无脑一点，不需要离线下来处理答案的暴力做法。

观察到数据范围是不常见的 $n\le40$，以及给了我们 $n\le20$ 的暴搜分，基本可以确定 meet in middle。

首先可以给题目加上第 $0$ 栋楼和第 $n+1$ 栋楼，让第 $0$ 栋楼最低，第 $n+1$ 栋楼最高，然后 $c_0=c_{n+1}=0$。所以起点终点确定了写起来更简单。

$h$ 可以离散化这个很容易看出来，在左边部分我们对于每栋楼都存一下在这里出现了哪些数和出现次数。对于右边的每栋楼我们从左边所有可以转过来的楼转移过来。

题解用的都是二维数点，但是每栋楼的转移是把所有大于等于 $K-s$ 的值对应的个数过来，所以无脑线段树维护就好了。

值域开到 $4\times10^{10}$，动态开点即可。算了一下，跑满一共大约 $2^{20}$ 次插入，每次新开 $\log V$ 也就是差不多 $35,36$ 个节点，所以总空间开到 $4\times10^7$ 差不多了。

全部开 long long 会 MLE 一个点，把不需要的 long long 去掉就好了。

复杂度 $O(2^{\frac{n}{2}}n\log V)$。

```cpp
#include <bits/stdc++.h>
// #define int long long
#define fi first
#define se second
#define Il inline
#define Rg register
#define Ri Rg int
#define pb push_back
#define vec vector
#define IT ::iterator
#define p_que priority_queue

using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
const int N=40,M=4e7,Inf=1e9;
const db eps=1e-9,pi=acos(-1.0);

int n,h[N+5],dn=0,ln=0,lsh[N+5],c[N+5];
ll sm=0,ans=0,K;
int si=0,sg[M+5],ls[M+5],rs[M+5],rt[N+5];

Il void add(ll ps,ll l,ll r,int &p,int K){
	if(!p)p=++si;sg[p]+=K;
	if(l==r)return;ll mid=(l+r)>>1ll;
	if(ps<=mid)add(ps,l,mid,ls[p],K);
	else add(ps,mid+1,r,rs[p],K);
	return;
}

Il int qy(ll ql,ll qr,ll l,ll r,int p){
	if(!p)return 0;if(ql<=l&&r<=qr)return sg[p];
	ll mid=(l+r)>>1ll,ret=0;
	if(ql<=mid)ret+=qy(ql,qr,l,mid,ls[p]);
	if(qr>mid)ret+=qy(ql,qr,mid+1,r,rs[p]);
	return ret;
}

Il void Disc(){
	for(Ri i=1;i<=n;i++)lsh[i]=h[i];
	sort(lsh+1,lsh+n+1);dn=unique(lsh+1,lsh+n+1)-lsh-1;
	for(Ri i=1;i<=n;i++)h[i]=lower_bound(lsh+1,lsh+dn+1,h[i])-lsh;
	return;
}

Il void dfs1(int p,ll s){
	add(s,0,sm,rt[h[p]],1);
	for(Ri i=p+1;i<=(n>>1);i++)if(h[i]>=h[p])dfs1(i,s+c[i]);
	return;
}

Il void dfs2(int p,ll s){
	for(Ri i=0;i<=h[p];i++)ans+=qy(max(0ll,K-s),sm,0,sm,rt[i]);
	for(Ri i=p-1;i>(n>>1);i--)if(h[i]<=h[p])dfs2(i,s+c[i]);
	return;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>K;for(Ri i=1;i<=n;i++)cin>>h[i]>>c[i],sm+=c[i];
	Disc();h[n+1]=dn+1;sm=max(sm,K);dfs1(0,0);dfs2(n+1,0);
	cout<<ans;
	return 0;
} 
```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10884)

**题目大意**

> 给定 $n$ 个元素，每个元素有高度和权值，求有多少个高度单调不降的子序列满足元素权值和 $\ge k$。
>
> 数据范围：$n\le 40$。

**思路分析**

考虑折半搜索，从前往后搜出在 $x$ 处结尾的 LIS，从后往前搜出在 $y$ 处开始的 LIS。

那么查询答案相当于在 $a_x\le a_y$ 的 LIS 上查询有多少权值 $\ge k-w$ 的序列。

可以离线下来二维数点，但直接暴力排序二分也能通过。

时间复杂度 $\mathcal O(n^22^{n/2})$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=45,inf=1e9;
int n,m,a[MAXN],w[MAXN];
ll k,ans=0;
vector <ll> s[MAXN];
void dfs1(int i,int x,ll c) {
	if(i>n/2) return s[x].push_back(c);
	dfs1(i+1,x,c);
	if(a[i]>=a[x]) dfs1(i+1,i,c+w[i]);
}
void dfs2(int i,int x,ll c) {
	if(i<=n/2) {
		for(int j=0;j<=n/2;++j) if(a[j]<=a[x]) {
			ans+=s[j].end()-lower_bound(s[j].begin(),s[j].end(),k-c);
		}
		return ;
	}
	dfs2(i-1,x,c);
	if(a[i]<=a[x]) dfs2(i-1,i,c+w[i]);
}
signed main() {
	scanf("%d%lld",&n,&k);
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i],&w[i]);
	dfs1(1,0,0);
	for(int i=1;i<=n/2;++i) {
		sort(s[i].begin(),s[i].end());
	}
	a[n+1]=inf;
	dfs2(n,n+1,0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：lfxxx_ (赞：0)

这题一眼就是一道 meet in middle 题。

我们先求出前一半的所有的和与最大值，装进一个数组里面，再求出后一半的，然后拼在一起。

但是有的时候不合法，怎么办？

明显，我们给前一半和后一半的答案排序，然后用平衡树+双指针维护，去扫一遍前一半的答案，然后另一个指针就往后移，同时平衡树删除元素。

具体见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=45,M=2e6+5;
//-- meet in middle --
int n,K;
int n1,n2;
int a[N],b[N];
int A[N],B[N],cnt;
vector<pair<int,int> >p,v;
void dfs1(int u)//求出前一半的答案 
{
	if(u==n1)
	{
		for(int i=0;i<cnt-1;++i)
			if(A[i]>A[i+1])
				return ;
		//判断合法性 
		int sum=0;
		for(int i=0;i<cnt;++i)
			sum+=B[i];
		if(cnt>0)p.push_back(make_pair(A[cnt-1],sum));
		//加入答案 
		return ;
	}
	A[cnt]=a[u];
	B[cnt]=b[u];
	++cnt;
	dfs1(u+1);
	--cnt;
	dfs1(u+1);
}
void dfs2(int u)
{
	if(u==n1-1)
	{
		for(int i=0;i<cnt-1;++i)
			if(A[i]<A[i+1])
				return ;
		int sum=0;
		for(int i=0;i<cnt;++i)
			sum+=B[i];
		if(cnt>0)v.push_back(make_pair(A[cnt-1],sum));
		return ;
	}A[cnt]=a[u];
	B[cnt]=b[u];
	++cnt;
	dfs2(u-1);
	--cnt;
	dfs2(u-1);
}
// -- meet in middle --
//-- FHQ treap --
int root,tot;
struct node{
	int val,pri,ls,rs,sz;
}tr[M];
int New(int x)
{
	++tot;
	tr[tot].val=x;
	tr[tot].pri=rand();
	tr[tot].ls=tr[tot].rs=0;
	tr[tot].sz=1;
	return tot;
} 
void pushup(int p){tr[p].sz=tr[tr[p].ls].sz+tr[tr[p].rs].sz+1;}
void Split(int p,int x,int &L,int &R)
{
	if(!p)
	{
		L=R=0;
		return ;
	}
	if(tr[p].val<=x)
	{
		L=p;
		Split(tr[p].rs,x,tr[p].rs,R);
	}
	else
	{
		R=p;
		Split(tr[p].ls,x,L,tr[p].ls);
	}
	pushup(p);
}
int Merge(int L,int R)
{
	if(!L||!R)
		return L+R;
	if(tr[L].pri<=tr[R].pri)
	{
		tr[L].rs=Merge(tr[L].rs,R);
		pushup(L);
		return L; 
	}
	tr[R].ls=Merge(L,tr[R].ls);
	pushup(R);
	return R;
}
// --  FHQ treap --
signed main()
{
	srand(time(0));
	cin>>n>>K;
	n1=n/2,n2=n-n1;
	for(int i=0;i<n;++i)
		cin>>a[i]>>b[i];
	dfs1(0);
	cnt=0;
	memset(A,0,sizeof A);
	memset(B,0,sizeof B); 
	dfs2(n-1);
	sort(p.begin(),p.end());
	sort(v.begin(),v.end());//排序然后以便后面的双指针 
	int pt=0,ans=0;
	for(int i=0;i<v.size();++i)
	{
		int L,R,x=v[i].second;
		if(x>=K)
			++ans;
		Split(root,x,L,R);
		root=Merge(Merge(L,New(x)),R);//插入x 
	}
	for(int i=0;i<p.size();++i)
	{
		int x=p[i].first,y=K-p[i].second;
		if(y<=0)
			++ans;
		while(pt<v.size()&&v[pt].first<x)//扫掉不合法的元素 
		{
			int L,R,p;
			Split(root,v[pt].second,L,R);
			Split(L,v[pt].second-1,L,p);
			p=Merge(tr[p].ls,tr[p].rs);
			root=Merge(Merge(L,p),R);
			++pt;
		}
		int L,R;
		Split(root,y-1,L,R);
		ans+=tr[R].sz;//求和 
		root=Merge(L,R);
	}
	cout<<ans;
	return 0;
}


```

---

## 作者：elbissoPtImaerD (赞：0)

$n \le 20$ 直接 dfs。

$n \le 40$，考虑 mid-in-middle，将序列从中间劈开，对前后两段分别 dfs。

合并就考虑前半段有 $(s_1,h_1)$ 表示**跳到了高 $h_1$ 的柱子**，有金币 $s_1$，后半段有 $(s_2,h_2)$ **从高 $h_2$ 的柱子开始跳**，有金币 $s_2$。这两段的合并合法条件是 $s_1+s_2 \ge K \wedge h_1 \le h_2$，这是二维偏序，直接离线下来数点即可。

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/173166628)

```cpp

void Solve() {
  int n; cin>>n;
  LL m; cin>>m;
  ve<int>h(n),a(n);
  for(int i=0;i<n;++i) cin>>h[i]>>a[i];
  [&] {
    ve<int>a(n,1);
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) a[i]+=h[j]<h[i];
    h=a;
  } ();
  int mid=n/2;
  ve<pair<LL,int>>e; e.reserve((int)1e7);
  e.pb(m,-1);
  const auto dfs1=[&](auto dfs,int i,LL s)->void {
    e.pb(m-s,-h[i]);
    for(int j=i+1;j<mid;++j) if(h[i]<=h[j]) dfs(dfs,j,s+a[j]);
  };
  for(int i=0;i<mid;++i) dfs1(dfs1,i,a[i]);
  const auto dfs2=[&](auto dfs,int i,LL s,int p)->void {
    e.pb(s,p);
    for(int j=i+1;j<n;++j) if(h[i]<=h[j]) dfs(dfs,j,s+a[j],p);
  };
  for(int i=mid;i<n;++i) dfs2(dfs2,i,a[i],h[i]);
  LL ans=0;
  const auto V=*max_element(all(h))+1;
  ve<LL>f(V);
  const auto _M=[&](int x) {
    for(;x<V;x+=x&-x) ++f[x];
  };
  const auto _Q=[&](int x) {
    LL s=0;
    for(;x;x-=x&-x) s+=f[x];
    return s;
  };
  e.pb(0,V-1);
  sort(all(e));
  for(auto[x,y]:e) {
    if(y<0) _M(-y);
    else ans+=_Q(y);
  }
  cout<<ans;
  return;
}
```

---


# 虚树

## 题目背景

首先，做这道题不需要用到任何虚树有关知识。

——尽管这是主题库里第一个名字含“虚树”的题（

## 题目描述

jq 姐姐有一棵以结点 $1$ 为根的树。定义一棵树的点集 $S$ 的非空子集 $s$ 是好的，当且仅当它满足 $\forall i,j \in s, \text{LCA}(i,j) \in s$。[什么是 $\text{LCA}$？](https://oi-wiki.org/graph/lca/)

为了让树的形态更加可爱，jq 姐姐打算修剪掉某个以节点 $i$ 为根的子树（也就是在原树里将节点 $i$ 及其子树内节点及其相连的边均删除）。

她有若干个修剪方案但从未实施，你需要求出每种方案实施后这棵树的好的非空子集数量。由于答案可能会很大，请输出其对 $998244353$ 取模的结果。

## 说明/提示

样例 1 解释：删去以 $2$ 为根的子树后，原树点集的 $3$ 个非空子集均满足性质，删去以 $5$ 为根的子树后，原树点集的 $15$ 个非空子集中有 $\{3,4\}$、$\{1,3,4\}$ 不满足性质。

对于前 $10\%$  的数据，$n,m \leq 20$。

对于前 $30\%$ 的数据，$n,m \leq 3000$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 5 \times 10^5$，$q \in [1,n]$。

## 样例 #1

### 输入

```
5
1 2
2 3
2 4
1 5
2
2 5```

### 输出

```
3
13```

## 样例 #2

### 输入

```
10
1 2
2 3
2 4
1 5
5 6
5 7
7 8
7 10
1 9
3
5 2 8```

### 输出

```
21
66
201```

# 题解

## 作者：SunsetVoice (赞：5)

好题啊（赞赏）

> 然后自信提交，获得了 $30$ 分的好成绩。

设 $dp_{i,0}$ 为 $i$ 方案中不包含 $i$，$i$ 的子树的方案总数；$dp_{i,1}$ 为包含 $i$ 的方案，$i$ 的子树的方案总数。

显然，如果要跨子树选择，必须选 $i$，因为 $\text{LCA}(u,v)$ 肯定有 $i$ 存在，再加上 $i$ 自身，一共是 $\prod dp_{v,0}+dp_{v,1}+1$.

若不选 $i$，则继承了任意一颗子树里的方案。总方案数为 $\sum dp_{v,0}+dp_{v,1}$。

转移都是 $O(n)$ 的。

> 然后自信提交，获得了 $30$ 分的好成绩。

这里有一个小优化，显然一次改变 $i$ 只影响 $i$ 到 $1$ 上的所有路径，删去即可，注意除法要有理数取模。

> 然后自信提交，获得了 $30$ 分的好成绩。

复杂度仍是 $O(nm)$，由于数据造的太好，没有骗到任何分。

我们考虑树上前缀积算子树贡献系数 $g_i$，显然这玩意可以预处理。

于是答案为 $dp_{1,0}+dp_{1,1}-(dp_{pos,0}+dp_{pos,1})\times g_{pos}$

复杂度为 $O(n\log mod)$

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
using namespace std;
int siz[500001] = {0},n,m,dp[500001][2] = {0},db = 0;
int fdp[500001][2] = {0};
vector<int>e[500001];
int vis[500001] = {0};
const int mod = 998244353;
int fa[500001] = {0};
int g[500001] = {0};
int qpow(int x,int y){
	int ret = 1; 
	while(y){
		if(y&1){
			ret*=x;
			ret%=mod;
		}
		x*=x;
		x%=mod;
		y>>=1;
	}
	return ret;
}
void dfs(int pos){
	vis[pos] = 1;
	int dyc = 1;
	for(int i = 0;i<e[pos].size();i++){
		if(!vis[e[pos][i]]){
			fa[e[pos][i]] = pos;
			//cout<<pos<<" "<<e[pos][i]<<endl;
			dfs(e[pos][i]);
			dp[pos][0]+=dp[e[pos][i]][0]+dp[e[pos][i]][1];
			dp[pos][0]%=mod;
			//cout<<dp[e[pos][i]][0]+dp[e[pos][i]][1]+1<<endl;
			dyc*=(dp[e[pos][i]][0]+dp[e[pos][i]][1]+1)%mod;
			dyc%=mod;
		}
	}
	dp[pos][1]+=dyc;
	dp[pos][1]%=mod;
	for(int i = 0;i<e[pos].size();i++){
		if(e[pos][i]!=fa[pos]){
			g[e[pos][i]] = dp[pos][1]*qpow(dp[e[pos][i]][1]+dp[e[pos][i]][0]+1,mod-2)%mod+1;
		}
	}
	return;
}
void dfs2(int pos){
	if(fa[pos]!=1){
		g[pos]*=g[fa[pos]];
		g[pos]%=mod;
	}
	for(int i = 0;i<e[pos].size();i++){
		if(e[pos][i]!=fa[pos]){
			dfs2(e[pos][i]);
		}
	}
	return;
}
signed main(){
	cin>>n;
	for(int i = 1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i = 1;i<=n;i++){
		dp[i][0] = 0;
		dp[i][1] = 0;
	}
	dfs(1);
	dfs2(1);
//	for(int i = 1;i<=n;i++){
//		cout<<g[i]<<" ";
//	}
//	cout<<endl;
	cin>>m;
	for(int i = 1;i<=m;i++){
		int pos;
		cin>>pos;
		cout<<(dp[1][0]+dp[1][1]+mod-g[pos]*(dp[pos][0]+dp[pos][1])%mod)%mod<<endl;;
	}
	return 0;
}

```

---

## 作者：fzitb7912 (赞：5)

## 分析

为什么不是虚树。

为什么比 B 题简单。

拿到这种题，首先想到树形 DP 啊。

看到 $O(n^2)$ 的暴力有 $30$ 分，先来个暴力 DP 看看。定义状态函数 $f_{i,1/0}$ 表示去掉 $q$ 为根的子树后在 $i$ 为根的子树中，选或者不选 $i$ 时满足条件点集的数量。

当 $i$ 不选的时候，对于它的一个儿子 $j$，只要 $j$ 为根的子树中有一个及以上的点被选了，就不能选 $i$ 的另一个儿子 $k$ 为根的子树中任意一个点了。因为 $j$ 为根子树中任意一个点 $x$ 和 $k$ 为根子树中任意一个点 $y$，$\operatorname{LCA(x,y)=i}$。有转移方程：$f_{i,0} = \sum\limits_{j \in son_i}^{}(f_{j,0}+f_{j,1})$。

当 $i$ 选的时候，$x$ 和 $y$ 就可以同时选了。有转移方程：$f_{i,1}=\prod\limits_{j \in son_i} (1+f_{j,0}+f_{j,1})$。

这样每次去掉 $q$ 为根的子树后跑一遍 DP,答案就是 $f_{1,0}+f_{1,1}$ 了。期望得分 $30$ 分。

这个时候不难想到，其实我们是可以先把总的方案数求出来，然后把选了 $q$ 为根子树中**至少**一个点的方案数剪掉的。这样我们就只需要针对 $q$ 的祖先考虑问题了。

DP 数组 $f_{i,1/0}$ 和上面的状态定义差不多，只是去掉 $q$ 的限制。然后定义一个新的 DP 数组 $g_{i,1/0}$，状态定义同 $30$ 分的 $f_{i,1/0}$。

对于 $q$ 的一个祖先 $i$，若 $j$ 也是 $q$ 的祖先且 $j \in son_i$。

当 $i$ 不选的时候，因为只能取 $j$ 这边，所以方案数为 $g_{i,0}=g_{j,0}+g_{j,1}$。

当 $i$ 选的时候，$j$ 这边必取，其它的可取可不取，有转移方程：$g_{i,1}=(g_{j,0}+g_{j,1}) \times \prod\limits_{k \in son_i \land k \ne j}^{} (1+f_{k,0}+f_{k,1}) $。

答案为 $g_{1,0}+g_{1,1}$。发现 $g$ 可以只定义一维，表示 $i$ 为根时的答案，则有：$g_{i}=g_j \times(1+ \prod\limits_{k \in son_i \land k \ne j}^{} (1+f_{k,0}+f_{k,1})) $。

不怎么仔细就能看出，$g$ 是可以预处理出来的，就可以实现 $O(1)$ 查询了。复杂度是 $O(n \log n)$ 的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
    il int read(){
        int x=0,f=1;char ch=gc;
        while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
        while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
        return x*f;
    }
    il int qmi(int a,int b,int p){
        int ans=1;
        while(b){
            if(b&1) ans=ans*a%p;
            a=a*a%p,b>>=1;
        }
        return ans;
    }
    il auto max(auto a,auto b){return (a>b?a:b);}
    il auto min(auto a,auto b){return (a<b?a:b);}
    il int gcd(int a,int b){
        if(!b) return a;
        return gcd(b,a%b);
    }
    il int lcm(int a,int b){
        return a/gcd(a,b)*b;
    }
    il void exgcd(int a,int b,int &x,int &y){
        if(!b) return x=1,y=0,void(0);
        exgcd(b,a%b,x,y);
        int t=x;
        x=y,y=t-a/b*x;
        return ;
    }
    il int F(int n,int a,int b,int c){
        //sum{|_ (ai+b)/c _| i:0~n}
        if(!n) return b/c;
        if(!a) return (n+1)*(b/c);
        if(a>=c||b>=c){
            int x=a/b,y=b/c;
            return n*(n+1)/2*x+(n+1)*y+F(n,a%c,b%c,c);
        }
        int m=(a*n+b)/c;
        return n*m+F(m-1,c,c-b+1,a);
    }
    struct lb{
        int d[64];
        il void print(){
            for(re int i=0;i<63;++i)
            if(d[i]) printf("%lld:%lld\n",i,d[i]);
            return ;
        }
        lb(){memset(d,0,sizeof(d));}
        il void operator +=(int x){
            for(re int i=62;i>=0;--i){
                if(!(x&(1ll<<i))) continue;
                if(d[i]) x^=d[i];
                else return d[i]=x,void(0);
            }
            return ;
        }
        int& operator [](int x){
            return d[x];
        }
        il void operator +=(lb &x){
            for(re int i=62;i>=0;--i)
            if(x[i]) *this+=x[i];
            return ;
        }
        il friend lb operator +(lb &x,lb &y){
            lb z=x;
            for(re int i=62;i>=0;--i)
            if(y[i]) z+=y[i];
            return z;
        }
        il int Max_calc(){
            int ans=0;
            for(re int i=62;i>=0;--i)
            if((ans^d[i])>ans) ans^=d[i];
            return ans;
        }
    };
    mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=5e5+10,p=998244353;
int n,m;
int ne[N<<1],e[N<<1],h[N],idx;
int f[N][2],g[N],sum;

il void add(int a,int b){
	ne[++idx]=h[a],e[idx]=b,h[a]=idx;
	ne[++idx]=h[b],e[idx]=a,h[b]=idx;
	return ;
}
il void dfs1(int u,int fa){
	f[u][0]=0,f[u][1]=1;
	for(re int i=h[u];i;i=ne[i]){
		int v=e[i];
		if(v==fa) continue;
		dfs1(v,u);
		f[u][0]=(f[u][0]+f[v][1]+f[v][0])%p;
		f[u][1]=(f[u][1]*(1+f[v][0]+f[v][1]))%p;
	}
	return ;
}
il void dfs2(int u,int fa){
	for(re int i=h[u];i;i=ne[i]){
		int v=e[i];
		if(v==fa) continue;
		g[v]=g[u]*(f[u][1]*qmi((1+f[v][0]+f[v][1])%p,p-2,p)%p+1)%p;
		dfs2(v,u); 
	}
	return ;
}

il void solve(){
	n=rd;
	for(re int i=1;i<n;++i) add(rd,rd);
	m=rd;
	dfs1(1,0);
	sum=(f[1][0]+f[1][1])%p,g[1]=1;
	dfs2(1,0);
	while(m--){
		int q=rd;
		printf("%lld\n",(sum-(f[q][0]+f[q][1])*g[q]%p+p)%p);
	}
    return ;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    int t=1;while(t--)
    solve();
    return 0;
}
```

---

## 作者：Thomas0702 (赞：5)

简明题意：给定一棵树，每次询问删去一棵子树后的树能形成的虚树数量。

考虑 dp。设 $f_{u,0}$ 表示考虑 $u$ 为根的子树，$u$ 不在虚树中，但子树中存在至少一个节点在虚树中的方案数；$f_{u,1}$ 表示 $u$ 在虚树中的方案数。可以列出转移方程：
$$f_{u,0}=\sum\limits_{v\in son_u}f_{v,0}+f_{v,1}$$
$$f_{u,1}=\prod\limits_{v\in son_u}(f_{v,0}+f_{v,1}+1)$$
第一个转移式表示从 $u$ 的子树中仅选一棵子树形成虚树的方案数；第二个转移式表示从 $u$ 的子节点 $v$ 为根的子树中选（即式子中的 $f_{v,0}+f_{v,1}$）或者不选（即式子中的 $1$）点形成虚树的方案数。特别地，当 $u$ 是叶节点，$f_{u,0}=0,f_{u,1}=1$。

这样，每次去掉以 $q_i$ 为根的子树，求 $f$ 都是 $O(N)$ 的，总复杂度 $O(NQ)$。

考虑优化。个人认为本题解的优化比较好想但是不太容易写。

优化去掉以 $q$ 为根的子树，求 $f$ 数组的过程。因为 dp 转移方程形式都是一样的，所以考虑用线段树同时维护**在 $u$ 的子树中，去掉以 $q$ 为根的子树后，$u$ 的 $f$ 数组**。具体地，将树拍扁在 dfs 序上，每个位置 $i$ 维护**去掉 dfs 序为 $i$ 的点为根的子树后，$u$ 的 $f$ 数组**。

先从 $q$ 所在的子树 $v$（$v$ 是 $u$ 的子节点）进行一次转移，起初 $dfn_q$ 处维护的是 $f_v$，由上面的转移式，可以得到第一种转移：
$$f_{u,0}=f_{v,0}+f_{v,1}$$
$$f_{u,1}=f_{v,0}+f_{v,1}+1$$
直接对 $u$ 子树中的所有点（除了 $u$）都修改即可，对应区间 $[dfn_u+1,dfn_u+sz_u-1]$。

预先求出什么也不删的 $f$ 数组，记作 $F$。那么 $dfn_q$ 处维护的 $f$ 值又可以从 $u$ 的子节点 $v'(v'\neq v)$ 的 $F$ 处转移，可以得到第二种转移：
$$f_{u,0}\leftarrow f_{u,0}+F_{v,0}+F_{v,1}$$
$$f_{u,1}\leftarrow f_{u,0}\times (F_{v,0}+F_{v,1}+1)$$
枚举 $u$ 的子节点 $v$，将非 $v$ 子树中的节点 $q$ 维护的 $f$ 值进行转移即可。容易发现对于每个 $v$，这个操作在 dfs 序上最多会对两个区间进行修改（即 $[dfn_u+1,dfn_v-1]$ 和 $[dfn_v+sz_v,dfn_u+sz_u-1]$）。所以总复杂度 $O((N+Q)\log N)$。

具体的细节：  
当 $q=u$ 时，$f_{u,0}=f_{u,1}=0$。  
用矩阵维护 $f$ 数组，形如：
$$\begin{bmatrix}f_{u,0}&f_{u,1}&1\end{bmatrix}$$
第一种转移的转移矩阵：
$$\begin{bmatrix}1&1&0\\1&1&0\\0&1&1\end{bmatrix}$$
第二种转移的转移矩阵：
$$\begin{bmatrix}1&0&0\\0&f_{v,0}+f_{v,1}+1&0\\f_{v,0}+f_{v,1}&0&1\end{bmatrix}$$
如果直接对每个线段树上的节点开一个 $s$ 矩阵和一个 $tag$ 矩阵，会 MLE，注意到最终答案就是矩阵 $\begin{bmatrix}0&0&1\end{bmatrix}$ 乘上此处的 $tag$，所以不妨只维护 $tag$。还要将存矩阵的数组开 int。

P.s.  
循环展开的优化非常显著（虽然这题不卡矩阵时间常数）。  
[11.62s](https://www.luogu.com.cn/record/174042332) $\rightarrow$ [5.91s](https://www.luogu.com.cn/record/174045041)
```cpp
#include<cstdio>
#define ll long long
using namespace std;
void rd(){}
template<typename T,typename... U> void rd(T &x,U&... arg){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	x*=f;rd(arg...);
}
const int maxn=5e5+5,P=998244353;
struct edge{int v,prev;}E[maxn<<1];
int N,Q,head[maxn],cnt;
void add(int u,int v){E[++cnt]={v,head[u]};head[u]=cnt;}
ll f[maxn][2];int dfn[maxn],sz[maxn];
void dfs(int u,int fa){
	f[u][1]=1,f[u][0]=0,dfn[u]=++dfn[0],sz[u]=1;
	for(int i=head[u],v=E[i].v;i;v=E[i=E[i].prev].v){
		if(v==fa) continue;
		dfs(v,u);sz[u]+=sz[v];
		(f[u][0]+=f[v][0]+f[v][1])%=P;
		(f[u][1]*=(f[v][0]+f[v][1]+1))%=P;
	}
}
struct Matrix{
	int a[3][3],n,m;
	Matrix(int __n=3,int __m=3,bool isI=1){
		n=__n,m=__m;
		a[0][0]=a[0][1]=a[0][2]=
		a[1][0]=a[1][1]=a[1][2]=
		a[2][0]=a[2][1]=a[2][2]=0;
		if(isI) for(int i=0;i<n;i++) a[i][i]=1;
	}
	friend Matrix operator*(Matrix x,Matrix y){
		Matrix z(x.n,y.m,0);
		z.a[0][0]=(1LL*x.a[0][0]*y.a[0][0]+1LL*x.a[0][1]*y.a[1][0]+1LL*x.a[0][2]*y.a[2][0])%P;
		z.a[0][1]=(1LL*x.a[0][0]*y.a[0][1]+1LL*x.a[0][1]*y.a[1][1]+1LL*x.a[0][2]*y.a[2][1])%P;
		z.a[0][2]=(1LL*x.a[0][0]*y.a[0][2]+1LL*x.a[0][1]*y.a[1][2]+1LL*x.a[0][2]*y.a[2][2])%P;
		z.a[1][0]=(1LL*x.a[1][0]*y.a[0][0]+1LL*x.a[1][1]*y.a[1][0]+1LL*x.a[1][2]*y.a[2][0])%P;
		z.a[1][1]=(1LL*x.a[1][0]*y.a[0][1]+1LL*x.a[1][1]*y.a[1][1]+1LL*x.a[1][2]*y.a[2][1])%P;
		z.a[1][2]=(1LL*x.a[1][0]*y.a[0][2]+1LL*x.a[1][1]*y.a[1][2]+1LL*x.a[1][2]*y.a[2][2])%P;
		z.a[2][0]=(1LL*x.a[2][0]*y.a[0][0]+1LL*x.a[2][1]*y.a[1][0]+1LL*x.a[2][2]*y.a[2][0])%P;
		z.a[2][1]=(1LL*x.a[2][0]*y.a[0][1]+1LL*x.a[2][1]*y.a[1][1]+1LL*x.a[2][2]*y.a[2][1])%P;
		z.a[2][2]=(1LL*x.a[2][0]*y.a[0][2]+1LL*x.a[2][1]*y.a[1][2]+1LL*x.a[2][2]*y.a[2][2])%P;
		return z;
	}
	friend bool operator!=(Matrix x,Matrix y){
		return x.a[0][0]!=y.a[0][0]||x.a[0][1]!=y.a[0][1]||x.a[0][2]!=y.a[0][2]||
		x.a[1][0]!=y.a[1][0]||x.a[1][1]!=y.a[1][1]||x.a[1][2]!=y.a[1][2]||
		x.a[2][0]!=y.a[2][0]||x.a[2][1]!=y.a[2][1]||x.a[2][2]!=y.a[2][2];
	}
};
#define ls i*2
#define rs i*2+1
Matrix t[maxn<<2];
void addtag(int i,Matrix tag){t[i]=t[i]*tag;}
void pushdown(int i){
	if(t[i]!=Matrix())
		addtag(ls,t[i]),
		addtag(rs,t[i]),
		t[i]=Matrix();
}
int L,R;Matrix tag;
void update(int i=1,int l=1,int r=N){
	if(L>R) return;
	if(l>=L&&r<=R) return addtag(i,tag);
	pushdown(i);int mid=(l+r)>>1;
	if(L<=mid) update(ls,l,mid);
	if(R>mid) update(rs,mid+1,r);
}
ll query(int p,int i=1,int l=1,int r=N){
	if(l==r) return (t[i].a[2][0]+t[i].a[2][1])%P;
	pushdown(i);int mid=(l+r)>>1;
	if(p<=mid) return query(p,ls,l,mid);
	return query(p,rs,mid+1,r);
}
#undef ls
#undef rs
void __dfs(int u,int fa){
	for(int i=head[u];i;i=E[i].prev)
		if(E[i].v^fa) __dfs(E[i].v,u);
	Matrix k(3,3,0);
	k.a[0][0]=k.a[0][1]=
	k.a[1][0]=k.a[1][1]=
	k.a[2][1]=k.a[2][2]=1;
	tag=k;L=dfn[u]+1,R=dfn[u]+sz[u]-1;update();
	for(int i=head[u],v=E[i].v;i;v=E[i=E[i].prev].v){
		if(v==fa) continue;
		k=Matrix(3,3,0);
		k.a[0][0]=k.a[2][2]=1;
		k.a[2][0]=f[v][0]+f[v][1];
		k.a[1][1]=k.a[2][0]+1;
		tag=k;L=dfn[u]+1,R=dfn[v]-1;update();
		L=dfn[v]+sz[v],R=dfn[u]+sz[u]-1;update();
	}
}
int main(){
	rd(N);
	for(int i=1;i<N;i++){
		int u,v;rd(u,v);
		add(u,v),add(v,u);
	}
	dfs(1,0);__dfs(1,0);
	rd(Q);
	while(Q--){
		int x;rd(x);
		printf("%lld\n",query(dfn[x]));
	}
	return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：4)

建议评蓝，很有意思的题目。
## solve
很明显树上动态规划。设 $dp_u$ 为以 $u$ 为根的子树答案的数量。

可以分为选 $u$ 和不选两种情况，不选的话 $u$ 的子树只能选其中一棵。$v$ 是 $u$ 的儿子们，那么有 $dp_u=\sum dp_v$。选的话子树就可以随便选了，显然相乘 $dp_u=\prod (dp_v+1)$，加一是因为子树 $v$ 可以啥也不选。

如此一来就是一个 $O(n^2)$ 的做法了。

我们考虑把子树 $u$ 删除，那么我们会把从 $u$ 到 $1$ 的这条链全部更新。可以推一些式子。

假设现在已经将这条链上的 $x$ 更新完了，那么我们要更新他的父亲 $u$，假设 $x$ 被减去了 $a$。计算一下可以得到 $u$ 被减去的部分是 $a\times(1+\frac{\prod(f_v+1)}{f_x+1})$。那么子树 $u$ 删除后减去的部分就是 $dp_u$ 乘上，$u$ 的所有祖先的 $\prod(1+\frac{\prod(f_v+1)}{f_x+1})$。这个 $\prod(1+\frac{\prod(f_v+1)}{f_x+1})$ 是显然可以前缀积预处理出来的，所以我们就不需要维护真实的 $1$ 到 $u$ 的 $dp_u$ 了，只需要知道答案减去了多少就行了，询问时再乘上 $dp_u$ 即可。
## code
可爱的代码。注意里面需要把选 $u$ 和不选分开记录，因为求这个 $\prod(1+\frac{\prod(f_v+1)}{f_x+1})$ 要用。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int nn=5e5+5,mod=998244353;
int n,m,nxt[nn*2],head[nn],cnt,dp1[nn],xi[nn],dp2[nn],f[nn];
struct node{
	int u,v;
}e[nn*2];
inline void add(int u,int v){
	cnt++;
	nxt[cnt]=head[u],head[u]=cnt;
	e[cnt].u=u,e[cnt].v=v;
}
inline void dfs(int u,int fa){
	int times=1,sum=0;
	for(int i=head[u];i;i=nxt[i]){
		int v=e[i].v;
		if(v!=fa){
			dfs(v,u);
			times*=((dp1[v]+dp2[v]+1)%mod);
			times%=mod;
			sum+=((dp1[v]+dp2[v])%mod);
			sum%=mod;
		}
	}
	dp1[u]=times,dp2[u]=sum;
} 
inline int poww(int x,int y){
	if(y==0) return 1;
	int g=poww(x,y/2);
	if(y%2==0) return g*g%mod;
	return g*g%mod*x%mod;
}
inline void dfsc(int u,int fa){
	f[u]=(f[fa]*((dp1[fa]*poww((dp1[u]+dp2[u]+1)%mod,mod-2)%mod+1)%mod))%mod;
	if(u==1) f[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		int v=e[i].v;
		if(v!=fa) dfsc(v,u);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v),add(v,u);
	}
	dfs(1,0);
	dfsc(1,0);
	int mzhxi=dp1[1]+dp2[1];//膜拜mzh 西葫芦大佬
	cin>>m;
	for(int i=1;i<=m;i++){
		int u;
		cin>>u;
		int sl=dp1[u]+dp2[u];
		int ans=(mzhxi-sl*f[u]%mod+mod)%mod;
		cout<<ans<<endl;
	}
	return 0;
}
```
时间复杂度 $O(n\log n)$，瓶颈在于求逆元。

---

## 作者：隔壁泞2的如心 (赞：3)

本题解为 Anoshag_Ruwan 所写，只是为了方便，由我代投（

首先考虑求出整棵树的方案数，因为某一子树内的虚树形态对父节点而言不重要，使用树形 dp 经典思路：令 $dp_i$ 表示以 $i$ 为根的方案，然后对于每一个点，考虑它选或不选分别的贡献：如果这个点选了，那么它的不同子树方案可以自由组合，而如果它没有选，那么它的不同子树方案就是互斥的，因为它们的 $\text{LCA}$ 没选。二者分别对应乘法和加法原理，然后加起来即可。
 
 $dp_i=\prod(dp_{son_i}+1)+\sum{dp_{son_i}}$
 
 求出整棵树后，面临删子树的询问，你发现每个节点的 $dp$ 值显然只会对其祖先有影响。~~于是自信地从该节点往上修改到根，获得了 $30$ 分的好成绩~~。而观察上式,发现 $dp_i$ 对 $dp_{f_i}$ 的贡献正好是 $dp_i \times (\prod(dp_{bro_i}+1)+1)$（$bro_i$ 指 $i$ 的兄弟节点），该因子可在处理父节点时同时维护，所以我们可以使用前缀积，$O(n)$ 处理出每个节点的 $dp_i$ 对根的贡献 $g_i$，询问时输出 $dp_1-dp_i \times g_i$ 即可。
 
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long p=998244353,f[500011],hd[500011],nt[1000011],cnt=0,b[1000011],m=1,dp[500001][4];
inline long long add(long long x,long long y){return x+y>=p?x+y-p:x+y;}
inline void addln(long long x,long long y){
	nt[++m]=hd[x],b[m]=y,hd[x]=m;
	nt[++m]=hd[y],b[m]=x,hd[y]=m;}
inline long long ksm(long long x,long long y){
	long long k=1,l=x;
	while(y){if(y&1)k=k*l%p;l=l*l%p,y>>=1;}
	return k;
}
inline long long rd(){
	long long i=0,j=1;char g=getchar();
	while(g>57||g<48){if(g=='-')j=-1;g=getchar();}
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i*j;
}
inline void dfs(long long x,long long y){
	cnt++;f[x]=y;
	for(int i=hd[x];i;i=nt[i])if(b[i]!=y){
		dfs(b[i],x);
		dp[x][1]=dp[x][1]*(dp[b[i]][2]+1)%p,dp[x][0]=add(dp[x][0],dp[b[i]][2]);
	}dp[x][2]=add(dp[x][1],dp[x][0]);
	for(int i=hd[x];i;i=nt[i])if(b[i]!=y)
		dp[b[i]][3]=(dp[x][1]*ksm(dp[b[i]][2]+1,p-2)+1)%p; 
}
inline void dfs1(long long x,long long y){
	if(y>1)dp[x][3]=dp[x][3]*dp[y][3]%p;
	for(int i=hd[x];i;i=nt[i])
		if(b[i]!=y)dfs1(b[i],x);
}
inline void sol(){
	long long i,j,k,n=rd(),q,ans,u,v,t;m=1;
	for(i=1,dp[n][1]=1;i<n;i++){
		dp[i][1]=1;
		u=rd(),v=rd();addln(u,v);}dfs(1,0);
	dfs1(1,0);t=rd();
	while(t--){q=rd();
		ans=q==1?0:add(dp[1][2],p-dp[q][3]*dp[q][2]%p);
		printf("%lld\n",ans);
	}
}
int main()
{	sol();
	return 0;
}
```

---

## 作者：block_in_mc (赞：3)

## 解题思路

我们可以先求出初始时这棵树的好的非空子集的数量。考虑树上 DP，定义 $dp_{i,0/1}$ 为以 $i$ 为根节点的子树的好的非空子集的数量，其中不选或者选节点 $i$。下面用 $dp_i$ 代表 $dp_{i,0}+dp_{i,1}$，分为两种情况考虑：

- 选择 $dp_i$，这时可以在 $i$ 的每一棵子树上任意选择（包括不选择任何节点），即：

$$dp_{i,1}=\prod\limits_{i\to j}(dp_j+1)$$

- 不选择 $dp_i$，这时可以在 $i$ 的一颗子树上任意选择（不能不选），即：

$$dp_{i,0}=\sum\limits_{i\to j}dp_j$$

暴力做法为对于每一次询问，都进行一遍 DP，时间复杂度 $O(nm)$，考虑进行优化：

考虑当节点 $i$ 的某个儿子 $a$的贡献减少了 $k$ 时，节点 $i$ 答案的减少量：设 $a,b,c,\cdots$ 是 $i$ 的每个子节点的两个 $dp$ 值之和，$a'=a+1,b'=b+1,\cdots$。

$dp_{i,0}$ 原来是 $a+b+c+\cdots$，变为 $a-k+b+c+\cdots$，减少了 $m$；$dp_{i,1}$ 原来为 $a'b'c'\cdots$，变为 $(a'-k)b'c'\cdots=a'b'c'\cdots-kb'c'\cdots$，减少了 $kb'c'\cdots=k\times\dfrac{dp_{i,1}}{a+1}$，共减少了 $k\times(\dfrac{dp_{i,1}}{a+1}+1)$。

对节点 $p$ 进行操作时，节点 $p$ 的答案减少了 $dp_p$（即变为 $0$），则 $p$ 的父节点 $f_p$ 的答案减少量可以依次乘上 $\dfrac{dp_{f_p,1}}{dp_p+1}+1$ 推出。

不难发现，对于每一个节点 $j$ 及其父节点 $i$，$\dfrac{dp_{i,1}}{dp_j+1}+1$ 均为一个定值，因此我们可以求出每个节点到根节点 $1$ 经过的节点的这个式子的积即**树上前缀积**再乘上 $dp_p$ 来求出最终的答案。

对于除法，可以使用逆元求解，且要注意取模问题。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;
const int N = 500100, P = 998244353;
struct node { ll mul, add; } dp[N], f[N];
int n, m, x, y, id, faa[N], sum[N];
vector<int> g[N];
ll fpow(ll a, ll b) {
	if (b == 0) return 1;
	ll tmp = fpow(a, b / 2);
	if (b % 2 == 0) return (tmp * tmp) % P;
	else return (a * ((tmp * tmp) % P)) % P;
}
void dfs1(int p, int fa) {
	faa[p] = fa;
	dp[p].mul = 1, dp[p].add = 0;
	for (int i = 0; i < g[p].size(); i++) {
		int ed = g[p][i];
		if (ed == fa) continue;
		dfs1(ed, p);
		ll v = (dp[ed].add + dp[ed].mul)%P;
		dp[p].add = (dp[p].add + v) % P, dp[p].mul = (dp[p].mul * ((v + 1)%P)) % P;
	}
}
void dfs2(int p, int fa) {
	if (p != 1) sum[p] = (sum[fa] * (dp[fa].mul * (fpow((dp[p].add + dp[p].mul + 1)%P, P - 2)%P) % P + 1) % P) % P;
	for (int i = 0; i < g[p].size(); i++) {
		int ed = g[p][i];
		if (ed == fa) continue;
		dfs2(ed, p);
	}
}
signed main() {
	scanf("%lld", &n);
	for (int i = 1; i < n; i++) {
		scanf("%lld%lld", &x, &y);
		g[x].push_back(y);
		g[y].push_back(x); 
	}
	dfs1(1, 0);
	sum[1] = 1;
	dfs2(1, 0);
	scanf("%lld", &m);
	for (int i = 1; i <= m; i++) {
		scanf("%lld", &id);
		printf("%lld\n", (((dp[1].add + dp[1].mul) % P - (((dp[id].add + dp[id].mul) % P * sum[id]) % P)) % P + P) % P);
	}
    return 0;
}
```

---

## 作者：YQsunny (赞：3)

# 虚树

### 题目大意

给出一棵树，设点集为 $S$。

$S$ 的一个非空点集 $s$ 满足条件当且仅当 $\forall i,j∈s,\operatorname{LCA}(i,j)\in s$。

有多次询问，每次询问切除一棵子树，求剩下的树中所有满足条件的非空子集的方案数。

  把这个题换成人话就是选出来一些点，对于任意的两个点，它们的 $\operatorname{LCA}$ 也在这些选出来的点里面，求其方案数。

### 设计状态
  
  碰到这种树上计数问题，首先就想到树形 dp 来求解。
  
  不难想到状态需要枚举 $\operatorname{LCA}$ 来实现，发现在统计以节点 $i$ 为根的子树时，在节点 $i$ 的不同的子树中的两个点，都是以节点 $i$ 为 $\operatorname{LCA}$ 的，而在相同子树内的两个点，那么便可以递归到它们的 $\operatorname{LCA}$ 接着求解。
  
  所以用 $f_i$ 表示以 $i$ 为根的子树中满足条件的方案数。

### 初始化

  首先来看题目中有 $\operatorname{LCA}$，那么就肯定与 $\operatorname{LCA}$ 有关。（~~这不是废话吗~~）
  
  那么考虑如何不重不漏的统计一个节点的方案数。

  注意到每个点只有两种状态（选或不选），那么处理到节点 $i$ 的时候，完全可以将这两种状态分别计入答案。
  
  每个点单独选出来便是一个答案，那么每个节点初始方案数为 $1$。

### 状态转移

#### 不选的情况

容易发现当不选节点 $i$ 时，在 $i$ 的不同子树的答案是永远不能合并的，因为 $i$ 的不同子树内的两个点，他们的 $\operatorname{LCA}$ 永远是 $i$。

如果不选这个节点，强行选择不同子树内的两个点，那么就不满足它们的 最近公共祖先在点集里了，所以只需要将每个子树内的方案数相加即可。

用 $\operatorname{son}_i$ 表示节点 $i$ 的儿子。

所以有 $f_i = \sum_{to\in\operatorname{son}_i} f_{to}$。

这部分代码如下。

```cpp
void dfs(int x,int fa){
	f[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==fa)
		continue;
		dfs(to,x);
		f[x]+=f[to];
	}	
}
```


#### 选的情况

当选择节点 $i$ 时，那么就需要合并节点 $i$ 的不同子树内的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/lpxh36q9.png)

因为已经选了 $i$ 这个点，所以任意几棵子树的答案都是可以合并的，如上图，根据乘法原理和加法原理，节点 $i$ 有三棵分别以 $a,b,c$ 为根的子树，那么 $f_a , f_b, f_c , f_a \times f_b,f_a \times f_c ,f_b \times f_c ,f_a \times f_b \times f_c$ 都应该作为答案累计计入 $f_i$ 中。


我们发现如果这样算的话，算一个节点的时间复杂度是 $\mathcal{O(n^2)}$，需要找出一个 $\mathcal{O(1)}$ 的式子来计算。

假设有四个节点 $a,b,c,d$，不难发现它们的方案数其实就是 $(f_a+1)(f_b+1)(f_c+1)(f_d+1)-1$。

所以有 $f_i = \prod_{to\in \operatorname{son}_i}^{} \ (f_{to}+1)-1$。

这部分代码如下。

```
void dfs(int x,int fa){
	f[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==fa)
		continue;
		dfs(to,x);
		f[x]*=(f[to]+1);
	}
	f[x]--;	
}
```

最后整理一下式子。
$$
f_i = \prod_{to\in \operatorname{son}_i}(f_{to}+1)+ \sum_{to\in \operatorname{son}_i}f_{to} 
$$

暴力代码，每次更改时将切掉的子树打上标记，不去经过它，然后重新求一遍答案。

### 代码

#### 30pts

```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
#define int long long 
const int N=5e5+10,mod=998244353,inf=1e9;
int n,m,f[N],fa[N],head[N],pos=0;
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
struct mm{
	int to,next;
}e[2*N];
bool vis[N];
void add(int x,int y){
	pos++;
	e[pos].to=y;
	e[pos].next=head[x];
	head[x]=pos;
}
void dfs(int x,int ff){
	fa[x]=ff;
	int anss=1;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==ff||vis[to])
		continue;
		dfs(to,x);
		f[x]+=f[to];//当不选i这个点是统计的答案 
		anss*=(f[to]+1);
		anss%=mod;
		f[x]%=mod;
	}
	f[x]+=anss;
	f[x]=(f[x]+mod)%mod;
}
signed main(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	m=read();
	for(int i=1;i<=m;i++){
		int x=read();
		for(int j=1;j<=n;j++)
		f[j]=1;
		vis[x]=1;
		dfs(1,0);
		cout<<f[1]<<endl;
		vis[x]=0;
	}
	return 0;
} 
```

时间复杂度为 $\mathcal{O(nm)}$。

#### 100pts

发现要想不超时，那么就必须预处理某些东西来降低时间复杂度。

考虑每个节点 $u$ 对于它的父亲 $i$ 的贡献为
$$
f_u  \times (\prod_{to\in \operatorname{bro}_{u}}^{} \ (f_{to}+1) +1 ) 
$$

（$\operatorname{bro}_{u}$ 为节点 $u$ 的兄弟节点）。


这部分代码如下。


```
void dfs(int x,int fa){
	sum[x]=1;//连乘数组 
	int anss=1;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==fa)
		continue;
		dfs(to,x);
		sum[x]=(sum[x]*(f[to]+1))%mod;
	}
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to; 
		if(e[i].to!=fa){
			int to=e[i].to;
			g[to]=(sum[x]*ksm(f[to]+1,mod-2)+1)%mod;
		}
	} 
}
```

$g_{i}$ 表示节点 $i$ 对于父亲的贡献，那么接下来只需要一个前缀积便可 $\mathcal{O(1)}$ 计算出答案，那么假设切掉以节点 $u$ 为根的子树，答案即为 $f_{u} - f_x \times g_{u}$。

时间复杂度为 $\mathcal{O(n+m)}$。

代码如下。


```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
#define int long long 
const int N=5e5+10,mod=998244353,inf=1e9;
int n,m,f[N],fa[N],head[N],pos=0,g[N],sum[N];
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
struct mm{
	int to,next;
}e[2*N];
int ksm(int x,int b){
	int anss=1;
	while(b){
		if(b&1)
		anss*=x,anss%=mod;
		b>>=1;
		x*=x;
		x%=mod;
	}
	return anss;
}
void add(int x,int y){
	pos++;
	e[pos].to=y;
	e[pos].next=head[x];
	head[x]=pos;
}
void dfs(int x,int ff){
	fa[x]=ff;
	sum[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==ff)
		continue;
		dfs(to,x);
		f[x]+=f[to];
		sum[x]=(sum[x]*(f[to]+1))%mod;;
		f[x]%=mod;
	}
	f[x]+=sum[x];
	f[x]=(f[x]+mod)%mod;
	for(int i=head[x];i;i=e[i].next)
	if(e[i].to!=ff){
		int to=e[i].to;
		g[to]=(sum[x]*ksm(f[to]+1,mod-2)+1)%mod;
	}
	
}

void dfs2(int x){
	if(x>1)
	g[x]=g[x]*g[fa[x]]%mod;
	for(int i=head[x];i;i=e[i].next){
		int to=e[i].to;
		if(to==fa[x])
		continue;
		dfs2(to);
	}
}//求出前缀积
signed main(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	m=read();
	g[1]=1;
	dfs(1,0);
	dfs2(1);
	for(int i=1;i<=m;i++){
		int xx=read();
		cout<<(f[1]-g[xx]*f[xx]%mod+mod)%mod<<endl;
	}
	return 0;
} 
```

感谢 @X____ 为我贴心的更改了题解的排版，@mmr123 为我提供了一张图片。

---

## 作者：Phoenix_2010 (赞：3)

昨天晚上从 8 点写到 11 点，$\texttt{AC}$ 了（大喜）。于是来写一篇题解。
## 题目大意
求去掉某颗子树后有多少树点集的非空子集 $s$ 满足 $\forall i,j\in s,\operatorname{LCA}(i,j)\in s$。
## 主要思路
首先考虑 $30$ 分的树形 dp。我们设 $dp_i$ 表示以 $i$ 为根的子树中的方案数。

注意到对于 $v_1,v_2,\dots \in \operatorname{subtree}(u)$,$\forall v \in \operatorname{son}(u),\exists v_i \not \in \operatorname{subtree}(v) \Rightarrow \operatorname{LCA}(v_1,v_2,\dots)=u$。

其实就是选一些 $u$ 子树中的点，满足它们不全属于 $u$ 某个儿子的子树，这些点的最近公共祖先是 $u$。

证明就是模拟一下暴力找 $\operatorname{LCA}$ 的过程。

对于 $dp_u$，分两种情况讨论：

**不选$u$**：根据上述结论，只能选一颗子树中的点，答案为 $\sum_{v \in \operatorname{son}(u)} dp_v$。

**选$u$**：此时我们可以选择若干颗子树（可以不选），保证同一子树内合法即可。答案为 $\prod_{v \in son_u}(dp_v+1)$。

综上，
$$
dp_u=(\sum_{v \in \operatorname{son}(u)}dp_v)+(\prod_{v \in \operatorname{son}(u)}(dp_v+1))
$$
特别地，如果 $u$ 是叶子结点，那么 $dp_u=1$。

于是对于每次询问暴力跑一遍，时间复杂度 $O(nm)$。

---

每次询问只会删一颗子树，每次跑一遍太浪费了。我们先求出不删子树时的 $dp$ 值，考虑删掉一颗子树对答案的贡献。

如果删除 $u$ 及其子树，那么
$$
\begin{aligned}

dp_{\operatorname{father}(u)}&=(\sum_{v \in \operatorname{son}(\operatorname{father}(u)),v\not= u} dp_v)+(\prod_{v \in \operatorname{son}(\operatorname{father}(u)),v\not= u}(dp_v+1))\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(u))}dp_v)-dp_u+(\prod_{v \in \operatorname{son}(\operatorname{father}(u))}(dp_v+1))-dp_u\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)}{dp_u+1}\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(u))}dp_v)+(\prod_{v \in \operatorname{son}(\operatorname{father}(u))}(dp_v+1))-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)}{dp_u+1}+1)\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(u))}dp_v)+(\prod_{v \in \operatorname{son}(\operatorname{father}(u))}(dp_v+1))-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)+(dp_u+1)}{dp_u+1})\\

\end{aligned}
$$

再往上跳一下，找找规律：
$$
\begin{aligned} 
dp_{\operatorname{father}(\operatorname{father}(u))}&=(\sum_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u))),v\not=\operatorname{father}(u)}dp_v)+dp_{\operatorname{father}(u)}-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))}(dp_v+1)+(dp_u+1)}{dp_u+1})\\

&+(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u))),{v\not=\operatorname{father}(u)}}(dp_v+1))(dp_{\operatorname{father}(u)}+1-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)+(dp_u+1)}{dp_u+1})\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}dp_v)-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))}(dp_v+1)+(dp_u+1)}{dp_u+1})\\

&+(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}(dp_v+1))-(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u))),{v\not=\operatorname{father}(u)}}(dp_v+1))dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)+(dp_u+1)}{dp_u+1})\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}dp_v)+(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}(dp_v+1))\\

&-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)+(dp_u+1)}{dp_u+1})(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u))),{v\not=\operatorname{father}(u)}}(dp_v+1)+1)\\

&=(\sum_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}dp_v)+(\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u)))}(dp_v+1))\\

&-dp_u(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(u))} (dp_v+1)+(dp_u+1)}{dp_u+1})(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(\operatorname{father}(u))}(dp_v+1)+(dp_{\operatorname{father(u)}}+1)}{dp_{\operatorname{father}(u)}+1})\\

\end{aligned}
$$

建议用草稿纸仿照推 $dp_{\operatorname{father}(u)}$ 的方法自己推一遍。

然后我们发现可以贡献就是
$$
dp_u\prod_{x}(\frac{\prod_{v \in \operatorname{son}(\operatorname{father}(x))}(dp_v+1)+(dp_x+1)}{dp_x+1})
$$
（其中 $x$ 表示节点 $u$ 到根节点路径上的每个点）

可以用树剖+树上前缀和维护。然后用 $dp_1$ 减去这个贡献就是答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5,mod=998244353;
int T,n,m,f[N],hson[N],sz[N],dfn[N],top[N];vector<int> a[N];long long dp[N],s1[N]={1},s2[N],tmp[N],s[N]={1};
//s1[u]表示u的dp值+1，s2[u]表示u子树的dp值+1的乘积
//s[u]表示u的兄弟的dp值+1的乘积加上自己的dp值+1，也就是上面式子的分子
inline long long qpow(long long a,int b){if(!b) return 1;long long ans=qpow(a,b/2);return ans*ans%mod*(b&1?a:1)%mod;}
//求解不删子树时的dp值
inline void dfs1(int u,int fa)
{
    dp[u]=1;f[u]=fa;sz[u]=1;
    for(auto v:a[u]) if(v!=fa) dfs1(v,u),(dp[u]*=(dp[v]+1))%=mod,sz[u]+=sz[v],sz[hson[u]]<sz[v]&&(hson[u]=v);s2[u]=dp[u];
    for(auto v:a[u]) if(v!=fa) (dp[u]+=dp[v])%=mod;
    s1[u]=(dp[u]+1)%mod;
}
inline void dfs2(int u,int t)
{
    top[u]=t;dfn[u]=++T;(s1[u]*=s1[f[u]])%=mod,(s[u]*=s[f[u]])%=mod;//树上前缀和
    if(!hson[u]) return;dfs2(hson[u],t);
    for(auto v:a[u]) if(v!=f[u]&&v!=hson[u]) dfs2(v,v);
}
inline long long solve(int u)
{
    long long ans=dp[u];
    while(top[u]!=1)
    {
        (ans*=s[dfn[u]]*qpow(s[dfn[f[top[u]]]],mod-2)%mod*s1[dfn[f[top[u]]]]%mod*qpow(s1[dfn[u]],mod-2)%mod)%=mod;
        u=f[top[u]];
    }
    (ans*=s[dfn[u]]*qpow(s[1],mod-2)%mod*s1[1]%mod*qpow(s1[dfn[u]],mod-2)%mod)%=mod;
    return ans;
}
int main()
{
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y;scanf("%d%d",&x,&y);
        a[x].push_back(y),a[y].push_back(x);
    }
    dfs1(1,0);for(int i=1;i<=n;i++) s[i]=(s2[f[i]]+s1[i])%mod;
    dfs2(1,1);
    //按照dfn重新对节点编号
    for(int i=1;i<=n;i++) tmp[dfn[i]]=s[i];memcpy(s,tmp,sizeof(s));
    for(int i=1;i<=n;i++) tmp[dfn[i]]=s1[i];memcpy(s1,tmp,sizeof(s1));
    cin>>m;
    while(m--)
    {
        int q;scanf("%d",&q);
        printf("%lld\n",(dp[1]-solve(q)+mod)%mod);
    }
    return 0;
}
```

## 细节
首先就是取模，写得时候一定要仔细一点，少写一个取模都会溢出。~~知道为什么写了那么久了吧~~ 尽量不要像我这样压行，不然写漏了一个取模很难看出来，可以运算一下，模一下，然后换行，比如：

```cpp
//(ans*=s[dfn[u]]*qpow(s[dfn[f[top[u]]]],mod-2)%mod*s1[dfn[f[top[u]]]]%mod*qpow(s1[dfn[u]],mod-2)%mod)%=mod;
(ans*=s[dfn[u]])%=mod;
(ans*=qpow(s[dfn[f[top[u]]]],mod-2))%=mod;
(ans*=s1[dfn[f[top[u]]]])%=mod;
(ans*=qpow(s1[dfn[u]],mod-2))%=mod;
```
然后记得给节点重新编号。

十年 OI 一场空，不开 long long 见祖宗。

---

## 作者：LYY_yyyy (赞：2)

为啥场上想不出来？

朴素的 $n^2$ dp 是比较显然的。考虑让每种虚树以最少的点数来刻画。若有一个点是两个其他点的 LCA，那么这个点可以删去。我们考虑用树形 dp 来统计数量。记 $dp_u$ 表示以 $u$ 为根的子树里的答案。不选 $u$ 的情况下，$u$ 的儿子的子树中可以随便选（可以不选），方案数为 $\prod\limits_ {v\in son(u)} (dp_v+1)-1$。如果选 $u$，那么 $u$ 的儿子子树最多选一个，方案数为 $(\sum\limits_{v\in son(u)} dp_v)+1$。所以有：

$$
dp_u=\prod\limits_{v\in son(u)} (dp_v+1)+\sum\limits_{v\in son(u)} dp_v
$$

之后考虑如何优化。我们发现删除 $x$ 的子树只会影响根到 $x$ 的一根链上的 dp 值，我们试图找出一些式子。若 $u$ 的一个儿子 $x$ 的 dp 值减少了 $w$，设 $u$ 的 dp 值改变成了 $dp'_u$。推式子:

$$
dp_u-dp'_u=\prod\limits_{v\in son(u)} (dp_v+1)-\frac{\prod\limits_{v\in son(u)} (dp_v+1)}{dp_x+1}(dp_x-w+1)+w
$$

$$
=(\prod\limits_{v\in son(u)} (dp_v+1))(\frac{w}{dp_x+1})+w
$$

$$
=w(1+\frac{\prod\limits_{v\in son(u)} (dp_v+1)}{dp_x+1})
$$

我们发现 $dp_u$ 只是减少了 $w$ 乘上一个系数，而这个系数和 $w$ 无关。在具体的修改上，这个系数是一段根到 $x$ 的前缀积，预处理即可。

代码：

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define lowbit(x) (x&(-x))
using namespace std;
int n;
vector<int> g[500010];
int dp[500010],w[500010]; 
const int mod=998244353;
int qpow(int a,int b)
{
	int x=1,y=a;
	while(b)
	{
		if(b&1) x=x*1ll*y%mod;
		y=y*1ll*y%mod;
		b>>=1;
	}
	return x;
}
inline void add(int &x,int y)
{
	x+=y;
	if(x>=mod) x-=mod;
}
void dfs(int now,int fa)
{
	dp[now]=1;
	for(auto to:g[now]) if(to!=fa) dfs(to,now),dp[now]=1ll*dp[now]*(dp[to]+1)%mod;
	for(auto to:g[now]) if(to!=fa) add(dp[now],dp[to]);
}
void dfs1(int now,int fa)
{
	int d=1;
	for(auto to:g[now]) if(to!=fa) d=1ll*d*(dp[to]+1)%mod;
	for(auto to:g[now]) if(to!=fa) w[to]=1ll*w[now]*(1ll*d*qpow(dp[to]+1,mod-2)%mod+1)%mod,dfs1(to,now);
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;int u,v;
	for(int i=1;i<n;i++) cin>>u>>v,g[u].pb(v),g[v].pb(u);
	dfs(1,0);w[1]=1;dfs1(1,0);
	int q;cin>>q;
	while(q--)
	{
		int x;cin>>x;
		cout<<(dp[1]-1ll*dp[x]*w[x]%mod+mod)%mod<<"\n";
	}
	return 0;
}
```

---

## 作者：一只小咕咕 (赞：1)

[**的阅读体验](https://www.cnblogs.com/yzxgg/p/18376361)

树形 dp 好题。
### 题意
给定一棵树，每次询问删去某一子树后的树能形成的虚树数量。虽然题目叫虚树，但确实和虚树没啥关系（
### 思路
拿到这种题，肯定先考虑树形 dp。定义 $f_i$ 为为 $i$ 为根的子树好的非空点集数量，考虑转移，显然在转移时会有选 $i$ 和不选 $i$ 两种情况。

- 不选 $i$，只能从若干子树中选择一棵子树中的点，方案总数为 $\sum_{v\in son} f_v$。
- 选 $i$，子树就可以随便选了，直接相乘得到 $\prod_{v\in son} (f_v+1)$。

这样就可以进行转移了：
$$
f_u=\sum_{v\in son} f_v+\prod_{v\in son} (f_v+1)
$$
现在考虑删除子树，发现本质上就是求删除掉一个点后对根产生的影响。

通过观察上式，注意到 $f_i$ 对 $f_{fa_i}$ 的贡献是 $f_i\times (\prod(f_{bro_i}+1)+1)$，这里 $bro_i$ 指 $i$ 的兄弟节点，后面这个因式可以在转移 $f$ 时同时维护，具体的，把 $\prod_{v\in son} (f_v+1)$ 除掉 $f_i+1$ 即可。

然后我们处理出一个前缀积，计为 $g$，$g_i$ 就表示删掉 $i$ 对根的影响，询问时再乘上 $f_i$ 就行了，输出 $f_1-f_i\times g_i$。

复杂度 $\mathcal{O(n \log n)}$，$\log$ 是求逆元带的，注意开 `long long` 和一步一模防止爆炸。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5;
const int mod=998244353;
inline int read();
int n,m,head[N],cnt;
int f[N],g[N]; 
struct node{
	int to,next;
}edge[N<<1];
void add(int u,int v)
{
	edge[++cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans=a*ans%mod;
		a=a*a%mod;
		b>>=1; 
	}
	return ans;
}
void dfs1(int x,int fa)
{
	int pro=1,sum=0;
	for(int i=head[x];i;i=edge[i].next)
	{
		int to=edge[i].to;
		if(to==fa) continue;
		dfs1(to,x);
		pro=pro*(f[to]+1)%mod;
		sum=sum+f[to]%mod;
	}
	f[x]=pro+sum%mod;
	for(int i=head[x];i;i=edge[i].next)
	{
		int to=edge[i].to;
		g[to]=(pro*ksm(f[to]+1,mod-2)+1)%mod; 
	}
}
void dfs2(int x,int fa)
{
	for(int i=head[x];i;i=edge[i].next)
	{
		int to=edge[i].to;
		if(to==fa) continue;
		if(x!=1) g[to]=g[x]*g[to]%mod;
		dfs2(to,x);
	}
} 
signed main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int x,y;
		x=read();y=read();
		add(x,y);
		add(y,x);
	}
	dfs1(1,0);
	dfs2(1,0);
	m=read();
	while(m--)
	{
		int x;
		x=read();
		printf("%lld\n",(f[1]-(f[x]*g[x]%mod)+mod)%mod);
	}
	return 0;
}

inline int read()
{
	int x=0,f=1;
	char ch;
	ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-') f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')
	{
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
    return x*f;
}
```

---

## 作者：RAND_MAX (赞：0)

（本人于赛时“自信地从该节点往上修改到根，获得了 30 分的好成绩”，望周知）

一道树形 DP 好题。\
我们设 $f_i$ 为以 $i$ 为根的子树好的非空点集数量，考虑如何进行转移。为了叙述简便，下文称“好的非空点集”为“合法点集”，$fa(i)$ 为 $i$ 的父节点，$bro(i)$ 为 $i$ 的兄弟节点，$son(i)$ 为 $i$ 的子节点。\
我们考虑枚举节点 $i$ 选或者不选。如果选节点 $i$，那么任意以节点 $i$ 的儿子为根的子树中的合法点集都可以自由组合，有贡献 $\prod_{j\in son(i)}(f_j+1)$，加一是因为可以不选。若是不选节点 $i$，那么只能在单个子树内选且必须选，有贡献 $\sum_{j\in son(i)}f_j$。\
将以上两种情况结合起来就可以得到 $f_i$ 的转移式子 $f_i=\prod_{j\in son(i)}(f_j+1)+\sum_{j\in son(i)}f_j$。

对于删除子树操作，由于每个节点只会对它的祖先产生贡献，一个比较 naive 的想法是从被删的子树往上改到根节点，但我们发现会被卡成 30 分的高分，这与暴力 $O(n^2)$ 相比多了高达 0 分！\
再考虑如何处理每一个节点对根节点的贡献。我们注意到 $f_{fa(i)}=(f_i+1)\times \prod_{j\in bro(i)}(f_j+1)+\sum_{j\in bro(i)}f_j+f_i=f_i\times (\prod_{j\in bro(i)}(f_j+1)+1)+\prod_{j\in bro(i)}(f_j+1)+1+\sum_{j\in bro(i)}f_j$。\
也就是说，对于一个节点 $i(i\ne 1)$，它对 $fa(i)$ 的贡献是 $\prod_{j\in bro(i)}(f_j+1)+1$。这可以运用前缀积的思想从根到 $i$ 处理出节点 $i$ 对根节点的贡献 $p_i$，最终答案即为 $f_1-f_i\times p_i$。


```cpp
#include<bits/stdc++.h>
#define R read()
#define int long long
#define mod 998244353
using namespace std;
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-') 
		{
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9') 
	{
		x=(x<<1)+(x<<3)+c-48;
		c=getchar();
	}
	return x*f;
}
void write(int x)
{
	static int st[35],top=0;
	if(x<0)
	{
		x=-x;
		putchar('-');
	}
	do
	{
		st[top++]=x%10;
		x/=10;
	}while(x);
	while(top)
	{
		putchar(st[--top]+48);
	}
	puts("");
}
int n,fa[500010],q,f[500010],sum[500010],qe,kk,inv[500010],ans[500010],num[500010],p[500010];
vector<int>g[500010];
int qpow(int x,int y)
{
	int num=1;
	while(y)
	{
		if(y&1) 
		{
			num=num*x%mod;
		}
		x=x*x%mod;
        y>>=1;
    }
    return num%mod;
}
void dfs(int x,int ff)
{
	num[x]=1;
	f[x]=0;
	fa[x]=ff;
	for(int i:g[x])
	{
		if(i==ff)
		{
			continue;
		}
		dfs(i,x);
		num[x]*=(f[i]+1)%mod;
		num[x]%=mod;
		sum[x]+=f[i]%mod;
		sum[x]+=mod;
	}
	f[x]=f[x]+sum[x]%mod;
	f[x]%=mod;
	f[x]+=num[x];
	f[x]%=mod;
	inv[x]=qpow(f[x]+1,mod-2)%mod;
}
void dfs1(int x)
{
	if(!p[x])
	{	
		p[x]=p[fa[x]]*(num[fa[x]]*inv[x]%mod+1)%mod;
		p[x]%=mod;
	}
	for(int i:g[x])
	{
		if(i==fa[x])
		{
			continue;
		}
		dfs1(i);
	}
}
signed main()
{
	n=R;
	for(int i=1,x,y;i<n;i++)
	{
		x=R,y=R;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(1,0);
	p[1]=1;
	dfs1(1);
	q=R;
	while(q--)
	{
		qe=R;
		write((f[1]-(f[qe]*p[qe])%mod+mod)%mod);
	}
 	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：0)

dp，$f_u$ 表示 $u$ 子树的虚树个数，考虑 $u$ 是否在虚树中显然有转移 $f_u = \prod\limits_{v \in \operatorname{son}(u)} (f_v + 1) + \sum\limits_{v \in \operatorname{son}(u)} f_v$。

考虑删子树 $u$，即考虑将 $f_u\gets 0$ 对 $f_1$ 的变化。

令 $k_v f_v + b_v = f_u$。易知 $k_v = \prod\limits_{v' \in \operatorname{son}(u)\backslash v}(f_{v'}+1) +1, b_v =\prod\limits_{v' \in \operatorname{son}(u)\backslash v}(f_{v'}+1) + \sum\limits_{v' \in \operatorname{son}(u)\backslash v}g_{v'}$。

再做一次自顶向下的递推（事实上是一次函数迭代）即可得到 $k'_v,b'_v$ 使 $k'_v f_v + b'_v = f_1$。

复杂度 $O(n)$。

---

## 作者：wxzzzz (赞：0)

### 思路

对整棵树先 DP 一遍。

若不选 $x$，则可选任意一个 $x$ 的子节点 $y$ 子树内的答案，而不可选多棵子树，因为它们的 LCA 是 $x$；若选 $x$，则可任意选所有 $y$ 子树内的答案。

设 $f_x$ 表示 $x$ 子树内的虚数子集数，有：

$$f_x=\prod_{y\in son(x)}(f_y+1)+\sum_{y\in son(x)}f_y$$

然后考虑删子树。

发现删 $x$ 只会影响 $x$ 到根路径，考虑实现如下代码：

```cpp
int x;
cin >> x;
int p = x, ans, tans;

while (ft[p]) {
    ans = 1;
    ans = g[ft[p]];
    ans = mod(ans * exgcd(f[p] + 1, MOD).first);

    if (p != x)
        ans = mod(ans * (tans + 1));

    ans = mod(ans + s[ft[p]]);
    ans = mod(ans - f[p] + MOD);

    if (p != x)
        ans = mod(ans + tans);

    p = ft[p];
    tans = ans;
}

cout << ans << '\n';
```

发现上面代码中的 $ans$ 可以形式化（$ft_x$ 表示 $x$ 的父亲）：

$$ans=f_x\prod_{p\in\{x\to 1\}}\Big(\prod_{y,x\notin T(y)}(f_y+1)+1\Big)$$

计算上式的瓶颈是一个从根到 $x$ 的前缀积，可预处理： 

$$h_x=\prod_{y\in son(ft_x),y\ne x}(f_y+1)+1$$

最终答案即为 $f_1-f_xh_x$。

### 代码

```cpp
#include <bits/stdc++.h>
#define MOD 998244353
using namespace std;
long long mod(long long x) {
    return x % MOD;
}
pair<long long, long long> exgcd(long long a, long long b) {
    if (!b)
        return {1, 0};

    pair<long long, long long> t = exgcd(b, a % b);

    long long x = t.first, y = t.second;

    return {y, mod(mod(x - a / b * y) + MOD)};
}
int n, m, ft[500005];
long long f[500005], g[500005], h[500005], s[500005];
vector<int> e[500005];
void add(int x, int y) {
    e[x].push_back(y);
}
void dfs1(int x, int F) {
    g[x] = 1;

    for (int y : e[x]) {
        if (y == F)
            continue;

        ft[y] = x;
        dfs1(y, x);
        s[x] = mod(s[x] + f[y]);
        g[x] = mod(g[x] * (f[y] + 1));
    }

    f[x] = mod(g[x] + s[x]);

    for (int y : e[x])
        h[y] = mod(g[x] * exgcd(f[y] + 1, MOD).first + 1);
}
void dfs2(int x, int F) {
    for (int y : e[x]) {
        if (y == F)
            continue;

        if (x != 1)
            h[y] = mod(h[y] * h[x]);

        dfs2(y, x);
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);

    cin >> n;

    for (int i = 1, x, y; i < n; i++) {
        cin >> x >> y;
        add(x, y), add(y, x);
    }

    dfs1(1, 0);
    dfs2(1, 0);
    cin >> m;

    while (m--) {
        int x;
        cin >> x;
        cout << mod(mod(f[1] - h[x]*f[x]) + MOD) << '\n';
    }

    return 0;
}
```

---


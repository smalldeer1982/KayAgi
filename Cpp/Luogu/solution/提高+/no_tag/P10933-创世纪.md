# 创世纪

## 题目描述

上帝手中有 $N$ 种世界元素，每种元素可以限制另外 $1$ 种元素，把第 $i$ 种世界元素能够限制的那种世界元素记为 $A[i]$。

现在，上帝要把它们中的一部分投放到一个新的空间中去建造世界。

为了世界的和平与安宁，上帝希望所有被投放的世界元素都至少有一个能够限制它的世界元素没有被投放。

上帝希望知道，在此前提下，他最多可以投放多少种世界元素？

## 说明/提示

数据保证，$1\le N \le 10^6$，$1 \le A[i] \le N$

## 样例 #1

### 输入

```
6
2 3 1 3 6 5```

### 输出

```
3```

# 题解

## 作者：mxjz666 (赞：11)

### 思路
本题如果将 $i$ 向 $a_i$ 连边，那么就成了基环树内向树森林，不好处理，所以我们将 $a_i$ 向 $i$ 连边，这样就成了基环树外向树森林。

考虑某一棵基环树：
先找到环上的一点 $p$ 断掉 $p$ 与 $a_p$ 的连边，这样就成了一棵以 $p$ 为根的树。
接着设 $f_{x,0/1}$ 表示 $x$ 不选/选时，以 $x$ 为根的子树的最多可以投放的个数。
状态转移方程为 $f_{x,0}=\sum\limits_{y \in Son(x)} \max(f_{y,0},f_{y,1})$

$f_{x,1}=1+\max\limits_{y \in Son(x)}\{f_{y,0}+\sum\limits_{z \in Son(x),z\neq y} \max(f_{z,0},f_{z,1})\}$

但其中 $f_{x,1}$ 的转移是可以优化的，进而优化成：

$f_{x,1}=1+f_{x,0}-\min\limits_{y \in Son(x)}\{\max(f_{y,0},f_{y,1})-f_{y,0}\}$

然后，因为这是忽略了 $p$ 可以限制 $a_p$ 这个条件，所以这是我们可以让 $p$ 强制限制 $a_p$ 这样再计算一次。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int bid,h[N],nxt[N],to[N],n,a[N],f[N][2],ans,km;
bool vis[N];
void add(int x,int y){
	to[++bid]=y;
	nxt[bid]=h[x];
	h[x]=bid;
}
int dp(int x,int d){
	f[x][0]=f[x][1]=0;
	vis[x]=1;
	int res=0,c=1e9+7;
	for(int i=h[x];i;i=nxt[i]){
		int y=to[i];
		if(y==km)continue;
		res=dp(y,d);
		c=min(c,res-f[y][0]);
		f[x][0]+=res;
	}
	f[x][1]=f[x][0]-c+1;
	if(d&&x==a[km])f[x][1]+=c;
	return max(f[x][0],f[x][1]);
}
int hjw(int x){
	for(km=x;!vis[a[km]];vis[km]=1)km=a[km];
	int cnt=dp(km,0);
	dp(km,1);
	return max(cnt,f[km][0]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		add(a[i],i);
	}
	for(int i=1;i<=n;i++)if(!vis[i])ans+=hjw(i);
	cout<<ans;
	return 0;
}

```

---

## 作者：Firsry (赞：9)

# P10933 创世纪

本文重点讲解一下思路中比较容易卡顿的位置。状态转移方程[这篇题解](https://www.luogu.com.cn/article/32nzvwri)有着详细的讲解，从推导到优化，这里就不赘述了。

### 反向建边

我们反向建立边，也就是建立 $A_i \rightarrow i$ 的边，表示 $i$ 限制 $A_i$，这样的好处是一棵外向树，每个节点有一个入度和多个出度，符合正常人的习惯。

这还带来一个好处，就是链式前向星不需要开二倍空间了，而在删去边的部分也不用考虑双向边带来的麻烦。

### $A_i$ 式返祖找环

如下图所示，例如我们从 $9$ 号节点开始向上跳，则路径是：
$$
9 \rightarrow 8 \rightarrow 4 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow 5
$$
注意建边是反向建边，返祖就是逆流而上：$p=A_p$ 。我们在返祖的过程中用 $vis$ 数组标记走过的点，则遇到一个标记过的点就是环上的一端，而此时的位置就是另一端。还是很显然的，因为不会经过自己的儿子，所以这一定是一条逆向的返祖边。

这个方法非常高效，不需要遍历整棵树，而且只需要知道 $fat$ 信息就可以了。不过一般不会直接告诉 $fat$ 信息，导致适用范围并不是非常广泛。

![](https://cdn.luogu.com.cn/upload/image_hosting/ot5grv6d.png)

### 基环树处理方式的选择

我们对于基环树的处理无非两种：

1. 删去一条边，当作树进行处理，然后特殊统计删去的边对结果的影响；
2. 分成环上问题以及树上问题（环上节点的子树）。

这个地方显然用第二种是不方便的，这样状态转移方程考虑的非常多。包括子树根节点的选或不选，环上节点的选或不选，以及多种多样的依赖关系。

使用第一种方法就很简单了，因为有“强制”策略的存在。

### 动态规划的强制策略

我们在城市环路中认识了通过赋值为 $-INF$ 做到在状态转移中强制不选取，而这个地方是另一种方法：两次树形动态规划。分别统计依赖非删去边以及依赖删去边。

以上图为例，我们从 $9$ 开始向上找到的环边的两端分别是 $4,5$，我们从 $5$ 开始进行树上动态规划。

1. 依赖非删去边：
   删去边 $4 \rightarrow 5$ 之后，节点 $4$ 不能够依赖于 $5$，结果是选取 $4$ 的情况中，必有 $7,8$ 中的一个不被选取。而这个时候 $5$ 节点是否被选取都不重要，统计答案 $\max(fTree_{5,1},fTree_{5,0})$。
2. 依赖删去边：
   现在 $4$ 的选取一定依赖于 $5$ 的不选取，答案就是 $fTree_{5,0}$，而这个时候 $4$ 的子节点可以任选。

### 删去边的方式

仍然以上图为例：只要一条边指向的 $to$ 节点不是起点 $5$，说明这条边就不是删去边，就可以正常处理。

### 代码

一个小的细节是，`vector<bool>` 有着极大的优化，几乎等同于 `bitset`，非常好用。

```cpp
#include<bits/stdc++.h>

inline int read() {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch))
		x = x * 10 + ch - '0', ch = getchar();
	return x;
}

using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1000005;

int n, ans;
int lt, rt;

int edgeCount;
int head[MAXN], toNode[MAXN], nextEdge[MAXN];

vector<bool> vis;
int control[MAXN];

int fTree[MAXN][2];

inline void addEdge(int from, int to) {
	edgeCount++;
	toNode[edgeCount] = to;
	nextEdge[edgeCount] = head[from];
	head[from] = edgeCount;
	return;
}

int dpTree(int from, bool isDelete) {
	fTree[from][0] = fTree[from][1] = 0;
	vis[from] = true;
	int gap = INF;
	for (int i = head[from]; i; i = nextEdge[i]) {
		int to = toNode[i];
		if (to ^ lt) {
			vis[to] = true;
			int res = dpTree(to, isDelete);
			fTree[from][0] += res;
			gap = min(gap, res - fTree[to][0]);
		}
	}
	fTree[from][1] = fTree[from][0] + 1 - gap;
	if (!isDelete && from == rt)
		fTree[from][1] += gap;
	return max(fTree[from][0], fTree[from][1]);
}

int main() {
	n = read();
	vis.resize(n + 1, false);
	for (int i = 1; i <= n; ++i)
		addEdge(control[i] = read(), i);
	for (int i = 1; i <= n; ++i)
		if (!vis[i]) {
			for (lt = i; !vis[control[lt]]; vis[lt] = true)
				lt = control[lt];
			rt = control[lt];
			int max1 = dpTree(lt, true);
			dpTree(lt, false);
			int max2 = fTree[lt][0];
			ans += max(max1, max2);
		}
	cout << ans;
	return 0;
}
```

### 闲话

本人在校测中使用的方法就是分成环和树，结果打了 $173$ 行代码，刚好多了 $100$ 行，并且直到比赛结束都没能调试成功。使用了骗分大法，输出每棵基环树结点个数的一半，竟然得了 $30$ 分。

---

## 作者：yanmingqian (赞：6)

有点意思。写个萌新向题解。

基环树上的问题，一般是断掉环上的边，然后当作树上问题做。那么我们一步一步来。

# 找环

首先是找环。找环一般用 dfs 或者拓扑，但是这题比较好，我们可以使用稍微简单一些的方式。

## 关于反向边

建边的时候我们要建反向边，也就是 $a_i \rightarrow i$ 建边。这个东西可能乍一看不太好理解，但是我们仔细思考一下（可以画个图），发现题目中每个元素只能限制另外**一种**元素，但是每个元素可以被另外**多种**元素限制。那么如果建正向边的话，最后出来的图就会是叶子指向根的基环树（森林），每个点只会向外伸一条边，但是却可能有多个边指着它。这个不太符合我们直觉，而且不太好看。相反，建反向边的话，限制一个点的元素就会全部在它的子树中，这样 dp 的时候显然是好做的，我们求完一个点的子树中所有点，然后求这个点，非常合理啊！而且，这样删边的时候相比双向边就方便了一些。因此，这题要建反向边。

回到找环上来，我们建了反向边，怎么往回遍历呢？其实也很简单，我们会发现 $a_u$ 中存的不就是 $u$ 的祖先吗！所以往回这样遍历即可。然后就比较典了，我们用一个 $vis$ 数组来记录一个点有没有被访问过，要是一个点第二次被访问到，显然它就是环上的一点，我们可以直接以这个点为根进行 dfs。

# 动态规划

下面来讲解一下动态规划部分。这个又是比较经典的没有上司的舞会模型啊，但是有一点小的变动。

## 状态设计

经典，设 $f_{u,0/1}$ 表示当前节点 $u$ 不选/选时以 $u$ 为根的子树（含 $u$ 本身）中最多能选的个数。

## 转移

当前点 $u$ 不选的情况是容易考虑的。既然当前点不选了，那它的儿子就全都随便选了呗。因此有 $f_{u,0}=\sum \max(f_{v,0},f_{v,1})$。

那么如果当前点 $u$ 选呢？根据题意，如果选了当前点 $u$，那么它的儿子中至少有一个点不能选。如果 $u$ 的儿子中有一个不选，那么这个点的贡献就要减掉。我们要让减掉的这部分贡献尽量小。同时，选了当前点 $u$ 会有 $1$ 的贡献，合起来就是 $f_{u,1}=1+f_{u,0}-\min\{\max(f_{v,0},f_{v,1})-f_{v,0}\}$。

综上，转移方程为：

$$
\begin{cases}
f_{u,0}=\sum \max(f_{v,0},f_{v,1})\\
f_{u,1}=1+f_{u,0}-\min\{\max(f_{v,0},f_{v,1})-f_{v,0}\}
\end{cases}
$$

具体实现的时候，分别记录一下 $\max(f_{v,0},f_{v,1})$ 和 $\max(f_{v,0},f_{v,1})-f_{v,0}$ 就好了。

# 基环树的处理

删边是简单的，判断当前节点的当前遍历到的儿子节点不是一开始锚定的环上的根节点就行。

然后考虑删边之后的影响。显然删去的这条边也是有限制作用的（根节点限制被限制点），那么我们需要考虑上这个限制。

考虑两次动态规划。

第一次的时候，我们强制让根节点选，那么被限制点的其他儿子就一定至少要删去一个，我们正常进行动态规划，取 $\max(f_{root,0},f_{root,1})$ 即可；

第二次的时候，我们强制让根节点不选，那么被限制点的其他儿子就可以随便选了，这依赖于根节点的不选，所以我们取 $f_{root,0}$。

考虑完这些，这个题就基本做完了。最后需要注意是基环森林，要多次找每一颗基环树进行计算。

代码：

```cpp
#include<iostream>
using namespace std;
const int N=1e6+10;
int a[N];
int head[N],nxt[N],v[N],idx;
void add(int x,int y){
	v[++idx]=y;
	nxt[idx]=head[x];
	head[x]=idx;
}
bool vis[N];
int f[N][2];  //f[u][0/1]：u不选/选，以u为节点的子树最多能投放几个
//转移：
//f[u][0]=sum of max(f[v][0],f[v][1]) (v belongs to u's sons)
//f[u][1]=1+f[u][0]-min{max(f[v][0],f[v][1])-f[v][0]} (v belong to u's sons)
int root;
int dfs(int u,int x){  //x记录删去边是否一定不选，1表示一定不选
    f[u][0]=f[u][1]=0;
    vis[u]=1;
    int t=0,minn=2e9;  //存储转移需要的中间变量，t记录max(f[v][0],f[v][1])，minn记录(t-f[v][0])
    for(int i=head[u];i;i=nxt[i]){
        int vv=v[i];
        if(vv==root){
            continue;
        }
        t=dfs(vv,x);
        minn=min(minn,t-f[vv][0]);
        f[u][0]+=t;
    }
    f[u][1]=f[u][0]-minn+1;
    if(x&&(u==a[root])){  //如果考虑删去边，其他的儿子节点可以任意选，因此前面多减去了一部分贡献，需要加回来
        f[u][1]+=minn;
    }
    return max(f[u][0],f[u][1]);
}
int get(int x){
    root=x;
    while(!vis[a[root]]){  //找环上的一个点，删边
        vis[root]=1;
        root=a[root];
    }
    int t=dfs(root,0);  //此时不考虑删去边的限制，当前点除了删去边的限制之外的限制有一个不选，因此删去边的另一边可选可不选
    dfs(root,1);  //考虑删去边，删去边的限制一定不选，因此未删去边都可选可不选
    return max(t,f[root][0]);
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        add(a[i],i);  //反向建边，使得每个点入度为1（基环外向树），方便后续处理
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(!vis[i]){  //基环森林
            ans+=get(i);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：hzoi_Shadow (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10933)

# 前置知识

[树形 DP](https://oi-wiki.org/dp/tree/) 

# 解法

将 $a_{i}$ 向 $i$ 连一条有向边，这样就形成了基环外向树森林。

设 $f_{x,0/1}$ 表示 $x$ 不选/选时，以 $x$ 为根的子树的最多选择个数，状态转移方程为 $\begin{cases} f_{x,0}=\sum\limits_{y \in Son(x)} \max(f_{y,0},f_{y,1}) \\ f_{x,1}=1+\max\limits_{y \in Son(x)} \{ f_{y,0}+\sum\limits_{z \in Son(x),z \ne y} \max(f_{z,0},f_{z,1}) \} \end{cases}$，其中 $f_{x,1}$ 的转移可以进一步写作 $f_{x,1}=1+f_{x,0}- \min\limits_{y \in Son(x)} \{ \max(f_{y,0},f_{y,1})-f_{y,0} \}$。

最后处理下环形 DP 的取或不取即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node
{
    int nxt,to;
}e[2000010];
int head[2000010],vis[2000010],u[2000010],v[2000010],f[2000010][2],rt,cnt=0;
void add(int u,int v)
{
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
int dfs_huan(int x)
{
    vis[x]=1;
    return (vis[u[x]]==1)?x:dfs_huan(u[x]);
}
void dfs(int x)
{
    int minn=0x3f3f3f3f;
    vis[x]=1;
    f[x][0]=0;
    for(int i=head[x];i!=0;i=e[i].nxt)
    {
        if(e[i].to==rt)
        {
            f[e[i].to][1]=-0x3f3f3f3f;
        }
        else
        {
            dfs(e[i].to);
            f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]);
            minn=min(minn,max(f[e[i].to][0],f[e[i].to][1])-f[e[i].to][0]);
        }
    }
    f[x][1]=1+f[x][0]-minn;
}
int main()
{
    int n,ans=0,maxx,i;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        v[i]=i;
        cin>>u[i];
        add(u[i],v[i]);
    }
    for(i=1;i<=n;i++)
    {
        if(vis[i]==0)
        {
            rt=dfs_huan(i);
            dfs(rt);
            maxx=max(f[rt][0],f[rt][1]);
            rt=u[rt];
            dfs(rt);
            ans+=max(maxx,f[rt][1]);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：XuZile (赞：3)

# P10933 题解
## 前言
~~该题我借鉴了楼上大佬的思路，勿喷。~~
## 解题思路
### 建边
这道题可以考虑去建一个外向基环树森林，那么可以将 $a_i$ 向 $i$ 进行建边。我这边是用结构体去进行建边。
```cpp
struct E {
	ll nxt,to;
} e[N<<1];
void add(ll u,ll v) {
	e[++ec]= {hd[u],v};
	hd[u]=ec;
}
for(ll i=1; i<=n; i++)s[i]=read(),add(s[i],i);
```
### 找环
我们对于每一个叶子节点 $a_i$ 进行向上找环。刚好我们建的就是外向基环树森林，所以对于点 $v$ 是每一个 $a_v$。用 DFS 去维护搜索。
### DP 方程
首先定义 DP 数组 $dp_{i,1/0}$，表示对于结点 $i$ 选与不选时，以 $i$ 为根的最多投放数量。

当不选结点 $i$ 时比较简单，最多投放数量就是他的每个儿子结点中选与不选的最大投放数量之和。即：
$$dp_{i,0}=\sum_{j=e_i.nxt}^{j!=0}\max(dp_{j,0},dp_{j,1})$$

当选结点 $i$ 时，最多投放数量为 1 加不选结点 $i$ 时最大的投放数量减去对于他的每个儿子结点最小的最大的他的每个儿子结点选与不选的值减去选该儿子结点的值。即：
$$dp_{i,1}=1+dp_{i,0}+\sum_{j=e_i.nex}^{j!=0}\min(\max(dp_{j,0},dp_{j,1})-dp_{j,0})$$
### 删边
如果结点的儿子节点不是一开始锚定的环上的根节点，就可以进行删边操作。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+5;

struct E {
	ll nxt,to;
} e[N<<1];
ll n,id,ec,ans;
ll vis[N],s[N],hd[N],dp[N][2];

inline ll read() {
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}

void add(ll u,ll v) {
	e[++ec]= {hd[u],v};
	hd[u]=ec;
}

ll dfs(ll u,bool f) {
	dp[u][0]=dp[u][1]=0;
	vis[u]=1;
	ll sum=0,mn=1e9+7;
	for(ll i=hd[u]; i; i=e[i].nxt){
		ll v=e[i].to;
		if(v==id)continue;
		ll t=dfs(v,f);
		mn=min(mn,t-dp[v][0]);
		sum+=t;
	}
	dp[u][0]=sum;
	dp[u][1]=sum-mn+1;
	if(f&&u==s[id])dp[u][1]+=mn;
	return max(dp[u][0],dp[u][1]);
}

void slove() {
	for(ll i=1; i<=n; i++)s[i]=read(),add(s[i],i);
	for(ll i=1; i<=n; i++)if(!vis[i]) {
			id=i;
			while(!vis[s[id]])id=s[id],vis[id]=1;
			ll t1=dfs(id,0);
			dfs(id,1);
			ans+=max(t1,dp[id][0]);
		}
}

int main() {
	n=read();
	slove();
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：LEWISAK (赞：3)

### 题目大意

给定一张内向基环树，求最多能选定几个点使得每个被选定的点都有至少一条未被选定的点指向它的边。

### 题解

特别的，以下对于 $a_i=j$ 称 $j$ 为 $i$ 的父亲。

题解都是树形 dp 啊，考虑拓扑加贪心，注意到几个性质：

1. 叶子节点绝对不能被选定，于是它的父亲就一定可以被选定，于是当拓扑时遇到了叶子节点就将它和父亲删掉并把答案加一。

2. 对于一个大小为 $siz$ 的环，答案显然为 $\left \lfloor{siz/2 } \right \rfloor$ （隔一个选一个），拓扑后找环即可。

关于正确性，注意到将叶子和其父亲删掉最多破坏一个贡献，但一定会产生一个贡献。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace j8{
int n,a[1001000],st[1001000],ru[1001000],tot,ans,vis[1001000];
string main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ru[a[i]]++;
	}
	for(int i=1;i<=n;i++){
		if(!ru[i]){
			st[++tot]=i;
		}
	}
	while(tot){
		int x=st[tot],f=a[x];
		tot--;
		if(vis[x]){
			continue;
		}
		vis[x]=1;
		ru[f]--;
		if(!ru[f]){
			st[++tot]=f;
		}
		if(!vis[f]){
			vis[f]=1;
			ans++;
			ru[a[f]]--;
			if(!ru[a[f]]){
				st[++tot]=a[f];
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(vis[i]){
			continue;
		}
		vis[i]=1;
		int cnt=1,x=a[i];
		while(x!=i){
			vis[x]=1;
			x=a[x];
			cnt++;
		}
		ans+=cnt/2;
	}
	cout<<ans<<'\n';
	return "LEWISAK";
}
}
int main(){
	cerr<<j8::main();
	return 0;
}
```

---

## 作者：MafuyuQWQ (赞：3)

## 题意
>  给定一张 $ n $ 个点 $ n $ 条边的有向图，若选了当前节点，那么当前节点的儿子节点至少有一个不能选。求最多能选多少个点。

## Solution

观察题面后发现这道题 $ n $ 个点 $ n $ 条边，且无明确说明图联通，所以图可能是基环树森林  

先从简单开始，只考虑最普通的树，不考虑基环

将当前点向控制它的点连一条边，发现这道题似乎可以用树形 dp 解决

设 $ f[i][j] $ 表示点 $ i $ 是否选择的答案，于是状态转移方程也就呼之欲出

设当前节点为 $ u $，$ u $ 的父节点为 $ p $。

则可以得到下面 $ 2 $ 个状态转移方程

$ f_{u,0} = max(f_{p,0}, f_{p,1}) $

$ f_{u,1} = max(f_{u,1}, f_{u,0} - max(f_{p,0}, f_{p,1}) + f_{p,0} + 1) $

但是，我们发现基环树不能做 dp，会 TLE。

于是考虑先断环，再断 $ (u, a_u) $ 这条边。

那么就会有 $ 2 $ 种情况，需要分类讨论：

* 选 $ a_u $，那么 $ u $ 就有限制，求出 $ f_{u,1},f_{u,0} $，答案为 $ f_{u,0} $。
  
* 不选 $ a_u $，那对于 $ u $ 就是没有限制，只要以 $ u $ 为根进行 dp 即可。



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10, M = 2 * N;

int n;
int rh[N], h[N], e[M], ne[M], idx;
bool st[N], ins[N];
int f1[N][2], f2[N][2];
int res;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;//加边
}

void dp(int u, int fa, int f[][2])
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        if (rh[i] == -1) continue;//反边
        int j = e[i];
        dp(j, fa, f);//dp
        f[u][0] += max(f[j][1], f[j][0]);//dp处理f[u][0]
    }

    if (u == fa) f[u][1] = f[u][0] + 1;//不选u
    else
    {
        f[u][1] = -1919810;
        for (int i = h[u]; ~i; i = ne[i])
        {
            if (rh[i] == -1) continue;//选u
            int j = e[i];
            f[u][1] = max(f[u][1], f[u][0] - max(f[j][1], f[j][0]) + f[j][0] + 1);
        }
    }
}

void dfs(int u)
{
    st[u] = ins[u] = true;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
        else if (ins[j])//找到环
        {
            rh[i] = -1;//反边打标记
            dp(j, -1, f1);//以j为根
            dp(j, u, f2);//选a[u]
            res += max(max(f1[j][0], f1[j][1]), f2[j][0]);//更新答案
            // cout << res << '\n';
        }
    }

    ins[u] = false;
}

int main()
{
    memset(h, -1, sizeof h);
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        int x;
        cin >> x;
        add(x, i);//加边
    }

    for (int i = 1; i <= n; i ++ )
        if (!st[i]) dfs(i);

    cout << res << '\n';

    return 0;
}
```

---

## 作者：ykzzldz (赞：3)

由于约束条件是由一个元素指向一个可以限制这个元素的，于是，我们从 $A_i$ 向 $i$ 连边，构成一棵基环树。

先考虑在树上的情况，设 $f_{u,0/1}$ 表示 $u$ 节点不选/选子树内的答案，转移比较简单：

$
f_{u,0}=\sum\max(f_{v,0},f_{v,1})
$

$
f_{u,1}=\max\{f_{v',0}-\max(f_{v',0},f_{v',1})\}+f_{u,0}+1
$

再考虑原问题，基环树的经典套路：断环。我们考虑断掉一条环边 $(A_i,i)$，以 $i$ 为根进行 dp，分两种情况讨论：

- 选 $A_i$，此时我们规定不选 $i$，用 $f_{i,0}$ 贡献答案

- 不选 $A_i$，此时 $i$ 无限制，用 $\max(f_{i,0},f_{i,1})$ 贡献答案

复杂度是严格线性的。

---

## 作者：Mirasycle (赞：3)

每个被限制的元素向限制它的元素连边，$n$ 个点，$n$ 条边。连出来的是一个基环树森林。

题目也就是要求选最多的点，使得被选点的儿子不能全选。

考虑如果是树怎么做，我们设 $dp_{u,0/1}$ 表示 $u$ 不选/选的最大权值。

于是 $dp_{u,0}=\sum\max(dp_{u,0},dp_{u,1})$

$dp_{u,1}=\max\{dp_{y,0}+\sum\limits_{v\neq y}\max(dp_{v,0},dp_{v,1})\}$

将这个做法扩展到基环树。

我们对于每颗基环树都用并查集找到环上两个相邻点。

这里处理环的方式是断环为链，两次 dp。

假设我们找到的相邻边是 $s\to t$，断开这条边，直接从 $t$ 开始 dp，然后 $ans\gets \max(dp_{t,0},dp_{t,1})$。但是当我们 dp 到 $s$ 的时候显然是没有利用到 $s\to t$ 的条件的，为了利用该条件，所以第二次 dp 的时候我们强制不选 $t$，然后 $s$ 随便选，这样子第二次 dp 完之后，$ans\gets dp_{t,0}$。

时间复杂度 $O(n\log n)$，如果用按秩合并的并查集，可以做到线性。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
using namespace std;
const int maxn=1e6+10;
const int inf=0x3f3f3f3f;
int dp[maxn][2],n,k;
int s[maxn][2],ans,m;
vector<int> G[maxn];
struct DSU{
	int fa[maxn];
	void init(){ for(int i=1;i<=n;i++) fa[i]=i; }
	int find(int x){ return x==fa[x]?x:fa[x]=find(fa[x]); }
	void merge(int u,int v){
		int f1=find(u),f2=find(v);
		if(f1==f2) s[++m][0]=v,s[m][1]=u;
		else{ G[v].pb(u); fa[f1]=f2; }
	}
}dsu;
void Dp(int u){
	int val=inf; dp[u][0]=0;
	for(auto v:G[u]){
		Dp(v);
		dp[u][0]+=max(dp[v][0],dp[v][1]);
		val=min(val,max(dp[v][0],dp[v][1])-dp[v][0]);
	}
	if(u!=k) dp[u][1]=dp[u][0]+1-val;
	else dp[u][1]=dp[u][0]+1;
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n; dsu.init(); m=0;
	for(int i=1;i<=n;i++){ int v; cin>>v; dsu.merge(i,v); }
	for(int i=1;i<=m;i++){
		Dp(s[i][1]); int res=max(dp[s[i][1]][0],dp[s[i][1]][1]);
		k=s[i][0]; Dp(s[i][1]); res=max(res,dp[s[i][1]][0]);
		ans+=res;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xf20280111 (赞：2)

## 题意
可以抽象成一个图论问题。

给你 $n$ 个点的有向图，每个点恰好有一个出边（可能有自环），选出尽可能多的点，使得每个被选出的点 $x$，都至少有一个指向 $x$ 的点没被选。
## 思路
可以想到 DP。

这是一棵树吗？显然不是，因为边数等于点数，那就是一棵基环树了！！！

基环树 DP 的一般思路就是先断掉一条边，使其变成一个普通的树形 DP 进行求解，最后考虑上删边的影响。

那我们就先考虑这个树上的 DP。

### 树上 DP
和没有上司的舞会很像。
#### 状态
设 $dp_{u,0/1}$ 表示以 $u$ 为根的子树，并且选或不选 $u$ 最多能选择的点数。

算是一个经典模型了，一般都会这么设。

#### 转移方程
如果 $u = 0$，那么他的儿子都可以选，当然也可以不选。所以求最大值。转移方程就是 $dp_{u,0}=\sum{\max(dp_{v,0},dp_{v,1})}$。

如果 $u = 1$，那么他至少要有一个儿子不选，不选的儿子肯定是值最小的，这样 $dp_{u,1}$ 才会大。即 $dp_{u,1} = 1 + dp_{u}{0} - \min(dp_{v,1} - dp_{v,0})$。

#### 边界条件

因为要求和，所以全赋值为 $0$，即 $dp_{u,0/1} = 0$。

### 删边
用两次 DP 来解决。

考虑 $u$ 选不选，一次设 $u$ 要选，一次设 $u$ 不选。

最后答案取最大值就行了。

## 代码
细节都在注释里。

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = 1e6 + 10;
const int INF = 0x3f3f3f3f;

int n,a[N];

vector<int> e[N];

int dfn[N],dp[N][2];

int vis[N];
void dfs(int u,int root,bool flag){
	dfn[u] = true;
	int mi = INF;
	for (auto v :e[u]){
		if (v == root) continue;//防止死循环
		dfs(v,root,flag);
		dp[u][0] += max(dp[v][1],dp[v][0]);
		mi = min(dp[v][1] - dp[v][0],mi);//维护最小值
	}
	dp[u][1] = 1 + dp[u][0];
	if (u != a[root] or !flag){	
		if (mi >= 0) dp[u][1] -= mi;
	}
}
int main()
{
	int n;cin >> n;
	for (int i = 1;i <= n;i++){
		cin >> a[i];
		e[a[i]].push_back(i);//还要在树的内部 DP，所以建反图
	}
	int sum = 0;
	for (int x = 1;x <= n;x++){//基环森林
		if (!dfn[x]){
			while(!vis[x]){
				vis[x] = true;
				x = a[x];
			}//求环
			dfs(x,x,1);
			int ans = dp[x][0];
			dfs(x,x,0);
			sum += max(dp[x][1],ans);
		}

	}
	cout << sum;
	return 0;	
} 
```

---

## 作者：Gon_Tata (赞：2)

# P10933 创世纪  题解

**[题目传送门](https://www.luogu.com.cn/problem/P10933)**

此题和 [[ZJOI2008] 骑士](https://www.luogu.com.cn/problem/P2607) 有点像，考虑基环树上跑 DP。

为了理解方便，我们对原图建反图。即对于一条由 $u$ 指向 $v$ 的边，其表示 $v$ 可以限制 $u$，此时题面可理解为“要求满足图上每个节点至少有一个子节点不被取用，求最多可取用的节点的数量“。

首先考虑树上 DP，定义 $dp_{0,x}$ 表示树上不取用（不投放）点 $x$ 时，以 $x$ 为根的子树中最多可投放的元素个数。与此类似，$dp_{1,x}$ 表示取用（投放）点 $x$ 的情况。

再通过树上 DP 将信息向根传递，最后 $\max(dp_{0,root},dp_{1,root})$ 即为整棵树上的答案。

对于 $dp_{1,x}$ 的转移，可以在其子树中选定一点 $p$，强制其不被选取。其相较 $dp_{0,x}$ 无限制的选取作出的负贡献为 $\max(dp_{0,p},dp_{1,p})-dp_{0,p}$，由此可推出转移方程

$$
\ dp_{0,x}=\sum\limits_{p\in son(x)} \max(dp_{0,p},dp_{1,p}) \\[2ex]
dp_{1,x}=1+dp_{0,x}-\min\limits_{p\in son(x)} \{ \max(dp_{0,p},dp_{1,p})-dp_{0,p} \}
$$

我们再考虑如何处理图上的环。注意到可以选取环上相邻两点，并分别以其为根跑树上 DP，当访问到自己时令其 $dp_{1,root}$ 为极小值，最后从两根中统计答案。

关于环上相邻两点的寻找，可以使用并查集。在建边过程中，如果在连边前两点已经联通，加上此边后其一定为环上相邻两点。


**Talk is cheap. Show me the code.**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int inf=1e6+10;
int n,fa[inf],dp[2][inf],ans,root;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
vector<int>w[inf];
vector<pair<int,int>> ring;
void dfs(int x){
	int minn=LONG_LONG_MAX;
	dp[0][x]=0;
	for(auto p:w[x]){
		if(p==root){
			dp[1][p]=LONG_LONG_MIN;
			continue;
		}
		dfs(p);
		dp[0][x]+=max(dp[1][p],dp[0][p]);
		minn=min(minn,max(dp[0][p],dp[1][p])-dp[0][p]);
	}
	dp[1][x]=1+dp[0][x]-minn;
}
signed main(){
	// freopen("a.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1,a;i<=n;i++){
		cin>>a;
		w[a].push_back(i);
		int fu=find(i),fv=find(a);
		if(fu==fv) ring.push_back(make_pair(i,a));
		else fa[i]=a;
	}
	for(auto p:ring){
		root=p.first;
		dfs(root);
		int kep=max(dp[0][root],dp[1][root]);
		root=p.second;
		dfs(root);
		ans+=max(kep,dp[1][root]);
	}
	cout<<ans<<'\n';
}
```

---

## 作者：DYYqwq (赞：2)

显然建边，形成内向基环森林。这样连环的限制关系让我们想到拓扑排序。

而且我们注意到一个性质：只要你能选，越早选越优。这点可以感性理解，我们一定不会空过去一个不选，而非要选第二个，这样就会白白浪费一个位置。

拓扑排序内部，我们需要一个 `bool` 类型的数组，记录该物品是否被选走。拓扑排序同时需要一个队列，代表考虑该点。每次考察队首，如若其被选走，则其后继无法参与；反之，其后继有机可乘，累加答案，设置状态，并加入队列。

但是注意到，可能图中存在孤环。考虑对一个孤环如何选择。画图分析发现，这与环长度的奇偶性相关。

![](https://cdn.luogu.com.cn/upload/image_hosting/jdygz1w4.png)

奇环状态下，贯彻我们隔一个选一个的战略，$1,3$ 号点一定能选。考察 $5$ 号点，发现无法选择，因为需要保证它的存在以确保 $1$ 号点可以参与建设世界。

因此奇环上选的物体数量是 $\frac{n-1}{2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1vup13ih.png)

而偶环无需考虑这么多。贯彻战略，选 $1,3,5$，不受牵挂，完美通关。

因此偶环上选的物体数量是 $\frac{n}{2}$。

两者综合一下其实就是 $\lfloor \frac{n}{2} \rfloor$。

于是在拓扑排序后，判一判环，把答案累加起来即可。

拓扑排序时间复杂度不用分析了吧，$O(n)$ 级别。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n , a[1000010] , in[1000010] , ans;
bool flag[1000010] , vis[1000010];
void input()
{
	scanf("%d" , &n);
	for(int i = 1 ; i <= n ; i ++) scanf("%d" , &a[i]) , in[a[i]] ++;
}
void topo_sort()
{
	queue<int> q;
	for(int i = 1 ; i <= n ; i ++) if(in[i] == 0) q.push(i);
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		vis[u] = true;
		if(flag[u] == true)
		{
			in[a[u]] --;
			if(in[a[u]] == 0) q.push(a[u]);
		}
		else
		{
			if(flag[a[u]] == false)
			{
				ans ++ , flag[a[u]] = true;
				q.push(a[u]);
			}
		}
	}
}
void check_rings()
{
	for(int i = 1 ; i <= n ; i ++)
	{
		if(vis[i] == false && in[i] != 0)
		{
			int len = 0 , now = i;
			while(vis[now] == false)
			{
				len ++;
				vis[now] = true;
				now = a[now];
			}
			ans += len / 2;
		}
	}
}
void output() {printf("%d" , ans);}
int main()
{
	input();
	topo_sort();
	check_rings();
	output();
	return 0;
}
```

---

## 作者：wayneoi (赞：2)

# P10933 创世纪 - 题解

前置芝士： [基环树](https://www.cnblogs.com/Dfkuaid-210/p/14696378.html)。

上帝有 $N$ 种世界元素，每种元素 $i$ 可以限制另一种元素 $A[i]$ 。现在要选择一部分元素投放到新空间，要求每个被投放的元素至少有一个能限制它的元素未被投放。求最多能投放多少元素。

可以转化为图论中的基环树问题，元素 $i$ 向 $A[i]$ 连一条有向边，这样就形成了一个由若干基环树组成的图。

1. 对于树的部分，可以用拓扑排序处理。从入度为 0 的叶子节点开始，这些节点必须被选择（投放），因为它们不能被其他节点限制。然后它们的父节点就不能被选择，依此类推。

2. 对于环中的节点，每个节点都需要被另一个节点限制。最优解是将环中的节点交替选择，这样对于一个长度为 $k$ 的环，最多可以选择 $\lfloor k/2 \rfloor$ 个节点。

首先处理所有入度为 0 的节点，这些节点必须被选择。然后它们限制的节点就不能被选择，更新相关节点的入度。剩下的未被访问的节点都位于环中。对于每个环，计算其长度 $k$ ，可以最多选择 $\lfloor k/2 \rfloor$ 个节点。

- 时间复杂度： $O(N)$ 。

#### 代码不重要，重要的是思路。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n, ans, out, a[N], to[N], cnt, in[N], vis[N], x[N];
inline void toposort(){
    queue<int> q;
    for(int i = 1; i <= n; i++) if(in[i] == 0) q.push(i); //将所有入度为0的节点加入队列
    while(!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 1;
        // 如果当前节点未被选择，则选择它限制的节点，并更新相关节点的入度。
        if(x[u] == 1){
            in[to[u]]--;
            if(in[to[u]] == 0) q.push(to[u]); 
        } else {
            if(!x[to[u]]) q.push(to[u]), out++;
            x[to[u]] = 1;
        }
    }
    ans += out;
    for(int i = 1; i <= n; i++){
        cnt = 0;
        if(vis[i] == 0 && in[i] > 0){
            for(int k = i ; vis[k] == 0; k = to[k]) cnt++, vis[k] = 1;
            ans += cnt / 2;
        }
    }
}
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        to[i] = a[i], in[a[i]]++;
    }
    toposort();
    cout << ans << "\n";
    return 0;
}
```
管理大大求过 🙏🙏。

---

## 作者：chentianmiao (赞：1)

## 思路分析
本题是一个经典的**内向基环树最小支配集**问题。

基环树上的问题，一般都是断开环上的边变成树形问题，每个节点可能被选入支配集或者不选入支配集。

接下来：
- $f[u][0]$ 表示不选 $u$ 时 $u$ 为根的子树最优解；
- $f[u][1]$ 表示选中 $u$ 时 $u$ 为根的子树最优解。

计算 $f[u][1]$ 时，$u$ 的子节点可以随意选择；
计算 $f[u][0]$ 时，$u$ 的儿子中必须至少选一个。

到这里似乎已经做完了，但还遗漏一种情况，强制断开的边 $(u,p[u])$ 发挥作用。必须选中 $u$ 号节点，在计算 $f[p[u]][0]$ 时 $p[u]$ 的子节点可以随意选择。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000009,INF=1e9;
struct Edge{
	int to,nxt;
}e[N*2];
int hd[N],nE=1;
int n,p[N];
int rt;
int f[N][2];
int nPick;
int iPart,tag[N];
void add(int u,int v){
	e[++nE]=(Edge){v,hd[u]};
	hd[u]=nE;
}
void dfs_DP(int u,int St){
	f[u][0]=0;
	f[u][1]=1;
	if(!hd[u]){
		f[u][0]=INF;
	}
	int dlt=INF;
	for(int i=hd[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==rt){
			continue;
		}
		dfs_DP(v,St);
		int minFv=min(f[v][0],f[v][1]);
		f[u][1]+=minFv;
		f[u][0]+=minFv;
		dlt=min(dlt,f[v][1]-minFv);
	}
	if(St&&u==p[rt]){
		if(f[u][0]==INF){
			f[u][0]=0;
		}
		return;
	}
	if(f[u][0]==INF){
		return;
	}
	f[u][0]+=dlt;
}
void solve(){
	dfs_DP(rt,0);
	int minPick=f[rt][0];
	dfs_DP(rt,1);
	minPick=min(minPick,f[rt][1]);
	nPick+=minPick;
}
int main(){
	cin>>n;
	for(int u=1;u<=n;u++){
		cin>>p[u];
		add(p[u],u);
	}
	for(int u=1;u<=n;u++){
		if(tag[u]){
			continue;
		}
		int x=u;
		iPart++;
		do{
			tag[x]=iPart;
			x=p[x];
		}while(!tag[x]);
		if(tag[x]!=tag[u]){
			continue;
		}
		rt=x;
		solve();
	}
	cout<<n-nPick;
	return 0;
}
```

---

## 作者：I_LOVE_MATH (赞：1)

### P10933 创世纪 [link](https://www.luogu.com.cn/problem/P10933)

[合集：浅谈基环树](https://www.luogu.com.cn/article/qrtj98oz)

#### 题目大意

给出一个有向基环森林，选出若干点，要求所有选出的点都必须要有一个没被选出的点指向它，最大化选出点数。

#### 解题思路

这道题连边上有些文章可作，我们将集成内向基环树与外向基环树的优点，进行连边。

具体地，记 $u$ 指向 $v$，我们用数组 $p$ 记录一个点指向的点即 $p_u = v$，这是内向基环树；我们再用链式向前星由 $v$ 向 $u$ 建单向边，这是外向基环树。

这么连边的好处是操作方便，内向基环树优点是找环方便，由于点都是向内指的，只需随便选一个点一直往其指向的点走，直到重复为止便找到了环；而链式向前星建单向边的好处是方便 dp，删去环上一边后，以断点为根，每个节点其连边都是儿子。

上面已经说过了找环方法，将边断掉之后便可以开始树形 dp：

-  状态表示：$dp_{i,0/1}$ 表示在以 $i$ 根的子树内，$i$ 不选 / 选时的最大选点数。
-  初始化：$dp_{i,0/1}=0$
-  状态转移
   -  不选 $i$：则其子节点不受限制，即
      
      $$dp_{i,0}=\sum_{j \in son_i}{\max(dp_{j,0},dp_{j,1})}$$

   -  选 $i$：则其子节点至少有一个不选，即
      
      $$dp_{i,1}=1+\max_{j \in son_i}{(dp_{j,0}+\sum_{k \in son_i,k \neq j}{\max(dp_{k,0},dp_{k,1})})}$$

		复杂度较高，考虑优化，发现右边的和式与 $dp_{i,0}$ 很相似，于是有：

		$$\begin{aligned}dp_{i,1} &= 1+\max_{j \in son_i}{(dp_{j,0}+dp_{i,0} - \max(dp_{j,0},dp_{j,1}))} \\ &= 1 + dp_{i,0} - \min_{j \in son_i}{(\max(dp_{j,0},dp_{j,1}) - dp_{j,0})}\end{aligned}$$

		即可快速转移。
-  答案：$\max(dp_{rt,0},dp_{rt,1})$

现在我们考虑删去边的影响，原来有一条边是由根指向一个节点的，但是被删除了，这意味者原来根是可以限制此节点的，现在不行了，也就是说我们要考虑根限制此节点的情况。

于是我们再跑一遍 dp，钦定选根节点，即这个点已经被限制住了，意味着就算选这个点其儿子也不受任何限制，只需将选这个点的 dp 值加上 $\min_{j \in son_i}{(\max(dp_{j,0},dp_{j,1}) - dp_{j,0})}$ 即可，最后答案为 $dp_{rt,1}$，与上面得到答案取最大值便得到了最终答案。

#### 代码实现

``` cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;

const int N = 1e6 + 10;

struct edge
{
	int to, next;
} e[N];

int n, tot, rt, ans;
int a[N], h[N];
int dp[N][2];
bool vis[N];

void add(int u, int v)
{
	tot++;
	e[tot].to = v;
	e[tot].next = h[u];
	h[u] = tot;
}

void dfs(int u, bool flag)
{
	dp[u][0] = 0;
	vis[u] = 1;
	int mn = 1e9;
	for (int i = h[u]; i; i = e[i].next)
	{
		int v = e[i].to;
		if (v != rt)
		{
			dfs(v, flag);
			dp[u][0] += max(dp[v][0], dp[v][1]);
			mn = min(mn, max(dp[v][0], dp[v][1]) - dp[v][0]);
		}
	}
	dp[u][1] = 1 + dp[u][0] - mn;
	if (flag && u == a[rt])
	{
		dp[u][1] += mn;
	}
}

int main()
{
	ios :: sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		add(a[i], i);
	}
	for (int i = 1; i <= n; i++)
	{
		if (!vis[i])
		{
			for (rt = i; !vis[rt]; rt = a[rt])
			{
				vis[rt] = 1;
			}
			dfs(rt, 0);
			int tmp = max(dp[rt][0], dp[rt][1]);
			dfs(rt, 1);
			ans += max(tmp, dp[rt][0]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：CommandSR (赞：1)

## 基本思路

对于每个点向能够限制它的世界元素建边，显然建完图之后是一个外向基环树森林。

对于每一颗基环树，先找到环，然后对于环上任意一条边的两个点分别树形 DP，取较大值计入答案。

对于树形 DP，设 $f_{u,0}$ 为不选 $u$ 点的最多可以投放的世界元素的数目，$f_{u,1}$ 为选这个点的最大数目。

对于 $f_{u, 0}$，对子树，即能够限制它的点没有限制，所以有 $f_{u,0} = \sum_{v \in son_u}{\max{f_{v,0}, f_{v,1}}}$。

对于 $f_{u,1}$，可以先按上面的式子转移，但必须保证有一个子节点不选。所以记录一下有没有一个子节点没有选，即是否存在一个 $v \in son_u$ 满足 $f_{v,0} \ge f_{v,1}$。

如果存在，那么符合题意，如果不存在，选择一个 $v$，将 $f_{u,1}$ 减去 $f_{v,1}$ 加上 $f_{v,0}$。容易发现需要统计子树中 $f_{v,0}-f_{v,1}$ 最大的 $v$ 作为选择。

具体可见代码。

## AC Code

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
using namespace std;
inline ll rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 1e6 + 5;
ll n;
struct E {
	ll to, nxt;
} e[N];
ll hd[N], ec;
bool vis[N];
void AE(ll u, ll v) {
	e[++ec] = (E){v, hd[u]}, hd[u] = ec;
}
ll r1 = 0, r2 = 0;
void Find(ll u, ll rt) {
	vis[u] = 1;
	for (int i = hd[u]; i; i = e[i].nxt) {
		ll v = e[i].to;
		if (v == rt) {
			r1 = u, r2 = v;
			return;
		}
		if (vis[v]) continue;
		Find(v, rt);
	}
}
ll f[N][2];
ll dfs(ll u, ll rt) {
	f[u][1] = 1, f[u][0] = 0;
	ll mx = 0; bool flag = 0;
	for (int i = hd[u]; i; i = e[i].nxt) {
		ll v = e[i].to;
		if (v == rt) continue;
		dfs(v, rt);
		f[u][0] += max(f[v][0], f[v][1]);
		if (f[v][0] > f[v][1]) flag = 1, f[u][1] += f[v][0]; 
		else f[u][1] += f[v][1];
		if (!mx || f[v][0]-f[v][1] > f[mx][0]-f[mx][1]) mx = v;
	}
	if (!flag) {
		if (mx) f[u][1] = f[u][1] - f[mx][1] + f[mx][0];
		else f[u][1] = 0;
	}
	return f[u][1];
}
int main() {
	n = rd();
	F(i, 1, n) {
		ll x = rd();
		AE(x, i);
	}
	ll ans = 0;
	F(i, 1, n) {
		if (vis[i]) continue;
		r1 = r2 = 0;
		Find(i, i);
		if (r1) {
			ll res1 = dfs(r1, r1);
			ll res2 = dfs(r2, r2);
			ans += max(res1, res2);
		}
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：GY程袁浩 (赞：1)

首先，你需要注意题目里实际上叶节点是不能选的。

几乎没有动机，我们通过套路单点单边知道了这道题的图实际上是一颗基环树森林。

然后每棵基环树是独立的，所以我们分连通块考虑即可。

现在来讲述单棵树的做法，首先基环树的套路做法就是找环再考虑。对于本题，我们有一个新的套路，就是我们可以依照有后效性的 DP 的处理思路，先断开环上一条边，这样整颗基环树就变成了一颗树，再考虑强制连上刚刚断开的边再考虑一遍。这样我们的答案就取到了全集，没有遗漏情况。

断开一条边实际上是给 $A_{p}$ 带来不利的环境。因为你考虑它本来可以从 $p$ 来转移，但是因为边被切了，所以不能够这么做。就是它的能用决策集合变小了。

注意：我们不把边连回去，只是特判考虑。

对于树上 DP，参考没有上司的舞会，简单地设计树上 DP 方程即可。

对于一个节点，选择一个子节点不选来转移。

如果是强制连边，$A_{p}$ 即可特判选择选择所有子节点。

不懂可以私信交流喵。

我最近在提升代码能力。我将寻找高效的代码作为这题的答案代码，同时，我也会写部分注释，希望读者能够仔细地去阅读，并学习代码设计简化的思路，不要走我的路。代码设计的不好，又不好调，又不好写，不仅在比赛时会吃大亏，也会影响平时训练。

这里我们有具体代码实现思路，我们建反图方便访问节点。然后为了简化，我们这样考虑环，由于整棵基环树是一个内向树，于是我们一直到达原图上的出点，直到遍历到遍历过的点。写一个深搜函数，其中所含特判，做两次，取最大值即可。另外，在转移过程中，我们可以记录不选单个儿子丢失的最小值，就可以从当前节点不选的状态转移啦。

# Code

```cpp
// Problem: P10933 创世纪
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10933
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int long long
#define upp(a, x, y) for (int a = x; a <= y; a++)
#define dww(a, x, y) for (int a = x; a >= y; a--)
#define pb(x) push_back(x)
#define endl '\n'
#define x first
#define y second
#define PII pair<int, int>
using namespace std;
const int N = 1e6 + 10, INF = 0x3f3f3f3f3f3f3f3f;
int st[N], vis[N], h[N], e[N], ne[N], a[N], f[N][2], n, rt, idx, ans;
void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }
/*
这里我们有状态转移方程
对于不特判
f[u][0]=sum of max(f[j][0],f[j][1]) (j belongs to u's sons)
f[u][1]=f[y][0]+sum of max(f[j][0],f[j][1]) (j and y belong to u's sons,but j
not equal to y)

对于特判，文中描述
*/
int dfs(int u, bool va) {
    int minn = INF; //记录不选单个，丢失的最小值，这个思想很妙。
    st[u] = 1;
    f[u][0] = f[u][1] = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j == rt) continue;
        dfs(j, va);
        f[u][0] += max(f[j][0], f[j][1]);
        minn = min(minn, f[j][1] - f[j][0]);
    }
    f[u][1] =
        max(f[u][1], f[u][0] - minn + 1); //这里就可以直接通过 f[u][0] 来转移
    if (u == a[rt] && va) f[u][1] = f[u][0] + 1; //特判
    return max(f[u][1], f[u][0]);
}
int solve(int x) {
    for (rt = x; !vis[rt]; rt = a[rt]) vis[rt] = 1; //寻找根
    int res = dfs(rt, 0);
    dfs(rt, 1);                //两次 DP
    return max(res, f[rt][0]); //这里是强制选边的情况
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    memset(h, -1, sizeof h);
    cin >> n;
    upp(i, 1, n) cin >> a[i], add(a[i], i);
    upp(i, 1, n) if (!st[i]) ans += solve(i);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：GXZJQ (赞：1)

# P10933 创世纪 题解

[题目链接](https://www.luogu.com.cn/problem/P10933)

## 思路分析
由于每个点可以限制另外一个点，如果我们看作从每个点向他限制的点连边，则本题就是一个基环森林。我们就是要在一个基环森林中选尽可能多的点，使得每个点都能被某一个没选中的点限制。

由于基环森林中每一棵基环树都是相互独立的，因此我们可以单独考虑每一棵基环树中最多能选择多少个点。

我们先考虑如果在一棵普通的树中如何求，一个点被限制就意味着有一个点指向它，因此就是要保证每个点的父节点都不能被选择，这样的方案我们可以用树形 DP 来求。

设 $f_{u,0}$ 表示从以 $u$ 为根的子树中选若干个点，且不选 $u$ 的所有方案的最大值。设 $f_{u,1}$ 表示从以 $u$ 为根的子树中选若干个点，且选择 $u$ 的所有方案的最大值。

设 $u$ 的每个父节点为 $s$，可得状态转移方程：

$$
\left\{\begin{matrix}   f_{u, 0}= \sum \max \{{f_{s,0}, f_{s,1}} \} \\    f_{u, 1} = \max \{{f_{u,0}-\max \{{f_{t,0},f_{t,1} \}}+f_{t,0}+1}\}\ (t \in s)\end{matrix}\right. 
$$

可以发现这里的树形 DP 中每个点的状态是通过父节点递推过来的，因此我们需要建一个反向边，反向递推。

但是基环树是没法做树形 DP 的，因此我们可以将环上某一条边断开，这样基环树就能变成一棵普通的树，就能做树形 DP 了，我们取环上一点 $p$，将 $p \to A_p$ 的边断开，此时我们可以将所有方案分成两类，一类是不用 $p \to A_p$ 这条边，这就意味着要么不选 $A_p$，要么选 $A_p$ 并且有另外一条边指向 $A_p$。此时没有用到 $p \to A_p$ 这条边，所以对 $p$ 没有任何限制，我们从 $p$ 开始求一遍树形 DP，最终得到两个状态 $f_{p,0}$ 和 $f_{p,1}$，由于 $p$ 选不选都行，因此这一类的答案就是这两个状态取一个最大值。

另一类是用 $p \to A_p$，这意味着我们一定要选 $A_p$，且一定不选 $p$，那么我们只需要在做树形 DP 的过程中特判一下 $A_p$ 一定要选即可，最终同样得到两个状态 $f_{p,0}$ 和 $f_{p,1}$，由于 $p$ 此时一定不能选，因此这一类的答案就是 $f_{p,0}$。

最终再从这两类情况的答案中取一个最大值，就是整个的答案。

## 参考代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1000010, INF = 0x3f3f3f3f;
int n;
int h[N], e[N], rm[N], ne[N], idx; //邻接表
bool st[N], ins[N]; //st 记录每个点是否被搜过，ins 记录每个点是否在栈中
//f[i][0] 表示从 i 为根的子树中选若干个节点，且不选 i 的所有方案的最大值
//f[i][i] 表示从 i 为根的子树中选若干个节点，且选择 i 的所有方案的最大值
int f1[N][2], f2[N][2];
int res; //记录答案

void add(int a, int b) //添加边
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs_f(int u, int ap, int f[][2]) //树形 dp 求以 u 根为的子树中必选 ap 的所有方案的最大值
{
    //不选 u
    for(int i = h[u]; i != -1; i = ne[i])
    {
        if(rm[i]) continue;
        int j = e[i];
        dfs_f(j, ap, f);
        f[u][0] += max(f[j][0], f[j][1]);
    }

    //如果 u 必选，则 u 已经被 p 限制，其他子节点可选可不选
    if(u == ap) f[u][1] = f[u][0] + 1;
    else
    {
        //选 u
        f[u][1] = -INF;
        for(int i = h[u]; i != -1; i = ne[i])
        {
            if(rm[i]) continue;
            int j = e[i];
            f[u][1] = max(f[u][1], f[u][0] - max(f[j][0], f[j][1]) + f[j][0] + 1);
        }
    }
}

void dfs_c(int u, int from) //找出所有基环树的环
{
    st[u] = ins[u] = true;
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(!st[j]) dfs_c(j, i);
        else if(ins[j]) //找到环
        {
            rm[i] = 1; //将边 ap -> p 删去
            dfs_f(j, -1, f1); //不用边 ap -> p
            dfs_f(j, u, f2); //用边 ap -> p（必选 ap，必不选 p）
            res += max(max(f1[j][0], f1[j][1]), f2[j][0]); //累加所有方案的最大值
        }
    }
    ins[u] = false;
}

int main()
{
    scanf("%d", &n);
    memset(h, -1, sizeof h); //初始化邻接表
    for(int i = 1; i <= n; i++)
    {
        int a;
        scanf("%d", &a);
        add(a, i); //有向边
    }
    //找出所有基环树的环
    for(int i = 1; i <= n; i++)
        if(!st[i])
            dfs_c(i, -1);

    printf("%d\n", res);

    return 0;
}
```

---

## 作者：wwwidk1234 (赞：0)

[合集：2025 暑假集训（Day 15）](https://www.cnblogs.com/wwwidk1234/p/19049954)

这题在校内集训的官方题解是贪心，然后我的这个断环 DP 做法调了六个小时

首先如果把这个限制与被限制的关系连上边的话，可以发现连成了若干基环树。遇到基环树一般的做法有两种：

1. 首先把环的边全部断开，变成若干棵以环上的点为根结点树，然后就可以转化成树上问题，最后我们就可以得到环上每一个结点的信息，问题就变成环上问题了。
2. （个人常用）我们可以发现基环树实际上就是一棵树多了一条边 $(lt,rt)$，把这条边断开之后做树上问题，对于两个断开的点 $lt,rt$ 分情况讨论。如果是只有一棵基环树可以使用并查集找环，如果是基环树森林可以先用并查集找出一个“有代表性的点”，然后再从这个点向上跳就可以找到 $lt,rt$ 了。

回归到这道题。如何连边建立模型？如果我们用边 $(u,v)$ 表示 $u$ 可以限制 $v$，我们会发现我们建立出来了若干棵内向基环树，不太好做。所以我们可以考虑用边 $(u,v)$ 表示 **$u$ 可以被 $v$ 限制，即子节点可以限制父节点**。

接着使用并查集来寻找这个**有代表性的点**。在输入的时候我们把 $i,a_i$ 合并到一个集合中，然后在并查集的祖先数组 `fa` 数组中寻找，如果有结点的祖先是这个结点自己，那么就是一个“有代表性的点”，这个点代表着这个点所在的基环树。

对于基环树森林中的每一棵基环树，我们先从这个有代表性的点向上跳**找环**。开一个标记数组将当前点标记，如果下一个要跳到的点是有标记的，则说明找到环了，这个基环树中的 $lt$ 是当前点，$rt$ 是当前点所限制的元素。在建图的时候不建立 $(rt,lt)$ 这条边就好了。（注意顺序，我们边的定义是前者被后者限制）

对于样例数据，我们建立的图如下（被标记的点就是所找的有代表性的点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/bdijjxx6.png)

可以考虑 DP：设 $dp_{u,0/1}$ 表示**以 $u$ 为根结点的子树，其中 $u$ 不选 / 选的最大投放数量**。我们将边 $(rt,lt)$ 删除建图之后，跑第一遍 DP。

对于**第一遍 DP**，考虑 $u$ 结点如何转移？如果 $u$ 结点没有放的话，那么**它的儿子想怎么放都可以**（因为子节点不要求限制父节点），于是我们有状态转移（其中 $\operatorname{son}(u)$ 表示 $u$ 结点所有儿子结点构成的集合）：

$$dp_{u,0}=\sum_{v \in \operatorname{son}(u)} \max \left\{ dp_{v,0},dp_{v,1}\right\}$$

如果 $u$ 选了怎么办？显然，我们只要让**任意一个儿子结点限制 $u$，其他儿子结点任选**即可。转移如下：

$$dp_{u,1}=1+\max_{v \in \operatorname{son}(u)}\left\{dp_{v,0}+\sum_{v^\prime \operatorname{son}(u) ,v^\prime \neq v}\max\left\{dp_{v^\prime,0},dp_{v^\prime,1}\right\}\right\}$$

转移要枚举一个 $v^\prime$，太耗时间了，怎么办？发现 $\sum_{v^\prime \operatorname{son}(u) ,v^\prime \neq v}\max\left\{dp_{v^\prime,0},dp_{v^\prime,1}\right\}$ 其实就是一个 $dp_{u,0}$ 扣掉了一个 $\max\left\{dp_{v,0},dp_{v,1}\right\}$，于是转移可以优化成如下：

$$dp_{u,1}=1+\max\left\{dp_{v,0}+dp_{u,0}- \max\left\{dp_{v,0},dp_{v,1}\right\}\right\}$$

把 $dp_{u,0}$ 拿出来：

$$dp_{u,1}=1+dp_{u,0}+\max\left\{dp_{v,0}- \max\left\{dp_{v,0},dp_{v,1}\right\}\right\}$$

这个就是我们最终的转移了。**第一遍 DP 的答案就是 $dp_{lt,0},dp_{lt,1}$ 取一个最大值。**

第一遍 DP 我们删掉了 $(rt,lt)$ 这条边，强制让 $lt$ 不能限制 $rt$。所以：

对于**第二遍 DP**，我们考虑**强制让 $lt$ 限制 $rt$**，转移方程同第一遍 DP。但要注意的是因为我们强制让 $lt$ 限制 $rt$，所以 $rt$ 的儿子怎么选都没关系。对于 $u=rt$ 的情况，$dp_{u,1}$ 的转移变成如下：

$$dp_{u,1}=1 + \sum_{v \in \operatorname{son}(u)} \max \left\{ dp_{v,0},dp_{v,1}\right\}=1+dp_{u,0}$$

考虑到我们强制让 $lt$ 限制 $rt$，$lt$ 一定不选，所以**第二遍 DP 的答案就是 $dp_{lt,0}$**。所以一棵基环树的贡献我们就算完了。有基环树森林的情况就直接一棵一棵算贡献，最后累加就好了。

[参考程序](https://www.luogu.com.cn/record/232246618)：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
constexpr int N=1e6+7;
int n,a[N];
bitset<N> vis;
vector<int> g[N];
vector<int> point;  //有代表性的节点 
namespace dsu
{
	int fa[N];
	void init(int n)
	{
		for(int i=1;i<=n;i++) fa[i]=i;
	}
	int find(int u)
	{
		return fa[u]==u?u:fa[u]=find(fa[u]); 
	}
	void merge(int u,int v)
	{
		fa[find(u)]=find(v);
	}
	bool judge(int u,int v)   //u,v是否在一个连通块中 
	{
		return find(u)==find(v);
	}
}
constexpr int inf=12180211;
int ans=0,lt,rt;
int dp1[N][2],dp2[N][2];
void dfs1(int u)
{
	int mx=-121802110;
	for(int v:g[u])
	{
		if(v==lt) continue;
		dfs1(v);
		dp1[u][0]+=max(dp1[v][0],dp1[v][1]);
		mx=max(mx,dp1[v][0]-max(dp1[v][0],dp1[v][1]));
	}
	dp1[u][1]=1+dp1[u][0]+mx;
}
void dfs2(int u)
{
	int mx=-121802110;
	for(int v:g[u])
	{
		if(v==lt) continue;
		dfs2(v);
		dp2[u][0]+=max(dp2[v][0],dp2[v][1]);
		mx=max(mx,dp2[v][0]-max(dp2[v][0],dp2[v][1]));
	}
	if(u==rt) dp2[u][1]=1+dp2[u][0];
	else dp2[u][1]=1+dp2[u][0]+mx;
}

inline int solve(int k)
{
	vis.reset();
	//寻找 lt,rt 
	lt=-1,rt=-1;
	int cur=k;  //当前点 
	vis[cur]=1;
	while(1)
	{
		if(vis[a[cur]]) //向上跳发现有标记 那就说明找到环了 
		{
			lt=cur,rt=a[cur];
			break;
		}
		vis[a[cur]]=1;
		cur=a[cur];
	}
	
	//这里的lt,rt连边的方向是rt->lt 
	
	//建图
	for(int i=1;i<=n;i++)
	{
		int u=a[i],v=i;
		if(dsu::find(u)!=dsu::find(k)||dsu::find(v)!=dsu::find(k)) continue; //这一个solve只要考虑当前基环树的结果,不用考虑其他基环树
		if(!(u==rt&&v==lt)) g[u].push_back(v);  //删掉的边(rt->lt)不连接 
	}
	
	//开始DP
	dfs1(lt);
	dfs2(lt);
//	for(int i=1;i<=n;i++) cerr<<i<<' '<<dp1[i][0]<<' '<<dp1[i][1]<<' '<<dp2[i][0]<<' '<<dp2[i][1]<<endl;
	return max({dp1[lt][0],dp1[lt][1],dp2[lt][0]});
}
int main()
{
//	freopen("neuvillette.in","r",stdin);
//	freopen("neuvillette.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	dsu::init(n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		dsu::merge(a[i],i);
	}
	for(int i=1;i<=n;i++) if(dsu::fa[i]==i) point.push_back(i);
	for(int v:point)
	{
		int res=solve(v);
		ans+=res;
	}
	cout<<ans;
	return 0;
}
/*
把a[i]->i连一条边,代表i可以被a[i]限制 
用并查集把森林中的每一颗基环树都找出来 
对于基环树森林中的每一颗基环树都考虑：
fa[i]=i就是一个“有代表性的”节点 
首先先从每一个基环树这个有代表性的节点往上跳找环, 
然后删掉环其中的一个边(lt,rt)然后开始DP

dp[u][0/1]表示以u为根的子树且u不选/选的最大答案
根据连边的结果,节点u可以被u的所有儿子节点v限制
所以如果u选了就至少有一个v不选，如果u不选v选和不选都无所谓 
dp[u][0]=∑max{dp[v][0],dp[v][1]}
dp[u][1]=1+max{dp[v][0]+∑max{dp[v'][0/1]}} 其中v'是u的儿子中除v以外的儿子,但是这个转移方程如果真的这么写肯定会超时的。怎么优化？
发现 ∑max{dp[v'][0/1]}就是dp[u][0]扣掉一个max{dp[v][0/1]}
然后方程可以优化成: 
dp[u][1]=1+max{dp[v][0]+dp[u][0]-max{dp[v][0/1]}}
=1+dp[u][0]+max{dp[v][0]-max{dp[v][0/1]}}
然后以lt为根跑一遍DP 
这样我们就得到了一个lt不能限制rt的方案dp1，答案为max{dp[lt][0/1]} 
然后把这个删掉的边考虑上去，强制让lt限制住rt,也就是说这个lt只能不投放,就是dp[lt][0],然后这个lt的儿子节点都不受限制了 
然后第二遍DP该怎么跑？
考虑到rt已经被限制了,所以他的儿子无论如何放都是合法的方案，所以第二次DP的状态转移方程就是：
对于u==rt(就是u被lt限制的情况)dp[u][1]=1+dp[u][0]
*/
```

---

## 作者：Little_duck_GGG (赞：0)

### 题目意思。
在一棵基环树上选一些点，使得对于被选集合中的**每一个**点都有至少一个**与其相连的且不在被选集合中**的点。
### 题目思路
遇到基环树我们首先肯定想着**在环上断边**，然后再断的边的左右端点做树形动规。我们考虑连接**单向边**。连接单向边后，其实这道题就变得很好做了。

首先我们考虑找环，~这里面向新手，大佬可以不看~。

对于一个单向图来说，一个点如果被走了两次那么它就一定再环上，因为对于一个环来说，环上的每个点都会被走**无数次**，而不在环上的点只会走**一次**，所以判断环的时候，只需找一个点出现**两次**，则它**必在环**上，则**它的父亲**也在环上。

现在给出找环的代码。

```cpp
int dfs(int x,int y)
{
	v[x]=1;//标记该点 
	if(v[vu[x]]==1) return x;//当出现过两次后返回当前值 
	return dfs(vu[x],x);//否则继续递归 
} 
```

接下来我们就知道在哪两个之间断边了。

那么我们就得开始做树形动规了。

我们设 $dp_{i,0}$ 表示如果不选择当前结点的最大贡献，设 $dp_{i,1}$ 表示如果选择当前结点的最大贡献。

先考虑 $dp_{i,0}$，对于不选择当前结点的情况，则此结点的儿子有两种选择，要么选要么不选则对于 $dp_{i,0}$，它的动规方程就是 $dp_{i,0} = dp_{i,0} + \operatorname{max}(dp_{son,0},dp_{son,1})$。

接下来考虑 $dp_{i,1}$，对于选择此结点的情况，则此时与 $dp_{i,0}$ 情况差不多，但是我们**必须注意**，此时我们**不能**把它的儿子全选了，所以我们要在 $dp_{i,0}$ 的基础下减去最小的 $\operatorname{max}(dp_{son,0},dp_{son,1})-dp_{son,1}$，而且因为我们当前此点选择了，所以还要**加一**。

下面给出树形动规代码。

```cpp
void dfs2(int x)
{
	v[x]=1;//注意这里标记一下，不然会超时 
	dp[x][0]=0;
	dp[x][1]=0;//清0 
	int fk=0;
	long long mi=0x3f3f3f3f; 
	for(int i=0;i<g[x].size();i++)
	{
		int son=g[x][i];
		if(son==a1) dp[son][1]=-0x3f3f3f3f;//如果此时枚举到了环上的结点，给它标记最小 
		else
		{
			dfs2(son);
			mi=min(mi,max(dp[son][1],dp[son][0])-dp[son][0]);//这里取最小 
			dp[x][0]+=max(dp[son][1],dp[son][0]); 
		}	
	} 
	dp[x][1]=dp[x][0]+1-mi;//转移方程 
} 
```
最终给出全部的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int tot,n,u,vu[1050000],a1,E,a2,head[1000005];
int v[1000005];
vector<int> g[1000005]; 
long long dp[1000005][2];
long long au;
int dfs(int x,int y)
{
	v[x]=1;//标记该点 
	if(v[vu[x]]==1) return x;//当出现过两次后返回当前值 
	return dfs(vu[x],x);//否则继续递归 
} 
void dfs2(int x)
{
	v[x]=1;//注意这里标记一下，不然会超时 
	dp[x][0]=0;
	dp[x][1]=0;//清0 
	int fk=0;
	long long mi=0x3f3f3f3f; 
	for(int i=0;i<g[x].size();i++)
	{
		int son=g[x][i];
		if(son==a1) dp[son][1]=-0x3f3f3f3f;//如果此时枚举到了环上的结点，给它标记最小 
		else
		{
			dfs2(son);
			mi=min(mi,max(dp[son][1],dp[son][0])-dp[son][0]);//这里取最小 
			dp[x][0]+=max(dp[son][1],dp[son][0]); 
		}	
	} 
	dp[x][1]=dp[x][0]+1-mi;//转移方程 
} 
int main()
{
	memset(head,-1,sizeof head);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&u);
		vu[i]=u;
		g[u].push_back(i);//单项边 
	}
	for(int i=1;i<=n;i++)
	{
		if(v[i]==1) continue;
		a1=dfs(i,-1);
		dfs2(a1);
		long long ans=dp[a1][0];
		ans=max(ans,dp[a1][1]); 
		a1=vu[a1];//它父亲 
		dfs2(a1);
		ans=max(ans,dp[a1][1]);//注意这里不能不取 
		au+=ans;//最后把所有环的答案累加 
	}
	cout<<au;
	return 0;
}
```

---


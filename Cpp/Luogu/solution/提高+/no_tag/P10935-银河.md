# 银河

## 题目描述

银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。

我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 $1$。

现在对于 $N$ 颗我们关注的恒星，有 $M$ 对亮度之间的相对关系已经判明。

你的任务就是求出这 $N$ 颗恒星的亮度值总和至少有多大。

## 说明/提示

数据保证，$1\le N \le 100000$，$1\le M \le 100000$。

## 样例 #1

### 输入

```
5 7 
1 1 2 
2 3 2 
4 4 1 
3 4 5 
5 4 5 
2 3 5 
4 5 1 ```

### 输出

```
11```

# 题解

## 作者：chzhh_111 (赞：28)

前置知识：**差分约束 $+$ 强连通 Tarjan $+$ 拓扑 DP**。

# 差分约束：

注意到，题目中所给出不等关系的约束都可以用 $x \ge y$ 以及 $x > y$ 来表示，同时 $x \ge y$ 和 $x > y$ 又可以用 $x \ge y + z$ 来表示，也就是：

- $x \ge y$ 转化为 $x \ge y + 0$
- $x > y$ 转化为 $x \ge y + 1$

所以都可以用这一关系来建图，$x \ge y + z$ 就是 $y$ 向 $x$ 连一条边，而边权就是 $z$。

# 强连通 Tarjan：

我们可以发现，当两个点在一个强连通图当中必然有这两个点的亮度相同，因为根据上述所说的建图方法能够得出来这个不小于是有传递性的，所以一条路的终点一定大于等于这一条路的起点，则成立。

因此就可以用 Tarjan 将所有的强连通预处理出来，这样子就可以把这个图变成了 DAG。

同时也可以发现，如果是这样的话，单个强连通里面的每一条边的边全都应该是 $0$。所以 $-1$ 的情况，就是如果发现在单个强连通里面有出现过一条边的边权是 $1$ 的情况。

在强连通的时候，预处理下每个强连通里面的节点数量，以后要用。

# 拓扑 DP：

题目中的亮度现在可以转化成从这个 DAG 的任意一点出发，所得到的最长路径的权值和是多少，发现可以用拓扑 DP 求解。

设 $dp_{i}$ 表示，从点 $i$ 的前驱转移到点 $i$ 的最长路径是多少，则动态转移方程就是：$dp_{i}= \max (dp_{j}+dis)$ 其中 $j$ 是 $i$ 的前驱，$dis$ 是从 $j$ 走到 $i$ 的权值是多少。

初始化是假如点 $i$ 的入度为零，则 $dp_{i} = 1$。

# 计算答案：

$ans = \displaystyle \sum_{i=1}^{tot} sum_{i} \times dp_{i}$

$tot$ 是强连通的数量。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+1;
int n,m,a,b,t,ls,z[N],zz[N],dfn[N],low[N],stak[N],top,tot,col[N],Time,sum[N],ru[N],q[N];
int f[N],ans;
struct bian{
	int qi,zhong,quan,zhi;
}s[N],ss[N];
void Tarjan(int x)
{
	dfn[x]=low[x]=++Time;
	stak[++top]=x;
	for(int i=z[x];i;i=s[i].zhi)
	{
		int u=s[i].zhong;
		if(!dfn[u])
		{
			Tarjan(u);
			low[x]=min(low[x],low[u]);
		}
		  else if(!col[u]) low[x]=min(low[x],low[u]);
	}
	if(low[x]==dfn[x])
	{
		col[x]=++tot;
		sum[tot]++;
		while(stak[top]!=x) sum[tot]++,col[stak[top--]]=tot;
		top--;
	}
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&t,&a,&b);
		if(t==1) s[++ls]=(bian){a,b,0,z[a]},z[a]=ls,s[++ls]=(bian){b,a,0,z[b]},z[b]=ls;
		else if(t==2) s[++ls]=(bian){a,b,1,z[a]},z[a]=ls;
		else if(t==3) s[++ls]=(bian){b,a,0,z[b]},z[b]=ls;
		else if(t==4) s[++ls]=(bian){b,a,1,z[b]},z[b]=ls;
		else s[++ls]=(bian){a,b,0,z[a]},z[a]=ls;
	}
	for(int i=1;i<=n;i++)
	  if(!dfn[i]) Tarjan(i);
	int len=ls;
	ls=0;
	for(int i=1;i<=len;i++)
	{
		int x=col[s[i].qi],y=col[s[i].zhong];
		if(x!=y) ss[++ls]=(bian){x,y,s[i].quan,zz[x]},zz[x]=ls,ru[y]++;
		  else if(s[i].quan) {printf("-1");return 0;}
	}
	int l=0,r=0;
	for(int i=1;i<=tot;i++) if(!ru[i]) q[++r]=i,f[i]=1;
	while(l<r)
	{
		l++;
		ans+=f[q[l]]*sum[q[l]];
		for(int i=zz[q[l]];i;i=ss[i].zhi)
		{
			int x=ss[i].qi,y=ss[i].zhong;
			if(f[y]<f[x]+ss[i].quan) f[y]=f[x]+ss[i].quan;
			if(!(--ru[y])) q[++r]=y;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ZinfI_Sh (赞：18)

[题目传送门](https://www.luogu.com.cn/problem/P10935)

省流：差分约束 $+$ 强连通分量 $+$ 拓扑 DP。

# Step 1 差分约束系统

不懂差分约束的看 [Link](https://oi-wiki.org/graph/diff-constraints/)。

题目中的五种关系复杂而冗余，有没有什么能够统一的方法呢？

这下就要请出一种常见的想法：$\tiny{\sout{请秦始皇}}$ 建立**差分约束系统。**

具体来讲，由于题目中结果恒星亮度一定为正整数，所以我们可以把 $5$ 种不等式转化为下面 $5$ 种：

+ $A=B$ 转为 $A\ge B$ 且 $B\ge A$
+ $A<B$ 转为 $B\ge A+1$
+ $A\ge B$ 转为 $A\ge B$
+ $A>B$ 转为 $A\ge B+1$
+ $A\le B$ 转为 $B\ge A$

通过这样的转化，我们就可以把 $5$ 种复杂的不等式均转化为 $5$ 种诸如 $x\ge y+d$ 的形式了。

这有什么用呢？很简单，若有 $A\ge B+d$，则从 $B$ 连一条至 $A$，权为 $d$ 的边，这下若 $u$ 向 $v$ 有一条连边，则节点 $u$ 它一定会 $\le v$。

所以接下来的几步就很显然了。

# Step 2 强连通分量

不懂强连通分量的看 [Link](https://oi-wiki.org/graph/scc/)。

为了后续通过某种神秘の小方法求出答案，我们需要先进行求强连通分量的操作。

通过求强连通分量的操作，同时我们也就可以判断无解的情况：

**若一个强连通分量中有一条边权为 $1$ 的边，则无解。**

比如下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/l8u4vzqk.png)

发现 $A\le B\le C$，又有 $C<A$，显然不成立，故**无解**。

求完后进行缩点，缩点后是一个 DAG，那么接下来这一步，是什么就不用我多说了吧。

# Step 3 拓扑 DP

不懂拓扑 DP 的看 [Link](https://oi-wiki.org/graph/topo/)。

接下来未指明的点都为缩点后的点。

我们记 $dp_{i}$ 表示点 $i$ 的“重量”，我们说过，若 $u$ 向 $v$ 有一条连边，代表 $u\le v$，则 $dp_{u}$ 也一定 $\le dp_{v}$。我们有如下转移式：

$$dp_{v}=\max\{dp_{u}+d_{u,v}\}$$

其中 $u$ 向 $v$ 有一条连边，$d_{u,v}$ 表示 $u$ 向 $v$ 的连边的权值。

$dp_{u}+d_{u,v}$ 很好理解，但为什么取 $\max$？这也很好理解，若取 $\min$，那么就会出现一个点 $v$，它只能满足它若干个前驱中的几个最小的约束关系了。

用拓扑 DP 可以很简洁的处理出 $dp_{i}$，这也是我们求强连通分量的一个原因。

现在考虑任意一个点 $i$ 对答案的贡献。这个 $i$ 是缩点后的一个结点，记原图缩成点 $i$ 的强连通分量的结点数为 $cnt_{i}$，则点 $i$ 对答案的贡献显然为：

$$cnt_{i}\times dp_{i}$$

这是因为同一个强连通分量的点不出现边权为 $1$ 的边，也就代表着**同一个强连通分量中的点的重量相等**，故用 $cnt_{i}$ 乘上 $dp_{i}$。

# AC 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define min(x, y) (x < y ? x : y)
#define max(x, y) (x > y ? x : y)
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
inline void read(int &res)
{
    char ch;
    bool un = 0;
    while (ch = getchar(), !isdigit(ch))
    {
        if (ch == '-')
            un = 1;
    }
    res = ch ^ 48;
    while (ch = getchar(), isdigit(ch))
        res = res * 10 + ch - 48;
    if (un)
    {
        res = -res;
    }
}
struct Edge
{
    int v, d;
};
vector<Edge> e[100001], af[100001];
int dfn[100001], low[100001], col[100001], cnt[100001], tick, tot;
stack<int> stak;
void tarjan(int x)
{
    dfn[x] = low[x] = ++tick;
    stak.push(x);
    for (auto tmp : e[x])
    {
        int v = tmp.v;
        if (!dfn[v])
        {
            tarjan(v);
            low[x] = min(low[x], low[v]);
        }
        else if (!col[v])
        {
            low[x] = min(low[x], dfn[v]);
        }
    }
    if (dfn[x] == low[x])
    {
        col[x] = ++tot;
        cnt[tot] = 1;
        while (stak.top() != x)
        {
            col[stak.top()] = tot;
            cnt[tot]++;
            stak.pop();
        }
        stak.pop();
    }
}
int ru[100001], dp[100001];
queue<int> q;
signed main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int t, a, b;
        cin >> t >> a >> b;
        if (t == 1)
        {
            e[a].push_back({b, 0});
            e[b].push_back({a, 0});
        }
        if (t == 2)
        {
            e[a].push_back({b, 1});
        }
        if (t == 3)
        {
            e[b].push_back({a, 0});
        }
        if (t == 4)
        {
            e[b].push_back({a, 1});
        }
        if (t == 5)
        {
            e[a].push_back({b, 0});
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if (!dfn[i])
        {
            tarjan(i);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (auto tmp : e[i])
        {
            int v = tmp.v, d = tmp.d;
            if (col[i] == col[v] && d == 1)
            {
                cout << "-1";
                return 0;
            }
            if (col[i] != col[v])
            {
                af[col[i]].push_back({col[v], d});
                ru[col[v]]++;
            }
        }
    }
    for (int i = 1; i <= tot; i++)
    {
        if (!ru[i])
        {
            q.push(i);
            dp[i] = 1;
        }
    }
    while (q.size())
    {
        int u = q.front();
        q.pop();
        for (auto tmp : af[u])
        {
            int v = tmp.v, d = tmp.d;
            dp[v] = max(dp[v], dp[u] + d);
            if (!--ru[v])
            {
                q.push(v);
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= tot; i++)
    {
        ans += dp[i] * cnt[i];
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Hughpig (赞：11)

对于这种若干个不等关系的题目显然可以用差分约束来做（模板见[此题](https://www.luogu.com.cn/problem/P5960)）。

具体地，对于一组 $A<B$ 的关系可以改写为 $A\le B+1$，我们可以从 $A$ 到 $B$ 连一条权值为 $1$ 的边；$A>B$ 或 $A\le B$ 这些同理。对于 $A=B$ 我们可以把它拆成 $A\le B$ 和 $A\ge B$ 两组关系，然后类似地连边即可。

由于要求每颗恒星的亮度最低为 $1$，因此要从一个超级源点出发向每个星星连一条长为 $1$ 都边。

用 SPFA 跑最长路，最后所有点的距离之和即为答案。

但这题 $N,M\le 10^5$，按道理来说直接跑 SPFA 最坏时间复杂度是 $O(NM)$ 的，会 TLE（实测会在第 $5$ 个点 TLE，得 $90$ 分）。

但是我们可以用奇妙方式优化 SPFA，让它跑得飞快。

考虑使用 SLF 优化。把算法中的队列改为双端队列。用 SPFA 求最长路时，如果当前松弛的点的距离大于队头的距离，即当前点看起来似乎更优，那么就放到队头，否则放到队尾。如果求最短路是同理的。

这样做它跑得飞快，本来 TLE 的第五个点现在只要跑 $10$ ms 就能冲过去。

拓展：本题有个[双倍经验](https://www.luogu.com.cn/problem/P3275)，那题加了强大的 hack 数据卡掉了 SPFA，该怎么办呢？

考虑继续优化，用卡时的技巧，如果一个数据很久没跑出来我们就认为它没啥前途了，直接输出 `-1` 退出。

具体地，我们统计 SPFA 里点的处理总次数，如果发现这个值大于了 $5\times 10^7$ 就认为无解。然后就能冲过所有的 hack 数据了。

---

## 作者：huangjialuo (赞：10)

## 思路

###  差分约束：

拿到这道题，一看给出 A 和 B 的一些关系，容易发现这就是差分约束系统。

那么我们该怎么建立差分约束系统呢？

我们可以将每一种情况转换为下列不等式：

1. $\ A \ = B$ 转换为 $\ A \geq B$。

2. $\ A \ < B$ 转换为 $\ B \geq A + 1$。

3.   $\ A \geq B$ 不变。

4. $\ A \ > B$ 转换为 $\ A \geq B + 1$。 

5. $\ A \leq B$ 转换为 $\ B \geq A$。

那么我们就可以通过上列不等式来建图， 再建一个超级源点，跑一遍 SPFA 判正环(会超时)。

### 方法一：

#### SPFA $+$ DFS 优化(不稳定，应该是数据太水了才过的) 

对于此题，其实是可以通过 SPFA 来做的，这是最容易实现的方法。我们求解从源点到所有节点的最长路径，同时检测是否存在正环，有正环即无解。有解时，将所有边的最长路累加。

但是都知道到 SPFA 的最坏时间复杂度是 $O(N \cdot M  )$，显然会超时，所以会使用最为简单好写的栈来优化，但是依然会 TLE 一个点。

这时候或许只能用 Tarjan $+$ 拓扑 DP？

但是 SPFA 还有一种优化叫 DFS 优化，具体见[SPFA算法的优化](https://pursuit.blog.csdn.net/article/details/107694885?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2)。

我们使用 DFS 优化就可以过掉本题。

### 方法二：

#### Tarjan $+$ 拓扑 DP

我们先用 Tarjan 求 SCC，在求完 SCC 后，我们顺带判断无解的情况：如果边的两端点在同一个强连通分量中，且边权大于 0，存在矛盾，无解。

不存在无解时就在缩点后的图加新边。

接着就是 拓扑 DP 最长路，我们根据新图进行递推算最长路，因为将问题转化为差分约束系统后，通过强连通分量缩点将图转化为有向无环图 (DAG)，进而利用拓扑排序的顺序进行 DP，就可以算出满足所有约束的最小亮度值。

最后把每个强连通分量总和加起来就可以得出答案。

#### 注：要开 long long。

---

## CODE：

### SPFA $+$ DFS优化：

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define pk pop_back
#define x first
#define y second
#define PII pair<int, int>
#define int long long
#define endl '\n'

using namespace std;

const int N = 2e5 + 10;

int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];                        // 存储最长路径长度
int st[N];                          // 标记节点是否在队列中
int cnt[N];                         // 记录节点入队次数，用于检测环
int flag = 0;                       // 标记是否存在正环

inline void add(int a, int b, int c) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

// SPFA算法，使用DFS实现（递归方式）
inline void spfa(int u) {
    // 如果节点入队次数超过n，说明存在正环
    if (cnt[u] >= n) {
        flag = 1;
        return ;
    }

    st[u] = 1;  // 标记当前节点在队列中
    for (int i = h[u]; ~i; i = ne[i]) { 
        int j = e[i];
        // 松弛操作：如果找到更长的路径，更新距离
        if (dist[j] < dist[u] + w[i]) {
            dist[j] = dist[u] + w[i];
            if (!st[j]) {  // 如果节点j不在队列中，加入队列
                st[j] = 1;
                spfa(j);  // 递归处理节点j
                if (flag) return ;  // 如果发现正环，直接返回
                cnt[j]++;  // 更新节点j的入队次数
            }
        }
    }
    st[u] = 0;  // 回溯，标记当前节点不在队列中
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    memset(h, -1, sizeof h);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> c >> a >> b;
        if (c == 1) add(a, b, 0), add(b, a, 0);  // A=B → A≥B且B≥A
        else if (c == 2) {
            if (a == b) {  // 特殊情况：A<B且A=B，矛盾，直接输出-1
                cout << "-1" << endl;
                return 0;
            }
            add(a, b, 1);  // A<B → B≥A+1
        }
        else if (c == 3) add(b, a, 0);  // A≥B → B→A
        else if (c == 4) {
            if (a == b) {  // 特殊情况：A>B且A=B，矛盾，直接输出-1
                cout << "-1" << endl;
                return 0;
            }
            add(b, a, 1);  // A>B → B→A, 1
        }
        else {
            add(a, b, 0);  // A≤B → A→B, 0
        }
    }

    // 添加超级源点0
    for (int i = n; i >= 1; i--) add(0, i, 1);

    dist[0] = 0, st[0] = 1;
    spfa(0);  // 从源点开始SPFA算法
    
    if (flag) cout << "-1" << endl;  // 存在正环，无解
    else {
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] < 0x3f3f3f3f) ans += dist[i];
        }
        cout << ans << endl;
    }

    return 0;
}
```

---

### Tarjan $+$ 拓扑 DP：

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define pk pop_back
#define x first
#define y second
#define PII pair<int, int>
#define int long long
#define endl '\n'

using namespace std;

const int N = 1e5 + 10, M = 6e5 + 10;

int n, m;
int h[N], hs[N];           // 原图和缩点后的图的邻接表表头
int e[M], ne[M], w[M], idx; // 边的终点、下一条边、边权和边的索引
int dfn[N], low[N], timestamp; // Tarjan算法中的时间戳和追溯值
int stk[N], top;           // 栈和栈顶指针
bool in_stk[N];            // 标记节点是否在栈中
int id[N], scc_cnt, scc_size[N]; // 节点所属强连通分量编号、强连通分量总数、各强连通分量大小
int dist[N];               // 缩点后图中各强连通分量的最长路径

void add(int h[], int a, int b, int c) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

// Tarjan算法求强连通分量
void tarjan(int u) {
    dfn[u] = low[u] = timestamp++;
    stk[++top] = u, in_stk[u] = true;

    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (in_stk[j]) {
            low[u] = min(low[u], dfn[j]);
        }
    }

    // 找到一个强连通分量的根节点
    if (dfn[u] == low[u]) {
        scc_cnt++;
        int y;
        do {
            y = stk[top--];
            in_stk[y] = false;
            id[y] = scc_cnt;
            scc_size[scc_cnt]++;
        } while (y != u);
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    // 建超级源点
    for (int i = 1; i <= n; i++) add(h, 0, i, 1);

    while (m--) {
        int t, a, b;
        cin >> t >> a >> b;
        if (t == 1) add(h, b, a, 0), add(h, a, b, 0); // a==b
        else if (t == 2) add(h, a, b, 1); // a < b
        else if (t == 3) add(h, b, a, 0); // a >= b
        else if (t == 4) add(h, b, a, 1); // a > b
        else add(h, a, b, 0); // a <= b
    }

    // 从超级源点开始Tarjan算法，求强连通分量
    tarjan(0);

    // 检查是否存在矛盾
    bool success = true;
    for (int i = 0; i <= n; i++) {
        for (int j = h[i]; ~j; j = ne[j]) {
            int k = e[j];
            int a = id[i], b = id[k];
            // 如果边的两端点在同一个强连通分量中，且边权大于0，存在矛盾
            if (a == b) {
                if (w[j] > 0) {
                    success = false;
                    break;
                }
            } else {
                // 否则在缩点后的图中添加边
                add(hs, a, b, w[j]);
            }
        }
        if (!success) break;
    }

    if (!success) cout << "-1";
    else {
        // 拓扑序已由Tarjan算法的逆序给出，直接求最长路
        for (int i = scc_cnt; i; i--) {
            for (int j = hs[i]; ~j; j = ne[j]) {
                int k = e[j];
                dist[k] = max(dist[k], dist[i] + w[j]);
            }
        }

        // 计算总和，每个强连通分量的最长路径乘以其大小
        int res = 0;
        for (int i = 1; i <= scc_cnt; i++) res += dist[i] * scc_size[i];
        cout << res;
    }

    return 0;
}
```

---

## 作者：ElmPoplar (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10935)

## 解题思路

让我们解这么多不等式，很明显就是**差分约束**了，稍微转换一下就可以用图来解了。一般按常理来说用 spfa 就行啦，不过这新添的 hack 数据弄了链，~~果然 SPFA 还是死了~~，而且我还是一个忠实的 DP 爱好者，所以我们就只能用 **tarjan 缩点**后跑**拓扑序 DP** 了。

不过我们还是来口胡一下这道题的差分约束，比如当 $x=2$ 的时候， $a < b$ ，很明显 $a$ 和 $b$ 都是整数，所以可以改成 $a+1\le b$ ，翻转过来就是 $b\ge a+1$ ，这就跟我们最短路(其实这里是最长路)的三角形不等式 $dis_y \ge dis_x+w$ 很相似了，那么我们把 $b\ge a+1$ 转换成从 $a$ 到 $b$ 权值为 $1$ 的一条边，然后用最长路让 $dis$ 收敛让不等式组成立，求和就行了。不过在差分约束中我们常常要考虑负环这个事情，不过这道题是正环罢了。

~~这里 SPFA 的做法就不过多阐述了，毕竟死了~~。

我们这里来说一下 tarjan 缩点跑拓扑序 DP 的做法。 tarjan 缩点后的图很明显是一张有向无环图，这就给跑拓扑序 DP 提供了条件。其实在这里处理正环变得十分简单，强连通分量肯定是环，图中权值除了 $1$ 就是 $0$ (笑，所以强连通分量只要有权值为 $1$ 的边那么这张图肯定就有正环，那么正环的问题就被很优美地解决了。

既然强连通分量里面的边权值都为 $0$ 且为环，那么缩点后用拓扑序 DP 求出最长路，该强连通分量总糖果数的最小值就应该是此强连通分量的最长路的解乘上该强连通分量中的恒星个数，因为强连通分量里只有权值 $0$ ，我们既然求得了这个强连通分量的最小权值，那么我们要让这个总数最小，那就让强连通分量里的每一个点都是这个权值，那么就最小啦，然后把每个强连通分量总和加起来就可以得出答案啦。

## Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
int n, m;
long long ans;

struct Edge {
	int to, next, w;
} g[N], g_c[N];

int cnt = 0, head[N];

void add(int u, int v, int w) {
	g[++ cnt].next = head[u];
	g[cnt].to = v;
	g[cnt].w = w;
	head[u] = cnt;
}

int cnt_c = 0, head_c[N];

void add_c(int u, int v, int w) {
	g_c[++ cnt_c].next = head_c[u];
	g_c[cnt_c].to = v;
	g_c[cnt_c].w = w;
	head_c[u] = cnt_c;
}

int tot = 0, col = 0, dfn[N], low[N], color[N], num[N];
bool instack[N];
stack<int> stk;

void tarjan(int u) {
	dfn[u] = low[u] = ++ tot;
	stk.push(u);
	instack[u] = true;
	
	for (int i = head[u]; i; i = g[i].next) {
		int v = g[i].to;
		
		if (! dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
		} else if (instack[v])
			low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		color[u] = ++ col;
		num[col] ++;
		while (stk.top() != u) {
			color[stk.top()] = col;
			num[col] ++;
			instack[stk.top()] = false;
			stk.pop();
		}
		instack[u] = false;
		stk.pop();
	}
}

int in[N], f[N];

void toposort() {
	queue<int> q;
	for (int i = 1; i <= col; i ++)
		if (! in[i]) q.push(i), f[i] = 1;
	
	while (! q.empty()) {
		int x = q.front(); q.pop();
		
		for (int i = head_c[x]; i; i = g_c[i].next) {
			f[g_c[i].to] = max(f[g_c[i].to], f[x] + g_c[i].w);
			if (-- in[g_c[i].to] == 0)
				q.push(g_c[i].to);
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i ++) {
		int x, a, b;
		scanf("%d%d%d", &x, &a, &b);
		
		switch (x) {
			case 1: add(a, b, 0), add(b, a, 0); break;
			case 2: add(a, b, 1); break;
			case 3: add(b, a, 0); break;
			case 4: add(b, a, 1); break;
			case 5: add(a, b, 0); break;
		}
	}
	
	for (int i = 1; i <= n; i ++)
		add(n + 1, i, 0);
	
	for (int i = 1; i <= n; i ++)
		if (! dfn[i])
			tarjan(i);
			
	for (int i = 1; i <= n; i ++)
		for (int j = head[i]; j; j = g[j].next) {
			if (color[i] != color[g[j].to]) {
				add_c(color[i], color[g[j].to], g[j].w);
				in[color[g[j].to]] ++;		
			} else if (g[j].w == 1) {
				printf("-1\n");
				return 0;
			}
		}
		
	toposort();
	
	for (int i = 1; i <= col; i ++)
		ans += (long long) f[i] * num[i];
	
	printf("%lld\n", ans);
	
	return 0;
}
```

---

## 作者：meifan666 (赞：3)

### 题目大意
有
$N$
个点，每个点有唯一亮度值，并有
$M$
个式子比较几个点之间的亮度值，问是否有解，若有解输出亮度值总和的最小值。
### 思路
像这种两个数之间的不等式关系，不难想到**差分约束**，将
$N$
个点根据条件连边（具体怎么连边其他题解都讲过，不再赘述），若出现正环则无解。

那么怎么找正环呢？最好想的当然是使用
$O(nm)$
的
SPFA
求解，但在
$N,M\le10^5$
的条件下显然会超时。分析题目，观察性质。

我们发现，所连的边中边权非
$0$
即
$1$，于是我们可以用
**tarjan**
先求强连通分量，若出现一条边权为
$1$
的边连接了两个同属一个强连通分量的点，那么显然就出现了正环。

最后统计答案时，我们也可以在缩点的基础上跑一遍拓扑
dp
，取最长路，就是该点的亮度值，然后统计和即可。

下面贴上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,x,a,b,sum,f[100100],cnt,ans,dp[100100];
int siz[100100];
struct road{
	int fro,to,val;
};
vector<road>p1[100010],p2[100010],p3[100010];
bool vis[100010];
stack<int>st;
void dfs1(int x){
	vis[x]=1;
	for(int i=0;i<p1[x].size();i++)
		if(!vis[p1[x][i].to])
			dfs1(p1[x][i].to);
	st.push(x);
}
void dfs2(int x,int opt){
	vis[x]=0,f[x]=opt;
	for(int i=0;i<p2[x].size();i++)
		if(vis[p2[x][i].to])
			dfs2(p2[x][i].to,opt);
}
void topo(){
	queue<int>p;
	for(int i=1;i<=n;i++){
		dp[i]=1;
		if(siz[i]==0)p.push(i);
	}
	while(!p.empty()){
		int t=p.front();p.pop();
		for(int i=0;i<p3[t].size();i++){
			dp[p3[t][i].to]=max(dp[p3[t][i].to],dp[t]+p3[t][i].val);
			--siz[p3[t][i].to];
			if(siz[p3[t][i].to]==0)p.push(p3[t][i].to);
		}
	}
}
signed main(){
	cin>>n>>m;
	while(m--){
		cin>>x>>a>>b;
		if(x==1){
			p1[a].push_back({a,b,0});
			p1[b].push_back({b,a,0});
			p2[a].push_back({a,b,0});
			p2[b].push_back({b,a,0});
		}else if(x==2){
			p1[a].push_back({a,b,1});
			p2[b].push_back({b,a,1});
		}else if(x==3){
			p1[b].push_back({b,a,0});
			p2[a].push_back({a,b,0});
		}else if(x==4){
			p1[b].push_back({b,a,1});
			p2[a].push_back({a,b,1});
		}else{
			p1[a].push_back({a,b,0});
			p2[b].push_back({b,a,0});
		}
	}
	for(int i=1;i<=n;i++)
		if(!vis[i])dfs1(i);
	while(!st.empty()){
		int t=st.top();st.pop();
		if(vis[t])dfs2(t,++cnt);
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<p1[i].size();j++){
			if(f[i]==f[p1[i][j].to]){
				if(p1[i][j].val>0)return puts("-1")&&0;
				continue;
			}
			p3[f[i]].push_back({f[i],f[p1[i][j].to],p1[i][j].val});
			++siz[f[p1[i][j].to]];
		}
	}
	topo();
	for(int i=1;i<=n;i++)
		ans+=dp[f[i]];
	cout<<ans;
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：2)

好家伙，就是四川省选的糖果一题，连数据都一毛一样。

看到题目，直接差分约束。

对于一个 $T_a-T_b\ge u$ 可以直接转化为从 $a$ 向 $b$ 连条长度为 $u$ 的有向边。

$T_a-T_b\le u$ 同理，转化为 $T_b-T_a \ge -u$。

接着建立虚点 $0$，因为亮度最少为 $1$，所以直接从 $0$ 向每个点连个长度为 $1$ 的边。

从 $0$ 跑最长路就行。

输入建边。

```cpp
cin>>n>>m;
for(int i=1;i<=m;i++){
	int opt,a,b;
	cin>>opt>>a>>b;
	switch(opt){
		case 1:add(a,b,0),add(b,a,0);break;
    	case 2:add(a,b,1);break;
    	case 3:add(b,a,0);break;
    	case 4:add(b,a,1);break;
    	case 5:add(a,b,0);break;
    }
}
for(int i=1;i<=n;i++) add(0,i,1);
```

跑个 spfa 就可以拿下吗？

好吧，不能，使用 SLF 优化也不能。

有菊花图，看过测试点。

当然看原题讨论区，可以用枚举次数大于 $50000000$ 直接输出 $-1$ 解围通过。

但是这是错的。

发现边权只有 $0$ 和 $1$。

又发现有正环直接输出 $-1$。

如果一个强连通分量里的边有一条边权为 $1$ 就一定有正环。

所以正环以外的都是 $0$ 权环，直接缩点。

在一个强连通分量内部的点权都一样。

缩点跑拓扑即可。

时间复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int n,m;
int _head[100010],from[300010],to[300010],val[300010],nxt[300010],tot;
inline void add(int u,int v,int w){
	to[++tot]=v,from[tot]=u,val[tot]=w;
	nxt[tot]=_head[u];
	_head[u]=tot;
}
int dfn[100010],low[100010],idx;
int st[100010],top,ins[100010];
int scc[100010],scc_cnt;
int siz[100010];
void dfs(int x){
	dfn[x]=++idx,low[x]=dfn[x];
	st[++top]=x,ins[x]=1;
	for(int i=_head[x];i;i=nxt[i]){
		if(!dfn[to[i]]) dfs(to[i]),low[x]=min(low[x],low[to[i]]);
		else if(ins[to[i]]) low[x]=min(low[x],dfn[to[i]]);
	}
	if(dfn[x]==low[x]){
		scc_cnt++;
		while(st[top]!=x){
			scc[st[top]]=scc_cnt;
			ins[st[top]]=0,top--;
			siz[scc_cnt]++;
		}
		scc[x]=scc_cnt;
		ins[x]=0,top--;
		siz[scc_cnt]++;
	}
}
vector<int>v[100010],w[100010];
int d[100010];
int q[100010],head,tail;
int dis[100010];
void top_sort(){
	head=1,tail=0;
	for(int i=1;i<=scc_cnt;i++) if(!d[i]) q[++tail]=i;
	while(head<=tail){
		int u=q[head++];
		for(int i=0;i<v[u].size();i++){
			dis[v[u][i]]=max(dis[v[u][i]],dis[u]+w[u][i]);
			if(--d[v[u][i]]==0) q[++tail]=v[u][i];
		}
	}
}
signed main() {
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int opt,a,b;
		cin>>opt>>a>>b;
		switch(opt){
			case 1:add(a,b,0),add(b,a,0);break;
			case 2:add(a,b,1);break;
			case 3:add(b,a,0);break;
			case 4:add(b,a,1);break;
			case 5:add(a,b,0);break;
		}
	}
	for(int i=1;i<=n;i++) add(0,i,1);
	dfs(0);
	for(int i=1;i<=tot;i++){
		if(scc[from[i]]==scc[to[i]]){
			if(val[i]==1){
				cout<<"-1\n";
				return 0;
			}
			continue;
		}
		v[scc[from[i]]].push_back(scc[to[i]]);
		w[scc[from[i]]].push_back(val[i]);
		d[scc[to[i]]]++;
	}
	top_sort();
	int ans=0;
	for(int i=1;i<=scc_cnt;i++) ans+=siz[i]*dis[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：hjhAKIOI (赞：2)

# P10935 银河题解

## 题目描述

现在对于 $N$ 颗恒星，有 $M$ 对亮度之间的相对关系已经判明，并且这些恒星的亮度为**正整数。**

你有一些恒星之间亮度的关系，现在你的任务就是求出这 $N$ 颗恒星的亮度值总和至少有多大。

大小关系有以下几种：

1. $A$ 和 $B$ 亮度相等。  
2. $A$ 的亮度小于 $B$ 的亮度。  
3. $A$ 的亮度不小于 $B$ 的亮度。  
4. $A$ 的亮度大于 $B$ 的亮度。  
5. $A$ 的亮度不大于 $B$ 的亮度。

数据范围：$1\le N \le 100000,1\le M \le 100000$

## 题意分析

把这 $N$ 个恒星的亮度看作是 $N$ 个数，那这 $M$ 条关系是一些关于它们的不等式，那我们就知道这其实是一个**差分约束系统**。

## 做题思路

对于这上面的五种关系，我们需要把它们进行转化。并且由于题目要求总和最小，所以我们应该转化为最长路判正环。转化如下：

1. $A=B$，即 $A-B\ge 0$ 且 $B-A\ge 0$。
2. $A<B$，即 $B-A\ge 1$。
3. $A\ge B$，即 $A-B\ge 0$。
4. $A>B$，即 $A-B\ge 1$。
5. $A\le B$，即 $B-A\ge 0$。

同时，题目要求每个数为正整数，我们可以把这个条件转化为 $A-0\ge 1$，其中 $1\le A\le N$。

这样，我们把这道题目转化为了正常的差分约束系统。

对于一个差分约束系统，一般的做法对于关系 $A-B\ge k$，建一条从 $B$ 到 $A$ 长度为 $k$ 的边，同时建立超级源点后跑 Bellman-Ford 或者 SPFA。

但是如果这么跑会 TLE。于是我们需要思考更快的算法。

考虑到本题的边权不是 $0$ 就是 $1$，我们发现这张图不存在正环**当且仅当在这张图的每个环中都不存在边权为 $1$ 的边**。推广一下，可以得出有解当且仅当在这张图的**每个强连通分量中都不存在边权为 $1$ 的边。**

于是我们可以使用 Tarjan 算法求出图中的每个强连通分量，如果在某个强连通分量中存在 $1$ 权边则直接判断无解。

否则如果有解，则每个强连通分量中的点**一定相等。** 这是由于对于强连通分量中的任意两个点 $A$ 和 $B$，$A$ 可以通过 $0$ 权边到达 $B$，即 $B-A\ge 0$。同时 $B$ 也可以通过 $0$ 权边到达 $A$，所以 $A-B\ge 0$。由上可以推出 $A=B$。

于是我们对这张图的强连通分量进行缩点，可以得到一张**有向无环图**，并且每条边的边权不是 $1$ 就是 $0$。我们在这样一张图上从 $0$ 开始求最长路就可以解决这个问题。

这个问题如何解决？非常显然，只要按拓扑序执行 DP 就可以。

于是，问题愉快的解决了。

## 时间/空间复杂度分析

### 时间复杂度

Tarjan 算法、缩点、拓扑序 DP 的时间复杂度均为 $O(N+M)$，统计答案需要 $O(N)$，所以整个算法的时间复杂度为 $O(N+M)$，可以通过此题。

### 空间复杂度

Tarjan 算、存强连通分量需要 $O(N)$ 的额外空间，存图和缩点后的图需要 $O(N+M)$ 的空间，所以整个算法的空间复杂度为 $O(N+M)$，可以通过此题。

## 实现细节

需要注意的是要开 `long long`，并且关系一会存两条边，至少需要开两倍的空间。

---

至此，所有的问题得到了解决。

下面给出本题的 AC 代码：

```cpp
#include<iostream>
#include<vector>
#include<queue>
#define int long long
using namespace std;
const int N=2e5+5,M=4e5+5;
int n,m,tot,cnt,num,top,totc,ans;
int head[N],ver[M],Next[M],edge[M],d[N],dfn[N],low[N],f[N],deg[N],c[N];  //f是缩点后的最长路
int vc[M],hc[N],nc[M],ec[M];  //缩点后的图
int st[N];    //栈
bool ins[N];  //是否在栈中

vector<int> scc[N];  //强连通分量

void add(int x,int y,int z){
	ver[++tot]=y;
	edge[tot]=z;
	Next[tot]=head[x];
	head[x]=tot;
}

void add_c(int x,int y,int z){
	vc[++totc]=y;
	ec[totc]=z;
	nc[totc]=hc[x];
	hc[x]=totc;
	deg[y]++;
}

void tarjan(int x){
	dfn[x]=low[x]=++num;
	st[++top]=x;
	ins[x]=1;
	for(int i=head[x];i;i=Next[i]){
		int y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y]){
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(dfn[x]==low[x]){
		cnt++;
		int y;
		do{
			y=st[top];
			top--;
			ins[y]=0;
			c[y]=cnt;
			scc[cnt].push_back(y);
		}while(x!=y);
	}
}

void toposort(){
	queue<int> q;
	for(int i=1;i<=cnt;i++){
		if(!deg[i]){
			q.push(i);
		}
	}
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=hc[x];i;i=nc[i]){
			int y=vc[i];
			deg[y]--;
			f[y]=max(f[y],f[x]+ec[i]);
			if(!deg[y]){
				q.push(y);
			}
		}
	}
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1){
			add(x,y,0);
			add(y,x,0);
		}
		if(op==2){
			add(x,y,1);
		}
		if(op==3){
			add(y,x,0);
		}
		if(op==4){
			add(y,x,1);
		}
		if(op==5){
			add(x,y,0);
		}
	}
	for(int i=1;i<=n;i++){
		add(0,i,1);
	}
	for(int i=0;i<=n;i++){
		if(!dfn[i]){
			tarjan(i);
		}
	}
	for(int i=0;i<=n;i++){
		for(int j=head[i];j;j=Next[j]){
			int y=ver[j];
			if(c[i]==c[y]){
				if(edge[j]){      //存在1权边，无解
					cout<<-1;
					return 0;
				}
				continue;
			}
			add_c(c[i],c[y],edge[j]);
		}
	}
	toposort();
	for(int i=1;i<=n;i++){
		d[i]=f[c[i]];
		ans=(long long)ans+(long long)d[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：JustPureH2O (赞：1)

[更好的阅读体验](https://justpureh2o.cn/articles/7830)

题目地址：[P10935](https://www.luogu.com.cn/problem/P10935)

题目给出的大小关系可以转化为如下不等式组：

$$
\begin{cases}
A\leq B,B\leq A
\\A\leq B+1
\\A\geq B
\\A\geq B+1
\\A\leq B
\end{cases}
$$

且需要满足亮度均大于等于 ${1}$，那么这道题就有两种做法：

## 差分约束

差分约束可以通过把若干形如 $x_1\leq x_2+c$ 的不等式组转化为图论问题来求得不等式组的特解。做法是把大的那部分向小的部分连一条长为 $c$ 的有向边，本例中就是有向边 $(x_2,x_1,c)$。题目要求亮度至少为 $1$，让一个虚拟源点向所有点连一条权值为 $1$ 的有向边即可。

然后注意到有一个结论，要求出未知量的最小值，就需要在新图上做最长路，反之做最短路，这两种情况无解当且仅当图中存在正环/负环。

因而可以使用 $\mathcal O(nm)$ 的 $\texttt{SPFA}$ 来求解，但是数据范围都是 ${10^5}$ 级别的，这条路不可取。于是我们转而寻找更优的策略解答。

## 强连通分量

强连通分量是指图中的极大强连通子图，而有向图强连通当且仅当图中任意两个点连通。

根据这个定义，有向图的强连通分量中必定会存在至少一个环（单点构成的强连通分量除外），考虑到建出的图中边权只会是 $0/1$，因此整张图存在正环当且仅当某个强连通分量中出现了长度为正数的边。

同样需要虚拟源点，使用 $\texttt{Tarjan}$ 算法能够在 $\mathcal O(n+m)$ 复杂度内解决。

```cpp
#include <bits/stdc++.h>

#define N 100010
#define M 300010
using namespace std;

typedef long long ll;

struct Edge {
    int to, ne, w;
} edges[M << 1];
int h[N], hs[N], idx = 0;
int scc_cnt = 0, dfs_cnt = 0;
int scc_id[N], scc_size[N];
int dfn[N], low[N];
int dist[N];
stack<int> stk;
bool in_stk[N];

void add(int head[], int a, int b, int w) {
    idx++;
    edges[idx].to = b;
    edges[idx].ne = head[a];
    edges[idx].w = w;
    head[a] = idx;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++dfs_cnt;
    stk.push(u);
    in_stk[u] = true;
    for (int i = h[u]; ~i; i = edges[i].ne) {
        int j = edges[i].to;
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (in_stk[j]) {
            low[u] = min(low[u], dfn[j]);
        }
    }
    if (dfn[u] == low[u]) {
        scc_cnt++;
        int t;
        do {
            t = stk.top();
            stk.pop();
            in_stk[t] = false;
            scc_id[t] = scc_cnt;
            scc_size[scc_cnt]++;
        } while (t != u);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);

    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) add(h, 0, i, 1);
    while (m--) {
        int t, a, b;
        cin >> t >> a >> b;
        if (t == 1) {
            add(h, a, b, 0);
            add(h, b, a, 0);
        } else if (t == 2) add(h, a, b, 1);
        else if (t == 3) add(h, b, a, 0);
        else if (t == 4) add(h, b, a, 1);
        else add(h, a, b, 0);
    }
    tarjan(0);
    for (int i = 0; i <= n; i++) {
        for (int j = h[i]; ~j; j = edges[j].ne) {
            int k = edges[j].to;
            int a = scc_id[i], b = scc_id[k];
            if (a == b) {
                if (edges[j].w > 0) {
                    cout << -1 << endl;
                    return 0;
                }
            } else add(hs, a, b, edges[j].w);
        }
    }
    for (int i = scc_cnt; i >= 1; i--) {
        for (int j = hs[i]; ~j; j = edges[j].ne) {
            int k = edges[j].to;
            dist[k] = max(dist[k], dist[i] + edges[j].w);
        }
    }
    ll res = 0;
    for (int i = 1; i <= scc_cnt; i++) res += dist[i] * scc_size[i];
    cout << res << endl;
    return 0;
}
```

## 后记

这道题启示我们，某些差分约束的题目可以使用强连通分量加速求解。

发现这道题和 [P3275 [SCOI2011] 糖果](https://www.luogu.com.cn/problem/P3275) 很像，没错，这是双倍经验！

$\texttt{The End}$

---

## 作者：Brilliant11001 (赞：1)

#### [更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18391686)

## [题目传送门](https://www.luogu.com.cn/problem/P10935)

这道题很有意思，（看上去像数据结构似的），考察的就是差分约束的掌握熟练程度和 Tarjan 算法的灵活变通。

首先发现要求最小值，所以跑**最长路**，并将所有关系都转化成**大于或大于等于**。

设 $x_i$ 表示第 $i$ 颗恒星的亮度值。

一共有五种关系，分类讨论：

第一种操作：$x_a = x_b$，~~根据 whk 上经常使用的方法~~可以转化为 $x_a \le x_b$ 且 $x_a \ge x_b$，所以在 $a,b$ 间连一条长度为 $0$ 的无向边。

第二种操作：$x_a < x_b$，由于亮度值一定是整数，所以转化为 $x_b - x_a \ge 1$，所以从 $a$ 向 $b$ 连一条长度为 $1$ 的有向边。

第三种操作：$x_a \ge x_b$，转化为 $x_a - x_b\ge 0$，所以从 $a$ 向 $b$ 连一条长度为 $0$ 的有向边。

第四种操作：$x_a > x_b$，由于亮度值一定是整数，所以转化为 $x_a - x_b \ge 1$，所以从 $b$ 向 $a$ 连一条长度为 $1$ 的有向边。

第五种操作：$x_a \le x_b$，转化为 $x_a - x_b\le 0$，所以从 $a$ 向 $b$ 连一条长度为 $0$ 的有向边。

考虑到恒星的亮度最暗是 $1$，所以建立一个超级源点 $0$，向每个点连一条长度为 $1$ 的边。

最后在 $0$ 号点跑 spfa 求最长路，累加答案，若出现了正环就说明无解（因为你不能自己大于自己嘛）。

时间复杂度 $O(nm)$。

不出所料会 TLE，因为我们的 spfa 算法~~实在是太快啦~~。

又考虑到边权只有两种，$0$ 或 $1$，由于出现正环一定无解，所以有解的情况**要么就没有环，要么就只有边权和为 $0$ 的环**，第一种情况可以直接根据拓扑排序递推，第二种情况边权和为 $0$ 的环显然没有用，直接用 Tarjan 缩掉，然后也可以根据拓扑排序递推了。

然后这道题就做完了，时间复杂度 $O(n + m)$。

$\texttt{Code:}$

```cpp
#include <queue>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010, M = 400010; //这里存边的数组要多开一点

int n, m;
int h[N], hc[N], e[M << 1], w[M << 1], ne[M << 1], idx;
int stk[N], top;
int dfn[N], low[N], scc_cnt, id[N], scc_siz[N], tim;
int dist[N];
bool st[N];

void add(int h[], int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++tim;
    stk[++top] = u, st[u] = true;
    for(int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if(!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if(st[j]) low[u] = min(low[u], dfn[j]);
    }
    if(dfn[u] == low[u]) {
        int y;
        scc_cnt++;
        do {
            y = stk[top--], st[y] = false;
            scc_siz[scc_cnt]++;
            id[y] = scc_cnt;
        }while(y != u);
    }
}

int main() {
	memset(h, -1, sizeof h);
    memset(hc, -1, sizeof hc);
	scanf("%d%d", &n, &m);
	int op, a, b;
	for(int i = 1; i <= n; i++) add(h, 0, i, 1);
	for(int i = 1; i <= m; i++) {
		scanf("%d%d%d", &op, &a, &b);
		if(op == 1) add(h, a, b, 0), add(h, b, a, 0);
		else if(op == 2) add(h, a, b, 1);
		else if(op == 3) add(h, b, a, 0);
		else if(op == 4) add(h, b, a, 1);
		else add(h, a, b, 0);
	}
	tarjan(0);//0 号点肯定与所有点联通
    for(int i = 0; i <= n; i++) {
        for(int j = h[i]; ~j; j = ne[j]) {
            int y = e[j];
            if(id[i] == id[y]) {
                if(w[j] > 0) {
                    puts("-1"); //出现正环即无解
                    return 0;
                }
            }
            else add(hc, id[i], id[y], w[j]);
        }
    }
    //Tarjan 的逆序即是拓扑排序
    for(int i = scc_cnt; i; i--) {
        for(int j = hc[i]; ~j; j = ne[j]) {
            int y = e[j];
            dist[y] = max(dist[y], dist[i] + w[j]);
        }
    }
    long long res = 0;
    for(int i = 1; i <= scc_cnt; i++) res += 1ll * dist[i] * scc_siz[i];
    printf("%lld\n", res);
	return 0;
}
```

---

## 作者：Aventurine_stone (赞：1)

## l. 题目分析
这么多约束条件。一眼就能看出这是差分约束的题，但是要注意的是，这题的 $n$ 比较大，用 SPFA 必定超时，我们只能考虑缩点。
## 2. 题目做法
对于这道题的约束条件。  
当 $A$ 与 $B$ 相等时，在他们之间建一条边权为零的双向边。  
当 $A$ 小于 $B$ 时，从 $A$ 往 $B$ 建一条边权为一的单向边。  
当 $A$ 不小于 $B$ 时，从 $B$ 往 $A$ 建一条边权为零的单向边。  
当 $A$ 大于 $B$ 时，从 $B$ 往 $A$ 建一条边权为一的单向边。  
当 $A$ 不大于 $B$ 时，从 $A$ 往 $B$ 建一条边权为零的单向边。  
之后进行缩点，因为求最小值，所以要跑最长路，有正环则无解，如果有解则以拓扑序跑一遍最长路即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=300010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int head[N],h2[N],ne[M],e[M],w[M],idx;
inline void add(int x,int y,int z)
{
	ne[++idx]=head[x];
	head[x]=idx;
	e[idx]=y;
	w[idx]=z;
}
inline void add2(int x,int y,int z)
{
	ne[++idx]=h2[x];
	h2[x]=idx;
	e[idx]=y;
	w[idx]=z;
}
int n,m;
int dfn[N],low[N],id[N],dai[N],num[N],cnt,biao;
bool vis[N];
stack<int>s;
int t;
void tarjan(int x)
{
	dfn[x]=low[x]=++biao;
	vis[x]=1;
	s.push(x);
	for(int i=head[x];i;i=ne[i])
	{
		int c=e[i];
		if(!dfn[c])
		{
			tarjan(c);
			low[x]=min(low[x],low[c]);
		}
		else if(vis[c])
			low[x]=min(low[x],dfn[c]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		dai[cnt]=x;
		while(1)
		{
			t=s.top();
			s.pop();
			vis[t]=0;
			num[cnt]++;
			id[t]=cnt;
			if(t==x)
				return ;
		}
	}
}
void dfs(int x)//判断是否有正环
{
	vis[x]=1;
	for(int i=head[x];i;i=ne[i])
	{
		int c=e[i];
		if(id[x]==id[c])
		{
			if(w[i])
			{
				printf("-1");
				exit(0);
			}
			if(!vis[c])
				dfs(c);
		}
	}
}
int rb[N],dist[N];
queue<int>d;
void tp()
{
	for(int i=1;i<=cnt;i++)
	{
		if(!rb[i])
		{
			dist[i]=1;
			d.push(i);
		}
	}
	while(!d.empty())
	{
		t=d.front();
		d.pop();
		for(int i=h2[t];i;i=ne[i])
		{
			int c=e[i],s=dist[t]+w[i];
			s>dist[c]?dist[c]=s:1;
			rb[c]--;
			if(!rb[c])
				d.push(c);
		}
	}
}
long long tt,ans;
int op,x,y;
int main()
{
	n=read(),m=read();
	while(m--)
	{
		op=read(),x=read(),y=read();
		if(op==1)
			add(x,y,0),add(y,x,0);
		else if(op==2)
			add(x,y,1);
		else if(op==3)
			add(y,x,0);
		else if(op==4)
			add(y,x,1);
		else
			add(x,y,0);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=cnt;i++)
		dfs(dai[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=head[i];j;j=ne[j])
		{
			int c=e[j];
			if(id[i]!=id[c])
			{
				add2(id[i],id[c],w[j]);
				rb[id[c]]++;
			}
		}
	}
	tp();
	for(int i=1;i<=cnt;i++)
		ans+=1ll*dist[i]*num[i];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Chen_Johnny (赞：0)

# P10935 银河 题解
全是SCC巨佬……
## 思路
这道题的核心思路就是贪心。为了让总和最小，我们会让最小值最小即为 $1$。此时，做法已经很明显。

  我们发现，任何一个节点 $a$ 与另一个节点 $b$ 可能会有一个关系，而这种关系最好的表述方式就是使用一个有向图。我们进一步思考，如果我们创建一个表达式：$a\leqslant b+k$ 的话（$k$ 为 `AB` 的边权），我们可以通过拓扑排序，加上 DP 计算出每个点的最小值。

不难发现：$a>b\Leftrightarrow a\geqslant b+1$，$a\geqslant b \Leftrightarrow a\geqslant b+0$。

所以，我们根据是 $>$ 还是 $\geqslant$ 进行构造 $0,1$ 边权图。

接下来，我们想到了 SCC，通过寻找强联通块进行分组求解。我们发现一个细节：如果 $A$，$B$ 处于同一个强联通块内，则 $A=B$，Why?

我们举个例子，假设有一个强联通块中有节点 $a_1,a_2,\cdots ,a_n$，且 $a_{i+1}\rightarrow a_{i}(1\leqslant i < n) (^*), a_1 \rightarrow a_n (^{**})$。不难发现，由 $(^*)$，$a_n\leqslant a_1$，反之由 $(^{**})$，$a_n\geqslant a_1 \Rightarrow a_n=a_1$。我们发现可以将 $a$ 中的数随意交换，可得：$a_1=a_2=\cdots= a_n$。

因此，我们通过 Tarjan 算法求出 $sum_i$ 为第 $i$ 个联通块的点的数量。
DP 的转移方程：$dp_i=\max \{dp_j + dis_j\}$ 轻松求出每一个 $dp$（$dp_i$ 为从 $i$ 的前驱到 $i$ 的最长路径）。

最后，使用小学数学：

$$ans = \sum_{i=1}^{tot}{sum_i\times dp_i}$$

## 代码
照着写就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 2e5 + 10;
struct edge {ll a, b, k, fa;} side [N], sides [N];
ll n, m, ls, ans, top, tot, Time;
ll z [N], zz [N], dfn [N], low [N], stk [N], col [N], sum [N], ru [N], q [N], f [N];
void Tarjan (ll x) {
    dfn [x] = low [x] = ++ Time; stk [++ top] = x;
    for (ll i = z [x]; i != 0; i = side [i].fa) {
        ll u = side [i].b;
        if (!dfn [u]) {
            Tarjan (u);
            low [x] = min (low [x], low [u]);
        } else if (!col [u]) 
            low [x] = min (low [x], low [u]);
    } if (low [x] == dfn [x]) {
        col [x] = ++ tot; sum [tot] ++;
        while (stk [top] != x) {
            sum [tot] ++;
            col [stk [top --]] = tot;
        } top --;
    }
}
int main () {
    cin >> n >> m;
    for (ll i = 1; i <= m; i ++) {
        ll t, a, b; cin >> t >> a >> b;
        if (t == 1) {
            side [++ ls] = {a, b, 0, z [a]};
            z [a] = ls; 
            side [++ ls] = {b, a, 0, z [b]};
            z [b] = ls;
        } else if (t == 2) {
            side [++ ls] = {a, b, 1, z [a]};
            z [a] = ls;
        } else if (t == 3) {
            side [++ ls] = {b, a, 0, z [b]};
            z [b] = ls;
        } else if (t == 4) {
            side [++ ls] = {b, a, 1, z [b]};
            z [b] = ls;
        } else {
            side [++ ls] = {a, b, 0, z [a]};
            z [a] = ls;
        }
    }
    for (ll i = 1; i <= n; i ++)
        if (!dfn [i]) 
            Tarjan (i);
    ll len = ls; ls = 0;
    for (ll i = 1; i <= len; i ++) {
        ll x = col [side [i].a], y = col [side [i].b];
        if (x != y) {
            sides [++ ls] = {x, y, side [i].k, zz [x]};
            zz [x] = ls; ru [y] ++;
        } else if (side [i].k) {cout << -1; return 0;}
    }
    ll l = 0, r = 0;
    for (ll i = 1; i <= tot; i++) 
        if (!ru [i]) {q [++ r] = i; f [i] =1;}
    while (l < r) {
        l ++; ans += f [q [l]] * sum [q [l]];
        for (ll i = zz [q [l]]; i != 0; i = sides [i].fa) {
            ll x = sides [i].a, y = sides [i].b;
            if (f [y] < f [x] + sides [i].k) f [y] = f [x] + sides [i].k;
            if (!(-- ru [y])) q [++ r] = y;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

显然是差分约束，但是直接跑死了的算法大概率会炸掉。所以我们考虑“手动”差分约束。

这个差分约束有一个特点：有很多的边权为 $0/1$ 的边，总之恒非负。

我们希望能 Dijkstra 跑最长路，问题在于可能有正权环。因此我们思考一下能不能缩点。

显然如果有一个边权为 $1$ 的边在一个强连通分量内的话，就一定无解。所以我们可以直接缩点。

缩完之后发现不存在这样的边的话就一定有解了。我们就可以愉快的跑 Dijkstra 了。

其实别说正权环了，连一个环都没有，直接跑拓扑，复杂度是线性的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, rd[100005], scn[100005], d[100005], ans;
struct node {
	int p, v;
	node(int pi = 0, int vi = 0) :p(pi), v(vi) {};
}; vector<node>son[100005], nsn[100005];
int dfn[100005], low[100005], cnt, scc[100005], sct;
bool ins[100005]; stack<int>s; queue<int>q;
inline void tmin(int& l, const int r) { (l > r) && (l = r); }
inline void tmax(int& l, const int r) { (l < r) && (l = r); }
inline void tarjan(int p) {
	dfn[p] = low[p] = ++cnt; ins[p] = 1; s.emplace(p);
	for (const node& sp : son[p])
		if (!dfn[sp.p]) tarjan(sp.p), tmin(low[p], low[sp.p]);
		else if (ins[sp.p]) tmin(low[p], dfn[sp.p]);
	if (dfn[p] == low[p]) {
		scc[p] = ++sct;
		while (s.top() != p)
			scc[s.top()] = sct,
			ins[s.top()] = 0, s.pop();
		s.pop(); ins[p] = 0;
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1, t, l, r;i <= m;++i) {
		cin >> t >> l >> r;
		if (t == 1)
			son[l].emplace_back(r, 0),
			son[r].emplace_back(l, 0);
		else if (t == 2)
			son[l].emplace_back(r, 1);
		else if (t == 3)
			son[r].emplace_back(l, 0);
		else if (t == 4)
			son[r].emplace_back(l, 1);
		else son[l].emplace_back(r, 0);
	}
	for (int i = 1;i <= n;++i)
		if (!dfn[i]) tarjan(i);
	for (int i = 1;i <= n;++i) {
		scn[scc[i]]++;
		for (const node& sp : son[i]) {
			if (scc[i] == scc[sp.p] && sp.v) return cout << "-1\n", 0;
			if (scc[i] != scc[sp.p]) nsn[scc[i]].emplace_back(scc[sp.p], sp.v), rd[scc[sp.p]]++;
		}
	}
	memset(d, 0xcf, sizeof d);
	for (int i = 1;i <= sct;++i)
		if (!rd[i]) q.emplace(i), d[i] = 1;
	while (q.size()) {
		int tp = q.front(); q.pop();
		ans += d[tp] * scn[tp];
		for (const node& sp : nsn[tp]) {
			tmax(d[sp.p], d[tp] + sp.v);
			if (!--rd[sp.p]) q.emplace(sp.p);
		}
	}
	cout << ans << endl;
}
```

---


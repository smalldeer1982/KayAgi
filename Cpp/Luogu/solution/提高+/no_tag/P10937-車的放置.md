# 車的放置

## 题目描述

给定一个 $N$ 行 $M$ 列的棋盘，已知某些格子禁止放置。

问棋盘上最多能放多少个不能互相攻击的車。

車放在格子里，攻击范围与中国象棋的“車”一致。

## 说明/提示

数据保证，$1 \le N,M \le 200$。

## 样例 #1

### 输入

```
8 8 0```

### 输出

```
8```

# 题解

## 作者：tjtdrxxz (赞：13)

## 前置知识：二分图

二分图是长这样滴：
![](https://cdn.luogu.com.cn/upload/image_hosting/m80jqafg.png)
一眼就能看出二分图类似于男女关系，A 喜欢 B，但 B 不一定喜欢 A，但 B 喜欢的人不一定喜欢 B。所以我们需要委屈下男方。如果有一对匹配好的男女（A 和 B），但又有另一个人（C）喜欢女方，我们就先把 C 和 B 连成一对，然后就看 A 能不能和别的女生匹配，类似这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/4bkge03k.png)

## 本题思路

我们可以把每行每列都看成一个点，一辆车占据每行每列就相当于占据他所在的行和列代表的点。

那么为了找到最多的车，自然就是二分图最大匹配了。

这题的数据范围比较小，$ N, M \le 200 $，所以 $ O (n^2) $ 可以过。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	register char in = getchar(),f = 0; register int t = 0;
	for(;in < '0' || in > '9';in = getchar())if(!(in ^ 45))f = 1;
	for(;in >= '0' && in <= '9';in = getchar())
	 t = (t << 1) + (t << 3) + (in ^ 48);
	return f ? -t : t;
}
void write(register long long x)
{
	static int t[25];register int tp = 0;
	if(x == 0)return(void)(putchar('0'));
	else if(x < 0) putchar('-'),x = -x;
	while(x) t[tp++] = x % 10,x /= 10;
	while(tp--) putchar(t[tp] + 48);
}
#define stdi stdin
#define stdo stdout
int n = read(),m = read(),t = read();
int vis[1012][1012],ans,dis[100012];
int lk[100012];
inline short dfs(int u)
{
	for(int i = 1;i <= m;i++)
	{
		if(!vis[u][i] && !dis[i])
		{
			dis[i] = 1;
			if(!lk[i] || dfs(lk[i]))
			{
				lk[i] = u;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	setvbuf(stdi,(char*)calloc(1 << 20,sizeof(char)),_IOFBF,1 << 20);
	setvbuf(stdo,(char*)calloc(1 << 20,sizeof(char)),_IOFBF,1 << 20);
	for(int i = 1;i <= t;i++)
	{
		register int u = read();
		register int v = read();
		vis[u][v] = 1;
	}
	for(int i = 1;i <= n;i++)
	{
		memset(dis,0,sizeof(dis));
		if(dfs(i)) ans++;
	}
	write(ans),puts("");
}
```

---

## 作者：wangbinfeng (赞：8)

[![](https://img.shields.io/badge/题目-P10937_車的放置-green)
![](https://img.shields.io/badge/难度-提高+/省选−-blue)
![](https://img.shields.io/badge/考点-匈牙利算法（二分图最大匹配）-red)
![](https://img.shields.io/badge/题型-传统题-yellow)](https://www.luogu.com.cn/problem/P10937)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

---
## 前置知识：
1. 什么是二分图？
> 若把一个 $n$ 个点的无向图可以分成两个部分（非空且不含重复结点，一般称为左部点和右部点），两个部分内部的点都没有边直接相连，那么这个图就被称为**二分图**。   
> 一个图是二分图，当且仅当不存在奇环。
2. 什么匹配？
> 任意两条边都没有公共点的边集称为图的一组**匹配**。
3. 什么是最大匹配：
> 二分图中包含最多的边的一组匹配称为二分图的**最大匹配**。
4. 增广路：
> 【《算法竞赛进阶指南（李煜东著）》定义】
> - 假设任意一个匹配 $S$，则这个匹配中的所有边被称为“匹配边”，而不在这个集合的边称为“非匹配边”，匹配边的端点称为“匹配点”，而其他结点称为“非匹配点”。如果二分图中存在一个路径 $path$ 使得非匹配边与匹配边轮流出现，那么称 $path$ 是匹配 $S$ 的**增广路**，也叫交错路。
> 
> ---
> 【OI-wiki 定义】
> - 交错路（alternating path）始于非匹配点且由匹配边与非匹配边交错而成。   
>- 增广路（augmenting path）是始于非匹配点且终于非匹配点（除了起始的点）的交错路。增广路中边的数量是奇数。
5. 增广路的性质：
> 1. 长度 $len$ 是奇数。
> 2. 路径上第 $1,3,5,\dots,len$ 条边是非匹配边，第 $2,4,6,\dots,len-1$ 条边是匹配边。
6. 推论：
> 1. 增广路上非匹配边比匹配边数量多 $1$，如果将增广路上的匹配边和未匹配边反转，则匹配数量会增加 $1$ 且依然是交错路。
> 2. 二分图的一组匹配 $S$ 是最大匹配，当且仅当图中不存在 $S$ 的增广路。

## 匈牙利算法（又称增广路算法）：
1. 主要思路：
> 因为增广路长度为奇数，路径起始点非左即右，所以我们先考虑从左边的未匹配点找增广路。注意到因为交错路的关系，增广路上的第奇数条边都是非匹配边，第偶数条边都是匹配边，于是左到右都是非匹配边，右到左都是匹配边。于是我们给二分图**定向**，问题转换成，有向图中从给定起点找一条简单路径走到某个未匹配点，此问题等价给定起始点 $s$ 能否走到终点 $t$。那么只要从起始点开始 DFS 遍历直到找到某个未匹配点，$\Theta(m)$。 未找到增广路时，我们拓展的路也称为**交错树**。——摘自 [OI-wiki](https://oi-wiki.org/graph/graph-matching/bigraph-match/#%E5%A2%9E%E5%B9%BF%E8%B7%AF%E7%AE%97%E6%B3%95-augmenting-path-algorithm)
2. 主要过程：
> 1. 设 $S=\varnothing$，即所有边都是非匹配边。
> 2. 寻找任意一条增广路 $path$，把路径上所有边的匹配状态取反，得到一个更大的匹配 $S'$。
> 3. 重复 2. 的步骤，直到图中不再存在增广路。
3. 右部点 $y$ 能与左部点 $x$ 匹配的条件：
> 1. $y$ 本身就是非匹配点：此时无向边 $(x,y)$ 本身就是非匹配边。
> 2. $y$ 已经与左部点 $x'$ 匹配，但从 $x'$ 出发能找到另一个右部点 $y'$ 与之匹配：路径 $x\leftrightarrow y\leftrightarrow x'\leftrightarrow y'$。
4. 正确性：
> 当一个点变为匹配点后，只会因为状态取反改变匹配对象，而不可能变回非匹配点。
5. 时间复杂度：
> 因为要枚举 $n$ 个点，总复杂度为 $\Theta(nm)$。
## 对于本题：
1. 题意简述：
> $n\times m$ 的棋盘，有 $t$ 个格子禁用，求最多放多少个中国象棋里的“車”。
2. 分析：
> 有两个十分显然的结论：
> 1. 每行、每列最多只能放一个“車”；
> 2. 没个“車”最多只能在一行或一列出现。
3. 思路：
> 可以把 $n$ 行看为左部点，把 $m$ 列作为右部点，那么本题就可以转化为二分图的最大匹配。
4. 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 200 + 9;
vector<int> g[maxn];
int n, m, t, ans, match[maxn << 1];
bitset<(maxn << 1)> dat[maxn], vis;
inline bool dfs(const int u)
{
	for (int v : g[u])
		if (!vis[v])
		{
			vis[v] = true;
			if (!match[v] || dfs(match[v]))
			{
				match[v] = u;
				return true;
			}
		}
	return false;
}
signed main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m >> t;
	for (int i = 1, x, y; i <= t; i++)
		cin >> x >> y, dat[x][y] = true;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (!dat[i][j])
				g[i].push_back(j + n);
	for (int i = 1; i <= n; i++)
		vis.reset(), ans += dfs(i);
	cout << ans;
}
```
## 二分图的其他重要性质：
（证明暂时省略，具体参考 [OI-wiki](https://oi-wiki.org/graph/graph-matching/bigraph-match/#%E8%A1%A5%E5%85%85)）
1. 二分图的最小点覆盖（König 定理）：
> 最小点覆盖定义：选最少的点，满足每条边至少有一个端点被选。   
> 二分图中，最小点覆盖 = 最大匹配。
2. 二分图最大独立集
> 最大独立集定义：选最多的点，满足两两之间没有边相连。   
> 因为在最小点覆盖中，任意一条边都被至少选了一个顶点，所以对于其点集的补集，任意一条边都被至多选了一个顶点，所以不存在边连接两个点集中的点，且该点集最大。因此二分图中，最大独立集的大小等于 $n$ 减去最小点覆盖。
## 其他与鸣谢：
1. 其他：
> 由于本题解作者是当成学习笔记写的，如果有写错或者哪里看不懂欢迎也希望读者可以在评论区反馈。
2. 鸣谢：
> 感谢《算法竞赛入门经典训练指南（刘汝佳、陈锋著）》帮助本人入门。   
> 感谢《算法竞赛进阶指南（李煜东著）》，让本人对二分图有了更深刻的理解。   
> 感谢 OI-wiki 提供本人对二分图更全面的认识。   
> ~~感谢 [@wangbinfeng](https://www.luogu.com.cn/user/387009) 完成本文章。（咋还有鸣谢自己的？）~~



[![](https://jrenc.azurewebsites.net/api/signature?code=zHZRCCItO-yB8t7d2KyitELFDwADnXIotkeeIQL3juyNAzFucnyrWA%3D%3D&name=thanks%20for%20reading%20%20%20%20%20%20%20%20by%20%40wangbinfeng(387009)&animate=true&speed=0.7&color=purple)](https://www.luogu.com.cn/user/387009)
$$\color{grey}{\tiny{\texttt{发现上面的签名是动图了吗？}}}$$

---

## 作者：L_zaa_L (赞：4)

## 分析
首先发现题目上的数据只有 $n,m\le 200$，然后题目有和行列有关，感觉是一个非常典的[网络流](https://zhuanlan.zhihu.com/p/666991274)的建图方式：我们对每行和每列都建一个点，每个行点连源点，列点连汇点。

然后发现这相当与一个二分图匹配，就是一个可以放车的位置，相当于连接左右两边点的边，如果这个位置被选了，左右端点这两个点都不能再次被选，也相当于这一行和这一列不能再次被选了，然后找最大匹配数就行了。

Dinic 在二分图上的时间是 $O(N\sqrt M)$ 的，这道题 $N=n\times m\le 40000,\sqrt M=\sqrt{n\times m}=200$。时间不会超。

## Code 
```cpp
int s=0,t=50000;
int tot=1,head[N];
struct Edge{
	int v,nxt,val;
}e[N];
inline void add(int u,int v,int val){
	e[++tot].v=v;
	e[tot].val=val;
	e[tot].nxt=head[u];
	head[u]=tot;
	
	e[++tot].v=u;
	e[tot].val=0;
	e[tot].nxt=head[v];
	head[v]=tot;
}
int dis[N],rad[N];
inline bool bfs(){
	For(i,0,t+5) dis[i]=1e16;
	queue<int>Q;
	Q.push(s);
	dis[s]=0;
	rad[s]=head[s];
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i].val;
			if(w&&dis[v]==1e16){
				rad[v]=head[v];
				dis[v]=dis[u]+1;
				Q.push(v);
			}
		}
	}
	return dis[t]!=1e16;
}
int dfs(int u,int sum){
	if(u==t) return sum;
	int res=0;
	for(int i=head[u];i&&sum;i=e[i].nxt){
		int v=e[i].v,w=e[i].val;
		rad[u]=i;
		if(w&&dis[v]==dis[u]+1){
			int f=dfs(v,min(sum,w));
			if(!f) dis[v]=1e16;
			e[i].val-=f;
			e[i^1].val+=f;
			res+=f;
			sum-=f;
			if(sum<=0) break;
		}
	}
	return res;
}
inline int Dinic(){
	int ans=0;
	while(bfs()){
		ans+=dfs(s,1e16);
	}
	return ans ;
}
int n,m,T;
int	vis[205][205]; 
inline void solve(){
	n=read(),m=read(),T=read();
	For(i,1,T){
		int x=read(),y=read();
		vis[x][y]=1;
	} 
	For(i,1,n)add(0,i,1);
	For(i,1,m) add(i+n,t,1);
	For(i,1,n){
		For(j,1,m){
			if(vis[i][j]) continue;
			add(i,j+n,1);
		}
	}
	printf("%lld\n",Dinic());
}


```

---

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P10937 車的放置](https://www.luogu.com.cn/problem/P10937)

## 题意简述

在一个 $n\times m$ 的矩阵中，给定 $t$ 个不可选的位置。要求在满足每行和每列最多选择一个点的前提下，求最多可以选取多少个点。

## 解题思路

可以将问题转化为二分图匹配。

将矩阵的每一行和每一列分别看作二分图中的一组点。

如果某个位置可以选取，就在其所在行和列对应的节点之间连一条边。

这样每行只能匹配一个列节点，确保每行和每列最多选一个点。

所以问题的答案即为该二分图的最大匹配数。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=205;
vector<int> G[N<<1];
int a[N<<1];
bool b[N][N],vis[N<<1];
bool match(int u)
{
	for(auto v:G[u])
	{
		if(!vis[v])
		{
			vis[v]=1;
			if(!a[v]||match(a[v]))
			{
				a[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n,m,t;
	cin>>n>>m>>t;
	while(t--)
	{
		int u,v;
		cin>>u>>v;
		b[u][v]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!b[i][j])G[i].push_back(j+n);
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		memset(vis,0,sizeof vis);
		ans+=match(i);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Cells (赞：1)

#### 思路

一眼二分图匈牙利。

因为车能攻击一行一列，所以放置的时候把一行一列标记为不能防止，另外有些格子不能放置，也需要标记。然后跑二分图就可以了。

**Code**

```c++
# include <bits/stdc++.h>
using namespace std;

const int N = 5e3 + 10;

int n, m, t, ans;
int lk[N];
bool vis[N], mp[N][N];

bool dfs(int x){
	for(int i = 1; i <= m; i ++){
		if(vis[i] || mp[x][i]) continue;//不能放 
		vis[i] = true;//放一下 
		if(!lk[i] || dfs(lk[i])){//必须找到新的 
			lk[i] = x;
			return true;
		}
	}
	
	return false;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> t;
	
	while(t --){
		int x, y;
		cin >> x >> y;
		mp[x][y] = true;//不能放的格子 
	}
	
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++) vis[j] = false;
		if(dfs(i)) ans ++;
	}
	
	cout << ans;
	
	return 0;
}
```

**谢谢你能看到这里！！！**

---

## 作者：zjinze (赞：1)

#### 前置知识： 二分图最大匹配

#### 思路：

如果一行在某一列放了車，那么这一行在其他列都不能放車；如果一列在某一行放了車，那么这一列在其他行都不能放車；也就是说每一行只能和一列匹配，同理每一列也只能和一行匹配。接下来考虑连边，如果第 $i$ 行，第 $j$ 列的位置可以放車，那么就把第 $i$ 行与第 $j$ 列连边即可，最后就是板子了。

#### code:


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=410;
int n,m,t,match[N],vis[N],idx=0,ma[N][N],x,y;
vector<int>ve[N];
bool dfs(int x){
    for(int j=0;j<ve[x].size();j++){
        int to=ve[x][j];
        if(vis[to]==idx)continue;
        vis[to]=idx;
        if(match[to]==0 || dfs(match[to])){
            match[to]=x;
            return true;
        }
    }
    return false;
}
signed main(){
    cin>>n>>m>>t;
    while(t--){
        cin>>x>>y;
        ma[x][y]=1;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(ma[i][j]==0){
                ve[i].push_back(j+n);
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ++idx;
        if(dfs(i)){
            ++ans;
        }
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：Mrkn_chenyx12 (赞：1)

# 思路

按照常识，中国象棋中車的移动方式是在其所在的行或列中任意移动。按照题意，要使得它们两两不能互相攻击，显然就是要使得每行或每列**至多放置一个車**。

观察到数据范围非常小，不妨给每行每列各分配一个点，并且用连边表示它们的交叉点可以放置，而要求的就是**二分图的最大匹配**。

可以考虑转换成网络流，这是一种高效且通用的做法。

# 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
bool g[224][224];

struct Edge {
    int v, x, f;
} e[90024];

int cnt, s[424], cur[424], dep[424];

void add(int u, int v) {
    e[cnt] = {v, s[u], 1};
    s[u] = cnt++;
    e[cnt] = {u, s[v], 0};
    s[v] = cnt++;
}

int S, T;

bool bfs() {
    queue<int> q;
    q.push(S);

    memset(dep, 0, sizeof(dep));
    dep[S] = 1;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = s[u]; ~i; i = e[i].x) {
            int v = e[i].v;
            if (e[i].f && !dep[v]) {
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }

    return dep[T];
}

int dfs(int u, int lim) {
    if (lim == 0 || u == T) return lim;

    int flow = 0;

    for (int& i = cur[u]; ~i; i = e[i].x) {
        int v = e[i].v;
        if (dep[v] != dep[u] + 1) continue;
        if (!e[i].f) continue;

        int tmp = dfs(v, min(lim - flow, e[i].f));
        if (tmp) {
            flow += tmp;
            e[i].f -= tmp;
            e[i ^ 1].f += tmp;
        }
        
        if (flow == lim) return lim;
    }
    
    return flow;
}

int main() {
    int t;
    memset(s, -1, sizeof(s));
    scanf("%d %d %d", &n, &m, &t);
    S = n + m + 1;
    T = n + m + 2;
    int a, b;
    while (t--) {
        scanf("%d %d", &a, &b);
        g[a][b] = true;
    }
    for (int i = 1; i <= n; i++) {
        add(S, i);
        for (int j = 1; j <= m; j++) {
            if (!g[i][j]) {
                add(i, j + n);
            }
        }
    }
    for (int i = 1; i <= m; i++) add(i + n, T);
    int ans = 0;
    while (bfs()) {
        for (int i = 1; i <= T; i++) cur[i] = s[i];
        ans += dfs(S, 114514);
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：sintle (赞：1)

## 原题链接

- [洛谷 P10937 車的放置](https://www.luogu.com.cn/problem/P10937)

## 解题思路

~其实就是匈牙利板子~

题意翻译一下就是每一行每一列都只能选一个点。

所以我们就可以建一张二分图，将行和列转化为点存储。

对于每一个可选的点，在行和列对应的点之间连一条边。

因为每行只能对应一列，所以能放的最大个数就是二分图的最大匹配。

## 参考代码

```cpp
#include <bits/stdc++.h>
#define N 205
#define M 205
using namespace std;

int n , m , t , p[M] , ans = 0;
bool able[N][M] , vis[M];
vector <int> g[N];

bool match(int x)
{
    for(int i = 1 ; i <= m ; i++)
    {
        if(able[x][i] && !vis[i])
        {
            vis[i] = 1;
            if(!p[i] || match(p[i]))
            {
                p[i] = x;
                return 1;
            }
        }
    }
    return 0;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    memset(able , true , sizeof able);
    cin >> n >> m >> t;
    for(int i = 1 , x , y ; i <= t ; i++)
    {
        cin >> x >> y;
        able[x][y] = 0;
    }
    for(int i = 1 ; i <= n ; i++)
    {
        memset(vis , 0 , sizeof(vis));
        if(match(i))
        {
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：20111019Yu (赞：1)

### 题意
有一个 $nm$ 大小的棋盘，有 $t$ 个位置不能放棋，问每行每列最多只有一个棋子的情况下最多能放多少。
### 思路
我们把每个点的下行列拆出来能发现，行和列构成的集合在各自本身内没有相交，行和列之间会连一些边。所以用二分图最大匹配。
### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, t, x, y, ans, dis[205], visit[205];
bool can[205][205];
vector<int> vec[205];

bool solve(int x, int tag){
	if(visit[x] == tag) return 0;
	visit[x] = tag;
	for( auto &i : vec[x] ){
		if(!dis[i] || solve(dis[i], tag)){
			dis[i] = x;
			return 1;
		}
	}
	return 0;
}

signed main(){
	cin >> n >> m >> t;
	for( int i = 1; i <= t; i++ ){
		cin >> x >> y;
		can[x][y] = 1;
	}
	for( int i = 1; i <= n; i++ ){
		for( int j = 1; j <= m; j++ ){
			if(!can[i][j]) vec[i].push_back(j);
		}
	}
	for( int i = 1; i <= n; i++ ) if(solve(i, i)) ans++;
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

本文知识点参考于：[oi-beats 二分图](https://ntsc-yrx.github.io/oi-beats/site/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE/)，[个人博客](https://ntsc.flowus.cn/)。

## 知识点摘录

二分图（二部图）的最大匹配：

设 $G$ 为二分图，若在 $G$ 的子图 $M $ 中，任意两条边都没有公共节点，那么称 $M$ 为二分图 $G $ 的一组**匹配**。在二分图中，包含边数最多的一组匹配称为**二分图的最大匹配**。

交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边……形成的路径叫交替路。

增广路：从一个未匹配点出发，走交替路，若能到达另一个未匹配点，则这条交替路称为增广路。

观察增广路，我们会发现：非匹配边比匹配边多一条。只要把增广路中的匹配边和非匹配边的身份交换（即倒过来走），交换后，图中的匹配边数目比原来多了 $1$ 条。

这里的增广路就是指能增加匹配边的一条路。

匈牙利算法通过不停地找增广路来增加配边找不到增广路时，达到最大匹配。可以用 DFS 或 BFS 来实现。

## 做法

建立 $n+m$ 个点分别代表行（左部）和列（右部），在棋盘上选择一个点 $(x,y)$ 就相当于建立一条二分图上的边，连接左部的 $x$ 和右部的 $y$。

因此题目的约束可以转化为：二分图上的点最多只能连一条边，问可以连的最大边数。因此就是二分图的最大匹配。

```C++

const int N = 5e2 + 5;
const int INF = 1e3;
const int M = 1e7;
const int MOD = 1e9 + 7;

int idx;
vector<int> e[N];
int vis[N];
bool ban[N][N];
int match[N];


bool dfs(int x){
    for(auto v:e[x]){
        if(vis[v]==idx)continue;
        vis[v]=idx;
        if(match[v]==0||dfs(match[v])){
            match[v]=x;
            return 1;
        }
    }
    return 0;
}

void solve(){
    itn n=rd,m=rd,t=rd;

    //建立n+m个点分别代表行和列，选择一个点就相当于一个二分图上的边
    while(t--){
        int a=rd,b=rd;
        ban[a][b]=1;
    }

    for(int i=1;i<=n;i++){
        for(itn j=1;j<=m;j++){
            if(!ban[i][j])
                e[i].pb(j+n);
        }
    }

    int ans=0;
    for(int i=1;i<=n;i++){
        ++idx;
        if(dfs(i))ans++;
    }
    cout<<ans<<endl;
}

signed main() {
    // freopen("center.in","r",stdin);
    // freopen("center.out","w",stdout);

    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

注意到，当 $(i,j)$ 被放了车以后，第 $i$ 行和第 $j$ 列都不能再放车了，故对于每个 $i$，最多只能找到一个 $j$ 与他配对。

发现是一个二分图最大匹配问题，若 $(i,j)$ 能放车，则建边 $i \to j$。

使用匈牙利算法即可，时间复杂度为 $O(N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const ll N=205;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,x,y,c,id,ans;
ll a[N],f[N];
bool F[N][N];
vector<ll> E[N];
void add(ll u,ll v){
	E[u].push_back(v);
}
bool dfs(ll u){
	for(auto v:E[u]){
		if(f[v]==id)
		  continue;
		f[v]=id;
		if(!a[v]||dfs(a[v])){
			a[v]=u;
			return 1;
		}
	}
	return 0;
}
void Match(){
	for(int i=1;i<=n;i++){
		id=i;
		if(dfs(i))
		  ans++;
	}
}
int main(){
	n=read(),m=read(),c=read();
	while(c--){
		x=read(),y=read();
		F[x][y]=1;
	}
	For(i,1,n){
		For(j,1,m){
			if(F[i][j])
			  continue;
			add(i,j);
		} 
	}
	Match();
	write(ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 题目描述

给定一个 $n$ 行 $m$ 列的棋盘，已知某些格子禁止放置。

问棋盘上最多能放多少个不能互相攻击的車。

### 解题思路
不难发现，若一种方案满足条件，那么在第 $i(i\leq n)$ 行或第 $j(j\leq m)$ 列中最多只有 $1$ 个棋子。

把 $n$ 行 $m$ 列抽象成二分图里的点，那么每个棋子就是二分图的一条边。

棋子的最大数量实际上就是该二分图的最大匹配。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=207;
int mat[N],vis[N][N],n,m,t,x,y,ans,vt[N];

int get(int x,int y){
	return (x&y)^((x^y)|(~x&y));
}

bool dfs(int x){
	for(int i=1;i<=m;++i)
		if(!get(vis[x][i],0)&&!get(vt[i],0)){
			vt[i]=get(1,0);
			if(!get(mat[i],0)||dfs(mat[i])){
				mat[i]=x;
				return get(1,0);
			}
		}
	return get(0,0);
}

int main(){
	cin>>n>>m>>t;
	for(int i=1;i<=t;++i){
		cin>>x>>y;
		vis[x][y]=get(1,0);
	}
	for(int i=1;i<=n;++i){
		memset(vt,get(0,0),sizeof vt);
		if(dfs(i))
			++ans;
	}
	cout<<ans;
}
```

---


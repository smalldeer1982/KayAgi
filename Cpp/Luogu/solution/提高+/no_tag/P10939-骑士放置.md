# 骑士放置

## 题目描述

给定一个 $N \times M$ 的棋盘，有一些格子禁止放棋子。

问棋盘上最多能放多少个不能互相攻击的骑士（国际象棋的“骑士”，类似于中国象棋的“马”，按照“日”字攻击，但没有中国象棋“别马腿”的规则）。

## 说明/提示

$1 \le N,M \le 100$

## 样例 #1

### 输入

```
2 3 0```

### 输出

```
4```

# 题解

## 作者：wangbinfeng (赞：8)

[![](https://img.shields.io/badge/题目-P10939_骑士放置-green)
![](https://img.shields.io/badge/难度-提高+/省选−-blue)
![](https://img.shields.io/badge/考点-匈牙利算法（二分图最大匹配）-red)
![](https://img.shields.io/badge/题型-传统题-yellow)](https://www.luogu.com.cn/problem/P10939)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

---
前置知识：匈牙利算法（二分图最大匹配），如果不会欢迎阅读[我写的另一篇题解](https://www.luogu.com.cn/article/hqxr10nu)。

本题和 [P10937 車的放置](https://www.luogu.com.cn/problem/P10937)没有什么本质区别，所以请先阅读我上面给出的题解链接，本题的唯一难点在于建图。

考虑到每行每列最多只能放一个棋子这个条件不再满足，我们就要寻找新的建图方式。

考虑到，“骑士”（“马”）走“日”，那么一定要让所有的日的对角线两端的节点颜色不同，发现每行每列分别为黑白交替恰巧能满足需求（具体见下）。那么建图时判断一下奇偶，求最大独立集即可。


|**黑**|**白**|**黑**|**白**|**黑**|
|:-:|:-:|:-:|:-:|:-:|
|**白**|**黑**|**白**|**黑**|**白**|
|**黑**|**白**|**黑**|**白**|**黑**|
|**白**|**黑**|**白**|**黑**|**白**|
|**黑**|**白**|**黑**|**白**|**黑**|

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 200 + 9, mx[] = {0, -2, -2, -1, -1, 1, 1, 2, 2}, my[] = {0, -1, 1, -2, 2, -2, 2, -1, 1};
vector<int> g[maxn * maxn];
int n, m, t, ans, vis[maxn * maxn], match[maxn * maxn];
bitset<maxn> dat[maxn];
inline bool dfs(const int u, const int idx)
{
	for (int v : g[u])
		if (vis[v] != idx)
		{
			vis[v] = idx;
			if (!match[v] || dfs(match[v], idx))
			{
				match[v] = u;
				return true;
			}
		}
	return false;
}
signed main()
{
	// freopen("dat.in", "r", stdin);
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m >> t;
	for (int i = 1, x, y; i <= t; i++)
		cin >> x >> y, dat[x][y] = true;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (!dat[i][j])
			{
				for (int k = 1; k <= 8; k++)
				{
					const int x = i + mx[k], y = j + my[k];
					if (x < 1 || x > n || y < 1 || y > m || dat[x][y])
						continue;
					if ((x + y) % 2)
						g[(i - 1) * m + j].push_back((x - 1) * m + y);
				}
			}
	for (int i = 1; i <= n * m; i++)
		ans += dfs(i, i);//小技巧：这样可以不用每次重置 vis 数组
	cout << n * m - t - ans;
}
```
本题有超高倍经验（好像五六道吧，具体不附上了），这个代码的时间复杂度较大但一般跑不满，如果某道题 TLE 了可以考虑修改奇偶建图（把代码中的奇数则建图改为偶数则建图），或者将正序枚举改为倒叙枚举均可降低代码实际运行速度。不过这本质上还是面向数据编程，如果可以建议学习正解的网络流（虽然但是网络流好像理论时间复杂度也不太好，不过总是跑不满就是了）。

[![](https://jrenc.azurewebsites.net/api/signature?code=zHZRCCItO-yB8t7d2KyitELFDwADnXIotkeeIQL3juyNAzFucnyrWA%3D%3D&name=thanks%20for%20reading%20%20%20%20%20%20%20%20by%20%40wangbinfeng(387009)&animate=true&speed=0.7&color=purple)](https://www.luogu.com.cn/user/387009)
$$\color{grey}{\tiny{\texttt{发现上面的签名是动图了吗？}}}$$

---

## 作者：jinminghao (赞：5)

前置知识：[匈牙利算法](https://blog.csdn.net/qq_52302919/article/details/132170356)

![](https://cdn.luogu.com.cn/upload/image_hosting/0f7a6v3f.png)

如上图，是一个国际象棋的棋盘，我们可以发现一匹马能跳到的格子的颜色一定和它所在格子的颜色是相反的。

例如：一匹马在白色格子 $(1,1)$ 上，它可以跳到 $(2,3)$ 和 $(3,2)$ 上，这两个格子都是黑色，与 $(1,1)$ 的颜色相反。

于是我们可以将每个位置与能跳到的位置连边（不让到达的格子不连），这样就构成了一个二分图（所有白色格子是一部分，所有黑色格子是一部分）。

我们还可以发现，如果想让所有的马都不能互相吃，那么这个二分图里一条边的两个点最多只能选一个点放马，所以这题就是让我们在一个二分图里相邻的两个点只能选一个，问最多能选多少个点。

那么这个问题就被我们转化成了求一个[二分图的最大独立集](https://www.cnblogs.com/ZeonfaiHo/p/6764486.html)的问题。

**根据定理**： $二分图的最大独立集 = 二分图顶点数 − 二分图最大匹配数$

所以我们只要用格子数减去二分图的最大匹配数再减去不能选的格子个数就能求出答案。

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e5+10,M=110;
int h[N],e[N],ne[N],idx;
int match[N],n,m,t,ans;
bool st[N];
bool f[M][M];
int dx[8]={-1,-2,-2,-1,1,2,2,1};
int dy[8]={-2,-1,1,2,-2,-1,1,2};
inline int id(int x,int y){
	return (x-1)*m+y;
}//表示格子(x,y)的编号
void add(int a,int b){
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
bool found(int x){
	for(int i=h[x];~i;i=ne[i]){
		int j=e[i];
		if(!st[j]){
			st[j]=true;
			if(!match[j]||found(match[j])){
				match[j]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	memset(h,-1,sizeof h);
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=t;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		f[x][y]=true;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(f[i][j]||((i&1)!=(j&1))) continue;//格子不是白色的或者不能选就跳出循环
			for(int k=0;k<8;k++){
				int tx=i+dx[k],ty=j+dy[k];
				if(tx<1||tx>n||ty<1||ty>m||f[tx][ty]) continue;
				add(id(i,j),id(tx,ty));
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
		    if(f[i][j]||((i&1)!=(j&1))) continue;
			int ret=id(i,j);
			memset(st,false,sizeof st);
			if(found(ret)) ans++;
		}
	}
	printf("%d",n*m-t-ans);//总格子数-不能选的格子数-二分图的最大匹配数
	return 0;
}

---

## 作者：JimmyLee (赞：5)

# 分析

前置知识：[网络流](https://oi-wiki.org/graph/flow/)，[最小割](https://oi-wiki.org/graph/flow/min-cut/)。

套路题。

在这道题基础上有很多改版，比如[长脖子鹿放置](https://www.luogu.com.cn/problem/P5030)。

首先黑白染色。$(n=m=4)$

保证染色后同种颜色上的骑士不能互相攻击。

| 1 | 0 | 1 | 0 |
| - | - | - | - |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 |

染色之后考虑将原题转化为**最小割**问题。

也就是说在棋盘上放满骑士后再考虑扔掉一些棋子。

连边方法如下：

- 从白格向到它能攻击到的黑格连边，边权为 $\infty$。
- 从原点 $S$ 向**能放置**的白格连边权为 $1$ 的边。
- 从**能放置**的黑格向汇点 $T$ 连边权为 $1$ 的边。

最后的结果就是 $nm-t-\operatorname{maxflow}$。

如果用 Dinic，令 $n$ 为点数，$m$ 为边数，其在二分图上最差时间复杂度为 $O(n\sqrt{m})$。（可惜我不会证）

所以最终的时间复杂度应为 $O(n^2)$。

# Code

这里使用[最高标号预流推进 HLPP](https://oi-wiki.org/graph/flow/max-flow/#hlpp-%E7%AE%97%E6%B3%95)。

```cpp
#include<bits/stdc++.h>
using namespace std;

template<typename Tp, size_t sizn, size_t sizm>
struct netflow
{
    int cnt=1, s=sizn-3, t=sizn-2;
    Tp val[sizm<<1], dis[sizn];

    void link(int u, int v, Tp w) 
    {
        to [++cnt]=v;       val [cnt]=w;
        nxt[ cnt ]=head[u]; head[ u ]=cnt;
        to [++cnt]=u;       val [cnt]=0;
        nxt[ cnt ]=head[v]; head[ v ]=cnt;
    }


    int head[sizn], to[sizm<<1], nxt[sizm<<1], now[sizm<<1];
    const Tp inf=((Tp)INFINITY)>>1;
    int bfs() 
    {
        for(int i=1;i<sizn;i++) dis[i]=inf;
        queue<int> q;
        q.push(s);
        dis[s]=0;
        now[s]=head[s];
        while (!q.empty())
        {
            int idx=q.front(); q.pop();
            for(int i=head[idx];i;i=nxt[i])
            {
                int arr=to[i];
                if(val[i]>0&&dis[arr]==inf)
                {
                    q.push(arr);
                    now[arr]=head[arr];
                    dis[arr]=dis [idx]+1;
                    if(arr==t) return 1;
                }
            }
        }
        return 0;
    }
    
    Tp dfs(int idx, Tp sum)
    {
        if(idx==t) return sum;
        Tp k, res=0;
        for(int i=now[idx];i&&sum;i=nxt[i])
        {
            now[idx]=i;
            int arr=to[i];
            if(val[i]>0&&(dis[arr]==dis[idx]+1))
            {
                k=dfs(arr, min(sum, val[i]));
                if(k==0) dis[arr]=inf;
                val[i]-=k;      res+=k;
                val[i^1]+=k;    sum-=k;
            }
        }
        return res;
    }

    Tp maxflow()
    {
        Tp ans=0;
        while (bfs()) ans+=dfs(s, inf); 
        return ans;
    }
};

netflow<int, 50000, 1000000> nf;

#define maxn 202
int blk[maxn][maxn];
#define pos(i, j) (((i)-1)*m+(j))

int dx[]={1, -1, 1, -1, 2, -2, 2, -2};
int dy[]={2, 2, -2, -2, 1, 1, -1, -1};

#define chk(i, j) ((i)>0&&(j)>0&&(i)<=n&&(j)<=m)

int main()
{
    int n, m, t;
    cin>>n>>m>>t;
    for(int i=1, a, b;i<=t;i++)
    {
        cin>>a>>b;
        blk[a][b]=1;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(blk[i][j]) continue;
            if((i+j)&1) nf.link(nf.s, pos(i, j), 1);
            else {nf.link(pos(i, j), nf.t, 1);continue;}
            
            for(int k=0;k<8;k++)
            {
                int nx=i+dx[k];
                int ny=j+dy[k];
                if(!chk(nx, ny)||blk[nx][ny]) continue;
                nf.link(pos(i, j), pos(nx, ny), nf.inf);
            }
        }
    cout<<n*m-t-nf.maxflow();

}
```

---

## 作者：tuntunQwQ (赞：4)

前置知识：匈牙利算法求二分图的最大匹配。

因为骑士按照“日”字攻击，所以我们可以将棋盘染色成黑白，并且使得能互相攻击的骑士一定一个在黑格，一个在白格。这样，所在格子颜色相同的骑士不能相互攻击。我们将能相互攻击的位置连边，构成一个二分图。

“日”字的两端要么是列数相差 $2$，行数相差 $1$；要么是列数相差 $1$，行数相差 $2$。考虑将所有的行数 $+$ 列数为偶数的格子染上白色，其余染上黑色，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fd2xdimj.png)

为什么这样染色可以使得能互相攻击的骑士一定一个在黑格一个在白格呢？设一个骑士在第 $i$ 行第 $j$ 列，则它能攻击的骑士只有可能在以下八个位置：

第 $i+2$ 行第 $j-1$ 列、第 $i+2$ 行第 $j+1$ 列、第 $i-2$ 行第 $j-1$ 列、第 $i-2$ 行第 $j+1$ 列、第 $i+1$ 行第 $j-2$ 列、第 $i+1$ 行第 $j+2$ 列、第 $i-1$ 行第 $j-2$ 列、第 $i-1$ 行第 $j+2$ 列。

我们发现，以上八个位置的行数 $+$ 列数均为 $i+j+1$、$i+j-1$、$i+j+3$ 或 $i+j-3$，故这些位置的行数+列数与第 $i$ 行第 $j$ 列的骑士的行数 $+$ 列数奇偶性不同，所以它们所在的格子一定颜色不同。

这样，我们将每个可以放置骑士的白色位置与它能攻击到的所有可以放置骑士的位置连边。这道题要求最多能放多少个不能互相攻击的骑士，因为连过边的两个点能互相攻击，所以我们求二分图的最大独立集（最大独立集 $=$ 图上点数 $-$ 最大匹配数）即可。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+10,M=8e4+10;
int n,m,t,e[M],nxt[M],h[N],idx,cnt,match[N];bool vis[N],f[105][105];
void add(int a,int b){
	e[++idx]=b,nxt[idx]=h[a],h[a]=idx;
}
bool find(int u){
	for(int i=h[u];i;i=nxt[i]){
		int v=e[i];
		if(!vis[v]){
			vis[v]=1;
			if(match[v]==0||find(match[v])){
				match[v]=u;
				return true;	
			}
		}
	}
	return false;
}
int main(){
	cin>>n>>m>>t;
	int cnt=n*m;
	for(int i=1;i<=t;i++){
		int x,y;
		cin>>x>>y;
		if(!f[x][y])cnt--;
		f[x][y]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2==j%2&&f[i][j]==0){
				if(i-2>=1&&j-1>=1&&f[i-2][j-1]==0)add(i*m+j,(i-2)*m+j-1);
				if(i+2<=n&&j-1>=1&&f[i+2][j-1]==0)add(i*m+j,(i+2)*m+j-1);
				if(i-2>=1&&j+1<=m&&f[i-2][j+1]==0)add(i*m+j,(i-2)*m+j+1);
				if(i+2<=n&&j+1<=m&&f[i+2][j+1]==0)add(i*m+j,(i+2)*m+j+1);
				if(i+1<=n&&j+2<=m&&f[i+1][j+2]==0)add(i*m+j,(i+1)*m+j+2);
				if(i-1>=1&&j+2<=m&&f[i-1][j+2]==0)add(i*m+j,(i-1)*m+j+2);
				if(i+1<=n&&j-2>=1&&f[i+1][j-2]==0)add(i*m+j,(i+1)*m+j-2);
				if(i-1>=1&&j-2>=1&&f[i-1][j-2]==0)add(i*m+j,(i-1)*m+j-2);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2==j%2&&f[i][j]==0){
				memset(vis,0,sizeof vis);
				if(find(i*m+j))ans++;
			}
		}
	}
	cout<<cnt-ans;
	return 0;
}
```

---

## 作者：Enoch2013 (赞：3)

# 知识点
- 二分图，建议大家先看一下我的 **[这篇专栏](https://www.luogu.com.cn/article/lrjw6tm4)**；
- 最小点覆盖，**[konig 定理证明](https://zhuanlan.zhihu.com/p/674117712)**。

# 相似题目
- **[P10937 車的放置](https://www.luogu.com.cn/problem/P10937)**

# 思路
这是一道经典的“马走日”问题，我们要让马走日时，走到的点和当前点的颜色不同，所以我们要把整个棋盘每个点交替染色，也就是相邻两点颜色不相同。然后在建图时判断奇偶性，求最大独立集即可。


```cpp
#include <bits/stdc++.h>
#define N 500005
#define wzx 205
using namespace std;
int n, m, e, u, v, pre[N], k = 0, match[N], dx[] = {0, -2, -2, -1, -1, 1, 1, 2, 2}, dy[] = {0, -1, 1, -2, 2, -2, 2, -1, 1};
bool mp[wzx][wzx];
bool vis[N];
struct Edge
{
    int to, ne;
} a[N];
void add(int u, int v)
{
    a[++k] = (Edge){v, pre[u]};
    pre[u] = k;
}
bool dfs(int x)
{
    for (int i = pre[x]; i; i = a[i].ne)
    {
        int to = a[i].to;
        if (!vis[to])
        {
            vis[to] = 1;
            if (!match[to] || dfs(match[to]))
            {
                match[to] = x;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    cin >> n >> m >> e;
    for (int i = 1; i <= e; i++)
    {
        cin >> u >> v;
        mp[u][v] = true;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!mp[i][j])
                for (int k = 1; k <= 8; k++)
                {
                    int xx = i + dx[k], yy = j + dy[k];
                    if (xx < 1 || xx > n || yy < 1 || yy > m || mp[xx][yy])
						continue;
					if ((xx + yy) & 1)
                        add((i - 1) * m + j, (xx - 1) * m + yy);
                }
    int res = 0;
    for (int i = 1; i <= n * m; i++)
    {
        memset(vis, 0, sizeof vis);
        res += dfs(i);
        // if (dfs(i))
        //     res++;
    }
    cout << ((n * m) - e - res);
    return 0;
}
```

![](https://jrenc.azurewebsites.net/api/signature?code=zHZRCCItO-yB8t7d2KyitELFDwADnXIotkeeIQL3juyNAzFucnyrWA%3D%3D&name=thanks%20for%20reading%20%20%20%20%20%20%20%20by%20%40Enoch(1069719)&animate=true&speed=0.5&color=blue)

---

## 作者：lly66666 (赞：3)

这是一道二分图最大独立集的问题。

我们可以先把所有地方的马能到达的地方连边，这时候就构成了一个二分图，因为我们要让所有马互不吃掉，那么每条边的两个点最多只能放一匹马，所以只能在图里相连的两个点中选一个，求最多能选几个点。

这时候问题就被转换成求二分图最大独立集的问题了。

然后跑一遍匈牙利算法就可以了。

附上代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> g[100005];
bool vis[105][105], col[100005];
int cp[100005], n, m, k, xnum, ynum, ans;
int dx[] = {-1, -2, -2, -1, 1, 2, 2, 1};
int dy[] = {-2, -1, 1, 2, -2, -1, 1, 2};
int id(int x, int y) {return (x - 1) * m + y;}
bool dfs(int x) {
	for(int i = 0; i < g[x].size(); i ++) {
		int v = g[x][i];
		if(!col[v]) {
			col[v] = true;
			if(!cp[v] || dfs(cp[v])) {
				cp[v] = x;
				return true;
			} 
		}
	}
	return false;
}
int main() {
	memset(vis, false, sizeof(vis));
	cin >> n >> m >> k;
	for(int i = 1; i <= k; i ++) cin >> xnum >> ynum, vis[xnum][ynum] = true;
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			if(vis[i][j] || ((i & 1) != (j & 1))) continue;
			for(int kk = 0; kk < 8; kk ++) {
				int tx = i + dx[kk], ty = j + dy[kk];
				if(tx < 1 || tx > n || ty < 1 || ty > m) continue;
                if(vis[tx][ty]) continue;
				g[id(i, j)].push_back(id(tx, ty));
			}
		}
	}
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			memset(col, false, sizeof(col));
			if(vis[i][j] || ((i & 1) != (j & 1))) continue;
			if(dfs(id(i, j))) ans ++;
		}
	}
	cout << n * m - k - ans;
	return 0;
}
```

完结撒花！

管理员大大大大大大大大大大大大大大大大大大求过。

---

## 作者：jrzhr (赞：2)

我们先把图按以下方式涂色。

![](https://cdn.luogu.com.cn/upload/image_hosting/pguvr6un.png)

我们发现马只可以从一个涂色的点跳到一个没涂色的点或者送没涂色的点跳到涂色的点，这是一个二分图。

于是问题就转换为了在二分图中，最多选出几个节点，使得他们之间没有边。即为求二分图的最大独立集。

而最大独立集等于节点数减去最小顶点覆盖，而最小顶点覆盖等于最大匹配。所以答案就等于节点数减去最大匹配。

代码如下：


```
#include<bits/stdc++.h>
using namespace std;
int n, m, T;
pair<int, int> match[110][110];
int res, g[110][110];
bool st[110][110];
int dx[10] = {1, -1, 2, -2, 1, -1, 2, -2};
int dy[10] = {2, 2, 1, 1, -2, -2, -1, -1};
bool find(pair<int, int> x){//匈牙利求最大匹配
	for(int i = 0; i < 8; i++){
        int a = x.first + dx[i];
        int b = x.second + dy[i];
        if(a < 1 || a > n || b < 1 || b > m || g[a][b] || st[a][b]) continue;
        st[a][b] = true;
        if(match[a][b].first == 0 || find(match[a][b])){
            match[a][b] = x;
            return true;
        }
	}
	return false;
}
int main(){
	scanf("%d%d%d", &n, &m, &T);
	for(int i = 1; i <= T; i++){
		int x, y;
		scanf("%d%d", &x, &y);
        g[x][y] = 1;
	}
	for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(!g[i][j] && (i + j) % 2 == 0){//枚举涂色的点
		        memset(st, 0, sizeof(st));
		        if(find({i, j})) res++;
            }
        }
	}
	printf("%d", n * m - res - T);//记住减去禁止放置的节点数
	return 0;
}
```

---

## 作者：run_away (赞：2)

## 题意

一张 $n\times m$ 的棋盘，上面有 $k$ 个点禁止放棋子，求至多可以放多少个国际象棋中的马，使得这些马无法互相攻击。

## 分析

考虑先填满棋盘，然后删去最少的点来满足条件。

这是网络流的最小割模型，把每个格点向可以攻击到的点连权值为 $+\infty$ 的边，表示这两个点只能留一个。

接下来把格点黑白染色，让图变成一张二分图，显然可以按照横纵坐标的奇偶性染。

从起点向左部点连权值为 $1$ 的边，从右部点向终点连权值为 $1$ 的边，表示删掉这些点的代价为 $1$。

跑最小割即可。

## Code

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
typedef __int128_t int128;
using namespace std;
// static char buf[100],*p1=buf,*p2=buf,obuf[100],*p3=obuf;
// #define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,100,stdin),p1==p2)?EOF:*p1++
// #define putchar(x) (p3-obuf<100)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
mt19937_64 rnd(chrono::system_clock::now().time_since_epoch().count());
#define dbg(x) cout<<#x<<": "<<x<<"\n"
#define usetime() printf("time: %.3lfs\n",clock()*1.0/CLOCKS_PER_SEC)
inline ll read(){ll x=0,f=1;char c=getchar();while(c<48||c>57){if(c==45)f=0;c=getchar();}while(c>47&&c<58)x=(x<<3)+(x<<1)+(c^48),c=getchar();return f?x:-x;}
inline void write(ll x){if(!x){putchar(48);putchar('\n');return;}short top=0,s[40];if(x<0)x=-x,putchar(45);while(x)s[top++]=x%10^48,x/=10;while(top--)putchar(s[top]);putchar('\n');}
namespace tobe{
	const ll maxn=1e2+5,mod=998244353;
	ll n,m,k,dx[9]={-1,1,2,2,1,-1,-2,-2},dy[9]={-2,-2,-1,1,2,2,1,-1};
    bool vis[maxn][maxn],flag[maxn*maxn];
    ll s,t,lvl[maxn*maxn],head[maxn*maxn],tot=1,now[maxn*maxn];
    struct edge{
    	ll to,nxt,val;
    }e[maxn*maxn*16];
    inline void add(ll u,ll v,ll w){
    	e[++tot]={v,head[u],w};
    	head[u]=tot;
    	e[++tot]={u,head[v],0};
    	head[v]=tot;
    }
    inline bool bfs(){
		memset(lvl,0,sizeof(lvl));lvl[s]=1;
		queue<ll>q;q.push(s);now[s]=head[s];
		while(!q.empty()){
			ll u=q.front();q.pop();
			for(ll i=head[u];i;i=e[i].nxt){
				ll v=e[i].to,w=e[i].val;
				if(w>0&&!lvl[v]){
					lvl[v]=lvl[u]+1;
					q.push(v);now[v]=head[v];
					if(v==t)return 1;
				}
			}
		}
		return 0;
	}
	inline ll dfs(ll u,ll f){
		if(u==t)return f;
		ll tmp=f;
		for(ll i=now[u];i&&tmp;i=e[i].nxt){
			now[u]=i;
			ll v=e[i].to,w=e[i].val;
			if(w&&lvl[v]==lvl[u]+1){
				ll k=dfs(v,min(w,tmp));
				if(!k)lvl[v]=0;
				e[i].val-=k,e[i^1].val+=k;
				tmp-=k;
			}
		}	
		return f-tmp;
	}
    inline ll id(ll x,ll y){return (x-1)*m+y;}
    inline void mian(){
    	n=read(),m=read(),k=read();
    	ll ans=n*m;
    	for(ll i=1;i<=k;++i){
    		ll x=read(),y=read();
    		if(!vis[x][y])--ans;
    		vis[x][y]=1;
    	}
    	for(ll i=1;i<=n;++i){
    		for(ll j=1;j<=m;++j){
    			if((i+j&1)==0||vis[i][j])continue;
    			for(ll k=0;k<8;++k){
    				ll x=i+dx[k],y=j+dy[k];
    				if(x<1||y<1||x>n||y>m||vis[x][y])continue;
    				add(id(i,j),id(x,y),INT_MAX);
    			}
    		}
    	}
    	s=0,t=n*m+1;
    	for(ll i=1;i<=n;++i){
    		for(ll j=1;j<=m;++j){
    			if((i+j)&1)add(s,id(i,j),1);
    			else add(id(i,j),t,1);
    		}
    	}
    	while(bfs())ans-=dfs(s,INT_MAX);
    	write(ans);
    }
}
signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ll t=1;
    while(t--)tobe::mian();
    // fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---

## 作者：JustPureH2O (赞：2)

[更好的阅读体验](https://justpureh2o.cn/articles/12834)

题目地址：[P10939](https://www.luogu.com.cn/problem/P10939)

> 给定一个 $N \times M$ 的棋盘，有一些格子禁止放棋子。
>
> 问棋盘上最多能放多少个不能互相攻击的骑士（国际象棋的“骑士”，类似于中国象棋的“马”，按照“日”字攻击，但没有中国象棋“别马腿”的规则）。
>
> $1 \le N,M \le 100$

看到数据范围，$N,M\leq100$，状压 DP 肯定是没戏的。于是寻找其他能够解决棋盘问题的算法。

棋盘是这样的（从隔壁 [P3355](https://www.luogu.com.cn/problem/P3355) 借的图）：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

骑士放在 $S$ 处，可以攻击到叉号的位置。

此时发现一个规律：骑士能攻击到的方格的颜色与当前被放置方格的颜色是相反的。如果我们让所有某色方格向能到达的异色方格连边，那么两个骑士能互相攻击到就意味着这两个骑士通过若干条边相连。

此时两种颜色的方格恰好组成一张二分图的左右部点；题目要求我们选择尽量多的点，使得选出的点任意两点不互通，我们就可以求这个二分图上的最大点独立集的大小来得到答案。

最大点独立集的大小可以用总点数减去最大匹配得到。由于本题设置了不可到达点，计算时同样也要减去、且进行匈牙利算法时需要排除它们。总的时间复杂度是 $\mathcal O(nm)$。

```cpp
#include <bits/stdc++.h>

#define N 210
using namespace std;

typedef pair<int, int> PII;

bool g[N][N];
PII match[N][N];
bool st[N][N];
int dx[8] = {-2, -1, 1, 2, -2, 1, -1, 2};
int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};
int n, m, k;

bool hungary(PII t) {
    for (int i = 0; i < 8; i++) {
        int nx = t.first + dx[i];
        int ny = t.second + dy[i];
        if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
        if (st[nx][ny] || g[nx][ny]) continue;
        st[nx][ny] = true;
        if (!match[nx][ny].first || hungary(match[nx][ny])) {
            match[nx][ny] = t;
            return true;
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++) {
        int a, b;
        cin >> a >> b;
        g[a][b] = true;
    }
    int res = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if ((i + j) % 2 || g[i][j]) continue;
            memset(st, false, sizeof st);
            if (hungary((PII) {i, j})) res++;
        }
    }
    cout << n * m - res - k << endl;
    return 0;
}
```

$\texttt{The End}$

---

## 作者：litangzheng (赞：1)

### 思路
![](https://cdn.luogu.com.cn/upload/image_hosting/9hy4knix.png)  
如图，这是一只象棋里的马，打钩的格子代表它能跳到这里来。  

观察一下，发现对于一只马，它只能从黑色格子跳到白色格子，从白色格子跳到黑色格子，而不能从白色格子跳到白色格子或从黑色格子跳到黑色格子。  

这个性质让我们想到了二分图，也就是一张图 $G$ 分为两个点集 $U$ 与 $V$ ，每个点集里没有互相相连的边，我们也就可以看成左边点集是白色格子，右边点集是黑色格子，如果两点连线表示马可以从这个格子跳到那个格子。  

两只马不能互相攻击，又让我们想到了最大独立集问题，也就是在一张图中选出最大的子集 $G$ ，使 $G$ 中任何一点都不连通，放在此题中就是最多的马都不能互相攻击。  

由于二分图的最大独立集等于总点数减最大匹配数，再将最大独立集减去 $T$ 就是答案了。  

### 代码  


```cpp
#include<bits/stdc++.h>
#define N 1005
using namespace std;
bool mp[N][N],st[N*N];
int n,m,t,head[N*N],cnt=1,dx[] = {0, -2, -2, -1, -1, 1, 1, 2, 2}, dy[] = {0, -1, 1, -2, 2, -2, 2, -1, 1},ans,match[N*N];
struct Edge{
    int to,nxt;
}edge[N*N];
void addedge(int u,int v){
    edge[cnt].to=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt++;
}
bool find(int x){
	for(int i=head[x];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!st[to]){
			st[to]=1;
			if(match[to]==0||find(match[to])){
				match[to]=x;
				return 1;
			}
		}
	}
	return 0;
}//最大匹配模板
int main(){
    cin>>n>>m>>t;
    for(int i=1;i<=t;i++){
        int x,y;
        cin>>x>>y;
        mp[x][y]=1;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int k=1;k<=8;k++){
                int x=i+dx[k],y=j+dy[k];
                if(x>=1&&x<=n&&y>=1&&y<=m&&!mp[i][j] &&(x+y) & 1&&!mp[x][y])
                    addedge((i-1)*m+j,(x-1)*m+y);
            }
        }
    }//核心是这一段建图
    for(int i=1;i<=n*m;i++){
		memset(st,0,sizeof(st));
		if(find(i)) ans++;
	}
	cout<<n*m-t-ans;//注意要减去T
}
```

---

## 作者：hanchengyi (赞：1)

## 思路

借鉴国际象棋棋盘的样式，我们将 $N \times M$ 的棋盘黑白染色，变成如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dbgtwg9j.png)

先不考虑不能放置的位置，假设在这个棋盘中间白色格子有一个骑士，它的攻击范围如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/l8tlkx1n.png)

可以发现攻击到的格点即白星所标处都是黑色格子，所以得出一个点的攻击点均与其异色。由颜色计算公式 `x+y&1` 易证。

给每个格子编号，容易想到将白色的格子按编号放在一边，黑色放在一边。对于每个可以放置的格子，与对面颜色的攻击点连边，构成一个二分图，然后跑匈牙利算法求最大匹配。

但是你会发现这道题的答案不是最大匹配数。我们要求的是最多能放的骑士数量，即最大独立集，它等于总点数减最小点覆盖。而在二分图中，最小点覆盖等于最大匹配数，求解完成。复杂度是匈牙利的 $O(n^3)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=205;
const int N=NN*NN*4;
int n,m;
int x,y;
int h[N],v[N],nt[N],cnt;
void add(int x,int y){//链式前向星
	v[++cnt]=y;
	nt[cnt]=h[x];
	h[x]=cnt;
}
bool vis[N];
int used[N];
bool dfs(int x){//匈牙利板子
	int y;
	for(int i=h[x];i;i=nt[i]){
		y=v[i];
		if(vis[y]) continue;
		vis[y]=1;
		if(!used[y]||dfs(used[y])) {
			used[y]=x;
			return 1;
		}
	}return 0;
}
bool u[NN][NN];
int dx[]={-2,-2,-1,-1,1,1,2,2};
int dy[]={-1,1,-2,2,-2,2,-1,1};//攻击点
int ans;//最大点覆盖
int t;
int main(){
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=t;i++) {
		scanf("%d%d",&x,&y);
		u[x][y]=1;//不能放
	}
	int nx,ny,tx,ty;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
		if(u[i][j]) continue;
		tx=(i-1)*m+j;
		for(int k=0;k<8;k++){//向八个攻击点建边
			nx=i+dx[k],ny=j+dy[k];
			if(nx<1||nx>n||ny<1||ny>m) continue;
			if(u[nx][ny]) continue;
			if(nx+ny&1){
				ty=(nx-1)*m+ny;
				add(tx,ty);
			}
		}
	}
	for(int i=1;i<=n*m;i++){
		memset(vis,0,sizeof(vis));
		if(dfs(i)) ans++;
	}
	cout<<n*m-ans-t; 
	//总数-不能放-最小点覆盖
}
```

---

## 作者：Lele_Programmer (赞：0)

# P10939 题解

## 思路

若当前点为黑色，相邻的四个点颜色则为白色，将点分成黑点和白点，发现一个处于黑点的骑士，只能跳到白点，处于白点的骑士，只能跳到黑点。

从源点向黑点连边，白点向汇点连边，不能同时存在棋子的黑白点之间连边。

求一遍最小割，得到的结果是断掉多少条边，可以使源点汇点不连通，断掉与源点连接的边，意义就是不在某个黑点放置，断掉与汇点连接的边，意义就是不在某个白点放置，用点数减掉最小割即可。

根据最大流最小割定理，最大流等于最小割，这里不深入证明了。

还要注意，有一些点被禁止了，也就是遇到这些点就不去连边了，统计答案的时候总点数也要减掉这些点。

## 代码

调试火车头懒得删了，就这样吧。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define BETTER

#ifdef BETTER

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define rint register int
#define LL long long

#endif

#ifdef DEBUG

#define TIMESTAMP cerr<<fixed<<setprecision(3)<<clock()*1.0/CLOCKS_PER_SEC<<"s"<<endl;

namespace PRINT {
    template<typename T> inline void PVAL(T x) { cerr<<x; }
    template<typename T> inline void PVALS(T x) { cerr<<x<<' '; }
    template<typename T> inline void PVALLN(T x) { cerr<<x<<endl; }
    template<typename T> inline void PVEC(vector<T> vec) { for (int i=0;i<vec.size();++i) PVALS(vec[i]); putchar(10); }
    template<typename T> inline void PQUE(queue<T> q) { while (!q.empty()) PVALS(q.front()),q.pop(); putchar(10); }
    template<typename T> inline void PDQU(deque<T> q) { while (!q.empty()) PVALS(q.front()),q.pop_front(); putchar(10); }
    template<typename T> inline void PSET(set<T> s) { for (typename set<T>::iterator it=s.begin();it!=s.end();++it) PVALS(*it); putchar(10); }
    template<typename T> inline void PUSET(unordered_set<T> s) { for (typename unordered_set<T>::iterator it=s.begin();it!=s.end();++it) PVALS(*it); putchar(10); }
    template<typename T,typename T2> inline void PMAP(map<T,T2> s) { for (typename map<T,T2>::iterator it=s.begin();it!=s.end();++it) PVAL(it->first),PVAL(": "),PVALLN(it->second); }
    template<typename T,typename T2> inline void PUMAP(unordered_map<T,T2> s) { for (typename unordered_map<T,T2>::iterator it=s.begin();it!=s.end();++it) PVAL(it->first),PVAL(": "),PVALLN(it->second); }
    template<typename T> inline void PARR(T* arr,int n) { for (int i=1;i<=n;++i) PVALS(arr[i]); putchar(10); }
    template<typename T> inline void PARR(T* arr,int l,int r) { for (int i=l;i<=r;++i) PVALS(arr[i]); putchar(10); }
    template<typename T> inline void PARR(T* arr,int n,string name) { for (int i=1;i<=n;++i) PVAL(name),PVAL("["),PVAL(i),PVAL("] = "),PVALLN(arr[i]); }
    template<typename T> inline void PARR0(T* arr,int n) { for (int i=0;i<=n;++i) PVALS(arr[i]); putchar(10); }
    template<typename T> inline void PARR0(T* arr,int n,string name) { for (int i=0;i<=n;++i) PVAL(name),PVAL("["),PVAL(i),PVAL("] = "),PVALLN(arr[i]); }
    template<typename T> inline void PARR2D(T** arr,int n,int m) { for (int i=1;i<=n;++i) { for (int j=1;j<=m;++j) PVALS(arr[i][j]); putchar(10); } }
}

using namespace PRINT;

#else

#define TIMESTAMP

namespace PRINT {
    template<typename T> inline void PVAL(T x) { ; }
    template<typename T> inline void PVALS(T x) { ; }
    template<typename T> inline void PVALLN(T x) { ; }
    template<typename T> inline void PVEC(vector<T> vec) { ; }
    template<typename T> inline void PQUE(queue<T> q) { ; }
    template<typename T> inline void PDQU(deque<T> q) { ; }
    template<typename T> inline void PSET(set<T> s) { ; }
    template<typename T> inline void PUSET(unordered_set<T> s) { ; }
    template<typename T,typename T2> inline void PMAP(map<T,T2> s) { ; }
    template<typename T,typename T2> inline void PUMAP(unordered_map<T,T2> s) { ; }
    template<typename T> inline void PARR(T* arr,int n) { ; }
    template<typename T> inline void PARR(T* arr,int l,int r) { ; }
    template<typename T> inline void PARR(T* arr,int n,string name) { ; }
    template<typename T> inline void PARR0(T* arr,int n) { ; }
    template<typename T> inline void PARR0(T* arr,int n,string name) { ; }
    template<typename T> inline void PARR2D(T** arr,int n,int m) { ; }
}

using namespace PRINT;

#endif

#ifdef FASTIO

namespace IO {
    inline void read(int &a) {
        int sym=1,num=0;
        char c=getchar();
        while (c<'0' || c>'9') {
            if (c=='-') {
                sym=-1;
            }
            c=getchar();
        }
        while (c>='0' && c<='9') {
            num=num*10+c-'0';
            c=getchar();
        }
        a=sym*num;
    }
    inline void write(int a) {
        if (a<0) {
            putchar('-');
            a*=-1;
        }
        if (a>=10) {
            write(a/10);
        }
        putchar(a%10+'0');
    }
}

using namespace IO;

#endif

const int N=10005;
const int M=200005;
const int inf=2e9;

int n,m,t,S,T;
int e[M],ne[M],f[M],h[N],tot;
int dep[N],cur[N];
bool flag[N];
int dx[8]={-1,-2,-2,-1,1,2,2,1};
int dy[8]={-2,-1,1,2,2,1,-1,-2};

void add(int a,int b,int c) {
    e[tot]=b,f[tot]=c,ne[tot]=h[a],h[a]=tot++;
    e[tot]=a,f[tot]=0,ne[tot]=h[b],h[b]=tot++;
}

bool bfs() {
    queue<int> q;
    memset(dep,-1,sizeof(dep));
    q.push(S); dep[S]=0; cur[S]=h[S];
    while (!q.empty()) {
        int u=q.front(); q.pop();
        for (int i=h[u];~i;i=ne[i]) {
            if (!~dep[e[i]] && f[i]) {
                dep[e[i]]=dep[u]+1;
                cur[e[i]]=h[e[i]];
                if (e[i]==T) return true;
                q.push(e[i]);
            }
        }
    }
    return false;
}

int dfs(int u,int limit) {
    if (u==T) return limit;
    int k=0;
    for (int i=cur[u];~i && k<limit;i=ne[i]) {
        cur[u]=i;
        if (dep[e[i]]==dep[u]+1 && f[i]) {
            int ret=dfs(e[i],min(limit-k,f[i]));
            if (!ret) dep[e[i]]=-1;
            else k+=ret,f[i]-=ret,f[i^1]+=ret;
        }
    }
    return k;
}

int dinic() {
    int ans=0,k;
    while (bfs()) while (k=dfs(S,inf)) ans+=k;
    return ans;
}

int get(int i,int j) {
    return (i-1)*m+j;
}

bool check(int i,int j) {
    return i>=1 && j>=1 && i<=n && j<=m && !flag[get(i,j)];
}

int main() {
    memset(h,-1,sizeof(h));
    scanf("%d %d %d",&n,&m,&t); S=0,T=N-1;
    int cnt=n*m;
    while (t--) {
        int a,b;
        scanf("%d %d",&a,&b);
        if (!flag[get(a,b)]) cnt--;
        flag[get(a,b)]=true;
    }
    _rep(i,1,n) {
        _rep(j,1,m) {
            if (flag[get(i,j)]) continue;
            if ((i&1)==(j&1)) {
                add(S,get(i,j),1);
                _rep(p,0,7) if (check(i+dx[p],j+dy[p])) add(get(i,j),get(i+dx[p],j+dy[p]),1);
            } else add(get(i,j),T,1);
        }
    }
    int k=dinic();
    printf("%d",cnt-k);
    return 0;
}
```

---


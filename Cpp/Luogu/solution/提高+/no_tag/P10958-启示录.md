# 启示录

## 题目描述

古代人认为 $666$ 是属于魔鬼的数。

不但如此，只要某数字的十进制表示中有三个连续的 $6$，古代人也认为这是个魔鬼的数，比如 $666,1666,6663,16666,6660666$ 等等。

古代典籍中经常用“第 $X$ 小的魔鬼的数”来指代这些数，这给研究人员带来了极大的不便。

现在请编写一个程序，可以实现输入 $X$，输出对应的魔鬼数。

## 说明/提示

$1 \le T \le 1000$，$1 \le X \le 5 \times 10^7$。

## 样例 #1

### 输入

```
3
2
3
187```

### 输出

```
1666
2666
66666```

# 题解

## 作者：cff_0102 (赞：8)

数位 dp 经典题，今天能在洛谷看到十分激动。

记忆化搜索实现的数位 dp 真的太好写也太好理解了吧。

代码中 $l1,l2$ 分别为上一位和上上位是否为 $6$。

可以用二分找到对应的数。

不知道多久以前写的代码，十分易懂：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[20][2][2];
int a[20];
int dfs(int p,bool l2,bool l1,bool lim){
	if(p==-1)return 1;
	if(!lim&&dp[p][l2][l1]!=-1)return dp[p][l2][l1];
	int up=lim?a[p]:9;
	int s=0;
	for(int i=0;i<=up;i++){
		if(l2&&l1&&i==6)continue;
		s+=dfs(p-1,l1,i==6,lim && i==a[p]);
	}
	if(!lim)return dp[p][l2][l1]=s;
	return s;
}
int solve(int x){//返回 1-x 之间有几个非恶魔数 
	int p=0;
	while(x){
		a[p++]=x%10;
		x/=10;
	}
	return dfs(p-1,0,0,1);
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	for(int i=0;i<20;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)dp[i][j][k]=-1;
	int t;cin>>t;
	while(t--){
		int n;cin>>n; 
		int l=665,r=9999999999ll;
		while(l<r){
			int mid=(l+r)>>1;
			if(mid+1-solve(mid)<n){
				l=mid+1;
			}else{
				r=mid;
			}
		}
		cout<<l<<endl;
	} 
	return 0;
}
```

---

## 作者：elonzhang (赞：3)

# [P10958 启示录](https://www.luogu.com.cn/problem/P10958)

## 前置知识

[数位 dp ](https://oiwiki.com/dp/number/)或者[记忆化 dfs](https://oiwiki.com/dp/memo/)（不会的看 oiwiki 链接）。

## 思路

记忆化 dfs 枚举每一位数，dfs 有 $6$ 个参数 `int dfs(int pos,int p1,int p2,bool f,bool fl,bool f666)`，分别是当前位数、前一位、前两位、是否可以无限制放置、是否在放置前导零、是否已经达成目标。在记忆化过程中只保留 $f\gets 1$ 的情况就可以了。然后在往下递归时注意更新三个布尔值和前两位的数就可以了。也就是在 $i<num_{pos}$ 时使 $f\gets1$，使 $fl\gets fl|i$，在达成 $i=p_1=p_2=6$ 时使 $f666\gets1$ 就可以了。这样我们就得到了求所有小于 $x$ 的魔鬼数总数量的函数 $js(x)$ 了。然后题目要求的是第几个魔鬼数是什么，我们只需要一个二分：如果 $js(mid)<a$ 那么 $l\gets mid+1$，否则 $r\gets mid$。思路会了代码就很简单了。

## ACcode

```cpp
#include <bits/stdc++.h>
using namespace std;
#define freop(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define int long long
#define double long double
#define re register
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
#define lowbit(x) (x&-x)
#define pii pair<int,int>
#define fir first
#define sec second
#define umap unordered_map
#define uset unordered_set
const int N=30,M=15;
int T,a,tot,vis[N][M][M][2],num[N];

bool c(int p1,int p2,int x){return !(x^6||p1^6||p2^6);}
inline int dfs(int pos,int p1,int p2,bool f,bool fl,bool f666){
	if(!pos) return f666;
	int sum=vis[pos][p1][p2][f666];
	if(f&&sum>=0) return sum;
	else{
		sum=0;
		int mx=(f?9:num[pos]);
		for(int i = 0;i<=mx;++i){
 			sum+=dfs(pos-1,i,p1,f|(i<num[pos]),fl|i,c(p1,p2,i)|f666);
		}
	}
	if(f) vis[pos][p1][p2][f666]=sum;
	return sum;
}
inline int js(int x){
	tot=0;
	while(x) num[++tot]=x%10,x/=10;
	return dfs(tot,10,10,0,1,0);
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(vis,-1,sizeof(vis));
//	freop();
//↑以上为初始化↑
//------------------------------
	cin >> T;
	while(T--){
		cin >> a;
		int l=666,r=1145141919810,mid;
		while(l<r){
			mid=(l+r)>>1;
			if(js(mid)>=a) r=mid;
			else l=mid+1;
		} 
		cout << l << endl;
	}
	return 0;
}
```

---

## 作者：Brilliant11001 (赞：3)

#### [更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18391140)

用记忆化搜索写数位 dp 真的很好写！

## [题目传送门](https://www.luogu.com.cn/problem/P10958)

### 题目大意：

$T$ 组数据，每次询问第 $x$ 个含有至少 $3$ 个连续 $6$ 的数是什么。

### 思路：

考虑数位 dp。

一般数位 dp 问题有两种常见形式：

1. 询问 $[l, r]$ 内有多少个符合条件的数；
2. 询问满足条件的第 $k$ 大（小）的数是什么。

很显然这道题是第二种形式。

首先问题 $1$ 很简单，那我们考虑将第二个问题转化成第一个问题来做。

因为答案具有单调性，于是可以二分判定。

每次二分到一个值 $mid$，计算 $[1, mid]$ 的魔鬼数个数，若大于等于 $x$，则说明所求在 $mid$ 左侧，否则在 $mid$ 右侧。

接着考虑问题 $1$，这里采用记忆化搜索的方式，注释在代码中。

```cpp
//pos 记录当前填到了哪一位，cnt 记录当前末尾有几个连续的 6，flag 记录当前数是否满足条件
//limit 记录当前有没有顶上界
//因为这道题有没有前导零无影响，遂不记录
int dfs(int pos, int cnt, bool flag, bool limit) {
    //边界，若填完了就检查一下是否符合条件
    if(pos < 0) return flag;
    //若不顶上界就记忆化，因为顶上界是特殊情况，满足条件的数可能和普通情况不同
    if(!limit && f[pos][cnt][flag] != -1) return f[pos][cnt][flag];
    //看一下当前这位需不需要顶上界，若前面填的数都是贴着上界的，这一位最多只能填到 num[pos]，否则不受限
    int mx = (limit ? num[pos] : 9);
    int res = 0;
    //枚举第 pos 位填什么
    for(int i = 0; i <= mx; i++) {
        //处理连续的 6
        int ncnt;
        if(i == 6) ncnt = cnt + 1;
        else ncnt = 0;
        res += dfs(pos - 1, ncnt, flag || (ncnt >= 3), limit && (i == num[pos]));
    }
    //若不顶上界就记忆化
    if(!limit) f[pos][cnt][flag] = res;
    return res;
}
```

这里我直接把二分值域拉满了，但是实测发现第 $50000000$ 个魔鬼数只有 $6668056399$。

时间复杂度为：$O(N^2MT\log V)$，这里 $N$ 表示数字位数，$V$ 表示二分值域，$M$ 表示每次枚举填的数的个数，可看作 $10$。

$\texttt{Code:}$
```cpp
#include <vector>
#include <cstring>
#include <iostream>

using namespace std;
typedef long long ll;

const int N = 20;

int T;
int x;
ll f[N][N][2];
vector<int> num;

ll dfs(int pos, int cnt, bool flag, bool limit) {
    if(pos < 0) return flag;
    if(!limit && f[pos][cnt][flag] != -1) return f[pos][cnt][flag];
    int mx = (limit ? num[pos] : 9);
    ll res = 0;
    for(int i = 0; i <= mx; i++) {
        int ncnt;
        if(i == 6) ncnt = cnt + 1;
        else ncnt = 0;
        res += dfs(pos - 1, ncnt, flag || (ncnt >= 3), limit && (i == num[pos]));
    }
    if(!limit) f[pos][cnt][flag] = res;
    return res;
}

ll calc(ll x) {
    num.clear();
    ll tmp = x;
    while(tmp) {
        num.push_back(tmp % 10);
        tmp /= 10;
    }
    return dfs(num.size() - 1, 0, 0, 1);
}

void solve() {
    scanf("%d", &x);
    ll l = 1, r = 5e18;
    while(l < r) {
        ll mid = l + r >> 1;
        if(calc(mid) >= x) r = mid;
        else l = mid + 1;
    }
    printf("%lld\n", l);
}

int main() {
    scanf("%d", &T);
    memset(f, -1, sizeof f);
    while(T--) {
        solve();
    }
    return 0;
}
```

---

## 作者：HasNoName (赞：3)

### 思路

考虑数位 dp。

定义 $f_{n,k}$ 表示当从高往低便利到第 $n$ 位时，到第 $n$ 项时有连续 $k$ 个 $6$ 的后面随便选的方案总数。

定义 $n=0$ 时表示个位。

显然当 $k\ge 3$ 时，后面取任何值都合法，故可以均视为 $k=3$。则 $f_{n,3}=10^n$。

对于 $k<3$ 时则有 $f_{n,k}=f_{n-1,0}\times 9+f_{n-1,k+1}$。

因为如果后一项取 $6$ 则 $k$ 为增加 $1$；否则对于另外 $9$ 种情况每种均以前没有连续的 $6$，故为 $f_{n-1,0}\times 9$。

考虑如何求出第 $N$ 个魔鬼数。

从高到低枚举每一位，数字再从 $0$ 到 $9$ 枚举，设当前位的数字为 $x$。

则如果这一位为 $0$ 到 $x$ 的方案总数大于等于 $N$ 则这一位为 $x$。

但每次 $N$ 需要减去这一项为 $0$ 到 $x-1$ 的每一种方案。

需要考虑到这一项为 $6$ 和前面连续 $6$ 的个数。

需要注意如果已经有连续 $3$ 个 $6$ 出现了，则后面所有方案均满足条件。

由于 $N\le5\times 10^7$，所以光最后面的三位数为 $6$ 的最大可能答案都少于 $10^{12}$，所以只要保证枚举最高位数大于等于 $12$ 即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//要开long long
ll f[20][4];
void run(ll n)
{
	bool flag=0;
	int p=0;
	for(int i=13;i>=0;i--)//枚举每一位
	{
		ll cnt=0,ne=0;
		for(int j=0;j<=9;j++)//枚举每一位的值
		{
			if(j==6||p==3)cnt+=f[i][p==3?p:p+1];//p>4和p=4方案一样，故不变
			else cnt+=f[i][0];//打断连续的6
			if(cnt>=n)
			{
				if(j)flag=1;//如果首位为0则不输出
				if(j!=6&&p<3)p=0;
				else if(p<3)p++;//增加连续6的长度
				if(flag)cout<<j;
				n-=ne;//从这一位剩下的方案中选取
				break;
			}
			ne=cnt;
		}
	}
	cout<<'\n';
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	f[0][3]=1;//边界条件
	for(int i=1;i<=14;i++)//用地推方式求出f[n][k]
	{
		f[i][0]=f[i-1][0]*9+f[i-1][1];
		f[i][1]=f[i-1][0]*9+f[i-1][2];
		f[i][2]=f[i-1][0]*9+f[i-1][3];
		f[i][3]=f[i-1][3]*10;
	}
	int T,n;
	cin>>T;
	while(T--)
	{
		cin>>n;
		run(n);
	}
	return 0;
}
```

---

## 作者：mirance2025 (赞：3)

### 题目描述

众所周知，一位 OIer 需要至少将题目读 3 遍。

[P10958 启示录](https://www.luogu.com.cn/problem/P10958)

### 题意分析 + soultion

[数位 DP](https://oiwiki.org/dp/number/)，了解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/rbw0q6dy.png)

预处理 $f_{i, j}$ 后，我们可以求出第 $X$ 小的魔鬼数的位数 $cnt$，然后就是从高位开始，确定每一位的值是多少了。

#### 如何确定每一位的值？

第一步，我们可以先算下有多少个魔鬼数，首先是 $i - 1$ 位的魔鬼数，然后从 $0$ 到 $9$ 遍历 $i$ 位数字时可能这位数字是 $6$，当其为 $6$ 或前 $i$ 的前 $3$ 个数都为 $6$ 时，再加上可能的魔鬼数，这样遍历 $i$ 位时总的魔鬼数就算出来了，当魔鬼数 $ cnt < X$ 时，说明当前遍历的这个数 $i$ 太小了，这时 $X$ 要：$X − cnt$。

#### 为什么？

假设我们要求第 $19$ 小的魔鬼数（$9666$），从 $0$ 开始遍历最高位，后面可能的魔鬼数为 $1$，$19 − 1$ 表示从 $0666$ 开始排名为 $18$ 的魔鬼数。

所以 $X − cnt$ 的作用即：在 $i$ 位为 $j$ 时的最大魔鬼数的基础上即 $i$ 位为 $j + 1$ 时第 $X − cnt$ 个魔鬼数即答案。

当 $cnt \ge X$ 时，由于 $cnt$ 指的是当前位为 $j$ 时的可能的所有魔鬼数，而我们要求的是 $i$ 位为 $j$ 中第 $X$ 大的魔鬼数，说明此时 $i$ 位为 $j$ 包含了答案，$j$ 正是第 $i$ 位，接着记录有多少个连续的 $6$，下一位同样如此处理。

#### 时间复杂度

$O (mT)$

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>

using namespace std;

using LL = long long;

LL f[21][4];//注意魔鬼个数可能很多，可能会爆int

void init(){
    f[0][0] = 1;//由0位构成，且没有魔鬼数的非魔鬼数为1？为什么初始化要这样？不妨注意一下它的转移：f[i][1]=f[i-1][0],f[1][0]=f[0][0]=1,f[1][1]=1表示6，合理
    for (int i = 1; i < 20; i ++ ){
        f[i][0] = 9 * (f[i - 1][0] + f[i - 1][1] + f[i - 1][2]);
        f[i][1] = f[i - 1][0];
        f[i][2] = f[i - 1][1];
        f[i][3] = 10 * f[i - 1][3] + f[i - 1][2];
    }
}
int main(){
    init();
    int T, n;
    for(scanf("%d", &T);T --;){
        scanf("%d", &n);
        int m = 3;//m记录第n小的魔鬼数的位数
        while(f[m][3] < n) m ++;
        for (int i = m, k = 0; i; i -- ){//从高位到低位，k记录高位出有多少个连续的6
            for (int j = 0; j <= 9; j ++ ){//该位从小到大枚举每一个数
                LL cnt = f[i - 1][3];//记录i-1位有多少个数是魔鬼数
                if(j == 6 || k == 3)
                    for (int t = max(3 - k - (j == 6), 0); t < 3; t ++ )//t记录还剩多少个6
                        cnt += f[i - 1][t];
                if(cnt < n) n -= cnt;//说明≥j+1
                else{
                    if(k < 3){
                        if(j == 6) k ++;//i位前面有连续k个0
                        else
                            k = 0;//断掉了连续的6
                    }
                    printf("%d", j);
                    break;
                }
            }
        }
        putchar('\n');
    }

    return 0;
}
```

都看到这了，点个赞，关注 [zzxzzxCCC](https://www.luogu.com.cn/user/500803) 再走吧。

---

## 作者：Statax (赞：3)

# P10958 启示录题解

[戳我跳转至题面](https://www.luogu.com.cn/problem/P10958)

## 题目分析

某数为魔鬼数当且仅当该数含有连续的三个或以上的 6，求第 $k$ 小的魔鬼数。

## 题目思路

考虑数位 DP。

一般的数位 DP 问题有两种常见的提问形式：

- 询问 $[l, r]$ 内有多少个符合条件的数，
- 询问满足条件的第 $k$ 大（小）的数。

很显然这道题是第二种形式，即求第 $k$ 小的魔鬼数。

具体的，令 $f_{i,j} (0 \leq j \leq 2)$ 为以 $j$ 个 6 开头的 $i$ 位数的个数。

接着定义 $g_i$ 为 $i$ 位魔鬼数的个数，显然我们可以得到如下转移方程。

$$
\begin{array}{c}
f_{i,0}=9 \times (f_{i - 1, 0} + f_{i - 1, 1} + f_{i - 1, 2})\\
f_{i, 1} = f_{i - 1, 0}\\
f_{i, 2} = f_{i - 1, 1}\\
g_i = f_{i - 1, 2} + g_{i - 1} \times 10\\
\end{array}
$$

随后使用试填法从高往低依次填数，同时维护当前末尾有多少个 6。（细致部分见代码）

## 题目代码

```cpp
#include <iostream>
#include <cstdio>
#include <string.h>

#define endl '\n'
#define int long long
#define lowbit(x) x & (-x)

using namespace std;
const int N = 25;

int n;
int f[N][4];

int get(int x) {
	int ret = 3;
	for(;x >= f[ret][3]; ++ret) ;
	return ret;
}
// 初始化函数
void init() {
	f[0][0] = 1;
	for(int i = 1;i <= 20; ++i) {
		f[i][0] = 9 * (f[i - 1][0] + f[i - 1][1] + f[i - 1][2]);
		f[i][1] = f[i - 1][0];
		f[i][2] = f[i - 1][1];
		f[i][3] = f[i - 1][2] + f[i - 1][3] * 10;
 	}
}

// 输入函数
void input() {
	cin >> n;	
}

// 处理函数
void solve() {
	int m = get(n), k = 0, ans = 0; // 获取第 n 大魔鬼数的数位
	for(int i = m;i >= 1; --i) { // 从高到低尝试填出每一位的数
		for(int j = 0;j <= 9; ++j) { // 从小到大枚举第 i 位填的数字
			int cnt = f[i - 1][3];// cnt 的含义为后面 i - 1 位有多少种填法能让整个数是魔鬼数
			
			if(k == 3 || j == 6) 
				for(int l = max(3 - k - (j == 6), 0ll);l < 3; ++l) cnt += f[i - 1][l];
			if(cnt < n) n -= cnt; // 如果 cnt 比 n 小，说明魔鬼数的第 i 位应该比 j 大
			else { // 否则第 i 位就应该填 j，因为 j 是按照从小到大枚举的
				if(k < 3) {
					switch(j) {
						case 6: { ++k; break; }
						default: { k = 0; break; }
					}
				}ans = ans * 10 + j; break;
			}
		}
	}cout << ans << endl;
}

// 输出函数
void output() {
	
}

// 任务函数
void task() {
	input();
	solve();
	output();	
}

// 主函数
signed main() {
	int ___; cin >> ___;
	init(); while(___ --) task();
	return 0;
}
```

---

## 作者：ZPB2011 (赞：2)

# [启示录](https://www.luogu.com.cn/problem/P10958)

## 前置芝士

[数位 dp](http://oi-wiki.com/dp/number/)。

## 思路

这题还是比较模板的。

数位 dp 的一道较为模板的题，作者用的是记忆化来写，可以设置参数 `pre1 pre2` 来记录前两位是什么，`limit` 是指前面是否都是当前能去的值的最大值。

在每次 dp 的时候记录前两位和用数组记录下现答案即可。

为了防止 `TLE` 在求答案时可以使用二分来优化。

时间复杂度为 $O(N^2MT \log V)$，这里 N 表示数字位数，V 表示二分值域，M 表示每次枚举填的数的个数。

[AC记录](https://www.luogu.com.cn/record/189128919)。

## AC code

```cpp
#include <iostream>
#include <cstring>
#define int long long//十年OI一场空，不开long long见祖宗
using namespace std;

const int N = 25;

int x, num[N], f[N][2][2];

int dfs(int pos, int pre1, int pre2, bool limit) {
	if(!pos) return 1;
	if(!limit && f[pos][pre1][pre2] > -1) return f[pos][pre1][pre2];
	int maxn = 9;
	if(limit) maxn = num[pos];
	int sum = 0;
	for(int i = 0; i <= maxn; i++) {
		if(i == 6 && pre1 && pre2) continue;
		sum += dfs(pos - 1, pre2, (i == 6), limit && (i == maxn));
	}
	if(!limit) f[pos][pre1][pre2] = sum;//记忆化
	return sum;
}

bool check(int mid) {
	int len = 0, tmp = mid;
	while(tmp != 0) {
		num[++len] = tmp % 10;
		tmp /= 10;
	}
	return (mid - dfs(len, 0, 0, 1) + 1) >= x;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin >> t;
	while(t--) {
		memset(f, -1, sizeof(f));
		cin >> x;
		int l = 0, r = 1e18;
		while(l <= r) {//二分优化
			int mid = (l + r) / 2;
			if(check(mid)) r = mid - 1;
			else l = mid + 1;
		} 
		cout << l << endl;
	}
	return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

## 简要题意

定义一个正整数数是好的，当且仅当十进制数码中包含子串 $666$。

$T$ 组数据，每组数据给出一个 $k$，你需要求出第 $k$ 小的好的数。

$1\leq x\leq 5\times 10^7,1\leq T\leq 10^3$。

## 思路

基础数位 dp 练习题。

先二分，转为给定前缀 $[1,p]$，求这段前缀内有多少个好的数。

设 $f(p, 0/1, 0/1, c)$ 表示从高到低考虑到第 $p$ 位，这一位填的数是否受到上界 $p$ 的限制，是否已经有了一个 $666$，如果没有 $666$ 则当前位匹配到了第几个 $6$。

转移容易，枚举下一位填什么即可。注意如果填了一个不是 $6$ 的位 $c$ 要清零。

时间复杂度 $O(T\log^2 f(k))$，其中 $f(k)$ 表示第 $k$ 个好的数。

## 代码

```cpp
// Problem: P10958 启示录

#include <bits/stdc++.h>
#define int long long
using namespace std;

int f[55][2][2][5];
int a[55], tot;

int dp(int pos, bool lim, bool got, int match){
    if(pos > tot) return got;
    if(f[pos][lim][got][match] != -1) return f[pos][lim][got][match];
    int bd = lim ? a[pos] : 9;
    int& ret = f[pos][lim][got][match]; ret = 0;
    for(int i=0;i<=bd;i++){
        ret += dp(pos + 1, lim && i == bd, got || (match == 2 && i == 6), i == 6 ? ((match + (i == 6)) % 3) : 0);
        ret = min(ret, (long long)INT_MAX);
    }
    return ret;
}

int solve(int x){
    tot = 0;
    while(x){
        a[++tot] = x % 10;
        x /= 10;
    }
    reverse(a + 1, a + tot + 1);
    memset(f, -1, sizeof(f));
    return dp(1, 1, 0, 0);
}

int find(int x){
    int L = 0, R = 1e18;
    while(L < R){
        int mid = (L + R) >> 1;
        if(solve(mid) >= x) R = mid;
        else L = mid + 1;
    }
    return L;
}

void solve(){
    int x; cin >> x;
    cout << find(x) << '\n';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

// Written by xiezheyuan
```

## 相似题目分享

- [Gym 105323F 810975](https://codeforces.com/gym/105323/problem/F) 本题为子串匹配，这道题为子序列匹配，也是求第 $k$ 小满足要求的数。

---

## 作者：AndrewBer (赞：1)

# 启示录

[P10958 启示录 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P10958)

## 题目大意

> 只要十进制表示中含有一段三个连续的6，就成这个数为魔鬼数。输出从小到大第$X$个魔鬼数

## 思路

对于区间中统计符合特定要求的数的数量，很容易想到数位统计$dp$.

很容易想到，一个魔鬼数肯定是由一个非魔鬼数从最高位加入三个连续的6得来的，所以

令$f[i][3]$表示$i$位的魔鬼数数量，$f[i][j]\ ,\ j\in[0,2] $表示开头有连续$j$个6，长度为$i$的非魔鬼数的数量。(允许有前导零)

然后有如下转移方程

$f[i][0] = 9*(f[i-1][0] + f[i-1][1] + f[i-1][2])$

$f[i][1] = f[i-1][0]$

$f[i][2] = f[i-1][1]$

$f[i][3] = 10*f[i-1][3] + f[i-1][2]$

然后我们就可以根据转移方程，预处理出$f$.

### 统计

对于答案的统计分为么几步

- 通过$f[i][3]$得出第$X$个魔鬼数的长度
- 然后用试填法，从高到低依次确定每一位，具体来说：
  - 从$0-9$枚举第$i$位数字$p$
  - 如果填好的数中已经有连续的三个6了，则能让得到的数为魔鬼数的后$i-1$位的填法有$cnt = cnt + \Sigma_{j=0}^{3}f[i-1][j]$种
  - 如果没有，如果$p=6$,假设有$k$个6与第$i$位相连，则能让得到的数为魔鬼数的后$i-1$位的填法有：$cnt = cnt + f[i-1][3] + \Sigma_{j=3-k-1}^{2}f[i][j]$。
  - 如果$p!=6$,则填法有$cnt = cnt + f[i-1][3]$。
  - 如果填法数小于n,令$n = n - cnt$,然后$p$继续向后枚举$p$。
  - 否则说明这一位就该填$p,n$减去$cnt$后，枚举下一位。

- 最后得到的数就是第$X$个魔鬼数

思路就是如此，有些像平衡树中节点前驱后继查找的感觉。具体实现有些细节和技巧，代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
long long f[21][4];

void init()
{
	f[0][0] = 1;
	for(int i = 1;i<=20;i++)
	{
		f[i][0] = 9*(f[i-1][0] + f[i-1][1] + f[i-1][2]);
		f[i][1] = f[i-1][0];
		f[i][2] = f[i-1][1];
		f[i][3] = f[i-1][2] + f[i-1][3] * 10;
	}
	return;
}

int main()
{
	init();
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(m = 3;f[m][3] < n;m++);
		for(int i = m,k = 0;i>=1;i--)
		{
			for(int j = 0;j<=9;j++)
			{
				long long cnt = f[i-1][3];
				if(j == 6 || k == 3)
				{
					for(int l = max(3 - k - (j == 6),0);l<3;l++) cnt += f[i-1][l];
				}
				if(cnt < n) n -= cnt;
				else
				{
					if(k < 3)
					{
						if(j == 6) k++;
						else k = 0;
					}
					printf("%d",j);
					break;
				}
			}
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Expert_Dreamer (赞：1)

### 题意
求第 $x$ 个含有连续 $3$ 个 $6$ 的数。
### 题解

一眼数位 dp。

设 $f_{i,j}(j<3)$ 表示由 $i$ 个数字构成且开头有 $j$ 个 $6$ 的数的个数，$f_{i,3}$ 为 $i$ 位魔鬼数的个数，且可以有前导 $0$。

由于下一位能填除了 $6$ 的其他数，所以有转移方程：

$$
f_{i,0}=9\sum_{j=0}^{2}f_{i-1,j}
$$

但是如果有开头连续的 $6$，则只有一种填法：

$$
f_{i,1}=f_{i-1,0}\\

f_{i,2}=f_{i-1,1}
$$

如果想要填一位后就为魔鬼数，则可以由两个连续的转移，也可直接从小一位的魔鬼数转移：

$$
f_{i,3}=f_{i-1,2}+10\cdot f_{i-1,3}
$$

然后先通过 $f$ 确定第 $x$ 个魔鬼数的位数，一位一位试填，统计是否已为魔鬼数，得到后面有多少种方法使数为魔鬼数，再与 $x$ 比较，超过即填入，不足则把上一位加一。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
long long f[111][30];
int t,n,m,min_size;
void pre(){//预处理
	f[0][0]=1;
	for(int i=0;i<100;i++){
		for(int j=0;j<min_size;j++){
			f[i+1][j+1]+=f[i][j];
			f[i+1][0]+=f[i][j]*9;
		}
		f[i+1][min_size]+=f[i][min_size]*10;
	}
}
signed main(){
	cin>>t;min_size=3;
	pre();
	while(t--){
		cin>>n;
		for(m=min_size;f[m][min_size]<n;m++);
		for(int i=m,k=0;i;i--){
            //枚举第 i 位
			for(int j=0;j<=9;j++){
                //求出个数
				long long cnt=f[i-1][min_size];
				if(j==6||k==min_size){
					for(int l=max(min_size-k-(j==6),0ll);l<min_size;l++){
						cnt+=f[i-1][l];
					}
				}
                //判断应确定还是自增
				if(cnt<n) n-=cnt;
				else{
					if(k<min_size){
						if(j==6) k++;
						else k=0;
					}
					cout<<j;
					break;
				}
			}
		}
		cout<<endl;
	}
}
```

---

## 作者：Hootime (赞：1)

~~听一个[同机房的大佬](https://www.luogu.com.cn/user/1294410)说学了数位 DP 可以刷很多蓝题紫题于是试了一下结果逝了两个小时。。。~~

一道基础的数位 DP，做这道题前建议先做 [P2657 Windy 数](https://www.luogu.com.cn/problem/P2657)。

## 思路
由题意可看出，这道题是数位 DP 题目，先初始化再对具体问题求解。

### 初始化
题目提到“魔鬼数”需要包含 $3$ 个连续的 $6$，于是我们可以设 $dp_{i,j}$ 为 $i$ 位且末尾有 $j$ 个 $6$ 的数的个数。由此得到状态转移方程式：

$$
\begin{cases}
dp_{i,0}=9\times(dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2})\\
dp_{i,1}=dp_{i-1,0}\\
dp_{i,2}=dp_{i-1,1}
\end{cases}
$$

边界为 $dp_{1,0}=1,dp_{1,1}=0,dp_{1,2}=0$。

设 $num[i]$ 为 $i$ 位“魔鬼数”的个数，则可以得到：

$$
num_i=num_{i-1}\times10+dp_{i,2}
$$

代码实现如下：

```cpp
for(int i = 1; i < 21; i++){ // DP 预处理
    dp[i+1][0] = 9*(dp[i][0]+dp[i][1]+dp[i][2]);
    dp[i+1][1] = dp[i][0];
    dp[i+1][2] = dp[i][1];
    num[i+1] = num[i]*10 + dp[i][2];
}
```


注：**开 long long！！！**

### 查找
首先我们需要知道第 $x$ 小的魔鬼数有几位。这一点可以通过搜索 $num$ 数组实现。

然后就可以~~拼凑~~枚举填法了。具体枚举方法见代码：
```cpp
int m = 3, k = 0; // m 为位数，k 为已经填到的尾部的连续6的最大长度
// 若 k == 3 则已经成为魔鬼数
while(num[m] < n) ++m;
m--;
for(int i = m; i > 0; i--){ // 枚举位置 
    for(int j = 0; j <= 9; j++){ // 枚举位置上填的数
        long long cnt = num[i]; // 求出后面 i-1 位有多少种方法
        if(k == 3){ // 已经是魔鬼数 
            cnt += dp[i][0] + dp[i][1] + dp[i][2]; // 直接乱来 
        }
        else if(j == 6){ // 可能成为魔鬼数 
            for(int q = 3-(k+1); q < 3; q++) cnt += dp[i][q]; // 加上将会成为魔鬼数的情况
        }
        if(cnt < n){ // j 小于应有的 j 
            // 此时的 n 表示的是从现在的情况到结束的距离
            n -= cnt; 
        }
        else{ // j 等于应有的 j
            if(k < 3){ // 处理 k
                if(j == 6) k++;
                else k = 0;
            } 
            printf("%d", j); // 输出 j
            break; // 直接枚举下一位
        }
    }
}
printf("\n");
```

## 代码
本蒟蒻码风十分奇怪，还望原谅：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long dp[25][3] = {{0}, {1}}, num[25];
int t, n;
int main(){
    for(int i = 1; i < 21; i++){ // DP 预处理
        dp[i+1][0] = 9*(dp[i][0]+dp[i][1]+dp[i][2]);
        dp[i+1][1] = dp[i][0];
        dp[i+1][2] = dp[i][1];
        num[i+1] = num[i]*10 + dp[i][2];
    	//printf("%lld %lld %lld %lld\n", dp[i][0], dp[i][1], dp[i][2], num[i]);
    }
    scanf("%d", &t);
    while(t--){
        scanf("%d", &n);
        int m = 3, k = 0; // m为位数，k为已经填到的尾部的连续6的最大长度  
        while(num[m] < n) ++m;
        m--;
        for(int i = m; i > 0; i--){ // 枚举位置 
        	//printf("Run: %d;\n", i);
        	for(int j = 0; j <= 9; j++){ // 枚举位置上填的数，求出后面 i-1 位有多少种方法
        		long long cnt = num[i];
        		if(k == 3){ // 已经是魔鬼数 
        			cnt += dp[i][0] + dp[i][1] + dp[i][2]; //直接乱来 
				}
				else if(j == 6){ // 即将成为魔鬼数 
					for(int q = 3-(k+1); q < 3; q++) cnt += dp[i][q];
				}
				if(cnt < n){ // j 小于应有的 j 
					n -= cnt; 
				}
				else{
					if(k < 3){
						if(j == 6) k++;
						else k = 0;
					} 
					printf("%d", j);
					break;
				}
			}
		}
		printf("\n");
    }
}
```

---

## 作者：GY程袁浩 (赞：0)

（参考蓝书）。

首先依照 [P7690 [CEOI2002] A decorative fence](https://www.luogu.com.cn/problem/P7690) 的思路，我们通过试填法来确定这个数。为了快速得到方案数，我们考虑 DP。

设 $f_{i,j}$ 为当前数有 $i$ 位，$j=0$ 表示最后一位不是 $6$，$j=1$ 表示最后一位是 $6$，但前一位不是，$j=2$ 表示我们从当前位连通的 $6$ 有两个，$j=3$ 表示我们已经凑出了一个魔鬼数。$f_{i,j}$ 记录这些情况的方案数（可含前导零，方便计算）。

决策当前位上的数字，得到以下状态转移方程：

$$
\begin{aligned}
f_{i,0}&=(f_{i-1,0}+f_{i-1,1}+f_{i-1,2}) \times 9\\
f_{i,j(1\le j \le 2)}&=f_{i-1,j-1}\\
f_{i,3}&=f_{i-1,3} \times 10+f_{i-1,2}
\end{aligned}
$$

接下来，按照刚刚的描述，我们来讨论试填法的具体过程。

先确定位数 $len$。

对于每一位 $i$（从高位到低位，方便输出），枚举当前位的数 $p$：

1. $cnt$ 表示我们如果把这一位赋值为 $p$ 的魔鬼数方案数，首先先赋值 $cnt$ 为当前数后有魔鬼数后继的方案数 $f_{i-1,3}$。

2. 如果当前数为 $6$ 的后继，或者我们已经有了一个魔鬼数后缀，那么我们还要把 $cnt$ 加上可以接上当前前缀的方案数。

3. 如果 $cnt<n$，将 $n$ 减去 $cnt$，然后继续枚举当前位的取值。否则说明这一位就是 $p$，输出 $p$，然后更新连续 $6$ 的个数，跳转至下一位。

这样，我们就用试填法填出了这个数。

至此，我们解决了这个问题，这是试填法思想带给我们的力量。

```cpp
// Problem: P10958 启示录
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10958
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

//try fill
#include <bits/stdc++.h>
#define int __int128
#define upp(a, x, y) for (int a = x; a <= y; a++)
#define dww(a, x, y) for (int a = x; a >= y; a--)
#define pb(x) push_back(x)
#define endl '\n'
#define x first
#define y second
#define PII pair<int, int>
using namespace std;
signed n;
int f[30][4];
void prework() {
    f[0][0] = 1;
    upp(i, 1, 20) {
        f[i][0] = 9 * (f[i - 1][0] + f[i - 1][1] + f[i - 1][2]);
        f[i][1] = f[i - 1][0];
        f[i][2] = f[i - 1][1];
        f[i][3] = f[i - 1][3] * 10 + f[i - 1][2];
    }
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    signed tt;
    cin >> tt;
    prework();
    while (tt--) {
        cin >> n;
        int len = 3;
        while (f[len][3] < n) len++; // sure about the len
        // next try to fill the number
        int now = 0;
        dww(i, len, 1) { // reverse to solve
            upp(j, 0, 9) {
                int cnt = f[i - 1][3];
                if (now == 3 || j == 6) { // to know the in-law works
                    upp(k, max((int)0, 3 - now - (j == 6)), 2) cnt += f[i - 1][k];
                }
                if (cnt < n)
                    n -= cnt;
                else {
                    if (now < 3) {
                        if (j == 6)
                            now++;
                        else
                            now = 0;
                    }
                    cout << ((signed)j);
                    break;
                }
            }
        }
        cout << endl;
    }
    return 0;
}
```

---

## 作者：ny_jerry2 (赞：0)

## 算法
明显是一道数位 dp，我还用了二分。
## 思路
套用记忆化搜索版的数位 dp 模板：  
### 状态定义
设 $f_{pos,cnt,is,limit}$ 表示到了第 $pos$ 位，当前连续 $6$ 的个数为 $cnt$，$is $ 记录是否已经出现了连续 $3$ 个 $6$ （或大于 $3$ 个），$limit$ 即数位限制。

### 状态转移
若最大能枚举到 $ed$ （由数位限制决定），当前枚举到了 $i$，$lim$ 为下一位的限制，分两种情况：  
- $i \ne 6$
$$f_{pos,cnt,is,limit} = f_{pos,cnt,is,limit} + f_{pos-1,0,is,lim}$$

- $i = 6$

  设一个数为 $x$。  
  如果 $is = 1$ 或 $cnt+1 \ge 3$，则 $x=1$。

  $$f_{pos,cnt,is,limit} = f_{pos,cnt,is,limit} + f_{pos-1,cnt+1,x,lim}$$

因为它是要求第 $k$ 大的数，所以我们可以二分。如果当前满足条件的数的个数已经大于等于 $k$，说明我们要找的数在左半区间；否则在右半区间。

## 代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=20;
long long f[N][N][2][2];
int a[N],len;
long long dfs(int pos,int cnt,bool is,bool lim){
	if(pos<=0){
		return is;
	}
	long long &t=f[pos][cnt][is][lim];
	if(t!=-1){
		return t;
	}
	long long res=0;
	int ed=lim?a[pos]:9;
	for(int i=0;i<=ed;i++){
		int x=(i==6?cnt+1:0);
		res+=dfs(pos-1,x,is|(x>=3),lim&&i==ed);
	}
	return t=res;
}
long long solve(long long x){
	memset(f,-1,sizeof f);
	len=0;
	while(x){
		a[++len]=x%10;
		x/=10;
	}
	return dfs(len,0,0,1);
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int x;
		scanf("%d",&x);
		long long l=1,r=1e18;
		while(l<r){
			long long mid=(l+r)>>1;
			if(solve(mid)>=x){
				r=mid;
			}else{
				l=mid+1;
			}
		}
		cout<<l<<endl;
	}
}
```

---

## 作者：cly312 (赞：0)

状态表示：$f_{i,j}$ 表示由 $i$ 个数组成的数，左边有连续 $j$（$0\le j\le 3$）个 $6$。

边界：$f_{0,0}=1$

转移方程：

$f_{i,0}=9\times(\sum_{j=0}^2f_{i-1,j})$（可以在至多连续 $2$ 个 $6$ 前填 $0,1,\dots,5,7,\dots,9$）

$f_{i,1}=f_{i-1,0}$（从连续 $0$ 个 $6$ 前补一个 $6$）

$f_{i,2}=f_{i-1,1}$（从连续 $1$ 个 $6$ 前补一个 $6$）

$f_{i,3}=10\times f_{i-1,3}+f_{i-1,2}$（从连续 $3$ 个 $6$ 转移或从连续 $2$ 个 $6$ 前补一个$6$）

dp 完成后，我们先通过 $f_{i,3}$ 确定第 $x$ 小的魔鬼数的位数，然后按照“试填法”的思想，从左到右依次考虑每个数位，同时记录当前末尾已经有连续几个 $6$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll f[30][4];
int T,m,x;
int main() {
	scanf("%d",&T);
	f[0][0]=1;
	for(int i=1; i<=20; i++) {
		f[i][0]=((f[i-1][0]+f[i-1][1]+f[i-1][2])<<3)+f[i-1][0]+f[i-1][1]+f[i-1][2];
		f[i][1]=f[i-1][0];
		f[i][2]=f[i-1][1];
		f[i][3]=f[i-1][2]+(f[i-1][3]<<3)+(f[i-1][3]<<1);
	}
	while(T--) {
		scanf("%d",&x);
		for(m=3; f[m][3]<x; m++);
		for(int i=m,k=0; i>=1; i--) {
			for(int j=0; j<=9; j++) {
				ll cnt=f[i-1][3];
				if(j==6||k==3) for(int l=max(3-k-(j==6),0); l<3; l++) cnt+=f[i-1][l];
				if(cnt<x) x-=cnt;
				else {
					if(k<3) {
						if(j==6) k++;
						else k=0;
					}
					printf("%d",j);
					break;
				}
			}
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：junee (赞：0)

# P10958 题解

## 前置知识

数位 dp。

## 题目分析

很容易看出来是数位 dp。

先预处理一下，我们记 $f_{i,0/1/2/3}$ 为 $i$ 位数，前 $0/1/2/3$ 位都为 6 有多少种填法。

然后从高位往低位走，枚举每一位填什么数，假设我们现在枚举到了 $x$，把合法的个数找出来，如果大于 $n$ 就填这个数，然后减去 $0-x-1$ 的方案数。

# Code

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
const int N=20;
int T,n;
LL f[N][4];
void init(){
	f[0][3]=1;
	for(int i=1;i<=15;i++){
		f[i][0]=f[i-1][0]*9+f[i-1][1];
		f[i][1]=f[i-1][0]*9+f[i-1][2];
		f[i][2]=f[i-1][0]*9+f[i-1][3];
		f[i][3]=f[i-1][3]*10;
	}
}
void get(int n){
	int t=0,first=0;
	for(int i=14;i>=0;i--){
		LL cnt=0,cnt2=0;
		for(int j=0;j<=9;j++){
			if(t==3||j==6)cnt+=f[i][t+(t!=3)];
			else cnt+=f[i][0];
			if(cnt>=n){
				if(j)first=1;
				if(t<3&&j!=6)t=0;
				else if(t<3)t++;
				if(first)cout<<j;
				n-=cnt2;
				break;
			}
			cnt2=cnt;
		}
	}
	cout<<'\n';
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T;
	init();
	while(T--){
		cin>>n;
		get(n);
	}
	return 0;
}

```

---

## 作者：Acheron_RBM (赞：0)

一道非常板的数位 dp。

定义 $f_{i,j}$ 为当从高往低数到第 $i$ 位时，有连续 $j$ 个 $6$ 的后面随便选的方案总数。

我们可以很轻松的把 $f_{i,j}$ 预处理出来。

接下来我们可以求出第 $k$ 小的魔鬼数的位数 $m$，然后就是可以高位开始，确定每一位的值是多少了。

然后确定每一位的值就好了。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[100][100];
void init()
{
    dp[0][0]=1;
    for(int i=0;i<20;i++)
    {
        for(int j=0;j<3;j++)
        {
	        dp[i+1][j+1]+=dp[i][j];
	        dp[i+1][0]+=9*dp[i][j];
	    }
       	dp[i+1][3]+=dp[i][3]*10;
    }
}
int main()
{
    init();
	int t,n,m;
    cin>>t;
    while(t--)
    {
        cin>>n;
        for(m=3;dp[m][3]<n;m++)
        {
        	
		}
        for(int i=m,k=0;i;i--)
        {
            for(int j=0;j<=9;j++)
            {
                long long cnt=dp[i-1][3];
                if(j==6||k==3)
                {
                	for(int l=max(3-k-(j==6),0);l<3;l++)
					{
						cnt+=dp[i-1][l];
					}
				}
                if(cnt<n)
                {
                	n-=cnt;
				}
                else
                {
                    if(k<3)
                    {
                        if(j==6)
						{
							k++;
						}
                        else
                        {
                        	k=0;
						}
                    }
                    cout<<j;
                    break;
                }
            }
        }
        cout<<"\n";
    }
     return 0;
}
```

---


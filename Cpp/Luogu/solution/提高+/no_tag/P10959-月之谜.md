# 月之谜

## 题目描述

如果一个十进制数能够被它的各位数字之和整除，则称这个数为“月之数”。

给定整数 $L$ 和 $R$，你需要计算闭区间 $[L,R]$ 中有多少个“月之数”。

## 说明/提示

数据保证，$1 \le L,R < 2^{31}$，单个测试点内不超过 $3000$ 组数据。

## 样例 #1

### 输入

```
1 100 
```

### 输出

```
33```

# 题解

## 作者：Super_Cube (赞：5)

# Solution

数位 dp 板子。

设 $dp_{i,j,k,p}$ 表示正在填从高到低的第 $i$ 位，之前数位和为 $j$，固定模数为 $p$，模剩下的是 $k$。

那么枚举当前位要填的数字 $k$，继续往下递归求解就好了。边界情况为 $i=0$ 时若 $j=p$ 且 $k=0$ 时为 $1$，否则为 $0$。

在最外面枚举每次固定的模数，就做完了。

# Code
```cpp
#include<stdio.h>
#include<string.h>
int dp[11][91][91][91];
int a[11],len;
int dfs(int dep,int sum,int num,int mod,bool lim){
	if(!dep)return sum==mod&&!num;
	if(!lim&&~dp[dep][sum][num][mod])return dp[dep][sum][num][mod];
	int res=0;
	const int up=lim?a[dep]:9;
	for(int i=0;i<=up;++i)
		if(sum+i<=mod)res+=dfs(dep-1,sum+i,((num<<3)+(num<<1)+i)%mod,mod,lim&(i==a[dep]));
	if(!lim)dp[dep][sum][num][mod]=res;
	return res;
}
inline int solve(int n){
	len=0;
	for(int i=n;i;i/=10)a[++len]=i%10;
	int res=0;
	for(int i=9*len;i;--i)
		res+=dfs(len,0,0,i,1);
	return res;
}
int l,r;
int main(){
	memset(dp,-1,sizeof(dp));
	while(~scanf("%d%d",&l,&r))
		printf("%d\n",solve(r)-solve(l-1));
	return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

## 简要题意

[P4127 \[AHOI2009\] 同类分布](https://www.luogu.com.cn/problem/P4127) 加强版。

定义一个数是好的，当且仅当这个数是其每一位的数的和的倍数。

多组数据，每组数据给出一个区间 $[l,r]$，求区间内有多少个好的数。

**注：数据有误，当 $r<l$ 时，你应该输出区间 $[r,l]$ 的答案的相反数而不是 $0$。**


$1\leq l,r\leq 2^{31}-1$

## 思路

数位 dp 经典题。

首先我们将答案差分，拆成求前缀 $[0,p]$ 中有多少个好的数。

不妨枚举预期的每一位数的和 $S$，然后 dp，设 $f(p,S,n,s,0/1)$ 表示考虑到从高到低第 $p$ 位，现在的数字对 $S$ 取模后为 $n$，现在的各数位之和为 $s$，这一位填的数是否受到上界的限制。

直接转移，时间复杂度每组数据 $O(\log^4 n)$，还有一个大约 $1000$ 的常系数，大概是过不去的。

考虑到我们每组数据在 dp 时，其实很多时候都是重复的。不妨将每一次的上界都补成最大位数 $10$ 位，则当这一位填的数不受上界限制的时候，那么求出的 dp 值是可以复用的。

不妨先去掉上界的限制，dp 一遍，求出不受上界限制的 dp 值。然后对于每组数据，我们不清空 dp 数据，对于受到上界限制的直接跑，不受上界限制的读取记忆化的值。

由于受到上界限制的状态只有 $O(\log n)$ 的（带有一个大约 $100$ 的常系数）。所以我们可以在 $O(\log^4 n)$ 预处理，$O(\log n)$ 单组数据求解本问题。这样就可以通过本题了。

## 代码

```cpp
// Problem: P10959 月之谜【数据疑似有误】

#include <bits/stdc++.h>
#define int long long
using namespace std;

int f[11][85][85][85];
int a[11], tot;

int dp1(int p, int mod, int num, int sum){
    if(p > tot) return (sum == mod) && (num == 0);
    if(f[p][mod][num][sum] >= 0) return f[p][mod][num][sum];
    int ret = 0;
    for(int i=0;i<=9;i++){
        ret += dp1(p + 1, mod, (num * 10 + i) % mod, sum + i);
    }
    return f[p][mod][num][sum] = ret;
}

int dp2(int p, int mod, int num, int sum, int lim){
    if(p > tot) return (sum == mod) && (num == 0);
    if(!lim) return f[p][mod][num][sum];
    int ret = 0, bd = lim ? a[p] : 9;
    for(int i=0;i<=bd;i++){
        ret += dp2(p + 1, mod, (num * 10 + i) % mod, sum + i, lim && (i == bd));
    }
    return ret;
}

int solve(int x){
    fill(a + 1, a + tot + 1, 0);
    int tt = 0;
    while(x){
        a[++tt] = x % 10;
        x /= 10;
    }
    reverse(a + 1, a + tot + 1);
    int ans = 0;
    for(int i=1;i<=83;i++) ans += dp2(1, i, 0, 0, 1);
    return ans;
}


signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    tot = 10;
    memset(f, -1, sizeof(f));
    for(int i=1;i<=83;i++) dp1(1, i, 0, 0);
    int l, r;
    while(cin >> l >> r) cout << (solve(r) - solve(l - 1)) << '\n';
    // in fact, you need write like this, but the data of this problem is wrong now:
    // while(cin >> l >> r) cout << (l > r ? 0 : (solve(r) - solve(l - 1)) << '\n';
    return 0;
}

// Written by xiezheyuan

```

## 相似题目分享

- [CF855E Salazar Slytherin's Locket](https://www.luogu.com.cn/problem/CF855E) 和本题类似，每组数据都跑一遍完整的数位 dp 会超时。

---

## 作者：elonzhang (赞：1)

# [P10959 月之谜](https://www.luogu.com.cn/problem/P10959)

## 前置知识

[数位 dp ](https://oiwiki.com/dp/number/)或者[记忆化 dfs](https://oiwiki.com/dp/memo/)（不会的看 oiwiki 链接）。

## 思路

### 暴力深搜

考虑记忆化搜索 `dfs(int pos,int S,int cnt,bool f)`。第一个是位数，第二个是现在搜出来的数字是什么，第三位是数位和，第四位是是否可以任意选择。记忆化数组是 $vis_{pos,S,cnt}$ 只记录 $f=1$ 的情况。

### 正解
发现直接数位 dp 样例都过不去。所以我们可以考虑用取模来剪枝，只是会多跑几十次数位 dp 而已。具体来说就是枚举模数让 `S%=mod` 只要在递归结束时判断 $cnt=mod$ 与 $S=0$ 就可以了。

## ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;
#define freop(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define int long long
#define double long double
#define re register
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
#define lowbit(x) (x&-x)
#define pii pair<int,int>
#define fir first
#define sec second
#define umap unordered_map
#define uset unordered_set
const int N=20,M=100;
int a,b,tot,vis[N][M][M][M],num[N],mod;

inline int dfs(int pos,int S,int cnt,bool f){
	if(!pos) return !(cnt^mod)&&!S;
	if(vis[pos][S][cnt][mod]^(-1)&&f) return vis[pos][S][cnt][mod];
	int sum=0;
	int mx=(f?9:num[pos]);
	for(int i = 0;i<=mx;++i) sum+=dfs(pos-1,(S*10+i)%mod,cnt+i,f|(i<num[pos]));
	if(f) vis[pos][S][cnt][mod]=sum;
	return sum;
}
inline int js(int x){
	tot=0;
	while(x) num[++tot]=x%10,x/=10;
	int sum=0;
	for(mod=1;mod<=tot*9;++mod) sum+=dfs(tot,0,0,0);
	return sum;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//	freop();
//↑以上为初始化↑
//------------------------------
	memset(vis,-1,sizeof(vis));
	while(cin >> a >> b) cout << js(b)-js(a-1) << endl;
	return 0;
}
```

---

## 作者：mirance2025 (赞：1)

### 前置知识
前缀和、数位dp。
### Solution
题目意思很简单，就是让统计一下 $[l, r]$ 中能被各位数字之和整除的数（月之数）的个数。

因为数位dp可以统计出小于等于当前数 $n$ 的所有数 $(1 - n)$ 中的满足条件的数的个数，记为 $solve(n)$，所以可以利用数位dp+前缀和的思想，统计出 $solve(r)$ 和 $solve(l - 1)$，$[l, r]$ 中月之数的个数显然即为：$solve(r) − solve(l − 1)solve(r) − solve(l − 1)$。

在数位 dp 时，枚举每个数位，将其数位上的数字加起来以求出各位数字之和显然会超时，所以对于每个数的各位数字之和只要暴力枚举一下即可(因为其上限较小)，然后从高位到低位枚举时，依次保留一个当前数值除以各位数字之和的余数 $mod$，最后递归到最后一位时，判断一下余数是否为 $0$，即可得出当前数能否被其各位数字之和整除，也就是是不是月之数了。

注：用 $f_{pos, sum, mod}$ 表示当前位编号位 $pos$，各位数字之和位 $sum$ 且当前余数位 $mod$ 时，月之数的个数。

每次枚举当前假设的各位数字之和 $p$，在 dfs 之前，要将 $f$ 数组初始化为 $-1$。

### 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

#define int long long 

using namespace std;

const int maxn=100;//maxn为数据中各位数字之和的上限

int f[30][maxn][maxn],num[maxn],p;

int dfs(int pos,int sum,int mod,bool limit)//pos为当前数位，sum为当前真实数位之和(p为枚举的数位之和)，mod为当前余数，limit为上一位是否达到上限的标志
{
    if(!pos){//pos从最到位枚举到了最低位0
        if(sum==p&&!mod) return 1;//如果当前各位数字之和=本次枚举的各位数字之和且除到最后余数为0，则说明当前各位数字之和能整除当前数，则说明当前数为月之数，返回统计数量+1
        return 0;
    }
    if(!limit&&f[pos][sum][mod]!=-1) return f[pos][sum][mod];
    int res=0,up=limit?num[pos]:9;
    for(int i=0;i<=up;i++){
        res+=dfs(pos-1,sum+i,(mod*10+i)%p,limit&&i==up);
    }
    return limit?res:f[pos][sum][mod]=res;
}

int solve(int n)//计算1-n中满足条件的数(月之数)的个数
{
    int cnt=0;
    while(n){
        num[++cnt]=n%10;
        n/=10;
    }
    int res=0;
    for(p=1;p<maxn;p++){//枚举当前数位之和
        memset(f,-1,sizeof f);
        res+=dfs(cnt,0,0,1);
    }
    return res;
}

signed main()
{
    int l,r;
    cin>>l>>r;
    cout<<solve(r)-solve(l-1)<<endl;
    return 0;
}
```

---

## 作者：ZPB2011 (赞：0)

# [月之谜](https://www.luogu.com.cn/problem/P10959)

## 前言

[三倍经验](https://www.luogu.com.cn/discuss/918075)。

## 思路

较为板子。

dp 数组为 $f_{pos,sum,mod,k}$，$pos$ 是从高到低的第几位，$sum$ 是数位和，$mod$ 是模数，$k$ 是取模后剩下的数。

枚举当前要填进去的数，然后递归继续算。

计算答案是要枚举模数，求和即可。

## AC code

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
 
const int N = 20;

int num[N], f[N][105][105][105];

int dfs(int pos, int sum, int mod, int k, bool limit) {//递归
	if(!pos) return sum == 0 && mod == 0;
	if(!limit && f[pos][sum][mod][k] > -1) return f[pos][sum][mod][k];
	int maxn = 9;
	if(limit) maxn = num[pos];
	int ans = 0;
	for(int i = 0; i <= maxn; i++) {
		ans += dfs(pos - 1, sum - i, (mod * 10 + i) % k, k, limit && (i == maxn));
	}
	if(!limit) f[pos][sum][mod][k] = ans;
	return ans;
}

int calc(int x) {//计算答案
	int len = 0;
	while(x != 0) {
		num[++len] = x % 10;
		x /= 10;
	}
	int sum = 0;
	for(int i = 1; i <= 9 * len; i++) sum += dfs(len, i, 0, i, 1);
	return sum;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int a, b;
	memset(f, -1, sizeof(f));
	while(cin >> a >> b) {
		cout << calc(b) - calc(a - 1) << endl;
	}
	return 0;
}
```

---

## 作者：cly312 (赞：0)

**声明：思路来自《算法竞赛进阶指南》，代码为自己实现。**

求一个区间内满足某种限制条件的数有多少个，是一个经典的数位 dp 问题。

设 $f_{i,j,k,l}$ 表示由 $i$ 位数字构成、各位数字之和是 $j$、对 $k$ 取模余数是 $l$ 的数有多少个。

在计算 $f$ 时，允许前导 $0$ 的存在，枚举第 $i$ 位的数字 $p$，得到状态转移方程：
$$f_{i,j,k,l} = \sum_{p=0}^{9} f_{i-1,j-p,k,(l - p \cdot 10^{i-1})\mod k}$$

闭区间 $[L, R]$ 种月之数的个数，等于 $[1, R]$ 种月之数的个数减去 $[1, L-1]$ 种月之数的个数。接下来以 $[1,R]$ 进行说明。

采取 “试填法” 的思想，从高位到低位给每一位填数，只要填了一个比上限 $R$ 小的数位，那么后边的数位无论是多少，整个数值都不会超过 $R$，此时就可以立即把 dp 预处理出的结果累加到答案中。只有在每一位上始终填写与上限 $R$ 相同的数字时，才需要继续向后扫描，所以最终的计算量是数值的 “位数” 级别的，非常小。

我们枚举最终的各位数字之和 $sum$，然后从左到右扫描每个数位，设当前正在处理第 $i$ 位（最高位为第 $N$ 位，最低位为第 $1$ 位），当前已经填写的数字之和是 $t$，当前数值对 $sum$ 取模余数是$q$，我们从小到大枚举第 $i$ 位要填的数字 $p$。

若 $p$ 小于上限 $R$ 在第 $i$ 位上的数字，则后边 $i - 1$ 位可以随便填，因为最终的数值能被 $sum$ 整除，所以第 $1 \sim i$ 位构成的数值对 $sum$ 取模的余数应该是 $sum - q$，因此答案直接累加 $f_{i-1,sum-t-p,sum,(sum-q-p \cdot 10^{i-1}) \mod sum}$

否则，令 $t = t + p, q = q + p \cdot 10^{i-1} \mod sum$，开始处理第 $i-1$ 位 $[1, L-1]$ 同理。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE=1e5+10;
int L,R;
int dp[12][85][85][85],s[85][10]; 
int num[12];

int val(int pos,int sum,int mod,int x,bool flag) {
    if(x<sum) return 0;
    if(!flag) return dp[pos+1][x][x-sum][(x-mod)%x]; 
    if(pos==-1) return (mod==0&&sum==x);
    int res=0;
    for(int d=0; d<=num[pos]; d++) {
        bool e=(d==num[pos]);
        res+=val(pos-1,sum+d,(mod+(s[x][pos])*d)%x,x,e);
    }
    return res;
}

int Calc(int x) {
    int len=0,res=0;
    while(x) num[len++]=x%10,x/=10;
    for(int i=1; i<=81; i++) res+=val(len-1,0,0,i,true);
    return res;
}

void pre() {
    for(int i=1; i<=81; i++) {
        memset(dp[0][i],0,sizeof(dp[0][i]));
        dp[0][i][0][0]=1;
        s[i][0]=1%i;
        for(int j=1; j<=9; j++) s[i][j]=(s[i][j-1]*10)%i;
        for(int j=1; j<=9; j++)
            for(int k=0; k<=j*9; k++)
                for(int p=0; p<=i; p++)
                    for(int q=0; q<=9&&k>=q; q++) 
                        dp[j][i][k][p]+=dp[j-1][i][k-q][((p-s[i][j-1]*q)%i+i)%i];
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    pre();
    while(cin>>L>>R) cout<<Calc(R)-Calc(L-1)<<endl;
    return 0;
}

```

---


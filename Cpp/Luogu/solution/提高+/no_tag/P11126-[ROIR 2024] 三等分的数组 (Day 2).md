# [ROIR 2024] 三等分的数组 (Day 2)

## 题目背景

翻译自 [ROIR 2024 D2T3](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day2.pdf)。

在生日那天，玛莎像往常一样收到了一个由 $n$ 个数组成的数组 $a$，其中每个数字都在 $1$ 到 $m$ 之间。玛莎非常喜欢数字 $3$，因此数组的长度能被 $3$ 整除。

玛莎决定将这些数字分组为三元组：每个三元组要么由三个相同的数字组成，要么由三个连续的数字组成。换句话说，每个三元组的形式要么是 $(x, x, x)$，要么是 $(x, x + 1, x + 2)$，其中 $x$ 是一个正整数。

玛莎想要研究这个礼物中的数组，她想知道将数组中的数字分成这样的三元组的方式有多少种。如果不能为第一个分组中的每个三元组与第二个分组中的每个三元组建立一一对应关系，使得对应三元组中的数字相等，则两个分组方式被认为是不同的。由于分组方式可能非常多，玛莎只需知道其模 $10^9 + 7$ 的余数。

## 题目描述

帮助玛莎计算将数组中的数字分成三元组的方式的数量，对 $10^9 + 7$ 取模。

## 说明/提示

在第一个样例中，数字可以分成三元组的两种方式为 $\{(2, 2, 2), (3, 3, 3), (4, 4, 4)\}$ 和 $\{ (2, 3, 4), (2, 3, 4), (2, 3, 4)\}$。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $10$ | $m\le3$ |
| $2$ | $8$ | $m\le4$ |
| $3$ | $10$ | 每个数字最多出现两次 |
| $4$ | $12$ | $a$ 不含 $4$ 的倍数 |
| $5$ | $29$ | $n,m\le500$ |
| $6$ | $31$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 5000$，$1 \leq a_i \leq m \leq 5000$，$n$ 是 $3$ 的倍数。

## 样例 #1

### 输入

```
9 4
3 4 2 4 4 2 3 3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
6 3
1 2 3 1 2 1```

### 输出

```
0```

# 题解

## 作者：Linge_Zzzz (赞：6)

场切题，但是似乎还有一个 $\frac{1}{1400}$ 倍常数的 $O(n^3)$ 做法？

# Descr

题目写的够清楚了。

# Sol

考虑 DP。

首先把所有的 $a_i$ 放进桶里，记 $i$ 出现的次数为 $c_i$。

从小到大分为两种模式匹配，对于数 $i$，匹配 $\{i,i,i\}$ 或 $\{i-2,i-1,i\}$，并且一个数匹配过了就再也不管这个数了。

由此可以设计 naive 的状态 $f_{i,j,k}$ 表示当前匹配完了 $i$，$i$ 这个数还剩下 $j$ 个，$i-1$ 这个数还剩下 $k$ 个，$i-2$ 及以前的数没有剩余。

从 $f_{i,j,k}$ 转移到 $f_{i+1,j',k'}$ 时因为要保证前面没有剩下的数，所以要把 $k$ 个 $i-1$ 全部匹配完，再枚举第 $i+1$ 个数有 $t$ 次自己跟自己匹配，可以得到如下方程：

$$ f_{i,j,k}\rightarrow f_{i+1,c_{i+1}-3t-k,j-k} $$

观察到枚举 $t$ 的过程实际上是对 $f_{i+1,c{i+1}-k,j-k}$ 做一个前缀隔 $3$ 的加，所以可以优化转移为以下两个方程：

$$
\begin{aligned}
f_{i,j,k}&\rightarrow f_{i+1,c_{i+1}-k,j-k}\\
f_{i,j,k}&\rightarrow f_{i,j-3,k}
\end{aligned}
$$

滚掉 DP 数组第一维后，直接做这个 DP 并跑一些大的数据发现很快，考虑分析复杂度。

注意到对于 $f_{i,j,k}$，$j$ 的上界是 $c_{i}$，$k$ 的上界是 $c_{i-1}$，所以总状态数是 $\sum c_ic_{i-1}$ 的。

我们在小学二年级学过 $a^2+b^2\geq 2ab$ 和 $(a+b)^2\geq a^2+b^2$，于是有：

$$
\begin{aligned}
m^2&=(\sum c_i)^2\\
&\geq \sum c_i^2\\
&\geq \sum c_ic_{i-1}
\end{aligned}
$$

于是状态数是 $O(m^2)$ 的，又因为转移是均摊 $O(1)$ 的所以总复杂度是 $O(m^2)$ 的。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
const int N=5e3+10,INF=0x3f3f3f3f,mod=1e9+7;
int n,m,c[N];
int f[N][N],g[N][N];
void solve1(){
	g[0][0]=1;
	for(int i=0;i<m;i++){
		for(int j=0;j<=(i>0?c[i]:0);j++){
			for(int k=0;k<=min((i>1?c[i-1]:0),j);k++){
				if(!g[j][k])continue;
				f[c[i+1]-k][j-k]=(f[c[i+1]-k][j-k]+g[j][k])%mod;
			}
		}
		for(int j=c[i+1];j>=0;j--)
			for(int k=0;k<=c[i+1];k++)
				f[j][k]=(f[j][k]+f[j+3][k])%mod;
		for(int j=0;j<=c[i];j++)
			for(int k=0;k<=c[i];k++)
				g[j][k]=0;
		for(int j=0;j<=c[i+1];j++)
			for(int k=0;k<=c[i+1];k++)
				g[j][k]=f[j][k],f[j][k]=0;
	}
	cout<<g[0][0]<<endl;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int t;cin>>t;
		c[t]++;
	}
	solve1();
	return 0;
}

```

---

## 作者：Helloworldwuyuze (赞：5)

# P11126 题解

## Des

给定 $3n$ 个数 $a_i$，三个数可以匹配当且仅当 $x=y=z$ 或者 $x+1=y=z-1$。一组 $n$ 个匹配不同当且仅当它们不能够一一对应，求一共有多少种匹配的方法。

## Sol

### Part 1

先想暴力要怎么做。

直接枚举哪三个数配对肯定是不行的，第一直觉告诉我们要动态规划。而动态规划的对象显然不应该是原数组 $a_i$，而应该将这些数加入桶之后的数组 $t_i$。这是显然是因为数在原来数组中的位置并不重要，我们只关心每种数一共有多少个。

我们可以尝试记录这样一个状态：$f_{x,i,j,k}$ 表示当前枚举的数为 $x$，且 $x,x-1,x-2$ 的数量分别为 $i,j,k$ 时的方案数量。

然后考虑怎么转移。通过题目中给出的两种配对方法，我们也对应两种转移，即三个相同的数配对或者三个相邻的数配对。这时候我们枚举 $l$ 表示我们使用 $l$ 次相邻的配对，这个时候剩下的 $i-3l$ 个 $x$ 就必须都使用相邻配对。也就是需要和 $j,k$ 配对。于是不难写出转移方程：
$$
f_{x,i,j,k} = \sum_{\begin{matrix}l=0\\j,k\ge i-3l\end{matrix}}^{\left\lfloor \frac{i}{3} \right\rfloor} f_{x-1,j-(i-3l),k-(i-3l),t_{x-3}}
$$
这样我们的状态是 $O(\sum t_i^3)$，转移是 $O(m)$ 的，于是就有了 $O(m^4)$ 的多项式做法。

### Part2

重新回顾一下转移方程，我们在大量式子中发现了少量扎眼的东西：最后的 $f_{x-1,j-(i-3l),k-(i-3l),t_{x-3}}$ 中的 $t_{x-3}$ 和整个式子一点关系都没有。于是我们不妨去除最后一个状态：设 $f_{x,i,j}$ 表示到 $x$ 个数，其中 $x,x-1$ 分别有 $i,j$ 个数的答案是多少，于是又有了新的转移方程：
$$
f_{x,i,j} = \sum_{\begin{matrix} l=0\\t_{x-2},j\ge i-3l \end{matrix}}^{\left\lfloor \frac{i}{3} \right\rfloor} f_{x-1,j-(i-3l),t_{x-2}-(i-3l)}
$$
这样复杂度就成功优化到 $O(m\sum t_i^2)$。但是仍然不可接受。

考虑继续优化。状态已经不是很能优化了，但是转移不是还有一个 $O(m)$ 吗。

考虑对于相同的 $j$，从 $i\to i+3$ 整个值会发生什么变化。首先，对于 $l$ 的上界显然比原来多了 $1$，但也仅此而已，况且有下界 $t_{x-2},j\ge i-3l$ 的限制也不见得这个 $1$ 都能加得上。对于多的那个 $1$，也即 $l=0$ 的新的情况（这里新的情况是 $l=0$ 是因为原来的 $i$ 变为了 $i+3$ 而 $j$ 不变，因此 $j-(i-3l)$ 里原来的 $l=0$ 可以对应现在的 $l=1$，故只有 $l=0$ 是新的），于是在 $t_{x-2},j\ge i$ 的情况下让 $f_{x,i,j}\leftarrow f_{x,i-3,j}+f_{x-1,j-i,t_{x-2}-i}$ 即可。

于是，转移方程就是：
$$
f_{x,i,j} = \begin{cases} f_{x,i-3,j}+f_{x-1,j-i,t_{x-2}-i},&j,t_{x-2}\ge i\\f_{x,i-3,j},&j,t_{x-2}<i \end{cases}
$$
空间的那一维随便滚掉就好了。这样时间复杂度和空间复杂度都是 $O(\sum t_i^2)$。

### Part3

**Code**

```cpp
#define endl '\n'
using namespace std;
const int N = 5e3 + 10;
const int MOD = 1e9 + 7;

int f[N][N], sum[2][N][N];
int n, m, a[N], t[N];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n>>m; m+=2;
	for(int i=1;i<=n;++i)	cin>>a[i], a[i]+=2, t[a[i]]++;
	sum[0][0][0] = 1;
	for(int x=3;x<=m;++x){
		for(int i=0;i<=t[x];++i){
			for(int j=0;j<=t[x-1];++j){
				f[i][j] = 0;
				if(j-i>=0 && t[x-2]-i>=0)	f[i][j] = (f[i-3][j] + sum[!(x&1)][j-i][t[x-2]-i]) % MOD;
				else	f[i][j] = f[i-3][j];
				sum[x&1][i][j] = f[i][j];
			}
		}
	}
	cout<<f[t[m]][t[m-1]]<<endl;
	return 0;
}
```

---

## 作者：Kketchup (赞：0)

### [[ROIR 2024 Day 2] 三等分的数组](https://www.luogu.com.cn/problem/P11126)

- DP

**Sol:** 首先可以发现的是题目与 $a_i$ 的顺序无关，所以先把序列放在值域上考虑，设 $i$ 出现的次数为 $c_i$。我们先考虑朴素的 DP，设 $f_{x,i,j,k}$ 表示当前是 $x$，匹配后 $x,x-1,x-2$ 分别剩下 $i,j,k$ 个的方案，这样做复杂度 $O(m^4)$。观察发现 $k$ 是没有用的，因为转移计算方案时前面的所有数一定用完了，所以只能是从 $k=0$ 向后转移，所以我们可以去掉最后一维。

那么 $f_{x,i,j}$ 表示当前是 $x$，匹配后 $x,x-1$ 分别剩下 $i,j$ 个的方案，转移时枚举自己跟自己配对了多少次，设为 $l$，则 $\large f_{x,i,j}\rightarrow f_{x+1,c_{x+1}-3l-j,i-j}$。这时候复杂度是 $O(m^3)$，我们还需要优化。进一步考虑 $l$ 增加时转移的变化，$f_{x,i,j}$ 会贡献到 $f_{x+1,c_{x+1}-3-j,i-j},f_{x+1,c_{x+1}-6-j,i-j}\cdots$，发现实质是在 $i$ 这一维每隔 $3$ 贡献一次。所以转移可以优化成两部分。

$$f_{x,i,j}\rightarrow f_{x+1,c_{i+1}-j,i-j}$$

$$f_{x,i,j}\rightarrow f_{x,i-3,j}$$

第一维可以滚动数组优化空间，此时时空复杂度均为 $O(m^2)$，可以通过本题。

**Trick:** DP 时可以观察无用的状态进行优化；转移方程观察贡献次数来优化枚举。

---

## 作者：_Lazy_whr_ (赞：0)

考虑 DP 。

$dp_{i,j,k}$ 代表从 $1$ 到 $i$ 的数字划分为三元组的方式数量，记录 $cnt_i$ 代表 $i$ 的出现次数，那么对于由相同数字组成的三元组 $i$ ，很明显状态转移就是 $dp_{i,j,k} = dp_{i,j,k+3}$ ；对于连续数字组成的三元组，只考虑 $(x-1, x, x+1)$ 的情况，因为我们希望用尽所有剩余的 $i-1$ ，唯一的方法是将它们用于连续的三元组，状态转移就是 $dp_{i+1,k-j,cnt_{i+1}-j} = dp_{i,j,k}$ 。

**十年OI一场空，不会取模见祖宗！**

# Code:
```cpp
#include<bits/stdc++.h>
#define int long long
#pragma GCC target("avx")
#pragma GCC optimize(3,"Ofast","inline")
namespace FastIO
{
	inline int read()
	{
		int x = 0, f = 1;
		char ch = getchar();
		while(ch < '0' || ch > '9')
		{
			if(ch == '-')
			{
				f = -1;
			}
			ch = getchar();
		}
		while(ch >= '0' && ch <= '9')
		{
			x = (x << 1) + (x << 3) + (ch^48);
			ch = getchar();
		}
		return x * f;
	}
	template<typename T> inline void read(T &x)
	{
		x = read();
		return;
	}
	template<typename T,typename... Args> inline void read(T &x, Args &...x_)
	{
		read(x);
		read(x_...);
		return;
	}
}
namespace Constants
{
	const int INF = 1e18;
	const int DIR[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};
	const double EPS = 1e-6;
	const double PI = 3.14159265358979323;
}
using namespace std;
using namespace FastIO;
using namespace Constants;
inline void CLOSE()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	return;
}
const int N = 5010;
const int MOD = 1e9 + 7;
int a[N];
signed main()
{
	CLOSE();
	int n = read(), m = read();
	vector<int> cnt(m);
	for(int i = 1; i <= n; i++)
	{
		int x = read();
		cnt[x - 1]++;
	}
	for(int i = 0; i < m - 2; i++)
	{
        if(cnt[i] < 0)
        {
            cout << 0 << endl;
            return 0;
        }
        int tmp = cnt[i] % 3;
		for(int j = i; j < min(m, i + 3); j++)
		{
			cnt[j] -= tmp;
		}
	}
	if(cnt[m - 1] % 3 || (m >= 2 && cnt[m - 2] % 3))
	{
		cout << 0 << endl;
		return 0;
	}
	for(int i = 0; i < m; i++)
	{
		cnt[i] /= 3;
	}
	vector< vector< vector<int> > > dp(m);//这里由于开不下5000^3，但是状态总数不会超过5000^2，所以需要使用动态数组
	for(int i = 0; i < m; i++)
	{
		int pre = 1, cur = cnt[i] + 1;
		if(i != 0)
		{
			pre = cnt[i - 1] + 1;
		}
		dp[i].resize(pre);
		for(int j = 0; j < pre; j++)
		{
			dp[i][j].resize(cur);
		}
	}
	dp[0][0][cnt[0]] = 1;//初始状态
	for(int i = 0; i < m; i++)
	{
		int pre = 0;
		if(i != 0)
		{
			pre = cnt[i - 1];
		}
		for(int j = 0; j <= pre; j++)
		{
			for(int k = cnt[i]; k >= 1; k--)
			{
				dp[i][j][k - 1] = (dp[i][j][k - 1] + dp[i][j][k]) % MOD;//第一种转移
			}
			if(i < m - 1 && cnt[i + 1] >= j)
			{
				for(int k = cnt[i]; k >= j; k--)
				{
					dp[i + 1][k - j][cnt[i + 1] - j] = (dp[i + 1][k - j][cnt[i + 1] - j] + dp[i][j][k]) % MOD;//第二种转移
				}
			}
		}
	}
	cout << dp[m - 1][0][0] << endl;//答案
	return 0;
}
```

---


# [COTS 2021] 虫 Kukac

## 题目背景


译自 [Izborne Pripreme 2021 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2021/) D1T2。$\texttt{3s,0.5G}$。

众所周知，昆虫只对顺逆时针方向有感觉。

如果怀疑 SPJ 有误，请联系搬题人。[SPJ 代码](https://www.luogu.com.cn/paste/94gufjh7)。

## 题目描述


**这是一道交互题。**

二维平面上有一个 $N$ 个点的多边形 $P$。注意 $P$ **不一定**是凸的（它可以是凹包）。我们将多边形上的点**依次**编号为 $1\sim N$。

此外，还有一个额外的点 $0$。试通过交互来确定它是否在 $P$ 内部。

**保证多边形的线段不交。保证这 $(N+1)$ 个点两两不同。保证无三点共线。**

定义：$A,B,C$ **逆时针排列**当且仅当从 $A$ 看向 $B$ 时，$C$ 在直线 $AB$ 左侧。如左图。

![](https://cdn.luogu.com.cn/upload/image_hosting/g40wcp0e.png)

【实现细节】

交互开始前，需要读入一行两个整数 $N,Q$，表示多边形点数，和允许的最大询问数。

接下来，你的程序通过标准输入输出流与交互库交互。以下是允许的询问：

- $\texttt{? a b c}$：询问点 $a,b,c$ 是否逆时针排列。必须保证 $a,b,c$ 两两不同，且 $0\le a,b,c\le N$。

    如果 $a,b,c$ 逆时针排列，回答为 $1$；否则回答为 $0$。

确定答案后，按照以下格式回答：

- $\texttt{! x}$：如果 $x=1$，则代表 $0$ 号点在多边形内部；$x=0$ 代表 $0$ 号点不在多边形内部。

每次输出后，别忘了刷新缓冲区。如：`std::cout.flush()`。


## 说明/提示


#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/4en0fhqq.png)

#### 数据范围

对于 $100\%$ 的数据，保证 $3\le N\le 500$。

再次提醒，**多边形不一定是凸的**。保证多边形的线段不交。保证这 $(N+1)$ 个点两两不同。保证无三点共线。


| 子任务编号 | $N\le $ | $Q=$   |  特殊性质   | 得分 |  
| :--: | :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 50 $    | $ N^3 $   | 有  | $ 5 $   |  
| $ 2 $    | $ 50 $    | $ N^3 $   | 无 | $ 25 $   |  
| $ 3 $    | $ 500 $    | $ N^2 $  | 无  | $ 15 $   |  
| $ 4 $    | $ 500 $    | $ 4N $  | 无 | $ 25 $   |  
| $ 5 $    | $ 500 $    | $ 2N $  | 无   | $ 30 $   |

特殊性质：$P$ 是凸的。

## 样例 #1

### 输入

```
5 125

1

1

0

0```

### 输出

```

? 1 2 3

? 0 4 1

? 2 5 4

? 0 1 5

! 0```

# 题解

## 作者：Twlight！ (赞：2)

逛题目列表时发现的题目，分享后被 @H3PO4 秒了，特此膜拜（%%%）。

## 题目大意
平面上有一个 $N$ 个点的简单多边形（点按顺序给出，令其为 $P_i$），和一个点 $O$，每次可以询问图中任意三个点是否是逆时针排列，判断点 $O$ 是否在这个多边形内部。保证点两两不同、无三点共线、且多边形线段不相交。

三个点 $A, B, C$ 逆时针排列的定义为：站在点 $A$ 看向点 $B$ 时，点 $C$ 在直线 $AB$ 的左侧，如题图，左侧 $A，B，C$ 成逆时针排列。

![](https://cdn.luogu.com.cn/upload/image_hosting/g40wcp0e.png)

## 前置知识：射线法
简单地说，判断一点是否在多边形内，可以从该点向任意方向引出一条射线，若射线与多边形有奇数个交点，那么该点在多边形内，否则在多边形外，如图：

[![图1](https://i.postimg.cc/dDPSgBvm/image.png)](https://postimg.cc/n92kDqXC) 
[![图2](https://i.postimg.cc/zGj8SLSP/image.png)](https://postimg.cc/3kds3xqg)

图1中点 $O$ 引出的射线与多边形有 $2$ 个交点，而图2中有 $1$ 个交点，故图1中 $O$ 点在多边形外部，图二中 $O$ 则在多边形内部。

### 简易证明：
首先得知道，一个多边形只会把平面分成两部分，一部分是在多边形内的，另一部分是在多边形外的，因此一个点只有在内、在外两种状态（这里不讨论在多边形上的情况）。

从一点出发沿着射线方向走，每穿过一次多边形，都会改变自己的状态（也就是从内部到外部，或从外部到内部），而沿着射线方向走总会走到多边形外部，因此只需要知道穿过次数的奇偶性，就可以逆推回去。

但是这样说是有缺陷的，如图：

[![image.png](https://i.postimg.cc/vBXVJHsP/image.png)](https://postimg.cc/cggCYW6Y)

当点 $C$ 在射线上时，它不应该算作穿过了一次多边形，因为经过它**没有改变**点的状态。因此，有些时候我们并不能仅判断交点数量，而是要判断改变状态的次数（也就是穿过多边形的次数）。

如此地，我们就可以证明上述方法的正确性。

## 回到本题
知道了上述结论，我们就需要从点 $O$ 引出一条射线，判断交点的数量。因为不能加点，不妨以点 $P_1$ 为方向，先引出射线 $OP_1$。

那么就来到了第二个问题，如何判断一条线段是否与射线相交呢？

图中的点是顺序给出的，因此我们可以知道如果一条线段与射线相交，它们两端的端点一定在异侧（因为题目无三点共线）。这样我们就可以询问 $N - 1$ 次，判断每个点与直线 $OP_1$ 的关系（在上边/下边），如图：

[![image.png](https://i.postimg.cc/fb7Cb9X5/image.png)](https://postimg.cc/94MZ8zLq)

然后就可以得出每个线段与直线 $OP_1$ 是否相交。

但是这样会产生两个问题，首先便是我们判断的是线段与**直线**的关系，而我们用的是**射线法**。其次，这样也并不能直接根据相交线段的数量而判断，而是要看**判断改变状态的次数**，这在上方证明时就已提过。

但是，第二个问题是好解决的，如果射线途中不经过多边形的任何端点，那么答案就等于与射线相交的线段数量。而题目保证了无三点共线，因此我们考虑换一下，以 $O$ 为起点，$P_1O$ 方向为射线方向，如图：

[![image.png](https://i.postimg.cc/nrBk5SZF/image.png)](https://postimg.cc/tnRWn5Yw)

为了方便，设此时射线为 $OQ$，则 $OQ$ 只会与某些线段相交，而不会经过顶点。

我们钦定 $P_1O$ 方向为左方向，此时点 $O$ 一定在直线 $P_1P_2$ 或者 $P_1P_n$ 的左边（询问要按从下往上的顺序，类似坐标系一样，这样才能保证统一性），不妨选直线 $P_1P_2$ 作为判断基准。

因为你不知道这个左方向到底是什么，所以你需要询问直线 $P_1P_2$ 与 $O$ 的关系，钦定这个返回值为左。往后统计答案时，判断询问 $P_iP_{i+1}$ 与 $O$ 的返回值是否与先前规定的左方向的返回值相同即可，这样共询问 $N - 1$ 次，总询问次数为 $2N - 2$ 次，符合题目条件。

至此我们就解决了这个问题的 $90\%$，剩余的便是小细节：前文提到，查询时是有方向的，确定一个点与直线的方向时要统一询问时的直线方向，具体细节可见代码。

## 参考代码
```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 500 + 10;
using namespace std;

int read () {
	int x = 0, k = 1; char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') k = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return (1ll * x * k);
}

int n, q;
int dire[N], lft, cnt;

int query (int A1, int A2, int p) { 
	return printf("? %d %d %d\n", A1, A2, p), cout.flush(), read(); 
}

signed main() {
	n = read(), q = read();

	// 询问每个点与直线 OP1 的关系（上下） 
	for (int i = 2; i <= n; ++i) dire[i] = query(0, 1, i);

	// 钦定 P1P2 与 O 询问的返回值为左方向，注意要从下往上 
	lft = dire[2] ? query(1, 2, 0) : query(2, 1, 0);

	for (int i = 3; i <= n; ++i)
		if (dire[i] != dire[i - 1]) // 判断是否与直线相交 
			if ((dire[i] ? query(i, i - 1, 0) : query(i - 1, i, 0)) == lft) // 判断是否与射线相交 
				++cnt;

	printf("! %d\n", cnt & 1);

	return 0;
}
```

时间复杂度：$O(N)$。

## 参考文献
1. [判断一点是否在任意多边形内部](http://oi-wiki.com/geometry/2d/#判断一点是否在任意多边形内部)
2. [判断点是否在多边形内（射线法）](https://zhuanlan.zhihu.com/p/701467904)
3. [@H3PO4](https://www.luogu.com.cn/user/178437) 的神秘口糊（%%%）

---

## 作者：H3PO4 (赞：2)

判断点 $O$ 是否在简单多边形（不自交）$P$ 内部可以使用[光线投射算法](https://oi.wiki/geometry/2d/#%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84%E7%AE%97%E6%B3%95-ray-casting-algorithm)。

其思路是，从 $O$ 点任意引出一条射线，统计它与多边形 $P$ 的交点个数，若是奇数则 $O$ 在 $P$ 内部，否则在外部。

![](https://cdn.luogu.com.cn/upload/image_hosting/0d6nnsjv.png)

证明：简单多边形会把平面分成内部和外部两部分，$OA$ 与 $P$ 的交点又把 $OA$ 分成了若干段，这些段一定是交替位于多边形的内外部分的。因为射线无线延长，而多边形是闭合曲线，所以最后一段一定在外部。于是交点数为 $0$ 则 $O$ 在外部，交点数为 $1$ 则 $O$ 在内部，交点数为 $2$ 则 $O$ 在外部……数学归纳即可得出结论。

回到此题，利用交互库提供的操作可以判断点在直线的哪一侧。发现直线与线段相交当且仅当线段两端点在直线的不同侧。

![](https://cdn.luogu.com.cn/upload/image_hosting/jkfzhcbq.png)

为判断射线与线段是否相交，可以再判断射线端点在线段的哪一侧。注意，这一步中要固定线段的方向（从射线的固定一侧到另一侧）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ll0oxlhr.png)

还剩下一个问题：如何构造射线？容易想到直接构造从点 $0$ 指向点 $1$ 的射线，但这会导致射线经过多边形上的点 $1$，对于边 $1,2$ 和 $n,1$ 是否算作与射线相交需要分类讨论。

更简便的方法是，构造从点 $0$ 开始、沿着从点 $1$ 到点 $0$ 的方向延长的射线，即与从点 $0$ 指向点 $1$ 的射线方向相反。由于题目保证所有点两两不同且无三点共线，这条射线不会经过多边形上的任意一点。

计算一下询问次数：先用 $n-1$ 次询问得到点 $2$ 到点 $n$ 与射线的关系，对于相交的那些边再判断射线端点与线段的关系。于是在 $2n$ 次询问内解决了问题。

代码非常好写。

```cpp
#include<bits/stdc++.h>
int pos[510],cnt[2];
int qr(int a,int b,int c){
    std::cout<<"? "<<a<<" "<<b<<" "<<c<<"\n"<<std::flush;
    int w;std::cin>>w;return w;
}
int main(){
    int n,q;std::cin>>n>>q;
    for(int i=2;i<=n;i++)pos[i]=qr(1,0,i); // 点 i 在射线 1,0 的哪一侧
    for(int i=3;i<=n;i++)
        if(pos[i]!=pos[i-1])
            cnt[pos[i]?qr(i,i-1,0):qr(i-1,i,0)]++;
            // 上面这一行：固定线段方向为从射线左侧指向右侧，
            // 判断点 0 在线段的哪一侧，统计交点个数。
    int w=cnt[!(pos[2]?qr(2,1,0):qr(1,2,0))]; // 射线沿着从点 1 到点 0 的方向延长
    std::cout<<"! "<<w%2<<'\n';
    return 0;
}
```

## Bonus

以下这份代码为什么是对的？
```c
#include<stdio.h>
a,k,n,o,i;q(x){return printf("?%d %d 0\n",x,i+1),fflush(stdout),scanf("%d",&x),x;}
main(){for(scanf("%d%d",&n);++i<n;k=a)a=q(1),o^=i>1&a^k&&a^q(i);printf("!%d",o);}
```

---


# [CSP-J 2024] 接龙

## 题目描述

在玩惯了成语接龙之后，小 J 和他的朋友们发明了一个新的接龙规则。

总共有 $n$ 个人参与这个接龙游戏，第 $i$ 个人会获得一个整数序列 $S_i$ 作为他的词库。

一次游戏分为若干轮，每一轮规则如下：

- $n$ 个人中的某个人 $p$ 带着他的词库 $S_p$ 进行接龙。若这不是游戏的第一轮，那么这一轮进行接龙的人不能与上一轮相同，但可以与上上轮或更往前的轮相同。
- 接龙的人选择一个长度在 $[2, k]$ 的 $S_p$ 的连续子序列 $A$ 作为这一轮的**接龙序列**，其中 $k$ 是给定的常数。若这是游戏的第一轮，那么 $A$ 需要以元素 $1$ 开头，否则 $A$ 需要以上一轮的接龙序列的最后一个元素开头。
  - 序列 $A$ 是序列 $S$ 的连续子序列当且仅当可以通过删除 $S$ 的开头和结尾的若干元素（可以不删除）得到 $A$。

为了强调合作，小 J 给了 $n$ 个参与游戏的人 $q$ 个任务，第 $j$ 个任务需要这 $n$ 个人进行一次游戏，在这次游戏里进行恰好 $r_j$ 轮接龙，且最后一轮的接龙序列的最后一个元素恰好为 $c_j$。为了保证任务的可行性，小 J 请来你判断这 $q$ 个任务是否可以完成的，即是否存在一个可能的游戏过程满足任务条件。

## 说明/提示

**【样例 1 解释】**

在下文中，我们使用 $\{A_i\} = \{A_1, A_2, \dots , A_r\}$ 表示一轮游戏中所有的接龙序列，$\{p_i\} = \{p_1, p_2, \dots , p_r\}$ 表示对应的接龙的人的编号。由于所有字符均为一位数字，为了方便我们直接使用数字字符串表示序列。

- 对于第一组询问，$p_1 = 1$、$A_1 = 12$ 是一个满足条件的游戏过程。
- 对于第二组询问，可以证明任务不可完成。注意 $p_1 = 1$、$A_1 = 1234$ 不是合法的游戏过程，因为此时 $|A_1| = 4 > k$。
- 对于第三组询问，$\{p_i\} = \{2, 1\}$、$\{A_i\} = \{12, 234\}$ 是一个满足条件的游戏过程。
- 对于第四组询问，可以证明任务不可完成。注意 $\{p_i\} = \{2, 1, 1\}、\{A_i\} = \{12, 23, 34\}$ 不是一个合法的游戏过程，因为尽管所有的接龙序列长度均不超过 $k$，但第二轮和第三轮由同一个人接龙，不符合要求。
- 对于第五组询问，$\{p_i\} = \{1, 2, 3, 1, 2, 3\}$、$\{A_i\} = \{12, 25, 51, 12, 25, 516\}$ 是一个满足条件的游戏过程。
-  对于第六组询问，可以证明任务不可完成。注意每个接龙序列的长度必须大于等于 $2$，因此 $A_1 = 1$ 不是一个合法的游戏过程。
- 对于第七组询问，所有人的词库均不存在字符 $\tt 7$，因此任务显然不可完成。

**【样例 2】**

见选手目录下的 chain/chain2.in 与 chain/chain2.ans。

该样例满足测试点 1 的特殊性质。

**【样例 3】**

见选手目录下的 chain/chain3.in 与 chain/chain3.ans。

该样例满足测试点 2 的特殊性质。

**【样例 4】**

见选手目录下的 chain/chain4.in 与 chain/chain4.ans。

该样例满足特殊性质 A，其中前两组测试数据满足 $n \leq 1000$、$r \leq 10$、单组测试数据内所有词库的长度和 $\leq 2000$、$q \leq 1000$。

**【样例 5】**

见选手目录下的 chain/chain5.in 与 chain/chain5.ans。

该样例满足特殊性质 B，其中前两组测试数据满足 $n \leq 1000$、$r \leq 10$、单组测试数据内所有词库的长度和 $\leq 2000$、$q \leq 1000$。

**【样例 6】**

见选手目录下的 chain/chain6.in 与 chain/chain6.ans。

该样例满足特殊性质 C，其中前两组测试数据满足 $n \leq 1000$、$r \leq 10$、单组测试数据内所有词库的长度和 $\leq 2000$、$q \leq 1000$。

**【数据范围】**

对于所有测试数据，保证：
- $1 \leq T \leq 5$；
- $1 \leq n \leq 10^5$，$2 \leq k \leq 2 \times 10^5$，$1 \leq q \leq 10^5$；
- $1 \leq l_i \leq 2 \times 10^5$，$1 \leq S_{i,j} \leq 2 \times 10^5$；
- $1 \leq r_j \leq 10^2$，$1 \leq c_j \leq 2 \times 10^5$；
- 设 $\sum l$ 为**单组测试数据内**所有 $l_i$ 的和，则 $\sum l\leq 2\times 10^5$。

::cute-table{tuack}

| 测试点 | $n\leq$ | $r\leq$ | $\sum l\leq$ | $q\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^3$ | $1$ | $2000$ | $10^3$ | 无 |
| $2,3$ | $10$ | $5$ | $20$ | $10^2$ | ^ |
| $4,5$ | $10^3$ | $10$ | $2000$ | $10^3$ | A |
| $6$ | $10^5$ | $10^2$ | $2\times 10^5$ | $10^5$ | ^ |
| $7,8$ | $10^3$ | $10$ | $2000$ | $10^3$ | B |
| $9,10$ | $10^5$ | $10^2$ | $2\times 10^5$ | $10^5$ | ^ |
| $11,12$ | $10^3$ | $10$ | $2000$ | $10^3$ | C |
| $13,14$ | $10^5$ | $10^2$ | $2\times 10^5$ | $10^5$ | ^ |
| $15\sim 17$ | $10^3$ | $10$ | $2000$ | $10^3$ | 无 |
| $18\sim 20$ | $10^5$ | $10^2$ | $2\times 10^5$ | $10^5$ | ^ |

特殊性质 A：保证 $k = 2 \times 10^5$。

特殊性质 B：保证 $k ≤ 5$。

特殊性质 C：保证在单组测试数据中，任意一个字符在词库中出现次数之和均不超过 $5$。

## 样例 #1

### 输入

```
1
3 3 7
5 1 2 3 4 1
3 1 2 5
3 5 1 6
1 2
1 4
2 4
3 4
6 6
1 1
7 7```

### 输出

```
1
0
1
0
1
0
0```

# 题解

## 作者：Register_int (赞：98)

容易发现是图论题，建模就是每个位置往他能接的位置连边，于是不妨先考虑给定一个一般的有向图怎么做。简单的想法是预处理出所有答案，你可以用一个类似广搜的东西，从 $1$ 开始每次向外拓展一层，记录可达性即可，复杂度是 $O(nr)$ 的。

但是这题的图边数特别多，那我们干脆不建边了，直接去判断每个点能否被当前的点到达。每次记录的就是当前接龙的最后一个数。

题目有个很烦的限制，一个人不能接两次。但是可以发现，如果当前这一层的某个数 $x$ 同时在至少两个人的序列里，那么所有人的数 $x$ 都能接到下一个了。所以只要考虑只有一个人有 $x$ 的情况。开个数组记录这一层的每个数在谁手上，没有为 $-1$，有一个人 $i$ 有就设为 $i$，两个人及以上有设为 $0$。这样处理后就可以快速找出可以接到哪些位置上了。

然后再通过这些新接的头找出所有能接的尾巴。先对所有头打标记，然后遍历每一个位置，如果他距离上一个标记（不含自己）的距离 $\le k$ 就加入下一层的队列。重复做这个就好了，单组数据复杂度 $O(nr+q)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;
const int MAXM = 1e2 + 10;

inline 
void read(int &x) {
	x = 0; char c = getchar();
	for (; isspace(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
}

int T, n, m, q; int cnt[MAXN]; bool ans[MAXM][MAXN];

int a[MAXN]; bool vis[MAXN]; int pos[MAXN];

inline 
void init() {
	vector<pair<int, int>> f, g;
	for (int i = 1; i <= n; i++) {
		for (int j = pos[i], p = -1e9; j < pos[i + 1]; j++) {
			if (j - p < m) f.emplace_back(i, j), ans[1][a[j]] = 1;
			if (a[j] == 1) p = j;
		}
	}
	for (int t = 2; t <= 100; t++) {
		memset(cnt, 0xff, sizeof cnt);
		for (pair<int, int> x : f) {
			int y = a[x.second];
			if (cnt[y] == -1) cnt[y] = x.first;
			else if (cnt[y] != x.first) cnt[y] = 0;
		}
		for (int i = 1; i <= n; i++) {
			for (int j = pos[i]; j < pos[i + 1]; j++) {
				if (~cnt[a[j]] && cnt[a[j]] != i) g.emplace_back(i, j);
			}
		}
		f.clear();
		for (pair<int, int> x : g) vis[x.second] = 1;
		for (int i = 1; i <= n; i++) {
			for (int j = pos[i], p = -1e9; j < pos[i + 1]; j++) {
				if (j - p < m) f.emplace_back(i, j), ans[t][a[j]] = 1;
				if (vis[j]) p = j;
			}
		}
		for (pair<int, int> x : g) vis[x.second] = 0;
		g.clear();
	}
}

int main() {
	freopen("chain.in", "r", stdin);
	freopen("chain.out", "w", stdout);
	for (read(T); T--; ) {
		read(n), read(m), read(q);
		memset(ans, 0, sizeof ans);
		memset(vis, 0, sizeof vis);
		for (int i = 1, k; i <= n; i++) {
			read(k), pos[i + 1] = pos[i] + k;
			for (int j = pos[i]; j < pos[i + 1]; j++) read(a[j]);
		}
//		clock_t st = clock();
		init();
//		fprintf(stderr, "init time: %.3lfs\n", (double)(clock() - st) / CLOCKS_PER_SEC);
		for (int r, c; q--; read(r), read(c), printf("%d\n", ans[r][c]));
	}
}

```

---

## 作者：4041nofoundGeoge (赞：85)

特别难的题！

## 思路

我们把所有人的序列依次排列成的一个序列设为 $a$，设第 $i$ 个人的序列对应长序列中的 $L_i\sim R_i$ 这一段。

当我们看到 $r_j\le100$，可以用动态规划，设 $f_{i,t}$ 表示当前为第 $i$ 轮，结束位置是 $t$ 的方案数答案就是 $F(f_{r_j,c_j})$，其中当 $f_{r_j,c_j}>0$ 函数返回 $1$，反之返回 $0$。然而转移需要枚举上一轮的结束点，再检查是否有合法的起始点，这样复杂度至少也要 $O(m^2r)$，其中 $m=\sum l_i$。

我们可以把一轮接龙的过程分成两步：先选择一个和上一次接龙未尾数字相同的起始点，在选择一个满足是同一个人，且位置相差在 $2\sim k$ 之间的结束点。

这样，我们发现，第一步只和每个位置上的数字有关，而第二步只和位置有关。因此我们可以把转移分成两步，先根据上一轮的 $f$，计算出合法的起始点，再根据起始点，转移到结束点。

我们再设 $g_{i,s}$ 表示第 $i$ 轮，结束的位置数字为 $s$ 的方案数。则我们可以在求完 $f_{i-1}$ 后直接计算出函数 $g$。

现在我们想如何利用 $g_{i-1}$，计算出 $f_i$。如果没有两轮接龙不能使用同一个人的序列，则我们发现，

$$
f_{i,t}=\sum_{l_t\le j\le t-1}g_{i-1,a_j}
$$

其中 $l_t$ 是 $t-k+1$ 和 $t$ 对应的小序列的第一项较大值，因为 $l_t$ 是单调的，所以利用一个指针，同时记录区间和就可以快速求出 $f_{i,t}$。

但是题目要求两轮接龙不能使用同一个人的序列，而 $g$ 并没有考虑结束的位置属于哪一个人的序列，因此我们需要把两轮接龙相同的人的方案数减掉。考虑这个限制后，新的转移方程为：

$$
f_{i,t}=\sum_{l_t\le j\le t-1}(g_{i-1,a_j}-\sum_{L_{B_t}\le b\le R_{B_t},a_b=a_j}f_{i-1,b})
$$

其中 $B_t$ 表示 $t$ 属于哪一个人的序列，而 $\sum_{L_{B_t}\le b\le R_{B_t},a_b=a_j}f_{i-1,b}$ 可以求出在 $f_{i-1}$ 后的东西。通过维护数组 $pre_i$ 表示上一个 $a_j=a_i$ 的位置 $j$ 快速计算求出。

综上我们可以在 $O(mr)$ 的时间复杂度通过此题，但**此题要开 long long**。

## 代码

```cpp
#include <bits/stdc++.h>
#define N 200100
#define M 110
using namespace std;

int T, n, K, Q, ok[M][N];
vector<int> num[N];

int main()
{
    cin >> T;
    while (T--)
    {
        memset(ok, -1, sizeof(ok));
        scanf("%d%d%d", &n, &K, &Q);
        for (int i = 1; i <= n; i++)
        {
            num[i].clear();
            int len;
            scanf("%d", &len);
            for (int j = 1; j <= len; j++)
            {
                int t;
                scanf("%d", &t);
                num[i].push_back(t);
            }
        }

        ok[0][1] = 0;
        for (int T = 1; T <= 100; T++)
        {
            for (int i = 1; i <= n; i++)
            {
                int len = 0;
                for (auto t : num[i])
                {
                    len = max(len - 1, 0);
                    if (len)
                    {
                        if (ok[T][t] == -1)
                            ok[T][t] = i;
                        else if (ok[T][t] && ok[T][t] != i)
                            ok[T][t] = 0;
                    }
                    if (ok[T - 1][t] != -1 && ok[T - 1][t] != i)
                        len = K;
                }
            }
        }
        while (Q--)
        {
            int p, q;
            scanf("%d%d", &p, &q);
            puts(ok[p][q] != -1 ? "1" : "0");
        }
    }
}//update:2024.10.29
```

---

## 作者：ylch (赞：76)

## Analysis

这道题光读题很困难，重点是我们要找到题目的规律和性质：

我们要找是否存在 $r$ 个头尾相接、长度为 $2 \sim k$ 的序列（第一个序列一定以 $1$ 开头）。

因为这是第四题，加上是序列类的问题，首先考虑 dp。题目有三个关键条件：轮数、结尾数字、上一轮选择的行。

从数据范围入手，这道题的数据范围很大，$q \le 10^5$，说明要 $O(1)$ 回答询问，不难想到要用 dp 预处理。

又因为 $r \le 100$，$S_{i,j} \le 2 \times 10^5$，两者相乘刚好是 $2 \times 10^7$，在 $1s$ 时限内。所以考虑用这两个维度设状态，另一个维度存数据，这样也方便转移。


---


下面是重点！

设 $dp[r][j]$ 记录在第 $r$ 轮能否以数字 $j$ 作为结尾。我们设 $dp[r][j]$ 的取值有以下三种情况：

- $-1$：不能接龙。

- $0$：可以从任意行接龙。

- $i$：上一轮由第 $i$ 个人接龙。

要判断 $dp[r][j]$ 是否能接龙，就要看在 $dp[r-1]$ 中 $j$ 是否在长为 $2 \sim k$ 的子序列中出现过，且可以进行接龙。

具体来说：

1. 枚举所有人的所有数字 $u$。因为题目中说 $\sum l \le 2 \times 10^5$，所以此处不超时。
2. 看 $u$ 前面的 $k$ 个数字中，是否有作为上一轮结尾的。
3. 若 $u$ 可以被接上，则 $u$ 之后的 $k-1$ 个数字都可以作为第 $r$ 轮的结尾。同时标记 dp 数组。

这样就可以做到 $O(r \times n + \sum l)$ 的预处理，$O(1)$ 询问。

几个注意事项：
1. $n \le 10^5$，$l \le 2 \times 10^5$，所以直接开二维数组不行。要用 vector。
2. 在上面的步骤三中，“$u$ 之后的 $k-1$ 个数字都可以作为第 $r$ 轮的结尾”这一操作可以用差分实现，还可以记录一个 $cnt$ 变量表示还剩几个可以作为结尾的数：在循环遍历的同时，每遍历到一个就把 $cnt$ 减一，可以在迭代同时实现和差分一样的效果。
3. 多组数据，注意每次都要清空 vector 数组及 dp 数组！！！

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 7;

int n, k, q, dp[110][maxn];
vector <int> v[maxn];

void solve()
{
	memset(dp, -1, sizeof dp); // 初始化！！！
	cin >> n >> k >> q;
	for(int i = 1; i <= n; i ++){
		int l; cin >> l;
		v[i].clear(); // 清空！！！
		for(int j = 0, x; j < l; j ++){
			cin >> x; v[i].push_back(x);
		}
	}
	
	// 预处理dp
	dp[0][1] = 0; // 第一轮一定从1开始
	for(int r = 1; r <= 100; r ++){ // 枚举轮数
		for(int i = 1; i <= n; i ++){ // 枚举当前轮要接的行数
			int cnt = 0; // 记录还有多少个可以作为接龙结尾的数
			for(auto u : v[i]){ // 遍历第i行每一个数
				if(cnt > 0){
					if(dp[r][u] == -1) dp[r][u] = i; // 第一次被接龙
					else if(dp[r][u] != i) dp[r][u] = 0; // 第二次被接龙后可以任意接龙
					-- cnt; // 要接龙的个数--
					//（这里也可以用差分实现）
				}
				
				if(dp[r - 1][u] != -1 && dp[r - 1][u] != i){
					cnt = k - 1; // u之后的k-1个数都可以被接
				}
			}
		}
	}
	
	// O(1)处理询问
	while(q --){
		int r, c; cin >> r >> c;
		cout << (dp[r][c] == -1? 0 : 1) << '\n';
	}
}

signed main()
{
	int T; cin >> T;
	while(T --) solve();
	return 0;
}
```

---

## 作者：abslime (赞：38)

# P11230 [CSP-J 2024] 接龙 题解

## 题意简述

- $n$ 个人玩接龙游戏，每个人有一个数字序列 $S_p$ 作为词集。
- 每轮接龙需要一个玩家在其数字序列 $S_p$ 中选择一个连续子序列 $A$， 子序列 $A$ 的长度需要在 $[2,k]$ 之间。
- 第一轮接龙必须由以 $1$ 开头的序列 $A$ 开始，后续轮次则需以上一轮 $A$ 的最后一个元素开头。
- 同一个人不能连续两轮接龙。
- $q$ 次询问，每次询问包括两个参数 $(r,c)$，表示询问是否存在一个 $r$ 轮的接龙游戏，满足最后一次接龙的 $A$ 以数字 $c$ 结尾。

## 解题思路

前三个测试点可以通过搜索解决，可以考虑对搜索算法进行记忆化来优化程序效率，进而可以想到从动态规划的角度思考这道题的解法。

对于第 $j$ 个数字序列 $S_j$，将其长度记为 $l_j$。不妨认为 $S_j$ 的内容从下标 $0$ 开始存储，即其下标范围为 $0 \sim l_j-1$。

我们定义状态 $f_{i,j,t}$ 表示在第 $i$ 轮中，能否以第 $j$ 个数字序列的第 $t$ 个位置作为起点（其中第 $2$ 维和第 $3$ 维的状态总数不超过 $\sum l = 200,000$）。

定义状态 $g_{i,j,t}$ 表示在第 $i$ 轮中，能否以第 $j$ 个数字序列的第 $t$ 个位置作为终点。

动态规划的边界条件： 若 $S_{j,t}=1$，则 $f_{1,j,t}=\text{true}$；否则 $f_{1,j,t}=\text{false}$。

动态规划的答案表示：对于询问 $(r, c)$，若存在 $j,t$ 满足 $S_{j,t}=c$ 并且 $g_{r,j,t}=\text{true}$，则说明存在一种接龙方案，否则说明不存在。

### 关键变量声明

注意到 $S$ 的两个维度范围可能都可能很大，第一个维度最大可以达到 $n=100,000$，第二个维度最大可以达到 $\sum l=200,000$。如果直接将 $S$ 定义为普通的二维数组会超空间。可以考虑将 $S$ 定义为一个`vector`数组。由于`vector`每一维大小都可以互不相同，占用的总空间可以正好为 $\sum l$。

```cpp
vector<int> s[101000]; 
```
注意题解中 $f,g$ 定义为三维是为了方便描述与理解思路，在代码实现中 $f,g$ 实际上都可以用滚动数组将第一维优化掉。

```cpp
vector<bool> f[101000], g[101000];
```

### 输入

```cpp
cin >> n >> k >> q;
for(int i = 1; i <= n; i++){
  cin >> l[i];
  s[i].resize(l[i]);//调整第i个vector长度正好为l[i] 
  f[i].resize(l[i]);
  g[i].resize(l[i]);
  for(int j = 0; j < l[i]; j++){
    cin >> s[i][j];
    f[i][j] = (s[i][j] == 1);//动态规划边界条件的设置 
  }
}
```

### 输出

可以用 $ans_{r,c}$ 记录通过 $r$ 轮接龙游戏，能否让最后一次接龙的序列 $A$ 以 $c$ 结尾。那么在动态规划的过程中可以处理好 $ans$ 每个位置的值。遇到每一个查询可以 $O(1)$ 查表回答。

```cpp
while (q--){
  int r, c;
  cin >> r >> c;
  cout << ans[r][c] << '\n';
}
```

### 状态转移方程的分析

转移可以分为两类：
1. $f_{i,\ldots,\ldots}$ 转移到同一轮 $g_{i,\ldots,\ldots}$；
2. $g_{i,\ldots,\ldots}$ 转移到下一轮 $f_{i+1,\ldots,\ldots}$。

第一类转移的暴力实现需要 $O(k\sum l )$ 的时间复杂度，因为对于每一个 $f_{i,j,t}$ 为 $\text{true}$ 的位置，需要将 $g_{i,j,t+1}\ldots g_{i,j,\min(t+k-1,l_j - 1)}$ 都标记为 $\text{true}$。

第二类转移的暴力实现需要需要 $O((\sum l)^2 )$ 的时间复杂度，因为对于每一个 $g_{i,j,t}$ 为 $\text{true}$ 的位置，我们需要找到所有的 $j',t'$ 满足 $S_{j',t'}=S_{j,t}$ 且 $j' \neq j$，将 $f_{i+1,j',t'}$ 设置为 $\text{true}$。

上面两种转移的暴力实现总时间复杂度为 $O(r(k+\sum l)\sum l )$，会超时，需要进一步优化。

### $f_{i,\ldots,\ldots}$ 转移到同一轮 $g_{i,\ldots,\ldots}$ 的优化

我们发现，对于每一个 $f_{i,j,t}$ 为 $\text{true}$ 的位置，需要将连续一段区间的 $g_{i, j, t}$ 标记为 $\text{true}$。那么我们可以通过一个长度为 $l_j$ 的差分数组 $num$ 比较快地实现连续一段区间标记。

如果某一轮中 $f_{i,j,t}$ 为 $\text{true}$，我们就对第 $j$ 个数字序列在区间 $[t+1, \min(t+k-1, l_j-1)]$ 进行加 $1$ 标记。这一操作表示能以 $[t+1, \min(t+k-1, l_j-1)]$ 区间的数字作为这一轮接龙的结尾。

然后对 $num$ 每个位置进行前缀和处理，这样只要前缀和后数组 $num$ 位置 $t$ 的值大于 $0$，就知道 $g_{i,j,t}$ 的值应该为 $\text{true}$。

代码实现如下：
```c++
for(int j = 1; j <= n; j++){
  for(int t = 0; t < l[j]; t++){
    num[t] = 0;//初始化差分数组每个位置为0 
  }
  for(int t = 0; t < l[j]; t++)
    if (f[j][t]){//第i轮f[j][t]为true，需要对区间[t+1,min(t+k-1,l[j]-1)]打上区间+1的标记 
      num[t + 1]++;
      if (t + k < l[j]) num[t + k]--; 
    }
  for(int t = 0; t < l[j]; t++){
    if (t > 0) num[t] += num[t - 1];//对num数组进行前缀和处理 
    g[j][t] = (num[t] > 0);//如果num[t] > 0，则说明第i轮g[j][t]为true 
    ans[i][s[j][t]] |= g[j][t];//ans[i][c]表示第i轮是否有一种接龙游戏能以c结尾，此时用g数组更新ans 
  }
}
```
这一步实际上也可以用双指针来优化。

### $g_{i,\ldots,\ldots}$ 转移到下一轮 $f_{i+1,\ldots,\ldots}$ 的优化

对于 $g_{i,\dots,\dots}$ 到 $f_{i+1,\dots,\dots}$ 的状态转移，我们发现对于 $j \neq j'$，就需要考虑 $g_{i,j,t}$ 到 $f_{i+1,j',t'}$ 是否可以转移。那么可以考虑将 $j \neq j'$ 的转移分为 $j < j'$ 和 $j > j'$ 两类，这样的约束会更为简单，方便我们优化。

我们维护两个辅助数组（作为桶数组）：

1. $visd_{j,x}$ 表示在当前轮中，第 $1$ 到 $j$ 个数字序列是否能够到达值等于 $x$ 的数字，那么 $visd_{j,S_{j,t}} = visd_{j-1, S_{j,t}} \lor g_{i,j,t}$。
2. $visu_{j,x}$ 表示在当前轮中，第 $j$ 到 $n$ 个数字序列是否能够到达值等于 $x$ 的数字，那么 $visu_{j,S_{j,t}} = visd_{j+1, S_{j,t}} \lor g_{i,j,t}$。

维护好辅助数组 $visd$ 和 $visu$ 后，我们就可以比较快地实现 $f_{i,\dots,\dots}$ 到下一轮 $g_{i+1,\dots,\dots}$ 的转移：

$$
f_{i+1,j,t} = visd_{j-1,S_{j,t}} \lor visu_{j+1,S_{j,t}}
$$

上述的 $visu$ 和 $visd$ 在实际代码实现时，也可以通过滚动数组进行优化，以节省空间。

```cpp
memset(vis, 0, sizeof vis);//相当于思路中的visd
for(int j = 1; j <= n; j++){//j<j'的转移 
  for(int t = 0; t < l[j]; t++)
    f[j][t] = vis[s[j][t]];
  for(int t = 0; t < l[j]; t++)
    if (g[j][t])
      vis[s[j][t]] = 1;
}
memset(vis, 0, sizeof vis);//相当于思路中的visu
for(int j = n; j >= 1; j--){//j>j'的转移 
  for(int t = 0; t < l[j]; t++)
    f[j][t] = f[j][t] || vis[s[j][t]];
  for(int t = 0; t < l[j]; t++)
    if (g[j][t])
      vis[s[j][t]] = 1;
}
```

### 常数较大的代码

```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
int T, l[101000], n, k, q;
bool vis[201000];
vector<int> s[101000]; 
vector<bool> f[101000], g[101000];
int num[201000];
bool ans[101][201000];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while (T--){
		cin >> n >> k >> q;
		for(int i = 1; i <= n; i++){
			cin >> l[i];
			s[i].resize(l[i]);//调整第i个vector长度正好为l[i] 
			f[i].resize(l[i]);
			g[i].resize(l[i]);
			for(int j = 0; j < l[i]; j++){
				cin >> s[i][j];
				f[i][j] = (s[i][j] == 1);//动态规划边界条件的设置 
			}
		}
		memset(ans, 0, sizeof ans);
		for(int i = 1; i <= 100; i++){
			for(int j = 1; j <= n; j++){
				for(int t = 0; t < l[j]; t++){
					num[t] = 0;//初始化差分数组每个位置为0 
				}
				for(int t = 0; t < l[j]; t++)
					if (f[j][t]){//第i轮f[j][t]为true，需要对区间[t+1,min(t+k-1,l[j]-1)]打上区间+1的标记 
						num[t + 1]++;
						if (t + k < l[j]) num[t + k]--; 
					}
				for(int t = 0; t < l[j]; t++){
					if (t > 0) num[t] += num[t - 1];//对num数组进行前缀和处理 
					g[j][t] = (num[t] > 0);//如果num[t] > 0，则说明第i轮g[j][t]为true 
					ans[i][s[j][t]] |= g[j][t];//ans[i][c]表示第i轮是否有一种接龙游戏能以c结尾，此时用g数组更新ans 
				}
			}
			memset(vis, 0, sizeof vis);//visd数组 
			for(int j = 1; j <= n; j++){//j<j'的转移 
				for(int t = 0; t < l[j]; t++)
					f[j][t] = vis[s[j][t]];
				for(int t = 0; t < l[j]; t++)
					if (g[j][t])
						vis[s[j][t]] = 1;
			}
			memset(vis, 0, sizeof vis);//visu数组 
			for(int j = n; j >= 1; j--){//j>j'的转移 
				for(int t = 0; t < l[j]; t++)
					f[j][t] = f[j][t] || vis[s[j][t]];
				for(int t = 0; t < l[j]; t++)
					if (g[j][t])
						vis[s[j][t]] = 1;
			}
		}
		while (q--){
			int r, c;
			cin >> r >> c;
			cout << ans[r][c] << '\n';
		}
	}
	return 0;
}
```

上述代码总时间复杂度为 $O(r\sum l + q)$，但常数较大，对于较强的数据可能只有 $60$ 分。

### 代码常数优化：将存储方式从vector改为一维数组

因为`vector`属于STL，常数相比普通数组会比较大。实际上我们可以考虑将类二维数组存储的所有 $S_i$ 拉长为一个一维数组 $s$ 存储。定义 $totlen_i$ 表示 $l_i$ 的前缀和。那么可以认为 $S_i$ 存储在一维数组 $s$ 区间 $[totlen_{i-1}, totlen_{i-1} + l_i)$ 的位置。那么 $S_{j,t}$ 将存储在 $s$ 下标为 $totlen_{j-1} + t$ 的位置。$f$ 和 $g$ 的存储也可以类似地优化。

```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
int T, l[101000], n, k, q, totlen[101000], s[201000];
bool vis[201000];
bool f[201000], g[201000];
int num[201000];
bool ans[101][201000];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while (T--){
		cin >> n >> k >> q;
		for(int i = 1; i <= n; i++){
			cin >> l[i];
			totlen[i] = totlen[i - 1] + l[i];
			for(int j = 0; j < l[i]; j++){
				cin >> s[totlen[i - 1] + j];
				f[totlen[i - 1] + j] = (s[totlen[i - 1] + j] == 1);
			}
		}
		memset(ans, 0, sizeof ans);
		for(int i = 1; i <= 100; i++){
			for(int j = 1; j <= n; j++){
				for(int t = 0; t < l[j]; t++){
					num[t] = 0;//初始化差分数组每个位置为0 
				}
				for(int t = 0; t < l[j]; t++)
					if (f[totlen[j - 1] + t]){//第i轮f[j][t]为true，需要对区间[t+1,min(t+k-1,l[j]-1)]打上区间+1的标记 
						num[t + 1]++;
						if (t + k < l[j]) num[t + k]--; 
					}
				for(int t = 0; t < l[j]; t++){
					if (t > 0) num[t] += num[t - 1];//对num数组进行前缀和处理 
					g[totlen[j - 1] + t] = (num[t] > 0);//如果num[t] > 0，则说明第i轮g[j][t]为true 
					ans[i][s[totlen[j - 1] + t]] |= g[totlen[j - 1] + t];//ans[i][c]表示第i轮是否有一种接龙游戏能以c结尾，此时用g数组更新ans 
				}
			}
			memset(vis, 0, sizeof vis);//visd数组 
			for(int j = 1; j <= n; j++){//j<j'的转移 
				for(int t = 0; t < l[j]; t++)
					f[totlen[j - 1] + t] = vis[s[totlen[j - 1] + t]];
				for(int t = 0; t < l[j]; t++)
					if (g[totlen[j - 1] + t])
						vis[s[totlen[j - 1] + t]] = 1;
			}
			memset(vis, 0, sizeof vis);//visu数组 
			for(int j = n; j >= 1; j--){//j>j'的转移 
				for(int t = 0; t < l[j]; t++)
					f[totlen[j - 1] + t] = f[totlen[j - 1] + t] || vis[s[totlen[j - 1] + t]];
				for(int t = 0; t < l[j]; t++)
					if (g[totlen[j - 1] + t])
						vis[s[totlen[j - 1] + t]] = 1;
			}
		}
		while (q--){
			int r, c;
			cin >> r >> c;
			cout << ans[r][c] << '\n';
		}
	}
	return 0;
}
```

上述代码即可通过全部的民间测试数据。

---

## 作者：Genius_Star (赞：28)

upd：有一些小错误。

upd：放了 Code。

### 思路：

容易发现是动态规划题，状态是 $dp_{k, i, j}$ 表示在 $k$ 轮第 $i$ 个人是否可以出以第 $j$ 张牌结尾的接龙序列，然后考虑状态转移方程：
$$
dp_{k,i,j} = \bigvee [l \ne i \& a_{l,p} \in S_{i, j - k + 1,j}] dp_{k -1, l, p}
$$
其中 $S_{i, l, r}$ 表示 $a_{i, l \cdots r}$ 这些数构成的集合。

然后考虑令：
$$
s_{k, x} = \sum_{i = 1}^n \sum_{j = 1} ^{len_i} [a_{i, j} = x] dp_{k,i,j} \\
g_{k, i, x} = \sum_{j = 1} ^{len_i} [a_{i, j} = x] dp_{k,i,j}
$$
则状态转移方程优化为：
$$
dp_{k, i, j} = \bigvee [s_{k - 1, a_{l,p}} \ne g_{k - 1, i, a_{l,p}} ] (a_{l,p} \in S_{i, j - k + 1,j})
$$
然后可以走指针优化一下，就可以实现 $O(1)$ 转移了，时间复杂度为 $O(q + nr)$。

### 考场代码：

```cpp
#include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define mkp(x, y) make_pair(x, y)
#define fin(s) freopen(s, "r", stdin)
#define fout(s) freopen(s, "w", stdout)
using namespace std;
typedef long long ll;
const int N  = 2e5 + 10, M = 105;
inline ll read(){
	ll x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-')
		  f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x < 10){
		putchar('0' + x);
		return ;
	}
	write(x / 10);
	write(x % 10);
	return ;
}
int T, n, m, q, r, c, cnt, Max;
int len[N], h[N], f[N], s[N];
bool F[M][N];
vector<int> a[N], id[N], g[N];
vector<bool> dp[N];
void solve(){
	Max = 0;
	n = read(), m = read(), q = read();
	for(int i = 1; i <= n; ++i){
		cnt = 0;
		a[i].clear(), g[i].clear(), id[i].clear(), dp[i].clear();
		len[i] = read();
		for(int j = 0; j < len[i]; ++j){
			a[i].push_back(read());
			h[++cnt] = a[i][j];
			Max = max(Max, a[i][j]);
		}
		sort(h + 1, h + cnt + 1);
		cnt = unique(h + 1, h + cnt + 1) - (h + 1);
		for(int j = 0; j < len[i]; ++j)
		  id[i].push_back(lower_bound(h + 1, h + cnt + 1, a[i][j]) - (h + 1));
		dp[i].resize(len[i]); 
		g[i].resize(len[i]); 
	}
	for(int i = 1; i <= Max; ++i){
		s[i] = 0;
		for(int j = 1; j <= 100; ++j)
		  F[j][i] = 0;
	}
	for(int i = 1; i <= n; ++i){
		for(int j = 0; j < len[i]; ++j){
			if(j - m >= 0)
			  --f[a[i][j - m]];
			if(j && f[1]){
				F[1][a[i][j]] = dp[i][j] = 1;
				++s[a[i][j]];
				++g[i][id[i][j]];
			}
			++f[a[i][j]];
		}
		for(int j = 0; j < len[i]; ++j)
		  f[a[i][j]] = 0;
	}
	for(int k = 2; k < M; ++k){
		for(int i = 1; i <= n; ++i){
			int sum = 0;
			for(int j = 0; j < len[i]; ++j){
				dp[i][j] = 0;
				if(j - m >= 0){
					--f[a[i][j - m]];
					if(!f[a[i][j - m]]){
						if(s[a[i][j - m]] != g[i][id[i][j - m]])
						  --sum;	
					}
				}
				dp[i][j] = (sum >= 1);
				if(!f[a[i][j]]){
					if(s[a[i][j]] != g[i][id[i][j]])
					  ++sum;
				}
				++f[a[i][j]];
			}
			for(int j = 0; j < len[i]; ++j)
			  f[a[i][j]] = 0;
		}
		for(int i = 0; i < N; ++i)
		  s[i] = 0;
		for(int i = 1; i <= n; ++i){
			for(int j = 0; j < len[i]; ++j)
			  g[i][j] = 0;
			for(int j = 0; j < len[i]; ++j){
				if(dp[i][j]){
					F[k][a[i][j]] = 1;
					++s[a[i][j]];
					++g[i][id[i][j]];
				}
			}
		}
	}
	while(q--){
		r = read(), c = read();
		if(F[r][c])
		  puts("1");
		else
		  puts("0");
	}
}
int main(){
//	fin("chain.in"), fout("chain.out");
	T = read();
	while(T--)
	  solve();
	return 0;
}
```

---

## 作者：ZHR100102 (赞：23)

怎么周围的人都秒了 T3 不会 T4 啊，只有我觉得 T4 很套路，T3 比较难写吗。

# 暴力 dp

为了避免多维的状态定义，我们把每个人的子序列化为长度最多为 $2\times 10^5$ 的一维序列，并记录下每一张牌对应的人是谁。记这个一维序列的长度为 $tot$，显然 $tot=\sum_{i=1}^{n} l_i$。


我们定义状态 $dp_{i,j}$ 表示当前进行到第 $i$ 轮，且该轮以一维序列中的第 $j$ 张牌结尾是否可行。

有一个显然的转移，我们遍历第 $j$ 张牌的前面 $k-1$ 张牌（必须要是同一个人的），假设某张前面的牌所写的数字为 $x$，那么我们可以遍历 $r-1$ 层中**不是同一个人**的且值为 $x$ 的人的牌转移过来，只要这些牌中有一个的结果为 $1$，那么第 $j$ 张牌的值就是 $1$。

时间复杂度 $O(rn^2k)$。

# 第一步优化

注意到我们的限制有一个是“不能从同一个人那里转移过来”，考虑一个和前几年提高组假期计划那题很像的想法。

原题中是记录前 $3$ 大的值，目的是避免走到重复的景点。而这题我们可以借鉴它的思路，记录**两个属于不同人的**且可以转移过来牌。只要这两张牌中，有一张和我现在的牌所属的人不同，就是可以转移过来的。

这个可以通过在每一轮结束之后预处理一遍得到。

时间复杂度 $O(rnk)$。

# 第二步优化

到这里我们就快做完这题了。观察到一个数的结果为 $1$，当且仅当前 $k-1$ 位的预处理值中有一个可以转移。熟悉 dp 的人肯定能一下就想到单调队列优化，进行转移，时间复杂度就被降到了 $O(rn)$。

但这是普及组，不能考单调队列。于是我们换一种普及组思路。因为这题可以预处理，而查询操作是查询 $l$ 到 $r$ 之间有没有元素 $1$，因此我们预处理之后前缀和一下就能做到 $O(1)$ 查询有没有元素 $1$ 了。

时间复杂度 $O(rn)$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int t,n,k,q,f[105][200005][2],a[200005],bl[200005],tot,can[200005];
bitset<200005>dp[105];
void init()
{
    memset(f,-1,sizeof(f));
    for(int r=1;r<=100;r++)
    {
        //count can
        if(r==1)
        {
            for(int i=1;i<=tot;i++)can[i]=can[i-1]+(a[i]==1);
        }
        else
        {
            for(int i=1;i<=tot;i++)can[i]=can[i-1]+((f[r-1][a[i]][0]!=-1&&f[r-1][a[i]][0]!=bl[i])||(f[r-1][a[i]][1]!=-1&&f[r-1][a[i]][1]!=bl[i]));
        }
        //count dp
        int pre=0;
        for(int i=1;i<=tot;i++)
        {
            if(bl[i]!=bl[i-1])pre=i;
            int rn=i-1;
            int ln=max(pre,i-k+1);
            dp[r][i]=((can[rn]-can[ln-1])>0);
        }
        //count f
        for(int i=1;i<=tot;i++)
        {
            if(dp[r][i]==0)continue;
            if(f[r][a[i]][0]==-1)f[r][a[i]][0]=bl[i];
            else if(f[r][a[i]][1]==-1&&f[r][a[i]][0]!=bl[i])f[r][a[i]][1]=bl[i];
        }
        // for(int i=1;i<=tot;i++)
        // {
        //     cout<<"can["<<r<<"]["<<i<<"]="<<can[i]<<endl;
        // }
        // for(int i=1;i<=tot;i++)
        // {
        //     cout<<"f["<<r<<"]["<<i<<"][0]="<<f[r][i][0]<<endl;
        //     cout<<"f["<<r<<"]["<<i<<"][0]="<<f[r][i][1]<<endl;
        // }
    }
}
void solve()
{
    scanf("%d%d%d",&n,&k,&q);
    tot=0;
    for(int i=1;i<=n;i++)
    {
        int l;
        scanf("%d",&l);
        for(int j=1;j<=l;j++)
        {
            tot++;
            scanf("%d",&a[tot]);
            bl[tot]=i;
        }
    }
    init();
    while(q--)
    {
        int r,c;
        scanf("%d%d",&r,&c);
        printf("%d\n",(f[r][c][0]!=-1||f[r][c][1]!=-1));
    }
}
int main()
{
    freopen("chain.in","r",stdin);
    freopen("chain.out","w",stdout);
    scanf("%d",&t);
    while(t--)solve();
    return 0;
}
```

---

## 作者：chenxi2009 (赞：19)

# Upd 2024.11.5
广搜默默地碎掉了。补充了动态规划版的思路。
# 思路
## 广搜
**注意：广搜的常数至少为动态规划的 2 倍左右，不建议作为正解练习。**

考虑广度优先搜素，由于最多只要 $100$ 轮的数据，就跑 $100$ 轮的广搜，每一次从上次达到的接龙起点开始向后挪 $[1,k-1]$ 步。有如下几点可以优化：
- 某一轮已经被作为终点过的点不用再被检测，可以记录它下一个未被作为终点的位置快速跳过一整段已被查过的子段。
- 记录一个数字出现的位置，以便找到一段接龙的末尾后确定下一轮的起点位置。
- 记录某一个位置是否作为了下一轮的起点（是否入队），如果有了就不用再进队了。
- 如果说有两个人在这一轮都以一个数字结尾，那么下一轮所有人都可以以这个数字开头，别的以这个数字结尾的点都不用再处理了。
## 动态规划
略微延续广搜的思想，发现这道题很可能是 $O(1)$ 或单 $\log$ 询问，而显然这道题又没有什么施用数据结构的空间，考虑动态规划。

简单动态规划的显著特征是答案可以存在转移数组中，于是考虑 $f_{i,j}$ 以表示第 $i$ 轮能否以 $j$ 结尾。\
但是显然还有一点需要考虑，就是相邻的两轮不能用同一个人接龙，并且我们发现 $f$ 数组极大程度地没被利用（仅存储了可行性），需要发掘新的性质。

在广搜思路中已经发现如果前面一轮中的某个数字可以被两个人结尾，那么下一轮它就可以被所有人接龙。所以考虑 $f_{i,j}$ 保存：
- $0$，若不能在第 $i$ 轮以 $j$ 结尾；
- $-1$，若 $j$ 在第 $i$ 轮能被两个以上（含）的人结尾；
- $k$，若第 $i$ 轮 $j$ 可以且仅可以被 $k$ 号玩家结尾。

如何状态转移呢？考虑遍历所有人的词库，如果说一个数字前 $k-1$ 个数中有一个数字可以作为这一轮的开头（在上一轮可以被两个以上的人作为结尾，或者被另外一个人作为结尾），那么这个数字就可以作为该轮结尾。形式化地描述，$S_{j,l}$ 可以在第 $i$ 轮作为结尾，当且仅当：
$$
(\max_{m=\max(1,l-k+1)}^{l-1}[f_{i,s_{j,m}}\ne0]+[f_{i,s_{j,m}}\ne j])=2
$$
所以容易想到遍历一个人的词库时记录**可以作为开头的数字个数的前缀和**，判断一个数能否作为结尾只需要看它之前长度为 $k-1$ 的区间里有无**可以作为开头的数字**即可。

时间复杂度 $O(\sum(\sum l\times r))$，空间复杂度 $O(\sum(\max S\times r))$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,q,l[100001],r[100001],c[100001],f[101][200001];
vector<int>s[100001];
inline void input(){
	scanf("%d%d%d",&n,&k,&q);
	for(int i = 1;i <= n;i ++){
		scanf("%d",&l[i]);
		s[i].clear();
		s[i].push_back(0);//1-下标的强迫症 QAQ
		for(int j = 1;j <= l[i];j ++){
			s[i].push_back(0);
			scanf("%d",&s[i][j]);
		}
	}
	for(int i = 1;i <= q;i ++){
		scanf("%d%d",&r[i],&c[i]);
	}
	return;
}
inline void pre(){
	memset(f,0,sizeof(f));
	f[0][1] = -1;
}
inline void solve(){
	for(int i = 1;i <= 100;i ++){
		for(int j = 1;j <= n;j ++){
			int sum = 0;
			for(int m = 1;m <= l[j];m ++){
				if(m > k){
					sum -= f[i - 1][s[j][m - k]] != 0 && f[i - 1][s[j][m - k]] != j;//表达式意为 s_{j,m-k} 在上一轮是否可以被不是 j 的人接龙为结尾，即是否可以在此轮作为开头 
				}
				if(sum){//前面这一段有可以作为开头的，那么当前这个数字可以作为结尾 
					if(f[i][s[j][m]] == 0){
						f[i][s[j][m]] = j;
					}
					else if(f[i][s[j][m]] != j){//注意不要让一个人词库里的同一个数被重复计算 
						f[i][s[j][m]] = -1;
					}
				} 
				sum += f[i - 1][s[j][m]] != 0 && f[i - 1][s[j][m]] != j;//参考 31 行注释 
			}
		}
	}
}
inline void output(){
	for(int i = 1;i <= q;i ++){
		printf("%d\n",bool(f[r[i]][c[i]]));
	}
	return;
}
int main(){
	scanf("%d",&T);
	while(T --){
		input(); 
		pre();//预处理 
		solve();
		output();
	} 
	return 0;
}
```
# 总结
作为 J 组 T4 具有一定的难度，但是逻辑清晰，代码好调，知识点并没有超纲，是一道优秀的简单动态规划题。

---

## 作者：huangboning (赞：18)

动态规划题。

设 $dp_{i,j}$ 表示第 j 轮时数字 i 能否被转移。其中 $dp_{i,j}=-1$ 表示不能，
$dp_{i,j}=k$ 表示由第 k 个人转移过来，$dp_{i,j}=0$ 表示可以由多个人转移过来。

每次转移将每个人扫一遍，用 x 来维护当前是否有可以转移的状态，特判前一个状态和这个状态是否为同一个人即可。

upd:发现不用快读，优化了一下码风。
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,q,l[200010],xx[200010],yy[200010],dp[200010][110];
vector<int>v[200010];//每个人的词库
int main()
{
	ios::sync_with_stdio(0);
	cin>>T;
	while(T--){
		cin>>n>>k>>q;
		int maxl=0,maxr=0;
		for(int i=1;i<=n;i++){
			cin>>l[i];
			v[i].clear();
			for(int j=1;j<=l[i];j++){
				int x;
				cin>>x;
				maxl=max(maxl,x);
				v[i].push_back(x);
			}
		}
		for(int i=1;i<=q;i++){
			cin>>xx[i]>>yy[i];
			maxr=max(maxr,xx[i]);
		}
		for(int i=0;i<=maxl;i++){
			for(int j=0;j<=maxr;j++){
				dp[i][j]=-1;
			}
		}
		dp[1][0]=0;//必须从1开始
		for(int i=1;i<=maxr;i++){//i为轮数
			for(int j=1;j<=n;j++){
				int x=-1;
				for(int k1=0;k1<v[j].size();k1++){
					int t1=v[j][k1];//t1为这个人的第k1+1个单词
					if(k1>=k){//长度超过k
						int t2=v[j][k1-k];
						if(dp[t2][i-1]!=-1&&dp[t2][i-1]!=j&&x==k1-k)x=-1;//如果唯一能转移的状态出界
					}
					if(x!=-1){//更新当前状态
						if(dp[t1][i]==-1)dp[t1][i]=j;
						else if(dp[t1][i]!=j)dp[t1][i]=0;
					}
					if(dp[t1][i-1]!=-1&&dp[t1][i-1]!=j)x=k1;//更新x
				}
			}
		}
		for(int i=1;i<=q;i++){
			if(yy[i]>maxl)cout<<"0";//如果不存在yy[i]
			else cout<<(dp[yy[i]][xx[i]]!=-1);//否则输出是否无解
			cout<<"\n";
		}
	}
}
```

---

## 作者：cuizimu (赞：13)

这是一道 CSP-S 第 1.5 题难度的动态规划，但是放在 CSP-J 来考严格来说也没有超纲。

- `S` 由所有人的拥有的序列首尾相接而成。
- 元素 `S[j]` 属于第 `person[j]` 个人。
- 第 `i` 个人与第 `i+1` 个人拥有的序列在 `S` 中的分界线为 `end[i]`。
- `head[round][j]` 表示第 `round` 轮以元素 `S[j]` 开头是否可行。
- `tail[round][j]` 表示第 `round` 轮以元素 `S[j]` 结尾是否可行。
- `headSum` 是第 `round` 轮中 `head[round]` 的左闭右开前缀和。
- `owner[round][x]`
  - 为 0 表示第 `round` 轮没有人能以值为 `x` 的元素结尾。
  - 为正整数表示第 `round` 轮第 `owner[round][x]` 个人能以值为 `x` 的元素结尾。
  - 为正无穷表示第 `round` 轮有超过一个人能以值为 `x` 的元素结尾。

```c++
#include <iostream>
#include <climits>
#include <algorithm>
namespace noip {
typedef long long Int;

constexpr Int maxN = 100'000;
constexpr Int maxR = 100;
constexpr Int maxLSum = 200'000;
constexpr Int maxS = 200'000;
constexpr Int veryBeginningS = 1;

Int S[maxLSum], person[maxLSum];
bool tail[1+maxR][maxLSum], head[1+maxR][maxLSum];
Int owner[1+maxR][1+maxS];
Int n, k, q;
Int l[1+maxN], end[1+maxN];

void main() {
	std::cin >> n >> k >> q;
	end[0] = 0;
	for (Int i = 1; i <= n; i++) {
		end[i] = end[i-1]; std::cin >> l[i];
		for (Int j = 1; j <= l[i]; j++) std::cin >> S[end[i]++];
		for (Int j = end[i-1]; j < end[i]; j++) person[j] = i;
	}
	for (Int round = 1; round <= maxR; round++) {
		if (round > 1)
			for (Int j = 0; j < end[n]; j++) head[round][j] =
				owner[round-1][S[j]] == LLONG_MAX ? true :
				owner[round-1][S[j]] == 0 ? false :
				owner[round-1][S[j]] != person[j];
		else
			for (Int j = 0; j < end[n]; j++)
				head[round][j] = S[j] == veryBeginningS;
		static Int headSum[1+maxLSum+1]; headSum[0] = 0; // 左闭右开
		for (Int j = 0; j < end[n]; j++) headSum[j+1] = headSum[j]+head[round][j];
		for (Int right = 0; right < end[n]; right++) {
			Int left = std::max(end[person[right]-1], right-k+1);
			tail[round][right] = headSum[right]-headSum[left];
		}
		std::fill(owner[round]+1, owner[round]+1+maxS, 0);
		for (Int j = 0; j < end[n]; j++) if (tail[round][j]) owner[round][S[j]] =
			owner[round][S[j]] == 0 ? person[j] :
			owner[round][S[j]] == person[j] ? person[j] :
			LLONG_MAX;
	}
	while (q--) {
		Int r, c; std::cin >> r >> c;
		std::cout << (Int)bool(owner[r][c]) << std::endl;
	}
}

} int main() {
	noip::Int T; std::cin >> T;
	while (T--) noip::main();
	return 0;
}

```

---

## 作者：WaTleZero_pt (赞：13)

这道题萌新居然想了 $90\texttt{ min}$ 实在是太菜了

我们注意到 $r_{i}$ 的数据范围非常小好吧，很容易想到一个 $O(T(\max r \sum l))$ 的做法。具体是如何操作的呢？

1. 首先我们找出词库中所有的数字 $1$ 作为可能的出发点。

1. 接下来我们将可能的出发点后面 $k-1$ 个数标记为可能的终止点。为了避免重复计算被卡到 $n^{2}$ 级别，我们开一个和词库一样大的动态数组 $b$，若 $S_{i,j}$ 可能为出发点，将 $b_{i,j+1}$ 赋值为 $k-1$，这样按照 $b_{i,j} = \max(b_{i,j},b_{i,j-1}-1)$ 的转移方法，只要 $b_{i,j} > 0$ 该点就可能成为终止点。

1. 如果现在已经经历了 $x-1$ 轮循环并执行了操作 $2$，我们就可以将接龙长度为 $x$ 的问题全部回答掉了。

1. 然后我们要做的就是再次找出那些可能是下一轮接龙的出发点。如果 $x$ 在至少两个人的词库中作为可能的终止点出现，那么所有人的词库中的 $x$ 都可以作为下一轮的出发点；如果 $x$ 只在一个人的词库中出现，那么除这个人以外的其他人词库中的 $x$ 都可以作为下一轮的出发点。这也是很好做的，只需要我们统计每一个数字成为终止点的次数，以及出现的位置即可。

这就算是一次完整的操作，我们继续回到操作 $2$ 进行下一轮循环。重复执行 $\max r$ 次即可。

---

## 作者：jomy (赞：12)

明显是一道dp题。

可以先预处理，做到 $O(1)$ 回答每个询问。

定义 $f_{i,j}$ 为从 $1$ 开始，经过 $j$ 轮接龙，能否使最后一个元素为 $i$。

但由于一个人不能连续接龙两次，我们还要在 $f_{i,j}$ 里记录是由哪个点开头转移过来的，例如我的代码里分为了以下 $3$ 种情况。

1. $f_{i,j}=-1$ 无法经过 $j$ 轮接龙，使最后一个接龙的人为 $i$。
1. $f_{i,j}=0$ 存在两种最后一轮接龙的人不同的方案。
1. $f_{i,j}>0$ 存在接龙方案，但最后一轮接龙的人一定为 $f_{i,j}$。

转移有点难写在这里，看代码注释罢，见谅。


```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int c[N<<1][105];//l的和小于2e5，记得开大一点。
vector<int>v[N];
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		int n,k,q;
		scanf("%d%d%d",&n,&k,&q);
		for(int i=1;i<=n;i++){
			int x;
			scanf("%d",&x);
			v[i].clear();
			for(int j=0;j<x;j++){
				int u;
				scanf("%d",&u);
				v[i].push_back(u);
			}
		}
		memset(c,-1,sizeof c);
		c[1][0]=0;
		for(int i=1;i<101;i++){
			for(int j=1;j<=n;j++){
				int p=k+1;
				for(int l=0;l<v[j].size();l++){
					if(p<=k){//区间长不超过k
						if(c[v[j][l]][i]==-1||c[v[j][l]][i]==j) c[v[j][l]][i]=j;//由2种方案，但是最后一个人都是j，也不能动
						else c[v[j][l]][i]=0;
						p++;
					}
					if(c[v[j][l]][i-1]!=-1&&c[v[j][l]][i-1]!=j){
						p=2;//重置区间长，与原区间合并，将这个循环的复杂度优化到线性
					}
				}
			}
		}
		while(q--){
			int a,b;
			scanf("%d%d",&a,&b);
			if(c[b][a]==-1){
				putchar('0');
				putchar('\n');
			}
			else{
				putchar('1');
				putchar('\n');
			}
		}
	}
	return 0;
}
```

---

## 作者：ty_mxzhn (赞：10)

显然是图论模型。我们把每个词看成一个点，每个人看成一条“公交线路”。

注意到 $r$ 很小，考虑 Bellman-Ford 最短路算法，设计 $f_{i,j}$ 表示第 $i$ 个点是否可以通过**恰好** $j$ 次接龙到达。

转移的时候对每一个 $f_{i,j}=1$ 的点转移到他所在每条公交线路的后 $k-1$ 个站点。

复杂度太高，对于转移到后 $k-1$ 个站点使用**差分优化**。时间复杂度 $O(\sum l\max r)$。

诶我样例怎么过不去！！！

哦原来是读漏题了，每一个人不能接自己的龙。

重新设计 $f_{i,j,k}$ 新增一维表示上一次转移是从 $k$ 这条公交线转移来的。

复杂度太高了怎么办！！！

注意到：当 $f_{i,j,k}=1,f_{i,j,l}=1$ 时：假设我们要通过坐第 $x$ 条公交转移到 $f_{?,j+1,x}$。

当 $x\neq j,x\neq l$ 时，可以从 $k,l$ 任取一条公交。

当 $x=j$ 或者 $x=l$ 时可以选择另外一条公交。

于是！如果 $f_{i,j,?}$ 有 $\ge 2$ 个位置有值，则下一次坐哪一条公交都可以！

重新设计状态：$f_{i,j}$ 表示第 $i$ 个点接了 $j$ 次龙时，如果 $f_{i,j}=-1$ 则无法接 $j$ 次龙，如果 $f_{i,j}=0$ 则下一次可以任意接龙，如果 $f_{i,j}>0$ 则下一次不能走 $f_{i,j}$ 这条公交线。

至此本题得解了，吗？

这样子空间 $O(nr)$ 开不下啊。

考虑将查询挂在 $r$ 上，然后将 $r$ 从 $1\sim \max q_r$ 中枚举，滚动 dp 数组即可优化这部分空间为 $O(n)$。

赛时 30min 想 + 写 + 调，应该算比较好写好调的做法。如果按照我这种做法评难度可能绿 $\sim$ 蓝吧。

等发代码了这里再贴出来吧。

怎么感觉比今年 S T3 难呢。

---

## 作者：船酱魔王 (赞：8)

## 题意回顾

$ n $ 个数组，记询问 $ (tim,num) $ 要求构造一个长度为 $ tim $ 的操作序列，满足：
* 操作序列中，每个元素是一个 $ (i,l,r) $ 三元组。
* $ \forall 1 \le j \le tim $，$ 1 \le i_j \le n $，$ 1 \le l < r \le |a_{i_j}| $，$ r-l+1 \le k $。
* $ \forall 1 \le j < tim $，$ i_j \ne i_{j+1} $。

你需要对于每个构造要求判断是否有构造方法，$ k $ 是给定的。

数据范围：
* 对于每组数据，$ 1 \le n \le 10^5 $，$ a_i $ 的长度之和不超过 $ 2 \times 10^5 $，$ 1 \le tim \le 100 $。
* 最多 $ 5 $ 组这样的测试数据。

## 分析

你发现接龙操作最多进行 $ 100 $ 次，故考虑设计一个 $ O(nr) $ 的解法（$ r=100 $，即接龙次数上限）。

对于上一次接龙，如果没有接龙数组不同的要求的话，我们只关心每个字符可不可以作为上一次接龙的结尾即可。但是要求相邻接龙次数数组不同，考虑记录接龙桶子的无法作为接龙结尾、可以作为哪个数组的接龙结尾和可以作为接龙结尾且至少两个上一个接龙的可行接龙数组三种状态。

所以，我们可以由上一次接龙的桶子求出本次接龙哪些位置是合法的开头，我们只需要求出对于每个位置，往前前 $ [2,k] $ 个中是否存在可行的接龙开头，这个可以用前缀和预处理快速查询。然后用接龙结尾的可行情况更新桶子即可。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;
const int N = 2e5 + 5;
int T;
int n, k, q;
vector<int> vec[N];
struct node {
	int cha;
	int tim;
	int id;
	bool operator<(node p2) {
		if(tim != p2.tim) return tim < p2.tim;
		return id < p2.id;
	}
} a[N];
int ans[N];
int buc[N];
vector<int> dp[N];
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d%d%d", &n, &k, &q);
		int x, y;
		for(int i = 1; i <= n; i++) {
			scanf("%d", &x);
			vec[i].clear(), dp[i].clear();
			vec[i].push_back(0), dp[i].push_back(0);
			while(x--) scanf("%d", &y), vec[i].push_back(y), dp[i].push_back(0);
		}
		for(int i = 1; i <= q; i++) scanf("%d%d", &a[i].tim, &a[i].cha), a[i].id = i;
		sort(a + 1, a + q + 1);
		int pnt = 1;
		memset(buc, 0, sizeof(buc));
		buc[1] = N;
		int maxa = 2e5;
		for(int ri = 1; ri <= 100; ri++) {
			for(int i = 1; i <= n; i++) {
				for(int j = 1; j < vec[i].size(); j++) {
					x = vec[i][j];
					if(buc[x] > 0 && buc[x] != i) dp[i][j] = dp[i][j - 1] + 1;
					else dp[i][j] = dp[i][j - 1];
				}
			}
			memset(buc, 0, sizeof(buc));
			for(int i = 1; i <= n; i++) {
				for(int j = 1; j < vec[i].size(); j++) {
					x = vec[i][j];
					if(dp[i][j - 1] - dp[i][max(0, j - k)] > 0) buc[x] = (buc[x] == 0 || buc[x] == i) ? i : N;
				}
			}
			while(pnt <= q && a[pnt].tim <= ri) ans[a[pnt].id] = buc[a[pnt].cha], pnt++;
		}
		for(int i = 1; i <= q; i++) puts(ans[i] ? "1" : "0");
	}
	return 0;
} 
```

---

## 作者：cosf (赞：8)

首先注意到，$r$ 的值特别的小。所以我们可以考虑 $O(Tr(|\Sigma| + \sum l_x))$ 的做法，其中 $\Sigma$ 为字符集。

一个基本的想法是，首先离线询问，然后维护一个 $t_{i, j}$ 表示接龙 $i$ 次之后，是否能停在 $j$。但由于题目要求两次接龙不能是同一个人，所以额外维护一个 $r_{i, j}$，表示：

- 如果 $j$ 可以从两个不同的人接过来，则 $r_{i, j} = 0$。
- 否则 $r_{i, j}$ 为唯一能接过来的人的编号。

转移时，我们遍历每一个人的词库，对于第 $x$ 个人的词库 $S_{x, j}$，如果 $t_{i - 1, S_{x, j}} = 1$ 且 $r_{i - 1, S_{x, j}} \not= x$，则我们给 $S_{x, j + 1}$ 到 $S_{x, j + k}$ 都打上一个 tag，表示他们能被接到。这个过程可以通过差分解决。

因此，我们便可以在 $O(\sum l_x + |\Sigma|)$ 的时间内从 $t_{i - 1}, r_{i - 1}$ 转移到 $t_i, r_i$。时间复杂度允许。

---

## 作者：MoonCake2011 (赞：7)

来一个被我称为 dp 三步走的方法。

# Step 1

直接确定大方向，设 $dp_{i,j,k}$ 为第 $k$ 轮是否可以以第 $i$ 个人的词库中的第 $j$ 个数作为接龙开头。

只要 $S_{i,j}=1$，初值 $dp_{i,j,0}=1$。

这是个 $0,1$ 的 dp。

# Step 2

确定转移第一步，我们现在知道了每一轮一些数作为开头能选到的数，于是我们要求出能作为本次接龙的尾巴的数。

于是可以单调队列直接求。

# Step 3

求出上面这个还不行，接着要去转移到其他地方。

因为只能同色转移，且不能转移到自己，所以直接尝试将所有颜色对应的数的位置存下来。

对于每个颜色，按它的位置排序（双关键字）。

这样每个颜色的数组可以直接求出前缀 $\max$ 与后缀 $\max$，记为 $pre_i$ 与 $suf_i$。

在一个颜色中，对于每个同一个人的词库的段 $[l,r]$ 可以知道他们的值均为的 $\max(pre_{l-1},suf_{r+1})$，因为不能转移自己。

于是可以转移了，剩下的就可以乱玩了。

然后这种方法因为常数大，所以被卡常了，啊啊啊！

所以我写了篇题解来寻求自我安慰。

代码等公开。

---

## 作者：wyp20130701_AC (赞：5)

## CSP-J T4 接龙题解
### 基本思路
考虑先把所有询问都存下来，在统一处理。看到 $r$ 特别小，可以使用暴力解决每一轮接龙的过程，在过程中回答询问即可。每一轮接力时，需要记录该轮之后能够作为序列结尾的数字有哪些。同时，因为**若这不是游戏的第一轮，那么这一轮进行接龙的人不能与上一轮相同，但可以与上上轮或更往前的轮相同**，所以除了记录能够作为序列结尾的数字有哪些，还需要记录一下每一个数字是哪个人接出来的。  
如果一个数字可以由多个 $(\ge 2)$ 人接出来，那么**就没有若这不是游戏的第一轮，那么这一轮进行接龙的人不能与上一轮相同，但可以与上上轮或更往前的轮相同**这个限制了，因为以该数字结尾下一轮无论哪一个人接都是可行的。接下来考虑怎么从当前数字去更新下一轮接力后作为序列结尾的有哪些。因为 $r$ 和 $\sum\limits_{i=1}^nl_i$ 范围都不大，所以可以每一轮更新时都扫一遍所有人的词库。  
用数组记录每个数字能否做结尾，同时记录是由哪个人接出来的。  
从前到后扫描第 $i$ 个人的词库时，如果当前数字 $S_{i,j}$ 可以作为结尾且 $S_{i,j}$ 作为结尾时不是仅能由第 $i$ 个人接力得到的，那么 $S_{i,j}$ 之后的 $k - 1$ 个数字都可以做为下一个数的结尾，并且是由第 $i$ 个人接出来的。最后再把数组 $r$ 排序一下即可。 

```cpp
代码暂时不可见
```

---


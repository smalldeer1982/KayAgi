# [GDKOI2023 普及组] 淋雨

## 题目描述

Moon 发现自己来到了一个二维平面上，但是自己只能在 $y=0$ 的直线上以不超过 $v_c \space m/s$ 的速度行走（可以折返来回行走）。这个时候天空开始下了倾盆大雨，一共有 $n$ 个雨滴，第 $i(1 \le i \le n)$ 个雨滴以 $v_g\space  m/s$ 的
速度从 $(x_i, y_i)$ 开始匀速下落，同时开始刮起了速度为 $v_w \space m/s$，方向为 $x$ 轴正方向的大风, 可以认为每个雨滴在水平方向上有了和风速一样的速度, 以及风不会影响人的行走速度。

Moon 非常喜欢淋雨，为了简单起见把每个雨滴和 Moon 都视为是一个点，只有某个雨滴到达 $x$ 轴的位
置的同时，Moon 也正好在这个位置上，Moon 才可以被这个雨滴淋到。现在给出 $q$ 个询问，第 $i(1 \le i \le q)$
次询问给出一个初始位置 $(s_i, 0)$，Moon 想知道自己从 $(s_i, 0)$ 出发，在整个运动过程中，最多可以被多少个
雨滴淋到呢？

## 说明/提示

### 数据范围

对于所有的数据，有 $1 \le n, q \le 10^5, 1 \le v_w, v_g , v_c, y_i \le 10^6, −10^6 \le x_i, s_i \le 10^6$；

对于 $30\%$ 的数据，有 $1 \le n, q \le 100$；

对于另外 $30\%$ 的数据，有 $1 \le q \le 5$。

## 样例 #1

### 输入

```
4 4 1 1 5
-3 2 
4 1 
0 4 
2 3 
-4
1
-2 
0```

### 输出

```
2
3
2
3```

## 样例 #2

### 输入

```
见/example/rain/下的 rain1.in ```

### 输出

```
见/example/rain/下的 rain1.out```

# 题解

## 作者：aioilit (赞：8)

询问不太能在线回答，我们考虑离线。容易求出每个雨滴到达地面的时刻 $t_i$ 和位置 $p_i$，记作二元组 $(t_i,p_i)$。Moon 能碰到这个雨滴当且仅当时间 $t_i$ 时他已经在位置 $p_i$ 等待了。为方便处理，我们考虑加入一些雨滴 $(0,s_i)$，最后再将答案减 $1$。最朴素的暴力是枚举 Moon 碰雨滴的顺序，然后判定是否可行。直接做是阶乘级别的，使用状压可以优化到 $\mathcal{O}(2^n)$。由于先后接触的雨滴的 $t_i$ 一定单调不降，这启发我们进行 dp。设 $f_i$ 表示从雨滴 $i$ 的落地位置出发，最多可以被多少雨滴淋到。转移为 $f_i=max\{f_j\}+1$，其中 $|p_i-p_j|\leq v_c(t_j-t_i)$。套路地，可以将绝对值拆掉，$\Rightarrow \max(p_i-p_j,p_j-p_i)\leq v_c(t_j-t_i)$，从而 $-p_j-v_ct_j \leq -p_i-v_ct_i,p_j-v_ct_j\leq p_i-v_ct_i$。由于式子左右结构相同，我们考虑将雨滴的信息抽象成坐标系上的点 $(-p_i-v_ct_i,p_i-v_ct_i)$，则转移的限制是一个二维偏序。将值域离散化后，上树状数组优化 dp 可以做到 $\mathcal{O}(n\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=200005;
int n,Q;
int vg,vw,vc;
int ok[N];
ll b[N],m;
int _x,_y;
struct Rain{
	ll t,p;
}a[N];
int s[N];
struct Note{
	ll x,y;
	int id;
}p[N];
int t;
unordered_map<int,int> mp;
struct BIT{
	int tr[N];
	void add(int pos,int x){
		for(int i=pos;i<=m;i+=i&-i)
			tr[i]=max(tr[i],x);
	}
	int qry(int pos){
		int ret=0;
		for(int i=pos;i;i-=i&-i)
			ret=max(ret,tr[i]);
		return ret;
	}
} T;
int dp[N],ans[N];
int main(){
	scanf("%d%d",&n,&Q);
	scanf("%d%d%d",&vg,&vw,&vc);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&_x,&_y);
		a[++t]={_y,1ll*_y*vw+1ll*_x*vg};
	}
	for(int i=1;i<=Q;i++){
		scanf("%d",&s[i]);
		if(mp[s[i]]) continue;
		mp[s[i]]=++t;
		a[t]={0,1ll*s[i]*vg};
	}
	for(int i=1;i<=t;i++)
		p[i]={-a[i].p-1ll*vc*a[i].t,a[i].p-1ll*vc*a[i].t,i};
	for(int i=1;i<=t;i++) b[++m]=p[i].y;
	sort(b+1,b+m+1);
	m=unique(b+1,b+m+1)-b-1;
	for(int i=1;i<=t;i++) p[i].y=lower_bound(b+1,b+m+1,p[i].y)-b;
	sort(p+1,p+t+1,[&](Note a,Note b){return a.x!=b.x?a.x<b.x:a.y<b.y;});
	for(int i=1;i<=t;i++){
		dp[i]=T.qry(p[i].y)+1;
		T.add(p[i].y,dp[i]);
		if(p[i].id>n) ans[mp[a[p[i].id].p/vg]]=dp[i];
	}
	for(int i=1;i<=Q;i++) printf("%d\n",ans[mp[s[i]]]-1);
	return 0;
}
```

---

## 作者：g1ove (赞：3)

## [P11255](https://www.luogu.com.cn/problem/P11255)

打过这年的 GDKOI。以前也写过，lg 有题了就来写一下。

可以把每个雨滴处理出两个参数：$(t,p)$ 表示在时间 $t$ 会落在地点 $p$。然后把起始点当做一个雨滴加进去。

对于每个雨滴，按照 $t$ 从大到小排序，定义状态 $f_i$ 表示钦定接住第 $i$ 滴雨滴后能接到的雨滴数量。那么有转移：
$$
f_i=\max_{j=1}^{i-1} f_j+w_i \times[|p_i-p_j|\le (t_i-t_j)\times v_c]
$$
对于真正的雨点，$w_i=1$，否则（就是询问）$w_i=0$（其实不管这个最后减一就行了）。

分类讨论一下：

+ $p_i\ge p_j$

$$
|p_i-p_j|\le (t_j-t_i)\times v_c\Leftrightarrow t_iv_c+p_i\le t_jv_c+p_j
$$



+ $p_i\le p_j$

$$
|p_i-p_j|\le (t_j-t_i)\times v_c\Leftrightarrow p_i-t_iv_c\ge p_j-t_jv_c
$$

不难发现是个三维偏序的形式，可以写 cdq 滚过去就行。时间复杂度 $O(n\log^2 n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb emplace_back
const int N=400005;
using namespace std;
int n,q,len;
double vg,vw,vc;
double bf[N];
struct point{
	double t,p;
	int w,id,f;
	double d1,d2;
	int c1,c2;
	int nid;
}a[N];
struct BIT{
	int tr[N];
	void add(int x,int v)
	{
		while(x<=n*2)
		{
			if(v^-1) tr[x]=max(tr[x],v);
			else tr[x]=0;
			x+=x&-x;
		}
	}
	int ask(int x)
	{
		int res=0;
		while(x)
		{
			res=max(res,tr[x]);
			x-=x&-x;
		}
		return res;
	}
}tr;
void solve(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)/2,i,j;
	solve(l,mid);
	sort(a+l,a+1+mid,[&](point a,point b){return a.p<b.p;});
	sort(a+mid+1,a+1+r,[&](point a,point b){return a.p<b.p;});
	i=l,j=mid+1;
	for(;j<=r;j++)
	{
		for(;i<=mid&&a[i].p<=a[j].p;i++)
			tr.add(a[i].c1,a[i].f);
		a[j].f=max(a[j].f,tr.ask(a[j].c1)+a[j].w);
	}
	for(;i>=l;i--) tr.add(a[i].c1,-1);
	reverse(a+l,a+1+mid);
	reverse(a+mid+1,a+1+r);
	
	i=l,j=mid+1;
	for(;j<=r;j++)
	{
		for(;i<=mid&&a[i].p>=a[j].p;i++)
			tr.add(a[i].c2,a[i].f);
		a[j].f=max(a[j].f,tr.ask(a[j].c2)+a[j].w);
	}
	for(;i>=l;i--) tr.add(a[i].c2,-1);
	sort(a+l,a+1+r,[&](point a,point b){return a.nid<b.nid;});
	solve(mid+1,r);
}
int main()
{
	scanf("%d%d%lf%lf%lf",&n,&q,&vg,&vw,&vc);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		double tim=y*1.0/vg;
		a[i]=(point){tim,x+tim*vw,1,i,1,0,0,0,0,0};
	}
	for(int i=n+1;i<=n+q;i++)
	{
		int s;
		scanf("%d",&s);
		a[i]=(point){0,s*1.0,0,i,0,0,0,0,0,0};
	}
	n+=q;
	sort(a+1,a+1+n,[&](point a,point b){return a.t>b.t;});
	for(int i=1;i<=n;i++)
		a[i].d1=a[i].t*vc+a[i].p*1.0,
		a[i].d2=-a[i].t*vc+a[i].p*1.0,
		bf[++len]=a[i].d1,bf[++len]=a[i].d2,
		a[i].nid=i;
	sort(bf+1,bf+1+len);
	len=unique(bf+1,bf+1+len)-bf;
	for(int i=1;i<=n;i++)
		a[i].c1=len-(lower_bound(bf+1,bf+len,a[i].d1)-bf),
		a[i].c2=lower_bound(bf+1,bf+len,a[i].d2)-bf;
	solve(1,n);
	sort(a+1,a+1+n,[&](point a,point b){return a.id<b.id;});
	for(int i=n-q+1;i<=n;i++) printf("%d\n",a[i].f);
	return 0;
}

```
后记：发现 $t$ 这一维根本不用管，写二维偏序就行了，🤡了。

---

## 作者：ty_mxzhn (赞：2)

淋雨淋雨淋淋雨。

我们很容易算出每个雨滴在什么时候到达 $x$ 轴。另外为了方便考虑人的速度，不妨把时间流速放慢一点，可以让人的速度变为 $1$。

## 算法 1

显然时间不能倒流，设计 $F_i$ 表示从接到雨滴 $i$ 开始，接下来可以接到几个雨滴。

直接枚举下一个到达的雨滴 $j$ 进行转移即可，复杂度 $O(n^2)$。

## 算法 2

考虑优化。两个雨滴可以转移的条件是 $t_j>t_i,|p_i-p_j|\le t_j-t_i$。

分类讨论拆开绝对值。我们有 $p_j-p_i\le t_j-t_i$ 是 $p_j-t_j\le p_i-t_i$。另一种同理。

等价于一个在线一维数点问题，用两个树状数组维护。

时间复杂度 $O(n\log n)$。代码不放了，很好写。

---

## 作者：toolong114514 (赞：0)

## 解题思路
我们不妨让时间拉长到原来的 $v_c$ 倍，那么人的移动速度就变成了 $1$，风速变成了 $\frac{v_w}{v_c}$，雨滴下落速度变成了 $\frac{v_g}{v_c}$。这样可以简化接下来的式子。

接下来计算出每个雨滴 $i$ 到达地面的时刻和此时的横坐标，分别记作 $t_i,pos_i$。由于时间不可倒流，所以淋雨有先后顺序，可以将雨滴按落地时刻从小到大排序后 DP。

我们不妨把 $q$ 个询问都看做落地时刻为 $0$ 雨滴参与 DP，只是其它的状态不能从此处转移。这些雨滴也没必要去排序，直接留在最前面。

定义 $f_i$ 表示钦定当前淋了第 $i$ 滴雨，以后总共能淋雨的最大滴数。

显然，$f_1-1,\cdots,f_q-1$ 即为询问的答案。

两个雨滴之间可以转移，当且仅当淋完一滴雨赶到另一滴雨落地处的时间小于等于落地时刻之差。

转移方程如下：
$$f_i=\min_{\forall j>i,\left|pos_i-pos_j\right|\le t_j-t_i}f_j+1$$

直接以此转移，时间复杂度约为 $O(n^2)$，需要优化。

转移方程中的绝对值不太好处理，将其拆开如下：
$$f_i=\min\begin{cases}\min_{pos_i-pos_j\le t_j-t_i}{f_j+1}&pos_i\ge pos_j\\\min_{pos_j-pos_i\le t_j-t_i}{f_j+1}&pos_i<pos_j\end{cases}$$
整理可得
$$f_i=\min\begin{cases}\min_{pos_i+t_i\le pos_j+t_j}{f_j+1}&pos_i\ge pos_j\\\min_{pos_j-t_j\le pos_i-t_i}{f_j+1}&pos_i<pos_j\end{cases}$$
所有 $f_i$ 的转移显然是两组三维偏序的形式：
$$\begin{cases}t_i\le t_j\\pos_j\le pos_i\\pos_i+t_i\le pos_j+t_j\end{cases}$$
$$\begin{cases}t_i\le t_j\\pos_j> pos_i\\pos_i-t_i\ge pos_j-t_j\end{cases}$$

直接无脑上 CDQ 分治优化 DP，第一维 ```sort``` 排序，第二维归并，第三维用树状数组维护最大值转移即可。

时间复杂度约为 $O(n\log^2{n})$，可以通过本题。
## 参考代码
```cpp
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
typedef long double db;
const int N=5e5+10;
struct ccf{
	db pos,ti;
	int xld;
}dot[N];
bool cmp1(ccf pre,ccf nxt){
	return pre.ti<nxt.ti;
}
bool cmp2(ccf pre,ccf nxt){
	return pre.pos<nxt.pos;
}
bool cmp3(ccf pre,ccf nxt){
	return pre.pos>nxt.pos;
}
db v_w,v_g,v_c;
int n,q,ans;
int f[N];
db num[N];
int cnt;
int get_pos(db x){
	int l=1,r=cnt;
	while(l<=r){
		int mid=(l+r)/2;
		if(x<num[mid]) r=mid-1;
		else if(x>num[mid]) l=mid+1;
		else return mid;
	}
}
int lowbit(int x){return x&-x;}
int arr[N];
void upd(int x,int y){
	while(x<=cnt){
		arr[x]=max(arr[x],y);
		x+=lowbit(x);
	}
}
int ask(int x){
	int res=0;
	while(x>0){
		res=max(res,arr[x]);
		x-=lowbit(x);
	}
	return res;
}
void cdq(int l,int r){
	if(l==r){
		f[dot[l].xld]=max(f[dot[l].xld],1);
		return;
	}
	int mid=(l+r)/2;
	cdq(mid+1,r);
	cnt=0;
	for(int i=l;i<=r;i++){
		num[++cnt]=dot[i].pos+dot[i].ti;
	}
	sort(num+1,num+cnt+1);
	cnt=unique(num+1,num+cnt+1)-num-1;
	for(int i=1;i<=cnt;i++){
		arr[i]=0;
	}
	sort(dot+l,dot+mid+1,cmp2);
	sort(dot+mid+1,dot+r+1,cmp2);
	int i=l,j=mid+1;
	while(i<=mid){
		while(j<=r&&dot[i].pos>=dot[j].pos){
			if(dot[j].xld>q) upd(cnt-get_pos(dot[j].pos+dot[j].ti)+1,f[dot[j].xld]);
			j++;		
		}
		f[dot[i].xld]=max(f[dot[i].xld],(ask(cnt-get_pos(dot[i].pos+dot[i].ti)+1)+1));
		i++;
	}
	cnt=0;
	for(i=l;i<=r;i++){
		num[++cnt]=dot[i].pos-dot[i].ti;
	}
	sort(num+1,num+cnt+1);
	cnt=unique(num+1,num+cnt+1)-num-1;
	for(i=1;i<=cnt;i++){
		arr[i]=0;
	}
	sort(dot+l,dot+mid+1,cmp3);
	sort(dot+mid+1,dot+r+1,cmp3);
	i=l,j=mid+1;
	while(i<=mid){
		while(dot[i].pos<=dot[j].pos&&j<=r){
			if(dot[j].xld>q) upd(get_pos(dot[j].pos-dot[j].ti),f[dot[j].xld]);
			j++;		
		}
		f[dot[i].xld]=max(f[dot[i].xld],ask(get_pos(dot[i].pos-dot[i].ti))+1);
		i++;
	}
	sort(dot+l,dot+mid+1,cmp1);	
	cdq(l,mid);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>q>>v_g>>v_w>>v_c;
	v_g/=v_c,v_w/=v_c;
	for(int i=q+1;i<=q+n;i++){
		db xx,yy;
		cin>>xx>>yy;
		dot[i].xld=i;
		dot[i].ti=yy/v_g;
		dot[i].pos=xx+v_w*dot[i].ti;
	}
	for(int i=1;i<=q;i++){
		cin>>dot[i].pos;
		dot[i].ti=0;
		dot[i].xld=i;
	}
	sort(dot+1,dot+n+q+1,cmp1);
	cdq(1,n+q);
	for(int i=1;i<=q;i++){
		cout<<f[i]-1<<'\n';
	}
	return 0;
}
```
[AC record](https://www.luogu.com.cn/record/231636581)

Written by [toolong114514](/user/477821) on 2025/8/18.

---

## 作者：muvum (赞：0)

给一个 CDQ 分治做法

首先我们容易想到把所有的雨点按照落地时间从小到大排序，然后进行动规。但是，询问相当于动态修改初始状态，我们不可能对于每一个初始状态都进行一次 DP。

重跑一遍的时间开销主要在于重复地递推了后面的状态，这是不必要的，因为如果某一时刻你接到了第 $i$ 个雨滴，后续的决策是确定的。

虽然初始状态不确定，但终态是确定的。不妨倒过来想，我们设 $f_i$ 表示从刚好接到第 $i$ 个雨滴开始，接下来最多接到多少滴。在转移时下一个接的雨滴是 $j$，$j$ 要满足落地时间在 $i$ 之后且着陆位置与 $i$ 的着陆位置之间的距离小于在这一段时间内能跑的最大距离。

写成柿子：

$$\left|(x_j+v_w\cdot\dfrac{y_j}{v_g})-(x_i+v_w\cdot\dfrac{y_i}{v_g}) \right| \le v_c(\dfrac{y_j}{v_g}-\dfrac{y_i}{v_g})$$

$$-v_c(\dfrac{y_j}{v_g}-\dfrac{y_i}{v_g})\le \left|(x_j+v_w\cdot\dfrac{y_j}{v_g})-(x_i+v_w\cdot\dfrac{y_i}{v_g})\right| \le v_c(\dfrac{y_j}{v_g}-\dfrac{y_i}{v_g})$$

$$-v_cy_j+v_cy_i\le v_gx_j+v_wy_j-v_gx_i-v_wy_i\le v_cy_j-v_cy_i$$

$$
\begin{cases}
v_gx_j+(v_w+v_c)y_j\ge v_gx_i+(v_w+v_c)y_i\\
v_gx_j+(v_w-v_c)y_j\le v_gx_i+(v_w-v_c)y_i
\end{cases}
$$

看到两维约束，自然而然地想到了 CDQ 分治（别问我为什么不想树状数组）。

我们把所有雨点按照 $v_gx_i+(v_w-v_c)y_i$ 从小到大先排一次序，在分治归并的过程中按照 $v_gx_i+(v_w+v_c)y_i$ 从大到小排序，用左区间的信息更新右区间的信息，可以算出所有 $f_i$。

对于询问， 可以离线下来，并添加一个虚幻雨滴 $i$，令 $x_i = p_i, y_i=0$，在更新过程中不用这个雨滴更新后续信息，答案即为 $f_i$。

在分治时有一个细节，处理左区间后要先把左区间对右区间的影响添加后再处理右区间，否则右区间内部处理使用的是没接过左区间内的雨点的信息，归并时右区间又只会考虑从左区间某个雨点直接跑过来的情况，也就是无法正确计算“左区间内某雨点 $\rightarrow$ 右区间节点 1 $\rightarrow$ 右区间节点 2”的情况。

```cpp
// 代码中 vm 其实是 vw
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define Max(x, y) ((x)<(y)?(y):(x))
#define Min(x, y) ((x)<(y)?(x):(y))

using namespace std;

typedef long long ll;

const int N = 2e5 + 5;

ll x[N], y[N], vc, vg, vm;
int n, m, f[N], id[N];

bool cmp(const int &a, const int &b) {
	ll t1 = vg * x[a] + (vm - vc) * y[a], t2 = vg * x[b] + (vm - vc) * y[b];
	return t1 != t2 ? t1 < t2 : y[a] > y[b];
}

bool cmp2(const int &a, const int &b) {
	return vg * x[a] + (vm + vc) * y[a] > vg * x[b] + (vm + vc) * y[b];
}

int tmp[N];
void solve(int l, int r) {
	if (l == r) return;
	int mid = l + r >> 1; solve(l, mid);
	
	for (int i=mid+1; i<=r; ++i) tmp[i] = id[i];
	sort(id + mid + 1, id + r + 1, cmp2); // 先行更新右区间
	for (int pl=l-1,pr=mid+1,mx=0; pr<=r; ++pr) {
		while (pl < mid && vg*x[id[pl+1]]+(vm+vc)*y[id[pl+1]] >= vg*x[id[pr]]+(vm+vc)*y[id[pr]]) {
            ++pl; ((id[pl] <= n) ? mx = Max(mx, f[id[pl]]) : 0);
        }
		f[id[pr]] = Max(f[id[pr]], mx + (id[pr]<=n));
	}
	
	for (int i=mid+1; i<=r; ++i) id[i] = tmp[i];
	solve(mid+1, r); // 此时更新右区间是计入左区间影响的
	sort(id + l, id + r + 1, cmp2);
}

int main(void) {
	ios::sync_with_stdio(false);
	
	cin >> n >> m >> vg >> vm >> vc;
	for (int i=1; i<=n; ++i) {
		id[i] = i; cin >> x[i] >> y[i];
	}
	for (int i=n+1; i<=n+m; ++i) {
		id[i] = i; cin >> x[i]; y[i] = 0;
	}
	
	
	sort(id + 1, id + n + m + 1, cmp); // id存的是雨滴编号，把编号进行排序
	for (int i=1; i<=n+m; ++i) f[i] = (i <= n); // 加入 m 个虚幻雨滴，其贡献设为零
	solve(1, n + m);
	for (int i=n+1; i<=n+m; ++i) cout << f[i] << '\n'; // 虚幻雨滴的 f 就是答案
	
	return 0;
}
```

---


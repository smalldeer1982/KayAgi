# [GDKOI2023 普及组] 海星

## 题目描述

小明想去海底抓海星, 海底是一个树状的结构，而海星就藏在里面。

给定一棵 $n$ 个点的树，分别标号为 $1, 2, 3, ..., n$, 且对应的点权记为 $p_i$。

定义海星为其中的花子图，不妨设其中心节点标号为 $O$, 边缘节点标号为 $a_1, a_2, ..., a_t$ (其中边缘节点必
定直接与中心节点相连，同时花子图至少由一个中心节点和一个边缘节点构成)。此时记海星的价值为 $|p_O -
\sum p_{a_i} |$。

小明想知道他最多能抓到价值总和为多少的海星。（可以同时抓很多只海星，但是任意两个海星之间点的
交集必须为空）

补充定义:

**花图: 直径小于等于三的联通图，其中度数最大的节点为中心节点，其余节点为边缘节点（可知任意的边
缘节点度数为一）**

**示例：最小的花图，是 $(G,V)=({1,2},{(1,2)})$，仅由两个节点和联结它们的一条边构成。**

## 说明/提示

### 样例解释

一个合法的方案是，小明抓了两个海星，第一个海星的中心节点为 $1$，边缘节点为 $3$，价值为 $6$；第二个
海星的中心节点为 $2$，边缘节点为 $5$，价值为 $4$，此时得到最大总价值 $10$。

### 数据范围

$(1)$ 对于 $10\%$ 的数据，保证数据形成一个花图。

$(2)$ 对于 $20\%$ 的数据，保证数据形成一条链。

$(3)$ 对于 $20\%$ 的数据，保证数据相邻节点乘积恒负。

$(4)$ 对于 $20\%$ 的数据，保证数据形成一颗以 1 为根节点的二叉树。

$(5)$ 对于 $30\%$ 的数据，无特殊限制。

对于所有数据 $1 \le a, b \le n \le 10^5$，$-10^9 \leq p_i \leq 10^8$。

下发样例中编号为 $i, i + 5$ 的数据对应序号为 $i$ 的限制条件. $i \in \{1, 2, 3, 4, 5\}$。

## 样例 #1

### 输入

```
5
-2 -3 4 -5 1
1 2
1 3
2 4
2 5```

### 输出

```
10```

## 样例 #2

### 输入

```
见/example/starfish/下```

### 输出

```
见/example/starfish/下```

# 题解

## 作者：水星湖 (赞：2)

树形 dp。

一个点有三种状态：

- 不属于任何海星。

- 为中心节点。

- 为边缘节点。

我们发现一个点为边缘节点时，该点对应的中心节点可能是它的子节点之一也可能是它的父节点，所以要把这两种情况分开讨论。

对于每个点 $u$，设 $f_{u,0}$ 表示该点不属于任何海星，$f_{u,1}$ 表示该点为边缘节点，且该点对应的中心节点是它的儿子之一，$f_{u,2}$ 表示该点是中心节点，且选择的边缘节点仅有该点的子节点，$f_{u,3}$ 表示该点是中心节点，且选择的边缘节点中包含该点的父节点。没有设一个东西表示“该点为边缘节点，对应的中心节点是父节点”的原因是可以从确定该点父节点是中心节点之后，直接从该点不属于任何海星的状态转移。

考虑转移：

显然，$f_{u,0}=\sum_{v\in son_u} \max(f_{v,0},f_{v,1},f_{v,2})$，因为该点不属于任何海星，所以该点必然不是一个中心节点，故不可以从 $f_{v,3}$ 转移。

根据状态定义可以看出，$f_{u,1}$ 需要从 $f_{v,3}$ 转移，因为每个点只能对应一个中心节点，所以我们**必须**从所有子节点中选择**一个**点 $v$ 从 $f_{v,3}$ 转移，其余子节点同上。实现时，可以先令 $f_{u,1}=\sum_{v\in son_u} \max(f_{v,0},f_{v,1},f_{v,2})$，最后加上 $\max_{v\in son_u} (f_{v,3} - \max(f_{v,0},f_{v,1},f_{v,2}))$ 即可。

$f_{u,2}$ 转移同样可以使用 $f_{u,1}$ 转移时的方式，即先令 $f_{u,2}=\sum_{v\in son_u} \max(f_{v,0},f_{v,1},f_{v,2})$，然后将一部分 $\max(f_{v,0},f_{v,1},f_{v,2})$ 替换为 $f_{v,0} + val_v$，$val_v$ 为 $v$ （边缘节点）的贡献，因为带绝对值，所以贡献要分正负计算。注意到，如果将一个点 $v$ 的 $\max(f_{v,0},f_{v,1},f_{v,2})$ 替换为 $f_{v,0} + val_v$，相当于 $f_{u,2} \gets f_{u,2}+(f_{v,0} + val_v-\max(f_{v,0},f_{v,1},f_{v,2}))$，所以实现时可以单独存 $f_{v,0}+val_v-\max(f_{v,0},f_{v,1},f_{v,2})$，只将其中 $>0$ 的计入贡献即可，但是注意如果没有 $>0$ 的值时，由于海星至少两个点，所以也必须选一个计入贡献（显然选最大的）。

$f_{u,3}$ 与 $f_{u,2}$ 类似，只需要在 $f_{u,2}$ 的基础上额外考虑一下父节点的贡献即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 1e5 + 5, inf = 1e18;
vector<int> p[N];
int n, a[N], f[N][4];
void dfs(int u, int fa) {
    int mx = -inf, val1 = a[u], val2 = -a[u];
    vector<int> v1, v2;
    for(int v : p[u]) {
        if(v == fa) continue;
        dfs(v, u);
        int tmp = max({f[v][0], f[v][1], f[v][2]});
        f[u][0] += tmp; f[u][1] += tmp;
        mx = max(mx, f[v][3] - tmp);
        v1.push_back(f[v][0] - tmp - a[v]);
        v2.push_back(f[v][0] - tmp + a[v]);
    }
    sort(v1.begin(), v1.end(), greater<int>());
    sort(v2.begin(), v2.end(), greater<int>());
    if(p[u].size() > (bool)fa) {
        val1 += f[u][0], val2 += f[u][0];
        f[u][1] += mx;
        val1 += v1[0], val2 += v2[0];
        for(int i = 1; i < (int)v1.size(); i++)
            if(v1[i] > 0) val1 += v1[i];
        for(int i = 1; i < (int)v2.size(); i++)
            if(v2[i] > 0) val2 += v2[i];
        f[u][2] = max(val1, val2);
        f[u][3] = max(val1 - a[fa], val2 + a[fa]);
    } else f[u][3] = abs(a[fa] - a[u]); 
}
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        p[u].push_back(v);
        p[v].push_back(u);
    }
    dfs(1, 0);
    cout << max({f[1][0], f[1][1], f[1][2]}) << '\n';
}

#undef int

}


int main()
{
    z::main();
    return 0;
}

```

---

## 作者：xiaofu15191 (赞：0)

哇。

两年前的远古题目，当时初一的我拿到了 $0$ 分的好成绩。感觉现在比当时也没提升多少。

题目要求在树上选一些菊花，定义一个菊花中心节点为 $O$，边缘节点为 $a_i$，该菊花价值为 $\lvert {p_O-\sum{p_{a_i}}} \rvert$。求最大总价值。感觉贪心不好记数，考虑树形 DP。

定义当前节点为 $i$，状态如下：

- $f_{i,0}$ 表示点 $i$ 不属于任何海星；
- $f_{i,1}$ 表示点 $i$ 为海星的边缘节点，其中心节点为 $i$ 的某个儿子；
- $f_{i,2}$ 表示点 $i$ 为海星的中心节点，仅拥有某些儿子为它的边缘节点；
- $f_{i,3}$ 表示点 $i$ 为海星的中心节点，拥有 $i$ 的某些儿子与 $i$ 的父亲为它的边缘节点。

不设状态表示“点 $i$ 为海星的边缘节点，其中心节点为 $i$ 的某个父亲”是因为这包含在 $f_{i,2} \cup f_{i,3}$ 中。

现在思考如何转移。令节点 $i$ 有儿子 $j$。

显然有 $f_{i,0}=\sum_{son_i}^j{\max(f_{j,0},f_{j,1
},f_{j,2})}$。

对于 $f_{i,1}$，我们要将 $\max(f_{j,0},f_{j,1
},f_{j,2})$ 的值带上来，同时选一个 $f_{j,3}$ 作为其中心节点转移。将 $j$ 遍历完后找到贡献最大的 $j$ 更新即可。

对于 $f_{i,2}$，与 $f_{i,1}$ 相似地，我们先令 $f_{i,2}=\sum_{son_i}^j{\max(f_{j,0},f_{j,1
},f_{j,2})}$，随后将一部分 $\max(f_{j,0},f_{j,1
},f_{j,2})$ 替换为 $f_{j,0}+p_j$。设 $t=f_{j,0}+p_j-\max(f_{j,0},f_{j,1
},f_{j,2})$，则替换等价于 $f_{j,2} \leftarrow t$。于是我们可以将 $t$ 单独拿出来，排序之后选取大于 $0$ 的计入答案。但是我们发现答案有绝对值，要**分正负情况讨论**。此外，注意不论是否大于 $0$，**最大的一个 $t$ 一定要取**。

$f_{i,3}$ 就是在 $f_{i,2}$ 的基础上加/减了 $p_{fa_i}$。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;
long long n,num[100010],f[100010][4];
/*
f[i][0] i 不属于任何海星
f[i][1] i 为海星的边缘节点，其中心节点为 i 的某个儿子
f[i][2] i 为海星的中心节点，仅拥有某些儿子为它的边缘节点
f[i][3] i 为海星的中心节点，拥有 i 的某些儿子与 i 的父亲为它的边缘节点
*/
vector<long long>graph[100010];
void DP(long long now,long long fa)
{
	long long tmp=-1145141919810;
	vector<long long>v1,v2;//贡献分正负计算
	for(auto to:graph[now])
	{
		if(to==fa) continue;
		DP(to,now);
		long long tmp2=max(f[to][0],max(f[to][1],f[to][2]));
		f[now][0]+=tmp2;
		f[now][1]+=tmp2;//把其他节点的答案带上来
		tmp=max(tmp,f[to][3]-tmp2);//选出此时对 f[now][1] 贡献最大的儿子作为海星中心点
		// f[now][1]=max(f[now][1],f[to][3]); 打的时候错误地想出来这一句 看前两行 不能像这一行这样做 :(
		v1.push_back(f[to][0]-tmp2-num[to]);
		v2.push_back(f[to][0]-tmp2+num[to]);
	}
	sort(v1.begin(),v1.end(),greater<long long>());
	sort(v2.begin(),v2.end(),greater<long long>());
	if(graph[now].size()>(fa==0?0:1)) //有没有儿子
	{
		long long val1=f[now][0]+num[now],val2=f[now][0]-num[now];
		f[now][1]+=tmp;
		val1+=v1[0];val2+=v2[0];
		for(long long i=1;i<v1.size();i++)
			if(v1[i]>0)
				val1+=v1[i];
		for(long long i=1;i<v2.size();i++)
			if(v2[i]>0)
				val2+=v2[i];
		f[now][2]=max(val1,val2);
		f[now][3]=max(val1-num[fa],val2+num[fa]);
	}
	else f[now][3]=abs(num[fa]-num[now]);//没有儿子只能这么选
}
int main()
{
	cin>>n;
	for(long long i=1;i<=n;i++) cin>>num[i];
	for(long long i=1;i<n;i++)
	{
		long long u,v;
		cin>>u>>v;
		graph[u].push_back(v);
		graph[v].push_back(u);
	}
	DP(1,0);
	cout<<max(f[1][0],max(f[1][1],f[1][2]));
}
```

---

## 作者：ty_mxzhn (赞：0)

海星海星海海星。

考虑树形 dp。一个点有 $4$ 种状态：

1. 是海星的触手。
2. 不属于任何海星。
3. 是海星的中心，且触手伸到了父亲。
4. 是海星的中心，触手没有伸到父亲。

转移时，前两个是简单的，后两个因为答案的计算是绝对值形式，所以要把 $|p_O-\sum p_{a_i}|$ 拆成 $\max(p_O-\sum p_{a_i},\sum p_{a_i}-p_O)$。

再多记两个状态得解。时间复杂度为大常数 $O(n)$。

---


# 世界沉睡童话

## 题目背景

$$
\begin{array}{cr}
\text{时针停在相互拥抱的前一秒}\\
\text{凝视每件事的空白}\\
\text{等待缝隙}\overset{\text{Memory Limit Exceeded}}{\text{被缺失章节填满}}\\
\text{等}\overset{\text{return }{\color{#EE0000}0}\text{;}}{{\color{#EE0000}\text{某个人}}\text{回来}}\\
&\text{——《世界沉睡童话》}
\end{array}
$$

![](bilibili:34574689)

---

在不断变化着的世界中，找出彼此的所属。

压缩成一个数的记忆，泠珞又能否还原呢？

## 题目描述

给定正整数 $n$ 和非负整数 $k$，请构造一个正整数序列 $a_1,a_2,\cdots,a_n$，满足恰有 $k$ 组正整数对 $(i,j)$  $(1\le i<j\le n)$，满足 $\max(a_i,a_j)$ 是 $\min(a_i,a_j)$ 的倍数。

输入保证有解。

为了获得满分，你需要保证 $a_i\le 2n-1$。

## 说明/提示

**【样例 #1 解释】**

符合要求的数对有 $(1,2),(1,3),(2,3),(2,5),(3,4),(3,5),(3,6),(4,5)$ 共 $k=8$ 组。

**【数据范围】**

**本题采用捆绑测试和子任务依赖。**

本题中，**RE 会显示为 UKE，这是正常现象**。

具体地，部分测试点可能属于多个子任务。因此，子任务不会显式地显示出来。以下表格表示了每个测试点属于的子任务情况：

| 测试点编号 | 所属子任务 |
| :----------: | :----------: |
| $1,2,4,8$ | $1,2,3,4,5$ |
| $22$ | $2,3,4,5$ |
| $43$ | $3,4,5$ |
| $3,5,6,9\sim11,15\sim18$ | $1,2,4,5$ |
| $7,12\sim 14,19\sim 21$ | $1,2,5$ |
| $23\sim25,33,39$ | $2,4,5$ |
| $26\sim 32,34\sim 38,40\sim 42$ | $2,5$ |
| $44\sim 54$ | $4,5$ |
| $55\sim 100$ | $5$ |

不保证**不存在**某些数据符合它不在的 Subtask 的条件。

对于 $100\%$ 的数据，$1\le n\le 2.5\times10^5$，$0\le k\le \dfrac{n(n-1)}{2}$，本题的数据保证有解。

对于每个子任务，如果你保证了 $a_i\le 4n$，你将获得 $p_1$ 的分数。如果你保证了 $a_i\le 3n$，你将获得 $p_2$ 的分数。如果你保证了 $a_i\le 2n-1$，你将获得 $p_3$ 的分数，即满分。

对于每个子任务，你只有保证了**所有**属于它的测试点都保证了以上的条件，你才能获得对应的分数。

输出任意一组符合要求的可行解都可以获得对应的分数。

因此，您无法直接知道每个子任务的 $p_1,p_2$ 部分分数的获取情况。你可以通过在程序内进行 `assert`（用法：`assert(表达式)`，若表达式为 `0` / `false` 则会 RE）确认自己的通过情况。

| 子任务编号 | $p_1$ | $p_2$ | $p_3$ | $n\le $ | $k\le $ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $3$ | $5$ | $5$ | $\dfrac{n(n-1)}{2}$ |
| $2$ | $5$ | $11$ | $17$ | $10^4$ | $\dfrac{n(n-1)}{2}$ |
| $3$ | $1$ | $1$ | $2$ | $2.5\times10^5$ | $0$ |
| $4$ | $7$ | $13$ | $29$ | $2.5\times10^5$ | $n-1$ |
| $5$ | $11$ | $23$ | $47$ | $2.5\times10^5$ | $\dfrac{n(n-1)}{2}$ |

## 样例 #1

### 输入

```
6 8```

### 输出

```
3 6 1 4 2 5```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5 5 5```

# 题解

## 作者：Naszt (赞：47)

# P11277 世界沉睡童话

我场切了？真的假的？~~飘了。~~  
而且感觉思维和代码复杂度都比官方解答简单。

## 思路分析

### step1 找突破口

**我们先考虑极端情况**

对于 $k=\binom{n}{2}=\frac{n(n-1)}{2}$:  
容易想到构造 $\{1,1,1,\dots,1\}$。  
两两相等即互相整除。

对于 $k=0$:  
容易想到构造 $\{n,n+1,n+2,\dots,2n-1\}$。  
这样最大也不会到两倍，即两两不整除。

**按照类似的思路**

对于 $k<n-1$:  
构造 $\{n,\dots,n,n+1,\dots,n+1,\dots\}$。  
这样形成 $x_1/x_2/\dots$ 个 $n/n+1/\dots$。  
每 $x$ 个相同的数字之间互相整除，不同数字之间仍旧不整除，  
即 $\sum \binom{x_i}{2}=k$。  

我们想要某个 $k$ 的意义下构造一组 $x$ 使得 $\sum x_i$ 尽可能的小，  
可以贪心的划分长度，使得前面的 $x$ 尽可能的大，  
这样是最优的，如果把前面的 $x$ 减少，那么 $\sum x_i$ 不会更少。  
按照这种方法，只用保证 $n\ge\sum x_i=$ [A336640](https://oeis.org/A336640)$(k)$。  
即 $k<n-1$ 是一个充分条件使得贪心方法可做。

对于 $k=n-1$:  
构造 $\{1,n,n+1,n+2,\dots,2n-2\}$。  
$1$ 可以被其他的所有数整除。

### step2 合并

我的解法就是把这两种情况合并。

若 $k\ge n-1$，我们令第一项为 $1$。  
这样就要解决一个子问题：$k'\gets k-(n-1),n'\gets n-1$  

再按照一样的方法添加 $1$ 解决这个子问题。  
直到 $k<n-1$，上方贪心的方法即可解决。


## 代码实现

还算比较短的 c 风格代码：

```c
long long n,k,t;
main(){
  scanf("%Ld%Ld",&n,&k);
  for(int i=n-1;i<=k&&t<n;k-=i--,t++)
    printf("1 ");
  for(int i=n;i<2*n;i++)
    for(int j=0;j<=k&&t<n;k-=j++,t++)
      printf("%d ",i);
}
```

---

## 作者：Drifty (赞：15)

### Solution

好神秘的题。

我们不妨设 $a_1 \le a_2 \le a_3 \le \dots \le a_n$，这样题面所述条件可以转化为恰好存在 $k$ 对 $(i, j)$，使得 $i < j,a_i\text{\textbar} a_j$。

我们先看到 $k=0$，令 $a_1 = n, a_2 = n + 1, \dots, a_n = 2n - 1$ 秒了。

我们又看到这个 $k < n - 1$ 的部分分，注意到如果把 $k < n - 1$ 的情况做出来，那么就做完了。因为对于 $k \ge n  - 1$，我们只要在 $a$ 中加入一个 $1$，我们就可以产生 $n - 1$ 的贡献，那么我们将 $k\leftarrow k - n + 1$，$n \leftarrow n - 1$，然后继续迭代，直到化为 $k < n - 1$ 为止，然后按照这个部分分来构造就好了。

接下来解决部分分。我们注意到 $\frac{(3 - 1) \times 3}{2}$，这意味着如果存在 $i$ 使得 $a_i=a_{i + 1}=a_{i + 2},a_i \neq a_{i-1},a_{i + 2}\neq a_{i + 3}$，那么这三个数能产生三个贡献，也就意味着这三个数每个数恰好产生一个贡献。这就很好了，因为这样可以让我们非常方便地去凑出 $k$，具体地，我们一直用三个相等的数去凑，为了避免交叉产生贡献一开始我们令 $p = 2n - 1$，然后让连续的三个 $a_i=a_{i + 1}=a_{i + 2} = p$，$p\leftarrow p - 1$，$k\leftarrow k - 3$，一直到 $k < 3$ 为止，剩下的我们就 2 个 2 个地凑，这样 2 个数产生一个贡献，注意到 $k < n - 1$ 因此 $n$ 一定够用。然后就可以了。

### Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k;
namespace AC {
    void Solve () {
        while (k >= n - 1 && n) k -= (n - 1), n --, cout << 1 << ' ';
        int p = 2 * n - 1, f = 0;
        for (int i = 1; i <= k / 3; i ++, p --)
            for (int j = 1; j <= 3; j ++) cout << p << ' ', f ++;
        for (int i = 1; i <= k % 3; i ++, p --, f += 2) cout << p << ' ' << p << ' ';
        for (int i = f + 1; i <= n; i ++, p --) cout << p << ' ';
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
    cin >> n >> k;
    AC::Solve ();
    return 0;
}
```

---

## 作者：lingziyi2025 (赞：12)

# P11277 世界沉睡童话 题解

~~我有一个更加神仙的做法！~~

首先，我们知道：放 $x$ 个相同的数能得到 $\frac{x(x-1)}{2}$ 个对。

直接考虑用上面的方式填感觉很乏力。

我们再考虑一个很“强劲”的方式：放 $1$，这样能直接得到 $n-1$ 个对。

那么考虑先放 $1$，把 $k$ 减小（ 同时 $n-1$ ），再放相同的数。

发现有一个很好的性质：放完以后 $k<n-1$。

然后就可以线性地放，放 $3$ 个相同能得到 $3$ 个，那么我们就先放 $3$ 个相同的。

如果最后 $k=1$，放一对相同的。

如果最后 $k=2$，放两对相同的（由于 $k<n-1$ 所以这样做刚刚好放得下）。

最后，为了放相同的数时不会互相干扰，我们依次放 $n,n+1,\cdots 2n-1$；

```c++
#include<bits/stdc++.h>
#define rg register int
#define fo(i,l,r) for(rg i=(l);i<=(r);i++)
#define dfo(i,r,l) for(rg i=(r);i>=(l);i--)
#define fe(i,x) for(rg i=hd[x];i;i=nex[i])
#define frein freopen("in.txt","r",stdin);
#define freout freopen("out.txt","w",stdout);
#define fre(p) freopen(#p".in","r",stdin),freopen(#p".out","w",stdout);
#define outa(l,r,a) {fo(i,l,r)cout<<a[i]<<" ";cout<<"\n";}
#define BZ cout<<"----------------\n";
#define eb emplace_back
#define ll long long
using namespace std;
const int N=3e5+5;ll k;
int tn,n,a[N],p;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;tn=n;
	while(k>=n-1&&k>0){
		k-=n-1;
		a[n--]=1;
	}
	p=n;
	while(k>=3){
		a[n]=a[n-1]=a[n-2]=p++;
		k-=3,n-=3;
	}
	if(k==1)a[n]=a[n-1]=p++,n-=2;
	else if(k==2)a[n]=a[n-1]=p++,n-=2,a[n]=a[n-1]=p++,n-=2;
	fo(i,1,n)a[i]=p++;
	fo(i,1,tn)cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：251Sec (赞：5)

我们猜测数据范围内一定有解。

若 $k \ge n-1$，则我们可以在开头放一个 $1$，令 $k \gets k-(n-1)$，$n \gets n-1$，然后最终归约到 $k<n-1$ 的子问题。

我们大胆猜测 $k<n-1$ 时答案一定可以形如若干值域 $\in [n,2n-1]$ 的连续段，每个连续段的值互不相同，它们的贡献即是每个连续段长度 $\binom{\text{len}}{2}$ 求和。

接下来我们直接贪心地填这些连续段，每次选择一个长度 $\text{len} \le n \land \binom{\text{len}}{2} \le k$ 的最大的 $\text{len}$ 填上一个长度为 $\text{len}$ 的连续段。感性上这是很优的，交一发发现过了。其实证明也很简单，归纳一下就全对了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n; ll k;
vector<int> ans;
int main() {
	scanf("%d%lld", &n, &k);
	while (n && k >= n - 1) {
		printf("1 ");
		k -= n - 1, n--;
	}
	int n0 = n;
	for (int i = n; i >= 1; i--) {
		while (k >= 1ll * i * (i - 1) / 2 && n >= i) {
			k -= 1ll * i * (i - 1) / 2, n -= i;
			ans.push_back(i);
		}
	}
	for (int i = 0; i < ans.size(); i++) {
		for (int j = 1; j <= ans[i]; j++) printf("%d ", i + n0);
	}
	return 0;
}
```

---

## 作者：Zhao_daodao (赞：4)

# P11277 世界沉睡童话

### $k=0$

答案就是 $n,n+1,n+2,\dots,2n-2,2n-1$。

这一些数显然满足条件。

因为 $2\times n\ge 2n-1$，头一个数的两倍大于最后一个数，所以不会有倍数关系。

### $k\le n-1$

当前 $k$ 比较小。考虑一些分组的做法。

把 $a$ 分成若干组，组组之间没有倍数关系，组内的数全部相等。

设每一个组的数量为 $p_i$，一共有 $m$ 个组。

那么当前的答案就是：
$$
\sum\limits_{i=1}^{m}\binom{p_i}{2}
$$
每一个数可以取 $k=0$ 时候的数，根据上面的描述，组之间肯定没有倍数关系。

每一次二分出当前的最大的 $p_i$，使得 $\binom{p_i}{2}\le k$，然后填入 $p_i$ 个数。

### $k\le \frac{n(n-1)}{2}$

打表发现，每一个 `1` 有非常大的用处。

因为 $a$ 的顺序无关紧要，设前面 $x$ 个数都是 `1`。

每一个 `1` 都能跟后面的所有数产生贡献，所以当前的贡献为：
$$
(n-1)+(n-2)+\cdots+(n-x+1)+(n-x)\\
=\frac{(2n-1-x)x}{2}
$$
后面的 $n-x$ 个数产生 $k-\frac{(2n-1-x)x}{2}$ 的贡献就可以了。

如果你取到当前最大的 $x$，会发现，$k-\frac{(2n-1-x)x}{2}\le (n-x)-2$。

也就是，$k'\le n'-2$。再拼上 $k\le n-1$ 的做法就对了。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=2.5e5+5;
int n,k;
inline int S(int x){
    return (2*n-1-x)*x/2;
}
inline int C2(int x){return x*(x-1)/2;}
int ans[MAXN];
inline void solve(){
    int x=0;
    for(int i=0;i<=n;i++){
        if(S(i)<=k&&S(i+1)>k){
            k-=S(i);x=i;break;
        }
    }
    for(int i=1;i<=x;i++)ans[i]=1;
    int cnt=2*n-1,lin=x+1;
    while(k>0){
        int l=1,r=n,del=1;
        while(l<=r){
        	int mid=l+r>>1;
        	if(C2(mid)<=k){
        		l=mid+1,del=mid;
        	}else r=mid-1;
        }
        k-=C2(del);
        for(int i=lin;i<=lin+del-1;i++)ans[i]=cnt;
        lin+=del;cnt--;
    }
    if(lin<=n){
        for(int i=lin;i<=n;i++)ans[i]=cnt,cnt--;
    }
    for(int i=1;i<=n;i++)cout<<ans[i]<<" ";cout<<"\n";
}
signed main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    cin>>n>>k;solve();
}
```

---

## 作者：sLMxf (赞：3)

## Pro
构造序列 $a$，长度为 $n$，并使得序列有 $k$ 组倍数关系。

要求：$a_i\le 2n-1$。
## Sol
我们最好让这个序列有序，因为这样只有后面的数对前面的数有倍数关系。

首先我们发现，$n\sim 2n-1$ 中间是没有倍数关系的。

我们还发现，如果有 $k$ 个相同的数 $a$，它对答案的贡献为 $\dfrac{1}{2}k(k-1)$。

最后我们发现，在 $k$ 个 $1$ 的基础上，再添加一个 $k$，会增加 $n-k+1$ 组倍数关系。

我们发现特殊性质有一栏是这么写的：
> $k\le n-1$。

这说明我们可以在 $n\le k$ 时，将其缩小到范围 $k<n$。

这里使用性质 3，在前面疯狂添加 $1$，直到 $k<n$。

```cpp
while(n<=k+1&&n!=0)
{
	cout<<"1 ";
	n--;
	k-=n;
}
```

如果此时 $n=0$，可以直接 `return 0;` 了。

如果此时 $n>0$，因为 $k<n$，所以 $2k<2n-1$，也就是说如果我们可以从前往后填 $n,\cdots,n,n+1,\cdots$，从后往前填 $2n-1,2n-2,\cdots$，且不重复。

使用性质 2，一直枚举最大的 $p$ 使得 $\dfrac{1}{2}p(p-1)\le k$，然后填上 $p$ 个 $a$，再使 $a$ 加 $1$。初始 $a=1$。

最后 $k=1$ 的时候，从 $2n-1$ 开始，从后往前填即可。

以上全部运用了性质 3。

时间复杂度是 $O(n)$ 的。

```cpp
void ans(int n,int k)
{
	while(n<=k+1&&n!=0)
	{
		cout<<"1 ";
		n--;
		k-=n;
	}
	if(n<=0) return;
	int a=n,lst=n;
	while(k&&lst)
	{
		int sum=sqrt(k)*2;
		while(sum*(sum-1)/2>k)sum--; // 这里应该可以直接用数学推出来
		k-=sum*(sum-1)/2;
		for(int i=1;i<=sum;i++) cout<<a<<' ';
		lst-=sum,a++;
	}
	for(int i=2*n-1;lst;i--) cout<<i<<' ',lst--;
}
```

---

## 作者：normalpcer (赞：3)

## 分析
首先观察子任务 3，此时保证 $k=0$，所以只需保证对于数列中的任意两个数都互不被对方整除。

不难想到，取区间 $\left[n, 2n-1\right]$ 中的所有整数即可保证。

另外，我们可以再考虑把一个整数重复添加 $T$ 次。这种方法可以简单地产生 $a_T = \frac{T\left(T-1\right)}{2}$ 的贡献。在数列中添加若干个这样的重复区间，并且用上文的方法让它们之间互不影响，最后的贡献即为各自贡献的总和。

用这个方法可以表达出一段连续的整数，但是值域比较有限。我们可以通过在数列前面添加若干个 $1$ 来让后面的所有数均产生贡献，获得一个基本的值，然后用上文的策略逐步逼近到 $k$。

具体来讲，我们分为以下几个步骤。

首先，在开头填上若干个连续的 $1$，在 $i$ 处添加即可获得 $n-i$ 的贡献，直到当前贡献值恰好不大于 $k$。

接下来，我们在后面依次填上 $n, n+1, \dots$ 这些数。同样地，我们每次尽可能填多，如果贡献超过了 $k$ 再换下一个数往上加。

最后，贡献恰好为 $k$，只需在 $i$ 填充 $n+i-1$，不产生额外贡献。

## 证明
我们对这个方案的正确性做一个简单的证明。

首先考虑这一堆 $1$ 的贡献。假设有 $x$ 个 $1$，那么不难求出它们的贡献为 
$$w_1=\frac{\left(2n-x-1\right)x}{2}$$
并且一定有
$$\frac{\left[2n-\left(x+1\right)-1\right](x+1)}{2}>k$$
稍加推导可知
$$k-w_1 < n-x-1$$

也就是说，接下来我们只需要用不多于 $n-x$ 个数凑出一个至多为 $n-x-1$ 的整数。

我们用 $f\left(x\right)$ 表示需要用多少个额外的数凑出 $x$。于是可以写出如下的递推式：设 $a_{g\left(x\right)}$ 为最大的不大于 $x$ 的项，则当 $x\ge 3$ 时，有
$$f\left(x\right) = g\left(x\right)+f\left(x-g\left(x\right)\right)$$
另外， $f\left(0\right)=0, f\left(1\right)=2, f\left(2\right)=4$。

于是，不难发现，除非 $x=2$，均能保证 $f\left(x\right)\le x+1$。

接下来，特殊考虑 $x=2$。如果第一步放置的 $1$ 比较少，有足够的空间放下四个数，自然是可以的；如果只剩下了三个空位，只需要多填一个 $1$ 就正好产生 $2$ 的贡献，依旧符合题意。

所以目标范围内的所有整数都可以被凑出。

## 代码
```cpp
#include <bits/stdc++.h>
using ll = long long;

namespace Solution {

    int N;  const int _N = 250'005;
    ll K;

    int res[_N];
    auto current = 0LL;  // 当前的组数

    void solve() {
        std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
        std::cin >> N >> K;

        // 先添加一定数量的 1
        // 1 和后面的所有数之间必然会产生贡献，一直添到总和恰好小于 0
        auto i = 1;  // 添加数的指针
        for (i = 1; i <= N; i++) {
            auto del = N - i;  // 新增的贡献
            auto new_sum = current + del;
            if (new_sum > K)  break;
            res[i] = 1, current = new_sum;
        }

        // 向后添加一些连续的数，每一段都会产生一些贡献
        // 避免这些数之间互相影响，只需填充 N, N+1, N+2, ...
        // 直到满足 cur == K
        for (auto j = N; current < K; j++) {  // 接下来，填充若干个 j
            for (auto len = 1; ; len++) {  // 再填充一个新的
                auto new_sum = current + len - 1;
                if (new_sum > K)  break;
                res[i] = j, current = new_sum;
                i++;
            }
        }

        assert(current == K);

        // 剩下的随便填一下即可
        for (; i <= N; i++)  res[i] = N + i - 1;

        for (auto i = 1; i <= N; i++)  std::cout << res[i] << ' ';
        std::cout << std::endl;
    }
}


int main() {
    Solution::solve();
    return 0;
}
```

---

## 作者：OneLeft (赞：3)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/P11277)

## 思路
先从部分分开始考虑。

### $k=0$
当 $k=0$ 时，不存在一个数是另外一个数的的倍数，考虑到 $a$ 中的最大值不超过 $2n-1$，若我们输出 $n\sim 2n-1$，则刚好满足要求。

### $k\le n-1$
当 $k=0$ 时同上，而 $k=n-1$ 时我们输出 $1$ 和 $n\sim 2n-2$ 即可，接下来考虑 $1\le k<n-1$ 即可。

注意到若恰好有 $2$ 个相同的数 $x$ 且满足 $x\ge n$，则它们互相可以有 $1$ 对倍数关系，所以当 $k=1$ 或 $k=2$ 时，我们输出 $k$ 对相同的大于等于 $n$ 的数即可。同时可以发现若恰好有 $3$ 个相同的数 $x$ 且满足 $x\ge n$，则它们互相可以有 $3$ 对倍数关系，所以当 $k=3$ 时我们输出 $3$ 个相同的大于 $n$ 的数即可。

那要是 $k\ge 4$ 呢？我们可以输出 $\left\lfloor\frac{k}{3}\right\rfloor$ 次 $3$ 个相同的数（每次输出的数不能相同），这样就可以保证剩下的 $k\le 2$，再按照 $k\le 2$ 的方式输出即可。

### 正解
从上一个部分分我们已经可以知道一些与正解相关的解法了，接下来把上面的做法推广到 $k>n$ 即可。

当 $n-1\le k<(n-1)+(n-2)$ 时，我们可以先输出 $1$，因为后面的所有数必然是 $1$ 的倍数，所以必然构成 $n-1$ 对倍数关系，所以使 $k\gets k-(n-1)$，接下来按照 $k<n-1$ 的方式输出即可。

当 $(n-1)+(n-2)\le k<(n-1)+(n-2)+(n-3)$ 时，我们可以在上面的基础上再次输出 $1$，这个 $1$ 可以与后面的数构成 $n-2$ 对倍数关系，所以在上面的基础上再使 $k\gets k-(n-2)$，然后按照 $k<n-1$ 的方式输出。

从上面的处理方式我们可以发现，若 $k\ge\sum_{i=1}^nn-i$ 且此时的 $i$ 为满足条件的 $i$ 中最大的，则需要输出 $i$ 个 $1$，然后按照部分分的思路输出即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int ans[N];
signed main()
{
    int n,k;
    cin>>n>>k;
    int m=n-1,cnt=1,tot=0;
    while(cnt<=n&&k-n+cnt>=0)k-=n-cnt,cnt++,ans[++tot]=1;
    while(k>=3)
    {
        ans[tot+1]=ans[tot+2]=ans[tot+3]=++m;
        tot+=3,k-=3;
    }
    for(int i=1;i<=k;i++)ans[tot+1]=ans[tot+2]=++m,tot+=2;
    while(tot<n)ans[++tot]=++m;
    for(int i=1;i<=tot;i++)cout<<ans[i]<<' ';
    return 0;
}
```

---

## 作者：Exp10re (赞：3)

注意到本题与 [GDCPC 2024 个人赛 D](https://www.luogu.com.cn/article/e5fn9a7s) 使用同一类型的 Trick，上面点进去是私货。

说一下我赛时的解题思路。

## 解题思路

注意到若满足条件的数列 $a$ 存在，则将 $a$ 排序后的数列也满足条件。

打表可以发现答案可以是形如前面若干个 $1$ 加上后面若干个互相不为倍数的连续段，启发我们枚举 $1$ 的个数。

考虑对于一个满足形如前面若干个 $1$ 加上后面若干个互相不为倍数的连续段的数列的答案计算，发现满足条件的数对个数 $S$ 形如：

$$S=\frac {p(p-1)}{2}+n(n-p)+\sum \frac {c_i(c_i-1)}{2}$$

其中 $p$ 表示开头 $1$ 的个数，$c$ 表示每个连续段的长度。

这启发我们对 $x=K-(\frac {p(p-1)}{2}+n(n-p))$ 进行三角形数拆分，具体的：

- 若 $x\lt 0$，则不存在开头 $p$ 个 $1$ 的解。
- 否则，将 $x$ 拆分成个数尽可能少的三角形数 $^\dagger$，即拆分成 $\sum \frac {c_i(c_i-1)}{2}$ 的形式，若此时 $\sum c_i\leq n-p$，则表明我们找到了一组解。

$\dagger$：拆分 $x$ 考虑以下做法：每次找到一个最大的 $t$ 满足 $\frac {t(t-1)}{2}\leq x$，然后拆分 $x-\frac {t(t-1)}{2}$ 直到其为 $0$，可以发现 $t$ 的值接近 $\sqrt x$，在这附近寻找即可。容易证明 $x-\frac {t(t-1)}{2}$ 大概是 $O(\sqrt x)$ 规模的，故递归的次数不会超过 $O(\log \log x)$。

得知 $c$ 的取值以及 $p$ 的值之后，解是好构造的，不多赘述。

由此枚举每一个 $p$ 判断是否有解即可。时间复杂度 $O(n\log\log n)$。

## 代码

提供一个三角形拆分的实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=1010100;
long long n,K,a[MAXN];
bool exist(long long x,long long lim)
{
	long long cnt=0,p;
	while(x>0)
	{
		p=sqrt(x*2);
		p+=2;
		while(p*(p-1)/2>x)
		{
			p--;
		}
		cnt+=p;
		x-=p*(p-1)/2;
	}
	return cnt<=lim;
}
void work(long long x,long long lim)
{
	long long M=n*2;
	long long p,mp=n,lst;
	while(x>0)
	{
		p=sqrt(x*2);
		p+=2;
		while(p*(p-1)/2>x)
		{
			p--;
		}
		lst=mp;
		M--;
		for(;mp>=lst-p+1;mp--)
		{
			a[mp]=M;
		}
		x-=p*(p-1)/2;
	}
	while(mp>n-lim)
	{
		M--;
		a[mp]=M;
		mp--;
	}
	while(mp>0)
	{
		a[mp]=1;
		mp--;
	}
	return;
}
int main()
{
	long long p,i;
	scanf("%lld%lld",&n,&K);
	for(p=n;p>=0;p--)
	{
		if(p*(p-1)/2+p*(n-p)<=K)
		{
			if(exist(K-p*(p-1)/2-p*(n-p),n-p))
			{
				work(K-p*(p-1)/2-p*(n-p),n-p);
				for(i=1;i<=n;i++)
				{
					printf("%lld ",a[i]);
				}
				return 0;
			}
		}
	}
	printf("I Love Segtree Forever.");//But this can never be print.
	return 0;
}
```

---

## 作者：AN6M (赞：3)

首先我们能想到一个简单的构造方法：

- 几个相同的数单独的贡献是 $C_{个数}^2$。

- $1$ 和任何数都能产生贡献。

于是我们可以枚举 $1$ 的个数。

根据人类直觉，$1$ 的个数应该靠近 $n$ 或 $0$。

于是我们可以枚举 $0$ 到 $50$ 和 $n-50$ 到 $n$。

然后其他的数可以从 $2n-1$ 开始试，不会有倍数关系。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define N 250010
const int P = 998244853, p = 998244353, bass = 13331;
int t, n, k, biao[N], ans[N * 2];
signed main()
{
    cin >> n >> k;
    for (int i = 1; i <= 250000; i++)
    {
        biao[i] = i * (i - 1) / 2;
    }
    int now = n * 2 - 1, p = n, tmp = n, tot = 0, tp = k, K = k, NN = n;
    if (n > 10000)
    {
        for (int i = 0; i <= 50; i++)
        {
            tot = 0;
            k = K - i * (NN - i) - biao[i];
            n = NN - i;
            tmp = n;
            p = n;
            now = NN * 2 - 1;
            // cout << n << ' ' << k << endl;
            while (k || (!k && (tmp > 0)))
            {
                while (biao[p] > k && p)
                {
                    p--;
                }
                if (biao[p] <= k)
                {
                    k -= biao[p];
                    tmp -= p;
                    for (int j = 1; j <= p; j++)
                    {
                        ans[++tot] = now;
                    }
                    now--;
                }
            }
            // cout << i << " " << tot << endl;
            if (tot == n)
            {
                for (int j = 1; j <= tot; j++)
                {
                    cout << ans[j] << ' ';
                }
                for (int j = 1; j <= i; j++)
                {
                    cout << 1 << " ";
                }
                return 0;
            }
        }
        for (int i = NN - 50; i <= NN; i++)
        {
            tot = 0;
            k = K - i * (NN - i) - biao[i];
            n = NN - i;
            tmp = n;
            p = n;
            now = NN * 2 - 1;
            // cout << n << ' ' << k << endl;
            while (k || (!k && (tmp > 0)))
            {
                while (biao[p] > k && p)
                {
                    p--;
                }
                if (biao[p] <= k)
                {
                    k -= biao[p];
                    tmp -= p;
                    for (int j = 1; j <= p; j++)
                    {
                        ans[++tot] = now;
                    }
                    now--;
                }
            }
            // cout << i << " " << tot << endl;
            if (tot == n)
            {
                for (int j = 1; j <= tot; j++)
                {
                    cout << ans[j] << ' ';
                }
                for (int j = 1; j <= i; j++)
                {
                    cout << 1 << " ";
                }
                return 0;
            }
        }
    }
    else
    {

        for (int i = 0; i <= NN; i++)
        {
            tot = 0;
            k = K - i * (NN - i) - biao[i];
            n = NN - i;
            tmp = n;
            p = n;
            now = NN * 2 - 1;
            // cout << n << ' ' << k << endl;
            while (k || (!k && (tmp > 0)))
            {
                while (biao[p] > k && p)
                {
                    p--;
                }
                if (biao[p] <= k)
                {
                    k -= biao[p];
                    tmp -= p;
                    for (int j = 1; j <= p; j++)
                    {
                        ans[++tot] = now;
                    }
                    now--;
                }
            }
            // cout << i << " " << tot << endl;
            if (tot == n)
            {
                for (int j = 1; j <= tot; j++)
                {
                    cout << ans[j] << ' ';
                }
                for (int j = 1; j <= i; j++)
                {
                    cout << 1 << " ";
                }
                return 0;
            }
        }
    }
    return 0;
}
```

---

## 作者：_lmh_ (赞：2)

拿到这道题可能会想到各种奇奇怪怪的构造方法，但大部分都没法搞出 $k$ 略小于 $\frac{n(n-1)}{2}$ 的情况。

注意到 $n$ 个相同的数可以凑出 $\frac{n(n-1)}{2}$ 个对子，而 $[n,2n-1]$ 任意两个整数都没法凑出整除关系，考虑把两个方法结合在一起。

找到最大的 $m(m-1)<2k$（特判 $k=0$）。

令 $p=[\frac{2n-1}{3}]$，在前 $m$ 个数当中放 $k-\frac{m(m-1)}{2}$ 个 $p$，剩下的放 $2p$，再额外放一个 $3p$，手算一下会发现这样就满足条件。

然后剩下的从 $2n-1$ 往 $n$ 一路排下来就行，注意把 $p$ 的两个倍数跳过去。已经放了 $m+1\ge2$ 个数，剩下 $\le n-2$ 个数足够放进这些空位里面。

有个小问题就是 $n$ 非常小的时候这么放会爆掉（$p=1$），记得拼一个暴力。

```cpp
//Happy Birthday, Ling Luo!
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=250007;
ll n,a[N],k,m;
bool ok[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>k;
//	initPrime(n);
	ll o=(2*n-1)/3;
	if (n<=5){
		for (int i=1;i<=n;++i) a[i]=1; 
		while(1){
			ll sum=0;
			for (int x,y,i=1;i<=n;++i) for (int j=i+1;j<=n;++j){
				x=a[i];y=a[j];
				if (x>y) swap(x,y);
				sum+=(y%x==0);
			}
			if (sum==k){
				for (int i=1;i<=n;++i) cout<<a[i]<<' ';cout<<endl;return 0;
			}
			ll i=1;
			while(a[i]==2*n-1) a[i++]=1;
			++a[i];
		}
	}
	if (k==0){
		for (int i=n;i<=2*n-1;++i) cout<<i<<' ';cout<<endl;return 0;
	}
	m=2;
	while(m*(m-1)/2<k) ++m;
	ll p=k-(m-2)*(m-1)/2;
	for (int i=1;i<=p;++i) a[i]=o;
	for (int i=p+1;i<m;++i) a[i]=o*2;
	a[m]=o*3;
	p=2*n-1;
	for (int i=m+1;i<=n;++i){
		while(p==o*3||p==o*2) --p;
		a[i]=p--;
	}
	for (int i=1;i<=n;++i) cout<<a[i]<<' ';cout<<endl;
	return 0;
}
```

---

## 作者：taiyuu (赞：2)

① $k=0$，这启发我们在 $[1,2n-1]$ 中找到 $n$ 个数，并且任意两个不能够构成倍数关系，思考易得选取 $n,n+1......2n-1$ 共 $n$ 个数。

② $k=\frac{n(n-1)}{2}$，显然这n个数应该为同一个数。

③ $k\leq n-1$，联想 $k=0$、$k=\frac{n(n-1)}{2}$ 的情况，我们是否可以令 $n$ 个数先取 $n,n+1......2n-1$，然后改变其中的某些数令其相等，来拼凑出符合要求的数对？答案是可以的，用数学归纳法：

任意 $k=n-1$ 的情况，我们都可以令其中一个数变为 1，其余数之间仍保持没有倍数关系即可。接下来只需要讨论 $k<n-1$ 的情况能否顺利构成。

当 $n\le 4$时，容易构造出合法数组。

假设 $n=x$，$k<x-1$ 都成立，当 $n=x+1$，$k<x-1$ 时，只需要令新增加的一个数与 $n=x$ 时构成的数组间都没有倍数关系即可，由于n变大了，这样的数显然存在；而对于 $n=x+1$，$k=x-1$，我们先令其中的 3 个数相等，此时构成了 3 个合法数对，我们还剩 $x-2$ 个数需要构 $x-4$ 个数对，此时一定在不借助1的情况下可以完成。（当然这里的构造方式有很多种，也可以用更多的相同的数，一次性构造更多的合法数对。）

综上，得证。

④最后讨论一般情况，根据③的结论，我们可以每次先令其中的一个数变成 1 ，则问题会转化为 $n=n-1$，$k=k-(n-1)$ 的问题，如此递归下去，直到 $k\le n-1$ 为止，问题得到解决。


```cpp
#include<bits/stdc++.h>
using namespace std;
int re(){
	int num=0,fl=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') fl=-1;ch=getchar();}
	while(isdigit(ch)){num=num*10+ch-'0';ch=getchar();}
	return num*fl;
}
const int N=3e5+100;
int n,a[N],b=1;
long long k;
int main(){
	cin>>n>>k;
	if(k==0){
		for(int i=n;i<=2*n-1;++i)	cout<<i<<" ";
	}
	else{
		int nn=n;
		while(nn&&k>=nn-1){
			a[nn--]=1;k-=nn; 
		}
		while(nn>=4&&k>=3){
			a[nn]=a[nn-1]=a[nn-2]=2*n-b;
			++b,k-=3,nn-=3;		
		}
		if(k==2)	a[nn]=a[nn-1]=2*n-b,++b,nn-=2,--k;
		if(k==1)	a[nn]=a[nn-1]=2*n-b,++b,nn-=2,--k;
		while(nn>0)	a[nn]=2*n-b,++b,--nn;
		for(int i=1;i<=n;++i)	cout<<a[i]<<" ";
	}
	return 0;
}

```

---

## 作者：Polarisx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11277)。

## 思路

部分分提示已经很明显了。

- 对于 $k=0$ 的部分，输出 $[n,2n-1]$ 中的数即可。

- 对于 $k=n-1$ 的部分，先输出 $n-1$ 个互不整除的数，再输出一个 $1$ 即可。

- 对于 $k<n-1$ 的部分，假设一个数在该序列里出现了 $c$ 次，那么它的贡献为 $\frac{c(c-1)}{2}$，考虑继续构造若干个互不整除的数 $i$，出现次数为 $b_i$，那么 $\sum b_i=n,\sum \frac{b_i(b_i-1)}{2}=k$，数学归纳法可以得到这是一定存在解的，对于每个 $i$，枚举其 $b_i$，直到 $(b_i+1)b_i>2k$，此时将 $k$ 减去 $b_i$ 的贡献即可。

- 对于 $k\ge n$ 的情况，我们不妨加上若干个 $1$，第 $i$ 个 $1$ 的贡献为 $n-i$，不难发现这是该数最大的贡献，接下来减到 $k<n$ 的情况，在套用上述算法即可。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=1e6+7,N=1e6;
inline void solve(int n,ll k){
    for(int i=n-1;i;i--){
        if(k>=n) k-=i,cout<<1<<' ',n--;
        else break;
    }
    if(!k){
        for(int i=2*n-1;i>=n;i--){
            cout<<i<<" ";
        }
        return ;
    }
    if(k==n-1){
        for(int i=2*n-1;i>n;i--) cout<<i<<' ';
        cout<<1;
        return ;
    }
    if(k<n-1){
        int c=0;
        for(int i=2*n-1;c<n;i--){
            int p=__builtin_sqrt(k);
            for(ll j=p;j<=n+1;j++){
                if(j*(j-1)/2>k){
                    j--;
                    for(int p=1;p<=j;p++) cout<<i<<" ",c++;
                    k-=j*(j-1)/2;
                    break;
                }
            }
        }
        return ;
    }

}

int n;ll k;

int main(){
    cin>>n>>k;
    solve(n,k);    

    system("pause");
    return 0;
}
```

---

## 作者：I_am_Lord_Voldemort (赞：1)

我们拿到题的时候，首先考虑暴力。作为一名没有实力的蒟蒻，我选择打表五分……

在打表的过程中，我尝试自己构造。我们发现：每放一个 $1$ ，可以提供 $n-sum1$ 的贡献，即 $n-1,n-2,n-3$……因此我们考虑多放几个。之后再放什么呢？

在打表的过程中，我发现：有 $k$ 个相同的数，在互不干扰的前提下，可以造成 $(k-1) \times k /2 $ 的贡献。因为不好统计，我们不妨令除了一以外的数互不为倍数，即从 $n$ 到 $2n - 1$。我们根据 $k$ 的个数考虑要几个相同的数，如果已经满足就只放一个。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
	int n,k,tot;
	cin>>n>>k;tot=n;
	while(n&&k>=(n-1)) cout<<1<<" ",k-=(n-1),n--;
	while(n){
		int i;for(i=1;i<=n;i++) if((i+1)*i/2>k) break;
		for(int j=1;j<=i;j++) cout<<tot<<" ";
		tot++;k-=(i-1)*i/2;
		n-=i;
	}
}
```

---

## 作者：SFlyer (赞：1)

首先我们可以添加若干个 $1$ 使得 $k\le n-2$。

发现 $n\le x\le 2n-1$ 的数互相不整除，因此我们可以全部用他们。剩余的位置中，我们可以填入若干个“$\binom{x}{2}$”，发现重复 $1,2,3$ 次就可以满足。证明考虑 $2$ 个一样的贡献 $1$，$3$ 个一样的贡献 $3$，最多用两个 $2$（$\bmod \ 3$），如果 $1$ 个一样的啥贡献都没有（当作填满数组的）。显然不会用多于 $2n-1-n+1=n$ 个数。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

const int N = 2.5e5+5;

void sol(int n,int k,int mx){
	for (int i=3; i>1; i--){
		int c=i*(i-1)/2;
		if (k>=c){
			int m=k/c;
			for (int j=1; j<=m; j++){
				for (int l=1; l<=i; l++) cout<<mx<<" ";
				mx--;
			}
			n-=m*i;
			k-=m*c;
		}
	}
	for (int i=1; i<=n; i++){
		cout<<mx<<" ";
		mx--;
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);

	ll n,k;
	cin>>n>>k;
	int tot=4*n,j=n+1;
	for (int i=1; i<=n; i++){
		if (k>=n-i){
			cout<<1<<" ";
			k-=n-i;
		}
		else{
			j=i;
			break;
		}
	}
	sol(n-j+1,k,2*n-1);
	return 0;
}
```

---

## 作者：RAND_MAX (赞：1)

部分分对正解很有启发啊。

先思考 $k<n$ 的部分分，由于 $k$ 比较小，考虑构造相等的数并使不同的数相互没有倍数关系，容易发现在区间 $[n,2n-1]$ 内两两均无倍数关系。一个相等的数的贡献为 0，两个相等的数贡献为 1，三个相等的数贡献为 3。只需将 $k$ 通过若干组两个相等的数变为 3 的倍数后用若干组三个相等的数变成 0，剩下用若干个不同的数产生 0 的贡献填充即可。不过还需特判 $k=n-1$ 的情况，此时只需在前面放一个 1，剩下 $n-1$ 位放不同的在 $[n,2n-1]$ 内的数即可。

对于 $k\ge n$ 的情况，与  $k=n-1$ 类似，在序列前面不断加入 1，此时会产生 $n-1$ 的贡献故将 $k$ 减去 $n-1$，序列长度 $n$ 减一。直到 $k<n$ 再进行与部分分相同的操作即可。

代码实现细节不多，若最后的 $n\le5$ 可以拼上搜索的部分分，更为保险。


```cpp
#include<bits/stdc++.h>
#define int long long
#define R read()
using namespace std;
int n,k,a[1000100],num;
void check()
{
	int su=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(max(a[i],a[j])%min(a[i],a[j])==0) su++;
		}
	}
	if(su==k)
	{
		for(int i=1;i<=num;i++) cout<<"1 ";
		for(int i=1;i<=n;i++) cout<<a[i]<<" ";
		exit(0);
	}
}
void dfs(int x)
{
	if(x>n) check();
	else for(int i=1;i<=2*n-1;i++) a[x]=i,dfs(x+1);
}
void solve()
{
	if(n<=5) dfs(1);
	if(!n) return;
	if(n-k==1)
	{
		a[1]=1;
		int num=n;
		for(int i=2;i<=n;i++) a[i]=++num;
		return;
	}
	int num=n,i=1;
	while(k%3) a[i++]=num,a[i++]=num,k--,num++;
	for(int j=1;j<=k/3;j++) a[i++]=a[i++]=a[i++]=num++;
	for(i;i<=n;i++) a[i]=num++;
}
signed main()
{
	cin>>n>>k;
	if(n<=0) dfs(1);
	else
	{
		while(k>=n) num++,n--,k-=n;
		solve();
		for(int i=1;i<=num;i++) cout<<"1 ";
		for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	}
 	return 0;
}
```

---

## 作者：gcx12012 (赞：1)

### 前言
当你做构造没有思路的时候可以先写个爆搜来寻找思路。
### Solution
首先我们注意一下 $a_i$ 的值域是 $[1,2n-1] \cap \N $，然后我们发现：值域在 $[n+1,2n-1]$ 内的整数不存在倍数对。

然后我们思考一下 $k\le n-1$ 时怎么做，考虑当前有 $p$ 个相同的数，那么其倍数对的个数为 $\frac{p(p-1)}{2}$。

所以对于这部分数据我们可以贪心的构造出 $p$ 最大的方案，然后一直累减 $k$ 即可。

事实上，当你会这一部分分时，正解也就不难想了。考虑 $1$ 是任何数的倍数，因此我们只需要加上一段前缀 $1$，接着考虑 $k\le n-1$ 的构造即可。

因为倍数对个数与数列顺序无关，所以构造的顺序可以随意钦定，我这里钦定数列单调不降。
### Code

```cpp
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
#define lll __int128
#define ull unsigned long long
#define N 500010
#define For(i,a,b) for(int i=a;i<=b;++i)
#define Rof(i,a,b) for(int i=a;i>=b;--i)
#define ls x<<1
#define rs x<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r 
#define pb push_back
#define mk make_pair
#define pque priority_queue
#define pii pair<int,int>

using namespace std;
bool st;
int a[N];
ll n,k;
bool ed;

ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

int main()
{
	//fprintf(stderr,"%d",(&ed-&st)/1024/1024);
	//freopen("2.in","r",stdin);
	//freopen("2.out","w",stdout);
	n=read(),k=read();
	ll p=n-1;
	int l=n+1,r=n;
	For(i,1,n){
		if(k>=p) k-=p,a[i]=1,p--;
		else{
			l=i;
			break;
		}
	}
	int now=2*n-1;
	while(l<=r){
		int len=1;
		while(len*(len+1)/2<=k) len++;
		k-=len*(len-1)/2;
		while(len--){
			a[r]=now;
			r--;
		}
		now--;
	}
	For(i,1,n) printf("%d ",a[i]); 
	return 0;
}
/*

*/
```

---

## 作者：Cl41Mi5deeD (赞：1)

部分分对正解有较大提示作用，故从其入手。

### $k\le 0$

注意题目给的 $a_i$ 的值域是 $[1,2n-1]$，考虑构造一个值域在 $[n,2n-1]$ 的不重复的序列，易得在这一段的元素两两不存在倍数关系。

### $k\le n-1$

等于的情况在上一问解决的情况下是容易的，更改其中一个元素为 $1$ 即可。小于的情况见下文。

### $k\le \frac{n(n-1)}{2}$

为了方便现在让上文那个序列是递增的，考虑从前向后逐个将元素改为 $1$。因为每将一个 $a_i$ 修改为 $1$ 就会向后提供 $(i,i+1)...(i,n)$ 共 $n-i$ 对答案，进而一定存在一种状况即某一次修改完 $a_i$ 后剩下需补足的的答案 $k'$ 满足 $0\le k'\le n-(i+1)$。

这时更改先前操作过的 $1$ 应该会把问题复杂化，考虑如何调整后面的序列使得正好额外凑出 $k'$ 个答案。

这时说一下考场上开始想到的错解，因为序列是递增的则必然为一奇一偶的形式，此时修改一个 $1$ 会超过所需的答案，不妨将现在扫描到的数改为 $2$，就会新增之后的偶数个答案约 $\frac{n-i}{2}$ 个。显然可能不足，于是再考虑先前替换了的 $i$ 个元素应当也有约 $\frac{i}{2}$ 个，将后面的奇数逐个替换直到补足。

问题在于 $n-i\ge k'\ge \frac{n}{2}$ 时是补不回来的。考虑修改这个做法，错点在于一个一个补对答案的贡献太慢了，那就考虑将后面的一段长为 $i$ 的子段集体替换成一个于 $[n,2n-1]$ 内的数 $x$，这段相同的数对答案的贡献是 $\binom{i}{2}$。增长速度是足够的。

但是有潜在的正确性问题，需要解决一个形如“能否用 $x$ 个元素通过分组后两两组合的形式表示出所有小于 $x$ 的数”的证明，否则一定存在一个 $k'$ 是无法表示的。我没有尝试证明但在赛后写了一个 dp 验证，发现都可以表示，应该是没问题了。


```cpp
	dp[0][0]=1;
	for(int i=2;i<MAXN;i++){
		for(int j=0;j<MAXN-1;j++){
			for(int l=2;l<=i;l++){
				if(!dp[i-l][j])continue;
				if(j+l*(l-1)/2>MAXN)break;
				dp[i][j+l*(l-1)/2]=1;
			}
		}
	} //dp长这个样子
```

以下是代码。


```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 250005
using namespace std;
int n,k;
int ans[MAXN<<1],s=1;
signed main(){
	scanf("%lld%lld",&n,&k);
	if(!k){
		for(int i=n;i<=2*n-1;i++)printf("%lld ",i);
		return 0;
	}
	for(int i=1;i<=n;i++)ans[i]=i+n-1;
	while(k>=n-s&&s<=n){
		ans[s]=1;
		k-=n-s;
		++s;
	}
	if(!k){
		for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
		return 0;		
	}
	int val=0;
	for(int i=s,lst=0;i<=n;i++){
		if(lst&&k+(val*(val-1)/2)-(val*(val+1)/2)>=0){
			ans[i]=lst;
			k+=(val*(val-1)/2)-(val*(val+1)/2);
			++val;
			continue;
		}
		else if(lst&&k+(val*(val-1)/2)-(val*(val+1)/2)<0)lst=val=0;
		if(ans[i]%2==0){
			lst=ans[i];
			val=1;
		}
		if(!k)break;
	}
	for(int i=1;i<=n;i++)printf("%lld ",ans[i]);
	return 0;
}
```

---

## 作者：keatsli (赞：1)

神秘的赛时做法，可能会被 `hack`，不过有一定借鉴价值。

注意到 $[n,2n-1]$ 之间的所有数都没有互相的整除关系，所以考虑多次重复一个数来得到恰好 $k$ 个题目描述的对。

于是，一个数重复 $k$ 次的贡献即为 $C_k^2=\frac{k(k-1)}2$。

但是这样会有几个点错误，我们观察第一个样例可以发现它假了，但是如果我们预先加入一个 $1$ ，并单独计算贡献就可以通过第一个样例。

于是我们又交一发，发现还是错误几个点。

我们考虑模仿这个思路，预先加入 $i$ 个 $1$，然后单独统计贡献（贡献即为 $C_i^2+i(n-i)$，因为每个 $1$ 会整除后面我们加的所有数，$1$ 之间还有整除关系），这样我们就通过了。

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500010];
long long cnt,cnt1;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	long long n,k,nwcnt=0;cin>>n>>k;
	for(long long i=n;i>=0;--i){
		if(k>=(n-i)*i+i*(i-1)/2){
			k-=(n-i)*i+i*(i-1)/2;
			while(i--)a[++cnt1]=1;
			break;
		}
	}
	for(long long i=n;i<=2*n-1;++i){
		long long cnt=0;
		while(nwcnt+cnt<=k)nwcnt+=cnt++,a[++cnt1]=i;
	}
	for(int i=1;i<=n;++i)cout<<a[i]<<' ';
	cout<<'\n';
	return 0;
}
```

---

## 作者：formu1 (赞：1)

### 题意
~~题面已经说的很清楚了 qwq。~~
### 思路
因为构造序列所需的要求是对若干个数对判断条件，而改变数的顺序是不会影响数对的判断的，所以数列排序可以随意变换。

当 $k=0$ 时，很明显的做法就是直接输出 $n$ 到 $2n-1$ 的序列，这样子的话，因为没有重复，所有 $a_i$ 都不会有 $1$ 倍 $a_i$ 的贡献，同时，$2$ 倍 $a_i$ 的贡献是从 $2n$ 到 $4n-2$，序列中的值域到不了，所以没有贡献。

进一步，可以发现若所有的 $a_i \geq n$，将只会产生 $1$ 倍 $a_i$ 的贡献，即只会产生相等的贡献。

这个规则将用于以下构造。


---


考虑接下来的 $k \leq n-1$。

有一种想法就是可以先将数列设成 $n$ 到 $2n-1$ 的递增排列，如果将一个数 $a_i$ 修改成其它原有的数 $x$，它就会产生“修改前 $x$ 的个数”的贡献。

比如下面的序列：
```
7
7 8 9 10 11 12 13
```

如果将第二个的 $8$ 改为 $7$，它会产生 $1$ 的贡献。

再如，如果继续将 $9$ 改为 $7$，它会产生 $2$ 的贡献。

容易发现，这样修改下去，第 $i$ 次修改所产生的贡献就是 $i$。

然后，如果总共按照这种方式修改 $m$ 次，它所产生的贡献是 $\frac{m\times (m+1)}{2}$。

这样做虽然确实不错，但带来了一个严重的问题，有些个数的贡献是表示不到的，那么如何表示这些次数？

下面有个例子：
```
7
7 7 7 10 11 12 13
```

现在已产生的贡献是 $3$，如何将其抬到 $4$？

我们可以 $10$ 和 $11$ 改成两个 $10$，这样子的话，两个 $10$ 会一共产生 $1$ 的贡献。

所以说，我们有一种做法如下：

1. 若需求贡献次数为 $k$，我们需要在前 $m$ 位将尽量多的贡献次数完成，即需要最大的 $m$，满足 $\frac{m\times (m+1)}{2}\leq k$，可以证明，这样的前 $m$ 位所产生的贡献是极大（最多）的。（修改后的数全部大于等于 $n$ 的情况下）
2. 如果在上一个操作中有若干贡献未完成，可以从 $m+1$ 开始，重复第一个操作，直到贡献全部实现。


---


到了接下来的 $k\leq \frac{n(n-1)}{2}$。

我们考虑另一种构造方式，因为如果全部按照上面，会有一些情况，$n$ “太短”。

比如：`7 8 9 10 11 12 13`，如果要贡献 $12$ 次，那就没办法了。

这时候，有一种方式。比如，如果将以上的第 $1$ 位修改成 $1$，将会产生 $n-1$ 的贡献（因为任意数都是 $1$ 的倍数），若继续将第 $2$ 位修改成 $1$，将会产生 $n-2$ 的贡献——若继续将第 $i$ 位修改成 $1$，将会产生 $n-i$ 的贡献。

这就好办了。还是上面的例子，只要我修改次数 $\geq 6$ 次，不管如何，我先在第 $1$ 位怼个 $1$，$6$ 个贡献就搞定了。再在第 $2$ 位怼个 $1$，$5$ 个贡献就搞定了，接下来只需要从第 $3$ 位开始重复前面的操作就可以了。

所以最终操作方法如下：

1. 如果当前是第 $i$ 位，考虑能否将这一位替换成 $1$，产生 $n-i$ 的贡献，并重复这一条，考虑下一位。
2. 使用第一个方法完成上一条完不成的。

实际上下面的代码中我针对 $n\leq 6$ 的情况进行了打表，所以可能会有一点恶心，请谅解。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5e5+5;
ll n,k;
ll sum=0,i;

void in_six(){
	ll a=2*n-6,b=2*n-5,c=2*n-4,d=2*n-3,e=2*n-2,f=2*n-1;
	ll shengyu=k-sum;
	if(shengyu==0) printf("%lld %lld %lld %lld %lld %lld ",a,b,c,d,e,f);
	else if(shengyu==1) printf("%lld %lld %lld %lld %lld %lld ",f,b,c,d,e,f);
	else if(shengyu==2) printf("%lld %lld %lld %lld %lld %lld ",f,b,b,d,e,f);
	else if(shengyu==3) printf("%lld %lld %lld %lld %lld %lld ",a,a,a,d,e,f);
	else if(shengyu==4) printf("%lld %lld %lld %lld %lld %lld ",a,a,a,d,d,f);
	else if(shengyu==5) printf("%lld %lld %lld %lld %lld %lld ",1,b,c,d,e,f);
	else if(shengyu==6) printf("%lld %lld %lld %lld %lld %lld ",a,a,a,d,d,d);
	else if(shengyu==7) printf("%lld %lld %lld %lld %lld %lld ",1,a,a,d,d,f);
	else if(shengyu==8) printf("%lld %lld %lld %lld %lld %lld ",1,a,a,a,e,f);
	else if(shengyu==9) printf("%lld %lld %lld %lld %lld %lld ",1,1,c,d,e,f);
	else if(shengyu==10) printf("%lld %lld %lld %lld %lld %lld ",1,1,c,c,e,f);
	else if(shengyu==11) printf("%lld %lld %lld %lld %lld %lld ",1,1,c,c,e,e);
	else if(shengyu==12) printf("%lld %lld %lld %lld %lld %lld ",1,1,1,d,e,f);
	else if(shengyu==13) printf("%lld %lld %lld %lld %lld %lld ",1,1,1,d,d,f);
	else if(shengyu==14) printf("%lld %lld %lld %lld %lld %lld ",1,1,1,1,e,f);
	else if(shengyu==15) printf("%lld %lld %lld %lld %lld %lld ",1,1,1,1,1,1);
}//对填充1剩余6位时的打表讨论
void two(){
	if(k==1) printf("1 1");
	else printf("2 3");
}//对只有2位时的讨论
void three(){
	if(k==3) printf("1 1 1");
	else if(k==2) printf("1 2 3");
	else if(k==1) printf("2 2 3");
	else if(k==0) printf("3 4 5");
}//对只有3位时的讨论
void four(){
	if(k==6) printf("1 1 1 1");
	else if(k==5) printf("1 1 4 5");
	else if(k==4) printf("1 4 4 5");
	else if(k==3) printf("1 3 4 5");
	else if(k==2) printf("4 4 6 6");
	else if(k==1) printf("4 5 6 6");
	else if(k==0) printf("4 5 6 7");
}//对只有4位时的讨论
void five(){
	if(k==10) printf("1 1 1 1 1");
	else if(k==9) printf("1 1 1 4 5");
	else if(k==8) printf("1 1 4 5 5");
	else if(k==7) printf("1 1 5 6 7");
	else if(k==6) printf("1 5 5 7 7");
	else if(k==5) printf("1 5 5 7 8");
	else if(k==4) printf("1 5 6 8 9");
	else if(k==3) printf("5 5 5 8 9");
	else if(k==2) printf("5 5 7 7 9");
	else if(k==1) printf("5 5 7 8 9");
	else if(k==0) printf("5 6 7 8 9");
}//对只有5位时的讨论
void solve(ll nowpos,ll nowk,ll st){
	//第一种方式
	//nowpos是现在递归所至少需要的位置
	//nowk是剩下还有多少贡献需要完成
	//st是当前填的数字，只需从n开始即可
	if(nowk==0){
		ll j=0;
		for(int i=nowpos;i<=n;++i){
			printf("%lld ",st+j);
			++j;
		}
		//如果已经完成了，直接输出递增序列就可以了
		return;
	}
	ll ssum=0;
	for(i=1;i<=n;++i){
		ssum+=i;
		if(nowk<ssum) break;
		printf("%lld ",st);
		++nowpos;
	}
	printf("%lld ",st);
	++nowpos;
	solve(nowpos,nowk-(ssum-i),st+1);
}
int main(){
	scanf("%lld%lld",&n,&k);
	if(n==1) printf("1");
	else if(n==2) two();
	else if(n==3) three();
	else if(n==4) four();
	else if(n==5) five();
	else{
		for(i=n-1;i>=6;--i){
			sum+=i;
			if(k<sum) break;
			printf("1 ");
		}
		//先尽量放1，放不动了，或者需要在6以内分类讨论了，就退出
		if(i<6) in_six();
		else solve(n-i,k-(sum-i),2*n-1-i);
	}
	return 0;
}
```
### 证明
![](https://cdn.luogu.com.cn/upload/image_hosting/holh1v7t.png)
对于长度 $x > 1$ 的序列，可以至少通过第一种方式完成 $x-1$ 次贡献（你管那一小点凸出来的干什么又取不到非整数）。

能用吗能用吗 awa。

---

## 作者：_WRYYY_ (赞：0)

[在我的博客观看。](https://www.cnblogs.com/wryyy-233/p/18547294)

比较简单的构造。

注意到题面给出 $a_i\le 2n-1$ 的条件，考虑这个有什么用，你会发现从 $n$ 到 $2n-1$ 这 $n$ 个数都是两两互不为约数，所以当我们构造出序列后，这些数可以用来填补空位。

$k$ 的上界是 $\frac{n(n-1)}{2}$，显然在全部都为同一个数的时候取到，显然有 $x$ 个数相同的时候，这 $x$ 个数至少产生 $\frac{x(x-1)}{2}$ 的贡献，那我们是否可以利用这个性质来构造出一个合法序列呢？当然是可以的。

首先给出这样一个性质，当我们取到的数为 $y$ 的时候，只由一些 $y$ 和一些 $dy$（$d$ 为常数）组成的可重集 $S$，和只由一些 $y$ 组成的可重集 $T$，若 $|S|=|T|$，那么这两个产生的贡献是相等的，可以通过找规律或者灵光一现知道这件事。证明的话就是两种集合内部都是任意两种元素都可以自由握手的，所以方案数在集合大小相等时显然相等。

我们接着想，自由握手是相等的，那么再加入一个不能自由握手的元素呢？以 $y,2y,3y$ 为例子，分别有 $x_1,x_2$ 个 $y,2y$，总和为 $x$，如果加入 $1$ 个 $3y$，最终产生的贡献就会是 $\frac{x(x-1)}{2}+x_1$，总和不变的情况下，将 $x_1$ 取遍 $[0,n)$ 的话我们可以做到贡献取遍 $[\frac{x(x-1)}{2},\frac{(x+1)x}{2})$，那么由不同的 $x$ 以及 $x_1$ 取值，以及是否加入 $3y$，贡献就可以取遍 $[0,\frac{n(n-1)}{2}]$，空位直接由 $n$ 到 $2n-1$ 中没被取的填上。

具体地就是找到最大的满足 $\frac{x(x-1)}{2}\le k$ 的 $x$，然后按上述构造法构造。

为了不产生额外的贡献，我们最优的取法显然是取 $\lfloor\frac{2n-1}{3}\rfloor$ 作为 $y$，这样是它倍数的数一般只有 $2$ 个，可以做到与其他数不产生贡献。为什么是一般，因为显然在一种最特殊的情况下 $n=3$ 时，$y$ 取到 $1$，这时就不成立，要特判一下。

实现有点细节，但不多。


```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define ll long long
#define ull unsigned long long
#define m_p make_pair
#define m_t make_tuple
#define N 250010
#define inf 0x3f3f3f3f3f3f3f3f
using namespace std;
using namespace __gnu_pbds;
signed main()
{
	// auto __IN__ = freopen(".in", "r", stdin);
	// auto __OUT__ = freopen(".out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	ll n, k, val, l, r, mid, ans = 0, d, p;
	cin >> n >> k;
	if(n==3&&k==2){
		cout << "1 2 3";
		return 0;
	}
	l = 0;
	r = n;
	while (l <= r)
	{
		mid = l + r >> 1;
		if (mid * (mid - 1) / 2ll <= k)
		{
			ans = mid;
			l = mid + 1;
		}
		else
			r = mid - 1;
	}
	val = (n * 2 - 1) / 3;
	if (val == 1 && n == 3)
		++val;
	d = k - ans * (ans - 1) / 2ll;
	// cerr << d << "\n";
	if (ans < 2)
		ans = 0;
	for (int i = 1; i <= d; i++)
		cout << val << " ";
	for (int i = 1; i <= ans - d; i++)
		cout << val * 2 << " ";
	p = n;
	if (ans < n && ans && ans * (ans - 1) / 2ll != k)
	{
		--n;
		cout << val * 3 << " ";
	}
	for (int i = ans + 1; i <= n; i++)
	{
		if (k && (p == val * 3 || p == val * 2 || p == val))
			++p;
		cout << p << " ";
		++p;
	}
	return 0;
}
```

---

## 作者：steambird (赞：0)

## 思路

这里提供一种和官方题解几乎完全不同的赛时思路。

下面把一对数对 $(i,j)$ 的贡献记在较小的数上（即 $a_i$ 较小就算作 $i$ 的贡献，否则算作 $j$ 的贡献）。

首先，注意到 $[n, 2n)$ 内的数不会产生贡献，因此可以用来填充多余的位置。由于这个区间内有 $n$ 个数，接下来考虑如何尽可能少地填充位置满足有 $k$ 对数。

考虑仅使用 $1$ 和质数的情况。它们的贡献分别为：

- 有 $x$ 个 $1$：${(2n-i-x) \times x} \over 2$。
- 有 $y$ 个某个质数 $p$：${y(y-1)} \over 2$。

要求 $0 \le x,y \le n$。可以通过下面方式说明（虽然略有点感性理解），所有可能的 $k$ 都能被表示：

- 假设原先是 $n$ 个 $1$，则此时总对数为 ${n(n-1)} \over 2$。
- 将其替换为某个质数 $p$，取决于当前已有的该质数 $p$ 的个数，总对数可能减少 $[0,n]$ 之间的任意值。

采用质数时，若有 $y$ 个相同质数，每个质数的平均贡献为 ${y-1} \over 2$，即 $y$ 越大，方案越优。因此，可以贪心考虑，每次都在总贡献不超过 $k$ 的情况下选择尽可能多的质数。

求最多能选多少个质数可以二分答案。观察贡献式子，可以得出 $n$ 大约被拆分为 $O(\log n)$ 种质数（因为一次能减少大约一半）。

最终代码需要注意下面两个细节：

- $[n,2n)$ 内的数如果能被前面选择的质数整除，则不能再选择。为了减少这种现象的发生，应当选择尽可能大的质数。事实上，由于只需要 $O(\log n)$ 种质数，这种情况涉及到的数较少，特判即可。
- 设最小的被选质数为 $q$，如果 $[n,2n)$ 内的数不足以填完所有数，可能需要用 $[2,q)$ 内的数填。

枚举 $1$ 的个数（下面的代码枚举到 $n$，事实上保证了有解，因此只需要枚举到 $\sqrt n$ 就会结束），对于每个个数求解即可。

时间复杂度约为 $O(n + \sqrt n \log^2 n)$。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

inline void train() {
	   ios::sync_with_stdio(false);
	   cin.tie(0);
	   cout.tie(0);
}

inline int maxi(int a, int b) {
	return a > b ? a : b;
}

inline int mini(int a, int b) {
	return a < b ? a : b;
}

constexpr int N = 3e5+4, NS = 6e5+4;
int n;
long long k;
vector<long long> res;
vector<int> grouped, primes, remain;
set<int> invalid;
bool notprime[NS];

int main() {

	train();
	
	cin>>n>>k;
	res.push_back(0);
	
	if (k == 0) {
		for (int i = n; i < (n<<1); i++) cout<<i<<' ';
		cout<<endl;
		return 0;
	}
	
	for (int i = 2; i < n; i++) {
		if (!notprime[i]) {
			primes.push_back(i);
		}
		for (auto &j : primes) {
			long long target = 1ll * i * j;
			if (target >= NS) break;
			notprime[target] = true;
			if (i % j == 0) break;
		}
	}
	
	for (int i = 1; i <= n; i++) {
		long long v = (1ll * i * (i-1)) >> 1;
		res.push_back(v);// No need to sort
	}
	
	
	for (int i = 0; i <= n; i++) {	// The number of '1'
		// Initially fetch current group with given number of '1':
		long long ones = (1ll * (n-1+n-i) * i) >> 1;
		// Split through
		long long demand = k - ones;

		if (demand < 0) continue;	// Invalid
		grouped.clear();
		bool fail = false;
		int gt = 0;
		while (demand > 0) {
			auto finder = upper_bound(res.begin(), res.end(), demand);	// Slower than log.

			grouped.push_back(finder - res.begin());	 // Group size
			gt += finder - res.begin();
			if (grouped.size() > primes.size()) {
				fail = true; break;
			}
			demand -= (*finder);
		}
		if (fail) continue;
		assert(demand == 0);
		if (gt + i <= n) {
			
			remain.clear(); invalid.clear();
			int rcnt = 0, minreach = INT_MAX;
			for (auto it = primes.rbegin(); it != primes.rend() && rcnt < grouped.size(); it++, rcnt++) {
				int iv = (*it);
				minreach = mini(minreach, iv);
				for (int i = iv; i < (n<<1); i += iv) invalid.insert(i);
			}
			// We have (n-1) numbers remaining.
			int required = n - i - gt;
			int external = minreach - 2;
			if (required > (n - invalid.size() + external)) {
				continue;	// Invalid solution ...
			}
			
			// Valid solution
			int cnt = 0;
			for (int j = 0; j < i; j++, cnt++) cout<<"1 ";
			auto pt = primes.rbegin();
			for (auto &j : grouped) {
				assert(pt != primes.rend());
				int ps = (*pt);
				for (int k = 0; k < j; k++, cnt++) cout<<ps<<' ';
				pt++;
			}

			int rc = 0;
			for (int j = n-1; j < (n<<1) && rc < required; rc++) {
				do {
					j++;
				} while (invalid.count(j));
				cout<<j<<' ';
			}
			for (int j = 2; j < minreach && rc < required; j++, rc++) {
				cout<<j<<' ';
			}
			cout<<endl;
			return 0;
		}
	}
	cerr << "No solution found ?" << endl;
	return 114;
	
	return 0;
}
```

---


# [JOI Open 2019] 汇款 / Remittance

## 题目描述

**译自 [JOI Open 2019](https://contests.ioi-jp.org/open-2019/index.html) T2 「送金」**

JOI 王国的河狸湖边有 $N$ 座房子，按逆时针方向给房子从 $1$ 到 $N$ 编号。

站在湖所在的位置看，每一座房子可以给它左边相邻的房子汇款，即：对于房子 $i\ (1\le i\le N-1)$，它左边的房子是房子 $i+1$，对于房子 $N$，它左边的房子为房子 $1$。然而，汇一笔款的手续费等于汇款金额。汇款金额必须是一个整数。当你汇款的时候，你必须交手续费，所以汇款钱数和手续费之和不能超出房子里的钱数。

目前，房子 $i\ (1\le i\le N)$ 里有 $A_i$ 元。另一方面，从收税的角度来看，我们希望房子 $i$ 里的钱数等于 $B_i$。因此你希望利用汇款系统使得房间 $i$ 里钱数等于 $B_i$ 元。你不能通过除给别的房子汇款和交手续费之外的方式花掉钱。

给定每座房子目前有的钱数和期望钱数，写一个程序判断能否使得每间房子都达到期望的钱数。

## 说明/提示

#### 数据范围：

$2\le N\le 10^6$，$0\le A_i\le 10^9$（$1\le i\le N$），$0\le B_i\le 10^9$（$1\le i\le N$）。

#### 子任务：

1. （15 分）$N\le 7$，$A_i\le 5$，$B_i\le 5$（$1\le i\le N$）。
2. （40 分）$N\le 20$。
3. （45 分）没有额外约束。

#### 样例解释：

举例来说，你可以按照以下支付方式，满足要求。

1. 房子 $5\to 1$，支付 $2$ 元。花费 $2$ 元。
2. 房子 $1\to 2$，支付 $1$ 元。花费 $1$ 元。
3. 房子 $2\to 3$，支付 $1$ 元。花费 $1$ 元。

你不能以任何方式满足要求。

注意钱必须以 $1$ 元作为单位支付。

你不需要使用支付系统。

## 样例 #1

### 输入

```
5
0 0
1 0
2 3
3 3
4 0```

### 输出

```
Yes```

## 样例 #2

### 输入

```
5
0 0
1 2
2 4
3 2
4 0```

### 输出

```
No```

## 样例 #3

### 输入

```
2
1 1
2 1```

### 输出

```
No```

## 样例 #4

### 输入

```
2
1 1
2 2```

### 输出

```
Yes```

# 题解

## 作者：VainSylphid (赞：2)

upd on 2024.12.20：修正了次数上界的错误，修改了代码中的错误，感谢 [rizynvu](https://www.luogu.com.cn/user/1051637) 的指正。

---

双倍经验：[CF2038B](https://www.luogu.com.cn/problem/CF2038B)。

观察到当 $A_i>B_i$ 时，我们必须通过汇款使得 $A_i\leq B_i$ 才可能有解，不妨先做尽可能多的操作使得 $A_i\leq B_i$。特别的，当 $B_i=0$ 时，因为你不能让 $A_i$ 变成负的，所以降到 $A_i=1$ 就暂时不能再降了。

我们从 $i=1$ 开始，执行这个汇款操作足够多次，直到不能操作为止，然后判断是否有所有的 $A_i=B_i$ 成立。这样看上去特别对，但是不太好证。一个感性的理解就是，如果有解，相邻两个位置之间汇款的次数是唯一确定的，而这样操作保证了每个位置不会超过次数的上界，因此不会提前把自己卡死，同时肯定在所有位置都达到上界之前一定存在一个位置可以继续调整，也就一定能调整出解。

然后我们考虑需要调整多少轮。考虑我们执行一圈以后，几乎所有多余的数都被推到了一个位置上，对于其他位置，若 $B_i=0$，有 $A_i=0$ 或 $A_i=1$；否则 $B_i\neq 0$，有 $A_i-B_i=0$ 或 $A_i-B_i=-1$。考虑这个位置的 $A_i-B_i$，设为 $V$，且 $V$ 是所有 $A_i-B_i$ 的最大值。当 $V>2$ 时，每在 $V$ 处做一次操作，$V$ 都会减小，变成一个不超过 $\lfloor\frac{V}{2}\rfloor+1$ 的值，因此做 $O(\log V)$ 轮后我们能得到 $V\leq 2$。此时有一种特殊的情况，即当前 $V=2$，下一个位置刚好满足 $B_i=0,A_i=1$，这个时候做一次操作 $V$ 不变。但是不可能一直出现这样的情况，至多再转一圈就会停下来。综上，我们只需要执行一圈，多做 $O(\log V)$ 次，再执行一圈，就一定能调整完。

注意，由于 $N$ 可能小于 $\log V$，在设置循环次数时应当设为 $kN+d$，其中 $k,d$ 是足够大的常数，其下界在上文已经做过分析。时间复杂度 $O(N+\log V)$。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[1000005],b[1000005];
int main()
{
	scanf("%d",&n);
	for(int i = 0;i < n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[i] = x - y;
		if(!y)
			b[i] = 1;
	}
	for(int i = 0;i < n * 2 + 50;i++)
	{
		int p = i % n,q = (i + 1) % n;
		if(a[p] < 0)
			continue;
		int tmp = (a[p] + 1) / 2;
		if(b[p])
			tmp = a[p] / 2;
		a[q] += tmp,a[p] -= tmp * 2;
	}
	for(int i = 0;i < n;i++)
		if(a[i] != 0)
		{
			printf("No\n");
			return 0;
		}
	printf("Yes\n");
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：1)

考虑对于一个大于目标的数，不对它进行操作是不可能达到目标的，因为前面的数的操作只会增加它。而且对它操作时，如果不把它减少到不大于目标，我们就仍然需要继续操作，所以每一次操作必须减少到达标或小于标准。

若这个数和标准的差值是偶数就直接调整至达标即可；若是奇数则减至比标准小 $1$。

这里需要一个特判：若这个数是 $1$，标准是 $0$，那么无法进行操作。

重复上面这个过程直到无法继续操作即可，由于每次被操作数都减半，所以一圈的复杂度近似 $O(\log V)$，其中 $V$ 是被操作数的最大值。

```cpp
const ll N=1e6+10;
ll n,a[N],tg[N],_a[N];

bool check(){
	rep(i,1,n){
		if(a[i]!=tg[i]) return 0;
	}
	
	return 1;
}

bool dif(){
	rep(i,1,n){
		if(a[i]!=_a[i]) return 1;
	}
	
	return 0;
}

int main() {
	cin>>n;

	rep(i,1,n) cin>>a[i]>>tg[i];

	while(1) {
		rep(i,1,n) _a[i]=a[i];

		rep(i,1,n) {
			if(a[i]==1 and tg[i]==0 or a[i]<=tg[i]) ctn;

			ll tmp;

			if((a[i]-tg[i])%2 and tg[i]) tmp=(a[i]-tg[i]+1)/2;
			else tmp=(a[i]-tg[i])/2;

			if(i<n) a[i+1]+=tmp;
			else a[1]+=tmp;

			a[i]-=tmp*2;
		}
		
		if(check()){
			cout<<"Yes";
			return 0;
		}
		
		if(dif()==0){
			cout<<"No";
			return 0;
		}
		
//		cout<<"a[]:";
//		
//		rep(i,1,n) cout<<a[i]<<' ';
//		
//		endl;
//		pause;
	}
}
```

---


# [ROIR 2017] 数据存放 (Day 1)

## 题目背景

翻译自 [ROIR 2017 D1T3](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day1.pdf)。

## 题目描述

一家公司大型的电信网络包含了 $n$ 台服务器，编号从 $1$ 到 $n$。其中，有一些服务器对之间通过双向通信通道连接，共有 $m$ 个通道。保证该网络中的服务器通过这些通道可以相互通信。

我们称一个服务器集合 $A$ 被称为“容错集合”，当且仅当在任意一条通道失效的情况下，满足以下条件：
- 对于任何不属于集合 $A$ 的服务器 $X$，总能通过剩下的通道将数据从集合 $A$ 中的某一台服务器传输到服务器 $X$。

下图显示了一个网络和一个容错集合 $A=\{1,4\}$。

- 对于服务器 $2$，当服务器 $1$ 和 $2$ 之间的通道失效时，可以从服务器 $4$ 传输数据；当服务器 $2$ 和 $3$ 之间的通道失效时，可以从服务器 $1$ 传输数据。当其它通道失效时，两个服务器都可以向其传输数据。  
- 对于服务器 $3$ 和 $5$，当任何通道失效时，可以通过其它通道从服务器 $4$ 传输数据。

![](https://cdn.luogu.com.cn/upload/image_hosting/mif7u71b.png)

公司的开发团队需要将他们的数据存放在这个网络中。为了提高数据的可用性和容错性，开发者希望将数据备份存储在多个服务器上，这些服务器需要形成一个容错集合。为了最小化开销，需要选择包含的服务器数量最少的容错集合。此外，为了了解网络的灵活性，还需要计算选择这个容错集合的不同方式的数量，由于这个数量可能很大，你只需要输出这个数对 $10^9 + 7$ 取模的结果。

## 说明/提示

### 样例解释

在样例中，容错集合可以为 $\{1, 3\},\{1, 4\} , \{1, 5\}$。

### 数据范围

本题满分为 $101$ 分。

| 子任务 | 分值 | $n$ | $m$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $25$ | $2\le n\le10$ | $1\le m\le45$ |
| $2$ | $27$ | $2\le n\le200000$ | $m=n-1$ |
| $3$ | $28$ | $2\le n\le1000$ | $1\le m\le5000$ |
| $4$ | $21$ | $2\le n\le200000$ | $1\le m\le200000$ |

## 样例 #1

### 输入

```
5 5
1 2
2 3
3 4
3 5
4 5```

### 输出

```
2 3```

# 题解

## 作者：chenly8128 (赞：5)

### 知识

- tarjan。
- ~~乘法原理~~

### 解法

很明显这是一道有关连通分量的题目。可以发现，在同一个边双连通分量中最多有一个点属于集合 A，否则肯定不是最优的方案。

由于这是一个无向图，所以可以先 tarjan 求出强连通分量（由于无向，等价于边双）。然后缩点，可以发现这张图变成了一棵无根树。

接下来我们贪心。设强连通分量个数为 $k$，第 $i$ 个连通分量中节点个数为 $cnt_i$。

- $k=1$ 时：此时特判，有一个节点属于 A。有 $n$ 种情况。
- $k>1$ 时：此时对于每个叶子分量（度为 1），缩成它的节点中必须要有且仅有一个节点属于 A。非叶子分量不需要有节点属于 A，原因是它可以通向至少两个路径无重复的叶子分量。所以只需要统计叶子分量个数，并且同时将叶子分量中的节点个数乘起来，得到方案数即可。

### 代码

赛时代码，微丑。

```cpp

// Author: chenly8128
// Created: 2025-01-05 10:52:42

#include <bits/stdc++.h>
using namespace std;
inline int read(void) {
	int res = 0;bool flag = true;char c = getchar();
	while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
	while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
	return flag ? res : -res;
}
const int MAXN = 2e5+10;
int n,m,u,v,now;
int col[MAXN],dfn[MAXN],low[MAXN],cnt[MAXN],dsfa,ans;
long long ans2 = 1;
vector <int> g[MAXN];
set <int> g2[MAXN];
stack <int> s;
void tarjan(int u,int fa) {
	dfn[u] = low[u] = ++dsfa;
	s.push(u);
	for (int v : g[u]) {
		if (v == fa) continue;
		if (!dfn[v]) {
			tarjan(v,u);
			low[u] = min(low[u],low[v]);
		}
		else low[u] = min(low[u],dfn[v]);
	}
	if (dfn[u] == low[u]) {
		col[u] = ++now;
		cnt[now] = 1;
		while (s.top() != u) {
			col[s.top()] = now;
			s.pop();
			cnt[now]++;
		}
		s.pop();
	}
}
int main (void) {
	n = read();m = read();
	for (int i = 1;i <= m;i++) {
		u = read();v = read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	tarjan (1,-1);
	for (int i = 1;i <= n;i++)
		for (int j : g[i])
			if (col[j] != col[i]) g2[col[i]].insert(col[j]);
	for (int i = 1;i <= now;i++)
		if (g2[i].size() == 1) {
			ans++;
			ans2 = ans2 * cnt[i] % 1000000007;
		}
	if (ans == 0) cout << 1 << ' ' << n << '\n';
	else cout << ans << ' ' << ans2 << '\n';
	return 0;
}
```

---

## 作者：dream_on_screen (赞：2)

首先我们可以发现，如果选择了一个节点的话，那么和这个点在同一个强连通分量（由于我太菜了，当时学的东西已经忘得差不多了，所以就笼统地说是强连通分量了。看到题解区别的题解说是边双连通分量）里的点无论怎么删边都可以通过选了的点到达。所以一个强连通分量里最多只会选一个点。

但是为什么是最多呢？因为如果能通过其他的强连通分量到达的话就可以不用选了。

可以把缩点之后的图建立出来，根据强连通分量的性质，新的图上不会存在环。因为如果有环的话那么环上的点就会变成一个新的强连通分量。因为原来的图是连通的，所以缩点之后的图也会连通。所以缩点之后应该会得到一棵树。

如果叶子节点没有选的话，可以直接切断叶子节点和她的上一级节点，然后就不能到达了，所以叶子节点一定全都要选。然后因为只能切断一条边，所以其他节点都不需要再选了。

最后选择的点数就应该是叶子节点的数量了。因为在每个强连通分量里的点都可以任意地选择一个，所以可以用乘法原理，把每个叶子节点里面的点数乘起来。

最后是写的最劣解代码。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int n,m;
vector<int> e[200005];
int dfn[200005],low[200005],cnt,cur,scc[200005];
int stack[200005],top;
int a[200005],p=1e9+7;
void dfs(int id,int last)
{
	cnt++;
	dfn[id]=cnt;
	low[id]=cnt;
	stack[++top]=id;
	for(int i=0;i<e[id].size();i++)
		if(e[id][i]!=last)
		{
			if(dfn[e[id][i]]==0)
			{
				dfs(e[id][i],id);
				low[id]=min(low[id],low[e[id][i]]);
			}
			else
				low[id]=min(low[id],dfn[e[id][i]]);
		}
	if(dfn[id]==low[id])
	{
		cur++;
		while(stack[top+1]!=id)
		{
			scc[stack[top]]=cur;
			top--;
		}
	}
}
vector<int> e_[200005];
int q,ans=1;
void dfs1(int id,int last)
{
	for(int i=0;i<e_[id].size();i++)
		if(e_[id][i]!=last)
			dfs1(e_[id][i],id);
	if(e_[id].size()==0||e_[id].size()==1)
	{
		q++;
		ans=1ll*ans*a[id]%p;
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	{
		a[scc[i]]++;
		for(int j=0;j<e[i].size();j++)
			if(scc[i]!=scc[e[i][j]])
				e_[scc[i]].push_back(scc[e[i][j]]);
	}
	dfs1(1,0);
	cout<<q<<" "<<ans;
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：1)

tarjan 缩点应用，比较板。

首先对整幅图进行缩点，把图变成无根树。考虑对于每一个度为 $1$ 的新点，构成它的点中必然有 $1$ 个点属于 $A$。因为若没有，则当切断这个新点的出边时图不连通；若多于 $1$ 个，则完全可以任意删除其中一个不影响连通性。

因此答案即为：容错集合中服务器的最小数量就是叶子节点数，方案数就是每个叶子节点的“大小”（即它由多少个原图中的点组成）的乘积。

```cpp
const ll N=2e5+10,mod=1e9+7;
vector<ll> g[N];
ll deg[N],n,m,ans1,ans2=1,newv[N],dfn[N],low[N],curdfn,scc,no[N];
stack<ll> Stack;
bool vis[N];

void tarjan(ll p,ll lst){
	curdfn++;
	dfn[p]=low[p]=curdfn;
	Stack.push(p);
	vis[p]=1;

	for(ll i:g[p]){
		if(i==lst) ctn;
		
		if(dfn[i]==0){
			tarjan(i,p);
			update(low[p],low[i],min);
		}elif(vis[i]) update(low[p],dfn[i],min);
	}

	if(low[p]==dfn[p]){
//		cout<<"find new scc:";
		scc++;

		while(1){
			ll cur=Stack.top();
			Stack.pop();
			no[cur]=scc;
			newv[scc]++;
			vis[cur]=0;
//			cout<<cur<<' ';

			if(cur==p) break;
		}
		
//		endl;
//		pause;
	}
}

int main(){
	cin>>n>>m;

	rep(i,1,m){
		ll u,v;
		cin>>u>>v;
		g[u].pb(v);
		g[v].pb(u);
	}

	tarjan(1,0);
	
//	cout<<"low[]:";
//	
//	rep(i,1,n) cout<<low[i]<<' ';
//	
//	endl;
//	pause;

	rep(i,1,n){
		for(ll j:g[i]){
			ll ii=no[i],jj=no[j];

			if(ii!=jj){
				deg[ii]++;
				deg[jj]++;
			}
		}
	}

//	cout<<"deg[]:";

	if(scc==1){
		cout<<"1 "<<n;
		return 0;
	}
	
	rep(i,1,scc) {
		deg[i]/=2;
//		cout<<deg[i]<<' ';

		if(deg[i]==1) {
			ans1++;
			(ans2*=newv[i])%=mod;
		}
	}

//	endl;
//	pause;
//	cout<<"scc:"<<scc<<'\n';
	cout<<ans1<<' '<<ans2;
}
```

---

## 作者：yi_hr (赞：1)

## tarjan
~~最近刚学 tarjan 算法，见此题较板，遂 A。~~  
## 思路
此题明显与图的连通性相关，不难看出，属于同一个边双连通分量的点只要有一个点属于容错集合 A 就符合条件，则一个边双里只有一个点属于 A 时最优。  

考虑进行边双连通缩点，则缩完的图为一个树。  

设此树有 $opt$ 个节点，若 $opt=1$ 则特判掉，输出“$1$   $n$”。否则，对于每个叶子，缩成它的节点中必须要有一个节点属于 A，且只有一个节点属于 A。非叶子节点则不需要有节点属于 A，因为它可以通过树边通向至少两个叶子节点。所以只需统计叶子节点个数，并同时将叶子节点中的节点个数乘起来即可。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+9,mod=1e9+7;
struct node{
	int to,next;
}e[N];
int head[N],cntt=1;
inline void add(int u,int v){
	e[++cntt].next=head[u];
	e[cntt].to=v;
	head[u]=cntt;
}
int n,m,opt;
int col[N],dfn[N],low[N],cnt[N],idx,ans;
long long ans2=1;
set<int> op[N];
stack<int> s;
void tarjan(int u,int fa) {
	int v;
	dfn[u]=low[u]=++idx;
	s.push(u);
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		if(v==fa)continue;
		if(!dfn[v]){
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}else{
			low[u]=min(low[u],dfn[v]);
		}
	}
	if (dfn[u]==low[u]) {
		++opt;
		while(1){
			int v=s.top();s.pop();
			col[v]=opt;
			cnt[opt]++;
			if(u==v)break;
		}
	}
}
int main(){
	cin>>n>>m;
	int u,v;
	for(int i=1;i<=m;i++) {
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	tarjan(1,-1);
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=e[j].next){
			v=e[j].to;
			if(col[v]!=col[i]) op[col[i]].insert(col[v]);
		}
	}
	for(int i=1;i<=opt;i++)
		if(op[i].size()==1){
			ans++;
			ans2=ans2*cnt[i]%mod;
		}
	if(ans==0)cout<<1<<" "<<n;
	else cout<<ans<<" "<<ans2;
	return 0;
}
```

---

## 作者：lam_dyr (赞：0)

~~本蒟蒻刚学 tarjan，切了蓝题有点小成就 qaq~~

## 题意

要求找到一个最小的容错集，使得在移除任意一条边后，剩余的图仍然连通。同时，要计算最小容错集的数量，并对 $10^9+7$ 取模。

显然，本题是一道与连通分量有关的题目。

## 思路

注意到属于一个边双联通分量（e-bcc）的节点，只要有一个节点在容错集合中，就可以通过 e-bcc 内的路径到达其他节点。因此，我们需要将图中的 e-bcc 缩点，并计算答案。

### 具体实现

- Tarjan 算法找到图中所有的 e-bcc。
- 将每个 e-bcc 缩成一个点，并构建缩点后的图（实际上是一棵树）。
- 如果缩点后只有一个节点，那么整个图就是一个 e-bcc，此时任意一个节点都可以作为容错集，因此最小容错集大小为 $1$，数量为 $n$。
- 否则，对于缩点后的树，只有叶子节点对应的 e-bcc 需要在容错集中包含节点。非叶子节点可以通过树上的路径到达至少两个叶子节点，所以不需要在容错集中包含节点。
- 最后，最小容错集大小等于缩点后树的叶子节点数量，容错集数量就等于所有叶子节点对应的 e-bcc 的大小的乘积。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=200005;
const int MOD=1e9+7;
int n,m;
vector<int> adj[N];
int dfn[N],low[N],tim;
int stk[N],top;
int id[N],bcc_cnt;
vector<int> bcc[N];
vector<int> deg;
void tarjan(int u, int p){
    dfn[u]=low[u]=++tim;
    stk[++top]=u;
    for (int v : adj[u]){
        if (v==p) continue;
        if (!dfn[v]){
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
        } else if(!id[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if (dfn[u]==low[u]){
        bcc_cnt++;
        while(true){
            int v=stk[top--];
            bcc[bcc_cnt].push_back(v);
            id[v]=bcc_cnt;
            if(v==u) break;
        }
    }
}
int main(){
    cin>>n>>m;
    for (int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    for (int i=1;i<=n;++i){
        if (!dfn[i]) 
            tarjan(i, -1);
    }
    if (bcc_cnt==1){
        cout<<"1 "<<n;
        return 0;
    }
    deg.resize(bcc_cnt + 1, 0);
    for(int i=1;i<=n;++i){
        for(int j : adj[i]){
            if (id[i]!=id[j]) 
                deg[id[i]]++;
        }
    }
    int leaf=0;
    long long ans=1;
    for (int i=1;i<=bcc_cnt;++i){
        if (deg[i]==1){
            leaf++;
            ans=(ans*bcc[i].size())%MOD;
        }
    }
    cout <<leaf<<" "<<ans;
    return 0;
}
```

[双倍经验](https://www.luogu.com.cn/problem/P3225)

---


# [ROIR 2016] 假期旅行 (Day 1)

## 题目背景

翻译自 [ROIR 2016 D1T4](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day1.pdf)。

## 题目描述

某地铁路是一条直线，沿线有 $n$ 个车站。我们称从某个车站到下一个车站之间的路段为一个区段。

一列火车从车站 $1$ 开始，最终到达车站 $n$，在每个车站都会停靠。火车上有 $k$ 个座位，座位编号从 $1$ 到 $k$。每张火车票上由三个数字 $s, t, a$，表示持有这张票的乘客允许从车站 $s$ 到车站 $t$，坐在编号为 $a$ 的座位上。

暑假的一天，Vasya 计划乘坐火车从一个车站到另一个车站。他发现当天已经售出了 $m$ 张票，并且可能在他感兴趣的车站之间已经没有空座位。直接从某个车站到另一个车站的票只能在每个区段的对应座位都空闲时购买。

Vasya 想到，有时即便如此，他仍然可以通过购买几张票，在某些中途车站换座位再继续乘坐。因此，他希望购买最少的票数，让他在每个区段都有座位。

Vasya 还没有完全确定下来要从哪个车站出发，也没有决定最终到达哪个车站。他记录了 $q$ 个出行方案，对于每个方案，他想知道如果选择这个方案，最少需要购买多少张票才能完成这次旅行。

## 说明/提示

### 样例解释

- 在车站 $2$ 到车站 $3$ 的区段，所有座位都已经被占用，因此从车站 $1$ 到车站 $5$ 的旅程无法进行。
- 从车站 $3$ 到车站 $5$，需要购买两张票：从车站 $3$ 到车站 $4$ 坐座位 $2$，从车站 $4$ 到车站 $5$ 坐座位 $1$。
- 从车站 $4$ 到车站 $5$ 只需要一张座位 $1$ 的票。

### 数据范围

| 子任务 | 是否捆绑 | 分值 | $n,m,k\le$ | $q\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $33$ | $100$ | $1$ |
| $2$ | 是 | $30$ | $200000$ | $1$ |
| $3$ | 是 | $37$ | $200000$ | $200000$ |

## 样例 #1

### 输入

```
5 4 3
1 4 1
2 5 3
2 3 2
4 5 2
3
1 5
3 5
4 5```

### 输出

```
-1
2
1```

# 题解

## 作者：Coffee_zzz (赞：1)

对于每个座位 $i$，处理出其所有被占用的区间，即可求出其所有未被占用的区间。我们称一段未被占用的区间为一条线段。

现在问题转化为了：给定若干条线段，求覆盖 $[f_j,d_j]$ 至少需要多少条线段。

先考虑单次询问怎么做。设 $r_i$ 表示所有包含 $i$ 的线段的右端点的最大值，则若当前位于第 $i$ 个车站，那么坐到第 $r_i$ 个车站一定是最优的。用线段树求出 $r$ 数组后，直接暴力跳，直到当前位置大于等于 $d_j$ 即可。

再考虑多次询问怎么做。我们发现这个东西是可以倍增维护的，直接上倍增即可。

这里认为 $n,m,k,q$ 同阶，复杂度 $\mathcal O(n \log n)$。

```cpp
#include <bits/stdc++.h>

#define ll long long
#define ull unsigned long long
#define i128 __int128
#define endl '\n'
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
#define vei vector<int>
#define pq priority_queue
#define yes puts("yes")
#define no puts("no")
#define Yes puts("Yes")
#define No puts("No")
#define YES puts("YES")
#define NO puts("NO")
#define In(x) freopen(x".in","r",stdin)
#define Out(x) freopen(x".out","w",stdout)
#define File(x) (In(x),Out(x))
using namespace std;
const int N=2e5+5,L=19;
vector <pii> ve[N];
int n,m,k,q,val[N<<2],ma[N],fa[N][L];
void modify(int g,int l,int r,int x,int y,int k){
	if(x<=l&&r<=y){
		val[g]=max(val[g],k);
		return;
	}
	if(r<x||y<l) return;
	int m=(l+r)>>1;
	modify(g<<1,l,m,x,y,k);
	modify(g<<1|1,m+1,r,x,y,k);
}
void getval(int g,int l,int r,int k){
	k=max(k,val[g]);
	if(l==r){
		ma[l]=max(l,k);
		return;
	}
	int m=(l+r)>>1;
	getval(g<<1,l,m,k);
	getval(g<<1|1,m+1,r,k);
}
void solve(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		int s,t,a;
		cin>>s>>t>>a;
		ve[a].pb({s,t});
	}
	for(int i=1;i<=n;i++) ma[i]=i;
	for(int i=1;i<=k;i++){
		sort(ve[i].begin(),ve[i].end());
		int las=1;
		for(auto p:ve[i]){
			if(las<p.fi) modify(1,1,n,las,p.fi,p.fi);
			las=p.se;
		}
		if(las<=n) modify(1,1,n,las,n,n);
	}
	getval(1,1,n,0);
	for(int i=1;i<=n;i++) fa[i][0]=ma[i];
	for(int j=1;j<L;j++) for(int i=1;i<=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
	cin>>q;
	for(int i=1;i<=q;i++){
		int s,t,ans=0;
		cin>>s>>t;
		for(int j=L-1;j>=0;j--) if(fa[s][j]<t) s=fa[s][j],ans+=(1<<j);
		if(fa[s][0]>=t) ans++;
		else ans=-1;
		cout<<ans<<endl;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	signed T=1;
//	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：jokiii (赞：1)

观察题目，发现我们并不在意每一站坐在哪个空座位，而是在意坐了多少个不同的座位。那么第一步可以把题目所给的有人坐的区间转换为没人坐的区间，同时无需在意座位编号。

设 $f_i$ 为从第 $i$ 站开始一直坐同一个座位最远可以坐到 $f_i$ 站。但如何快速求出两站之间换了多少次座位呢？考虑加一维度，设 $f_{i,j}$ 为从第 $i$ 站开始坐了 $2^j$ 个座位最远可以坐到 $f_{i,j}$ 站。倍增求解即可。

本题是一道典型的倍增处理题目，类似的题目还有：

**[CF1175E Minimal Segment Cover](https://codeforces.com/contest/1175/problem/E)** 与该题转换题意后相同。

**[P4155 [SCOI2015] 国旗计划](https://www.luogu.com.cn/problem/P4155)** 在环上处理该问题。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e5+10;
int n,m,k,q;
vector<pair<int,int> >vec[maxn];
int f[maxn][22];
int solve(int x,int y){
	int ans = 0;
	for(int i = 20;~i;i--){
		if(f[x][i]<y){//注意此处不能直接判断到=y。 
			ans+=(1<<i);
			x = f[x][i];
		}
	}
	if(f[x][0]>=y)ans+=1;
	else ans = -1;
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i = 1,s,t,id;i<=m;i++){
		cin>>s>>t>>id;
		vec[id].push_back({s,t});
	}
	for(int i = 1;i<=k;i++){
		sort(vec[i].begin(),vec[i].end());
		
		//将有人坐的区间转换成没人坐的区间。 
		int u = 1;
		for(auto to:vec[i]){
			if(to.first>u){
				f[u][0]=max(f[u][0],to.first);
			}u = to.second;
		}if(u<=n)f[u][0]=n;
	}
	
	for(int i = 1;i<=n;i++){
		f[i][0] = max(f[i][0],f[i-1][0]);
	//	cout<<f[i][0]<<" ";
	}//cout<<endl;
	for(int j = 1;j<=21;j++){
		for(int i = 1;i<=n;i++){
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	cin>>q;
	while(q--){
		int x,y;cin>>x>>y;
		cout<<solve(x,y)<<'\n';
	}
} 
```

---

## 作者：Lhm_Freeopen (赞：0)

### 题目复述
Vasya 的出行路线中有 $n$ 个车站和 $q$ 个出行计划，其中有 $m$ 张票已经被占用。对于每个出行计划，需要求出至少买多少张票才能完成这次旅行。
### 题目分析
通过观察题意，我们可以发现每一段旅行坐哪个空位其实与答案毫无关系，我们只需要关心需要坐几个不同的座位（也就是有几次需要因为位置被人占住而不得不换座）。   
于是，我们就可以完全忽略座位编号，只是通过有人坐的间推理出无人的区间，然后将每个有空位的区间处理成一个区间（具象化表示为一条线段），同时将询问的区间也转化成线段，示意图如下（绘图技术较差，请包涵）：
![](https://cdn.luogu.com.cn/upload/image_hosting/upfcgpie.png)
由此，我们就将问题转化成了一个格式化、较为易懂的形式：用**最少**的区间，覆盖一个给定的区间。   
对于这个问题，如果是单次询问，可以直接暴力求解~~拿下 63 分~~。   
在此基础上，我们开始考虑在**多次询问**时该如何把时间复杂度控制在可以接受的范围内。   
为了降低多次查询的总复杂度，我们可以通过**倍增**的方式降低单词查询的时间复杂度，具体表现为预处理一个数组，用 $p(i,j)$ 表示在第 i 个车站上车，坐了 $a^j$ 站后到达的车站。在此预处理数组的基础上进行倍增求解即可。
### 蒟蒻的 AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define made_by return
#define Lhm 0
using namespace std;
const int N=2e5+5;
int n,m,k;
int num;
int pre_opt[N][30];//用倍增方法求出预处理数组 
vector<pair<int,int> >p[N];//记录题目给定的有人区间 
int read(){//试图卡常 
    int x=0,w=1;
    char ch=0;
    while(ch<'0'||ch>'9'){
	    if(ch=='-'){
			w=-1;
		}
  		ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
  		x=x*10+(ch-'0');
  		ch=getchar();
    }
  return x*w;
}
int query(int s,int e){//倍增处理查找命令 
	int ans=0;
	for(int i=25;~i;i--){
		if(pre_opt[s][i]<e){
			ans+=pow(2,i);
			s=pre_opt[s][i];
		}
	}
	if(pre_opt[s][0]>=e){
		ans++;
	}
	else{
		ans=-1;//完成不了就返回 -1 
	} 
	return ans;
}
signed main(){
	n=read();
	m=read();
	k=read();
	for(int i=1;i<=m;i++){
		int l,r,idx;
		l=read();
		r=read();
		idx=read();
		p[idx].push_back(make_pair(l,r));
	}
	for(int i=1;i<=k;i++){//将有人的区间推理转化成无人的区间，方便后续处理 
		sort(p[i].begin(),p[i].end());
		int x=1;
		for(auto it:p[i]){
			if(it.first>x){
				pre_opt[x][0]=max(pre_opt[x][0],it.first);
			}
			x=it.second;
		}
		if(x<=n){
			pre_opt[x][0]=n;
		}
	}
	for(int i=1;i<=n;i++){
		pre_opt[i][0]=max(pre_opt[i][0],pre_opt[i-1][0]);
	}
	for(int j=1;j<=25;j++){//倍增求预处理数组 
		for(int i=1;i<=n;i++){
			pre_opt[i][j]=pre_opt[pre_opt[i][j-1]][j-1]; 
		}
	}
	int q;
	cin>>q;
	int st,en;
	for(int i=1;i<=q;i++){
		st=read();
		en=read();
		int r=query(st,en);
		cout<<r<<"\n";
	}
	made_by Lhm;
}
```
说在后面：蒟蒻的第一篇题解，求通过。

---


# [COCI 2024/2025 #4] Xor

## 题目背景

译自 [COCI 2024/2025 #4](https://hsin.hr/coci/) T3。$\texttt{1s,0.5G}$。满分为 $90$。


## 题目描述


给定长度为 $n$ 的非负整数序列 $a_1,a_2,\ldots,a_n$，求出 $\displaystyle \bigoplus _{1\le i\le j\le n} \left(a_i+a_j\right) $。

这里，$\oplus$ 指按位异或运算。


## 说明/提示


对于 $100\%$ 的数据，保证：

- $1\le n\le 5\times 10^5$；
- $0\le a_i\lt 2^{30}$。


| 子任务编号 | $n\le$ |  $a_i\lt$ | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $2\times 10^3$ | $2^{30}$  |   $ 7 $   |  
| $ 2 $    | $5\times 10^5$ | $2^{10}$  |   $ 17 $   |  
| $ 3 $    | $10^5$ | $2^{30}$  |   $ 45 $   |  
| $ 4 $    | $5\times 10^5$ | $2^{30}$  |   $ 21 $   |  






## 样例 #1

### 输入

```
3
2 4 5```

### 输出

```
14```

## 样例 #2

### 输入

```
4
6 7 3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
7
2 3 5 7 9 11 13```

### 输出

```
6```

# 题解

## 作者：Nangu (赞：5)

我们按位计算答案。

设当前枚举到了第 $k$ 位，下文计 $b_i$ 表示 $a_i$ 在第 $k$ 位的值，$c_i$ 表示 $a_i$ 前 $k-1$ 位的值（当 $k=1$ 时 $c_i=0$）。

$a_i+a_j$ 的第 $k$ 位为 $1$，当且仅当 $ [b_i=1] \operatorname{xor} [b_j=1] \operatorname{xor}  [c_i+c_j\ge 2^k]=1$（其实就是一个不考虑进位的加法），易得答案的第 $k$ 位为 $$\displaystyle\bigoplus _{1\le i\le j\le n}[b_i=1] \operatorname{xor} [b_j=1] \operatorname{xor}  [c_i+c_j\ge 2^k]$$。

我们讲这三个贡献分开算，前两个是容易的，做第三个时，考虑讲 $c_i$ 排序，然后用双指针维护。排序的复杂度为 $O(\log n)$，再加上枚举 $k$ 的复杂度，总复杂度为 $O(n\log n \log maxa)$，可以拿到五十二分。

瓶颈在于排序，我们考虑用类似于基数排序的方法来实现这个排序，在从小到大枚举 $k$ 时，若 $c_i=1$，就将 $i$ 放到序列的后面，若 $c_i=0$，就将 $i$ 放到序列的前面，相等的 $c$ 之间的相对位置不改变，这样总复杂度就由 $O(n\log n \log maxa)$ 降为 $O(n\log maxa)$ 了。

代码：
```cpp
#include<bits/stdc++.h>
#define rep(i, j, k) for(int i=(j); i<=(k); ++i)
#define per(i, j, k) for(int i=(j); i>=(k); --i)
#define print(a, len) cout<<#a<<"= "; rep(i, 0, len-1) cout<<(a)[i]<<' '; cout<<endl;
using namespace std;
namespace DEBUG{
	template<class T> void _debug(const char *s, T x){cout<<s<<'='<<x<<endl;}
	template<class T, class... Nxt> void _debug(const char *s, T x, Nxt... nxt){
		while(*s!=',') cout<<*s++;
		cout<<'='<<x<<',';
		_debug(s+1, nxt...);
	}
	template<class T> ostream& operator<<(ostream& c, vector<T> x){
		c<<'[';
		for(auto v:x) c<<v<<", ";
		return c<<']';
	}
	#ifdef ck
	#define debug(...) 0
	#else
	#define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)
	#endif
} using namespace DEBUG;
const int N=5e5+7;
int n, a[N], b[N], c[N], d[N], c1, c2, ans;
int buc[N];
inline bool bit(int s, int i){return s>>i&1;}
inline int mod(int s, int k){return s&((1<<k)-1);}

signed main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	rep(i, 1, n) cin>>a[i];
	rep(k, 0, 30){
		auto bit=[&](int i){return a[i]>>k&1;};
		auto mod=[&](int i){return a[i]&((1<<k)-1);};
		bool res=0;
		if(n+1&1) rep(i, 1, n) res^=bit(i);
		if(k){
			c1=c2=0;
			rep(i, 1, n) if(mod(i)<1<<k-1) b[++c1]=i; else c[++c2]=i;
			rep(i, 1, c1) d[i]=a[b[i]];
			rep(i, 1, c2) d[c1+i]=a[c[i]];
			rep(i, 1, n) a[i]=d[i];
			int pos=n+1;
			rep(i, 1, n){
				while(pos>i && mod(i)+mod(pos-1)>=1<<k) --pos;
				pos=max(pos, i);
				if(n-pos+1&1) res^=1;
			}
		}
		if(res) ans^=1<<k;
	}
	cout<<ans;
}
```

---

## 作者：jimmy0926 (赞：4)

## 题解：P11651 [COCI 2024/2025 #4] Xor

注：本题解中“二进制下第 $x$ 位”均从 $0$ 开始计数。

### 算法思路

位运算的一大特点就是在二进制下不进位。  
这启发我们分开考虑每一位。

**对于二进制下第 $i$ 位，我们可以只保留每个数的后 $i$ 位。**

紧接着我们考虑对第 $i$ 位有影响的是什么。  
令 $tmp_{j, i} = a_i \bmod 2^j$。  
对 $tmp_j$ 排序。  
**则答案二进制第 $k$ 位即为满足 $2^k \le tmp_i + tmp_j < 2^{k + 1} \vee tmp_i + tmp_j \ge 2^i + 2^{i + 1} \quad (1 \le i \le j \le n)$ 的 $i, j$ 的奇偶性。**

再用**容斥原理**将问题转化成

> 有数列 $a$，对任意 $x$，求满足 $1 \le i \le j \le n \wedge a_i + a_j \ge x$ 的 $i, j$ 的个数。

~~我想了很久才发现~~双指针秒了（注意本题卡常，我二分没过）。

---
### 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 5e5 + 10;
typedef long long lld;
int n, a[N], tmp[N];
int ans;

lld solve(lld k) {
	lld cnt = 0;
	int l = 1, r = n;
	while (l <= n) {
		while (r >= l && tmp[l] + tmp[r] >= k)
			--r;
		cnt += std::min(n - l + 1, n - r);
		++l;
	}
	return cnt;
}

signed main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
		scanf("%d", a + i);
	for (int i = 0; i <= 30; ++i) {
		for (int j = 1; j <= n; ++j)
			tmp[j] = a[j] & ((1ll << (i + 1)) - 1);
		std::sort(tmp + 1, tmp + n + 1);
		lld lim[3] = { 
			1ll << i, 
			1ll << (i + 1), 
			(1ll << i) + (1ll << (i + 1))
		};
		lld sum = 0;
		for (int k = 0; k < (i == 0 ? 2 : 3); ++k)
			if (k == 1)
				sum -= solve(lim[k]);
			else
				sum += solve(lim[k]);
		ans += (sum & 1) * (1 << i);
	}
	printf("%lld\n", ans);
	return 0;
}
```
时间复杂度：$\Theta \big (n\log \left (\max_{i = 1}^n a_i \right ) \big )$。

~~煤油注释，将就看吧~~

[AC 记录](https://www.luogu.com.cn/record/201056199)

---

## 作者：Drifty (赞：3)

### Solution

双倍经验：CF1322B。

很典很典的题。

考虑拆位算贡献，枚举当前位 $k$，会发现 $(a_i + a_j)$ 能产生 $1$ 的贡献等价于 $(a_i\bmod 2^{k + 1} + a_j\bmod 2^{k + 1})$ 能产生 $1$ 的贡献。即，我们只需要考虑到当前位下的值，因为往后的更高位再怎么加都不会影响到当前位。

然后我们记 $b_i = a_i \bmod 2^{k + 1}$，然后如果说 $(b_i + b_j)\in[2 ^ k, 2^{k + 1} - 1]$ 显然是可以的，当然也有可能进位，因此 $(b_i + b_j)\in[3\times 2 ^ k, 2 ^ {k + 2} - 1]$ 也可以，然后对 $b$ 排序双指针直接数这个东西就好。

之后的话注意一下实现，排序使用归并的技巧可以去掉一个 $\log$，当然用基数排序也可以。

总复杂度 $\mathcal{O}(n\log a_i)$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 5e5 + 7;
int n, a[N], b[N], id[N], ans;

void merge (int mask) {
    static int l[N], r[N], lid[N], rid[N];
    int lt = 0, rt = 0;
    for (int i = 1; i <= n; i ++)
        if (a[id[i]] & mask) r[++rt] = b[i] | mask, rid[rt] = id[i];
        else l[++lt] = b[i], lid[lt] = id[i];
    int i = 1, j = 1, k = 1;
    while (i <= lt && j <= rt)
        if (l[i] <= r[j]) b[k] = l[i], id[k ++] = lid[i ++];
        else b[k] = r[j], id[k ++] = rid[j ++];
    while (i <= lt) b[k] = l[i], id[k ++] = lid[i ++];
    while (j <= rt) b[k] = r[j], id[k ++] = rid[j ++];
}

int count (int x, int y) {
    if (x > y) return 0;
    int cnt = 0;
    for (int i = n, l = 1, r = 1; i; i --) {
        while (l <= n && b[i] + b[l] < x) l ++;
        while (r <= n && b[i] + b[r] <= y) r ++;
        cnt += r - l - (l <= i && i < r);
    }
    return (cnt >> 1) & 1;
}

int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; i ++) cin >> a[i], id[i] = i;
    int lim = floor(log2(* max_element(a + 1, a + n + 1)));
    for (int i = 0; i - 1 <= lim; i ++) {
        merge (1 << i);
        if (count(1 << i, (1 << (i + 1)) - 1) ^
            count(3 << i, (1 << (i + 2)) - 2)) ans |= (1 << i);
    }
    for (int i = 1; i <= n; i ++) ans ^= a[i] * 2;
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：1)

经典题。

注意到拆位后问题互不影响，所以枚举第 $i$ 位计算贡献，等价计算多少个 $1$。

因为只考虑某一位的贡献，自然发现只保留前 $i$ 位计算即可。具体而言当 $a_i+a_j$ 的范围在 $[2^i,2^{i+1})$ 或 $[2^i+2^{i+1},2^{i+2})$ 时有贡献，因为能够保证第 $i$ 位为 $1$，可以从二进制从大到小的试填法来说明。

考虑差分，这样我们就把问题转化为计算 $a_i+a_j \ge x$ 的组数，排序双指针计数即可。

时间复杂度是 $O(n \log n \log V)$ 的，需要优化。

考虑精细实现，先对原数组排序，然后从高到低枚举二进制位，并去除无用位。然后发现这两个区间的数内具有单调性，目标在于合并两个数组，归并排序的方法即可。

可以做到 $O(n \log n)$。

---

## 作者：Associate_Entropy (赞：1)

考虑对于每个二进制位 $w$ ，有多少对无序点对 $(i,j)$ 满足 $a_i+a_j$ 第 $w$ 位为 $1$ ，如果有奇数对那么答案的这一位就是 $1$ 。

设当前考虑第 $w$ 位（$w$ 从 $0$ 开始枚举），设 $b_i$ 为 $a_i$ 前 $w$ 位的值，只要 $b_i+b_j$ 第 $w$ 位是 $1$ ，$a_i+a_j$ 第 $w$ 位就是 $1$ ，因为第 $w+1$ 位以后的进位对第 $w$ 位没有任何影响。容易发现，对于一个数 $x$ ，满足 $x+y$ 第 $w$ 位为 $1$ 的 $y$ 在值域上形成两段连续的区间，因此我们将 $b$ 数组排序后用双指针扫一遍。如果直接排序每个二进制位单次时间复杂度是 $\mathcal{O} (n log n)$ 的，所以我们采用基数排序，刚好可以用上第 $w-1$ 位的 $b$ 数组顺序，每个二进制位排序的时间复杂度是 $\mathcal{O} (n)$ 的。

关于为什么对于一个数 $x$ ，满足 $x+y$ 第 $w$ 位为 $1$ 的 $y$ 在值域上形成两段连续的区间，这是因为如果 $x+y$ 在第 $w$ 位不进位，那么满足 $2^w\le x+y < 2^{w+1}$，如果 $x+y$ 进位了，那么满足 $2^{w+1}+2^w\le x+y < 2^{w+2}$，$y$ 的范围自然就是两段区间了。

实现细节可以参考代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,a[N],b[N],cnt[N],tmp[N],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=31;i++){//题解中的w=i-1，注意不要爆 int
		cnt[0]=cnt[1]=0;
		for(int j=1;j<=n;j++)cnt[(a[j]>>(i-1))&1]++;//计数排序 a 数组第 w 位的值
		cnt[1]+=cnt[0];
		for(int j=n;j>=1;j--)tmp[cnt[(a[j]>>(i-1))&1]]=a[j],b[cnt[(a[j]>>(i-1))&1]--]=(i==31? a[j]:(a[j]&((1<<i)-1)));
		memcpy(a+1,tmp+1,n*sizeof(int));
		int ql=1<<i-1,qr=(1ll<<i)-1,l=n,r=n,cc=0;
		for(int j=1;j<=n&&r>=j;j++){//第一段值域
			while(r>=j&&b[j]+b[r]>qr)r--;
			while(l>=j&&b[j]+b[l]>=ql)l--;
			if(r>=j)cc^=((r-max(l,j-1))&1);//求奇偶性可以直接异或
		}
		if(i<31){
			ql=(1<<i)+(1<<i-1);qr=(1ll<<i+1)-1;l=n;r=n;
			for(int j=1;j<=n&&r>=j;j++){//第二段值域
				while(r>=j&&b[j]+b[r]>qr)r--;
				while(l>=j&&b[j]+b[l]>=ql)l--;
				if(r>=j)cc^=((r-max(l,j-1))&1);
			}
		}
		if(cc)ans^=(1<<i-1);
	}
	cout<<ans;
}
```

---

## 作者：Polarisx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11651)。

这个不是黄/绿难度？

## 思路

首先容易想到按位拆贡献，只需对每个位 $i$ 求出有多少个 $a_j+a_k(j\le k)$ 使得其和的第 $i$ 位上为 $1$。

不妨舍去 $i$ 位以后的位，那么 $a_j+a_k$ 的范围就在 $[0,2^i),[2^i,2^{i+1}),[2^{i+1},2^{i+1}+2^i),[2^{i+1}+2^i,2^{i+2})$ 其中之一，显然只有第 $2,4$ 个区间有贡献，剩下的问题就是对于一个已知的 $u$ 如何快速求出有多少个 $j,k(j\le k)$ 使得 $a_j+a_k\ge u$ 了，这是个经典的问题，排序双指针即可。

归并排序即可做到 $\mathcal O(n\log V)$。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=5e5+7;
int n;
ll a[Maxn];
ll b[Maxn],c[Maxn];

inline int solve(ll u){
    int r=n+1;int ret=0;
    for(int l=1;l<=n;l++){
        while(a[l]+a[r-1]>=u and r>=1) --r;
        ret+=(n-max(l,r)+1)&1;
    }
    return ret&1;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    sort(a+1,a+n+1);

    ll ans=0;
    for(int i=31;~i;i--){
        int tot1=0,tot2=0;
        for(int j=1;j<=n;j++) 
            if(a[j]>>(i+1)&1) b[++tot1]=a[j]-(1<<(i+1)); 
            else c[++tot2]=a[j];
        merge(b+1,b+tot1+1,c+1,c+tot2+1,a+1);
        ll u=1ll<<i;
        if((solve(u)-solve(u*2)+solve(u*3))&1) ans^=(1ll<<i);
    }

    printf("%lld",ans);
    return 0;
}
```

---

## 作者：huangleyi0129 (赞：1)

结果为一堆数异或，故考虑逐位确定。

对于第 $w$ 位，只需要考虑 $a_i$ 第 $w$ 位为 $1$ 的数量（需要乘上 $n$ 或 $n-1$，视其部分意义而定）和 $a_i+a_j$ 在第 $w$ 位产生进位的数量。

由于是异或运算，只需关注此数量的奇偶性，故直接加起来即可。

具体地，对于第二项，在有序数组中双指针即可计算。

枚举位的同时做一个按位的基数排序即可做到 $O(nw)$，其中 $w$ 取 $30$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005,W=30;
int a[N],b[N],n,ans;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	int u,j;
	long long cnt;
	for(int w=0;w<=W;++w)
	{
		u=(1<<w)-1,j=n+1,cnt=0;
		for(int i=1;i<n;++i)
		{
			while(j-1>i&&(a[j-1]&u)+(a[i]&u)>u)
				--j;
			if(j<=i)
				j=i+1;
			cnt+=n-j+1;
		}
		j=0;
		for(int i=1;i<=n;++i)
			if((a[i]>>w)&1)
				cnt+=n-1;
			else
				b[++j]=a[i];
		if(cnt&1)
			ans|=1<<w;
		for(int i=1;i<=n;++i)
			if((a[i]>>w)&1)
				b[++j]=a[i];
		memcpy(a,b,sizeof a);
	}
	for(int i=1;i<=n;++i)
		ans^=(a[i]+a[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

## 1. Description

给定长度为 $n$ 的非负整数序列 $\{a\}$，求出 $\displaystyle \bigoplus _{1\le i\le j\le n} \left(a_i+a_j\right)$

## 2. Solution

发现是一道异或的题目，考虑拆位分别计算每一位对答案的贡献，等价于计算对于每一个数 $a_i$，有几个数 $a_j$ 满足 $a_i+a_j$ 在这一位上是 $1$。

考虑对于加法而言，高位的运算不会影响到低位，在计算第 $k$ 位的结果时，我们只需要考虑这个数模 $2^{k+1}$ 得到的余数即可，记 $b_i=a_i\bmod 2^{k+1}$，那么有 $\forall i,j\ b_i+b_j<2^{k+2}-2$，在第 $k$ 位上为 $1$ 的值有 $[2^k,2^{k+1}-1]\cup [3\times 2^k,2^{k+2}-1]$，因此对于 $b_i$，只需求出 $b$ 序列中有多少个数在 $[2^k-b_i,2^{k+1}-1-b_i]\cup [3\times 2^k-b_i,2^{k+2}-1-b_i]$ 即可，注意当 $2\times b_i$ 在第 $k$ 位上为 $1$ 时，$(i,i)$ 只计算了一次，其他组合均计算了两次。

但是如果使用二分求解的话，时间复杂度为 $O(n\log V\log n)$，显然是会 $T$ 的，因此考虑优化。

首先排序可以选择使用类似归并排序的技巧来优化，因为在第 $k$ 位上是 $0$ 的数一定小于第 $k$ 位上是 $1$ 的数，而当第 $k$ 位上的数相同时，大小由前 $k-1$ 位的值来决定，这一部分的大小关系已经前面的计算中确定了。

然后二分求解显然可以使用两个双指针分别维护两个区间，直接计算即可。

最后注意一下 $a_i+a_j$ 在第 $30$ 位上也可能是 $1$ 即可。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=5e5+5;
int n,ans;
struct Node{
	int val,num;
}b[N],c[N];
signed main(){
	read(n);
	for(int i=1;i<=n;i++)read(b[i].num);
	for(int i=0,cnt,L,R;i<30;i++){
		L=0,R=n+1;
		for(int j=1;j<=n;j++){
			if(b[j].num&1<<i){
				c[--R]=b[j];
				c[R].val+=1<<i;
			}else c[++L]=b[j];
		}
		for(int j=1;j<=L;j++)b[j]=c[j];
		for(int j=R;j<=n;j++)b[j]=c[n-j+R];
		cnt=0;
		for(int j=1,l1=n+1,r1=n+1,l2=n+1,r2=n+1;j<=n;j++){
			while(l1>1&&b[l1-1].val>=(1<<i)-b[j].val)l1--;
			while(r1>1&&b[r1-1].val>(1<<i+1)-1-b[j].val)r1--;
			cnt+=r1-l1;
			while(l2>1&&b[l2-1].val>=3*(1<<i)-b[j].val)l2--;
			while(r2>1&&b[r2-1].val>(1<<i+2)-1-b[j].val)r2--;
			cnt+=r2-l2;
			if((b[j].val+b[j].val)&(1<<i))cnt++;
		}
		if(cnt%4)
			ans+=1<<i;
	}
	int cnt=0;
	for(int j=1,p=n+1;j<=n;j++){
		while(p>1&&b[p-1].val>=(1<<30)-b[j].val)p--;
		cnt+=n-p+1;
		if((b[j].val+b[j].val)&(1<<30))cnt++;
	}
	if(cnt%4)
		ans+=1<<30;
	write(ans);
}
```

---

## 作者：f_hxr_ (赞：0)

复健笑传之 Count Count Bit。

还记得第一次看见位运算于加减法同时出现，心情是多么的目力。究竟是谁发明的这几把玩意！然后便思索如何处理进位的问题。然后不知不觉摸鱼去了。

然后我就退役了。然后我到现在都不知道这一类题该怎么做。

下文中，对于二进制位，我们从 $0$ 开始数。

求一堆东西的异或和。我们可以枚举它的每一个二进制位，尝试判断上面是 $0$ 还是 $1$。

答案是一堆数的异或和。所以，如果我们想知道第 $i$ 位是 $0$ 还是 $1$，我们需要数出第 $i$ 位是 $1$ 的数有多少个。答案也是一堆数的**和**的异或和。所以，我们要完成这样一件事情：

> 给定两个正整数 $A$ 和 $B$，快速判断 $A+B$ 的二进制的第 $i$ 位是 $0$ 还是 $1$。

我们当然可以直接加起来在上左移右移之类的东西。但这样我们就回到原点了。毕竟我们面对的不是一对数，而是很多对数。位运算是不进位的，加减法是进位的。如果它们混在一起，会对优化带来麻烦。我们必须转化或去掉其中之一。

但我不会。

但首先，我们注意到，如果只是关注第 $i$ 位，那么第 $i+1,i+2$ 等位上是否进位我们是不用考虑的。所以我们可以像 $10$ 进制下对 $10^k$ 取模，来获取末 $k$ 位数字一样，我们将数字对 $2^k$ 取模，来获取末 $k$ 个二进制位。前面的可以丢掉方便处理。

然后我们想，**假设 $A+B$ 的第 $i$ 位是 $1$，那么，其他位上是 $0$ 是 $1$ 我们都不关心。$i$ 的上面顶多会进一位，$i$ 的下面有 $i-1$ 个位。所以我们可以通过枚举是否进位来得到，当 $A+B$ 的第 $i$ 位为 $1$ 时，$A+B$ 的大小范围。**

就像下面这样~~上面这几句话或许有点拗口~~

$\color{blue}{0}\color{red}{1}\color{black}{000000} \le A+B \le \color{blue}{0}\color{red}{1}\color{black}{111111} \ 或 \  \color{blue}{1}\color{red}{1}\color{black}{000000} \le A+B \le \color{blue}{1}\color{red}{1}\color{black}{111111}$ 

上面红的部分就是我们说的第 $i$ 位。蓝色的就是进的位。黑色的就是我们不管心的那一坨 $i-1$ 个位。

将上面的二进制变成十进制就是这样：

$2^i \le A+B \le 2^{i+1}-1 \ 或 \ 3 \times2^i \le A+B \le 2^{i+2}-1$

然后你就把左移右移改成了大小比较，然后就能和加减法兼容了。然后你就会这道题了。然后我会了。然后我忘了。然后我退役了。

最右边的 $2^{i+2}-1$ 是取不到的，丢掉。然后我们设 $u=2^i$。把 所有满足 $a_i+a_j \ge u$ 的数对数出来，减去 $a_i+a_j \ge 2u$ 的，再加上 $a_i+a_j \ge 3u$ 的，就得到答案了。

求一个数组里有多少个 $a_i+a_j\ge u$，双指针就够了。给式子移个项就行。

然后这道题就做完了。

哦孩子们我们还要满足 $i\le j$ 所以代码里有一点点细节。

哦孩子们这题卡常我懒得基数排序了直接用快读日过去了。

```cpp
#include <bits/stdc++.h>
namespace IO{
	char buff[1<<21],*P1OfFastIO=buff,*P2OfFastIO=buff;
	#define getch() (P1OfFastIO==P2OfFastIO&&(P2OfFastIO=((P1OfFastIO=buff)+fread(buff,1,1<<21,stdin)),P1OfFastIO==P2OfFastIO)?EOF:*P1OfFastIO++)
	template<typename T>
	void read(T &x){char CHOfFastIO=getch();int fl=1;x=0;while(CHOfFastIO>'9'||CHOfFastIO<'0'){if(CHOfFastIO=='-')fl=-1;CHOfFastIO=getch();}while(CHOfFastIO<='9'&&CHOfFastIO>='0'){x=x*10+CHOfFastIO-48;CHOfFastIO=getch();}x*=fl;}
	template<typename T,typename ...Args>
	void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*P3OfFastIO=obuf;
	inline void putch(char CHOfFastIO){if(P3OfFastIO-obuf<(1<<21))*P3OfFastIO++=CHOfFastIO;else fwrite(obuf,P3OfFastIO-obuf,1,stdout),P3OfFastIO=obuf,*P3OfFastIO++=CHOfFastIO;}
	char CHOfFastIO[100];template<typename T>
	void write(T x){if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)CHOfFastIO[++top]=x%10+48,x/=10;while(top)putch(CHOfFastIO[top]),top--;}
	template<typename T,typename ...Args>
	void write(T x,Args ...args){write(x);write(args...);}
	inline void flush(){fwrite(obuf,P3OfFastIO-obuf,1,stdout);}
}using namespace IO;
using namespace std;
typedef long long LL;
const int maxn=5e5+7;
const LL inf=1e18+7;
LL N,a[maxn],b[maxn];
inline LL solve(LL p){
	LL ret=0;
	LL mod=(1LL<<(p+1)),u=(1LL<<p);
	for(int i=1;i<=N;i++)b[i]=a[i]%mod;
	sort(b+1,b+N+1);b[N+1]=inf;
	//for(int i=1;i<=N;i++)cout<<b[i]<<' ';cout<<endl;
	for(int i=1,p=N+1;i<=N;i++){
		while(p!=0&&b[p]+b[i]>=u)--p;
		ret+=N-max(p,i-1);
	}
	//cout<<"ret: "<<ret<<endl;
	for(int i=1,p=N+1;i<=N;i++){
		while(p!=0&&b[p]+b[i]>=u*2)--p;
		ret-=N-max(p,i-1);
	}
	//cout<<"ret: "<<ret<<endl;
	for(int i=1,p=N+1;i<=N;i++){
		while(p!=0&&b[p]+b[i]>=u*3)--p;
		ret+=N-max(p,i-1);
	}
	//cout<<"ret: "<<ret<<endl;
	return ret&1;
}
int main(){
	//scanf("%lld",&N);
	read(N);
	//for(int i=1;i<=N;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=N;i++)read(a[i]);
	LL ans=0;
	for(int p=0;p<=30;p++)
		if(solve(p))ans|=(1LL<<p);
	//printf("%lld",ans);
	write(ans);flush();
	return 0;
}
```

---


# [JOIGST 2024] 年轮蛋糕 2 / バームクーヘン 2

## 题目背景



译自 [日本情報オリンピック 第4回女性部門 (JOIG 2023/2024) 春季トレーニング](https://www2.ioi-jp.org/joig-camp/2024/2024-sp-tasks/) R1T2。

图：年轮蛋糕。バームクーヘン = baumkuchen，即树木（德语 baum）+ 蛋糕（德语 kuchen）。图源百度百科。

![](https://cdn.luogu.com.cn/upload/image_hosting/47miipjm.png)

## 题目描述


葵计划举办一场派对，共有 $K$ 人参加，编号 $1\sim K$。

众人将分享一个**环形的**年轮蛋糕。蛋糕的圆周上均匀刻有 $K \times L$ 个切缝，蛋糕只能沿切缝分割。

将切缝按顺时针编号 $1\sim K\times L$，切缝 $i$ 和切缝 $\left(i\bmod KL\right) +1$ 之间的区域叫做第 $i$ 个部分。

分割规则如下：
1. 选择 $K$ 个切缝切割，将蛋糕分为 $K$ 块，每个块包含恰好 $L$ 个**连续的**部分。
2. 把 $K$ 块蛋糕分给 $K$ 个人，要求每个人都恰好分到一块蛋糕。

现在有 $Q$ 条限制，第 $j$ 条限制要求第 $X_j$ 个部分必须被分配给第 $Y_j$ 个人。保证每个部分 $X_j$ 只会在限制中出现一次。

对于 $i=1,2,\cdots,Q$，求出有多少种切蛋糕和分蛋糕的方案满足前 $i$ 条限制，对给定的素数 $P$ 取模。

两个方案不同，当且仅当存在一个人，他在这两个方案中拿到了不同的蛋糕块。



## 说明/提示


### 样例解释

#### 样例 $1$ 解释

$i=1$ 时，要求将包含第 $1$ 个部分的块分给第 $2$ 个人，有 $4$ 个方案。举例：

1. 沿切缝 $1$、$3$、$5$ 切割蛋糕；
2. 分配方式：
   - 第 $1$ 个人：第 $3,4$ 个部分；
   - 第 $2$ 个人：第 $1,2$ 个部分；
   - 第 $3$ 个人：第 $5,6$ 个部分。


$i=2$ 时，在 $i=1$ 的基础上额外要求将包含第 $6$ 个部分的块分配给第 $2$ 个人，有 $2$ 个方案。举例：

1. 沿切缝 $2$、$4$、$6$ 切割蛋糕；
2. 分配方式：
   - 第 $1$ 个人：第 $4,5$ 个部分；
   - 第 $2$ 个人：第 $6,1$ 个部分；
   - 第 $3$ 个人：第 $2,3$ 个部分。

该样例满足所有子任务的限制。
#### 样例 $2$ 解释


该样例满足所有子任务的限制。

#### 样例 $3$ 解释

该样例满足子任务 $2\sim 6$ 的限制。

### 数据范围
- $2\le K\le 2\times 10^5$；
- $1\le L\le 2\times 10^5$；
- $10^8\lt P\lt 10^9$；
- $P$ 是素数；
- $1\le Q\le 2\times 10^5$；
- $\forall 1\le j\le Q$，$1\le X_j\le KL$；
- $\forall 1\le j\lt k\le Q$，$X_j\neq X_k$；
- $\forall 1\le j\le Q$，$1\le Y_j\le k$；
- 输入的值全部是整数。

### 子任务

1. （13pts）$K\le 8$，$L\le 10$，$Q\le 10$。
2. （14pts）$K\le 100$，$L\le 100$，$Q\le 100$。
3. （18pts）$K\le 400$，$L\le 400$，$Q\le 400$。
4. （17pts）$K\le 2\, 500$，$L\le 2\, 500$，$Q\le 2\, 500$；
5. （28pts）$K\le 40$；
6. （10pts）无额外限制。

翻译来自 DeepSeek-R1 并经过人工微调。

## 样例 #1

### 输入

```
3 2
998244353
2
1 2
6 2```

### 输出

```
4
2```

## 样例 #2

### 输入

```
8 10
304623133
10
8 8
6 8
51 1
36 5
10 7
38 5
68 3
57 4
76 3
19 2```

### 输出

```
50400
40320
5760
960
48
48
12
0
0
0```

## 样例 #3

### 输入

```
10 8
446958661
10
26 5
49 9
37 6
10 1
15 3
29 5
69 2
2 1
25 5
12 1```

### 输出

```
2903040
322560
40320
5760
600
240
48
0
0
0```

# 题解

## 作者：FFTotoro (赞：5)

之前把这题搬进了模拟赛，直接把当时写的题解弄过来。

考虑到如果一个人提出过要求，那么在蛋糕切割之后他需要拿的部分就唯一确定了。如果一个人提出过多次要求，那么蛋糕的某些切割方法（即选择切口的方法）将会变得不合法。

设没有提出过要求的人有 $x$ 个，有 $y$ 种合法的切割方法，那么答案为 $x!\cdot y$。

使用 `std::set` 维护合法的切割方法：具体地，维护合法的切割方法（切口的编号 $\bmod l$ 的值），每次如果一个人提出了一个新的要求，考虑同时满足这个要求和之前所有的要求的切割方法集合的交集（显然是一段区间）；同时还需考虑这个要求和其他人的要求形成的交集。把上述所有情况取交集即可。更多实现细节可以参照代码。

令 $k,l,q$ 同阶，则时间复杂度为 $O(k\log k)$。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> pii;
static int p,f[200001];
main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int k,l,q,c,r; cin>>k>>l>>p>>q,r=((c=k)*l);
  for(int i=f[0]=1;i<=k;i++)
    f[i]=f[i-1]*i%p;
  bool w=true;
  set<int> ps;
  for(int i=0;i<l;i++)
    ps.emplace(i);
  vector<int> id(k);
  vector<set<int> > s(k);
  set<pii> as;
  auto upd=[&](int a,int b){
    if(a<=b){
      while(!ps.empty()&&*ps.begin()<a)ps.erase(ps.begin());
      while(!ps.empty()&&*prev(ps.end())>b)ps.erase(prev(ps.end()));
    }
    else{
      auto it=ps.upper_bound(b);
      while(it!=ps.end()&&*it<a)it=ps.erase(it);
    }
  }; // 与 [a,b] 取交集
  while(q--){
    int x,y; cin>>x>>y,x--,y--,as.emplace(x,y);
    if(s[y].empty())c--,id[y]=x,s[y].emplace(0);
    else if((x-id[y]+r)%r<l||(id[y]-x+r)%r<l){
      if((x-id[y]+r)%r<l)s[y].emplace((x-id[y]+r)%r);
      else s[y].emplace(-(id[y]-x+r)%r);
      if(*prev(s[y].end())-*s[y].begin()>=l)w=false;
      else upd((*prev(s[y].end())+1+id[y]+l)%l,(*s[y].begin()+id[y]+l)%l);
    }
    else w=false;
    if(as.size()>1){
      auto p1=as.upper_bound(make_pair(x,2e9));
      if(p1==as.end())p1=as.begin();
      auto [x1,g1]=*p1;
      auto p2=as.lower_bound(make_pair(x,0));
      if(p2==as.begin())p2=as.end();
      auto [x2,g2]=*--p2;
      if(y!=g1&&x1!=x2&&g1==g2&&(x1-x2+r)%r<l)w=false;
      else{
        if(!s[g2].empty()&&(x-(*s[g2].begin()+id[g2])+r)%r<l)
          upd((*prev(s[g2].end())+1+id[g2]+l)%l,x%l);
        if(!s[g1].empty()&&(*prev(s[g1].end())+id[g1]-x+r)%r<l)
          upd((x+1)%l,(*s[g1].begin()+id[g1]+l)%l);
      }
    }
    if(w)cout<<f[c]*ps.size()%p<<'\n';
    else cout<<"0\n";
  }
  return 0;
}
```

---


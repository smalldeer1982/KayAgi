# [COCI 2024/2025 #5] 绘图 / Crtež

## 题目背景

译自 [COCI 2024/2025 #5](https://hsin.hr/coci/) T4。$\texttt{2s,0.5G}$。满分为 $120$。

赛时公告：$a_i$ 初值为 $0$。

## 题目描述



考虑一个长度为 $n$ 的整数序列 $a_1,\ldots,a_n$，初始时 $a_i\in \{-1,0\}$。

你可以按照如下的步骤操作任意多次（包括零次）：


- 令这是第 $x$ 次操作。首先选择 $i$ 满足 $1\le i\le n$，且 $a_i=0$。（如果不存在，则无法继续操作）
- 从如下的操作中二选一：
    - 令 $a_i\gets -1$，然后终止本次操作。
    - 令 $a_i\gets x$。重复执行以下操作，直到 $i=1$ 或 $a_{i-1}\neq 0$：
      - 令 $i\gets i-1$，然后令 $a_{i}\gets x$。

操作完后会得到若干个结果序列 $a$。

我们称两个序列 $a,b$ **等价**，当且仅当，能够重标号 $a$ 序列中 $>0$ 的元素，使得重标号后这两个序列相等。

例如，$[1,1,-1,5,1,0]$ 和 $[2,2,-1,6,2,0]$ 等价。

更为精确地说，如果能构造一个**双射** $f: \{-1,0,\ldots\}\to \{-1,0,\ldots\}$，满足：

- $f(-1)=-1$，$f(0)=0$；
- 对于 $i\gt 0$，$f(i)\gt 0$；
- $[f(a_1),f(a_2),\ldots,f(a_n)]=[b_1,b_2,\ldots,b_n]$。

那我们就说，$a$ 和 $b$ 等价。

---

现在有 $q$ 个操作。每个操作给定 $l,r$，将 $a_l,a_{l+1},\ldots,a_r$ 中的 $0$ **同时**替换成 $-1$，$-1$ **同时**替换成 $0$。

每次操作后，求出以当前的 $a$ 序列为起始序列，操作得到的互不等价的结果序列的数量模 $(10^9+7)$ 后的结果。

**没有进行任何操作之前，$a_i=0$。**

## 说明/提示


#### 样例解释

样例 $1$ 解释：

第一次操作后，$a=[-1]$。无法操作。互不等价的序列只有 $[-1]$。

第二次操作后，$a=[0]$。互不等价的序列有 $[0],[1],[-1]$。

#### 数据范围

对于 $100\%$ 的数据，保证：
- $1\le n\le 10^{18}$；
- $1\le q\le 10^5$；
- $1\le l\le r\le n$。

| 子任务编号 |  $n\le$ | 特殊性质 | 得分 |  
| :--: | :--: | :--: | :--: |
| $ 1 $    |  $ 10^3$  | A  | $ 20 $   |  
| $ 2 $    |  $10^6$  |  | $ 55 $   |  
| $ 3 $    |  $10^{18}$  |  | $ 45 $   |  

特殊性质 A：$q\le  10^3$。


## 样例 #1

### 输入

```
1 2
1 1
1 1```

### 输出

```
1
3```

## 样例 #2

### 输入

```
3 2
2 2
1 3```

### 输出

```
9
3```

## 样例 #3

### 输入

```
57 2
13 39
6 42```

### 输出

```
130653412
804077942```

# 题解

## 作者：_ayaka_ (赞：8)

### 思路

我在做完这道题后想出了一个更好理解的推结论过程，所以这里附出更简单的版本。至于更丑陋的考场版本有兴趣可以看看。

答案显然是每一段连续的 $0$ 的情况相乘后的答案，因此先只考虑连续的 $0$。因为显然对一个位置进行操作 $2$ 后，直到其左边第一个非 $0$ 数，之间的所有数全部会被染成一种颜色，不好讨论，考虑从左到右来进行操作。

随后，不难发现，对于一个已经被选择为 $0$ 的点，即使这个点被后面的一次操作 $2$ 染上色了，这也仍然只是一种情况，可推出对于每一个点，有进行操作 $1$，进行操作 $2$，以及不操作三种情况，可得如果有 $n$ 个连续的 $0$，总情况为 $3^n$。

然后我们的问题就变成了如何求出每次询问里序列 $a$ 中 $0$ 的数量。不难想到离散化后使用线段树维护即可，因为不是此题重点就不细说了。

时间复杂度 $O(q\log n)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll (k<<1)
#define rr (k<<1|1)
#define mid ((l+r)>>1)
const int mod = 1e9 + 7;
int qpow(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
struct que {
	int l, r;
} p[1000005];
map <int, int> mp;
int num[1000005], cnt, ls[1000005], un;
struct tree {
	int l, r, lazy, num, sum;
} t[4000005];
int n, q;
inline void pushup(int k) {
	t[k].num = t[ll].num + t[rr].num;
}
void build(int k, int l, int r) {
	t[k].l = l;
	t[k].r = r;
	if (l == r) {
		t[k].num = num[l];
		t[k].sum = num[l];
		return ;
	}
	build(ll, l, mid);
	build(rr, mid + 1, r);
	pushup(k);
	t[k].sum = t[ll].sum + t[rr].sum;
	return ;
}
inline void pushdown(int k) {
	if (t[k].lazy) {
		t[ll].lazy ^= 1;
		t[rr].lazy ^= 1;
		t[ll].num = t[ll].sum - t[ll].num;
		t[rr].num = t[rr].sum - t[rr].num;
		t[k].lazy = 0;
	}
}
void update(int k, int l, int r) {
	if (t[k].r < l || t[k].l > r) return ;
	if (t[k].r <= r && t[k].l >= l) {
		t[k].lazy ^= 1;
		t[k].num = t[k].sum - t[k].num;
		return ;
	}
	pushdown(k);
	update(ll, l, r);
	update(rr, l, r);
	pushup(k);
	return ;
}
signed main() {
	cin >> n >> q;
	for (int i = 1; i <= q; i++) {
		cin >> p[i].l >> p[i].r;
		ls[i * 2 - 1] = p[i].l, ls[i * 2] = p[i].r;
	}
	sort(ls + 1, ls + q * 2 + 1);
	un = unique(ls + 1, ls + q * 2 + 1) - ls - 1;
	for (int i = 1; i <= un; i++) {
		num[i * 2 - 1] = ls[i] - ls[i - 1] - 1;
		num[i * 2] = 1;
		mp[ls[i]] = i * 2;
	}
	num[un * 2 + 1] = n - ls[un];//num 数组保存的是这一个新点存储了几个点 
	build(1, 1, un * 2 + 1); 
	for (int i = 1; i <= q; i++) {
		p[i].l = mp[p[i].l];
		p[i].r = mp[p[i].r];
		update(1, p[i].l, p[i].r);
		cout << qpow(3, t[1].num) % mod << "\n";
	}
	return 0;
//}
```


#### 关于更多

这里附考场思路：

首先只考虑对一段连续的 $0$ 做操作 $2$ 的情况。操作 $2$ 也就是把从一个点到其左边第一个非 $0$ 数前的所有数染上同一个颜色。接下来，我们对于每个数就有了“染了色”和“未染色”两种情况。根据题面给出的“**等价**”的概念，我们不用在意这个染色具体是哪种颜色，只需要知道这一段的颜色与其他所有颜色都不同就好了。

接下来对这个情况进行简单的讨论：

- 当有 $1$ 个 $0$ 时，显然对于第 $1$ 个数有两种选择：染色或不染。
- 当有 $2$ 个 $0$ 时，对于第 $2$ 个数，前一个数未被染色的情况有 $1$ 个，此时这一个数也只能不染色，因为按照操作 $2$ 的定义，不可能存在两段染了色的段中间有一段未染色的情况。因此前一个数未染色而这一个数未染色的情况有一种；而前一个数被染色的情况有 $1$ 种，那这个点有三种选择：染前一个点的颜色，染新的颜色，不染。最后总情况为 $4$ 种，这个点未被染色的有 $2$ 种，被染色的有 $2$ 种。
- 当有 $3$ 个 $0$ 时，根据上一种情况可得前一个数未染色可推出的情况有 $1\times 2=2$ 种，而前一个数被染色的情况有 $3\times 2=6$ 种，总情况有 $8$ 种，这个点未被染色的有 $4$ 种，被染色的有 $4$ 种。

接着根据这个规律，显然可得有 $n$ 个 $0$ 时，总情况有 $2^n$ 种。

接下来，我们加入第 $1$ 种操作。可以将第 $1$ 种操作看作是把一段连续的 $0$ 拆成几个部分，显然若添加了 $x$ 个 $-1$，则总情况为 $2^{n-x}$ 种。可得总情况为：

$$\sum^n_{i=0} \binom{n}{i}\times 2^i$$

根据牛顿二项式定理（~~或者打一点表出来看~~）可得此式为 $3^n$。随后可得结论。

---

## 作者：zzy0618 (赞：3)

考虑每一段连续的 $0$，显然将每段的答案相乘就是答案。

然后你尝试 DP，$g_i$ 表示长度为 $i$ 的全 $0$ 序列 $a$ 有多少种不同赋值结果，然后不太好做。考虑再开一个辅助数组 $f_i$ 表示长度为 $i$ 的全 $0$ 序列 $a$ 不赋值为 $-1$ 有多少种不同的赋值结果，然后有 $f_i=1+\sum_{j=0}^{i-1}f_j$，原理就是枚举第一次操作的位置，后面的就是子问题。然后我们有 $g_i=f_i+\sum_{j=1}^ig_{j-1}\times f_{i-j}$，原理就是枚举离 $i$ 最近的 $-1$。

可以获得 $20$ 分。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+5,P=1e9+7;
int n,m,a[N],f[N],g[N];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    f[0]=1,f[1]=2;
    for(int i=1;i<=1000;++i){
        f[i]=1;
        for(int j=0;j<i;++j)
            (f[i]+=f[j])%=P;
    }g[0]=1,g[1]=3;
    for(int i=2;i<=1000;++i){
        g[i]=f[i];
        for(int j=1;j<=i;++j)
            (g[i]+=g[j-1]*f[i-j])%=P;
    }cin>>n>>m;
    while(m--){
        int l,r,ans=1;cin>>l>>r;
        for(int i=l;i<=r;++i)
            a[i]^=1;
        for(int i=1;i<=n;++i){
            int j=i-1;
            while(j<n&&a[j+1]==0)++j;
            ans=ans*g[j-i+1]%P;//cout<<i<<' '<<j<<'\n';
            i=j+1;
        }cout<<ans<<'\n';
    }
    return 0;
}
```

你输出了 $g_i$，发现 $g_i=3^i$，然后相当于求 $a$ 中 $0$ 的个数 $x$，最终输出 $3^x$ 就行。实现的话用动态开点线段树即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid (l+r>>1)
using namespace std;
const int N=4e5+5,M=2e7,P=1e9+7;
int qp(int x,int y){
    int res=1;
    for(;y;y>>=1,x=x*x%P)
        if(y&1)res=res*x%P;
    return res;
}int n,m,rt,tot;
struct node{int ls,rs,w,tag;}a[M];
void f(int p,int l,int r){
    a[p].tag^=1;
    a[p].w=r-l+1-a[p].w;
}void pd(int p,int l,int r){
    if(!a[p].tag)return;
    if(!a[p].ls)a[a[p].ls=++tot].w=mid-l+1;
    if(!a[p].rs)a[a[p].rs=++tot].w=r-mid;
    f(a[p].ls,l,mid),f(a[p].rs,mid+1,r);a[p].tag=0;
}void update(int &p,int l,int r,int L,int R){
    if(!p)a[p=++tot].w=r-l+1;
    if(L<=l&&r<=R)return f(p,l,r);pd(p,l,r);
    if(L<=mid)update(a[p].ls,l,mid,L,R);
    if(mid<R)update(a[p].rs,mid+1,r,L,R);
    a[p].w=(a[p].ls?a[a[p].ls].w:mid-l+1)+(a[p].rs?a[a[p].rs].w:r-mid);
}signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    a[rt=tot=1].w=n;
    while(m--){
        int l,r;cin>>l>>r;
        update(rt,1,n,l,r);
        cout<<qp(3,a[rt].w)<<'\n';
    }return 0;
}
```

为什么 $g_i=3^i$ 呢？考虑每个位置只有不操作，填 $-1$，操作填数共 $3$ 种选择，每个不同的操作都唯一对应一种序列，然后就是 $3^i$ 了。有些诈骗题的感觉。

---

## 作者：zxdjmq (赞：1)

# P11754 [COCI 2024/2025 #5] 绘图 / Crtež

更好的阅读体验：[本人的博客园](https://www.cnblogs.com/zxdjmq/p/18759032)

## 解法说明

题面复杂程度可以说是非常诈骗。本题代码难度不高，难度主要在理解题面。

无论如何操作，初始序列都是由 $-1$ 间隔开的 $0$ 的连续段。

根据操作说明，我们可以知道两个 $0$ 的连续段不会互相影响，并且要求的是互不等价的最终序列的方案数，所以根据乘法原理，总方案数就是各个连续段方案数之积。

但是这个也很难求，可以手模一下找规律。设连续段长度为 $l$。

$l=1$ 时，有 $3$ 种方案：$[0],[-1],[1]$；

$l=2$ 时，有 $9$ 种方案：$[-1,-1],[-1,0],[-1,1],[0,-1],[0,0],[1,-1],[1,0],[1,1],[1,2]$。

聪明的你一定已经发现了规律并通过第三个样例验证了该规律：长为 $l$ 的连续段的方案数为 $3^l$。

当然还有另一种找规律方法：dp

设 $dp_{i,0/1/2/3}$ 表示第 $i$ 位分别为 $-1$，$0$，新数字，上一位填的数字的方案数。

则可以得到转移方程：

$$
\begin{cases}
dp_{i,0}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}\\
dp_{i,1}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}\\
dp_{i,2}=dp_{i-1,0}+dp_{i-1,2}+dp_{i-1,3}\\
dp_{i,3}=dp_{i-1,2}+dp_{i-1,3}
\end{cases}
$$

总方案数为四情况之和，容易发现总方案数都是 $3^i$。

综上，最终解法即为维护当前 $0$ 的数量 $t$ 并输出 $3^t$ 即可，此处使用动态开点线段树，空间卡的比较死。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define int long long
#define mid ((l+r)>>1)
const int N=1e6+10,qq=1e5+10,mod=1e9+7;

int n,Q;

il int qpow(int x,int y){
    int res=1;
    while(y){
        if(y&1)res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}

// 动态开点线段树
struct Segment_Tree{
    int t[qq<<8];
    signed ls[qq<<8],rs[qq<<8];
    bool lz[qq<<8];
    int cnt=1;
    il void pu(int nw){
        t[nw]=t[ls[nw]]+t[rs[nw]];
    }
    il void pd(int l,int r,int nw){
        if(lz[nw]){
            if(!ls[nw])ls[nw]=++cnt;
            if(!rs[nw])rs[nw]=++cnt;
            t[ls[nw]]=(mid-l+1)-t[ls[nw]];
            t[rs[nw]]=(r-mid)-t[rs[nw]];
            lz[ls[nw]]^=1,
            lz[rs[nw]]^=1;
            lz[nw]=0;
        }
    }
    void modify(int l,int r,int S,int T,int nw){
        if(S<=l && r<=T){
            t[nw]=(r-l+1)-t[nw];
            lz[nw]^=1;
            return;
        }
        pd(l,r,nw);
        if(mid>=S){
            if(!ls[nw])ls[nw]=++cnt;
            modify(l,mid,S,T,ls[nw]);
        }
        if(mid<T){
            if(!rs[nw])rs[nw]=++cnt;
            modify(mid+1,r,S,T,rs[nw]);
        }
        pu(nw);
    }
}t;

//求总和直接t.t[1]即可。

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cin>>n>>Q;
    while(Q--){
        int l,r;
        cin>>l>>r;
        t.modify(1,n,l,r,1);
        cout<<qpow(3,n-t.t[1])<<'\n';
    }
    return 0;
}
```

---

## 作者：SunburstFan (赞：1)

## [P11753 [COCI 2024/2025 #5] 绘图 / Crtež 题解](https://www.luogu.com.cn/problem/P11753)

### 题目大意

给定一个长度为 $n$ 的序列，初始全为 $0$。每次给定区间 $[l,r]$，将区间内的 $0$ 和 $-1$ 互相翻转。每次操作后，求出能够以当前序列为基础，进行若干次填数操作得到的互不等价序列数量。

### 解题思路

对于每个位置，我们只关心它是 $0$ 还是 $-1$。用线段树维护区间翻转操作。

$n \leq 10^{18}$，不能直接建树，考虑离散化，每个 $0$ 可以贡献 $3$ 种状态（保持 $0$ or $-1$ or 正数）。

因此答案为 $3^{cnt0}$。

核心代码如下:

```cpp
// 线段树维护区间内0和-1的个数
namespace SGT{
    int tree[N<<2][2],rev[N<<2]; // [0]存0的个数,[1]存-1的个数
    
    void pushup(int rt){
        tree[rt][0]=tree[rt<<1][0]+tree[rt<<1|1][0];
        tree[rt][1]=tree[rt<<1][1]+tree[rt<<1|1][1];
    }

    void upd(int rt){
        swap(tree[rt][0],tree[rt][1]); // 翻转0和-1
        rev[rt]^=1;
    }

    void modify(int rt,int l,int r,int L,int R){
        if(L<=l&&r<=R){
            upd(rt);
            return;
        }
        pushdown(rt);
        int md=(l+r)>>1;
        if(L<=md)modify(lson,L,R);
        if(R>md)modify(rson,L,R);
        pushup(rt);
    }
}

// 每次查询时计算3^cnt0
printf("%lld\n",qpow(3,SGT::tree[1][0]));
```

时间复杂度 $O(q \log q)$。

---

## 作者：冷却心 (赞：0)

先给出结论：一个序列操作后的方案数为 $3^c$，其中 $c$ 为序列中 $0$ 的个数，或者说序列中任意一个 $0$ 的操作为 $-1$，操作为赋值，不操作，都对应了一种不同的方案。

我们先考虑序列全部为 $0$，设长度为 $n$。因为序列要重标号，所以操作顺序无关，于是我们从前往后考虑每个 $0$ 的决策：

- 赋值为 $-1$：容易注意到除了这种操作以外任何的操作都不能使得这一位为 $-1$，所以是一种方案。
- 赋值为某个正标号或者不操作：前者即为把当前位置和后一位断开，后者是连在一起，显然任意标号时这两种方案都恒不一样，所以各自都能计入答案。

所以该序列的方案数为 $3^n$，再考虑有 $-1$ 的序列，显然不同的 $0$ 极长连续段互相独立，所以相乘得到结论。

然后就变成区间取反，区间求 $0$ 个数，但是值域很大，离散化之后线段树做完了。时间复杂度 $\mathcal O(q(\log n+\log q))$。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 2e5 + 10;
const LL MOD = 1e9 + 7;
LL Qpow(LL x, LL k, LL P) {
	LL ret = 1, tmp = (x + P) % P;
	while (k) {
		if (k & 1) ret = ret * tmp % P;
		tmp = tmp * tmp % P; k >>= 1;
	} return ret;
}
LL n, tmp[N], m; int Q; pair<LL, LL> qry[N];

#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
LL tr[N << 2]; bool tag[N << 2];
void f(int p, int l, int r) { tag[p] ^= 1; tr[p] = tmp[r + 1] - tmp[l] - tr[p]; }
void pushdown(int p, int l, int r) {
	int mid = (l + r) >> 1; if (tag[p]) f(ls(p), l, mid), f(rs(p), mid + 1, r), tag[p] = 0;
}
void update(int p, int l, int r, int x, int y) {
	if (x > r || y < l) return ;
	if (x <= l && y >= r) { f(p, l, r); return ; }
	int mid = (l + r) >> 1; pushdown(p, l, r);
	update(ls(p), l, mid, x, y), update(rs(p), mid + 1, r, x, y);
	tr[p] = tr[ls(p)] + tr[rs(p)]; return ;
}

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> Q; m = 2; tmp[1] = 0; tmp[2] = n + 1; LL u, v;
	for (int i = 1; i <= Q; i ++) {
		cin >> u >> v; qry[i] = {u, v}; tmp[++ m] = u, tmp[++ m] = v + 1;
	} sort(tmp + 1, tmp + 1 + m); m = unique(tmp + 1, tmp + 1 + m) - tmp - 1;
	for (int i = 1; i <= Q; i ++) {
		int l = lower_bound(tmp + 1, tmp + 1 + m, qry[i].first) - tmp,
			r = lower_bound(tmp + 1, tmp + 1 + m, qry[i].second + 1) - tmp - 1;
		update(1, 1, m - 1, l, r); cout << Qpow(3, n - tr[1], MOD) << "\n";
	}
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

[Link](https://www.luogu.com.cn/problem/P11754)

## 1. Description

题面十分清晰了，这里不过多赘述。

## 2. Solution

我们首先考虑一个线性的 DP，定义 $f_{i,0/1/2}$ 表示第 $i$ 位为 $-1$ 或 $0$ 或 $>0$ 的方案数，那么转移显然：
$$
f_{i,0}=f_{i-1,0}+f_{i-1,1}+f_{i-1,2}\\
f_{i,1}=f_{i-1,0}+f_{i-1,1}+f_{i-1,2}\\
f_{i,2}=f_{i-1,0}+2\times f_{i-1,2}
$$
 那么我们就得到了一个 $O(nq)$ 的做法，可以得到 $20$ 分的好成绩了。

当然，如果你看出规律，发现答案一定是 $3$ 的正整数幂的话，那么就可以直接线段树维护了。

但是，如果没看出规律呢？我们发现这个转移显然可以使用矩阵优化，那么不妨将所有位置离散化后，使用线段树维护所有矩阵的乘积，但是这样区间取反就不好做了，但是难道这道题看不出规律就真的不可以写吗？

我们发现在可持久化文艺平衡树的[这篇题解](https://www.luogu.com.cn/article/z31y67gx)中，有一种不常见的区间翻转做法，此时我们借鉴这个写法，维护两棵平衡树，初始状态分别是全部为 $0$ 的序列的矩阵乘积和全部为 $-1$ 的序列的矩阵乘积，那么区间取反时，我们只需要分裂出两棵平衡树的对应区间，互换之后重新合并即可，这样的时间复杂度为 $O(q\log q)$，但是一交，居然 T 了？

这样写的常数确实挺大的，但是，我们可以把平衡树改成线段树，这样甚至不用线段树合并和分裂，直接交换对应的子节点即可，时间复杂度同样是 $O(q\log q)$，但是常数小了很多，最后再稍微卡一卡常，在吸氧的情况下，这样就过了！

## 3. Code

```c++
/*by qwer6*/
/*略去快读快写与缺省源*/
const int M=1e5+5,N=1e6+5,mod=1e9+7;
int q,tot;
ll n;
ll tmp[M<<1];
struct Query{
	ll l,r;
}a[M];
int add(int x,int y){
	x+=y;
	return x>=mod?x-mod:x;
}
int mul(int x,int y){
	long long res=1ll*x*y;
	return res>=mod?res%mod:res;
}
int add(int x,int y,int z){
	return add(add(x,y),z);
}
struct Mat{
	int c[3][3];
	Mat(int opt=-2){
		if(opt==0){
			c[0][0]=1,c[0][1]=1,c[0][2]=1;
			c[1][0]=1,c[1][1]=1,c[1][2]=0;
			c[2][0]=1,c[2][1]=1,c[2][2]=2;	
		}else if(opt==-1){
			c[0][0]=1,c[0][1]=0,c[0][2]=0;
			c[1][0]=1,c[1][1]=0,c[1][2]=0;
			c[2][0]=1,c[2][1]=0,c[2][2]=0;	
		}else{
			c[0][0]=1,c[0][1]=0,c[0][2]=0;
			c[1][0]=0,c[1][1]=1,c[1][2]=0;
			c[2][0]=0,c[2][1]=0,c[2][2]=1;	
		}
	}
	Mat operator *(const Mat &T){
		Mat res;
		res.c[0][0]=add(mul(c[0][0],T.c[0][0]),mul(c[0][1],T.c[1][0]),mul(c[0][2],T.c[2][0]));
		res.c[0][1]=add(mul(c[0][0],T.c[0][1]),mul(c[0][1],T.c[1][1]),mul(c[0][2],T.c[2][1]));
		res.c[0][2]=add(mul(c[0][0],T.c[0][2]),mul(c[0][1],T.c[1][2]),mul(c[0][2],T.c[2][2]));
		res.c[1][0]=add(mul(c[1][0],T.c[0][0]),mul(c[1][1],T.c[1][0]),mul(c[1][2],T.c[2][0]));
		res.c[1][1]=add(mul(c[1][0],T.c[0][1]),mul(c[1][1],T.c[1][1]),mul(c[1][2],T.c[2][1]));
		res.c[1][2]=add(mul(c[1][0],T.c[0][2]),mul(c[1][1],T.c[1][2]),mul(c[1][2],T.c[2][2]));
		res.c[2][0]=add(mul(c[2][0],T.c[0][0]),mul(c[2][1],T.c[1][0]),mul(c[2][2],T.c[2][0]));
		res.c[2][1]=add(mul(c[2][0],T.c[0][1]),mul(c[2][1],T.c[1][1]),mul(c[2][2],T.c[2][1]));
		res.c[2][2]=add(mul(c[2][0],T.c[0][2]),mul(c[2][1],T.c[1][2]),mul(c[2][2],T.c[2][2]));
		return res;
	}
	void print(){
		write(c[0][0]),Spa,write(c[0][1]),Spa,write(c[0][2]),Nxt; 
		write(c[1][0]),Spa,write(c[1][1]),Spa,write(c[1][2]),Nxt; 
		write(c[2][0]),Spa,write(c[2][1]),Spa,write(c[2][2]),Nxt; 
	}
};
Mat binpow(Mat a,ll b){
	Mat res;
	res.c[0][0]=1,res.c[0][1]=0,res.c[0][2]=0;
	res.c[1][0]=0,res.c[1][1]=1,res.c[1][2]=0;
	res.c[2][0]=0,res.c[2][1]=0,res.c[2][2]=1;	
	while(b){
		if(b&1)res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
struct Segment_tree{
	int num,rt1,rt2;
	int ls[M<<4],rs[M<<4];
	Mat c[M<<4];
	#define mid (l+r>>1)
	int New(){
		num++;
		ls[num]=rs[num]=0;
		c[num]=Mat();
		return num;
	}
	void pushup(int p){
		c[p]=c[ls[p]]*c[rs[p]];
	}
	int build(int l,int r,int opt){
		int p=New();
		if(l==r){
			if(~opt)c[p]=binpow(Mat(0),tmp[l+1]-tmp[l]);
			else c[p]=Mat(-1);
			return p;
		}
		ls[p]=build(l,mid,opt),rs[p]=build(mid+1,r,opt);
		pushup(p);
		return p;
	}
	pii change(int p,int q,int l,int r,int L,int R){
		if(L<=l&&r<=R)return {q,p};
		if(mid>=L){
			pii tmp=change(ls[p],ls[q],l,mid,L,R);
			ls[p]=tmp.first,ls[q]=tmp.second;
		}
		if(mid<R){
			pii tmp=change(rs[p],rs[q],mid+1,r,L,R);
			rs[p]=tmp.first,rs[q]=tmp.second;
		}
		pushup(p),pushup(q);
		return {p,q};
	}
	void init(){
		rt1=build(1,tot-1,0);
		rt2=build(1,tot-1,-1);
	}
	void change(int l,int r){
		pii tmp=change(rt1,rt2,1,tot-1,l,r);
		rt1=tmp.first,rt2=tmp.second;
	}
	int query(){
		return add(c[rt1].c[0][0],c[rt1].c[0][1],c[rt1].c[0][2]);
	}
	#undef mid
}Set;
signed main(){
	read(n),read(q);
	for(int i=1;i<=q;i++){
		read(a[i].l),read(a[i].r);
		tmp[++tot]=a[i].l;
		tmp[++tot]=a[i].r+1;
	}
	tmp[++tot]=1,tmp[++tot]=n+1;
	sort(tmp+1,tmp+tot+1);
	tot=unique(tmp+1,tmp+tot+1)-tmp-1;
	Set.init();
	for(int i=1,l,r;i<=q;i++){
		l=lower_bound(tmp+1,tmp+tot+1,a[i].l)-tmp;
		r=lower_bound(tmp+1,tmp+tot+1,a[i].r+1)-tmp;
		Set.change(l,r-1);
		write(Set.query()),Nxt;
	}
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

好神秘的题。

首先你观察到序列中的 $-1$ 相当于把这个序列切割成了多个段，你考虑具体的颜色并不重要，与答案相关的实际上是你填的颜色在之前是否出现过，所以每个段的贡献是相对独立的。

第一种操作相当于手动给这个序列继续分段，先考虑不填 $-1$ 的情况。设 $f_{i,0/1}$ 表示长度为 $i$ 的全 $0$ 序列，强制不填 $-1$，最后一位填的颜色是否为 $0$ 的填色方案。

$f_{i,1}=f_{i-1,0}+f_{i-1,1}$。原因显然，这一位只能填 $0$，上一位没有限制。

$f_{i,0}=2f_{i-1,1}$。上一位必须强制不为 $0$，可以选择一个存在过的颜色和一个新的颜色。

边界是 $f_{1,0}=f_{1,1}=1$。长度为 $i$ 的段答案显然为 $f_{i,0}+f_{i,1}$。

注意到 $f_{1,0}=f_{1,1}=1$，则 $f_{2,0/1}$ 中用于转移的两个位置取值一样，则 $f_{2,0}=f_{2,1}$。同理我们可以得到 $f_{i,0}=f_{i,1}$。所以我们可以直接得到递推的第 $i$ 项 $f_{i,0}+f_{i,1}=2^i$。

现在考虑加入 $-1$。这相当于将 $i$ 分为若干段，每一段单独考虑后乘起来。

所以长度为 $i$ 的段总答案 $g_i$ 为 $\sum_{k=1}^i {i\choose k}2^{i-k}$。

动用一点注意力可以注意到二项式定理 $(x+y)^n=\sum_{i=1}^n{n\choose i}x^iy^{n-i}$ 中取 $x=1,y=2$ 即有 $\sum_{i=1}^n{n\choose i}2^{n-i}=3^n$。即 $g_i=3^i$。非常优美的性质。

考虑到最后的答案为乘积的形式，我们只需要维护序列中 $0$ 的个数即可。

但是注意到这题 $n\le10^{18}$，动态开点的空间复杂度达到了惊人的 $O(q\log n)$，同时由于区间修改需要 pushdown 在 pushdown 时还可能需要新建节点，怀疑空间会炸。

于是考虑离散化。令离散化数组为 $p$，离散化后第 $i$ 个点实际含义指 $[p_i,p_{i+1})$ 一段。感觉很像矩形面积并的思想。

注意本题可能出现的单点修改，我的解决方法是对于出现的坐标 $l,r$ 在离散化的同时加入 $l+1,r+1$，这样就可以确保单点修改不会出错。

```cpp
#include <bits/stdc++.h>
#define lint __int128
#define int long long
#define fi first
#define se second
#define Il inline
#define vec vector
#define pb push_back
#define IT ::iterator
#define p_q priority_queue

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef double db;
const int N=1e5,mod=1e9+7;
const db eps=1e-9,pi=acos(-1.0);

mt19937 rnd(time(0));
Il int rint(int l,int r){return rnd()%(r-l+1)+l;}

Il int qpow(int x,int y){int t=1;for(;y;y>>=1ll,x=x*x%mod)if(y&1ll)t=t*x%mod;return t;}

int n,Q,lq[N+5],rq[N+5],lsh[(N<<2)+5],dn=0;
int sm[(N<<4)+5],tg[(N<<4)+5];

Il void Disc(){
    for(int i=1;i<=Q;i++)lsh[++dn]=lq[i],lsh[++dn]=rq[i],lsh[++dn]=lq[i]+1,lsh[++dn]=rq[i]+1;
    lsh[++dn]=n,lsh[++dn]=1;
    sort(lsh+1,lsh+dn+1);dn=unique(lsh+1,lsh+dn+1)-lsh-1;
    for(int i=1;i<=Q;i++)lq[i]=lower_bound(lsh+1,lsh+dn+1,lq[i])-lsh,rq[i]=lower_bound(lsh+1,lsh+dn+1,rq[i])-lsh;
    lsh[++dn]=n;//防止访问 n 时出错手动加上一个边界
    return;
}

Il void pown(int p,int l,int r){
    int mid=(l+r)>>1;if(!tg[p])return;
    sm[p<<1]=lsh[mid+1]-lsh[l]-sm[p<<1],tg[p<<1]^=1;
    sm[p<<1|1]=lsh[r+1]-lsh[mid+1]-sm[p<<1|1],tg[p<<1|1]^=1;
    tg[p]=0;
    return;
}

Il void rev(int ql,int qr,int l,int r,int p){
    if(ql>qr)return;
    if(ql<=l&&r<=qr){sm[p]=lsh[r+1]-lsh[l]-sm[p],tg[p]^=1;return;}
    int mid=(l+r)>>1;pown(p,l,r);
    if(ql<=mid)rev(ql,qr,l,mid,p<<1);
    if(qr>mid)rev(ql,qr,mid+1,r,p<<1|1);
    sm[p]=sm[p<<1]+sm[p<<1|1];
    return;
}

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>Q;for(int _=1;_<=Q;_++)cin>>lq[_]>>rq[_];
    Disc();for(int _=1;_<=Q;_++)rev(lq[_],rq[_],1,dn,1),cout<<qpow(3,n-sm[1])<<'\n';
    return 0;
}
```

---

## 作者：gdf_yhm (赞：0)

[P11754](https://www.luogu.com.cn/problem/P11754)

人都傻了。

### 思路

重标号 $>0$ 的元素，所以操作可以认为直接从左到右。对于每个 $a_i=0$ 的点可以选择：赋值 $-1$，不操作，赋值为 $x$（但是编号不区分）。所以答案等价于 $3^{cnt0}$。

离散化后线段树维护每个区间 $0$ 的个数。

### code

```cpp
int n,q;
inline int ksm(int a,int b=mod-2){
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int lsh[maxn],len;
pii que[maxn];
#define mid (l+r>>1)
#define ls nd<<1
#define rs nd<<1|1
int tree[maxn<<2][2],rev[maxn<<2];
void build(int nd,int l,int r){
	tree[nd][0]=lsh[r+1]-lsh[l];
	if(l==r)return ;
	build(ls,l,mid),build(rs,mid+1,r);
}
void upd(int nd){swap(tree[nd][0],tree[nd][1]),rev[nd]^=1;}
void down(int nd){upd(ls),upd(rs),rev[nd]=0;}
void updata(int nd,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr)return upd(nd);
	if(rev[nd])down(nd);
	if(ql<=mid)updata(ls,l,mid,ql,qr);
	if(qr>mid)updata(rs,mid+1,r,ql,qr);
	tree[nd][0]=tree[ls][0]+tree[rs][0];
	tree[nd][1]=tree[ls][1]+tree[rs][1];
}
void work(){
	n=read();q=read();
	for(int i=1;i<=q;i++){
		int u=read(),v=read();
		que[i]={u,v};
		lsh[++len]=u,lsh[++len]=v+1;
	}
	lsh[++len]=1;lsh[++len]=n+1;
	sort(lsh+1,lsh+len+1);len=unique(lsh+1,lsh+len+1)-lsh-1;
	len--;build(1,1,len);
	for(int i=1;i<=q;i++){
		auto[l,r]=que[i];
		l=lower_bound(lsh+1,lsh+len+2,l)-lsh;
		r=lower_bound(lsh+1,lsh+len+2,r+1)-lsh-1;
		updata(1,1,len,l,r);
		printf("%lld\n",ksm(3,tree[1][0]));
	}
}
```

---


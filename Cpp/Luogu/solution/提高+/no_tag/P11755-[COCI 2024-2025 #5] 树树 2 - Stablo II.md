# [COCI 2024/2025 #5] 树树 2 / Stablo II

## 题目背景

译自 [COCI 2024/2025 #5](https://hsin.hr/coci/) T5。$\texttt{3.5s,0.5G}$。满分为 $120$。


## 题目描述


给定 $n$ 个节点的树，初始时所有边边权为 $0$。

$q$ 次操作，第 $i$ 次操作将 $u,v$ 最短路径上的边权**覆盖**为 $i$。

最终输出每条边的边权。


## 说明/提示


#### 数据范围

对于 $100\%$ 的数据，保证：
- $2\le n\le 10^6$；
- $1\le q\le 10^6$；
- $1\le u,v\le n$。

| 子任务编号 |  $n\le$ | 特殊性质 | 得分 |  
| :--: | :--: | :--: | :--: |
| $ 1 $    |  $10^6$  | A  | $ 15 $   |  
| $ 2 $    |  $2\times 10^3$  | B | $ 15 $   |  
| $ 3 $    |  $10^5$  |  | $ 45 $   |  
| $ 4 $    |  $10^6$  |  | $ 45 $   |  

- 特殊性质 A：$u_i=i,v_i=i+1$。
- 特殊性质 B：$q\le 2\times 10^3$。

## 样例 #1

### 输入

```
6 2
1 2
2 3
2 4
1 5
4 6
5 2
6 1```

### 输出

```
2 0 2 1 2```

## 样例 #2

### 输入

```
5 4
1 2
2 3
3 4
4 5
5 5
4 3
2 1
2 4```

### 输出

```
3 4 4 0```

## 样例 #3

### 输入

```
5 4
3 5
2 3
4 3
5 1
4 1
5 5
4 2
1 5```

### 输出

```
1 3 3 4```

# 题解

## 作者：FFTotoro (赞：8)

最朴素的做法是树剖 + 线段树维护，时间复杂度 $O(n\log^2n)$，需要较优秀的常数以通过。

如果我们将所有操作反转（即从后往前做），一条边被覆盖一次后就不用再被考虑，于是可以使用并查集维护，时间复杂度 $O(n\log n\alpha(n))$。

倒着做的思路启发了我们，能否不使用树剖？有一个很直接的想法，对于一组询问 $(u,v)$ 直接暴力跳祖先，跳的过程中将整条路径缩成一个点（可以用并查集维护），于是可以做到 $O(n\alpha(n))$。实现时有一些细节，具体可以参考代码。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
namespace IAOI_lib{
  template<typename T> class dsu{
    private:
      vector<T> a;
      vector<int> s;
    public:
      dsu(int n=2e5){
        a.resize(n),s.resize(n,1);
        iota(a.begin(),a.end(),0);
      }
      T leader(T x){
        return a[x]==x?x:a[x]=leader(a[x]);
      }
      inline int size(T x){
        return s[leader(x)];
      }
      inline void merge(T x,T y){
        x=leader(x),y=leader(y);
        if(x==y)return;
        if(s[x]>s[y])swap(x,y);
        s[y]+=s[x],a[x]=y;
      }
      inline bool same(T x,T y){
        return leader(x)==leader(y);
      }
  };
}
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n,q; cin>>n>>q;
  vector<vector<pii> > g(n);
  vector<int> r(n-1,-1),f(n),w(n),l(n);
  // r[i] 表示第 i 条边的答案，f[u] 表示 u 的父亲
  // w[u] 表示 u 到父亲的边的编号，l[u] 表示 u 的深度
  for(int i=0;i<n-1;i++){
    int u,v; cin>>u>>v;
    g[--u].emplace_back(--v,i);
    g[v].emplace_back(u,i);
  }
  auto dfs=[&](auto &&self,int u)->void{
    for(auto [i,x]:g[u])
      if(i!=f[u])l[i]=l[f[i]=u]+1,w[i]=x,self(self,i);
  }; // 预处理初始信息
  dfs(dfs,0);
  vector<pii> a(q);
  for(auto &[u,v]:a)cin>>u>>v,u--,v--;
  IAOI_lib::dsu<int> d(n);
  auto cp=[&](int x,int y){
    f[x]=f[y],w[x]=w[y],l[x]=l[y];
  }; // 并查集中的代表元发生变化，将后者的信息转换到前者便于维护
  for(int i=q-1;~i;i--){
    auto [u,v]=a[i];
    u=d.leader(u),v=d.leader(v);
    while(u!=v){
      if(l[u]>l[v]){
        int x=d.leader(f[u]);
        r[w[u]]=i,d.merge(u,x);
        if(d.leader(x)==u)cp(u,x);
        else u=x;
      } // 选深度大的跳
      else{
        int x=d.leader(f[v]);
        r[w[v]]=i,d.merge(v,x);
        if(d.leader(x)==v)cp(v,x);
        else v=x;
      }
      u=d.leader(u),v=d.leader(v);
    }
  }
  for(int i:r)cout<<i+1<<' ';
  cout<<endl;
  return 0;
}
```

---

## 作者：jiangxinyang2012 (赞：6)

这篇题解将手把手教会你如何卡常。

首先考虑树剖。因为每个子节点只有一个父节点，所以可以拿每个子节点存连接它和它的父亲的那条边的边权。每次只要修改 $u$ 到 $v$ 的点权就好了。这样可以获得 $75$ 分的高分。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
struct node {
    int l, r, col;
} tri[N * 4];
struct edge {
    int u, v;
} e[N];
int n, m, dep[N], fa[N], top[N], pos[N], sz[N], cnt, son[N];
vector<int> g[N];
void build(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    sz[u] = 1;
    for (auto v : g[u]) {
        if (v == f) continue;
        build(v, u);
        if (sz[v] > sz[son[u]]) {
            son[u] = v;
        }
        sz[u] += sz[v];
    }
}
void dfs(int u, int h) {
    top[u] = h;
    pos[u] = ++cnt;
    if (son[u] != 0) dfs(son[u], h);
    for (int v : g[u]) {
        if (v == fa[u] || v == son[u]) {
            continue;
        }
        dfs(v, v);
    }
}
void build_tri(int p, int l, int r) {
    tri[p].l = l;
    tri[p].r = r;
    tri[p].col = -1;
    if (l == r) {
        tri[p].col = 0;
        return;
    }
    int mid = l + r >> 1;
    build_tri(p << 1, l, mid);
    build_tri(p << 1 | 1, mid + 1, r);
}
void pushdown(int p) {
    if (tri[p].l == tri[p].r || tri[p].col == -1) {
        return;
    }
    tri[p << 1].col = tri[p << 1 | 1].col = tri[p].col;
    tri[p].col = -1;
}
void update(int p, int l, int r, int col) {
    if (tri[p].l >= l && tri[p].r <= r) {
        tri[p].col = col;
        return;
    }
    pushdown(p);
    int mid = tri[p].l + tri[p].r >> 1;
    if (l <= mid) {
        update(p << 1, l, r, col);
    }
    if (r > mid) {
        update(p << 1 | 1, l, r, col);
    }
}
int query(int p, int x) {
    if (tri[p].l == tri[p].r) return tri[p].col;
    pushdown(p);
    int mid = tri[p].l + tri[p].r >> 1;
    if (x <= mid) {
        return query(p << 1, x);
    } else {
        return query(p << 1 | 1, x);
    }
}
void update_path(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) {
            swap(x, y);
        }
        update(1, pos[top[x]], pos[x], k);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) {
        swap(x, y);
    }
    update(1, pos[x] + 1, pos[y], k);
}
int query_path(int x, int y) {
    if (fa[x] == y) {
        return query(1, pos[x]);
    } else {
        return query(1, pos[y]);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
        e[i] = {u, v};
    }
    build(1, 0);
    dfs(1, 1);
    build_tri(1, 1, n);
    for (int i = 1; i <= m; i++) {
        int x, y, col = i;
        scanf("%d%d", &x, &y);
        update_path(x, y, col);
    }
    for (int i = 1; i < n; i++) {
        printf("%d ", query_path(e[i].u, e[i].v));
    }
    return 0;
}

```

这个时候你发现超时的点数不多，明显卡卡常就能过去。

于是考虑卡常。

先将线段树的修改操作离线，存在一个 vector 里面，最后一起修改。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
struct node {
    int l, r, col;
} tri[N * 4];
char *p1, *p2, buf[100000];
#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
    int x = 0, f = 1;
    char ch = nc();
    while (ch < 48 || ch > 57) {
        if (ch == '-')
            f = -1;
        ch = nc();
    }
    while (ch >= 48 && ch <= 57)
        x = x * 10 + ch - 48, ch = nc();
    return x * f;
}
struct edge {
    int u, v;
} e[N];
int n, m, dep[N], fa[N], top[N], pos[N], sz[N], cnt, son[N];
vector<int> g[N];
inline void build(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    sz[u] = 1;
    for (auto v : g[u]) {
        if (v == f) {
            continue;
        }
        build(v, u);
        if (sz[v] > sz[son[u]]) {
            son[u] = v;
        }
        sz[u] += sz[v];
    }
}
inline void func(int u, int tot) {
    top[u] = tot;
    pos[u] = ++cnt;
    if (son[u] != 0) {
        func(son[u], tot);
    }
    for (int v : g[u]) {
        if (v == fa[u] or v == son[u]) {
            continue;
        }
        func(v, v);
    }
}
inline void build_tri(int p, int l, int r) {
    tri[p].l = l;
    tri[p].r = r;
    tri[p].col = -1;
    if (l == r) {
        tri[p].col = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build_tri(p << 1, l, mid);
    build_tri(p << 1 | 1, mid + 1, r);
}
inline void pushdown(int p) {
    if (tri[p].l == tri[p].r or tri[p].col == -1) {
        return;
    }
    tri[p << 1].col = tri[p << 1 | 1].col = tri[p].col;
    tri[p].col = -1;
}
inline void update(int p, int l, int r, int col) {
    if (tri[p].l >= l and tri[p].r <= r) {
        tri[p].col = col;
        return;
    }
    pushdown(p);
    int mid = (tri[p].l + tri[p].r) >> 1;
    if (l <= mid) {
        update(p << 1, l, r, col);
    }
    if (r > mid) {
        update(p << 1 | 1, l, r, col);
    }
}
inline int query(int p, int x) {
    if (tri[p].l == tri[p].r) {
        return tri[p].col;
    }
    pushdown(p);
    int mid = (tri[p].l + tri[p].r) >> 1;
    if (x <= mid) {
        return query(p << 1, x);
    } else {
        return query(p << 1 | 1, x);
    }
}
struct Node {
    int x, y, k;
};
vector<Node> vec;
inline void update_path(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) {
            swap(x, y);
        }
        // update(1, pos[top[x]], pos[x], k);
        vec.push_back({pos[top[x]], pos[x], k});
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) {
        swap(x, y);
    }
    vec.push_back({pos[x] + 1, pos[y], k});
    // update(1, pos[x] + 1, pos[y], k);
}
inline int query_path(int x, int y) {
    if (fa[x] == y) {
        return query(1, pos[x]);
    } else {
        return query(1, pos[y]);
    }
}
int main() {
    n = read(), m = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read();
        g[u].push_back(v);
        g[v].push_back(u);
        e[i] = {u, v};
    }
    build(1, 0);
    func(1, 1);
    build_tri(1, 1, n);
    for (int i = 1; i <= m; i++) {
        int x = read(), y = read(), col = i;
        update_path(x, y, col);
    }
    for (auto [x, y, k] : vec) {
        update(1, x, y, k);
    }
    for (int i = 1; i < n; i++) {
        printf("%d ", query_path(e[i].u, e[i].v));
    }
    return 0;
}

```
这份代码快的起飞，只超时 $4$ 个点。

这时，你发现因为查询都在修改之后，而且每个位置在查询时都会被访问多次，所以给它记忆化一下就过了。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
struct node {
    int l, r, col;
} tr[N * 4];
char *p1, *p2, buf[100000];
#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
    int x = 0, f = 1;
    char ch = nc();
    while (ch < 48 || ch > 57) {
        if (ch == '-')
            f = -1;
        ch = nc();
    }
    while (ch >= 48 && ch <= 57) x = x * 10 + ch - 48, ch = nc();
    return x * f;
}
void write(const int &x) {
    int num = x;
    string str;
    do {
        str.push_back(num % 10 + '0');
        num /= 10;
    } while (num);
    for (int i = str.size() - 1; i >= 0; i--) putchar(str[i]);
    return;
}
struct edge {
    int u, v;
} e[N];
int n, m, dep[N], fa[N], top[N], pos[N], sz[N], cnt, son[N];
vector<int> g[N];
inline void build(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    sz[u] = 1;
    for (auto v : g[u]) {
        if (v == f) continue;
        build(v, u);
        if (sz[v] > sz[son[u]]) son[u] = v;
        sz[u] += sz[v];
    }
}
inline void dfs(int u, int h) {
    top[u] = h;
    pos[u] = ++cnt;
    if (son[u]) dfs(son[u], h);
    for (auto v : g[u]) {
        if (v == fa[u] || v == son[u]) continue;
        dfs(v, v);
    }
}
inline void build_tri(int u, int l, int r) {
    tr[u].l = l;
    tr[u].r = r;
    tr[u].col = -1;
    if (l == r) {
        tr[u].col = 0;
        return;
    }
    int mid = l + r >> 1;
    build_tri(u << 1, l, mid);
    build_tri(u << 1 | 1, mid + 1, r);
}
inline void pushdown(int u) {
    if (tr[u].l == tr[u].r || tr[u].col == -1) return;
    tr[u << 1].col = tr[u << 1 | 1].col = tr[u].col;
    tr[u].col = -1;
}
inline void update(int u, int l, int r, int col) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].col = col;
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) update(u << 1, l, r, col);
    if (r > mid) update(u << 1 | 1, l, r, col);
}
int f[N << 2];
inline int query(int u, int x) {
    if (tr[u].l == tr[u].r) return tr[u].col;
    pushdown(u);
    if (f[x]) return f[x];
    int mid = tr[u].l + tr[u].r >> 1;
    if (x <= mid) {
        return f[x] = query(u << 1, x);
    } else {
        return f[x] = query(u << 1 | 1, x);
    }
}
struct Node {
    int x, y, k;
};
vector<Node> vec;
inline void update_path(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        vec.push_back({pos[top[x]], pos[x], k});
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) {
        swap(x, y);
    }
    vec.push_back({pos[x] + 1, pos[y], k});
}
inline int query_path(int x, int y) {
    if (fa[x] == y) {
        return query(1, pos[x]);
    } else {
        return query(1, pos[y]);
    }
}
int main() {
    n = read(), m = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read();
        g[u].push_back(v);
        g[v].push_back(u);
        e[i] = {u, v};
    }
    build(1, 0);
    dfs(1, 1);
    build_tri(1, 1, n);
    for (int i = 1; i <= m; i++) {
        int x = read(), y = read();
        update_path(x, y, i);
    }
    for (auto [x, y, k] : vec) update(1, x, y, k);
    for (int i = 1; i < n; i++) {
        write(query_path(e[i].u, e[i].v));
        putchar(' ');
    }
    return 0;
}

```
[AC记录](https://www.luogu.com.cn/record/203762964)

---

## 作者：cybermage_liu (赞：4)

一眼就认出了正解是树剖，甚至比[【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)还简单。

时间复杂度 $O(n\log^2{n})$，卡一下常就能过。

如果会树剖的话只要边权转点权就行了。

我们可以把一条边的边权当作这条边深度较大的节点的点权。

如图，以样例 $1$ 最终结果为例，节点内左边较大数字为编号，右边较小数字为转化后的点权，边上数字为边权。
![](https://cdn.luogu.com.cn/upload/image_hosting/9zm9bl56.png)
# AC code

```cpp
#include<bits/stdc++.h>
#define int long long
#define nc() getchar()
using namespace std;
const int N=1e6+5;
int n,q,t[N<<2],uu[N],vv[N];
int head[N],ver[N<<1],nxt[N<<1],tot=0;//链式前向星三件套 
int top[N],id[N],dep[N],fa[N],size[N],son[N],tot2=0;//朴实无华的树剖 
//top重链的开端 
//id在线段树中的位置 
//dep节点深度
//fa节点父亲
//size子树大小 
//son重儿子 
inline int read(){
	int x=0,f=1;
	char ch=nc();
	while(ch<48||ch>57){
		if(ch=='-') f=-1;
		ch=nc();
	}
	while(ch>=48&&ch<=57) x=x*10+ch-48,ch=nc();
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
void add(int x,int y){//加边 
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
void pushdown(int k,int l,int r,int mid){
	if(!t[k]) return;
	t[k<<1]=t[k];
	t[k<<1|1]=t[k];
	t[k]=0;
}
void change(int k,int l,int r,int x,int y,int z){//区间修改 
	if(x<=l && r<=y){
		t[k]=z;
		return;
	}
	int mid=l+r>>1;
	pushdown(k,l,r,mid);
	if(x<=mid) change(k<<1,l,mid,x,y,z);
	if(mid<y) change(k<<1|1,mid+1,r,x,y,z);
}
void change_chain(int x,int y,int z){//将x到y的路径上的边权修改为z 
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		change(1,1,n,id[top[x]],id[x],z);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(x!=y) change(1,1,n,id[x]+1,id[y],z);
	//注意是in[x]+1，x和y的最近公共祖先的点权不修改 
}
int query(int k,int l,int r,int x){//单点查询
	if(l==r) return t[k];
	int mid=l+r>>1;
	pushdown(k,l,r,mid);
	if(x<=mid) return query(k<<1,l,mid,x);
	else return query(k<<1|1,mid+1,r,x);
}
void dfs1(int u,int father){
	fa[u]=father;dep[u]=dep[fa[u]]+1;size[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa[u]) continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int top_){ 
	id[u]=++tot2;top[u]=top_;
	if(son[u]) dfs2(son[u],top_);
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(v==fa[u] || v==son[u]) continue;
		dfs2(v,v);
	}
}
signed main(){
	cin>>n>>q;
	for(int i=1;i<n;i++){
		uu[i]=read();vv[i]=read();//记录第i条边 
		add(uu[i],vv[i]);add(vv[i],uu[i]);
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=q;i++){
		int x=read(),y=read();
		change_chain(x,y,i);
	}
	for(int i=1;i<n;i++){
		if(dep[uu[i]]>dep[vv[i]]) write(query(1,1,n,id[uu[i]])),putchar(' ');
		else write(query(1,1,n,id[vv[i]])),putchar(' ');
		//一条边中深度较大的节点点权即这条边的边权
//不懂的话看上面的图 
	}
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

给定 $n$ 个节点的树，初始时所有边边权为 $0$。

$q$ 次操作，第 $i$ 次操作将 $u$，$v$ 最短路径上的边权覆盖为 $i$。

最终输出每条边的边权。

## Solution

这是一道非常模板的线段树加树链剖分题，需要注意修改的是边权，我们可以将边权的值存在一条边上最下面的那个点上来实现。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,q,x,y,tot,cnt;
int fa[N],dep[N],siz[N],son[N],top[N],dfn[N],rnk[N],head[N],tree[N<<2],lazy[N<<2];
struct node{
	int x,y;
}nex[N<<1];
void add(int x,int y){
	tot++;
	nex[tot].x=y;
	nex[tot].y=head[x];
	head[x]=tot;
}
void dfs1(int node){
	siz[node]=1;
	for(int i=head[node];i;i=nex[i].y){
		int w=nex[i].x;
		if(w!=fa[node]){
			fa[w]=node;
			dep[w]=dep[node]+1;
			dfs1(w);
			siz[node]+=siz[w];
			if(siz[w]>siz[son[node]])
				son[node]=w;
		}
	}
}
void dfs2(int node,int x){
	top[node]=x;
	cnt++;
	dfn[cnt]=node;
	rnk[node]=cnt;
	if(!son[node])
		return;
	dfs2(son[node],x);
	for(int i=head[node];i;i=nex[i].y){
		int w=nex[i].x;
		if(w!=fa[node]&&w!=son[node])
			dfs2(w,w);
	}
}
void pushdown(int node){
	tree[node<<1]=lazy[node];
	tree[node<<1|1]=lazy[node];
	lazy[node<<1]=lazy[node];
	lazy[node<<1|1]=lazy[node];
	lazy[node]=0;
}
void update(int node,int l,int r,int x,int y,int val){
	if(x<=l&&r<=y){
		tree[node]=val;
		lazy[node]=val;
		return;
	}
	if(lazy[node])
		pushdown(node);
	int mid=l+r>>1;
	if(x<=mid)
		update(node<<1,l,mid,x,y,val);
	if(mid<y)
		update(node<<1|1,mid+1,r,x,y,val);
}
int query(int node,int l,int r,int x){
	if(l==r)
		return tree[node];
	if(lazy[node])
		pushdown(node);
	int mid=l+r>>1;
	if(x<=mid)
		return query(node<<1,l,mid,x);
	else
		return query(node<<1|1,mid+1,r,x);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=q;i++){
		cin>>x>>y;
		while(top[x]!=top[y]){
			if(dep[top[x]]<dep[top[y]])
				swap(x,y);
			update(1,1,n,rnk[top[x]],rnk[x],i);
			x=fa[top[x]];
		}
		if(dep[x]>dep[y])
			swap(x,y); 
		update(1,1,n,rnk[x]+1,rnk[y],i);
	}
	for(int i=1;i<n;i++)
		cout<<query(1,1,n,rnk[dep[nex[i<<1].x]>dep[nex[(i<<1)-1].x]?nex[i<<1].x:nex[(i<<1)-1].x])<<" ";
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11755)

加上快读之后顺利场切，来写篇题解。~~不会好不容易场切然后代码又写麻烦了吧。~~

暴力写起来不难，但时间复杂度会输掉。优化的话我用的是重链剖分加线段树。

先用邻接表来建树，记录一下第 $i$ 条边的两个节点，然后用两次 dfs 来处理。第一次把每个节点的深度、父节点、子树大小和重儿子都计算出来，第二次对树进行重链剖分，为每个节点分配在线段树中的编号，并确定每个节点所在重链的链头。然后更新边权，最后利用函数查询第 $i$ 条边的边权并输出。

一些比较重要的信息在代码中也有注释。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1e6 + 5;

int dep[N], fa[N], top[N], son[N], sz[N], id[N], rk[N], lazy[N * 4], eid[N][2];
// dep 存储每个节点的深度
// fa 存储每个节点的父节点
// top 存储每个节点所在重链的链头节点
// son 存储每个节点的重儿子
// sz 存储以每个节点为根的子树的节点数量
// id 存储每个节点在线段树中的编号
// rk 存储线段树编号对应的节点
// lazy 是线段树的懒惰标记数组
// e 存储每条边的两个端点
vector<int> G[N];
// G 是邻接表

template<typename T>inline void read(T &x)
{
    bool f = 1; x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = !f; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    x = (f ? x : -x); return;
}

inline void dfs1(int u, int f, int d) { // 计算每个节点的深度、父节点、子树大小和重儿子
    dep[u] = d, fa[u] = f, sz[u] = 1;
    for (int v : G[u])
        if (v != f) {
            dfs1(v, u, d + 1);
            sz[u] += sz[v]; // 更新当前节点 u 的子树大小，加上子节点 v 的子树大小
            if (sz[son[u]] < sz[v]) son[u] = v; // 将 v 设为当前节点 u 的重儿子
        }
}

inline void dfs2(int u, int f) { // 重链剖分
    id[u] = ++id[0], rk[id[u]] = u, top[u] = f;
    if (son[u]) dfs2(son[u], f); // 优先对重儿子进行 dfs2 操作
    for (int v : G[u])
        if (v != fa[u] && v != son[u]) dfs2(v, v);
}

inline void pushdown(int rt) { // 懒惰标记
    if (lazy[rt]) {
        lazy[rt << 1] = lazy[rt];
        lazy[rt << 1 | 1] = lazy[rt];
        lazy[rt] = 0;
    }
}

inline void upd(int rt, int l, int r, int L, int R, int val) { // 区间修改
    if (L <= l && r <= R) {
        lazy[rt] = val;
        return;
    } pushdown(rt);
    int mid = (l + r) >> 1;
    if (L <= mid) upd(rt << 1, l, mid, L, R, val);
    if (R > mid) upd(rt << 1 | 1, mid + 1, r, L, R, val);
}

inline int query(int rt, int l, int r, int pos) { // 单点查询
    if (l == r) return lazy[rt];
    pushdown(rt);
    int mid = (l + r) >> 1;
    if (pos <= mid) return query(rt << 1, l, mid, pos);
    else return query(rt << 1 | 1, mid + 1, r, pos);
}

inline void update(int u, int v, int val) { // 修改边权
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v); // 选择所在重链链头深度较大的节点设为 u
        upd(1, 1, id[0], id[top[u]], id[u], val); // 对 u 所在重链从链头到 u 对应的线段树区间进行修改
        u = fa[top[u]]; // 将 u 更新为其所在重链链头的父节点
    } if (dep[u] > dep[v]) swap(u, v); // 确保 u 的深度小于 v 的深度
    if (id[u] + 1 <= id[v]) upd(1, 1, id[0], id[u] + 1, id[v], val); // 若 u 和 v 之间存在节点则修改区间
}

int main() {
    ios::sync_with_stdio(false);
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    int n, q;
    read(n), read(q); 
    for (int i = 1; i < n; i++) {
        int u, v;
        read(u), read(v);
        G[u].push_back(v);
        G[v].push_back(u);
        eid[i][0] = u, eid[i][1] = v;
    } dfs1(1, 0, 1), dfs2(1, 1);
    for (int i = 1; i <= q; i++) {
        int u, v;
        read(u), read(v);
        update(u, v, i);
    } for (int i = 1; i < n; i++) {
        int u = eid[i][0], v = eid[i][1];
        if (dep[u] < dep[v]) swap(u, v); // 确保 u 是深度较大的节点
        printf("%d ", query(1, 1, id[0], id[u]));
    }
    return 0;
}
```

---

## 作者：AzusidNya (赞：2)

可能有人看到这个题可能会想树剖线段树直接做，不过复杂度和代码难度都较高。

考虑离线后倒序处理操作。这样每条边只会被第一次影响它的操作覆盖，也就是每条边只会被覆盖一次。

那么现在只需要做到高效地跳过已经被覆盖过的边，精确地找到一次操作需要影响的边即可。

边转点，用一条边连接的点中深度较大的点表示这条边。

考虑使用并查集。每个点所在的集合的代表元素是表示这个点的祖先中第一条没被覆盖的边的点。然后对于每一次操作就可以用一种类似树剖的向上跳的方式，每次令深度较大的点代表的边染色并将它与它的父亲节点的集合合并，然后跳到集合的代表元素的位置，继续判断深度并向上跳。当两个点所在的集合相同时，说明这两个点之间的路径都被染过色了，这次操作就结束了。

直接执行上面的步骤就能做到 $O(n \alpha(n))$。

```cpp
#include<bits/stdc++.h>
// #define int long long
#define eb emplace_back
#define mp make_pair
// #define DEBUG
using namespace std;
using pii = pair<int, int>;
using piii = pair<int, pii>;
using piiii = pair<pii, pii>;
using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;
const int P = 998244353;const i64 inf = 0x3f3f3f3f3f3f3f3f;
namespace IO{
	#define AzusIO
	int read(int &x){
		x = 0; int ch = 1;
		char u;
		while(!(isdigit(u = getchar()))){ if(u == '-') ch = -1; }
		x = u - '0';
		while(isdigit(u = getchar())) {x = (x << 3) + (x << 1) + u - '0';}
		x *= ch; return 0;
	}
} using namespace IO;
namespace DSU{
    int find(int *fa, int u){
        if(fa[u] == u) return u;
        return fa[u] = find(fa, fa[u]);
    }
    int merge(int *fa, int u, int v){
        int x = find(fa, u), y = find(fa, v);
        if(x != y) fa[y] = x;
        return x;   
    }
} using namespace DSU;
namespace azus{
	int n, q;
	int fa[1000005];
	int col[1000005], dep[1000005];
	vector<int> edge[1000005];
	int g[1000005];
	int dfs(int u){
		for(int v : edge[u]){
			if(v == fa[u]) continue;
			dep[v] = dep[u] + 1; fa[v] = u;
			dfs(v);
 		}
		return 0;
	}
	pii qu[1000005];
	pii eu[1000005]; int c[1000005];
	int solve(int u, int v, int w){
		u = find(g, u), v = find(g, v);
		while(u != v){
			if(dep[u] < dep[v]) swap(u, v);
			col[u] = w;
			u = merge(g, fa[u], u);
		}
		return 0;
	}
	int main(){
		read(n); read(q);
		for(int i = 1; i <= n; i ++)
			g[i] = i;
		for(int i = 1; i < n; i ++){
			int u, v; read(u); read(v);
			edge[u].eb(v), edge[v].eb(u);
			eu[i].first = u, eu[i].second = v;
		}
		dep[1] = 1;
		dfs(1);
		for(int i = 1; i <= n; i ++){
			int u = eu[i].first, v = eu[i].second;
			if(dep[u] < dep[v]) c[i] = v;
			else c[i] = u;
		}
		for(int i = 1; i <= q; i ++)
			read(qu[i].first), read(qu[i].second);
		for(int i = q; i >= 1; i --)
			solve(qu[i].first, qu[i].second, i);
		for(int i = 1; i < n; i ++)
			printf("%d ", col[c[i]]);
		putchar('\n');
		return 0;
	}
}
signed main(){
#ifndef DEBUG
	#ifndef AzusIO
		ios::sync_with_stdio(0);
		cin.tie(0), cout.tie(0);
	#endif
#endif
	int T = 1;
	while(T --)
		azus::main();
	return 0;
}
```

---

## 作者：_cbw (赞：1)

最开始没看到是全部修改完再统一查一遍，以为是树剖 + 线段树 + 卡常题。。

---

全部操作完之后再一起问是个很重要的性质，这告诉我们可以离线。

结合覆盖操作的特点：边上的权是它最后一次被覆盖时的权，我们可以想到：把操作全部离线下来，倒着做操作。这样，每条边在被操作之后就不会（也不能）再参与到其余的任何一次操作中了。

于是，问题转化为，每次改一条路径上边的边权，然后删掉（指不改变连通性的删）。使用树上并查集，每次更新父边之后把当前点**向**父亲合并即可，直到到达两点的 LCA。合并次数最多为 $n - 1$，因此复杂度是有保证的。

### Solution 1

倍增求 LCA，时间复杂度 $\Theta((n + q) \log n)$。常数较大。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int LOG = 20;
const int MAXN = 1e6 + 5;

vector<pair<int, int>> adj[MAXN];
int parent[MAXN], depth[MAXN], edge_id[MAXN];
int up[LOG][MAXN];
int uf[MAXN];
int ans[MAXN];
int n, q;

void build_tree() {
    queue<int> q;
    q.push(1);
    parent[1] = -1;
    depth[1] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto &[v, idx] : adj[u]) {
            if (v != parent[u]) {
                parent[v] = u;
                edge_id[v] = idx;
                depth[v] = depth[u] + 1;
                q.push(v);
            }
        }
    }
}

void preprocess_lca() {
    for (int u = 1; u <= n; ++u) {
        up[0][u] = (parent[u] == -1) ? u : parent[u];
    }
    for (int k = 1; k < LOG; ++k) {
        for (int u = 1; u <= n; ++u) {
            up[k][u] = up[k-1][up[k-1][u]];
        }
    }
}

int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    for (int k = LOG - 1; k >= 0; --k) {
        if (depth[u] - (1 << k) >= depth[v]) {
            u = up[k][u];
        }
    }
    if (u == v) return u;
    for (int k = LOG - 1; k >= 0; --k) {
        if (up[k][u] != up[k][v]) {
            u = up[k][u];
            v = up[k][v];
        }
    }
    return up[0][u];
}

int find(int u) {
    if (uf[u] != u) {
        uf[u] = find(uf[u]);
    }
    return uf[u];
}

void cover(int u, int l, int i) {
    while (true) {
        u = find(u);
        if (depth[u] <= depth[l]) break;
        ans[edge_id[u]] = i;
        int p = parent[u];
        uf[u] = find(p);
    }
}

int main() {
    scanf("%d%d", &n, &q);
    for (int i = 0; i < n-1; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        adj[u].emplace_back(v, i);
        adj[v].emplace_back(u, i);
    }
    build_tree();
    preprocess_lca();
    for (int u = 1; u <= n; ++u) {
        uf[u] = u;
    }
    vector<pair<int, int>> queries;
    for (int i = 0; i < q; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        queries.emplace_back(u, v);
    }
    for (int i = q; i >= 1; --i) {
        auto [u, v] = queries[i-1];
        int l = lca(u, v);
        cover(u, l, i);
        cover(v, l, i);
    }
    for (int i = 0; i < n-1; ++i) {
        printf("%d ", ans[i]);
    }
    puts("");
    return 0;
}
```

### Solution 2

LCA 太慢了，但是只要我不断跳两个点中深度更大的点，直到两点相等就可以了。

其实能想到第 $1$ 种没啥理由想不到这种。。。

时间复杂度 $\Theta(n + q \log n)$，常数还很小。当然如果你多开个 `root_in_real_tree` 然后启发式合并的话可以变成 $\Theta(n + q \alpha(n))$，但是估计常数的增加会使这个优化入不敷出。读者可以自行尝试比较。

```cpp
#include <cctype>
#include <cstdio>
#include <numeric>
#include <utility>
#define MAXN 1000003
using namespace std;

namespace IO
{
#define SIZ (1 << 19)
    char ibuf[SIZ], *p1 = nullptr, *p2 = nullptr;
#define gc() (p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, SIZ, stdin), p1 == p2) ? EOF : *p1++)
    void rd(int &x)
    {
        x = 0;
        char c = gc();
        while (!isdigit(c))
            c = gc();
        while (isdigit(c))
            x = x * 10 + (c ^ 48), c = gc();
    }
    template <typename... Arg>
    inline void rd(int &x, Arg &...args)
    {
        rd(x), rd(args...);
    }
    char obuf[SIZ], *p3 = obuf;
    inline void flush()
    {
        fwrite(obuf, 1, p3 - obuf, stdout), p3 = obuf;
    }
    inline void pc(const char c)
    {
        if (p3 - obuf == SIZ)
            flush();
        *p3++ = c;
    }
    void prt(int x)
    {
        static char stk[8];
        int stkp = 0;
        do
        {
            stk[stkp] = char(x % 10), x /= 10;
            ++stkp;
        } while (x);
        while (stkp)
            pc(char(stk[--stkp] + '0'));
        pc(' ');
    }
#undef gc
#undef SIZ
}
using IO::prt;
using IO::rd;

struct Edge
{
    int to, id, nxt;
} edges[MAXN << 1];
int cnt, head[MAXN], rt[MAXN], dep[MAXN], ans[MAXN];
pair<int, int> fa[MAXN], qur[MAXN];

inline void add_edge(const int from, const int to, const int id)
{
    edges[++cnt] = {to, id, head[from]}, head[from] = cnt;
}
void dfs(const int u)
{
    int f = fa[u].first;
    for (int i = head[u], to, id; i; i = edges[i].nxt)
    {
        to = edges[i].to, id = edges[i].id;
        if (to == f)
            continue;
        fa[to] = {u, id}, dep[to] = dep[u] + 1;
        dfs(to);
    }
}
int getrt(const int x)
{
    return x == rt[x] ? x : rt[x] = getrt(rt[x]);
}

int main()
{
    int n, q, u, v;
    rd(n, q);
    for (int i = 1; i < n; ++i)
        rd(u, v), add_edge(u, v, i), add_edge(v, u, i);
    dfs(1);
    for (int i = 1; i <= q; ++i)
        rd(qur[i].first, qur[i].second);
    iota(rt + 1, rt + n + 1, 1);
    for (int i = q; i; --i)
    {
        u = getrt(qur[i].first), v = getrt(qur[i].second);
        while (u != v)
        {
            if (dep[u] < dep[v])
                swap(u, v);
            ans[fa[u].second] = i, rt[u] = fa[u].first, u = getrt(rt[u]);
        }
    }
    for (int i = 1; i < n; ++i)
        prt(ans[i]);
    IO::flush();
    return 0;
}
```

---

题外话：第一份代码完全由 DeepSeek 独立思考完成。一遍过。

---

## 作者：lilong (赞：0)

树链剖分模板题。边权转点权的操作十分经典，用两个点中深度较大的存储边权（因为父亲唯一），然后就转化为点权的操作了。轻度卡常即可通过，比如线段树查询时写非递归版等。

时间复杂度 $O(n \log n + q \log^2 n )$。


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#define N 2000010

using namespace std;

vector<int> G[N];
int dep[N],top[N],fa[N],siz[N],son[N],id[N],rev[N],ans1[N],ans2[N],eid[N],tot;
struct E
{
	int u,v;
}e[N];

int n,q;

struct T
{
	int t[N * 4];
	void update( int u , int l , int r , int L , int R , int x )
	{
		if( L > R ) return;
		if( L <= l && r <= R )
		{
			t[u] = x;
			return;
		}
		if( t[u] )
		{
			t[u << 1] = t[u];
			t[u << 1 | 1] = t[u];
			t[u] = 0;
		}
		int mid = ( l + r ) >> 1;
		if( L <= mid ) update( u << 1 , l , mid , L , R , x );
		if( R > mid ) update( u << 1 | 1 , mid + 1 , r , L , R , x );
		return;
	}
	int que( int p )
	{
		int l = 1,r = n,u = 1,mid;
		while( l < r )
		{
			mid = ( l + r ) >> 1;
			if( t[u] )
			{
				t[u << 1] = t[u];
				t[u << 1 | 1] = t[u];
				t[u] = 0;
			}
			if( p <= mid ) r = mid,u = u << 1;
			else l = mid + 1,u = u << 1 | 1;
		}
		return t[u];
	}
}tr;

void upd( int u , int v , int x )
{
	while( top[u] != top[v] )
	{	
		if( dep[top[u]] > dep[top[v]] ) swap( u , v );
		tr.update( 1 , 1 , n , id[top[v]] , id[v] , x );
		v = fa[top[v]];
	}
	if( dep[u] > dep[v] ) swap( u , v );
	tr.update( 1 , 1 , n , id[u] + 1 , id[v] , x );//由于是边权，故 LCA 不属于修改范围
	return;
}

void dfs1( int u , int f )
{
	fa[u] = f;
	dep[u] = dep[f] + 1;
	siz[u] = 1;
	for( auto v : G[u] )
	{
		if( v == f ) continue;
		dfs1( v , u );
		siz[u] += siz[v];
		if( siz[v] > siz[son[u]] )
			son[u] = v;
	}
	return; 
}

void dfs2( int u , int f , int flag )
{
	id[u] = ++ tot;
	rev[tot] = u;
	if( flag ) top[u] = u;
	else top[u] = top[f];
	if( son[u] )
		dfs2( son[u] , u , 0 );
	for( auto v : G[u] )
	{
		if( v == f || v == son[u] ) continue;
		dfs2( v , u , 1 );
	}
	return;
}

int read( void )
{
	int x = 0;
	char ch = getchar();
	while( ch < '0' || ch > '9' ) ch = getchar();
	while( ch >= '0' && ch <= '9' ) x = x * 10 + ch - '0',ch = getchar();
	return x; 
}

void write( int x )
{
	if( x <= 9 )
	{
		putchar( x + '0' );
		return;
	}
	write( x / 10 );
	putchar( x % 10 + '0' );
	return;
}

int main()
{
	int u,v;
	cin >> n >> q;
	for( int i = 1 ; i < n ; i ++ )
	{
		u = read(),v = read();
		e[i].u = u,e[i].v = v;
		G[u].push_back( v );
		G[v].push_back( u );
	}
	dfs1( 1 , 0 );
	dfs2( 1 , 0 , 1 );
	for( int i = 1 ; i <= q ; i ++ )
	{
		u = read(),v = read();
		upd( u , v , i );
	}
	for( int i = 1 ; i <= n ; i ++ )
		ans1[i] = tr.que( id[i] );
	for( int i = 1 ; i < n ; i ++ )
	{
		if( dep[e[i].u] < dep[e[i].v] ) swap( e[i].u , e[i].v );
		write( ans1[e[i].u] ),putchar( ' ' );
	}
	return 0;
}
```

---

## 作者：zyn_ (赞：0)

简直一个模板题？

钦定 $1$ 为根，重链剖分。每条边在较深的一个端点维护。对边的链上查询就是链上所有点去掉 LCA。问题变为序列上 $O(n\log n)$ 次区间覆盖，$O(n)$ 次单点询问。线段树即可，时间复杂度 $O(n\log^2 n)$。虽然 $n\le 10^6$，但注意到树剖常数小，稍微卡常即可通过。

很可惜，虽然是区间覆盖，但是珂朵莉树在本题中没用，因为其自带一个来自 `set` 的 $\log$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000009
#define INF 0x3f3f3f3f
struct SegmentTree{
	int n,t[N<<2];
    void init(int _n){n=_n;}
    void upd(int l,int r,int pl,int pr,int p,int d){
        if(l<=pl&&pr<=r){t[p]=d;return;}
        if(t[p])t[p<<1]=t[p<<1|1]=t[p],t[p]=0;
        int mid=(pl+pr)>>1;
        if(l<=mid)upd(l,r,pl,mid,p<<1,d);
        if(r>mid)upd(l,r,mid+1,pr,p<<1|1,d);
    }
    void assign(int l,int r,int x){
        upd(l,r,1,n,1,x);
    }
    int qr(int c){
        int pl=1,pr=n,mid,p=1;
        while(pl<pr){
            if(t[p])t[p<<1]=t[p<<1|1]=t[p],t[p]=0;
            mid=(pl+pr)>>1;
            if(c<=mid)pr=mid,p<<=1;
            else pl=mid+1,p=p<<1|1;
        }
        return t[p];
    }
}tr;
int n,q,a,b,em[N],fa[N],dep[N],siz[N],son[N],top[N],dfn[N],id[N],cnt;
struct edge{int to,id;};
vector<edge> v[N];
void dfs1(int p,int f){
	fa[p]=f;dep[p]=dep[f]+1;siz[p]=1;
	for(edge e:v[p])if(e.to!=f){
		em[e.to]=e.id;
		dfs1(e.to,p);siz[p]+=siz[e.to];
		if(!son[p]||siz[e.to]>siz[son[p]])son[p]=e.to;
	}
}
void dfs2(int p,int t){
	dfn[p]=++cnt;top[p]=t;
	if(!son[p])return;
	dfs2(son[p],t);
	for(edge e:v[p])if(e.to!=fa[p]&&e.to!=son[p])dfs2(e.to,e.to);
}
void modify(int u,int v,int x){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		tr.assign(dfn[top[u]],dfn[u],x);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	if(u!=v)tr.assign(dfn[u]+1,dfn[v],x);
}
int ans[N];
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;++i){
		scanf("%d%d",&a,&b);
		v[a].push_back({b,i});
		v[b].push_back({a,i});
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;++i)id[dfn[i]]=i;
	tr.init(n);
	for(int i=1;i<=q;++i)scanf("%d%d",&a,&b),modify(a,b,i);
	for(int i=1;i<=n;++i)ans[em[id[i]]]=tr.qr(i);
	for(int i=1;i<n;++i)printf("%d%c",ans[i],i==n-1?'\n':' ');
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：0)

注意到这题直接树剖并不好过，所以猜测本题正解不是树剖，疑似有离线到序处理的单 $\log$ 做法。

但是，我树剖卡过去了，学好卡常是非常有用的！

做法很简单，就是数剖裸题，统计答案只需要在最后把线段树 dfs 一遍就可以求出每个点上面的边了，记下每个点的编号，用哈希表存下每条边，然后用每个点连向父亲的边可以找出来，注意，每条边的两个端点是无序的。

这里借着这个题介绍几个比较随手的卡常技巧，主流的线段树写法会传查询区间，我并不理解为什么要这么写，但是把修改和查询的参数放到全局变量里能快很多，同时，如果想要卡到极限可以考虑把当前节点表示的区间作为节点信息，这样我们每次递归都只需要传一个参数，事实上，在用输入一个 $seed$ 随出所有数据的情况下，这样做线段树可以轻松卡过 $2\times10^7$（当然操作要比较简单，比如加，覆盖等，本题正好满足条件），而且卡过 $2\times10^7$ 不是这种写法线段树的极限，而是因为那场模拟赛的正解是并查集，为了在两秒的时限下放过正解，事实上，我只跑了 $650$ 毫秒左右，拿到最优解，详情可以看前年清北学堂 OJ 上我用 @sjkmvdtjvc 的号交的那一发。

关于 ```__builtin_expect()``` 的使用，虽然有言论说这个东西只有在 ```if``` 的时候是有用的，但实际上这个东西同时可以用于三目运算符，在不加优化的情况下，```if``` 和三目运算符的速度取决于表达式取值的概率，如果取 $01$ 的概率差不多则三目运算符快，反之如果差很多则 ```if``` 快，但由于 ```__builtin_expect()``` 适用于三目运算，在概率差很多的时候是可以强行三目的，这样可以减少一些不必要的函数，将其转化为表达式 ```#define``` 出来，在 ```fread``` 快读中就是一个很好的应用，甚至，这个东西可以加到 ```for``` 里面，这个用处是很大的，因为很多时候我们循环次数是已知的，循环 $n$ 次说明取 $1$ 的概率只有 $\frac{1}{n}$。

事实上，我的程序还可以继续卡，但平时习惯就比较卡常，顺手的卡常都做了，所以下面说的我没有写，但也是有用的。

线段树单点修改和区间修改访问的区间个数差两倍常数（事实上略小于两倍），虽然在 ```pushdown``` 的时候该问多少还是得问多少，但这可以减少递归的常数，所以可以特判单点修改。

同时，树剖的第一个 ```dfs``` 可以比较无痛地改成 ```bfs```，这个技巧还有别的用处，比如对于需要预处理 $fa,dep,size$ 的一些 dp 题，可以先跑出 ```bfs``` 序，然后按 ```bfs``` 序到序枚举，容易发现，这样做在拓扑序上是没问题的，不过本题没用到，不展开说了。

对于 ```swap```，不要用位运算模拟，因为位运算需要三次赋值三次异或，而正常的写法只需要三次赋值和一次定义变量，虽然异或也许是快的，但三次异或绝对跑不过一次定义变量，在此我呼吁大家不要形成手写异或 ```swap``` 的风气，因为标准库很厉害，当然，把这个函数展开是有用的，但一定要按标准库的方式实现。

然后，如果你认为 ```fread``` 仍然不够快，一方面，你可以参考[这个](https://metaso.cn/search/0dbdc1cb-5f62-4ae6-8c16-82d2486ce0af?q=C%2B%2B%E4%B8%AD%EF%BC%8C%E7%94%A8fread%28c%2C1%2Cn%2Cstdin%29%E5%90%91char+c%5BN%5D%E4%B8%AD%E8%AF%BB%E5%85%A5m%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BF%9D%E8%AF%81m%3Cn%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E6%8F%90%E5%89%8D%E7%9F%A5%E9%81%93m%E7%9A%84%E5%85%B7%E4%BD%93%E5%80%BC%EF%BC%8C%E6%AD%A4%E6%97%B6fread%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFO%28n%29%E8%BF%98%E6%98%AFO%28m%29%E7%9A%84)，同时，你可以阅读一下其源码，删除一部分为了安全性或者异常处理进行的操作，事实上这里面是有优化空间的，但这并不重要，因为往往读入不是瓶颈，比起这个不如开大 ```fread``` 读入用的数组，并且在判断的时候使用 ```__builtin_expect()```。

本题在某些地方，比如最后统计答案是可以循环展开的。

数组大小尽可能卡着数据范围开小，可以优化访问内存，本题数据范围挺大的，我在本地测试发现开两倍要比卡着开有明显差距（因为我本来电脑就慢，所以这一点有放效果，事实上差距并不会这么大），不过这里不是瓶颈。

最后，```register``` 的作用是比较玄学的，但加上绝对不会有坏处（起码在 ```-std=c++14``` 的时候是这样的），而且我始终认为这是多少有点用的，因为我在开启 ```O2``` 的情况下无论是本地还是洛谷整体上加是比不加好的，我很自信我有足够多的数据作为参考，即使你认为没用，那也不要紧，建议尽可能开全局变量，因为这是等效的，而且 ```inline``` 一定是有用的，虽然可能会负优化，但大部分情况下不用担心这个问题，所以可以考虑强制内联。

我不知道为什么测评机波动这么大，我在赛时卡过了赛后前面两发就没过，而且交的几次部分点的时间极差达到了 $0.5$ 秒，但我认为稳定稳定之后是好过的。

更新：昨晚睡觉的时候突然又想到一个能卡的地方，由于修改的信息递增，我们要做的是 ```chkmax```，所以修改的时候不需要 ```pushdown```，一方面，这样使得我们正常做的常数变小，另一方面，单点修改可以做到 $O(1)$，可以考虑开一个数组记录每个点表示的线段树节点，如果长度小于 $\log$ 则暴力改，这样做常数更小，同时，这可以启发我们可以在线段树上跳 LCA，只修改左端点的右父亲和右端点的左父亲，定义左父亲表示如果一个节点是其父亲的右儿子，则称其父亲为左父亲。

刚才写的时候我突然悟了一个大部分线段树可用的更强的卡常方式，如果维护的信息满足交换律，处理的问题没有查询（最后把序列输出来）只有单点查询，可以把序列补成 $2$ 的幂，然后按刚才说的跳 LCA 的办法做，同时能发现一个神奇的事情，叶子节点的深度相等，这样两个节点跳的步数相等。

这里放出完整程序，虽然有的缺省源没用上，但大部分用上了，考虑到我的做法是卡常卡过，所以我认为应该放出卡常的全过程，并不存在“火车头”的问题。

```cpp
#include <bits/stdc++.h>
#define il inline
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int rg unsigned
#define void il void
#define ll long long
#define ull unsigned ll
#define lll __int128
#define db double
#define vector basic_string
#define pq priority_queue
#define vint vector<unsigned>
#define vll vector<ll>
#define vull vector<ull>
#define ump unordered_map
#define ust unordered_set
#define deq deque
#define mkp make_pair
#define pii pair<unsigned,unsigned>
#define pll pair<ull,ull>
#define fi first
#define se second
#define Bool(a,n) bitset<n>a
#define sca(a) for(int $=0;$<n;cin>>a[++$])
#define cle(a) memset(a,0,sizeof a)
#define tmx(a) memset(a,0x3f,sizeof a)
#define tmn(a) memset(a,0xbf,sizeof a)
#define tif(a) memset(a,0xff,sizeof a)
//#define ge getchar_unlocked()
#define pu putchar_unlocked
#define lik(x) __builtin_expect((x),1)
#define ulk(x) __builtin_expect((x),0)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
//#define abs(a,b) (a>b?a-b:b-a)
#define fls cout<<endl;
#define PP pop_back()
#define PS push
#define BK back()
#define SZ size()
//inline ll max(const rg ll a,const rg ll b){return a>b?a:b;}
//inline ll min(const rg ll a,const rg ll b){return a<b?a:b;}
inline ll abs(const rg ll a,const rg ll b){return a>b?a-b:b-a;}
using namespace std;constexpr unsigned N=1e6+1,M=4e3+2;
namespace IO{unsigned char b[1<<24],*l=b,*r=b;
	#define ge (ulk(l==r)?r=(l=b)+fread(b,1,1<<24,stdin):0,ulk(l==r)?'\0':*l++)
	il unsigned rd(){int char c=ge;int s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;return s;}
	void rd(int&s){int char c=ge;s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;}
}using IO::rd;
unsigned n,q;vint a[N];unsigned tim;
namespace seg{unsigned t[N<<2],ans[N],x,y;
    #define ls o<<1
    #define rs ls|1
    #define in x<=l&&y>=r
    #define ot y< l||x> r
    void tag(cit o,cit z){t[o]=z;}
    void dwn(cit o){if(t[o])t[ls]=t[rs]=t[o],t[o]=0;}
    void dpdate(cit o,cit l,cit r){if(ot)return;if(in)return tag(o,tim);cit m=l+r>>1;dwn(o);dpdate(ls,l,m),dpdate(rs,m+1,r);}
    void qry(cit o,cit l,cit r){if(l==r){ans[l]=t[o];return;}cit m=l+r>>1;dwn(o);qry(ls,l,m),qry(rs,m+1,r);}
    void dpdate(cit l,cit r){if(ulk(l>r))return;x=l,y=r;dpdate(1,1,n);}
}ump<ull,unsigned>mp;
namespace lik{unsigned s[N],d[N],c[N],p[N],id[N],f[N],cnt,ans[N];
    void dfs1(cit u){s[u]=1;for(cit&v:a[u])if(lik(v^f[u]))f[v]=u,d[v]=d[u]+1,dfs1(v),s[u]+=s[v],s[c[u]]<s[v]?c[u]=v:0;}
    void dfs2(cit u,cit r){id[u]=++cnt;if(c[u])dfs2(c[u],r);p[u]=r;for(cit&v:a[u])if(lik((v^f[u])&&(v^c[u])))dfs2(v,v);}
    void cover(int u,int v){for(;p[u]^p[v];seg::dpdate(id[p[u]],id[u]),u=f[p[u]])if(d[p[u]]<d[p[v]])swap(u,v);if(u==v)return;if(d[u]>d[v])swap(u,v);seg::dpdate(id[u]+1,id[v]);}
    void print(){seg::qry(1,1,n);for(int i=1;i<=n;++i)ans[i]=seg::ans[id[i]];}
}unsigned ans[N];
#define Hash(u,v) 1ll*minmax(u,v).fi*N+minmax(u,v).se
void init(){rd(n),rd(q);
    for(int i=1,u,v;i<n;++i)rd(u),rd(v),mp[Hash(u,v)]=i,a[u]+=v,a[v]+=u;
    lik::dfs1(1),lik::dfs2(1,1);
}void solve(){init();int u,v;
    for(tim=1;tim<=q;++tim)rd(u),rd(v),lik::cover(u,v);
    lik::print();for(int i=1;i<=n;++i)ans[mp[Hash(i,lik::f[i])]]=lik::ans[i];
    for(int i=1;i<n;++i)cout<<ans[i]<<' ';
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```

---


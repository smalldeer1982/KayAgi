# [COTS 2012]  宿舍移动 / BUKA

## 题目描述

**本题为交互题。**

有一棵 $n$ 个节点的有根满二叉树，若 $n=1$ 则根度数为 $0$ 否则根度数为 $2$，每个点的编号未知。

你每次可以询问两个点 $a,b$，交互库返回树上 $a$ 到 $b$ 的路径中离根最近的点的编号，你需要在 $5 \times 10^4$ 次询问内求出每个点的父亲。特别地，根的父亲为根。

### 交互方式

这是一道 IO 交互题，你需要从标准输入输出中与交互库交互。

首先，从标准输入中读取满二叉树点数 $n$。

然后，你可以进行不超过 $5 \times 10^4$ 次交互，形式为 `pitaj a b`，其中需要满足 $1 \leq a, b \leq n$，交互库返回树上 $a$ 到 $b$ 路径中到根最近的点的编号。在你确定答案后，首先输出 `kraj` 并换行，然后输出 $n$ 行，第 $i$ 行表示编号为 $i$ 的点在二叉树上的父亲。

在每次询问后以及最终输出答案后，你需要刷新缓冲区。

## 说明/提示

$1 \leq n \leq 10^4$，保证 $n = 2^k-1$，$k$ 为正整数。

# 题解

## 作者：andychen_2012 (赞：1)

我们无需考虑左右儿子的问题，因为我们只需要求出每个节点的父亲。

考虑递归处理。

每次处理一个子树时，花费子树大小次询问找到其一条链，强制其为左链，将其存储在 vector 中，而后按顺序处理每个点的右子树，设询问次数为 $f(n)$，则 $f(n)\le n-1+\sum_{i=1}^{\log n} f(\frac{n}{2^i})$，计算后最大值如下：

```
f[1]=0
f[3]=2
f[7]=8
f[15]=24
f[31]=64
f[63]=160
f[127]=384
f[255]=896
f[511]=2048
f[1023]=4608
f[2047]=10240
f[4095]=22528
f[8191]=49152
```

具体而言，应如何寻找到一条链呢？在进入一个子树后，我们先随机一个点 $x$。然后以 $x$ 为一个固定的点询问子树内的其他点，设当前询问为 $\mathrm{lca}(x,y)=z$。若 $z$ 在之前的询问中没有作为 $\mathrm{lca}$ 出现过，那么说明 $z$ 为 $x$ 的祖先，则令链经过它，同时标记 $z$。若 $z=x$，则说明 $y$ 在 $x$ 的子树中，将 $x$ 换到 $y$ 上，否则如果 $y \neq z$，那么说明 $y$ 在 $z$ 的子树中，将 $z$ 的子树大小 $+1$。此时我们可以遍历到子树内的所有点，并计算出我们取出的链上每个点的子树大小的值。按子树大小从大到小排序得到的链，深度从小到大，依次为下一个点的父亲。

代码如下：

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0;
    int f=0,ch=0;
    while(ch<48||ch>57) f=(ch=='-'),ch=getchar();
    while(ch>47&&ch<58) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
    return f?-x:x;
}
inline void write(ll x,char end='\n'){
    if(x==0){
        putchar('0');
        putchar(end);
        fflush(stdout);
        return;
    }
    if(x<0) putchar('-'),x=-x;
    int ch[40]={0},cnt=0;
    while(x){
        ch[cnt++]=(int)(x%10);
        x/=10;
    }
    while(cnt--) putchar(ch[cnt]+48);
    putchar(end);
    fflush(stdout);
}
inline int ask(int u,int v){
	printf("pitaj %d %d\n",u,v);
	fflush(stdout);
	return read();
}
const int N=1e4+5;
int fa[N],tot;
int to[N],id[N];
vector<int> subsz[N];
inline bool cmp(int x,int y){return subsz[x].size()>subsz[y].size();}
inline void solve(int rt,vector<int> sub){
	int n=sub.size();
	++tot;
	vector<int> anc;
	int now=sub[0];
	for(int i=0;i<n;++i){
		int v=sub[i];
		if(now==v) continue;
		if(to[v]==tot) continue;
		int x=ask(now,v);
		if(to[x]!=tot){
			anc.emplace_back(x);
			to[x]=tot;
			subsz[x].clear();
		}
		if(x==now) now=v;
		else if(x!=v) subsz[x].emplace_back(v);
	}
	sort(anc.begin(),anc.end(),cmp);
	for(auto v:anc){
		fa[rt]=v;
		solve(rt*2+1,subsz[v]);
		rt*=2;
	}
	fa[rt]=now;
}
int main(){
	int n=read();
	if(n==1){
		puts("kraj");
		fflush(stdout);
		puts("1");
		fflush(stdout);
		return 0;
	}
	if(n==3){
		int f=ask(1,2);
		puts("kraj");
		fflush(stdout);
		write(f),write(f),write(f);
		return 0;
	}
	vector<int> sub;
	for(int i=1;i<=n;++i) sub.emplace_back(i);
	solve(1,sub);
	fa[0]=fa[1];
	for(int i=1;i<=n;++i) id[fa[i]]=i;
	puts("kraj");
	fflush(stdout);
	for(int i=1;i<=n;++i) write(fa[id[i]/2]);
    return 0;
}
```

---

## 作者：Shunpower (赞：0)

这是蓝题？？？

----------

我会一个 $\sum siz_i$ 的方法，只能获得 $80$ 分。操作指南就是先找出子树的根，然后往两个儿子分配，做子问题。显然在找出根之后只需要把子树内的点连成一棵树，对树染色即可（可以通过 LCA 是否是子树的根判定在同个子树或不同子树）。考虑我们随机一个点开始往所有点连边（也就是把子树内的点连成菊花），这样需要 $siz_i-1$ 次操作，并且这些操作中查出来的 LCA 的绝对众数应该就是根。特殊情况是随到的点就是根，此时我们可以重来一次，期望 $siz_i$ 的概率随到根，多出 $siz_i-1$ 的贡献，匀下来就是每个点都贡献 $siz_i$。

然而在 $n=8191$ 的时候需要大约 $9\times 10^4$ 次询问。

----------------

正解和这个几乎不是一个思路，so sad。

写出计算操作次数的暴力可以发现，如果我们可以砍掉一半的 $siz_i$ 就能过了。我们就没有什么办法可以只做一边子树吗？

考虑找出当前子树根到底的一条链。因为我们不在乎左右儿子关系，直接钦定它是最左链，然后如果我们可以求出所有点到这条链链底的 LCA 就能分配右子树了。这样可以看成我们只做了右子树！

考虑怎么在 $siz_i$ 次询问内求出这条链，以及怎么分配。考虑我们先随一个点 $x$，然后再随便问一个没有问过且不等于 $x$ 的点 $y$。此时会出现三种情况：

- $\operatorname{LCA}(x,y)$ 是一个未知的点。这说明 $\operatorname{LCA}(x,y)$ 是 $x$ 的一个祖先，并且之前从未出现过，我们把这个祖先添加到最左链中。
- $\operatorname{LCA}(x,y)$ 是一个已知的点，但不是 $x$。这种情况没什么影响。
- $\operatorname{LCA}(x,y)$ 是 $x$。这说明 $y$ 比 $x$ 更深，可以放在最左链上。为了便于我们分配 $y\to x$ 路径上那些点右子树内的点（需要确定这些点和链底的 $\operatorname{LCA}$。不过没必要是链底，$y$ 就行了），我们把 $x\gets y$，然后递归继续做。

正确性较为显然。注意到我们还需要还原最左链，在过程中维护一下每个点右半子树大小就好了，显然从大到小对应了从上到下。

询问次数的式子是 $f_n\gets n-1+\sum\limits_{i=1}^{\log_2n}\frac{n}{2^i}$，打出来一看刚好 $4.9\times 10^4$。

有一点点细节。

```cpp
int n;
vector <int> nodes;
int ans[N];
int siz[N];
vector <int> dv[N];
int LCA(int x,int y){
	cout<<"pitaj "<<x<<" "<<y<<endl;
	int lca;
	cin>>lca;
	return lca;
}
void divide(vector <int> p,int f){
	if(p.empty()) return;
	if(p.size()==1) return ans[p[0]]=f,void();
	int x=p[0];
	vector <int> lef;
	lef.pb(x);
	siz[x]=1;
	fr1(i,1,(int)p.size()-1){
		int lca=LCA(x,p[i]);
		if(lca==x){
			x=p[i];
			lef.pb(x);
			siz[x]++;
		}
		else{
			if(!siz[lca]) lef.pb(lca);
			if(lca!=p[i]) dv[lca].pb(p[i]);
			siz[lca]++;
		}
	}
	sort(lef.begin(),lef.end(),[](int &x,int &y){
		return siz[x]>siz[y];
	});
	// for(auto i:lef) cout<<i<<","<<siz[i]<<endl;
	// cout<<endl;
	ans[lef[0]]=f;
	fr1(i,1,(int)lef.size()-1) ans[lef[i]]=lef[i-1];
	for(auto i:lef) divide(dv[i],i);
}
int main(){
#ifdef Shun
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(false);
	cin>>n;
	fr1(i,1,n) nodes.pb(i);
	divide(nodes,0);
	cout<<"kraj"<<endl;
	fr1(i,1,n) cout<<(ans[i]?ans[i]:i)<<endl;
	ET;
}
//ALL FOR Zhang Junhao.
```

---


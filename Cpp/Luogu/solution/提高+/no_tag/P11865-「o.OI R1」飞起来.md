# 「o.OI R1」飞起来

## 题目背景

小 C 和小 T 居住在一个反重力星球上。

他们还喜欢各自在自己家的窗台上向下抛物。

自然而然地物体会向上飞。

## 题目描述

小 C 有一个长度为 $n$ 的序列 $C$，小 T 有一个长度也为 $n$ 的序列 $T$，保证两个序列中的 $2n$ 个数互不相同。

小 C 和小 T 想要玩一个游戏，过程如下，按顺序执行：

- 游戏开始时，两人都会知道自己的序列和对方的序列的内容。
- 小 C 从他的序列 $C$ 中选择两个不同的数，设为 $a$ 和 $c$（需要满足 $a<c$），**并将这两个数告诉小 T**。
- 小 T 从他的序列 $T$ 中选择两个不同的数，设为 $b$ 和 $d$（需要满足 $b<d$），**并将这两个数告诉小 C**。
- 小 C 选择一个实数，设为 $x_c$（需要满足 $a\leq x_c\leq c$），**并将其告诉小 T**。   
- 小 T 选择一个实数，设为 $x_t$（需要满足 $b\leq x_t\leq d$），**并将其告诉小 C**。
- 令 $x=\dfrac{x_c+x_t}{2}$，小 C 的得分为 $(x-a)(x-c)$，小 T 的得分为 $(x-b)(x-d)$。
- 得分大的一方赢，得分相同则平局。  

你需要求出在两人都采取最优策略时谁会赢，并给出一种小 C 选择数字 $a$ 和 $c$ 的方案。

最优策略是指尽量让自己赢，如果不行尽量平局。

## 说明/提示

可能有其他的策略，但是最后结果是一样的。

**「样例解释 #1」**

小 C 只能选择 $3$ 和 $7$，小 T 只能选择 $2$ 和 $4$。

接下来小 T 可以选择 $3.8$，这样小 C 怎么做选择都会输。

**「样例解释 #2」**

小 C 如果选择 $1$ 和 $2$，小 T 只能选择 $-2$ 和 $-1$ 才可以达成平局。  

**「样例解释 #3」**

小 C 可以选择 $2$ 和 $15$，小 T 无论如何选择都会输。

**「数据范围」**

**本题采用捆绑测试与 Special Judge。**  

设 $\sum n$ 为一个数据点所有 $n$ 的和。

对于所有测试数据，保证：

- $2\leq n,\sum n \leq 10^6$。
- $-10^{9}\leq C_i,T_i\leq 10^{9}$。

|子任务|$\sum n$|$\lvert C_i\rvert,\lvert T_i\rvert$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|
| $0$ | $\leq 20$ | $\leq 100$| 无 | $10$ |
| $1$ | $\leq 300$ | $\leq 10^9$| 无 | $15$ |
| $2$ | $\leq 2000$ | $\leq 10^9$| 无 | $15$ |
| $3$ | $\leq 10^5$ | $\leq 10^{9}$| A | $10$ |
| $4$ | $\leq 10^5$ | $\leq 10^{9}$| B | $15$ |
| $5$ | $\leq 10^5$ | $\leq 10^{9}$| 无 | $15$ |
| $6$ | $\leq 10^6$ | $\leq 10^{9}$| 无 | $20$ |

- 特殊性质 A：$C_{n}<T_1$，且对于任意的整数 $i(1\le i< n)$ 都有 $C_{i}<C_{i+1}$ 和 $T_{i}<T_{i+1}$。
- 特殊性质 B：$C_1<T_1$，且对于任意的整数 $i(1\le i< n)$ 都有 $T_i<C_{i+1}<T_{i+1}$。


## 样例 #1

### 输入

```
3
2
3 7
2 4
3
-3 1 2
-2 -1 5
3
2 9 15
17 -9 18```

### 输出

```
T 3 7
Draw 1 2
C 2 15```

# 题解

## 作者：TruchyR (赞：2)

这是一道结论题。结论比较好猜，这里将给出证明。

以下将两人选择视为两个区间。

然后如果两个区间有包含关系，容易发现不管怎么选择，区间短的那一方一定会赢。  

所以我们将重心放在剩下的情况，以下作出几个限制来减少分讨个数。 

- 先抛开题目中的字母，设甲选择了区间 $[-a,a]$，乙选择了区间 $[b,b+2l]$。
- 即甲区间长度为 $2a$，乙区间长度为 $2l$。  
- 作出限制 $a>0$，$b=ap$，$l=aq$，$p>-1$，$q\ge 1$。  
- 即乙的区间在甲右边，区间长度不小于甲。
- 甲的结果为 $y_{甲}=(x+a)(x-a)=x^2-a^2$。   
- 乙的结果为 $y_{乙}=(x-b)(x-b-2l)=x^2+b^2-2xb-2xl+2bl$。  

两个线段相对位置在左在右的关系显然没有影响，所以去除包含情况后不重不漏。

将甲的结果减去乙的结果：  

$\begin{aligned}
 y_{差} &= y_{甲}-y_{乙} \\
    &= (x^2-a^2)-(x^2+b^2-2xb-2xl+2bl) \\
    &= -a^2-b^2+2xb+2xl-2bl \\
    &= 2x(p+q)a+a^2(1-p^2-2pq) \\
\end{aligned}$

显然有 $(p+q)a>0$，所以这个式子的值随着 $x$ 的增大而增大。

所以甲会尽可能往右选择，乙会尽可能往左选择；即一人选 $a$，一人选 $b$。

当 $x=\dfrac{a+b}{2}$ 时式子可以化简为 $y_{差}=-a^2(p-1)(q-1)$。

当 $q=1$ 时一定有 $y_{差}=0$，即平局。

当 $p>1$ 时两区间不交，且区间更长的赢。

当 $-1<p<1$ 时两区间有交，且区间更短的赢。

保证了两个序列互不相同所以 $p≠0$。

总结以上所有内容，于是我们有：
- 区间长度相同必定平局。
- 否则，两个区间线段不交时，线段长的获胜。
- 否则，两个区间有交时，线段短的获胜。

于是考虑枚举小 C 的左端点：  
- 如果两端点中间有至少两个小 T 的选择点那么会造成包含局面。
- 所以小 C 右端点有一个最大值。
- 如果中间没有小 T 的选择点那么两区间一定不交，两人都尽量选区间大的。
- 如果中间恰有一个小 T 的选择点那么小 T 可交可不交，小 C 选择的区间大小有范围。

排序后进行二分即可，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define MX 1000005
#define CKE if(CHECK)
#define FRE if(FIL)
using namespace std;
const int CHECK=0,FIL=0;int read();
int Tt,F,ansL,ansR,n,C[MX],T[MX];
void update(int op,int cl,int cr){
	if(cl==cr) return;
	if(!F || op==2) F=op,ansL=cl,ansR=cr;}
int check(int cl,int cr,int tl,int tr){
	//小C选择 C[cl],C[cr]   小T选择 T[tl],T[tr] 
	//相等必平局 
	int Xc=C[cr]-C[cl],Xt=T[tr]-T[tl];
	if(Xc==Xt) return 1;
	//有交短的赢 无交长的赢 
	if(C[cr]<T[tl] || T[tr]<C[cl]) swap(Xc,Xt);
	if(Xc<Xt) return 2;
	return 0;
}
signed main(){
	//ios::sync_with_stdio(false);
	//cin.tie(0);cout.tie(0);
	FRE freopen("segment.in","r",stdin);
	FRE freopen("segment.out","w",stdout);
	Tt=read();while(Tt--){
		n=read();
		for(int i=1;i<=n;i++) C[i]=read();
		sort(C+1,C+1+n);C[n+1]=3e18,C[0]=-3e18;
		for(int i=1;i<=n;i++) T[i]=read();
		sort(T+1,T+1+n);T[n+1]=3e18,T[0]=-3e18;
		F=0,ansL=1,ansR=2;
		//0->T  1->Dr  2->C
		for(int cl=1;cl<n;cl++){//枚举小C区间的左端点 
			int ti=upper_bound(T+1,T+1+n,C[cl])-T;
		  //找右侧离这个点最近的小T选择点 
		  //如果没有，一定不交 
			if(ti>n){
			    update(check(cl,n,1,n),cl,n);
				continue;
			}
		  //如果有
		    //找小C区间右端点的最小值 
			int cr=upper_bound(C+1,C+1+n,T[ti+1])-C-1;
			if(cr==cl) continue;//形如 C,T,T,C，小C必败
			  //1: T,T,[C],..,C,T,T，此时一定不交
			int cmr=upper_bound(C+1,C+1+n,T[ti])-C-1;
			update(min(check(cl,cmr,1,ti-1)
					  ,check(cl,cmr,ti,n)),cl,cmr);
			  //2: T,T,[C],T,C,..,C,T,T
			    //如果小T选择和小C不交，小C选择长度有最小值 
			int Xcl=max(T[ti-1]-T[1],T[n]-T[ti+1]);
			cmr=max(cmr+1,(int)(lower_bound(C+1,C+1+n,C[cl]+Xcl)-C));
			if(cmr>cr) continue;
			    //小T还可以选择和小C相交
			update(min(
					min(check(cl,cmr,1,ti-1)
					   ,check(cl,cmr,ti+1,n)),
					min(check(cl,cmr,ti-1,ti)
					   ,check(cl,cmr,ti,ti+1))),cl,cmr);
			    //这里还有可能平局还得再逝逝 
			if(cmr+1<=cr) cmr++; 
			update(min(
					min(check(cl,cmr,1,ti-1)
					   ,check(cl,cmr,ti+1,n)),
					min(check(cl,cmr,ti-1,ti)
					   ,check(cl,cmr,ti,ti+1))),cl,cmr);
		}
		if(F==0) printf("T ");
		if(F==1) printf("Draw ");
		if(F==2) printf("C ");
		printf("%lld %lld\n",C[ansL],C[ansR]);
	}
	return 0;
}
int read(){
	int Ca=0;char Cr=' ';int Cf=1;
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-1;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---


# [威海市赛2024] 大家的公因数 2

## 题目描述

4202 年，第 2184 届威海市大学生程序设计竞赛如期举行。小威与你组队参加了这次竞赛，你们在五小时的比赛中大杀四方，仅使用两小时的时间就解决了 12 题。现在，你们翻开了最后一道题的题面，但你们发现，纸上只印了两个正整数序列 $\{a_i\}$ 和 $\{p_i\}$ 和一个三元组序列 $\{u_i, v_i, w_i\}$。

你以为是印刷错误，于是你看向了小威的纸质题面，却发现小威也在看你的。你们面面相觑，不知道如何是好。最终，你们决定，猜一个题意！或许你们就是天命人吧，按照你们猜的题意写完代码提交后，一发通过了该题，AK 了这场比赛。

你们猜的题意是这样的：对于正整数序列中的两个数 $a_i$ 和 $a_j$，当且仅当它们有一个**大于 1** 的公因数时，它们之间有一条无向边连接。如此，你得到了一张无向图，每个点上有点权 $p_i$。你现在想知道，对于每个三元组，是否存在一条从 $u_i$ 到 $v_i$ 的路径，其点权异或和为 $w_i$。

比赛结束之后，只有你们通过了这道题。其他队的参赛成员找到你们，希望要一份你们的代码学习参考，但很不幸，你们的代码并没有保存下来。你能再复现一份吗？

## 说明/提示

样例 #1 对应的无向图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxwpndnt.png)

对于第一个查询，一条可行的路径为：$2 \to 2 \to 6 \to 3 \to 3$；

对于第二个查询，无法找到一条路径使得异或和为 $10$；

对于第三个查询，一条可行的路径为：$2 \to 2 \to 6 \to 6 \to 3 \to 3$；

对于第四个查询，$1$ 和 $2$ 之间不存在路径，故查询结果为 `No`。

## 样例 #1

### 输入

```
5
1 2 3 6 5
1 2 3 6 1145
4
2 3 6
3 6 10
2 3 0
1 2 0```

### 输出

```
Yes
No
Yes
No```

## 样例 #2

### 输入

```
8
1 2 3 4 5 6 7 8
3 19 5 8 2 17 6 17
6
3 5 629185
4 8 25
5 5 4274800
6 6 947319
1 2 16
8 8 2205033
```

### 输出

```
No
Yes
No
No
No
No
```

# 题解

## 作者：fish_love_cat (赞：9)

没打比赛，赛后独立做出来的。

---

首先可以搞个桶上去。

然后跑线性筛，把每个质数视作一个点进行连边。

这样就建了图。

糊个并查集上去判掉不连通的情况。剩余问题离线出来，按照连通块排序。

容易发现一个限制能做当且仅当所在连通块能异或出指定数。

所以对于每个连通块的问题可以搞个线性基处理。

做完了。

---

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MB=60;
int a[500005],flc[10000005],fa[10000005],p[MB+5],d[MB+5],top,N;
bool aa[10000005],ans[500005],vis[10000005];
vector<int>ve[10000005];
struct fish{
    int u,v,z;
    int id;
    int fa;
}Q[500005];
void ins(int x){
    if(!x)return;
	for(int i=MB;i>=0;i--)
	if((1ll<<i)&x){
		if(!p[i]){p[i]=x;break;}
		else x^=p[i];
	}
}
bool ask(int x){
	for(int i=MB;i>=0;i--)
    if((1ll<<i)&x)x^=p[i];
	return x==0;
}
int find(int x){
    return(x==fa[x]?x:fa[x]=find(fa[x]));
}
void zss(int n){
	for(int i=2;i<=n;i++)
    if(!aa[i]){
        for(int j=1;j*i<=n;j++){
            aa[j*i]=true;
            if(flc[j*i]!=-1)
            fa[find(j*i)]=find(i);
        }
    }
}
bool cmp(fish x,fish y){
    return x.fa<y.fa;
}
void news(int x){
    memset(p,0,sizeof p);
    memset(d,0,sizeof d);
    for(int i=0;i<ve[x].size();i++)ins(flc[ve[x][i]]);
}
signed main(){
    int n,q;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i],N=max(N,a[i]);
    for(int i=1;i<=N;i++)fa[i]=i,flc[i]=-1;
    for(int i=1,x;i<=n;i++)cin>>x,flc[a[i]]=x;
    zss(N);
    cin>>q;
    for(int i=1;i<=q;i++){
        int u,v,z;
        cin>>u>>v>>z;
        if(find(u)!=find(v))continue;
        Q[++top].u=u,Q[top].v=v,Q[top].z=z,Q[top].id=i,Q[top].fa=find(u);
        vis[find(u)]=1;
    }
    sort(Q+1,Q+1+top,cmp);
    for(int i=1;i<=N;i++)
    if(vis[find(i)])ve[find(i)].push_back(i);
    for(int i=1;i<=top;i++){
        if(Q[i].fa!=Q[i-1].fa)news(Q[i].fa);
        if(ask(Q[i].z))ans[Q[i].id]=1;
    }
    for(int i=1;i<=q;i++)puts((ans[i]?"Yes":"No"));
    return 0;
}
```

本来写了 123 行，太难读了，于是现在只有 71 行。

效率比较低劣，跑了 40s 以上。

注意建图和并查集的一些细节。

[提交记录](https://www.luogu.com.cn/record/list?pid=P11867&user=754021)。

---

建议评蓝或紫。

---

## 作者：Dusker (赞：1)

# 大家的公因数 2

- 预期难度：铜+/银（蓝）
- 关键词：筛法、质因数分解、图、线性基

由题意可知，两个点有一个大于 1 的公因数时会连边，则我们可以枚举每个数对的因数，根据因数的情况进行连边。

这样建图的复杂度为 $\mathcal O(n^2 \sqrt a_i)$ 的，不能接受。

考虑不枚举数对，可以通过并查集维护每个数对应的连通块，在同一个连通块 $i$ 中的数至少都有公因数 $i$。

暴力枚举每个数的因数时复杂度为 $\mathcal O(n \sqrt a_i)$，本数据范围无法通过，对每个数进行质因数分解即可。

不需要显式建图，只需要记录下每个连通块中有哪些点即可。

对于查询 $(u_i, v_i, w_i)$，进行分类讨论：
- 若 $u_i$ 和 $v_i$ 不在同一个连通块，必然无法找到合法的路径；
- 若 $u_i$ 和 $v_i$ 在同一个连通块，由样例解释可知，我们可以经过同一个点两次，从而消除该点对异或和的影响。因此，问题转化为，给定若干数，能否从其中选出一些数使得其异或和为 $w_i$。线性基即可解决。

时间复杂度为 $\mathcal O\left(n \sqrt{\frac{a_i}{\ln a_i}} + q \log n\right)$。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define ioclear std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr);
 
using i64 = long long;
 
struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if(siz[x] > siz[y])
            std::swap(x, y);
        assert(siz[x] <= siz[y]);
        siz[y] += siz[x];
        f[x] = y;
        return true;
    }
    
    int size(int x) {
        return siz[find(x)];
    }
};
 
struct Basis
{
    using i64 = long long;
    using T = i64;
    static const int n = 60;
 
    T p[n + 10] {};
 
    void add(T x)
    {
        for(int i = n; i >= 0; i--)
            if(x >> i & 1)
            {
                if(p[i] == 0)
                {
                    p[i] = x;
                    break;
                }
                x ^= p[i];
            }
        return;
    }
 
    bool query(T x)
    {
        for(int i = n; i >= 0; i--)
            if((x >> i & 1) && p[i] != 0)
                x ^= p[i];
        return x == 0;
    }
    
    T mx()
    {
        T ans = 0;
        for(int i = n; i >= 0; i--)
            ans = std::max(ans, (ans ^ p[i]));
        return ans;
    }
};
 
std::vector<int> primes;
 
void init(int up)
{
    std::vector<int> vis(up + 1, 0);
    for(int i = 2; i <= up; i++)
    {
        if(!vis[i])
        {
            primes.push_back(i);
            for(int j = 2; i * j <= up; j++)
                vis[i * j] = 1;
        }
    }
    return;
}
 
void solve()
{
    int n, mx = 0;
    std::cin >> n;
    std::vector<int> a(n + 1);
    std::vector<i64> p(n + 1);
    for(int i = 1; i <= n; i++)
    {
        std::cin >> a[i];
        mx = std::max(mx, a[i]);
    } 
    for(int i = 1; i <= n; i++)
        std::cin >> p[i];
    DSU dsu(mx + 1);
    for(int i = 1; i <= n; i++)
    {
        auto cur = a[i];
        for(auto v: primes)
        {
            if(v * v > cur)
                break;
            if(cur % v == 0)
            {
                dsu.merge(a[i], v);
                while(cur % v == 0)
                    cur /= v;
            }
        }
        if(cur > 1)
            dsu.merge(a[i], cur);
    }
    std::map<int, Basis> basis;
    // std::vector<Basis<i64>> basis(mx + 1, Basis<i64>(60));
    for(int i = 1; i <= n; i++)
        basis[dsu.find(a[i])].add(p[i]);
    int q;
    std::cin >> q;
    while(q--)
    {
        int u, v;
        i64 w;
        std::cin >> u >> v >> w;
        if(dsu.find(u) != dsu.find(v))
        {
            std::cout << "No\n";
            continue;
        }
        if(basis[dsu.find(u)].query(w))
            std::cout << "Yes\n";
        else
            std::cout << "No\n";
    }
}
 
int main()
{
    #ifdef ONLINE_JUDGE
    ioclear;
    #endif
 
    init(1E7 + 10);
    int t = 1;
    // std::cin >> t;
    while(t--)
        solve();
}

```

---

## 作者：modfish_ (赞：0)

## 思路
显然如果 $u_i$ 与 $v_i$ 不连通，那么不可能存在。

否则，有结论：找出 $u_i$ 与 $v_i$ 所在连通块的所有点的点权集合 $A$，那么 $A$ 的任意任意一个子集的异或和，都可以成为 $u_i$ 到 $v_i$ 的一条路径的点权异或和。

这个结论还挺显然的，考虑随便找一条经过所有点的路径，如果想要改变某个点的经过次数，就走一条那个点的自环即可（观察样例可以发现有自环）。

所以直接并查集维护连通块，每个连通块维护一个线性基即可。时间复杂度 $O(V\log\log V+(n+q)\log V)$，其中 $V$ 为值域。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 5, maxv = 1e7 + 5;

int pr[maxv], isp[maxv], cnt = 0;
int fa[maxv], id[maxv], it = 0;
int a[maxn], v[maxn], bas[maxn][35], tag[maxv];

void prime(int m){
    isp[1] = 1;
    for(int i = 2; i <= m; i ++){
        if(!isp[i]) pr[++ cnt] = i;
        for(int j = 1; j <= cnt && i * pr[j] <= m; j ++){
            isp[i * pr[j]] = 1;
            if(!(i % pr[j])) break;
        }
    }
}
int find(int x){
    if(fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
void insert(int i, int x){
    for(int j = 30; j >= 0; j --){
        if((x >> j) & 1){
            if(!bas[i][j]){
                bas[i][j] = x;
                break;
            }else x ^= bas[i][j];
        }
    }
}
bool query(int i, int x){
    for(int j = 30; j >= 0; j --) if((x >> j) & 1) x ^= bas[i][j];
    return !x;
}

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= 1e7; i ++) fa[i] = i;
    prime(1e7);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &a[i]);
        tag[a[i]] = 1;
    }
    for(int i = 1; i <= cnt; i ++) for(int j = 1; pr[i] * j <= 1e7; j ++) if(tag[pr[i] * j]) fa[find(pr[i] * j)] = find(pr[i]);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &v[i]);
        if(!id[find(a[i])]) id[find(a[i])] = ++ it;
        int d = id[find(a[i])];
        insert(d, v[i]);
    }
    int q;
    scanf("%d", &q);
    while(q --){
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        if(find(u) != find(v)) printf("No\n");
        else printf(query(id[find(u)], w) ? "Yes\n" : "No\n");
    }
    return 0;
}
```

---


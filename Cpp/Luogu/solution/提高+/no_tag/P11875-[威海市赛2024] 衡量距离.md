# [威海市赛2024] 衡量距离

## 题目描述

$W$ 市的交通系统由 $n$ 个站点和 $m$ 条单向道路组成，小威有一张可以乘坐 $k$ 公里的单次票，在每个站点可以指定走任意一条可使用的单向道路（从一条单向道路的一端到另一端为一站地）。

为了物尽其用，小威想知道，从哪些站出发再到哪些站结束可以存在刚好长度为 $k$ 公里的路径，请按字典序从小到大输出。

## 样例 #1

### 输入

```
3 3
1 2 1
2 3 1
3 1 1
2
```

### 输出

```
1 3
2 1
3 2
```

# 题解

## 作者：xxr___ (赞：2)

首先看到可达性问题，而且 $N$ 的范围不大，并且 $k$ 的值很大，就很难不想到矩阵快速幂。

但是这个题和普通的题不同，这个题的边权 $w\leq 10$ 不能用朴素版本来做，但是可以考虑把每个点拆成 $10$ 个点使得他们变成一条链的形态，具体建边的方式如下：
1. 把每个点拆成 $10$ 个点，我们称他叫做点 $i$ 的附属点。第 $i$ 个点的第 $j$ 个附属点的编号为 $i+(j-1)\times n$ 这样编号的好处就是不会重复，避免边和边之间的交叉问题。
2. 连边的时候，首先第 $i$ 个点的第 $j$ 个附属点向第 $i$ 个点的第 $j+1$ 个附属点连边，可以保证 $i$ 的附属点是一条链的结构。
3. 连那 $M$ 条边的时候，设边权为 $w$ 则把 $u$ 的第 $w$ 个附属点向 $v$ 连边。

这样我们就构造好了初始矩阵，接下来考虑矩阵快速幂的时候如何更新矩阵。

由于我们每个点增加了 $10$ 个附属点，所以现在一共有 $10\times n$ 个节点，也就是 $1000$ 级别，如果直接上矩阵快速幂并且使用朴素版更新的话是 $O(n^3\log k)$ 的，这里 $n\leq 1000$ 所以无法接受，我们发现在更新的时候实际上是类似于一个传递闭包的形式的，并且 $j$ 的那一维是没有用的所以可以使用 `bitset` 优化它，这样时间复杂度就变成了 $O(\frac{n^3}{w} \log k)$ 可以通过。

[代码](https://www.luogu.com.cn/record/211432359)

---

## 作者：lrx___ (赞：1)

## 矩阵乘法与路径问题

首先，我们知道一般的矩阵乘法，一个 $N \times M$ 的矩阵与一个 $M \times P$ 相乘：

$$C_{i, j} = \sum \limits_{k = 1}^M A_{i, k} \times B_{k, j}$$

该运算具有结合律，即 $(A \times B) \times C = A \times (B \times C)$。感性理解：乘法和加法具有结合律。

我们将乘法改成**逻辑与**，求和改成**逻辑或**，便得到了一种新的矩阵乘法。即：

$$C_{i, j} = \lor _{k = 1}^M A_{i,k} \land B_{k, j}$$

（$\lor$ 表示逻辑或，$\land$ 表示逻辑与）这个矩阵乘法也具有结合律。感性理解：逻辑与和逻辑或具有结合律。

那这个矩阵乘法有什么意义呢？

我们考虑一个图的邻接矩阵（边权都为 $1$）。将邻接矩阵与自己相乘，设原邻接矩阵为 $F$，与自己相乘后为 $G$：

$$G_{i, j} = \lor_{k = 1}^N F_{i, k} \land F_{k, j}$$

即：对于 $(i, j)$，如果存在 $k$ 使得 $F_{i, k}$ 和 $F_{k, j}$ 都为 $1$，则 $G_{i, j}$ 为 $1$，否则为 $0$。

那它的实际意义就是：对于 $i, j$，如果存在 $k$ 使得 $i$ 能走到 $k$，$k$ 能走到 $j$，那么 $G_{i, j}$ 为 $1$。

也就是说，如果 $i, j$ 之间存在长度为 $2$ 的边时，$G_{i, j} = 1$。

所以，$F$ 的 $n$ 次方 $F^n$ 就表示了经过 $n$ 条边的情况：如果 $F^n_{i, j} = 1$，则 $i$ 可以经过 $n$ 条边到达 $j$。

## 回到原题

如果无重边无边权，我们直接将邻接矩阵进行矩阵快速幂即可。时间复杂度为 $\mathcal{O}(N^3 \log K$)。

但是原题中不仅有重边，边还有边权，该怎么处理呢？

第一个想法应该是设立 $10$ 个扩展点，如果边 $(i, j)$ 长度为 $w$，就从 $i$ 连 $w - 1$ 个扩展点，再到 $j$，即 $i \to u_1 \to u_2 \to \dots \to u_{w - 1} \to j$。

但这样会有什么问题呢？

如果边 $(i, j)$ 长度为 $2$，边 $(k, l)$ 长度为 $2$，$i, k$ 都连向 $u_1$，$u_1$ 同时指向 $j, l$，则会凭空产生 $(i, l)$ 和 $(k, j)$ 的边。因此该方案不可行。

修改一下：我们对每个点建立 $9$ 个出点，设 $i$ 的出点为 $i_{1 \sim 9}$，用 $i_0$ 表示 $i$，且初始有边 $i \to i_1 \to i_2 \to \dots \to i_9$。对于长度为 $w$ 的边 $(i, j)$，只需连接 $i_{w - 1}$ 和 $j$ 即可。因此这个问题解决了。

现在变成了 $1000$ 个点，无法再直接矩阵乘法了。怎么办？

注意到这个矩阵乘法只涉及到逻辑与和逻辑或，因此可以使用 `std::bitset` 优化。

```cpp
// 原矩阵乘法：
for (int k = 0; k < N; ++k) {
  for (int i = 0; i < N; ++k) {
    for (int j = 0; j < N; ++j) {
      c[i][j] |= a[i][k] & b[k][j];
    }
  }
}
// 发现最后枚举的 j 跟 a[i][k] 无关，于是可以变成：
for (int k = 0; k < N; ++k) {
  for (int i = 0; i < N; ++k) {
    if (a[i][k]) {
      for (int j = 0; j < N; ++j) {
        c[i][j] |= b[k][j];
      }
    }
  }
}
// 发现最后一维都是 j，所以这一维改为 std::bitset。
for (int k = 0; k < N; ++k) {
  for (int i = 0; i < N; ++k) {
    if (a[i].test(k)) {
      c[i] |= b[k];
    }
  }
}
```

时间复杂度为 $\mathcal{O}(\frac{n^3 \log K}{\omega})$ 带 $1000$ 的常数。可以通过本题。

## 代码

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <bitset>
using i8 = signed char;
using i64 = long long;
using u32 = unsigned;
using u64 = unsigned long long;
using f64 = double;

constexpr int N = 1000;
struct matrix {
	std::vector<std::bitset<N>> a;
	matrix(): a(N){}
	matrix(const matrix&) = default;
	matrix(matrix&&) = default;
	matrix& operator=(const matrix&) = default;
	matrix& operator=(matrix&&) = default;
	std::bitset<N>& operator[](int k) {
		return a[k];
	}
	const std::bitset<N>& operator[](int k) const {
		return a[k];
	}
	matrix operator*(const matrix& b) const {
		matrix c;
		for (int k = 0; k < N; ++k) {
			for (int i = 0; i < N; ++i) {
				if (a[i].test(k)) {
					c[i] |= b[k];
				}
			}
		}
		return c;
	}
};
void solve(int) {
	int n, m;
	std::cin >> n >> m;
	matrix g;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < 8; ++j) {
			// i + j * n 即为 i 的第 j 个出点。当 j = 0 时，该点为原图中的点
			g[i + j * n].set(i + (j + 1) * n);
		}
	}
	for (int i = 0, u, v, w; i < m; ++i) {
		std::cin >> u >> v >> w;
		--u; --v;
		g[u + n * (w - 1)].set(v);
	}
	i64 k;
	std::cin >> k;
	if (k == 0) { // 这里需要特判
		for (int i = 0; i < n; ++i) {
			std::cout << (i + 1) << ' ' << (i + 1) << '\n';
		}
		return;
	}
	matrix r(g);// 这里已经是 1 次方了
	for (--k; k; k >>= 1, g = g * g) {
		if (k & 1) {
			r = r * g;
		}
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (r[i].test(j)) {
				std::cout << (i + 1) << ' ' << (j + 1) << '\n';
			}
		}
	}
}
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	int t = 1;
	// std::cin >> t;
	for (int c = 1; c <= t; ++c) solve(c);
	return 0;
}
```

---


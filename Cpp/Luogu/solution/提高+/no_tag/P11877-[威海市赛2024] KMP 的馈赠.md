# [威海市赛2024] KMP 的馈赠

## 题目描述

小威正在学习字符串相关的内容，今天，他开始学习 KMP 算法。

正好，小海精通 KMP 算法，向小威讲述了算法流程，并向小威提出了一个问题：

小海给了小威一个长度为 $n$ 的字符串 $s$，定义一个前缀 $s_{1:i}$ 的价值 
$$v_i = i \oplus \operatorname{len}(\operatorname{border}(s_{1:i}))$$ 
其中：
- $\oplus$ 表示按位异或；
- $\operatorname{border}(s)$ 表示 $s$ 中最长的前缀与后缀相同的子串，例如：$\operatorname{border}(abcda) = a$，$\operatorname{border}(aaa) = aa$；
- $\operatorname{len}(s)$ 表示 $s$ 的长度。

特别地，定义空串的价值 $v_0 = 0$。

小海告诉小威，如果要在 $s$ 中选择一个前缀 $t$，那同时要选择前缀 $\operatorname{border}(t)$，例如，如果小威选择了 $aaa$，那么小威需要同时选择 $aa, a, \varepsilon$，其中 $\varepsilon$ 表示空串。如此，小威选择了 $\{aaa, aa, a, \varepsilon\}$ 共 $4$ 个前缀。称这为一个前缀集合，前缀集合的价值为集合中所有前缀的价值之和。

对于一个字符串 $x$ 的前缀集合 $u$，和另一个字符串 $y$ 的前缀集合 $v$，设把它们合并后的前缀集合为 $\{u \cup v\} \setminus \{u \cap v\} \cup \{g(x, y)\}$。其中 $g(x, y)$ 表示 $x$ 和 $y$ 的最长公共 border。特别地，若 $x$ 属于 $y$ 的 前缀集合，则 $g(x,y) = x$。

例如，$u$ 为 $aaa$ 的前缀集合，$v$ 为 $aba$ 的前缀集合，则合并后为
$$\{\varepsilon, a, aa, aaa, aba\} \setminus \{\varepsilon, a\} \cup \{a\} = \{a, aa, aaa, aba\}$$

小海会问小威 $m$ 次，是否存在两个不同的前缀集合 $u$ 和 $v$，使得合并 $u$ 和 $v$ 后的价值之和为 $k$？


## 样例 #1

### 输入

```
5 4
abcab
0
15
10
18
```

### 输出

```
No
Yes
Yes
No
```

## 样例 #2

### 输入

```
10 8
wlwlwlwlwl
0
14
1
9
6
2
2
14
```

### 输出

```
No
No
Yes
Yes
No
Yes
Yes
No
```

# 题解

## 作者：MrPython (赞：0)

做个题给我气笑了，难点在于读题。

考虑字符串的所有 $s$ 所有前缀所构成的集合 $p_s = \{s_{1:i} | 0 \leq i \leq \left|s\right| \}$。由于 $\operatorname{border}(t)$ 是 $t$ 的前缀，显然有 $t \in s \Rightarrow \operatorname{border}(t)\in s$。将 $s$ 中的每个元素视为图上的点，并对于所有满足 $t \in s \wedge t \neq \varepsilon$ 的字符串 $t$ 在图上添加边 $t \leftrightarrow \operatorname{border}(t)$，则整张图会构成一颗以 $\varepsilon$ 为根的树。

用 $s$ 的前缀 $x$ 生成的前缀集合 $u$ 也要求 $t \in s \Rightarrow \operatorname{border}(t)\in s$，则 $u$ 显然是 $s$ 的子集，用刚才的方式生成的图即为树上 $x$ 到跟 $\varepsilon$ 的链。$g(x,y)$ 则是图上 $x$ 和 $y$ 的 LCA。因此，最后合并后的集合是树上 $x$ 到 $y$ 路径上的点所构成的集合。

然后你发现这其实是点分治板子，然后就做完了。

---

## 作者：Dusker (赞：0)

# KMP 的馈赠

- 预期难度：银（蓝+/紫-，可评紫）
- 关键词：KMP、border tree、树上问题、点分治、dsu on tree

注意到题目中的 len(border) 即为 KMP 算法所求的 nxt 数组。

由 $nxt_i \to i$ 建树，则两个集合 $u$ 和 $v$ 的合并过程等价于从树上找到 $u \to v$ 的路径。

题意转化为能否找到一条路径，使得点权和为 $k$。

暴力是 $\mathcal O(mn^2 \log n)$ 的，无法接受。

暴力写法是 `dis[u] + dis[v] - 2 * dis[lca(u, v)] + val[lca(u, v)]`，而不是 `dis[u] + dis[v] - dis[lca(u, v)]`，我第一遍暴力也写错了（

事实上，这是点分治应用的经典问题，直接点分治即可通过。时间复杂度为 $\mathcal O(mn \log n)$。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define ioclear std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr);

constexpr int inf = 0x3f3f3f3f;

std::vector<int> judge(1E7 + 10);

void solve()
{
    int n, m;
    std::string s;
    std::cin >> n >> m >> s;
    s = '#' + s;
    std::vector<int> nxt(n + 1);
    for(int i = 2, p = 0; i <= n; i++)
    {
        while(p && (s[p + 1] != s[i]))
            p = nxt[p];
        p = nxt[i] = p + (s[p + 1] == s[i]);
    }
    std::vector<int> v(n + 1);
    for(int i = 1; i <= n; i++)
        v[i] = i ^ nxt[i];
    std::vector<std::vector<int>> edge(n + 1);
    auto add = [&](int u, int v)
	{
		edge[u].push_back(v);
	};
    for(int i = 1; i <= n; i++)
	{
		add(nxt[i], i);
		add(i, nxt[i]);
	} 
	std::vector<int> siz(n + 1), maxp(n + 1), vis(n + 1), dis(n + 1), rem(n + 1), q(n + 1);
	std::vector<int> query(m + 1), ok(m + 1);
	int rt = 0, sum = n;
	maxp[rt] = n;
	auto getrt = [&](auto &&self, int u, int fa) -> void
	{
		siz[u] = 1;
		maxp[u] = 0;
		for(auto vv: edge[u])
		{
			if(vis[vv] || vv == fa)
				continue;
			self(self, vv, u);
			siz[u] += siz[vv];
			maxp[u] = std::max(maxp[u], siz[vv]);
		}
		maxp[u] = std::max(maxp[u], sum - siz[u]);
		if(maxp[u] < maxp[rt])
			rt = u;
	};
	
	auto getdis = [&](auto &&self, int u, int fa) -> void
	{
		if(dis[u] > 1E7)
            return;
		rem[++rem[0]] = dis[u];
		for(auto vv: edge[u])
		{
			if(vis[vv] || vv == fa)
				continue;
			dis[vv] = dis[u] + v[vv];
			self(self, vv, u);
		}
	};

	auto calc = [&](int u)
	{
		int p = 0;
		for(auto vv: edge[u])
		{
			if(vis[vv])
				continue;
			rem[0] = 0;
			dis[vv] = v[vv];
			getdis(getdis, vv, u);
			for(int j = rem[0]; j; j--)
				for(int k = 1; k <= m; k++)
					if(query[k] >= rem[j] + v[u])
						ok[k] |= judge[query[k] - rem[j] - v[u]];
			for(int j = rem[0]; j; j--)
				q[++p] = rem[j], judge[rem[j]] = 1;
		}
		for(int i = 1; i <= p; i++)
			judge[q[i]] = 0;
	};

	auto solv = [&](auto &&self, int u) -> void
	{
		vis[u] = judge[0] = 1;
		calc(u);
		for(auto vv: edge[u])
		{
			if(vis[vv])
				continue;
			sum = siz[vv];
			maxp[rt = 0] = inf;
			getrt(getrt, vv, -1);
			self(self, rt);
		}
	};

	for(int i = 1; i <= m; i++)
		std::cin >> query[i];
	maxp[rt] = sum = n;
	getrt(getrt, 0, -1);
	solv(solv, rt);

	for(int i = 1; i <= m; i++)
		std::cout << (ok[i] ? "Yes" : "No") << endl;
	
}

int main()
{
    #ifdef ONLINE_JUDGE
    ioclear;
    #endif
    
    int t = 1;
    // std::cin >> t;
    while(t--)
        solve();
}
```

验题队写了 dsu on tree 做法，也放过去了。时间复杂度为 $\mathcal O(mn \log^2 n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
 
typedef vector<int> vint;
 
const int N = 50005;
 
int nxt[N];
int n, m, d[N];
vint e[N];
int qr[505], as[505], val[N];
 
set<int> b[N];
 
void dfs(int u, int pa) {
    d[u] += val[u];
    b[u].insert(d[u]);
    for (int v : e[u]) {
        d[v] = d[u];
        dfs(v, u);
        if (b[u].size() < b[v].size()) b[v].swap(b[u]);
        for (int i : b[v]) {
            for (int j = 1; j <= m; ++j)
                if (!as[j] && b[u].find(qr[j] + d[u] + d[pa] - i) != b[u].end()) as[j] = 1;
        }
        b[u].merge(b[v]);
    }
   // for (int i : b[u]) cout << i << ' '; cout << ": " << u << '\n';
}
 
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    string s; cin >> s; s = '#' + s;
    for (int i = 2,p = 0; i <= n; ++i) {
        while(p && s[i] != s[p + 1]) p = nxt[p];
        if(s[i] == s[p + 1]) p ++;
        nxt[i] = p;
    }
    for (int i = 1; i <= n; ++i) e[nxt[i]].push_back(i), val[i] = i ^ nxt[i];
    for (int i = 1; i <= m; ++i) cin >> qr[i];
    dfs(0, 0);
    for (int i = 1; i <= m; ++i) cout << (as[i] ? "Yes" : "No") << '\n';
    return 0;
}

```

---


# [威海市赛2024] 速成之道

## 题目描述

在某场梦中，你预见了 CPCI 赛场中那道杀死你的题目，为了悲剧不在现实中发生，你决定迅速掌握解决这道题的能力。

现在的你对此题目涉及的相关基础内容一窍不通，但却了解学习路线------这方面的知识图谱是一个有向无环图！可以抽象成 $n$ 个知识点，在知识点之间存在 $m$ 个依赖关系。在你掌握第 $i$ 知识点的全部前置知识点后，你可以付出 $a_i$ 的时间学会它。你深知自己的时间不够系统地去学习，而且知识点不必通过掌握其前置，也可以通过付出更长的时间代价 $b_i$ 攻克它。而解决这道题目，需要用到知识点为 $X$，你要做的是，用最短的时间速成知识点 $X$。

## 样例 #1

### 输入

```
4 4
1 2
1 3
2 4
3 4
3 5 7 9
5 10 15 30
4
```

### 输出

```
24
```

## 样例 #2

### 输入

```
5 5
1 2
1 3
2 4
4 5
3 5
3 5 7 9 11
5 5 5 50 50
5
```

### 输出

```
30```

# 题解

## 作者：Dream_poetry (赞：5)

### 思路：
一眼网络流，但是需要一些神奇的建边方式。

我们考虑建立超级源点和超级汇点，并把每个点拆分为 $x1,x2$，分别表示两种情况。

我们让超级源点像每个 $x1$ 建一条容量为 $A_x$ 的单向边，反边正常建为 $0$ 就行。

随后，我们从 $x1$ 向 $x2$ 建一条容量为 $B_x$ 的单向边，反边正常建为 $0$。

考虑对于每一条限制，让 $x_2$ 向 $y_1$ 建边，边权正无穷，以表明约束关系。反边照旧。

最后，我们考虑让 $q_2$ 直接连向汇点，边权设为正无穷。

不难发现，我们这种建边方式满足了我们需要达成的限制，通过观察和模拟，也不难发现我们要求的答案就是最小割。

按最大流最小割定理，把最大流一求，输出即可。


### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
const int Maxn=1e12; 

struct node{
	int nex,to,val;
}e[1000005];
int tot=1;
int he[1000005];

inline void add(int x,int y,int w){
	e[++tot].nex=he[x];
	e[tot].to=y;
	e[tot].val=w;
	he[x]=tot;
}

int a[1000005];
int p[1000005];

int q;



int ans;

int dis[1000005];
int now[1000005];
int s,t;


inline int bfs(){
	for (int i=1;i<=2*n+2;i++){
		dis[i]=Maxn;
	}
	queue<int>q;
	q.push(s);
	dis[s]=0;
	now[s]=he[s];
	while(q.size()){
		int x=q.front();
		q.pop();
		for (int i=he[x];i;i=e[i].nex){
			int v=e[i].to;
			if (e[i].val>0 && dis[v]==Maxn){
				q.push(v);
				now[v]=he[v];
				dis[v]=dis[x]+1;
				if (v==t){
					return 1;
				}
			}
		}
	} 
	return 0;
}

inline int dfs(int x,int sum){
	if (x==t){
		return sum;
	}
	int res=0;
	for (int i=now[x];i && sum;i=e[i].nex){
		now[x]=i;
		int v=e[i].to;
		if (e[i].val>0 && (dis[v]==dis[x]+1)){
			int k=dfs(v,min(sum,e[i].val));
			if (k==0){
				dis[v]=Maxn;
			}
			e[i].val-=k;
			e[i^1].val+=k; 
			res+=k;
			sum-=k;
		}
	}
	return res;
}



int x[1000005];
int y[1000005];

signed main(){
	cin>>n>>m;
	s=2*n+2;
	t=2*n+1;
	for (int i=1;i<=m;i++){
		cin>>x[i]>>y[i];
	}
	for (int i=1;i<=n;i++){
		cin>>a[i];
	} 
	for (int j=1;j<=n;j++){
		cin>>p[j];
	}
	
	for (int i=1;i<=n;i++){
		add(s,i,a[i]);
		add(i,s,0);
	}
	for (int i=1;i<=n;i++){
		add(i,i+n,p[i]);
		add(i+n,i,0);
	}
	
	for (int i=1;i<=m;i++){
		add(x[i]+n,y[i],Maxn);
		add(y[i],x[i]+n,0);
	}
	cin>>q;
	add(q+n,t,Maxn);
	add(t,q+n,0);
	while(bfs()){
		ans+=dfs(s,Maxn);
	} 
	
	cout<<ans;
	
	return 0;
}
```

---

## 作者：xxr___ (赞：3)

楼上讲的很有道理，这里主要讲下这样建图的原理。

首先，看到这种题，可以考虑建最小割模型来解决，可以理解成如果删了哪条边那么一定也要删那些边，这些条件就形成了一些约束关系。这道题也是这样的。

首先，把每个点 $x$ 拆点，拆成 $x_1,x_2$ 并且建一个超级源点，超级汇点，分别记 $s,t$。

建边：
- $s→x_1,x\in [1,n]$，流量是 $A_x$。
- $x_2→t,x = X$，流量是 $\infty$。
- $x_1→x_2,x\in [1,n]$，流量是 $B_x$。

这样建图为什么对呢，这里就提到了刚刚说到的约束关系了。

先不考虑约束关系，把图建出来，长这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/oyf9jlu7.png)

可以发现，此时想让 $s$ 和 $t$ 不联通，实际上就是删除 $s→t$ 路径上边权最小的那个边，也就是 $A_i$ 或者 $B_i$ 这是满足要求的。

那么如果加入了约束点呢？比如加入约束，如果想要速通 $i$ 需要先速通 $j$。那么图长这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/mc694j52.png)

这样，我们再来看原图的割：
- 如果我们只割 $i→i'$ 的边，此时边权是 $B_i$ 可行，相当于直接速通了 $i$ 没用到前置速通知识。
- 如果我们此时割 $s→i$ 的边，那么我们肯定还得割 $s→j→j'→i$ 的任意一条边，要不然就不是割了，根据最小割的原理，我们会割最小的那条边，也就是 $\min(A_j,B_j)$ 这是满足条件的，相当于要么速通了 $j$ 以及前置知识然后用了 $A_j$ 要么直接速通 $j$。

综上，我们这么建图是很对的，然后代码就很好写了。

代码：

```cpp
#include<iostream>
#include<queue>
#define int long long
const int N = 40005,inf = 1e9;
int n,m,s,t,head[405],a[N],b[N],tot=1;
struct edge{
	int to,flow,nxt;
}e[N<<2];
void add(int u,int v,int w){
	e[++tot].to=v;
	e[tot].flow=w;
	e[tot].nxt=head[u];
	head[u]=tot;
	e[++tot].to=u;
	e[tot].flow=0;
	e[tot].nxt=head[v];
	head[v]=tot;
}
int dep[405],cur[405];
bool vs[405];
bool bfs(){
	std::queue<int> q;
	for(int i=0;i<=t;++i){
		vs[i]=0;cur[i]=head[i];dep[i]=-1;
	}
	q.push(s);dep[s]=0;
	while(q.size()){
		int u=q.front();q.pop();
		if(u==t) return true;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(!(~dep[v])&&e[i].flow>0){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return false;
}
int dfs(int x,int flow){
	if(x==t || !flow) return flow;
	int used=0;
	vs[x]=1;
	for(int i=cur[x];i&&flow;i=e[i].nxt){
		cur[x]=i;
		int v=e[i].to;
		if(e[i].flow>0&&!vs[v]&&dep[v]==dep[x]+1){
			int k=dfs(v,std::min(flow,e[i].flow));
			if(!k){
				dep[v]=inf;
			}
			used += k;flow -= k;
			e[i].flow -= k;e[i^1].flow += k;
		}
	}
	vs[x]=0;
	if(!used) vs[x]=1;
	return used;
}
int32_t main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin>>n>>m;
	s=0;t=401;
	for(int i=1;i<=m;++i){
		int x,y;
		std::cin>>x>>y;
		add(x+n,y,inf);
	}
	for(int i=1;i<=n;++i){
		std::cin>>a[i];
		add(s,i,a[i]);
	}
	for(int i=1;i<=n;++i){
		std::cin>>b[i];
		add(i,i+n,b[i]);
	}
	int x,ans=0;
	std::cin>>x;
	add(x+n,t,inf);
	while(bfs()){
		ans+=dfs(s,inf);
	}
	std::cout<<ans;
	return 0;
}
```

---

## 作者：EternalHeart1314 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11879)

# Problem

给定一个依赖图，$x\rightarrow y$ 表示 $y$ 依赖 $x$。攻克一个点可以直接花费 $b_i$ 或先攻克这个点所依赖的所有点，然后再花费 $a_i$。求攻克 $X$ 的最小代价。$n\le100$。

# Solution

最小割。套路拆点，$i_1$ 为入点，$i_2$ 为出点。攻克 $i$ 表示 $S\longrightarrow i_2$ 不连通。$X_2\xrightarrow\infty T$，表示不能割即要攻克 $X$。$i_1\xrightarrow{b_i}i_2$，表示割掉直接攻克 $i$。$S\xrightarrow{a_i} i_1$ 和 $j_2\xrightarrow\infty i_1$（$i$ 依赖 $j$），表示将所有 $i$ 依赖的点攻克后再花费 $a_i$ 就可以攻克 $i$。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 7, INF = 1e9;
int n, m, s, t, tot = -1, ans, to[N], wt[N], hd[N], nxt[N], d[N], nw[N];

inline void add(int u, int v, int w) {
    nxt[++tot] = hd[u], to[hd[u] = tot] = v, wt[tot] = w;
    nxt[++tot] = hd[v], to[hd[v] = tot] = u;
}
inline bool BFS() {
    for (int i = 0; i <= t; ++i) d[i] = INF, nw[i] = hd[i];
    queue<int> q; q.push(s), d[s] = 0;
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int i = nw[u]; ~i; i = nxt[i])
            if (d[to[i]] == INF && wt[i]) {
                q.push(to[i]);
                d[to[i]] = d[u] + 1;
            }
    }
    return d[t] < INF;
}
inline int Dinic(int u, int florr) {
    if (u == t) return florr;
    int cur = florr, k;
    for (int i = nw[u], v; ~i && cur; i = nxt[i]) {
        nw[u] = i, v = to[i];
        if (d[v] == d[u] + 1 && wt[i]) {
            k = Dinic(v, min(cur, wt[i]));
            wt[i] -= k, wt[i ^ 1] += k, cur -= k;
        }
    }
    return florr - cur;
}

int main() {
    memset(hd, -1, sizeof hd);
    cin >> n >> m, t = n + n + 1;
    for (int i = 1, u, v; i <= m; ++i)
        cin >> u >> v, add(u * 2, v * 2 - 1, INF);
    for (int i = 1, a; i <= n; ++i)
        cin >> a, add(s, i * 2 - 1, a);
    for (int i = 1, b; i <= n; ++i)
        cin >> b, add(i * 2 - 1, i * 2, b);
    cin >> m, add(m * 2, t, INF);
    while (BFS()) ans += Dinic(s, INF);
    return cout << ans, 0;
}
```

---

## 作者：Damon12 (赞：0)

## P11879 [威海市赛2024] 速成之道题解

对于我这种蒟蒻来说，有些时候建模太难了。于是我点开了题解，看了大佬们讲的，还是不知道为何那样建模，于是用了一上午想这题，想通了 QwQ。

~~于是好心的我来发篇题解帮助后人。~~

---
由于题目给的信息相当于是点权，但是点权不好处理，于是就要拆点。为了叙述方便，令 $x$ 拆点后为 $x_{in}$ 与 $x_{out}$。

然后我们倒推，由于最后的流要流到 $X_{out}$，于是有两种方案可选。
1. 直接学习 $X$，花费时间为 $b_X$。
2. 学习 $X$ 的前置知识，假设要花费 $c_X$ 的时间，再加上 $a_X$。

于是结果为 $\min(c_X+a_X,b_X)$，刚好符合网络流里“串联”的性质。继续倒推 $c_X$ 的值，就是所有连向 $X$ 的点的边权和。设 $p$ 为连向 $X$ 的任意一点，$U$ 为直接连向 $X$ 的所有边的集合，拆点后可将 $X_{in}$ 与 $p_{out}$ 视作同一点，于是：
$$c_X=\sum_{u\in U}^{} c_u$$
刚好符合网络流的“并联”性质。每个点同理推下去，很容易发现 $x_{in}$ 与 $x_{out}$ 之间边权应该为 $b_x$，由于 $X_{in}$ 与 $p_{out}$ 视作了同一点，所以 $X_{in}$ 与 $p_{out}$ 之间的边权应为 $\infty$。

这时候我们画个局部图![局部图](https://cdn.luogu.com.cn/upload/image_hosting/1gni0251.png)我们发现应该还要加一个 $a_x$ ，那这个点应该由谁来承担呢，可以建个超级源点 $S$ ，$S$ 把每个点全部连上，边权为 $a_x$。

这样，我们所有的点就都连完了，我们连最小割的知识点都没用上，网络流用 $dinic$。

### 理一下思路
1. 读入 $n,m$。
2. 对于每个 $x,y$，把 $x_{out}$ 连向 $y_{in}$，边权 $\infty$。
3. 让 $S$ 连上每个 $i$，边权 $a_i$。
4. 对于每个 $i$，让 $i_{in}$ 连上 $i_{out}$，边权 $b_i$。

#### AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define inf 1e18
using namespace std;
const int N=205;
struct node{
	int v,r;
	ll w;
};
int n,m,s,t;
vector<vector<node> >adj(N);
vector<int> ptr(N),level(N);
void add(int u,int v,int w){
	adj[u].pb((node){v,adj[v].size(),w});
	adj[v].pb((node){u,adj[u].size()-1,0});
	return ;
}
bool bfs(int s,int t){
    fill(level.begin(),level.end(),-1);
	level[s]=0;
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(node v:adj[u]){
			if(level[v.v]==-1 && v.w>0){
				level[v.v]=level[u]+1;
				if(v.v==t)return 1;
				q.push(v.v);
			}
		}
	}
	return 0;
}
ll dfs(int u,int t,ll flow){
	if(u==t)return flow;
	for(int &i=ptr[u];i<adj[u].size();i++){
		node &e=adj[u][i];
		if(level[e.v]==level[u]+1 && e.w>0){
			ll nflow=dfs(e.v,t,min(flow,e.w));
			if(nflow>0){
				e.w-=nflow;
				adj[e.v][e.r].w+=nflow;
				return nflow;
			}
		}
	}
	return 0;
}
ll din(int s,int t,int n){
	ll maxflow=0;
	adj.resize(n);ptr.resize(n);level.resize(n);
	while(bfs(s,t)){
		fill(ptr.begin(),ptr.end(),0);
		while(ll flow=dfs(s,t,inf)){
			maxflow+=flow;
		}
	}
	return maxflow;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		add(x+n,y,inf);
	}
	for(int i=1;i<=n;i++){
		int a;
		cin>>a;
		add(0,i,a);//超级源点 S 的编号为 0
	}
	for(int i=1;i<=n;i++){
		int b;
		cin>>b;
		add(i,i+n,b);//拆点会吧，(i+n)就是 i 的“out”节点
	}
	int X;
	cin>>X;
	cout<<din(0,X+n,n*2+1)<<"\n";//n*2 是总节点数，(X+n)是 X 的“out”节点
	return 0;
}
```

记得数组开两倍 QwQ。

---

## 作者：Tachibana27 (赞：0)

对于一个知识点，我们一定采用以下三种方式之一：

1. 全力学习前置知识，然后花费 $a_i$。

2. 全力 $b_i$ 学习。

3. 不学。



在三个方式中选择一个，启发我们思考最小割。

考虑以下的连边方式：

1. 将知识点 $x_i$ 拆分为 $x_{i,1}$，$x_{i,2}$。将源点 $S$ 与 $x_{i,1}$ 连边，边权为 $a_i$；将 $x_{i,1}$ 与 $x_{i,2}$ 连边，边权为 $b_i$。

2. 对于 $x$ 依赖 $y$ 的知识点，$y_2$ 向 $x_1$ 连边，边权为正无穷。即这条边不允许被割，因为这是题目所给的。

3. 对于点 $X$，$X_2$ 向汇点连边，边权为正无穷。

这样建图我们发现：

方法一，割掉边权为 $a_i$ 的边后，依赖也要学，再去选择依赖割哪条边；

方法二，割掉边权为 $b_i$ 的边；

方法三，这个最简单，不管它，哪条边也不割就相当于不学了。

选择割哪条边最优的问题可以直接利用最大流最小割定理跑 Dinic 解决。

```cpp
#define int long long
int n,m,s,t;
#define N 286
#define INF 1000000000000000
class node{
    public:
        int v;
        int w;
        int id;
};
std::vector<node>e[N];
//这一部分是手写队列，比较冗长，删掉了。当这里有个 std::queue<int>q 就行
int lv[N];
int kkk[N];
inline bool bfs(){
    memset(kkk,0,sizeof kkk);
    q.clear();
    memset(lv,0,sizeof lv);
    q.push(s);
    lv[s]=1;
    while(not q.empty()){
        int x=q.top();
        q.pop();
        for(int i=0;i<e[x].size();i++){
            int v=e[x][i].v;
            int w=e[x][i].w;
            if(w and not lv[v]){
                lv[v]=lv[x]+1;
                q.push(v);
                if(v==t)
                    return true;
            }
        }
    }
    return false;
}
int dfs(int x,int f){
	if(x==t)
		return f;
    int qwq=f;
    for(int i=kkk[x];i<e[x].size() and qwq;i++){
        kkk[x]=i;
        int v=e[x][i].v;
        int w=e[x][i].w;
        if(w and lv[v]==lv[x]+1){
            int awa=dfs(v,std::min(qwq,w));
            if(not awa)
                lv[awa]=0;
            e[x][i].w-=awa;
            e[v][e[x][i].id].w+=awa;
            qwq-=awa;
        }
    }
    return f-qwq;
}
int ans;
inline void adeg(int u,int v,int w){
    e[u].push_back((node){v,w,e[v].size()});
    e[v].push_back((node){u,0,e[u].size()-1});
    return;
}
int a[N];
int b[N];
int awa;
signed main(){
    std::cin>>n>>m;
    s=(n<<1) bitor 1;
    t=s+1;
    for(int i=1;i<=m;i++){
        int x,y;
        std::cin>>x>>y;
        adeg(x<<1,(y<<1)-1,INF);
    }
    for(int i=1;i<=n;i++)
        std::cin>>a[i];
    for(int i=1;i<=n;i++)
        std::cin>>b[i];
    std::cin>>awa;
    adeg(awa<<1,t,INF);
    for(int i=1;i<=n;i++){
        adeg(s,(i<<1)-1,a[i]);
        adeg((i<<1)-1,i<<1,b[i]);
    }
    while(bfs())
        ans+=dfs(s,INF);
    std::cout<<ans;
    return 0;
}
```

---


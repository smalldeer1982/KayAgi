# [PA 2025] 叠积木 / Wieża

## 题目背景

PA 2025 R4C.



## 题目描述


有 $n$ 块正方体积木，编号 $1\sim a_i$。第 $i$ 块积木的边长为 $a_i$，图案种类为 $w_i$。

我们称一座**塔**是一个序列 $p_1,p_2,\ldots,p_m$，其中 $1\le p_i\le n$，且 $p_i$ 两两不同。

一座塔是**稳的**，当且仅当：

- $\forall 1\le i\lt m$，$a_{p_i}\gt a_{p_{i+1}}$。

给定正整数 $c$。定义一座塔的**美观度**为：

$$\sum_{1\le i\le m} a_{p_i}-c\cdot \sum_{1\le i\lt m} [w_{p_i}\neq w_{p_{i+1}}]$$

换句话说，是组成塔的积木高度减去（相邻的不同图案的积木对数乘以 $c$）。

求出**稳的**塔的最大美观度。


## 说明/提示

### 样例解释

**两个样例中**，四块积木的形状和图案如下所示。两个样例唯一的区别只有 $c$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fgnbuet8.png?x-oss-process=image/resize,m_lfit,h_150)


样例 $1$ 中，下图的两个稳的塔的美观度是最大的，为 $4+3+1-(1+1)\times 1=6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ys9t7rao.png?x-oss-process=image/resize,m_lfit,h_150)


但是在样例 $2$ 中，上图的塔的美观度为 $-2$。样例 $2$ 中美观度最大的稳的塔如下所示，它的美观度为 $4+1-5\times 0=5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/l1ou8e1y.png?x-oss-process=image/resize,m_lfit,h_100)

### 子任务

在价值 $50$ 分的子任务中，满足 $\forall 1\le i\lt n$，$a_i\lt a_{i+1}$。

### 数据范围

- $1\le n,c,a_i,w_i\le 5\times 10^5$；
- $\forall 1\le i\lt n$，$a_i\le a_{i+1}$。


## 样例 #1

### 输入

```
4 1
1 1
3 2
4 3
4 1```

### 输出

```
6```

## 样例 #2

### 输入

```
4 5
1 1
3 2
4 3
4 1```

### 输出

```
5```

# 题解

## 作者：冷却心 (赞：0)

花绿青。

超级简单的 dp。记 $f_i$ 表示以 $i$ 结尾的塔的最大美观度。因为要满足严格偏序，所以维护一个指针 $j$ 不停往右移动到最后一个**小于** $a_i$ 的位置即可，那么转移是：

- 新开一个序列 $f_i \gets a_i$。
- 任意颜色转移，付出代价 $c$，$\displaystyle f_i \leftarrow \max_{1\le k\le j} f_i + a_i - c$。
- 钦定上一位颜色相同，$\displaystyle f_i \gets \max_{1\le k\le j \wedge w_k = w_i} f_k + a_i$。

第二种转移直接移动指针维护 $\max$，第三种转移对每种颜色统计 $\max$，然后做完了，答案是 $f$ 的最大值。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 5e5 + 10;
int n, C, W[N]; LL A[N], F[N], tmp[N];

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> C;
	for (int i = 1; i <= n; i ++) cin >> A[i] >> W[i];
	LL Ans = 0, mx = 0;
	for (int i = 1, j = 0; i <= n; i ++) {
		while (A[j + 1] < A[i]) {
			mx = max(mx, F[++ j]), tmp[W[j]] = max(tmp[W[j]], F[j]);	
		} F[i] = max({F[i], mx - C + A[i], tmp[W[i]] + A[i]}); Ans = max(Ans, F[i]);
	} cout << Ans << "\n";
	return 0;
}
```

---

## 作者：Error_Eric (赞：0)

### Statement

每个积木块有边长和颜色。每个积木的价值是其边长。每一处相邻的积木，若颜色不同，则有 $c$ 的代价。求所有边长**严格单调**的积木序列的最大价值。

### Sol

想要边长严格单调只需要 sort 之后将边长相同的一起转移即可。考虑怎么 dp。

记 $f_i$ 是以 $i$ 结尾的最大价值，则 $f_i = \max_{a_j < a_i}\{f_j - c*[w_i \not = w_j]\} + a_i$。这个是 $O(n^2)$ 的。

如果不用考虑颜色，那就只需要维护所有 $f$ 的价值最大的位置 $h_0$。

但是要考虑颜色，那么就对于每个颜色维护一下颜色 $w$ 的价值最大的位置 $g_w$。以及颜色同 $h_0$ 不同的所有位置中，价值最大的位置 $h_1$ 就行。

那么只有两个位置可能转移给 $f_i$，分别是 $g_{w_i}$ 和 $h_0$ （若 $h_0$ 颜色相同，则是 $g_{w_i}$ 和  $h_1$）。现在单次维护和转移都是 $O(1)$ 的，因此总共的复杂度是 $O(n\log n + n) = O(n\log n)$，瓶颈在排序。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>

using namespace std;
const int _= 5.1e5;
int n, c, a[_], col[_], g[_], h[3];
long long f[_];
#define B g[col[i]] // best option with ending of color of i so far
map<int, vector<int>> i_ata;
signed main(){
    ios::sync_with_stdio(0),
    cin.tie(0), cout.tie(0);
    cin >> n >> c;
    for(int i = 1; i <= n; i++)
        cin >> a[i] >> col[i], i_ata[a[i]].push_back(i);
    for(auto aval_ixs:i_ata){
        auto aval = aval_ixs.first;
        auto  ixs = aval_ixs.second;
        for(int i:ixs)
            f[i] = max(f[B], f[h[h[0] == B]] - c) + aval;
        for(int i:ixs){
            if(f[i] > f[B]) B = i;
            if(f[i] > f[h[0]]){
                if(col[h[0]] != col[i])
                    h[1] = h[0];
                h[0] = i;
            }
            else if(f[i] > f[h[1]] && col[h[0]] != col[i])
                h[1] = i;
        }
        
    }
    cout << *max_element(f+1, f+n+1) << endl;
    return 0;
}
```

---


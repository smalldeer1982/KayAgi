# [CrCPC 2024] 排序

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) D.

## 题目描述

给定 $1\sim n$ 的排列 $p_1,p_2,\ldots,p_n$。

你可以执行任意多次（包括零次）以下操作：

- 将 $p$ **划分**成**可以为空**的四段，依次记为 $a,b,c,d$。将这四段重排成 $c,a,d,b$。

求出至少操作多少次后，排列将变为 $1,2,\ldots,n$。


## 说明/提示

#### 样例解释

- 样例 $1$ 解释：
	- 令 $a=[3,4],b=[7,8,9],c=[1,2],d=[5,6]$。
    - 交换后变为 $[1,2],[3,4],[5,6],[7,8,9]$。
- 样例 $2$ 解释：
	- 令 $a=[1],b=[3],c=[],d=[2]$。
    - 交换后变为 $[],[1],[2],[3]$。
#### 数据范围

- $1\le n\le 10$。

## 样例 #1

### 输入

```
9
3 4 7 8 9 1 2 5 6```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 3 2```

### 输出

```
1```

## 样例 #3

### 输入

```
4
1 3 2 4```

### 输出

```
2```

# 题解

## 作者：xiazha (赞：2)

非常厉害的题目，观察到 $n\le10$，爆搜，但是复杂度是 $O(n!n^3)$ 的，显然超时，想到加剪枝，这里需要挖掘性质：

注意到设一次操作前的数列为 $a$，操作后为 $b$，那么若 $\sum_{i=1}^{n-1} [a_i+1=a_{i+1}]\ge \sum_{i=1}^{n-1} [b_i+1=b_{i+1}]$，那么这次操作是无效的，不继续搜索，这样就能过了，如果你想要更快，那么观察到答案 $\le 6$，可以进一步节省时间。

注：才发现是最优解


```
map<long long,int> mp,pm;
long long val()
{
	long long v=0;
	for(int i=1;i<=n;i++) v+=(a[i]-1)*pw[i];
	return v;
}
void dfs(int step)
{
	long long v=val();
	if(mp[v]<=step&&pm[v]) return;
	if(step>=6||step>=minn) return;
	mp[v]=step;pm[v]=1;
	if(v==ans) minn=min(minn,step);
	int ppp=0,ppp1=0;
	for(int p=1;p<n;p++)
		if(a[p]+1==a[p+1])
			ppp++;
	for(int p=1;p<n;p++)
		if(a[p]>a[p+1])
			ppp1++;
	for(int i=0;i<=n;i++)
		for(int j=i;j<=n;j++)
			for(int k=j;k<=n;k++)
			{
				int cnt=0,b[11];
				memcpy(b,a,sizeof(a));
				for(int p=j+1;p<=k;p++) a[++cnt]=b[p];
				for(int p=1;p<=i;p++) a[++cnt]=b[p];
				for(int p=k+1;p<=n;p++) a[++cnt]=b[p];
				for(int p=i+1;p<=j;p++) a[++cnt]=b[p];
				int pp=0,pp1=0;
				for(int p=1;p<n;p++)
					if(a[p]+1==a[p+1]) pp++;
				for(int p=1;p<n;p++)
					if(a[p]>a[p+1]) pp1++;
				if(ppp>=pp||pp1>ppp1)
				{
					memcpy(a,b,sizeof(b));
					continue;
				}
				dfs(step+1);
				memcpy(a,b,sizeof(b));
			}
}
signed main()
{
	cin>>n;
	pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=pw[i-1]*10,ans+=(i-1)*pw[i];
	for(int i=1;i<=n;i++) cin>>a[i];
	dfs(0);
	if(minn==1e9) cout<<6;
	else cout<<minn;
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

暴力枚举三个分割点跑 DFS 即可，考虑剪枝：定义两个衡量操作价值的数：$v_1=\sum [a_i=a_{i+1}],v_2=\sum[a_i>a_{i+1}]$。显然 $v_1$ 应该尽量大，$v_2$ 应该尽量小。用这两个标准比对修改前后的序列剪枝。

```cpp
const ll N = 20, MAX = 6;
ll n, a[N], ans = MAX, goal;
map<ll, bool> vis;
map<ll, ll> mem;

ll hash1() {
	ll ret = 0;

	rep(i, 1, n) ret = ret * 10 + a[i] - 1;

	return ret;
}

void dfs(ll step) {
//	cout << "dfs:step=" << step << ",status=";
//
//	rep(i, 1, n) cout << a[i] << ' ';
//
//	endl;
//	pause;
	ll tmp = hash1();
//	cout << "tmp=" << tmp << '\n';
//	pause;

	if ((vis[tmp] and mem[tmp] <= step) or step >= ans)
		return;

//	cout << "signal!\n";
	vis[tmp] = 1;
	mem[tmp] = step;

	if (tmp == goal) {
		update(ans, step, min);
		return;
	}

	ll v11 = 0, v12 = 0;

	rep(i, 1, n - 1) {
		if (a[i] + 1 == a[i + 1])
			v11++;
		else if (a[i] > a[i + 1])
			v12++;
	}

	rep(i, 0, n) {
		rep(j, i, n) {
			rep(k, j, n) {
//				cout << "status=";
//
//				rep(i, 1, n) cout << a[i] << ' ';
//
//				endl;
//				pause;
//				cout << i << ' ' << j << ' ' << k << '\n';
//				pause;
				vector<ll> new1;
				new1.clear();

				rep(l, j + 1, k) new1.pb(a[l]);

				rep(l, 1, i) new1.pb(a[l]);

				rep(l, k + 1, n) new1.pb(a[l]);

				rep(l, i + 1, j) new1.pb(a[l]);

//				cout << "size:" << new1.size() << '\n';
//				pause;

//				for (ll l : new1)
//					cout << l << ' ';
//
//				endl;
//				pause;
				ll v21 = 0, v22 = 0;

				rep(l, 0, n - 2) {
					if (new1[l] + 1 == new1[l + 1])
						v21++;
					else if (new1[l] > new1[l + 1])
						v22++;
				}

//				cout << "v11=" << v11 << ",v12=" << v12 << ",v21=" << v21 << ",v22=" << v22 << '\n';
//				pause;

				if (v11 >= v21 or v22 > v12)
					ctn;

//				cout << "signal A\n";
				ll _a[N];
				cpy(_a, a);

				rep(i, 1, n) a[i] = new1[i - 1];

				dfs(step + 1);
				cpy(a, _a);
			}
		}
	}
}

int main() {
	cin >> n;

	rep(i, 1, n) cin >> a[i];

	rep(i, 0, n - 1) goal = goal * 10 + i;

//	cout << "goal=" << goal << '\n';
//	pause;
	dfs(0);

	cout << ans;
}
```

---

## 作者：DengStar (赞：0)

[在博客园中查看](https://www.cnblogs.com/dengstar/p/18780257/solution-CrCPC2024)

数据范围比较小，猜测是搜索。状态空间的大小 $\le 10! = 3628800$，所以完全可以把整个状态空间遍历一遍。

考虑直接 bfs，对于一个排列，用 $O(n^{3})$ 的时间枚举四段的三个分界点，再用 $O(n)$ 的时间拼出新的排列，总时间复杂度 $O(n! \cdot n^{4})$，不可通过。（如果用 `map` 记录是否访问过某状态，还要多一个 $\log n!$，但可以用字符串存排列，然后用 `unordered_map` 代替 `map`。）

如果把排列看作状态空间中的点，转移关系看作边，到这一步我们有两种优化的方向：一种是减少边数，即避免无效转移；另一种是减少点数，即避免访问无效的状态。vp 时我们一直在尝试前者，想办法减少一个状态能转移出的后继状态数量，但这似乎是不可行的。但这题的关键点在于终态是唯一确定的，这启示我们使用**双向 bfs**（这也是官方题解的做法），这本质上减少了访问的状态数。修改后确实可以通过本题。[AC 记录](https://www.luogu.com.cn/record/208783431)

代码见文章开头的链接。

（但是我现在仍然不会严谨地分析这种做法的时间复杂度。std 似乎认为答案不会超过 $6$，因为 std 双向搜索的边界都是 $3$。测试发现，对于答案为 $6$ 的输入，入队的状态数大概为 $70$ 万，远小于上界。）

---


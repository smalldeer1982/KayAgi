# [CrCPC 2024] 信步山中

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) H.

## 题目描述

给定两张 $n$ 个点的**无向连通图** $G_1(V_1,E_1),G_2(V_2,E_2)$。边有边权。

初始时童子军们在起点 $s$，他们要行军到终点 $t$。

他们的行动会遵循以下规则：

令童子军当前在节点 $x$，

- 第 $1,3,5,\cdots$ 次移动，他们会选择一条边 $(x,y,w)\in E_1$，然后移动到 $y$。
	- 令 $\operatorname{dist}_1(x,y)$ 表示 $G_1$ 中 $x,y$ 之间的最短路长度。$\operatorname{dist}_1(x,t)\textcolor{red}{\gt}\operatorname{dist}_1(y,t)$ 必须满足。
- 第 $2,4,6,\cdots$ 次移动，他们会选择一条边 $(x,y,w)\in E_2$，然后移动到 $y$。
	- 令 $\operatorname{dist}_2(x,y)$ 表示 $G_2$ 中 $x,y$ 之间的最短路长度。$\operatorname{dist}_2(x,t)\textcolor{red}{\gt}\operatorname{dist}_2(y,t)$ 必须满足。

你需要求出，在满足上述条件的情况下，从起点到终点经过边的边权和的**最大值**。

特别地，最大值可以为无穷大，即他们可以永远走不到终点。在符合条件的情况下，可以一直拖着不走到终点。


## 说明/提示

- $2\le n\le 10^3$；
- $n-1\le m_1,m_2\le 10^5$；
- $1\le u,v\le n$，$1\le w\le 10^6$；
- $1\le s,t\le n$。



## 样例 #1

### 输入

```
5 1 5
5
1 2 2
1 4 2
2 3 1
3 4 1
5 3 1
4
1 2 2
2 4 2
2 3 1
2 5 2```

### 输出

```
-1```

## 样例 #2

### 输入

```
3 1 3
4
1 2 10
2 3 10
1 3 20
2 3 30
4
2 1 10
1 3 10
1 1 10
2 3 10```

### 输出

```
20```

# 题解

## 作者：Rnfcr (赞：1)

因为每走一条边要换一张图，考虑使用分层图来解决这个问题。将 $G_1$ 中的每条边 $(u_i,v_i)$ 转化为 $(u_i,v_i+n)$ 的一条边，$G_2$ 中的 $(u_i,v_i)$ 转化为 $(u_i+n,v_i)$ 来解决移动次数奇偶性的问题，之后在 $G_1$ 和 $G_2$ 上分别跑一次 dijkstra，求出哪些点对间是可达的，之后就是求从 $s$ 点到 $t$ 点或 $t+n$ 点的最长路了。无解有从 $s$ 点可以到达一个环和 $s$ 点与 $t$ 或 $t+n$ 点不连通两种情况，用 SPFA 算法求最长路即可。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,s,t,m1,m2;
struct edge{
	int v,w;
};
vector<edge> ve[2009],G1[2009],G2[2009];
int dis[2009],cnt[2009],vis[2009],f[2009],ff[2009];
deque<int> q;
bool check(int u,int v){
	if(u<=n){//G1->G1
		if(f[u]>f[v-n]) return 1;
		return 0;
	}
	else{//G2->G2
		if(f[u]>f[v+n]) return 1;
		return 0;
	}
}
bool SPFA(int st){
	for(int i=1;i<=2*n;i++) dis[i]=1e18;
	dis[st]=0;
	vis[st]=1;
	q.push_back(st);
	while(!q.empty()){
		int u=q.front();
		vis[u]=0;
		q.pop_front();
		for(int i=0;i<ve[u].size();i++){
			edge now=ve[u][i];
			int v=now.v,w=now.w;
			if(!check(u,v)) continue;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				cnt[v]=cnt[u]+1;
				if(cnt[v]>=2*n) return 1;
				if(!vis[v]){
					vis[v]=1;
					if(!q.empty()&&dis[v]>dis[q.front()]) q.push_back(v);
					else q.push_front(v);
				}
			}
		}
	}
	return 0;
}
struct data{
    int v,w;
};
priority_queue<data> q2;
bool operator < (data a,data b){
    return a.w>b.w;
}
void dij(int st){
	for(int i=1;i<=n;i++) f[i]=1e18;
	f[st]=0;
	q2.push(data {st,0});
    while(!q2.empty()){
        int v=q2.top().v;
        int w=q2.top().w;
        if(v>n) continue;
        q2.pop();
        if(vis[v]) continue;
        vis[v]=1;
        f[v]=w;
        for(int i=0;i<G1[v].size();i++){
            if(!vis[G1[v][i].v]&&w+G1[v][i].w<f[G1[v][i].v]){
            	f[G1[v][i].v]=w+G1[v][i].w;
            	q2.push(data {G1[v][i].v,w+G1[v][i].w});
			}
        }
    }
}
void dij1(int st){
	for(int i=n+1;i<=n+n;i++) f[i]=1e18;
	f[st]=0;
	q2.push(data {st,0});
    while(!q2.empty()){
        int v=q2.top().v;
        int w=q2.top().w;
        if(v<=n) continue;
        q2.pop();
        if(vis[v]) continue;
        vis[v]=1;
        f[v]=w;
        for(int i=0;i<G2[v].size();i++){
            if(!vis[G2[v][i].v]&&w+G2[v][i].w<f[G2[v][i].v]){
            	f[G2[v][i].v]=w+G2[v][i].w;
            	q2.push(data {G2[v][i].v,w+G2[v][i].w});
			}
        }
    }
}
signed main(){
    ios::sync_with_stdio(NULL),cin.tie(0),cout.tie(0);
   	cin>>n>>s>>t;
   	cin>>m1;
   	for(int i=1;i<=m1;i++){
   		int u,v,w;
   		cin>>u>>v>>w;
   		w*=-1;
   		ve[u].push_back(edge{v+n,w});
    	ve[v].push_back(edge{u+n,w});
    	G1[u].push_back(edge{v,-w});
    	G1[v].push_back(edge{u,-w});
	}
	cin>>m2;
   	for(int i=1;i<=m2;i++){
   		int u,v,w;
   		cin>>u>>v>>w;
   		w*=-1;
   		ve[u+n].push_back(edge{v,w});
    	ve[v+n].push_back(edge{u,w});
    	G2[u+n].push_back(edge{v+n,-w});
    	G2[v+n].push_back(edge{u+n,-w});
	}
	dij(t);
	dij1(t+n);
	memset(vis,0,sizeof(vis));
	if(SPFA(s)){
		cout<<-1;
		return 0;
	}
	else{
		cout<<min(dis[t],dis[n+t])*-1;
	}
    return 0;
}

---

## 作者：DengStar (赞：0)

[在博客园中查看](https://www.cnblogs.com/dengstar/p/-/solution-CrCPC2024)

> 图论建模，最短路

同时考虑两个图是不方便的，不妨合成到一个图考虑。注意到每次移动能到达的点和移动次数的奇偶性有关，所以把每个点拆成两个，分别代表第奇数次移动和第偶数次移动。下面用 $(u, 1 / 0)$ 表示在点 $u$，且下一次移动是第奇数/偶数次。

先用 Dijkstra 求出两个图中所有节点到 $t$ 的距离，然后就可以按题目要求建出新图 $G$，它有 $2n$ 个点和不超过 $m_1 + m_2$ 条边。那么我们要求的就是 $(s, 1)$ 到 $(t, 0)$ **或** $(t, 1)$ 的最长路。有两种情况使得答案为无穷大：

1. $(s, 1)$ 与 $(t, 0)$ 和 $(t, 1)$ 都不连通。

2. 从 $(s, 1)$ 出发可以到达一个**不经过** $(t, 0)$ 和 $(t, 1)$ 的正环。（根据题目描述，到达 $(t, 0)$ 或 $(t, 1)$ 之后就不能再移动了。）

第一种情况容易判断。对于第二种情况，我们可以**直接删除 $G$ 中 $(t, 0)$ 和 $(t, 1)$ 的所有出边**，然后再判断是否存在正环，这样就不用考虑环经过了 $(t, 0)$ 和 $(t, 1)$ 的情况。由于边权都为正，所以只需判断是否存在 $(s, 0)$ 能到达的环，可以用 SPFA 或者拓扑排序解决。前者的时间复杂度为 $O(nm)$，但本题似乎没有特意去卡（其实我也不知道能不能卡，因为 $G$ 是自己建的图），因此可以通过；后者的时间复杂度为 $O(n + m)$。

如果用 SPFA，可以在判断这些特殊情况的同时求出最长路，总时间复杂度为 $O(nm)$。

如果用拓扑排序，先 dfs 一遍判断起点是否能到达终点，顺便计算起点可到达的点的入度，然后再拓扑排序。注意，我们只关心起点能到达的点导出的子图，计算入度时不要把起点不可达的点算进来。总时间复杂度 $O(n + m \log m)$。

AC 记录：[SPFA](https://www.luogu.com.cn/record/208843150) | [拓扑排序](https://www.luogu.com.cn/record/208863411)

代码见文章开头的链接。

---


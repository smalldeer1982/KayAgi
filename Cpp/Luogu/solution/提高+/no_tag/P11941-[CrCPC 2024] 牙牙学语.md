# [CrCPC 2024] 牙牙学语

## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) K.

## 题目描述

给定 $26$ 个只含小写英文字母的字符串 $s_a,s_b,\ldots,s_{z}$。

对于任意一个只含小写英文字母的字符串 $t$，我们把 $t$ 中的每个字母 $x$ 替换成字符串 $s_x$，得到新的字符串 $t'$。

> 例子：当 $s_a=\texttt{ana}$，$s_b=\texttt{ban}$ 时，
> 
> $t=\texttt{\textcolor{green}{b}a\textcolor{green}{b}a}\implies t'=\texttt{\textcolor{green}{ban}ana\textcolor{green}{ban}ana}$。

如果**存在**两个不同的字符串 $p,q$，它们在替换后得到的字符串 $p',q'$ 相同，亦即 $p\neq q$ 且 $p'=q'$，那么我们就说这个替换规则是坏的，否则我们说这个替换规则是好的。

试判断给定的替换规则是不是好的。


## 说明/提示

#### 样例解释

样例 $2$ 解释：$\texttt{a}$ 和 $\texttt{et}$ 是一个符合条件的例子。

#### 数据范围

- $1\le t\le 10^4$；
- 输入的字符串长度和不超过 $10^6$。


## 样例 #1

### 输入

```
1
brainrot
time
gospodin
malnar
je
w
rizzler
i
veliki
sigma
te
ima
ogroman
gyatt
a
skibidi
toilet
nije
jer
zivi
u
ohiou
pa
placa
fanum
tax```

### 输出

```
Krasan```

## 样例 #2

### 输入

```
1
dotdash
dashdotdotdot
dashdotdashdot
dashdotdot
dot
dotdotdashdot
dashdashdot
dotdotdotdot
dotdot
dotdashdashdash
dashdotdash
dotdashdotdot
dashdash
dashdot
dashdashdash
dotdashdashdot
dashdashdotdash
dotdashdot
dotdotdot
dash
dotdotdash
dotdotdotdash
dotdashdash
dashdotdotdash
dashdotdashdash
dashdashdotdot```

### 输出

```
Ruzan```

# 题解

## 作者：114514lhc (赞：0)

普通哈希，直接哈希套搜索（广搜）即可。   
题意可简化为使用这些字符串用两种不同拼法拼成相同的字符串。   
搜索时，我们可以选取拼出的较短序列，比较哈希值，枚举可行字符串入队，这样，只需在队列里存储较长序列中末尾字符串的编号，以及未被匹配的节点。   
代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,x[11451410],x1=233,p1=998244353,l[30],v[11451410],k[30];
string s[30];
vector<int>a[114514];
struct N{int a,b;};
queue<N>p;
int bfs()
{
    while(p.size())
    {
        N t=p.front();p.pop();
        if(t.b==l[t.a])return 1;
        if(v[k[t.a-1]+t.b])continue;//搜过
        v[k[t.a-1]+t.b]=1;
        for(int i=1;i<=26;i++)
        {
            if(i==t.a&&!t.b)continue;
            if(l[i]+t.b<=l[t.a])//若短序列拼接后的新序列比原来长序列短
            {
                int u=a[i][l[i]]*x[t.b]%p1;//原长序列哈希值
                int v=(a[t.a][l[i]+t.b]-a[t.a][t.b]+p1)%p1;//新序列哈希值
                if(u==v)p.push({t.a,t.b+l[i]});
            }
            else
            {
                int u=a[i][l[t.a]-t.b]*x[t.b]%p1;
                int v=(a[t.a][l[t.a]]-a[t.a][t.b]+p1)%p1;
                if(u==v)p.push({i,l[t.a]-t.b});
            }
        }
    }
    return 0;
}
signed main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    x[0]=1;
    for(int i=1;i<=1145141;i++)x[i]=x[i-1]*x1%p1;
    cin>>t;
    while(t)
    {
        t--;
        for(int i=1;i<=26;i++)cin>>s[i],s[i]=' '+s[i];
        for(int i=1;i<=26;i++)
        {
            l[i]=s[i].size()-1;
            k[i]=k[i-1]+l[i];a[i].push_back(0);
            for(int j=1;j<=l[i];j++)
            {
                int u=s[i][j]-'a'+1;
                int o=u*x[j];
                if(j)o+=a[i][j-1];o%=p1;
                a[i].push_back(o);
            }
        }
        for(int i=1;i<=26;i++)p.push({i,0});
        int q=bfs();
        if(q)cout<<"Ruzan"<<endl;
        else cout<<"Krasan"<<endl;
        for(int i=1;i<=26;i++)a[i].clear();
        for(int i=0;i<=k[26];i++)v[i]=0;
        while(p.size())p.pop();
    }
 	return 0;
}

```

---

## 作者：Ag2WO4 (赞：0)

PyPy 可以直接模拟通过本题。

只接取初始不同串为前缀关系，迭代前缀 bfs 直至匹配即可。集合查重优化。
```python
for _ in range(int(input())):
    a=[input()for i in range(26)];b=set();d=set();g=0
    for i in range(26):
        for j in range(i):
            f=1
            if len(a[i])>len(a[j]):
                for k in range(len(a[j])):
                    if a[i][k]!=a[j][k]:f=0;break
                if f:b.add(a[i][len(a[j]):]);d.add(a[i][len(a[j]):])
            else:
                for k in range(len(a[i])):
                    if a[i][k]!=a[j][k]:f=0;break
                if f:b.add(a[j][len(a[i]):]);d.add(a[i][len(a[j]):])
    while b:
        c=set()
        for i in b:
            for j in range(26):
                if i==a[j]:g=1;c=set();break
                f=1
                if len(i)>len(a[j]):
                    for k in range(len(a[j])):
                        if i[k]!=a[j][k]:f=0;break
                    if f and i[len(a[j]):]not in d:c.add(i[len(a[j]):]);d.add(i[len(a[j]):])
                else:
                    for k in range(len(i)):
                        if i[k]!=a[j][k]:f=0;break
                    if f and a[j][len(i):]not in d:c.add(a[j][len(i):]);d.add(a[j][len(i):])
            if g:break
        b,c=c,set()
    print(['Krasan','Ruzan'][g])
```

---


# [JOI2025 预选赛 R2] 亲密的厨师

## 题目描述

在某家玻利维亚餐厅，有 $N$ 位厨师，编号从 $1$ 到 $N$。厨师 $i$ ($1 \le i \le N$) 可以制作美味度为 $A_i$ 的锡尔潘乔 (silpancho) 和美味度为 $B_i$ 的皮克马乔 (pique macho)。

然而，这些厨师都有很强的个性，因此有 $M$ 对厨师彼此不和。第 $j$ 对 ($1 \le j \le M$) 不和的厨师是厨师 $U_j$ 和厨师 $V_j$。

来到这家餐厅的顾客会按以下方式用餐：

* 选择满足 $1 \le p < q \le N$ 的整数 $p, q$，并委托厨师 $p$ 和厨师 $q$ 这两人制作料理。但是，不能委托不和的两人组制作料理。
* 锡尔潘乔和皮克马乔这两道菜都由厨师 $p$ 和厨师 $q$ 中能够做出更高美味度料理的那位厨师制作。如果对于某道菜，两人都能做出相同美味度的料理，则由其中一人制作。注意，一位厨师可以制作两道菜。
* 顾客的**满意度**是锡尔潘乔的美味度和皮克马乔的美味度之和。

这家餐厅来了 $Q$ 位顾客，编号从 $1$ 到 $Q$。

顾客 $k$ ($1 \le k \le Q$) 会委托在所有可以委托的两人组中，满意度第 $X_k$ 高的两人组制作料理。具体来说，如果满意度为 $S$，则选择使得 $S \times N^2 + p \times N + q$ 的值是第 $X_k$ 高的厨师 $p$ 和厨师 $q$ ($1 \le p < q \le N$) 两人组来制作料理。

给定餐厅厨师和顾客的信息，请编写一个程序来计算顾客 $k$ ($1 \le k \le Q$) 的满意度。

## 说明/提示

### 样例 1 解释

可以委托制作料理的厨师二人组有 4 种，每种组合的顾客满意度如下：

* 选择厨师 1 和厨师 2 时，锡尔潘乔由厨师 2 制作，皮克马乔由厨师 1 制作。因此，锡尔潘乔的美味度为 7，皮克马乔的美味度为 4。所以，顾客的满意度为 $7 + 4 = 11$。
* 选择厨师 1 和厨师 4 时，锡尔潘乔由厨师 4 制作，皮克马乔由厨师 4 制作。因此，锡尔潘乔的美味度为 5，皮克马乔的美味度为 8。所以，顾客的满意度为 $5 + 8 = 13$。
* 选择厨师 2 和厨师 3 时，锡尔潘乔由厨师 2 制作，皮克马乔由厨师 3 制作。因此，锡尔潘乔的美味度为 7，皮克马乔的美味度为 4。所以，顾客的满意度为 $7 + 4 = 11$。
* 选择厨师 3 和厨师 4 时，锡尔潘乔由厨师 4 制作，皮克马乔由厨师 4 制作。因此，锡尔潘乔的美味度为 5，皮克马乔的美味度为 8。所以，顾客的满意度为 $5 + 8 = 13$。

因此，对于每位顾客，可以得到以下信息：

* 顾客 1 选择厨师 3 和厨师 4 的二人组。因此，顾客 1 的满意度为 13。
* 顾客 2 选择厨师 1 和厨师 4 的二人组。因此，顾客 2 的满意度为 13。
* 顾客 3 选择厨师 2 和厨师 3 的二人组。因此，顾客 3 的满意度为 11。
* 顾客 4 选择厨师 1 和厨师 2 的二人组。因此，顾客 4 的满意度为 11。

这个输入样例满足子任务 1, 7, 8 的约束。

### 样例 2 解释
可以委托制作料理的厨师二人组有 3 种，每种组合的顾客满意度如下：

* 选择厨师 1 和厨师 3 时，锡尔潘乔由厨师 3 制作，皮克马乔由厨师 1 或厨师 3 制作。因此，锡尔潘乔的美味度为 5，皮克马乔的美味度为 1。所以，顾客的满意度为 $5 + 1 = 6$。
* 选择厨师 1 和厨师 4 时，锡尔潘乔由厨师 4 制作，皮克马乔由厨师 1 或厨师 4 制作。因此，锡尔潘乔的美味度为 4，皮克马乔的美味度为 1。所以，顾客的满意度为 $4 + 1 = 5$。
* 选择厨师 3 和厨师 4 时，锡尔潘乔由厨师 3 制作，皮克马乔由厨师 3 或厨师 4 制作。因此，锡尔潘乔的美味度为 5，皮克马乔的美味度为 1。所以，顾客的满意度为 $5 + 1 = 6$。

因此，对于顾客 1，可以得到以下信息：

* 顾客 1 选择厨师 3 和厨师 4 的二人组。因此，顾客 1 的满意度为 6。

这个输入样例满足子任务 1, 3, 4, 5, 6, 7, 8 的约束。


### 数据范围

* $2 \le N \le 400\,000$
* $1 \le A_i \le 10^9$ ($1 \le i \le N$)
* $1 \le B_i \le 10^9$ ($1 \le i \le N$)
* $0 \le M \le 400\,000$
* $M < N(N - 1) \div 2$
* $1 \le U_j < V_j \le N$ ($1 \le j \le M$)
* $(U_i, V_i) \neq (U_j, V_j)$ ($1 \le i < j \le M$)
* $1 \le Q \le 400\,000$
* $1 \le X_k \le 400\,000$ ($1 \le k \le Q$)
* $X_k \le N(N - 1) \div 2 - M$ ($1 \le k \le Q$)
* 输入的所有值都是整数。

### 子任务
1.  (4 分) $N \le 50$, $M \le 50$, $Q \le 50$, $X_k \le 50$ ($1 \le k \le Q$).
2.  (9 分) $B_i = 1$ ($1 \le i \le N$), $M = 0$, $Q = 1$.
3.  (10 分) $B_i = 1$ ($1 \le i \le N$), $Q = 1$.
4.  (5 分) $B_i = 1$ ($1 \le i \le N$).
5.  (29 分) $N \le 100\,000$, $M \le 100\,000$, $Q = 1$, $X_1 = 1$.
6.  (14 分) $N \le 100\,000$, $M \le 100\,000$, $Q = 1$, $X_1 \le 100\,000$.
7.  (18 分) $N \le 100\,000$, $M \le 100\,000$, $Q \le 100\,000$, $X_k \le 100\,000$ ($1 \le k \le Q$).
8.  (11 分) 没有额外的限制。


## 样例 #1

### 输入

```
4 2 4
2 7 3 5
4 3 4 8
1 3
2 4
1 2 3 4```

### 输出

```
13
13
11
11```

## 样例 #2

### 输入

```
4 3 1
3 6 5 4
1 1 1 1
1 2
2 3
2 4
1```

### 输出

```
6```

## 样例 #3

### 输入

```
5 0 4
1 2 3 4 5
5 4 3 2 1
3 9 10 1```

### 输出

```
9
7
7
10```

## 样例 #4

### 输入

```
13 12 10
2 28 28 60 48 77 63 92 13 71 36 91 87
85 7 64 15 55 92 66 91 83 35 49 22 61
2 9
8 13
7 11
9 11
8 12
5 12
4 7
11 12
10 12
4 11
1 5
3 8
49 21 46 13 20 41 6 33 24 7```

### 输出

```
121
169
129
174
169
137
183
148
169
183```

# 题解

## 作者：yyyx_ (赞：7)

前情提要：多路归并优先队列（模板 [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)）。

题目简述：给定 $n$ 个二元组 $\{a_i,b_i\}$，选择编号为 $i$ 和 $j$ 的两个二元组（$i<j$），令 $S = \max(a_i,a_j) + \max(b_i,b_j)$，按 $S$ 为第一关键字，$p$ 为第二关键字，$q$ 为第三关键字从大到小排序得到排名前若干项。

$p$ 和 $q$ 的大小顺序很好处理，先考虑 $S$。将二元组按 $b_i$ 从大到小排序后设置 $n$ 个指针 $it_i$ 来表示 $a_i$ 下一个对应的 $b_{it_i}$。这样对于任意一个 $a_i$，$a_i + \max(b_i,b_{it_i})$ 的值是单调不增的。

用 set 存一下对于每个人不能合作的人的编号，指针遍历查找下一个的时候在 set 里查一下有没有 $it_i$ 就行了。注意我们实际钦定了 $a_i$ 的大小关系，所以若 $a_i<a_{it_i}$ 是不能放进优先队列的。若找到合法搭配，将多元组 $\{a_i + \max(b_i,b_{it_i}),\min(i,it_i),\max(i,it_i)\}$ 加入队列即可。

注意上述做法会出现重复，所以任意钦定一下顺序，当加入队列的两人组编号 $i,it_i$ 中 $i>it_i$ 时才加入队列。

时间复杂度 $O(n\log n)$。

同做法好题：[P10768 「CROI·R2」落月摇情](https://www.luogu.com.cn/problem/P10768)。


```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x)
{
    x = 0;
    char c = getchar();
    bool f = false;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = true;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    f ? (x = -x) : 0;
}

template <typename T, typename... Args>
inline void read(T &x, Args &...temps)
{
    read(x), read(temps...);
}

#define de(x) cerr << '[' << #x << ' ' << '=' << ' ' << x << ']' << ' '
#define ed() cerr << endl
const int N = 4e5 + 5;
typedef long long ll;

struct node
{
    int v1, v2, id;
} a[N];
int n, m, q;
set<int> st[N];
int it[N], to[N];
int ans[N];
priority_queue<tuple<int, int, int, int>> Q;

void insert(int id)
{
    int &i = it[id];
    ++i;
    for (; i <= n; i++)
    {
        int j = a[i].id;
        if (st[id].count(j))
            continue;
        j = to[j];
        int k = to[id];
        if (a[k].v1 < a[j].v1)
            continue;
        if (a[k].v1 == a[j].v1 && a[k].id <= a[j].id)
            continue;
        Q.emplace(a[k].v1 + max(a[k].v2, a[j].v2), min(id, a[i].id), max(id, a[i].id), id);
        return;
    }
}

signed main()
{
    read(n, m, q);
    for (int i = 1; i <= n; i++)
        read(a[i].v1), a[i].id = i;
    for (int i = 1; i <= n; i++)
        read(a[i].v2), st[i].emplace(i);
    for (int i = 1, x, y; i <= m; i++)
    {
        read(x, y);
        st[x].emplace(y);
        st[y].emplace(x);
    }
    sort(a + 1, a + n + 1, [](node x, node y)
         { return x.v2 == y.v2 ? x.id > y.id : x.v2 > y.v2; });
    for (int i = 1; i <= n; i++)
        to[a[i].id] = i;
    for (int i = 1; i <= n; i++)
        insert(i);
    vector<int> qy;
    for (int x; q--;)
    {
        read(x);
        qy.emplace_back(x);
    }
    int M = *max_element(begin(qy), end(qy));
    for (int i = 1; i <= M; i++)
    {
        auto [v, id1, id0, id] = Q.top();
        Q.pop();
        ans[i] = v;
        insert(id);
    }
    for (auto x : qy)
        printf("%d\n", ans[x]);

    return 0;
}
```

---

## 作者：suzhikz (赞：5)

来个鬼畜做法，不知道咋过的。

简化下题目意思，找第 $k$ 大的组合，组合就是把两个位置的二元组对应位置取最大值然后加起来。

我们先不考虑两个厨师之间不和。

然后我们发现询问的 $X$ 并不大，考虑预处理出一定范围内的排名。

先考虑如何处理出大于 $x$ 的所有组合。我们把所有厨师按照 $a$ 和 $b$ 分别排序，然后按照 $a$ 的大小先枚举每个厨师，如果这个厨师自己的和已经大于 $x$ 了，那么他可以随便和其他人组合，否则，我们就一个一个枚举，把所有组合大于 $x$ 的取出来。

但是这样子会超时，我们发现固定完第一个厨师之后，我们假设我们取得是这个厨师的 $a$，那么我们只要考虑另一个厨师的 $b$ 要大于 $x-a$ 即可。如果这个厨师的 $b$ 小于 $x-a$，我们显然不会选他。然后用个 map 把重复的判掉即可。

找这个 $x$ 比较难，考虑放宽条件，不用求出来具体的，比他小点没关系。

所以我们先二分一个 $mid$ 出来，然后检查比他大的个数，一种是一个厨师自己的和比 $mid$ 大，一种是两个组合起来，但是这个组合起来我们只考虑第一个厨师的 $a$ 和第二个的 $b$。这样子有可能第二个的 $a$ 比第一个更大或者第一个的 $b$ 比第二个更大，但是我们不管他，所以我们求出来的东西会偏小。

但是不会小非常多，所以我们求出来之后直接做即可。对于矛盾的厨师我们先不管，然后我们多求一些答案，把里面矛盾的剔除即可。


```cpp
//我永远喜欢艾莉丝!
#include<iostream>
#include<algorithm>
#include<cmath>
#include<iomanip>
#include<cstdio>
#include<string>
#include<deque>
#include<stack>
#include<queue>
#include<vector>
#include<stdio.h>
#include<map>
#include<set>
#include<string.h>
#include<random>
#include<time.h>
#include<stdlib.h>
#include<bitset>
#define il inline
#define reg register
#define ll long long
#define popcount __builtin_popcount
using namespace std;
//#define int __int128
inline void read(int &n){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}n=x*f;}
inline void read(ll &n){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}n=x*f;}
const int N=4e5+5;
int n,m,t;
priority_queue<int>q;
struct node{
	int x,y,id;
}z1[N],z2[N];
bool cmp1(node a,node b){
	if(a.x==b.x)return a.y<b.y;
	return a.x>b.x;
}
bool cmp2(node a,node b){
	if(a.y==b.y)return a.x<b.x;
	return a.y<b.y;
}
bool vis[N];
int tree[N];
map<int,bool>g[N];
ll check(int x){
	for(int i=1;i<=n;i++)vis[i]=0;
	ll re=0,j=1;
	for(int i=1;i<=n;i++){
		if(z1[i].x+z1[i].y>=x){
			re+=n;continue;
		}
		while(j<=n&&z1[i].x+z2[j].y<x){
			j++;
		}
		re+=n-j+1;
	}
	return re;
}

int anss[N];
int main(){
//	freopen("my.in","r",stdin);
	read(n);read(m);read(t);
	for(int i=1;i<=n;i++){
		read(z1[i].x);z1[i].id=i;
	}
	for(int i=1;i<=n;i++){
		read(z1[i].y);z2[i]=z1[i]; 
	}sort(z1+1,z1+1+n,cmp1);sort(z2+1,z2+1+n,cmp2);
	for(int u,v,i=1;i<=m;i++){
		read(u);read(v);
		g[u][v]=g[v][u]=1;
	}
	ll l=2,r=2e9,ans=2;
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)>=900000){
			ans=mid;l=mid+1;
		}else{
			r=mid-1;
		}
//		cout<<l<<' '<<r<<endl;
	}
	ans++;
	for(int i=1;i<=n;i++)vis[i]=0;
	int j=1,cnt=0;
	for(int i=1;i<=n;i++){
		while(j<=n&&z1[i].x+z2[j].y<ans){
			j++;
		}
		for(int k=j;k<=n;k++){
			if(g[z1[i].id][z2[k].id]||z1[i].id==z2[k].id)continue;
			q.push(max(z1[i].x,z2[k].x)+max(z1[i].y,z2[k].y));
			g[z1[i].id][z2[k].id]=g[z2[k].id][z1[i].id]=1;
		}
		if(z1[i].x+z1[i].y>=ans){
			for(int k=1;k<j;k++){
				if(g[z1[i].id][z2[k].id]||z1[i].id==z2[k].id)continue;
				q.push(max(z1[i].x,z2[k].x)+max(z1[i].y,z2[k].y));
				g[z1[i].id][z2[k].id]=g[z2[k].id][z1[i].id]=1;
			}
		}
	}
//	cout<<114514;return 0;
	for(int i=1;i<N;i++){
		if(q.empty())break;
//		cout<<q.top()<<endl;
		anss[i]=q.top();q.pop();
	}
	int ask[N];
	for(int i=1;i<=t;i++)read(ask[i]);
	for(int i=1;i<=t;i++){
		printf("%d\n",anss[ask[i]]==0?ans-1:anss[ask[i]]);
	}
	return 0;
}

```

---

## 作者：Sliarae (赞：4)

首先将题意转化一步。设 $X = \max X_i \le 4 \times 10^5$。那么我们只需要先求出前 $X + M$ 大的满意度，然后再删去不合法的那 $M$ 对厨师产生的满意度即可。

将所有厨师按 $A_i$ 从小到大排序，那么如果厨师 $i$ 与 $j$ 组合（$i < j$），顾客的满意度是 $\text{Val}(i, j) = A_j + \max(B_i, B_j)$。

那么我们让厨师 $j$ 在 $[1, j)$ 中寻找厨师 $i$，显然 $j$ 会优先找 $B_i$ 较大的。

将所有 $(i, j)$ 放到一个堆中维护，每次取出 $\text{Val}(i, j)$ 最大的，然后再找 $B_{i'} < B_i$ 的 $i'$ 中 $B_{i'}$ 最大的那个，这个相当于在序列上的一段前缀中找前驱，可以用可持久化线段树。最后将 $(i', j)$ 加入堆中。

时空复杂度都是一个 $\log$。

```cpp
#include <iostream>
#include <algorithm>
#include <numeric>
#include <vector>
#include <queue>
#include <set>

using namespace std;
using Pii = pair<int, int>; 

const int kN = 4e5 + 5; 
const int V = 1e9;
const Pii Empty = {-1, -1};

int n, m, q, rd;
int a[kN], b[kN];
int eu[kN], ev[kN];

void Renumber () {
  static int p[kN], to[kN];
  iota(p + 1, p + n + 1, 1);
  sort(p + 1, p + n + 1, [&](int i, int j) -> bool {
    return a[i] < a[j];
  }); 
  for (int i = 1; i <= n; ++i) to[p[i]] = i; 
  static int na[kN], nb[kN];
  for (int i = 1; i <= n; ++i) na[to[i]] = a[i], nb[to[i]] = b[i];
  for (int i = 1; i <= n; ++i) a[i] = na[i], b[i] = nb[i];
  for (int i = 1; i <= m; ++i) {
    eu[i] = to[eu[i]], ev[i] = to[ev[i]];
  }
}

const int kT = kN * 80;

struct Seg {
  int tot;
  int lc[kT], rc[kT], cnt[kT];

  void Insert (int &k, int t, int x, int L = 1, int R = V) {
    k = ++tot;
    cnt[k] = cnt[t] + 1;
    if (L == R) return; 
    int mid = (L + R) >> 1;
    if (x <= mid) rc[k] = rc[t], Insert(lc[k], lc[t], x, L, mid);
    else lc[k] = lc[t], Insert(rc[k], rc[t], x, mid + 1, R);
  }

  Pii Subtree_end (int k, int L = 1, int R = V) {
    if (L == R) return {L, cnt[k]};
    int mid = (L + R) >> 1;
    if (rc[k] && cnt[rc[k]]) return Subtree_end(rc[k], mid + 1, R);
    else return Subtree_end(lc[k], L, mid); 
  } 

  Pii Find_pre (int k, int x, int L = 1, int R = V) {
    if (!k || L == R) return Empty;
    int mid = (L + R) >> 1;
    if (x <= mid) return Find_pre(lc[k], x, L, mid);
    Pii ret = Find_pre(rc[k], x, mid + 1, R);
    if (ret != Empty) return ret;
    if (lc[k] && cnt[lc[k]]) return Subtree_end(lc[k], L, mid);
    return Empty;
  } 
} seg; 

int rt[kN];

struct Node {
  int i, a, b;
  Pii p;

  Node () {} 
  Node (int i, int a, int b, Pii p) : i(i), a(a), b(b), p(p) {}

  int Val () const {
    return a + max(b, p.first);
  }

  bool operator< (const Node &n) const {
    return Val() < n.Val();
  }
}; 

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m >> q; 
  for (int i = 1; i <= n; ++i) cin >> a[i];
  for (int i = 1; i <= n; ++i) cin >> b[i];
  for (int i = 1; i <= m; ++i) cin >> eu[i] >> ev[i];
  Renumber();
  // for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
  // cout << '\n';
  // for (int i = 1; i <= n; ++i) cout << b[i] << ' '; 
  // cout << '\n';
  // for (int i = 1; i <= m; ++i) cout << "Edge " << eu[i] << ' ' << ev[i] << '\n';
  vector<int> qry;
  for (int i = 0, x; i < q; ++i) {
    cin >> x;
    qry.push_back(x);
    rd = max(rd, x);  
  }
  vector<int> banned;
  for (int i = 1; i <= m; ++i) {
    int u = eu[i], v = ev[i];
    banned.push_back(max(a[u], a[v]) + max(b[u], b[v]));
  }
  rd += banned.size();
  for (int i = 1; i <= n; ++i) seg.Insert(rt[i], rt[i - 1], b[i]);
  priority_queue<Node> q; 
  for (int i = 1; i <= n; ++i) {
    Pii p = seg.Subtree_end(rt[i - 1]);
    if (p == Empty) continue;
    q.push(Node(i, a[i], b[i], p));
  }
  multiset<int, greater<int>> st;
  int cur = rd;
  while (true) {
    Node node = q.top();
    q.pop();
    int ned = min(cur, node.p.second);
    for (int i = 1; i <= ned; ++i) st.insert(node.Val());
    cur -= ned;
    if (!cur) break;
    Pii p = seg.Find_pre(rt[node.i - 1], node.p.first);
    // cout << node.i << ' ' << node.a << ' ' << node.b << ' ' << node.p.first << ' ' << node.p.second << ' ' << node.Val() << p.first << ' ' << p.second << '\n';
    if (p == Empty) continue;
    node.p = p; 
    q.push(node);
  }
  // for (auto i : st) cout << i << ' ';
  // cout << '\n';
  for (auto i : banned) {
    auto it = st.find(i);
    if (it != st.end()) st.erase(it);
  }
  static int ans[kN];
  rd -= banned.size();
  for (int i = 1; i <= rd; ++i) {
    ans[i] = *st.begin();
    st.erase(st.begin());
  }
  for (auto i : qry) cout << ans[i] << '\n'; 
  return 0; 
}
```

---

## 作者：banned_gutongxing (赞：1)

我来一篇不怎么正经的做法（空间使用大），但是能过的算法。

首先前面的思路跟其他题解一样，看见求第 $k$ 大，且 $k$ 较小，使用多路归并。

从这里开始就有一点不一样了。

考虑到有 $A_i$ 和 $B_i$ 两种贡献，所以我们首先按照 $A_i$ 排序，用来消掉一个最大值。

考虑当 $i$ 固定时，其他的 $B_i$ 的贡献。当 $B_j<B_i$ 时，我们需要将他们调整为 $B_i$，否则就不变。然后还要求这个 $B$ 序列的第 $k$ 大，这个结构非常适合线段树。于是考虑使用**权值**线段树。

想一想每一个操作：
- 区间调整为 $B_i$，这个直接记录区间个数和 $tot$，然后再打上覆盖标记就行。
- 求第 $k$ 大，这个很简单吧。不会请左转 [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369) 。
- 然后最关键的是每一次要插入一个 $B_i$，但是由于覆盖标记的不同，我们可以选择使用**主席树**。

综上，套上一个多路归并就做完了。

如果是本做法的话，一定要卡好你的空间。其中的覆盖标记可以用 bitset 将空间变为原来的 $\frac18$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
//#define int long long
namespace gtx{
//	Fast IO
    void read(int &x){
        x = 0;int h = 1;char tmp;
        do{tmp=getchar();if(tmp=='-')h*=-1;}while(!isdigit(tmp));
        while(isdigit(tmp)) x*=10,x+=tmp-'0',tmp=getchar();
        x*=h;
    }
    void read(char &x){do{x=getchar();}while(x==' '||x=='\n'||x=='\r');}
    void write(char x){putchar(x);}
    void write(int x){
        if(x<0) putchar('-'),x=-x;int st[200]={0},tot=0;
        do st[++tot]=x%10,x/=10; while(x);
        while(tot){putchar(st[tot--]+'0');}
    }
    void write(int x,char y){write(x);write(y);}
#ifndef int
    void read(long long &x){
        x = 0;int h = 1;char tmp;
        do{tmp=getchar();if(tmp=='-')h*=-1;}while(!isdigit(tmp));
        while(isdigit(tmp)) x*=10,x+=tmp-'0',tmp=getchar();
        x*=h;
    }
    void write(long long x){
        if(x<0) putchar('-'),x=-x;int st[200]={0},tot=0;
        do st[++tot]=x%10,x/=10; while(x);
        while(tot){putchar(st[tot--]+'0');}
    }
    void write(long long x,char y){write(x);write(y);}
#endif
    const int MAXN = 4e5+10;
    struct segmentree{
        int lson,rson;
        int tot;
    }tree[60000100];
    bitset<60000100> cleartag,made;
    int segmentsum;
    void makeson(int k,int L,int R){
        int mid = (L+R)>>1;
        if(tree[k].lson){
        	
            tree[++segmentsum] = tree[tree[k].lson];
            made[segmentsum] = false;
        }else ++segmentsum;
        tree[k].lson = segmentsum;
        if(tree[k].rson){
        	
            tree[++segmentsum] = tree[tree[k].rson];
            made[segmentsum] = false;
        }else ++segmentsum;
        tree[k].rson = segmentsum;
        made[k] = true;
    }
    void maketag(int k){
        cleartag[k] = 1;
        tree[k].tot = 0;
    }
    void pushdown(int k,int L,int R){
        if(!made[k]) makeson(k,L,R);
        if(cleartag[k]) maketag(tree[k].lson),maketag(tree[k].rson);
        cleartag[k] = false;
    }
    void pushup(int k){
        tree[k].tot = tree[tree[k].lson].tot+tree[tree[k].rson].tot;
    }
    void modify(int k,int l,int r,int L,int R){
        if(L>r||R<l) return;
        if(L>=l&&R<=r) return maketag(k),void();
        pushdown(k,L,R);
        int MID = (L+R)>>1;
        modify(tree[k].lson,l,r,L,MID);
        modify(tree[k].rson,l,r,MID+1,R);
        pushup(k);
    }
    void add(int k,int x,int y,bool p,int L,int R){
        if(L>x||R<x) return;
        if(L==x&&R==x){
            tree[k].tot += y;
            return;
        }
        if(p&&made[k]) makeson(k,L,R); 
        pushdown(k,L,R);
        int MID = (L+R)>>1;
        add(tree[k].lson,x,y,p,L,MID);
        add(tree[k].rson,x,y,p,MID+1,R);
        pushup(k);
    }
    int ask_tot(int k,int l,int r,int L,int R){
        if(L>r||R<l) return 0;
        if(L>=l&&R<=r) return tree[k].tot;
        pushdown(k,L,R);
        int MID = (L+R)>>1;
        return ask_tot(tree[k].lson,l,r,L,MID)+ask_tot(tree[k].rson,l,r,MID+1,R);
    }
    int ask(int k,int kth,int L,int R){
        if(L==R) return L;
        pushdown(k,L,R);
        int MID = (L+R)>>1;
        if(tree[tree[k].rson].tot>=kth) return ask(tree[k].rson,kth,MID+1,R);
        return ask(tree[k].lson,kth-tree[tree[k].rson].tot,L,MID);
    }
    int n,m,q;
    pair<pair<int,int>,int> a[MAXN];
    vector<int> v[MAXN];
    int root[MAXN];
    struct nothing{
        int a;
        int b;
        int kth;
    };
    bool operator < (const nothing A,const nothing B){
        return !(a[A.a].first.first+A.b>a[B.a].first.first+B.b);
    }
    priority_queue<nothing> pq;
    struct question{
        int K,id,ans;
    };
    vector<question> ques;
    int newpos[MAXN];
    vector<int> lsh;
    int get(int x){
        return lower_bound(lsh.begin(),lsh.end(),x)-lsh.begin()+1;
    }
    signed main(){
    	read(n);read(m);read(q);
        root[0] = ++segmentsum;
        for(int i = 1;i<=n;i++) read(a[i].first.first);
        for(int i = 1;i<=n;i++) read(a[i].first.second),a[i].second=i,lsh.push_back(a[i].first.second);
        sort(lsh.begin(),lsh.end());
        
        lsh = vector<int>(lsh.begin(),unique(lsh.begin(),lsh.end()));
        for(int i = 1;i<=m;i++){
            int g,h;
            read(g);read(h);
            v[g].push_back(h);
            v[h].push_back(g);
        }
        sort(a+1,a+1+n);
        for(int i = 1;i<=n;i++){
            newpos[a[i].second] = i;
            root[i] = ++segmentsum;
            tree[root[i]] = tree[root[0]];
            made[root[i]] = false;
            int sum = ask_tot(root[i],1,get(a[i].first.second),1,(int)lsh.size());
            if(sum) modify(root[i],1,get(a[i].first.second),1,(int)lsh.size());
            if(sum) add(root[i],get(a[i].first.second),sum,0,1,(int)lsh.size());
            for(int j:v[a[i].second]){
                if(newpos[j]){
                    add(root[i],get(max(a[newpos[j]].first.second,a[i].first.second)),-1,0,1,(int)lsh.size());
                }
            }
            if(tree[root[i]].tot){
                pq.push({i,lsh[ask(root[i],1,1,(int)lsh.size())-1],1});
            }
            add(root[0],get(a[i].first.second),1,1,1,(int)lsh.size());
        }
        for(int i = 1;i<=q;i++){
            int x;
            read(x);
            ques.push_back({x,i});
        }
        sort(ques.begin(),ques.end(),[](question a,question b){
            return a.K<b.K;
        });
        int nowk = 1;
        for(auto &i:ques){
            while(nowk<i.K){
                auto O = pq.top();pq.pop();
                if(O.a==3){
                	int u = 0;
				}
                if(O.kth<tree[root[O.a]].tot) pq.push({O.a,lsh[ask(root[O.a],O.kth+1,1,(int)lsh.size())-1],O.kth+1});
                nowk++;
            }
            i.ans = a[pq.top().a].first.first+pq.top().b;  
        }
//        cerr << "end"; 
        sort(ques.begin(),ques.end(),[](question a,question b){
            return a.id<b.id;
        });
        for(auto i:ques){
            write(i.ans,endl);
        }
//        cout << segmentsum << endl;
        return 0;
    }
}
signed main(){
//	freopen("chef.in","r",stdin);
//	freopen("chef.out","w",stdout);
//	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int T = 1;
//	gtx::read(T);
    while(T--) gtx::main();
//	while(1);
    return 0;
}
```

---


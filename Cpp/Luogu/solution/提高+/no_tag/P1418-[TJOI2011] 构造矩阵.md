# [TJOI2011] 构造矩阵

## 题目描述

要求构造一个 $n\times m$ 的 $01$ 矩阵，满足每一行中 $1$ 的个数分别为 $r_1,r_2,\ldots,r_n$ ,每一列中1的个数为 $c_1,c_2,\ldots,c_m$。

在此基础上要求字典序最小。两个矩阵比较字典序时先比较第一行，第一行相等再比较第二行……

## 说明/提示

对于 $100\%$ 的数据 $n,m\le 100$。

## 样例 #1

### 输入

```
2 3
2 1 
1 0 2 
```

### 输出

```
101
001
```

# 题解

## 作者：Drind (赞：7)

题目给定一个 $01$ 矩阵每行和每列的 $1$ 的个数,求字典序最小的满足条件的矩阵.

如果只需要给出一个构造那么这题非常简单,只需要建立一个二分图,左边有 $n
$ 个点，右边有 $m$ 个点，左部的第 $i$ 个点和源点连边,权值为 $r_i$ ,右部的第 $j$ 个点和汇点连边,权值为 $c_j$,每个左部点 $i$ 和右部点 $j$ 连边,权值为$1$.跑完最大流之后只需要把每条经过增广的边 $(i,j)$ 都输出 $1$,其他的输出 $0$ 就完成了构造.

显然这样的构造不满足字典序最小,于是我们想,对于每个边,肯定是更靠前的边更重要,那是否可以给每个边一个费用跑费用流呢?事实上也是不行的,如果要让边之间互相不影响的话,费用最大的边必须达到 $2^{nm}$,显然是会爆 long long 的,这种方法不可行.

那么,既然每条经过增广的边都代表这个点是 $1$ 的话,我们是否可以把这条边删掉再跑一遍最大流,判断这条边是否必须呢?

如果用这种思路做的话,首先我们先贪心地从大到小枚举每个点,先跑一遍最大流,然后看看这个点对应的边是否被增广,如果没有被增广说明这个点不必要,输出 $0$;如果这个点对应的边被增广,那么就删掉这条边,再跑一遍最大流,如果这次最大流还能找到一条增广路替代这条边的话,就说明这个点不必要,输出 $0$;如果第二次最大流找不到增广路了,说明这个点必要，输出 $1$.

不用考虑如果前面的点取 $0$ 后是否会对后面的点产生影响,因为只要求字典序最小,前面的尽可能小,后面的再大也无所谓.

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;

struct node
{
	int to,nxt;
	int flow;
}edge[500001];//链式前向星

int cnt=1,s,t,n,m;
int head[1021];
int cur[1021];
int dep[1021];
int r[10001];
int c[10001];
int id[201][201];//id数组代表点对应的边，其中第一维的n+1代表连向汇点的边，第二位的m+1代表连向源点的边

void add(int u,int v,int w)
{
	edge[++cnt]={v,head[u],w};
	head[u]=cnt;
	edge[++cnt]={u,head[v],0};
	head[v]=cnt;
}//一次加正向和反向边
//以下为dinic板子
bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];~i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if(!dep[v]&&edge[i].flow>0)
			{
				dep[v]=dep[u]+1;
				q.push(v);
				if(v==t)
					return true;
			}
		}
	} 
	return false;
}

int dfs(int u,int f)
{
	if(u==t)
		return f;
	int r=f;
	for(int i=head[u];~i&&r;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(dep[v]==dep[u]+1&&edge[i].flow>0)
		{
			int temp=dfs(v,min(r,edge[i].flow));
			if(!temp)
				dep[v]=0;
			edge[i].flow-=temp;
			edge[i^1].flow+=temp;
			r-=temp;
		}
	}
	return f-r;
}

int dinic()
{
	int mxflo=0;
	while(bfs())
	{
		mxflo+=dfs(s,1e9);
	}
	return mxflo;
}//以上为dinic板子

int check(int x,int y)//check函数代表第(x,y)个点是否必须
{
	dinic();
	if(!r[x]||!c[y]) return 0;//如果没有0可以放了，则输出1
	r[x]--,c[y]--;//假设放置0，行列0的数量都减一
	if(edge[id[x][y]].flow)//如果这个点未被增广，则不必要，输出0
	{
		edge[id[x][y]].flow=0;//删除这个点对应的边，以防今后再次使用
		return 1;
	}
	else
	{
		edge[id[x][y]^1].flow=0;//删除这条边，再次跑最大流，看看这条边是否必要
        edge[id[x][y]].flow=0;
		edge[id[x][m+1]^1].flow--;
		edge[id[x][m+1]].flow++;
		edge[id[n+1][y]^1].flow--;
		edge[id[n+1][y]].flow++;
		if(dinic()==1)//如果找到新的增广路替代则这个点不必要
			return 1;
		r[x]++;
		c[y]++;
		edge[id[n+1][y]].flow--;
		edge[id[n+1][y]^1].flow++;
		edge[id[x][m+1]].flow--;
		edge[id[x][m+1]^1].flow++;//这个点必要，恢复原状
		return 0;
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	cin>>n>>m;
	s=n+m+1;
	t=s+1;
	for(int i=1;i<=n;i++) cin>>r[i];
	for(int i=1;i<=m;i++) cin>>c[i]; 
	for(int i=1;i<=n;i++)
	{
		id[i][m+1]=cnt+1;
		add(s,i,r[i]);
		for(int j=1;j<=m;j++)
		{
			if(i==1)
			{
				id[n+1][j]=cnt+1;
				add(j+n,t,c[j]);
			}
			id[i][j]=cnt+1;
			add(i,j+n,1);
		}
	}//建图，初始化id数组
	for(int i=1;i<=n;i++) r[i]=m-r[i];//注意这里r和c数组已经被替换成0的数量
	for(int i=1;i<=m;i++) c[i]=n-c[i];
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			cout<<1-check(i,j);//对于每个点判断
		cout<<endl;
	}
}
```


---

## 作者：dengyixuan (赞：7)

* 这道题非常的神（主要是网上找不到题解）
*	开始我看到这道题丢了个费用流上去，给每行每列一个权值，这样就尽量往后流，获得了二十分的好成绩，因为权值差距不够大。
*	首先，这道题你从后贪心能放1就放1肯定是不的，你后面放很多个1，如果最后几个1被迫放在最前面那肯定不是字典序最小
*	反过来考虑，每一行每一列需要多少个0，这样显然可以贪心，这样肯定字典序最小，然后打了个暴力，获得50分
*	为什么只有50分呢？因为贪心放0之后，后面不一定可以满足要求，你就要回溯，所以TLE。
*	考虑优化贪心，不回溯，对于每一位，你都判一下放0的话后面是否有解，用网络流判是否可以完美匹配就行了。
*	但这样时间复杂是错的，所以不必每次都重新建图，现在原来的图中看一下该行列是否已经匹配，若没有，则强制该行列匹配，重新建图，看是否完美匹配即可
*	时间复杂度好像是错的？首先，随着你点放的点越来越多，你的图会越来越小，跑的越来越快。其次，有很多行列在原来的途中就已经匹配，不必每次都跑。最后，它可以飞快的通过本题。
代码[http://www.cnblogs.com/dengyixuan/p/8671142.html]

---

## 作者：mgzc (赞：5)

## [题面](https://www.luogu.org/problemnew/show/P1418)

### [结合博客食用效果更佳](https://www.cnblogs.com/ztlztl/p/11007824.html)

## 题解

很容易看出来是道网络流的题目, 要是没有这个字典序最小, 直接建图跑一遍就好了, 考虑如何输出字典序最小的方案

我们可以贪心地去选择, 若当前点可以选0就选0, 不能选0就选1, 有一点像搜索, 但是直接搜索回溯肯定会爆炸, 考虑如何不回溯

用网络流优化, 若当前点选0后面有可行的方案, 直接选0, 若没有可行的方案, 这个点就只能选1了, 考虑到当前点的选择是在前面点已经选择完并确定有了可行解的情况下进行的, 所以这个策略是可行的, 至于时间复杂度的问题, 代码中会讲到

### 代码

```cpp
###include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <queue>
#define itn int
#define reaD read
#define N 105
#define INF 1000000009
using namespace std;

int n, m, r[N], c[N], d[N << 1], S, T, head[N << 1], cur[N << 1], cnt = 1, id[N][N], ans[N][N];
struct edge { int to, next, flow; } e[20005]; 

inline int read()
{
	int x = 0, w = 1; char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

inline void add(int u, itn v, int w) { e[++cnt] = (edge) { v, head[u], w }; head[u] = cnt; e[++cnt] = (edge) { u, head[v], 0 }; head[v] = cnt; }

int bfs()
{
	queue<int> q; memset(d, 0, sizeof(d));
	q.push(S); d[S] = 1;
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int v, i = head[u]; i; i = e[i].next)
			if(!d[v = e[i].to] && e[i].flow > 0) { d[v] = d[u] + 1; q.push(v); }
	}
	return d[T]; 
}

int dfs(int u, int a)
{
	if(u == T || !a) return a;
	int flow = 0;
	for(int v, &i = cur[u]; i; i = e[i].next)
	{
		if(d[v = e[i].to] == d[u] + 1 && e[i].flow > 0)
		{
			int f = dfs(v, min(a, e[i].flow));
			flow += f; a -= f; e[i].flow -= f; e[i ^ 1].flow += f; 
		}
		if(!a) break; 
	}
	if(a) d[u] = -1;
	return flow; 
}

int dinic() { int flow = 0; while(bfs()) { memcpy(cur, head, sizeof(head)); flow += dfs(S, INF); } return flow; }

bool check(itn x, int y)
{
	dinic(); if(!r[x] || !c[y]) return 0; r[x]--; c[y]--; 
    //先考虑当前行或列是否已经选完了所有可选的0
	if(e[id[x][y]].flow) { e[id[x][y]].flow = 0; return 1; }//若这条边flow = 1, 代表这条边没有被增广过, 也就是(x, y)这个点是0, 直接断掉这条边(保证以后增广不走他), return即可
	else
	{
        /*若这条边flow = 0, 代表这条边被增广过, 这个点(x, y)当前为1, 考虑将他变成0是否有可行解, 
        由于这条边被增广过, 故必有一条S -> x -> y -> T的增广路, 手动退流, 再次增广, 若能找到一条新的增广路补上这条路断掉之后的影响, 代表点(x, y)可以为0, 否则, 不能为0, 将x -> y断掉, 表示强制走他, S -> x和y -> T这两条边的流量减1即可, 由于没有被增广过, 刚刚正向边加上后流量必然>0, 将正向边流量减1即可*/
		e[id[x][y] ^ 1].flow = 0; e[id[x][m + 1] ^ 1].flow--; e[id[x][m + 1]].flow++;
		e[id[n + 1][y] ^ 1].flow--; e[id[n + 1][y]].flow++; if(dinic() == 1) return 1;
		r[x]++; c[y]++; e[id[n + 1][y]].flow--; e[id[x][m + 1]].flow--; return 0; 
	}
    //由于每次断边后只需要找到一条新的增广路即可, 所以每次dinic只会找到一条增广路, 复杂度是正确的
}

int main()
{
	n = read(); m = read(); S = n + m + 1; T = n + m + 2; 
	for(int i = 1; i <= n; i++) r[i] = read(); 
	for(int i = 1; i <= m; i++) c[i] = read(); 
	for(int i = 1; i <= n; i++)
	{
		id[i][m + 1] = cnt + 1; add(S, i, r[i]); 
		for(int j = 1; j <= m; j++)
		{
			if(i == 1) id[n + 1][j] = cnt + 1, add(j + n, T, c[j]); 
			id[i][j] = cnt + 1; add(i, j + n, 1); 
		}
	}
	for(int i = 1; i <= n; i++) r[i] = m - r[i]; 
	for(int j = 1; j <= m; j++) c[j] = n - c[j]; 
	for(int i = 1; i <= n; i++, puts(""))
		for(int j = 1; j <= m; j++) printf("%d", check(i, j) ? 0 : 1);
	return 0;
}

```



---

## 作者：破壁人 (赞：3)

分析：

首先很自然的一个想法就是贪心+搜索，每次尽量放0。

但是这样肯定很慢，我们来观察一下问题出在哪里。

我们发现每次遇到走不通的路就要回溯。我们可以优化他。

每次放0之后判断一下后面是否可行。

我们用网络流判断：

建立S和T，S向每一行连容量为r[i]的边，每一行向每一列连容量为1的边。

每一列向T连容量为c[j]的边，跑最大流，判断最大流与所有r[i]的和是否相等。

等等，这样每次都要重新建图，复杂度是错的。

其实，每次跑完最大流，在判断下一个点之前看一下i向j的边是否为0，

若为零，表示这个点放0是可行的，那就直接放0，不用重新建图判断了。

然后，在不断判断过程中，图是越来越小的，所以最后可以很快的通过本题。

代码:

```cpp
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;

const int inf=1e9;

int to[25001],w[25001],w1[25001],next[25001],first[210],e[210],jude;
int n,m,S,T,d[210],f[210],cur[210],e1,mi=inf,now,a[101],b[201];

void insert(int o,int p,int q)
{
    to[e1]=p;w[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w[e1]=0;next[e1]=first[p];first[p]=e1++;
}

void rebuild(int o,int p)
{
    memset(first,-1,sizeof(first));   
    memset(f,0,sizeof(f)); 
    e1=jude=0;
    d[S]=3;f[3]=f[0]=1;
    for(int i=o;i<=n;i++)
        for(int j=(i==o)?p:1;j<=m;j++) insert(i,j+n,1);
    for(int i=1;i<=n;i++) {d[i]=2;f[2]++;jude+=a[i];insert(S,i,a[i]);}
    for(int i=1;i<=m;i++) {d[i+n]=1;f[1]++;insert(i+n,T,b[i]);}
}

int dfs(int u,int flow)
{
    if(u==T) return flow;
    int res=flow,v,ff;
    for(register int &i=cur[u];i!=-1;i=next[i])
        if((d[u]==d[to[i]]+1)&&(w[i]>0))
        {
            ff=dfs(to[i],min(res,w[i]));
            w[i]-=ff;w[i^1]+=ff;
            if(!(res-=ff))return flow;
        }
    if(!--f[d[u]]) d[S]=T;
    ++f[++d[u]];
    return flow-res;
}

int isap()
{
    int res=0;
    for(;d[S]<T;) 
    {
        memcpy(cur,first,sizeof cur);
        res+=dfs(S,inf);
    }
    return res;
}

bool check(int x,int y)
{
    a[x]--,b[y]--;
    for(register int i=first[x];i!=-1;i=next[i])
        if((to[i]==y+n)&&(w[i]==0)) return true;
    (y==m)? rebuild(x+1,1):rebuild(x,y+1);
    if(jude==isap()) return true;
    a[x]++,b[y]++;
    (y==m)? rebuild(x+1,1):rebuild(x,y+1);
    isap();
    return false;
}

int main()
{
    scanf("%d%d",&n,&m);
    S=n+m+1;T=S+1;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]=m-a[i];
    for(int i=1;i<=m;i++) scanf("%d",&b[i]),b[i]=n-b[i];
    rebuild(1,1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            if(a[i]&&b[j]&&check(i,j)) {cout<<0;}else {cout<<1;}
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：tommymio (赞：1)

转换一下，这题求最小字典序似乎不太容易，但求一个方案的可行性却是十分容易，是经典的棋盘类问题模型.

由于最小字典序的性质，可以贪心解决，每次确定当前位置上的数，再套用模型 $\texttt{check}$ 可行性即可.

但是直接建图时间复杂度不正确，我们可以直接在残量网络上进行修改转移到当前层的图，再在残量网络上跑 $\texttt{dinic}$.

**Show the Code**
```cpp
#include<cstdio>
#define min(a,b) ((a)<(b)? (a):(b))
const int inf=0x3f3f3f3f;
int n,m,s,t,cnt=1;
int q[100005],d[205],r[105],c[105];
int w[205][205],id[205][205],a[105][105];
int h[1005],to[100005],ver[100005],incf[100005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y,int z) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	incf[cnt]=z;
	w[x][y]=z;
	id[x][y]=cnt;
	h[x]=cnt;
}
inline void add_d(int x,int y,int z) {add(x,y,z);add(y,x,0);}
inline void change(int x,int y,int val) {
	incf[id[s][x]]+=val;
	w[s][x]+=val;
	incf[id[y+n][t]]+=val;
	w[y+n][t]+=val;
}
inline bool bfs() {
	int hd=0,tl=0;
	for(register int i=1;i<=t;++i) d[i]=0;d[s]=1;
	q[++tl]=s;
	while(hd<tl) {
		int x=q[++hd];
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			if(!d[y]&&incf[i]) d[y]=d[x]+1,q[++tl]=y;
		}
	}
	return d[t]>0;
}
inline int dinic(int x,int flow) {
	if(x==t) return flow;
	int rest=flow;
	for(register int i=h[x];i&&rest;i=ver[i]) {
		int y=to[i];
		if(d[y]==d[x]+1&&incf[i]) {
			int k=dinic(y,min(rest,incf[i]));
			if(!k) d[y]=0;
			incf[i]-=k;
			incf[i^1]+=k;
			w[x][y]=incf[i];
			w[y][x]=incf[i^1];
			rest-=k;
		}
	}
	return flow-rest;
}
inline void show() {
	for(register int i=1;i<=n;++i) {
		for(register int j=h[i];j;j=ver[j]) {
			int y=to[j];
			if(y!=s&&!incf[j]) printf("(%d,%d)\n",i,y-n);
		}
	}
}
int main() {
	n=read(),m=read();
	int maxflow=0,sum=0;s=n+m+1,t=n+m+2;
	for(register int i=1;i<=n;++i) r[i]=read();
	for(register int i=1;i<=m;++i) sum+=(c[i]=read());
	for(register int i=1;i<=n;++i) add_d(s,i,r[i]);
	for(register int i=1;i<=m;++i) add_d(i+n,t,c[i]);
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j) add_d(i,j+n,1);
	while(bfs()) maxflow+=dinic(s,inf);
	// printf("---------0-------\n");
	// printf("%d\n",maxflow);
	// show();
	for(register int i=1;i<=n;++i) {
		for(register int j=1;j<=m;++j) {
			if(!w[i][j+n]) {--maxflow;change(i,j,1);}
			else {w[i][j+n]=incf[id[i][j+n]]=incf[id[i][j+n]^1]=0;}
			while(bfs()) maxflow+=dinic(s,inf);
			// printf("---------%d-------\n",i);
			// printf("%d\n",maxflow);
			// show();
			if(maxflow>=sum) {a[i][j]=0;}
			else {++maxflow;change(i,j,-1);a[i][j]=1;}
		}
	}
	for(register int i=1;i<=n;++i) {for(register int j=1;j<=m;++j) printf("%d",a[i][j]);printf("\n");}
	return 0;
}
```

---

## 作者：KAZHYI (赞：0)

先用最大流求出任意一个合格矩阵,再用如下 BFS 修改矩阵.  
我们注意到如果想把一个位置的1修改成0,这个点的行和列都需要一个0修改成1,反之亦然,如此反复,如果形成了一个回路则可以修改最初的那个位置  
形式化来讲就是:        
$a_{i,j}=1$ $\to$ $a_{i,k}=0$ $\to$ $a_{s,k}=1$
$\to$ $\dots$ $\to$ $a_{i,j}=1$  
如果能找到这样一条回路,那么就可以把路径上的点异或 $1$ 后依然是一个合格矩阵.  
我们以**行和列**为状态,行转移这一行上点等于0的列,列转移这一列上点等于1的行,这样转移路径上行列是交错的,然后递归修改交点即可.  
修改一次复杂度为 $O((n+m)^2)$  
要枚举每个点然后修改所以总复杂度为 $O(nm(n+m)^2)$ 基本上达不到理论复杂度,可以通过此题  
[提交记录](https://www.luogu.com.cn/record/232008343)  

```cpp
#include <bits/stdc++.h>
using namespace std;
struct root {
  int t;
  int x;
} qq[1000001], accq[101][101];
int g[211][211], n, m, r, q[1000001], ac[1000001], ans[111][111], acc[101][101],acq[1000001];
void bfs(int x, int y) {
  int l = 0, r = 0;
  for (int i = 1; i <= max(n, m); i++) {
    accq[1][i] = accq[2][i] = {0, 0};
    acc[1][i] = acc[2][i] = 0;
  }
  qq[r++] = {1, x};
  acc[1][x] = 1;
  while (r > l) {
    root now = qq[l++];
    if (now.t == 2 && now.x == y) {
      ans[x][y] ^= 1;
      //递归输出交点
      while (1) {
        root qs = accq[now.t][now.x];
        if (!qs.x) break;
        if (now.t == 2)
          ans[qs.x][now.x] ^= 1;
        else
          ans[now.x][qs.x] ^= 1;
        now = qs;
      }
      break;
    }
    if (now.t == 1) {
      //不能跑已经处理过的点
      for (int i = now.x == x ? y : 1; i <= m; i++)
        if (ans[now.x][i] == 0 && !acc[2][i]) {
          qq[r++] = {2, i};
          acc[2][i] = 1;
          accq[2][i] = {now.t, now.x};
        }
    } else {
      //不能跑已经处理过的点
      for (int i = x; i <= n; i++)
        if (ans[i][now.x] == 1 && !acc[1][i]) {
          qq[r++] = {1, i};
          acc[1][i] = 1;
          accq[1][i] = {now.t, now.x};
        }
    }
  }
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> r;
    g[0][i] = r;
  }
  for (int j = 1; j <= m; j++) {
    cin >> r;
    g[j + n][n + m + 1] = r;
  }

  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) g[i][j + n] = 1;
  //最大流
  while (1) {
    int l = 0, r = 0;
    q[r++] = 0;
    ac[0] = 1;
    for (int i = 1; i <= n + m + 1; i++) ac[i] = acq[i] = 0;

    int f = 1;
    while (r > l) {
      int now = q[l++];
      if (now == n + m + 1) {
        while (now) {
          g[acq[now]][now]--;
          g[now][acq[now]]++;
          now = acq[now];
        }
        f = 0;
        break;
      }
      for (int i = 0; i <= n + m + 1; i++)
        if (!ac[i] && g[now][i]) {
          q[r++] = i;
          acq[i] = now;
          ac[i] = 1;
        }
    }
    if (f) break;
  }
  //找到一个合理矩阵
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (g[j + n][i]) ans[i][j] = 1;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      //如果是1看看能不能变成0
      if (ans[i][j] == 1) {
        bfs(i, j);
      }
    }
  }

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cout << ans[i][j];
    }
    cout << '\n';
  }
}
```

---

## 作者：Celebrate (赞：0)

解法1 ： 递归+回溯

每个位置找0和1，如果搜不下去了就回溯，一搜到就马上输出并且，exit(0)

听说是可以拿50分

1<= n,m <= 100 ，不用说都会超时

 

解法2：网络流

搜到当前位置，就用网络流判断这个如果这个位置填上0，是否有解

若有解比如为0 ，否则为1 

因为要判断是否能填0，我们就把1的个数改成0的个数

网络流难在建图，我们可以把每行每列想象成一个点，并对着后面的点建图

起点与每行建立一条边，流量为r[] ， 每行与每列建边，流量为c[] 

当搜索到一个点的时候，先判断这个点在前面跑过的dicnic中是否有流量走过

如果有那么肯定是0，否则重新建图再次判断

如果最大流为a[i]之和，说明可以填0

解法1 ： 递归+回溯

每个位置找0和1，如果搜不下去了就回溯，一搜到就马上输出并且，exit(0)

听说是可以拿50分

1<= n,m <= 100 ，不用说都会超时

 
网络流之所以比递归快

是因为网络流能判断当前位置及以后的全局最优解，但是递归只能找到局部最优解

具体点说，就是网络流不仅考虑现在，而且考虑了全局

而递归只是无脑的去暴力搜索，只是判断这个位置填这个数是否行，能就继续找，不能就回溯，因此就慢了

代码见 ：[Myblog](https://blog.csdn.net/zsyzClb/article/details/85037738)


---


# 种树

## 题目描述

cyrcyr 今天在种树，他在一条直线上挖了 $n$ 个坑。这 $n$ 个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr 不会在相邻的两个坑中种树。而且由于 cyrcyr 的树种不够，他至多会种 $k$ 棵树。假设 cyrcyr 有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。


## 说明/提示

对于 $20\%$ 的数据，$n\leq 20$。

对于 $50\%$ 的数据，$n\leq 6000$。

对于 $100\%$ 的数据，$1 \le n\leq 300000$，$1 \le k\leq \dfrac{n}{2}$，在一个地方种树获利的绝对值在 $10^6$ 以内。


## 样例 #1

### 输入

```
6 3 
100 1 -1 100 1 -1
```

### 输出

```
200```

# 题解

## 作者：litc (赞：220)

本题其实是在n个数中选出至多k个数，且两两不相邻，并使所选数的和最大。

很容易想到动规思路：f[i][j]表示种到第i棵树且种了j棵的最大获利，则f[i][j]=max(f[i-1][j],f[i-2][j-1]+a[i])，注意边界、初始化即可。

但是，对于本题n<=300000的数据规模，动规显然不足以通过本题，需要另想算法。

我们先进行小规模枚举：

k=1时，显然取n个数中取最大的即可（暂不考虑全负的情况）。设最大的数是a[i]。

k=2时，则有两种可能：1、另取一个与a[i]不相邻的a[j]。2、取a[i-1]和a[i+1]。

我们可以发现：如果k=1时最优解为a[i]，那么我们便可以把a[i-1]和a[i+1]进行合并，因为它们要么同时被选，要么同时落选（证明不难，请自行解决）。而且，我们还注意到：当选了a[i-1]和a[i+1]时，获利便增加了a[i-1]+a[i+1]-a[i]。所以当a[i]被选时，我们就可以删去a[i-1]和a[i+1]，并把a[i]改成a[i-1]+a[i+1]-a[i]，重新找最大的。

每次找的都是最大的数，我们便可以使用堆进行操作，直到堆中最大值小于0或取出k个数后停止。复杂度O(klogn)。


---

## 作者：3493441984zz (赞：112)

# 贪心$+$双向链表

思路真的很神奇，我做过了这种题目但是看的第一眼还是想不到这种办法，太弱惹呜呜呜


------------
# 最开始的思路：

虽然最近做过这种贪心题，但是苦思冥想后还是做不出，于是重新看一遍题目呀，发现，这不是一道$dp$吗，小菜吧，于是我兴高采烈的看了一下数据范围，$QAQ$，我这种蒟蒻写的$dp$肯定会爆空间，于是使用秘术：看题解$qwq$



------------
# 思路：

看完题解后，其实讲的有点模糊，所以来写一篇题解，希望能讲清

在这里先膜拜一下题解里的$dalao$，这种思路都想得出

那么**言归正传**

### 我们先观察这一道题，要求最大值，那么我们先来看一种**错误**的做法(**注意是错误的**)：

先用优先队列处理每个点（大根堆）

我们对于每一次种树，取美观度最大值种树，然后标记两旁访问过，访问过的地方就不种树

那么可能一开始都这么想~~（可能并不是）~~，然而这种做法错在哪里呢：

假如是这种情况（$4$个点中取$2$个）(序列为$8,9,8,1$不想重新画图了，将就着看吧)：

![](https://i.loli.net/2019/02/15/5c6615f95097d.png)

我们按照上面的做法取的话，会是下图的结果

![](https://i.loli.net/2019/02/15/5c6616cb074df.png)

### 那么我们发现了一个问题:

我们取最大值的时候，可能取两边的会比取中间的更优！

### 那么为了处理这个问题，我们可以这样做：

一开始对于每个点建立双向链表

当前取了这个点后，把它出优先队列的同时，再加入一个点，这个点的权值是左边点权$+$右边点权$-$当前点权，例如上图：

当我们取了$9$后，我们应该加一个点，点权为$8+8-9=7$，并且把双向链表更新，$9$的右边变为$8$的右边$1$

### 为什么这样弄呢？为什么这样就能解决上面的问题呢？

其实我们这样做是添加了一个反悔机制，我们来模拟一下上图：

当我们把$7$入队列，$9$出队列后，图就变成下图了：

![](https://i.loli.net/2019/02/15/5c661bb044c17.png)

那么由于是优先队列，下一个出来的是$8$，但是$8$被访问过了，（在$9$出队列的时候，左右都标记为访问了），那么直接退出，下一个出队列的是$8$，也被访问过了，退出，下一个出队列的是$7$，没被访问，更新$ans$，并且把左右两边置为访问过，也就是下图：

![](https://i.loli.net/2019/02/15/5c6619e9aee3d.png)

由于取了两次了，退出，那么最后的答案就是$16$也就是$9+7$，但是我们发现$16$也等于$8+8$，那么这整个过程其实就相当于我们取了$8,8$,因为我们一开始取了$9$，然后取了$7$，但是$7$是怎么来的呢，就是$8+8-9$来的，那么$9+7$就可以化为$9+8+8-9$，也就是$8+8$,所以你看懂这个反悔机制了吗


------------
下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 500007
#define int long long
using namespace std;
struct Place
{
	int val,l,r;
}p[N];
struct Node
{
	int val,id;
	bool operator <(Node it) const
	{
		return val<it.val;
	} 
};
int n,m,ans;
bool vis[N];
priority_queue<Node> q;
void Del(int x)
{
	p[x].l=p[p[x].l].l;
	p[x].r=p[p[x].r].r;
	p[p[x].l].r=x;
	p[p[x].r].l=x;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%lld",&p[i].val);
		p[i].l=i-1;
		p[i].r=i+1;
		q.push((Node){p[i].val,i});
	}
	for(int i=1;i<=m;++i)
	{
		while(vis[q.top().id])
			q.pop();
		Node now=q.top();
		q.pop();
		if(now.val<=0)
			break;
		ans+=now.val;
		vis[p[now.id].l]=vis[p[now.id].r]=1;
		p[now.id].val=p[p[now.id].l].val+p[p[now.id].r].val-p[now.id].val;
		q.push((Node){p[now.id].val,now.id});
		Del(now.id);
	}
	printf("%lld",ans);
	return 0;
}
~~~


---

## 作者：clamee (赞：42)

这个题可以直接 DP + wqs 二分解决。

考虑当没有 $k$ 限制时，可以设方程 f[i][0/1] 表示**选完前 $i$ 个，最后一个选不选。**

考虑有 $k$ 的限制，只需证明 ans 是一个关于 $k$ 的凸函数即可。

显然这只有可能是一个上凸函数。

假设 ans 在 [0,m] 上单调递增，在 [m,n/2] 单调递减，即 $m$ 是第一个 ans 开始减小的位置。

为了直观表示，我们用 01 串来表示选取情况。

假设当前 m 次选择的 01 串为：

0100100010101...

第 m+1 次选择必然会选择一个合法的 0101...1010 形式的回文串翻转。

显然，该串是所有如此形式回文串中贡献最大的，并且显然贡献小于 0。

考虑在之后的一次翻转中，要么翻转的新串的贡献一定小于这一次的贡献：

如两串不重叠，显然成立。

如两串重叠，考虑重叠部分还原后，新串绝对是 1-2 个 0101...1010 形式的回文串.又因为之前翻转的串是所有如此形式回文串中贡献最大的，并且贡献小于 0。

故本次一定比上次更小。

所以直接再套个 wqs 二分即可。

复杂度： $O(nlog_2\max(a_i))$

```
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define il inline
#define rg register

il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}

il void write(int x)
{
	if(x<0)return putchar('-'),write(-x),void();
	if(x<10)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}

int n,m,f[2][2],g[2][2],a[500005],ans,cnt,t;

void sol(int x)
{
	f[0][0]=f[0][1]=g[0][1]=g[0][0]=0;
	for(rg int i=1;i<=n;i++)
	{
		int t=i&1;
		if(f[t^1][0]>f[t^1][1]||(f[t^1][0]==f[t^1][1]&&g[t^1][0]<g[t^1][1]))
			f[t][0]=f[t^1][0],g[t][0]=g[t^1][0];
		else f[t][0]=f[t^1][1],g[t][0]=g[t^1][1];
		f[t][1]=f[t^1][0]+x+a[i];
		g[t][1]=g[t^1][0]+1;
	}
	if(f[n&1][0]>f[n&1][1]||(f[n&1][0]==f[n&1][1]&&g[n&1][0]<g[n&1][1]))
		ans=f[n&1][0],cnt=g[n&1][0];
	else ans=f[n&1][1],cnt=g[n&1][1];
}

signed main()
{
	//freopen("1.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sol(0);
	if(cnt<=m)//看函数的峰在不在 0-m 内。
	{
		write(ans);
		return 0;
	}
	int l=-10000000ll,r=0;
	while(l<=r)//wqs 二分。
	{
		int mid=(l+r)>>1ll;
		sol(mid);
		//cerr<<cnt<<" "<<mid<<" "<<ans<<endl;
		if(cnt<=m)
		{
			t=ans-m*mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	write(t);
}
```

---

## 作者：旅人杜 (赞：40)

本题基本题意为在n个坑中种至多k棵树，且树与树间不相邻，并使权和最大。

刚看到这个题的时候就想，只要建立一个大根堆并保证每次出堆后，根顶元素互不相邻，然后累加权利就可以了。**但实际当然不行！！**其实应该考虑拿出一个根顶元素后，那么下次累加一定应选下一个不与它相邻的元素，但这时候就要考虑一个问题了，**万一上述情况的权利累加和小于第一次拿出来的根顶相邻的两个元素权利累加和呢？**

在详细读了各大神犇的题解后，理解了，**当选择了num[i]后，反悔了，反之选择选了num[i-1]和num[i+1]时，获利便增加了num[i-1]+num[i+1]-num[i]。**所以当num[i]被选时，我们就可以删去num[i-1]和num[i+1]，即为其代表的book数组打上标记并把num[i]改成num[i-1]+num[i+1]-num[i]，放进堆中，重新找最大的。

而想到这里后，正在学习搜索的我第一时间便想到了多次深搜，即深搜递归中加标记后去标记，但转念一想，先前的错误想法都有超时的数据，那如果用了搜索，岂不是一组也过不去，所以我们要用**大根堆**存储坑的权利与编号，然后进行上述操作即可。

当取元素取k次或取到元素小于0时结束。
**代码如下：**

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
int n,k;
long long num[500001],ans;//记录权利
int left[500001],right[500001];//记录左右坑 
bool book[500001];//记录遍历过与否
struct node
{
	int id;
	long long w;//w是权利 id是序号 
	bool operator <(node b) const
    {
        return w < b.w;
    }
 } t;//t用来过渡 
priority_queue<node>q;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&t.w);
		num[i]=t.w;
		t.id=i;
		left[i]=i-1;
		right[i]=i+1;
		q.push(t);
	}
	left[n+1]=n;
	right[0]=1;//补全r，l数组
	for(int i=1;i<=k;i++)
	{
		while(book[q.top().id])//如果遍历过则删除 ,注意！一定要用while删除，因为1不知道有几个遍历过。2可能有多次根顶遍历过。 
			q.pop();
		t=q.top();//取出堆顶元素 
		q.pop();
		if(t.w<0)//如果堆顶元素小于0则跳出 
			break;
		ans+=t.w;
		int c=t.id;
		num[c]=num[left[c]]+num[right[c]]-num[c];
		t.w=num[c];//设置新节点，意为若不选x节点选择x节点左右两节点的权利增加量 ，即提供反悔选项。 
		book[left[c]]=book[right[c]]=1;//删除左右的坑
		left[c]=left[left[c]];
		right[c]=right[right[c]];
		right[left[c]]=c;
		left[right[c]]=c;//更新左右坑的左右坑 
		q.push(t);
	}
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：BeautyYu言醴 (赞：20)

私以为各位的题解都没有点明解决问题的关键,甚至有些在描述上是错误的.

这里用自己的理解方式来详细讲讲这道题.

或者你可以在我的[个人博客](https://beautyyuyanli.ml/2018/10/19/2018-10-19-Luogu1484%E7%A7%8D%E6%A0%91%E9%A2%98%E8%A7%A3/)查看这篇题解

***


> cyrcyr今天在种树，他在一条直线上挖了n个坑。这n个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr不会在相邻的两个坑中种树。而且由于cyrcyr的树种不够，他至多会种k棵树。假设cyrcyr有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。
>
> n<=500000

很有趣的一道题

dp的做法我就不多赘述了.主要讲讲怎么$O(klogn)$实现它

***

首先我们考虑一个特殊情形:不限制树的数量上限,所有权值都为正数

假设$n=3$,用$01$串表示种树的情况的话,无非就是这两种:

1. $010$
2. $101$

假如目前策略是$010$的话,总价值$ans$为$val[2]$,如果满足条件:

$val[1]+val[3]>val[2]$

我们就可以改用策略$101$,此时价值增加量$f_1=val[1]+val[3]-val[2]$,种下的树的数量增加$1$

假设$n$大一些,例如$n=5$时,从$01010$转为$10101$的情形也大致一样:种下的树数量增加$1$,价值增加量为$f_2=val[1]+val[5]-f_1$,($f_1$含义见上一行,即$01010$的增加量)

如果$f_2>0$,那么这个新的策略是值得的

于是我们发现了它重要的规律:**这极其类似于求二分图匹配的增广路算法**

也就是:路径上的$0$变为$1$,$1$变为$0$,种的树数量增加$1$

不过有一个区别:本题中进行一次类似"增广"的操作,会产生一个价值$f$,这个$f$可以通过容斥原理求得.

那么原题题意就明了了:我们的任务是进行不多于$k$次类似"增广"的操作,使得所有$f$之和最大

***

那么怎么实现这个操作呢?双向链表.

我们用一个节点来表示一段**交错种树**的坑的区间,初始状态下一个节点对应一个坑.

这个节点里要保存这段区间进行一次"增广"后产生的价值.初始状态就是原先这个坑的价值

如果进行了一次增广,那么区间就会和它左/右两边的区间合并,例如$0010100$,如果我们对区间$[3:5]$进行一次"增广",那么就变成了$0101010$,区间扩大为$[2:6]$.这时候表示$[2:2]$的节点和表示$[6:6]$的节点都被$[2:6]$覆盖了,因此我们新建一个节点表示$[2:6]$,而原先的三个节点都打上删除标记.新节点直接与节点$[1:1]$和节点$[7:7]$相连.

由于我们要使$k$次"增广"的价值之和最大,显然把所有节点丢进一个大根堆里,按价值$f$从大到小取出就好了.

***

代码如下.

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <cstring>
#include <cmath>
#include <queue>
#define LL long long
using namespace std;
struct qwq{
        //the node in the Linked-list
        //it represents a sub-sequence of the array of holes
        LL val;//the value that the sequence can provide if we make it expand
        qwq *left,*right;
        bool if_del;//if the node has been deleted
        qwq (LL al,qwq *be):
                val(al),left(be),right(NULL),if_del(0){}
        qwq (LL al):
                val(al),left(NULL),right(NULL),if_del(0){}
};
struct pwp{
        //pointer to the node on the Linked-list
        qwq *p;
        bool operator < (const pwp &be)const{
                return p->val < be.p->val;
        }
};
priority_queue<pwp> h;
int main(){
        LL n,k;
        cin >> n >> k;
        LL al;qwq *be;
        scanf("%lld",&al);
        be = new qwq(al,NULL);
        h.push((pwp){be});
        for (LL i = 2;i <= n;++ i){
                scanf("%lld",&al);
                be->right = new qwq(al,be);
                be = be->right;
                h.push((pwp){be});
        }
        LL ans = 0;
        for (LL i = 1;i <= k;++ i){
                //take the node which owns the max value
                while(h.size() && h.top().p->if_del)
                        h.pop();
                qwq *p = h.top().p;
                h.pop();
                //we needen't to exactly chose k holes 
                if (p->val <= 0)
                        break;
                //make the sequence expand
                ans += p->val;//add value to the answer
                qwq *new_ = new qwq(0 - p->val);//create a new node to represent the larger sequence
                //the new node 's value is (left->val)+(right->val)-(origin->val)
                //if the left/right node exist
                //just like Augmenting-Path algorithm in gragh theory
                if (p->left != NULL){
                        //delete the left node,because it's sequence will be contained by the sequence of the new node
                        p->left->if_del = 1;
                        new_->val += p->left->val;
                        new_->left = p->left->left;
                        if (new_->left != NULL)
                                new_->left->right = new_;
                }
                else
                        new_->right = NULL;
                if (p->right != NULL){
                        p->right->if_del = 1;
                        new_->val += p->right->val;
                        new_->right = p->right->right;
                        if(new_->right != NULL)
                                new_->right->left = new_;
                }
                else
                        new_->right = NULL;
                //push the new node to the heap
                h.push((pwp){new_});
        }
        cout << ans;
        return 0;
}

```

文结.

![](https://s1.ax1x.com/2018/08/01/PwLNFO.jpg)

---

## 作者：M_seа (赞：17)

[更好的阅读体验](https://blog.csdn.net/qq_36288976/article/details/80787858)

首先应该想到的是O(nk)的dp， 可以获得50分。

**正解：贪心+堆（大根堆）**

我们可以把选择分为两种， 选择 a[i] 和选择 a[i-1] 、a[i+1] 
这样，将坑每3个分成一组，对于每个a[i], 要么就选择a[i],要么就a[i-1],a[i+1]一起选。 
然后堆优化贪心。具体贪心看代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 500010;
struct node
{
    ll v;
    int id;
    bool operator <(node b) const
    {
        return v < b.v;
    }
};
ll a[N], ans;
int l[N], r[N];
bool bj[N];
priority_queue<node> q;
int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; i++)
    {
        scanf("%lld", &a[i]);
        q.push((node){a[i], i});
        l[i] = i-1, r[i] = i+1;
    }
    int len = n;
    for(int i = 1; i <= k; i++)
    {
        while(!q.empty() && bj[q.top().id])
            q.pop();
        if(q.empty() || q.top().v < 0)
            break;
        node t = q.top();q.pop();
        ans += t.v;
        bj[t.id] = bj[l[t.id]] = bj[r[t.id]] = 1;
        a[++len] = a[l[t.id]]+a[r[t.id]]-a[t.id];
        int l1 = l[t.id], r1 = r[t.id];
        l[len] = l[l1], r[len] = r[r1];
        r[l[len]] = len, l[r[len]] = len;
        q.push((node){a[len], len});
    }
    printf("%lld\n", ans);
    return 0;
}

```

---

## 作者：Strelitzia (赞：14)

#### [题目传送门](https://www.luogu.com.cn/problem/P1484)

-------------------

$\ \ \ \ \ \ $这道题一看就是的$dp$，可是看一眼数据范围，可知，应该不是$dp$。

$\ \ \ \ \ \ $从题目中，我们很容易看出这是一道贪心。

$\ \ \ \ \ \ $原始贪心思路：

$\ \ \ \ \ \ $先观察这一道题，要求最大值，那么我们先用优先队列处理每个点。

$\ \ \ \ \ \ $对于每一次种树，取美观度最大值种树，然后标记两旁访问过，访问过的地方就不种树。

$\ \ \ \ \ \ $很明显，这是错的，实测只有$10$分

$\ \ \ \ \ \ $假如数据为：$8848\ 8849\ 8847\ 0$

$\ \ \ \ \ \ $按上述做法是先取$8849$，将两旁标记为不可种。

$\ \ \ \ \ \ $然后再取$0$。

$\ \ \ \ \ \ $但十分明显，取$8848$和$8847$才是最好选择。

$\ \ \ \ \ \ $所以，主角来了

$\ \ \ \ \ \ $——后悔机制

$\ \ \ \ \ \ $具体是怎么做呢？

$\ \ \ \ \ \ $一开始对于每个点建立双向链表

$\ \ \ \ \ \ $当前取了这个点后，把它出优先队列的同时，再加入一个点，点的值是前驱的点权$+$后继的点

$\ \ \ \ \ \ $权$-$取出点的点权

$\ \ \ \ \ \ $例如$8848\ 8849\ 8847\ 0$ 

$\ \ \ \ \ \ $当取了$8849$后，加一个点，点权为$8847+8848-8849=8846$。

$\ \ \ \ \ \ $将$8848\ 8847$删去。

$\ \ \ \ \ \ $之后反复进行取点，删点。

$\ \ \ \ \ \ $我们又会取到$8846$,就是新加入的点。

$\ \ \ \ \ \ $ ans=8846+8849=(8848+8847-8849)+8849=8848+8847

$\ \ \ \ \ \ $就相当于与取了$8848\ 8847$。

$\ \ \ \ \ \ $是不是很牛逼。

$10$代码

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
template<typename T>void read(T &x) {
    T f = 1;x = 0;char s = getchar();
    while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
    x *= f;
}
template<typename T>void print(T x) {
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
int n,m,a[2000005],ans,MAX;
priority_queue<pair<int,int> > pq;
bool vis[2000005];
signed main () {
	read(n);read(m);
	for (int i = 1 ; i <= n ; ++ i)
		read(a[i]),pq.push(make_pair(a[i],i));
	while (m --) {
		pair<int,int> no = pq.top();
		pq.pop();
		while (vis[no.second]) {
			no = pq.top();
			pq.pop();
		}
		ans += no.first;
		if (MAX > ans) return 0 & printf("%lld",MAX);
        else MAX = ans;
        if (no.second == 1) {
			vis[n] = 1;
			vis[2] = 1;
		}
		if (no.second == n) {
			vis[1] = 1;
			vis[n - 1] = 1;
		}
		else vis[no.second + 1] = vis[no.second - 1] = 1;
	}
	printf("%lld",ans);
	return 0;
}
```

$100$代码

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
    T f = 1;x = 0;char s = getchar();
    while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
    x *= f;
}
template<typename T>void print(T x) {
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}
long long n,m,ans,a[2000005],pre[2000005],nxt[2000005],MAX;
priority_queue<pair<long long,long long> > pq;
bool vis[2000005];
void Delete(int x) {
	pre[nxt[x]] = pre[x];
	nxt[pre[x]] = nxt[x];
}
int main () {
	read(n);read(m);
	for (int i = 1 ; i <= n ; ++ i)
		read(a[i]),pq.push(make_pair(a[i],i));
	for (int i = 1 ; i <= n ; ++ i) {
		pre[i] = i - 1;
		nxt[i] = i + 1;
	}
	while (m --) {
		pair<int,int> no = pq.top();
		pq.pop();
		while (vis[no.second]) {
			no = pq.top();
			pq.pop();
		}
		int x = no.second;
		ans += a[x];
		if (MAX >= ans) return printf("%lld",MAX) & 0;
		else MAX = ans;
		a[x] = a[pre[x]] + a[nxt[x]] - a[x];
		pq.push(make_pair(a[x],x));
		vis[pre[x]] = vis[nxt[x]] = 1;
		Delete(pre[x]);
		Delete(nxt[x]);
	}
	printf("%lld",MAX);
	return 0;
}
```

$\ \ \ \ \ \ $蟹蟹大家٩('ω')و

---

## 作者：kikuss (赞：12)

注意到题目中的限制条件，如果在**一个坑中种了树，那么这个坑两边的坑就不可以再种树**

那么就有这种情况出现，对任意一个坑id，其左边的坑$l[id]$及$r[id]$，选择$max(v[id],v[l[id]]+v[r[id]])$

正解其实为优先队列（大根堆），首先将所有的坑全部丢入堆中维护，然后最多种满k个坑，所以从1枚举到k，可以不种满，这种情况下肯定是因为种下这棵树的价值是负的，对我们来说没有意义

1~k的循环中每次取出堆顶，直接将其加到ans中（这肯定是不对的，但是之后我们会进行比较，即事实上我们的堆中维护的是$v[l[id]]+v[r[id]]-v[id].$

所以下次取出来后，如果这是一个正数，那么我们实际上加的是$v[l[id]]+v[r[id]]$，将其与左右两个坑的值得和比较，然后作差丢入堆中，并将这三个点全部打上标记（不管选择哪种方案这三个坑都不能再使用了）.

然后将这个值赋给在n个坑之后的空位中，即安排一个变量num，初始值为n，并将这个坑num左端点链到$l[l[id]]$,右端点链到$r[r[id]]$（因为$l[id],r[id]$这两个坑都是不能用的），再维护其左右端点

欢迎来踩博客[real_l](https://www.cnblogs.com/real-l/p/9188014.html)

---

## 作者：Grisses (赞：7)

upd: 
- 20240714 感谢提醒，代码打注释的时候改错了

---

[题面](https://www.luogu.com.cn/problem/P1484)

本题除了思维的难度大了一点之外，还是很简单的，方法与 [\[国家集训队\]种树](https://www.luogu.com.cn/problem/P1792) 类似，通过链表维护区间，优先队列求最值就可以了。但还是有一些细节。

我们设 $nxt_i$ 表示链表中编号为 $i$ 的元素的下一个元素的编号，$per_i$ 表示链表中编号为 $i$ 的元素的上一个元素的编号，$a_i$ 表示链表中编号为 $i$ 的元素的值。
  
当我们从优先队列中取出一个值时，把它累加进答案后，就表示我们选了这棵树。那么它两边的树就都不能选了。但是，有可能选两边会更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/6axcm1nv.png)

这时，代码的精髓就来了：“后悔处理”。如果现在我们选了 $i$，那我们就可以 $a_i$ 变为 $a_{per_i}+a_{nxt_i}-a_i$。不难发现，如果我们选了这个新的 $i$ 那么就相当于我们选了 $per_i$ 和 $nxt_i$，而没选 $i$。

另外，还有一个细节是我们可以不种到 $m$ 棵树，所以我们需要一边处理，一边求答案的最大值。


代码
```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  int n,m,ans,cnt,a[500005];
  int l[500005],nxt[500005],per[500005];//数组模拟链表
  struct node{
      int a,x;
      node(){}
      node(int c,int d){a=c,x=d;}
      bool operator<(const node &t)const{
          return a<t.a;
      }
  };//结构体存储节点信息
  priority_queue<node>q;
  bool vis[500005];
  signed main()
  {
      scanf("%lld%lld",&n,&m);
      for(int i=1;i<=n;i++)scanf("%lld",&a[i]),q.push(node(a[i],i));
      for(int i=1;i<=n;i++)nxt[i]=i+1,per[i]=i-1,l[i]=a[i];
      while(m--){
          while(vis[q.top().x])q.pop();//弹出已经不存在的
          node tmp=q.top();
          q.pop();
          vis[nxt[tmp.x]]=vis[per[tmp.x]]=1;//标记
          ans+=tmp.a;//累加
          tmp.a=-tmp.a+l[nxt[tmp.x]]+l[per[tmp.x]];
          l[tmp.x]=tmp.a;
          per[nxt[nxt[tmp.x]]]=tmp.x;
          nxt[tmp.x]=nxt[nxt[tmp.x]];
          nxt[per[per[tmp.x]]]=tmp.x;
          per[tmp.x]=per[per[tmp.x]];//删去左右两边的节点
          q.push(tmp);//因为可以不种m棵树，所以要一边维护一边更新答案
          cnt=max(cnt,ans);
      }
      printf("%lld",cnt);
      return 0;
  }
```

---

## 作者：March_H (赞：6)

定义f[i][j][0/1]表示为当前考虑到i号坑，种或不种，且已经种了j棵树的最大值

目标:max{f[n][j][0/1]},0<=j<=k

考虑转移方程:

对于第i个坑，如果种树，则f[i][j][1]=val[i]+f[i-1][j-1][0]

因为i号坑种树，所以i-1号坑不能种树，然后已经种了j棵树，而i号坑种树，所以到i-1号坑已经种了j-1棵树

对于第i号坑，如果不种树，则f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);

因为i号坑不种树，所以i-1号坑可种可不种，而当前已经种了j棵树，所以是由i-1号坑中已经种了j棵树的方程转移过来

空间超限，发现每个状态仅由前一个状态递推而来，考虑滚动数组

时间超限，考虑优化dp，优化目标：klog2(n)：

发现k<=n/2，尝试枚举j的范围更改为：1<=j<=min(i/2+1,k),修改后超时4个点，错误4个点，优化错误(并不知为什么)

发现每个坑的收益，有正有负，考虑取出每个正数，尝试中...

更改转移方程：

对于存储正数的b数组：
```cpp
book[i]=true代表与上一个正数相邻
if(book[i]) f[otk^1][j][1]=b[i]+f[otk][j-1][0];
else f[otk^1][j][1]=b[i]+max(f[otk][j-1][0],f[otk][j-1][1]);
f[otk^1][j][0]=max(f[otk][j][0],f[otk][j][1]);
```
依旧超时5个点，但前5个数据点时间几乎少了一半，优化无误，不考虑更改

无法优化,考虑其他解法

发现对于连续3个正数坑，如果中间最大，那么备选答案为max(a[l]+a[r],a[mid]);

发现可以推入堆中取得最大值，达到dp未能达到的klog2(n)，且不会超时
于是将所有坑都推入堆中，并维护每个坑的左右坑l[x],r[x]

每次取出堆中最大值，一直到取完k次或者堆中最大值为负

对于每次操作，更新当前取出坑的l[x]与r[x],l[x]=l[l[x]],r[x]=r[r[x]];

同时，左边界的右边界更新为x，右边界的左边界更新为x

另外，将a[x]更新为a[l[x]]+a[r[x]]-a[x]。并在此推进堆，如果之后选到了更新后的的a[x],那么答案就会变成:

a[x]+a[l[x]]+a[r[x]]-a[x],

即表示选择了左右2个坑而未选择中间的坑，所以哪怕是之后的答案也不会对当前答案造成干扰

最重要的是，开long long

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

const int maxn=500010;
int n,k;
int l[maxn],r[maxn];
int tot;
//int tot=0,b[maxn];
//int f[2][maxn>>1][2];

ll a[maxn];
ll ans;

//bool otk=false;
//bool book[maxn];
bool dig[maxn];

struct node{
	ll val;
	int ip;
} dui[maxn];

inline ll read(){
	ll ans;
	char c;
	bool op=false;
	while(c=getchar(),c<'0'||c>'9'){
		if(c=='-') op=true;
	}
	ans=(c^48);
	while(c=getchar(),c>='0'&&c<='9'){
		ans=(ans<<3)+(ans<<1)+(c^48);
	}
	return op? -ans:ans;
}

inline void up(int x){
	while((x>>1)>=1){
		if(dui[x>>1].val<dui[x].val){
			swap(dui[x>>1],dui[x]);
			x>>=1;
		}else break;
	}
}

inline void down(int x){
	int l,r;
	int maxx;
	while(1){
		l=x<<1,r=x<<1|1;
		if(l<=tot&&dui[l].val>dui[x].val) maxx=l;
		else maxx=x;
		if(r<=tot&&dui[r].val>dui[maxx].val) maxx=r;
		if(maxx==x) break;
		swap(dui[x],dui[maxx]);
		x=maxx;
	}
}

int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;++i){
		a[i]=read();
		l[i]=i-1;
		r[i]=i+1;
		dui[++tot]=(node){a[i],i};
		up(tot);
	}
	node mid;
	while(k--){
		while(dig[dui[1].ip]){
			swap(dui[1],dui[tot]);
			--tot;
			down(1);
		}
		mid=dui[1];
		swap(dui[1],dui[tot]);--tot;down(1);
		if(mid.val<0) break;
		ans+=mid.val;
		int ip=mid.ip;
		a[ip]=a[l[ip]]+a[r[ip]]-a[ip];
		mid.val=a[ip];
		dig[l[ip]]=dig[r[ip]]=true;
		dui[++tot]=mid;up(tot);
		l[ip]=l[l[ip]];r[l[ip]]=ip;
		r[ip]=r[r[ip]];l[r[ip]]=ip;
	}
	printf("%lld",ans);
	/*for(int i=1;i<=n;++i){
		a[i]=read();
		if(a[i]>0){
			b[++tot]=a[i];
			if(a[i-1]>0) book[tot]=true;
		}
	}
	if(!tot){
		printf("0");
		return 0;
	}
	for(int i=1;i<=tot;++i,otk^=1)
		for(int j=1;j<=k;++j){
			if(book[i]) f[otk^1][j][1]=b[i]+f[otk][j-1][0];
			else f[otk^1][j][1]=b[i]+max(f[otk][j-1][0],f[otk][j-1][1]);
			f[otk^1][j][0]=max(f[otk][j][0],f[otk][j][1]);
		}
	int maxx=-1;
	for(int j=0;j<=k;++j)
		maxx=max(f[tot&1][j][0],f[tot&1][j][1]);
	printf("%d",maxx);*/
	
	return 0;
}
```

---

## 作者：algobase (赞：4)

我们要在 $n$ 棵树中最多选出 $k$ 棵树，并且它（们）的获利最大。

种第一棵树时，显然要选获利最大的那一棵树。假设这棵树的下标是 $x$ （以下的的 $x$ 表示“第 $x$ 棵树”）。

种第二棵树时，有两种选择。第一种是选 $(x + \text{另外一棵树})$ ，第二种是选 $[(x - 1) + (x + 1)]$ 。没有第三种了，因为无论是 $(x + 1)$ 还是 $(x - 1)$ 都没有 $x$ 的获利大。

这时就出现了一种**反悔**的情况，前面选过的我们不要了。

------------
如何实现上述的步骤呢？

存储获利值的变量和 $ans$ 变量都是 $\text{long long}$ 类型的。

第一步，输入 $n$ 个数，把它们全部放进一个大根堆里。

第二步，循环 $k$ 次，每次从大根堆里取 $top$ 值，如果它已经被用过（ $vis[q.top().id] $ ）则从堆里弹出这棵树，直到它没用过（ $!vis[q.top().id] $ ）。这棵树的下标是 $x$ （以下的的 $x$ 表示“第 $x$ 棵树”）。如果这棵树的获利值为负就退出循环，因为把它加到 $ans$ 就是做减法了。再把符合条件的这棵树 $q.top().val$ 加到 $ans$ 中。

第三步，标记 $vis[x - 1]$ 和 $vis[x + 1]$ 为 $1$ ，表示它们已经被用过了。这两棵树和第 $x$ 棵树合体，变成一棵新的树，它的获利值是 $(-val[x] + val[x - 1] + val[x + 1])$ 。再把这棵树放回大根堆中。

那么最开始时 $x$ 的左边是 $(x - 1)$ ，右边是 $(x + 1)$ ，但是假如它们合并成了一棵新的树，那么这棵树的左边不是 $(x - 1)$ ，右边也不是 $(x + 1)$ 了。现在该怎么办？

这时，我们需要两个**类似于指针**的数组。一个是 $l[x]$ ，表示 $x$ 的左边的树的下标；另一个是 $r[x]$ ，表示 $x$ 的右边的树的下标。

在输入时，需要把 $l$ 数组和 $r$ 数组初始化。

第四步，更新 $l$ 数组和 $r$ 数组。新树的左边是原树的左边的左边（ $l[l[x]]$ ），右边是原树的右边的右边（ $r[r[x]]$ ）。新树的左边的右边是原树 （ $x$ ），新树的左边的右边也是原树 （ $x$ ）。

第五步，输出 $ans$ 。

---

## 作者：WHFF521 (赞：4)

种了一下午的树，终于给搞明白了（（多谢各位大神的题解）（题解就不能讲清楚点吗（看不见看不见）））；

你有k个树，你可以种在一条直线上，每个位置都有一个价值，如果你把树种在这里就可以获得这个价值，但是条件是不能有任意两棵树相邻；

当然你可以种0到k任意棵树；

怎么办呢？这道题也是一个（少见）的良心题；我先写了个无脑20分暴力，枚举这个位置选还是不选；
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5e5+10;
typedef long long ll;
int n,k;
int a[maxn];
int b[maxn];
ll ans;
ll cnt;
void dfs(int x)
{
    if(x==n+1)
    {
        ll sum=0;
        int num=0;
        for(int i=1;i<=n;i++)
        {
            if(b[i]==1&&b[i-1]==1) return ;
            if(b[i]==1) 
            {
                num++;
                if(num>k) return ;
                sum+=(ll)a[i];
            }
        }
        ans=max(ans,sum);
        return ;
    }
    b[x]=0;dfs(x+1);
    b[x]=1;dfs(x+1);
}

int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    dfs(1);
    printf("%lld",ans);
    return 0;
}
```
但是怎么能甘心20分，想到这个是一个直线，可能用dp，随便糊了一个就过了50分；

就是$f[i][j]$表示当前从1到i位置一共种了j棵树最大价值；

如果当前不种树，直接复制$f[i-1][j]$,要是想种树，就复制$f[i-2][j-1]$(因为不能相邻)
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5e5+10;
typedef long long ll;
int n,k;
ll a[maxn];
ll ans;
ll f[6010][3010];
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    f[1][1]=a[1];
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=k;j++)
        {
            f[i][j]=max(f[i-1][j],f[i-2][j-1]+a[i]);
            ans=max(ans,f[i][j]);
        }
    }
    printf("%lld",ans);
    return 0;
}
```
终于，我打开了题解（眼睛放出光芒）

three months later……

我们不用管什么谁先种谁后种，只要最大值；

我们可以用优先队列，这个是怎么想出来的呢？面对连续的3个数（首位或末尾位置随意），标号1,2,3；

如果我们选2号坑，那么1,3就废了；

如果选1.3，那么2就不能选了；（我表示不想分析这种事情）（优先队列帮您实现！！）

我们默认堆顶就是我们要找的最大值，但是我们需要经过一些处理；

将每个点的左右端位置记录下来$l[i]=i-1$;$r[i]=i+1;$

先将n个坑扔进去，那么堆顶将是价值最大的那个，我们取出来ans+=val(为什么，1,3怎么办？)

没关系，因为我们选1就不能选1,3，那我们就不选1,3了，将2的值取出后再更新2的值，

$val[2]=val[1]+val[3]-val[2];$（ans需要更新的值）

但是我们要避免重复选取，将$vis[1]=vis[3]=1;$(不在特殊访问)

还有就是这样做相当于分成了三个一组三个一组，我们将2的值更新后要将左右位置更新（相当于变成了0,2,4）

这样我们其实解决了三个一组首尾会相连的问题（如果我们要选1,3，我们会再次更新2.此时是0,2,4,模式，他们就不会相连；）

（在选1，3时已经和0,4比较了）

处理完成；

当堆里都是负数的时候就直接退出就行了；
```
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=5e5+10;
typedef long long ll;
int a[maxn];
int n,k;
int l[maxn],r[maxn];
priority_queue<pair<int,int> > q;
ll ans;
int vis[maxn];
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        //a[i].val=-a[i].val;
        q.push(make_pair(a[i],i));
        l[i]=i-1;
        r[i]=i+1;
    }
    r[0]=1;l[n+1]=n;
    while(k--)
    {
        while(vis[q.top().second]) q.pop();
        int x=q.top().first;
        int i=q.top().second;
        q.pop();
        if(x<0) break;
        ans+=(ll)x;
        a[i]=a[l[i]]+a[r[i]]-a[i];
        vis[l[i]]=1;vis[r[i]]=1;
        l[i]=l[l[i]];r[l[i]]=i;
        r[i]=r[r[i]];l[r[i]]=i;
        q.push(make_pair(a[i],i));
    }
    printf("%lld",ans);
    return 0;
}
```
 看这些做法和代码长度，你觉得这题（它难吗）（逃~）；

---

## 作者：cqbzhyf (赞：1)

[如题](https://www.luogu.com.cn/problem/P1484)

细看题目，这不就是那道数据备份（~~其实这类题目有4道左右~~）。

题目简单理解：
在 $n-1$ 条路里选择 $k$ 个不相邻的路段，使得路段长度总和最小。

初看题目，你会联想到线性DP，再看一下数据范围：能水部分分
为了不空间超限，我们压维（发现第一维只用记录前3个数值）

有了如下代码（不完整）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,A[100005],a[100005],dp[5][500005];
int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&A[i]);
		a[i]=A[i]-A[i-1];
	}
	for(int i=1;i<=k;i++)dp[2][i]=dp[1][i]=dp[0][i]=0x3f3f3f3f3f;
	for(int i=2;i<=n;i++){
		for(int j=0;j<=k;j++){
			if(j!=0)dp[i%3][j]=min(dp[(i-2)%3][j-1]+a[i],dp[(i-1)%3][j]);
			else dp[i%3][j]=dp[(i-1)%3][j];
		}
	}
	printf("%d",dp[n%3][k]);
	return 0;
}
```
现在我们来考虑正解，这一道题可以用贪心来解决（只不过是反悔贪心），也就是我们先选择最小值，在退回来验证选其两边数字的答案，就保证了正确性。

首先记录当前编号是否选择过，而对于删除元素操作，普通的数组太慢了，于是我们使用**链表**来进行维护。

首先左端点初始化为 $i-1$，同理右端点初始化为 $i+1$，注意此题不是环状，所以两边要特判处理。

并且为了快速取得最小值，我们考虑用优先队列进行维护，选择后记录编号，为保证之后的处理：当前节点的数值变为其左端点数值加右端点数值减当前数值。

处理后重新放入队列（删除该节点）。

其实此题还是与数据备份有一些不同的，比如“最大获利”的情况下，求解答案就有了些许的改变，见下：

```cpp
ans+=zqw.val;
Ans=max(Ans,ans);
```

最后答案是 `Ans`，而数据备份的答案是 `ans`。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Q1{int val,l,r;}a[500005];
struct Q{
	int val,id;
	bool operator<(Q x)const{return val<x.val;} 
};
int n,m,ans;
bool vis[500005];
priority_queue<Q>q;
int Ans;
inline void remove(int x){a[x].l=a[a[x].l].l,a[x].r=a[a[x].r].r,a[a[x].l].r=x,a[a[x].r].l=x;}
signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i].val);
		a[i].l=i-1,a[i].r=i+1,q.push(Q{a[i].val,i});
	}
	for(int i=1;i<=m;++i){
		while(vis[q.top().id])q.pop();
		Q zqw=q.top();q.pop();
		ans+=zqw.val;
		Ans=max(Ans,ans);
		vis[a[zqw.id].l]=vis[a[zqw.id].r]=1;
		a[zqw.id].val=a[a[zqw.id].l].val+a[a[zqw.id].r].val-a[zqw.id].val;
		q.push(Q{a[zqw.id].val,zqw.id});
		remove(zqw.id);
	}
	printf("%lld",Ans);
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

### 1. 题意
在 $n$ 个数中选择 $k$ 个互不相邻的数，并且使得它们的和最大。
### 2. 思路
首先：有一种显然的贪心思路：每次选取最大值，只需要保证不相邻即可。

但这种思路显然是错的，为什么呢？如图，现在要选 $2$ 个：
![](https://cdn.luogu.com.cn/upload/image_hosting/4s3th3ji.png)

我们知道，这个的最优解是：$5+6=11$，但如果按照刚才的贪心，就会先选 $7$，答案就只有 $7+3=10$ 了。

所以，刚才的贪心是不成立的。

我们可以先想到 $O(n^2)$ 的 dp：设 $dp_{i,j}$ 表示的是前 $i$ 棵树选择 $j$ 棵的最大值，那么就有取和不取两种情况，则 $dp_{i,j}\gets\max(dp_{i-1,j},dp_{i-2,j-1}+a_i)$。但是，这样时间复杂度为 $O(n^2)$，显然没办法过，并且不能优化。那，我们应该怎么做呢？

首先，还是从最初的思路出发：先把所有的排序，然后取最大的。此时我们取完后会发现还有一种情况：取旁边两个！我们可以用优先队列存储答案，每次取出编号为 $i$ 的元素，那么我们只需要再将 $a_{i-1}+a_{i+1}-a_i$ 入队即可，这样，对于上一个状态，个数仍然只增加了 $1$ 个，但是和是 $a_{i-1}+a_{i+1}$。

因为要进行多次扩展，用双向链表维护即可，时间复杂度 $O(n\log_2 n)$。

最后还有一个贪心：如果当前的最大值已经为负数，那么选择它答案就会减小，就不能选。
### AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=3e5+5;
int n,m,a[maxn],ans,l[maxn],r[maxn];
bool vis[maxn];
struct node{
	int x;
	inline bool operator <(const node &t) const{
		return a[x]<a[t.x];
	}
};
priority_queue<node> q;
inline int read(){
	char ch=getchar();
	int f=0,res=0;
	while(ch<'0'||ch>'9')
		f|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return f?-res:res;
} 
signed main(){
	n=read(),m=read();
	if((n>>1)<m){
		printf("Error!");
		return 0;
	}
	for(int i=1;i<=n;++i){
		a[i]=read();
		l[i]=i-1,r[i]=i+1;//初始化左边和右边
		q.push(node({i}));
	}
	for(int i=1;i<=m;++i){
		int k=q.top().x;
		if(a[k]<=0){
			break;
		}
		q.pop();
		if(vis[k]){
			--i;
			continue;
		}
		ans+=a[k];
		vis[l[k]]=vis[r[k]]=1;
		a[k]=a[l[k]]+a[r[k]]-a[k];
		r[l[l[k]]]=k;
		l[k]=l[l[k]];
		l[r[r[k]]]=k;
		r[k]=r[r[k]];
		q.push(node({k}));
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Others (赞：1)

就是[SP1553](https://www.luogu.com.cn/problem/SP1553)的环形背景。

反悔贪心，具体思路就参照一下我的[SP1553 的题解](https://383791.blog.luogu.org/solution-sp1553)。

对于我个人来说，环形背景比线性背景要好打很多，因为你不需要特判一些边界，只需要维护循环链表就行了。

注意这题唯一的一个坑点**至少种 $k$ 颗树**。

这里打个特判就行了。

**Code**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
template<typename zqw>void qr(zqw &x){
	bool f=x=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	x=f?~(x-1):x;
}
int n,m,a[500005],tot,flag[500005],nxt[500005],lst[500005];
struct node{
	int id,x;
	bool operator<(const node &p)const{
		return x<p.x;
	}
};
priority_queue<node> qu;
signed main() {
	qr(n),qr(m);
	for(int i=1;i<=n;i++) {
		qr(a[i]);
		qu.push((node){i,a[i]});
		nxt[i]=(i==n?0:i+1);
		lst[i]=(i==1?0:i-1);
	}
	a[0]=-1000000000000;
	qu.push((node){0,-1000000000000});
	while(m--){
		node tmp=qu.top();
		if(tmp.x<=0) break;
		qu.pop();
		if(flag[tmp.id]) {
			m++;
			continue;
		}else{
			flag[nxt[tmp.id]]=flag[lst[tmp.id]]=1;
			tot+=a[tmp.id];
//			cout << tmp.id << " " << a[tmp.id] << endl;
			a[tmp.id]=a[nxt[tmp.id]]+a[lst[tmp.id]]-a[tmp.id];
			qu.push((node){tmp.id,a[tmp.id]});
			lst[tmp.id]=lst[lst[tmp.id]];
			nxt[tmp.id]=nxt[nxt[tmp.id]];
			nxt[lst[tmp.id]]=tmp.id;
			lst[nxt[tmp.id]]=tmp.id;
		}
	}
	cout << tot;
	return 0;
}
```

---

## 作者：Spasmodic (赞：1)

反悔贪心 √

一个显然的思路是 dp，但是复杂度是 $O(nk)$ 的，过不了，然而这题的做法是贪心。

先考虑一些特殊情况。

1. $k=0$

这种情况，我们直接取最大值即可。

2. $k=1$

这种情况，我们先取最大值，然后考虑第二个应该怎么取，有三种取法：

+ 不取
+ 另取一个 $a_j$
+ 不取最大值，取最大值的左边和最大值的右边

分别考虑即可。

3. $k=2$

我们还是考虑已经取了两个之后该怎么办。

+ 不取
+ 另取一个 $a_j$
+ 不取一个数，取它的左边和右边。

以此类推，做法就出来了：我们依次考虑下一个种哪棵树，维护取这棵树的贡献。特别的，如果这棵树已经被取了，那么就表示不取一个数，取它的左边和右边的贡献。如果发现最优的取法也会让答案减少，那就不取。

找左边和右边用双向链表即可，至于如何维护，我们发现只有插入，删除最大和查询最大值，用一个大根堆即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct IO_Tp {
    const static int _I_Buffer_Size = 2 << 22;
    char _I_Buffer[_I_Buffer_Size], *_I_pos = _I_Buffer;

    const static int _O_Buffer_Size = 2 << 22;
    char _O_Buffer[_O_Buffer_Size], *_O_pos = _O_Buffer;

    IO_Tp() { fread(_I_Buffer, 1, _I_Buffer_Size, stdin); }
    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }

    IO_Tp &operator>>(ll &res) {
    	ll f=1;
        while (!isdigit(*_I_pos)&&(*_I_pos)!='-') ++_I_pos;
        if(*_I_pos=='-')f=-1,++_I_pos;
        res = *_I_pos++ - '0';
        while (isdigit(*_I_pos)) res = res * 10 + (*_I_pos++ - '0');
        res*=f;
        return *this;
    }

    IO_Tp &operator<<(ll n) {
    	if(n<0)*_O_pos++='-',n=-n;
        static char _buf[10];
        char *_pos = _buf;
        do
            *_pos++ = '0' + n % 10;
        while (n /= 10);
        while (_pos != _buf) *_O_pos++ = *--_pos;
        return *this;
    }

    IO_Tp &operator<<(char ch) {
        *_O_pos++ = ch;
        return *this;
    }
} IO;

const ll N=500005;
ll n,k,ans,a[N],pre[N],nxt[N];
bool del[N];
void remove(int x){pre[nxt[x]]=pre[x],nxt[pre[x]]=nxt[x],del[x]=1;}
struct node{
	ll id,v;
	node(ll id_,ll v_){id=id_,v=v_;}
	bool operator<(const node&x)const{
		return v<x.v;
	}
};
priority_queue<node>q;
int main(){
	IO>>n>>k;
	for(ll i=1;i<=n;i++)IO>>a[i],pre[i]=i-1,nxt[i]=i+1,q.push(node(i,a[i]));
	while(k--){
		while(del[q.top().id])del[q.top().id]=0,q.pop();
		node cur=q.top();q.pop();
		if(cur.v<=0)break;
		ans+=cur.v;
		q.push(node(cur.id,a[cur.id]=a[pre[cur.id]]+a[nxt[cur.id]]-cur.v));
		remove(pre[cur.id]),remove(nxt[cur.id]);
	}
	IO<<ans;
	return 0;
}
```

---

## 作者：哈啊哈 (赞：1)

# P1484[种树]
带反悔的贪心  
当要求取出一个a[i]而不能选择与a[i]相邻的两个时  
取出a[i]后  
将a[i-1]+a[i+1]-a[i]压入堆中  
下次如果再选中该项  
相当于抵消了原来的选择  
需要用双向链表实现  

## 注意
带反悔贪心中a[0]与a[n+1]的初始值  
最大值时可以不管  
最小值时只要不首尾相接  
一定要赋值成极大值  


### 一发使用stl set的代码

``` c++

#include<iostream>
#include<cstdio>
#include<set>
using namespace std;
#define int long long//开long long 
const int N=500010;
int n,k,a[N],l[N],r[N],ans;
struct node{
	int val,pos;
	bool operator <(const node &cmp)const{//重载小于号 
		if(val==cmp.val) return pos<cmp.pos;
		return val>cmp.val;
	}
};
set<node> s;
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		s.insert((node){a[i],i});
		l[i]=i-1,r[i]=i+1;
	}
	a[0]=-1e9,a[n+1]=-1e9;//处理边界 
	while(k--){
		set<node>::iterator it=s.begin();
		int x=it->pos;
		if(it->val<=0) break;//小于0一定不是最优 
		ans+=it->val;
		s.erase(it);
		node tmp1={a[l[x]],l[x]},tmp2={a[r[x]],r[x]};
		s.erase(tmp1),s.erase(tmp2);//删除相邻点 
		a[x]=a[l[x]]+a[r[x]]-a[x];//反悔贪心 
		s.insert((node){a[x],x});
		l[x]=l[l[x]],r[x]=r[r[x]];//双向链表维护 
		l[r[x]]=x,r[l[x]]=x;
	}
	printf("%lld\n",ans);
	return 0;
}
``` 
~~话说set常数是真的大~~


---

## 作者：Celtic (赞：1)

这道题可以贪心做。

看到题上说相邻位置不能种树，那么也就是如果$x$位置种了一棵树那么$x-1$和$x+1$必须空着。

我们可以开一个堆，把所有的位置的价值放进去，然后每次选最大的把两边的打上标记不选。

但是这样做有一个问题，就是可能选两边的比选它和另一个比较小的要更优，比如$3,6,5,1$，如果我们按上面的做法选的会是$6,1$，没有选$3,5$好。

考虑到如果$a_{x}$最大，我们如果选了$x-1$，那么一定会选$x+1$，不然如果选别的一定不如选$x$和另一个。

所以此时我们可以选择$a_x$，把它从堆中取出，在同样的位置放入$a_{x-1}+a_{x+1}-a_x$，然后把$a_{x-1}$和$a_{x+1}$删掉。这时如果我们以后选择新加入的这个点就相当于选择了$a_{x-1}$和$a_{x+1}$，效果是一样的，

为了做到$O(1)$删除和添加元素我们用双向链表存储原数组，然后只需要选$k$次就可以输出答案啦。

其他细节详见代码。

```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define re register
#define N 501001
#define MAX 2001
#define PI 3.1415927
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
    ret=pd?-ret:ret;
}
ll n,a[N],pre[N],nxt[N],ans,now,m,anss=-inf;
priority_queue<pair<ll,ll> >q;
inline void pop(re ll det)
{
	pre[nxt[det]]=pre[det];
	nxt[pre[det]]=nxt[det];
}
bool vis[N]; 
int main()
{
	read(n);
	read(m);
	for(re int i=1;i<=n;i++)
		read(a[i]),nxt[i]=i+1,pre[i]=i-1,q.push(make_pair(a[i],i));
	nxt[0]=1,pre[n+1]=n;
	while(!q.empty())
	{
		while(vis[q.top().second])
			q.pop();
		now++;
		if(now>m)
			break;
		ans+=q.top().first;
		anss=max(anss,ans);
		re ll det=q.top().second;
		q.pop();
		a[det]=a[pre[det]]+a[nxt[det]]-a[det];
		q.push(make_pair(a[det],det));
		vis[pre[det]]=vis[nxt[det]]=true;
		pop(pre[det]);
		pop(nxt[det]);
	}
	printf("%lld\n",anss);
	exit(0);
}
```


---

## 作者：llzzxx712 (赞：1)

# P1792题解

[传送门](https://www.luogu.com.cn/problem/P1792)

## 题意简述

给出一个 n 个有权值节点的链，选出 k 个不相邻的节点，使它们的权值和最大。

$ n<=5*10^5 , k<=n/2 $

## 题目分析

如果 k = 1，那么结果就是$a$数组中的最大值。

如果 k = 2，那么就有两种情况：

1. 选择最大值 $a_i$ ，不选 $a_{i-1} ,a_{i+1} $ ，再从剩下的数中选择最大值。
1. 不选最大值 $a_i$ ，选 $a_{i-1} ,a_{i+1} $ 。

为什么不选最大值 $a_i$ 就要选 $a_{i-1} ,a_{i+1} $ 呢？

如果只选了 $a_{i-1} ,a_{i+1} $ 中的一个，那么把选了的换成了 $a_i$ 一定更优。

显然$a_i , a_{i-1} ,a_{i+1} $都不选不是最优解。

**所以最小值左右两侧的数要么都选，要么都不选。**

所以我们可以先选上 $a$ 数组中的最大值（第一种情况），然后将然后将 $a_{i-1},a_i,a_{i+1}$ 从数列中删除，并在原位置插入一个新元素$a_{i-1}-a_i+a_{i+1}$ 。这样原问题就变成了一个从 $a$数组中选 $k-1$ 的数的子问题，显然重复这个操作 $k-1$次就可以求出最终结果。

## 代码实现思路

所以我们可以建立一个链表 Q，分别记录$a_1,a_2,a_3 … a_{N-1}$ 。 再建立一个二元组大根堆，每个元素与链表中的每一个元素成一一映射关系，第二元记录对应链表中的指针。

每次取出堆顶，更新答案。再删除节点（链表中打标记、更新左右节点数组，大根堆中删除）、插入新节点。

执行$K$次后输出。

## 易错点
- 这是一条链。
- 记得开 long long 。

## AC代码

内带详细注释

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<cmath>
#define N 500010
#define ll long long
using namespace std;
void read(ll &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
ll a[N],le[N],r[N];
long long ans;
bool v[N];
priority_queue < pair < ll , ll > > q;
void del(int x){//删除操作 
	le[r[x]]=le[x];
	r[le[x]]=r[x];
	v[x]=1;//节点是否删除 
}
int main(){
	int n,m;
	cin>>n>>m;
	//le[1]=n;r[1]=2;le[n]=n-1;r[n]=1;
	for(int i=1;i<=n;i++){
		read(a[i]);//读入 
	}
	for(ll i=1;i<=n;i++) le[i]=i-1,r[i]=i+1;//建立链表 
	for(ll i=1;i<=n;i++){
		q.push(make_pair(a[i],i));//第一元为值，第二元为标号 
	}
	while(m--){
		int x,y;
		while(v[q.top().second]) q.pop();
		y=q.top().second;q.pop();//取出最大节点 
		if(a[y]<0) break;
		ans+=a[y];//更新答案 
		a[y]=a[le[y]]+a[r[y]]-a[y];//新节点 
		del(le[y]);del(r[y]);//删除 
		q.push(make_pair(a[y],y)); 
	}
	printf("%lld\n",ans);
	return 0;
}	
```








---

## 作者：Suyun (赞：1)

对于一棵树 $i$，我们先假设它一定被种。但是，如果它不被种，那么它的左右两边一定会被选。所以，如果「反悔」，这等价于又种了一棵收益为 $a_{\operatorname{left}(i)} + a_{\operatorname{right}(i)} - a_i$ 的树。

所以，用一个堆来选择当前收益最大的树，再用一个链表维护每棵树左右两侧的树，最后选择收益最大的 $k$ 棵树。

注意要在当前待种的树的收益为负时及时退出。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500000;
const int K = 250000;

int n, k;
int a[N + 1];
int l[N + 1], r[N + 1];
bool deleted[N + 1];

int main() {
  priority_queue< pair<int, int> > q;

  cin >> n >> k;
  for (int i = 1; i <= n; ++i) {
    cin >> a[i];
    q.emplace(a[i], i);
  }

  for (int i = 1; i <= n; ++i) {
    l[i] = i - 1;
    r[i] = i + 1;
  }

  long long res = 0;
  while (k--) {
    while (deleted[q.top().second]) {
      q.pop();
    }

    auto p = q.top(); q.pop();
    if (p.first < 0) {
      break;
    }

    int i = p.second;
    int v = p.first;

    res += v;
    a[i] = a[ l[i] ] + a[ r[i] ] - a[i];

    // delete l[i] and r[i]
    deleted[ l[i] ] = deleted[ r[i] ] = true;
    l[i] = l[ l[i] ];
    r[ l[i] ] = i;
    r[i] = r[ r[i] ];
    l[ r[i] ] = i;

    q.emplace(a[i], i);
  }

  cout << res << endl;
}

```

---

## 作者：俾斯麦 (赞：1)

# 题解——种树（堆）


------

## 题面

**Description**

cyrcyr今天在种树，他在一条直线上挖了n个坑。这n个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr不会在相邻的两个坑中种树。而且由于cyrcyr的树种不够，他至多会种k棵树。假设cyrcyr有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。

**Input**

第一行，两个正整数n,k。

第二行，n个正整数，第i个数表示在直线上从左往右数第i个坑种树的获利。

**Output**

输出1个数，表示cyrcyr种树的最大获利。

**in.1**
6 3 
100 1 -1 100 1 -1

**out.1**
200

**数据范围与约定** 

对于20%的数据，n<=20。

对于50%的数据，n<=6000。

对于100%的数据，n<=500000，k<=n/2,在一个地方种树获利的绝对值在1000000以内。

## 部分分做法

**20分做法：**
 
 想怎样暴力，就怎样暴力。20分暴力做法之多。
 
**50分做法：**
 
 DP，转移并不是特别难。
 我们定义 dp[ i ][ j ][ 1/0 ] 表示递推到第 i 位，已经选了 j 个数, 1/0 表示当前位是否选择
 实际上和没有上司的舞会的dp转移很像，不过是序列上的
 
 ```cpp
 dp[ i ][ j ][ 1 ] = dp[ i-1 ][ j-1 ][ 0 ]
 dp[ i ][ j ][ 0 ] = max( dp[ i-1 ][ j ][ 0 ] , dp[ i-1 ][ j ][ 1 ] )
 ```
 
 答案取 max{ dp[ N ][ K ][ 1/0 ] } ， 滚掉第一位以节省空间


## 100% 数据思路

**主要思路**

1.处理选择矛盾的情况，即可以反悔。
  
  我们考虑，当选择了一个当前最大值 a[ i ] 后，发现其实最优值要选择a[ i-1 ] 和 a[ i+1 ]， 为了可以反悔，在选择下一个时，我们把 a[ i ]修改为 a[ i-1 ] + a[ i+1 ] - a[i] 。所以当 a[i] 被选后反悔时，我们在之后的选择中，我们就可以删去先前 a[ i ]的贡献而选择旁边两个。如果不反悔则不选，这样可以满足整个结构的最优性。

2.维护序列，不断满足上述条件
 
 最大值我们考虑使用大根堆（优先队列来维护），先把所有值和编号压入堆，并且记录左右值的编号，在选择了 a[ i ]后进行上述操作，同时更行左右值得编号即可。整个操作进行K次，由于存在负值，所以要不断取最大值。



**细节：**

 边界是不能合并越界，处理下即可。



```cpp
#include<bits/stdc++.h>
using namespace std ;
#define ll long long
const int MAXN = 500005  ;
inline int read(){
	int s=0,w=1 ; char g=getchar() ; while(g>'9'||g<'0'){ if( g=='-')w=-1;g=getchar() ;} 
	while(g>='0'&&g<='9')s=s*10+g-'0',g=getchar() ; return s*w ;
}
priority_queue< pair<ll,int> >q ;
int N , K , tot ; 
ll ans = 0 , last = 0 ;
struct ap{
	int  l , r ; 
	ll val ;
	bool f ; 
}t[ MAXN ];
int main(){
	t[ 0 ].val = -10000000000000005LL ; //边界
	N = read() , K = read() ; tot = N ;
	for( int i = 1 ; i <= N ; ++i ){
		t[ i ].val = (ll)read() , t[ i ].l = i-1 , t[ i ].r = i+1 ;
		q.push( make_pair(t[ i ].val , i) ) ;
	}
	t[ N ].r = 0 ;//边界
	while( K-- ){
		int u = q.top().second ;
		if( t[ u ].f ){ K++;q.pop();continue; }
		ll v = q.top().first ; q.pop() ;
		ans += v ; t[ t[ u ].l ].f = t[ t[ u ].r ].f = true ;//更新答案
		t[ u ].val = t[ t[ u ].l ].val + t[ t[ u ].r ].val - t[ u ].val ; 
		t[ t[ t[ u ].l ].l ].r = u , t[ t[ t[ u ].r ].r ].l = u ;//updata，更新左右编号
		t[ u ].l = t[ t[ u ].l ].l , t[ u ].r = t[ t[ u ].r ].r ;
		q.push( make_pair( t[ u ].val , u ) ) ;
		last = max( last , ans ) ;
	}
	cout<<last ;
}
```

###如有不足，请大佬指出

---

## 作者：Rbrq (赞：1)

## 题目描述

   cyrcyr今天在种树，他在一条直线上挖了n个坑。这n个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr不会在相邻的两个坑中种树。而且由于cyrcyr的树种不够，

他至多会种k棵树。假设cyrcyr有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。


## 数据范围

对于20%的数据，n<=20。

对于50%的数据，n<=6000。

对于100%的数据，n<=500000，k<=n/2,在一个地方种树获利的绝对值在1000000以内。


## 解题思路

我们考虑维护一个优先队列，使得其中的数按照严格单调递减的方式排序。  对于初始化而言，我们将每个点的获利放到优先队列中。

在操作中，每次取出堆顶，对于这个堆顶id我们有两个选择，将其加入选择，或者将它的两端都加入选择。不可能存在一种情况使得两端某个单独加入(如果这样两端id才是堆顶)

对于上述操作的实现是这样的，我们先将该点值直接加入总和中，然后将该点两端删去，把该点的值修改为两端值之和减去原来的该点的值，我们考虑以下几种情况

1.val[x]>=val[l[x]]+val[r[x]]

在这种情况下表示选择该点是最优的抉择，再也不可能影响最后总和结果.

2.val[x]<va[l[x]]+val[r[x]].

有两个可能

  A.它在最后排序中位于可以影响结果的位置，表示对于之前做的决定反悔。

  B.反之表示虽然两端和大于该点值，但是选择此点对于后续的影响使结果更优。

附上AC代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define reg register
using namespace std;
const int Maxn=5e5+5;
typedef long long ll;
struct dug{
    int g,val;
    bool operator <(const dug &rhs) const {
        return val<rhs.val;
    }
};
ll ans=0,val[Maxn];
int n,k,fin=0;
bool sbp[Maxn];
priority_queue<dug> q;
int l[Maxn],r[Maxn];
int main(){
    memset(sbp,0,sizeof(sbp));
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;++i){
        l[i]=i-1;
        r[i]=i+1;
        scanf("%lld",&val[i]);    
        q.push((dug){i,val[i]});
    }
    r[0]=1; l[n+1]=n;
    while(k--){
        while(sbp[q.top().g])q.pop();
        dug fr=q.top(); 
        if(q.top().val<0) break;
        q.pop();
        ans+=fr.val;
        int id=fr.g;
        sbp[r[id]]=sbp[l[id]]=1;
        val[id]=val[l[id]]+val[r[id]]-val[id];
        q.push((dug){fr.g,val[id]});
        l[id]=l[l[id]];r[l[id]]=id;
        r[id]=r[r[id]];l[r[id]]=id;
    }
    printf("%lld",ans);
    return 0;
} 

```
 

---

## 作者：彭天宇 (赞：1)

链表的基础题，其实是简单的数据结构。

不过这一题的思维价值不错。

选取了一些数之后（当这个状态最优），下一步要么选取剩余与这些数不相邻的数中最大的一个，要么选取其中一些数，用其左右的数字代换它（如果直接扔掉那之前为什么要选他？），总之要选取当前状态最优的。

选取一个数字之后，这个位置的价值就得到了，左右两个位置就不能选，将其标记，在序列上每次找到最大的值进行操作之后，如果发现还可以再取一个数，而左$+$右$>$中，那就可以用左右替换中间的，相应的，中间的更是不能选了，又要标记左左和右右。(像极了增广路)

那么我们不是很容易想到将中间的选取之后，将左右的权值集中到中间的点上（“缩点”），即：选取$a[p]$后，将其权值变成$a[l[p]]+a[r[p]]$，左右：$l[p]=l[l[p]]$，$r[p]=r[r[p]]$。那么接下来如果选取到$a[p]$的话，这样一加，就是$a[l[p]]+a[r[p]]$。当然具体实现的时候调用不能这么随意。

然后就可以用优先队列维护。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,m,ans,l[N],r[N],a[N];
priority_queue<pair<int,int> >q;
bool used[N];
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		l[i]=i-1;
		r[i]=i+1;
		q.push(make_pair(a[i],i));
	}
	r[0]=1;
	l[n+1]=n;
	while(m--){
		while(used[q.top().second])q.pop();
		int x=q.top().first;
		int pl=q.top().second;
		if(x<0)break;
		q.pop();
		ans+=x;
		a[pl]=a[l[pl]]+a[r[pl]]-a[pl];
		used[l[pl]]=1;
		used[r[pl]]=1;
		l[pl]=l[l[pl]];
		r[l[pl]]=pl;
		r[pl]=r[r[pl]];
		l[r[pl]]=pl;
		q.push(make_pair(a[pl],pl));
		for(int i=1;i<=n;i++)cout<<used[i]<<" ";
		cout<<endl;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Sym_Je (赞：0)

              堆 
  [P1484 种树](https://www.luogu.org/problemnew/show/P1484)     
	我们发现我们需要输出所有不相挨着的最大的和，所以我们这可以用堆来维护，我们从k=1开始，因为只有一个呢就是他本身了，然后我们再看k=2时，我们就会选最大值，然后k=3时，我们就会去选中间的一个或去选两边的。   
    因此我们我们要么选他本身要么选他两边的，因此我们维护一个堆，然后我们在用类似差分的算法，去搞出一个数两边得和，与之的差，这样如果是负数就说明他们之和比中间的小，就可以不加，如果大于的话就可以加，然后我们再用链表去维护一下，就OK咯。        
    每次我们只需要弹出其中的最大值，然后再去看是否需要更该，如果其中地最大值都小于0了，就说明这形成的的已经是最大的了，就结束就好咯。
    然后我们发现操作一次就等于把其中的一个数加入，或删掉一个个数加入两个数，所以只要搞m次就OK咯。
    
    
  
 ```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>

using namespace std;

long long a[500001];
long long l[500001],r[500001];

bool ok[500001];

struct node
{
	long long v,id;
	bool operator < (const node &a)
	const
	{
		return v<a.v;
	}
}t;

priority_queue<node> q;

long long n,m;

int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&t.v);
		a[i]=t.v;
		l[i]=i-1;
		r[i]=i+1;
		t.id=i;
		q.push(t);		
	}
	r[0]=1;
	l[n]=n+1;
	
	long long ans=0;
	
	while(m--)
	{
		while(ok[q.top().id])
		q.pop();
		t=q.top();
		if(t.v<0)
		break;
		
		q.pop();
		ans=ans+t.v;
		long long x=t.id;
		ok[l[x]]=ok[r[x]]=1;
		a[x]=a[l[x]]+a[r[x]]-a[x];
		t.v=a[x];
		t.id=x;
		l[x]=l[l[x]];
		r[x]=r[r[x]];
		r[l[x]]=x;
		l[r[x]]=x;
		q.push(t);
	}
	printf("%lld",ans);
	return 0;
}

```
    
    

---


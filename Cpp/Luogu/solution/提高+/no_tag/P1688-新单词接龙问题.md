# 新单词接龙问题

## 题目描述

给定一个包含 $n$ 个单词的字典，从中选择若干个单词，按字典序进行单词接龙，使得接龙的长度最大。

新单词接龙的规则：

1. 单词变换：单词 $w_i$ 添加一个字母，删除一个字母，或修改一个字母可以得到单词 $w_{i+1}$；
2. 字典序接龙：$w_1,w_2,\cdots,w_n$，满足字典序。

## 说明/提示

### 样例解释

长度为 $5$ 的单词接龙为：$\texttt{dig\underline afigafin\underline afine\underline awine}$。

## 样例 #1

### 输入

```
9
cat
dig
dog
fig
fin
fine
fog
log
wine
```

### 输出

```
5```

# 题解

## 作者：fzwfzwfzw (赞：9)

这是一道trie树的题目：

[P4407 [JSOI2009]电子字典](https://www.luogu.com.cn/problem/P4407)这一道题的变化和4407的变化是一样的！

单词的变化有三种：1删掉一个字母，2：插入一个字符，3：将一个字符变成另外一个字符

$$dig→fig→fin→fine→wine$$

### 因为单词接龙的顺序是限定的（字典序），所以我们可以将可以互相变化的字符串连起来，顺序限定所以方向是一定的，举个例子

因为dig可以变化为fig

$$dig→fig$$

### 所以dig向fig连一条边，因为dig的字典序小于fig，所以，是dig连向fig的有向边，不能是fig连向dig

在这样连完所有边之后，就可以发现这是一个DAG（有向无环图）所以，这里面的最长的单词接龙就是将他拓扑排序过后的最长链啦！

下面是代码时间！

下面的三个find分别是表示三种变化，其他的是trie的基本操作

从queue<int>开始就是拓扑排序啦！

```cpp

#include<bits/stdc++.h>
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int vis[250005];
struct node
{
	int to[26];
	int cu;
}e[250005];
string a[250005];
int cnt;
int n,mm;
int cst;
int ooo;
int ins(int x,int y)
{
	if(!e[x].to[y])
	e[x].to[y]=++cnt;
	return e[x].to[y];
}
int last;
int www;
void inser(string w,int p)
{
	last=0;
	www=w.size();
	for(int i=0;i<www;i++)
	{
		last=ins(last,w[i]-'a');
	}
	e[last].cu=p;
}
int fid(int x,int y)
{
	if(!e[x].to[y])
	return -2;
	return e[x].to[y];
}
int find(string w)
{
	last=0;
	www=w.size();
	for(int i=0;i<www;i++)
	{
		last=fid(last,w[i]-'a');
		if(last==-2)
		{
			return 0;
		}
	}
	if(ooo)
	{
		if(vis[last]!=cst)
		{
			vis[last]=cst;
			return e[last].cu;
		}
		else return 0;
	}
	return e[last].cu;
}
int find1(string w,int aw)
{
	last=0;
	www=w.size();
	for(int i=0;i<www;i++)
	{
		if(i!=aw)
		{
			last=fid(last,w[i]-'a');
			if(last==-2)
			{
				return 0;
			}
		}
	}
	if(ooo)
	{
		if(vis[last]!=cst)
		{
			vis[last]=cst;
			return e[last].cu;
		}
		else return 0;
	}
	return e[last].cu;
}
int find2(string w,int aw,int pp)
{
	last=0;
	www=w.size();
	for(int i=0;i<www;i++)
	{
		if(i==aw)
		{
			last=fid(last,pp);
			if(last==-2)
			{
				return 0;
			}
		}
		last=fid(last,w[i]-'a');
		if(last==-2)
		{
			return 0;
		}
	}
	if(aw==www)
	{
		last=fid(last,pp);
		if(last==-2)
		{
			return 0;
		}
	}
	if(ooo)
	{
		if(vis[last]!=cst)
		{
			vis[last]=cst;
			return e[last].cu;
		}
		else return 0;
	}
	return e[last].cu;
}
int find3(string w,int aw,int pp)
{
	last=0;
	www=w.size();
	for(int i=0;i<www;i++)
	{
		if(i==aw)
		{
			last=fid(last,pp);
			if(last==-2)
			{
				return 0;
			}
		}
		else 
		{
			last=fid(last,w[i]-'a');
			if(last==-2)
			{
				return 0;
			}
		}
	}
	if(ooo)
	{
		if(vis[last]!=cst)
		{
			vis[last]=cst;
			return e[last].cu;
		}
		else return 0;
	}
	return e[last].cu;
}
struct nod
{
	int next,to;
}ew[1000005];
int ppp;
int h[1000005];
int rd[1000005];
void add(int x,int y)
{
	if(!y)return;
	ppp++;
	ew[ppp].next=h[x];
	h[x]=ppp;
	ew[ppp].to=y;
	rd[y]++;
}
int longest[1000005];
int main(){
	n=read();
	char c[18];
	for(int i=1;i<=n;i++)
	{
		scanf("%s",c);
		a[i]=c;
	}
	inser(a[n],n);
	for(int iw=n-1;iw>=1;iw--)
	{
		cst++;
		ooo=1;
		string w=a[iw];
		int o=a[iw].size();
		for(int i=0;i<o;i++)
		{
			add(iw,find1(w,i));
		}
		for(int i=0;i<=o;i++)
		{
			for(int j=0;j<26;j++)
			{
				add(iw,find2(w,i,j));
			}
		}
		for(int i=0;i<o;i++)
		{
			for(int j=0;j<26;j++)
			{
				add(iw,find3(w,i,j));
			}
		}
		inser(a[iw],iw);
	}
	queue<int>q;
	for(int i=1;i<=n;i++)
	{
		if(!rd[i])
		{
			q.push(i);
		}
	}
	while(!q.empty())
	{
		int f=q.front();
		q.pop();
		longest[f]++;
		for(int i=h[f];i;i=ew[i].next)
		{
			rd[ew[i].to]--;
			if(!rd[ew[i].to])q.push(ew[i].to);
			longest[ew[i].to]=max(longest[ew[i].to],longest[f]);
		}
	}
	int maxx=0;
	for(int i=1;i<=n;i++)
	{
		maxx=max(maxx,longest[i]);
	}
	cout<<maxx<<endl;
	return 0;
}
```
### 祝大家好运

---

## 作者：KaisuoShutong (赞：5)

这是一道 字典树 题目。

[前置题目：[JSOI2009]电子词典]( https://www.luogu.com.cn/problem/P4407 )

对于转移方式的理解可以看这道题[我的题解]( https://www.luogu.com.cn/blog/setfire/solution-p4407)。

容易发现，这两个题的变换方式是一样的。  
那我们考虑倒序处理这些字符串。

设 $pr[i]$ 表示已经从第 $i$ 到 $n$ 个单词选出一些接龙的最大值。  
转移就是所有可达的字符串中 $pr$ 值最大的 +1。  
转移方法同 **电子词典** 一题。

对所有的 $pr$ 取 $max$ 即为答案。

掐头去尾好代码：

```cpp
void Insert(char*S)
{
	int x=0;
	for(int i=0;i<strlen(S);i++)
		if(ch[x][S[i]-'a']) x=ch[x][S[i]-'a'];
		else x=ch[x][S[i]-'a']=++dot;
	ed[x]=NOW;
}
void Mapping(int x,int lth,int fu)//当前节点 当前长度 是否编辑 
{
	if(lth==len&&ed[x]) return pr[NOW]=max(pr[NOW],pr[ed[x]]),void(0);
	if(!fu)
	{
		if(lth<len) Mapping(x,lth+1,1);//Delete
		for(int i=0;i<26;i++)
			if(ch[x][i])
			{
				Mapping(ch[x][i],lth,1);//Add
				if(i!=(S[NOW][lth]-'a')) Mapping(ch[x][i],lth+1,1);//Replace
			}
	}
	if(lth==len) return;
	if(ch[x][S[NOW][lth]-'a']) Mapping(ch[x][S[NOW][lth]-'a'],lth+1,fu);
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++) rein(S[i]);
	for(NOW=n;NOW;NOW--) len=strlen(S[NOW]),Mapping(0,0,0),++pr[NOW],Insert(S[NOW]),ans=max(ans,pr[NOW]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Saliеri (赞：4)

前置芝士 ： 

$\quad$[P4407 \[JSOI2009\]电子字典](https://www.luogu.com.cn/problem/P4407)。

$tips$ : 请确保理解了[**电子字典的做法**](https://www.luogu.com.cn/problem/solution/P4407)后再来阅读本文章，本文作者对自己的语言表达不是很自信。

___

题目描述：

- 给你一堆字符串，字符串$B$能够接在另一个字符串$A$后的条件为：
 > - $B$的字典序比$A$大。
 > - $B$可以由$A$**删去**一个字符，**添加**一个字符，或**替换**一个字符得到。
 
- 问最长能使多少个字符串相连接。
 
做过电子词典的可以直接秒了。
 
首先互相连接形成一种有向的链接关系，而又因为限制了字典序，所以肯定不会形成环。
 
所以互相连接关系抽象成一张图是一个**DAG**,原问题对应为DAG上的最长路。
 
问题来了，如何快速得到一个字符串能与那些字符串相连接？
 
 ___

解决方案：
 
我们将所有的文本串建成一颗$Trie$(不要告诉我你来切蓝题不会$Trie$)。
 
则添加，删除，替换三个操作可以在$Trie$树的查询过程中经过扰动得到。
 
实现方式:
 
- 我们将迭代查找改为递归查找，记录当前匹配串扫描到的位置与是否经过操作。
 
- 若没有经过操作，则枚举三种操作：

> - 插入：枚举26种字符，插入当前位置（通过那个字符走一步），扫描位置不变。
 
> - 删除：直接跳过当前字符，扫描位置向后挪（$Trie$树上不跳）。
 
> - 替换：枚举25种字符(跳过与当前相同的那种)，沿着这个字符跳一步（扫描位置向后挪）。
 
> - 最后记得讲是否经过操作的标记置为$true$.
 
- 若已经过操作，直接在$Trie$树上跳即可。
 
- 若扫描位置到达末尾，已经过操作且$Trie$树上有标记，将这个位置加入当前匹配串的后继栏（注意：只有当匹配到的串字典序大于匹配串才可加入）。
 
 ___
 
关于$DAG$最长路：
 
初始每个$d_i = 1$.
 
对于每个节点$i$：更新$d_{suf} = \operatorname{max}(d_{suf},d_i+1)$。
 
 
$Ans = \operatorname{max}(d_i)$
 
 ___
时间复杂度：
 
对于每次匹配操作：最坏情况下每个匹配点都延伸出$52$个分支，但大多数都会返回。
 
所以大概是$O(???*52*len*n)$
 
有很大的优化。（对暴力）
 
___
具体实现见代码：
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
const int maxn = 1e6+5;
inline int max(int a,int b){
	return a>b?a:b;
}
int n,tot=1;
char c[25005][17];
struct Trie{int ch[26],flag,id;}t[maxn];
//flag:结尾标记 id :结尾的串的编号。 
inline void insert(char *s,int id){
	int now = 1,len = strlen(s);
	for(int i=0;i<len;++i){
		if(!t[now].ch[s[i]-'a'])t[now].ch[s[i]-'a'] = ++tot;
		now = t[now].ch[s[i]-'a'];
	}
	t[now].flag = 1,t[now].id = id;
}
std :: vector <int> suf[25005];//vector存贮后继。 
int vis[maxn],q[25005],cnt;
//保证每个结尾点只被访问一次。 
inline void getsuf(char *s,int len,int pos,int now,int done,int id){
	//字符串，长度，匹配位置，当前Trie上位置，是否经过操作，匹配串编号。 
	if(len == pos && done && t[now].flag){
		vis[q[++cnt] = now] = 1;
		if(t[now].id > id)suf[id].push_back(t[now].id);
		//输入数据保证，编号大便保证字典序大。 
		return ;
	}
	if(!done)
		for(int i=0;i<26;++i)
			if(t[now].ch[i])
				getsuf(s,len,pos,t[now].ch[i],1,id);//添加操作 
	//因为添加操作不会影响pos，所以退出操作放在后面 
	if(pos >= len)return ;//匹配失败 
	if(!done){
		getsuf(s,len,pos+1,now,1,id);//删除 
		for(int i=0;i<26;++i)
			if(t[now].ch[i] && s[pos]-'a'!=i)
				getsuf(s,len,pos+1,t[now].ch[i],1,id);//替换 
	}
	if(t[now].ch[s[pos]-'a'])getsuf(s,len,pos+1,t[now].ch[s[pos]-'a'],done,id);// 正常跳 
}
inline void clear(){while(cnt)vis[q[cnt--]] = 0;}//清空标记 
int d[maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%s",&c[i]),insert(c[i],i),d[i]=1;
	for(int i=1;i<n;++i)getsuf(c[i],strlen(c[i]),0,1,0,i),clear();
	for(int i=1;i<=n;++i)
		for(int j=0;j<suf[i].size();++j)
			d[suf[i][j]] = max(d[suf[i][j]],d[i]+1);
	int ans = 0;
	for(int i=1;i<=n;++i)ans = max(ans,d[i]);
	printf("%d",ans);
	return 0;
}
```

若有问题，欢迎提问。

完结撒花。

---

## 作者：Cotsheep (赞：2)

~~大家好，我喜欢 Hash，所以我用 Hash 通过了这道题~~。  
## 思路： 哈希  

[*My Blog*](https://www.cnblogs.com/cotsheep/p/16873675.html)

处理方法有点类似于 [P6521](https://www.luogu.com.cn/problem/P6521)  

首先我们最终接出的字符串要求其中的小字符串按字典序排序，那么我们就将所有字符串排好序后从前往后枚举（其实题目已经给我们排好序了，但有些人可能没有注意到），每次枚举到一个字符串就更新把它作为答案串结尾的最大长度。     

然后注意到一一枚举从 `a` 到 `z` 的每一个字母会让复杂度爆掉，那么我们就用一个空字符（比如 `#`）来代替要变换的部分。

举个例子，对于字符串 `adcb`，它可以由 `adb` 加一个字符 `c` 变换过来，那么我们就会在枚举到 `adb` 时将状态 `ad#b` 塞到 Hash 中，之后枚举到 `adcb` 时就可以用 `ad#b` 来更新答案。  

具体过程：  

令当前枚举到第 $i$ 个字符串，我们先更新这个字符串作为结尾的答案。  
分三种变换（两种情况）：  
1. 添加 & 修改一个字母  
 枚举每一位字符，将其变为 `#` 后在 Hash 中查找该串，更新找到的最大长度。  
2. 删除一个字母（当前字符串长度不能为 $16$）  
 枚举每一个字符间的位置，把 `#` 插进去后在 Hash 中查找，更新找到的最大长度。  

将找到的最大长度 $+1$ 后更新到最终答案里。  
然后再插入这个字符串，也分三种变换两种情况，但删除和添加操作调换了一下：  
1. 删除 & 修改一个字母  
 枚举每一位字符，将其变为 `#` 后把它塞进 Hash。  
2. 添加一个字母（当前字符串长度不能为 $16$）  
 枚举每一个字符间的位置，把 `#` 插进去后把串塞进 Hash。  

最后我们会发现这样会让相同的字符串重复统计，那么我们在一开始就把相同的字符串去掉就好，不影响最终结果。  

更具体一点看代码（写的有点 Naive）：  

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline ll Max(ll x, ll y){return x > y ? x : y;}
inline ll rd(){
	ll x = 0;bool f = true;char c = getchar();
	while (c < '0' || c > '9'){if (c == '-') f = false; c = getchar();}
	while (c >= '0' && c <= '9'){x = (x<<3) + (x<<1) + (c ^ 48);c = getchar();}
    return f ? x : -x;
}
const int N = 2.5e4 + 10, M = 1e5 + 7;

class Hash_table{
    private: 

    struct Node{
        int nextt, num;// num 是 “str” 这个状态的最大长度
        string str;
    }data[N * 50];int head[M + 10], cnt;

    int h(string s){
        int l = s.size(), res = 0;
        for(int i = 0; i < l; ++i)
            res = ((res << 4) + int(s[i] - 'a') + M) % M;
        return res;
    }

    public: 

    int find(string s){
        int key = h(s);
        for(int i = head[key]; i; i = data[i].nextt)
            if(s == data[i].str)
                return data[i].num;
        return 0;
    }

    void insert(string s, int val){
        int key = h(s);
        for(int i = head[key]; i; i = data[i].nextt){
            if(s == data[i].str){
                data[i].num = Max(data[i].num, val);
                return ;
            }
        }
        data[++cnt].nextt = head[key];
        data[cnt].num = val;
        data[cnt].str = s;
        head[key] = cnt;
        return ;
    }
}H;

int n;
int ans;
string s, lst = "", tmp, tmp1, tmp2;// lst用来去重，一坨tmp用来枚举带’#’的字符串

int main(){
    n = rd();
    for(int i = 1; i <= n; ++i){
        cin >> s;
        if(s == lst)continue;
        lst = s;
        int l = s.size(), val = 0;// val是以当前串结尾的串的最大长度
		tmp = s;
        for(int j = 0; j < l; ++j){// 查找之前 添加和修改 的字符串
            tmp[j] = '#';
            val = Max(val, H.find(tmp));
			tmp[j] = s[j];
        }
        if(l < 16)// 查找之前 删除 的字符串
            for(int j = 0; j <= l; ++j){
                tmp = "", tmp1 = "", tmp2 = "";
                for(int k = 1; k <= j; ++k)// 用一堆 += 时间更优
                    tmp1 += s[k - 1];
                for(int k = j + 1; k <= l; ++k)
                    tmp2 += s[k - 1];
                tmp += tmp1;
                tmp += '#';
                tmp += tmp2;
                val = Max(val, H.find(tmp));
            }

        val++;
        ans = Max(ans, val);// 更新最终答案

		tmp = s;
        for(int j = 0; j < l; ++j){// 插入 删除和修改 后的字符串
            tmp[j] = '#';
            H.insert(tmp, val);
			tmp[j] = s[j];
        }

        if(l < 16)// 插入 添加 后的字符串
            ans = Max(ans, val);
            for(int j = 0; j <= l; ++j){
                tmp = "", tmp1 = "", tmp2 = "";
                for(int k = 1; k <= j; ++k)
                    tmp1 += s[k - 1];
                for(int k = j + 1; k <= l; ++k)
                    tmp2 += s[k - 1];
                tmp += tmp1;
                tmp += '#';
                tmp += tmp2;
                H.insert(tmp, val);
            }
    }
    printf("%d", ans);
	return 0;
}
```


---

## 作者：chzhh_111 (赞：1)

注：这里的字典序大小是按照编号大小排的。

考虑动态规划，设 $dp_{w_i}$ 表示以 $w_i$ 结尾所能得到的最大长度，则很自然地得到动态转移方程为：$dp_{w_i}=\max(dp_{w_j})+1$，其中 $w_j$ 代表 $w_i$ 能够通过题目当中的变化得到 $w_j$，且 $j<i$，即 $w_j$ 的字典序小于 $w_i$。

现在问题是如何求 $w_j$（下文的 $len$ 指的是 $w_i$ 的长度）。

- 对于删除操作，假设我们要删除第 $i$ 位的字符，就相当于把以第 $i-1$ 位结尾的前缀和以第 $i+1$ 位开头的后缀拼起来，分别处理前后缀就行了。特别的，如果 $i-1=0$，则前缀为空串，如果 $i+1>len$，则后缀为空串。

- 对于修改操作，只要修改后的字符不等于当前位置上的字符就行了，其他的和删除操作一样。

- 对于添加操作，我们要的后缀是以第 $i$ 位开头的，其他的一样。

这样子对于第一个条件我们就可以满足了，而对于第二个条件，我们可以从小到大枚举字符串编号 $i$，这样子以前出现过的字符串肯定比现在的字符串字典序小。

对于这些数组，我们可以用 `unordered_map` 来寄存 ~~因为用 `map` 会超时~~。

答案为 $\max\limits_{1 \le i \le n} dp_{w_i}$。

代码部分：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2.5e4+10,L=31;
int n,ans;string a[N];
unordered_map<string,int>dp;
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int len=a[i].size();
		a[i]=' '+a[i];
		string pre=" ";
		//s1 是删除操作所得到的字符串；s2 是插入操作所得到的字符串；s3 是添加操作所得到的字符串 
		for(int j=1;j<=len;j++)
		{
			string s1=pre+a[i].substr(j+1,len);
			if(dp.find(s1)!=dp.end()) dp[a[i]]=max(dp[a[i]],dp[s1]);
			for(char k='a';k<='z';k++)
			{
				string s2=pre+k+a[i].substr(j,len),s3=pre+k+a[i].substr(j+1,len);
				if(dp.find(s2)!=dp.end()) dp[a[i]]=max(dp[a[i]],dp[s2]);
				if(dp.find(s3)!=dp.end()) dp[a[i]]=max(dp[a[i]],dp[s3]);
			}
			pre+=a[i][j];
		}
		for(char j='a';j<='z';j++)//注意添加字符添加在末尾的情况
		{
			string s3=pre+j;
			if(dp.find(s3)!=dp.end()) dp[a[i]]=max(dp[a[i]],dp[s3]);
		} 
		dp[a[i]]++;
		ans=max(ans,dp[a[i]]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Avocadooo (赞：0)

### 1.题目类型判断

题中涉及到了多个字符串的操作，且要**判断字符串的变换**，很明显就是一道关于 $ \texttt{Trie} $ 树的题目。

### 2.基本思路

如果对于单词 $ w_i $ ，想要判断 $ w_{i+1} $ 是否可以由它变换得到这个问题，你仍然没有思路，可以先做一下 [P4407 [JSOI2009]电子字典](https://www.luogu.com.cn/problem/P4407) 这道题。

在了解如何判断单词是否**满足变换**后，问题就很简单了。他让我们求单词接龙的最大长度，想到用 DP 来解决。

由于它已经按字典序输入了，那么这个 DP 数组的定义很容易想到：

 $ dp[i] $ 表示以第 $ i $ 个字符串为结尾字符串可以获得的单词接龙最大长度。
 
考虑转移，要想完成单词接龙，肯定要满足当前插入的字符串和之前的字符串满足**单词变换**。所以，在插入新的字符串之前，先在 $ \texttt{Trie} $ 树上看已插入的字符串有哪些与它满足**单词变换**。而当前字符串 $ i $ 的 $ dp[i] $ 值显然就是已插入的与其满足**单词变换**的所有字符串 $ dp[j]+1 $ 的最大值。

最后的结果呢？我们只需要求出以每个单词结尾的单词接龙最大长度最大值即可。

### 3.std代码 ~~（你们最喜欢的）~~

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
#define N 500001
int n,m;
int vst[N];
int vststack[N];
int dp[N];
bool FLAG;
int ans;
string t;
int Len,arr;
int Max(int a,int b)
{
	return a>b?a:b; 
} 
template < typename _TYPE_ , typename _VAL_TYPE_ > 
class Trie
{
	private:
		int Trie_size;
		int ch[N][27];
		int setdown[N];
	public:
		Trie(){ Trie_size=1; }
		int size(){ return Trie_size; }
		void insert(string s,int Lenth)
		{
			int Now=1;
			for(int j=0;j<Lenth;j++)
			{
				int Tos=s[j]-'a';
				if(!ch[Now][Tos]) ch[Now][Tos]=++Trie_size;
				Now=ch[Now][Tos];
			}
			setdown[Now]=arr;
		}
		void search(int Now,int dep,bool Use)
		{
			if(dep==Len && setdown[Now])
			{
				if(Use==false) return;
				else dp[arr]=Max(dp[setdown[Now]]+1,dp[arr]);
				return;
			}
			int Tos=t[dep]-'a';
			if(Use==false)
			{
				if(dep<Len) search(Now,dep+1,true);
				for(int Add=0;Add<26;++Add)
					if(ch[Now][Add])
					{
						search(ch[Now][Add],dep,true);
						if(Add!=Tos) search(ch[Now][Add],dep+1,true);
					}
			}
			if(dep==Len) return;
			if(ch[Now][Tos])
				search(ch[Now][Tos],dep+1,Use);
		}
};
Trie<char,int> s;
int main()
{
	scanf("%d %d",&n,&m);
	for(arr=1;arr<=n;arr++)
	{
		cin>>t;
		Len=t.length();
		dp[arr]=1;
		s.search(1,0,0);
		s.insert(t,t.length());
	}
	int Ans=0;
	for(int i=1;i<=n;i++) Ans=max(Ans,dp[i]);
	printf("%d",Ans); 
}
```

---

## 作者：LinkWish (赞：0)

## 审题
给出 $n$ 个单词，求在符合要求的变换下按字典序排列接龙的最大长度。

其中符合要求的变换有三种：

1.向单词的前面、中间或后面添加一个字母；

2.删除一个字母；

3.将单词中的一个字母变成另一个字母。

## 思路

这道题和 [P4407 [JSOI2009]电子字典](https://www.luogu.com.cn/problem/P4407)很像，都是求一个字符经过一次变换后可以转移到的所有其他字符串。

我们可以使用字典树来记录一个单词是否出现过，然后分类讨论三种变换求出每一个单词可以转移到的所有的单词，最后使用dp求出结果。

## 变换一
向单词的前面、中间或后面添加一个字母。

我们可以枚举每一个位置上添加每一个字母的情况，然后在字典树上查询原来有没有一个单词和这个变换后的单词一样。


其实我们不用真正地在原单词里面加上这一个字母，我们可以在查询时模拟加上了这一个字母，具体实现如下：

```cpp
inline int find1(int pos,int change){
	int now=0;
	for(int i=0;i<llen;i++){
		if(i==pos){
            //如果我们正在查询要添加的那一项，我们就先查询添加的值
			if(!trie[now][change])return 0;
			now=trie[now][change];
		}
		if(!trie[now][ch[i]-'a'])return 0;
		now=trie[now][ch[i]-'a'];
	}
	if(pos==llen){
        //特判添加到末尾的情况
		if(!trie[now][change])return 0;
		now=trie[now][change];
	}
	return is[now];//is数组在这里扮演了两个角色：一是标记这是不是一个结束节点，二是这个单词的编号（后同）
}
for(int i=0;i<=len[x];i++){
//枚举添加的位置（注意：我们需要枚举到字符串的长度+1，因为我们枚举的是添加到每一项的前面，遗漏了在单词末尾添加的情况）
	for(int j=0,v;j<26;j++){//枚举每一个字母
		v=find2(x,i,j);
		if(v)can[x].push_back(v);//can数组记录着这个单词可以变换到的所有单词的编号（后同）
	}
}

```
## 变换二

删除一个字母。

我们只需要枚举每一个位置，并且在查询时跳过那一个位置即可模拟删除了它的情况。具体实现如下：
```cpp
inline int find2(int pos){
	int now=0;
	for(int i=0;i<llen;i++){
		if(i==pos)continue;//如果是要删除的哪一位就跳过
		if(!trie[now][ch[i]-'a'])return 0;
		now=trie[now][ch[i]-'a'];
	}
	return is[now];
}
for(int i=0,v;i<len[x];i++){
	v=find1(x,i);
	if(v)can[x].push_back(v);
}
```
## 变换三
将单词中的一个字母变成另一个字母。

和变换一二一样，我们不需要真改（当然这个变换可以真改），我们只需要在查询到这一位时用变换后的值去查询就达到了修改的效果。具体实现如下：

```cpp
inline int find3(int x,int pos,int change){
	int now=0;
	for(int i=0;i<len[x];i++){
		if(i==pos){//到了修改的位置就用改后的值替换
			if(!trie[now][change])return 0;
			now=trie[now][change];
		}
		else{
			if(!trie[now][ch[x][i]-'a'])return 0;
			now=trie[now][ch[x][i]-'a'];		
		}
	}
	return is[now];
}
for(int i=0;i<len[x];i++){
	for(int j=0,v;j<26;j++){
		v=find3(x,i,j);
		if(v)can[x].push_back(v);
	}
}

```

## 去重

大家有没有发现一个问题，一个单词可能可以由一个单词通过几种不同的方式变换而来，所以我们需要去重。而去重的方式也很简单，建立 vis 数组用来标记这个变换出来的单词是否被当前这个单词变换出来过。

但是问题来了，如果每一次遍历到一个单词都将 vis 数组清零的话时间复杂度会太大，这个时候我有一种常用的做法，就是将 vis 数组设置为 int 类型，里面存放的是上一次被变换出来的时间，而每一次遍历的时间是唯一的，所以不存在误判。具体实现的话就将每一个 find 函数后面的

```return is[now]```

替换为

```
if(is[now]&&vis[now]!=x&&is[now]!=x){//is[now]!=x在这里是为了防止在变换三中变到了自己
	vis[now]=x;
	return is[now];
}
return 0;
```

## dp

这道题的 dp 其实比较好想，题目中数据按字典序排列和答案只能按字典序排列让这道题的 dp 难度大大降低。

设 $dp[i]$ 表示以编号为 $i$ 的单词结尾的最大接龙长度，那么答案就是 $\max{dp[i]}$ 。

动态转移方程为 $dp[i]=\max{dp[j]}$ $(1\leqslant j < i,j \in can[i])$

具体实现如下：
```cpp
for(int i=1;i<=n;i++)
	for(int j=0;j<can[i].size()&&can[i][j]<i;j++)
		dp[i]=max(dp[i],dp[can[i][j]]+1);
int ans=0;
for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
	printf("%d",ans);

```

完整代码如下（转换一和转换二调了下位置）
```cpp
//Linkwish's code
#include<bits/stdc++.h>
using namespace std;
int n,dp[50010];
int trie[500010][26],vis[500010],cnt,len[50010],is[1000010];
char ch[50010][20];
vector<int> can[25010];
inline void insert(int x){
	int now=0;
	for(int i=0;i<len[x];i++){
		if(!trie[now][ch[x][i]-'a'])trie[now][ch[x][i]-'a']=++cnt;
		now=trie[now][ch[x][i]-'a'];
	}
	is[now]=x;
}
inline int find1(int x,int pos){
	int now=0;
	for(int i=0;i<len[x];i++){
		if(i==pos)continue;
		if(!trie[now][ch[x][i]-'a'])return 0;
		now=trie[now][ch[x][i]-'a'];
	}
	if(is[now]&&vis[now]!=x&&is[now]!=x){
		vis[now]=x;
		return is[now];
	}
	return 0;
}
inline int find2(int x,int pos,int change){
	int now=0;
	for(int i=0;i<len[x];i++){
		if(i==pos){
			if(!trie[now][change])return 0;
			now=trie[now][change];
		}
		if(!trie[now][ch[x][i]-'a'])return 0;
		now=trie[now][ch[x][i]-'a'];
	}
	if(pos==len[x]){
		if(!trie[now][change])return 0;
		now=trie[now][change];
	}
	if(is[now]&&vis[now]!=x&&is[now]!=x){
		vis[now]=x;
		return is[now];
	}
	return 0;
}
inline int find3(int x,int pos,int change){
	int now=0;
	for(int i=0;i<len[x];i++){
		if(i==pos){
			if(!trie[now][change])return 0;
			now=trie[now][change];
		}
		else{
			if(!trie[now][ch[x][i]-'a'])return 0;
			now=trie[now][ch[x][i]-'a'];		
		}
	}
	if(is[now]&&vis[now]!=x&&is[now]!=x){
		vis[now]=x;
		return is[now];
	}
	return 0;
}
inline void init(int x){
	for(int i=0,v;i<len[x];i++){
		v=find1(x,i);
		if(v)can[x].push_back(v);
	}
	for(int i=0;i<=len[x];i++){
		for(int j=0,v;j<26;j++){
			v=find2(x,i,j);
			if(v)can[x].push_back(v);
		}
	}
	for(int i=0;i<len[x];i++){
		for(int j=0,v;j<26;j++){
			v=find3(x,i,j);
			if(v)can[x].push_back(v);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		dp[i]=1;
		scanf("%s",ch[i]);
		len[i]=strlen(ch[i]);
		insert(i);
	}
	for(int i=1;i<=n;i++)init(i);
	for(int i=1;i<=n;i++)sort(can[i].begin(),can[i].end());
	for(int i=1;i<=n;i++)
		for(int j=0;j<can[i].size()&&can[i][j]<i;j++)
			dp[i]=max(dp[i],dp[can[i][j]]+1);
	int ans=0;
	for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
	printf("%d",ans);
	return 0;
}
```

## update
1/26：将“...然后在字典树上查询元来有没有一个单词和这个变换后的单词一样。”中的“元来”改正为“原来”。

---


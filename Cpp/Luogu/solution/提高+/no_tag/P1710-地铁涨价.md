# 地铁涨价

## 题目描述

博艾市除了有海底高铁连接中国大陆、台湾与日本，市区里也有很成熟的轨道交通系统。我们可以认为博艾地铁系统是一个无向连通图。博艾有 $N$ 个地铁站，同时有 $M$ 小段地铁连接两个不同的站。

地铁计价方式很简单。从 A 站到 B 站，每经过一小段铁路（连接直接相邻的两个点的一条边），就要收取 $1$ 博艾元。也就是说，从 A 站到 B 站，选择的路径不一样，要价也会不同。

我们认为凡华中学在 $1$ 号地铁站。学生们通过地铁通勤，他们当然知道选择最短路来坐车的话，票价最便宜。

然而博艾地铁公司经营不善，一直亏损，于是他们打算提价。提价一次就是将一小段铁路原来收费 $1$ 元改收 $2$ 元。同一小段的铁路不会多次提价。他们打算提价 $Q$ 次。

学生们知道，如果他们到学校的一条最短路径中的一小段提价了，可以改变路径，使总票价不变。然而随着一条一条的铁路被提价，当居住在某个站附近的学生发现，提价后，没有任何一种方案可以从家到学校的费用和初始费用相等时，就会不满。

现在地铁公司希望知道，对于每一次涨价，有多少个站，学生会因为涨价而不满呢？

## 说明/提示

### 样例解释

```plain
次数 车站2 车站3 车站4 车站5
初始 1     1     2     2
1    1     1     2     2
2    1     2     2     3
3    1     2     2     3
4    2     2     3     3
5    2     2     4     3
```
### 数据范围及约定

- 对于 $20\%$ 的数据 $N \le 100,Q \le 30$。
- 对于 $40\%$ 的数据 $Q \le 30$。
- 对于 $70\%$ 的数据正确的输出结果中，不会有超过 $50$ 种不一样的整数（数据范围剧透解法系列）
- 对于 $100\%$ 的数据 $N \le 100000,Q \le M \le 200000$。

## 样例 #1

### 输入

```
5 6 5
1 2
1 3
4 2
3 2
2 5
5 3
5
2
4
1
3
```

### 输出

```
0
2
2
4
4```

# 题解

## 作者：Scarlet (赞：30)

##转化问题

这里路线涨价明显等同于删边，所以我们可以把问题倒过来思考：

>    **图上依次(倒序)加边，问每个点成为最终图最短路的时间**
##分析

记\*原图\*的点1到达点i的最短路为dis[i]，\*当前状态\*下点1到达点i最短路为d[i]。下面称d[i]==dis[i]的点i为扩展点。


通过分析最短路性质发现，某个点v**新**成为扩展点情况有两个


1. 加边(u,v)更新，且dis[u]==d[u]&&dis[v]==d[u]+1&&**d[v]!=dis[v]**。

2.    邻居u突然成为最终图最短路，且dis[v]==d[u]+1&&**d[v]!=dis[v]**


\_(其实上面是同一种情况XD)\_


重要的是，**每个点只会被更新1次**，体现在了上面的强调处。这是很显然的，因为这题答案是唯一确定的，但这个是降低复杂度的重要条件。


##确定算法


1.    首先把最终图的最短路情况dis[i]求出来。然后重建图，去掉所有待加边。

2.    然后依次加入待加边，检测边的两端是否符合条件1，若符合，则进行深度优先搜索，对新成为扩展点邻居进行条件2判断。

3.    将每次新成为扩展点的数目记录，最后处理出答案。


##复杂度分析


1.    由于边权为1，求dis[]可以用bfs遍历，复杂度为O(n+m)。

2.    加入了q条边，在整个过程2中每个点只会被dfs到一次，所以复杂度为O(n+m+q)。

3.    每一次的答案是新成为扩展点的数目，所以需要一遍前缀和，复杂度为O(q)。


最终复杂度为O(n+m+q)


##代码


```cpp
#include<bits/stdc++.h>
#define maxn 400010
using namespace std;
#define G c=getchar()
inline int read()
{
    int x=0,f=1;char G;
    while(c>57||c<48){if(c=='-')f=-1;G;}
    while(c>47&&c<58)x=x*10+c-48,G;
    return x*f;
}
#define AE(u,v) to[Si]=v,nxt[Si]=idx[u],idx[u]=Si++
int to[maxn],nxt[maxn],idx[maxn],Si;
int n,m,q,dis[maxn],d[maxn];
queue<int>Q;
int vis[maxn],b[maxn];
int E[maxn][2],qq[maxn],ans[maxn],tmp;
void dfs(int u,int fa)
{
    for(int i=idx[u];i+1;i=nxt[i])
        if(to[i]!=fa&&dis[to[i]]==d[u]+1&&dis[to[i]]!=d[to[i]])
        {
            d[to[i]]=d[u]+1;tmp++;
            dfs(to[i],u);
        }
}
void bfs(int s,int dis[])
{
    while(!Q.empty())Q.pop();
    Q.push(s);dis[s]=0;vis[s]=1;
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=idx[u],v;i+1;i=nxt[i])
        {
            if(vis[v=to[i]])continue;
            dis[v]=dis[u]+1;
            Q.push(v);vis[v]=1;
        }
    }
}
int main()
{
    memset(idx,-1,sizeof(idx));
    n=read(),m=read(),q=read();
    for(int i=1;i<=m;i++)
        E[i][0]=read(),E[i][1]=read(),AE(E[i][0],E[i][1]),AE(E[i][1],E[i][0]);
    bfs(1,dis);
    memset(idx,-1,sizeof(idx));Si=0;
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=q;i++)qq[i]=read(),b[qq[i]]=1;
    for(int i=1;i<=m;i++)
        if(!b[i])AE(E[i][0],E[i][1]),AE(E[i][1],E[i][0]);
    bfs(1,d);
    for(int i=q;i>=1;i--)
    {
        int x=qq[i],u=E[x][0],v=E[x][1];tmp=0;
        if(dis[u]==d[u]&&dis[v]==d[u]+1&&d[v]!=dis[v])tmp++,d[v]=dis[v],dfs(v,u);
        swap(u,v);
        if(dis[u]==d[u]&&dis[v]==d[u]+1&&d[v]!=dis[v])tmp++,d[v]=dis[v],dfs(v,u);
        AE(u,v),AE(v,u);
        ans[i]=tmp;
    }
    for(int i=1;i<=q;i++)
        ans[i]+=ans[i-1],printf("%d\n",ans[i]);
}
```

---

## 作者：kkksc03 (赞：22)


题解：

将图从1节点开始，进行bfs，生成一个bfs序的DAG（有向无环图，有点像树）。

我们把“涨价”行为直接认为是删边。

如果某个定点往DAG上面回溯，不能到达1节点，说明没有跟初始值一样的最短路径。

于是我们开始删除一条边。假设这条边是连u->v节点。我们要确定这条边方的子图哪些会因为删了这条边而不能回溯到根节点。

策略是这样的：

使用bfs，将u->v放入队列。

删除u->v。

若v的入度为0：则删了这条边之后，不能回溯到根，记录v是第几条边删除后不能联通的，然后将v->w1，v->w2...v->wn全部放入队列。wi是v可以直接连到且没有连边被删除的节点。

若v的入度不为0：v的入度-=1

然后我们就知道了每个节点在什么时候是不能被访问的。

由于所有边和节点都会被至多访问一次，所以复杂度是线性的。



解法2：DAG上的dp（Claris提供）

dp[x]=max(min(dp[pre],deltime(pre,x)))



---

## 作者：x_liuier (赞：3)

## BB in front

~~用了和机房[神犇](https://www.luogu.org/user/174433)差不多的方法抢走了神犇第二优解记录~~

神犇们可以看完本题解碾压本蒟蒻的记录,QAQ

想要更~~不~~好的阅读体验，请点击[这里](https://www.luogu.org/blog/x-liuier/solution-p1710)

## 题目大意

在$Q$个时间段内，每个时间段内从**当前图**上割去一条边。

问，在时刻$i(1 \leq i \leq Q)$时，**当前图**上有多少个点到源点$s=1$的最短距离与**原图**不同。

## solution

假设单个点$t$到源点$s=1$的最短路径组成的图为图$G$，求出在图$G$上$s$到$t$没有路径相连的时间，记作$time[t]$。

则第$i(1 \leq i \leq Q)$个时刻的答案就是$\sum_{i=2}^n(time[i] \leq q)$，即满足条件$time[i] \leq q$的点的数量。

而关于$time[i]$的求法，利用$dp$可以求得：

>PS：为了方便处理，假设没被切断的边在时刻$+\infty$被切断。
>
>设$cut(u, v)$为边$(u$->$v)$被切断的时刻。
>
>设点$u$与点$v$直接相连，且点$v$到源点$1$的某条最短路经过边$(v$->$u)$。
>
> 1. 点$v$经过点$u$的最短路路径被切断的时刻$=min(time[u], cut(u, v))$
>
> 2. 则$time[v]=max\{min(time[u], cut(u, v))\}$

而在用$bfs$(边权为1)求最短路的过程中，因为边权为1，所以在第一次更新点$v$的距离$dis[v]$时，$dis[v]$即为最短距离。

以上可得
> 1. $time[v]$只与$min(time[u], cut(u, v))$有关。
>
> 2. 没必要求出每个点对应的图$G$再计算$time$，只要确定边$(u$->$v)$是否是最短路径，便可判断该点$u$是否在点$v$对应的图$G$上，进而通过$time[u]$来得到$time[v]$。

因此，在$bfs$同时，就可以通过$time[u]$求出$time[v]$啦！(qwq)

不懂可以直接看代码(PS:被我删掉了[部分(namespace)](https://www.luogu.org/paste/x1w7luyf)，方便看主体，不影响神犇们看代码)

## Code：

~~不要吐槽码风(求求各路神犇嘴下留情QAQ)~~

```cpp
#include <cstring>
#include <queue>
using namespace tool;
using namespace io;
const int MAX_N = 1e5;
const int MAX_M = 2e5;
const int MAX_Q = 2e5;
const int INF = 0x3f3f3f3f;

// 这里用cst[]代替time[]
int n, m, q, cst[MAX_N], dis[MAX_N], ans[MAX_Q+1];
edge *E[MAX_N], pool[MAX_M<<1], *iter=pool-1;

inline void add_edge(int u, int v) {
  *++iter=(edge){v, INF, E[u]}; E[u]=iter;
  *++iter=(edge){u, INF, E[v]}; E[v]=iter;
}

inline void dij() {
  memset(dis, 0x3f, sizeof(dis)); cst[0]=INF;
  std::queue<int> que; que.push(dis[0]=0);
  int u, v;
  while (!que.empty()) {
    u = que.front(); que.pop();
    for (edge *e=E[u]; e!=NULL; e=e->nt) {
      if (dis[v=e->v]==INF) {dis[v] = dis[u] + 1; que.push(v);}
      if (dis[v]-dis[u]==1) cmax(cst[v], min(cst[u], e->t));
      // void cmax(i, j) {i = max(i, j);}
    }
  }
}

inline void solve() {
  dij(); // ~~三行solve~~ writeln():输出并换行
  for (int i=1; i<n; ++i) if (cst[i]<=q) ++ans[cst[i]];
  for (int i=1; i<=q; ++i) writeln(ans[i] += ans[i-1]);
}

int main() {
  // io_开头的可无视, read():输入
  io_begin("P1710", true);
  read(n); read(m); read(q);
  for (int i=0, u, v; i<m; ++i) {
    read(u); read(v);
    add_edge(--u, --v);
  }
  for (int i=0, in; i<q; ++i) {
    read(in); pool[(in<<1)-2].t = i+1;
    pool[(in<<1)-1].t = i+1;
  } solve(); io_end(); return 0;
}

```

## summary

什么，看懂题解后你居然没有去膜提供思路的[神犇](https://www.luogu.org/user/174433)？不要犹豫了，快去膜啊！

---

## 作者：Fading (赞：2)

这是我们的模拟赛题，我成功切掉此题成为全场唯一一个$AC$（有一个巨佬数组开小了）

而且就我是在线的！其他人都是离线。。。

首先一条边改变了权值可以当成断边处理。

考虑建出最短路树。但是一棵树边断掉了，可能还有另一条最短路怎么办呢？

那就建出“最短路图”，满足$1$号节点到每一个节点的任意一条路径都是一条最短路！由于边权都是$1$，这个是可以直接建出来的。

而且这个“最短路图”是一个$DAG!!!$

断掉一条边，就在最短路图上对应终点的入度减一，如果入度减为$0$，那么这个点就不能到达了，再把这个点的出边全部给删掉，继续判断这个点减后入度是否为$0$，继续执行。这样可以用类似于拓扑排序的方法实现。

复杂度为$O(N+M+Q)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
	static char now[1<<16],*S,*T;
	if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
	return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int dep[1000001],Q,n,m,head[1000001],tot,heade[1000001],tote;
struct edge{
	int from,to,nxt,ID;
}g[1000001],e[1000001];
inline void made(int from,int to){
	g[++tot].to=to;g[tot].nxt=head[from];head[from]=tot;
	g[tot].from=from;
}
int indo[1000001];
inline void maded(int from,int to){
	e[++tote].to=to;e[tote].nxt=heade[from];heade[from]=tote;
	e[tote].from=from;indo[to]++;
}
int vis[1000001];
inline void bfs(){
	for (int i=1;i<=n;i++) dep[i]=999999999;
	dep[1]=0;
	queue<int> dl;
	while (!dl.empty()) dl.pop();
	dl.push(1);
	while (!dl.empty()){
		int u=dl.front();dl.pop();
		for (int i=head[u];i;i=g[i].nxt){
			int v=g[i].to;
			if (dep[v]==999999999)
				dep[v]=dep[u]+1,dl.push(v);
		}
	}
	for (int i=1;i<=tot;i++){
		int u=g[i].from,v=g[i].to;
		if (dep[u]+1==dep[v]) maded(u,v),g[i].ID=tote;
	}
}
signed main(){
	n=read(),m=read(),Q=read();
	for (int i=1;i<=m;i++){
		int x=read(),y=read();made(x,y);made(y,x);
	}
	bfs();
	int ANS=0;
	queue<int> dl;
	while (Q--){
		int x=read();
		int ed=0;
		if (g[2*x].ID) ed=g[2*x].ID;
		else if (g[2*x-1].ID) ed=g[2*x-1].ID;
		if (ed&&!vis[ed]){
			indo[e[ed].to]--;vis[ed]=1;
			if (indo[e[ed].to]<=0){
				while (!dl.empty()) dl.pop();
				dl.push(e[ed].to);
				while (!dl.empty()){
					int u=dl.front();dl.pop();
					ANS++;
					for (int i=heade[u];i;i=e[i].nxt){
						if (vis[i]) continue;
						vis[i]=1;
						if ((--indo[e[i].to])<=0){
							dl.push(e[i].to);
						}
					}
				}
			}
		}
		printf("%d\n",ANS);
	}
	return 0;
}

```

---

## 作者：沉辰 (赞：2)

解：暴力 20  

正解:(发现其实好多的题删边删点都是倒序来写的)  

考虑倒序加边。  

令d1[i]  为全图中  1 -> i  的最短距离 

d2[i]   为删除掉所有的边之后  1 -> i  的最短距离,不

连通则为inf    

现在考虑什么样才算做不合法的点呢？  

即:如果再加这条边(u,v,c)之前,  

d2[v]>d1[v]  && d1[u]==d2[u]  && d1[v]==d1[u]+1 

那么v就是不满的学生    

即v的d1[]是通过u得到的,删了这条边之后,v自然就不满了

然后再去更新其他与之相关的点   

至于删边加边操作，用个数组记一下就好。
[代码](http://www.cnblogs.com/adelalove/p/8507123.html)

（如果这篇题解通过了能不能告诉我为什么这个打"enter"不管用）

---

## 作者：Erotate (赞：1)

以前用 vector 这次试试听取机房某神犇的意见，用链式前向星试试。

------------
首先，要对比涨价前后的关系，显然我们需要先记录下初始花费。所以我们先建一张图，再直接跑一遍模板 Dijkstra，再用 dis 数组记录下从原点到每个城市的花费。

接着，我们把图清空。因为每涨价一条边都会有多出来的学生不满意，所以考虑重新把不会涨价的边先建成一个图，再跑一遍模板 Dijkstra，用 d 数组记录下当前再原点到每个城市的花费,以后用来更新和比较大小。

然后，把会涨价的边倒序一条一条的加进去。把边加进去后，和这条边有关的节点的花费肯定会改变，所以每一次加边后对和这条边有关联的点的花费进行更新，即更新 d 数组。假如更新后，原点的花费比原来高，那就更新答案。

最后，因为如果第 i 年有学生不满意，那这些不满意的学生在第 i+1 年也会不满意。所以，对于第 i 年，要累计1到 i 年不满意的人数做为最终答案。

**注意：** 每一个节点只会被更新一次

------------
捋一下思路：

1. 先把原图建好，跑一遍 Dijkstra，用 dis 记录下原点到各个点的花费。
2. 把原图清空。
3. 再跑一遍 Dijkstra，用 d 数组记录下当前再原点到每个城市的花费
4. 倒序加边，更新有关联的点
5. 统计答案

------------
代码：
```cpp
#include<bits/stdc++.h>
#define N 400010
#define add(u,v) to[lhr]=v,nxt[lhr]=head[u],head[u]=lhr++;
using namespace std;
queue<int>Q;
int n,m,q,tmp,lhr,qq[N];
int dis[N],vis[N],d[N],b[N];
int is[N],ans[N],to[N],nxt[N],head[N],e[N][2];
void dfs(int now,int f){//dfs用来更新与当前加入的边的两个端点有关联的点
	for(int i=head[now];i+1;i=nxt[i])
        if(to[i]!=f && dis[to[i]]==d[now]+1 && dis[to[i]]!=d[to[i]]){
            d[to[i]]=d[now]+1;
			tmp++;
            dfs(to[i],now);
        }
}
void djstl(int s,int dis[]){//没有负权边，模板Dijkstra即可
	while(!Q.empty()) Q.pop();
	Q.push(s);
	dis[s]=0;
	vis[s]=1;
	while(!Q.empty()){
		int u=Q.front();
		Q.pop();
		for(int i=head[u],v;i+1;i=nxt[i]){
			if(vis[v=to[i]]) continue;
			dis[v]=dis[u]+1;
			Q.push(v);
			vis[v]=1;
		}
	}
}
int main(){
	memset(head,-1,sizeof head);//初始原图用数组d来储存距离
	cin>>n>>m>>q;
	for(int i=1;i<=m;++i){
		cin>>e[i][0]>>e[i][1];
		add(e[i][0],e[i][1]);
		add(e[i][1],e[i][0]);
	}
	djstl(1,dis);
	memset(head,-1,sizeof head);//清空数组，准备依次加边
	lhr=0;
	memset(vis,0,sizeof vis);
	for(int i=1;i<=q;++i){//这里是把不用涨价的边先建一个图
		cin>>qq[i];
		is[qq[i]]=1;
	}
	for(int i=1;i<=m;++i)
		if(!is[i]){
			add(e[i][0],e[i][1]);
			add(e[i][1],e[i][0]);
		}
	djstl(1,d);
	for(int i=q;i>=1;--i){
		int x=qq[i],u=e[x][0],v=e[x][1];
		tmp=0;
		if(dis[u]==d[u] && dis[v]==d[u]+1 && d[v]!=dis[v]){//如果这个点的边没有被涨价，并没有更新过，开始更新
			tmp++;
			d[v]=dis[v];
			dfs(v,u);
		}
        swap(u,v);
        if(dis[u]==d[u] && dis[v]==d[u]+1 && d[v]!=dis[v]){
        	tmp++;
			d[v]=dis[v];
			dfs(v,u);
		}
       add(u,v);//加边，统计答案
       add(v,u);
	   ans[i]=tmp;
	}
	for(int i=1;i<=q;++i){//统计答案
		ans[i]+=ans[i-1];
		cout<<ans[i]<<endl;
	}
	return 0;
}
```



---

## 作者：__stdcall (赞：1)

我太辣鸡了，看了最下面的kkksc03的题解，主要考点就是图的建模

但是kkksc03没放代码，我就放上来一份吧







```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cmath>
#include <algorithm>
#include <vector>
#include <cctype>
using namespace std;
struct IO {
    static const int BUFSZ = 500000;
    char buf[BUFSZ]; int idx;
    IO() { idx = BUFSZ; }
    char getch() {
        if( idx == BUFSZ ) {
            fread( buf, 1, BUFSZ, stdin );
            idx = 0;
        }
        return buf[idx++];
    }
    int getint() {
        int num = 0; char ch;
        while( isspace(ch=getch()) );
        do {
            num *= 10; num += ch-'0';
        }while( !isspace(ch=getch()) );
        return num;
    }
}io;
struct Graph {
    int head[100010],to[400010],nxt[400010],idx;
    Graph() { idx = 0; memset( head, -1, sizeof(head) ); }
    void addedge( int u, int v ) {
        to[idx] = v; nxt[idx] = head[u];
        head[u] = idx; ++idx;
    }
}g;
int n,m,q;
int from[200010],to[200010];
int used[200010]; // 0表示不使用，1表示终点是from，2表示终点是to
int dist[100010];
int in[100010];
queue<int> bfsq;
void bfs() {
    memset( in, 0, sizeof(in) );
    memset( dist, -1, sizeof(dist) );
    bfsq.push(1); dist[1] = 0;
    while( !bfsq.empty() ) {
        int u = bfsq.front(); bfsq.pop();
        for( int p = g.head[u]; p != -1; p = g.nxt[p] ) {
            int v = g.to[p];
            if( dist[v] >= 0 && dist[v] == dist[u]+1 ) { // u->v是最短路中的一条边
                in[v]++;
                if( to[p/2] == v ) used[p/2] = 2; // 路的编号即p/2+1
                else used[p/2] = 1;
            }
            if( dist[v] >= 0 && dist[v] > dist[u]+1 ) { // u->v不是最短路的一条边
                used[p/2] = 0;
            }
            if( dist[v] == -1 ) {
                dist[v] = dist[u]+1; in[v]++; bfsq.push(v);
                if( to[p/2] == v ) used[p/2] = 2;
                else used[p/2] = 1;
            }
        }
    }
}
int main() {
    n = io.getint(); m = io.getint(); q = io.getint();
    for( int i = 0; i < m; ++i ) {
        int u,v; u = io.getint(); v = io.getint();
        from[i] = u; to[i] = v;
        g.addedge(u,v); g.addedge(v,u);
    }
    bfs();
    int ans = 0;
    for( int i = 0; i < q; ++i ) {
        int id; id = io.getint();
        if( used[id-1] == 0 ) {
            printf( "%d\n", ans );
        }
        else {
            int v = used[id-1] == 1 ? from[id-1] : to[id-1];
            used[id-1] = 0; // 删边
            if( --in[v] == 0 ) {
                queue<int> topoq; topoq.push(v);
                while( !topoq.empty() ) {
                    int u = topoq.front(); topoq.pop();
                    ++ans;
                    for( int p = g.head[u]; p != -1; p = g.nxt[p] ) if( used[p/2] ) {
                        int v = g.to[p]; used[p/2] = 0;
                        if( --in[v] == 0 ) topoq.push(v);
                    }
                }
            }
            printf( "%d\n", ans );
        }
    }
    return 0;
}

```

---

## 作者：翠竹叶飞 (赞：1)

30分算法：Q次SPFA即可。

但是如果要满分，Q次找最短路显然需要O(n)的算法。

如果只是顺序地做，似乎没有什么优化，因为一个点的最短路不止一条！

因此，我们想到了逆序的方法。因为是最短路，所以涨价后的边不可能构成一条权值与当初不变的路，所以果断删边。

将Q条边先删掉，然后一条一条地加边。

这样，如果某个点已经最短就不要管，当且仅当一个点能够通过加的边来构成最短，向周围延伸。这样时间为O(m+n)，总时间为O(m+n+q)

更新方法：若d[t1]==dis[t1] && d[t2]!=dis[t2] && d[t1]+1==dis[t2]，则通过t1更新t2

```cpp
#include<cstdio>
#include<cstring>
#define MAXN 100001
#define MAXM 200001
int i,j,k,n,m,Q;
int a[MAXM], b[MAXM], ans[MAXM];
bool judge[MAXM];
int seq[MAXM], head[MAXN], edgenum;
struct Edge
{
    int to, next;
} edge[MAXM << 1];
int dis[MAXN], d[MAXN];
int q[MAXN];
bool exist[MAXN];
void addedge(int u, int v)
{
    edge[++edgenum].to=v;
    edge[edgenum].next=head[u];
    head[u]=edgenum;
}
void cutedge(int u)
{
    head[u]=edge[edgenum--].next;
}
void getpath(int dis[])
{
    memset(exist,0,sizeof(exist));
    int f=0, r=0, u;
    dis[1]=0; q[0]=1; exist[1]=1;
    while (f<=r)
    {
        u = q[f++];
        for (i = head[u]; i != 0; i = edge[i].next)
            if (exist[edge[i].to] == 0)
            {
                exist[edge[i].to]=1;
                q[++r]=edge[i].to;
                dis[edge[i].to]=dis[u]+1;
            }
    }
}
int dfs(int u)
{
    d[u]=dis[u];
    int res=1;
    for (int i=head[u]; i!=0; i=edge[i].next)
        if (d[edge[i].to] != dis[edge[i].to] && d[u]+1==dis[edge[i].to])
            res+=dfs(edge[i].to);
    return res;
}
int main()
{
    memset(d,0x7f7f7f7f,sizeof(d));
    scanf("%d%d%d",&n,&m,&Q);
    for (i=1; i<=m; i++)
        scanf("%d%d",&a[i],&b[i]);
    for (j=1; j<=Q; j++)
    {
        scanf("%d",&seq[j]);
        judge[seq[j]]=1;
    }
    for (i=1; i<=m; i++)
        if (judge[i] == 0)
        {
            addedge(a[i],b[i]);
            addedge(b[i],a[i]);
        }
    for (i=1; i<=Q; i++)
    {
        addedge(a[seq[i]],b[seq[i]]);
        addedge(b[seq[i]],a[seq[i]]);
    }
    getpath(dis);
    for (i=Q; i>=1; i--)
    {
        cutedge(b[seq[i]]);
        cutedge(a[seq[i]]);
    }
    getpath(d); //初始化最短路dis与现在的最短d 
    for (i=1; i<=n; i++)
        if (d[i]!=dis[i])
            ans[Q]++;
    for (i=Q; i>1; i--)
    {
        int t1=a[seq[i]], t2=b[seq[i]];
        addedge(t1,t2);
        addedge(t2,t1);
        int num=0;
        if (d[t1]==dis[t1] && d[t2]!=dis[t2] && d[t1]+1==dis[t2]) 
            num=dfs(t2);
        if (d[t2]==dis[t2] && d[t1]!=dis[t1] && d[t2]+1==dis[t1]) 
            num=dfs(t1);
        ans[i-1]=ans[i]-num;
    }
    for (i=1; i<=Q; i++)
        printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：LVYOUYW (赞：1)

这道题是一道图论题，题目的意思是每次删除一条边，询问当前有多少点与1号节点的最短路的值与未删边之前不同。首先我们一定是求出原图的最短路，由于我们可以默认边权是1，于是我们可以BFS，这样我们就能够得到一张“最短路图”，所谓最短路图就是说对于一条边（u，v），我们只走dis[v]=dis[u]+1的边，这样如果删除的边不是最短路图上的边，对其他点是没有任何影响的，那我们考虑如果删除最短路图上的边，只要这条边的端点还在最短路图中能被1号点访问到，那么它的最短路一定不会变化，那我们怎么维护呢，感觉正着做很不好搞，因为删除一条边后，即使它的两端点不与1连通，它的两端点的点也可能与1连通，我们考虑正难则反，离线处理，将删边变成加边，维护一个bz数组表示每个点是否已经和1连通，这样，每加进一条边，我们判断它能否将1与边的出点连通，如果连通，我们就从这条边的出点DFS，将所有bz[i]=0的点变成1，对于每个bz[i]=1的点，我们不再进行DFS，这样就保证了每个点只被访问1次，也就保证了复杂度是线性的。









```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 400005
int n,m,q,l=1,w=0;
int pre[maxn],other[maxn],last[maxn];
int pre1[maxn],other1[maxn],last1[maxn];
int dis[maxn],que[maxn],ans[maxn],query[maxn],cnt;
bool vis[maxn],flag[maxn],pd[maxn],bj[maxn];
struct edge
{
    int fr,to;    
}e[maxn];
int read(void)
{
    char ch=getchar();
    int x=0;
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') 
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
void connect(int x,int y)
{
    l++;
    pre[l]=last[x];
    last[x]=l;
    other[l]=y;    
}
void connect1(int x,int y)
{
    w++;
    pre1[w]=last1[x];    
    last1[x]=w;
    other1[w]=y;
}
void pre_bfs(void) 
{
    int h=1,t=1;
    vis[1]=1;que[1]=1;
    while (h<=t) 
    {
        int u=que[h];h++;
        for (int p=last[u];p;p=pre[p]) 
        {
            int v=other[p];
            if (vis[v]) continue;
            dis[v]=dis[u]+1;
            que[++t]=v;    
            vis[v]=1;
        }
    }
}
void bfs(void)
{
    memset(vis,0,sizeof vis);
    vis[1]=1;que[1]=1;
    int h=1,t=1;
    while (h<=t) 
    {
        int u=que[h];h++;
        for (int p=last[u];p;p=pre[p]) 
        {
            int v=other[p];
            if (dis[v]==dis[u]+1) flag[p/2]=1;
            if (vis[v]) continue;
            que[++t]=v;
            vis[v]=1;
        }
    }
}
void dfs(int u)
{
    cnt++;bj[u]=1;
    for (int p=last1[u];p;p=pre1[p]) 
    {
        int v=other1[p];
        if (bj[v]) continue;
        dfs(v);
    }
}
int main()
{
    //scanf("%d%d%d",&n,&m,&q);
    n=read();m=read();q=read();
    for (int i=1;i<=m;i++) 
    {
        int a,b;
        //scanf("%d%d",&a,&b);
        a=read();b=read();
        e[i].fr=a;e[i].to=b;
        connect(a,b);connect(b,a);    
    }
    pre_bfs();
    bfs();
    for (int i=1;i<=q;i++) 
    {
        int a;
        //scanf("%d",&a);
        a=read();
        pd[a]=1;query[i]=a;
    }
    for (int i=1;i<=m;i++) 
        if (dis[e[i].fr]>dis[e[i].to]) swap(e[i].fr,e[i].to);
    bj[1]=1;cnt=1;
    for (int i=1;i<=m;i++) 
        if (!pd[i]&&flag[i]) 
        {
            if (bj[e[i].fr]&&bj[e[i].to]) continue;
            connect1(e[i].fr,e[i].to);
            if (bj[e[i].fr]) dfs(e[i].to);    
        }
    ans[q]=n-cnt;
    for (int i=q-1;i>=1;i--) 
    {
        int num=query[i+1];
        if ((!(bj[e[num].fr]&&bj[e[num].to]))&&flag[num]) connect1(e[num].fr,e[num].to);
        if (bj[e[num].fr]&&flag[num]&&!bj[e[num].to]) dfs(e[num].to);
        ans[i]=n-cnt;    
    }
    for (int i=1;i<=q;i++) printf("%d\n",ans[i]);
    return 0;    
}
```

---

## 作者：Vacuum (赞：0)

Orz lcb 大佬

反正就是反向加边(也叫时间倒流) 每次从加边的两个端点跑dfs dfs是部分dfs 加起来一共会跑整个图一遍 所以复杂度很低。。。。。。

但是spfa很慢？smg

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define maxn 121020
#define maxs 201201
#define INF 1000000007
#define pii pair<int, int>
using namespace std;
struct edge{
    int from, to, next, w;
}e[maxn * 4], es[maxn * 4];
int n, m, k, tot = 1, cnt = 0, tots = 1;
int first[maxn], dist[maxn], q[maxn], a[maxs], s[maxs]; 
pii c[maxs];
int firsts[maxn];
bool vis[maxs];
void add(int x, int y){
    e[++tot].from = x;
    e[tot].to = y;
    e[tot].next = first[x];
    first[x] = tot;
}
void adds(int x, int y){
    es[++tots].from = x;
    es[tots].to = y;
    es[tots].next = firsts[x];
    firsts[x] = tots;
}
void spfa(int x){
    int head = 0, tail = 1;
    for (int i = 1; i <= n; i++)    dist[i] = INF;
    dist[1] = 0;
    memset(vis, 0, sizeof(vis));
    q[1] = x;    
    while (head < tail){
        head = (head + 1) % n;
        int u = q[head];
        vis[u] = 1;
        for (int i = firsts[u]; i; i = es[i].next){
            int v = es[i].to;
            if (dist[v] > dist[u] + 1){
                dist[v] = dist[u] + 1;
                 if (!vis[v])    {
                     tail = (tail + 1) % n;
                     q[tail] = v;
                     vis[v] = 1;
                 }
            }    
        }
        vis[u] = 0;
    }
}
void dfs(int u, int dep){
    for (int i = first[u]; i; i = e[i].next){
        int v = e[i].to;
        if (!vis[v] && dep + 1 == dist[v]){
            cnt++;
            vis[v] = 1;
            dfs(v, dep + 1);
        }
    }
}
int main(){
    scanf("%d%d%d", &n, &m, &k);
    int x, y;
    for (int i = 1; i <= m; i++){
        scanf("%d%d", &x, &y); 
        c[i] = make_pair(x, y);
        adds(x, y);
        adds(y, x);
    }
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= k; i++){    
        scanf("%d", &a[i]);
        vis[a[i]] = 1;
    }
    for (int i = 1; i <= m; i++){
        if (!vis[i])    {
            x = c[i].first, y = c[i].second;
            add(x, y);
            add(y, x);
        }
    }
    memset(vis, 0, sizeof(vis));
    spfa(1);
    memset(vis, 0, sizeof(vis));
    vis[1] = 1;
    dfs(1, 0);
    for (int i = k; i > 0; i--){    
           s[i] = n - cnt - 1;
        x = c[a[i]].first, y = c[a[i]].second;
        add(x, y), add(y, x);
        if (vis[x])    dfs(x, dist[x]);
        else if (vis[y])    dfs(y, dist[y]);
    }
    for (int i = 1; i <= k; i++)    printf("%d\n", s[i]);
    return 0;
}
Orz jif Auzs
```

---


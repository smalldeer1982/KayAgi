# 染色的立方体

## 题目描述

小胖最近迷上了3D物体，尤其是立方体。他手里有很多个立方体，他想让所有的立方体全都长得一样，所以他决定给某些立方体的表面重涂颜色，使得所有的立方体完全相同。但是小胖是很懒的，他想知道最少涂多少次颜色，可以让所有立方体完全相同。


## 样例 #1

### 输入

```
3
scarlet green blue yellow magenta cyan
blue pink green magenta cyan lemon
purple red blue yellow cyan green
2
red green blue yellow magenta cyan
cyan green blue yellow magenta red
2
red green gray gray magenta cyan
cyan green gray gray magenta red
2
red green blue yellow magenta cyan
magenta red blue yellow cyan green
3
red green blue yellow magenta cyan
cyan green hlue yellow magenta red
magenta red blue yellow cyan green
3
blue green green green green blue
green blue blue green green green
green green green green green sea-green
3
red yellow red yellow red yellow
red red yellow yellow red yellow
red red red red red red
4
violet violet salmon salmon salmon salmon
violet salmon salmon salmon salmon violet
violet violet salmon salmon violet violet
violet violet violet violet salmon salmon
1
red green hlue yellow magenta cyan
4
magenta pink red scarlet vermilion wine-red
aquamarine blue cyan indigo sky-blue turciuoise-blue
blond cream chrome-yellow lemon olive yellow
chrome-green emerald-green green olive vilidian sky-blue
0```

### 输出

```
4
2
0
0
2
3
4
4
0
16```

# 题解

## 作者：「QQ红包」 (赞：7)

刘汝佳的训练指南上的一道题，基本上是暴搜

24种方式打表

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
int qp[24][6] = 
{
{2, 1, 5, 0, 4, 3},
{2, 0, 1, 4, 5, 3},
{2, 4, 0, 5, 1, 3},
{2, 5, 4, 1, 0, 3},
{4, 2, 5, 0, 3, 1},
{5, 2, 1, 4, 3, 0},
{1, 2, 0, 5, 3, 4},
{0, 2, 4, 1, 3, 5},
{0, 1, 2, 3, 4, 5},
{4, 0, 2, 3, 5, 1},
{5, 4, 2, 3, 1, 0},
{1, 5, 2, 3, 0, 4},
{5, 1, 3, 2, 4, 0},
{1, 0, 3, 2, 5, 4},
{0, 4, 3, 2, 1, 5},
{4, 5, 3, 2, 0, 1},
{1, 3, 5, 0, 2, 4},
{0, 3, 1, 4, 2, 5},
{4, 3, 0, 5, 2, 1},
{5, 3, 4, 1, 2, 0},
{3, 4, 5, 0, 1, 2},
{3, 5, 1, 4, 0, 2},
{3, 1, 0, 5, 4, 2},
{3, 0, 4, 1, 5, 2},
};
map<string,int> name;
int d;//颜色编号 
int n,i,j;
char ch[26];
int ans;
int a[5][7];//存原本颜色 
int r[5];//存每个立方体用的姿态编号 
int co[5][7];
int sum[25];
int maxx;
void check()
{
    for (int ii=0;ii<n;ii++)
        for (int jj=0;jj<6;jj++)
        {
            co[ii][qp[r[ii]][jj]]=a[ii][jj]; 
        }
    int t=0;
    for (int jj=0;jj<6;jj++)
    {
        memset(sum,0,sizeof(sum));//清空
        maxx=0;
        for (int ii=0;ii<n;ii++)
        {
            sum[co[ii][jj]]++;
            maxx=max(sum[co[ii][jj]],maxx);
        }
        t=t+(n-maxx);
    }
    ans=min(t,ans);
} 
void dfs(int x)
{
    if (x==n) 
    {
        check();//搜完了
        return;
    }
    else 
    for (int ii=0;ii<24;ii++)//继续搜 
    {
        r[x]=ii;
        dfs(x+1);
    } 
    return;
}
int main()
{
    while (scanf("%d",&n)!=EOF)
    {
        name.clear();
        d=0;
        if (n==0) return 0;
        for (i=0;i<n;i++)
            for (j=0;j<6;j++)
            {
                scanf("%s",ch);
                if (name[ch]==0)
                {
                    d++;
                    name[ch]=d;
                    a[i][j]=d;//第i个立方体第j个面 颜色 标号 
                } else a[i][j]=name[ch];
            }
        ans=n*6;//最大所有的都涂嘛
        r[0]=0;//0不旋转
        dfs(1); 
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Sparrow_hmm (赞：4)

## 题目描述：
### [P1780 题目传送门](https://www.luogu.com.cn/problem/P1780)
## 算法思路：
~~震惊，我算法复杂度白学了。~~

这是一道贪心题。

#### 所用算法：
搜索和贪心。（申请添加**贪心**和**搜索**两个标签）

1. 先~~打表~~枚举所有骰子旋转之后的形态，因为第一个骰子不需要动，所以单个时间复杂度约为 $O(24^{n})$（事实上只要枚举两个面就可以确定一个骰子的形态）。

2. 在~~打表~~枚举完形态之后，贪心给上下左右前后 $6$ 个面每个面单独染成同一种颜色。所以时间总复杂度约为 $O(n25^{n})$。

关于爆搜：没啥好说，递归入门也能打。

关于贪心：枚举看能不能找到匹配度最高的位置，因为**匹配度越高，需要再涂的面越少**，所以**找到匹配度最高的位置，意味着答案一定最小**。
## 蒟蒻の AC 代码
[AC 记录](https://www.luogu.com.cn/record/123339851)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,c[4][6],nc[4][6],ans;
const int t[24][6]=
	{{0,1,2,3,4,5},
     {0,2,4,1,3,5},
     {0,4,3,2,1,5},
     {0,3,1,4,2,5},
     {2,0,1,4,5,3},
     {2,1,5,0,4,3},
     {2,4,0,5,1,3},
     {2,5,4,1,0,3},
     {1,0,3,2,5,4},
     {1,2,0,5,3,4},
     {1,3,5,0,2,4},
     {1,5,2,3,0,4},
     {3,0,4,1,5,2},
     {3,1,0,5,4,2},
     {3,4,5,0,1,2},
     {3,5,1,4,0,2},
     {4,0,2,3,5,1},
     {4,5,3,2,0,1},
     {4,3,0,5,2,1},
     {4,2,5,0,3,1},
     {5,1,3,2,4,0},
     {5,2,1,4,3,0},
     {5,3,4,1,2,0},
     {5,4,2,3,1,0}};//状态表 
void work(int dep)
{
	if(dep==n)
	{
		int tmp=0,col[24];
		for(int i=0;i<6;i++)//贪心染色
		{
			for(int j=0;j<24;j++)col[j]=0;
			for(int j=0;j<n;j++)col[nc[j][i]]++;
			int max_c=0;
			for(int j=1;j<24;j++)
			if(col[j]>col[max_c])
			max_c=j;
			for(int j=0;j<n;j++)
			if(nc[j][i]!=max_c)tmp++;
		}
		if(tmp<ans)ans=tmp;
		return;
	}
	for(int i=0;i<24;i++)//枚举状态
	{
		for(int j=0;j<6;j++)
		nc[dep][j]=c[dep][t[i][j]];
		work(dep+1);
	}
}
int main()
{
//	freopen("cubes.in","r",stdin);
//	freopen("cubes.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	while(1)
	{
		ans=100;
		cin>>n; 
		if(!n)return 0;
		int tot=0;
		char s[4][6][100],str[24][100];
		for(int i=0;i<n;i++)
		for(int j=0;j<6;j++)
		{
			cin>>s[i][j];
			strcpy(str[tot++],s[i][j]);
		}
		for(int i=0;i<n;i++)
		for(int j=0;j<6;j++)
		{
			int k;
			for(k=0;k<tot;k++)
			if(!strcmp(str[k],s[i][j]))break;
			c[i][j]=k;//预处理
		}
		for(int i=0;i<6;i++)nc[0][i]=c[0][i];
		work(1);
		cout<<ans<<'\n';
	}
	return 0;
}
```
## 总结：
~~打表出奇迹，爆搜拿省一！~~

### 贪心算法好！
 

---

## 作者：xianxi (赞：1)

# 赛时经历

赛时没有注意复杂度，以为暴力搜索会超时，于是喜提爆零。

# 思路

暴力搜索加贪心。

## 暴力搜索部分

### 复杂度证明

大家应该都玩过骰子吧，玩久了就会发现，一个骰子如果分出方向的话，一共有 $24$ 种摆放方法。

如何证明？

用排列组合，我们可以假定 $1$ 号面的朝向不动，可将与 $1$ 号面相邻的 4 个面进行旋转，则有 4 种可能；而 $1$ 号面一共有 6 个朝向，则可得一共有 $4 \times 6 = 24$ 种摆放可能。

由题意得立方体数量 $1 \le n \le 4$，则最多可能情况有 $24^4 = 331776$ 完全不会超时。

### 代码片段

我们可以通过打表列出立方体的 $24$ 种变换方式，这样在变换时，可通过数组进行变换。
以下给出变换数组：

```cpp
int ch[24][6]={
{2,1,5,0,4,3},
{2,0,1,4,5,3},
{2,4,0,5,1,3},
{2,5,4,1,0,3},
{4,2,5,0,3,1},
{5,2,1,4,3,0},
{1,2,0,5,3,4},
{0,2,4,1,3,5},
{0,1,2,3,4,5},
{4,0,2,3,5,1},
{5,4,2,3,1,0},
{1,5,2,3,0,4},
{5,1,3,2,4,0},
{1,0,3,2,5,4},
{0,4,3,2,1,5},
{4,5,3,2,0,1},
{1,3,5,0,2,4},
{0,3,1,4,2,5},
{4,3,0,5,2,1},
{5,3,4,1,2,0},
{3,4,5,0,1,2},
{3,5,1,4,0,2},
{3,1,0,5,4,2},
{3,0,4,1,5,2},
};
```

## 贪心部分

在确定了 $n$ 个骰子的一种情况后，对于每一个朝向，找相同颜色面数量最多的颜色，将不是该颜色的面改为该颜色，即可做到对于该朝向修改颜色次数最少，再遍历每一个朝向，即可得到答案。

# 误区

本人在进行贪心时，以为一定要将所有骰子统一为其中一个骰子的所有面的颜色，并获得了 $40$ 分的好成绩。

实际则不然，如此贪心是错误的，题目只要求所有相同朝向的面颜色相同即可。

所以切不可像本人一样为省去遍历一个骰子的时间，痛失 $60$ 分。

# 代码实现

基于如上思路，便可得到以下通过代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ch[24][6]={
{2,1,5,0,4,3},
{2,0,1,4,5,3},
{2,4,0,5,1,3},
{2,5,4,1,0,3},
{4,2,5,0,3,1},
{5,2,1,4,3,0},
{1,2,0,5,3,4},
{0,2,4,1,3,5},
{0,1,2,3,4,5},
{4,0,2,3,5,1},
{5,4,2,3,1,0},
{1,5,2,3,0,4},
{5,1,3,2,4,0},
{1,0,3,2,5,4},
{0,4,3,2,1,5},
{4,5,3,2,0,1},
{1,3,5,0,2,4},
{0,3,1,4,2,5},
{4,3,0,5,2,1},
{5,3,4,1,2,0},
{3,4,5,0,1,2},
{3,5,1,4,0,2},
{3,1,0,5,4,2},
{3,0,4,1,5,2},
};
map<string,int>mp;
int arr[10][10],t[10][10],cnt,ANS=INT_MAX,n;
int check()
{
	int cnt=0,maxn=0,sum[105];
	for(int i=0;i<6;++i)
	{
		maxn=0;
		memset(sum,0,sizeof sum);	
		for(int j=1;j<=n;++j)
		{
			sum[t[j][i]]++;
			maxn=max(maxn,sum[t[j][i]]);
		}
		cnt+=n-maxn;
	}
	return cnt;
}
void solve(int k)
{
	if(k>n)
	{
		ANS=min(ANS,check());
		return ;
	}
	int cnt;
	for(int i=0;i<24;++i)
	{
		cnt=0;
		for(int j=0;j<6;++j)
		{
			t[k][j]=arr[k][ch[i][j]];
		}
		solve(k+1);
	}
	return ;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n; 
    while(n!=0)
    {
    	for(int i=1;i<=n;++i)
    	{
    		for(int j=0;j<6;++j)
    		{
    			string s;
    			cin>>s;
    			if(mp[s]==0)
    			{
    				mp[s]=++cnt;
				}
				arr[i][j]=mp[s];
			}
		}
		solve(1);
		cout<<ANS<<"\n";
		cnt=0;
		ANS=INT_MAX;
		mp.clear();
		cin>>n;
	}
	return 0;
}
```

最后感谢您的留步与观看，希望本篇题解能够帮到您。

---

## 作者：arfa (赞：1)

## 考场没切掉...(60')
本题其实就是一个暴搜+结论的题目,具体题解在下方。

---

## 考场时的想法:
### 1.贪心
看能不能找到最佳的合适位置,很显然:效率低,正确率也低。
### 2.结论
想起不管上下左右怎样转,只有24种转法,增加了这个条件,就可以爆搜了。
```psacal
考场即时验证:

procedure make(mode,x,y:longint);// 草稿枚举上下左右翻转
begin
        if mode=1 then
        begin
                may_color[x,1]:=may_color[y,1];
                may_color[x,2]:=may_color[y,3];
                may_color[x,3]:=may_color[y,5];
                may_color[x,4]:=may_color[y,2];
                may_color[x,5]:=may_color[y,4];
                may_color[x,6]:=may_color[y,6];
        end;
        if mode=2 then
        begin
                may_color[x,1]:=may_color[y,1];
                may_color[x,2]:=may_color[y,4];
                may_color[x,3]:=may_color[y,2];
                may_color[x,4]:=may_color[y,5];
                may_color[x,5]:=may_color[y,3];
                may_color[x,6]:=may_color[y,6];
        end;
        if mode=3 then
        begin
                may_color[x,1]:=may_color[y,4];
                may_color[x,2]:=may_color[y,2];
                may_color[x,3]:=may_color[y,1];
                may_color[x,4]:=may_color[y,6];
                may_color[x,5]:=may_color[y,5];
                may_color[x,6]:=may_color[y,3];
        end;
        if mode=4 then
        begin
                may_color[x,1]:=may_color[y,3];
                may_color[x,2]:=may_color[y,2];
                may_color[x,3]:=may_color[y,6];
                may_color[x,4]:=may_color[y,1];
                may_color[x,5]:=may_color[y,5];
                may_color[x,6]:=may_color[y,4];
        end;
end;

procedure items;
var
        i,j,a,b,c,d,e,f,head,tail:longint;
begin
        for i:=1 to 6 do
                may_color[1,i]:=i;
        head:=0;
        tail:=1;
        repeat  //翻转状态
                inc(head);
                for j:=1 to 4 do
                begin
                        inc(tail);
                        make(j,tail,head);
                end;
        until tail>=96;
        for i:=1 to 96 do
                ask[may_color[i,1],may_color[i,2],may_color[i,3],may_color[i,4],may_color[i,5],may_color[i,6]]:=True;
        for a:=1 to 6 do for b:=1 to 6 do for c:=1 to 6 do for d:=1 to 6 do for e:=1 to 6 do for f:=1 to 6 do
        if ask[a,b,c,d,e,f] then //判断可能
        begin
                inc(x);
                able[x,1]:=a;
                able[x,2]:=b;
                able[x,3]:=c;
                able[x,4]:=d;
                able[x,5]:=e;
                able[x,6]:=f;
        end;
end;
```
这里的able也就是可能翻转的状态了。
得出已下状态:
```pascal
注视:add(x,状态);表示第x个状态翻转。
		add(1,1,2,3,4,5,6);
        add(2,1,3,5,2,4,6);
        add(3,1,4,2,5,3,6);
        add(4,1,5,4,3,2,6);
        add(5,2,1,4,3,6,5);
        add(6,2,3,1,6,4,5);
        add(7,2,4,6,1,3,5);
        add(8,2,6,3,4,1,5);
        add(9,3,1,2,5,6,4);
        add(10,3,2,6,1,5,4);
        add(11,3,5,1,6,2,4);
        add(12,3,6,5,2,1,4);
        add(13,4,1,5,2,6,3);
        add(14,4,2,1,6,5,3);
        add(15,4,5,6,1,2,3);
        add(16,4,6,2,5,1,3);
        add(17,5,1,3,4,6,2);
        add(18,5,3,6,1,4,2);
        add(19,5,4,1,6,3,2);
        add(20,5,6,4,3,1,2);
        add(21,6,2,4,3,5,1);
        add(22,6,3,2,5,4,1);
        add(23,6,4,5,2,3,1);
        add(24,6,5,3,4,2,1);
```
暴搜是地球人都会的:
```psacal
procedure check;
var
        i,j,k,sum,km,ss:longint;
begin
        ss:=0;
        for k:=1 to 6 do
        begin
                km:=6666;
                for i:=1 to n do
                begin
                        sum:=0;
                        for j:=1 to n do
                                if j<>i then
                                        if use[i,k]<>use[j,k] then
                                                inc(sum);
                        if sum<km then
                                km:=sum;
                end;
                inc(ss,km);
        end;
        if ss<ans then
                ans:=ss;
end;

procedure work_(x:longint);
var
        i,j:longint;
begin
        sum:=0;
        if x=n+1 then
                check
        else
                for i:=1 to 24 do
                begin
                        for j:=1 to 6 do
                                use[x,j]:=color[x,able[i,j]];
                        work_(x+1);
                end;
end;

begin
        items;
        repeat
                ans:=6666;
                sum:=0;
                read_;
                work_(1);
                writeln(ans);
        until 1<0;
end.

```
#### psacal会卡,90分,所以各位看完请写c++吧

---


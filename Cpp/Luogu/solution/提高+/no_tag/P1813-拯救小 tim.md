# 拯救小 tim

## 题目描述

小 tim 在游乐场，有一天终于逃了出来！但是不小心又被游乐场的工作人员发现了…所以你的任务是安全地把小 tim 护送回家。但是，A 市复杂的交通状况给你出了一大难题。 

A 市一共有 $n$ 个路口，$m$ 条单行马路。但是，每条马路都只有一段时间是开放的。为了安全，你必须选择一条护送路线，使得小 tim 在路上的时间最短，即到家的时刻减去离开游乐场的时刻最短。

## 说明/提示

**【样例解释 #1】**

最优方案应该是，在 $1$ 号点停留至时刻 $1$，然后走到 $3$ 号点，然后走到 $4$ 号点。到达时刻为时刻 $4$。tim 在路上的时间为 $4-1=3$。

### 数据范围

对于所有测试数据：
- $2\leqslant n\leqslant100$，$0\leqslant m\leqslant1000$，$1\leqslant s,t\leqslant n$，$s\not=t$；
- $1\leqslant x,y\leqslant n$，$0\leqslant b,e,c\leqslant10000$，$b<e$。

## 样例 #1

### 输入

```
4 5 1 4 
1 2 0 1 1 
1 2 0 1 2 
1 3 1 3 2 
2 4 3 4 1 
3 4 3 4 1 ```

### 输出

```
3```

# 题解

## 作者：chzhc (赞：12)

如果 $b, e, c$ 开到 1e9 题解中的做法会 TLE

实际上有 $\mathcal O(m \times (n+m) \log m)$ 的做法。

若存在一条路使得在每一条马路上时间都没有卡在时间上限，那么至少可以在 $s$ 路口多停留一个单位时间。依此类推，最优答案必然走过一条刚好卡在时间上限的马路。那么我们枚举这条马路，从这条马路的两个路口分别出发(提前建好反向边)走到 $s$ 和 $t$，最后统计答案即可。

所以枚举每条边跑 dij / spfa 就行了

code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, beg, end, x, y, xx, yy, z, ans = 707406378;
int disa[1000001], disb[1000001], team[1000001], teamb[1000001];
int tot, next[1000001], first[1000001], front[1000001], 
	go[1000001], ta[1000001], tb[1000001], value[1000001];
int totb, nextb[1000001], firstb[1000001], frontb[1000001], 
	gob[1000001], tab[1000001], tbb[1000001], valueb[1000001];
void Add(int x, int y, int xx, int yy, int z)
{
	next[++tot] = first[x];
	first[x] = tot;
	front[tot] = x;
	go[tot] = y;
	ta[tot] = xx;
	tb[tot] = yy;
	value[tot] = z;
}
void Addd(int x, int y, int xx, int yy, int z)
{
	nextb[++totb] = firstb[x];
	firstb[x] = totb;
	frontb[totb] = x;
	gob[totb] = y;
	tab[totb] = xx;
	tbb[totb] = yy;
	valueb[totb] = z;
}
void SpfaOne(int x, int ti)
{
	int t = 0, w = 1;
	team[w] = x;
	disa[x] = 0;
	while (t < w)
	{
		int u = team[++t];
		for (int i = first[u]; i; i = next[i])
		{
			int v = go[i];
			if (disa[u] + ti + value[i] <= tb[i])
			{
				if (disa[u] + ti < ta[i])
				{
					if (disa[v] > ta[i] + value[i] - ti)
					{
						disa[v] = ta[i] + value[i] - ti;
						team[++w] = v;
					}
				}
				else if (disa[v] > disa[u] + value[i])
				{
					disa[v] = disa[u] + value[i];
					team[++w] = v;
				}
			}
		}
	}
}
void SpfaTwo(int x, int ti)
{
	int t = 0, w = 1;
	teamb[w] = x;
	disb[x] = 0;
	while (t < w)
	{
		int u = teamb[++t];
		for (int i = firstb[u]; i; i = nextb[i])
		{
			int v = gob[i];
			if (ti - disb[u] - valueb[i] >= tab[i])
			{
				if (ti - disb[u] > tbb[i])
				{
					if (disb[v] > ti - tbb[i] + valueb[i])
					{
						disb[v] = ti - tbb[i] + valueb[i];
						teamb[++w] = v;
					}
				}
				else if (disb[v] > disb[u] + valueb[i])
				{
					disb[v] = disb[u] + valueb[i];
					teamb[++w] = v;
				}
			}
		}
	}
}
int main()
{
	freopen("road.in", "r", stdin);
	freopen("road.out", "w", stdout);
	scanf("%d%d%d%d", &n, &m, &beg, &end);
	for (int i = 1; i <= m; ++i)
	{
		scanf("%d%d%d%d%d%", &x, &y, &xx, &yy, &z);
		if (z <= yy - xx) // 若开放的时间都不够通过则不需要这一条边 
		{
			Add(x, y, xx, yy, z);
			Addd(y, x, xx, yy, z);// 反向边
		}
	}
	for (int i = 1; i <= tot; ++i)
	{
		for (int j = 1; j <= n; ++j) disa[j] = disb[j] = 707406378;
		SpfaOne(go[i], tb[i]);// 跑到终点
		SpfaTwo(front[i], tb[i] - value[i]); // 跑到起点
		if (ans > disa[end] + disb[beg] + value[i]) // 更新最小值
			ans = disa[end] + disb[beg] + value[i];
	}
	if (ans < 707406378)
		printf("%d", ans);
	else printf("Impossible"); // 无解
	fclose(stdin), fclose(stdout);
}

```

---

## 作者：XiaoQuQu (赞：2)

感觉本题不是很蓝的样子，实际难度感觉像是绿。

考虑设 $f_{i,j}$ 表示时刻 $j$ 从 $i$ 点出发，到达 $t$ 的最小时刻，然后直接按照 $f_{i,j}=\min_{i\to u} f_{u,\max(j,b)+w}$ 转移即可。

最终复杂度似乎是 $O(nV)$ 的。

```cpp
const int MAXN = 105, MAXW = 1e4 + 5;
int n, m, s, t;
int f[MAXN][MAXW];
struct _node {
	int v, w, b, e;
};
vector<_node> G[MAXN];

int dp(int i, int j) {
	if (f[i][j] != INT_MAX) return f[i][j];
	if (i == t) return j;
	for (auto [v, w, b, e]:G[i]) {
		int st = max(b, j);
		if (st + w > e) continue;
		f[i][j] = min(f[i][j], dp(v, st + w));
	}
	return f[i][j];
}

void work() {
	cin >> n >> m >> s >> t;
	for (int i = 1; i <= m; ++i) {
		int u, v, w, b, e;
		cin >> u >> v >> b >> e >> w;
		G[u].push_back({v, w, b, e});
	}
	for (int i = 1; i <= n; ++i) 
		fill(f[i], f[i] + MAXW, INT_MAX);
	int ans = INT_MAX;
	for (int i = 1; i <= 1e4; ++i)
		ans = min(ans, dp(s, i) - i);
	if (ans > 1e4)
		cout << "Impossible" << endl;
	else
		cout << ans << endl;
}
```

---

## 作者：橙子汁 (赞：2)

[转自这篇文章](https://blog.csdn.net/Cliu__/article/details/76973796)

这就是一个SPFA的模板题，步骤如下：

（我们可以按照时间点进行SPFA。）

1.首先，如果到了当前节点而当前的路还没有开放，那就应该按照开放的时间点向下走，如果开放了而晚到了，那就按晚到的时间，所以应该取max。

2.按照出发的时间点进行spfa，取最早的出发点和最晚的出发点进行SPFA。

3.SPFA时，点能进入队列有两个条件：

	①.在道路关闭之前到达。②.时间最短。

于是乎就得出这样的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>q;
struct node
{
    int from,to,l,r,ds;
}list[1005];
int minn,k,maxx=-1e9,n,m,s,t,x,y,l,r,c,ans;
int head[1005],dis[1005],v[1005];
void add(int x,int y,int l,int r,int c) //邻接表添边
{
    list[++k].from=head[x];
    list[k].to=y;
    list[k].l=l;
    list[k].r=r;
    list[k].ds=c;
    head[x]=k;
}
void spfa(int x)//最短路部分
{
    memset(dis,127/3,sizeof(dis));
    memset(v,0,sizeof(v));
    q.push(s);dis[s]=x;v[s]=1;
    while(!q.empty()){
        int u=q.front();q.pop();v[u]=0;
        for (int i=head[u];i;i=list[i].from){

        if (max(dis[u],list[i].l)+list[i].ds<=list[i].r)
        if (max(dis[u],list[i].l)+list[i].ds<dis[list[i].to]){
            dis[list[i].to]=max(dis[u],list[i].l)+list[i].ds;
            if (!v[list[i].to]){
                v[list[i].to]=1;
                q.push(list[i].to);
            }
        }
    }
}
}
int main()
{
    cin>>n>>m>>s>>t;
    ans=minn=1e9;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d%d%d",&x,&y,&l,&r,&c);
        if (l>r) swap(l,r);
        if (l+c>r) continue;
        if (x==s)
        {
            minn=min(minn,l);
            maxx=max(maxx,r-c);
        }
        add(x,y,l,r,c);
    }
    for (int i=minn;i<=maxx;i++)
    {
        spfa(i);
        if (dis[t]==dis[0]) break;//优化，如果某一时刻到达不了，那后来的也就到达不了了。
        ans=min(ans,dis[t]-dis[s]);
    }
    if (ans==1e9) cout<<"impossible";
    else cout<<ans;
    return 0;
}
```

---

## 作者：汤姆里德尔 (赞：1)

其实这一道题是一道裸的spfa，当然因为两个点中间有多条边，每一条边有不同开放时间，所以用邻接矩阵存图必须开100*100*1000，约9MB，但是用邻接矩阵去找边时复杂度是O（n*m）加上spfa和从1到n都要算，总复杂度为，O（k*m*n*m*n),达到1e+12,就完美的TLE了。所以只能用邻接表，复杂度为O（k*m*n),可以AC。

还有一个问题，如何判定加进的这条边满足要求，用dis[i]表示起点到i的最短时间，用a[i].st,a[i].en,a[i].c,表示第i条边从st到en均开放，通过需要c的时间。则若（dis[u]+a[i].c<a[i].en 且 max(dis[u],a[i].st)+a[i].c<dis[v]）即可进行转移。

下面上代码

------------//分隔线

```
#include<bits/stdc++.h>
using namespace std;
 
struct que{
    int next,to,c,st,en;
}a[5009];//邻接表定义 
 
int n,m,s,t,head[1009],dis[1009],tot,mx,flag[1009],ans;
 
queue <int> q;//stl队列 
 
void add(int from,int to,int st,int en,int c)
{
    tot++;
    a[tot].next=head[from];
    a[tot].to=to;
    a[tot].c=c;
    a[tot].st=st;
    a[tot].en=en;
    head[from]=tot;
}//邻接表存图 
 
void spfa(int k)//spfa最短路 
{
    for(int i=1;i<=n;i++) dis[i]=1e+9;
    memset(flag,0,sizeof(flag));
    q.push(s);dis[s]=k;flag[s]=1;
    while(!q.empty())
    {
        int u=q.front();flag[u]=0;q.pop();
        if(u==t) ans=min(ans,dis[u]-k);//到达终点进行比较 
        for(int i=head[u];i;i=a[i].next)//邻接表记下每一条边 
        {
            int v=a[i].to;
            if(dis[u]+a[i].c<=a[i].en && max(dis[u],a[i].st)+a[i].c<dis[v])//满足条件 
            {
                dis[v]=max(dis[u],a[i].st)+a[i].c;
                if(!flag[v])
                {
                    q.push(v);
                    flag[v]=1;
                }
            }
        }
    }
}
 
int main(){
    memset(head,0,sizeof(head));
    tot=0;mx=-1;
    cin>>n>>m>>s>>t;
    for(int i=1;i<=m;i++)
    {
        int x,y,b,e,c;
        scanf("%d%d%d%d%d",&x,&y,&b,&e,&c);
        if(b+c<=e) add(x,y,b,e,c);//减掉不符合要求的边 
        if(e>mx) mx=e;//找最长的时间 
    }
    ans=1e+9;//初始化 
    for(int i=1;i<=mx;i++) spfa(i);//每个时间都求一遍最短路 
    if(ans==1e+9) printf("Impossible");//如果走不到就输出Impossible 
    else printf("%d",ans);
    return 0;
}
```


---

## 作者：yangwenbin (赞：1)

最优解算法（无卡常）

![](https://cdn.luogu.com.cn/upload/image_hosting/x1rkk6xv.png)

------------

最短路模板 $+1$ 

[P1813 拯救小tim](https://www.luogu.com.cn/problem/P1813)

这道题就是一个裸的 $Dijkstra$ 模板（当然可以识别的最短路，我用了 $Dijkstra$ ）

这道题的难点在于，他的每条边有一个开放时间，只有在这个开放时间里，这条边才联通。

所以可以通过这个特性搞得你焦头烂额，也可以通过这条边让你优化算法（去掉不合法的边）。

这个之后再讲，首先先了解如何操作，在 $Dijkstra$ 的过程中，$tim$ 可以在一个点不动，就如同在一个点上连了一个长度为 $1$ 的边（自环）

但是跑最短路的时候这条边是不走的，同时读题，只有在起点停留的时间，不用记录在总时间里。

所以我们通过枚举起步时间来运算，那么，枚举多少呢？？

我们要保证，在期待点起步，可以出发

所以我们就枚举到起点的 $\min b_i$

然后几乎是裸的 $Dijkstra$ ：

只要加上几个优化（删除）即可

在做松弛操作的时候，把路径起始时间，和前一个点最短时间取最大：

$$ 
dis[v] = \max(edge[i].start,tmp)+edge[i].val;
$$

最后记得判 无解

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1050;
const int NUM = 100;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,m,s,t,num_edge;
int head[SIZE],dis[SIZE];
struct node
{
	int to,nxt,val,start,end;
};
node edge[SIZE];
struct point
{
	int u,dis;
	friend bool operator < (point a,point b)
	{
		return a.dis < b.dis;
	}
};

priority_queue <point> que;

inline void add(int u,int v,int start,int end,int val)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	edge[num_edge].start = start;
	edge[num_edge].end = end;
	edge[num_edge].val = val;
	head[u] = num_edge;
}

inline int dijkstra(int T)
{
	//for (int i = 1; i <= n; ++i) dis[i] = 1e9;
	point u;
	u.u = s;
	u.dis = 0;
	dis[s] = T;
	que.push(u);
	while (!que.empty())
	{
		u = que.top();que.pop();
		for (int i = head[u.u]; i ; i = edge[i].nxt)
		{
			int v = edge[i].to;
			int tmp = dis[u.u];
			if (tmp + edge[i].val > edge[i].end) continue;
			tmp = max(edge[i].start,tmp) + edge[i].val;
			if (tmp < dis[v])
			{
				dis[v] = tmp;
				point x;
				x.u = v;x.dis = dis[v];
				que.push(x);
			}
		}
	}
	if (dis[t] == 1061109567) return 1061109567;
	return dis[t] - dis[s];
}

int main()
{
	int maxn = 0,minn = 1e9;
	n = read();m = read();s = read();t = read();
	for (int i = 0; i < m; ++i)
	{
		int u = read(), v = read(), start = read(), end = read(), val = read();
		if (start + val > end) continue;
		add(u,v,start,end,val);
		if (u == s) maxn = max(maxn,start),minn = min(minn,start);
	}
	int ans = 1061109567;
	for (int i = minn; i <= maxn; ++i)
	{
		memset(dis,0x3f,sizeof(dis));
		int x = dijkstra(i);
		ans = min(ans,x);
	}
	if(ans == 1061109567) printf("Impossible");
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：huangmingyi (赞：0)

这题 ~~没写数据范围~~ 可以用广度优先搜索来做。我们先找出最晚的出发时间并设为 $\operatorname{LGT}$，就是从起点出发的所有路中的 $e-c$ 的最大值。再此之后枚举出发时间从最晚的出发时间到 $0$ 为止，把每个出发时间用 $\operatorname{SPFA}$ 求出到终点最短的路径。时间复杂度是 $O(LGT \times M)$。这题本蒟蒻就不放代码了。

---

## 作者：nomonick (赞：0)

考试竟然考了这种题（还有人爆零）

不会吧，讲真很板子，就是在堆优化 $Dijkstra$ （最开始忘记染色导致成了 $SPFA$ ）上加了一个对于时间的判断，而且这道题的可优化型很多（我做了一下尝试）。

首先看到题面，第一眼很奇怪，尤其是没有数据范围。仔细一想其实挺简单的。

重点就在于开放时间，所以有些路是根本走不了的，这里可也预处理去除。

同时可以在一个点不动，但是如果你不是迫不得已，待着不动一定不是最优解（最短路）所以只要在松弛操作的时候考虑一下是否一定要等待路径开启。

最后考虑一下会在起点停几秒，但是这个时间不记录在内，所以枚举实现即可：

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1050;
const int NUM = 100;

inline int read()
{
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int n,m,s,t,num_edge;
int head[SIZE],dis[SIZE];
bool vis[SIZE];
struct node
{
	int to,nxt,val,start,end;
};
node edge[SIZE];
struct point
{
	int u,dis;
	friend bool operator < (point a,point b)
	{
		return a.dis < b.dis;
	}
};

priority_queue <point> que;

inline void add(int u,int v,int start,int end,int val)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	edge[num_edge].start = start;
	edge[num_edge].end = end;
	edge[num_edge].val = val;
	head[u] = num_edge;
}

inline int dijkstra(int T)
{
	point u;
	u.u = s;
	u.dis = 0;
	dis[s] = T;
	que.push(u);
	while (!que.empty())
	{
		u = que.top();
        que.pop();
        if (vis[u.u]) continue;
        vis[u.u] = true;
		for (int i = head[u.u]; i ; i = edge[i].nxt)
		{
			int v = edge[i].to;
			int tmp = dis[u.u];
			if (tmp + edge[i].val > edge[i].end) continue;
			tmp = max(edge[i].start,tmp) + edge[i].val;
			if (tmp < dis[v])
			{
				dis[v] = tmp;
				point x;
				x.u = v;x.dis = dis[v];
				que.push(x);
			}
		}
	}
	if (dis[t] == 1061109567) return 1061109567;
	return dis[t] - dis[s];
}

int main()
{
	int maxn = 0,minn = 1e9;
	n = read();m = read();s = read();t = read();
	for (int i = 0; i < m; ++i)
	{
		int u = read(), v = read(), start = read(), end = read(), val = read();
		if (start + val > end) continue;
		add(u,v,start,end,val);
		if (u == s) maxn = max(maxn,end - val),minn = min(minn,start);
	}
	int ans = 1061109567;
	for (int i = minn; i <= maxn; ++i)
	{
		memset(dis,0x3f,sizeof(dis));
		memset(vis,false,sizeof(vis));
		int x = dijkstra(i);
		ans = ans < x ? ans : x;
	}
	if(ans == 1061109567) printf("Impossible");
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：zhenghongzhe (赞：0)

###简单的要命。。。。

我们可以这样想：

①n^3的floyd，但更新的时候需用要判断。

② n^2的dijsktra最短路，更新的时候也需要判断。

③贪心思想，在每次找路线时，找到一个关闭时间和你路过的时间差距最小的时间，以这个时间作为增量来得到下一次开始行动的时间。

接下来，代码献上，两种方法（c++）

方法一：

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
const int maxn = 1005;
int n,m,cnt;
int x,y,o,c,z,s,t,ans=1e9,minn=1e9,maxx;
int f[maxn],head[maxn];
bool vis[maxn];
queue<int> q;
struct Edge{
    int to,next,s,t,val;
}e[maxn*5];
void addEdge(int u,int v,int s,int t,int w){
    e[++cnt].to=v;e[cnt].val=w;e[cnt].next=head[u];head[u]=cnt;
    e[cnt].s=s,e[cnt].t=t;
}
void spfa(int x){
    for(int i=1;i<=n;i++)
        vis[i]=0,f[i]=1e9;
    f[s]=x;
    q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=0;
        if(u==t)    ans=min(ans,f[u]-x);
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            if(f[u]+e[i].val<=e[i].t){    //能在关门之前赶到 
                if(max(e[i].s,f[u])+e[i].val<f[v]){    //下面属于spfa操作 
                    f[v]=max(e[i].s,f[u])+e[i].val;
                    if(!vis[v])    q.push(v),vis[v]=0;
                }
            }
        }
    }
}
int main(){
    cin>>n>>m>>s>>t;
    for(int i=1;i<=m;i++){
        cin>>x>>y>>o>>c>>z;
        if(c-z<o)    continue;//删掉不符条件的边 
        if(x==s)    minn=min(minn,o),maxx=max(maxx,c-z);
        addEdge(x,y,o,c,z);
    }
    for(int i=minn;i<=maxx;i++)
        spfa(i);
    if(ans<1e9)    cout<<ans;
    else cout<<"Impossible";
}
```
第二种：
```cpp
#include<bits/stdc++.h>/还是万能库
using namespace std;
const int maxn = 1005;
int n,m,cnt;
int x,y,o,c,z,s,t,ans=1e9,minn=1e9,maxx;
int f[maxn];
int head[maxn],ind[maxn],in[maxn];
queue<int> q;
struct Edge{
    int to,next,s,t,val;
}e[maxn*10];
void addEdge(int u,int v,int w,int s,int t){
    e[++cnt].to=v;e[cnt].next=head[u];head[u]=cnt;
    e[cnt].s=s,e[cnt].t=t,e[cnt].val=w;
    ind[v]++;
}
void topo(int x){
    q.push(s);
    for(int i=1;i<=n;i++)
        in[i]=ind[i],f[i]=1e9;
    f[s]=x;
    while(!q.empty()){
        int u=q.front();q.pop();
        if(u==t)    ans=min(ans,f[u]-x);
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].to;
            if(f[u]+e[i].val<=e[i].t)
                f[v]=min(f[v],max(f[u],e[i].s)+e[i].val);
            in[v]--;
            if(in[v]==0)    q.push(v);
        }
    }
}
int main(){
    cin>>n>>m>>s>>t;
    for(int i=1;i<=m;i++){
        cin>>x>>y>>o>>c>>z;
        if(c-o<z)    continue;
        if(x==s)    minn=min(minn,o),maxx=max(maxx,c-z);
        addEdge(x,y,z,o,c);
    }
    for(int i=minn;i<=maxx;i++)
        topo(i);
    if(ans!=1e9)cout<<ans;
    else cout<<"Impossible";
}*/
```

---

## 作者：冷月冰瞳 (赞：0)

由于题目没有给出路口开放的时刻范围，所以只能说一个没有时间复杂度保证的算法。

先找到最晚的出发时间MAX\_START\_TIME，就是从起点出发的所有路中e-c的最大值。然后枚举出发时间start\_time从MAX\_START\_TIME到0，对每个start\_time用SPFA求出到终点的最短路。

可以优化的一点就是，枚举过程中，不需要将最短路复原成无穷大，只需要更新一下起点的时间，然后接着做spfa（其实变成了bfs）即可。所以总时间复杂度就是O(MAX\_START\_TIME\*M)


---


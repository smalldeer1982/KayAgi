# 数的序号

## 题目描述

我们可以用下面的方案给二叉树标号：

- 空树的序号为 $0$。
- 只有一个根结点的树序号为 $1$。
- 所有包含 $m$ 个结点的二叉树的序号一定比任何一个包含 $m+1$ 个结点的二叉树的序号小。
- 对于任何一棵二叉树，设其左子树序号为 $L$，右子树序号为 $R$，且它有 $m$ 个结点，若它的序号为 $n$，则所有序号大于 $n$ 的 $m$ 个结点的二叉树，要么左子树序号大于 $L$，要么左子树序号等于 $L$ 且右子树序号大于 $R$。

例如，编号为 $0$ 到 $5$ 的六棵树形状如下：

```plain
0   1   2       3   4       5 
    X   X       X   X       X
         \     /     \       \
          X   X       X       X
                       \     /
                        X   X
```

你的任务就是对给定的序号，输出该序号所对应的二叉树。


## 说明/提示

### 数据规模与约定

对于所有测试点，保证 $1\le n\le 5\times10^8$，数据组数不超过 $50$。

## 样例 #1

### 输入

```
1   
20 
31117532   
0 ```

### 输出

```
X
((X)X(X))X
(X(X(((X(X))X(X))X(X))))X(((X((X)X((X)X)))X)X)```

# 题解

## 作者：WYXkk (赞：7)

这是一道令人谔谔的数学题（？

如果我们记 $c_i$ 为大小为 $i$ 的不同二叉树的个数，则有

$$c_0=1,c_n=\sum\limits_{i=0}^{n-1}c_ic_{n-1-i}$$

即，去掉根之后考虑左右点的个数。

随便打个表就知道 $\sum\limits_{i=1}^{18}c_i>5\times 10^8$，只需预处理 $c_1,\cdots,c_{18}$ 即可。

我们首先对输入的 $x$ 作一些处理，改为求大小为 $n$ 的树中序号第 $x$ 个。

这一步处理很好写：

```cpp
int n=1;while(x>c[n]) {x-=c[n];++n;}
```

之后考虑实现 `void print(ll x,int n)`。

按照题目要求，编号按左子树排序，相等则按右子树排序。

而树先按大小排序，因此我们可以先计算出左子树和右子树的大小，以及在这个大小下要求的树是第几个。

这部分的代码：

```cpp
int l=0;while(x>c[l]*c[n-1-l]) {x-=c[l]*c[n-1-l];++l;}int r=n-1-l;
```

接下来，如果用 $(x,y)$ 来表示左子树编号为 $x$，右子树编号为 $y$ 的二叉树，则其排序如下：

$(1,1),(1,2),(1,3),\cdots,(1,c_r),(2,1),(2,2),\cdots,(c_l,c_r)$

不难发现，其中第 $x$ 个即为 $\left(\left\lfloor\dfrac{x-1}{c_r}\right\rfloor+1,(x-1)\mod c_r+1\right)$。

于是特判 $l,r$ 是否为 $0$ 后，分别递归下去即可。

复杂度我不会算，反正常数级别。

$\texttt{code:}$

```cpp
void print(ll x,int n)
{
	int l=0;while(x>c[l]*c[n-1-l]) {x-=c[l]*c[n-1-l];++l;}int r=n-1-l;
	if(l) {putchar('(');print((x-1)/c[r]+1,l);putchar(')');}
	putchar('X');
	if(r) {putchar('(');print((x-1)%c[r]+1,r);putchar(')');}
}
int main()
{
	/* prework for c[i] */
	while(true)
	{
		ll x=rd();
		if(!x) break;
		int n=1;while(x>c[n]) {x-=c[n];++n;}
		print(x,n);
		putchar('\n');
	}
	return 0;
}
```



---

## 作者：joy2010WonderMaker (赞：2)

一道不难的数学题，为啥没人做啊。~~虽然我也是随机跳题跳出来的。~~

### 题目分析

首先我们可以知道，大小为 $k$ 的二叉树一共有 $C_k$，也就是卡特兰数的第 $k$ 项的值。随便算一下，$C_1+C_2+\cdots+C_{18}$ 已经超过了 $5\times 10^8$，保险起见，算到 20。

现在我们就可以把问题转化成求大小为 $k$ 的二叉树，序号为 $s$ 的是什么。

考虑左右孩子，显然对于左右孩子，它们也是二叉树。所以依然可以套用卡特兰数，这样我们就可以算出左子树的大小和右子树的大小。

由于题目要求先按左孩子，再按右孩子排序，所以不难发现，假设右子树大小为 $b$，则左孩子为 $(s-1)/c_b+1$ （即把根去掉后，每组有 $c_b$ 棵二叉树，加一即可得到组数），右孩子为 $(s-1)\bmod c_b+1$ （即这是这组里的第几个）。递归即可。若序号为 1，则输出单个的 `X` 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[21];
void print(int x,int s){
	if(x==1){
		putchar('X');
		return;
	}
	int l=0,r=x-1;
	while(s>c[l]*c[r]){
		s-=c[l]*c[r];
		l++,r--;
	}
	if(l){
		putchar('(');
		print(l,(s-1)/c[r]+1);
		putchar(')');
	}
	putchar('X');
	if(r){
		putchar('(');
		print(r,(s-1)%c[r]+1);
		putchar(')');
	}
	return;
}
int main(){
	c[0]=1;
	for(int i=1;i<=20;i++)
		for(int j=0;j<i;j++)
			c[i]+=c[j]*c[i-j-1];
	while(~scanf("%d",&n)&&n!=0){
		int pos=1;
		while(n>c[pos])
			n-=c[pos],pos++;
		print(pos,n);
		puts("");
	}
	return 0;
}
```


---

## 作者：nomonick (赞：2)

数学题？？

考场上想到思路，然后调了一个小时，就离谱～～

[P1814 数的序号](https://www.luogu.com.cn/problem/P1814)

这道题可以很明确的确定，对于某一节点数的情况，存在一个状态转移方程。

$$
siz_i = \sum\limits_{j=0}^{i-1} siz_j \times siz_{i-j-1};
$$

这样用搜索加上记忆化应该是最快的。

```cpp
int get_siz(int u)
{
	if (siz[u]) return siz[u];
	int sum = 0;//siz[u-1];
	for (int i = 0; i < u; ++i)
	{
		sum += get_siz(u-i-1) * get_siz(i);
	}
	return siz[u] = sum;
}
```

然后分析题目中的判断条件，得出结论：

- 优先总点数，点数越少，顺序越小

- 之后左子树优先，左子树点数越少，顺序越小

- 最后右子树，右子树点数越少，顺序越小

然后分治输出一棵树的中序遍历（补上括号），在此前统计一下有几个点，一步一步加下去就行了，

```cpp
int at = 1;
while (n > siz[at])
{
	n -= siz[at];
	at ++;
}
dfs(at,n);
```

之后在搜索了有 $at$ 个点的第 $n$ 小的树

按照找到的规律，优先考虑左子树点数小的情况，找到左子树的点数，并同时算出右子树的点数。

```cpp
int ls = 0,rs = u-1;
while (num > siz[ls] * siz[rs])
{
	num -= siz[ls] * siz[rs];
	ls++;rs--;
}
```

左右分治

```cpp
if (ls) // 存在左子树
{
    printf("(");
	dfs(ls,(num-1)/siz[rs]+1);　// 向上取整，自己理解一下，自己的情况一定大于一嘛
	printf(")");
}
printf("X");
if (rs)　// 存在右子树
{
	printf("(");
	dfs(rs,(num-1) % siz[rs]+1); // 避免最大的情况被取模成 0
	printf(")");
}
```

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int SIZE = 10050;

inline int read()
{
	int x = 0,f = 1;
	char  ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int limit;
int siz[SIZE],pre[SIZE];

int get_siz(int u)
{
	if (siz[u]) return siz[u];
	int sum = 0;//siz[u-1];
	for (int i = 0; i < u; ++i)
	{
		sum += get_siz(u-i-1) * get_siz(i);
	}
	return siz[u] = sum;
}

int n;

void dfs(int u,int num)
{
	if (u == 1)
	{
		printf("X");
		return ;
	}
	int ls = 0,rs = u-1;
	while (num > siz[ls] * siz[rs])
	{
		num -= siz[ls] * siz[rs];
		ls++;rs--;
	}
	if (ls)
	{
		printf("(");
		dfs(ls,(num-1)/siz[rs]+1);
		printf(")");
	}
	printf("X");
	if (rs)
	{
		printf("(");
		dfs(rs,(num-1) % siz[rs]+1);
		printf(")");
	}
}

signed main()
{
	siz[0] = 1;
	int indax = 1;
	while (indax <= 20)
	{
		siz[indax] = get_siz(indax);
		indax ++;
	}
	while (true)
	{
		n = read();
		if (n == 0) break;
		int at = 1;
		while (n > siz[at])
		{
			n -= siz[at];
			at ++;
		}
		dfs(at,n);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：wflhx2011 (赞：0)

对于 $n$ 个节点的二叉树，总共有 $C_n$ 种不同的形态，其中 $C_n$ 为卡特兰数第 $n$ 项。

当然，不知道也没关系，设 $f_i$ 表示 $i$ 个节点的二叉树不同形态种数。为了使计算正确，需要让 $f_0=1$。

显然 $f_1=1$。

因为是二叉树，那么左右子树也必然是二叉树，所以 $f_i=\sum_{j=1}^{i-1}f_j\times f_{i-j-1}$。即按左子树节点个数分类，对每种情况求出右子树节点个数，这种情况的答案就是两棵子树形态种数相乘，最后把所有情况相加。

这就是卡特兰数的递推式。

回到本题，显然可以先求出总共有多少节点。

和上面类似，因为左右子树必然是二叉树，可以递归求解。

那么需要知道子树的节点个数和编号，节点个数较好求，假设求出分别是 $l$ 和 $r$。

对于编号，可以理解为分成了 $C_r$ 个一组，总共 $C_l$ 组，左子树编号就是第几组，右子树编号就是组内第几个，也就容易求了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[25];
void print(int siz,int ind)
{
	if(!ind) 
		ind=c[siz];
	if(siz==1)
	{
		cout<<'X';
		return;
	}
	int l=0,r=siz-1,cyc;
	while(ind>c[l]*c[r]) 
		ind-=c[l]*c[r],l++,r--;
	cyc=ceil(ind*1.0/c[r]);
	if(l) 
		cout<<'(',print(l,cyc),cout<<')';
	cout<<'X';
	if(r) 
		cout<<'(',print(r,ind-(cyc-1)*c[r]),cout<<')';
}
int main()
{
	c[0]=1;
	for(int i=1;i<=20;i++)
		for(int j=0;j<i;j++)
			c[i]+=c[j]*c[i-j-1];
	while(cin>>n&&n)
	{
		int siz=1;
		while(n>c[siz]) 
			n-=c[siz],siz++;
		print(siz,n),cout<<endl;
	}
	return 0;
}
```

---

## 作者：EXR_FAL (赞：0)

## P1814 数的序号

### 题目传送门  [Link](https://www.luogu.com.cn/problem/P1814)

### 前置知识

[卡特兰数](https://oi-wiki.org/math/combinatorics/catalan/)

### 双倍经验（

[P2247](https://www.luogu.com.cn/problem/P2274)，是的，我就从这里来的。

### 分析 & 思路

拿到这个题，上来先手模一下前几个二叉树，~~应该是人之常情~~。

然后手模完了你就会发现这个题中最核心的一个也是最巧妙的一个性质：

> 由 $n$ 个节点构成的不同二叉树的数量刚好是卡特兰数的第 $n$ 项。

证明就不放了，这个[很多文章](https://blog.csdn.net/adminabcd/article/details/46672759)都有写，~~不是我不会~~。

于是我们可以愉快的预处理出卡特兰数然后获得第 $n$ 个二叉树的节点个数了。

解决完节点个数问题后问题就简单了。记第 $n$ 项 卡特兰数为 $H_n$。\
直接愉快地递归，设当前子树有 $m$ 个点，，枚举左儿子的点数 $t$，则对应有 $H_t H_{m-1-t}$ 种形态，看看给定的 $N$ 是否落在其中即可。\
由于 $H_n$ 的增长是极快的，所以时间复杂度看似是 $O(m^2)$，其实也可以写成 $O(\log^2 N)$。

### Code 如下：

含手模的前 10 个二叉树（不是

```cpp
//Ciallo～(∠・ω< )⌒★

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
inline ll read(){
	ll x=0,flag=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+(ch^48);
		ch=getchar();
	}
	return x*flag;
}
void out(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x<10) putchar(x+'0');
	else{
		out(x/10);
		putchar(x%10+'0');
	}
}

const int N=20;
int n;

// 反正Catalan预处理时间也不长
// 干脆直接没写Catalan的表直接预处理出来了（偷懒

vector<ll> C(N+1);
vector<ll> S(N+1);

void Ciallo() {
    C[0]=1;
    for(int n=1;n<=N;n++) {
        C[n]=0;
        for(int i=0;i<n;i++) 
            C[n]+=C[i]*C[n-1-i];
    }

    S[0]=0;
    for (int k=1; k<=N;k++) 
        S[k]=S[k-1]+C[k];
}

string get_tree(int k, int m) { //其实就是DFS
    ll cnt=0;
    for(int i=0;i<k;i++) {
        int j=(k-1)-i;
        ll tot=C[i]*C[j];
        if (cnt+tot>=m) {
            int m_prime=m-cnt;
            int l=(m_prime-1)/C[j]+1;
            int r=(m_prime-1)%C[j]+1;
            string le=(i>0)?get_tree(i,l):"";
            string ri=(j>0)?get_tree(j,r):"";
            string res="";
            if(!le.empty()) res+="("+le+")";
            res+="X";
            if(!ri.empty()) res+="("+ri+")";
            return res;
        }else cnt+=tot;
    }
	return "FAKE_CCB"; // ?
}

inline void solve(){

    // 手推的供参考（
	if(n==1) {puts("X"); return ;}
	if(n==2) {puts("X(X)"); return ;}
	if(n==3) {puts("(X)X"); return ;}
	if(n==4) {puts("X(X(X))"); return ;}
	if(n==5) {puts("X((X)X)"); return ;}
	if(n==6) {puts("(X)X(X)"); return ;}
	if(n==7) {puts("(X(X))X"); return ;}
	if(n==8) {puts("((X)X)X"); return ;}
	if(n==9) {puts("X(X(X(X)))"); return ;}
	if(n==10) {puts("X(X((X)X))"); return ;}

	int k=1;
	while(k<=N&&S[k]<n) ++k;
	int m=n-S[k-1];
	cout<<get_tree(k,m)<<'\n';

}

int main(){

	Ciallo();

    while(n=read()) 
		solve();

	return 0;
}
```

---

## 作者：Herobrine6265 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1814) 
（~~好水的蓝题啊作者这种苣蒻都能搞定~~）

# 思路

一道奇妙的数学题。

### 预处理

由于题目中有规则说“所有包含 $m$ 个结点的二叉树的序号一定比任何一个包含 $m+1$ 个结点的二叉树的序号小“，所以首先要根据给定的编号确定一下树的大小。

考虑记录每一种大小的树的个数（记作 $c_i$，其中 $i$ 表示树的大小），则根据加法和乘法原理有：

$$
c_0=1
\\
c_n=\sum_{i=0}^{n-1}c_ic_{n-1-i}
$$

目测 $c_i$ 增长很快，所以考虑打表预处理，打表时只需要保证 $\sum c_i \geq 5 \times 10^8$ 即可。（实际上最多只需要处理到 $c_{18}$）

### 计算

首先把每一种大小的树的最大编号记录下来（记作数组 $r$），每次询问的时候在 $r$ 中二分查找确定数的大小，然后把编号转化成在当前大小树中的排名（记作 $rk$），根据排名确定左右子树的大小。

由于编号规则的最后一条说明左子树小的一定排名更靠前，因此我们可以重新进行在初始化过程中求该种大小树的数量的操作，使 $\sum_{i=0}^k c_ic_{n-1-i} \geq rk$ 成立的最小的 $k$ 即为对应的左子树大小。

易于证明左子树的排名为 $\lceil \frac{rk}{c_{n-1-k}} \rceil$，右子树的排名为 $rk$ $ \bmod$ $c_{n-1-k}$（理解不了多画几个图就好了）

# AC Code

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

vector<int> types = {1}, r = {0};
int n;

void printTree(int now, int siz)
{
    if (siz == 0)
        return;
    for (int i = 0; i < siz; i++)
    {
        int temp = types[i] * types[siz - 1 - i];
        if (now <= temp)
        {
            if (i)
            {
                cout << "(";
                int next = now / types[siz - 1 - i];
                if (now == next * types[siz - 1 - i])
                    printTree(next, i);
                else
                    printTree(next + 1, i);
                cout << ")";
            }
            cout << "X";
            if (siz - 1 - i)
            {
                cout << "(";
                printTree((now - 1) % types[siz - 1 - i] + 1, siz - 1 - i);
                cout << ")";
            }
            return;
        }
        now -= temp;
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    for (int i = 1; r.back() <= 500000000; i++)
    {
        int cnt = 0;
        for (int j = 0; j < i; j++)
            cnt += types[j] * types[i - 1 - j];
        types.push_back(cnt);
        r.push_back(r.back() + cnt);
    }
    while (true)
    {
        cin >> n;
        if (!n)
            return 0;
        int temp = lower_bound(r.begin(), r.end(), n) - r.begin();
        printTree(n - r[temp - 1], temp);
        cout << endl;
    }
    return 0;
}
```

---

## 作者：scp020 (赞：0)

# P1814 数的序号 题解

忘了怎么发现的这道题，反正题挺水的。

## 解法

想要输出一棵树的结构，我们必须先知道这棵树有几个节点。

我们知道节点个数相同的一类树它们的编号是连续的。我们考虑预处理出节点个数为 $i$ 的不同的树有几种，记作 $num_i$。

每棵树肯定有一颗树根。枚举左子树的大小 $j \in [0,i-1]$，那么右子树的大小即为 $i - j - 1$，根据乘法原理，当左子树的大小为 $j$ 时节点个数为 $i$ 的不同的树有 $sum_j \times sum_{i - j - 1}$，所以 $sum_i = \sum \limits ^{n-1} _{j=0} sum_j \times sum_{i - j - 1}$。我选择了打表预处理，代码如下。

```cpp
#include<bits/stdc++.h>
#define int long long
int ans[20],n;
signed main()
{
	ans[0]=1,ans[1]=1;
	for(int i=2;i<=19;i++)
	{
		for(int j=0;j<i;j++) ans[i]+=ans[j]*ans[i-j-1];
		if(ans[i]>500000000)
		{
			n=i-1;
			break;
		}
	}
	std::cout<<n<<"\n";
	for(int i=0;i<=n;i++) std::cout<<ans[i]<<",";
	return 0;
}
```

现在考虑两颗节点数相同的树。

一颗树的编号共同取决于其左子树的编号和右子树的编号。在左子树编号不同时，左子树编号小的树编号小。在左子树编号不同时，右子树编号小的树编号小。

考虑如何确定左、右子树的编号。这样就可以完整打印一棵树的结构了。

定义一类 $n$ 颗节点，左子树大小为 $lsiz$ 的树的初始形态如下:

```
       X
      / \
     X   X
      \   \
       X   X
        \   \
         X   X
          ......
```

此时 $id_{ori} = \sum \limits ^{n-1} _{i=0} num_i$。如果想要求 $id$ 为 $id_{now}$ 的树的形态，就优先改变右子树的形态 $id_{now} - id_{ori}$ 次，注意到，右子树改变了 $num_{n-lsiz-1}$ 次后就改变了一个周期。这时我们需要改变左子树的形态，在右子树改变了一个周期后左子树改变一次。

需要注意的是因为优先改变右子树，所以我们在周期中不能改变 $0$ 次右子树形态，所以需要一次特判，将 $0$ 改成 $num_{n-lsiz-1}$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
	/**
	 * 快读快写
	*/
};
using namespace fast_IO;
#define int long long // 害怕。
int n,num[]={1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700};
inline void print(int siz,int ind) // siz 表示子树大小，ind 表示子树大小为 siz 中需要打印的树的排序，第几大。
{
	if(ind==0) ind=num[siz];
	if(siz==1)
	{
		out<<'X';
		return;
	}
	int lsiz=0,cyc;
	while(ind>num[lsiz]*num[siz-lsiz-1]) ind-=num[lsiz]*num[siz-lsiz-1],lsiz++; // 确定左子树大小
	cyc=ceil(ind*1.0/num[siz-lsiz-1]);
	if(lsiz) out<<'(',print(lsiz,cyc),out<<')';
	out<<'X';
	if(siz-lsiz-1) out<<'(',print(siz-lsiz-1,ind-(cyc-1)*num[siz-lsiz-1]),out<<')';
}
signed main()
{
	int siz;
	while(1)
	{
		in>>n;
		if(n==0) break;
		siz=1;
		while(n>num[siz]) n-=num[siz],siz++;
		print(siz,n),out<<'\n';
	}
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```


---


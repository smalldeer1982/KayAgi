# 速算游戏

## 题目描述

jyx 和 cyy 打赌，比谁 $24$ 点算得快，算得慢的那个人请客。$24$ 点的规则是这样的：给定 $4$ 个 $1\sim 9$ 的整数，用括号改变运算顺序，通过加、减、乘、除中的一系列运算，得到整数 $24$。

注意所有中间结果必须是整数（例如 $(2\times 2)/4$ 是允许的，而 $2\times (2/4)$ 是不允许的）。

为了赢得这个比赛，请写一个程序帮助我作弊，快速地计算出 $24$ 点。

## 样例 #1

### 输入

```
2 3 5 7 ```

### 输出

```
(((3*5)+2)+7)```

# 题解

## 作者：Kelin (赞：10)

因为字典序是这样的(,),\*,+,-,/,1,2,3,4,5,6,7,8,9(从小到大)

所以括号有(((a\_b)\_c)\_d)||((a\_b)\_(c\_d))||(a\_(b\_(c\_d)))这样的3种顺序
当然题目还有一些其他细节

1.运算中不能出现0和负数

e.g. 3 4 5 6=>

(((3-4)+4)\*6) WA

(((3+5)-4)\*6) AC

2.运算中必须保证只有整除

e.g. 1 2 4 6 =>

(((1/2)+4)\*6) WA

(((2-1)+4)\*6) AC

3.按照\*,+,-,/的顺序枚举运算符

所以我们按顺序枚举 3 个运算符,枚举数的摆放位置,并且枚举优先运算的顺序,然后计算值即可,复杂度o(4!\*3^3)

有一种方法是直接全排序 然后3^3枚举 然后找到就退出

但是实际上是会wa的

e.g.2 4 6 8=>

(((2\*6)+4)+8) WA

(((2\*6)\*8)/4) AC

因为(2 6 4 8)<(2 6 8 4)所以按照全排列找到退出就会WA

所以我们考虑把所有解都记录下来 然后sort一下就ok了(或者堆)(用sprintf可以节省很多赋值的代码)复杂度o(648\*log648)

ps:代码非常好写


---

## 作者：ganpig (赞：6)

乍一看是个码量大细节多的毒瘤暴力题，然而如果使用 Python 的话是可以轻松解决的。

因为需要保证字典序最小，而所有可能出现的字符中括号的 ASCII 码最小，我们知道答案必定属于下面两种形式之一（其他形式都可**变形**为这两种字典序更小的形式）：

- $(((a \circ b) \circ c) \circ d)$

- $((a \circ b) \circ (c \circ d))$

因此我们只需对于这两种形式，分别枚举四个数的全排列和三个运算符并求值检验即可，循环次数最多为 $2 \times 4! \times 4^3=3072$，显然能过。

因为我们用的是 Python，这些操作都非常方便：

- 枚举四个数的全排列可以用内置库函数 `itertools.permutations`；

- 枚举三个运算符可以用生成笛卡尔积的函数 `itertools.product`；

- 求值可以用 `eval` 函数，但由于求值时可能出现除数为 $0$ 的情况导致 `ZeroDivisionError` 异常，要套个异常处理的壳。

## $\text{Code}$

```python
from itertools import *

def safe_eval(*args):
    try: return eval(*args)
    except: return 114514

print(min(r.replace('a', str(a)).replace('b', str(b)).replace('c', str(c)).replace('d', str(d))
          for a, b, c, d in permutations(map(int, sorted(input().split()))) # 枚举全排列
          for s in ('(((a{}b){}c){}d)', '((a{}b){}(c{}d))')                 # 枚举括号形式
          for t in product('+-*/', repeat=3)                                # 枚举运算符
          if safe_eval(r := s.format(*t), globals(), locals()) == 24))
```

## $\text{Hack}$

上面的代码能通过本题当前的数据，但它其实并没有完全满足题目的要求。

> 注意所有中间结果必须是整数（例如 $(2\times 2)/4$ 是允许的，而 $2\times (2/4)$ 是不允许的）。

我们求值时使用的是 `/` 运算符，Python 中两个 `int` 用 `/` 相除返回的是 `float` 型，也就说明我们并没有排除中间结果是小数的答案。其实排除起来也很简单，只要将 `/` 替换为 `//` 进行二次验证就行了，也就是将代码的最后一行修改为：

```python
if safe_eval(r := s.format(*t), globals(), locals()) == 24 and safe_eval(r.replace('/', '//'), globals(), locals()) == 24
```

经过枚举，能使前文中的代码得到错误答案的数据有且仅有三组：

```
2 2 3 9 F: (((2/3)+2)*9) T: (((9-3)*2)*2)
2 6 9 9 F: (((6/9)+2)*9) T: (((9+9)-6)*2)
4 4 5 5 F: (((4/5)+4)*5) T: (((5+5)-4)*4)
```

所以请求管理大大在审这篇题解的时候顺带给本题加上 hack 数据（）

完结撒花！

---

## 作者：zxtikes (赞：6)

#### 前言
~~实际上是一些废话~~，今天一个蒟蒻正在为 Splay 的一道题而感到苦恼的时候，这时，机房的一位同志说了几句话。

“这道题题解区代码都很长啊，最长的一个都有 $170$ ”。本蒟蒻感到疑惑，询问了他什么题，于是就有了这篇题解。

------------
#### 题目分析
从题目可以知道，这其实就是一个求 $24$ 点的问题。对于这样的问题，我们会发现，这类问题的解的数量是有限的，换言之，我们可以枚举所有可能的情况，对每种情况算出它的值，看所得到的结果是否等于 $24$ 就可以了。

于是有一个最令人关心的问题来了，复杂度怎么样？

很显然，用暴力的做法，枚举全排列数目是 $n!$ 的，由于题目中 $n=4$ ,所以排列个数为 $24$ ；对于每一种排列的情况，我们考虑运算符号如何填补，由于只考虑加减乘除的四种运算符号，且只需要在三个位置填补运算符号，所以这个地方的复杂度是 $4^3=64$ 。

最难的问题还是运算先后顺序的情况，也就是括号的填补。

由于题目只是四个数的运算，所以括号的情况很少，经过思考和枚举之后，仅仅只有五种情况，分别如下：

1. $((a?b)?(c?d))$
2. $(((a?b)?c)?d)$
3. $((a?(b?c))?d)$
4. $(a?((b?c)?d))$
5. $(a?(b?(c?d)))$

其中 $a,b,c,d$ 表示四个数，问号表示待定填充的运算符号。

综上，这种暴力的时间复杂度为稳定的 $O(24\times64\times5=7680)$

也就是说，这个游戏最多的解也就是 $7680$ 个，而实际上远远达不到这个上限，所以题目中要求字典序最小，我们可以存储每一个解，最后排序就可以了。

最后我们需要最后注意做除法时，被除数不能为零，以及要满足结果不能为分数就可以了。

------------
#### 代码展示
个人感觉还是很简洁，可观性因人而异。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;

int a[5];
string ans[1000005];
int cnt;
inline string sym(int x){//判断符号的函数 
	if(x==1)return "+";
	else if(x==2)return "-";
	else if(x==3)return "*";
	else return "/";
}
inline int calc(int a,int b,int k){//运算的函数 
	if(a==inf||b==inf)return inf;//如果已经又出现过不合法的运算，那么直接返回不合法 
	else if(k==1)return a+b;
	else if(k==2)return a-b;
	else if(k==3)return a*b;
	else{
		if(b==0)return inf;//处理被除数为零的情况 
		else if(a%b==0)return a/b;
		else return inf;//处理题目中的不合法情况 
	}
}
int main(){
	rep(i,1,4)cin>>a[i];
	sort(a+1,a+5);
	do{
		rep(i,1,4)
		    rep(j,1,4)
		        rep(k,1,4){
		        	if(calc(calc(a[1],a[2],i),calc(a[3],a[4],k),j)==24)ans[++cnt]+=string("((")+(char)(a[1]+'0')+sym(i)+(char)(a[2]+'0')+string(")")+sym(j)+string("(")+(char)(a[3]+'0')+sym(k)+(char)(a[4]+'0')+string("))");
		        	if(calc(calc(calc(a[1],a[2],i),a[3],j),a[4],k)==24)ans[++cnt]+=string("(((")+(char)(a[1]+'0')+sym(i)+(char)(a[2]+'0')+string(")")+sym(j)+(char)(a[3]+'0')+string(")")+sym(k)+(char)(a[4]+'0')+string(")");
		        	if(calc(calc(a[1],calc(a[2],a[3],j),i),a[4],k)==24)ans[++cnt]+=string("((")+(char)(a[1]+'0')+sym(i)+string("(")+(char)(a[2]+'0')+sym(j)+(char)(a[3]+'0')+string("))")+sym(k)+(char)(a[4]+'0')+string(")");
		        	if(calc(a[1],calc(calc(a[2],a[3],j),a[4],k),i)==24)ans[++cnt]+=string("(")+(char)(a[1]+'0')+sym(i)+string("((")+(char)(a[2]+'0')+sym(j)+(char)(a[3]+'0')+string(")")+sym(k)+(char)(a[4]+'0')+string("))");
		        	if(calc(a[1],calc(a[2],calc(a[3],a[4],k),j),i)==24)ans[++cnt]+=string("(")+(char)(a[1]+'0')+sym(i)+string("(")+(char)(a[2]+'0')+sym(j)+string("(")+(char)(a[3]+'0')+sym(k)+(char)(a[4]+'0')+string(")))");
		        	//五种情况 
				}
	}while (next_permutation(a+1,a+5));//进行全排列 
	sort(ans+1,ans+cnt+1);//对所有的答案进行排序 
	cout<<ans[1]<<endl;//字典序最小的答案 
	return 0;
}
```



---

## 作者：孤芒星河233 (赞：5)

# P1834 速算问题

[洛谷原题面](https://www.luogu.com.cn/problem/P1834)

## 题意

给定4个1~9的整数，通过括号和加、减、乘、除使结果为24，过程中不允许出现分数。输出时需要将每一步运算的括号补齐，并输出字典序最小的一个

## 思路

~~不知道其他题解怎么写这么多~~
四个数，三个填入运算符的位置，四个运算符，甚至可以直接全排列，现在问题就在字典序上面了。通过查阅 ASCII 码，我们知道字典序优先级为 ( , ) , * , + , - , / , 1 ~ 9 。同时对于确定位置的四个数 $a,b,c,d$ ，很明显有以下三种运算顺序
$$(((a\ \ b)\ \ c)\ \ d)$$
$$((a\ \ b)\ \ ( c\ \ d))$$
$$(a\ \ (b\ \ (c\ \ d)))$$

全排列时，第三种情况等同于第一种情况。

于是我们可以先对四个数字排序，然后对于每个填入运算符的位置，按字典序枚举四个运算符。那么我们是否可以在第一种运算顺序成立时输出结果，第一种运算顺序无解时输出第二次运算顺序的第一个解呢？

请看这两个式子 $(((2*6)+4)+8)$ 与 $(((2*6)*8)/4)$ ，很明显后者的 '*' 字典序在前所以后者才是正解，但全排列时应该是前者优先。因此，我们需要把每一个解的字符串存下来，排序后再输出。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int M=114514;
int a[5],ans,x,y,z,xx,yy,zz,cnt;//x,y,z为第一种运算顺序，xx,yy,zz是第二种
char op[5]={' ','*','+','-','/'},str[20];
string s[M];

int operate(int a,int b,char c){//整数a,b,运算符
    if(c=='+') return a+b;
    else if(c=='-') return a-b;
    else if(c=='*') return a*b;
    else{
        if(b==0||a%b!=0) return M;//这样就不用对非法解再处理了
        return a/b;
    }
}

int main(){
    for(int i=1;i<=4;i++) scanf("%d",&a[i]);
    sort(a+1,a+5);
    do{
        for(int i=1;i<=4;i++){
            xx=x=operate(a[1],a[2],op[i]);
            for(int j=1;j<=4;j++){
                y=operate(x,a[3],op[j]);
                for(int k=1;k<=4;k++){
                    z=operate(y,a[4],op[k]);
                    if(z==24){
                        //sprintf转化输出内容到char[]
                        sprintf(str,"(((%d%c%d)%c%d)%c%d)",a[1],op[i],a[2],op[j],a[3],op[k],a[4]);
                        s[++cnt]=str;
                    }
                    yy=operate(a[3],a[4],op[k]);
                    zz=operate(xx,yy,op[j]);
                    if(zz==24){
                        sprintf(str,"((%d%c%d)%c(%d%c%d))",a[1],op[i],a[2],op[j],a[3],op[k],a[4]);
                        s[++cnt]=str;
                    }
                }
            }
        }
    }while(next_permutation(a+1,a+5));//全排列小技巧
    sort(s+1,s+1+cnt);
    printf("%s",s[1].c_str());//string转char[]
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

楼下大神们的题解本蒟蒻看不懂，所以我弱弱地打了一个深搜。
然后过了，呵呵呵。
代码：
```c
#include<cstring>
#include<cstdio>
typedef char String[20];
int a[4],b[4], ans[4][2];
String x[4],m,mina="zzzzz";
char op[4],data[4];
void print()
{
    for(int i=0;i<4;i++)
    {
        sprintf(x[i],"%c",data[i]);//将原来数组记录一下
    }
    for(int i=0;i<3;i++)
    {
        sprintf(m,"(%s%c%s)",x[ans[i][0]],op[i],x[ans[i][1]]);//去找字典序最小的值
        strcpy(x[ans[i][0]],m);//复制粘贴
    }
    if(strcmp(mina,x[ans[2][0]])>0)
    {
        strcpy(mina,x[ans[2][0]]);//比较
    }
}
void dfs(int k)
{
    if(k==3)
	{
        int i;
        for(i=0;i<4;i++)
            if(a[i]!= 0) break;//将a[i]数组的值存到a[3]里，方便判断
        if(i<4&&a[i]==24)
		{
			print();
		}
        return;
    }
    for(int i=0;i<4;i++)
    {
        for(int j=0;j<4;j++)
        {
            if(i!=j&&a[j]!=0&&a[i]!=0)
            {
                int t1,t2;
                //加操作
                t1=a[i],t2=a[j];
                a[i]=a[i]+a[j];a[j]=0;
                ans[k][0]=i,ans[k][1]=j;//记录本次的加数
				op[k]='+';//记录符号
                dfs(k+1);//再搜一遍
                a[i]=t1,a[j]=t2;
                //减操作
                t1=a[i];
                t2=a[j];
                a[i]=a[i]-a[j];
                a[j]=0;
                ans[k][0]=i;
                ans[k][1]=j;
                op[k]='-';//记录
                dfs(k+1);
                a[i]=t1;
                a[j]=t2;
                //乘
                t1=a[i];
                t2=a[j];
                a[i]=a[i]*a[j];
                a[j]=0;
                ans[k][0]=i;
                ans[k][1]=j;
                op[k]='*';
                dfs(k+1);
                a[i]=t1;
                a[j]=t2;
				//判断会不会出现小数            
                if(a[i]%a[j]==0)
                {
                    t1=a[i];
                    t2=a[j];
                    a[i]=a[i]/a[j];
                    a[j]=0;
                    ans[k][0]=i;
                    ans[k][1]=j;
                    op[k]='/';
                    dfs(k+1);
                    a[i]=t1;
                    a[j]=t2;
                }
            }
        }
    }
}
int main()
{
	char hh;
    memset(ans,-1,sizeof(ans));
    for(int i=0;i<4;i++)
    {
        scanf("%c ", &hh);//我以为会出现A，T，J，Q，K。
        data[i]=hh;
        if(hh=='A') a[i]=1;
        else if(hh=='T') a[i]=10;
        else if(hh=='J') a[i]=11;
        else if(hh=='Q') a[i]=12;
        else if(hh=='K') a[i]=13;
        else
        {
            a[i]=hh-'0';
        }
    }
    memcpy(b,a,sizeof(a));//其实可以删掉。
    dfs(0);//搜素
    printf("%s\n", mina);//输出
    return 0;
}
```

---

## 作者：ByMartClu (赞：2)

## 前言
[题面传送门](https://www.luogu.com.cn/problem/P1834)

这道题难度不大，评蓝的原因大概主要是因为码量比较大。

## 思路分析

看到题解中许多大佬都列出了 $3$ 种 情况甚至 $5$ 种情况，实际上并没有这么多情况。经过我的思考，只需要考虑以下 $2$ 种情况：

- $(((a?b)?c)?d)$

- $((a?b)?(c?d))$

其他的情况，都可以转化成这两种情况。

由于这道题要输出字典序最小的答案，所以我一开始错误地认为先将数字排序，让后就开始快乐地按照字典序开始枚举了，枚举完再生成下一个全排列继续枚举。

使用 ```next_permutation``` 生成全排列可以使代码更简单。


但是后来我发现，这样有个问题，有的时候字典序在后面的才是正解，比如说 $2468$ 这四个数，$(((2\times6)+4)+8)$ 是比 $(((2\times6)\times8)\div4)$ 要大的。

所以说我们需要把所有的可能性情况都存起来排好序，最后输出最小的即可。

这道题容易忽视掉的细节是运算过程中不能有分数和除数不能为 $0$。

## 代码实现

其他题解都有很详细的正解代码，这边我来给大家分享一下~~不用搜索纯枚举的代码。~~


[代码链接](https://www.luogu.com.cn/paste/zxzc46z3)

---

## 作者：闲人 (赞：2)

 ## 题目描述
- 1 ~ 9 的数用四则运算凑成 24。  

- 满足答案字典序最小。  
- 题目保证有解。  
#### [题目传送门](https://www.luogu.com.cn/problem/P1834) 
## 讲解  
### Round1
此题关键在于字典序。先让我们来想一想，什么情况下字典序.可以尽可能小？  $(((3 * 5)+2)+7)$  这是样例给出的答案。  
观察一下，为什么他要把三个括号放在前面？ 显然，因为“()”的 ASCII 码是运算符里（仅限于本题）最小的。所以如果我们可以把式子写成   $(((A\operatorname{opr} B)\operatorname{opr} C)\operatorname{opr} D)$ （注：opr 指运算符）的形式就不需要额外考虑怎么加括号的事了！  
### Round2
分析一下刚刚我们处理字典序的方法，不难发现其中的 BUG！如果遇上了 $ 5 5 5 5 $ 的情况显然用刚才的表达式是无法求出解的，而只能换成 $((5* 5)-(5/5))$ 的形式。所以当我们遇到这样的情况，先看一下第一种情况行不行的通，行不通再用第二种方法。  
### Round3
我们如何来比对那个式子的字典序最小呢？我们可以用一个 cmp 数组初始为“zzzzzzzzzzzzz”然后每搜到一个答案就把它替换掉。
### Round4
深搜的思路也比较简单，先枚举四张牌，在枚举运算符，然后把得到的数值递归到下一层，最后判断是否等于 24 即可。
### Round5
其他的细节会在代码注释里出现，这样方便同学们理解。
## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int src[5]; //面值
char opr[4] = {'+', '-', '*', '/'};
char out[15] = {'(', '(', '(', '\0', '\0', '\0', ')', '\0', '\0', ')', '\0', '\0', ')'};
//数字在（从“0”开始数）第3，5，8，11的位置 
//可以推出公式：除第1个数字在位置3外，第n个数字在3 * n - 1
//运算符同理：第n个运算符在3 * n - 2(符号只有三个)
char cmp[15] = "zzzzzzzzzzzzz";  
bool u[5];
int calc(int a, int b, int cal)
{
    switch (cal)
    {
    case (0):
        return a + b;
    case (1):
        return a - b;
    case (2):
        return a * b;
    case (3):
        return a / b;
    default:
        return -1;
    }
}

void search_second(int d)		//第二种情况 
{
    int A, B;
    int sum;
    for (int a1 = 1; a1 <= 4; a1++)
    {
        for (int a2 = 1; a2 <= 4; a2++)
        {
            if (a2 == a1)
                continue;
            for (int a3 = 1; a3 <= 4; a3++)
            {
                if (a3 == a1 || a3 == a2)
                    continue;
                for (int a4 = 1; a4 <= 4; a4++) //24
                {
                    if (a4 == a1 || a4 == a2 || a4 == a3)
                        continue;
                    for (int i = 0; i < 4; i++)
                    {
                        if (i == 3 && src[a1] % src[a2] != 0)
                        {
                            continue;
                        }
                        for (int j = 0; j < 4; j++)
                        {
                            if (j == 3 && src[a3] % src[a4] != 0)
                            {
                                continue;
                            }
                            A = calc(src[a1], src[a2], i);
                            B = calc(src[a3], src[a4], j);

                            for (int q = 0; q < 4; q++)
                            {
                                if (q == 3)
                                {
                                    if (A != 0 && B != 0)
                                    {
                                        if (A % B != 0)
                                            continue;
                                    }
                                    else
                                        continue;
                                }

                                sum = calc(A, B, q);
                                if (sum == 24)
                                {
                                    int x1 = src[a1], x2 = src[a2], x3 = src[a3], x4 = src[a4];
                                    out[0] = '(';
                                    out[1] = '(';
                                    out[2] = x1 + '0';
                                    out[3] = opr[i];
                                    out[4] = x2 + '0';
                                    out[5] = ')';
                                    out[6] = opr[q];
                                    out[7] = '(';
                                    out[8] = x3 + '0';
                                    out[9] = opr[j];
                                    out[10] = x4 + '0';
                                    out[11] = ')';
                                    out[12] = ')';

                                    if (strcmp(out, cmp) < 0)
                                    {
                                        strcpy(cmp, out);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}

void search(int d, int sum)
{
    if (d > 4)
    {
        if (sum == 24 && strcmp(out, cmp) < 0)
        {
            strcpy(cmp, out);
        }
        return;
    }
    for (int i = 1; i <= 4; i++)
    {
        if (!u[i])
        {
            u[i] = 1;
            if (d == 1)
            {
                out[3] = char(src[i] + '0');
            }
            else
            {
                out[3 * d - 1] = char(src[i] + '0'); //放数字
            }
            for (int j = 0; j < 4; j++)
            {
                int tmps = sum;
                if (j == 3 && tmps % src[i] != 0)
                {
                    continue;
                }
                if (d == 1)
                {
                    search(d + 1, src[i]);
                    break;
                }
                tmps = calc(tmps, src[i], j); //计算当前能算出的数值
                out[3 * d - 2] = opr[j];      //放符号
                search(d + 1, tmps);          //下一个数
                out[3 * d - 2] = '\0';
            }
            if (d == 1)
            {
                out[3] = '\0';
            }
            else
            {
                out[3 * d - 1] = '\0';
            }
            u[i] = 0;
        }
    }
    return;
}
int main()
{
    for (int i = 1; i <= 4; i++)
    {
        cin >> src[i];
    }
    search(1, 0);
    if (cmp[1] == 'z')						//如果第一种情况找不出就换第二种 
    {
        search_second(1);
    }
    puts(cmp);
    return 0;
}
```

## 后记
此题最开始做的时候以为只用第一种情况就能过，然后发现事情不对，硬是把代码写了一百七十多行。暴力的地方可能有点臃肿，希望巨佬们要是有更好的方法可以私信提出。  
改了多次题解，一直LaTeX或英文少空格，不晓得是哪里的问题，望能再得到更详细的解释，谢。

---

## 作者：Milthm (赞：1)

## P1834 题解

### 前置知识

- 模拟

### 题目解法

~~最暴力的解法。~~

通过枚举半天，会发现答案的式子只有可能是以下几种（以下用问号代表运算符）：


1. $(((a?b)?c)?d)$

2. $((a?(b?c))?d)$

3. $(a?(b?(c?d)))$

4. $((a?b)?(c?d))$

5. $(a?((b?c)?d))$

那我们可以先全排列枚举四个数字的方法，然后再枚举三个运算符，最后枚举这 $5$ 种情况，如果等于 $24$ 就把式子转成字符串，放到数组里。排序就可以得到字典序最小的。

容易发现循环只会有 $24\times4^3=1536$ 次，根本不会超时。

代码有点混乱，但是相比其它大佬算短的，建议在清醒的时候写这道题。

### AC 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[8],cnt; 
char op[8]={'+','-','*','/'};
int calc(int x,int y,int op){//计算用的函数
	if(op==0)return x+y;
	if(op==1)return x-y;
	if(op==2)return x*y;
	if(op==3&&y!=0&&x%y==0)return x/y;
	return -114;//如果除数为0或者不整除就返回一个奇怪的值
}
string ans[100005];
string str(int x){//把数字转成字符串
	string s="";
	s.push_back(x+'0');
	return s;
}
int main(){
	for(int i=1;i<=4;++i)cin>>a[i];
	for(int qwq=1;qwq<=24;++qwq){//枚举全排列
		for(int i=0;i<4;++i){
			for(int j=0;j<4;++j){
				for(int k=0;k<4;++k){//枚举三个运算符
                //以下为 5 种情况的判断
					if(calc(calc(calc(a[1],a[2],i),a[3],j),a[4],k)==24){
						ans[++cnt]="((("+str(a[1])+op[i]+str(a[2])+")"+op[j]+str(a[3])+")"+op[k]+str(a[4])+")";
					}
					if(calc(calc(a[1],calc(a[2],a[3],j),i),a[4],k)==24){
						ans[++cnt]="(("+str(a[1])+op[i]+"("+str(a[2])+op[j]+str(a[3])+"))"+op[k]+str(a[4])+")";
					}
					if(calc(a[1],calc(a[2],calc(a[3],a[4],k),j),i)==24){
						ans[++cnt]="("+str(a[1])+op[i]+"("+str(a[2])+op[j]+"("+str(a[3])+op[k]+str(a[4])+")))";
					}
					if(calc(calc(a[1],a[2],i),calc(a[3],a[4],k),j)==24){
						ans[++cnt]="(("+str(a[1])+op[i]+str(a[2])+")"+op[j]+"("+str(a[3])+op[k]+str(a[4])+"))";
					}
					if(calc(a[1],calc(calc(a[2],a[3],j),a[4],k),i)==24){
						ans[++cnt]="("+str(a[1])+op[i]+"(("+str(a[2])+op[j]+str(a[3])+")"+op[k]+str(a[4])+"))";
					}
				}
			}
		}
		next_permutation(a+1,a+5);//STL 的函数，很好用
	}
	sort(ans+1,ans+cnt+1);//排序
	cout<<ans[1];//输出字典序最小的一个
	return 0;
}

```





---

## 作者：_LAUV_ (赞：1)

一看完题 就感觉是一道~~神秘~~的搜索题

但直接地搜索似乎有点复杂 特别是运算优先级和括号匹配的处理

观察到数据很小 每次都只有4个数字 所以 干脆直接枚举好了

所以把式子看成

## T1 . f1 . T2 . f2 . T3 . f3 . T4

(t代表数字 f代表符号）

然后每次在最外面都枚举一波f 和 t

那每一次运算的优先级怎么枚举 还有 最终结果的字符串要如何构造呢？

（想了一个特别原始 被我写的异常复杂 的搜索）

（嫌麻烦可以借鉴一下思想 然后自己去想个实现方法）

大概是构造成像下图一样的一棵DFS树 然后每一次每个节点要么是运算符要么是数字

在回溯的时候将括号加上s=“（” +s1+ss+s2+ ")"

![](https://cdn.luogu.com.cn/upload/pic/31082.png)


嗯 大概就是这样吧 不过DFS真的被我写的好复杂（见我~~又原始又复杂又丑陋~~的代码）

但其实 枚举运算符的优先级时还要分五种情况讨论

![](https://cdn.luogu.com.cn/upload/pic/31152.png)


就是最后算第2个符号、最后算第1个符号。。。

```c
int DFS(int fst,int dp,int k,int kx,string&s)
```

所以我的DFS就变成了这样：

fst 代表如果最后算1和3 第二层要算的2或1/3。

dp 是此时的深度。

k 是此时运算符的位置（1,2,3）。

ks 是这个节点的数字（如果没到叶子节点就是0。

s 就是以这个点位根节点的子树的字符串了。 每次往上传然后连接起来成为整个式子。

哦请注意做除法时分母不能为0 （因为这个错找了好久

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
string fn[10000],st;
int tot=0;
int a[5],as[5],i,j,k,fs[5];
bool v[5];
inline void read(int &v){
    v=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}

char cs[20];
bool vis[5];
int DFS(int fst,int dp,int k,int kx,string&s){
    vis[k]=1;
    if(kx!=0){
        sprintf(cs,"%d",as[kx]);
        int len=strlen(cs);
        for(int i=0;i<len;++i)s=s+cs[i];
        vis[k]=0;
        return as[kx];

    }

    string s1,s2,ss;
    int t1,t2;
    if(k==2&&dp==1){
        t1=DFS(fst,dp+1,1,0,s1);
        t2=DFS(fst,dp+1,3,0,s2);    
    }
    if(k==1&&dp==1){
        t1=DFS(fst,dp+1,0,k,s1);
        t2=DFS(fst,dp+1,fst,0,s2);
    }
    if(k==3&&dp==1){
        t1=DFS(fst,dp+1,fst,0,s1);
        t2=DFS(fst,dp+1,0,k+1,s2);
    }

    if(k==2&&dp==2){
        if(!vis[1])t1=DFS(fst,dp+1,1,0,s1); else t1=DFS(fst,dp+1,0,k,s1);
        if(!vis[3])t2=DFS(fst,dp+1,3,0,s2); else t2=DFS(fst,dp+1,0,k+1,s2);
    }
    if(k==1&&dp==2){
        if(!vis[2])t2=DFS(fst,dp+1,2,0,s2); else t2=DFS(fst,dp+1,0,k+1,s2);
        t1=DFS(fst,dp+1,0,k,s1);
    }

    if(k==3&&dp==2){
        if(!vis[2])t1=DFS(fst,dp+1,2,0,s1); else t1=DFS(fst,dp+1,0,k,s1);
        t2=DFS(fst,dp+1,0,k+1,s2);
    }   

    if(dp==3){
        t1=DFS(fst,dp+1,0,k,s1);
        t2=DFS(fst,dp+1,0,k+1,s2);
    }

    if(t1==-1||t2==-1){vis[k]=0;return -1;}

    int fx=fs[k]; int tx;
    if(fx==1)tx=t1+t2,ss="+";
    if(fx==2)tx=t1-t2,ss="-";
    if(fx==3)tx=t1*t2,ss="*";
    if(fx==4){
        if(t2==0){vis[k]=0;return -1;}
        if(t1%t2!=0){vis[k]=0;return -1;}
        tx=t1/t2; ss="/";
    }   

    s="("+s1+ss+s2+")";

    vis[k]=0;
    return tx;  
} 

int main(){
    for(i=1;i<=4;++i)read(a[i]);

    for(int t1=1;t1<=4;++t1)for(int t2=1;t2<=4;++t2)
    for(int t3=1;t3<=4;++t3)for(int t4=1;t4<=4;++t4){
        memset(v,0,sizeof(v)); 
        bool fg=0;
        v[t1]=1; v[t2]=1; v[t3]=1; v[t4]=1;
        for(i=1;i<=4;++i)if(v[i]==0)fg=1;         
        if(fg)continue;
        as[1]=a[t1]; as[2]=a[t2]; as[3]=a[t3]; as[4]=a[t4];
        for(int f1=1;f1<=4;++f1)for(int f2=1;f2<=4;++f2)for(int f3=1;f3<=4;++f3){
            fs[1]=f1; fs[2]=f2; fs[3]=f3;
            int x;
            string s;

            x=DFS(0,1,2,0,s);   if(x==24)fn[++tot]=s;  //2最后算 

            x=DFS(1,1,3,0,s);   if(x==24)fn[++tot]=s;  //3最后算 第二个算1 
            x=DFS(2,1,3,0,s);   if(x==24)fn[++tot]=s;  //3最后算 第二个算2 

            x=DFS(3,1,1,0,s);   if(x==24)fn[++tot]=s;  //1最后算 第二个算3 
            x=DFS(2,1,1,0,s);   if(x==24)fn[++tot]=s;  //1最后算 第二代算2 
        }
    }
    sort(fn+1,fn+tot+1);
    cout<<fn[1];
}
```


---

## 作者：dormantbs (赞：1)

emmm其实这就是一道很裸的搜索题，具体思路就是枚举所有数字的全排列与符号的全排列，再check输出就好了。

关于字典序的问题我们发现对括号有三种种情况：(((a+b)+c)+d)或((a+b)+(c+d))或(a+(b+(c+d))) 然后会发现第一种和第三种其实是完全等效的。

根据ASII的排列，'(' 是排在最前的，所有我们果断选择第一种啊\_(:зゝ∠)\_

所以就跑两遍dfs，第一遍处理(((a+b)+c)+d)，第二遍处理((a+b)+(c+d))，至于为什么不能一起处理还是字典序的锅orz

然后还有一个细节就是数字和符号要一起搜，否则还是字典序会出事，仔细想想为什么吧2333

```cpp
#include<cstdio>
#include<algorithm> 
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
#define Files "fun"
using namespace std;
#ifdef Files
#define redir(name) freopen(name".in","r",stdin),freopen(name".out","w",stdout)
inline char gc(){
    static char buf[1<<17],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<17,stdin),p1==p2)?EOF:*p1++;
}
#else
#define gc getchar
#endif
template <class T>
inline void read(T&n){
    int sign=1;register char ch=gc();
    for(n=0;(ch<'0'||ch>'9')&&ch!='-';ch=gc());
    for(ch=='-'?ch=gc(),sign=-1:0;ch>='0'&&ch<='9';ch=gc())(n*=10)+=ch-'0';
    n*=sign;
}
// 0 1 3 5 * + - /
const int op[5]={0,0,1,3,5};
int s[9],num[5];
bool flag,vis[5];
inline int cac1(){
    register int sum=s[1];
    for(register int i=2;i<=6;i+=2)
        switch(s[i]){
            case 0:sum*=s[i+1]; break;
            case 1:sum+=s[i+1]; break;
            case 3:sum-=s[i+1]; break;
            case 5:if(sum%s[i+1]) return -1;
                else sum/=s[i+1]; break;
        }
    return sum;
}
inline int cac2(){
    register int sum1=s[1],sum2=s[5];
    switch(s[2]){
        case 0:sum1*=s[3]; break;
        case 1:sum1+=s[3]; break;
        case 3:sum1-=s[3]; break;
        case 5:if(sum1%s[3]) return -1;
            else sum1/=s[3]; break;
    }
    switch(s[6]){
        case 0:sum2*=s[7]; break;
        case 1:sum2+=s[7]; break;
        case 3:sum2-=s[7]; break;
        case 5:if(sum2%s[7]) return -1;
            else sum2/=s[7]; break;
    }
    switch(s[4]){
        case 0:return sum1*sum2;
        case 1:return sum1+sum2;
        case 3:return sum1-sum2;
        case 5:if(sum1%sum2) return -1;
            else return sum1/=sum2;
    }
}
void dfs1(int step){
    if(flag) return;
    if(step==8){
        if(cac1()==24)
            printf("(((%d%c%d)%c%d)%c%d)\n",s[1],s[2]+'*',s[3],s[4]+'*',s[5],s[6]+'*',s[7]),flag=1;
        return;    
    }
    if(step&1){
        for(register int i=1;i<=4;++i)
            if(!flag&&!vis[i])vis[i]=1,s[step]=num[i],dfs1(step+1),vis[i]=0;
    }
    else for(register int i=1;i<=4;++i)if(!flag) s[step]=op[i],dfs1(step+1);
}
void dfs2(int step){
    if(flag) return;
    if(step==8){
        if(cac2()==24)
            printf("((%d%c%d)%c(%d%c%d))\n",s[1],s[2]+'*',s[3],s[4]+'*',s[5],s[6]+'*',s[7]),flag=1;
        return;    
    }
    if(step&1){
        for(register int i=1;i<=4;++i)
            if(!flag&&!vis[i])vis[i]=1,s[step]=num[i],dfs2(step+1),vis[i]=0;
    }
    else for(register int i=1;i<=4;++i) if(!flag)s[step]=op[i],dfs2(step+1);
}
int main(){
#ifdef Files
    if(fopen(Files".in","r")) redir(Files);
#endif
    for(register int i=1;i<=4;++i) read(num[i]);
    sort(num+1,num+5);
    dfs1(1); 
    if(!flag) dfs2(1);
    return 0;
}
```

---

## 作者：Furina_Saikou (赞：0)

# 思路

爆搜即可。

先枚举数字的全排列，然后在枚举三个运算符用什么，最后枚举运算顺序，如果可以算得 $24$，就将答案转为字符串，最后按字典序将所有答案字符串排序并输出最小即可。

运算顺序的枚举很简单，因为括号的字典序排在四个运算符前面，所以要将三个括号都用上，最终我们有五种可能的运算顺序：

1. `(((a?b)?c)?d)`
2. `((a?b)?(c?d))`
3. `((a?(b?c))?d)`
4. `(a?((b?c)?d))`
5. `(a?(b?(c?d)))`

思路不难，用深度优先搜索或者循环嵌套都能实现，代码较繁，注意细节不要出错。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=114514;
int a[N],vis[N],u[N],cnt;
char fu[N]="+-*/(",f[N];
string ans[N];
inline string change(int a)
{
	static string x="";
	return x+(char)(a+'0');
}
inline int calc(int a,int b,char c)
{
	if(c=='+')return a+b;
	if(c=='-')return a-b;
	if(c=='*')return a*b;
	if(c=='/'&&b!=0)return (a%b==0?a/b:114514ll);//注意除法的除数不能为零，而且必须整除
	return 114514ll;
}
void check()
{
	static string s;
	if(calc(calc(calc(u[1],u[2],f[1]),u[3],f[2]),u[4],f[3])==24)
	{
		s="(((";
		s=s+change(u[1])+f[1]+change(u[2])+")"+f[2]+change(u[3])+")"+f[3]+change(u[4])+")";
		ans[++cnt]=s;
	}else if(calc(calc(u[1],u[2],f[1]),calc(u[3],u[4],f[3]),f[2])==24)
	{
		s="((";
		s=s+change(u[1])+f[1]+change(u[2])+")"+f[2]+"("+change(u[3])+f[3]+change(u[4])+"))";
		ans[++cnt]=s;
	}else if(calc(calc(u[1],calc(u[2],u[3],f[2]),f[1]),u[4],f[3])==24)
	{
		s="((";
		s=s+change(u[1])+f[1]+"("+change(u[2])+f[2]+change(u[3])+"))"+f[3]+change(u[4])+")";
		ans[++cnt]=s;
	}else if(calc(u[1],calc(calc(u[2],u[3],f[2]),u[4],f[3]),f[1])==24)
	{
		s="(";
		s=s+change(u[1])+f[1]+"(("+change(u[2])+f[2]+change(u[3])+")"+f[3]+change(u[4])+"))";
		ans[++cnt]=s;
	}else if(calc(u[1],calc(u[2],calc(u[3],u[4],f[3]),f[2]),f[1])==24)
	{
		s="(";
		s=s+change(u[1])+f[1]+"("+change(u[2])+f[2]+"("+change(u[3])+f[3]+change(u[4])+")))";
		ans[++cnt]=s;
	}
}
void solve(int k)
{
	if(k>3)
	{
		check();
		return;
	}
	for(int i=1;i<=4;i++)
	{
		f[k]=fu[i];
		solve(k+1);
	}
}
void dfs(int k)
{
	if(k>4)
	{
		solve(1);
		return;
	}
	for(int i=1;i<=4;i++)
	{
		if(vis[i])continue;
		vis[i]=1;//数字不能重复，但是上面的符号可以
		u[k]=a[i];
		dfs(k+1);
		vis[i]=0;
	}
}
signed main()
{
	sort(fu,fu+5);
	for(int i=1;i<=4;i++)cin>>a[i];
	dfs(1);
	sort(ans+1,ans+cnt+1);//排序答案
	cout<<ans[1];
}
```

---

## 作者：kingho11 (赞：0)

## 思路
这道题还是非常简单的，一道小模拟，暴搜即可，但是细节很多，我结合着代码来讲。

## AC CODE+细节
```
#include<bits/stdc++.h>
using namespace std;
int a[10],cntt;//a数组就是存数字的数组，cntt是记录有多少个答案的 
bool use[10];//记录这个数字有没有被用过 
string jie[1000005];//用来存放解的 
string change(int x)//将一个数字转换为运算符号 
{
	if(x==0) return "+";
	if(x==1) return "-";
	if(x==2) return "*";
	if(x==3) return "/";
}
string change_num(int x)//将一个数字转换为字符形式 
{
	string s="";
	s+=(char)(x+'0');
	return s; 
}
int calc(int a,int fh,int b)//计算函数
{
	if(fh==0) return a+b;
	if(fh==1) return a-b;
	if(fh==2) return a*b;
	if(fh==3) return a/b;
}
bool fl=false;
void dfs(int step,int sum,string cz)//step是现在选择了多少个数字进行运算，sum是现在算出来的值，cz是现在的计算方法序列 
{
	if(step==4 && sum==24)//找到解了
	{
		jie[++cntt]=cz;//将这种计算方法存到答案中 
		return ;
	}
	if(step==0)//如果现在什么都没有选择，就要选择两个一起进行计算，以为如果选择一个的话，就不知道选择什么运算符，会很难处理且很麻烦。 
	{
		for(int i=1;i<=4;i++)//枚举第一个数 
		{
			for(int j=1;j<=4;j++)//枚举第二个数 
			{
				if(i==j) continue;//如果选到了同样的位置就要continue 
				for(int fh=0;fh<4;fh++)//枚举运算符 
				{
					if(fh==3 && (a[i]%a[j]!=0 || a[j]==0)) continue;//特判有没有除数为0的情况或者不整除的情况，这些都是不可行的 
					string o="";
					o="("+change_num(a[i])+change(fh)+change_num(a[j])+")";//更新操作序列（更新前序列是空的） 
					use[i]=use[j]=1;
					dfs(step+2,calc(a[i],fh,a[j]),o);//搜索下一层 
					use[i]=use[j]=0;
				}
			}
		}
		return ;
	}
	//如果现在已经有选择好的数了，那么就可以选择一个运算符加在现在的计算方法序列后面，再选择一个数字与他进行运算 
	for(int i=1;i<=4;i++)//枚举加在运算符后面的数字 
	{
		if(use[i]) continue;//如果被使用过就要continue 
		for(int j=0;j<4;j++)//枚举运算符 
		{
			if(j==3 && (sum%a[i]!=0 || a[i]==0)) continue;//跟上一个特判除法的意思一样 
			use[i]=1;
			string o=cz;
			o="("+o;
			o+=change(j)+change_num(a[i])+")";//更新操作序列 
			dfs(step+1,calc(sum,j,a[i]),o);//搜索下一层，更新sum 
			use[i]=0;
		}
	}
	//如果现在选好了两个数，我们不仅可以在后面加一个符号，加一个数字，还可以一次性加两个数，进行两次运算 
	if(step==2)
	{
		for(int i=1;i<=4;i++)//枚举第一个数 
		{
			for(int j=1;j<=4;j++)//枚举第二个数 
			{
				if(i==j || use[i]==1 || use[j]==1) continue;//如果被使用过或者选到了一个数字上面就要continue 
				for(int fh1=0;fh1<4;fh1++)//枚举第一个符号 
				{
					for(int fh2=0;fh2<4;fh2++)//枚举第二个符号 
					{
						if(fh2==3 && (a[i]%a[j]!=0 || a[j]==0)) continue;//特判除法 
						if(fh1==3 && (calc(a[i],fh2,a[j])==0 || sum%calc(a[i],fh2,a[j])!=0)) continue;//特判除法 
						string o=cz;
						use[i]=use[j]=1;
						o="("+o;
						o+=change(fh1)+"("+change_num(a[i])+change(fh2)+change_num(a[j])+"))";//更新操作序列 
						dfs(step+2,calc(sum,fh1,calc(a[i],fh2,a[j])),o);//搜索下一层，更新sum 
						use[i]=use[j]=0;
					}
				}
			}
		}
	}
}
int main()
{
	cin>>a[1]>>a[2]>>a[3]>>a[4];//输入 
	dfs(0,0,"");//开始搜索 
	sort(jie+1,jie+1+cntt);//因为要选择字典序小的，所以要将所有的操作方式排序之后再输出字典序最小的一种 
	cout<<jie[1];//输出字典序最小的一种操作方法 
} 
```

---

## 作者：cheng2010 (赞：0)

# 速算游戏
## 题意
经典问题之 $24$ 点。
## 思路

先排序，再通过 `next_permutation` 求全排列，可以发现，有效的计算方案只有两个：

- $((a?b)?(c?d))$
- $(((a?b)?c)?d)$

而其他的都可以转换成此，这时，题目就很显然了，枚举四个运算符，再套入公式即可。

还有一个问题：怎么输出？

只需要把每次的式子用 `string` 记录一下，再拍一下序就好啦。

## code
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int a[11];
string ans[114514];
int cnt;
inline string fu(int x)
{
	if(x==1)return "+";
	else if(x==2)return "-";
	else if(x==3)return "*";
	else return "/";
}
inline int js(int a,int ys,int b)
{
	if(a==-1||b==-1) return -1;
	if(ys==1) return a+b;
	if(ys==2) return a-b;
	if(ys==3) return a*b;
	if(ys==4)
	{
		if(b==0) return -1;
		if(a%b!=0) return -1;
		return a/b;
	}
}
signed main()
{
	for(int i=1;i<=4;i++) cin>>a[i];
	sort(a+1,a+5);
	do
	{
		for(int s1=1;s1<=4;s1++)
		{
			for(int s2=1;s2<=4;s2++)
			{
				for(int s3=1;s3<=4;s3++)
				{
					if(js(js(a[1],s1,a[2]),s2,js(a[3],s3,a[4]))==24)
					{
						ans[++cnt]+=string("((")+(char)(a[1]+'0')+fu(s1)+(char)(a[2]+'0')+string(")")+fu(s2)+string("(")+(char)(a[3]+'0')+fu(s3)+(char)(a[4]+'0')+string("))");
					}
					if(js(js(js(a[1],s1,a[2]),s2,a[3]),s3,a[4])==24)
					{
						ans[++cnt]+=string("(((")+(char)(a[1]+'0')+fu(s1)+(char)(a[2]+'0')+string(")")+fu(s2)+(char)(a[3]+'0')+string(")")+fu(s3)+(char)(a[4]+'0')+string(")");
					}
				}
			}
		}
	}while(next_permutation(a+1,a+5));
	sort(ans+1,ans+1+cnt);
	cout<<ans[1];
}
```

---

## 作者：nomonick (赞：0)

[P1834 速算游戏](https://www.luogu.com.cn/problem/P1834)

模拟赛上，打的累死老子的。

首先通过打表找出了 $(,),*,+,-,/,0,1,2,3,4,5,6,7,8,9$ 的 $ASCLL$ 码的排序，及字典序（同上）

看出括号的优先级高于一切，所以必须加上，而且却多越好

进过分析，只有加减乘除的二十四点，两两最多三组运算，所以最多只加三个括号，如下：

$$
(((a\ \ \ b) \ \ \ c) \ \ \ d)
$$
$$
((a\ \ \ b)\ \ \ (c\ \ \ d))
$$
$$
(a\ \ \ (b\ \ \ (c\ \ \ d)))
$$

因为第一种与第三种的写法基本相同，所以可以通过转化把第三种变成一种。

所以第一二两中包含了所有的运算可能。

之后要保证在数字上最优，所以将四个数字升序排序即可。

最优依照字典序填入运算符，检验，这个过程深搜即可。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int op[5]={0,0,1,3,5};

inline int read()
{
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9')
		ch = getchar();
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int s[9],num[5];
bool flag,vis[5];

inline int check1()
{
    int sum=s[1];
    for(int i=2;i<=6;i+=2)
    {
        switch(s[i])
        {
            case 0:sum*=s[i+1]; break;
            case 1:sum+=s[i+1]; break;
            case 3:sum-=s[i+1]; break;
            case 5:if(sum%s[i+1]) return -1;
                else sum/=s[i+1]; break;
        }
    }
    return sum;
}

inline int check2()
{
    int sum1=s[1],sum2=s[5];
    switch(s[2])
    {
        case 0:sum1*=s[3]; break;
        case 1:sum1+=s[3]; break;
        case 3:sum1-=s[3]; break;
        case 5:if(sum1%s[3]) return -1;
            else sum1/=s[3]; break;
    }
    switch(s[6])
    {
        case 0:sum2*=s[7]; break;
        case 1:sum2+=s[7]; break;
        case 3:sum2-=s[7]; break;
        case 5:if(sum2%s[7]) return -1;
            else sum2/=s[7]; break;
    }
    switch(s[4])
    {
        case 0:return sum1*sum2;
        case 1:return sum1+sum2;
        case 3:return sum1-sum2;
        case 5:if(sum1%sum2) return -1;
            else return sum1/=sum2;
    }
}

void dfs1(int step)
{
    if(flag) return;
    if(step==8)
    {
        if(check1()==24)
        {
            printf("(((%d%c%d)%c%d)%c%d)\n",s[1],s[2]+'*',s[3],s[4]+'*',s[5],s[6]+'*',s[7]),flag=1;
        }
        return;    
    }
    if(step&1)
    {
        for(int i=1;i<=4;++i)
        {
            if(!flag&&!vis[i])
            {
				vis[i]=1,s[step]=num[i],dfs1(step+1),vis[i]=0;
            }
        }
    }
    else 
    {
		for(int i=1;i<=4;++i)
        {
			if(!flag) 
            {
				s[step]=op[i],dfs1(step+1);
            }
        }
    }
}

void dfs2(int step)
{
    if(flag) return;
    if(step==8)
    {
        if(check2()==24)
        {
            printf("((%d%c%d)%c(%d%c%d))\n",s[1],s[2]+'*',s[3],s[4]+'*',s[5],s[6]+'*',s[7]),flag=1;
        }
        return;    
    }
    if(step&1)
    {
        for(int i=1;i<=4;++i)
        {
            if(!flag&&!vis[i])
            {
                vis[i]=1,s[step]=num[i],dfs2(step+1),vis[i]=0;
            }
        }
    }
    else 
    {
		for(int i=1;i<=4;++i) 
        {
			if(!flag)
            {
				s[step]=op[i],dfs2(step+1);
            }
        }
    }
}

int main(){
    for(int i=1;i<=4;++i) 
    {
		num[i] = read();
    }
    sort(num+1,num+5);
    dfs1(1); 
    if(!flag)
    {
		dfs2(1);
    }
    return 0;
}
```

---

## 作者：风手 (赞：0)

 实测这题是可以七重循环过的，我们用abcd来代表四个数字的编号，用xyz来表示运算符的标号。那么我们只需要枚举这四个数和三个运算符就行了。
  但是有了四个数字和三个对应运算符，我们还得考虑括号匹配（即优先级）的问题。
  显然我们可以有这两种形式
  1：((（a+b）+c）+d);
  2: ((a+b)+(c+d));
 所以我们只需要枚举出数字和运算符后分别模拟两遍就行了
 ```pascal
const f:array[1..4] of char=('+','-','*','/');//运算符
var k:array[1..4] of integer;
 i,j,n,m,p,q,t,w:integer;
 a,b,c,d,x,y,z:integer;  s1,s2,s3,ans:string; v:real; flag:boolean;
function count(x,y:integer; ch:integer):integer;//计算
 begin
   case ch of
    1:exit(x+y);
    2:exit(x-y);
    3:exit(x*y);
    4:exit(x div y);
      end;
 end;
begin
    for i:=1 to 4 do
     read(k[i]);
                ans:='z';
    for a:=1 to 4 do
     for b:=1 to 4 do
      if (a<>b)then
      for c:=1 to 4 do
       if (c<>a)and(c<>b) then
       for d:=1 to 4 do //枚举四个数字
        if (a<>d)and(d<>b)and(d<>c) then
         for x:=1 to 4 do
          for y:=1 to 4 do
           for z:=1 to 4 do begin //枚举三个运算符
            flag:=true;
{1:(a+b)+(c+d)} if (x<>4)or(k[a] mod k[b]=0) then
               p:=count(k[a],k[b],x)
             else flag:=false;//显然，如果中间值出现小数，这个模拟就是不成立的
            if flag then begin
              if (y<>4)or(p mod k[c]=0) then
               p:=count(p,k[c],y)
              else flag:=false;
            if flag then begin
              if(z<>4)or(p mod k[d]=0) then
               p:=count(p,k[d],z)
              else flag:=false;
            if flag then
              if p=24 then begin
               s1:='('+chr(k[a]+48)+f[x]+chr(k[b]+48)+')';
               s1:='('+s1+f[y]+chr(k[c]+48)+')';
               s1:='('+s1+f[z]+chr(k[d]+48)+')';

              if (s1<ans)or(ans='z') then
                                  ans:=s1;
                           end;
                          end;
                        end;
            flag:=true;
{2:(((a+b)+c)+d)}if (x<>4)or(k[a] mod k[b]=0) then
               p:=count(k[a],k[b],x)
             else flag:=false;
           if flag then begin
              if(z<>4)or(k[c] mod k[d]=0) then
               q:=count(k[c],k[d],z)
              else flag:=false;
           if flag then begin
              if (y<>4)or((q<>0)and(p mod q=0)) then
               p:=count(p,q,y)
              else flag:=false;
            if flag then
             if p=24 then begin
              s1:='('+chr(k[a]+48)+f[x]+chr(k[b]+48)+')';
              s2:='('+chr(k[c]+48)+f[z]+chr(k[d]+48)+')';
              s1:='('+s1+f[y]+s2+')';

             if (s1<ans)or(ans='z') then
                                   ans:=s1;
                         end;
                        end;
                       end;
                           end;
      writeln(ans);
end.

---


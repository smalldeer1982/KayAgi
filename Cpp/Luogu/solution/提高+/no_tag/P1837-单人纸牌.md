# 单人纸牌

## 题目描述

单人纸牌游戏，共 $36$ 张牌分成 $9$ 叠，每叠 $4$ 张牌面向上。每次，游戏者可以从某两个不同的牌堆最顶上取出两张牌面相同的牌（如黑桃 $10$ 和梅花 $10$）并且一起拿走。如果最后所有纸牌都被取走，则游戏者就赢了，否则游戏者就输了。

George 很热衷于玩这个游戏，但是一旦有时有多种选择的方法，George 就不知道取哪一种好了，George 会从中随机地选择一种走，例如：顶上的 $9$ 张牌为 $\tt KS,\tt KH,\tt KD,\tt 9H,\tt 8S,\tt 8D,\tt 7C,\tt 7D,\tt 6H$，显然有 $5$ 种取法：$\tt (KS,KH),(KS,KD),(KH,KD),(8S,8D),(7C,7D)$，当然 George 取到每一种取法的概率都是 $1/5$。

有一次，George 的朋友 Andrew 告诉他，这样做是很愚蠢的，不过 George 不相信，他认为如此玩最后成功的概率是非常大的。请写一个程序帮助 George 证明他的结论：计算按照他的策略，最后胜利的概率。

## 样例 #1

### 输入

```
AS 9S 6C KS 
JC QH AC KH 
7S QD JD KD 
QS TS JS 9H 
6D TD AD 8S 
QC TH KC 8D 
8C 9D TC 7C 
9C 7H JH 7D 
8H 6S AH 6H ```

### 输出

```
0.589314```

# 题解

## 作者：zimujun (赞：7)

#### 写在前面

- 感谢巨佬 yu__xuan 的帮助！
- 原本题解区的大佬们大都写的九层循环，其实此题如果写成状压，可以将这九层循环写成一层，非但简洁、代码可读性强，常数也比直接九维 dp 小。

#### 算法思路

由于每一行都只有四张牌，考虑写成五进制状压 dp。

设当前状态为 $t$，则五进制状压 dp 取出第 $i$ 行的状态的方式:$\frac{t}{5^i}\!\!\!\!\mod 5$（视初始行为第 $0$ 行）

因此，若设第 $i$ 行的第 $j$ 张牌的点数为 $a_{i,j}$,则状态转移方程为：

$$\large f_{t - 5^{p1} - 5^{p2}} = f_{t - 5^{p1} - 5^{p2}}  + f_t \times p(a_{p1,\frac{t}{5^p1}\!\!\!\!\mod 5} = a_{p2,\frac{t}{5^p2}\!\!\!\!\mod 5})$$

其中 $p$ 为此次转移的概率，等于从状态 $t$ 能转移到的状态数总和的倒数。

边界条件: $f_{5^9 - 1} = 1$。

倒序枚举所有状态，每当找到一个当前答案不为 $0$ 的状态时，先统计出它能更新到的状态数，算出转移的概率 $P$，然后用该状态去更新它所能更新到的状态的答案。

由于一直在拿牌，表示状态的变量会逐渐减小，倒序枚举状态时可行的。

#### Tips

- 读入的时候用类似于快速读入的方式过滤一下不合法字符可以极大地简化读入部分的代码。

- 扑克牌的点数不等同于真实的扑克牌的点数，因此统计的时候不需要再对点数进行处理，直接将 `char` 转成 `int` 存下来即可。

#### Code

```cpp
#include<bits/stdc++.h>
#define LF double

const int pow5[] = {1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125}; 
using namespace std;

LF f[1953125];
int a[10][5];

char Getch() {char ch = getchar(); while((!isalpha(ch)) && (!isdigit(ch))) ch = getchar(); return ch;}

int main() {
	for(register int i = 0; i < 9; ++i) {
		for(register int j = 1; j <= 4; ++j) {
			a[i][j] = Getch(); Getch();
		}
	}
	f[1953124] = 1.0;
	for(register int t = pow5[9] - 1; t >= 0; --t) {
		if(f[t] == 0) continue;
		LF choise = 0;
		for(register int p1 = 0; p1 < 9; ++p1) {
			for(register int p2 = p1 + 1; p2 < 9; ++p2) {
				if((a[p1][t / pow5[p1] % 5] == a[p2][t / pow5[p2] % 5]) && ((t / pow5[p1] % 5) > 0) && ((t / pow5[p2] % 5) > 0)) choise++;
			}
		}
		LF P = f[t] * 1.0 / choise;
		for(register int p1 = 0; p1 < 9; ++p1) {
			for(register int p2 = p1 + 1; p2 < 9; ++p2) {
				if((a[p1][t / pow5[p1] % 5] == a[p2][t / pow5[p2] % 5]) && ((t / pow5[p1] % 5) > 0) && ((t / pow5[p2] % 5) > 0)) {
					f[t - pow5[p1] - pow5[p2]] += P;
				}
			}
		}
	}
	printf("%lf", f[0]);
	return 0; 
}
```

---

## 作者：jixuan (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P1837)

### 思路
我们首先看看题目，发现牌仅仅只有 $36$ 张，分成 $9$ 叠，每叠 $4$ 张。我们不妨**大胆亿点**，开一个九维数组 $dp[5][5][5][5][5][5][5][5][5]$，表示每一堆选 $i$ 个的概率（$dp[0][0][0][0][0][0][0][0][0]$ 概率为 $1$，不取一定行），最后我们再用九层循环枚举，$ans=dp[4][4][4][4][4][4][4][4][4]$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10];
double dp[5][5][5][5][5][5][5][5][5];
char a[1001][10],s[10];
int main()
{
	dp[0][0][0][0][0][0][0][0][0]=1;
	for(int x=1;x<=9;x++)
	{
		for(int i=4;i;--i)
		{
			scanf("%s",s+1);
			a[x][i]=s[1];
		}
	}
	//枚举 
	for(f[1]=0;f[1]<=4;f[1]++)
		for(f[2]=0;f[2]<=4;f[2]++)
			for(f[3]=0;f[3]<=4;f[3]++)
				for(f[4]=0;f[4]<=4;f[4]++)
					for(f[5]=0;f[5]<=4;f[5]++)
						for(f[6]=0;f[6]<=4;f[6]++)
							for(f[7]=0;f[7]<=4;f[7]++)
								for(f[8]=0;f[8]<=4;f[8]++)
									for(f[9]=0;f[9]<=4;f[9]++)
										if(dp[f[1]][f[2]][f[3]][f[4]][f[5]][f[6]][f[7]][f[8]][f[9]])
										{
											double p=dp[f[1]][f[2]][f[3]][f[4]][f[5]][f[6]][f[7]][f[8]][f[9]];
											int cnt=0;//一定要清零 
											for(int i=1;i<9;i++)
												for(int j=i+1;j<=9;j++)
													if(f[i]<4&&f[j]<4&&a[i][f[i]+1]==a[j][f[j]+1])
														cnt++;
											if(cnt>0)
												for(int i=1;i<9;i++)
													for(int j=i+1;j<=9;j++)
														if(f[i]<4&&f[j]<4&&a[i][f[i]+1]==a[j][f[j]+1]) 
														{
															f[i]++;
															f[j]++;
															dp[f[1]][f[2]][f[3]][f[4]][f[5]][f[6]][f[7]][f[8]][f[9]]+=p/(cnt*1.0);
															f[i]--;//回溯 
															f[j]--; 
														}
										}
	double ans=dp[4][4][4][4][4][4][4][4][4]; 
	printf("%.6lf",ans);//输出答案 
	return 0;
}
```


---

## 作者：std__unsigned (赞：4)

这道题是概率DP。。。

f[5][5][5][5][5][5][5][5][5]表示的是每一堆取了x个的概率

然后九层循环枚举

top数组是每个堆得堆顶位置

找出所有的情况，那么概率就要加上上一个状态的概率\*（情况数分之一）

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<iostream>
using namespace std;
int x,y,cnt,top[11];
double f[5][5][5][5][5][5][5][5][5];
char a[1001][10];
int main()
{
    for (x=1;x<=9;x++)//读入数据
    {
        char s[100];
        gets(s+1);
        a[x][1]=s[10];
        a[x][2]=s[7];
        a[x][3]=s[4];
        a[x][4]=s[1];
    }
    f[0][0][0][0][0][0][0][0][0]=1;//初始化
    for(top[1]=0;top[1]<=4;top[1]++)
    for(top[2]=0;top[2]<=4;top[2]++)
    for(top[3]=0;top[3]<=4;top[3]++)
    for(top[4]=0;top[4]<=4;top[4]++)
    for(top[5]=0;top[5]<=4;top[5]++)
    for(top[6]=0;top[6]<=4;top[6]++)
    for(top[7]=0;top[7]<=4;top[7]++)
    for(top[8]=0;top[8]<=4;top[8]++)
    for(top[9]=0;top[9]<=4;top[9]++)//。。。
    if(f[top[1]][top[2]][top[3]][top[4]][top[5]][top[6]][top[7]][top[8]][top[9]])
    {
    double p=f[top[1]][top[2]][top[3]][top[4]][top[5]][top[6]][top[7]][top[8]][top[9]];
    cnt=0;
    for(x=1;x<9;x++)
    for(y=x+1;y<=9;y++)
    if(top[x]+1<=4&&top[y]+1<=4&&a[x][top[x]+1]==a[y][top[y]+1])
        cnt++;
    if(cnt>0)
    for (x=1;x<9;x++)
    for (y=x+1;y<=9;y++)
    if (top[x]+1<=4&&top[y]+1<=4&&a[x][top[x]+1]==a[y][top[y]+1]) 
    {
        top[x]++;top[y]++;
        f[top[1]][top[2]][top[3]][top[4]][top[5]][top[6]][top[7]][top[8]][top[9]]+=p/(double)(cnt*1.0);
        top[x]--;top[y]--;//回溯
    }
    }
    printf("%.6lf",f[4][4][4][4][4][4][4][4][4]);
}
```

---

## 作者：QQQfy (赞：2)

# 胆子要大一点，要敢于实验

### ——邓小平

## 1.算法：~~显然是~~ 期望DP

## 2.状态：
**这个状态的设计是非常考验胆量的**

$dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]]$表示第$i,(i\in [1,9])$堆成功取了$g[i]$张的概率

ovo

## 3.转移：

先统计有几对相同的，然后找到它们，转移概率。

不过这里有点坑，下面会讲。

方程太长这里就不写了具体看代码吧

## 4.边界

$dp[0][0][0][0][0][0][0][0][0]=1$(什么都不取一定行，概率为1)

$ans=dp[4][4][4][4][4][4][4][4][4]$ (取完了)

## 5.坑点

输入顺序是由堆底到堆顶给出，注意输入顺序

统计相同的时候注意不要重复

转移的时候边界不能大于4

~~我会出这些问题一定因为我太菜了~~

## 6.~~喜闻乐见的~~ 代码

```cpp
#include<bits/stdc++.h>
#define For(x,i,j) for (x=i;x<=j;x++)
using namespace std;

double dp[5][5][5][5][5][5][5][5][5]={1},tmp;
int g[10];
char a[10][5];
string s;

int main()
{
	for (int i=1;i<=9;i++)
	{
		for (int j=4;j>=1;j--)
		{
			cin>>s;a[i][j]=s[0];
//			cout<<a[i][j]<<' '; 
		}
//		cout<<endl;
	}
		
		
	For(g[1],0,4) For(g[2],0,4) For(g[3],0,4) 
	For(g[4],0,4) For(g[5],0,4) For(g[6],0,4) 
	For(g[7],0,4) For(g[8],0,4) For(g[9],0,4)
	if (dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]])
	{
		tmp=dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]];
		int cnt=0;
		for (int i=1;i<=9;i++)
			for (int j=i+1;j<=9;j++)
				if (g[i]+1<=4&&g[j]+1<=4&&a[i][g[i]+1]==a[j][g[j]+1]) cnt++;
		if (cnt>0)
			for (int i=1;i<=9;i++)
				for (int j=i+1;j<=9;j++)
					if (g[i]+1<=4&&g[j]+1<=4&&a[i][g[i]+1]==a[j][g[j]+1])
					{
						g[i]++;g[j]++;
						dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]]+=tmp/(double(cnt));
						g[i]--;g[j]--;
					}
					
	}
	printf("%.6lf",dp[4][4][4][4][4][4][4][4][4]);
	return 0;
} 
```


---

## 作者：ARZhu (赞：1)

这道题目是一个简单的记忆化搜索dp。记录状态为第$k$个牌堆当中已经抽走了几张牌，于是用九维记录状态；然后所求的值就是输的概率。状态转移便是在有$i,j$的两位排相同时转移过来，然后总值除以可能的量。用记忆化搜索就可以过了。


用map来记录，状态用struct记录，略微常数有点大，但是程序可读性更强。


```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
using namespace std;
inline int read() {
    int x = 0,tmp = 1;char ch = getchar();
    while( ch < '0' || ch > '9' ) { if( ch == '-' ) tmp = -1; ch = getchar();}
    while( ch >= '0' && ch <= '9'){ x = x * 10 + ch - '0'; ch = getchar(); }
    return x * tmp;
}
int num[9][4];
struct stat__ {
    int s[9];
    stat__() { }
    stat__( int a, int b, int c, int d, int e, int f, int g, int h, int i ) {
        s[0] = a; s[1] = b; s[2] = c; s[3] = d; s[4] = e; s[5] = f; s[6] = g; s[7] = h; s[8] = i;
    }
    bool operator < ( const stat__& b ) const {
        for( int i = 0 ; i < 9 ; ++ i ) if( s[i] < b.s[i] ) return 1;
        else if( s[i] > b.s[i] ) return 0;
        return 0;
    }
};
map< stat__, db > dp;
db dfs( stat__ now ) {
    if( dp.count( now ) ) return dp[now];
    int t = 0;
    for( int i = 0 ; i < 9 ; ++ i ) t += now.s[i]; if( t == 4 * 9 ) {
        dp.insert( make_pair( now, 0 ) );
        return 0;
    } 
    t = 0; db res = 0; stat__ tmp = now;
    for( int i = 0 ; i < 9 ; ++ i ) if( now.s[i] == 4 ) continue; else
        for( int j = i + 1 ; j < 9 ; ++ j ) if( now.s[j] == 4 ) continue; else if( num[i][now.s[i]] == num[j][now.s[j]] ) {
            tmp.s[i] ++; tmp.s[j] ++;
            res += dfs( tmp ); t ++;
            tmp.s[i] --; tmp.s[j] --;
        }
    if( t == 0 ) dp.insert( make_pair( now, 1 ) ); else dp.insert( make_pair( now, res / (db)t ) );
    return dp[now];
}
inline bool isdigit( char c ) {
    return ( c <= '9' && c >= '0' );
}
inline bool isalpha( char c ) {
    return ( c <= 'Z' && c >= 'A' );
}
void init() {
    char ch;
    for( int i = 0 ; i < 9 ; ++ i )
        for( int j = 3 ; j >= 0 ; -- j ) {
            ch = getchar();
            while( !isdigit( ch ) && !isalpha( ch ) ) ch = getchar();
            if( ch == 'A' ) num[i][j] = 1;
            else if( ch == 'T' ) num[i][j] = 10;
            else if( ch == 'J' ) num[i][j] = 11;
            else if( ch == 'Q' ) num[i][j] = 12;
            else if( ch == 'K' ) num[i][j] = 13;
            else num[i][j] = ch - '0';
            ch = getchar();
            while( !isdigit( ch ) && !isalpha( ch ) ) ch = getchar();
        } 
}
int main() {
    init();
    db ans = dfs( stat__( 0, 0, 0, 0, 0, 0, 0, 0, 0 ) );
    printf( "%.6lf", 1.0 - ans );
    return 0;
}
```

---

## 作者：Furina_Saikou (赞：0)

唯一一篇记忆化搜索的题解代码可读性过低，我就来了。

# 爆搜方法

不难想出我们可以用九个变量存九个牌堆的堆顶下标。然后每次在堆顶选两个牌面相同的牌递归，边递归边算概率，如果所有牌堆都取完就返回 $1$，其他时候就返回更深层的概率和除以可以选择的走法数量。

# 优化

使用记忆化来优化搜索。用九维数组存当前状态得到的结果，之后遇到相同状态就直接返回数组存的结果。

注意如果搜索无法继续往下走，直接返回 $0$。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[9][4],v[9];
double dp[5][5][5][5][5][5][5][5][5];
inline int change(char c)
{
	if('0'<=c&&c<='9')return c-'0';
	else return c-'A'+10;
}
double dfs1()
{
	if(dp[v[0]][v[1]][v[2]][v[3]][v[4]][v[5]][v[6]][v[7]][v[8]]>=0)return dp[v[0]][v[1]][v[2]][v[3]][v[4]][v[5]][v[6]][v[7]][v[8]];//遇到计算过的状态直接返回
	double sum=0,cnt=0;
	for(int i=0;i<8;++i)
	{
		if(v[i]==4)continue;
		for(int j=i+1;j<9;++j)
		{
			if(v[j]==4)continue;
			if(a[i][v[i]]==a[j][v[j]])
			{
				++v[i],++v[j];
				sum+=dfs1();//概率求和之后除以cnt
				++cnt;
				--v[i],--v[j];
			}
		}
	}
	if(cnt==0)return dp[v[0]][v[1]][v[2]][v[3]][v[4]][v[5]][v[6]][v[7]][v[8]]=0;
	return dp[v[0]][v[1]][v[2]][v[3]][v[4]][v[5]][v[6]][v[7]][v[8]]=sum/cnt;//数组存结果
}
signed main()
{
	for(int i=0;i<5;i++)for(int j=0;j<5;j++)for(int k=0;k<5;k++)for(int l=0;l<5;l++)for(int o=0;o<5;o++)for(int p=0;p<5;p++)for(int u=0;u<5;u++)for(int y=0;y<5;y++)for(int t=0;t<5;t++)dp[i][j][k][l][o][p][u][y][t]=-1;//初始化
	for(int i=0;i<9;i++)
	{
		char x,y;
		for(int j=3;~j;j--)
		{
			cin>>x>>y;
			if(x=='1'&&y=='0')
			{
				a[i][j]=10;
				cin>>x;
			}else
			{
				a[i][j]=change(x);
			}
		}
	}
	dp[4][4][4][4][4][4][4][4][4]=1;//边界状态
	double x=dfs1();
	printf("%.6lf",x);
}
```

---


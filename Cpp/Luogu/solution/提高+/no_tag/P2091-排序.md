# 排序

## 题目描述

小 A 有 $n$ 个物件排成一排，每个物件有它的体积 $V$ 和质量 $M$。$n$ 个物件的体积在 $1 \sim n$ 内，且各不相同，但质量可能相同。

现在，小 A 需要把 $n$ 个物件按体积从小到大重新排列。他的排序方式是：每次交换两个物件。这样会他会消耗的体力值为两个物件的质量和。

小 A 想知道，为了将物件排序，他消耗的最少体力值是多少？

## 说明/提示

| 测试点 | $n$ | $m$ |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $n=2000$ | $m=1$ |
| $3$ | $n=2000$ | $m \leq 10$ |
| $4$ | $n=2000$ | $m \leq 10000000$ |
| $5\sim 7$ | $n=200000$ | $m=1$ |
| $8$ | $n=200000$ | $m \leq 10$ |
| $9\sim 10$ | $n=200000$ | $m \leq 10000000$ |

## 样例 #1

### 输入

```
3
1 3 2
2 2 3
```

### 输出

```
5```

# 题解

## 作者：AC_Automation (赞：6)

貌似没什么人做，来写一篇题解

首先，我们拆出给定序列的置换与$\left ( 1,2,3\dots,n \right )$这个置换的循环

然后，对于每一个循环，计算循环内部的答案

我们先定义全局最小值为$Min$，循环内部最小值为$M$，循环中数的总和为$S$，循环中数的数量为$cnt$，则可能的交换方式有：

1. 用$M$一个一个与别的数交换，所需的体力值为：
$$M*(cnt-2)+S$$
2. 将全局最小值与循环内部最小值交换，然后用全局最小值与别的数交换，最后再将全局最小值和循环内部最小值交换，所需体力值为：
$$Min*(cnt+1)+S+M$$
对于每个循环，将两种方法的最小值加到总答案里就行了。
代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
ll read(){
	ll x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		x*=10;x+=ch-'0';
		ch=getchar();
	}
	return x;
}
ll a[200005],wz[200005],val[200005];
bool book[200005];
int main(){
	ll n,cnt,ans,minn,S,minm=2147483647;
	bool bj;
	cin>>n;
	for(int i=1;i<=n;i++){
		a[i]=read();
		wz[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		val[i]=read();
		minm=min(minm,val[i]);
	}
	ans=0;
	for(int i=1;i<=n;i++){
		if(!book[a[i]]){
			int x=i;
			cnt=0;S=0;
			minn=2147483647;
			while(!book[a[x]]){
				book[a[x]]=1;
				S+=val[x];cnt++;
				minn=min(minn,val[x]);
				x=wz[x];
			}
			ans+=min(minn*(cnt-2)+S,minm*(cnt+1)+S+minn);
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：fjsmghj (赞：3)

①暴力分解置换群成若干轮换

②对于每个轮换单独处理：

1、求出这个轮换中最小值m‘和这个轮换中各个元素的总和s以及个数n，则上述第一种方案的代价为：Cost1=m’\*(n-1)+s-m’

2、求出整个数组中最小值m，则上述第二种方案的代价为：Cost2=m+m’+m\*(n-1)+s-m+m+m’

3、去Cost1和Cost2中的最小值作为此轮换处理结果，加入到最后结果中

注意：再回归到这个题目，注意到数字不是连续的，所以要离散处理

```cpp
//P2091 排序
#include<iostream>
#include<algorithm>
#include<cstring>
#include<set>
using namespace std;
struct node{
    long long no;
    long long zl;
    long long data;
    bool operator <(const node &n)const
    {
        if (data<n.data) return true;
        else return false;
    }
};
node d[200001];
bool f[200001];
multiset <long long> qa;
long long minzl;
int main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        d[i].no=i;
        cin>>d[i].data;
    }
    cin>>d[1].zl;
    minzl=d[1].zl;
    for (int i=2;i<=n;i++)
    {
        cin>>d[i].zl;
        if (minzl>d[i].zl) minzl=d[i].zl;
    }
    sort(d+1,d+n+1);
    memset(f,0,sizeof(f));
    long long  ans=0,anst=0;
    for (int i=1;i<=n;i++)
    {
        if (!f[i])
        {
            int x=i;
            qa.clear();
            while (!f[x]&&d[x].no!=x)
            {
                qa.insert(d[x].zl);
                f[x]=true;
                x=d[x].no;
            }
            if (qa.empty()) continue;
            multiset<long long>::iterator iter;
            iter=qa.begin();
            anst=*iter;
            anst=anst*(qa.size()-1);
            if (anst>(minzl+*iter)*2+minzl*(qa.size()-1))        
            {
                anst=(minzl+*iter)*2+minzl*(qa.size()-1);
            }
            iter++;
            while (iter!=qa.end())
            {
                anst+=*iter;
                iter++;
            }
            ans+=anst;
        }
    }
    cout<<ans<<endl;
}
```
/\*
3
3 1 2
1 1 1
4
8 1 2 4

8 1 2 4

6
8 4 5 3 2 7

8 4 5 3 2 7

3
3 2 1
3 2 3
4
8 1 2 4

8 8 6 8

3
1 2 3
3 3 3
5
5 2 3 4 7

100 101 102 103 1

\*/

---

## 作者：My_hanshuang (赞：2)

# luogu P2091 题解

~~蒟蒻看不懂其他的题解，决定写一篇造福其他的蒟蒻~~

提前声明：**本题解仅仅起引导思路的作用，并没有严格数学证明**，并且个人认为思路远远比证明更重要。

原题链接 [P2091 排序]([P2091 排序 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2091))

题目大意：有 $n$ 个物品，每一个物品有一个体积 $V$ 和一个质量 $M$，在以物品体积为基础排序的时候，每次交换两个物品并且代价为两物品质量之和。求排好序之后的最小代价。

当我们看见这个交换的时候，应该意识到这有一定的规律。~~n和m的范围表示很赞~~。

我们首先想一个一个地将物品放回应该在的位置。将 $V$ 最小的物品放回第一个位置，明显我们有这样一些选择：

1. 利用最小值，将它运送回去。
2. 硬搬。

对于情况一，我们还可以进一步细化：利用全局的最小值，在与区间内的最小值交换，再借助它搬运需要搬运的物品。

![here](https://cdn.luogu.com.cn/upload/image_hosting/anm29yyl.png)

接下来找找规律就好了：不难发现**硬搬处理区间就是回家路径上数的和加上这个数乘以交换次数，全局最小值帮忙是全局最小值乘以区间长度加一再加上区间和与区间最小值**，具体阐述如图。

总计: $cost=\min(S+(cnt-2) \times val[now],S+(cnt+1) \times m+M)$

好的，最后注意离散化一下就可以 AC 了！

~~既然是面向蒟蒻，那肯定讲全啊。~~

这里简述一下离散化：由于体积的大小范围题目没有给出，因此最稳妥的方式就是离散化。

**在只需表示相对大小的时候并且需要以值作为下标的时候**，可以用它来压缩数组空间。

具体实现：使用一个相对大小来替代原本大小，例如：

![here](https://cdn.luogu.com.cn/upload/image_hosting/4df2i6fa.png)

如果按照第一行的方式反向存储，那肯定会爆炸，不过根据相对大小就没这些问题，如第二行。

因此我们可以根据排序之后的相对大小来决定它的值是多少，如果遇到相同的值，不要犹豫，直接干掉。

这里利用 STL 库可以很方便地实现，讲解一下这三个函数：

- `s.erase(start,end)` 删除 start 至 end 的元素 ；
- `unique(start,end)` 将 start 至 end 的元素中重复的移动至整个数组后面，并返回移动后的首地址；
- `lower_bound(start,end,val)`  在 start 至 end 二分查找大于等于 val 的位置，返回地址。

因此，只需短短几行即可：

```cpp
sort(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());
for(int i=1;i<=n;i++)
    pos[i]=lower_bound(v.begin(),v.end(),pos[i])-v.begin()+1;
 //为了返回的是值，减去数组首地址；+1是为了从1开始编号。
```

贴一下自己的 code :

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N=1e7+10;
#define int long long
bool vis[N];
int pos[N],val[N],id[N];
int n,minn=0x7f7f7f7f7f7f7f7f,ans;
vector<int>v;
signed main(){
 cin>>n;
 for(int i=1;i<=n;i++){
  cin>>pos[i];
  v.push_back(pos[i]);
 }
 sort(v.begin(),v.end());
    v.erase(unique(v.begin(),v.end()),v.end());
 for(int i=1;i<=n;i++)
  pos[i]=lower_bound(v.begin(),v.end(),pos[i])-v.begin()+1,id[pos[i]]=i;
    for(int i=1;i<=n;i++){
        cin>>val[i];
        minn=min(val[i],minn);
    }//离散化基本操作
    for(int i=1;i<=n;i++){
        int cnt,sum,minx;
        if(!vis[pos[i]]){//它没有被放在正确的位置上
            int t=i;//cnt代表区间长度，sum代表区间和，minx代表区间最小值
            cnt=0,sum=0,minx=0x7f7f7f7f7f7f7f7f;
            while(!vis[pos[t]]){
                vis[pos[t]]=1;
                sum+=val[t];cnt++;
                minx=min(minx,val[t]);
                t=id[t];
            }
            ans+=min(minx*(cnt-2)+sum,minn*(cnt+1)+sum+minx);
        }
    }
    cout<<ans<<endl;
}
```

**希望这篇题解能帮到你！**


---

## 作者：StarRoam (赞：1)

来水一篇题解。

自己手动模拟一下样例，我们可以先得到一个看似正确的贪心结论，每次我们选取全局一个最小的 $m_i$，将它与最终应该在此位置上的 $m_j$ 交换，最后交换到无法再交换为止，我们可以使用 set 维护，复杂度为 $O(n \log n)$，但是这样似乎只有 $70$ 分。

我们再深入思考来分析这个贪心为什么是错的。

如果是**按照上面的贪心思路**，我们实际上是一直在多个环上面操作，即最初我们将 $i$ 与 $v_i$ 连一条边，则最后一定能形成多个互不相连的简单环，然后我们就是在环上最小的 $m_i$ 开始，每次都与连向它的点交换，而实际上就是 $m_i$ 与其余的点都换了一次，如果我们记此环上所有点的总和为 $sum$，一共有 $num$ 个点，则所计算的答案就是 $sum-(num-2) \times m_i$。

但是如果此环的中最小的 $m_i$ 很大，我们却不一定要像上面的操作一样，这也是为什么此前的贪心是错的。因为我们只要将**其他环中的最小点最为交换的基础**来交换即可，所以此前的贪心少考虑了一个方面。

我用的是缩点，时间复杂度约为 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+5;
int n,b[N];
int dfn[N],low[N],stk[N],col[N],top,cnt,tot;
ll mn[N],sum[N],num[N];
vector<int> to[N];
void Tarjan(int pos)
{
	dfn[pos]=low[pos]=++cnt;
	stk[++top]=pos;
	for(auto v:to[pos])
	{
		if(!dfn[v]){
			Tarjan(v);
			low[pos]=min(low[pos],low[v]);
		}
		else if(!col[v]) low[pos]=min(low[pos],dfn[v]);
	}
	if(dfn[pos]==low[pos])
	{
		col[pos]=++tot;
		num[tot]=1;
		mn[tot]=sum[tot]=b[pos];
		while(stk[top]!=pos)
		{
			int now=stk[top];
			col[now]=tot;
			mn[tot]=min(mn[tot],b[now]*1ll);
			sum[tot]+=b[now];
			num[tot]++;
			top--;
		}
		top--;
	}
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		to[i].push_back(a);
	}
	int mc=1e8;
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		mc=min(mc,b[i]);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) Tarjan(i);
	ll ans=0;
	for(int i=1;i<=tot;i++)
		ans=(ans+(sum[i]+min(mn[i]*(num[i]-2),mn[i]+1ll*mc*(num[i]+1))));
	cout<<ans;
	return 0;
}
/*
*/
```

---

## 作者：caohan (赞：0)

# 思路

可能会有这样的想法：把体积最小的直接搬到开头。

可是如果在中途的物品中停下，分多次搬，可能会有节省。

上面的想法即为在路径中找一个最小，先将当前的物品与他交换，再去处理前面更小的区间。

~~当然，有的时候硬搬可能确实更好~~

所以最后移动这一个的代价为 $\min(sum+(len-2) \times cost_{now},sum+(len+1)\times mintot+minpath)$。

其中 $mintot$ 为全局最小，$minpath$ 为全局最小往前的路径中最小的，$len$ 是全局最小往前的长度,$sum$ 为这一段路径上重量之和。

最后因为要考虑搬没搬过，所以在 $vis$ 数组中离散化的存一下即可。

# 代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
#define ll long long
#define int ll
using namespace std;
int val[200005];
int pos[200005];
int id[200005];
int vis[200005];
int n,minn=0x7f7f7f7f,ans;
vector<int> v;//离散化专用
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>pos[i];
		v.push_back(pos[i]);
	}
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());
	for(int i=1;i<=n;i++)
	{
		pos[i]=lower_bound(v.begin(),v.end(),pos[i])-v.begin()+1;
		id[pos[i]]=i;
	}//先离散化
	for(int i=1;i<=n;i++)
	{
		cin>>val[i];
		minn=min(minn,val[i]);
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int cnt,sum,minx;
		if(!vis[pos[i]])
		{
			int t=i;
			cnt=0;
			sum=0;
			minx=0x7f7f7f7f;
			while(!vis[pos[t]])
			{
				vis[pos[t]]=1;
				sum+=val[t];
				cnt++;
				minx=min(minx,val[t]);
				t=id[t];//找路径
			}
			ans+=min(minx*(cnt-2)+sum,minn*(cnt+1)+sum+minx);//用公式算
		}
	}
	cout<<ans;
	return 0;
}
```


---


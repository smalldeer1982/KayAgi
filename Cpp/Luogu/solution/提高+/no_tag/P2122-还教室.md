# 还教室

## 题目背景

还记得 NOIP 2012 提高组 Day2 中的借教室吗？时光飞逝，光阴荏苒，两年过去了，曾经借教室的同学们纷纷归还自己当初租借的教室。请你来解决类似于借教室的另一个问题。

## 题目描述

在接受借教室请求的 $n$ 天中，第 $i$ 天剩余的教室为 $a_i$ 个。作为大学借教室服务的负责人，你需要完成如下三种操作共 $m$ 次：

1. 第 $l$ 天到第 $r$ 天，每天被归还 $d$ 个教室；
1. 询问第 $l$ 天到第 $r$ 天教室个数的平均数；
1. 询问第 $l$ 天到第 $r$ 天教室个数的方差。

## 说明/提示

对于全部测试数据满足：$1 \leq l \leq r \leq n \leq 10^5, m\leq 10^5$，$0 \leq a_i \leq 10$，$1 \leq d \leq 3$，操作 $1$ 的数量不超过 $10\%$。

注意：$a_i$ 和 $d$ 的范围很小及操作 $1$ 数量很少的原因是为了保证答案的分子不会很大，以防止答案的分子溢出 $64$ 位整数的范围，这与题目做法无关。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 1 2 3
2 2 4
3 2 4
3 1 5```

### 输出

```
4/1
2/3
14/25```

# 题解

## 作者：夏色祭 (赞：11)

显然这题要用线段树搞。

平均数？

出门左拐线段树模板一再加个gcd就行了。

方差？

先说下这是个什么东西。


$\sum_{i=l}^{r}(a[i]-q)^2/(r-l+1)$ (q为这r-l+1个数的平均数)


就是上面那个式子。

显然我们不能直接搞。

考虑化简，运用完全平方公式把$(a[i]-q)^2$化开，得：


$\sum_{i=l}^{r}(a[i]^2-2*q*a[i]+q^2)/(r-l+1)$ (q为这r-l+1个数的平均数)


那么我们再用线段树维护下区间平方和就行了。

然后问题是平方和区间加怎么维护？

哎哎哎，别慌。。。

我们可以再用完全平方公式把$(a[i]+d)^2$化开来，得：


$a[i]^2+2*a[i]*d+d^2$


a[i]平方就是我们**原先的答案**，然后就加上 **区间和\*2\*d** 和 **区间长度\*d** 就行了


具体还有些小细节，我就不一一说了。。


由于代码是在太长(4K+)我就不展示了。

![我好菜啊](https://s1.ax1x.com/2018/01/11/p163Hs.jpg)


---

## 作者：lianliangyu (赞：9)

## 线段树神题

一看题目，区间平均数，区间方差，就知道要用线段树维护两个变量：

$1. $
**区间和**

$2.$
**区间平方和**
$\sum_{i=l}^{r}a_i^2$

区间和没什么好说的，线段树常规操作。所以值得注意的就是区间平方和了。向上$pushup$和查询时与区间和的操作几乎一模一样，唯一不同的是区间修改。

初二及以上的同学们一定很熟悉这个式子：
#### $(x+y)^2=x^2+2xy+y^2$

那么我们就用这个式子来推出如何进行懒标记下放的操作：

$\sum_{i=l}^r(a_i+x)^2$

$=\sum_{i=l}^r(a_i^2+2a_ix+x^2)$

$=\sum_{i=l}^ra_i^2+2x\sum_{i=l}^ra_i+\sum_{i=l}^rx^2$

所以修改时还要用到区间和，因此修改顺序是先区间平方和再区间和。
```cpp
inline int len(int p) {return t[p].right-t[p].left+1;}

inline void pushdown(int p)
{
	if(t[p].tag)
	{
		int k=t[p].tag;
		t[p<<1].tag+=k;t[p<<1|1].tag+=k;
		t[p<<1].square+=2*k*t[p<<1].sum+1ll*len(p<<1)*k*k;
		t[p<<1|1].square+=2*k*t[p<<1|1].sum+1ll*len(p<<1|1)*k*k;
		t[p<<1].sum+=1ll*len(p<<1)*k;
		t[p<<1|1].sum+=1ll*len(p<<1|1)*k;
		t[p].tag=0;
	}
}

update:
if(l<=t[p].left&&r>=t[p].right)
	{
		t[p].tag+=x;
		t[p].square+=2*x*t[p].sum+1ll*len(p)*x*x;
		t[p].sum+=1ll*x*len(p);
		return;
	}
```
线段树部分打完了，接下来是最重要的处理输出了。
题目要求用最简分数来输出，那么我们就将输出的分数分成分子和分母两部分分别处理。区间平均数也很简单，分成区间和和区间大小就可以了。而区间方差就需要一些化简操作了。

方差公式是这个：
#### $s^2=\frac{1}{n}\sum_{i=1}^n(a_i-\overline{a})^2$

所以我们可以推出：

$\frac{\sum(a_i-\overline{a})^2}{n}$

$=\frac{\sum(a_i^2-2\overline{a}a_i+\overline{a}^2)}{n}$

$=\frac{\sum a_i^2-2\frac{\sum a_i}{n}\sum a_i+n(\frac{\sum a_i}{n})^2}{n}$

$=\frac{\sum a_i^2-\frac{(\sum a_i)^2}{n}}{n}$

$=\frac{n\sum a_i^2-(\sum a_i)^2}{n^2}$

所以就用最后这个式子作为分数输出就行了。

另外，千万不要忘记开$long long$。
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=100005;
typedef long long ll;
struct Segment_Tree
{
	int left,right;
	ll sum,tag,square;
}t[N<<2];
int n,m;
ll a[N];
template<class type>inline void read(type &k)
{
	k=0;type t=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') t=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {k=k*10+ch-'0';ch=getchar();}
	k*=t;
}
inline ll gcd(ll x,ll y) {return y==0?x:gcd(y,x%y);}                              //分数化简用 
inline void pushup(int p)
{
	t[p].square=t[p<<1].square+t[p<<1|1].square;
	t[p].sum=t[p<<1].sum+t[p<<1|1].sum;
}
inline void build(int p,int l,int r)
{
	t[p].left=l;t[p].right=r;
	if(l==r)
	{
		t[p].sum=a[l];t[p].square=a[l]*a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
}
inline int len(int p) {return t[p].right-t[p].left+1;}
inline void pushdown(int p)
{
	if(t[p].tag)
	{
		int k=t[p].tag;
		t[p<<1].tag+=k;t[p<<1|1].tag+=k;
		t[p<<1].square+=2*k*t[p<<1].sum+1ll*len(p<<1)*k*k;
		t[p<<1|1].square+=2*k*t[p<<1|1].sum+1ll*len(p<<1|1)*k*k;
		t[p<<1].sum+=1ll*len(p<<1)*k;
		t[p<<1|1].sum+=1ll*len(p<<1|1)*k;
		t[p].tag=0;
	}
}
inline void update(int p,int l,int r,ll x)
{
	if(l<=t[p].left&&r>=t[p].right)
	{
		t[p].tag+=x;
		t[p].square+=2*x*t[p].sum+1ll*len(p)*x*x;
		t[p].sum+=1ll*x*len(p);
		return;
	}
	pushdown(p);
	int mid=(t[p].left+t[p].right)>>1;
	if(l<=mid) update(p<<1,l,r,x);
	if(r>mid) update(p<<1|1,l,r,x);
	pushup(p);
}
inline ll query1(int p,int l,int r)
{
	if(l<=t[p].left&&r>=t[p].right) return t[p].sum;
	pushdown(p);
	int mid=(t[p].left+t[p].right)>>1;ll ans=0;
	if(l<=mid) ans+=query1(p<<1,l,r);
	if(r>mid) ans+=query1(p<<1|1,l,r);
	return ans;
}
inline ll query2(int p,int l,int r)
{
	if(l<=t[p].left&&r>=t[p].right) return t[p].square;
	pushdown(p);
	int mid=(t[p].left+t[p].right)>>1;ll ans=0;
	if(l<=mid) ans+=query2(p<<1,l,r);
	if(r>mid) ans+=query2(p<<1|1,l,r);
	return ans;
}
int main()
{
	int i,opt,x,y;
	ll z;
	read(n);read(m);
	for(i=1;i<=n;i++) read(a[i]);
	build(1,1,n);
	while(m--)
	{
		read(opt);read(x);read(y);
		if(opt==1) read(z),update(1,x,y,z);
		if(opt==2)
		{
			ll k=query1(1,x,y),t=gcd(k,y-x+1);
			printf("%lld/%lld\n",k/t,1ll*(y-x+1)/t);
		}
		if(opt==3)
		{
			ll k1=query1(1,x,y),k2=query2(1,x,y),ans1,ans2,t=(ll)y-x+1;          //k1为区间和，k2为区间平方和 
//			cout<<k1<<" "<<k2<<endl;
			ans1=t*k2-k1*k1;ans2=t*t;                                            //直接套用推出的公式 
//			cout<<ans1<<" "<<ans2<<endl;
			ll k=gcd(ans1,ans2);
			printf("%lld/%lld\n",ans1/k,ans2/k);
		}
	}
	return 0;
}
```
#### 三倍经验题：

$1.$ [P1471 方差](https://www.luogu.org/problem/P1471)
把$long long$改成$double$，也不用这么麻烦算分数，直接相除即可。

$2.$ [P5142 区间方差](https://www.luogu.org/problem/P5142)
需要求最后分数的逆元。

---

## 作者：OldVagrant (赞：6)

## 题意
给定一个长为 $n$ 的序列，要在该序列上进行 $m$ 次操作，每次操作如下：   
```1 l r d``` 将 $a_l\sim a_r$ 都加上 $d$。    
```2 l r``` 求出 $a_l\sim a_r$ 的平均数。  
```3 l r``` 求出 $a_l\sim a_r$ 的方差。   
对于每个询问，以一个最简分数 ```a/b``` 的形式输出，当 $a=0$ 时输出 ```0/1```。
## Solution
难度主要在推式子上，剩下的就是个线段树的板子。
#### 前置知识：   
线段树初步（区间求和，区间修改，不会的请先移步[P3372 【模板】线段树1](https://www.luogu.com.cn/problem/P3372)）。   
#### Step1：推出计算公式
平均数就不用说了，本来就是 $\frac{\sum_{i=l}^ra_i}{r-l+1}$，直接用线段树维护一个区间和，但是方差的话还要再推一下。 

观察一下方差的计算式子: $s^2=\frac{\sum_{i=l}^r (a_i-\bar a)^2}{r-l+1}$。  

展开一下可以得到： $s^2=\frac{\sum_{i=l}^r (a_i^2+\bar a^2-2\times a_i\times \bar a)}{r-l+1}$。

再分开求和：$s^2=\frac{\sum_{i=l}^r a_i^2+\bar a\times \sum_{i=l}^r \bar a-2\times \bar a\times \sum_{i=l}^r a_i}{r-l+1}$。  

令 $sum=\sum_{i=l}^r a_i,sum2=\sum_{i=l}^r a_i^2$,因为 $\sum_{i=l}^r \bar a=sum$,所以原式可以进一步简化为 $s^2=\frac{sum2+\bar a\times  sum-2\times \bar a\times sum}{r-l+1}$,最终得到 $s^2=\frac{sum2-\bar a\times  sum}{r-l+1}$。   
得到这个式子之后，我们可以得知，要维护两样东西：$sum$ 和 $sum2$。    
~~恭喜你完成了三分之一~~。
#### Step2：推出修改公式
$sum$ 的修改就不说了，~~听我的话先做P3372再来看的肯定都会了~~，但是   $sum2$ 的修改还是要再推一下式子。   
读题，可以发现，题目上说的是给 $a_l\sim a_r$ 同时加上同一个数 $d$ ,而增加的总量就是 $\sum_{i=l}^r ((a_i+d)^2 -a_i^2))$。   
展开式子： $\sum_{i=l}^r (a_i^2+d^2 -a_i^2+2\times a_i\times d)$。  
消掉 $a_i^2$ 并分开求和： $\sum_{i=l}^r d^2 +2\times d\times \sum_{i=l}^r a_i$，可以发现，最终得到的结果就是 $d^2\times (r-l+1)+2\times d\times sum$,提出一个 $d$ 得到  $d\times ((r-l+1)\times d+2\times sum)$。   
注意一点，一定要先修改 $sum2$ 再修改 $sum$，因为你修改 $sum2$ 时用的是之前的区间和，如果先改 $sum$ 的话区间和就变大了，答案就会大很多。   
~~恭喜你完成了三分之二~~。
#### Step3：推出查询公式  
完成了上面两个式子的推导之后，建线段树相信大家都会，修改操作应该也都会，就是查询的话还要麻烦一点，再推出一个式子。     
定义 $len=r-l+1$。  
平均数的话应该没人不会吧，就是 $\frac{sum}{len}$，约分一下就好。 

根据方差的计算公式，$s^2=\frac{sum2-\bar a\times sum}{len}$。  
这里的平均数不能直接算出来，只能拿 $sum$ 去算，变成 $\frac{sum^2}{len}$,否则会有误差，因为有总和不为区间长度的倍数的情况。 
然后式子就变成了 $s^2=\frac{sum2-\frac{sum^2}{len}}{len}$，分子分母同时乘以 $len$ 得到 $s^2=\frac{len\times sum2-sum^2}{len^2}$。  
然后就是算出区间长度的平方，再把分子算出来，约分一下即可。  
这里有一个小技巧，就是查询 $sum2$ 的时候你可以开一个全局变量，每次查询前设为 0，每当累加 $sum2$ 的时候顺便给这个全局变量也累加上那个节点的  $sum$，这样的话最后就不用再次查询，能快一点。    
~~完结撒花~~。
## Code
跑的挺快的。
```c
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rint register int
#define gc getchar
int n,m,tp,x,y;
ll a[100001],sum[400001],z,lazy[400001],sum2[400001],sm,sm2,gcd,len;
//sum维护区间和，sum2维护区间所有数的平方之和，sm就是那个全局变量
inline int read(){
	int x=0;
	char ch=gc();
	while(!isdigit(ch)) ch=gc();
	while(isdigit(ch)) x=x*10+ch-48,ch=gc();
	return x;
}
inline void push_down(int p,ll x,int l,int mid,int r){
	sum2[p<<1]+=x*(sum[p<<1]*2+x*(mid+1-l)),sum2[p<<1|1]+=x*(sum[p<<1|1]*2+x*(r-mid)),sum[p<<1]+=(mid+1-l)*x,sum[p<<1|1]+=(r-mid)*x,lazy[p<<1]+=x,lazy[p<<1|1]+=x;
}
inline void build(int p,int l,int r){
	if(!(l^r)){
		sum[p]=a[l],sum2[p]=a[l]*a[l];//初始化每个叶子结点的sum,sum2
		return;
	}int mid=l+r>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r),sum[p]=sum[p<<1]+sum[p<<1|1],sum2[p]=sum2[p<<1]+sum2[p<<1|1];//建树并更新父亲节点的和
}
inline void change(int p,int l,int r,ll d,int x,int y){
	if(l<=x&&y<=r){
		sum2[p]+=d*(d*(y-x+1)+2*sum[p]),sum[p]+=(y-x+1)*d,lazy[p]+=d;
		return;//根据公式计算
	}int mid=x+y>>1;
	if(lazy[p]) push_down(p,lazy[p],x,mid,y),lazy[p]=0;//下传标记
	if(l<=mid) change(p<<1,l,r,d,x,mid);
	if(mid<r) change(p<<1|1,l,r,d,mid+1,y);
	sum[p]=sum[p<<1]+sum[p<<1|1],sum2[p]=sum2[p<<1]+sum2[p<<1|1];
}
inline ll query_ave(int p,int l,int r,int x,int y){
	if(l<=x&&y<=r) return sum[p];
	int mid=x+y>>1;
	if(lazy[p]) push_down(p,lazy[p],x,mid,y),lazy[p]=0;
	ll num=0;
	if(l<=mid) num+=query_ave(p<<1,l,r,x,mid);
	if(mid<r) num+=query_ave(p<<1|1,l,r,mid+1,y);
	return num;
}
inline ll query_fc(int p,int l,int r,int x,int y){
	if(l<=x&&y<=r){
		sm+=sum[p];//累加sum2时顺便也把sum累加上
		return sum2[p];
	}int mid=x+y>>1;
	if(lazy[p]) push_down(p,lazy[p],x,mid,y),lazy[p]=0;
	ll num=0;
	if(l<=mid) num+=query_fc(p<<1,l,r,x,mid);
	if(mid<r) num+=query_fc(p<<1|1,l,r,mid+1,y);
	return num;
}
int main(){
	n=read(),m=read();
	for(rint i=1;i<=n;i++) a[i]=read();
	build(1,1,n);
	while(m--){
		tp=read(),x=read(),y=read();
		if(tp<2) z=read(),change(1,x,y,z,1,n);
		else{
			if(tp&1){
				len=y-x+1,sm=0,sm2=query_fc(1,x,y,1,n)*len,len*=len,sm*=sm,sm2-=sm;
				if(!sm2) printf("0/1\n");//注意特判
				else gcd=__gcd(sm2,len),sm2/=gcd,len/=gcd,printf("%lld/%lld\n",sm2,len);//月份后输出
			}else{
				len=y-x+1,sm=query_ave(1,x,y,1,n);
				if(!sm) printf("0/1\n");
				else gcd=__gcd(sm,len),sm/=gcd,len/=gcd,printf("%lld/%lld\n",sm,len);
			}
		} 
	}return 0;
}
```


---

## 作者：wcyQwQ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2122)

题目大意:给定一个序列，支持区间加法，查询平均数和方差。

区间问题，最喜欢用线段树来解决。

首先我们由查询平均数知道肯定要维护区间和，但是我们还要支持查询方差，所以我们还需要维护一些其它的东西，把方差公式展开得到( $A_i$ 表示序列第 $i$ 项，$\overline A$ 表示序列 $A$ 的平均数)。

$$
s^2=\frac{1}{n}\sum_{i=1}^n(A_i-\overline A)^2
$$

$$
s^2=\frac{1}{n}(A_1^2-2A_1\overline A+\overline A^2+A_2^2-2A_2\overline A+\overline A^2+\cdots+A_n^2-2A_n\overline A+\overline A^2)
$$

$$
s^2=\frac{\sum_{i=1}^nA_i^2}{n}-\frac{2\overline A\sum_{i=1}^{n}A_i-n\overline A^2}{n}
$$

$$
s^2=\frac{\sum_{i=1}^nA_i^2}{n}-2\overline A\frac{\sum_{i=1}^{n}A_i}{n} + \overline A^2
$$

$$
s^2=\frac{\sum_{i=1}^nA_i^2}{n}-2\overline A^2+\overline A^2
$$

$$
s^2=\frac{\sum_{i=1}^nA_i^2}{n}-\overline A^2
$$

所以我们不难看出，我们要维护一个区间的和与平方和，那我们在区间加之后修改区间的平方和数据呢？

假设我们这次把区间内的每个数加上 $k$ ，那么我们可以得到。
$$
\sum_{i=1}^{n}(A_i+k)^2=\sum_{i=1}^{n}A_i^2+2k\sum_{i=1}^{n}A_i+nk^2
$$
所以我们就可已用上一轮的平方和与区间和数据来更新被修改后的区间平方和，这个式子也告诉我们在修改时，要先修改平方和，再修改区间和。

但是这道题题目让我们输出的是最简分数的形式，所以我们还需要对平均数式子和方差式子进行进一步简化。

设当前区间和为 $sum$ ，区间平方和为 $square$ ，区间长度为 $n$ 

那么我们就可以把平均数式子写成这样：
$$
\frac{sum}{n}
$$
所以我们就可以通过约去上下两式的最大公因式来得到它的最简形式。

再来看方差
$$
\frac{square}{n}-(\frac{sum}{n})^2
$$
化简得到
$$
\frac{n\cdot square - sum^2}{n^2} 
$$
也是通过约去上下的最简公分母来得到最简形式。

于是我们就做完了这道蓝题。

## 代码

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;
const int N = 1e5 + 10;

struct node
{
    int l, r;
    ll sum, square, add;
} t[N << 2];
int a[N];

inline ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}

inline void pushup(int p)
{
    t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum;
    t[p].square = t[p << 1].square + t[p << 1 | 1].square;
}

inline void pushdown(int p)
{
    node &u = t[p], &l = t[p << 1], &r = t[p << 1 | 1];

    if (!u.add) return;

    l.add += u.add;
    r.add += u.add;

    l.square += 2 * u.add * l.sum + (l.r - l.l + 1) * u.add * u.add; // 平方和式子
    r.square += 2 * u.add * r.sum + (r.r - r.l + 1) * u.add * u.add;
    
    l.sum += (l.r - l.l + 1) * u.add;
    r.sum += (r.r - r.l + 1) * u.add;
    
    u.add = 0;
}

inline void build(int p, int l, int r)
{
    t[p].l = l, t[p].r = r;
    if (l == r)
    {
        t[p].sum = a[l];
        t[p].square = a[l] * a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    pushup(p);
}

inline void modify(int p, int l, int r, int d) // 区间修改，线段树板子
{
    if (l <= t[p].l && t[p].r <= r)
    {
        t[p].add += d;
        t[p].square += 2 * d * t[p].sum + (t[p].r - t[p].l + 1) * d * d; // 推平方和的式子
        t[p].sum += d * (t[p].r - t[p].l + 1);
        return;
    }
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    if (l <= mid) modify(p << 1, l, r, d);
    if (r > mid) modify(p << 1 | 1, l, r, d);
    pushup(p);
}

inline ll get_sum(int p, int l, int r) // 查询区间和
{
    if (l <= t[p].l && t[p].r <= r) return t[p].sum;
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    ll res = 0;
    if (l <= mid) res += get_sum(p << 1, l, r);
    if (r > mid) res += get_sum(p << 1 | 1, l, r);
    return res;
}

inline ll get_square(int p, int l, int r) // 查询区间平方和
{
    if (l <= t[p].l && t[p].r <= r) return t[p].square;
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    ll res = 0;
    if (l <= mid) res += get_square(p << 1, l, r);
    if (r > mid) res += get_square(p << 1 | 1, l, r);
    return res;
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    build(1, 1, n); // 建树
    while (m--)
    {
        int opt, l, r;
        scanf("%d%d%d", &opt, &l, &r);
        if (opt == 1)
        {
            int d;
            scanf("%d", &d);
            modify(1, l, r, d); // 区间加
        }
        else if (opt == 2)
        {
            ll sum = get_sum(1, l, r), length = r - l + 1;
            if (sum == 0)
            {
                puts("0/1");
                continue;
            }
            ll d = gcd(sum, length);
            printf("%lld/%lld\n", sum / d, length / d);
        }
        else if (opt == 3)
        {
            ll sum = get_sum(1, l, r), square = get_square(1, l, r), length = r - l + 1;
            ll tmp = length * square - sum * sum; length *= length; // 方差式子中的分母
            if (tmp == 0)
            {
                puts("0/1");
                continue;
            }
            ll d = gcd(tmp, length);
            printf("%lld/%lld\n", tmp / d, length / d);
        }
    }
    return 0;
}
```







---

## 作者：MY（一名蒟蒻） (赞：2)

[P2122 还教室](https://www.luogu.com.cn/problem/P2122)

## 题意简述

一个区间，你需要维护区间加，区间平均数，区间方差。

## Part 0 方差

首先看一下方差公式：

$a^2=\frac{1}{n}\sum_{i=1}^n(a_i-\overline{a})^2$

其中 $a^2$ 是方差， $\overline{a}$ 是区间平均数。

这东西和每个数字都有关系，那么直接用这个公式就非常不可做。

考虑展开。

$$a^2=\frac{1}{n}\sum_{i=1}^n(a_i-\overline{a})^2$$

$$\Downarrow$$

$$a^2=\frac{1}{n}\sum_{i=1}^na_i^2-2a_i\overline{a}+\overline{a}^2$$

$$\Downarrow$$

$$a^2=\frac{\sum_{i=1}^na_i^2-2\sum_{i=1}^na_i\overline{a}+n\overline{a}^2}{n}$$

$$\Downarrow$$

$$a^2=\frac{\sum_{i=1}^na_i^2}{n}-2\overline{a}^2+\overline{a}^2$$

$$\Downarrow$$

$$a^2=\frac{\sum_{i=1}^na_i^2}{n}-\frac{(\sum_{i=1}^na_i)^2}{n^2}$$

$$\Downarrow$$

$$a^2=\frac{n\sum_{i=1}^na_i^2-(\sum_{i=1}^na_i)^2}{n^2}$$

所以我们只需要维护**区间平方和**和**区间和**即可。

## Part 1 区间加

考虑计算贡献。

区间和很容易，那区间平方和呢？

设区间加 $k$ ，则平方和加上 $\sum_{i=1}^n(a_i+k)^2-\sum_{i=1}^na_i^2=\sum_{i=1}^n2\times a_ik+k^2=2k\sum_{i=1}^na_i+nk^2$

注意这个区间和是以前的区间和，下放标记时先处理区间平方和。

## Part 2 既约分数

分子分母约一个 $\gcd$ 即可。

吐槽一下数据里没有特殊情况，我没加特判过了。

## Part 3 Code

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdlib>

using namespace std;

#define ls(o) o << 1
#define rs(o) o << 1|1

typedef long long ll;
const int N=1e5+10;
int n,m,a[N];

struct Segment_Tree
{
	ll sumv[N << 2],sump[N << 2],tag[N << 2],sz[N << 2];
	inline void pushup(int o) {sumv[o]=sumv[ls(o)]+sumv[rs(o)]; sump[o]=sump[ls(o)]+sump[rs(o)]; return ;}
	inline void pushdown(int o)
	{
		tag[ls(o)]+=tag[o]; tag[rs(o)]+=tag[o];
		sump[ls(o)]+=sz[ls(o)]*tag[o]*tag[o]+2*tag[o]*sumv[ls(o)];
		sump[rs(o)]+=sz[rs(o)]*tag[o]*tag[o]+2*tag[o]*sumv[rs(o)];
		sumv[ls(o)]+=sz[ls(o)]*tag[o]; sumv[rs(o)]+=sz[rs(o)]*tag[o];
		tag[o]=0;
		return ;
	}
	void build(int o,int l,int r)
	{
		sz[o]=r-l+1; tag[o]=0;
		if(l == r) {sumv[o]=a[l]; sump[o]=a[l]*a[l]; return ;}
		int mid=(l+r) >> 1;
		build(ls(o),l,mid); build(rs(o),mid+1,r);
		pushup(o); return ;
	}
	void modify(int o,int l,int r,int nl,int nr,ll k)
	{
		if(nl <= l && r <= nr) {tag[o]+=k; sump[o]+=sz[o]*k*k+2*k*sumv[o]; sumv[o]+=sz[o]*k; return ;}
		int mid=(l+r) >> 1;
		pushdown(o);
		if(nl <= mid) modify(ls(o),l,mid,nl,nr,k);
		if(nr > mid) modify(rs(o),mid+1,r,nl,nr,k);
		pushup(o); return ;
	}
	ll query(int o,int l,int r,int ql,int qr,bool f)
	{
		if(ql <= l && r <= qr) return f?sumv[o]:sump[o];
		int mid=(l+r) >> 1; ll res=0;
		pushdown(o);
		if(ql <= mid) res+=query(ls(o),l,mid,ql,qr,f);
		if(qr > mid) res+=query(rs(o),mid+1,r,ql,qr,f);
		return res;
	}
} tree;

ll gcd(ll x,ll y)
{
	if(!y) return x;
	return gcd(y,x%y);
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int op,l,r,k; tree.build(1,1,n);
	while(m--)
	{
		scanf("%d%d%d",&op,&l,&r);
		if(op == 1) {scanf("%d",&k); tree.modify(1,1,n,l,r,k);}
		else
		{
			ll res=tree.query(1,1,n,l,r,true),siz=r-l+1;
			if(op == 2) {ll _gcd=gcd(res,siz); printf("%lld/%lld\n",res/_gcd,siz/_gcd);}
			else
			{
				ll resp=tree.query(1,1,n,l,r,false)*siz-res*res;
				ll _gcd=gcd(resp,siz*siz);
				printf("%lld/%lld\n",resp/_gcd,siz*siz/_gcd);
			}
		}
	}
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```

额外的经验

1. [P1471 方差](https://www.luogu.com.cn/problem/P1471)
2. [P5142 区间方差](https://www.luogu.com.cn/problem/P5142) [题解](https://www.luogu.com.cn/blog/nizhuan/solution-p5142)

感谢您的阅读！

---

## 作者：QSWei (赞：2)

线段树

bt建树；

pushdown维护;

update操作1；

getsum操作2；

getmul操作3；

.c是权值的和；

.mul是权值平方的和；

.add传递  增加的值，用来维护；

代码；

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100000+5;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}
int n,m,len;
int a[maxn];
struct node
{
    int l,r,lc,rc;
    long long  c,mul,add;
}tr[maxn<<1];
void bt(int x,int y)
{
    len++; int now=len;
    tr[now].l=x; tr[now].r=y;
    tr[now].lc=tr[now].rc=0;
    if(x==y) 
    { tr[now].c=a[x]; tr[now].mul=a[x]*a[x]; }
    else
    {
        int mid=(x+y)>>1;
        tr[now].lc=len+1; bt(x,mid);
        tr[now].rc=len+1; bt(mid+1,y);
        tr[now].c=tr[tr[now].lc].c+tr[tr[now].rc].c;
        tr[now].mul=tr[tr[now].lc].mul+tr[tr[now].rc].mul;
    }
}
inline void pushdown(int now)
{
    if(tr[now].l==tr[now].r||!tr[now].add) return;
    int lc=tr[now].lc,rc=tr[now].rc;
    tr[lc].mul=tr[lc].mul+2*tr[lc].c*tr[now].add+(tr[lc].r-tr[lc].l+1)*tr[now].add*tr[now].add;
    tr[rc].mul=tr[rc].mul+2*tr[rc].c*tr[now].add+(tr[rc].r-tr[rc].l+1)*tr[now].add*tr[now].add;
    tr[lc].c=tr[lc].c+(tr[lc].r-tr[lc].l+1)*tr[now].add;
    tr[rc].c=tr[rc].c+(tr[rc].r-tr[rc].l+1)*tr[now].add;
    tr[lc].add+=tr[now].add; tr[rc].add+=tr[now].add;
    tr[now].add=0;
}
void update(int now,int x,int y,int d)
{
    if(tr[now].l==x&&tr[now].r==y)
    {
        tr[now].mul=tr[now].mul+2*tr[now].c*d+(tr[now].r-tr[now].l+1)*d*d;
        tr[now].c=tr[now].c+(y-x+1)*d;
        tr[now].add+=d;
    }else
    {
        pushdown(now);
        int lc=tr[now].lc,rc=tr[now].rc;
        int mid=(tr[now].l+tr[now].r)>>1;
        if(y<=mid) update(lc,x,y,d);
        else if(x>=mid+1) update(rc,x,y,d);
        else {  update(lc,x,mid,d); update(rc,mid+1,y,d); }
        tr[now].c=tr[lc].c+tr[rc].c;
        tr[now].mul=tr[lc].mul+tr[rc].mul;
    }
}
long long  getsum(int now,int x,int y)
{
    if(tr[now].l==x&&tr[now].r==y)
        return tr[now].c;
    else
    {
        pushdown(now);
        int lc=tr[now].lc,rc=tr[now].rc;
        int mid=(tr[now].l+tr[now].r)>>1;
        if(y<=mid) return getsum(lc,x,y);
        else if(x>=mid+1) return getsum(rc,x,y);
        else return getsum(lc,x,mid)+getsum(rc,mid+1,y);
    }
}
long long  getmul(int now,int x,int y)
{
    if(tr[now].l==x&&tr[now].r==y)
        return tr[now].mul;
    else
    {
        pushdown(now);
        int lc=tr[now].lc,rc=tr[now].rc;
        int mid=(tr[now].l+tr[now].r)>>1;
        if(y<=mid) return getmul(lc,x,y);
        else if(x>=mid+1) return getmul(rc,x,y);
        else return getmul(lc,x,mid)+getmul(rc,mid+1,y);
    }
}
long long  gcd(long long  a, long long  b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
int main()
{
    //freopen("classroom.in","r",stdin);
    //freopen("classroom.out","w",stdout);
    n=read();m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    bt(1,n);
    for(int i=1;i<=m;i++)
    {
        int p,x,y,d;
        p=read();
        if(p==1)
        {
            x=read(); y=read(); d=read();
            update(1,x,y,d);
        }else
        {
            x=read(); y=read();
            long long  sum,num,fz,fm,t;
            sum=getsum(1,x,y); num=y-x+1;
            if(!sum){cout<<0<<'/'<<1<<endl; continue;}
            t=gcd(sum,num);
            if(p==2) cout<<sum/t<<'/'<<num/t<<endl;
            else if(p==3)
            {
                long long  mul=getmul(1,x,y);
                fz=mul*num-sum*sum;
                fm=num*num;
                t=gcd(fz,fm);
                cout<<fz/t<<'/'<<fm/t<<endl;
            }
        }
    }
    return 0;
}

```

---

## 作者：0xFF (赞：1)

#### 题目大意


------------
给出一个数列 $\left \{ a_n \right \} $，支持三种操作

- 区间加
- 查询一段区间的平均数
- 查询一段区间的方差

#### 思路分析


------------
方差的公式为 $s^{2}=\frac{1}{n} \sum_{i=1}^{n}\left(a_{i}-\bar{a}\right)^{2}$

根据完全平方公式展开得到 $s^{2}=\frac{1}{n} \sum_{i=1}^{n}(a_i^2-2a_i\times\bar{a}+\bar{a}^2)$

$\therefore s^2 = \frac{(a_1^2+a_2^2+\cdots+a_n^2)+n \times \bar{a}^2-2 \bar{a}\times (a_1+a_2+\cdots+a_n)}{n}$

$\because \bar{a} = \frac{1}{n}\sum_{i=1}^na_i=\frac{a_1+a_2+\cdots+a_n}{n}$

$\therefore s^2 = \frac{a_1^2+a_2^2+\cdots+a_n^2}{n}+\bar{a}^2 - 2\bar{a}^2=\frac{a_1^2+a_2^2+\cdots+a_n^2}{n}-\bar{a}^2$

所以只需维护区间和、区间平方和即可。

对一段区间加 $k$ 的时候：

$a_1^2 + a_2^2+\cdots+a_n^2 \to (a_1+k)^2+(a_2+k)^2+\cdots+(a_n+k)^2$ 

$= \sum_{i=1}^n(a_i^2+k^2+2a_i\times k)$

$= a_1^2+a_2^2+\cdots+a_n^2+n\times k^2 + 2k\times(a_1+a_2+\cdots+a_n)$

注意，下传懒标记的时候需要先更新区间平方和再更新区间和，因为更新区间平方和需要用到原来的区间和。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<cctype>
#include<ctime>
#include<queue>
#define int long long
using namespace std;
const int N = 2e5 + 10;
const int mod = 1e9 + 7;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
    return x*f;
}
struct Tree{
	int l,r,add;
	int sum,pfsum;
}tree[N<<2];
void push_up(int p){
	tree[p].sum = tree[p<<1].sum + tree[p<<1|1].sum;
	tree[p].pfsum = tree[p<<1].pfsum + tree[p<<1|1].pfsum;
}
int a[N];
void build(int p,int l,int r){
	tree[p].l = l , tree[p].r = r;
	if(l == r){
		tree[p].sum = a[l];
		tree[p].pfsum = a[l] * a[l];
		return;
	}
	int mid = l + r >> 1;
	build(p<<1,l,mid); build(p<<1|1,mid+1,r);
	push_up(p);
}
void Add(int p,int k){
	tree[p].add += k;
	tree[p].pfsum += 2 * k * tree[p].sum + k * k * (tree[p].r - tree[p].l + 1);
	tree[p].sum += k * (tree[p].r - tree[p].l + 1);
}
void push_down(int p){
	if(tree[p].add != 0){
		Add(p<<1,tree[p].add);
		Add(p<<1|1,tree[p].add);
		tree[p].add = 0;
	}
}
void modify(int p,int l,int r,int k){
	if(l <= tree[p].l && tree[p].r <= r){
		Add(p,k);
		return;
	}
	push_down(p);
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) modify(p<<1,l,r,k);
	if(r >  mid) modify(p<<1|1,l,r,k);
	push_up(p);
}
int query1(int p,int l,int r){
	if(l <= tree[p].l && tree[p].r <= r){
		return tree[p].sum;
	}
	push_down(p);
	int res = 0;
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) res += query1(p<<1,l,r);
	if(r >  mid) res += query1(p<<1|1,l,r);
	return res;
}
int query2(int p,int l,int r){
	if(l <= tree[p].l && tree[p].r <= r){
		return tree[p].pfsum;
	}
	push_down(p);
	int res = 0;
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) res += query2(p<<1,l,r);
	if(r >  mid) res += query2(p<<1|1,l,r);
	return res;
}
int gcd(int a,int b){
	if(b == 0) return a;
	else return gcd(b,a%b);
}
signed main(){
	int n = read() , m = read();
	for(int i=1;i<=n;i++) a[i] = read();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int opt = read();
		if(opt == 1){
			int l = read() , r = read() , k = read();
			modify(1,l,r,k);
		}
		if(opt == 2){
			int l = read() , r = read();
			int res1 = query1(1,l,r);
			if(res1 == 0){
				printf("0/1\n");
				continue;
			}
			int res2 = r - l + 1;
			int pos = gcd(res1,res2);
			printf("%lld/%lld\n",res1/pos,res2/pos);
		}
		if(opt == 3){
			int l = read() , r = read();
			int sum = query1(1,l,r);
			int res1 = (r - l + 1) * query2(1,l,r) - sum * sum;
			if(res1 == 0){
				printf("0/1\n");
				continue;
			}
			int res2 = (r - l + 1) * (r - l + 1);
			int pos = gcd(res1,res2);
			if(res1 == 0) printf("0/1\n");
			printf("%lld/%lld\n",res1/pos,res2/pos);
		}
	}
	return 0;
}
```


---

## 作者：dxy2020 (赞：1)

显然这题要用线段树搞。

# 思路

平均数只需要求区间和，再除以区间长度即可。

那么区间方差怎么做呢？下面到了喜闻乐见的推式子环节：

设 $x$ 为 $[1,n]$ 平均数

方差公式

$$\frac{\sum_{i=1}^n {(a_i-x)^2}}{n}$$

完全平方公式展开

$$\frac{\sum_{i=1}^n {(a_i^2+x^2-2a_ix)}}{n}$$

分母拉进去展开

$$\sum_{i=1}^n {(\frac{a_i^2}{n}+\frac{x^2}{n}-\frac{2a_ix}{n})}$$

第一项拉出来

$$\frac{\sum_{i=1}^n {a_i^2}}{n}+\sum{_{i=1}^n{(\frac{x^2}{n}-\frac{2a_ix}{n})}}$$

后两项展开，设 $sqr$ 为 $[1,n]$ 平方和，$s$ 为 $[1,n]$ 的和，则 $s=nx$

$$\frac{sqr}{n}+x^2-\frac{2nx^2}{n}$$

合并同类项可得

$$\frac{sqr}{n}-x^2$$ 

将 $x$ 代换得

$$\frac{sqr}{n}-\frac{s^2}{n^2}$$

所以我们只需要分别维护区间平方和、区间和值即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,op;
int Tree1[400001],tag[400001],Tree2[400001],k;
inline int gcd (int a,int b){
	return !b?a:gcd (b,a%b); 
}
inline void push_up (int u){
	Tree1[u]=Tree1[u<<1]+Tree1[u<<1|1];
	Tree2[u]=Tree2[u<<1]+Tree2[u<<1|1];
}
inline void build (int u,int l,int r){
    tag[u]=0;
    if (l==r){
		scanf ("%lld",&Tree1[u]);
		Tree2[u]=Tree1[u]*Tree1[u];
    	return ;
	}
    int mid=l+r>>1;
    build (u<<1,l,mid);
    build (u<<1|1,mid+1,r);
    push_up (u);
}
inline void push_down (int u,int l,int r){
    if (l==r||!tag[u]) return;
    int mid=l+r>>1;
    tag[u<<1]+=tag[u];tag[u<<1|1]+=tag[u];
    Tree2[u<<1]+=2*tag[u]*Tree1[u<<1]+tag[u]*tag[u]*(mid-l+1);
	Tree2[u<<1|1]+=2*tag[u]*Tree1[u<<1|1]+tag[u]*tag[u]*(r-mid);
    Tree1[u<<1]+=tag[u]*(mid-l+1);Tree1[u<<1|1]+=tag[u]*(r-mid);
    tag[u]=0;
}
inline void update (int u,int l,int r){
    if (x<=l&&r<=y){
        tag[u]+=k;
        Tree2[u]+=2*Tree1[u]*k+k*k*(r-l+1);
        Tree1[u]+=k*(r-l+1);return ;
    }
    push_down (u,l,r);
    int mid=l+r>>1;
    if (x<=mid) update (u<<1,l,mid);
    if (mid<y) update (u<<1|1,mid+1,r);
    push_up (u);
}
inline int query_sum (int u,int l,int r){
    if (x<=l&&r<=y) return Tree1[u];
    push_down(u,l,r);
    int mid=l+r>>1,ans=0;
    if (x<=mid) ans=query_sum(u<<1,l,mid);
    if (mid<y) ans+=query_sum(u<<1|1,mid+1,r);
    return ans;
}
inline int query_sqr (int u,int l,int r){
    if (x<=l&&r<=y) return Tree2[u];
    push_down(u,l,r);
    int mid=l+r>>1;int ans=0;
    if (x<=mid) ans=query_sqr(u<<1,l,mid);
    if (mid<y) ans+=query_sqr(u<<1|1,mid+1,r);
    return ans;
}
signed main(){
    scanf ("%lld%lld",&n,&m);
    build(1,1,n);
    while(m--){
        scanf("%d",&op);
        if (op==1){
            scanf ("%lld%lld%lld",&x,&y,&k);
            update(1,1,n);
        }
        if (op==2){
            scanf ("%lld%lld",&x,&y);
            int Ans=query_sum (1,1,n),len=y-x+1;
            int g=gcd (Ans,len);Ans/=g;len/=g;
            printf ("%lld/%lld\n",Ans,len);
        }
        if (op==3){
            scanf ("%lld%lld",&x,&y);
            int len=y-x+1,ans1=query_sum(1,1,n),ans2=query_sqr(1,1,n);
            int Ans1=ans1*ans1,Ans2=ans2*len,Len=len*len,ANS=Ans2-Ans1;
            int g=gcd (ANS,Len);ANS/=g;Len/=g;
            printf ("%lld/%lld\n",ANS,Len);
        }
    }
    return 0;
}
```
双倍经验：[P1471 方差](https://www.luogu.com.cn/problem/P1471)

公式纯手打，希望管理大大能给过！

---

## 作者：Isshiki·Iroha (赞：1)

## 题解

[传送门](https://www.luogu.com.cn/problem/P2122)

[~~在博客里食用效果更佳~~](https://www.luogu.com.cn/blog/yousa22/solution-p2122)


### 正文

题目要求区间修改，区间求平均数，区间求方差，前面两个比较简单了吧。

$$\overline{a}=\frac{1}{n} \sum_{i=1}^{n}a_i$$

后面的 $\sum_{i=1}^{n}a_i$ 就是区间和了吧，就是线段树模板。要求分数**化简**后输出，我们直接同时除上**他们的最大公因数**即可：

令 $sum=\sum_{i=1}^{n}a_i$ 最终答案为

$$ans=\frac{sum \times \frac{1}{\gcd(sum,n)}}{n \times \frac{1}{\gcd(sum,n)}}$$

来看区间求方差，我们知道方差的公式是 

$$s^2=\frac{1}{n} \sum_{i=1}^n (a_i-\overline{a})^2$$

根据平方和公式

$$s^2=\frac{1}{n} \sum_{i=1}^n (a_i^2-2a_i\overline{a}+\overline{a}^2)$$

后面的 $\overline{a}^2$ 可以提出

$$s^2=\frac{1}{n}( \sum_{i=1}^n (a_i^2-2a_i\overline{a})+n\times\overline{a}^2)$$

化简:

$$s^2=\frac{1}{n}\sum_{i=1}^n (a_i^2-2a_i\overline{a})+\overline{a}^2$$

我们还可以把 $a_i^2-2a_i\overline{a}$ 分别提出

$$s^2=\frac{1}{n}\sum_{i=1}^n a_i^2-\frac{1}{n}\sum_{i=1}^n 2a_i\overline{a}+\overline{a}^2$$

我们发现第二项的 $2,\overline{a}$ 可以提到外面去

$$s^2=\frac{1}{n}\sum_{i=1}^n a_i^2-\frac{1}{n}\times2\times\overline{a}\sum_{i=1}^n a_i+\overline{a}^2$$

此时的 $\frac{1}{n}\sum_{i=1}^n a_i$ 不就是 $\overline{a}$ 吗？

$$s^2=\frac{1}{n}\sum_{i=1}^n a_i^2-2\overline{a}^2+\overline{a}^2$$

最后就是 

$$s^2=\frac{1}{n}\sum_{i=1}^n a_i^2-\overline{a}^2$$

此时我们已经知道：通过**维护一个区间平方和一个区间和**(上文也提到了)就可以算出方差，我们先不急，题目要我们写成**分数形式**，我们再化简一下。

$$s^2=\frac{\sum_{i=1}^n a_i^2-n\times\overline{a}^2}{n}$$

$$s^2=\frac{\sum_{i=1}^n a_i^2-n\times(\frac{1}{n}\sum_{i=1}^n{a_i})^2}{n}$$

提出括号里面的 $n$，与外面的 $n$ 消去

$$s^2=\frac{\sum_{i=1}^n a_i^2-\frac{1}{n}\times(\sum_{i=1}^n{a_i})^2}{n}$$

分子分母同时乘 $n$

$$s^2=\frac{n\times\sum_{i=1}^n a_i^2-(\sum_{i=1}^n{a_i})^2}{n^2}$$

接下来得到**分子分母的 $\gcd$ 再相除**即可。

最终答案已经确定了，现在还有一个问题，就是怎么维护**区间平方和**。

原来的式子:

$$\sum_{i=1}^n a_i^2$$

假设加上了 $x$

则变为:

$$\sum_{i=1}^n (a_i+x)^2$$

根据平方和公式

$$\sum_{i=1}^n (a_i^2+2a_ix+x^2)$$

提出 $x^2$

$$\sum_{i=1}^n (a_i^2+2a_ix)+n\times x^2$$

还是把 $(a_i^2+2a_ix)$ 拆开

$$\sum_{i=1}^n (a_i^2)+\sum_{i=1}^n (2a_ix)+n\times x^2$$

把 $x,2$ 提出括号

$$\sum_{i=1}^n (a_i^2)+n\times 2x\sum_{i=1}^n (a_i)+n\times x^2$$

我们发现第一项和第三项都是目前已知的，第二个是区间和，我们已经维护了。
所以维护就容易了。

**注意：上面的式子的 $1$ 就是区间左段点 $l$，$n$ 就是区间右端点 $r$，所以 $\frac{1}{n}$ 就相当于 $\frac{1}{r-l+1}$，$\sum_{i=1}^n$ 就相当于 $\sum_{i=l}^r$，$n$ 就是 $r-l+1$。**

我就只放部分代码了：

维护区间和和平方和

    inline void Add(int k,int l,int r,int v){
    //add表示区间要加的数字，就是 lazytag
        add[k]+=v;
        //按照上面的公式写
        pow_sum[k]=pow_sum[k]+sum[k]*2*v+(r-l+1)*v*v;
        sum[k]+=(r-l+1)*v;
    }
    inline void pushdown(int k,int l,int r){
        int mid=l+r>>1;
        if(!add[k])return;
        Add(ls,l,mid,add[k]);
        Add(rs,mid+1,r,add[k]);
        add[k]=0;
    }
    
 
 输出：
 
 ```cpp
        else if(opt==2){
            int ans1=query1(1,1,n,x,y);
            int ans2=y-x+1;
            int m=gcd(ans1,ans2);
            ans1/=m;
            ans2/=m;
            printf("%lld/%lld\n",ans1,ans2);
        }
        else {
        //query1是查询区间和
            int average=query1(1,1,n,x,y);
            average*=average;
        //query2是查询区间平方和
            int sum=query2(1,1,n,x,y)*(y-x+1);
            int ans1=sum-average;
            int ans2=(y-x+1)*(y-x+1);
            int m=gcd(ans1,ans2);
            ans1/=m;
            ans2/=m;
            printf("%lld/%lld\n",ans1,ans2);
        }
```


---

## 作者：Reywmp (赞：1)

- ## P2122 还教室

这熟悉的题面与输入

三种操作：1个修改2种查询。

足以想到我们的经典数据结构——线段树。

没有完全掌握或者不会线段树的同学可以康康我的[**学习笔记**](https://www.luogu.com.cn/blog/PandaStudioblog/SegmentTree)然后A了模板再来看这题哦

------------

这是一道基本可以说是模板形式的线段树题目，但是难度却不低。

无非是给定序列，让你**维护区间平均值与方差**。

但是这道题目离谱之处在于：

- **要求输出分数形式**

不过如果了解了思路与做法后也就是多对通分约分操作进行了要求。

------------

- ### Prelude

这是我们机房模拟赛的题目。我就顺便说说我的思路历程吧。

其实最开始我的想法是线段树，但是我想得就是直接维护方差平均值(指线段树内就存方差和平均值，~~我是个狼灭~~）。

我是怎么想的呢，我建了应该子结构体，存储分数的分子分母。顺便写了分数加分数乘以及简化分数的函数。

我仔细分析复杂度与实现难度，炸了。

然后我脑中就开始思考方差和平均值的共性，拿出草稿纸计算，于是得出正解思路。如下。

------------

- ### Solution

做这题你需要一定的小学(~~或初中~~?)数学知识:

首先区间`[l,r]`的平均值为(下文设为$\bar a$)：

$$

\displaystyle \frac{\sum_{i=l}^ra_i}{r-l+1}

$$

方差则是（下文设为$s^2$):

$$

\displaystyle \frac{\sum_{i=l}^r(a_i-\bar a)^2}{r-l+1}

$$

显然，平均值很好维护，我们只需要维护区间和再在输出时用分数表示区间和除以区间长度就行。

那么我们还要做的其实是用$\bar a$推出$s^2$。

我们展开单独的

$$(a_i- \bar a)^2$$

$$

=a_i^2-2a_i\bar a+\bar a^2

$$

分别分析$a_i^2$,$2a_i \bar a$,和 $\bar a^2$

- 对于$\sum a_i^2$:

我们可以直接单独维护，并不复杂，但对于区间$+x$的操作我们可以推出懒惰标记的下传公式是:

$$

\sum_{i=l}^r (a_i+x)^2

$$

$$

=\sum_{i=l}^r (a_i^2+2a_ix+x^2)

$$

$$

=\sum_{i=l}^r a_i^2+2x\sum_{i=l}^r a_i+(r-l+1)x^2

$$

在这里我们就很明显看出来我们要维护的就是区间和($\sum a_i$)与平方和($\sum a_i^2$)了。

但是根据上面式子，我们只需要维护一个懒惰标记。

- 对于$\sum 2a_i \bar a$:

对于每个区间的平均值我们已经有了维护方法，所以在这我们将其视为定值($\frac{\sum a_i}{r-l+1}$)，于是我们将式子转换成:

$$
2 \bar a \sum a_i 
$$


$$
=\frac{2\sum a_i}{r-l+1} \sum a_i
$$

$$
=\frac{2(\sum a_i)^2}{r-l+1}
$$
- 对于$\sum \bar a^2$

显然我们有$\sum \bar a^2$=$(r-l+1)\bar a^2$


我们再像之前一样代入$\bar a$

于是乎:
$$

\sum \bar a_i^2

$$

$$
=(r-l+1)(\frac{\sum a_i}{r-l+1})^2
$$

$$
=\frac{(\sum a_i)^2}{r-l+1}
$$

我们发现可以消了，于是列出全式：

$$
s^2=\frac{\sum(a_i-\bar a)^2}{r-l+1}
$$

$$

=\frac{\sum a_i^2-\sum2a_i\bar a+\sum \bar a^2}{r-l+1}
$$
$$

=\frac{\sum a_i^2-\frac{2(\sum a_i)^2}{r-l+1}+\frac{(\sum a_i)^2}{r-l+1}}{r-l+1}

$$

$$

=\frac{(r-l+1)\sum a_i^2-{(\sum a_i)^2}}{(r-l+1)^2}
$$

可能略显麻烦，但是有结果就是好的。

所以我们得出了一个只需要$\sum a_i^2$和$\sum a_i$就可以维护区间方差的式子。

求方差时，最后结果就先查询区间和区间平方和，然后按照这个公式输出就可以了。

------------

- ### Code

有几个易错点在这里说一下。

- 记得开`long long`，虽然$a_i$和$d$的范围在两位数以内，但是一旦要求计算成一个$10^5$区间的平方和，这题没有模数，所以自然需要`long long`。

- 下传标记和更新计算时先更新平方和再更新区间和，根据上面式子可知要的是更新前的区间和来更新平方和。在Pushdown函数中有体现（我的是`PD(int p)`)

```cpp
#include<cstdio>
#include<cstring>
#include<cmath> 
#include<iostream>
#include<algorithm>

#define N 100005
#define ll long long 

using namespace std;

struct Rey
{
	int l,r;
	ll s1,s2;
	ll lazadd;
}T[N<<2];
int n,m;
ll a[N];

ll gcd(ll a,ll b)
{
	return !b?a:gcd(b,a%b);
}

ll lcm(ll a,ll b)
{
	return (a*b)/gcd(a,b);
}

int LS(int p){return p<<1;}
int RS(int p){return p<<1|1;}

void UPDATE_sum(int p)
{
	T[p].s1=T[LS(p)].s1+T[RS(p)].s1;
	T[p].s2=T[LS(p)].s2+T[RS(p)].s2;
}

void build(int p,int l,int r)
{
	T[p].l=l,T[p].r=r;
	if(l==r){T[p].s1=a[l],T[p].s2=a[l]*a[l];return;}
	int mid=(l+r)>>1; 
	build(LS(p),l,mid);
	build(RS(p),mid+1,r);
	UPDATE_sum(p);
}

void PD(int p)
{
	int L,R;
	ll ADD=T[p].lazadd;
	L=LS(p),R=RS(p);
	T[L].s2+=2*ADD*T[L].s1+(T[L].r-T[L].l+1)*ADD*ADD*1ll;
	T[R].s2+=2*ADD*T[R].s1+(T[R].r-T[R].l+1)*ADD*ADD*1ll;
	T[L].s1+=ADD*(T[L].r-T[L].l+1)*1ll;
	T[R].s1+=ADD*(T[R].r-T[R].l+1)*1ll;
	T[L].lazadd+=ADD;
	T[R].lazadd+=ADD;
	T[p].lazadd=0;
}

void FIX(int p,int l,int r,ll x)
{
	if(l>T[p].r||T[p].l>r)return;
	if(T[p].l>=l&&T[p].r<=r)
	{
		T[p].lazadd+=x;
		T[p].s2+=T[p].s1*2*x+(T[p].r-T[p].l+1)*x*x*1ll;
		T[p].s1+=x*(T[p].r-T[p].l+1)*1ll; 
		return ;
	}
	if(T[p].lazadd)PD(p);
	FIX(LS(p),l,r,x);
	FIX(RS(p),l,r,x);
	UPDATE_sum(p);
}

ll Vuq1(int p,int l,int r)//查询区间和
{
	ll res=0;
	if(l>T[p].r||T[p].l>r)return 0;
	if(T[p].l>=l&&T[p].r<=r)return T[p].s1;
	if(T[p].lazadd)PD(p);
	res+=Vuq1(LS(p),l,r);
	res+=Vuq1(RS(p),l,r);
	return res; 
}

ll Vuq2(int p,int l,int r)//区间平方和
{
	ll res=0;
	if(l>T[p].r||T[p].l>r)return 0;
	if(T[p].l>=l&&T[p].r<=r)return T[p].s2;
	if(T[p].lazadd)PD(p);
	res+=Vuq2(LS(p),l,r);
	res+=Vuq2(RS(p),l,r);
	return res; 
}

int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	build(1,1,n);
	while(m--)
	{
		int op;
		scanf("%d",&op);
		if(op==1)
		{
			int x,y;
			ll z;
			scanf("%d %d %lld",&x,&y,&z);
			FIX(1,x,y,z);
		}
		if(op==2)
		{
			int x,y;
			scanf("%d %d",&x,&y);
			ll sum=Vuq1(1,x,y);
			ll mu=y-x+1;
			ll G=gcd(sum,mu);
			printf("%lld/%lld\n",sum/G,mu/G); 
		}
		if(op==3)
		{
			int x,y;
			scanf("%d %d",&x,&y);
			ll sum1=Vuq1(1,x,y);
			ll sum2=Vuq2(1,x,y);
			ll mu=(ll)(y-x+1);
			ll sum=mu*sum2-sum1*sum1*1ll;
			mu=mu*mu;
			ll G=gcd(sum,mu);
			printf("%lld/%lld\n",sum/G,mu/G);
            //要求最简形式所以同除以GCD约分
			 
		}
	}
	return 0;
}
```

---

## 作者：little_gift (赞：1)

区间加区间平均数区间方差.

考虑线段树.

区间平均数$\bar{x}=\frac{1}{n}\sum_{k=1}^nx_k$.

那么只需要维护$\sum_{k=1}^nx_k$, 即区间和即可.

考虑区间方差.

$\sigma^2=\frac{1}{n}\sum_{k=1}^n\left(x_k-\bar{x}\right)^2$

展开平方然后分离化简得到

$\sigma^2=\frac{1}{n}\left(\sum_{k=1}^nx_k^2-2\bar{x}\sum_{k=1}^n+n\bar{x}^2\right)$

设区间和$s_1=\sum_{k=l}^ra_k$, 平方和$s_2=\sum_{k=l}^ra_k^2$

那么只需要一棵线段树维护这两个信息.

区间加的时候更新和与平方和.

其中对于平方和的区间加$x$的维护是$s_2'=\sum_{k=1}^n\left(a_k+x\right)^2=s_2+2s_1x+nx^2$.

区间平均数需要求出区间和然后除以区间长度.

区间方差的话那么就是$\frac{ns_2-s_1^2}{n^2}$.

什么?你问我既约分数怎么处理?

你怕是传说中的不会gcd就写线段树的神仙.

当然很显然线段树已经有很多题解写过了并且思路基本差不多.

所以这里放的是一个标记永久化的线段树.

```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
struct _ { //线段树节点
    ll s1, s2; //区间和，平方和.
    _(const ll& s1 = 0, const ll& s2 = 0) : s1(s1), s2(s2) {}
    _& operator=(const _& rhs) {s1 = rhs.s1, s2 = rhs.s2; return *this;}
    _ operator+(const _& rhs) const {return _(s1 + rhs.s1, s2 + rhs.s2);}
    _& operator+=(const _& rhs) {s1 += rhs.s1, s2 += rhs.s2; return *this;}
    _ add(const ll& t, const ll& len) const {
        return _(s1 + len * t, s2 + 2 * s1 * t + len * t * t);
    } //各种维护信息
} tree[400001]; //这里的tree[]的定义是执行当前节点及其子树中所有的add操作(tag)之后的值
ll tag[400001];
void build(const int& h, const int& l, const int& r) {
    if (l == r) {
        scanf("%lld", &tree[h].s1);
        tree[h].s2 = tree[h].s1 * tree[h].s1;
        return;
    }
    int mid = (l + r) >> 1;
    build(h << 1, l, mid); build(h << 1 | 1, mid + 1, r);
    tree[h] = tree[h << 1] + tree[h << 1 | 1];
}
void add(const int& h, const int& l, const int& r, const int& L, const int& R, const int& x) {
    if (L <= l && r <= R) {
        tag[h] += x;
        tree[h] = tree[h].add(x, r - l + 1);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) add(h << 1, l, mid, L, R, x);
    if (mid < R) add(h << 1 | 1, mid + 1, r, L, R, x);
    tree[h] = (tree[h << 1] + tree[h << 1 | 1]).add(tag[h], r - l + 1); //不要忘记维护的时候要考虑标记
}
_ sum(const int& h, const int& l, const int& r, const int& L, const int& R) {
    if (L <= l && r <= R)
        return tree[h];
    _ ret;
    int mid = (l + r) >> 1;
    if (R <= mid) ret = sum(h << 1, l, mid, L, R);
    else if (mid < L) ret = sum(h << 1 | 1, mid + 1, r, L, R);
    else ret = sum(h << 1, l, mid, L, mid) + sum(h << 1 | 1, mid + 1, r, mid + 1, R); //标记永久化可以有很多种写法, 这里是其中一种, 多写一个if.
    return ret.add(tag[h], R - L + 1);
}
inline ll gcd(ll a, ll b) {
    for (ll c; (c = a % b); a = b, b = c);
    return b;
}
int n, m;
int main() {
    scanf("%d%d", &n, &m);
    build(1, 1, n);
    while (m--) {
        int opt, l, r, d;
        scanf("%d%d%d", &opt, &l, &r);
        if (opt == 1) {
            scanf("%d", &d);
            add(1, 1, n, l, r, d);
        }
        else if (opt == 2) {
            ll s1 = sum(1, 1, n, l, r).s1;
            int len = r - l + 1;
            ll d = gcd(s1, len);
            printf("%lld/%lld\n", s1 / d, len / d);
        }
        else if (opt == 3) {
            _ temp = sum(1, 1, n, l, r);
            int len = r - l + 1;
            ll s1 = temp.s1, s2 = temp.s2;
            ll a = s2 * len - s1 * s1, b = 1ll * len * len; //奇怪的计算
            ll d = gcd(a, b);
            printf("%lld/%lld\n", a / d, b / d);
        }
    }
}
```



---

## 作者：Shanganze (赞：0)

三倍经验：[P1471](https://www.luogu.com.cn/problem/P1471) $\;$[P5142](https://www.luogu.com.cn/problem/P5142)
### 分析：

一看题意，区间加，求区间平均值，求区间内的方差，都是区间操作，很容易想到到用线段树来维护。

区间加：直接打个线段树一的板子。

区间求平均值：直接区间求和，然后除以区间长度。

#### 区间方差：
此题最大的难点就是求区间的方差。

先来看一下方差公式：定义 $a$ 为区间平均值，$l$ 为左端点，$r$ 为右端点，$n$ 为长度,即 $r-l+1$。

$$\frac{1}{n}\sum\limits^r_{i=l}(a_i-a)^2$$
我们可以把这个公式化简一下得：
$$\frac{na^2+(a_l^2+a_{l+1}^2+a_{l+2}^2…+a_r^2)+2a(a_l+a_{l+1}+a_{l+2}+…+a_r)}{n}$$
这样只要记录下序列的和 $\sum\limits^r_{i=l}$ 和平方和 $\sum\limits^r_{i=l}a_i^2$，就可求出方差。

然后就是考虑懒惰标记怎样下传，求和部分懒标记的根据模板来就行，主要分析一下平方和的懒标记怎样传递。

由 
$$a_l^2+a_{l+1}^2+…+a_{r}^2$$

变为 
$$(a_l+x)^2+(a_{l+1}+x)^2+…+(a_{r}+x)^2$$

化简得：
$$(a_l^2+a_{l+1}^2+…+a_{r}^2)+nx^2+(a_l+a_{l+1}+a_{l+2}+…+a_r)$$ 
所以懒标记就处理好了。

还有最后的分式形式输出，求两数最大公约数在分别除。
话说我在这，卡了半天。

## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N=1e5+1;
struct a1
{
	int l,r;
	int pow,he;
}x[8000051];
int d[8000051],j[8000051];
void build(int p,int l,int r)//建树
{
	x[p].l=l;x[p].r=r;
	if(l==r)
	{
		x[p].he=d[l];
		x[p].pow=d[l]*d[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	x[p].he=x[p<<1].he+x[p<<1|1].he;
	x[p].pow=x[p<<1].pow+x[p<<1|1].pow;
}
void pushdown(int p)//重点，懒标记。
{
	if(j[p]!=0)
	{
		j[p<<1]+=j[p];
		j[p<<1|1]+=j[p];
		x[p<<1].pow+=2*j[p]*x[p<<1].he+(int)(x[p<<1].r-x[p<<1].l+1)*j[p]*j[p];
		x[p<<1|1].pow+=2*j[p]*x[p<<1|1].he+(int)(x[p<<1|1].r-x[p<<1|1].l+1)*j[p]*j[p];
		x[p<<1].he+=(int)(x[p<<1].r-x[p<<1].l+1)*j[p];
		x[p<<1|1].he+=(int)(x[p<<1|1].r-x[p<<1|1].l+1)*j[p];
		j[p]=0;
	}
}
void jj(int p,int l,int r,int k)
{
	if(x[p].l>=l&&x[p].r<=r)
	{
		x[p].pow+=2*k*x[p].he+(x[p].r-x[p].l+1)*k*k;
		x[p].he+=(x[p].r-x[p].l+1)*k;
		j[p]+=k;
		return ;
	}
	pushdown(p);
	int mid=(x[p].l+x[p].r)>>1;
	if(mid>=l)
	{
		jj(p<<1,l,r,k);
	}
	if(mid<r)
	{
		jj(p<<1|1,l,r,k);
	}
	x[p].he=x[p<<1].he+x[p<<1|1].he;
	x[p].pow=x[p<<1].pow+x[p<<1|1].pow;
}
int getsum1(int p,int l,int r)
{
	if(x[p].l>=l&&x[p].r<=r)
	{
		return x[p].he;
	}
	pushdown(p);
	int mid=(x[p].l+x[p].r)>>1;
	int ans=0;
	if(mid>=l)ans+=getsum1(p<<1,l,r);
	if(mid<r)ans+=getsum1(p<<1|1,l,r);
	return ans;
}
int getsum2(int p,int l,int r)
{
	if(x[p].l>=l&&x[p].r<=r)
	{
		return x[p].pow;
	}
	pushdown(p);
	int mid=(x[p].l+x[p].r)>>1;
	int ans=0;
	if(mid>=l)ans+=getsum2(p<<1,l,r);
	if(mid<r)ans+=getsum2(p<<1|1,l,r);
	return ans;
}
signed main()
{
	int n,m;
	cin>>n>>m;
	for(int q=1;q<=n;q++)cin>>d[q];
	build(1,1,n);
	for(int q=1;q<=m;q++)
	{
		int a;
		a=read();
		if(a==1)
		{
			int x,y;
			int k;
			x=read();y=read();cin>>k;
			jj(1,x,y,k);
		}
		else if(a==2)
		{
			int x,y;
			x=read();y=read();
			int i=getsum1(1,x,y);
			int j=(y-x+1);
			if(j==0||i==0)
			{
				cout<<"0/1\n";
			}
			else 
			{
				int o=__gcd(i,j);
			    cout<<i/o<<"/"<<j/o<<endl;
			}
		}
		else 
		{
			int x,y;
			x=read();y=read();
			int p=getsum1(1,x,y);
			int ans=p*p+getsum2(1,x,y)*(y-x+1)-2*p*p;
            int i=ans;
			int j=(y-x+1)*(y-x+1);
			if(j==0||i==0)
			{
				cout<<"0/1\n";
			}
			else 
			{
				int o=__gcd(i,j);
			    cout<<i/o<<"/"<<j/o<<endl;
			}
		}
	}
	return 0;
} 
```



---

## 作者：dingshengyang (赞：0)

本题解分为 $3$ 部分：

---

$1$.分数。题目既然要求我们求分数（还要约分），那么自然应该写一个结构体。

约分方法：分子 $x$、分母 $y$ 同时除以 $\gcd(x,y)$。（不会吧，如果这都不会建议重读小学）。

这里有一个分数结构体，重载了四则运算：

```cpp
typedef pair<LL, LL> PII;

LL gcd(LL a, LL b) {
	return (!b) ? (a) : (gcd(b, a % b));
}

struct fra {
	LL x, y;
	void judge() {//约分
		LL gg = gcd(x, y);
		x /= gg;
		y /= gg;
	}
	fra operator =(pair<LL, LL> p) {//赋值
		x = p.first;
		y = p.second;
		judge();
		return *this;
	}
	fra operator +(fra p) {//四则运算（自动约分）
		LL ny = y * p.y;
		LL nx = (p.y * x) + (y * p.x);
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator -(fra p) {
		LL ny = y * p.y;
		LL nx = (p.y * x) - (y * p.x);
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator *(fra p) {
		LL nx = x * p.x;
		LL ny = y * p.y;
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator /(fra p) {
		fra tmp = {p.y, p.x};
		return (*this) * tmp;
	}
	fra rec() {//倒数
		return {y, x};
	}
};
```

$2$.公式推导。这题只要有了公式就很简单了。

- 平均数：设总和为 $sum$，区间长度为 $len$，则平均数 $\bar{a}$ 为 $\dfrac{sum}{len}$。

- 方差：方差不好直接推，我们考虑维护平方和。

  case $1$：当区间加 $d$ 时，设原来平方和为 $fs$，统一加 $v$，且原来总值为 $sum$。
  
  
  则现在有：$\sum^{r}_{i=l} (a_i+v)^2$；
  
  
  用完全平方公式打开得 $\sum^{r}_{i=l} {a_i^2 + a_i \times v \times 2  + v^2}$。
  
  然后得：$\sum^{r}_{i=l} a_i^2 + 2\times v \times \sum^{r}_{i=l} a_i + \sum^{r}_{i=l} v^2$。
  
  我们用 $fs$ 替换 $\sum^{r}_{i=l}$，然后用 $sum$ 替换 $\sum^{r}_{i=l}$。
  
  得现在平方和是：$fs + 2 \times v \times sum + \sum^{r}_{i=l} v^2$。
  
  我们只需要加 $2 \times v \times sum + \sum^{r}_{i=l} v^2$ 就可以了。
  
  ---
  
  case $2$：用平方和计算出方差。这个麻烦一点。
  
  原式 $ = \sum^{r}_{i = l} (a_i - \bar{a})^2$。
  
  用完全平方公式打开得 $\sum^{r}_{i = l} a_i^2 - \sum^{r}_{i=l}2 \times \bar{a} \times a_i+ \sum^{r}_{i=l}\bar{a}^2$。
  
  然后得：$fs - \bar{a} \times 2 \times sum +  \sum^{r}_{i=l} \bar{a}^2$。
  
  进一步得：$fs - 2 \times sum \times \bar{a} + \dfrac{sum^2}{r-l+1}$。就好算了。
  
  也就是：$fs - 2 \times sum \times \dfrac{sum}{r - l + 1} + \dfrac{sum^2}{r-l+1}$。
  
  得出：$fs - 2 \times \dfrac{sum^2}{r - l + 1} + \dfrac{sum^2}{r-l+1}$。
  
  别急，马上就推好了！
  
  现在有：$fs - \dfrac{2 \times sum^2}{r-l+1} + \dfrac{sum^2}{r-l+1}$。
  
  为了方便我们写程序，还可以化成：$\dfrac{(r-l+1) \times fs - sum^2}{(r-l+1)^2}$。
  
  现在很方便，不是吗？
  
  
  ---
  
  $3$.代码时间！
  
```cpp
#include <bits/stdc++.h>
#define R register
#define inl inline
#define fastios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#define Debug(file) freopen(file".in","r",stdin);freopen(file".out","w",stdout);
using namespace std;
#define L(u) (u << 1)
#define R(u) ((u << 1) | 1)
typedef unsigned long long LL;
LL f(LL x) {
	return x * x;
}
typedef pair<LL, LL> PII;

LL gcd(LL a, LL b) {
	return (!b) ? (a) : (gcd(b, a % b));
}

struct fra {
	LL x, y;
	void judge() {
		LL gg = gcd(x, y);
		x /= gg;
		y /= gg;
	}
	fra operator =(pair<LL, LL> p) {
		x = p.first;
		y = p.second;
		judge();
		return *this;
	}
	fra operator +(fra p) {
		LL ny = y * p.y;
		LL nx = (p.y * x) + (y * p.x);
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator -(fra p) {
		LL ny = y * p.y;
		LL nx = (p.y * x) - (y * p.x);
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator *(fra p) {
		LL nx = x * p.x;
		LL ny = y * p.y;
		fra tmp = {nx, ny};
		tmp.judge();
		return tmp;
	}
	fra operator /(fra p) {
		fra tmp = {p.y, p.x};
		return (*this) * tmp;
	}
	fra rec() {
		return {y, x};
	}
};

istream &operator >>(istream &i, fra &f) {
	scanf("%llu/%llu", &f.x, &f.y);
	return i;
}

ostream &operator <<(ostream &o, fra f) {
	printf("%llu/%llu", f.x, f.y);
	return o;
}
```


```cpp
/*----------FRACTION-----------PART------------*/
const int N = 1e5 + 5;

struct node {
	int l, r;
	LL ps, sum;
	LL add;
} tr[N * 4];
LL n, m, a[N];

void pushup(int u) {
	tr[u].ps = tr[u << 1].ps + tr[u << 1 | 1].ps;
	tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(int u) {	
	node &l = tr[u << 1];
	node &r = tr[u << 1 | 1];
	node &now = tr[u];
	l.add += now.add;
	r.add += now.add;
	l.ps += (f(now.add) * (l.r - l.l + 1)) + (2ll * l.sum * now.add);
	r.ps += (f(now.add) * (r.r - r.l + 1)) + (2ll * r.sum * now.add);
	l.sum += (l.r - l.l + 1ll) * now.add;
	r.sum += (r.r - r.l + 1ll) * now.add;
	now.add = 0;
}

void build(int u, int l, int r) {
	if (l == r)
		tr[u] = {l, r, f(a[l]), a[l],0};
	else {
		int mid = l + r >> 1;
		tr[u] = {l, r, 0, 0, 0};
		build(L(u), l, mid);
		build(R(u), mid + 1, r);
		pushup(u);
	}
}

void modify(int u, int l, int r, LL v) {
	if (l <= tr[u].l && tr[u].r <= r) {
		tr[u].add += v;
		tr[u].ps += (f(v) * (tr[u].r - tr[u].l + 1)) + (2ll * tr[u].sum * v);
		tr[u].sum += (tr[u].r - tr[u].l + 1) * v;
	} else {
		int mid = (tr[u].l + tr[u].r) >> 1;
		pushdown(u);
		if (l <= mid) {
			modify(u << 1, l, r, v);
		}
		if (r > mid) {
			modify(u << 1 | 1, l, r, v);
		}
		pushup(u);
	}
}

LL query_sum(int u, int l, int r) {
	if (l <= tr[u].l && tr[u].r <= r) {
		return tr[u].sum;
	} else {
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		LL ans = 0;
		if (l <= mid)
			ans = query_sum(u << 1, l, r);
		if (r > mid)
			ans += query_sum(u << 1 | 1, l, r);
		return ans;
	}
}

LL query_fs(int u, int l, int r) {
	if (l <= tr[u].l && tr[u].r <= r) {
		return tr[u].ps;
	} else {
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		LL ans = 0;
		if (l <= mid)
			ans += query_fs(u << 1, l, r);
		if (r > mid)
			ans += query_fs(u << 1 | 1, l, r);
		return ans;
	}
}
```


```cpp
/*----------SEGMENT----TREE----PART------------*/
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++)
		scanf("%llu", &a[i]);
	build(1,1,n);
	for (int i = 0; i < m; i ++) {
		int op, l, r;LL d;
		scanf("%d%d%d", &op, &l, &r);
		if (op == 1) {
			scanf("%llu", &d);
			modify(1, l, r, d);
		}
		if (op == 2) {
			fra tmp = {query_sum(1, l, r), (r - l + 1)};
			tmp.judge();
			cout << tmp << endl;
		}
		if (op == 3) {
			LL sum = query_sum(1,l,r);
			LL pfs = query_fs(1,l,r);
			LL len = r-l+1;
			//printf("pfs:%llu sum:%llu\n",pfs,sum);
			fra ans = {len*pfs-sum*sum,len*len};
			ans.judge();
			cout << ans << endl;
		}
	}
	return 0;
}
```
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

---

## 作者：zhimao (赞：0)

### 背景

纪念NOIP复活所作

### 分析

首先，显然，本题一看就知道要用**线段树**去做。

对于第一个操作，区间修改没问题。 

而第二个操作：求平均数，就是区间求和/区间长度。

第三个操作是重点。方差，凡学过初二下的数学统计的同学都知道，即：方差
**b=((a[i]-c)²+(a[i+1]-c)²+(a[i+2]-c)²+…+(a[j]-c)²)/(j-i+1)（c为a[i]到a[j]的平均数）**

看上去它不能被拆分进而通过区间查询解决（因为c），但我们可以用完全平方式将它变形，如下：(n=j-i+1)

    b=(n*c²+(a[i]²+a[i+1]²+a[i+2]²+…+a[j]²)-2c(a[i]+a[i+1]+a[i+2]+…a[j]))/n
     =((a[i]+a[i+1]+a[i+2]+…a[j])²/n+(a[i]²+a[i+1]²+a[i+2]²+…+a[j]²)-2(a[i]+a[i+1]+a[i+2]+…a[j])²/n)/n
     =((a[i]²+a[i+1]²+a[i+2]²+…+a[j]²)-(a[i]+a[i+1]+a[i+2]+…a[j])²/n)/n
     =((a[i]²+a[i+1]²+a[i+2]²+…+a[j]²)*n-(a[i]+a[i+1]+a[i+2]+…a[j])²)/n²
其中，(a[i]+a[i+1]+a[i+2]+…a[j])²可以由区间求和再平方得到，a[i]²+a[i+1]²+a[i+2]²+…+a[j]²可以再建一棵线段树。

但对它区间修改(每个数+z）又是一个问题，再算一波：(n=j-i+1)

    x=a[i]²+a[i+1]²+a[i+2]²+…+a[j]²;
    y=(a[i]+z)²+(a[i+1]+z)²+(a[i+2]+z)²+…+(a[j]+z)²
     =x+n*z²+2*z*(a[i]+a[i+1]+a[i+2]+…+a[j])
于是，又化为了第一棵线段树的问题。成功！

既约分数~~听上去好怪~~就用一下gcd。

最后，千万记得要用****int64****。

### 代码

附上代码：（超长qwq）
```pascal
var a,lazy,a1:array[0..400005] of int64;
  b:array[0..100005] of int64;
  n,m,i,j,c,x,y,z,t:longint;
  p,q,r:int64;
function gcd(p,q:int64):int64;
begin
  repeat
    gcd:=p mod q;
    p:=q;
    q:=gcd;
  until q=0;
  gcd:=p;
end;
procedure pushdown(l,r,mid,k:longint);
begin
  a1[k*2]:=a1[k*2]+(mid-l+1)*lazy[k]*lazy[k]+2*lazy[k]*a[k*2];
  a1[k*2+1]:=a1[k*2+1]+(r-mid)*lazy[k]*lazy[k]+2*lazy[k]*a[k*2+1];
  a[k*2]:=a[k*2]+(mid-l+1)*lazy[k];
  a[k*2+1]:=a[k*2+1]+(r-mid)*lazy[k];
  inc(lazy[k*2],lazy[k]);inc(lazy[k*2+1],lazy[k]);lazy[k]:=0;
end;
procedure build(l,r,k:longint);
var mid:longint;
begin
  if l=r then begin a[k]:=b[l];a1[k]:=b[l]*b[l];exit;end;
  mid:=(l+r) div 2;
  build(l,mid,k*2);
  build(mid+1,r,k*2+1);
  a[k]:=a[k*2]+a[k*2+1];
  a1[k]:=a1[k*2]+a1[k*2+1];
end;
function find(l,r,k:longint):int64;
var mid:longint;
  s1,s2:int64;
begin
  if(l>=x)and(r<=y)then exit(a[k]);
  mid:=(l+r) div 2;
  pushdown(l,r,mid,k);
  if x<=mid then s1:=find(l,mid,k*2) else s1:=0;
  if y>mid then s2:=find(mid+1,r,k*2+1) else s2:=0;
  find:=s1+s2;
end;
function find1(l,r,k:longint):int64;
var mid:longint;
  s1,s2:int64;
begin
  if(l>=x)and(r<=y)then exit(a1[k]);
  mid:=(l+r) div 2;
  pushdown(l,r,mid,k);
  if x<=mid then s1:=find1(l,mid,k*2) else s1:=0;
  if y>mid then s2:=find1(mid+1,r,k*2+1) else s2:=0;
  find1:=s1+s2;
end;
procedure update(l,r,k,t:longint);
var mid:longint;
begin
  if(l>=x)and(r<=y)then
    begin
      a1[k]:=a1[k]+(r-l+1)*t*t+2*t*a[k];
      a[k]:=a[k]+t*(r-l+1);
      lazy[k]:=t+lazy[k];
      exit;
    end;
  mid:=(l+r) div 2;
  pushdown(l,r,mid,k);
  if y<=mid then update(l,mid,k*2,t)else
  if x>mid then update(mid+1,r,k*2+1,t)else
    begin
      update(mid+1,r,k*2+1,t);update(l,mid,k*2,t);
    end;
  a[k]:=a[k*2]+a[k*2+1];
  a1[k]:=a1[k*2]+a1[k*2+1];
end;
begin
  readln(n,m);
  for i:= 1 to n do read(b[i]);
  build(1,n,1);
  for i:= 1 to m do
    begin
      read(Z);
      case z of
        1:begin
            read(x,y,t);
            update(1,n,1,t);
          end;
        2:begin
            read(x,y);
            p:=find(1,n,1);
            q:=y-x+1;
            r:=gcd(p,q);
            p:=p div r;
            q:=q div r;
            writeln(p,'/',q);
          end;
        3:begin
            read(x,y);
            p:=find(1,n,1);
            p:=(y-x+1)*find1(1,n,1)-p*p;
            q:=(y-x+1)*(y-x+1);
            r:=gcd(p,q);
            p:=p div r;
            q:=q div r;
            writeln(p,'/',q);
          end;
      end;
    end;
  close(input);close(output);
end.
```

本蒟蒻Markdown与LaTeX不太会用请谅解。

---

## 作者：AcRapper (赞：0)

关于本题的解法楼上和楼下已经说的非常详细了，在这里提供一份非结构体线段树的代码供像我一样不喜欢写结构体线段树的人参考。

细节在注释里
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=1e5;
int n,m;
ll a[maxn];
ll ans[maxn<<2],tag[maxn<<2],sum[maxn<<2];//ans是区间和，tag是懒惰标记，sum是区间平方和
inline int ls(ll p){return p<<1;}
inline int rs(ll p){return p<<1|1;}
//左右子树
void push_up(ll p){ans[p]=ans[ls(p)]+ans[rs(p)];sum[p]=sum[ls(p)]+sum[rs(p)];}
void build(ll p,ll l, ll r)
{
	tag[p]=0;
	if(l==r){ans[p]=a[l];sum[p]=a[l]*a[l];return ;}
	ll mid =(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	push_up(p);
}
//建树
inline void f(ll p,ll l, ll r ,ll k)
{
	tag[p]+=k;
	sum[p]+=2*k*ans[p]+k*k*(r-l+1);
	ans[p]+=k*(r-l+1);
}
//↑用来处理区间加的函数，方便理清思路
inline void push_down(ll p, ll l, ll r)
{
	ll mid=(l+r)>>1;
	f(ls(p),l,mid,tag[p]);
	f(rs(p),mid+1,r,tag[p]);
	tag[p]=0;
}
//下传懒惰标记，记得清零
inline void update(ll nl,ll nr,ll l, ll r,ll p,ll k)
{
	if(nl<=l&&nr>=r){f(p,l,r,k);return;}
	push_down(p,l,r);
	ll mid=(l+r)>>1;
	if(nl<=mid)update(nl,nr,l,mid,ls(p),k);
	if(nr>mid)update(nl,nr,mid+1,r,rs(p),k);
	push_up(p);
}
//不会的出门左转线段树模板1
ll query(ll qx,ll qy,ll l,ll r,ll p)
{
	ll res=0;
	if(qx<=l&&qy>=r)return ans[p];
	ll mid=(l+r)>>1;
	push_down(p,l,r);
	if(qx<=mid)res+=query(qx,qy,l,mid,ls(p));
	if(qy>mid)res+=query(qx,qy,mid+1,r,rs(p));
	return res;
}
//↑计算区间和
ll query2(ll qx,ll qy,ll l,ll r,ll p)
{

	ll res=0;
	if(qx<=l&&qy>=r)return sum[p];
	ll mid=(l+r)>>1;
	push_down(p,l,r);
	if(qx<=mid)res+=query2(qx,qy,l,mid,ls(p));
	if(qy> mid)res+=query2(qx,qy,mid+1,r,rs(p));
	return res;
}
//↑计算区间平方和
ll gcd(ll a,ll b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}
//↑gcd（滑稽）
int main()
{
//↓cin慢的一批
	// cin>>n>>m;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);//建树
	ll x,l,r,d;
	while(m--)
	{
		scanf("%lld",&x);
		// cin>>x;
		if(x==1)
		{
			scanf("%lld%lld%lld",&l,&r,&d);
			// cin>>l>>r>>d;
			update(l,r,1,n,1,d);
		}
		if(x==2)
		{
			scanf("%lld%lld",&l,&r);
			// cin>>l>>r;
			ll up=query(l,r,1,n,1);
			ll down=r-l+1;
			ll temp=gcd(up,down);
			up/=temp;
			down/=temp;
			printf("%lld/%lld\n",up,down);
			// cout<<up<<"/"<<down<<endl;
		}
		if(x==3)//把方差展开后手推公式得
		{
			scanf("%lld%lld",&l,&r);
			// cin>>l>>r;
			ll sum=query(l,r,1,n,1);
			ll fang=query2(l,r,1,n,1);
			ll up=fang*(r-l+1)-sum*sum;
			ll down=(r-l+1)*(r-l+1);
			ll temp=gcd(up,down);
			up/=temp;
			down/=temp;
			printf("%lld/%lld\n",up,down);
			// cout<<up/temp<<"/"<<down/temp<<endl;
		}
	}
}

```


---

## 作者：qwaszx (赞：0)

这种题当然要拿分块水过

戳[这里](https://www.luogu.org/problemnew/show/P1471)获得双倍经验

首先假设分块你们都会了

如果不会的话看[这里](http://hzwer.com/8053.html)

然后平均数就维护一个区间和

方差就是这个东西:

$\frac{1}{n}\sum_{i=1}^n(x_i-\bar{x})$

其中$\bar{x}=\frac{1}{n}\sum_{i=1}^n x_i$，即平均值

那么我们来化一化式子

原式$=\frac{1}{n}(\sum_{i=1}^n(x_i^2-2\bar{x}x_i+\bar{x}^2))$

　　$=\frac{1}{n}(\sum_{i=1}^nx_i^2-2\bar{x}\sum_{i=1}^nx_i+n\bar{x}^2)$
  
　　$=\frac{1}{n}(\sum_{i=1}^nx_i^2-\bar{x}(2\sum_{i=1}^nx_i+n\bar{x}))$

　　令$S=\sum_{i=1}^n$

　　$=\frac{1}{n}(\sum_{i=1}^nx_i^2-\bar{x}S)$
  
也就是说只要维护区间和以及区间平方和就可以算出方差

区间和非常容易维护，那么区间平方和如何维护?

$(x+a)^2=x^2+2ax+a^2=x^2+a(2x+a)$

所以也可以直接维护

然后就是放代码了

```cpp
//分块
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
long long a[1000000],s1[1000000],s2[1000000],tag[1000000],fz,fm,fd;
int blo,l,r,x,opt,n,m,bl[1000000],L[100000],R[100000];
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int wt[30];
void putout(long long x)
{
	if(!x){putchar('0');return;}
	int l=0;
	while(x)wt[++l]=x%10,x/=10;
	while(l)putchar(wt[l--]+48);
}
long long gcd(long long a,long long b)
{
	return b?gcd(b,a%b):a;
}
long long query1(int l,int r)
{
	long long ans=0;
	int minn=min(r,R[l]);
	for(int i=l;i<=minn;i++)ans+=a[i]+tag[bl[l]];
	if(bl[l]!=bl[r])for(int i=L[r];i<=r;i++)ans+=a[i]+tag[bl[r]];
	for(int i=bl[l]+1;i<bl[r];i++)ans+=s1[i]+tag[i]*blo;
	return ans;
}
long long sqr(long long x)
{
	return x*x;
}
long long query2(int l,int r)
{
	long long ans=0;
	int minn=min(r,R[l]);
	for(int i=l;i<=minn;i++)ans+=sqr((a[i]+tag[bl[l]]));
	if(bl[l]!=bl[r])for(int i=L[r];i<=r;i++)ans+=sqr(a[i]+tag[bl[r]]);
	for(int i=bl[l]+1;i<bl[r];i++)ans+=s2[i]+(s1[i]*tag[i]<<1)+blo*tag[i]*tag[i];
	return ans;
}
void update(int l,int r,int w)
{
	int minn=min(r,R[l]);
	long long t=0;
	for(int i=l;i<=minn;i++)
		t+=a[i],a[i]+=w;
	s1[bl[l]]+=(minn-l+1)*w;
	s2[bl[l]]+=w*((t<<1)+w*(minn-l+1));
	if(bl[l]!=bl[r])
	{
		t=0;
		for(int i=L[r];i<=r;i++)
			t+=a[i],a[i]+=w;
		s1[bl[r]]+=(r-L[r]+1)*w;
		s2[bl[r]]+=w*((t<<1)+w*(r-L[r]+1));
	}
	for(int i=bl[l]+1;i<bl[r];i++)tag[i]+=w;
}
int main()
{
	n=getin(),m=getin();
	blo=sqrt(n);
	for(int i=1;i<=n;i++)
	{
		a[i]=getin(),bl[i]=(i-1)/blo+1;
		s1[bl[i]]+=a[i],s2[bl[i]]+=a[i]*a[i];
		L[i]=(bl[i]-1)*blo+1,R[i]=bl[i]*blo;
	}
	for(int i=1;i<=m;i++)
	{
		opt=getin(),l=getin(),r=getin();
		if(opt==1)
		{
			x=getin();
			update(l,r,x);
		}
		else
		{
			fz=query1(l,r),fm=r-l+1;
			if(opt==3)fz=query2(l,r)*fm-fz*fz,fm*=fm;
			if(fz==0)fm=1;
			else fd=gcd(fz,fm),fz/=fd,fm/=fd;
			putout(fz),putchar('/'),putout(fm),puts("");
		}
	}
}
```

```cpp
//线段树
#include<iostream>
#include<cstdio>
#include<cstring>
#define getin() it
#define putout it.out
#define putchar it.outc
using namespace std;
struct XDS
{
	long long tag,s1,s2;
}a[2000000];
int w[2000000],n,m,x,l,r,opt;
long long fz,fm,fd;
void build(int rot,int lt,int rt)
{
	if(lt==rt){a[rot].s1=w[lt],a[rot].s2=w[lt]*w[lt];return;}
	int mid=(lt+rt)>>1;
	build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
	a[rot].s1=a[rot<<1].s1+a[rot<<1|1].s1;
	a[rot].s2=a[rot<<1].s2+a[rot<<1|1].s2;
}
void pushdown(int rot,int lt,int rt)
{
	if(a[rot].tag)
	{
		long long t=a[rot].tag;a[rot].tag=0;
		int mid=(lt+rt)>>1;
		a[rot<<1].tag+=t,a[rot<<1].s2+=t*((mid-lt+1)*t+(a[rot<<1].s1<<1)),a[rot<<1].s1+=(mid-lt+1)*t;
		a[rot<<1|1].tag+=t,a[rot<<1|1].s2+=t*((rt-mid)*t+(a[rot<<1|1].s1<<1)),a[rot<<1|1].s1+=(rt-mid)*t;
	}
}
void update(int rot,int lt,int rt,int lq,int rq,int w)
{
	if(lt>rq||rt<lq)return;
	if(lt>=lq&&rt<=rq)
	{
		a[rot].s2+=w*((rt-lt+1)*w+(a[rot].s1<<1));
		a[rot].s1+=(rt-lt+1)*w;
		a[rot].tag+=w;
		return;
	}
	int mid=(lt+rt)>>1;
	pushdown(rot,lt,rt);
	update(rot<<1,lt,mid,lq,rq,w);
	update(rot<<1|1,mid+1,rt,lq,rq,w);
	a[rot].s1=a[rot<<1].s1+a[rot<<1|1].s1;
	a[rot].s2=a[rot<<1].s2+a[rot<<1|1].s2;
}
long long query1(int rot,int lt,int rt,int lq,int rq)
{
	if(lt>rq||rt<lq)return 0;
	if(lt>=lq&&rt<=rq)return a[rot].s1;
	int mid=(lt+rt)>>1;
	pushdown(rot,lt,rt);
	return query1(rot<<1,lt,mid,lq,rq)+query1(rot<<1|1,mid+1,rt,lq,rq);
}
long long query2(int rot,int lt,int rt,int lq,int rq)
{
	if(lt>rq||rt<lq)return 0;
	if(lt>=lq&&rt<=rq)return a[rot].s2;
	int mid=(lt+rt)>>1;
	pushdown(rot,lt,rt);
	return query2(rot<<1,lt,mid,lq,rq)+query2(rot<<1|1,mid+1,rt,lq,rq);
}
struct buf
{
	char a[1<<25],*s;
	char b[1<<25],*t;
	buf():s(a),t(b){a[fread(a,1,sizeof(a),stdin)]=0;}
	~buf(){fwrite(b,1,t-b,stdout);}
	operator int()
	{
		int x=0;
		while(*s<'0'||*s>'9')s++;
		while(*s>='0'&&*s<='9')x=x*10+*s++-48;
		return x;
	}
	void out(long long x)
	{
		static char ch[30];
		char *i=ch;
		if(!x){*t++='0';return;}
		while(x)*i++=x%10,x/=10;
		while(i!=ch)*t++=*--i+48;
	}
	void outc(char ch){*t++=ch;}
}it;
long long gcd(long long a,long long b)
{
	return b?gcd(b,a%b):a;
}
int main()
{
	n=getin(),m=getin();
	for(int i=1;i<=n;i++)w[i]=getin();
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		opt=getin(),l=getin(),r=getin();
		if(opt==1)
		{
			x=getin();
			update(1,1,n,l,r,x);
		}
		else
			if(opt==2)
			{
				fz=query1(1,1,n,l,r),fm=r-l+1;
				if(fz==0)fm=1;
				else fd=gcd(fz,fm),fz/=fd,fm/=fd;
				putout(fz),putchar('/'),putout(fm),putchar(10);
			}
			else
			{
				fz=query1(1,1,n,l,r),fm=r-l+1;
				fz=query2(1,1,n,l,r)*fm-fz*fz,fm*=fm;
				if(fz==0)fm=1;
				else fd=gcd(fz,fm),fz/=fd,fm/=fd;
				putout(fz),putchar('/'),putout(fm),putchar(10);
			}
	}
}
```

---


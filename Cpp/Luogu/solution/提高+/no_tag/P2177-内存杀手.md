# 内存杀手

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的 KK 最近一段时间突然迷上了电影，但是他从来不去电影院，因为他口袋里没有一分钱，更因为没人陪他去！但是 KK 不是这么容易就会屈服于命远的，他从爸爸那里“偷”来了电脑，没日没夜的进入了疯狂刷电影状态。

显然我们的 KK 在任何情况下都会出现问题的：KK 习惯于用“百度影音”这个神奇的软件。众所周知，这个软件具备一个牛犇的功能，他可以一边看一边下载，然后，KK 每次都不会在线观看，而是连着 wifi（哇\~\~还说没钱！）看，然后的然后KK发现电脑开始变得卡起来了，为了在爸爸突击检查时能够准确准时的将电脑关闭归位，KK 不得不干起了电脑修理师的工作。

KK 翻查了注册表（这都懂？！牛~），发现罪魁祸首竟是存在于一个内存区域中的一个正方形方阵。现在我们的 KK 简单的称呼这种方阵为“内存杀手”，他对于这个“内存杀手”的定义是边长大于 $1$，且在旋转了 $180\degree$ 之后方阵仍与原来保持不变，如：

$$
\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix},
\begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix},
\begin{bmatrix}
1 & 0 & 1 \\ 
1 & 1 & 1 \\
1 & 0 & 1
\end{bmatrix}
$$

当然，一个内存区域中“内存杀手”可能不止一个的，现在我们的 KK 想找出这个方阵中最大的“内存杀手”的边长。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据 $0<N$，$M \le 100$；
- 对于 $60\%$ 的数据 $0<N$，$M \le 200$；
- 对于 $100\%$ 的数据 $0<N$，$M \le 300$。

## 样例 #1

### 输入

```
3 6
101010
111001
101001```

### 输出

```
3```

# 题解

## 作者：平衡树森林 (赞：28)

## 我好像无意间搞出了二维哈希！
------
* 题目让我们求一个最大的**旋转对称**的正方形

* $n,m<=300$意味这我们最多能承受$n^3$的复杂度

怎么办呢？

### 我会暴力！

一个简单的思路：枚举每个正方形，然后判断这个正方形是否旋转对称

然后我们发现，单单是枚举每个正方形就已经有$n^3$的复杂度了，

别急，**还有希望！** 假如我们能在$O(1)$的时间内**判断**旋转对称呢？

立马想到，假如我们有一种哈希，它能在$O(1)$的时间内获取任何一个矩阵的哈希值，那就好办了。咱们可以正着取那个正方形的哈希值，再把矩阵倒着再取一遍，判断是否一样即可。

可是我们没有二维哈希呀>.<，那就先从一维哈希入手，找点灵感：

### 一维哈希

一维哈希是这样的：对于序列
$$a_1,a_2,a_3......a_k$$
我们想要给每一个序列一个**独一无二**的哈希值H，这样我们只需要花费$O(1)$的时间去比较这个值，就能快速比较出两个数列是否相同了

* 一种简单的思想，讲所有数的和直接作为H。但这显然是不行的，反例太好举了

* 思想进阶一下：如果我们作为H的是所有数的平方和呢？仍然有反例，但明显要好得多

* 再深入想一下，二次不行，咱们还可以立方和，四次方，五次方...甚至可以用指数函数，总有一个不容易有反例吧！

但这种做法显然有一个致命的漏洞，就是我们完全不能决定序列的顺序。相反，如果是对于集合哈希，这个方法非常优秀，可咱们是数列啊！/

于是一位奆佬给出了一个解决方案：我们可以找一个比所有a都大的p，然后直接把序列当成一个**p进制的大数**，以此作为H。当然，这个数大到我们存不下来，但没关系，我们还能取模啊！把它对一个大质数取模，就能得到一个近乎不可能重复的哈希值了。同时我们也发现，对于两个相似的序列，只要它们稍稍有一点不同，所得的哈希值就千差万别。**完美解决！**

#### 两种算法一个适用于集合，一个适用于序列，它们究竟差在哪呢？

仔细思考一下，会发现，序列中**顺序**非常重要。那么如果我把序列中的每一个元素变成一个二元组，第一元是数值，第二元是它的位置，会发生什么呢？奇妙的事情出现了：序列变成了二元组的集合！

**原来序列的本质是集合！**

回过来看看那个正确的哈希，根据位值原理，我们可以把它想象成，它首先把序列变成了
$p^1a_1,p^2a_2,p^3a_3...p^ka_k$，再求和（首项应该是从0开始的，但从1开始其实没什么影响）。

与我们的想法的区别在于，我们最初的想法在哈希时完全没有考虑顺序，而这个哈希在计算时先把位置与对应的值用计算“绑定”到了一起，于是哈希的结果就考虑到了顺序。

也就是说，对于序列的哈希关键在于我们要找一个二元函数$h(x,i)$，然后把序列的每个$a_i$变成$h(a_i,i)$，最终的哈希值就是所有$h$的和。这样哈希出来的值便可以兼顾元素的值与顺序

照这个思路，二维哈希就很容易了：

------
## 二维哈希
对于一个r行c列的矩阵
$$a_{1,1},a_{1,2}...a_{1,c} $$
$$a_{2,1},a_{2,2}...a_{2,c} $$
$$...$$
$$a_{r,1},a_{r,2}...a_{r,c} $$

我们可以找两个质数p,q，然后把i行j列元素变成$a_{i,j}*p^i*q^j$，然后矩阵的哈希值就是所有数的和，即

$$H=(\sum_{i,j<=r,c}a_{i,j}*p^i*q^j) \%mod$$

这样很明显，我们可以把哈希写成二维前缀和的形式了，做完了？

别急，还没完。思考一下，如果我们先用二维前缀和来预处理，那么计算一个中间的矩阵的哈希值时，首项的p和q的指数都不是从1开始的，也就是说，如果我们求的矩阵的左上角为$(x,y)$，那么实际上求得的哈希值是原来的$p^{x-1}*q^{y-1}$倍。

怎么办呢？除掉？显然不可行，因为在模意义下除法可不好做。~~我还会滑动窗口~~滑动窗口太麻烦了，有没有简单的解决方法呢？

有的！除法不行，但是我们可以乘啊！我们重新定义哈希函数：

$$H=(\sum_{i,j<=r,c}a_{i,j}*p^{i+n}*q^{j+m}) \%mod$$

但处理二维前缀和时每个数仍然变成$a_{i,j}*p^i*q^j$

这样二维前缀和算出来的值就比实际的哈希值少了$p^{n-x}*q^{m-j}$倍，咱们可以直接乘上去

二维哈希，完成！



------------
回归本题，我们只需要正这做一遍哈希，倒过来再做一遍，就可以在$O(1)$的时间里判断一个正方形是否为旋转对称了

时间复杂度$O(n^3)$

而事实上，这个算法的时间复杂度显然是还能降低的。我们只需要先枚举正方形中心点，再向外二分，就能把时间复杂度降到$O(n^2log_2n)$

~~但是朴素算法能过，咱何必呢~~

上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define FOR  for(LL i=1;i<=n;i++)for(LL j=1;j<=m;j++)
#define FOR2 for(LL i=n;i>=1;i--)for(LL j=m;j>=1;j--)
using namespace std;

inline LL read()
{
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

const LL maxn=300+10;
const LL A=10007,B=10009;
const LL MOD=1e9+9;
LL a[maxn][maxn];
LL X1[maxn],X2[maxn];
LL h1[maxn][maxn],h2[maxn][maxn];
LL n=read(),m=read();

LL hash1(LL a,LL b,LL c,LL d)
{
	LL ans=(h1[c][d]-h1[a-1][d]-h1[c][b-1]+h1[a-1][b-1]+MOD)%MOD;
	return ans*X1[n-a]%MOD*X2[m-b]%MOD;
}

LL hash2(LL a,LL b,LL c,LL d)
{
	LL ans=(h2[a][b]-h2[c+1][b]-h2[a][d+1]+h2[c+1][d+1]+MOD)%MOD;
	return ans*X1[c-1]%MOD*X2[d-1]%MOD;
}

int main()
{
	FOR
	{
		char ch;cin>>ch;
		if (ch=='1') a[i][j]=1;
	}
	X1[0]=X2[0]=1;
	for (LL i=1;i<=300;i++) X1[i]=X1[i-1]*A%MOD,X2[i]=X2[i-1]*B%MOD;
	FOR h1[i][j]=X1[i]*X2[j]*a[i][j]%MOD;
	FOR h2[i][j]=X1[n-i+1]*X2[m-j+1]*a[i][j]%MOD;
	FOR h1[i][j]=h1[i-1][j]+h1[i][j-1]-h1[i-1][j-1]+h1[i][j];
	FOR2 h2[i][j]=h2[i+1][j]+h2[i][j+1]-h2[i+1][j+1]+h2[i][j];
	LL ans=0;
	FOR for (LL k=1;k+i<=n && k+j<=m;k++)
		if (hash1(i,j,i+k,j+k)==hash2(i,j,i+k,j+k)) ans=max(ans,k+1);
	if (ans==0) cout<<-1<<endl; else cout<<ans<<endl;
	return 0;
}
```
ps.这种哈希法还真是我自己想的，如果本来就有相关文章，各位可以在评论区里说一声~ STO STO

**求个赞>.<** 

~~

---

## 作者：yangshurong (赞：4)

借鉴了@wanghaoyu1008的思路。
看到中心对称，想到manacher，用处理回文串的那个思路，对角线扩展。

对于两边每新扩展一个点，判断一下满不满足行和列的中心对称。

判断方法可以用@wanghaoyu1008的暴力。

也可以用hash优化：
对于每一行，正着来一遍hash，反着来一遍hash，
列同理。

复杂度计算：

枚举对角线：O(n+m),对角线上manacher:O(max(n,m)),
hash判断：O(1)
最终复杂度：**O((n+m)*(max(n,m)))**

相当于是O(n^2),理论上可以过掉n<=1000的数据，但实测常数太大，即使开int也要440ms.

unsigned long long 和 long long 都是480ms。

这只比O(n^3)的暴力要快300ms左右。

还有种二维hash的方法，就是枚举正方形右下角的点，正方形的边长，然后hash判断正方形满不满足条件。


这种方法好像跑的贼快，@BLUE_EYE 只用了52ms。

```cpp
#define rel(a) a=readl()
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
#define ull unsigned long long
using namespace std;
const int N=1000007;
const int p=1e9+7;
const int M=607;
const int base=31;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
    return x*w;
}
int n,m,P[N],ans=0;
ll sumx[M][M],sumy[M][M],rsumx[M][M],rsumy[M][M],pw[M];
char ch[M],a[M][M];
in bool check(int x,int y,int t){
	return (((sumy[x-t][y+t]-1ll*sumy[x-t][y-t-1]*pw[2*t+1]%p+p)%p)==((rsumy[x+t][y-t]-1ll*rsumy[x+t][y+t+1]*pw[2*t+1]%p+p)%p))&&(((sumx[x+t][y-t]-1ll*sumx[x-t-1][y-t]*pw[2*t+1]%p+p)%p)==((rsumx[x-t][y+t]-1ll*rsumx[x+t+1][y+t]*pw[2*t+1]%p+p)%p));
} 
in int manacher(int x,int y){
	int cen=1,q=min(n-x+1,m-y+1),res=0;;
	if((ans<<1)>q)return 0;
	me(P);
	P[cen]=1,cen=1;
	r(i,2,q){
		P[i]=cen+P[cen]-1<i?1:min(P[(cen<<1)-i],cen+P[cen]-i);
		if(i+P[i]>=cen+P[cen]){
			while(i-P[i]>0&&i+P[i]<=q&&check(x+i-1,y+i-1,P[i]))P[i]++;
			cen=i;
			res=max(res,P[i]);
		}
	}
	return res-1;
}
int main(){
	re(n),re(m);
	n=n<<1|1,m=m<<1|1;
	for(int i=2;i<=n;i+=2){
		scanf("%s",ch);
		for(int j=2;j<=m;j+=2)a[i][j]=ch[(j>>1)-1];
	}
	pw[0]=1;
	r(i,1,602)pw[i]=pw[i-1]*base%p;
	r(i,1,n){
		r(j,1,m){
			sumy[i][j]=(sumy[i][j-1]*base%p+a[i][j])%p;
			sumx[i][j]=(sumx[i-1][j]*base%p+a[i][j])%p;
		}
	}
	rr(i,n,1){
		rr(j,m,1){
			rsumx[i][j]=(rsumx[i+1][j]*base%p+a[i][j])%p;
			rsumy[i][j]=(rsumy[i][j+1]*base%p+a[i][j])%p;
		}
	}
	for(int j=3;j<m;j+=2)ans=max(ans,manacher(1,j));
	for(int i=1;i<n;i+=2)ans=max(ans,manacher(i,1));
	printf("%d\n",ans==1?-1:ans);
	return 0;
}

```

码风还是很好看的

---

## 作者：BLUE_EYE (赞：4)

考虑这是一个0 1矩阵  我们对每一行进行$hash$，再对每一列进行$hash$，取两个不同的$base$，这样可以一定程度上保证$hash$的正确性，由于蒟蒻我比较菜，没有写散列表，只能$RP++$看有没有重复了，横行$d[i][j]=d[i][j-1]*base1+a[i][j]$,再考虑竖列$sum[i][j]=sum[i-1][j]*base2+d[i][j]$,再将矩阵整个旋转$180$°,如果一个子正方形旋转前和旋转后的$hash$值相同，则大概率下，这两个矩阵相同。我们枚举方阵的边长（注意不能二分，这玩意坑了我很久，我二分一直$WA$，仔细一想发现如果前面不满足，后面满足的情况也是存在的，不满足单调性），枚举矩阵的点，进行$hash$判断，时间复杂度O（N³）,下面贴代码

//看了看AC记录，貌似$RANK1$，比$RANK2$快了差不多10倍？其实这题二进制压缩貌似也可做？不过工程量巨大？不管了，$QAQ$

// 可能代码略丑，借鉴思路即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef unsigned long long ll;
ll base1=131,base2=233;
ll re(){
	char c=getchar();ll all=0,pd=1;
	for(;c>'9'||c<'0';c=getchar()) if(c=='-') pd=-1;
	while(c>='0'&&c<='9') all=all*10+c-'0',c=getchar();return all*pd;
}const ll N=305;
char s[N];ll a[N][N],d[N][N],sum[N][N],aa[N][N],sum2[N][N],n,m,qpow1[N],qpow2[N];
ll cal(ll x,ll y,ll l,ll type){
	if(type==1) return sum[x][y]-sum[x-l][y]*qpow2[l]-sum[x][y-l]*qpow1[l]+sum[x-l][y-l]*qpow1[l]*qpow2[l];
	y=m+l-y,x=n+l-x;
	return sum2[x][y]-sum2[x-l][y]*qpow2[l]-sum2[x][y-l]*qpow1[l]+sum2[x-l][y-l]*qpow1[l]*qpow2[l];
}
ll work(ll l){
	for(ll i=l;i<=n;i++)
		for(ll j=l;j<=m;j++)
	if(cal(i,j,l,1)==cal(i,j,l,2)) return 1;
	return 0;
}ll ans=0;
int main(){
	n=re(),m=re();
	for(ll i=1;i<=n;i++){
		scanf("%s",s+1);
		for(ll j=1;j<=(ll)strlen(s+1);j++)
			a[i][j]=s[j]-'0';
	}
	qpow1[0]=1;for(int i=1;i<=300;i++) qpow1[i]=qpow1[i-1]*base1;
	qpow2[0]=1;for(int i=1;i<=300;i++) qpow2[i]=qpow2[i-1]*base2;
	
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
	d[i][j]=d[i][j-1]*base1+a[i][j];
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
	sum[i][j]=sum[i-1][j]*base2+d[i][j];
	
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
			aa[i][j]=a[n-i+1][m-j+1];
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
	d[i][j]=d[i][j-1]*base1+aa[i][j];
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
	sum2[i][j]=sum2[i-1][j]*base2+d[i][j];
	
	
	for(int i=1;i<=max(n,m);i++)
	if(work(i)) ans=i;
	if(ans!=1&&ans!=0)printf("%llu",ans);
	else printf("-1\n");
}
```

---

## 作者：0x3F (赞：3)

# 一句话题意

求 $n \times m$ 的 $0-1$ 矩阵中最大的中心对称的子方阵的边长。

# 算法一

暴力，$\Theta(n^3)$ 枚举正方形，再 $\Theta(n^2)$ 判断，总复杂度 $\Theta(n^5)$。

过于简单，不讲了。

# 算法二

优化枚举的复杂度或许有一些难度，那为什么不尝试优化判断呢？

判断怎么优化呢？

考虑旋转 $180^{\circ}$ 后的情形，第 $1$ 行与第 $k$ 行互为倒序，第 $2$ 行与第 $k-1$ 行互为倒序，以此类推。

所以我们只需要分别求出第 $i$ 行的哈希值和第 $(k-i+1)$ 行的倒序的哈希值即可。

对原矩阵每一行分别正着反着各哈希一次即可。

具体方法为：

$$hash_{i, j} = (hash_{i, j-1} + arr_{i, j} \times p^{j-1}) \% mod$$

当需要知道第 $i$ 行 $l$ 到 $r$ 的子段的哈希值时：

$$hash_{i, [l, r]} = [(hash_{i, r} - hash_{i, l-1}) \times(p^{\prime})^{l-1}] \% mod$$

其中 $p^{\prime}$ 指 $p$ 在模 $mod$ 意义下的逆元。

反方向同理。

判断复杂度降为 $\Theta(n)$，总复杂度 $\Theta(n^4)$。

显然过不了。

# 算法三

由数据范围显然可得我们需要 $\Theta(n^3)$ 的算法，也就意味着需要 $\Theta(1)$ 的判断方法。

考虑将算法二中的数列哈希变为矩阵哈希。

矩阵怎么哈希呢？

需要将每一行都求一个哈希值，将求出的哈希值们从上到下再求一个哈希。

也就是：

$$(\sum_{i=1}^{n}\sum_{j=1}^{m}p_1^{i-1}p_2^{j-1}arr_{i, j}) \% mod$$

也就是：

$$hash_{i, j} = (hash_{i, j-1} + hash_{i-1, j} - hash_{i-1, j-1} + arr_{i, j} \times p_1^{i-1} \times p_2^{j-1}) \% mod$$

求左上角为 $(x_1, y_1)$ ，右下角 $(x_2, y_2)$ 为的矩阵的哈希值时：

$$hash_{[x_1, x_2], [y_1, y_2]} = [(hash_{x_1, y_1} + hash_{x_2, y_2} - hash_{x_1, y_2} - hash_{x_2, y_1}) \times (p_1^{\prime})^{i-1} \times (p_2^{\prime})^{j-1}] \% mod$$

反方向依然同理。

# 几点注意


1. $1 \times 1$ 的子矩阵不算数！

1. 十年 $\texttt{OI}$ 一场空，不开 $\texttt{long long}$ 见祖宗！

1. 三数相乘可能会爆 $\texttt{long long}$，所以要乘一次膜一次！

# 代码

```cpp
#include <bits/stdc++.h>
#define mod 998244353
#define p1 114514
#define p2 1919810
#define r1 137043501
#define r2 595887626
#define int long long
using namespace std;
int n, m;
bool arr[310][310];
int hash[310][310];
int hsah[310][310];
int pow1[310];
int pow2[310];
int rev1[310];
int rev2[310];
char ch;
int ans;
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> ch;
			arr[i][j] = (ch == '1');
		}
	}
	pow1[0] = pow2[0] = rev1[0] = rev2[0] = 1;
	for (int i = 1; i < n; i++) {
		pow1[i] = pow1[i-1] * p1 % mod;
		rev1[i] = rev1[i-1] * r1 % mod;
	}
	for (int i = 1; i < m; i++) {
		pow2[i] = pow2[i-1] * p2 % mod;
		rev2[i] = rev2[i-1] * r2 % mod;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			hash[i][j] = ((hash[i][j-1] + hash[i-1][j] - hash[i-1][j-1] + pow1[i-1] * pow2[j-1] * arr[i][j]) % mod + mod) % mod;
		}
	}
	for (int i = n; i >= 1; i--) {
		for (int j = m; j >= 1; j--) {
			hsah[i][j] = ((hsah[i][j+1] + hsah[i+1][j] - hsah[i+1][j+1] + pow1[n-i] * pow2[m-j] * arr[i][j]) % mod + mod) % mod;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 2; k <= min(n-i+1, m-j+1); k++) {
				if ((((hash[i+k-1][j+k-1] - hash[i+k-1][j-1] - hash[i-1][j+k-1] + hash[i-1][j-1]) % mod * rev1[i-1] % mod * rev2[j-1]) - ((hsah[i][j] - hsah[i][j+k] - hsah[i+k][j] + hsah[i+k][j+k]) % mod * rev1[n-i-k+1] % mod * rev2[m-j-k+1])) % mod == 0) ans = max(ans, k);
			}
		}
	}
	if (ans == 0) cout << -1 << endl;
	else cout << ans << endl;
	return 0;
}
```

# 后面的话

$$\color{white}\Huge\texttt{求过，求赞}$$

---

## 作者：the___ (赞：2)

# 读题
看到二维中翻转 $180^\circ$ 即可想到一维中求回文串，故可用马拉车的思路求解（若没写过请转向[P3805【模板】manacher 算法](https://www.luogu.com.cn/problem/P3805)）。
其中枚举每行 $O(N)$，求解每行 $O(M)$，判断线性，总复杂度刚好不超。
# 思路
1. 输入，按马拉车算法，注意行与行间也要插入一行特殊字符。
1. 暴力枚举每行，对每行分别使用马拉车，即除判断外只需考虑横坐标，纵坐标均相同。
	
   判断扩展时注意完整判断一周的全部对应点。下说明如何判断：
   
   设当前扩展距离为 $p$，中心点横纵坐标分别为 $x$、$y$。
   1. 对于正方形左侧边上的点，易知其横坐标为 $x-p$，其对应点在正方形右侧边上，且其对应点横坐标为 $x+p$。因为这两点距中心点距离相等，且其横坐标与 $x$ 差的绝对值相等，所以由勾股定理可得，这两点的纵坐标与 $y$ 差的绝对值相等。故可枚举左侧点纵坐标与 $y$ 的差，以此确定两点坐标并判断。
   2. 同理，对于正方形上侧边上的点，易知其纵坐标为 $y-p$，其对应点在正方形下侧边上，且其对应点横坐标为 $y+p$。因为这两点距中心点距离相等，且其纵坐标与 $y$ 差的绝对值相等，所以由勾股定理可得，这两点的横坐标与 $x$ 差的绝对值相等。故可枚举上侧点横坐标与 $x$ 的差，以此确定两点坐标并判断。
   
   由上述说明可发现，两步骤过程相似，且枚举范围相同，即在下面代码中，为减少代码量，缩小常数，将两步同时执行。
1. 输出，注意题目描述最后：边长大于 $1$ 才要输出，否则输出 ```-1```。
# 代码
奉上代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char s[610][610];
int p[610][610],d,mid,r,n,m,br;
int main(){
    cin>>n>>m;                                              \\输入
    for(int i=0;i<=2*n+1;i++){
        s[i][0]='~';
        s[i][2*m+1]='#';
    }
    for(int i=0;i<=2*m;i++){
        s[0][i]='~';
        s[2*n+1][i]='#';
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=2*m;j++)
            s[2*i-1][j]='#';
        for(int j=1;j<=m;j++){
            s[2*i][j*2-1]='#';
            cin>>s[2*i][j*2];
        }
    }
    for(int i=1;i<=2*n+1;i++){                          \\枚举每行
        mid=0;
        r=0;
        for(int j=1;j<=2*m+1;j++){
            if(j<=r)
                p[i][j]=min(p[i][mid+mid-j],r-j+1);
            else
                p[i][j]=1;
            br=0;
            while(1){                                   \\判断拓展
                for(int k=-p[i][j];k<=p[i][j];k++){
                    if(s[i+p[i][j]][j+k]!=s[i-p[i][j]][j-k]){
                        br=1;
                        break;
                    }
                    if(s[i+k][j+p[i][j]]!=s[i-k][j-p[i][j]]){
                        br=1;
                        break;
                    }
                }
                if(br==1)
                    break;
                p[i][j]++;
            }
            if(r<p[i][j]+j){
                mid=j;
                r=p[i][j]+j-1;
            }
            if(d<p[i][j])
                d=p[i][j];
        }
    }
    if(d-1<=1)                                              \\输出
        cout<<-1;
    else
        cout<<d-1;
    return 0;
}
```
若有疏漏、不详之处，恳请大佬指点。

---

## 作者：chenzida (赞：2)

## 题意简述：
在一个 $n\times m$ 的矩阵中找到一个子正方矩阵，使得这个正方矩阵上下对称，问这个子正方矩阵的最大边长是多少？
## 思路解析：
### 暴力1：$O(n^5)$ 0分
相信暴力大家都能想到，那就是先枚举正方形的左上顶点，之后枚举正方形的边长，然后再枚举判断这个正方形合不合法，这个方法是 $O(n\times m\times \ \min(n,m)^3)$，连20分都拿不了，就什么也别说了。
### 暴力2：$O(n^4)$ 20分
我们尝试对这个进行优化，显然枚举正方形的左上顶点和边长是很难再被优化的，所以我们尝试优化判断这一步，显然，如果想要判断一个正方形是否为上下对称图形只用看最上一行与最下一行，最上两行与最下两行...一直到最后是否能够匹配上，所以我们考虑使用 $hash$，用算出每一行的哈希值，之后尝试匹配，可以把匹配复杂度降低到 $O(\min(n,m))$，总复杂度为$O(n\times m\times \min(n,m)^2)$ 这样能够得到20分。
### 正解：$O(n^3)$
之前我们已经将判断的复杂度优化到了 $O(\min(n,m))$ 现在我们要考虑进一步优化，而上一次的 $hash$ 给了我们灵感，我们可以用二维 $hash$，即 $h[i][j]$ 表示左上角为 $(1,1)$，右下角为 $(i,j)$ 的矩形的 $hash$ 值，这样我们就能对比两个矩阵的 $hash$ 值了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int NR=1005;
int n,m;
int ans;
int base1=131,base2=233;
int a[NR][NR];
int b[NR][NR];
ull tmp[NR][NR];
ull power1[NR];
ull power2[NR];
ull h1[NR][NR],h2[NR][NR];
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
ull cal(int x,int y,int l,int flag)
{
	if(flag==1)
	{
		return h1[x][y]-h1[x-l][y]*power2[l]-
			   h1[x][y-l]*power1[l]+
			   h1[x-l][y-l]*power1[l]*power2[l];
	}
    y=m+l-y,x=n+l-x;
	return h2[x][y]-h2[x-l][y]*power2[l]-
		   h2[x][y-l]*power1[l]+
		   h2[x-l][y-l]*power1[l]*power2[l];
}
bool check(int x)
{
	for(int i=x;i<=n;i++)
		for(int j=x;j<=m;j++)
			if(cal(i,j,x,1)==cal(i,j,x,2))
				return 1;
	return 0;
} 
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char ch;
			scanf(" %c",&ch);
			a[i][j]=ch-'0';
		}
	}
	
	power1[0]=1;
	for(int i=1;i<=1000;i++) power1[i]=power1[i-1]*base1;
	power2[0]=1;
	for(int i=1;i<=1000;i++) power2[i]=power2[i-1]*base2;
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			tmp[i][j]=tmp[i][j-1]*base1+a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			h1[i][j]=h1[i-1][j]*base2+tmp[i][j];
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			b[i][j]=a[n-i+1][m-j+1];
			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			tmp[i][j]=tmp[i][j-1]*base1+b[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			h2[i][j]=h2[i-1][j]*base2+tmp[i][j];
	
	for(int i=1;i<=max(n,m);i++) 
		if(check(i)) ans=i;
	
	if(ans!=1&&ans!=0) cout<<ans;
	else puts("-1");
	return 0;
}

```


---

## 作者：zcq_qwq (赞：2)

## 题目分析

其实就是找正着看和反着看一样的子矩形，所以我们可以正着一遍 hash 反着一遍 hash，然后三重循环枚举子矩形，将正着的矩形和反着的矩形的 hash 值进行比较，相同则是 killer。

### 具体写法

如果暴力枚举每个子矩形，时间复杂度是 $O(n^4)$，无法接受。

此时回到题目，题目要求输出最大的 killer 的边长，因为最大的 killer 的边长不大于 $\min(n,m)$，于是我们想到了可以从 $\min(n,m)$ 往下依次枚举边长。现在，只要在内层枚举以 $i+k-1$ 和 $j+k-1$ 为右下角的正方形，求出这个正方形正着和反着的 hash 值，如果相等输出 $k$，否则循环结束后输出 `-1` 即可。

**PS：$k$ 的下界为 $2$，因为题目中明确说明 killer 包含的字符数量严格大于 $1$（即边长不为 $1$）。**

接下来我们分析 hash 函数的写法。因为是二维 hash，所以我们需要两个 base。

类似于一维 hash，定义：

$$hash_{i,j}=a_{i,j} \cdot base_1^i \cdot base_2^j$$

前缀和：

$$S_{x,y}=S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y} \cdot base_1^x \cdot base_2^y$$

对于差分，我们需要将 $base_1,base_2$ 对齐到左上角：

$$H_{x_1,y_1,x_2,y_2}=(S_{x_2,y_2}-S_{x_1-1,y_2}-S_{x_2,y_1-1}+S_{x_1-1,y_1-1}) \cdot (base_1^{x_1-1})^{-1} \cdot (base_2^{y_1-1})^{-1}$$

此时，有蒟蒻同学提出：我不会写逆元……

考虑优化：

正难则反，考虑以各维度到矩形右下角 $(x_2,y_2)$ 的距离作为 $base_1,base_2$ 的指数，从而避免逆元运算。

前缀和：

$$S_{x,y}=S_{x-1,y} \cdot base_1+S_{x,y-1} \cdot  base_2-S_{x-1,y-1} \cdot base_1 \cdot base_2+a_{x,y} \cdot base_1 \cdot base_2$$

差分顺理成章：

$$H_{x_1,y_1,x_2,y_2}=S_{x_2,y_2}-S_{x_1-1,y_2} \cdot base_1^{x_2-x_1+1}-S_{x_2,y_1-1} \cdot base_2^{y_2-y_1+1}+S_{x_1-1,y_1-1} \cdot base_1^{x_2-x_1+1} \cdot base_2^{y_2-y_1+1}$$

取模的话，我用的是自然溢出，不知道大模数能不能过。

## 完整代码：
```cpp
#include <bits/stdc++.h> // 本代码的 base 和讲解略有不同，见谅

typedef unsigned long long ull;

using namespace std;

const int N = 300 + 5;

const ull base1 = 23, base2 = 29;

int n, m;

ull f1[N][N], f2[N][N], ba1[N], ba2[N], a[N][N];

ull hash_funtion1(int x, int y, int z) {
	return f1[x][y] - f1[x - z][y] * ba1[z] - f1[x][y - z] * ba2[z] + f1[x - z][y - z] * ba1[z] * ba2[z];
}

ull hash_funtion2(int x, int y, int z) {
	return f2[x][y] - f2[x + z][y] * ba1[z] - f2[x][y + z] * ba2[z] + f2[x + z][y + z] * ba1[z] * ba2[z];
}

int main(void) {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%1llu", &a[i][j]);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			f1[i][j] = f1[i - 1][j] * base1 + a[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			f1[i][j] += f1[i][j - 1] * base2;
		}
	}
	for (int i = n; i >= 1; i--) {
		for (int j = m; j >= 1; j--) {
			f2[i][j] = f2[i + 1][j] * base1 + a[i][j];
		}
	} 
	for (int i = n; i >= 1; i--) {
		for (int j = m; j >= 1; j--) {
			f2[i][j] += f2[i][j + 1] * base2;
		}
	}
	ba1[0] = ba2[0] = 1;
	for (int i = 1; i <= n; i++) {
		ba1[i] = ba1[i - 1] * base1;
	}
	for (int i = 1; i <= m; i++) {
		ba2[i] = ba2[i - 1] * base2;
	}
	int ans = 0;
	for (int k = min(n, m); k >= 2; k--) {
		for (int i = 1; i <= n - k + 1; i++) {
			for (int j = 1; j <= m - k + 1; j++) {
				ull tmp1 = hash_funtion1(i + k - 1, j + k - 1, k);
				ull tmp2 = hash_funtion2(i, j, k);
				if (tmp1 == tmp2) {
					cout << k;
					return 0;
				}
			}
		}
	}
	cout << -1;
	return 0;
}
```
完结撒花~~ 

至于代码讲解有误等问题，欢迎提出~~

写题解不易，望点赞。

---

## 作者：yihang2011 (赞：1)

# P2177 内存杀手

[题目传送门](https://www.luogu.com.cn/problem/P2177)

-----

这道题二维哈希，由于数据不大，所以 $O(n^{3})$ 是可以过的，二维哈希在[平衡树森林的文章](https://www.luogu.com.cn/article/eru7vl1s)中已经讲的很详细了，我再来说一下自然溢出哈希吧。

自然溢出哈希相当于一个模数 $M$ 是 $2^{64}$ 的大模数哈希，在 C++ 中使用 `unsigned long long` 来模仿取模 $2^{64}$ ，由于 C++ 中 `unsigned` 系列特性，自然溢出哈希个人认为比大模数哈希好写（不用取模）。

然后就是翻转的问题了，解决思想就是不翻转算一遍哈希，翻转算一遍，翻转和不翻转有两个区别：

 - 在算哈希时，不翻转是
 
   `h[i - 1][j] * P + h[i][j - 1] * Q + a[i][j] - h[i - 1][j - 1] * P * Q`，

   而翻转是

   `ht[i - 1][j] * P + ht[i][j - 1] * Q + a[n - i + 1][m - j + 1] - ht[i - 1][j - 1] * P * Q`，

   区别就是原数组的下表从 $i$ 到 $n - i + 1$ 和从 $j$ 到 $m - j + 1$ ，很好理解；

 - 在查哈希时，不翻转是 `Hash(hs, x1, y1, x2, y2)`，

   翻转是 `Hash(ht, n - x2 + 1, m - y2 + 1, n - x1 + 1, m - y1 + 1)` ，同理。

-------

这些区别讲完了基本上就很简单了，算完哈希之后枚举正方形左上角，然后再枚举长度，判断是否越界，再对比哈希值，然后更新答案就可以了，代码如下：

```cpp
#include <iostream>
using namespace std;
using ull = unsigned long long;

const int N = 310;
int n, m, ans;
int P = 131, Q = 137;
ull hs[N][N], ht[N][N];
ull p[N], q[N];
char a[N][N];

ull Hash(ull h[][N], int x1, int y1, int x2, int y2) {
	return h[x2][y2] - h[x1 - 1][y2] * p[x2 - x1 + 1] - h[x2][y1 - 1] * q[y2 - y1 + 1] + h[x1 - 1][y1 - 1] * p[x2 - x1 + 1] * q[y2 - y1 + 1]; 
}

bool chk(int x1, int y1, int x2, int y2) {
    return Hash(hs, x1, y1, x2, y2) == Hash(ht, n - x2 + 1, m - y2 + 1, n - x1 + 1, m - y1 + 1);
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
		}
	}
    p[0] = q[0] = 1;
    for (int i = 1; i <= max(n, m); i++) {
        p[i] = p[i - 1] * P;
        q[i] = q[i - 1] * Q;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
			hs[i][j] = hs[i - 1][j] * P + hs[i][j - 1] * Q + a[i][j] - hs[i - 1][j - 1] * P * Q;
            ht[i][j] = ht[i - 1][j] * P + ht[i][j - 1] * Q + a[n - i + 1][m - j + 1] - ht[i - 1][j - 1] * P * Q;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            for (int len = 2; i + len - 1 <= n && j + len - 1 <= m; len++) {
            	if (chk(i, j, i + len - 1, j + len - 1)) {
            		ans = max(ans, len);
            	}
            }
        }
    }
    if (ans < 2) {
    	ans = -1;
    }
    cout << ans << endl;
	return 0;
}
```

---

## 作者：ctj12461 (赞：1)

 本题前置算法知识：
 - 二分答案
 - 哈希

不同于其他题解，这里给出一种时间复杂度为 $O(nm \log_2 \min (n,m))$ 的做法，目前为最优解。  
![](https://cdn.luogu.com.cn/upload/image_hosting/k34jd0be.png)


### 算法分析
二维哈希其他题解都已经讲过了，这里就不再赘述，我们讲重点。如果有做过 [反对称](https://loj.ac/p/2452) 这道题，应该就知道这题也是类似的做法。

回到本题，题目要求我们找到一个边长最大的 $01$ 方阵，且满足旋转 $\pi$ 后与原来一样，即这个方阵中心对称。
考虑一个已经符合题意的方阵，它的边长为 $a$，则以它为中心，边长小于 $a$ 的方阵也一定是中心对称的。
这就说明，同一个中心的方阵系中，其合法性是具有单调性的，对于一个点 $P$，一定可以找到一个 $b$，满足所有边长小于等于 $a$ 且已 $P$ 为中心的方阵都是中心对称的，而所有边长大于 $a$ 且已 $P$ 为中心的方阵都不是中心对称的。

有了这个性质，我们就可以进行二分答案。即确定一个边长，然后根据边长找出所有方阵，进行判断并缩小答案所在区间。
需要注意的是，我们不能对边长进行二分。为什么？由于边长的奇偶性会影响中心的位置，
中心可能在矩阵的格子上，也可能在格子之间，而上述性质都是建立在中心相同的条件之上。
我们对点的位置进行讨论。对于每一种情况进行一次二分答案，最后取两者的最大值即可。

时间复杂度 $O(nm \log_2 \min (n,m))$。

### 参考程序
```cpp
#include <bits/stdc++.h>
using namespace std;

/** constexpr 是 C++ 11 的新增关键字，用来定义一个编译期常量，推荐用这个替代 #define */
constexpr int maxn = 300 + 10;
constexpr int mod = 998244353;
constexpr int base1 = 258 + 1e9 + 7;
constexpr int base2 = 97 + 1e9 + 9;

/**
 * using 语句，也是 C++ 11 新增语法，等价于 typedef，但要更加强大。
 * 如 template <typename T> using MapType = map<int, T>;
 */
using ll = long long;

int n, m;
ll mat[2][maxn][maxn], h[2][maxn][maxn], power1[maxn], power2[maxn];
char tmp[maxn];

int calc(int which, int x1, int y1, int x2, int y2) {
    ll res = h[which][x2][y2] -
             h[which][x1 - 1][y2] * power1[x2 - x1 + 1] % mod -
             h[which][x2][y1 - 1] * power2[y2 - y1 + 1] % mod +
             h[which][x1 - 1][y1 - 1] * power1[x2 - x1 + 1] % mod * power2[y2 - y1 + 1] % mod;
    return (res + mod) % mod;
}

bool check(int x, int y, int a) {
    int r = (a + 1) / 2;
    if (a % 2) {
        int x1 = x - r + 1, y1 = y - r + 1;
        int x2 = x + r - 1, y2 = y + r - 1;
        int rx1 = n - x1 + 1, ry1 = m - y1 + 1;
        int rx2 = n - x2 + 1, ry2 = m - y2 + 1;
        return calc(0, x1, y1, x2, y2) == calc(1, rx2, ry2, rx1, ry1);
    } else {
        int x1 = x - r + 1, y1 = y - r + 1;
        int x2 = x + r, y2 = y + r;
        int rx1 = n - x1 + 1, ry1 = m - y1 + 1;
        int rx2 = n - x2 + 1, ry2 = m - y2 + 1;
        return calc(0, x1, y1, x2, y2) == calc(1, rx2, ry2, rx1, ry1);        
    }
}

bool check(int a) {
	/** 这里传入边长，根据边长判断 */
    int r = (a + 1) / 2;
    if (a % 2) {
        for (int i = r; i + r - 1 <= n; ++i)
            for (int j = r; j + r - 1 <= m; ++j)
                if (check(i, j, a))
                    return true;
        return false;
    } else {
        for (int i = r; i + r <= n; ++i)
            for (int j = r; j + r <= m; ++j)
                if (check(i, j, a))
                    return true;
        return false;
    }
}

void preprocess() {
	/** 求二维哈希 */
    power1[0] = power2[0] = 1;
    for (int i = 1; i <= max(n, m); ++i) {
        power1[i] = power1[i - 1] * base1 % mod;
        power2[i] = power2[i - 1] * base2 % mod;
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            h[0][i][j] = (h[0][i][j - 1] * base2 + mat[0][i][j]) % mod;
            h[1][i][j] = (h[1][i][j - 1] * base2 + mat[1][i][j]) % mod;            
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            h[0][i][j] = (h[0][i - 1][j] * base1 + h[0][i][j]) % mod;
            h[1][i][j] = (h[1][i - 1][j] * base1 + h[1][i][j]) % mod;
        }
    }
}

void divide() {
	/** 对不同的位置情况分别二分 */
    int l = 1, r = min(n, m) / 2 + 1, ans1 = -1, ans2 = -1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(mid * 2)) {
            ans1 = mid * 2;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    l = 1, r = min(n, m) / 2 + 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(mid * 2 + 1)) {
            ans2 = mid * 2 + 1;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    cout << max(ans1, ans2) << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> (tmp + 1);
        for (int j = 1; j <= m; ++j) {
            mat[0][i][j] = tmp[j] - '0';
            /** 储存中心对称的矩阵 */
            mat[1][n - i + 1][m - j + 1] = tmp[j] - '0';
        }
    }
    preprocess();
    divide();
    return 0;
}
```
### 提示
如果你觉得写的没问题却 WA 了，检查一下是不是哈希冲突了，有条件就写双哈希，这道题写单哈希很容易被卡。

---

## 作者：12345678hzx (赞：1)

题意十分简洁明了，就是让我们求出最大的一个旋转对称的正方形。

考虑到一个正方形如果左上顶点和边长确定，就能确定整个正方形，枚举这部分的时间复杂度是 $O(n^3)$。

但是这道题的数据范围最多承受 $O(n^3)$ 的时间复杂度，这意味着我们要 $O(1)$ 地判定一个正方形是否旋转对称。

我们考虑先把这个问题拍到一维上，例如判断一个字符串是否回文的问题，而这个问题很容易想到哈希做法，我们只要在时间范围内预处理出哈希的前缀和，就能 $O(1)$ 地判定，所以考虑用哈希解决本题。

相信大家都会二维前缀和，于是我们可以效仿一维哈希，预处理出哈希前缀和，取两个大质数分别作为行和列的 $P$，从左上角到右下角做一遍哈希，然后再从右下角到左上角做一遍哈希，就能 $O(1)$ 地判定，然后就能过了这题，时间复杂度为 $O(n^3)$。

---

## 作者：a_sad_soul (赞：0)

哈希 , 爽 !

这里容易想到如果对于上下两个三角矩阵如果相同（这里等价的一个命题是上下两个矩阵中翻转一个矩阵 ，若相等  那么他们是对称的），那么就是可行的答案 ，于是我们从小到大枚举答案 ，然后去求解。

这里介绍一个叫做 BKDRHash 的一个东西 。 这个哈希是一种进制哈希 ，主要步骤如下：

1. 设定一个进制 $ P $
2. 然后对于哈希前缀和 ，有递推式 $sum[i]=sum[i-1]\times P+s[i]$
3. 查询一个哈希的公式为 $sum[r]-sum[l-1]\times P[R-L+1]$ 。 其中 $P[R-L+1]$ 是 $P$ 的乘方的预处理。


于是我们就可以枚举每个矩阵 ，然后每次花 $\large\frac{k}{2}$ 的时间去判断一个点为起点 ，大小为 $k$ 的矩阵是否合法。

对于取余这个比较慢的可以实用无符号整型 `unsigned long long` 去使其自然溢出打到更快的一个速度。

具体时间就直接上代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long pre[505][505],bac[505][505];
unsigned long long mult[1001];
int n,m;
unsigned long long Get_Front(int x,int l,int r){
	return pre[x][r]-pre[x][l-1]*mult[r-l+1];
}
unsigned long long Get_Back(int x,int l,int r){
	return bac[x][l]-bac[x][r+1]*mult[r-l+1];	
}
const unsigned long long Y=131;
char ch[505][505];

bool Judge(int sx,int sy,int tx,int ty){
	while(sx<=tx){
		if(Get_Back(tx,sy,ty)!=Get_Front(sx,sy,ty))return false;
		++sx;
		--tx;
	}
	return true;
}

bool Get_ans(int k){
	for(int i=1;i+k-1<=n;++i)
		for(int j=1;j+k-1<=m;++j)
			if(Judge(i,j,i+k-1,j+k-1)==true)return true;
	return false;
}
int main(){
	mult[0]=1;
	mult[1]=Y;
	for(int i=1;i<=1000;++i)
		mult[i]=mult[i-1]*Y;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",ch[i]+1);
		for(int j=1;j<=m;++j)
			pre[i][j]=pre[i][j-1]*Y+ch[i][j];
		for(int j=m;j>=1;--j)
			bac[i][j]=bac[i][j+1]*Y+ch[i][j];
	}
	int k=min(n,m);
	for(;k>1;--k)
		if(Get_ans(k))break;
	if(k!=1)cout<<k<<endl;
	else cout<<-1<<endl;
	return 0;
}

```

[提交](https://www.luogu.com.cn/record/156867198)证明这个思路能达到不错的一个效果。

---

## 作者：Union_Find (赞：0)

首先，这道题很明显就是求二维回文串，但是本蒟蒻不会二维 `manacher`，于是有了这篇题解。

在一维中，做回文串除了 `manacher`，还有一个东西，叫做 `hash`，它可以升级为二维 hash，于是就可以做了。

先预处理出来正的前缀 hash，再预处理反的后缀 hash，接下来三重循环，$i,j$ 表示左上角坐标，$k$ 表示边长，就可以 $O(1)$ 的判断了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define max(a, b) a > b ? a : b
const ll P = 1e9 + 9, base = 1e4 + 7, bbas = 1e4 + 9;
ll n, m, a[305][305], ba1[305], ba2[305], h1[305][305], h2[305][305], ans = -1;
char ch;
il ll hash1(ll a, ll b, ll c, ll d){
	ll ans = (h1[c][d] - h1[a - 1][d] - h1[c][b - 1] + h1[a - 1][b - 1] + P) % P;
	return ans * ba1[n - a] % P * ba2[m - b] % P;
}
il ll hash2(ll a, ll b, ll c, ll d){
	ll ans = (h2[a][b] - h2[c + 1][b] - h2[a][d + 1] + h2[c + 1][d + 1] + P) % P;
	return ans * ba1[c - 1] % P * ba2[d - 1] % P;
}
int main(){
	scanf ("%lld %lld", &n, &m);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			cin >> ch;
			a[i][j] = ch - '0';
		}
	}
	ba1[0] = ba2[0] = 1;
	for (int i = 1; i <= 300; i++)
		ba1[i] = ba1[i - 1] * base % P, ba2[i] = ba2[i - 1] * bbas % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			h1[i][j] = ba1[i] * ba2[j] * a[i][j] % P, h2[i][j] = ba1[n - i + 1] * ba2[m - j + 1] * a[i][j] % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			h1[i][j] = h1[i][j] + h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1];
	for (int i = n; i >= 1; i--)
		for (int j = m; j >= 1; j--)
			h2[i][j] = h2[i][j] + h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 1; k + i <= n && k + j <= m; k++)
				if (hash1(i, j, i + k, j + k) == hash2(i, j, i + k, j + k))
					ans = max(ans, k + 1);
	printf ("%lld", ans);
	return 0;
}

```

---

## 作者：koobee (赞：0)

本体的思路可参考 [P2601 理想的正方形](https://www.luogu.com.cn/problem/P2601)，是一道二维哈希+二分的题。（不用二分可能也行， $O(n^3)$）

想法：将原图旋转 $180°$ 就是上下对称再左右对称，因此可将原矩阵求完哈希值后上下对称再左右对称，得到的新矩阵求二维哈希值（前缀和）。枚举中心或对称点 $(x, y)$。讨论边长奇偶性，可以直接枚举边长，如果想效率高一些就用二分，取出最大边长取最大值。

如何判断 $(x_1, y_1, x_2, y_2)$ 是内存杀手：

$(x_1, y_1, x_2, y_2)$ 上下对称再左右对称之后的区间应为 $(n-x_2+1, n-y_2+1, n-x_1+1, n-y_1+1)$，直接判断两个区间的哈希值是否一样就行了。

相信二维哈希各位都已经学过了，这里就不做详细解释了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 1005, P = 1e9+7, Q = 1e9+9;
ull p[N], q[N], h1[N][N], h2[N][N];
int n, m, ans=1;
char a[N][N];
ull Hash(int X1, int Y1, int X2, int Y2, int op){
	if(op == 1) return h1[X2][Y2] - h1[X2][Y1 - 1] * p[Y2 - Y1 + 1] - h1[X1 - 1][Y2] * q[X2 - X1 + 1] + h1[X1 - 1][Y1 - 1] * p[Y2 - Y1 + 1] * q[X2 - X1 + 1];
	return h2[X2][Y2] - h2[X2][Y1 - 1] * p[Y2 - Y1 + 1] - h2[X1 - 1][Y2] * q[X2 - X1 + 1] + h2[X1 - 1][Y1 - 1] * p[Y2 - Y1 + 1] * q[X2 - X1 + 1];
}
bool check(int X1, int Y1, int X2, int Y2){
	int n1 = n - X1 + 1, m1 = m - Y1 + 1, n2 = n - X2 + 1, m2 = m - Y2 + 1;
	ull H1 = Hash(X1, Y1, X2, Y2, 1), H2 = Hash(n2, m2, n1, m1, 2);
	if(H1 != H2) return 0;
	return 1;
}
int main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n>>m;
	q[0] = p[0] = 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			cin>>a[i][j];
			h1[i][j] = h1[i][j-1] * P + h1[i-1][j] * Q - h1[i-1][j-1] * P * Q + a[i][j] - '0' + 1;
		}
	for(int i = 1; i <= n; i++) q[i] = q[i-1] * Q;
	for(int j = 1; j <= m; j++) p[j] = p[j-1] * P;
	for(int i = 1; i <= n; i++)
		 for(int j = 1; j * 2 <= m; j++) swap(a[i][j], a[i][m-j+1]);
	for(int j = 1; j <= m; j++)
		for(int i = 1; i * 2 <= n; i++) swap(a[i][j], a[n-i+1][j]);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) h2[i][j] = h2[i-1][j] * Q + h2[i][j-1] * P - h2[i-1][j-1] * Q * P + a[i][j] - '0' + 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			int l = 0, r = min(min(i, n-i), min(j, m-j));
			while(l < r){
				int mid = (l + r + 1) / 2;
				if(check(i - mid + 1, j - mid + 1, i+mid, j+mid)) l = mid;
				else r = mid - 1;
			}
			ans = max(ans, l*2), l = 0, r = min(min(i-1, n-i), min(j-1, m-j));
			while(l < r){
				int mid = (l + r + 1) / 2;
				if(check(i-mid, j-mid, i+mid, j+mid)) l = mid;
				else r = mid - 1;
			}
			ans = max(ans, l*2+1);
		}
	cout<<(ans == 1 ? -1 : ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

# 前言

本蒟蒻首 A [紫题](https://www.luogu.com.cn/problem/P2177)，写篇题解当作记录。

# [题目传送门](https://www.luogu.com.cn/problem/P2177)

# First 题意

题意不难理解，就是在一个矩阵中，找出一个正方形，使它满足反转 $180\degree$ 之后还是本身，求正方形的最大变长 $ans$ （$ans > 1$），若没有，输出 `-1`。

# Second 暴力

暴力不难想，就是 $O(n^3)$ 暴力枚举一波中心点和边长，再来 $O(n^2)$ 判断是否反转后还是本身。

总时间复杂度 $O(n^5)$，恭喜 T 飞了。

# Third 小优化

好的，前一种算法还能优化。

我们可以发现，这其实就是一个二维回文串的求解，可以用 `manacher` 来求解。

但是我太蒻了，不会二维 `manacher`，但没事，我们可以参考一下回文串求解的方法。

去 `manacher` 模板题题解里就会发现，有一种算法可以 $O(n^2)$ 的求解，就是枚举反转的中心，然后向外扩展。

这个算法放到这题里，就可以 $O(n^4)$ 的求解了。

恭喜，还是 T 了。

# Fourth 优化

我们再看 Second 的思路，每次判断都需要反转过来一一匹配，这不就是 `hash` 干的事吗？把 `hash` 放到这题里来，就是一个前缀和 `hash` 了。

求解方法就是预处理矩阵前缀和后缀的 `hash` 值，每次就可以 $O(1)$ 判断，加上 $O(n^3)$ 的枚举，总共时间复杂度 $O(n^3)$。

恭喜，终于 A 了。

# Fifth 提示

不开 `long long` 见祖宗。

# Sixth Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define max(a, b) a > b ? a : b
const ll P = 1000000009, C1 = 10007, C2 = 10009; 
ll n, m, mp[305][305], ran_d1[305], ran_d2[305], ha1[305][305], ha2[305][305];
char ch;
il ll hash1(ll a, ll b, ll c, ll d){
	ll ans = (ha1[c][d] - ha1[a - 1][d] - ha1[c][b - 1] + ha1[a - 1][b - 1] + P) % P;
	return ans * ran_d1[n - a] % P * ran_d2[m - b] % P;
}
il ll hash2(ll a, ll b, ll c, ll d){
	ll ans = (ha2[a][b] - ha2[c + 1][b] - ha2[a][d + 1] + ha2[c + 1][d + 1] + P) % P;
	return ans * ran_d1[c - 1] % P * ran_d2[d - 1] % P;
}
int main(){
	scanf ("%lld %lld", &n, &m);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			cin >> ch;
			mp[i][j] = ch - '0';
		}
	}
	ran_d1[0] = ran_d2[0] = 1;
	for (int i = 1; i <= 300; i++)
		ran_d1[i] = ran_d1[i - 1] * C1 % P, ran_d2[i] = ran_d2[i - 1] * C2 % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			ha1[i][j] = ran_d1[i] * ran_d2[j] * mp[i][j] % P, ha2[i][j] = ran_d1[n - i + 1] * ran_d2[m - j + 1] * mp[i][j] % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			ha1[i][j] = ha1[i][j] + ha1[i - 1][j] + ha1[i][j - 1] - ha1[i - 1][j - 1];
	for (int i = n; i >= 1; i--)
		for (int j = m; j >= 1; j--)
			ha2[i][j] = ha2[i][j] + ha2[i + 1][j] + ha2[i][j + 1] - ha2[i + 1][j + 1];
	ll ans = -1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 1; i + k <= n && j + k <= m; k++)
				if (hash1(i, j, i + k, j + k) == hash2(i, j, i + k, j + k))
					ans = max(ans, k + 1);
	printf ("%lld", ans);
	return 0;
}

```

---


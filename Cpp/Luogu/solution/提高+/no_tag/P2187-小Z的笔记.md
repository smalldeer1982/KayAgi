# 小Z的笔记

## 题目背景

小Z由于写情书浪费了太多时间，导致他外语课都没有好好听。为什么是外语课而不是英语课？因为小Z也不知道这门课学的是什么语言。


## 题目描述

由于没有好好听课，小Z的笔记全都记的杂乱无章，出现了好多错误的地方。小Z的笔记是如此的糟糕，以至于他只记了一句例句，而且自己还不知道是什么意思……然后在老师讲语法的时候，小Z又零星的记了几个字母对，老师说，这几个字母对是绝对不能相邻的，而且相邻是不关心字母的顺序的，比如老师说，“ab”不能相邻，那么相同的，“ba”也不能相邻。

现在小Z到家了，打开了上课的笔记，然后他发现笔记有很多自相矛盾的地方：为什么下面的不能相邻的字母对会出现在上面的例句里面呢？纠结再三，小Z觉得下面的东西相对比较简单，所以记错的概率比较小……他决定在上面的例句里面擦掉几个字母，使得句子变得合法。

但是小Z还有其他作业要做呢，来不及整理笔记了，就把这个艰巨的任务留给了大家，请问大家，小Z最少要擦掉几个字母，才能使得上面的例句合法？


## 说明/提示

【数据规模】

对于10%的数据，M=0；

对于另外30%的数据，N<=1000；

对于100%的数据，N<=100000，M<=400。


## 样例 #1

### 输入

```
4
noip
2
ip
mo```

### 输出

```
1```

# 题解

## 作者：Siyuan (赞：13)

[$$\Large\texttt{My Blog}$$]()

---

## Description

> 题目链接：[Luogu 2187](https://www.luogu.org/problemnew/show/P2187)

小 Z 的有一个长度为 $n$ 的笔记，他规定有 $m$ 个字母对不能相邻，并且是与字母顺序无关的。现在给出这个笔记，请求出最少需要擦掉多少个字母，使得整个笔记合法。

数据范围：$1\le n\le 10^5$，$1\le m\le 400$

------

## Solution

我们可以很容易地写出朴素的 $\text{DP}$ 转移方程：
$$f_i=\min\{f_j+i-j-1\}\quad(0\le j<i,\text{第}\ i\ \text{个字母和第}\ j\ \text{个字母可以相邻})$$
显然整个转移方程的复杂度为 $O(n^2)$，我们考虑如何优化。首先我们把带有 $i$ 的项提出，得到 $f_i=\min\{f_j-j\}+i-1$，那么这个方程的实质就是求出最小的 $f_j-j$。我们对于每个字母 $i$ 维护一个 $f_i-i$ 的最小值 $g_i$，每次枚举上一个字母 $k$，用 $g_k+i-1$ 来更新 $f_i$ 即可。

**时间复杂度**：$O(26\cdot n)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=1e5+5;
int n,f[N],g[30];
char s[N];
bool e[30][30];

char getc() {
	char c=getchar();
	while(c<'a'||c>'z') c=getchar();
	return c;
}
int main() {
	scanf("%d%s",&n,s+1);
	int m;
	for(scanf("%d",&m);m--;) {
		int u=getc()-'a',v=getc()-'a';
		e[u][v]=e[v][u]=1;
	}
	for(int i=1;i<=n;++i) {
		f[i]=1<<30;
		for(int j=0;j<26;++j) if(!e[s[i]-'a'][j]) f[i]=std::min(f[i],g[j]+i-1);
		g[s[i]-'a']=std::min(g[s[i]-'a'],f[i]-i);
	}
	printf("%d\n",f[n]);
	return 0;
}
```


---

## 作者：linyinuo2008 (赞：5)

[**原题链接**](https://www.luogu.com.cn/problem/P2187)

感谢[这篇博客](https://www.luogu.com.cn/blog/Lazyhurryup/solution-p2187)对我的启发，使我彻底明白了这题,我也决定把一些说的不太清楚的地方写清楚。

首先，我发现目前题解中有一些$O(26 \times n)$的做法有一点问题，未曾考虑删除头尾的情况，过不了[这组Hack](https://www.luogu.com.cn/discuss/show/273605)。建议管理员把这组数据加入。

我的做法是$O(26^2 \times n)$和$O(26 \times n)$，下面来看一下我是如何实现的。

# 1、题意理解


给你一个字符串，并给你一些不能相邻的字符，让你求出这个字符串最少要删几个字符才合法。

这是一道典型的动规题，我们来分析一下为什么。

- 首先，这题有后效性，前面删的很可能影响到后面删的。

- 这时可以根据数据来做一个简单判断，发现可以用动归做。

# 2、算法实现

**处理技巧$1$:** 

我们对字符发现不好处理，我们就干脆把每个字符都变成一个数。其中`a`对应$0$，`z`对应$25$。我们就把$0$到$25$这些数与字符建起了联系。

------------
**处理技巧$2$:**

我们开一个数组$d$记录两个字符能否相邻，初始所有值均为零，若$d_{i,j}$ $=$ $1$则表示$i$, $j$两个字符不能相邻，反之则表示可以。这样我们处理起来就方便多了。
## 想法1
设$f_i$表示字符串中前$i$个字符最少要删字符的数量。

显然上来可以先推出简单的动归方程：

$f_i$ $=$ $min(f_j+i-j-1)$   

其中$0 \leq j \le i$且第$i$个字符和第$j$个字符可以相邻。

这个转移方程的基本意思就是枚举所有可以相邻的字符$i$和$j$，然后删掉中间所有的字符，更新答案的最小值。

这个算法复杂度正常是$O(n^2 \times m)$，加上处理技巧$2$之后是$O(n^2)$的，绝对超时了。

## 想法2
我之后决定对想法一进行优化，但当我看到[君のNOIP。](https://www.luogu.com.cn/user/250469)的题解后，我改变了主意。我决定采用$O(26^2 \times n)$的做法来试一下。

当从前向后依次删字符时，我们发现这个字符该不该删只与上一个字符有关，这时我们设$f_{i,j}$表示字符串中前$i$个字符，且最后一个字符为$j$时最少删字符的个数。

初始值：$f_{i,j}$ $=$ $INF$

显然边界值为:  $f_{0,i}$ $=$ $0$ 其中$0 \leq i \leq 25$

动归转移方程：$f_{i,j}$ $=$ $min(f_{i-1,k})$，其中$0 \leq k \leq 25$

步骤如下：

1. 枚举$i$，然后枚举这一位上可能的字符$j$，$f_{i,j}$考虑最大值也就是$f_{i-1,j}$ $+$ $1$，即直接将这一位上的字符删去。

2. 若原字符串第$i$位$s_i$等于$j$，即这一位字符合法有效，则枚举$s_{i-1}$。

3. 若枚举的$s_i$与$s_{i-1}$可以相邻，那么执行动归转移方程。

4. 答案为$min(f_{n,i})$，其中$0 \leq i \leq 25$（这很显然吧）。

## 想法3
在用想法二过了这道题后，我决定回头去仔细的想一想为什么想法一优化后过不了[这组Hack](https://www.luogu.com.cn/discuss/show/273605)。

首先我先来说一下怎样对想法一进行优化。

$f_i$ $=$ $min(f_j+i-j-1)$

由上式得到：

$f_i$ $=$ $min(f_j-j)$ $+$ $i$ $-$ $1$

我们令$k_i$ $=$ $f_i-i$，于是我们对字符串中每一个`a`到`z`的字符都维护一个$k_i$的最小值。由于这一步可以与动归转移同步进行，所以复杂度就简化到了$O(26 \times n)$。

后来发现是因为未考虑删除头尾的情况。我们在想法一中所提到的转移方程是把区间$[j+1,i-1]$中的字符都删掉，其中$1 \leq i,j \leq n$，所以显然无法对头尾字符进行操作的。

于是解决方法就油然而生了：在头尾各加上一个任意字符，再进行操作。

步骤如下：

1. 枚举$i$，将$f_i$先设为$INF$。

2. 枚举`a`至`z`的所有字符，利用$k_i$进行动归转移。

3. 求当前字符的$k_i$，更新$k_i$。

结果：$min(f_{n,i})$

# 3、代码

代码中有注释欧。

$Code$想法二:
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N=1e5+5;
const int INF=0x7f7f7f;
char s[N],p,q;//s[i]为字符串 
int a[N],n;
int f[N][27],ans=INF;//初始化ans为无限大 
bool d[27][27];
int m;
int min(int a,int b)//手写min函数，应该更快一些 
{
	return a<b?a:b;
}
int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>s[i];
		a[i]=s[i]-'a';//用处理技巧1转化一下 
	}
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>p>>q;
		d[p-'a'][q-'a']=1;
		d[q-'a'][p-'a']=1;//处理技巧2 
	}
	memset(f,INF,sizeof(f));//初始化f为无限大 
	for(i=0;i<=26;i++)
	{
		f[0][i]=0;//显然边界值为(0,i) 
	}
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=26;j++)//枚举这一位上的字母 
		{
			f[i][j]=min(f[i][j],f[i-1][j]+1);//f[i][j]最大的情况：这一位必须删 
			if(a[i]==j)//如果j是这一位上的字母，才能转移 
			{
				for(k=0;k<=26;k++)//枚举上一位的字母 
				{
					if(!d[j][k]) f[i][j]=min(f[i][j],f[i-1][k]);
					//如果这两个字符能挨在一起，转移 
				}
			}
		}
	}
	for(i=0;i<=26;i++)
	{
		ans=min(ans,f[n][i]);//答案更新 
	}
	cout<<ans;
	return 0;
}
```

$Code$想法三：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N=1e5+5;
const int INF=0x7f7f7f;
int f[N],k[N],d[40][40];//k[i]如原文所述，d开大一点 
int a[N],n,m;
char c1,c2;

int min(int a,int b)
{
	return a<b?a:b;
}

int main()
{
	int i,j;
	cin>>n;
	n+=2;
	a[1]=35,a[n]=35;//在首尾各加一个字符 
	for(i=2;i<n;i++)//在中间读入真的字符串 
	{
		cin>>c1;
		a[i]=c1-'a';
	}
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>c1>>c2;
		d[c1-'a'][c2-'a']=d[c2-'a'][c1-'a']=1;
	}
	for(i=1;i<=n;i++)
	{
		f[i]=INF;//f[i]初始化无限大 
		for(j=0;j<=35;j++)//枚举字符 
		{
			if(!d[a[i]][j])  f[i]=min(f[i],k[j]+i-1);//转移 
		}
		k[a[i]]=min(k[a[i]],f[i]-i); //维护k[i]最小值 
	}
	cout<<f[n];
	return 0;
}
```

创作不易，管理员大大求通过，同时求一下置顶！

**若有错误，欢迎指出！**

---

## 作者：Karry5307 (赞：5)

### 题意

有一个长度为 $n$ 的字符串和 $m$ 个限制，每个限制形如 $ab$ 两个字母不能相邻，最小化删去字母的个数使得满足所有限制。

$\texttt{Data Range:}1\leq n\leq 10^5,1\leq m\leq 400$

### 题解

应该是一篇真正正确的题解了。

设 $f_{i}$ 表示原串 $1\sim i$ 的前缀的答案，转移的时候枚举上一个字母是什么，有

$$f_i=\min\{f_j+i-j-1\}=\min\{f_j-j\}+i-1$$

于是可以对于每个字母维护最小的 $f_j-j$，设为 $g$（一个注意的点是 $g$ 不能赋初值为 $\infty$），然后就可以 $O(n)$ 转移了。

但是会出现删除末尾字符的情况，因为 $f_i$ 表示一段前缀的答案，所以直接枚举保留的最后一个字符是哪一个即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
ll n,m,res;
ll f[MAXN],g[51],h[51][51];
char ch[MAXN],s[10];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),memset(f,0x3f,sizeof(f)),f[1]=0;
	scanf("%s",ch+1),m=read(),g[ch[1]-'a'+1]=-1,res=0x3f3f3f3f;
	for(register int i=1;i<=m;i++)
	{
		scanf("%s",s+1);
		h[s[1]-'a'+1][s[2]-'a'+1]=h[s[2]-'a'+1][s[1]-'a'+1]=1;
	}
	for(register int i=2;i<=n;i++)
	{
		for(register int j=1;j<=26;j++)
		{
			!h[ch[i]-'a'+1][j]?f[i]=min(f[i],g[j]+i-1):1;
		}
		g[ch[i]-'a'+1]=min(g[ch[i]-'a'+1],f[i]-i);
	}
	for(register int i=1;i<=n;i++)
	{
		res=min(res,f[i]+n-i);
	}
	printf("%d\n",res);
}
```

---

## 作者：狸狸养的敏敏 (赞：3)

目前的题解区普遍存在的问题就是：未曾考虑删除头尾的情况

从头看这道题，我们发现，一种可行的方案是找到两个最近的可以相邻的字符，然后把中间所有的字符擦掉。

不妨令 $f_i$ 表示让 $[1,i]$ 这个字串满足题目要求所需要的**最小**操作数，那么根据我们上面的分析，就有$f_i=\min\{f_j+(i-j-1)\}$，此时 $s_i$ 必须可以和 $s_j$ 相邻（$s_i$ 表示原字符串中第 $i$ 位的字符）

这样的复杂度是 $O(n^2)$ 的，远远不足以通过此题

考虑哪些是冗余转移，如果 $s_j=s_k,k>j$ ，且 $s_i$ 可以和 $s_j$ 相邻 ( $i>k$ )  
不考虑 $f_k$ 时，显然我们会选择把 $[k+1,i-1]$ 擦掉而非 $[j+1,i-1]$  
问题出现在 $f_k-k+i-1$ 不一定小于 $f_j-j+i-1$  
我们发现我们并不关心转移来的位置，我们只关心转移来的位置 $p$ 的 $f_p-p$ 是否足够小  
因此我们令 $h_i=f_i-i$  
根据我们上面讨论的，如果 $s_j=s_k,h_k<h_j$ ，出现一个可以转移的位置时，我们必然选择从 $k$ 转移，而能否转移只和 $s_k$ 有关  
所以我们令 $g_i=\min_{s_p=i}\{h_p\}$   
那么我们转移的部分已经和 $j$ 摆脱了关系，我们只需要从每个字符转移即可

复杂度 $O(n^2)\rightarrow O(|S|n)$ ，其中 $|S|$ 表示字符集的大小

回到开头的问题，为什么这种做法无法考虑到头尾，注意到我们上面的删除操作本质是删除一段 $[j+1,i-1]$ 这样的区间，而 $i,j\in [1,n]$ ，显然无法涉及到删除 $1,n$ 这两个位置的操作

解决方法也很简单，开头和结尾处各加一个特殊字符即可

```
#include<bits/stdc++.h>
#define reg register
#define i64 long long
using namespace std;
int read(){int x=0,f=0;char ch=0;while(!isdigit(ch))f|=(ch=='-'),ch=getchar();while(isdigit(ch))(x*=10)+=(ch^48),ch=getchar();return f?-x:x;}
void Ot(int x){if(x<0)putchar('-'),x=-x;if(x>=10)Ot(x/10);putchar(x%10+48);}
void Print(int x,char til='\n'){Ot(x);putchar(til);}
int Max(int x,int y){return x>y?x:y;}
int Min(int x,int y){return x<y?x:y;}
int Abs(int x){return x<0?-x:x;}
const int MAXN=101010;
int n,m;
int g[33],f[MAXN];
int a[MAXN];
bool mp[33][33];
char Getch(){char ret=getchar();while(!isalpha(ret))ret=getchar();return ret;}
signed main(){
	#ifndef ONLINE_JUDGE
		freopen("C:/Users/Administrator/Desktop/data.txt","r",stdin);
		freopen("C:/Users/Administrator/Desktop/out.txt","w",stdout);
	#endif
	n=read()+2;
	a[1]=30;a[n]=30;
	for(reg int i=2;i<n;i++)
		a[i]=Getch()-'a'+1;
	m=read();
	for(reg int i=1;i<=m;i++){
		int u=Getch()-'a'+1,v=Getch()-'a'+1;
		mp[u][v]=mp[v][u]=1;
	}
	for(reg int i=1;i<=n;i++){
		f[i]=INT_MAX;
		for(reg int j=1;j<=30;j++)
			if(!mp[a[i]][j])f[i]=Min(f[i],g[j]+i-1);
		g[a[i]]=Min(g[a[i]],f[i]-i); 
	}
//	for(reg int i=1;i<=n;i++)
//		printf("%d\n",f[i]);
	printf("%d\n",f[n]);
	#ifndef ONLINE_JUDGE
		fclose(stdin);fclose(stdout);
		system("C:/Users/Administrator/Desktop/out.txt");
	#endif
	return 0;
}



```

---

## 作者：Para (赞：1)

$\ \ \ \ \ \ \ $对于这道题，我们可以十分容易的得到它的 $DP$ 定义

$\ \ \ \ \ \ \ $定义 $dp_i$ 为前 $i$ 个字符中最少需要删除的字符数量。

$\ \ \ \ \ \ \ $如果 $j$ 字符与则 $i$ 字符可以相邻 $(j < i)$, 则 $dp_i$ 可以由删除 $(j + 1)$ ~ $(i - 1)$得到

$\ \ \ \ \ \ \ $即： 

$\ \ \ \ \ \ \ $ $ dp_i=\min \{{dp_{i},dp_j+(i-j-1)\}}$

----

## codeTLE:

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
bool vis[105][105];
char s[100005], ch[5];
int dp[100005];
int main () {
	int n;
	scanf ("%d %s", &n, s + 1);
	int m;
	scanf ("%d", &m);
	for (int i = 1; i <= m; i++) {
		scanf ("%s", ch + 1);
		vis[ch[1]-'a'+1][ch[2]-'a'+1] = vis[ch[2]-'a'+1][ch[1]-'a'+1] = 1;//双向
	}
	memset (dp, 0x3f, sizeof dp);//因为dp取最小值，所以我们初始化时要给dp附上最大值  
	dp[0] = 0;
	s[0] = 'a' - 1;//防止越界
	for (int i = 1; i <= n; i++) {
		for (int j = i - 1; j >= 0; j--) {
			if (vis[s[i]-'a'+1][s[j]-'a'+1] == 0) {
				dp[i] = min (dp[i], dp[j] + (i - j - 1));//dp[j] 的值加上删除 i - 1 到 j + 1 的花费
			}
		}
	}
	printf ("%d", dp[n]);
	return 0;
}
```

$\ \ \ \ \ \ \ $ 但面对 $N <= 100000$ 的数据， 显然 O ($n^2$) 是无法 $AC$ 的

$\ \ \ \ \ \ \ $ 所以我们要进行以下优化

$\ \ \ \ \ \ \ $ 考虑到输入为 $26$ 个小写字母，我们可以用一个数组 $p$ 来记录之前的值

$\ \ \ \ \ \ \ $ $p_i$ 表示最小的 $dp_j - j$  $(s_j ==  i)$ ($i$ 与 $s_j$ 都是字母)

$\ \ \ \ \ \ \ $ 通过 $dp$ 式转移

$\ \ \ \ \ \ \ $ $ dp_i=\min \{{dp_{i},dp_j+(i-j-1)\}}$ 变为 

$\ \ \ \ \ \ \ $ $ dp_i=\min \{{dp_{i},p_j + i - 1\}}$ 

$\ \ \ \ \ \ \ $ 这两处 j 含义不同， 第一处是下表， 第二处是字母

----

## codeAC:
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
bool vis[105][105];
char s[100005], ch[5];
int dp[100005];
int p[105];
int main () {
	int n;
	scanf ("%d %s", &n, s + 1);
	int m;
	scanf ("%d", &m);
	for (int i = 1; i <= m; i++) {
		scanf ("%s", ch + 1);
		vis[ch[1]-'a'+1][ch[2]-'a'+1] = vis[ch[2]-'a'+1][ch[1]-'a'+1] = 1;
	}
	memset (dp, 0x3f, sizeof dp);
	dp[0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= 26; j++) if (vis[s[i]-'a'+1][j] == 0) dp[i] = min (dp[i], p[j] + i - 1);
		p[s[i]-'a'+1] = min (p[s[i]-'a'+1], dp[i] - i);
	}
	printf ("%d", dp[n]);
	return 0;
}
```
时间复杂度
O ($26 * n$)


---

## 作者：DDOSvoid (赞：1)

思路：首先能判断这是个 dp，贪心的从前往后删显然是错的。

那么先有一个朴素的 dp 方程，$f[i]$ 表前 i 个满足条件（包括第 i 个，最少删几个。那么转移只需要枚举一个 j，如果 i 和 j 可以相邻，则可以拿 $f[j]$ 来更新 $ f[i]$，即 $f[i]=min(f[i],f[j]+i-j-1)$ 就是把 j + 1 ~ i - 1 都删掉。

至于判断是可以做到 O(1)，即只需要拿一个二维数组记录两个字母之间是否可以相邻。

上面的 dp 的复杂度是 $O(n^2)$ 的，考虑优化。

发现转移的过程实际上是找一个最小的 $f[j]-j$，那么我们只需要记录每个字母的最小的 $f[j]-j$ 即可，这样每次转移的复杂度是 $O(26)$，总的复杂度是 $O(26n)$，那么这题就做完了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 100010
#define maxm 410
using namespace std;

int n, m;
char s[maxn], c[3];
int ma[50][50];

int f[maxn];
int g[26];

int main(){
	scanf("%d%s", &n, s + 1);
	scanf("%d", &m);
	for(int i = 1; i <= m; ++i){
		scanf("%s", c+ 1);
		c[1] -= 'a'; c[2] -= 'a';
		ma[c[1]][c[2]] = ma[c[2]][c[1]] = 1;
	}
	memset(f, 10, sizeof f); f[1] = 0; g[s[1] - 'a'] = 0 - 1;
	for(int i = 2; i <= n; ++i){
		for(int j = 0; j < 26; ++j){
			if(ma[s[i] - 'a'][j]) continue;
			f[i] = min(f[i], g[j] + i - 1);
		}
		g[s[i] - 'a'] = min(g[s[i] - 'a'], f[i] - i);
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：forever516 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2187)
# Part 1 题意简述。
有一个长度为 $n$ 的序列，规定有 $m$ 个字母对不能相邻，并且是与字母顺序无关的。求最少要去掉多少个字母，使得整个序列合法。
# Part 2 解法。
本题求最少要擦除的字母数，求最值可选用 DP 大法。

来推这题的方程：$f_i$ 表示前 $i$ 个满足条件（包括第 $i$ 个，最少删几个。那么转移只需要枚举一个 $j$，如果 $i$ 和  $j$ 可以相邻，则可以拿 $f_i$ 来更新 $f_j$。

然后，我们就得出了式 $f_i=\min(f_i,f_j+i-j-1)$。
但是时间复杂度爆了，优化一下（把带有 $i$ 的项提出）。然后，我们就得到了这个 $f_i=\min{f_j-j}+i-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int n, m,ma[50][50],f[maxn],g[26];
char s[maxn], c[3];
int main() {
	cin>>n;
	cin>>s+1;//一定要注意加一，不然会WA
	cin>>m;
	for(int i = 1; i <= m; ++i) {
		cin>>c+1;//一定要注意加一，不然会WA
		c[1] -= 'a';//处理字符
		c[2] -= 'a';
		ma[c[1]][c[2]] = ma[c[2]][c[1]] = 1;
	}
	memset(f, 10, sizeof f);
	f[1] = 0;
	g[s[1] - 'a'] = 0 - 1;
	for(int i = 2; i <= n; ++i) {
		for(int j = 0; j < 26; ++j) {
			if(ma[s[i] - 'a'][j]) continue;
			f[i] = min(f[i], g[j] + i - 1);//dp式子 
		}
		g[s[i] - 'a'] = min(g[s[i] - 'a'], f[i] - i);//记得修改g数组 
	}
	cout << f[n];//经典dp题输出 
	return 0;
}
```
感谢大佬帮助：@ Para @DDOSvoid @ Siyuan。

如有问题，欢迎提出。

---

## 作者：Lee666666 (赞：0)

首先求最小值一眼 DP，注意到我们只需要考虑删除字母后的序列中前一个字母和后一个字母的关系，所以设 $dp(i,j)$ 表示考虑前 $i$ 个字母，删除字母后最后一个字母为 $j$ 时的最小删除字母数。  
关于第 $i$ 个字母是否删除我们有两种转移如下：
$$
dp(i,j)=\begin{cases}\min dp(i-1,k)&j=str(i)\\dp(i-1,j)+1&j \ne str(i)\end{cases}
$$  
其中 $str$ 表示题意中字符串，字母 $k$ 须满足 $match(i,j)=0$。（当字母 $i$ 与字母 $j$ 不能相邻时，$match(i,j)=1$，反之则为 $0$）  
显然刚开始除了最后一个字母为 $str(0)$ 其他方案都不存在，所以初始化如下：  
$$
dp(0,i)=\begin{cases}0&i=str(0)\\\inf&i \ne str(0)\end{cases}
$$
注意到第一维中的 $i$ 仅能从 $i-1$ 转移过来，可以使用滚动数组优化掉一维空间。  

代码  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int inf = 0x3f3f3f3f;

inline int min(int a, int b)
{
	return a < b ? a : b;
}

char str[100015];
int n, m, tmp, ans = inf, dp[26];
bool mp[26][26];

int main()
{
	char ch1, ch2;
	cin >> n >> str >> m;
	while (m--)
	{
		cin >> ch1 >> ch2;
		mp[ch1 - 'a'][ch2 - 'a'] = mp[ch2 - 'a'][ch1 - 'a'] = 1;
	}
	for (register int i = 0; i < 26; i++) // 初始化 
	{
		dp[i] = inf;
	}
	dp[str[0] - 'a'] = 0;
	for (register int i = 1; i < n; i++)
	{
		tmp = i;
		for (register int j = 0; j < 26; j++) // 第一种转移（为防止 dp[i - 1][j] 与 dp[i][j] 混淆用 tmp 记录 dp[i][j] 的值） 
		{
			if (mp[str[i] - 'a'][j] ^ 1)
			{
				tmp = min(tmp, dp[j]);
			}
		}
		for (register int j = 0; j < 26; j++) // 第二种转移 
		{
			dp[j]++;
		}
		dp[str[i] - 'a'] = min(dp[str[i] - 'a'], tmp);
	}
	for (register int i = 0; i < 26; i++) // 计算答案
	{
		ans = min(ans, dp[i]);
	}
	cout << ans;
	return 0;
}
	return 0;
}
```  
设字符集为 $S$，时间复杂度 $O(n \cdot \left|S\right|)$，空间复杂度 $O(\left|S\right|)$。

---

## 作者：aSunnyDay (赞：0)

这题对我来说像个黄题一样，但是我看讨论区的同志们没有对难度提出异议、

转换：这题问 **最小擦除几个数**，我们可以研究 **最大保留几个数**。

最开始想到 $f[i]$ 代表 $s[i]$ 必须在 $ANS$ 字符串内,问满足所有限制的最长字符串的长度

因为我们**只要看**不会冲突的字母最后出现的位置（因为如果是**找前面出现**的**一定不会更优**）

于是我们设 $lst[i]$ 为第 $i$ 个字母上一次出现的位置

状态转移方程就显而易见了:

若字符 $j$ 不与 $s[i]$ 冲突的话，那么 $f[i]=max(f[i],f[lst[j]]+1)$

$ANS:MAX(f[i])$

思路完整了，放代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100009;
ll n,m,lst[N],f[N],ans;
string s;
bool vis[26][26];
int main(){
	cin>>n>>s>>m;
	for(ll i=1;i<=m;++i){
		string s2;
		cin>>s2;
		vis[s2[0]-'a'][s2[1]-'a']=vis[s2[1]-'a'][s2[0]-'a']=1;
	}
	for(ll i=0;i<26;++i) lst[i]=-1;
	for(ll i=0;i<n;++i) f[i]=1;
	for(ll i=0;i<n;++i){
		for(ll j=0;j<26;++j)///////~lst[j]???
			if(!vis[j][s[i]-'a']&&(lst[j]!=-1)) f[i]=max(f[i],f[lst[j]]+1);
		lst[s[i]-'a']=i;
		ans=max(ans,f[i]);
	}
	cout<<n-ans;
	return 0;
}
```


---

## 作者：君のNOIP。 (赞：0)

**与其他所有题解不同，本题解为 $O(27^2 *n )$ 的 dp。**

考虑从前往后依次删字符，过程中要保证始终满足条件，发现考虑第 $i$ 个字符时只和前 $i-1$ 个字符序列中最后一个字符有关。

设 $dp_{i,j}$ 为考虑前 $i$ 个字符，最后一个字符为 $j$ 时需要删去的最少字符数量，枚举 $i$ 和 $j$。

初始值： $dp_{i,j} = +oo,dp_{0,0} = 0$。

- 新加入第 $i$ 个字符时可以直接删去： $dp_{i,j} \leftarrow dp_{i-1,j} + 1$

- 枚举上一个字符 $p$， 设第 $i$ 个字符为 $c_i$， 若字母对 $p c_i$ 不冲突，则可以不用删去 $c_i$： $dp_{i,c_i} \leftarrow dp_{i-1,p}$


答案为 $min(dp_{n,j})$， $j = 0$ 时相当于全部删去。

------------


### Code:


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
#define G() Cr = getchar()
#define LL long long
LL Xr, Fr; char Cr;
inline LL rd() {
	Xr = 0, Fr = 1, G();
	while(Cr < '0' || Cr > '9') {if(Cr == '-') Fr = -1; G();}
	while(Cr >= '0' && Cr <= '9') Xr = (Xr<<1) + (Xr<<3) + (Cr&15), G();
	return Xr * Fr;
}
#define MAX_N 100005
#define oo 1000000007
int n, m, a, b, ans;
string ss;
int va[MAX_N], dp[MAX_N][27]; // i_th j min_ans
bool jd[30][30];
int main() {
	n = rd();
	cin >> ss;
	for( int i = 1; i <= n; i++ ) va[i] = ss[i-1] - 'a' + 1;
	m = rd();
	for( int i = 1; i <= m; i++ ) {
		cin >> ss;
		a = ss[0] - 'a' + 1, b = ss[1] - 'a' + 1;
		jd[a][b] = jd[b][a] = 1;
	}
	for( int i = 1; i <= n; i++ )
		for( int j = 0; j <= 26; j++ )
			dp[i][j] = oo;
	for( int i = 1; i <= n; i++ ) 
		for( int j = 0; j <= 26; j++ ) {
			dp[i][j] = min(dp[i][j], dp[i-1][j]+1);
			for( int p = 0; p <= 26; p++ )
				if(!jd[p][j] && va[i] == j ) dp[i][j] = min(dp[i][j], dp[i-1][p]);
		}
	ans = n;
	for( int i = 0; i <= 26; i++ ) ans = min(ans,dp[n][i]);
	cout << ans;
}
```

------------

此方法不需要特殊处理，可以轻松通过 Akrry 的 [hack](https://www.luogu.com.cn/discuss/show/273605)。

---


# [HNOI2001] 洋洋吃蛋糕

## 题目描述

洋洋是有名的“小馋猫”。他爱吃许多东西，但也有一些不爱吃的东西。一天，洋洋发现家中有一块刚烤好的长方形的蛋糕，而且蛋糕里放上了各种各样的东西，有爱吃的草莓，奶酪，也有不爱吃的核桃仁。这使得洋洋有一些为难，到底是吃还是不吃呢？这时，爷爷看出了洋洋的烦恼，然后说：你若能够遵守以下几条规则的话，蛋糕可以随便吃：

1. 蛋糕的尺寸为 $n\times m$，在吃之前，需先把蛋糕划分成 $n\times m$ 个单位蛋糕块，然后对每一个单位蛋糕块按照自己的喜好给其打分，分数越高表示越爱吃，反之则表示越不爱吃。这个分数为这一个单位蛋糕块的好吃程度值。

1. 每一个单位蛋糕块要么全部被吃掉，要么不吃。

1. 被吃掉的蛋糕块必须成长方形或正方形，是由一些单位蛋糕块组成的，且蛋糕块的两边必须和原来的大蛋糕块的两边平行。一块蛋糕块的好吃程度值就是所有组成这个蛋糕块的单位蛋糕块的分数之和。

1. 被吃掉的蛋糕块的尺寸任意，且块数也任意。

1. 为了保持蛋糕块的美观，所有被吃掉的蛋糕块在原来的大蛋糕块中的位置不能相邻，且不能重叠。如图 1 和图 2 的吃法是不允许的，而图 3 和图 4 的吃法是允许的。
![](https://cdn.luogu.com.cn/upload/pic/1295.png) 
1. 所有被吃掉的蛋糕块的好吃程度值之和最大。

爷爷的话并没有消去洋洋的烦恼，因为他只能做好第一点，而不知如何选择蛋糕块。于是，洋洋请你帮忙选择蛋糕块，以使得所有被吃掉的蛋糕块的好吃程度值之和最大。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1\le n\le 200$，$1\le m\le 10$，$-100\le c\le 100$。

## 样例 #1

### 输入

```
2 3                            
4 5 -2
-1 2 1
```

### 输出

```
10```

# 题解

## 作者：AC_Evil (赞：8)

## 状压DP

尤其注意到$m\leq 10$，那必然想到状压来求解。

状压$m$位二进制表示当前行中在矩形内的点为$1$，其余为$0$。

转移到下一行必须要满足题目内矩形的合法条件。

而判断需要$\mathcal O(m)$的复杂度。

总复杂度为$\mathcal O(nm\times 2^{2m})$，看起来很容易TLE，考虑做些有用的优化。

比如感性理解来看很多转移都是无用的（大概有$90\%$），这样常数就变成$1/10$。

再然后判断发现可以通过位运算直接$\mathcal O(1)$。

这样复杂度可以变成$\mathcal O(\frac1{10}\times n\times 2^{2m})$

细节请君看代码（又短又快又简洁/se）

```cpp
#include <bits/stdc++.h>

const int B = 10, L = 205;

int f[1<<B], g[1<<B], n, m, c[L][B];
std::vector<int> tran[1<<B];

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			scanf("%d", &c[i][j]);
	for (int S = 0, U; S < 1<<m; S++)
		for (int T = 0; T < 1<<m; T++)
			if (U = S^T, !((U>>1|U<<1)&S&T)) tran[T].push_back(S);
	for (int i = 0; i < n; i++) {
		for (int S = 0; S < 1<<m; S++) {
			int sum = 0;
			for (int j = 0; j < m; j++) if (S&(1<<j)) sum += c[i][j];
			for (int j = 0; j < tran[S].size(); j++)
				g[S] = std::max(g[S], f[tran[S][j]] + sum);
		}
		memcpy(f, g, sizeof f); memset(g, 0, sizeof g);
	}
	int ans = 0;
	for (int S = 0; S < 1<<m; S++) ans = std::max(ans, f[S]);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：stansxt (赞：3)

# 前言
- 代码长度比楼上长了不少，但是自认为解释的稍微清楚一些QwQ
- 适合完全没有思路的同学www

# 思路
- 楼上说的没错，大体思路就是状压DP，但是我在这里用了一些预处理来降低复杂度。

- 首先，观察到 $m$ 非常小，只有10，因此考虑把这一维进行状态压缩。状态为一个2进制01串，0表示不选，1表示选，$dp[i][j]$ 表示考虑了前 $i$ 行，第 $i$ 行状态为 $j$ 的最大得分，那么我们很容易把转移方程写出来：

- $dp[i][j] = max(_{k=0}^{k<2^m}[$ 状态k与j相邻时满足题目要求 $]dp[i-1][k])+($ 这一行所选的得分 $)$ 。

- 暴力转移的话，状态复杂度为 $O(n\times 2^m)$ ，转移复杂度为 $O(m\times n\times 2^{2m})$ ，大概在 $2e9$ 左右，这显然有点太大了。

- 考虑怎么优化。我们可以发现，两个状态拼在一起是否符合题目要求与他们在哪一行是无关的，因此我们可以 $O(2^m)$ 预处理出哪两个状态在一起是合法的（怎么处理稍后再讲）。

- 进而，我们用一个 $vector$ < $int$ > $G[1024]$ 来存储从每一个状态可以与哪些其他状态相邻。

- 之后我用一个程序计数了一下，$m=10$ 的时候只有 $1e5+2e4$ 左右对满足题意的可以互相转移的状态。因此我们最终的复杂度大概是 $O(n\times 1e5)$ 左右，也就是 $2e7$ 左右。

- 现在我们来说一下如何判断两种状态是否可以相邻。首先，每个状态都是一个01串，因此都是一段1一段0一段1一段0……。我们观察题目中的图，会发现如果两个状态相邻，那么他们的每段1， **不会存在部分重叠的情况** 。就是说，对于两个状态中的每一段1，它们或是完全重合，或是完全不重合。因此当我们判断这两种状态是否合法时，只需要从左往右扫一遍，发现有哪一段是由 **一段两状态都是1的和一段两状态中恰有一个是1的** 组成，那么这两个状态就不能放在一起。

- 举个例子：
~~~
011100
001110
~~~

- 这两个状态显然不能放在一起，因为没有一个矩形恰覆盖所有1，而两个矩形的话又不合法了。

- 这两个状态中，第2位是1个1，1个0，第3、4位是两个1，第5位又是1个1，1个0，因此不合法。

- 再举个合法的例子：
~~~
011000
011010
~~~

- 这就是合法的，因为它不存在我上述的情况。显然，第2、3位可以用一个矩形覆盖，第5位在用另一个矩形覆盖就好了。

- 那么还有最后一个问题。当相邻两行合法后，他与接下来的行拼在一起也能合法吗？答案是肯定的。因为一个两个矩形，如果他们各一条边与另一矩形的一条边重合的话，又因为他们都是水平、竖直放置的，所以一定可以拼在一起。大家如果想不明白可以手绘三行模拟一下。

# 代码
```
//P3616 富金森林公园
//submit 1
//By sxt on 2021.7.12
#include<bits/stdc++.h>
#define rg register int
#define il inline
#define in read()
#define _num(x) (x >= '0' && x <= '9')
#define Mem(x) memset(x, 0, sizeof(x)) 
#define mid (l+r>>1)
#define el else if
#define lowbit(x) (x&(-x))
using namespace std;
const int N = 205;
const int M = 1024;
il void ckmin(int &x, int y){return (void)(x = x < y ? x : y);}
il void ckmax(int &x, int y){return (void)(x = x > y ? x : y);}
il int read(){
		int x=0,f=1;
		char ch=getchar();
		while(!_num(ch)){
			if(ch=='-')
				f=-1;
			ch=getchar();
		}
		while(_num(ch)){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
}
char fp[18];
int pcnt;
il void pint(int x){
		pcnt = 0;
		if(x == 0) putchar('0');
		if(x < 0){
			x = -x;
			putchar('-');
		}
		while(x){
			fp[++pcnt] = x % 10 ^ 48;
			x /= 10;
		}
		while(pcnt) putchar(fp[pcnt--]);
		putchar('\n');
}
int n, m, a[N][15], dp[N][M], c[N][M];//我的a数组是题目中的c数组
vector<int> G[M]; 
bool check(int x, int y){
		int d1[11], c1 = 0, d2[11], c2 = 0;
		for(int i = 0; i < 11; ++ i) d1[i] = d2[i] = 0;
		while(x) d1[++ c1] = x & 1, x >>= 1;
		while(y) d2[++ c2] = y & 1, y >>= 1;
		int now = -1;
		for(int i = 1; i <= m; ++ i){
			if(d1[i] == 1 && d2[i] == 1){
				if(now == 1) return false;
				now = 0;
			}
			if((d1[i] | d2[i]) == 1 && (d1[i] & d2[i]) == 0){
				if(now == 0) return false;
				now = 1;
			}
			if((d1[i] | d2[i]) == 0) now = -1;
		}
//	for(int i = 1; i <= m; ++ i) cout << d1[i] << ' ' ;
//	puts("");
//	for(int i = 1; i <= m; ++ i) cout << d2[i] << ' ' ;
//	puts("\n");
		return true;
}
signed main()
{
//	freopen("oh.txt", "r", stdin);
		n = in, m = in;
		for(int i = 1; i <= n; ++ i) for(int j = 1; j <= m; ++ j) a[i][j] = in;
		for(int i = 0; i < (1 << m); ++ i) for(int j = 0; j < (1 << m); ++ j)
			if(check(i, j)) G[i].push_back(j);
		int now, wei;
		for(int i = 1; i <= n; ++ i) for(int j = 0; j < (1 << m); ++ j){
			now = j;
			wei = 1;
			while(now){
				if(now & 1) c[i][j] += a[i][wei];
				++ wei;
				now >>= 1;
			}
		}
		for(int i = 1; i <= n; ++ i) for(int j = 0; j < (1 << m); ++ j){
			for(int k = 0; k < G[j].size(); ++ k) dp[i][j] = max(dp[i][j], dp[i - 1][G[j][k]]);
			dp[i][j] += c[i][j];
		}
		int ans = 0;
		for(int i = 0; i < (1 << m); ++ i) ans = max(ans, dp[n][i]);
		printf("%d\n", ans);
		return 0;
}
```

# 后记
- 这题难度并不是很高，并且感性理解的话应该很容易写出来，但是读者应该仔细想明白每一步的证明，也许我写的、想的也不是很清晰，大家可以自己多动动脑、手推一下，还是很有意义的。

## THE·END.

---

## 作者：_lyx111 (赞：2)

# P2228 [HNOI2001]洋洋吃蛋糕

[link](https://www.luogu.com.cn/problem/P2228)

题意这里就不赘述了。

观察到 $m\le 10$，自然地想到**状压dp**。

考虑将每一行的每一个格子是否被吃这个状态进行状压，被吃则这个格子所对的二进制位为 $1$，否则为 $0$。那么每一行就有 $2^m$ 种状态。

设 $dp_{i,S}$ 表示前 $i$ 行，最后一行的吃蛋糕的方案为 $S$ 的方案数。

当状态 $S$ 的上一行可以为 $T$ 时，显然的有以下转移：

$$dp_{i,S}=\max_{T}dp_{i-1,T}+sum$$

其中 $sum$ 表示状态 $S$ 为 $1$ 的位的 $C_{i,j}$ 之和。

那么暴力转移的时间复杂度为 $O(n\times 2^{2m}\times m)$，枚举每一行 $i$ 是 $O(n)$，枚举第 $i$ 行的状态 $S$ 是 $O(2^m)$ 的，枚举第 $i-1$ 行的状态 $T$ 是 $O(2^m)$ 的，判断 $S,T$ 在相邻两行是否合法是 $O(m)$ 的。

考虑优化：枚举第 $i-1$ 行的状态 $T$ 和判断 $S,T$ 在相邻两行是否合法的时间复杂度。

容易发现：状态 $S,T$ 是合法的只有以下几种情况：

- $S=0$。

- $T=0$。

- $((S\ \text{xor}\ T)>>1|(S\ \text{xor}\ T)<<1)=0$，其中 $\text{xor}$ 是按位异或运算。

那么可以 $O(1)$ 判断 $S,T$ 是否合法。

那么可以 $O(2^{2m})$ 预处理出对于状态 $T$，它的上一行的可行的状态。

## 代码

~~~cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN=210,MAXM=15,M=10;

int n,m;
int c[MAXN][MAXM];

vector<int>t[1<<M]; //预处理状态 T 的上一行的合法状态 S 

int dp[MAXN][1<<M];
int ans;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=0;j<m;j++)
			scanf("%d",&c[i][j]);
	
	for(int S=0;S<(1<<m);S++)
		for (int T=0;T<(1<<m);T++)
			if(!(((S^T)>>1|(S^T)<<1)&S&T)) //S=0 or T=0 or ((S^T)>>1=0 and (S^T)<<1=0)
				t[T].push_back(S); //预处理状态 T 的上一行的合法状态 S 
	
	for(int i=1;i<=n;i++)
		for(int S=0;S<(1<<m);S++)
		{
			int sum=0;
			for(int j=0;j<m;j++)
				if(S&(1<<j))
					sum+=c[i][j];
			for(int j=0;j<t[S].size();j++)
				dp[i][S]=max(dp[i][S],dp[i-1][t[S][j]]+sum);
		}
	
	for(int S=0;S<(1<<m);S++)
		ans=max(ans,dp[n][S]); //计算答案 
	
	printf("%d",ans);
	return 0;
}
~~~

---

## 作者：Swirl (赞：1)

状压。

---

### 壹

题意就省略了。

观察到 $1 \le m \le 10$，大概率就是一个 $2^m$ 量级的算法，可以不错地想到状压（实在不行也能记搜）。

定义 $dp_{i, S}$ 为前 $i$ 行且第 $i$ 行情况为 $S$ 的时候的最大答案。

### 贰

考虑如何转移。

枚举 $i$、$S$，则对于所有的 $S$，需要找到所有合法的上一行的状态 $T$。

有：

$$
dp_{i, S} = \max (dp_{i - 1, T} + \sum_{j \in S}a_{i, j})
$$

枚举 $i$ 需要 $n$，枚举 $S$、$T$ 各需要 $2^m$，判定 $T$ 是否合法需要 $1$，则复杂度为 $\mathcal O(n2^m)$，理论能过，但会被卡常。

### 叁

优化。

发现无论 $i$ 取什么值，$S$ 的上一行的状态 $T$ 所组成的集合是一定的，这是一件非常好玩的事情。

我们可以预处理，在枚举 $i$ 的循环外枚举 $S$ 和 $T$，预处理出所有 $S$ 的上一行状态集合。

### 肆

然而你貌似不知道怎么判定 $T$ 是否合法。

定义 $V = S \oplus T$， 即 $S$ 与 $T$ 的不同部分，相同部分可以通过一个矩形覆盖住。

如果任意 $j \in V$，与覆盖的矩阵相邻，即 `((V << 1) | (V >> 1)) & S & T != 0`，则不合法，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dj9ftm9r.png)

这样是一个合法的状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/uv61qz82.png)

这样是一个不合法的状态。

### 伍

代码。

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int& x, int c) {
	x = max(x, c);
}
inline void cmin(int& x, int c) {
	x = min(x, c);
}

int _test_ = 1;

const int N = 205, M = 15;
int n, m, a[N][M], dp[2][1 << M], ans = 0;
vector<int> t[1 << M];

void init() {}

void clear() {}

void solve() {
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> a[i][j];
		}
	}
	for (int j = 0; j < (1 << m); j++) {
		for (int r = 0; r < (1 << m); r++) {
			int u = j ^ r;
			if (!(((u << 1) | (u >> 1)) & j & r)) {
				t[r].push_back(j);
			}
		}
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < (1 << m); j++) {
			dp[i & 1][j] = 0;
			int sum = 0;
			for (int k = 0; k < m; k++)
				if (j & (1 << k))
					sum += a[i][k];
			for (int r : t[j]) dp[i & 1][j] = max(dp[i & 1][j], dp[(i + 1) & 1][r] + sum);
			if (i == n - 1) cmax(ans, dp[i & 1][j]);
		}
	}
	cout << ans;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	// cin >> _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：0)

# P2228 [HNOI2001] 洋洋吃蛋糕 题解
不算太难的一道蓝题。  
### 解题思路  
看见 $m\le 10$，望文生义，容易想到状压。那我们不妨令 $dp_{i,j}$ 为第 $i$ 行选取状态为 $j$ 的最大值。答案即为 $\max_{0\le i < 2^m} dp_{n,i}$。考虑转移即为本题第一个要用脑子的地方。显然该行状态只与上一行有关。设前后两行状态是 $A,B$，一开始以为判断是 $A=B$ 或 $A\land B=\varnothing$，但发现如果有：

```markdown
11101
11100（二进制形式）
```
这时候也是可以的。  
那么我们实际就是要考虑有没有对应位不相等且邻接与一个相等的状态的位置，有就不行，没有就行。    
可以令 $T$ 为 $A$ 异或 $B$，这时 $T$ 就表示所有对应位不相等的位置的并。分别对 $T$ 左移 1 位和右移 1 位，判断是否和 $A,B$ 有交集就可以了。即 `!((t>>1|t<<1)&a&b)`，学过初赛的同学都容易感性理解。  
但是，这样时间复杂度是 $O(n\times 2^{2m})$，大约为 $2\times 10^8$，虽然你谷曾打出一些传奇战绩，但还是不是很好。  
我们考虑离线处理每个状态对应可搜索的状态，虽然时间复杂度看似没变，但是帮我们省去了很多时间。以 $m=10$ 为例子，如果不预处理每个 $n$ 需要跑 $1048576$ 种状态，但如果与处理了就只需要跑 $121552$ 种状态，大约是 $\frac{1}{10}$。  
就这样吧。  
### AC 代码  

```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n,m;
int c[205][15];
int dp[205][1<<11];
vector<int> v[1<<11];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;i<(1<<m);i++){
		for(int j=0;j<(1<<m);j++){
			int t=i^j;
			if(!((t>>1|t<<1)&i&j)) v[i].push_back(j);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<m;j++){
			scanf("%d",&c[i][j]);
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=0;j<(1<<m);j++){
			for(register int k=0;k<m;k++){
				if(j&(1<<k)) dp[i][j]+=c[i][k];
			}
		}
	}
	for(register int i=2;i<=n;i++){
		for(register int j=0;j<(1<<m);j++){
			int tmp=0;
			for(register auto k:v[j]){
				tmp=max(tmp,dp[i-1][k]);
			}
			dp[i][j]+=tmp;
		}
	}
	int ans=0;
	for(int j=0;j<(1<<m);j++){
		ans=max(ans,dp[n][j]);
	}
	printf("%d",ans);
}
```

---


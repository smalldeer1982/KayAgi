# 命运的彼方

## 题目背景

kkksc03 与 lzn 踏上了一次寻宝之旅，经过 kkksc03 与 lzn 的不懈努力，终于解开了所有的谜题，依靠御风飞翔之术越过了大河。终点距离他们只有一步之遥了……


## 题目描述

他们现在位于的地方，是连接古代和现代两个世界的结界法阵。一般来说，即使是神也是不能跨越时空的，但是， lin\_toto 给了他们一点提示，告诉了他们这个法阵的玄机。并告诉 kkksc03 与 lzn，只要同心协力，就可以改变命运，突破结界的枷锁。

lin\_toto 带他们走到了法阵的前方。展示在他们面前的是一堵巨大却残缺的墙，由若干组连续魔力砖组成（每个魔力砖均为正方体，大小均为 $1\times1\times1$），且各组魔力砖的高度各不相同。根据经验，只有让最少连续 $K$ 组成这堵墙的魔力砖的高度相同，才能突破法阵的入口，召唤来自神界的帮助，跨越时空。

两人可完成的操作如下：从墙上搬走一块砖，或是从旁边的魔力砖堆（假设可用的魔力砖无限）中拿一块砖放置在墙上。每搬运一块砖都会耗费 kkksc03 与 lzn 一点能量值。lzn 希望让两人所耗费的能量值最少。

现在kkksc03带着这个问题找到了聪明的你，你能帮他计算出他所需付出的最少能量值吗？


## 说明/提示

对于 $10\%$ 的数据, 有 $1≤ N ≤ 10, 2 ≤ K ≤ N, 0 ≤ H _ i ≤ N$。

对于 $20\%$ 的数据，有 $K = 2$。

对于 $40\%$ 的数据，有 $1≤ N ≤ 500, 2 ≤ K ≤ N, 0 ≤ H _ i ≤ N$。

对于 $80\%$ 的数据，有 $1≤ N ≤ 10 ^ 5 , 2 ≤ K ≤ N, 0 ≤ H _ i ≤ 10 ^ 6$。

对于 $100\%$ 的数据，有 $1≤ N ≤ 5\times 10 ^ 5 , 2 ≤ K ≤ N, 0 ≤ H _ i ≤ 10 ^ {12}$，并且所有 $H _ i$ 互不相同。


## 样例 #1

### 输入

```
5 2
5
4
1
2
3
```

### 输出

```
1```

# 题解

## 作者：ModestCoder_ (赞：9)

[
原题传送门](https://www.luogu.org/problemnew/show/P2263)

### 题目大意：
一串长度为n的数，进行一次操作可将其中一个数+1或-1，问最少进行多少次操作，使得数列中有一段长度为k，且大小相同的数

### 思路：
先考虑如何进行最少次的操作可将一串长度为k的数变成大小相同
显然是**将这段数的大小都变成中位数，可是操作数最少**
比如1 2 3，若把数都变成3，则需要3-1+3-2=3次操作；若把数变成2（中位数），则需要3-2+2-1=2次操作

所以现在考虑如何找到一串数中的中位数，以及找到中位数后，如何进行统计操作总数
我们一个一个来

###### 找中位数
排序？先进行排序，中位数就找到了，但是时间复杂度太高，淘汰
堆？利用堆维护，开一个大根堆一个小根堆……太麻烦，而且本题需要支持插入和删除操作
数据结构！用树状数组即可求得一段数的中位数，[详细请点击这里](https://www.luogu.org/blog/51719/solution-p1168)，不过本题需要再做一个小改动，设当前数组c，那么插入为add(i,1)，删除为add(i - K, -1);

###### 求操作总数
操作可分为两种，+1和-1
即原数列中有两种数，比大于中位数的数与小于中位数的数

大于中位数的数，要把它变成中位数，需要进行(该数-中位数)次操作
小于中位数的数，要把它变成中位数，需要进行(中位数-该数)次操作

我们现在可以知道这段数中的中位数，以及它的位置，
那么操作总数等于（前方高能）：**（小于中位数的数的个数 * 中位数 - 小于中位数的数之和）+（大于中位数的数之和 - 大于中位数的数的个数 * 中位数）**

这些家伙都可以用树状数组维护
数的个数跟前面求中位数一起维护了（用同一个树状数组）
数的和则需再开一个树状数组，维护前缀和即可

**另外，此题要开long long， 要离散化进行操作**

Code：

```cpp
//tree1维护数的个数，tree2维护数的和
#include <bits/stdc++.h>
#define res register int
#define ll long long
#define maxn 500010
using namespace std;

inline ll read(){
	ll s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
struct node{
	ll x; 
	int num;
};
node b[maxn];
int tree1[maxn], n, K, p, c[maxn];
ll tree2[maxn], a[maxn], val[maxn];

inline bool cmp(node x, node y){ return x.x < y.x; }
inline int lowbit(int x){ return x & -x; }
inline void add1(int x, int y){ for (; x <= p; x += lowbit(x)) tree1[x] += y; }
inline void add2(int x, ll y){ for (; x <= p; x += lowbit(x)) tree2[x] += y; }
inline int query1(int x){ int sum = 0; for (; x; x -= lowbit(x)) sum += tree1[x]; return sum; }
inline ll query2(int x){ ll sum = 0; for (; x; x -= lowbit(x)) sum += tree2[x]; return sum; }

inline int find(int x){ //二分配合树状数组查找中位数
	int ans = 0, l = 0, r = p;
	while (l <= r){
		int mid = (l + r) >> 1; 
		if (query1(mid) >= x) ans = mid, r = mid - 1; else l = mid + 1;
	}	
	return ans;
}

int main(){
	n = read(), K = read();
	for (res i = 1; i <= n; ++ i) a[i] = read(), b[i].x = a[i], b[i].num = i;
	sort(b + 1, b + 1 + n, cmp);
	b[0].x = b[1].x - 1; 
	for (res i = 1; i <= n; ++ i) c[b[i].num] = b[i].x == b[i - 1].x ? p : ++p, val[p] = b[i].x;//离散化，val数组记录离散后的数对应的原数
	for (res i = 1; i <= K; ++ i) add1(c[i], 1), add2(c[i], a[i]);
	ll ans = 0x3f3f3f3f3f3f3f3f; 
	for (res i = K + 1; i <= n + 1; ++ i){  
		int tmp = find((K + 1) >> 1);
		ll mid = val[tmp];
		ans = min(ans, query1(tmp - 1) * mid - query2(tmp - 1) + query2(p) - query2(tmp) - (query1(p) - query1(tmp)) * mid);
		if (i == n + 1) break; 
		add1(c[i - K], -1); add1(c[i], 1);
		add2(c[i - K], -a[i - K]); add2(c[i], a[i]);
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：a___ (赞：4)

对顶堆板子题。

观察题意发现显然是将连续 $k$ 个数变为它们的中位数。

每次加入（删除）一个数的时候以堆顶为分界线，选择将其加入（删除）小根堆或大根堆。如果某一边堆的大小比另一边大，就从这边取一个元素丢到另一边。

所以我们将两个 `priority_queue` 组成一个可删堆，再将两个可删堆组成一个对顶堆就好。

```cpp
#include<cstdio>
#include<queue>
const int N=500010;
int n,k,siz1,siz2;
long long a[N],sum1,sum2,ans=3e18;
std::priority_queue<long long>q1,q3;
std::priority_queue<long long,std::vector<long long>,std::greater<long long> >q2,q4;
int main()
{
	int i;scanf("%d%d",&n,&k);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		if(i>k)!siz2||(siz1&&a[i-k]<=q1.top())?(q3.push(a[i-k]),--siz1,sum1-=a[i-k]):(q4.push(a[i-k]),--siz2,sum2-=a[i-k]);
		while(!q3.empty()&&q1.top()==q3.top())q1.pop(),q3.pop();
		while(!q4.empty()&&q2.top()==q4.top())q2.pop(),q4.pop();
		!siz2||(siz1&&a[i]<=q1.top())?(++siz1,q1.push(a[i]),sum1+=a[i]):(++siz2,q2.push(a[i]),sum2+=a[i]);
		if(siz1-1>=siz2+1)--siz1,++siz2,sum1-=q1.top(),sum2+=q1.top(),q2.push(q1.top()),q1.pop();
		if(siz2-1>=siz1+1)--siz2,++siz1,sum2-=q2.top(),sum1+=q2.top(),q1.push(q2.top()),q2.pop();
		if(i>=k&&ans>sum2-sum1+(siz1!=siz2?siz1<siz2?-q2.top():q1.top():0))ans=sum2-sum1+(siz1!=siz2?siz1<siz2?-q2.top():q1.top():0);
	}
	printf("%lld\n",ans);
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/50249611) - 当前最优解

---

## 作者：peterwuyihong (赞：3)

因为你 fhq 平衡树刚学，需要巩固，于是你掏出一个 fhq 平衡树。

每次你找到中位数，求出中位数的 rank，数学计算一下，就是小于这个中位数的数量乘以中位数减去小于这个中位数的和，大于等于的部分同理，所以只需要维护一下 fhq 节点的大小和总和即可。

```cpp
#define int long long
#define maxn 500010
int n,k;
int a[maxn];
struct prpr{
	int l,r;
	int dat,siz,val,sm;
}tree[maxn];
mt19937 rnd(time(NULL));
int tot,rt;
inline int Build(int val){
	tree[++tot].siz=1;
	tree[tot].dat=rnd();
	tree[tot].val=val;
	tree[tot].sm=val;
	return tot;
}
inline void Pushup(int x){
	tree[x].siz=tree[tree[x].l].siz+1+tree[tree[x].r].siz;
	tree[x].sm=tree[tree[x].l].sm+tree[x].val+tree[tree[x].r].sm;
}
inline void Split(int rt,int k,int &x,int &y){
	if(!rt)x=y=0;
	else{
		if(tree[rt].val<=k)x=rt,Split(tree[rt].r,k,tree[rt].r,y);
		else y=rt,Split(tree[rt].l,k,x,tree[rt].l);
		Pushup(rt);
	}
}
inline int Merge(int x,int y){
	if(!x||!y)return x+y;
	if(tree[x].dat>tree[y].dat){
		tree[x].r=Merge(tree[x].r,y);
		Pushup(x);return x;
	}else{
		tree[y].l=Merge(x,tree[y].l);
		Pushup(y);return y;
	}
}
inline void ins(int val){
	int x,y;
	Split(rt,val,x,y);
	rt=Merge(Merge(x,Build(val)),y);
}
inline void del(int val){
	int x,y,z;
	Split(rt,val,x,y);
	Split(x,val-1,x,z);
	z=Merge(tree[z].l,tree[z].r);
	rt=Merge(Merge(x,z),y);
}
inline int Kth(int x,int k){
	while(1){
		if(k<=tree[tree[x].l].siz)x=tree[x].l;
		else if(tree[tree[x].l].siz+1==k)return tree[x].val;
		else k-=tree[tree[x].l].siz+1,x=tree[x].r;
	}
}
inline int ask(int k){
	int x,y,z;
	Split(rt,k,x,z);
	Split(x,k-1,x,y);
	int tmp=tree[x].siz*k-tree[x].sm+tree[z].sm-tree[z].siz*k;
	rt=Merge(Merge(x,y),z);
	return tmp;
}
int uu,ans=LLONG_MAX;
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=0;i<k;i++)ins(a[i]);
	for(int i=k,mid;i<=n;i++){
		del(a[i-k]),ins(a[i]);
		mid=Kth(rt,(k>>1)+1);
		uu=ask(mid);
		ans=min(ans,uu);
	}
	cout<<ans;
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```
单走一个 [双倍经验](https://www.luogu.com.cn/problem/P3466)

---

## 作者：Dawn_Chase (赞：3)

## 没有题解？P党来一发。
首先我们需要理解题意。

“从墙上搬走一块砖，或是从旁边的魔力砖堆（假设可用的魔力砖无限）中拿一块砖放置在墙上”
### 这句话的意思就是：每堵墙高度可以+1或者-1。
我们通过观察可以发现:k个连续的魔力砖高度相等时，
### 一定是这k个魔力砖的高度的中位数所付出的能量值最小。
正确性？显而易见是对的~~，（我不会告诉你这是七年级数学题）~~

观察题目所给数据的大小，1,000,000,000,000，所以我们需要将这些魔力砖的高度离散化。

代码大致如下（来自P党的忧伤）：
```
  for i:=1 to n do
   begin
    read(a[i]);
    b[i]:=i;
   end;
  sort1(1,n);           //把a按从大到小排序
  for i:=1 to n do      //防止重复的数
   if a[i]<>a[i-1] then
    begin
     c[i]:=c[i-1]+1;
     ls[c[i]]:=a[i];    //ls[x]表示的是离散后是x的数的原来的数
    end
   else
    c[i]:=c[i-1];
  a:=c;
  sort2(1,n);           //再排回去。。。
```
~~蒟蒻的我打离散时挂了无数回~~

### 然后我们需要考虑怎样把中位数算出来
我们可以考虑建立一棵权值线段树，里面存储的是权值~~（废话）~~和**这个区间里的数的和**（下面会用到）

建立完之后，我们就可以把中位数搞出来了。

建树的代码：
```
procedure update(i,l,r,x,p:int64);
var mid:int64;
begin
  t[i].s:=t[i].s+p;            //这个区间的权值
  t[i].ans:=t[i].ans+ls[x]*p;  //这个区间里的数的和
  if l=r then
   exit;
  mid:=(l+r) div 2;
  if mid>=x then
   update(i*2,l,mid,x,p)
  else
   update(i*2+1,mid+1,r,x,p);
end;
```
这里的p表示是插入还是删除，如果p=1，就是插入，如果p=-1，就是删除。~~（我太懒了）~~

查找中位数的代码：
```
function findnum(i,l,r,x:int64):int64;
var ans,mid:int64;
begin
  if i=0 then
   exit(0);
  if l=r then
   exit(l);
  mid:=(l+r) div 2;
  if t[i*2].s>=x then        //如果中位数的位置小于左子树的权值，就递归左子树。否则递归右子树
   ans:=findnum(i*2,l,mid,x)
  else
   ans:=findnum(i*2+1,mid+1,r,x-t[i*2].s);
  exit(ans);
end;
```
~~跟普通平衡树的查数有异曲同工之妙~~
### 那我们怎么统计答案呢？
~~（七年级数学题又来了）~~我们设midd=(k+1)>>1~~（我太懒了）~~显而易见，大于中位数的数有k-midd个。**那么大于中位数的数所需要的能量值为大于中位数的所有数的和-中位数*（k-midd）**

同理可得，**小于等于中位数的数所需要的能量值为中位数*（midd）-小于等于中位数的所有数的和**

所以，最终的能量值就是**大于中位数的数所需要的能量值+小于等于中位数的数所需要的能量值**

算能量值的代码：
```
  ans:=20000000000000000;
  midd:=(k+1) div 2;
  for i:=k to n do
   begin
    update(1,1,maxh,a[i],1);      //插入
    mid:=findnum(1,1,maxh,midd);  //中位数
    big:=getbig(1,1,maxh,mid);    //大于中位数的数的和
    small:=getsmall(1,1,maxh,mid); //小于中位数的数的和
    s:=big+ls[mid]*midd-ls[mid]*(k-midd)-small; //最终能量值
    if s<ans then //更新答案
     ans:=s;
    update(1,1,maxh,a[i-k+1],-1); //删除
   end;
  writeln(ans);
```
其中，getbig和getsmall的含义就是注释里写的。

代码如下：
```
function getsmall(i,l,r,x:int64):int64; //小于中位数的数的和
var mid:int64;
begin
  if r<=x then
   exit(t[i].ans);
  if l>x then
   exit(0);
  mid:=(l+r) div 2;
  getsmall:=getsmall(i*2,l,mid,x)+getsmall(i*2+1,mid+1,r,x);
end;
function getbig(i,l,r,x:int64):int64; //大于中位数的数的和
var mid:int64;
begin
  if l>x then
   exit(t[i].ans);
  if r<=x then
   exit(0);
  mid:=(l+r) div 2;
  getbig:=getbig(i*2,l,mid,x)+getbig(i*2+1,mid+1,r,x);
end;
```
至此，我们就已经得出正确答案了。
完整代码（码风巨丑）：
```
type node=record
      s,ans:int64;
     end;
var s,n,k,ans,maxh,mid,midd,big,small:int64;
    i:longint;
    a,b,c,ls:array[0..4000001] of int64;
    t:array[0..4000001] of node;
procedure sort1(l,r:int64);
var i,j,x,y:int64;
begin
  i:=l;j:=r;x:=a[(l+r) div 2];
  repeat
   while a[i]<x do
    inc(i);
   while x<a[j] do
    dec(j);
   if not(i>j) then
    begin
     y:=a[i];a[i]:=a[j];a[j]:=y;
     y:=b[i];b[i]:=b[j];b[j]:=y;
     inc(i);j:=j-1;
    end;
  until i>j;
  if l<j then
   sort1(l,j);
  if i<r then
   sort1(i,r);
end;
procedure sort2(l,r:longint);
var i,j,x,y:longint;
begin
  i:=l;j:=r;x:=b[(l+r) div 2];
  repeat
   while b[i]<x do
    inc(i);
   while x<b[j] do
    dec(j);
   if not(i>j) then
    begin
     y:=a[i];a[i]:=a[j];a[j]:=y;
     y:=b[i];b[i]:=b[j];b[j]:=y;
     inc(i);j:=j-1;
    end;
  until i>j;
  if l<j then
   sort2(l,j);
  if i<r then
   sort2(i,r);
end;
procedure update(i,l,r,x,p:int64);
var mid:int64;
begin
  t[i].s:=t[i].s+p;
  t[i].ans:=t[i].ans+ls[x]*p;
  if l=r then
   exit;
  mid:=(l+r) div 2;
  if mid>=x then
   update(i*2,l,mid,x,p)
  else
   update(i*2+1,mid+1,r,x,p);
end;
function findnum(i,l,r,x:int64):int64;
var ans,mid:int64;
begin
  if i=0 then
   exit(0);
  if l=r then
   exit(l);
  mid:=(l+r) div 2;
  if t[i*2].s>=x then
   ans:=findnum(i*2,l,mid,x)
  else
   ans:=findnum(i*2+1,mid+1,r,x-t[i*2].s);
  exit(ans);
end;
function getsmall(i,l,r,x:int64):int64;
var mid:int64;
begin
  if r<=x then
   exit(t[i].ans);
  if l>x then
   exit(0);
  mid:=(l+r) div 2;
  getsmall:=getsmall(i*2,l,mid,x)+getsmall(i*2+1,mid+1,r,x);
end;
function getbig(i,l,r,x:int64):int64;
var mid:int64;
begin
  if l>x then
   exit(t[i].ans);
  if r<=x then
   exit(0);
  mid:=(l+r) div 2;
  getbig:=getbig(i*2,l,mid,x)+getbig(i*2+1,mid+1,r,x);
end;
begin
  read(n,k);
  for i:=1 to n do
   begin
    read(a[i]);
    b[i]:=i;
   end;
  sort1(1,n);
  for i:=1 to n do
   if a[i]<>a[i-1] then
    begin
     c[i]:=c[i-1]+1;
     ls[c[i]]:=a[i];
    end
   else
    c[i]:=c[i-1];
  a:=c;
  sort2(1,n);
  maxh:=500000;
  for i:=1 to k-1 do
   update(1,1,maxh,a[i],1);
  ans:=20000000000000000;
  midd:=(k+1) div 2;
  for i:=k to n do
   begin
    update(1,1,maxh,a[i],1);
    mid:=findnum(1,1,maxh,midd);
    big:=getbig(1,1,maxh,mid);small:=getsmall(1,1,maxh,mid);
    s:=big+ls[mid]*midd-ls[mid]*(k-midd)-small;
    if s<ans then
     ans:=s;
    update(1,1,maxh,a[i-k+1],-1);
   end;
  writeln(ans);
end.
```
注释就不打了，上面很详细了~~（其实是我太懒了）~~
最后鸣谢[大佬](https://www.luogu.org/space/show?uid=29575)的启发

---

## 作者：jr_linys (赞：2)

[**题目链接**](https://www.luogu.com.cn/problem/P2263)

[双倍经验](https://www.luogu.com.cn/problem/P3466)

本题解给出树状数组的 $O(n \log n)$ 的做法，且树状数组有优秀的常数。

关键在于查找第 $m=\lceil \frac{k}{2} \rceil$ 个数。

## $O(n\log V \log k)$
二分第 $m$ 大的数字，使用树状数组计算 $[0,x]$ 中的数字个数与 $m$ 比较。

## $O(n \log V)$

在权值线段树上查找第 $m$ 大可以对每个节点记录此区间的数字个数，然后决定往哪走。

在树状数组上查找第 $m$ 大可以用类似的方法，基于树状数组的结构，我们可以倍增地跳。

以下代码实现了查找第 $m$ 大，$sp_i$ 是 $(i-\operatorname{lowbit}(i),i]$ 中的数字个数，$M$ 是值域。

```cpp
	int m=(k+1)>>1,s=0;p=0;
	for(int l=1<<(log2(M)-1);l;l>>=1){
		if(p+l<=M&&s+sp[p+l]<m) p+=l,s+=sp[p];
	}++p;
```

## $O(n \log n)$
由于 $0\le H_i \le 1,000,000,000,000$，直接树状数组会爆。再加个离散化，时间复杂度变成了 $O(n \log n)$。

目前第 $2$ 优（$n$ 太大跑不过对顶堆...）。

**[记录](https://www.luogu.com.cn/record/120405079)**

### CODE
```cpp
#include<bits/stdc++.h>
typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
inline ull read(){
	char c;
	while(c=getchar(),c<'0'||c>'9');
	ull x=c^'0';
	while(c=getchar(),c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^'0');
	return x;
}
const uint N=500000;
struct stu{
	ull s;uint id;
	bool operator<(stu b)const{return s<b.s;}
}b[N+5];
uint n,m,k,a[N+5],sp[N+5];
ull c[N+5],sum[N+5],z,anss;
inline void add(uint x){
	ull d=c[x];z+=d,x=a[x];
	for(;x<=n;x+=x&-x) ++sp[x],sum[x]+=d;
}
inline void reduce(uint x){
	ull d=c[x];z-=d,x=a[x];
	for(;x<=n;x+=x&-x) --sp[x],sum[x]-=d;
}
inline ull com(){
	uint p=0;
	for(register uint l=262144,s=0;l;l>>=1){
		if(p+l<=n&&s+sp[p+l]<m) p+=l,s+=sp[p];
	}
	++p;
	ull ss=0;
	for(ull x=p;x;x-=x&-x) ss+=sum[x];
	return m*b[p].s+(z-ss)-ss-(k-m)*b[p].s;
}

int main(){
	n=read(),k=read(),m=k+1>>1;
	for(register uint i=1;i<=n;++i) c[i]=read(),b[i]={c[i],i};
	sort(b+1,b+1+n);
	for(register uint i=1;i<=n;++i) a[b[i].id]=i;
	
	for(register uint i=1;i<=k;++i) add(i);
	anss=com();
	for(register uint i=k+1;i<=n;++i){
		add(i),reduce(i-k);
		anss=min(anss,com());
	}
	printf("%llu\n",anss);
}
```

---

## 作者：HYdroKomide (赞：2)

我 STL 面前，一切数据结构都是渣渣！

[双倍经验](https://www.luogu.com.cn/problem/P3466)

### 题意：
一个长度为 $n$ 的数组，每次操作能给任意一个数 $+1$ 或者 $-1$，问最少多少次操作能产生一个长度为 $k$ 的相等数字区间。

### 思路：

楼上题解已经证出（而且也是显而易见的），将一个区间全部转化为这个区间的中位数所消耗的步数最少。

于是大体思路出来了：用一个东西维护滚动区间的中位数。

在维护的同时，自然就能找到小于中位数的所有数——我们设这些数的和为 $suml$，和大于中位数的所有数——我们设这些数的和为 $sumr$。

所以需要的步数就是所有数对中位数的差之和，也就是 $mid\times |l|-suml + sumr-mid\times |r|$。

STL 中的 multiset 容器能自带排序，可以很好的维护以上那些东西。

我们开两个 multiset $l$ 和 $r$，$l$ 维护中位数**及**比它小的数，$r$ 维护大于中位数的数。那么很显然中位数就是$l$ 的最大值。通过以上公式即可求解步数。

对于修改，multiset 自带的 `find()` 功能可以查找需要删除的数，并使用 `erase()` 进行删除。我们将出列的元素在两个 multiset 中都查找一遍，然后弹出一个。

插入元素时，将需要加入的变量与中位数进行比对，以此确定插入到的位置。

特别地，这一套下来两个 multiset 的元素个数可能被打乱（即不再对半分了）。由于我们需要保证 $l$ 的最后一个元素是中位数他自己，所以当 $|l|$ 超过 $|r|+2$，我们需要将 $l$ 的队尾删除并插入到 $r$ 中，反之同理。

最后，必须全部开 long long。
### 程序如下：
```cpp
#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
const int N=5e5+1;
long long n,k,a[N],tmp[N],ans=1e19,suml,sumr;
multiset<long long>l,r;
namespace FASTIO{
	inline long long read(){
	    register long long x=0,f=1;
		static char ch=getchar();
	    while(ch>'9'||ch<'0'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
	    while(ch>='0'&&ch<='9'){
			x=(x<<3)+(x<<1)+(ch^48);
			ch=getchar();
		}
	    return x*f;
	}
	inline void write(long long x){
	    if(x<0)putchar('-'),x=-x;
	    register int i=0;
	    static char s[20];
	    while(x||i==0)s[i++]=x%10+'0',x/=10;
	    while(i--)putchar(s[i]);
	    putchar('\n');
	}
}
using namespace FASTIO;
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=k;i++)tmp[i]=a[i];
	sort(tmp+1,tmp+k+1);
	for(int i=1;i<=(k-1)/2+1;i++)l.insert(tmp[i]),suml+=tmp[i];
	for(int i=(k-1)/2+2;i<=k;i++)r.insert(tmp[i]),sumr+=tmp[i];
	for(int i=1;i+k-1<=n;i++){
		multiset<long long>::iterator it=l.end();
		long long mid=*(--it),sum=mid*l.size()-suml+sumr-mid*r.size();
		if(sum<ans)ans=sum;
		if(a[i+k]<=mid)l.insert(a[i+k]),suml+=a[i+k];
		else r.insert(a[i+k]),sumr+=a[i+k];
		if(l.count(a[i])!=0)l.erase(l.find(a[i])),suml-=a[i];
		else r.erase(r.find(a[i])),sumr-=a[i];
		int ls=l.size(),rs=r.size();
		if(ls>rs+1){
			it=l.end();
			long long lar=*(--it);
			l.erase(it);
			r.insert(lar);
			suml-=lar;
			sumr+=lar;
		}
		if(ls<rs){
			it=r.begin();
			long long lar=*it;
			r.erase(it);
			l.insert(lar);
			sumr-=lar;
			suml+=lar;
		}
	}
	write(ans);
	return 0;
}
```
### THE END

---

## 作者：Kaenbyou_Rin (赞：2)

好像题解区还没有这种写法？


------------


这题珂以用**权值线段树**做

数学课上学过，对一段数,到他们的中位数的代价最小。

所以，我们维护中位数即可。


------------
这里使用权值线段树维护中位数。

众所周知，当 k 为偶数时，中位数为中间两个数的平均值，当 $k$ 为奇数时，中位数为当前大小为 $k/2+1$ 的数。

考虑建一棵线段树维护一个区间 $[l,r]$ 中数的个数。

再考虑移动区间对中位数的影响即可。


### Code:
```
#include<bits/stdc++.h>
#define ll long long
//记得开long long
using namespace std;
const int N=5e6+10;
inline ll read(){
    ll x=0,w=1;
    char ch=getchar();
    for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return x*w;
}
ll a[N],c[N],dui[N];
struct tree{
	ll l,r,sum;//sum存的是一个区间内数的个数
}t[N<<2];
ll cmp(ll x,ll y){
	return x<y;
}
ll far(ll x,ll y){
	return x>y?x-y:y-x;//与当前中位数的差的绝对值
}
void build(ll cur,ll l,ll r){//建树
	t[cur].l=l;t[cur].r=r;
	if(l==r) return;
	ll mid=(l+r)>>1;
	build(cur<<1,l,mid);
	build(cur<<1|1,mid+1,r);
}
void update(ll cur,ll id,ll x){//更改操作
	if(t[cur].l==t[cur].r&&t[cur].l==id){
		t[cur].sum+=x;
		return;
	}
	ll mid=(t[cur].l+t[cur].r)>>1;
	if(id<=mid) change(cur<<1,id,x);
	if(id>mid) change(cur<<1|1,id,x);
	t[cur].sum=t[cur<<1].sum+t[cur<<1|1].sum;
}
ll query(ll cur,ll x){//查询排名为x的数
	if(t[cur].l==t[cur].r) return t[cur].l;
	ll res;
	if(t[cur<<1].sum>=x) res=ask(cur<<1,x);//如果左区间的数的个数大于排名，说明在左区间
	else res=ask(cur<<1|1,x-t[cur<<1].sum);//如果在右区间要减去左区间的数的个数，想想为什么
	return res;
}
ll n,k,sum,ans,maxn;
int main(){
	n=read(),k=read();
	for(ll i=1;i<=n;i++) a[i]=c[i]=read();
	sort(c+1,c+1+n,cmp);
	ll un=unique(c+1,c+1+n)-c-1;
	for(ll i=1,tp;i<=n;i++){//由于本题答案与数的值有关，故离散化时要增加一个数组纪录原数
		tp=a[i];
		a[i]=lower_bound(c+1,c+un+1,a[i])-c;
		dui[a[i]]=tp;
		maxn=max(a[i],maxn);
	}
//	for(ll i=1;i<=n;i++){
//		printf("%lld\n",dui[a[i]]);
//	}
	build(1,0,maxn);
	for(ll i=1;i<=k;i++) update(1,a[i],1);//可以理解为元素进队
	ll m=query(1,k/2+1);//查询中位数
	for(ll i=1;i<=k;i++) sum+=far(dui[a[i]],dui[m]);
	ans=sum;
//	printf("%lld\n",sum);
	for(ll i=2,j=1+k;j<=n;i++,j++){
		update(1,a[i-1],-1);update(1,a[j],1);//出树，进树
		ll p=query(1,k/2+1);
		if(k&1) sum-=(far(dui[a[i-1]],dui[m])-far(dui[a[j]],dui[p]));
		else {
			if(p<=m) sum-=(far(dui[a[i-1]],dui[p])-far(dui[a[j]],dui[p]));
		    else sum-=(far(dui[a[i-1]],dui[m])-far(dui[a[j]],dui[m]));//动态维护，看不懂手动模拟一下即可
            //不能直接用，要传回原来的值（就是dui数组）
		}
		m=p;
//		printf("%lld\n",sum);
		if(ans>sum) ans=sum;//更新答案
	}
	printf("%lld\n",ans);
	return 0;
}
```

[双倍经验](https://www.luogu.com.cn/problem/P3466)

---

## 作者：lun_hao (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2263)

[双倍经验](https://www.luogu.com.cn/problem/P3466)

写在前面：
- 本文使用了 FHQ_Treap 求解，若读者还不会 FHQ_Treap 可自行前往 [OI Wiki 无旋 treap](https://oi-wiki.org/ds/treap/#%E6%97%A0%E6%97%8B-treap) 学习或者跳过代码部分。
- 下文记 $n,n-k+1$ 同阶为 $n$。
### 题目大意：
给定一个长度为 $n$ 的序列，每次可以将其中一个数 $+1$ 或者 $-1$，求最小的次数使得该序列上最少有连续 $k$ 个相同的数。

数据范围：$1\leq n \leq 5 \times 10^5,2 \leq k \leq n, 0 \leq H_i \leq 10^{12}$。

### 题目分析：
先考虑一个长度为 $k$ 的序列将所有数变成相同的最小次数。

不难发现，变成该序列的中位数的次数最小。

证明如下：

假设序列长为 $2n+1$，将序列从小到大排好，那么中位数为 $mid=H_{n+1}$，比中位数小的数有 $n$ 个，比中位数大的数也有 $n$ 个，不妨设：
$$sumL=\sum_{i=1}^{n} (mid-H_i),\\sumR=\sum_{n+2}^{2n+1} (H_i-mid)$$
那么如果将整个序列变成 $mid$，其代价为 $ans_0=sumL+sumR$。

如果将整个序列变成不是 $mid$ 的数，例如 $mid-1$，其代价为
$$\begin{aligned}
ans_x&=(sumL-n)+(sumR+n)+1\\
&=sumL+sumR+1\\
&>sumL+sumR=ans_0\\
\end{aligned}$$
，其余同理，都能证明 $ans_x>ans_0$。

所以，当变成整个序列的中位数的时候，次数最小。

同理可得，当序列长为 $2n$ 时，将序列从小到大排好，那么中位数为 $mid=(H_n+H_{n+1})/2$，证明与序列长为 $2n+1$ 的证明相似，可以得出相同的结论。

再回到题目，显然是要在长度为 $n$ 的序列中枚举每一个长度为 $k$ 的区间求出对应的最小次数 $res_i=\sum_{j=i}^{i+k-1} |H_j-mid_i|$，那么最终的答案为 $ans=\min_{i=1}^{n-k+1} res_i$，瓶颈在于如何**快速求动态区间的中位数（动态 kth）**。

想到这里，可以感觉到有点与平衡树沾上边了，我们可以先把区间 $[L_1,R_1]$ 预处理放在平衡树上，每次求区间 $[L_i,R_i]$ 的答案时，只需要删除 $H_{L_{i-1}}$ 以及增加 $H_{R_{i}}$ 即可，这里选用了 FHQ_Treap **按权值分裂**求解。

每一次将平衡树分裂成三部分：$[L,mid-1],(mid-1,mid],(mid,R]$，此时 $siz_L$ 就是小于中位数的个数，$siz_R$ 就是大于中位数的个数，那么
$$res=siz_L \times mid - sum_L + sum_R - siz_R \times mid$$

其余与 FHQ_Treap 模板一致，注意本题数据会超 `int`，记得开 `long long`。

（不过真的不建议跟我一样懒打了 `#define int long long`）

时间复杂度：$O(n \log n)$，由于 FHQ_Treap 自带较大常数所以跑得有点慢了。

Tip：本代码不开 O2 似乎是跑不过去的（TLE 90pts），建议优化常数或者开 O2。
### Code：
```cpp
#include<bits/stdc++.h>
#define int long long//记得开 long long !!!
#define ls(u) t[u].ls
#define rs(u) t[u].rs
using namespace std;
const int N=5e5+5;
const int INF=1e18;
int n,k,root,cnt;
int a[N],ans=INF;//初始值赋一个较大值
struct FHQ_Treap
{
	int ls,rs;
	int val,sum;
	int pri,siz;
}t[N];
void update(int u)
{
	t[u].siz=t[ls(u)].siz+t[rs(u)].siz+1;
	t[u].sum=t[ls(u)].sum+t[rs(u)].sum+t[u].val;
}
int newNode(int x)
{
	int u=++cnt;
	t[u].ls=t[u].rs=0;
	t[u].val=t[u].sum=x;
	t[u].pri=rand();
	t[u].siz=1;
	return u;
}
void split(int u,int x,int &L,int &R)
{
	if(!u)
	{
		L=R=0;
		return;
	}
	if(t[u].val<=x)//按权值分裂
	{
		L=u;
		split(rs(u),x,rs(u),R);
	}
	else
	{
		R=u;
		split(ls(u),x,L,ls(u));
	}
	update(u);
}
int merge(int L,int R)
{
	if(!L||!R) return L|R;
	if(t[L].pri>t[R].pri)
	{
		t[L].rs=merge(t[L].rs,R);
		update(L);
		return L;
	}
	else
	{
		t[R].ls=merge(L,t[R].ls);
		update(R);
		return R;
	}
}
void insert(int x)//插入
{
	int L,R;
	split(root,x,L,R);
	root=merge(merge(L,newNode(x)),R);
}
void del(int x)//删除
{
	int L,R,p;
	split(root,x,L,R);
	split(L,x-1,L,p);//分成 [L,mid-1],(mid-1,mid],(mid,R]三部分
	p=merge(t[p].ls,t[p].rs);//只删除等于 x 的一个数
	root=merge(merge(L,p),R);
}
int kth(int u,int k)//求排名为 k 的值在平衡树上的位置
{
	if(k==t[ls(u)].siz+1) return u;
	if(k<=t[ls(u)].siz) return kth(ls(u),k);
	if(k>t[ls(u)].siz) return kth(rs(u),k-t[ls(u)].siz-1);
}
int query(int x)
{
	int L,R,p;
	split(root,x,L,R);
	split(L,x-1,L,p);
	int ans=t[L].siz*x-t[L].sum+t[R].sum-t[R].siz*x;//详细证明在上面已提到
	root=merge(merge(L,p),R);
	return ans;
}
signed main()
{
	srand(time(0));
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)	
		scanf("%lld",&a[i]);
	for(int i=0;i<k;i++)//预处理将 [0,k) 插入平衡树
		insert(a[i]);
	for(int i=k;i<=n;i++)
	{
		int mid;
		del(a[i-k]),insert(a[i]);//区间 [L,R]
       //分类讨论
		if(k&1) mid=t[kth(root,k/2+1)].val;//若 k 为奇数，mid=a[k/2+1]
			else mid=(t[kth(root,k/2)].val+t[kth(root,k/2+1)].val)/2;//若 k 为偶数，mid=(a[k/2]+a[k/2+1])/2
		int res=query(mid);
		if(res<ans)
			ans=res;
	}
	printf("%lld\n",ans);
	return 0;
}
```
写在后面：

update 24/8/13：修改了部分 $\LaTeX$ 公式，~~让其排版更加舒服（bushi）~~。

---

## 作者：封禁用户 (赞：1)

### 题面
给一个长 $n$ 的序列 ${a}$，你要选长 $K$ 的子段，使得把他们变成一样高度的代价最小。

定义代价为：对一个数，你可以花费 $1$ 的代价使他加或减 $1$。

### 思路
假设我们选了一段 $a_l$ 到 $a_r$，我们肯定要将他们变成中位数的高度。

#### 小证明：
设一段排好序的数列中中位数 $a_{mid}$ 有：

$$\sum_{i=l}^{r}|a_i-a_{mid}|$$

如果我们把它变成 $a_{mid+1}$ 得 ：

$$\sum_{i=l}^{r}|a_i-a_{mid+1}|$$

这时 $mid+1$ 个数会变大 $|a_{mid+1}-a_{mid}|$，$n-mid-1$ 个数会减小 $|a_{mid+1}-a_{mid}|$，显然答案变大。

#### 所以说
我们要维护的其实是一段数的中位数，于是 FHQ-Treap 闪亮登场。在枚举的时候计算答案，取个最小值，完了。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 500005 
using namespace std;
int val[Maxn],prio[Maxn],sum[Maxn],lson[Maxn],rson[Maxn],sz[Maxn],tot,root;
int NewNote(int k) {
    val[++tot]=k;
    sz[tot]=1;
    sum[tot]=k;
    prio[tot]=rand();
    return tot;
}
void pushup(int x) {
    sz[x]=sz[lson[x]]+sz[rson[x]]+1;
    sum[x]=sum[lson[x]]+sum[rson[x]]+val[x];
}
void split(int now,int bound,int &x,int &y) {
    if(!now)return x=y=0,void();
    if(val[now]<=bound) {
        x=now;
        split(rson[now],bound,rson[now],y);
    } else {
        y=now;
        split(lson[now],bound,x,lson[now]);
    } pushup(now);
}
int merge(int x,int y) {
    if(!x||!y)return x+y;
    if(prio[x]<prio[y]) {
        rson[x]=merge(rson[x],y);
        pushup(x);
        return x;
    } else {
        lson[y]=merge(x,lson[y]);
        pushup(y);
        return y;
    }
}
void Insert(int k) {
    int x,y=NewNote(k),z;
    split(root,k,x,z);
    root=merge(x,merge(y,z));
}
void Delete(int k) {
    int x,y,z;
    split(root,k,y,z);
    split(y,k-1,x,y);
    y=merge(lson[y],rson[y]);
    root=merge(x,merge(y,z));
}
int Middle() {
    int cur=root,siz=sz[root]/2+1,fa;
    while(siz) {
        if(siz>sz[lson[cur]])
            siz-=sz[lson[cur]]+1,
            fa=cur,cur=rson[cur];
        else fa=cur,cur=lson[cur];
    } return fa;
}
int solve() {
    int x,y,z,k=Middle();
    // cout<<k<<" ";
    split(root,val[k],x,y);
    int g0=sum[x],g1=sum[y];
    int sz0=sz[x],sz1=sz[y];
    int opt=sz0*val[k]-g0+g1-sz1*val[k];
    root=merge(x,y);
    return opt;
}
int a[Maxn];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    srand(time(0));
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=k;i++) {
        cin>>a[i];
        Insert(a[i]);
    } int ans=LONG_LONG_MAX;
    for(int i=k+1;i<=n;i++) {
        cin>>a[i];
        ans=min(ans,solve());
        // cout<<solve()<<" ";
        Delete(a[i-k]);
        Insert(a[i]);
    } cout<<min(ans,solve());
    return 0;
}
```

---

## 作者：Inter12 (赞：0)

## 题意：

> 给定一个 $N$ 个数的数列，给定两个操作：
> 1. 从中选一个数，使这个数 $+1$；
> 2. 从中选一个数，使这个数 $-1$。\
> 问：最少需要几次操作，使这个数列至少有 $K$ 个连续的数字相等。\
> 数据范围：$1 \le N \le 5 \times 10^5, 2 \le K \le N, 0 \le H_i \le10^{12}$

## 分析：

要求至少有 $K$ 个连续的数字相等，首先就可以想到，枚举数列，找到一段区间，让他们相等。

相等就必定要找一个数值，使得他们都会等于这一个数值。

不难猜到，找中位数。

### 证明：

设中位数为 $med$，有 $a$ 个数字，比 $med$ 大的数字有 $a$ 个，总和为 $Big$，比 $med$ 小的数字有 $b$ 个，总和为 $Small$：

那么可以列出算式（其中 $S$ 为操作数）：

$$S = (Big - med \times a) + (med \times b - Small)$$

因为**中位数的性质**：$a - b = 0 \lor 1$

所以可以保证在所有数中 $|med \times a - med \times b| \le med$，差值最小。

如果改成 $med + 1$，则有：

$$S' = (Big - med \times a - med \times b) + (med \times b + med \times a - Small) + 1$$（$+1$ 指 $med$ 要多贡献）

差值为：$S = S' - med \times a + med \times b - 1, S \le S'$

同理，当改成 $med - 1$ 时，关系式为 $S = S' - med \times b + med \times a - 1$，仍满足 $S \le S'$。

所以 $S \le S'$ 恒成立。

不同的是，与其他题解不同的是，当序列长 $2n$ 时，可以是**两中位数中任意一数**（对答案没有影响）。


证毕。

### 算法分析：

> 分析数据范围 $N \le 5 \times 10^5$ 可得时间复杂度大概率是 $O(N \times Log N)$；\
> \
> 序列是不规则的，且求值需要严格遵从原序列，因此必将付出一个枚举的时间复杂度 $O(N)$；\
> \
> 枚举 $[i, i + K - 1]$ 过程中，不难发现，只要找出中位数（维护 $med$），再维护类似前缀和的数组（维护 $Big, Small$），就能找出 $a, b$，最后，求出 $\min\sum_{i = 1}^{n - K + 1}ans = \sum_{j = i}^{i + K - 1}|H_j - med| = (Big - med \times a) + (med \times b - Small)$
。\
> \
> 问题聚焦于如何求 $med$，不难想出，子序列中的求值正好适合**将序列转成树。**\
> \
> 权值线段树和平衡树都很适合，这里讲一下平衡树（无旋 [Treap](https://oi.wiki/ds/treap/)）。\
> \
> 由于按 $size$ 劈的平衡树更适合于处理区间改变的问题，因而按 $val$ 劈。利用平衡树找第 $\lfloor\frac{K + 1}{2}\rfloor$ 大的数，即是中位数。\
> \
> 维护 $siz, sum$ 对应 $a, b$ 和 $Big, Small$，将平衡树分裂，得到 $a, b, Big, Small$，即可求得 $ans$。

### 提示：

1. 数据范围 $H_i \le 10^{12}$，开`long long`；

2. 无旋 Treap 的常数有点大，如果超时需卡常。

3. 小常识：无旋 Treap 但凡函数里面出现合并分裂时就要参数绑定，如`&cur`。

## 代码君

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5 + 5, mod = 0; 

int h[N], rot = 0, k, n, tot;

struct node
{
	int lc, rc, size, rnk, val, sum; // siz, sum 
}tree[2 * N];

void update(int cur)
{
	tree[cur].size = tree[tree[cur].lc].size + tree[tree[cur].rc].size + 1;
	tree[cur].sum = tree[tree[cur].lc].sum + tree[tree[cur].rc].sum + tree[cur].val;
}

void split(int k, int &a, int &b, int val)
{
	if(k == 0)
	{
		a = b = 0;
		return ;
	}
	if(tree[k].val <= val)
	{
		a = k;
		split(tree[k].rc, tree[k].rc, b, val);
	} else
	{
		b = k;
		split(tree[k].lc, a, tree[k].lc, val);
	}
	update(k);
	return ;
}

void Union(int &k, int a, int b)
{
	if(a == 0 || b == 0)
	{
		k = a + b;
		return ;
	}
	if(tree[a].rnk < tree[b].rnk)
	{
		k = a;
		Union(tree[a].rc, tree[a].rc, b);
	} else
	{
		k = b;
		Union(tree[b].lc, a, tree[b].lc);
	}
	update(k);
	return ;
}

int Add(int val)
{
	tree[++tot].size = 1;
	tree[tot].val = val;
	tree[tot].sum = val;
	tree[tot].lc = tree[tot].rc = 0;
	tree[tot].rnk = rand();
	return tot;
}

void insert(int &k, int val)
{
	int a = 0, b = 0, cur = Add(val);
	split(k, a, b, val);
	Union(a, a, cur);
	Union(k, a, b);
	return ;
}

int find_num(int k, int x) // 找第x大的数值 
{
	while(tree[tree[k].lc].size + 1 != x) // 当k本身的排名等于x时，循环停止
	{
		if(tree[tree[k].lc].size >= x) // 排名太大了，找左子树
			k = tree[k].lc;
		else // 反之亦然 
		{
			x -= tree[tree[k].lc].size + 1;
			k = tree[k].rc; 
		}
	} 
	return tree[k].val;
}

int query(int &k, int val)
{
	int a = 0, b = 0, z = 0;
	split(k, a, b, val - 1); // 分裂成[L, val - 1], [val, val], [val + 1, R]，方便处理Big, Small, a, b 
	split(b, b, z, val);
	int siz1 = tree[a].size, siz2 = tree[z].size;
	int sma = tree[a].sum, big = tree[z].sum;
	Union(b, b, z);
	Union(k, a, b);
	return (big - val * siz2) + (val * siz1 - sma);
}

void del(int &k, int val)	
{
	int a = 0, b = 0, z = 0;
	split(k, a, b, val);
	split(a, a, z, val - 1);
	Union(z, tree[z].lc, tree[z].rc);
	Union(a, a, z);
	Union(k, a, b);
	return ;
}

signed main()
{
	srand(time(0)); // 千万不要忘了 
	cin >> n >> k;
	int ans = 1e17, pos, num;
	for(int i = 1; i <= n; i++) cin >> h[i];
	for(int i = 1; i <= n; i++)
	{
		insert(rot, h[i]);
		if(i < k) continue;
		if(i > k) del(rot, h[i - k]); // 保证平衡树中的序列是[i, i + k - 1] 
		int med = find_num(rot, (k + 1) / 2); // 找中位数 
		int res = query(rot, med); // 求 Big, Small, a, b 
		if(ans > res)
			ans = res, pos = i, num = med;
	}
	cout << ans << '\n';
	return 0;
}
```
不足之处欢迎指出！

---

## 作者：xiao7_Mr_10_ (赞：0)

经典题。

首先发现原问题的答案等价于长度刚好为 $k$ 的区间的答案，这是显然的，因为区间长度越长答案越大。然后我们就是要维护每个区间 $[i,i+k-1]$ 里的答案。

问题可以转化为经典初中数学问题：给你若干个点，问选取哪个点才能让其他点到它的距离和最小。结论是选取中位数，证明显然。

因此，我们需要支持查询区间的中位数。由于区间长度固定，不妨用值域线段树维护每个数出现次数和数的总和，配合滑动窗口算法，这样即可轻松计入答案，时间复杂度 $O(n \log n)$，需要进行离散化。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5;
struct Point{
	int val,sum;
	Point operator+(const Point &x)const{
		return (Point){val+x.val,sum+x.sum};
	}
}c[N<<2];
int n,K,a[N],len,b[N];
void updata(int x){
	c[x]=c[x<<1]+c[x<<1|1];
}
void change(int x,int l,int r,int s,int k){
	if(l==r){
		c[x].val+=k,c[x].sum+=b[l]*k;
		return;
	}int mid=(l+r)>>1;
	if(s<=mid)change(x<<1,l,mid,s,k);
	else change(x<<1|1,mid+1,r,s,k);updata(x);
}
int query(int x,int l,int r,int k){
	if(l==r)return l;int mid=(l+r)>>1,siz=c[x<<1].val;
	if(k<=siz)return query(x<<1,l,mid,k);
	return query(x<<1|1,mid+1,r,k-siz);
}
Point query(int x,int l,int r,int s,int t){
	if(s>t)return (Point){0,0};
	if(l>=s&&r<=t)return c[x];int mid=(l+r)>>1;
	if(s>mid)return query(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return query(x<<1,l,mid,s,t);
		return query(x<<1,l,mid,s,t)+query(x<<1|1,mid+1,r,s,t);
	}
}int ans=1e18;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n >> K;
	for(int i = 1;i <= n;i++)cin >> a[i],b[i]=a[i];sort(b+1,b+1+n);
	len=unique(b+1,b+1+n)-b-1;
	for(int i = 1;i <= n;i++)a[i]=lower_bound(b+1,b+1+len,a[i])-b;
	for(int i = 1;i <= K;i++)change(1,1,len,a[i],1);
	for(int i = 1;i+K-1 <= n;i++){
		int id=query(1,1,len,K/2+1);Point ans1=query(1,1,len,1,id),ans2=query(1,1,len,id+1,len);
		ans=min(ans,b[id]*ans1.val-ans1.sum+ans2.sum-ans2.val*b[id]);
		id=query(1,1,len,K/2);ans1=query(1,1,len,1,id),ans2=query(1,1,len,id+1,len);
		ans=min(ans,b[id]*ans1.val-ans1.sum+ans2.sum-ans2.val*b[id]);
		if(i!=n-K+1)change(1,1,len,a[i],-1),change(1,1,len,a[i+K],1);//移动指针 
	}cout << ans;
	return 0;
}
//原答案等价刚好k个 
//[l,l+k-1]枚举i
//显然发现答案是i*cnt1-sum1+sum2-i*cnt2
//根据经典结论选中位数最优
//稍微使用可持久化线段树即可，但是由于区间固定，滑动窗口维护值域线段树即可 
```

---

## 作者：GETexas (赞：0)

这是一道对顶堆的题解。  
我在百度中搜洛谷对顶堆搜到了这道题的对顶堆题解，但是大佬的三目运算符码风让我看了很久。  
请先参考这位大佬的题解 [P2263](https://www.luogu.com.cn/article/83d3zx8l)，这篇题解是对大佬题解的解读。  
观察题意发现显然是将连续 $k$ 个数变为它们的中位数。
#### 什么是对顶堆？  
对顶堆是两个堆的组合，一个大根堆和一个小根堆，其中大根堆储存前 $k$ 小的数，小根堆储存前 $n-k$ 大的数。
#### 什么是可删堆？  
我们知道，优先队列只能删除堆顶元素，然而我们并不能删掉其他元素，有时甚至找不到要删的元素。这时怎么办呢？于是，可删除堆出场了。  
可删除堆的实现原理也比较简单。我们建一个临时堆，如果要删除哪个元素，就把哪个元素压入临时堆，然后待此元素和正常堆的堆顶元素相同时（即两个堆顶一样），就同时pop掉。
#### 具体做法  
##### 定义部分  
```cpp
priority_queue<int> q1,q3;
priority_queue<int,vector<int>,greater<int> > q2,q4;
int ans=1e17,a[N],n,k,siz1,siz2,sum1,sum2,rot;
```
$q1$ 是大根堆，$q3$ 是对于 $q1$ 的可删堆。$q2$ 是小根堆，$q4$ 是对于 $q2$ 的可删堆。$a$ 数组是读入的魔力砖的高度，$siz1$ 是大根堆的大小，$siz2$ 是小根堆的大小，$sum1$ 是大根堆值的和，$sum2$ 是小根堆值的和。
##### 读入部分  

```cpp
signed main(){
	n=in();k=in();
	for(int i=1;i<=n;i++){
		a[i]=in();
		//work()
	}
    return 0;
}
```
##### 删除部分  
由于是区间大小是 $k$，当右端点 $i$ 小于等于 $k$ 时，不需要删除区间的左端点。如果小根堆是空的，那需要左端点必然在大根堆里。如果大根堆不是空的，那么当左端点比大根堆顶小或等的话，左端点在大根堆里。
```cpp
if(i>k){
			if(!siz2||(siz1&&a[i-k]<=q1.top())){
				q3.push(a[i-k]);//将左端点加入q1的可删堆
				--siz1;
				sum1-=a[i-k];
			}
			else {//左端点在小根堆的情况
				q4.push(a[i-k]);
				--siz2;
				sum2-=a[i-k];
			}
		}
		while(!q3.empty()&&q1.top()==q3.top()){//删除操作
			q1.pop();
			q3.pop();
		}
		while(!q4.empty()&&q2.top()==q4.top()){
			q2.pop();
			q4.pop();
		}
```
##### 加入部分  
如果小根堆是空的，说明大根堆没有或刚填满，先加入大根堆，再后续调整。如果大根堆不是空的，那么当右边要加的端点比大根堆顶小或等的话，要加的端点加入大根堆。
```cpp
if(!siz2||(siz1&&a[i]<=q1.top())){
			++siz1;
			q1.push(a[i]);
			sum1+=a[i];
		}
		else {//要加的端点加入小根堆的情况
			++siz2;
			q2.push(a[i]);
			sum2+=a[i];
		}
```
##### 调整部分  
本题的目标是两个堆尽可能有相近的大小，这样就能求出中位数。
```cpp
if(siz1-siz2>=2) {
			--siz1;
			++siz2;
			sum1-=q1.top();
			sum2+=q1.top();
			q2.push(q1.top());
			q1.pop();
		}
		else if(siz2-siz1>=2){
			++siz1;
			--siz2;
			sum1+=q2.top();
			sum2-=q2.top();
			q1.push(q2.top());
			q2.pop();
		}
```
#####  比较部分  
现在已经有一段长度为 $k$ 的区间，并且这个区间的值已经分进了对顶堆。不妨设中位数为 $m$。  
那么当 $k$ 为偶数时，两个堆的大小是相等的，那么显而易见答案是两个对顶堆各自的元素和之差（很容易想出来）。  
当 $k$ 为奇数时，一个堆的大小比另一个堆多一，而由中位数与对顶堆的定义，这多出来的某个堆的堆顶就是中位数。相较于偶数的情况，这时两堆元素和的差值相较于偶数的情况多了或者少了 $m$，对应的增减即可。  
定义 $rot$ 为偏移量。
```cpp
if(i>=k){
			rot=0;
			if(siz1<siz2) rot-=q2.top();
			else if(siz1>siz2) rot+=q1.top();
			if(ans>sum2-sum1+rot) ans=sum2-sum1+rot;
		}
```
#### AC Code  
基于 [P2263](https://www.luogu.com.cn/article/83d3zx8l)，当然可以阅读大佬代码增强对压行代码的理解能力。  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
const int N=5e5+5;
inline int in()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void out(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
int ans=1e17,a[N],n,k,siz1,siz2,sum1,sum2,rot;
priority_queue<int> q1,q3;
priority_queue<int,vector<int>,greater<int> > q2,q4;
signed main(){
	n=in();k=in();
	for(int i=1;i<=n;i++){
		a[i]=in();
		if(i>k){
			if(!siz2||(siz1&&a[i-k]<=q1.top())){
				q3.push(a[i-k]);
				--siz1;
				sum1-=a[i-k];
			}
			else {
				q4.push(a[i-k]);
				--siz2;
				sum2-=a[i-k];
			}
		}
		while(!q3.empty()&&q1.top()==q3.top()){
			q1.pop();
			q3.pop();
		}
		while(!q4.empty()&&q2.top()==q4.top()){
			q2.pop();
			q4.pop();
		}
		if(!siz2||(siz1&&a[i]<=q1.top())){
			++siz1;
			q1.push(a[i]);
			sum1+=a[i];
		}
		else {
			++siz2;
			q2.push(a[i]);
			sum2+=a[i];
		}
		if(siz1-siz2>=2) {
			--siz1;
			++siz2;
			sum1-=q1.top();
			sum2+=q1.top();
			q2.push(q1.top());
			q1.pop();
		}
		else if(siz2-siz1>=2){
			++siz1;
			--siz2;
			sum1+=q2.top();
			sum2-=q2.top();
			q1.push(q2.top());
			q2.pop();
		}
		if(i>=k){
			rot=0;
			if(siz1<siz2) rot-=q2.top();
			else if(siz1>siz2) rot+=q1.top();
			if(ans>sum2-sum1+rot) ans=sum2-sum1+rot;
		}
	}
	out(ans);
    return 0;
}

```

---

## 作者：RAND_MAX (赞：0)

题意很明确，这里不再赘述。

很难不发现把一个区间全部变为一个数的最小花费就是将整个区间变为这个区间的中位数。证明是容易的，也可参考其他题解。

考虑对于一个区间，将其变为中位数的花费。我们设区间中位数为 $mid$，$x_1,y_1$ 分别是区间中**小于、大于**中位数的数的个数，$x_2,y_2$ 分别是区间中**小于、大于**中位数的数的和。那么花费即为 $(x_1\times mid-x_2)+(y_2-y_1\times mid)$。对于 $x_1,y_1,x_2,y_2$，我们可以用树状数组在 $O(\log n)$ 的时间内求出。对于 $mid$，我们考虑二分，根据中位数的性质，区间内有 $\left\lfloor\frac{k+1}{2}\right\rfloor$ 个数小于等于 $mid$，我们可以利用树状数组来 check。总时间复杂度 $O(n\log^2n)$。

由于本题 $H_i$ 较大，树状数组无法存储，所以还需离散化。


```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f3f3f
#define lb x&(-x)
#define R read()
#define maxn 2000001
using namespace std;
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-')
		{
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-48;
		c=getchar();
	}
	return x*f;
}
void write(int x)
{
	static int st[35],top=0;
	if(x<0)
	{
		x=-x;
		putchar('-');
	}
	do
	{
		st[top++]=x%10;
		x/=10;
	}while(x);
	while(top)
	{
		putchar(st[--top]+48);
	}
	putchar('\n');
}
int n,k,a[500010],b[500010],p[500010],ans=inf,ln; 
int s[2000010][2];//0:sum 1:num
void add(int x,int y,int z)
{
	x++;
	while(x<=maxn)
	{
		s[x][0]+=y,s[x][1]+=z;
		x+=lb;
	}
}
int que(int x,int y)
{
	x++;
	int su=0;
	while(x)
	{
		su+=s[x][y];
		x-=lb;
	}
	return su;
}
int solve()
{
	int l=1,r=ln,mid,anss=inf,sum,m,kkk;
	while(l<=r)
	{
		mid=l+r>>1;
		if(que(mid,1)<(k+1>>1)) l=mid+1;
		else anss=mid,r=mid-1,kkk=que(mid,1); 
	}
	m=b[anss],sum=que(anss-1,1)*m-que(anss-1,0)+(-m*(que(maxn,1)-que(anss,1))+que(maxn,0)-que(anss,0));
	return sum;
}
signed main()
{
	n=R,k=R;
	for(int i=1;i<=n;i++)
	{
		a[i]=b[i]=R;
	}
	sort(b+1,b+n+1);
	ln=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)
	{
		p[i]=lower_bound(b+1,b+ln+1,a[i])-b;
	}
	for(int i=1;i<=k;i++)
	{
		add(p[i],a[i],1);
	}
	ans=solve();
	for(int i=k+1;i<=n;i++)
	{
		add(p[i],a[i],1);
		add(p[i-k],-a[i-k],-1);
		ans=min(ans,solve());
	}
	write(ans);
 	return 0;
}

```

---

## 作者：Patronus (赞：0)

发现本题还没有用 Splay 写的题解，就让我来补一篇吧。

- [题目传送门](https://www.luogu.com.cn/problem/P2263)

[双倍经验](https://www.luogu.com.cn/problem/P3466)

如果还不会 Splay 的请看这两篇学习资料。

1. [非指针](https://oi-wiki.org/ds/splay/)

1. [Splay 详细介绍](https://www.cnblogs.com/five20/p/8312575.html)

题目大意：给定 $n$ 和 $k$，以及长度为 $n$ 的序列 $h$，设最后更改的数为 $x$，则代价为 $\sum_{i=1}^k |h_i-x|$，求代价的最小值。

可以发现，若要使代价最小化，则 $x$ 应取长度为 $k$ 的这个区间的最小中位数。于是我们就可以把每个区间的代价求出来，取最小值即为最终答案。

在实现时我们可以发现，从 $[x,y]$ 转移到 $[x+1,y+1]$ 时，这个区间只是删除了第 $x$ 个数，加上了第 $y+1$ 个数。

总结一下，我们发现，我们需要动态加入、删除一个数，维护区间第 $k$ 大数，小于某个数的数的和、大于某个数的数的和，这不就是裸的平衡树嘛。

记得最后开 O2 优化。

时间复杂度：$O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
//本题数据较大，建议用unsigned long long
const int N=5e5+5;
const ull INF=1e19;
ull fa[N],ch[N][2];
//fa[x]表示x的父亲的编号
//ch[x][0]表示x点的左儿子，ch[x][1]表示x点的右儿子
ull tot[N],val[N],sz[N],h[N];
//tot[x]表示以x为根的子树的h值的和
//tot[x]表示以x为根的子树大小
//val[x]表示编号为x的h值
ull root,cnt;//root为根节点的编号
ull n,k;
ull read(){
    ull x=0,f=1;
    char c=getchar();
    while(!isdigit(c) && c!='-') c=getchar();
    if(c=='-') f=-1,c=getchar();
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
namespace Splay{
    void maintain(ull rt){//类比线段树的pushup操作，从下往上更新
        sz[rt]=sz[ch[rt][0]]+sz[ch[rt][1]]+1;
        tot[rt]=tot[ch[rt][0]]+tot[ch[rt][1]]+val[rt];
    }
    bool get(ull x){//求x是左儿子还是右儿子
        return x==ch[fa[x]][1];
    }
    void rotate(ull x){
        ull y=fa[x],z=fa[y],chk=get(x);
        ch[y][chk]=ch[x][chk^1];
        fa[ch[x][chk^1]]=y;
        ch[x][chk^1]=y;
        fa[y]=x; fa[x]=z;
        if(z) ch[z][y==ch[z][1]]=x;
        maintain(y); maintain(x);
    }//Splay 的根本操作，不作赘述
    void splay(ull x,ull to){
        for(ull f;(f=fa[x])!=to;rotate(x)){
            if(fa[f]!=to) rotate(get(x)==get(f)?f:x);
        }
        if(!to) root=x;
    }//Splay 的根本操作，不作赘述
    void insert(ull &rt,ull x){//插入节点x
        if(!rt){
            rt=++cnt; val[cnt]=x;
            sz[cnt]=1; tot[cnt]=x;
            return;
        }
        if(x<val[rt]) insert(ch[rt][0],x),fa[ch[rt][0]]=rt;
        else insert(ch[rt][1],x),fa[ch[rt][1]]=rt;
        maintain(rt);
    }
    ull kth(ull rt,ull k){//求以x为根的子树的第k大数
        if(sz[ch[rt][0]]+1==k) return rt;
        if(sz[ch[rt][0]]>=k) return kth(ch[rt][0],k);
        else return kth(ch[rt][1],k-sz[ch[rt][0]]-1);
    }
    ull getmin(ull rt){
        ull p=rt,ans=-1;
        while(p) ans=p,p=ch[p][0];
        return ans;
    }
    void del(ull rt){//删除节点x
        splay(rt,0);
        ull p=getmin(ch[rt][1]);
        if(~p){
            splay(p,rt);
            root=p,fa[p]=0;
            ch[p][0]=ch[rt][0]; fa[ch[rt][0]]=p;
            maintain(p);
        }
        else root=ch[rt][0],fa[ch[rt][0]]=0;
    }
}
using namespace Splay;
int main(){
    //freopen(Name ".in", "r", stdin);
    //freopen(Name ".out", "w", stdout);
    n=read(); k=read();
    ull ans=INF,sum,x,tp,num=0,l,r;
    //ans为答案
    for(ull i=1;i<=n;i++){
        h[i]=x=read(); insert(root,x);
        splay(cnt,0); num++;
        if(num>=k){
            x=kth(root,(k+1)>>1);
            splay(x,0);
            sum=sz[ch[x][0]]*val[x]-tot[ch[x][0]]+tot[ch[x][1]]-sz[ch[x][1]]*val[x];
            if(sum<ans) ans=sum,tp=val[x],l=i-k+1,r=i;
            del(i-k+1);
        }
    }
    printf("%llu\n",ans);
    return 0;
}

```


---

## 作者：xuhanxi_dada117 (赞：0)

# P2263 命运的彼方  题解

~~在 STL 面前，平衡树就...~~

[题目传送门](https://www.luogu.com.cn/problem/P2263)

## 题目大意

给出 $n$ 个数，求要把连续 $k$ 个数变相同的次数。每次可以把一个数 $+1$ 或 $-1$ 。

[双倍经验](https://www.luogu.com.cn/problem/P3466)

## 题目解法

首先，我们明确：每连续 $k$ 个数要变成一样的最优方案是变成中位数。

### 中位数

中位数可用对顶堆实现，每次维护一个大根堆，一个小根堆。每次加点就看与中位数的大小放入对应的堆，看到大小不一样就调整中位数。

可在自行学习。

**但是！！**  对顶堆**不能删除！**  所以单纯的对顶堆肯定不行。

### 对顶  "multiset"

根据对顶堆的思想，我们需要一个数据结构：
+ 能维护最大最小值
+ 能动态删点，增点

这不就是 ```multiset``` ??

所以，我们只要把堆改成 ```multiset``` 即可。

## 代码

```cpp
#include<bits/stdc++.h>  //全开 long long 记得开 O2
#pragma GCC Optimize 1  // 本代码非常卡时，一定开 O1O2O3
#pragma GCC Optimize 2
#pragma GCC Optimize 3
#define N 500010
#define int long long  // 一定开 long long
using namespace std;
int n,k,h[N],sm1,sm2,mid,ans=9000000000000000000; // ans 开大点
multiset<int> s1,s2;// 两个 multiset 维护比中位数大的和比中位数小的。
void insert(int x){  //动态加点维护 multiset
    if(x<*s2.begin()) s1.insert(x),sm1+=x;// 加入
    else s2.insert(x),sm2+=x;
    if(s1.size()>s2.size()){// 平衡
        multiset<int>::iterator it=--s1.end();
        sm1-=(*it);sm2+=(*it);
        s2.insert(*it);
        s1.erase(it);
    }
    if(s1.size()+1<s2.size()){// 平衡
        multiset<int>::iterator it=s2.begin();
        sm2-=(*it);sm1+=(*it);
        s1.insert(*it);
        s2.erase(it);
    }
}
void dele(int x){ //删点
    if(s2.count(x)) s2.erase(s2.find(x)),sm2-=x;//先删
    else s1.erase(s1.find(x)),sm1-=x;
    // 这里 erase 一定要删迭代器，不然40
    if(s1.size()>s2.size()){// 平衡
        multiset<int>::iterator it=--s1.end();
        sm1-=(*it);sm2+=(*it);
        s2.insert(*it);
        s1.erase(it);
    }
    if(s1.size()+1<s2.size()){// 平衡
        multiset<int>::iterator it=s2.begin();
        sm2-=(*it);sm1+=(*it);
        s1.insert(*it);
        s2.erase(it);
    }
}
//一定输入输出优化
signed main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&h[i]);
    for(int i=1;i<k;++i) insert(h[i]); //预处理前 k-1 个数
    for(int i=k;i<=n;++i){
        insert(h[i]); // 插入新点
        if(i>k) dele(h[i-k]); //删除：维持连续 k 个
        mid=*s2.begin();// 找到中位数
        int ss=mid*s1.size()-sm1+sm2-mid*s2.size();
        // 计算答案 mid*s1.size()-sm1 为 s1 中数的修改量
        //printf("sm1: %lld , sm2: %lld , mid: %lld.\n",sm1,sm2,mid);
        ans=min(ans,ss);
		}
    }
    printf("%lld",ans);
    return 0;
}
// 总结：#define int long long 会被卡常QAQ
```

谢谢观看。

---


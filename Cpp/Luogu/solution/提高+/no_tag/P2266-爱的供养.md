# 爱的供养

## 题目背景

在很久很久以前，有一只野心勃勃的骑士 Mori，带领自己的军队，征战世界，所向披靡……

有一天，他跨过千山万水，越过重重山岭，来到了一个美丽的（程序）国度。在这里，他与 Soha 公主一见钟情，并最终坠入爱河。

从此，他们幸福快乐地生活在了一起……


## 题目描述

但好日子却不长久。Mori 的手下大将恶魔猎手在此时背叛了他，自立为王，率领深藏在世界之轴的龙族叛变，并掳走了 Soha 公主。Mori 在与恶魔猎手的战斗中，遭遇围杀，被困在一个荒芜人烟的大岛上。但在经过勘探后，他惊喜地发现，Soha 也同时被恶魔猎手关押在这座岛上！

经过精心研究，Mori 发现关押 Soha 的地牢需要若干把钥匙才能打开，而钥匙则被埋藏在一系列的法阵中。凭借着自己的身手与魔力，Mori 是能够破解法阵、获得钥匙的。法阵是一个 $M\times N$ 大小的矩阵，法阵中的每一格都具有自己的高度。其中，有一部分格中埋藏着钥匙，但 Mori 法力不足，无法直接挖取。而他发现，只需从埋藏着钥匙的格子出发向四周的格子走，并在不少于 $T$ 个的独立法阵格子中施法（包括埋藏钥匙的格子本身也要施法），便可挖出钥匙。换句话说，在他每次挖掘钥匙之前，都必须先从埋藏钥匙的格子开始，走过周围的 $T-1$ 个不重复的格子。

虽然 Mori 施法不需要耗费体力，但他在移动的过程中，需要耗费一定量的体力（体育不及格 233）。从一个格子移动到另一个格子中所耗费的体力值为两个格子的高度值之差的绝对值。

对于每个埋藏钥匙的格子来说，定义其难度值 $P$ 为在施法过程中，每次在各个格子间移动的所需耗费的体力的最大值。

而 Mori 则希望让这个难度值越小越好。因为，只有保留足够多的体力，他才能营救 Soha，并两人合力打败恶魔猎手的背叛。

所以，他想知道所有埋藏钥匙的点的难度值的和最小值可以是多少？


## 说明/提示

$1 ≤ M, N ≤ 600$

$1 ≤ T ≤ M\times N$


## 样例 #1

### 输入

```
3 5 5
20 21 20 20 21
19 22 20 60 80
80 90 80 70 90
1 0 0 0 0
0 0 0 0 0
1 0 0 0 1
```

### 输出

```
31```

# 题解

## 作者：shanjianyu (赞：10)

本题要求求出和某个格子相连的最小边的最大值的最小值(变得权值可以看作为格子与格子之间高度的绝对值之差)，因此我们需要用最小生成树来解决，由于询问可能很多我们需要对答案进行预处理。

建图：我们可以将每个格子和它周围的格子连边，边权为格子高度绝对值之差，之后我们对整个图跑最小生成树。但是我们需要保证至少走过T个格子，我们用并查集维护联通性，还要维护每个集合里面的顶点数以及每个集合它所询问的点数，如果两个集合合并后它们的点数之和>= T，那么其中一个集合询问的点数就对答案有贡献，即ans+=ask[i]，ask[i]表示i集合有多少个询问的点(即里面包含多少个钥匙)，之后将两个集合合并。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
#define LL long long 
#define Maxn 400005
#define Maxm 1600005

struct node {
    LL u,v,w;
}e[2*Maxm];

LL n,m,T,cnt,N,tot,M,ans=0;
LL fa[Maxn],dot[Maxn],ask[Maxn],rank[Maxn];
LL a[605][605],b[605][605],dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};

bool comp(const node &k1,const node &k2) {return k1.w<k2.w;}
LL find(LL x) {
    if(fa[x]==x) return x;
    else return fa[x]=find(fa[x]);
}

//ask[i]表示i集合询问的点数,dot[i]表示i集合里面的点数 
int main() {
    scanf("%lld%lld%lld",&n,&m,&T);N=n*m;
    for(int i=1;i<=n*m;i++) fa[i]=i,dot[i]=1;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",&a[i][j]);
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) {
        scanf("%lld",&b[i][j]);
        ask[(i-1)*m+j]=b[i][j];
    }
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) {
        for(int k=0;k<4;k++) {
            int x=i+dx[k],y=j+dy[k];
            if(x>n||x<1||y<1||y>m) continue ;
            e[++M].u=(i-1)*m+j;e[M].v=(x-1)*m+y;
            e[M].w=abs(a[i][j]-a[x][y]);
        } 
    }
    sort(e+1,e+M+1,comp);LL r1,r2;
    for(int i=1;i<=M;i++) {
        r1=find(e[i].u);r2=find(e[i].v);
        if(r1!=r2) {
            if(dot[r1]+dot[r2]>=T) {
                if(dot[r1]<T) ans+=e[i].w*ask[r1]; 
                if(dot[r2]<T) ans+=e[i].w*ask[r2];//这两句话统计对答案的贡献    
            }    
            if(rank[r1]<rank[r2]) fa[r1]=r2,dot[r2]+=dot[r1],ask[r2]+=ask[r1];
            else {
                fa[r2]=r1,dot[r1]+=dot[r2],ask[r1]+=ask[r2];
                if(rank[r1]==rank[r2]) rank[r1]++;
            }
            tot++;
            if(tot==N-1) break;
        }
    } 
    printf("%lld\n",ans);
    return 0;
} 
```

---

## 作者：CaoSheng_zzz (赞：2)

### 题目大意
给你一个矩阵 $ w $，大小为 $ n \times m $，然后你每次都从一个宝藏点开始去走旁边 $ T - 1 $ 个点施法，施法过的点就不用再走了，施法不需要耗费体力但是每一次从一个点走到另一个点需要耗费的权值为这两个点的高度差，你每次可以走的方向是上下左右。求最小需要耗费的体力。

### 思路
首先我们要明白一个东西就是周的定义：对于一个点 $ a $ 它可以走一步走到点 $ b $ 那么 $ b $ 就在 $ a $ 的周围，对于点 $ b $ 他可以走一步走到点 $ c $ 且 $ c \neq a $ 那么 $ c $ 在 $ b $ 的周围 $ c $ 也在 $ a $ 的周围但是要使 $ c $ 在 $ a $ 的周围必须走过 $ c $ 周围的点。

在长久的思考过后我觉得我们可以把用最小生成树 Kruskal 算法来解决这一道题，因为题目要求求与这个点连接 $ T - 1 $ 条边需要的最小体力，边得权值就设为点 $ u $ 到点 $ v $ 需要耗费的体力就行了。

对于联通块的维护我们可以用到并查集，合并并查集时如果它们的边数 $ \ge T - 1 $ 时说明他对答案可能有贡献所以我们就判断。在加体力的时候我们用当前边的权值乘上当前联通块的宝藏数量就行了当然当前联通块的边的数量需要 $ \le T - 1 $，我们的思路就完事了，代码量中偏短所以建议自己先写一下。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#define sc(ppt) scanf("%lld" , &ppt)
#define ll long long
#define int long long
#define prt printf
using namespace std;

const int maxm = 8e5 + 1 , maxn = 6e2 + 1;
const int dx[] = {0 , 0 , 0 , 1 , -1};
const int dy[] = {0 , 1 , -1 , 0 , 0};
int n , m , T , a[maxn][maxn] , vis[maxn][maxn] , oe[maxn * maxn] , anc[maxn * maxn] , Size[maxn * maxn] , sign;
int h[maxn] , cnt = 0 ;
struct edge{
	int next , to , val;
}e[maxm << 1]; // 前向心 

inline void add(int u , int v , int w){
	++ cnt;
	e[cnt].next = u ; e[cnt].to = v; e[cnt].val = w;
//	h[u] = cnt;
}

bool cmp(const edge &x , const edge &y){
	return x.val < y.val;
} // 找最小权值的边 

int get_father(int u){ // 并查集 
	if(anc[u] == u) return u;
	else return anc[u] = get_father(anc[u]); // 记忆化 
}

void Kruskal(){
	int res = 0;
	for(int i=1 ; i<=cnt ; i++){
		int u = e[i].next , v = e[i].to;
		int t1 = get_father(u) , t2 = get_father(v);
		if(t1 != t2){
			if(Size[t1] + Size[t2] >= T){
				if(Size[t1] < T) res += e[i].val * oe[t1];
				if(Size[t2] < T) res += e[i].val * oe[t2];
			}
			if(Size[t1] > Size[t2]) swap(t1 , t2);
			anc[t1] = t2;
			Size[t2] += Size[t1];
			oe[t2] += oe[t1];
			++ sign;
			if(sign == n * m - 1){
				prt("%lld" , res);
				exit(0);
			}
		}	
	}
}

signed main(){
	sc(n) ; sc(m) ; sc(T) ;
	for(int i=1 ; i<=n * m ; i++) {anc[i] = i ; Size[i] = 1;}
	for(int i=1 ; i<=n ; i++) for(int j=1 ; j<=m ; j++) sc(a[i][j]);
	for(int i=1 ; i<=n ; i++){
		for(int j=1 ; j<=m ; j++){
			sc(vis[i][j]);
			oe[(i - 1) * m + j] = vis[i][j];
		}
	} // 预处理宝藏位置 
	for(int x=1 ; x<=n ; x++){
		for(int y=1 ; y<=m ; y++){
			for(int i=1 ; i<=4 ; i++){
				int xx = x + dx[i] , yy = y + dy[i];
				if(xx > n || xx < 1 || yy > m || yy < 1) continue;
				add((x - 1) * m + y , (xx - 1) * m + yy , abs(a[x][y] - a[xx][yy]));
			}
		}
	}
	sort(e + 1 , e + cnt + 1 , cmp);
	Kruskal();
	return 0;
}
```

---


# 琪琪的项链

## 题目背景

Piet 项目的一对开发者 laosb（吕世博）与 scjyholy（叶嘉琪）最近一直为中国学生站长联盟的童鞋们所津津乐道，不仅仅因为他们天天在某群中秀恩爱，而且他们还经常被用作题目背景。现在我们以他们为背景来引出一道问题。

## 题目描述

话说 laosb 在与 scjyholy 配对成功 $1$ 周年后， laosb 花光了其所有的积蓄，为 scjyholy 买了一条项链。但是，他发现店中项链的样式实在太少，于是他想买回一条项链，组成自己的独特样式，以使 scjyholy 感动。

首先 laosb 把项链中所有珠子取下，然后从左到右，选出若干珠子（至少 $1$ 颗），组成新的项链。因为项链珠子有很多颜色，laosb 希望知道他一共能组合出多少种不同的样式。

如图所示，假设原始的项链有 $3$ 颗珠子：蓝、黄、蓝，这样他一共有如下的选择方法：

 ![](https://cdn.luogu.com.cn/upload/pic/1.png) 

由于答案可能很大，请输出答案 $\bmod\ M$ 的结果。

## 样例 #1

### 输入

```
3 100
1 888 1
```

### 输出

```
6```

## 样例 #2

### 输入

```
4 100
1 2 3 4
```

### 输出

```
15```

# 题解

## 作者：stoorz (赞：5)

[$$\color{blue}{\texttt{Link:蒟蒻的Blog}}$$](https://blog.csdn.net/SSL_ZYC/article/details/102257792)

设$f[i]$表示最后一个数字是第$i$个数字的排列个数。

设位置$i$的数字是$a[i]$，那么能对其做成贡献的区间就是$[x,i-1]$，其中$a[x]=a[i]$且$x$尽量大。

因为取任意一个位置$[1,x-1]$的数字，有一下三种选择方法：

 - 选择$x$，不选择$i$，那么这个位置就对$x$做了贡献。
 - 选择$i$，不选择$x$，这样形成的序列就和上一行所述序列一样，就重复了。
 - 选择$x$和$i$，这样依然是对$x$做了贡献。

所以我们就得到了方程

$$f[i]=\sum^{i-1}_{j=x}f[j]\ \ (a[x]=a[i],a[x+1\sim i-1]≠a[i])$$

预处理出对于一个位置$i$的$last[i]$表示$a[last[i]]=a[i]$且$last[i]$尽量大。然后前缀和维护一下就好了。

时间复杂度$O(n)$

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;

const int N=500010;
int n,MOD,a[N],b[N],last[N];
ll f[N],sum[N];

int main()
{
	scanf("%d%d",&n,&MOD);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+1+n);
	int tot=unique(b+1,b+1+n)-b-1;
	for (int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+1+tot,a[i])-b;  //离散化
	for (int i=1;i<=n;i++)
	{
		if (last[a[i]]) f[i]=(sum[i-1]-sum[last[a[i]]-1])%MOD;
			else f[i]=(sum[i-1]+1)%MOD;  //判断这个颜色是不是第一个出现，如果是，就包含单独这一个颜色的方案，所以+1
		sum[i]=(sum[i-1]+f[i])%MOD;
		last[a[i]]=i;
	}
	printf("%lld",(sum[n]%MOD+MOD)%MOD);
	return 0;
}
```



---

## 作者：lzdll (赞：4)

这道题其实很简单，请诸位思考后再看题解。真的，非常简单。

注意到答案很大，所以猜测这题是个动态规划。
## 定义状态

不妨设 $dp_i$ 为第 $i$ 个作为结尾，对答案的贡献。$ans_i$ 为从第 $1$ 位到第 $i$ 位，所有的贡献。

很明显，我们最后输出的就是 $ans_n$。

## 状态转移

首先，我们假设我们没有看见这句话：

“laosb 希望知道他一共能组合出多少种**不同**的样式。”

所以，每一个珠子都可以和前面所有的连起来成为一串新的项链。

即 $dp_i=ans_{i-1}+1$。

然后更新，$ans_i=ans_{i-1}+dp_i$。

但是，我们看到了这句话，题目要求不能有相同的项链，怎么办？

我们使用 $lst_i$ 表示 $i$ 这个字符上一次出现是在哪个位置。遍历每一颗珠子，如果它没出现过，也就是 $lst_i=0$，按照上面写的就没有问题。如果它出现过，我们就要减去重复的情况，因为上一次它出现的时候，它已经和前面的都连过一次了，所以这一次就不能再和前面的连了。

所以这个时候，$dp_i=ans_{i-1}-ans_{lst_{c_i}-1}$，把前面的情况减掉。

对了，这题还有个坑。他减的时候可能减成负的，所以最后输出的时候要加上模数再输出。

## 代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<map>
#define int long long
#define R(x) x=read()
using namespace std;
inline int read() {
	int x,y;
	char c=getchar();
	x=0,y=1;
	while(c<'0'||c>'9') {
		if(c=='-') y=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=(x<<3)+(x<<1)+(c^'0');
		c=getchar();
	}
	return x*y;
}
const int N=1000007;//
int n,c[N],dp[N],ans[N];
map<int,int> lst;
signed main() {
	R(n),R(zsy);
	for(int i=1;i<=n;++i){
		R(c[i]);
	}
	dp[1]=1,ans[1]=1,lst[c[1]]=1;
	for(int i=2;i<=n;++i){
		if(lst[c[i]]){
			dp[i]=ans[i-1]-ans[lst[c[i]]-1];
		}else{
			dp[i]=ans[i-1]+1;
		}
		ans[i]=ans[i-1]+dp[i];
		ans[i]=ans[i]%zsy;
		dp[i]=dp[i]%zsy;
		lst[c[i]]=i;
	}
	cout<<(ans[n]+zsy+zsy+zsy)%zsy;
	return 0;
}
```

---

## 作者：青葱 (赞：1)

# 考虑dp

### **令f [ i ]为：**
## ****以第i个颜色为结尾的方案数****


在一个完整的项链后**加上不同的珠子可以形成新的项链**

考虑以第i个珠子为结尾的项链对后面的珠子所做的贡献

容易知道，以第i个珠子为结尾的项链，会对其后面所有数字第一次出现的位置作出贡献



------------


**举个栗子：**

例如：序列为　１、２、１、２、３、２

以第２个珠子为结尾形成的项链(1、2)和(2)
会对第３、４、５个珠子造成贡献，却不会对第６个珠子造成贡献，因为２不是第一次出现


------------
```
令col[p]表示第p个珠子的颜色
```
------------


### 则动态转移方程可以写作：
```cpp
for(int j=i+1;j<=n;j++){
    if(col[j]相对第i个珠子而言第一次出现)
        f[j]+=f[i];
}
```

------------
### 反过来讲，动态转移方程也可以写作：
```cpp
for(int j=1;j<=i;j++){
    if(col[i]相对第j个珠子而言第一次出现)
        f[i]+=f[j];
}
```
------------
```
假设第i个珠子前，有最近的p,使得col[p]==col[i]，
则p之前的项链已经对p作出了贡献，就不会对i再作贡献
```
**举个栗子：**

例如：序列为　１、２、１、２、３、２

以第３个珠子及之前的珠子为结尾的项链，可以加上第４个珠子出现新的项链，但却不会对第６个珠子作出贡献

------------

### 所以，动态转移方程可以写作：
```
for(int j=上一次col[i]出现的位置＋１；j<i;j++)
    f[i]+=f[j];
```
------------
### 于是问题变成了快速找前面第一个相同颜色的珠子和区间加

### 自然的想到前向星和树状数组

------------
## 前向星：
```
令head[p]表示颜色为p的珠子最后出现的位置
令next[q]表示在第q个珠子前最近的相同颜色的珠子
扫一遍序列，有：
for(int i=1;i<=n;i++){
    next[i]=head[col[i]];
    head[col[i]]=i;
}
```
------------
## 树状数组不再赘述

当然前缀和可以更优秀的解决问题，但我更喜欢树状数组，虽然凭空加了一个log

------------
## 核心代码如下：
```
for(int i=1;i<=n;i++){
    if(nex[i]) f[i]=(sum(i-1)-sum(nex[i]-1))%m;
    else f[i]=(1+sum(i-1))%m;
    add(i,f[i]);
}
```

------------

## 温馨提示：
１、由于不知道表示颜色的数有多大，所以需要开long long

２、由于不知道表示颜色的数有多大，所以需要离散化

---

## 作者：hejianxing (赞：0)

[link](https://www.luogu.com.cn/problem/P2267)

# 题目大意

$n(1\le n\le 5\times 10^5)$ 颗带颜色的珠子，从左到右选出若干颗珠子（不少于 $1$ 颗），问有多少种方案。答案模 $m$.

# 题解

小 dp 题。

首先对珠子颜色离散化，记得开 `long long`. 不多说。

观察发现，选出珠子不考虑原数组中的位置，只需要保证珠子序列在原数组中是从左到右的。

故设状态 $f[i]$ 表示以 $a[i]$ 结尾的珠子序列的方案数。

从左到右枚举，考虑第 $i$ 颗珠子（颜色为 $a[i]$）能接在哪些序列后。记离第 $i$ 颗珠子最近的颜色与这颗珠子相同的珠子位置为 $lst[i]$. 那么有

$$f[i]=\sum\limits_{j=lst[i]}^{i-1}f[j]$$

为什么？

观察序列：1，2，3，2，3，2

最后一颗珠子颜色为 $2$，它不能接在第 $1$ 到 $3$ 颗珠子后，因为这种情况（在第 $1$ 到 $3$ 颗珠子后接上颜色为 $2$ 的珠子）已经被第 $4$ 颗珠子统计过了。

$O(n\log n)$ 离散化，$O(n)$ 预处理出 $lst$ 数组，前缀和优化 dp $O(n)$，总的时间复杂度 $O(n\log n)$.

记得模 $m$.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 500005;
int n, m, c[N], lst[N];
LL f[N], b[N], a[N], ans = 0, sum[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]), b[i] = a[i];
    sort(b + 1, b + n + 1);
    for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;
    for (int i = 1; i <= n; i++) lst[i] = c[a[i]], c[a[i]] = i;
    for (int i = 1; i <= n; i++) {
        if (lst[i]) f[i] = (sum[i - 1] - sum[lst[i] - 1] + m) % m;
        else f[i] = (sum[i - 1] + 1) % m;
        sum[i] = (sum[i - 1] + f[i]) % m;
    }
    for (int i = 1; i <= n; i++) ans = (ans + f[i]) % m;
    printf("%lld", ans);
    return 0;
}
```

# END

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2267)
## 思路
很水的一道入门 $\verb!DP!$。

发现我们要求的是本质不同的子串个数。你可以使用容斥或者简单的子序列自动机。

这里简单起见使用子序列自动机求解。

设 $f_i$ 表示以 $i$ 为结尾的本质不同子串个数。

+ 一种理解方式：我们把 $s_i$ 和后面的数字连边，等同于求路径数，但是比较难以理解。
+ 另一种理解方式：我考场上手推出来的，当时不知道子序列自动机这个东西，我们发现 $s_i$ 可以接到所有 $s_j\ \ (j<i)$ 上，但是会有重复情况，就是上一个 $s_i$ 出现的位置，所以需要减掉。

然后这道题就做完了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int const N=5e5+10;
int a[N],mp[N],b[N],f[N];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int n,m;cin>>n>>m;
    for (int i=1;i<=n;++i) cin>>a[i],b[i]=a[i];
    sort(b+1,b+n+1);int l=unique(b+1,b+n+1)-b-1;
    for (int i=1;i<=n;++i) a[i]=lower_bound(b+1,b+l+1,a[i])-b;
    int now=0;
    for (int i=1;i<=n;++i){
        f[i]=now+1;f[i]%=m;
        now+=(f[i]-mp[a[i]]+m)%m;now%=m;
        mp[a[i]]=f[i];
    }
    cout<<now<<'\n';
    return 0;
}
```


---

## 作者：AzusaShirasu (赞：0)

对于读入的数据，因为没有给出颜色的取值范围，保险起见必须使用 $\texttt{long long}$ 保存，这是前提；之后对颜色进行离散化，映射到 $[1, n]$ 区间，不多解释。

重点放在如何计算方案上。可以发现，在任意一条合法的项链末尾添加上新的珍珠，就能够产生新的项链。很容易的想到以当前位置 $x$ 作为动态规划的阶段。设 $f(x)$ 表示当前位置为 $x$ 时，能产生的所有新项链的总和，那么状态转移不难写出：因为是**从左到右**选（不允许回头选），所以 $f(x)$ 的值应当是从 $x+1$ 开始到 $n$ 所有状态的总和，即

$$f(x)=\sum_{i=x+1}^{n}(f(i)+\Delta(i))$$

在方程中引入了一个 $\Delta(i)$ 作为修正。之所以要修正，是因为**不允许出现重复项链**。假设当前 $i=p$，设珍珠颜色为 $a_p$，如果能找到一个 $q \in [x + 1, p - 1]$ 使得 $a_q=a_p$，那么此时若再加上 $f(p)$ 就会产生重复，因为在 $p$ 之后产生的所有项链**肯定可以**在 $q$ 产生的项链中找到。

如下图：


![](http://39.106.8.172:4080/get_image?pic=b364761ef85798125f31e067687491d4)

此时在 $x$ 和 $p$ 之间存在了 $a_q=a_p$，此时，由于在 $p$ 之后的所有珍珠都肯定在 $q$ 之后，而 $q$ 会比 $q$ 先计算到，因此若在存在 $q$ 的情况下仍然计算 $p$ 就会导致重复计算。所以，我们需要在计算 $f(x)$ 时，**保存前面所遇到的所有珍珠颜色**，若产生重复则不转移，也就是说：

$$f(x)=\sum_{i=x+1}^{n}
\begin{cases}
0 && (a_i \text{ 出现过})\\
f(i) && (a_i \text{ 未出现过})\\
\end{cases}
$$

当 $x=1$ 时，说明计算到了边界，此时应当返回 $1$ 表示找到了一种合法的项链。依此，可以写出一个记忆化搜索的主程序如下：

```
int dp(int loc) {
	if(f[loc]) return f[loc];
	if(loc == n + 1) { // 边界 
		return 1;
	}
	set<int> vis; 
	int ret = 0;
	for(int i = loc + 1; i <= n + 1; i++) {
		if(!vis.count(colour[i])) { // 没有出现过 
			vis.insert(colour[i]);
			ret += dp(i) % m, ret %= m; // 往下计算 
		}
	}
	return f[loc] = ret % m;
}
```

这个程序的时间复杂度是 $O(n^2 \log n)$，会超时，因此需要对它进行优化。

思考：如果已知 $f(x-1)$，且 $x$ 的颜色在 $1$ 至 $x-1$ 中均未出现过，那么 $f(x)$ 能不能计算呢？答案是肯定的。考虑 $f(x)$ 如何从 $f(x-1)$ 计算得来：

1. 可以在所有 $x-1$ 能产生的项链之后**额外加上一颗珍珠**，所以会新产生 $f(x-1)$ 条；

2. 可以只选现在的第 $x$ 颗，这样还会新产生 $1$ 条。

综上，$f(x)=2f(x-1)+1$。

这是**没有重复的情况**，如果加入包含重复的情况呢？假设现在有 $a_x=a_p$，
对于 $1$ 到 $p-1$ 之间的**所有**项链，在后面加上一颗颜色为 $a_x$ 的珍珠都是没有必要的，因为已经加过 $p$ 了，与 $p$ 颜色相同的 $x$ **对答案没有贡献**。也就是说，$p$ 珍珠对**之前所有珍珠**的贡献此时**不应该被计入**，则多计算出的数量为 $f(p-1)$。

那么，难道每个 $f(p)$ 都要计算一次吗？其实不是的，因为 $f(p)$ 已经包含了 $p$ 之前所有和 $x$ 颜色相同的珍珠所多产生的项链数量，所以不需要作额外的扣除。我们需要的 $p$ 是**离** $x$ **最近的那个** $p$，也就是**最近一次** $a_x$ 出现的位置，这可以用一个变量保存。

做到这里，已经不需要采取记忆化搜索了，可以使用递推的方式计算。

```
#include <bits/stdc++.h>

using namespace std;
#define int long long

const int maxn = 500000 + 5;

int n, m;
int p[maxn];
int f[maxn];
int a[maxn];

void dp() {
	for(int i = 1; i <= n; i++) {
		f[i] = f[i - 1] * 2, f[i] %= m; // 先 * 2
		if(!p[a[i]]) f[i]++, f[i] %= m; // 之前没有出现过，为 * 2 + 1
		else f[i] -= f[p[a[i]] - 1] % m, f[i] %= m; // 之前出现过了，不能 +1，而且要扣除 f[p - 1]
		p[a[i]] = i;
	}
}

int t[maxn];
signed main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], t[i] = a[i];
	sort(t + 1, t + 1 + n);
	int cnt = unique(t + 1, t + 1 + n) - t - 1;
	for(int i = 1; i <= n; i++) a[i] = lower_bound(t + 1, t + cnt + 1, a[i]) - t; // 离散化，不多解释
	dp();
	cout << (f[n] + m) % m;
	return 0;
}
```

最后需要注意的是，如果计算过程中出现了减法，那么最终答案注意要转化为正数。

---


# [HNOI2002] 奶牛的运算

## 题目描述

最近，Farmer John 农场里的奶牛正在学习数学基础课。这天，奶牛 Besty 学会了加减法运算和括号的使用。

Farmer John 为了考察 Besty 的学习情况，写了如下一个算式：

$S =A_1-A_2-\ldots-A_n$

接着，Farmer John 告诉 Besty，这个算式中省略了 $K$ 个括号。将这 $K$ 个括号加入该算式中，就会得到一种算式方案。

例如：$S=A_1-A_2-A_3-A_4$，$K = 2$，则 $S = (A_1)-A_2 - (A_3- A_4)$ 就是一种算式方案。

而对任意两个算式方案，$S'$ 和 $S''$ 本质不同是指：存在某数列 $A_1,\ldots,A_n$ 满足 $S'\ne S''$。否则就是本质相同。

例如：$S'=(A_1)-A_2-(A_3-A_4)$ 与 $S''=(A_1-A_2)-(A_3-A_4)$ 就是本质相同的算式方案。

现在，Farmer John 告诉奶牛 Besty 算式中项的个数 $N$ 和括号的个数 $K$（数列 $A$ 是变量，我们不需要关心它），他想考考 Besty 究竟有多少本质不同的算式方案。


## 样例 #1

### 输入

```
4 1```

### 输出

```
4```

# 题解

## 作者：Purified (赞：6)

###这绝对不是一道入门难度的题！

虽然我手贱写了入门。。。。

第一次写题解求轻喷

你会发现这道题改一下会变成这样


有一个长度为N-2的序列，你能进行M次操作

每次操作可以翻转其中的一个子序列（也可以不反转 浪费一次操作）

初始值全为0

求M次操作能获得的可能结果有多少种


然后就变成了求组合数的和

你会发现M次操作可以产生的0段1段的数量小于2\*M+1

序列有N-3个空

插0~2\*M次就可以了

注意除了2\*M次 其他的组合数都是要\*2的（你还有剩余操作可以把它整体翻过来嘛）


高精没优化也过了（数据并不是很强 我甚至不知道需不需要高精 但理论上讲是要的）

上代码

’‘’cpp

```cpp
#include<bits/stdc++.h>
#define MAXN 105
int ans[MAXN],f[MAXN];
void cauculate1(int a)
{for(int i=0;i<MAXN;i++) f[i]*=a;
 for(int i=MAXN-1;i>=1;i--)
 {f[i-1]+=f[i]/10;f[i]%=10;}
 return;}
 void cauculate2(int a)
 {int flag=0;
  for(int i=0;i<MAXN;i++)
  {flag*=10;flag+=f[i];
   f[i]=flag/a;flag%=a;}
   return;}
void cauculate3(int k)
{
    for(int i=MAXN-1;i>=1;i--)
    {
       ans[i]+=k*f[i];    
       ans[i-1]+=ans[i]/10;
       ans[i]%=10; 
    }
    return;
}
void cmn(int n,int m)
{
    f[MAXN-1]=1;
    for(int i=0;i<m;i++) cauculate1(n-i);
    for(int i=0;i<m;i++) cauculate2(1+i);
    return;
}
int main()
{
    int op,l,i;
    scanf("%d%d",&l,&op);
    l=l-2;
    if(op==0)
    {
        printf("1");
        return 0;
    }
    if(op>(l-1)/2)
    {
        f[104]=1;
        for(i=0;i<l;i++) cauculate1(2);
        for(i=0;i<MAXN;i++) if(f[i]) break;
        for(;i<MAXN;i++) printf("%d",f[i]);
    }
    else
    {
        for(i=1;i<2*op;i++)
        {
            cmn(l-1,i);
            cauculate3(2);
            memset(f,0,sizeof(f));
        }
        cmn(l-1,2*op);
        cauculate3(1);
        memset(f,0,sizeof(f));
        f[MAXN-1]=2;
        cauculate3(1);
        for(i=0;i<MAXN;i++) if(ans[i]) break;
        for(;i<MAXN;i++) printf("%d",ans[i]);
    }
    return 0;
}
‘’‘
```

---

## 作者：Troubadour (赞：5)

好题，不过看题解全都是插板法做的，那这里说另一种思路。

### 题意

给你一个长度为 $n-2$ 的 01 序列，初始全是 $0$。（为什么是 $n-2$ 呢？因为 $n$ 个数字，$n-1$ 个符号，然而第一个无论如何是改变不了的，所以可操作的序列长度为 $n-2$。）

你每次可以翻转（flip，不是 reverse）其中的一个子序列，最多操作 $m$ 次。

问你最后可能得到的结果有多少种。

### 分析

我们考虑连续的两次操作，有四种情况：（下面的分析中，如果没有另作说明，翻转的序列均非空）

1. 两次操作的序列不相交，也不相邻，如图所示：

![如果你看到这行字，说明图挂了qwq](http://r.photo.store.qq.com/psc?/V53Jnu1D3vSo501VoEus464qox1MU2UT/45NBuzDIW489QBoVep5mcaosC*3eAlxsZiHNnJ7N.AZJhyIJD1Lezmojzt6ydiCUrS0X2fl6xa32LL*VWf44wno03GfT7AcRifv9mE8s1TU!/r)

没什么好说的，翻转了两个区间，而且这两个区间至少间隔 $1$（记住这句话，后面有用到）。

2. 两次操作的序列相邻，如图所示：

![如果你看到这行字，说明图挂了qwq](http://r.photo.store.qq.com/psc?/V53Jnu1D3vSo501VoEus464qox1MU2UT/45NBuzDIW489QBoVep5mcaosC*3eAlxsZiHNnJ7N.AaXaKMyy5GkxFNTz45sGO*KNpNnAItdJPi3LafPQMg1WdzP*QDeWuRd9JXgAMIG2Sc!/r)

容易发现，这种情况等价于一次操作了一整段，然后第二次操作直接浪费掉。所以我们可以直接把他看做一次操作。

3. 两次操作的序列相交，且第二次操作的是第一次的子区间，如图所示：

![如果你看到这行字，说明图挂了qwq](http://r.photo.store.qq.com/psc?/V53Jnu1D3vSo501VoEus464qox1MU2UT/45NBuzDIW489QBoVep5mcadIDSANkZMC.4BX5KRKbHDJWaC6wkkUZWuuL.GkQozRk6FZTRg6wv6Qbl1tczg9EzXLCGt01EFCbb.JdvFEgMM!/r)

可以看出，中间蓝色那一段被翻转了两次回去了，相当于根本没有操作，这样就把我们的红色区间分成了两部分，如图所示：

![如果你看到这行字，说明图挂了qwq](http://r.photo.store.qq.com/psc?/V53Jnu1D3vSo501VoEus464qox1MU2UT/45NBuzDIW489QBoVep5mcaosC*3eAlxsZiHNnJ7N.AYfYzYjTSlihfeF0eJSR9*oNCEwU1tWwlwHkzNMaBkmARZWbCrh7kUEdx1tq1d0RE8!/r)

很好，我们现在把它转化成了情况 $1$。

当然还有一种可能是，两次操作区间有至少一个端点重合了，那我们就看做操作一次或不操作的情况。

4. 两个序列相交，如图所示：

![如果你看到这行字，说明图挂了qwq](http://r.photo.store.qq.com/psc?/V53Jnu1D3vSo501VoEus464qox1MU2UT/45NBuzDIW489QBoVep5mcadIDSANkZMC.4BX5KRKbHDqIOxvSjY.9wJa0MW9ZfOEjujMS1UjLSQ1c*rqG*UE3HtZe51CSZFFLn1ZRfMlJCk!/r)

可以发现，翻转两次的翻回来了，我们也可以把这个转化为情况 $1$。

综上所述，我们连续操作两次，最多翻转了两个不相邻区间。

扩展这个结论，当这操作次数大于 $2$ 的时候，我们也可以发现类似的性质：

#### 连续的 $m$ 次操作等价于翻转最多 $m$ 个不相邻的区间。

根据这个性质，题意如下：

给你一个长度为 $n-2$ 的 01 序列，初始全是 $0$，你最多可以翻转 $m$ 个**互不相邻**的区间，问最后可能得到的结果有多少种。

因为选择的区间之间至少隔了 $1$ 个数，我们就不用担心翻不同的次数得到相同的结果。这个问题等价于求方案数。

考虑 DP。

### 推式子

设 $f_{i,j,0/1}$ 表示前 $i$ 个位置一共选了 $j$ 段，第 $i$ 个位置是否翻转的方案数。

如果前 $i$ 个数一个都不选，即 $j=0$：

$$
\large f_{i,0,0}=1
$$

接下来开始枚举 $j$:

- 假如第 $i$ 个位置不选，则 $i-1$ 位置可选可不选，继承前面的状态，这样转移：

$$
\large f_{i,j,0}=f_{i-1,j,0}+f_{i-1,j,1}
$$

- 假如第 $i$ 个位置要选，那么第 $j$ 段区间必然要和第 $j-1$ 段有一个分割点。枚举这个分割点，这样转移：

$$
\large f_{i,j,1}=\sum\limits_{k=0}^{i-1}f_{k,j-1,0}
$$

这里 $k$ 要从 $0$ 开始枚举。

那么，最终统计答案的时候，把 $f_i$ 的所有状态全加起来就行了。

复杂度：状态 $n^2$，转移 $O(n)$，总复杂度 $O(n^3)$。

顺便说一下，这道题在 $n=100,m=100$ 的情况下答案为 $316912650057057350374175801344$，用 `__int128` 存储即可。

### Code:

```cpp
#include<bits/stdc++.h>
inline void write(__int128 x)
{
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 105;
__int128 f[N][N][2], ans;
int n, m;
int main()
{
	std::cin >> n >> m;
	n -= 2;
	f[0][0][0] = 1;
	for (int i = 1;i <= n;i++)
	{
		f[i][0][0] = 1;
		for (int j = 1;j <= m;j++)
		{
			f[i][j][0] = f[i - 1][j][0] + f[i - 1][j][1];
			for (int k = 0;k < i;k++)
			{
				f[i][j][1] += f[k][j - 1][0];
			}
		}
	}
	for (int i = 0;i <= m;i++)
	{
		ans += f[n][i][0];
		ans += f[n][i][1];
	}
	write(ans);
}
```

---

## 作者：Epoch_L (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P2270)
## Solution
陈年老题了，但真是一道组合数好题。

根据数学知识，加括号就相当于改变里面的符号，所以我们可以将其看为对符号的修改，问题就变为：一个长度为 $n-1$ 的符号序列，每次可以选一个区间将其符号反转，问 $k$ 次操作后，能得到多少不同的序列。

要注意第一个符号没有办法改变，这在最后会提到。

### 引理
$k$ 次对任意区间的操作可以看作**不超过** $k$ 次对**互不相交且不相邻**的区间的操作。

只考虑 $2$ 个区间的情况即可推广，分情况讨论：
1. 当区间不交时且不相邻时，可以通过相同的操作次数来实现相同的效果。
2. 当区间有相交部分，例如 $[1,5]$ 和 $[3,7]$，容易发现对于相交的区间 $[3,5]$ 被改了 $2$ 次又被改回来了，就相当于只改变了 $[1,2]$ 和 $[6,7]$。可以通过相同的操作次数来实现相同的效果，注意这里包含了一个区间是另一个区间子集的情况。
3. 当区间相邻，如 $[1,3]$ 和 $[4,5]$，我们可以通过一次操作 $[1,5]$ 即可实现相同效果。

### 答案
这样就很清楚了，答案就是选择至多 $k$ 个不交也不相邻区间的方案数，插板法即可。

注意第一个符号是不能改的，于是头不能插板，而尾插板有意义，所以有 $n-1$ 个位置，插至多 $2\times k$ 个偶数板，组合数即可，答案为：
$$
\sum_{i=0}^{2k} \binom{n-1}{i}
$$
注意增量 $\Delta=2$。
## Code
答案会很大，用高精，这里为了不占版面就不加了。
```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x)
{
	char ch=getchar();
	int r=0,w=1;
	while(!isdigit(ch))w=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch))r=(r<<3)+(r<<1)+(ch^48),ch=getchar();
	x=r*w;
}
int C(int n,int m)
{
	if(m==0)return 1;
	if(n<m)return 0;
	int ans=1;
	for(int i=1;i<=m;i++)
		ans*=(n-i+1),ans/=i;
	return ans;
}
int main()
{
	int n,k;
	read(n);read(k);
	int ans=0;
	for(int i=0;i<=2*k;i+=2)
		ans+=C(n-1,i);
	cout<<ans;
	return 0;
}
```

---

## 作者：kyel (赞：0)

## 标签：高精 - 组合数，挡板法/DP
（看过题解的我写了两份代码）

首先不难发现，题意可以转化为对一长度为n-2的0/1序列，进行**至多**k次区间翻转（0->1,1->0）操作，问最终有多少种可能的序列。

为什么是n-2的0/1序列呢？因为总共有n-1个减号，除了第一个之外都可以加括号使其展开后变为加号。

为什么是至多呢？因为你可以 **(((((((A1))))))) - A2** 等等来浪费你的括号。

组合数的方法基于如下结论：对于任意X次翻转操作，最终一定可以用Y个互不重叠的区间描述，且Y一定不大于X。

“一定可以用互不重叠的区间描述”比较直观，而后半句话的证明方法是假设刚开始序列元素全部为0，而假定最终的序列中有x段互不相邻的1，则显然将最终的序列翻转回去时**每一次操作最多只能减少一段连续的1**（若恰好覆盖n段1，则其中必然同时覆盖了n-1段0，净结果仍为-1），故最少的翻转操作就是x次。由于**翻转回原始状态即翻转成最终状态的逆操作**，所以翻转到最终状态的最少操作次数就是x，于是用x段互补相邻的区间来描述这一系列操作一定是最优解之一。

然后显然这样一些区间可以用序列来表示，如[1,3][7,10]可以写作(1,3,7,10)。显然，**序列不同，得到的最终结果就不同**。

而这样一个序列的个数可以通过**挡板法**计算（在一排球间不重复的插入挡板)。一个板所代表的数字即它前面的**所有**球的个数，于是我们用挡板得到的数字是递增的，满足上面的要求。

于是，长度为n-2的序列里有n-1个空（首尾插入板是有意义的），我们要求的就是往里面插入**至多**k\*2个板的方案数。组合数求一求，加起来就好了。
```cpp
//法1：组合数，挡板法
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

const int maxn(112);
class number {
    public:
        number() : len(0) { memset(all, 0, sizeof(all)); }
        number(int l) : len(l) { memset(all, 0, sizeof(all)); }
        
        number operator=(int v) {
            len = 0;
            while (v) {
                all[len++] = v % 10;
                v /= 10;
            } return *this;
        }
        number operator*(const number& n) const {
            number ret;
            for (int i(0); i != len; ++i) {
                for (int j(0); j != n.len; ++j) {
                    ret.all[i + j] += all[i] * n.all[j];
                }
            }
            for (int i(0); i != len + n.len; ++i) {
                if (ret.all[i] >= 10) {
                    ret.all[i + 1] += ret.all[i] / 10;
                    ret.all[i] %= 10;
                    ret.len = i + 2;
                } else if (ret.all[i]) ret.len = i + 1;
            } return ret;
        }
        number& operator+=(const number& n) {
            for (int i(0); i != std::max(len, n.len); ++i) {
                all[i] += n.all[i];
                if (all[i] >= 10) ++all[i + 1], all[i] -= 10;
            }
            len = std::max(len, n.len);
            if (all[len]) ++len;
            return *this;
        }
        number operator+(const number& n) const {
            number v(len);
            for (int i(0); i != len; ++i) v.all[i] = all[i];
            return v += n;
        }
        bool operator!=(const number& n) const {
            if (len != n.len) return true;
            for (int i(0); i != len; ++i) if (all[i] != n.all[i]) return true;
            return false;
        }
        void print() const { for (int i(len - 1); ~i; --i) printf("%d", all[i]); printf("\n"); }
        int all[112], len;
};
bool bVis[maxn][maxn];
int n, k;
number dp[maxn][maxn];
int main() {
    scanf("%d%d", &n, &k);
    for (int i(1); i <= n; ++i) {
        dp[i][1] = i;
        dp[i][i] = 1;
        for (int j(2); j < i; ++j) {
            dp[i][j] += dp[i - 1][j] + dp[i - 1][j - 1];
        }
    }
    number ans;
    ans = 1;
    for (int i(1); i <= k && (i << 1) <= n - 1; ++i) {
        ans += dp[n - 1][i << 1];
    } ans.print();
    return 0;
}
```

有没有更不需要脑子的方法呢？当然是有的——**DP**。

仍然按照翻转0/1序列的方式来思考。令dp[a][b][c]为“对长度为a+1的序列进行b次翻转操作，其中第一个元素的值为c”的不同方案数。

如果c==true,那么第一个元素是被翻转的，于是后面可以跟上一串1而不需要消耗翻转操作次数，因为这**仅仅是扩张了前面所使用的区间**。

我们**只考虑第2个元素是否翻转**，按照c的值进行讨论。递归边界是(b==0且c==false)或者(n==0)。注意，即使b==0了，若c为true，我们仍然可以继续翻转。

dp的方法要更容易想到一些，当然由于各种递归也会慢一些。

```cpp
//法2 ： dp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

const int maxn(112);
class number {
	public:
		number() : len(0) { memset(all, 0, sizeof(all)); }
		number(int l) : len(l) { memset(all, 0, sizeof(all)); }
		
		number operator=(int v) {
			len = 0;
			while (v) {
				all[len++] = v % 10;
				v /= 10;
			} return *this;
		}
		number operator*(const number& n) const {
			number ret;
			for (int i(0); i != len; ++i) {
				for (int j(0); j != n.len; ++j) {
					ret.all[i + j] += all[i] * n.all[j];
				}
			}
			for (int i(0); i != len + n.len; ++i) {
				if (ret.all[i] >= 10) {
					ret.all[i + 1] += ret.all[i] / 10;
					ret.all[i] %= 10;
					ret.len = i + 2;
				} else if (ret.all[i]) ret.len = i + 1;
			} return ret;
		}
		number& operator+=(const number& n) {
			for (int i(0); i != std::max(len, n.len); ++i) {
				all[i] += n.all[i];
				if (all[i] >= 10) ++all[i + 1], all[i] -= 10;
			}
			len = std::max(len, n.len);
			if (all[len]) ++len;
			return *this;
		}
		number operator+(const number& n) const {
			number v(len);
			for (int i(0); i != len; ++i) v.all[i] = all[i];
			return v += n;
		}
		bool operator!=(const number& n) const {
			if (len != n.len) return true;
			for (int i(0); i != len; ++i) if (all[i] != n.all[i]) return true;
			return false;
		}
		void print() const { for (int i(len - 1); ~i; --i) printf("%d", all[i]); printf("\n"); }
		int all[112], len;
};
bool bVis[maxn][maxn][2];
int n, k;
number dp[maxn][maxn][2];
number& dfs(int n, int k, bool h) {
	if (bVis[n][k][h]) return dp[n][k][h];
	bVis[n][k][h] = true;
	number& state(dp[n][k][h]);
	if (!h && k == 0) { state = 1; return state; }
	if (n == 0) { state = 1; return state; }
	if (h) {
		state += dfs(n - 1, k, false);
		state += dfs(n - 1, k, true);
		return state;
	} else {
		state += dfs(n - 1, k, false);
		if (k) state += dfs(n - 1, k - 1, true);
		return state;
	}
}
int main() {
	scanf("%d%d", &n, &k);
	dfs(n - 2, k, false).print();
	return 0;
}
```

---


# 小红帽的回文数

## 题目描述

小红帽喜欢回文数，但生活中的数常常不是回文数。现在她手上有 $t$ 个数，现在她知道这 $t$ 个数分别在 $x$ 进制下是回文数（$x \ge 2$），请你对于每个数求出最小的 $x$。

## 说明/提示

$1$ 在二进制下为 $1$，$4$ 在三进制下为 $11$。

$21$ 在 $2$ 进制下为 $10101$，$345332$ 在 $114$ 进制下为 $266526$。

## 样例 #1

### 输入

```
4
1
4
21
345332```

### 输出

```
2
3
2
114```

# 题解

## 作者：暮天闻角 (赞：23)

#### 我是蒟蒻，，，，，，
------------

这道题嘛，第一眼以为是~~直接枚举~~；

然而，一看a的取值范围，显然不是裸暴力；

仔细一看题意，显然，$ a[i]+1 $进制一定是使$ a[i] $成为回文串的一种情况；

同时，$ a[i]-1 $进制也一定是使$ a[i] $成为回文串的一种情况(得到11)；

但题目要求最小的进制；

然后，考虑进制数的特殊性质，即这个进制数超过了$ \sqrt{a[i]} $之后，

a[i]转换进制后得到的数一定是两位数(考虑当进制数为$ a[i] $的情况可知)；

那么不妨设满足条件的两位数字均为j(由回文串可知)，那么一定有:

$$ j*x+j=a[i]; $$

-----------------------------------------------(其中$ x $为进制数,$ x > \sqrt{a[i]} $)-----------------------------------------------

$$ j*(x+1)=a[i]; $$
$$ x=a[i]/j-1; $$
那么在 $ x > \sqrt{a[i]} $ 的情况下,只要找到一个j是a[i]的一个因数，

那么$ a[i]/j-1 $就是题目的一个答案

至于$ x < \sqrt{a[i]} $的情况嘛，暴力跑一遍就好了，然后还有一两句特判，

贴上AC代码，，，各位大佬可以优化一下，，，

```cpp
#include <cmath>
#define maxn 30
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
inline char GET_CHAR(){//读优卡常 
    static char buf[maxn],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
}
template<class T>inline void read(T &x){//读优背一下就OK 
    x=0;int f=0;char ch=GET_CHAR();
    while(ch<'0'||ch>'9')  {f|=(ch=='-');ch=GET_CHAR();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=GET_CHAR();}x=f?-x:x;
}
bool f;
int T;
LL x;
LL re[1000];//注意long long 
inline bool judg(LL sta,LL n){
    f = true;
    int pos=0;
    while(n){
        //强迫症 
        //转进制 
        re[++pos]=
        n-n/sta*sta;
        n /= sta;
    }
    int l=pos>>1,r=((pos+1)>>1)+1;
    //等价于 l=pos/2,r=(pos+1)/2+1; 
    for(int i=l,j=r;i && j<=pos;--i,++j)
    //我跑的比较奇葩
    //从中间向两边扫 
        if(re[i]!=re[j]){f=false;break;}
    return f;
}
int main(){
    read(T);
    while(T--){
        x;LL y;
        read(x);//这就是a[i] 
        y=(LL)sqrt((double)x)+1;
        if(x==2){ puts("3");continue; }//特判 
        else if(x<=3){ puts("2");continue; }
        for(LL i=2LL;i<=y;++i)//x<√a[i]
            if(judg(i,x))
                { printf("%lld\n",i);break; }
        if(!f){
            for(LL i=x/y-1;i>=0;--i)//x>√a[i]
                if(x-x/i*i==0)
                    {printf("%lld\n",x/i-1);f=true;break;}
            if(!f) printf("%lld\n",x+1);//应该算最后防线吧，，， 
        }
    }
    return 0;
}
```

---

## 作者：naroto2022 (赞：7)

# P2425 题解

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P2425)

### 题意

给定 $t$ 个数，对于每个数 $n$，求一个最小的 $p$，使得 $n$ 在 $p$ 进制下是回文数。

### 思路

首先看到这道题就想要暴力，但是发现 $n\leqslant 10^{10}$，一看 $O(nt)$ 的暴力复杂度是不行的。

接下来考虑如何优化，注意到一个性质，当 $\sqrt n\leqslant p\leqslant n$ 时，$n$ 在 $p$ 进制下只有两位数，这个可以很好判，而 $p<\sqrt n$ 时直接暴力，暴力到了就直接下一个数，我们来推一下只有两位数的情况。

设 $p$ 满足题意，则有如下式子。

$$\exists i,i<p,i\times p+i=n$$

转化一下。

$$p=\frac{n}{i}-1$$

由于 $p$ 一定要是整数，所以只要从 $\sqrt n$ 开始（因为要满足 $\sqrt n\leqslant p\leqslant n$）从大到小（这样枚举到第一个满足条件的它所对应的 $p$ 一定是最小的）枚举 $i$，满足 $n\bmod i=0$ 且 $p>i$。

如果一个都没有枚举到，那么就输出 $n+1$，因为 $n+1$ 进制下的 $n$ 一定是 $n$，回文。

于是就可以快乐地对了这道题啦~

### 实现细节

1. 注意从大到小枚举 $i$。
2. 注意有没有 $i$ 的情况为 $n+1$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int MN=64;
ll n,t[MN],l;
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
bool check(ll x, ll n){//判回文。
    l=0;//长度要初始化。
    while(n){
        t[++l]=n%x;//把每个数统计出来。
        n/=x;
    }
    for(int i=1; i<=l/2; i++) if(t[i]!=t[l-i+1]) return false;
    return true;
}
void solve(){
    n=read();
    for(int i=2; i<=sqrt(n); i++) if(check(i,n)){write(i);putchar('\n');return;}//暴力判断小于等于根号n。
    for(int i=sqrt(n); i>=1; i--) if(n%i==0&&n/i-1>i&&n/i-1>sqrt(n)){write(n/i-1);putchar('\n');return;}//只要加这一句就AC了！
    //枚举i*p+i=n的i，注意有if中的限制，由于要最小的p，那么就从大到小来枚举i。
    write(n+1);putchar('\n');//前面的都不行，n+1进制的n一定是n，回文。
}
int main(){
    ll T=read();while(T--)solve();
    return 0;
}
```

---

## 作者：Zxsoul (赞：3)

枚举暴力水题

**思路**
很显然，你可以暴力，然后 $50$ 分
```c
int n,num[A];
main()
{
	int x;
	n=read();
	while (n--)
	{
		x=read();
		if (x==1) {printf("2\n"); continue;}
		for (int base=2;base<=x;base++)
		{
			int s=x,cnt=0;
			while (s)
			{
				num[++cnt]=s%base;
				s=s/base;
			}
			
			int l=1,r=cnt,flag=0;
			while (l<=r)
			{
				if (num[l]==num[r]) l++,r--;
				else
				{
					flag=1;
					break;
				}
			}
			if (!flag) {printf("%lld\n",base);break;}
		}
	}
}
```
我们尝试优化，我们发现：当进制大于 $\sqrt n$ 时，产生的回文子串长度为 $2$，我们不妨假设 当进制为 $x$ 时满足的条件,回文数为 $j$,则有：
$$
j\times x+j=a[i]
$$

化简得：

$$
\frac{a[i]}{j}-1=x
$$

不难发现，$x$ 必须是整数,所以 $j$ 要满足的条件就是被 $a$ 整除

那么 $j$ 的范围是多大呢？

我们已知 $\sqrt n \le x$ 由上面式子代换得
$$
	j \le \frac{a[i]}{\sqrt n-1}
$$

所以 $\sqrt n$ 以前的正常暴力枚举，之后的可以利用以上办法减少时间消耗

顺便说一句：如果你真的想搞懂题目，请自己手推，不要看tj
```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 1e7+10;
const int B = 1e4+10;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int n,num[A];
main()
{
	int x;
	n=read();
	while (n--)
	{
		int pt=0;
		x=read();
		if (x==2) {printf("3\n"); continue;}
		if (x<=3) {printf("2\n"); continue;}
		for (int base=2;base<=sqrt((double)x)+1;base++)
		{
			int s=x,cnt=0;
			while (s)
			{
				num[++cnt]=s%base;
				s=s/base;
			}
			
			int l=1,r=cnt,flag=0;
			while (l<=r)
			{
				if (num[l]==num[r]) l++,r--;
				else
				{
					flag=1;
					break;
				}
			}
			if (!flag) {pt=1;printf("%lld\n",base);break;}
		}
		if (pt==1) continue;
		for (int i=x/(sqrt(x)+1);i>=1;i--)
		{
			if (x%i==0) {printf("%lld\n",x/i-1);break;}
		}
	}
}

```

---

## 作者：jyz666 (赞：2)

# 题解 P2425 【小红帽的回文数】

[传送门](https://www.luogu.com.cn/problem/P2425)

蒟蒻又来写题解啦。。。

_十年OI一场空，不开longlong见祖宗_

------------

不难看出，这题有个规律，对于一个大于$2$的正整数$n$ 在$n-1$进制下表示为$1 1 $  在$>n$的进制下也是一个回文数。

一般对于一个大数据，常常不整体上计算，把一个大数据拆分为小数据可以使计算更加简便

常用的拆分方法：二分（分治）

对于此题 把其分为在$x$进制下是二位数的情况和在$x$进制下不是二位数的情况；

对于是二位数的情况 我们可以把$n$在$x$进制下的数看为$P$。

所以可以得出等式 $n=x*P+P=P*(x+1)$  由此等式进行判断，对于不是二位数的情况就可以直接枚举了。

在我看来 本题最重要的的不外乎两点：

1. 变量类型（对于AC很重要）

1. 分情况（对于不爆零很重要）

### 上核心代码》》

```cpp
int chk(ll x,ll y){
	int f=1;
	while(y>=x){
		s[f]=y%x;
		y/=x;
		f++;
	}
	s[f]=y;
	for(int i=1;i<=(i+f)/2;i++){
		if(s[i]!=s[f+1-i])return 0;
	}
	return 1;
}

void work(ll x){
	if(x==2){
		cout<<3<<endl;
		return;
	}
	if(x<=3){
		cout<<2<<endl;
		return;
	}
	ll y=(ll)sqrt((double)x)+1; 
	for(int i=2;i<=y;i++){
		if(chk(i,x)){
			cout<<i<<endl;
			return ;
		}
	}
	for(int i=x/y-1;i>=1;--i){
		if(x-x/i*i==0){
			cout<<x/i-1<<endl;
			return ;
		}
	}
}
```

 _**环境不会改变，解决之道在于改变自己。**_ 


---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2425)

## 题目大意：

多次询问，每次询问给定 $q$，求最小的 $m$ 使得 $q$ 在 $m$ 进制下是一个回文数。

## 注意：

注意样例解释中这一行：

>$345332$ 在 $114$ 进制下为 $266526$。

看起来$266526$ 并不是一个回文数，但其实这里面的 $266526$ 其实是 $114$ 进制的三个位，分别是 $26$、$65$、$26$，所以这是一个回文数。

## 思路：

考虑一个裸的暴力，直接暴力枚举每个 $a_i$ 在某一进制下的表示再判断其是否回文，但注意到 $a_i \le 10^{10}$ 的同时 $t \le 1000$，所以是不可取的。

考虑优化这个暴力，注意到它主要的时间复杂度是在枚举进制上，但是对于一个进制 $k$，只要 $a_i \le k^2$，那么 $a_i$ 在 $k$ 进制下的表示就只有两位了，所以暴力判断只需要到 $\sqrt{a_i}$ 就可以停了。

那么再考虑对于一个进制 $k$，$a_i$ 的表示只有两位的情况下，显然可以得到 $a_i=w \times k + v$，那如果回文就是 $w=v$ 的情况了，即 $a_i=w \times k + w$，变形，得 $a_i=w \times (k+1)$，移项，得 $k=\frac{a_i}{w} - 1$，接下来就一目了然了，只需要找一个 $w$ 是 $a_i$ 的因数就能得到答案了。

注意特判 $a_i \le 3$ 的情况。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long  long m[1000005];
long  long from10toy(long  long x,long  long y){
	long  long a=0,qw=0;
	while(1){
		if(x<y&&x>=1){
			qw=x;
			break;
		}
		if(x==0){
			break;
		}
		a++;
		m[a]=x%y;
		x=x/y; 
	} 
	if(qw!=0) m[++a]=qw; 
	return a;
}//进制转化 
bool checker(long  long c){
	for(long  long i=1,j=c;i<=c/2;i++,j--){
		if(m[i]!=m[j]) return false;
	}
	return true;
}//判断回文 
long  long t;
long  long q;
int main(){
	cin>>t;
	for(long  long i=1;i<=t;i++){
		cin>>q;
		if(q==1) cout<<1<<endl;
		else if(q==2) cout<<3<<endl;
		else if(q==3) cout<<2<<endl;
		//特判 
		else{
			long  long g=ceil(sqrt(q*1.0)),f=0;
		    for(long  long j=2;j<=g;j++){
		    	long  long v=from10toy(q,j);
		    	if(checker(v)==true){
			    	cout<<j<<endl;
		    		f=1;
				break;
		    	}
		    }//小于根号a_i，暴力求答案 
	    	if(f==0){
		    	for(int j=q/g-1;j>=0;j--){
		        	if(q-q/j*j==0){
		    	    	cout<<q/j-1<<endl;
		        		f=1;
		    	    	break;
		        	}
	        	} 
		    } //大于根号a_i 
		}
	}
	return 0;
} 
```

---

## 作者：CaiZi (赞：1)

校内模拟赛考到了这题，于是记录一下。

妙妙题。

首先可以考虑枚举进制 $x$，其上限为 $a_i+1$，然后一一判断，但是这样会 TLE。

我们可以注意到一个性质，因为数 $a_i$ 要在 $x$ 进制下有 $3$ 位及以上，需要 $a_i\ge x^2$。因此考虑以 $\sqrt{x}$ 为阈值，对于 $2\le x\le\sqrt{n}$ 同样暴力判断。而对于 $\sqrt{n}<x\le a_i+1$，此时只要判断在 $x$ 进制下第 $1$ 位是否等于第 $2$ 位即可，符合条件的 $x$，只需要存在 $y$ 使得 $y<x,xy+y=a_i$，即 $y(x+1)=a_i$ 即可。考虑枚举 $a_i$ 的因数 $y$，此时 $x$ 是从小到大的，直接判断是否符合条件即可。这部分时间复杂度也是 $O(\sqrt{n})$ 的。

如果上述方法任然无法找到答案，显然在 $a_i+1$ 进制下，这个数为 $1$，总是回文数。事实上，只有 $1,2$ 两个数有这种情况。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m;
bool g;
inline bool check(int a,int b){
	int c=0,d[35];
	while(a){
		c++;
		d[c]=a%b;
		a/=b;
	}
	for(int i=1;i<=c;i++){
		if(d[i]!=d[c-i+1]){
			return false;
		}
	}
	return true;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t;
	while(t--){
		g=false;
		cin>>n;
		m=floor(sqrt(n));
		for(int i=2;i<=m;i++){
			if(check(n,i)){
				g=true;
				cout<<i<<'\n';
				break;
			}
		}
		if(!g){
			for(int i=m;i>=1;i--){
				if(n%i==0&&n/i-1>m){
					g=true;
					cout<<n/i-1<<'\n';
					break;
				}
			}
			if(!g){
				cout<<n+1<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：程门立雪 (赞：1)

# 小红帽的回文数

**题解：**

对于一个数$a[i]$ , $a[i] + 1$进制一定能使它成为回文串，$a[i] - 1$进制也一定能使它成为回文串， （例如： $8$， 在$9$进制下是$8$，在$7$进制下为$11$），所以进制$x\leq a[i] + 1$ 。


当进制数超过了$\sqrt{a[i]}$之后， $a[i]$进制转换得到的数字一定是两位数， （可以举几个例子， 如：$16$的$5$进制数是$31$，$4$的$3$进制数是$11$），因为当进制是$\sqrt{a[i]}$时，正好为$100$， 如果进制数$x$超过了$\sqrt{a[i]}$，有第三位的话，这个数至少表示的是 $ x ^ 2$，是不成立的。


当$x > \sqrt{a[i]} $时，
可以设转化后的回文数的两位数均为$b$（因为是回文串），


$a[i] = b * x + b$        
$a[i] = b * (x + 1)$      
$x = a[i]/b - 1$

当$x \leq \sqrt{a[i]} $时，暴力枚举$x$。
```c
#include <cstdio>
#include <iostream>
#include <cmath>
#define orz cout << "AK IOI" <<"\n"
#define int long long 

using namespace std;
const int maxn = 1010;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}
	return x * f;
}
int n, a, number[10000000];

bool judge(int num, int x)
{
	int cnt = 0;
	while(num > 0)
	{
		number[++cnt] = num % x;
		num /= x;
	}
	int mid;
	if(cnt % 2 == 1) mid = (cnt - 1) / 2;
	else mid = cnt / 2;
	for(int i = 1; i <= mid; i++)
	if(number[i] != number[cnt - i + 1]) return 0;
	return 1;
}
signed main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    n = read();
    for(int i = 1; i <= n; i++) 
	{
		a = read();
		int flag = 0;
		if(a == 2){printf("3\n"); continue;}
		if(a == 1 || a == 3){printf("2\n"); continue;}
		
		int f = sqrt(double(a));         //分界线 
		for(int j = 2; j <= f + 1; j++)
			if(judge(a, j)) {printf("%lld\n", j); flag = 1; break;}
			
		if(!flag)
		{
			for(int j = f - 1; j >= 0; j--) //枚举的是b 
			{
				if(a % j == 0)
				{
					printf("%lld\n", a / j - 1);
					break;
				}
			}	
		}
	}
	return 0;
}
```

---

## 作者：槑小杨 (赞：1)

显然，此题直接枚举会超时。

假设这个数字为$a$。

考虑当$a$的进制$f(a) \geq a$时在$f(a)$进制下$a$就为$a$，是一位数那么为回文数。

考虑当$f(a)=a-1$时，$f(a)$下也是回文，然而题目中要求找到最小的回文数。

再考虑$f(a)>\sqrt{a}$时，转制以后这个数为两位数，因为要为回文数，那么第一位数与第二位数相等，我们假设这个位上的数字为$w$，那么经过代数变形可以得到：
$$w\times f(a)+w=a$$
$$w\times [f(a)+1]=a$$
$$f(a)=\frac{a}{w}-1$$

显然，$w$是$a$的因子。

对于$f(a) \leq \sqrt{a}$，暴力枚举判断一下$w$就好了，不担心超时。

贴代码：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL n,a[10000],f;
bool judge(LL c,LL sta)
{
    f=1;
    int pos=0;
    while(c)
    {
        a[++pos]=c-c/sta*sta;
        c/=sta;
    }
    for(LL i=1,j=pos;i<=j;i++,j--)
    {
        if(a[i]!=a[j])
        {
            f=0;
            return f;
            break;
        }
    }
    return f;
}
int main()
{
    LL x;
    scanf("%lld",&n);
    while(n--)
    {
        scanf("%lld",&x);
        if(x==2)
        {
            printf("3\n");
            continue;
        }
        if(x<=3)
        {
            printf("2\n");
            continue;
        }
        LL p=(LL)sqrt((double)x)+1;
        for(LL i=2LL;i<=p;i++)
        {
            if(judge(x,i))
            {
                printf("%lld\n",i);
                break;
            }
        }
        if(!f)
        {
            for(LL i=x/p-1;i>=0;i--)
            {
                if(x==x/i*i)
                {
                    printf("%lld\n",x/i-1);
                    f=1;
                    break;
                }
            }
            
            if(!f)printf("%lld\n",x+1);
        }
    }
}
```

最后：

**十年OI一场空，不开longlong见祖宗！！**


---

## 作者：stywzh (赞：1)

## 蒟蒻第一篇题解

这个题是之前看洛谷网校春季营回放的时候看到的。。
 
主要是看着是~~蓝题还~~~~很简单~~ 

但做起来还是踩了几个坑(~~疯狂打脸~~)
 
代码写成了这样

------------
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#define csh flag=0;memset(w,0,sizeof(w));cnt=0
using namespace std;

int n,a,w[10101010],cnt;
bool flag;

inline int read()
{
    int s=0,r=1;
    char c=getchar();
    while(c<'0'||c>'9')if(c=='-'){r=-1;c=getchar();}
    while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}
    return s*r;
}


inline bool hw()
{
    int e;
    if(cnt%2==1)e=(cnt-1)/2;
    else e=cnt/2;
    for(int i=1;i<=e;i++)
        if(w[i]!=w[cnt-i+1])return false;
    return true;
}

inline bool pd(int x,int y)
{
    while(x>0)
    {
        w[++cnt]=x%y;
        x/=y;
    }
    return hw();
}


int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        a=read();
        csh;
        if(a<=3){printf("2\n");continue;}
        for(int j=2;j<=sqrt(a)+1;j++)
        {
        	csh;
            if(pd(a,j))
            {
                printf("%d\n",j);
                flag=1;
            }
            if(flag)break;
        }
        for(int j=a/sqrt(a)-1;j>=1;j--)
        {
        	if(flag)break;
            if(a%j==0)
            {
                printf("%d\n",j);
                break;
            }
        }
    }
    return 0;
}
```
------------
提交后就[这样](https://www.luogu.org/record/24493155)了 
 
 其实原因很简单，我在每一次循环的时候都执行了'csh'语句；而每一次执行又有一个对10101010下标的数组的清空，而对于样例中的345332会循环800+次，这就意味着会清空800+次，而实际上，只要把cnt归零就可以了。。。
## 在循环中一定少用memset！！！


------------
在折腾一番之后，终于AC了，最后附上AC代码


------------
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>   //头文件
#define ll long long
using namespace std;

ll n,a,w[10101010],cnt,tot;
bool flag;

inline ll read()   //快读板子
{
    ll s=0,r=1;
    char c=getchar();
    while(c<'0'||c>'9')if(c=='-'){r=-1;c=getchar();}
    while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}
    return s*r;
}

inline void write(ll x)   //快写板子
{
    if(x<0){putchar('-'),x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}

inline bool hw()
{
    ll e;
    if(cnt%2==1)e=(cnt-1)/2;	
    else e=cnt/2;			//计算中间位置
    for(int i=1;i<=e;i++)
    {
        if(w[i]!=w[cnt-i+1])return false;  //判断回文数
    }
    return true;
}

inline bool pd(ll x,ll y)
{
	cnt=0;
    while(x>0)
    {
        w[++cnt]=x%y;
        x/=y;      //进制转换
    }
    return hw();
}


int main()
{
    n=read();
    for(ll i=1;i<=n;i++)
    {
        a=read();
        flag=0;
        ll b=sqrt((double)a);
        if(a==2){printf("3\n");continue;} //如果是2，在二进制下是10，而在三进制下则是1，一个数一定就是回文数了
        if(a<=3){printf("2\n");continue;}//对于一和三来说在二进制一个是1一个是11，都是回文数
        for(ll j=2;j<=b+1;j++)
        {
            if(pd(a,j))
            {
               	write(j);
               	printf("\n");
            	flag=1;
            }
            if(flag)break;
        }
        for(ll j=b-1;j>=1;j--)//详细的内容下文讲解
        {
        	if(flag)break;
            if(a%j==0)
            {
                write(a/j-1);
                printf("\n");
                break;
            }
        }
    }
    return 0;
}
```
 然后是对一些进制规律的~~具体~~讲解：
 
 1、用除法知识可知:
 X÷（X-1）= 1······1；

也就是说，X在（X-1）进制下一定是11；

所以最坏的结果就是X-1;

2、对于大于√X的进制来说，X一定是一个二位数：

以√X进制举例：

如果转过进制的数是100；
第二位一个1，代表一个√X，

而第三位的一个1，就代表√X个√X，即X，

所以X在大于√X进制下一定是个二位数；

3、这就意味着X=y*z+y就是回文数的唯一情况；

y是数字，z是进制；

提取公因式之后就变成了X=y*（z+1）；

所以我们可以枚举出能被X整除的y，输出商-1就可以了

值得注意的是这只能出现在枚举√X+1到X-1进制中；

大概就是这样，如果还有不理解的可以评论。。。

# 祝各位2019CSP RP++！！！！！

---

## 作者：CRH_Beijingzhan (赞：0)

[P2425 小红帽的回文数](https://www.luogu.com.cn/problem/P2425)

### 解题思路

对于本题，单个数据范围为 $10^{10}$，显然不能用 ```int``` 来解决。所以单个数据的变量类型要为 ```long long```。

不然的话，总会有几个点因为溢出而 ```WA```。保险起见，对于此题也可以把所有变量类型都变为 ```long long``` 类型。

不难看出对于一个大于 2 的正整数 $n$ 在 $n-1$ 进制下表示为 1，在大于 $n$ 的进制下也是一个回文数。

一般对于一个大数据，常常不整体上计算，把一个大数据拆分成小数据可以让计算更加简便，也就是二分。

对于此题，把其分在 $x$ 进制下是两位数的情况和在 $x$ 进制的情况下不是两位数的情况：对于是两位数的情况，我们可以把 $n$ 在 $x$ 进制下的数看作为 $j$,所以可以得出等式 $n=x×j+j=j×(x+1)$。

对于不是两位数的情况就可以直接枚举了！

### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int t;
ll x,y,tmp;
ll a[10001];
int pd(ll x,ll y){
    int flag=1;
    while(y>=x){
        a[flag]=y%x;
        y/=x;
        flag++;
    }a[flag]=y;
    for(int i=1; i<=(i+flag)/2; i++){
        if(a[i]!=a[flag+1-i]){
            return 0;
        }
    }return 1;
}ll jc(ll x){
    ll xx=(ll)sqrt((double)x)+1;
    for(int i=2; i<=xx; i++){
        if(pd(i,x)) return i;
    }for(int i=x/xx-1; i>=1; i--){
        if(x-x/i*i==0) return x/i-1;
    }
}int main(){
    cin>>t;
    while(t--){
        cin>>y;
        if(y==2){
            cout<<3<<endl;
            continue;
        }else if(y<=3){
            cout<<2<<endl;
            continue;
        }tmp=jc(y);
        cout<<tmp<<endl;
    }return 0;
}
```

---

## 作者：lbh666 (赞：0)

## 思路分析

若答案 $x \le \sqrt n$，考虑直接从 $2$ 枚举到 $\sqrt n$，暴力判断即可。

但是若 $n > x > \sqrt n$，暴力枚举一定会超时。我们发现 $n$ 在 $x$ 进制下只能是一个两位数。又由于 $n$ 在 $x$ 进制下应该回文，所以这两位上的数必须相等，记这个相等的数为 $y$。

那么根据位值原理，有 $y(x+1) = n$，所以 $x + 1 \mid n$。于是我们从小到大地枚举 $n$ 的因数 $d$，满足 $d > \sqrt n$。这时就会有 $x = d-1$，第一个满足条件即为最优解。

## 代码实现

判断了一些不必要的上下界，如 $\lceil \sqrt n \rceil$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,l,r) for(int i=l;i<=r;++i)
#define debug cout<<"debug\n"
using namespace std;

const int N=1005;
int T,n;
int a[N];

bool check(int k){
	int tot=0,m=n;
	while(m){
		a[++tot]=m%k;
		m/=k;
	}
	if(tot==1)return 1;
	for(int i=1;i<=tot/2;++i){
		if(a[i]!=a[tot+1-i])return 0;
	}
	return 1;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>T;
	while(T--){
		cin>>n;
		if(n==1 || n==2){
			cout<<"2\n";
			continue;
		}
		int t=ceil(sqrt(n));
		bool flag=0;
		rep(i,2,t){
			if(check(i)){
				flag=1;
				cout<<i<<"\n";
				break;
			}
		}
		if(flag)continue;
		int p=floor(sqrt(n))-1; 
		for(int i=p;i>=1;--i){
			if(n%i==0){
				cout<<n/i-1<<"\n";
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：HHC883 (赞：0)

# 题目分析
若答案 $x$ 不超过 $\sqrt{a_i}$，可以直接暴力地从小到大枚举所有 $2 \le j \le \sqrt{a_i}$，并判断当 $x = j$ 时是否满足条件。

但是，当答案 $x > \sqrt{a_i}$ 时，暴力枚举就会超时。不过，我们发现，当 $x > \sqrt{a_i}$ 时，$a_i$ 在 $x$ 进制下是一个两位数。又由于 $a_i$ 在 $x$ 进制下应当是回文数，所以这两位还必须相同。于是我们就可以设这两位都是 $n$，则由位值原理可得 $a_i = nx + n$，即 $a_i = n (x + 1)$。那么我们只要枚举所有 $a_i$ 的因数 $d$，令 $n = d , x = \frac{a_i}{d} - 1$，并判断是否满足 $n < x$，最后取最小的 $x$ 即可。

时间复杂度 $O(\sum \sqrt{a_i} \log {a_i})$。
# 参考代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int t,n;
int res[40];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		bool has_ans=false;
		for(int i=2;i*i<=n;i++){
			int cnt=0;
			int tmp=n;
			while(tmp){
				res[++cnt]=tmp%i;
				tmp/=i;
			}
			bool flag=true;
			for(int j=1;j<=cnt;j++){
				if(res[j]!=res[cnt-j+1]){
					flag=false;
					break;
				}
			}
			if(flag){
				has_ans=true;
				cout<<i<<'\n';
				break;
			}
		}
		if(!has_ans){
			int ans=1e18;
			for(int i=1;i*i<=n;i++){
				if(n%i==0){
					if(i<n/i-1) ans=n/i-1;
				}
			}
			if(ans==1e18) cout<<n+1<<'\n';
			else cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：许多 (赞：0)

我们首先思考暴力枚举怎么做。

一个比较好想的思路就是我们从 $2$ 开始枚举 $x$，把这个数用 $x$ 进制表示出来，检查一下是否回文。

```cpp
bool check(LL x){
    LL aa=a;
    p[0]=0;//p数组存储a的x进制
    while(aa){
        p[++p[0]]=aa%x;
        aa/=x;
    }
    for(LL i=1;i<=p[0]/2;i++)
        if(p[i]!=p[p[0]-i+1])
            return 0;
    return 1;
}
```

这样显然是拿不到满分的。我们~~通过瞪眼法~~能发现一个性质：当 $x>\sqrt{a}$ 时，转换完进制后最多是两位数。

用反证法很好证明，即使是最小的三位数也满足 $100=x^2>a$。

我们就可以进行一个分类讨论，对于 $x\le \sqrt{a}$ 进行暴力枚举，对于剩下的部分我们单独计算。

不妨设转换完进制后两位数上的数都是 $q$，则有 $q+qx=a$，即 $q=\frac{a}{x+1}$，我们只需要枚举 $a$ 的因数即可。

# code

```cpp
#include<bits/stdc++.h>
#include<cstdio>
#define LL long long
#define run puts("Ilikecxn")
#define N 100
using namespace std;
inline LL read(){
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
LL t,a;
LL p[N];
bool check(LL x){
    LL aa=a;
    p[0]=0;
    while(aa){
        p[++p[0]]=aa%x;
        aa/=x;
    }
    for(LL i=1;i<=p[0]/2;i++)
        if(p[i]!=p[p[0]-i+1])
            return 0;
    return 1;
}
int main(){
    t=read();
    while(t--){
        a=read();
        if(a==0||a==1){puts("2");continue;}
        LL nx=-1;
        for(LL x=2;x*x<a;x++){
            if(check(x)){
                printf("%lld\n",x);
                goto wacxn;
            }
            if(a%x)continue;
            nx=a/x;
        }
        if(nx==-1)printf("%lld\n",a-1);
        else printf("%lld\n",nx-1);
        wacxn:;
    }
    return 0;
}
```

---


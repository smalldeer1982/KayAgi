# [HAOI2010] 工厂选址

## 题目描述

某地区有 $m$ 座煤矿，其中第 $i$ 号矿每年产量为 $a_i$ 吨。现有一火力发电厂，每年需用煤恰好 $b$ 吨，每年运行的固定费用（不包括煤的运费）为 $h$ 元，每吨原煤从第 $i$ 号矿运到火力发电厂的运费为 $C_{i,0}$ 元。

现规划新建一个发电厂， $m$ 座煤矿每年开采的原煤将全部供给这两座发电厂。有 $n$ 个备选的新发电厂厂址，若在第 $j$ 号备选厂址建新厂，每年运行的固定费用为 $h_j$ 元；每吨原煤从第 $i$ 号矿运到第 $j$ 号备选厂址的运费为 $C_{i,j}$ 元。

试问：应如何选取新厂厂址并分配 $m$ 座煤矿开采的原煤，才能使每年的总费用（发电厂运行费用与原煤运费之和）最小。

## 说明/提示

对于$100 \%$的数据，$1 \leq m \leq 5 \times 10^4$，$1 \leq b \leq 10^4$，$1 \leq n \leq 50$，$0 \leq h , h_i \leq 100$，$0 \leq a_i \leq 500$，$\sum\limits_{i=1}^m a_i \geq b$，$0 \leq C_{i,j} \leq 50$。

## 样例 #1

### 输入

```
4 2 7 9 
3 1 10 3 
6 3 7 1 10 2 7 4 9 
1 2 4 3 
6 6 8 2 
4 10 8 4 
10 2 9 2 
7 6 6 2 
9 3 7 1 
2 1 6 9 
3 1 10 9 
4 2 1 8 
2 1 3 4 ```

### 输出

```
8 
49 ```

# 题解

## 作者：我好蒻呀 (赞：8)

# 70分算法：费用流

- 我们可以将煤看做流量，通过**最小费用最大流**来算出我们的最小费用。

- 枚举新厂地址$now$，每次都重新建图，将最大流控制在$\sum{a_i}$，并控制送到两厂的煤的数量，来求最小费用。

- 建图如下：

- 从源点向第$i$座煤矿连一条容量为$a_i$，费用为$0$的边，表示第$i$号矿每年产量为$a_i$吨。

- 从第$i$座煤矿向旧厂连一条容量为$INF$（煤的数量已经在前面限制过），费用为$c_{i,0}$的边，表示从这座煤矿送煤到旧厂的单位费用为$c_{i,0}$（它需要的煤数量会在后面限制，而不能在这里限制，肯定会出错，因为$b$是送到旧厂的煤的**总数**）。

- 同理，从第$i$座煤矿向新厂连一条容量为$INF$（煤的数量已经在前面限制过），费用为$c_{i,now}$的边，表示从这座煤矿送煤到旧厂的单位费用为$c_{i,now}$。

- 最重要的部分——从原厂向汇点连一条容量为$b$，费用为$0$的边；从新厂向汇点连一条容量为$\sum{a_i}-b$，费用为$0$的边。因为原厂需要$b$个单位的煤矿**（这里要求送来的煤严格等于$b$，不能多也不能少）**，我们需要用这条边限制；对于新厂，因为我们需要将所有煤都送出，因此送到新厂的煤就是$\sum{a_i}-b$，我们也同样连一条边限制。

- 这里我们可以将第$i$座煤矿的编号看做$i$，原厂编号看做$m+1$，新厂编号看做$m+2$，源点汇点编号分别看作$0$和$m+3$。

- 因为旧厂和新厂还有自己的运行费用，而费用流求出来的只是运输费用，因此我们最后还要用(运输费用+$h_0+h_{now}$)来更新答案。

- 建图如下图所示：（cap表示容量，w表示单位费用）

 ![](https://cdn.luogu.com.cn/upload/pic/6310.png) 

- 代码如下：

```cpp
#include <cstdio>

inline void read(int &x)
{
    static char ch; 
    while ((ch = getchar()) < '0' || ch > '9'); 
    x = ch - '0'; 
    while ((ch = getchar()) >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + ch - '0'; 
}

inline int getmin(const int &a, const int &b) {return a < b ? a : b;}

const int MaxN = 55; 
const int MaxM = 5e4 + 10; 
const int MaxB = 1e4 + 10; 
const int INF = 0x3f3f3f3f; 

const int MaxP = MaxM; 
const int MaxE = MaxP * 10; 

int dis[MaxP], src, des; 
int ect = 1, nxt[MaxE], to[MaxE], cap[MaxE], cst[MaxE], adj[MaxP], frm[MaxE], pre[MaxP]; 
int n, m, b, ans = 0, minAns = INF, ansNum; 
int h[MaxN], a[MaxM], c[MaxM][MaxN], tota; 

inline void addEdge(const int &u, const int &v, const int &c, const int &w)
{
    nxt[++ect] = adj[u], adj[u] = ect, to[ect] = v, frm[ect] = u, cap[ect] = c, cst[ect] = w; 
    nxt[++ect] = adj[v], adj[v] = ect, to[ect] = u, frm[ect] = v, cap[ect] = 0, cst[ect] = -w; 
}

inline bool SPFA()
{
    static int q[MaxE << 2], tail; 
    static bool inq[MaxP]; 
    for (int i = src; i <= des; ++i)
        dis[i] = INF; 
    inq[q[tail = 1] = src] = 1; 
    dis[src] = 0; 
    for (int head = 1, u, v, e; inq[u = q[head]] = 0, head <= tail; ++head)
        for (e = adj[u]; v = to[e], e; e = nxt[e])
            if (cap[e] > 0 && dis[v] > dis[u] + cst[e])
            {
                dis[v] = dis[u] + cst[e], pre[v] = e; 
                if (!inq[v])
                    inq[q[++tail] = v] = 1; 
            }
    return dis[des] != INF; 
}

inline void deal()
{
    int minFlow = INF; 
    for (int e = pre[des]; e; e = pre[frm[e]]) minFlow = getmin(minFlow, cap[e]); 
    for (int e = pre[des]; e; e = pre[frm[e]])
    {
        cap[e] -= minFlow; 
        cap[e ^ 1] += minFlow; 
        ans += minFlow * cst[e]; 
    }
}

int now; 
inline void MCMF()
{
    ans = 0; 
    while (SPFA()) deal(); 
    ans += h[0] + h[now]; 
    if (ans < minAns)
        minAns = ans, ansNum = now; 
}

inline void buildGraph()
{
    ect = 1; 
    for (int i = src; i <= des; ++i) adj[i] = 0, pre[i] = 0; 
    src = 0, des = m + 3; 
    for (int i = 1; i <= m; ++i)
        addEdge(src, i, a[i], 0), addEdge(i, m + 1, INF, c[i][0]), addEdge(i, m + 2, INF, c[i][now]); 
    addEdge(m + 1, des, b, 0), addEdge(m + 2, des, tota - b, 0); 
}

int main()
{
    read(m), read(b), read(h[0]), read(n); 
    for (int i = 1; i <= m; ++i) read(a[i]), tota += a[i]; 
    for (int i = 1; i <= n; ++i) read(h[i]); 
    for (int i = 0; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            read(c[j][i]); 
    for (now = 1; now <= n; ++now)
        buildGraph(), MCMF(); 
    printf("%d\n%d\n", ansNum, minAns); 
    return 0; 
}
```
# 100分算法：贪心

- 我们可以枚举新工厂的地址来贪心。

- 设第i个煤矿到新工厂的单位运费为$x_i$，到旧工厂的单位运费为$x_i+delta_i$。

- 那么对于每一单位的煤，它的运费要么是$x_i$，要么是$x_i+delta_i$。

- 由于所有煤的运费中都包含项$x_i$， 有b单位煤的运费中包含项$delta_i$，所以我们只需要使项$delta_i$尽量小，这样就能使整体方案最优。

- 因此我们可以得到以下步骤：

- 枚举新工厂地址$now$；

- 预处理出$delta_i=c[i,0]-c[i,now]$，这里$x_i$就是$c[i,now]$；

- 将煤矿以$delta_i$为关键字从小到大排序。

- 假设我们目前把煤全送到了新工厂，目前费用为$\sum{x_i*a_i}$。那么要有$b$个单位的煤要调到旧工厂，我们贪心将$delta_i$最小的那些煤都送到旧工厂，直到送满$b$为止。每次在第i个煤矿调一单位的煤时，费用应加上$delta_i$。

- 那么我们就算出了新工厂为$now$时符合条件的最优方案，用(运输费用$+h_0+h_{now}$)更新答案即可。

- 外层枚举n个厂址，内层对m个煤矿排序，时间总复杂度为$O(nm\log m)$。


代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

typedef long long ll;
typedef unsigned long long ull;

int getintRes; 
inline int getint()
{
    static char ch; 
    while ((ch = getchar()) < '0' || ch > '9'); 
    getintRes = ch - '0'; 
    while ((ch = getchar()) >= '0' && ch <= '9')
        getintRes = getintRes * 10 + ch - '0'; 
    return getintRes; 
}

inline void read(int &x)
{
    static char ch; 
    while ((ch = getchar()) < '0' || ch > '9'); 
    x = ch - '0'; 
    while ((ch = getchar()) >= '0' && ch <= '9')
        x = x * 10 + ch - '0'; 
}

inline int getmin(const int &a, const int &b) {return a < b ? a : b;}

const int MaxN = 55; 
const int MaxM = 5e4 + 10; 
const int MaxB = 1e4 + 10; 
const int INF = ~0u >> 1; 

struct cyxPair
{
    int delta, count; 
    cyxPair() {}
    cyxPair(const int &d, const int &c):
        delta(d), count(c) {}
    inline bool operator < (const cyxPair &rhs) const
    {
        return delta < rhs.delta; 
    }
}c[MaxM]; 

int n, m, b; 
int a[MaxM], h[MaxN], c0[MaxM]; 
int minAns = INF, numAns; 

#define p(x, y) cyxPair(x, y)

int main()
{
    read(m), read(b), read(h[0]), read(n); 
    for (int i = 1; i <= m; ++i) read(a[i]); 
    for (int i = 1; i <= n; ++i) read(h[i]); 
    for (int i = 1; i <= m; ++i) read(c0[i]); 
    
    int totCount, totAns, tmp;  
    for (int now = 1; now <= n; ++now)
    {
        static int i; 
        totCount = b, totAns = 0; 
        for (i = 1; i <= m; ++i)
            read(tmp), c[i] = p(c0[i] - tmp, a[i]), totAns += tmp * a[i]; 
        std::sort(c + 1, c + m + 1); 
        for (i = 1; i <= m; ++i)
            if (totCount >= c[i].count)
                totCount -= c[i].count, totAns += c[i].delta * c[i].count; 
            else
                break; 
        if (totCount > 0)
            totAns += totCount * c[i].delta; //当我们有剩余的煤要送但不满该煤矿总量，我们也要将剩下的送出
        totAns += h[0] + h[now]; 
        if (totAns < minAns)
            minAns = totAns, numAns = now; 
    }
    printf("%d\n%d\n", numAns, minAns); 
    return 0; 
}
```

---

## 作者：Larryyu (赞：5)

## _Description_
有 $m$ 座煤矿，每一座煤矿有 $a_i$ 吨煤，第 $i$ 座煤矿到第 $j$ 号发电厂的运费为 $c_{i,j}$ 每吨。

有一座发电厂（标号为 ```0```），需要恰好 $b$ 吨煤矿发电，初始运行费用为 $h$。还有 $n$ 座待运行的发电厂（标号为 ```1~n```），每座发电厂初始运行费用为 $h_i$，你需要选择其中一座让它运行起来。

将所有煤分给这两座发电厂，问最小费用是多少。
## _Solution_
这道题的题目描述就是第一个坑，注意以下几点：
- ```0``` 号发电站一定要运行，原题面可能有些表述模糊。
- 对于新的发电站，它分配到的煤为 $tot-b$（其中 $tot=\sum \limits_{i=1}^m a_i$）吨，而不是 $b$ 吨。

发现 $1\le m\le5\times10^4,1\le n\le50$，所以遍历 $n$ 座发电厂，每次遍历所有煤矿，比较选当前的发电厂时的费用是可以过的。

假设当前遍历到 $i$ 号发电厂，若所有煤都在这个发电厂，费用为 $\sum\limits_{j=1}^m a_{j}\times c_{j,i}$ 。
 
因为 ```0``` 号发电厂要选 $b$ 吨，所以费用为 $\sum\limits_{j=1}^m a_{j}\times c_{j,i}-\sum\limits_{k=1}^t a_k\times(c_{k,i}-c_{k,0})$（后面的都是转到 ```0``` 号去了）。为了最小化费用，所以要让 $c_{k,i}-c_{k,0}$ 尽量大，按这个值对每一座煤矿进行排序。然后遍历煤矿，如果还加的进 ```0``` 号（可能整座煤矿加不进，只加的进一部分，需要判断每次加入前 ```0``` 号的剩余空间）就加，加不进就加到 $i$ 号。

然后比较每一座发电站的费用大小即可。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,b,h,n;
int a[50050],w[60],c[60][50050];
struct node{
	int no,val;
}d[50050];
bool cmp(node x,node y){
	return x.val>y.val;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>m>>b>>h>>n;
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=0;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
		}
	}
	int minn=1000000000,ans=0;
	for(int i=1;i<=n;i++){
		int tot=0,sum=h+w[i];  //运行费用别忘了
		for(int j=1;j<=m;j++){
			d[j].no=j;
			d[j].val=c[i][j]-c[0][j];
		}
		sort(d+1,d+1+m,cmp);
		int j=1;
		for(j;j<=m;j++){
			if(b-tot<=a[d[j].no]){  //放不进整座
				sum+=(b-tot)*c[0][d[j].no];
				sum+=(a[d[j].no]-b+tot)*c[i][d[j].no];
				break;
			}
			sum+=a[d[j].no]*c[0][d[j].no];
			tot+=a[d[j].no];  //更新剩余空间
		}
		j++;
		for(j;j<=m;j++){
			sum+=a[d[j].no]*c[i][d[j].no];
		}
		if(sum<minn){
			minn=sum;
			ans=i;
		}
	}
	cout<<ans<<endl<<minn<<endl;
	return 0;
}
```

---

## 作者：Log_x (赞：3)

一开始想到枚举每个备用厂址贪心选取最小费用 $c[i][j]$，建了两个堆后完美爆零。

仔细想想后感觉不对，最小费用并非最优，而且还会影响到后面的选取，于是心态很崩地膜拜了网上代码。

看完代码后仿佛顿悟：**实际上应贪心的是 $c[0][j] - c[i][j]$ 的最小值。**

我们假设都将原煤送至枚举的备用厂址 $i$，然后将 $m$ 座煤矿按 $c[0][j] - c[i][j]$ 从小到大排序，按顺序选取这些煤矿中 $c[0][j] - c[i][j]$ 最小的 $b$ 吨煤运往原火力发电厂，则这样必定是对于备用厂址 $i$ 的最优方案。这是为什么呢？ 首先无论运往哪里，煤产量 $a[j]$ 都是固定不变的，则我们可以不考虑；那么 $c[0][j] - c[i][j]$ 表示运往原火力发电厂较于备用厂址 $i$ 产生的对运煤费用的影响，这个值越小，则总的运煤花费就越小，因此贪心是正确的，这样的时间复杂度为 $O(nmlogm)$。

最后附上代码（感觉贪心没想清楚还是不能瞎写啊）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 55, M = 5e4 + 5;
int val[M], Id[M], c[N][M], a[M], h[N];
int n, b, Ans = Maxn, K, m;

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline bool cmp(const int &x, const int &y) {return val[x] < val[y];}

int main()
{
    m = get(); b = get(); h[0] = get(); n = get();
    for (int i = 1; i <= m; ++i) a[i] = get();
    for (int i = 1; i <= n; ++i) h[i] = get();
    for (int i = 0; i <= n; ++i) 
     for (int j = 1; j <= m; ++j) c[i][j] = get();
    for (int i = 1; i <= n; ++i)
    {
        int sum = h[i], tmp = b;
        for (int j = 1; j <= m; ++j) 
        {
            sum += c[i][j] * a[j];
            Id[j] = j; val[j] = c[0][j] - c[i][j];
        }
        sort(Id + 1, Id + m + 1, cmp);
        for (int j = 1; j <= m && tmp; ++j)
        if (tmp >= a[Id[j]])
         sum += val[Id[j]] * a[Id[j]], tmp -= a[Id[j]]; 
        else sum += val[Id[j]] * tmp, tmp = 0;
        if (sum < Ans) Ans = sum, K = i;
    }
    put(K), putchar('\n'), put(Ans + h[0]);
    return 0;
}
```

---

## 作者：WangXCentury (赞：1)

# 洛谷P2514[HAOI2010]工厂选址
## 解法说明
### 题目大意
有一个厂，需要 $ b$ 吨煤炭，然后第 $ j$  个矿运到该厂的运费为 $c_{0j}$,运行总费用为运费之和加上 $h_0$ 现在在 $ 1∼ n$  挑选一个建一个新厂，其余的煤矿都运到这个厂，第 $ j$  个矿运到该厂的运费为 $c_{ij}$，运行费用为运费之和加上 ${c}_i$ 
求最小费用。
     
### 解题思路
很简单的一道贪心题，显然我们将最优的 $ b$  吨运到旧厂。我们枚举建立在哪个厂，然后对于每个矿将 $c_{0j}−c_i$ 进行从小到大排序，然后将最小的 $ b$  吨运入旧厂就行了。
   
## 代码
```c
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define re register
using namespace std;
int b,c[50005][55],m,n,s[50005],h[100001],a[1000001],d[50001],H,cost[50001],id[50001];
int maxx=999999999,ans;
inline bool cmp(const int &x,const int &y)
{
    return cost[x]<cost[y];
}
int main()
{
    cin>>m>>b>>H>>n;
    for(re int i=1;i<=m;i++) cin>>a[i];
    for(re int i=1;i<=n;i++) cin>>h[i];
    for(re int i=0;i<=n;i++)
        for(re int j=1;j<=m;j++)
            cin>>c[j][i];
    for(re int i=1;i<=n;i++)
    {
        int cnt=h[i],t=b;
        for(re int j=1;j<=m;j++)
        {
            id[j]=j;
            cost[j]=c[j][0]-c[j][i];
            cnt+=c[j][i]*a[j];
        }
        sort(id+1,id+m+1,cmp);
        for(re int j=1;j<=m;j++)
        {
            if(t>=a[id[j]])
            {
                t-=a[id[j]];
                cnt+=a[id[j]]*cost[id[j]];
            }
            else
            {
                cnt+=cost[id[j]]*t;
                break;
            }
        }
        if(cnt<maxx)
        {
            maxx=cnt;
            ans=i;
        }
    }
    cout<<ans<<endl<<maxx+H;
}
```

---

## 作者：H_D_NULL (赞：0)

本题很容易构建出一个网络流的模型，但是对于$M<=50000$的数据而言，网络流是无法承受的。而本题的二分图很特殊，有一边只有2个点，而且其中一个点是固定流量的，所以果断放弃（~~反正我也不会~~）。

由于**所有的煤都要运出**，我们不妨假设所有的煤都先运输到**新工厂**，再由新工厂转运到旧工厂。不难发现，本处的“转运”第 $i$ 个煤矿的煤对应的费用就是这个煤矿运到两个工厂**运费的差值** $Ci0-Cin$。所以就有了贪心的策略，即**枚举新工厂，优先选择差值最小的煤矿填补旧工厂的 $b$ 吨用煤**，直至填满。

现在的问题在于如何在枚举到一个新工厂是快速对差值进行排序，本人提供以下3种：
- **快排：** 最简单易懂，对于本题的数据理论上勉强能过，但不保险。代码略。。。

- **堆排序（本人做法）：** 因为每次只取最小，所以建一个小根堆，建堆 $O(M)$，最坏情况时间复杂度为 $O(NMlogM)$，快赶上快排了，但是至少不会慢于快排。用STL同样容易实现，不开O2超时，开了O2跑得飞快。

```cpp
#include<bits/stdc++.h>
#define re register
#define N 55
#define M 50005
using namespace std;

inline int read(){
	re int x=0,f=1;
	re char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return x*f;
}

int m,b,h,n;
int a[M];
int hh[N];
int v[N][M];
int dif[M];
int ans=1<<30,ansi;

struct cmp{
    bool operator ()(int &a,int &b){
		return dif[a]>dif[b];
    }
};

priority_queue <int,vector<int>,cmp> q;

int main(){
	m=read();
	b=read();
	h=read();
	n=read();
	for(re int i=1;i<=m;i++) a[i]=read(),a[0]+=a[i];
	for(re int i=1;i<=n;i++) hh[i]=read();
	for(re int i=0;i<=n;i++)
		for(re int j=1;j<=m;j++) v[i][j]=read();
	for(re int i=1,sum,rest;i<=n;i++){
		sum=h+hh[i]; rest=b;
		for(re int j=1;j<=m;j++){
			dif[j]=v[0][j]-v[i][j];
			sum+=v[i][j]*a[j];
			q.push(j);
		}
		re int l;
		while(rest){//贪心地加
			l=q.top();
			if(rest>=a[l]){
				rest-=a[l];
				sum+=dif[l]*a[l];
			}
			else{
				sum+=dif[l]*rest;
				rest=0;
			}
			q.pop();
		}
		if(sum<ans){
			ans=sum;
			ansi=i;
		}
		while(!q.empty()) q.pop();//初始化
	}
	printf("%d\n%d",ansi,ans);
	return 0;
}
```


- **计数排序：** 由于本题数据很小，所以计数排序最优，时间复杂度为 $O(N * M)$

```
#include<bits/stdc++.h>
using namespace std;
const int MaxN=50005,oo=0x7fffffff>>1;

int C[55],s[MaxN],a[MaxN],f[MaxN],h[MaxN];
int sa[MaxN],sum[MaxN],M,B,N,MM,low,high,ans,MinCost;

void Init()
{
	int i;
	scanf("%d%d%d%d",&M,&B,&C[0],&N);
	for (i=1;i<=M;i++)scanf("%d",&a[i]);
	for (i=1;i<=N;i++)scanf("%d",&C[i]);
	for (i=1;i<=M;i++)scanf("%d",&f[i]);
}
void CountSort()//类似后缀数组的计数排序
{
	low=MaxN,high=-MaxN;
	int i;
	for(i=1;i<=M;i++){ if(h[i]<low)low=h[i]; if(h[i]>high)high=h[i];}
	for(i=1;i<=M;i++) h[i]-=low;high-=low;
	for(i=0;i<=high;i++) sum[i]=0;
	for(i=1;i<=M;i++) sum[h[i]]++;
	for(i=1;i<=high;i++) sum[i]+=sum[i-1];
	for(i=M;i>=1;i--) sa[sum[h[i]]--]=i;
}
void Make()
{
	int x,y,z,i;
	for (i=1;i<=M;i++){scanf("%d",&x); MinCost+=x*a[i]; h[i]=f[i]-x;}
	//读入数据，计算差值
	CountSort();
	y=B;i=1;
	while (y)//枚举满足原有发电厂的用煤需求
	{
		x=sa[i];z=h[x]+low;
		if (a[x]>y){MinCost+=y*z;return;}
		y-=a[x];
		MinCost+=a[x]*z;
		i++;
	}
}
void Solve()
{
	int i,deci;
	ans=oo;//初始化
	for(i=1;i<=N;i++)//枚举第i个工厂为新建的厂址
	{
		MinCost=C[0]+C[i];//这两个厂的固定费用
		Make();//处理
		if(MinCost<ans){ans=MinCost;deci=i;}//取最小值
	}
	cout<<deci<<endl<<ans<<endl;//输出答案
}
int main()
{
	Init();
	Solve();
	return 0;
}

```


---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P2514)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难想到枚举新工厂的选址然后计算花费。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑如何分配每个工厂的煤。先假设没有这样一个旧工厂，于是我们就只有一个新工厂了，比如当前枚举到了$i$号新工厂。这个时候肯定是全部煤都运过去，总花费是$H+h_i+\sum_{j=1}^mC_{j,i}\times a_j$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑出现了旧工厂，那么每从$j$号矿向旧工厂运过去一吨煤，我们就可以节约下来$C_{j,i}-C_{j,0}$。所以就可以想到按照$C_{j,i}-C_{j,0}$从大到小贪心地向旧工厂运煤，直到装满了$B$吨（这也相当于按照$C_{j,0}-C_{j,i}$从小到大贪心）。这是一个经典的部分背包的问题，解法不再赘述，时间是$O(nm\log_2m)$。  
# 代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;

const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 55, MAXM = 50005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int seq[MAXM], dif[MAXM];
int C[MAXN][MAXM];
int a[MAXM], h[MAXN];
int M, B, H, N;

bool cmp1( const int &x, const int &y ) { return dif[x] < dif[y]; }

int main()
{
	read( M ), read( B ), read( H ), read( N );
	for( int i = 1 ; i <= M ; i ++ ) read( a[i] );
	for( int i = 1 ; i <= N ; i ++ ) read( h[i] );
	for( int j = 0 ; j <= N ; j ++ )
		for( int i = 1 ; i <= M ; i ++ )
			read( C[j][i] );
	LL cost = 0, mnCost = INF;
	int ans, left, u;
	for( int cur = 1 ; cur <= N ; cur ++ )
	{
		left = B, cost = H + h[cur];
		for( int i = 1 ; i <= M ; i ++ ) cost += 1ll * C[cur][i] * a[i], dif[i] = C[0][i] - C[cur][i], seq[i] = i;
		sort( seq + 1, seq + 1 + M, cmp1 );
		for( int i = 1 ; i <= M ; i ++ )
		{
			if( a[u = seq[i]] <= left ) left -= a[u], cost += 1ll * dif[u] * a[u];
			else { cost += 1ll * dif[u] * left; break; }
		}
		if( cost < mnCost ) ans = cur, mnCost = cost;
	}
	write( ans ), putchar( '\n' ), write( mnCost ), putchar( '\n' );
	return 0;
}
```

---


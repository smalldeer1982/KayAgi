# [AHOI2004] DNA变异

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1660.png)

## 样例 #1

### 输入

```
3
ATCTACTG
CTATACTG
CTATGATC```

### 输出

```
1```

# 题解

## 作者：CommonDigger (赞：4)

![](https://picx.zhimg.com/70/v2-f6957a0cbc79146e376c1fb738245ea3_1440w.awebp?source=172ae18b&biz_tag=Post)
在专栏食用[本文章](https://www.luogu.com.cn/article/s1celzfs)更佳。（**真的更佳！不骗你**）

### 题目意思
给出若干个**不重复的** DNA 序列，每个 DNA 均是由 A，C，T 和 G 四个字母组成的 $8$ 位字符串。求变异一次可以得到序列中另一个 DNA 的组数。

DNA 变异的过程：在 $8$ 位字符串中找出 $4$ 个不相同的位置，第一个位置和第二个位置上的字符互换，第三个和第四个位置上的字符互换。比如说 DNA 序列 $\texttt{ATCTACTG}$ 变异位置为 1，2，3 和 4，则变异后就是 $\texttt{TATCACTG}$。

### 过程
很明显，对于每一个 DNA 都需要模拟它每一种变异后的结果。用一个简单的循环可以计算出任意一个 $8$ 位 DNA 有 $210$ 种变异方法。从数学角度也可以计算出： $C_8^4\times3=210$。

```cpp

for(int i=0;i<8;i++)
    for(int j=i+1;j<8;j++)
        for(int k=i+1;k<8;k++){
            if(k==j) continue;
            for(int l=k+1;l<8;l++){
                if(l==j) continue;
                printf("%d %d %d %d\n", i, j, k, l);
                cnt++;
            }
        }
cout << cnt;
```

对于每一次变异之后的新 DNA，我们需要知道这个新 DNA 是否存在于给出的 DNA 序列中。首先想到的是用 bool 数组记录是否存在，由此想到了用[**哈希**](https://www.luogu.com.cn/blog/551417/p3370on23nov12)。这里，我令 A 表示 0，G 表示 1，T 表示 2，C 表示 3。哈希函数：
```cpp
int hash_(string h_){
    int id=0;
    for(int i=0;i<8;i++){
        id*=4;
        switch(h_[i]){
            case 'G': id+=1; break;
            case 'T': id+=2; break;
            case 'C': id+=3; break;
            default: break;
        }
    }
    return id;
}
```
这样，得到变异后的 DNA，如果这个 DNA 的哈希值在序列中，就说明找到了一对。注意：一个 DNA 可能有多种修改方法得到的是同一个 DNA，所以需要用 bool 数组去重一下。

整体过程：
- 输入 DNA 序列时，将每个 DNA 的哈希值存入 bool 数组。  
- 遍历每个 DNA，模拟 210 次变异，如果变异后的新 DNA 在序列中出现过，则找到了一对。
- 最后，输出对数。

注意两点：1.模拟 DNA 变异需要交换字符，模拟完一次变异之后要**换回来**；2.如果 DNA $\alpha$ 变异之后得到 DNA $\beta$，则说明 DNA $\beta$ 变异也可以得到 DNA $\alpha$，每一对都被计算了两次，输出答案时要除以 2。

然后就没啥难的了。个人感觉这个题目难度应该不到蓝题吧。。
```cpp
#include "iostream"
#include "cstring"
using namespace std;
int t, num1, num2, cnt;
string input[8005];
bool vis[65536], book[65536];
int hash_(string h_){
    int id=0;
    for(int i=0;i<8;i++){
        id*=4;
        switch(h_[i]){
            case 'G': id+=1; break;
            case 'T': id+=2; break;
            case 'C': id+=3; break;
            default: break;
        }
    }
    return id;
}
int main(){
    cin >> t;
    for(int i=1;i<=t;i++){
        cin >> input[i];
        book[hash_(input[i])]=1; // 这个哈希值在序列中出现过
    }
    for(int c=1;c<=t;c++){
        memset(vis, false, sizeof(vis)); // 去重数组
        for(int i=0;i<8;i++)
            for(int j=i+1;j<8;j++)
                for(int k=i+1;k<8;k++){
                    if(k==j) continue;
                    for(int l=k+1;l<8;l++){
                        if(l==j) continue;
                        num1=hash_(input[c]);
                        swap(input[c][i], input[c][j]);
                        swap(input[c][k], input[c][l]);
                        num2=hash_(input[c]); // 新DNA的哈希值
                        if(book[num2] && !vis[num2] && num2!=num1) cnt++, vis[num2]=true;
                        //注意，除了判断重复以外，还需要判断 num2!=num1，如果变异得到的和原来一样，就不能算一对。
                        swap(input[c][i], input[c][j]);
                        swap(input[c][k], input[c][l]); // 换回来
                    }
                }
    }
    printf("%d", cnt/2);
}

```

### 如何获得最优解
**这个题到这儿就完毕了**，接下来的内容大家……随便看看吧。

当我向教练请教这一题的时候，教练说：  
![](https://cdn.luogu.com.cn/upload/image_hosting/7xovpg5n.png)

所以，我决定启动*面向结果编程技术*！

因为变异方法只有 210 种，所以我们可以预处理这 210 种变异的位置。

把上面模拟变异的四重循环稍微改一下，单独运行，让它输出变异 210 组位置。

```cpp
#include "iostream"
using namespace std;
int cnt;
int main(){
    cout << "int swaps[][4]={";
    for(int i=0;i<8;i++)
        for(int j=i+1;j<8;j++)
            for(int k=i+1;k<8;k++){
                if(k==j) continue;
                for(int l=k+1;l<8;l++){
                    if(l==j) continue;
                    printf("{%d,%d,%d,%d},", i, j, k, l);
                }
            }
    printf("};");
}
```

输出： `int swaps[][4]={{0,1,2,3},{0,1,2,4}...{4,7,5,6}};`

~~对，就是打表~~

接下来，因为 $8$ 位 DNA 只有 $4^8=65536$ 种可能，每个 DNA 只有 210 种变异方法，所以可以把 65536 个 DNA 的 210 种变异都列举出来。

在这之前，有一点值得注意：稍微想一下，每个 DNA 的 210 种变异方法不可能都不一样，肯定有一些变异是重复的。所以我先循环一遍，统计 DNA 最多有多少个变异方法。代码不放了，运算结果是 175。这样，我们就只需要 `int ans[65536][176]` 的数组来记录答案了。下面的打表代码里面，我用 `freopen` 将输出写在 txt 里（因为担心剪贴板复制不了）。我还在开始打表和结束打表的时候各放了一个输出时间，用来看打表用时多久。

```cpp
#include "iostream"
#include "windows.h"
using namespace std;
int swaps[][4]={{0,1,2,3},{0,1,2,4},{0,1,2,5},{0,1,2,6},{0,1,2,7},{0,1,3,4},{0,1,3,5},{0,1,3,6},{0,1,3,7},{0,1,4,5},{0,1
        ,4,6},{0,1,4,7},{0,1,5,6},{0,1,5,7},{0,1,6,7},{0,2,1,3},{0,2,1,4},{0,2,1,5},{0,2,1,6},{0,2,1,7},{0,2,3,4},{0,2,3,5},{0,2
                        ,3,6},{0,2,3,7},{0,2,4,5},{0,2,4,6},{0,2,4,7},{0,2,5,6},{0,2,5,7},{0,2,6,7},{0,3,1,2},{0,3,1,4},{0,3,1,5},{0,3,1,6},{0,3
                        ,1,7},{0,3,2,4},{0,3,2,5},{0,3,2,6},{0,3,2,7},{0,3,4,5},{0,3,4,6},{0,3,4,7},{0,3,5,6},{0,3,5,7},{0,3,6,7},{0,4,1,2},{0,4
                        ,1,3},{0,4,1,5},{0,4,1,6},{0,4,1,7},{0,4,2,3},{0,4,2,5},{0,4,2,6},{0,4,2,7},{0,4,3,5},{0,4,3,6},{0,4,3,7},{0,4,5,6},{0,4
                        ,5,7},{0,4,6,7},{0,5,1,2},{0,5,1,3},{0,5,1,4},{0,5,1,6},{0,5,1,7},{0,5,2,3},{0,5,2,4},{0,5,2,6},{0,5,2,7},{0,5,3,4},{0,5
                        ,3,6},{0,5,3,7},{0,5,4,6},{0,5,4,7},{0,5,6,7},{0,6,1,2},{0,6,1,3},{0,6,1,4},{0,6,1,5},{0,6,1,7},{0,6,2,3},{0,6,2,4},{0,6
                        ,2,5},{0,6,2,7},{0,6,3,4},{0,6,3,5},{0,6,3,7},{0,6,4,5},{0,6,4,7},{0,6,5,7},{0,7,1,2},{0,7,1,3},{0,7,1,4},{0,7,1,5},{0,7
                        ,1,6},{0,7,2,3},{0,7,2,4},{0,7,2,5},{0,7,2,6},{0,7,3,4},{0,7,3,5},{0,7,3,6},{0,7,4,5},{0,7,4,6},{0,7,5,6},{1,2,3,4},{1,2
                        ,3,5},{1,2,3,6},{1,2,3,7},{1,2,4,5},{1,2,4,6},{1,2,4,7},{1,2,5,6},{1,2,5,7},{1,2,6,7},{1,3,2,4},{1,3,2,5},{1,3,2,6},{1,3
                        ,2,7},{1,3,4,5},{1,3,4,6},{1,3,4,7},{1,3,5,6},{1,3,5,7},{1,3,6,7},{1,4,2,3},{1,4,2,5},{1,4,2,6},{1,4,2,7},{1,4,3,5},{1,4
                        ,3,6},{1,4,3,7},{1,4,5,6},{1,4,5,7},{1,4,6,7},{1,5,2,3},{1,5,2,4},{1,5,2,6},{1,5,2,7},{1,5,3,4},{1,5,3,6},{1,5,3,7},{1,5
                        ,4,6},{1,5,4,7},{1,5,6,7},{1,6,2,3},{1,6,2,4},{1,6,2,5},{1,6,2,7},{1,6,3,4},{1,6,3,5},{1,6,3,7},{1,6,4,5},{1,6,4,7},{1,6
                        ,5,7},{1,7,2,3},{1,7,2,4},{1,7,2,5},{1,7,2,6},{1,7,3,4},{1,7,3,5},{1,7,3,6},{1,7,4,5},{1,7,4,6},{1,7,5,6},{2,3,4,5},{2,3
                        ,4,6},{2,3,4,7},{2,3,5,6},{2,3,5,7},{2,3,6,7},{2,4,3,5},{2,4,3,6},{2,4,3,7},{2,4,5,6},{2,4,5,7},{2,4,6,7},{2,5,3,4},{2,5
                        ,3,6},{2,5,3,7},{2,5,4,6},{2,5,4,7},{2,5,6,7},{2,6,3,4},{2,6,3,5},{2,6,3,7},{2,6,4,5},{2,6,4,7},{2,6,5,7},{2,7,3,4},{2,7
                        ,3,5},{2,7,3,6},{2,7,4,5},{2,7,4,6},{2,7,5,6},{3,4,5,6},{3,4,5,7},{3,4,6,7},{3,5,4,6},{3,5,4,7},{3,5,6,7},{3,6,4,5},{3,6
                        ,4,7},{3,6,5,7},{3,7,4,5},{3,7,4,6},{3,7,5,6},{4,5,6,7},{4,6,5,7},{4,7,5,6}};
int ans[65536][176];
bool flag;
int hash_(string s){
    int id=0;
    for(int i=0;i<8;i++){
        id*=4;
        switch(s[i]){
            case 'G': id+=1; break;
            case 'T': id+=2; break;
            case 'C': id+=3; break;
            default: break;
        }
    }
    return id;
}
char next_(char c){
    if(c=='A') return 'G';
    else if(c=='G') return 'T';
    else if(c=='T') return 'C';
    else return 0;
}
int main(){
    freopen("result.txt", "w", stdout);
    int num1, num2;
    string a="########";

    SYSTEMTIME time;
    GetLocalTime(&time);
    printf("Start at %02d:%02d:%02d\n\n", time.wHour, time.wMinute, time.wSecond);

    for(int w1='A';w1!=0;w1=next_(w1)){
        a[0]=w1;
        for(int w2='A';w2!=0;w2=next_(w2)){
            a[1]=w2;
            for(int w3='A';w3!=0;w3=next_(w3)){
                a[2]=w3;
                for(int w4='A';w4!=0;w4=next_(w4)){
                    a[3]=w4;
                    for(int w5='A';w5!=0;w5=next_(w5)){
                        a[4]=w5;
                        for(int w6='A';w6!=0;w6=next_(w6)){
                            a[5]=w6;
                            for(int w7='A';w7!=0;w7=next_(w7)){
                                a[6]=w7;
                                for(int w8='A';w8!=0;w8=next_(w8)){
                                    a[7]=w8;
                                    printf("%s\n", a.c_str());
                                    for(int t=0;t<210;t++){
                                        num1=hash_(a);
                                        swap(a[swaps[t][0]], a[swaps[t][1]]);
                                        swap(a[swaps[t][2]], a[swaps[t][3]]);
                                        num2=hash_(a);
                                        flag=true;
                                        for(int i=1;i<=ans[num1][0];i++)
                                            if(ans[num1][i]==num2){
                                                flag=false;
                                                break;
                                            }
                                        if(flag) ans[num1][++ans[num1][0]]=num2;
                                        swap(a[swaps[t][0]], a[swaps[t][1]]);
                                        swap(a[swaps[t][2]], a[swaps[t][3]]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    printf("int ans[65536][25]={");
    for(int i=0;i<65536;i++){
        printf("{");
        for(int j=0;j<=ans[i][0];j++)printf("%d,", ans[i][j]);
        printf("},");
    }

    GetLocalTime(&time);
    printf("\n\nEnd at %02d:%02d:%02d", time.wHour, time.wMinute, time.wSecond);
}
```

事实上，打到 txt 里的 ans 数组有**五千万**个字符，我用的两个编译器 Dev-C++ 和 CLion 都无法打开或编辑。

![](https://picx.zhimg.com/80/v2-4730cb02b48374dc7c0cf7fe564627fa_720w.webp?source=2c26e567)

综上，这一题的打表打法最终失败了。

---

## 作者：万万没想到 (赞：2)

[原题传送门：P2547 [AHOI2004]DNA变异](https://www.luogu.com.cn/problem/P2547)

题目大意：

给出 $n$ 个序列，每个序列有 $8$ 个元素，每个元素可以是‘A’‘T’‘C’‘G’四个不同字母。

将由一个序列经过其中两组不同的两个元素交换（不同定义为共四个元素的位置各不相同）后，变成另一个序列，这两个序列为血缘序列，求 $n$ 个序列中两两是血缘序列的总个数。

数据范围：
- $1 \leq n \leq 8000$

思考过程：

首先，我们先考虑朴素的暴力，枚举两次交换的四个不同位置，再进行暴力判断两两序列之间是否合法，去重。由于每一个元素位置不同，所以枚举位置时并不需要枚举 $8^4$ 次，而是 $C_8^4$ 次。时间复杂度约为 $O(C_8^4n^2)$ 。时间复杂度爆炸。

然后，我们考虑优化，由于每个元素只可能有四种不同情况，一个序列总共八个元素，我们可以将其压成一个四进制数，然后用 $vis$ 数组记录位置，去重即可，作者为了偷懒，用了STL里的 $map$ 。

算法的时间复杂度约为 $O(C_8^4n)=O(1680n)$ ，可以通过此题。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[8005],b[8005][9],mul[9],vis[70005],ans;
char c[9];
map<int,int>vis2[8005];
void check(int w,int x,int y,int z){
	int temp;
	for(int i=1;i<=n;i++){
		temp=a[i]-mul[w]*b[i][7-w]+mul[x]*b[i][7-w]-mul[x]*b[i][7-x]+mul[w]*b[i][7-x];
		temp=temp-mul[y]*b[i][7-y]+mul[z]*b[i][7-y]-mul[z]*b[i][7-z]+mul[y]*b[i][7-z];
		if(temp!=a[i]&&vis[temp]&&!vis2[i][temp])ans++,vis2[i][temp]=1;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",c);
		for(int j=0;j<8;j++){
			a[i]=a[i]*4;
			if(c[j]=='A')b[i][j]=0;
			else if(c[j]=='T')a[i]++,b[i][j]=1;
			else if(c[j]=='C')a[i]=a[i]+2,b[i][j]=2;
			else a[i]=a[i]+3,b[i][j]=3;
		}
		vis[a[i]]=1;
	}
	mul[0]=1;
	for(int i=1;i<=7;i++)mul[i]=mul[i-1]*4;
	for(int i=0;i<8;i++){
		for(int j=i;j<8;j++){
			if(i==j)continue;
			for(int k=i;k<8;k++){
				if(i==k||j==k)continue;
				for(int l=k;l<8;l++){
					if(i==l||j==l||k==l)continue;
					check(i,j,k,l);
				}
			}
		}
	}
	printf("%d\n",ans/2);
	return 0;
}
```


---

## 作者：0x80mem (赞：1)

用的是十分简单的方法

血缘序对（S1, S2）必定有相同的A、T、C、G数，只需在具有相同ATCG数的DNA中寻找血缘序对。

代码:
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
const int chag[4][5] = {{1, 0, 3, 2}, {2, 3, 0, 1}, {3, 2, 1, 0}};
//有两对不同碱基交换的三种情况

struct DNA
{
    int s[10];
    int n;
    
    bool operator < (const DNA& dna) const
    {   
        const DNA& A = (*this);
        const DNA& B = dna;
        if (A.n < B.n) return true; 
        if (A.n > B.n) return false; 
        
        for (int i = 1; i <= 8; i++)
        {
            if (A.s[i] < B.s[i]) return true;
            if (A.s[i] > B.s[i]) return false;
        }
        return false;
    }
};

int N;
DNA A[8010];

//碱基转数字
inline int AP(char c)
{
    switch(c)
    {
        case 'A': return 0;
        case 'T': return 1;
        case 'C': return 2;
        case 'G': return 3;
    }
    return 4;
}

//得出[l, r]中血缘序对个数
int getPair(int l, int r)
{    
    int ans = 0;
    for (int i = l; i <= r; i++)
        for (int j = i + 1; j <= r; j++)
        {
            int n[9][2], t = 0, AGCT[5];
            memset(n, 0, sizeof(n));
            memset(AGCT, 0, sizeof(AGCT));
            
            //记录不同处
            for (int k = 1; k <= 8; k++)
                if (A[i].s[k] != A[j].s[k])
                    n[t][0] = A[i].s[k], n[t][1] = A[j].s[k], t++;
                else AGCT[A[i].s[k]]++;
                    
            switch (t)
            {
                case 2:
                {
                    if (n[0][0] == n[1][1] && n[1][0] == n[0][1])
                        if (AGCT[0] > 1 || AGCT[1] > 1 ||
                            AGCT[2] > 1 || AGCT[3] > 1)
                            ans++;
                    //有两个不同碱基交换，两个相同交换
                    break;
                }
                case 4:
                {
                    for (int k = 0; k < 3; k++)
                    {
                        int m;
                        for (m = 0; m < 4; m++)
                            if (n[m][0] != n[chag[k][m]][1])
                                break;
                
                        if (m >= 4)
                        { ans++; break; }
                    }
                    //有两对不同碱基交换
                    break;
                }
            }
        }
    return ans;
}

int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; i++)
    {
        int AGCT[5];
        memset(AGCT, 0, sizeof(AGCT));
        
        char str[10]; scanf("%s", str);
        for (int j = 1; j <= 8; j++)
        {
            char c = str[j - 1];
            A[i].s[j] = AP(c);
            AGCT[AP(c)]++;
            //记录AGCT数
        }
        A[i].n = (AGCT[3] << 9) + (AGCT[2] << 6)
               + (AGCT[1] << 3) + AGCT[0];
        //将DNA AGCT数转为八进制数
    }
    
    sort(A + 1, A + N + 1);
    
    int ans = 0;
    int p = 1, q = 1;
    while (p <= N)
    {
        while (A[p].n == A[++q].n && q <= N) {}
        ans += getPair(p, q - 1);
        //取得AGCT数相同的DNA血缘序对数
        p = q;
    }
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：Dilute (赞：1)

# [在本人Blog食用更佳](https://dilute.coding.me/2018/10/24/Solutions/Solution-Luogu2547/)

诶……似乎没有C++的题解

那本蒟蒻就来水一发了QwQ

首先我作为一个蒟蒻，拿到字符串题，首先看看能不能无脑哈希

然后于是我们就发现了一个绝妙的做法：暴力枚举每个字符串能够转换成的字符串

于是我们就获得了$O(N * 8^4)$的优秀复杂度

显然会T飞QwQ

我们考虑再这个基础上进行优化

我们会发现如果我们$O(8^4)$枚举的话，其中有一大部分枚举出来的状态都是重复的

那么我们思考：这其中有多少个状态是有用的呢

首先我们假设我们将$s_a, s_b$交换，$s_c, s_d$互换（$a,b,c,d\in [1, 8] $, $a \neq b \neq c \neq d$）同时我们令$a < b $ 且 $c < d$

那么我们会发现最终只有$C_8^4 * 3$种可能是可行的

所以我们只需要把这些预处理出来，那么我们在后面枚举的时候只需要在这些状态中取就行了

最终复杂度$O(N * C_8^4 * 3 * 8)$，（最后的8是Hash的复杂度）佐以优秀的常数便可AC此题。

```cpp
// Sooke bless me.
// LJC00118 bless me.
#include<bits/stdc++.h>

using namespace std;

#define INF 2147483647
#define ll long long

int Inp(){
	char c = getchar();
	register int Neg = 1;
	while(c < '0' || c > '9'){
		if(c == '-')
			Neg = -1;
		c = getchar();
	}
	register int Sum = 0;
	while(c >= '0' && c <= '9'){
		Sum = ((Sum << 3) + (Sum << 1)) + c - '0';
		c = getchar();
	}
	return Neg * Sum;
}

string s[10010];
bool Used[20];

bool cg[10000000];

inline int Hash(string s){
	int Sum = 0;
	for(int i = 0; i < 8; i++){
		Sum <<= 2;
		switch(s[i]){
			case 'A':{
				Sum += 1;
				break;
			}
			case 'C':{
				Sum += 2;
				break;
			}
			case 'T':{
				Sum += 3;
				break;
			}
		}
	}
	return Sum;
}

int Hsh[10000];
int sa[1010];
int sb[1010];
int C_swap;

int main(){
	register int n = Inp();
	for(register int i = 1; i <= n; i++)
		cin >> s[i], Hsh[i] = Hash(s[i]);
	for(register int j1 = 0; j1 < 8; j1++){
		Used[j1] = true;
		for(register int j2 = j1 + 1; j2 < 8; j2++){
			if(Used[j2])
				continue;
			Used[j2] = true;
			sa[++C_swap] = j1;
			sb[C_swap] = j2;
			Used[j2] = false;
		}
		Used[j1] = false;
	}
	register int Ans = 0;
	for(register int i = 1; i <= n; i++){
		
		for(int j = 1; j <= C_swap; j++)
			for(int u = j + 1; u <= C_swap; u++){
				if(sa[j] == sa[u] || sb[j] == sb[u] || sa[j] == sb[u] || sb[j] == sa[u])
					continue;
				string s2 = s[i];
				swap(s2[sa[j]], s2[sb[j]]);
				swap(s2[sa[u]], s2[sb[u]]);
				cg[Hash(s2)] = true;
			}
		for(register int j = i + 1; j <= n; j++) 
			if(cg[Hsh[j]])
				Ans++, cg[Hsh[j]] = false;
	}
	printf("%d", Ans);
}

```

---

## 作者：BFSBFSBFSBFS (赞：1)

~~抢fb.~~

**题意**.给出$n$个DNA序列.若2个DNA序列可以通过变异互相得到.则视为1对血缘关系.求血缘关系总数.

DNA序列:由8个基因段构成.基因段可能为$A,T,C,G$中的1个.

变异:若1个DNA序列发生2次交换.每次都选2个**不同**且**没有交换过**的基因段交换.过程称为变异.

由于只有8个位置.仅仅交换2次.可以暴力枚举每个序列的交换位置.

好像只有1680种..

可以发现,DNA序列最多只有$4^8 = 65536$种..

把DNA序列当做4进制变成数字储存.可以$O(1)$判断序列是否存在..

至于交换过程.转化成了数.就可以加减对应的值了..

设交换位置$p,p1$.序列的数为$ssum$.整个序列为s.则:

$ssum\;-= (s_p*4^{8-p}+s_{p1}*4^{8-p1}) - (s_p*4^{8-p1}+s_{p1}*4^{8-p})$.

然后判断$ssum$是否存在就可以了..

最后.中间可能出现重复的.数组标记..去掉就行了..

时间复杂度$O(1680n)$.空间$O(5n)$.

Diu代码..

```cpp
program P2547;
 var
  d,b:array[0..100001] of longint;
  c:array[0..8001] of longint;
  p:Array[0..8001] of int64;
  s:array[0..8001] of string;
  dp:array['A'..'Z'] of longint;
  dp2:array[1..8] of longint=(16384,4096,1024,256,64,16,4,1);
  i,j,k,l,m,n,o,pc,t,ss,ssum:longint;
 function hahahash(k,u:int64):longint; //前身是哈希(Tle)..
  var                                    //现在用来直接判断.
   o:longint;
  begin
   if u=0 then
    if d[k]=1008208820 then d[k]:=1;   //说明有这个序列..
   if u>0 then
    if (d[k]=1) and (b[k]<>u) then     //序列存在.且是当前
     begin                               //这个序列第1次产生的.
      b[k]:=u;                         //标记为不是第1次产生.
      exit(k);
     end
                              else exit(1008208820);  //..
  end;
 procedure hahaswap(k,x,y,x1,y1:longint); //得出交换位置后的序列值.
  begin
   dec(p[k],dp2[x1]*dp[s[k,x]]+dp2[y1]*dp[s[k,y]]); //相当于先赋值成0.
   inc(p[k],dp2[x1]*dp[s[k,y]]+dp2[y1]*dp[s[k,x]]); //再加回来..
  end;
 begin
  dp['A']:=0;
  dp['C']:=1;
  dp['T']:=2;
  dp['G']:=3;                             //代表数字..
  filldword(d,length(d),1008208820);      //以数字形式存放序列..
  filldword(b,length(b),0);               //用来判重..
  readln(n);
  for i:=1 to n do
   begin
    readln(s[i]);
    p[i]:=0;                              //当前序列代表的值..
    for j:=1 to 8 do
     p[i]:=p[i]*4+dp[s[i,j]];             //当成4进制..
    t:=hahahash(p[i],0);
   end;
  ssum:=0;
  for i:=1 to n do
   begin
    for j:=1 to 8 do
     for k:=1 to 8 do
      for l:=1 to 8 do
       for m:=1 to 8 do                   //大力枚举..
        if (j<>k) and (j<>l) and (j<>m) and (k<>l) and (k<>m) and (l<>m) then
         begin
          hahaswap(i,j,k,j,k);
          hahaswap(i,l,m,l,m);
          if hahahash(p[i],i)<>1008208820 then inc(ssum); //成功匹配..
          hahaswap(i,k,j,j,k);
          hahaswap(i,m,l,l,m);
         end;
    dec(ssum);       //特别注意.由于1个序列至少有2对相同的基因.
   end;                //自己与自己1定能成为血缘关系..应当减掉..
  writeln(ssum>>1);
 end.
```
(ಡωಡ).


---

## 作者：Andycode3759 (赞：0)

大力出奇迹！既然 $n$ 只有 $8000$，那么 $O(n^2)$ 左右数量级的做法是完全没有问题的，最外层的框架只需两层循环枚举：

```cpp
for (int i = 1; i <= n; i++)
{
    for(int j = i + 1; j <= n; j++)
    {
        if(check(i, j))
            ans++;
    }
}
```

所以只需要实现这个 `check` 函数就可以了。首先显然的一点是，两个 DNA 串中各个字母的数量必须相等。这个可以通过简单的计数+哈希实现：

```cpp
inline int hsash(int idx)
{
    int cnt[6] = {0};
    for (int i = 1; i <= 8; i++)
    {
        switch (input[i])
        {
        case 'A':
            cnt[1]++;
            break;
        case 'T':
            cnt[2]++;
            break;
        case 'C':
            cnt[3]++;
            break;
        case 'G':
            cnt[4]++;
            break;
        }
    }
    return cnt[1] * 1000 + cnt[2] * 100 + cnt[3] * 10 + cnt[4];
    // 之后只需判断两个字符串的哈希是否相等即可
}
```

然后，对于两个字母数量相同的字符串，题目已经排除了两者完全一致的情况。我们可以将字符串的 $8$ 个位置分为两类：**变化位**（发生过交换的位置）和**非变化位**（没有发生过交换的位置），两类各 $4$ 个位置。

很明显，两个字符串上所有非变化位的字符需要数量和位置完全相同。那么变化位呢？需要注意的是，变化位上的四个字符可不是乱变的。考虑一个只有四个元素的排列 $[1,2,3,4]$，在纸上手玩一下，可以发现只有三种变化方式是符合题意的：

- $[2,1,4,3]$（交换 $1,2$ 和 $3,4$ 号位）
- $[3,4,1,2]$（交换 $1,3$ 和 $2,4$ 号位）
- $[4,3,2,1]$（交换 $1,4$ 和 $2,3$ 号位）

既然这样，我们可以枚举四个变化位的位置和变化方式，对于每一种组合再依次分别检查变化位和非变化位是否符合上述条件。代码并不需要很优美，使出全部的力气暴力循环即可 AC（请重点参考 `check` 函数的实现）：

```cpp
#include <cstdio>
// 既然用不到STL，要啥万能头？
const int MAXN = 8008;

// 四元序列所有可能的变化情况
const int Change[][4] = {{3, 4, 1, 2},
                         {2, 1, 4, 3},
                         {4, 3, 2, 1}};

int n;
int hashs[MAXN];
int dna[MAXN][10];
char input[10];

// 将输入的字符串转化为数字，再顺便算个哈希
inline void storeInput(int idx)
{
    int cnt[6] = {0};
    for (int i = 1; i <= 8; i++)
    {
        switch (input[i])
        {
        case 'A':
            cnt[1]++;
            dna[idx][i] = 1;
            break;
        case 'T':
            cnt[2]++;
            dna[idx][i] = 2;
            break;
        case 'C':
            cnt[3]++;
            dna[idx][i] = 3;
            break;
        case 'G':
            cnt[4]++;
            dna[idx][i] = 4;
            break;
        default:
            break;
        }
    }
    hashs[idx] = cnt[1] * 1000 + cnt[2] * 100 + cnt[3] * 10 + cnt[4];
}

// 检查两串DNA是否符合条件（参数是下标）
inline bool check(int d1, int d2)
{
    // 第一步：检查哈希
    if (hashs[d1] != hashs[d2])
        return false;

    // 第二步：枚举变化位和变化情况
    int ma[5];
    for (ma[1] = 1; ma[1] <= 5; ma[1]++)
        for (ma[2] = ma[1] + 1; ma[2] <= 6; ma[2]++)
            for (ma[3] = ma[2] + 1; ma[3] <= 7; ma[3]++)
                for (ma[4] = ma[3] + 1; ma[4] <= 8; ma[4]++)
                    for (int c = 0; c < 3; c++)
                    {
                        bool good = true;
                        // 第三步：检查变化位，按照变化情况，查看对应位置上的字符是否相同
                        for (int i = 0; i < 4; i++)
                        {
                            int target = ma[Change[c][i]];
                            if (dna[d1][ma[i + 1]] != dna[d2][target])
                            {
                                good = false;
                                break;
                            }
                        }
                        if (!good)
                            continue;
                        // 第四步（不要漏了！）：检查非变化位是否完全相同
                        for (int i = 1; i <= 8; i++)
                        {
                            if (i == ma[1] || i == ma[2] || i == ma[3] || i == ma[4])
                                continue;
                            if (dna[d1][i] != dna[d2][i])
                            {
                                good = false;
                                break;
                            }
                        }
                        if (!good)
                            continue;

                        // 过了全部四关，就是合格的搭配啦 ^_^
                        return true;
                    }

    return false;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", input + 1);
        storeInput(i);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            if (check(i, j))
                ans++;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

时间复杂度：不会算，外层框架是 $O(n^2)$ 的，`check` 函数应该比较接近于常数级别。

综上，本题没有太高的思维难度，比较适合拿来练习码力。~~（说实话标蓝题是不是有些虚高了？建议降成绿题）~~


---


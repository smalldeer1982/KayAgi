# [AHOI2001] 华夏60战斗机

## 题目描述

华夏 60 超音速战斗机是当今世界上机动性能最先进的战斗机。战斗过程中的一个关键问题是如何在最短的时间内使飞机从当前的飞行高度和速度爬升/俯冲到指定的高度并达到指定速度，以便占据有利的战斗位置。

现假定只允许华夏 60 执行以下三种基本飞行动作，并且只能在完成了一个基本动作的情况下再去执行另一个基本飞行动作。这样华夏 60 的飞行可以表示成由这三种基本飞行动作组成的动作序列。

(1) 维持原速做恒速爬升飞行，直至飞行高度提高 ∆h 英尺；

(2) 水平加速飞直至速度提高 1 马赫(1 马赫≈1200 公里/小时)；

(3) 垂直俯冲飞行 ∆h 英尺，飞行速度会提高 1 马赫。

同时假定飞机的初始飞行速度和执行每个基本飞行动作初始时刻的飞行速度都是 1 马赫的整数倍，且不超过 6 马赫；初始飞行高度和执行每个基本飞行动作初始时刻的飞行高度都为 ∆h 英尺( ∆h 是整数)的整数倍。

实验研究表明：在不同高度 H 和不同的初始速度V 完成上述的三种基本飞行动作所需的时间也是各不相同的。表 1~表 3 给出了 ∆ h = 15000英尺和最大飞行高度 = 75000

H m 英尺时完成这三种基本飞行动作所需的时间。

根据表 1~表 3 的数据，欲使华夏 60 战斗机从 H = 0 英尺、V = 1马赫的飞行状态达到 H = 75000 英尺、V = 6 马赫的飞行状态的最短飞行时间是79 秒，相应的飞行动作序列是：

 ![](https://cdn.luogu.com.cn/upload/pic/1669.png) 

(1) 恒速爬升飞行至 H = 15000英尺，V = 1马赫状态；

(2) 连续做两次水平加速飞行至 H = 15000英尺，V = 3马赫状态；

(3) 连续做四次恒速爬升飞行至 H = 75000 英尺，V = 3马赫状态；


(4) 水平加速飞行至 H = 75000 英尺，V = 4马赫状态；

(5) 连续做两次垂直俯冲飞行至 H = 45000 英尺，V = 6 马赫状态；

(6) 连续做两次恒速爬升飞行至 H = 75000 英尺，V = 6 马赫状态。

现在小明驾驶华夏 60 战斗机以V1马赫的速度飞行于 H1英尺高度，中队长发出了让他以V2 马赫的速度飞行于 H 2 英尺高度的指令。请你编写程序帮小明决策一下如何飞行才能花费最少的时间执行完中队长下达的命令。


## 样例 #1

### 输入

```
0 1 75000 6 15000 75000
12 12 12 11 12 14
11 10 8 9 10 11
9 8 6 7 8 8
8 7 6 6 6 5
8 6 6 6 6 5
11 11 11 13 15
10 10 9 9 10
10 9 9 10 10
9 8 9 9 10
7 8 8 9 9
7 7 7 8 8
5 4 3 3 2
4 3 3 2 2
3 3 2 2 2
3 3 2 2 2```

### 输出

```
79
RAARRRRADDRR```

# 题解

## 作者：彭程远 (赞：6)

###### 为什么像个阅读题？？？

## 题目描述

其实就是一个最短路，只要你能转化为一个图。

## 题目分析

把输入的三种方式转为边，然后跑一遍dij即可

## 代码

```cpp
#include<bits/stdc++.h>//万能头好评
#define Pair pair<int,pair<int,int> >
#define MAXN 300+10
#define MAXM 90000+10
using namespace std;
struct tu{
	int next,d;
	char n;
	pair<int,int> from,to;//链式前向星
}e[MAXM];
pair<int,int> s,t;
int o,n,m,nu,h[MAXN][MAXN],d[MAXN][MAXN],v[MAXN][MAXN],hm,dh,pr[MAXN][MAXN];//记得二维数组
char ans[MAXN];
void cun(pair<int,int> from1,pair<int,int> to1,int di,char n1){
	e[++nu].next=h[from1.first][from1.second];
	e[nu].to=to1;
	e[nu].n=n1;//标准链式前向星操作（字符也要存）
	e[nu].d=di;
	e[nu].from=from1;
	h[from1.first][from1.second]=nu;
}
void dij(){
	memset(d,0,sizeof(d));
	memset(v,0,sizeof(v));
	priority_queue<Pair,vector<Pair>,greater<Pair> > q;
	for(int i=0;i<=6;i++)
        for(int j=0;j<=m;j++)
    		d[i][j]=2147483647;
	d[s.first][s.second]=0;
	q.push(Pair(d[s.first][s.second],s));
	while(!q.empty()){
		pair<int,int> k=q.top().second;
		q.pop();
		if(v[k.first][k.second])
			continue;
		v[k.first][k.second]=1;
		for(int i=h[k.first][k.second];i;i=e[i].next)
			if(d[k.first][k.second]+e[i].d<=d[e[i].to.first][e[i].to.second]){
				d[e[i].to.first][e[i].to.second]=d[k.first][k.second]+e[i].d;
				pr[e[i].to.first][e[i].to.second]=i;
				q.push(Pair(d[e[i].to.first][e[i].to.second],e[i].to));
			}
	}//堆优dij
}
int main(){
	cin>>s.second>>s.first>>t.second>>t.first>>dh>>hm;
	m=hm/dh;
	s.second/=dh;
	t.second/=dh;
	for(int i=0;i<m;i++)
		for(int j=1;j<=6;j++){
			int x;
			cin>>x;
			pair<int,int> a,b;
			a.first=b.first=j;
			a.second=i;
			b.second=i+1;
			cun(a,b,x,'R');
		}
	for(int i=0;i<=m;i++)
		for(int j=1;j<=5;j++){
			int x;
			cin>>x;
			pair<int,int> a,b;
			a.first=j;
			b.first=j+1;
			a.second=i;
			b.second=i;
			cun(a,b,x,'A');
		}
	for(int i=2;i<=m;i++)
		for(int j=1;j<=5;j++){
			int x;
			cin>>x;
			pair<int,int> a,b;
			a.first=j;
			b.first=j+1;
			a.second=i;
			b.second=i-1;
			cun(a,b,x,'D');
		}//三个（真讨厌）
	dij();
	cout<<d[t.first][t.second]<<endl;
	for(int i=pr[t.first][t.second];i;i=pr[e[i].from.first][e[i].from.second])
		ans[++o]=e[i].n;
	for(int i=o;i;i--)
		cout<<ans[i];
	exit(0);//完美结束
}
```

### [AC记录](https://www.luogu.com.cn/record/43899151)

---

## 作者：CommonDigger (赞：4)

### 1.这道题说了些什么  
给你一架飞机，可以进行 $3$ 个操作：
1. 将高度提高 $1$（$\Delta h$ 英尺）。  
2. 将速度提高 $1$（马赫）。  
3. 将高度下降 $1$（$\Delta h$ 英尺），同时速度提高 $1$（马赫）。  

上述的 $3$ 个操作在不同的高度和速度下需要的时间都是不同的，输入的 $3$ 个表中分别给出这些不同的时间。

题目要求：利用给出的数据，求出从初始高度、初始速度变化到目标高度、目标速度的最小代价。

### 2.这道题输入了些什么  
依题意，有四个部分，第一部分输入几个变量，下面的三个部分分别输入三个表。

设 $\frac{\Delta h}{Hm}=x$。

表一分别给出从 $0\sim(x-1)$ 单位高度、$1\sim6$ 速度的状态进行操作 $1$ 的用时。

表二分别给出从 $0\sim x$ 单位高度、$1\sim5$ 速度的状态进行操作 $2$ 的用时。

表三分别给出从 $2\sim x$ 单位高度、$1\sim5$ 的速度的状态进行操作 $3$ 的用时。

### 3.过程  
三个表中给出的数据都是**从一个状态变化到另一个状态的用时**，由此很容易理解为两个点之间的边的权值。那么，每一个状态为一个边，表中给出的数据就是边的权值。要求的就是从初始点到目标点的最小代价，也就是~~原始的纯天然的野生~~**单源最短路算法。**

（如果你忘记了最短路的话点[这里](https://www.luogu.com.cn/problem/P4779)，完全不知道的话要不你还是先学最短路吧。）

这个题中，飞行状态包含两个方面：高度和速度。所以需要将两个状态揉 (bushi) 在一起，变成一个点的编号。

不难发现，速度一直是题目给出的 $1\sim6$ 马赫的范围，即只可能是个一位数，所以可以把他们揉 (bushi) 成 $h\times10+v$ 的形式，其中 $h$ 为高度，$v$ 为速度。比如高度为 $15$，速度为 $3$，就揉成 $153$ 作为点的编号。

此外，所有的高度、更改高度的操作都是以给出的 $\Delta h$ 为单位进行的，任何时刻的高度都是 $\Delta h$ 的正整数倍。所以我们可以忽略这个单位，即**把所有高度除以这个单位**。例如样例中 $\Delta h=15000$，则将高度 $30000$ 简化成 $2$，$45000$ 简化成 $3$。 

有了点之后，再将输入的时间转换为边的权值。举个例子，根据表一的数据，飞机在 $45000$ 英尺 $1$ 马赫（揉成 $31$）的飞行状态下做恒速爬升飞行，需要 $8$ 秒，变化到 $60000$ 英尺 1 马赫（揉成 $41$）的飞行状态，则 $31$ 点与 $41$ 点的距离为 $8$。

点和边都有了之后，计算最短路，使用 SPFA 和 Dij 都可以。起点是初始飞行状态揉成的点，终点是目标状态的点。

输出动作序列，只需要新建一个字符串数组，保存每一个点的最短路对应的操作。同时，还要记录每条边的操作是什么。~~（我依稀记得还有更高级的办法，但是我不想思考了。）~~

程序：
```cpp
#include "iostream"
#include "queue"
#include "cstring"
using namespace std;
int h1, v1, h2, v2, AH, HM, temp, temp2;
int head[100001], dis[100001], idx;
bool book[100001];
string track[100001];
int combine(int h, int s){ // 将高度和速度揉成一个编号。
	return h*10+s;
}
struct edge{
	int to, nxt, w;
	string op;
}e[100001];
void add_edge(int u, int v,int w, string op){
	e[++idx].to=v;
	e[idx].w=w;
	e[idx].nxt=head[u];
	e[idx].op=op;
	head[u]=idx;
}
void spfa(){ // 最原始的野生的最短路算法。
	memset(dis, 0x3f, sizeof(dis));
	queue<int>q;
	q.push(combine(h1, v1));
	dis[combine(h1, v1)]=0;
	track[combine(h1, v1)]="";
	while(!q.empty()){
		temp=q.front();
		book[temp]=false;
		q.pop();
		for(int i=head[temp];i!=0;i=e[i].nxt){
			if(dis[temp]+e[i].w<dis[e[i].to]){
				dis[e[i].to]=dis[temp]+e[i].w;
				track[e[i].to]=track[temp]+e[i].op; //记录轨迹，原理与记录最短路类似。
				if(!book[e[i].to]){
					book[e[i].to]=true;
					q.push(e[i].to);
				}
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> h1 >> v1 >> h2 >> v2 >> AH >> HM;
	h1/=AH, h2/=AH; // 忽略高度单位
	temp=HM/AH;
	for(int i=0;i<temp;i++){ // 表1
		for(int j=1;j<=6;j++){
			cin >> temp2;
			add_edge(combine(i, j), combine(i+1, j), temp2, "R");
		}
	}
	for(int i=0;i<=temp;i++){ // 表2
		for(int j=1;j<=5;j++){
			cin >> temp2;
			add_edge(combine(i, j), combine(i, j+1), temp2, "A");
		}
	}
	for(int i=1;i<temp;i++){ // 表3
		for(int j=1;j<=5;j++){
			cin >> temp2;
			add_edge(combine(i+1, j), combine(i, j+1), temp2, "D");
		}
	}
	spfa();
	cout << dis[combine(h2, v2)] << endl;
	cout << track[combine(h2, v2)];
}
```

但是你会发现这个程序 WA 了一个点。为什么呢？[讨论区是这么说的。](https://www.luogu.com/discuss/37363)   

原因就是更新节点距离的时候因该以 $\leqslant$ 判断更新，而不是 $<$。改了之后就过了。我推测这可能跟此题造数据的程序有关。~~考试的时候遇到这种情况就只能看缘分了。~~

```cpp
/*
Luogu P2551 华夏60战斗机
https://www.luogu.com.cn/problem/P2551
*/
#include "iostream"
#include "queue"
#include "cstring"
using namespace std;
int h1, v1, h2, v2, AH, HM, temp, temp2;
int head[1001], dis[1001], idx;
bool book[1001];
string track[1001];
int combine(int h, int s){
	return h*10+s;
}
struct edge{
	int to, nxt, w;
	string op;
}e[1001];
void add_edge(int u, int v,int w, string op){
	e[++idx].to=v;
	e[idx].w=w;
	e[idx].nxt=head[u];
	e[idx].op=op;
	head[u]=idx;
}
void spfa(){
	memset(dis, 0x3f, sizeof(dis));
	queue<int>q;
	q.push(combine(h1, v1));
	dis[combine(h1, v1)]=0;
	track[combine(h1, v1)]="";
	while(!q.empty()){
		temp=q.front();
		book[temp]=false;
		q.pop();
		for(int i=head[temp];i!=0;i=e[i].nxt){
			if(dis[temp]+e[i].w<=dis[e[i].to]){
				dis[e[i].to]=dis[temp]+e[i].w;
				track[e[i].to]=track[temp]+e[i].op;
				if(!book[e[i].to]){
					book[e[i].to]=true;
					q.push(e[i].to);
				}
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> h1 >> v1 >> h2 >> v2 >> AH >> HM;
	h1/=AH, h2/=AH;
	temp=HM/AH;
	for(int i=0;i<temp;i++){
		for(int j=1;j<=6;j++){
			cin >> temp2;
			add_edge(combine(i, j), combine(i+1, j), temp2, "R");
		}
	}
	for(int i=0;i<=temp;i++){
		for(int j=1;j<=5;j++){
			cin >> temp2;
			add_edge(combine(i, j), combine(i, j+1), temp2, "A");
		}
	}
	for(int i=1;i<temp;i++){
		for(int j=1;j<=5;j++){
			cin >> temp2;
			add_edge(combine(i+1, j), combine(i, j+1), temp2, "D");
		}
	}
	spfa();
	cout << dis[combine(h2, v2)] << endl;
	cout << track[combine(h2, v2)];
}
```

最优解！
![](https://cdn.luogu.com.cn/upload/image_hosting/xj2x81dw.png)

---

## 作者：Helenty (赞：3)

## 解题思路

~光是看题目就让人不想做~。但仔细分析一下，其实就是一个最短路的问题。那么怎么建模呢，这和平时的最短路有所不同。**不妨把每一个状态当做一个点**，包含**高度**与**速度**两个参数，那么，表格里的每一个数据都相当于连接两个状态的一条边，权值为时间。**这样最大也只会产生 300 个点。用堆优化的 Dijkstra 完全可以胜任。**


## Code

**无注释版，可放心食用~**
```cpp
#include <bits/stdc++.h>
#define Pair pair<int,pair<int,int> >
#define N 300+10
#define M 90000+10
using namespace std;
int n,m,num,head[N][N],dis[N][N],vis[N][N],hm,dh,pre[N][N],ans[N];
pair<int,int> s,t;
struct Edge{
    int dis,next,exi,n;
    pair<int,int> to,from;
}edge[M];
void add(pair<int,int> from,pair<int,int> to,int dis,int n)
{
    edge[++num].next=head[from.first][from.second];
    edge[num].to=to;
    edge[num].dis=dis;
    edge[num].n=n;
    edge[num].from=from;
    head[from.first][from.second]=num;
}
void doing()
{
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    priority_queue<Pair,vector<Pair>,greater<Pair> > h;
    for(int i=0;i<=6;i++)
        for(int j=0;j<=m;j++)
     dis[i][j]=2147483647;
    dis[s.first][s.second]=0;
    h.push(Pair(dis[s.first][s.second],s));
    while(h.size()>0)
    {
        pair<int,int> k=h.top().second;h.pop();
        if(vis[k.first][k.second]) continue;
        vis[k.first][k.second]=1;
        for(int i=head[k.first][k.second];i;i=edge[i].next)
        if(dis[k.first][k.second]+edge[i].dis<=dis[edge[i].to.first][edge[i].to.second])
        {
            dis[edge[i].to.first][edge[i].to.second]=dis[k.first][k.second]+edge[i].dis;
            pre[edge[i].to.first][edge[i].to.second]=i;
            h.push(Pair(dis[edge[i].to.first][edge[i].to.second],edge[i].to));
        }
    }
}
int main()
{
    scanf("%d%d%d%d%d%d",&s.second,&s.first,&t.second,&t.first,&dh,&hm);
    m=hm/dh;s.second/=dh;t.second/=dh;
    for(int h=0;h<=m-1;h++)
    {
        for(int v=1;v<=6;v++)
        {
            int x; 
            pair<int,int> a,b;
            scanf("%d",&x);
            a.first=v;a.second=h;
            b.first=v;b.second=h+1;
            add(a,b,x,'R');
        }
    }
    for(int h=0;h<=m;h++)
    {
        for(int v=1;v<=5;v++)
        {
            int x;pair<int,int> a,b;
            scanf("%d",&x);
            a.first=v;a.second=h;
            b.first=v+1;b.second=h;
            add(a,b,x,'A');
        }
    }
    for(int h=2;h<=m;h++)
    {
        for(int v=1;v<=5;v++)
        {
            int x;pair<int,int> a,b;
            scanf("%d",&x);
            a.first=v;a.second=h;
            b.first=v+1;b.second=h-1;
            add(a,b,x,'D');
        }
    }
    doing();
    printf("%d\n",dis[t.first][t.second]);
    for(int i=pre[t.first][t.second];i;i=pre[edge[i].from.first][edge[i].from.second])ans[++ans[0]]=edge[i].n;
    for(int i=ans[0];i>=1;i--)printf("%c",ans[i]);
	printf("\n");
    return 0;
}
```

### 后记
[record](https://www.luogu.com.cn/record/191203309)

---

## 作者：__凉皮__ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2551)
[博客传送门](https://www.luogu.com.cn/blog/SamandNeber/solution-p2551)
 
 **恕我直言:**

第一眼看到这个题表示有点**崩溃**~

**如此之长**的题意死活**看不懂**，于是乎瞅一眼**题解**，果然没有人来照顾一下像我一样**语文挂科**的...

没一个**解释题意**，于是乎，我便干脆讲一下**题意**及**思路**

# 题意（当然你可以直接跳过）：
## 题目描述：
从 $V1$ 的速度和 $H1$ 的高度变成 $V2$ 的速度和 $H2$ 的高度，求所需**最少的时间**以及**具体步骤**。

改变速度以及高度有3种方法（高度上限为 $Hm$ ）：

1. **高度增加$∆h$**；（恒速爬升飞行）

2. **速度提高1**；（水平加速飞行）

3. **高度减少$∆h$，速度提高1**。（恒速爬升飞行）

**注：在不同高度和不同的速度时完成这三种操作所需的时间也是不相同的。**

## 输入：

 $H1$ , $V1$ , $H2$ , $V2$ , $∆h$ , $Hm$ 

然后输出3个图，分别表示每种操作**在不同高度不同速度**的耗时。

如图（由于原题面里的图挂了，于是乎再放一遍）：
![](https://cdn.luogu.com.cn/upload/pic/1669.png)

**解释：如表1中第i行第j个数表示在（ $i$ -1）\* $∆h$ 的高度， $j$ 的速度时完成第一个操作的耗时。**

完~

# 思路：
## 大概思路：

把**每一个操作弄成一条边，每一个状态弄成一个点**，然后跑一遍**最短路 Heap-Dijkstra**即可。

## 具体思路
先说**输入**
```cpp
//表1，n=hm/∆h;
for(int i=0;i<n;i++)
	for(int j=1;j<=6;j++){
		int x,f=c6(i,j),t=c6(i+1,j);
		cin>>x;
		add(f,t,x,'R');
	}
//表2表3同理
```
然后**存图**

**前向星+一维存二维**：
```cpp
int c6(int i,int b){//a[i][j]==a[i*6+j]
	return 6*i+j; 
}
int add(int x,int y,int z,char c){
	to[++k]=y;
	ac[k]=c;
	w[k]=z;
	ne[k]=he[x];
	he[x]=k;
}
```
然后是**存答案路径**（~~这里卡了好久，还是某位大佬告诉我的~~）
```cpp
void print(int x){
    if(pre[x])print(pre[x]);
    if(acc[x])cout<<acc[x];
}
pre[to]=x;	
acc[to]=ac[i];
print(end);
```

**完整高清**代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000001//题目貌似没给数据范围，就瞎定了个大点的
#define M(x,y) make_pair(x,y) 
priority_queue< pair<int,int> > q;
int to[N],he[N],w[N],ne[N],f[N],dis[N],k=0,pre[N];
char ac[N],acc[N];
int c6(int i,int j){
	return 6*i+j; 
}
int add(int x,int y,int z,char c){
	to[++k]=y;
	ac[k]=c;
	w[k]=z;
	ne[k]=he[x];
	he[x]=k;
}
void print(int x){
    if(pre[x])print(pre[x]);
    if(acc[x])cout<<acc[x];
}
int main(){
	int h1,v1,h2,v2,h,hm,n;
	cin>>h1>>v1>>h2>>v2>>h>>hm;
	n=hm/h;
	for(int i=0;i<n;i++)
		for(int j=1;j<=6;j++){
			int x,f=c6(i,j),t=c6(i+1,j);
			cin>>x;
			add(f,t,x,'R');
		} 
	for(int i=0;i<=n;i++)
		for(int j=1;j<=5;j++){
			int x,f=c6(i,j),t=c6(i,j+1);
			cin>>x;
			add(f,t,x,'A');
		}
	for(int i=2;i<=n;i++)
		for(int j=1;j<=5;j++){
			int x,f=c6(i,j),t=c6(i-1,j+1);
			cin>>x;
			add(f,t,x,'D');
		}
   //输入
	int s=c6(h1/h,v1); //起点
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	q.push(M(0,s));
	while(!q.empty()){
		int x=q.top().second;
		q.pop();
		if(f[x])continue;
		f[x]=1;
		for(int i=he[x];i;i=ne[i]){
			int t=to[i],l=w[i];
			if(dis[t]>=dis[x]+l){
				pre[t]=x;		
				dis[t]=dis[x]+l;
				acc[t]=ac[i];
				q.push(M(-dis[t],t));//懒得重载运算符了
			} 
		} 
	}
   //模板
	int e=c6(h2/h,v2);//终点
	cout<<dis[e]<<endl;
	print(e);
} 
```
**完结撒花，感谢观看！**

---

## 作者：封禁用户 (赞：2)

读完题用了很长的时间，但把它和图论联系起来想到建图的方法就不难。问题本质就是一个最短路，可以把每一个V与H的状态抽象为一个坐标点，用一维数组简化二维坐标加上队列SPFA 就水过去了O\_\_O






    
    
    



```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MA=2010,inf=4e8;
int h1,v1,h2,v2,st,en,dh,hm,n,m,t;
int sum,k;
int head[MA],dis[MA],ex[MA],pre[MA],w[MA];
struct edge{
    int t,l,n,u;
}e[MA];
queue<int>q;
char ch[]={' ','R','A','D'};
int calc(int a,int b)
{
    return m*a+b;
}
void build(int from,int to,int len,int u)
{
    e[++sum].t=to;
    e[sum].u=u;
    e[sum].l=len;
    e[sum].n=head[from];
    head[from]=sum;
}
void init()
{
    scanf("%d%d%d%d%d%d",&h1,&v1,&h2,&v2,&dh,&hm);
    n=hm/dh;
    m=6;
    h1/=dh;st=calc(h1,v1);
    h2/=dh;en=calc(h2,v2);
    for(int i=0;i<=n-1;++i)//恒速爬升
        for(int j=1;j<=6;++j)
        {
            scanf("%d",&t);
            int e=calc(i,j),f=calc(i+1,j);
            build(e,f,t,1);
        }
    for(int i=0;i<=n;++i)//水平加速
        for(int j=1;j<=5;++j)
        {
            scanf("%d",&t);
            int e=calc(i,j),f=calc(i,j+1);
            build(e,f,t,2);
        } 
    for(int i=2;i<=n;++i)//垂直俯冲 
        for(int j=1;j<=5;++j)
        {
            scanf("%d",&t);
            int e=calc(i,j),f=calc(i-1,j+1);
            build(e,f,t,3);
        }
}
void SPFA()
{
    for(int i=0;i<=(n+1)*m;++i)dis[i]=inf;
    dis[st]=0;
    q.push(st);
    while(!q.empty())
    {
        k=q.front();
        q.pop();
        ex[k]=0;
        for(int i=head[k];i;i=e[i].n)
        {
            if(dis[e[i].t]>=dis[k]+e[i].l)
            {
                dis[e[i].t]=dis[k]+e[i].l;
                w[e[i].t]=e[i].u;
                pre[e[i].t]=k;
                if(!ex[e[i].t])
                {
                    ex[e[i].t]=1;
                    q.push(e[i].t);
                }
            }
        }
    }
}
void print(int x)
{
    if(pre[x])print(pre[x]);
    if(w[x])printf("%c",ch[w[x]]);
}
int main()
{
    init();
    SPFA();
    printf("%d\n",dis[en]);
    print(en);
    printf("\n");
    return 0;
}
```

---

## 作者：wfycsw (赞：1)

- ### 代码5分钟，读题半小时。

读完题，不难发现这是一道**标准的**最短路题，但是本题的难点（也是坑点），就在**理解题意和存图**

- ### 题意

跑最短路有3种走法（高度上限为$h_{max}$)

1. 高度增加$∆h$；

2. 速度提高$1$；

3. 高度减少$∆h$，速度提高$1$。

- ### 存图

存三种走法，代码如下：
```cpp
inline void add(int u,int v,int x,int y,int s,char c){
	p=-~p;a[p].s=s;
	a[p].x=x;a[p].y=y;
	a[p].c=c;
	a[p].n=h[u][v];h[u][v]=p;
}

分割线—————————————————————————————————————————————————

for(RI i=0;i<m;i=-~i)
		for(RI j=1;j<=6;j=-~j){
			scanf("%d",&x);
			add(i,j,-~i,j,x,'R');
		}
	for(RI i=0;i<=m;i=-~i)
		for(RI j=1;j<=5;j=-~j){
			scanf("%d",&x);
			add(i,j,i,-~j,x,'A');
		}
	for(RI i=2;i<=m;i=-~i)
		for(RI j=1;j<=5;j=-~j){
			scanf("%d",&x);
			add(i,j,i-1,-~j,x,'D');
		}
```

接着再套上$dij$模板：
```cpp
]for(RI i=0;i<=m;i=-~i)
		for(RI j=0;j<=6;j=-~j)
			f[i][j]=da;
	a[0].x=q1;a[0].y=q2;
	q.push((du){0,0});f[q1][q2]=0;
	while(q.size()){
		t=q.top().s;q.pop();
		u=a[t].x;v=a[t].y;
		if(b[u][v]) continue;
		b[u][v]=1;
		for(RI i=h[u][v];i;i=a[i].n){
			x=a[i].x;y=a[i].y;s=a[i].s;	
			if(f[x][y]>=f[u][v]+s){
				f[x][y]=f[u][v]+s;
				fa[x][y]=t;//记录路径
           	ru(x,y,i);//入队
				if(x==z1&&y==z2) ans=a[i].c;
			}                     
		}
	}
 ```
最后，用$string$类型存路径答案。

```cpp
for(RI i=fa[z1][z2];i;i=fa[a[i].x][a[i].y])
		ans=a[i].c+ans;//把顺序倒过来
```

奉上AC代码：

```cpp
#include<bits/stdc++.h>
#define RI register int
#define s second
#define f first
#define du pair<int,int>
#define ru(x,y,z) q.push((du){-f[x][y],z})
using namespace std;
const int N=300+2;
const int M=1e6;
const int da=2147483647;
struct wu{
	int n,x,y,s;
	char c;
}a[M];
bool b[N][7];string ans="";
int f[N][7],h[N][7],p,fa[N][7];//u==gao v==su
inline void add(int u,int v,int x,int y,int s,char c){
	p=-~p;a[p].s=s;
	a[p].x=x;a[p].y=y;
	a[p].c=c;
	a[p].n=h[u][v];h[u][v]=p;
}
int main(){
	priority_queue<du>q;
	RI q1,q2,z1,z2,m,m1,m2,x,y,u,v,s,t;
	scanf("%d%d%d%d%d%d",&q1,&q2,&z1,&z2,&m1,&m2);
	m=m2/m1;q1/=m1;z1/=m1;
	for(RI i=0;i<m;i=-~i)
		for(RI j=1;j<=6;j=-~j){
			scanf("%d",&x);
			add(i,j,-~i,j,x,'R');
		}
	for(RI i=0;i<=m;i=-~i)
		for(RI j=1;j<=5;j=-~j){
			scanf("%d",&x);
			add(i,j,i,-~j,x,'A');
		}
	for(RI i=2;i<=m;i=-~i)
		for(RI j=1;j<=5;j=-~j){
			scanf("%d",&x);
			add(i,j,i-1,-~j,x,'D');
		}
	for(RI i=0;i<=m;i=-~i)
		for(RI j=0;j<=6;j=-~j)
			f[i][j]=da;
	a[0].x=q1;a[0].y=q2;
	q.push((du){0,0});f[q1][q2]=0;
	while(q.size()){//模板
		t=q.top().s;q.pop();
		u=a[t].x;v=a[t].y;
		if(b[u][v]) continue;
		b[u][v]=1;
		for(RI i=h[u][v];i;i=a[i].n){
			x=a[i].x;y=a[i].y;s=a[i].s;	
			if(f[x][y]>=f[u][v]+s){
				f[x][y]=f[u][v]+s;
				fa[x][y]=t;ru(x,y,i);
				if(x==z1&&y==z2) ans=a[i].c;
			}                     
		}
	}
	for(RI i=fa[z1][z2];i;i=fa[a[i].x][a[i].y])
		ans=a[i].c+ans;
	printf("%d\n",f[z1][z2]);
	cout<<ans;
	return 0;
}
```

---

## 作者：purinliang (赞：1)

首先这道题没有给Hm的最大值，很坑，只能随便开一个100没想到还过了。

观察题目，发现虽然高度可以变化，但是速度是不会下降的。

那么就可以考虑dp，设 $dp[h][v]$ 表示从开始状态$ dp[h1][v1]=0$ 到达高度为h，且速度为v的最短的时间。

搞个记忆化搜索就可以了。

需要注意的地方是，不知道什么玄学原因，不能在h为1的时候俯冲，大概是怕撞到地面吧。

要么给h加上上限hm，要么赋值初始化dp为INF标记为禁止状态。

这道题绝对不是蓝色难度，顶多绿色。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int INF=0x3f3f3f3f;

int h1,v1,h2,v2,dh,hm;

struct Node{
    int cost;
    int preh,prev;
    char op;
    Node(){};
    Node(int _cost,int _preh,int _prev):cost(_cost),preh(_preh),prev(_prev){};
}node[105][7];

bool vis[105][7];
int costtime[105][7][4];

int DP(int h,int v){
    //printf("h=%d v=%d\n",h,v);
    if(vis[h][v]){
        //printf("h=%d v=%d\n",h,v);
        //printf(" ret=%d\n",node[h][v].cost);
        return node[h][v].cost;
    }
    else{
        vis[h][v]=1;
        if(v<v1){
            //printf("h=%d v=%d\n",h,v);
            //printf(" ret=INF\n");
            node[h][v].cost=INF;
            return INF;
        }
        if(h==h1&&v==v1){
            //printf("h=%d v=%d\n",h,v);
            //printf(" ret=0\n");
            node[h][v].cost=0;
            return 0;
        }
        int &cost=node[h][v].cost;
        int &preh=node[h][v].preh;
        int &prev=node[h][v].prev;
        char &op=node[h][v].op;
        cost=INF;
        if(h!=0){
            int tcost=DP(h-1,v)+costtime[h-1][v][1];
            if(tcost<cost){
                preh=h-1;
                prev=v;
                cost=tcost;
                op='R';
            }
        }
        if(v!=0){
            int tcost=DP(h,v-1)+costtime[h][v-1][2];
            if(tcost<cost){
                preh=h;
                prev=v-1;
                cost=tcost;
                op='A';
            }
        }
        if(h>=2&&h+1<=hm){
            int tcost=DP(h+1,v-1)+costtime[h+1][v-1][3];
            if(tcost<cost){
                preh=h+1;
                prev=v-1;
                cost=tcost;
                op='D';
            }
        }
        //printf("h=%d v=%d\n",h,v);
        //printf(" ret=%d\n",cost);
        return cost;
    }
}

void out(int h,int v){
    if(h==h1&&v==v1){
        return;
    }
    else{
        out(node[h][v].preh,node[h][v].prev);
    }
    printf("%c",node[h][v].op);
}

int main() {
    scanf("%d%d%d%d%d%d",&h1,&v1,&h2,&v2,&dh,&hm);
    h1/=dh,h2/=dh,hm/=dh;

    for(int i=0;i<hm;i++){
        for(int j=1;j<=6;j++){
            scanf("%d",&costtime[i][j][1]);
        }
    }

    for(int i=0;i<=hm;i++){
        for(int j=1;j<=5;j++){
            scanf("%d",&costtime[i][j][2]);
        }
    }

    for(int i=2;i<=hm;i++){
        for(int j=1;j<=5;j++){
            scanf("%d",&costtime[i][j][3]);
        }
    }

    memset(vis,0,sizeof(vis));

    printf("%d\n",DP(h2,v2));
    out(h2,v2);
    printf("\n");
}

```


---

## 作者：uncle_steve (赞：0)

繁杂的题面……

## 解题思路：

### Dijkstra

分析一下，其实就是一个最短路的问题。

不妨把每一个状态当做一个点，包含高度与速度两个参数，那么，表格里的每一个数据都相当于连接两个状态的一条边，权值为时间。然后跑最短路，Dijkstra 完全可以胜任。

本题的难点（也是坑点），就在**理解题意和存图**。

###  题意：

改变速度以及高度有 3 种方法（高度上限为 $H_m$）：

1. 高度增加 $\Delta h$；（爬升）

2. 速度提高 1；（加速）

3. 高度减少 $\Delta h$，速度提高 1。

**数据范围：开个 300 就能过。**

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<pair<pair<int,char>,pair<int,int> > >gra[1005][10];
int dis[1005][10];
bool vis[1005][10];
pair<char,pair<int,int> >pre[1005][10];
int h1,v1,h2,v2,delh,hm;
void hs(int xxx,int yyy)
{
	if(pre[xxx][yyy].second.first==h1/delh&&pre[xxx][yyy].second.second==v1)
	{
		cout<<pre[xxx][yyy].first;
		return ;
	}
	hs(pre[xxx][yyy].second.first,pre[xxx][yyy].second.second);
	cout<<pre[xxx][yyy].first;
}
signed main()
{
	cin>>h1>>v1>>h2>>v2>>delh>>hm;
	for(int i=1;i<=hm/delh;i++)
	{
		for(int j=1;j<=6;j++)
		{
			int t;
			cin>>t;
			gra[i-1][j].push_back(make_pair(make_pair(t,'R'),make_pair(i,j)));
		}
	}
	for(int i=0;i<=hm/delh;i++)
	{
		for(int j=1;j<6;j++)
		{
			int t;
			cin>>t;
			gra[i][j].push_back(make_pair(make_pair(t,'A'),make_pair(i,j+1)));
		}
	}
	for(int i=2;i<=hm/delh;i++)
	{
		for(int j=1;j<6;j++)
		{
			int t;
			cin>>t;
			gra[i][j].push_back(make_pair(make_pair(t,'D'),make_pair(i-1,j+1)));
		}
	}
	memset(dis,0x3f,sizeof dis);
	dis[h1/delh][v1]=0;
	for(int i=1;i<=hm/delh*7;i++)
	{
		int x=-1,y=-1;
		for(int xx=0;xx<=hm/delh;xx++)
		{
			for(int yy=1;yy<=6;yy++)
			{
				if(!vis[xx][yy]&&(x==-1&&y==-1||dis[xx][yy]<dis[x][y]))
				{
					x=xx;
					y=yy;
				}
			}
		}
		vis[x][y]=1;
		for(int j=0;j<gra[x][y].size();j++)
		{
			int tox=gra[x][y][j].second.first,toy=gra[x][y][j].second.second,w=gra[x][y][j].first.first;
			if(dis[tox][toy]>=dis[x][y]+w)
			{
				dis[tox][toy]=dis[x][y]+w;
				pre[tox][toy]=make_pair(gra[x][y][j].first.second,make_pair(x,y));
			}
		}
	}
	cout<<dis[h2/delh][v2]<<endl;
	hs(h2/delh,v2);
}
```

---

## 作者：Crasole (赞：0)

将每个操作都看做是图上的一条边即可，然后跑最短路。

采用分层图的方式，令 $dis_{h, v}$ 表示飞机变为高度是 $h$，速度为 $v$ 的状态所要的时间，其余的就是最短路模板了。

还有一个小细节，就是在转移的代码中。

```cpp
nh = h + 1, nv = v, ntt = tt + up[h][v];
if(dis[nh][nv] >= ntt) {
  dis[nh][nv] = ntt;
  from[nh][nv] = Node(h, v, 'R');
  q.emplace(nh, nv, ntt);
}
```

不要把 `dis[nh][nv] >= ntt` 的 `>=` 给写成 `>`，不然的话虽然时间是最短的，但是操作序列和测试点的是不对的。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e5 + 5;
int h1, v1, h2, v2, dh, mh, uh;
int up[N][10], quick[N][10], down[N][10];
int dis[N][10];
bool vis[N][10];
struct DijNode {
    int h, v, tt;
    DijNode (int _h, int _v, int _tt) :
        h(_h), v(_v), tt(_tt) {}
    DijNode () {}
    bool operator < (const DijNode& x) const {
        return tt > x.tt;
    }
};
priority_queue <DijNode> q;
struct Node {
    int h, v;
    char opt;
    Node(int _h, int _v, char _opt) :
        h(_h), v(_v), opt(_opt) {}
    Node () {}
} from[N][10];

void dijkstra() {
    memset(dis, 0x7f, sizeof dis);
    memset(vis, false, sizeof vis);
    q.emplace(h1, v1, 0);
    dis[h1][v1] = 0;
    while(q.size()) {
        DijNode u = q.top();
        q.pop();
        int h = u.h, v = u.v, tt = u.tt;
        if(h > mh || v > 6) continue;
        if(vis[h][v]) continue;
        vis[h][v] = true;
        int nh, nv, ntt;
        //恒速爬升飞行
        if(h < mh) {
            nh = h + 1, nv = v, ntt = tt + up[h][v];
            if(dis[nh][nv] >= ntt) {
                dis[nh][nv] = ntt;
                from[nh][nv] = Node(h, v, 'R');
                q.emplace(nh, nv, ntt);
            }
        }
        //水平加速
        if(v != 6) {
            nh = h, nv = v + 1, ntt = tt + quick[h][v];
            if(dis[nh][nv] >= ntt) {
                dis[nh][nv] = ntt;
                from[nh][nv] = Node(h, v, 'A');
                q.emplace(nh, nv, ntt);
            }
        }
        //垂直俯冲
        if(h >= 2 && v != 6) {
            nh = h - 1, nv = v + 1, ntt = tt + down[h][v];
            if(dis[nh][nv] >= ntt) {
                dis[nh][nv] = ntt;
                from[nh][nv] = Node(h, v, 'D');
                q.emplace(nh, nv, ntt);
            }
        }
        
    }
    return;
}

void print(int h, int v) {
    if(h == h1 && v == v1) return;
    int th = from[h][v].h, tv = from[h][v].v;
    print(th, tv);
    cout << from[h][v].opt;
    return;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
    cin >> h1 >> v1 >> h2 >> v2 >> dh >> mh;
    uh = mh / dh;
    h1 /= dh, h2 /= dh, mh /= dh;
    //因为每次h变化是以Δh为单位的，所以可以直接将高度除以Δh以节省空间
    for (int i = 1; i <= uh; ++i)
        for (int j = 1; j <= 6; ++j)
            cin >> up[i - 1][j];
    for (int i = 1; i <= uh + 1; ++i)
        for (int j = 1; j <= 5; ++j)
            cin >> quick[i - 1][j];
    for (int i = 1; i <= uh - 1; ++i)
        for (int j = 1; j <= 5; ++j)
            cin >> down[i + 1][j];
    dijkstra();
    cout << dis[h2][v2] << '\n';
    print(h2, v2);
    cout << '\n';
    return 0;
}
```

---

## 作者：胡金梁 (赞：0)

## 前言：
首先这题做出来之后发现这题真的十分不符合蓝题的标签，估计能标蓝纯属因为题面过长且过复杂，而且讲的云里雾里，没有耐心的估计就直接扔了。

还有就是没有数据范围，但这题的数据范围小到离谱。


------------
接下来是正文。
## 题意简介
先看输入：$H_1,V_1$ 是初始状态，而 $H_2,V_2$ 是最终状态，还给了两个操作参数：$\Delta h$ 和 $H_m$。假设当前状态为 $H_t,V_t$,我们有如下的操作：

1. 将 $H_t$ 增加 $\Delta h$，$V_t$ 不变。
2. 将 $V_t$ 增加 $1$，$H_t$ 不变。
3. 将 $H_t$ 减去 $\Delta h$，$V_t$ 增加 $1$。

（限制条件：$0\leq H_t\leq H_m$，$0\leq V_t\leq6$，且都为整数）
（隐藏条件：$\Delta h\mid H_t , \Delta h \mid H_m$）

## 算法分析
对于操作型最值问题，我们很容易想到最短路和动规，但这题我用的是最短路（好想？也许吧），然后被迫写了一大坨。具体看代码吧。

## 代码
```cpp
#include<map>
#include<vector>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
vector<pair<pair<int,char>,pair<int,int> > >gra[1005][10];//表示：分别为时间、操作、终点的编号
int dis[1005][10];
bool vis[1005][10];
pair<char,pair<int,int> >pre[1005][10];//表示：分别为操作、终点的编号
int h1,v1,h2,v2,delh,hm;
void hs(int xxx,int yyy)
{
	if(pre[xxx][yyy].second.first==h1/delh&&pre[xxx][yyy].second.second==v1)
	{
		cout<<pre[xxx][yyy].first;
		return ;
	}
	hs(pre[xxx][yyy].second.first,pre[xxx][yyy].second.second);
	cout<<pre[xxx][yyy].first;
}//奇怪的回溯求路径
signed main()
{
	cin>>h1>>v1>>h2>>v2>>delh>>hm;
	for(int i=1;i<=hm/delh;i++)
	{
		for(int j=1;j<=6;j++)
		{
			int t;
			cin>>t;
			gra[i-1][j].push_back(make_pair(make_pair(t,'R'),make_pair(i,j)));
		}
	}
	for(int i=0;i<=hm/delh;i++)
	{
		for(int j=1;j<6;j++)
		{
			int t;
			cin>>t;
			gra[i][j].push_back(make_pair(make_pair(t,'A'),make_pair(i,j+1)));
		}
	}
	for(int i=2;i<=hm/delh;i++)
	{
		for(int j=1;j<6;j++)
		{
			int t;
			cin>>t;
			gra[i][j].push_back(make_pair(make_pair(t,'D'),make_pair(i-1,j+1)));
		}
	}
	memset(dis,0x3f,sizeof dis);
	dis[h1/delh][v1]=0;
	for(int i=1;i<=hm/delh*7;i++)
	{
		int x=-1,y=-1;
		for(int xx=0;xx<=hm/delh;xx++)
		{
			for(int yy=1;yy<=6;yy++)
			{
				if(!vis[xx][yy]&&(x==-1&&y==-1||dis[xx][yy]<dis[x][y]))
				{
					x=xx;
					y=yy;
				}
			}
		}
		vis[x][y]=1;
		for(int j=0;j<gra[x][y].size();j++)
		{
	//	cout<<1<<endl;
			int tox=gra[x][y][j].second.first,toy=gra[x][y][j].second.second,w=gra[x][y][j].first.first;
			if(dis[tox][toy]>=dis[x][y]+w)//注意，一定是>=，因为这题没有SPJ，所以就……
			{
				dis[tox][toy]=dis[x][y]+w;
				pre[tox][toy]=make_pair(gra[x][y][j].first.second,make_pair(x,y));
			}
		}
	}
	cout<<dis[h2/delh][v2]<<endl;
	hs(h2/delh,v2);
}
```

码风丑陋，还请见谅！

---


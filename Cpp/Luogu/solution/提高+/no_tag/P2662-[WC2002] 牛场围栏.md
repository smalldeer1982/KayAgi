# [WC2002] 牛场围栏

## 题目背景

小 L 通过泥萌的帮助，成功解决了二叉树的修改问题，并因此写了一篇论文，成功保送了叉院（羡慕不？）

勤奋又勤思的他在研究生时期成功转系，考入了北京大学光华管理学院！毕业后，凭着自己积累下的浓厚经济学与计算机学的基础，成功建设了一个现代化奶牛场！

## 题目描述

奶牛们十分聪明，于是在牛场建围栏时打算和小 L 斗智斗勇！小 L 有 $N$ 种可以建造围栏的木料，长度分别是 $l_1,l_2,\dots,l_N$，每种长度的木料无限。

修建时，他将把所有选中的木料拼接在一起，因此围栏的长度就是他使用的木料长度之和。但是聪明的小 L 很快发现很多长度都是不能由这些木料长度相加得到的，于是决定在必要的时候把这些木料砍掉一部分以后再使用。

不过由于小 L 比较节约，他给自己规定：任何一根木料最多只能削短 $M$ 米。当然，每根木料削去的木料长度不需要都一样。不过由于测量工具太原始，小 L 只能准确的削去整数米的木料，因此，如果他有两种长度分别是 $7$ 和 $11$ 的木料，每根最多只能砍掉 $1$ 米，那么实际上就有 $4$ 种可以使用的木料长度，分别是 $6,7,10,11$。        

因为小 L 相信自己的奶牛举世无双，于是让他们自己设计围栏。奶牛们不愿意自己和同伴在游戏时受到围栏的限制，于是想刁难一下小 L，希望小 L 的木料无论经过怎样的加工，长度之和都不可能得到他们设计的围栏总长度。不过小 L 知道，如果围栏的长度太小，小 L 很快就能发现它是不能修建好的。因此他希望得到你的帮助，找出无法修建的最大围栏长度。

这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\frac{1}{8}$ 哦！

## 说明/提示

对于 $40 \%$ 的数据，$1<N<10$，$0\le M<300$。

对于 $100 \%$ 的数据，$1<N<100$，$0\le M<3000$。

## 样例 #1

### 输入

```
2 1
7 11```

### 输出

```
15```

# 题解

## 作者：CaptainSlow (赞：37)

## 前言
我觉得这题挺好啊...为什么题解都写得这么草率...那就由我来系统地讲解讲解。
（顺带安利一发自己的博客，大家也可以去[这里](https://captainslow.cf/2018/09/06/luogup2662-%E7%89%9B%E5%9C%BA%E5%9B%B4%E6%A0%8F/)看）
## 分析
~~规模较小，直接上可行解DP~~（有个叫[_DYT](https://www.luogu.org/space/show?uid=36654)大佬搞了一波分析证明这个解若存在是小于$9 \times 10^6$）
当然我们要考虑更好的解法，如果是初中我也会写可行解DP，当然考场上实在写不出来我还是应该打个暴力骗骗~~满分~~的。
### PART 1 无解？
问题确实可能无解，分两种情况：

> - 存在数字1
> > - 如果有1这个数字，那么所有的数字都可以被表示出来，就不存在不能表示出的数了

> - 所有数的gcd大于1
> > - 设这些数为$A_1, A_2,...,A_n$，设$q=gcd(A_1, A_2,...,A_n)$，则$q|A_1x_1+A_2x_2+...+A_nx_n$($x_1,x_2,...,x_n \in Z$)。这是一个很显然的结论，学习整除的时候是必回讲到的。所以，由于$q > 1$，必然存在不能表示出来的数，即$\forall q \nmid m$，都是不符合条件的数，显然这个$m$是可以到无穷大的。

这两者情况我们可以先特判出来，而剩下的就是$q=1$的情况了，这样的话是肯定存在最大的不能表示出来的数的。
这个很显然。
### PART 2 寻找
我们如何去寻找这个最大的不能被表示出来的数呢？
我们考虑所有可以被表示出来的数构成的数集$S$，由最小数原理可知，$S$中一定存在最小的$s_0$。考虑模$s_0$的每一个剩余系，记为$K_i=\lbrace x|x \equiv i\pmod{s_0}\rbrace,i=0,1,2,...,s_0-1$。
显然$s_0=min(A_i)$。对$\forall K_i$，由最小数原理，存在最小的能被表示出来的$t_i$，$t_i=s_0*p+i$，显然$p>0$，否则与$s_0$的最小性矛盾。那么对每一个$K_i$，最大不能被表示出来的数就是$s_0*(p-1)+i$。这样，问题就转化为了求每一个这样的$t_i$，这时候，我们就引入这个被称为剩余系最短路的算法了。我们可以把每个剩余系$K_i$抽象为图中的点，那么连接它们的边就是$A_i$中的那些数。然后就用普通的最短路更新方式就可以了。我选择了用Dijkstra算法。
## 参考程序
```cpp
// Luogu P2262
#include <cstdio>
#include <cstring>
#include <algorithm>
const int ARSIZE = 4005;
const int INF = 0x7f7f7f7f;

int N, M, L[ARSIZE], tot_l = 0, Q[ARSIZE];
bool exist[ARSIZE] = {0}, used[ARSIZE] = {0};

inline int gcd(int a, int b) {
    for (a < b ? std::swap(a, b) : (void)0; b; std::swap(a, b)) a %= b;
    return a;
}
int dijkstra();

int main() {
    scanf("%d%d", &N, &M);
    int j, li, gd = 0;
    for (int i = 0; i < N; i++) {
        scanf("%d", &li);
        gd = gcd(gd, li);
        for (j = 0; j <= M && j < li; j++) exist[li - j] = true, gd = gcd(li - j, gd);	// 很多人WA，半天查不出错，很可能就是只算了所有L[i]的gcd
    }
    if (exist[1] || gd > 1) puts("-1");
    else printf("%d\n", dijkstra());
    return 0;
}

int dijkstra() {
    memset(Q, 0x7f, sizeof(Q));
    int i, v, k;
    for (Q[0] = 0, i = 2; i <= 3000; i++)	// 初始化
        if (exist[i]) L[tot_l++] = i;
    int MOD = L[0];
    while (true) {
        for (i = 0, k = -1; i < MOD; i++)
            if (!used[i] && (k == -1 || Q[i] < Q[k])) k = i;
        if (k == -1) break;
        used[k] = true;
        for (i = 1; i < tot_l; i++)
            if (!used[v = (k + L[i]) % MOD]) Q[v] = std::min(Q[v], Q[k] + L[i]);	// 更新其他剩余系
    }
    int res = -1;
    for (i = 1; i < MOD; i++) res = std::max(res, Q[i] - MOD);
    return res;
}
```

---

## 作者：狛枝凪斗 (赞：20)

本题是同余最短路，稍加拓展。这里想稍微说说同余最短路。

关于同余最短路，详细讲起的话从这道题入手比较复杂，不如先来看看这道题：

【P3403跳楼机】

## 题目背景
DJL为了避免成为一只咸鱼，来找srwudi学习压代码的技巧。

## 题目描述
Srwudi的家是一幢h层的摩天大楼。由于前来学习的蒟蒻越来越多，srwudi改造了一个跳楼机，使得访客可以更方便的上楼。

经过改造，srwudi的跳楼机可以采用以下四种方式移动：

向上移动x层；

向上移动y层；

向上移动z层；

回到第一层。

一个月黑风高的大中午，DJL来到了srwudi的家，现在他在srwudi家的第一层，碰巧跳楼机也在第一层。DJL想知道，他可以乘坐跳楼机前往的楼层数。

## 输入输出格式
输入格式：

 

第一行一个整数h，表示摩天大楼的层数。

第二行三个正整数，分别表示题目中的x, y, z。

 

输出格式：

 

一行一个整数，表示DJL可以到达的楼层数。

 

## 输入输出样例
输入样例#1：

15

4 7 9

输出样例#1：

9

输入样例#2：

33333333333

99005 99002 100000

输出样例#2：

33302114671
## 说明
可以到达的楼层有：1,5,8,9,10,12,13,14,15

想不出来不要死磕这一题，先看看第三题。。。。

1<=h<=2^63-1

1<=x, y, z<=100000

## 思路

首先考虑低一级的问题，假如只存在x，y两种操作而不是x，y，z三种（暂时忽略回到第一层）

那么很好想，只要用y能凑出来x的剩余系（%x的所有余数的集合），那么所有楼层都能达到

设i为%x的一个余数，f[i]为用y能凑出来的%x=i的最小高度，那么f[i]再往上跳任意个x的层数都能达到，即对于f[x]能达到的层数为(h-f[i])/x+1。因为程序里面的除法是向下取整，后面还要补一个1。另外，由于f数组的存在，一定不存在整除的情况。

那么把所有这样的f[i]加起来就是所求的答案。推广到三种操作的情况，只要用y和z去凑f就能得到答案。

接下来问题是怎么求f[i]。假设我们已经求出一个f[i]，在它的基础上再执行一遍y或z操作，例如用f[i]+y，显然能得到f[i+y]。那么考虑让f[i+y]和f[i]都成为点，用y作为边相连，以已知状态推出其它所求状态。因为f数组范围是x的剩余系，为了使f最小我们选择x，y，z中最小的成为x，连边时f[i+y]要作为f[(i+y)%x]这个点使用，对结果并无影响。

考虑起始状态是第一层且最低只能回到第一层，那么已知状态是f[1]=1。用SPFA来松弛这些等式关系，跑出f数组。最后用h计算总答案的时候，要排除掉f[i]中>h的答案。

这道题中的同余最短路思想，个人理解在于利用同余来构造x的剩余系这些点。f[i]，f[i]+x，f[i]+2x，...，f[i]+kx，这些楼层数都%x同余，那么只要建立f[i]的状态就能用极低的时间复杂度求出f[i]+x，f[i]+2x等是否可行。

然后回到本题牛场围栏。

依然是由一些数字去凑一个数字的剩余系，这道题由于多了M的条件，需要先暴力把所有能用的数字求出来，并让其中最小的那个成为提供剩余系的x。

然后跑一遍所有能用的数字，和x的剩余系建边，最后跑最短路。

求不能凑出的最大数的时候，我们要先考虑d数组的意义。d[i]即为其他数字能凑出来的%x=i的最小数字，那么d[i]+x,d[i]+2x,d[i]+3x... d[i]以上跳所有个x都能达到。

那么%x=i的数字，最大凑不出来的就是d[i]-x。

那么很显然了，把所有的d[i]-x求出来，取其中最大值。

但是还有要注意的地方，本题存在输出-1的要求。其中一种输出-1的情况是没有凑不出来的数，那么当我们能用的木料中存在长为1的，自然就能达到所有的长度。

另一种情况是不存在这个最大值。这里有两种考虑方向，一种是求出所有数字的gcd，若其不等于1，自然有一系列没法凑出来的数字。因为能凑出来的数字一定是这个gcd的倍数，其不为一的时候必然存在凑不出来的空缺。还有一种方法是最后找ans的时候顺便看一下是否有d[i]>max（max是给d数组跑最短路前设的最大值），如果有，那么一定存在一串%x=i的数字都凑不出来。（其实这种做法大概相当于猜测利用了数据比较小）

代码：
```cpp
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
int n,m;
int x,a[101];
int ver[5100001],Next[5100001],head[2600001],edge[5100001],tot,d[2600001],vis[2600001],ans=0;
queue<int>q;
void add(int x,int y,int z){
    ver[++tot]=y;
    Next[tot]=head[x];
    edge[tot]=z;
    head[x]=tot;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    sort(a+1,a+n+1);
    x=max(1,a[1]-m);
    if(x==1){
        printf("-1");
        return 0;
    }
    for(int i=1;i<=n;i++){
        for(int j=max(a[i-1]+1,a[i]-m);j<=a[i];j++){
            if(j!=x){
                for(int k=0;k<x;k++){
                    add(k,(k+j)%x,j);
                }
            }
        }
    }
    memset(d,0x3f,sizeof(d));
    d[0]=0;
    q.push(0);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=Next[i]){
            int v=ver[i],z=edge[i];
            if(d[v]>d[u]+z){
                d[v]=d[u]+z;
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    d[x]=0;
    for(int i=1;i<x;i++){
//        printf("%d %d\n",i,d[i]);
        if(d[i]>100000000){
            printf("-1");
            return 0;
        }
        ans=max(ans,d[i]-x);
    }
    printf("%d",ans);
    return 0;
}
```
以上。

---

## 作者：Lynx (赞：11)

裸的同余类bfs，注意木棍长度不能为负，可以去重减少复杂度。

(然而太短了，不能过审核，就讲一下同余类bfs是什么吧)

把围栏按照长度最短的围栏的长度分为几个同余类，我们只需要求出每个同余类内能够拼成的最短的围栏，那么这个同余类内比他长的围栏都可以通过添加最短的那根围栏拼成。

可以把同余类看成节点，从每个 x 到 (x+Ai) mod L 连一条长度为 Ai 的边（Ai为每根围栏长度，L为最短围栏长度），然后以0为起点求单源最短路。

在所有点到0号点的最短路中取最大值记为T，那么最长不能够拼成的围栏就是T-L。

如果所有的围栏都是其中一条围栏的整数倍，则输出-1.


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=105;
const int M=3005;
int n,m,nn,ans,a[N*M],dis[3005];
bool inq[3005];
queue<int>q;
bool pd()
{
    for(int i=2;i<=nn;i++)
        if(a[i]%a[1]!=0)
            return 0;
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    nn=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i]-j>0)
                a[++nn]=a[i]-j;
    sort(a+1,a+nn+1);
    if(pd())
    {
        printf("-1\n");
        return 0;
    }
    nn=unique(a+1,a+nn+1)-a-1;
    memset(dis,0x3f,sizeof(dis));
    dis[0]=0;
    q.push(0);
    inq[0]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=2;i<=nn;i++)
            if(dis[(u+a[i])%a[1]]>dis[u]+a[i])
            {
                dis[(u+a[i])%a[1]]=dis[u]+a[i];
                if(!inq[(u+a[i])%a[1]])
                {
                    inq[(u+a[i])%a[1]]=1;
                    q.push((u+a[i])%a[1]);
                }
            }
        inq[u]=0;
    }
    for(int i=1;i<=a[1]-1;i++)
        ans=max(ans,dis[i]);
    printf("%d\n",ans-a[1]);
    return 0;
}
```

---

## 作者：星星与辰 (赞：10)

这时一篇非常详细的，比较清楚的题解（~~自我认为的~~）。
### 小贴士
前置知识 djikstra 算法可以点这里进行学习[P3771](https://www.luogu.com.cn/problem/P3371)。或者这里[P4779](https://www.luogu.com.cn/problem/P4779)。
## 题意
即给出一个含有 $N(1 \leq N \leq 100)$ 个数的序列 $A$，将序列中每个元素 $a_i$ 到 $a_i-M$ 之间的数加入序列 $A$（包括 $a_i-M$），然后算出最大不可被序列 $A$ 表示的数（当一个数可由该序列中的可重复的元素相加得到时，该数可以被表示）。
### 思路的开始
先从特殊开始，假如序列 $A$ 中只存在两个元素。

容易发现，假如有一个元素数值为 $x$，那么 $x$ 的所有倍数将会成为可以被表示的数。 

此时若序列中还存在一个元素 $y(x<y)$，设可以被表示的数为 $ z $，那么有等式 $ ax+by=z $，其中 $a,b$ 为任意自然数（即可以为 $0$）~~（用扩展欧几里得定理！bushi）~~。则可以变换一下等式，变为：

$$ by\equiv z \pmod x$$ 

那么也就是说 $z$ 与 $by$ 同余(这里要注意 $z \geq by$)，这启发我们用到刚刚提到的剩余类 $z$ 与 $by$ 同属在取模 $x$ 意义下的同一个同余类。

接下来就是本题解的需要思考重点了！

**我们发现 在正整数域对于任意一个剩余类中的可以被表示的正整数 $z$，都可以使 $z+ax$（$a$ 为任意正整数）这个数也能被表示（即这个剩余类中所有大于等于 $z$ 的整数都可以被表示），那么如果我们找到这个剩余类中最小的正整数 $z$ 那我们不就可以找到最大的不可被表示的数了吗？**

**因为这个剩余类中所有大于等于 $z$ 的整数都可以被表示，那么并且 $z$ 本身就是最小的可以被表示的数，所以 $z-x$ 为最大不可被表示的数，因为在取模 $x$ 意义下的所有剩余类覆盖整个正整数集合，那么我们只需要找到对于每个剩余类中最小的可以被表示的数 $z$ ，那么我们就能求到所有剩余类中的最大不可被表示的数，然后其中肯定有我们要的答案。**

### 思路的发展

 令 $ rm=y \bmod  x,mc=y / x$ 当 $b=1$ 时，我们可以知道所有大于等于 $rm\cdot x+c$ 且取余 $x$ 为 $c$ 的数都可以被表示（即此时暂时认为 $rm\cdot x+c$ 为该剩余类中最小可被表示的数），此时若想要得到得到这个值，我们需要从 $0$ 开始加上表示大小的 $rm\cdot x$ 然后再加上表示哪个剩余类的 $mc$，我们可以以此更新剩余类 $mc$ 中的最小值，这时就要用到最短路算法了，我们把每个剩余类当作一个节点，用路径长度表示该剩余类中最小可被表示的数的大小，那么我们就是要求从源点 $0$ 到所有点的最短路。

那么换个表示方法讲解，我们可以用 $dis_{mc}$ 表示在取模 $x$ 意义下 $mc$ 的剩余类，其到源点的距离为 $rm$（加上了多少个 $x$）。

这时如果要通过这个 $dis_{mc}$ 扩展到别的地方，我们可以通过加上另一个可以被表示的数来进行转移，我们知道每个 $dis_{mc}$ 其实本质上都是由序列 $A$ 中的元素相加得到的，那么我们可以直接通过加上 $A$ 中的元素进行转移（注意现在在考虑只有两个元素的情况，所以直接用 $y$ 来表示这个元素），假如 $y=rm_{1}\cdot x+mc_{1}$，那么我们可以写出扩展方式：
$$dis_{(mc + mc_{1} ) \mod x}=dis_{mc} + ( mc + mc_{1} )\div x + rm_{1}$$

 _PS:注意这里 $( mc + mc_{1} )\div x$ 容易漏掉，因为没有考虑到在余数相加时大于 $x$ 的情况。_ 

### 最终解法

其实经过上面的叙述后，在元素数量大于2的情况也已经可见一斑了，我们只需要找到一个作为标准的 $x$，然后用其他元素进行扩展，显而易见，我们的图中的节点数是为 $x-1$ 的，所以我们使 $x$ 取尽量小的值时，我们就可以减少时间复杂度 ~~（其实没有减少多少）~~。

我们用 $rm_i$ 表示第某个其他元素除以 $x$ 的商，其余数为 $i$，为了贪点复杂度，这里应尽量使 $rm_i$ 最小，我们只需要在每个元素除以 $x$ 后取最小值就好了。

那么依据上文转移就写成了：

$$dis_{(mc_{i}+mc_{j})\mod x}=dis_{mc_{i}}+(mc_i+mc_j)\div x+rm_j $$

### 关于-1的情况
- 存在可以用的单位为 $1$ 的栅栏
>如果存在一个可以用的栅栏（可能是被削后的）为 $1$ 时，即不存在任何不能被表示的数时，输出 $-1$。

- 所有数的 $\gcd$ 不为 $1$ 时，输出 $-1$。
>这时最大值可能无限大，其实证法挺简单的，假如所有数的 $\gcd$ 大于 $1$，应为所有可以被表示的数一定都为 $\gcd$ 的倍数，若 $\gcd$ 不为 $1$，那么可以说明存在无限个不可被表示的数（只要满足不是 $\gcd$ 的倍数就行了），此时也不可填满所有剩余类，不过其实这个不需要在意，因为题目要求 $m>0$，所以一定存在两个相邻的正整数，它们是一定互质的，此时 $\gcd$ 为 $1$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
int n, m, a[3001], dis[3001], rm[3001], mc[3001], cnt;
bool vis[3001];
int Min = 3001, ans;
priority_queue<pii, vector<pii>, greater<pii> >q;
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		Min = min(Min, a[i]);
	}
	/*以最小值为标准*/
	Min -= m;
	/*存在可用栅栏（可能是被削后的）为1时，输出-1*/
	if (Min <= 1)
	{
		printf("-1");
		return 0;
	}
	for (int i = 1; i < Min; i++) 
		dis[i] = rm[i] = 3001;
	/*找到最小的剩余类扩展方式或者是图中的边权*/
	for (int i = 1; i <= n; i++) 
		for (int j = 0; j <= m; j++)
			rm[(a[i] - j) % Min] = min(rm[(a[i] - j) % Min], (a[i] - j) / Min);
    /*找到对于rm[i]的最小的商*/
	for (int i = 1; i < Min; i++)
		if (rm[i] != 3001) 
			mc[++cnt] = i;
	q.push(make_pair(0,0));	
	while (!q.empty())
	{
		pii x = q.top();
		int k = x.second;
		q.pop();
		if (vis[k])continue;
		vis[k] = true;
		for (int i = 1; i <= cnt; i++)
			if (dis[(mc[i] + k) % Min] > dis[k] + rm[mc[i]] + (mc[i] + k) / Min)
			{
				/*dis[(i+j)%x] = dis[i] + (i+j)/x + rm[j]*/
				dis[(mc[i] + k) % Min] = dis[k] + rm[mc[i]] + (mc[i] + k) / Min ;
				q.push(make_pair(dis[(mc[i] + k) % Min], (mc[i] + k) % Min));
			}
	}
	for (int i = 1; i < Min; i++) 
	{
		/*if (dis[i] == 3001) {
			printf("-1");
			return 0;
			//剩余类未被填满时
		}因为M>0，所以被予考虑*/
		ans = max(ans, (dis[i] - 1) * Min + i);
	}
	printf("%d", ans);
	finish /(^v^)/
	return 0;
}


```
## 吐槽 & 总结
这个题目挺好的，但数据太水了，我写的时候看到自己A了9个点，本以为只是一些小错误，结果竟然是将 pair 的两个关键字写反了。 

这道题目主要考察对数字相加和取模的理解，其实考虑到这个其他就迎刃而解了，是一道非常好的题目 ~~（词穷）~~。

---

## 作者：saikrilll (赞：8)

### 前言：
看到人多人说本题数据很水所以背包能跑过，其实不然。背包能过是存在数学严谨的时间复杂度证明的。本篇题解来解决这个证明问题。
## 题意：
给你 $n$ 个长度为 $m+1$ 的序列，对于每一个序列而言，满足其编号从 $1$ 到 $m+1$ 的元素单调递增且相邻元素增值为 $1$，现在将 $n$ 个序列看成一个总集合，从集合中可以任意挑选某种元素再乘若干倍求和表示一个数，问最大的不能表示的自然数。如果都能表示输出 $-1$。
## 解释：
第一眼看过，我的题意翻译和原题不同，先说序列元素能否为负数：用原题的背景说，当任一原木材长度小于等于 $m$ 的时候，所有的长度都能表示，这个大家想必都能理解。也就是可以表示 $1$ 的长度，所有的也都可以被表示。所以遇到上述情况输出 $-1$ 即可。还有就是题意存在一种情况是：总有不能表示的木材，输出 $-1$。现在我要证明的是：这个情况不存在。
### 证明思路：
欲证原命题，即证存在一个数，满足大于等于它的数都能被表示。先拿出一个序列看：

$l-m,l-m+1,l-m+2 \cdots ,l$

考虑这个序列能表示哪些数，举个简单的例子：$6,7$，手模一遍会发现：$6,7,12,13,14,18,19,20,21,24,25,26,27,28$ 等数都能表示，从中发现一些规律：$6$ 和 $7$ 是否可以表示 $[\varphi6,\varphi7](\varphi\in N)$ 区间？可以。证明这里提供一个链接：[区间覆盖](https://zhuanlan.zhihu.com/p/640241664)

有了这个结论后，在推广就得到了一般性结论，也就是上上述序列能表示：$[\varphi(l-m),\varphi l](\varphi\in N)$ 区间。大家能明显发现：这个覆盖区间刚开始不一定是完全连续的本质在于 $\varphi l$ 不一定大于等于 $(\varphi+1)(l-m)$，求 $\varphi$ 需列出一个方程：

$\varphi l\geq(\varphi+1)(l-m)  \Rightarrow \varphi\geq \frac{l}{m}-1$ 

也就是：当 $\varphi=l/m-1$ 时，区间 $[\varphi(l-m),+\infty)$ 范围内的数都能表示出来。证毕。 
利用上述性质，求出每个序列的上述临界值，再求出 $\min(\varphi(l_i-m))$ 就可以确定枚举范围了。（换而言之：我们只需要标记上述最小值以下的数就可以了。）

------------
## 时间复杂度
使用无限背包，枚举木头 $O(n)$，枚举每个序列 $O(m)$，枚举背包容量 $\frac{(l-m)^2}{m}$,乘起来就是：$n(l-m)^2$，所以时间复杂度最大是：$100\times3000^2=9\times10^8$，忽略常数 $10^8$ 能过，我的代码跑得飞快（离谱），可能是数据把 $m$ 开太大了。

------------
## 代码
```c
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	register int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^48); 
		c=getchar();
	}
	return x*f;
}
inline void write(int X)
{
    if(X<0) {X=~(X-1); putchar('-');}
    if(X>9) write(X/10);
    putchar(X%10+'0');
}
int n,m,l[(int)1e2+(int)1e1],f[(int)9e6+(int)1e1],minx=1e3;
int chu(int x,int y){
	if(x%y==0)return x/y;
	return x/y+1;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i){
		l[i]=read();
		if(l[i]<=m){
			write(-1); return 0;
		}
		minx=min(minx,l[i]-m);
	}
	minx=chu(minx,m)*minx-1; f[0]|=1;
	for(int i=1;i<=n;++i){
		for(int h=l[i]-m;h<=l[i];++h){
			for(int v=h;v<=minx;++v){
				f[v]=max(f[v],f[v-h]);
			}
		}
	}
	for(int i=minx;i>=1;--i){
		if(f[i]==0){
			write(i); return 0;
		}
	}
	write(-1);
	return 0;
}
```
### 注：

本篇题解关键在于背包时间复杂度的论述证明，算法固然不好。

[AC记录](https://www.luogu.com.cn/record/121264023)

---

## 作者：ivyjiao (赞：2)

数据范围好小，SPFA 都能过。

每种长度的木料无限！每种长度的木料无限！每种长度的木料无限！不要被输入格式里的“每根木料削去的最大值”带偏了！

先暴力把所有能直接用的数字求出来，并求出其中最小的那个数字 $p$，如果 $p=1$，那么任何长度的围栏都可以修建，输出 $-1$。

考虑同余优化，如果一个数 $y$ 能被拼出，那么 $p+y,2p+y,\cdots,np+y$ 都能被拼出，而 $p$ 是最小的能直接用的数字，这样能保证正确性和效率，**但是不代表 $y-p,y-2p,\cdots,y-np$ 能被拼出**（这个可以仔细想一下）。

我们对于每个不小于 $0$ 且不大于 $p$ 的数，抽象成一个点，把它向每一个接一段能到达的数的点连一条长为该段木料的长度的边，然后跑 SPFA 最短路，$dis_i$ 即为 $i$ 的倍数中最小可以拼出的数。

如果最后有点不可达，说明只要是这个数的倍数，都不能被拼出，这个最大值不存在，输出 $-1$。

否则由于我们跑的是最短路，所以此时 $dis_i-p$ 肯定不能被拼出，答案即为 $\max_{i=1}^{p-1} dis_i-p$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=1e5+1;
int n,m,p,a[N],g,dis[N],ans;
vector<PII>G[N];
queue<int>q;
void SPFA(){
    memset(dis,0x3f,sizeof dis);
    dis[0]=0;
    q.push(0);
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].se,w=G[u][i].fi;
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                q.push(v);
            }
        }
    }
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+1+n);
    p=max(1ll,a[1]-m);
    if(p==1){
        cout<<-1;
        return 0;
    }
    for(int i=1;i<=n;i++){
        for(int j=max(a[i-1]+1,a[i]-m);j<=a[i];j++){
            if(j!=p){
                for(int k=0;k<p;k++) G[k].push_back({j,(k+j)%p});
            }
        }
    }
    SPFA();
    for(int i=1;i<p;i++){
        if(dis[i]>1e18){
            cout<<-1;
            return 0;
        }
        ans=max(ans,dis[i]-p);
    }
    cout<<ans;
}
```

---

## 作者：ztjp13 (赞：2)

**省流：同余最短路**

本题是一道同余最短路算法的好题。接下来讲讲个人对这道题的理解。

首先，根据题意，我们知道，我们可以获得最多 $m \times (m +1)$ 种木棍长度。我们设 $t$ 为这个最大值，则木棍长度可表示为 $a_1,a_2,…,a_t$。设栅栏长度为 $l$ ,若一个栅栏的长度是可表示的，则等同于 $\exist k_1,k_2,…,k_t\in\Z^+,k_1a_1+k_2a_2+…+k_ta_t=l$。

根据数据范围可以看到，$t$ 最大可以达到 $9000000$，因此直接爆搜肯定不现实。但我们发现，单个木棍的长度最长只有 $100$，我们又发现，当其中 $t-1$ 个系数确定后，所有可表示的栅栏长度对剩下那个未被确定的系数对应的木棍长度取余的结果相同。因此，我们就可以使用同余的思想，选取长度最小的木棍来作为系数不确定的木棍，设其长度为 $a_1$，同时设 $d_i(i\in[0,a_1-1])$ 来表示当 $l \bmod a_1=i$ 时，$l$ 的最小值。此时，我们只需要建立从 $i(i\in[0,a_1-1]) $ 到 $(a_j+i)\bmod a_1(j\in[1,t])$，长度为 $a_j$ 的有向边，并跑一遍 Dijkstra 求最短路即可。

在求出最短路后，若 $d_i(i\in[0,a_1-1])$ 未被更新，就说明不存在最大值，输出 $-1$。否则，求出 $ans=max\set{d_i-a_1(i\in[0,a_1-1])}$，输出即可。

上代码


```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

const int N=3005;
const int M=6000005;

int n,m;
int ans=-1,tot,maxn,minn=0x7ffffff;
int l[N],h[N];
int edge[M],ver[M],head[M],Next[M];
int d[M],vis[M];

struct node{
	int id,step;
	bool operator <(const node b)const{
		return step>b.step;
	}
};

priority_queue<node>q;

inline int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
}

void add(int x,int y,int z){
	edge[++tot]=z; ver[tot]=y; Next[tot]=head[x]; head[x]=tot;
}

void dij(){
	d[0]=0;
	q.push(node{0,0});
	while(!q.empty()){
		int x=q.top().id; q.pop();
		if(vis[x]) continue;		
		vis[x]=true;
		for(int i=head[x];i;i=Next[i]){
			int y=ver[i];
			int z=edge[i];
			if(d[y]>d[x]+z){
				d[y]=d[x]+z;
				q.push(node{y,d[y]});
			}
		}
	}
}

signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) l[i]=read();
	for(int i=1;i<=n;i++){
		for(int j=l[i]-m;j<=l[i];j++) h[j]=1;
		maxn=max(l[i],maxn);
		minn=min(l[i]-m,minn); //求出木棍长度、最小值和最大值
	}
	for(int i=0;i<minn;i++){
		for(int j=minn;j<=maxn;j++)
			if(h[j]==1) add(i,(i+j)%minn,j); //加边
		d[i]=(1ull<<63)-1;
	}
	dij();
	for(int i=0;i<minn;i++){
		if(d[i]==(1ull<<63)-1){
			cout<<-1<<endl;
			return 0;
		}
		ans=max(ans,d[i]-minn);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Eltaos_xingyu (赞：2)

## 题目描述

已知处理过后的木料长度 $a_{1,2\cdots n}$，求 $\sum_{k=1}^{n}a_kx_k=b$ 中，$b$ 的最大使该方程无解的值。其中 $x_k \geq 0$。

## 分析

同余最短路板子题。

首先考虑如何判断无解。

如果存在 $a_i\leq 1$，也就是说在原来的数组中存在 $s_i \leq m+1$，那么一定所有的长度都能被取到，那么无解。

还有一种情况，就是这个最大值不存在，如果你知道如何求同余最短路，一定能想到对于点 $num$ 的最短路径还是 $+\infty$ 时，不存在任何数使得 $num+kx$ 的长度能被取到（其中 $x$ 为最短木料的长度），又由于此时 $k$ 能取到 $+\infty$，也就是说，$b$ 的最大使该方程无解的值是 $+\infty$，即该最大值不存在，无解。

如果你不知道同余最短路怎么求及其正确性，你可以参照其他题解，以下只是讲讲本题思路。

首先预处理木料长度最小值 $minn$，并且判断无解。

然后...直接暴力连边，可以稍微记忆化一下...我本来以为暴力连边可能超时，但是过了......

连边的过程大体可以看做是对于每一个 $k=[0,minn)$，都连一条从 $k$ 到 $(k+a_i)\bmod minn$ 的边，其中 $a_i\in[s_i-m,s_i]$。

从 $0$ 开始跑一遍最短路，然后统计无解和最大值即可。

（不知道为什么从 $1$ 开始也行，只能说数据太水）

贴上代码：

```cpp
#define int long long
int n,x[100001],y,z;
struct line{
	int to;
	int link;
	int w;
}E[500001];

int head[500001],tot;

void addE(int u,int v,int w){
	E[++tot].to=v;
	E[tot].w=w;
	E[tot].link=head[u];
	head[u]=tot;
	return;
}

bool vis[500001];
int dis[500001];

struct po{
	int dis,id;
	bool operator >(const po &a) const {
		return dis>a.dis;
	}
};

po getpo(int dis,int id){
	po nw;
	nw.dis=dis;
	nw.id=id;
	return nw;
}

priority_queue<po,vector<po>,greater<po> >q;

void dij(int s){
	memset(dis,0x3f3f3f3f,sizeof(dis));
	dis[s]=0;
	q.push(getpo(0,s));
	while(!q.empty()){
		int u=q.top().id;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=E[i].link){
			if(dis[E[i].to]>dis[u]+E[i].w){
				dis[E[i].to]=dis[u]+E[i].w;
				q.push(getpo(dis[E[i].to],E[i].to));
			}
		}
	}
	return;
}
int ttt=1e18,m;
map<int,int> mp;
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x[i];
		ttt=min(ttt,x[i]);	
	}
	ttt=max(1ll,ttt-m);
	if(ttt==1){
		cout<<-1;
		return 0;
	}
	for(int i=1;i<=n;i++)
		for(int j=x[i]-m;j<=x[i];j++){
			if(mp[j])continue;
			mp[j]=1;
			for(int k=0;k<ttt;k++){
				addE(k,(k+j)%ttt,j);
			}
		}
	dij(0);
	long long ans=0;
//	for(int i=0;i<ttt;i++){
//		cout<<dis[i]<<" ";
//	} 
	for(int i=0;i<ttt;i++)
		/*if(dis[i]>=ttt)*/{
			if(dis[i]==0x3f3f3f3f){
				cout<<-1;
				return 0;
			}
			ans=max(dis[i]-ttt,ans);
		}
	cout<<ans;
	return 0;
}
```


---

## 作者：无钩七不改名 (赞：2)

同余最短路。

如果存在 $a_i\le m+1$ 则结果为 $-1$，因为此时木材的长度一定能取到 $1$，因为此时没有长度是凑不出来的。

否则，设 $p=\max a_i$，用 $dis_x$ 记录使得 $c \equiv x \pmod p$ 成立的最小的点 $c$。跑 dijkstra，每条边长度为所有木材可能取到的长度。但是需要注意的是，如果直接枚举，边的数量为 $n\times m$，而边权的取值上界为 $p-1$，此时是容易出现大量重边的，会 TLE，所以我们需要预处理出 $1\sim p-1$ 范围内可能取到的边权，去重。

最终，答案即为 $\max(-1,\max(dis_x-p))$，其中 $dis_x-p$ 表示使得 $c \equiv x \pmod p$ 不成立的最大的点 $c$。

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=105,M=3005;

int n,m,a[N],p;
int b[M],nwn,sf[M];
int dis[M],ans=-1;

int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
}

bool vis[M];
priority_queue<pair<int,int> > pq;
void dij(){
	memset(dis,0x3f,sizeof dis);
	dis[0]=0;
	pq.push({0,0});
	while(pq.size()){
		int x=pq.top().second;pq.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i(1);i<=nwn;++i){
			int nxt=x+b[i];
			if(nxt>=p)nxt-=p;
			if(dis[nxt]>dis[x]+b[i]){
				dis[nxt]=dis[x]+b[i];
				pq.push({-dis[nxt],nxt});
			}
		}
	}
	return;
}

int main(){
	n=read();m=read();
	p=m;
	for(int i(1);i<=n;++i){
		a[i]=read();
		if(a[i]<=m+1)return puts("-1"),0;
		if(a[i]>p)p=a[i];
		for(int j(0);j<=m;++j)
			if(!sf[a[i]-j]){
				b[++nwn]=a[i]-j;
				sf[a[i]-j]=1;
			}
	}
	dij();
	for(int i(1);i<p;++i)ans=max(ans,dis[i]-p);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：木木！ (赞：2)

讲一下可行性DP的做法（

首先，先判-1，如果gcd起来不等于一或者有个木棒长度为1，直接输出-1（避免之后计算错误）。

有个小优化，如果`m!=0`的话，因为gcd(x,x-1)=1，gcd肯定为1，直接跳过算gcd的部分~~节省几毫秒~~。

然后，通过[P3951 小凯的疑惑](https://www.luogu.org/problemnew/show/P3951)的结论，设最小的两根木棍长度为为a,b，则令$limit=a\times b-a-b$。因为比limit大的长度肯定能通过a和b拼出。limit的大小是$\Theta(li^2)$级的。

之后直接跑可行性DP。但是如果对于每个li和每个m都枚举一遍的话，最多能有$\Theta(nm\times limit)$的复杂度，保不准会炸。

观察到对于一个li和当前扫描到可行的一个j，需要修改`j+li-m`到`j+li`一段的值。因为是连续的区间修改，就很容易想到差分。所以，可以将DP数组差分，每次只需要枚举`n`，因为每次更新都要扫一遍，也不会增加格外负担，时间复杂度降到$\Theta(n\times limit)$。

理论上得卡卡，但是实际上跑得挺快，大概在100ms左右。

别问我bool数组怎么差分，我用的int。

附现在AC，但是数据一加强就得TLE代码。

```cpp
#include <bitset>
#include <cstdio>
#include <algorithm>
using namespace std;

int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}

int li[105];
int cani[9000005];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",li+i);
	}
	
	sort(li+1,li+1+n);
	
	if(li[1]-m <= 1)
	{
		printf("-1");
		return 0;
	}
	
	if(!m)
	{
		int sgcd = li[1];
		for(int i=2; i<=n; ++i)
		{
			sgcd = gcd(sgcd,li[i]);
		}
		if(sgcd != 1)
		{
			printf("-1");
			return 0;
		}
	}
	
	int limit = m?(li[1]-m)*(li[1]-m+1)-(li[1]*2-m*2+1):li[1]*li[2]-li[1]-li[2];
	
	cani[0] = 1;
	cani[1] = -1;
	for(int i=1; i<=n; ++i)
	{
		int s = 0;
		for(int j=0; j+li[i]-m<=limit; ++j)
		{
			s += cani[j];
			if(s)
			{
				++cani[j+li[i]-m];
				
				if(j+li[i]+1 <= limit)
				{
					--cani[j+li[i]+1];
				}
			}
		}
	}
	
	int s = 0;
	int ans = 0;
	for(int i=0; i<=limit; ++i)
	{
		s += cani[i];
		if(!s)
		{
			ans = i;
		}
	}
	
	printf("%d",ans);
}
```

（暴力碾标算系列）

---

## 作者：平衡树森林 (赞：2)

这题的数据水到不可思议
=
纯暴力型dp就能跑过。。。而且跑得飞快


------------
具体怎么dp呢？

我们用集合s记录可用的木棍长度，并设f[i]表示用可能的木棍是否能拼出长度i

那转移方程就很简单了：f[i]=f[i] || f[i-x]    (x在s中) 边界f[0]=1

dp到哪呢？只需要到可选木棍长度中最小的两个数的积即可。可以证明，对于沪互质的两个长度a和b，能最大拼出的长度为a*b-a-b。。我不证了，可自行跳转2017提高组D1T1[小凯的疑惑](https://www.luogu.org/problem/P3951)进行研究。显然，木棍种类变多后，答案只会变小

木棍的种类数显然不会超过3000（因为最长才3000）可以用桶处理一下

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define LL long long
using namespace std;

const LL maxn=3000+10;
LL u[maxn];
LL f[maxn];
LL a[maxn],cnt;

int main()
{
	LL n,m;
	cin>>n>>m;
	for (LL i=1;i<=n;i++)
	{
		LL x;
		cin>>x;
		for (LL j=0;j<=m;j++)
		{
			if (x>j) u[x-j]=1;
		}
	}
	for (LL i=1;i<maxn;i++)
	{
		if (u[i]) a[++cnt]=i;
	}
	LL ans=-1;
	f[0]=1;
	for (LL i=1;i<=a[1]*a[2];i++)
	{
		f[i%maxn]=0;
		for (LL j=1;j<=cnt;j++)
		{
			if (a[j]>i) break;
			if (f[(i-a[j]+maxn)%maxn]) 
			{
				f[i%maxn]=1;
				break;
			}
		}
		if (!f[i%maxn]) ans=i;
	}
	cout<<ans<<endl;
	return 0;
}
```
时间复杂度O(max(l)^3)(虽然跑不满，但怎么看都会超时)，上文分析还存在~~我懒得矫正的~~逻辑错误

但它就是以平均一个点**7ms**的速度A了
=
qwq

---

## 作者：QCurium (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P2662)

[视频讲解链接](https://www.bilibili.com/video/BV1s34y1u7Zy/?spm_id_from=333.999.0.0&vd_source=a8f2ca9bd086cb49d933fb93cb7409c0)

## 题意

给你 $n$ 个数 $li_1,li_2,\dots,li_n$，$li_i$ 可以变成 $li_i,li_i-1,li_i-2,\dots,li_i-m$，而这些数有无限个。

求**不能**这些数中取出来一些数的和表示的**最大数**

## 题目分析

因为涉及到一堆数的和，而且这些数能取无限个，我们考虑同余最短路。

但是，这题有无解的情况，所以我们要判断什么时候无解：

1. $li_i=1$，显然，这种情况是无解的。
2. 从 $li_i$ 里拆出来的数为 $1$，这种情况也是显然的。

判断完无解的情况，我们现在要考虑，答案是什么。

我们在数组中存的，是模 $li_{\operatorname{min}}$ 意义下，最小的和，也就是可以凑出来的数，那不能凑出来的是几？我们来模拟一下样例。

![](https://cdn.luogu.com.cn/upload/image_hosting/g0j85sjn.png)

我们发现，答案其实就是数组中最大的数减去 $li_{\operatorname{min}}$，这是为什么呢？

因为如果 $15$ 能被凑出来，那么，余 $3$ 的那个地方就是 $15$ 了，所以 $15$ 就是答案。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define base 200807
#define mod 212370440130137903
using namespace std;
const int N=105;
const int M=3005;
int n,m,cnt=0,tot=0;
int li[N*M],dp[M],head[M];
bool bj[M],vis[M];
queue<int> q;
struct edge{
	int to,nxt,val;
}e[M<<5];
void ade(int u,int v,int w){
	e[tot]=(edge){v,head[u],w};
	head[u]=tot++;
}
void spfa(){
	dp[0]=0;
	vis[0]=1;
	q.push(0);
	while(!q.empty()){
		int asd=q.front();
		q.pop();
		vis[asd]=0;
		for(int i=head[asd];~i;i=e[i].nxt){
			int er=e[i].to,val=e[i].val;
			if(dp[er]>dp[asd]+val){
				dp[er]=dp[asd]+val;
				if(!vis[er]){
					vis[er]=1;
					q.push(er);
				}
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	memset(head,-1,sizeof(head));
	memset(dp,0x3f,sizeof(dp));
	cin>>n>>m;
	for(int i=1,asd;i<=n;i++){
		cin>>asd;
		if(asd==1){
			cout<<-1;
			return 0;
		}
		for(int j=0;j<=m;j++){
			if(!bj[asd-j]&&asd-j>0){
				if(asd-j==1){
					cout<<-1;
					return 0;
				}
				bj[asd-j]=1;
				li[++cnt]=asd-j;
			}
		}
	}
	sort(li+1,li+cnt+1);
	for(int i=2;i<=cnt;i++){
		for(int j=0;j<li[1];j++)
			ade(j,(j+li[i])%li[1],li[i]);
	}
	spfa();
	int mx=-1;
	for(int i=0;i<li[1];i++)
		mx=max(mx,dp[i]);
	if(mx>li[1])
		cout<<mx-li[1];
	else
		cout<<-1;
	return 0;
}

```

[AC 记录](https://www.luogu.com.cn/record/128771903)

---

## 作者：Coros_Trusds (赞：1)

这是一道同余最短路类型的题。

# 题目大意

给出若干种木棍的长度 $a$，每种木棍数量无限，每根木棍可以削短 $1\sim m$ 的长度再用，然后问用这些木棍不能组成的最大长度是多少，如果所有长度都能组成或不存在这个最大长度，那么输出 $-1$。

-----------

# 题目分析

什么是同余最短路。[link](https://www.luogu.com.cn/blog/430409/knowledge-tongyu-shortest-path)

取 $minn$ 为 $\min\{a\}-m$，然后就是套路。令 $dis[i]$ 表示模 $minn$ 下等于 $i$ 的最小长度，一个木棍可能变成 $a[i]-m\sim a[i]$ 之内的所有值，数据范围较小所以直接暴力连边。跑最短路就好了。

最后答案就是 $\max\{dis[i]-m\}$。因为 $dis[i]$ 已经是最小的了，$dis[i]-m$ 与 $dis[i]$ 模 $minn$ 意义下余数相同，若 $dis[i]-m$ 也满足条件则与“最小”相悖。

代码：

```cpp
//2022/5/6
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <queue>
#include <utility>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if (x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if (x < 0) {
			putchar('-');
			x = -x;
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
typedef std::pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 1e6 + 5;
struct Gragh {
	int v,w,nxt;
} gra[N << 1];
int a[N],head[N],dis[N];
bool vis[N]; 
int n,m,idx,minn;
inline void add(int u,int v,int w) {
	gra[++ idx].v = v,gra[idx].w = w,gra[idx].nxt = head[u],head[u] = idx;
}
inline void dijkstra(int st) {
	mst(dis,0x3f),mst(vis,false);
	dis[st % minn] = 0;
	std::priority_queue<PII,std::vector<PII>,std::greater<PII> >q;
	q.push(std::make_pair(dis[st % minn],st % minn));
	while (!q.empty()) {
		int u = q.top().second;q.pop();
		if (vis[u]) continue;
		vis[u] = true;
		for (register int i = head[u];i;i = gra[i].nxt) {
			int v = gra[i].v,w = gra[i].w;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				q.push(std::make_pair(dis[v],v));
			}
		}
	}
}
inline int query(int x) {
	int res = 0;
	for (register int i = 0;i < x; ++ i) {
		if (dis[i] == INF) {
			return -1;
		}
		res = std::max(res,dis[i] - x);
	}
	return res;
}
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read(),m = read();
	minn = INF;
	for (register int i = 1;i <= n; ++ i) {
		a[i] = read();
		minn = std::min(minn,a[i]);
	}
	minn = std::max(minn - m,1);
	if (minn == 1) return puts("-1"),0;//长度为 1,则所有长度都可以拼出来 
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = a[i] - m;j <= a[i]; ++ j) {
			if (j != minn) {
				for (register int k = 0;k < minn; ++ k) {
					add(k,(k + j) % minn,j);
				}
			}
		}
	}
	dijkstra(0);
	printf("%d\n",query(minn));
	
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：1)

#### 解析

首先我们可以将所有能用的数暴力跑出来，复杂度 $O(NM)$，可以接受。

此时我们发现第一个无解情况：当能用的数出现 $1$ 的时候，可以拼凑的出任意正整数。

将其特判掉，我们继续。

设所有能用的数个数为 $n$，那么本题的问题就是给定一个序列 $\{a_n\}$，求 $\sum_{i=1}^na_ix_i$ 最大不能表示出的整数。

我们可以考虑使用[**同余最短路**](https://www.luogu.com.cn/blog/Izayoimiku9/tong-yu-zui-duan-lu)的技巧来求。

设 $base$ 是我们规定的模数，同余最短路求出的距离 $f[x]$ 是能拼凑出的在以 $x$ 为代表元的剩余类中的最小数字。

那么 $f[x]-base$ 就是不能拼凑出的在该剩余类中的最大数字。遍历所有剩余类 $[x]$ ，取最大的 $f[x]$ 即可。

这里我们会遇到另一个无解情况，可能我们根本无法拼出某一个剩余类中的数字，即 $f[x]\to \infty$。

仍然特判掉即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;

const int N=4e5+10,INF=0x3f3f3f3f;

int n,m;
int arr[N],cnt=0;
int base=INF;

int head[N],ver[N<<1],nxt[N<<1],edg[N<<1],tot=0;
void add(int x,int y,int z)
{
	ver[++tot]=y; edg[tot]=z; nxt[tot]=head[x]; head[x]=tot;
}
bool vis[N];
int f[N];
priority_queue<PII,vector<PII>,greater<PII> > q;

void dijkstra()
{
	memset(f,0x3f,sizeof f);
	memset(vis,0,sizeof vis);
	f[0]=0; q.push({0,0});
	while(q.size())
	{
		int x=q.top().second;
		q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];
			if(f[y]>f[x]+edg[i])
			{
				f[y]=f[x]+edg[i];
				q.push({f[y],y});
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	cnt=n;
	for(int i=1;i<=cnt;i++) scanf("%d",&arr[i]),vis[arr[i]]=1,base=min(base,arr[i]);
	for(int i=1;i<=n;i++)//暴力跑出所有能用的数
	{
		for(int j=1;j<=m;j++)
			if(arr[i]-j>0&&!vis[arr[i]-j]) arr[++cnt]=arr[i]-j,vis[arr[cnt]]=1,base=min(arr[cnt],base);
			else if(arr[i]-j<=0) break;
	}
	if(vis[1]) return 0&printf("-1");//出现了 1
	for(int i=0;i<base;i++)
	{
		for(int j=1;j<=cnt;j++)
			add(i,(i+arr[j])%base,arr[j]);
	}
	dijkstra();
	int ans=0;
	for(int i=1;i<base;i++)
	{
		if(f[i]>=INF) return 0&printf("-1");//这个剩余类无法被拼凑出
		ans=max(ans,f[i]-base);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：C_Pos_Princess (赞：0)

# 题目
[P2662 牛场围栏](https://www.luogu.com.cn/problem/P2662)

### 题目模型

求 $\sum_{k = 1}^n a_kx_k = b$ 中，最大使得该方程无解的 $b$，其中 $x_k \ge 0$。

## 题解

这个题意就是同余最短路了。

第一步，判断无解。一共两种情况：

1. 全都能构造，即存在 $a_x = 1$。
2. 存在 $x$，使得存在一个 $k\le x$ ，任意一个 $d\times x + k$ 都不能被构造出来。

第二步，求解：

我们考虑 $dis$ 数组的意义，令 $x$ 表示所有木板中最小的那个，$d_i$ 表示能被构造出来的最小的对 $x$ 取余等于 $i$ 的数字，那么对于 $d_i$，所有的 $d_i+x,d_i+2\times x$ 等都可以被构造出来，那么 $d_i-x$ 就是构造不出来的，即为一个解，我们取最大即可。



## 代码

```
ll n,m;
ll minn = 1e18;
ll x[N];
map<ll,ll>mp;
int e[N],ne[N],cnt,w[N];
int h[N];
void add(int a,int b,int c){
	e[++cnt]  = b;
	ne[cnt] = h[a];
	h[a] = cnt;
	w[cnt] = c;
}


ll dis[N];
priority_queue<pii,vector<pii>,greater<pii> >q;

void dijkstra(int s){
	memset(dis,0x3f3f3f3f,sizeof dis);
	dis[s] = 0;
	q.push({dis[s],s});
	while(!q.empty()){
		int u = q.top().second;
		q.pop();
		for(int i = h[u];~i;i = ne[i]){
			int j = e[i];
			if(dis[j]>dis[u]+w[i]){
				dis[j] = dis[u]+w[i];
				q.push({dis[j],j});
			}
		}
	}
}


int main(){
	memset(h,-1,sizeof h);
	read(n,m);
	for(int i = 1;i<=n;i++){
		read(x[i]);
		minn = min(minn,x[i]);
	}	
	minn = max(1ll,minn-m);
	if(minn == 1){
		cout<<-1;
		return 0;
	}
	
	for(int i = 1;i<=n;i++){
		for(int j = x[i]-m;j<=x[i];j++){
			if(mp[j]) continue;
			mp[j] = 1;
			for(int k = 0;k<minn;k++){
					add(k,(k+j)%minn,j);
			}
		}
	}
	
	dijkstra(0);
	ll ans =0;
	for(int i = 0;i<minn;i++){
		if(dis[i] == 0x3f3f3f3f){
			cout<<-1;
			return 0;
		}
		ans = max(dis[i]-minn,ans);
	}
	cout<<ans;

	return 0;
}
```

---

## 作者：Exp10re (赞：0)

你谷为数不多的同余最短路例题。

文章同步于 [浅谈同余最短路：关于 SPFA 为什么还没死](https://www.luogu.com.cn/blog/Exp10re/shortest-path)。

## 解题思路

记集合 $A$ 满足 $\forall i\in[1,n],j\in[0,\min(l_i,M)],$ 有 $l_i-j \in A$。

先暴力枚举出 $A$ 中所有元素，找到其中最小的一个记为 $m$。（与题面中的 $M$ 区分开）

显然的，若 $m=1$，那么所有正整数都能被表示，最大值不存在。

若 $\gcd(l_{1\dots n})\ne 1$ 且 $M=0$，则显然最大值不存在。

记 $d_i$ 表示满足 $k \equiv i(\bmod\ m)$ 且合法的最小的 $k$，那么答案即为 $\max((d_i-m)\in\mathbb{N^+})$。

而我们知道 $d_i$ 可以用同余最短路，这道题目就解决了……并没有。

注意到 $A$ 中元素在不去重的情况下最多有 $3000^2$ 个，这是我们无法接受的，因此要对其进行去重。

去重后找到其最小值 $m$ 之后还能进一步优化：若多个数 $\bmod\ m$ 的余数相同，只保留其中最小的一个。

在同余最短路的实现中，余数相同的数所连的边的两个端点相同（端点只与余数有关），而边权由数本身决定。在最短路算法中，对于重边，使用其他边转移一定不优于用其中边权最小的边进行转移。因此，多个数 $\bmod\ m$ 的余数相同只保留其中最小的一个的正确性显然。

## 代码

使用 SPFA 来实现最短路。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=3030;
struct edg
{
	long long pos,dis;
};
vector<edg> edge[MAXN];
long long n,l,r,a[MAXN],M,dis[MAXN],vis[MAXN],cnted[MAXN],cntM[MAXN];
long long q[MAXN*10],ql,qr;
void spfa()
{
	long long t,i,j,u,mm;
	ql=qr=1;
	q[ql]=0;
	while(ql<=qr)
	{
		u=q[ql];
		vis[u]=0;
		mm=edge[u].size()-1;
		for(i=0;i<=mm;i++)
		{
			t=edge[u][i].pos;
			if(dis[t]>dis[u]+edge[u][i].dis)
			{
				dis[t]=dis[u]+edge[u][i].dis;
				if(!vis[t])
				{
					vis[t]=1;
					qr++;
					q[qr]=t;
				}
			}
		}
		ql++;
	}
	return;
}
long long gcd(long long ta,long long tb)
{
	long long tc=ta%tb;
	while(tc!=0)
	{
		ta=tb;
		tb=tc;
		tc=ta%tb;
	}
	return tb;
}
int main()
{
	long long i,j,m,t,minn=MAXN,GCD=1;
	scanf("%lld%lld",&n,&m);
	bool flag=(m==0);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&t);
		if(flag)
		{
			if(i==1)
			{
				GCD=t;
			}
			else
			{
				GCD=gcd(GCD,t);
			}
		}
		for(j=0;j<=m&&t-j>=1;j++)
		{
			cnted[t-j]=1;
			minn=min(minn,t-j);
			if(minn==1)
			{
				printf("-1\n");
				return 0;
			}
		}
	}
	if(minn==1)
	{
		printf("-1\n");
		return 0;
	}
	if(GCD!=1&&flag)
	{
		printf("-1\n");
		return 0;
	}
	M=minn;
	for(i=1;i<=MAXN-10;i++)
	{
		if(cnted[i]==1&&cntM[i%M]==0)
		{
			cntM[i%M]=i;
		}
	}
	n=0;
	for(i=0;i<M;i++)
	{
		if(cntM[i]!=0)
		{
			n++;
			a[n]=cntM[i];
		}
	}
	for(i=2;i<=n;i++)
	{
		for(j=0;j<M;j++)
		{
			edge[j].push_back((edg){(j+a[i])%M,a[i]});
		}
	}
	memset(dis,0x3f,sizeof(dis));
	dis[0]=0;
	spfa();
	long long maxn=-1;
	for(i=0;i<M;i++)
	{
		maxn=max(maxn,dis[i]-M);
	}
	printf("%lld",maxn);
	return 0;
}
```

---

## 作者：Lamb_Carp (赞：0)

# advertisement

这个靓仔，你都来看我的题解了，为什么不来[我的博客](https://www.cnblogs.com/carp-oier/p/17744591.html)看呢。

# prologue

建议大家特别关注自己新建完长度那个数组，我用错然后调了 20min。（代码 5min，调试 20min 的屑。（

# analysis

观察题目，抛去所有条件，发现本质是让我们用一堆数字去拼凑数字，然后找到最大的一个拼凑不成的数字。很符合同余最短路的模板样子，所以我们就开始往同余最短路这一方面考虑。

这个时候审题发现，题目中说每跟木棒是可以磨去最多 $m$ 的，我们就可以把所有木棒给提前预处理出来。

对于同余最短路，众所不周知，有两种做法，一种就是顾名思义，用最短路进行解决，另一种我们可以用一种神奇的转圈方法去解决。如果还不会请自行[左转](https://www.cnblogs.com/alex-wei/p/17531487.html "左转")或者[右转](http://www.cnblogs.com/ying-xue/p/16976289.html "右转")到大佬的博客进行学习。

# code time

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long 
#define rl register ll

const ll N = 1e7 + 10, M = 110;

ll n, m,l[M], tot, a[N], f[N];

ll ans = -1;

inline void add()
{
    for(rl i=1; i <= n; ++ i)
        for(rl j=0; j <= m; ++ j)
        {
            ll x = l[i] - j;
            if(x <= 0) break;
            a[ ++ tot] = x;
        }
}

inline ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}   

int main()
{
    // freopen("1.in", "r", stdin), freopen("1.out", "w", stdout);

    cin >> n >> m;

    for(rl i=1; i <= n; ++ i) cin >> l[i];

    add();

    sort(a + 1, a + 1 + tot);
    
    m = a[1];

    memset(f, 0x3f, sizeof f); f[0] = 0;

    for(rl i=2; i <= tot; ++ i) // 没错啊，就是这个这里，不要写成 n ！！！是tot！！！因为你分割了！！！
        for(rl j=0, lim = __gcd(m, a[i]); j < lim; ++ j) 
            for(rl t=j, c = 0; c < 2; c += t == j)
            {
                ll p = (t + a[i]) % m;
                f[p] = min(f[p], f[t] + a[i]), t = p;
            }
    
    for(rl i=0; i < a[1]; ++ i)
        ans = max(ans, f[i] - m);
    

    cout << ans << endl;
    return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~这数据水到炸。~~

------------
## 前言：
本题别看它标着个蓝色标识，它其实跟个绿题差不多，所以本篇题解只讲大致思路，具体细节以及为什么笔者不会多赘述，请各位读者悉知。

------------
## 大致思路：
首先我们先把一开始我们得到的木棍长度预处理出来，并将其存在数组 $c$ 中，同时，我们建立一个 $minlength$ 变量用来储存最短的木棍，如果最短的木棍长度为 $1$，则说明建不出来，输出 $-1$。

然后我们抽象的把 $0$ 到 $minlength-1$ 的每一个长度看成一个点，将这些长度赋值给每个点，作为它们的点权，为后面的操作（也就是最短路做准备），因此我们要求的长度一定在这之间。

在跑最短路之前，我们还可以发现，如果我们能够组成某个长度 $x$， 且 $y = x \bmod minlength$，又设 $X = y + i \times minlength$，则我们一定能够组成所有的 $X$ 且这个 $X$ 满足下列关系（$X \bmod minlength$ 等于 $y$，小学数学除法移项就可以了）。如果不能组成呢？那么**我们一定不能组成任意一个 $X$ 使得 $X \bmod minlength$ 等于 $y$）**，也就是说，**不能组成的最大长度是无限大**，此时无解，输出 $-1$。如果能组成，我们只保存一个最小的 $x$（这个最小的 $x$ 一定大于 $minlength$），那么 $x - minlength$ 一定不能被组成。所以，抽象出 $minlength - 1$ 个点，用 $dis[i]$ 表示余数为 $i$ 的最小长度 $x$。根据一开始的木棍长度，首先得到 $dis[i]$ 的初始值，同时要全部赋值为最大值（就是 int 类型的最大值），来保证能跑出最短路（不然你能跑出个啥），然后边走边建边。跑 spfa 即可。

注意，这个建边过程是**边跑 spfa 边建边，且不用存每个点可连向那些点**，因为对于可以组成的 $i$，其他的每个点都可以与 $i$ 相连，即这边是它们**互相连通**的。

为什么要边跑 spfa 边建边呢？因为对当前 $i$，有一个 $j$，要使得 $(dis[i]+dis[j]) \bmod minlength$ 的值等于 $y$ 且 $dis[X]$ 并未被更新，因此 $dis[X]$ 为初始极大 INF，则建的边数组 $v$ 表中肯定不含这个点！这时候把这个点加入到 $v$ 中，才能够继续跑 spfa。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int INF = 0x3f3f3f3f3f;
int dis[3009];
int c[100009], vis[100009];
int n, m;
queue<int> q;
vector<int> v;
int min_length = INF;
int max_length = -5;
int iv[2009];
int spfa()
{
    for (int i = 0; i <= min_length; i++)
    {
        dis[i] = INF;
    }
    for (int i = 1; i <= c[0]; i++)
    {
        // cout << "ll:" << i << ' ' << c[i] << '\n';
        int now = c[i] % min_length;
        if (dis[now] == INF || dis[now] > c[i])
        {
            dis[now] = c[i];
            q.push(now);
        }
    }
    while (!q.empty())
    {
        int now = q.front();
        q.pop();
        vis[now] = 0;
        if (!iv[now])
        {
            v.push_back(now);
            iv[now] = 1;
        }
        for (int i = 0; i < v.size(); i++)
        {
            int nn = (dis[v[i]] + dis[now]) % min_length;
            if (dis[nn] > dis[now] + dis[v[i]])
            {
                dis[nn] = dis[now] + dis[v[i]];
                if (!vis[nn])
                {
                    vis[nn] = 1;
                    q.push(nn);
                }
            }
        }
    }
    // cout << endl;
    for (int i = 0; i < min_length; i++)
    {
        // cout << i << ' ' << min_length << ' ' << dis[i] << endl;
        if (dis[i] < INF)
        {
            max_length = max(max_length, dis[i]);
        }
        else
        {
            return -1;
        }
    }
    return max_length - min_length;
}
int main()
{
    n = read();
    m = read();
    for (int i = 1; i <= n; i++)
    {
        int x = read();
        for (int j = 0; j <= m && x - j; j++)
        {
            if (!vis[x - j])
            {
                vis[x - j] = 1;
                c[++c[0]] = x - j;
                min_length = min(min_length, c[c[0]]);
                if (x - j == 1)
                {
                    cout << -1 << endl;
                    return 0;
                }
            }
        }
    }
    cout << spfa() << endl;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122210705)

---

## 作者：Z1qqurat (赞：0)

同余最短路板子题，借此讲一下同余最短路的流程和原理。

* 首先同余最短路解决的是这样一类问题：有 $n$ 个数，分别为 $a_1, a_2, \dots, a_n$，求在某个范围内最大的不能被表示为 $\sum\limits_{i=1}^{n}{a_i \times c_i}, c_i \ge 0$ 的正整数 $x$。

  > 其实这个题也可以被转化为这种形式：因为每种长为 $a_i$ 的木板，可以被变为长为 $a_i, a_i - 1, \dots, \max(0, a_i - m)$ 的木板。所以我们将所有原有的木板长度和所有被切割后的可能长度存入 $a$，就转化为上面的模板问题了。

  乍一看像是一个完全背包问题，但是范围 $[0, R]$ 可达 $10^{18}$，那怎么做？

* 考虑以 $a$ 中最小的数为基底，设这个数为 $a_1$，那么所有 $[0, R]$ 的数都可以被分入模 $a_1$ 的 $a_1$ 个同余类（$0, 1, \dots, a_1 - 1$）中的恰好一个。发现在同一个同余类中，如果 $x$ 可以被凑出，那么 $x + k \times a_1$ 也可以被凑出。也就是说如果一个数 $x$ 可以被凑出那么和它处于同一个同余类内 $\ge x$ 的数都凑得出来了（这玩意儿在同一个同余类中有单调性）。所以我们只需要对每一个同余类 $i$ 求出一个 $f_i$，表示该类中最小的能被 $a$ 表示出来的数，那么类 $i$ 中，所有大于等于 $f_i$ 的数都能被凑出，小于 $f_i$ 的数都凑不出。

* 那么怎么算出 $f_i$ 呢？考虑如果 $x$ 能被凑出来，那么 $x + a_i(i \in [2, n])$，也能被表示出来。考虑以同余类为点，点 $i$ 向所有同余类 $(i + a_j) \bmod a_1$ 连长为 $a_j$ 的边，其中 $j \in [2, n]$，那么 $f_i$ 就是起点 $0$ 到点 $i$ 的最短路。跑 SPFA 或 Dijkstra 即可，点数为 $a_1$，边数最多为 $a_1 \times n$。

* 答案 $x = \max\limits_{i \in [0, a_1 - 1]} (f_i - a_1)$，$f_i-a_1$ 就表示同余类 $i$ 中最大的无法凑出的数。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#define ll long long
#define pii pair<int, ll>
#define mr make_pair
using namespace std;
const int N = 3e5 + 5;
int n, nn, m, a[N];
ll ans, f[N];
bool inq[N], vis[N];
vector <pii> G[N];
queue <int> q;

void build() {
    nn = n;
    for (int i = 1; i <= nn; ++i) {
        for (int j = 1; j <= min(a[i], m); ++j) {
            if(!vis[a[i] - j]) {
                a[++n] = a[i] - j;
                vis[a[i] - j] = 1;
            }
        }
    }
    sort(a + 1, a + n + 1);
    for (int i = 0; i < a[1]; ++i) {
        for (int j = 2; j <= n; ++j) {
            G[i].push_back(mr((i + a[j]) % a[1], a[j]));
        }
    }
    return ;
}

void SPFA() {
    memset(f, 0x3f, sizeof(f));
    q.push(0), inq[0] = 1, f[0] = 0;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        for (int i = 0; i < G[u].size(); ++i) {
            int v = G[u][i].first; ll w = G[u][i].second;
            if(f[v] > f[u] + w) {
                f[v] = f[u] + w;
                if(!inq[v]) q.push(v), inq[v] = 1;
            }
        }
    }
    return ;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        vis[a[i]] = 1;
    }
    build();
    SPFA();
    ll ans = -1e18;
    for (int i = 0; i < a[1]; ++i) {
        if(f[i] != 0x3f3f3f3f3f3f3f3fll) {
            ans = max(ans, f[i] - a[1]);
        }
    }
    if(ans == -1e18) puts("-1");
    else printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：zhoujinrui (赞：0)

# 问题简述

- [问题传送门](https://www.luogu.com.cn/problem/P2662)。

- 题面简述：给定 $n$ 个数，以及一个 $m$ 表示每个数可以减小 $1 \sim m$ 再使用，求出最大的无法拼凑的数。若无解输出 $-1$。

# 前置芝士

- [详细的同余最短路](https://www.luogu.com.cn/blog/zhoujinrui/tong-yu-zui-duan-lu)。

- 这里简单地讲一下同余最短路：一般用于求解 $\sum_{i=1}^na_ix_i=k$ 中 $k$ 的取值方案数，且 $k$ 有一定上线的问题。

- 接下来以一个问题为例：已知 $x,y,z,h$，求不定方程 $ax+by+cz=k\ (k<=h)$ 中 $k$ 有多少种不同的取值。

- 令 $f_i$ 为 **最小的**模 $x$ 等于 $i$ 的数。考虑转移
	$$\begin{cases}
    f_{(i+y) \operatorname{mod}x}=f_i+y\\
    f_{(i+z) \operatorname{mod}x}=f_i+z
   \end{cases}$$
    
- 这很像**单源最短路**？于是我们就用单源最短路来进行状态转移。求得这个 $f$ 数组后便可以根据题意灵活的算出一些答案。

# 问题求解

- 我们回到正题，我们同样考虑同余最短路求解问题。

- 先暴力建边，复杂度 $O(nm)$。 

- 钦定 $p=\operatorname{min}\{a\}-m$，我们依然令 $f_i$ 为**最小的**模 $p$ 等于 $i$ 的数，用最短路进行对 $f$ 数组的状态转移后怎么计算出答案？

- 先一个个考虑剩余系当中的情况。对于 $f_i$，其含义为**最小的**模 $p$ 等于 $i$ 的数，那么 $f_i-p$ 既与 $f_i$ 同余，也是该剩余类中**最大**的拼凑不出来的数。

- 我们最后来枚举**所有的剩余类**，答案即为 $\operatorname{max}_{i=1}^{p-1}\{f_i-p\}$。

- 还有一些**无解**的情况：
	1. 数列中有 $1$，可以凑出任何数，无解。
    1. 无法拼出某个剩余类，那么 $f_i=∞$，无解。

# code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 5e6 + 5;
const int INF=0x3f3f3f3f;

int n, m;
int p, ans, cnt;
int hd[MAXN], dis[MAXN], a[MAXN];
bool vis[MAXN];

queue <int> q;

struct edge{
	int nt, v, w;
}e[MAXN];

int read(){
	char ch=getchar(); int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}

void addedge(int u, int v, int w) {
	e[++cnt].v = v; 
   	e[cnt].w = w;
	e[cnt].nt = hd[u]; 
    hd[u] = cnt;
}

void Spfa(){
    memset(dis, 0x3f, sizeof dis);
    dis[0] = 0; q.push(0); vis[0] = 1;
    while(!q.empty()) {
        int u = q.front();
        q.pop(); vis[u] = 0;
        for(int i = hd[u]; i; i = e[i].nt) {
            int v = e[i].v;
            if(1LL * dis[u] + 1LL * e[i].w < dis[v]){
                dis[v] = dis[u] + e[i].w;
                if(!vis[v]){
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    } 
}

void init() {//建边 
	for(int i = 1; i <= n; ++i)  {//枚举每种木料 
		for(int j = max(a[i - 1] + 1, a[i] - m); j <= a[i]; ++j) {//枚举削去的方案 
			if(j != p) {
				for(int k = 0; k < p; ++k)
					addedge(k, (k + j) % p, j);//假设所有的k点都能被到达并建边，如果k无法到达后面有特判 
			}
		}
	}
}

int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; ++i) a[i] = read();
	sort(a + 1, a + 1 + n);
	p = max(1, a[1] - m);//最小值最为取模的数
	if(p == 1) {
		puts("-1");//有1则无解 
		return 0;
	}
	init();//建边
	Spfa();//状态转移用Spfa实现
	for(int i = 0; i < p; ++i) {
		if(dis[i] >= INF) {//无法凑出该剩余类则无解
			puts("-1");
			return 0;
		}
		ans = max(ans, dis[i] - p);//比较答案
	}
	
	printf("%d\n", ans);
	return 0;
} 
```




---


# [NOI2003] 木棒游戏

## 题目背景

这是一个很古老的游戏。用木棒在桌上拼出一个不成立的等式，移动且只移动一根木棒使得等式成立。现在轮到你了。


## 题目描述

你只能移动用来构成数字的木棒，不能移动构成运算符（+、-、=）的木棒，所以加号、减号、等号是不会改变的。移动前后，木棒构成的数字必须严格与图2中的0~9相符。如果移动一根木棒可以使等式成立，则输出新的等式，否则输出No。


## 样例 #1

### 输入

```
1+1=3#```

### 输出

```
1+1=2#```

## 样例 #2

### 输入

```
1+1=3+5#```

### 输出

```
No```

## 样例 #3

### 输入

```
11+77=34#```

### 输出

```
17+17=34#```

# 题解

## 作者：jun头吉吉 (赞：7)

## 一道~~简单~~的模拟题

首先我们来看一下题面

![严格与图2中的0~9相符](https://cdn.luogu.com.cn/upload/image_hosting/h06x84mu.png)

**???** 图呢

![黑人问号](https://cdn.luogu.com.cn/upload/image_hosting/owt05ia3.png)

根据我们的生活经验，我们知道$0\to 9$应该是这么摆的：

![0~9](https://cdn.luogu.com.cn/upload/image_hosting/2uni3enp.png)

首先我们发现，题目中**不能移动构成运算符（+、-、=）的木棒** ，因此我们不管怎么移动数字的木棒，这个数的加、减和位数是不变的。我们如果把所有的数字都按照位数拆开来，以样例为例

```
11+77=34
```

变成

```
1*10+1*1+7*10+7*1=3*10+4*1
```

那么不管数字怎么变，它后面乘的多少是不会变的，因此我们可以提前处理好。然而在等号两边让我们看起来很不爽，反正符号不会变，我们可以通过**初中知识**移项将其全部移到一遍就ok了

```
1*10+1*1+7*10+7*1-3*10-4*1=0
```

那我们现在只需要通过更改上式中任意两个第一项使其成立就做完了

我们知道$n\le 1000$，因此我们完全可以枚举两个数，然后考虑移动火柴带来的情况，在判断是否成立

由于我比较懒，用了一种常数较大的$O(n^2)$算法，即选一个有火柴的地方，在选取一个没有火柴的地方，移动火柴，判断式子是否成立（其实这么做枚举了很多不必要的情况）

对于一个数字，选择用状压去描述，如果有第$i$根火柴，二进制下第$i$位就是$1$，反之为$0$

当对第$i$根火柴进行更改时，就把数字$\oplus2^i$即可

具体实现可以参考代码

```cpp
#include<bits/stdc++.h>
char ch[2000];
const int n[10]={0b1111011,//0
				 0b1001000,//1
				 0b0111101,//2
				 0b1101101,//3
				 0b1001110,//4
				 0b1100111,//5
				 0b1110111,//6
				 0b1001001,//7
				 0b1111111,//8
				 0b1101111//9
				 };
struct num{//数字 
	int val;//权值 
	int des;//描述
	/*
	 _   1
	|_|  2 3 4
	|_|  5 6 7 
	*/
	/*                  7 6 5 4 3 2 1
	1  4 7              1 0 0 1 0 0 0
	2  1 3 4 5 6        0 1 1 1 1 0 1
	3  1 3 4 6 7        1 1 0 1 1 0 1
	4  2 3 4 7          1 0 0 1 1 1 0
	5  1 2 3 6 7        1 1 0 0 1 1 1
	6  1 2 3 5 6 7      1 1 1 0 1 1 1
	7  1 4 7            1 0 0 1 0 0 1
	8  1 2 3 4 5 6 7    1 1 1 1 1 1 1
	9  1 2 3 4 6 7      1 1 0 1 1 1 1
	0  1 2 4 5 6 7      1 1 1 1 0 1 1
	*/
	bool check(){//检验是否合法 
	 	for(int i=0;i<10;i++)
	 		if(val==n[i])
	 			return true;
	 	return false;
	}
	bool check(int w){//检验第w根是否存在 
		if(val>>w&1!=0)return true;
		return false; 
	}
	bool change(int w){//更改w根的位置 
		val^=(1<<w);
	}
	int get(){
		for(int i=0;i<10;i++)
			if(val==n[i])
				return i;
	}
	num(int _N=0,int Wi=0,int type=0){//_N表示数值  Wi表示位置 
		val=n[_N];
		des=type*pow(10,Wi); 
	}
}a[2000];
bool check(num *t,int L){//检查 
	int num=0;
	for(int i=1;i<=L;i++){
		if(!t[i].check())return false;
		num+=t[i].des*t[i].get();
	}
	return num==0;
}
int tot=0;
signed main(){
	//freopen("t.in","r",stdin);
	int len=0,eq=1;
	while(true){
		ch[++len]=getchar();
		if(ch[len]=='#')break;
	}
	while(ch[eq]!='=')eq++;
	//分别处理等号前后
	//把右边的等价到左边
	for(int i=len-1,j;i>eq;i=j-1){
		j=i;
		while(j-1>0&&isdigit(ch[j-1]))j--;
		int type=-1;
		if(ch[j-1]=='-')type=1;
		for(int w=i;w>=j;w--)
			a[++tot]=num(ch[w]-'0',i-w,type);
		if(ch[j-1]=='+'||ch[j-1]=='-')j--;
	} 
	for(int i=eq-1,j;i>=1;i=j-1){
		j=i;
		while(j-1>0&&isdigit(ch[j-1]))j--;
		int type=1;
		if(ch[j-1]=='-')type=-1;
		for(int w=i;w>=j;w--)
			a[++tot]=num(ch[w]-'0',i-w,type);
		if(ch[j-1]=='+'||ch[j-1]=='-')j--;
	} 
	//for(int i=1;i<=tot;i++)
	//	printf("%d*%d ",a[i].get(),a[i].des);
	check(a,tot);
	for(int i=1;i<=tot;i++)
		for(int j=0;j<8;j++)//枚举拿走的火柴
			if(a[i].check(j))
				for(int w=1;w<=tot;w++)
					for(int k=0;k<8;k++)
						if(!a[w].check(k)){
							//将i的j放到w的k上
							a[i].change(j);
							a[w].change(k);
							if(check(a,tot)){
								int p=tot;
								for(int i=1;i<=len;i++)
									if(isdigit(ch[i]))putchar(a[p--].get()+'0');
									else putchar(ch[i]);
								return 0;
							} 
							a[i].change(j);
							a[w].change(k);
						}
	printf("No"); 
	return 0;
}
```

~~跑得慢了点但能过就对了~~

---

## 作者：_maojun_ (赞：4)

一种避免模拟计算值的写法。

---

题意大概就是说，给你一个错误的等式，然后问你是否能只移动一根火柴使等式成立。

把所有的数按位拆开然后丢到等式的一边，最后的式子形如 $\sum\limits a_i\times b_i\times10^{k_i}=0$，其中 $a_i\in\{-1,1\},b_i\in[0,9],k_i\in\mathbb N$。

然后暴力枚举两个数，看一下能否通过改变着两个数达成目标。这里枚举两个数已经达到 $O(n^2)$，加上枚举两个数的最终状态有多了 $10\times10=100$ 倍的常数，判断的函数必须为 $O(1)$。

注意到字符串长度小等 $1000$，最坏情况下可能会让你比较两个几百位数是否相等，如果暴力显然会超时，于是考虑直接哈希。

把所有计算值的东西用 `unsigned long long` 存起来，然后认为计算出来等式左边的值为 $0$ 则原式成立。本来以为单哈希会被卡准备着待会就加成双哈希，但是还真给过了。

这种做法常数本身比较小，所以跑到很快。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;

typedef unsigned long long ull;
const int MAXN=1e3+5;
int n,tot=0;ull d[MAXN];char s[MAXN];
struct node{
	int num,pos,flag;ull index;                             // num 是这个数的数码，pos 是这个数在原字符串中对应的位置，flag 区分正负，index 表示 10^k
	node():num(0),index(0),flag(0),pos(0){}
	node(int num,ull index,int flag,int pos):num(num),index(index),flag(flag),pos(pos){}
	inline ull val(){return num*index*flag;}
	inline ull instead(int k){return(k-num)*index*flag;}    // a[i].instead(k) 意思是把 a[i] 的数码改为 k 对左式的和产生的影响
}a[MAXN];

bool g[10][10],gg[10][10];  // g[u][v] ：为 true 表示 u 去掉一个火柴可以得到 v，等价于 v 去掉一个火柴可以得到 u
// gg[u][v]：其中 u<v，表示 u 去掉一个火柴，再加上一个火柴可以得到 v
inline void init(){
	g[0][8]=true;
	g[1][7]=true;
	g[3][9]=true;
	g[5][6]=g[5][9]=true;
	g[6][8]=true;
	g[9][8]=true;
	gg[0][6]=gg[0][9]=true;
	gg[2][3]=true;
	gg[3][5]=true;
	gg[6][9]=true;
}
inline void print(){
	for(int i=1;i<=n;i++)printf("%c",s[i]);
	printf("\n");exit(0);
}
int main(){
	for(char ch;scanf(" %c",&ch);){
		s[++n]=ch;if(ch=='#')break;     // 据说在 # 之后可能还有字符，但要忽视掉
	}
	for(int i=n;i>=1;i--)
		if(isdigit(s[i])&&isdigit(s[i+1]))d[i]=d[i+1]*10;
	else d[i]=1;
	int op=1,flag=1;
	for(int i=1;i<=n;i++)
		if(s[i]=='+')op=1;
	else if(s[i]=='-')op=-1;
	else if(s[i]=='=')flag=-1,op=1;		// 过了等号之后符号要取反
	else if(s[i]^'#')a[++tot]=node(s[i]-0x30,d[i],op*flag,i);
	ull sum=0;
	for(int i=1;i<=tot;i++)sum+=a[i].val();
	init();
	for(int i=1;i<=tot;i++){            // 枚举火柴从哪里移动到哪里
		for(int k=0;k<10;k++)
			if(gg[a[i].num][k]||gg[k][a[i].num]){
				if(!(sum+a[i].instead(k)))
					s[a[i].pos]=k+0x30,print();
			}
		for(int j=1;j<=tot;j++)if(i^j)
			for(int k=0;k<10;k++)if(g[a[i].num][k])
				for(int l=0;l<10;l++)if(g[l][a[j].num])
					if(!(sum+a[i].instead(k)+a[j].instead(l)))
						s[a[i].pos]=k+0x30,s[a[j].pos]=l+0x30,print();
	}
	printf("No\n");
	return 0;
}
```

类似邻接表相对邻接矩阵的优化，用对 vector 的遍历代替对 bool 数组的枚举，做到一点常数上的优化。

```cpp
#define pb push_back
//...
vector<int>g1[10],g2[10],gg[10];
inline void init(){       	  // 表稍微写得长了一点
	g1[0].pb(8);
	g1[1].pb(7);
	g1[3].pb(9);
	g1[5].pb(6);g1[5].pb(9);
	g1[6].pb(8);
	g1[9].pb(8);
	g2[6].pb(5);
	g2[7].pb(1);
	g2[8].pb(0);g2[8].pb(6);g2[8].pb(9);
	g2[9].pb(3);g2[9].pb(5);
	gg[0].pb(6);gg[0].pb(9);
	gg[2].pb(3);
	gg[3].pb(2);gg[3].pb(5);
	gg[5].pb(3);
	gg[6].pb(0);gg[6].pb(0);
	gg[9].pb(0);gg[9].pb(6);
}
int main(){
	//...
	init();
	for(int i=1;i<=tot;i++){    // 改成遍历 vector
		for(int k:gg[a[i].num])
			if(!(sum+a[i].instead(k)))
				s[a[i].pos]=k+0x30,print();
		for(int j=1;j<=tot;j++)if(i^j)
			for(int k:g1[a[i].num])for(int l:g2[a[j].num])
				if(!(sum+a[i].instead(k)+a[j].instead(l)))
					s[a[i].pos]=k+0x30,s[a[j].pos]=l+0x30,print();
	}
	printf("No\n");
	return 0;
}
```

---

## 作者：zoobidubi (赞：3)

前言：经受了今年[CSP-2020T1](https://www.luogu.com.cn/problem/P7075)爆掉的惨烈教训，决定刷一些能力范围内的模拟好题来提升一下模拟的能力.

 ·题意 : 给你一个等式，让你移动一根**组成数字**的火柴棒(只有一根), 使得移动这根火柴棒后， 等式成立， 即左右两边相等。


**1. 细节1**:  题目给出的字符串的"#"后面可能含有其它不相关的字符，要忽略掉这些字符

所以我们可以这样读入

```
while (1) 
{
    char c = getchar();
    if (c != '#') s[++ len] = c;
    else break;	
}
```

当我们读取到非‘#’的字符就把这个字符加进字符数组里，一旦读入到‘#’，立刻break掉

**2. 细节2**   ：因为我们不确定给出的算式是否可能会出现这样的（eg: -9+6 = 9）即第一个数字前面有符号(可能为加号也可能为减号), 所以我们要特判一波

```
   if (pos == 1 && s[1] == '-') hao = 1, pos ++;
	else if (pos == 1 && s[1] == '+') hao = 0, pos ++;
	else if (pos != 1) hao = (s[pos] == '-'), pos ++;
	else hao = 0;
    
```
像这样，我们就把字符串最开始出现的符号记录下来了，在加的时候再特判处理

**3.  细节3:** 在打字符转换表的时候要细心考虑到所有可能的情况(我就是因为这个WA了QWQ)


- **具体实现思路** : 分两次枚举，第一次一重循环枚举**单个**数字移动火柴，第二次两重循环枚举**两个数字间的火柴移动**，当找到可以从某个数字转换到另外一个数字的时候，就尝试变换，并判断这个式子左右两边是否相等

具体看代码

code:

```
#include<bits/stdc++.h>
using namespace std;
char s[100101];
int len;
int a1[11][11] = {
	{0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
	{0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 0, 0, 0, 0, 0, 1, 0, 0, 0}
};//记录自己转移火柴棒到自己的矩阵
int a2[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
    {0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0}
};//记录添加一根火柴棒能转移到哪些数的矩阵
int a3[11][11] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
	{1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
	{0, 0, 0, 1, 0, 1, 0, 0, 0, 0}
};//记录减少一根火柴棒能转移到哪些数的矩阵
bool ok() {//判断等式是否成立
	int pos = 1, ans1 = 0, ans2 = 0, flag = 0, res = 0, hao = 0, sp = 1, edpos = 0;//赋初始值
	while (pos <= len) {
		if (s[pos] == '=') {
			flag = 1, pos ++, edpos = pos;//到等号就把flag置为1
			continue;
		}
		if (!flag){//计算等号左边
			if (pos == 1 && s[1] == '-') hao = 1, pos ++;
			else if (pos == 1 && s[1] == '+') hao = 0, pos ++;
			else if (pos != 1) hao = (s[pos] == '-'), pos ++;
			else hao = 0;//特判开头的符号
			int r = pos;//记录下能扩展到的右边端点
			while (s[r + 1] >= '0' && s[r + 1] <= '9' && r + 1 <= len) r ++;//下一位是数字且往下一位不会超出字符串长度，就往下扩展一个
			sp = 1, res = 0;
			for (int i = r; i >= pos; i --) {
				res += sp * int(s[i] - '0');
				sp = sp * 10;
			}//倒序循环计算和
			pos = r + 1, sp = 0;//pos跳到右边端点+1,中间量清零
			if (hao) res = - res;//如果有负号,置为负
			ans1 += res;//加上中间量
			res = 0, hao = 0;//清零
		} else {//下面计算等号右边的其实同理，只是在特判初始负号的时候要看是否等于edpos
            if (pos == edpos && s[pos] == '-') hao = 1, pos ++;
			else if (pos == edpos && s[pos] == '+') hao = 0, pos ++;
			else if (pos != edpos) hao = (s[pos] == '-'), pos ++;
			else hao = 0;
			int r = pos;
			while (s[r + 1] >= '0' && s[r + 1] <= '9' && r + 1 <= len) r ++;
			sp = 1, res = 0;
			for (int i = r; i >= pos; i --) {
				res += sp * int(s[i] - '0');
				sp = sp * 10;
			}
			pos = r + 1, sp = 0;
			if (hao) res = - res;
			ans2 += res;
			res = 0, hao = 0;
		}
	}
    return (ans1 == ans2);// 如果计算的总和相等就返回true
}
int main() {
    while (1) {
    	char c = getchar();
    	if (c != '#') s[++ len] = c;
    	else break;
	}//读入字符串
    for (int i = 1; i <= len; i ++) {
    	char c = s[i];//存下这个位置原本的数字
    	if (c == '-' || c == '+' || c == '=' || c == '#') continue;
    	for (int j = 0; j <= 9; j ++)
		    if (a1[int(c - '0')][j]) //如果这个数字可以自己转换成另外一个数字
			{
		        s[i] = char('0' + j);//将这个字母替换
		        if (ok()){//可以就输出
		        	for (int k = 1; k <= len; k ++)
		        		cout << s[k];
		        	cout <<'#';
					return 0;
				}
		        else s[i] = c;//不成立的话就换回原来的
	        }
	}
	for (int i = len; i >= 1; i --) {
		if (s[i] > '9' || s[i] < '0') continue;//找数字替换，不是数字的就continue
        for (int j = len; j >= 1; j --) {
        	if (s[j] > '9' || s[j] < '0') continue;
        	//i + 1, j - 1
			for (int k = 0; k <= 9; k ++)//枚举0~9，看看是否能够转移火柴棒
			    for (int l = 0; l <= 9; l ++) {
	            if (a3[int(s[i] - '0')][k] && a2[int(s[j] - '0')][l]) //如果让s[i]这个位置减掉一根，让s[j]这个位置增加一根成立
			    { 
			    	int c1 = s[i], c2 = s[j];//记录原本的
		            s[i] = char('0' + k);
		            s[j] = char('0' + l);// 替换
		            if (ok()){
		        	    for (int mm = 1; mm <= len; mm ++)
		        		    cout << s[mm];
		        	    cout <<'#';
					    return 0;
				    } else s[i] = c1, s[j] = c2;//换回原本的
	            } else if (a2[int(s[i] - '0')][k] && a3[int(s[j] - '0')][l]) {//反之，如果让s[i]这个位置加上一根，让s[j]这个位置减掉一根成立
			    	int c1 = s[i], c2 = s[j];
		            s[i] = char('0' + k);
		            s[j] = char('0' + l);//同理
		            if (ok()){
		        	    for (int mm = 1; mm <= len; mm ++)
		        		    cout << s[mm];
		        	    cout <<'#';
					    return 0;
				    } else s[i] = c1, s[j] = c2;
	        }
	    }
		}
	}
	cout << "No";//如果都不成立的话就输出No
	return 0;
}
```
- **后记**

这题按照这样的打法来说应该是O(n^2 * 100) 的，因为中间很多冗余的循环被continue掉了，所以不会T

遇到这种大模拟，初始的框架是很重要的，最好先打出框架，再仔细分析好细节再动键盘，这种题调起来还是很崩心态的QWQ

最后，祝各位NOIP2020 RP ++ !

---

## 作者：Caro23333 (赞：3)

既然没有题解那就来水一发......

可以将移动一根木棍的操作视为拿走一根，再放进来一根

那么我们预处理每个数字可以拿走哪些位置的木棍，以及可以在哪些位置放进来木棍

然后枚举拿走的位置和放的位置，计算等式左右的变化量来O(1)判定是否合法

记得单独处理拿走的位置和放回来的位置相同的情况

可以O(n^2)解决此题

代码：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <map>
#include <vector>

using namespace std;
const int MAXN = 1005;
typedef long long ll;
map<int,int> mpa,mpb;
vector<int> canput[11],candel[11],canchg[11];
int deg[MAXN],n = 0;
bool lastop[MAXN],side[MAXN];
ll bin[20];
inline void init_put_del(int x)
{
    if(x==0)
        canput[x].push_back(8), canchg[x].push_back(6), canchg[x].push_back(9);
    else if(x==1)
        canput[x].push_back(7);
    else if(x==2)
        canchg[x].push_back(3);
    else if(x==3)
        canput[x].push_back(9), canchg[x].push_back(2), canchg[x].push_back(5);
    else if(x==5)
        canput[x].push_back(9), canput[x].push_back(6), canchg[x].push_back(3);
    else if(x==6)
        canput[x].push_back(8), candel[x].push_back(5), canchg[x].push_back(0), canchg[x].push_back(9);
    else if(x==7)
        candel[x].push_back(1);
    else if(x==8)
        candel[x].push_back(6), candel[x].push_back(9), candel[x].push_back(0);
    else if(x==9)
        canput[x].push_back(8), candel[x].push_back(3), canchg[x].push_back(0), canchg[x].push_back(6);
}  
char str[MAXN];
inline void print(int posx, int tmpx, int posy, int tmpy)
{
    for(int i = 1; i<=n; i++)
    {
        if(!isdigit(str[i])) cout << str[i];
        else
        {
            if(i!=posx&&i!=posy)
                cout << str[i];
            else if(i==posx&&i!=posy)
                cout << tmpx;
            else if(i!=posx&&i==posy)
                cout << tmpy;
            else if(i==posx&&i==posy)
                cout << tmpy;
        }
    }
    cout << "#" << endl;
}
ll leftsum,rightsum,tmpleftsum,tmprightsum;
inline void calc(int posx, int posy, int orgx, int tmpx, int orgy, int tmpy)
{
    tmpleftsum = leftsum, tmprightsum = rightsum;
    if(!side[posx])
    {
        if(lastop[posx]) tmpleftsum += bin[deg[posx]]*(tmpx-orgx);
        else tmpleftsum -= bin[deg[posx]]*(tmpx-orgx);
    }
    else 
    {
        if(lastop[posx]) tmprightsum += bin[deg[posx]]*(tmpx-orgx);
        else tmprightsum -= bin[deg[posx]]*(tmpx-orgx);
    }
    if(!side[posy])
    {
        if(lastop[posy]) tmpleftsum += bin[deg[posy]]*(tmpy-orgy);
        else tmpleftsum -= bin[deg[posy]]*(tmpy-orgy);
    }
    else
    {
        if(lastop[posy]) tmprightsum += bin[deg[posy]]*(tmpy-orgy);
        else tmprightsum -= bin[deg[posy]]*(tmpy-orgy);
    }
}

int main()
{
    while(1)
    {
        cin >> str[++n];
        if(str[n]=='#')
        {
            n--;
            break;
        }
    }
    for(int i = 0; i<10; i++)
        init_put_del(i);
    bin[0] = 1;
    for(int i = 1; i<=18; i++)
        bin[i] = bin[i-1]*10;
    deg[n+1] = -1;
    for(int i = n; i>=1; i--)
    {
        if(!isdigit(str[i])) deg[i] = -1;
        else deg[i] = deg[i+1]+1;
    }
    bool flag = false, op = true;
    for(int i = 1; i<=n; i++)
    {
        if(str[i]=='=') op = flag = true;
        else if(str[i]=='+') op = true;
        else if(str[i]=='-') op = false;
        else
        {
        	lastop[i] = op, side[i] = flag;
            if(!flag&&op) leftsum += bin[deg[i]]*(str[i]-'0');
            if(!flag&&!op) leftsum -= bin[deg[i]]*(str[i]-'0');
            if(flag&&op) rightsum += bin[deg[i]]*(str[i]-'0');
            if(flag&&!op) rightsum -= bin[deg[i]]*(str[i]-'0');
        }
    }
    for(int i = 1; i<=n; i++)
    {
        if(!isdigit(str[i])) continue;
        for(int j = 0; j<candel[str[i]-'0'].size(); j++)
        {
            int orgx = str[i]-'0', tmpx = candel[str[i]-'0'][j];
            for(int k = 1; k<=n; k++)
            {
            	if(!isdigit(str[k])) continue;
            	int tmpy,orgy;
            	if(k==i) continue;
                else orgy = str[k]-'0';
                for(int l = 0; l<canput[orgy].size(); l++)
                {
                    tmpy = canput[orgy][l];
                    calc(i,k,orgx,tmpx,orgy,tmpy);
                    if(tmpleftsum==tmprightsum)
                    {
                        print(i,tmpx,k,tmpy);
                        return 0;
                    }
                }
            }
        }
    }
    for(int i = 1; i<=n; i++)
    {
        if(!isdigit(str[i])) continue;
        int orgx = str[i]-'0', tmpx;
        for(int j = 0; j<canchg[orgx].size(); j++)
        {
            tmpx = canchg[orgx][j];
            if(!side[i]&&lastop[i])
                if(leftsum+bin[deg[i]]*(tmpx-orgx)==rightsum)
                {
                    print(i,tmpx,i,tmpx);
                    return 0;
                }
            if(!side[i]&&!lastop[i])
                if(leftsum-bin[deg[i]]*(tmpx-orgx)==rightsum)
                {
                    print(i,tmpx,i,tmpx);
                    return 0;
                }
            if(side[i]&&lastop[i])
                if(leftsum==rightsum+bin[deg[i]]*(tmpx-orgx))
                {
                    print(i,tmpx,i,tmpx);
                    return 0;
                }
            if(side[i]&&!lastop[i])
                if(leftsum==rightsum-bin[deg[i]]*(tmpx-orgx))
                {
                    print(i,tmpx,i,tmpx);
                    return 0;
                }
        }
    }
  	cout << "No" << endl;
    return 0;
}
```

---

## 作者：ybw0731 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P2702)

# Part 1 题意

- 给你一个错误的等式，然后让你只移动一根木棒，让它变成一个正确的等式。（不能将符号变换）

# Part 2 思路

- 首先我们会发现，这个字符串最多有 $1000$ 个字符，所以它很可能会让你比较两个 $10^{500}$ 量级的数进行比较。

- 所以我们是不可能把每个数都存起来进行比较的，只能使用哈希大法。

## Part 2.1 预处理

```cpp
unsigned long long num[N];
//每位对应的数量级
//这里把每一位都看成一个数

for(int i=n;i>=1;i--) 
		if('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9')
			num[i]=num[i+1]*10;
		else num[i]=1;
```

- 然后，我们把所有的数都移到左边。

```cpp
struct Node{
	int num,pos,flag,id;
  //数码，位置，前面的符号，数量级
}a[N];
//存储每个数

//f1:数前面是减号还是加号
//f2:在等号左边还是右边
for(int i=1;i<=n;i++)
		if(s[i]=='+') f1=1;
		else if(s[i]=='-') f1=-1;
		else if(s[i]=='='){
			f1=1;
			f2=-1;
		}else if(s[i]-'#')
			a[++tot]={s[i]-'0',i,f1*f2,num[i]};
```

- 然后我们把所有数的总和加起来。
```cpp
for(int i=1;i<=tot;i++)
		sum+=a[i].flag*a[i].id*a[i].num;
// flag*id*num 为这个数的值
```

## Part 2.2 移动木棒

- 不妨注意到，移动一根木棒有两种方式
  - 自己->自己
  - 自己->别人
- 那么，我们预处理三个映射
  - $mp[x][1]$ 表示把 $x$ 加一根木棒可以变到那些数
  - $mp[x][2]$ 表示把 $x$ 减一根木棒可以变到那些数
  - $mp[x][3]$ 表示把 $x$ 的一根木棒移到另一个位置可以变到那些数。
  - 注意：一个数可能会变成多个数，所以要用 vector。
```cpp
void Init(){
	mp[0][1].push_back(8);
	mp[1][1].push_back(7);
	mp[3][1].push_back(9);
	mp[5][1].push_back(6);
	mp[5][1].push_back(9);
	mp[6][1].push_back(8);
	mp[9][1].push_back(8);
	
	mp[6][2].push_back(5);
	mp[7][2].push_back(1);
	mp[8][2].push_back(0);
	mp[8][2].push_back(6);
	mp[8][2].push_back(9);
	mp[9][2].push_back(3);
	mp[9][2].push_back(5);
	
	mp[0][3].push_back(6);
	mp[0][3].push_back(9);
	mp[2][3].push_back(3);
	mp[3][3].push_back(2);
	mp[3][3].push_back(5);
	mp[5][3].push_back(3);
	mp[6][3].push_back(0);
	mp[6][3].push_back(9);
	mp[9][3].push_back(0);
	mp[9][3].push_back(6);
} 
```

- 然后枚举每个数，再枚举它可以变道那些数，最后计算改变后总和的变化即可。

```cpp
for(int i=1;i<=tot;i++){
    //自己 -> 自己
		for(int nxt:mp[a[i].num][3])
			if(sum+a[i].flag*a[i].id*(nxt-a[i].num)==0){
        //flag*id*(nxt-num)为变化的数的大小
				s[a[i].pos]=nxt+'0';
				Print();
			}
		for(int j=1;j<=tot;j++){
			if(i==j) continue;
      //自己 ->别人
			for(int nxt1:mp[a[i].num][1])
				for(int nxt2:mp[a[j].num][2])
					if(sum+a[i].flag*a[i].id*(nxt1-a[i].num)+a[j].flag*a[j].id*(nxt2-a[j].num)==0){
						s[a[i].pos]=nxt1+'0';
						s[a[j].pos]=nxt2+'0';
						Print();
					}
		}
	}
```

# Part 3 总代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define U unsigned
using namespace std;
inline int read(){
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){
		if(s=='-') f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9'){
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	return x*f;
}
const int N=1e3+5;
char s[N];
int n,f1=1,f2=1,tot;
U int num[N];
U int sum;
struct Node{
	int num,pos,flag,id;
}a[N];
vector<int>mp[10][4];
void Init(){
	mp[0][1].push_back(8);
	mp[1][1].push_back(7);
	mp[3][1].push_back(9);
	mp[5][1].push_back(6);
	mp[5][1].push_back(9);
	mp[6][1].push_back(8);
	mp[9][1].push_back(8);
	
	mp[6][2].push_back(5);
	mp[7][2].push_back(1);
	mp[8][2].push_back(0);
	mp[8][2].push_back(6);
	mp[8][2].push_back(9);
	mp[9][2].push_back(3);
	mp[9][2].push_back(5);
	
	mp[0][3].push_back(6);
	mp[0][3].push_back(9);
	mp[2][3].push_back(3);
	mp[3][3].push_back(2);
	mp[3][3].push_back(5);
	mp[5][3].push_back(3);
	mp[6][3].push_back(0);
	mp[6][3].push_back(9);
	mp[9][3].push_back(0);
	mp[9][3].push_back(6);
} 
void Print(){
	for(int i=1;i<=n;i++) cout<<s[i];
	exit(0);
}
signed main(){
	char ch;
	while(cin>>ch){
		s[++n]=ch;
		if(ch=='#') break;
	} 
	for(int i=n;i>=1;i--) 
		if('0'<=s[i]&&s[i]<='9'&&'0'<=s[i+1]&&s[i+1]<='9')
			num[i]=num[i+1]*10;
		else num[i]=1;
	for(int i=1;i<=n;i++)
		if(s[i]=='+') f1=1;
		else if(s[i]=='-') f1=-1;
		else if(s[i]=='='){
			f1=1;
			f2=-1;
		}else if(s[i]-'#')
			a[++tot]={s[i]-'0',i,f1*f2,num[i]};
	for(int i=1;i<=tot;i++)
		sum+=a[i].flag*a[i].id*a[i].num;
	Init();
	for(int i=1;i<=tot;i++){
		for(int nxt:mp[a[i].num][3])
			if(sum+a[i].flag*a[i].id*(nxt-a[i].num)==0){
				s[a[i].pos]=nxt+'0';
				Print();
			}
		for(int j=1;j<=tot;j++){
			if(i==j) continue;
			for(int nxt1:mp[a[i].num][1])
				for(int nxt2:mp[a[j].num][2])
					if(sum+a[i].flag*a[i].id*(nxt1-a[i].num)+a[j].flag*a[j].id*(nxt2-a[j].num)==0){
						s[a[i].pos]=nxt1+'0';
						s[a[j].pos]=nxt2+'0';
						Print();
					}
		}
	}
	cout<<"No";
	return 0;
}

```

## Part 4 结尾

- $\textcolor{black}{复制}$一时爽。
- $\textcolor{brown}{棕名}$两行泪。

# [AC链接](https://www.luogu.com.cn/record/226844029)

---


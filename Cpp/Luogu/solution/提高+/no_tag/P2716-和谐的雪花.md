# 和谐的雪花

## 题目背景

没有背景


## 题目描述

现在有 $n\times m$ 个雪花，被放在了一个 $n\ \times m$ 的矩阵当中。每个雪花都有一个优美值。一个正方形的和谐度被定义为在这个正方形中雪花的最大优美值和最小优美值的差，和谐度越大这个正方形就越和谐。现在给出这个矩阵和一个非负整数 $k$，zzs 和 zzy 希望你能告诉他，在所有和谐度不小于 $k$ 的正方形中，边长最小的正方形的边长（即找到一个最小的边长 $a$，使得存在一个边长为 $a$ 的正方形它的和谐度不小于 $k$）。如果没有解，输出 $-1$。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$1 \le n,m \le 20$；
- 对于 $100\%$ 的数据，$1 \le n,m \le 500$；
- 对于 $100\%$ 的数据，矩阵中所有数不超过 $100000$。

## 样例 #1

### 输入

```
3 5 7
3 4 2 8 7
6 5 2 4 6
3 1 4 0 9```

### 输出

```
2```

# 题解

## 作者：Laisira (赞：9)

## 提供一种二分加二维线段树的算法。
### 题目大意
给定 $n$，$m$，$k$ 和一个 $n \times m$ 的矩阵。定义一个正方形的优美值为其最大值和最小值的差，要最小化优美值大于 $k$ 正方形边长。

### 思路
在我们增加正方形边长时，会发现矩阵最大的这种正方形的优美值单调递增。于是二分答案，枚举起点，然后用二维线段树统计该种的最大优美值。


### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 501
using namespace std;
int a[Maxn][Maxn];
int maxn[Maxn*4][Maxn*4];
int minv[Maxn*4][Maxn*4];
int Max,Min;
int m,n;
//线段树模板
void pushup1(int x1,int x2) {
    maxn[x1][x2]=max(maxn[x1<<1][x2],maxn[x1<<1|1][x2]);
    minv[x1][x2]=min(minv[x1<<1][x2],minv[x1<<1|1][x2]);
}
void pushup2(int x1,int x2) {
    maxn[x1][x2]=max(maxn[x1][x2<<1],maxn[x1][x2<<1|1]);
    minv[x1][x2]=min(minv[x1][x2<<1],minv[x1][x2<<1|1]);
}
void build2(int x1,int x2,int l,int r,int flag)
{
    if(l == r) {
        if(flag != -1)
        maxn[x1][x2]=minv[x1][x2]=a[flag][l];
        else pushup1(x1,x2);
        return;
    }
    int mid=l+r>>1;
    build2(x1,x2<<1,l,mid,flag);
    build2(x1,x2<<1|1,mid+1,r,flag);
    pushup2(x1,x2);
}

void build1(int x1,int l,int r)
{
    if(l == r) {
        build2(x1,1,1,m,l);
        return;
    }
    int mid=l+r>>1;
    build1(x1<<1,l,mid);
    build1(x1<<1|1,mid+1,r);
    build2(x1,1,1,m,-1);
}
void query2(int x1,int x2,int l,int r,int y1,int y2)
{
    if(l>=y1&&r<=y2) {
        Max=max(Max,maxn[x1][x2]);
        Min=min(Min,minv[x1][x2]);
        return;
    }
    int mid=l+r>>1;
    if(y1<=mid)query2(x1,x2<<1,l,mid,y1,y2);
    if(y2>mid)query2(x1,x2<<1|1,mid+1,r,y1,y2);
}
void query1(int u1,int l,int r,int x1,int x2,int y1,int y2)
{
    if(l>=x1&&r<=x2) {
        query2(u1,1,1,m,y1,y2);
        return;
    }
    int mid=l+r>>1;
    if(x1<=mid)query1(u1<<1,l,mid,x1,x2,y1,y2);
    if(x2>mid)query1(u1<<1|1,mid+1,r,x1,x2,y1,y2);
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    build1(1,1,n);
    //二分答案
    int l=1,r=min(n,m),ans=-1,mid;
    while(l<=r)
    {
        mid=l+r>>1;
        int res=-1;
        for(int i=1;i<=n-mid+1;i++)
            for(int j=1;j<=m-mid+1;j++)
                Max=-INT_MAX,Min=INT_MAX,
                query1(1,1,n,i,i+mid-1,j,j+mid-1),
                res=max(res,Max-Min);
        //枚举正方形，求最大优美值
        if(k<=res)ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：clamee (赞：7)

其实这道题还是很水的

其实和[P2216理想的正方形](https://www.luogu.org/problem/P2216)差不多

今天旁边就有位大佬让我来看下这道题，应该不到5分钟就能想出这个算法。

由“边长最小的正方形的边长”可以很自然地想到二分答案。

那么显然，我们要知道二维的区间最大最小值，而且这个区间是固定的。如果这是在一维区间内，现在就转化为了区间dp的版子题。那么现在，我们要将这个方法拓展到二维。

很显然，这里的方法可以和P2216一模一样：

我们先维护一维的：即用a[i][j]表示第i行，第j个到第j+k-1个的最值（k为本次二分出的答案）然后再套用单调队列拓展到二维。

然后就能很容易地判断了，复杂度为O(nmlog(min(n,m))

代码分割线
------------
```
#include<bits/stdc++.h>
using namespace std;
int a[1005][1005],b[1005][1005],c[1005][1005],n,m,nn,mm,aa[1005][1005],bb[1005][1005],ans=-1,mi;
inline int read()//快读
{
	int ans=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){ans=(ans<<3)+(ans<<1)+ch-48;ch=getchar();}
	return ans*k;
}
deque<int> q;
bool judge(int k)
{
	for(int i=1;i<=n;i++)
	{
		while(!q.empty())q.pop_front();
		for(int j=1;j<=m;j++)
		{
			if(j<k)
			{
				while(!q.empty()&&c[i][q.back()]<c[i][j])
					q.pop_back();
				q.push_back(j);
			}
			else
			{
				while(!q.empty()&&c[i][q.back()]<c[i][j])
					q.pop_back();
				q.push_back(j);
				while(j-q.front()>=k)q.pop_front();
				a[i][j-k+1]=c[i][q.front()];
			}
		}
	}//先维护一维
	mm=m-k+1;
	for(int j=1;j<=mm;j++)
	{
		while(!q.empty())q.pop_front();
		for(int i=1;i<=n;i++)
		{
			if(i<k)
			{
				while(!q.empty()&&a[q.back()][j]<a[i][j])
					q.pop_back();
				q.push_back(i);
			}
			else
			{
				while(!q.empty()&&a[q.back()][j]<a[i][j])
					q.pop_back();
				q.push_back(i);
				while(i-q.front()>=k)q.pop_front();
				b[i-k+1][j]=a[q.front()][j];
			}
		}
	}//拓展到二维 
    //维护最大值
	nn=n-k+1;
	for(int i=1;i<=n;i++)
	{
		while(!q.empty())q.pop_front();
		for(int j=1;j<=m;j++)
		{
			if(j<k)
			{
				while(!q.empty()&&c[i][q.back()]>c[i][j])
					q.pop_back();
				q.push_back(j);
			}
			else
			{
				while(!q.empty()&&c[i][q.back()]>c[i][j])
					q.pop_back();
				q.push_back(j);
				while(j-q.front()>=k)q.pop_front();
				aa[i][j-k+1]=c[i][q.front()];
			}
		}
	}
	for(int j=1;j<=mm;j++)
	{
		while(!q.empty())q.pop_front();
		for(int i=1;i<=n;i++)
		{
			if(i<k)
			{
				while(!q.empty()&&aa[q.back()][j]>aa[i][j])
					q.pop_back();
				q.push_back(i);
			}
			else
			{
				while(!q.empty()&&aa[q.back()][j]>aa[i][j])
					q.pop_back();
				q.push_back(i);
				while(i-q.front()>=k)q.pop_front();
				bb[i-k+1][j]=aa[q.front()][j];
			}
		}
	}//同理维护最小值
	for(int i=1;i<=nn;i++)
		for(int j=1;j<=mm;j++)
			if(b[i][j]-bb[i][j]>=mi)return 1;//判断
	return 0;
}
int main()
{
	n=read();m=read();mi=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			c[i][j]=read();
	int l=1,r=min(n,m);
	while(l<=r)//二分答案
	{
		int mid=(l+r)/2;
		if(judge(mid))
		{
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
    printf("%d",ans);
}
```

---

## 作者：localhost (赞：5)

这是一道很好的动态规划

首先，我们把一个正方形用   它左上角的顶点的坐标+它的边长  表示。

而这时我们可以推出一道公式：

正方形中的最大值：

**f[i][j][k]=max(max(f[i+1][j][k-1],f[i][j+1][k-1]),max(a[i][j],a[i+k][j+k]));**

正方形中的最小值：

**g[i][j][k]=min(min(g[i+1][j][k-1],g[i][j+1][k-1]),min(a[i][j],a[i+k][j+k]));**

i,j表示正方形左上角顶点的坐标，k+1表示它的边长


但是，我们又发现：如果这样的话，数组的空间会爆掉（500\*500\*500\*2/1024/1024=238.5mb）

幸运的是，我们找到了解决的方法：

f[i][j][k]用过一次后，之后的计算就不需要用到了。

所以，我们可以压缩成二维的，空间也就大大减小了。


代码：

```cpp
#include<cstdio> 
#define ll int 
using namespace std;
inline void in(ll &x){x=0;char c;bool f=0;while((c=getchar())>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=getchar())<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;} 
inline void out(ll x){if(x<0){putchar('-');x=-x;}if(x>9)out(x/10);putchar(x%10+48);} 
inline void outn(ll x){out(x);printf("\n");}
inline ll max(ll x,ll y){return x>y?x:y;}
inline ll min(ll x,ll y){return x<y?x:y;}
ll a[501][501],f[501][501],g[501][501],i,k,j,n,m,p;
int main(){
    in(n);in(m);in(p);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){in(a[i][j]);f[i][j]=g[i][j]=a[i][j];}
    for(k=1;k<=min(n,m)-1;k++)
        for(i=1;i<=n-k;i++)
            for(j=1;j<=m-k;j++){
                f[i][j]=max(max(f[i+1][j],f[i][j+1]),max(a[i][j],a[i+k][j+k]));
                g[i][j]=min(min(g[i+1][j],g[i][j+1]),min(a[i][j],a[i+k][j+k]));
                if(f[i][j]-g[i][j]>=p){outn(k+1);return 0;}
            }
    outn(-1);
}

```

---

## 作者：crashed (赞：5)

# 分析：
1. 我们可以发现问题的答案存在单调性。   
  （因为当边长增加时，最大值不会变小，最小值不会变大，所以和谐度不会下降）  
  所以我们可以二分答案。
2. 我们还需要考虑如何检查答案。  
  根据题意，也就是如何搜索区块中的最大值和最小值。  
  这个可以用$RMQ(ST-Table)$在$O(1)$中解决。    
  (二维的$RMQ$)  
  (不知道$RMQ$的[点这里](https://baike.baidu.com/item/rmq/1797559?fr=aladdin))  
  那么我们可以枚举正方形的左上角，然后用$RMQ$得到区间的最大值和最小值
  做差得到和谐度进行检查，时间$O( N\times M )$。  
3. 总的框架：  
  二分搜索答案，运用$RMQ$技术检查。  
  $RMQ$时间$O( N\times M \times log_2(min(N, M)))$  
  二分和检查时间$O( N\times M\times log_2(min(N, M)) )$  
  总时间$O( N\times M\times log_2(min(N,M)) )$  
  ~~过题毫无压力~~
# 代码：
```cpp
#include <cstdio>
#include <cmath>
typedef long long LL;
const int MAXN = 505, MAXM = 505, MAXLOG = 15;
template<typename _T>
void read( _T &x ) {
	x = 0;
	char s = getchar();
	int f = 1;
	while( s > '9' || s < '0' ) {
		if( s == '-' ) f = -1;
		s = getchar();
	}
	while( s >= '0' && s <= '9' ) {
		x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();
	}
	x *= f;
}
template<typename _T>
void write( _T x ) {
	if( x < 0 ) {
		putchar( '-' );
		x = ( ~ x ) + 1;
	}
	if( 9 < x ) {
		write( x / 10 );
	}
	putchar( x % 10 + '0' );
}
template<typename _T>
_T MIN( const _T a, const _T b ) {
	return a < b ? a : b;
}
template<typename _T>
_T MAX( const _T a, const _T b ) {
	return a > b ? a : b;
}
int RMinQ[MAXN][MAXM][MAXLOG], RMaxQ[MAXN][MAXM][MAXLOG];
int N, M, K, lg2;
void init() {
	for( int k = 1 ; k <= lg2 ; k ++ ) {
		for( int i = 1 ; i + ( 1 << ( k - 1 ) ) <= N ; i ++ ) {
			for( int j = 1 ; j + ( 1 << ( k - 1 ) ) <= M ; j ++ ) {
				RMinQ[i][j][k] = MIN( MIN( RMinQ[i][j][k - 1], RMinQ[i][j + ( 1 << ( k - 1 ) )][k - 1] ), MIN( RMinQ[i + ( 1 << ( k - 1 ) )][j][k - 1], RMinQ[i + ( 1 << ( k - 1 ) )][j + ( 1 << ( k - 1 ) )][k - 1] ) );
				RMaxQ[i][j][k] = MAX( MAX( RMaxQ[i][j][k - 1], RMaxQ[i][j + ( 1 << ( k - 1 ) )][k - 1] ), MAX( RMaxQ[i + ( 1 << ( k - 1 ) )][j][k - 1], RMaxQ[i + ( 1 << ( k - 1 ) )][j + ( 1 << ( k - 1 ) )][k - 1] ) );
			}
		}
	}
}
LL query( const int lx, const int ly, const int len, const bool type ) {
	int indx = int( log2( len ) );
	int rx = lx + len - 1, ry = ly + len - 1;
	if( type ) {
		return MAX( MAX( RMaxQ[lx][ly][indx], RMaxQ[rx - ( 1 << indx ) + 1][ly][indx] ), MAX( RMaxQ[lx][ry - ( 1 << indx ) + 1][indx], RMaxQ[rx - ( 1 << indx ) + 1][ry - ( 1 << indx ) + 1][indx] ) );
	} else {
		return MIN( MIN( RMinQ[lx][ly][indx], RMinQ[rx - ( 1 << indx ) + 1][ly][indx] ), MIN( RMinQ[lx][ry - ( 1 << indx ) + 1][indx], RMinQ[rx - ( 1 << indx ) + 1][ry - ( 1 << indx ) + 1][indx] ) );
	}
}
bool check( const int length ) {
	for( int i = 1 ; i <= N - length + 1 ; i ++ ) {
		for( int j = 1 ; j <= M - length + 1 ; j ++ ) {
			if( query( i, j, length, 1 ) - query( i, j, length, 0 ) >= K ) return true;
		}
	}
	return false;
}
int main() {
	int num;
	read( N ), read( M ), read( K );
	lg2 = int( log2( MIN( N, M ) ) );
	for( int i = 1 ; i <= N ; i ++ ) {
		for( int j = 1 ; j <= M ; j ++ ) {
			read( num );
			RMinQ[i][j][0] = RMaxQ[i][j][0] = num;
		}
	}
	init();
	if( N > M ) {
		for( int i = 1 ; i <= N - M + 1 ; i ++ ) {
			if( query( i, 1, M, 1 ) - query( i, 1, M, 0 ) >= K ) {
				goto there;
			}
		}
		puts( "-1" );
		return 0;
	} else {
		for( int i = 1 ; i <= M - N + 1 ; i ++ ) {
			if( query( 1, i, N, 1 ) - query( 1, i, N, 0 ) >= K ) {
				goto there;
			}
		}
		puts( "-1" );
		return 0;
	}
	there:
	int l = 1, r = MIN( N, M ), mid;
	while( r > l ) {
		mid = ( l + r ) >> 1;
		if( check( mid ) ) {
			r = mid;
		} else {
			l = mid + 1;
		}
	}
	write( r ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Caro23333 (赞：5)

之前似乎有人提到过st表......

其实完全不需要将待求的正方形区域拆成若干条啊
直接搞一个二维的st表就OK了

大约就是$st[i][j][k]$表示以$(i,j)$为左上角的边长为$2^{k}$的正方形区域的最值

预处理和查询类似一维st表
在求答案时，枚举正方形的左上角位置，然后二分这个长度，并且查询区域的极差是否满足要求

容易证明正方形区域的极差在左上角固定时随着正方形边长扩大单调不降，故二分答案可行

时间复杂度$O(nmlogn)$，可以通过此题

代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cmath>

using namespace std;
const int MAXN = 505;
int n,m,k,a[MAXN][MAXN],st[MAXN][MAXN][11][3];
inline int min4(int a, int b, int c, int d)
{
    return min(min(a,b),min(c,d)); 
}
inline int max4(int a, int b, int c, int d)
{
    return max(max(a,b),max(c,d));
}
inline int query(int i, int j, int len, int t)
{
    int k = log2(len), res;
    if(t==1)
        res = min4(st[i][j][k][1],st[i+len-(1<<k)][j][k][1],
                   st[i][j+len-(1<<k)][k][1],st[i+len-(1<<k)][j+len-(1<<k)][k][1]);
    else if(t==2)
        res = max4(st[i][j][k][2],st[i+len-(1<<k)][j][k][2],
                   st[i][j+len-(1<<k)][k][2],st[i+len-(1<<k)][j+len-(1<<k)][k][2]);
    return res;
}
inline bool check(int i, int j, int x)
{
    if(query(i,j,x,2)-query(i,j,x,1)>=k) return true;
    else return false;
}
int main()
{
    cin >> n >> m >> k;
	for(int i = 1; i<=n; i++)
	    for(int j = 1; j<=m; j++)
		    scanf("%d",&a[i][j]);	
    for(int i = 1; i<=n; i++)
        for(int j = 1; j<=m; j++)
            st[i][j][0][1] = st[i][j][0][2] = a[i][j];
    for(int p = 1; p<=10; p++)
        for(int i = 1; i<=n-(1<<p)+1; i++)
            for(int j = 1; j<=m-(1<<p)+1; j++)
            {
                st[i][j][p][1] = min4(st[i][j][p-1][1],st[i+(1<<(p-1))][j][p-1][1],
				                      st[i][j+(1<<(p-1))][p-1][1],st[i+(1<<(p-1))][j+(1<<(p-1))][p-1][1]);
				st[i][j][p][2] = max4(st[i][j][p-1][2],st[i+(1<<(p-1))][j][p-1][2],
				                      st[i][j+(1<<(p-1))][p-1][2],st[i+(1<<(p-1))][j+(1<<(p-1))][p-1][2]);
			}
	int ans = 1<<30;
	for(int i = 1; i<=n; i++)
	    for(int j = 1; j<=m; j++)
	    {
	        int left = 1, right = min(n-i+1,m-j+1), res = 0, mid;
	        while(left<=right)
	        {
	            mid = (left+right)>>1;
	            if(check(i,j,mid)) res = mid, right = mid-1;
	            else left = mid+1;
			}
			if(res) ans = min(ans,res);
		}
	if(ans==(1<<30)) cout << -1 << endl;
	else cout << ans << endl;
	return 0;
} 
```

---

## 作者：AC_Evil (赞：4)

看了楼下的几个题解，好像都用的是动归，我提供个非动归的思想，效率可以达到O(nm*logn)，测试点总共用时600ms(未开O2）。

在阐述题解之前，先普及个知识：滑动窗口算法。

作用：若有一个序列A1, A2, ... , An，其中存在着若干个长度为k的子序列（连续的k个元素），事实上存在着n-k+1个子序列。我们想求这些子序列之中的最大（小）值，可以采取滑动窗口算法，复杂度为O(n)。

思想：假设存在一个序列A={3, 2, 4, 6, 5, 9, 8, 1}，k=3时，B[i]记录A[i-k+1]到A[i]的最大值（先谈一个）。这个问题可以看成：有一个长度为k的队列，每次弹出一个数，进入一个数，并维护这个队列的最大值。怎么维护呢？在A序列中，3在2的左边。这意味着，2在3离开队列前，一直会被3“压迫”着，不会成为队列的最大值，只有在3出队时才有可能成为最大值。之后，4入队。此时无论如何，前面的3永远不会成为最大值了（包括2），换句话说，此时3和2是无用的，可以删除。当删除无用元素后，此时，滑动窗口中的有用元素是递减的。我们把这些有用的元素看成一个队列（事实上，可以用一个队列Q单独保存其有用元素对应的下标。这个队列对应的元素是单调队列）。每次维护，分成3个步骤：

	1.如果Q队列非空（只会出现第一次未入队）且Q队头下标已经不在子序列的区间中，出队；

	2.如果Q队列非空时，进队元素大于Q队列尾部的元素，弹出Q尾部的元素下标，重复2；（弹出元素永远不能成为最大值，所以弹出）

	3.将该元素放入Q队尾部。（此时可以保证有用元素递减）

Q队头对应的元素即为当前子序列的最大值。

附上一段程序辅助理解（已知量在上面已阐述）。
```
Q_head = Q_tail = 0; // 队列自己写的，当Q_head < Q_tail时队列非空
for (int i = 1; i <= n; i++) {
	if (Q_head < Q_tail && Q[Q_head] == i - k) Q_head++; // 步骤1
	while (Q_head < Q_tail && A[i] > A[Q[Q_tail]]) Q_tail--; // 步骤2
	Q[Q_tail++] = i; // 步骤3
	B[i] = A[Q[Q_head]]; // 最大值
}
```
最小值请根据自己的理解自行完成。

这道题又有求最小值，可以采取二分的策略解决此题：确定答案区间、二分折中一个答案、判断答案是否成立、调整区间。

对于判断答案，这题最主要的是要求一个正方形区域的最大值和最小值，如果相减的值>=k，则答案成立。对于求正方形区域的最值，可将平面转化成线性的方式降维处理：将一个ans*ans的正方形拆成ans条线性数组，一趟滑动窗口算法求出每行中所有长度为ans序列的最大/小值，存到一个数组中，再将这个数组纵向处理一趟滑动窗口，此时原本的正方形已经处理成了线性数组，每个ans长的区间的最大/小值即对应了原本的正方形的最值，每次判断答案是否正确。下面将展示伪代码来解释主要内容。
```
bool check(int size)
	for x = 1 -> n
		Queue1_init(); Queue2_init();
		for i = 1 -> m
			window_put_1(arr[x][i]); // window_put包括了上述3个步骤，后面的_1区分操作队列1（还有队列2），arr指输入数据的矩阵。
			Max[x][i] = arr[Queue1.front()];
			window_put_2(arr[x][i]) // 具体实现和window_put_1不太一样，求的是最大值。这个是求最小值
			Min[x][i] = arr[Queue2.front()];
	
	for x = size -> m // arr的有效位置是从size开始
		Queue1_init(); Queue2_init();
		for i = 1 -> n
			window_put_1(Max[i][x]); // 注意参数
			window_put_2(Min[i][x]); // 同上
			if (Max[Queue1.front()] - Min[Queue2.front()] >= k) return true; // 判断出答案正确，即存在一个size*size的区间的最大值和最小值之差大于题目中的k

	return false; // 未找到答案，失败
```

判断矩阵为O(m * n)，二分为O(logn)（保证n<m），总复杂度O(mnlogn)

本题思路讲到这里。剩下的实现靠你们了！

---

## 作者：qiliu (赞：3)

~~我从来没有切蓝切这么快过(一个小时)~~

------------
建议大家先做一下[理想的正方形](https://www.luogu.com.cn/problem/P2216)这一道题，几乎是双倍经验。

## 思路 
首先观察到题面要求一个矩阵中的最大值和最小值，于是考虑单调队列。

这时候发现，这一道题和的一个区别，就是在
[P2216](https://www.luogu.com.cn/problem/P2216)中矩阵大小已经规定好了，但本题正是要求你求这个大小。

于是我们考虑一个二分。

#### 1.证明二分可行

二分的一个重要条件就是**单调性**，然而这道题中单调性确实存在。我们假设一个边长为 $ a_1 $ 的矩阵（此处以 $ 3 $ 为例），其中的最大优美值（即 $ max_1 $）和最小优美值（即 $ min_1 $）位置如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/776t8ui3.png)

此时我们将他拓展成一个边长为 $ a_2 $ 的矩阵（此处以 $ 4 $ 为例），拓展区域中的最大优美值（即 $ max_2 $）和最小优美值（即 $ min_2 $）情况如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/rfl4by4c.png)


于是我们假设新矩阵的最大优美值为 $ max_3 $ 最小优美值为 $min_3$。

结合上图，不难发现无论我们怎么拓展，只可能有：

1. $ max_3 \geq max_1 $。

2. $ min_3 \leq min_1 $。

于是有新矩阵和谐度 $ k_3 $ 与原矩阵和谐度 $ k_1 $（下标的跳跃是为了方便理解）的关系：

- $ k_3 \geq k_1 $

#### 2.单调队列过程

刷到这道题的朋友们应该会单调队列，不会的话出门左转来[这里](https://www.luogu.com.cn/problem/P1886)

这里就和[P2216](https://www.luogu.com.cn/problem/P2216)很像了。

我们假设现在我们二分到的矩阵边长为 $ a $ 我们可以先对于每一个组长度为 $ a $ 的列进行单调队列操作，得到每一组长为 $ a $ 的列的最大最小值。

然后我们再对于上面处理好的这些数据做相同的处理，就可以得到每一个边长为 $ a $ 的矩阵的最大最小值。

#### 3.复杂度分析

这里我就讲的简略一些。单调队列的时间复杂度为 $ O(n) $ 二分的时间复杂度为 $ O( \log n ) $ 的。于是我们的程序复杂度显然是 $ O( nm\log n ) $，显然是合法的。

### Code

变量命名都有注释，请放心食用。

```cpp
#include<bits/stdc++.h>
#define int long long
#define DEBUG(x) cerr<<#x<<'='<<x<<endl
using namespace std;
const int N=505;
int n,m,K;//K即为题目中的k 
int mp[N][N];//即题目中给的n*m的优美值 
int X[N][N],x[N][N];//分别为每行的最大最小值 
int Y[N][N],y[N][N];//分别为每列的最大最小值 
bool solve(int k)//此处的k是当前二分到的边长 
{
	memset(X,0,sizeof(X));
	memset(Y,0,sizeof(Y));
	memset(x,0,sizeof(x));
	memset(y,0,sizeof(y));
	for(int i=1;i<=n;i++)
	{
		deque<int>Q;
		deque<int>q;
		for(int j=1;j<=m;j++)
		{
			if(!Q.empty()&&j-Q.front()>=k)
				Q.pop_front();
			while(!Q.empty()&&mp[i][Q.back()]<=mp[i][j])
				Q.pop_back();
			Q.push_back(j);
			if(j-k+1>0)
			X[i][j-k+1]=mp[i][Q.front()];
			/*------我是maxmin分割线------*/ 
			if(!q.empty()&&j-q.front()>=k)
				q.pop_front();
			while(!q.empty()&&mp[i][q.back()]>=mp[i][j])
				q.pop_back();
			q.push_back(j);
			if(j-k+1>0)
			x[i][j-k+1]=mp[i][q.front()];
		}
	}
	for(int i=1;i<=m-k+1;i++)
	{
		deque<int>Q;
		deque<int>q;
		for(int j=1;j<=n;j++)
		{
			if(!Q.empty()&&j-Q.front()>=k)
				Q.pop_front();
			while(!Q.empty()&&X[Q.back()][i]<=X[j][i])
				Q.pop_back();
			Q.push_back(j);
			if(j-k+1>0)
			Y[j-k+1][i]=X[Q.front()][i]; 
			/*------我是maxmin分割线------ */ 
			if(!q.empty()&&j-q.front()>=k)
				q.pop_front();
			while(!q.empty()&&x[q.back()][i]>=x[j][i])
				q.pop_back();
			q.push_back(j);
			if(j-k+1>0)
			y[j-k+1][i]=x[q.front()][i]; 
		}
	}
	int value=0;
	for(int i=1;i<=n-k+1;i++)
	{
		for(int j=1;j<=m-k+1;j++)
		{
			value=max(value,Y[i][j]-y[i][j]);
		}
	}
	if(value<K)return 0;
	return 1;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n>>m>>K;
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=m;j++)
		{
			cin>>mp[i][j];
		}
	}
	int l=1,r=min(n,m);
	int mid;
	bool flag=0;//记录的是是否有解 
	int ans=-1; 
	while(l<=r)
	{
		mid=(l+r)>>1;	
		if(solve(mid)==1)
		{
			ans=mid;
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	cout<<ans;
    //fclose(stdin);
    //fclose(stdout);
	return 0;
}

```
这就是全部啦~  感谢每一位阅读本题解的朋友~

---

## 作者：World_Creater (赞：2)

二维 $\verb!RMQ!$ 模板题。

首先我们先解决这个问题：如何处理一个子矩形的最大/最小值？

我们可以求出这个子矩形每行的最大/最小值，在对这些我们算出的最大/最小值做一遍最值。

这样这样我们就把问题拍成了两次 $\verb!RMQ!$ 问题：对行（内层） $\verb!RMQ!$，在把内层的结果 $\verb!RMQ!$（外层）。

----

接下来我们来解决本题。

观察到一个性质，即答案关于正方形面积的大小是单调不降的。

显然，当正方形面积变大时，最大值会变大，最小值会变小，这样作差的结果也会变大。

于此，我们考虑对正方形的边长进行二分，而二分判定的过程，正是上方的二维 $\verb!RMQ!$。

由于我们可能会多次询问同行中不同长度的最值，但是当我们确定了正方形的边长后，外层 $\verb!RMQ!$ 的区间大小是固定的，因此我在内层使用了 $\verb!ST!$ 表，在外层使用了单调队列，复杂度 $O(nm\log m)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int stmax[505][505][20],stmin[505][505][20],n,m,K,a[505][505],lg[505],q1[505],q2[505];
void init(int l)
{
	for(int i=1;(1<<i)<=m;i++)
		for(int j=1;j<=m;j++)
		{
			stmin[l][j][i]=min(stmin[l][j][i-1],stmin[l][j+(1<<i-1)][i-1]);
			stmax[l][j][i]=max(stmax[l][j][i-1],stmax[l][j+(1<<i-1)][i-1]);
		}
}
int querymax(int x,int l,int r)
{
	int k=lg[r-l+1];
	return max(stmax[x][l][k],stmax[x][r-(1<<k)+1][k]);
}
int querymin(int x,int l,int r)
{
	int k=lg[r-l+1];
	return min(stmin[x][l][k],stmin[x][r-(1<<k)+1][k]);
}
//以上st表部分
bool check(int k)
{
	int res=0;
	//cout<<"When size is"<<k<<":\n";
	int lis1[505]={},lis2[505]={};
	for(int i=k;i<=m;i++)
	{
		int h1=1,t1=0,h2=1,t2=0;
		for(int j=1;j<=n;j++)
		{
			lis1[j]=querymin(j,max(i-k,0)+1,i);
			lis2[j]=querymax(j,max(i-k,0)+1,i);
		}
		for(int j=1;j<=n;j++)
		{
			q1[++t1]=j;
			q2[++t2]=j;
			//cout<<lis1[j]<<" "<<lis2[j]<<" \n";
			while(t1>h1&&lis1[q1[t1]]<lis1[q1[t1-1]])
			{
				q1[t1-1]=q1[t1];
				t1--;
			}
			while(t2>h2&&lis2[q2[t2]]>lis2[q2[t2-1]])
			{
				q2[t2-1]=q2[t2];
				t2--;
			}
			while(q1[h1]<=j-k) h1++;
			while(q2[h2]<=j-k) h2++;
			//cout<<lis2[q2[h2]]<<"->"<<lis1[q1[h1]]<<"\n";
			if(j>=k) res=max(res,lis2[q2[h2]]-lis1[q1[h1]]);
		}
		//puts("...");
	}
	//cout<<res<<"\n";
	return res>=K;
}
//以上使用单调队列进行判断。
int main()
{
	cin>>n>>m>>K;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j],stmin[i][j][0]=stmax[i][j][0]=a[i][j];
	for(int i=2;i<=n;i++)
		lg[i]=lg[i-1]+!(i&(i-1));
	for(int i=1;i<=n;i++)
	{
		init(i);
	}
	int l=1,r=min(n,m)+1;
	while(l<r)
	{
		int mid=l+r>>1;
		if(check(mid))
			r=mid;
		else l=mid+1;//二分过程。
	}
	if(l==min(n,m)+1)
	{
		puts("-1");
	}
	else cout<<l;
}
```

---


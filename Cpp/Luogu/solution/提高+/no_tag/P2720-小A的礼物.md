# 小A的礼物

## 题目背景

** 数据已更新（2018-3-2） **

## 题目描述

小 A 去学校参加活动辣，学校会发礼物哦，学校有很多礼物点。

每一个礼物点都有去别的礼物点的道路和各种种类的礼物。

为了防止多次领礼物，这些道路都是单向的道路，并且没有环。

而且对于每条边连接 $a$，$b$ 点，如果删去这条边之后，存在点 $c$ 可以到达 $a$，也能到达 $b$，那么这条边就不会存在于路径中。

并且除了点 $1$ 之外，所有点有且只有一条入边。

小 A 想知道，对于点 $S$ 能到达的所有点（包括本身），有多少种不同的礼物？

## 说明/提示

### 样例解释
点 $1$ 可以到达点 $(1, 2, 3, 4)$，有三种礼物 $(1,2,3)$。

点 $2$ 可以到达点 $2, 3, 4$，有两种礼物 $2, 3$。

### 数据范围


|测试点编号|$n$|$m$|$c_i$（颜色）|
|:-:|:-:|:-:|:-:|
|$1$|$\le 10^2$|$\le 10^2$|$\le 10^2$|
|$2\sim3$|$\le 10^3$|$\le 10^3$|$\le 10^3$|
|$4\sim5$|$\le 10^4$|$\le 10^4$|$\le 20$|
|$6$|$\le5\times 10^4$|$\le5\times 10^4$|$\le5\times 10^4$|
|$7\sim8$|$\le 10^5$|$\le5\times 10^4$|$\le6\times 10^4$|

## 样例 #1

### 输入

```
4
1 2 2
1 2 3 3
2
1
2```

### 输出

```
3
2```

# 题解

## 作者：xxseven (赞：2)

子树数颜色问题居然没有树上启发式合并的题解？

首先观察题面，$2$ 到 $n$ 的每一个点都有唯一的入边，保证点 $1$ 能到达任意点，这不就是一棵只能往下走的树嘛。

那么，一个点能走到的位置也就是它子树内的所有节点了。也就是说，对于每一次询问的节点，我们要求出它子树内的不同礼物种类。

对于这个问题我们有一个很优秀的解法：树上启发式合并。

顾名思义，这种方法运用了启发式的思想。首先我们有朴素算法：对于每个节点，**暴力统计**出子树内的所有信息。

这个时候，有人开始发扬人类智慧，想到：之前的做法每次都要清空统计的数组，但是我们可以**保留其中一个子树的信息**，这样就可以少统计一部分了。那么保留哪个子树呢？显然是要保留大小最大的了，也就是重链剖分里的重儿子。

可以证明，按照这样的方式，每个节点被**重复统计**的次数等于它到根的轻边个数，而这个数是 $O(\log n)$ 级别的，因此总时间复杂度即为 $O(n \log n)$。

代码非常好写，因为这其实就是一个暴力。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6;
int n,m,ans[N],buck[N],cnt,a[N];
vector<int> f[N];
int fa[N],dep[N],son[N],siz[N];
void dfs(int x,int y){
	dep[x]=dep[y]+1; siz[x]=1;
	for(int u:f[x]){
		if(u==y) continue;
		dfs(u,x); siz[x]+=siz[u];
		if(siz[u]>siz[son[x]]) son[x]=u;
	}
}
void calc(int x,int son,int sgn){ //暴力递归统计子树
	if(!buck[a[x]]) cnt++;
	buck[a[x]]+=sgn;
	if(!buck[a[x]]) cnt--;
	for(int u:f[x]){
		if(u==son||u==fa[x]) continue;
		calc(u,son,sgn);
	}
}
void dfs2(int x,int flag){//flag表示该节点是否是重儿子，即是否要清空
	for(int u:f[x]){
		if(u!=fa[x]&&u!=son[x]) dfs2(u,0);
	}
	if(son[x]) dfs2(son[x],1);
	calc(x,son[x],1);
	ans[x]=cnt;//对于每个节点存下答案
	if(flag) return;//如果是重儿子，则跳过清空步骤
	calc(x,-1,-1);
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;++i){
		cin>>fa[i];
		f[i].push_back(fa[i]);
		f[fa[i]].push_back(i);
	}
	for(int i=1;i<=n;++i) cin>>a[i];
	dfs(1,0); dfs2(1,1);
	cin>>m;
	for(int x,i=1;i<=m;++i){
		cin>>x; cout<<ans[x]<<'\n';
	}
	return 0;
}
```

希望这篇题解能够帮到你！

---

## 作者：nosta (赞：2)

考虑用权值线段树来维护每个点子树内的所有颜色，然后因为此题不带修，直接上树上线段树合并就好了，复杂度是十分正确的$O(n\log n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct sgnd{int ls,rs,sum;};

sgnd t[N*20];
int rt[N],st[N],top,cnt;

int nnd() {return top?st[top--]:++cnt;}
void dnd(int&x) {memset(&t[x],0,sizeof t[x]);st[++top]=x;x=0;}
void ist(int&x,int l,int r,int p) {
	if(!x) x=nnd();
	if(l==r) {t[x].sum=1;return;}
	int mid=(l+r)>>1;
	if(p<=mid) ist(t[x].ls,l,mid,p);
	else ist(t[x].rs,mid+1,r,p);
	t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;
}
void mge(int&x,int&y,int l,int r) {
	if(!y) return;
	if(!x) {x=y;y=0;return;}
	if(l==r) t[x].sum|=t[y].sum;
	else {
		int mid=(l+r)>>1;
		mge(t[x].ls,t[y].ls,l,mid);
		mge(t[x].rs,t[y].rs,mid+1,r);
		t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;
	}
	dnd(y);
}

int n,m,c;
int val[N],fa[N],knd[N];
list<int> ch[N];

void dfs(int x) {
	for(int y:ch[x]) dfs(y);
	ist(rt[x],1,c,val[x]);
	knd[x]=t[rt[x]].sum;
	if(x!=1) mge(rt[fa[x]],rt[x],1,c);
}

int main() {
	scanf("%d",&n);
	for(int i=2; i<=n; ++i) {
		scanf("%d",&fa[i]);
		ch[fa[i]].push_back(i);
	}
	for(int i=1; i<=n; ++i) {
		scanf("%d",&val[i]);
		c=max(c,val[i]);
	}
	dfs(1);
	scanf("%d",&m);
	for(int x; m--; ) {
		scanf("%d",&x);
		printf("%d\n",knd[x]);
	}
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：2)

各位都会莫队，我不会，于是我就交了个树套树

首先分析图的性质：

1.为了防止多次领礼物，这些道路都是单向的道路，并且没有环  

分析：**DAG**

2.而且对于每条边联接a，b点，如果删去这条边之后，存在点c可以到达a，也能到达b，那么这条边就不会存在于路径中 

分析：也就是说不会存在类似这种东西，不能有中间的黑边![luogu](https://cdn.luogu.com.cn/upload/pic/52968.png)

3.并且除了点1之外，所有点有且只有一条入边&保证1号点可到达所有点

分析：显然就长得像个以1位根节点的树

于是我们就可以用dfs序转化为连续区间 然后跑[P1903 [国家集训队]数颜色 / 维护队列 ](https://www.luogu.org/problemnew/show/P1903)

[我的树套树详解](https://www.luogu.org/blog/van/solution-p1903)

于是我就写了个线段树套Splay
```cpp
#include<cstdio>
#include<algorithm>
using std::max;
using std::min;
template<class type>inline const void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
const int N=1e5+10,C=6e4+10;
int n,q,last[N],tmp[N],tot,col[N];
int head[N],cnt,to[N],next[N];
inline const void addedge(int u,int v)
{
    next[++cnt]=head[u];
    to[head[u]=cnt]=v;
}
int ranking,l[N],r[N],org[N];
inline const void renumber(int p) //重新编号，我是叶节点l=r=dfs序，非叶节点l=min{l[son]},r=max{r[son]}，也可以所有的点都处理dfn和size，然后区间就是[dfn[x],dfn[x]+size[x]-1]
{
    l[p]=n;r[p]=1;
    for (int i=head[p];i;i=next[i])
        renumber(to[i]),
        l[p]=min(l[to[i]],l[p]),
        r[p]=max(r[to[i]],r[p]);
    ranking++;
    if (!head[p])l[p]=r[p]=ranking;
    else l[p]=min(l[p],ranking),r[p]=max(r[p],ranking);
    org[ranking]=p;
}
namespace Splay
{
    struct tree
    {
        int val,cnt,size;
        tree *fa,*son[2];
        inline const void pushup()
        {
            size=son[0]->size+cnt+son[1]->size;
        }
        inline const bool identity()
        {
            return fa->son[1]==this;
        }
    }memory_pool[N<<6],*recycle[N<<6],*tail,*null,*root[C];
    int top;
    inline const void init()
    {
        tail=memory_pool;
        null=tail++;
        null->val=null->cnt=null->size=top=0;
        null->fa=null->son[0]=null->son[1]=null;
        std::fill(root+1,root+C,null);
    }
    inline tree *spawn(int key)
    {
        tree *p=top?recycle[--top]:tail++;
        p->val=key;
        p->size=p->cnt=1;
        p->fa=p->son[0]=p->son[1]=null;
        return p;
    }
    inline const void erase(tree *&p)
    {
        recycle[top++]=p;
        p=null;
    }
    inline const void connect(tree *p,tree *fa,bool which)
    {
        if (p!=null)p->fa=fa;
        if (fa!=null)fa->son[which]=p,fa->pushup();
    }
    inline const void rotate(tree *p)
    {
        tree *fa=p->fa;
        bool id=p->identity();
        connect(p,fa->fa,fa->identity());
        connect(p->son[id^1],fa,id);
        connect(fa,p,id^1);
    }
    inline const void splay(tree *&root,tree *p)
    {
        for (tree *fa;(fa=p->fa)!=null;rotate(p))
            if (fa->fa!=null)
                rotate(p->identity()^fa->identity()?fa:p);
        root=p;
    }
    inline const void insert(tree *&root,int key)
    {
        if (root==null)return (void)(root=spawn(key));
        tree *now=root;
        while (1)
        {
            if (now->val==key)
                return now->cnt++,now->pushup(),splay(root,now);
            tree *fa=now;
            bool nxt=fa->val<key;
            now=fa->son[nxt];
            if (now==null)
                return now=spawn(key),connect(now,fa,nxt),splay(root,now);
        }
    }
    inline const void find(tree *&root,int key)
    {
        tree *now=root;
        if (now==null)return;
        while (now->son[now->val<key]!=null&&now->val!=key)
            now=now->son[now->val<key];
        splay(root,now);
    }
    inline tree *precursor(tree *&root,int key)
    {
        find(root,key);
        if (root->val<key)return root;
        tree *now=root->son[0];
        while (now->son[1]!=null)now=now->son[1];
        return now;
    }
    inline tree *successor(tree *&root,int key)
    {
        find(root,key);
        if (root->val>key)return root;
        tree *now=root->son[1];
        while (now->son[0]!=null)now=now->son[0];
        return now;
    }
    inline const void Delete(tree *&root,int key)
    {
        find(root,key);tree *p=root;
        if (p->cnt>1)return p->cnt--,p->pushup();
        if (p->son[0]==null&&p->son[1]==null)return root=null,erase(p);
        if (p->son[0]==null)return (root=p->son[1])->fa=null,erase(p);
        if (p->son[1]==null)return (root=p->son[0])->fa=null,erase(p);
        tree *pre=precursor(root,key);splay(root,pre);connect(p->son[1],pre,1);erase(p);
    }
    inline const int less(tree *&root,int key)
    {
        tree *now=root;int tot=0;
        while (now!=null)
            if (key<now->val)now=now->son[0];
            else
            {
                tot+=now->son[0]->size;
                if (now->val==key)return tot;
                tot+=now->cnt;
                now=now->son[1];
            }
        return tot;
    }
}using namespace Splay;
class Segment_Tree
{
    private:
        struct tree
        {
            Splay::tree *root;
            tree *lson,*rson;
            inline const void update(int l,int r,int pos,int key)
            {
                Delete(root,last[pos]);
                insert(root,key);
                if (l==r)return;
                int mid=l+r>>1;
                if (pos<=mid)lson->update(l,mid,pos,key);
                else rson->update(mid+1,r,pos,key);
            }
            inline const int query(int l,int r,int L,int R)
            {
                if (l>R||r<L)return 0;
                if (l>=L&&r<=R)return less(root,L);
                int mid=l+r>>1;
                return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);
            }
        }memory_pool[N<<2],*tail;
        inline const void init()
        {
            tail=memory_pool;
        }
        inline tree *spawn()
        {
            tree *p=tail++;
            p->root=null;
            p->lson=p->rson=NULL;
            return p;
        }
    public:
        tree *root;
        inline Segment_Tree(){init();}
        inline const void build(tree *&p,int l,int r)
        {
            p=spawn();
            for (int i=l;i<=r;i++)
                insert(p->root,last[i]);
            if (l==r)return;
            int mid=l+r>>1;
            build(p->lson,l,mid);
            build(p->rson,mid+1,r);
        }
}sgt;
int main()
{
    read(n);int x;
    for (int i=2;i<=n;i++)read(x),addedge(x,i);
    for (int i=1;i<=n;i++)read(col[i]);
    renumber(1);init();
    for (int i=1;i<=n;i++)
        x=col[org[i]],
        last[i]=tmp[x],
        insert(root[x],tmp[x]=i);
    sgt.build(sgt.root,1,n);
    read(q);
    while (q--)
        read(x),printf("%d\n",sgt.root->query(1,n,l[x],r[x]));
    return 0;
}
```

---

## 作者：whx2009 (赞：1)

## 前言：
题解中竟然没有离线下来做扫描线的，过来交一发。

~~这样写代码极短（没加超级快读的情况下）且常数优秀，目前 [最优解](https://www.luogu.com.cn/record/218904001)……~~

## 本题思路：
题目中说了一张图的一大堆限制条件，总结下来其实就是一棵以一为根节点的树，只能从上往下走就是处理查询节点的子树问题。

转化题面后这道题就是要求我们求出一个节点的子树中有多少个不同的颜色。各路大神在这里可能就直接上各种合并操作了，但是我们可以发现这道题没有强制在线！那么我们就可以把一棵树按照 dfs 序变成一个数列，然后查询一个节点的子树就变成了查询当前点的 dfs 序一直到当前点的 dfs 序加上子树大小减一这一段区间的不同颜色数。我们可以根据 [HH的项链](https://www.luogu.com.cn/problem/P1972) 的思路做一遍扫描线，每个颜色都在最后出现的位置打上一的贡献，答案就是查询一段区间内一的个数，直接树状数组维护即可。

## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int siz[100005],tr[100005],n,dfn[100005],cnt,c[100005];
int b[100005];
vector<int>s[100005];
void dfs(int p,int fa){
	cnt++;dfn[p]=cnt;siz[p]=1;b[cnt]=c[p];
	for(int i=0;i<s[p].size();i++){
		int y=s[p][i];dfs(y,p);siz[p]+=siz[y];
	}
}
int suan(int p){return p&(-p);}
void add(int p,int k){for(int i=p;i<=n;i+=suan(i)) tr[i]+=k;}
int cha(int p){int ans=0;for(int i=p;i;i-=suan(i)) ans+=tr[i];return ans;}
int la[100005],ans[100005];
struct f{int l,r,id;}a[100005];
bool cmp(f x,f y){return x.r<y.r;}
signed main(){
	cin>>n;
	for(int i=2;i<=n;i++){int x;cin>>x;s[x].push_back(i);}
	for(int i=1;i<=n;i++) cin>>c[i];
	dfs(1,0);
	int m;cin>>m;
	for(int i=1;i<=m;i++){int x;cin>>x;a[i].l=dfn[x],a[i].r=dfn[x]+siz[x]-1;a[i].id=i;}
	sort(a+1,a+1+m,cmp);
	int l=1;
	for(int i=1;i<=n;i++){
		if(la[b[i]]) add(la[b[i]],-1);
		add(i,1),la[b[i]]=i;
		while(a[l].r==i){
			ans[a[l].id]=cha(i)-cha(a[l].l-1);
			l++;
		}
		if(l>m) break;
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Great_Influence (赞：1)

跟大家说一个事，之前的std是错的，作者dfs的时候忘记给数组重标号了......

就简单说吧。本题做法很多，可以dfs后转为区间题，然后就是区间处理了。（std就是这么打的，用莫队）

但是发现n只有1e5，貌似$\frac{nc}{\omega}$也可以过。然后就真的能过。。。。。。直接dfs时用bitset维护就可以了。

代码：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("input8.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
vector<bitset<60011> >G;
bitset<60011> emp;
const int MAXN=100101;
static struct edge
{
    int v,next;
}p[MAXN];
static int head[MAXN],e,ans[MAXN],w[MAXN],sz=-1,n,m,b[MAXN],tt;
inline void add(int u,int v){p[++e].v=v;p[e].next=head[u];head[u]=e;}
bool flag;
void dfs(int u)
{
    G.push_back(emp);G[++sz].set(w[u]);
    for(register int v=head[u];v;v=p[v].next)
        dfs(p[v].v);
    ans[u]=G[sz].count();
    if(sz)G[sz-1]|=G[sz];--sz;G.pop_back();
}
#define Find(x) (lower_bound(b+1,b+tt+1,x)-b);
void init()
{
    read(n);
    static int f;
    Rep(i,2,n)read(f),add(f,i);
    Rep(i,1,n)read(w[i]),b[i]=w[i];
    sort(b+1,b+n+1);tt=unique(b+1,b+n+1)-b-1;
    //Rep(i,1,n)w[i]=Find(w[i])-1;
    dfs(1);
}
void solve()
{
    read(m);
    static int x;
    Rep(i,1,m)
    {
        read(x);printf("%d\n",ans[x]);
    }
}
int main(void){
    file();
    init();
    solve();
    return 0;
}

```

再附上罪恶的std。(已修改)

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
vector<int> E[100005];
struct question
{
    int l,r;
    int s;
}ques[N];
struct orz
{
    int l,r;
}sec[N];
int size;
bool cmp(question a , question b)
{
    int x = (a.l-1)/size,y = (b.l-1)/size;
    if(x != y) return x < y;
    return a.r < b.r;
}
int n;
int a[N],w[N];
long long ans[N];
long long last[N];
long long lastsum;
inline void asks(int lastl,int lastr,int left,int right,int k)
{
 //   printf("%d %d %d %d %d\n",lastl,lastr,left,right,k);
    if(lastr < right)
        for(int i = lastr + 1;i <= right;i++)
        {
            if(last[a[i]] == 0) lastsum++;
            last[a[i]]++;
        }
    else if(lastr > right)
        for(int i = right + 1;i <= lastr;i++)
        {
            last[a[i]]--;
            if(last[a[i]] == 0) lastsum--;
        }
   // printf("lastsum = %d\n",lastsum);
    if(lastl < left)
        for(int i = lastl;i <= left - 1;i++)
        {
            last[a[i]]--;
            if(last[a[i]] == 0) lastsum--;
        }
    else if(lastl > left)
        for(int i = left;i <= lastl - 1;i++)
        {
            if(last[a[i]] == 0) lastsum++;
            last[a[i]]++;
        }
    int cnt=0;
    // printf("lastsum = %d\n",lastsum);
    ans[k]= lastsum;
    return;
}
inline void add(int u,int v)
{
    E[u].push_back(v);
}
int dfst = 0;
bool flag;
void dfs(int u)
{
    dfst++;a[dfst]=w[u];
    sec[u].l = dfst;
    for(int i = 0;i < E[u].size();i++)
        dfs(E[u][i]);
    sec[u].r = dfst;
    return;
}
int main()
{
    int q;
    freopen("input1.in","r",stdin);
    freopen("output1.out","w",stdout);
    memset(last,0,sizeof(last));
    scanf("%d",&n);
    for(int i = 2;i <= n;i++)
    {
        int s;
        scanf("%d",&s);
        add(s,i);
    }
    int l,r;
    size = (int)sqrt(n)+1;
    for(int i = 1;i <= n;i++)
    {
        scanf("%d",&w[i]);//原来直接输入a[i]，然后就没有重标号，就凉了
    }
    dfs(1);
    scanf("%d",&q);
    for(int i = 0;i < q;i++)
    {
        int p;
        scanf("%d",&p);
        ques[i].l = sec[p].l;
        ques[i].r = sec[p].r;
        ques[i].s = i;
    }
    sort(ques,ques+q,cmp);
    l = 1,r = 1;
    lastsum = 1;
    last[a[1]] = 1;
    for(int i = 0;i < q;i++)
    {
        asks(l,r,ques[i].l,ques[i].r,ques[i].s);
        l = ques[i].l,r = ques[i].r;
    }
    for(int i = 0;i < q;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：FallingFYC_ (赞：0)

[P2720 小A的礼物](https://www.luogu.com.cn/problem/P2720)

---

好耶，刚学会线段树合并就随机跳到了这道题。

首先，题目对图给了一大堆条件总结就是一棵以点 $1$ 为根的树。

我们可以在每个节点开一个动态开点的权值线段树来维护每个子树的礼物种类，因为题目中给出的是树所以可以 dfs 一遍然后从叶子节点开始合并线段树，询问就是对应线段树的根节点的值。

---
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define REV(i,a,b) for(int i=(a);i>=(b);i--)
#define CLOSE_TIE ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define psbk push_back
#define mkp make_pair
#define endl '\n'
#define outval(x) cout<<(#x)<<'='<<x<<endl;
#define outarr(a,be,ed) {\
    cout<<(#a)<<'=';\
    FOR(i,be,ed)cout<<a[i]<<' ';\
    cout<<endl;\
}
const int N=1e5+5;
const int C=6e4+5;
struct Node{
    int x,ls,rs;
}t[N*20];
int n,a[N],m,cnt,rt[N];
vector<int> e[N];
void push_up(int p){
    t[p].x=t[t[p].ls].x+t[t[p].rs].x;
}
void update(int &p,int l,int r,int k){
    if(!p) p=++cnt;
    if(l==r&&l==k){
        t[p].x=1;
        return;
    }
    int mid=(l+r)>>1;
    if(k<=mid) update(t[p].ls,l,mid,k);
    else update(t[p].rs,mid+1,r,k);
    push_up(p);
}
int merge(int a,int b,int l,int r){
    if(!a) return b;
    if(!b) return a;
    if(l==r){
        t[a].x|=t[b].x;
        return a;
    }
    int mid=(l+r)>>1;
    t[a].ls=merge(t[a].ls,t[b].ls,l,mid);
    t[a].rs=merge(t[a].rs,t[b].rs,mid+1,r);
    push_up(a);
    return a;
}
void dfs(int u){
    update(rt[u],1,C,a[u]);
    for(int v:e[u]){
        dfs(v);
        merge(rt[u],rt[v],1,C);
    }
}
signed main(){
    CLOSE_TIE
    cin>>n;
    FOR(i,2,n){
        int fa;
        cin>>fa;
        e[fa].psbk(i);
    }
    FOR(i,1,n) cin>>a[i];
    dfs(1);
    cin>>m;
    FOR(i,1,m){
        int id;
        cin>>id;
        cout<<t[rt[id]].x<<endl;
    }
    return 0;
}
```

---

## 作者：a_sad_soul (赞：0)

注意到颜色范围仅有 $5\times 10^4$，这个数量级，所以我们可以考虑用 `bitset` 进行优化。

我们设某个点的 `bitset` 表示子树内存在的点有哪几个。

这里设 $p$ 为子树包含颜色的集合，容易得到一个处理的方程：

$$p_u=p_u\cup p_v,v\in son_u$$

但是发现最后得到的整个 `bitset` 会炸空间。所以我们可以把深搜的返回值定为 `bitset` 就不会炸了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN= 6e4+10;
const int N  = 1e5+10;
int n,m;
vector<int>e[N];
bool vis[N];
int ans[N];
int col[N];
bitset<NN>dfs(int u){
    vis[u]=1;
    bitset<NN>ret;ret[col[u]]=1;
    for(int v:e[u])ret|=dfs(v);
    ans[u]=ret.count();
    return ret;
}
int main(){
    scanf("%d",&n);
    for(int i=2;i<=n;++i){
        int x;
        scanf("%d",&x);
        e[x].push_back(i);
    }
    for(int i=1;i<=n;++i)scanf("%d",&col[i]);
    dfs(1);
    scanf("%d",&m);
    while(m--){
        int q;
        scanf("%d",&q);
        printf("%d\n",ans[q]);
    }
    return 0;
}
```

---

## 作者：__phiu (赞：0)

# 洛谷 P2720
## 思路分析

### 建图

由于题目每个点都有一个入点，所以不难想到这是一个 1 为根的树

### 维护

由于要求维护子树信息，且只需要知道子树，不难想到用 dfs 序转换成连续区间，进行区间查询

### 查询

这样一个个子树询问处理后，我们就变成了一个个区间内不同颜色的数量，用莫队维护即可

### 注意点

1. 在转换后加入删除的是序列上这个位置所对应的点的颜色
2. 区间长度要写对
3. 要将询问的点转换为区间存入莫队
4. 莫队四个循环顺序写对

## Code

```cpp
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
using namespace std;
vector<int>v[200005];
int n;
int fa[200005];
int cntt;
int p[200005];
int gift[200005];
int size[200005];
int a[200005];
void dfs(int now)
{
	size[now]=1;
	p[++cntt]=now;
	a[now]=cntt;
	for(int i=0;i<v[now].size();i++)
		dfs(v[now][i]),size[now]+=size[v[now][i]];
	return;
}
int len;
struct query{
	int l,r,opt;
	bool operator < (const query &a) const{
		if(l/len == a.l/len)
			return r<a.r;
		return l/len<a.l/len;
	}
}q[200005];
int cnt[200005];
int ans;
void add(int x)
{
	if(!cnt[x])
	{
		ans++;
	}
	cnt[x]++;
}
void del(int x)
{
	cnt[x]--;
	if(!cnt[x])
		ans--;
}

int tot[200005];
int main(){
	cin>>n;
	for(int i=2;i<=n;i++)
	{
//		int fa;
		cin>>fa[i];
		v[fa[i]].push_back(i); 
	}
	for(int i=1;i<=n;i++)
	{
		cin>>gift[i];
	} 
	dfs(1);
	int qq;
	cin>>qq;
	len=sqrt(n);
	for(int i=1,x;i<=qq;i++)
	{
		cin>>x;
		q[i].opt=i;
		q[i].l=a[x];
		q[i].r=a[x]+size[x]-1;
	}
	sort(q+1,q+qq+1);
	int l=1,r=0;
	for(int i=1;i<=qq;i++)
	{
		while(r<q[i].r)
			add(gift[p[++r]]);
		while(l>q[i].l)
			add(gift[p[--l]]);
		while(l<q[i].l)
			del(gift[p[l++]]);
		while(r>q[i].r)
			del(gift[p[r--]]);
		tot[q[i].opt]=ans;
	}
	for(int i=1;i<=qq;i++)
		cout<<tot[i]<<endl;
}
```

言简意赅，望审核通过


---


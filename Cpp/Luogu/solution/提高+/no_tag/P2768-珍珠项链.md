# 珍珠项链

## 题目背景

小L通过泥萌的帮助，成功解决了牛栏的修建问题。奶牛们觉得主人非常厉害，于是再也不敢偷懒，母牛们奋力挤奶，生娃。子子孙孙无穷匮也！小L于是成为了一代富豪！

但是一直困扰小L的就是单身问题！小L经过长久的寻觅，小L终于找到了一个心仪的漂亮妹子。于是，小L打算在520那天给妹子一个惊喜！（虽然小L很节约，但是对妹子还是很阔绰的！）


## 题目描述

小L决定用K种珍珠为妹子做一串举世无双的珍珠垂饰。珍珠垂饰是由珍珠连接而成的，其长度可以认为就是珍珠垂饰上珍珠的个数。小L现在腰缠万贯，每种珍珠他都拥有N颗。根据将珍珠垂饰打开后珍珠不同的排列顺序可以区别不同种类的项链。现在，小L好奇自己可以组成多少种长度为1至N的不同的珍珠垂饰？当然，为显富有，每串珍珠垂饰都要必须由K种珍珠连成。 答案取模1234567891。

这一定难不倒聪明的你吧！如果你能帮小L解决这个问题，也许他会把最后的资产分给你1/4哦！


## 说明/提示

40 % ：1<= N<= 100000,  0<= K<= 30

100% ：T <= 10， 1<= N<= 1000000000,  0<= K<= 30

70%-100%：时限10ms


## 样例 #1

### 输入

```
2
2 1
3 2```

### 输出

```
2
8```

# 题解

## 作者：YouAreMySunshine (赞：8)

//看到大神们都不愿写题解那我就来补一发题解好了…… 写的不好或者有问题欢迎指正

- 看完题之后首先观察一下数据范围，**N<=100000000,时限10ms** ,然后T和k非常的小，这启发我们想一个和log n有关的算法

- 仔细审题，题目中 **组成多少种长度为1至N的不同的珍珠垂饰**，**每串珍珠垂饰都要必须由K种珍珠连成**  这告诉我们合法的项链长度至少为K，要求的就是长度K到N的项链中 用了K种珍珠的项链数 ( 以下提到的项链均指长度为K到N的项链 )

- 先考虑不要求一定要用完K种珍珠的项链数 。 显然正好用i种珍珠形成的所有项链有

   **g[i]=i^k+i^(k+1)+i^(k+2)+i^(k+3) ··· +i^n**种

- 设f[i]为正好有i种珍珠可形成的所有合法的项链数 那么本题答案即为f[k] 那f[i]应该怎么算呢？ 运用容斥原理 合法的项链数=总项链数-非法项链数（即没有用够i种珍珠的项链） ，那么我们可以找到关于f数组的递推关系

可以得出这样一个结论：**对于 f[i] , 所有 f[j] (1<=j<i )，都是非法的**

然而因为种类增加了 所以并不能单纯地减掉f[j]，而应该减去** f[j]\*C( j , i ) **（因为从i种中选j种种类有C（j，i）种方案）

于是** f[i] = g[i]-f[j]\*C(j,i) (1<=j<i )** f[0]=0

于是就能递推地计算出f[k] 注意g[i]的计算要用等比数列求和公式 以及组合数的计算要求逆元 （都是一个快速幂的事儿） 还有就是最好变量和函数返回值都开long long 因为MOD+MOD>2147483647 以及int的自乘会溢出啥的

- 总复杂度O（T（k^2+klogn））常数还挺小 足够在10ms之内出解啦

（我由于懒没写组合数的预处理，所以我程序的复杂度实际是O（T（k^3+klogn））的，香港记者号太劲了还是能1ms出解）

- 代码仅供参考：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
    using namespace std;
const int MOD=1234567891;
ll f[33],f1[33];
int Inv[33];
int t,n,k;

ll fpower(ll a,ll b){
    ll r=1,c=b;
    while (c) {
        if (c&1) r=r*a%MOD;
        a=a*a%MOD;
        c>>=1;
    }
    return r;
}

inline ll C(int up,int down) {
    ll res=1;
    if (up==down) return 1;
    if (up>(down-up)) up=down-up;
    for (int i=down-up+1;i<=down;i++) res=res*i%MOD;
    for (int i=1;i<=up;i++) res=res*Inv[i]%MOD;
    return res;
}

int main(){
    cin>>t;
    for (int i=1;i<=30;i++) Inv[i]=fpower(i,MOD-2);
    while (t--) {
        scanf("%d%d",&n,&k);
        f[0]=0; f[1]=n-k+1;
        for (int i=2;i<=k;i++) {
            f[i]=(((fpower(i,n+1)-fpower(i,k)+MOD)%MOD)*Inv[i-1])%MOD;
            for (int j=1;j<i;j++) 
                f[i]=(f[i]-f[j]*C(j,i)%MOD+MOD)%MOD;
        }
        cout<<f[k]<<endl;
    }
    return 0;
}
```

---

## 作者：mqxmm (赞：8)

# 小兔的话
欢迎大家在评论区留言哦~
- - -
# 思路
题目中所说的 **珍珠项链长度为 $i$ 的种类数** 其实就是 **用不同的方式连接出长度为 $i$ 的珍珠项链方案数**  
我们可以先思考 $dp$：$dp[i][j]$ 表示 **用 $j$ 种珍珠** 连接出 **长度为 $i$ 的珍珠项链的方案数**  

- 大家在这里可能会有一个疑问：$dp$ 的状态 $dp[i][j]$，似乎没有考虑每种珍珠的数量  
- 其实是因为每种珍珠的个数是 $N$ 颗，所需要求的最大长度也是 $N$；也就是说，可以只用 $1$ 种珍珠连接出所有的项链，每种珍珠的数量都是足够的；因此，珍珠的数量是不会造成影响的，可以忽略不计  

我们可以进一步推出 $dp$ 的状态转移方程：$dp[i][j] = dp[i - 1][j - 1] * (K - (j - 1)) + dp[i - 1][j] * j$  
- $dp[i - 1][j - 1] * (K - (j - 1))$：当 **第 $i$ 颗珍珠** 与 **前面 $i - 1$ 颗用过的珍珠种类都不同** 的时候，所连接出长度为 $i$ 的珍珠的方案数  
  - $dp[i - 1][j - 1]$：用 **$j - 1$ 种珍珠** 连接出 **长度为 $i - 1$ 的项链** 的方案数  
  - $K - (j - 1)$：**前面的 $i - 1$ 颗珍珠** 已经用了 **$j - 1$ 种珍珠**，而 **第 $i$ 颗使用的珍珠种类是之前没有用过的**，就会有 **没用的珍珠种类的个数** 种情况，即 $K - (j - 1)$  
- $dp[i - 1][j] * j$：当 **第 $i$ 颗的珍珠的种类** 是之前用过的时候，所连接出来的方案数  
  - $dp[i - 1][j]$：**用 $j$ 种珍珠** 连接出 **长度为 $i - 1$ 的项链** 的方案数  
  - $j$：前面 $i - 1$ 颗珍珠用了 $j$ 种，**第 $i$ 颗珍珠** 还是使用 **这 $j$ 种中的某一种**，就有 $j$ 种情况  

最后的答案就是 $dp[1][K] + dp[2][K] + dp[3][K] + ··· + dp[N][K] = \sum_{i = 1}^{N} dp[i][K]$  
- - -
# 分析
如果这道题的数据较小的话，用 $dp$ 就可以 $AC$ 了，可惜 $N$ 的范围太大了
这时候我们就要思考如何优化 $dp$ 的时间复杂度了  

$dp$ 是在进行状态转移，不妨可以把 $dp$ 放在矩阵里求解  
我们设 $ans[i] = dp[1][K] + dp[2][K] + ··· + dp[i][K]$，我们所求的答案就是 $ans[N]$  

我们可以构造一个 **原始矩阵**：  
$$
\begin{bmatrix}
 & dp[1][1] & dp[1][2] & dp[1][3] & ··· & dp[1][K] & ans[0] & \\
\end{bmatrix}
$$
为了状态转移，我们需要将它变成：  
$$
\begin{bmatrix}
 & dp[2][1] & dp[2][2] & dp[2][3] & ··· & dp[2][K] & ans[1] & \\
\end{bmatrix}
$$
继续进化成：  
$$
\begin{bmatrix}
 & dp[3][1] & dp[3][2] & dp[3][3] & ··· & dp[3][K] & ans[2] & \\
\end{bmatrix}
$$
以此类推，直到求出 $ans[N]$ 为止  

从 **构造的原始矩阵** 和 **$dp$ 的状态转移方程** 中，我们可以推出 **加速矩阵 ($k$ 行 $k$ 列)**：  
$$
\begin{bmatrix}
 & 1 & k - 1 & 0 &0 & ··· & 0 & 0 & \\ 
 & 0 & 2 & k - 2 &0 & ··· & 0 & 0 & \\ 
 & 0 & 0 & 3 & k - 3 & ··· & 0 & 0 & \\ 
 & ··· & ··· & ···  & ···  & ··· & 0 & 0 & \\ 
 & ··· & ··· & ···  & ···  & ··· & 1 & 0 & \\ 
 & 0 &0  &0  &0  &0  &k &1 & \\ 
 & 0 &0  &0  &0  &0  &0 &1 & \\
\end{bmatrix}
$$
刚开始是 $ans[0]$，答案是 $ans[N]$，所以要乘以 $N$ 个加速矩阵，可是仍然要超时  

这时候就需要矩阵快速幂了：根据矩阵乘法的结合律，先把 $N$ 个加速矩阵乘起来，再用 **原始矩阵** 乘以 **这个得到的矩阵**，就可以得到最终的答案了
（注意：**矩阵1 $*$ 矩阵2** 不一定等于 **矩阵2 $*$ 矩阵1**，所以不能乘反了）  
- - -
# 代码
```cpp
#include <cstdio>

#define i32 int
#define i64 long long
#define u32 unsigned i32
#define u64 unsigned i64

const i64 MOD = 1234567891;
int T, N, K;

const int MAXK = 30;
struct Matrix
{
	i64 Mat[MAXK + 5][MAXK + 5];
	int R, C;
	
	Matrix()
	{
		for (int i = 1; i <= MAXK + 1; i++)
			for (int j = 1; j <= MAXK + 1; j++)
				Mat[i][j] = 0;
	}
	
	Matrix operator * (const Matrix One) const // 重载矩阵的乘号 
	{
		Matrix Res;
		Res.R = R, Res.C = C;
		for (int i = 1; i <= Res.R; i++) 
			for (int j = 1; j <= Res.C; j++)
				for (int k = 1; k <= One.R; k++)
					Res.Mat[i][j] = (Res.Mat[i][j] + Mat[i][k] * One.Mat[k][j]) % MOD;
		return Res;
	}
}A, B;

Matrix Pow(Matrix One, i64 k) // 矩阵快速幂 
{
	Matrix Res, cnt = One;
	Res.R = K + 1, Res.C = K + 1;
	for (int i = 1; i <= K + 1; i++)
		Res.Mat[i][i] = 1; // 单位矩阵 
	for (int i = k; i >= 1; i >>= 1)
	{
		if (i & 1) Res = Res * cnt;
		cnt = cnt * cnt;
	}
	return Res;
}

void Init(int k) // 初始化 原始矩阵 和 加速矩阵 
{
	A.R = 1, A.C = k + 1;
	A.Mat[1][1] = 1 * k;
	
	B.R = B.C = k + 1;
	B.Mat[1][1] = 1;
	for (int i = 2; i <= k; i++)
	{
		B.Mat[i][i] = i;
		B.Mat[i - 1][i] = k + 1 - i;
	}
	B.Mat[k][k + 1] = B.Mat[k + 1][k + 1] = 1;
}

int main()
{
	scanf("%d", &T);
	while (T--)
	{
		scanf("%d %d", &N, &K);
		Init(K);
		Matrix ans = A * Pow(B, N);
		printf("%lld\n", ans.Mat[1][K + 1]);
	}
	return 0;
}

```

- - -


---

## 作者：Mr_Spade (赞：6)

我好像跟楼下的题解不是很一样啊...

这道题用二项式反演来做很自然吧，而且k完全可以开到$10^5$啊。

开始推式子：

我们用$f_i$表示用了$i$种颜色制作项链的方案数。在不考虑颜色的限制的情况下，总的方案数就是$\sum_{i=1}^n k^i$。于是我们设$g_k=\sum_{i=1}^nk^i$，就很自然的得到：

$$g_k=\sum_{i=1}^k {k \choose i} f_i$$

这就是很经典的二项式反演的式子，它可以转化成：

$$f_k=\sum_{i=1}^k (-1)^{k-i} {k \choose i}g_i$$

于是我们用这个式子算出$f_k$就好了。

那么怎么快速求出$g_i$呢，我们可以发现这是一个等比数列的和，于是用求和公式推一下就是：

$$g_i=\frac{i^{n+1}-i}{i-1}$$

不过要注意这个式子只能对$i>1$的情况使用，那么$i=1$怎么办呢，可以发现结果就是$n$呀，所以特判一下就好了。

对了还要注意这个模数$*2$是会溢出的，所以可以直接开$long\ long$。

所以总的复杂度就是$O(k\log n)$。(其实可以优化成$O(k\frac{\log n}{\log k})$不过看这个复杂度你觉得我会写吗)

代码有点丑不要在意
```cpp
#include<cstdio>
#define int long long
const int mod=1234567891;
inline int add(int a,int b)
{
	if((a+=b)>=mod)
		a-=mod;
	return a;
}
inline int sub(int a,int b)
{
	if((a-=b)<0)
		a+=mod;
	return a;
}
inline int mul(int a,int b)
{
	return (long long)a*b%mod;
}
inline int qpow(int a,int b)
{
	int res=1;
	for(;b;a=mul(a,a),b>>=1)
		if(b&1)
			res=mul(res,a);
	return res;
}
const int K=35;
int n,k;
int fact[K],ifact[K];
inline int C(int n,int m)
{
	return mul(fact[n],mul(ifact[m],ifact[n-m]));
}
inline void solve()
{
	int res=0;
	register int i;
	scanf("%lld%lld",&n,&k);
	for(i=2;i<=k;i++)
		res=add(res,mul(qpow(mod-1,k-i),mul(C(k,i),mul(sub(qpow(i,n+1),i),qpow(i-1,mod-2)))));
	res=add(res,mul(qpow(mod-1,k-1),mul(k,n)));
	printf("%lld\n",res);
}
signed main()
{
	int T;
	register int i;
	fact[0]=1;
	for(i=1;i<=30;i++)
		fact[i]=mul(fact[i-1],i);
	ifact[30]=qpow(fact[30],mod-2);
	for(i=29;i>=0;i--)
		ifact[i]=mul(ifact[i+1],i+1);
	scanf("%lld",&T);
	while(T--)
		solve();
	return 0;
}
```

---

## 作者：wydqwq (赞：2)

[题面](https://www.luogu.com.cn/problem/P2768)

## 思路

首先可以想出，设 $f_{i,j}$ 表示构造一个长度为 $i$ 的序列，使用过 $j$ 中珍珠的方案总数。容易得到：

$$
\left\{\begin{matrix}
f_{i+1,j} \gets j\times f_{i,j}
 \\
f_{i+1,j+1} \gets (k-j)\times f_{i,j}
\end{matrix}\right.
$$

时间复杂度为 $O(Tnk)$，明显不能过，观察数据范围，考虑优化 $O(n)$ 的部分。

对于每个 $f_{i,j}$，只由 $f_{i-1,j}$ 和 $f_{i-1,j-1}$ 转移而来，可以使用矩阵加速。

观察答案为 $\sum_{i=1}^{n}f_{i,k}$，可以在矩阵最后在加一行记录总和。

于是这题就能用 $O(Tk^3 \log n)$ 过了。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10,K=40,mod=1234567891;
int n,k;
struct Matrix{
	int R,C;
	int v[K][K];
};
Matrix operator *(Matrix& x,Matrix& y){
	Matrix c;
	c.R=x.R;
	c.C=y.C;
	memset(c.v,0,sizeof(c.v));
	for(int i=0;i<x.R;i++){
		for(int j=0;j<y.C;j++){
			for(int k=0;k<x.C;k++){
				c.v[i][j]=(c.v[i][j]+x.v[i][k]*y.v[k][j])%mod;
			}
		}
	}
	return c;
}
Matrix One(int x){
	Matrix o;
	o.R=x;
	o.C=x;
	for(int i=0;i<x;i++){
		for(int j=0;j<x;j++){
			o.v[i][j]=0;
			if(i==j) o.v[i][j]=1;
		}
	}
	return o;
}
Matrix qpow(Matrix x,int b){
	Matrix ans=One(x.R);
	while(b){
		if(b&1) ans=ans*x;
		x=x*x;
		b>>=1;
	}
	return ans;
}
signed main(){
	int _;
	cin>>_;
	while(_--){
		cin>>n>>k;
		Matrix a;
		a.R=a.C=k+2;
		memset(a.v,0,sizeof(a.v));
		for(int i=1;i<=k;i++){
			a.v[i][i]=i;
			a.v[i][i-1]=k-i+1;
		}
		a.v[k+1][k-1]=1;
		a.v[k+1][k]=k;
		a.v[k+1][k+1]=1;
		a=qpow(a,n);
		Matrix ans;
		memset(ans.v,0,sizeof(ans.v));
		ans.R=k+2;ans.C=1;
		ans.v[0][0]=1;
		ans=a*ans;
		cout<<ans.v[k+1][0]<<"\n";
	}
	return 0;
}
```

---

## 作者：_zhy (赞：1)

[Link](https://www.luogu.com.cn/problem/P2768)。

## 题目大意

有 $n$ 种珍珠，每种 $n$ 颗，要组成长度为 $1 \sim n$ 的序列，且至少需要用到 $k$ 种不同的珍珠，问有多少种方案。

## 思路

这题很明显是动态规划，我们假设 $f[i][j]$，表示使用 $j$ 颗珍珠，长度为 $i$ 共有多少种方案。

则 $f[i][j] = f[i - 1][j] \times j + f[i - 1][j - 1] \times (k - (j - 1))$。

最终答案就是: $\sum\limits_{i=1}^nf[i][k]$。

所以直接动态规划即可，注意多组数据。

```cpp
#include <cstdio>
#define int long long

const int N = 5e4 + 5, K = 35, Mod = 1234567891;

int n, k, T, f[N][K], ans;

signed main() {
	scanf("%lld", &T);
	while (T--) {
		scanf("%lld %lld", &n, &k);
		f[0][0] = 1, ans = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= k; j++)
				f[i][j] = (f[i - 1][j] * j % Mod + f[i - 1][j - 1] * (k - j + 1) % Mod) % Mod;
			ans = (ans + f[i][k]) % Mod;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

可是我们把这样一份代码交上去后，发现：[Link](https://www.luogu.com.cn/record/89439751)。

这时，我发现 $n \le 1000000000$。

数组都开不了这么大。

这个时候就要请出我们的主角——矩阵加速([不会的戳这里](https://www.luogu.com.cn/problem/P1939))。

关于这道题，我们先看到动态规划的部分：

```cpp
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++)
			f[i][j] = (f[i - 1][j] * j % Mod + f[i - 1][j - 1] * (k - j + 1) % Mod) % Mod;
		ans = (ans + f[i][k]) % Mod;
	}
```

由于每个长度下我们都需要更新完每种情况我们才能继续更新更新下一个长度。

所以初始矩阵一定包含 $f[1][1] \sim f[1][k]$ 这一部分。

而我们需要统计：$\sum\limits_{i=1}^nf[i][k]$，所以可以再在矩阵中添加一个数表示答案。

以 $k = 5$ 举个例子：

初始矩阵为：

$$
\left[
\begin{matrix}
f[1][1] & f[1][2] & f[1][3] & f[1][4] & f[1][5] & 0
\end{matrix}
\right]
$$

现在我们需要寻找到一个矩阵和初始矩阵相乘得到：

$$
\left[
\begin{matrix}
f[2][1] & f[2][2] & f[2][3] & f[2][4] & f[2][5] & f[1][5]
\end{matrix}
\right]
$$

根据递推式，我们可以知道加速矩阵应该如下：

$$
\left[
\begin{matrix}
1 & 4 & 0 & 0 & 0 & 0\\
0 & 2 & 3 & 0 & 0 & 0 &\\
0 & 0 & 3 & 2 & 0 & 0 &\\
0 & 0 & 0 & 4 & 1 & 0 &\\
0 & 0 & 0 & 0 & 5 & 0 &\\
0 & 0 & 0 & 0 & 0 & 1 &\\
0 & 0 & 0 & 0 & 0 & 1 &\\
\end{matrix}
\right]
$$

所以用初始矩阵乘加速矩阵的 $n$ 次方即可。

最终答案为结果矩阵的最后一项。

## code

```cpp
#include <cstdio>
#include <cstring>
#define int long long

const int N = 1e6 + 5, K = 35, Mod = 1234567891;

int n, k, T;

struct Matrix {
	int n, m, a[K][K];
	Matrix() { memset(a, 0, sizeof(a)); }
	Matrix operator * (const Matrix &c) { // 矩阵乘法
		Matrix res;
		res.n = n, res.m = c.m;
		for (int i = 1; i <= 31; i++)
			for (int j = 1; j <= 31; j++)
				for (int k = 1; k <= 31; k++)
					res.a[i][j] = (res.a[i][j] + a[i][k] * c.a[k][j] % Mod) % Mod;
		return res;
	}
} s, ans;

inline void qkpow(int x) { // 矩阵快速幂
	while (x) {
		if (x & 1)
			ans = ans * s;
		s = s * s;
		x >>= 1;
	}
}

signed main() {
	scanf("%lld", &T);
	while (T--) {
		scanf("%lld %lld", &n, &k);
		memset(ans.a, 0, sizeof(ans.a));
		memset(s.a, 0, sizeof(s.a)); // 每次清 0，不然会错
		ans.n = 1, ans.m = k + 1, ans.a[1][1] = k;	// f[1][1] 为 k
		s.n = k + 1, s.m = k + 1;
		for (int i = 1; i <= k; i++)
			s.a[i][i] = i, s.a[i - 1][i] = k - i + 1;
		s.a[k + 1][k + 1] = s.a[k][k + 1] = 1;	// 根据刚才推出的规律得到初始矩阵
		qkpow(n);
		printf("%lld\n", ans.a[1][k + 1]);
	}
	return 0;
}


```

---

## 作者：Pink__ink (赞：1)



## 第一步：

看到这道题，我首先想到是 $dp$，但是问题来了：怎么设计状态呢？


因为这道题关系到两个变量，所以我们可以用二维 $dp$。

设：$dp[i][j]$ 表示用 $j$ 种珍珠构成长度为 $i$ 的吊坠的总方案数。


根据题意，我们可以推出：

$dp[i][j] = (k-(j-1))*dp[i-1][j-1] + j*dp[i-1][j]$


$ans[i]$ 表示长度在i以内且满足条件的吊坠的总方案数。


所以 ：

$ans[i]=dp[1][k]+dp[2][k]+...+dp[i][k]$


显然，问题的最终答案为 $ans[n]$。


但是考虑到 $n$ 的范围，想办法优化。


## 第二步：

根据前面的分析显然有：

$ans[i]=ans[i-1]+dp[i][k]$

我们可以构造一个 $1*(k+1)$ 的矩阵 $F$，里面装的是：

${dp[i][1],dp[i][2],dp[i][3], ... ,dp[i][k],ans[i-1]}$

我们希望再构造一个 $(k+1)*(k+1)$ 的加速矩阵 $A$。

使得原矩阵乘上这个加速矩阵为：

$dp[i+1][1], dp[i+1][2], dp[i+1][3], ... , dp[i+1][k], ans[i]$

加速矩阵的求法很好求，这里就不过多解释了。

最终答案就是 $F*An$ ，其中矩阵 $F$ 的初始值为：

$dp[1][1], dp[1][2], dp[1][3], ... ,dp[1][k], ans[0]$


## Code:
```cpp

#include<bits/stdc++.h>
using namespace std;
#define MAXN 205
#define int long long
const int mod=1234567891;
int n,T,k;
struct Matrix{
	int c[MAXN][MAXN],n,m;
	Matrix operator *(const Matrix &x)const{
		Matrix r;
		r.n=n,r.m=x.m;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=x.m;j++){
				int sum=0;
				for(int k=1;k<=m;k++)
					sum=(sum+c[i][k]*x.c[k][j])%mod;
				r.c[i][j]=sum;
			}
		return r;
	} 
}A,B;
Matrix qkpow(Matrix A,int n){
	Matrix res=A;
	while(n){
		if(n&1) res=res*A;
		A=A*A,n>>=1;
	}
	return res;
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&k);
		A.n=1,A.m=B.n=B.m=k+1;
		A.c[1][1]=k,B.c[1][1]=1;
		for(int i=2;i<=k;i++) B.c[i][i]=i,B.c[i-1][i]=k-i+1;
		B.c[k][k+1]=B.c[k+1][k+1]=1;
		Matrix ans=A*qkpow(B,n-1);
		printf("%lld\n",ans.c[1][k+1]);
	}
	return 0;
}
```

---

## 作者：renhr2002 (赞：1)

发现没有矩阵乘法的题解，我就想来H2O2一发（**不是指我开了O2优化，这是我的第二篇题解**）。实际上，我的代码过是过了，但没达到10ms的“要求”。如有更优化的算法，敬请指出。
设长度为i，用了j种珍珠的方案数为dp【i】【j】，长度不超过i的方案数为ans【i】，就可以得到矩阵：
```
|dp[i][0]| |0 0 0 0 ... 0 0 0| |dp[i-1][0]|
|dp[i][1]| |k 1 0 0 ... 0 0 0| |dp[i-1][1]|
|dp[i][2]| |0 k-1 2 0 ... 0 0| |dp[i-1][2]|
|dp[i][3]|=|0 0 k-2 3 0 ... 0|*|dp[i-1][3]|
|........| |.................| |..........|
|dp[i][k]| |0 0 0 0 0 ... 1 k| |dp[i-1][k]|
|ans[i]  | |0 0 0 0 0 ... 1 1| |ans[i-1]  |
```
记上述表达式中转换矩阵为A，则方案数就是A的n+1次幂的左下角元素。
这个可以用矩阵快速幂解决。时间复杂度O（$k^2logn$）。
代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 36
#define mod 1234567891
#define ull unsigned long long
int T;
ull n;
int k;
struct matrix
{
	ull mat[maxn][maxn];
	int siz;
	friend matrix operator * (matrix &a,matrix &b)
	{
		matrix ret;
		memset(&ret,0,sizeof(ret));
		ret.siz=a.siz;
		for(int i=1;i<=a.siz;i++)
		{
			for(int j=1;j<=a.siz;j++)
			{
				for(int k=1;k<=a.siz;k++)
				{
					ret.mat[i][j]+=a.mat[i][k]*b.mat[k][j];
					ret.mat[i][j]%=mod;
				}
			}
		}
		return ret;
	}
};
matrix power(matrix a,ull b)
{
	matrix ans;
	memset(&ans,0,sizeof(ans));
	ans.siz=a.siz;
	for(int i=1;i<=ans.siz;i++)
	{
		ans.mat[i][i]=1;
	}
	while(b)
	{
		if(b&1)
		{
			ans=ans*a;
		}
		a=a*a;
		b>>=1;
	}
	return ans;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%llu%d",&n,&k);
		matrix a;
		memset(&a,0,sizeof(a));
		a.siz=k+2;
		for(int i=2;i<=k+1;i++)
		{
			a.mat[i][i]=i-1;
		}
		for(int i=2;i<=k+1;i++)
		{
			a.mat[i][i-1]=k-i+2;
		}
		a.mat[k+2][k+1]=a.mat[k+2][k+2]=1;
		a=power(a,n+1);
		printf("%llu\n",a.mat[k+2][1]);
	}
	return 0;
}

```

---

## 作者：UserJCY (赞：0)

定义 $f_i$ 表示恰好使用 $i$ 种珍珠拼成的长度为 $[k,n]$ 的串的方案数。

可以发现，$f$ 有如下性质（证明在文末）：

- $f_1=n-k+1$ [1]
- $ans=f_k$ [2]
- $f_i=\frac{i^{n+1}-i^k}{i-1}-\sum_{j=1}^{i-1}f_j\times\binom{i}{j}$ [3]

由于 $k \le 30$，所以可以直接递推得到答案。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1234567891;
int T,n,k,f[35],fac[35],inv[35];
int qpow(int a,int b){
	int ret=1;
	while(b){
		if(b&1)(ret*=a)%=mod;
		(a*=a)%=mod,b>>=1;
	}
	return ret;
}
void init(){
	fac[0]=inv[0]=1;
	for(int i=1;i<=32;i++)fac[i]=fac[i-1]*i%mod;
	inv[32]=qpow(fac[32],mod-2);
	for(int i=31;i>=1;i--)inv[i]=inv[i+1]*(i+1)%mod;
	return;
}
int C(int n,int m){
	return fac[m]*inv[n]%mod*inv[m-n]%mod;
}
signed main(){
	init();
	cin>>T;
	while(T--){
		cin>>n>>k;
		f[1]=n-k+1;
		for(int x=2;x<=k;x++){
			f[x]=(qpow(x,n+1)-qpow(x,k)+mod)%mod*qpow(x-1,mod-2)%mod;
			for(int i=1;i<x;i++)((f[x]-=f[i]*C(i,x)%mod)+=mod)%=mod; 
		}
		cout<<f[k]<<endl;
	}
	return 0;
} 
```

### 对 $f$ 性质的证明：

#### [1] $f_1=n-k+1$：

只有一种珍珠时，对于长度从 $k$ 到 $n$，都分别有且仅有一种排法，故 $f_1=n-k+1$。

#### [2] $ans=f_k$：

由 $f$ 的定义和题意显然，这里不再赘述。

#### [3] $f_i=\frac{i^{n+1}-i^k}{i-1}-\sum_{j=1}^{i-1}f_j\times\binom{i}{j}$：

首先，在不考虑必须使用完全部 $i$ 种珍珠时，长度为 $l$ 的串有 $i^l$ 种可能（每位有 $i$ 种，乘法原理），所以共有 $\sum_{l=k}^{n}i^l$ 种排法。

**引理：$\sum_{i=1}^nx^i=\frac{x^{n+1}-1}{x-1}$**

**证明：**

令 $s=\sum_{i=1}^nx^i$ ①

则 $xs=\sum_{i=2}^{n+1}x^i$ ②

$②-①$ 得：$xs-s=x^{n+1}-1$

所以 $s=\frac{x^{n+1}-1}{x-1}$

故可以化简上式 $\sum_{l=k}^{n}i^l$：

$$
\begin{align}
\sum_{l=k}^{n}i^l&=\sum_{l=1}^{n}i^l-\sum_{l=1}^{k-1}i^l\nonumber\\
&=\frac{i^{n+1}-1}{i-1}-\frac{i^k}{i-1}\nonumber\\
&=\frac{i^{n+1}-i^k}{i-1}\nonumber
\end{align}
$$

现在考虑删去不合法的情况，即没有使用全部 $i$ 种珍珠的情况。不合法的情况就是恰由 $1\sim i - 1$ 种珍珠组成的情况数之和。

恰好使用 $j(1\le j\le i - 1)$ 种珍珠组成的长度在 $[k,n]$ 范围内的串的方案数为 $f_j$。这里我们是从 $i$ 种珍珠中选取 $j$ 种来组成串，从 $i$ 个元素中选取 $j$ 个元素的组合数为 $\binom{i}{j}$，所以恰由 $j$ 种珍珠组成的不合法情况共有 $f_j\times\binom{i}{j}$ 种。因此，我们需要从总的方案数中减去所有不合法的情况，即减去 $\sum_{j = 1}^{i - 1}f_j\times\binom{i}{j}$。

综上，我们得到了转移 $f_i=\frac{i^{n+1}-i^k}{i-1}-\sum_{j=1}^{i-1}f_j\times\binom{i}{j}$。此题得解。

---


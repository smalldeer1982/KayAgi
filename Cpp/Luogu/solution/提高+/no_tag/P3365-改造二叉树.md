# 改造二叉树

## 题目背景

勤奋又善于思考的小 L 接触了信息学竞赛，开始的学习十分顺利。但是，小 L 对数据结构的掌握实在十分渣渣。

所以，小 L 当时卡在了二叉树。

## 题目描述

在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设 $key_p$ 表示结点 $p$ 上的数值。对于其中的每个结点 $p$，若其存在左孩子 $lch$，则 $key_p>key_{lch}$；若其存在右孩子 $rch$，则 $key_p<key_{rch}$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的 $key$ 小于当前结点的 $key$，其右子树中的 $key$ 大于当前结点的 $key$。（因为小 L 十分喜欢装 xx，所以这里他十分装 xx 的给大家介绍了什么是二叉树和二叉搜索树）。

可是善于思考的小 L 不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或 $0$），所要的最少修改次数。

这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\dfrac{1}{16}$ 哦！

## 说明/提示

对于 $20\%$ 的数据：$n \leq 10$，$a_i \leq 100$。

对于 $40\%$ 的数据：$n \leq 100$，$a_i \leq 200$。

对于 $60\%$ 的数据：$n \leq 2000$。

对于 $100\%$ 的数据：$n \leq 10^5$，$a_i < 2^{31}$。

## 样例 #1

### 输入

```
3
2 2 2
1 0
1 1```

### 输出

```
2```

# 题解

## 作者：asuldb (赞：34)

非常妙的一道题

首先如果看到这是一棵树就往树形$dp$上想那肯定就想不出来了

注意这是一棵二叉搜索树，所以有一些非常奇妙的性质

熟悉平衡树的人应该知道，二叉搜索树的中根遍历是严格上升的

所以我们将中根遍历求出来就好了

现在的问题变成最少修改一个序列上的一些数，使得其严格上升

首先直接求出$LIS$的长度再用$n$一减肯定是错的

我们考虑一下反着做

我们设$f_i$表示前$i$个数里最多有多少个不用修改

对于$i$位置上的数$a_i$如果前面有一个位置$j$满足$a_i-a_j>=i-j$的话，我们就可以把$(i,j)$上的数全部修改而且能使得其严格递增

于是就有这样一个方程

$f_i=max(f_j+1)[a_i-a_j>=i-j]$

也就是$a_i-i>=a_j-j$

那就是所有的数减掉下标之后求一个最长不下降子序列啊，最后拿$n$减去这个长度就好了

$O(nlogn)$就可以求出了

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 100005
#define max(a,b) ((a)>(b)?(a):(b))
inline int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
int ch[maxn][2],a[maxn],n,now,key[maxn];
void dfs(int x)
{
    if(ch[x][0]) dfs(ch[x][0]);
    a[++now]=key[x];
    if(ch[x][1]) dfs(ch[x][1]);
}
int f[maxn],d[maxn],len;
inline int find(int x)
{
    int l=1,r=len,ans=0;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(d[mid]<=x) ans=mid,l=mid+1;
            else r=mid-1;
    }
    return ans;
}
int main()
{
    n=read();
    for(re int i=1;i<=n;i++)
        key[i]=read();
    int x,fa;
    for(re int i=2;i<=n;i++)
        fa=read(),x=read(),ch[fa][x]=i;
    dfs(1);
    for(re int i=1;i<=n;i++)
        a[i]-=i;
    for(re int i=1;i<=n;i++)
    {
        f[i]=find(a[i])+1;
        d[f[i]]=a[i];
        len=max(len,f[i]);
    }
    printf("%d\n",n-len);
    return 0;
}
```

---

## 作者：zzw4257 (赞：15)

看到这道题，我们应该有种冲动吧——如果你没有，那么我们一起来看

排序二叉树最大的特点是什么——没错，就是排序，更严谨来说，是它的中序遍历成升序（无重复元素前提下） ，而对一棵二叉树，它的中序遍历的顺序是不会变化的，因此现在的a[i]只会是a[i]不变化/变化后得到的结果

我们又想让修改次数最少，又想令其保持升序，因此我们直接找出其中最长上升子序列不动，其余修改（爱咋咋地）不是

流程如下：

1.	读入，求树的中序遍历，计入s[]数组
2.	LIS一遍求出len，ans=n-len

同时，这道题n<=100000,$n^2$的老年LIS算法是不行的，大家可以去看大神的博客，建议写法：

```cpp
memset(dp,INF,sizeof dp);
go(i,1,n)dp[lower_bound(dp+1,dp+n+1,s[i])-dp]=s[i];
	reintlen=(lower_bound(dp+1,dp+n+1,INF)-dp)-1;

```
    
但千万别开心过头了
来看看我考场上写的样例

![](https://cdn.luogu.com.cn/upload/pic/41030.png)

How to 完善我们的方案？
借用一句话：不严谨的真理往往是通往真理的钥匙。


从错误入手，分析错误原因：
考虑二叉排序树的定义：

 _设key[p]表示结点p 上的数值，对于其中的每个结点p，若其存在左孩子lch，则key[p]>key[lch]；若其存在右孩子rch，则key[p]<key[rch]。注意，应该是所有左子树中的key 小于当前key，所有右子树中的key 大于当前key。_ 

其中唯一且最大的限制就在于根和儿子的大小约束关系：而这种关系体现在什么，是中序遍历的编号！

![](https://cdn.luogu.com.cn/upload/pic/41031.png)

再看此图，5在中序是4,3在中序是7

故3和5的关系牵扯到3层（第一次我们将其列出：1比3小，2比1小，5比2大），简单来说，由于这里不可取等，3和5就至少相差三——不信的话你还是尝试去造第二个图
在程序实现中即对每对i，j,|va[i]-va[j]|>=|其中序遍历之差|

这个东西很麻烦，而中序遍历时我们其实可以直接保存va[i]-(i的中序遍历编号)之后就求一个不下降序列即可

具体的实现如下：

中序：
```cpp
void zx(re int rt)
{
	if(t[rt].lc) zx(t[rt].lc);
	s[++s[0]]=t[rt].va-s[0];
	if(t[rt].rc) zx(t[rt].rc);
}
```
不降lis（这里没办法stl直接写）：
```cpp
dp[len=1]=s[1];
go(i,2,n)
	if(s[i]>=dp[len]) 
		dp[++len]=s[i]; 
	else{      		
        	re int j=upper_bound(dp+1,dp+len+1,s[i])-dp;
            dp[j]=s[i];
		}
//ans=n-len
```





---

## 作者：张亦弛 (赞：12)

## 题目大意

给出一颗二叉树及其NN个节点的权值，每个节点权值最多修改一次，且只能修改成整数。求最小的修改次数，使这棵二叉树成为排序二叉树。

N<=100000N<=100000
## 题目分析
首先，排序二叉树是一种左儿子权值严格小于父亲，右儿子权值严格大于父亲的二叉树（BSTBST）。所谓“排序”，就是中序遍历排序二叉树，得到的是一个严格递增的序列。

那么我们显然要先中序遍历一趟，构造出inord数组，那么题目就变成求使一个序列变为严格递增所需的最少修改次数 
所以答案就为N−LIS(最长上升子序列)

#### 但是，

题目要求每个节点的权值只能改为整数！只要有“卡死”的重复元素，就完蛋了 

如这个样例就崩溃了： 

N=4　

A:1　　2　　2　　3

LIS=3　　
Wrong Answer=1 ，
Wright  Answer=2



我们再思考一下：

修改完后，显然 

A[1]<A[2]<...<A[i]<A[i+1]<...<A[N]

即

A[1]+1<=A[2],A[2]+1<=A[3],...,A[i]+1<=A[i+1],...,A[N-1]+1<=A[N]

又对于i<=j,A[j]-A[i]>=j-i,即A[j]-j>=A[i]-i

则A[1]-1<=A[2]-2<=A[3]-3......


此时，就没有重复的元素影响了

只要O(N∗logN)求一趟最长不降子序列就OK了



### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//二叉树节点数
struct tree//二叉树 
{
	int fa;//父亲节点 
	int l;//左孩子 
	int r;//右孩子 
}tr[100005];
int w[100005];//结点的数值 
int inord[100005];//中序遍历 
int k;
int lis[100005];//最长不降子序列
void inorder(int root)//中序遍历 
{
	if(tr[root].l)//如果左儿子不为空 
		inorder(tr[root].l);//搜索左儿子 
	inord[++k]=w[root]-k;
	if(tr[root].r)//如果右儿子不为空 
		inorder(tr[root].r);//搜索右儿子 
}
int main()
{
	cin>>n;//输入n个结点 
	for(int i=1;i<=n;i++)
		cin>>w[i];//输入每个人结点的数值 
	tr[1].fa=0;//1号点的父亲为空 
	for(int i=2;i<=n;i++)
	{
		int t;//左/右儿子 
		cin>>tr[i].fa>>t;//输入父亲结点 
		if(t==0) 
			tr[tr[i].fa].l=i;//这个点是他父亲的左儿子 
		else
			tr[tr[i].fa].r=i;//这个点是他父亲的右儿子 
	}
	inorder(1);//对这棵树进行中序遍历 
	lis[1]=inord[1];//求最长不下降序列 
	int cnt=1;//最长不下降序列长度 
	for(int i=2;i<=n;i++)
	{
		if(inord[i]>=lis[cnt])
			lis[++cnt]=inord[i];
		else
		{
			int j=lower_bound(lis+1,lis+1+cnt,inord[i])-lis;//lower_bound返回的是在lis的1~1+cnt的范围内第一个大于等于inord[i]的数的位置 
			lis[j]=inord[i]; 
		}	
	} 
	cout<<n-cnt;//总个数-最长不下降序列长度，就是要修改的个数 
}
```

---

## 作者：Horrigue_袁四爷 (赞：7)

快读+中序遍历+不减LIS

洛谷最优解美滋滋
```
#include<cstdio>
#include<algorithm>
using namespace std;
struct Binary{
	int lch,rch,data;
}tr[500010];
int spray[500010],d[500010],k,n;
inline long long read()
{
    long long ans=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {ans=ans*10+ch-'0';ch=getchar();}
    return ans*f;
}
void MiddleOrder(int now){
	if(tr[now].lch) MiddleOrder(tr[now].lch);
	spray[++k]=tr[now].data-k;
	if(tr[now].rch) MiddleOrder(tr[now].rch);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		tr[i].data=read();
	for(int i=1,fa,ch;i<=n-1;i++)
	{
		fa=read();ch=read();
		if(!ch) tr[fa].lch=i+1;
		 else tr[fa].rch=i+1;
	}
	MiddleOrder(1);
	int head=1;
    d[1]=spray[1];
	for(int i=2;i<=n;i++)
	{
		if(spray[i]>=d[head]) d[++head]=spray[i];
		 else{
		 	int j=lower_bound(d+1,d+head+1,spray[i])-d;
		 	d[j]=spray[i];
		 }
	}
	printf("%d",n-head);
	return 0;
}
```

---

## 作者：Kwork (赞：6)

题面好恶心的说。

根据题面，我们看不出他在说什么，仔细看，还是看不懂。。。。然后，看懂了------

可以先求出树的中序遍历，然后做一遍最长上升子序列？？？但是由于整数限制，这样会WA。

所以我们可以对于数di做一个映射，di=di-i，然后做一遍最长不下降子序列就可以得出正确的答案。

求遍历的方法和LIS的方法不细说了。






```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn=100000+20;
int n,p[maxn],lch[maxn],rch[maxn];
int order[maxn],tot=0;
int f[maxn],ans;
inline void read(int& n){
    n=0;
    char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return;
}
void init(){
    memset(lch,-1,sizeof(lch));
    memset(rch,-1,sizeof(rch));
    read(n);
    for(int i=1;i<=n;i++) read(p[i]);
    for(int i=2;i<=n;i++){
        int fa,ff;
        read(fa);
        read(ff);
        if(ff==0) lch[fa]=i;
        else rch[fa]=i;
    }
    return;
}
void dfs(int node){
    if(node==-1) return;
    dfs(lch[node]);
    ++tot;
    order[tot]=p[node]-tot;
    dfs(rch[node]);
    return;
}
void solve(){
    dfs(1);
    for(int i=1;i<=tot;i++){
        f[i]=2100000000;
    }
    f[1]=order[1];ans=1;
    for(int i=2;i<=tot;i++){
        if(order[i]>=f[ans])
            f[++ans]=order[i];
        else{
            int l = 1,r = ans;
            while (l <= r) {
                int mid = l + r >> 1;
                if (f[mid] <= order[i]) l = mid + 1;
                else     r = mid - 1;
            }
            f[l] = order[i];
        }
    }
    ans=n-ans;
    printf("%d",ans);
    return;
}
int main(){
    init();
    solve();
    return 0;
}

```

---

## 作者：zac2010 (赞：5)

### 题意

给定一颗树，每次操做可以修改一个点的权值，求最少几步可以变成二叉搜索树（及每个左边儿子的权值都小于中间儿子,每个右边儿子都大于中间儿子）

### 思路

由于题目要求要变成二叉搜索树，所以我们可以想到：二叉搜索树的中根遍历是严格上升的。所以我们可以求其中序遍历，再求最长上升子序列

但是这个最长上升子序列是有限制的，设我们设 $dp_i$ 表示前 $i$ 个数里最多有多少个数是不用修改就能满足二叉搜索树的。为了满足他们间的部分能放得下那些中间的数，所以我们要满足以下式子： $a_i-a_j>=i-j$ 

接下来我们便可得到以下式子： $dp_i=\max(dp_j+1)[a_i-a_j>=i-j]$ ,也就可以化为 $dp_i=\max(dp_j+1)[a_i-i>=a_j-j]$ 。那也就是把所有的数都减掉下标之后（即式子中的 $a_i-i$ 和 $a_j-j$ ）再求一个最长不下降子序列，最后拿 $n$ 减去这个长度 $len$ 就好了（等量关系为：总数 $-$ 不要修改的数的个数 $=$ 要修改的个数）

### 证明

这里进行最长上升子序列 $O(nlogn)$ 解法的证明（如果不理解代码可以来看此证明）。至于可以证明什么，其他地方好理解，就证明代码里的 $val$ 数组怎么保证有序。我们假设先前的 $val$ 数组是有序的，那我们的长度 $len$ 如果要变大，那 $find$ 函数就必须返回先前的最大值（即 $len$ 变量），所以我们可以保证，所有的 $val$ 数组里的元素都小于等于当前数，那么在更新新的 $val[dp[i]]$ 也就是 $val[len+1]$ 时，就能保证前面的 $val$ 数组的数都小于当前的数了。

### 时间复杂度

时间：中序遍历为 $O(n)$ ，求最长上升子序列为 $O(n \log n)$ ，最长上升子序列的遍历数组为 $O(n)$ ，二分为 $O(\log n)$ ，总为 $O(n \times \log n)=O(n \log n)$ 。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N],son[N][2],val[N],c[N],dp[N],tot,ll;
void dfs(int x){
	if(son[x][0])dfs(son[x][0]);
	c[++tot]=a[x];
	if(son[x][1])dfs(son[x][1]);
}
int find(int x){
	int l=1,r=ll,ans=0;
	while(l<=r){
		int mid=(l+r)/2;
		if(val[mid]<=x) l=mid+1,ans=mid;
		else r=mid-1;
	}
	return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=2,fa,lr;i<=n;i++){
    	scanf("%d%d",&fa,&lr);
    	son[fa][lr]=i;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
		c[i]-=i;
	for(int i=1;i<=n;i++){
		dp[i]=find(c[i])+1;
		ll=max(ll,dp[i]);
		val[dp[i]]=c[i];
	}
	cout<<n-ll<<endl;
    return 0;
}
```

---

## 作者：torque (赞：4)

# [P3365 改造二叉树](https://www.luogu.org/problem/P3365)

> ## 题意

### 题目背景
```
勤奋又善于思考的小L接触了信息学竞赛，开始的学习十分顺利。但是，小L对数据结构
的掌握实在十分渣渣。

所以，小L当时卡在了二叉树。
```

### 题目描述
```
在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作
“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起
了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设key[p]表示结
点p上的数值。对于其中的每个结点p，若其存在左孩子lch，则key[p]>key[lch]；若其
存在右孩子rch，则key[p]<key[rch]；注意，本题中的二叉搜索树应满足对于所有结
点，其左子树中的key小于当前结点的key，其右子树中的key大于当前结点的key。（因
为小L十分喜欢装xx，所以这里他十分装xx的给大家介绍了什么是二叉树和二叉搜索
树）。

可是善于思考的小L不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定
一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结
点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数
（可以是负整数或0），所要的最少修改次数。

这一定难不倒聪明的你吧！如果你能帮小L解决这个问题，也许他会把最后的资产分给
你1/16哦！
```

### 输入格式
```
第一行一个正整数n表示二叉树节点数。

第二行n个正整数用空格分隔开，第i个数ai表示结点i的原始数值。

此后n - 1行每行两个非负整数fa, ch，第i + 2行描述结点i + 1的父亲编号fa，以及
父子关系ch，(ch = 0 表示i + 1为左儿子，ch = 1表示i + 1为右儿子)。

为了让你稍微减轻些负担，小L规定：结点1一定是二叉树的根哦！
```

### 输出格式
```
仅一行包含一个整数，表示最少的修改次数
```

### 输入样例
```cpp
3
2 2 2
1 0
1 1
```

### 输出样例
```cpp
2
```

### 说明/提示
```
20 % ：n <= 10 , ai <= 100.
40 % ：n <= 100 , ai <= 200
60 % ：n <= 2000 .
100 % ：n <= 10 ^ 5 ,  ai < 2 ^ 31.
```

### 题意简述
```
给定一棵二叉树以及书上每个点的点权，你每次可以将一个点的点权改为任意值，要
求最后的树是一棵二叉搜索树
```
注：不知道二叉搜索树是啥的戳[这里](https://oi-wiki.org/ds/bst/)

> ## 解题
~~第一眼以为这是一个树形DP的举起你们的爪子~~

虽然题目是用树的形式给出的

但是如果你使用树形DP实际操作时却很困难

因为：
```
1.如何DP？或者说：如何转移？
2.最后的答案如何统计
```

反正当我做的时候连第一点都解决不了~~所以说我是真的蒻啊~~

再看看题目，就是要求最小的修改次数使得给定的树变成二叉搜索树

怎么办呢？

这个时候就要利用到二叉搜索树的一个重要性质了：

**二叉搜索树的中序遍历是有序的**

于是题目就变成了
```
给定一个长度为n的序列(是序列不是排列)，求最少的修改次数使得这个序列变为单调
上升序列
```

所以我们再来思考上面这个问题

要修改尽量少的次数和保留尽量多的原数是等价的

我们就求出能保留的最多个数

其实就是[LIS](https://baike.baidu.com/item/LIS/16018280?fr=aladdin)啦

简单证明一下
```
不可能找出比LIS更长的保留序列
因为结果必须有序
所以保留的部分必须有序
```
但是事情远没有这么简单

在保留值的同时，这个数的位置也必须保留

比如
```cpp
10
1 9 8 2 3 4 5 6 7 8
```
按照刚刚的想法，应求出len_of_LIS=8

所以答案是10-8=2

然而，原题目要求序列严格升序，1与2之间的两个数无论如何也无法塞在1和2的中间

就是说，最后求出的LIS还需满足

**记d[i]表示LIS中的第i个数，那么对于任意i!=j，有d[i]-d[j]>=i-j**

也就是说，两个数之间必须要给待修改的数留空间

很多人就mengbi了：LIS也没这玩法呀？

其实我把刚刚的条件变形一下就很简单了

$\boxed{d[i]-i>=d[j]-j}$

怎么样，是不是很神奇？

所以我们最后只需要把d[i]映射成d[i]-i就行了，最后再求**最长不降子序列**(不是LIS!!!)

总结一下，总共就是以下几步
```
1.读入、建树
2.中序遍历，获得序列
3.映射并求解
```

> ## 代码
### $\color{red}{FBI}$&nbsp;&nbsp;&nbsp;&nbsp;$\color{red}{WARNING}$
### 如果你仍未掌握此题，请不要观看代码部分，除非是部分细节不理解

```cpp
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define N 100001
#define rnt register int
using namespace std;
int n,x,y,cnt,len,d[N],dp[N];
struct node{int val,ch[2],fa;}tree[N];
inline char my_getchar(){
    static char buf[2048];
    static int size=0,pos=0;
    if(size==pos){
        pos=0;
        size=fread(buf,1,2048,stdin);
        if(!size) return EOF;
        else return buf[pos++];
    }
    else return buf[pos++];
}
inline int FR(){//fast_read
    int ans=0,fh=0;
    char c=my_getchar();
    while(!isdigit(c)){
        fh|=c=='-';
        c=my_getchar();
    }
    while(isdigit(c)) ans=(ans<<1)+(ans<<3)+(c^48),c=my_getchar();
    return fh?-ans:ans;
}
inline void init(){
	n=FR();memset(dp,0x3f,sizeof(dp));d[0]=-0x3fffffff;dp[0]=0;
	for(rnt i=1;i<=n;i=-~i) tree[i].val=FR();
	for(rnt i=2;i<=n;i=-~i){
		x=FR(),y=FR();
		tree[i].fa=x;
		tree[x].ch[y]=i;
	}
}
void inorder_traversal(int x){
    if(tree[x].ch[0]) inorder_traversal(tree[x].ch[0]);
    d[++cnt]=tree[x].val;
    if(tree[x].ch[1]) inorder_traversal(tree[x].ch[1]);
}
inline void solve(){
	for(rnt i=1;i<=n;i=-~i) d[i]-=i;
	dp[1]=d[1];len=1;
	for(rnt i=2;i<=n;i=-~i){
		if(d[i]>=dp[len]) dp[++len]=d[i];
		else *upper_bound(dp+1,dp+len+1,d[i])=d[i];
	}
	printf("%d",n-len);
}
int main(){
	/*1*/init();
	/*2*/inorder_traversal(1);
	/*3*/solve();
	return 0;
}
```

---

## 作者：_Chesed_ (赞：3)

# [P3365 改造二叉树](https://www.luogu.com.cn/problem/P3365)
## 题意
给定一棵二叉树，可以任意修改结点的数值。要求用最小的费用将其变成一棵[二叉搜索树](https://oi.wiki/ds/bst/)。
## 初步分析
由题意可知这是一道求最优解的题目，可以想到贪心、动规求解。因为修改每个结点的费用都是 1，所以这道题其实就是要求修改最少的结点数，也就是求出最多可以有多少个结点符合要求。

首先，容易发现二叉搜索树的性质是其中序遍历是一个严格上升子序列。那么这道题的二叉树就只是一个幌子，我们完全可以把二叉树的中序遍历求出来。那么问题简化成了：给你 $n$ 个数字，问至少要修改多少个数字，才能使其变为单调上升。
## 简化分析
上文已将题目简化，这个题目在洛谷上是有板子的：[P3902](https://www.luogu.com.cn/problem/P3902)。如果直接求最长上升子序列很明显不对，如：```1 3 2 3```。对于两点 $i$ 和 $j(i<j)$ 满足：

$$a[j]-a[i] \ge j-i$$
即：
$$a[j]-j\ge a[i]-i$$
令 $b[i]=a[i]-i$，即求 $b$ 的最长非降子序列的长度。

最长非降子序列的经典求法，$f[i]$ 表示以 $i$ 结尾的最长非降子序列的长度，$g[i]$ 表示长度。为 $j$ 的非降子序列中，最后一位的最小值是多少。

$f[i]=j+1$，其中 $j$ 表示 $a[i]$ 在 $g$ 数组中二分的位置，有 $g[j]b \le a[i] \le g[j+1]$，然后更新 $g[j+1]=a[i]$。

这样求最长非降子序列是 $O(n \log n)$ 的算法，所以不会超时。最终答案就是 $n-maxx$，$maxx$ 表示最长非降子序列。
## Code（AC）
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
namespace rnfmabj{
struct tree{
	int lson,rson,val;
}t[MAXN];
int bl[MAXN];
int tot;
int f[MAXN];
void dfs_find(int u){
	if(t[u].lson!=0) dfs_find(t[u].lson);
	bl[++tot]=t[u].val-tot;
	if(t[u].rson!=0) dfs_find(t[u].rson);
}
int Mid(int l,int r,int i){
	while(l<=r){
		int mid=(l+r)>>1;
		if(f[mid]<=bl[i]) l=mid+1;
		else r=mid-1;
	}
	return l;
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&t[i].val);
	}
	for(int i=2;i<=n;i++){
		int id,flag;
		scanf("%d%d",&id,&flag);
		if(flag==0) t[id].lson=i;
		else t[id].rson=i;
	}
	dfs_find(1);
	int cnt=0;
	f[++cnt]=bl[1];
	for(int i=2;i<=n;i++){
		if(bl[i]>=f[cnt]) f[++cnt]=bl[i];
		else{
			int l=Mid(1,cnt,i);
			f[l]=bl[i];
		}
	}
	printf("%d",n-cnt);
	return 0;
}
}
int main(){
	rnfmabj::main();
}
```


---

## 作者：Mobius127 (赞：2)

搜索二叉树的中序遍历是一个**完美的**上升序列。

我们可以用同样的方打印出题中二叉树的生成数组（这东西初赛就学了吧。）

那么问题就转成了：给出一个整数序列，问多少次修改能使得该序列成为一个最长上升序列，这是一个十分经典的 dp 。

考虑求出有多少个不用改，设不用修改的坐标为 $b_1, b_2..., b_m$，则我们应满足这下面两个柿子：

$$a_{b_1}<a_{b_2}<...<a_{b_m}$$

原意如此，不再解释。

$$\text{对于} \forall i<m, \text{满足} a_{b_{i+1}}-a_{b_i} \ge b_{i+1}-b_i$$

移项后得 

$$ a_{b_{i+1}}-b_{i+1} \ge a_{b_i}-b_i $$

令 $c_i=a_i-i$ 得

$$c_{b_{i+1}} \ge c_{b_i}$$

这恰好是不下降子序列的定义。

而我们对于最长不下降子序列的求法，已经有 $O(nlogn)$ 的解法，至此，本题得到完美解决。

### Code

```cpp
#include <stdio.h>
#include <algorithm>
#include <vector>
#define N 100005
using namespace std;
inline int read(){
	char ch;int x=0, f=1;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int G[N][2];
int tot, n, s[N], a[N];
void dfs(int pos){
	if(!pos) return ;
	dfs(G[pos][0]);
	a[++tot]=s[pos];
	dfs(G[pos][1]);
}
int d[N];
int main(){
	n=read();
	for(int i=1; i<=n; i++) s[i]=read();
	for(int i=2; i<=n; i++) G[read()][read()]=i;
	dfs(1);
	for(int i=1; i<=n; i++) a[i]-=i;
	int len=1;d[1]=a[1];
	for(int i=2, j; i<=n; i++){
		if(a[i]>=d[len]) d[++len]=a[i];
		else
			j=(upper_bound(d+1, d+len+1, a[i])-d), d[j]=min(d[j], a[i]);
	}
	printf("%d", n-len);
	return 0;
}
```


---

## 作者：liangbowen (赞：1)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P3365)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17083677.html)

一道个人感觉非常妙的题目，想了半天都想不到，但是听老师一句话就悟了！

## 思路

**本题关键：二叉搜索树，等价于这棵树中序遍历下** $a_i$ **单调不降**。

那么这题不就做完了吗。首先跑中序遍历，把一整个 $a_i$ 求出来。

然后用一个常见的 trick：$a_i \leftarrow a_i - i$ 就能把单调不降转化为严格单调上升（$\le$ 变成 $<$）。

最后根据 P3902 的结论，修改的次数等于 $n - \operatorname{LIS}(a)$。

所以直接上 $O(n \log n)$ 求 LIS 的有关算法即可。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int val[N], l[N], r[N], a[N], cur;
void dfs(int x) //求中序遍历
{
	if (!x) return;
	dfs(l[x]), cur++, a[cur] = val[x] - cur, dfs(r[x]);
}
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	for (int i = 2; i <= n; i++)
	{
		int fa, ch;
		scanf("%d%d", &fa, &ch);
		if (!fa) continue;
		if (ch == 0) l[fa] = i; else r[fa] = i; //按照题目怪异的读入方式存边
	}
	dfs(1);
	
	vector <int> dp; //n log n 求 LIS
	for (int i = 1; i <= n; i++)
		if (i == 1) dp.push_back(a[i]);
		else
		{
			int pos = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();
			if (pos >= (int)dp.size()) dp.push_back(a[i]); else dp[pos] = a[i];
		}
	cout << n - (int)dp.size(); //答案即为 n - LIS
	return 0;
}
```

---

## 作者：SoyTony (赞：1)

# 题意
求使一个二叉树通过修改点权的方式成为二叉搜索（排序）树的最少修改次数。

二叉搜索树指对于任意节点 $u$ 以及其左右儿子 $v_1,v_2$，满足 $val(v_1)<val(u)<val(v_2)$。

对平衡树有一定了解的话，就知道平衡树实际是在维护一个**中序遍历**不变的，深度接近 $\log n$ 的二叉搜索树。

# 分析
因此，本题要求的是，一个数列 $A$ (指这棵二叉树的中序遍历），修改成一个单调上升序列的最少次数。

显然直接求 $\operatorname{LIS}$ 再进行一系列操作时错误的，例如 $A=\{3,5,4\}$ 时，显然不能只修改 $5$。抽象的讲，就是映射成的 $A$ 数列的每个区间不保证值域大于等于定义域。

设 $f_i$ 表示前 $i$ 位无需改变的数量，发现当且仅当 $ val_i-val_j\ge i-j$ 时，$f_i$ 可以由 $f_j$ 转移。

把这个条件移项，就有 $val_i-i\ge val_j-j$，于是处理出一个数组表示 $val_i-i$，因为转移次数等于最后的结果，所以要这个转移次数最大，也就是这个数组的最长不降子序列，当然不要忘了结果用 $n$ 减去。

# 实现
这里不能用朴素的求 $\operatorname{LIS}$，需要带二分的 $O(n\log n)$ 算法（用 $\operatorname{STL}$ 中自带的查找也可）。
```cpp
int n,len;
int val[maxn],a[maxn],tot;
int tr[maxn][2];
inline void dfs(int u){
	if(tr[u][0]) dfs(tr[u][0]);
	a[++tot]=val[u];
	if(tr[u][1]) dfs(tr[u][1]);
}
int f[maxn],g[maxn];
inline int get(int x){
	int l=1,r=len;
	int res=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(g[mid]<=x){
			res=mid;
			l=mid+1;
		}
		else{
			r=mid-1;
		}
	}
	return res;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		val[i]=read();
	}
	for(int i=2;i<=n;i++){
		int fa=read(),ch=read();
		tr[fa][ch]=i;
	}
	dfs(1);
	for(int i=1;i<=n;i++){
		a[i]-=i;
	}
	for(int i=1;i<=n;i++){
		f[i]=get(a[i])+1;
		g[f[i]]=a[i];
		len=max(len,f[i]);
	}
	printf("%d\n",n-len);
	return 0;
}
```

---

## 作者：abc123_abc123 (赞：1)

首先我们手膜一遍可以发现，树的结构与答案无关，所以我们可以遍历出一个数组来算。看了看题面，发现它要求的是中序遍历（二叉排序树好评）。

然后我们中序遍历：

```cpp
struct node{
	int c[2],val;		//两个儿子和自己的值
}a[100010];
struct nd{
	int val,num,z;
	bool operator < (nd x)const{
		return val<x.val;
	}
}b[100010];
inline void dfs(int now)
{
	if(a[now].c[0]!=0)dfs(a[now].c[0]);
	b[++len].val=a[now].val;
	b[len].num=len;		//记录编号，后面有用
	if(a[now].c[1]!=0)dfs(a[now].c[1]);
}
```

接下来我们得到b数组，发现是求最小修改次数使序列升序，那就是n-最长上升子序列长？

我不会最长上升子序列，于是手膜吧。

离散+线段树走起来，详见代码：

```
//蒟蒻的做法
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
int c[400010];
inline void pt(int now,int l,int r,int lr,int xt)
{
	if(l==r){
		c[now]=maxs(c[now],xt);
		return;
	}
	int lc=now<<1,md=l+r>>1;
	if(lr<=md)pt(lc,l,md,lr,xt);
	else pt(lc+1,md+1,r,lr,xt);
	c[now]=maxs(c[lc],c[lc+1]);
}
inline int gt(int now,int l,int r,int ll,int rr)
{
	if(rr<ll)return 0;
	if(l==ll&&r==rr)return c[now];
	int lc=now<<1,md=l+r>>1;
	if(rr<=md)return gt(lc,l,md,ll,rr);
	if(md<ll)return gt(lc+1,md+1,r,ll,rr);
	return maxs(gt(lc,l,md,ll,md),gt(lc+1,md+1,r,md+1,rr));
}
//...
struct nd{
	int val,num,z;
	bool operator < (nd x)const{
		return val<x.val;
	}
}b[100010];
int d[100010];
//...
int main()
{
    //...
	sort(b+1,b+1+n);		//记得调用algorithm
	b[1].z=u1=1;
	for(i=2;i<=n;i++)
	{
		if(b[i].val!=b[i-1].val)u1++;
		b[i].z=u1;
	}
	for(i=1;i<=n;i++)
	d[b[i].num]=b[i].z;
    //于是我们把离散后的值存在了d里，最大值为u1
    for(i=1;i<=n;i++)
	{
		u2=gt(1,1,u1,1,d[i]-1)+1;	//得到比d[i]小的值中 已有序列长度最长 的值
       	//然后加上自己的1
		if(ans<u2)ans=u2;
		pt(1,1,u1,d[i],u2);			//更新ans，把自己放进线段树里
	}
    //...
```

然后我们把代码搞出来是长这样的：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
int c[400010];
inline void pt(int now,int l,int r,int lr,int xt)
{
	if(l==r){
		c[now]=maxs(c[now],xt);
		return;
	}
	int lc=now<<1,md=l+r>>1;
	if(lr<=md)pt(lc,l,md,lr,xt);
	else pt(lc+1,md+1,r,lr,xt);
	c[now]=maxs(c[lc],c[lc+1]);
}
inline int gt(int now,int l,int r,int ll,int rr)
{
	if(rr<ll)return 0;
	if(l==ll&&r==rr)return c[now];
	int lc=now<<1,md=l+r>>1;
	if(rr<=md)return gt(lc,l,md,ll,rr);
	if(md<ll)return gt(lc+1,md+1,r,ll,rr);
	return maxs(gt(lc,l,md,ll,md),gt(lc+1,md+1,r,md+1,rr));
}
struct node{
	int c[2],val;
}a[100010];
struct nd{
	int val,num,z;
	bool operator < (nd x)const{
		return val<x.val;
	}
}b[100010];
int n,i,u1,u2,len,d[100010],ans;
inline void dfs(int now)
{
	if(a[now].c[0]!=0)dfs(a[now].c[0]);
	b[++len].val=a[now].val;
	b[len].num=len;
	if(a[now].c[1]!=0)dfs(a[now].c[1]);
}
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i].val);
	for(i=2;i<=n;i++)
	{
		scanf("%d%d",&u1,&u2);
		a[u1].c[u2]=i;
	}
	dfs(1);
	sort(b+1,b+1+n);
	b[1].z=u1=1;
	for(i=2;i<=n;i++)
	{
		if(b[i].val!=b[i-1].val)u1++;
		b[i].z=u1;
	}
	for(i=1;i<=n;i++)
	d[b[i].num]=b[i].z;
	for(i=1;i<=n;i++)
	{
		u2=gt(1,1,u1,1,d[i]-1)+1;
		if(ans<u2)ans=u2;
		pt(1,1,u1,d[i],u2);
	}
	printf("%d",n-ans);
	return 0;
}
```

自信提交，发现WA了。

我们看看发生了什么：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vfm6dsp.png)

我们发现那个蓝圈里的3无法通过1次修改使自己能够放在3和4中间。

思考良久，发现我把每一个值都减去自己的下标，然后再算最长不降子序列好像就可以了，记得要在离散前减哦。

P.S.:我把最长不降子序列改成最长上升子序列也AC了，这是为什么？（数据太水？）

附上代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
int c[400010];
inline void pt(int now,int l,int r,int lr,int xt)
{
	if(l==r){
		c[now]=maxs(c[now],xt);
		return;
	}
	int lc=now<<1,md=l+r>>1;
	if(lr<=md)pt(lc,l,md,lr,xt);
	else pt(lc+1,md+1,r,lr,xt);
	c[now]=maxs(c[lc],c[lc+1]);
}
inline int gt(int now,int l,int r,int ll,int rr)
{
	if(rr<ll)return 0;
	if(l==ll&&r==rr)return c[now];
	int lc=now<<1,md=l+r>>1;
	if(rr<=md)return gt(lc,l,md,ll,rr);
	if(md<ll)return gt(lc+1,md+1,r,ll,rr);
	return maxs(gt(lc,l,md,ll,md),gt(lc+1,md+1,r,md+1,rr));
}
struct node{
	int c[2],val;
}a[100010];
struct nd{
	int val,num,z;
	bool operator < (nd x)const{
		return val<x.val;
	}
}b[100010];
int n,i,u1,u2,len,d[100010],ans;
inline void dfs(int now)
{
	if(a[now].c[0]!=0)dfs(a[now].c[0]);
	b[++len].val=a[now].val-len;
	b[len].num=len;
	if(a[now].c[1]!=0)dfs(a[now].c[1]);
}
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i].val);
	for(i=2;i<=n;i++)
	{
		scanf("%d%d",&u1,&u2);
		a[u1].c[u2]=i;
	}
	dfs(1);
	sort(b+1,b+1+n);
	b[1].z=u1=1;
	for(i=2;i<=n;i++)
	{
		if(b[i].val!=b[i-1].val)u1++;
		b[i].z=u1;
	}
	for(i=1;i<=n;i++)
	d[b[i].num]=b[i].z;
	for(i=1;i<=n;i++)
	{
		u2=gt(1,1,u1,1,d[i])+1;
		if(ans<u2)ans=u2;
		pt(1,1,u1,d[i],u2);
	}
	printf("%d",n-ans);
	return 0;
}
```


---

## 作者：Boeing737_MAX_8 (赞：1)

```
20191013修改：个人博客网址变更
```


同样欢迎来到[我的个人博客查看](https://officerbonin.home.blog/2019/08/19/%e3%80%90%e4%bf%a1%e7%ab%9e%e3%80%91luogup3365-%e6%94%b9%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91/)

本题被教练选作了模拟赛的第一题，~~结果我去死磕树形DP,噗....~~

考后[一位大佬](https://www.luogu.org/space/show?uid=88268)给我讲了本题的解法。

思想等同于本题[张亦弛给出的题解](https://www.luogu.org/blog/1557114139--com/solution-p3365)。

我发这篇题解，因为我使用的线段树优化的方式，但瞧见其他题解都是二分优化的，没有题解用这个方式。

修改后交题解没过，那就加点解释吧，见代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<climits>
#include<cmath>
#include<algorithm>
#include<map>
#include<vector>
#define maxn 100005
using namespace std;
int n;
struct node
{
	int lc,rc,fa;
} pot[maxn];
int a[maxn],b[maxn];
map<int,int>yst;
int qa[maxn],f[maxn];

struct segmenttree
{
	int l,r;
	int data;
} tr[100005*4];

void zsbl(int now)//中序遍历
{
//	cout<<now<<endl;
	if(pot[now].lc)
	{
		zsbl(pot[now].lc);
	}
//	cout<<now;
	qa[++qa[0]]=a[now];
	if(pot[now].rc)
	{
		zsbl(pot[now].rc);
	}
	return;
}

void build(int l,int r,int k)
{
	tr[k].l=l;
	tr[k].r=r;
	if(l==r)
	{
		tr[k].data=0;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,k*2);
	build(mid+1,r,k*2+1);
}
int ask(int l,int r,int k)
{
	if(!r)return 0;
	if(l<=tr[k].l&&tr[k].r<=r)return tr[k].data;
	if(r<tr[k].l||tr[k].r<l)return 0;
	return max(ask(l,r,k*2),ask(l,r,k*2+1));
}
void update(int x,int k,int id)
{
	if(tr[k].l==tr[k].r)
	{
		tr[k].data=max(tr[k].data,id);
		return;
	}
	int mid=(tr[k].l+tr[k].r)/2;
	if(x<=mid)update(x,k*2,id);
	else update(x,k*2+1,id);
	tr[k].data=max(tr[k*2].data,tr[k*2+1].data);
}

int main()
{
	int n;
	cin>>n;
	for(int i = 1; i <= n; i++)
	{
		scanf("%d",&a[i]);
	}
	int x,y;
	for(int i = 2; i <= n; i++)
	{
		scanf("%d%d",&x,&y);
		pot[i].fa=x;
		if(!y)
			pot[x].lc=i;
		else
			pot[x].rc=i;
	}
	zsbl(1);//中序遍历
	for(int i = 1; i <= n; i++)
	{
		qa[i]-=i;
		b[i]=qa[i];
	}
	sort(b+1,b+n+1);
	int cntb=unique(b+1,b+n+1)-b-1;
	for(int i = 1; i <= cntb; i++)
		yst[b[i]]=i;
	for(int i = 1; i <= n; i++)
		qa[i]=yst[qa[i]];
//上头都在读入和离散化
	int maxx=0;
	build(1,n,1);
/*
数组qa是二叉搜索树中序遍历展开并离散化后得到的序列，下简称q.

f的含义稍有不同，f[i]为以第q[i]个数结尾，前头都塞小于等于q[i]的数（保证序列单调递增）时最多能保留多少个数（就是能有多少个数不变。

所以,f[i]的最佳值当然是1~q[i]中最大的+1.实现查找区间内最大的并进行单点修改，当然线段树十分好用
*/
	for(int it = 1; it <= n; it++)
	{
		f[it]=ask(1,qa[it],1)+1;
		update(qa[it],1,f[it]);
		maxx=max(maxx,f[it]);
	}
	cout<<n-maxx;
}

```


---

## 作者：SSSF (赞：1)

题目求的是一颗二叉树改为二叉搜索树的最少步骤


因为二叉搜索树的中序遍历一定是一个由小到大的最长上升子序列


所以我们只需要中序遍历这颗二叉树


将他的中序遍历出的结点依次放入一个数组


然后求一遍最长上升子序列的长度，用总个数减去这个满足要求的长度，就得到了要修改的点数


但是由于题目中整数的限制，所以求最长不降而不是上升


提一点，最长不下降用lower——bound

最长上升用upper——bound 

减的是d的长度哦

最后如果有童鞋不会求lis（最长上升子序列），给你看一个大神博客哦，他讲的很清楚。你可以先看了，才知道为什么后面的那个for循环要这样写的哦！

[求最长上升、不降子序列](https://www.cnblogs.com/itlqs/p/5743114.html)

美美哒代码送给你，请接收！

```cpp
#include <iostream>
#include <cstdio>
const int maxn=500100;
using namespace std;
struct NODE{
	int key,lc,rc;
}node[maxn];
int shuzu[maxn],d[maxn];
int n,a,b,k;
void midsearch(int u){
	if(node[u].lc)midsearch(node[u].lc);
	//这一步是为什么？
	//因为当i到j是递增，他们值也是递增的情况时，因为i到j的值差一定要大于等于i到j的下标差，不然怎么递增啊？即aj-ai>=j-i,即aj-j>=ai-i，
	//这样我们再去求lis 
	shuzu[++k]=node[u].key-k;//k是点依次进入数组的编号，中序遍历的顺序 
	if(node[u].rc)midsearch(node[u].rc);
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&node[i].key);
	}
	for(int i=2;i<=n;i++){//大家输入搞对了嘛？第一个数是节点，后一个数是说i是他的什么儿子，所以i从2开始好些 
		scanf("%d%d",&a,&b);
		if(b){
			node[a].rc=i;
		}
		else node[a].lc=i;
	}
	midsearch(1);
	d[1]=shuzu[1];
	int len=1;
	for(int i=2;i<=n;i++){
		if(shuzu[i]>=d[len]){
			d[++len]=shuzu[i];
		}
		else{
			int j=lower_bound(d+1,d+1+len,shuzu[i])-d;//减去d的长度你减了吗？ 
			d[j]=shuzu[i]; 
		}
	}
	printf("%d",n-len);
	return 0;
}
```


---

## 作者：ListenSnow (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P3365 "原题链接")

## 题意

给定一颗二叉树，每次操作可以修改一个点的权值为任意**整数**，求将原树变为二叉搜索树的最小操作次数。

注意：本题中的二叉搜索树定义为：每个左边儿子的权值都**严格小于**中间儿子,每个右边儿子的权值都**严格大于**中间儿子。

$1 \leq n \leq 10^5$。

## 思路：

在本题中，一棵二叉树为二叉搜索树的充要条件为：该二叉树的中序遍历权值**严格单调递增**。

先求出这棵树的中序遍历。由于点的权值只能修改为整数，直接求 $\mathrm{LIS} $ 无法解决有连续若干个相同整数的情况。

设中序遍历的第 $i$ 个点权值为 $w_i$。令 $w_i \longleftarrow w_i-i$，那么就可以将严格单调递增转化为非严格单调递增，于是最终的答案就是 $n-\mathrm{LIS} (a)$。

## code：

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
int a[N],ch[N][2],q[N],tot,n,f[N],len;
void dfs(int u)
{
	if(!u) return ;dfs(ch[u][0]);tot++;q[tot]=a[u]-tot;dfs(ch[u][1]);
}
int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=2;i<=n;i++)
	{
		int fa,op;scanf("%d%d",&fa,&op);ch[fa][op]=i;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
	{
		if(q[i]>f[len]) f[++len]=q[i];
		else
		{
			int k=upper_bound(f+1,f+len+1,q[i])-f;
			f[k]=q[i];
		}
	}
	printf("%d\n",n-len);
	return 0;
}
```

---

## 作者：Hongse_Fox (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P3365)

# 零.前记
板子写什么函数名题目中就写什么函数名

~~一个小细节写错函数名卡了半小时就离谱~~

# 一.大体思路
大家对二叉查找树多多少少都有所了解（我是在学可并堆的时候学的

其实说白了就是一个点$i$满足$:$

$1.$左子树上每个点$j$都满足$a_i>a_j$

$2.$右子树上每个点$j$都满足$a_i<a_j$

因此可以知道一个二叉查找树的中序遍历是单调递增的

换言之我们把题目给的二叉查找树中序遍历后

要求的就是把序列改成单调递增的最小次数

既然如此我们就可以想到大体做法就是$LIS$

# 二.实现细节

### 预处理

题目中强制修改后的数为整数

即任意$i,j\in[1,n],i<j$满足$a_i-a_j>=i-j$

否则里面就装不下嘛

因此移一下项$:$

任意$a_i-i>=a_j-j$

**所以最终的结果就是序列满足$a_i-i$单调不下降**

注意是不下降而不是上升

把$a_i-i$与处理一下就可以做了

**code**
```
inline void search(int now){//中序遍历 
	if(son[now][0]) search(son[now][0]);
	a[++zz]=b[now];
	if(son[now][1]) search(son[now][1]);
	return ;
}
```


### 求$LIS$

这题如果用$n^2dp$的方法求$LIS$肯定会炸

因此我们可以用$n log n$的二分做法

当然我们用$STL$偷一下懒

不过在比赛场上 还是把卡常视作生命

# 三.代码
```
#include<cstdio>
#include<cctype>
const int maxn=100005;
inline int R(){
	int r=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r;
}
int n,a[maxn],son[maxn][2],b[maxn],zz,low[maxn],ans=1;
inline void search(int now){//中序遍历 
	if(son[now][0]) search(son[now][0]);
	a[++zz]=b[now];
	if(son[now][1]) search(son[now][1]);
	return ;
}
inline int g(int x){//二分x 
	int l=1,r=ans;
	while(l<r){
		int mid=(l+r)>>1;
		if(low[mid]<=x) l=mid+1;
		else r=mid;
	}
	return l-1;
}
int main(){
	n=R();
	for(register int i=1;i<=n;i++) b[i]=R();
	for(register int i=2;i<=n;i++){
		int fa=R(),opt=R();
		son[fa][opt]=i;
	}
	search(1);
	for(register int i=1;i<=n;i++) a[i]-=i;//每个点-i满足整数条件 
	low[1]=a[1];
	for(register int i=2;i<=n;i++){//求LIS 
		if(low[ans]<=a[i]) low[++ans]=a[i];//注意求的是不下降序列 
		else{
			int u=g(a[i]);
			low[u+1]=a[i];
		}
	}
	printf("%d\n",n-ans);//ans为最长长度 剩下的就是要修改的 
	return 0;
}
```
# 四.后记
当题目出现整数要求的时候

我们要想办法怎么把这个要求给干掉

像这道题当中把条件改成$a_i-a_j<=i-j$

从而通过改变数组把条件去掉

当然改变的时候注意一下边界条件 要不要取等

Finally，谢谢大家

[更好的阅读体验](https://www.luogu.com.cn/blog/HongseFox/solution-p3365)

---

## 作者：Gerald_Chen (赞：0)

二叉搜索树最重要的性质就是它的中序遍历结果是一个递增数列。  
现在设已经生成的中序遍历数列为$\{a_n\}(\forall i\in \mathbb{N^*,a_i<a_{i+1}})$。  
题目中有这么一句话：

	任意时刻结点的数值必须是整数

要能构造出一个全是整数的递增数列，该数列一定满足该性质：对于任意的$i,j\in \mathbb{N^*}$且$i<j$，都有$a_i+(j-i)\leq a_j$，即$a_i-i\leq a_j-j$。  
可以这么理解，两个数的差至少能够被位置差弥补起来。  
比如有这么个数列$\{1,7,8,4,9,5\}$，对于第1项和第4项来说，中间的第2项和第3项有位置用来填2和3，但对于第4项和第6项来说，差值为1，位置差为2，中间没有可以填的数。  
所以令$b_n=a_n-n$，$\{b_n\}$就是一个非降序列，用常规方法做最长非降子序列即可。  
希望能对不理解其他题解的同学有一点帮助。

---

## 作者：AmadeusSG (赞：0)

[博客食用](https://hackblogs.home.blog/2019/08/19/题解-p3365-【改造二叉树】/)


这道题30分的暴力是直接枚举i和j，这样会多一维。

但我们可以降维，改为枚举k，对于每次枚举，从k位置前后延伸，找到前面最

先 不 能 整 除 的地方，和后面 不 能 整 除 的地方，那这样一个序列一定是合法的，

所以直接更新答案即可。

代码：


```
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define re register
using namespace std;
ll n,tot;
ll ans;
ll a[100005];
struct Tree
{
	ll lc,rc;
	ll fa;
	ll val;
}t[200005];
ll dfn[1000005];
ll v[1000005];
ll dp[1000005];
ll cnt,len;
ll x,ch;
inline void dfs(ll x)
{
	if(!x)return;
	if(t[x].lc)dfs(t[x].lc);
	dfn[++tot]=a[x];
	if(t[x].rc)dfs(t[x].rc);
}
inline ll find(ll x)
{
	ll l=1,r=len,ans=0;
	while(l<=r)
	{
		ll mid=(l+r)>>1;
		if(v[mid]<=x)
		{
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	return ans;
}
int main()
{
	scanf("%lld",&n);
	for(re ll i=1;i<=n;++i)scanf("%lld",&a[i]);
	t[1].val=a[1];
	for(re ll i=2;i<=n;++i)
	{
		scanf("%lld%lld",&x,&ch);
		t[i].fa=x;
		if(ch==0)t[x].lc=i;
		else t[x].rc=i;
		t[i].val=a[i];
	}
	dfs(1);
	for(ll i=1;i<=n;++i)dfn[i]-=i;
	for(ll i=1;i<=n;++i)
	{
		dp[i]=find(dfn[i])+1;
		v[dp[i]]=dfn[i];
		len=max(len,dp[i]);
	}
	cout<<n-len;
	return 0;
}
```
**提后声明**：

这是我在网上发现的一个极其鬼畜的方法， _仅供娱乐_ （复杂度O(n^2),不用卡常...）。


（奉劝大家一句：还是要学习一下正解，太多歪门邪道对oj水平是没有提升的...）

---

## 作者：liuyifan (赞：0)

## 转载一个我们教练的题解

![](https://s2.ax1x.com/2019/08/19/mlwpef.png)
![](https://s2.ax1x.com/2019/08/19/mlw9w8.png)

---
附上本人丑陋code:
```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define reg register
#define ll long long
#define inf 0x3f3f3f3f
#define iinf 0x3f3f3f3f3f3f3f3fll
#define y1 liuyifan_y1
#define next liuyifan_next
using namespace std;
ll n,i,j,k,ans,cnt,son[500005][2],a[500005],b[500005],d[500005],len,fa,ch;
void dfs(reg ll x)
{
	if(x==0)return;
	dfs(son[x][0]);
	b[++cnt]=a[x];
	dfs(son[x][1]);
	return ;
}//求中序遍历
inline ll find(reg ll x)
{
	ll l=1,r=len,mid=0;
	while(l<=r)
	{
		mid=(l+r)/2;
		d[mid]>x?r=mid-1:l=mid+1;
	}
	return l;
}//二分
inline void lis()
{
	d[1]=b[1];
	len=1;
	for(reg ll i=2;i<=n;++i)
	{
		if(b[i]>=d[len])d[++len]=b[i];
		else
		{
			reg ll k=find(b[i]);
			d[k]=min(d[k],b[i]);
		}
	}
}//二分求LIS
int main()
{
	scanf("%lld",&n);
	for(reg ll i=1;i<=n;++i)scanf("%lld",&a[i]);
	for(reg ll i=2;i<=n;++i)
	{
		scanf("%lld%lld",&fa,&ch);
		son[fa][ch]=i;
	}
	dfs(1);
	for(reg ll i=1;i<=n;++i)b[i]-=i;//一种很好的处理方式,值得借鉴
	lis();
	printf("%lld\n",n-len);
	return 0;
}
/*
3
2 2 2
1 0
1 1
*/
/*
7
4 2 6 1 3 5 7
1 0
1 1
2 0
2 1
3 0
3 1
*/
```


---


# 妖精大战争

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/4726.png) 

琪露诺一如既往忙碌地生活着。

某天，在外出时她的家被人破坏了。

损坏的家插着一面奇怪的旗。

旗上画着似曾相识的几个妖精的图案。

狂怒的琪露诺对旗的主人贴出了宣战告示。

就这样，妖精们的大战争开始了。

(摘自《妖精大战争》manual)


## 题目描述

三月精 Sunny Milk, Lunar Child, Star Sapphire 为了让冰之妖精琪露诺加入她们的恶作剧计划，破坏了琪露诺的房子。琪露诺当然不会就此罢休，于是她找到了三月精准备进行复仇，复仇的方式是进行一场弹幕对决。 在Normal 难度下，Star Sapphire 在此次对战中不会出场，因此只有 Sunny Milk, Lunar Child两只妖精出场和琪露诺对决了。

在一张符卡中，Sunny Milk 和 Lunar Child 发射的弹幕几乎填满了整个 $100\times 100$ 的正方形战斗场地，并且恰好可以被一条静止不动，非垂直的直线划分成两部分，其中直线上方的部分是 Sunny Milk 发射的日光弹幕，直线下方的部分是 Lunar Child 发射的月光弹幕。

琪露诺是最强的妖精，但她面对两只妖精密集的弹幕也会有些紧张。在她的干劲快要被消磨完时，琪露诺忽然发现，如果能用两种不同的策略来对付两种弹幕，获胜的希望将会大大增加。因此，她想知道一些关键的位置会出现什么弹幕。

不幸的是，琪露诺无法判断出分界线在哪里，她只知道当前在战斗场地中每个弹幕的位置，和这个弹幕是月光弹幕还是日光弹幕。在极少情况下(至多 $0.1\%$)，琪露诺可能会错误识别弹幕的类型，因为它们实在太像了。琪露诺想要了解的是，对于接下来可能出现弹幕的位置，如果出现了弹幕，它是月光弹幕还是日光弹幕。你能帮帮她吗？


## 说明/提示

【样例解释】

注：该数据因量过小，信息量不足而不合法，可能会发生无法得到准确答案的情况。因此仅供理解题意使用，不可用来测试程序。

观察输入数据，我们发现当 $y=3$ 时，都是月光弹幕 $,y=4$ 时，都是日光弹幕。可以猜想直线在 $y=3 \sim y=4$ 之间。

因此对于四个询问分别回答 $1,-1,1,-1$。

【数据范围和提示】

单个弹幕的面积可视为 $0$。

若询问的位置恰好落在分界线上，当做在分界线的下方处理。

本题有 SpecialJudge。

- 对于第 $1$ 个测试点：

$N=100000$，$m=100000$。

若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $30\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。

- 对于第 $2 \sim 5$ 个测试点：

$n=1000$，$m=1000$。

若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $60\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。

- 对于第 $6 \sim 7$ 个测试点，

$n=100000$，$m=100000$。

若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $70\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。

- 对于第 $8 \sim 10$ 个测试点，

$n=100000$，$m=100000$。

若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $80\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。

- 对于 $100\%$ 的数据：

$0.000 \le x,y \le 100.000$。

所有输入的实数均保留 $3$ 位小数。

保证输入数据有合法的解能够满足题目要求的判定准确率。

评测时限：对于测试点 $2 \sim 5,$ 时限为 $1s$，其他测试点时限为 $2s$。

## 样例 #1

### 输入

```
4 4 0
3.000 4.000 1
3.000 3.000 -1
8.000 3.000 -1
8.000 4.000 1
100.000 100.000
0.000 0.000
3.141 5.926
0.618 1.618```

### 输出

```
1
-1
1
-1```

# 题解

## 作者：封禁用户 (赞：6)

题解区在写什么啊？

每次均匀随机生成定点 $(x,y)$ 和倾斜角 $\theta$，暴力找最优解。

该做法的正确率可以稳定在 $98\%$ 以上。

相比之下，模拟退火甚至不能稳定 AC。

**AC Code：**

```cpp
#include <bits/stdc++.h>
using namespace std;
double x[100012],y[100012];
int z[100012];
int check(int n,double dk,double db)
{
    dk=tan(dk);
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(y[i]>dk*x[i]+db&&z[i]==1) ans++;
        if(y[i]<=dk*x[i]+db&&z[i]==-1) ans++;
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(0);
    srand(time(0));
    int n,m,k;
    cin>>n>>m>>k;
    double bk=1,bb=0;
    int bm=0;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i]>>z[i];
    for(int i=n;i<=100000000;i+=n)
    {
        double dk=rand()*1000000.0/RAND_MAX;
        double dx=rand()*100.0/RAND_MAX;
        double dy=rand()*100.0/RAND_MAX;
        double db=dy-dx*tan(dk);
        int dm=check(n,dk,db);
        if(dm>bm) bm=dm,bk=dk,bb=db;
    }
    int et=100000000*(1.9/(clock()*1.0/CLOCKS_PER_SEC));
    if(k>=2&&k<=5) et=100000000*(0.95/(clock()*1.0/CLOCKS_PER_SEC));
    for(int i=100000000;i<=et;i+=n)
    {
        double dk=rand()*1000000.0/RAND_MAX;
        double dx=rand()*100.0/RAND_MAX;
        double dy=rand()*100.0/RAND_MAX;
        double db=dy-dx*tan(dk);
        int dm=check(n,dk,db);
        if(dm>bm) bm=dm,bk=dk,bb=db;
    }
    bk=tan(bk);
    for(int i=1;i<=m;i++)
    {
        double x,y;
        cin>>x>>y;
        if(y>bk*x+bb) puts("1");
        else puts("-1");
    }
    return 0;
}
```

---

## 作者：fbhou (赞：5)

## 本题正解：~~只有一个结点的~~神经网络

背景：本蒟蒻一直想出这样一道神经网络的基础练习题，一直没有想到好的形式。

某一天同机房的大佬刚刚通了天空璋normal，甩给我一堆背景是幻想乡的题目链接，翻着翻着就发现了这道，当时眼前一亮，决定把NOIP前宝贵的时间浪费几天在这道题上。

~~（考了血赚，没考不亏）~~

#### 不懂神经网络的同学看[这里](https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460)

#### 3B1B的讲解视频可以看[这里](https://www.bilibili.com/video/av15532370)，对神经网络入门选手~~（比如我）~~可以说非常有帮助

虽然都是神经网络，~~而且都只有一层一个结点（虽然更多的层数也没用）~~但这里的思路和出题人@orangebird 巨佬的官方题解还是有一些差别的。

首先是训练数据使用的问题，官方题解相当于对于每条数据只处理了一次，而下面的代码有可能会多次使用某些数据（对于$n=100000$的档平均每条信息会使用42次），从而提升训练效果。

其次，官方题解每次进化只使用一条信息，准确度欠佳，因此可以考虑将信息离线，每次随机扰动两个系数（$kx, ky$）和偏置$bias$后随机调用多条（这里是700条）信息执行，并通过估价函数（这里是判断错误的次数）判断本次随机扰动的“好坏”。如果这次扰动“好”，也即能使估价函数值降低，则向同一方向再跨一步；如果“不好”，或者说能使估价函数值升高，则撤销这一步（后来尝试过向反方向跨两步，但实际效果不佳）。

经过**反复**（前后调了不下30次）选取

- “随机变异”幅度（太小容易收敛到局部最优解[（血案，#5单点正确率创新低）](https://www.luogu.org/record/show?rid=11816993)，太大找不到最优解）

- 额外步数（太少训练效果不好，太多容易跳过最优解）

- 训练次数（太少相当于没训练，太多会TLE~~这就是为什么我吸了氧还是比最优解倒数第二慢两倍多~~）

- 单次训练集容量（太小有失普遍性，太大会TLE，再大相当于没有随机）

等各项参数[之后](https://www.luogu.org/record/show?rid=11817095)，这个神（yī）经（cì）网（hán）络（shù）的正确率还是相当可观的（并不）。除#3、#8两个点（目测多半是不幸收进了局部最优解，分别是93%和95%）之外，其他点的正确率均在99.2%以上，最高的#6达到了99.91%~~错误率已经小于了输入数据的噪声率~~。

~~咱家神经网络真聪明~~

#### 话不多说，上代码（C++）：
```cpp
// luogu-judger-enable-o2
//不加O2要T我有什么办法QAQ 
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
int n,m,k,a[maxn];//n,m,k同题目描述，a数组记录每一条信息的k值
double px,py;//神经网络每一次运行的输入
double kx,ky,bias,_out;//前两个是神经网络前两个参数的正切值（取正切目的是使系数调整更平滑），bias是偏置，_out存放运行结果
double x[maxn],y[maxn];//弹幕坐标信息
double dx,dy,db;//三个参数的随机增量
inline double sigmoid(double x){//视频里提到的sigmoid函数（虽然这里没有什么卵用）
    return 1.0/(1.0+exp(-x));
}
inline void work(){//神经网络单次工作，运算结果存放在_out，_out>0则为日光弹幕，否则为月光弹幕
    _out=atan2(kx,1.0)*px+atan2(ky,1.0)*py+bias;
}
inline int cost(){//估价函数，核心代码
    int c=0,ch;//c用于累加估价函数值，ch存放每一次训练数据的编号
    for(register int i=1;i<=700;i++){
        ch=rand()%n+1;//每次训练从原信息中随机选取700条
        px=x[ch]-50.0;py=y[ch]-50.0;//把坐标原点放到游戏区域中央
        work();
        if(a[ch]*_out<0) c++;//运算结果错误
    }
    return c;
}
int main(){
    srand(time(0));//种子是个人习惯
    kx=(rand()-1073000000)/1000000000.0;
    ky=(rand()-1073000000)/1000000000.0;
    bias=(rand()-1073000000)/1000000000.0;//初始扰动
    scanf("%d%d%d",&n,&m,&k);
    for(register int i=1;i<=n;i++){
        scanf("%lf%lf%d",&x[i],&y[i],&a[i]);
    }
    for(register int i=1;i<=6000;i++){
    	dx=(rand()-1073000000)/2000000000.0;
    	dy=(rand()-1073000000)/2000000000.0;
    	db=(rand()-1073000000)/2000000000.0;//随机扰动
    	int c1=cost();//先计算扰动前的估价函数值
    	kx+=dx;ky+=dy;bias+=db;
    	int c2=cost();//考虑扰动后的估价函数值
    	if(c2>c1){
    		kx-=dx;ky-=dy;bias-=db;//如果扰动“不好”
    	}
    	else{
    		kx+=dx;ky+=dy;bias+=db;//“好”
    	}
    }
    for(register int i=1;i<=m;i++){
        scanf("%lf%lf",&px,&py);
        px-=50.0;py-=50.0;//原因同上
        work();
        if(_out>0) printf("1\n");
        else printf("-1\n");
    }
    return 0;
}
```

> 自分は弱いだから、これ以上は出来ないです。いい最適化があれば、僕に教えてください！

---

## 作者：orangebird (赞：4)

题意是拟合一条直线来区分点的颜色

这波分送的厉害啊，直接输出1就能得30分

然后还可以乱搞，提供两个方法(我没亲自试过，不确定是否能过)

1.别人给的思路，用半平面交。不过有噪点，我也不知道有没有效果。

2.分块，来一个点就加入对应的块，对所有的询问看块内哪种颜色的点更多。


那么正解呢？

神经网络，机器学习= =

好吧，不需要神经网络，只要一个神经元就行了。

其实就是一道模板题，训练一个感知器，调调参数就能过。

下面是详细做法:

建立这样一个模型，3个输入x,y,bias，1个输出，输入作为参数传到一个函数里得到输出。

bias是常数1，在后面计算中可以省略。其他两个通过读入读进来即可。

然后给每个输入都赋一个随机权值wx,wy,wb，-1~1之间的浮点数。


对于每组读入数据x,y。

输出值out=(wx\*x+wy\*y+wb)>=0?1:-1

设正确答案为k，误差为error

那么error=k-out

然后更新三个权值

wx=wx+error\*x\*learnconst

wy=wy+error\*y\*learnconst

wb=wb+error\*learnconst

这样处理完所有数据，就训练完成了。

对于每组询问，输出out，就可以得到高概率正确的答案了。

需要调的参数是learnconst，这个多试几次看看哪个效果好就行，识别率大约90%。


嗯，然后某天我突发奇想就试了一下乱搞法2

大数据识别率大于99%......好吧，乱搞法2才是正解，感知器那段就当哈哈一笑了

两段代码，首先是本来的"正解"，感知器。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int n,m;
const float bias=1.0;//偏置量 
float learn;//学习常数 
float wx,wy,wbias;//权重 
float randlf3()//3位随机小数 
{
    return (float)(rand()%1000)/1000.0;
}
//获得结果 
int result(float x,float y)
{
    float res=x*wx+y*wy+bias*wbias;
    if(res>0)return 1;
    return -1;
}
//感知器训练 
void train(float x,float y,float k)
{
    float res=result(x,y);
    float error=k-res;
    wx=wx+error*x*learn;
    wy=wy+error*y*learn;
    wbias=wbias+error*bias*learn;
    //cout<<wx<<" "<<wy<<" "<<wbias<<endl;
}
int main()
{
    srand(233);
    ios::sync_with_stdio(false); 
    wbias=randlf3()*2.0-1.0;
    wx=randlf3()*2.0-1.0;
    wy=randlf3()*2.0-1.0;
    int cas=0;
    scanf("%d %d %d",&n,&m,&cas);
    if(n==1000)learn=0.9;
    else learn=0.0005;
    for(int i=1;i<=n;++i)
    {
        float x,y;
        int k;
        scanf("%f %f %d",&x,&y,&k);
        train(x,y,k);
    }
    for(int i=1;i<=m;++i)
    {
        float x,y;
        scanf("%f %f",&x,&y);
        printf("%d\n",result(x,y));
    }
    return 0;
}
```
然后是乱搞法2,代码更短。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,k;
int sunny[233][233];
int lunar[233][233];
double len=1.0;
double x,y;int t;
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    if(n<=1000)len=8.0;
    for(int i=1;i<=n;++i)
    {
        scanf("%lf%lf%d",&x,&y,&t);
        if(t==1)sunny[(int)(x/len)][(int)(y/len)]++;
        else lunar[(int)(x/len)][(int)(y/len)]++;
    }
    for(int i=1;i<=m;++i)
    {
        scanf("%lf%lf",&x,&y);
        if(sunny[(int)(x/len)][(int)(y/len)]>=lunar[(int)(x/len)][(int)(y/len)])
            printf("1\n");
        else printf("-1\n");
    }
    return 0;
}
```

---

## 作者：Little_Ming (赞：1)


我看了看题解，发现都是神经网络，弄不懂啊QAQ

所以这是个乱搞做法qwq

我们考虑如果一个点如果离同种点距离近，那么它就更可能属于这种点。

对于每个询问点$Q$，随机挑出$X$个点，其中每个点$P$会为它所属种类贡献 $|PQ|^{-2}$ 的权重。取距离平方的倒数是因为如果$P$太远，对答案没有帮助，应使其贡献迅速减小，这样就避免了很远的点产生干扰。

然后分别计算两种点权重的平均值，取更大的那个作为答案。

$X$的取值越大越好，但太大会**TLE**。我把它取作$5\times10^6/M$，把时间平分到每个询问。

当然这个做法应该很好卡……我也以为这个做法仅能拿到$40$或更低的分数。然而[**AC**](https://www.luogu.org/record/show?rid=13137558)了，大数据正确率在$94$%~$95$%之间。

奉上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100100;
const int M=500;//被X代替了
inline double sqr(double x){
	return x*x;
}
struct Pos{
	double x,y;
	int fg;
	Pos(){
	}
	Pos(double _x,double _y){
		x=_x,y=_y;
	}
	inline double operator %(const Pos o)const{//返回距离的平方
		return sqr(x-o.x)+sqr(y-o.y);
	}
}p[N];
int main(){
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int mm=5e6/m;//这个就是X
	for(int i=0;i<n;i++){
		scanf("%lf%lf%d",&p[i].x,&p[i].y,&p[i].fg);
	}
	for(int i=0;i<m;i++){
		Pos q;
		scanf("%lf%lf",&q.x,&q.y);
		int p1s=0,n1s=0;
		double p1w=0,n1w=0;
		for(int j=0;j<mm;j++){
			int id=(unsigned int)(rand()*RAND_MAX+rand())%n;
			if(p[id].fg==1){
				p1s++;
				p1w+=1/(q%p[id]);
			}else{
				n1s++;
				n1w+=1/(q%p[id]);
			}
		}
		q.fg=p1w*n1s>n1w*p1s?1:-1;//以乘代除，避免某一次有一种点一个都没选到而RE
		printf("%d\n",q.fg);
	}
	return 0;
}
```

最后%一发写了神经网络的大佬，代码比我跑得快得多，正确率也好得多。

**祝各位**`NOIP rp++`**！**

---


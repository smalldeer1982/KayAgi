# 拆分

## 题目描述

给定一个整数 $n$，求将 $n$ 分解为互不相同的不小于 $2$ 的整数的乘积的方案数。答案模 $998244353$。


## 说明/提示

样例中，因为

$688 = 2 \times 4 \times 86= 2 \times 8 \times 43= 2 \times 344= 4 \times 172= 8 \times 86= 16 \times 43$

所以答案为 $6$



对于 $10\%$ 的数据，保证 $n$ 为质数

对于 $20\%$ 的数据，保证 $2 \leq n \leq 10^4$

对于 $50\%$ 的数据，保证 $ 2  \leq n \leq 10^7$

对于 $100\%$ 的数据， 保证 $ 2 \leq n \leq 10^{12}$

所有数据满足 $1 \leq T \leq 5$


## 样例 #1

### 输入

```
1
688```

### 输出

```
6```

# 题解

## 作者：vegetabird (赞：19)

对于每一个N，我们先求出它的第$i$小因子$fac_{i}$, 然后记录下因子$j$所对应的位置$pos_{j}$。这里有一个小技巧：

##+$if$ $j \le \sqrt{N}$, 则令$pos1_{j}=pos_{j}$

##+$if$ $j > \sqrt{N}$, 则令$pos2_{\frac{N}{j}}=pos_{j}$

这样就可以把空间压缩为$O(\sqrt{N})$

然后令$dp_{ij}$为把$fac_{i}$分解成若干个小于等于$fac_{j}$的数（包括$1$）的积的方案总数，则：

#$dp_{ij}=dp_{i j-1}$

#$if$ $i=j$, $dp_{ij}++$

#$if$ $fac_{i} \equiv 0,mod( fac_{j})$, $dp_{ij}+=dp_{pos_{\frac{fac{i}}{fac_{j}}} j-1}$

CODE:
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<utility>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<set>
#include<iostream>
#include<map>
using namespace std;
long long T,n;
long long fac[11000];
int dp[11000][11000];
const long long mod=998244353;
int pos1[1000010],pos2[1000010];
map<long long,int>ans;
int main(){
    cin>>T;
    register int i,j,s;long long q;
    while(T--){
        cin>>n;
        if(ans[n]){
            cout<<ans[n]<<endl;
            continue;
        }
        s=0;
        q=sqrt(n);
        if(n%q==0){
            fac[++s]=q;
            if(q*q!=n){
                fac[++s]=n/q;
            }
        }
        for(i=1;i<q;i++){
            if(n%i==0){
                fac[++s]=i;
                fac[++s]=n/i;
            }
        }
        stable_sort(fac+1,fac+s+1);
        for(i=0;i<=s;i++){
            for(j=0;j<=s;j++){
                dp[i][j]=0;
            }
        }
        for(i=1;i<=s;i++){
            dp[i][i]=1;
            if(fac[i]<=q){
                pos1[fac[i]]=i;
            }else{
                pos2[n/fac[i]]=i;
            }
        }
        for(i=1;i<=s;i++){
            for(j=1;j<=s;j++){
                dp[i][j]+=dp[i][j-1];
                if(i<=j){
                    continue;
                }
                if(fac[i]%fac[j]==0){
                    long long tmp=fac[i]/fac[j];
                    if(tmp<=q){
                        dp[i][j]+=dp[pos1[tmp]][j-1];
                    }else{
                        dp[i][j]+=dp[pos2[n/tmp]][j-1];
                    }
                    dp[i][j]%=mod;
                }
            }
        }
        cout<<dp[s][s]-1<<endl;
        ans[n]=dp[s][s]-1;
    }
}
```

---

## 作者：WJiannan (赞：15)

动态规划：


首先定义一个数组 $f[i][j]$，表示当前乘积为 $i$，包含的最大的因数为 $j$ 时，方案数时多少。

这样可能可以得到 $20$ 分。

然后我们考虑优化，首先 $i$ 一定是 $n$ 的一个因数，$j$ 也同理。

于是我们可以把所有的因数预处理出来，有多少个呢？$\sqrt{n}$？


可以先来考虑一下另一道题，给定一个数 $n$，求 $n$ 以内的数因数最多的数的因数是多少？

这个问题可以用搜索，开一个 $60$ 以内的质数表，就解决了。


于是我们知道了，当 $n \le 10^{12}$ 时，因数的个数最多为 $6720$。

那这也太简单了吧！


转移的时候就只有 $6720 \times 6720$ 个状态了，你可以写一个 $\mathrm{Hash}$ 也可以根据单调性来扫（如下面的程序）。

复杂度 $O(45158400)$，bingo！

%zzx

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define R register
const int Mod = 998244353;
namespace Steaunk
{
    long long Ans, n, P[7010];
    int f[7010][7010], tot;
    void main()
    {
        tot = Ans = 0;
        memset(f, 0, sizeof(f));
        scanf("%lld", &n);
        for(R int i = 1; 1ll * i * i <= n; i++) 
        {
            if(n % i == 0) 
            {
                P[++tot] = i;
                if(n / i != i) P[++tot] = n / i;
            }
        }
        std::sort(P + 1, P + 1 + tot);
        P[tot + 1] = n * 5;
        f[1][1] = 1;
        for(R int i = 1; i <= tot; i++)
        {    
            R int l = i + 1;
            for(R int j = 1; j < tot; j++)
            {    
                if(f[i][j] == 0) continue;
                if(P[i] * P[j + 1] <= n) 
                {
                    while(P[l + 1] <= P[i] * P[j + 1]) l++;
                    if(P[l] == P[i] * P[j + 1]) (f[l][j + 1] += f[i][j]) %= Mod;
                }
                (f[i][j + 1] += f[i][j]) %= Mod;
            }
        }
        printf("%d\n", f[tot][tot] - 1);
    }
}
int main()
{
    R int T;
    scanf("%d", &T);
    while(T--) Steaunk::main();
    return 0;
}
```

---

## 作者：dayz_break404 (赞：9)

很妙的一道计数 dp 题。

~~根据数学直觉~~，我们可以感受到就算是一个很大的数，它的因数个数也是较小的。由于 $2\le n \le 10^{12}$，可以用程序分解质因数，发现在这个范围内的数的最大因数个数也不会超过 $10^4$。所以数组可以开一个二维的啦。

由于题目让我们计算方案数，可以用 dp 计算方案数。

考虑先将 $n$ 的因数记录下来并排序（因为之后我们是根据位置在前的数的乘积计算出位置在后的因数的值），得到序列 $a$。

记 $dp_{i,j}$ 表示 $n$ 的第 $i$ 个因数用 $n$ 的前 $j$ 个因数表示出来的方案数，$pos_{i}$ 为数字 $i$ 在因数序列 $a$ 中的位置下标。

当前的第 $j$ 个因数可以选，也可以不选，那么有 dp 方程：
$$dp_{i,j}=\begin{cases}dp_{i,j-1} ,a_{i}\nmid a_{j} \\ dp_{i,j-1}+dp_{pos_{\frac{a_i}{a_j}},j},a_{i}\mid a_{j}\end{cases}$$

但是，这里会出现一个问题，由于本题值域很大，$pos$ 数组会溢出，我们可以将值域为 $1\sim n$ 的数分解为 $1\sim \sqrt{n}$ 和 $\sqrt{n}+1\sim n$ 的数，分为两个 $pos1$ 和 $pos2$ 数组存储下标。

由于要排除 $1\times n$ 的情况，所以最后的 $dp_{n,n}-1$ 即是答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e4+20;
const int maxm=2e6+20;
const int mod=998244353;
#define ll long long
ll t,idx;
ll a[maxn],dp[maxn][maxn],x,pos1[maxm],pos2[maxm];
ll n;
inline ll get(ll i,ll j){
	x=a[i]/a[j];
	ll k=(ll)(sqrt(n));
	if(x<=k) return pos1[x];
	else return pos2[n/x];
}
inline void solve(){
	idx=0;
	for(ll i=1;i<=n/i;i++){
		if(n%i==0) {
			a[++idx]=i;
			if(i!=n/i) a[++idx]=n/i;
		}
	}
	sort(a+1,a+idx+1);
	for(ll i=1;i<=(idx+1)/2;i++) pos1[a[i]]=i,pos2[a[i]]=idx-i+1;//记录下标
	for(ll i=1;i<=n;i++) dp[i][1]=(i==1);//初始状态
	for(ll i=1;i<=idx;i++){
		for(ll j=2;j<=idx;j++){
			dp[i][j]=dp[i][j-1];
			if(a[i]%a[j]==0) dp[i][j]=(dp[i][j]+dp[get(i,j)][j-1])%mod;
		}
	}
	printf("%lld\n",dp[idx][idx]-1);
}
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		solve();		
	}
	return 0;
}
```

---

## 作者：_HCl_ (赞：8)

你说的对，但是这个状态是真的想不到啊。

# P3861 题解

**题意简述**

求将 $n$ 分解为互不相同且不小于 $2$ 的若干个整数的乘积的方案数。

**思路引导**

考虑动态规划。设 $f(i,j)$ 表示将 $i$ 分解为若干个不大于 $j$ 的整数的方案数，其中 $i$ 和 $j$ 均为 $n$ 的因数。

不难列出转移方程：

$$f(i,j)=f(i,pre(j))+f(\frac{i}{j},pre(j))$$

其中 $pre(i)$ 是 $i$ 在 $n$ 的所有因数中的前驱。

答案即为 $f(n,n)-1$。因为分解成自己不算。

这个方程可以这么理解：

- 直接扩大因数的考虑范围，即直接继承 $f(i,pre(j))$ 的方案数。
- 乘上因数 $j$，即从 $f(\frac{i}{j},pre(j))$ 转移过来。

接下来考虑边界情况。显然有 $f(1,1)=1$ 和 $f(i,1)=0\ (i\neq1)$。因为 $1$ 可以分解为一个 $1$，但只有一个 $1$ 不可能乘出大于 $1$ 的数。


但是，数据范围是 $10^{12}$，考虑优化空间。由于 $i$ 和 $j$ 只可能是 $n$ 的约数，所以我们可以用一个 $i$ 在 $n$ 的因数序列（正序排列）中的位置来表示 $i$。这样 $pre(j)$ 也可以表示为 $j-1$ 了。

但是这样我们就需要去处理出 $\frac{i}{j}$ 在因数序列中的位置。我们可以用一个数组 $rcd$ 去记录。但这么搞数组显然开不下。

所以我们把它拆分乘两部分，$rcd1_x$ 记录 $x$ 在因数序列中的位置（负责 $[1,\sqrt(n)]$），$rcd2_x$ 记录 $\frac{n}{i}$ 在因数序列中的位置（负责 $(\sqrt(n),n]$）。这样空间就开的下了。

还有要注意的是，由于题目要求“不小于 $2$”，所以 $j$ 从 $2$ 开始跑。

**代码**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=998244353; 
int p[100001],rcd_1[2000001],rcd_2[2000001],f[10001][10001];
int tot,n;
int calc(int i,int j){//还原成位置 
	int tmp=p[i]/p[j];
	int zxj=(int)sqrt(n);//必须这么写，不然“就会爆炸” 
	if(tmp<=zxj)return rcd_1[tmp];
	else return rcd_2[n/tmp];
}
signed main(){
	int T;
	cin>>T;
	while(T--){
		tot=0;
		cin>>n;
		for(int i=1;i*i<=n;++i)
			if(n%i==0){
				p[++tot]=i;//因数序列 
				if(i*i!=n)p[++tot]=n/i;
			}
		sort(p+1,p+tot+1);//要排个序 
		for(int i=1;i<=(tot+1)/2;++i)rcd_1[p[i]]=i,rcd_2[p[i]]=tot-i+1;//记录位置 
		for(int i=1;i<=tot;++i){
			if(i==1)f[i][1]=1;
			else f[i][1]=0;
			for(int j=2;j<=tot;++j){//注意从2开始 
				f[i][j]=f[i][j-1];
				if(p[i]%p[j]==0)//整除才能搞 
					f[i][j]=(f[i][j]+f[calc(i,j)][j-1])%MOD;
			}
		}
		cout<<f[tot][tot]-1<<"\n";
	} 
}
```



---

## 作者：卷王 (赞：3)

题目很简洁，不解释了。

这是计数类问题，所以我们可以考虑 dp。

设 $dp_{i,j}$ 表示当前乘积为 $i$，包含的最大的因数为 $j$ 时的方案数。然后发现，这样会超时。但是根据题意，我们再设两个辅助数组 $pos_{i}$ 就可以解决。

这样的话，只需在记录 $n$ 的每一个因子后直接进行 dp 即可。


详细代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mod 998244353
typedef long long ll;
ll T, n, tot = 0, tmp, ok;
ll a[1000005];
int dp[7005][7005];
int pos[3][1000001];
int main()
{
	scanf("%ld", &T);
	while(T--)
	{
		scanf("%ld", &n);
		tot = 0;
		for(ll i = 1; i * i <= n; i++) //枚举 n 的所有因数 
			if(n % i == 0)
			{
				a[++tot] = i;
				if(i != n / i) a[++tot] = n / i;
			}
		sort(a + 1, a + tot + 1); //排序 
		for(int i = 1; (i << 1) <= tot + 1; i++) //记录pos 
		{
			pos[1][a[i]] = i;
			pos[2][a[i]] = tot - i + 1;
		}
		for(int i = 1; i <= tot; i++) //动态规划 
		{
			if(i == 1) dp[i][1] = 1; //初始化
			for(int j = 2; j <= tot; j++)
			{
				dp[i][j] = dp[i][j - 1];
				if(i < j) continue; //特判，请自行理解 
				if(a[i] % a[j] == 0) //转移 
				{
					tmp = a[i] / a[j];
					if(tmp <= (ll)sqrt(n)) ok = pos[1][tmp];
					else ok = pos[2][n / tmp]; //注意！不是pos[2][tmp]！ 
					dp[i][j] = (dp[i][j] + dp[ok][j - 1]) % mod;
				}
			}
		}
		printf("%d\n", dp[tot][tot] - 1); //需要去掉 1 * n 的情况，所以-1 
	}
	return 0;
}
```

---

## 作者：Allan_Xu (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3861)

- 首先，你要明白这是一道 dp 的题。

- 然后，如果你注意到了那巨大的数据范围，请你**暂时**忘掉它，后面再处理。

#### 正题：

1. 状态设计：设 $f_{i,j}$ 为 $x_i$ 分解成 $\le x_j$ 的数乘积的方案数。
2. 初始化：将 $f_{1,1} = 1$，因为 $1$ 的方案数只有 $1\times1$。
3. 状态转移 对于 $f_{i,j}$ 若 $x_i \nmid x_j$ , 那么有 $f_{i,j} = f_{i-1,j}$；若 $x_i \mid x_j$ 那么有 $f_{i,j} \gets f_{x_i/x_j,j-1}$
4. 整理得：$f_{i,j}=\begin{cases}f_{i-1,j} (x_i \nmid x_j) \\ f_{i,j} + f_{xi/xj,j-1} (x_i \mid x_j)\end{cases}$

#### 数据存储处理 （现在你可以记得巨大的数据范围了）：

因为 $n$ 的数据范围为 $n \le 10^{12}$，所以我们将其分为两块处理 $x_i$：第一块：$1 \sim \sqrt{n}$ ; 第二块；$\sqrt{n} + 1 \sim n$ , 分别存在数组 $pos1$ 和 $pos2$ 里，然后再加一个判断，如果大于 $\sqrt{n}$ 就访问 $pos2$，没有就访问 $pos1$。

#### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
inline long long read(){//快读
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int mod=998244353;
#define int long long
int p[100001],pos1[2000001],pos2[2000001],f[10001][10001];
int tot,n;
int calc(int i,int j){
	int tmp=p[i]/p[j];
	int zxj=(int)sqrt(n);
	if(tmp<=zxj)return pos1[tmp];
	else return pos2[n/tmp];
}
signed main(){
int t=read();
while(t--){
	tot=0;
	n=read();
	for(int i=1;i*i<=n;++i){
		if(n%i==0){
			p[++tot]=i;
			if(i*i!=n)p[++tot]=n/i;
		}
	}
	sort(p+1,p+1+tot);
	for(int i=1;i<=(tot+1)/2;++i)pos1[p[i]]=i,pos2[p[i]]=tot-i+1;
	f[1][1]=1;
	for(int i=1;i<=tot;++i){
		for(int j=2;j<=tot;j++){
			f[i][j]=f[i][j-1];
			if(p[i]%p[j]==0)f[i][j]=(f[i][j]+f[calc(i,j)][j-1])%mod;
		} 
	}
	cout << f[tot][tot]-1 << "\n";
}
	return 0;
}
```

#### 完结散花

---

## 作者：jr_inf (赞：2)

阅读了多遍 @WJiannan 的题解，还是有很多不理解的地方，翻新一下。

新奇 dp 题。

暴力地，令 $dp_{i,j}$ 为将 $i$ 拆分为任意个不大于 $j$ 的因数之积的方案数，则有 $dp_{i,j}=dp_{i,j-1}+\sum_{k|i}dp_{k,j-1}$。

发现对于任意对 $dp_{n,n}$ 有贡献的 $dp_{k,j-i}$ 都满足 $k|n$，考虑舍弃无用状态。

将 $n$ 升序分解因数得到序列 $p$。令 $dp_{i,j}$ 为将 $p_i$ 拆分为任意个不大于 $p_j$ 的因数之积的方案数，则有 $dp_{i,j}=dp_{i,j-1}+\sum_{p_k | p_i} dp_{k,j-1}$，相当于只选了一个 $p_j$ 或者不选的方案数之和。

具体到实现，枚举 $k$ 和 $j$，计算 $dp_{k,j}$ 对于 $dp_{i,j+1}$ 的贡献，其中 $i=p_k \times p_{j+1}$，发现 $k$ 不变时，$i$ 随 $j$ 增大而增大，在增大 $j$ 的同时维护 $i$ 可以节省时间。令 $m$ 为 $n$ 的因数个数，时间复杂度 $O(m^2)$，$m \leq 6720$ 足以通过此题。

code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int N=7000+10,mod=998244353;
int	t,n,p[N],dp[N][N],qp;
signed main()
{
	scanf("%d",&t);
	while(t--)
	{
		qp=0;
		memset(dp,0,sizeof(dp));
		scanf("%lld",&n);
		for(int i=1;i*i<=n;i++)
		{
			if(n%i==0)
			{
				qp++,p[qp]=i;
				if(n/i!=i)qp++,p[qp]=n/i;
			}
		}
		sort(p+1,p+1+qp);
		p[qp+1]=n*4;
		dp[1][1]=1;
		for(int k=1;k<=qp;k++)
		{
			int i=k+1;
			for(int j=2;j<=qp;j++)//按照上文，这里代表 j+1
			{
				if(p[j]*p[k]<=n)
				{
					while(p[i+1]<=p[j]*p[k])i++;
					if(p[i]==p[j]*p[k])dp[i][j]=(dp[i][j]+dp[k][j-1])%mod;
				}
				dp[k][j]=(dp[k][j]+dp[k][j-1])%mod;
			}
		}
		printf("%lld\n",dp[qp][qp]-1);
	}
}

```


---

## 作者：dutianchen1 (赞：1)

# P3861 拆分
题意较明显，翻译略
### 思路简析

对于 $10$ 分的情况，显然质数在本题要求下，方案数为 $0$。

对于部分分的情况，我们考虑将 $n$ 的所有因数算出来，进行搜索求解。

在搜索的过程中，我们会发现，我们求解的 $n$ 的方案数，并不会影响 $n$ 的因数的方案数（无后效性）。并且，每个大的因数的方案数也可以通过较小的因数计算得来。于是，我们考虑用计数类动态规划求解。

#### 动态规划状态：
表示用第 $1$ 到 $j$ 个因数表示第 $i$ 个因数的**方案数**。
#### 动态规划转移方程
$$
\left\{ \begin{matrix}
dp_{i,j}=dp_{i,j-1} \\
dp_{i,j}=dp_{i,j-1}+dp_{p,j-1} 
\end{matrix} \right.
$$

第一行表示**不用**第 $j$ 个因数的方案数。第二行表示**用**第 $j$ 个因数的方案数。其中第二行的 $p$ 表示第 $i$ 大的因数除掉第 $j$ 大的因数后剩下的因数所在位置。

大体思路就如上。详细的解释和注意事项可以看代码注释。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int M = 7e3+5;
const int mod = 998244353;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
ll T,n;
int pos[N][2];//分别存储 大小在1~sqrt(n)的因数 与 sqrt(n)~n的因数。  可以使得原本O(n)的存储空间压缩至 2*sqrt(n) 
ll num[N],cnt,tot;
int dp[M][M];//表示 用第1到j个因数表示第i个因数的方案数 
void get_num(ll x){
	for(ll i=1;i*i<=x;i++)
	{
		if(x%i==0) {
			num[++tot]=i;
			if(i*i!=x){
				num[++tot]=x/i;
			}
		}
	}
}
int main()
{
	T=read();
	while(T--){
		n=read();
		tot=0;
		get_num(n);
		sort(num+1,num+1+tot); 
		for(int i=1;2*i-1<=tot;i++)
		{
			pos[num[i]][0]=i;
			pos[num[i]][1]=tot-i+1;//分别存储 
		}
		for(int i=1;i<=tot;i++){
			dp[i][1]=(i==1)?1:0;//初始化 第一个因数是 1，可以用自己表示。其余的因数不可能只用第一个因数表示 
			for(int j=2;j<=tot;j++)
			{
				dp[i][j]=dp[i][j-1]; //不选第j个因数的方案数 
				if(num[i]%num[j]==0)
				{
					ll temp=num[i]/num[j];
					ll p=(temp<=(ll)sqrt(n))?pos[temp][0]:pos[n/temp][1];
					dp[i][j]+=dp[p][j-1],dp[i][j]%=mod;//选第j个因数的方案数 
				}
			}
		}
		cout<<dp[tot][tot]-1<<'\n';//排除掉用自己的方案 
	}
	
	return 0;
}


```

---

## 作者：GXZJQ (赞：1)

# P3861 拆分 题解

[题目链接](https://www.luogu.com.cn/problem/P3861)

## 题目大意

给定一个整数 $n$，求将 $n$ 分解为**互不相同**的不小于 $2$ 的数的乘积的方案数。

## 题目分析

我们先求出 $n$ 的所有约数 $x_1,x_2,x_3,···,x_{d(n)}$，设 $f_{i,j}$ 为把 $x_i$ 分解为若干个小于等于 $x_j$ 的数的乘积的方案数（包括 $x_i = 1 \times x_i$），记录 $pos_j$ 表示 $x_{pos_j} = j$。如果直接记录 $pos_j$，那么空间复杂度将会是 $\mathcal {O}(n)$，我们无法接受。但考虑当 $j \le \sqrt{n} $ 时，记录 $pos_{1,j}=pos_j$；当 $j >  \sqrt{n} $ 时，记录 $pos_{2,\frac{n}{j} } = pos_j$，就可以将空间复杂度降至 $\mathcal {O}(\sqrt{n} )$。

然后考虑 $f_{i,j}$ 的求法。首先是 $f$ 的初始化，当 $j=1$ 时，可以发现 $i=1$ 即 $x[i]=1$ 时 $f_{i,j}=1$，否则 $f_{i,j}=0$，因为只有 $1$ 可以表示成 $1 \times 1$。

接下来考虑 $f$ 的传递。首先考虑 $x_i$ 的分解中不包含 $x_j$ 的情况，那么就是把 $x_i$ 分解为若干个小于 $x_j$ 的数的乘积，也就是 $f_{i,j-1}$。然后考虑 $x_i$ 的分解中包含 $x_j$ 的情况，这种情况要求 $x_j\mid x_i$，那么接下来就要将 $\frac{x_i}{x_j}$ 分解为若干个小于 $x_j$ 的数的乘积，也就是 $f_{pos_{\frac{x_i}{x_j}},j-1}$。最后将二者相加即为答案。所以最终结果为 $f_{d(n),d(n)}-1$（$x_{d_n}=n$），记得要排除 $n=1 \times n$ 的情况。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 1000010;
int f[6721][6721], pos1[N], pos2[N], t, tot, pos;
long long x[N], n, sqrtn, tmp;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> n;
		tot = 0, sqrtn = (long long) sqrt(n);
		for (long long i = 1; i * i <= n; i++) {//求出n的约数  
			if (n % i == 0) {
				x[++tot] = i;
				if (i * i != n) x[++tot] = n / i;
			}
		}
		sort(x + 1, x + tot + 1);
		for (int i = 1; 2 * i <= tot + 1; i++){//记录pos  
			pos1[x[i]] = i;
			pos2[x[i]] = tot - i + 1;
		}
		for (int i = 1; i <= tot; i++) {
			f[i][1] = i == 1 ? 1 : 0;//初始化
			for (int j = 2; j <= tot; j++) {
				f[i][j] = f[i][j-1];
				if (j > i) continue;
				if (x[i] % x[j] == 0) {
					tmp = x[i] / x[j];
					pos = tmp <= sqrtn ? pos1[tmp] : pos2[n / tmp];
					f[i][j] = (f[i][j] + f[pos][j - 1]) % mod;
				} 
			} 
		}
		cout << f[tot][tot] - 1 << endl;
	} 
	return 0;
}
```

---


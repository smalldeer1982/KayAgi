# [TJOI2010] 砍树

## 题目背景

小 A 在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。

## 题目描述

我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点 $i$ 处都结着一个水果，每个水果有一个价值 $v_i$ 和重量 $w_i$。小 A 想带走树的一部分（或全部），包含至少 $K$ 个结点（也就是至少 $K$ 个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小 A 砍下的树必须是在原来的树中连通的一部分。

## 说明/提示

### 数据规模与约定

- 对 $20\%$ 的数据，$1 \le N \le 16$；
- 对 $100\%$ 的数据，$1 \le N \le 100$，$1 \le K \le N$，$1 \le v_i \le 10000$，$1 \le w_i \le 10000$。

## 样例 #1

### 输入

```
3 1
20 10 20
1 1 1
1 2
2 3
```

### 输出

```
20.00```

## 样例 #2

### 输入

```
3 2
20 10 20
1 1 1
1 2
2 3
```

### 输出

```
16.67```

# 题解

## 作者：青葱 (赞：7)

## 前置知识：

~~树形DP~~

其实无所谓，和普通DP差不多

------------

## 大致思路：


------------


看到**价值和重量**，~~不管三七二十一~~，直接考虑背包

然后再看一下数据范围，value和weight的范围极大，不能用传统的以价值作为下标的背包

但是n很小，仅到100，所以考虑以件数作为下标

------------

## 转移方程：

------------
```cpp
设f[u][i]表示:
在以u为根的子树中，选择i个节点，所能得到的最大平均值
```

当然，记录最大平均值的同时，也要记录权值和与重量和，方便转移

那么自然有：

```cpp
对于u的每棵子树v:
f[u][j]=f[v][k]+f[u][j-k];
其中，j-k>=1，因为要保证联通，所以u这个节点是必选的

```
------------

## 具体做法：

------------
首先，我开了一个结构体，用于存储状态

```cpp

struct node{
	int v,w;double ave;//转移状态的权值和，重量和，平均值
	node(){}
	node(int a,int b,double p):v(a),w(b),ave(p){}
}f[E][E];
```

然后dfs

```
void dfs(int u,int fa){
	f[u][1]=node(val[u],wei[u],(double)val[u]/wei[u]);//初始化
	for(int i=head[u];i;i=nex[i])
		if(to[i]!=fa){//不能走回父亲
			dfs(to[i],u);//先遍历子树
			for(int j=n;j>1;j--){//注意，这里一定要逆序，否则重复选择该棵子树的点
				for(int k=1;k<=j;k++){
					node p=f[to[i]][j-k];
					node q=f[u][k];
					double ave=(double)(p.v+q.v)/(p.w+q.w);
					if(ave>=f[u][j].ave){
						f[u][j]=node(p.v+q.v,p.w+q.w,ave);
					}
				}
			}
		}
}
```

好了，完了

------------

## 最终的代码
复杂度O(n^3)
```cpp
#include<bits/stdc++.h>
#define E 209
#define inf 1e8
using namespace std;
inline int read(){
	int x=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+c-48,c=getchar();
	return x;
}
int n,kk,m,wei[E],val[E];
int head[E],nex[E],to[E],cnt;
inline void add(int u,int v){
	nex[++cnt]=head[u];
	head[u]=cnt;to[cnt]=v;
}
struct node{
	int v,w;double ave;
	node(){}
	node(int a,int b,double p):v(a),w(b),ave(p){}
}f[E][E];
void dfs(int u,int fa){
	f[u][1]=node(val[u],wei[u],(double)val[u]/wei[u]);
	for(int i=head[u];i;i=nex[i])
		if(to[i]!=fa){
			dfs(to[i],u);
			for(int j=n;j>1;j--){
				for(int k=1;k<=j;k++){
					node p=f[to[i]][j-k];
					node q=f[u][k];
					double ave=(double)(p.v+q.v)/(p.w+q.w);
					if(ave>=f[u][j].ave){
						f[u][j]=node(p.v+q.v,p.w+q.w,ave);
					}
				}
			}
		}
}
int main(){
	n=read(),kk=read();
	for(int i=1;i<=n;i++) val[i]=read();
	for(int i=1;i<=n;i++) wei[i]=read();
	for(int i=1,v,u;i<n;i++){
		u=read(),v=read();
		add(u,v);add(v,u);
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=node(-inf,inf,-inf);
	dfs(1,0);double ans=0.0;
	for(int i=1;i<=n;i++)
		for(int j=kk;j<=n;j++){
//			cout<<i<<" "<<j<<" "<<f[i][j].v<<" "<<f[i][j].w<<endl;
			ans=max(ans,f[i][j].ave);
		}
	printf("%.2f",ans);
	return 0;
}
```



---

## 作者：zxh_mc (赞：2)

## 前置

树形 dp，二分。

## 题意

本质上是一个树上背包，需要选不少于 $k$ 个物品，每个物品有一个重量 $w$ 和价值 $v$，求性价比最大值。

## 分析

既然是性价比，显然是分数规划。

先介绍一下分数规划是什么：

我们二分这个最大性价比。

假设当前枚举到 $mid$，则我们将每个点的价值修改为 

$$v-mid \times w$$

然后我们正常做树形 dp，然后统计一下是否有价值大于等于 $0$ 的即可。

那么为什么这样呢？

假设性价比为 $g$，我们选的是 

$$p_1,p_2,...p_s( k\le s \le n)$$

则我们有

$$\frac {\sum_{i=1}^s{v_{p_i}}}{\sum_{i=1}^s{w_{p_i}}}=g$$

进而可以推出

$$\sum_{i=1}^s{w_{p_i} \times g}=\sum_{i=1}^s{v_{p_i}}$$

那么，当我们定义价值 $val_i=v_i-w_i \times g$ 时，有

$$\sum_{i=1}^s{val_{p_i}}=0\ge0$$ 

成立，故以上算法正确。

## 实现

比较好说，先二分出来 $g$，然后跑树形背包即可，注意要一边计算大小 $size_p$ 一边跑背包，不然复杂度 $O(n^3)$，加上二分可能 TLE。（虽然我没试过）

然后就是注意把精度卡到 $0.0001$，不然会 WA。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;
typedef double db;

int ver[N * 2], nxt[N * 2], hd[N], idx;

inline void add (int x, int y) {
	ver[++idx] = y;
	nxt[idx] = hd[x];
	hd[x] = idx;
}

int n, w[N], v[N], k, s[N];
bool mk[N];
db dp[N][N], g[N];

void dfs (int u, int fa) {
	dp[u][0] = 0; dp[u][1] = g[u]; s[u] = 1;
	for (int i = hd[u]; i ;i = nxt[i]) {
		int y = ver[i];
		if (y == fa) continue;
		dfs(y, u);
		s[u] += s[y];   										  //注意size和dp要一起算 
		for (int j = min(n, s[u]);j >= 1;j--) {                   //处理背包 
			for (int z = 0;z <= min(j - 1, s[y]);z++) {
				dp[u][j] = max(dp[u][j], dp[u][j - z] + dp[y][z]);
			}
		}
	}
}

bool check (db x) {
	for (int i = 1;i <= n;i++) g[i] = v[i] - x * w[i];                        //处理val 
	for (int i = 1;i <= n;i++) for (int j = 0;j <= n;j++) dp[i][j] = -200000;
	dfs(1, 0); 
	db res = -1;
	for (int i = 1;i <= n;i++) for (int j = k;j <= n;j++) {
		res = max(res, dp[i][j]);
	}
	if (res >= 0) return 1;
	return 0;
}

int main () {
	cin >> n >> k;
	for (int i = 1;i <= n;i++) cin >> v[i];
	for (int i = 1;i <= n;i++) cin >> w[i];
	for (int i = 1;i < n;i++) {
		int x, y;
		cin >> x >> y;
		add(x, y); add(y, x);
	}
	db l = 0, r = 200000;           //二分 
	while (r - l > 0.0001) {        //注意精度 
		db mid = (l + r) / 2;
		if (check(mid)) l = mid;
		else r = mid - 0.0001;
	}
	printf("%.2lf", l);
	return 0;
} 
```


---

## 作者：Angraecum (赞：1)

为什么有题解有两个直接背包的老哥。

---

首先，要求平均价值最高，很显然就是 [$01$ 分数规划](https://oi-wiki.org/misc/frac-programming/)。知道这个的人应该都清楚这种问题是不能直接用背包求解的，因为某一部分的最大均值和其他部分合并时还要考虑到 $w,v$ 的大小，所以不一定最优。

OI-Wiki 上给出了两种做法，这里采用通用的二分法。

我们二分答案 $mid$，然后考虑转化判定的式子，这一段 OI-Wiki 上有，在此复述一遍：

要求一组 $f_i\in\{0,1\}$ 使得 $\dfrac{\sum v_i\times f_i}{\sum w_i\times f_i}$ 最大，现在已经二分出答案 $mid$，考虑转化判定式：
$$
\begin{align*}
& \dfrac{\sum v_i\times f_i}{\sum w_i\times f_i} \ge mid\\
\Longrightarrow & \sum v_i\times f_i\ge mid\times w_i\times f_i\\
\Longrightarrow & \sum (v_i-mid\times w_i)\times f_i \ge 0
\end{align*}
$$

到了这里，我们就把每个物品的价值转化成了 $v_i-mid\times w_i$，这样就可以愉快的当树形背包板子来打了，来做这个题的应该都会，复杂度 $O(n^2\log V)$。需要注意的是二分时的精度不要只精确到 $0.01$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define db double
#define pb push_back
#define pi pair<ll,ll>
#define fi first
#define se second
const ll N=1005,M=1919810,mod=1e9+7;
const db eps=1e-4;
vector <ll> g[N];
ll n,k,siz[N];
db dp[N][N],w[N],v[N];
void dfs(ll u,ll fa,db mid){
	siz[u]=1;
	dp[u][0]=0,dp[u][1]=v[u]-mid*w[u];
	for(int v:g[u]){
		if(v==fa) continue;
		dfs(v,u,mid);
		siz[u]+=siz[v];
		for(int j=siz[u];j>0;--j)
			for(int k=0;k<=min(siz[v],j-1);++k)
				dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]);
	}
}
bool check(db mid){
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) dp[i][j]=-2e9;
	dfs(1,0,mid);
	db ans=-1;
	for(int i=1;i<=n;++i) for(int j=k;j<=n;++j) ans=max(ans,dp[i][j]);
	return ans>=0;
}
int main(){
	//ios::sync_with_stdio(0);
	//cin.tie(0); cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i) cin>>v[i];
	for(int i=1;i<=n;++i) cin>>w[i];
	for(int i=1;i<n;++i){
		ll a,b;
		cin>>a>>b;
		g[a].pb(b),g[b].pb(a);
	}
	db ans=0,l=0,r=200000;
	while(r-l>eps){
		db mid=(l+r)*1.0/2;
		if(check(mid)) l=ans=mid;
		else r=mid-eps;
	}
	printf("%0.2lf",ans);
	return 0;
}
```

[双倍经验 P4322](https://www.luogu.com.cn/problem/P4322)

---

## 作者：Alystkia (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P3874)
## 思路
看到价值和重量，就知道这是一道我不会的树上背包问题。一般背包可以设 $f_{i}$ 表示选择重量不超过 $j$ 的物品能获得的最大价值。但是这道题要结合树形结构，而且 $w$ 和 $v$ 的范围都很大，所以考虑基于个数来设置状态。

我们设 $f_{i,j}$ 表示在以 $i$ 为根的子树中选择 $j$ 个点能获得的最大平均价值。对于它的每棵子树，我们枚举从中选择了多少节点来转移。

因为题目要求记录平均值，而平均值并不容易直接转移，所以我们将 $f$ 数组开成结构体，记录当前状态的总重量，总价值，以及平均值（总价值/总重量）。这道题显然是树上 $01$ 背包，因此别忘了要倒序循环外层。

 ## 部分代码
```
struct node
{
    double w, v, ave;
    node() {}
    node(double a, double b, double c) : w(a), v(b), ave(c) {}
}f[105][105];
 
void dfs(int now, int father)
{
    f[now][1] = node(w[now], v[now], v[now] / w[now]);
    for (int i = head[now]; i; i = nxt[i])
    {
        if (to[i] == father)
            continue;
        dfs(to[i], now);
        for (int j = n; j > 1; --j)
        {
            for (int k = 1; k <= j; ++k)
            {
                node p = f[to[i]][j - k];
                node q = f[now][k];
                double ave = (p.v + q.v) / (p.w + q.w);
                if (ave >= f[now][j].ave)
                    f[now][j] = node(p.w + q.w, p.v + q.v, ave);
            }
        }
    }
    return;
}
```



---


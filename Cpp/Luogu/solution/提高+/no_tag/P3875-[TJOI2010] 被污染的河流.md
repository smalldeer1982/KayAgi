# [TJOI2010] 被污染的河流

## 题目背景

有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。


## 题目描述

郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。

![](https://cdn.luogu.com.cn/upload/pic/6840.png)


## 说明/提示

- 对于 $10\%$ 的数据，$1 \le  x_1,y_1,x_2,y_2 \le 100$，$1\le N \le 100$；
- 对于 $30\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^4$，$1\le N \le 100$；
- 对于 $100\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^5$，$1\le N \le 10^4$。

## 样例 #1

### 输入

```
3
1 3 4 3
6 7 6 3
4 6 7 6
```

### 输出

```
16```

# 题解

## 作者：中二病 (赞：6)

扫描线，用线段树维护。  
把每个矩形左边界和右边界存储，给左边界赋值1，右边界赋值-1，把线段排序，然后依次处理每个线段，给线段所在的区间加上付的值，把每个值>0的区间加到ans里就是当前被矩形覆盖的线的长度，再乘上距离下一个线段之间的距离，就是这两个线段之间覆盖矩形的面积。  
然后考虑用线段树处理。先想到用lazy_tag进行区间修改，但其实只有+1和-1的操作并且都是成对出现的，所以只要在push_up的时候对cnt[i]>0的i区间更新sum即可
```
if(cnt[qaq])
sum[qaq]=r-l+1;
else sum[qaq]=sum[left(qaq)]+sum[right(qaq)];
```  
然后这个题坐标全是整数且数据不大，所以偷个懒不用离散化  
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100010;
struct pg
{
	int x;
	int y1;
	int y2;
	int flag;
}line[N*5];
int cnt[N*10],sum[N*10];
int n;
bool cmp(pg a,pg b)
{
	return a.x<b.x;
}
int left(int qaq)
{
	return qaq<<1;
}
int right(int qaq)
{
	return qaq<<1|1;
}
void push_up(int qaq,int l,int r)
{
	if(cnt[qaq])
		sum[qaq]=r-l+1;
	else sum[qaq]=sum[left(qaq)]+sum[right(qaq)];
}
void change(int qaq,int l,int r,int nl,int nr,int k)
{
	if(nl<=l&&nr>=r)
	{
		cnt[qaq]+=k;
		push_up(qaq,l,r);
		return ;
	}
	int mid=(l+r)>>1;
	if(nl<=mid)change(left(qaq),l,mid,nl,nr,k);
	if(nr>mid)change(right(qaq),mid+1,r,nl,nr,k);
	push_up(qaq,l,r);
}
int main()
{
	cin>>n;
	int X1,X2,Y1,Y2;
	int tot=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&X1,&Y1,&X2,&Y2);
		if(X1>X2)swap(X1,X2);
		if(Y1>Y2)swap(Y1,Y2);
		if (X1==X2)
		{
             line[++tot].x=X1-1;line[tot].y1=Y1;line[tot].y2=Y2;line[tot].flag=1;
             line[++tot].x=X2+1;line[tot].y1=Y1;line[tot].y2=Y2;line[tot].flag=-1;
         }
		 else
		 {
             line[++tot].x=X1;line[tot].y1=Y1-1;line[tot].y2=Y2+1;line[tot].flag=1;
             line[++tot].x=X2;line[tot].y1=Y1-1;line[tot].y2=Y2+1;line[tot].flag=-1;
         }
	}
	sort(line+1,line+tot+1,cmp);
	int ans=0;
	for(int i=1;i<=tot;i++)
	{
		//cout<<sum[1]<<endl;
			ans+=sum[1]*(line[i].x-line[i-1].x);
			change(1,0,100010,line[i].y1,line[i].y2-1,line[i].flag);
	}
	cout<<ans;
	return 0;
}
```
如果要进行离散化，对所有的x值排序并去重，标上序号，用c[i]表示序号为i的x值，然后再push_up时改成sum[qaq]=c[r]-c[l]+1即可



---

## 作者：TSTYFST (赞：3)

# [P3875 [TJOI2010]被污染的河流](http://www.luogu.com.cn/problem/P3875 "P3875 [TJOI2010]被污染的河流") 

本来是为了改昨天的题，发现扫描线基本上都忘了，打算找个扫描线练练手，结果打的有来有回的。

## 解析

污染区域是以河流为中线的一块矩形，可能生病的社区数量就是这些矩形的面积并。

很显然是扫描线，线段树维护。

存储每个矩形左，右边界，左边界赋 $1$，右边界赋 $-1$，把线段排序，再依次处理每一条线段。

整体来说挺板子的，需要注意一些小细节。

河流起始位置和结束位置的坐标不一定先左后右，先下后上，所以要 ```swap``` 一下。

$x$ 值相等时，河流为纵向流向，左边界的 $x$ 值为 $x - 1$，右边界的 $x$ 值为 $x + 1$。

$y$ 值相等时，河流为横向流向，左，右边界的 $yl$（下方的端点）值为 $y - 1$，$yl$（上方的端点）值为 $y + 1$。

因为有 $-1$ 和 $+1$ 的操作，所以端点会出现值为 $0$ 或 $1000001$ 的情况，线段树初始化的时候要注意。

以及，$4e5$ 大小的线段树会```RE```，所以开大一点。

## Code

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

const int MAXN = 1e4 + 10, MAXM = 2e5 + 10;
int n, sum, maxr;

struct Line{
    int x;
    int yh, yl;
    int sit;
}line[MAXM << 1];

inline bool cmp(const Line &a, const Line &b){
    return a.x < b.x;
}

struct Segment_Tree{
    struct Tree{
        int l, r;
        int len;
        int cnt;
    }tr[MAXM << 2];

    inline int lson(int rt){
        return rt << 1;
    }

    inline int rson(int rt){
        return rt << 1 | 1;
    }

    inline void Pushup(int rt){
        if(tr[rt].cnt)
            tr[rt].len = tr[rt].r - tr[rt].l + 1;
        else   
            tr[rt].len = tr[lson(rt)].len + tr[rson(rt)].len;
    }

    void Build(int rt, int l, int r){
        tr[rt].l = l;
        tr[rt].r = r;
        tr[rt].len = 0;
        tr[rt].cnt = 0;

        if(l == r)
            return;
        
        int mid = (l + r) >> 1;
        Build(lson(rt), l, mid);
        Build(rson(rt), mid + 1, r);
    }

    void Update(int rt, int l, int r, int data){
        if(tr[rt].l >= l && tr[rt].r <= r){
            tr[rt].cnt += data;

            Pushup(rt);
            return;
        }

        int mid = (tr[rt].l + tr[rt].r) >> 1;
        if(l <= mid) Update(lson(rt), l, r, data);
        if(r > mid) Update(rson(rt), l, r, data);

        Pushup(rt);
    }
}S;

inline int read(){
    int x = 0, f = 1;
    char c = getchar();

    while(c < '0' || c > '9'){
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }

    return x * f;
}

int main(){
    n = read();
    for(register int i = 1; i <= n; i++){
        int x1, y1, x2, y2;
        x1 = read(), y1 = read(), x2 = read(), y2 = read();
        
        if(x1 > x2) swap(x1, x2);
        if(y1 > y2) swap(y1, y2);

        if(x1 == x2){
            line[(i << 1) - 1].x = x1 - 1, line[(i << 1)].x = x2 + 1;
            line[(i << 1) - 1].yl = line[(i << 1)].yl = y1;
            line[(i << 1) - 1].yh = line[(i << 1)].yh = y2;
            line[(i << 1) - 1].sit = 1;
            line[(i << 1)].sit = -1;
        }
        else if(y1 == y2){
            line[(i << 1) - 1].x = x1, line[(i << 1)].x = x2;
            line[(i << 1) - 1].yl = line[(i << 1)].yl = y1 - 1;
            line[(i << 1) - 1].yh = line[(i << 1)].yh = y2 + 1; 
            line[(i << 1) - 1].sit = 1;
            line[(i << 1)].sit = -1;
        }
    }

    n <<= 1;
    sort(line + 1, line + 1 + n, cmp);
    S.Build(1, 0, 100001);

    for(register int i = 1; i < n; i++){
        S.Update(1, line[i].yl, line[i].yh - 1, line[i].sit);
        sum += S.tr[1].len * (line[i + 1].x - line[i].x);
    }

    printf("%d\n", sum);

    return 0;
}
```

---

## 作者：Juan_feng (赞：2)

emm这题就是个矩形面积并qwq

**但是**

现在的某些人， **一看到**扫描线， **就想到**线段树， **更有甚**者， 认为扫描线就是线段树的**一种实现形式**罢了。

**实际上， 分块也是可以做扫描线问题的** ~~（线段树也是一种分块你这不是废话吗~~

**小蒟蒻这里就发一篇分块扫描线的题解qwq**

具体做法就是先保存一下每个矩形的左右边， 然后按从左到右排序（横坐标)， 循环从左到右枚举每一条边， 先计算出上一条边到这条边一共有多少面积的贡献， 即（当前边的位置-上条边的位置）* 上次修改后的序列上有多少个被覆盖次数非0的点（纵坐标） 

然后再根据这条边是一个矩形开始的边还是结束的边来判断是在分块上区间加还是区间减就行啦qwq

**这里提一下分块的维护区间非零个数的方法**： 

维护一下一个块内 **被散块覆盖所覆盖的（不计算整块修改）** 次数非零的点的个数， 和整块覆盖的次数（非负） 

统计的时候判断一下整块覆盖的次数是否为0， 如果为0的答案就加上被散块所覆盖的覆盖次数非零的点的个数， 否则就直接加上块长久好了qwq（改块被整体覆盖了）

然后就没什么啦。 没怎么调参跑得还挺快， 当然还有能优化的地方， 小蒟蒻比较懒就没有写， 但是还是提一下吧， 应该还是可以减少一定常数的qwq

改进： 在统计和修改的时候顺便维护一下 被覆盖的最上面的和最下面的点， 这样就能缩小查询的范围啦qwqwq

**那么代码如下：**
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define maxn 100010
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, z, xx, yy, cnt;
int sq;
int a[maxn], b[maxn], tag[maxn], ans[maxn];

struct hz {
    int pos;
    int st;
    int ed;
    int bl; //0为开始1为结束 
    bool operator < (const hz &o)const{
        if(pos == o.pos) 
          return bl < o.bl;
        return pos < o.pos;
    }
}h[maxn];

inline void in(re int &x){
    x=0;int bl = 1;char c=getchar();
    while(c<'0'||c>'9'){
    	if(c == '-')
    	  bl = -1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x *= bl;
}

void out(re int a){
    if(a < 0) {
        putchar('-');
        a = -a;
    }
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

int query() {
    int res = 0;
    FOR(i, 1, b[100002]) { //第一个和最后一个块不可能打标记 
        if(tag[i])
          res += sq;
        else
          res += ans[i]; 
    }
    return res;
}

void changeup(int x, int y) {
    FOR(i, x, min(y, b[x]*sq)) {
        ++a[i]; 
        if(a[i] == 1)  
          ++ans[b[x]];
    }
    if(b[x] != b[y])
      FOR(i, (b[y]-1)*sq+1, y) {
          ++a[i];
          if(a[i] == 1)
            ++ans[b[y]];
      }
    FOR(i, b[x]+1, b[y]-1)
      ++tag[i];
} 

void changedown(int x, int y) {
    FOR(i, x, min(y, b[x]*sq)) {
        --a[i]; 
        if(a[i] == 0)  
          --ans[b[x]];
    }
    if(b[x] != b[y])
      FOR(i, (b[y]-1)*sq+1, y) {
          --a[i];
          if(a[i] == 0)
            --ans[b[y]];
      }
    FOR(i, b[x]+1, b[y]-1)
      --tag[i];
}

int main() {
    in(n);
    sq = sqrt(100002);
    FOR(i, 1, 100002)
      b[i] = (i-1)/sq+1;
    FOR(i, 1, n) {
        in(x), in(y), in(xx), in(yy);
        if(y == yy) {
            if(x > xx)
              swap(x, xx);
            h[++cnt].bl = 0;
            h[cnt].st = y;
            h[cnt].ed = y+1;
            h[cnt].pos = x+1;
            
            h[++cnt].bl = 1;
            h[cnt].st = y;
            h[cnt].ed = y+1;
            h[cnt].pos = xx;
        }
        else {
            if(y > yy)
              swap(y, yy);
            h[++cnt].bl = 0;
            h[cnt].st = y+1;
            h[cnt].ed = yy;
            h[cnt].pos = x;
            
            h[++cnt].bl = 1;
            h[cnt].st = y+1;
            h[cnt].ed = yy;
            h[cnt].pos = x+1;
        }
    }
    sort(h+1, h+cnt+1);
    int pre = 0;
    int res = 0;
    int now = 0;
    FOR(i, 1, cnt) {
        if(h[i].bl == 1) {
            now = h[i].pos;
            res += (now-pre+1)*query();
            pre = now+1;
            changedown(h[i].st, h[i].ed);
        }
        else {
            now = h[i].pos;
            res += (now-pre)*query();
            pre = now;
            changeup(h[i].st, h[i].ed);
        }
    }
    out(res);
    putchar(10);
}
```

---

## 作者：Like_Amao (赞：1)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P3875)

**思路**

扫描线纯模板，考虑用线段树维护。

我们可以将每一个矩阵的左边界赋值为 1，右边界为 -1，然后将每一条线段按从小到大的顺序排序一遍，然后对于每一条线段都进行操作，将线段所在的这个区间加上之前赋值的 1 或 -1，把每个值超过 0 的区间加到一个答案变量里就是当前这条被矩形覆盖的线的长度，再乘以与下一条线段之间的距离，就是这两个线段之间矩形的面积。

因为要进行区间修改，所以我们才使用线段树维护。

因为区间只会修改 1 或 -1，并且都是成对出现，所以我们只用在上传的时候对于每一个有标记的区间做修改就可以了。

其实我们可以再用上离散化优化，但是 ~~因为我不会~~，因为每个线只是在 $10 ^ 5$ 范围内，且不会有浮点数的情况，所以我们可以不用离散化，但如果你追求效率的话，可以写一下。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
struct edge
{
	int x;
	int y;
	int yy;
	int flag;
}line[N/2];
int cnt[N],f[N];
bool cmp(edge,edge);
void Swap(int&,int&);
void push_up(int,int,int);
void add(int,int,int,int,int,int);
int main()
{
	int n,t=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x,y,xx,yy;
		cin>>x>>y>>xx>>yy;
		if(x>xx)
		{
			Swap(x,xx);
		}
		if(y>yy)
		{
			Swap(y,yy);
		}
		if(x==xx)
		{
			line[++t].x=x-1;
			line[t].y=y;
			line[t].yy=yy;
			line[t].flag=1;
            line[++t].x=xx+1;
			line[t].y=y;
			line[t].yy=yy;
			line[t].flag=-1;
		}
		else
		{
			line[++t].x=x;
			line[t].y=y-1;
			line[t].yy=yy+1;
			line[t].flag=1;
            line[++t].x=xx;
			line[t].y=y-1;
			line[t].yy=yy+1;
			line[t].flag=-1;
		}
	}
	sort(line+1,line+t+1,cmp);
	int ans=0;
	for(int i=1;i<=t;i++)
	{
		ans+=f[1]*(line[i].x-line[i-1].x);
		add(1,0,N/10,line[i].y,line[i].yy-1,line[i].flag);
	}
	cout<<ans;
	return 0;
}
void add(int i,int left,int right,int u,int v,int tag)
{
	if(u<=left and v>=right)
	{
		cnt[i]+=tag;
		push_up(i,left,right);
		return;
	}
	int middle=(left+right)>>1;
	if(u<=middle)
	{
		add(i+i,left,middle,u,v,tag);
	}
	if(v>middle)
	{
		add(i+i+1,middle+1,right,u,v,tag);
	}
	push_up(i,left,right);
}
void push_up(int i,int left,int right)
{
	if(cnt[i])
	{
		f[i]=right-left+1;
	}
	else
	{
		f[i]=f[i+i]+f[i+i+1];
	}
}
void Swap(int &x,int &y)
{
	int t=x;
	x=y;
	y=t;
}
bool cmp(edge x,edge y)
{
	return x.x<y.x;
}
```

---

## 作者：Ofnoname (赞：1)

//UPD:换了一张图片

每一条线段对应一个$2*i$或者$i*2$的矩形。转换后就是一个弱化的扫描线问题。

坐标范围只有100000且没有负数，所以不用离散化。下面简单讲讲扫描线。

我们用一根竖直的线从左向右依次扫描，每当与矩形的竖直边重合时就累加一次面积，相当于把并集图形分割为一个一个小的矩形。
![](https://cdn.luogu.com.cn/upload/image_hosting/hkkv76ib.png)

具体来说，建立数组$d[i]$保存这个y坐标被覆盖了多少次，并把矩形的竖边按$(x,y1,y2,d)$表示，d表示这是矩形的左边界(1)还是右边界(-1)，比如图中第一条边就是$(2,3,7,1)$，并按x排序依次考虑。

对于每条边，我们把$[y1,y2)$的值都加上d，表示这条左数边把y轴这些地方又覆盖了一次，或者右数边表示该矩形对y轴影响已经结束。

（为什么是左闭右开：我们把点转化为线段来求覆盖次数，点的数量是比线段的数量多1个的，比如第一条线段里$[3,7]$是有5个点的，但是放在d数组里只有4个值需要修改。）

接着统计答案，下一个矩形的宽就是相邻两根竖边的x坐标差，而长度就是d数组里至少被覆盖一次的坐标数。

（图中：$2*4+2*6+1*8+2*7+1*7+1*4+3*4+0*0\ =\ 60$）

d数组涉及了区间修改和区间查询，可以使用线段树来维护。

由于只需要查询$(1,N)$里的覆盖次数，我们的懒标记可以不用下推。更新时，如果一个节点有懒标记（表示自己被完全覆盖的次数），那么他的贡献就是区间总长度（因为被覆盖），否则递归计算左右儿子并相加。

还有一个细节，线段树下表只能从1开始，但题目里可能出现0，所以可以将所有坐标读进来时+1储存。

```cpp
#include <bits/stdc++.h>
#define MAX (100000 + 10)
#define mid (L + R >> 1)
#define RS (i << 1 | 1)
#define LS (i << 1)
using namespace std;

struct Node{int x,y1,y2,d;} a[MAX<<1];
struct Tree{int L,R,v,len;} d[MAX<<4];
int N,ans,xa,xb,ya,yb;

int cmp(const Node &a,const Node &b) {return a.x < b.x;}
void swap(int &a,int &b) {a ^= b ^= a ^= b;}

void read(int &a)
{
	register char c = getchar();
	for (a=0; c<'0'||'9'<c; c=getchar());
	for (; '0'<=c && c<='9'; c=getchar())
		a = a * 10 + (c & 15);
}

void init(int i,int L,int R)
{
	d[i].L = L; d[i].R = R;
	if (L != R) init(LS,L,mid), init(RS,mid+1,R);
}

void add(int i,int L,int R,int v)
{
	if (L <= d[i].L && d[i].R <= R)
		d[i].v += v;//v即懒标记
	else
	{
		const int md = (d[i].L+d[i].R) >> 1;
		if (L <= md) add(LS,L,R,v);
		if (R > md) add(RS,L,R,v);
	}//以下就是上推过程
	if (d[i].v) d[i].len = d[i].R - d[i].L + 1;
	else d[i].len = d[LS].len + d[RS].len;//len就是覆盖长度
}

int main()
{
	read(N); init(1,1,MAX);
	for (int i = 1, xa = 0, xb = 0; i <= N; i++)
	{
		read(xa); read(ya);
		read(xb); read(yb);
		if (xa == xb)
		{//把线段转化为矩形
			if (ya > yb) swap(ya,yb);
			a[i] = Node{xa, ya+1, yb+1, 1}, 
			a[i+N] = Node{xa+2, ya+1, yb+1, -1};
		}
		else
		{
			if (xa > xb) swap(xa,xb);
			a[i] = Node{xa+1, ya, ya+2, 1},
			a[i+N] = Node{xb+1, ya, ya+2, -1};
		}	
	}
	
	sort(a + 1, a + N + N + 1, cmp);
	for (int i = 1; i <= N<<1; i++)
	{
		add(1, a[i].y1, a[i].y2-1, a[i].d);
		ans += d[1].len * (a[i+1].x - a[i].x);//计算面积
	}printf("%d\n",ans);
}
```
举一反三：

[P5490 【模板】扫描线](https://www.luogu.org/problem/P5490)

[P1856 [USACO5.5]矩形周长Picture](https://www.luogu.org/problem/P1856)


---

## 作者：Little_Deer_Peach (赞：0)

题意已经够简洁了不再赘述。

很明显的，这是一道矩形面积并模板题。注意到一条河流会影响其两边的社区，那么设这条河流长度为 $x$，则可以把它看做一个 $2 \times x$ 的矩形，然后求出面积并即可。

注意到给的坐标可能 $x_1 > x_2$ 或者 $y_1 > y_2$，所以需要处理一下。如果 $x_1 = x_2$，那么矩形左下角坐标就是 $(x_1 - 1,y_1)$，右上角坐标就是 $(x_2+1,y_2)$。同理，如果 $y_1=y_2$，那么矩形左下角坐标就是 $(x_1,y_1-1)$，右上角坐标为 $(x_2,y_2+1)$。

然后就是[模板](https://www.luogu.com.cn/problem/P5490)部分了，不会可以先去做模板题。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define endl '\n'
const int N=1e4+5;
int n;
struct line{
	int l,r;
	int x;
	int tag;
	bool operator<(const line l)const{
		return x<l.x||(x==l.x&&tag>l.tag);
	}
}Line[N<<1];
int px[N<<1],cnt,len;
int ans[N<<2],tag[N<<2];
int ls[N<<2],rs[N<<2];
int rt,p;
void insert(int &x,int nowl,int nowr,int l,int r,int k){
	if(!x)x=++p;
	if(l<=nowl&&nowr<=r){
		tag[x]+=k;
		if(nowl==nowr&&nowl==len)return;
		if(tag[x])ans[x]=px[nowr+1]-px[nowl];
		else ans[x]=ans[ls[x]]+ans[rs[x]];
		return;
	}
	int mid=nowl+nowr>>1;
	if(l<=mid)insert(ls[x],nowl,mid,l,r,k);
	if(mid<r)insert(rs[x],mid+1,nowr,l,r,k);
	if(nowl==nowr&&nowl==len)return;
	if(tag[x])ans[x]=px[nowr+1]-px[nowl];
	else ans[x]=ans[ls[x]]+ans[rs[x]];
	return;
}
signed main(){
	IOS;
	cin>>n;
	for(int i=1;i<=n;++i){
		int sx,sy,ex,ey;
		cin>>sx>>sy>>ex>>ey;
		if(sx>ex)swap(sx,ex);
		if(sy>ey)swap(sy,ey);		
		if(sx==ex)--sx,++ex;
		if(sy==ey)--sy,++ey;
		Line[++cnt]={sx,ex,sy,1};
		px[cnt]=sx;
		Line[++cnt]={sx,ex,ey,-1};
		px[cnt]=ex;
	}
	sort(px+1,px+cnt+1);
	len=unique(px+1,px+cnt+1)-px-1;
	for(int i=1;i<=cnt;++i){
		Line[i].l=lower_bound(px+1,px+len+1,Line[i].l)-px;
		Line[i].r=lower_bound(px+1,px+len+1,Line[i].r)-px;
	}
	sort(Line+1,Line+cnt+1);
	int res=0;
	for(int i=1;i<cnt;++i){
		insert(rt,1,len,Line[i].l,Line[i].r-1,Line[i].tag);
		res+=(Line[i+1].x-Line[i].x)*ans[rt];
	}
	cout<<res<<endl;
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/231009900)。

---

## 作者：Iniaugoty (赞：0)

显然是[扫描线](/problem/P5490)，直接套板子即可。

$10 ^ 5$ 的值域，不用离散化是极好的。

然后有一个小坑，可能会出现 $x _ 1 > x _ 2$ 或者 $y _ 1 > y _ 2$ 的情况，特判一下。

注意矩形边界的处理，~~以前写板子的时候调了好久~~。

这里使用线段树维护。

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = a; i <= (b); ++i)
#define dF(i, a, b) for(int i = a; i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 1e5 + 5;
const int K = 1e5;

LL n, ans;
struct edge { int h, l, r, d; };
bool cmp(edge a, edge b) { return a.h < b.h; }
vector<edge> e;

struct node {
	int l, r, cov, len; 
} t[N * 12];
void push_up(int u) {
	if (t[u].cov) t[u].len = t[u].r + 1 - t[u].l;
	else t[u].len = t[u * 2].len + t[u * 2 + 1].len;
}
void Build(int l, int r, int u) {
	t[u].l = l, t[u].r = r;
	t[u].cov = t[u].len = 0;
	if (l == r) return;
	int mid = l + r >> 1;
	Build(l, mid, u * 2);
	Build(mid + 1, r, u * 2 + 1);
	push_up(u);
}
void Add(int l, int r, int d, int u) {
	if (l <= t[u].l && t[u].r <= r) t[u].cov += d;
	else {
		int mid = t[u].l + t[u].r >> 1;
		if (l <= mid) Add(l, r, d, u * 2);
		if (r > mid) Add(l, r, d, u * 2 + 1);
	}
	push_up(u);
}

int main() {
	//freopen("wmyr.in", "r", stdin);
	//freopen("wmyr.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	F(i, 1, n) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
        if (x1 == x2) {
            if (y1 > y2) swap(y1, y2);
            e.push_back({y1, x1 - 1, x2, 1});
            e.push_back({y2, x1 - 1, x2, -1});
        }
        if (y1 == y2) {
            if (x1 > x2) swap(x1, x2);
            e.push_back({y1 - 1, x1, x2 - 1, 1});
            e.push_back({y2 + 1, x1, x2 - 1, -1});
		}
	}
	n *= 2;
	Build(0, K - 1, 1);
	sort(e.begin(), e.end(), cmp);
	for (int i = 0; (int) i < e.size() - 1; ++i)
		Add(e[i].l, e[i].r, e[i].d, 1),
		ans += (LL) (e[i + 1].h - e[i].h) * t[1].len;
	cout << ans;
	return 0;
}
```

---

## 作者：elijahqi (赞：0)

http://www.elijahqi.win/2018/01/02/luogu3875-tjoi2010%e8%a2%ab%e6%b1%a1%e6%9f%93%e7%9a%84%e6%b2%b3%e6%b5%81/


题目背景

http://blog.csdn.net/elijahqi/article/details/78951550

有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是1公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。

题目描述


郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。


输入输出格式


输入格式：


输入文件的第一行是一个整数N，表示被污染的河段的数目。


接下来N行，每行4个整数x1，y1，x2，y2，表示被污染河段的起始位置和结束位置。每行输入的两个位置保证不重合，并且满足x1=x2或y1=y2


输出格式：


输出一个整数A，表示有A个社区的居民会喝到被污染的水。

输入输出样例


输入样例#1： 复制


3
1 3 4 3

6 7 6 3

4 6 7 6


输出样例#1： 复制


16

说明

对于10%的数据，1 ≤ x1，y1，x2，y2 ≤ 100，N ≤ 100；


对于30%的数据，1 ≤ x1，y1，x2，y2 ≤ 10000，N ≤ 100；


对于100%的数据，1 ≤ x1，y1，x2，y2 ≤ 100000，N ≤ 10000。


每个测试点时限1秒。


哇首先必膜icefox巨佬 在蒟蒻我苦苦思索 大佬直接秒出正解 这不矩形面积并嘛 强啊 %%![这里写图片描述](http://img.blog.csdn.net/20180102120344650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZWxpamFocWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


顺带学习了下这种扫描线的写法 表示自己以前写的十分不好 不方便写代码  很麻烦 还是膜icefox吧

![这里写图片描述](http://img.blog.csdn.net/20180102120344650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZWxpamFocWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


这题首先已经可以知道 方法就是扫描线做矩形面积并 那么 我是以横坐标排序 然后纵坐标线段树这样做的 首先我把每个矩形拆分成两个线 一个是左边的一个是右边的 注意 我扫描线我现在一共需要维护两种东西 1、我这区域被覆盖几次 2、我这区域被覆盖的长度是多少


那么只有在我区域被覆盖次数减没的时候我需要把区间覆盖的长度更改一下  注意 这个更改不是直接暴力的更改成0 而是更改成我子节点覆盖的一共有多少 此外update的时候 如果发现我当前这一层已经被完整的覆盖了 那么我就不从下一级更新上来了 画一画图就可以知道了 然后直接输出答案即可 另外这题 因为针对这个y也不是闭区间 所以我干脆给他变成这个左闭右开的形式方便统计答案

```cpp

#include<cstdio>
#include<algorithm>
#define N 110000
#define ll long long
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0;char ch=gc();
    while(ch<'0'||ch>'9') ch=gc();
    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x;
}
struct node{
    int x,y1,y2,op;
}line[N>>1];
struct node1{
    int left,right,v,len;
}tree[N<<2];
int num=0,n,root;ll ans; 
inline bool cmp(node a,node b){return a.x==b.x?a.op>b.op:a.x<b.x;}
inline void update(int x){
    if (tree[x].v) return;
    int l=tree[x].left,r=tree[x].right;
    tree[x].len=tree[l].len+tree[r].len;
}
inline void insert1(int x,int l,int r,int l1,int r1,int v){
    if (l1<=l&&r1>=r){tree[x].v+=v;if (tree[x].v) tree[x].len=r-l+1;else update(x);return;}
    int mid=l+r>>1;if (l1<=mid) insert1(tree[x].left,l,mid,l1,r1,v);
    if (r1>mid) insert1(tree[x].right,mid+1,r,l1,r1,v); update(x);
}
void build(int &x,int l,int r){
    x=++num;if (l==r) return;
    int mid=l+r>>1;build(tree[x].left,l,mid);build(tree[x].right,mid+1,r);
}
int main(){
    freopen("3875.in","r",stdin);
    n=read();int max1=0;
    for (int i=1;i<=n;++i){
        int x1=read(),y1=read(),x2=read(),y2=read();
         if (x1>x2) swap(x1,x2);if (y1>y2) swap(y1,y2);max1=max(max1,y2+1);
         if (x1==x2){
             line[++num].x=x1-1;line[num].y1=y1;line[num].y2=y2;line[num].op=1;
             line[++num].x=x2+1;line[num].y1=y1;line[num].y2=y2;line[num].op=0;
         }else{
             line[++num].x=x1;line[num].y1=y1-1;line[num].y2=y2+1;line[num].op=1;
             line[++num].x=x2;line[num].y1=y1-1;line[num].y2=y2+1;line[num].op=0;
         }
    }sort(line+1,line+num+1,cmp);num=0;build(root,0,max1);ll ans=0;
    for (int i=1;i<=n<<1;++i){
        ans+=(ll)tree[root].len*(line[i].x-line[i-1].x);
        insert1(root,0,max1,line[i].y1,line[i].y2-1,line[i].op?1:-1);
    }printf("%lld\n",ans);
    return 0;
}

```

---


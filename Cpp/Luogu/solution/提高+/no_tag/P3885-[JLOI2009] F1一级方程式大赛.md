# [JLOI2009] F1一级方程式大赛

## 题目背景

众所周知，迈克尔·舒马赫 (Michael  Schumacher) 是当今车坛最伟大的王者，从 1991 年至 2006 年他一共参加了 260 多场比赛，获得近 100 次分站冠军，9 次年度冠军。舒马赫取得如此辉煌的战绩得益于他有一个非常优秀的智囊团。每次比赛之前他的智囊团将根据场地、气候、路况以及赛车状态，来为舒马赫制定比赛中的策略。


## 题目描述

我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。


作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。


## 样例 #1

### 输入

```
3  100  0  10  0  20  0```

### 输出

```
300.000  30.000  0```

## 样例 #2

### 输入

```
3  100  2  10  0.1  20  1```

### 输出

```
422.469  23.457  1
2  11.111
```

## 样例 #3

### 输入

```
3  100  4  10  0  20  1```

### 输出

```
480.000  10.000  2
1  10.000
2  10.000
```

# 题解

## 作者：Richard_H (赞：6)

## ~~切了这个题，你也可以成为法拉利策略师~~

首先这个题的输入数据就比较多，好好整理一下再仔细思考这个题。

下面定义一下文中会出现的变量名的含义：

- 比赛的总圈数 `int n`

- 理论上，没有油的空车跑一圈所需的时间 `double emtt`

- 每增加 $1$ 公升汽油，赛车跑一圈所增加的时间 `double inct`

- 理论上，没有油的空车跑一圈所消耗的油量 `double emtg`

- 每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗 `double incg`

- 每次进站所需花费的时间 `double pitt`

- 每次进站后，每加 $1$ 公升汽油，所需花费的时间 `double pitg`

（解释一下，其中的 $t$ 表示的是时间，$g$ 表示的是汽油，$emt$ 表示空车，$inc$ 表示增加，$pit$ 表示进站，方便记忆，免得搞混）

在搞懂了题目之后不难发现这玩意是动态规划，暂定 $f[i]$ 表示的是~~维斯塔潘~~舒马赫跑了 $i$ 圈后最短时间，利用贪心的思想，每次进站或者到达终点的时候肯定是把油箱跑得一滴油都不剩了，所以我们先得预处理出来恰好跑 $i$ 圈耗油是多少。

首先，如果只跑一圈，我们可以列出来这样一个关于耗油量 $gas$ 的方程：

$$\begin{aligned}
gas - emtg - incg \times gas = 0
\end{aligned}$$

然后同理可得，对于跑 $i$ 圈的耗油量 $gas[i]$ 的方程：

$$\begin{aligned}
(gas[i] - emtg - incg \times gas[i]) = gas[i - 1]
\end{aligned}$$

由此得到递推式

$$gas[i] = \frac{gas[i - 1] + emtg}{1 - incg}$$

然后由于我们每次跑 $i$ 圈的时间与油量也有关，所以我们每次还需要预处理出来跑 $i$ 圈正好把油箱跑空的时间是多少。这个东西按照题目的要求计算即可。

接下来就是正经的 dp 部分，$f[i]$ 表示的就是跑了 $i$ 圈正好进站（或者到达终点）的最短时间，可以枚举上一次进站时间是第几圈，然后转移。在遍历的时候我们假装他是维修区发车，但是不计算进站和加油的时间。然后他又要输出方案，所以每次记录一下是从哪里转移过来的，最后用一下 `stack` 按顺序输出。

时间复杂度 $\Theta (n^2)$

---

贴代码！（目前 30ms，最快哦）

```cpp
#include<bits/stdc++.h>
#include<ext/rope>
using namespace std;
using namespace __gnu_cxx;
typedef long long lol;
typedef pair<int, int> pii;
typedef unsigned int uin;

const int N = 505;
int n;
double emtt, inct, emtg, incg, pitt, pitg;
double gas[N], lap[N], f[N];
int pre[N];

int main () {
    scanf ("%d%lf%lf%lf%lf%lf%lf", &n, &emtt, &inct, &emtg, &incg, &pitt, &pitg);

    for (int i(1); i <= n; ++ i ) 
        gas[i] = (gas[i - 1] + emtg) / (1 - incg), 
        lap[i] = lap[i - 1] + emtt + gas[i] * inct, 
        f[i] = 1e18;
    
    for (int i (1); i <= n; ++ i ) 
        for (int j (0); j < i; ++ j ) 
            if (j) 
            {
                double t = f[j] + pitt + gas[i - j] * pitg + lap[i - j];
                if (f[i] > t) 
                    f[i] = t, pre[i] = j;
            }
            else 
            {
                double t = f[j] + lap[i - j];
                if (f[i] > t) 
                    f[i] = t, pre[i] = j;
            }
    
    stack <pii> s;
    int u = n;
    while (pre[u]) 
        s.push(pii (pre[u], u - pre[u])), 
        u = pre[u];

    printf ("%.3lf %.3lf %d\n", f[n], gas[u], s.size());
    while (!s.empty()) 
        printf ("%d %.3lf\n", s.top().first, gas[s.top().second]), s.pop();
    
    return 0;
}
```


---

## 作者：GNAQ (赞：5)

不是……我前面那两位咋不写题解啊……

那我写算了。。

首先这是一道DP……这很显然。。

注意到每次加油一定是加**刚好够跑整数圈**的油……要不浪费时间。

然后方便起见，我们预处理跑 $1 \sim n$圈的耗油和耗时，因为这和你当前在跑哪一圈是无关的。

设为了跑第 $i$ 圈，需要用油 $q_i$，每圈空车跑油 $s$ , 每多一升油多跑油 $a$ , 初中数学解方程可以得到：

$ q_i = (q_{i-1} + q_i) \cdot a + s $

$ q_i = \frac{s + q_{i-1} \cdot a }{1-a} $

时间比较好算……就不说了。

预处理完了，我们开始dp。

设dp[i][j]表示：在第 $i$ 圈起点，准备不加油一口气地跑 $j$ 圈的最小时间。

转移就是（need是跑 $i$ 圈的油量，tim是时间，incost是进加油站，gcost是加油）：

```cpp
dp[i][j]=min(dp[i][j],dp[i-k][k]+tim[j]+incost+gcost*need[j];)
```

然后记录一下转移的前驱，最后输出就行了。

$O(n^3)$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iterator>
#include<queue>
#include<vector>
#include<cstdlib>
#include<map>
#include<set>
using namespace std;

int n;
double stime,atime,scost,acost,gcost,incost;
double need[105]={0},tim[105]={0},dp[105][105]={0};

short pre[105][105]={0},go[105][105]={0};

inline void output(int a,int b)
{
	if (pre[a][b])
	{
		output(pre[a][b],a-pre[a][b]);
		printf("%d %.3lf\n",a-1,need[b]);
	}
}
inline double getprimery(int a,int b)
{
	if (pre[a][b]==1) return need[a-pre[a][b]];
	return getprimery(pre[a][b],a-pre[a][b]);
}

int main()
{
	memset(dp,0x43,sizeof dp);
	scanf("%d%lf%lf%lf%lf%lf%lf",&n,&stime,&atime,&scost,&acost,&incost,&gcost);
	
	for (int i=1;i<=n+2;i++) need[i]=need[i-1] + ((need[i-1]*acost+scost)/(1-acost));
	for (int i=1;i<=n+2;i++) tim[i]= tim[i-1] + stime+need[i]*atime;
	for (int i=0;i<=n;i++) dp[1][i]=tim[i];
	
	register double cac=0;
	for (int i=2;i<=n+1;i++)
		for (int j=1;j<=n+1;j++)
			for (int k=1;k<=n+1;k++)
			{
				if (i-k<1) break;
				cac=dp[i-k][k]+tim[j]+incost+gcost*need[j];
				
				if (cac<dp[i][j])
				{
					dp[i][j]=cac;
					
					pre[i][j]=i-k;
					go[i][j]=go[i-k][k]+1;
				}
			}
	
	register int pos=n; register double start;
	for (int i=n;i;i--) if (dp[i][n+1-i]<dp[pos][n+1-pos]) pos=i;
	if (pos==1) start=need[n];
	else start=getprimery(pos,n+1-pos);
	
	printf("%.3lf %.3lf %d\n",dp[pos][n+1-pos],start,go[pos][n+1-pos]);
	output(pos,n+1-pos);
	return 0;
}
```

---

## 作者：qiyichen12 (赞：3)

# 前言
以下为后文中的变量名及意义：
1. 圈数 $l$。
2. 空车跑一圈所需的时间 $kt$。
3. 增加 $1$ 公升汽油增加的时间 $dt$。
4. 空车跑一圈所消耗的油量 $kl$。
5. 增加 $1$ 公升汽油增加的油量损耗 $dl$。
6. 每次进站所需花费的时间 $jit$。
7. 加 $1$ 公升汽油花费的时间 $jat$。

# 分析
一看就是 dp 题，只不过复杂一些。首先，因为跑 $i$ 圈的时间和耗油量一定，可以先预处理出耗油 $hy[i]$ 和时间 $ht[i]$。

转移方程：$hy[i]=(hy[i−1]+kl)÷(1−dl)$
_注：由 $hy[i]-hy[i]×dl=hy[i−1]+kl$ 得来。_

同时：$ht[i] = ht[i-1]+kt+hy[i]×dt$ _（即第 $i$ 圈为第 $i-1$ 圈+空车一圈的时间+油量拖慢的时间）。_


```cpp
for (int i = 1;i <= l;i++)
{
    hy[i] = (hy[i-1]+kl)/(1-dl);
    ht[i] = ht[i-1]+kt+hy[i]*dt;
}
```
考虑转移时间，可以一一比较在哪里加油。定义 $dtp[i]$ 为第 $i$ 圈的最短时间 $(i>0)$ 则遍历 $[1,i)$ 区间比较。

因为要耗油耗时最小，所以加一次油要加整圈：即加 $hy[i-j]$ 升油。

得到转移方程：$dtp[i]=\min(dtp[i],dtp[j]+jit+ht[i-j]+hy[i-j]×jat)$ _注意要先将 $dtp[i]$ 设为无穷大_

而 $j=0$ 要特判 $dtp[i]=\min(dtp[i],dtp[0]+ht[i])$，因为第零次加油即初始油量不必耗时。

```cpp
for (int i = 1;i <= l;i++)
{
    dtp[i] = min(dtp[i],dtp[0]+ht[i]);
    for (int j = 1;j < i;j++) 
    {
        dtp[i] = min(dtp[i],dtp[j]+jit+ht[i-j]+hy[i-j]*jat);
    }
}
```
因为要输出加油的时间和量，所以定义 $yo[i]$ 和 $qa[i]$ 保存油量和圈数。

最后在处理一下细节就好啦！~处理细节花了我两个小时~

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(l,r,i) for(int i = l;i <= r;i++)
const int Len = 1000000;
int l,cnt;
double kt,dt,kl,dl,jit,jat,zy,dzy;
double dtp[Len],ht[Len],hy[Len];
int qa[Len];
double yo[Len];
int main()
{
    scanf("%d%lf%lf%lf%lf%lf%lf",&l,&kt,&dt,&kl,&dl,&jit,&jat);
    For(1,l,i) hy[i] = (hy[i-1]+kl)/(1-dl),ht[i] = ht[i-1]+kt+hy[i]*dt,dtp[i] = 1e18;
    For(1,l,i)
    {
        if(dtp[i] > dtp[0]+ht[i]) dtp[i] = dtp[0]+ht[i],cnt = (zy?cnt:cnt+1),zy = hy[i];
        For(1,i-1,j) 
        {
            double nt = dtp[j]+jit+ht[i-j]+hy[i-j]*jat;
            if(dtp[i] > nt) dtp[i] = nt,cnt = (yo[i]?cnt:cnt+1),yo[i] = hy[i-j],qa[i] = j,zy = dzy;
        }
        dzy = zy;
    }
    printf("%.3lf %.3lf %d\n",dtp[l],zy,max(cnt-1,0));
    For(1,l,i) if (yo[i]) printf("%d %.3lf\n",qa[i],yo[i]);
    return 0;
}
```

---

## 作者：潘德理2010 (赞：1)

:::info[关于本题题面和数据范围]
+ 经 [assert](https://www.luogu.com.cn/record/228748600)，本题数据范围至多为 $n\le 100$，其余数在 $[0,100]$ 范围内。
+ 输入范围中所写的 $n$ 为不超过 $1$ 的正整数并不真实。
:::

这是一篇决策单调性（二分队列）优化 dp 的题解，时间复杂度 $O(n\log n)$。

首先，不难发现，到一个地方准备加油时，油箱里一定没有油（如果有，那么上次加油时少加这些油一定更优）。

考虑使用 dp 解决本题。

我们做一些定义：

+ $n$ 为比赛圈数。

+ $t$ 为没有油的空车跑一圈所需的时间，$\Delta t$ 为每增加 $1$ 公升汽油，赛车跑一圈所增加的时间。

+ $p$ 为没有油的空车跑一圈所消耗的油量，$\Delta p$ 为每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗。

+ $L$ 为进加油站所需时间，$r$ 为加 $1$ 公升油所需时间。

我们 $O(n)$ 预处理出以下值，方便计算转移的代价：

+ $ps_i$，表示行驶 $i$ 路程（中途不加油）前所需要带的油，且行驶完 $i$ 路程后这些油要全部用完。

+ $ks_i$，表示没有油时，加 $ps_i$ 的油（刚好够用），然后行驶 $i$ 路程所需要的总时间（包括行驶时间和加油时间）。

+ $kf_i$，同 $ks$，但是不包括加油时间，即从 $0$ 出发到 $i$ 需要的时间。

使用递推的方式计算：

$$ps_i=p+ps_i\times \Delta p+ps_{i-1}$$

变形，得到：

$$ps_i=\frac{ps_{i-1}+p}{1-\Delta p}$$

另有：

$$ks_i=ks_{i-1}+(t+ps_i\times \Delta t)+(ps_i-ps_{i-1})\times r+L[i=1]$$

$$kf_i=kf_{i-1}+(t+ps_i\times \Delta t)$$

记 $f_i$ 为走完第 $i$ 圈且油箱没有油的最短时间。有 $f_i=\max(f_j+ks_{i-j})$。令代价函数 $w(j,i)=ks_{i-j}$，则有 $f_i=\max(f_j+w(j,i))$。感性判断一下，$ps,ks$ 均呈指数型增长，所以四边形不等式成立，即有决策单调性。使用二分队列优化即可把时间复杂度降到 $O(n\log n)$。

:::warning[注意]
估价函数 $w$ 并不包括从 $0$ 转移过来的情况。上一段话对 $j=0$ 的情况并不适用。这种情况需要单独讨论，不能放入队列中，因为这种情况的代价为 $kf_i$ 而非 $w(j,i)$，并不一定满足决策单调性。
:::

如果你不知道如何用二分队列优化 dp，推荐阅读：

[OI Wiki](http://oi-wiki.com/dp/opt/quadrangle/) / [洛谷日报](https://www.luogu.com.cn/article/gqwl6j4y)

代码如下：（本代码能够 AC，但是本题数据似乎很弱，我不能保证此代码正确）

```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
int n;
double tk,p,dt,dp,lx,rx;
double ps[110],ks[110],kf[110];
double f[110],ft[110];
double w(int j,int i){//代价函数 
	int k=i-j;
	return f[j]+ks[k];
}
int q[110],l[110],r[110],h=0,t=-1;
void ins(int x){//入队函数 
	while(h<=t&&r[h]<x) h++;
	if(h<=t) l[h]=x;
	while(h<=t&&w(q[t],l[t])>=w(x,l[t])) t--;
	if(h>t){
		q[++t]=x,l[t]=x,r[t]=n;
		return;
	}
	if(w(q[t],r[t])<=w(x,r[t])) return;
	int lt=l[t],rt=r[t];
	while(lt<rt){// 找最后一个原来的数（q[t]）更优的位置 
		int mid=(lt+rt+1)/2;
		if(w(q[t],mid)>w(x,mid)) rt=mid-1;
		else lt=mid;
	}
	r[t]=rt;
	q[++t]=x,l[t]=rt+1,r[t]=n;
}
int main(){
	scanf("%d",&n);
	scanf("%Lf%Lf%Lf%Lf%Lf%Lf",&tk,&dt,&p,&dp,&lx,&rx);//输入 
	for(int i=1;i<=n;i++){//预处理 
		ps[i]=(ps[i-1]+p)/(1-dp);
	}
	for(int i=1;i<=n;i++){
		ks[i]=ks[i-1]+(ps[i]-ps[i-1])*rx+(tk+dt*ps[i]);
		if(i==1) ks[i]+=lx;
	}
	for(int i=1;i<=n;i++){
		kf[i]=kf[i-1]+(tk+dt*ps[i]);
	}
	for(int i=1;i<=n;i++){// dp 部分 
		double u;// u 表示最优状态（即队尾的状态） 
		int tg=0;
		if(h<=t) u=w(q[h],i),tg=1;
		if(u>kf[i]||!tg){// 与从 0 转移过来作比较 
			f[i]=kf[i];
			ft[i]=0;// ft 记录从哪里转移过来的，用于最后统计答案 
		}
		else{
			f[i]=u;
			ft[i]=q[h];
		}
		ins(i);//入队 
	}
	printf("%.3Lf ",f[n]);//统计答案并输出 
	int cnt=0,pos=n;
	stack<double> stk,sp;
	while(pos){
		int np=ft[pos];
		stk.push(ps[pos-np]);
		sp.push(np);
		cnt++;
		pos=np;
	}
	cnt--;
	printf("%.3Lf %d\n",stk.top(),cnt);
	stk.pop();
	sp.pop();
	while(!stk.empty()){
		double u=stk.top();
		int v=sp.top();
		stk.pop();
		sp.pop();
		printf("%d %.3Lf\n",v,u);
	}
}
```

---

## 作者：烟灬 (赞：1)

# # NOIP2021 RP++

## 题目描述


我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。

作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。


## 分析

题目的信息很多，先将输入变量的含义和数据类型区分明确：

- 比赛的总圈数： $n$
- 没有油的空车跑一圈所需的时间： $t0$
- 每增加 1 公升汽油，赛车跑一圈所增加的时间： $dt$

- 没有油的空车跑一圈所消耗的油量： $c0$

- 每增加 1 公升汽油，赛车跑一圈所增加的油量损耗： $dc$

- 每次进站所需花费的时间： $in$

- 每次进站后，每加 1 公升汽油，所需花费的时间： $add$

其中除 $n$ 为整型以外，其他变量均为浮点型。

------------

很容易可以想到动态规划来解决这道题目。

发现如果在进入加油站前油箱中还有剩油，那这部分剩油就会导致跑之前的路程时耗时和耗油增加，所得结果一定不优。

于是得出结论：每一次加油一定加正好可以跑完整圈的油。

又发现一次性跑 $i$ 圈的耗时和耗油量是不变的，所以我们预处理出 $sumc[i]$ 和   $sumt[i]$ 分别表示每次跑 $i$ 圈的耗油量和每次跑 $i$ 圈的耗时。

那么怎么计算这两个数组的值呢，容易发现跑 $i$ 圈的耗时是跟油量有关的，而耗油则与时间无关，于是我们先处理出：

 $sumc[i]=sumc[i-1]+(sumc[i-1]\times dc+c0)/(1-dc)$ 

再得到：

 $sumt[i]=sumt[i-1]+t0+sumc[i]\times dt$ 

------------

接下来考虑如何求解。

设 $dp[i][j]$ 表示在跑完第 $i-1$ 圈也就是开始跑第  $i$ 圈，并且在下次加油前一次性跑 $j$  圈的最短时间。

可以得到转移式为：

 $dp[i][j]=\min(dp[i][j],dp[i-k][k]+sumt[j]+in+add\times sumc[j])$ 

但并没有这么简单，因为题目还要求输出初始载油量，比赛过程中进站加油的次数。对于每次加油，输出之前已经跑过的圈数和这次加油所加的油量。

所以我们在更新 $dp$ 数组时，要记录其前驱，在输出时向上回溯得到答案。

## 代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N=505;

int n,ans;
double t0,dt,c0,dc,in,add,sum,ansc;
double sumc[N],sumt[N],dp[N][N];
double ans1[N][N];
int ans2[N][N];

inline void init(){
	cin>>n;//总圈数 
	cin>>t0;//空车一圈耗时
	cin>>dt;//多带1升油一圈所增加的时间
	cin>>c0;//空车一圈耗油
	cin>>dc;//多带1升油一圈所增加的油耗
	cin>>in;//进站耗时
	cin>>add;//每加一升油耗时
	memset(dp,0x7f,sizeof(dp));
}

inline double solve(int x,int y){
	if(ans1[x][y]==1) return sumc[x-1];
	else return solve(ans1[x][y],x-ans1[x][y]);
}

inline void write(int x,int y){
	if(ans1[x][y]){
		write(ans1[x][y],x-ans1[x][y]);
		printf("%d %.3lf\n",x-1,sumc[y]);
	}
}

int main(){
	init();//读入
	for(int i=1;i<=n+2;i++)
		sumc[i]=sumc[i-1]+(sumc[i-1]*dc+c0)/(1-dc);//每次跑i圈的耗油量 
	for(int i=1;i<=n+2;i++)
		sumt[i]=sumt[i-1]+t0+sumc[i]*dt;//每次跑i圈的耗时 
	for(int i=0;i<=n;i++) 
		dp[1][i]=sumt[i];//初始化dp数组 
	for(int i=2;i<=n+1;i++){//dp过程 O(n^3) 
		for(int j=1;j<=n+1;j++){
			for(int k=1;k<=n+1;k++){
				if(i-k<1) break;
				sum=dp[i-k][k]+sumt[j]+in+add*sumc[j];
				if(sum<dp[i][j]){//记录前驱 
					dp[i][j]=sum;
					ans1[i][j]=i-k;
					ans2[i][j]=ans2[i-k][k]+1;
				}	
			}
		}
	}
	ans=n;
	for(int i=n;i>=1;i--){//记录答案 
		if(dp[i][n-i+1]<dp[ans][n-ans+1])
			ans=i;
	}
	if(ans==1) ansc=sumc[n];
	else ansc=solve(ans,n-ans+1);
	printf("%.3lf %.3lf %d\n",dp[ans][n-ans+1],ansc,ans2[ans][n-ans+1]);
	write(ans,n-ans+1);//回溯比赛过程并输出 
	return 0;
}
```


---

## 作者：是青白呀 (赞：0)

前两篇题解的时间复杂度都是 $O(n^3)$，而很明显这道题的dp时间复杂度可以很简单的写成 $O(n^2)$。

可以发现，我们只需要加刚好够到下次加油的油量即可。所以与前两篇题解相似，我们可以先处理出一次性跑 $i$ 圈所需要的油量和时间。
```cpp
sumy[i]=sumy[i-1]+(y+sumy[i-1]*dy)/1.0/(1-dy);
sumt[i]=sumt[i-1]+t+dt*sumy[i];
```
其中 $t$ 代表空车一圈的时间，$dt$ 代表每增加一升油时间增量；$y$ 代表空车一圈油量，$dy$ 表示每增加一升油跑一圈耗油增量。

设 $dp[i][j]$ 表示跑完第 $i$ 圈后，再跑 $j$ 圈，所用的时间总量（注意：此处的时间总量从比赛开始计算）。先可以用 $O(n)$ 处理出跑完 $i$ 圈所需要的最短时间,再用 $O(n)$ 处理出再跑 $j$ 圈所需要的时间。则：

$dp[i][j]=\min(dp[k][i-k],0<k<i)+sumt[j]+tj+sumy[j]\times ty$

其中，$tj$ 表示进站时间，$ty$ 表示加一升油的耗时。

为了输出每次加油的情况，可在处理跑完 $i$ 圈所需要的最短时间时，记录最短时间所对应的上一个加油时间，也就是上面式子中的 $k$。最后从 $n$ 往回遍历一次即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,inf=0x3f3f3f3f;
int n,ans1[N];
double t,dt,y,dy,tj,ty;
double sumy[N],sumt[N],dp[N][N],ans2[N];
int pre[N];
int main(){
	scanf("%d%lf%lf%lf%lf%lf%lf",&n,&t,&dt,&y,&dy,&tj,&ty);
	for(int i=1;i<=n;i++){
		sumy[i]=sumy[i-1]+(y+sumy[i-1]*dy)/1.0/(1-dy);
		sumt[i]=sumt[i-1]+t+dt*sumy[i];
		dp[0][i]=sumt[i];
	}
	double ans;
	for(int i=1;i<=n;i++){
		double mint=inf;
		for(int j=0;j<i;j++){
			if(mint>dp[j][i-j]){
				mint=dp[j][i-j];
				pre[i]=j;
			}
		}
		if(i==n)ans=mint;
		for(int k=1;k<=n-i;k++)
			dp[i][k]=mint+sumt[k]+tj+sumy[k]*ty;
	}
	printf("%.3lf ",ans);
	int cnt=0,la=n;
	double st;
	if(pre[n]==0)st=sumy[n];
	for(int i=pre[n];i;i=pre[i]){
		cnt++;
        ans1[cnt]=i;//记录加油时已经跑完的圈数
        ans2[cnt]=sumy[la-i];//记录加的油量
        la=i;
        if(pre[i]==0)st=sumy[i];
	}
	printf("%.3lf %d\n",st,cnt);
	for(int i=cnt;i>=1;i--)
	    printf("%d %.3lf\n",ans1[i],ans2[i]);
	return 0;
}
```
tips：虽然样例中一行的各个数据间有两个空格，但其实只需要输出一个空格即可。

---


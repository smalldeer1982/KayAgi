# [湖南集训] 大新闻

## 题目描述

有一个在 [0,n) 内等概率随机选择的整数，记其为 x。我们需要在 [0,n)内找到某一个整数 y，使得 x ⊕ y 达到最大值。这里 ⊕ 代表异或。

问题在于，有可能对 x 进行了加密。情报显示，没有被加密的概率为 p。我们决定采取这样的策略：如果 x 没有被加密，那么我们选出使得 x ⊕ y 最大的 y；否则，我们在 [0,n) 内等概率随机选择一个整数作为 y。

请求出 x ⊕ y 的期望值。


## 说明/提示

考虑样例一。如果 x 没有被加密，那么可能的 x 与对应的 y 的取值如下：

 ![](https://cdn.luogu.com.cn/upload/pic/6855.png) 

此时的期望值为 8/3。

如果大新闻被加密了，那么可能的 x 和 y 的取值如下：

 ![](https://cdn.luogu.com.cn/upload/pic/6856.png) 

此时的期望值为 12/9 = 4/3。

所以总的期望值为 2。


所有测试点的数据规模如下：

 ![](https://cdn.luogu.com.cn/upload/pic/6857.png) 

对于全部测试数据，$1 \le n \le 10^{18}$。


## 样例 #1

### 输入

```
3 0.5```

### 输出

```
2.000000```

## 样例 #2

### 输入

```
123456 0.5```

### 输出

```
98063.674346```

# 题解

## 作者：wlj_55 (赞：13)

[传送门](https://www.luogu.org/problem/P3898)
## 题意简述
有两个数$x,y$，其中$x$是随机生成的$[0,n)$间一个正整数，$y$有$p$的概率为$[0,n)$间一个数，使得$x\space xor\space y$最大，有$(1-p)$的概率生成方式同$x$，求$x\space xor \space y$的期望值。

## 解题思路

我们先考虑暴力的解法。

### 35pts

$n\le100$，随便怎么暴力都可以过。

当$p=0$时，即求

$$\frac{\sum_{i=1}^n\sum_{j=1}^n i\space xor\space j}{n^2}$$

直接两重循环求解即可，时间复杂度$O(n^2)$，记得开$double$

当$p=1$时，我们只需对上述情况的第二层循环做出微调，将求和改为求最大值，再讲每一个$i$所对应的最大值分别相加即可。

代码略。
### 50pts
我们可以观察到后面$15pts$的数据是$2^k$的形式，那么它们间一定有着一些特殊规律。

经~~打表~~检验得：

当$p=0$时，答案为$\frac{n-1}{2}$

当$p=1$时，答案为$n-1$

下面给出证明：

首先，在$p=1$时，对于每个数$x$，总有一个数$y∈[0,n)$使得$x\space xor \space y=n-1$，所以期望为$\frac{n(n-1)}{n}=n-1$

在$p=0$时，我们首先有一个结论：
$$x\space xor\space i+x\space xor\space (2^k-i-1)=2^k-1\qquad i∈[0,2^k)$$

证明也很简单，~~手玩一下就好了。~~

所以我们对$[0,n)$间数两两配对，求得期望为$\frac{n\times \frac{n\times(n-1)}{2}}{n^2}=\frac{n-1}{2}$

### 100pts
由于这里有$0\le p\le1$的情况，所以我们要先解决这种情况。

设$P$为总的期望值，$P_1$为$p$取$0$时的期望，$P_2$为$p$取$1$时的期望，

由期望的一些基本知识可以很容易的推出

$$P=(1-p)\times P_1+p\times P_2$$

那么下面就是如何计算$P_1,P_2$的问题了。

先讨论$p=0$时的情况，

我们设对于两个数异或起来的值，第$i$位为$1$为事件$A$，第$j$位为$1$为事件$B$，由位运算的性质知$A,B$相互独立，故我们可以分开计算。

我们再设从$[0,n)$中选出一个数，其二进制第$i$位为$1$的概率为$p_i$，那么刚才的答案就是

$$\sum_{i=0}^{\log n}2\times p_i\times (1-p_i)\times2^i$$

考虑对于区间$[0,2^{k})$，一定有区间$[0,2^{k-1})$的所有数的第$k$位均为$0$，区间$[2_{k-1},2^k)$的所有数第$k$位均为$1$。

然后我们考虑区间$[0,n)$，那么必定有区间$[S\times 2^{k},S\times2^k+2^{k-1})$中的数第$k$位为0，区间$[S\times2^k+2^{k-1},(S+1)\times2^{k+1})$中数的第$k$位为0，所以第$k$位为1的数的个数是：

$$\lfloor\frac{n}{2^{k+1}}\rfloor\times 2^k+max(n\space mod\space2^{k+1}-2^k,0)$$

故概率$p_i$为
$$\frac{\lfloor\frac{n}{2^{k+1}}\rfloor\times 2^k+max(n\space mod\space2^{k+1}-2^k,0)}{n}$$
时间复杂度$O(\log n)$

我们再来考虑$p=1$时的情况（~~比较毒瘤~~）

我们设$f(x)$为$[0,n)$内使$x\space xor\space f(x)$最大的$f(x)$的值

如果没有范围的限制的话，$f(x)$应为$x$按位取反后的值，现在多了一个$n$的限制，那我们可以考虑用一种贪心的手法保留高位的$1$，如果某一位取$1$会使$f(x)\ge n$，那么这一位就只能取$0$。

我们考虑最高的$i-1$位$(i-1\ge0)$和$n-1$的前$(i-1)$位相同的所有的$x$对答案的贡献，我们考虑$n-1$与$x$的第$i$位，有下列情况：

$1.n-1$的第$i$位为$0$，由于$x\le n-1,f(x)\le n-1$，所以$x$的第$i$位和$f(x)$的第$i$位必须为$0$。

$2.n-1$的第$i$位为$1$，那么$x$第$i$位的取值又可以分两种情况：

①$:x$的第$i$位为$1$，那么$f(x)$的第$i$位为$0$，且以后的位数一定可以取$x$取反后的值。

②$:x$的第$i$位为$0$，那么$f(x)$的第$i$位为$1$，但还有后面的限制。

每次处理时$n-1$的规模将减半，故时间复杂度为$O(\log n)$

### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
double solve1(ll n){
	double ret=0;
	ll Pow=0,tmp=n-1;
	while(tmp!=0){
		Pow++;
		tmp>>=1;
	}
	for(int i=Pow;i>0;i--){
		ll nw=(n>>i)*(1LL<<i-1)+min(n-(n>>i<<i),1LL<<i-1);
		double p=double(n-nw)/n;
		ret+=(1.0-p)*(1LL<<(i-1))*p;
	}
	return ret*2.0;
}
double solve2(ll n){
	if(n==1)  return 0.0;
	double ret=0.0;
	ll v=1LL,delta,num,tmp=n-1;
	n--;
	while(v<=tmp){
		v<<=1;
	}
	delta=v-1LL;
	v>>=1;
	ret+=(double)delta*(n-v+1);
	ret+=(double)v*v;
	num=v,delta>>=1;
	while(v!=1){
		v>>=1,delta>>=1;
		if(n&v){
			ret+=(double)num*v;
			ret+=(double)(num>>1)*delta;
			num>>=1;
		}
		else
		  ret+=(double)(num>>1)*v;
	}
	return ret/(double)(n+1);
}
int main(){
	ll n;
	double p;
	scanf("%lld%lf",&n,&p);
	double p1=solve1(n),p2=solve2(n),ans=(1.0-p)*p1+p*p2;
	printf("%.6lf\n",ans);
}

```
如果大家有不懂的可以问我，我会尽我所能解答。

---

## 作者：dead_X (赞：8)

## 前言
作为一名【】，在写完 P3701 之后我就来写这题了，很快啊！
## 思路
这个题很傻逼，就在于其实你是**知道这个数有没有被加密**的。

所以你要解决的其实就是两个子问题：

$$\frac{1}{n^2}\sum_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}(i\oplus j)$$
$$\frac{1}{n}\sum_{i=0}^{n-1}\max\limits_{j=0}^{n-1}(i\oplus j)$$

两个东西分别对应加密了和没加密。
## Subtask $1$
第一个问题比较简单。

由于期望的线性和位运算每位之间相互独立的性质，我们直接拆开柿子按位考虑。于是，答案变成了以下形式：

$$\sum_{i=0}^{\log n}2p_i(1-p_i)2^i$$

其中 $p_i$ 为这第 $i$ 位为 $1$ 的数的数量除以 $n$，显然很好计算。
## Subtask $2$
第二个问题比较困难，我大概想了 $15$ 分钟左右。

考虑一个 $O(n\log a_i)$ 的贪心做法：

设最优匹配为 $y$，从高到低按位考虑，如果 $x$ 这位是 $1$ 就跳过，不然如果 $y$ 加上这一位对应的值仍然小于 $n$ 就加上。

不难发现这样的决策很像一个东西，那就是**数位 dp**。在数位 dp 中的 $flag$ 表示这一位是否“顶格”。例如最大值为 $114514$，前三位填了 $114$，那么第四位就“顶格”了。

诶，等等，数位 dp？

我们突然发现，在 $O(n\log a_i)$ 的做法里面，计算过程中仅仅记录了**当前位**和**是否顶格**两个状态，显然状态数是 $O(\log n)$ 级别的。于是我们可以改进一下这个 dp，同时对于所有数跑，问题就迎刃而解了。

有一点小细节。
## 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
map<pair<int,int>,long double> mp;
long double calc(int x,int d,int g)
{
	if(!d) return 0;
	long double p=1.0L*min(d,x-g)/min(d<<1,x-g);
	if(x-g>=(d<<1)) g=0;
	if(mp[make_pair(d,g)]) return mp[make_pair(d,g)];
	if((x-1)&d) return mp[make_pair(d,g)]=p*(calc(x,d>>1,g)+d)+(1.0L-p)*((d<<1)-1);
	else return mp[make_pair(d,g)]=p*calc(x,d>>1,g)+(1.0L-p)*(calc(x,d>>1,g+d)+d);
}
long double f0(int x)
//没有被加密 
{
	if(x==1) return 0; 
	int i=1;
	while((i<<1)<x) i<<=1;
	return calc(x,i,0);
}
long double f1(int x)
//被加密 
{
	long double ans=0;
	for(int i=1; i<x; i<<=1)
	{
		int t=i<<1;
		long double g=1.0L*(x/t*i+min(i,x%t))/x;
		ans+=2.0L*i*g*(1.0L-g); 
	}
	return ans;
}
signed main()
{
	int n=read();
	long double p;
	scanf("%Lf",&p);
	printf("%.6Lf\n",p*f0(n)+(1.0L-p)*f1(n));
	return 0;
}


```

---

## 作者：clamee (赞：5)

一个不算太难期望题。~~这套题好妙啊~~

对于第一问，我们如果考虑 $n-1$ 第 $i$ 位的情况：

设 $now$ 为当前考虑的系数。
 
- 如果这一位为 1， 那么答案要加上 $2^i\cdot now+2^i\cdot (now-2^i+1)$，然后将 now 赋为 $2^i-1 ,i--$ 继续求解。

- 如果这一位为 0， 那么答案要加上 $2^{2i-1}$ ，将 $now/2,i--$ 然后继续求解。此时需要注意权值系数要乘 2.

对于第二问，就较为简单了。

只要分别考虑每一位异或唯一的概率乘以这一位的期望即可。

以下是代码部分：

```
#include<bits/stdc++.h>
using namespace std;
#define int __int128
long long n,tot;
long double ans1,ans2,p;
void sol(int tt,int now,int lim,int w)
{
	if(lim<0ll)return;
	if((tt>>lim)&1ll)
	{
		int t=now-(1ll<<lim)+1ll;
		ans1+=w*t*((1ll<<lim)-1ll);
		ans1+=w*(now+1ll)*(1ll<<lim);
		sol(tt,now-t,lim-1ll,w);
		return;
	}
	else
	{
		int t=now-(1ll<<lim)+1ll;
		ans1+=w*(1ll<<lim)*t;
		sol(tt,now>>1ll,lim-1ll,w*2ll);
		return;
	}
}
signed main()
{
	scanf("%lld%Lf",&n,&p);
	long long lim=1ll,now=n-1ll,sum=0ll;
	while((1ll<<lim)<=(n-1ll))lim++;
	lim--;
	sol(n-1,n-1,lim,1);
	ans1/=n;
	long double inv=1.0/n/n;
	for(int i=n-1,lim=1;i;i>>=1ll,lim<<=1ll)
	{
		int t0=((i)>>1ll)*lim,t1=((i)>>1ll)*lim;
		if(((i)&1ll))t1+=(n-1ll)%(lim)+1ll,t0+=lim;
		else t0+=(n-1)%(lim)+1ll;
		ans2+=2ll*inv*t0*t1*lim;
	}
	printf("%.10Lf",ans1*p+ans2*(1.0-p));
}
```

---

## 作者：phoebuszhu (赞：2)

本题首先要搞懂题目要让你求什么。

很明显，本题当 $0<q<1$ 时，$S_0,S_1$ 两个问题都是要求的。

由期望的公式 $E(x)=\sum p(x)·d(x)$，所以很明显，$E=q\times S_1+(1-q)\times S_0$。

接下来，我们就要求 $S_0,S_1$。

### P1. 求 $S_1$

首先，我们来求一下 $S_1$。

由于加密了，所以我们是盲选 $y$ 的，也就是说，$S_1=\dfrac{1}{n^2}\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}(i\oplus j).$

很明显，我们可以按位做。

设第 $i$ 位选到 $0$ 的概率为 $p_i$，那么我们就可以知道第 $i$ 位对答案的贡献为： 

$$p_i\times(1-p_i)\times 2^{i+1}$$

我们来具体分析这个式子。

$p_i$ 就是 $x_i$ 是 $0$，$1-p_i$ 就是 $y_i$ 是 $1$，$2^i$ 是这一位的贡献，$2$ 为 $(x,y)$ 是有序的，所以要乘 $2$。

所以 $n^2S_1=\sum \limits_{i=0}^{\log (n-1)}p_i\times (1-p_i)\times 2^{i+1}$。

### P2. 计算 $S_0$（数位dp） 

接下来是 $S_0$ 的情况。

我们考虑贪心。

从高到低，如果第一位可以填 $1$ 就填 $1$，否则就填 $0$。

好一个数位 dp 的思想啊。

首先回顾一下数位 dp 吧。

数位 dp 是一个类似于记忆化的方法。

简单点讲，把 $n$ 转为二进制。

在本题中，第 $i$ 位顶格的定义就是前 $i$ 位均与 $n$ 同样。

设状态 $f(i,j,0/1)$ 为第 $i$ 个位置，填的 $j$，当前位置是否顶格对于答案的贡献是多少。

那转移公式是好想的，直接记忆化即可。

我们会发现，状态数是 $O(\log n)$ 的，转移复杂度 $O(1)$。

总复杂度 $O(\log n)$。

最终答案很明显是 $f(n,0/1,0/1)$。

### P3. 计算 $S_1$（数位 dp）

我们可以用数位 dp 的思想，但是不一定要实际写数位 dp。

小学的时候我们学过，$[1,2025]$ 中有多少个 $5$。

我们可以数 $[0001,2000],[2001,2020],[2021,2025]$ 这三段，分别是从前向后的一位一位固定。

我们也可以用这种思想来做。

可以找到一个性质，二进制数的第 $i$ 位的循环节为 $0(2^{i}个0),1(2^{i}个 1)$ 这样的循环节。

性质应用请看： [[ABC356] Masked Popcount](https://www.luogu.com.cn/problem/AT_abc356_d)。

所以，对于 $i$ 这一位，我们可以先把 $n$ 分为 $2^{i+1}$ 段，然后就可以整段的加贡献了。

当然，对于零散的段落，很明显是先 $0$ 后 $1$，用 if 判断即可。

这里给一个表格感性理解一下：

| 第 $i$ 位 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ | $11$ | $12$ | $13$ | $14$ | $15$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |:----------: |
| $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$|
| $2$ | $0$ | $0$ | $0$ | $0$ | $1$ | $1$ | $1$ | $1$ | $0$ |$0$  | $0$ | $0$ | $1$ | $1$ | $1$ |$1$ |
| $1$ | $0$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |
| $0$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |$0$  | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$|

这样就能算出第 $i$ 位为 $1$ 的概率了。

代码如下：

```cpp
p[i]=n/(1<<(i+1))*(1<<i);
p[i]+=1*max(n%(1<<(i+1))-(1<<i),0);
p[i]/=n
```
然后期望一下即可。

这个复杂度也是 $O(\log n)$ 的。

### P4. 总结

所以，本题的总复杂度为 $O(\log n)$。

代码难度不高，但是思维深度非常之高，需要选手对于位运算 / 数位dp 有深刻的了解。

---


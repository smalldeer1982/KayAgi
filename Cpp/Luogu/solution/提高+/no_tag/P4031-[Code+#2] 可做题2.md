# [Code+#2] 可做题2

## 题目背景

“codeplus比赛的时候在做什么？有没有空？能来解决丢番图方程问题吗？”sublinekelzrip这样问qmqmqm。


当然，qmqmqm并不会丢番图方程问题，所以sublinekelzrip改为提出了另一个题目，现在请你帮助qmqmqm解决这个题目。


## 题目描述

这个问题是这样的：


若一个数列$a$满足条件$a_n=a_{n-1}+a_{n-2}$,$n \geq 3$,而$a_1,a_2$为任意实数，则我们称这个数列为广义斐波那契数列。


现在请你求出满足条件$a_1=i$，$a_2$为区间$[l,r]$中的整数，且$a_k mod p = m$的广义斐波那契数列有多少个。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/12655.png) 

对于所有数据，$0 \leq l \leq r$,$1 \leq p \leq 10^9$,$0 \leq m < p$,$T=10$,$0 \leq i \leq 10^{18},k \geq 3$。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/卢政荣 命题/卢政荣 验题/吕时清，茹逸中，王聿中

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
6
2 17 68 3 23 1
1 17 68 3 57 1
5 17 68 10 11 9
5 17 68 10 71 9
10 17 68 11 12 3
10 17 68 8 6 4```

### 输出

```
3
1
4
1
5
9```

# 题解

## 作者：Great_Influence (赞：5)

参加div1后唯一A的题目。。。。。。

设$a_2=x$。先推式子，暴力算出前几项，发现


$a_z=iFi[z-3]+Fi[z-2]x$


(Fi为斐波那契数列，且Fi[0]=1)

所以

$a_k=iFi[k-3]+Fi[k-2]x\equiv m\pmod p$


即

$Fi[k-2]x\equiv m-iFi[k-3]\pmod p$


设$Q=m-iFi[k-3]$，则


$Fi[k-2]x\equiv Q\pmod p$


$Fi[k-2]x=Q+py$


$Fi[k-2]x-py=Q$


同余方程，用扩展欧几里得求解得出x的通解公式，在利用通解公式来计算x在[l,r]内解个数。时间复杂度，$O(log_2k)$。


代码：


```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    #define Chkmax(a,b) a=a>(b)?a:(b)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
    #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
    #endif
    }
    long long g,l,r,k,mod,m;
    void init()
    {
        read(g);read(l);read(r);read(k);read(mod);read(m);
    }
    long long a[2][2]={0ll,1ll,1ll,1ll},s[2][2],base[2][2];
    inline void tim(long long a[][2],long long b[][2])
    {
        long long c[2][2]={0ll};
        Rep(i,0,1)Rep(j,0,1)Rep(k,0,1)(c[i][j]+=a[i][k]*b[k][j])%=mod;
        Rep(i,0,1)Rep(j,0,1)a[i][j]=c[i][j];
    }
    long long ext_gcd(long long a,long long b,long long &x,long long &y)
    {
        if(!b){x=1ll;y=0ll;return a;}
        long long ans=ext_gcd(b,a%b,x,y);
        swap(x,y);
        y=y-a/b*x;
        return ans;
    }
    void solve()
    {
        --k;
        memcpy(base,a,sizeof a);
        s[0][0]=s[1][1]=1;s[0][1]=s[1][0]=0;
        for(;k;k>>=1,tim(base,base))if(k&1)tim(s,base);
        g%=mod;
        m-=s[0][0]%mod*g%mod;m%=mod;m+=mod;m%=mod;
        long long y,z;
        long long gcd=ext_gcd(s[1][0],mod,y,z);
        if(m%gcd!=0)
        {
            printf("0\n");
            return;
        }
        y*=m/gcd;
        if(y>=0)(y%=(mod/gcd))-=mod/gcd;
        printf("%lld\n",(r-y)/(mod/gcd)-(l-1-y)/(mod/gcd));
    }
    int main(void){
        file();
        int _;
        read(_);
        while(_--)
        init(),
        solve();
        return 0;
}
```

---

## 作者：DEMAC (赞：2)

可做题。

注意到 $\forall k\in \mathbb{N^*}$ ，有 $a_k=\alpha(k)a_1+\beta(k)a_2$.

尝试把系数关于 $k$ 的表达式求出来。

赋值法，简单令 $a_1=1,a_2=0$ 可推得 $\alpha(x)=a_x=\text{Fib}(x-2)$，同理推得 $\beta(x)=a_x=\text{Fib}(x-1)$。$^\dagger$

于是就有：

$$\begin{aligned}
  \alpha(k)a_1+\beta(k)a_2 &\equiv a_k &\pmod p\\
  \text{Fib}(k-2)a_1+\text{Fib}(k-1)a_2&\equiv a_k &\pmod p \\
  \text{Fib}(k-1)a_2&\equiv a_k -\text{Fib}(k-2)a_1 &\pmod p\\
  \text{Fib}(k-1)a_2+yp&= a_k -\text{Fib}(k-2)a_1
\end{aligned}$$

令等号右边为 $A$, 将 $a_2,y$ 看做未知数，利用扩展欧几里得可求解 $a_2$ 的 $1$ 个特解 $a_2'$，全体解有形式 $a_2=a_2'+\dfrac{A}{\gcd(\text{Fib}(k-1),p)}n,\ (n\in\mathbb{Z})$。

题目要求求解满足 $a_2\in[l,r]$ 的解的个数，于是我们利用整点个数公式得到答案.

值得注意的是，此处 $k$ 值较大，需要用矩阵加速递推。

**code:**

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

int p;

struct Mat {
	int a[2][2];
	Mat(){memset(a,0,sizeof a);}
	Mat operator*(const Mat& b) const {
		Mat ret;
		for(int i=0;i<=1;i++) {
			for(int j=0;j<=1;j++) {
				for(int k=0;k<=1;k++) {
					ret.a[i][j]+=a[i][k]*b.a[k][j];
					ret.a[i][j]%=p;
				}
			}
		}
		return ret;
	}
	
	Mat qpow(int p) {
		Mat ret,tmp=*this;
		ret.a[1][1]=1;
		ret.a[0][0]=1;
		while(p>0) {
			if(p&1) ret=ret*tmp;
			p>>=1;
			tmp=tmp*tmp;
		}
		return ret;
	}
};

void exgcd(int a,int b,int &g,int &x,int &y) {
	if(b==0) {
		g=a,x=1,y=0;
		return;
	}
	exgcd(b,a%b,g,y,x);
	y-=a/b*x;
}

main() {
	Mat base,trans;
	base.a[0][1]=1;
	trans.a[0][0]=0;
	trans.a[0][1]=trans.a[1][0]=trans.a[1][1]=1;
	int T;
	cin>>T;
	while(T--) {
		int f,l,r,k,m;
		cin>>f>>l>>r>>k>>p>>m;
		Mat res=trans.qpow(k-1);
		f%=p;
		//?*ra[1]-_p==A
		int x=0,_=0,g,A=(m-(res.a[0][0]*f%p)+p)%p;
		exgcd(res.a[0][1],p,g,x,_);
		if(A%g) {
			cout<<"0\n";
			continue;
		}
		x *= (A / g), p /= g;
		if(x >= 0) x = (x % p - p);
		cout<<(r - x) / p - (l - 1 - x) / p<<'\n';
	}
}
		
```
**$\dagger$ Hint:**
| $x$ | $\cdots$ | $-1$ | $0$ | $1$ | $2$ | $3$ |$\cdots$|
| :-: | :-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $\text{Fib}(x)$ | $\cdots$ | $1$| $0$|$1$|$1$|$2$|$\cdots$|

update 2024/08/16: fixed code.

---

## 作者：fight_for_humanity (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P4031)。

[Better experience](https://www.cnblogs.com/fight-for-humanity/p/18363122)。

### Analysis

打模拟赛时没有往当前数列与最基本的斐波那契数列的关系上想。

看到斐波那契以及如此之大的数据范围，应该第一时间想到矩阵快速幂。

看到 $a\equiv m \pmod{p}$ 应该第一时间要想到用 $\operatorname{exgcd}$ 求解。

意识到单纯枚举 $a_2$ 是达不到正解要求的，不能由 $a_2$ 出发去判断，而是应由条件出发去统计答案。

若果直接扩展欧几里得计算的话算出来的是 $a_k$，难以映射到 $[l,r]$ 区间内，因此将其拆为与 $a_1,a_2$ 有关的式子再进行求解。

这样解法就呼之欲出了，我们将数列列出来看看：

```plaintext
标号:   1 2 3   4    5     6
原数列: 1 1 2   3    5     7
新数列: a b a+b a+2b 2a+3b 3a+5b
```
发现对于新数列第 $k$ 个数，其值为 $\operatorname{fib}(k-2) \cdot a + \operatorname{fib}(k-1) \cdot b$。

现在就可以化式子了。

$$
\begin{aligned}
a_k = \operatorname{fib}(k-2) \cdot a_1 + \operatorname{fib}(k-1) \cdot a_2 \\
\operatorname{fib}(k-2) \cdot a_1 + \operatorname{fib}(k-1) \cdot a_2 \equiv m \pmod{p} \\
\operatorname{fib}(k-1) \cdot a_2 \equiv m - \operatorname{fib}(k-2) \cdot a_1\pmod{p} \\
\operatorname{fib}(k-1) \cdot a_2 + b \cdot p = m - \operatorname{fib}(k-2) \\
\end{aligned}
$$

最后用 $\operatorname{exgcd}$ 求解即可。


### CODE
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int l,r,k,p,m,a1;
inline int add(int x,int y){ return x + y >= p ? x + y - p : x + y; }
inline void toadd(int &x,int y){ x = add(x,y); }
inline int mul(int x,int y){ return x * y % p; }
inline int sub(int x,int y){ return x - y < 0 ? x - y + p : x - y; }
struct Mat{
	int c[2][2];
	Mat(){ memset(c,0,sizeof c); }
	Mat(int op){ for(int i = 0;i<2;++i)for(int j = 0;j<2;++j)c[i][j] = (i == j); }
	Mat(int x,int y){ c[1][0] = c[1][1] = 0, c[0][0] = x, c[0][1] = y; }
	Mat friend operator *(const Mat &a,const Mat &b){
		Mat res;
		for(int i = 0;i<2;++i)
			for(int j = 0;j<2;++j)
				for(int k = 0;k<2;++k)
					toadd(res[i][j],mul(a[i][k],b[k][j]));
		return res;
	}
	int * operator [](const int i){ return c[i]; }
	const int * operator [](const int i)const{ return c[i]; }
}bas;
Mat fpow(Mat a,int k){
	Mat res(2);
	while(k){
		if(k & 1)res = res * a;
		a = a * a;
		k >>= 1;
	}
	return res;
}
int exgcd(int a,int b,int &x,int &y){
	if(b == 0){
		x = 1, y = 0;
		return a;
	}	
	int d = exgcd(b,a%b,x,y);
	int t = x;
	x = y;
	y = t - a/b*y;
	return d;
}
//#define printf printf(">>> "),printf
void solve(){
	scanf("%lld%lld%lld%lld%lld%lld",&a1,&l,&r,&k,&p,&m);
	a1 %= p;
	Mat fibo = fpow(bas,k-2);
	
	
	int Q = m - mul(fibo[0][1],a1);
	int x,y,a = fibo[0][0],gcd = exgcd(a,p,x,y);
	
	if(Q % gcd != 0)return puts("0"),void();
	int B = p / gcd;
	int res = (x*Q/gcd%B+B)%B;
//	res + B * k ∈ [l,r]
//	res + (l - res)/B*B
	if(res > r)puts("0");
	else{
		if(l < res)printf("%lld\n",(r - res) / B + 1);
		else printf("%lld\n",(r - res) / B - (l - res - 1) / B);
	}
}
signed main(){
	bas[0][0] = bas[0][1] = bas[1][0] = 1, bas[1][1] = 0;
	int T; scanf("%lld",&T);
	while(T--)solve();
	return 0;
}
```

---


# [JSOI2010] 旅行

## 题目描述

2009 的新年即将到来，JSK 决定开车去拜访他小镇上的所有朋友，由于他在每一个街道都有一个朋友，他开始考虑如何使旅程尽可能地短。很快他意识到最短的方法就是经过所有的街道一次且仅一次。很自然地，他希望能在旅行结束时回到开始的地方，即他父母的房子。

JSK 计划他的环城旅行：城镇的街道编号为 $1\sim n$，交汇点编号为 $1\sim m$ ，没有哪个交汇点连接了多于 $44$ 个街道。所有的交汇点有着不同的数字编号。

每个街道恰好联接着两个交汇点，任两个街道的数字编号不同。如果存在一个以上满足条件的旅行路径，则按旅行经过的街道顺序排列街道编号，选择其字典序最小的那一个路径。

由于 JSK 连一条这样的街道都无法找到，只有请你帮他写一个程序来找这样最短的旅行路径。如果不存在这样的路径则打印出一条信息。假定 JSK 住在和街道 $1$ 相连的编号较小的那个交汇点。

城镇中每一个街道都是相同的（不是死胡同），任两个街道之间有路可以达到。这些街道很窄因此一旦车进了一条路它不可能调头回走。


## 说明/提示

【数据范围】    
$1\le n \le 1994$，$1\le m \le 43$。

## 样例 #1

### 输入

```
1 2 1
2 3 2
3 1 6
1 2 5
2 3 3
3 1 4
0 0 0```

### 输出

```
1 2 3 5 4 6
```

## 样例 #2

### 输入

```
1 2 1
2 3 2
1 3 3
2 4 4
0 0 0```

### 输出

```
Round trip does not exist```

# 题解

## 作者：ivyjiao (赞：1)

[洛谷管理快修这题数据](https://www.luogu.com.cn/discuss/960052)。

---

三倍经验：P4038，SP9528，UVA302。

一本通提高篇的题居然还能写题解。

这题甚至比板子简单。$n\leq 44,m\leq 1995$ 是闹着玩的？

很明显就是在有向图里找一个字典序最小的欧拉回路，每次输入数据结束后，先用判断图是否满足欧拉回路的条件，满足的话跑一遍求欧拉回路的 DFS 即可，注意求的是字典序最小，要对于每个边的出度点排序，本题数据很小，不用当前弧优化。

过程是很平凡的，不会求的左转 [P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771)，和这题一模一样。

注意格式！输出格式每组数据要额外换一行，和 LOJ 不一样！这题面和输入输出格式也太恶心了点。

代码：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=2001;
int n,m,u,v,w,s,d[N],ans[N],l;
bool vis[N],e;
vector<PII>G[N];
void dfs(int u){
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i].se,w=G[u][i].fi; 
		if(vis[w]) continue;
        vis[w]=1;
		dfs(v);
        ans[++l]=w;
	}
}
int main(){
    while(cin>>u>>v){
        if(!u&&!v){
            if(!e) break;
            for(int i=1;i<=2000;i++){
                sort(G[i].begin(),G[i].end());
                if(d[i]%2){
                    cout<<"Round trip does not exist.\n";
                    goto T2;
                }
            }
            dfs(s);
            while(l>1) cout<<ans[l--]<<" ";
            cout<<ans[l--]<<endl;
            T2:;
            memset(vis,0,sizeof vis);
            memset(d,0,sizeof d);
            for(int i=1;i<=2000;i++) G[i].clear();
            s=0;
            e=0;
            cout<<endl;
            continue;
        }
        e=1;
        cin>>w;
        if(!s) s=min(u,v);
        G[u].push_back({w,v});
        G[v].push_back({w,u});
        d[u]--;
        d[v]++;
    }
}
```

---


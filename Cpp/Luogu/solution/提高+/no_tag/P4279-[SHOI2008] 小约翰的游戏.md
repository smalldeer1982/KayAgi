# [SHOI2008] 小约翰的游戏

## 题目描述

小约翰经常和他的哥哥玩一个非常有趣的游戏：桌子上有 $n$ 堆石子，小约翰和他的哥哥轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算输。

小约翰相当固执，他坚持认为先取的人有很大的优势，所以他总是先取石子，而他的哥哥就聪明多了，他从来没有在游戏中犯过错误。小约翰一怒之前请你来做他的参谋。自然，你应该先写一个程序，预测一下谁将获得游戏的胜利。

## 说明/提示

- 对于 $40\%$ 的数据，$T \leq 250$；
- 对于 $100\%$ 的数据，$T \leq 500$。

## 样例 #1

### 输入

```
2
3
3 5 1
1
1```

### 输出

```
John
Brother```

# 题解

## 作者：Ark_ (赞：44)

# 题意
反Nim游戏,两人轮流选一堆石子拿,拿到最后一个的输.问先手是否必胜.
# 分析
怎么说,分类讨论?
 - 情形1:首先考虑最简单的情况,所有石子数都为1.那么奇数堆石子为必败,偶数为必胜
 
 - 情形2:然后考虑只有一堆石子>1.那么先手一定可以通过**拿完这一堆石子**或者是**留下一个石子**,使得剩下的全部是1.而这两种操作后的局面一种是奇数个1,一种是偶数个1.所以先手一定可以留给后手奇数个1的局面,从而让后手必败,先手必胜.
 
 - 情形3:那么如果有多堆石子>1呢?可以发现,不管怎么拿,因为石子数在减少,一定会有某个人在某个时刻面临情况2(只有一堆石子大于1),那么他就必胜了.那我们来看看这种情况有什么特征.
 
	于是这就是常见的Nim游戏套路,将所有石子数异或起来后,情形2得到的值一定>0.因为>1的那一堆石子在二进制中除去末位一定还至少有一个1.所以说这时只要异或和>0就表示必胜.
    
	由于异或和为0的情况任意取都会变成异或和>0的情况,而异或和>0的情况一定有一种取石子方案使得异或和为0.那么异或和为0就表示了必败状态,而>0就表示必胜状态.

所以这道题首先特判一下情形1,然后只用异或起来看等不等于0就行了.

(我在想Anti-SG是不是可以看作两个人都希望对方赢而斗智斗勇的普通SG...)

# CODE
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
template<typename T>void read(T &num) {
	char ch; int flg=1;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;
	for(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());
	num*=flg;
}
int n, x;
int main() {
	int T; read(T);
	while(T--) {
		read(n);
		int ans = 0, sum = 0;
		for(int i = 1; i <= n; ++i) {
			read(x), ans ^= x;
			sum += (x==1);
		}
		if(sum == n) puts((n&1) ? "Brother" : "John");
		else puts(ans ? "John" : "Brother");
	}
}

```

---

## 作者：Nemlit (赞：19)

~~我怎么什么都不会啊$QAQ$博弈论怎么和期望一样玄学啊$QAQ$~~

我们分几种情况讨论：

$Case1$：只有一堆且为1，那么后手胜利

$Case2$：每一堆都是1，那么只需要判断奇偶性，奇数则先手败，偶数则后手败

$Case3$：只有一堆不是1，其余堆都是1，那么可以根据就行，先手可以选择是拿完或是那得只剩一个

$Case4$：一般情况，思考怎么转化成$Case\ 1-3$

现在题意是说：给定K堆，先手想要自己去到最后一堆他就会胜利$(Case3)$，这不就变成$nim$游戏了吗？

于是只需要把每一堆的权值异或起来即可
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
int read() {
    int x = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
int main() {
    int T = read();
    while(T --) {
        int n = read(), x, ans = 0, sum = 0;
        for(int i = 1; i <= n; ++ i) x = read(), ans ^= x, sum += x;
        if(sum == n) puts(n & 1 ? "Brother" : "John");
        else puts(ans ? "John" : "Brother");
    }
	return 0;
}

```

---

## 作者：VenusM1nT (赞：10)

这是一道经典的 $\textbf{Anti - Nim}$ 问题。  
![](https://t1.picb.cc/uploads/2020/10/26/tYOSar.png)  
先说结论：当每堆石子都只有 $1$ 个的时候分奇偶讨论，否则求异或和，若异或和 $>0$ 则先手必胜。  
再来尝试口胡一下正确性。  
![](https://t1.picb.cc/uploads/2020/10/26/tYMvgD.png)  
定义“孤单堆”为只有一颗石子的堆，“充裕堆”为石子数 $>1$ 的堆，下面定义若干状态：$\text{S/T}$ 分别代表异或和 $\not=0$ 与 $=0$ 的状态，$\text{S}/0/1/2$ 代表在 $\text{S}$ 状态下充裕堆的数量 $=0/=1/\ge2$，$\text{T}/0/2$ 代表在 $\text{T}$ 状态下充裕堆的数量 $=0/\ge2$，没有 $\text{T}1$ 是因为如果充裕堆的数量 $=1$ 则异或和不可能为 $0$。下有若干推论。
 - 显然 $\text{S}0$ 时必败，$\text{T}0$ 时必胜，因为此时是若干孤单堆，$\text{S/T}$ 分别代表奇偶状态。
 - **$\text{S}1$ 时先手必胜。** 若孤单堆为奇数则取走整堆，否则取成孤单堆。
 - $\text{S}2\to\text{T}0$ 为非法，因为不能同时取两堆，但 $\text{S}2\to\text{T}2$ 是合法的。
 - $\text{T}2\to\text{S}0$ 为非法，原因同上，但 $\text{T}2\to\text{S}2/1$ 为合法。
 - $\text{S}2$ 时先手必胜。先手直接 $\text{S}2\to\text{T}2$，此时若后手 $\text{T}2\to\text{S}2$ 则重复上面的操作，最终后手必然 $\text{T}2\to\text{S}1$，此时先手必胜。  

最终得出结论：$\text{T0,S1,S2}$ 时先手必胜，$\text{S0,T2}$ 时先手必败，也就是最上面的结论。  
大概就是这个亚子。  
![](https://t1.picb.cc/uploads/2020/10/26/tY8kz8.png)
```cpp
#include<bits/stdc++.h>
#define N 50
#define reg register
#define inl inline
using namespace std;
int n,a[N+5];
int main()
{
	reg int Time;
	scanf("%d",&Time);
	while(Time--)
	{
		reg int ans=0;
		reg bool fg=1;
		scanf("%d",&n);
		for(reg int i=1;i<=n;i++)
		{
			reg int x;
			scanf("%d",&x);
			ans^=x;
			fg&=(x==1);
		}
		if(fg) puts(ans?"Brother":"John");
		else puts(ans?"John":"Brother");
	}
	return 0;
}
```

---

## 作者：GNAQ (赞：10)

本文首发于 [随便搞搞 ICG (公平组合游戏) 和其余的博弈](https://fancydreams.ink/2018/11/06/%E9%9A%8F%E4%BE%BF%E6%90%9E%E6%90%9E-icg-%E5%85%AC%E5%B9%B3%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F/) （第五页） 欢迎围观

## 扩展 SG 博弈 - Anti-SG

### 简单的 Anti-Nim 游戏

我们定义 Anti-Nim 游戏：

有 $n$ 堆石子，双方轮流取石子。

 - 每次能从其中一堆取出任意数目的石子，不能不取。

 - 取走最后一颗石子者败。

不管别的我们先定义：

 > 如果某堆中只有 $1$ 个石子，则称为孤单堆，否则称为充裕堆。

直接给出结论：先手必胜当且仅当

- 只有偶数个孤单堆；

- 存在充裕堆且游戏的 $\mathrm{SG}$ 值不为 $0$ 。

那么接下来要证明结论：

首先第一种情况比较显然，每人每次能做的操作只有拿走一堆石子。

第二种情况呢?

首先考虑当存在多于一个充裕堆时的情况，设当前的局面为 $\mathrm{S}$ ，这时从结论可知 $\mathrm{SG} \ne 0$ ，那么根据 $\mathrm{SG}$ 函数的定义， $ \exists \mathrm{T} \text{ s.t. } \mathrm{S} \rightarrow \mathrm{T} \,,\, \mathrm{SG(T)} \ne 0 $ 。

那么先手让 $\mathrm{S}$ 变为 $\mathrm{T}$ 即可。( 又因为每次只能操作一堆，比较显然地， $\mathrm{T}$ 中一定存在充裕堆。 )

如果当前局面里只有一堆充裕堆，首先根据 Nim 的异或判定方法，显然此时的 $\mathrm{SG}$ 值不会为 $0$ ，其次，先手总可以把状态变为只有奇数个孤单堆，所以先手必胜。

另外我们还必须说明当存在充裕堆且 $\mathrm{SG}$ 为 $0$ 的时候是先手必败的，那么：

首先至少存在两堆充裕堆。因为按照 Nim 的异或判定方法，充裕堆会影响异或和的高位。所以必然有两堆以上的充裕堆使得高位异或和为 $0$ 。

那么无论先手如何决策， $\mathrm{T}$ 中必然存在一堆以上的充裕堆，根据上文可知此时另一位玩家必胜。

## 更加复杂的结论 - Anti-SG

给出 Anti-SG 游戏的定义：

- Anti-SG 游戏规定，决策集合为 $\oslash$ 的游戏者赢。

- Anti-SG 游戏其他规则与 SG 游戏相同。

对于 Anti-SG 游戏，我们也是先给出定理，再尝试证明。那么这次的定理名字叫做 Sprague Grundy - Jia Zhihao 定理，简称 SJ 定理，它说的是：

对于任意一个 Anti-SG 游戏，如果规定当局面中所有单一游戏的 $\mathrm{SG}$ 值都为 $0$ 时游戏结束，那么先手必胜当且仅当：

1. 游戏的 $\mathrm{SG}$ 不为 $0$ 且 $\exists G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) > 1 $ 。

2. 游戏的 $\mathrm{SG} = 0 $ 且 $\forall G_i \in \mathbb{G} \,,\, \mathrm{SG}(G_i) \leqslant 1 $ 。
证明：

我们还是只需要证明以下三点：

Anti-SG 的结束局面为 P-position ；
能转移到 P-position 的局面是 N-position ；
所有合法转移都是 N-position 的局面是 P-position 。
那么我们设当前的局面为 $\mathrm{S}$ ，证明如下：

[1] 局面的 $\mathrm{SG} = 0 $ 且 $\exists G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) > 1 $ 。
首先由 SG 定理我们可以知道的是此时存在至少两个单一游戏，他们的 $\mathrm{SG} > 1$ ；

又因为每次只能对一个单一游戏操作，那么$\forall \mathrm{T} \in N(\mathrm{S}) $ ， $\mathrm{T} $ 中存在至少一个单一游戏其 $\mathrm{SG} > 1 $ 。

然后根据 SG 函数的性质， $\forall \mathrm{T} \in N(\mathrm{S}) \,,\, \mathrm{SG(T)} \ne 0 $ 。

所以我们证明了在先手的任意操作之后，局面都转移至 SJ 定理中的 $(1)$ ，先手必败。

[2] 局面的 $\mathrm{SG} \ne 0 $ 且 $\forall G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) \leqslant 1$ 。
根据 SG 定理，显然只有奇数个单一游戏其 $\mathrm{SG} =1 $ 且其余单一游戏的 $\mathrm{SG} =0 $ 。

首先，如果将某个单一游戏的 $\mathrm{SG}$ 值改为大于 $1$ 的数，我们可知

游戏的 $\mathrm{SG} \ne 0$ 。
有且仅有一个单一游戏其 $\mathrm{SG} > 1$
在先手操作之后，游戏转移至 SJ 定理中的 $(1)$ ，先手必败。

其次，将某个单一游戏的 $\mathrm{SG}$ 值改为 $0$ 或 $1$ ：

仅有偶数个单一游戏其 $\mathrm{SG} = 1$ ，且其余的单一游戏其 $\mathrm{SG} =0$ ，既局面的 $\mathrm{SG} = 0$ ；
对于所有的单一游戏其 $\mathrm{SG} \leqslant 1$ 。
在先手的任意操作操作之后，局面都转移至 SJ 定理中的 $(2)$ ，先手必败。

[3] 局面的 $\mathrm{SG} \ne 0 $ 且 $\exists G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) > 1 $ 。
 首先，如果只有一个单一游戏其 $\mathrm{SG} > 1$ :

先手选择更改此单一游戏，选择将其更改为 $\mathrm{SG} = 0$ 或 $\mathrm{SG} = 1 $ 的单一游戏，使得局面中有只有奇数个 $\mathrm{SG} = 1$ 的单一游戏。

此时 (操作完成后) 根据 SG 函数的定义，为 P-position 。所以先手必胜。

其次，如果有超过一个单一游戏其 $\mathrm{SG} > 1$ :

根据 SG 函数的性质， $\exists \mathrm{T} \in N(\mathrm{S}) \text{ s.t. } \mathrm{SG(T)} = 0$ ；

因为每次最多对一个单一游戏操作，所以 $\exists G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) > 1 $ 。

此时 (操作完成后) 情况到了刚刚讨论过的 [1] , 所以先手必胜。

[4] 局面的 $\mathrm{SG} = 0 $ 且 $\forall G_i \in \mathbb{G} \text{ s.t. } \mathrm{SG}(G_i) \leqslant 1$ 。
首先如果 $\forall G_i \in \mathbb{G} \,,\, \mathrm{SG}(G_i) = 0 $ ，那么游戏结束了，先手必胜。

其次显然局面中有偶数个 $\mathrm{SG} = 0 $ 的单一游戏。先手选择任一将其 $\mathrm{SG}$ 变为 $0$ ，那么游戏出现奇数个 $\mathrm{SG} = 1 $ 的单一游戏，为 P-positon , 先手必胜。

综上， SJ 定理证毕。

----------------

**于是这题目就是板题了**

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#define ll long long
using namespace std;

int T,n,seq[5010],ans;

template<typename int_t>
void readx(int_t& x)
{
    x=0; int_t k=1; char ch=0;
    while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    x*=k;
}

int main()
{
    readx(T);
    while (T--)
    {
        readx(n);
        for (int i=1;i<=n;i++) readx(seq[i]);
        int lonely=0,full=0; ans=0;
        for (int i=1;i<=n;i++) 
        {
            if (seq[i]==1) lonely++;
            else full++;
            ans^=seq[i];
        }
        if (!full)
        {
            if (lonely%2) printf("Brother\n");
            else printf("John\n");
        }
        else
        {
            if (!ans) printf("Brother\n");
            else printf("John\n");
        }
    }
}

```

---

## 作者：SuperJvRuo (赞：8)

显然，奇数个1是必败态。我们应该想办法把局面转换成这种必败态。

当“超过1颗石子”的堆数大于1的时候，按照Nim的方法走。直到“超过1颗石子”的堆数等于1，这时将这堆石子全部取掉或剩1颗，保证非空（剩下1颗石子）的堆数为奇数即可胜利。

```
#include<cstdio>
int main()
{
    int a,t,N;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&N);
        int ans=0,sum=0;
        for(int i=0;i<N;i++)
        {
            scanf("%d",&a);
            ans^=a;
            sum+=a;
        }
        if(sum==N)
        {
            printf("%s\n",sum&1?"Brother":"John");
        }
        else
        {
            if(ans)
                printf("John\n");
            else
                printf("Brother\n");
        }
    }
    return 0;
}

```

---

## 作者：cyffff (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4279)
## 题意
$\text{Anti Nim}$ 博弈。

有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 颗，双人博弈，每次可以取走某堆石子的任意颗。取走最后一颗石子的人输，求先手是否有必胜策略。
## 思路
类似的，$\text{Anti Nim}$ 博弈的 $\text{SG}$ 函数与 $\text{Nim}$ 游戏一样，都是 $f(x)=\text{xor}_{i=1}^na_i$，当且仅当 $f(x)\ne0$ 时先手有必胜策略。

我们考虑胜利条件：

1. $f(x)=0$ （即 $2|n$）且  $a_i$ 全都是 $1$；
2. $f(x)\ne0$ 且 $a_i$ 不全都是 $1$。 

则我们可以根据 $a_i$ 是否全是 $1$ 进行分类讨论。

首先考虑 $a_i$ 全都是 $1$ 的情况。十分显然，若 $2|n$，先手必胜，否则后手必胜。

然后是至少有 $1$ 个 $a_i$ 大于 $1$ 的情况。讨论此时 $\text{SG}$ 函数 $f(x)$ 的值。

- 1.$f(x)=0$，即至少有两堆石子的颗数大于 $1$。那么操作后 $f(x)$ 定不为 $0$。则先手必败。
- 2.$f(x)\ne0$，则需将 $f(x)$ 变为 $0$ 即可，那么先手必胜。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=1e6+10,mod=998244353;
int n,fl;
int SG;
int main(){
	int T=read();
	while(T--){
		n=read(),fl=0,SG=0;
		for(int i=1;i<=n;i++){
			int x=read();
			SG^=x,fl|=x>1;
		}
		string a="John",b="Brother";
		puts((fl?(SG?a:b):(n&1?b:a)).c_str());
	} 
	flush();
}
```
再见 qwq~

---

## 作者：Shikita (赞：2)

# 一道博弈论的入门题吧
首先说说博弈论是什么：

博弈论又被称为对策论（Game Theory），既是现代数学的一个新分支，也是运筹学的一个重要学科。
博弈论主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法。 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。（以上摘自百度百科）

其中，博弈论最经典的题目就是取石子问题啦，而本题则又是一道基础的取石子题目

## 题目大意
两个人在n堆石子中轮流取，每次最少一个，最多取完这堆，取走最后一颗石子的人为负，问谁会胜利

如果不知道博弈论的人，估计深搜啊什么神奇的东西弄一弄，也就弄不出来的（不排除某些大佬）。实际上我们判断胜负只需要判断能否达到必胜态（必败态），然后逐渐往这两个状态去靠近，直到达到某个状态，判定出胜负为止。

在本题，关于必胜态和必败态有两个结论

John必胜：a1^a2^......^an=1

John必败：a1^a2^.......^an!=0

一般只需要知道这两个公式再加上特判就可以轻松做出本题啦

### 代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
int t=read(),n,ans,flag;
int main()
{
	while(t--)
	{
		n=read(),flag=1,ans=0;
		for(int i=1;i<=n;++i) 
		{
			int x=read();
			if(x!=1) flag=0;
			ans^=x;
		}
		if(flag) if(n&1) printf("Brother\n");else printf("John\n");
		else if(ans) printf("John\n");else printf("Brother\n");
	}
}
```

但是我们学习不能只是为了切掉某一题，那么我下面给出证明：

对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成aii后满足a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=x，则一定存在某个ai使得ai^x<ai一定成立。则如果我们可以将ai改变成aii=ai^x，此时a1^a2^...^aii^...^an=a1^a2^...^an^x=0。
 
对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成aii后满足a1^a2^...^ai'^...^an=0。因为异或运算性质，由a1^a2^...^an=a1^a2^...^aii^...^an可以得到ai=aii。所以将ai改变成aii不是一个合法的移动
 
所以在这道题中如果当前是必胜的话，那么就要下一个移动的人必败，所以就要改变一个ai变成aii使得原本的a1^...ai^...^an!=0变成a1^...aii...^an=0

证明完毕

呃我差不多讲完了，如果对于博弈论还想有更多了解的话，我推荐下面几个博客（不是我的）

[斐波那契博弈（Fibonacci Nim）](https://blog.csdn.net/dgq8211/article/details/7602807)

[威佐夫博弈](https://blog.csdn.net/qq_41311604/article/details/79980882)

[稍微综合版博弈论](https://blog.csdn.net/qq_33765907/article/details/51174524)

以上的博客都是我随便找的，~~才不是因为我自己没写过博弈论的博客~~


---

## 作者：yy1695651 (赞：2)

# Anti-SG游戏和SJ定理

我们不妨从最本质的Anti-Nim游戏入手。

### 描述

Alice和Bob轮流取N堆石子。每次只能从一堆中取出任意数目的石子，但不能不取。取走最后一个石子者败。

讨论

这个问题有一个结论，先手必胜当且仅当：

#### 所有堆的石子数都为1且游戏的SG值为0

#### 有些堆的石子数大于1且游戏的SG值不为0

下面给出证明。 
游戏分三种情况：

每个堆只有一个石子 

如果异或值=0，即有偶数个堆，则先手必胜（A）

如果异或值≠0，即有奇数个堆，则先手必败（B）

只存在一堆石子数>1，则先手必胜（C） 

可以发现在这种情况下，异或值一定≠0。并且可以发现，在这种情况下先手一定有一种方法使得剩下奇数个石子个数都为1的堆，即转化为B状态。所以先手必胜。

存在至少2堆石子数>1 

当异或值=0时，先手必败（D）

当异或值≠0时，先手必胜（E） 

关于这一步的证明应该把这两个状态结合来看。 

首先，参考Nim游戏的证明，当异或值=0时，无论进行怎样的操作都会使异或值≠0；而当异或值≠0时，一定存在一种移动方案，使得异或值=0，这个性质符合N,P状态的转换。 

而不断地进行这种转换，总会有一个时刻局面变成了C状态，而C状态一定是从D状态转移过来的。所以可以证明D状态总会在一个时刻必须转移到先手必胜态，即D状态是先手必败态。相应地，我们就可以证明E状态是先手必胜态。

证明结束。

### 延伸

我们来定义Anti-SG游戏

Anti-SG游戏规定，决策集合为空的游戏者赢。

Anti-SG其他规则与SG游戏相同

定理：SJ定理

对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当： 

#### 游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于 1； （单一游戏中有一个SG大于1，且整个游戏SG不等于0）

#### 游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。（每一个单一游戏SG都小于等于1，且整个游戏SG等于0）

其实我们可以类比Nim游戏与SG函数的证明方法，来感性地理解一下SJ定理的正确性。这里mex和sg的定义都是完全相同的，不再给出证明。


```
#include <cstdio>
using namespace std;
inline void read(register int &x){
    x = 0; register int f = 1;
    register char ch = getchar();
    while (!(ch >= '0' && ch <= '9')){if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int T, n, sum, winner;
bool fg;
int main(){
    read(T);
    while (T--){
        read(n);
        sum = 0;
        fg = false;
        while (n--){
            register int x; read(x);
            sum ^= x;
            if (x != 1) fg = true;
        }
        if (fg && sum == 0) winner = 2;
        if (fg && sum != 0) winner = 1;
        if (!fg && sum == 0) winner = 1;
        if (!fg && sum != 0) winner = 2;
        if (winner == 1) printf("John\n");
        else printf("Brother\n");
    }
    return 0;
}

```


参考博客

https://blog.csdn.net/Clove_unique/article/details/53868567 


---

## 作者：mzyc_jx (赞：1)

[[SHOI2008]小约翰的游戏](https://www.luogu.com.cn/problem/P4279)

博弈论最经典的题目就是取石子问题，而本题则又是一道基础的取石子题目，所以蒟蒻我一会儿就切了这道题。

## 题意：

两人在 n 堆石子中轮流取，每次最少一个，最多取完这堆，取走最后一颗石子的人为负，问谁会胜。

## 思路：

此题需要分以下几种情况讨论：

1. 只有一堆且为 1 ，后手胜利。

2. 每一堆都为 1 ，只需要判断堆数的奇偶，奇数则先手败，偶数则后手败。

3. 只有一堆不是 1 ，其余堆都是 1 ，先手可以选择是拿完或是拿得只剩 1 个。

4. 其余的一般情况，通过每堆的奇偶转化成 1～3 中的一个。

最后，把每一堆的权值异或，判断结果等不等于 0 。

## CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[55];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int ans=0;
		bool f=1;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			int x;
			cin>>x;
			ans^=x;
			f&=(x==1);
		}
		if(f)
		cout<<(ans?"Brother":"John")<<"\n";
		else
		cout<<(ans?"John":"Brother")<<"\n";
	}
	return 0;
}
```

---

## 作者：DQYdqy (赞：1)

dalao们讲的都太数学了，蒟蒻表示自己真的是太弱了

安利一发博客:[ヾ(≧∇≦*)ゝ](https://www.cnblogs.com/NLDQY/p/10216881.html)

**Solution**

在普通的Nim游戏当中，若各堆石子数异或和不为0，则**先手必胜**

然而在本题中，取走最后的那颗石子人输

我们来分情况讨论

1.若当前每堆石子数都为1,且石子堆数为奇数,则先手必败,为偶数,先手必胜

2.若某一堆石子数>1且各堆石子异或和不为0,则先手必胜

为什么呢？(~不知道......)   我们来推导一下

结论1是很显然的,我们就不再做出赘述，如何来证明结论2呢

根据普通的Nim游戏可以知道，在**先手必胜**的情况下，总是有某种策略可以让**局势**重新转换为**先手必胜**的局势(先后手在不断变换)，而**先手必败**的局势是只能通向先手必胜的。

又由于我是先手,则在双方都采取**先手必胜->先手必胜**的策略的情况下，最后输的总是我。

那么转换到本题，在满足2条件的情况下，最后赢得肯定是我。

得证。

**Code:**
```
#include<bits/stdc++.h>
#define N 101
using namespace std;
int n,a[N];
int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int main(){
    int Case=read();
    begin:Case--;
    if(Case<0)return 0;
    n=read();memset(a,0,sizeof(a));
    for(int i=1;i<=n;i++){
        a[i]=read();
        a[0]^=a[i];
    }
    sort(a+1,a+n+1);
    if((a[n]==1&&!a[0])||(a[0]&&a[n]>1))puts("John");
    else puts("Brother");
    goto begin;
}
```

---

## 作者：XL4453 (赞：0)

## 解题思路:

反 $\text{Nim}$ 游戏经典题。

---
### SG 函数部分：

这一般的 $\text{Nim}$ 游戏一样。

没有石子时无法取，也就是说：$G(0)=0$，然后每一个 $G(x)$ 都可以任意地取 $G(x-k)$ 其中整数 $k \in[1,x]$，根据 $SG$ 函数的定义，得到：$G(x)=MEX(G(x-k))=x$。

---
### 反 $\text{Nim}$ 游戏部分

分情况讨论。

1. 当有且仅有石子数为 1 的堆的时候，直接根据奇偶性判断最终结果。

2. 当有且仅有一堆不为 1 的时候，根据奇偶性调整取完有多余石子的一堆，必胜。

3. 否则和一般的 $\text{Nim}$ 一样，求出所有数的异或和。每一个异或和为 0 的状态一定只能转换到异或和不为 0 的状态或者转化到情况 2，即让下一个取的玩家必胜。而每一个异或和不为 0 的状态一定能转化到为 0 的状态。显然异或和为 0 是必败态，否则为必胜态。

---
综上所述，也就是比一般的 $\text{Nim}$ 游戏多了一个全为 1 的特判。感性理解一下就是原 $\text{Nim}$ 中全为 1 的情况和一般情况的结果重合，而这里反过来了。


---
## 代码：

```cpp
#include<cstdio>
using namespace std;
int n,T,x,ans,flag;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		ans=0;flag=1;
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			ans^=x;
			flag&=(x==1);
		}
		if(flag==1)ans=!(n&1);
		if(ans==0)printf("Brother\n");
		else printf("John\n");
	}
	return 0;
}
```


---

## 作者：keep_ (赞：0)

# 博弈论(入门，持续更新)

## 博弈论

(本来想发博客园的，但太晚了又没办法发首页（虽然发了也要被扯）)
顺便发到洛谷来得咕值

本篇只对尼姆博弈和巴什博弈进行介绍（其余博弈遇到了再加进去）

**定义** ：博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分

支，也是运筹学的一个重要学科。博弈论  是二人在平等的对局中各自利用对方的策略变换自己的

对抗策略，达到取胜的目的。

### 1，巴什博弈

　　巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多
　
　取m个。最后取光者得胜。

　显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都
　
　能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）
　
　r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先
　
　取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获
　
　胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。这个游戏还可以有一种变相的
　
　玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。对于巴什博弈，
　
　那么我们规定，如果最后取光者输，那么又会如何呢？（n）%（m+1）==0则后手胜利

先手会重新决定策略，所以不是简单的相反行的
例如n=15，m=3
后手 先手 剩余
0 2 13
1 3 9
2 2 5
3 1 1
1 0 0
先手胜利 输的人最后必定只抓走一个，如果>1个，则必定会留一个给对手

上面是百度百科的解释，先手胜利的条件比较显然，后手胜利的本质便是先手取任意数把原本（n）%

（m+1）==0的形式转化为n=（m+1）r+s的形式，也就是把先手转化为后手；原本后手变为先手；

例题：洛谷好像没有巴什博弈的例题 

从别的佬博客里搬运了几道

 [HDU1847](http://acm.hdu.edu.cn/showproblem.php?pid=1847) 

[HDU2147](http://acm.hdu.edu.cn/showproblem.php?pid=2147)

[HDU2149 ](http://acm.hdu.edu.cn/showproblem.php?pid=2149)

[HDU2188](http://acm.hdu.edu.cn/showproblem.php?pid=2188)

[HDU2897](http://acm.hdu.edu.cn/showproblem.php?pid=2897)

## 2，尼姆博奕

有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，

最后取光者得胜。

这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，

0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要

与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局

势，无论自己如何拿，接下来对手都可以将其变为（0，n，n）的情形。

计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号⊕表示这种运算，先看

（1，2，3）的按位模2加的结果：

1 =二进制01

2 =二进制10

3 =二进制11 ⊕

———————

0 =二进制00 （注意不进位）

对于奇异局势（0，n，n）也一样，结果也是0。

任何奇异局势（a，b，c）都有a⊕b⊕c =0。

注意到异或运算的交换律和结合律，及a⊕a=0，:

a⊕b⊕(a⊕b)=(a⊕a)⊕(b⊕b)=0⊕0=0。

所以从一个非奇异局势向一个奇异局势转换的方式可以是：

1）使 a = c⊕b

2）使 b = a⊕c

3）使 c = a⊕b
因此，我们得到结论 把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。
证明可以看一下下面这位佬的博客 [链接](https://www.iteye.com/blog/ghods-2088667)

### Anti-Nimm game (尼姆博弈的变形,反尼姆博弈)

以这道题为例[洛谷 P4279 SHOI2008小约翰的游戏](https://www.luogu.com.cn/problem/P4279)

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
int t;
int a[1000];
int ans;
int n;
int sum;
int main(){
	cin>>t;
	while(t){
		t--;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		ans=0;
		sum=0;
		for(int i=1;i<=n;i++){
			ans^=a[i];
			sum+=a[i];
		}
		if(sum==n){
			puts(sum&1?"Brother":"John");
		//	cout<<endl; 注意puts自带换行
		}
		else{
			puts(ans?"John":"Brother");
		//	cout<<endl;
		}
	}
	return 0;
}
```
反nimm博弈和尼姆博弈又是不同的情况

我们对代码中运用方法进行证明和总结

 分类讨论再将相同情况合并

 1 当每一堆的石子数都为1时，当堆数为奇数时先手输，否则后手输

 2 当有且有一堆石子的个数>=2其余均为单个石子时，我们可以通过调整使下一状态下的全为单个石

子且数量可为奇数可为偶数，故，无论是谁，遇到这个状态其必将胜利

3 当有至少2堆的石子数>=2

显然石子必然要在减少的过程中由3状态变为2状态，

因为2状态下存在大于等于2的那堆石子，所以可知2状态下异或和一定大于0（存在较高位）

假设我们3状态下异或和大于0，则我们可将下一状态的异或和变为0或者仍然大于0（证明过程和尼姆

博弈的过程相同）

假设我们3状态下异或和等于0，我们通过取石子，只能使下一状态的异或和大于0，

我们已知2状态下异或和大于0，所以当我们处于状态3且异或和大于0时，我们可以通过调整使

下一状态的异或和等于0，但下一状态只能让下下状态的异或和大于0，所以当处于第三种情况时，

若异或和大于0，那么先手一定胜利，等于0则先手失败。

我们进行一下总结，由于第一种情况与后两种情况无法进行合并，所以对第一种情况进行特判定

对2.3种情况进行合并，即大于0先手一定胜利。

证明完毕

完结撒花。

其实这只是博弈论很少一部分，本题好像由sj定理可以直接做？（但我不会）

sg函数也不会（sg函数的题很少），以后遇到再学吧.我还是太菜了（真）； 





---

## 作者：Yyxxxxx (赞：0)

### 这显然是一个博弈论。   
首先如果每一堆都是$1$时，堆数奇数时`Brother`胜，偶数时`John`胜。   
如果不是，先考虑只有一堆不是$1$，`John`珂以选择取完或取到剩一个。保证剩下的堆数为偶数。   
否则，就要两人博弈，使自己可以取到最后一堆个数不为$1$。本条参考[Nim游戏](https://www.luogu.com.cn/problem/P2197)

## 总结
记异或和为$Xor$
- 若$n$堆个数均为$1$，$Xor\%2=0$时`John`胜，$Xor\%2=1$时`Brother`胜
- 否则，$Xor\%2=0$时`Brother`胜，$Xor\%2=1$时`John`胜
# $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000001],n;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		int cnt=0,ans=0;
		for(int i=1;i<=n;i++)
			if(a[i]==1)cnt++;
			else break;
		for(int i=1;i<=n;i++)
			ans^=a[i];
		if(cnt==n)
		{
			ans?puts("Brother"):puts("John");
		}
		else
		{
			ans?puts("John"):puts("Brother");
		}
	}
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：0)

反 Nim 游戏模板题。

## 题目大意
有 $n$ 堆石子，每次可以从任意一堆石子中取走任意多个，但不能不取，取走最后一个石子的人输。请问是否有先手必胜？

## 大体思路
反 Nim 游戏的结论为：先手必胜，当且仅当：

1. 每堆石子的个数均为 $1$ 且 $SG$ 和为 $0$；
2. 至少有一堆石子的个数 $>1$ 且 $SG$ 和不为 $0$。

证明如下：

首先考虑一种特殊情况，即 $a_1=a_2=\cdots=a_n=1$，显然先手必胜当且仅当 $n$ 为偶数，而偶数个 $1$ 的异或和恰好为 $0$，因此 $SG$ 和为 $0$。

否则，当 $SG$ 和不为 $0$ 时，

- 若当前有至少两堆石子的个数 $>1$，则先手可以使得 $SG$ 和变为 $0$，此时情况与普通的 Nim 类似；

- 若当前有且仅有一堆石子的个数 $>1$，先手可以选择是否将当前堆取完，使得剩余奇数堆的 $1$，保证先手必胜。

当 $SG$ 和为 $0$ 时，情况相反，后手必胜。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 55;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int T, n;
int main () {
	read(T);
	while(T --) {
		read(n);
		int sum = 0, sX = 0;
		rep(i, 1, n) {
			int x; read(x);
			sum += x;
			sX ^= x;
		}
		if(sum == n) puts((sX == 0 ? "John" : "Brother"));
		else puts((sX ? "John" : "Brother"));
	}
	
	return 0;
}
```

---

## 作者：ZVitality (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4279)以及[双倍经验](https://www.luogu.com.cn/problem/UVA1566)

简单的博弈论。

考虑分类讨论，可以列出：

1. 所有的为 $1$，那么取最后一个石子的人输，很简单，看堆数奇偶性即可。
2. 有一堆不为 $1$，那么看堆数奇偶性，和上面相反，如果是偶数堆，约翰可以将不为 $1$ 的堆剩下 $1$ 个石子，则转换为哥哥先手，偶数堆的情况。
3. 普通情况，我们可以想出如何转化为 1 或 2。

那么，这就十分像 nim 游戏了。（做这题的人应该都会吧）

所以，全部异或即可。

代码就不放了，反正其他题解也有。

---


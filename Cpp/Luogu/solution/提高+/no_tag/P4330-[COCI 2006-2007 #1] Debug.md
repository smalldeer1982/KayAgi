# [COCI 2006/2007 #1] Debug

## 题目描述

在调试程序时，Mirko 注意到程序中的一个错误可能与程序内存中存在的所谓“方形杀手”有关。程序内存是一个由 R 行 C 列组成的矩阵，仅包含 0 和 1。一个“方形杀手”是内存中的一个方形子矩阵，由多个字符组成，当旋转 180 度时看起来完全相同。例如，下面的矩阵包含 3 个“方形杀手”：

![](https://cdn.luogu.com.cn/upload/pic/15764.png)

Mirko 想知道最大“方形杀手”的大小与程序中的错误是否存在关联。请帮助 Mirko 编写一个程序，给定内存的布局，输出最大“方形杀手”的大小。“方形杀手”的大小是指其包含的行数（或列数）。在上面的例子中，“方形杀手”的大小分别为 2、2 和 3。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3 6
101010
111001
101001```

### 输出

```
3```

## 样例 #2

### 输入

```
4 5
10010
01010
10101
01001```

### 输出

```
3```

## 样例 #3

### 输入

```
3 3
101
111
100```

### 输出

```
-1```

# 题解

## 作者：平衡树森林 (赞：16)

## 我好像无意间搞出了二维哈希！
------
* 题目让我们求一个最大的**旋转对称**的正方形

* $n,m<=300$意味这我们最多能承受$n^3$的复杂度

怎么办呢？

### 我会暴力！

一个简单的思路：枚举每个正方形，然后判断这个正方形是否旋转对称

然后我们发现，单单是枚举每个正方形就已经有$n^3$的复杂度了，

别急，**还有希望！** 假如我们能在$O(1)$的时间内**判断**旋转对称呢？

立马想到，假如我们有一种哈希，它能在$O(1)$的时间内获取任何一个矩阵的哈希值，那就好办了。咱们可以正着取那个正方形的哈希值，再把矩阵倒着再取一遍，判断是否一样即可。

可是我们没有二维哈希呀>.<，那就先从一维哈希入手，找点灵感：

### 一维哈希

一维哈希是这样的：对于序列
$$a_1,a_2,a_3......a_k$$
我们想要给每一个序列一个**独一无二**的哈希值H，这样我们只需要花费$O(1)$的时间去比较这个值，就能快速比较出两个数列是否相同了

* 一种简单的思想，讲所有数的和直接作为H。但这显然是不行的，反例太好举了

* 思想进阶一下：如果我们作为H的是所有数的平方和呢？仍然有反例，但明显要好得多

* 再深入想一下，二次不行，咱们还可以立方和，四次方，五次方...甚至可以用指数函数，总有一个不容易有反例吧！

但这种做法显然有一个致命的漏洞，就是我们完全不能决定序列的顺序。相反，如果是对于集合哈希，这个方法非常优秀，可咱们是数列啊！/

于是一位奆佬给出了一个解决方案：我们可以找一个比所有a都大的p，然后直接把序列当成一个**p进制的大数**，以此作为H。当然，这个数大到我们存不下来，但没关系，我们还能取模啊！把它对一个大质数取模，就能得到一个近乎不可能重复的哈希值了。同时我们也发现，对于两个相似的序列，只要它们稍稍有一点不同，所得的哈希值就千差万别。**完美解决！**

#### 两种算法一个适用于集合，一个适用于序列，它们究竟差在哪呢？

仔细思考一下，会发现，序列中**顺序**非常重要。那么如果我把序列中的每一个元素变成一个二元组，第一元是数值，第二元是它的位置，会发生什么呢？奇妙的事情出现了：序列变成了二元组的集合！

**原来序列的本质是集合！**

回过来看看那个正确的哈希，根据位值原理，我们可以把它想象成，它首先把序列变成了
$p^1a_1,p^2a_2,p^3a_3...p^ka_k$，再求和（首项应该是从0开始的，但从1开始其实没什么影响）。

与我们的想法的区别在于，我们最初的想法在哈希时完全没有考虑顺序，而这个哈希在计算时先把位置与对应的值用计算“绑定”到了一起，于是哈希的结果就考虑到了顺序。

也就是说，对于序列的哈希关键在于我们要找一个二元函数$h(x,i)$，然后把序列的每个$a_i$变成$h(a_i,i)$，最终的哈希值就是所有$h$的和。这样哈希出来的值便可以兼顾元素的值与顺序

照这个思路，二维哈希就很容易了：

------
## 二维哈希
对于一个r行c列的矩阵
$$a_{1,1},a_{1,2}...a_{1,c} $$
$$a_{2,1},a_{2,2}...a_{2,c} $$
$$...$$
$$a_{r,1},a_{r,2}...a_{r,c} $$

我们可以找两个质数p,q，然后把i行j列元素变成$a_{i,j}*p^i*q^j$，然后矩阵的哈希值就是所有数的和，即

$$H=(\sum_{i,j<=r,c}a_{i,j}*p^i*q^j) \%mod$$

这样很明显，我们可以把哈希写成二维前缀和的形式了，做完了？

别急，还没完。思考一下，如果我们先用二维前缀和来预处理，那么计算一个中间的矩阵的哈希值时，首项的p和q的指数都不是从1开始的，也就是说，如果我们求的矩阵的左上角为$(x,y)$，那么实际上求得的哈希值是原来的$p^{x-1}*q^{y-1}$倍。

怎么办呢？除掉？显然不可行，因为在模意义下除法可不好做。~~我还会滑动窗口~~滑动窗口太麻烦了，有没有简单的解决方法呢？

有的！除法不行，但是我们可以乘啊！我们重新定义哈希函数：

$$H=(\sum_{i,j<=r,c}a_{i,j}*p^{i+n}*q^{j+m}) \%mod$$

但处理二维前缀和时每个数仍然变成$a_{i,j}*p^i*q^j$

这样二维前缀和算出来的值就比实际的哈希值少了$p^{n-x}*q^{m-j}$倍，咱们可以直接乘上去

二维哈希，完成！



------------
回归本题，我们只需要正这做一遍哈希，倒过来再做一遍，就可以在$O(1)$的时间里判断一个正方形是否为旋转对称了

时间复杂度$O(n^3)$

而事实上，这个算法的时间复杂度显然是还能降低的。我们只需要先枚举正方形中心点，再向外二分，就能把时间复杂度降到$O(n^2log_2n)$

~~但是朴素算法能过，咱何必呢~~

上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define FOR  for(LL i=1;i<=n;i++)for(LL j=1;j<=m;j++)
#define FOR2 for(LL i=n;i>=1;i--)for(LL j=m;j>=1;j--)
using namespace std;

inline LL read()
{
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

const LL maxn=300+10;
const LL A=10007,B=10009;
const LL MOD=1e9+9;
LL a[maxn][maxn];
LL X1[maxn],X2[maxn];
LL h1[maxn][maxn],h2[maxn][maxn];
LL n=read(),m=read();

LL hash1(LL a,LL b,LL c,LL d)
{
	LL ans=(h1[c][d]-h1[a-1][d]-h1[c][b-1]+h1[a-1][b-1]+MOD)%MOD;
	return ans*X1[n-a]%MOD*X2[m-b]%MOD;
}

LL hash2(LL a,LL b,LL c,LL d)
{
	LL ans=(h2[a][b]-h2[c+1][b]-h2[a][d+1]+h2[c+1][d+1]+MOD)%MOD;
	return ans*X1[c-1]%MOD*X2[d-1]%MOD;
}

int main()
{
	FOR
	{
		char ch;cin>>ch;
		if (ch=='1') a[i][j]=1;
	}
	X1[0]=X2[0]=1;
	for (LL i=1;i<=300;i++) X1[i]=X1[i-1]*A%MOD,X2[i]=X2[i-1]*B%MOD;
	FOR h1[i][j]=X1[i]*X2[j]*a[i][j]%MOD;
	FOR h2[i][j]=X1[n-i+1]*X2[m-j+1]*a[i][j]%MOD;
	FOR h1[i][j]=h1[i-1][j]+h1[i][j-1]-h1[i-1][j-1]+h1[i][j];
	FOR2 h2[i][j]=h2[i+1][j]+h2[i][j+1]-h2[i+1][j+1]+h2[i][j];
	LL ans=0;
	FOR for (LL k=1;k+i<=n && k+j<=m;k++)
		if (hash1(i,j,i+k,j+k)==hash2(i,j,i+k,j+k)) ans=max(ans,k+1);
	if (ans==0) cout<<-1<<endl; else cout<<ans<<endl;
	return 0;
}
```
ps.这种哈希法还真是我自己想的，如果本来就有相关文章，各位可以在评论区里说一声~ STO STO

**求个赞>.<**

~~

---

## 作者：yangshurong (赞：4)

借鉴了@wanghaoyu1008的思路。
看到中心对称，想到manacher，用处理回文串的那个思路，对角线扩展。

对于两边每新扩展一个点，判断一下满不满足行和列的中心对称。

判断方法可以用@wanghaoyu1008的暴力。

也可以用hash优化：
对于每一行，正着来一遍hash，反着来一遍hash，
列同理。

复杂度计算：

枚举对角线：O(n+m),对角线上manacher:O(max(n,m)),
hash判断：O(1)
最终复杂度：**O((n+m)*(max(n,m)))**

相当于是O(n^2),理论上可以过掉n<=1000的数据，但实测常数太大，即使开int也要440ms.

unsigned long long 和 long long 都是480ms。

这只比O(n^3)的暴力要快300ms左右。

还有种二维hash的方法，就是枚举正方形右下角的点，正方形的边长，然后hash判断正方形满不满足条件。


这种方法好像跑的贼快，@BLUE_EYE 只用了52ms。

```cpp
#define rel(a) a=readl()
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
#define ull unsigned long long
using namespace std;
const int N=1000007;
const int p=1e9+7;
const int M=607;
const int base=31;
inline int read(){
    char ch=getchar();
    int w=1,x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
    return x*w;
}
int n,m,P[N],ans=0;
ll sumx[M][M],sumy[M][M],rsumx[M][M],rsumy[M][M],pw[M];
char ch[M],a[M][M];
in bool check(int x,int y,int t){
	return (((sumy[x-t][y+t]-1ll*sumy[x-t][y-t-1]*pw[2*t+1]%p+p)%p)==((rsumy[x+t][y-t]-1ll*rsumy[x+t][y+t+1]*pw[2*t+1]%p+p)%p))&&(((sumx[x+t][y-t]-1ll*sumx[x-t-1][y-t]*pw[2*t+1]%p+p)%p)==((rsumx[x-t][y+t]-1ll*rsumx[x+t+1][y+t]*pw[2*t+1]%p+p)%p));
} 
in int manacher(int x,int y){
	int cen=1,q=min(n-x+1,m-y+1),res=0;;
	if((ans<<1)>q)return 0;
	me(P);
	P[cen]=1,cen=1;
	r(i,2,q){
		P[i]=cen+P[cen]-1<i?1:min(P[(cen<<1)-i],cen+P[cen]-i);
		if(i+P[i]>=cen+P[cen]){
			while(i-P[i]>0&&i+P[i]<=q&&check(x+i-1,y+i-1,P[i]))P[i]++;
			cen=i;
			res=max(res,P[i]);
		}
	}
	return res-1;
}
int main(){
	re(n),re(m);
	n=n<<1|1,m=m<<1|1;
	for(int i=2;i<=n;i+=2){
		scanf("%s",ch);
		for(int j=2;j<=m;j+=2)a[i][j]=ch[(j>>1)-1];
	}
	pw[0]=1;
	r(i,1,602)pw[i]=pw[i-1]*base%p;
	r(i,1,n){
		r(j,1,m){
			sumy[i][j]=(sumy[i][j-1]*base%p+a[i][j])%p;
			sumx[i][j]=(sumx[i-1][j]*base%p+a[i][j])%p;
		}
	}
	rr(i,n,1){
		rr(j,m,1){
			rsumx[i][j]=(rsumx[i+1][j]*base%p+a[i][j])%p;
			rsumy[i][j]=(rsumy[i][j+1]*base%p+a[i][j])%p;
		}
	}
	for(int j=3;j<m;j+=2)ans=max(ans,manacher(1,j));
	for(int i=1;i<n;i+=2)ans=max(ans,manacher(i,1));
	printf("%d\n",ans==1?-1:ans);
	return 0;
}

```

码风还是很好看的

---

## 作者：12345678hzx (赞：2)

题意十分简洁明了，就是让我们求出最大的一个旋转对称的正方形。

考虑到一个正方形如果左上顶点和边长确定，就能确定整个正方形，枚举这部分的时间复杂度是 $O(n^3)$。

但是这道题的数据范围最多承受 $O(n^3)$ 的时间复杂度，这意味着我们要 $O(1)$ 地判定一个正方形是否旋转对称。

我们考虑先把这个问题拍到一维上，例如判断一个字符串是否回文的问题，而这个问题很容易想到哈希做法，我们只要在时间范围内预处理出哈希的前缀和，就能 $O(1)$ 地判定，所以考虑用哈希解决本题。

相信大家都会二维前缀和，于是我们可以效仿一维哈希，预处理出哈希前缀和，取两个大质数分别作为行和列的 $P$，从左上角到右下角做一遍哈希，然后再从右下角到左上角做一遍哈希，就能 $O(1)$ 地判定，然后就能过了这题，时间复杂度为 $O(n^3)$。

---

## 作者：zcq_qwq (赞：2)

## 题目分析

其实就是找正着看和反着看一样的子矩形，所以我们可以正着一遍 hash 反着一遍 hash，然后三重循环枚举子矩形，将正着的矩形和反着的矩形的 hash 值进行比较，相同则是 killer。

### 具体写法

如果暴力枚举每个子矩形，时间复杂度是 $O(n^4)$，无法接受。

此时回到题目，题目要求输出最大的 killer 的边长，因为最大的 killer 的边长不大于 $\min(n,m)$，于是我们想到了可以从 $\min(n,m)$ 往下依次枚举边长。现在，只要在内层枚举以 $i+k-1$ 和 $j+k-1$ 为右下角的正方形，求出这个正方形正着和反着的 hash 值，如果相等输出 $k$，否则循环结束后输出 `-1` 即可。

**PS：$k$ 的下界为 $2$，因为题目中明确说明 killer 的字符数量严格大于 $1$（即边长不为 $1$）。**

接下来我们分析 hash 函数的写法。因为是二维 hash，所以我们需要两个 base。

类似于一维 hash，定义：

$$hash_{i,j}=a_{i,j} \cdot base_1^i \cdot base_2^j$$

前缀和：

$$S_{x,y}=S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y} \cdot base_1^x \cdot base_2^y$$

对于差分，我们需要将 $base_1,base_2$ 对齐到左上角：

$$H_{x_1,y_1,x_2,y_2}=(S_{x_2,y_2}-S_{x_1-1,y_2}-S_{x_2,y_1-1}+S_{x_1-1,y_1-1}) \cdot (base_1^{x_1-1})^{-1} \cdot (base_2^{y_1-1})^{-1}$$

此时，有蒟蒻同学提出：我不会写逆元……

考虑优化：

正难则反，考虑以各维度到矩形右下角 $(x_2,y_2)$ 的距离作为 $base_1,base_2$ 的指数，从而避免逆元运算。

前缀和：

$$S_{x,y}=S_{x-1,y} \cdot base_1+S_{x,y-1} \cdot  base_2-S_{x-1,y-1} \cdot base_1 \cdot base_2+a_{x,y} \cdot base_1 \cdot base_2$$

差分顺理成章：

$$H_{x_1,y_1,x_2,y_2}=S_{x_2,y_2}-S_{x_1-1,y_2} \cdot base_1^{x_2-x_1+1}-S_{x_2,y_1-1} \cdot base_2^{y_2-y_1+1}+S_{x_1-1,y_1-1} \cdot base_1^{x_2-x_1+1} \cdot base_2^{y_2-y_1+1}$$

取模的话，我用的是自然溢出，不知道大模数能不能过。

## 完整代码：
```cpp
#include <bits/stdc++.h> // 本代码的 base 和讲解略有不同，见谅

typedef unsigned long long ull;

using namespace std;

const int N = 300 + 5;

const ull base1 = 23, base2 = 29;

int n, m;

ull f1[N][N], f2[N][N], ba1[N], ba2[N], a[N][N];

ull hash_funtion1(int x, int y, int z) {
	return f1[x][y] - f1[x - z][y] * ba1[z] - f1[x][y - z] * ba2[z] + f1[x - z][y - z] * ba1[z] * ba2[z];
}

ull hash_funtion2(int x, int y, int z) {
	return f2[x][y] - f2[x + z][y] * ba1[z] - f2[x][y + z] * ba2[z] + f2[x + z][y + z] * ba1[z] * ba2[z];
}

int main(void) {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%1llu", &a[i][j]);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			f1[i][j] = f1[i - 1][j] * base1 + a[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			f1[i][j] += f1[i][j - 1] * base2;
		}
	}
	for (int i = n; i >= 1; i--) {
		for (int j = m; j >= 1; j--) {
			f2[i][j] = f2[i + 1][j] * base1 + a[i][j];
		}
	} 
	for (int i = n; i >= 1; i--) {
		for (int j = m; j >= 1; j--) {
			f2[i][j] += f2[i][j + 1] * base2;
		}
	}
	ba1[0] = ba2[0] = 1;
	for (int i = 1; i <= n; i++) {
		ba1[i] = ba1[i - 1] * base1;
	}
	for (int i = 1; i <= m; i++) {
		ba2[i] = ba2[i - 1] * base2;
	}
	int ans = 0;
	for (int k = min(n, m); k >= 2; k--) {
		for (int i = 1; i <= n - k + 1; i++) {
			for (int j = 1; j <= m - k + 1; j++) {
				ull tmp1 = hash_funtion1(i + k - 1, j + k - 1, k);
				ull tmp2 = hash_funtion2(i, j, k);
				if (tmp1 == tmp2) {
					cout << k;
					return 0;
				}
			}
		}
	}
	cout << -1;
	return 0;
}
```
完结撒花~~ 

至于代码讲解有误等问题，欢迎提出~~

写题解不易，望点赞。

---

## 作者：仙肉粽子 (赞：1)

# P4330题解

无耻的推荐一下我的 [CSDN](https://blog.csdn.net/weixin_60600142/article/details/132531624?spm=1001.2014.3001.5502)。

## 暴力——人类的智慧！

我们可以枚举边长，然后枚举左上角，再判断是否为对称子矩形。

|步骤|时间|
|:--------:|:--------:|
|枚举边长|$O(n)$|
|枚举左上角|$O(n ^ {2})$|
|判断是否为对称子矩形|$O(n ^ {2})$|
|总时间复杂度|$O(n ^ {5})$|

恭喜你，40 分！

## 优化的开始——二分！

我们可以想想，枚举边长的时候可不可以二分呢？那么，时间复杂度就完美的把一个 $O(n)$ 降成 $O(\log {n})$。

|步骤|时间|
|:--------:|:--------:|
|枚举边长|$O(\log n)$|
|枚举左上角|$O(n ^ {2})$|
|判断是否为对称子矩形|$O(n ^ {2})$|
|总时间复杂度|$O(n ^ {4} \log n)$|

虽然不知道有多少分~~（懒得测了）~~，但时间复杂度已经降下来了。

## 只判断边框——降了一个 $O(n)$！

我们在判断的时候会出现多余的地方，用一个 $flag[x][y][len]$ 数组记录以 $(x,y)$ 为左上角，边长为 $len$ 的矩阵是否为回文串，每次判断的时候如果 $flag[x + 1][y + 1][len - 2]$ 为假，直接跳掉，每次判断的时候只要判断两条长和两条宽就行了。

|步骤|时间|
|:--------:|:--------:|
|枚举边长|$O(n)$ 或 $O(\log {n})$|
|枚举左上角|$O(n ^ {2})$|
|判断是否为对称子矩形|$O({n})$|
|总时间复杂度|$O(n ^ {4})$ 或 $O(n ^ {3} \log {n})$|

$O(n ^ {3} \log {n})$ 接近 $O(n ^ {3})$ 有 100 的希望了！

## 逆流而上——又优化了一点点！

我们可以倒着枚举边长，只要找到了，退出整个循环，有可能优化一点点，但效果不明显~~（卡常用）~~。

## 几个long long跑得快——二进制拆分！

我们可以每 64 个数为一组，判断的时候直接 $O(n \log {n})$，$O(\log {n})$ 直接可以忽略不计！

|步骤|时间|
|:--------:|:--------:|
|枚举边长|$O(n)$ 或 $O(\log {n})$|
|枚举左上角|$O(n ^ {2})$|
|判断是否为对称子矩形|$O(n \log {n})$|
|总时间复杂度|$O(n ^ {4} \log {n})$ 或 $O(n ^ {3} {\log ^ 2 {n}})$|

## 一个矩阵一个数——二维hash！

枚举边长和左上角不能再优化了，但判断的时间复杂度可以降成 $O(1)$！二维 HASH 上场！
我们用p1、p2表示两个质数（随便什么质数都可以，不同就行了），第i行j列的数为 $a _ {ij} \times p1 ^ {i} \times p2 ^ {j}$，然后矩阵的哈希值就是所有数的和。
$$
H = (\sum a _ {ij} \times p1 ^ {i} \times p2 ^ {j}) \bmod mod
$$
```cpp
/*
*/
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define ull unsigned long long
#define sort stable_sort
#define INF 0x7f7f7f7f
#define ll long long 
using namespace std;
ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];
int n,m,ans,a[1010][1010];
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>m;
	int i,j,l;
	ull s1,s2;
	char ch;
	rep(i,1,n,1) rep(j,1,m,1) cin>>ch,a[i][j] = ch - '0';
	rep(i,1,n + m,1) p1[i] = 2 * p1[i - 1],p2[i] = 3 * p2[i - 1];
	rep(i,1,n,1) rep(i,1,m,1)
		h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + 
					p1[i] * p2[j] * a[i][j];
	rep(i,1,n,1) rep(i,1,m,1)
		h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + 
					p2[n - i + 1] * p2[m - j + 1] * a[i][j];
	rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1){
		s1 = h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1];
		s2 = h2[i + l][j + l] - h2[i + l][j + 1] - h2[i + 1][j + l] + h2[i + 1][j + 1];
		if(s1 == s2){
			ans = l;
			l++;
			i = 1,j = 1;
		}
	}
	if(ans > 1) cout<<ans;
	else cout<<-1; 
	return 0;
}
```
恭喜，18 分。

------------

让我们想想，设矩阵的左上角为 $(x,y)$，我们算出来的矩阵的值会多出 $p1 ^ {x - 1} \times p2 ^ {y - 1}$ 倍！怎么办？除掉？~~（我不会）~~只有乘。

### 交叉相乘法

小学知识：
$$
\frac{s1}{p1 ^ {x - 1} \times p2 ^ {y - 1}} = \frac{s2}{p1 ^ {n - x - l} \times p2 ^ {n - y - l}}
$$
$$
s1 \times p1 ^ {n - x - l} \times p2 ^ {n - y - l} = s2 \times p1 ^ {x - 1} \times p2 ^ {y - 1}
$$
所以，代码来——
```cpp
/*
*/
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define ull unsigned long long
#define sort stable_sort
#define INF 0x7f7f7f7f
#define ll long long 
using namespace std;
ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];
int n,m,ans,a[1010][1010];
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>m;
	int i,j,l;
	ull s1,s2;
	char ch;
	rep(i,1,n,1) rep(j,1,m,1) cin>>ch,a[i][j] = ch - '0';
	p1[0] = p2[0] = 1;
	rep(i,1,max(n,m),1) p1[i] = 101 * p1[i - 1],p2[i] = 131 * p2[i - 1];
	rep(i,1,n,1) rep(j,1,m,1)
		h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + 
					p1[i] * p2[j] * a[i][j];
	r(i,n,1,1) r(j,m,1,1)
		h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + 
					p1[n - i + 1] * p2[m - j + 1] * a[i][j];
	rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1){
		s1 = (h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1]) * p1[n - i - l] * p2[m - j - l];
		s2 = (h2[i][j] - h2[i + l + 1][j] - h2[i][j + l + 1] + h2[i + l + 1][j + l + 1]) * p1[i - 1] * p2[j - 1];
		if(s1 == s2){
			ans = l + 1;
			i = n,j = m;
		}
	}
	if(ans > 1) cout<<ans;
	else cout<<-1; 
	return 0;
}
```

### 统一倍数法

既然我们要减小倍数，保证他们的倍数统一，那么我们不如将倍数扩大保证他们统一，我的方法就是把他扩大成 $p1 ^ {n} \times p2 ^ {m}$，这样他们的倍数就统一了，也可以正常比较了。
```cpp
/*
*/
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define ull unsigned long long
#define sort stable_sort
#define INF 0x7f7f7f7f
#define ll long long 
using namespace std;
ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];
int n,m,ans,a[1010][1010];
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>m;
	int i,j,l;
	ull s1,s2;
	char ch;
	rep(i,1,n,1) rep(j,1,m,1) cin>>ch,a[i][j] = ch - '0';
	p1[0] = p2[0] = 1;
	rep(i,1,max(n,m),1) p1[i] = 101 * p1[i - 1],p2[i] = 131 * p2[i - 1];//����ģ����unsigned long long��Ȼ����Ϳ����� 
	rep(i,1,n,1) rep(j,1,m,1)
		h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + 
					p1[i] * p2[j] * a[i][j];
	r(i,n,1,1) r(j,m,1,1)
		h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + 
					p1[n - i + 1] * p2[m - j + 1] * a[i][j];
	rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1){
		s1 = (h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1]) * p1[n - i] * p2[m - j];
		s2 = (h2[i][j] - h2[i + l + 1][j] - h2[i][j + l + 1] + h2[i + l + 1][j + l + 1]) * p1[i + l - 1] * p2[j + l - 1];
		if(s1 == s2){
			ans = l + 1;
			i = n,j = m;
		}
	}
	if(ans > 1) cout<<ans;
	else cout<<-1; 
	return 0;
}
```

---

## 作者：wmy_goes_to_thu (赞：1)

我是 sb，所以只会 sb 暴力。

最大子段和变成最大子矩阵和的时候用了一种办法，枚举上下端点。

这道题也可以这么做，枚举上下端点，但是这还是四维的，所以需要哈希一下。现在可以得到两个字符串，一个是从上往下哈希，另一个是从下往上哈希。如何比较呢？再哈希一遍。

如果还是以刚才的模数哈希肯定不行，比如 `0 mod` 和 `1 0` 会被哈希成一个数值，这也是我纠结的一个地方。

其实可以把它当做一个数表，一列一列取，就可以发现这个模数是原来的模数的距离次方，其中距离指的是上端点到下端点这个区间的长度。

最后放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[305];
int f[305][305];
unsigned long long mm=14757395258967641293ull,h1[305][305],h2[305][305];
unsigned long long b[1000005],t1[305],t2[305],m1[605],m2[605];
int main()
{
	b[0]=1;
	for(int i=1;i<=1000000;i++)b[i]=b[i-1]*mm;
	int n,m,ans=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)f[i][j]=s[j]-'0';
	}
	for(int j=1;j<=m;j++)for(int i=1;i<=n;i++)
		h1[i][j]=mm*h1[i-1][j]+f[i][j];
	for(int j=1;j<=m;j++)for(int i=n;i>=1;i--)
		h2[i][j]=mm*h2[i+1][j]+f[i][j];
	for(int l=1;l<=n;l++)for(int r=l;r<=n;r++)
	{
		memset(m1,0,sizeof(m1));
		memset(m2,0,sizeof(m2));
		int jl=r-l+1;
		for(int i=1;i<=m;i++)t1[i]=h1[r][i]-h1[l-1][i]*b[r-l+1];
		for(int i=1;i<=m;i++)t2[i]=h2[l][i]-h2[r+1][i]*b[r-l+1];
		for(int i=1;i<=jl;i++)m1[1]=m1[1]*b[jl]+t1[i];
		for(int i=m;i>=m-jl+1;i--)m2[m-jl+1]=m2[m-jl+1]*b[jl]+t2[i];
		for(int i=2;i<=m-jl+1;i++)m1[i]=(m1[i-1]-t1[i-1]*b[jl*(jl-1)])*b[jl]+t1[i+jl-1];
		for(int i=m-jl;i>=1;i--)m2[i]=(m2[i+1]-t2[i+jl]*b[jl*(jl-1)])*b[jl]+t2[i];
		for(int i=1;i<=m-jl+1;i++)if(m1[i]==m2[i])ans=max(ans,jl);
	}
	if(ans==1)ans=-1;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wanghaoyu1008 (赞：1)

此题其实就是求最大的中心对称的正方形。

我来讲一种自认为非常妙的算法。

$Manacher$想必大家都会，那么我们可以直接借鉴其思想，加入无用字符，然后按对角线拓展。

中心对称图形中嵌的图形可以直接翻过来，又由于是正方形，三个对称中心正好在同一条主对角线上。

$O(n)$条对角线，一条对角线只能扩展$O(n)$步，每步扩展代价$O(n)$，当然此处可以用$hash$进一步优化，能得到更优的复杂度。我太懒了就没写。$O(n^3)$稳稳地AC。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=602;

int n,m,ans;
char a[N][N];
int s[N];

bool chk(int x,int y,int t){
//一次扩展，可以用hash优化
	for(int i=y-t,j=y+t;i<=y+t;i++,j--)
		if(a[x-t][i]!=a[x+t][j])return 0;
	for(int i=x-t,j=x+t;i<=x+t;i++,j--)
		if(a[i][y-t]!=a[j][y+t])return 0;
	return 1;
}

int mnc(int x,int y){
//按对角线扩展
	int d,q=min(n-x+1,m-y+1);
	if((ans<<1)>q)return 0;
	s[1]=1;d=1;
	for(int i=2;i<=q;i++){
		if(d+s[d]-1<i)s[i]=1;
		else s[i]=min(d+s[d]-i,s[2*d-i]);
		if(i+s[i]-1>=d+s[d]-1){
			while(i-s[i]>0&&i+s[i]<=q&&chk(x+i-1,y+i-1,s[i]))
				++s[i];
			d=i;
		}
	}
	int ans=0;
	for(int i=1;i<=q;i++)
		ans=max(ans,s[i]-1);
	return ans;
}

char t[N];

int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	n=n<<1|1;m=m<<1|1;
	for(i=2;i<=n;i+=2){
		scanf("%s",t);
        //我被读入坑了N多次
		for(j=2;j<=m;j+=2)
			a[i][j]=t[(j>>1)-1];
	}
	for(j=3;j<m;j+=2)
		ans=max(ans,mnc(1,j));
	for(i=1;i<n;i+=2)
		ans=max(ans,mnc(i,1));
	printf("%d",ans==1?-1:ans);
	return 0;
}
```
其实这种思路并不难想，不过建立在透彻理解$Manacher$算法的基础上。

如果有人用了$hash$优化那一步留言说一下时间，谢谢。

---

## 作者：star_eternal (赞：1)

## 全网没有一篇中文题解。。。 或许我没找到。
考虑极大化枚举，一个正方形，只有其内部的点是合法的，他才是合法的。
这样我们会得到一个大概的$O(N^4)$的算法。

这样会超时，$O_2$优化或许可以。

怎么办，考虑压位。

因为是只有$0,1$所以，以一个节点为中心节点向四周扩展出$64$个$01$串。然后一段一段的比较就可以了。这样已经不是常数优化了，

时间复杂度为$O ({{N^4} \over 64} = N^3\times \log_2N)$

```cpp
#include <cstdio>
#include <cctype>
using namespace std;
typedef long long ll;
const int Maxn = 300 + 10;
int n, m;char mat[Maxn][Maxn];
ll ex[Maxn][Maxn][4]; 
const int dr[] = { 1, 0, -1, 0 } , dc[] = { 0, 1, 0, -1 };

void prepare() {
	for( register int i = n - 1; i >= 0; --i ) 
		for( register int j = m - 1; j >= 0; --j ) 
			for( int k = 0; k < 2; ++k ) {
				int r = i + dr[k] , c = j + dc[k]; 
				if( r < 0 || r >= n || c < 0 || c >= m ) ex[i][j][k] = 0;
				else ex[i][j][k] = ex[r][c][k] << 1;
				ex[i][j][k] |= mat[i][j] == '1'; 
			}
	for( register int i = 0; i < n; ++i )
		for( register int j = 0; j < m; ++j )
			for( register int k = 2; k < 4; ++k ) {
				int r = i + dr[k] , c = j + dc[k];
				if( r < 0 || r >= n || c < 0 || c >= m ) ex[i][j][k] = 0;
				else ex[i][j][k] = ex[r][c][k] << 1;
				ex[i][j][k] |= mat[i][j] == '1';
			}
}

inline bool check( int r, int c, int siz ) {
	if( r < 0 || r + siz >= n ) return 0;
	if( c < 0 || c + siz >= m ) return 0;
	for( int d = 0; d < 2; ++d ) {
		int r1 = r, c1 = c, r2 = r + siz, c2 = c + siz;
		for( register int s = siz + 1; s > 0; s -= 64 ) {
			ll x = ex[r1][c1][d] , y = ex[r2][c2][d + 2];
			if( s >= 64 ) { if( x ^ y ) return 0; }
			else if( (x ^ y) & ((1ll << s) - 1) ) return 0;
			r1 += 64 * dr[d]; c1 += 64 * dc[d];
			r2 -= 64 * dr[d]; c2 -= 64 * dc[d];
		} 
	}
	return 1;
}
int main()
{

	scanf("%d%d",&n,&m);
//	for( register int i = 0; i < n; ++i ) 
//		for( register int j = 0; j < m; ++j ) {
//			char ch = getchar();
//			while( !isdigit(ch) ) ch = getchar();
//			mat[i][j] = !( ch == '0' ) ;
//		}
	for( int i = 0; i < n; i++ ) scanf("%s",mat[i]);
	prepare();
	int ret = 0;
	for( register int r = 0; r < n; ++r )
		for( register int c = 0; c < m; ++c )
			for( register int x = 0; x < 2; ++x ) {
				int siz = x;
				while( check( r - siz / 2, c - siz / 2, siz ) ) siz += 2;
				if( siz - 1 > ret ) ret = siz - 1;
			}
	printf("%d\n",ret > 1 ? ret : -1);
	fclose(stdout);
	return 0;
}
```


---

## 作者：sodalyghat (赞：0)

### 分析
一道挺裸的矩阵哈希题啊。正着哈希一遍，反着哈希一遍，然后枚举一个左上角和边长，比较这个正方形正反哈希的值一不一样就好了。

### 代码
```cpp
#include<bits/stdc++.h>
typedef unsigned long long ull;
using namespace std;
namespace ac{
	const int MAXN = 1005;
	ull h[MAXN][MAXN], base1[MAXN], base2[MAXN], _h[MAXN][MAXN];
	unordered_map<ull, bool> mp;
	ull hash1(int i, int j, int len){
		return h[i][j] - h[i - len][j] * base1[len] - h[i][j - len] * base2[len] + h[i - len][j - len] * base1[len] * base2[len];
	}
	ull hash2(int i, int j, int len){
		return _h[i][j] - _h[i + len][j] * base1[len] - _h[i][j + len] * base2[len] + _h[i + len][j + len] * base1[len] * base2[len];
	}
	int main(){
		int m, n;
		base1[0] = base2[0] = 1;
		base1[1] = 131;
		base2[1] = 13331;
		scanf("%d%d", &m, &n);
		for(int i = 2;i <= m;i++) base1[i] = base1[i - 1] * base1[1];
		for(int i = 2;i <= n;i++) base2[i] = base2[i - 1] * base2[1];
		for(int i = 1;i <= m;i++) for(int j = 1;j <= n;j++) scanf("%1llu", &h[i][j]);
		for(int i = 1;i <= m;i++) for(int j = 1;j <= n;j++) _h[i][j] = h[i][j];
		for(int i = 1;i <= m;i++) for(int j = 1;j <= n;j++) h[i][j] = h[i - 1][j] * base1[1] + h[i][j];
		for(int i = 1;i <= m;i++) for(int j = 1;j <= n;j++) h[i][j] = h[i][j - 1] * base2[1] + h[i][j];
		for(int i = m;i >= 1;i--) for(int j = n;j >= 1;j--) _h[i][j] = _h[i + 1][j] * base1[1] + _h[i][j];
		for(int i = m;i >= 1;i--) for(int j = n;j >= 1;j--) _h[i][j] = _h[i][j + 1] * base2[1] + _h[i][j];
		for(int len = min(m, n);len >= 2;len--){
			for(int i = 1;i <= m - len + 1;i++){
				for(int j = 1;j <= n - len + 1;j++){
					ull h1 = hash1(i + len - 1, j + len - 1, len), h2 = hash2(i, j, len);
					if(h1 == h2){
						printf("%d", len);
						return 0;
					} 
				}
			}
		}
		printf("-1");
		return 0;
	}
}
int main(){
	return ac::main();
}
```

---

## 作者：koobee (赞：0)

本体的思路可参考 [P2601 理想的正方形](https://www.luogu.com.cn/problem/P2601)，是一道二维哈希+二分的题。（不用二分可能也行，$O(n^3)$）

想法：将原图旋转 $180°$ 就是上下对称再左右对称，因此可将原矩阵求完哈希值后上下对称再左右对称，得到的新矩阵求二维哈希值（前缀和）。枚举中心或对称点 $(x,y)$。讨论边长奇偶性，可以直接枚举边长，如果想效率高一些就用二分，取出最大边长取最大值。

如何判断 $(x_1,y_1,x_2,y_2)$ 是内存杀手：

$(x_1,y_1,x_2,y_2)$ 上下对称再左右对称之后的区间应为 $(n-x_2+1,n-y_2+1,n-x_1+1,n-y_1+1)$，直接判断两个区间的哈希值是否一样就行了。

相信二维哈希各位都已经学过了，这里就不做详细解释了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 1005, P = 1e9+7, Q = 1e9+9;
ull p[N], q[N], h1[N][N], h2[N][N];
int n, m, ans=1;
char a[N][N];
ull Hash(int X1, int Y1, int X2, int Y2, int op){
	if(op == 1) return h1[X2][Y2] - h1[X2][Y1 - 1] * p[Y2 - Y1 + 1] - h1[X1 - 1][Y2] * q[X2 - X1 + 1] + h1[X1 - 1][Y1 - 1] * p[Y2 - Y1 + 1] * q[X2 - X1 + 1];
	return h2[X2][Y2] - h2[X2][Y1 - 1] * p[Y2 - Y1 + 1] - h2[X1 - 1][Y2] * q[X2 - X1 + 1] + h2[X1 - 1][Y1 - 1] * p[Y2 - Y1 + 1] * q[X2 - X1 + 1];
}
bool check(int X1, int Y1, int X2, int Y2){
	int n1 = n - X1 + 1, m1 = m - Y1 + 1, n2 = n - X2 + 1, m2 = m - Y2 + 1;
	ull H1 = Hash(X1, Y1, X2, Y2, 1), H2 = Hash(n2, m2, n1, m1, 2);
	if(H1 != H2) return 0;
	return 1;
}
int main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n>>m;
	q[0] = p[0] = 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			cin>>a[i][j];
			h1[i][j] = h1[i][j-1] * P + h1[i-1][j] * Q - h1[i-1][j-1] * P * Q + a[i][j] - '0' + 1;
		}
	for(int i = 1; i <= n; i++) q[i] = q[i-1] * Q;
	for(int j = 1; j <= m; j++) p[j] = p[j-1] * P;
	for(int i = 1; i <= n; i++)
		 for(int j = 1; j * 2 <= m; j++) swap(a[i][j], a[i][m-j+1]);
	for(int j = 1; j <= m; j++)
		for(int i = 1; i * 2 <= n; i++) swap(a[i][j], a[n-i+1][j]);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++) h2[i][j] = h2[i-1][j] * Q + h2[i][j-1] * P - h2[i-1][j-1] * Q * P + a[i][j] - '0' + 1;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			int l = 0, r = min(min(i, n-i), min(j, m-j));
			while(l < r){
				int mid = (l + r + 1) / 2;
				if(check(i - mid + 1, j - mid + 1, i+mid, j+mid)) l = mid;
				else r = mid - 1;
			}
			ans = max(ans, l*2), l = 0, r = min(min(i-1, n-i), min(j-1, m-j));
			while(l < r){
				int mid = (l + r + 1) / 2;
				if(check(i-mid, j-mid, i+mid, j+mid)) l = mid;
				else r = mid - 1;
			}
			ans = max(ans, l*2+1);
		}
	cout<<(ans == 1 ? -1 : ans);
	return 0;
}
```


---

## 作者：vеctorwyx (赞：0)

### ~~关于我做题时手玩了一个小时的哈希前缀和这件事~~

（复杂度均把题目中的 $m$ 视为 $n$ ，因为数量级一样\cy）

$n\le 300$ ，$O(n^4)$ 就能过~~吧大概~~。

首先暴力枚举一下 “  square killer ” 的位置和大小（复杂度 $O(n^3)$ ）

然后就是判断矩阵是否合法了（是否是 “ square killer ” ）：

第一行旋转后是倒数第一行的倒序，

第二行旋转后是倒数第二行的倒序，

。。。。。。

就可以用哈希维护每行的前缀和跟后缀和，通过哈希进行比较。

具体子串的哈希因人而异， ~~我的有点诡异~~， 具体还是看代码吧。

这样复杂度就是 $O(n^4)$ 的，**但是明显跑不满**， ~~而且还跑的蛮快的~~。

code:

```
#include<bits/stdc++.h>
#define int long long
#define p1 998244353
#define p2 1000000007
using namespace std;
int n, m;
char c[310][310];
int h1[310][310];
int h2[310][310];
int pf1[310];//预处理p1的n次方
void hash1(int x, int i, int j){//正序哈希插入
	h1[i][j] = h1[i][j - 1] * p1 % p2 + x;
}
void hash2(int x, int i, int j){//倒序哈希插入
	h2[i][j] = h2[i][j + 1] * p1 % p2 + x;
}
int ask1(int i, int l, int r){//正序哈希询问
	return ((h1[i][r] - h1[i][l - 1] * pf1[r - l + 1] % p2)% p2 + p2) % p2;
}
int ask2(int i, int l, int r){//倒序哈希询问
	return ((h2[i][l] - h2[i][r + 1] * pf1[r - l + 1] % p2)% p2 + p2) % p2;
}
bool cmp(int i, int j, int k){;
	int i1 = i + k - 1;
	int j1 = j + k - 1;
	int ji = 0;
	while(ji * 2 <= k + 1){
		if(ask1(i + ji, j, j1) != ask2(i1 - ji, j, j1))
			return 0;
		ji++;
	}
	return 1;
}
int maxx = 1;
signed main(){
	pf1[0] = 1;
	for(int i = 1; i <= 300; i++)
		pf1[i] = pf1[i - 1] * p1 % p2;
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= n; i++)
		scanf("%s", c[i] + 1);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++)
			hash1(c[i][j] - '0' + 1, i, j);
	}
	for(int i = 1; i <= n; i++){
		for(int j = m; j >= 1; j--)
			hash2(c[i][j] - '0' + 1, i, j);
	}
	for(int i = 1; i <= n; i++)//这里修改枚举顺序其实可以更快
		for(int j = 1; j <= m; j++)
			for(int k = maxx + 1; k <= min(n - i + 1, m - j + 1); k++)
				if(cmp(i, j, k))
					maxx = k;
	if(maxx == 1)
		puts("-1");
	else
		printf("%lld\n", maxx);
}
```

~~我哈希基本忘光了所以写的好怪哦~~

---

## 作者：EgLund (赞：0)

首先我们观察样例，发现"Sq Killer"就是正反相等的square，所以两遍hash即可。

为了求边长的最大值，我们二分边长的**一半**（注意奇偶性讨论），在`check`函数中，如果正反hash相等那么返回1。

具体hash细节见代码。
```
#include<iostream>
using namespace std;
#define int unsigned long long
int sum1[305][305],sum2[305][305];
const int base1=131,base2=63;
int bin1[305],bin2[305];
int n,m;
int a[305][305],b[305][305];
inline char getch()
{
	char c;cin>>c;return c;
}
inline bool check(int x,int y,int l)
{
	if (x>n||y>m) return 0;
	if (x<l||y<l) return 0;
	int xx=x,yy=y;
	int ans1=sum1[x][y]-sum1[x-l][y]*bin1[l]-sum1[x][y-l]*bin2[l]+sum1[x-l][y-l]*bin1[l]*bin2[l];
	x=n-(x-l); y=m-(y-l);
	int ans2=sum2[x][y]-sum2[x-l][y]*bin1[l]-sum2[x][y-l]*bin2[l]+sum2[x-l][y-l]*bin1[l]*bin2[l];
	if (ans1!=ans2) return 0;
	return 1;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(register int i=1;i<=n;i++)
	for(register int j=1;j<=m;j++)
	a[i][j]=getch()-'0';
	bin1[0]=bin2[0]=1;
	for(register int i=1;i<=n;i++)bin1[i]=bin1[i-1]*base1;
	for(register int i=1;i<=m;i++)bin2[i]=bin2[i-1]*base2;
	for(register int i=1;i<=n;++i)
	for(register int j=1;j<=m;++j)
	sum1[i][j]=sum1[i][j-1]*base2+a[i][j];
	for(register int i=1;i<=n;++i)
	for(register int j=1;j<=m;++j)
	sum1[i][j]+=sum1[i-1][j]*base1;
	for(register int i=1;i<=n;++i)
	for(register int j=1;j<=m;++j)
	b[i][j]=a[n-i+1][m-j+1];
	for(register int i=1;i<=n;++i)
	for(register int j=1;j<=m;++j)
	sum2[i][j]=sum2[i][j-1]*base2+b[i][j];
	for(register int i=1;i<=n;++i)
	for(register int j=1;j<=m;++j)
	sum2[i][j]+=sum2[i-1][j]*base1;
	int ans=0,sum=0;
	for(register int i=1;i<=n;i++)
	for(register int j=1;j<=m;j++)
	{
		int l=1,r=min(n,m);
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(i+mid,j+mid,mid+mid+1))ans=mid,l=mid+1;
			else r=mid-1;
		}
		sum=max(sum,ans+ans+1);
	}
	for(register int i=1;i<=n;i++)
	for(register int j=1;j<=m;j++)
	{
		int l=1,r=min(n,m);
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(i+mid,j+mid,mid+mid))ans=mid,l=mid+1;
			else r=mid-1;
		}
		sum=max(sum,ans+ans);
	}
	if(sum>1)cout<<sum;else cout<<"-1";
}
```

---

## 作者：封禁用户 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P4330)

# First 题意

题意不难理解，就是在一个矩阵中，找出一个正方形，使它满足反转 $180\degree$ 之后还是本身，求正方形的最大变长 $ans$ （$ans > 1$），若没有，输出 `-1`。

# Second 暴力

暴力不难想，就是 $O(n^3)$ 暴力枚举一波中心点和边长，再来 $O(n^2)$ 判断是否反转后还是本身。

总时间复杂度 $O(n^5)$，恭喜 T 飞了。

# Third 小优化

好的，前一种算法还能优化。

我们可以发现，这其实就是一个二维回文串的求解，可以用 `manacher` 来求解。

但是我太蒻了，不会二维 `manacher`，但没事，我们可以参考一下回文串求解的方法。

去 `manacher` 模板题题解里就会发现，有一种算法可以 $O(n^2)$ 的求解，就是枚举反转的中心，然后向外扩展。

这个算法放到这题里，就可以 $O(n^4)$ 的求解了。

恭喜，还是 T 了。

# Fourth 优化

我们再看 Second 的思路，每次判断都需要反转过来一一匹配，这不就是 `hash` 干的事吗？把 `hash` 放到这题里来，就是一个前缀和 `hash` 了。

求解方法就是预处理矩阵前缀和后缀的 `hash` 值，每次就可以 $O(1)$ 判断，加上 $O(n^3)$ 的枚举，总共时间复杂度 $O(n^3)$。

恭喜，终于 A 了。

# Fifth 提示

不开 `long long` 见祖宗。

# Sixth Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define max(a, b) a > b ? a : b
const ll P = 1000000009, C1 = 10007, C2 = 10009; 
ll n, m, mp[305][305], ran_d1[305], ran_d2[305], ha1[305][305], ha2[305][305];
char ch;
il ll hash1(ll a, ll b, ll c, ll d){
	ll ans = (ha1[c][d] - ha1[a - 1][d] - ha1[c][b - 1] + ha1[a - 1][b - 1] + P) % P;
	return ans * ran_d1[n - a] % P * ran_d2[m - b] % P;
}
il ll hash2(ll a, ll b, ll c, ll d){
	ll ans = (ha2[a][b] - ha2[c + 1][b] - ha2[a][d + 1] + ha2[c + 1][d + 1] + P) % P;
	return ans * ran_d1[c - 1] % P * ran_d2[d - 1] % P;
}
int main(){
	scanf ("%lld %lld", &n, &m);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			cin >> ch;
			mp[i][j] = ch - '0';
		}
	}
	ran_d1[0] = ran_d2[0] = 1;
	for (int i = 1; i <= 300; i++)
		ran_d1[i] = ran_d1[i - 1] * C1 % P, ran_d2[i] = ran_d2[i - 1] * C2 % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			ha1[i][j] = ran_d1[i] * ran_d2[j] * mp[i][j] % P, ha2[i][j] = ran_d1[n - i + 1] * ran_d2[m - j + 1] * mp[i][j] % P;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			ha1[i][j] = ha1[i][j] + ha1[i - 1][j] + ha1[i][j - 1] - ha1[i - 1][j - 1];
	for (int i = n; i >= 1; i--)
		for (int j = m; j >= 1; j--)
			ha2[i][j] = ha2[i][j] + ha2[i + 1][j] + ha2[i][j + 1] - ha2[i + 1][j + 1];
	ll ans = -1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 1; i + k <= n && j + k <= m; k++)
				if (hash1(i, j, i + k, j + k) == hash2(i, j, i + k, j + k))
					ans = max(ans, k + 1);
	printf ("%lld", ans);
	return 0;
}

```

---


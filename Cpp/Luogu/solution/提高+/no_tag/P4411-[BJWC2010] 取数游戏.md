# [BJWC2010] 取数游戏

## 题目描述

小 C 刚学了辗转相除法，正不亦乐乎，这小 P 又出来捣乱，给小 C 留了个 难题。 给 $N$ 个数，用 $a_1,a_2, \cdots ,a_n$来表示。现在小 P 让小 C 依次取数，第一个数可以 随意取。假使目前取得 $a_j$，下一个数取$a_k(k>j)$，则$a_k$必须满足$\mathrm{gcd}(a_j,a_k)≥L$。 

到底要取多少个数呢？自然是越多越好！ 不用多说，这不仅是给小 C 的难题，也是给你的难题。

## 说明/提示

### 样例解释

选取 $3$个数$16,24,6$。$\mathrm{gcd}(16,24)=8$，$\mathrm{gcd}(6,24)=6$。 

### 数据范围

30% 的数据$N≤1000$；   
100% 的数据 $N≤50 000,2≤L≤a_i≤1 000 000$。

## 样例 #1

### 输入

```
5 6 
7 16 9 24 6```

### 输出

```
3```

# 题解

## 作者：ytb2024 (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P4411)

题意：从头到尾选数，相邻两个数的 $\gcd$ 应大于等于 $L$，最多能选多少个数。

## 30 pts
相信很多同学的第一想法是 DP。一维 $f_i$ 表示选当前的这个数的最大值，可以 $O\left(n^2\right)$ 实现。具体为（不会写公式的蒟蒻 qwq），$j<i$ 且 $\gcd\left(a_i,a_j\right)\ge$ $L$ 时，$f_i=f_j+1$，$f_i$ 取最大值。最后 $ans$ 为所有 $f_i$ 中的最大值。

下面是代码实现，就不加注释了。（看一看前面的就知道）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,a[50001],f[50001],ans=1;
inline void init()
{
	cin>>n>>l;
	for(int i=1;i<=n;i++)cin>>a[i],f[i]=1;
}
inline void solve()
{
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<i;j++)if(__gcd(a[i],a[j])>=l)f[i]=max(f[i],f[j]+1);
		ans=max(ans,f[i]);
	}
	cout<<ans;
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
	init(),solve();
	return 0;
}
```
## 100 pts
我们可以发现，题目中的 $L$ 与 $a_i$ 不超过 $10^6$。

而对 $\gcd\left(a_i,a_j\right)\ge{L}$ 的理解可以转化成 $a_i$ 与 $a_j$ 的相同约数至少要为 $L$。

由于 $L$ 与 $a_i$ 很小，所以考虑预处理所有 $a_i$ 的约数，但是小于 $L$ 的可以不管(后面会提到)。

**注意**：由于此题空间很小，如果数组的第二维开得太大了，就会[MLE](/record/96720941)。这里经过计算后，$10^6$ 内约数最多（不包含 $1$）的是 $720720$，有约数 $239$ 个，所以考虑第二维开 $250$。

```cpp
for(int i=1;i<=n;i++)
{
	int x;
	cin>>x;
	for(int j=1;j*j<=x;j++)if(x%j==0)
	{
		if(j>=l)a[i][++t[i]]=j;
		if(x/j>=l&&j*j!=x)a[i][++t[i]]=x/j;
	}
}
```
可以发现这相当于一个一个的组，在同一个组的数是可以用前面的更新后面的，而小于 $L$ 的明显是不可以更新值的，而上面的预处理便是把它的每一个组记录下来。

可以对每一个组开一个数组，表示这个组中目前的最大值。对于每个数，从它所在的所有组中选最大值，$+1$ 后将它在的组全部更新为这个数。
```cpp
for(int i=1;i<=n;i++)
{
	int sum=0;
	for(int j=1;j<=t[i];j++)sum=max(sum,maxn[a[i][j]]+1);
	ans=max(ans,sum);
	for(int j=1;j<=t[i];j++)maxn[a[i][j]]=sum;
}
```
最后输出 $ans$ 就可以 AC 啦。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,a[50001][250],t[50001],maxn[1000001],ans;
inline void init()
{
	cin>>n>>l;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		for(int j=1;j*j<=x;j++)if(x%j==0)
		{
			if(j>=l)a[i][++t[i]]=j;
			if(x/j>=l&&j*j!=x)a[i][++t[i]]=x/j;
		}
	}
}
inline void solve()
{
	for(int i=1;i<=n;i++)
	{
		int sum=0;
		for(int j=1;j<=t[i];j++)sum=max(sum,maxn[a[i][j]]+1);
		ans=max(ans,sum);
		for(int j=1;j<=t[i];j++)maxn[a[i][j]]=sum;
	}
	cout<<ans;
}
int main()
{
	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
	init(),solve();
	return 0;
}
```

---

## 作者：yuzhechuan (赞：13)

简单dp

---
f[i]表示一定选第i个数的条件下前i个数所能得到的最优值

last[i]表示质因数i在数列a中最后出现时的下标

状态转移方程为$f[i]=max\{f[last[j]\:|\: j|i \}+1$

复杂度$O(n\sqrt{a_i})$

---
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l,ans,a[50005],last[1000005],f[50005];
signed main(){
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		int SQRT=sqrt(a[i]); //循环外先算出，提高效率
		for(int j=1;j<=SQRT;j++)if(a[i]%j==0){
			int x=j,y=a[i]/j; //x,y是a[i]的一组因数
			if(x>=l) f[i]=max(f[i],f[last[x]]+1); //由上一个有相同质因数的数转移得到
			if(y>=l) f[i]=max(f[i],f[last[y]]+1);
			last[x]=last[y]=i; //修改质因数的最后出现下标
		}
		ans=max(ans,f[i]); //保存最优解
	}
	printf("%d",ans);
}
```

---

## 作者：Hexarhy (赞：6)

### Preface

动态规划稍微进阶的题，需要简单的优化，没有涉及高深的前置知识，适合新手提升。难度评紫恶评了吧，大致绿。

### Description

给定 $n$ 个数，从左往右依次取数。当前的数 $a_j$ 与前一个数 $a_i$ 满足 $\gcd(a_i,a_j)\ge L$ 则可以取。输出可以取数的最大数量。

### Solution

显然这是动态规划题，要考虑如何转移。

先考虑朴素做法。设 $F_i$ 为枚举到第 $i$ 位时的最多能选取的数量。根据题意，我们就有：

$$F_i=\max_{1\le j<i}\{F_j+1\}(\gcd(a_i,a_j)\ge L)$$

时间复杂度 $O(n^2)$。

接下来考虑如何优化。

思考暴力的瓶颈在哪。我们第二层循环枚举 $j$ 显然造成了许多浪费。利用 $\gcd$ 的限制，我们可以快速选出我们想要的 $j$。结合 $L$ 和 $a_i$ 的值域很小，我们可以往这方面思考。

为了使 $\gcd(a_i,a_j)\ge L$，我们枚举 $a_i$ 的因数 $x$，对于每一个 $x\ge L$，我们就寻找最近的 $x$ 之前出现的位置并递推过来。

设 $t_x$ 为因数 $x$ 最近在之前出现的位置。我们就得到：

$$F_i=\max_{x|a_i}\{F_{t_x}\}+1$$

为什么是 $a_i$ 前面最近的就可以了呢？因为再往前的数也都会由这个递推式递推过来。此时 $F_{t_x}$ 已经是前面最优的了。

当然枚举 $x$ 不会是整个枚举，枚举到 $\sqrt{a_i}$ 就可以了，另一个 $O(1)$ 计算出来。这是很基础的技巧。

$t_i$ 可以在递推的时候顺便得到。

时间复杂度 $O(n\sqrt a_i)$。

### Notice

1. 开数组时别忘了 `t[]` 要开到 $a_i$ 值域大小。

1. 答案是 $\max\{F_i\}$ 而非 $F_n$。自己想想。

1. 枚举 $x$ 的时候，注意可能 $x=\frac{n}{x}$，要特判是否会相等，否则会统计两次，造成答案错误。

### Code

```cpp#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN=1e6+5;
int n,L;
int a[MAXN],f[MAXN],t[MAXN]; 

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>L;
    for(int i=1;i<=n;i++)
     cin>>a[i];
    for(int i=1;i<=n;i++)
    {
    	for(int x=1;x*x<=a[i];x++)
    	 if(a[i]%x==0)
    	 {
    	 	const int u=x,v=a[i]/x;
    	 	if(u>=L)
    	 	{
    	 		f[i]=max(f[i],f[t[u]]+1);
    	 		t[u]=i;//顺便求 ti
			}
    	 	if(v>=L && u!=v)//注意特判
    	 	{
    	 		f[i]=max(f[i],f[t[v]]+1);
    	 		t[v]=i;
			}
		 }
	}
    cout<<*max_element(f+1,f+1+n)<<endl;
	return 0;
}
```

---

## 作者：Betrayer_of_love (赞：2)

### 思路


------------
我们用一种类似 LIS 的 DP 思路，用 $dp_i$ 表示以i结尾最多能选多少个数，有以下转移：$dp_i=\max_{\substack{j | a_i,j \ge l}}{dp[lst_j]}$。 

其中 $lst_i$ 表示含因数 $i$ 的数最后一次出现的位置。易知对于每一个因数，含它的数的位置越靠后，dp 值是不降的，因此转移成立。枚举因数转移一下即可。

复杂度 $O (n\sqrt{\smash[b]{y}})$。

### CODE

```c
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
inline char fgc() {
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)
        ? EOF : *p1++;
}
inline LL readint() {
    register LL res = 0, neg = 1; register char c = fgc();
    for(; !isdigit(c); c = fgc()) if(c == '-') neg = -1;
    for(; isdigit(c); c = fgc()) res = (res << 1) + (res << 3) + c - '0';
    return res * neg;
}
const int MAXN = 1000005;
int n, l, a[MAXN], lst[MAXN], dp[MAXN];
int main() {
    n = readint(); l = readint();
    for(int i = 1; i <= n; i++) {
        a[i] = readint();
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j * j <= a[i]; j++) {
            if(a[i] % j == 0) {
                if(j >= l) dp[i] = std::max(dp[i], dp[lst[j]] + 1);
                if(a[i] / j >= l) dp[i] = std::max(dp[i], dp[lst[a[i] / j]] + 1);
                lst[j] = lst[a[i] / j] = i;
            }
        }
        ans = std::max(ans, dp[i]);
    }
    printf("%d", ans);
    return 0;
}
```


**完结撒花，谢谢！！！**

---

## 作者：pikabi (赞：2)

看到大家都是用 $f_i$ 来存储枚举到 $i$ 的答案，这里再来一种别样的方法。

同样得先枚举 $a_i$ 的约数，我们其实不需要存储 $a_i$ , 边读边算即可。

我们用 $ma_i$ 存储约数为 $i$ 的最大答案数量，每次先遍历出 $a_i$ 约数的最大 $ma_i$ 为 $ans_i$ , 并用 vector 存储约数，最后将每个 $ma_i$ = $ans_i + 1$ 即可。

下面给出代码 $-->$

```
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <vector>
#include <cmath>
#define ll long long
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

vector <int> vec[500006];

int n, l, a[50005], ma[1000006], ans[50005], anss;

int main(){
	n = read();
	l = read();
	for(int i = 1; i <= n; i++){
		int j;
		j = read();
		int m = sqrt(j);
		for(int x = 1; x <= m; x++){
			if(j % x == 0){
				int y = j / x;
				if(x >= l){
					vec[i].push_back(x); 
					ans[i] = max(ans[i], ma[x]);
				}
				if(x != y && y >= l){
					vec[i].push_back(y); 
					ans[i] = max(ans[i], ma[y]);
				}
			}
		}
		anss = max(anss, ans[i] + 1);
		for(int j = 0; j < vec[i].size() ; j++){
			ma[vec[i][j]] = ans[i] + 1;
		}	
	}
	printf("%d",anss);
    return 0;
}
```

完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：lraM41 (赞：1)

记 $dp_i$ 为前 $i$ 个数中最多能取多少个数，我们可以枚举 $a_i$ 的因数 $j$，如果 $L \le j$，说明 $a_i$ 可以和上一个有因数 $j$ 的数一起取，即转移: $dp_i=\max(dp_i,dp[lst_j]+1)$,转移后更新上一个有因数 $j$ 的数的位置。

可以做到 $O(\sqrt{\smash[b]{a_i}})$ 枚举因数。

```
#include<bits/stdc++.h>
using namespace std;
int n,l,a[50005],dp[50005],lst[1000005],s;
signed main(){
    cin>>n>>l;
    for(int i=1;i<=n;i++) cin>>a[i],dp[i]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j*j<=a[i];j++){
            if(a[i]%j) continue;
            if(j*j!=a[i]&&a[i]/j>=l) dp[i]=max(dp[i],dp[lst[a[i]/j]]+1);
            if(j>=l) dp[i]=max(dp[i],dp[lst[j]]+1);
            lst[a[i]/j]=lst[j]=i;
        }
    }
    for(int i=1;i<=n;i++) s=max(s,dp[i]);
    cout<<s;
    return 0;
}

---

## 作者：Piwry (赞：1)

写完发现我的思路和其它题解都不一样？

~~快水题解a~~

## 解析

题意就不分析了

其它的题解貌似都是设 $dp[i]$ 作为一定选第 $i$ 个数时最长的子序列长度，然后再开一个记录质因子最后出现位置的辅助数组帮助转移

然而可能我的思路比较清奇...我设 $dp[i][j]$ 表示当选到第 $i$ 个数时，子序列结尾**含**质因子 $j$ 的最长长度

于是转移方程就是 $\forall p'|a_i, dp[i][p'] = \sum\limits_{p | a_i, p \geq L}max(dp[i-1][p]+1)$ 和 $dp[i][j]=dp[i-1][j]$（对于没有更新的位置）；以及一个设当前数为序列开头的转移（这里就不写式子了）

（这样每次拓展子序列时，$\gcd(a_j, a_k)$ 可能会大于枚举的 $p$，不过这并不影响答案）

对于每个 $a_i$，根号枚举质因子转移即可

&nbsp;

不过这里开二维数组会炸空间，同时也不可能每次都 $O(10^6)$ 地转移

先把第一维滚了，然后我们发现每次涉及到的 $dp[j]$ 都要满足 $j|a_i$，于是在枚举质因数时把这几个需要用到的 $dp$ 值存下来即可（具体可见代码）

由于质因子个数是 $\log n$ 级别的，所以这样每次转移的复杂度就可以接受了

总的复杂度应该是 $O(n\sqrt n)$（瓶颈在于分解质因数）

## CODE

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using std::max;

const int MAXN =1e6+50;

int dp[MAXN];/*表示序列结尾含质因子 i 的最长序列长度*/
int dppre[1000];
int fact[1000], tot;

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	int n =read(), L =read();
	/*对于 dp[i-1][p] 为 0 的转移可能有点不严谨 ( 转移前子序列没有元素 )...不过没关系*/
	for(int k =0; k < n; ++k){
		int ai =read();
		tot =0;
		for(int i =1; i <= sqrt(ai)+1; ++i)
			if(ai%i == 0){
				dppre[tot] =dp[i];
				fact[tot++] =i;
				if(ai/i != i){
					dppre[tot] =dp[ai/i];
					fact[tot++] =ai/i;
				}
			}
		/*a_k 和 a_j 的 gcd 可能比枚举的还大，不过这没有大碍qaq*/
		for(int i =0; i < tot; ++i){
			if(fact[i] < L)
				continue;
			for(int j =0; j < tot; ++j)
				dp[fact[j]] =max(dp[fact[j]], dppre[i]+1);
		}
		for(int i =0; i < tot; ++i)
			dp[fact[i]] =max(dp[fact[i]], 1);/*选当前数为开头*/
	}
	int ans =0;
	for(int i =0; i < MAXN; ++i)
		ans =max(ans, dp[i]);
	printf("%d", ans);
}
```

---

## 作者：cirnovsky (赞：1)

## 题意简述

在一个序列中选数，使得其GCD大于某个定值，问最多能选几个。

## 题解

蓝题过了吧。

定义 $dp_{i}$ 为选第 $i$ 个数的情况下前 $i$ 个数的最优答案

方程:

$$
dp_{i}=\max_{1\le j<i,\gcd(a_{i},a_{j})\ge L}\{dp_{j}+1\}
$$

发现光这样转移的复杂度为n方，T飞。

令 $las_{x}$  表示约数 $x$ 上次出现的位置。

则方程可以写成：

$$
dp_{i}=\max_{j\mid i}\{dp_{las_{j}}+1\}
$$

则答案为：

$$ANS=\max_{1\le i\le n}\{dp_{i}\}$$

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int Maxn = 1e6 + 5;
int n, L, a[Maxn], dp[Maxn], las[Maxn];

signed main() {
	scanf("%d %d", &n, &L);
	for (int i = 1; i <= n; ++i) 	scanf("%d", &a[i]);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j * j <= a[i]; ++j) {
			if (a[i] % j == 0) {
				int X = j, Y = a[i] / j;
				if (X >= L) {
					dp[i] = max(dp[i], dp[las[X]] + 1);
					las[X] = i;
				}
				if (X != Y) {
					dp[i] = max(dp[i], dp[las[Y]] + 1);
					las[Y] = i;
				}
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) 	ans = max(ans, dp[i]);
	return printf("%d\n", ans), 0;
}
```

---

## 作者：For_The_Union (赞：0)

本题可使用动态规划解决。

设 $f_i$ 表示强制选第 $i$ 个数，前 $i$ 个数中最多能选出多少数。

维护一个桶，第 $i$ 个位置表示包含 $i$ 这个因子的数最大的 $f$ 值是多少。

转移时枚举因子，从桶里找最大值即可。

转移完再将当前数加入桶中，同样枚举因子即可。

时间复杂度 $O(nσ(V))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool im(int n)
{
  if(n<2)return 0;
  for(int i=2;i*i<=n;++i)
  if(n%i==0)return 0;
  return 1;
}//这个函数非常有用，它可以给我撑场子！
int n,m,i,j,a[50002][250],b[50002],s[1000002],maxn=-1,x,sum;
int main()
{
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin>>n>>m;
  for(i=1;i<=n;++i)
  {
	cin>>x;
	for(j=1;j*j<=x;++j)
	if(x%j==0)
	{
	  if(j>=m)
	  a[i][++b[i]]=j;
	  if(x/j>=m&&j*j!=x)
	  a[i][++b[i]]=x/j;
	}
  }
  for(i=1;i<=n;++i)
  {
	sum=0;
	for(j=1;j<=b[i];++j)
	sum=max(sum,s[a[i][j]]+1);
	maxn=max(maxn,sum);
	for(j=1;j<=b[i];++j)
	s[a[i][j]]=sum;
  }
  cout<<maxn;
  return 0;//好习惯
}
```

---

## 作者：M4rkSELby (赞：0)

考虑 DP。

设 $f_i$ 为选择第 $i$ 个数时最多能取到多少数，$lst_i$ 为因子 $i$ 上一次出现的位置。可以对于每个 $a_i$ 枚举其所有因子，再设当前枚举到的因子为 $j$，则意味着我们上一个数可以选择 $a_{lst_j}$，则考虑转移：

$$f_i=max(f_i,f_{lst_j}+1)$$

同时更新 $lst_j$ 为 $i$。注意枚举时枚举到的因子为 $j$，我们还要把与 $j$ 对应的因子 $a_i/j$ 也顺带更新掉。更新方式同 $j$ 的更新方式。由此我们可以将枚举因子的复杂度降为 $\sqrt{a_i}$，复杂度为 $O(n\sqrt{a_i})$，可以过掉此题。

附上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 1000000007
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=(jya<<1)+(jya<<3)+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
int n,l,a[50086],f[50086],ans,lst[1000086];
signed main(){
	n=rd();l=rd();
	for(int i=1;i<=n;++i)a[i]=rd(),f[i]=1;
	for(int i=1;i<=n;++i){
		for(int j=1;j*j<=a[i];++j){
			if(a[i]%j!=0)continue;
			if(j>=l)f[i]=max(f[i],f[lst[j]]+1);
			if(a[i]/j>=l)f[i]=max(f[i],f[lst[a[i]/j]]+1);
			lst[j]=lst[a[i]/j]=i;
		}
	}
	for(int i=1;i<=n;++i)ans=max(ans,f[i]);
	wr(ans);
	return 0;
}
```

---

## 作者：tXX_F (赞：0)

# [BJWC2010] 取数游戏

## [传送门](https://www.luogu.com.cn/problem/P4411)

## 解题思路

根据题意，我们不难列出动态转移方程：$f_i=\max{f_j+1}(1\leq j <i,\gcd(a_i,a_j)\geq L)$。但是，时间复杂度为 $O(n^2)$ 无法通过。

再仔细想，会发现 $\gcd(a_i,a_j)$ 可以用桶记录，$tong_x$ 表示因数 $x$ 最近一次出现的位置，那么方程式可以写成 $f_i=\max(f_{tong_x}+1)(x\mid a_i)$，则最终答案 $Ans=\max(f_i)$。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int Maxn = 1000000 + 5;
int N, L, a[Maxn];
int tong[Maxn], f[Maxn];
int ans;
inline void work() {
	cin >> N >> L;
	for (int i = 1; i <= N; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= N; i++) {
		for (int j = 1; j * j <= a[i]; j++) {
			if (a[i] % j == 0) {
				int tmp1 = j, tmp2 = a[i] / j;
				if (tmp1 >= L) {
					f[i] = max(f[i], f[tong[tmp1]] + 1);
					tong[tmp1] = i;
				}
				if (tmp1 != tmp2) {
					f[i] = max(f[i], f[tong[tmp2]] + 1);
					tong[tmp2] = i;
				}
			}
		}
	}
	for (int i = 1; i <= N; i++) {
		ans = max(ans, f[i]);
	}
	cout << ans << endl;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	work();
	return 0;
}
```

---

## 作者：sycqwq (赞：0)

__思路：__

考虑 $dp$。

设 $f_i$ 为以第 $i$ 个数结尾最多可以选的数，显然对于任何选的数 $j$，都有 $j\leq i$。

$n^2$ 的做法就是对于每一个 $f_i$，暴力转移，$f_i=max(f_i,f_k+1)$，$k<i$，$gcd(a_k,a_i) \ge L$。

这样的复杂度是不能接受的。

可以考虑从那个 $gcd$ 来进行优化。

可以发现，$gcd(a_i,a_k)$ 一定是 $a_i$ 的因子，且一定是一个合法转移的 $a_k$ 的因子。

所以我们可以设 $lst_j$ 为存在一个因子为 $j$ 的 $a_i$ 的 $f_i$ 的最大值。

而每次转移的时候，只需要找出 $a_i$ 的因子，然后对于满足条件的用 $lst$ 更新就好，具体可以见代码。

__代码：__

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+5;
int n,l,a[maxn],lst[maxn],f[maxn];
int main()
{
    cin>>n>>l;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    int s=0;
    for(int i=1;i<=n;i++)
    {
        f[i]=1;
        for(int j=1;j<=sqrt(a[i]);j++)
        {
            if(a[i]%j==0)//如果是因子的话
            {
                f[i]=max(f[i],max((j>=l)?(lst[j]+1):0,(a[i]/j>=l)?(lst[a[i]/j]+1):0)); 
            }
        }
        for(int j=1;j<=sqrt(a[i]);j++)//更新lst
            if(a[i]%j==0)
                lst[j]=max(lst[j],f[i]),lst[a[i]/j]=max(lst[a[i]/j],f[i]);
        s=max(s,f[i]); 
    }
    cout<<s<<endl;
    return 0;
}
```

---

## 作者：FjswYuzu (赞：0)

[动态规划 100 题查 22 题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)。

考虑到我们朴素 dp 的缺点在于需要枚举质因数。先不考虑 dp，我们要让答案尽量的大，空闲不取的数一定要尽量的少。

也就是说，如果满足有 $i,j,k$，$i<j<k$，并且 $\gcd(a_i,a_j) \geq L,\gcd(a_i,a_k) \geq L,\gcd(a_j,a_k) \geq L$，通过 $i \to j \to k$ 的转移方案数一定大于 $i \to k$。

于是我们定义 $dp_i$ 为选 $a_i$ 的最大合法答案，$pre_j$ 为因子 $j$ 上一次出现的地点，有：

$$dp_i=\max\{ dp_{pre_j} ,dp_{pre_{a_i/j}}\}+1$$

其中 $j$ 为 $a_i$ 的因子。这道题就很显而易见了。

```cpp
#include<cstdio>
int max(int a,int b){return a>b?a:b;}
int dp[50005],a[50005],pre[1000005];
int main(){
	int n,L;
	scanf("%d %d",&n,&L);
	for(int i=1;i<=n;++i)	scanf("%d",&a[i]),dp[i]=1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j*j<=a[i];++j)
		{
			if(a[i]%j)	continue;
			if(a[i]/j>=L)	dp[i]=max(dp[i],dp[pre[a[i]/j]]+1);
			if(j>=L)	dp[i]=max(dp[i],dp[pre[j]]+1);
			pre[j]=pre[a[i]/j]=i;
		}
	}
	int ans=0;
	for(int i=1;i<=n;++i)	ans=max(ans,dp[i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：JZYshuraK (赞：0)

# 取数游戏
题解：
显然可以用动态规划解决。

状态：$dp_i$表示强制选第$i$个数，前$i$个数中最多能取多少个数。

转移是$O(n^2)$的。

接下来，我们思考：如何才能优化这个过程。

有一个性质：

假设存在$i<j<k$，使得$m|a_i,m|a_j,m|a_k,m\ge L$，那么我们选择用$j$更新$k$而不是$i$，原因在于$f_j$完全可以在$i$构成的序列中，后面加上$j$因为$gcd(a_i,a_j)\ge m\ge L$。

所以我们只需要更新出$mx$数组：$mx_i$表示枚举到当前的$a$，可以被$i$整除的最大的下标（时间戳）最大是多少。

接下来，我们既可以通过$mx$数组来更新$dp$数组。

具体地：每次我们枚举当前元素的时候，将当前元素质因数分解，动态更新$mx$数组。

如何更新$f$数组呢？

我们只需要将$mx$数组的值直接加到$f$上可。

总时间复杂度$O(n\sqrt {a_i})$。

Code:
```cpp
#include <bits/stdc++.h>
#define N 50010 
#define M 1000010 
using namespace std;
int f[N],mx[M],a[N];
inline char nc() {static char *p1,*p2,buf[100000]; return (p1==p2)&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;}
int rd() {int x=0; char c=nc(); while(!isdigit(c)) c=nc(); while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=nc(); return x;}
int main()
{
	int n=rd(),L=rd(); for(int i=1;i<=n;i++) a[i]=rd();
	for(int i=1;i<=n;i++)
	{
		int now=0;
		for(int j=1;j*j<=a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(j>=L) now=max(now,mx[j]);
				if(j*j!=a[i])
				{
					if(a[i]/j>=L) now=max(now,mx[a[i]/j]);
				}
			}
		}
		f[i]=now+1;
		for(int j=1;j*j<=a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(j>=L) mx[j]=max(mx[j],f[i]);
				if(j*j!=a[i])
				{
					if(a[i]/j>=L) mx[a[i]/j]=max(mx[a[i]/j],f[i]);
				}
			}
		}
	}
	int ans=0; for(int i=1;i<=n;i++) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```
推销个人blog [JZYshuraK](https://www.cnblogs.com/ShuraK/p/10237630.html)

---

## 作者：lizhous (赞：0)

[洛谷传送门](https://www.luogu.com.cn/problem/P4411)

## 分析

受到最长不下降子序列的启发，我们想到向前枚举合法，然后 DP 一下。但这样时间复杂度不对，我们考虑用空间换时间。

我最开始想到开值域个 vector，第 $i$ 个存储含有因数 $i$ 的数的 DP 值，每次转移只需要枚举因数并在线扫对应的 vector 即可。但我们发现这样可能退化到 $O(n^2)$，考虑继续优化。

我们发现我们并不关心具体 DP 值，我们只关心所有 vector 中的 DP 最大值。省去 vector，设 $ma_i$ 表示含有因数 $i$ 的数的 DP 最大值。在线更新即可。时间复杂度 $O(n\sqrt {\max a})$。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define int long long
#define mod 1000000007
using namespace std;
long long n,m,ma[1000001],ans;
int work(int a)
{
	if(a<m) return 0; //小于定值，不合法
	return ma[a];
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1,a;i<=n;i++)
    {
    	int maa=0; //当前DP值
		scanf("%lld",&a);
		for(int z=1;z*z<=a;z++)
		{
			if(a%z==0)
			{
				maa=max(maa,work(z)); //更新
				maa=max(maa,work(a/z));
			}
		}
		maa++; //增加序列长度
		for(int z=1;z*z<=a;z++)
		{
			if(a%z==0)
			{
				if(z>=m) //合法
				{
					ma[z]=max(ma[z],maa); //更新
				}
				if(a/z>=m)
				{
					ma[a/z]=max(ma[a/z],maa);
				}
			}
		}
		ans=max(ans,maa); //更新答案
	}
	printf("%lld",ans); //输出
}
```

---

## 作者：For_The_Union (赞：0)


设 $fi$ 表示强制选第 $i$ 个数，前 $i$ 个数中最多能选出多少数。

维护一个桶，第 $i$ 个位置表示包含 $i$ 这个因子的数最大的 $f$ 值是多少。

转移时枚举因子，从桶里找最大值即可。

转移完再将当前数加入桶中，同样枚举因子即可。

时间复杂度 $O(nσ(V))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool im(int n)
{
  if(n<2)return 0;
  for(int i=2;i*i<=n;++i)
  if(n%i==0)return 0;
  return 1;
}//这个函数非常有用，它可以给我撑场子！
int n,m,i,j,a[50002][250],b[50002],s[1000002],maxn=-1,x,sum;
int main()
{
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin>>n>>m;
  for(i=1;i<=n;++i)
  {
	cin>>x;
	for(j=1;j*j<=x;++j)
	if(x%j==0)
	{
	  if(j>=m)
	  a[i][++b[i]]=j;
	  if(x/j>=m&&j*j!=x)
	  a[i][++b[i]]=x/j;
	}
  }
  for(i=1;i<=n;++i)
  {
	sum=0;
	for(j=1;j<=b[i];++j)
	sum=max(sum,s[a[i][j]]+1);
	maxn=max(maxn,sum);
	for(j=1;j<=b[i];++j)
	s[a[i][j]]=sum;
  }
  cout<<maxn;
  return 0;//好习惯
}
```


---


# [COCI 2006/2007 #2] STOL

## 题目描述

米尔科买了一套别墅，他想要邀请尽量多的人和他一起庆祝。他需要一张大的木质矩形桌子来让他和他的嘉宾坐下。每张桌子可容纳的人数等于它的周长（四边长度的总和）。米尔科想要买一张即可在他的公寓里放下，也可以坐下尽量多的人和他一起享用晚餐的桌子。桌子必须放置成四条边都与公寓的墙平行的样子。题目给出公寓内部的布局，请问米尔科最多可以邀请多少人吃晚餐。

## 样例 #1

### 输入

```
2 2
..
..```

### 输出

```
7```

## 样例 #2

### 输入

```
4 4
X.XX
X..X
..X.
..XX```

### 输出

```
9```

## 样例 #3

### 输入

```
3 3
X.X
.X.
X.X```

### 输出

```
3```

# 题解

## 作者：ROY1994 (赞：8)

枚举区间 $l$ ~ $r$ 

再计算最多有多少行在 $l$ ~ $r$ 上没有 X

可以每行用前缀和维护 X 的数量

时间复杂度 $O(n^2)$ 

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[405][405];
int sum[405][405];
int r,s,ans=-10000;
int main()
{
	scanf("%d%d",&r,&s);
	for(int i=1;i<=r;i++)
		scanf("%s",a[i]+1);
	for(int i=1;i<=r;i++)
		for(int j=1;j<=s;j++)
			if(a[i][j]=='X') sum[i][j]=sum[i][j-1]+1;
			else sum[i][j]=sum[i][j-1];	
	for(int ll=1;ll<=s;ll++)
		for(int rr=ll;rr<=s;rr++)
		{
			int maxn=0,len=0;
			for(int i=1;i<=r;i++)
			{
				if(sum[i][rr]-sum[i][ll-1]==0) len++,maxn=max(maxn,len);
				else len=0;
			}
			if(maxn==0) continue;
			ans=max(ans,maxn*2+(rr-ll+1)*2-1);
		}
	printf("%d",ans);
}
```

---

## 作者：liswt (赞：4)

**本蒟蒻第一篇题解**  
写得不好见谅  
其他题解都是$O(n^3)$的,  
我来发一个$O(n^2)$的.  
50ms  
因为我在比赛时做到数据是(1<=R,S<=2000).  
(~~然而比赛时没有做出来~~）  

$\Large \text{本题的}\Large O(n^2)\Large \text{算法要使用栈，不会的请先学会栈}$  


大家可能做过下面这题  
![](http://poj.org/images/2559_1.jpg)  
给一个柱形图,求柱形图中面积最大的矩形的面积  

原题[POJ2559](http://poj.org/problem?id=2559)  
此题对应数据的算法是$O(n)$的，要用到单调栈.  
对于每一个高度，(用单调栈)求出它用这个高度可以覆盖到的左右两个位置$st[\;i\;],ed[\;i\;]$  
那么$ans=max(ans,h[\;i\;]\times(ed[\;i\;]-st[\;i\;]+1)$  
至于如何$O(n)$求出$st[\;i\;],ed[\;i\;]$?在下面会有详解

本题类似上面的题目，不过变成了二维的，面积也变成了周长.  
不过做法类似，同样要使用单调栈.  
先预处理：
```cpp
scanf("%d%d",&n,&m);
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
{
	ch=getchar();
	while(ch!='.'&&ch!='X')ch=getchar();
	if(ch=='.')a[i][j]+=a[i-1][j]+1;
}
```
$a[\;i\;][\;j\;]$代表第i行第j列自己及上面有多少个连续空位  
也就是转换成上面的题目(柱形图).  

如何求$st[\;j\;],ed[\;j\;]\;:$  
维护一个单调递增的栈,  
如果当前值小于栈顶就弹出栈顶以维护单调性.  
当一个元素入栈，根据情况维护$st[\;j\;]$  
当一个元素出栈，根据情况维护$ed[\;j\;]$   

以下为详解 :  
入栈时 :  
如果是空栈，就说明当前值是最小值，即可以无限向左延伸，直到延伸到位置$1$,  
如果当前元素的值与栈顶相同，直接使用栈顶元素的$st$值就行了,  
如果当前元素与栈顶不同，就说明当前元素向左不能延伸到栈顶元素的位置，此时$st$值应该为栈顶元素位置$+1$.  
出栈时 :  
若被迫出栈，则栈顶元素大于当前值，栈顶不能延伸到当前位置，故栈顶的$ed$值为当前位置$-1$,  
若到最后都为出栈，即可以延伸到最右边，故$ed$值为$m$.  

最后是$ans$的处理方法(与上面的面积不同)  
$ans=max(ans,a[\;i\;][\;j\;]\times2+(ed[\;j\;]-st[\;j\;]+1)\times2)$  
(我是先求周长,在最后的时候$ans-1$)

贴AC代码(有详细注释)
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
char ch;
int a[2005][2005];
int st[2005];
int ed[2005];
//st和ed数组是循环利用的
int s[2005];
int p,ans,t;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		ch=getchar();
		while(ch!='.'&&ch!='X')ch=getchar();
		if(ch=='.')a[i][j]+=a[i-1][j]+1;
	}//预处理转换成柱形图
	for(int i=1;i<=n;i++)
	{
		p=0;
		for(int j=1;j<=m;j++)
		{
			while(p&&a[i][j]<a[i][s[p]])
			{
				ed[s[p]]=j-1;//若被迫出栈，则栈顶元素大于当前值，栈顶不能延伸到当前位置，故栈顶的eded值为当前位置-1
				p--;
			}
			if(p==0)st[j]=1;//如果是空栈，就说明当前值是最小值，即可以无限向左延伸，直到延伸到位置1
			else 
			if(a[i][j]==a[i][s[p]])st[j]=st[s[p]];//如果当前元素的值与栈顶相同，直接使用栈顶元素的st值就行了
			else st[j]=s[p]+1;//如果当前元素与栈顶不同，就说明当前元素向左不能延伸到栈顶元素的位置，此时st值应该为栈顶元素位置+1
			p++;
			s[p]=j;
		}
		while(p)
		{
			ed[s[p]]=m;//若到最后都为出栈，即可以延伸到最右边，故ed值为m
			p--;
		}
		for(int j=1;j<=m;j++)
		if(a[i][j])
		ans=max(ans,(a[i][j]<<1)+((ed[j]-st[j]+1)<<1));//处理答案，a<<1等价于a*2
	}
	printf("%d",ans-1);//主人不算客人，客人数为周长减一
	return 0;
}
```
如有错误请指出，谢谢

---

## 作者：SDqwq (赞：3)

[博客食用更佳](https://www.luogu.com.cn/blog/Sham-Devour/solution-p4417)

前置芝士：无

# $\texttt{Step 0 题意}$

- 给出一个 $R\times S$ 的由 $\texttt{"."}$ 和 $\texttt{"X"}$ 构成的矩阵。

- $\texttt{"."}$ 代表空地，$\texttt{"X"}$ 代表墙。

- 求出这个矩阵中最大的由 $\texttt{"."}$ 构成的矩形的周长 $-1$。

# $\texttt{Step 1 非正解解法 1}$

- 枚举矩形的左上角坐标和右下角坐标。

- 扫描枚举出的这个矩形是否可行。

时间复杂度：$\mathcal{O}(R^3S^3)$

# $\texttt{Step 2 非正解解法 2}$

- 将 $\texttt{"."}$ 看成 $0$，将 $\texttt{"X"}$ 看成 $1$。

- 维护这个矩阵的二维前缀和。

- 仍然枚举矩形的左上角坐标和右下角坐标，如果该矩形整体的和为 $0$，视为合法矩形。

时间复杂度：$\mathcal{O}(R^2S^2)$

# $\texttt{Step 3 正解解法}$

- 仍然将 $\texttt{"."}$ 看成 $0$，将 $\texttt{"X"}$ 看成 $1$。

- 维护矩阵中每一行的前缀和。

- 枚举矩形的左边界和右边界。

- 从第 $1$ 行扫到第 $R$ 行，途中如果遇到不合法的行则更新答案。

时间复杂度：$\mathcal{O}(RS^2)$

# $\texttt{Step 4 代码}$

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

int Max (int x, int y) {return x > y ? x : y;}

int q[405][405];
char s[405][405];

int get (int i, int j) {return s[i][j] == '.' ? 0 : 1;}

int main () {
	int R, S, ans = 0;
	scanf("%d %d", &R, &S);
	for (int i = 1; i <= R; i++) {
		scanf("%s", s[i] + 1);
		for (int j = 1; j <= S; j++)
			q[i][j] = q[i][j - 1] + get(i, j);
	}
	for (int i = 1; i <= S; i++)
		for (int j = i; j <= S; j++) {
			int ret = 0;
			for (int k = 1; k <= R; k++) {
				if (q[k][j] - q[k][i - 1] == 0) {
					ret++;
					ans = Max(ans, ret * 2 + (j - i + 1) * 2 - 1);
					continue;
				}
				ret = 0;
			}
		}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Ln_YJIn (赞：3)

这里提供一个$O(n^3)$的做法   
我觉得代码里讲的比较详细了  
需要注意，我们要输出的是**客人**的数量，因此把周长-1（主人不坐？我觉得不星） 
### code: 
```cpp
/*
	Name: luoguP4417
	Author: Ln_YJin
	Date: 14-10-2019 17:44
*/
#include<bits/stdc++.h>
#define ll long long
#define fo(a,b,c) for(register int a=b;a<=c;a++)
#define fr(a,b,c) for(register int a=b;a>=c;a--)

using namespace std;
const int N=405;
int n,m;
int ans=0;
int mp[N][N],sum[N][N];
/*
mp存图 
sum[i][j]表示第i列中从j开始向上能延伸的最大长度 
*/ 
char ch;
int main()
{
	scanf("%d%d",&n,&m);
	fo(i,1,n)
	{
		fo(j,1,m)
		{
			cin>>ch;
			if(ch=='.')mp[i][j]=0;
			else mp[i][j]=1;
		}
	}
	fo(i,1,n+1)mp[i][0]=mp[i][m+1]=1;//打上一圈边界qwq
	fo(i,1,m+1)mp[0][i]=mp[n+1][i]=1;
	fo(i,1,n)
	{
		fo(j,1,m)
		{
			if(!mp[i][j])
			{
				if(mp[i-1][j])sum[i][j]=1;//如果上一个是X,则为1 
				else sum[i][j]=sum[i-1][j]+1;//否则在上一个的基础上+1 
			}
		}
	}
	fo(i,1,n)
	{
		fo(j,1,m)
		{
			int x=j,minn=INT_MAX;//minn记录最短的宽以确保构成长方形 
			while(!mp[i][x])
			{
				minn=min(sum[i][x],minn);
				ans=max(ans,(x-j+1+minn)<<1);//求最大周长 
				x++;
			}
		}
	}
	printf("%d",ans-1); 
	return 0;
}
 
```


---

## 作者：George1123 (赞：2)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

此题无需任何算法，$O(n^3)$就$\colorbox{#00d000}{\color{white}\text{AC}}$了

$O(n^3)$方法：

枚举每个区间$(l,r)$求从$l$行摆到第$r$行的餐桌的最大宽度

并用这个餐桌周长更新答案$ans$即可

注意，由于主人不算，所以答案是最大周长$-1$

以下是代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans;
string in;
int maxf[410][410];
bool g[410][410],x[410];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		cin>>in;
		for(int j=1;j<=m;j++)
			g[i][j]=(in[j-1]=='X');
	} for(int i=1;i<=n;i++){
		memset(x,0,sizeof(x));
		for(int j=i;j<=n;j++){
			int tmp=0,maxn=0;
			for(int k=1;k<=m;k++){
				if(g[j][k])
					x[k]=1;
				if(!x[k]){
					tmp++;
				} else{
					maxn=max(maxn,tmp);
					tmp=0;
				}
			} if(tmp) maxn=max(maxn,tmp);
			if(maxn) ans=max(ans,(maxn+j-i+1)*2);
		}
	} if(ans) ans--;
	printf("%d\n",ans);
	return 0;
}
```
for循环中固定$l$遍历$r$便只用$O(n^3)$

谢谢大家！

---

## 作者：OnlyU (赞：2)

这又是一道非常水的蓝题。因为这道题的数据非常水，所以我们用暴力加前缀和优化就可以AC掉这道题。
具体见以下AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char maze[401][401];
int p[401][401];
int n,m,en;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>maze[i][j];
        }
    }
    int cnt=m+1;
    for(int i=1;i<=n;i++){//前缀和优化 
        cnt=m+1;
        for(int j=m;j>=1;j--){
            if(maze[i][j]=='X'){
                cnt=j;
            }
            p[i][j]=cnt;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(maze[i][j]=='.'){//枚举 
                int maxx=501,ans=0;
                for(int k=i;k<=n;k++){
                    if(maze[k][j]=='X')break;
                    maxx=min(maxx,p[k][j]);
                    int c=(k-i+1)*2+(maxx-j)*2;
                    ans=max(c,ans);
                }
                en=max(ans,en);//取最大值 
            }
        }
    }
    cout<<en-1;//最后减1，他自己不算 
    return 0;
}
```


---

## 作者：lzqy_ (赞：1)

提供两种都不一样的做法，$\text{O(n}^\text{3}\text{logn)}$ 和 $\text{O(n}^\text{3}\text )$。

###  $\text{O(n}^\text{3}\text{logn)}$ 做法

对于左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的矩形，枚举四个量肯定会超时，所以选择先枚举 $x_1,y_1,y_2$，即相当于枚举矩形上面的那条边。

当枚举完这三个量后，发现 $x_2$ 是具有单调性的。即如果 $A>B$，且 $B$ 可以作为 $x_2$ 时，$A$ 也一定可以作为 $x_2$。

所以就可以二分了。

判断一个矩阵是否合法用前缀和 $O(1)$ 判断就好了。

这时代码就不难写了：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=410;
inline bool cread(){
	char c=getchar();
	while(c!='.'&&c!='X') c=getchar();
	return c=='.'?1:0;
}
int n,m,ans; 
int a[maxn][maxn];
int pre[maxn][maxn];
int Sum(int x,int y,int xx,int yy){
//统计右下角(xx,yy)，左上角(x,y)区间的和
	return pre[xx][yy]-pre[xx][y-1]-pre[x-1][yy]+pre[x-1][y-1]; 
}
int Solve(int x,int yl,int yr){
//已知x1(x),y1(yl),y2(yr)，二分x2
	int l=x,r=n,mid;
	while(r>l){
		mid=l+r+1>>1;
		if(Sum(x,yl,mid,yr)!=(mid-x+1)*(yr-yl+1)) r=mid-1; 
		else l=mid;
	}
	return (l-x+1+yr-yl+1)*2;//直接返回周长
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			a[i][j]=cread();
			//X->0 .->1
			pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];
		}
	for(int i=1;i<=n;i++)//x1
		for(int j=1;j<=m;j++)//y1
			for(int u=j;a[i][u];u++)//y2
				ans=max(ans,Solve(i,j,u));
	printf("%d\n",ans-1);
	return 0;
} 

```

### $\text{O(n}^\text{3}\text )$ 做法

在上一个做法的基础上考虑优化。

假设已经求出了 $x_1,y_1,y_2$ 所对应的 $x_2$，接着将 $y_2$ 增大后的 $x_2$ 的变化。

可以发现，$y_2$ 增大，$x_2$ 一定单调不升的。也就是说，在 $y_2$ 的值从 $y_1$ 加到 $n$ 的过程中，$x_2$ 的值最多减 $n$ 且不会增加。所以就可以放心地在 $y_2$ 内再嵌套循环，求每次 $y_2+1$ 后的 $x_2$。因为单调不升，所以内部循环总共循环 $n$ 次以内，时间复杂度严格 $O(n^3)$。

代码也很简单：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=410;
inline bool cread(){
	char c=getchar();
	while(c!='.'&&c!='X') c=getchar();
	return c=='.'?1:0;
}
int n,m,ans; 
int a[maxn][maxn];
int pre[maxn][maxn];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=cread();
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n;i++)
			pre[j][i]=pre[j][i-1]+a[i][j];
   //为了下面判断方便，这里的前缀和数组与上一个代码不同
   //pre_j,i:第j列前i个数的和
	for(int i=1;i<=n;i++)
		for(int j=1,ii=i;j<=m;j++,ii=i){
			if(!a[i][j]) continue;
			while(a[ii][j])//求出当y1=y2时的x2 
				ii++;
			ii--;
			ans=max(ans,(ii-i+1+1)*2);
			for(int k=j+1;a[i][k];k++){
				while(pre[k][ii]-pre[k][i-1]!=ii-i+1) ii--;
				//求出新的x2
				ans=max(ans,(ii-i+1+k-j+1)*2);
			}
		} 
	printf("%d\n",ans-1);
	return 0;
} 
```

---

## 作者：Schwarzkopf_Henkal (赞：1)

评分感觉有点怪，要是数据范围给大点（例如1000）蓝题是刚好的。

提供一个思路，首先枚举桌子左下角的点，然后枚举桌子的长度，预先处理出当前点上面的最接近的墙或者上边界的距离，然后桌子的宽度是左下角的点往右延伸到的点的值取最小。时间复杂度是$O(n^3)$。

具体实现和其他解释在代码里，如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
int r,s,wsi[405][405],ans;//wsi数组保存这个点上方最接近的墙或者上边界与该点的距离
char inp;
bool cal[405][405];//保存该点是否是空地
int area(int x,int y){
    int len=2147483647,res=0;
    for(int j=y;j<=s&&cal[x][j];j++){//一直延伸到遇到墙或者右边界
        len=min(len,wsi[x][j]);//宽度对这些点的wsi值取min。
        res=max(res,len*2+(j-y+1)*2);
    }
    return res;
}
int main(){
    cin>>r>>s;
    for(int i=1;i<=r;i++)
        for(int j=1;j<=s;j++){
            cin>>inp;
            if(inp=='.')
                cal[i][j]=1;
        }
    for(int j=1;j<=s;j++){
        int up=0;
        for(int i=1;i<=r;i++){
            if(cal[i][j])//该点是空地?距离值++:距离值=0;
                up++;
            else up=0;
            wsi[i][j]=up;
        }
    }
    for(int i=1;i<=r;i++)
        for(int j=1;j<=s;j++)
            if(cal[i][j])
                ans=max(ans,area(i,j)-1);//ans对以每个点为左下角能够得到的最大周长值取max
    cout<<ans;
}
```


---

## 作者：Celebrate (赞：1)

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84647371)

经过观察得出，这题需要打O（n^2)-O(n^3)的题解，先考虑O(n^3)的解

首先枚举行和列

因为需要找出1-i行可以形成的矩形，所以我们另k从i搜索到1

要成为矩形，每一行的连续空余位置都必须一样，所以sum[ i ] [ j ]表示第i行的第j列又多少个连续的空余位置

如果要每一行的连续空余位置一样并且矩阵周长最大化，那么矩阵的长度就是由目前找过最小的sum来决定

当搜索到X时，就退出，每次找到矩阵都记录一次最大值，故时间保证在O(n^3)以内

我讲的不是很清晰，希望我清晰的代码能够帮助您

代码：

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
using namespace std;
const int N=4e2+10;
int n,m;
int sum[N][N];
int maxx=0;
string s;
int read(){//弱智读入 
	int t;cin>>t;
	return t;
}
int print(int x){//弱智输出 
	cout<<x<<endl; 
}
int solve(int x,int y){//长和宽分别为x和y的矩阵的周长 
	return (x+y)<<1;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=0;j<m;j++)
			if(s[j]=='.')sum[i][j+1]=sum[i][j]+1;//记录前缀和 
	}
	int minn;
	for(int i=1;i<=n;i++)//枚举 
		for(int j=1;j<=m;j++){
			minn=999999999;//记录行的最小前缀 
			for(int k=i;k>=1;k--){
				minn=min(minn,sum[k][j]);
				if(!minn)break;//当然不能为0 
				maxx=max(maxx,solve(i-k+1,minn));//记录最大值 
			}
		}
	print(maxx-1);return 0;
}

```


---

## 作者：JoyJoyGang (赞：0)

类似悬线条法

先 $O(n^2)$ 的时间复杂度求一下每个点最多可以向左和向右延伸多少。

然后枚举每个点向上最多可以延伸多少，根据上面的缩小左右范围，然后记录最大值即可

时间复杂度 $O(n^2)$

代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int MA=405;
int r,s,zuo[MA][MA],you[MA][MA],a[MA][MA],shang[MA][MA],maxn=0;
char si[MA][MA];
int main()
{
	scanf("%d%d",&r,&s);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			cin>>(si[i][j]);
			if(si[i][j]=='.'){
				a[i][j]=1;
			}
			else{
				a[i][j]=0;
			}
		}
	}
	int maxn=0;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			if(a[i][j]==1){
				zuo[i][j]+=zuo[i][j-1]+1;
//				printf("(");
			}
			else{
				zuo[i][j]=0;
			}
		}
	}
	for(int i=1;i<=r;i++){
		for(int j=s;j>=1;j--){
			if(a[i][j]==1){
				you[i][j]+=you[i][j+1]+1;
			}
			else{
				you[i][j]=0;
			}
		}
	}
//	for(int i=1;i<=r;i++){
//		for(int j=1;j<=s;j++){
//			printf("%d ",you[i][j]);
//		}
//		printf("\n");
//	}
	for(int i=1;i<=s;i++){
		zuo[0][i]=MA;you[0][i]=MA;
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			if(a[i][j]==1){
				if(a[i-1][j]==1||i==1){
					shang[i][j]+=shang[i-1][j]+1;
					zuo[i][j]=min(zuo[i][j],zuo[i-1][j]);
					you[i][j]=min(you[i][j],you[i-1][j]);
				}
				else{
					shang[i][j]=1;
				}
			}
			maxn=max(maxn,shang[i][j]+(you[i][j]+zuo[i][j]-1));
//			printf("%d %d %d %d %d %d\n",i,j,shang[i][j],you[i][j],zuo[i][j],maxn); 
		}
	}
	printf("%d",(maxn*2)-1);
	return 0;
}
```


---

## 作者：Yexuaj (赞：0)

听说 O($n^4$)的暴力算法也能过

那太暴力了，这里给出O($n^3$)算法

想象这幅图是竖着的，对于每个点，预处理出它向上能够到的最大的点。

以每一个点为左下角向右扫描，遇到够到的点的x比它大的时候就更新，注意每一次都要判断并更新答案

还有就是，
### 米尔科本人也要位置坐，所以答案为取到的周长-1

本来以为如果全是X的话要特判一下，但是好像不用

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char gar[405][405];
int h[405][405];
int ans;

void prepare() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
		scanf("%s",gar[i]+1);
	for(int j=1; j<=m; ++j) {
		int tmp=1;
		for(int i=1; i<=n; ++i) {
			if(gar[i][j]=='X')
				tmp=i+1;
			else h[i][j]=tmp;
		}
	}
}

void solve() {
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			if(gar[i][j]=='X')continue;
			int tmp=h[i][j];
			for(int p=j; p<=m; ++p) {
				if(gar[i][p]=='X')
					break;
				if(h[i][p]>tmp)tmp=h[i][p];
				ans=max(ans,2*(p-j+1)+2*(i-tmp+1));
			}
		}
	}
}

int main() {
	prepare();
	solve();
	cout<<ans-1;
}

```


---

## 作者：wudiss8 (赞：0)

本蒟蒻第三篇题解


------------
夏令营模拟赛题，比赛时玄学方法只枚举从每一列最上面往下走的最深是多少，最大的左右宽度是多少，每向下一格更新一次，没想到这种水法骗到50分？~~（夏令营OJ数据过水）~~


------------
题目大意
给你一个格子图，有些格子不能放，要求在这张格子图中找出一个周长最长的矩形，因为主人不是客人，所以要输出周长-1

$O(n^3)$的方法，在上面的方法更改一下就好了

首先可以预处理出每一个格子向右延伸最大宽度是多少

然后从每一个格子开始向下枚举，

在这个可以放置的区间向下延伸（也就是长度++）同时用min看这些格子向右延伸最短的宽度是多少，ans可以直接先记录为半周长(长加宽)（周长等于长宽的和乘2，长宽的和最大，乘2也就最大了），每次去对比，取最大值

就拿样例来说:
黑色格子表示不可放置的('X'),蓝色格子表示可放置的，格子上的数字表示它向右延伸的最大宽度
![](https://cdn.luogu.com.cn/upload/pic/71357.png)


------------

先从左边的第一列第三行的格子开始枚举，最大宽度是二，

答案更新为长加宽即2+1=3
![](https://cdn.luogu.com.cn/upload/pic/71361.png)



------------

再向下延伸一格，最大宽度还是二,答案更新为2+2=4
![](https://cdn.luogu.com.cn/upload/pic/71363.png)

以此类推，当我们枚举到下图的情况时:
![](https://cdn.luogu.com.cn/upload/pic/71359.png)

答案是1+4=5,为最大值,右边两个格子的更新已无法超过这个值。
当然计算机还是继续枚举，因为它布吉岛awa

然后输出ans*2-1就是正确答案了，具体细节代码见

$code$:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
bool mapp[2501][2501];//该点能否放置
ll kkk[2501][2501];//每个点向右最多延伸的宽度
ll r,c,ans;
inline void dfs(ll h,ll l){//枚举每一个点向下所能走出最长的矩形是多大
	ll tot=0,k2=10000;//tot向下能走的长度，k2宽度最小值
	while(h<=r){
		if(!mapp[h][l]){//该点能够放置，就在原来基础上向下+1
			tot++;
			k2=min(k2,kkk[h][l]);//最短宽度
			ans=max(ans,tot+k2);//维护答案
		}else{//如果延伸到了不能走的点，退出循环
		break;
	    }
		h++;
	}
}
inline ll read(){//快读
	char c=getchar();
	ll s=1,f=0;
	while(c<'0' or c>'9'){
		if(c=='-')
		s=-1;
		c=getchar();
	}
	while(c>='0' and c<='9'){
		f=f*10+c-'0';
		c=getchar();
	}
	return s*f;
}
int main(){
	char s;
	r=read();c=read();
    s=getchar();
	for(register int i=1;i<=r;i++){
	 for(register int j=1;j<=c;j++){
	 	s=getchar();
	 	if(s=='X')
	 	mapp[i][j]=1;
	 }//记录一个点是否能走
	 s=getchar();
    s=getchar();//手动读换行符，空格，一开始因为这个被卡了好久
	}
	 for(register int i=0;i<=r+1;i++)
	 mapp[i][0]=mapp[i][c+1]=1;
	 for(register int i=0;i<=c+1;i++)
	 mapp[0][i]=mapp[r+1][i]=1;
	 //这两个都是初始化，离开了这个图就不能延伸了，所以加一圈标记
	 for(register int i=1;i<=r;i++)
	  for(register int j=c;j>=1;j--)
	  if(!mapp[i][j])
	  kkk[i][j]=kkk[i][j+1]+1;
      //倒序枚举，看每个点向右延伸多少格
	  
	 for(register int i=1;i<=r;i++) 
	  for(register int j=1;j<=c;j++)
	   if(!mapp[i][j])//枚举每个点
	   dfs(i,j);
	 printf("%lld\n",ans*2-1); //输出答案,记得*2再-1
	return 0;
}
```
本篇题解到这里就结束了qwq,如果有不足之处，请批评指正，如果还有不懂的可以私信找我

---


# [COCI 2017/2018 #3] Retro

## 题目描述

小 Mirko 在圣诞节得到了一个视频游戏机。它不是 Playstation 4 或 Xbox one，而是 Atari 2600，并且附带了一个免费游戏。游戏的主角站在屏幕的底部，屏幕上其他地方有各种物体向底部掉落。

更确切地说，屏幕可以表示为一个由 R 行 S 列像素组成的网格。主角占据最底行的一个像素，并用 'M' 标记。其余像素用以下字符之一标记：'.'（空格）、'*'（炸弹）、'('（左括号）或 ')'（右括号）。

主角可以在一次移动中向左或向右移动一个像素，但不需要移动，而其他物体同时向下移动一个像素（可能移出屏幕）。当主角与一个括号处于同一位置时，我们说他拾取了该括号并将其添加到他已获得的括号数组的末尾。主角的目标是获得尽可能长的**有效**括号表达式。

有效的括号表达式通过以下方式递归定义：

- "()" 是一个有效的表达式。
- 如果 **a** 是一个有效的表达式，那么 "(**a**)" 也是一个有效的表达式。
- 如果 **a** 和 **b** 是有效的表达式，那么 "**ab**" 也是一个有效的表达式。

当主角与炸弹处于同一位置时，或者当所有物体都掉出屏幕时，游戏结束。

## 说明/提示

在价值 25% 总分的测试用例中，将满足 1 ≤ R ≤ 15。

在价值 50% 总分的测试用例中，将满足 1 ≤ R ≤ 100。

如果你输出了正确的长度，但表达式错误，你将获得该测试用例 40% 的分数。无论如何，为了得分，你的输出必须包含两行非空内容。

**第一个测试用例的说明**：主角的移动是：左，左，右，右。

**第二个测试用例的说明**：主角的移动是：保持不动，保持不动，保持不动，右，左。

**第三个测试用例的说明**：主角的移动是：保持不动，保持不动，右。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
5 4
..).
.)(.
(.)*
*(.*
..M.
```

### 输出

```
4
(())
```

## 样例 #2

### 输入

```
6 3
)(.
*..
(**
)()
().
M..
```

### 输出

```
4
()()
```

## 样例 #3

### 输入

```
6 3
((.
*..
(**
)()
().
M..
```

### 输出

```
2
()```

# 题解

## 作者：Zjl37 (赞：5)

### 简单的动态规划可以完成第一问

从上往下进行动态规划。设 $f(i, j, k)$ 为到达第 $i$ 行第 $j$ 列，$ \text{\small\sf 右括号数}-\text{\small\sf 左括号数} = k$ 时序列的最大长度。

> 合法括号序列的性质：
>
> 任何后缀中 $ \text{\small\sf 右括号数}-\text{\small\sf 左括号数} \ge 0$，因此我们要求 DP 中 $k\ge 0$。

> 优化空间的提示：
>
> 由于最终左右括号数量相等，所以 k 可以只用开 R 的一半。

DP 的起点可以是第一行非左括号的位置或炸弹的位置。对于第一行的右括号，k = 1，f 赋值为 1；对其他起点，k = 0，f 赋值为 0；

> 对其他位置，初始化时可以赋值一个负数。

从 $f(i, j, k)$ 可以转移到下一行的三个相邻位置。根据下一个位置的字符，k 发生相应的变化。比如接收到一个左括号，则 k 减一。如果接收到的是括号，f 的值就加 1。

最终的答案即为 $f(R, \textsf{‘M’\small所在的横坐标}, 0)$。

### 记录节点状态以求出字典序最小的括号序列

我们发现，如果**用滚动数组优化**，完全有足够的空间**用二进制压缩地**记录下每一个 DP 状态的括号序列!

于是我们在 DP 时不仅比较长度，而且在长度相等时留意一下序列大小即可。

该算法的时间复杂度是 $\mathcal O(R^2 S)$，用到的空间不到 5MB，真是惊人的小！

### 参考实现

本题的代码非常的琐碎，请仔细阅读。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define validx(a) ((a) >= 1 && (a) <= s)
int r, s, sx;
char c[301][301];

// 一个 node 代表 DP 的一个状态
struct node {
	int len;
	unsigned seq[10];
	// seq 记录括号序列，每个二进制位上 0 代表 '('，1代表 ')'
	// 用 10 个 32 位整数可以存下至多 320 个括号。
	// 不用 std::bitset，因为它没有提供比较运算符。

	void init(int x, unsigned y) {
		len = x;
		memset(seq, 0, sizeof seq);
		seq[0] = y;
	}
	void set(unsigned x) {
		seq[x/32] |= 1u<<x%32;
	}
} nd[2][301][152];

// 比较括号序列的大小。
bool cmpSeq(const node &a, const node &b) {
	for(int i = (a.len-1)/32+1; i >= 0; --i) {
		if(a.seq[i] != b.seq[i]) return a.seq[i] < b.seq[i];
	}
	return 0;
};

ostream &operator<<(ostream &out, const node &x) {
	out<<x.len<<"\n";
	for(int i = x.len-1; i >= 0; --i)
		out<<(x.seq[i/32] & 1u<<i%32 ? ')' : '(');
	return out;
}

int main() {
	// ifstream cin("r:/test/retro.in");
	ios::sync_with_stdio(0);
	cin>>r>>s;
	memset(nd, -1, sizeof nd);
	for(int i = 1; i <= r; i++)
		for(int j = 1; j <= s; j++) {
			cin>>c[i][j];
		}
	// sx = 'M' 所在的横坐标
	sx = find(c[r]+1, c[r]+s+1, 'M') - c[r];
	for(int j = 1; j <= s; j++)
		if(c[1][j] == ')') {
			nd[1][j][1].init(1, 1);
		} else if(c[1][j] != '(') {
			nd[1][j][0].init(0, 0);
		}
	// 将 DP 转移中大量重复的代码写成函数，节省码量。
	// 注意：为了方便，这个函数中没有向 seq 添加新的括号。
	auto dpUpt = [](const node &cur, node &nxt, int df) -> bool {
		if(cur.len+df > nxt.len || (cur.len+df == nxt.len && cmpSeq(cur, nxt))) {
			nxt = cur;
			nxt.len = cur.len+df;
			return 1;
		}
		return 0;
	};
	for(int i = 1; i < r; ++i) {
		// 及时清空滚动数组。
		memset(nd[i+1 & 1], -1, sizeof nd[0]);
		for(int j = 1; j <= s; j++) {
			// 注意：非首行的炸弹作为起点，只能在滚动到此时进行初始化。
			if(c[i+1][j] == '*') nd[i+1 & 1][j][0].init(0, 0);
			// 只处理序列存在的节点。
			for(int k = 0; k <= r/2 && k <= i; ++k) if(nd[i & 1][j][k].len >= 0) {
				// 注意：为了方便，在新一轮 DP 开始前向 seq 中添加括号。
				// 因为二进制用 0 代表左括号，所以只用管右括号。
				if(c[i][j] == ')') {
					nd[i & 1][j][k].set(nd[i & 1][j][k].len-1);
				}
				for(int dx: {-1, 0, 1}) if(validx(j+dx)) {
					if(c[i+1][j+dx] == ')') {
						dpUpt(nd[i & 1][j][k], nd[i+1 & 1][j+dx][k+1], 1);
					} else if(c[i+1][j+dx] == '(') {
						if(k > 0)
							dpUpt(nd[i & 1][j][k], nd[i+1 & 1][j+dx][k-1], 1);
					} else if(c[i+1][j+dx] != '*') {
						dpUpt(nd[i & 1][j][k], nd[i+1 & 1][j+dx][k], 0);
					}
				}
			}
		}
	}
	cout<<nd[r & 1][sx][0]<<endl;
	return 0;
}
```

---

## 作者：xukuan (赞：3)

## dp


### 52分做法：

1.输入倒着存（利于常人理解）

#### 2.dp的东西：

重复子问题：对于每一个(i,j)，它只能通过(i-1,j-1),(i-1,j),(i-1,j+1)转移过来

最优子结构：用f[i][j][k] (k>=0)表示当前在(i,j)位置中，左括号数-右括号数为k的最大序列

无后效性：对于(i,j)之后这个位置，左括号数-右括号数为k的最大序列与之前的取法无关

3.滚动数组（不然会MLE）

4.输出的确保出发点一定能到

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll r,s;
char a[310][310];
string ans,f[2][310][310];

inline string max(string a,string b){//字符串的大小比较
    if(a[0]=='M'&&b[0]!='M') return a;
    if(b[0]=='M'&&a[0]!='M') return b;
    if(b[0]!='M'&&a[0]!='M') return "";
    //肯定要从出发点出来
    //出发点能到的格子上有‘M’
    if(a.size()>b.size()) return a;
    if(a.size()<b.size()) return b;
    //取长度能到的
    return a<b?a:b;
    //取字典序小的
}

int main(){
//	freopen("bracket.in","r",stdin);
//	freopen("bracket.out","w",stdout);
    scanf("%lld%lld",&r,&s);
    for(ll i=r; i>=1; i--) scanf("%s",a[i]+1);
    for(ll i=1; i<=s; i++){
        if(a[1][i]=='M'){
            f[1][i][0]="M";//找到出发点
            break;
        }
    }
    for(ll i=2; i<=r; i++){
        for(ll j=1; j<=s; j++){
            if(a[i][j]=='*'){//如果是炸弹
                ans=max(max(ans,f[(i-1)%2][j-1][0]),max(f[(i-1)%2][j][0],f[(i-1)%2][j+1][0]));//取最大值
            }
            else if(a[i][j]=='(')//左括号
            for(ll k=1; k<=r; k++){
                f[i%2][j][k]=max(f[(i-1)%2][j-1][k-1],max(f[(i-1)%2][j][k-1],f[(i-1)%2][j+1][k-1]))+"(";
            }
            else if(a[i][j]==')')//右括号
            for(ll k=0; k<=r; k++){
                f[i%2][j][k]=max(f[(i-1)%2][j-1][k+1],max(f[(i-1)%2][j][k+1],f[(i-1)%2][j+1][k+1]))+")";
            }
            else if(a[i][j]=='.')//普通的
            for(ll k=0; k<=r; k++){
                f[i%2][j][k]=max(f[(i-1)%2][j-1][k],max(f[(i-1)%2][j][k],f[(i-1)%2][j+1][k]));
            }
        }
    }
    for(ll i=1; i<=s; i++) ans=max(ans,f[r%2][i][0]);//取最大值
    printf("%d\n",ans.size()-1);
    ans.erase(0,1);
    cout<<ans<<endl;
//	fclose(stdin); fclose(stdout);
    return 0;
}
```

68分：

1.滚动数组的%2改成&1

2.O(2)优化



100分：

有参考https://blog.csdn.net/acterminate/article/details/79624251

首先dp做出最长后缀的长度，

定义dp[i][j][k]表示位置i,j后缀和是k的时候的最长串

再bfs还原字串

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll dir[3][2]={//三个方向
	{1,-1},
	{1,0},
	{1,1}
};

ll f[305][305][155],mark[305][305][155],n,m;
char ans[305],a[305][305];
struct node{
	ll x,y,sum,len;
}s,e;
priority_queue<node> q;

inline ll val(char c){//字符的值
	if(c=='.') return 2;
	if(c=='(') return 1;
	if(c==')') return 0;
}

inline bool operator <(node A,node B){
//重载node的<
	if(A.len==B.len) return val(a[A.x][A.y])<val(a[B.x][B.y]);
	return A.len<B.len;
}

inline void bfs(){//bfs还原字串
	while(!q.empty()){
		node k=q.top(); q.pop();
		if(a[k.x][k.y]==')'&&ans[k.len]=='(') continue;
		if(a[k.x][k.y]=='('||a[k.x][k.y]==')') ans[k.len]=a[k.x][k.y];
		for(ll i=0; i<3; i++){
			ll x=k.x-dir[i][0],y=k.y-dir[i][1],sum=k.sum,len=k.len;
            //接下来的两个点
			if(a[k.x][k.y]=='('){
				sum++;
				len--;
			}//左括号处理
			if(a[k.x][k.y]==')'){
				sum--;
				len--;
			}//右括号处理
			if(x>=1&&y>=1&&x<=n&&y<=m&&f[x][y][sum]==len&&a[x][y]!='*'&&mark[x][y][sum]==0){//在范围内，不是炸弹，没有走过
				mark[x][y][sum]=1;
				q.push(node{x,y,sum,len});	
			}
		}
	}
}

int main(){
	memset(f,-1,sizeof(f));
	scanf("%lld%lld",&n,&m);
	for(ll i=1; i<=n; i++){
		scanf("%s",a[i]+1);
		for(ll j=1; j<=m; j++){
			if(a[i][j]=='M'){//找到初始点
				s.x=i;
				s.y=j;
				break;
			}
		}
	}
	s.len=s.sum=0;
		
	for(ll i=1; i<=m; i++){
		if(a[1][i]==')') f[1][i][1]=1;
		if(a[1][i]=='.') f[1][i][0]=0;
	}
	
	for(ll i=1;i<=n;i++){
		for(ll j=1; j<=m; j++){
			if(a[i][j]=='*') f[i][j][0]=0;
		}
	}
	
	for(ll i=1; i<=n; i++){
		for(ll j=1; j<=m; j++){
			for(ll k=0; k<=n/2; k++){
            //左括号和右括号数一定相等，所以穷举到n/2就行了
				if(f[i][j][k]==-1) continue;
				for(ll l=0; l<3; l++){//三个方向
					ll x=i+dir[l][0],y=j+dir[l][1];//找到下一个点
					if(a[x][y]=='*'||x<=0||y<=0||x>n||y>m) continue;//超范围或碰到炸弹
					if(a[x][y]=='('||a[x][y]==')'){
						if(a[x][y]==')') f[x][y][k+1]=max(f[x][y][k+1],f[i][j][k]+1);
						if(a[x][y]=='('&&k) f[x][y][k-1]=max(f[x][y][k-1],f[i][j][k]+1);
					}//括号
					else f[x][y][k]=max(f[x][y][k],f[i][j][k]);//点
				}
			}
		}
	}
		
	printf("%lld\n",f[s.x][s.y][0]);//找到长度
	q.push(node{s.x,s.y,0,f[s.x][s.y][0]});
	mark[s.x][s.y][0]=1;
	bfs();//还原
	for(ll i=f[s.x][s.y][0]; i; i--) putchar(ans[i]);
	return 0;
}
```

---


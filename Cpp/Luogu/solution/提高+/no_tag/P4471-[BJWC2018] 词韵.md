# [BJWC2018] 词韵

## 题目描述

Adrian 很喜欢诗歌中的韵。他认为，两个单词押韵当且仅当它们的最长公共后缀的长度至少是其中较长单词的长度减一。也就是说，单词A 与单词B 押韵当且仅当LCS(A,B) ≥ max(|A|,|B|)- 1。( 其中LCS 是最长公共后缀longest common suffix 的缩写）

现在，  Adrian 得到了N 个单词。他想从中选出尽可能多的单词，要求它们能组成一个单词序列，使得单词序列中任何两个相邻单词是押韵的。


## 说明/提示

**【样例解释】**

一种最长单词序列是ask-psk-sk-k。

**【数据规模和约定】**

30%的测试数据：1≤N≤20，所有单词长度之和不超过3 000

100%的测试数据：1≤N≤500000，所有单词长度之和不超过3 000 000。

## 样例 #1

### 输入

```
5
ask
psk
k
krafna
sk```

### 输出

```
4```

# 题解

## 作者：三点水一个各 (赞：16)

本题出现公共后缀，考虑将所有单词放在一棵树里做。

### 什么是Trie

Trie 亦称字典树、前缀树，是一种以空间换时间的做法。

对于一个长度为 $L$ 的字符串，插入和查询的复杂度均为 $O(L)$。

如图所示，将 $\texttt{ab},\texttt{ad},\texttt{ace},\texttt{acf}$ 放入 Trie。

![](https://cdn.luogu.com.cn/upload/image_hosting/98hq3jwp.png)

详细的 Trie 插入和查询操作请完成模板题[P2580](https://www.luogu.com.cn/problem/P2580)。

***
### 建树


观察本题，需要找到公共后缀，所以将单词反向存入 Trie，如图所示，将$\texttt{ba},\texttt{da},\texttt{eca},\texttt{fca}$ 放入 Trie。

![](https://cdn.luogu.com.cn/upload/image_hosting/98hq3jwp.png)

题面写到，序列中相邻两个单词需满足 $LCS (A,B) ≥ \max(|A|,|B|)-1$，所以相邻两个单词要么是父子关系，要么是兄弟关系，如：

$\texttt{abcd}$ 和 $\texttt{bcd}$ 是父子关系（当然顺序可以调换，$\texttt{bcd}$ 和 $\texttt{abcd}$ 也是合法的）；

$\texttt{abcd}$ 和 $\texttt{bbcd}$ 是兄弟关系（同理可以调换顺序，$\texttt{bbcd}$ 和 $\texttt{abcd}$ 也是合法的）。

所以，我们可以确定在图中的访问顺序是以下三种：访问父结点，访问子结点，访问同父的兄弟结点，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/upr02k90.png)

随后我们发现，在建树的过程中，不是所有结点都能按照如上三种顺序访问，如对 $\texttt{a},\texttt{ba},\texttt{dcba}$ 建树时，结点 $d$ 不能到结点 $c$，因为并不存在 $\texttt{cba}$ 这个单词，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/sh272knp.png)

所以对于每个结点，我们用一个 $b$ 数组来存储他们出现的次数，当然，由于`所有单词互不相同`，这个数值只可能是 $0$ 或 $1$。

对 $\texttt{a},\texttt{ba},\texttt{dcba}$ 建树时，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/mqxk8r35.png)

至此，建树完毕。

***

### 查找

我们知道，在查找过程中，因为出现次数为 $0$ 的点不可以被经过，所以不会出现 脱 节 的现象。

并且由于`所有单词互不相同`，所以不走回头路，即同一结点不经过 $2$ 次。

所以最后所有序列构成的图是一棵树而不是森林。

如图是对于 $\texttt{ba},\texttt{da},\texttt{eca},\texttt{fca}$ 一种可能的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ma6xb85h.png)

因此在一种可能的情况中，一个结点可能作为根结点，也可能是非根结点。

下面我先将情况**理想**化：

1. 所有结点 $i$ 所代表的单词次数均为 $1$，即 $b_i=1$。
2. 该结点是**非根结点**。 
3. 不考虑该结点以上的结点（包括其父结点）

开一个数组，记 $i$ 结点作为非根结点时能取得最大单词数为 $f_i$。

首先，因为兄弟结点互相之间可以连接，并且访问顺序可以随意，在这里将所有的子节点 $j$ 都取来（取的是结点 $j$ 本身，而不是 $f_j$）。

然后，思考对于 $i$ 的子结点 $j$，在访问到 $j$ 之前，肯定是由 $j$ 以下的结点过来的，也就是由 $f_j$ 个结点过来的，要使 $f_i$ 最大，就得找到最大的 $f_j$。

（这里 $i,j,f_i,f_j$ 的关系有点复杂，总之就是 $j$ 是 $i$ 的子结点，$f_{i/j}$ 是 $i/j$ 作为非根结点时能取得最大单词数，请读者自行梳理）。

最后可以取到 $i$ 结点本身，不要漏掉。

设 $i$ 有 $k$ 个子结点，那么

$$f_i=\max(f_j-1)+k+1$$

至于为什么是 $f_j-1$ 而不是 $f_j$，是因为 $j$ 在 $f_j$ 和 $k$ 中均出现一次。

举个例子：

对于单词 $\texttt{ba},\texttt{da},\texttt{eca},\texttt{fca},\texttt{ica},\texttt{heca},\texttt{geca},\texttt{jfca}$，以 $\texttt{c}$ 为非根结点时，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/hrq6x90m.png)

解释一下，此图中，$c$ 子节点个数 $k=3$，子节点（$\texttt{e}$,$\texttt{f}$,$\texttt{i}$）中最大的 $f$ 为 $3$，故 $f_c=\max(f_j-1)+k+1=(3-1)+3+1=6$。

为什么 $f_c$ 只能取子结点 $j$ 中最大的一个 $f$ 而不是取多个？

因为如果取第二个，意味着从一个叶子结点（如 $\texttt{h}$,$\texttt{g}$ ）经过 $\texttt{c}$ 到另一个叶子结点（如$\texttt{j}$），此时无法再从叶子结点往上，因为`所有单词互不相同`，那么此时，$\texttt{c}$ 就成了根节点，与我的假设不符。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/e93j1rjt.png)

***

接下来考虑当该结点为根结点：

上面分析非根结点说过，如果取第二个，意味着该结点就是根结点。

所以以该点为根节点时，最大单词个数是在以该单词为非根结点的基础上，再加上第二大的 $f_j$，即：

$$f'_{i}=max1(f_j-1)+max2(f_j-1)+k+1$$

***

接下来考虑该结点对应单词个数为 $0$，即 $b_i=0$:

对于一个对应单词个数为 $0$ 的结点，不能将它忽略。

因为如果他存在对应单词个数不为 $0$ 的子结点，即 $b_j=1$。

这些 $b_j=1$ 的子结点之间扔可以相互访问，

这是只需要把公式中最后加上去的 $1$ 删掉就可以了。

### 复杂度

设单词个数为 $N$，长度之和为 $S$。

建树复杂度 $O(s)$。

查找复杂度 $O(26N)$。

$\mathtt{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000003][27],b[2000003],f[2000003];//3e6似乎要炸
int n,m,l1,l2,num=0,ans=0;
string s;
int main()
{
	scanf("%d",&n);
	memset(a,0,sizeof(a));
	for(int k=1;k<=n;++k) //Trie 建树
	{
		int x=0;
		cin>>s;
		for(int i=s.length()-1;i>=0;--i)
		{
		  if(!a[x][s[i]-'a']) 
		    a[x][s[i]-'a']=++num;
		  x=a[x][s[i]-'a']; 
	    }
	    b[x]++; //单词个数
	}
	for(int i=num;i>=0;--i)
	{
		f[i]=b[i]; //该节点单词个数，是1或是0
		l1=l2=0; //最大和次大
		for(int j=0;j<=25;++j) 
		  if(b[a[i][j]]) //存在该子结点，若该结点对应单词数为0，没有意义。
		  {
		  	  f[i]++;  //选取子结点本身
		  	  if(f[a[i][j]]-1>l1) l2=l1,l1=f[a[i][j]]-1; //更新最长
		  	  else if(f[a[i][j]]-1>l2) l2=f[a[i][j]]-1;//更新次长
		  }
		f[i]+=l1; //非根结点最多单词
		ans=max(ans,f[i]+l2); //根节点最多单词。
	}
	printf("%d",ans);
	return 0;
 } 
```

---

## 作者：you_xiao (赞：12)

我们教练说这套题是三蓝一紫，可简单。。。（其实两紫两灰  
~~我们还没打过noip好吧？~~

# 我们说题

这一题乍一看：woc？

又是lcs，又是序列，又是长度减一的你会想到字符串，dp，~~排列组合~~  

公共后缀长度>=长词-1？

你觉得KMP肯定不行，你开始想dp求lcs，但是这东西n*len^2能过？  
于是你就需要寻找更适合的算法

你发现，把单词全倒过来，题设就变成了公共前缀序列。。。（没事想这个？~~是个大闲者~~  
然后你再想，想起一个叫做tire字典树的东西，可以得到不同序列的公共前缀，这个好像可以。  
你又想，我应该用dp做，  
你终于意识到tire是棵树！！！  
然后呢？  

# 树上DP！！！
~~是不是很妙？~~

写这道题大概会tire吧。。

一个tire中，我们每个单词的结尾会被存在一个节点中，词尾的权值为1  
而同一个父亲的节点，他们的公共前缀就是max(|A|,|B|)-1;  而子节点和他的父亲公共前缀一定是 |son|-1;  
那么A，B是押韵词，满足A，B节点是词尾，A和B是儿子或兄弟关系，
但是怎么取呢？


------------

设以下直到分割线出现 的所有节点都是词尾。

我们可以知道，如果取某个点，一定要取他的所有兄弟和儿子

再观察，假设已经颠倒过方向 , 我们最后取得序列，一定是这样：
$$ aaaa,aaab,aaa,aab,aa,ab,abb,abbb $$

或者
$$a,ab,abc,abcd$$

一定是{树上某条链以及链上所有节点的父亲和儿子}的中序遍历



------------


但是，仔细一看，只有aa 和ab ，他们肯定“押韵”，但是本应是他们的父亲的a却不在，  
于是你发现，一条链的顶端不一定是词尾节点.(哈哈，前面一片题解错了的说)  
即你需要某个节点的 最大子链权值 和 次大子链权值 以及这个节点的权值来更新答案。

f[s]记录节点的所有子节点权  
g[x]记录x最大的{链以及链上所有节点的父亲和儿子}的权值和  
于是对于x 
$$dp[x]=max1(g[y])+max2(g[y])+f[x]+val[x]$$

于是你就A了题

```cpp
#include<bits/stdc++.h>
using namespace std;
struct dd{
	int nex,to,c;
}q[1000005];
int l,n,ma=0,mi=0,cnt=0,tot=0,st,val[1000005],f[1000005],head[1000005],dp[1000005],g[1000005];
char c[1000005];
int ans=0;
void tdp(int x,int fa){
	int ma1=0,ma2=0;
	for(register int i=head[x];i;i=q[i].nex){
		int y=q[i].to;
		if(y==fa)continue;
		tdp(y,x);
		if(!val[y])continue;
		f[x]+=val[y];
		if(g[y]>=ma1){
			ma2=ma1;
			ma1=g[y];
		}
		else if(g[y]>ma2)ma2=g[y];	
		
	}
	if(val[x])g[x]=f[x]+ma1;
	ans=max(ans,ma1+ma2+f[x]+val[x]);
}
void add(int a,int b,int c){
	q[++cnt]=(dd){head[a],b,c};head[a]=cnt;
}
int main(){
	scanf("%d",&n); tot=1;
	for(int i=1;i<=n;i++){
		scanf("%s",c);
		int len=strlen(c)-1;
		int u=1;
		for(int j=len;j>=0;j--){
			int v=c[j]-'a'+1;bool flag=0;
			for(register int k=head[u];k;k=q[k].nex){
				if(q[k].c==v){
					flag=1;
					u=q[k].to;
					goto nex;    			//社会goto。。。
				}
			}
			tot++;
			add(u,tot,v);
			u=tot;
			nex:;
		}
		val[u]=1;
	}
	tdp(1,-1);
	printf("%d",ans);
	return 0; 
}
```

---

## 作者：樱洛CHANGE (赞：8)

## 思路
发现题目的限制是 LCS，我们可以考虑把题目给出的字符串翻转，再求其 LCP（longest common prefix，最长公共前缀），显然可以使用 trie 树轻松维护。

观察题目让我们求的东西，进行了如上转化后，我们发现，两个状态（字符串 $\text{A\ B}$）之间合法的转移一定是满足如下图的关系：
![](https://cdn.luogu.com.cn/upload/image_hosting/lkoc2dvx.png)

那么，为了我们更好的深入理解，我们来看一组样例：
```cpp
7
ba
cba
da
eda
fha
gta
ra
```
我们把这组样例对应的 trie 树建出，注意要反着建：

![](https://cdn.luogu.com.cn/upload/image_hosting/aj5ez24e.png)

其中单词结尾用`$`标出。
这组样例的答案是5，如果你的答案不是的话，那说明你对本题的理解还是不够透彻，建议重新读题，手跑样例。

我们看看在 trie 树上实际是哪几个点做出了贡献：

![](https://cdn.luogu.com.cn/upload/image_hosting/kbj33kcr.png)

如果上述样例中的`h`和`t`也打上结尾标记呢？

那么应该是：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohm6uax1.png)

或者：

![](https://cdn.luogu.com.cn/upload/image_hosting/uba8v0k2.png)

观察一下这张图，想想这个题的做法，DP，树形DP，你想到了什么？

对！树形DP经典题——[毛毛虫](https://www.luogu.com.cn/problem/P3174)。

所以这个题实际上是让我们按照上述方法建出 trie 树后，求出树上最大的毛毛虫，转移方程和毛毛虫的一模一样，只需要维护一个最长链和次长链即可。

那么，到这里就完了吗？

并没有，想想我们刚才忽略了些什么，回到我们刚才的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/aj5ez24e.png)

可能你在跑样例的时候已经意识到了这一点，对，**单词结尾标记**，显然如果一个点都不是一个单词的结尾，那么它一定不能参与转移，所以在转移过程中特判一下即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define awa 2147483647
#define zhale exit(0)
#define re register
#define rint re int

using namespace std;
/*Shioiri Kukuri*/

typedef long long ll;
typedef unsigned long long ull;
typedef double qwq;
typedef pair<int,int> P;
typedef pair<ll,ll> llP;
#define rll re ll
#define rqwq re qwq

/*Otho Ai*/

template<class T>
void Swap(T &x,T &y)
{
	T z=x;
	x=y;
	y=z;
}

//#define PairOP
#ifdef PairOP
template<class T1,class T2>
inline const pair<T1,T2> operator + (const pair<T1,T2> &p1,const pair<T1,T2> &p2){
	return pair<T1,T2>(p1.first+p2.first,p1.second+p2.second);
}

template<class T1,class T2>
inline const pair<T1,T2> operator - (const pair<T1,T2> &p1,const pair<T1,T2> &p2){
	return pair<T1,T2>(p1.first-p2.first,p1.second-p2.second);
}
#endif

//#define FastIO
#ifdef FastIO
	char buf[1<<21],*p1,*p2;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif

template<class T>
T Read()
{
	T x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
//int (*read)()=Read<int>;
ll (*readll)()=Read<ll>;
#define read Read<int>

const int N=1e6+5;
int n,m,f[N],ans,p[N],tr[N][27],cnt;
vector<int> e[N];
char c[N];

inline void Insert(char *s)
{
	rint x=0;
	for(rint i=0;s[i];++i)
	{
		if(!tr[x][s[i]-'a']) tr[x][s[i]-'a']=++cnt;
		x=tr[x][s[i]-'a'];
	}
	p[x]++;
}

inline void Chuans() 
{
	for(rint i=cnt,mx1,mx2;~i;--i)
	{
		f[i]=p[i],mx1=mx2=0;
		for(rint j=0;j<26;++j)
		{
			if(!p[tr[i][j]]) continue;
			f[i]++;
			if(f[tr[i][j]]-1>mx1) mx2=mx1,mx1=f[tr[i][j]]-1;
			else if(f[tr[i][j]]-1>mx2) mx2=f[tr[i][j]]-1;
		}
		f[i]+=mx1,ans=max(f[i]+mx2,ans);
	}
}

inline int True()
{
//#define Freopen
#ifdef Freopen
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif

//#define Clock
#ifdef Clock
	rint STR=clock();
#endif

	n=read();
	for(rint i=1;i<=n;++i)
	{
		scanf("%s",c);
		rint len=strlen(c);
		reverse(c,c+len),Insert(c);
	}
	Chuans(),printf("%d",ans);

#ifdef Clock
	rint END=clock();
	printf("Time:%dms\n",int((END-STR)/(qwq)CLOCKS_PER_SEC*1000));
	printf("Time:%ds\n",int((END-STR)/(qwq)CLOCKS_PER_SEC));
#endif
	return (0-0);//q(0-0)p q(>-<)p
}

int Love=True();

signed main(){;}

```

---

## 作者：erge (赞：5)

首先第一感觉是把每个单词反转后建trie树

我们称trie上的单词结尾节点为关键点

称一个节点的儿子中的关键点为该点的关键儿子

那么题意就是要选尽量多的合法关键点

我们考虑答案中两个相邻的字符串

可以发现他们的关键点一定是父子或兄弟关系

并且可以发现

如果选择了一个关键点以及他的一个关键儿子

那么应该贪心的把该点的所有关键儿子选完

并且该点最多只有两个儿子的子树中的其他关键点会被选取

如果选择了该点的两个儿子的子树中的其他关键点就不能选择该点的父亲

否则可以选择父亲

到这里就可以考虑答案长什么样了

我们发现我们答案选出来的节点一定是树上的一条关键节点的链并上该链上所有节点的关键儿子

于是这题就变成了树上最大链权问题

提高组的树形dp

---

## 作者：cosf (赞：2)

## [P4471 词韵](https://www.luogu.com.cn/problem/P4471)

## 思路

看到字符串、公共后缀等字眼，我们很容想到可以利用字典树，将字符串倒序插入，这样公共后缀就变成公共前缀了。

可以发现，两个押韵的单词的长度之差不会超过 $1$，这种状态在树上是很容易转移的，所以可以用树形 `dp`。

为了研究如何 `dp`，我们需要先知道最长的单词序列应该要长什么样。

注意到，对于一个单词，比他短并且和他押运的单词仅有一个，所以序列中一个单词左边和右边的单词不能同时小于它，经过推导，整个序列呈 `"<"` 型时是最长的。

![](https://cdn.luogu.com.cn/upload/image_hosting/jjzwi9zg.png)

可以发现，这样的序列被分为了两半。若我们令 $e_i$ 表示第 $i$ 个单词在树上的末尾，那么所有单词的 $e$ 都在以最短字符串的 $e$ 的父亲为根的子树上，完全符合树形 `dp` 的要求。

那么，我们设 $dp_i$ 表示以 $i$ 节点为结束的长度不增的押运序列的最长长度，。

可以推导出递推公式：

$$
dp_i = \begin{cases}0 & i \not\in E\\\max\{(\max_{j \in \operatorname{son \space of} i}dp_j) + (\sum_{j\in\operatorname{son\space of} i}[j \in E]), 1\}&i \in E\end{cases}
$$

其中 $E$ 表示所有单词结尾的节点集。

第二行描述的序列的具体意义为：以它的子节点为结束中最长的序列、它的所有为字符串结束的子节点、它自己。

那么答案就是 

$$
\max_{i}\{[i \in E] + \max_{j\in\operatorname{son\space of}i}dp_j + \operatorname{smax}_{j\in\operatorname{son\space of} i}dp_j + \max\{\sum_{j \in \operatorname{son\space of}i}[j \in E], 0\}\}
$$

其中 $\operatorname{smax}$ 表示次大。不要以为它很复杂，实际上它描述的就是图中的序列情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/ssglnej4.png)

有了这个思路，我们就可以愉快地用 `dfs` 写树形 `dp` 了！

## 深搜部分代码

```cpp
int dfs(int p)
{
    int f = 0, s = 0, c = 0, r = 0;
    for (int i = 1; i <= 26; i++)
    {
        if (t[p].s[i])
        {
            r = max(r, dfs(t[p].s[i]));
            c += t[t[p].s[i]].e;
            /*
             * 这里的 max 是重载过的，返回的是前 2 大。
             * tie 的作用感兴趣者自行搜索。
             */
            tie(f, s) = max(f, s, dp[t[p].s[i]]);
        }
    }
    if (t[p].e)
    {
        dp[p] = f + max(c, 1);
    }
    return max(r, f + s + t[p].e + max(c - 2, 0));
}
```

---

## 写在最后

这题有 [双倍经验](https://www.luogu.com.cn/problem/P7537)，在洛谷上题目编号比此题大，而它被出的时间比此题早。


---

## 作者：fanke (赞：1)

### 题目

[link](https://www.luogu.com.cn/problem/P4471)

### 题解

根据字符串倒序建 trie 树，然后 dp，若某个点是单词的结尾则它和它父亲，孩子，以及兄弟 能形成押韵，维护一个最长押韵序列 $f[i]$，和最短的押韵序列 $h[i]$。

以 $i$ 为根的子树中形成的最长押韵序列长度。


```cpp
ans = max(ans , max(f[i][0] , f[i][1]));

```


然后就是 dfs。

### 部分代码（dfs）

```cpp
void dfs(int u)
{
    int ma = -1 , ma1 = -1; 
    int sum = w[u];
    for(int i = he[u] ; ~i ; i = tr[i].next)
    {
        dfs(i);
        sum += w[i];
        int t = dp[i][1] - w[i];
        if(t >= max1)
        {
            ma1 = ma;
            ma = t;
        }
        else if(t > ma1)
            ma1 = t;
    }
    if(ma >= 0 && ma >= 0)    
    	f[u][0] = sum + ma + ma ;
    if(w[u])  
		f[u][1] = sum + max(ma , 0);
}
```


---

## 作者：naoliaok_lovely (赞：1)

[双倍经验](https://www.luogu.com.cn/problem/P7537)

提供一种不用 trie 的方法。（至少整个思考过程与 trie 无关。但剖析其本质，二者之间还是有细微的联系）

# 哈希
由于题目要求 $\operatorname{lcs}(\rm A,B)\ge\max(A,B)-1$，先翻译成人话：若 $\rm A\ne B$，则 $\rm |A|=|B|+1(|A|<|B|)$ 且 B 为 A 的后缀；若 $\rm |A|=|B|$，则 A 和 B 的后 $\rm len-1$ 个字符相同。特别提醒：**不存在两个相同的字符串！**（本做法就是以这个条件为基础的，否则下述很多性质都不成立，请读者带着这个条件阅读下文）

由于要判断后缀相等，这里自然想到了 hash。设 $s1_i$ 表示原串对应的哈希值，$s2_i$ 表示原串后面的 $\rm len-1$ 个字符对应的哈希值。为了后面计算方便，顺便离散化一下。

# 分组
我们发现，如果把最终字符串序列对应的长度序列画出来，应该是一个下凸函数，即 $\cup$ 的形状。那是因为，一旦出现了一个地方是 $\land$ 型，不妨设为 ABC，其中 $\rm |A|+1=|B|=|C|+1$，则 A = C = B的后缀。（不会吧不会吧，不会真的有字符串存在长度相等的两个不同后缀吧？）这与题目条件矛盾（A 与 C 相同了）。于是我们将长度排序，从大到小处理，即只考虑长度减小的情况。注意到，abc,bbc,cbc...这类字符串，他们都会缩减为 bc 这个串。于是我们把这样后缀相同的的字符串分为一组。显然，每一组字符串会一起被使用。（这个结论后面会重新讨论，请留意）

```
for(int i = 1; i <= n; i++)
{
	len[i] = read(c);
	for(int j = 1; j <= len[i]; j++) s1[i] = s1[i] * P + c[j];
	s2[i] = s1[i] - c[1] * p[len[i] - 1];
	s1[i] = get(s1[i]), s2[i] = get(s2[i]);
	s[s2[i]].insert(s1[i]), to[s1[i]] = s2[i];
}
```

# DP
（以下的 $i$ 是上面分组的编号，即 $s2_i$，而非初始字符串编号）定义状态 $f1_i$ 表示只使用长度 $>$ 当前串的字符串，并以第 $i$ 组字符串结尾的长度最大值；$f2_i$ 表示次大值。转移时只需要用当前答案更新后续答案即可。

```
#include<bits/stdc++.h>
using namespace std;
#define ULL unsigned long long

const int N = 1e6 + 10, M = 3e6 + 10, P = 13331;
int n, len[N], id[N];
int f1[N], f2[N], ans;
char c[M];
ULL p[M], s1[N], s2[N];
set<int> s[N];
int to[N];
bool vis[N];

char buf[1 << 21], *p1 = buf, *p2 = buf;
inline char gc()
{
	if(p1 == p2)
		p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin);
	return p1 == p2 ? EOF : *p1++;
}
inline int read()
{
	int f = 1, w = 0;
	char ch = gc();
	while(ch < '0' || '9' < ch)
	{
		if(ch == '-') f = -1;
		ch = gc();
	}
	while('0' <= ch && ch <= '9')
	{
		w = (w << 1) + (w << 3) + (ch ^ 48);
		ch = gc();
	}
	return f * w;
}
inline int read(char c[])
{
	int len = 0;
	char ch = gc();
	while(ch < 'a' || 'z' < ch) ch = gc();
	while('a' <= ch && ch <= 'z')
	{
		c[++len] = ch;
		ch = gc();
	}
	return len;
}

unordered_map<ULL, int> ids;
int idx;
int get(ULL x)
{
	if(ids.count(x)) return ids[x];
	return ids[x] = ++idx;
}

bool cmp(int x, int y)
{
	return len[x] > len[y];
}

int main()
{
	p[0] = 1;
	for(int i = 1; i <= 3e6; i++) p[i] = p[i - 1] * P;
	n = read();
	for(int i = 1; i <= n; i++)
	{
		len[i] = read(c);
		for(int j = 1; j <= len[i]; j++) s1[i] = s1[i] * P + c[j];
		s2[i] = s1[i] - c[1] * p[len[i] - 1];
		s1[i] = get(s1[i]), s2[i] = get(s2[i]);
		s[s2[i]].insert(s1[i]), to[s1[i]] = s2[i];
	}
	
	for(int i = 1; i <= n; i++) id[i] = i;
	sort(id + 1, id + n + 1, cmp);
	for(int i = 1; i <= n; i++)
	{
		int t = id[i];
		if(vis[s2[t]]) continue;
		vis[s2[t]] = 1;
		f1[s2[t]] += s[s2[t]].size();
		ans = max(ans, f1[s2[t]] + f2[s2[t]]);
		if(f1[s2[t]] > f1[to[s2[t]]]) f2[to[s2[t]]] = f1[to[s2[t]]], f1[to[s2[t]]] = f1[s2[t]];
		else if(f1[s2[t]] > f2[to[s2[t]]]) f2[to[s2[t]]] = f1[s2[t]];
	}
	
	cout << ans << endl;
	return 0;
}
```
[挂分记录](https://www.luogu.com.cn/record/113453093)  

# 特判边界
没错，这样写只能拿到 $50pts$。那问题出在哪里？？？假设有这样一组数据：  
`a ba ca xba yca`  
上面的代码会输出 `4`。  
没错，在之前的程序中，`ba ca` 这两个字符串被一起使用了，而正解应该为 `xba ba a ca yca`。确实，这两个最终都会使用，但不一定会连续。这也是之前的错误之处。再次定义 $f3_i$ 表示以第 $i$ 组的**某一个**字符串作为最短串的答案，顺带转移 $f3_i$ 即可。注意这里为什么是 $1$ 个，而不是 $1$ 组，读者可以自行思考。

# 代码
```
#include<bits/stdc++.h>
using namespace std;
#define ULL unsigned long long

const int N = 1e6 + 10, M = 3e6 + 10, P = 13331;
int n, len[N], id[N];
int f1[N], f2[N], f3[N], ans;
char c[M];
ULL p[M], s1[N], s2[N];
set<int> s[N];
int to[N];
bool vis[N];

char buf[1 << 21], *p1 = buf, *p2 = buf;
inline char gc()
{
	if(p1 == p2)
		p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin);
	return p1 == p2 ? EOF : *p1++;
}
inline int read()
{
	int f = 1, w = 0;
	char ch = gc();
	while(ch < '0' || '9' < ch)
	{
		if(ch == '-') f = -1;
		ch = gc();
	}
	while('0' <= ch && ch <= '9')
	{
		w = (w << 1) + (w << 3) + (ch ^ 48);
		ch = gc();
	}
	return f * w;
}
inline int read(char c[])
{
	int len = 0;
	char ch = gc();
	while(ch < 'a' || 'z' < ch) ch = gc();
	while('a' <= ch && ch <= 'z')
	{
		c[++len] = ch;
		ch = gc();
	}
	return len;
}

unordered_map<ULL, int> ids;
int idx;
int get(ULL x)
{
	if(ids.count(x)) return ids[x];
	return ids[x] = ++idx;
}

bool cmp(int x, int y)
{
	return len[x] > len[y];
}

int main()
{
	p[0] = 1;
	for(int i = 1; i <= 3e6; i++) p[i] = p[i - 1] * P;
	n = read();
	for(int i = 1; i <= n; i++)
	{
		len[i] = read(c);
		for(int j = 1; j <= len[i]; j++) s1[i] = s1[i] * P + c[j];
		s2[i] = s1[i] - c[1] * p[len[i] - 1];
		s1[i] = get(s1[i]), s2[i] = get(s2[i]);
		s[s2[i]].insert(s1[i]), to[s1[i]] = s2[i];
	}
	
	for(int i = 1; i <= n; i++) id[i] = i;
	sort(id + 1, id + n + 1, cmp);
	for(int i = 1; i <= n; i++)
	{
		int t = id[i];
		if(vis[s2[t]]) continue;
		vis[s2[t]] = 1;
		f1[s2[t]] += s[s2[t]].size(), f3[s2[t]]++;
		ans = max(ans, max(f1[s2[t]] + f2[s2[t]], f3[s2[t]]));
		if(f1[s2[t]] > f1[to[s2[t]]]) f2[to[s2[t]]] = f1[to[s2[t]]], f1[to[s2[t]]] = f1[s2[t]];
		else if(f1[s2[t]] > f2[to[s2[t]]]) f2[to[s2[t]]] = f1[s2[t]];
		if(s[s2[t]].size() > 1) f3[to[s2[t]]] = f1[s2[t]] + f2[s2[t]];
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Fake_coder (赞：1)

对于这一题来说最主要的不是反向建立一个trie　　　~~毕竟这是一道紫题~~　　

我觉得这一题最终要的是树上DP(我想了接近半个月)
这一道题的状态转移方程为dp[i]=val[i]+max(dp[j])
其中ｊ是ｉ这一个结点的儿子的编号

我们要在字典树中的结点上标记true or false　ｔｒｕｅ的意思是有一个字符串的最后一个字母终止在这里

```cpp
void build(string s){
    int u=0;
    int l=s.length();
    for(int i=l-1;i>=0;i--){
        if(!ch[u][s[i]-'a']){
            ch[u][s[i]-'a']=++sz;
        }
        u=ch[u][s[i]-'a'];
        if(i==0)
        val[u]++;
    }
}
```


然后我们在寻找的时候只要找到从叶结点到一个ｉ结点的最长链和次最长链
（为什么是链呢？因为题目中说要么上下两个字符串一个字符串是另外一个字符串的子结点，要么两个字符串相差一个字母，这两种情况分别对应兄弟节点和父子节点）
往兄弟节点走的情况就是状态转移方程中的ｖａｌ[i]　　往父子节点走的最优状况就是所有儿子节点中的dp值最大的

好的就是这样，然后我们就能过了

---

## 作者：Mortidesperatslav (赞：1)

因为后缀比较难求，所以我们考虑来一个变形。

我们容易发现，其实把每个字符串倒过来，只要把 LCS 换成 LCP 就行了，影响不大。

然后，前缀怎么做，当然是 Trie！我们可以用 Trie 维护字符集，然后我们多加一个信息，记录每个节点是否是一个字符串的末尾。

再然后，写一个简简单单的树形 dp 就好了。

因为递归可能常数过大，可能有一点点悬，所以考虑从字符的加入顺序逆序维护，因为一个节点的父亲总是比这个节点早加入。这样就解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, q, n, tr[3000005][27], ct[3000005], cnt, ans;
int til[3000005];
int f[3000005], ff[3000005];
string s;
int gvl(char x){//给字符一个非单向的散列值，节省空间
	return x - 97;
}
void ins(string str){//添加一个字符串
	int p = 0, n = str.size();
	for (int i = n - 1; i >= 0; i--){
		int vl = gvl(str[i]);
		if (tr[p][vl] == 0)//新增节点
			tr[p][vl] = ++cnt;
		p = tr[p][vl];
		ct[p]++;
		if (i == 0)
			til[p] = 1;//记录末尾
	}
}
void DPOnTree(){//dp
	int u;
	while (cnt >= 0){
		u = cnt;
		int mx = 0, smx = 0;
		for (char i = 'a'; i <= 'z'; i++){//枚举子节点
			int vl = gvl(i);
			int v = tr[u][vl];
			if (!til[v])
				continue;
			f[u] += til[v];
			if (ff[v] >= mx){
				smx = mx;
				mx = ff[v];
			}else if (ff[v] >= smx)
				smx = ff[v];
		}
		if (til[u])
			ff[u] = f[u] + mx;
		ans = max(ans, mx + smx + f[u] + til[u]);
		cnt--;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> s;
		ins(s);
	}
	DPOnTree();
	cout << ans;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P4471)

[双倍经验](https://www.luogu.com.cn/problem/P7537)

# 思路：

容易想到，将字符串翻转一下，后缀就变成了前缀，然后将字符串挂到字典树上。
如果要满足两个字符串的最大公共前缀长度大于等于最长的字符串的长度 $-1$，只有两种情况。

设字符串为 $S$，字符为 $C$。那么只可能是 $S+C_1$ 和 $S+C_2$ 或者 $S$ 和 $S+C$。设 ```dp[u]``` 为以字符 $u$ 为结尾的字符串中，押韵字符串的最大数量。

对于一个字符串，要找最大押韵序列，它可以从自己的子节点转移过来，但是不能所有的节点都转移过来，只能有两个。

最中间的字符串找到的最大的押韵序列，就是它子节点中最大的两个孩子的数量之和。
同时，它也可以用剩余孩子，但是不能用它们的孩子。所以对于 $u$，它的最大值就是最大的两个孩子的数量加自己加剩余有的孩子的数量。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e6+10;
const int INF=0x3f3f3f3f;
char s[N];
int n,ans;
struct node{
	int tr[N][26],c[N],dp[N],ix=0;
	void insert(char s[]){
		int u=0,len=strlen(s);
		for(int i=len-1;i>=0;i--){
			int v=s[i]-'a';
			if(!tr[u][v]){
                tr[u][v]=++ix;
            }
			u=tr[u][v];
		}
		c[u]++;
	}
	void dfs(int u){
		int m1=0,m2=0,cnt=0;
		for(int i=0;i<26;i++){
			int v=tr[u][i];
			if(!v){
                continue;
            }
			dfs(v);
			cnt+=c[v];
			if(dp[v]>m1){
				m2=m1;
				m1=dp[v];
			}else if(dp[v]>m2){
				m2=dp[v];
			}
		}
		if(c[u]){
			dp[u]=m1+max(cnt,1ll);
        }
		ans=max(ans,m1+m2+max(0ll,cnt-2)+c[u]);
	}
}tr;
signed main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		tr.insert(s);
	}
	tr.dfs(0);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：LHW_Cosset_Idiot (赞：0)

此题涉及到了 [LCS](https://oi-wiki.org/string/sa/)（最长公共后缀），建议 LCP 把一起学了。

当然不会那么简单，还涉及到了 [字典树](https://oi-wiki.org/string/trie/)。

trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（$c$ 的取值范围和字符集大小有关，不一定是 $0 \sim 26$。）

- 构造字典树
- 模拟字典树

### 正解代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,f[1000001],cnt[1000001][27],t,ans,maxx,maxl,sum;
char c[3000001];
bool p[1000001];
void getnum(char s[3000001]) //构造字典树
{
    for(int i=strlen(s)-1; i>=0; i--){
        if(cnt[m][s[i]-'a']==0){
            cnt[m][s[i]-'a']=++t;
        }
        m=cnt[m][s[i]-'a'];
    }
    p[m]=1;
    m=0;
    return ;
}
int main()
{
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>c;
        getnum(c); 
    }
    for(int i=t; i>=0; i--){ //LCS以及字典树的模拟（其实是一个东西）
        for(int j=0; j<=25; j++){
            if(p[cnt[i][j]]==0){
                continue;
            }
            sum++;
            if(f[cnt[i][j]]>=maxx){
                maxl=maxx;
                maxx=f[cnt[i][j]];
            }else if(f[cnt[i][j]]>=maxl){
                maxl=f[cnt[i][j]];
            }
        }
        ans=max(ans,maxx+maxl+p[i]+sum);
        f[i]=sum+maxx;
        maxx=0,maxl=0,sum=0;
    }
    cout<<ans;
    return 0; 
}
```
正解做法就是用 LCS 模拟，这里给出一个字典树模版做比较。（这两本质上是差不多的）

```
#include<bits/stdc++.h>
using namespace std;
int T,q,n,t[3000005][65],cnt[3000005],idx;
char s[3000005];
int getnum(char x)
{
    if(x>='A' && x<='Z'){
        return x-'A';
    }else if(x>='a' && x<='z'){
        return x-'a'+26;
    }else{
        return x-'0'+52;;
    }
}
void insert(char str[])
{
    int p=0,len=strlen(str);
    for(int i=0; i<len; i++){
        int c=getnum(str[i]);
        if(!t[p][c]){
            t[p][c]=++idx;
        }
        p=t[p][c];
        cnt[p]++;
    }
}
int find(char str[])
{
    int p=0,len=strlen(str);
    for(int i=0; i<len; i++){
        int c=getnum(str[i]);
        if(!t[p][c]){
            return 0;
        }
        p=t[p][c];
    }
    return cnt[p];
}
int main()
{
    cin>>T;
    while(T--){
        for(int i=0; i<=idx; i++){
            for(int j=0; j<=122; j++){
                t[i][j]=0;
            }
        }
        for(int i=0; i<=idx; i++){
            cnt[i]=0;
        }
        idx=0;
        cin>>n>>q;
        for(int i=1; i<=n; i++){
            cin>>s;
            insert(s);
        }
        for(int i=1; i<=q; i++){
            cin>>s;
            cout<<find(s)<<endl;
        }
    }
    return 0;
}
```
其实这两份代码非常相似，只需要稍加理解就 OK 了。 

严禁抄袭！！！

---


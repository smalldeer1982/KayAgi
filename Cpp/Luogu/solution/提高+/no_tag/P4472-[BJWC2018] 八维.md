# [BJWC2018] 八维

## 题目描述

我们将一个 $M$ 行 $N$ 列的字符矩阵无限复制，可以得到一个无限字符矩阵。例如，对于以下矩阵:

$$\begin{aligned}
& \verb!honi! \\
& \verb!hsin! \\
\end{aligned}$$

可以无限复制出矩阵

$$\begin{aligned}
& \verb!...honihonihonihoni...! \\
& \verb!...hsinhsinhsinhsin...! \\
& \verb!...honihonihonihoni...! \\
& \verb!...hsinhsinhsinhsin...! \\
\end{aligned}$$

我们认为矩阵是八连通的。八连通，  指矩阵中的每个位置与上下左右和四个斜向（左上、右上、左下、右下）的位置相邻。因此，从矩阵任意位置出发沿八个方向中的任意一个都可以无限延长。

如果我们随机选择一个位置和一个方向，则可以从此位置开始沿此方向连续选取 $K$ 个字符组成一个字符串。问，两次这样操作得到两个相同字符串的概率是多少。(假设随机选择时任意位置是等可能的，任意方向也是等可能的)

## 说明/提示

**【样例解释】**

样例一中，一次操作共有 $16$ 种可能，其中得到 $\verb!aa!$ 的概率是 $1/8$，得到 $\verb!ab!$ 的概率是 $3/8$,得到bb 的概率是 $1/8$，得到 $\verb!ba!$ 的概率是 $\verb!3/8!$。两次操作结果相同的
概率是 $5/16$。

**【数据规模和约定】**

- 对于 $30\%$ 的测试数据：$M, N ≤ 10$，$K ≤ 100$。
- 对于 $50\%$ 的测试数据：$M = N$。
- 对于 $100\%$ 的测试数据 ：$1 ≤ M,N ≤ 500$，$2 ≤ K ≤ 10^9$。

## 样例 #1

### 输入

```
1 2 2
ab```

### 输出

```
5/16```

## 样例 #2

### 输入

```
3 3 10
ban
ana
nab```

### 输出

```
2/27```

# 题解

## 作者：囧仙 (赞：5)

## 题目大意

给一个由 $n\times m$ 的字符矩阵无限复制得到的矩阵。等概率随机选择一个起点，并等概率随机选择一个方向（上、下、左、右、左上、左下、右上、右下），将这个方向上 $k$ 个字符组成一个字符串。询问这样选出来的两个字符串相同的概率。

$n,m\le 500; k\le 10^9$ 。

## 题解

我们设 $S_{i,j}$ 表示第 $i+1$ 行第 $j+1$ 列的字符。由无限复制的定义可以得到， $S_{i,j}=S_{i\bmod n,j\bmod m}$ 。

考虑计算出每个起点、每个方向上组成的字符串的哈希值。这里我们采用如下哈希方式：

$$H(X)=\sum_{i=0}^{len} X_iP^{len-i-1} \pmod{2^{64}}$$

其中 $X$ 是一个长度为 $len$ ，下标范围是 $[0,len)$ 的字符串。

如果直接暴力计算所有的字符串，这样的时间复杂度是 $\mathcal O(nmk)$ ，显然是不行的。但事实上，我们可以找到 $X$ 的循环节。可以证明， $X$ 的循环节长度不会超过 $nm$ （考虑 $X$ 的下标的模意义）。

假定有一个循环节是 $\verb!"aab"!$ 的字符串，它的长度为 $11$ 。

$$X=\verb![(aab)(aab)(aab)aa]!$$

我们可以计算出它循环节的哈希值（设为 $H_0$ ，它的长度为 $L_0$ ），那么完整的循环部分的哈希值应该为：

$$\begin{aligned}H(\verb!aabaabaab!)&=H_0\times \left(P^3\right)^2+H_0\times \left(P^3\right)^1+H_0\times \left(P^3\right)^0\cr
&=H_0\left(\left(P^3\right)^2+\left(P^3\right)^1+\left(P^3\right)^0\right)
\end{aligned}$$

显然，括号里的是一个首项为 $1$ ，公比为 $P^3$ 的等比数列。对于一个等比数列，我们有如下公式：

$$q^0+q^1+\cdots +q^{n-1}=\frac{q^n-1}{q-1}$$

但是由于模数是 $2^{64}$ ，而 $q-1=P^{L_0}-1$ 是不存在乘法逆元的。考虑使用分治法。

假设我们要计算 $F(q,n)=q^0+q^1+\cdots +q^{n-1}$ ，那么有：

$$F(q,n)=\begin{cases}
0 & n=0 \cr
1 & n=1 \cr
(1+q)\times F(q^2,\lfloor n\div2\rfloor) & n\equiv 0\pmod 2 \cr
(1+q)\times F(q^2,\lfloor n\div2\rfloor)\times q+1 & n\equiv 1\pmod 2 \cr
\end{cases}$$

这么做的复杂度是 $\mathcal O(\log k)$ 。

对于 $H(X)$ 的后半部分，我们可以直接暴力。这样的复杂度不超过 $\mathcal O(L_0)$ 。但由于 $L_0$ 可能达到 $n\times m$ ，于是总复杂度为 $\mathcal O(n^2m^2)$ 。显然，我们还要进一步优化。

不妨以样例二为例：

$$\begin{bmatrix}
\tt\color{grey}\textcolor{black}{b\ a\ n}\ b\ a\ n\ b\ a\ n\ b\ a\ n \cr
\tt\color{grey}\textcolor{black}{a}\ \underlinesegment{\textcolor{black}{n\ a}\ a\ n\ a\ a\ n\ a\ a\ n}\ a \cr
\tt\color{grey}n\ a\ b\ n\ a\ b\ n\ a\ b\ b\ a\ n \cr
\tt\color{grey}b\ a\ n\ b\ a\ n\ b\ a\ n\ a\ n\ a \cr 
\tt\color{grey}a\ n\ a\ a\ n\ a\ a\ n\ a\ b\ a\ n \cr
\tt\color{grey}n\ a\ b\ n\ a\ b\ n\ a\ b\ a\ n\ a \cr
\end{bmatrix}$$

假如我们已经计算出了 $X_0=\verb![naanaanaan]!$ 这一段的哈希值，现在要计算它右边的一个字符串 $X_1=\verb![aanaanaana]!$ 。我们能够发现，它们共用一个循环节。它的哈希值就是把 $H(X_0)$ 乘上 $P$ 、减去最左侧的字母 $\verb!n!$ 的贡献、再加上最右侧 $\verb!a!$ 的贡献。

也就是说，只要我们计算出任意一个长度为 $k$ 的字符串的哈希值，就能 $\mathcal O(\log k)$ 转移到将它向右移动一位的字符串的哈希值。但事实上，我们可以预处理 $P^k$ ，那么单次转移的复杂度就降为了 $\mathcal O(1)$ 。

计算一个长度为 $k$ 的字符串的哈希值的复杂度是 $\mathcal O(L_0\log  k)$ ，我们再花费 $\mathcal O(L_0)$ 的复杂度将共用这个循环节的其他的长度为 $k$ 的字符串的哈希值求出来。于是平均每个字符串的复杂度是 $\mathcal O(\log k)$ 。又因为一共只有 $n\times m\times 8$ 个需要计算的字符串，于是总复杂度为 $\mathcal O(nm\log k)$ ，可以通过本题。

另外，我们需要开一个哈希表将哈希值相同的字符串插入进去，然后统计相同哈希值的字符串有多少个，计算出共有多少种选法使得两个字符串哈希值相同。除以总方案数 $n\times m\times 8$ 就行了。

实测跑的飞起（

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN=500+3,P=13331;
char S[MAXN][MAXN],T[MAXN*MAXN]; u64 h;
bool vis[MAXN][MAXN]; int n,m,p,s,t; i64 ans1,ans2;
const int dir[8][2]={{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};
u64 pwr(u64 a,u64 b){
    u64 r=1; while(b){if(b&1) r=r*a; a=a*a,b>>=1;} return r;
}
const int SIZ =999997,MAXM=MAXN*MAXN*8;
int head[SIZ],val[MAXM],nxt[MAXM],tot; u64 ver[MAXM];
void add(int u,u64 v){
    ver[++tot]=v,nxt[tot]=head[u],val[tot]=1,head[u]=tot;
}
void inc(u64 h){
    for(int p=head[h%SIZ];p;p=nxt[p])
    if(ver[p]==h){ans1+=2ll*val[p]+1,++val[p];return;}
    add(h%SIZ,h),++ans1;
}
u64 calc(u64 a,u64 b){  //calc a^0+a^1+a^2+...+a^(b-1)
    if(b==0) return 0; if(b==1) return 1;
    if(b&1) return (1ull+a)*calc(a*a,b>>1)*a+1;
    else    return (1ull+a)*calc(a*a,b>>1);
}
int main(){
    n=qread(),m=qread(),p=qread(); u64 q=pwr(P,p);
    up(0,n-1,i) scanf("%s",S[i]);
    up(0,7,d){
        up(0,n-1,i) up(0,m-1,j) if(!vis[i][j]){
            int a=i,b=j; h=0; while(!vis[a][b]){
                h=h*P+S[a][b],T[t++]=S[a][b],vis[a][b]=true;
                a=(n+a+dir[d][0])%n,b=(m+b+dir[d][1])%m;
            }
            int x=p%t; h*=calc(pwr(P,t),p/t);
            up(0,x-1,k) h=h*P+T[k];
            up(0,t-1,k) inc(h),h=h*P+T[(x+k)%t]-T[k]*q;
            t=0;
        }
        up(0,n-1,i) up(0,m-1,j) vis[i][j]=0;
    }
    ans2=1ll*n*m*8*(1ll*n*m*8); i64 d=__gcd(ans1,ans2);
    printf("%lld/%lld\n",ans1/d,ans2/d);
    return 0;
}
```

---

## 作者：lqsy002 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P4472)。

## 解题思路

哈希，倍增。

注意到 $k \in[2,10^9]$。

暴力复杂度 $O(mnk)$ 显然超时，考虑用 $\log k$ 的时间处理。

类似 ST 表的做法，因为 $k$ 步同方向，倍增处理后合并。

合并后遍历 hash 数组，将答案加上所有相同的字符串数量，因为所有字符串均可以由原字符串向 $8$ 个方向扩张后平移得到。

所以实际只需得出 $8 \times m \times n$ 个字符串的哈希值即可。

$n \times m$ 的矩阵 $8$ 个方向，总方案数 $(8 \times m \times n)^2$。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define int long long
#define siz 2000000//8mn 
#define maxn 205
using namespace std;
int n,m,k,logk,pm,pn,ans1,ans2,pow1[50],cnt[siz+10];
int dic[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
ull pow2[50],hash1[siz+10],hash2[siz+10],f[5][10][maxn][maxn];
//f_{i,j,k,l}表示从(i,j)开始像k方向走2^l步得到的hash 
//pow1倍增 pow2作为hash的base 
string s;
int Hash(ull x,ull y){
    int p=x%siz; 
    while(hash1[p]&&((hash1[p]!=x)||(hash2[p]!=y)))
        if(++p==siz)
            p=0;
    return p;
}
signed main(){
    freopen("genius.in","r",stdin);
    freopen("genius.out","w",stdout);
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    cin>>m>>n>>k;
    logk=log(k)/log(2);//倍增的边界 
    for(int i=1;i<=m;++i){
        cin>>s;
        s=" "+s;
        for(int j=1;j<=n;++j)
            for(int l=0;l<8;++l)
                f[0][l][i][j]=s[j]-('a'-1);
    }
    pow1[0]=1;
    pow2[0]=31;
    for(int i=1,p;i<=logk;++i){
        pow1[i]=(pow1[i-1]<<1);
        pow2[i]=pow2[i-1]*pow2[i-1];
        for(int j=0;j<8;++j)
            for(int l=1;l<=m;++l)
                for(int o=1;o<=n;++o){
                    p=i&1;
                    pm=((l+dic[j][0]*pow1[i-1]-1)%m+m)%m+1;
                    pn=((o+dic[j][1]*pow1[i-1]-1)%n+n)%n+1;
                    f[p][j][l][o]=f[p^1][j][l][o]+f[p^1][j][pm][pn]*pow2[i-1];
                }
    }
    for(int i=0,p,logkk=logk&1;i<8;++i)
        for(int j=1;j<=m;++j)
            for(int l=1;l<=n;++l){
                pm=((j+dic[i][0]*(k-pow1[logk])-1)%m+m)%m+1;
                pn=((l+dic[i][1]*(k-pow1[logk])-1)%n+n)%n+1;
                p=Hash(f[logkk][i][j][l],f[logkk][i][pm][pn]);//找到插入hash的位置 
                hash1[p]=f[logkk][i][j][l];
                hash2[p]=f[logkk][i][pm][pn];
                ++cnt[p];//计数相同哈希值 
            }
    for(int i=0;i<siz;++i)
        if(cnt[i])
            ans1+=cnt[i]*cnt[i];
    ans2=n*n*m*m*64;
    k=__gcd(ans1,ans2);
    cout<<ans1/k<<'/'<<ans2/k;
    return 0;
}
//双倍经验 P7635
```

---

## 作者：zhangshiyan (赞：0)

# P4472 [BJWC2018] 八维
[R188750950 记录详情](https://www.luogu.com.cn/record/188750950)

## Main Idea
给定一个字符矩阵，我们将这个矩阵无限复制，形成一个无限大的矩阵。然后，从矩阵中的任意位置出发，可以沿着八个方向（上下左右以及四个斜对角方向）选取连续的 $K$ 个字符，形成一个字符串。题目要求计算，随机选择两个位置和两个方向，得到两个相同的字符串的概率。

## Solution
枚举起点 $i$ 和 $j$ 和八个方向 $d$，于是考虑计算哈希值，由于 $2 \leq K \leq 10^9$，数据太大了，于是可以考虑倍增计算哈希值。

我们发现对于每个点，只有八个方向，最终能得到 $8 \times n \times m$ 个字符串，不是很多，那我们可以考虑求出这些字符串的哈希值，相同的哈希值代表选到相同字符串的一种可能，直接统计即可。

但是，模数取 $998244353$ 时被卡掉一个点。

你可以选择：
1. 使用双哈希。
2. 使用一些不那么有名的模数。
3. 自然溢出

### 优化
当你做完后，开心地提交后，发现错了，为什么呢？由于空间复杂度是 $O(8 \times n ^ 2 \times \log_{2}{K})$ 内存超限了，怎么办呢？

肯定是用类似滚动数组的方式来优化空间复杂度，由于八个方向之间的计算互不影响，所以我们分开算八次，优化空间复杂度为 $O(n ^ 2 \times \log_{2}{K})$ 刚好可以过，具体实现见代码。

当你改完后，开心地提交后，发现还是错了，为什么呢？

注意，如果哈希的时候取模，是很慢。可以用自然溢出或不要再同一行代码取太多了模。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define INF 0x7ffffff

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')
		{
			f = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar();
	}
	return x * f;
}

const ll mod = 998244853;

char c[505][505];
int st[505][505][50];
ll poww[100];
ll pow2[100];
ll ans[20000010], top;

int dx[10] = {0, 0, 1, -1, 1, 1, -1, -1};
int dy[10] = {1, -1, 0, 0, 1, -1, 1, -1};

ll gcd(ll a, ll b)
{
	return !b ? a : gcd(b, a % b);
}

int main()
{
	poww[0] = 133;
	for(int i = 1; i <= 35; i++)
	{
		poww[i] = (poww[i - 1] * poww[i - 1]) % mod;
	}
	pow2[0] = 1;
	for(int i = 1; i <= 35; i++)
	{
		pow2[i] = pow2[i - 1] * 2;
	}
	int n = read(), m = read(), kkk = read();
	for(int i = 0; i < n; i++)
		scanf("%s", c[i]);
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < m; j++)
		{
			st[i][j][0] = c[i][j] - 'a' + 1;
		}
	}
	for(int k = 0; k < 8; k++)//分开算八次
	{
		for(int l = 1; l <= 30; l++)
		{
			for(int i = 0; i < n; i++)
			{
				for(int j = 0; j < m; j++)
				{
					int x = (i + dx[k] * (pow2[l - 1])) % n;
					int y = (j + dy[k] * (pow2[l - 1])) % m;
					x = (x + n) % n;
					y = (y + m) % m;
					st[i][j][l] = (st[i][j][l - 1] * poww[l - 1] + st[x][y][l - 1]) % mod;
				}
			}
		}
		for(int i = 0; i < n; i++)
		{
			for(int j = 0; j < m; j++)
			{
				ll Hash = 0;
				int x = i, y = j;
				for(int l = 30; l >= 0; l--)
				{
					if(kkk & (1 << l))
					{
						Hash = Hash * poww[l] + st[x][y][l];
						x = (x + pow2[l] * dx[k]) % n;
						y = (y + pow2[l] * dy[k]) % m;
						x = (x + n) % n;
						y = (y + m) % m;
					}
				}
				ans[++top] = Hash;
			}
		}
	}
	sort(ans + 1, ans + top + 1);
	ll cnt = 0;
	ll ans1 = 0;
	ll ans2 = top * top;
	for(int i = 1; i <= top; i++)
	{
		if(i > 1 && ans[i] == ans[i - 1])
		{
			cnt++;
		}
		else
		{
			ans1 += 1LL * cnt * cnt;
			cnt = 1;
		}
	}
	ans1 += cnt * cnt;
	printf("%lld/%lld", ans1 / gcd(ans1, ans2), ans2 / gcd(ans1, ans2));
	return 0;
}
```

---


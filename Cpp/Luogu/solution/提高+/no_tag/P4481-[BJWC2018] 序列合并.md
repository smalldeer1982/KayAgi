# [BJWC2018] 序列合并

## 题目背景

绿意盎然的一天，Scape 去 XX 赛区加冕为王。

## 题目描述

Scape 倒开题目，看到了这样一道题：

有一个序列 $A$ 和 $L,R$，每次可以合并相邻的 $K$ 个元素（要求 $L\leq K\leq R$），代价为这 $K$ 个元素的和并合并产生一个新元素，权值为这 $K$ 个元素的和。

求把整个序列合并为一个元素的最小代价。

Scape 想都不想就写了一个 $\mathcal{O}(n^4)$ 暴力，结果居然 T 了，作为 XX 之王的 Scape 自然不会管这种辣鸡题，请你写出这道题。

## 说明/提示

对于 $20\%$ 的数据， $n\le 20$。

对于 $60\%$ 的数据， $n\le 50$。

对于 $100\%$ 的数据， $1\le T\le 10,n\le 300,A_i\le 100$。

## 样例 #1

### 输入

```
3
3 2 2
1 2 3
3 2 3
1 2 3
4 3 3
1 2 3 4```

### 输出

```
9
6
0```

# 题解

## 作者：Querainy (赞：6)

虽然说挺水的，但是这是我的童年阴影，所以还是写个题解吧（

直接dp。设 $g(l,r)$ 表示区间 $l,...,r$ 合并成一个点的答案，$dp(l,r,i)$ 表示区间 $l,...,r$ 分成 $i$ 段，每一段合并成一个点的答案，$g$ 的转移枚举分了多少段，$dp$ 的转移枚举最后一段。复杂度 $O(n^4)$，常数小的吓人，直接冲就过了。滚一下 $dp$，空间是 $O(n^2)$ 的。

```cpp
#include<stdio.h>
#include<string.h>

inline int min(int x,int y){ return x<y?x:y; }

int n,L,R;
int dp[302][302],g[302][302];
int a[302],pre[302];

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&L,&R);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]),pre[i]=pre[i-1]+a[i];
		memset(g,0x3f,sizeof(g));
		for(int i=1;i<=n;i++) g[i][i]=0;
		for(int l=n;l>=1;l--)
		{
			memset(dp,0x3f,sizeof(dp));
			dp[l-1][0]=0;
			for(int r=l;r<=n;r++)
			{
				for(int i=1;i<=r-l+1&&i<=R;i++)
					for(int p=r;p>=l;p--)
						dp[r][i]=min(dp[r][i],dp[p-1][i-1]+g[p][r]);
				for(int i=L;i<=R;i++) g[l][r]=min(g[l][r],dp[r][i]+pre[r]-pre[l-1]);
				dp[r][1]=min(dp[r][1],g[l][r]);
			}
		}
		printf("%d\n",g[1][n]==0x3f3f3f3f?0:g[1][n]);
	}
	return 0;
}
```

---

## 作者：出言不逊王子 (赞：4)

开个坑，等 emo 了再写。

开 e 了，来更新题解了。

---

观察到数据范围很小，我们考虑区间 DP。套路地，设 $f_{i,j}$ 表示把 $[i,j]$ 合并成一个石头的最小代价。

考虑 $r=2$ 是套路的石子合并，列出方程有 $f_{i,j}=\min_k f_{i,k}+f_{k+1,j}+\sum a_x$。

这个可能看不出来啥，所以我们再列出 $r=3$ 时的方程，即 $f_{i,j}=\min_{k,l} f_{i,k}+f_{k+1,l}+f_{l+1,j}+\sum a_x$。

删掉 $\sum a_x$，我们发现其实我们只是想要把一段序列分成 $r$ 段，求最小代价。

那么我们固定左端点 $i$，考虑 $g_{x,j}$ 表示将 $[i,j]$ 分成 $x$ 段的最小代价，则每次我们可以划一段出来合并成一个石子，即 $g_{x,j}=\min_k g_{x-1,j}+f_{k,j}$。

那么 $f_{i,j}=\min_{x=l}^r g_{x,j}+\sum a_k$，最后输出 $f_{1,n}$ 即可。

为了节省常数，可以倒序枚举 $i$ 再正序枚举 $j$。

```cpp
#include<bits/stdc++.h>
#define fs(i,x,y,z) for(int i=x;i<=y;i+=z)
#define ft(i,x,y,z) for(int i=x;i>=y;i+=z)
#define int long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
#define pii pair<int,int>
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=303,inf=0x3f3f3f3f3f3f3f3f;
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int a[N],f[N][N],g[N][N],n,m,l,r,p[N];
void mian(){
	ms(f,0x3f);n=read(),l=read(),r=read();
	fs(i,1,n,1) a[i]=read(),p[i]=p[i-1]+a[i],f[i][i]=0;
//	fs(i,1,n,1) cout<<p[i]<<' ';
	ft(le,n,1,-1){
		ms(g,0x3f);g[0][le-1]=0;fs(ri,le,n,1){//g[i][j]表示[L,j]拿去切i段的最小代价
			fs(k,1,min(ri-le+1,r),1) fs(fg,le,ri,1) g[k][ri]=min(g[k][ri],g[k-1][fg-1]+f[fg][ri]);
			fs(k,l,r,1) f[le][ri]=min(f[le][ri],g[k][ri]+p[ri]-p[le-1]);
			g[1][ri]=min(g[1][ri],f[le][ri]);
	//		cout<<le<<' '<<ri<<' '<<f[le][ri]<<'\n';
		}
	}
//	fs(i,1,n,1) fs(j,1,n,1) cout<<f[i][j]<<" \n"[j==n];
//	cout<<f[1][n]<<"!\n";
//	if(f[1][n]==inf) puts("0");
//	else cout<<f[1][n]<<'\n';
	cout<<((f[1][n]==inf)?(0):f[1][n])<<'\n';
}
signed main(){
	int t=read();while(t--) mian();
	return 0;
}

```

---

## 作者：IGpig (赞：0)

## P4481
### Solution
这个题是个动态规划很容易看出来吧，既然题目写了 $\mathcal{O}(n^4)$ 那肯定就是这个复杂度了。

接下来先定义状态，$f_{i,j}$ 表示合并 $i\rarr j$ 的答案，最后答案就是 $f_{1,n}$。\
但是这样不好转移，因为我们不知道怎么来转移，所以真正的转移 $dp_{l,r,i}$ 表示把 $l\rarr r$ 分成 $i$ 段来合并的代价（分了之后不合并）。这样就能推出转移方程了（$r \ge i\ge l$）：

$$dp_{i,r} = \min(dp_{i-1,j-1} + f_{j,r})$$

$$f_{i,r} = \min(dp_{i,r} + (sum_r - sum_{i-1}))$$

$$dp_{i,r} = \min(f_{i,r})$$

按以上顺序更新就可以了，其中 $sum_i$ 表示原数组的前缀和，$(sum_r - sum_{i-1})$ 就是 $i\rarr r$ 的和。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
LL n,L,R,t,dp[305][305],f[305][305],a[305],sum[305];
int main(){
    cin>>t;
    while(t--){
        memset(f,0x3f,sizeof(f));
        cin>>n>>L>>R;
        for(int i=1;i<=n;i++){
            cin>>a[i];sum[i]=sum[i-1]+a[i];f[i][i]=0;
        }
        for(int l=n;l>=1;l--){
            memset(dp,0x3f,sizeof(dp));dp[0][l-1]=0;
            for(int r=l;r<=n;r++){
                for(int i=1;i<=min((int)R,r-l+1);i++){
                    for(int j=r;j>=l;j--){
                        dp[i][r]=min(dp[i][r],dp[i-1][j-1]+f[j][r]);
                    }
                }
                for(int i=L;i<=R;i++) f[l][r]=min(f[l][r],dp[i][r]+(sum[r]-sum[l-1]));
                dp[1][r]=min(dp[1][r],f[l][r]);
            }
        }
        cout<<(f[1][n]==f[304][304] ? 0 : f[1][n])<<endl;
    }
    return 0;
}
```

---

## 作者：yyyyxh (赞：0)

orz zhy，又被爆杀了。

首先四方 DP 是 trivial 的，我们设 $f_{l,r,d}$ 表示 $[l,r]$ 的区间内被合并成 $d$ 个石子的最小代价，对于 $d>1$ 的位置 DP 完后可以贡献到 $d=1$ 的位置。

其实这个做法可以直接通过本题（~~跑得飞快~~）可能有些卡常，所以这里需要对于同一个 $l$ 滚动空间，然后为了在复杂度瓶颈处访问连续需要交换两维。

```cpp
#include <cstdio>
using namespace std;
const int N=403;
const int INF=0x7fffffff;
int f[N][N],g[N][N];
inline void chmn(int &x,int v){if(x>v) x=v;}
int n,cl,cr;
int read(){/*...*/}
int s[N];
int main(){
	int tc=read();
	while(tc--){
		n=read();cl=read();cr=read();s[0]=0;
		for(int i=1;i<=n;++i) s[i]=read()+s[i-1];
		for(int i=0;i<=n;++i)
		    for(int j=0;j<=n;++j) f[i][j]=g[i][j]=INF;
		for(int l=n;l;--l){
		    g[l][l]=0;
		    f[1][l]=0;
			for(int r=l+1;r<=n;++r){
				g[r][l]=INF;
				for(int t=2;t<=r-l+1&&t<=cr;++t){
					register int tmp=INF;
					for(register int p=l+t-2;p<r;++p)
						if(f[t-1][p]!=INF&&g[r][p+1]!=INF) chmn(tmp,f[t-1][p]+g[r][p+1]);
					if(cl<=t&&t<=cr&&tmp!=INF) chmn(g[r][l],tmp+s[r]-s[l-1]);
					f[t][r]=tmp;
				}
				f[1][r]=g[r][l];
			}
		}
		if(g[n][1]==INF) puts("0");
		else printf("%d\n",g[n][1]);
	}
	return 0;
}
```

接下来是神 zhy 的福音：考虑这样一个问题，对于一个序列，给出每个区间的代价 $w_{l,r}$，问对于每一个区间 $[l,r]$ 将其划分成 $x$ 个区间，满足 $x\in[L,R]$，求划分出来的区间的最小代价和。

对于 $L=R$ 是经典的 $(\min,+)$ 卷积快速幂，我们只需要求出 $W^L$ 就可以了。

对于 $x\in[L,R]$ 的问题，实际上就相当于求 $\sum_{i=L}^R W^i$（当然这里的广义矩阵加法定义为对应位置取 $\min$）。我们把它化成 $W^L \sum_{i=0}^{R-L} W^i$ 右边也可以通过分治的手段轻松计算。

对于这道题，事情似乎没有这么简单，因为此题的 $w_{l,r}$ 需要由 $f_{l,r,d}$ 决定，而 $f$ 又需要 $w$ 矩乘得来。这个特点令我们回想起了“半在线卷积”这个东西。

有些结构可以天然的支持半在线卷积，比如集合幂级数乘法。本题的矩阵也是如此，我们可以按照区间从小到大的顺序转移。

说了这么多还是感觉很抽象怎么办？我们可以这样理解：普通做法外层快速幂内层矩阵乘法，半在线做法外层矩乘内层做一个类似快速幂的东西。

这本质上还是一个 DP，只不过第三维从 $d$ 变成了一个类似“快速幂自动机”的东西（大家可以意会，这东西当然跟真正的自动机没什么关系）。比如说，我们可以设 $f_{l,r,t}$ 表示将 $[l,r]$ 划分成 $2^t$ 个区间的最小代价，它可以由 $f_{\times,\times,t-1}$ 的状态转移过来。也可以设 $g_{l,r,t}$ 表示划分成 $[1,2^t]$ 个区间的最小代价，可以由 $g_{\times,\times,t-1}$ 和 $f_{l,r,t}$ 转移而来。

然而我蠢了没推太清楚内层的转移，于是用了一个常数稍大的写法：直接将 $[L,R]$ 像 ST 表一样拆成两个区间 $[L,L+2^k-1],[R-2^k+1,R]$，用 $f$ 一位一位地拼出 $L-1$ 和 $R-2^k$ 再直接和 $g_{\times,\times,k}$ 拼一起，结果最后比 $O(n^4)$ 的写法优秀不了多少。如果想要完全用半在线矩乘推的可以看看 zhouhuanyi 的写法。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef unsigned int ui;
ui read(){/*...*/}
const int N=403;
const ui INF=0x5fffffff;
inline void chmn(ui &x,ui v){if(x>v) x=v;}
ui f[N][N][9],g[N][N][9],dpa[N][N][9],dpb[N][N][9],s[N];
// f -> 2^t
// g -> 1 to 2^t
int n,cl,cr;
int ac[9],ap;
int bc[9],bp;
const char NoSol[3]="0";
int main(){
	int tc=read();
	while(tc--){
		n=read();cl=read();cr=read();
		for(int i=1;i<=n;++i) s[i]=read()+s[i-1];
		if(n==1){puts("0");continue;}
		if(cl>cr){puts(NoSol);continue;}
		if(cl==1&&cr==1){puts(NoSol);continue;}
		if(cl==1) ++cl;
		if(cl==cr){
			int a=cl;
			ap=0;
			for(int t=0;t<9;++t) if(a>>t&1) ac[ap++]=t;
			for(int len=1;len<=n;++len)
				for(int l=1,r=len;r<=n;++l,++r){
					for(int t=1;t<ap;++t){
						dpa[l][r][t]=INF;
						for(int p=l;p<r;++p) chmn(dpa[l][r][t],dpa[l][p][t-1]+f[p+1][r][ac[t]]);
					}
					for(int t=1;t<9;++t){
						f[l][r][t]=INF;
						for(int p=l;p<r;++p) chmn(f[l][r][t],f[l][p][t-1]+f[p+1][r][t-1]);
					}
					f[l][r][0]=INF;
					if(l==r) f[l][r][0]=0;
					dpa[l][r][0]=f[l][r][ac[0]];
					chmn(f[l][r][0],dpa[l][r][ap-1]+s[r]-s[l-1]);
					chmn(dpa[l][r][0],f[l][r][ac[0]]);
				}
		}
		else{
			int k=__lg(cr-cl+1);
			int a=cl-1,b=cr-(1<<k);
			ap=bp=0;
			for(int t=0;t<9;++t){
				if(a>>t&1) ac[ap++]=t;
				if(b>>t&1) bc[bp++]=t;
			}
			for(int len=1;len<=n;++len)
				for(int l=1,r=len;r<=n;++l,++r){
					for(int t=1;t<ap;++t){
						dpa[l][r][t]=INF;
						for(int p=l;p<r;++p) chmn(dpa[l][r][t],dpa[l][p][t-1]+f[p+1][r][ac[t]]);
					}
					for(int t=1;t<bp;++t){
						dpb[l][r][t]=INF;
						for(int p=l;p<r;++p) chmn(dpb[l][r][t],dpb[l][p][t-1]+f[p+1][r][bc[t]]);
					}
					for(int t=1;t<9;++t){
						f[l][r][t]=INF;
						for(int p=l;p<r;++p) chmn(f[l][r][t],f[l][p][t-1]+f[p+1][r][t-1]);
					}
					f[l][r][0]=INF;
					for(int p=l;p<r;++p){
						chmn(f[l][r][0],dpa[l][p][ap-1]+g[p+1][r][k]+s[r]-s[l-1]);
						chmn(f[l][r][0],dpb[l][p][bp-1]+g[p+1][r][k]+s[r]-s[l-1]);
					}
					if(l==r) f[l][r][0]=0;
					dpa[l][r][0]=f[l][r][ac[0]];
					dpb[l][r][0]=f[l][r][bc[0]];
					g[l][r][0]=f[l][r][0];
					for(int t=1;t<=k;++t){
						g[l][r][t]=f[l][r][0];
						for(int p=l;p<r;++p) chmn(g[l][r][t],g[l][p][t-1]+g[p+1][r][t-1]);
					}
				}
		}
		if(f[1][n][0]==INF) puts(NoSol);
		else printf("%u\n",f[1][n][0]);
	}
	return 0;
}
```

---


# [BJOI2014] 路径

## 题目描述

在一个 $N$ 个节点的无向图（没有自环、重边）上，每个点都有一个符号，可能是数字，也可能是加号、减号、乘号、除号、小括号。你要在这个图上数一数，有多少种走恰好 $K$ 个节点的方法，使得路过的符号串起来能够得到一个算数表达式。路径的起点和终点可以任意选择。

所谓算数表达式，就是由运算符连接起来的一系列数字。括号可以插入在表达式中以表明运算顺序。

注意，你要处理各种情况，比如数字不能有多余的前导 $0$，减号只有前面没有运算符或数字的时候才可以当成负号，括号可以任意添加（但不能有空括号），$0$ 可以做除数（我们只考虑文法而不考虑语意），加号不能当正号。

例如，下面的是合法的表达式：
```
-0/0
((0)+(((2*3+4)+(-5)+7))+(-(2*3)*6))
```
而下面的不是合法的表达式：
```
001+0
1+2(2)
3+-3
--1
+1
()
```

## 说明/提示

$1 \le N \le 20，0 \le M \le\frac{N×(N-1)}{2}，0\le K\le 30$

![](https://cdn.luogu.com.cn/upload/pic/18714.png)

一共有 $10$ 条路径，构成的表达式依次是 ``101, (1), 1+1, 1+0, 1*1, 1*0, 0+0, 0+1, 0*0, 0*1``。

## 样例 #1

### 输入

```
6 10 3
)(1*+0
1 2
1 3
1 4
2 3
3 4
2 5
3 5
3 6
4 6
5 6```

### 输出

```
10```

# 题解

## 作者：forgotmyhandle (赞：9)

[传送门](https://www.luogu.com.cn/problem/P4580)

## 分析
可以考虑 dp。先朴素地定义 $dp[i][j]$ 表示当前在结点 $i$，已经走过了 $j$ 个结点（含当前）的方案数。发现没法处理括号匹配，于是加一维 $k$ 表示当前还剩 $k$ 个前括号没有匹配。又发现没法处理前导 $0$。于是考虑再加一维表示当前的最后一位是什么状态。

发现如果要排除掉前导 $0$ 的话，只需要知道 将要转移到我的这个状态 所在结点上的 $0$ 是不是作为一个数字的开头出现的即可。于是最后一维就可以表示这个结点上的数字是否作为首位出现。当然还要考虑当前位不是数字的情况。

于是有最终的状态：$dp[i][j][k][0/1/2]$ 表示当前在 $i$ 这个结点，已经经过了 $j$ 个结点（含当前），还剩 $k$ 个前括号没有匹配。最后一维是 $1$ 代表当前结点上的**数字**作为首位出现，是 $0$ 代表不作为首位，是 $2$ 代表这一位根本就不是数字。

接下来考虑转移（前方有大分讨，请注意）：

对于 $dp[i][j][k][0/1/2]$，我们枚举所有与 $i$ 相邻的结点 $v$ 进行转移：
1. 若 $i$ 结点上是数字：
	1. 若 $v$ 结点上是非 $0$ 数字，则将 $dp[v][j - 1][k][0] + dp[v][j - 1][k][1]$ 加到 $dp[i][j][k][0]$，因为这时我们不关心 $v$ 上的数是否作为首位；
   2. 若 $v$ 结点上是 $0$，则将 $dp[v][j - 1][k][0]$ 加到 $dp[i][j][k][0]$，因为这时若 $v$ 上的 $0$ 作首位，后面就不能接数字；
   3. 若 $v$ 结点上是运算符或**前**括号，则将 $dp[v][j - 1][k][2]$ 加到 $dp[i][j][k][1]$，因为数字前面一定可以接这两者；
   4. 由于后括号之后不接数字，所以 $v$ 上是后括号时不转移。
   
   注意，当 $v$ 上是数字时，当前位的数字就不作为首位。当 $v$ 上不是数字，则当前位的数字就必然作为首位。
2. 若 $i$ 结点上是运算符：
	1. 若 $v$ 上为数字，则将 $dp[v][j - 1][k][0] + dp[v][j - 1][k][1]$ 加过来，因为运算符前一定可以接数字；
   2. 若 $v$ 是前括号，则当且仅当 $i$ 上为减号时可以将 $dp[v][j - 1][k][2]$ 加过来，因为这时减号作负号用，而其他运算符均没有该用法；
   3. 若 $v$ 是后括号，则将 $dp[v][j - 1][k][2]$ 加过来，因为后括号后一定可以接运算符；
   4. 由于任意两运算符不能相连，于是当 $v$ 是运算符时不转移。
3. 若 $i$ 上是前括号：
	1. 当且仅当 $v$ 上是运算符或前括号时可以将 $dp[v][j - 1][k - 1][2]$ 加过来，因为只有这两者后才可以接前括号。（没说乘号可以省就不能省（确信））
    
   注意，由于多了一个未匹配的前括号，所以第三维从 $k - 1$ 转移。
4. 若 $i$ 上是后括号：
	1. 若 $v$ 上是数字，则将 $dp[v][j - 1][k + 1][0] + dp[v][j - 1][k + 1][1]$ 加过来；
   2. 若 $v$ 上是后括号，则将 $dp[v][j - 1][k + 1][2]$ 加过来；
   3. 由于运算符后不能直接加后括号，括号内又不能为空，于是 $v$ 为运算符或前括号时不转移。
   
   注意，由于这个后括号匹配了一个前括号，所以第三维从 $k + 1$ 转移。

赋初值的时候注意，当且仅当这个结点上是数字或前括号**或减号**时才能有初值。

统计答案时注意，当且仅当最后一位是后括号或数字时才可以加入答案。

## 代码
```cpp
#include <iostream>
#define int long long
using namespace std;
const int p = 1000000007;
int head[200005], nxt[400005], to[400005], ecnt;
void addE(int u, int v) { to[++ecnt] = v, nxt[ecnt] = head[u], head[u] = ecnt; }
int n, m, K;
int dp[25][35][35][3];
// currently at point i, has passed j vertices, have k front bracket left to match
// l = (0 : this digit is not the beginning, 1 : is beginning, 2 : not a digit)
bool issym(char x) { return (x == '+' || x == '-' || x == '*' || x == '/'); }
bool isbrc(char x) { return (x == '(' || x == ')'); }
inline void add(int& x, int y) { x = (x + y) % p; }
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> K;
    string str;
    cin >> str;
    str = ' ' + str;
    for (int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        addE(u, v);
        addE(v, u);
    }
    for (int i = 1; i <= n; i++) {
        if (isdigit(str[i])) 
            dp[i][1][0][1] = 1;
        else if (str[i] == '(') 
            dp[i][1][1][2] = 1;
        else if (str[i] == '-') 
            dp[i][1][0][2] = 1;
    }
    for (int j = 2; j <= K; j++) {
        for (int i = 1; i <= n; i++) {
            for (int k = (str[i] == '('); k <= K; k++) {
                for (int l = head[i]; l; l = nxt[l]) {
                    int v = to[l];    
                    if (isdigit(str[i])) {
                        if (isdigit(str[v])) 
                            add(dp[i][j][k][0], dp[v][j - 1][k][0] + (str[v] == '0' ? 0 : dp[v][j - 1][k][1]));
                        else if (issym(str[v]) || str[v] == '(') 
                            add(dp[i][j][k][1], dp[v][j - 1][k][2]);
                    } else if (issym(str[i])) {
                        if (isdigit(str[v])) 
                            add(dp[i][j][k][2], dp[v][j - 1][k][0] + dp[v][j - 1][k][1]);
                        else if (str[v] == '(') 
                            str[i] == '-' ? add(dp[i][j][k][2], dp[v][j - 1][k][2]) : void();
                        else if (str[v] == ')') 
                            add(dp[i][j][k][2], dp[v][j - 1][k][2]);
                    } else if (str[i] == '(') {
                        if (issym(str[v]) || str[v] == '(') 
                            add(dp[i][j][k][2], dp[v][j - 1][k - 1][2]);
                    } else {
                        if (isdigit(str[v])) 
                            add(dp[i][j][k][2], dp[v][j - 1][k + 1][0] + dp[v][j - 1][k + 1][1]);
                        else if (str[v] == ')') 
                            add(dp[i][j][k][2], dp[v][j - 1][k + 1][2]);
                    }
                }
                
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (isdigit(str[i])) 
            add(ans, dp[i][K][0][0] + dp[i][K][0][1]);
        else if (str[i] == ')')
            add(ans, dp[i][K][0][2]);
    }
    cout << ans;
    return 0;
}
```
关于什么情况下要赋初值：

这里的 dp 值的意义实际上是当前合法的方案数 加上 当前非法但到后面可能变得合法的方案数。显然只有一个减号或前括号都是可能变得合法的，于是有初值。又显然只有一个后括号或别的运算符都是永远也不可能变得合法的，于是就没有初值。

关于统计答案：

显然这里的非法情况只有两种；运算符缺第二个参数 和 前括号没匹配完。于是只要最后一位是数字或后括号，再加上只统计第三维是 $0$ 的情况就不会出现非法。

---

## 作者：文文殿下 (赞：5)

一道DP裸题。 
首先我们定义状态`f[i][j][k][0/1/2][0/1]` 来表示，第i个节点，长度为j,有k个未匹配的左括号，现在下一个不能加数字(0) /下一个可以加一个数字的开始(1) / 下一个可以加数字的其他位数(2),下一个是否可以加符号(0/1)。 \
转移非常显然： 
* 数字如果是以0开始，后面不能加数字，但是可以加符号，如果是以其他开始，后面既可以加数字也可以加符号。
* 符号后面既可以加数字，也可以加左括号
* 左括号后面既可以加左括号，也可以加数字
* 右括号后面只能加符号
* 负号只能在字符串最开始或者紧接着左括号放

用上面几个条件来转移。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 35,p=1000000007;
int inc(int a,int b) {
	a+=b;
	return a>=p?a-p:a;
}
int dec(int a,int b) {
	a-=b;
	return a<0?a+p:a;
}
int mul(int a,int b) {
	return 1ll*a*b%p;
}
int qpow(int a,int b) {
	int ret=1;
	while(b) {
		if(b&1) ret=mul(ret,a);
		a=mul(a,a);
		b>>=1;
	}
	return ret;
}
int f[maxn][maxn][maxn][3][2];// ver u len k with j ( and ends with num 0/1 and opt 0/1
int n,m,k;
char S[maxn];
vector<int> E[maxn];
bool isd(char ch) {
	return ch >='0'&&ch<='9';
}
bool isopt(char ch) {
	return ch == '-' || ch == '+' || ch=='*' || ch =='/' ;
}
int main() {
	scanf("%d%d%d",&n,&m,&k);
	scanf("%s",S+1);
	for(int i=1;i<=m;++i) {
		int u,v;
		scanf("%d%d",&u,&v);
		E[u].push_back(v);
		E[v].push_back(u);
	}
	for(int i=1;i<=n;++i) {
		if(isd(S[i]) ) {
			if(S[i] != '0')
				f[i][1][0][2][1] = 1;
			else f[i][1][0][0][1] = 1;
		}
		else if(S[i] == '(') f[i][1][1][1][0] = 1;
		else if(S[i] == '-') {
			f[i][1][0][1][0] = 1;
		}
	}
	for(int j = 1;j<=k;++j) {
		for(int u=1;u<=n;++u) {
			for(int c = 0;c<=k;++c) {
				for(auto nx : E[u]) {
					int k = j;
					if(isd(S[nx]) ) {
						if(S[nx] != '0') {
							f[nx][k+1][c][2][1] = inc(f[nx][k+1][c][2][1],f[u][k][c][1][1]);
							f[nx][k+1][c][2][1] = inc(f[nx][k+1][c][2][1],f[u][k][c][1][0]);
						}
						f[nx][k+1][c][2][1] = inc(f[nx][k+1][c][2][1],f[u][k][c][2][1]);
						f[nx][k+1][c][2][1] = inc(f[nx][k+1][c][2][1],f[u][k][c][2][0]);
						if(S[nx] == '0') {
							f[nx][k+1][c][0][1] = inc(f[nx][k+1][c][0][1],f[u][k][c][1][1]);
							f[nx][k+1][c][0][1] = inc(f[nx][k+1][c][0][1],f[u][k][c][1][0]);
						}
					}
					else if(isopt(S[nx])) {
						f[nx][k+1][c][1][0] = inc(f[nx][k+1][c][1][0],f[u][k][c][0][1]);
						f[nx][k+1][c][1][0] = inc(f[nx][k+1][c][1][0],f[u][k][c][1][1]);
						f[nx][k+1][c][1][0] = inc(f[nx][k+1][c][1][0],f[u][k][c][2][1]);
						if(S[nx] == '-') {
							if(S[u] == '(') {
								f[nx][k+1][c][1][0] = inc(f[nx][k+1][c][1][0],f[u][k][c][1][0]);
							}
						}
					}
					else if(S[nx] == '(') {
						f[nx][k+1][c+1][1][0] = inc(f[nx][k+1][c+1][1][0],f[u][k][c][1][0]);
					} else {
						assert(S[nx] == ')');
						if(c > 0 ) {
							f[nx][k+1][c-1][0][1] =inc(f[nx][k+1][c-1][0][1],f[u][k][c][2][1]);
							f[nx][k+1][c-1][0][1] =inc(f[nx][k+1][c-1][0][1],f[u][k][c][0][1]);
						}
					}
				}
			}
		}
	}
	int ans = 0;
	for(int i=1;i<=n;++i) {
		ans = inc(ans,f[i][k][0][0][1]);
		ans = inc(ans,f[i][k][0][1][1]);
		ans = inc(ans,f[i][k][0][2][1]);
	}
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：FQR_ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P4580)

## 思路

由于变量名冲突，题目中的步数 $k$ 会在接下来用 $t$ 表示。

首先考虑 DP。$f_{i,j,k,l}$ 表示经过 $i$ 个点，当前节点为 $j$，还剩 $k$ 个左括号没被匹配，最后一个符号的种类为 $l$ 的方案数。

前三维容易理解，第四维 $l$ 有五种取值：

- $l=0$：最后一个符号为 `(`；
- $l=1$：最后一个符号为 `)`；
- $l=2$：最后一个符号为 `+-*/`；
- $l=3$：最后一个符号为 `0`，且倒数第二个符号不是数字或不存在；
- $l=4$：最后一个符号为数字，且不属于 $l=3$ 的情况。

接下来对以上五种情况逐个分析，考虑每种情况后面可以接什么符号：

- $l=0$：接数字、`(` 或 `-`（这里用作负号）。
- $l=1$：接 `+-*/` 或 `)`。
- $l=2$：接数字或 `(`。
- $l=3$：接 `+-*/` 或 `)`。注意此处不能接数字，否则会产生前导 0。
- $l=4$：接数字、`+-*/` 或 `)`。

于是四层循环枚举 $i,j,k,l$，然后枚举 $j$ 能通向的所有点 $p$，把 $f_{i,j,k,l}$ 按以上情况转移到 $f_{i+1,p}$ 即可。

统计答案时，发现只有 $l=1,3,4$ 时能结束。于是将所有的 $f_{t,j,0,1/3/4}$ 加起来即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define up(s,e,i) for(int i=s;i<=e;i++)
#define down(s,e,i) for(int i=s;i>=e;i--) 
#define endl '\n' 

#define num(x) (x>='0'&&x<='9')
#define pos(x) (x>='1'&&x<='9')
#define fh(x) (x=='+'||x=='-'||x=='*'||x=='/')

namespace Main
{
    const int N = 35, mod = 1000000007;
    int n, m, t;
    string s;
    vector<int> g[N];
    int f[N][N][N][5];

    void main()
    {
        ios::sync_with_stdio(0);
        cin.tie(0);cout.tie(0);
        cin >> n >> m >> t >> s;
        s = " " + s;
        up(1, m, i)
        {
            int x, y;
            cin >> x >> y;
            g[x].push_back(y);
            g[y].push_back(x);
        }
        up(1, n, i)
        {
            if(pos(s[i])) f[1][i][0][4] = 1;
            else if(s[i] == '0') f[1][i][0][3] = 1;
            else if(s[i] == '(') f[1][i][1][0] = 1;
            else if(s[i] == '-') f[1][i][0][2] = 1;
        }
        up(1, t - 1, i) up(1, n, j) up(0, n, k) up(0, 4, l) 
        {
            if(!f[i][j][k][l]) continue;
            for(auto p : g[j])
            {
                if(l == 0)
                {
                    if(pos(s[p]))
                    {
                        (f[i + 1][p][k][4] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == '0')
                    {
                        (f[i + 1][p][k][3] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == '-')
                    {
                        (f[i + 1][p][k][2] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == '(')
                    {
                        (f[i + 1][p][k + 1][0] += f[i][j][k][l]) %= mod;
                    }
                }
                else if(l == 1)
                {
                    if(fh(s[p]))
                    {
                        (f[i + 1][p][k][2] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == ')')
                    {
                        if(k)
                            (f[i + 1][p][k - 1][1] += f[i][j][k][l]) %= mod;
                    }
                }
                else if(l == 2)
                {
                    if(pos(s[p])) 
                    {
                        (f[i + 1][p][k][4] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == '0')
                    {
                        (f[i + 1][p][k][3] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == '(')
                    {
                        (f[i + 1][p][k + 1][0] += f[i][j][k][l]) %= mod;
                    }
                }
                else if(l == 3)
                {
                    if(fh(s[p]))
                    {
                        (f[i + 1][p][k][2] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == ')')
                    {
                        if(k) (f[i + 1][p][k - 1][1] += f[i][j][k][l]) %= mod;
                    }
                }
                else if(l == 4)
                {
                    if(num(s[p]))
                    {
                        (f[i + 1][p][k][4] += f[i][j][k][l]) %= mod;
                    }
                    else if(fh(s[p]))
                    {
                        (f[i + 1][p][k][2] += f[i][j][k][l]) %= mod;
                    }
                    else if(s[p] == ')')
                    {
                        if(k) (f[i + 1][p][k - 1][1] += f[i][j][k][l]) %= mod;
                    }
                }
            }
        }
        int ans = 0;
        up(1, n, i) (ans += ((f[t][i][0][1] + f[t][i][0][3]) % mod + f[t][i][0][4]) % mod) %= mod;
        cout << ans;
    }
};

int main()
{
    Main::main();
    return 0;
}
```

---

## 作者：farfarqwq (赞：1)

## 前言
一道好玩的 dp 题，本蒟蒻在一个数组上被卡了 3 天T_T。
## 正题
考虑 dp 状态：$dp_{u,j,k,l}$ 表示当前节点 $u$，已经走了 $j$ 步，有 $k$ 个左括号未匹配，$l$ 表示如果当前是数字，有没有前导 0。

这道题用递推比较难懂，所以我们用记忆化搜索大法，是这样转移的：

设当前点为 $u$，接下来要走的节点为 $v$。

- 当 $v$ 是数字：

1. 如果 $u$ 也是数字，且没有前导零，则 $ans$ 加上 $dp_{u,j+1,k,0}$。
1. 如果 $u$ 是左括号或运算符，定义 $f$ 等于 $v$ 是否为 $0$，则 $ans$ 加上 $dp_{v,j+1,k,f}$。

- 当 $v$ 是左括号：

  如果 $u$ 是运算符或左括号，则 $ans$ 加上 $dp_{v,j+1,k+1,0}$。

- 当 $v$ 是右括号：

  如果 $u$ 是数字或右括号并且 $k>0$，则 $ans$ 加上 $dp_{v,j+1,k-1,0}$。

- 当 $v$ 是运算符：

1. 如果 $u$ 是数字或右括号，则 $ans$ 加上 $dp_{v,j+1,k,0}$。
1. 特殊情况，如果 $v$ 是减号（负号）并且 $u$ 是左括号，$ans$ 还是加上 $dp_{v,j+1,k,0}$。

最后把 $dp_{u,j,k,l}$ 赋值为 $ans$。

最终答案：

对于每个点 $i$，以它们作为起点的答案之和。

这些点分别有以下 3 种情况：

1. $i$ 为左括号，答案加上 $dp_{i,1,1,0}$。
1. $i$ 为数字，答案加上 $dp_{i,1,0,f}$，$f$ 还是老样子。
1. $i$ 为减号，答案加上 $dp_{i,1,0,0}$。

其他细节：
- 每次加完要对 $10^9+7$ 取模
- dp 数组要开大一点，把握不住就开到 $40$。
- 小数据采用邻接矩阵更方便。
- 一定要注意每个细节，特别是在搜索时，写错一个就会BBQ。

最后贴上我的代码：
```cpp
#include <iostream>
using namespace std;
const int mod = 1000000007;
int n, m, k;
long long dp[25][35][35][2];//个人习惯，开了个long long，不开也应该能过
int g[25][25];
char s[40];
bool isnum(char c) {
	return '0' <= c && c <= '9';
}//判断是否为数字
bool isop(char c) {
	return c == '+' || c == '-' || c == '*' || c == '/';
}//判断是否为运算符
long long dfs(int u, int step, int l, int hz) {//关键：记忆化搜索
	if (dp[u][step][l][hz] >= 0)
		return dp[u][step][l][hz];
	long long ans = 0;
	if (step == k) {
		if (!l && !isop(s[u]))
			return dp[u][step][l][hz] = 1;
		else
			return dp[u][step][l][hz] = 0;
	}
	for (int i = 0; i < n; i++)
		if (g[u][i]) {
			if (isnum(s[i])) {
				if (isnum(s[u]) && !hz)
					ans = (ans + dfs(i, step + 1, l, 0)) % mod;
				else if (isop(s[u]) || s[u] == '(')
					ans = (ans + dfs(i, step + 1, l, s[i] == '0')) % mod;
			} else if (s[i] == '(') {
				if (isop(s[u]) || s[u] == '(')
					ans = (ans + dfs(i, step + 1, l + 1, 0)) % mod;
			} else if (s[i] == ')') {
				if (l > 0 && (isnum(s[u]) || s[u] == ')'))
					ans = (ans + dfs(i, step + 1, l - 1, 0)) % mod;
			} else if (isop(s[i])) {
                if(isnum(s[u]))
					ans = (ans + dfs(i, step + 1, l, 0)) % mod;
                if(s[u] == ')' || (s[u] == '(' && s[i] == '-'))
					ans = (ans + dfs(i, step + 1, l, 0)) % mod;
			}
		}
	return dp[u][step][l][hz] = ans % mod;
}
signed main() {
	cin >> n >> m >> k;
	cin >> s;
	int u, v;
	long long ans = 0;
	memset(dp, -1, sizeof(dp));//初始化
	for (int i = 1; i <= m; i++) {
		cin >> u >> v;
		--u;
		--v;
		g[u][v] = g[v][u] = 1;
	}
	for (int i = 0; i < n; i++) {
		if (s[i] == '(')
			ans = (ans + dfs(i, 1, 1, 0)) % mod;
		else if (s[i] == '-')
			ans = (ans + dfs(i, 1, 0, 0)) % mod;
		else if (isnum(s[i]))
			ans = (ans + dfs(i, 1, 0, s[i] == '0')) % mod;
	}
	cout << ans;//输出答案
	return 0;
}
```
抄袭没好下场呦！

---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

更多相关（或者不相关）知识点快戳：[oi-beats](https://entiesci.github.io/oi-beats/site/)，[个人博客](https://ntsc.flowus.cn/)。

## 做法

dp。看似简单，实则特细节。

令 $op(i)$ 为点 $i$ 处的字符。

定义 $f_{i,j,l,zr}$ 为当前走了 $i$ 步，在点 $j$，
此前缀的未匹配左括号的个数为 $l$，$op(j)$ 如果为 $0$ 
则 $j$ 是否为**非前导零**时的方案数。解释一下 $zr$：如果 $op(j)$ 为 $0$，则 $zr$ 为 $0$ 或者 $1$ 时都有值，否则只用得到 $zr=0$ 时的 $f$ 值。

那么自然是枚举 $i,j$ 和 $j$ 的邻居 $v$，再枚举 $l$，考虑是否可以转移了。如果可以转移，那么就是 $f_{i,j,\dots}←f_{i,j,\dots}+f_{i-1,v,\dots}$。

重点在于如何判断是否可以转移。我们写一个 `check(a,b)`，其中 $a,b$ 分别是 $op(v),op(j)$。就是要判断 $a,b$ 两个字符是否可以靠在一起。

我们将所有可能的字符都映射为数字，这样好判断一些。特别的，对于 $0$，如果其不是前导零，那么我们映射为 $10$。

```C++
    0(前导),1~9   ->  0~9
    0(非前导)     ->  10
    +-*\          ->  11~14
    ()            ->  15~16
```


所有可行的情况如下，在注释中解释。标记 `!` 的需要注意。

```C++
    if(zr&&a==0)a=10; //zr,zi分别代表op(v),op(j)是否是前导零，这个是枚举来的，如果op(j)是0，那么zi={0,1}，否则zi={0}。zr同。
    if(zi&&b==0)b=10;
    if(b<=10&&b>0&&a>=1&&a<=10)return 1;//数字接数字。注意数字+前导0不合法。
    if(b<=9&&a>=11&&a<=15)return 1;//运算符+数字，注意运算符+前导0不合法。
    if(b>=11&&b<=14&&a<=10)return 1;//数字+运算符
    if(b>=11&&b<=14&&a==16)return 1;//! ）+运算符
    if(b==12&&a==15)return 1;//! 负号+（
    if(b==15&&a>=11&&a<=14)return 1;//运算符+（
    if(b==15&&a==15)return 1;//! （（
    if(b==16&&a<=10)return 1;//数字+）
    if(b==16&&a==16)return 1;//! ））
    return 0;
```


注意这里我们只是判断两个字符是否可以相邻。还需要的判断是：括号序列应该合法（即若 $op(j)$ 为)，那么 $l$ 应该大于 $0$）。在统计答案时，应当判断当前序列是否合法，此时只需要判断这个序列的最后一个字符是否可以作为一个合法序列的末尾即可。

```C++
/*  Erica N  */
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define ps second
#define pf first
#define itn int

#define rd read()
int read(){
    int xx = 0, ff = 1;char ch = getchar();
    while (ch < '0' || ch > '9') {if (ch == '-')ff = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9')xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}

#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() { cerr << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cerr << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cerr << a << ' '; err(x...); }


const int N = 3e1 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1000000007;

int f[405][N][33][2];//当前走了i步，在点j，
//此前缀的未匹配左括号的个数为l，j如果为0
//则j是否非前导0 时的方案数
map<char,int> id;
vector<int> e[N];
int p[N];
void add(itn a,int b){
    e[a].pb(b);
    e[b].pb(a);
}
string s;

bool able(int a,int b,int zr,int zi){
    if(zr&&a==0)a=10;
    if(zi&&b==0)b=10;
    if(b<=10&&b>0&&a>=1&&a<=10)return 1;
    if(b<=9&&a>=11&&a<=15)return 1;
    if(b>=11&&b<=14&&a<=10)return 1;
    if(b>=11&&b<=14&&a==16)return 1;//!
    if(b==12&&a==15)return 1;//!
    if(b==15&&a>=11&&a<=14)return 1;
    if(b==15&&a==15)return 1;//！
    if(b==16&&a<=10)return 1;
    if(b==16&&a==16)return 1;//！
    return 0;
}

void solve(){
    int n=rd,m=rd,K=rd;
    cin>>s;
    s=" "+s;
    for(int i=1;i<=m;i++){
        add(rd,rd);
    }

    for(int i=0;i<=9;i++){
        id['0'+i]=i;
    }
    id['+']=11;
    id['-']=12;
    id['*']=13;
    id['/']=14;
    id['(']=15;
    id[')']=16;

    /*
    0~9 ->  0~9
    ~0  ->  10
    +-*\->  11~14
    ()  ->  15,16
    
    */

   for(int i=1;i<=n;i++){
        p[i]=id[s[i]];
   }

   for(int i=1;i<=n;i++){
        if(p[i]<=10||p[i]==12)f[1][i][0][0]=1;
        if(p[i]==15)f[1][i][1][0]=1;
   }

    for(int i=1;i<=K;i++){
        for(int j=1;j<=n;j++){
            for(int l=0;l<=i;l++){
                for(auto v:e[j]){
                    for(int zrj=0;zrj<=(p[v]==0);zrj++){
                    for(int zri=0;zri<=(p[j]==0);zri++){
                        if(!able(p[v],p[j],zrj,zri))continue;
                        if(p[j]==16)f[i][j][l][zri]+=f[i-1][v][l+1][zrj];
                        else if(p[j]==15){
                            if(l>0)f[i][j][l][zri]+=f[i-1][v][l-1][zrj];
                        }
                        else f[i][j][l][zri]+=f[i-1][v][l][zrj];
                        f[i][j][l][zri]%=MOD;
                    }}
                }
            }
        }
    }

    int ans=0;

    for(int i=1;i<=n;i++){
        if(p[i]<11||p[i]==16){
            (ans+=f[K][i][0][0])%=MOD;
            (ans+=f[K][i][0][1])%=MOD;
        }
    }

    cout<<ans<<endl;
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);

    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

---

## 作者：huangrenheluogu (赞：0)

感觉很签到。只要不被很小的数据范围带到指数算法感觉就可以写出来。

考虑合法路径的要求。括号符合要求，其次还需要运算符前面不是括号、没有前导 $0$、左右括号之间要有东西等要求。按照要求设置状态，$f_{i,x,d,o}$ 表示走了 $i$ 步，所在点的编号为 $x$，括号深度为 $d$，上一位的状态是 $o$。其中 $o=0,1,2,3,4$ 分别对应上一位的状态是运算符、左括号、右括号、$0$、非 $0$ 的数字。解释以下为什么减号（负号）和其他符号可以合并，主要原因是减号（负号）和其他符号后面跟的东西是一样的。

初始状态是简单的，开始只可能是减号（负号）、左括号、$0$ 或者其他数字。

转移也是简单的，以运算符后可以接的东西为例。可以接左括号、$0$ 或者非 $0$ 数字。判断转移即可。

注意 $n,k$ 是不同的，数组不要开错了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 25, mod = 1e9 + 7;
int n, m, k, ans;
int u, v, f[35][N][35][5];//+*/-, (, ), 0, number
char s[N];
vector<int> G[N];
inline void addedge(int x, int y){
    G[x].push_back(y);
}
inline void add(int &x, int y){
    x += y;
    if(x >= mod) x -= mod;
}
int main(){
    // freopen("data.in", "r", stdin);
    // freopen("code.out", "w", stdout);
    scanf("%d%d%d%s", &n, &m, &k, s + 1);
    while(m--){
        scanf("%d%d", &u, &v);
        addedge(u, v), addedge(v, u);
    }
    for(int i = 1; i <= n; i++){
        if(s[i] == '('){
            f[1][i][1][1] = 1;
        }
        if(s[i] == '0'){
            f[1][i][0][3] = 1;
        }
        if('1' <= s[i] && s[i] <= '9'){
            f[1][i][0][4] = 1;
        }
        if(s[i] == '-'){
            f[1][i][0][0] = 1;
        }
    }
    for(int i = 1; i < k; i++){
        for(int x = 1; x <= n; x++){
            for(int d = 0; d <= i; d++){
                // for(int o = 0; o < 5; o++){
                //     if(f[i][x][d][o]){
                //         printf("f[%d][%d][%d][%d] = %d\n", i, x, d, o, f[i][x][d][o]);
                //     }
                // }
                for(int y : G[x]){
                    if(s[y] == '('){
                        add(f[i + 1][y][d + 1][1], f[i][x][d][0]);
                    }
                    if(s[y] == '0'){
                        add(f[i + 1][y][d][3], f[i][x][d][0]);
                    }
                    if('1' <= s[y] && s[y] <= '9'){
                        add(f[i + 1][y][d][4], f[i][x][d][0]);
                    }

                    if(s[y] == '-'){
                        add(f[i + 1][y][d][0], f[i][x][d][1]);
                    }
                    if(s[y] == '('){
                        add(f[i + 1][y][d + 1][1], f[i][x][d][1]);
                    }
                    if(s[y] == '0'){
                        add(f[i + 1][y][d][3], f[i][x][d][1]);
                    }
                    if('1' <= s[y] && s[y] <= '9'){
                        add(f[i + 1][y][d][4], f[i][x][d][1]);
                    }

                    if(s[y] == '+' || s[y] == '-' || s[y] == '*' || s[y] == '/'){
                        add(f[i + 1][y][d][0], f[i][x][d][2]);
                    }
                    if(d && s[y] == ')'){
                        add(f[i + 1][y][d - 1][2], f[i][x][d][2]);
                    }

                    if(s[y] == '+' || s[y] == '-' || s[y] == '*' || s[y] == '/'){
                        add(f[i + 1][y][d][0], f[i][x][d][3]);
                    }
                    if(d && s[y] == ')'){
                        add(f[i + 1][y][d - 1][2], f[i][x][d][3]);
                    }

                    if(s[y] == '+' || s[y] == '-' || s[y] == '*' || s[y] == '/'){
                        add(f[i + 1][y][d][0], f[i][x][d][4]);
                    }
                    if('0' <= s[y] && s[y] <= '9'){
                        add(f[i + 1][y][d][4], f[i][x][d][4]);
                    }
                    if(d && s[y] == ')'){
                        add(f[i + 1][y][d - 1][2], f[i][x][d][4]);
                    }
                }
            }
        }
    }
    for(int i = 1; i <= n; i++){
        for(int o = 1; o < 5; o++){
            // printf("f[%d][%d][%d][%d] = %d\n", k, i, 0, o, f[k][i][0][o]);
            add(ans, f[k][i][0][o]);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---


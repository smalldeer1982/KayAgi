# [BJWC2008] 序列

## 题目描述

对一个长度为$N$的序列$\{a_n\}(a_i\in[0,2^{16}-1])$，进行如下两种，共计$M$个操作：

1. `A x`$(x\ge0)$：$a_i=a_i+x\mod2^{16}$

2. `Q i`：询问$Card\{k\mid(a_k\;\&\;2^i)>0,1\le k\le N,k\in\mathbb{Z}\}$的结果

其中$\&$运算符为相当于C/C++中的`&`或Pascal中的`and`

给定初始序列和操作序列，请你模拟操作过程，并计算所有$Q$操作的相应的结果的和。

## 说明/提示

初始序列为$1\;2\;4$

`Q 1`：仅$a_2=2$满足$(a_k\;\&\;2^i)>0$，该$Q$操作的结果为$1$

`Q 2`：仅$a_3=4$满足$(a_k\;\&\;2^i)>0$，该$Q$操作的结果为$1$

`A 1`：原序列变为$2\;3\;5$

`Q 1`：仅$a_1=2,a_2=3$满足$(a_k\;\&\;2^i)>0$，该$Q$操作的结果为$2$

`Q 2`：仅$a_3=5$满足$(a_k\;\&\;2^i)>0$，该$Q$操作的结果为$1$

$1+1+2+1=5$，所以最终结果为5

$30\%$的数据满足$1\le N\le100,1\le M\le1000$

$100\%$的数据满足$1\le N,M\le10^5$

## 样例 #1

### 输入

```
3 5
1
2
4
Q 1
Q 2
A 1
Q 1
Q 2```

### 输出

```
5```

# 题解

## 作者：123456zmy (赞：4)

题意：  
给你一个序列，支持全局加及查询二进制某位为 $1$ 的数的个数，序列中的数对 $65536$ 取模。
___
设序列中的数的值域为 $v$。
___
注意到操作都是全局的，所以序列中的数可以开桶来存，全局加也可以用标记解决。

对于查询，需要计入答案的数的区间是 $[k\cdot2^{i+1}+2^i,(k+1)\cdot2^{i+1})$，暴力 $O(mv)$。~~加个指令集就可以过了，[代码](https://www.luogu.com.cn/paste/3ot5sjt3)。~~

通过观察发现其答案只与加上的数的和的后 $i$ 位有关，用前缀和及记忆化优化后可以通过此题。~~可以卡到最优解~~。

AC代码：（$O(n+v\log v),191ms$）
```cpp
#include<bits/stdc++.h>
int n,m,a2;
char c;
unsigned short p,x;
int sum[131088],cnt[131088],ans[17][65537];
bool vis[17][65537];
int main()
{
	register long long anss=0;
	register unsigned short p=0;
	scanf("%d%d",&n,&m); 
	for(int i=0;i<n;i++)scanf("%d",&a2),++cnt[a2],++cnt[a2+65536];
	sum[0]=cnt[0];
	for(int i=1;i<131088;i++)sum[i]=sum[i-1]+cnt[i];
	while(m--)
	{
		scanf("%s%d",&c,&x);
		if(c=='A')p+=x;
		else
		{
			if(vis[x][p&((2<<x)-1)])anss+=ans[x][p&((2<<x)-1)];
			else
			{
				register int ansa=0;
				for(register int i=(2<<x)-1;i<65536;i+=2<<x)ansa+=sum[65536-p+i]-sum[65536-p+i-(1<<x)];
				vis[x][p&((2<<x)-1)]=1,anss+=(ans[x][p&((2<<x)-1)]=ansa);
			}
		}
	}
	printf("%lld",anss);
	return 0;
}
```

---

## 作者：zl_just (赞：4)

极其玄学的题目,好像没几个人通过,那我就讲下我的思路吧,看了下通过的巨佬的$Code$,好像没人和我一样,以下为毒瘤做法,~~好孩子不要学习~~

---
### 一

首先,一个数二进制第$i$为$1$的话,那么它肯定大于$2^{i}$,那它有没有上界呢,~~好像没有~~,不用怕,没有上界我们也要创造上界,我们把它模上$2^{i+1}$，那它不就有上界了嘛,所以分别$mod$ $2$,$4$,$8$...  
我们可以建$16$颗权值线段树或平衡树查找区间$[2^{i},2^{i+1})$中数的个数  

## 二
关键这题还有个修改操作,  
因为$a+x$属于$[2^{i},2^{i+1})$,所以$a$属于$[2^{i}-x,2^{i+1}-x)$,  
可还是有取模呢? 

我们大胆猜测$a$属于$[2^{i}-x(mod$ $2^{i+1}),2^{i+1}-x(mod$ $2^{i+1}))$  
~~大家自己手玩一下也能推得出来~~，$OI$~~界不需要证明~~  

可左边界还有可能是负的呢?  
~~没关系，继续大胆猜测~~  
令$l=2^{i}-x(mod$ $2^{i+1})$,$r=2^{i+1}-x(mod$ $2^{i+1})-1$,$nr=2^{i+1}-1$  
那此时$a$应属于$[0,r]$并上$[nr+l+1,nr]$  
如果不懂的话就把它想象成一个环吧

**关键还是分析，代码相信大家都能写出了，这种分析比较不容易的懂,建议大家自己去推，去手算**  
毒瘤$Code$
```cpp
#include<cstdio>
namespace IO {

    template<typename T>
    T read(T& a) {
        int c;
        while((a=getchar()-'0')) if(a>0&&a<=9) break;
        while((c=getchar())) {
            if(c<'0'||c>'9') return a;
            a=a*10+c-'0';
        }
        return a;
     }

    inline char get() { int c; while((c=getchar())) if(c=='A'||c=='Q') return c; }
}

class SegmentTree {
    static const int maxn = 1<<18;
    int s[maxn],lc[maxn],rc[maxn];
    int size;

    public:
    int root[20];

    void build(int o,int L,int R) {
        s[o]=lc[o]=rc[o]=0;
        if(L==R) return ;
        int mid=(L+R)>>1;
        rc[o]=(lc[o]=size)+1,size+=2;
        build(lc[o],L,mid);
        build(rc[o],mid+1,R);
    }

    SegmentTree() {
        size=0;
        for(int i=0;i<=15;++i)
            build(root[i]=size++,0,(1<<(i+1))-1);
    }

    void insert(int o,int L,int R,int x) {
        if(L==R) s[o]++;
        else {
            int mid=(L+R)>>1;
            if(x<=mid) insert(lc[o],L,mid,x);
            else insert(rc[o],mid+1,R,x);
            s[o]=s[lc[o]]+s[rc[o]];
        }
    }

    int query(int o,int L,int R,int l,int r) {
        if(l<=L&&r>=R) return s[o];
        int mid=(L+R)>>1,res=0;
        if(l<=mid) res=query(lc[o],L,mid,l,r);
        if(r>mid) res+=query(rc[o],mid+1,R,l,r);
        return res;
    }
/*
    void Debug(int o,int L,int R){
        printf("L %d R %d s %d\n",L,R,s[o]);
        if(L==R) return ;
        int mid=(L+R)>>1;
        Debug(lc[o],L,mid);
        Debug(rc[o],mid+1,R);
    }
*/
}t;
int n,m,a;
long long ans;
using namespace IO;

#define Mod(x,i) ((x)%(1<<(i)))

int main() {
    int x;
    read(n); read(m);
    for(register int i=0;i<n;++i) {
        read(x);
        for(int j=0;j<=15;++j) {
            int k=Mod(x,j+1);
            t.insert(t.root[j],0,(1<<(j+1))-1,k);
        }
    }
    while(m--) {
        if(get()=='A') read(x),a+=x,a=Mod(a,16);
        else {
            read(x);
            if(x>=16) continue;
            int k=Mod(a,x+1),l=(1<<x)-k,r=(1<<(x+1))-k-1;
            if(l<0) {
                int nr=(1<<(x+1))-1;
                ans+=t.query(t.root[x],0,nr,nr+l+1,nr);
                l=0;
            }
            ans+=t.query(t.root[x],0,(1<<(x+1))-1,l,r);
        }
    }
    return !printf("%lld\n",ans);
}

```

---

## 作者：不存在之人 (赞：1)

首先观察到是全局加，可用变量X表示。 

然后对于依次询问，大力转移一法询问范围。 

然后随便用一下线段树就OK辣。
```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define N 65535
using namespace std;
char s[10];
int n,m,x,t,X,l,r,mo;
int v[16][270000];
long long ans; 
void change(int K,int k,int l,int r,int p)
{
    v[K][k]++;
    if (l==r) return;
    int mid=(l+r)/2;
    if (p<=mid) change(K,k*2,l,mid,p);
    else change(K,k*2+1,mid+1,r,p);
}
int ask(int K,int k,int l,int r,int x,int y)
{
    if (l==x&&r==y) return v[K][k];
    int mid=(l+r)/2;
    if (y<=mid) return ask(K,k*2,l,mid,x,y);
    if (x>mid) return ask(K,k*2+1,mid+1,r,x,y);
    return ask(K,k*2,l,mid,x,mid)+ask(K,k*2+1,mid+1,r,mid+1,y);
}
int main()
{
    scanf("%d%d",&n,&m);
    while (n--)
    {
        scanf("%d",&x);
        t=0;
        for (int i=0;i<16;i++)
        {
            t+=x&(1<<i);
            change(i,1,0,N,t);
        }
    }
    while (m--)
    {
        scanf("%s",s);
        if (s[0]=='A')
        {
            scanf("%d",&x);
            X+=x;
        }
        if (s[0]=='Q')
        {
            scanf("%d",&x);
            if (x>=16)
            {
                puts("0");
                continue;
            }
            l=1<<x; r=l*2-1; mo=r+1;
            l=(l-X%mo+mo)%mo;
            r=(r-X%mo+mo)%mo;
            if (l<=r) ans+=ask(x,1,0,N,l,r);
            else ans+=ask(x,1,0,N,l,N)+ask(x,1,0,N,0,r);
        }
    }
    printf("%lld",ans);
}
```

---


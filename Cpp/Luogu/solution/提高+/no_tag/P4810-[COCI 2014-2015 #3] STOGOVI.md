# [COCI 2014/2015 #3] STOGOVI

## 题目描述

 **译自 [COCI 2014/2015 Contest 3](http://www.hsin.hr/coci/archive/2014_2015/) T5「STOGOVI」**

Mirko 正在玩栈。游戏开始时，他有一个编号为 $0$ 的空栈。在游戏中的第 $i$ 步，他会选择一个存在的编号为 $v$ 的栈，将它复制一份并进行以下其中一种操作：

 1. 将数字 $i$ 加入新栈的顶部。

 2. 将新栈顶部的数字删除。

 3. 选择另外一个编号为 $w$ 的栈，并统计有多少个不同的数同时存在于新栈与栈 $w$ 中。

新创建的栈编号为 $i$。

Mirko 不喜欢自己用栈模拟这个过程，所以他想要你替他写一个程序来执行这个过程。对于每个删除操作输出删除的数，且对于每个统计操作，输出统计的结果。

## 说明/提示

#### 样例解释 1

开始时，我们有栈 $S_0 = \{\}$。

第一步，我们复制 $S_0$ 并将数字 $1$ 加入到顶部，$S_1 = \{1\}$。

第二步，我们复制 $S_1$ 并将数字 $2$ 加入到顶部，$S_2 = \{1,2\}$。

第三步，我们复制 $S_2$ 并删除数字，$2$，$S_3 = \{1\}$。

第四步，我们复制 $S_2$ 并编号为 $S_4$，统计有多少个不同的数同时存在于 $S_4$ 与 $S_3$ 中。唯一同时存在于两个栈中的数是 $1$，所以答案为 $1$。

第五步，我们复制 $S_4$ 并删除数字，$2$，$S_5 = \{1\}$。


## 样例 #1

### 输入

```
5
a 0
a 1
b 2
c 2 3
b 4```

### 输出

```
2
1
2```

## 样例 #2

### 输入

```
11
a 0
a 1
a 2
a 3
a 2
c 4 5
a 5
a 6
c 8 7
b 8
b 8```

### 输出

```
2
2
8
8```

# 题解

## 作者：TonviaSzt (赞：4)

**题目大意**

开始时有一个编号为 0 的空栈。第 $i$ 步选择一个栈 $v$，将它复制一份到栈 $i$ 并进行以下其中一种操作：

>a.将数字 $i$ 加入新栈的顶部。
>
>b.将新栈顶部的数字删除。
>
>c.选择另外一个编号为 $w$ 的栈，并统计有多少个相同的数同时存在于新栈与栈 $w$ 中。

**思路分析**

一眼可持久化类的题目，但是可持久化数据结构我已经忘光了。

可持久化的题显然不能将每种状态都记录下来，可以考虑将所有状态集中到一棵树上，每个分支可以看作不同状态的延伸。这样做的好处是每次新增状态的本质就是原树节点或原树节点的简单延伸。

回归本题，使用树的方法做达到可持久化的效果：

我们维护每个栈栈顶的元素 $top_i$，对于 $a$ 操作，即原树新增节点，且父亲节点为 $top_v$；

对于 $b$ 操作 ，直接将 $top_i$ 赋值为 $top_v$ 的父节点即可；

对于c操作，先令 $top_i=top_v$，由于每个元素互不相同且树只会向下简单延伸的性质，两栈相同数的个数即为 $top_i$ 与 $top_w$ 节点的 LCA 深度，倍增维护即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,a[N],dep[N],f[N][20];
char op[2];
inline int Rd(){
	int s=0,w=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s*w;
}
int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;~i;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=19;~i;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
int main(){
	freopen("stack.in","r",stdin);
	freopen("stack.out","w",stdout);
	n=Rd();
	for(int i=1;i<=n;i++){
		scanf("%s",op);
		if(*op=='a'){
			int v=Rd();
			a[i]=i;dep[i]=dep[a[v]]+1;
			f[i][0]=a[v];
			for(int j=1;j<20;j++) f[i][j]=f[f[i][j-1]][j-1];
		}else if(*op=='b'){
			int v=Rd();
			a[i]=f[a[v]][0];
			printf("%d\n",a[v]);
		}else{
			int v=Rd(),w=Rd();
			a[i]=a[v];
			printf("%d\n",dep[LCA(a[i],a[w])]);
		}
	}
}
```

---

## 作者：TLEWA (赞：3)

## 注意！本篇题解不是解决本题的正常做法，如为学习本题优秀解法，不建议观看此题解。

建图的 trick 别的题解已经讲得够多了，在此不在赘述。不过我并没有想到将删除操作指向父亲的方法，而是将其也加入了所建的树当中，从而得到了一份可能和其他人都不同的解题代码，而且似乎能够支持更多操作。下面来介绍一下我的做法：

由于我们将删除操作保留了下来，我们查询的答案显然不是两点间 LCA 的深度这么简单了，注意到两点到 LCA 的路径上显然不会增加贡献，而由于删除操作的存在，一旦删除 LCA 到根路径上的节点。则贡献 -1，类似其他题解的做法，我们也需要统计 LCA 的深度，并需要额外计算删除所产生的负贡献，不难想到使用数链剖分维护。但是简单统计删除操作的数量并不能得到答案，我们考虑维护不产生贡献的插入操作数量，在线段树的 pushup 中维护出删除产生贡献的插入操作的数量，对应我的代码如下：


```cpp
node merge(node a,node b) {
	node c={max(a.save-b.del,0)+b.save,a.del+max(b.del-a.save,0)};
	return c;
}

void pushup(int now) {
	if(tre[now].l==tre[now].r) return;
	tre[now].ans=merge(tre[lson].ans,tre[rson].ans);
}
```

于是我们将所有操作离线下来建图，建完后树剖后统一进行询问回答即可，AC 代码如下：


```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=300005;

int n;

struct Node {
	char op;
	int x,y;
}qst[N];

vector<int> vec[N];

struct node {int save=0,del=0;}nullnode;
node merge(node a,node b) {
	node c={max(a.save-b.del,0)+b.save,a.del+max(b.del-a.save,0)};
	return c;
}

// 线段树部分

struct Tre {
	int l,r;
	node ans; // ans 为非 LCA 减少量
}tre[4*N];

#define mid (tre[now].l+tre[now].r>>1)
#define lson (now*2)
#define rson (now*2+1)

void pushup(int now) {
	if(tre[now].l==tre[now].r) return;
	tre[now].ans=merge(tre[lson].ans,tre[rson].ans);
}

void build(int now,int l,int r) {
	tre[now].l=l,tre[now].r=r;
	if(l==r) return;
	build(lson,l,mid);build(rson,mid+1,r);
}

void change(int now,int p,int flg) { // flg=1 save，flg=-1 del 
	if(tre[now].l>p || tre[now].r<p) return;
	if(tre[now].l==tre[now].r) {
		if(flg==1) tre[now].ans.save++;
		else if(flg==-1) tre[now].ans.del++;
		return;
	}
	change(lson,p,flg);change(rson,p,flg);
	pushup(now);
}

node query(int now,int l,int r) {
	if(tre[now].l>r || tre[now].r<l || l>r) return nullnode;
	if(tre[now].l>=l && tre[now].r<=r) return tre[now].ans;
	return merge(query(lson,l,r),query(rson,l,r));
}

// 树链剖分部分

int siz[N],dep[N],fa[N],mson[N];

int pos[N],sta[N]; // 删除和添加标记 

int topn[N];
stack<int> S;

void dfs1(int u,int father,int cnt) {
	fa[u]=father,siz[u]=1,dep[u]=dep[father]+1,cnt+=pos[u],sta[u]=cnt;
	
	int mtop=0;
	if(!S.empty()) mtop=S.top();
	topn[u]=mtop;
	
	if(pos[u]==1) S.push(u-1);
	if(pos[u]==-1) S.pop();
	
	for(auto v:vec[u]) {
		if(v==fa[u]) continue;
		dfs1(v,u,cnt);
		siz[u]+=siz[v];
		if(siz[v]>siz[mson[u]]) mson[u]=v;
	}
	
	if(pos[u]==1) S.pop();
	if(pos[u]==-1) S.push(mtop);
}

int top[N],dfn[N],cnt;

void dfs2(int u,int topnode) {
	dfn[u]=++cnt,top[u]=topnode;
	change(1,dfn[u],pos[u]);
	
	if(mson[u]) dfs2(mson[u],topnode);
	for(auto v:vec[u]) if(v!=fa[u] && v!=mson[u]) dfs2(v,v);
}

int query_path(int u,int v) {
	node U=nullnode,V=nullnode;
	while(top[u]!=top[v]) {
		if(dep[top[u]]<dep[top[v]]) {swap(u,v);swap(U,V);}
		U=merge(query(1,dfn[top[u]],dfn[u]),U);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v]) {swap(u,v);swap(U,V);}
	U=merge(query(1,dfn[mson[v]],dfn[u]),U);
	return sta[v]-max(U.del,V.del);
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin >> n;
	
	for(int i=1;i<=n;++i) {
		cin >> qst[i].op >> qst[i].x;
		++qst[i].x; 
		if(qst[i].op=='c') cin >> qst[i].y;
		else pos[i+1]=(qst[i].op=='a'?1:-1);
		vec[qst[i].x].push_back(i+1);
		vec[i+1].push_back(qst[i].x);
	}
	
	build(1,1,n+1);
	dfs1(1,0,0);
	dfs2(1,1);
	
	for(int i=1;i<=n;++i) {
		if(qst[i].op=='b') cout << topn[i+1] << '\n';
		if(qst[i].op=='c') cout << query_path(i+1,qst[i].y+1) << '\n';
	}
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：3)

# Luogu P4810 / COCI2014-2015#3 Solution / rope 容器的使用

## 题面

初始存在一个编号为 $0$ 的空栈。

除编号为 $0$ 的站之外，维护 $n$ 个栈，进行 $n$ 次操作，第 $i$ 次操作选择一个编号小于 $i$ 的栈复制至第 $i$ 个栈，支持将 $i$ 加入栈顶/查询栈顶元素并弹出栈顶/查询多少个数同时存在于该栈和另一个指定的栈。

数据范围：$n\le 3\times 10^5$

原题面在[此](https://www.luogu.com.cn/problem/P4810)。

## 思路

由于每次加入的数均是唯一的，所以不同栈出现相同数的唯一方法就是继承同一个栈。

将不同的栈抽象成一棵树，每一个栈就是这棵树上的一个节点。如果继承后需要加入一个数，那么在被继承栈的节点下增加一个节点，将这个栈挂在这个节点上；如果需要弹出栈顶，就输出被继承栈所在节点代表的数字，然后将栈挂在这个节点的父节点上；如果需要查询出现相同数的个数，那么找到这两个栈所在节点的 LCA，输出这个节点的深度即可。

使用离线树剖/在线倍增均可解决，时间复杂度 $O(n\log n)$。

但是，为了更快地解出这道题，我们并不需要手打树剖或倍增。

## GNU C++ `rope`

`rope` 为 GNU 提供的 C++ 扩展库内的一种数据结构，其表现为可持久化数组，内部实现为平衡树，支持 $O(1)$ 的数组复制，以及 $O(\log n)$ 的下标查询/任意位置插入/任意位置删除等操作。**不支持修改操作**。

`rope` 包含在 `ext/rope` 头文件以及 `__gnu_cxx` 命名空间中，由于 CCF 系列赛采用 `g++` 编译器，故可以使用。

所以，我们可以借助这个容器方便地实现题目中提到的 $4$ 种操作。

1. 栈复制

```c++
rp[i] = rp[x];
```

2. 入栈

```c++
rp[i].push_back(i);
```

3. 出栈

```c++
rp[i].pop_back();
```

4. 查询 LCA

```c++
while (l <= r)
{
    mid = (l + r) >> 1;
    if (rp[i][mid - 1] == rp[y][mid - 1])
        rs = mid, l = mid + 1;
    else
        r = mid - 1;
}
```

上方提到的 LCA 的本质其实是将栈从底到顶转化为数组后使得两数组对应值不同的第一个下标（以 $0$ 开始）。

使用二分查询即可。

由于 `rope` 的时间复杂度带一个 $\log$，所以总时间复杂度为 $O(n\log^2 n)$。

## 完整代码

```c++
#include <iostream>
#include <ext/rope>
using namespace std;
const int N = 3e5 + 10;
using namespace __gnu_cxx;
int n, l, r, mid, rs;
char ch;
rope<int> rp[N];
int main()
{
    scanf("%d", &n);
    for (int i = 1, x, y; i <= n; i++)
    {
        cin >> ch >> x;
        rp[i] = rp[x];
        if (ch == 'a')
        {
            rp[i].push_back(i);
            continue;
        }
        if (ch == 'b')
        {
            printf("%d\n", rp[i].back());
            rp[i].pop_back();
            continue;
        }
        cin >> y;
        l = 1, r = min(rp[i].size(), rp[y].size()), rs = 1;
        while (l <= r)
        {
            mid = (l + r) >> 1;
            if (rp[i][mid - 1] == rp[y][mid - 1])
                rs = mid, l = mid + 1;
            else
                r = mid - 1;
        }
        printf("%d\n", !r or rp[i][0] != rp[y][0] ? 0 : rs);
    }
}
```

---

## 作者：decoqwq (赞：3)

考虑将所有操作化成一棵树的形态，容易发现删除完一个数之后的栈一定会与之前出现过的某一个栈相同，则考虑只维护一棵有进栈操作的树。

对于操作 $a$，新建结点 $i$ 成为 $x$ 的儿子，记录 $i$ 的栈顶并预处理出 $i$ 的 $2^k$ 级父亲。

对于操作 $b$，显然新结点 $i$ 和 $x$ 的父亲完全等价，直接将新结点 $i$ 指针指向 $x$ 的父亲即可，并输出 $x$ 的栈顶元素。

对于操作 $c$，因为每次加入的数互不相同，所以只有在操作树上经过同一个操作的结点才会增加一个相等的数，显然其个数就是 $x$ 和 $y$ 的 $lca$ 的 $size$，倍增即可。

要注意的是，每次操作前都要将 $x$ 变为其指向的等价结点，避免查询到空结点。

```cpp
#include <bits/stdc++.h>
using namespace std;
int fa[300010][19],siz[300010],n,ys[300010],dep[300010],tree[300010];
int lca(int x,int y)
{
	if(dep[x]<dep[y])
	{
		swap(x,y);
	}
	for(int i=18;i>=0;i--)
	{
		if(dep[fa[x][i]]>=dep[y])
		{
			x=fa[x][i];
		}
	}
	if(x==y)
	{
		return x;
	}
	for(int i=18;i>=0;i--)
	{
		if(fa[x][i]==fa[y][i])
		{
			continue;
		}
		x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		char opt[5];
		int x,y;
		scanf("%s%d",opt,&x);
		x=tree[x];
		if(opt[0]=='a')
		{
			tree[i]=i;
			fa[i][0]=x,siz[i]=siz[x]+1,ys[i]=i;
			dep[i]=dep[fa[i][0]]+1;
			for(int j=1;j<=18;j++)
			{
				fa[i][j]=fa[fa[i][j-1]][j-1];
			}
		}
		if(opt[0]=='b')
		{
			tree[i]=fa[x][0];
			cout<<ys[x]<<'\n';
		}
		if(opt[0]=='c')
		{
			scanf("%d",&y);
			y=tree[y];
			cout<<siz[lca(x,y)]<<"\n";
			tree[i]=x;
		}
	}
}
```

---

## 作者：Swirl (赞：2)

想要访问历史信息，要么用可持久化，要么用操作树。

可持久化是在线，操作树是离线。

看起来可持久化更好一点。

你说的对，但是操作树很好写，就这一点就够了。

---

访问历史信息并不能把所有的版本都记上去，所以考虑维护变化量。

直接开一个全局数据结构维护当前信息（类似扫描线和回滚莫队）。

而访问以前的版本信息实际上就是在一个操作链上做回滚操作，滚到链上某个点。

每次回滚实际上可以看成从第 $u$ 个点跳到了链上的 $v$ 点。

但回滚回去之后如果继续按这条链改下去就会覆盖掉以前的版本信息，所以考虑新开一条链。

而这就是一棵树，我们称它为**操作树**。

---

值得注意的一点是影响到结点 $u$ 版本信息的地方只有 $u$ 的祖先链。

因此只要没有对版本信息造成影响就不应该在操作树上新建端点。

---

对于本题，`a` 和 `b` 操作没有什么难度。

`c` 操作让你找公共部分，实际上就是两点的 $\text{LCA}$ 的祖先链，个数即深度。

只需要离线之后在操作树上跑 $\text{LCA}$ 即可。

直接上代码：

```cpp
#include <bits/stdc++.h>
// #define int long long
#define pii pair<int, int>
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int& x, int c) {
    x = max(x, c);
}
inline void cmin(int& x, int c) {
    x = min(x, c);
}

int _test_ = 1;

const int N = 3e5 + 5;

int n, fa[N], fav[N], ver[N], tot, f[N][20], dep[N], ans[N];
vector<int> g[N];
// ver 代表第 i 个操作之后的版本（结点）编号、
// fav 代表连向父亲的边上的权值

struct Q {
    int l, r, id;
};

void dfs(int u, int fa) {
    f[u][0] = fa;
    dep[u] = dep[fa] + 1;
    for (auto x : g[u]) {
        if (x == fa)
            continue;
        dfs(x, u);
    }
}

int lca(int u, int v) {  // lca
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int max_dep = 0;
    while ((1 << (max_dep + 1)) < dep[u])
        max_dep++;
    for (int i = max_dep; i >= 0; i--) {
        if (dep[u] - (1 << i) >= dep[v]) {
            u = f[u][i];
        }
    }
    if (u == v) {
        return u;
    }
    for (int i = max_dep; i >= 0; i--) {
        if (f[u][i] != f[v][i]) {
            u = f[u][i];
            v = f[v][i];
        }
    }
    return f[u][0];
}

void init() {}

void clear() {}

void solve() {
    cin >> n;
    ver[0] = tot = 1;
    vector<Q> q;   // 离线
    int qtot = 0;  // 查询的个数
    for (int i = 1; i <= n; i++) {
        char c;
        int v;
        cin >> c >> v;
        if (c == 'a') {                   // a
            ver[i] = ++tot;               // 对应新的结点
            g[ver[v]].push_back(ver[i]);  // 建边
            g[ver[i]].push_back(ver[v]);
            fa[ver[i]] = ver[v];  // 记父亲
            fav[ver[i]] = i;
        }
        if (c == 'b') {
            qtot++;  // 需要回答，计数器加一
            ver[i] =
                fa[ver[v]];  // 找到版本，并删除（删除即撤销添加，即版本的父亲）
            ans[qtot] = fav[ver[v]];  // 记录答案
        }
        if (c == 'c') {
            qtot++;  // 需要回答
            int w;
            cin >> w;
            ver[i] = ver[v];  // 找到版本
            q.push_back(
                {ver[v], ver[w], qtot});  // 放到后面整棵树建好了用 lca 做（lca
                                          // 懒得写在线就干脆顺便把查询也离线）
        }
    }
    dfs(1, 0);
    int t = log2(n);
    for (int i = 1; i <= t; i++) {
        for (int j = 1; j <= n; j++) {
            f[j][i] = f[f[j][i - 1]][i - 1];
        }
    }
    for (auto [x, y, id] : q) {
        ans[id] = dep[lca(x, y)] - 1;  // 减一是因为答案为路径上的边数而非点数
    }
    for (int i = 1; i <= qtot; i++)
        cout << ans[i] << "\n";
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    //	cin >> _test_;
    init();
    while (_test_--) {
        clear();
        solve();
    }
    return 0;
}
```

你会发现操作树并没有什么~~难度~~技巧。

---

## 作者：Brainless (赞：2)

一道比较难发现的$LCA$，关键在于如何建树。

	对于栈的操作，分为三种：
	a、复制+栈顶添加
    b、复制+栈顶删除
    c、复制+比较
   
对于操作$a$，在其栈$v$所属的节点下再开一个新的节点，编号为$i$，所以编号为$i$的节点所代表的栈，栈顶数字就是$i$（这点在操作$b$中有很大的作用）。

对于操作$b$，删除栈$v$的栈顶，得到的新栈则是栈$v$的父亲节点所代表的栈。至于输出删除的数字，由于操作$a$中讲到，栈顶数字就是节点编号的原因，答案就是栈$v$所属的节点编号。

对于操作$c$，复制，就是要将新栈合并到栈$v$所属的节点（即一个节点可以包含多个内容一样，编号不同的栈），而比较则需要$LCA$，找到栈$v$和栈$w$所属节点的$LCA$，而$LCA$节点的深度则为相同部分的长度。

实现方面，合并节点用并查集，$LCA$我选择树剖。

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#define rep(i,a,b)  for(int i=a;i<=b;++i)
#define per(i,a,b)  for(int i=a;i>=b;--i)
#define REP(i,a,U)  for(int i=a;i;i=U[i].nxt)
#define add(x,y)  e[++totE]=(E){y,head[x]},head[x]=totE
using namespace std;
const int N = 3e5 + 7;
struct E {
  int to, nxt;
}e[N << 1]; int head[N], totE; //邻接表
int mp[N]; //并查集数组
int fa[N], dep[N], sz[N], son[N], top[N]; //树剖LCA五大数组
int req[N][2], tot; //由于LCA的原因，要把所有需要输出的操作存起来，建树完成后再操作
int n, m;
void dfs1(int x, int Fa) { //树剖1
  sz[x] = 1; fa[x] = Fa;
  REP(i, head[x], e) {
    int v = e[i].to;
    if(v == Fa) continue;
    dep[v] = dep[x] + 1;
    dfs1(v, x);
    sz[x] += sz[v];
    if(sz[v] > sz[son[x]])
      son[x] = v;
  }
}
void dfs2(int x, int tp) { //树剖2
  top[x] = tp;
  if(!son[x]) return;
  dfs2(son[x], tp);
  REP(i, head[x], e) {
    if(!top[e[i].to]) dfs2(e[i].to, e[i].to);
  }
}
inline int lca(int x, int y) { //树剖LCA
  while(top[x] != top[y]) {
    if(dep[top[x]] < dep[top[y]])
      swap(x, y);
    x = fa[top[x]];
  }
  return dep[x] < dep[y] ? x : y;
}
int main() {
  scanf("%d", &n);
  mp[1] = 1;
  rep(i, 2, n + 1) { //注意！！！这里把所有的节点都加了1
    char opt; int v, w;
    cin >> opt >> v; ++v; //加1
    if(opt == 'a') {
      add(mp[v], i);
      mp[i] = i; //新开节点
      fa[i] = mp[v];
    }
    if(opt == 'b') {
      mp[i] = fa[mp[v]]; //合并到栈v父亲节点
      req[++tot][0] = -1;
      req[tot][1] = mp[v] - 1; //储存b操作的答案
    }
    if(opt == 'c') {
      cin >> w; ++w; //加1
      mp[i] = mp[v]; //合并到栈v
      req[++tot][0] = v;  //储存c操作的操作栈序号。
      req[tot][1] = w;
    }
  }
  dfs1(1, 0);
  dfs2(1, 1);
  rep(i, 1, tot) {
    if(req[i][0] == -1) cout << req[i][1] << endl; 输出b操作答案
    else cout << dep[lca(mp[req[i][0]], mp[req[i][1]])] << endl;
    //进行c操作统计
  }
}
```


---

## 作者：Great_Influence (赞：2)

操作树。

首先，可以建出这些点的操作树。

对于插入操作，直接将这个点挂在前驱节点的下面。

对于删除操作，直接将这个点和前驱节点的**父亲节点**合并，用并查集维护。

那么，可以知道，询问操作所问的就是两个点在操作树上的距离(因为加入的所有数字都互不相同)。直接处理即可。

注意因为要支持删除操作的输出，需要记录栈底元素是什么。

这样做的时间复杂度取决于求$lca$的时间。根据实现的不同可以得到$O(n\alpha(n))$或者$O(n(\log n+\alpha(n)))$的复杂度。

---

## 作者：Emy_ (赞：0)

看题，第一眼: ~~直接数据结构暴力做~~。

显然不是。

仔细发掘，我们的每一步操作都是在上一步基础上完成，容易发现若将 0 号节点看作根节点，那么所有操作便构成了一棵操作树。

一个一个的看。

1. 添加操作往下新建儿子节点连边即可。

2. 那删除呢？

实际上每一个删除操作可以忽略掉，发现删除栈顶后的栈一定在历史上存在过，因此一定存在一个深度更浅的点等价，直接合并即可，删除的数即为删除的状态的栈顶，因此对于每个点，维护一个栈顶值。

3. 对于第三个操作，由于每次加的数不同，因此两个栈相同的时期一定是两个点的公共祖先，而相同的数量即是深度，倍增 lca 实现。

三个操作便解决了。

而对于那些本质相同的点合并即可，每次新数入栈时建立一个虚拟节点，后面的等价的点直接指向虚拟节点即可，因此要维护的只有第一个操作。


本质非常套路的题，有助于积累经验。

下面是代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e5+10;
int h[N],es[N],ne[N],idx,fa[N],f[N][25],cnt,dep[N],val[N],up[N];
int n;
struct node
{
	char op;
	int v,w,ans;
}e[N];
void add(int a,int b)
{
	es[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int u)
{
	for(int i=h[u];~i;i=ne[i])
	{
		int j=es[i];
		dep[j]=dep[u]+1;
		f[j][0]=u;
		
		for(int k=1;(1<<k)<=dep[j];k++)
		f[j][k]=f[f[j][k-1]][k-1];
		
		dfs(j);
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	
	if(x==y) return x;
	
	for(int i=20;i>=0;i--)
	if(f[x][i]!=f[y][i])
	{
		x=f[x][i];
		y=f[y][i];
	}
	return f[x][0];
}
void solve()
{
	for(int i=1;i<=n;i++)
	{
		if(e[i].op=='b') printf("%d\n",e[i].ans);
		else if(e[i].op=='c') 
		{
			int v=e[i].v,w=e[i].w;
			int t=lca(fa[v],fa[w]);
			printf("%d\n",dep[t]);
		}
	}
}
int main()
{
	scanf("%d",&n);
	memset(h,-1,sizeof(h));
	
	for(int i=1;i<=n;i++)
	{
		char op;
		int v,w;
		cin>>op>>v;
		
		if(op=='a')
		{
			fa[i]=++cnt;
			
			val[fa[i]]=i;
			up[fa[i]]=fa[v];
		        add(fa[v],fa[i]);
		        e[i]={op,v,w};
		}
		
		else if(op=='b') 
		{
			fa[i]=up[fa[v]];
			e[i]={op,v,w};
			e[i].ans=val[fa[v]];
		}
		
		else
		{
			fa[i]=fa[v];
			cin>>w;
			e[i]={op,v,w};
		}
	}
	dfs(0);
	solve();
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

难点在于读题。

对于原问题，以 $0$ 号栈为根，将栈中的树转化为带权树路径上边权集。

边分为两种：一操作的带权边以及二三操作带来的无权边。

对于二操作输出祖先的第一条有权边。

对于三操作求出两点 LCA 节点的深度即可。

注意深度只体现在带权边上，即无权边对深度的贡献是 $0$。

实现时可以使用并查集收缩无权边链。

```cpp
/*
考虑把树建出来。
那样就是树深度了。 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e5 + 5 , MX = 3e5;
int n,m;
char s[5];
int x,y,rt,head[Len],cnt,dep[Len],qv[Len];
struct Node
{
	int next,to,w;
}edge[Len << 1];
inline void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
int fa[Len],iff[Len][25];
inline void makeSet(int x){for(int i = 1 ; i <= x ; i ++) fa[i] = i;}
int findSet(int x){return fa[x] == x ? fa[x] : fa[x] = findSet(fa[x]);}
void unionSet(int x,int y)
{
	int u = findSet(x) , v = findSet(y);
	if(u == v) return;
	fa[v] = u;
}
void cc(int x,int f)
{
	iff[x][0] = f;dep[x] = dep[f] + 1;
	for(int i = 1 ; (1 << i) <= dep[x] ; i ++) iff[x][i] = iff[iff[x][i - 1]][i - 1];
}
int FLCA(int x,int y)
{
	if(dep[x] < dep[y]) swap(x , y);
	for(int i = 20 ; i >= 0 ; i --) if(dep[iff[x][i]] >= dep[y]) x = iff[x][i];
	if(x == y) return x;
	for(int i = 20 ; i >= 0 ; i --) if(iff[x][i] != iff[y][i]) x = iff[x][i] , y = iff[y][i];
	return iff[x][0];
}
int main()
{
	scanf("%d",&n);makeSet(n);
	int lst = 0;
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%s",s + 1);scanf("%d",&x);x = findSet(x);
		if(s[1] == 'c') 
		{
			unionSet(x , i);
			scanf("%d",&y);y = findSet(y);
			printf("%d\n",dep[FLCA(x , y)]);
		}
		else if(s[1] == 'b')
		{
			printf("%d\n",qv[x]);
			unionSet(iff[x][0] , i);
		}
		else
		{
			add(x , i , i);
			qv[i] = i;
			cc(i , x);
		}
	}
	return 0;
}
```

---


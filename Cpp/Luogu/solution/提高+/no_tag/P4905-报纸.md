# 报纸

## 题目背景

终于熬过了初中三年，《学英语报》却阴魂不散。当高一的第一张《学英语报》飘到我面前时，CYD 大神心里充满了绝望，然而，他还有一线希望——XHY 同学总是做得比他快。

## 题目描述

作为做 PPT 的回报，XHY 同学决定送点“温暖”给 CYD 大神——一份英语报纸的答案。这份报纸是一个 $N \times N$ 的方阵，其中某些格子写有答案。答案的分布似乎很有规律：对于格子 $(x,y)$，当且仅当 $x$ 和 $y$ 不互质时，这个格子上有答案。

XHY 同学的手机每次能拍下一个 $1 \times 2$ 的区域（横竖均可）。请你帮她写一个程序，求出至少要拍多少张照片，才能把所有的答案发给 CYD 大神。

## 说明/提示

对于 $30 \%$ 数据，$N \le 10$。  
对于 $60 \%$ 数据，$N \le 50$。  
对于 $100 \%$ 数据，$1 \le N \le 233$。

## 样例 #1

### 输入

```
4
```

### 输出

```
5
```

## 样例 #2

### 输入

```
5
```

### 输出

```
6
```

## 样例 #3

### 输入

```
6
```

### 输出

```
11
```

# 题解

## 作者：gaoyangyang (赞：10)

因为本题数据并不会很大只有 233 ，所以可以用**打表**的方式做：

打表思路：

首先写一个**判断互质**的函数（返回值 $1$ ：不互质；$0$ ：互质）。
```cpp
int hz(int a,int b)
{
	for (int i=2;i<=min(a,b);i++)
	{
		if  (a%i==0 and b%i==0)
		{
			return 1;
		}
	}
	return 0;
   //例如：当我输入4时，他会产生：
   	//2 2
	//2 4
	//3 3
	//4 2
	//4 4
   //一共五个非互质数对
}
```
接下来将互质的数对**可视化**。
```cpp
int hz(int a,int b)
{
	for (int i=2;i<=min(a,b);i++)
	{
		if  (a%i==0 and b%i==0)
		{
			return 1;
		}
	}
	return 0;
}
int a[1000][1000];
int n;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			if (hz(i,j))
			{
				a[i][j]=1;
			}
		}
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
   //例如：当我输入4时，会输出：
   	//0 0 0 0
	//0 1 0 1
	//0 0 1 0
	//0 1 0 1
   //这一个矩阵即题目中有答案的地方
}
```
然后运用“自然有机分子运算器”（大脑）开始打表。

这里以输入样例：$6$ 为例。

首先，生成有“答案”的坐标二维表。

可得：

|0|0|0|0|0|0|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|0|1|0|1|0|1|
|0|0|1|0|0|1|
|0|1|0|1|0|1|
|0|0|0|0|1|0|
|0|1|1|1|0|1|

接下来以有“ $1$ ”的点开始 **向外扩展**（只有两种方向：右或下，尽量多的覆盖没有被覆盖的标记点）。
所以输入为 $6$ 的矩阵就可以这样填充（数字为编号，这里为方便展示将原本的标记“ $1$ ”改为@）填法不唯一。

|0|0|0|0|0|0|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|0|@1|0 2|@2|0 11|@11|
|0|0 1|@3|0 3|0|@10|
|0|@4 |0 4|@5|0 8|@10|
|0|0|0|0 5|@8|0 9|
|0|@6|@6|@7|0 7|@9|

刚刚好 $11$ 个。

接下来加亿点肝量（耗时数周）可得出答案。
下面亮代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	//暴力出奇迹，打表得省一 
	int a[234]={0,1,2,5,6,11,12,19,22,31,32,43,44,57,64,79,80,97,98,117,126,147,148,171,176,201,210,237,238,267,268,299,312,345,356,391,392,429,444,483,484,525,526,569,590,635,636,683,690,739,758,809,810,863,880,933,954,1011,1012,1071,1072,1133,1160,1223,1240,1305,1306,1373,1398,1467,1468,1539,1540,1613,1648,1723,1740,1817,1818,1897,1924,2005,2006,2089,2112,2195,2226,2313,2314,2403,2424,2513,2546,2639,2662,2757,2758,2855,2894,2993,2994,3095,3096,3199,3256,3361,3362,3469,3470,3579,3618,3729,3730,3843,3870,3985,4030,4147,4170,4289,4300,4421,4464,4587,4612,4737,4738,4865,4910,5039,5040,5171,5196,5329,5392,5527,5528,5665,5666,5805,5854,5995,6018,6161,6194,6339,6402,6549,6550,6699,6700,6851,6908,7061,7096,7251,7252,7409,7464,7623,7652,7813,7814,7977,8062,8227,8228,8395,8408,8577,8640,8811,8812,8985,9046,9215,9276,9453,9454,9633,9634,9815,9878,10061,10102,10287,10314,10501,10582,10771,10772,10963,10964,11157,11256,11451,11452,11649,11650,11849,11918,12119,12154,12357,12404,12607,12682,12889,12918,13127,13128,13339,13412,13625,13672,13887,13924,14141,14216,14435,14464,14685,14686,14909,15014,15239,15240,15467,15468,15697,15808,16039,16040};
	cin>>n;
	cout<<a[n-1]<<endl;
}
```

---

## 作者：Xqbk (赞：10)

值此所有陈旧的乱搞被粉兔正义裁决之际趁机投稿一个崭新的题解。

首先注意到 $N\le 233$，这么小的范围可以直接把题目中说的网格图 $O(N^2\log N)$ 建出来。

题目中让我们求用 $1\times 2$ 矩形覆盖所有非空矩形的最小数量，也就是网格图的最小点覆盖。

而网格图又一定是二分图，于是问题就成为了我们熟知的二分图最小点覆盖，也就等于点数减去最大匹配。

于是求出最大匹配即可。这里用了 Dinic 算法。

复杂度粗略计算好像是 $O(N^3)$？实际上应该远远跑不满的吧。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int INF=9999999;
const int MAXN=300*300;
int n,s;
int a[300][300];
int gcd(int x,int y)
{
	if(!y)return x;
	return gcd(y,x%y);
}
int cnt=1;
struct Edge
{
	long long nxt,to,flow;
}e[MAXN<<1];
int head[MAXN];
void addEdge(int u,int v,int f)
{
	cnt++;
	e[cnt].nxt=head[u];
	e[cnt].to=v;
	e[cnt].flow=f;
	head[u]=cnt;
}
long long dis[MAXN],vis[MAXN];
long long flo[MAXN],pre[MAXN];
bool bfs(int n,int s,int t)
{
	queue<int> Q;
	for(int i=1;i<=n;i++)
	{
		dis[i]=INF;
		vis[i]=0;
	}
	Q.push(s);
	dis[s]=0;
	vis[s]=1;
	flo[s]=INF;
	while(!Q.empty())
	{
		int u=Q.front();
		Q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		{
			if(!e[i].flow)continue;
			int v=e[i].to;
			if(vis[v])continue;
			if(dis[v]>dis[u]+1)
			{
				dis[v]=dis[u]+1;
				flo[v]=min(flo[u],e[i].flow);
				pre[v]=i;
				Q.push(v);
				vis[v]=1;
			}
		}
	}
	return dis[t]!=INF;
}
int cur[MAXN];
long long dfs(int u,int t,long long d)
{
	if(u==t||d==0)return d;
	long long res=0;
	long long f;
	for(int i=cur[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		cur[u]=i;
		if(dis[u]+1==dis[v]&&(f=dfs(v,t,min(d,e[i].flow)))>0)
		{
			e[i].flow-=f;
			e[i^1].flow+=f;
			res+=f;
			d-=f;
			if(d==0)break;
		}
	}
	return res;
}
long long maxflow;
void MaxFlow(int n,int s,int t)
{
	while(bfs(n,s,t))
	{
		for(int i=1;i<=n;i++)cur[i]=head[i];
		maxflow+=dfs(s,t,INF);
	}
}
int num(int x,int y)
{
	return (x-1)*n+y;
}
int main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		for(int j=2;j<=n;j++)
		{
			if(gcd(i,j)!=1)
			{
				a[i][j]=1;
				s++;
				bool d=(i%2==j%2);
				if(d)
				{
					addEdge(n*n+2,num(i,j),0);
					addEdge(num(i,j),n*n+2,1);
				}
				else
				{
					addEdge(n*n+1,num(i,j),1);
					addEdge(num(i,j),n*n+1,0);
				}
				if(a[i-1][j])
				{
					addEdge(num(i-1,j),num(i,j),d);
					addEdge(num(i,j),num(i-1,j),!d);
				}
				if(a[i][j-1])
				{
					addEdge(num(i,j-1),num(i,j),d);
					addEdge(num(i,j),num(i,j-1),!d);
				}
			}
		}
	}
	MaxFlow(n*n+2,n*n+1,n*n+2);
	cout<<s-maxflow<<endl;
}

```


---

## 作者：Argon_Cube (赞：3)

* **【题目链接】**

[Link:P4905](https://www.luogu.com.cn/problem/P4905)

* **【解题思路】**

本题思路来自某题解下的一个评论。

> 可以先计算最多能有多少次拍照可以直接拍掉 $2$ 个答案（一个答案不能重复拍），然后加上剩下的答案数即可。

那么，我们要怎么计算最多能有多少次拍照可以直接拍掉 $2$ 个答案？

我们看看这个数据范围，$n\leq233$。考虑乱搞。

首先，问题显然可以转化为在一个 $1$ 的四连通块内最多能塞下多少个 $1\times 2$ 的方块，其中方块可以任意旋转。

然后我们直接打出一个 $233\times233$ 的表，如果为 $1$ 就代表这个位置有答案。为了方便观察，我们把 $1$ 替换为`@`，$0$ 替换为空格。

```cpp
#include <iostream>

using namespace std;

int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}

int main(int argc,char* argv[],char* envp[])
{
	for(int i=1;i<=233;i++)
	{
		for(int j=1;j<=233;j++)
			cout<<(gcd(i,j)!=1?'@':' ');
		cout<<'\n';
	}
	return 0;
}

```

然后我们看一下这个表，我们发现这个表里`@`的连通块大小都比较小，并且奇形怪状的。然后，我们考虑对于每一个连通块爆搜可以塞多少个方块。于是这题便做完了。

* **【代码实现】**

```cpp
//本代码需要O2。
#include <unordered_set>
#include <iostream>
#include <vector>
#include <array>

using namespace std;

int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}

namespace std _GLIBCXX_VISIBILITY(default)
{
	_GLIBCXX_BEGIN_NAMESPACE_VERSION
	template<>
	struct hash<pair<int,int>>
	{
		size_t operator()(const pair<int,int>& tmp)const
		{
			return tmp.first+tmp.second;
		}
	};
}
array<array<char,300>,300> coprime;
unordered_set<pair<int,int>> finder;

void DFS_add(int i,int j)
{
	return (void)(coprime[i][j]==1&&(coprime[i][j]=2,finder.emplace(i,j),DFS_add(i+1,j),DFS_add(i-1,j),DFS_add(i,j+1),DFS_add(i,j-1),true));
}

int DFS_put(int i,int j)
{
	vector<pair<int,int>> valid_pairs;
	valid_pairs.reserve(10);
	int result=0;
	finder.erase(finder.find(make_pair(i,j)));
	if(finder.find(make_pair(i,j+1))!=finder.end())
	{
		finder.erase(finder.find(make_pair(i,j+1)));
		result=1;
		for(const auto& tmp:finder)
			valid_pairs.push_back(tmp);
		for(const auto& tmp:valid_pairs)
			result=max(result,1+DFS_put(tmp.first,tmp.second));
		finder.emplace(i,j+1);
	}
	valid_pairs.clear();
	valid_pairs.reserve(10);
	if(finder.find(make_pair(i+1,j))!=finder.end())
	{
		finder.erase(finder.find(make_pair(i+1,j)));
		result=1;
		for(const auto& tmp:finder)
			valid_pairs.push_back(tmp);
		for(const auto& tmp:valid_pairs)
			result=max(result,1+DFS_put(tmp.first,tmp.second));
		finder.emplace(i+1,j);
	}
	finder.emplace(i,j);
	return result;
}

int DFS_count(int i,int j)
{
	finder.clear();
	DFS_add(i,j);
	int result=0;
	vector<pair<int,int>> valid_pairs;
	for(const auto& tmp:finder)
		valid_pairs.push_back(tmp);
	for(const auto& tmp:valid_pairs)
		result=max(DFS_put(tmp.first,tmp.second),result);
	return result;
}

int DFS_clear(int i,int j)
{
	return coprime[i][j]?(coprime[i][j]=0,1+DFS_clear(i,j+1)+DFS_clear(i+1,j)+DFS_clear(i-1,j)+DFS_clear(i,j-1)):0;
}

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int cnt;
	cin>>cnt;
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
			coprime[i][j]=gcd(i,j)!=1; 
	int ans=0,tmp;
	for(int i=1;i<=cnt;i++)	
		for(int j=1;j<=cnt;j++)
			if(coprime[i][j]==1)
				tmp=DFS_count(i,j),ans+=DFS_clear(i,j)-tmp;
	cout<<ans;
	return 0;
}
//你可以用我的代码打表，我不拦着你。我已经用这个代码打过表了。

```

---

## 作者：XZDZD (赞：1)

# **P4905 报纸 题解**
最近学习了二分图最小点覆盖问题，于是心血来潮写下这篇题解。如有不当，还请斧正。
## Part 0

不难看出是二分图最小点覆盖问题，于是考虑使用匈牙利算法解决该问题。~~其实是别的不会。~~

## Part 1

首先考虑如何建图，答案只存在于横纵坐标不互质的点上。因此互质的点是没有答案的。判断互质的方法我们使用 gcd 如果两个数的最大公约数为一，那么这两个数就是互质的，这是基本定义。

## Part 2

建边时我们考虑奇偶性建边~~不然会被 hack~~ 但其实奇偶性建边才能保证是二分图，应该说不这样建边本来就是错误的，但是数据过水。

当然也有染色建图的办法，但这里不过多介绍。

建好的图应该如下：

左部点（奇 / 偶 不互质） |  右部点（偶 / 奇 不互质）。

## Part 3

最后的答案根据二分图最小点覆盖可知，答案为下：

点的总数 - 没有答案的点数 - 最大匹配数。

# AcCode

```cpp
#include<bits/stdc++.h>
#define int long long
const int N = 65500;
using namespace std;
int n;
int dx[4] = {-1,1,0,0};
int dy[4] = {0,0,-1,1};
int gcd (int a,int b) {
    return b ? gcd(b, a % b) : a;
}
bool cmp (int a,int b) {
    return gcd(a, b) == 1;
} // 判断函数 gcd就可以 写cmp多此一举
bool vis[250][250];
vector <int> G[N];
int vs[N];
int dfn = 0;
int match[N];
bool dfs (int u) {
    for (auto v : G[u]) {
        if (vs[v] != dfn) {
            vs[v] = dfn; //这样写不用每次初始化
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}
signed main() {
    cin >> n;
    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (cmp(i,j) && !vis[i][j]) vis[i][j] = true,cnt++;
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if ((i + j) % 2 == 1) { //根据奇偶性建边，写成 (i + j) % 2 == 0 也是OK的。
                if (vis[i][j]) continue;
                for (int k = 0; k < 4; ++k) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x > n || y > n || x < 1 || y < 1 || vis[x][y] ) continue;
                    G[(i - 1) * n + j].push_back((x - 1) * n + y);
                }                
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n * n; ++i) {
        dfn++;
        if (dfs(i)) ans++;
    }
    cout << n * n - cnt - ans;
    return 0;
}
```

## 其他练习 ~~（经验）~~

[P5030](https://www.luogu.com.cn/problem/P5030)  这道题建图需要思考。

[P3355](https://www.luogu.com.cn/problem/P3355) 这道题建边的奇偶会影响效率。

[P4304](https://www.luogu.com.cn/problem/P4304) 水。

[P10937](https://www.luogu.com.cn/problem/P10937) 水。

[P10939](https://www.luogu.com.cn/problem/P10939) 水。

---

## 作者：rainbow_cat (赞：1)

怎能没有匈牙利题解呢？   
考虑直接把网格图建出来，相邻的有答案的格子之间连边，这里照片就相当于边了。   
网格图是典型的二分图，选择尽量少的边使得每个点都被覆盖，这应该是最小边覆盖而不是最小点覆盖。   
结论：最小边覆盖 $=$ 点数 $-$ 最大匹配。   
这个东西跑匈牙利算法即可。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,idx,now,ans,to[100010],dx[]={-1,0,1,0},dy[]={0,1,0,-1};
int vis[100010];
map<pair<int,int>,int>mp;
vector<int>e[100010];
bool dfs(int u)
{
	for(auto i:e[u])
	{
		if(vis[i]==now)continue;
		vis[i]=now;
		if(!to[i]||dfs(to[i]))
		{
			to[i]=u;
			return 1;
		}
	}
	return 0;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if((i+j)%2||__gcd(i,j)==1)continue;
			if(!mp[{i,j}])mp[{i,j}]=++idx;
			for(int k=0;k<4;k++)
			{
				int nx=i+dx[k],ny=j+dy[k];
				if(!(nx>=1&&nx<=n&&ny>=1&&ny<=n&&__gcd(nx,ny)!=1))continue;
				if(!mp[{nx,ny}])mp[{nx,ny}]=++idx;
				e[mp[{i,j}]].push_back(mp[{nx,ny}]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if((i+j)%2||__gcd(i,j)==1)continue;
			now++,ans+=dfs(mp[{i,j}]);
		}
	}
	cout<<idx-ans;
	return 0;
}
```

---

## 作者：Kketchup (赞：0)

## [P4905 报纸](https://www.luogu.com.cn/problem/P4905)

#### 【题目描述】

在 $n\times n$ 的方阵中，称一个点为特殊点当且仅当此点横纵坐标不互质，即 $(i,j)$ 满足 $\gcd(i,j)\ne1$。

一次操作可以任选一个 $1\times 2$ 的矩形并覆盖，矩形不能超出边界，求使所有特殊点都被覆盖的最小操作数。

$n\le 233$（其实可以加强到 $500$）。

#### 【题目解析】

看到这个题首先想到打表，不直接输入特殊点，而是固定的，不就是让我们打表吗。

我们直接 $O(n^2\log n)$ 暴力算出所有特殊点的位置，然后标记为 $1$，依赖于 $1$ 的联通块大小会很大，爆搜枚举联通块摆放方案即可（好像爆搜不打表也直接能过）。

附上打好的表（前 $233$，答案为 $ans_n$）：

```cpp
int ans[300]={0,0,1,2,5,6,11,12,19,22,31,32,43,44,57,64,79,80,97,98,117,126,147,148,171,176,201,210,237,238,267,268,299,312,345,356,391,392,429,444,483,484,525,526,569,590,635,636,683,690,739,758,809,810,863,880,933,954,1011,1012,1071,1072,1133,1160,1223,1240,1305,1306,1373,1398,1467,1468,1539,1540,1613,1648,1723,1740,1817,1818,1897,1924,2005,2006,2089,2112,2195,2226,2313,2314,2403,2424,2513,2546,2639,2662,2757,2758,2855,2894,2993,2994,3095,3096,3199,3256,3361,3362,3469,3470,3579,3618,3729,3730,3843,3870,3985,4030,4147,4170,4289,4300,4421,4464,4587,4612,4737,4738,4865,4910,5039,5040,5171,5196,5329,5392,5527,5528,5665,5666,5805,5854,5995,6018,6161,6194,6339,6402,6549,6550,6699,6700,6851,6908,7061,7096,7251,7252,7409,7464,7623,7652,7813,7814,7977,8062,8227,8228,8395,8408,8577,8640,8811,8812,8985,9046,9215,9276,9453,9454,9633,9634,9815,9878,10061,10102,10287,10314,10501,10582,10771,10772,10963,10964,11157,11256,11451,11452,11649,11650,11849,11918,12119,12154,12357,12404,12607,12682,12889,12918,13127,13128,13339,13412,13625,13672,13887,13924,14141,14216,14435,14464,14685,14686,14909,15014,15239,15240,15467,15468,15697,15808,16039,16040};
```

各种乱搞贪心做法也很好想，已被 hack，目前最高得到 $95$ 分。

接下来提供一种所谓的正解。

看到题目中 $1\times2$ 的矩形覆盖性质，有点像最小点覆盖问题。

顺着这个思路想，对网格图黑白染色以后连边情况变成二分图，于是网络流即可。

代码实现使用 $\text{Dinic}，$设边数为 $m$，则时间复杂度 $O(m\sqrt m)$。实测 $n=500$ 时总边数在 $3\times 10^5$ 左右，跑得飞快。

**实现细节：**

- $O(n^2\log n)$ 时间暴力连边处理（$\log$ 来自 $\gcd$）。源点连黑点，白点连汇点，相邻的特殊点黑点连向白点，这样一定是二分图。

- 最小点覆盖 $=$ 总点数 $-$ 最大匹配。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
#define cal(x,y) ((x-1)*n+y)
const int N=300,M=N*N,INF=0x3f3f3f3f;
int n,s,t,cnt,ans;
bool c[N][N];
struct edge{
    int v,next,w;
}e[M<<1];
int head[M],tot=1;
void add(int u,int v,int w){
    e[++tot]={v,head[u],w};
    head[u]=tot;
    e[++tot]={u,head[v],!w};
    head[v]=tot;
}
int dis[M],now[M];
bool bfs(){
    queue<int> q;
    memset(dis,0,sizeof(dis));
    q.push(s),dis[s]=1;
    now[s]=head[s];
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=e[i].next){
            int v=e[i].v;
            if(!dis[v]&&e[i].w){
                dis[v]=dis[u]+1;
                q.push(v);
                now[v]=head[v];
                if(v==t) return 1;
            }
        }
    }
    return 0;
}
int dfs(int u,int sum){
    if(u==t) return sum;
    int res=0,tmp;
    for(int i=now[u];i&&sum;i=e[i].next){
        now[u]=i;
        int v=e[i].v;
        if((dis[v]==dis[u]+1)&&e[i].w){
            tmp=dfs(v,min(e[i].w,sum));
            if(!tmp) dis[v]=0;
            e[i].w-=tmp,e[i^1].w+=tmp;
            sum-=tmp,res+=tmp;
        }
    }
    return res;
}
int gcd(int a,int b){
    if(b==0) return a;
    return gcd(b,a%b);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n;
    s=n*n+1,t=s+1;
    for(int i=2;i<=n;++i){
        for(int j=2;j<=n;++j){
            if(gcd(i,j)!=1){
                c[i][j]=1;
                cnt++;
                int odd=(i+j)&1;
                if(odd) add(cal(i,j),t,1);
                else add(s,cal(i,j),1);
                if(c[i-1][j]) add(cal(i-1,j),cal(i,j),odd);
                if(c[i][j-1]) add(cal(i,j-1),cal(i,j),odd);
            }
        }
    }
    while(bfs()) ans+=dfs(s,INF);
    cout<<cnt-ans<<endl;
    return 0;
}
```

有问题或错误欢迎交流，个人觉得码风还行，完结撒花！

---


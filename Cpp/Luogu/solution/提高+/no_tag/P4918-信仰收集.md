# 信仰收集

## 题目背景

随着各种势力的迁入，守矢神社丧失了不少信仰  

现在，为了挽回香火日益惨淡的神社，八坂神奈子派遣神社的风祝早苗去人类村落收集信仰

## 题目描述

你可以将村落看成一个 $m$ 个点的**有向无环图**，其中在某些点上有 $n$ 簇待收集的信仰(每一簇都有一定的数量)，图中有 $k$ 条有向边，每条边的长度均为 $1$ 。   

早苗会从图中的 $1$ 号点出发，在图中的任意一个点停止收集，当早苗在一个有信仰的点的时候，她会将这个点所有的信仰全部收集(包括 $1$ 号点)。  

为了方便，早苗从宇佐见堇子那里学会了瞬移，所以她可以一次移动 $a$ 个单位长度(称为小瞬移)，也可以一次移动 $b$ 个单位长度(称为大瞬移)，分别会花费 $w_a,w_b$点灵力，保证 $a≤b$ ，但由于幻想乡不能被常识所束缚，所以 $w_a$ 不一定小于 $w_b$ 。 

现在，早苗希望你能帮她求出她在村落中能获得的(信仰数量-灵力耗费)的最大值。  

    

## 说明/提示

#### 样例解释:  

图如下所示:
![](https://cdn.luogu.com.cn/upload/pic/34550.png)   

其中 $2$ 号点有 $2$ 信仰， $4$ 号点有 $3$ 信仰， $6$ 号点有 $4$ 信仰。  

早苗可以瞬移 $1$ 或 $2$ 条边的距离，花费分别为 $3,2$   

最优的方案之一是从 $1$ 花费$2$ 瞬移到 $6$ ，收集了 $6$ 号点的 $4$ 点信仰后停止收集，信仰-消耗 $=2$     

#### 数据范围:  

![](https://cdn.luogu.com.cn/upload/pic/34566.png)

## 样例 #1

### 输入

```
3 7 8
1 2
3 2
2 2
4 3
6 4
1 2
2 4
4 5
2 6
7 6
6 4
3 2
3 4```

### 输出

```
2```

# 题解

## 作者：x_angelkawaii_x (赞：6)

首先应该不难想到一维$dp$,$dp[i]$表示到第$i$个点的最大受益,对每个点$dfs$到它所有后面距离它$a,b$长度的点并更新  

然而后来这样复杂度最坏是$O(n^b)$,比如下面这种图:  

![](https://cdn.luogu.com.cn/upload/pic/34710.png)

如果$b=2$那么对于左侧的每一个点,都会去更新右边的所有点,复杂度就是平方级别的,你可以试想如果这种结构重复十次然后$b=20$的复杂度  

$gg$  

其实做到这里$60$分也是不错的成绩了,正解是不太好想的二维$dp$,意会一下就好  

$dp[i][k]$表示第$i$号点,还需要从这个点走$k$步才能停下来的最大收益  

那么,先拓扑排序,对于一个点$u$,我们枚举它直接相连的点$v$,那么转移有四种:  
$$dp[v][i]=max(dp[v][i],dp[u][i+1])(0<i<b)$$

$$dp[v][a-1]=max(dp[v][a-1],dp[u][0]-w_a)$$  

$$dp[v][b-1]=max(dp[v][b-1],dp[u][0]-w_b)$$  

$$dp[v][0]=max(dp[v][0],dp[u][1]+w[v])$$($w[i]$表示$i$处收益)  

然后就可以愉快的水过了(雾),注意$dp[1][0]$的初值  

难度主要集中在思维难度上  

$ACcode$  
```cpp
    struct edge
    {
        int to,next;
    }e[maxn<<4];
    int head[maxn],cnt=0;
    int f[maxn][51];
    int rudu[maxn];
    int w[maxn];
    inline void addedge(int u,int v)
    {
        e[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;
    }
    queue<int>q;
    void del(int x)
    {
        for(int i=head[x];i;i=e[i].next)
        {
            int v=e[i].to;
            rudu[v]--;
            if(!rudu[v]&&v!=1)q.push(v);
        }
    }
    int main()
    {
        scanf("%d%d%d%d%d%d%d",&n,&m,&k,&a,&b,&wa,&wb);
        int u,v;
        for(int i=1;i<=n;++i)u=read(),v=read(),w[u]+=v;
        for(int i=1;i<=k;++i)u=read(),v=read(),addedge(u,v),rudu[v]++;
        memset(f,-127,sizeof(f));
        for(int i=2;i<=m;++i)
            if(!rudu[i])q.push(i);
        while(!q.empty())
        {
            int u=q.front();q.pop();
            del(u);
        }
        q.push(1);
        f[1][0]=w[1];
        while(!q.empty())
        {
            int x=q.front();q.pop();
            del(x);
            for(int i=head[x];i;i=e[i].next)
            {
                int v=e[i].to;
                if(f[x][0]!=f[0][0])
                {
                    if(a!=1)f[v][a-1]=max(f[v][a-1],f[x][0]-wa);
                    else f[v][0]=max(f[v][0],f[x][0]-wa+w[v]);
                }
                if(f[x][0]!=f[0][0])
                {
                    if(b!=1)f[v][b-1]=max(f[v][b-1],f[x][0]-wb);
                    else f[v][0]=max(f[v][0],f[x][0]-wb+w[v]);
                }
                if(f[x][1]!=f[0][0])f[v][0]=max(f[v][0],f[x][1]+w[v]);
                for(int j=b;j>1;--j)
                    if(f[x][j]!=f[0][0])f[v][j-1]=max(f[v][j-1],f[x][j]);
            }
        }
        int ans=0;
        for(int i=1;i<=m;++i)ans=max(ans,f[i][0]);
        printf("%d\n",ans);
    }
```

---

## 作者：锅钢Carl (赞：2)

我WA了数次后，决定看题解，并拿出题人的程序来对拍，但是不管怎么对拍，输出结果都是一样的，然后再看一次题目，发现自己忽视了“不保证pos互不相同”这一条件……可见认真审题的重要性。

我的做法与出题人有点相似，但思维方式又有点不同，这里姑且讲一讲。

看完这题，我想到DAG上的DP，于是顺着这个思路来思考。

首先，对于题目中“她可以一次移动$a$个单位长度(称为小瞬移),也可以一次移动b个单位长度(称为大瞬移),分别会花费$wa,wb$点灵力”，也可以理解为，早苗从上一个被收集信仰的结点出发，走完$a$个单位长度，则**可以**收集当前结点的信仰，若要收集当前结点的信仰，则要花费$wa$的灵力；当早苗从上一个被收集信仰的结点出发，走完$b$个长度单位，则**必须**收集当前节点的信仰，并花费$wb$的灵力。

设$dp[i][j]$表示从上一个被收集信仰的结点出发，走$j$步到结点$i$时的(信仰数量-灵力耗费)的最大值，那么$dp[i][0]$则是表示结点i的信仰被收集，设$faith[i]$表示在结点$i$的信仰数。

$dp$数组初始时可全部赋值为$-∞$。

那么状态转移方程如下：（~~应该比较好想吧~~）

$dp[1][0]=faith[1]$

设结点u可直接走到结点v。

对于$1 \leq i < b,dp[v][i]=max(dp[v][i],dp[u][i-1])$

$dp[v][0]=max(dp[v][0],dp[u][a-1]+faith[v]-wa,dp[u][b-1]+faith[v]-wb)$

关于答案，则是对于$1 \leq i \leq m$，$ans=max(ans,dp[i][0])$

可能我的语言表达有些怪怪的，如果写错了些什么，可以发私信给我。

~~出题人说“难度主要集中在思维难度上”，然而我却觉得难度主要集中在审题上（雾）~~

C++代码如下：

```cpp
#include<cstdio>

#define maxn 100005
#define maxm 200005
#define maxk 300005
#define maxb 55
#define inf 0x3f3f3f3f

struct edge_type
{
    int to,next;
}e[maxk];
int head[maxm];
int in_degree[maxm];

int n,m,k;
int a,b,wa,wb;
int pos,faith[maxm];
int u,v;

int dp[maxm][maxb];

int ans;

inline void add_e(int u,int v,int x)
{
    e[x].to=v;
    e[x].next=head[u];
    head[u]=x;
}

int qhy[maxm],closed,open;

void bfs()
{
    int i;
    
    closed=0;
    open=1;
    qhy[1]=1;
    do{
        closed++;
        for(i=head[qhy[closed]];i;i=e[i].next)
        {
            if (in_degree[e[i].to]==0) qhy[++open]=e[i].to;
            in_degree[e[i].to]++;
        }
    }while (closed<open);
}

void top_sort()
{
    int i,j,tmp;
    
    closed=0;
    open=1;
    qhy[1]=1;
    dp[1][0]=faith[1];
    do{
        closed++;
        for(i=head[qhy[closed]];i;i=e[i].next)
        {
            for(j=1;j<b;j++)
                if (dp[e[i].to][j]<dp[qhy[closed]][j-1]) dp[e[i].to][j]=dp[qhy[closed]][j-1];
                
            if (dp[qhy[closed]][b-1]!=-inf&&dp[e[i].to][0]<dp[qhy[closed]][b-1]+faith[e[i].to]-wb)
                dp[e[i].to][0]=dp[qhy[closed]][b-1]+faith[e[i].to]-wb;
            
            if (dp[qhy[closed]][a-1]!=-inf&&dp[e[i].to][0]<dp[qhy[closed]][a-1]+faith[e[i].to]-wa)
                dp[e[i].to][0]=dp[qhy[closed]][a-1]+faith[e[i].to]-wa;
                
            in_degree[e[i].to]--;
            if (in_degree[e[i].to]==0) qhy[++open]=e[i].to;
        }
    }while (closed<open);
}

int main()
{
    int i,j,tmp;

    scanf("%d%d%d",&n,&m,&k);
    scanf("%d%d",&a,&b);
    scanf("%d%d",&wa,&wb);

    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&pos,&tmp);
        faith[pos]+=tmp;
    }
    
    for(i=1;i<=m;i++)
        for(j=0;j<b;j++) dp[i][j]=-inf;

    for(i=1;i<=k;i++)
    {
        scanf("%d%d",&u,&v);
        add_e(u,v,i);
    }
    
    bfs();
    top_sort();

    for(i=1;i<=m;i++)
        if (ans<dp[i][0]) ans=dp[i][0];
    
    printf("%d\n",ans);
    
    return 0;
}
```

---


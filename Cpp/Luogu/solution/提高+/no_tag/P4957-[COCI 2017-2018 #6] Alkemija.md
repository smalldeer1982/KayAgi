# [COCI 2017/2018 #6] Alkemija

## 题目描述

在古代，当炼金术士们在寻找黄金时，世界上已知共有 N 种不同的物质，用 1 到 N 表示。经过多年的努力，寻找秘密配方，炼金术士们发现了一系列有趣的规律——炼金反应。在一种反应中，可以将物质集合 $\{X_1, X_2, \ldots, X_L\}$ 转化为另一种物质集合 $\{Y_1, Y_2, \ldots, Y_R\}$。例如，物质集合 $\{1, 4, 5\}$ 可能反应一次并生成新的物质集合 $\{2, 6\}$。

Joško 是一位现代炼金术士，他拥有 M 种不同的物质，用 $A_1, A_2, \ldots, A_M$ 表示。他拥有这些物质的无限量。Joško 想知道他可以使用古代炼金术士的反应列表创造出哪些物质，所以他请你帮助他解决这个问题。

## 说明/提示

在总分值的 60% 的测试用例中，将满足：

- $N, K \leq 500$。
- 所有 L 值的总和和所有 R 值的总和不会超过 500。

**第一个测试用例的说明：**

有 2 个反应。

第一个反应将物质集合 $\{1, 2\}$ 转化为物质集合 $\{3\}$。

第二个反应将物质集合 $\{1, 3\}$ 转化为物质集合 $\{4\}$。

Joško 起初拥有物质集合 $\{1, 2\}$。

使用第一个反应，Joško 可以获得物质 3，之后他拥有物质集合 $\{1, 2, 3\}$。

之后，使用第二个反应，他还可以获得物质 4。

**第二个测试用例的说明：**

Joško 起初拥有物质集合 $\{1, 4, 5\}$。

使用第二个反应，可以获得物质 6，之后可以应用第三个反应，得到物质 2。

第一个反应无法应用，因为 Joško 没有物质 3。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
4 2
1 2
2
2 1
1 2
3
2 1
1 3
4
```

### 输出

```
4
1 2 3 4```

## 样例 #2

### 输入

```
6 3
1 4 5
3
3 2
2 3 4
1 6
1 3
4
1 5 6
1 1
6
2
```

### 输出

```
5
1 2 4 5 6```

# 题解

## 作者：zpy12345 (赞：10)

# [[COCI 2017/2018 #6] Alkemija](https://www.luogu.com.cn/problem/P4957)
蒟蒻的第一篇题解，不喜勿喷。
## 思路
这里介绍一个比较简单的模拟做法。可以按照题目要求模拟，先求出用初始物质可以发生的反应，把反应得到的新物质加入集合。执行上述操作，直到无法得到新物质，时间复杂度 $O(N\sum (L_{i}+R_{i}))$。考虑优化，我们发现这个算法慢在每一轮遍历了许多不必要的反应。容易发现，下一轮发生的每一个反应一定满足：其需要的物质至少有一个是这一轮的新产生物质（如果不是，那么该反应应该在更靠前的轮数就执行）。开个数组记录需要当前物质的反应编号即可。时间复杂度 $O(N+K+\sum (L_{i}+R_{i}))$。
::::::warning[警告]{open}
该优化为必要条件，并非充分条件，需要别的 $O(1)$ 判断来辅助。可以记录每个反应的需要物质中没有得到的数量，新得到这个反应的某个需要物质就 $-1$。
::::::
::::info[时间复杂度证明]
~~显然~~每个物质只会新出现一次，每个物质包含的反应数量总和 $=$ 每个反应包含的物质数量总和 $=$ $\sum L_{i}$。
::::

---

## 作者：xiangshengtao (赞：3)

### 首先，为什么是紫题？~~无语~~

## 题意

共有 $n$ 种物质，他已经有了 $m$ 种，以及有 $k$ 种变化，每种变化可以由 $L$ 个 $x_{i}$ 变成 $R$ 个 $y_{i}$。求最终可以产生哪些物质。

## 思路

可能刚看到题时，都是一头雾水（~~我也是这样~~），细看，一道拓扑模板题，只不过前面还得想到怎么处理。我们把每种变化的需要物质连向（ $n$ +第几组变化）这个新建点，再将（ $n$ +第几组变化）这个新建点连向变为的物质。之后做一遍拓扑，若这个点入度小于等于为 $0$，则它就是可以变成的物质。

## 一个注意点
$1\sim n$ 所有点（除了已经获得的$m$种物质）最开始都应为 $1$，因为只要有一种变化可以变出此物质，它就是可以的。

## 一个小陷阱

范围应开两倍，因为有新建点。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,k,x,y,z,j,s,num[200010],f[200010];//num为入度
vector<int>a[200010];
queue<int>q;
int main(){
    scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++) scanf("%d",&f[i]);
    scanf("%d",&k);
    for (i=1;i<=k;i++){
        scanf("%d%d",&x,&y);
        for (j=1;j<=x;j++) scanf("%d",&z),a[z].push_back(n+i);//将z连向新建点n+i
        num[n+i]=x;//新建点入度为x
        for (j=1;j<=y;j++) scanf("%d",&z),a[n+i].push_back(z);//将新建点n+i连向z
    }
    for (i=1;i<=n;i++) num[i]=1;//所有点入度为1
    for (i=1;i<=m;i++) num[f[i]]=0,q.push(f[i]);//已经获得的m个点入读设为0，进队列
    //拓扑
    while (!q.empty()){
    	x=q.front();
    	for (i=0;i<a[x].size();i++){
    		y=a[x][i];
    		num[y]--;
    		if (num[y]==0) q.push(y);
		}
		q.pop();
	}
    for (i=1;i<=n;i++)
        if (num[i]<=0) 
            s++;//满足条件s++
    printf("%d\n",s);
    for (i=1;i<=n;i++)
        if (num[i]<=0)
            printf("%d ",i);//输出满足条件的所有物质
    return 0;
}
```


---

## 作者：Karry5307 (赞：2)

### 题意

有 $n$ 种已知物质，现在手上有 $m$ 种，每种无限多个。已知 $k$ 种反应，每种可以将一些反应物变成一些生成物。求经过这些反应过后最多可以有多少种不同的物质。

$\texttt{Data Range:}1\leq m\leq n\leq 10^5,1\leq k\leq 10^5$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13881597.html)

由于考场上不会写各种暴力所以来练习一下如何写优雅的暴力。

首先注意到如果所有反应都是化合或分解的话就是建个图 DFS 一下就好了，但是有多变多的就不好做。

但是我们要有梦想。有一个非常暴力的方法是不断进行 $1\sim n$ 的所有反应，如果在一轮所有反应进行过后并不能使得物质种类数增加那么就认为我们得出了答案。

这个东西效率比较低下，于是考虑怎么优化。注意到如果已经进行了某个反应的话那么以后就再也不用进行了，因为再做还是只能得到那些生成物，相当于没用，所以一个反应最多进行一次。

不仅如此，这里还有第二个优化：考虑记录一下每个物质能参加哪些反应，这样当取出一个生成物的时候就能很快的知道这个物质可以参加哪些反应而不是 $O(k)$ 去找。

这里还有一个优化，配合第二个优化能跑得很快，就是可以不需要直接记录每个反应需要哪些物质，而是记录要完成这个反应还需要多少种物质，因为有第二个优化所以取出生成物的时候可以直接减 $1$，如果这个反应不需要物质的话那么就一定可以反应了。

最后，这 $k$ 个反应的依赖顺序组成了一个 DAG，所以可以用拓扑排序的思路来更新这些反应，于是就做完了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
queue<ll>q;
vector<ll>re[MAXN],g[MAXN];
ll n,m,kk,x,top,res;
ll vis[MAXN],visr[MAXN],l[MAXN],r[MAXN],need[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=m;i++)
	{
		vis[read()]=1;
	}
	kk=read();
	for(register int i=1;i<=kk;i++)
	{
		l[i]=read(),r[i]=read();
		for(register int j=1;j<=l[i];j++)
		{
			!vis[x=read()]?re[x].push_back(i),need[i]++:1;
		}
		for(register int j=1;j<=r[i];j++)
		{
			g[i].push_back(read());
		}
		!need[i]?q.push(i),visr[i]=1:1;
	}
	while(!q.empty())
	{
		top=q.front(),q.pop();
		for(register int i:g[top])
		{
			if(vis[i])
			{
				continue;
			}
			vis[i]=1;
			for(register int j:re[i])
			{
				!visr[j]&&!(--need[j])?q.push(j),visr[j]=1:1;
			}
		}
	}
	for(register int i=1;i<=n;i++)
	{
		res+=vis[i];
	}
	printf("%d\n",res);
	for(register int i=1;i<=n;i++)
	{
		vis[i]?printf("%d ",i):1;
	}
}
```

---

## 作者：_zexal_ (赞：1)

## 前言
今天考试考了这道题，~~这道题居然还是紫？建议评绿。~~ 特来写下此文。
## 思路
一种和拓扑排序差不多的方法，我们用 $dep_i$ 表示还差几个元素可以合成。用 $ans_i$ 表示差 $i$ 的合成方程是哪些，$answer_i$ 表示第 $i$ 个数合成之后可以带来的收益。并且使用一个数组记录每个元素是否现在拥有。同时我们也用一个队列记录可以立刻合成的数，我们将这个数的 $answer_i$ 拿出来，然后再通过 $ans_i$ 让缺 $answer_i$ 的 $dep_i$ 减去一，如果这个数 $dep_i$ 变成了 $0$ ，我们就入队，直到队列为空即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int dep[100005];// 第 i 个不等式还有多少没有
bool b[100005];//是否拥有i
vector<int> answer[100005],ans[100005];//第i个合成之后的物品
queue<int> Q;
int n,m,k,L,R,x,y,z,sum,num=1;
int main() {
	cin>>n>>m;
	sum=m;
	for(int i=1; i<=m; i++) {
		cin>>z;
		b[z]=1;
	}
	cin>>k;
	for(int i=1; i<=k; i++) {
		cin>>L>>R;
		for(int j=1; j<=L; j++) {
			cin>>x;
			if(b[x]==1) continue;
			dep[i]++;
			ans[x].push_back(i);
		}
		if(dep[i]==0) Q.push(i);
		for(int j=1; j<=R; j++) {
			cin>>x;
			answer[i].push_back(x);
		}
	}
	while(!Q.empty()) {
		for(int i=0;i<answer[Q.front()].size();i++){
				int num=answer[Q.front()][i];
				if(b[num]==0) sum++;
				b[num]=1;
				for(int j=0;j<ans[num].size();j++){
					dep[ans[num][j]]--;
					if(dep[ans[num][j]]==0) Q.push(ans[num][j]);
					ans[num][j]=0;
				}
			}
		Q.pop();
	}
	cout<<sum<<endl;
	for(int i=1; i<=n; i++) {
		if(b[i]) cout<<i<<" ";
	}
	return 0;
}
```


---

## 作者：chenruikai (赞：0)

### 题意
对于本题，虚假的考点：编程能力；真实的考点：英语水平。主要是那个翻译缺失了一些内容~~我的输入格式呢~~。

该题意思是给定 $M$ 个初始已有的元素（对，我看翻译以为初始的是要自己选的，那就变成另一个难度了）以及 $K$ 个转化关系，求最后能获得多少钟不同的元素。
### 解
首先，凭借由某些点推出某些点想到拓扑（这要是想不到就完啦）。而后的~~剧情~~思路可能是这样的。

由反应物中的每个点与生成物全都连一遍，然后暴力跑拓扑。

该算法的时间主要花在了建图上，可以有 $\Theta(KLR)$，显然是会 TLE 的。细想，如何减少边的数量。我们想到一种鬼畜的操作：把转换式看作一个点，由反应物向该点连边，再由该点向生成物连边。这样一来，所有反应物集齐时才可有转化的条件满足了，复杂度也减少到 $\Theta(K(L+R))$。

但是上述建图有个问题：若有多个转化式可以生成同一元素，则在拓扑排序时就要求所有反应都要进行才会生成，这是有违题意的。于是，这里需要特判一下，具体见代码（发动人类的智慧想想，其实简单的很）。

代码中 topo 部分中，$w$ 存储**新**产生的元素。大致逻辑是这样的：由反应物推出哪些反应可进行，再由反应推出可生成哪些。

$point$ 中前 $pointnum$ 个是元素，后面是代表转化式。

### CODE
```cpp
#include <bits/stdc++.h>
using namespace std;

struct cell
{
    vector <int> con;
    int deg;
    bool vis;
};
cell point[200005];
int pointnum , initnum , eqnum;
void addedge(int frompos , int endpos)
{
    point[frompos].con.push_back(endpos);
    point[endpos].deg++;
}
void topo()
{
    queue <int> w;int pos;
    for(int i = 0;i < pointnum;i++)
        if(point[i].vis)w.push(i);
    while(!w.empty())
    {
        pos = w.front();w.pop();
        for(int nextpos : point[pos].con)
            if(!(--point[nextpos].deg))
                for(int npos : point[nextpos].con)
                    if(!point[npos].vis)
                        {point[npos].vis = true;w.push(npos);}
    }
}
int main()
{
    cin >> pointnum >> initnum;
    for(int i = 0;i < pointnum;i++)
    {
        point[i].deg = 0;
        point[i].vis = false;
    }
    int pos , pren , afn;
    for(int i = 0;i < initnum;i++)
    {
        scanf("%d" , &pos);
        point[pos - 1].vis = true;
    }
    cin >> eqnum;
    for(int i = 0;i < eqnum;i++)
    {
        scanf("%d%d" , &pren , &afn);
        while(pren--)
        {
            scanf("%d" , &pos);
            addedge(pos - 1 , pointnum + i);
        }
        while(afn--)
        {
            scanf("%d" , &pos);
            addedge(pointnum + i , pos - 1);
        }
    }
    topo();
    int ans = 0;
    for(int i = 0;i < pointnum;i++)
        if(point[i].vis)ans++;
    cout << ans << '\n';
    for(int i = 0;i < pointnum;i++)
        if(point[i].vis)printf("%d " , i + 1);
    puts("");
    return 0;
}
```
玥玥月月如今朝。

---

## 作者：cosf (赞：0)

可以想到，如果第 $i$ 个反应可以发生，那么 $X_{i, 1}, X_{i, 2}, \dots, X_{i, L_i}$ 都需要可以量产。

于是我们想到 topo 里面的度数 $d$。当元素 $j$ 能够量产时，就把需要 $j$ 的所有反应 $i$ 的 $d_i$ 减去 $1$。当 $d_i$ 第一次成为 $0$ 时，对应的 $Y_{i, 1}, Y_{i, 2}, \dots, Y_{i, R_i}$ 都可以量产了。

于是就做完了。

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

#define MAXN 100005

vector<int> e[MAXN], f[MAXN];
int v[MAXN], d[MAXN];

int a[MAXN];

int n, m, k;

int main()
{
    cin >> n >> m;
    queue<int> q;
    for (int i = 1; i <= m; i++)
    {
        int a;
        cin >> a;
        v[a] = 1;
        q.push(a);
    }
    cin >> k;
    for (int i = 1; i <= k; i++)
    {
        int l, r;
        cin >> l >> r;
        d[i] = l;
        for (int j = 1; j <= l; j++)
        {
            int x;
            cin >> x;
            e[x].push_back(i);
        }
        for (int j = 1; j <= r; j++)
        {
            int y;
            cin >> y;
            f[i].push_back(y);
        }
    }
    int res = m;
    while (!q.empty())
    {
        int c = q.front();
        q.pop();
        for (int u : e[c])
        {
            d[u]--;
            if (d[u] == 0)
            {
                for (int z : f[u])
                {
                    if (!v[z])
                    {
                        q.push(z);
                        res++;
                        v[z] = 1;
                    }
                }
            }
        }
    }
    cout << res << endl;
    for (int i = 1; i <= n; i++)
    {
        if (v[i])
        {
            cout << i << ' ';
        }
    }
    cout << endl;
    return 0;
}

```

---

## 作者：xiaolu12356 (赞：0)

[[COCI2017-2018#6] Alkemija](https://www.luogu.com.cn/problem/P4957)

## 题意

一共有 $n$ 种物质，已知开始你有 $m$ 种物质且数量足够多，再给 $K$ 个物质的转化规则(一堆物质变成另一堆)，问一共能够得到多少种物质。

## 分析

- 对 $n$ 种物质和 $K$ 种转移分别建点，转化成图论问题。

- 一种物质显然只要有一个转移满足了就可以得到，而一种转移可以完成当且仅当所有需求物质已经得到。

- 直接 $\operatorname{bfs}$ 转移即可,转移的判定类似拓扑排序。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define go(u) for(int i=head[u],v=e[i].to;i;i=e[i].lst,v=e[i].to)
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define pb push_back
typedef long long LL;
inline int gi(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch))	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
template<typename T>inline bool Max(T &a,T b){return a<b?a=b,1:0;}
template<typename T>inline bool Min(T &a,T b){return b<a?a=b,1:0;}
const int N=2e5 + 7;
int edc,S,ndc,n,m;
int head[N],ind[N];
bool vis[N];
struct edge{
	int lst,to;
	edge(){}edge(int lst,int to):lst(lst),to(to){}
}e[N*10];
void Add(int a,int b){
	e[++edc]=edge(head[a],b),head[a]=edc;	
}
queue<int>Q;
void bfs(){
	Q.push(S);vis[S]=1;
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		go(u)if(!vis[v]){
			if(v>n){
				if(--ind[v]==0) vis[v]=1,Q.push(v);
			}else{
				vis[v]=1,Q.push(v);
			}
		}
	}
}
int main(){
	n=gi(),m=gi();S=n+1,ndc=S+1;
	rep(i,1,m) Add(S,gi());
	int Q=gi();
	while(Q--){
		int L=gi(),R=gi();++ndc;
		rep(i,1,L) Add(gi(),ndc),++ind[ndc];
		rep(i,1,R) Add(ndc,gi());
	}
	bfs();
	int ans=0;
	rep(i,1,n) if(vis[i]) ++ans;
	printf("%d\n",ans);
	for(int i=1,fi=1;i<=n;++i)if(vis[i]){
		if(fi) fi=0,printf("%d",i);
		else printf(" %d",i);
	}
	puts("");
	return 0;
}
```



---

## 作者：Feyn (赞：0)

[link](https://www.luogu.com.cn/problem/P4957)

首先这道题绝对没有紫，感觉就是一个模拟，~~估计大概率是恶评。~~

按照题目中的设定，一开始主角拥有的物品数量均为无限多，可以理解成这些物品用不完，也可以近似地理解成转换不需要消耗物品。这样一来很明显对于一种合法的转换，进行了转换不会有消耗却可能得到新物品，那么我们肯定会做这件事啊，不做白不做对吧。于是难点就变成了如何快速确定哪些转换是可以进行的。

显然一个转换可以进行当且仅当当前拥有所有转换所需的物品。于是我们可以开个数组来记录每个转换还有多少种物品未被满足，如果这个值被清零则立刻进行这个转换，显然这样一来每个转换只会被进行一次，复杂度就有了保证。但如何迅速更新上面的那个数组呢？考虑对于每个物品维护一个集合，集合中储存它被哪些转换需要，于是每个物品第一次被得到的时候就可以遍历这个集合更新对应转换的数组即可。

写了许多 COCI 的题发现它非常喜欢卡空间，什么 64M,32M 的题一大堆，于是我写的手写单链表，~~意外跑到了当前最优解。~~

```cpp
#include<bits/stdc++.h>
//#define feyn
const int N=100010;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}
inline int max(int s1,int s2){
	return s1<s2?s2:s1;
}

int m,n,nu,in,maxn;
bool s[N];

struct node{int data;node* nxt;};
inline void insert(node* &top,int data){
	node* now=new node();
	now->data=data;now->nxt=top;top=now;
}
inline void del(node* &top){top=top->nxt;}

node* pl[N];node* to[N];
int a[N],num[N];

inline void change(int wh);
inline void work(int wh){
	for(node* now=to[wh];now!=NULL;now=now->nxt)change(now->data);
}
inline void change(int wh){
	if(s[wh])return;s[wh]=true;
	for(node* now=pl[wh];now!=NULL;now=now->nxt){
		int th=now->data;num[th]--;
		if(num[th]==0)work(th);
	}
}

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	scanf("%d%d",&m,&n);
	for(register int i=1;i<=n;++i)scanf("%d",a+i),maxn=max(maxn,a[i]);
	scanf("%d",&nu);
	for(register int i=1;i<=nu;i++){
		int l,r;scanf("%d%d",&l,&r);num[i]=l;
		for(register int j=1;j<=l;++j){scanf("%d",&in);insert(pl[in],i);maxn=max(maxn,in);}
		for(register int j=1;j<=r;++j){scanf("%d",&in);insert(to[i],in);maxn=max(maxn,in);}
	}
	for(register int i=1;i<=n;++i)change(a[i]);
	int ans=0;
	for(register int i=1;i<=maxn;++i)ans+=s[i];
	printf("%d\n",ans);
	for(register int i=1;i<=maxn;++i)if(s[i])printf("%d ",i);
	
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4957)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~为什么是紫的呢？恶意评分吧。~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，这就是一个暴力+优化。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个暴力的方法可以很显然地看出来——每次枚举反应，如果发现当前反应所需的原料都有了，就可以将反应得到的物质标为“已得到”。一直这样迭代直到没有得到新的物质。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后很容易看出一个优化——因为已经得到的物质不会减少，所以之前已经检查为可以进行的反应就不用了再检查第二次了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们考虑将还没有确定为可以进行的反应放在一个序列里面，每次就检查这个序列里面的反应。如果检查出来一个反应可以进行就把这个反应从序列里面删除。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以优化。每次检查所需的物质够不够太慢了，我们直接记录每个反应缺少的材料总数$l$。我们将可以进行的反应放在一个队列里面。每次我们反应出新的一种物质，我们就把需要它的所有反应的$l$减少$1$。如果此时某个反应的需要物质足够了，我们就把它塞到队列里面。一直操作直到队列为空。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实整个操作就是类似于拓扑排序。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样运行时间就真正做到了$O(M+K+\sum L+\sum R)$  
# 代码
```cpp
#include <queue>
#include <cstdio>
#include <vector>
using namespace std;

const int MAXN = 100005, MAXM = 100005, MAXK = 100005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct reaction
{
	int L, R;
	int left;
	vector<int> spawn;
}r[MAXM];

queue<int> q;
vector<int> lis[MAXN], res;

int N, M, K, tot = 0;
bool avail[MAXN], used[MAXM];

int main()
{
	int num;
	read( N ), read( M );
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( num );
		avail[num] = true;
	}
	read( K );
	for( int ind = 1 ; ind <= K ; ind ++ )
	{
		read( r[ind].L ), read( r[ind].R );
		r[ind].left = 0;
		r[ind].spawn.clear();
		for( int i = 1 ; i <= r[ind].L ; i ++ )
		{
			read( num );
			if( ! avail[num] )
			{
				lis[num].push_back( ind );
				r[ind].left ++;
			}
		}
		for( int i = 1 ; i <= r[ind].R ; i ++ )
		{
			read( num );
			r[ind].spawn.push_back( num );
		}
		if( ! r[ind].left ) q.push( ind );
	}
	int cnt = 0, h, indx;
	while( ! q.empty() )
	{
		h = q.front();
		used[h] = true;
		q.pop();
		cnt ++;
		for( int i = 0 ; i < r[h].R ; i ++ )
		{
			indx = r[h].spawn[i];
			if( ! avail[indx] )
			{
				avail[indx] = true;
				for( int j = 0 ; j < lis[indx].size() ; j ++ )
				{
					if( ! used[lis[indx][j]] )
					{
						r[lis[indx][j]].left --;
						if( ! r[lis[indx][j]].left ) q.push( lis[indx][j] );
					}
				}
			}
		}	
	}
	res.clear();
	for( int i = 1 ; i <= N ; i ++ )
	{
		if( avail[i] ) res.push_back( i );
	}
	write( res.size() ), putchar( '\n' );
	write( res[0] );
	for( int i = 1 ; i < res.size() ; i ++ )
	{
		putchar( ' ' ), write( res[i] );
	}
	putchar( '\n' );
	return 0;
}
```

---

## 作者：亦笙箫 (赞：0)

~~**为什么紫题会出现在T2...**~~

这道题数据范围还是有点吓人的,但是我们其实可以不用开那么大.用$vector<vector<int>>$就好了.  
输入$n$之后和输入$k$之后我们要用$vector$自带的$resize$函数开大小.  
按照题目暴力即可,
  
## $Code$
  
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<set>

using namespace std;

int n,m,k,l,r;

set<int> a;

vector<int> sizes;
vector<vector<int>> has;
vector<vector<int>> gives;

int main()
{
//	freopen("alkemija.in","r",stdin);
//	freopen("alkemija.out","w",stdout);
	scanf("%d %d",&n,&m);
	has.resize(n);
	for(int i=0,x;i<m;i++)
		scanf("%d",&x),
		a.insert(x-1);
	scanf("%d",&k);
	gives.resize(k);
	sizes.resize(k);
	for(int i=0,x;i<k;i++)
	{
		scanf("%d %d",&l,&r);
		sizes[i]=l;
		while(l--)
		{
			scanf("%d",&x);
			has[x-1].push_back(i);
		}
		gives[i].reserve(r);
		while(r--)
		{
			scanf("%d",&x);
			gives[i].push_back(x-1);
		}
	}
	queue<int> q;
	for(const auto &i:a)
		for(const auto &j:has[i])
			if(--sizes[j]==0)
				q.push(j);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(const auto &i:gives[x])
		{
			if(a.find(i)==a.end())
			{
				a.insert(i);
				for(const auto &j:has[i])
					if(--sizes[j]==0)
						q.push(j);
			}
		}
	}
	printf("%d\n",(int)a.size());
	for(const auto &i:a) printf("%d ",i+1);
	printf("\n");
	return 0;
}
```


---

## 作者：mol_low (赞：0)

[题目传送门](https://www.luogu.org/problem/P4957)

### 题目描述
共有$n$种物质中，有$k$种反应。在每种反应中，$l$种物质生成$r$种物质。现有$m$种物质，每种物质有无限量，问最终可以由反应得到多少种物质(包括已有物质)，并输出这些物质的编号。

(我也不知道为什么本题不征求翻译，望管理员注意此事)
# 分析
~~本题的数据范围是用来吓人的~~，其实在极限数据下我们输入都要超时($k*(l+r)=100000^2$)......所以我们根本不需要注意数据范围，暴力即可。

我们将每种物质参与的反应记录下来(作为反应物质)，若已得到该物质，则将它参与的所有反应需要的物质数减一。当有反应需要的物质数为$0$时，我们就可以将生成物质全部视为得到，并重复上文的操作。最后，统计所有得到的物质并输出即可。

$Code:$
```
#include <bits/stdc++.h>
using namespace std;
#define N 100000

int n , m , k , ans;
bool have[N + 2];
vector<int> make[N + 2];
int num[N + 2];
bool Move[N + 2];
vector<int> Get[N + 2];

void del(int u);
void solve(int u);

template <typename _T>

void in(_T &x) {
	x = 0;
	char c = getchar();
	bool f = 1;
	while(c < '0' or c > '9') {
		if(c == '-') f = 0;
		c = getchar();
	}
	while(c >= '0' and c <= '9') {
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	if(!f) x = (~x) + 1;
}

template <typename _T>

void out(_T x) {
	if(x < 0) {
		x = (~x) + 1;
		putchar('-');
	}
	if(x >= 10) out(x / 10);
	putchar(x % 10 + '0');
}

int main() {
	in(n);in(m);
	int x , r;
	for(int i = 1; i <= m; ++ i) {
		in(x);
		have[x] = 1;
	}
	in(k);
	for(int i = 1; i <= k; ++ i) {
		in(num[i]);in(r);
		for(int j = 1; j <= num[i]; ++ j) in(x) , make[x].push_back(i);
		for(int j = 1; j <= r; ++ j) in(x) , Get[i].push_back(x);
	}
	for(int i = 1; i <= n; ++ i) if(have[i]) del(i);
	for(int i = 1; i <= n; ++ i) if(have[i]) ++ ans;
	out(ans);putchar('\n');
	for(int i = 1; i <= n; ++ i) if(have[i]) out(i) , putchar(' ');
	return 0;
}

void del(int u) {
	if(Move[u]) return;
	Move[u] = 1;
	int S = make[u].size();
	for(int i = 0; i < S; ++ i) {
		-- num[make[u][i]];
		if(!num[make[u][i]]) solve(make[u][i]);
	}
}

void solve(int u) {
	int S = Get[u].size();
	for(int i = 0; i < S; ++ i) have[Get[u][i]] = 1;
	while(!Get[u].empty()) {
		del(Get[u].back());
		Get[u].pop_back();
	}
}
```

---


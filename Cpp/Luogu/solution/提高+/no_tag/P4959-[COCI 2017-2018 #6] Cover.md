# [COCI 2017/2018 #6] Cover

## 题目描述

给定坐标系中的 N 个点。需要用一个或多个矩形覆盖这些点，使得满足以下条件：

- 每个矩形的边平行于坐标轴，
- 每个矩形的中心在原点，即点 (0, 0)，
- 每个给定点要么在矩形内部，要么在其边界上。

当然，可以用一个矩形覆盖所有的点，但这个矩形可能会有非常大的面积。我们的目标是找到所需矩形的选择，使得它们的面积总和最小。

## 说明/提示

在占总分 40% 的测试用例中，将满足 N ≤ 20。

**第一个测试用例的说明：** 我们选择以给定点为对角的矩形，因为它满足题目中的条件。

**第二个测试用例的说明：** 我们选择两个中心在原点的矩形。第一个矩形的尺寸为 50 x 20，覆盖点 (25, 10)。第二个矩形的尺寸为 18 x 60，覆盖前两个点。如果我们想用一个矩形覆盖所有点，它的尺寸将是 50 x 60。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2
1 1
-1 -1```

### 输出

```
4```

## 样例 #2

### 输入

```
3
-7 19
9 -30
25 10
```

### 输出

```
2080```

## 样例 #3

### 输入

```
6
1 20
3 17
5 15
8 12
9 11
10 10```

### 输出

```
760```

# 题解

## 作者：_maojun_ (赞：8)

提供一种复杂度更优的做法。

---

首先可以观察到可以另 $\forall x_i\gets\left| x_i\right|,y_i\gets\left| y_i\right|$，然后求出以原点为左下角的矩形最小面积覆盖，其四倍即是答案。

考虑一对偏序 $(p,q),x_p\le x_q$ 且 $y_p\le y_q$，那么如果用矩形覆盖了 $q$ 时，就一定覆盖了 $p$。于是去掉这些不会产生贡献的点。

称以原点为左下角 $(x,y)$ 为右上角的矩形为一个点 $(x,y)$ 的原始矩形，则先设每个点都由自己的原始矩形覆盖，再合并去优化。

考虑剩下的点有什么性质。若按 $x$ 坐标递增排序，则 $y$ 坐标一定是对应递减的。那么若要合并，一定是一段连续的区间。

不然，比如 $i$ 点采用的是原始矩形，而 $i-1,i+1$ 合并，那么因为 $x_{i+1}>x_i,y_{i-1}>y_i$，所以 $i$ 点已经被包含，采用原始矩形一定不优。

于是我们可以在排序后的点上 dp，设 $f_i$ 表示前 $i$ 个点的矩形最小面积覆盖。每次枚举一个 $j\in[0,i)$ 表示合并 $(j,i]$。因为 $j+1\le i$ 所以 $x_{j+1}\le x_i,y_{j+1}\ge y_i$，所以合并出来矩形的面积为 $x_i\times y_j$。

则可得到转移方程 $f_i=\min\limits_{0\le j<i}f_j+x_i\times y_{j+1}$，复杂度 $O(n^2)$，可以通过。

```cpp
#define pi pair<int,int>
#define fi first
#define se second
#define mp make_pair

typedef long long ll;
const int MAXN=5e3+5,INF=0x3f3f3f3f;
int n;pi a[MAXN];
ll dp[MAXN];

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d%d",&a[i].fi,&a[i].se);a[i].fi=abs(a[i].fi);a[i].se=abs(a[i].se);}
	sort(a+1,a+n+1,greater<pi>());// 先按 x,y 降序排序
	int mxy=0,tot=0;
	for(int i=1;i<=n;i++)		// 若 x 比该点大且 y 不比该点小，则该点被偏序
		if(a[i].se>mxy){a[++tot]=a[i];mxy=a[i].se;}
	n=tot;for(int i=1;i<=n>>1;i++)swap(a[i],a[n-i+1]);// 之前为了方便将 x 降序，这里反转一下
	memset(dp,0x3f,n+1<<3);dp[0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			dp[i]=min(dp[i],dp[j]+a[i].fi*1ll*a[j+1].se);
	printf("%lld\n",dp[n]<<2);	// 最后乘 4
	return 0;
}
```

然后你发现状态其实是 $O(n)$ 级别的，凭什么复杂度到 $O(n^2)$ 了呢？

这个转移的形式特别好，典型的斜优，而且 $f$ 单调递增，一个单调队列就好了。

复杂度 $O(n\log n)$ 或 $O(n)$，瓶颈在排序。

```cpp
#define pi pair<int,int>
#define fi first
#define se second
#define mp make_pair

typedef long long ll;typedef double db;
const int MAXN=5e3+5,INF=0x3f3f3f3f;
int n;pi a[MAXN];
ll dp[MAXN];

inline ll X(int i){return a[i+1].se;}inline ll Y(int i){return-dp[i];}
inline db K(int i,int j){return(Y(j)-Y(i))*1.0/(X(j)-X(i));}
int l,r,q[MAXN];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d%d",&a[i].fi,&a[i].se);a[i].fi=abs(a[i].fi);a[i].se=abs(a[i].se);}
	sort(a+1,a+n+1,greater<pi>());
	int mxy=0,tot=0;
	for(int i=1;i<=n;i++)
		if(a[i].se>mxy){a[++tot]=a[i];mxy=a[i].se;}
	n=tot;for(int i=1;i<=n>>1;i++)swap(a[i],a[n-i+1]);
	dp[q[l=r=1]=0]=0;
	for(int i=1;i<=n;i++){
		while(l<r&&K(q[l],q[l+1])<a[i].fi)l++;
		dp[i]=dp[q[l]]+a[i].fi*1ll*a[q[l]+1].se;
		while(l<r&&K(i,q[r])<K(q[r],q[r-1]))r--;
		q[++r]=i;
	}
	printf("%lld\n",dp[n]<<2);
	return 0;
}
```

---

## 作者：路人丙 (赞：6)

#### 思路
一看就是动态规划了，首先数据要处理一下
- 所有点都转到第一象限
- 如果有x[a]>x[b]&&y[a]>y[b]那么点b可以忽略


然后正常做，把筛出来的点按x排个序

```
dp[i][0]  表示点i处新建一个矩形时的最小面积

dp[i][1]  表示不新建时的最小面积

方程：
dp[i][0]=w[i]+min(dp[i-1][0],dp[i-1][1]);
dp[i][1]=min(dp[j][0]+(x[i]-x[j])*y[j]);（1<=y<i）
```
效率貌似是O(n^2)的,不过数据应该比较随机，还是过了
#### 代码
```cpp
#include<bits/stdc++.h>
#define P pair<int,int>
using namespace std;
int n;
long long x[5001];
long long y[5001];
P p[5001];
int num=0;
long long dp[5001][2]={0};
int main()
{
    cin>>n;

    for(int i=1;i<=n;i++)
    {
        cin>>p[i].second>>p[i].first;
        p[i].first=abs(p[i].first);
        p[i].second=abs(p[i].second);
    }
    sort(p+1,p+n+1);
    int maxx=p[n].second;
    y[++num]=p[n].first;
    x[num]=p[n].second;
    for(int i=n-1;i>=1;i--)
    {
        if(p[i].second>maxx)
        {
            maxx=p[i].second;
            x[++num]=maxx;
            y[num]=p[i].first;
        }
    }
    for(int i=1;i<=num;i++)
    {
        dp[i][0]=x[i]*y[i]+min(dp[i-1][0],dp[i-1][1]);
        dp[i][1]=dp[i][0];
        for(int j=1;j<i;j++)
        {
            dp[i][1]=min(dp[i][1],dp[j][0]+(x[i]-x[j])*y[j]);
        }
    }
    long long ans=min(dp[num][0],dp[num][1]);
    cout<<ans*4;
}

```


---

## 作者：naturelyf (赞：3)

##### 题外话
也是做的模拟赛，但是是第一题比较简单~~建议降绿~~，一口气把就把一二（[第二题](https://www.luogu.com.cn/problem/P6497)）题打出来了。
### 题目大意
给定 $n$ 个点，要求你给出几个关于原点对称的矩形，覆盖所有给出的点，求这些矩形最小面积之和。
### 解题思路
#### 暴力
看到数据范围 $n\le5000$ 就能反应过来应该是 $O(n^2)$ 或 $O(n\log n)$ 的做法。由于矩形是中心对称的，所以这些点无论在哪个象限都可以转化到第一象限，这样会好考虑很多。本人觉得第三组样例给的很好，先来分析一下它：显然是一个 $2 \times 40$ 和一个 $20 \times 34$ 的矩形，在手搓样例的时候发现，从左往右每枚举到一个没有被覆盖的点时，有两种可能，要不由前面某个矩形拓展来覆盖，要不自己单独形成一个矩形。


看到了这里，就应该想到动态规划了，状态就这么设计：$f_i$ 表示第 $i$ 个点和之前所有点被覆盖的最小面积。那么状态这么转移呢？按照手推来：枚举每个小于 $i$ 的点，看是从那个点拓展过来还是自己开一个矩形，具体的：$f_i=f_i+pr*x_i$ 其中 $j$ 为我们枚举的那个点，$pr$ 是从 $j$ 到 $i-1$ 最大的 $y$ 值，因为要覆盖 $i$ 前的所有点，所以要找最大值。具体代码如下：
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int N=5010;
struct node{
	int x,y;
	bool friend operator<(node a,node b){
		return a.x<b.x;
	}
}e[N];
int x[N],y[N];
int n;
int f[N];
signed main(){
//	freopen("cover.in","r",stdin);
//	freopen("cover.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>e[i].x>>e[i].y;
		e[i].x=abs(e[i].x),e[i].y=abs(e[i].y);
	}
	sort(e+1,e+n+1);//按照x排序，从左往右
	for(int i=0;i<=n;i++)f[i]=1e18;
	f[0]=0;  
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			int pr=0;
			for(int k=j+1;k<=i;k++)pr=max(pr,e[k].y);
			f[i]=min(f[i],f[j]+1ll*pr*e[i].x);
		}
	}
	cout<<f[n]*4;
	return 0;
}
```
这样就······TLE 了，因为我们的做法是 $O(n^3)$ 的做法，比我们预想的要大，考虑优化。
#### 优化做法
看到找最大值那步，不就是 RMQ 问题嘛（不会看这里[模板](https://www.luogu.com.cn/problem/P3865)），直接把 ST 表打上，这样就优化掉一个 $n$ 了（ST 表 $O(1)$ 查询），优化后代码如下：
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int N=5010;
struct node{
	int x,y;
	bool friend operator<(node a,node b){
		return a.x<b.x;
	}
}e[N];
int x[N],y[N];
int n;
int f[N];
int st[N][15];
int query(int l,int r){
	int k=__lg(r-l+1);
	return max(st[l][k],st[r-(1<<k)+1][k]);
}//O(1)查询
signed main(){
//	freopen("cover.in","r",stdin);
//	freopen("cover.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>e[i].x>>e[i].y;
		e[i].x=abs(e[i].x),e[i].y=abs(e[i].y);
	}
	sort(e+1,e+n+1);
	for(int i=1;i<=n;i++)st[i][0]=e[i].y;
	for(int j=1;j<=14;j++){
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	for(int i=0;i<=n;i++)f[i]=1e18;
	f[0]=0;  
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			int pr=query(j+1,i);
			f[i]=min(f[i],f[j]+1ll*pr*e[i].x);
		}
	}
	cout<<f[n]*4;
	return 0;
}
```
完结撒花！

---

## 作者：wqc2011 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4959)

### 思路
首先，我们会发现，对于任意一个点 $(x,y)$，它都可以转换到第一象限，如下图。
![如何将点转入第一象限](https://cdn.luogu.com.cn/upload/image_hosting/7bs2sgdn.png)
对于所有点 $(x,y)$，我们进行如下操作。
$$|x| \to x,|y| \to y$$
接着，我们不考虑被其它点覆盖的点，如下图，$B$ 点不被考虑（它被 $A$ 覆盖），而 $C$ 点会被考虑。
![点的覆盖](https://cdn.luogu.com.cn/upload/image_hosting/soupyvkw.png)
我们考虑对这些不能被其他点覆盖的点进行排序，再进行 $dp$ 即可。
### 代码如下

```cpp
#include<bits/stdc++.h>
#define int long long
#pragma GCC optimize(3)
using namespace std;
const int maxn = 5010;
const int inf = 1e9;
//unsigned long long 
//cout << fixed << setprecision(3)
//cout << setw(5) << 
//continue
struct S{
	int x, y;
}a[maxn];
int dp[maxn], id[maxn];
bool cmp(S a, S b){
	if(a.x != b.x) return a.x > b.x;
	return a.y > b.y;
}
signed main(){
    //freopen("a.in", "r", stdin);
    //freopen("a.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, cnt = 0;
    cin >> n;
    for(int i = 1;i <= n;i++){
    	cin >> a[i].x >> a[i].y;
    	a[i].x = abs(a[i].x);
    	a[i].y = abs(a[i].y);
    }
    sort(a + 1, a + 1 + n, cmp);
    for(int i = 1;i <= n;i++){
    	int st = i;
    	while(i <= n && a[st].x >= a[i].x && a[st].y >= a[i].y) i++;
    	i--;
    	cnt++;
    	dp[cnt] = dp[cnt - 1] + a[st].x * a[st].y;
    	id[cnt] = st;
    	for(int j = cnt - 1;j >= 1;j--){
    		dp[cnt] = min(dp[cnt], dp[j - 1] + a[id[j]].x * a[st].y);
    	}
    }
    cout << dp[cnt] * 4;
    return 0;
}
```
感谢阅读。

---

## 作者：zzzyyyyhhhhh (赞：0)

发现可以将所有点转换到第一象限上，这样问题就转化成了选定一些矩形覆盖所有的点，矩形的一个顶点位于原点。发现一些点具有如下性质，覆盖这个点的矩形一定覆盖到其他几个点，如覆盖 $A(10,10)$ 就一定会覆盖 $B(1,1)$ 此时像 $B$ 这样的点就可以不考虑，最后要考虑的点形成一个二维偏序形式，对于点 $i$ 有 $ x_{i+1}>x_i,y_{i+1}<y_i$，称要考虑的点为关键点，对这些点按横坐标排序。

然后就可以设计 dp 状态了，设 $f_i$ 表示区间 $[i,n]$ 的关键点都被覆盖，其余关键点没被覆盖的答案，转移是每次枚举一个高度 $y$ 并用 $f_{i+1}$ 加上 $y\times x_i$ 更新 $f_j$ ，下标为 $j$ 的点是第一个纵坐标值小于等于 $y$ 的点。 

注意离散化。

code:

```clesslessslesssss
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 6000;
struct ma
{
	int x,y;
}p[N],pp[N];
bool cmp(ma x,ma y)
{
	if(x.x!=y.x)return x.x>y.x;
	return x.y>y.y;
}
int xx[N],yy[N];
int n;
int tot;
int hi;
int f[N];
int to[N];
signed main()
{
	cin>>n;
	int x,y;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		x=abs(x),y=abs(y);
		xx[i]=x;
		yy[i]=y;
		p[i]={x,y};
	}
	sort(xx+1,xx+1+n);
	sort(yy+1,yy+1+n);
	int cnt,cnt1;
	cnt=unique(xx+1,xx+1+n)-xx-1;
	cnt1=unique(yy+1,yy+1+n)-yy-1;
	for(int i=1;i<=n;i++)
	{
		p[i]={lower_bound(xx+1,xx+1+cnt,p[i].x)-xx,
			  lower_bound(yy+1,yy+1+cnt1,p[i].y)-yy,};
	}
	sort(p+1,p+1+n,cmp);
	int ans=0;
	memset(to,0x3f,sizeof to);
	for(int i=1;i<=n;i++)
	{
		if(p[i].y>hi)
		{
			hi=p[i].y;
			pp[++tot]=p[i];
		}
	}
	reverse(pp+1,pp+1+tot);
	for(int i=1;i<=tot;i++)
	{
		to[pp[i].y]=min(to[pp[i].y],i);
	}
	memset(f,0x3f,sizeof f);
	f[tot+1]=0;
	for(int i=tot;i>=1;i--)
	{
		for(int j=pp[i].y;j<=cnt1;j++)
		{
			if(to[j]>1e6)continue;
			f[to[j]]=min(f[to[j]],f[i+1]+yy[j]*xx[pp[i].x]*4);
		}
		for(int j=2;j<=tot;j++)
		{
			f[i]=min(f[i-1],f[i]);
		}
	}
	cout<<f[1];
}

```

---

## 作者：Bulyly (赞：0)

### $40pts$ 做法
由于 $n\le20$，我们考虑状压记录覆盖哪些点，需要的最少面积。思考如何转移。枚举子集显然不可做会超时。套路地，考虑思考从必要的步骤转移。我们发现，对于当前点集 $S$，记录其中 $y$ 的绝对值最大的点为 $a$,如果需要覆盖这些点，必然需要一个 $(2\times y_{max})\times x$ 的矩形去覆盖。考虑 $x$ 如何得到，显然最优情况一定是边界在某个点上时。于是我们枚举这个 $y$ 最大的矩形覆盖了哪些点来转移。具体的，我们记录当哪些点中的 $y_{max}$ 点与当前 $y_{max}$ 点相同且是其子集即可。复杂度 $O(2^n)$。[code](https://www.luogu.com.cn/paste/w9o5wz9e)。

### $100pts$ 做法

~~好像和楼上的不太一样。~~

我们真的需要去找子集吗？根据矩形中心在原点的性质，考虑将所有点转到第一象限。接着我们发现覆盖是对区间内**连续**的点进行覆盖。到这里，做法已经显然。将所有点按 $x$ 排序。定义 $f_i$ 表示覆盖到前 $i$ 个点所需要的最小面积，转移就从前面枚举一个分界点即可。复杂度 $O(n^2)$，代码比之前的做法短很多。[code](https://www.luogu.com.cn/paste/zcjbb13s)。



---


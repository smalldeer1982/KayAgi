# 二进制之谜

## 题目背景

虽然过了$Faded$，但是小埋还是没有解出二进制之谜。

## 题目描述

这个时候，她感觉到了$0$与$1$存在的某种可能的特殊对应关系。于是，她定义了“启发系数”：对应的两个数位数（按从高位到低位顺序去数）的差的绝对值；她现在希望将$0$与$1$进行对应使得**在对应关系最多的前提下**，启发系数之和最大。

对应规则如下：

$1$.对应关系必须从$0$开始，以$1$结束；换句话说，每个对应关系必须$0$在前（高位），$1$在后（低位）；

$2$.可以取若干个对应关系，但对应关系之间**不能交叉**；**交叉**的含义是：共用某个区间且不是包含关系；

$e.g.$ 假设一个对应关系为第$2$位数与第$4$位数，另一个对应关系为第$3$位数与第$5$位数，那么它们不可同时取，因为在区间$[3,4]$交叉；但是若对应关系分别为第$1$、$5$位数与第$2$、$4$位数，则不算作交叉，因为它们虽然共用区间$[2,4]$但存在包含关系，可以同时取。

![avatar](https://cdn.luogu.com.cn/upload/pic/38793.png)

这即是说，**交叉不等于交集**。

$3$.每个数最多只能存在于一个对应关系中。

## 说明/提示

对于$30$%的数据，$0<n<=20$；

对于$100$%的数据，$0<n<=300$；

**样例说明**

对于样例一，由于$1$在$0$前面，两者不能对应；

对于样例二，对应方案为$3-4$，故总和为$1$。


如果您提前$AK$了，可以做一下[数据增强版](https://www.luogu.org/problemnew/show/T53667)

## 样例 #1

### 输入

```
2
10```

### 输出

```
0```

## 样例 #2

### 输入

```
6
110100```

### 输出

```
1```

# 题解

## 作者：QuantAsk (赞：6)

## 堆$n\ log\ n$解法

# 正题
题目链接:https://www.luogu.org/problemnew/show/P4989

------------

## 题目大意
一个二进制数两两配对，要求
1. 配对的数不能交叉(用同一个区间但不包含)
2. 0在前1在后

要求配对最多的情况下所有配对的距离之和最远。

-------------

## 解题思路
将0视为左括号，1视为右括号，题目变为括号匹配问题。

我们考虑贪心，先是交叉的问题，我们发现如果两个交叉了，我们让他们反过来配对(配对方的那个)的话答案并不会改变。所有我们不要考虑交叉问题。

那我们开始做，首先不考虑配对最多，我们可以开一个小根堆，存储目前所有已经匹配的右括号还有未左括号的位置。然后我们每次到一个右括号时，取出最小的那个与其匹配并计算多出来的代价。然后从新丢入堆中。

这是距离之和最远，但是配对最多怎么办，那么我们定义权值，小根堆维护权值。对于已经匹配的右括号我们权值就是它的位置；对于没有匹配的左括号，我们让它的权值加上一个$-inf$就可以了。

这样就可以保证优先匹配没有匹配的且权值最大。

时间复杂度$O(n\ log\ n)$

--------------

## $code$
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
struct node{
	int wz,w;
};
bool operator <(const node &a,const node &b)
{return a.w<b.w;}
priority_queue<node> q;
int n,ans,a[1000];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		char c;cin>>c;
		a[i]=c-'0';
	}
	for(int i=1;i<=n;i++)
	{
		if(!a[i]) q.push((node){i,233333333-i});
		else{
			if(q.empty()) continue;
			ans+=i-q.top().wz;q.pop();
			q.push((node){i,-i});
		}
	}
	printf("%d",ans);
}
```


---

## 作者：Untitled_unrevised (赞：2)

### 解法

用力贪心就完事了。

队列 $q_0$ 记录没被匹配的 `'0'` 的下标；

队列 $q_1$ 记录已经匹配的 `'1'` 的下标。

从左往右处理字符串：

1. 遇到 `'0'`，就把下标 $\mathrm{idx}_0$ 放入队列 $q_0$ 中；

2. 遇到 `'1'`，如果队列 $q_0$ 非空，弹出队首 $\mathrm{idx}_0$，把下标为 $\mathrm{idx}_0$ 的 `'0'` 与当前下标为 $\mathrm{idx}_1$ 的 `'1'` 匹配，加上启发系数 $\mathrm{idx}_1 - \mathrm{idx}_0$，然后把 $\mathrm{idx}_1$ 放入队列 $q_1$ 中；

3. 遇到 `'1'`，如果队列 $q_0$ 已空，表示前面已经没有 `'0'` 可以跟它匹配了。先将当前下标 $\mathrm{idx}_1$ 丢入队列 $q_1$ 中，然后弹出 $q_1$ 的队首 $\mathrm{idx}_1'$，将启发系数减去 $\mathrm{idx}_1'$ 再加上 $\mathrm{idx}_1$。（也就是将原先匹配到位于 $\mathrm{idx}_1'$ 的 `'1'` 的 `'0'` 匹配到位于 $\mathrm{idx}_1$ 的 `'1'`）

### 正确性

可以看到这种做法根本没去考虑交叉的问题。实际上也根本不需要去考虑这种问题。以下是解释：

如果一个 `0-1` 对 $(\mathrm{idx}_0, \mathrm{idx}_1)$ 与另一个 `0-1` 对 $(\mathrm{idx}_0', \mathrm{idx}_1')$ 交叉了，假定 $\mathrm{idx}_0 < \mathrm{idx}_0' < \mathrm{idx}_1 < \mathrm{idx}_1'$，光看这个不等式应该都能想到了：把两个 `0-1` 对换成 $(\mathrm{idx}_0, \mathrm{idx}_1')$ 和 $(\mathrm{idx}_0', \mathrm{idx}_1)$ 就可以了。

启发系数还是 $\mathrm{idx}_1 + \mathrm{idx}_1' - \mathrm{idx}_0 - \mathrm{idx}_0'$。

然后是怎么保证对应关系最多：

根据 2.，每次遇到 `'1'` 的时候，只要前面还有没匹配的 `'0'`，就一定会去匹配它。

如果前面没有匹配的 `'0'` 了，不会添加新的 `0-1` 对。因为后面的 `'0'` 无法匹配前面的 `'1'`。

最后是怎么保证启发系数最大：

对于每个 `0-1` 对，它会贡献 $\mathrm{idx}_1 - \mathrm{idx}_0$ 的启发系数。

让 $\mathrm{idx}_0$ 尽可能小就可以让启发系数尽可能大。由于是从左往右扫描字符串，又使用队列这一数据结构，我们保证了队首的 $\mathrm{idx}_0$ 是最小的。

让 $\mathrm{idx}_1$ 尽可能大就可以让启发系数尽可能大。根据 3.，在遇到已经没有未匹配的 `'0'` 的情况下，让启发系数减去尽可能小的 $\mathrm{idx}_1'$（已经匹配的 `'1'` 中下标最小的）再加上当前的下标 $\mathrm{idx}_1$ 就可以让启发系数尽可能大。同样地，从左往右扫描字符串，并使用队列来维护最小的 $\mathrm{idx}_1'$。

还有一个是关于 3. 的一个需要注意的地方：为什么是先插入再弹出？

如果之前根本没有匹配的 `0-1` 对，先弹出再插入会试图对空的 $q_1$ 执行弹出操作，而先插入后弹出则可以巧妙地避开这一问题。

至于是先加还是先减，其实不重要。因为在类型相同的情况下，溢出了也能修正回来。

------------

综上，我们得到了时间复杂度 $O(n)$ 的算法，甚至支持从尾端在线插入，不需要提前知道 $n$ 的值，拿来解这道题可谓绰绰有余了。

参考代码：

```cpp
#include <stdio.h>
#include <queue>

typedef unsigned long long u64;

inline void nextint() {
	int ch = getchar();
	while(ch >  '9' || ch <  '0') ch = getchar();
	while(ch >= '0' && ch <= '9') ch = getchar();
}

inline void run() {
	
	char ch = getchar();
	std::queue<u64> zerolist, onelist;
	
	while(ch > '1' || ch < '0') ch = getchar();
	u64 idx = 0, zerosum = 0, onesum = 0;
	
	while(ch >= '0' && ch <= '1') {
		if(ch == '0')
			zerolist.push(idx);
		else if(!zerolist.empty()) { // get 1, no-empty
			onesum += idx;
			zerosum += zerolist.front();
			zerolist.pop();
			onelist.push(idx);
		}
		else { // get 1, empty
			onelist.push(idx);
			onesum += idx;
			onesum -= onelist.front();
			onelist.pop();
		}
		++idx;
		ch = getchar();
	}
	
	printf("%llu", onesum - zerosum);
	
}

int main() {
	nextint(); // 过滤 n 的值，因为在这个算法中不重要
	run();
	return 0;
}
```

嗷呜一下~

---

## 作者：ShineEternal (赞：2)

# 为了让大家看起来方便，于是验题人就把题解放进来了，相关题目请点击[这里](https://blog.csdn.net/kkkksc03/article/details/83239164)

## T3

题意略。

**Solution 0**

我们可以有信仰！~~输出0，期望得分0。~~

**Solution 1**

我们可以暴力！枚举所有组合状态，期望得分30。

**Solution 2**

建图跑费用流。

将所有0视为源点，所有1视为汇点，当然这样是跑不了网络流的，所以我们设置超级源点与超级汇点分别与所有源点和所有汇点相连，由于每个0和1只能用一次，这些边的费用为0，容量为1。

之后处理二进制数，将每一个0与其后面的1连一条费用为两者位数差的绝对值且容量为1的边。

这样建图就完成了，跑一遍费用流即可。

但这里有个问题：如何保证它们不交叉？

其实显然可以发现，同样的几个数，不管对应关系交叉还是不交叉，总启发系数是相等的，这样我们就无需另外特殊处理了。

时间复杂度在$O(n^3)$~$O(n^4)$之间，期望得分100分。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
    int n,first;
    char c[501]; 
    int w[502][502];
    bool f[502][502];
    int stack[502];
    int dist[502];
    int pre[502];
    bool vis[502];
int check()
{
    int top=1;
    stack[1]=0;
    for (int i=1;i<=n+1;i++)
        dist[i]=-2147483647;
    dist[0]=0;
    memset(vis,false,sizeof(vis));
    vis[0]=true;
    while (top>0)
    {
        int now=stack[top];
        top--;
        vis[now]=false;
        for (int i=0;i<=n+1;i++)
            if (f[now][i]&&dist[now]+w[now][i]>dist[i])
            {
                dist[i]=dist[now]+w[now][i];
                pre[i]=now;
                if (!vis[i])
                {
                    vis[i]=true;
                    stack[++top]=i;
                }
            }
    }
    return dist[n+1]; 
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        char s;
        s=getchar();
        while (s!='0'&&s!='1') s=getchar();
        c[i]=s;
    }
    for (int i=1;i<=n;i++)
    {
        if (c[i]=='0')
        {
            w[0][i]=0;
            w[i][0]=0;
            f[0][i]=1;
            f[i][0]=0;
        }
        else
        {
            w[i][n+1]=0;
            w[n+1][i]=0;
            f[i][n+1]=1;
            f[n+1][i]=0;
        }
        for (int j=i+1;j<=n;j++)
            if (c[i]=='0'&&c[j]=='1')
            {
                w[i][j]=j-i;
                w[j][i]=-(j-i);
                f[i][j]=1;
                f[j][i]=0;
            }
    }
    int ans=0;
    bool find=false;
    while (!find)
    {
        int del=check();
        if (del==-2147483647)
            find=true;
        else
        {
            ans+=del;
            int t=n+1;
            while (t!=0)
            {
                f[t][pre[t]]=!f[t][pre[t]];
                f[pre[t]][t]=!f[pre[t]][t];
                t=pre[t];
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```


---


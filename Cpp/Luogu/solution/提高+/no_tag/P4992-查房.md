# 查房

## 题目背景

答疑请到： https://www.luogu.org/discuss/show?postid=79498

$sqn$是个电子游戏爱好者，但很遗憾的是，他的母上大人没收了他的手机。为了过一把游戏瘾，$sqn$到各个$oier$的宿舍借手机玩......

## 题目描述

当然，这是一件风险很大的事，因为van恶的静静和晶晶会定时查房，被抓到可就惨了。当然$oier$们不会束手就擒，他们组织了一个反查房联盟。这个联盟由$n$个宿舍(点)组成，某些宿舍之间有边权为1无向边连接，共有$n-1$条无向边。每个点都有一个概率$k_i$，表示在颓废的几率为$k_i$。如果老师查到某个房间，而这个房间的人在学习，他就会发出警报，距离他1的人收到警报后都会在下一时刻无条件停止颓废，之后恢复原状态，如果查到在颓废的人，则那个人不会发出警报而是GG（可以当作这个人死了，再也不会发出信号）。静静和晶晶一起行动，查一遍房间。$sqn$只会在$ztz11$，$AK$爷，$floatiy$的房间里颓废，他想知道，在哪个房间里颓废被查到几率最小？当然，由于他在颓废，所以自然不可能算几率啦，他将这个问题交给了你，请你帮他来解决这个问题

## 说明/提示

对于 $30$% 的数据，$n,m<=10$,

对于另 $10$% 的数据，$k=1$

对于 $100$% 的数据，$1<=m,n<=1000000$,确保每个人被且仅被查一次

感谢@XiaoX，@Monster_qi帮助出数据&验题


## 样例 #1

### 输入

```
3 2
1 2 3
2 2 3
1 1
1 2
1 3
0.3 0.1 0.2
```

### 输出

```
1
0.9940```

# 题解

## 作者：ztz11 (赞：3)

## 思路：
这道题告你n-1条边就是骗你的

部分分也是骗你的

这道题连对边5分钟的事

一个点对另一个点有影响当且仅当这个点在另一个点的前一时刻被查

且这两个点之间有边相连

我们加上超级根节点后可以建一棵树

跑树形DP即可

## 代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rij register int j
#define rii register int i
using namespace std;
int head[1000005],n,m,tim[1000005],bj[1000005];
double dp[1000005],gl[1000005];
int bnt;
struct road{
    int to,nxt;
}x[2000005];
int a,b,c;
inline int rd(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)) {f=ch=='-'?0:1;ch=getchar();}
    while(isdigit(ch))  {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return f?x:-x;
}
void add(int from,int to)
{
//    cout<<from<<" "<<to<<endl;
    bnt++;
    x[bnt].to=to;
    x[bnt].nxt=head[from];
    head[from]=bnt;
}
void dplast(int wz)
{
    double ans=1.0;
    for(rii=head[wz];i!=0;i=x[i].nxt)
    {
        dplast(x[i].to);
        ans*=(1-dp[x[i].to]);
    }
    ans*=gl[wz];
    dp[wz]=1-ans;
}
int main()
{
//    freopen("cf8.in","r",stdin);
//    freopen("cf8.out","w",stdout);
    n=rd();m=rd();a=rd();b=rd();c=rd();
    for(rii=1;i<=m;i++)
    {
        int k;k=rd();
//        scanf("%d",&k);
        for(rij=1;j<=k;j++)
        {
            int bh=rd();
//            scanf("%d",&bh);
            tim[bh]=i;
        }
    }
    for(rii=1;i<=n-1;i++)
    {
        int from=rd(),to=rd();
//        scanf("%d%d",&from,&to);
        if(tim[from]-tim[to]==1)
        {
            add(from,to);
            bj[to]++;
        }
        if(tim[to]-tim[from]==1)
        {
            add(to,from);
            bj[from]++;
        }
    }
    for(rii=1;i<=n;i++)
    {
        if(bj[i]==0)
        {
            add(0,i);
        }
    }
    for(rii=1;i<=n;i++)
    {
        scanf("%lf",&gl[i]);
    }
    dplast(0);
//    for(rii=1;i<=n;i++)
//    {
//        printf("%.4lf ",dp[i]);
//    }
    double maxn=max(dp[a],max(dp[b],dp[c]));
    if(dp[a]==maxn)
    {
        printf("%d\n",a);
    }
    else
    {
        if(maxn==dp[b])
        {
            printf("%d\n",b);
        }
        else
        {
            printf("%d\n",c);
        }
    }
    printf("%.4lf",maxn);
}
```

---

## 作者：阿尔萨斯 (赞：2)

# 题意
### 题面看起来有点复杂，所以我解释一下：
- $n$ 个房间由 $n-1$ 条边构成一棵树，老师会进行查房，而每个人若没有被警告，则有一定概率颓废。如果被查房时没有颓废，那么该房间会向相领房间警告，让他们在下一时间一定不颓废。而  _sqn_  可在给出三个房间中选择某一个，求其中哪个房间被抓包的概率最小。
#  思路
### 不难发现，每个人被抓包都需同时满足以下两个条件：
1. 他正在颓废；
 
1. 本可以提醒他的所有人（也可能不存在）全被抓包了。
### 再进一步思考，谁可能救我？
- 可以想到，是我被查房的前一时间被查，且和我房间相邻的人。

- 综上，我只需将我颓废的概率，乘上所以可以救我的人被抓包的概率，就可以得到我被抓包的概率了。又因为我被抓包是我安全的对立事件，所以二者概率相加为 $1$ ，用 $1$ 去减被抓概率就是安全概率。使用 **深度优先搜索（DFS）** 解决，详细内容请看代码。
# 复杂度
- 空间不用考虑，时间复杂度的话，因为每个房间仅需搜索一次，搜索每个房间时都需搜索与之相邻的边，每条边最多搜两次（从两端搜过来），所以时间复杂度是 $O(n)$ 。（不甚严谨，将就看看吧）

- 提一句，注意是在相邻房间中找时间符合的，而不要在时间符合的中找相邻房间，否则如果数据是第一时间查一半房间，第二时间查另一半，时间复杂度就会变成 $O(n^2)$ 。

- 最后，因为每间房只会被查一次，所以一旦搜索到，即能得到这间房的最终被抓概率，所以可以用记忆化来剪枝。本题看似没必要，因为只用判断三间房，但如果题目加大难度，要判断所有房间，时间复杂度就吃不消了。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iomanip>
#include<algorithm>
#include<queue>
#define ll long long
using namespace std;
inline ll read()//快读
{
	ll s=0,t=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')t*=1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*t;
}
double ans[1000001],p[1000001],answer=1;//被抓包概率，颓废概率，最后答案
bool bj[1000001];//是否已被搜索过的标记
ll n,m,tot=0,head[1000001],timee[1000001],ye[5];
//n，m见题意，链式前向星头，被查房时间，三个 sqn 可藏身的房间号
struct kkk
{
	ll to,next;
}e[2000001];//相邻房间的边
inline void add(ll x,ll y)//连边
{
	tot++;
	e[tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
double f(ll x)//搜索函数，返回房间x被抓包的概率
{
	if(bj[x])//记忆化
	{
		return ans[x];
	}
	ans[x]=p[x];//被抓包的基本概率即为自己颓废的概率
	for(ll i=head[x];i;i=e[i].next)
	{
		ll to=e[i].to;
		if(timee[to]==timee[x]-1)//如房间to有可能救你
		{
			ans[x]*=f(to);//将房间to被抓包的概率乘进房间x被抓包的概率
		}
	}
	bj[x]=1;
	return ans[x];
}
int main()
{
	memset(bj,0,sizeof(bj));
	n=read();
	m=read();
	ll k,kk;
	ye[1]=read();
	ye[2]=read();
	ye[3]=read();
	for(ll i=1;i<=m;i++)
	{
		k=read();
		for(ll j=1;j<=k;j++)//记录时间
		{
			kk=read();
			timee[kk]=i;
		}
	}
	ll x,y;
	for(ll i=1;i<n;i++)
	{
		x=read();
		y=read();
		add(x,y);//双向都要连边
		add(y,x);
	}
	for(ll i=1;i<=n;i++)
	{
		scanf("%lf",&p[i]);
	}
	ll minn=0;
	double minnanswer=1,kkk;
	for(ll i=3;i>=1;i--)//打擂台
	{
		kkk=f(ye[i]);
		if(kkk<=minnanswer)
		{
			minnanswer=kkk;
			minn=ye[i];
		}
	}
	printf("%lld\n",minn);
	cout<<fixed<<setprecision(4)<<1-minnanswer;//保留四位小数输出安全概率
}
```
by 阿尔萨斯 写于 2021.11.12

---

## 作者：封禁用户 (赞：1)

其实我并不清楚什么是树形DP （可能是我太弱了）
我就按照模拟的方法来做
一层层地来判断
每一层分别找到对应的转移
乘以下概率就是答案了

```cpp
#include<bits/stdc++.h>
#define int long long
#define dl double
using namespace std;
const int maxn=1e6+7;
struct edge{int nxt,v;}eg[maxn<<1];
struct r{ double p,p1; int dep;	 }room[maxn];
int n,m,a,b,c,en,head[maxn];
int read()
{
	int x=0,y=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x;
}
void insert(int u,int v)
{
	eg[++en].v=v;
	eg[en].nxt=head[u];
	head[u]=en;
}
int fll[maxn];
int z[maxn];
void work()
{
	if(room[a].p>=room[b].p&&room[a].p>=room[c].p )
	{
		cout<<a<<endl;
		printf("%.4lf",room[a].p);return ;
	}
	else if(room[b].p>=room[c].p)
	{
		cout<<b<<endl;
		printf("%.4lf",room[b].p);
		return ;
	}
	cout<<c<<endl;
	printf("%.4lf",room[c].p);
}
signed main()
{	
	int step=0;
	n=read();m=read();
	a=read(),b=read(),c=read();
	for(int i=1;i<=m;i++)
	{	int y;y=read();int t;
		z[i]=z[i-1]+y;
		for(int j=1;j<=y;j++)
		{
		 t=read();
		 fll[++step]=t;
		 room[t].dep=i;
		}
	}
	int u,v;
	for(int i=1;i<n;i++){ u=read(),v=read();insert(u,v),insert(v,u);}
	for(int i=1;i<=n;i++) scanf("%lf",&room[i].p);
	for(int i=1;i<=n;i++)room[i].p1=1;
	for(int k=1;k<=m;k++)
	{
		for(int i=z[k-1]+1;i<=z[k];i++)
		{	
			int u=fll[i];
			room[u].p=(1-room[u].p1)+room[u].p1*(1-room[u].p);
			for(int e=head[u];e;e=eg[e].nxt)
			{
				int v=eg[e].v;
				if(room[v].dep==k+1)
					room[v].p1*=(1-room[u].p);
			}
		}
	}

	work();
	return 0;
}
```


---


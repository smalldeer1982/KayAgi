# 庞氏骗局

## 题目背景

众所周知，庞氏骗局就是借新债还就债的骗术，隐瞒企业已经大开倒车的真相，保持虚假的增长。

## 题目描述

庞氏骗局源自于一个名叫查尔斯•庞兹的人。1919 年，他故弄玄虚，设计了一份假金融企划向大众兜售。借此，坑骗了成千上万的波士顿的长脖子鹿，套走了近 1500 万美金。

查尔斯•庞兹的骗局计划分为两部分，第一次他向 $K_1$ 名长脖子鹿展示了自己的创业计划，向每一头长脖子鹿要来了 $1$ 万元的投资。第二次他向 $K_2$ 名长脖子鹿展示了自己的创业计划，由于第二次需要填补第一次的亏空，所以向每一头长脖子鹿要来了 $2$ 万元的投资。

现在，查尔斯•庞兹拥有了 $K_1$ 份 $1$ 万元和 $K_2$ 份 $2$ 万元，他希望通过一种特定的方式消费从而躲避美国税务局（IRS）的追查。每一天，他都会选择两份钱，各消费 $1$ 万元。为了进一步减轻自己的嫌疑，他每天选择的两份钱不会与之前重复。他想知道，花光所有的钱，共有多少不同的方案集合，**即方案内没有先后顺序，每一天不分先后**。

例如：第一天选择了从 $(1,2)$ 两只长脖子鹿那里拿钱，第二天不能花 $(1,2)$ 两只长脖子鹿的钱，但可以从 $(2,3)$ 或 $(1,3)$ 这样的长脖子鹿组中拿钱。

方案数对 $10^9+7$ 取模。

## 说明/提示

##### 样例解释

我们设 $1,2$ 号长颈鹿给了 $1$ 万元，$3,4$ 号长颈鹿给了 $2$ 万元。

方案一为这样的方案集合${(1,3),(3,4),(2,4)}$。

方案二位这样的方案集合${(1,4),(3,4),(2,3)}$。

![](https://cdn.luogu.com.cn/upload/pic/40820.png)

## 样例 #1

### 输入

```
2 2```

### 输出

```
2```

# 题解

## 作者：天南月 (赞：5)

Markdown炸了，已update
### 题目简述

有$K1$份$1$万元和$K2$份$2$万元。每一天都可以选择两份钱，各消费$1$万元。每天选择的两份钱不能与之前重复。求花光所有的钱，共有多少不同的方案集合。
#### 方案没有先后顺序，每一天不分先后。

例如：如果第一天选择了$(1,2)$两份钱，第二天就不能花$(1,2)$，但可以从$(2,3)$或$(1,3)$这样的组合中拿钱。

输入格式

一行，两个整数，$K1$，$K2$

输出格式

一行，一个整数，表示方案数

样例：

输入 $2$ $2$ 

输出 $2$

---

### 做法（以下图中加粗的为新点）

##### 如果有什么问题可以私信或者评论，如果我到时候还没退役会尽量回答的

可以将原题目转化成：

在一张无向图上有$K1$个出度为一，$K2$个出度为2的点，每个点的标号都不一样，求图的总可能方案数。

容易发现，最后一定是由若干个环和若干条链组成的图，像这样：
![2019-09-12 19-54-48屏幕截图.png](https://i.loli.net/2019/09/12/97Xqneo8KplRgxk.png)

每一条链的两端都是出度为一的点，易得若图有方案，则出度为一的点个数必为偶数。

我们先考虑特殊情况。

当$K2=0$时，易得方案数为$(K1-1)*(K1-3)*(K1-5)……$

将该方案数记为$sum1$

当$K1=0$时，考虑DP。记$f_{i\ j}$为$i$个点组成$j$个环的方案数，则有$f_{i\ j}=f_{i-1\ j}*(i-1)+f_{i-3\ j-1}*C^2_{i-1}$

那么$K2$的总方案数就是$\sum^{K2 \over 3}_{i=1}f_{K2 \ i}$

DP边界是$f_{0\ 0}=1$。

接下来我们解释上面的DP式子。

$f_{i\ j}$的方案有两种可能：

* 1.把第$i$个点插入已有的j个环中，可由$f_{i-1\ j}$转移而来。如图：
![2019-09-12 19-57-07屏幕截图.png](https://i.loli.net/2019/09/12/RATbkDJlrvG8i9S.png)会重复，故该情况的方案数为$f_{i-1\ j}*(i-1)$

* 2.从已有的$i-1$个点中选出$2$个点与点$i$组成一个新的环，剩下的$i-3$点再组成$j-1$个环的方案数，故该情况的方案数为$f_{i-3\ j-1}*C^2_{i-2}$。至于为什么新环的大小为3，因为环最小为3，如果新环更大，就相当于点$i$插入一个环中，与之前的情况重复。如图：
![2019-09-12 19-52-24屏幕截图.png](https://i.loli.net/2019/09/12/zQVNDJ3G4csTBux.png)

特殊情况考虑完了，接下来把两种情况综合到一起。我们发现，其实总方案数就是

$sum1*$ $\sum^{K2}_{i=0}$ (将 $i$ 个点放入 $K1 \over 2$ 条长度为2的链中的方案数) $*$ (余下 $K2-i$ 个点组成若干个环的方案数)

而将$i$个点放入$j$条长度为2的链中的方案数为

$j*(j+1)*(j+2)*……*(j+i-1)={(j+i-1)! \over (j-1)!}$

即将第$1$个点放入有$j$个空可以放，故有$j$种方案；将第$2$个点放入有$j+1$个空可以放，故有$j+1$种方案……以此类推。

$f$数组可以用一个二维DP求出，所以总时间复杂度是$O(n^2)$的。

贴代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7,N=6e3;
int k1,k2;
int sum1,zs1;
int f[N][2005];
int jc[N<<1],inv[N<<1];
int QP(int x,int k){
	int ret=1;
	while(k){
		if(k&1)ret=ret*x%mod;
		k>>=1;
		x=x*x%mod;
	}
	return ret;
}
signed main(){
	scanf("%lld%lld",&k1,&k2);
	if(k1&1){puts("0");return 0;}
	zs1=k1>>1;
	sum1=1;
	for(int i=k1-1;i>=0;i-=2)sum1=(sum1*i)%mod;
	jc[0]=1;
	f[0][0]=1;
	for(int i=1;i<=k2+zs1;++i)jc[i]=jc[i-1]*i%mod;
	inv[k2+zs1]=QP(jc[k2+zs1],mod-2);
	for(int i=k2+zs1-1;i>=0;--i)inv[i]=inv[i+1]*(i+1)%mod;
	for(int i=2;i<=k2;++i){
		int x=((i-1)*(i-2)>>1)%mod;
		for(int j=1;j<=i/3;++j){
			f[i][j]=f[i-1][j]*(i-1)%mod;
			(f[i][j]+=(f[i-3][j-1]*x)%mod)%=mod;
		}
	}
	for(int i=3;i<=k2;++i)
		for(int j=1;j<=i/3;++j)
			(f[i][0]+=f[i][j])%=mod;
	int ans=0;
	if(!k2)ans=sum1;
	else if(!k1)ans=f[k2][0];
	else{
		int ret=0,cs=inv[zs1-1]*jc[k2]%mod;
		for(int i=0;i<=k2;++i){
			ret=inv[i]*inv[k2-i]%mod*jc[zs1+i-1]%mod*f[k2-i][0]%mod;
			(ans+=ret)%=mod;
		}
		(ans*=sum1*cs%mod)%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：JackMerryYoung (赞：1)

# 前言

会做了先糊个题解。

# 正文

由于方案中每一天拿的钱顺序与答案无关，所以简单建个无向图，我们认为有 $K_1$ 个度数为 $1$ 的点而有 $K_2$ 个度数为 $2$ 的点，即一条边为猹胖子（查尔斯•庞兹）花的一组钱。

易知最后建的图一定是一些链和环，显然这 $K_1$ 个点都在链上且 $K_1$ 应为偶数（因为有且仅有它们站在链的两端），而 $K_2$ 个点既可以在链也可以在环上。

考虑数数 DP。先排除链。设 $f_{i, j}$ 为 $i$ 个点组成 $j$ 个环的方案，显然：

$$f_{i, j} = f_{i - 1, j} \times (i - 1) + f_{i - 3, j - 1} \times C_{i - 2}^2$$

第一类贡献是不创建新的环而是随便插入，共有 $i - 1$ 种；第二类贡献是另选 $2$ 个点与 $i$ 一起新建一个环。

再考虑链。只需算一下所有情况：当 $k$ 个度数为 $2$ 的点选入链里，另外一些在环里，这种方案的贡献就好了。计算中需要用的 $f$ 只需 $\mathcal{O}(N ^ 2)$ 预处理一下。

$k$ 个度数为 $2$ 的点选入链的计算可以这么操作：先把链的两端（度数为 $1$ 的点）放好，然后考虑剩下点的插入。这样思考简单不少。

# 后言

终于会数数了。

~~感觉数数难度绿，想到这题可以建图解决我觉得难度有点大（可能是我太菜了）。~~

---

## 作者：Asakawa_Luka (赞：1)

# 前言

[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)好像不那么易懂，并且答案是不完整的（虽说代码里是对的，但是代码里写得很丑，不好看出来）。

因此本题解将再解释第一篇题解，并给出一种常数更大但更容易想出的想法。

看之前请先移步至[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)，或许您就会了也不一定。

# 正文

## Solution 1

把本题转换为图的想法真的很巧妙，并且对本题 $K1 = 0$ 的部分解释很清晰，但是其余部分需要读者自行思考。

这里将[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)的“易得”部分进行解析，并展示正确的转移方程。

### 1. 无向图

我们将从鹿看做点，消费不同两只鹿（记作 $u$ 与 $v$，从 $u$ 向 $v$ 的边记作 $(u, v)$）的投资看作这两个点之间连了一条边。

题目中“方案内没有先后顺序”，即 $(u, v)$ 和 $(v, u)$ 没有区别，那就是无向边了。

那么可以观察得到，投资了 $1$ 万元的鹿为出度为 $1$ 的点，投资 $2$ 万元的鹿为出度为 $2$ 的点。

则原题转化为：给定 $K1$ 个出度为 $1$ 的点与 $K2$ 个出度为 $2$ 的点，能构成多少个不同的图。

### 2. $K2 = 0$ 怎么做

我们已经从[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)里得到了 $2 \mid K1$，此时我们要将点两两配对才能保证每个点出度为 $1$。

求方案数的朴素想法是，从 $K1$ 的点里先取两个点配对，有 $C^2_{K1}$ 种选择，然后从剩下 $K1 - 2$ 个点里取两个点配对，有 $C^2_{K1 - 2}$ 种选择，以此类推。

由于这 $\frac{K1}{2}$ 次选择没有顺序，所以答案要除以 $A^{2}_{\frac{K1}{2}}$。

则方案数为：

$$ \frac{\prod \limits_{i = 0}^{\frac{K1}{2} - 1} C^2_{K1 - 2 i}}{A^{2}_{\frac{K1}{2}}} = (K1 - 1)!! $$

同[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)一样，这里记为 $sum1$。

### 3. 正确的答案

按[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)的写法，总方案数为：

$sum1 \times \prod \limits_{i = 0}^{K2}$（从 $K2$ 个点里选 $i$ 个点的方案数）$\times$（将 $i$ 个点放入 $\frac{K1}{2}$ 条长度为 $2$ 的链中的方案数）$\times$（余下 $K2 - i$ 个点组成若干个环的方案数）

[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)里的总方案数里少了“（从 $K2$ 个点里选 $i$ 个点的方案数）”部分。

这件事是很自然的：

- 如果图中要新加入一个出度为 $2$ 的点（比如 $w$），把之前的图里一条边（例如 $(u, v)$），变成 $(u, w)$ 与 $(w, v)$ 即可。

- 这个点加进两个出度为 $1$ 的点之间（将 $i$ 个点放入 $\frac{K1}{2}$ 条长度为 $2$ 的链中的方案数），

- 这个点加进两个出度为 $2$ 的点之间（余下 $K2 - i$ 个点组成若干个环的方案数）。

- 这个点加进出度为 $1$ 的点与两个出度为 $2$ 的点之间可以归于加进两个出度为 $1$ 的点之间，因为图中每个连通块总会有偶数个出度为 $1$ 的点。

- 不同的 $\frac{K1}{2}$ 条长度为2的链种类数就是 $K2 = 0$ 的情况（$sum1$）。

- 当将 $K2$ 个出度为 $2$ 的其中 $i$ 个点多个出度为 $1$ 的点对之间时，总有 $C^i_{K2}$ 种选法。

## Solution 2

关于上述“这件事是很自然的”并没有必要像[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)里那样分解成多个子问题，我们考虑直接进行 DP。

令 $f_{i, j}$ 为有 $i$ 个出度为 $1$ 的点与 $j$ 个出度为 $2$ 的点时的方案数，此时图中总边数为 $\frac{i + 2(j - 1)}{2}$。

把一个出度为 $2$ 的点加进两个出度为 $1$ 的点之间或加进出度为 $1$ 的点与两个出度为 $2$ 的点之间，即是把一条边拆成两条边，这样有**总边数**种选法。

把一个出度为 $2$ 的点加进两个出度为 $2$ 的点之间，可以看作三个出度为 $2$ 的点之间新形成了一个三元环，这样有 $C_j^2$ 种选法。

综上得：

$f_{i, j} = f_{i, j - 1} \times \frac{i + 2(j - 1)}{2} + C_j^2 \times f_{i, j - 3}$


当 $j = 0$ 时，按照 $K2 = 0$ 做即可。

注意：

- 当 $j \leq 2$ 时，是第 $j$ 个出度为 $2$ 的点没法作为新加的一个出度为 $2$ 的点形成一个三元环的，此时 $f_{i, j} = f_{i, j - 1} \times \frac{i + 2(j - 1)}{2}$。

- 这种方法无法处理 $K1 = 0, K2 \neq 0$ 的情况，需要按[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)中 $K1 = 0$ 的做法单独处理。

# 代码

## Solution 1

```cpp
// Problem: P5031 庞氏骗局
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5031
// Memory Limit: 500 MB
// Time Limit: 1500 ms
// Author: Asakawa_Luka (uid:321898)
// Powered by CP Editor (https://cpeditor.org)
#include <iostream>
namespace Solution {
using namespace std;
typedef unsigned long long ull;
constexpr ull mod = 1e9 + 7, maxK1 = 5500ull, maxK2 = 5500ull,
              maxCycle = maxK2 / 3ull;
ull scheme[maxK2 + 1ull][maxCycle + 1ull], sum[maxK2 + 1ull],
    link[maxK2 + 1ull], C[maxK2 + 1u][maxK2 + 1u];
int main() {
  ull K1, K2;
  cin >> K1 >> K2;
  if (K1 & 1ull)
    cout << '0';
  else {
    ull ans = 1ull;
    for (ull i = 1ull; i < K1; i += 2ull) (ans *= i) %= mod;
    if (K2) {
      scheme[0ull][0ull] = 1ull;
      for (ull i = 3ull, j; i <= K2; ++i)
        for (j = 1ull; j <= i / 3ull; ++j) {
          scheme[i][j] =
              (scheme[i - 1ull][j] * (i - 1ull) +
               scheme[i - 3ull][j - 1ull] * ((i - 1ull) * (i - 2ull) >> 1ull)) %
              mod;
        }
      sum[0ull] = 1ull;
      for (ull i = 3ull, j; i <= K2; ++i) {
        for (j = 1ull; j <= i / 3ull; ++j) sum[i] += scheme[i][j];
        sum[i] %= mod;
      }
      for (ull i = 0ull, j; i <= K2; ++i) {
        C[i][0ull] = 1ull;
        for (j = 1ull; j <= i; ++j)
          C[i][j] = (C[i - 1ull][j] + C[i - 1ull][j - 1ull]) % mod;
      }
      if (K1) {
        link[0ull] = 1ull;
        for (ull i = 1ull, j = (K1 >> 1ull); i <= K2; ++i)
          link[i] = link[i - 1ull] * (j++) % mod;
        ull tmp = 0ull;
        for (ull i = 0ull; i <= K2; ++i)
          (tmp += (C[K2][i] * sum[K2 - i] % mod) * link[i]) %= mod;
        cout << ans * tmp % mod;
      } else
        cout << sum[K2];
    } else
      cout << ans;
  }
  return 0;
}
}  // namespace Solution
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  return Solution::main();
}
```

## Solution 2

```cpp
// Problem: P5031 庞氏骗局
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5031
// Memory Limit: 500 MB
// Time Limit: 1500 ms
// Author: Asakawa_Luka (uid:321898)
// Powered by CP Editor (https://cpeditor.org)
#include <iostream>
namespace Solution {
using namespace std;
typedef unsigned long long ull;
constexpr ull mod = 1e9 + 7, maxK1 = 5500ull, maxK2 = 5500ull;
ull f[maxK1 + 1ull][maxK2 + 1ull], C[maxK2 + 1ull][maxK2 + 1ull];
int main() {
  ull K1, K2;
  cin >> K1 >> K2;
  if (K1 & 1ull)
    cout << '0';
  else if (!K1) {
    f[0ull][0ull] = 1ull;
    for (ull i = 3ull, j; i <= K2; ++i)
      for (j = 1ull; j <= i / 3ull; ++j) {
        f[i][j] = (f[i - 1ull][j] * (i - 1ull) +
                   f[i - 3ull][j - 1ull] * ((i - 1ull) * (i - 2ull) >> 1ull)) %
                  mod;
      }
    K1 = 0ull;
    for (ull i = 1ull; i <= K2 / 3ull; ++i) K1 += f[K2][i];
    cout << K1 % mod;
  } else {
    for (ull i = 0ull, j; i <= K2; ++i) {
      C[i][0ull] = 1ull;
      for (j = 1ull; j <= i; ++j)
        C[i][j] = (C[i - 1ull][j] + C[i - 1ull][j - 1ull]) % mod;
    }
    f[0ull][0ull] = 1ull;
    for (ull i = 2ull, j; i <= K1; i += 2ull) {
      f[i][0ull] = f[i - 2ull][0ull] * (i - 1ull) % mod;
      for (j = 1u; j <= K2; ++j) {
        f[i][j] = f[i][j - 1ull] * ((i + ((j - 1ull) << 1ull)) >> 1ull);
        if (j >= 3ull) f[i][j] += C[j - 1ull][2ull] * f[i][j - 3ull];
        f[i][j] %= mod;
      }
    }
    cout << f[K1][K2];
  }
  return 0;
}
}  // namespace Solution
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  return Solution::main();
}
```

# 后言

[第一篇题解](https://www.luogu.com.cn/blog/HNYL-Konnyaku/solution-p5031)造成的阅读困难是作者写这篇题解的唯一动机。

**Thank you for reading!**

---


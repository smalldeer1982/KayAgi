# 果冻

## 题目背景

[赛时答疑](https://www.luogu.org/discuss/show/80694)

**数据已经修复**。

【生存世界】Steve：你们哪位 dalao 可以收留我啊 qwq……

在 Minecraft 一个很友善、和谐的服务器里面，Steve 很喜欢在里面畅游，服务器采用小镇机制，于是有很多小镇。有一个镇叫果冻镇，镇长~~长得很像~~喜欢吃果冻，他很喜欢~~对着镜子~~吃着 bling bling 的果冻。突然，他收到“捷报”，镇上不久就要造反。他吓了一跳，赶紧从床上跳了起来（qwq），吃了一口果冻（误），着手处理这件事情。

## 题目描述

镇上有一个镇长以及 $n-1$ 个镇员，所有的镇员都有着他的直属上司 $f_i$。每个镇镇员与镇长都有一个距离 $d_i$（也就是他与镇长之间上司的人数加 $1$）。镇长想要所有镇员都是自己的直属下司，也就是与他的距离为 $1$。

他每分钟可以让自己的一个镇员变为自己的直属下司，在第 $t (t > 0)$ 分钟的时候，（也就是每一分钟的意思，而 $t$ 将从 $1$ 开始），这个镇员变为自己的直属下司，镇长可以收获 $ (d_i+t) \& k$ 的安全指数（其中，$\&$ 为按位与运算）。然后**这个镇员的下司都会跟着这个镇员一起变动**（也就是这个镇员的直属下司仍然是这个镇员的，除非镇长把这个下司变为自己的直属下司）。

当所有镇员都是自己的直属下司后，镇长就可以安心吃他的果冻了。他现在想问你，应该怎样变动，才能使安全指数最大。因为镇长很想快点吃到果冻，他就把这个任务交给你了。

## 说明/提示

### 样例解释

第二个样例：（图片有可能会挂，请耐心等待一会哦 qwq）
![](https://s1.ax1x.com/2018/10/28/ic6RmQ.png)  
![](https://s1.ax1x.com/2018/10/28/ic6Wwj.png)    
![](https://s1.ax1x.com/2018/10/28/ic6fTs.png)  
![](https://s1.ax1x.com/2018/10/28/ic64kn.png)  
![](https://s1.ax1x.com/2018/10/28/ic6gOg.png)  
由于~~出题人过懒~~，移动子节点的情况就未列举。请自行 hack 自己。（滑稽）

### 数据范围

记下列两种特殊情况：  
1. 保证字符串长度为 $1$。
2. 树退化成一条链。
![]( https://cdn.luogu.com.cn/upload/pic/39861.png)     
对于所有的数据，保证 $k$ 在 `int` 范围内，字符串长度不超过 $10^6$。$n,k$ 均为正整数。

## 样例 #1

### 输入

```
3 1
1
2 1
3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
7 3
LDLD
tk_sky LDLD
Jayden_deng LDLD
only_xiaohuang tk_sky
Muddled_xiaopan tk_sky
Inkn only_xiaohuang
ipdjkl only_xiaohuang```

### 输出

```
8```

# 题解

## 作者：南城忆潇湘 (赞：9)

解法1：  
我有信仰，我是MC玩家，输出0，预计得分3.

解法2：  
我会暴力dfs，预计得分33分。

解法3：  
我会特判，观察到k的取值范围以及树退化的情况，考虑特判，预计得分60-70分。

解法4：  
我会模拟退火，出题人~~特意~~开了乐多赛制，期望得分0-100

解法5：  
我会状压DP。我们可以记录每个节点的儿子。因为在变动节点的时候，他的儿子始终是不变的。  
对于每一个集合S，记S'除去当前考虑的节点x,然后看他里面有几个点的儿子是x,然后减去这个距离再计算（转移）就可以了。时间复杂度$O(n^2*2^n)$，可以过全部的点。

代码：（100pts）  
```
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,k,d[101],top,far;
int o[51][51],f[1<<20];
int son[1<<20];
string s,t;
map<string,int> qwq;
int num(int x){
    if(x==0)	return 0;
    return num(x-(x&-x))+1;
}
void dfs(int node){
    if(d[node]>1)
        far|=(1<<node-1);
    for(int i=1;i<=n;i++)
        if(o[node][i]){
            d[i]=d[node]+1;
            dfs(i);			
            son[node]|=(1<<i-1);
            son[node]|=son[i];
        }
    return ;
}
int main(){
    int cnt=1;
    cin>>n>>k;
    cin>>s;	qwq[s]=1;
    for(int i=2;i<=n;i++){
        cin>>s>>t;
        qwq[s]=++cnt;
        o[qwq[t]][qwq[s]]=1;
    }
    dfs(1);
    for(int s=1;s<(1<<n);s++){
        for(int i=1;i<=n;i++){
            if(s&(1<<i-1)){
                int s1=s-(1<<i-1),dis=d[i];
                for(int j=1;j<=n;j++)
                    if(s1&(1<<j-1)&&(son[j]&(1<<i-1))&&d[j]>1)
                        dis--;
                if(dis<=1)	f[s]=max(f[s],f[s1]);
                else	f[s]=max(f[s],f[s1]+((num(s&far)+dis)&k));
            }
        }
    }
    cout<<f[(1<<n)-1]<<endl;
    return 0;
}
```

~~其实也不是很长，对吧~~


---

## 作者：IIIIIlIIIl (赞：1)


~~蒟蒻第一次写题解，写的不好还请包容~~
## Descripition
有一棵 $n$ 个点构成的以节点 1 为根的树，每个叶子节点到 1 号节点的距离 $d_i$ 为该节点到 1 节点的边数，第 $t$ 分钟会有一个不以 1 节点为父节点的儿子节点带着自己的子树挂到 1 号节点上，并会获得 $(d_i+t) \operatorname{and} k$ 的贡献，求当所有节点的父节点都为 1 时，获得的贡献最大为多少。
## Solution
蒟蒻写这道题是刚学完模拟退火，看到这个 $n$ 的范围只有 20，便决定洗把脸拿模退乱搞，不会模退的可以先去看这道题
[吊打xxx](https://www.luogu.com.cn/problem/P1337)，这里就不过多对模退本身进行讲解。首先我们构造一个长度为 $n$ 的数列，初始赋值为 $1$ 到 $n$，表示我们要挂到 1 号节点的顺序，初始时先求出 $ans$，然后模拟退火时随机选 $1$ 到 $n$ 中的 2 个不相同的数交换，然后再计算答案与 $ans$ 作比较，如果更优就更改 $ans$，否则根据模退公式概率接受新答案，然后进行下一次交换，因为 $n$ 的范围很小，所以只要交换的次数够多，总能找到最优答案。


------------
### Part 1
首先是输入部分，题目中每个节点可能是字符串，我这里采用 map 将字符串全部转化为数字，然后只需要存下每个节点的父节点即可。
```cpp
scanf("%d%d",&n,&k);
if(n==0&&k==0){//特判k=0的情况
	printf("0");
	return 0;
}
std::cin>>s;
map[s]=1;
for(int i=2;i<=n;i++){
	std::cin>>s>>s1;
	map[s]=i;//存入新节点
	fa[i]=map[s1];//存下每个节点的父节点
	a[i]=i;//模退初始数列
}
```
### Part 2
接下来是我们得到一个可能最有的顺序时怎样求出答案，这里我采用的是类似并查集的思想，递归求出当前节点到根节点的距离，然后根据题意算出贡献，然后将该节点的父节点改为 1，这样该节点的子树也同样会改变位置，帮助计算叶节点的贡献。
```cpp
int find(int now,int step){
	if(now==1){//如果已经到达根节点，就返回dis
   //这里不如处理出每个节点到根节点距离是因为每个节点在变化中到根节点dis会变
		return step;
	}
	return find(fa1[now],step+1);
}

int getans(){
	for(int i=1;i<=n;i++){
		fa1[i]=fa[i];//每次求答案时每个节点的父节点都会改变，所以每次求之前重置
	}
	int tmp=0;
	int t=0;//记录第几分钟
	for(int i=2;i<=n;i++){
		if(fa1[a[i]]==1)continue;//如果父节点本身就是1那就不需要挂上去
		t++;
		sum=find(a[i],0);//求该节点到根节点距离
		tmp=tmp+((sum+t)&k);//求出贡献
		fa1[a[i]]=1;//将该节点挂到根节点上
	}
	return tmp;//返回答案
}
```
### Part 3
接下来就是最重要的模退部分，首先构造一个数列 $a$ 求出一个初始的挂节点的顺序，然后每次模退的时候随机交换 2 个点的挂的顺序，然后根据上一部分求出每次答案，然后取最大值，模退是个玄学算法，记得多跑几遍。
```cpp
void sa(int times){
	while(times--){//洗把脸，多跑几次说不定就过了
		for(double i=t;i>end;i*=down){//实时温度
			int x=0,y=0;
			while(x==y){//随机交换2个不一样的点
				x=rand()%(n-1)+2;
				y=rand()%(n-1)+2;
			}
			std::swap(a[x],a[y]);
			int tmp=getans();
			for(int i=2;i<=n;i++){
				
			}
			if(tmp>=ans){
				ans=tmp;
			}else if(exp(ans-tmp)/i>(double)rand()/RAND_MAX){//不是最优解时概率接受当前答案
				std::swap(a[x],a[y]);
			}
		}
	}
}
```
------------

模退主要还是看~~人品~~参数，祝愿各位调出快一点的参数，最后附上完整高清无注释代码。
### Code
```cpp
#include<bits/stdc++.h>

const double t=4000,down=0.99,end=1e-13;
std::map<std::string,int>map;
std::string s,s1;
int n,k,fa[30],fa1[30],a[30],ans,sum;

int find(int now,int step){
	if(now==1){
		return step;
	}
	return find(fa1[now],step+1);
}

int getans(){
	for(int i=1;i<=n;i++){
		fa1[i]=fa[i];
	}
	int tmp=0;
	int t=0;
	for(int i=2;i<=n;i++){
		if(fa1[a[i]]==1)continue;
		t++;
		sum=find(a[i],0);
		tmp=tmp+((sum+t)&k);
		fa1[a[i]]=1;
	}
	return tmp;
}

void sa(int times){
	while(times--){
		for(double i=t;i>end;i*=down){
			int x=0,y=0;
			while(x==y){
				x=rand()%(n-1)+2;
				y=rand()%(n-1)+2;
			}
			std::swap(a[x],a[y]);
			int tmp=getans();
			for(int i=2;i<=n;i++){
				
			}
			if(tmp>=ans){
				ans=tmp;
			}else if(exp(ans-tmp)/i>(double)rand()/RAND_MAX){
				std::swap(a[x],a[y]);
			}
		}
	}
}

int main(){
	scanf("%d%d",&n,&k);
	if(n==0&&k==0){
		printf("0");
		return 0;
	}
	std::cin>>s;
	map[s]=1;
	for(int i=2;i<=n;i++){
		std::cin>>s>>s1;
		map[s]=i;
		fa[i]=map[s1];
		a[i]=i;
	}
	ans=getans();
	sa(10);
	printf("%d",ans);
	return 0;
}
```
考场慎用模退。

---

## 作者：dangerous_DZR (赞：0)

$upd.2025.8.9$ 修复了一些排版错误。

当你看到数据范围的第一眼，你会立即~~晕倒~~发现这是明显的暴力枚举。于是你再次审视题面，然后发现这是令无数人~~晕倒~~痴迷的**状压 dp**!
## 解法
依据状压 dp 的惯例，我们令 $f_i$ 表示当 $n$ 位二进制数 $i$ 的每一位表示的官员是/不是镇长的直属下司时的最大安全指数。  
第一步：我们可以先预处理出每个官员的下司和与镇长的距离。
```cpp
void init(int now){
	if (d[now] > 1)maxn |= (1 << now - 1);//找出所有要变为镇长直属下司的人
	for (int i = 1; i <= n; i ++){
		if (v[now][i])d[i] = d[now] + 1, init(i), p[now] |= ((1 << i - 1) | p[i]);//处理每个官员的下司和到镇长的距离，v数组为邻接矩阵
	}
}
```
第二步：构造一个计算当前状态中人数的函数。
```cpp
int sum(int x){
	int num = 0;
	while (x)num += (x & 1), x >>= 1;//枚举每一位
	return num;
}
```
第三步：枚举并进行状态转移（具体见注释）。
```cpp
for (int i = 1; i < (1 << n); i ++){//枚举所有状态
    for (int j = 1; j <= n; j ++){
        if (i & (1 << j - 1)){//当第j个人被选为镇长的直属下司时
            int now = 1;
            for (int l = 1; l <= n; l ++){
                if (l != j && (i & (1 << l - 1)) && (p[l] & (1 << j - 1)) && (maxn & (1 << l - 1)))now = max(now, d[l]);//找出当前状态下第j个人变为镇长直属下司前离镇长的距离
            }
            if (d[j] - now + 1 <= 1)f[i] = max(f[i], f[i - (1 << j - 1)]);//如果第j个人一开始就是镇长的直属下司，则直接转移
            else f[i] = max(f[i], f[i - (1 << j - 1)] + ((sum(i & maxn) + d[j] - now + 1) & k));//否则，加上镇长此时增加的安全指数（算时间时要去掉本来就是镇长直属下司的人）
        }
    }
}
```
最后，救起晕倒的你，让你一窥代码全貌：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, d[25], f[1 << 21], p[25], maxn;
bool v[30][30];//邻接矩阵
string s, x;
map<string, int> m;//对官员编号
void init(int now){//预处理
	if (d[now] > 1)maxn |= (1 << now - 1);
	for (int i = 1; i <= n; i ++){
		if (v[now][i])d[i] = d[now] + 1, init(i), p[now] |= ((1 << i - 1) | p[i]);
	}
}
int sum(int x){//计算状态中的人数
	int num = 0;
	while (x)num += (x & 1), x >>= 1;
	return num;
}
int main(){
	cin >> n >> k >> s;
	m[s] = 1;
	for (int i = 2; i <= n && cin >> s >> x; i ++)m[s] = i, v[m[x]][i] = 1;
	init(1);
	for (int i = 1; i < (1 << n); i ++){//转移
		for (int j = 1; j <= n; j ++){
			if (i & (1 << j - 1)){
				int now = 1;
				for (int l = 1; l <= n; l ++){
					if (l != j && (i & (1 << l - 1)) && (p[l] & (1 << j - 1)) && (maxn & (1 << l - 1)))now = max(now, d[l]);
				}
				if (d[j] - now + 1 <= 1)f[i] = max(f[i], f[i - (1 << j - 1)]);
				else f[i] = max(f[i], f[i - (1 << j - 1)] + ((sum(i & maxn) + d[j] - now + 1) & k));
			}
		}
	}
	cout << f[(1 << n) - 1];//输出所有人都是镇长直属下司时的最大安全指数
	return 0;
}
```
感谢 [南城忆潇湘](https://www.luogu.com.cn/user/20780) 大佬！

---


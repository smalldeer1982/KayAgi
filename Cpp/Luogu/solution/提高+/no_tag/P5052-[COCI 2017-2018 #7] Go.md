# [COCI 2017/2018 #7] Go

## 题目描述

Branimirko 是世界著名游戏 Pokémon Go 的一位热情玩家。最近，他决定组织一场抓小精灵的比赛。比赛将在 Zagreb 的 Ilica 大街举行，主要赞助商是他的朋友 Slavko。奖励当然是糖果!

我们都知道，Ilica 是 Zagreb 最长的街道。在街道的同一侧有 $N$ 栋房子，房子从左到右分别依次有 $1$ 到 $N$ 的门牌号。

比赛前，Branimirko 看了看地图，发现了一共有 $M$ 只小精灵。每个小精灵都位于自己的各不相同的房子里，第 $i$ 个房子门牌号为 $A_i$，小精灵价值 $B_i$ 个糖果，并且只能在 $T_i$ 秒内被抓，之后它就会从地图上消失。

Branimirko 第 $1$ 秒在门牌号为 $K$ 的房子。接下来每一秒它可以移动到门牌号相邻的房子，或者不移动。当他在一个时刻和一只小精灵处在相同的房子时，他就会抓住这只小精灵，获得其对应的糖果，且这只小精灵就从地图上消失了。

因为 Branimirko 真的很喜欢糖果，所以他请求你的帮助。

帮助他求出他可以得到多少糖果。

## 样例 #1

### 输入

```
10 5 4
1 30 4
3 5 7
7 10 12
9 100 23```

### 输出

```
115 ```

## 样例 #2

### 输入

```
20 8 7
1 35 14
4 57 1
6 32 2
9 94 28
14 78 8
15 8 1
17 55 3
```

### 输出

```
172```

# 题解

## 作者：Rhodoks (赞：13)

&emsp;&emsp;显而易见的一点是，当我走过了某间房子，如果这间房子里有小精灵，那么一定会把它们抓了换糖吃。由于每次只能前往相邻门牌号的房子，所以在整个比赛过程中，我访问过的房子会构成一个连续的闭区间，这个区间里的所有小精灵全部没了，而区间外的小精灵全部没有被抓。

&emsp;&emsp;同时，我们也可以考虑这样一个想法：比赛者永远从一间有小精灵的房子径直走向另外一间有小精灵的房子。直观感受一下，如果中途有停留或者掉头的情况，那么时间会白白浪费而没有任何额外收益，最后收获的糖果数绝对是不增的。

&emsp;&emsp;所以说，我们关注的仅仅是有小精灵的房子（还包括起点）和他们之间的距离。介于题中将小精灵按位置升序给出，我们只需挨个读入并且把起点插进去就行了。

&emsp;&emsp;考虑这样一个dp，当我访问过最左端的房子为l，最右端的房子为r，目前正在左/右端（dir=0/1），而时间已经过了T秒时，最大糖果收入为dp[l][r][dir][T]。

&emsp;我们可以写出状态转移方程：

	dp[l-1][r][0][T+dis(pos,l-1)]=max(dp[l-1][r][0][T+dis(pos,l-1)], dp[l][r][dir][T]+candy[l-1]*p) (l-1>0) 

	dp[l][r+1][0][T+dis(pos,r+1)]=max(dp[l][r+1][0][T+ dis(pos,r+1)], dp[l][r][dir][T]+candy[r+1]*p) (r+1<=m)

&emsp;&emsp;其中pos=dir ? l:r，dis函数代表两间屋子之间的距离，p则是代表该间屋子里的小精灵是否未超时的布尔变量。

&emsp;&emsp;由于(1<=M<=100)，（1<=Ti<=2000），（0<=dir<=1）我们需要开一个四千万大的数组……看上去的确很大，大到一开始我压根没敢用这个做法，不过算一下也就20MB大小的内存。回头看下内存限制，嗯，512M，可以。

&emsp;&emsp;先上代码吧。
```cpp
#include <bits/stdc++.h>
#define LL long long
#define _ 0
#define MAXN 102
#define MAXT 2010 
#define INF 9999999
using namespace std;

int n,k,m;

struct pokeman
{
	int house,candy,tim;
}poke[MAXN]; //存储小精灵（还有起点）的信息 

int dp[MAXN][MAXN][MAXT][2];
int maxcandy=0;

inline int dis(int x,int y) //求距离函数 
{
	return abs(poke[x].house-poke[y].house);
}

void dfs(int l,int r,int tim,int dir,int candy)
{
	int pos=(dir==0 ? l:r);
	
	if (tim<poke[pos].tim)
		candy+=poke[pos].candy;
		
	if (candy<=dp[l][r][tim][dir])
		return;
	else
		dp[l][r][tim][dir]=candy;
		
	if (maxcandy<candy)
		maxcandy=candy;
		
	if (r<m-1)//向左走 
		dfs(l,r+1,tim+dis(pos,r+1),1,candy);
	if (l>0) //向右走 
		dfs(l-1,r,tim+dis(pos,l-1),0,candy);
}

int main()
{
	for (int i=0;i<MAXN;i++)
		for (int j=0;j<MAXN;j++)
			for (int s=0;s<MAXT;s++)
			{
				dp[i][j][s][0]=-1;
				dp[i][j][s][1]=-1;
			}
	//初始化 
	
	cin>>n>>k>>m;
	int start;
	for (int i=0;i<m;i++)
		scanf("%d%d%d",&poke[i].house,&poke[i].candy,&poke[i].tim);
		
	//把起点放进去，注意考虑到起点房屋有小精灵的情况。 
	for (start=0;start<m && k>poke[start].house;start++);
	if (k<poke[start].house)
		for (int j=m-1;j>=start;j--)
			poke[j+1]=poke[j];
	if (k!=poke[start].house)
	{
		m++;
		poke[start]={k,0,INF}; //把起点视为一个能换0糖果的小精灵 
	}
	
	
	dfs(start,start,0,0,0);
	cout<<maxcandy;
	
	return ~~(0^_^0);
}


```


&emsp;&emsp;四千万数组的初始化可不是一个很快的工作。从我的提交结果来看，开了O2之后这一步骤仍然需要150ms左右（memset应该会快一些，不过我没试）。而假如没开O2，测试点#10已经在TLE的边缘了。

&emsp;&emsp;那么能不能省略初始化的步骤？
```cpp
if (candy<=dp[l][r][tim][dir])
	return;
else
	dp[l][r][tim][dir]=candy;
```


&emsp;&emsp;原先我把dp数组初始化到-1。如果不初始化，dp数组初值为0，由于这条语句我写的是<=号，candy初值为0，0<=0，这个算法压根跑不了。

&emsp;&emsp;那么改成<号行不行？

&emsp;&emsp;~~5个刺眼的TLE狠狠地教育了我。~~

&emsp;&emsp;事实上解决方案也简单，令candy初值为1，最后输出的结果-1即可。

&emsp;&emsp;算是小蒟蒻发现的一个小技巧吧，利用全局变量初值为0的特性节省初始化时间，不知道有用没用，姑妄言之。

---

## 作者：Bulyly (赞：5)

感觉题目难度有点虚高。就是一道裸的区间 dp。除开时间限制外，和 [关路灯](https://www.luogu.com.cn/problem/P1220) 这道题没有什么区别。由于选择的点一定是连续的，我们记 $f_{t,l,r,0/1}$ 表示时间为 $t$ 时，已经经过 $[l,r]$ 的精灵，且当前处于左端还是右端时的贡献。转移需要计算一下转移点到现在的时间，并且判断当前点是否能产生贡献，即没有超时。其他的没什么区别。如果没有点 $k$ 我们可以设置一个虚拟点 $k$ 来初始化。具体可以参考代码。
```cpp
#include<bits/stdc++.h>
#define gc getchar
using namespace std;
using ll=long long;
inline int read() {
	int x=0;bool fg=0;char ch=gc();
	for(;!isdigit(ch);ch=gc()) fg|=ch=='-';
	for(;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+(ch^48);
	return fg?~(x-1):x;
} 
const int N=2010;
int n,k,m,ans;
int f[N][110][110][2];
bool st[N];
struct node {
	int id,w,t;
}a[N];
int main() {
	n=read(),k=read(),m=read();
	for(int i=1;i<=m;i++) {
		int id=read(),w=read(),t=read();
		a[i]={id,w,t},st[id]=1;
	}
	if(!st[k]) a[++m]={k,0,0};
	sort(a+1,a+m+1,[](node A,node B){return A.id<B.id;});
	int start=0;
	for(int i=1;i<=m;i++) if(a[i].id==k) start=i;
	memset(f,-0x3f,sizeof f);
	f[0][start][start][0]=f[0][start][start][1]=a[start].w;
	for(int t=1;t<=2000;t++) {
		for(int i=1;i<=m;i++) {
			for(int l=1;l+i-1<=m;l++) {
				int r=i+l-1;
				int t1=t-abs(a[l+1].id-a[l].id),t2=t-abs(a[r].id-a[l].id),t3=t-abs(a[r].id-a[r-1].id);
				if(t1>=0) f[t][l][r][0]=max(f[t][l][r][0],f[t1][l+1][r][0]+a[l].w*(a[l].t>t));
				if(t2>=0) f[t][l][r][0]=max(f[t][l][r][0],f[t2][l+1][r][1]+a[l].w*(a[l].t>t));
				if(t2>=0) f[t][l][r][1]=max(f[t][l][r][1],f[t2][l][r-1][0]+a[r].w*(a[r].t>t));
				if(t3>=0) f[t][l][r][1]=max(f[t][l][r][1],f[t3][l][r-1][1]+a[r].w*(a[r].t>t));
				ans=max(ans,max(f[t][l][r][1],f[t][l][r][0]));
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：MnZnOIer (赞：2)

### 大致思路
首先，我们应该知道这题应该用区间 dp ~~（当然你也可以试试其他玄学的东西）~~。

### 动态规划
#### 状态设置
我们令 $f_{t,l,r,f}$ 表示第 $t$ 秒 $l$ 到 $r$ 的 $f$ 部分贡献（0 表示左，1 表示右）。

#### 状态转移
现已枚举出所有参数（$t,l,r$），转移方程如下：

1. 从 $l+1$ 号房子到 $l$ 号房子的时间小于当前时间，令 $tt$ 表示到 $l+1$ 的剩余时间。
$$f_{t,l,r,0}=\max{f_{t,l,r,0},f_{tt,l+1,r,0}+w_l\times (t_l > t)}$$

- 判断是因为当这个点的时间已过的时候不能增加贡献。
2. 从 $l$ 到 $r$ 的时间小于当前时间，令 $tt$ 表示从 $l$ 到 $r$ 的剩余时间。
$$f_{t,l,r,0}=\max{f_{t,l,r,0},f_{tt,l+1,r,1}+w_l\times (t_l > t)}$$
$$f_{t,l,r,1}=\max{f_{t,l,r,1},f_{tt,l,r-1,0}+w_r\times (t_r > t)}$$
3. 从 $r-1$ 到 $r$ 的时间小于当前时间，令 $tt$ 表示从 $r-1$ 到 $r$ 的剩余时间。
$$f_{t,l,r,1}=\max{f_{t,l,r,1},f_{t,l,r-1,1}+w_r\times (t_r>t)}$$

### 一些问题
一定要在原数组中插入 $k$。

因为保证 $A_i$ 按严格升序给出，个人认为为了插入一个值而排序是多此一举，所以可以直接在输入的时候插入。

但是，无论用是么方法，都要先判断没有 $k$ 再插入。

### 代码
部分对于上面的实现，可以参考其他题解。

下面给出状态转移的代码：

```cpp
for (int t = 0; t <= T; ++ t)//枚举时间
{
	for (int l = 1; l <= m; ++ l)//枚举左端点
	{
		for (int r = l; r <= m; ++ r)//枚举右端点
		{
			int tt = t - a[l + 1] + a[l];//剩余时间
			if (tt >= 0)f[t][l][r][0] = max ({
				f[t][l][r][0],//原状态
				f[tt][l + 1][r][0] + b[l] * (c[l] > t)//在 l+1 到 r 的区间的左贡献上加上 l 的贡献
			});
			tt = t - a[r] + a[l];
			if (tt >= 0)
			{
				f[t][l][r][0] = max ({
					f[t][l][r][0],
					f[tt][l + 1][r][1] + b[l] * (c[l] > t)//在 l+1 到 r 的区间的右贡献上加上 l 的贡献
				});
				f[t][l][r][1] = max ({
					f[t][l][r][1],
					f[tt][l][r - 1][0] + b[r] * (c[r] > t)//在 l 到 r-1 的区间的左贡献上加上 r 的贡献
				});
			}
			tt = t - a[r] + a[r - 1];
			if (tt >= 0)f[t][l][r][1] = max ({
				f[t][l][r][1],
				f[tt][l][r - 1][1] + b[r] * (c[r] > t)//在 l 到 r-1 的区间的右贡献上加上 r 的贡献
			});
			ans = max ({ans, f[t][l][r][0], f[t][l][r][1]});//统计答案
		}
	}
}
```
完整代码参见[这里](https://www.luogu.com.cn/paste/6mtcam0h)。

[后继](https://www.luogu.com.cn/paste/kmdscric)。

---

## 作者：Unnamed114514 (赞：1)

首先，因为得到糖果不需要时间，所以所经过的路径上的糖果一定会得到，那么得到糖果的区间就一定是连续的。

那么我们可以定义 $dp_{l,r}$ 表示 $[l,r]$ 的答案，考虑到得到糖果需要考虑时间，求解时间需要知道位置，我们最终的状态定义如下：

定义 $dp_{l,r,0/1,t}$ 表示 $[l,r]$ 区间中，$0$ 表示在左端点，$1$ 表示在右端点，当前时间为 $t$ 时的答案。

接下来我们再考虑一个问题：为什么选取端点一定是对的呢？

由于上面的说明，我们可以发现 $[l,r]$ 的糖果都已经拿完了，那么下一步只能向左或者向右扩展，此时扩展出去后所在的位置一定是端点。

时间复杂度 $O(m^2t_{max})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,dp[105][105][2][2005];
bool flg;
struct node{
	int a,b,t;
	inline bool operator <(const node &o) const{
		return a<o.a;
	}
}f[105];
int dfs(int l,int r,int flg,int t){
	if(t>2000||l<1||r>m)
		return 0;
	if(~dp[l][r][flg][t])
		return dp[l][r][flg][t];
	int res=0;
	if(flg==1)
		res=max(dfs(l-1,r,0,t+(f[r].a-f[l-1].a)),dfs(l,r+1,1,t+(f[r+1].a-f[r].a)));
	else
		res=max(dfs(l-1,r,0,t+(f[l].a-f[l-1].a)),dfs(l,r+1,1,t+(f[r+1].a-f[l].a)));
	return dp[l][r][flg][t]=res+(t<f[flg?r:l].t?f[flg?r:l].b:0);
}
int main(){
	cin>>n>>k>>m;
	for(int i=1;i<=m;++i){
		cin>>f[i].a>>f[i].b>>f[i].t;
		if(f[i].a==k)
			flg=1;
	}
	if(!flg)
		f[++m]=node({k,0,0}),sort(f+1,f+m+1);
	memset(dp,-1,sizeof(dp));
	for(int i=1;i<=m;++i)
		if(f[i].a==k)
			cout<<dfs(i,i,1,0)<<endl;
	return 0;
}
```

---

## 作者：mahaorui2012 (赞：0)

# 思路

首先，取到的精灵**一定在一个区间内**。

其次，下一步取到的糖果只取决于区间的左右端点、当前在区间的左端点还是右端点以及当前时间，即**无后效性**。 

所以这道题可以使用**区间DP**。

## 状态 

### 未优化的状态

记 $f_{t,l,r,p}$ 表示当前时间为 $t$，区间左端点位于第 $l$ 个房子，右端点位于第 $j$ 个房子，在左端点（$p=0$） 还是右端点（$p=1$）时的最大糖果数量。 

但是，这样做时，空间和时间均来到了 $2000\times 10^3\times 10^3\times 2=2\times 10^9$ 级别，无法接受。

### 优化了的状态

由于仅当走到有精灵的位置时才会对答案有贡献，考虑离散化。

时间复杂度为 $\operatorname{O}(TM^2K)$，空间同理，可以接受。 

## 初始状态

第一步一定会走到离 $K$ 最近的两个精灵家里之一，具体实现见代码。 

## 转移方程

不妨设每走一次必会新走到一个精灵处。 

若当前状态为 $f_{t,l,r,0}$，则有四种情况：

### 由 $[l+1,r]$ 且 $p=0$ 的状态得来

则最优走法为从第 $l+1$ 个精灵走到第 $l$ 个精灵。

### 由 $[l+1,r]$ 且 $p=1$ 的状态得来

则最优走法为从第 $r$ 个精灵走到第 $l$ 个精灵。 

### 由 $[l,r-1]$ 且 $p=0$ 的状态得来

则最优走法为从第 $l$ 个精灵走到第 $r$ 个精灵再走到第  $l$ 个精灵。 

### 由 $[l,r-1]$ 且 $p=1$ 的状态得来

则最优走法为从第 $r-1$ 个精灵走到第 $r$ 个精灵再走到第 $l$ 个精灵。  

具体实现见代码。 

$p=1$ 时思路类似，故不再赘述。

# AC CODE
```C++
#include <iostream>
#include <cstring>
using namespace std;

int max3(int a,int b,int c){
	return max(a,max(b,c));
}
int max4(int a,int b,int c,int d){
	return max(max(a,b),max(c,d));
}

struct sprite{
	int street=0,candy,tm;
} arr[105];

int dp[2005][105][105][2];

int main(){
	memset(dp,-0x3f,sizeof(dp));
	int n,k,m;
	cin>>n>>k>>m;
	int lw,up=0;
	for(int i=1;i<=m;++i){
		cin>>arr[i].street>>arr[i].candy>>arr[i].tm;
		if(arr[i].street>k && up==0){
			lw=i-1;
			up=i;
		}else if(arr[i].street==k && up==0){
			lw=up=i;
		}
	}if(up==0){
		lw=m;
		arr[0].street=k;
	}
	dp[arr[up].street-k+1][up][up][0]=dp[arr[up].street-k+1][up][up][1]=
			(arr[up].tm>arr[up].street-k?arr[up].candy:0);
	dp[k-arr[lw].street+1][lw][lw][0]=dp[k-arr[lw].street+1][lw][lw][1]=
			(arr[lw].tm>k-arr[lw].street?arr[lw].candy:0);
	int mx=0;
	for(int t=2;t<=2001;++t){
		for(int i=2;i<=m;++i){
			for(int l=1;l+i-1<=m;++l){
				int r=l+i-1;
				dp[t][l][r][0]=max4(dp[max(0,t-(arr[l+1].street-arr[l].street))][l+1][r][0]+(arr[l].tm>=t?arr[l].candy:0),
								   dp[max(0,t-(arr[r].street-arr[l].street))][l+1][r][1]+(arr[l].tm>=t?arr[l].candy:0),
								   dp[max(0,t-(arr[r].street-arr[r-1].street+arr[r].street-arr[l].street))][l][r-1][0]+(arr[r].tm>=t?arr[r].candy:0),
								   dp[max(0,t-(arr[r].street-arr[l].street)*2)][l][r-1][1]+(arr[r].tm>=t?arr[r].candy:0)
								   );
				dp[t][l][r][1]=max4(dp[max(0,t-(arr[r].street-arr[l].street))][l][r-1][0]+(arr[r].tm>=t?arr[r].candy:0),
								   dp[max(0,t-(arr[r].street-arr[r-1].street))][l][r-1][1]+(arr[r].tm>=t?arr[r].candy:0),
								   dp[max(0,t-(arr[l+1].street-arr[l].street+arr[r].street-arr[l].street))][l+1][r][0]+(arr[l].tm>=t?arr[l].candy:0),
								   dp[max(0,t-(arr[r].street-arr[l].street)*2)][l+1][r][1]+(arr[l].tm>=t?arr[l].candy:0)
								   );
				mx=max3(mx,dp[t][l][r][0],dp[t][l][r][1]);
				//cout<<t<<' '<<l<<' '<<r<<' '<<dp[t][l][r][0]<<' '<<dp[t][l][r][1]<<endl;
			}
		}
	}cout<<mx;
	return 0;
}
```

---

## 作者：Engulf (赞：0)

类似的题目：[P1220 关路灯](https://www.luogu.com.cn/problem/P1220)。

考虑动态规划，设 $f_{i, j, t, 0/1}$ 表示取 $[i, j]$ 中的精灵，在时刻 $t$，停在 $i$ 还是 $j$（$0$ 表示停在 $i$，$1$ 表示停在 $j$），能取得的最大价值。

首先当然是对所有精灵按照 $a$ 排序。

转移是十分简单的，因为有点长，我不想打公式，就在代码里解释一下吧。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair<int, int>;

#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif

const int N = 105, M = 2005;

int n, m, k;

struct Genshin {
    int a, b, t;
} a[N];

int f[N][N][M][2];

void chkmax(int &x, int y) {x = max(x, y);}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k >> m;

    for (int i = 1; i <= m; i++) cin >> a[i].a >> a[i].b >> a[i].t;
    // a[++m] = {k, 0, 0};

    sort(a + 1, a + 1 + m, [](Genshin x, Genshin y) {return x.a < y.a;});

    memset(f, -0x3f, sizeof f);
    for (int i = 1; i <= m; i++)
        f[i][i][1 + abs(a[i].a - k)][0] = f[i][i][1 + abs(a[i].a - k)][1] = (1 + abs(a[i].a - k) <= a[i].t ? a[i].b : 0);

    int ans = 0;
    for (int t = 1; t <= 2000; t++)
        for (int len = 2; len <= m; len++)
            for (int i = 1; i + len - 1 <= m; i++) {
                int j = i + len - 1;
                if (t + abs(a[i + 1].a - a[i].a) <= 2000) chkmax(f[i][j][t + abs(a[i + 1].a - a[i].a)][0], f[i + 1][j][t][0] + (t + abs(a[i + 1].a - a[i].a) <= a[i].t ? a[i].b : 0)); // 从 i + 1 走到 i
                if (t + abs(a[j].a - a[i].a) <= 2000) chkmax(f[i][j][t + abs(a[j].a - a[i].a)][0], f[i + 1][j][t][1] + (t + abs(a[j].a - a[i].a) <= a[i].t ? a[i].b : 0)); // 从 j 走到 i
                if (t + abs(a[j].a - a[i].a) <= 2000) chkmax(f[i][j][t + abs(a[j].a - a[i].a)][1], f[i][j - 1][t][0] + (t + abs(a[j].a - a[i].a) <= a[j].t ? a[j].b : 0)); // 从 i 走到 j
                if (t + abs(a[j - 1].a - a[j].a) <= 2000) chkmax(f[i][j][t + abs(a[j - 1].a - a[j].a)][1], f[i][j - 1][t][1] + (t + abs(a[j - 1].a - a[j].a) <= a[j].t ? a[j].b : 0)); // 从 j - 1 走到 j
            }

    for (int t = 1; t <= 2000; t++)
        ans = max({ans, f[1][m][t][0], f[1][m][t][1]});

    cout << ans << "\n";

    return 0;
}
```

---

## 作者：_zexal_ (赞：0)

## 思路
观察题目，发现我们的决策只有两种，要么往左边收集宝可梦，要么往右边。而我们需要维护的信息也只有五种，区间长度，时间，方向和价值。我们考虑动态规划，对于第 $i$ 个点，他只会从 $i+1$ 或 $i-1$ 转换而来。可以得到如下方程，其中 $p_i$ 表示他的距离，$t$ 代表时间，$l,r$ 代表左右端点，$01$ 表示方向，$1$ 为左，$0$ 为右。

```cpp
dp[i][l][r][1]=max(dp[max(i-(p[l+1].num-p[l].num),0)][l+1][r][1],dp[max(i-(p[r].num-p[l].num),0)][l+1][r][0])+p[l].give;
dp[i][l][r][0]=max(dp[max(i-(p[r].num-p[r-1].num),0)][l][r-1][1],dp[max(i-(p[r].num-p[l].num),0)][l][r-1][0])+p[l].give;
```

注意到范围 $N \leq 10^3$ ，所以我们需要一些方法减低数组开的空间。现在，请我们返回题面。对于任意宝可梦，是不需要时间捕捉的。由于我们不需要在意他的过程，我们只需要在意他在区间左右端点即可，所以，我们可以考虑离散化只存储有宝可梦的房间即可。由于 $m\leq 100$ 所以最后我们的空间可以控制在 $10^7$ ，这样，我们就可以过这道题了。
## 细节处理
我们可能开始的时候并不在有宝可梦的地方，我们就从离最近的地方开始状态转移就好了。

---

## 作者：DesignDigits (赞：0)

明确一个常识：在一条直的路上左右走，走过的部分一定是连续的一段。

我们可以将房子进行 **离散化**，即 **只考虑有精灵的房子**，而不考虑没有精灵的房子（因为那些房子得不到糖果）。这样可以把时间复杂度里的 $n$ 都降成 $m$。（我可能讲的不清楚，这一段没明白没关系，不影响看下文）

OK，开始区间 dp。我们设 $\mathit{dp(now, fur, t)}$ (fur=furthest) 表示：

- 已经走过精灵 $\mathit{now}$ 与 $\mathit{fur}$ 之间的路段（包括两端，注意 $\mathit{now}$ 和 $\mathit{fur}$ 的大小关系不确定）；
- 当前位置为精灵 $\mathit{now}$；
- 现在时间为 $t$

的情况下，**当前及以后** 最多能得到多少糖果。**为了方便，我们也考虑已经消失了的精灵。**

![image.png](https://s2.loli.net/2022/08/27/t9Xj2RYZgSalGcL.png)

接下来列状态转移方程。如果 $t$ 小于等于精灵 $\mathit{now}$ 的时限，就能拿到这个精灵的糖果，否则没糖果。

而下一个遇到的 **未经过** 的精灵可以是谁呢？（超过抓捕时限的也算）有两种可能：往前走一步，或者调头往后退一步。即，当 $\mathit{fur<now}$ 时，下一步可以走到精灵 $\mathit{now}+1$ 或 $\mathit{fur}-1$，反之亦然。所以列出状态转移方程如下：(fd=forward, bk=back, pok=pokemon (精灵))

```cpp
int fd = now<fur? now-1: now+1, bk = now<fur? fur+1: fur-1;
dp[now][fur][t] = (t<=pok[now].t? pok[now].candies: 0) + max(
	fd>=1&&fd<=m? dp[fd][fur][t+abs(pok[now].pos-pok[fd].pos)]: 0,
	bk>=1&&bk<=m? dp[bk][now][t+abs(pok[now].pos-pok[bk].pos)]: 0
)
```

需要注意，$\mathit{fd}$ 和 $\mathit{bk}$ 可能是不合法的（从 $1$ 往左走或从 $m$ 往右走），所以需要判断。由于状态转移是往 $t$ 更大的方向，所以写循环应该是 `for(int t=2000; t>=1; t--)` 为最外层。

还有最后一个问题，即起点。因为我们不考虑无精灵的房子了，所以起点 $k$ 可能会不存在（不被考虑），所以我们需要改成从两个地方开始，即 $k$ 往左和往右走分别遇到的第一只精灵。我的实现如下，当然这个的写法挺多的。

```cpp
int k_left_pok=0; // 从起点往左走遇到的第一只精灵（包括起点）
for(int i=m; i>=1; i--){
	if(pok[i].pos<=k){
		k_left_pok = i;
		break;
	}
}
cout<<max(
	k_left_pok>=1? dp[k_left_pok][k_left_pok][1+k-pok[k_left_pok].pos]: 0,
	k_left_pok+1<=m? dp[k_left_pok+1][k_left_pok+1][1+pok[k_left_pok+1].pos-k]: 0
)
```

完整代码不再贴了，关键的部分基本上都在上面了。

你们有没有发现，其实这题要想出 dp 并没有那么难，但是实现起来有比较多坑（要很多特判），而且转移方程长（我这个看起来还好是被我改过的，原来的方程一行硬生生折成了 7 行）。也许这就是它作为紫题的资本吧。

**广告：推荐一下 [我的奆佬同学 @tobie 这题的 $O(n^2)$ 题解](https://www.luogu.com.cn/blog/wjq1234567/solution-p5052)，排在最优解榜 rk 7！而且只要简单离散化一下就能优化到 $O(m^2)$！~~现在看是 rk 8 了，因为我拿他代码 O2 交了一发变成了新的 rk 7~~**

> 其实也可以设 $dp$ 表示 **从开始到现在这个状态为止**，可以得到的最多糖果，但是我感觉，这样推状态转移方程的话，就变成反向想“要到现在这个状态需要从哪里过来”，思考起来会稍微麻烦些。


---


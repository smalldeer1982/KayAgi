# 中国象棋

## 题目背景

$ gjm $  非常喜欢研究棋类问题，最近，他在钻研中国象棋 $QwQ$   

## 题目描述

现在，$ gjm $ 脑海里有一个 $ N $ × $ N $ 的棋盘，其上共有 $ N $ × $ N $个格子，$ gjm $ 开始在棋盘上的格点上摆放卒，已知卒仅会攻击往左边一个格点和往右边一个格点上的棋子，现在 $ gjm $ 开始在棋盘上摆放任意多个卒，满足：

$(1)$ 每一行都至少摆放有两个卒

$(2)$ 任意两个卒都不会互相攻击

$ gjm $ 现在想知道，满足上述条件，有多少种摆放卒的方案？由于答案可能很大，你只需输出方案数对 $ P $  取模的结果即可。

两种方案被认为不同当且仅当存在同一格点的摆放情况不同。

## 说明/提示

**样例1解释**
很明显没有方案

**样例2解释**  ($0$ 表示格点上无卒，$1$ 表示格点上有卒)

仅有一种方案

$1$ $0$ $1$

$1$ $0$ $1$

$1$ $0$ $1$

该样例以及解释无误

**样例3解释**
太大了无法列出所有方案，故不予解释

对于 $ 20 $% 的数据， $ N≤100$，$P≤10^{9}$

对于 $ 50 $% 的数据， $ N≤10^5$，$P≤10^{9}$

对于 $ 100 $%的数据 ， $ N≤10^{18}$，$P≤10^{18}$

$By : $ 学无止境

## 样例 #1

### 输入

```
1 10007```

### 输出

```
0```

## 样例 #2

### 输入

```
2 1000000000```

### 输出

```
1```

## 样例 #3

### 输入

```
7 1000000000```

### 输出

```
612231936```

# 题解

## 作者：学无止境 (赞：11)

本题数据规模较大，容易看出这是一道数学题，有一个坑点，就是格点与格子并不是一个东西，有没有掉坑呢 $QwQ$

然后就是对本题的解决了

首先我们可以发现每一行是独立的，所以只需要处理一行的答案即可

设 $F[i][0]$ 表示一行中摆了 $i$ 个位置且第 $i$ 个位置不摆放棋子的方案数

设 $F[i][1]$ 表示一行中摆了 $i$ 个位置且第 $i$ 个位置摆放棋子的方案数

设 $Ans[i]$ 表示 $F[i][0]+F[i][1]$ 

那么忽略第二个限制可以发现有:

$F[i][0]=F[i-1][0]+F[i-1][1]$  

$F[i][1]=F[i-1][0]$

所以有 

$Ans[i]$

$=F[i][0]+F[i][1]$

$=2F[i-1][0]+F[i-1][1]$

$=(F[i-1][0]+F[i-1][1])+(F[i-2][0]+F[i-2][1])$
		
$=Ans[i-1]+Ans[i-2]$

初始条件：$Ans[1]=2,Ans[2]=3$

可以发现这就是 $Fibonacci$ 数列：$Ans[i]=Fib[i+2]$

接着进行拓展，由于存在第二个限制，仅仅摆了一个棋子的方案以及没有棋子的方案不合法，需要减去 $(i+1)$

所以最终答案是 $Fib[N+3]-N-2$ $(N$即是题目中的含义$)$

接着便可以使用矩阵快速幂在 $O(log_2N)$ 的时间复杂度内求出答案

最后再使用快速幂算出整个棋盘的方案数就好啦

$Code:$
```
#include<iostream>
#include<cstdio>
#include<cstring> 
using namespace std;
struct Martrix
{
	long long f[2][2];
}ans,mat;
long long n,p,temp[2][2];
inline long long multiply(long long a,long long b)
{
	long long x=a,y=b,tmp=0;
	while(y)
	{
		if(y&1)
			tmp=(tmp+x)%p;
		x=(x*2)%p;
		y>>=1;
	}
	return tmp;
}

long long qpow(long long a,long long b)
{
	long long tmp=1;
	while(b)
	{
        if(b&1)
			tmp=multiply(tmp,a);
        a=multiply(a,a);
		b>>=1;
    }
    return tmp;
}

void mat_mul(Martrix &q,Martrix &w)
{
	memset(temp,0,sizeof(temp));
	for(int i=0;i<=1;i++)
		for(int j=0;j<=1;j++)
			for(int k=0;k<=1;k++)
				temp[i][j]=(temp[i][j]+multiply(q.f[i][k],w.f[k][j]))%p;
	memcpy(q.f,temp,sizeof(temp));
}

long long fib(long long a)
{
	while(a)
	{
		if(a&1)
			mat_mul(ans,mat);
		a>>=1;
		mat_mul(mat,mat);
	}
	return ans.f[0][0];
}


int main()
{
	ans.f[0][0]=ans.f[1][1]=mat.f[0][1]=mat.f[1][0]=mat.f[0][0]=1;
	scanf("%lld%lld",&n,&p);
	printf("%lld",qpow(((fib(n+2)-n-2)%p+p)%p,n+1));
	return 0;
} 
```




---

## 作者：Gorenstein (赞：6)

这篇题解侧重介绍不考虑摆放数量的限制时，答案为何为斐波那契序列。当然，解题的其他步骤也不会忽略。

------------

首先显然每一行相互独立，设一行的方案为 $x$，则答案显然为 $x^n$。

先不考虑摆放数量的限制。不妨将总摆放的方案按最后一个摆放位置进行分类。设最后一个棋子在位置 $i$ 的方案数为 $g_i$，有：

$$
g_i=1+\sum_{k=0}^{i-2}g_k
$$

表示枚举除去 $i$ 的最后一个棋子的位置 $k$，并最后加上只有单独 $i$ 一个棋子的方案。

设 $g$ 的前缀和为 $S$，即 $S_i=\sum_{k\leqslant i}a_i$。因 $S_{i-2}=S_{i-3}+g_{i-2}$，故有：

$$
g_{i}=1+S_{i-2}=(S_{i-3}+1)+g_{i-2}=g_{i-1}+g_{i-2}
$$

边界显然为 $g_0=0,g_1=1$。于是这就是一个标准的 $\rm Fibonacci$ 序列。

在不考虑摆放棋子数量的限制时，最终答案显然为 $S_{n}+1$，即对以不同位置结尾的摆放方案进行求和，并加上一个棋子也不放的情况。设 $f_n=S_{n}+1$，不妨先把 $g$ 和 $S$ 的表打出来。

$$
\begin{matrix}
\,\,n=&1&2&3&4&5&6&7\\
g_n=&1&1&2&3&5&8&13\\
f_n=&2&3&5&8&13&21&34
\end{matrix}
$$

真是太神奇了，$f$ 居然也是一个砍掉了前两位的 $\rm Fibonacci$ 序列。怎么回事呢？下面就来解释这个结果。

考虑设 $G(z)=\sum\limits_{k=0}^{\infty}g_kz^k$ 为序列 $f$ 的生成函数，其中令 $g<0$ 的 $f_{k}$ 均为 $0$。根据 $g$ 的递归关系 $g_n=g_{n-1}+g_{n-2}+[n=1]$，显然有：

$$
G(z)=\sum\limits_{k=0}^{\infty}g_kz^k=\sum_{k=0}^{\infty}g_{k-1}z^{k}+\sum_{k=0}^{\infty}g_{k-2}z^{k}+\sum_{k=0}^{\infty}[n=1]z^k
$$

$$
=\sum_{k=0}^{\infty}g_{k}z^{k+1}+\sum_{k=0}^{\infty}g_{k}z^{k+2}+z
$$

$$
=zG(z)+z^2G(z)+z
$$

解得：

$$
G(z)=\frac{z}{1-z-z^2}
$$

我们设 $F_1(z)$ 为 $S_{n}+1$ 的生成函数，$F_2(z)$ 为 $g_{n+2}$ 的生成函数。根据前面打出的那张表，这两个东西应该是相等的。

$F_2(z)$ 是很容易求出的。因 $g_{n+2}=g_n+g_{n+1}$，故：

$$
F_2(z)=G(z)+\sum_{k=0}^{\infty}g_{k+1}z^{k}=G(z)+\frac{1}{z}\sum_{k=0}^{\infty}g_kz^{k}
$$

$$
=G(z)+\frac{1}{z}G(z)
$$

现在考虑求 $F_1(z)$。先求 $S_n$ 的生成函数，有个经典结论是 $k$ 维前缀和的生成函数应当乘上 $\frac{1}{(1-z)^k}$，具体来说：

$$
S(z)=G(z)\left(1+z+z^2+z^3+\cdots\right)=\frac{G(z)}{1-z}
$$

$F_1(z)$ 即为 $G(z)+\sum\limits_{k=0}^{\infty}z^k=G(z)+\frac{1}{1-z}$。将 $G(z)$ 代入可得：

$$
F_1(z)=\frac{1}{1-z}\left(1+\frac{z}{1-z-z^2}\right)
$$

$$
=\frac{1}{1-z}\frac{1-z^2}{1-z-z^2}=\frac{1+z}{1-z-z^2}
$$

$$
=G(z)+\frac{1}{z}G(z)
$$

即得 $F_1(z)=F_2(z)$。从而我们就证明了 $f_n=g_{n+2}$。

这样就解释了 $f$ 作为一个砍掉前两位的 $\rm Fibonacci$ 序列的原因。现在我们加上了限制，那么不放棋子的那种情况肯定不合法了，并且只放一个的情况也不合法了，这些的数量为 $n+1$。对于每一行我们只需先求出 $f_n$，然后再减去 $n+1$ 即可。

求 $\mathit{fib}_n$ 是一个非常典的矩阵加速：

$$
(\mathit{fib}_n,\mathit{fib}_{n-1})\begin{pmatrix}1&1\\1&0\end{pmatrix}=(\mathit{fib}_{n+1},\mathit{fib}_{n})
$$

直接上矩阵快速幂即可。注意模数最大可以到 $10^{18}$，要用快速乘。

---

## 作者：珅肐 (赞：5)

不得不说这题稍有些恶心，

先是格点，推不出样例卡了半天

再是取模，没用快速乘又爆longlong

快速乘之后，T了六个点，调了调一看幂是负的

气炸..

---

咳咳
### 正题：

如果你做过[P5004 专心OI - 跳房子](https://www.luogu.org/problemnew/show/P5004)，那是极好的

$5004$这道题$m$=$1$的时候，跟这道题几乎一样，

有兴趣可以试一试

先不说它

看这道题，容易发现行与行是独立的，就是说只要求出一行的方案数，答案就是它的$n$次方。

（注：本文所指的的$n$都是一行有多少个位置）

我们从简单的考虑,先去掉"每行至少有两个卒"这个条件

那么简单推一推就可以发现：这是个斐波那契数列！



$n=3: 1+3+1=5$

$n=4: 1+4+2=8$

$n=5: 1+5+(3+2+1)+1=13$

$n=6: 1+6+(4+3+2+1)+(2+1+1)=21$

$n=7: 1+6+(5+4+3+2+1)+((3+2+1)+(2+1)+(1)+(1))+1=34$

.

.


那么，加上“至少有两个卒”的条件就是把前面两项去掉就好了

思路就很明了了：算出斐波那契数列第n+1项，减去前面两项，即-n-1，算出它的n次方输出

噢对！

关于模数最大为1e18，若直接相乘会爆longlong，这里用了快速乘，当然，int28也可以，而且会快。


#### 完整代码奉上！

```cpp
#include<iostream>
#include<cstdio>
#include<ctype.h>
using namespace std;
typedef long long ll;
ll mod;
inline ll read(){
	ll x=0,f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return f?-x:x;
}
inline ll Slow_Mul(ll b,ll p){//快速乘
	ll ans=0;
	while(p){
		if(p&1)ans=(ans+b)%mod;
		b=(b+b)%mod;p>>=1;
	}
	return ans;
}
inline void Mati_Mul(ll a[][2],ll b[][2]){//矩阵乘
	ll c[2][2]={0};
	for(int i=0;i<=1;++i)
		for(int j=0;j<=1;++j)
			for(int k=0;k<=1;++k)
				c[i][j]=(c[i][j]+Slow_Mul(a[i][k],b[k][j]))%mod;
	for(int i=0;i<=1;++i)for(int j=0;j<=1;++j)a[i][j]=c[i][j];
}
inline ll Mati_Fast_pow(ll p){//矩阵快速幂
	ll ans[2][2]={1,0,0,1};//答案矩阵
	ll b[2][2]={0,1,1,1};//常用斐波那契的矩阵
	ll f[2][2]={1,1,0,0};//初始矩阵
	while(p){
		if(p&1)Mati_Mul(ans,b);
		Mati_Mul(b,b);p>>=1;
	}
	Mati_Mul(f,ans);
	return f[0][1];
}
inline ll Fast_pow(ll b,ll p){//快速幂
	ll ans=1;if(b<0)cout<<b;
	while(p){
		if(p&1)ans=Slow_Mul(ans,b)%mod;
		b=Slow_Mul(b,b)%mod;p>>=1;//注意把所有乘法都换成快速乘
	}
	return ans;
}
int main(){
	ll n=read()+1;mod=read();
	cout<<Fast_pow(((Mati_Fast_pow(n)-n-1)%mod+mod)%mod,n);//第n+1项只需做n次乘法
	return 0;//好习惯
}

```


---

## 作者：Semorius (赞：4)

首先中国象棋是放在格点上的，所以先 $n \gets n+1$ 转化为放在方格上。~~样例因为这个看了好久没看懂~~

又由于每个卒只能攻击与其相邻的两个卒，所以容易发现行与行之间是独立的，所以只考虑一行中的情况。

对于每行至少放两个棋子的限制，可以先抛开不管，最后减去只放一个或不放的 $n+1$ 种情况。

设 $dp_{i,1/0}$ 表示在当前行中考虑到第 $i$ 位，第 $i$ 位放或不放的方案数，由于不能有相邻的两个卒，于是可以得到如下转移：

$$
\begin{aligned}
&dp_{i,1}=dp_{i-1,0}\\
&dp_{i,0}=dp_{i-1,1}+dp_{i-1,0}\\
\end{aligned}
$$

因为 $N \leq 10^{18}$，所以可以用矩阵加速 $\text{dp}$。

$$\begin{vmatrix}dp_{i-1,0}&dp_{i-1,1}\end{vmatrix}\begin{vmatrix}1&1\\1&0\end{vmatrix}=\begin{vmatrix}dp_{i,0}&dp_{i,1}\end{vmatrix}$$

求出每一行的方案以后，根据乘法原理，总方案数为每行的方案数之积。

计算过程可能爆 $\text{long long}$，要开 $\text{int128}$。

时间复杂度 $O(8 \log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll SIZE = 200005;
ll n, mod;

inline ll rd(){
	ll f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f*x;
}

inline void wt(ll x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9)
		wt(x/10);
	putchar(x%10+'0');
}

struct node{
	ll o[2][2];
	node(){
		for(ll i = 0; i < 2; i++)
			for(ll j = 0; j < 2; j++)
				o[i][j] = 0;
	}
};

node mul(node A, node B){
	node jl;
	for(ll i = 0; i < 2; i++)
		for(ll j = 0; j < 2; j++)
			for(ll k = 0; k < 2; k++)
				jl.o[i][j] = (jl.o[i][j] + ((__int128)A.o[i][k] * B.o[k][j] % mod)) % mod;	
	return jl;
}

node power(node x, ll y){
	node jl;
	for(ll i = 0; i < 2; i++) jl.o[i][i] = 1;
	while(y){
		if(y&1) jl = mul(jl, x);
		x = mul(x, x);
		y >>= 1;
	}
	return jl;
}

ll power(ll x, ll y){
	ll jl = 1;
	while(y){
		if(y&1) jl = ((__int128)jl *  x) % mod;
		x = ((__int128)x * x) % mod;
		y >>= 1;
	}	
	return jl;
}

int main(){
	n = rd()+1, mod = rd();
	if(n <= 2){
		printf("0");
		return 0;
	}
	node ans;
	ans.o[0][0] = ans.o[0][1] = ans.o[1][0] = 1; ans.o[1][1] = 0;
	ans = power(ans, n-1);
	ll jl = ((ans.o[0][0] + ans.o[0][1])%mod + (ans.o[1][0] + ans.o[1][1])%mod)%mod;
	jl = ((jl - n - 1) % mod + mod) % mod;
	wt(power(jl, n));
	return 0;
}
```


---

## 作者：Dirt、 (赞：4)

这个题我的做法不太一样

~~（虽然会跑得更慢但是还是发一下）~~

先从某一行的情况入手。

我们设 $f(i,0)$ 表示放到了第 $i$ 个位置，第 $i$ 个位置不放棋子的方案数

$f(i,1)$ 表示放到了第 $i$ 个位置，第 $i$ 个位置放棋子的方案数

这里有一个限制，就是每行放置的棋子数必须大于等于 $2$

对于第 $i$ 个位置不放的情况，前面可以随便放

得到 $f(i,0) = f(i-1,0) + f(i-1,1)$

对于第 $i$ 个位置放的情况，在第 $i-1$ 个位置一定不能放

所以所有在第 $i-1$ 个位置不放的方案都成立

但是还有一点：前面只放了一个棋子的方案也可以成立

因为第 $i-1$ 个位置不能放棋子，所以前面只放一个棋子的方案数为 $i-2$

得到 $f(i,1) = f(i-1,0) + i-2$

一行的总方案数为 $f(i,0) + f(i,1)$

因为卒只会攻击同一行的棋子，所以每行的状态是互不影响的

所以最终方案数为 $[f(i,0) + f(i,1) ] ^ N $

由于 $N$ 过大我们用矩阵加速递推

设矩阵

$\begin{vmatrix}f(i,0)&f(i,1)&i-1&1\end{vmatrix}$ 

令 $i=3$ 时的矩阵为初始矩阵

则初始矩阵为

$\begin{vmatrix}0&1&2&1\end{vmatrix}$ 

可以得到转移矩阵

$\begin{vmatrix}1&1&0&0\\1&0&0&0\\0&1&1&0\\0&0&1&1\end{vmatrix}$

跑完矩乘跑快速幂就可以了

此题的坑点：

相乘会爆$long\ long$，需要使用龟速乘

$N$ 是格子数不是格点数，$N+1$ 才是格点数，实际上有$(N+1)$行$(N+1)$列 ~~（我还因为这个发了讨论）~~

注意特判$N$较小的情况

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
struct Mat
{
    ll a[5][5];
    Mat(){memset(a,0,sizeof(a));}
}base,st;
ll n,mod;
ll add(ll a,ll b)
{
    ll res=a+b;
    if(res>=mod) res-=mod;
    return res;
};
ll mul(ll x,ll b)
{
    ll res=0;
    while(b)
    {
        if(b&1) res=add(res,x);
        x=add(x,x);
        b>>=1;
    }
    return res;
}
ll fpowll(ll x,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1) res=mul(res,x);
        x=mul(x,x);
        b>>=1;
    }
    return res;
}
Mat operator * (const Mat &a,const Mat &b)
{
    Mat c;
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            for(int k=1;k<=4;k++)
                c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j]));
    return c;			
}
Mat fpow(Mat x,ll b)
{
    Mat res;
    for(int i=1;i<=4;i++)
        res.a[i][i]=1;
    while(b)
    {
        if(b&1) res=res*x;
        x=x*x;
        b>>=1;
    }
    return res;
}
int main()
{
    cin>>n>>mod;
    n++;
    if(n<3)
    {
        putchar('0');
        return 0;
    }
    st.a[1][2]=st.a[1][4]=1;
    st.a[1][3]=2;
    base.a[1][1]=base.a[1][2]=base.a[2][1]=base.a[3][2]=base.a[3][3]=base.a[4][3]=base.a[4][4]=1;
    st=st*fpow(base,n-3);
    cout<<fpowll(add(st.a[1][1],st.a[1][2]),n);
    return 0;
}
```

如果有疑问欢迎提出~

---

## 作者：Alex_Wei (赞：3)

> [P5059 中国象棋 题目传送门](https://www.luogu.com.cn/problem/P5059)。

注意到每一列是独立的，且方案数为 $fib_{n+3}-(n+2)$：设 $f_i$ 表示第 $i$ 列（从 $1$ 下标开始，共有 $n+1$ 列）不放棋子且任意两个不放棋子的格子间隔不超过 $2$ 的方案数，则有 $f_0=f_1=1$，$f_i=f_{i-1}+f_{i-2}$， 则 $f_i=fib_{i+1}$。总方案数为 $f_{n+1}+f_n=f_{n+2}=fib_{n+3}$，再减去全部不放的 $1$ 种和只有一个放的 $n+1$ 种即可。故答案为 $(fib_{n+3}-n-2)^{n+1}$。计算 $fib$ 用矩阵快速幂即可。注意要用慢速乘。

时间复杂度 $\mathcal{O}(\log^2 n)$。

```cpp
ll n, p;
void add(ll &x, ll y) {
	x = (x + y) % p;
}
ll mul(ll x, ll y) {
	ll s = 0;
	while(y) {
		if(y & 1) add(s, x);
		x = (x << 1) % p, y >>= 1;
	}
	return s;
}
ll ksm(ll a, ll b) {
	ll s = 1;
	while(b) {
		if(b & 1) s = mul(s, a);
		a = mul(a, a), b >>= 1;
	}
	return s;
}

struct Matrix {
	ll a[2][2];
	Matrix() {mem(a, 0, 2);}
	friend Matrix operator * (Matrix x, Matrix y) {
		Matrix z;
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				for(int k = 0; k < 2; k++)
					add(z.a[i][j], mul(x.a[i][k], y.a[k][j]));
		return z;
	}
} base, c, I;

Matrix ksm(Matrix a, ll b) {
	Matrix ans = I;
	while(b) {
		if(b & 1) ans = ans * a;
		a = a * a, b >>= 1;
	}
	return ans;
}

int main() {
	cin >> n >> p;
	I.a[0][0] = I.a[1][1] = 1;
	base.a[0][0] = base.a[1][0] = base.a[0][1] = 1;
	c.a[0][0] = 2, c.a[0][1] = 1;
	ll res = (c * ksm(base, n)).a[0][0] - n - 2;
	res = (res % p + p) % p;
	cout << ksm(res, n + 1) << endl;
	return 0;
}
```

哦，上帝，请原谅我写水题题解。

---

## 作者：Leowang2009 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5059)

这道题总体来说代码实现并不难，主要是思路较为难，且代码细节较多。
# 思路
首先看题目，注意是要放在格点上，所以输入 $n$ 时可以将 $n+1$，更便于理解。

接下来，由于“卒”只能向左或向右走，所以只用单独考虑每行的情况，然后根据乘法原理用快速幂解决。

下面将说明如何求每行的情况数：

题目中有限制，说每行至少有两枚棋子，为了方便起见，我们可以考虑用总情况数减去不符合条件的情况数。
## 1.总情况数：
设 $dp[i]$ 为已经考虑过 $i$ 格后的总情况数。

对于第 $i$ 格，有两种情况，放和不放。

对于放的情况，根据题意可以知道，第 $i-1$ 格一定不能放，故此时应将 $dp[i]$ 加上 $dp[i-2]$。

对于不放的情况，此时就相当于是第 $i-1$ 格的情况，故 $dp[i]$ 此时应加上 $dp[i-1]$。

综上，可得动态转移方程为：
$$dp[i]=dp[i-1]+dp[i-2]$$
这个明显是斐波那契数列啊，再加上题目中说的 $N\le 10^{18}$，想到用矩阵快速幂求解。
### code:
```cpp
int Fibonacci(int x){
	//矩阵快速幂，其实就是求斐波那契数列
	node res,cnt;
	cnt.a[1][0]=cnt.a[0][1]=cnt.a[1][1]=res.a[0][0]=res.a[0][1]=1;
	cnt.a[0][0]=res.a[1][0]=res.a[1][1]=0;
	while(x){
		if(x&1) res=mul(res,cnt);
		cnt=mul(cnt,cnt),x>>=1;
	}return res.a[0][0]%mod;
}
```
## 2.不符合条件的情况数：
共分为两种，也很好想，一种是放了零个，显然只有一种，其次是放了一个，只有 $n$ 种，在最后求解总情况数时减掉就好了。
# 代码
这道题代码实现较为简单，但注意到数据范围很大，需要用到~~快速乘~~龟速乘以避免爆 ```long long```，还有减掉不符合的情况时要考虑结果为负数的情况，取模一下就可以了，要不然会被卡掉。
## AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,mod;
struct node{
	int a[2][2];
};
int multi(int a,int b){//龟速乘
	int res=0;
	while(a){
		if(a&1) res=(res+b)%mod;
		b=(b*2)%mod,a>>=1;
	}return res%mod;
}
node mul(node a,node b){//矩阵乘
	node c;
	memset(c.a,0,sizeof(c.a));
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			for(int k=0;k<2;k++)
				c.a[i][j]=(multi(a.a[i][k],b.a[k][j])+c.a[i][j])%mod;
	return c;
}
int Fibonacci(int x){
	//矩阵快速幂，其实就是求斐波那契数列
	node res,cnt;
	cnt.a[1][0]=cnt.a[0][1]=cnt.a[1][1]=res.a[0][0]=res.a[0][1]=1;
	cnt.a[0][0]=res.a[1][0]=res.a[1][1]=0;
	while(x){
		if(x&1) res=mul(res,cnt);
		cnt=mul(cnt,cnt),x>>=1;
	}return res.a[0][0]%mod;
}
int qpow(int d,int x){//快速幂
	int res=1;
	while(x){
		if(x&1) res=multi(res,d);
		d=multi(d,d),x>>=1;
	}return res%mod;
}
signed main(){
	scanf("%lld%lld",&n,&mod),n++;
	if(n<=2) printf("0");//小于二时显然无解
	else printf("%lld",qpow(((Fibonacci(n+1)-n-1)%mod+mod)%mod,n));//一定要再取模一次！
	return 0;
}
```
完结撒花！

---

## 作者：翼德天尊 (赞：1)

注意到每一行都答案其实是相对独立且相同的，所以只需要算出一行的答案，即可得到整个棋盘的答案。

我们都关注哪些信息呢？阶段显然是设置成当前处理到了前 $i$ 个格点，除此之外，我们显然还关心当前格点有没有放置卒且当前行一共有几个卒，这样才能使我们转移出的方案满足题目中给定的两个条件。

那么现在其实就有两种设置状态的选择：

- 设 $dp_i$ 表示处理完前 $i$ 个格点的方案数，且第 $i$ 个格点强制放置时的方案数，此时我们只需要枚举上一次放置的格点，注意一些细节即可同时满足两个条件。 
- 设 $dp_{i,0/1,0/1/2}$ 表示处理完了前 $i$ 个格点，且第 $i$ 个格点 没有放置/放置棋子，本行目前 没有棋子/有一个棋子/棋子个数达到要求 时的方案数。则转移时考虑上一个格子的状态即可。

两个 dp 状态设置的区别在于一个强制选择而另一个不强制选择，正常来说应该是第一个 dp 更方便一些的，但是观察到此题的数据范围，$N\le 10^{18}$，果断考虑矩阵加速优化，那么由于矩阵转移的特殊性，转移时决策显然是越少越好的，第一种的决策涉及到了前面的所有状态，显然无法写成矩阵，于是我们便采取了第二种状态设计方式。

对于每一个阶段，一共有六种不同的状态，所以我们设计一个 $6\times 6$ 的矩阵即可优化转移。最后将答案 $s$ 作一个 $n$ 次幂即可。

注意到模数的取值范围，记得使用龟速乘。

时间复杂度 $O(6^3\log N\log P)$.

```cpp
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
const int N=6;
ll n,p;
struct node{
	ll a[N][N];
	node(){
		memset(a,0,sizeof(a));
	}
	void init(){
		for (int i=0;i<N;i++) a[i][i]=1;
	}
	void init1(){
		a[0][0]=1;
	}
	void init2(){
		a[0][0]=a[0][4]=1;
		a[1][1]=a[1][5]=1;
		a[2][2]=a[2][5]=1;
		a[4][1]=1;
		a[5][2]=1;
	}
};
ll ksc(ll x,ll y){
	ll ans=0;
	while (y){
		if (y&1) ans=(ans+x)%p;
		x=(x+x)%p;
		y>>=1;
	}
	return ans;
}
node operator *(const node&x,const node&y){
	node z;
	for (int k=0;k<N;k++)
		for (int i=0;i<N;i++)
			for (int j=0;j<N;j++)
				z.a[i][j]=(z.a[i][j]+ksc(x.a[i][k],y.a[k][j]))%p;
	return z;
}
node ksm(node S,ll y){
	node H;
	H.init();
	while (y){
		if (y&1) H=H*S;
		S=S*S;
		y>>=1;
	}
	return H;
}
ll read(){
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
ll ksm2(ll x,ll y){
	ll ans=1;
	while (y){
		if (y&1) ans=ksc(ans,x);
		x=ksc(x,x);
		y>>=1;
	}
	return ans;
}
int main(){
	n=read()+1,p=read();
	node S,P;
	S.init1(),P.init2();
	S=S*ksm(P,n);
	ll ans=ksm2((S.a[0][2]+S.a[0][5])%p,n);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Φρανκ (赞：1)

新手第一篇题解，望包涵。

题意：在 $n\times n$ 的棋盘**格点**上放置若干棋子，使每行有至少两枚棋子且棋子两两不能横向相邻，求放置方法数。

核心思想：数列代换

解：

容易发现，每行之间不会相互影响。

设在长度为 $a$ 的一行中放置 $b$ 个子的方法数为 $A(a, b)\:(a, b\in\mathbb{N})$，则有:

$A(a, b)=A(a-1, b)+A(a-2, b-1)\:(b>1)$

其中第一项对应最后一格不放棋子的方法数，第二项对应最后一格放棋子的方法数。

令 $f(x)=\sum_{i=2}^{x}A(x, i)$，则有

$f(x)=f(x-1)+f(x-2)+A(x-2, 1)$，

即 $f(x)=f(x-1)+f(x-2)+x-2$.

观察到该数列的相邻项之比与 $\frac{\sqrt{5}+1}{2}$ 接近，考虑其与斐波那契数列的关系。

~~直接上OEIS，此题解决~~

经过~~Excel乱算~~观察，发现 $f(x)-f(x-1)=F(x)-1$，故所求即 $\Sigma F(i)-x$.

由斐波那契数列定义 $F(x)=F(x-1)+F(x-2)\:(x\ge3)$，有

$\sum F(x)=(F(2)+...+F(x-1))+(F(1)+...+F(x-2))+F(1)+F(2)$

即 $\sum F(x)=\sum F(x-1)+\sum F(x-2)+1$.

$\sum F(i)$ 的形式就类似于 $F(i+1)$. 

由定义，有 $\sum F(x)=\sum F(x-1)+F(x)$：

若 $\sum F(x)=F(x+2)-1$，有

$\sum F(x+1)=F(x)+F(x-1)-1=F(x+3)-1$.

观察有 $\sum F(1)=F(3)-1$.

由数学归纳法，$\forall x\ge1$，$\sum F(x)=F(x+1)-1+F(x)=F(x+2)-1$.

代入可得 $f(x)=F(x+2)-x-1$，而题目所求结果为 $f(n+1)^{n+1}\bmod p$，求算即可。时间复杂度 $O(\log^2n)$，不会 T。快速幂 + 快速倍增，遂 A。


------------


代码太烂，恕不附。






---

## 作者：tuo3288 (赞：1)

该题是本蒟蒻的第一道紫题，发下自己的思路纪念一下。

首先，格点与格子是两码事。每行每列，格点数=格子数+1，千万别点进坑里啊。

其次，对于此题，因为卒只能吃到左右，所以我们只需考虑一行里方案的总数，之后再乘方即可。

出于此题数据范围过大，所以我的第一想法是，矩阵快速幂。

由于我太菜了，所以我先打了一个深搜，求一下小数据的结果。

深搜代码太过丑陋，连剪枝都没有，就不拿出来丢人啦。

结果如下：一行可以有的情况数：

 n  2 ，3 ，4 ，5 ，6 ，7 ，8 ，9

res  0 ，1 ，3 ，7 ，14 ，26 ，46 ，79 ，133

之后，我眼睁睁看了四个点，写了三张草纸，才发现：

设 f[i] 表示斐波那契数列第i项；

s[i]表示前i项的和;

t[i]=1乘以f[1] + 2乘以f[2] + 3乘以f[3]…… + i乘以f[i];

则res[i]=n*s[i]-t[i]=(n-1)f[1]+(n-2)f[2]+(n-3)f[3]……+(n-(n-1))f[n-1];

由此可得，res[i]=res[i-1]+s[i-1];

所以，矩阵乘法的底矩阵base为

base[1][1]=base[1][2]=base[2][1]=base[3][1]=base[3][3]=base[4][3]=base[4][4]=0;

接下来利用矩阵快速幂，即可求解。

//但是我太低估出题者的神威了//

这道题的数据用long long装不下；

所以我用了高精度。可能代码有点晦涩，用了一些初学者理解不了的东西，但是高精可以慢慢打，思路最重要。

AC代码：
```cpp
#include<cstring>
#include<iostream>
#include<vector>
using namespace std;
struct int_X:vector<int>
{
    int_X(int n=0)
    {
        push_back(n);
        check();
    }
    int_X& check()
    {
        while(!empty()&&!back())pop_back();
        if(empty())return *this;
        for(int i=1;i<size();++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;
    }
};
istream& operator>>(istream &is,int_X &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1;i>=0;--i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const int_X &n)
{
    if(n.empty())os<<0;
    for(int i=n.size()-1;i>=0;--i)os<<n[i];
    return os;
}
bool operator!=(const int_X &a,const int_X &b)
{
    if(a.size()!=b.size())return 1;
    for(int i=a.size()-1;i>=0;--i)
        if(a[i]!=b[i])return 1;
    return 0;
}
bool operator==(const int_X &a,const int_X &b)
{
    return !(a!=b);
}
bool operator<(const int_X &a,const int_X &b)
{
    if(a.size()!=b.size())return a.size()<b.size();
    for(int i=a.size()-1;i>=0;--i)
        if(a[i]!=b[i])return a[i]<b[i];
    return 0;
}
bool operator>(const int_X &a,const int_X &b)
{
    return b<a;
}
bool operator<=(const int_X &a,const int_X &b)
{
    return !(a>b);
}
bool operator>=(const int_X &a,const int_X &b)
{
    return !(a<b);
}
int_X& operator+=(int_X &a,const int_X &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0;i!=b.size();++i)a[i]+=b[i];
    return a.check();
}
int_X operator+(int_X a,const int_X &b)
{
    return a+=b;
}
int_X& operator-=(int_X &a,int_X b)
{
    if(a<b)swap(a,b);
    for(int i=0;i!=b.size();a[i]-=b[i],++i)
        if(a[i]<b[i])
        {
            int j=i+1;
            while(!a[j])++j;
            while(j>i)
            {
                --a[j];
                a[--j]+=10;
            }
        }
    return a.check();
}
int_X operator-(int_X a,const int_X &b)
{
    return a-=b;
}
int_X operator*(const int_X &a,const int_X &b)
{
    int_X n;
    n.assign(a.size()+b.size()-1,0);
    for(int i=0;i!=a.size();++i)
        for(int j=0;j!=b.size();++j)
            n[i+j]+=a[i]*b[j];
    return n.check();
}
int_X& operator*=(int_X &a,const int_X &b)
{
    return a=a*b;
}
int_X divmod(int_X &a,const int_X &b)
{
    int_X ans;
    for(int t=a.size()-b.size();a>=b;--t)
    {
        int_X d;
        d.assign(t+1,0);
        d.back()=1;
        int_X c=b*d;
        while(a>=c)
        {
            a-=c;
            ans+=d;
        }
    }
    return ans;
}
int_X operator/(int_X a,const int_X &b)
{
    return divmod(a,b);
}
int_X& operator/=(int_X &a,const int_X &b)
{
    return a=a/b;
}
int_X& operator%=(int_X &a,const int_X &b)
{
    divmod(a,b);
    return a;
}
int_X operator%(int_X a,const int_X &b)
{
    return a%=b;
}
int_X pow(const int_X &n,const int_X &k)
{
    if(k.empty())return 1;
    if(k==2)return n*n;
    if(k.back()%2)return n*pow(n,k-1);
    return pow(pow(n,k/2),2);
}
struct M
{
	int_X a[5][5];
	M(){
		memset(a,0,sizeof(a));
	}
}ans,base;
int_X mod;
M mul(M m,M n)
{
	M c;
	for(int i=1;i<=4;i++){
		for(int k=1;k<=4;k++){
			if(m.a[i][k]!=0){
				for(int j=1;j<=4;j++)c.a[i][j]=(c.a[i][j]+m.a[i][k]*n.a[k][j]%mod)%mod;
			}
		}
	}
    return c;
}
void pre()
{
	ans.a[1][1]=ans.a[1][2]=0;
	ans.a[1][3]=ans.a[1][4]=1;
	base.a[1][1]=base.a[1][2]=base.a[2][1]=base.a[3][1]=base.a[3][3]=base.a[4][3]=base.a[4][4]=1;
}
int_X caculate(int_X x)
{
	pre();
	x-=1;
	while(x>0)
	{
		if(x%2==1)ans=mul(ans,base);
		base=mul(base,base);
		x/=2;
	}
	return ans.a[1][1];
}
int_X fast(int_X a,int_X b)
{
	int_X e=1;
	while(b>0){
		if(b%2==1){
			e=(e%mod)*(a%mod)%mod;
		}
		a=(a%mod)*(a%mod)%mod;
		b/=2;
	}
	return e%mod;
}
int main()
{
	int_X n;
	cin>>n>>mod;
	if(n<3)cout<<"0";
	else if(mod==1)cout<<"0";
	else cout<<fast(caculate(n),n+1);
	return 0;
}
```

---

## 作者：Butterfly_qwq (赞：0)

先考虑 $N\times 1$ 格点的情况。

忽略掉第一个条件，设 $dp_{i,0}$ 为表示一行中摆了 $i$ 个位置且第 $i$ 个位置不摆放棋子的方案数，设 $dp_{i,1}$ 为表示一行中摆了 $i$ 个位置且第 $i$ 个位置摆放棋子的方案数。

则：$dp_{i,0}=dp_{i-1,0}+dp_{i-1,1}$，$dp_{i,1}=dp_{i-1,0}$。

$dp_{i,0}+dp_{i,1}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,0}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-2,0}+dp_{i-2,1}$。

定睛一看，这不就是斐波拉契数列吗？

矩阵快速幂解决。

还有第一个条件，所以就是要将答案减去 $(N+1)$。

总答案还要变为原先的 $N$ 次方，所以用一次快速幂就解决了。

时间复杂度：$O(\log N)$。

最后有一个坑点：$N\times N$ 的格子是 $(N+1)\times(N+1)$ 个格点。

Code:

```
#include<bits/stdc++.h>
#define int __int128
using namespace std;
int n,mod;
struct matrix
{
	int c[2][2];
}dp,trans;
matrix mul(matrix p,matrix q)
{
	matrix r;
	for(int i=0;i<2;i++)for(int j=0;j<2;j++)r.c[i][j]=0;
	for(int i=0;i<2;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)(r.c[i][j]+=p.c[i][k]*q.c[k][j])%=mod;
	return r;
}
int qpow(int a,int x)
{
	if(x==0)return 1;
	if(x==1)return a;
	int c=qpow(a,x/2),y=qpow(a,x%2);
	return c*y%mod*c%mod;
}
int fib(int x)
{
	while(x)
	{
		if(x&1)dp=mul(dp,trans);
		trans=mul(trans,trans);
		x>>=1;
	}
	return dp.c[0][0];
}
signed main()
{
	cin>>n>>mod;
	dp.c[0][0]=dp.c[1][1]=trans.c[0][0]=trans.c[0][1]=trans.c[1][0]=1;
	cout<<qpow(((fib(n+2)-n-2)%mod+mod)%mod,n+1);
}
```

由于有 __int128（不然会炸掉）需要使用 C++11。

亲测 long long 60pts，unsigned long long 50pts。

---


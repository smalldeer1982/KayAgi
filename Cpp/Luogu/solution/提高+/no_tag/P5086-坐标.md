# 坐标

## 题目背景

题解：<https://blog.csdn.net/kkkksc03/article/details/84928342>。

小奔知道 Minecraft 的坐标参数有三个，分别是 $X, Y, Z$，但是在小奔的眼中，有第四个参数 $Q$，表示对这个坐标的喜爱，比如有些位置是小奔的家，$Q$ 的值会大，而有些地方是危险的矿洞，所以 $Q$ 的值小。

## 题目描述

有 $N$ 个坐标。对于第 $i$ 个坐标的参数 $\{X _ i, Y _ i, Z _ i, Q _ i\}$ 和 $\{X _ j, Y _ j, Z _ j, Q _ j\}$ 存在 $X _ i - X _ j = Y _ i - Y _ j = Z _ i - Z _ j = Q _ i - Q _ j$ 则称该坐标为优美坐标。现给出 $N$ 个坐标，小奔想知道所有优美坐标的 $j - i$ 的最小值和 $i + j$ 的最大值，你能帮帮他吗？

## 说明/提示

### 样例 1 解释：

$(1, 2, 3, 4)$ 和 $(2, 3, 4, 5)$ 或 $(1, 4, 3, 3)$ 和 $(2, 5, 4, 4)$ 构成最小值。

$(1, 4, 3, 3)$ 和 $(2, 5, 4, 4)$，$6 + 7 = 13$ 为最大值。

### 数据规模与约定

对于 $30\%$ 的数据，$n \le 10 ^ 3$；    
对于 $100\%$ 的数据，$1 \le n \le 5 \times 10 ^ 5 $，$X, Y, Z, Q$ 均在 `int` 范围内。

## 样例 #1

### 输入

```
7
1 2 3 4
2 3 4 5
1 4 3 3
5 2 3 5
2 4 5 6
1 4 3 3
2 5 4 4```

### 输出

```
1 13```

## 样例 #2

### 输入

```
10
1 4 3 2
4 4 4 4
2 3 4 5
1 1 1 1
1 2 3 1
3 4 2 1
2 4 5 2
8 9 7 6
0 0 0 0
1 2 3 4```

### 输出

```
2 14```

# 题解

## 作者：Kevin_Wa (赞：7)

本题居然变成了比赛里最送分的题目，还成了提高+/省选-，这恶意评分怕是有毒。

题意解析：

找两个优美坐标，要想知道所有优美坐标的$j$-$i$的最小值和$i$+$j$的最大值，

$Xi$-$Xj$=$Yi$-$Yj$=$Zi$-$Zj$=$Qi$-$Qj$我们可以将四个数组换成三个，即

$Ai$=$Yi$-$Xi$;$Bi$=$Zi$-$Yi$;$Ci$=$Qi$-$Zi$;

所以只要满足 $Ai$=$Aj$ $Bi$=$Bj$ $Ci$=$Cj$ 即可满足要求

在加一个数组表示输入时他的位置，我们将四个数组四关键字从小到大排序一下，再记录一下最值即可，用最长不降子序列，时间复杂度$O$($N$)，算上快排$O$($N$ $log$ $N$)

代码（标程是$Pascal$，但$C++$快排要简单，且怕与vecont程序重复，放$C++$）：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
    long long x,y,z,k;
}a[1000010];
int a1,b1,c1,d1,n,i,mi,ma;
template <typename T> void read(T &x) {
x = 0; char c = getchar();
for (; !isdigit(c); c = getchar());
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
}
int cmp(node a,node b)
{
    if (a.x<b.x) return 1;if (a.x>b.x) return 0;
    if (a.y<b.y) return 1;if (a.y>b.y) return 0;
    if (a.z<b.z) return 1;if (a.z>b.z) return 0;
    if (a.k<b.k) return 1;if (a.k>b.k) return 0;
}
int main()
{
scanf("%d",&n);
for (int i=1;i<=n;i++)
  {
  	scanf("%d %d %d %d",&a1,&b1,&c1,&d1);
  	a[i].x=b1-a1;a[i].y=c1-b1;a[i].z=d1-c1;a[i].k=i;
  }
sort(a+1,a+1+n,cmp);
mi=INT_MAX;ma=-INT_MAX;
for (int i=2;i<=n;i++)
  if (a[i].x==a[i-1].x&&a[i].y==a[i-1].y&&a[i].z==a[i-1].z)
    {
    	if (a[i].k-a[i-1].k<mi) mi=a[i].k-a[i-1].k;
    	if (a[i].k+a[i-1].k>ma) ma=a[i].k+a[i-1].k;
    }
printf("%lld %lld\n",mi,ma);
return 0;
}
```



---

## 作者：sel_fish (赞：4)

上面的题解好像都没有说出相减的原因，于是就有了这一篇题解来解释一下，为什么可以开三个数组记录相减的值

这道题咋一看，好像特别难的样子，其实就是用来一个很简单的数学知识（~~前方高能，非数学精通者请撤退~~）

其实就是我们小学的时候学的**移项**

### X _i_ -X _j_ =Y _i_ -Y _j_ =Z _i_ -Z _j_ =Q _i_ -Q _j_

以**X _i_ -X _j_ =Y _i_ -Y _j_** 为例，我们**把Y _i_ 移到右边，把X _j_ 移到左边**
于是这个式子就变成了**X _i_ -Y _i_ =X _j_ -Y _j_**

### 所以我们只需要记录相减的值，如果相同，就代表他们两个是优美坐标

**因为需要记录j-i的最小值和i+j的最大值，所以我们还要再开一个数组来记录每一个优美坐标的序号**

其他应该也就没什么了，看代码吧

**AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
struct dd {
	int x,y,z,id;
}e[500005];
int n,minx=0x3f3f3f3f,maxx=0;
bool cmp(dd a,dd b) {
	if(a.x<b.x) return true;
	if(a.x>b.x) return false;
	if(a.y<b.y) return true;
	if(a.y>b.y) return false;
	if(a.z<b.z) return true;
	if(a.z>b.z) return false;
	if(a.id<b.id) return true;//这两句十分重要，不加上这两句只有90分
	if(a.id>b.id) return false;//因为前三个可能都相等，只有序号不同
} 
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		e[i].x=b-a;
		e[i].y=c-b;
		e[i].z=d-c;
		e[i].id=i;
	}
	sort(e+1,e+n+1,cmp);
	for(int i=2;i<=n;i++) {
		if(e[i].x==e[i-1].x&&e[i].y==e[i-1].y&&e[i].z==e[i-1].z) {
			if(e[i].id-e[i-1].id<minx) minx=e[i].id-e[i-1].id;
			if(e[i].id+e[i-1].id>maxx) maxx=e[i].id+e[i-1].id;
		}
	}
	cout<<minx<<" "<<maxx;
	return 0;
}
```

如果各位读者感觉写的还不错，~~点个赞怎么样~~

**END**

---

## 作者：_std_O2 (赞：1)

# 分析
我们需要找到一个 $j$ 使得 $X _ i - X _ j = Y _ i - Y _ j = Z _ i - Z _ j = Q _ i - Q _ j$。

此时容易发现 $X _ i - Y _ i = X _ j - Y _ j , Z _ i - Y _ i = Z _ j - Y_j , Q_i - Z_i=Q_j-Z_j$。

也就是它们的增减性相同，且变化量相同，我们不妨将这种相同的增减性与变化量映射为一个值，好将它们放为一类。在这些映射值相同的坐标中，就是优美坐标了，我们此时只需枚举找到 $j−i$ 的最小值和 $i+j$ 的最大值就行了。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,MOD=1e9+7;
int minn=1e9+7,maxn;
long long w[N],n;
struct node{
	int x,y,z,q,rank,num;
}a[N];
bool cmp(node x,node y){
	if(x.rank==y.rank) return x.num<y.num;
	return x.rank<y.rank; 
}
inline int read(){
	 int w = 0  , f = 1;
	char ch = getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f = -1;
		ch = getchar();
	}
	while('0'<=ch&&ch<='9'){
		w = w*10+(ch-'0');
		ch = getchar();
	}
	return w*f;
}
map<string,int> mp;
int cnt=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		a[i].x=read(),a[i].y=read(),a[i].z=read(),a[i].q=read();
		string s=to_string(a[i].y-a[i].x)+" "+to_string(a[i].z-a[i].y)+" "+to_string(a[i].q-a[i].z);
		if(!mp[s]) mp[s]=++cnt;
		a[i].rank=mp[s],a[i].num=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		if(a[i].rank==a[i+1].rank) 
			minn=min(minn,a[i+1].num-a[i].num),
			maxn=max(maxn,a[i].num+a[i+1].num);
	cout<<minn<<" "<<maxn;
}
```

---

## 作者：62500a (赞：1)

# 思路
观察等式 $$X_i-X_j=Y_i-Y_j=Z_i-Z_j=Q_i-Q_j$$，简单地移项后会发现：
$$\begin{cases}
Y_i-X_i=Y_j-X_j\\
Z_i-Y_i=Z_j-Y_j\\
Q_i-Z_i=Q_j-Z_j
\end{cases}$$
于是令 $$a_i=Y_i-X_i$$，$$b_i=Z_i-Y_i$$，$$c_i=Q_i-Z_i$$，那么题中等式等价于：
$$\begin{cases}
a_i=a_j\\
b_i=b_j\\
c_i=c_j
\end{cases}$$
这样，我们就可以以 $$a_i$$，$$b_i$$，$$c_i$$ 为关键字对原数组排序。由于排序会使数组顺序全乱套，在此我们还需要变量 $$pos_i$$，用来存储输入时的位置。排序后若第 $$i-1$$ 个点与第 $$i$$ 个点若满足：
$$\begin{cases}
a_i=a_{i-1}\\
b_i=b_{i-1}\\
c_i=c_{i-1}
\end{cases}$$
则记 $$m_i=pos_i-pos_{i-1}$$，$$n_i=pos_i+pos_{i-1}$$，最后输出 $$m_{min}$$ 与 $$n_{max}$$ 即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	long long a,b,c;int pos;
	void in(int i){
		long long x,y,z,w;
		scanf("%lld%lld%lld%lld",&x,&y,&z,&w);
		a=y-x;b=z-y;c=w-z;pos=i;
	}
	bool operator< (node x)const{
		if((this->a)!=x.a)return (this->a)<x.a;
		if((this->b)!=x.b)return (this->b)<x.b;
		if((this->c)!=x.c)return (this->c)<x.c;
		return (this->pos)<x.pos;
	}
	bool operator== (node x)const{
		return (this->a)==x.a&&(this->b)==x.b&&(this->c)==x.c;
	}
}a[500005];int n,amin=0x7f7f7f7f,amax;
int main(){
	scanf("%d",&n);for(int i=1;i<=n;i++)a[i].in(i);
	sort(a+1,a+n+1);
	for(int i=2;i<=n;i++){
		if(a[i-1]==a[i]){amin=min(amin,a[i].pos-a[i-1].pos);amax=max(amax,a[i].pos+a[i-1].pos);}
	}printf("%d %d",amin,amax);
	return 0;
}

```

---

## 作者：wind_whisper (赞：1)

## $\text{Solution}$
介绍一种代码难度和思维难度都远远低于其他题解的偷懒实现方法.    
不难看出本题完美坐标的充要条件是邻项差相等.  
接下来的统计部分,似乎题解区大部分都是使用的 sort 加一些记录处理.  
这种做法当然也很好并且很快，但是需要处理的细节较多.  
这样要求相等的题目我们完全可以使用  **map** 来实现.  
每个 map 记录一下最大编号，中间不断更新答案，做完了.  
看到代码相信你就会明白这道题用 map 的优越性.
## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
inline ll read() {
	ll x(0),f(1);char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}

int n,m,k;
#define mkp(a,b,c) make_pair(make_pair(a,b),c)
#define pr pair<pair<int,int>,int>
map<pr,int>mp;
int main(){
	n=read();
	int mn(2e9),mx(0);
	for(int i=1;i<=n;i++){
		int x=read(),y=read(),z=read(),w=read();
		pr o=mkp(y-x,z-y,w-z);
		if(mp.count(o)){
			mn=min(mn,i-mp[o]);
			mx=max(mx,i+mp[o]);
			mp[o]=max(mp[o],i);
		}
		else mp[o]=i;
	}
	printf("%d %d\n",mn,mx);
	return 0;
}
/*
*/
```


---

## 作者：ShineEternal (赞：1)

# 代码：
这道题也并不难，用排序+简单动规即可。因为@Kevin_Wa 大佬放的是c++，所以我来一发Pascal。

```cpp
var min,max,i,a1,b1,c1,d1,n:longint;
a,b,c,d:array[0..500000] of int64;
procedure sort(l,r: longint);
var i,j,x,y,y1,y2,y3:longint;
begin
i:=l;j:=r;x:=a[(l+r) div 2];y1:=b[(l+r) div 2];
y2:=c[(l+r) div 2];y3:=d[(l+r) div 2];
repeat
 while (a[i]<x)or((a[i]=x)and(b[i]<y1))or((a[i]=x)and(b[i]=y1)and(c[i]<y2))
 or((a[i]=x)and(b[i]=y1)and(c[i]=y2)and(d[i]<y3))  do inc(i);
 while (x<a[j])or((x=a[j])and(y1<b[j]))or((x=a[j])and(y1=b[j])and(y2<c[j]))
 or((x=a[j])and(y1=b[j])and(y2=c[j])and(y3<d[j]))  do dec(j);
 if not(i>j) then
   begin
   y:=a[i];a[i]:=a[j];a[j]:=y;
   y:=b[i];b[i]:=b[j];b[j]:=y;
   y:=c[i];c[i]:=c[j];c[j]:=y;
   y:=d[i];d[i]:=d[j];d[j]:=y;
   inc(i);j:=j-1;
   end;
until i>j;
if l<j then sort(l,j);
if i<r then sort(i,r);
end;
begin
readln(n);
for i:=1 to n do
  begin
  read(a1,b1,c1,d1);
  a[i]:=b1-a1;b[i]:=c1-a1;c[i]:=d1-a1;
  d[i]:=i;
  end;
sort(1,n);
min:=maxlongint;
max:=-maxlongint;
for i:=2 to n do
  if (a[i]=a[i-1])and(b[i]=b[i-1])and(c[i]=c[i-1]) then
    begin
    if (d[i]-d[i-1]<min) then min:=d[i]-d[i-1];
    if (d[i]+d[i-1]>max) then max:=d[i]+d[i-1];
    end;
writeln(min,' ',max);
close(input);close(output);
end.

```


---

## 作者：hhhyyyfff (赞：1)

## 算法

- 枚举+hash

## 思路

- 利用hash缩小枚举范围。

- 若$X_i-X_j=Y_i-Y_j=Z_i-Z_j=Q_i-Q_j$，则$X_i-Y_i=X_j-Y_j,X_i-Z_i=X_j-Z_j,X_i-Q_i=X_j-Q_j$。

 ### 预处理
 
 - 按要求输入数据
 
 - 把数据插入hash表
 
 ### 枚举
 
 - 枚举**hash值相同的**的坐标
 
 ### 输出
 
 - 按要求统计并输出答案
 
## 代码

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
//hash表
vector<int> hash[500010];
//maxx记录i+j的最大值，minn记录j-i的最小值，其余同题目描述
int n,X[500010],Y[500010],Z[500010],Q[500010],maxx,minn;
//hash函数
int f(int pos){
  return (((X[pos]-Y[pos])%500007+500007)*153257ll%500007+
         ((X[pos]-Z[pos])%500007+500007)*153257ll%500007+
     ((X[pos]-Q[pos])%500007+500007)*153257ll%500007)%500007;
}
int main(){
  scanf("%d",&n);
  //预处理
  for(int i=1;i<=n;++i){
    scanf("%d%d%d%d",&X[i],&Y[i],&Z[i],&Q[i]);
    hash[f(i)].push_back(i);
  }
  //枚举
  minn=500010;
  for(int i=0;i<500007;++i){
    int l=hash[i].size();
    //同一hash值比较
    for(int j=0;j<l;++j)
      for(int k=j+1;k<l;++k){
    int tj=hash[i][j],tk=hash[i][k];
    if(tj>tk)
      tj^=tk^=tj^=tk;
    //统计
    if(X[tj]-X[tk]==Y[tj]-Y[tk] && Y[tj]-Y[tk]==Z[tj]-Z[tk] && Z[tj]-Z[tk]==Q[tj]-Q[tk]){
      maxx=max(maxx,tk+tj);
      minn=min(minn,tk-tj);
          }
      }
  }
  //输出
  printf("%d %d\n",minn,maxx);
  return 0;
}
```

## 进一步优化

- 优化hash函数，增大hash表

---

## 作者：Jerry_heng (赞：0)

（一）


由于要求两个坐标中对应的值的差相等，转化为单独一个坐标中四个数的差分相等。

将输入的四个数差分得到三个值，那么这三个值相同的两个坐标符合条件。

用 map 存储记录这三个值的结构体，然后用 vector 存储下标。

根据计算的顺序，每个 vector 内的坐标的下标是递增的。

注意特判 vector 里坐标个数是否 $>1$。

（二）

AC 代码。

```cpp
#include<bits/stdc++.h>
#define db double
#define pb push_back
#define fi first
#define se second
#define mkp make_pair
#define pii pair<int,int>
using namespace std;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f; 
}
struct node{
	int x,y,z;
	bool operator<(const node &p)const{
		return x<p.x||x==p.x&&y<p.y||x==p.x&&y==p.y&&z<p.z;
	}
};
map<node,vector<int> >mp;
int n,ans1=INT_MAX,ans2;
signed main(){
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=read();
    for(int i=1;i<=n;i++){
    	int a=read(),b=read(),c=read(),d=read();
    	mp[(node){b-a,c-b,d-c}].pb(i);
    }
    for(auto t:mp){
    	vector<int>v=t.se;
    	if(v.size()<2)continue;
    	for(int i=0;i<v.size()-1;i++)
    		ans1=min(ans1,v[i+1]-v[i]);
    	ans2=max(ans2,v[v.size()-1]+v[v.size()-2]);
    }
    printf("%d %d\n",ans1,ans2);
    return 0;
}
```

---


# 矩形

## 题目背景

小奔月考考的可棒了！作为奖励，老师给了他一只激光笔。

## 题目描述

但老师永远不是白给小奔奖品的。他告诉小奔：反射角等于入射角。并让他解决下面的问题：

如果有一个矩形，长和宽之比为N：M，现在有一束激光从左上角射出，且与长N的夹角为 ζ °（0≤ζ≤90），且满足cot ζ ° = A ： B，求最少需要多少次反射才能重新反射入四个角当中的任意一个角呢？

![](https://cdn.luogu.com.cn/upload/pic/37985.png)

## 说明/提示

对于10%的数据,A=B=1；

对于另10%的数据,N=M；

对于50%的数据，$0≤A,B,M,N≤10^5$；

对于100%的数据，$0≤A,B,M,N≤10^{10}$；

## 样例 #1

### 输入

```
3 4
1 1```

### 输出

```
5```

# 题解

## 作者：Rigel (赞：18)

## 思路

将原图逆时针旋转 $90 \degree$ 并建系。

![](https://cdn.luogu.com.cn/upload/image_hosting/5353n18g.png)

考虑到直接模拟光路较为复杂，我们可以建立如图所示的镜像单元格。

![](https://cdn.luogu.com.cn/upload/image_hosting/u4eb3g2z.png)

容易证明，图中同色线段长度相等。

于是问题就转换为：求直线第一次到达形如 $(k_1m,k_2n)$ 的点（其中 $k_1,k_2 \in \mathbb N_+$）途中穿过矩形边的次数。

由于 $\cot \zeta = \displaystyle{\frac{a}{b}}$，因此直线的解析式为 $y = \displaystyle{\frac{a}{b}} \cdot x$。

设直线第一次到达的点为 $(k_1m,k_2n)$，则：

$
\begin{aligned}
\displaystyle{\frac{a}{b}} \cdot k_1m&=k_2n\\
amk_1&=bnk_2\\
k_1&=\displaystyle{\frac{bnk_2}{am}}.
\end{aligned}
$

由于 $k_1 \in \mathbb N_+$，故 $am \mid bnk_2$。

容易证明，$k_2$ 的最小值为 $\displaystyle{\frac{am}{\gcd(am,bn)}}$，此时 $k_1=\displaystyle{\frac{bn}{\gcd(am,bn)}}$。

我们回到 $k_1$ 与 $k_2$ 的定义，不难得出最终答案为 $k_1+k_2-2$。

---

注意以下两点：
- 在开始时要先化简。令 $g_1 = \gcd(n,m)$，$g_2 = \gcd (a,b)$，并使 $n \gets \displaystyle{\frac{n}{g_1}}$，$m \gets \displaystyle{\frac{m}{g_1}}$，$a \gets \displaystyle{\frac{a}{g_2}}$，$b \gets \displaystyle{\frac{b}{g_2}}$。

- 特判 $a=0$ 或 $b=0$ 的情况。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int n,m,a,b;

inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')ret=ret*10+(ch&15),ch=getchar();
	return ret*f;
}

int gcd(int x,int y){
	return y?gcd(y,x%y):x;
}

int solve(int n,int m,int a,int b){
	if(!a||!b)return 0;
	int g1=gcd(n,m),g2=gcd(a,b);
	n/=g1,m/=g1,a/=g2,b/=g2;
	int g=gcd(a*m,b*n);
	int k1=b*n/g,k2=a*m/g;
	return k1+k2-2;
}

signed main(){
	n=read(),m=read(),a=read(),b=read();
	printf("%lld\n",solve(n,m,a,b));
	return 0;
}
```

---

## 作者：天泽龟 (赞：18)

## ~~OI退役想去搞物理竞赛的我还是太弱了~~

初中物理的光学竞赛问题，基于反射角=入射角，我们可以拿张草稿纸手膜小样例最终推出答案。

- ## 对于$N=M$的情况：

### 不妨设N=M=1，先手膜一组$2*3$的数据（绿线是经折射的线，蓝点为反射点）：

![](https://cdn.luogu.com.cn/upload/pic/45868.png)

这里用了**反射角=入射角**的原理，关于射线的折射点反复对称就得到这张图。

可以注意到第三行我标了两个蓝点，这是因为~~我标错了~~这两个点关于法线对称，因此可以等价看待。

然后我们就可以注意到一个有趣的事实，我们设$AB$是从入射点不考虑折射，直接引出的且起始点为网格点的最短线段，可以发现3个蓝点均在$AB$上！

#### 于是我们可以~~大胆~~得出结论：对于任意AB为对角线形成的最小矩形，与其他网格点所形成的交点即为反射的次数。

#### 若矩形大小为$a,b$，每行会有一个交点，每列也会有一个交点，减去B所在的点的贡献，答案即为$a+b-2$，10分到手

- ## 对于$A=B$

### 等价于是$tan ζ =1$的情况，不妨设$A=B=1$，我们先手膜一个$3*5$的表格（很丑）：![](https://cdn.luogu.com.cn/upload/pic/45859.png)

### ~~经观察~~我们发现：经上下边界反射的点数=列数；经左右边界反射的点数=行数
### ~~咋证明呢？我好像不太会啊。~~

~~（一本正经的胡说八道）~~其实我们可以用映射的思想，因为我们求的均是长宽比值，所以具体大小是不影响答案的，我们可以感性的将这个大矩形压缩成一个单位1的正方形，如图：![](https://cdn.luogu.com.cn/upload/pic/45870.png)

~~你看这个小正方形和那个大矩形是不是很像！？~~

#### 此时原本$tanζ=1$的线应是被我们压缩成了$tan  ζ=A/B=3/5$，相当于我们就可以直接引用第一种情况的结论得出答案辣！第二个10分的结论就是$n+m-2$


- # 正解

### ~~想到了映射还有什么问题没解决了吗？？~~
我们只要把任意数据都替换成$N=M$的情况，直接套结论就可以啦！

对于水平方向的$N,a$同时除以N，竖直方向的$M,b$同时除以M，可以证明与原来的数据是等价的。

此时修改过后的$N=M=1$，那么对于a1与b1先使他们互质，再直接套第一种情况的结论就行啦！

最后还有记得特判a=0,b=0的情况。。死活卡在95就是这个原因。

最后，上丑陋的代码：

```
#include <iostream>
#define ll long long
using namespace std;
ll n,m,a,b;

ll gcd(ll a,ll b)
{
	return (!b)?a:gcd(b,a%b); 
}

int main()
{
	cin>>n>>m;
	cin>>a>>b;
	a*=m; b*=n; //与a/n,b/m等价，而且这样可以保证a,b为整数
	ll d=gcd(a,b); 
	if (a==0||b==0) {
		cout<<0<<endl; return 0;
	}
	a/=d; b/=d;
	cout<<b+a-2<<endl;
}
```

大冬天待在空调房，可能脑子不是很好使，如有错误指出_(:з」∠)

---

## 作者：hgoicjl (赞：11)

### 这道题对于我这种初中水平的OIer极度不友好

[cot函数](https://baike.baidu.com/item/cot/37020?fr=aladdin)

---

#### 题意特别明白
![P5088](https://cdn.luogu.com.cn/upload/pic/62983.png)

---
#### 算法

数学思维?

结论题

---

#### 题解

我们可以把这个题解给简化或者是等价改变一下

![P5088_2](https://cdn.luogu.com.cn/upload/pic/62984.png)

我们不妨设这个长方形的长(X轴)就为$N$，宽(Y轴)就为$M$

根据[cot](https://baike.baidu.com/item/cot/37020?fr=aladdin)的定义

题目中给定的$cot$值$A:B$(且为最简分数,原因详见下文)

我们不妨设点‘行走’$1$个单位在X轴上移动了$A$个单位并且在Y轴上移动了$B$个单位(前提$A$,$B$互质 否则对于数据(2 2 6 6)会挂掉)

假设该点行走了若干步到达了一个角，则他在X轴上通过的距离一定是$k_1N,k_1\in N^+$

同理，再Y轴上通过的距离为$k_2M,k_2\in N^+$

设这个点走过了$k_3$步到达了角上

同时$k_1,k_2$满足$k_1N=k_3A,k_2M=k_3B,k_3\in N^+$

因为这个点一定走过了整数步

对于一次反射(除非它射入角上)，我们可以认为在X轴上距离为$N$(第一次在右边反射)，$2N$(第一次在左边反射)，$3N$(第二次再右边反射)...时发生了反射

在Y轴上亦是同理

根据$k_1N=k_3A,k_2M=k_3B,k_3\in N^+$

我们可以推出$k_3$满足 $\frac{M}{gcd(M,B)}|k_3$且$\frac{N}{gcd(N,A)}|k_3$

即$ min_{k_3}=lcm(\frac{M}{gcd(M,B)},\frac{N}{gcd(N,A)})$

显而易见，一共反射了$k_1+k_2$次，再减去最后射入角上回多加$2$次

即$k_1+k_2-2$次

---
0711更新

这么看思路确实是正确的，我~~打了~~复制一个[高精度](https://blog.csdn.net/wlxsq/article/details/49717209)(侵删)

然后按照上述思路(详见Code B)

90分(long long 60分)

~~我想骂人了~~

---

7.11 2更

我又回来了

需要特判a==0或者b==0

直接输出0

**终于AC了！**

---
### Code A(使用long long)
```
#include<bits/stdc++.h>
using namespace std;
long long gcd(long long a,long long b)
{
	return (b==0)?a:gcd(b,a%b);
}
long long lcm(long long a,long long b)
{
	return a/gcd(a,b)*b;
}
int main()
{
	long long n,m,a,b,a1,b1;
	cin>>n>>m>>a1>>b1;
	a=a1/gcd(a1,b1); b=b1/gcd(a1,b1);
	long long k3=lcm(m/gcd(b,m),n/gcd(a,n));
	cout<<k3*a/n+k3*b/m-2<<endl;
	return 0;
   //有没有人来拯救下这个代码啊！
   //以及洛谷用不了__int128吗
} 
```
### Code B(使用高精) 4581B
```
#include<bits/stdc++.h>
using namespace std;
const int L=110; 
string add(string a,string b)  
{  
    string ans;  
    int na[L]={0},nb[L]={0};  
    int la=a.size(),lb=b.size();  
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';  
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';  
    int lmax=la>lb?la:lb;  
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;  
    if(na[lmax]) lmax++;  
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';  
    return ans;  
}  
string mul(string a,string b)  
{  
    string s;  
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积  
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0  
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数  
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';  
    for(int i=1;i<=La;i++)  
        for(int j=1;j<=Lb;j++)  
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）  
    for(int i=1;i<=La+Lb;i++)  
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位  
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0  
    for(int i=La+Lb-1;i>=1;i--)  
        s+=nc[i]+'0';//将整形数组转成字符串  
    return s;  
}  
int sub(int *a,int *b,int La,int Lb)  
{  
    if(La<Lb) return -1;//如果a小于b，则返回-1  
    if(La==Lb)  
    {  
        for(int i=La-1;i>=0;i--)  
            if(a[i]>b[i]) break;  
            else if(a[i]<b[i]) return -1;//如果a小于b，则返回-1  
  
    }  
    for(int i=0;i<La;i++)//高精度减法  
    {  
        a[i]-=b[i];  
        if(a[i]<0) a[i]+=10,a[i+1]--;  
    }  
    for(int i=La-1;i>=0;i--)  
        if(a[i]) return i+1;//返回差的位数  
    return 0;//返回差的位数  
  
} 
string sub1(string a,string b)//只限大的非负整数减小的非负整数  
{  
    string ans;  
    int na[L]={0},nb[L]={0};  
    int la=a.size(),lb=b.size();  
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';  
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';  
    int lmax=la>lb?la:lb;  
    for(int i=0;i<lmax;i++)  
    {  
        na[i]-=nb[i];  
        if(na[i]<0) na[i]+=10,na[i+1]--;  
    }  
    while(!na[--lmax]&&lmax>0)  ;lmax++;  
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';  
    return ans;  
} 
string div(string n1,string n2,int nn)//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数  
{  
    string s,v;//s存商,v存余数  
     int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;//a，b是整形数组表示被除数，除数，tp保存被除数的长度  
     fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0  
     for(i=La-1;i>=0;i--) a[La-1-i]=n1[i]-'0';  
     for(i=Lb-1;i>=0;i--) b[Lb-1-i]=n2[i]-'0';  
     if(La<Lb || (La==Lb && n1<n2)) {  
            //cout<<0<<endl;  
     return n1;}//如果a<b,则商为0，余数为被除数  
     int t=La-Lb;//除被数和除数的位数之差  
     for(int i=La-1;i>=0;i--)//将除数扩大10^t倍  
        if(i>=t) b[i]=b[i-t];  
        else b[i]=0;  
     Lb=La;  
     for(int j=0;j<=t;j++)  
     {  
         int temp;  
         while((temp=sub(a,b+j,La,Lb-j))>=0)//如果被除数比除数大继续减  
         {  
             La=temp;  
             r[t-j]++;  
         }  
     }  
     for(i=0;i<L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位  
     while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的  
     while(i>=0) s+=r[i--]+'0';  
     //cout<<s<<endl;  
     i=tp;  
     while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的</span>  
     while(i>=0) v+=a[i--]+'0';  
     if(v.empty()) v="0";  
     //cout<<v<<endl;  
     if(nn==1) return s;  
     if(nn==2) return v;  
}  
bool judge(string s)//判断s是否为全0串  
{  
    for(int i=0;i<s.size();i++)  
        if(s[i]!='0') return false;  
    return true;  
}  
string gcd(string a,string b)//求最大公约数  
{  
    string t;  
    while(!judge(b))//如果余数不为0，继续除  
    {  
        t=a;//保存被除数的值  
        a=b;//用除数替换被除数  
        b=div(t,b,2);//用余数替换除数  
    }  
    return a;  
} 
int main()
{
    string n,m,a,b,a1,b1,n1,m1;
    cin>>n1>>m1>>a1>>b1;
    if(a1=="0"||b1=="0")
    	cout<<0<<endl;
    else
    {
	    a=div(a1,gcd(a1,b1),1); b=div(b1,gcd(a1,b1),1);
	    n=div(n1,gcd(n1,m1),1); m=div(m1,gcd(n1,m1),1);
	    string k3,ans,k="2";
	    k3=mul(div(div(m,gcd(b,m),1),gcd(div(m,gcd(b,m),1),div(n,gcd(a,n),1)),1),div(n,gcd(a,n),1));
	    string ans1;
	    ans1=sub1(add(div(mul(k3,a),n,1),div(mul(k3,b),m,1)),k);
	    cout<<ans1<<endl;
	}
	return 0;
}
```

---

## 作者：hhh_778899 (赞：4)

## 写在前面
- 这道题的难点在于分析题目，理解本质之后还是挺简单的 (仅代表个人观点) 。

- 本题涉及到 $\cot$ (余切) ，不知道的可以看[这里](https://baike.baidu.com/item/%E4%BD%99%E5%88%87)。

## 进入正题

计算激光反射的次数，在矩形内部考虑显然是不现实的，所以我们化折线为直线。

每次反射，我们将反射光线沿反射面对称，使其变为一条直线。

不妨设有无穷多个 $N \times M$ 的矩形，让对称后的反射光线直接穿过，如下图所示：

- 相同颜色代表相同的光线，每个白色点代表一次反射。

![](https://cdn.luogu.com.cn/upload/image_hosting/g51ad2kv.png)

我们假设横向有 $p$ 条长度为 $N$ 的边，纵向有 $q$ 条长度为 $M$ 的边。根据 $\cot$ 的定义我们可以知道：

$$ \cot \, \zeta = \frac{ p \times N }{ q \times M} = \frac{A}{B}$$

由于 $p$ 和 $q$ 必然是互质的 (若不互质，就不是第一次满足题意) ，可知光线横向跨度为 $p$ ，纵向跨度为 $q$ ，再减去起始点，

便可以得出反射次数：$p+q-2$ 。

显然，当 $p=A \times M$ ， $q=B \times N$ 时，上述等式成立。

为了让 $p$ 和 $q$ 互质，我们还需要同时除以 $A \times M$ 和 $B \times N$ 的最大公约数，即可得到答案：
$$\frac{A \times M \, + B \times N}{\gcd (A \times M\,,B \times N)}$$

## 坑点
- 本题卡精度，数据最大可以达到 $10^{20}$ ，所以要边写边化简。

- 要注意特判 $A=0$ 或 $B=0$ 的情况。

## 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long n,m,a,b;

int main()
{
    cin>>n>>m>>a>>b;
    if(a==0||b==0)//特判
    {
        cout<<"0";
        return 0;
    }
    long long p=__gcd(a,b);
    a/=p,b/=p;//化简
    long long q=__gcd(n,m);
    n/=q,m/=q;//化简
    a*=m,b*=n;//化简
    long long r=__gcd(a,b);
    cout<<(a/r)+(b/r)-2;
    return 0;
}
```


---

## 作者：WanderingTim (赞：3)

## 解题思路

代码很短，也有人谈论这道题不应该是蓝题，但我认为蓝色的是思想！

废话不多说，我们来
### 分析一下

![](https://cdn.luogu.com.cn/upload/image_hosting/cizkw7r1.png)

这是原题折射几次后的结果。~~手动画图，丑请见谅~~

是不是有一种强烈的不适感？没关系，我们只需——

### 镜像扩展
和经典问题“将军饮马”处理思路相同，我们多创建几个图中的“单元矩形”再对光线进行对称处理。

![](https://cdn.luogu.com.cn/upload/image_hosting/0vokbavt.png)

~~嗯，舒服啦！~~
ok，那么我们的题目所求问题转化为：**让光线一直延长，何时能够第一次到达任意一个矩形的顶点？**

设一个小矩形长为 $p$，宽为 $q$，第一次到达其中一个矩形的顶点时，总矩形长为 $A$，宽为 $B$。再设总矩形横向有 $k1$ 个小矩形，纵向有 $k2$ 个小矩形，即 $k1 \times p = A$，$k2 \times q = B$。

那么接下来我们很容易得出以下关键结论：
-  **横向镜面反射的次数=列数**
-  **纵向镜面反射的点数=行数**
-  **由1. 2. 得最少需要的反射次数**

那么，最终答案为 $k1 + k2 - 2$（需要排除最后射入角多加的两次）。

但是，**最少**需要多少次反射呢？也就是说，为了不让计算机把整个过程进行好多次（射到顶点后继续进行反射），我们需要如何做呢？

因为 $\frac{A}{B} = \frac{k1 \times p}{k2 \times q} = \frac{a}{b}$，所以我们需将长宽比和余切比都约到最简，然后计算出真正的 $A$ 和 $B$。

```cpp
int t = __gcd(n, m);
n /= t, m /= t;  // 约分后的长宽比
t = __gcd(a, b);
a /= t, b /= t;  // 约分后的余切比
int A = a * m; // 横向总步数
int B = b * n; // 纵向总步数
```
然后就可以愉快地计算最小重复周期，得到 $k1$ 和 $k2$ 啦！  

```cpp
t = __gcd(A, B);//最小重复周期
A /= t;//k1
B /= t;//k2
```
咦？奇怪，怎么 90pts？

原来还要特判‌垂直或水平光线 QWQ……

## 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n, m, a, b;

signed main() {
	cin >> n >> m;
	cin >> a >> b;
	if (a == 0 || b == 0) {//特判
		cout << 0;
		return 0;
	}
	int t = __gcd(n, m);
	n /= t, m /= t;  // 约分后的长宽比
	t = __gcd(a, b);
	a /= t, b /= t;// 约分后的余切比
	int A = a * m;// 横向总步数
	int B = b * n;// 纵向总步数
	t = __gcd(A, B);//最小重复周期
	A /= t;//k1
	B /= t;//k2
	cout << (A + B - 2) << endl;
	return 0;
}
```

拜拜！
---

---

## 作者：雄鹰展翅 (赞：2)

提供一组hack数据：~~可以hack掉不少AC代码~~
```
输入：10000000000 10000000000 10000000000 1
输出：9999999999
```

以左上角为原点建立平面直角坐标系，以n为x轴，m为y轴。

[![JkM9LF.png](https://s1.ax1x.com/2020/04/16/JkM9LF.png)](https://imgchr.com/i/JkM9LF)

假设光线在x轴移动的速度为a m/s,则其在y轴移动的速度为b m/s。

画出光线的横纵坐标与时间的函数图像：

[![JkMpsU.png](https://s1.ax1x.com/2020/04/16/JkMpsU.png)](https://imgchr.com/i/JkMpsU)

从图像中可以看出，x方向上每隔$t1=n/a$秒碰撞一次墙壁，y方向上每隔$t2=m/b$秒碰撞一次墙壁，

当光线在x和y方向上同时碰撞墙壁时，光线就落入了墙角。

此时的总时间为$T=lcm(t1,t2)$

故碰撞总次数为$T/t1+T/t2-2$(减2是减去最终在角落处的碰撞)。

这里有一个细节，为了避免t1和t2不是整数而导致lcm出错的现象发生，我们可以将$n/a$和$m/b$同乘ab，

即：$lcm(abt1,abt2)/abt1=ablcm(t1,t2)/abt1=lcm(t1,t2)/t1$,


最终结果不变。

除了这些，还要特判a=0或b=0的情况。


代码：
```cpp
#include <iostream>
#define ll long long
using namespace std;
ll n,m,a,b;

ll gcd(ll a,ll b){
	if(b==0) return a;
    return gcd(b,a%b); 
}

int main(){
    ll k1,k2,k,t;
	cin>>n>>m>>a>>b;
	if(a==0||b==0) {cout<<0<<endl; return 0;}
	t=gcd(a,b),a/=t,b/=t;//化简，可以避免爆精度
	t=gcd(n,m),n/=t,m/=t;
	
	a*=m,b*=n; //根据gcd(a,b)*lcm(a,b)=a*b化简
    t=gcd(a,b);

	cout<<a/t+b/t-2<<endl;
    
    return 0;
}

```
后记：

在2017初赛中曾经出过这样一道题：
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n, m;
    cin >> n >> m;
    int x = 1;
    int y = 1;
    int dx = 1;
    int dy = 1;
    int cnt = 0;
    while (cnt != 2)
    {
        cnt = 0;
        x = x + dx;
        y = y + dy;
        if (x == 1 || x == n)
        {
            ++cnt;
            dx = -dx;
        }
        if (y == 1 || y == m)
        {
            ++cnt;
            dy = -dy;
        }
    }
    cout << x << " " << y << endl;
    return 0;
}
输入 1：4 3
输出 1：_________（3 分）

输入 2：2017 1014
输出 2：_________（5 分）
```
在这道题中，给了边长和cot，求落在哪个角，如果知道方法的话就不用模拟了。（8分到手~）


---

## 作者：mydcwfy (赞：1)

## 1. 题意

[原题面](https://www.luogu.com.cn/problem/P5088)

抽象一下题意：

求 $k1,k2$，使得：
$$
k1\times N:k2\times M=A:B
$$
（先使 $\gcd(A,B)=1$

然后，题目要求的就是 $k1+k2-2$ 的最小值。

对应到原题意是什么呢？

我们假设有无穷多个这样的 $N\times M$ 的矩形，然后我们不反射，直接穿过，直到碰到交界的点为止。

![](https://cdn.luogu.com.cn/upload/image_hosting/tng8b96b.png)

蓝线是原来的反射路径，但是我们可以通过一系列的翻折，使得路径变为绿线。

变为绿线，其实已经简洁了许多。

我们假设横向的有 $k1$ 个 $N$，纵向的有 $k2$ 个 $M$，那么最后 $\zeta$ 的对边是 $k2\times M$，邻边是 $k1\times N$。

于是，我们可以得到：
$$
\cot\zeta=\dfrac{k1\times N}{k2\times M}=\dfrac{A}{B}
$$
也就是上面的式子了。

至于反射了多少次，其实就是穿过边界了多少次。

~~大眼观察法~~易得 $ans=k1+k2-2$。

问题转化为怎样求 $k1,k2$。

首先，可以得到一个解：$k1=A\times M,k2=B\times N$。

然后，我们可以同时除以一个数 $x$。

那么需要满足：$x|A\times M,x|B\times N$。（不然的话，$k1,k2$ 无法整除 $x$，就不是整数了）。

综上，我们其实就可以总结出这道题的答案了：
$$
ans=\dfrac{A\times M+B\times N}{\gcd(A\times M,B\times N)}
$$

## 2. 代码

数据水了一点，没有卡掉 `long long`。

唯一注意的是 $A=0$ 或 $B=0$ 的情况。

```cpp
int main()
{
	read(n, m, a, b);
	if (a == 0 || b == 0) return puts("0"), 0;
	ll g = Gcd(a, b);
	a /= g, b /= g;
	ll x = Gcd(a * m, b * n);
	write(a * m / x + b * n / x - 2);
	return 0;
}
```

---

## 作者：ShineEternal (赞：1)



# 分析：
交叉相乘，然后除以最大公因数（为了减少爆常数的可能性std做了两次，数据很大），得到的两个数相加减二就是答案

# 代码：
```
var
  p,q,n,m,a,b,i:int64;
begin
  readln(n,m);
  readln(a,b);
  p:=n;
  q:=m;
  if p<q then begin i:=p; p:=q; q:=i; end;
  while (p mod q)<>0 do if p>q then begin p:=p mod q; i:=p; p:=q; q:=i; end;
  n:=n div q;
  n:=n*b;
  m:=m div q;
  m:=m*a;
  p:=n;
  q:=m;
  if (n=0)or(m=0) then begin writeln(0); halt; end;
  if p<q then begin i:=p; p:=q; q:=i; end;
  while (p mod q)<>0 do if p>q then begin p:=p mod q; i:=p; p:=q; q:=i; end;
  n:=n div q;
  m:=m div q;
  writeln(n+m-2);
end.
```

---

## 作者：BDFZ_hym_AK_hym_ing (赞：0)

### 题目解读：
给定一个 $N \times M$ 的矩阵，并给出一束激光满足夹角为 $ζ$ °，且满足 $\cotζ=\frac{A}{B}$，求激光反射多少次后射入任意一角中。  
$\cot$：指余切，三角函数的一种（不会的百度搜索）。锐角的余切是其邻边与对边的比值（与 $\tan$ 相反）。
### 解题思路：
注意到数据范围最高到 $10^{10}$，所以这题明显是一道数学题而非模拟题。  
只观察一个方向时（假设为长 $N$ 的方向），直到碰到对边时，激光的光线在这个方向上不会被改变，所以每次碰到对边的时间 $T_1=\frac{N}{A}$，宽 $M$ 的方向同理，所以 $T_2=\frac{M}{B}$。  
当射入一个角时，我们可以把它看作同时碰上两条边，所以总时间 $T=\operatorname{lcm}(T_1,T_2)$。  
所以：
$$
T=\operatorname{lcm}(\frac{N}{A},\frac{M}{B})=\frac{N \times M}{A \times B \times \gcd(\frac{N}{A},\frac{M}{B})}
$$
所以在长 $N$ 方向上的次数应该为 $\frac{T}{T_1}-1$（$1$ 表示最后一次射入角内时不用计算次数，后面同理），而在宽 $M$ 方向上的次数应该为 $\frac{T}{T_2}-1$。
所以总次数：
$$
S=T \times (\frac{A}{N}+\frac{B}{M})-2=T \times \frac{A \times M+B \times N}{N \times M}-2
$$
将 $T$ 代入得：
$$
S=\frac{A \times M+B \times N}{A \times B \times \gcd(\frac{N}{A},\frac{M}{B})}-2=\frac{T_1+T_2}{\gcd(T_1,T_2)}-2
$$
因为此时 $T_1,T_2$ 需要为整数，所以将 $N,M$ 同时乘上 $A\times B$，所以 $S$ 此时为：
$$
S=\frac{N \times B+M \times A}{\gcd(N \times B,M \times A)}-2
$$
当我们将 $\gcd(N\times B,M\times A)$ 最小化时，$S$ 将会有最小值。即让 $\gcd(N\times B,M\times A)=1$，此时 $S$ 最小值为 $N \times B+M \times A-2$，直接输出即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a,b;
long long g;
int main(){

	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	cin>>n>>m>>a>>b;
	/*
	要使gcd(am,bn)=1,
	则gcd(a,b)=gcd(a,n)=gcd(m,b)=gcd(m,n)=1
	*/
	g=__gcd(a,b);
	a/=g;
	b/=g;
	g=__gcd(a,n);
	a/=g;
	n/=g;
	g=__gcd(m,n);
	m/=g;
	n/=g;
	g=__gcd(m,b);
	m/=g;
	b/=g;
	cout<<max(0ll,a*m+b*n-2);//特判垂直和水平两个方向

	return 0;
}
```

---

## 作者：破壁人罗辑 (赞：0)

题目传送门 [P5088 矩形](https://www.luogu.com.cn/problem/P5088)

## 解题思路

如果我们把光路拉直，让这个矩形不断重复。

![图中每个矩形都是长为N宽为M的矩形](https://cdn.luogu.com.cn/upload/image_hosting/d8rapkek.png)

我们就把问题转化为求这条光线从一个顶点到达另一个顶点时穿过的边的数量。

我们可以发现，如果这个光线竖直方向上的距离为 $k_1M$，水平方向上的距离为 $k_2N$，则这条光线穿过的边的数量为 $k_1+k_2-2$。

所以我们就把问题转化成了求最小的 $k_1,k_2$，使得 $\frac{k_1M}{k_2N}=\frac BA$，即 $\frac{k_1}{k_2}=\frac{BN}{AM}$。

设 $g=\gcd(AM,BN)$，所以 $k_1=\frac{BN}{g},k_2=\frac{AM}{g}$ 就是我们想要的答案。

再特判一下 $A$ 或者 $B$ 等于 $0$ 的情况。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long gcd(long long x,long long y){
	return x?gcd(y%x,x):y;
}
int main(){
	long long N,M,A,B,g;
	scanf("%lld%lld%lld%lld",&N,&M,&A,&B);
	g=gcd(N,M);N/=g;M/=g;
	g=gcd(A,B);A=A/g*M;B=B/g*N;
	g=gcd(A,B);A/=g;B/=g;
	printf("%lld",A+B>2?A+B-2:0);
	return 0;
}
```

---

## 作者：SalN (赞：0)

[link](https://www.luogu.com.cn/problem/P5088)

----

### 题目大意

一个矩形长宽之比为 $n:m$，边是平面镜

一束激光从左上角出发的跟长 $n$ 夹角为 $ζ^{\circ}(0≤ζ≤90)$

反射角等于入射角，$\cot ζ^{\circ}=a:b$

给定 $n,m,a,b$，求几次反射后到矩形的角

$0\leq n,m,a,b\leq 10^{10}$

----

### 题目解法

首先 [cot](https://baike.baidu.com/item/%E4%BD%99%E5%88%87/9601625?fromtitle=cot&fromid=37020&fr=aladdin) 是直角三角形一个锐角和邻边与对边的比值的函数

设这个矩形就长宽是 $n,m$

我们先玩一下 kawaii 的样例

![lkx世界第一可爱](https://cdn.luogu.com.cn/upload/image_hosting/ro1o9swn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

非常错乱，这给我们一种无从下手的感觉（？？

于是乎我们考虑对称把光路拉直，就将军饮马那个调调

![jyx世界第一可爱](https://cdn.luogu.com.cn/upload/image_hosting/f1o76sf0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所以说就这样拼矩形，答案对应到光线跟非起点的矩形顶点的第一个交点

设合法的这种长方形矩阵长宽为 $P=pn,Q=qm$

这时候反射次数就是 $(p-1)+(q-1)=p+q-2$

也有 $\frac{pn}{qm}=\frac{a}{b}$，意思就是 $\frac{p}{q}=\frac{am}{bn}$

那么把 $\frac{am}{bn}$ 约到最简就是实际上的 $\frac{p}{q}$ 了，不然相当于把这个大整体又拼出一次

这个题这样差不多了，但是有特殊情况，这里 $a=0$ 或者 $b=0$ 的话是要特殊判断答案为 $0$ 的，不然会喜提 $90pts$ 的

----

### 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 

using namespace std;

int n, m, a, b;
int p, q, lsy;

signed main() {
	cin >> n >> m;
	cin >> a >> b;
	if(a==0||b==0) {
		cout << 0;
		return 0;
	}
	lsy=__gcd(n,m);
	n/=lsy, m/=lsy;
	lsy=__gcd(a,b);
	a/=lsy, b/=lsy; 
	p=m*a, q=n*b;
	lsy=__gcd(p,q);
	cout << p/lsy+q/lsy-2;
	return 0;
}
```


---


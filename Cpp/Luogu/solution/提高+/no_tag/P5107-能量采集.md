# 能量采集

## 题目描述

**题面已修改，请大家注意。**

请你求下列式子：$\sum_{i=1}^N\sum_{j=1}^Ngcd(i,j)$ ，答案对大质数取模。

不好意思读错剧本了。

给定一个 $n$ 个点 $m$ 条边的有向图，每个点有初始能量 $a_i$ 。

每过一秒，每个点的能量便会等量地流向所有出边，另外，会有一份流向自己（你可以当做有一个自环）。

现在 $dkw$ 有 $q$ 次询问，每次询问会给你一个时间 $t$ ，$dkw$想知道 $t$ 秒时每个点的能量。

不保证图中没有重边和自环，答案对$998244353$取模。

## 说明/提示

对于 30% 的数据，$1\le t \le 50$

对于 60% 的数据，$1\le q\le 50$

对于 80% 的数据，$1\le q\le 1000$

对于 100% 的数据，$1\le n\le 50,1\le m\le n\times (n-1),1\le q\le 5\times 10^4,0< a_i< 998244353,1\le t\le 10^9$

## 样例 #1

### 输入

```
5 10 3
4 5 3 2 7 
4 1
1 4
2 1
3 2
1 2
5 1
2 4
2 1
2 4
1 4
1
2
3
```

### 输出

```
15
548614965
80769513
```

# 题解

## 作者：foreverlasting (赞：10)

题解同步发在[博客](https://foreverlasting1202.github.io/)

矩阵快速幂。

真的可惜啊，比赛的时候必须要去晚自修，导致一堆分都没拿，难受得一批。

说说这道题，出题人的原意是$k$进制矩乘是吧。然后我就正常倍增矩乘过了此题，让我很是震惊。

我既没有循环展开，也没有什么矩乘的时候乘了一定次数再膜来减少膜的次数，就是最老实的矩乘，可能我代码天生自带小常数。不过一些小技巧还是要注意一下的，比如说能减法就做减法，不要取模，然后尽量减少矩乘时的循环次数，比如记录一个矩阵大小，其他好像就没有什么了。

正式题解在[此](https://blog.csdn.net/stone41123/article/details/85039483)
，有正式题解那我不用讲了，直接上代码。

code:
```
//2018.12.17 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=50+10;
const int kcz=998244353;
namespace MAIN{
    struct Matrix{
        int t[N][N],n,m;
        Matrix() {memset(t,0,sizeof(t));}
        inline void INIT(){
            for(res i=0;i<n;i++)t[i][i]=1;
        }
    };
    int n,m,q;
    int a[N];
    inline void add(res &x,const res &y){
        x+=y,x>=kcz?x-=kcz:1;
    }
    inline Matrix operator * (const Matrix &x,const Matrix &y){
        Matrix cnt;
        for(res i=0;i<x.n;i++)
            for(res j=0;j<y.m;j++)
                for(res k=0;k<x.m;k++)add(cnt.t[i][j],1LL*x.t[i][k]*y.t[k][j]%kcz);
        cnt.n=x.n,cnt.m=y.m;
        return cnt;
    }
    Matrix ret,ans[32];
    inline int qpow(res x,res y){
        res ret=1;
        while(y){
            if(y&1)ret=1LL*ret*x%kcz;
            x=1LL*x*x%kcz,y>>=1;
        }
        return ret;
    }
    inline void MAIN(){
        n=read(),m=read(),q=read();
        for(res i=0;i<n;i++)ret.t[i][0]=read();
        ret.n=ret.m=1;
        ans[0].n=ans[0].m=n;
        ans[0].INIT();
        for(res i=1;i<=m;i++){
            res u=read(),v=read();
            ans[0].t[v-1][u-1]++;
        }
        for(res i=0;i<n;i++){
            res pos=0;
            for(res j=0;j<n;j++)add(pos,ans[0].t[j][i]);
            pos=qpow(pos,kcz-2);
            for(res j=0;j<n;j++)ans[0].t[j][i]=1LL*ans[0].t[j][i]*pos%kcz;
        }
        for(res i=1;i<=31;i++)ans[i]=ans[i-1]*ans[i-1];
        while(q--){
            res t=read();
            Matrix tmp=ret;
            for(res i=0;i<=31;i++)if((1<<i)&t)tmp=ans[i]*tmp;
            LL qaq=0;
            for(res i=0;i<n;i++)qaq^=tmp.t[i][0];
            printf("%lld\n",qaq%kcz);
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：cyffff (赞：6)

# P5107 能量采集
#### [ 传送门](https://www.luogu.com.cn/problem/P5107)

**暴 力 草 标 算**

当然也不是最基础的暴力，用矩阵快速幂倍增一下再卡卡常就轻松过去了。
##### 前置知识

先看数据范围，$1\leqslant n\leqslant 50$，显然是让 $n^3$ 算法过的， $n^3$ 想到什么？矩阵乘法！

想到矩阵乘法就好做了，如果你不知道矩阵乘法是什么~~那你看为啥要看这道题~~，出门左转模板区[矩阵快速幂](https://www.luogu.com.cn/problem/P3390)和[矩阵加速](https://www.luogu.com.cn/problem/P1939)，这里简单列出式子，不再讲解：

对于 $p\times q$ 的矩阵 $A$ 与 $q\times r$ 的矩阵 $B$，它们的乘积 $C=A\times  B$ 计算方式为：

$$C_{i,j}=\sum_{k=1}^{q}A_{i,k}\times B_{k,j}$$

时间复杂度为 $O(pqr)$。

****

现在你了解了矩阵乘法与矩阵快速幂，那么对于这道题，我们可以使一个 $n\times1$  的矩阵 $res$ 为初始矩阵，其中 $res_{i,1}$ 代表第 $i$ 个点最开始的能量。

对于边，我们创造一个 $n\times n$ 的转换矩阵 $base$ 为图的邻接矩阵，其中，$res_{i,1}\times base_{i,j}$ 为 $i$ 号点会流给 $j$ 号点的能量。对于边$(u,v)$，我们使 $base'_{v,u}$ 加一，最后
$$base_{i,j}=\frac{base'_{i,j}}{\sum_{k=1}^nbase'_{k,j}}$$

求一个逆元即可。

****
对于每次询问直接上矩阵快速幂吗？时间复杂度为 $O(qn^3log_2t)≈1.8\times10^{11}$ ~~原地升天~~。

那怎么办？

令
$$P_i=base^{2^i}={P_{i-1}}^2$$
每次询问的答案矩阵 $ans$ 初始值设为 $res$ ，对于每个 $i\in[0,31]$ 且 $t$ 在二进制下第 $i$ 位有为 $1$，$ans\gets P_i\times ans$
.

最终答案为$\bigoplus_{i=1}^{n}ans_{i,1}$。

时间复杂度为$O(n^3log_2t+qn^2log_2t)≈3.7\times10^9$，卡卡常就可以过了，用`__int128`把 $\sum_{k=1}^{q}A_{i,k}\times B_{k,j}$ 存起来最后取模可以大大减少取模次数，可以卡进 $3s$。

正解大概是转到 $k$ 进制倍增，但是我太蒟蒻了不会，可以看别的奆佬的题解。
****
$Code$：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//IO优化
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<25)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		while(ch<'0'||ch>'9') ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return x;
	}
	inline void write(int x){
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
}using namespace IO;
const int mod=998244353;
inline void add(int &a,int b){//优化加法
	a+=b;
	if(a>=mod) a-=mod;
}
struct matrix{//矩阵
	int n,m,a[55][55];
	int* operator[](const int &x){
		return a[x];
	}
	matrix(){
		memset(a,0,sizeof(a));
	}
	friend matrix operator*(const matrix &a,const matrix &b){//矩阵乘法
		matrix c;
		c.n=a.n;
		c.m=b.m;
		for(int i=1;i<=a.n;i++){
			for(int j=1;j<=b.m;j++){
				__int128 ret=0;
				for(int k=1;k<=a.m;k++){
					ret+=1ll*a.a[i][k]*b.a[k][j];
				}
				c[i][j]=ret%mod;
			}
		}
		return c;
	}
	inline void init(int qwq){//大小为qwq*qwq的单位矩阵
		n=m=qwq;
		for(int i=1;i<=n;i++){
			a[i][i]=1;
		}
	}
}res,p[32];
inline int qpow(int x,int y){//快速幂
	int ret=1;
	while(y){
		if(y&1) ret=1ll*ret*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return ret;
}
int n,m,q;
inline void init(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=n;i++){//原矩阵
		res[i][1]=read();
	}
	res.n=n;
	res.m=1;
	p[0].init(n);
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		p[0][v][u]++;//邻接矩阵
	}
	for(int i=1;i<=n;i++){
		int ret=0;
		for(int j=1;j<=n;j++){
			add(ret,p[0][j][i]);
		}
		ret=qpow(ret,mod-2);//逆元
		for(int j=1;j<=n;j++){
			p[0][j][i]=1ll*p[0][j][i]*ret%mod;
		}
	}
	for(int i=1;i<=31;i++){//预处理P
		p[i]=p[i-1]*p[i-1];
	}
}
inline void solve(){
	for(int i=1;i<=q;i++){
		int t=read();
		matrix now=res;
		for(int j=31;~j;j--){//倍增
			if(t&(1<<j)){
				now=p[j]*now;
			}
		}
		ll ans=0;
		for(int j=1;j<=n;j++){
			ans^=now[j][1];
		}
		write(ans%mod);
		out[len++]='\n';
	}
}
int main(){
	init();
	solve();
	fwrite(out,1,len,stdout);
    return 0;
}
/*
Memoty:5.49MB
Time:5.17s
*/
```
那么蒟蒻的这篇题解就结束了，再见$qwq$~

---

## 作者：小粉兔 (赞：5)

### 题意简述：

给定一张 $n$ 个点，$n+m$ 条有向边（包括自环）的有向图。

每一时刻点 $u$ 的权值会平均分配到所有 $u\to v$ 的边的终点上。

例如 $2\to 2$，$2\to 1$，$2\to 3$，$2\to 3$ 四条边。  
点 $2$ 的权值就会平分成 $4$ 份，一份给点 $2$，一份给点 $1$，两份给点 $3$。

$q$ 次询问，问 $t$ 时刻后每个点的权值 ${}\bmod 998244353$。

### 题解：

考虑表示出每一时刻权值分配的过程。

发现可以用矩阵的形式转移：边 $u\to v$（包括自环）表示在矩阵 $Q_{v,u}$ 处加上 $1/d_u$。其中 $d_u$ 表示点 $u$ 的出度（包括自环）。

最终即是求 $Q^{t}\times a$。其中 $a$ 就是初始权值的列向量。

考虑矩阵快速幂优化。

复杂度 $\Theta(qn^3\log_2t)\approx 2\times 10^{11}$。显然不能接受。

---

### 一、

考虑优化矩阵快速幂的过程。

考虑求的是 $Q^{t}\times a$ 是一个列向量，本质上是矩阵和向量的乘积。

计算矩阵和向量的乘积的时间复杂度是 $\Theta(n^2)$ 的，比较低。

考虑减少矩阵和矩阵乘积的次数，用矩阵和向量的乘积代替。

把 $Q^t$ 表示成若干个可以直接得出的矩阵的乘积 $Q_1\times Q_2\times Q_3\times \cdots$。

则答案可以写作 $Q_1\times(Q_2\times(Q_3\times(\cdots \times a)))$ 的形式。

其中的每次乘法都是矩阵和向量的乘法，复杂度比较优。

---

### 二、

那么如何把 $Q^t$ 分解呢？比较容易想到的是二进制拆分。

即记录 $Q^1, Q^2, Q^4, Q^8, Q^{16}, Q^{32}, \cdots$，计算时根据 $t$ 的值与对应的矩阵相乘即可。

这样的复杂度是 $\Theta(\log_2 t(n^3+qn^2))\approx 4\times 10^9$，相较上次有较大优化。

但是仍然不能接受，发现其中 $n^3\log_2 t$ 是预处理复杂度，比较小。  
而复杂度瓶颈仍在于计算答案时的复杂度。

---

### 三、

考虑让预处理复杂度稍微扩大，以减小计算答案时的复杂度。

方法就是不要用二进制拆分。

令进制数为 $b$ ，则最终复杂度应该为 $\Theta(b\lceil\log_b t\rceil n^3+q\lceil\log_b t\rceil n^2)$。  
即 $\Theta(n^2\lceil\log_b t\rceil (bn+q))$。

计算一波可以得到，当 $\lceil\log_b t\rceil=4$ 的时候会比较科学，对应的 $b$ 值为 $178$。

最终的复杂度为 $\Theta(n^2\times 4\times (178n+q))\approx 5.89\times 10^8$ 可能可以通过此题。

---

### 四、

最后考虑一下 $q$ 个询问，发现 $t$ 是没有顺序的。

如果把 $t$ 从小到大排序，每次从上一个的结果推过来，也可以优化一些常数。

---

### 五、

最后是底层优化。在矩阵快速幂时循环展开可能可以得到更好的效果。

---

### 总结：

前三种优化如果不加是过不了这题的。后两种优化可以选择性的使用。

我的代码只用了第四个优化，而标程则两种都用了。

贴一下代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define F(i) for(int i=0;i<N;++i)
const int Mod=998244353;
const int B=178;
typedef long long LL;
int inv[2452];
inline void Init(){inv[1]=1;for(int i=2;i<=2451;++i)inv[i]=(LL)(Mod-Mod/i)*inv[Mod%i]%Mod;}
inline void Add(int&x,int y){x-=(x+=y)>=Mod?Mod:0;}
int N,M,Q;
int q[50000],p[50000],Ans[50000];
int S[2450],T[2450],d[50];
struct Mat{int a[50][50];};
struct Vec{int a[50];};
Mat operator*(Mat p1,Mat p2){
	Mat p3;LL s;
	F(i)F(j){
		s=0;
		F(k)s=(s+(LL)p1.a[i][k]*p2.a[k][j])%Mod;
		p3.a[i][j]=s;
	}
	return p3;
}
Vec operator*(Mat p1,Vec p2){
	Vec p3;LL s;
	F(i){
		s=0;
		F(j)s=(s+(LL)p1.a[i][j]*p2.a[j])%Mod;
		p3.a[i]=s;
	}
	return p3;
}
Vec v;
Mat A;
Mat s[4][B];
inline void IM(){
	for(int i=0;i<4;++i){
		if(i)s[i][1]=s[i-1][1]*s[i-1][B-1];
		else s[i][1]=A;
		for(int j=2;j<B;++j)s[i][j]=s[i][1]*s[i][j-1];
	}
}
inline Vec E(Vec v,int e){
	if(!e)return v;
	for(int j=0;e;++j,e/=B)if(e%B)v=s[j][e%B]*v;
	return v;
}
int main(){
	Init();int x;
	scanf("%d%d%d",&N,&M,&Q);
	F(i)scanf("%d",&x),v.a[i]=x,d[i]=1;
	for(int i=0;i<M;++i)scanf("%d%d",S+i,T+i),++d[--S[i]],--T[i];
	F(i)F(j)A.a[i][j]=i==j?inv[d[i]]:0;
	for(int i=0;i<M;++i)Add(A.a[T[i]][S[i]],inv[d[S[i]]]);
	IM();
	for(int i=0;i<Q;++i)scanf("%d",q+i),p[i]=i;
	sort(p,p+Q,[](int i,int j){return q[i]<q[j];});
	int lst=0;
	for(int qq=0;qq<Q;++qq){
		v=E(v,q[p[qq]]-lst);
		int S=0;
		F(i)S^=v.a[i];
		Ans[p[qq]]=S%Mod;
		lst=q[p[qq]];
	}
	for(int qq=0;qq<Q;++qq)printf("%d\n",Ans[qq]);
	return 0;
}
```

---

## 作者：1saunoya (赞：3)

好草啊…简单题调了半天。

这题其实是一个矩阵快速幂的板子，如果不会的话建议去学矩阵快速幂。

然后的话这题普通的快速幂是过不去的。
我们考虑 $k$ 进制优化。

常见的倍增矩阵其实是 $k^x$ 的$k=2$情况。

但是这题用这种方法不知道能不能跑过去，似乎题解有人这么过了。。

所以我们考虑 $k$ 取 32 的时候，跑的飞快（

```cpp
#include <bits/stdc++.h>
const int P = 998244353;
void mul(int &x, const int &y) {
	x = 1ll * x * y % P;
}
int power(int x, int y) {
	if (y < 0) {
		y += P - 1;
	}
	int res = 1;
	while (y) {
		if (y & 1) {
			mul(res, x);
		}
		mul(x, x);
		y /= 2;
	}
	return res;
}
void plus(int &x, const int &y) {
	x += y;
	if (x >= P) {
		x -= P;
	}
}
void sub(int &x, const int &y) {
	x -= y;
	if (x < 0) {
		x += P;
	}
}
struct modint {
	int value;
	modint() {
		value = 0;
	}
	modint(int _value): value(_value) {}
	void operator =(const int &rhs) {
		value = rhs;
	}
	void operator =(const modint &rhs) {
		value = rhs.value;
	}
	modint operator +(const int &rhs) {
		if (value + rhs >= P) {
			return value + rhs - P;
		} else {
			return value + rhs;
		}
	}
	modint operator +(const modint &rhs) {
		if (value + rhs.value >= P) {
			return value + rhs.value - P;
		} else {
			return value + rhs.value;
		}
	}
	modint operator -(const int &rhs) {
		if (value < rhs) {
			return value - rhs + P;
		} else {
			return value - rhs;
		}
	}
	modint operator -(const modint &rhs) {
		if (value < rhs.value) {
			return value - rhs.value + P;
		} else {
			return value - rhs.value;
		}
	}
	modint operator *(const int &rhs) {
		return 1ll * value * rhs % P;
	}
	modint operator *(const modint &rhs) {
		return 1ll * value * rhs.value % P;
	}
	modint operator /(const int &rhs) {
		return 1ll * value * power(rhs, -1) % P;
	}
	modint operator /(const modint &rhs) {
		return 1ll * value * power(rhs.value, -1) % P;
	}
	void operator +=(const int &rhs) {
		plus(value, rhs);
	}
	void operator +=(const modint &rhs) {
		plus(value, rhs.value);
	}
	void operator -=(const int &rhs) {
		sub(value, rhs);
	}
	void operator -=(const modint &rhs) {
		sub(value, rhs.value);
	}
	void operator *=(const int &rhs) {
		mul(value, rhs);
	}
	void operator *=(const modint &rhs) {
		mul(value, rhs.value);
	}
	void operator /=(const int &rhs) {
		mul(value, power(rhs, -1));
	}
	void operator /=(const modint &rhs) {
		mul(value, power(rhs.value, -1));
	}
	bool operator ==(const int &rhs) {
		return value == rhs;
	}
	bool operator ==(const modint &rhs) {
		return value == rhs.value;
	}
	operator int() {
		return value;
	}
};
int n, m, q;
const int N = 50;
struct Matrix {
	modint a[N][N];
	modint* operator[](int x) {
		return a[x];
	}
	Matrix() {}
	void initial() {
		for (int i = 0; i < n; i++) {
			a[i][i] = 1;
		}
	}
	void print() {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				std::cout << a[i][j] << ' ';
			}
			std::cout << "\n";
		}
	}
};
struct Line {
	modint a[N];
	modint& operator[](int x) {
		return a[x];
	}
	Line() {}
	void print() {
		for (int i = 0; i < n; i++) {
			std::cout << a[i] << ' ';
		}
		std::cout << "\n";
	}
};
Matrix mul(Matrix x, Matrix y) {
	Matrix z;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			z[i][j] = 0;
			for (int k = 0; k < n; k++) {
				z[i][j] += x[i][k] * y[k][j];
			}
		}
	}
	return z;
}
Line mul(Line x, Matrix y) {
	Line z;
	for (int j = 0; j < n; j++) {
		z[j] = 0;
		for (int k = 0; k < n; k++) {
			z[j] += x[k] * y[k][j];
		}
	}
	return z;
}
Line initial;
const int T = 5;
const int S = 1 << T;
Matrix base, pw[32 / T + 1][S];
Line res;
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> n >> m >> q;
	for (int i = 0; i < n; i++) {
		int x;
		std::cin >> x;
		initial[i] = x;
	}
	while (m--) {
		int x, y;
		std::cin >> x >> y;
		--x;
		--y;
		base[x][y] += 1;
	}
	for (int i = 0; i < n; i++) {
		base[i][i] += 1;
	}
	for (int i = 0; i < n; i++) {
		modint all = 0;
		for (int j = 0; j < n; j++) {
			all += base[i][j];
		}
		int iv = power(all, -1);
		for (int j = 0; j < n; j++) {
			base[i][j] *= iv;
		}
	}
	for (int i = 0; i < 32 / T + 1; i++) {
		pw[i][0].initial();
		if (i == 0) {
			pw[i][1] = base;
		} else {
			pw[i][1] = mul(pw[i - 1][S - 1], pw[i - 1][1]);
		}
		for (int j = 2; j < S; j++) {
			pw[i][j] = mul(pw[i][j - 1], pw[i][1]);
		}
	}
	while (q--) {
		int x;
		std::cin >> x;
		res = initial;
		int t = 0;
		while (x) {
			res = mul(res, pw[t][x & S - 1]);
			x >>= T;
			++t;
		}
		int ans = 0;
		for (int i = 0; i < n; i++) {
			ans ^= res[i];
		}
		if (ans >= P) {
			ans -= P;
		}
		std::cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：是个汉子 (赞：3)

当我看到这道题的时候，我就感觉它和[魔法值](https://www.luogu.com.cn/problem/P6569)特别像，所以没做过的可以去做做，说不定会有什么新的发现。

### Solution

矩阵快速幂

看见 $n$ 的范围是 $1\leq n\leq 50$ ，不难想到这道题要用到邻接矩阵。

然后就可以用矩阵快速幂做这个题。构造一个 $n\times n$ 的矩阵， $G_{i,j}$ 代表 $i\rightarrow j$ 有是否一条有向边，有的话存储的则是 $i$ 的出度的逆元，那么 $G$ 就是我们的转移矩阵。把 $F$ 一个 $1\times n$ 的列向量作为初始矩阵，只存储 $a_i$ 。此时复杂度为 $O(qn^3\log t)$ 。

如果加上倍增预处理 $G^{2^i}$ ，复杂度可降为 $O(n^3\log t+qn^2\log t)$ 。   



但此时的复杂度在脸黑的情况下还是过不了的，我们还需要优化，可以考虑将倍增中的二进制预处理改为更大的进制，设为 $z$ 进制，则此时复杂度为 $O(n^3\log_z t+qn^2\log_z t)$ 就可以过了

（还有一些优化是优化常数，在这里不提了）

**注意：因为会流向自己，所以 $i\rightarrow i$  也相当于有一条有向边，即在矩阵中也要转移**

### 代码

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define ll long long

using namespace std;
const int maxn=51,mod=998244353;
inline int add(int a,int b){int res=a+b;if(res>=mod) res-=mod;return res;}
inline int mul(int a,int b){return (ll)a*b-(ll)a*b/mod*mod;}
inline int dec(int a,int b){int res=a-b;if(res<0) res+=mod;return res;}
int n,m,q,out[maxn],map[maxn][maxn],inv[maxn*maxn];
struct matrix{
    int a[maxn][maxn],x,y;//x,y是矩阵
    inline matrix(){memset(a,0,sizeof(a));}
    inline matrix operator = (const matrix &o){
        memcpy(a,o.a,sizeof(a));x=o.x;y=o.y;
        return *this;
    }
    inline matrix operator * (const matrix &o) const {
        matrix res;
        res.x=x;res.y=o.y;
        for(re int i=1;i<=x;i++)
            for(re int k=1;k<=y;k++)
                for(re int j=1;j<=o.y;j++)
                    res.a[i][j]=add(res.a[i][j],mul(a[i][k],o.a[k][j]));
        return res;
    }
}F,G;
matrix quick[4][257];//高次幂的预处理

inline void init(){
    inv[0]=0;inv[1]=1;
    for(int i=2;i<=2500;i++)
        inv[i]=dec(0,mul(inv[mod%i],mod/i));
}

int main(){
    scanf("%d%d%d",&n,&m,&q);
    init();
    F.x=1;F.y=n;
    for(re int i=1;i<=n;i++){
        ++map[i][i];++out[i];
        scanf("%d",&F.a[1][i]);
    }
    for(re int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        ++map[x][y];++out[x];
    }
    for(re int i=0;i<4;i++){
        quick[i][0].x=quick[i][0].y=n;
        for(re int j=1;j<=n;j++) quick[i][0].a[j][j]=1;
    }
    quick[0][1].x=quick[0][1].y=n;
    for(re int i=1;i<=n;i++)
        for(re int j=1;j<=n;j++)
            quick[0][1].a[i][j]=mul(map[i][j],inv[out[i]]);
    for(re int i=2;i<=256;i++) quick[0][i]=quick[0][i-1]*quick[0][1];
    quick[1][1]=quick[0][256];
    for(re int i=2;i<=256;i++) quick[1][i]=quick[1][i-1]*quick[1][1];
    quick[2][1]=quick[1][256];
    for(re int i=2;i<=256;i++) quick[2][i]=quick[2][i-1]*quick[2][1];
    quick[3][1]=quick[2][256];
    for(re int i=2;i<=256;i++) quick[3][i]=quick[3][i-1]*quick[3][1];
    while(q--){
        int x,ans=0;
        scanf("%d",&x);
        G=F*quick[0][x&255]*quick[1][(x>>8)&255]*quick[2][(x>>16)&255]*quick[3][(x>>24)&255];
        for(re int i=1;i<=n;i++) ans^=G.a[1][i];
        printf("%d\n",(ans>=mod)?ans-mod:ans);
    }
    return 0;
}
```



---

## 作者：mrsrz (赞：2)

显然是个矩阵快速幂，构造$n\times n$的矩阵。

有多组询问，如果每次快速幂一遍，则时间复杂度$O(qn^3\log t)$，过不了。

可以考虑记录矩阵的$2^k$次幂，然后二进制拆分乘。由于状态矩阵为$1\times n$的，其做矩阵乘法一次复杂度为$O(n^2)$，所以可以做到$O(n^3\log t+qn^2\log t)$。

看起来还是有些大（实际上可以过）。

考虑分块求幂，可以做到预处理复杂度$O(\sqrt tn^3)$，查询$O(qn^2)$。

但是空间复杂度为$O(qn^2)$，会超过512MB的限制。

那么我们考虑分成4块，每$\sqrt[4]t$分成一块（此处取$256$），然后查询也分4块询问。

时间复杂度$O(4\sqrt[4]tn^3+4qn^2)$。

## Code：
```cpp
#include<cstdio>
#define md 998244353
#define STC static_cast<long long>
#ifndef ONLINE_JUDGE
#define __int128 long long
#endif
#define reg register
struct matrix{
	int a[50][50];
	int r,c;
	matrix operator*(const matrix&b)const{
		matrix c;
		c.r=r,c.c=b.c;
		for(int i=0;i<r;++i)
		for(reg int j=0;j<b.c;++j){
			reg __int128 tmp=0;
			for(reg int k=0;k<b.r;++k)
			tmp+=STC(a[i][k])*b.a[k][j];
			c.a[i][j]=tmp%md;
		}
		return c;
	}
}_1[257],_2[257],_3[257],_4[257],a;
int deg[50],inv[2501],n,m,T;
void init(){
	inv[1]=1;
	for(int i=2;i<2500;++i)inv[i]=STC(md-md/i)*inv[md%i]%md;
	for(int i=0;i<n;++i)
	scanf("%d",&a.a[0][i]),_1->a[i][i]=deg[i]=1;
	a.r=1,a.c=_1->r=_1->c=n;
	_1[1]=*_1;
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		++_1[1].a[--x][y-1];
		++deg[x];
	}
	for(int i=0;i<n;++i)
	for(int j=0;j<n;++j)
	_1[1].a[i][j]=STC(_1[1].a[i][j])*inv[deg[i]]%md;
	for(int i=2;i<257;++i)_1[i]=_1[i-1]*_1[1];
	*_2=*_1,_2[1]=_1[256];
	for(int i=2;i<257;++i)_2[i]=_2[i-1]*_2[1];
	*_3=*_2,_3[1]=_2[256];
	for(int i=2;i<257;++i)_3[i]=_3[i-1]*_3[1];
	*_4=*_3,_4[1]=_3[256];
	for(int i=2;i<257;++i)_4[i]=_4[i-1]*_4[1];
}
int main(){
	scanf("%d%d%d",&n,&m,&T);
	init();
	while(T--){
		scanf("%d",&m);
		matrix x=a*_1[m&255]*_2[m>>8&255]*_3[m>>16&255]*_4[m>>24&255];
		int y=0;
		for(int i=0;i<n;++i)y^=x.a[0][i];
		printf("%d\n",y>=md?y-md:y);
	}
	return 0;
}
```

---

## 作者：LinkCatTree (赞：1)

[安利博客](https://www.cnblogs.com/LinkCatTree/p/18997157)。

观察数据范围发现 $n$ 很小而 $t$ 很大，于是我们想到矩阵快速幂。我们可以直接建 $n \times n$ 的转移矩阵 $A$，设 $u$ 的出边为 $d_u$ 条，边 $(u,v)$ 共有 $cnt_{(u,v)}$ 条（注意重边要计算多次即 $cnt_{(u,v)}$ 可能大于一），则 $A_{v,u} \equiv \dfrac{cnt_{(u,v)}}{d_u} \pmod {998244353}$，再定义 $n \times 1$ 的初始矩阵 $B$ 其中 $B_{i,1} \equiv a_i \pmod {998244353}$。则询问 $t$ 的答案即为 $A^t \times B$。此时时间复杂段为 $\mathcal{O}(qn^3 \log t)$，~~卡卡常能过~~不太能过。

我们考虑进行优化。我们考虑快速幂的过程，据一个例子 $t=13$，则我们实际计算的是 $A^8 \times A^4 \times A^1 \times B$。而矩阵乘法具有结合律，我们可以优化计算顺序：$A^8 \times (A^4 \times (A^1 \times B))$，我们发现 $A^{2^k}$ 与 $B$ 相乘的复杂度仅为 $\mathcal{O}(n^2)$，而由于转移矩阵是已知的，那么 $A^{2^k}$ 是可以预处理的。于是我们成功把时间复杂度降为了 $\mathcal{O}(n^3 \log t + qn^2 \log t)$，能过。

```cpp
// 火车头
const int mod=998244353;
const int N=55;

struct Matrix {
	int n,m,a[N][N];
	Matrix(int l=0,int c=0) {
		n=l,m=c,memset(a,0,sizeof(a));
		return ;
	}
	inline void init(int d) {
		n=m=d,memset(a,0,sizeof(a));
		for(int i=1;i<=d;i++) a[i][i]=1;
		return ;
	}
	inline Matrix operator *(const Matrix &tmp) const {
		Matrix res(n,tmp.m);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				for(int k=1;k<=tmp.m;k++)
					add(res.a[i][k],(ll)a[i][j]*tmp.a[j][k]%mod);
		return res;
	}
};

int n,m,q;
vector<int> edge[N];
Matrix ret[30],stat;

inline ll quickpow(ll base,ll p) {
	ll tmp=1;
	for(;p;p>>=1) {
		if(p&1) tmp=tmp*base%mod;
		base=base*base%mod;
	}
	return tmp;
}
inline Matrix quickpow_matrix(ll p) {
	Matrix tmp=stat;
	for(int i=0;i<30;i++)
		if((p>>i)&1) tmp=ret[i]*tmp;
	return tmp;
}

int main() {
	read(n),read(m),read(q);
	stat=Matrix(n,1);
	for(int i=1;i<=n;i++) read(stat.a[i][1]),edge[i].pb(i);
	for(int i=1,u,v;i<=m;i++) read(u),read(v),edge[u].pb(v);
	ret[0]=Matrix(n,n);
	for(int i=1;i<=n;i++) {
		ll c=quickpow(edge[i].size(),mod-2);
		for(int v:edge[i]) add(ret[0].a[v][i],c);
	}
	for(int i=1;i<30;i++) ret[i]=ret[i-1]*ret[i-1];
	for(int i=1,t;i<=q;i++) {
		read(t);
		Matrix res=quickpow_matrix(t);
		ll ans=0;
		for(int i=1;i<=n;i++) ans^=res.a[i][1];
		write(ans%mod),_E;
	}
	return 0;
}
```

---

## 作者：Jμdge (赞：1)

表示这道题朴素做法 + 一堆优化能 A ，之前题解好像没怎么写过这些优化的（都是在口胡？），于是补上一篇

# noteskey

首先就是得知道这道题的朴素做法：

一看到这数据范围就感觉可以用矩阵加速 dp 转移（好像也不是 dp？ ）

然后我们就构造矩阵，每个点存一下出度，然后 i 转向的每个点边数乘上 du[i] 的逆元，这样就能构造出转移矩阵 F[0] 了
 
 然后我们倍增求出 F[0~30] ，询问的时候也是倍增查询就好了
 

但是这个复杂度...显然崩掉了吧？

然后我们发现时间基本都在查询那块丢掉的，于是乎我们有两种路可走，一种就是老老实实增加预处理复杂度以均衡询问复杂度，也就是用 k 进制优化这个算法；另外一种就是去优化常数（卡常！）了...


于是我们考虑：

> -1. 快读、快输加上去

> 0. 各种 register 、 static 、 inline ...

> 1. 矩乘的时候记录两个矩阵的行数、列数，这样查询的时候的矩乘复杂度就变成了 $n^2$ ！

> 2. 所有的询问读进来，排个序，然后从小到大处理所有询问的答案

> 3. 循环展开优化...一般来讲就是 4 层了 QVQ ，效果好像挺明显的...

> 4. 实在不行，试试评测机波动卡常

> 5. 还是TLE，第四步基础上洗把脸可能就 A 了 XD

# code

然鹅这个代码跑得巨慢，勉强卡过...

```
//by Judge
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define ll unsigned int
using namespace std;
const int mod=998244353;
const int M=51;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
    if(CCF>1<<20)Ot(); while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} static int n,m,Q,du[M],ans[50003];
struct que{ int t,id; }q[50003];
bool cmp(que& a,que& b){return a.t<b.t;}
inline int qpow(Rg int x,Rg int p=mod-2,Rg int s=1){
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
struct Matrix{ int n,m,a[M][M]; Matrix(){memset(a,0,sizeof a);}
	int* operator [](const int& x){return a[x];}
	Matrix operator *(Matrix& b)const{ Matrix c; c.n=n,c.m=b.m;
		fp(i,1,n) fp(k,1,b.n) fp(j,1,b.m) c[i][j]=inc(c[i][j],1ll*a[i][k]*b[k][j]%mod); return c;
	}
}A,S,F[35];
int main(){ n=read(),m=read(),Q=read();
	F[0].n=F[0].m=A.m=n,A.n=1; int x,y;
	fp(i,1,n) A[1][i]=read(),du[i]=F[0][i][i]=1;
	fp(i,1,m) x=read(),y=read(),++F[0][x][y],++du[x];
	fp(i,1,n) du[i]=qpow(du[i]);
	fp(i,1,n) fp(j,1,n) F[0][i][j]=mul(F[0][i][j],du[i]);
	fp(i,1,30) F[i]=F[i-1]*F[i-1];
	fp(i,1,Q) q[i].t=read(),q[i].id=i;
    sort(q+1,q+1+Q,cmp),S=A;
    fp(j,1,Q){ Rg int t=q[j].t-q[j-1].t;
        Rg int i; for(i=0;i<=27;i+=4){
            if((t>>i)&1) S=S*F[i];
            if((t>>i+1)&1) S=S*F[i+1];
            if((t>>i+2)&1) S=S*F[i+2];
            if((t>>i+3)&1) S=S*F[i+3];
        }
        for(;i<=30;++i) if((t>>i)&1) S=S*F[i];
        fp(i,1,n) ans[q[j].id]^=S[1][i];
    }
    fp(i,1,Q) print(ans[i]%mod); return Ot(),0;
}
```

加了这么多优化我才过...果然是人傻常规数大呢~





---

## 作者：fr200110217102 (赞：1)

# 暴力

设$f[i][u]=$ 第$i$秒$u$号点的能量，则

$f[i][u]=\sum{map[v][u]*inv(d[v])}$

其中$map[i][j]$是$i$号点和$j$号点之间边数，$d[i]$是$i$号点的度数。

时间复杂度$O(qn^2t)$

可以得到$30$分。

# 矩阵快速幂

因为每轮转移的系数都是固定的，所以显然可以矩阵乘法优化。

把$map[i][j]*inv(d[i])$存入$n*n$的转移矩阵中，然后用$1*n$的初始能量的矩阵乘转移矩阵的$t$次幂即可。

时间复杂度$O(qn^3logt)$

结合暴力可以得到$60$分。

# 预处理

注意到两个$n*n$的矩阵的相乘复杂度是$O(n^3)$的，但是一个$1*n$的矩阵和一个$n*n$的矩阵相乘，复杂度就是$O(n^2)$的。

因此，可以不在每次询问的时候都把$t$次幂现用快速幂算一次，而是在处理所有询问之前，先把矩阵的$2^1$、$2^2$、$2^3$、……、$2^{30}$次幂预处理出来，询问时把$t$拆成二进制，如果对应的位数是$1$就乘对应幂次的矩阵。

这样复杂度就是$O(n^3logt+qn^2logt)$了。

如果你的矩阵乘法是边乘边取模的，恭喜你获得$80$分的好成绩！

如果你的矩阵乘法这么写，可以减少大量的取模次数。

```cpp
struct mat{
	int n,m;
	ll a[N][N];
	mat operator*(const mat& p)const{
		mat res;
		res.n=n,res.m=p.m;
		for(rint i=1;i<=n;++i)
			for(rint j=1;j<=p.m;++j){
				__int128 sum=0;
				for(rint k=1;k<=m;++k)
					sum+=a[i][k]*p.a[k][j];
				res.a[i][j]=sum%mod;
			}
		return res;
	}
}A[32],ans;
```

就可以过了。而且最慢的点也就不到$3s$。

这题很多套路都和P4007很像。做完那道题再来做就会感觉这个题很简单。

# 代码

```cpp

#include<bits/stdc++.h>
#define rint register int
using namespace std;
typedef long long ll;
inline int read(){
	register int res=0;
	register char c=getchar();
	while(c<48||c>57)c=getchar();
	while(c>=48&&c<=57)res=(res<<3)+(res<<1)+(c&15),c=getchar();
	return res;
}

const int N=55,mod=998244353;
inline ll qpow(ll x,ll y){
	ll res=1;
	for(;y;y>>=1){
		if(y&1)res=res*x%mod;
		x=x*x%mod;
	}return res;
}
inline ll inv(ll x){
	return qpow(x,mod-2);
}
struct mat{
	int n,m;
	ll a[N][N];
	mat operator*(const mat& p)const{
		mat res;
		res.n=n,res.m=p.m;
		for(rint i=1;i<=n;++i)
			for(rint j=1;j<=p.m;++j){
				__int128 sum=0;
				for(rint k=1;k<=m;++k)
					sum+=a[i][k]*p.a[k][j];
				res.a[i][j]=sum%mod;
			}
		return res;
	}
}A[32],ans;

int n,m,q,x,y,d[N];
int mp[N][N];
ll a[N],res,t;

int main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=n;++i)
		a[i]=read(),++d[i],mp[i][i]=1;
	for(int i=1;i<=m;++i){
		x=read(),y=read();
		++d[x],++mp[x][y];
	}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			A[0].a[i][j]=mp[i][j]*inv(d[i])%mod;
	A[0].n=A[0].m=n;
	ans.n=1,ans.m=n;
	for(int i=1;i<=30;++i)
		A[i]=A[i-1]*A[i-1];
	
	while(q--){
		t=read();
		memset(ans.a,0,sizeof(ans.a));
		for(int i=1;i<=n;++i)ans.a[1][i]=a[i];
		for(int i=0;i<=30;++i)
			if((t>>i)&1)ans=ans*A[i];
		res=0;
		for(int i=1;i<=n;++i)
			res^=ans.a[1][i];
		printf("%lld\n",res%mod);
	}return 0;
}
```

---


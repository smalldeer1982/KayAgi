# 不可思议的迷宫

## 题目背景

融合了强力的装备,当然要去探索迷宫了  

## 题目描述

然而，在你用一套神装愉快的切瓜切菜时，慧音大小姐对你发动了忘却技能，于是，没有融合"记"印记的你忘记了迷宫的构造。  

由于在忘却前你对这个迷宫的构造已经了如指掌，所以你知道这个迷宫的 $ n $ 个房间都是互相连通的，并且有 $ n $ 条道路连接这些房间(当然，道路从两个方向都可以经过)    

即使在不可思议的幻想乡，基本的常识也是存在的，也就是说不会有连接两个相同房间的道路，也不会有两端是同一个房间的道路。  

忘记了迷宫的构造后，你无从得知你在哪里，以及前往下一层的通道在哪里.幸运的是，你保存了一份这个迷宫大致的地图，知道了这 $ n $ 条道路分别连接哪两个房间以及每条道路的长度。  

为了通关，你会从你所在的位置(某个随机的位置)不重复经过道路地走向前往下一层的通道(某个随机的位置)，显然，这种路径可能不止 $1$ 条，那么这时你会随机选取其中一条。  

现在，你想知道自己走过的路径的期望长度，为了避免精度误差，只要对 $19260817$ 取模就好了。      


## 说明/提示

#### 样例解释:  

迷宫的结构如下:  
![](https://cdn.luogu.com.cn/upload/pic/42707.png)  
起始点和结束点都是随机的，用二元组$(x,y)$表示  

以几个有代表性的二元组为例:  

$(1,1)$，只有一条长度为$0$的路径  

$(1,2)$，有两条路径$1-4-2,1-4-3-2$，期望路径长度为 $\frac{4+6}{2}=5$   
$(3,3)$，有两条路径$3-2-4,3$，期望路径长度为 $\frac{6+0}{2}=3$   

不难算出，将所有可能的二元组的期望路径长度加在一起为$57$，所以答案为 $\frac{57}{16}$ ,在模意义下等于 $8426611$。

#### 数据范围:  

![](https://cdn.luogu.com.cn/upload/pic/42697.png)

## 样例 #1

### 输入

```
4
1 4 2
4 2 2 
3 4 2
2 3 2```

### 输出

```
8426611```

# 题解

## 作者：Danno0v0 (赞：10)

真是很有意思的一道题呢 ~~虽然我交了一页才过~~

首先呢看到 $n \leq 300000$ ，那么枚举每条路径是肯定要 T 飞的。

那么既然是计算期望路径长，不能枚举每条路径，那就把路径拆开，我们来依次枚举每条边会被经过多少次。

还有为了方便，我们可以先算出总路径长再除以方案总数来算期望长度。

有了这些就可以开干了。

题上说有 $n$ 个点 $n$ 条边，那就是基环树，那我们就把在环边和非环边分开来看。

- 非环边

非环边的经过次数应该很好算，次数这条边两侧的点数量之积再乘以 $2$ 。为什么呢，假如这条边一侧有 $a$ 个点，另一侧是有 $b$ 个点，那么如果要经过这条边，那就是要从一侧到另一侧去（假如起点和终点都在同一侧的话那为什么还要经过这条边呢）所以一共有 $a\times b$ 条路径是要经过这条边的，然后又因为假如把起点和终点对调是算两条路径的所以要乘个 $2$ 。

那么非环边对答案的贡献就是 $sum_{left} \times sum_{right} \times 2 \times w_i$ 。

- 环边

首先我们要明白一个道理：假如一条路径经过了环上任意一点，那么一定是存在另一条路径的。

（这也是这道题一个大坑：假设我们要从 $4$ 到 $1$ ，那么其实是有两条路的：

![](https://cdn.luogu.com.cn/upload/image_hosting/c5zq0waz.png)

）

那么这两条路径的长度分别是：

（假设起点是 $a$ 终点是 $b$）

- $a$ 到环的距离 $+$ 环的一侧的长度 $+$ $b$ 到环的距离

- $a$ 到环的距离 $+$ 环的另一侧的长度 $+$ $b$ 到环的距离

它们一起对答案的贡献是：（由于在 $a$ 到 $b$ 的方案中，两条路径的被选择概率都是 $\frac{1}{2}$ ，所以要除一个 $2$）

 $(2 \times$ $a$ 到环的距离 $+$ 环的长度 $+$ $2\times b$  到环的距离$) \div 2$ 
 
而我们这里只关注环边的贡献，那么环边的贡献也就是：

环的长度 $\div 2$ 

那么我们可以推测出：假设有一个起点和终点之间的路径会经过环，那么环边一定会贡献环的长度 $\div 2$ 的贡献。

那么我们就可以算出到底有多少种方案会经过环，再把方案数乘上这个贡献，就是环边的所有贡献了。这里呢先算有多少种方案不经过环再从总方案里扣除比较好算，而一个方案不经过环，那么起点和终点一定满足：

在同一棵子树内；

公共祖先不在环上。

说的简单明了，就是起点和终点一定要在环上的点的同一棵子树内：（如果在环上的点的两颗子树内，那么一定会经过环上的那个点）

![](https://cdn.luogu.com.cn/upload/image_hosting/49zhdes7.png)

那么，同一棵子树里的点两两之间可以产出一条不经过环的路径，那么总路径就是 $x^2$ 条 ,其中 $x$ 是子树大小；

那么有多少条路径不经过环也就可以算了，也就是所有子树的大小平方之和：

$x_1^2+x_2^2+ \dots x_n^2$

那么有多少条路径经过环也就可以算了，那么环边做出的总贡献也就可以算了：（$length$ 是环的长度）

$length\times(n^2-\sum\limits_{i=1}^nx_i^2)$

然后两种边的贡献就算完了，加起来再除以方案总数，完——

code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fi[10000001],nx[10000001],to[10000001],co[10000001],tot,length;
int n;
int loop[10000001],num,size[10000001];
int size_tree;
bool check[10000001],in[10000001],huan;
long long all;
stack<pair<int,int> >sta;
namespace Mod {
    const int mod = 19260817;
    int add(int x, int y) {
        return (x += y) < mod ? x < 0 ? x + mod : x : x - mod;
    }
    int Add(int&x, int y) {
        return (x += y) < mod ? x < 0 ? (x += mod) : x : (x -= mod);
    }
    int mul(int x, int y) {
        return 1LL * x * y % mod;
    }
    int Mul(int&x, int y) {
        return x = 1LL * x * y % mod;
    }
    int qpow(int x, int y) {
        int res = 1;
        for (; y; y >>= 1) {
            if (y & 1) Mul(res, x);
            Mul(x, x);
        }
        return res;
    }
    int inv(int x) {
        return qpow(x, mod - 2);
    }
}
using namespace Mod;
void link(int a,int b,int c)
{
	nx[++tot]=fi[a];
	fi[a]=tot;
	to[tot]=b;
	co[tot]=c;
} 
void dfs1(int now,int fa,int w)
{
	if(in[now])
	{
		length+=w;
		while(sta.top().first!=now)
		{
			loop[++num]=sta.top().first;
			length+=sta.top().second;
			check[sta.top().first]=1;
			sta.pop();
		}
		loop[++num]=now;
		check[now]=1;
		huan=1;
		return;
	}
	sta.push({now,w});
	in[now]=1;
	for(int i=fi[now];i;i=nx[i])
	{
		int v=to[i];
		if(v!=fa)
		{
			dfs1(v,now,co[i]);
			if(huan)
			{
				return;
			}
		}
	}
	sta.pop();
}
void dfs2(int now,int fa,int w)
{
	size[now]=1;
	for(int i=fi[now];i;i=nx[i])
	{
		int v=to[i];
		if(check[v]||v==fa)
		{
			continue;
		}
		dfs2(v,now,co[i]);
		size[now]+=size[v];
		if(check[now])
		{
			Add(size_tree,mul(size[v],size[v]));
		}
	}
	Add(all,mul(w,mul(2,mul(size[now],n-size[now]))));
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		link(x,y,z);
		link(y,x,z);
	}
	dfs1(1,0,0);
	for(int i=1;i<=num;i++)
	{
		dfs2(loop[i],0,0);
	}		
	Add(all,mul(mul(add(mul(n,n),-size_tree),length),inv(2)));
	cout<<mul(all,inv(mul(n,n)))<<endl;
} 
```


---

## 作者：老莽莽穿一切 (赞：3)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/15413354.html)

这道题难度不大，但是坑点很多，下面我们一一清点 ~~（拉清单）~~ 。

首先，最不坑的坑点，$i\to j$ 和 $j\to i$ 分开计算，$i\to i$ 只算一次。

然后，只要路径上的节点与环**有交集**，路径就可以从环的两侧走，这一点在样例里有部分体现。

最坑的点，若起点或终点在环上，则可以在**从起点出发之前（到达终点之后）绕环一周**，同样的，如果起点和终点重合在环上，则可以经过 $0$ 的长度直接到达，也可以绕环一周后到达，你的路径中只要有一个点在环上，路径就可以从环上绕一圈，比如下面这张图中 $1\to5$ 的路径有$\color{red}{红色}$和$\color{blue}{蓝色}$标出来的两条 ~~（画图技术有限）~~ ：

![](https://cdn.luogu.com.cn/upload/image_hosting/nmgmvmgb.png)

知道了这些坑点，其实这道题难度不大，下面开始分析做法。

我们发现如果枚举每个起点和终点，时间就炸了，所以我们可以枚举每条边，考虑每条边被经过的次数。

另外，直接计算期望不方便，不妨先计算路径和，再除以总方案数。

### 1 非环边

如果一条边是非环边，这条边考虑起来就相对简单，如果起点和终点在它同一侧，则不可能经过它，因为没法回去，如果起点和终点在它异侧，则肯定会经过它，所以直接将左右两边点数乘起来，再乘 $2$（将起点和终点对调）就是答案了。

### 2 环边

如果一条边在环上，那么只要一条路径与环有交集，就肯定有 $\dfrac{1}{2}$ 的概率经过这条边，所以问答题转化为有多少条路径会经过环。

我们分情况讨论。

首先，约定总点数为 $n$ ，环上的点数为 $c$ ，**不在环上但和环上的点有直接边相连**的第 $i$ 个点的子树大小为 $v_i$ 。

#### 2.1 两个端点都在环上

如果两个端点都在环上，则这条路径肯定只能沿着环的某个方向走，一定会经过环，环上的每个点都可以作为起点，也可以作为终点，方案数是 $c^2$ 。

#### 2.2 只有一个端点在环上

这个也很简单，显然，根据上面的坑点，这种情况也肯定会存在路径经过环，如果有一个端点在环上，则一个端点取在环上，方案数是 $c$ ，另一个端点取在环外，方案数是 $n-c$ ，答案就是 $2c(n-c)$ ，乘 $2$ 的原因同上。

#### 2.3 两个端点在两个不同的子树内

这里的不同不仅仅是根节点在环上的编号不同，还有同一个环上节点的不同儿子的子树，这个原因上面坑点已经给出解释，这个其实也比较好算，你其实就是选取一个子树，在其中任取一点作为起点，再选取**另一个**子树，任选一点作为终点，方案数如下：

$$
\sum_i\sum_jv_iv_j[i\neq j]
$$

这个式子是 $n^2$ 级别的，肯定不行，我们要进行优化，如何优化呢？我们可以通过构造两个线性可求的式子进行相减，有初中水平知识的可以注意到完全平方公式，没错，我们只要用完全平方公式减去平方和就好了，原因如下：

完全平方式展开后就变成了下面。

$$
(\sum_iv_i)^2=\sum_i\sum_jv_iv_j
$$

观察发现只少了一个 $[i\neq j]$ ，我们可以专门把这部分取出来，即 $i=j$ 的情况：

$$
\sum_iv_i^2
$$

所以方案数就是：

$$
(\sum_iv_i)^2-\sum_iv_i^2
$$

这样我们就分情况讨论完毕了，接下来就是代码实现。

### 代码实现

先把基环树上的环找到，我这里用的是一种冷门到极点的写法（也许只有我在用），你们可以使用自己的写法，或者查看别的题解，找到环以后就直接统计上面约定的 $c$ 和 $v$ ，再统计，最后别忘了乘 $n^2$ 的逆元。

[**c++ 代码**](https://www.cnblogs.com/LaoMang-no-blog/p/15413354.html)

---

## 作者：Shandris (赞：3)

### 1.一个环
首先考虑一个环的情况，假设有$n$个点，那么对于任意的起点$s$和终点$t$,有且仅有两条路径,长度之和为环长$len$。那么期望的距离就是$len/2$，所以一个环的情况答案是$n^2\times len / 2$
### 2.考虑每条边的计算次数
还是考虑一个环的情况，这次我们计算每条边经过的次数。对于任意的起点$s$和终点$t$，有且仅有两条路径，其中一条**一定经过这条边**，另一条一定**不经过**。所以这一条边的计算次数为$n^2/2$，除以2是因为有两条路径。
### 3.考虑基环树的情况
假设我们现在已经找到了一个环，那么我们先来计算环上的每一条边需要计算多少次。假设任意取一条环上的边$e$，对于任意的起点$s$和终点$t$，我们要从$s$走到$t$，先来思考什么情况下只会有1条路径，只有当$s$和$t$位于同一颗子树的时候(这里的同一颗子树指的是，$s$和$t$都不在环上，并且从$s$到$t$不会经过环)，环上的这条边e**必然不会被经过**，对于其他情况下的$s$和$t$(不在同一颗子树)，那么**必然要经过环**，那么**必然有且仅有两条路径**，其中一条**一定经过$e$**，另一条**一定不经过$e$**，而且我们还会发现，$\color{red}\textbf{环上的每条边所需要的计算次数是一样的}$
，所以环上的所有边需要计算的次数为$n^2-v_1^2-v_2^2-v_3^2...$这里的$v_i^2$指的是第$i$颗子树有多少个节点(不包括环上的点)。
### 4.计算非环上的边
剩下的就比较简单了，非环上的边计算次数，只需要算一下两边各有多少个节点，乘起来就可以了。最后别忘了答案加起来除以$n^2$。


---

## 作者：liheyang123 (赞：0)

### test 1
$n \le 100$，可以直接通过暴力实现，即找出任何一个二元组 $(u,v)$ 的期望路径长度，因为只有一个简单环，所以任意两点间最多只有三条简单路径，时间复杂度 $O(n^2m \log_2 n)$。

### test 2，3
$n \le 1000$，不难证明 $\forall (u,v)$ 都与 $(v,u)$ 的期望路径长度相等，所以可以通过对 $u$ 进行一次 dijikstra 进行对 $\forall v$，的 $(u,v)$ 与 $(v,u)$ 的期望路径长度，时间复杂度 $O(nm \log_2 n)$。

### test 2，4，9
不难发现一个性质，$\forall (u,v)$，它们的期望路径长度一定是环上的边权总和的一半，时间复杂度 $O(n)$。

### test 4，5，6，7，8

有 $n$ 个点 $n$ 条边，那就是基环树，那我们就把在环边和非环边分开来看。

首先有如下性质：假如一条路径经过了环上任意一点，那么一定是存在另一条路径的。

#### 环边
假设有n个点，那么对于 $\forall (u,v)$，有且仅有两条路径，长度之和为环长 $len$。那么贡献就是 $\frac{len}{2}$。

#### 非环边
记一条边其中一端有 $ls$ 个节点，另一端有 $rs$ 个节点，边权为 $w$，那么这条的贡献为 $ls \times rs \times w$。

#### 一些值得注意的点
乘法有可能会爆 ```int```，如果不追求空间复杂度可以用 ```long long```，先给出带余除法和带余加法代码。

```cpp
//注意两段代码应同时使用
//带余加法
int operator + (const int  &a, const int  &b){
  return (a + b > mod ? a - mod + b : a - b);
}

//带余乘法
int operator * (const int &a , const int &b){
  int s = 0;
  while(a){
    if(a & 1) s = (s + b);
    a >>= 1;
    b = (b + b);
  }
  return s;
}
```


#### 时间复杂度分析
求逆元 $O(\log_2 mod)$，找环 $O(n)$，对边求贡献时间复杂度 $O(n)$，在找环部分可以顺便求一条边的左右节点数，最后总时间复杂度 $O(n)$。

### test 9，10
同上。

---

## 作者：Sukilin (赞：0)

# P5129 【不可思议的迷宫】
## 题意
给定一个 $n$ 个节点的基环树，均匀随机地选择两个节点构成的有序对，对于每个点对均匀随机地选取它们之间的路径（一条路径不能经过同一条边），求路径长度的期望（模 $19260817$ 意义下）。

## 思路
我们先求出期望的“分子”，再除以 $n ^ 2$ 即可。

我们只需要分几种情况讨论。

以下我们称以一个与环相邻的点为根的树为一个“子树”，如下图画框的部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/4brtxd1j.png)


以下是一些符号：
|$p$|$l$|$u_i$|$v_i$|$d_v$（$v$ 为环外的任何节点）|$\sum d$|$k$|$s_i$|
|---|---|---|---|---|---|---|---|
|环上节点的个数|环的长度|环上的某个节点|环外的某个节点|$v$ 节点到环的距离|所有环外节点到环的距离的总和|子树个数|第 $i$ 棵子树中节点数目

### 两点都在环上
显然，每个点对的期望都是 $l / 2$。这样的点对有 $p ^ 2$ 个，总和为 $p ^ 2 l / 2$。

### 有且仅有一个点在环上
此时两点之间有两条路。设该数对为 $(u, v)$，其中 $v$ 在环外，则其期望为 $d_v + l/2$。我们把每一个点对的贡献拆成 $d_v$ 和 $l/2$。

注意所有该情况下的数对为

$(u_1, v_1)(u_2, v_1)\cdots (u_p, v_1)\\
(u_1, v_2)(u_2, v_2)\cdots (u_p, v_2)\\
\vdots \\
(u_1, v_{n-p})(u_2, v_{n-p})\cdots (u_p, v_{n-p})$

以及

$(v1, u1)(v2, u1)\cdots (v_{n-p}, u_1)\\
(v1, u2)(v2, u2)\cdots (v_{n-p}, u_2)\\
\vdots \\
(v1, u2)(v2, u2)\cdots (v_{n-p}, u_2)
$

通过观察和推理，可以发现每个环外点出现了 $2p$ 次。于是 $d_v$ 的总和为 $2p\sum d$。一共有 $2p(n-p)$ 个点对，因此 $l/2$ 的总和为 $lp(n-p)$。

### 两个点在环外且其 LCA 在环上
符合条件的点对显然都满足两个点在不同的子树。

每个点对 $(u, v)$ 的贡献为 $d_u + d_v + l/2$。

考虑拆贡献，每个点 $u$ 被计算 $2s_u(n-p-s_u)$ 次。

注意到还有 $l/2$，由于有 $\sum _{i=1} ^k s_i(n-p-s_i)$ 个点对，相乘即可。贡献为 $(l/2)\sum _{i=1} ^k s_i(n-p-s_i)$。

### 两个点在环外且其 LCA 不在环上。
那么路径就只有一条了，就是树上的路径。但是直接算不好处理，而且时间复杂度可能会出 $\lg n$，所以我们拆出每条边的贡献。

看下面的图，一棵子树内每条边被经过的点对一定一个在红色方框内，一个在蓝色方框内。（致患有色盲的读者：左下方框是红的，右上方框是蓝的。）

![](https://cdn.luogu.com.cn/upload/image_hosting/juujv9ts.png)

预先维护每个节点下方的树（就是真正意义上的子树）的节点个数，然后用整个子树减去它，再相乘即可。

## 细节
首先涉及 $l/2$，我们分子分母同时乘以 $2$ 以规避可能的分数。然后一眼就能看出来 $19260817$ 是素数，因此直接快速幂即可求乘法逆元。

直接 DFS 可以找到环、求出环长度、维护 $d_v$ 等信息，都非常简单，这里不再赘述。

## 代码
写得稍微有点闹心
```cpp
#include <iostream>
#include <cstdio>
const int N = 3e5 + 7, M = 3e5 + 7, MOD = 19260817;
int nex[M << 1], to[M << 1], wt[M << 1], head[N], cnte = 1;
inline void add(int u, int v, int w) {
	nex[++cnte] = head[u];
	to[cnte] = v;
	wt[cnte] = w;
	head[u] = cnte;
}
int n;
int p, l;
int dfn[N], loop[N], fr[N], cntd;
bool inloop[N];
void getloop(int u) {
	dfn[u] = ++cntd;
	for(int i = head[u]; i; i = nex[i]) {
		int v = to[i];
		if(dfn[v]) {
			if(dfn[v] < dfn[u]) continue;
			loop[++p] = v, inloop[v] = true;
			for(; v != u; v = fr[v]) loop[++p] = fr[v], inloop[fr[v]] = true;
		}
		else fr[v] = u, getloop(v);
	}
}
bool vis[M << 1];
void getlen(int u) {
	for(int i = head[u]; i; i = nex[i]) {
		int v = to[i];
		if(inloop[v] && !vis[i] && !vis[i ^ 1]) {
			vis[i] = true, vis[i ^ 1] = true;
			l = (l + wt[i]) % MOD;
			getlen(v);
		}
	}
}
int fa[N], d[N], sz[N];
bool isch[N];
int an[N];
int sm[N];
int ch[N], cntc;
int sumd;
int hanchar;
void dfs1(int u, int f) {
	sz[u] = 1;
	for(int i = head[u]; i; i = nex[i]) {
		int v = to[i];
		if(v == f || inloop[v]) continue;
		fa[v] = u;
		d[v] = d[u] + wt[i];
		dfs1(v, u);
		sz[u] += sz[v];
	}
}
void dfs2(int u, int f, int rt) {
	an[u] = rt, sm[rt] = (sm[rt] + d[u]) % MOD;
	for(int i = head[u]; i; i = nex[i]) {
		int v = to[i];
		if(v == f) continue;
		hanchar = (hanchar + (1ll * sz[v] * (sz[rt] - sz[v]) * wt[i]) % MOD) % MOD;
		dfs2(v, u, rt);
	}
}
int pow(int a, int b) {
	int res = 1;
	a = a % MOD;
	while(b) {
		if(b & 1) res = (1ll * res * a) % MOD;
		a = (1ll * a * a) % MOD;
		b >>= 1;
	}
	return res;
}
int main() {
	std::cin >> n;
	for(int i = 1; i <= n; i++) {
		int u, v, w;
		std::cin >> u >> v >> w;
		add(u, v, w);
		add(v, u, w);
	}
	getloop(1);
	getlen(loop[1]);
	for(int i = 1; i <= p; i++) dfs1(loop[i], 0);
	for(int i = 1; i <= n; i++) sumd = (sumd + d[i]) % MOD;
	for(int i = 1; i <= n; i++) if(!inloop[i] && inloop[fa[i]]) isch[i] = true, ch[++cntc] = i;
	for(int i = 1; i <= cntc; i++)
		dfs2(ch[i], fa[ch[i]], ch[i]);
	int nume = 0;
	nume = (nume + (1ll * l * p * p) % MOD) % MOD;
	nume = (nume + (2ll * p * ((2ll * sumd) % MOD + (1ll * l * (n - p)) % MOD)) % MOD) % MOD;
	int tsum = 0;
	for(int i = 1; i <= n; i++) {
		if(inloop[i]) continue;
		tsum = (tsum + ((2ll * d[i] * (n - p - sz[an[i]])) % MOD)) % MOD;
	}
	tsum = (2ll * tsum) % MOD;
	nume = (nume + tsum) % MOD;
	tsum = 0;
	for(int i = 1; i <= cntc; i++) 
		tsum = (tsum + ((1ll * sz[ch[i]] * (n - p - sz[ch[i]]) * l) % MOD)) % MOD;
	nume = (nume + tsum) % MOD;
	nume = (nume + (4ll * hanchar) % MOD) % MOD;
	int dve = (2ll * n * n) % MOD;
	std::cout << (1ll * nume * pow(dve, MOD - 2)) % MOD << '\n';
	return 0;
}
```

---


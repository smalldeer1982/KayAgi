# WD与循环

## 题目背景

WD整日沉浸在循环中，无法自拔……

## 题目描述

这天，WD 蒟蒻为了解决一个小问题写了个很长很长的 for 循环：
```cpp
int cnt = 0;
for (int a_1 = 0; a_1 <= m; a_1++) {
    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {
    ...
        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {
            cnt = (cnt + 1) % 19491001;
        }
    }
}
printf("%d\n", cnt);
```
CX 过来看了一眼，说：**WD 你个笨蛋，这道题不是 SB 题吗？** WD 一脸懵逼，只好请你来教教他啦……

## 说明/提示

$\text{subtask1}(23pts):~n,m\le 1,000,~1\le T\le 10,000$

$\text{subtask2}(35pts):~n,m\le 10^7,~1\le T\le 5$

$\text{subtask3}(42pts):~n,m\le 10^{18},~1\le T\le 100,000$

对于样例 1，写个代码就知道答案是 55 了（大雾）。

## 样例 #1

### 输入

```
2
2 9
10 14```

### 输出

```
55
1961256```

# 题解

## 作者：Awdrgysxc (赞：7)

【分析】

可以把每个循环理解为是一个盒子，m是球的数量，因为循环的性质，这不就是求方案吗（组合数），加上卢卡斯定理就好了

【Code】

By waaadreamer

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int mod = 19491001;
ll fac[mod], rev[mod], n, m;
ll modpow(ll a, int b) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
    }
    return res;
}
ll lucas(ll a, ll b) {
    if (a < b) return 0;
    if (a < mod) return fac[a] * rev[b] % mod * rev[a - b] % mod;
    return lucas(a / mod, b / mod) * lucas(a % mod, b % mod) % mod;
}
int main() {
    for (int i = fac[0] = 1; i < mod; i++) fac[i] = fac[i - 1] * i % mod;
    rev[mod - 1] = modpow(fac[mod - 1], mod - 2);
    for (int i = mod - 1; i > 0; i--) rev[i - 1] = rev[i] * i % mod;
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%lld%lld", &n, &m);
        printf("%lld\n", lucas(n + m, m));
    }
    return 0;
}
--------------------- 
作者：WAautomaton 
https://blog.csdn.net/WAautomaton/article/details/85057257 
```

---

## 作者：Fading (赞：5)

题意:询问有多少个由非负整数构成的序列 $(a_1,a_2,... ,a_n)$

满足 

$$a_1 + a_2 + ... + a_n \leq m$$

如果是 $a_1 + a_2 + ... + a_n = m$，很简单，直接上隔板法，答案就是
 $C^{n-1}_{n+m-1}$

那么如果是 $\leq$ 呢？直接求和就好了。

$$ans=\sum_{i=0}^{n+m-1}C^{m-1}_{i}$$

我看看数据范围就放弃了暴力。但是我打了一个杨辉三角的表就发现：

$$\sum_{i=0}^{n}C^{m}_{i}=C_{n+1}^{m+1}$$

也就是

$$\sum_{i=1}^{n+m}C^{m-1}_{n+m-i}=C_{n+m}^{m}$$

~~所以和lucas定理模板题就是双倍经验了~~

这是为什么呢？

我们考虑数学归纳法。

证明：

$$\sum_{i=0}^{n}C^{m}_{i}=C_{n+1}^{m+1}(n,m\geq0)$$

若 $n=0$，分类讨论一下就知道成立了。~~什么鬼证明~~

假设 $n=k$ 时结论成立，即
$$\sum_{i=0}^{k}C^{m}_{i}=C_{k+1}^{m+1}$$

$$∴(\sum_{i=0}^{k}C^{m}_{i})+C_{k+1}^{m}=C_{k+1}^{m+1}+C_{k+1}^{m}$$

根据组合数的性质（杨辉三角的性质）

$$C_{n-1}^{m-1}+C_{n-1}^{m}=C_{n}^{m}$$

$$∴\sum_{i=0}^{k+1}C^{m}_{i}=(\sum_{i=0}^{k}C^{m}_{i})+C_{k+1}^{m}=C_{k+1}^{m+1}+C_{k+1}^{m}=C_{k+2}^{m+1}$$

即对于 $n=k+1$ 时结论也成立

综上所述，对于 $(n,m\geq0)$ 时结论成立。

-------------------------

这题就变成一道组合数裸题了。

题目出的还是挺不错的。套一下 Lucas 就好了！

个人感觉是蓝~紫题吧，评成黑题的话就有点厉害了。

代码：
```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL fa[19491003],T,n,m,pp;
LL fast_pow(LL a,LL b,LL p){    
    LL t=1;a%=p;
    while (b>0){
        if (b%2) t=t*a%p;
        b/=2;a=(a*a)%p;
    }
    return t;
}
LL un(LL a,LL p){
    return fast_pow(a,p-2,p); 
}
void _init(LL p){
    fa[0]=1;
    for (int i=1;i<=p;i++){
        fa[i]=fa[i-1]*(i%p);fa[i]%=p;
    }
}
LL C(LL n,LL m,LL p){ 
    if (n<m) return 0;
    return fa[n]*un(fa[n-m],p)%p*un(fa[m],p)%p;
}
LL fast_C(LL n,LL m,LL p){
    if (n<m) return 0;
    if (!n) return 1;
    return fast_C(n/p,m/p,p)%p*C(n%p,m%p,p)%p;
}
int main(){
    scanf("%lld",&T);
    _init(19491001);
    while (T--){
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",fast_C(n+m,m,19491001));
    }
}
```

---

## 作者：Albedo (赞：4)



## Solution

我们直接强制 $ a_i \ge 1 $ ，那么这时候 $ \sum_{i=1}^{n} a_i\le n+m $ ，然后反手一个隔板法，答案为 $ C_{n+m}^{n} $  ，你发现模数为 $ 19491001 $ 是个质数，反手一个卢卡斯定理，就做好了。

## Code

```c++
long long C(long long n,long long m)
{
	if ((n<0)||(m<0)||(n<m)) return 0;
	return fac[n]*ifac[n-m] % MOD*ifac[m] % MOD;
}
long long Lucas(long long n,long long m,long long p)
{
	if ((n<p)&&(m<p)) return C(n,m);
	return Lucas(n/p,m/p,p)*C(n % p,m % p) % MOD;
}
int main()
{
	//ios::sync_with_stdio(0);cin.tie();cout.tie();
	MOD=19491001;
	fac[0]=1;
	for (i=1;i<MOD;i++) fac[i]=fac[i-1]*i % MOD;
	ifac[MOD-1]=pow(fac[MOD-1],MOD-2,MOD);
	for (i=MOD-2;i>=0;i--) ifac[i]=ifac[i+1]*(i+1) % MOD;
	for (T=read();T;T--)
	      {
	      	n=read();m=read();
	      	printf("%lld\n",Lucas(n+m,n,MOD));
		  }
    return 0; 
}
```



---

## 作者：luogu10086 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P5160)

### PART 1

题目大意：

给定多组数据，每组数据有两个数 $n$ 和 $m$。表示有 $n$ 个自然数，问：有多少种和小于等于 $m$ 的方案，方案数对 $19491001$ 取模。




------------
### PART 2

整体思路：

转换一下，我们可以把问题变成我们熟知的**球盒问题**。

$n$ 个相同的小球，分到 $m$ 个相同的盒子里，每个盒子**可以**为空，问有多少种可行的方案。

我们可以得出方案数为 $C ^{\texttt{{ }}m}_{\texttt{ }n+m}$ 种，但是 $n,m \le 10^{18}$，无法直接去算。

我们可以借助[卢卡斯定理](https://www.luogu.com.cn/problem/P3807)。

卢卡斯定理，简单地来说就是：  
$C ^{\texttt{{ }}n}_ {\texttt{ }m} \equiv C ^{\texttt{ }n \bmod p}_ {\texttt{ }m \bmod p}  \times  C ^{\texttt{{ }}n/p}_ {\texttt{ }m/p} \pmod p$，且 $p$ 为质数。

我们可以转化成：   
$Lucas(n,m,p)\equiv C ^{\texttt{ }n \bmod p}_ {\texttt{ }m \bmod p}  \times Lucas(n/p,m/p,p)  \pmod p$


而 $19491001$ 刚好是一个质数，所以我们可以套用，再加以修改通过此题。



------------
### PART 3

代码实现：

```cpp
#include<bits/stdc++.h>
#define p 19491001
using namespace std;
int T;
long long n,m;
long long fac[20000000],inv[20000000];
long long C(long long n,long long m){//组合数公式
	if(m > n)return 0;
	return fac[n] % p * inv[fac[m]] % p * inv[fac[n - m]] % p;
}
long long Lucas(long long n,long long m){//卢卡斯定理
	if(!m)return 1;//判断
	return C(n % p,m % p)*Lucas(n / p,m / p) % p;//套用
}
int main(){
	fac[0] = 1;//初始化
	for(int i = 1;i <= 19491001;++i)fac[i]=(fac[i - 1] * i) % p;
	inv[1] = 1;
	for(int i = 2;i <= 19491001;++i)inv[i]=(long long)((p - p / i) * inv[p % i]) % p;
	cin>>T;//T 组数据
	while(T--){
		cin>>n>>m;
		cout<<Lucas(n+m,n)<<endl;//输出
	}
}
```


---

## 作者：周子衡 (赞：2)

思路：数学

首先简化一下题意：求$N$个非负整数和小于等于$M$的方案数，对$19491001$取模

先考虑下面一种情况：$N$个数和恰等于$M$

这种情况下，相当于把$M$个1分给$N$个人，每个人可能不拿也可能拿多个，求方案数

当然，不拿的情况比较难处理，所以我们可以给每个数加上1，总和加上$N$，也就是转化成把$N+M$个1分给$N$人，每人至少$1$个的方案数

我们可以理解成把$N+M$个1分为$N$块，那么需要$N-1$块“挡板”，而一共有$N+M-1$个地方可以插“挡板”，每个地方最多插一块，“挡板”无差别，那么答案显然是$C_{N+M-1}^{N-1}$

而原题要求$N$个数和小于等于$M$即可，答案显然为

$\sum_{i=0}^{M}C_{N+i-1}^{N-1}$

发现：

$\sum_{i=0}^{M}C_{N+i-1}^{N-1}=C_{N+M}^{N}=C_{N+M}^M$

使用$Lucas$定理求出即可

代码：

```cpp
#include<cstdio>

using namespace std;

const int MOD=19491001;

long long fac[MOD+1]={};
void gf()
{
    fac[0]=1;
    for(int i=1;i<MOD;i++)
    {
        fac[i]=fac[i-1]*i%MOD;
    }
}

long long pw(long long a,long long n)
{
    a%=MOD;
    long long ans=1;
    while(n)
    {
        if(n&1)
        {
            ans=ans*a%MOD;
        }
        a=a*a%MOD;
        n/=2;
    }
    return ans;
}

long long C(long long n,long long k)
{
    if(k>n)
    {
        return 0;
    }
    return fac[n]*(pw(fac[k]*fac[n-k]%MOD,MOD-2))%MOD;
}

long long lucas(long long n,long long m)
{
    return m?lucas(n/MOD,m/MOD)%MOD*C(n%MOD,m%MOD)%MOD:1;
}

int main()
{
    int t=0;
    scanf("%d",&t);
    gf();
    long long n=0,m=0;
    while(t--)
    {
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",lucas(n+m,m));
    }
    return 0;
}
```

---

## 作者：lamboo (赞：1)

问题转化为求$a_1+a_2+\cdots+a_n\leq m$，其中$a_i\in N$

由于$a_i$可以取0比较难求，所以我们可以将$a_i$都加1。于是问题转化为：

$a_1+a_2+\cdots+a_n\leq m+n$，其中$a_i\in N_+$

这是一个比较经典的组合问题。**我们可以将$m+n$看做$m+n$个小球，可以在两个小球之间和最后一个小球之后放上隔板**。于是，问题有被转化为了：

有$n+m$个空格，在每个空格上可以放至多1个隔板，求放$n$个隔板的方案数。这显然是一个组合问题。答案就是$C_{n+m}^n$

由于$n,m$比较大，但是模数比较小，且应该是质数~~（我并没有验证过，如果不是质数也太**毒瘤**了吧）~~。所以，我们可以套上一个卢卡斯定理模板。

代码写起来也比较方便。

```cpp
#include <bits/stdc++.h>
#define p 19491001
using namespace std;
long long f[p],inv[p];
inline long long C(long long m,long long n)
{
    if (n<m) return 0;
    if (m>=p || n>=p) return C(m/p,n/p)*C(m%p,n%p)%p;
    if (m==0 || n==0) return 1;
    return f[n]*inv[m]%p*inv[n-m]%p;
}
inline long long read()
{
    long long x=0;
    char ch=getchar();
    while (ch<'0' || '9'<ch) ch=getchar();
    while ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
inline void write(long long x)
{
    if (x>9) write(x/10);
    putchar(x%10+'0');
}
int main()
{
    int T=read();
    f[0]=inv[0]=f[1]=inv[1]=1;
    for (int i=2;i<=p;i++) f[i]=f[i-1]*i%p;
    for (int i=2;i<=p;i++) inv[i]=(p-p/i)*inv[p%i]%p;
    for (int i=2;i<=p;i++) inv[i]=inv[i-1]*inv[i]%p;
    while (T--)
    {
        long long n=read();
        long long m=read();
        write(C(n,m+n));putchar('\n');
    }
    return 0;
}
```

---

## 作者：peterwuyihong (赞：1)

题意：$n$ 个有标号自然数加起来 $\le m$，问方案数。$n,m\le 10^{18},T\le 10^5$。

考虑出一个隔板法，如果 $n$ 个有标号自然数加起来 $= m$，那么把自然数变成正整数，$m$ 变成 $m+n$，然后就是 $\dbinom{n+m-1}{n-1}$。

使用平行求和法则，所以答案就是

$$\sum_{o=0}^m\binom{n+o-1}{o}=\binom{n+m}m$$

然而这么做并不够有意思，考虑到题解区没有，我们就来点有意思的。

考虑出一个母函数，对每个数它可以选任意次，于是母函数就是 $1+x+x^2+\ldots=\dfrac{1}{1-x}$，把 $n$ 个这玩意儿乘起来，$[x^m]$ 项就是加起来等于 $m$ 的答案，我们对这个东西求一个前缀和，就是给它乘上一个 $\dfrac{1}{1-x}$，它的第 $[x^m]$ 项就表示真正的答案了。

至于 $[x^m]\dfrac 1 {(1-x)^{n+1}}$，[老经典玩意儿了](https://oi-wiki.org/math/gen-func/ogf/#_2)，等于 $\dbinom {n+m}m$。

不管怎么说，求答案的过程都是一样的卢卡斯，$O(p+T\log n)$。

现在是 $16:38$，我看我什么时候写完。

现在是 $16:53$，我写完了。

```cpp
#define maxn 19491002
const int p=19491001;
template<class _Tp,class _tp>void add(_Tp&x,const _tp& y){((x+=y)>=p)&&(x-=p);}template<class _Tp,class _tp>_Tp Add(_Tp x,const _tp y){add(x,y);return x;}
template<class _Tp,class _tp>void sub(_Tp&x,const _tp&y){((x-=y)<0)&&(x+=p);}template<class _Tp,class _tp>_Tp Sub(_Tp x,const _tp y){sub(x,y);return x;}
template<class _Tp,class _tp>void mul(_Tp&x,const _tp&y){x=1ll*x*y%p;}template<class _Tp,class _tp>_Tp Mul(const _Tp x,const _tp y){return 1ll*x*y%p;}
template<class _Tp,class _tp>_Tp ksm(_Tp a,_tp b){_Tp ans(1);for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;} 
template<class _Tp>_Tp div2(_Tp a){if(a&1)a+=p;return a>>1;}
int inv[maxn],jc[maxn],jcinv[maxn];
void init(int n){
	for(int i=0;i<2;i++)inv[i]=jc[i]=jcinv[i]=1;
	for(int i=2;i<=n;i++)inv[i]=Mul(p-p/i,inv[p%i]),jc[i]=Mul(jc[i-1],i),jcinv[i]=Mul(jcinv[i-1],inv[i]);
}
int _C(int n,int m){if(n<m)return 0;return Mul(jc[n],Mul(jcinv[m],jcinv[n-m]));}
template<class _Tp,class _tp>_Tp C(_Tp n,_tp m){if(!m)return 1;return Mul(_C(n%p,m%p),C(n/p,m/p));}
int T;
long long n[100000],m[100000];
signed main(){
#ifndef ONLINE_JUDGE
	freopen("testdata.in","r",stdin);
#endif
	bool flg=1;
	cin>>T;for(int i=0;i<T;i++)cin>>n[i]>>m[i],flg&=n[i]+m[i]<=2000;
	if(flg)init(2000);
	else init(19491000);
	for(int i=0;i<T;i++)cout<<C(n[i]+m[i],m[i])<<endl;
#ifndef ONLINE_JUDGE
	cerr<<endl<<(double)clock()/CLOCKS_PER_SEC;
#endif
}
```


---

## 作者：King_of_gamers (赞：1)

#### 其实不难发现，这道题跟我们小学奥数中的一个问题类似：有n个糖果分给m个人，每个人可以不分到。

我们就可以把这题中的每个a看成是人，把m看成糖果数，这样问题就可以完美转化。

然后我们就知道了这题的答案应该是$C(n,n+m)$,常规求组合数的方法是O(n)的，显然过不去，于是我们就要借助卢卡斯定理（不熟悉的童鞋可以先去做一下卢卡斯模板），这样就可以在$O(19491001+t)$的时间内解决了(假装这题里卢卡斯$O(1)$出解)。

顺便赞一个出题人因为19491001是质数，没有让我们再去毒瘤一下拓展卢卡斯。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,p,II[20000005];
int t;
long long ksm(long long a,long long b)
//快速幂模板,名字取了首字母有点low
{
	int tmp=1;
	for (;b>0;b=b>>1)
	{
		if (b & 1==1) tmp=tmp*a%p;
		a=a*a%p;
	}
	return tmp;
}
long long c(long long a,long long b)
//求组合数C(a,b)即b的阶乘/(a的阶乘*b的阶乘)
{
    if (a>b) return 0;
    return II[b]*ksm(II[a],p-2)%p*ksm(II[b-a],p-2)%p;
    //II是我们预处理完的阶乘。
}
long long work(long long a,long long b)//work函数即卢卡斯过程
{
    if ((a<p)&&(b<p)) return c(a,b);
    else return work(a/p,b/p)*c(a%p,b%p)%p;
}
int main()
{
    p=19491001;
    II[0]=1;
    for (int i=1;i<=p;i++) II[i]=II[i-1]*i%p;//预处理阶乘
    scanf("%d",&t);
    while (t>0)
    {
        t--;
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",work(n,n+m));
    }
}
```

---

## 作者：JustinRochester (赞：1)

看到除了出题人还没人发题解，赶紧发一篇“公(xiā)式(jī)归(bā)纳(luàn)法(cāi)” ~~2333333~~

来自某 AFO 且数学学完数学归纳法的蒟蒻

---

**【分析】**
--

这里，如果直接看得出是排列数的大佬可以不用费时间了，因为本蒟蒻看不出来，就说说看不出来怎么破

我们可以根据题目，得到，它相当于是求一个** $n$ 个总和不大于 $m$ 的自然数**的方案数

如果会 dp 的大犇们这里可以列出一个转移方程了：

$dp_{n,m}$ 表示用 $n$ 个数合成了**总和为 $m$ **的方案总数

$\therefore dp_{n,m}=\sum_{i=0}^m dp_{n-1,i}$

而答案为不超过 $m$ 的，即为 $\sum_{i=0}^mdp_{n,i}$

根据 dp 转移方程的定义，我们可以推出答案其实就是 $dp_{n+1,m}$

当然，你很快就会发现， dp 的复杂度连 $30\%$ 的暴力分都拿不到......

那我们来看一下数据范围，应该是对于每次询问都要 $O(1)$ 或者 $O(\log n),O(\log m)$ 出答案的，那应该就需要分治之类的或者推公式

我们来考虑一下：

1.当 $n=0$ 时，当且仅当 $m$ 为 $0$ 时 $dp_{n,m}=1$，否则 $dp_{n,m}=0$

2.当 $n=1$ 时， $dp_{n,m}=\sum_{i=0}^mdp_{n-1,i}=1+0=1$

3.当 $n=2$ 时， $dp_{n,m}=\sum_{i=0}^mdp_{n-1,i}=\sum_{i=0}^m1=(m+1)$

4.当 $n=3$ 时， $dp_{n,m}$

$=\sum_{i=0}^mdp_{n-1,i}$

$=\sum_{i=0}^m(i+1)$

$=\sum_{i=1}^{m+1}i$

$={(m+1)(m+2) \over 2}$

5.当 $n=4$ 时， $dp_{n,m}$

$=\sum_{i=0}^mdp_{n-1,i}$

$=\sum_{i=0}^m{(i+1)(i+2) \over 2}$

$=\sum_{i=0}^m({1 \over 2}i^2+{3\over2}i+1)$

$={1\over6}\sum_{i=0}^m(3i^2+3i)+\sum_{i=0}^m(i+1)$

$\because (i+1)^3-i^3=3i^2+3i+1$

$\therefore \sum_{i=0}^m(3i^2+3i)$

$=\sum_{i=0}^m[(i+1)^3-i^3-1]$

$=(m+1)^3-0^3-(m+1)$

$\therefore dp_{n,m}={(m+1)^3-(m+1)\over 6}+{3(m+1)(m+2)\over6}$

$={(m+1)\over 6}[(m+1)^2-1+3(m+2)]$

$={(m+1)\over6}(m^2+5m+6)$

$={(m+1)(m+2)(m+3)\over 6}$

其实，到这里，眼尖的小伙伴已经看出来了，除了 $n=0$ 的情况(其实也包括在内，小伙伴们可以想想为什么)，分式的下面为 $(n-1)!$ ，上面是 $(m+1)(m+2)(m+3)...(m+n-1)$

$\because (m+1)(m+2)(m+3)...(m+n-1)={(m+n-1)!\over m!}$

$\therefore dp_{n,m}={1\over (n-1)!}\times{(m+n-1)!\over m!}=C_{m+n-1}^m$

因此，答案为 $dp_{n+1,m}=C_{m+n}^m$

对答案仍有疑意的小伙伴，可以用数学归纳法证一下，这里就不浪费篇幅证明了，应该是挺显然的

---

如果我们是数学竞赛，直接输出 $C_{m+n}^m\%p,p=19491001$ 即可

不过很可惜，我们不是

我们得考虑如何化简，根据 $Lucas$ 定理，显然有

$C_{m+n}^m\%p=C_{(m+n)\%p}^{m\%p}\times C_{\lfloor{m+n\over p}\rfloor}^{\lfloor{m\over p}\rfloor}\%p$，直接递归求解即可

而对于 $n,m<p$ 范围内的 $C_n^m$ (注意跟上面不一样)

我们可以预处理 $0$~$(p-1)$ 范围内的所有阶乘 ($Frac_i$) 和它们的逆元 $Afrc_i$

那么，当 $n<m$ 时直接特判 $0$ ；当 $n\geq m$ 时，$C_n^m=Frac_n\times Afrc_m \times Afrac_{(n-m)}$ ，记得要防溢出

预处理也是很简单的，我们对于 $0$ 的特判，其他的我们一遍扫过去： $Frac_i=Frac_{i-1}\times i\%p$

而求逆元，我们只要求 $Afrc_{(p-1)}$ 即可，剩下的也是一遍扫过去： $Afrc_i=Afrc_{(i+1)}\times(i+1)\%p$

```cpp
	int &me=LRJ;
    me->"想一想，为什么？";
```

---

**【代码】**
--

那本蒟蒻就放 ~~我码风极丑的~~ 代码了：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
const int Mod=19491001;
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return neg?-ans:ans;
}//条件反射的结果
ll ar_d_Frac[Mod],ar_d_Afrc[Mod];
void exgcd(int a,int b,ll &x,ll &y){
	if(b==0){ x=1; y=0; return ; }
	exgcd(b,a%b,x,y);
	ll tmp=x;
	x=y;
	y=tmp-a/b*y;
}
inline ll ny(int a){
	ll x,y;
	exgcd(a,Mod,x,y);
	return (x%Mod+Mod)%Mod;
}
inline void pre(){
	ar_d_Frac[0]=ar_d_Frac[1]=ar_d_Afrc[0]=ar_d_Afrc[1]=1;
	f(i,2,19491000) ar_d_Frac[i]=ar_d_Frac[i-1]*i%Mod;
	ar_d_Afrc[19491000]=ny(ar_d_Frac[19491000]);
	g(i,19490999,2) ar_d_Afrc[i]=ar_d_Afrc[i+1]*(i+1)%Mod;
}
inline int c(int n,int m){
	if(n<m) return 0;
	return ar_d_Frac[n]*ar_d_Afrc[m]%Mod*ar_d_Afrc[n-m]%Mod;
}
int lucas(ll n,ll m){
	ll ans=1;
	while(n&&m&&ans){
    	//ans==0时不论乘什么都不会变了，没必要算下去
		ans*=c(n%Mod,m%Mod);
		ans%=Mod;
		n/=Mod;
		m/=Mod;
	}
	return ans;
}
int main(){
	pre();
	int d_T=read();
	while(d_T--){
		ll d_N=read(),d_M=read();
		printf("%d\n",lucas(d_N+d_M,d_M));
	}
	return 0;
}
```

---

## 作者：Cheng_yf (赞：1)

理解代码得：

一个长为m的区间，分成n个连续区间（长度可以为0），有多少种方案，答案对19491001取模。

根据小学讲过的玄学定理("隔板法","补苹果法")得到答案为C(n+m,n)

因为n,m≤10^18,1≤T≤100,000,mod=19491001(质数)

所以要用lucas定理完成

[lucas定理](https://www.luogu.org/blog/1-2-3-4-5-6-7-8-9-0/lucas-ding-li)

code：

```cpp
#include<bits/stdc++.h>
#define mod 19491001
#define ll long long
using namespace std;
ll power(ll n,ll x){
    ll sp=1LL;
    while(x){
        if(x&1LL) sp=(sp*n)%mod;
        n=(n*n)%mod;
        x>>=1LL;
    }
    return sp;
}
ll fact[mod+5],inv[mod+5];
void init(){
    fact[0]=1LL;
    for(int i=1;i<mod;i++)
    fact[i]=fact[i-1]*i%mod;
    inv[mod-1]=power(fact[mod-1],mod-2);
    for(int i=mod-2;i>=0;i--)
    inv[i]=inv[i+1]*(i+1)%mod;	
}
ll C(ll n,ll m){
    return fact[n]*inv[n-m]%mod*inv[m]%mod;
} 
ll lucas(ll n,ll m){
    if(n<m) return 0;
    if(n<mod) return C(n,m);
    return lucas(n/mod,m/mod)*lucas(n%mod,m%mod)%mod;
}
ll n,m;
ll t;
int main(){
	init();
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",lucas(m+n,n));	
    }
    return 0;
}
```

---

## 作者：Catalan1906 (赞：0)

我们看这段代码
```
int cnt = 0;
for (int a_1 = 0; a_1 <= m; a_1++) {
    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {
    ...
        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {
            cnt = (cnt + 1) % 19491001;
        }
    }
}
printf("%d\n", cnt);
```

其实是可以改写为
```
int cnt = 0;
for (int a_1 = 1; a_1 <= m + n; a_1++) {
    for (int a_2 = 1; a_1 + a_2 <= m + n; a_2++) {
    ...
        for (int a_n = 1; a_1 + a_2 + ... + a_n <= m + n; a_n++) {
            cnt = (cnt + 1) % 19491001;
        }
    }
}
printf("%d\n", cnt);
```
答案不变（就是把$a_0, a_1, ... , a_n$全部加了1，源代码里相应的$m$要增加$n$，因为n个循环变量，每个变量都增加了1，所需增加即为$n \times 1 = n$）

然后根据组合数学中组合数的定义，所求为C(m + n, n)

由于数特~别~大~，而且`19491001`是质数，所以这里使用了[Lucas定理](https://www.luogu.org/problemnew/show/P3807)

哦对了还要用[乘法逆元的线性求法](https://www.luogu.org/problemnew/show/P3811)

下面代码
```
#include <bits/stdc++.h>
#define int long long
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")

using namespace std;

const int maxn = 20000000;
const int p = 19491001LL;
int n, inv[maxn], m, js[maxn];

int Lucas(int n, int m)
{
    if(n < m)return 0LL;
    if(n < p)return js[n] * inv[m] % p * inv[n - m] % p;
    return Lucas(n % p, m % p) * Lucas(n / p, m / p) % p;
}

signed main()
{
    int t;
    scanf("%lld", &t);
    js[0] = 1LL;
    for(register int i = 1LL; i <= p; i++)js[i] = js[i - 1] * i % p;
    inv[1] = 1LL; inv[0] = 1LL;
    for(register int i = 2LL; i <= p; i++)inv[i] = (p - p / i) * inv[p % i] % p;
    for(register int i = 2LL; i <= p; i++)inv[i] = inv[i] * inv[i - 1] % p;
    while(t--)
    {
        scanf("%lld%lld", &n, &m);
        printf("%lld\n", Lucas(n + m, m));
    }
    return 0;
}
```

~~三年OI一场空，不开long long见祖宗~~

---

## 作者：newbiechd (赞：0)

# WD与循环

[LG传送门](https://www.luogu.org/problemnew/show/P5160)

日常打[广告](https://www.cnblogs.com/cj-chd/p/10448339.html)

为什么大家都是先算$n$个数的和等于$m$的情况再求前缀和？

既然已经想到了插板法，为什么不直接对$n$个数的和$\le m$的情况做呢？

基本套路没有变：考虑对于$n$个非负整数，先变成$n$个正整数，求和$\le m + n$的情况。**下面是不同的地方**：在$m + n$个小球之间插入$n$块板子，具体地说，在每个球的右边可以插入一块板子，对于从左往右数第$i$块板子，它到第$i - 1$块板子或者左端点之间的小球数就是第$i$个数，对于最右边的一块板子，它左边的板子数即没有被分到任何一个数中的小球个数一定$\ge 0$，这正好对应了我们$\le m + n$的条件。得到式子$\binom {n + m} {n}$，lucas定理即可。

~~yyb是我们的红太阳，%yyb有益身心健康~~

```cpp
//written by newbiechd
#include <cstdio>
#include <cctype>
#define R register
#define I inline
#define B 1000000
#define L long long
using namespace std;
const int yyb = 19491001;
char buf[B], *p1, *p2;
I char gc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, B, stdin), p1 == p2) ? EOF : *p1++; }
I L rd() {
    L f = 0;
    R char c = gc();
    while (c < 48 || c > 57)
        c = gc();
    while (c > 47 && c < 58)
        f = f * 10 + (c ^ 48), c = gc();
    return f;
}
L a[yyb];
I L pow(L x, L y) {
    L r = 1;
    for (x %= yyb; y; y >>= 1, x = x * x % yyb)
        if (y & 1)
            r = r * x % yyb;
    return r;
}
I L com(L n, L m) {
    if (m > n)
        return 0;
    return a[n] * pow(a[m], yyb - 2) % yyb * pow(a[n - m], yyb - 2) % yyb;
}
L lucas(L n, L m) {
    if (!m)
        return 1;
    return com(n % yyb, m % yyb) * lucas(n / yyb, m / yyb) % yyb;
}
int main() {
    R int T = rd(), i;
    L n, m;
    a[0] = 1;
    for (i = 1; i < yyb; ++i)
        a[i] = a[i - 1] * i % yyb;
    for (i = 1; i <= T; ++i)
        n = rd(), m = rd(), printf("%lld\n", lucas(n + m, n));
    return 0;
}

```





---

## 作者：chenlingxi (赞：0)

## 吐槽部分

### 表示昨天比赛真心毒瘤~~QAQ~~

------------

## 正文部分

首先说一句，身为一个被LJC00118吊打的人，我不会写任何有关数论证明的东西，只是讲讲做数论题的思路。

~~因为我相信总会有人把证明过程放上来的~~

先看题面

```cpp
int cnt = 0;
for (int a_1 = 0; a_1 <= m; a_1++) {
    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {
    ...
        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {
            cnt = (cnt + 1) % 19491001;
        }
    }
}
printf("%d\n", cnt);
```
这么多重循环，很明显不能直接递推，而且暗示是一道数论题~~这不废话吗~~

看一下样例

输入：

$2$

$2$ $9$

$10$ $14$

输出：
$55$

$1961256$

先看小的

自己手推一下

先是a_1=0，然后a_2有0~9十种可能

然后是a_1=1，九种

……

最后结果是10+9+8+7+……1=55

然后有种组合数的感觉吧~~万恶的小学数学老师~~

显然，$C_{9}^{2}$=$36$，那么它们之间有什么关系呢

刚才算的是$C_{n}^{m}$，那么现在算下$C_{n+m}^{n}$

试着把公式换成$C_{9+2}^{2}$，然后算出来结果是55

刚好！

那么再拿稍大一点的样例测测看

$C_{10+14}^{10}$=1961256，即为第二行样例的结果。

但显然直接杨辉三角递推妥妥T飞为止

~~还好最近智推给了Lucas模板，而且我还打了~~

[P3807链接](https://www.luogu.org/problemnew/show/P3807)

lucas定理具体证明不讲了，你们自己看里面的题解就好。

只要知道它能用来优化单个组合数的计算速度就行了

然后记得把里面在线处理的逆元和阶乘预处理掉。

解释一下：因为模板里面的模数是在线输入的，因此阶乘和逆元的值可能会改变

~~不然还是妥妥T飞~~

本题源码
```cpp
#include<cstdio>
#define int long long
using namespace std;
long long a[19491002];
long long inv[19491002];
const int mod=19491001;
long long C(int n,int m)
{
	if(m>n)return 0;
	return (a[n]%mod*inv[a[m]]%mod*inv[a[n-m]]%mod);
}
long long L(int n,int m)
{
	if(!m)return 1;
	return C(n%mod,m%mod)*L(n/mod,m/mod)%mod;
}
signed main()
{
	int t;
	scanf("%lld",&t);
	a[0]=1;inv[1]=1;
	for(register int j=1;j<=19491001;++j)a[j]=(a[j-1]*j)%mod;
	for(register int i=2;i<=19491001;++i)inv[i]=(long long)((mod-mod/i)*inv[mod%i])%mod;
	for(register int i=1;i<=t;++i)
	{
		register int n,m;
		scanf("%lld%lld",&n,&m);
		printf("%lld\n",L(n+m,n));
	}
}
```
不要在意那个define。

~~这只是因为我打Lucas怕炸数据范围又不想一个个改的结果~~

期待标准证明

------------

## 后记

给一个建议

~~仅适用于洛谷比赛~~

关注一下别人的编译信息

比如这种

![昨天T1](https://cdn.luogu.com.cn/upload/pic/47615.png)

~~水印遮住的是printf,后面的f能看到就行了~~

然后我就快速幂水过了

---

## 作者：muller (赞：0)

楼上说的很好

这道题我们把它转换为组合数形式

就是n个盒子m个球

用一下C(n,m)

但是p不够大

所以用一下卢卡斯既可

然后就会觉得代码非常短

其实这题也可以找规律的

就是要变成组合数

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll P = 19491001;
ll n, m, Pow[P];
template <class T> void rd(T &x) {
    char c = getchar(); int f = 1; x = 0;
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    x *= f;
}
ll qpow(ll a, ll b) {
    if (!b) return 1;
    ll c = qpow(a, b / 2); c = (c * c) % P;
    if (b % 2) c = (c * a) % P;
    return c;
}
ll C(ll n, ll m) {
    if (m > n) return 0;
    return Pow[n] * qpow(Pow[n - m], P - 2) % P * qpow(Pow[m], P - 2) % P;
}
ll lucas(ll n, ll m) {
    if (!m) return 1;
    return C(n % P, m % P) * lucas(n / P, m / P) % P;
}
int main() {
    int i, Q; rd(Q); Pow[0] = 1;
    for (i = 1; i < P; ++i) Pow[i] = (Pow[i - 1] * i) % P;
    while (Q--) {
        int i; rd(n); rd(m);
        printf("%lld\n", lucas(n + m, m));
    }
    return 0;
}

```


---

## 作者：ezoixx130 (赞：0)

### 题意：

有一个数列 $a_1,a_2,a_3,...,a_n$，其中每个数都是自然数，问有多少种方案使得它们的和不超过 $m$，答案对 $19491001$ 取模。

### 题解：

题目是求和不超过 $m$ 的方案数，这个有点难处理，我们考虑求出和等于 $i$ 的方案数，再累加起来。

那么这就转化为了一个经典问题：$n$ 个数的和等于 $m$ 的方案数，考虑插板法解决，和为 $m$ 相当于 $m$ 个球，$m-1$ 个空位，$n$ 个数相当于 $n-1$ 个板，那么答案就是 $m-1 \choose n-1$。

但是这样考虑的话是 $n$ 个正整数的和等于 $m$ 的方案数，如何将自然数变为正整数呢？

每个数都加一即可，问题变为 $n$ 个正整数的和等于 $m+n$ 的方案数，答案为 $m+n-1 \choose n-1$。

于是题目要求的答案是 $\sum\limits_{i=0}^{m}{i+n-1 \choose n-1}$

然后由于 $\sum\limits_{k=0}^{n}{m+k \choose k}={m+n+1 \choose n}$。

所以答案就是 $\sum\limits_{i=0}^{m}{i+n-1 \choose n-1}={n+m \choose m}$。

然而这需要支持 $10^{18}$ 以内的组合数计算，发现模数很小，预处理模数以内的阶乘以及阶乘逆元，使用 lucas 定理即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define mod 19491001

int fac[mod+1],inv[mod+1];

int qpow(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)res=(long long)res*a%mod;
        a=(long long)a*a%mod;
        b>>=1;
    }
    return res;
}

void init()
{
    fac[0]=fac[1]=1;
    for(int i=2;i<mod;++i)fac[i]=(long long)fac[i-1]*i%mod;
    inv[0]=1;
    inv[mod-1]=qpow(fac[mod-1],mod-2);
    for(int i=mod-2;i>=1;--i)inv[i]=(long long)inv[i+1]*(i+1)%mod;
}

int c(int n,int m)
{
    if(n>m)return 0;
    else return (long long)fac[m]*inv[n]%mod*inv[m-n]%mod;
}

int lucas(long long n,long long m)
{
    if(n<mod && m<mod)return c(n,m);
    else return (long long)lucas(n/mod,m/mod)*lucas(n%mod,m%mod)%mod;
}

int main()
{
    init();
    int T;
    scanf("%d",&T);
    while(T--)
    {
        long long n,m;
        scanf("%lld%lld",&n,&m);
        printf("%d\n",lucas(n,n+m));
    }
}
```

---


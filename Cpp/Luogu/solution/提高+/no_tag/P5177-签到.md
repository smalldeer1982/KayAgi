# 签到

## 题目背景

题解：https://blog.csdn.net/kkkksc03/article/details/85008142

## 题目描述

求$\sum_{i=1}^n \sum_{j=1}^n i \  xor \ j \in [\min(i,j),\max(i,j)]$

由于答案可能过大，输出答案对$10^9+7$取模的值。

## 说明/提示

第一组样例解释：

符合题意的$(i,j)$有$20$对。
```
i=1  j=3  i^j=2
i=1  j=5  i^j=4
i=1  j=7  i^j=6
i=1  j=9  i^j=8
i=2  j=6  i^j=4
i=2  j=7  i^j=5
i=2  j=10  i^j=8
i=3  j=1  i^j=2
i=3  j=6  i^j=5
i=3  j=7  i^j=4
i=3  j=10  i^j=9
i=5  j=1  i^j=4
i=6  j=2  i^j=4
i=6  j=3  i^j=5
i=7  j=1  i^j=6
i=7  j=2  i^j=5
i=7  j=3  i^j=4
i=9  j=1  i^j=8
i=10  j=2  i^j=8
i=10  j=3  i^j=9
```

对于27%的数据，$T\le 5, n \le 1000$。

对于54%的数据，$T\le 20, n \le 5 \times 10^5$。

对于90%的数据，$T\le 10^5, n \le 10^{18}$。

最后一个点，$T=3\times 10^6 \ ,\  n\le 10^{18}$。

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
20
2634
325502```

# 题解

## 作者：Eric1031 (赞：6)

对大佬的代码表示无限懵逼……

这道题目思维有点毒瘤，因为logn都会超时，从头讲吧。

对两个数i，j不妨设i>j，令h=i^j，则j最高位不能为i的最高位，否则h<j,当满足这一条件时,h一定大于j,其次，要让h<i,那么（经过多次尝试）只要对i第二1处，j在此取最高位，后面随便取，我们神奇地发现，它代表的正好是该位代表的数字，同理对第3，第4……

于是，一个数代表的就是它减去最高位！

然后，就好办了……
```
#include<bits/stdc++.h>
using namespace std;
long long q[101],n,b[101],sum,bit;
int t,l;
const long long mod=1000000007,inv=500000004;
long long num(long long x)
{
    long long h=(((((x+1)%mod)*x)%mod)*inv)%mod;
    return h;
}//等差数列求和
int main()
{
    b[1]=1;
     for(int i=2;i<64;i++)
     { 
        b[i]=b[i-1]<<1;
        q[i]=num(((1ll<<(i-1))-1)%mod);
        q[i]=(q[i]+q[i-1])%mod;//求2^i的情况数
    }
    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld",&n);
        for(bit=63;bit>=1;bit--)
        { 
            if(n>b[bit])break;
        }//倒着求，不然会T
        n-=(1ll<<(bit-1)); 
        sum=q[bit-1];
        sum=(sum+num(n%mod))%mod;
        sum=(sum*2)%mod;
        printf("%lld\n",sum);
    }
}
```

---

## 作者：da32s1da (赞：6)

### T5:签到题
#### 思考难度：提高-?
#### 代码难度：普及?
算法1：暴力

实际得分：27

算法2：有技巧的暴力枚举

考虑枚举每一个$n$，然后对$\le n$的计数。

发现$n$的二进制第一个$1$不可放，然后第二个$1$如果放1，后面随便放，如果不放，那第三个$1$可放，后面随便放，......

所以对于一个$n$，可以放的就是删去第一个$1$后的值。

所以暴枚$n$即可。

实际得分54

算法3：

考虑预处理出$2^k$的答案。

对于$n=2^k+p\ (p<2^k)$，后$p$个等差数列求和，加上预处理的$2^k$答案即可。

复杂度$\ Tlog_2n$

实际得分90

算法4：

瓶颈在如何找到$k$，二分或者调用__builtin_clzll即可。

复杂度$\ T loglogn$

实际得分100

```
#include<cstdio>
typedef long long LL;
const int mod=1e9+7;
LL t,n,x,z,i;
LL _2[66],_3[66];
template<typename T>inline void rad(T&_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch>='0'&&ch<='9')_=_*10+ch-48;
}
template<typename T>inline void print(const T x){
    if(x>=10)print(x/10);
    putchar(x%10+'0');
}
int main(){
//	freopen("testdata11.in","r",stdin);
//	freopen("testdata11.out","w",stdout);
    for(_2[0]=1,i=1;i<=65;++i)_2[i]=(_2[i-1]<<1)%mod;
    for(_3[1]=1,i=2;i<=65;++i)_3[i]=(_3[i-1]<<2|1)%mod;
    for(i=1;i<=65;++i)_3[i]=_2[i-1]*(_2[i]-1)-_3[i];
    for(i=1;i<=65;++i)_3[i]=(_3[i]<<1)%mod;
    for(rad(t);t;--t){
        rad(n);
        
        if(n>>47){
            float q=(float)(n>>46);
    		x=47+((*(int*)&q)>>23&31);
        }else if(n>>24){
            float q=(float)(n>>23);
            x=24+((*(int*)&q)>>23&31);
        }else if(n>>1){
            float q=(float)n;
            x=1+((*(int*)&q)>>23&31);
        }else x=0;
        
        z=(n-_2[x])%mod;
        print((_3[x]+z*(z+1))%mod);
        putchar('\n');
    }
}
```

---

## 作者：qian_shang (赞：2)

## [题目](https://www.luogu.com.cn/problem/P5177)

- **这题显然可以$O(n^2)$暴力枚举，期望得分$27$**

### 考虑优化，先观察柿子

- 发现当$i=j$时$i\ xor\ j$为零一定不满足条件。
- 所以可以假设$i<j$，最后答案乘二就可以了。
- 对于每一个$j$，合法的个数是$j-j\ and\ (-j)$。
- 考虑如何证明，先设$low$为二进制下的最高位,对于每一个$0\leq i<low$，显然$i\ xor\ j \geq low>i$，那最小边界已经考虑好了。
- 进一步的，对于$\ j\ $中$\ low\ $后面的第$k$位$1$,有两种情况，选$1$或不选$1$。若选择，那么之后的每一位都可以任意选，有$2^k$种答案。若不选，则考虑$j$之后的那一位$1$，所以对于$j$的每一位$low$后面的$1\ $，都有$2^k$个$i$,于是$i$的总数为$j-j\ and\ (-j)$
- **知道这一步就可以$O(Tn)$过掉$54$分了**

### 知道了上面的结论后就好做许多了

- 对于$n$，还是先使$low=n\ and\ (-n)$,对于$low\leq j \leq n$，这一部分の贡献是$\sum_{i=1}^n\ i$，可用高斯求和$O(1)$计算。
- 对于后面的每一位，可以预处理$2^n$的前缀和，详细看代码
- 因为$low$的位数不太好直接求，垃圾的我就写了个二分QAQ
- **时间复杂度$O(6T)$**


------------
```cpp
#include<bits/stdc++.h>
#define N 64
#define R register
#define LL long long
#define inf 0x7f7f
using namespace std;
inline LL read(){
	LL x=0,sum=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')sum=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*sum;
}//题目读入有点大人傻常数大的窝选择了快读。
const LL mo=1e9+7;
inline LL maxx(LL A,LL B){return A>B?A:B;}
inline LL minn(LL A,LL B){return A<B?A:B;}
inline LL abss(LL A){return A<0?-A:A;}
LL T,n,ans,low,tow[N],sum[N];
inline LL find(LL x){
	LL l=0,r=63,ans,mid;
	while (l<=r){
		mid=(l+r)>>1;
		if (tow[mid]<=x) ans=mid,l=mid+1;
			else r=mid-1;
	}
	return ans;
}//寻找low是第几位。
int main(){
	T=read();
	tow[0]=1; sum[1]=0;//初始化
	for (R int i=1;i<=63;++i){
		tow[i]=tow[i-1]*2;	
		LL j=(tow[i]-1)%mo;
		sum[i+1]=(sum[i]+j*(j+1)/2)%mo;
	}//sum是方案数的前缀和。
	while (T--){
		n=read();
		low=find(n); n=(n-tow[low])%mo;
		ans=(2*sum[low]+n*(n+1)%mo)%mo;//如上所说的那样。
		printf("%lld",ans);putchar('\n');
	}
	return 0;
}
```


### PS:现目前因特殊原因只有$90$分，一个点$OLE$,望管理大大$Fix$一下


### 感谢tommy0103指出来的错误

---

## 作者：Super_Cube (赞：1)

# Solution

这题要真放签到的位置会给我整自闭的。

当 $i=j$ 时一定不满足条件，故假定 $i<j$ 便于计算，即最终答案为 $2\displaystyle\sum_{i=1}^n\sum_{j=i+1}^ni\oplus j\in[i,j]$。

此时若 $i$ 与 $j$ 的二进制下位数相同，说明最高位都为 $1$，异或后最高位变为 $0$ 一定不满足条件，于是除开这种情况一定有 $i\oplus j$ 不小于 $i$，只需要关注 $i\oplus j\le j$，所以要在 $j$ 除去最高位剩下的所有非零位中钦定出第一个 $i$ 对应位置上为 $1$，其前面的二进制位必须全为 $0$，后面没有限制可以乱填，最终得到每个 $j$ 对应的合法 $i$ 数量为 $j-2^{\operatorname{highbit}(j)}$，即答案为 $2\displaystyle\sum_{i=1}^ni-2^{\operatorname{highbit}(i)}$。

直接硬算的时间复杂度为 $O(Tn)$，很可惜无法通过。

参考代码如下（没取模也没开 `long long`）：

```cpp
#include<stdio.h>
int T,n,ans;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		ans=0;
		for(int i=1;i<=n;++i)
			ans+=i-(1<<31-__builtin_clz(i));
		ans<<=1;
		printf("%d\n",ans);
	}
	return 0;
}
```

看这个答案式子这么简洁，应该是可以 $O(1)$ 计算的。首先把 $i$ 与 $2^{\operatorname{highbit}(i)}$ 分开，$\sum i$ 是好算的，主要关注 $\sum2^{\operatorname{highbit}(i)}$，而这可以转化为 $\sum 2^i\sum[\operatorname{highbit}(j)=i]$。再以 $\operatorname{highbit}$ 是否为 $\operatorname{highbit}(n)$ 分成两段，不是的那段每个的个数都是满的，即 $\sum2^i(2^{i+1}-2^i)=\dfrac{4^{\operatorname{highbit}(n)}-1}{3}$；是的那段也很好算，为 $2^{\operatorname{highbit}(n)}(n-2^{\operatorname{highbit}(i)}+1)$。

于是最终答案为：$n(n+1)-\dfrac{2^{2\operatorname{highbit}(n)+1}-2}{3}-2^{\operatorname{highbit}(n)+1}(n-2^{\operatorname{highbit}(n)}+1)$。

---

## 作者：tommymio (赞：1)

这个 $\min(i,j),\max(i,j)$ 看上去很难受，不妨规定 $i<j$，由于 $i=j$ 时 $i\oplus j=0\notin[i,j]$，所以只需给规定 $i<j$ 的答案乘上 $2$ 即可。

现在考虑对于一个固定的 $j$ ，有多少个满足条件的 $i$。我们可以发现，当 $j$ 的最高位和 $i$ 相同，$i\oplus j<i,i\oplus j<j$，一定不在 $[i,j]$ 内。所以得到结论：若设 $i$ 的最高位为 $x$，则可能满足条件的 $j$ 一定满足 $j<2^x$。并且进一步的，若 $i$ 除去最高位的 $1$ 以外，第 $b_1,b_2,b_3...b_m$ 位上为 $1$，其中 $b_1<b_2<b_3...<b_m$，那么 $j$ 的最高位取了 $b_i$ 以后，第 $b_i-1\sim 0$ 位可以任意取，有 $2^{b_i}$ 种取法。则 $j$ 有 $\sum_{i=1}^m 2^b_i$ 种取值。记 $\mathrm{highbit(n)}$ 为十进制数 $n$ 在二进制意义下最高位的值及其之后的二进制位，如 $\mathrm{highbit(6)=4}$，那么对于一个 $i$，其合法取值 $j$ 有 $i-\mathrm{highbit(i)}$ 种。

答案就为 $\sum\limits_{i=1}^n i-\mathrm{highbit(i)}$。考虑怎么快速计算这个值，发现 $\mathrm{highbit(x)}$ 在 $x\in[2^i,2^{i+1}-1]$ 时，值都是 $2^i$，所以将 $\sum_{i=1}^n \mathrm{highbit(x)}$ 分段计算，得到：

$$
\sum_{i=0}^{\lfloor\log_2 n\rfloor-1}2^i\times2^i+2^{\lfloor\log_2 n\rfloor}\times(n-2^{\lfloor\log_2 n\rfloor}+1)
$$

其中和式中第一个 $2^i$ 为 $x\in [2^i,2^{i+1}-1] $ 的 $\mathrm{highbit(x)}$，第二个 $2^i$ 为 $[2^i,2^{i+1}-1]$ 这一段的长度。和式外的柿子是边界值，因为长度不再为 $2^{\lfloor\log_2 n\rfloor}$，必须拎出来处理。

这样大家应该就都会做了，$O(32767+\log n)$ 预处理出 $2$ 的 $i$ 次幂对 $10^9+7$ 取模的值 $(i\in [0,32767^2])$，以及等比数列时要用到的 $3$ 的逆元（事实上 $3$ 的逆元你可以用另一个程序跑出结果再直接记录，这样就少一个 $\log n$ 的预处理）。对于 $\mathrm{highbit(x)}$ 没有什么好的求法，只能从高到低枚举，或者调用 $\text{GNU Extension}$ 的 $\texttt{\_\_lg}$（$\text{NOIP}$ 别用），除去 $\mathrm{highbit}$ 的一个跑不满的 $\log$ 之外，询问的其他部分都是线性的。

时间复杂度为 $O(2^{16}+T\log n)$，但事实证明并跑不满（~~时间复杂度里为什么有常数，因为这个常数它很大啊~~

```cpp
#include<cstdio>
typedef long long ll;
const ll phimod=1e9+6;
const ll mod=1e9+7;
ll powf[(1<<16)+10],powg[(1<<16)+10];
inline ll read() {
	ll x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline ll pow(ll x) {return powg[x/32767]*powf[x%32767]%mod;}
inline ll pow(ll x,ll p) {ll res=1;for(;p;p>>=1) {if(p&1) res=res*x%mod; x=x*x%mod;} return res;}
int main() {
	int T=read(),inv3=pow(3,mod-2);
	powf[0]=powg[0]=1;
	for(register int i=1;i<=32767;++i) powf[i]=powf[i-1]*2ll%mod;
	for(register int i=1;i<=32767;++i) powg[i]=powg[i-1]*powf[32767]%mod;
	while(T--) {
		ll n=read(),lim=63;
		while(n>>lim&1^1) {--lim;}
		ll x1,x2=pow(lim); x1=x2*x2%mod; 
		ll ans=(n%mod)*((n+1)%mod)%mod*pow(mod-2)%mod-(x1-1)*inv3%mod-x2*((n-x2+1)%mod)%mod;
		ans=ans*2%mod; printf("%lld\n",(ans%mod+mod)%mod);
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：0)

可以发现，$a\not = b$。那么首先强制令$a< b$。反过来的情况乘$2$即可。

那么，观察可得:

$a$的最高位比$b$的最高位小，且该最高位被$b$包含。

这两个性质很容易得到。

那么，对于一个合法的$b$，对应合法的$a$的数量为$b-maxbit_b$。其中$maxbit_b$为$b$二进制位最高位。

那么，直接枚举这个最高位，然后减掉即可。注意输出量特别大，需要用快读。快读需要注意内存限制。

代码:
```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<20;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

void file(void)
{
    FILE*DSD=freopen("water.in","r",stdin);
    FILE*CSC=freopen("water.out","w",stdout);
}

static int _;

static ll n;

static int ans;

const int mod=1e9+7,div2=(mod+1)>>1;

static int cnt;

inline void work()
{
	read(n);
	ans=n%mod*((n+1)%mod)%mod*div2%mod;
	for(register ll k=1;k<=n;k<<=1)
		ans=(ans+mod-(uint64)k%mod*(min((n^k)+1,k)%mod)%mod)%mod;
	write(ans*2%mod);
	if(++cnt>=100000)cnt=0,flush();
}

int main()
{
    read(_);
    while(_--)work();
    flush();
    return 0;
}
```

---


# [COCI 2009/2010 #2] POSLOZI

## 题目背景

 **译自 [COCI 2009.11](http://hsin.hr/coci/archive/2009_2010/) T5「[POSLOZI](http://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)」**

给一个长度为 $N$ 的排列 $(1\le N\le 12)$。有 $M$ 种允许的修改方式 $(1\le M\le \frac{N\times (N-1)}{2})$，保证修改方式不重复，每种方式用 $L,$ $R$ 来表示，意为你可以将下标为 $L$ 的数与下标为 $R$ 的数交换。你可以修改该排列若干次，请给出一种修改方案，使原排列变为 $1,$ $2,$ $3,$ $\ldots,$ $N$。如果有多种方案，输出修改次数最少的方案。如果还有多种方案，输出任意一组即可。

## 样例 #1

### 输入

```
2 1
2 1
1 2```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3 2
2 1 3
1 3
2 3```

### 输出

```
3
2
1
2```

## 样例 #3

### 输入

```
5 5
1 2 3 4 5
1 5
2 5
1 4
1 1
3 5```

### 输出

```
0```

# 题解

## 作者：伟大的王夫子 (赞：6)

先看数据范围 $ n \le 12$，就差告诉我们就是一道搜索题了。否则，为什么不把数据范围扩大？

首先，个人认为这题广搜应该不太行。毕竟一个队列中的节点还需要记录许多信息，对于我而言，我认为十分麻烦。不过听说本题可以用 A* 过。
下面我介绍一种比较方便的方法 IDA*。

搜索算法的本身框架十分简单，这里便不多说了。主要讨论搜索的优化

剪枝一：不妨设刚刚使用的操作编号为 $i$，那么这一次搜索一定不能使用该操作。~~虽然这个剪枝可能优化效果不好，但是乱剪枝总比不剪好~~。

剪枝二：估价函数。我们不妨设当前排列与全排列对不上的个数为 $cnt$，那么估价函数明显可以设置为$\lceil{\dfrac{cnt}{2}} \rceil$。可惜的是，这个剪枝仍然不够强。那我们再进一步优化。我们设当前排列为 $a$，$d_{i,j}$ 为第 $i$ 个位置上的数与第 $j$ 个位置上的数交换位置最少需要的次数。其中，$d$ 数组可以提前用 floyd 算法求出。此时，我们便可以设 $\lceil \dfrac{\sum_{i = 1}^n d_{i,a_i}}{2} \rceil$ 为我们的估价函数。这个剪枝的效果相当之好。
也是 IDA* 的精华所在。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[13], b[170][2], depth, d[13][13];
vector<int> p, _p;
int h() {
	int cnt = 0;
	for (register int i = 1; i <= n; ++i) cnt += d[i][a[i]];
	return cnt;
}
bool dfs(int dep, int pre) {
	int k = h();
	if (!k) {
	   _p = p;
	   return 1;
	}
	if (2 * dep + k > 2 * depth) return 0;
	for (register int i = 1; i <= m; ++i)
		if (pre != i) {
			swap(a[b[i][0]], a[b[i][1]]);
			p.push_back(i);
			if (dfs(dep + 1, i)) return 1;
			p.pop_back();
			swap(a[b[i][0]], a[b[i][1]]);	
		}
	return 0;
}
int main() {
	scanf("%d%d", &n, &m);
	memset(d, 0x3f, sizeof d);
	for (register int i = 1; i <= n; ++i) scanf("%d", a + i), d[i][i] = 0;
	for (register int i = 1; i <= m; ++i) {
		scanf("%d%d", b[i], b[i] + 1);
		d[b[i][0]][b[i][1]] = d[b[i][1]][b[i][0]] = min(d[b[i][1]][b[i][0]], 1);
	}
	for (register int k = 1; k <= n; ++k)
		for (register int i = 1; i <= n; ++i)
			for (register int j = 1; j <= n; ++j)
				d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
	depth = 0;
	while (!dfs(0, -1) && depth <= 30) ++depth;
	if (depth == 31) puts("NEMA");
	else {
		printf("%d\n", depth);
		for (register int i = 0; i < _p.size(); ++i) printf("%d\n", _p[i]);
	}
}
```

---

## 作者：Rainy7 (赞：5)

- **前言**

  这题数据有那么点水（？）。


------------

- **分析**

  直接 IDA* 会被一些精心构造的数据卡掉，~~虽然这题没有~~，我们尝试换一种搜索方式。

  对交换方式建图，发现每次操作相当于交换两个相邻的点。

  考虑贪心，若一个点 $i$ 已经到达了他该在的位置，我们贪心的希望他不在移动，把他标记住。

  固定了第 $i$ 个点，就意味着其他点移动时候不能经过这个点。但这样可能会导致结果无解或者结果不是最优的情况。

  这意味着固定第 $i$ 个点前，一定要先固定另外若干个点。

  所以我们考虑暴力枚举每个点固定的顺序，按照这个顺序让每个点到他应该到的地方即可。这里显然跑最短路就行。

  这样上限是 $12!$ 的，但我们可以一边跑一边维护是否有解的情况，可以大力剪枝。
  
  然后加个 IDA* 就跑的飞快了。

  需要注意的是，对于每个点移动过程中，可能会出现多个最短路，此时每次优先跑第一个最短路即可。

  简单证明一下，对于路径 $x$ 到 $y$ ，若有多条最短路，优先跑第一条路径。但一定存在一个排列顺序，使在第一条路径上存在一个点被提前标记，这样第一条路径就不能走了。按照之前优先程度，那个排列此时会跑第二个最短路。

  第三个最短路或以上同理。

  但这个做法常数有点大，在这里需要开 O2 才能通过。

------------

- **代码**

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
const int N=15*15*15,M=15*15*15;
const int inf=1e9;
struct node{
	int x,y;
}b[M];
struct edge{
	int v,nx;
	int id;
}e[M];
int n,m,ne,f[N],a[N],p[N],d[N],lst[N],nxt[N],iid[N];
int ansn,tot,ans[M],t[M],dis[16][16];
bool vis[N];
queue<int> q;
int solve(int s,int t)
{	
	for(int i=1;i<=n;i++)d[i]=inf,lst[i]=0;
	while(!q.empty())q.pop();
	d[s]=0;q.push(s);
	while(!q.empty())
	{	
		int u=q.front();
		q.pop();
		for(int i=f[u];i;i=e[i].nx)
		{	
			int v=e[i].v;
			if(d[v]!=inf)continue;
			if(vis[v])continue;
			d[v]=d[u]+1;
			lst[v]=u;
			iid[v]=e[i].id;
			q.push(v);
		}
	}
	return d[t];
}
void getans(int res)
{	
	if(res>=ansn)return;
	ansn=res;
	for(int i=1;i<=res;i++)
		ans[i]=t[i];
}
int geth()
{	
	int res=0;
	for(int i=1;i<=n;i++)
		res+=dis[i][p[i]];
	return res;
}
void dfs(int x,int res,int deep)
{	
	if(x==n+1){getans(res);return;}
	int h=geth();
	if(res>=deep)
	{	
		if(h==0){getans(res);return;}
		return;
	}
	if(h/2+res>=ansn)return;
	if(res>=ansn)return;
	for(int i=1;i<=n;i++)
	{	
		if(vis[i])continue;
		int cnt=solve(i,p[i]);
		if(cnt==inf)continue;
		vis[i]=1;
		for(int u=p[i];u!=i&&lst[u]!=0;u=lst[u])
		{	
			swap(p[a[u]],p[a[lst[u]]]);swap(a[u],a[lst[u]]);
			t[++tot]=iid[u];
		}
		dfs(x+1,tot,deep);
		vis[i]=0;
		solve(a[i],i);
		while(tot>res)
		{	
			swap(p[a[b[t[tot]].x]],p[a[b[t[tot]].y]]);
			swap(a[b[t[tot]].x],a[b[t[tot]].y]);
			tot--;
		}
	}
}
void read(int u,int v,int w)
{	
	e[++ne].v=v;
	e[ne].nx=f[u];
	f[u]=ne;
	e[ne].id=w;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{	
		scanf("%d",&a[i]);
		p[a[i]]=i;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j)dis[i][j]=inf;
	for(int i=1;i<=m;i++)
	{	
		scanf("%d%d",&b[i].x,&b[i].y);
		if(b[i].x==b[i].y)continue;
		read(b[i].x,b[i].y,i);
		read(b[i].y,b[i].x,i);
		dis[b[i].x][b[i].y]=dis[b[i].y][b[i].x]=1;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	int deep=0;
	while(deep<=n*n)
	{	
		ansn=inf;
		dfs(1,0,deep);
		if(ansn!=inf)break;
		deep++;
	}
	printf("%d\n",ansn);
	for(int i=1;i<=ansn;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：ColinKIA (赞：3)

只看一眼就可以发现此题是一个搜索题，但是用什么搜索是很需要思考的。

1. BFS 或 DFS
> 明显不行，在题目中，交换次数是可以无限的，但是 bfs 和 dfs 没有限制，点会不断往搜索树里添加，会 T/M 。

2. A*
> 可以，题目中使用 A* 加上估价函数可以有效的排除大部分无效解，而往优先队列里扩展。

3. iddfs
> 也可以，但是可能会 T ,每次规定搜索深度可以有效避免搜索进搜索树无限的无解分支，但是可能效率也不够高。

4. DBBFS
> 可以，使用 dbbfs 可以有效减少 bfs 的时间复杂度，但是码量过大，且需要使用 hash ，不推荐。

5. idA*
> 最优解，每次规定搜索树深度，并且在搜索时规定估价函数，排除掉大部分的无效解，以达到剪枝的效果。

（下面讲解默认为 idA* )

选好之后，我们看到题目

给一个长度为 $N$ 的排列 $(1\le N\le 12)$。有 $M$ 种允许的修改方式 $(1\le M\le \frac{N\times (N-1)}{2})$，保证修改方式不重复，每种方式用 $L,$ $R$ 来表示，意为你可以将下标为 $L$ 的数与下标为 $R$ 的数交换。你可以修改该排列若干次，请给出一种修改方案，使原排列变为 $1,$ $2,$ $3,$ $\ldots,$ $N$。如果有多种方案，输出修改次数最少的方案。如果还有多种方案，输出任意一组即可。


正常的 dfs 的代码很好写

就是每次枚举操作 $i$ 判定一下 $i$ 和上一次的操作不同, 将两者交换，直到序列满足条件。

肯定会 T ，因为如果不去限制搜索树的深度，很有可能在无解的情况中耗费大量时间，期望 10 pts 。

这时我们使用 iddfs ，对搜索深度进行限制。

然后还是 T 了，如果不剪枝，仅仅靠着深度限制，很有可能被极限数据卡爆，期望得分 30 pts 。

这时我们使用 idA* ，考虑一下估价函数如何写。

我们给出一个序列

>  2 3 1

我们交换任意两个数，最多可以使得两个数到它应该的位置上。

所以我们枚举当前序列与目标序列有几个数不同，将这个数除以 2 ，加上当前交换次数，如果大于我们规定的深度，就剪枝。

这样会快很多，但是被卡了，期望得分 80 pts 。

证明我们的估价函数不够优秀。

我们再想一下，当有一个数需要交换时，如果我们能交换的数中不含它们俩，则至少需要两次才能让其回到正确的位置上。

又会快一些，但是还是 T 了，得分 90 pts 。

那这个时候怎么办？

我们看一下题目，把每一次操作抽象成两个点连接一条边，那我数字的位移，可以理解为一条从一个数到另一个数的一条路径。这个之后，可以使用 floyd 求出从一个数到另一个数的最短路，也就是最少的变换次数，然后在估价函数中求出位移到目标点的最小距离,然后将所有的距离加起来，除以 2 ，然后加上当前的变换次数，如果大于我们规定的深度就剪枝，然后就可以 AC 此题了。

不会 floyd 的看到[这里](https://blog.csdn.net/weixin_60737527/article/details/123774572)（此   floyd 博客转自 CSDN 生信小兔博主）。

```cpp
#include <bits/stdc++.h>
using namespace std;
int depth;
int a[15],n,m,b[80],c[80],d[15],ans,qian[80],dp[15][15];
bool flag;
int h(){
	int res=0;
	for(int i=1;i<=n;i++) res+=dp[i][d[i]];
	return res;
}//估价函数
bool check(){
	for(int i=1;i<=n;i++){
		if(d[i]!=i) return 0; 
	}
	return 1;
}//判断是否变换为目标状态
void idA_star(int now,int last){//idA*
	if(now*2+h()>depth*2){
		return ;
	}//不用h()/2是怕被卡精度
	if(check()){
		printf("%d\n",now);
		for(int i=0;i<now;i++){
			printf("%d\n",qian[i]);
		}
		exit(0);
	}
	for(int i=1;i<=m;i++){
		if(i==last) continue;//不判断last可能会死循环
		swap(d[b[i]],d[c[i]]);
		qian[now]=i;
		idA_star(now+1,i);
		swap(d[b[i]],d[c[i]]);
	}
}
int main(){
	scanf("%d %d",&n,&m);
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		d[i]=a[i];
		dp[i][i]=0;
	}
	for(int i=1;i<=m;i++){
		scanf("%d %d",&b[i],&c[i]);
		dp[b[i]][c[i]]=dp[c[i]][b[i]]=1;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[j][k]);//floyd
	while(++depth){//迭代加深
		idA_star(0,0);
		for(int i=1;i<=n;i++){
			d[i]=a[i];//复制一份a数组
		}
	}
	return 0;//结束
} 
```






---

## 作者：Unnamed114514 (赞：3)

算法：ID A\*。

首先，我们可以知道，对于一个序列，每次可以改变其中的两个数，那么也就是说，估价函数就是该序列与全排列不同的数量除以 $2$ 向下取整。

那么我们可以使用 ID A\* 实现这道题，但是这样会 TLE 90。

此时我们还有一个优化：如果预定位置和当前位置可以直达，那么步数多 $1$，否则，至少两步，步数多 $2$。

这样就会快得飞起，只用 457ms 就可以解决。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,tot[105],qwq,A[15],l[105],r[105];
bool p[105][105];
inline char gc(){
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	int res=0;
	char ch=gc();
	while(ch<'0'||ch>'9')
		ch=gc();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=gc();
	}
	return res;
}
inline int F(){
	int ans=0;
	for(int i=1;i<=n;++i){
		if(A[i]^i){
			if(p[A[i]][i])
				++ans;
			else
				ans+=2;
		}
	}
	return ans+1>>1;
}
bool dfs(int a,int b){
	int XZJ=F();
	if(a+XZJ>b)
		return 0;
	if(!XZJ){
		printf("%d",b);
		putchar('\n');
		for(int i=0;i<b;++i){
			printf("%d",tot[i]);
			putchar('\n');
		}
		exit(0);
	}
	for(int i=1;i<=m;++i){
		if(i^tot[a-1]){
			tot[a]=i;
			swap(A[l[i]],A[r[i]]);
			dfs(a+1,b);
			swap(A[l[i]],A[r[i]]);
		}
	}
	return 0;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i)
		A[i]=read();
	for(int i=1;i<=m;++i){
		l[i]=read(),r[i]=read();
		p[l[i]][r[i]]=p[r[i]][l[i]]=1;
	}
	while(!dfs(0,ans))
		++ans;
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：2)

很多人都可以看得出来，这是一道标准的搜索。

但是又很明显，暴搜肯定是会炸掉的。

联系所学的各种搜索优化知识，我们不难看出这是一道迭代加深的 IDA*。于是乎我们迅速打出了迭代加深的标准代码。

```cpp
	lim=0;
	while(!DFS(0))	lim++;
	cout<<lim<<endl;
```

那么我们的估价函数该怎么写呢？很简单，我们先往最好的方向思考，一次转换最多可以使得两个数字归到原位上，所以如果我们现在序列和标准序列不同的数字的个数除以 $2$，加上我们已经走的步数，如果直接大于了我们设定的最终步数，那么肯定就不能完成了，直接返回就可以了。

所以继续搜索的条件为：

$$step+\dfrac{Dif}{2}\leq lim$$

其中 $step$ 表示现在步数，$Dif$ 表示不同数字的个数，$lim$ 表示设定的最终步数。

但是它也不过只是 $90pts$。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int MAXN=15;
int n,m;
int now[MAXN];
int l[MAXN*MAXN>>1],r[MAXN*MAXN>>1];
int lim;
int check()
{
	int sum=0;
	for(int i=1;i<=n;i++)	sum+=(i!=now[i]);
	return sum;
}
int did[MAXN*MAXN>>1];
int cnt;
int DFS(int step)
{
	if(step*2+check()>lim*2)	return 0;
	if(step==lim)
	{
		if(!check())	return 1;
		return 0;
	}
	for(int i=1;i<=m;i++)
	{
		swap(now[l[i]],now[r[i]]);
		did[++cnt]=i;
		if(DFS(step+1))	return 1;
		cnt--;
		swap(now[l[i]],now[r[i]]);
	}
	return 0;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)	cin>>now[i];
	for(int i=1;i<=m;i++)	cin>>l[i]>>r[i];
	lim=0;
	while(!DFS(0))	lim++;
	cout<<lim<<endl;
	for(int i=1;i<=lim;i++)	cout<<did[i]<<endl;
	return 0;
}
```

在这种情况下，就不是卡不卡常的问题了，而是我们估价函数并不够优秀。

考虑到估价函数太弱了，联系上文不等式 $step+\dfrac{Dif}{2}\leq lim$，其中 $step$ 和 $lim$ 的值是定的，则推出 $Dif$ 的值太小了，无法排除更多的答案。

那么怎么才能使得估价函数的值更大呢？我们不难发现，一次交换是最多使两个数字归回原位，但是我们交换位置是固定的，假设当前交换了位置，也有可能需要借助其它的操作使它们归位。哎！细品一下 “需要借助其它的操作使它们归位” 这句话，是不是想到了什么。

没错，我们每次交换是可以联系起来的，$i$ 和 $j$ 位置互换，$j$ 和 $k$ 位置互换，那么就相当于 $i$ 花了两次回到 $k$。这里的次数就很像一个边权。我们设 $1…n$ 每个数字为一个节点，$n$ 个节点构成一个图，每个不同的操作就相当于连接两个点，边权即操作次数为 $1$，那么我们求数字 $a_i$ 回到自己该到的位置 $i$ 上的次数就是最短路，我们直接求出 $a_i$ 到 $i$ 的最短路就是交换次数。

于是我们将估价函数修改成 $\sum dist(a_i,i)$ 的值就可以了。

代码拿到了 $100pts$ 的好成绩。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int MAXN=15;
int n,m;
int now[MAXN];
int l[MAXN*MAXN>>1],r[MAXN*MAXN>>1];
int lim,dp[MAXN][MAXN];
int check()
{
	int sum=0;
	for(int i=1;i<=n;i++)	sum+=dp[now[i]][i];
	return sum;
}
void Floyd()
{
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)	dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
		}
	}
}
int did[MAXN*MAXN>>1];
int cnt,flag;
int pre;
int DFS(int step)
{
	if(flag)	return 1;
	if(step+check()/2>lim)	return 0;
	if(step==lim)
	{
		if(!check())	return flag=1;
		return 0;
	}
	for(int i=1;i<=m;i++)
	{
		swap(now[l[i]],now[r[i]]);
		did[++cnt]=i;
		if(DFS(step+1))	return 1;
		cnt--,pre=0;
		swap(now[l[i]],now[r[i]]);
	}
	return 0;
}
int main()
{
	memset(dp,0x3f,sizeof(dp));
	cin>>n>>m;
	for(int i=1;i<=n;i++)	cin>>now[i],dp[i][i]=0;
	for(int i=1;i<=m;i++)	cin>>l[i]>>r[i],dp[l[i]][r[i]]=dp[r[i]][l[i]]=1;
	Floyd();
	lim=0;
	while(!DFS(0))	lim++;
	cout<<lim<<endl;
	for(int i=1;i<=lim;i++)	cout<<did[i]<<endl;
	return 0;
}
```

---

## 作者：JasonL (赞：2)

### P5183 【[COCI 2009] POSLOZI】

[题目传送门](https://www.luogu.com.cn/problem/P5183)

#### 分析

写了4种做法，在这里都提一下吧。

只附上正解的代码，前几种写的太难看不附上来了。

P.S. 我以为IDA*没用，狂写了两小时，但结果是用了就过去了……~~爆锤桌子~~

· BFS

刚开始写了一个朴素的BFS。为了记录状态，用一个(n+1)进制数来表示。map存当前状态还原回前一状态的状态编号，最后顺着map倒序输出即可。

可以利用该状态是否在map里记录过来确定该状态是否被访问过。

实际得分50分。后5个点TLE。

· 双端BFS

与上一做法唯一不同的在于我们从终点做同样的BFS，开同样的map。如果某一个状态被两端都访问过了，那么我们就得到了操作数最少的情况下的一种操作序列。操作序列可以由两个map得到。

实际得分90分。最后一个点MLE。

· A*

写了一个简单的估价函数：有多少个数字不在自己的位置上。如果为0那么说明已经还原成功，否则如果有$w$个，那么至少要$w-1$次才能还原。

实际得分50分。TLE+MLE。

· IDA*

用了上面的估价函数写了IDA*（A*+限制DFS深度）。

结果跑得飞快。AC，361ms。

代码如下。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,mdep;
int a[14],op[2][14*14];
int ans[2010],dep;
inline int read(){
	int res=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return res;
}
int calc(){//估价函数 
	int res=0;
	for(register int i=1;i<=n;++i)
		res+=a[i]!=i;
	return res?res-1:0;
}
void opt(int x){//执行编号为x的交换操作 
	swap(a[op[0][x]],a[op[1][x]]);
}
bool dfs(){
	int h=calc();
	if(!h)return true;//h=0,还原成功 
	if(dep+h>=mdep)return false;//一定会超过限制深度 
	for(register int i=1;i<=m;++i){
		ans[++dep]=i;
		opt(i);
		if(dfs())return true;
		opt(i);
		--dep;
	}
	return false;
}
int main(){
	n=read();m=read(); 
	for(register int i=1;i<=n;++i)
		a[i]=read();
	for(register int i=1;i<=m;++i)
		op[0][i]=read(),op[1][i]=read();
	while(!dfs())++mdep;//逐渐增加搜索深度 
	printf("%d\n",dep);
	for(register int i=1;i<=dep;++i)
		printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：lsd110504lsd (赞：1)

## 分析

我们设 $f_{i,j}$ 表⽰第 $i$ 个位置上的数与第 $j$ 个位置上的数交换位置最⼩需要的次数，这相当于构建⼀张 $n$ 个点的图，每种修改⽅式的两个点之间连边，$f_{i,j}$ 就是从i到j的最短路。使⽤ floyd 即可求出 $f$ 数组。那么如果我们现在的排列为 $p$ ，那么让 $\frac{\sum_{i=1}^n f_{i,p_{i}}}{2}$ 作为我们的估价函数即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=13;
int a[N];
int n,m;
int dis[N][N];
int idx;
int ans[30],b[N*N],c[N*N],pos[N];
inline bool check(){
	for(int i=1;i<=n;i++){
		if(a[i]!=i) 	return false;
	}
	return true;
}
inline int getgu(){
	int cnt=0;
	for(int i=1;i<=n;i++) pos[a[i]]=i;
	for(int i=1;i<=n;i++){
		cnt+=dis[i][pos[i]];
//		for(int j=1;j<=n;j++){
//			if(a[j]==i){
//				cnt+=dis[i][j];
//				cout<<i<<" "<<j<<" "<<pos[a[i]]<<endl;
//				break;
//			}
//		}
	}
	return (cnt+1)>>1;
}
inline bool Dfs(int maxdep,int fa,int now){
	if(check()) 	return true;
	int p=getgu();
	if(p+now>maxdep)	return false;
	for(int i=1;i<=m;i++){
			if(i==fa)	continue;
			swap(a[b[i]],a[c[i]]);
			ans[++idx]=i;
			if(Dfs(maxdep,i,now+1)) 	return true;
			swap(a[b[i]],a[c[i]]);
			ans[idx--]=0;
	}
	return false;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	for(int i=1;i<=N-1;i++){
		for(int j=1;j<=N-1;j++){
			dis[i][j]=(int)1e9;
		}
		dis[i][i]=0;
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++)	cin>>a[i];
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		b[i]=u,c[i]=v;
		if(u!=v) dis[u][v]=dis[v][u]=1;
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	for(int i=0;i<=13;i++){
		if(Dfs(i,0,0)){
			cout<<i<<"\n";
			for(int i=1;i<=idx;i++)
				cout<<ans[i]<<"\n";
			break;
		}
	}

	return 0;
}
```

---


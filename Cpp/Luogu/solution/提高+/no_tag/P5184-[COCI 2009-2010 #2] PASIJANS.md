# [COCI 2009/2010 #2] PASIJANS

## 题目背景

原题时限 5s，这里根据洛谷评测机速度更改了时限。

## 题目描述

 **译自 [COCI 2009.11](http://hsin.hr/coci/archive/2009_2010/) T6「[PASIJANS](http://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)」**

给出 $N$ 个已经塞了数进去的栈（每个栈中元素的数量可能不同），有一个空的「答案队列」，你每次可以「将一个栈的栈顶元素弹出，插入答案队列的末尾」，直至所有栈都清空。试求「字典序最小」的答案队列。

如果两个答案队列 $a, b$ （从队首往队尾数）前 $i-1$ 个数都相同，而 $a_i<b_i$，则我们称 $a$ 的字典序比 $b$ 的字典序小。

## 说明/提示

$1\le N\le 1000,$ $1\le L\le 1000$。

## 样例 #1

### 输入

```
3
1 2
1 100
1 1```

### 输出

```
1 2 100
```

## 样例 #2

### 输入

```
2
5 10 20 30 40 50
2 28 27```

### 输出

```
10 20 28 27 30 40 50```

## 样例 #3

### 输入

```
2
3 5 1 2
3 5 1 1```

### 输出

```
5 1 1 5 1 2```

# 题解

## 作者：JimmyLee (赞：8)

# 分析

考虑贪心，每次尽量选最小的字符。

显然是每次选字典序最小的弹栈。

我们要比较的是每个栈的字典序，但是朴素比较是 $O(L)$ 的，考虑将它优化到 $O(1)$。

这个时候我们可以先离散化然后套路地将所有串拼一起跑 SA。

~~记得在每个串之间加分割符。~~

这样每次比较字典序就变成了 $O(1)$。

时间复杂度 $O((\sum L)\log (\sum L))$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1001006

int sa[maxn], x[maxn], y[maxn], c[maxn];

void radix_sort(int n, int m)
{
    for(int i=1;i<=m;i++) c[i]=0;
    for(int i=1;i<=n;i++) c[x[i]]++;
    for(int i=1;i<=m;i++) c[i]+=c[i-1];
    for(int i=n;i;i--) sa[c[x[y[i]]]--]=y[i];
}

void suffix_sort(int *s, int n)
{
    int m=1e6+1;
    for(int i=1;i<=n;i++) x[i]=s[i], y[i]=i;
    radix_sort(n, m);
    for(int k=1;k<=n;k<<=1)
    {
        int cnt=0;
        for(int i=n-k+1;i<=n;i++) y[++cnt]=i;
        for(int i=1;i<=n;i++) if(sa[i]>k) y[++cnt]=sa[i]-k;
        radix_sort(n, m);
        swap(x, y);
        x[sa[1]]=cnt=1;
        for(int i=2;i<=n;i++)
            x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?cnt:++cnt;
        if((m=cnt)==n) return;
    }
}

int cont[maxn];
vector<int> wa;
int pos[1003], len[1003], stp[1003];
int rk[maxn];
struct cmp
{
    bool operator()(int a, int b) {return rk[pos[a]]>rk[pos[b]];}
};

priority_queue<int, vector<int>, cmp> pq;

int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        pos[i]=stp[i]=*cont+1;
        cin>>len[i];
        for(int j=1;j<=len[i];j++)
        {
            cin>>cont[++*cont];
            wa.emplace_back(cont[*cont]);
        }
        cont[++*cont]=2e9;
    }
    sort(wa.begin(), wa.end());
    auto end_it=unique(wa.begin(), wa.end());
    for(int i=1;i<=*cont;i++)
        cont[i]=lower_bound(wa.begin(), end_it, cont[i])-wa.begin()+1;
    suffix_sort(cont, *cont);
    for(int i=1;i<=*cont;i++)
        rk[sa[i]]=i;
    for(int i=1;i<=n;i++) pq.emplace(i);
    while(!pq.empty())
    {
        int v=pq.top();
        pq.pop();
        cout<<wa[cont[pos[v]]-1]<<' ';
        pos[v]++;
        if(pos[v]!=stp[v]+len[v]) pq.emplace(v);
    }
}
```

---

## 作者：Planet6174 (赞：3)

后缀数组的简单应用。如果你学过后缀数组的话，你应该可以跳过我这篇题解了。

---

$\ $

$\ $

$\ $

$\ $

一眼可以看出是贪心。

先考虑一种较简单的情况：目前所有栈的栈顶元素互不相同。显然，当前这步的最优解应该选择栈顶元素最小者，将其放入答案队列。

但是，如果两个栈的栈顶元素相同呢？乍一看，随意选择一个均可，但是你会发现在样例 3（两个栈中的元素分别为 5 1 2 和 5 1 1）中，
如果第一步选择了一号栈的 5，那么最终结果会得出 5 1 2 5 1 1，而最优解应该是先选二号栈的 5，最终结果为 5 1 1 5 1 2。

假设有两个大小均为 $2$ 的栈 $a,b$，$a$ 中栈顶元素为 $p$，接下来是 $q_1$；$b$ 中栈顶元素同样为 $p$，接下来是 $q_2$。

那么，**先**选哪个栈好呢？请模拟一下，可以总结出：

- 如果 $q_1=q_2$，则继续往后考虑。
- 若 $q_1<q_2$，则先选栈 $a$ 「肯定不会」「得不到」最优解。请自行模拟 $p<q_1<q_2,$ $q_1<p<q_2,$ $q_1<q_2<p$ 的情况。
- 若 $q_1>q_2$，则先选栈 $b$ 肯定不会得不到最优解，自行模拟的东西与上面类似。

一言以蔽之：

### 每次选择字典序最小的栈，将其栈顶的元素放入答案队列。

把总共 $NL$ 个后缀（$N$ 个数组，每个数组有 $L$ 个）搞个后缀数组出来即可。接下来你可以去查一下后缀数组怎么写了。

---

## 作者：phigy (赞：2)

### 主要思想与方法

显然是一道贪心。

每一次将最小的取出。

例如两个栈：

第一个 ：1 10

第二个 ：2 1

显然先取第一个更优。

**既然长度是固定的肯定是越靠前的数越大越好。**

这和比大小是一个原则。

但如果最小的有两个一样的数。

还是两个栈：

第一个： 1 10。

第二个： 1 2。

第三个： 2 1。

第一个肯定是选两个1中的一个。

但具体选哪个呢？

这里可以告诉你是继续比较后面，2<10所以选第二个。

但为什么呢？

既然不管选后面大的还是选后面小的。

前面都要选一个一。

而后面的两个2和10中，最小的2一定比10先被选。

虽然不知道什么时候选。

就像排序的时候。

一个数列 4 2 1 6 5。

4和2你虽然不知道它们的位置。

但你知道2在4前面。



------------
### 实现方法与提示
本题常数较大。

可以开O2。

可以选择手动模拟。

也可以选择使用结构体配合队列与优先队列。

实现较为简单。

需要代码私信。

-----
### 总结
此题为一道基础的贪心题目。

方法类似于比大小。

总体难度不到蓝题，绿题左右。


---

## 作者：_•́へ•́╬_ (赞：1)

### $\texttt{思路}$

贪心

显然，应该输出目前栈顶元素最小的那个栈的栈顶元素。

但是，如果有多个栈的栈顶元素相同，咋办？

> > ~~随便哪个都行~~

为后面着想，应该选字典序最小的。

还有一点：如果有两个栈$a[]$和$b[]$，长度分别是$l_1$和$l_2$（$l_1<l_2$），正常来讲$a[]$的字典序比$b[]$的小，但是本题$b[]$应该比$a[]$更优先。Hack数据:![](https://i.loli.net/2020/02/10/SAHFfUOr48obNcJ.png)。本题的数据中有这种情况。

-------------

---------------

--------------

### $code$

拿笨方法模拟的，很慢。

```cpp
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
//以上为奇怪的优化，对本题有巨大作用，大型比赛不要用（毕竟你背不下来
#include<stdio.h>
#include<queue>
#define pr pair<int,int> 
using namespace std;
inline void read(int&x)//快读
{
	register char c=getchar();for(;c<'0'||'9'<c;c=getchar());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());
}
struct node
{
	int l,i,a[1000];
	inline void in(){read(l);for(i=0;i<l;++i)read(a[i]);i=0;}//输入
	inline bool operator<(const node&kkk)const//重载运算符
	{
		for(register int j=0;i+j<l&&kkk.i+j<kkk.l;++j)
			if(a[i+j]!=kkk.a[kkk.i+j])return a[i+j]>kkk.a[kkk.i+j];
		return l-i<kkk.l-kkk.i;
		/*这个是按字典序从大到小排序的。
		 *stl的堆是反的。
		 *如果你写从大到小，就是小根堆。
		 *如果你写从小到大，就是大根堆。
		 *这与你重载小于号还是大于号没有关系。
		 */
	}
}a;
int n;priority_queue<node>q;
main()
{
	read(n);for(register int i=0;i<n;++i)a.in(),q.push(a);//输入
	for(register node now;q.size();)
	{
		now=q.top();q.pop();printf("%d ",now.a[now.i++]);//输出
		if(now.i<now.l)q.push(now);//如果栈里还有东西，还要扔到堆里去看下一个数
	}
}
```



---

## 作者：ZhongYuLin (赞：1)

有一个显然的贪心策略：

**每次将当前字典序最小的栈的栈顶弹出，放入答案序列。**

实现难点在于维护字典序最小的栈，考虑使用哈希，二分相同前缀长度：对于两个字符串，当 $mid$ 越大时，前缀越不容易相同；而当 $mid$ 越小时，前缀越容易相同。找到不相同的第一位时，返回即可。

注意：当一个字符串是另一个的前缀时，长度较大的字典序较大。

代码（码风抽象，慎看）：

```cpp
#include<bits/stdc++.h>
using ull=unsigned long long;
using namespace std;
const int N=1e3+10,MUL=13331;
ull hsh[N];
struct Node{
    ull h[N],a[N];int l,r;
    Node(){}
    Node(int i){
        cin>>r;h[0]=0;l=1;
        for(int i=0;++i<=r;)cin>>a[i],h[i]=h[i-1]*MUL+a[i];
    }
    ull get(int len)const{
        int r=l+len-1;
        return h[r]-h[l-1]*hsh[r-l+1];
    }
    friend bool operator<(const Node &x,const Node &y){
        int r=min(x.r-x.l+1,y.r-y.l+1),l=1,mid,ans=-1;
        for(;l<=r;)mid=l+r>>1,x.get(mid)!=y.get(mid)?r=mid-1,ans=mid:l=mid+1;
        if(ans==-1)return x.r-x.l<y.r-y.l;
        return x.a[x.l+ans-1]>y.a[y.l+ans-1];
    }
};
struct It{
    int to;
    It(){}
    It(const int &i){to=i;}
    friend bool operator<(const It &x,const It &y){
        return nd[x.to]<nd[y.to];
    }
};
int n;
priority_queue<It>q;
Node nd[N];
int main(){
    int i,j,k;
    for(hsh[0]=1,i=0;++i<N;)hsh[i]=hsh[i-1]*MUL;
    // freopen("P5184.in","r",stdin);
    ios::sync_with_stdio(0);cin.tie(0);
    for(cin>>n,i=0;++i<=n;)nd[i]=Node(1),q.push(It(i));
    while(!q.empty()){
        int at=q.top().to;q.pop();
        Node* x=&nd[at];
        printf("%llu ",x->a[x->l++]);
        if(x->l<=x->r)q.push(It(at));
    }
    puts("");
    return 0;
}
```


---

## 作者：Usada_Pekora (赞：0)

题意还是很清晰的，在此不作分析。

考虑用一个支持动态维护优先级的数据结构来对这些栈进行排序，为什么要是动态的呢？因为删了一个栈顶以后优先级要变。

显然把栈顶比较小的栈放到前面比较好，因为假如有 $a,b(a<b)$ 可以选，我们先选 $a$ 后面加一堆数肯定是比先选 $b$ 后面加一堆数好的。

栈顶元素都一样的时候随便 pop 一个栈这两个栈顶就不一样了。需要注意的是如果一个栈直到 pop 空了都和另一个栈相同，则考虑将另一个栈放上去。

比如考虑栈 $A,B$，其中 $B$ 仅在栈底比 $A$ 多一个元素。假设这个多出的元素比 $A$ 中出现的其它元素都要小，那么 $B$ 显然放在 $A$ 前面是更合适的。如果更大也没关系，因为对这两个栈的操作必定是对称的，总会发现这个多的元素比较大。

所以比较按照这样的流程进行，注意每次需要删除掉被选出的数：

```cpp
bool cmp(int x, int y) { // a[x] : 栈 x，顶从 1 开始编号，siz[x] : 栈 x 的大小
	for (int i = 1; i <= min(siz[x], siz[y]); i++)
		if (a[x][i] != a[y][i])
			return a[x][i] < a[y][i];
	return siz[x] > siz[y];
}

```

复杂度 $O(L\sum L\log L)$，过不了。

注意到这个比较是可以优化的：我们只需找出两个前缀第一个不同的地方并比较大小即可，这个可以哈希或者 SA 解决，于是复杂度变成了 $O(\sum L\log^2 L)$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
inline int read() {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
	return x;
}
const int mod = 998244353, P = 131;
int qpw[1005];
struct node {
	int *a, *b;
	int64_t *hsh;
	node() {
		int L = read();
		a = (int*)calloc(L + 1, sizeof(int)), b = a + L;
		hsh = (int64_t*)calloc(L + 1, sizeof(int64_t));
		for (int i = 0; i < L; i++)
			a[i] = read();
		for (int i = 1; i <= L; i++)
			hsh[i] = (hsh[i - 1] * P + a[i - 1]) % mod;
	}
	inline int64_t hshval(int l, int r) const {
		return (hsh[r] - hsh[l - 1] * qpw[r - l + 1] % mod + mod) % mod;
	}
	bool operator < (const node &o) const {
		int l = 1, r = min(b - a, o.b - o.a), res = -1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			int64_t lhs = hshval(1, mid), rhs = o.hshval(1, mid);
			if (lhs != rhs)
				res = mid, r = mid - 1;
			else
				l = mid + 1;
		}
		if (res != -1) 
			return a[res - 1] > o.a[res - 1];
		return b - a < o.b - o.a;
	}
};
__gnu_pbds::priority_queue<node, less<node>, pairing_heap_tag> q;
signed main() {
	cout.tie(nullptr)->sync_with_stdio(false);
	qpw[0] = 1;
	for (int i = 1; i <= 1000; i++)
		qpw[i] = 1ll * qpw[i - 1] * P % mod;
	for (int n = read(); n--; )
		q.push(node());
	while (!q.empty()) {
		node now = q.top();
		q.pop();
		cout << *now.a++ << ' ';
		now.hsh++;
		if (now.a != now.b)
			q.push(now);
	}
	return 0;
}
```

---


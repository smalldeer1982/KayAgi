# [COCI 2009/2010 #5] ZUMA

## 题目描述

 **译自 [COCI 2010.03.06](http://hsin.hr/coci/archive/2009_2010/) T4「[ZUMA](http://hsin.hr/coci/archive/2009_2010/contest5_tasks.pdf)」**

Mirko 将 $N$ 颗弹子排成一排，依次编号为 $1\ldots N$。$i$ 号弹子的颜色为 $c_i$。他发现，如果他触摸 $\ge K$ 颗连续的弹子，且这些弹子的颜色相同，魔法会使这些弹子消失；此后，这 $K$ 颗弹子前面的弹子便与这 $K$ 颗弹子后面的弹子相邻。

Mirko 家里有很多弹子，他想在这 $N$ 颗弹子之间（也可以在开头的弹子前面或末尾的弹子后面）插入尽可能少的弹子，使得这 $N$ 颗弹子+插入的所有弹子消失。

## 说明/提示

$1\le N\le 100,$ $2\le K\le 5,$ $1\le c_i\le 100$.

## 样例 #1

### 输入

```
2 5
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5 3
2 2 3 2 2```

### 输出

```
2```

## 样例 #3

### 输入

```
10 4
3 3 3 3 2 3 1 1 1 3```

### 输出

```
4```

# 题解

## 作者：LiaoYF (赞：8)

## 做法

我写的详细一点。

每次消除一个区间，很容易让人想到用 $f_{i,j}$ 表示将 $i \sim j$ 这一段消除，所需要添加的弹子数量。转移的时候，想要把 $j$ 消除，要么是将 $j$ 单独添加一些弹子消除，要么与 $i \sim j-1$ 的一些同色弹子合并，再添加一些弹子消除。

但是当我们要将 $j$ 和前面的一些弹子合并消除的时候，没法知道之前还剩下几个同色弹子，就没法知道要添加多少了。如果新增状态表示之前弹子的情况，状态数就炸了。

如果能构造一个状态，使得这次合并在前面与 $j$ 合并的那个弹子的位置就被预料到并且计算了花费，然后在处理 $i \sim j$ 这一段的时候再调用，问题就解决了。

使用 [P2135](https://www.luogu.com.cn/problem/P2135) 中的技巧，$f_{i,j,x}$ 表示将 $i \sim j$ 这一段消除，并且未来 $j$ 与后面的 $x$ 个本来就存在的弹子合并消除了，所需要添加的弹子数量。可以写出转移：

1. 直接消除 $j$ 和后面的 $x$ 个：$f_{i,j,x}=f_{i,j-1,0}+\max(0,k-x-1)$。

2. 假设 $c_p=c_j$，将 $j$ 和后面的 $x$ 个与 $p$ 合并：$f_{i,j,x}=f_{i,p,x+1}+f_{p+1,j-1,0}$。

那为什么只需要考虑 $j$ 和后面的弹子合并，不需要考虑 $i \sim j-1$ 的弹子和后面的弹子合并呢？借用一下 2009 集训队论文 徐源盛 《对一类动态规划问题的研究》中的一段话。
![](https://cdn.luogu.com.cn/upload/image_hosting/7fni4duf.png)

这样已经可以过了，但 $\geq K$ 个弹子合并都不需要额外添加弹子，所以 dp 数组的第三维其实只用算到 $K-1$ 即可。最终时间复杂度 $O(N^3 K)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define i128 __int128
#define ALL(x) x.begin(),x.end()
#define popcount(x) __builtin_popcountll(x)
#ifdef LOCAL
#include "debug.h"
#else
#define debug(...) 42
#endif
using namespace std;
const int INF=1e18;
const int N=105;
const int MOD=1e9+7,MOD2=998244353;
int n,k,a[N],f[N][N][6];//和j后面本来就存在的k个一起消除
void solve_(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int len=1;len<=n;len++){
        for(int i=1;i+len-1<=n;i++){
            int j=i+len-1;
            for(int x=0;x<k;x++){
                f[i][j][x]=f[i][j-1][0]+max(0ll,k-x-1);
                for(int p=i;p<j;p++){
                    if(a[p]==a[j]){
                        f[i][j][x]=min(f[i][j][x],f[i][p][min(k-1,x+1)]+f[p+1][j-1][0]);
                    }
                }
            }
        }
    }
    cout<<f[1][n][0]<<"\n";
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int testcase,multitest=0;
    if(multitest)cin>>testcase;
    else testcase=1;
    while(testcase--){
        solve_();
    }
    return 0;
}
```

---

## 作者：zpy12345 (赞：6)

# [ [COCI 2009/2010 #5] ZUMA](https://www.luogu.com.cn/problem/P5189)
~~本篇题解写得应该还挺详细。~~
## 思路
提供一种容易理解，时间复杂度为 $O(KN^3)$ 的算法（好像别的题解没有和我思路一样的）。

容易想到区间 DP，但依照传统分割转移，显然会漏掉区间左右端点一起消除的情况，而区间左右端点还可能一起与中间的某些同色点一同消除情况更优（见样例 3）。故我们还需要知道某个区间最后一次消除的点中，有多少是原序列中本来存在的点。不知道该信息怎么办？~~凉拌~~写进状态里。

设 $ans_{i,j}$ 表示区间 $[i,j]$ 全部消除最少需要插入几颗弹子。设 $dp_{i,j,p}$ 表示区间 $[i,j]$ 全部消除，其中区间的左右端点 $i$ 和 $j$ 最后一次一起消除，且最后一次消除（$i$ 和 $j$ 一起消除的操作）的点中有 $p$ 个原序列中本来存在的点（包含 $i$ 和 $j$），最少需要插入几颗弹子。显然，该状态只在 $c_{i}= c_{j}$ 时有意义。同时可以发现，对于所有 $p\ge K$ ，其最后一次消除的花费是相同的，我们并不需要关心最后一次具体是多少点一起消除。于是不妨将 $p\ge K$ 的状态合并到 $dp_{i,j,K}$，特别令 $dp_{i,j,K}$ 的最后一次消除的点数 $p\ge K$，故 $p\in [2,K]$。

考虑转移，$ans_{i,j}$ 的转移非常简单：
$$ans_{i,j} = \min (         
\min_{x=i}^{j-1}\{ans_{i,x}+ans_{x+1,j}\},\min_{x=2}^{K}\{dp_{i,j,x}\})$$
当 $c_{i}=c_{j}$ 时，对于 $dp_{i,j,p}(p\in [3,K])$，我们会在区间 $[i+1,j-1]$ 中选取 $p-2$ 个同色点，我们可以枚举这些同色点的最后一个 $x$，要求 $c_{x}=c_{i}$，此时我们需要在 $[i,x]$ 中选 $p-1$ 个同色点。故有转移：
$$dp_{i,j,p} =          
  \min_{x=i}^{j-1}\{\max (dp_{i,x,p-1}-(K-(p-1))+(K-p)+ans_{x+1,j-1},0)(c_{x}=c_{i})\}  (p\in [3,K])$$
特别的，$dp_{i,j,2} = ans_{i+1,j-1}+K-2$。$dp_{i,j,K}$ 还可以等于 $$\min_{x=i}^{j-1}\{dp_{i,x,K}+ans_{x+1,j-1}(c_{x}=c_{i})\} $$，与上方的式子取 min 即可。

显然，时间复杂度为 $O(KN^3)$。

## 代码
挤进最优解第一页了。
```cpp lines=30-31
#include<bits/stdc++.h>
using namespace std;
int n,k,c[105],dp[105][105][6],ans[105][105];
//这里的dp实际上没用dp[][][0]与dp[][][1],如果想优化空间可以减去
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]);
	for(int i=1;i<=n;i++)
	{
		ans[i][i]=k-1;
		for(int j=2;j<=k;j++)
			dp[i][i][j]=5000;
	}
	for(int l=2;l<=n;l++)
	{
		for(int i=1;i+l-1<=n;i++)
		{	
			int j=i+l-1;
			ans[i][j]=5000;
			for(int p=2;p<=k;p++) 
				dp[i][j][p]=5000;
			for(int x=i;x<=j-1;x++)
			{
				ans[i][j]=min(ans[i][j],ans[i][x]+ans[x+1][j]);
				if(c[i]==c[j])//这里其实不需要判a[i]=a[x],因为如果a[i]!=a[x],那么dp[i][x][]一定都为5000
				{
					for(int p=3;p<=k;p++)
						dp[i][j][p]=min(dp[i][j][p],max(dp[i][x][p-1]+ans[x+1][j-1]-1,0));
//初始化赋为大值,但不能太大,要不然上方的式子dp[i][x][p-1]+ans[x+1][j-1]-1可能爆int
					dp[i][j][k]=min(dp[i][j][k],dp[i][x][k]+ans[x+1][j-1]);
				}
			}
			if(c[i]==c[j])
			dp[i][j][2]=min(dp[i][j][2],ans[i+1][j-1]+k-2);
			for(int p=2;p<=k;p++)
				ans[i][j]=min(ans[i][j],dp[i][j][p]);
		}	
	}
	cout<<ans[1][n];
	return 0;
}
```

---

## 作者：lzy20091001 (赞：6)

[洛谷 P5189 [COCI 2009/2010 #5] ZUMA](https://www.luogu.com.cn/problem/P5189)

思路来自 @[LiaoYF](luogu://user/633466) 大佬的[题解](https://www.luogu.com.cn/article/2iaivsnr)，当时花了不少功夫才读懂，这里写一篇更易懂、明了的题解。

## 题意简述

有一个长度的数列 $c_{1, 2, \cdots, n}$。你可以进行 2 种操作：

- 在其中任意位置添加任意一个数；
- 删除任意一段满足以下条件的区间 $c_{l, \cdots ,r}$：
  - $r - l + 1 \ge k$；
  - $c_l = c_{l + 1} = \cdots = c_r$。

添加操作代价为 $1$，删除操作代价为 $0$。求使得整个数列都被删去的最小代价。

## 思路

考虑区间 DP。

### 状态

套路的做法是设删除区间 $[l, r]$ 的代价为 $f(l, r)$。但是我们可以通过删除中间部分，把两个原本不相邻的区间拼成一个新的大区间。这启示我们构造的状态应当包含 $[l, r]$ 以外的信息。

具体地，设 $f(l, r, x)$ 表示：**在“删除了 $[r + 1, n]$ 内所有不等于 $c_r$ 的数”的前提下，“将 $[l, r]$ 和 $r$ 后面的前 $x$ 个数共同删去”的代价。**（这 $x$ 个数都是原有而非我们添加的，前提中也删除了所有我们添加的数。）

这个定义非常拗口。为什么要这么定义？因为这就相当于“删除了中间部分”，把 $c_r$ 和后面所有能一起删去的数拼在了一起。

### 转移

转移有两种：

- 直接删除 $c_r$ 和后面的 $x$ 个数：如果 $x + 1 < k$，那么我们就要添加 $k - x - 1$ 个数。所以这种转移的方程为 $f(l, r, x) = f(l, r - 1, 0) + \max \{ 0, k - x - 1 \}$（为什么 $f(l, r - 1, 0)$ 第三个参数是 $0$？牢记我们状态定义的前提就是已经把 $r$ 以后所有不等于 $c_r$ 的数都删去了）；
- 若存在 $i \in [l, r]$ 且 $c_i = c_r$，那么我们也可以先删去 $[i + 1, r - 1]$，然后再把 $c_i, c_r$ 以及后面的 $x$ 个数一起删除。这种转移的方程为 $f(l, r, x) = f(i + 1, r - 1, 0) + f(l, i, x + 1)$。

枚举所有转移取最小即可。

#### 小优化

删除操作没有代价，因此长度大于等于 $k$ 且可以被删除的区间没有意义，第三维的取值范围可以设为 $[0, k - 1]$。当然，转移方程也随之有一点小变化。

### 边界

$l = r$ 时 $f(l, r, x) = 0$。

### 复杂度分析

时间复杂度为 $\operatorname{O}(N^3K)$，但常数很小；空间复杂度为 $\operatorname{O}(N^2K)$。

## 实现

```cpp
#include <iostream>

using namespace std;

const int N = 100, K = 5;

int c[N + 5], f[N + 5][N + 5][K + 5];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, k;

    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        cin >> c[i];

    for (int len = 1; len <= n; len++)
        for (int l = 1, r = l + len - 1; r <= n; l++, r++)
            for (int x = 0; x < k; x++)
            {
                f[l][r][x] = f[l][r - 1][0] + k - x - 1;
                for (int i = l; i < r; i++)
                    if (c[i] == c[r])
                        f[l][r][x] = min(f[l][r][x], f[l][i][min(x + 1, k - 1)] + f[i + 1][r - 1][0]);
            }

    cout << f[1][n][0] << "\n";

    return 0;
}
```

---

## 作者：P_Bisector (赞：3)

这里提供一种没有思维含量的，时间复杂度为 $O(KN^4)$ 的，不知道为啥能卡过的做法。
 

显而易见的，此题是一个区间 DP 题。我们设计状态 $f_{i,j,k,len}$ 表示可以通过 $f_{i,j,k,len}$ 次操作将  $[i,j]$ 消除为一个长度为 $len$，颜色为 $k$ 的序列。

我们考虑以下三种情况：

- 消除最右边的珠子。转移如下：

$$f_{i,j,k,len} = \begin{cases}
  f_{i,j-1,k,len-1} & a_j=k                \\
  \min\{f_{i,j-1,k,len-1},f_{i,j-1,k,len}\} & a_j=k \land len=K  
\end{cases}$$

代码如下：

```cpp
if(a[j]==k){
      f[i][j][k][len]=min(f[i][j][k][len],min(f[i][j-1][k][len-1],(len==K)?f[i][j-1][k][len]:inf));
}
```

- 消除最左边的珠子。转移同上。可见代码。

- 拼接两个区间。转移如下：

 
$$f_{i,j,k,len} =          
  \min_{mid=i}^{j-1}\{f_{i,mid,k,len}+f_{mid+1,j,k,0},f_{i,mid,k,0}+f_{mid+1,j,k,len}\} $$

代码如下：

```cpp

for(int mid=i;mid<j;mid++){
		f[i][j][k][len]=min(f[i][j][k][len],min(f[i][mid][k][len]+f[mid+1][j][k][0],f[i][mid][k][0]+f[mid+1][j][k][len]));
}
```
然后每计算完一个 $[i,j]$ 就考虑重新计算所有的 $f_{i,j,k,0}$。换言之，将所有 $f_{i,j,k,0}$ 替换为 $f_{i,j,k,K}$ 的最小值。

我们注意到这个做法十分劣。但是我们注意到区间 DP 中有很多减小常数的地方，比如区间个数实际约为 $n^2$ 的一半，复杂度瓶颈中枚举分割点的实际操作次数为 $\sum (j-i+1)$，约是 $n^3$ 的十分之一，再加上 $K\leq 5$ 的条件，卡进 1s 并非难事。


代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=1e18;
const int N=105;
int f[N][N][N][6],a[N]; 
signed main(){
    int n,K;
    cin>>n>>K;
    for(int i=1;i<=n+1;i++){
    	if(i<=n)cin>>a[i];
    	for(int j=0;j<=n;j++){
    		for(int k=1;k<=100;k++){
    			for(int len=0;len<=5;len++){
    				if(i-1!=j||len!=0)f[i][j][k][len]=inf;
				}
			} 
		}
	}
	for(int l=1;l<=n;l++){
		for(int i=1;i+l-1<=n;i++){
			int j=i+l-1;
			for(int k=1;k<=100;k++){
				for(int len=1;len<=K;len++){
					if(a[j]==k){
						f[i][j][k][len]=min(f[i][j][k][len],
			min(f[i][j-1][k][len-1],(len==K)?f[i][j-1][k][len]:inf)); 
					}
					if(a[i]==k){
						f[i][j][k][len]=min(f[i][j][k][len],
			min(f[i+1][j][k][len-1],(len==K)?f[i+1][j][k][len]:inf)); 
					}
					for(int mid=i;mid<j;mid++){
						f[i][j][k][len]=min(f[i][j][k][len],
						min(f[i][mid][k][len]+f[mid+1][j][k][0],
						f[i][mid][k][0]+f[mid+1][j][k][len]));
					}
				}
			}
			int MN=inf;
			for(int k=1;k<=100;k++){
				for(int len=1;len<=K;len++){
					MN=min(MN,f[i][j][k][len]+K-len);	
				}
			}
			for(int k=1;k<=100;k++){
				f[i][j][k][0]=MN; 
			}
		} 
	}
	cout<<f[1][n][1][0];
    return 0;
}
```

## 附

实测极端情况下分割点枚举约 $8\times 10^7$ 次。

---

## 作者：chrispang (赞：1)

## 题目大意

给定一个长度为 $n$ 的序列 $a$，你可以执行以下两种操作：

- 在任意位置插入一个数 $x$。
- 删除 $[l,r]$ 的数，要求：

   - $r-l+1 \ge m$。
   - $a_l=a_{l+1}=...=a_r$，即区间中的所有数相等。

问要把序列所有的数删掉（包括插入的数），至少需要插入多少个数。

$1\le n,a_i \le 100,1\le m\le 5$。

## 题目分析

遇到这类与区间有关的题目，可以尝试使用区间 DP。

再看看数据范围，可以让数据在 $O(n^4)$ 甚至更低的时间复杂度通过，因此考虑使用区间 DP。

### 定义

我们先假设 $f(l,r)$ 表示删掉 $[l,r]$ 中所有数需要插入多少个数。但是，这个状态有个致命缺陷：

- 它无法描述**区间外的弹子与区间内弹子的颜色关联**。例如，删除 $[i,j]$ 后，$i-1$ 位置的弹子可能与 $j+1$ 位置的弹子颜色相同，形成新的连续序列。但 $f(i,j)$ 只会关注 $[i,j]$ 内部，无法跟踪这种“外部关联”。

- 无法处理**合并后的长度计算**。例如，$[i,j]$ 右侧可能有 $k$ 个与 $a_j$ 同色的弹子，删除 $[i,j]$ 后，这些弹子会与 $[i,j]$ 内的同色弹子合并，总长度可能达到 $m$ 而无需插入。而 $f(i,j)$ 无法记录 $k$ 这个关键信息。

因此我们要考虑多加一维储存别的信息。

---

定义 $f(i,j,k)$ 表示把区间 $[j+1,n]$ 中 $\ne a_j$ 的数删除后（不算入代价），将 $[i,j]$ 与 $j$ 右边的前 $k$ 个数一起删掉的最小代价。

这样我们就可以处理上述问题了。

### 转移方程

转移方程会遇到两种情况：

- $f(l,r,k)=f(l,r-1,0)+(m-k-1)$，表示先将 $[l,r-1]$ 删除，再把 $a_r$ 与后面的 $k$ 个数删除的最小代价，这里 $m-k-1$ 中多出的 $-1$ 表示 $a_r$ 对答案的贡献。
- 若存在 $a_i=a_r(l\le i<r)$，则可以考虑先把 $[i+1,r-1]$ 删除后，再选择把 $a_i,a_r$ 以及后面 $k$ 个数删掉的代价，即 $f(l,r,k)=f(l,i,k+1)+f(i+1,r-1,0)$。

之后对上述转移取个 $\min$ 值即可。

### 初始化

$f(i,i,k)=m-k-1$。

## 代码

::::success[代码]
```cpp lines=24-35 line-numbers
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 110, M = 10;

int n, m, a[N];
int f[N][N][M];

// f[l][r][x] 表示删除了 [r + 1,n] 内所有不等于 a_r 的数”的前提下，“将 [l, r] 和 r 后面的前 x 个数共同删去”的代价 

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= m; j++)
			f[i][i][j] = m - j - 1;
	
	for (int l = n; l >= 1; l--) {
		for (int r = l + 1; r <= n; r++) {
			for (int k = 0; k <= m; k++) {
				f[l][r][k] = f[l][r - 1][0] + (m - k - 1);
				for (int i = l; i < r; i++)
					if (a[i] == a[r]) {
						int val = f[l][i][min(m - 1, k + 1)] + f[i + 1][r - 1][0];
						f[l][r][k] = min(f[l][r][k], val);
					}
			}
		}
	}
	
	cout << f[1][n][0] << endl;
	
    return 0;
}
```
::::

## 总结

::::info[豆包生成的废话，当然也有自己写的]

区间 DP 的题目不只是那个模板，仍需要投入很多思考在里面。我们的人生，就如同这道题一样，当你迷茫的时候，不妨再加一维，就算那看似增加了复杂度，却可能恰好捕捉到问题的关键关联。

就像这道题中，从二维的 $f(l,r)$ 到三维的 $f(l,r,k)$，多出的 $k$ 维度看似让状态更复杂，实则精准抓住了 “区间外同色弹子” 这个核心矛盾，让合并效应得以被量化和传递。这告诉我们，面对复杂问题时，与其困在固定框架里，不如敏锐观察那些被忽略的关联 —— 它们往往就是破局的关键。

最终，解题的本质不仅是找到答案，更是学会如何拆解问题、定义状态、传递信息。就像删除弹子的过程，每一步决策都要考虑后续的连锁反应，而人生的每一次选择，也需要我们看清那些 “隐藏的维度”，才能以最优的方式前行。
::::

---

## 作者：_H17_ (赞：1)

## 题目分析

首先对于有“序列”、“最少”、“最多”和一些操作（包括 $1$ 个）时，就应该想到区间 DP。

开始玩老套路，$f_{i,j}$ 表示从 $i\sim j$ 的答案。

结果发现没法转移，于是不得不更改成一个可行的状态。

我们经过分析，发现：插入操作比较难实现，不妨直接把插入后的连续值设进状态里：$f_{i,j,k}$ 表示 $i\sim j$ 最左边有大于等于连续 $k$ 个相同的珠子。

转移方程怎么推？首先考虑添加一个元素的：如果 $a_i=a_{i+1}$ 则 $f_{i+1,j,k}=f_{i,j,k+1}$。

既然维度很多，肯定有同区间的只有第 $3$ 个维度改变的转移：从连续更长的转移 $f_{i,j,k}=f_{i,j,k+1}+1$。

最常规的转移，从中间点 $x$ 让 $a_x\sim a_j$ 消掉。

当然 $k=K-1$（注意大写 $K$ 是表示题目中的 $K$）时，可以直接全部消除。

初始状态和最终答案：$f_{i,i,k}=K-k-1$（直接加上一堆珠子然后到 $K$ 消掉），答案显然是全部区间无特殊情况 $f_{1,n,0}$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[101],f[101][101][6];
int main(){
	memset(f,0x3f,sizeof(f));
	cin>>n>>k;
	for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        for(int k=0;k<::k;k++)
            f[i][i][k]=::k-k-1;//初始状态
    for(int l=2;l<=n;l++)//枚举长度
        for(int i=1,j;i<=n-l+1;i++){//左
            j=i+l-1;//右
            for(int k=::k-1;k>=0;k--){//注意转移用到了 k + 1，要倒着枚举
                if(k==::k-1)
					f[i][j][k]=min(f[i][j][k],f[i+1][j][0]);//清空
				else if(k<::k-1)
					f[i][j][k]=min(f[i][j][k],f[i][j][k+1]+1);//同阶段转移
				if(a[i]==a[i+1])
					f[i][j][k]=min(f[i][j][k],f[i+1][j][min(::k-1,k+1)]);//特殊情况转移
				for(int x=i+1;x<=j-1;x++)
					if(a[i]==a[x+1])
						f[i][j][k]=min(f[i][j][k],f[i+1][x][0]+f[x+1][j][min(::k-1,k+1)]);//常规情况转移 
            }
        }
	cout<<f[1][n][0];//答案
	return 0;
}
```

---


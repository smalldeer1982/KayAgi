# [COCI 2009/2010 #6] HOLMES

## 题目描述

 **译自 [COCI 2010.03.20](http://hsin.hr/coci/archive/2009_2010/) T5「[HOLMES](http://hsin.hr/coci/archive/2009_2010/contest6_tasks.pdf)」**

有 $D$ 个事件，编号分别为 $1\ldots D$。

福尔摩斯有 $M$ 组形如 $A\rightarrow B$ 的推论，表示「如果事件 $A$ 发生，那么事件 $B$ 一定会发生」。请注意，这不代表「如果 $A$ 不发生，$B$ 就一定不会发生」。

福尔摩斯的这 $M$ 组推论可以形成链式结构，例如 $A\rightarrow B\rightarrow C$，但一定不会形成环，如 $A\rightarrow B\rightarrow C\rightarrow \dots \rightarrow A$。

已知事件 $S_1\ldots S_N$ 会发生，试求哪些事件一定会发生。

> Update: 原题题意不清（或者是我语文太差），补充一句，这样才能解释样例 1。对于一个事件 $X$，如果存在推论 $Y_1\rightarrow X,$ $Y_2\rightarrow X$，那么「事件 $X$ 一定会发生」当且仅当『「事件 $Y_1$ 一定会发生」或「事件 $Y_2$ 一定会发生」……』

## 说明/提示

#### 样例说明 2
只知事件 3 发生，无法推出是事件 1 导致事件 3 发生还是事件 2 导致事件 3 发生。

#### 样例说明 3
事件 4 发生，则事件 2 和事件 3 至少有一者发生；  
无论是何者发生，其条件都是事件 1 一定发生；  
因为事件 1 一定发生，因此事件 2, 3 都一定发生。

#### 样例说明 4
事件 3 发生，则事件 1 和 2 一定有一者发生；  
若事件 1 和 2 中有任意一者发生，则事件 4 一定会发生。

#### 数据范围与提示
$1\le D\le 1000,$ $1\le M\le 10^5,$ $1\le N,$ $X_i,$ $A_i,$ $B_i\le D$.

## 样例 #1

### 输入

```
3 2 1
1 2
2 3
2```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
3 2 1
1 3
2 3
3```

### 输出

```
3```

## 样例 #3

### 输入

```
4 4 1
1 2
1 3
2 4
3 4
4```

### 输出

```
1 2 3 4
```

## 样例 #4

### 输入

```
4 4 1
1 3
2 3
1 4
2 4
3```

### 输出

```
3 4
```

# 题解

## 作者：Eleven谦 (赞：5)


#### 说明

2020.9.14的考试题

考场上没想出来，之后借鉴了学长的思路才改正。


------------
#### 思路

设给出的已知事件为 $x$

- 朴素想法

对于每个 $x$，显然所有子孙是要选的，那么我们就只需要考虑祖先怎么选。

首先任选一个父亲往上走直到走到一个入度为0的点 $top$，然后再从 $top$ 往下标记所有点（这些点就全部都要输出）

如果此时还存在一个入度为0且没被标记过的点能够走到 $x$，则说明 $x$ 的父亲相互矛盾，即样例二的情况，那么所有的父亲都不能选

但是，这样做就会遗漏掉一种情况，而且大概率会 $T$ 掉

- 完整思路

来看样例四，我们会发现：即使 $x=3$ 的父亲相互矛盾，但是输出却不止3，而还有4

这样我们的朴素算法就被 $Hack$ 掉了，看一下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/t218zdx9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

归纳一下，样例四的情况即：即使当前 $x$ 的所有父亲不能选，但是所有父亲有除 $x$ 以外的公共儿子（例如点4），那么这些公共儿子也一定会被选

这种情况怎么处理？

设当前已经确定要输出的数的个数为 $sum$

我们首先将每个点的所有祖先存入对应的 $set$ 中，然后对于每个不是 $x$ 的点 $i$ 进行一次 $check$，判断所有不在 $i$ 的路径上的点中已经被确定的数的个数 $cnt$ 是否等于 $sum$

如果小于 $sum$，则说明当前点 $i$ 一定会被选中输出。因为剩余的被确定的数（即 $sum-cnt$）只可能存在于当前点 $i$ 所在的路径上，那么 $i$ 一定会被选中

$check$ 算法框架：

1. 找到除当前点 $i$ 的父节点以外的入度为0的点

2. 然后遍历找到的这些点的子孙

3. 所有以上找到的点就是不存在于当前点 $i$ 路径上的点

有一点抽象，来看一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/dutxezjc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

则有：

```
set[1]={1}
set[2]={1,2}
set[3]={1,2,3}
set[4]={1,2,4}
set[5]={5}
set[6]={1,2,4,6}

```

假设当前点 $i=2$，那么 ${5，6}$ 就是找到的不存在于 $i$ 的路径上的点


------------
#### 代码

如果思路有些不懂也不要急，结合下面的代码理解，多画一下样例，就好了qwq

```cpp
#include <bits/stdc++.h>
using namespace std;
set<int> fa[20010];
int d,m,n,x,y,tot,sum;
int in[20010],vis[20010],head[200010],viss[20010];

struct node {
	int to,net;	
} e[200010];

void add(int u,int v) {
	e[++tot].to=v;
	e[tot].net=head[u];
	head[u]=tot;
}

void bfs1(int now) {
	queue<int> q;
	memset(viss,0,sizeof(viss));
	q.push(now);
	viss[now]=1;
	while(!q.empty()) {
		int xx=q.front();
		q.pop();
		fa[xx].insert(now);
		for(int i=head[xx];i;i=e[i].net) {
			int v=e[i].to;
			if(viss[v]) continue;
			q.push(v);
			viss[v]=1;
		}
	}
}

int check(int now) {
	queue<int> q;
	memset(viss,0,sizeof(viss));
	for(int i=1;i<=d;i++) {
		if(fa[now].find(i)==fa[now].end()&&!in[i]) q.push(i),viss[i]=1;  //除x的父节点以外入度为0的节点（即不在x的路径上） 
	}
	int cnt=0;
	while(!q.empty()) {
		int xx=q.front();
		q.pop();
		cnt+=vis[xx];  //统计其中被确定的数的个数 
		for(int i=head[xx];i;i=e[i].net) {
			int v=e[i].to;
			if(viss[v]) continue;
			viss[v]=1;
			q.push(v);
		}
	}
	return cnt;
}

void bfs2() {
	queue<int> q;
	for(int i=1;i<=d;i++) {
		if(vis[i]) q.push(i);
	}
	while(!q.empty()) {
		int xx=q.front();
		q.pop();
		for(int i=head[xx];i;i=e[i].net) {
			int v=e[i].to;
			if(vis[v]) continue;
			vis[v]=1;
			q.push(v);
		}
	}
}

int main() {
	scanf("%d%d%d",&d,&m,&n);
	for(int i=1;i<=m;i++) {
		scanf("%d%d",&x,&y);
		add(x,y);
		in[y]++;
	}
	for(int i=1;i<=n;i++) {
		scanf("%d",&x); 
		vis[x]=1;  //所有被确定的事件不用管 
		sum++;  //sum表示已经被确定的事件个数 
	}
	for(int i=1;i<=d;i++) bfs1(i);   //找到每个点i的所有祖先 
	for(int i=1;i<=d;i++) {
		if(vis[i]) continue;
		if(check(i)<sum) {  //如果不在i的路径上的点中被确定的数的个数小于sum，则说明当前i一定会被选 
			vis[i]=1;
			sum++;
		}
	}
	bfs2();   //最后遍历标记所有能被确定的数，输出 
	for(int i=1;i<=d;i++) {
		if(vis[i]) printf("%d ",i);
	}
	return 0;
}
```

------------






---

## 作者：ppip (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P5191)

定义：初始入度为 $0$ 的点为源点。

我们令 $S_i$ 为如果成立，就能够推出事件 $i$ 的源点集合。

则当事件 $i$ 成立时，显然 $S_i$ 中的点必有至少一个是真的。

所以我们只要把所有 $S_j$ 包含 $S_i$ 的事件 $j$ 都标记为真就行了。

bitset 实现，复杂度 $\Theta\left(\frac{D^3}{w}\right)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N{1000};
list<int> e[N+5];int ind[N+5];
bitset<N+5> s[N+5];
int d,m,n;
void TP()
{
    queue<int> q;
    for (int i{1};i<=d;++i)
        if (ind[i]==0) q.push(i),s[i][i]=1;
    while (q.size())
    {
        int u{q.front()};q.pop();
        for (auto v:e[u])
        {
            --ind[v];
            s[v]|=s[u];
            if (ind[v]==0) q.push(v);
        }
    }
}
int qp;
int pp[MAXN];
vector<int> ans;
int main()
{
    cin>>d>>m>>n;
    for (int i{1};i<=m;++i)
    {
        int a,b;
        scanf("%d %d",&a,&b);
        e[a].push_back(b);++ind[b];
    }
    TP();
    queue<int> q;
    for (int i{1};i<=n;++i)
        scanf("%d",&qp),pp[qp]=true,q.push(qp);
    while (q.size())
    {
        int u{q.front()};q.pop();
        ans.push_back(u);
        for (int j{1};j<=d;++j)
        {
            if (pp[j]!=0) continue;
            if ((s[j]&s[u])==s[u])
            {
                pp[j]=true;
                q.push(j);
            }
        }
        pp[u]=-1;
    }
    sort(ans.begin(),ans.end());
    for (auto x:ans) cout<<x<<" ";
    return 0;
}
```

---

## 作者：high_sky (赞：1)

## 题目大意
给你一个有向无环图，一条有向边 $(x,y)$ 代表如果 $x$ 发生了那么 $y$ 一定发生，求当 $d$ 个点 $x_1,x_2,\dots,x_d$ 发生时，有多少个点一定发生。

## 思路
看到这道题目就感觉跟子树有关，不难发现如果建了一个反图，那么如果 $x$ 发生，在反图上 $x$ 子树的点也一定发生，记录答案可以考虑用 `bitset` 维护，此时我们可以设 $ans_i$ 表示 $i$ 发生时，有哪些点一定发生。

我们再考虑一下 $x$ 的祖先有没有可能一定发生。

先从简单的考虑，就是如果 $x$ 在反图上只有一个父亲，那肯定直接继承 $ans_{fa}$。

我们再考虑一下有多个父亲的情况，样例也给出了。

我们假设已经处理了他所有父亲的 $ans$ 值，那么我们可以发现他们 $ans$ 中都有的点要么就是当前点 $x$ 在反图上的子树的点，要么就是他们共同的祖先，也就说，我们可以通过他们的 $ans$ 取交集得到这些祖先一定发生了，最后再用 $ans_x$ 与这些一定发生的祖先的 $ans$ 值取并集即可。

那么我们预处理的时间复杂度是 $\mathcal{O}(n^2)$ 的，其中还有一个小于 $1$ 的常数，我们在输入那 $d$ 个点的时候直接将他们的 $ans$ 取并集即可，最后按照输出格式就行了。

代码中找祖先的那一段考虑从原图中拓扑排序一下，这样写起来较为简单。

## 代码
其中有两个自己的样例在代码下面，没有给出那 $d$ 个已经发生的点，需要自己补充调试，仅供参考。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stdlib.h>
#include <cstring>
#include <vector>
#include <queue>
#include <bitset>
#define int long long
#define N 1005
using namespace std;
int n,m,d,du[N];
vector<int> g[N],g2[N];
queue<int> q;
bitset<N> ans[N];
signed main(){
	// freopen("detect.in","r",stdin),freopen("detect.out","w",stdout);
	cin >> n >> m >> d;
	for (int i = 1;i <= m;i ++) {
		int u,v;
		scanf("%lld%lld",&u,&v);
		g[v].push_back(u);
		g2[u].push_back(v);
		du[u] ++;
	}
	for (int i = 1;i <= n;i ++)
		if (du[i] == 0) q.push(i);
	while(!q.empty()) {
		int t = q.front();
		q.pop();
		ans[t][t] = 1;
		for (auto i : g[t]) {
			ans[i] |= ans[t];
			if ((--du[i]) == 0) q.push(i);
		}
	}
	for (int i = 1;i <= n;i ++) du[i] = g[i].size();
	for (int i = 1;i <= n;i ++) if (du[i] == 0) q.push(i); 
	while(!q.empty()) {
		int i = q.front();
		q.pop();
		for (auto j : g2[i])
			if ((--du[j]) == 0) q.push(j);
		if (g[i].empty()) continue; 
		bitset<N> t2;
		for (int j = 1;j <= n;j ++) t2[j] = 1;
		for (auto j : g[i]) t2 = t2 & ans[j];
		for (int j = 1;j <= n;j ++)
			if (t2[j]) ans[i] |= ans[j]; 
	}
	bitset<N> t;
	for (int i = 1;i <= d;i ++){
		int x;
		scanf("%lld",&x);
		t |= ans[x];
	}
	for (int i = 1;i <= n;i ++) if (t[i]) printf("%lld ",i);
	return 0;
}
/*
13 17 1
1 2
1 3
2 4
2 5
5 6
6 7
6 8
6 9
7 10
8 10
8 11
9 11 11 12
10 12
3 5
4 6
13 4

5 4 1
1 2
2 3
3 4
5 3
*/
```

---

## 作者：Fla_Akebono (赞：1)

# 题解：P5191 [COCI2009-2010#6] HOLMES

## I.题目大意

维护一个DAG，如果一个节点被染色，则其可达到的节点一定被染色，且一定存在一个可以直接到达该点的点被染色，给定已知被染色的k个点，输出一定会被染色的点的个数。

## II.问题分析

显然将子节点染色是好维护的。考虑对前驱的染色方案。显然，如果只有一个入度为 $0$ 的点可以到达被染色的点，等价与这个入度为 $0$ 的点被染色。考虑有多个入度为 $0$ 的点可以到达该节点。令 $S_1,S_2 \dots S_v$ 为这些点可达到的点的集合，同时令 $S=(S_1\cap S_2 \cap \dots \cap S_v)$ 为这些集合的交，则无论是那个入度为 $0$ 的点被染色，$S$ 中的点一定会被染色。在染色给定的点时判断即可。

## Code
```cpp
#include <algorithm>
#include <bitset>
#include <cmath>
#include <csignal>
#include <cstring>
#include <iostream>
#include <queue>
#include <set>
#include <vector>

using namespace std;
using ll = long long;
using Int = __int128_t;
#define pii pair<int, int>
#define For(x, n) for (int x = 1; x <= (n); x++)
#define Rof(x, n) for (int x = (n); x >= 1; x--)
#define resets(x) memset(x, 0, sizeof(x))
const int MAXN = 1e4 + 5, mod = 998244353, inf = 0x3f7f3f7f;

bitset<MAXN> able, son[MAXN], vis, vis1;
vector<int> edge[MAXN], redge[MAXN], f[MAXN];

int n, m, k;

void dfs(int now) {
    son[now][now] = vis[now] = 1;
    for (int to : edge[now]) {
        if (!vis[to]) {
            dfs(to);
        }
        son[now] |= son[to];
    }
}

void dfs1(int now) {
    if (able[now]) return;
    able[now] = 1;
    for (int to : edge[now]) {
        if (!able[to]) dfs1(to);
    }
}

void dfs2(int now, int s) {
    vis1[now] = 1;
    if (redge[now].size() == 0) {
        f[s].emplace_back(now);
    } else {
        for (int to : redge[now]) {
            if (!vis1[to]) dfs2(to, s);
        }
    }
}

void marge(int s) {
    bitset<MAXN> v{};
    v.flip();
    for (int i : f[s]) {
        v &= son[i];
    }
    if (v.any()) For(i, n) {
            if (v[i] && i != s) dfs1(i);
        }
}

void solve() {
    vector<int> x{};
    scanf("%d %d %d", &n, &m, &k);
    For(i, m) {
        int u, v;
        scanf("%d %d", &u, &v);
        edge[u].emplace_back(v);
        redge[v].emplace_back(u);
    }
    For(i, n) dfs(i);

    For(i, n) vis1.reset(), dfs2(i, i);

    For(i, k) {
        int u;
        scanf("%d", &u);
        x.emplace_back(u);
    }

    for (int now : x) {
        dfs1(now);
        if (f[now].size() == 1) dfs1(f[now].front());
        if (f[now].size() > 1) marge(now);
    }

    For(i, n) if (able[i]) printf("%d ", i);
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.in", "r", stdin);
#endif
    int t = 1, id;
    // scanf("%d %d", &t, &id);
    while (t--) {
        solve();
    }
    return 0;
}

```

#### 如果你的时间复杂度伪了，检查 dfs 函数的 vis 标记。

---

## 作者：naoliaok_lovely (赞：1)

# 题目大意
对于一个有向无环图，若节点 $i$ 为真，则它能到达的所有点均为真；如果存在边的终点为 $i$，则所有可以直接到达它的点中至少有一个为真。求最终一定为真的点的集合。

# 分析
设集合 $f_i$ 表示若 $i$ 号点为真，可以推出哪些点一定为真。注意，这里的 $f_i$ 指的是**直接推出**，而非**间接推出**。即：若 $j\in f_i,k\in f_j$，那么 $k\in f_i$ 不一定成立。这样定义主要是为了写代码的时候方便。当然了，那些间接推出的点在集合里当然更好，总之就是怎么简单怎么来。  

先处理第一类，即把当前点可以到达的那些点改为真。这个很好写，因为原图是一个 DAG（有向无环图），随便搞搞 DFS 就可以了。关键点在后面，怎么处理第二类情况？根据定义，我们会用到所有可以到达当前点的那些点，于是考虑——**反图**。对于原图的反图来说，先递归把 $i$ 号点能到达的点处理了，则 $f_i$ 应当加上那些能到达的点的 $f$ 集合的 **交集** 这些点。至于为什么是交集，我个人认为那些点在图中的性质是有些类似于 **割点** 的，手搓几组样例其实就很明白了。

# 代码
实现上，我用的 bitset 维护的 $f$ 集合，常数会小一点，代码的复杂度应该是 $O(n^2)$。
```
#include<bits/stdc++.h>
using namespace std;

const int N = 1010, M = 2e5 + 10;
int n, m, k;
bool flag[N];
bitset<N> f[N];

int h[N], h1[N], ne[M], e[M], idx;
void add(int h[], int a, int b)
{
	e[++idx] = b, ne[idx] = h[a], h[a] = idx;
}

void happen(int x)
{
	if(flag[x]) return;
	flag[x] = 1;
	
	for(int i = 1; i <= n; i++)
		if(f[x][i]) happen(i);
}

bool is[N];
void dfs(int x)
{
	if(is[x]) return;
	is[x] = 1;
	
	f[x][x] = 1;
	for(int i = h[x]; i; i = ne[i])
	{
		int j = e[i];
		dfs(j);
		f[x] |= f[j];
	}
}
void solve(int x)
{
	if(is[x]) return;
	is[x] = 1;
	
	if(!h1[x]) return;
	bitset<N> g;
	g = ~g;
	for(int i = h1[x]; i; i = ne[i])
	{
		int j = e[i];
		solve(j);
		g &= f[j];
	}
	f[x] |= g;
}

int main()
{
	cin >> n >> m >> k;
	for(int i = 1, a, b; i <= m; i++)
	{
		scanf("%d%d", &a, &b);
		add(h, a, b), add(h1, b, a);
	}
	
	for(int i = 1; i <= n; i++)
		dfs(i);
	memset(is, 0, sizeof(is));
	for(int i = 1; i <= n; i++)
		solve(i);
		
	for(int i = 1, a; i <= k; i++)
	{
		scanf("%d", &a);
		happen(a);
	}
	
	for(int i = 1; i <= n; i++)
		if(flag[i])
			printf("%d ", i);
	return 0;
}
```

---

## 作者：ybe2007 (赞：1)

应当说是一道想法题，想到了以后这题就不会太难了，因为涉及的算法也不是很高深。

首先稍稍转化一下题目，将这些事件转化为一个个节点，推论条件可视作有向边（~~这不显然~~）。然后不妨令某一个事件发生为某一个节点被标记，考虑对于每一个节点，如果其被标记，那么根据题意，其祖先中至少有 $1$ 个是被标记了的。注意：只要祖先中有，那么该节点就是被标记的。

这个基本思路的瓶颈在于，如何知道一个点的祖先中是否有被标记了的节点。这时我们可以用逆向思维，如果存在，那么除去祖先集合以外的其他点被标记数之和一定等于当前个数 $D$。具体地，为了彻底排除祖先对外部的影响，采用拓扑排序，对于每一个入度为 $0$ 的非祖先结点，加入队列，然后考察每一个加入队列的元素，如果被标记，$cnt$ 累加，最后判断 $cnt$ 是否等于 $D$。最后动态更新 $D$ 以及标记数组 $mark$。

如果还有不理解的地方，可以参照上述的方法手动模拟一下题面里的样例 $4$，加深理解。另外，某一个点的祖先结点显然是可以提前 $O(n)$ 预处理的，总时间复杂度 $O(n^2)$。具体可以参考代码。

```cpp
#include<bits/stdc++.h>
#define N 1005
#define M 100005
using namespace std;
int n,m,d;
int tot,ver[M],nxt[M],head[N],deg[N];
void add_E(int x,int y){ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
int tot2,ver2[M],nxt2[M],head2[N];
void add_E2(int x,int y){ver2[++tot2]=y,nxt2[tot2]=head2[x],head2[x]=tot2;}
bool mark[N],r[N],vis[N];
queue<int> q;
bool check(int S)
{
	int cnt=0;
	memset(r,0,sizeof(r));
	q.push(S);
	r[S]=1;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		for(int i=head2[x];i;i=nxt2[i])
		{
			int y=ver2[i];
			if(!r[y]) r[y]=1,q.push(y);
		}
	}
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++) if(!r[i]&&!deg[i]) q.push(i),vis[i]=1;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		if(mark[x]) cnt++;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];
			if(!vis[y]&&!r[y]) vis[y]=1,q.push(y);
		}
	}
	return cnt<d;
}
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add_E(x,y),deg[y]++;
		add_E2(y,x);
	}
	for(int i=1;i<=d;i++)
	{
		int x;
		scanf("%d",&x);
		mark[x]=1;
	}
	for(int i=1;i<=n;i++) if(check(i)&&!mark[i]) d++,mark[i]=1;
	for(int i=1;i<=n;i++) if(mark[i]) printf("%d ",i);
}
```

---

## 作者：Left_i_Forever (赞：0)

$\Large{\text{Solution}}$

模拟赛时看第三个样例（和本题一样）想到的，比较神秘……

从一个点往回走走到头，可能会有很多个结束的点。反过来，这些点都是拓扑的起点（入度为 $0$），并且都能走到这个点。例如第三个样例中的点都会走到 $1$ 这个点。

令第 $i$ 个点往回走到的终点的集合为 $s_i$，那么 $s_i$ 中必然有至少一个点是发生了的。由于没有其他条件，所以我们无法确定具体是谁发生了，但是可以推理。

对于每一个发生了的 $i$，枚举所有 $j$，若 $s_i$ 是 $s_j$ 的子集，那么 $j$ 一定发生了。注意到只有 $10^3$ 个点，所以 $\Omicron(n^2)$ 是可以接受的。

预处理 $s$ 可以在拓扑排序的时候使用 `bitset` 优化 DP。

$\Large{\text{Code}}$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
bitset <N> b[N];
vector <int> v[N], v2[N];
int in[N];
int n, m, d;
bool ans[N];

void topsort()
{
	queue <int> q;
	for (int i = 1; i <= n; i++)
		if (!in[i]) b[i][i] = true, q.push (i);
	while (q.size ())
	{
		int u = q.front ();
		q.pop ();
		for (int j : v[u])
		{
			in[j]--;
			if (!in[j]) q.push (j);
			b[j] |= b[u];
		}
	}
}

int main()
{
//	freopen ("detect.in", "r", stdin);
//	freopen ("detect.out", "w", stdout);
	cin >> n >> m >> d;
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		v[x].push_back (y);
		v2[y].push_back (x);
		in[y]++;
	}
	topsort ();
	for (int i = 1; i <= d; i++)
	{
		int x;
		cin >> x;
		for (int j = 1; j <= n; j++)
		{
			bitset <N> tep = b[x] & b[j];
			if (tep == b[x]) ans[j] = true;
		}
	}
	for (int i = 1; i <= n; i++)
		if (ans[i]) cout << i << " ";
	puts ("");
	return 0;
}
```

---

## 作者：Hog_Dawa_IOI (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/P5954)。  
注意：本题解思路和别的题解思路略有不同。    

数据范围有亿点小，完全可以在 $O(n^2)$ 内解决。   
以下文字中一个点被标记，当且仅当它代表的事件发生了。
我们暴力枚举每一个点，判断如果这个点没被标记，会不会导致某些输入中确定会被标记的点无法被标记。   
为了完成这句话，我们需要：

- 人为钦定某个点被标记。
- 为了让这个点不被标记，能到达这个点的点都不能被标记。因此需要反向建图，反过来把这个点的祖先们（反图上这个点的孩子们）都标记为不被标记。
- 同时对于其它没受影响的点，如果它入度为 $0$，那么应该把这个点标记。
- 再把这个图遍历一遍，按照题意模拟。如果一个点的父亲们中有至少一个被标记了，那么这个点也应当被标记。
- 最后检查是否有点应当被标记，但是在这种情况下没有被标记。如果有，那么只有当前被钦定不被标记的点被标记，才能让那个应被标记的点被标记。（因为其它不受当前点影响的点，能被标记的都被标记了，还是救不了它。）

这一套流程下来时间复杂度是 $O(n)$ 的，外层枚举那个被钦定的点也是 $O(n)$ 的，因此总的时间复杂度是 $O(n^2)$ 的。这样我们就能把那些必须被标记的点都找到。   
最后还要再 DFS 一遍，把那些必须被标记的点的后代们都打上标记。

马蜂有点丑。并且这里 DFS、BFS 混杂，可读性好像有点低……？
```cpp
#include<stdio.h>
int n,m,d,fir[1005],num,a,b;
int du[1005],numm,firr[1005];
struct ss{int ed,nxt;}
bia[100005],tuned[100005];
int coled[1005];
bool f[1005],cled[1005];
int que[1005],l,r,cntt[1005];
void clear(int wh)
{
	f[wh]=0,cled[wh]=1;
	for(int i=firr[wh];i;i=tuned[i].nxt)
	if(!cled[tuned[i].ed]) clear(tuned[i].ed);
}
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++) scanf("%d%d",&a,&b),du[b]++,
	bia[++num].ed=b,bia[num].nxt=fir[a],fir[a]=num,
	tuned[++numm].ed=a,tuned[numm].nxt=firr[b],firr[b]=numm;
	for(int i=1;i<=d;i++) scanf("%d",&a),coled[a]=2;
//你别问为什么这里要赋值为 2，这没什么关系的。
	for(int i=1;i<=n;i++) if(!coled[i])
	//如果输入本来就被染色那我也说不了什么了。 
	{
		for(int j=1;j<=n;j++) f[j]=(!du[j]),
		cntt[j]=du[j],cled[j]=0;l=r=0,clear(i);
		for(int j=1;j<=n;j++) if(!du[j]) que[++r]=j;
		while(l<r)
		{
			l++;for(int kk=fir[que[l]];kk;kk=bia[kk].nxt)
			{
				f[bia[kk].ed]|=f[que[l]],cntt[bia[kk].ed]--;
				if(!cntt[bia[kk].ed]) que[++r]=bia[kk].ed;
			}
		}
		for(int j=1;j<=n;j++) if(!f[j]
		&&coled[j]) {coled[i]=1;break;}
	}
	l=r=0;for(int j=1;j<=n;j++)
	{
		if(!du[j]) que[++r]=j;
		cntt[j]=du[j];
	}
	while(l<r)
	{
		l++;for(int kk=fir[que[l]];kk;kk=bia[kk].nxt)
		{
			coled[bia[kk].ed]|=coled[que[l]],cntt[bia[kk].ed]--;
			if(!cntt[bia[kk].ed]) que[++r]=bia[kk].ed;
		}
	}
	for(int i=1;i<=n;i++) if(!!coled[i]) printf("%d ",i);
}
```

---


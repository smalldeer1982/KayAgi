# [LnOI2019] 加特林轮盘赌

## 题目背景

加特林轮盘赌是一个养生游戏。

## 题目描述

与俄罗斯轮盘赌等手枪的赌博不同的是，加特林轮盘赌的赌具是加特林。

加特林轮盘赌的规则很简单：在加特林的部分弹夹中填充子弹。游戏的参加者**坐在一个圆桌上**，轮流把加特林对着自己的头，扣动扳机一秒钟。中枪的自动退出，坚持到最后的就是胜利者。

我们使用的是 2019 年最新技术的加特林，他的特点是**无需预热、子弹无限**，每一个人，在每一回合，中枪的概率是完全相同的 $P_0$。

每局游戏共有 $n$ 只长脖子鹿，从 1 长脖子鹿开始，按照编号顺序从小到大进行游戏，绕着圆桌不断循环。

游戏可能会循环进行多轮，直到场上仅剩下最后一只长脖子鹿时，游戏结束。

给出 $P_0$ 和 $n$，询问 $k$ 号长脖子鹿最终成为**唯一幸存者**的概率 $P_k$。

**如果 $P_0=0$，我们认为胜者为 $1$ 号。**

## 说明/提示

- 对于 $10\%$ 的数据，$n \le 100$。
- 对于 $30\%$ 的数据，$n \le 500$。
- 对于另外 $20\%$ 的数据，$k = n$。
- 对于 $100\%$ 的数据，$1 \le k \le n \le 10^{4}, 0 \le P_0 \le 1$。

所有数据的时间限制为 1000ms，空间限制为256MB，可开启 O2 优化。

## 样例 #1

### 输入

```
0.5 2 1```

### 输出

```
0.33333333```

## 样例 #2

### 输入

```
0.5 2 2```

### 输出

```
0.66666667```

## 样例 #3

### 输入

```
0.5 3 1```

### 输出

```
0.23809524```

## 样例 #4

### 输入

```
0.5 3 2```

### 输出

```
0.28571429```

# 题解

## 作者：诗乃 (赞：24)

说这个题目的$n$是$10^4$，当$n=0$和$n=1$的时候答案是显然的,然后我们考虑两个人的情况。比方说两个参赛者，一个yyy，一个雪碧。先崩yyy，如果他$P_0$的概率崩死了，那yyy没了，剩一个雪碧，雪碧赢了；如果他$(1-P_0)$的概率没死，那么游戏要继续呀。雪碧来到了第一位，yyy相当于到了第二位。其实这个局面，和开枪前没有区别，只不过是yyy和雪碧互换了位置罢了。

*//以上题解由$X$口述，朝田诗乃记录。*

这样，我们设$F[2][1]$表示第一个人**最终幸存**的概率，$F[2][2]$表示第二个人**最终幸存**的概率。

$$ F[2][1] = P_0 * 0 + (1-P_0) * F[2][2] $$

作为一个二元一次方程，我们还需要一个等式才能解出他们，不难想到：

$$ F[2][1] + F[2][2] = 1 $$

K个人呢？头两个式子我们可以抄上面的啊！

$$ F[n][1] = (1-P_0) * F[n][n] $$

$$ F[n][1] + F[n][2] + ... F[n][n] = 1 $$

当前我们在崩第1个玩家，这个时候排在第k位玩家的概率会是怎么样的呢?

概率$1-P_0$：如果第一个玩家没被崩死，所有人都向前走了一步！

$$F[n][k] -> F[n][k-1]$$

概率$P_0$：如果第一个玩家被崩死，所有人还是都向前走了一步！

$$F[n][k] -> F[n-1][k-1]$$

不过因为死了一个，所以总人数也少了一个。

故：

$$ F[n][k] = P_0 * F[n][k-1] + (1-P_0) * F[n-1][k-1] $$

这一共能给你$n$个等式。

由于最后有且仅有最后一个幸存者，所以有

$$\Sigma_{k=1}^{n}F[n][k] = 1$$

解n元一次方程，高斯消元能拿10pts。

手动消元就能100pts了。

最后要特判一下$P_0=0$的情况。

总复杂度$O(n^2)$

题解By X

*//朝田诗乃：居然被那么多人水过了QAQ*

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
using namespace std;
const int MAXN = 20050;
double p0; int n, k, cur = 1, last;
double f[2][MAXN];
int main() {
	cin >> p0 >> n >> k;
	f[1][1] = 1;
	if(p0 == 0) {
		if(n == 1) puts("1");
		else puts("0");
		return 0;
	}
	for(int i = 2; i <= n; ++i) {
		double a = 1, c = 0, A = 0, C = 0;
		last = cur; cur ^= 1;
		for(int j = 2; j <= i; ++j) a *= (1-p0), A += a, c = (1-p0) * c + p0 * f[last][j-1], C += c;
		f[cur][1] = (1-C) / (A+1);
		for(int j = 2; j <= i; ++j)
			f[cur][j] = p0 * f[last][j-1] + (1 - p0) * f[cur][j-1];
	}
	printf("%.10lf", f[cur][k]);
}

```

---

## 作者：wjyyy (赞：16)

## 题解

**[博客传送门]( http://www.wjyyy.top/3343.html)**

首先需要推出DP/递推方程，然后考虑进一步的优化。因为本题有阶段性，姑且称之为DP。

每次枪会对准一个人，这个人有 $P_0$ 的概率挂掉，**此时进入 $n-1$ 个人的状态**。

考虑到枪打人是轮流进行的，先后顺序和位次顺序都是有影响的。因此我们设 $f[i][j]$ 表示当剩下 $i$ 个人时，令枪对准的人是第一个人，第 $j$ 个人作为最后一个人存活下来的概率。

**“当前的”第一个人**有 $P_0$ 的概率挂掉。这之后，总人数从 $i$ 变成了 $i-1$，而枪会指向原来第二个人，那么原来的 $f[i][j]$ 在这样的**条件**下存活的概率是 $f[i-1][j-1]$。记为 $P_0f[i-1][j-1]$。

> **注：**条件指条件概率。

在 $1-P_0$ 的概率下，当前的第一个人不会挂掉，那么总人数不变，枪会指向原来的第二个人，那么第 $j$ 个人就变成了第 $j-1$ 个人，原来的 $f[i][j]$ 在这样的条件下存活的概率是 $f[i][j-1]$，记为 $(1-P_0)f[i][j-1]$。

因此有

$$f[i][j]=P_0f[i-1][j-1]+(1-P_0)f[i][j-1],j\ge 2$$

这样由于每次在前一个大阶段有了所有的 $f[i-1]$，就有了 $f[i][j],1\le j\le i$ 的 $i-1$ 个方程。根据逻辑关系我们知道 $\sum_{j=1}^if[i][j]=1$，把这个当作第 $i$ 个方程，这一组 $f[i]$就可以解了。

但是高斯消元是 $O(n^3)$ 的，对于每一行都做，那就是 $O(n^4)$ 的。实际上每一行可以做到线性。

由于 $P_0f[i-1][j-1]$ 已知，我们把这个数设为常数 $d_j$，则方程为

$$f[i][j]=d_j+(1-P_0)f[i][j-1],j\ge 2$$

此时可以通过这个式子减小第二维的 $j$，上面有个式子是

$$\sum_{j=1}^if[i][j]=1$$

把这个式子所有的 $j$ 都通过上面的方程迭代为 $f[i][1]$，方程的形式就变为了 $a\cdot f[i][1]+b=1$ 的形式，$a,b$ 都是常数，$f[i][1]$ 就被解出来了，再通过方程递推即可。

$$\begin{aligned}&f[i][1]&+&f[i][2]&+&\cdots+f[i][i]\\ =&f[i][1]&+&d_2+(1-P_0)f[i][1]&+&\cdots+d_i+(1-P_0)f[i][i-1]\end{aligned}$$

针对这个式子，从后往前递归处理就可以得到 $f[i][1]$ 的系数和常数项了。（实际上从前往后循环也可以，递归更好理解）

注意当 $P_0=0$ 时，当且仅当 $n=1$ 有 $P_1=1$，其余情况下都不可能成为唯一幸存者，需要特判。

时间复杂度 $O(n^2)$。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#define db double
db f[10010],d[10010],tmp,sum,p;
db a,b;
//a代表 f(x-1) 中 f1 的系数 b 代表 f(x-1) 的常数项
void calc(int x)
{
    if(x==1)
    {
        a=1;
        tmp=1;
        b=0;
        return;
    }
    calc(x-1);
    //tmp 代表已经积累的 f1 的系数 sum 代表常数项
    tmp+=(1-p)*a;
    sum+=p*d[x]+(1-p)*b;
    a=(1-p)*a;
    b=p*d[x]+(1-p)*b;
}
int main()
{
    int n,m;
    scanf("%lf%d%d",&p,&n,&m);
    if(p==0)
    {
        puts(n>1?"0":"1");
        return 0;
    }
    f[1]=1;
    d[2]=1;
    for(int i=2;i<=n;++i)
    {
        tmp=0.0,sum=0.0;
        calc(i);
        f[1]=(1-sum)/tmp;
        for(int j=2;j<=i;++j)
            f[j]=p*d[j]+(1-p)*f[j-1];
        for(int j=2;j<=i+1;++j)
            d[j]=f[j-1];
    }
    printf("%.10lf\n",f[m]);
    return 0;
}
```



---

## 作者：hfctf0210 (赞：10)

其实我的方法还是挺暴力的。令pw1[i]表示前(k-1)只长颈鹿自毙i次**以内**退役的概率，pw2[i]表示编号在k+1~n的长颈鹿自毙i次**以内**退役的概率。于是pw1[i]=s[i]^(k-1),pw2[i]=s[i]^(n-k)，其中s[i]为一只长颈鹿自毙i次以内退役的概率，很容易得到s[i]=1-(1-p)^i，因为一次中枪没有退役的概率为1-p，重复i次均退役则是(1-p)^i，所以i次内退役的概率就是1-(1-p)^i。因为题目中求的是小数，精度要求是10^-8，所以枚举第k只长颈鹿在第i次中枪时退役且为最后一个退役的概率，把所有概率加起来就行了，可以做到线性复杂度，枚举到10^6即可（我写的是线性10^5也过了）。注意要特判n=1/k=1/k=n的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+7;
int n,k;
double p,sp,ans,s[N],pw1[N],pw2[N];
double qpow(double a,int b)
{
    double ret=1;
    while(b)
    {
        if(b&1)ret*=a;
        a*=a,b>>=1;
    }
    return ret;
}
int main()
{
    cin>>p>>n>>k;
    if(n==1){cout<<1;return 0;}
    for(int i=1;i<=1e5;i++)s[i]=1-qpow(1-p,i);
    for(int i=1;i<=1e5;i++)pw1[i]=qpow(s[i],k-1),pw2[i]=qpow(s[i],n-k);
    for(int i=1;i<=1e5;i++)
    if(k==n)ans+=pw1[i]*(s[i]-s[i-1]);
    else if(k==1)ans+=pw2[i-1]*(s[i]-s[i-1]);
    else ans+=pw1[i]*pw2[i-1]*(s[i]-s[i-1]);
    printf("%0.9f",ans);
}
```


---

## 作者：Dancing_Wave (赞：9)

~~半年前被这道题卡到自闭……~~

感谢草稿纸的大力支援

------------

# [P5249[LnOI2019]加特林轮盘赌](https://www.luogu.org/problem/P5249) 题解

这篇题解主要是详细说明一下楼顶[诗乃的题解](https://www.luogu.org/blog/shoko/solution-p5249)

## 方程并非一定列为和为1，其实也可以用代入法

再讲一遍思路，顺便演示一下手动消元

题目让我们求n个 长脖子鹿 中第m个 长脖子鹿 唯一存活的概率，于是我们想到了dp

设现在开枪的这个 长脖子鹿 是第1个长脖子鹿 ，接下来是第2个，以此类推

设dp(i,j)为还有i个人时第j个 长脖子鹿 最终唯一存活的概率（满足i>=j)

那么dp(1,1)一定为1

我们要求的是答案是dp(n,m)

对于每一个dp(i,j)有两种情况：

### 第一种：j=1

现在“自杀”的是我们“关注”的长脖子鹿

ta不能死！~~蜜汁感性~~ 即ta必须不中枪，不中枪的概率为（ 1-P0 )

那么不中枪后ta变成了第i个人，一共有i个人，我们要求的是dp(i,i)

### 所以dp(i,1)=( 1-P0 )*dp(i,i)

---

### 第二种：2<=j<=i

现在“自杀”的长脖子鹿死不死都没什么关系了

不管那个自杀的死没死，我们关注的ta都会从**第j个**变成**第j-1个**

如果死了，人数为i-1，我们要求的是dp(i-1,j-1)

反之，人数仍为i，我们要求的是dp(i,j-1)

由于中枪概率是P0，不中枪概率是( 1-P0 )

### 所以dp(i,j)=P0 * dp(i-1,j-1) + ( 1-P0 ) * dp(i,j-1)

---

总结一下

### 当j==1

### dp(i,1)=( 1-P0 ) * dp(i,i)

### 否则

### dp(i,j)=P0 * dp(i-1,j-1) + ( 1-P0 ) * dp(i,j-1)

于是

```
 dp(i,1)
 
=(1-P0)*dp(i,i)

=(1-P0)*(P0*dp(i-1,i-1)+(1-P0)*dp(i,i-1))

=(1-P0)*(P0*dp(i-1,i-1)+(1-P0)*(P0*dp(i-1,i-2)+(1-P0)*dp(i,i-2)))

=(1-P0)*(P0*dp(i-1,j-1)+(1-P0)*……*（P0*dp(i-1,1)+(1-P0)*dp(i,1)

```

拆项得：

```
 dp(i,1）

=P0*[
	dp(i-1,i-1)*(1-P0)^1
	+dp(i-1,i-1)*(1-P0)^2
	+……
	+dp(i-1,1)*(1-P0)^(i-1)
    ]
+dp(i,1)*(1-P0)^i

（"^"指幂运算）

```

当n很大时，每次算（1-P0)^x 不可能用快速幂

所以我们在计算之前要预处理（1-P0)的1~n 次方

于是dp(i,1)=P0*(中间那一大坨）/（1-（1-P0)^i)

求出dp(i,1),dp(i,2)~dp(i,n)也很容易算出来了

注意求第i行的时候，第i-1行已经求出来了，所以中间那一大坨不要再拆开了！

记得P0=0时要特判，而且要用滚动数组存

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double mi[10010];
double dp[2][10010];//滚动数组
int main(){
	int n,m;
	double k;
	cin>>k>>n>>m;//k是P0
	if(k==0){//特判
		if(n==1)cout<<1<<endl;
		else cout<<0<<endl;
		return 0;
	}
	mi[0]=1;
	for(int i=1;i<=n;i++){
		mi[i]=mi[i-1]*(1.0-k);
	}
	dp[0][1]=1;
	for(int i=2;i<=n;i++){
		double sum=0;
		for(int j=2;j<=i;j++){
			sum+=(dp[0][j-1]*mi[i-j+1]);//如刚才描述
		}
		dp[1][1]=k*sum/(1.0-mi[i]);//求dp(i,1)
		for(int j=2;j<=i;j++){
			dp[1][j]=dp[1][j-1]*(1.0-k)+dp[0][j-1]*k;
		}
		for(int j=1;j<=i;j++){
			dp[0][j]=dp[1][j];
		}
	}
	printf("%0.8lf\n",dp[0][m]);
	return 0;
}
```

安利一下blog

# [点这里！](https://www.luogu.org/blog/xiaduowenboke/)

---

## 作者：Adove (赞：5)

我们设$f[n][i]$为剩余$n$人时，标号为$i$的人存活的概率

设$g[i]$为该轮第$i$个人被打成马蜂窝的概率

则有$g[i]=(1-p)^{i-1}p \sum_{j=0}^{\infty}(1-p)^{nj}$

根据等比数列求和公式

得$g[i]=\frac{(1-p)^{i-1}p}{1-(1-p)^n}$

然后一个人被打成马蜂窝后，得到一个新的局面

而这个局面可以作为子问题求解

前缀和优化一下即可$\Theta(n^2)$通过本题

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e4+5;
const double eps=1e-10;

double p0;
int n,c;
double f[MAXN],g[MAXN],h[MAXN];
double pw[MAXN],dpw[MAXN];

int main()
{
	scanf("%lf%d%d",&p0,&n,&c);
	pw[0]=dpw[0]=1;
	for(int i=1;i<=n;++i) pw[i]=pw[i-1]*p0,dpw[i]=dpw[i-1]*(1-p0);
	f[1]=1;
	for(int i=2;i<=n;++i){
		double sum=0;int cnt=0;
		for(int j=1;j<=i;++j) g[j]=dpw[j-1]*p0/(1-dpw[i]+eps);
		for(int j=1;j<i;++j) sum+=f[i-j]*g[j];
		for(int j=1;j<=i;++j){
			h[j==1?i:j-1]=sum;
			sum=(sum-g[i]*f[cnt])*dpw[1]+f[cnt]*g[1];
			++cnt;
		}for(int j=1;j<=i;++j) f[j]=h[j];
	}printf("%.9lf\n",f[c]);
	return 0;
}
```

---

## 作者：clamee (赞：5)

好像正解是高消来着，但这题为什么要高消呢？

可以设	$f[i]$ 表示在剩下了 $i$ 个人的轮盘赌中，第一个人活下来的概率。

显然有转移方程：

$f[i]=\sum_{j=1}^{i-1}\frac{p0^j(1-p0)^{n-j}C_{i-1}^{j}\cdot f[i-j]}{1-p0^i}$

然后考虑第 $k$ 个人和第 $1$ 个人的关系。

显然有 $ans=\sum_{i=0}^{k-1}(1-p0)^{k-1-i}\cdot p0^i\cdot C_{k-1}^{i+1}\cdot f[n-i]$

但由于这道题的精度开到了 1e-8 所以只有70分。

但是这个方程还可以继续优化成 O(n) 。

只需要考虑组合数的特殊性质即可。

但这没有什么意义，还是会被卡精度。

所以这题为什么不对概率取模然后出到 1e6 呢？

下面是没有优化复杂度的代码，只有 $70pts$ ，如果优化了的话精度误差会更大。

```
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define il inline
il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
il void write(int x)
{
	if(x<0){putchar('-');write(-x);return;}
	if(x<10)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}
#define p0 P0
double g[10005],f[10005],P0;
int n,k,jc[10005],inv;
signed main()
{
	cin>>P0>>n>>k;
	f[1]=1;
	double T=1.0-P0;
	if(P0+1e-11>1.0)
	{
		if(k==n)
		{
			puts("1.0000000000");
		}
		else
			puts("0.0000000000");
		return 0;
	}
	if(P0-1e-11<0.0)
	{
		puts("0.000000000");
		return 0;
	}
	double P=T*T;
	for(int i=2;i<=n;i++,P*=T)
	{
		double now=1.0/(1-P),t=P;
		for(int j=1;j<i;j++)
		{
			t=t*P0/T;
			t=t*(i-j)/(j);
			f[i]+=t*now*f[i-j];
		}	
	}
	double ans=0;
	P=pow(T,k-1);
	for(int i=0;i<k;i++)
	{
		ans+=P*f[n-i];
		P=P*P0/T*(k-i-1)/(i+1);
	}
	cout<<fixed<<setprecision(15)<<ans;
}
```


---

## 作者：___w (赞：4)

#### [P5249 [LnOI2019] 加特林轮盘赌](https://www.luogu.com.cn/problem/P5249)

考虑 dp，设 $f_{i,j}$ 为在 $i$ 只长脖子鹿中第 $j$ 只获胜的概率。

若 $j$ 不为第 $1$ 个时，由第 $1$ 个死或不死转移而来；若 $j$ 为第 $1$ 个时，自己不能死，所以只能从 $f_{i,i}$ 转移而来，注意下一轮 $j$ 变为了第 $i$ 个。有

$$f_{i,j}=\begin{cases}
  (1-p)⋅f_{i,j-1}+p⋅f_{i-1,j-1} & j>1 \\
  (1-p)⋅f_{i,i} & j=1
\end{cases}$$

观察方程式，假设前 $i-1$ 已求完，我们会发现这 $i$ 个状态相互之间有依赖关系，而且这个关系刚好为一个环。

那么我们可以假设 $f_{i,1}$ 为 $x$。则 $f_{i,2}$ 为 $(1-p)⋅x+p⋅f_{i-1,1}$，以此类推可以得出 $f_{i,i}$ 一定能写成 $ax+b$ 的形式，又有 $x=(1-p)⋅f_{i,i}$，所以能解出 $f_{i,1}$，再递推出其他状态即可。

这题空间有点紧，所以我们可以用滚动数组把 $i$ 这一维滚掉。

代码：

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') f = c == '-' ? -1 : f, c = getchar();
	while (c >= '0' && c <= '9') x = (x<<3)+(x<<1)+(c^48), c = getchar();
	return x*f;
}

inline void write(int x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x/10);
	putchar('0'+x%10);
}

const int N = 1e4+5;
const double eps = 1e-12;
int n, k, id = 1;
double p, a[N], b[N], f[2][N];

int main() {
	scanf("%lf%d%d", &p, &n, &k);
	if (fabs(p) < eps) puts(k == 1 ? "1" : "0"), exit(0);
	f[0][1] = 1; a[1] = 1;
	for (int i = 2; i <= n; ++i) {
		for (int j = 2; j <= i; ++j) {
			a[j] = a[j-1]*(1-p);
			b[j] = b[j-1]*(1-p)+f[id^1][j-1]*p;
		}
		f[id][1] = (1-p)*b[i]/(1-(1-p)*a[i]);
		for (int j = 2; j <= i; ++j) f[id][j] = f[id][j-1]*(1-p)+f[id^1][j-1]*p;
		id ^= 1;
	}
	printf("%.8lf", f[id^1][k]);
	return 0;
}
```

---

## 作者：lkwbian (赞：3)

看题解区没有，所以提供一种纯 DP，与解方程无关的 $O(n^2)$ 做法。

观察“养生游戏”的过程，将游戏想象为一排长脖子鹿，每次第一个开枪，死了就下一个继续，没死就回到队尾。考虑用长脖子鹿的死亡作为 dp 各个状态的转移。

什么状态能用长脖子鹿的死亡连接呢？不难想到 **人数** 。

只维护人数肯定是不行的，因为编号 $k$ 的特殊性没有体现出来。那就再加一维，维护一开始编号 $k$ 的长脖子鹿现在的位置。

状态 $dp_{i,j}$ 表示还有 $i$ 只长脖子鹿活着，一开始编号 $k$ 的长脖子鹿现在的位置为 $j$ 的概率。初始化 $dp_{n,k} \gets 1$。

转移就是某只长脖子鹿死掉了，设死掉的是 $k$ 位置的。

1. $k<j$，那么 $k$ 位置前的 $k-1$ 只都开枪没死，回到了队尾 （$j$ 的后面），$j$ 的新位置为 $j-k$，则 $dp_{i,j}$ 为 $dp_{i-1,j-k}$ 贡献了 $(1-p)^{k-1}p\times dp_{i,j}$。

2. $k>j$，那么 $k$ 位置前的 $k-1$ 只都开枪没死，$j$ 跟着前面的回到了队尾，$1-j$ 前面还有活着的 $i-k$ 只，则 $dp_{i,j}$ 为 $dp_{i-1,i-k+j}$ 贡献了 $(1-p)^{k-1}p\times dp_{i,j}$。

这两种都是给 $dp_{i-1}$ 做一次区间加公比相同的等比数列，可以差分维护。

然后你会发现答案偏小。为什么呢？因为漏了一种情况——转一轮一只长脖子鹿也没有死，这种概率为 $(1-p)^i$。不考虑这种情况则只有 $(1-(1-p)^i)dp_{i,j}$ 参与了转移，而这种情况下 $dp_{i,j}$ 的转移和上文是一模一样的（转一圈对状态没有改变）。所以只需每轮 $i$ 开始时 
$$
dp_{i,j} \gets \frac{1}{1-(1-p)^i}dp_{i,j}
$$
即可。

code :
```cpp
#include<bits/stdc++.h>
using namespace std;
double p;
int n,k;
double a[10005],dp[2][10005];
signed main(){
	ios::sync_with_stdio(0);cin.tie(nullptr);
	cin>>p>>n>>k;
	if(p==0){
		cout<<(k==1);
		return 0;
	}
	a[0]=1;
	for(int i=1;i<=n;i++)
		a[i]=a[i-1]*(1-p);//a[i]=(1-p)^i
	dp[n&1][k]=1;
	for(int i=n;i>1;i--){
		double tmp=1.0/(1.0-a[i])*p;
		for(int j=1;j<=i;j++){
			dp[i&1][j]*=tmp;
			dp[i+1&1][j-1]+=dp[i&1][j];//k=1~j-1 的差分
			dp[i+1&1][i-1]+=dp[i&1][j]*a[j],dp[i+1&1][j-1]-=dp[i&1][j]*a[i];//k=j~i的差分
			dp[i&1][j]=0;//注意滚动数组清空！！！
		}
		for(int j=i-2;j;j--)
			dp[i+1&1][j]+=dp[i+1&1][j+1]*(1-p);//差分做前缀和
	}
	printf("%.10f",dp[1][1]);
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P5249)

~~期望真 nm 有意思，所以蒟蒻又来颓期望辣~~

先特判掉 $P_0=0$ 的情况，下面假设 $P_0\ne 0$。

首先注意到我们每次将加特林对准一个人，如果这个人被毙掉了，那么相当于进入了 $n-1$ 个人的状态，否则等价于每个人都向前移动了一个位置，原来第 $k$ 个位置上的人挪到了第 $k-1$ 个位置上，故我们考虑设 $dp_{i,j}$ 表示在有 $i$ 个人的状态下，第 $j$ 个人成为唯一的幸存者的概率。考虑转移，这里不妨假设 $j>2$，考虑第一个人是否被毙掉，如果被毙掉了那么相当于 $i-1$ 个人中第 $j-1$ 个人成为唯一幸存者的概率，即 $P_0dp_{i-1,j-1}$，否则每个人都向前挪了一位，原来第 $j$ 个人变成了第 $j-1$ 个人，即 $(1-P_0)dp_{i,j-1}$，故我们有 $dp_{i,j}=P_0dp_{i-1,j-1}+(1-P_0)dp_{i,j-1}$，这样可以得到 $i-1$ 个方程，可是要求出每个 $dp_{i,j}$ 至少要 $i$ 个方程啊……别急，显然最终幸存者一定存在于这 $i$ 个人当中，因此所有 $dp_{i,j}$ 的和为 $1$，即 $\sum\limits_{j=1}^idp_{i,j}=1$，这样就有 $i$ 个方程了，可高斯消元了，复杂度 $n·n^3=n^4$，一脸过不去的样子。

注意到这题中方程组的特殊性，如果我们先求出 $dp_{1}$，在求出 $dp_2,dp_3,\cdots$，那么在求 $dp_{i,j}$ 时，$P_0dp_{i-1,j-1}$ 必定是一个常数，也就是说前面 $i-1$ 个方程都可以写成 $dp_{i,j}=adp_{i,j-1}+b_j$ 的形式，因此我们考虑将所有 $dp_{i,j}$ 都表示为 $x_jdp_{i,1}+y_j$ 的形式，这显然可以在线性时间内求出，具体来说就 $x_j=(1-P_0)x_{j-1},y_j=(1-P_0)y_{j-1}+P_0dp_{i-1,j-1}$，线性递推即可，这样最后 $\sum\limits_{j=1}^idp_{i,j}=1$ 就可以化为 $(\sum\limits_{j=1}^ix_j)dp_{i,1}+(\sum\limits_{j=1}^iy_j)=1$，简单解个方程即可求出 $dp_{i,1}$，然后再回代递推出其他 $dp_{i,j}$ 即可，这样复杂度即可降到 $n^2$。

由于每次我们求 $dp_i$ 只用到 $dp_{i-1}$ 的值，因此需采用滚动数组优化空间，这样空间复杂度即可降到 $\mathcal O(n)$。

```cpp
const int EPS=1e-8;
const int MAXN=1e4;
double p0;int n,k;
double pre[MAXN+5],cur[MAXN+5];
double calc(int n){
	double sa=1,sb=0,cur=1,sum=0;
	for(int i=2;i<=n;i++){
		cur*=(1-p0);sum*=(1-p0);sa+=cur;
		sum+=pre[i-1]*p0;sb+=sum;
	} return (1-sb)/sa;
}
int main(){
	scanf("%lf%d%d",&p0,&n,&k);
	if(p0==0) return printf("%d\n",(n==1)?1:0),0;
	pre[1]=1;
	for(int i=2;i<=n;i++){
		cur[1]=calc(i);
		for(int j=2;j<=i;j++) cur[j]=cur[j-1]*(1-p0)+pre[j-1]*p0;
		for(int j=1;j<=i;j++) pre[j]=cur[j];
	} printf("%.10lf\n",pre[k]);
	return 0;
}
```



---

## 作者：feecle6418 (赞：3)

### 本题解没有经过代码验证，若存在问题请直接指出

思路来源于 https://www.luogu.com.cn/blog/user3525/solution-p5249

我们快进到这个式子 

$$
\sum_{i\ge 1} (1-(1-p)^i)^{k-1}(1-(1-p)^{i-1})^{n-k}((1-p)^{i-1}-(1-p)^i)
$$

设 $q=(1-p)$；

$$
\sum_{i\ge 1} (1-q^i)^{k-1}(1-q^{i-1})^{n-k}(q^{i-1}-q^i)
$$

$$
=\sum_{i\ge 1}\sum_{0\le x\le k-1}\binom{k-1}x(-1)^xq^{(k-1-x)}\sum_{0\le y\le n-k}\binom{n-k}y(-1)^yq^{i(n-k-y)-(n-k-y)}(q^{i-1}-q^i)
$$

$$
=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^y\sum_{i\ge 1}(q^{i-1}-q^i)q^{i(n-k-y)-(n-k-y)}q^{i(k-1-x)}
$$

$$
=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^y\sum_{i\ge 1}(q^{i-1}-q^i)q^{i(n-y-1-x)-(n-k-y)}
$$

$$
=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^yq^{y+k-n}\sum_{i\ge 1}q^{i(n-y-x)-1}-q^{i(n-y-x)}
$$

---

设 

$$
t=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^yq^{y+k-n}\sum_{i\ge 1}q^{i(n-y-x)}
$$

则只需求 $-t+\dfrac 1q t$。

$$
=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^yq^{y+k-n}\dfrac{q^{n-y-x}}{1-q^{n-y-x}}
$$

$$
=\sum_{0\le x\le k-1}\binom{k-1}x(-1)^x\sum_{0\le y\le n-k}\binom{n-k}y(-1)^y\dfrac{q^{k-x}}{1-q^{n-y-x}}
$$

$$
=\sum_{t}\dfrac{(-1)^t}{1-q^{n-t}}\sum_{x+y=t}\binom{k-1}x\binom{n-k}y(-1)^yq^{k-x}
$$

$$
=\sum_{t}\dfrac{(-1)^tq^k}{1-q^{n-t}}[x^t](1-x)^{n-k}(1+\dfrac{1}{q}x)^{k-1}
$$


即需要解决：给定 $a,b,n,m$，求 $(1+ax)^n(1+bx)^m$ 的所有系数。

$$
f(x)=(1+ax)^n(1+bx)^m
$$

$$
\ln f(x)=n\ln(1+ax)+m\ln (1+bx)
$$

$$
\dfrac{f'(x)}{f(x)}=n\dfrac{a}{1+ax}+m\dfrac{b}{1+bx}
$$

$$
f'(x)=f(x)(n\dfrac{a}{1+ax}+m\dfrac{b}{1+bx})
$$

$$
(n+1)f_{n+1}=f'_n=\sum_{i=0}^n f_i(na\times (-a)^{n-i}+mb\times (-b)^{n-i})
$$

可以线性递推。

综上，在**忽略精度误差**的情况下应该可以线性解决本题。

不过其它题解从 dp 出发也可以线性解决，所以这个方法不仅傻逼而且没啥意义。

---

## 作者：tommymio (赞：2)

和约瑟夫问题不太相同，我们可以直接独立每个人在第 $i$ 轮的退出概率，但是概率是条件概率，可能会出问题。并且，为了取到 $\infty$ 轮，我们需要求极限。不妨思考一种更简单的解法。

设 $f_{i,j}$ 为仅剩 $i$ 个人时，第 $j$ 个人存活到最后的概率。假设在剩下 $i$ 个人时，第 $1$ 个人退出了，那么此时还剩下 $i-1$ 个人，第 $2$ 个人变成了第 $1$ 个人，第 $j$ 个人变成了第 $j-1$ 个人。假如第 $1$ 个人没有退出，轮到第 $2$ 个人扣动扳机，第 $2$ 个人就变成了第 $1$ 个人，第 $j$ 个人就变成了第 $j-1$ 个人，但是总人数不变。记每一轮中枪的概率为 $P$，于是我们得到：

$$
f_{i,j}=f_{i-1,j-1}\times P+f_{i,j-1}\times (1-P)
$$

似乎可以直接 $O(n^2)$ 求出？但是很不幸，这个方程有后效性，需要高斯消元。行与行之间没有后效性，所以对于每一行分别消元，我们可以 $O(n^4)$ 求出每个 $f_{i,j}$，直接 $\text{TLE}$。

想想看，是不是还有什么没有考虑到的？我们突然发现对于剩下 $i$ 个人的情况，每一个人最终存活这一事件覆盖了整个状态空间。形式化的说，有：

$$
\sum_{j=1}^if_{i,j}=1
$$

看过《具体数学》的同学应该非常快能够反应过来，$f_{i,j}$ 的转移式事实上是对 $j$ 的一个放缩！（是不是像极了组合数的放缩？）经过尝试，我们发现 $f_{i,j}$ 能够被化成一个与 $f_{i-1}$ 项和 $f_{i,1}$ 相关的柿子，而 $f_{i-1}$ 项之前已被求出。形式化的说，我们能够得到一个 $af_{i,1}+b=1$ 的柿子，然后就可以解出 $f_{i,1}$，回带得到 $f_i$ 项。

那我们来尝试求出 $a_i$。记 $\forall j,f_{i-1,j}=d_j$，大力推柿子，可以得到 $f_{i,j}=(1-P)^{i-1}f_{i,1}+\sum\limits_{x=1}^{i-1}d_xP(1-P)^{i-x-1}$。利用 $2$ 阶前缀和的思想（没听说过可以去做[[JXCSP2019]和积和](https://www.luogu.com.cn/problem/P5686)），最终可以得到：

$$
\sum_{j=1}^if_{i,j}=\left(\sum_{x=0}^{i-1}(1-P)^x\right)f_{i,1}+\sum_{x=0}^{i-2}d_{i-x-1}P\left(\sum_{y=0}^x(1-P)^y\right)=1
$$

直接解这个方程，回带，一轮轮迭代即可。这题告诉我们，很多具有特殊性质的方程，往往需要挖掘性质手动求解而非暴力高斯消元，因为高斯消元解方程的过程往往不是一个最优的过程。

**Show the Code**

```cpp
#include<cstdio>
double f[2][10005];
int main() {
    double P;
    int n,k;
    scanf("%lf%d%d",&P,&n,&k);
    if(n!=1&&P==0) {printf("0\n");return 0;}
    f[0][0]=1.00;
    for(register int i=1;i<=n;++i) {
        int cur=i&1; 
        double tmp1=1.00,tmp2=1.00,sum=1.00;
        for(register int j=0;j<=i-2;++j) {tmp1-=P*sum*f[cur^1][i-j-1];tmp2*=(1-P);sum+=tmp2;}
        f[cur][1]=tmp1/sum;
        for(register int j=2;j<=i;++j) f[cur][j]=f[cur^1][j-1]*P+f[cur][j-1]*(1-P);
    }
    printf("%.9lf\n",f[n&1][k]);
    return 0;
}
```


---

## 作者：轻舟XY (赞：2)

[更好的阅读体验](https://www.cnblogs.com/DReamLion/p/15379928.html)

[P5249 [LnOI2019]加特林轮盘赌](https://www.luogu.com.cn/problem/P5249) 

**期望+高斯消元** 

因为是个环，不妨把这 $n$ 只鹿想成排了一队，每次是队首拿加特林，他开一枪只有两种可能，要么在那 $P_0$ 的概率里中枪了，要么在剩下的 $1-P_0$ 的概率里没中枪，没中枪的话他就跑到队尾去当最后一只鹿了。

设 $f_{i,j}$ 表示有 $i$ 只鹿，第 $j$ 只赢的概率。

就有了一个比较好想的状态转移方程：
$$
f_{i,j}=P_0f_{i-1,j-1}+(i-P_0)f_{i,j-1}  \ ,j\in[2,i]
$$
其中 $f_{i-1,j-1}$ 表示当前这只鹿死了，整体来看少了一只，这是有 $P_0$ 的概率的；$f_{i-1,j-1}$ 表示当前这只鹿没死，总数不变，这是有 $(1-P_0)$ 的概率的。

因为最后有且仅有一个幸存者，所以所有鹿做幸存者的概率和为 $1$，得到：
$$
\sum_{j=1}^if_{i,j}=1
$$
$i$ 个方程找全了，看起来可以高斯消元了 ，但是 $n$ 的范围是 $10^4$，现在需要考虑优化，也就是手动高斯消元。

尝试把上面那个转移看成一个 $y=kx+b$ 形式的一次函数，设 $y=f_{i,j}$，$x=f_{i,j-1}$，那么 $k=(i-P_0)$，常数项就是 $P_0f_{i-1,j-1}$。

发现这样设是可行的，因为 $f_{i-1,j-1}$ 是在之前已经算出来的，而 $f_{i,j-1}$ 可以由 $f_{i,j-2}$ 得到，$f_{i,j-2}$ 可以由 $f_{i,j-3}$ 得到，$f_{i,j-3}$ 可以由 $f_{i,j-4}$ 得到……直到这一串由 $f_{i,1}$ 得到。

所以 $f_{i,j}$ 就是一个关于 $f_{i,1}$ 的一次函数。求出这个函数，代入最后一个方程 $a\cdot f_{i,1}+b=1$，就能求出 $f_{i,1}$， 进而求出所有的。

注意特判一下 $P_0=0$ 的情况。

**$code$** 

```cpp
#include<bits/stdc++.h>
#define N 1000010
#define int long long
#define debug cout<<"------------------"<<endl
using namespace std;

int n,k;
int now=1,lst=0;
double p0;
double fac[N],f[2][N];

signed main(){
    cin>>p0>>n>>k;
    if(p0==0) printf("%d\n",(n==1)?1:0),exit(0);
    fac[0]=1;
    for(int i=1;i<=n;i++) fac[i]=(1-p0)*fac[i-1];

    f[1][1]=1;
    for(int i=2;i<=n;i++){
        lst=now,now^=1;
        double sum=0;
        for(int j=1;j<=i-1;j++) sum+=fac[i-j]*f[lst][j];
        for(int j=1;j<=i;j++){
            f[now][j]=sum;
            sum=(1-p0)*(sum-fac[i-1]*f[lst][j])+f[lst][j];
        }
        sum=p0/(1-fac[i]);
        for(int j=1;j<=i;j++) f[now][j]*=sum;
    }

    printf("%.10f",f[now][k]);
    return 0;
}
```



---

## 作者：MoonCake2011 (赞：1)

直接可以看出此题是概率 dp。

设 $dp_{i,j}$ 为一共 $i$ 个人在赌第一个人，第 $j$ 个人的存活概率。

最终答案为 $dp_{n,k}$。

首先，我们可以让要赌的队列整体移动，而不是让枪移动。

所以推出 $dp_{i,j}=p \times dp_{i-1,j-1}+(1-p)\times dp_{i,j-1}$。

因为第一个人给自己玩没了，概率为 $1-p$，你向前移动，人数减 $1$。

否则人数不减。

此处定义 $j=1$ 时，$j-1=n$。

因为是一直在转的。

所以 $dp_{i,2}$ 的计算需要 $dp_{i,1}$，$dp_{i,3}$ 的计算需要 $dp_{i,2}$，一大堆类似的与 $dp_{i,n}$ 计算需要 $dp_{i,1}$。

什么，环形的 dp。

继续分析，第一维是没有后效性的。

所以直接循环枚举。

第二维有 $n$ 个式子，$n$ 个变量。

可以高斯消元然后消 T 了。

又注意到每个变量的计算只需用到另一个变量。

于是设 $dp_{i,1}=x$ 并用 $x$ 去表示 $dp_{i,x}$。

推下去，$dp_{i,n}$ 可以用 $x$ 表示。

并且与 $x$，也就是 $dp_{i,1}$ 有另一个关系。

那么这样就可以解出 $dp_{i,1}$。

知道 $dp_{i,1}$，正常递推可得 $dp_{i,x}$。

因为空间问题，所以滚动数组。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
double p;
struct node{//封装一次代数式 ax+b
	double a,b;
	node(double x=0,double y=0){
		a=x,b=y;
	}
}f[2][10010];
double dp[2][10010];
node operator * (double y,node x){//代数式的乘
	x.a*=y,x.b*=y;
	return x;
}
node operator + (node x,double y){//代数式的加
	x.b+=y;
	return x;
}
signed main() {
	cin>>p>>n>>k;
	if(p==0){//特判 
		if(n==1) cout<<1;
		else cout<<0;
		return 0;
	}
	dp[1][1]=1,f[1][1]=node(1,0);//初始值 
	for(int i=2;i<=n;i++){//注意滚动数组 
		f[i&1][1]=node(1,0);//代数式初始值 
		for(int j=2;j<=i;j++) f[i&1][j]=(1-p)*f[i&1][j-1]+p*dp[(i&1)^1][j-1];//推下去
		dp[i&1][1]=(1-p)*f[i&1][i].b/(1-(1-p)*f[i&1][i].a);//算出 dp[i][1]
		for(int j=2;j<=i;j++) dp[i&1][j]=(1-p)*dp[i&1][j-1]+p*dp[(i&1)^1][j-1];//第二次推
	}
	cout<<dp[n&1][k]; 
	return 0;
}
```

---

## 作者：红黑树 (赞：1)

[可能更好的阅读体验](https://rbtr.ee/luogu-P5249)

## [题意](https://www.luogu.com.cn/problem/P5249)

~~由于题目比较搞笑，就不简述题意了，大家自己看看吧（~~

## 题解
这题最关键的一点是搞清楚只有两个人的情况。

如果第一个人以 $P_0$ 的概率被崩了，那么第二个人就赢了。如果第一个人以 $\left(1 - P_0\right)$ 的概率没被崩，那么此时相当于两人交换了位置。

设 $f_{n, i}$ 表示有 $n$ 个人时，第 $i$ 个人最终幸存的概率。

显然 $f_{2, 1} = \left(1 - P_0\right) \times f_{2, 2}$，而所有人的最终幸存的概率之和应该为 $1$，因此 $f_{2, 1} + f_{2, 2} = 1$，于是可以解出它们。

现在假设有 $n$ 个人，按照两个人的情况扩展：
$f_{n, 1} = \left(1 - P_0\right) \times f_{n, n}$ 且 $\sum\limits_{i = 1}^nf_{n, i} = 1$。

我们还需要几个式子才能解方程。现在考虑一下递推关系：

如果第一个玩家以 $P_0$ 的概率被崩，那么局面变为 $f_{n - 1, k - 1}$。

否则第一个玩家以 $\left(1 - P_0\right)$ 的概率没被崩，那么局面变为 $f_{n, k - 1}$。

因此：$f_{n, k} = P_0 \times f_{n, k - 1} + \left(1 - P_0\right) \times f_{n - 1, k - 1}$

这样我们就有 $n$ 个方程了，手动解方程即可达到 $\mathcal O\left(n^2\right)$ 的复杂度。

---

## 作者：约瑟夫用脑玩 (赞：1)

## Part 1

第一眼就想到了游戏本质只有 $O(n^2)$ 种状态，只与剩的人和剩的人在哪里有关。

因为你到了一个位置后就不会管被打死的人具体的编号，你对答案会有影响的只是你隔最后钦定活下来的人的距离，当然还有总人数因为你可能转了一圈。

即还剩下了 $i$ 个人，当前打到第 $j$ 个人，设从这个时候开始的答案为 $f_{i,j}$。

假设第一个人是被钦定活下来的人，每次打一个往编号更大的转，那么转移是：$f_{i,j}=P_0f_{i-1,j}+(1-P_0)f_{i,j+1}$。

解释：下一个要打的人肯定是在当前编号下为 $j+1$ 的人，如果当前人被打死了，那么人数减少且编号前移转移到 $f_{i,j-1}$，否则不变正常转移。

注意这里第二维的编号要对 $i$ 取模。

坏消息是发现转移会出一个环，好消息是这个环看上去很简单。

事实上每个环第一维都一样，也就是只会在第二维成环，那么只观察第一维不变时的第二维转移，发现就是 $f_{i}(j)\leftarrow pf_i(j+1)$，也就是由后一项转移过来，显然可以直接手动递推得到系数。

然后就听隔壁 lsy 说各种掉精度的办法和应对方案直接把我劝退了。

lsy 声称掉精度的可能性大概就两种，**这两种必定掉**：

- 大正数加大负数。

  e.g. $(10^{100}+10)+(-10^{100})\to0$

- 大数乘小数，相当于是放大了误差。

  e.g. $(1\times10^{-10})\times 10^{10}\to 1$

  $(0\times 10^{-10})\times 10^{10}\to 0$

## Part 2

然后在题解区看到了一种做法神奇但是说话及其奇怪的题解，我用人话来详细说明。

由于这道题会掉精度，但是我们只要求在一定误差范围内的答案。

于是我们不使用精确求法再想办法不掉精度，我们直接用原本正确但不精确的求法去逼近精确的答案。

设第 $i$ 轮只剩它一个的概率为 $g_i$，我们希望答案应该是形如 $ans=\sum\limits_i^\infty x_ig_i$ 的形式，其中 $x_i$ 应当是一个简单且误差不大的系数。

但是不舒服的是第 $i$ 轮只剩它和第 $i+1$ 轮只剩它的部分有重合，也就是说我们还得略微容斥一下减去贡献，那么系数肯定就不太简单。

考虑直接在第 $i$ 轮把它打死，也就是第 $i$ 轮**到它时**只剩它一个且恰在这一轮当中它死了，设概率为 $p_i$。

发现这样所有情况就不重复了，并且我们累加到无限后显然概率是对的，也就是 $ans=\sum\limits_i^\infty p_i$，系数为 $1$ 直接累加即可。

考虑怎么求 $p_i$，发现在它前面的人都得在 $i$ 轮前被打死，在它后面的人由于最后一圈转不过去得在 $i-1$ 轮前被打死。

然后在强制自己恰在 $i$ 轮被打死，因为我们不能和其他情况有重叠而使得答案错误。

一个人在第 $x$ 轮前被打死的概率为 $q_x=1-(1-p)^x$，就是 $1$ 减去前 $x$ 轮一直没打死的概率。

那么前面 $k-1$ 个人都打死直接累乘即可，设为 $left_i=q_i^{k-1}$。

后面的 $n-k$ 个人同理，设为 $right_i=q_i^{n-k}$。

恰在当前打死也很简单，就是 $now_i=q_i-q_{i-1}$。

于是 $p_i$ 就能求了，有 $p_i=left_i\times now_i\times right_{i-1}$。

答案为 $\sum\limits_i^\infty p_i$，显然我们累计不到 $\infty$，那累计多少？~~当然是能累多少累多少。~~

实测累到 $10^5$ 就能过了，~~具体误差未知~~，其实是具体误差不会算。

变量名取得很好的代码：

```
int n,ps;
#define db double
db lft[Mx+5],rgt[Mx+5];
db out_in_x_turns[Mx+5],out_on_x_turns[Mx+5];
inline db Ksm(db x,int y)
{
	db s=1;
	for(;y;y>>=1)
	{
		if(y&1)s*=x;
		x*=x;
	}
	return s;
}
db ans;
signed main()
{
	#ifndef ONLINE_JUDGE
	freopen("_.in","r",stdin);
//	freopen("_.out","w",stdout);
	#endif
	int i;
	db p,live_in_x_turns=1;
	scanf("%lf",&p);
	n=read();ps=read();
	if(n==1)return writenum(1,10),output;
	for(i=1;i<=Mx;i++)
	{
		live_in_x_turns*=1-p;
		out_in_x_turns[i]=1-live_in_x_turns;
		out_on_x_turns[i]=out_in_x_turns[i]-out_in_x_turns[i-1];
		lft[i]=Ksm(out_in_x_turns[i],ps-1);
		rgt[i]=Ksm(out_in_x_turns[i],n-ps);
	}
	for(i=1;i<=Mx;i++)
	{
		if(ps==n)ans+=lft[i]*out_on_x_turns[i];
		if(ps==1)ans+=rgt[i-1]*out_on_x_turns[i];
		if(ps^n&&ps^1)ans+=lft[i]*rgt[i-1]*out_on_x_turns[i];
	}
	printf("%.9f\n",ans);
	return output;
}
```

---

## 作者：Tsawke (赞：0)

# [LG-P5249 [LnOI2019]加特林轮盘赌](https://www.luogu.com.cn/problem/P5249) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P5249-Solution)

### 题面

存在加特林，存在 $ n $ 个人围城一圈轮流使用加特林并每次均有 $ P $ 的概率被打死，求第 $ k $ 个人是最终唯一的幸存者的概率。

### Solution

很有意思的一道题，和一般的朴素概率 DP 不尽相同。

前面的思路和其它题解差不多，主要细说一下最后推式子的步骤。

对于 $ n = 1 $ 平凡解决，对于 $ n = 2 $ 考虑，发现不能用一般的线性递推的思路，不难想到对于处于第一位的人，若其没有被打死，那么下一次的时候枪指向下一个人，局面与初始时原来处于第一位的人处于第二位等效，那么不难想到我们令 $ dp(2, i) $ 表示 $ 2 $ 个人时处于第 $ i $ 位的人幸存的概率，不难发现转移：
$$
dp(2, 1) = P \times 0 + (1 - P) \times dp(2, 2)
$$
也就是说考虑其原本处于第 $ 1 $ 位，被打死则无贡献，没有被打死并且在下一次被移动到 $ 2 $ 位置后仍然幸存即为答案。

写到这就不难发现这东西是存在后效性的，或者说不存在初值，但是仍然存在显然的 $ dp(2, 1) + dp(2, 2) = 1 $，所以也可以计算。

于是考虑扩展到 $ dp(n, i) $，不难想到最朴素地：
$$
dp(n, 1) = (1 - P) \times dp(n, n)
$$

$$
\sum_{i = 1}^n dp(n, i) = 1
$$

此时我们仔细想一下刚才的过程，不难发现意义就是我们每次只崩首位的人，崩完之后不移动枪，而是将整个圆排列对应旋转。

然后我们考虑对于中间的转移，不难想到对于 $ dp(n, k) $，我们如果 $ P $ 的概率崩掉首位了，则 $ k \leftarrow k - 1, n \leftarrow n - 1 $，即 $ P \times dp(n - 1, k - 1) $，如果 $ 1 - P $ 地没崩掉，那么人虽然没有减少但是圆排列仍然需要转一下 $ k \leftarrow k - 1 $，也就是 $ (1 - P) \times dp(n, k - 1) $，于是转移即为：
$$
dp(n, k) = P \times dp(n - 1, k - 1) + (1 - P) \times dp(n, k - 1)
$$
当然我们这东西是没有初值的，不能直接递推，但是共存在 $ n $ 个方程，可以直接解 $ n $ 元 $ 1 $ 次方程组，用高斯消元即可，但是这个是 $ O(n^4) $ 的，考虑优化。

考虑对于 $ P \times dp(n - 1, k - 1) $ 此时已经为常量了，令其为 $ \xi $，则有：
$$
dp(n, k) = (1 - P) \times dp(n, k - 1) + \xi
$$
令 $ f(k) = dp(n, k) $，令 $ \xi(k) $ 表示 $ dp(n - 1, k - 1) \times P \times (1 - P)^{k - 1} $，则有：
$$
f(k) = (1 - P)^{k - 1}f(1) + \sum_{i = 1}^{k - 1}\xi(i)
$$
这样我们可以用 $ f(1) $ 表示出所有 $ f(k) $，然后带入 $ \sum f(k) = 1 $ 求出 $ f(1) $，再 $ O(n) $ 求出所有的 $ f(k) $。

注意需要特判 $ P = 0 $ 的情况，且注意需要滚动数组优化空间。

最终时间复杂度 $ O(n^2) $，空间复杂度 $ O(n) $。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define EPS (1e-10)

template < typename T = int >
inline T read(void);

ld P;
int N, K;
ld dp[2][11000];

int main(){
    scanf("%Lf", &P), N = read(), K = read();
    if(P < EPS)printf("%.10Lf\n", N == 1 ? (ld)1 : (ld)0), exit(0);
    dp[1][1] = 1.0;
    bool cur(false);
    for(int i = 2; i <= N; ++i){
        ld K(1.0), B(0.0), base1(1.0), base2(0.0);
        for(int j = 2; j <= i; ++j)
            base1 *= (1 - P), base2 = base2 * (1 - P) + P * dp[cur ^ 1][j - 1],
            K += base1, B += base2;
        dp[cur][1] = (1 - B) / K;
        for(int j = 2; j <= i; ++j)
            dp[cur][j] = (1 - P) * dp[cur][j - 1] + P * dp[cur ^ 1][j - 1];
        cur ^= 1;
    }printf("%.10Lf\n", dp[cur ^ 1][K]);
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2023_02_25 初稿

---

## 作者：creation_hy (赞：0)

## 前言

~~刚不小心交错地方了，我删了，这是重新交的~~

为啥这么眼熟啊这题，我好像在哪见过来着（

那题题意大概就是一个队列，第 $i$ 个人有一个概率会到队尾，还有出队的概率，求某个人最后为队列唯一一个人的概率（

## 思路

（以下 $P_0$ 均用 $P$ 代替）

设 $f[i][j]$ 表示有 $i$ 个人，当前人排在第 $j$ 位时最后的期望。

到第 $i$ 个人的时候，考虑：

- 第一个人死了：

  可以理解为出队。
  
  此时队内人数减一，每个人都往前补位。
  
  转移：$f[i][j]\to f[i-1][j-1]$
  
  概率：$P$

- 第一个人没死：

  可以理解为到队尾了，等待其他人先玩一次。
  
  此时队内人数不变，每个人都往前补位。
  
  转移：$f[i][j]\to f[i][j-1]$
  
  概率：$1-P$

结合以上两种情况，得出方程：

$f[i][j]=P\times f[i-1][j-1]+(1-P)\times f[i][j-1]$

这个式子就是个 $n$ 元一次方程，直接解就行了。

另外，空间可能会爆，所以用滚动数组优化一下。

最后，有个坑点，$P$ 可能为 $0$，如果那样谁都不会死。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
const double eps = 1e-10;
double p, f[2][N];
int n, m;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> p >> n >> m;
    f[1][1] = 1;
    if (!p)
    {
        cout << (n == 1);
        return 0;
    }
    for (int i = 2; i <= n; i++)
    {
        double curp = 1, sp = 0, curf = 0, sf = 0;
        for (int j = 2; j <= i; j++)
        {
            curp *= (1 - p), sp += curp;
            curf = (1 - p) * curf + p * f[i & 1 ^ 1][j - 1], sf += curf;
        }
        f[i & 1][1] = (1 - sf) / (sp + 1);
        for (int j = 2; j <= i; j++)
            f[i & 1][j] = (1 - p) * f[i & 1][j - 1] + p * f[i & 1 ^ 1][j - 1];
    }
    cout << fixed << setprecision(10) << f[n & 1][m];
    return 0;
}
```

---

## 作者：wsy_jim (赞：0)

P5249 加特林轮盘赌

题意：有 $n$ 个人围成一个圈，从编号为 $1$ 的人开始，每个人有 $p_0$ 的几率淘汰，问最后剩下编号为 $k$ 的人的概率是多少，数据范围：$1\leq k\leq n\leq 10^4$ 

发现谁先死谁后死实际上并没有啥用对吧

设 $f[n][k]$ 表示 $n$ 个人玩游戏编号为 $k$ 的人存活的概率，从两个人开始考虑

两个人的话如果第二个人存活，并且第一个人也没有淘汰，那第一个人就存活，写成表达式就是 $f[2][1]=f[2][2]\times (1-p_0)$，这是一个二元一次方程，还差一个方程，可以从概率的角度写出第二个方程 $f[2][1]+f[2][2]=1$，于是 $n=2$ 的情况就解决了

那 $n$ 再大一点，也可以套用上面的两个式子，剩下的式子是考虑 $f[n][i]$ 的存活概率，考虑转移，假设当前轮到第一个人了，如果他 $(1-p_0)$ 的概率没有死，那第二个人变成第一个人，之后的人往前移一格，$i$ 变成 $i-1$，如果他 $p_0$ 的概率死了，那人数少了一个，之后的人还是往前移一格，$i$ 变成 $i-1$，方程是 $f[n][i]=p_0\times f[n-1][i-1]+(1-p_0)\times f[n][i-1]$ 

这样我们就得到了 $n$ 个方程，要手动消元不能高斯消元，不然会T的很惨

---


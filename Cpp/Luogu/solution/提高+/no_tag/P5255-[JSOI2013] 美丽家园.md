# [JSOI2013] 美丽家园

## 题目描述

现在富裕的家庭都有了自己的别墅，别墅的院子往往大家选择铺上黑白两色的地砖。如何铺地砖是很有学问的，因为这涉及到美学方面的问题。怎样铺是美的呢？先看下面两组：

![qwq](https://cdn.luogu.com.cn/upload/pic/54050.png)
 
Figure 1 中的就被人们认定为比较美丽的，而 Figure 2 中的铺法则是不美丽的了。因为人们认为，如果出现一块 2*2 的区域里，只有一种颜色，那这就是不美丽的，反之则是美丽的。

现在，小 G 的公司拿到了一个任务，一块 N*M 的院子必须铺上地砖。爱美之心人皆有之，主人家自然希望这块院子地砖的铺法是美丽的，所以他首先想让小 G 的公司拿出设计方案的总数来。

而且这户主人家似乎对 P这个数特别迷信，所以他希望得到的总方案数对P取模后的结果。

## 说明/提示

$1~\leq~N~\leq~10^{100}$

$1~\leq~M~\leq~5$

$1~\leq~P~\leq~10000$

## 样例 #1

### 输入

```
2 2 5```

### 输出

```
4```

# 题解

## 作者：da32s1da (赞：3)

$n$这么大，一眼矩阵快速幂。

从第$i$列转移到第$i+1$列，每一列有$32$种状态，暴力枚举，判断能否转移，转移矩阵就搞好了。

初始化用**黑白黑白黑白**，能转移到所有情况。

注意高精。

没了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int m,p,s,Ans;
char t[105];
struct mat{
	int c[32][32];
	void clear(){memset(c,0,sizeof(c));}
	mat operator *(const mat &o)const{
		mat r;
		r.clear();
		for(int i=0;i<s;i++)
		for(int k=0;k<s;k++)
		for(int j=0;j<s;j++)
		if(c[i][k]&&o.c[k][j])
		r.c[i][j]=(r.c[i][j]+c[i][k]*o.c[k][j])%p;
		return r;
	}
}f,g;
struct BigInt{
	int c[105],len;
	void rad(){
		scanf("%s",t);
		len=strlen(t);
		for(int i=0;i<len;i++)c[i]=t[i]-48;
		reverse(c,c+len);
	}
	bool pd(){return len>1||c[0];}
	void div(){
		int tmp=0;
		for(int i=len-1;i>=0;i--){
			tmp=tmp*10+c[i];
			c[i]=tmp>>1;
			tmp&=1;
		}
		if(!c[len-1])len--;
	}
	bool je(){return c[0]&1;}
}n;
int main(){
	n.rad();scanf("%d%d",&m,&p);
	s=1<<m;
	for(int i=0;i<s;i++)
	for(int j=0;j<s;j++){
		int tmp=1;
		for(int k=0;k<m-1;k++){//注意-1
			if(((i>>k)&(i>>(k+1))&(j>>k)&(j>>(k+1)))&1){tmp=0;break;}//2*2黑
			if(!(((i>>k)|(i>>(k+1))|(j>>k)|(j>>(k+1)))&1)){tmp=0;break;}//2*2白
		}
		g.c[j][i]=tmp;
        //转移矩阵
	}
	int tmp=0;
	for(int i=0;i<m;i++)tmp+=(i&1)*(1<<i);
	f.c[0][tmp]=1;//初始化 黑白黑白
	for(;n.pd();n.div(),g=g*g)
	if(n.je())f=f*g;
	for(int i=0;i<s;i++)Ans+=f.c[0][i];//累加最后一列所有情况
	printf("%d\n",Ans%p);
}
```

---

## 作者：yanqijin (赞：2)

# 题目大意
有一个 $N \times M$ 的地板，可以铺上一些黑白的砖，要求每个 $2 \times 2$ 的区域里，颜色不能完全一样，问有多少种方案($N \le 10^{100}$ $M \le 5$)。
# 思路
首先看到 $M$ 这么小，还要统计方案数，容易想到~~暴力~~ 状压，枚举 $i(i \le n)$，$j(j \le 2^m-1)$，则 $f_{i,j} =\sum_{s=1}^{2^m-1}f_{i-1,s}[s\text{和}j\text{合法}]$。但是 $N \le 10^{100}$，这么大的数据范围，普通的状压承受不了，所以要用 **矩阵快速幂** 优化。

式子 $[f_{1,0},f_{1,1},f_{1,2}\dots f_{1,2^m-2},f_{1,2^m-1}]\times C^{n-1}=[f_{n,0},f_{n,1},f_{n,2}\ldots f_{n,2^m-2},f_{n,2^m-1}]$。其中矩阵 $C$ 中，若 $S'\to S$ 合法，则 $C_{S',S}=1$，否则 $C_{S',S}=0$。

时间复杂度 $O(2^{3m}\log n)$。

(**记得高精度**)。
# $Code$
```cpp
#include<cstdio>
using namespace std;
int n[105],m,p,c[32][32],x[32][32],ans[32],z=0,cnt;//高精度
void read(int &x) {//快读
	x=0;
	char ch=0;
	while(ch<'0'||ch>'9') {
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+ch-48;
		ch=getchar();
	}
}
void write(int x) {//快输
	if(x<0) putchar('-'),x=-x;
	int sta[100];
	int top=0;
	do {
		sta[top++]=x%10,x/=10;
	} while(x);
	while(top) putchar(sta[--top]+48);
	putchar('\n');
}
void cheng() {
	if(z==0) {
		for(int j=0; j<(1<<m); j++) {
			for(int j1=0; j1<(1<<m); j1++) {
				c[j][j1]=x[j][j1];
			}
		}
		z=1;
		return ;
	}
	int q[32][32];
	for(int j=0; j<(1<<m); j++) {
		for(int j1=0; j1<(1<<m); j1++) {
			q[j][j1]=c[j][j1];
			c[j][j1]=0;
		}
	}
	for(int j=0; j<(1<<m); j++) {
		for(int j1=0; j1<(1<<m); j1++) {
			for(int k=0; k<(1<<m); k++) {
				c[j][j1]=(c[j][j1]+q[j][k]*x[k][j1])%p;
			}
		}
	}
}
void cheng1() {
	int q[32][32],s[32][32];
	for(int j=0; j<(1<<m); j++) {
		for(int j1=0; j1<(1<<m); j1++) {
			q[j][j1]=x[j][j1];
			s[j][j1]=x[j][j1];
			x[j][j1]=0;
		}
	}
	for(int j=0; j<(1<<m); j++) {
		for(int j1=0; j1<(1<<m); j1++) {
			for(int k=0; k<(1<<m); k++) {
				x[j][j1]=(x[j][j1]+q[j][k]*s[k][j1])%p;
			}
		}
	}
}
void qpow() {//矩阵快速幂
	while(cnt) {
		if(n[1]&1) {
			cheng();
		}
		cheng1();
		long long s=0,d=cnt;
		for(int i=cnt; i>=1; i--) {
			n[i]+=s*10;
			s=n[i]&1;
			n[i]>>=1;
		}
		cnt=0;
		for(int i=1; i<=d; i++) {
			if(n[i]) cnt=i;
		}
	}
}
int main() {
	char ch=0;
	while(ch<'0'||ch>'9') {
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		n[++cnt]=ch-48;
		ch=getchar();
	}
	int h[105];
	for(int j=1; j<=cnt; j++) h[j]=n[j];
	for(int j=1; j<=cnt; j++) n[j]=h[cnt-j+1];
	read(m);
	read(p);
	if(p==1) {
		write(0);
		return 0;
	}
	for(int j=0; j<(1<<m); j++) {
		for(int j1=0; j1<(1<<m); j1++) {
			int a=j,d=j1;
			bool q=1;
			for(int s=1; s<m; s++) {
				if((a&1)==(d&1) and ((a>>1)&1)==((d>>1)&1) and (a&1)==((a>>1)&1)) q=0;
				a>>=1;
				d>>=1;
			}
			if(q) {
				x[j][j1]=1;
			}
		}
	}
	n[1]--;
	int v=1;
	while(n[v]<0) {
		n[v]+=10;
		n[v+1]--;
		v++;
	}
	qpow();
	for(int j1=0; j1<(1<<m); j1++) {
		for(int k=0; k<(1<<m); k++) {
			ans[j1]+=c[k][j1];
		}
	}
	int sum=0;
	for(int i=0; i<1<<m; i++) {
		sum=(sum+ans[i])%p;
	}
	write(sum);//输出
	return 0;
}
```

---

## 作者：CarroT5656 (赞：0)

**解题思路**

发现虽然 $N$ 的值可能达到 $10^{100}$，然而 $M$ 最大却只有 $5$。

由于题目中是一个 $2\times 2$ 的矩阵内不能全部相同，即当前一列只会被上一列影响。

考虑将一列的状态状压成一个二进制数。枚举当前列和上一列，判断是否可以转移。

每一列的转移都是一样的。所以可以用矩阵快速幂优化这个转移。

初始状态可以设为黑白交替，这样可以让所有可能的下一列都被转移到。

注意 $N\le 10^{100}$，需要高精度。

时间复杂度 $O(2^{3M}\log N)$，可以通过。

**Code**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define N 10
#define M 35
ll m,p,s[N][2];
char t[N<<4];
struct mtrx{
	ll n,m,x[M][M];
	mtrx(){n=m=0,memset(x,0,sizeof x);return ;}
	mtrx operator*(mtrx a){
		mtrx ans;
		ans.n=n,ans.m=a.m;
		for(ll i=1;i<=n;i++) for(ll j=1;j<=a.m;j++) for(ll k=1;k<=m;k++)
			(ans.x[i][j]+=x[i][k]*a.x[k][j])%=p;
		return ans;
	}
}g,h,ans;
struct Lint{
	ll l,x[N<<4];
	Lint(){l=0,memset(x,0,sizeof x);}
	void read(){
		scanf("%s",t+1);
		l=strlen(t+1);
		for(ll i=0;i<l;i++) x[i]=t[l-i]-'0';
	}
	bool emp(){return (l==0);}
	bool odd(){return (x[0]&1);}
	void divd(){
		for(ll i=l-1;i>=0;i--){
			if(i&&(x[i]&1)) x[i-1]+=10;
			x[i]>>=1;
		}
		while(l&&!x[l-1]) l--;
	}
}n;
int main(){
	n.read();
	scanf("%lld%lld",&m,&p);
	g.n=g.m=h.m=ans.n=ans.m=(1<<m),h.n=1;
	for(ll i=0;i<(1<<m);i++) for(ll j=0;j<(1<<m);j++){
		for(ll k=0;k<m;k++) s[k+1][0]=((i&(1<<k))>0);
		for(ll k=0;k<m;k++) s[k+1][1]=((j&(1<<k))>0);
		bool f=1;
		for(ll k=1;k<m;k++){
			if(s[k][0]==s[k][1]&&s[k][0]==s[k+1][0]&&s[k][0]==s[k+1][1]){
				f=0;
				break;
			}
		}
		g.x[i+1][j+1]=f;
	}
	ll l=1,cnt=0;
	for(ll i=0;i<m;i++) l+=(i&1)*(1<<i);
	for(ll i=1;i<=(1<<m);i++) ans.x[i][i]=1;
	h.x[1][l]=1;
	while(!n.emp()){
		if(n.odd()) ans=ans*g;
		g=g*g,n.divd();
	}
	h=h*ans;
	for(ll i=1;i<=(1<<m);i++) (cnt+=h.x[1][i])%=p;
	printf("%lld\n",cnt);
	return 0;
}
```

---


# [JSOI2013] 编程作业

## 题目描述

考虑到如下的两段代码，很容易发现他们其实是一样的。

#### 代码1

```cpp
int i, j;
i = 3;
j = i + 1;
```

#### 代码2

```cpp
int a, i;
a = 3;
i = a + 1;
```

这是因为这两段代码之间唯一的差异，只是他们更换了一下变量名，比如第一段代码中的 `i` 变成了第二段的 `a`，第一段的 `j` 变成了第二段的 `i` 。而其他的常量，例如 `3`，`1` 或者其他的关键字和运算符，比如 `int`，`+` 和 `;`。都是没有发生变化的。 

不过注意到如下的代码片段，我们并不能简单认为这是一样的，因为这不是一个简单的替换，而是可以导致不同运算结果的。
#### 代码3

```cpp
a = 3;
b = 3;
```

#### 代码4
```cpp
c = 3;
c = 3; 
```

为了简化问题，我们用大写字母来表示所有的关键字、常量等非变量符号。

假如我们采用如下的替换表：

![qwq](https://cdn.luogu.com.cn/upload/pic/54051.png)

那么最开始给出的两段雷同代码就可以分别写成 `AiBjCiDECjDiFGC` 以及 `AaBiCaDECiDaFGC`。

或者简单的说，我们认为这两段代码是一样的。

现在请写一个程序，处理若干这样的代码雷同检测问题：给一个完整代码以及一个较短的代码片段，请求出，这个代码片段在完整代码中一共出现了多少次（代码片段出现的位置可以重叠）。

为了简单起见，我们认为程序中只会至多出现 $\text a\sim \text z$ 这 $26$ 个变量，同时也至
多只有 $\text A\sim \text Z$ 这 $26$ 个非变量符号。

## 说明/提示

#### 样例说明
前两个样例均为题目中所举例的代码段。第三个样例中，在完整代码 $S$ 中与代码片段 $T$ 一样的片段为：`ccd` 和 `dde`

#### 数据范围
$Q<=3,|T|<=10^5,|S|<=10^6$

## 样例 #1

### 输入

```
3
AiBjCiDECjDiFGC
AaBiCaDECiDaFGC
cDEcDEbDE
aDEbDE
ccddef
aab```

### 输出

```
1
1
2```

# 题解

## 作者：lgswdn_SA (赞：9)

作业题。感觉比较灵活的题目，所以为什么这道题没有 KMP 标签啊？

### 题意

给定一个母串和一个模式串，其中小写字母需要建立一个一一对应的关系，然后将小写字母替换成对应的小写字母。问替换后的最大匹配数。

### 题解

我们模拟一下匹配，发现其实**小写字母到底是什么字母**根本不重要，比如说给定的模式串是 ```QabWabQa``` 还是 ```QqwWqwQq``` 本质是相同的，而小写字母真正不同的是它们的 mode 是相同的（瞎起的名字，就是字母排列的样式是一样的）。

先不考虑大写字母。如果两个串的 mode 相同，那么它们就是匹配的。而 mode 中真正重要的是几个相同的字母的位置关系，母串中相同的字母的位置 和 模式串中相同的字母的位置 应该保持一样。

怎么表示这种串中相同的字母的位置呢？有一种方法，即记录 $a_i$ 为 $i$ 到 $s_i$ 上一次出现的距离。比如 ```abaabb``` 的 $a$ 数组为 $0,0,2,1,3,1$ （如果前面没有那么就为 0）。两个小写字母的字符串匹配，当且仅当它们的 $a$ 数组相同。

不过有一个问题，模式串中每个字母第一个出现的位置不应该是 0，否则可能会无法匹配。我们举个例子。母串为 ```aababa```，模式串为 ```qwqw```，那么母串的 $a$ 数组为 $0,1,0,2,2,2$，模式串的 $a$ 数组为 $0,0,2,2$，显然和母串 $a$ 数组的后四位不能匹配。所以模式串中每个字母第一个出现的位置需要设一个“通配符”，即什么都能配上。

现在整个字符串中的小写字母都可以用数字或通配符去替代，于是我们把字符串替换后，再做一次 KMP 即可。KMP 时要注意改变匹配规则（通配符和数字）。

注意，通配符不代表所有都通配，否则你样例2都过不了。这个通配一定指可以通配这个区间中第一次出现的字符。可以具体看代码是怎么实现的。

```cpp
bool same(int a,int b,int j) {
	if(a<0||b<0) return a==b;	//大写字母
	return a==b||(b==0&&a>j);	//小写字母 
}
```

j 代表匹配的长度，所以如果要用通用符我们必须保证这个 a 代表的字符 s 不是第一次出现，即 ```a>j```。

接下来看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+9;

char cs[N],ct[N];
int n,m,s[N],t[N],pre[29],nxt[N];

bool same(int a,int b,int j) {
	if(a<0||b<0) return a==b;			//大写字母
	return a==b||(b==0&&a>j);			//小写字母 
}
void kmp() {
	int j=0,ans=0; nxt[1]=0;
	for(int i=1;i<m;i++) {
		while(j&&!same(t[i+1],t[j+1],j)) j=nxt[j];
		if(same(t[i+1],t[j+1],j)) j++;
		nxt[i+1]=j;
	}
	j=0;
	for(int i=0;i<n;i++) {
		while(j&&!same(s[i+1],t[j+1],j)) j=nxt[j];
		if(same(s[i+1],t[j+1],j)) j++;
		if(j==m) ans++,j=nxt[j];
	}
	printf("%d\n",ans);
}

int main() {
	int Q; cin>>Q;
	while(Q--) {
		memset(ct,0,sizeof(ct)), memset(cs,0,sizeof(cs));
		memset(t,0,sizeof(t)), memset(s,0,sizeof(0));
		scanf("%s%s",cs+1,ct+1); n=strlen(cs+1), m=strlen(ct+1);
		memset(pre,0,sizeof(pre));
		for(int i=1;i<=n;i++)				//预处理s串 
			if(cs[i]>='a'&&cs[i]<='z')
				s[i]=(pre[cs[i]-'a'+1]>0 ? i-pre[cs[i]-'a'+1] : 0),
				pre[cs[i]-'a'+1]=i;
			else s[i]=-(cs[i]-'A'+1);		//大写字母记为负数
		memset(pre,0,sizeof(pre));
		for(int i=0;i<=m;i++)				//预处理t串 
			if(ct[i]>='a'&&ct[i]<='z')
				t[i]=(pre[ct[i]-'a'+1]>0 ? i-pre[ct[i]-'a'+1] : 0),
				pre[ct[i]-'a'+1]=i;
			else t[i]=-(ct[i]-'A'+1);
		kmp();
	}
	return 0;
}
```

---

## 作者：__LZQ__ (赞：7)

## 题意

$Q$ 次询问，每次询问一个字符串 $T$ 的**雷同串**在另一个字符串 $S$ 中出现了多少次。

这里的雷同定义为大写字母完全一致且小写字母模式一致。

比如 `aad` 与 `ccb` 就是模式一致。

## 解法

字符匹配考虑 KMP。

因为小写字母要求模式一致容易想到对于每个小写字母 $i$ 维护 $pre_i$ 表示上一个 $i$ 出现的位置。

对于字符串 $S$ 求解出 $s$ 数组。

大写字母不动，小写字母表示为与上一个同样字母的相对距离 即 $s_i=i-pre_{S_i}$。

对于 $T$ 也同理求解出 $t$ 数组。

然后用 $s$ 和 $t$ 跑 KMP。

你就会发现：过不了样例。

我们把其中一组样例拽过来看一下 $s$ 和 $t$（为了方便大写字母先保持原样）。

```txt
S:cDEcDEbDE
s:1DE3DE7DE 
T:aDEbDE
t:1DE4DE
```

我们会发现 `cDEbDE` 与 `aDEbDE` 是可以匹配的。

但是对应的 $s$ 与 $t$ 不行。

这个样例提醒我们对于两个匹配子串中都是**第一次**出现的字符来说是**一定可以匹配的**。

现在之前 $s$ 与 $t$ 中存的**相对距离**就有用了。

在子串中第一次出现等价于 `s[i]>l`。

$l$ 是当前匹配长度，对于 $t$ 也同理。

于是我们可以用一个函数 `thesame` 平替 KMP 中的 `==`。

```c++
bool thesame(int x,int y,int len)//x，y分别为s和t的值 len是当前长度
{
    return x==y||(x>len&&y>len);
}
```

~~细节 same 前面必须有 the。~~

还有个细节就是大写字母的值直接取负以免与小写字母匹配上了。

然后就没了。

#### code

```c++
#include<bits/stdc++.h>
using namespace std;
const int Slen=1e6+5,Tlen=1e5+5;
int TT,n,m,s[Slen],t[Tlen],pre[30],nxt[Tlen];
char S[Slen],T[Tlen];
bool thesame(int x,int y,int len){return (x==y)||(y>len&&x>len);}
void Kmp()
{
	int res=0;
	memset(nxt,0,sizeof(nxt));
	nxt[1]=0;
	for(int i=2,j=0;i<=m;i++)
	{
		while(j&&!thesame(t[j+1],t[i],j))j=nxt[j];
		if(thesame(t[j+1],t[i],j))j++;
		nxt[i]=j;
	}//求nxt数组
	for(int i=1,j=0;i<=n;i++)
	{
		while(j&&!thesame(t[j+1],s[i],j))j=nxt[j];
		if(thesame(t[j+1],s[i],j))j++;
		if(j==m)res++,j=nxt[j];
	}
	cout<<res<<"\n";
}
void solve()
{
	cin>>S+1>>T+1;
	n=strlen(S+1),m=strlen(T+1);
	memset(pre,0,sizeof(pre));
	for(int i=1;i<=n;i++)
	{
		if(S[i]<='Z'&&S[i]>='A')s[i]=-(S[i]-'A'+1);
		else s[i]=i-pre[S[i]-'a'+1],pre[S[i]-'a'+1]=i;
	}
	memset(pre,0,sizeof(pre));
	for(int i=1;i<=m;i++)
	{
		if(T[i]<='Z'&&T[i]>='A')t[i]=-(T[i]-'A'+1);
		else t[i]=i-pre[T[i]-'a'+1],pre[T[i]-'a'+1]=i;
	}
	Kmp();
}
int main(){cin>>TT;while(TT--){solve();}}
```

---

## 作者：SleepinGod (赞：3)

- ## 题意

  可以简化为给出一个字符串和模式串，这个模式串的小写字母之间的关系在模式串中不变，大写字母一模一样，问出现了多少次

- ## 思路

  这道题是一个匹配问题，我们不难想到它是跟 KMP 有关的，我们会发现一个有趣的性质，就是我们只关心小写字母之间的对应的关系，所以我们可以考虑记录小写字母上一次出现的位置，可以发现只要对应位置上的小写字母它上一次出现的位置是相同的，或者都未出现它就是可以匹配上的，但是有一个问题，就是我们需要考虑它在原串中上一次出现的位置是否会超过开始匹配的位置，所以我们可以考虑上一次出现与当前位置的位置差进行 KMP 可以发现如果这个值大于当前匹配到模式串的位置它就是未出现过的。为了保障大写字母不会与小写字母的值域有交集，我们可以考虑把大写字母对应的位置设成负数

- ## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 5, M = 300;

int nxt[N], vis[M], a[N], b[N];

string s, str;

bool D(int x, int y, int len) {
	if (x < 0 && y < 0) {
		return x == y; //大写字母只能等于才算匹配 
	}
	if (x > len && y > len) {
		return 1;
	} //如果离上一次的距离大于现在的长度，则都未出现过 
	return x == y; //离上一次的距离相同 
}

int main() {
	int T;
	for (cin >> T; T--;) {
		cin >> s >> str;
		int n = str.size(), m = s.size();
		s = " " + s, str = " " + str; //注意作者马蜂下标从1开始 
		
		memset(vis, 0, sizeof(vis)); 
		for (int i = 1; i <= m; i++) {
			if ('A' <= s[i] && s[i] <= 'Z') {
				a[i] = -s[i];  //大写字母设成负数 
				continue;
			}
			a[i] = i - vis[s[i]]; //计算与上一次的距离（当第一次出现时长度是i易得在比较函数中它会被判断为未出现 
			vis[s[i]] = i;
		}
		
		memset(vis, 0, sizeof(vis));
		for (int i = 1; i <= n; i++) {
			if ('A' <= str[i] && str[i] <= 'Z') {
				b[i] = -str[i];
				continue;
			}
			b[i] = i - vis[str[i]];
			vis[str[i]] = i;
		} //同理 
		
		for (int i = 2, j = 0; i <= n; i++) {
			for (; j && !D(b[i], b[j + 1], j); j = nxt[j]) {
			}
			j = nxt[i] = j + D(b[i], b[j + 1], j);
		} //kmp匹配
		 
		int ans = 0;
		for (int i = 1, j = 0; i <= m; i++) {
			for (; j && !D(a[i], b[j + 1], j); j = nxt[j]) {
			}
			j += D(a[i], b[j + 1], j);
			if (j == n) {
				ans++;
				j = nxt[j];
			}
		}  //与原串匹配 
		
		cout << ans << "\n";
	}
	return 0;
}

---

## 作者：jiangjiangQwQ (赞：3)

### 思路
这是一道标准的 KMP 匹配的题，只是匹配规则需要重载。首先，对于一些非变量关键字和常量等是使用大写字母替换，所以在 KMP 的时候这一部分必须完全一致。那么对于小写字母，其匹配规则较为宽松。

![](https://cdn.luogu.com.cn/upload/image_hosting/tm8ehzvt.png)

例如 `ccffeccf` 和 `aab` 在匹配的时候：第一个 `ccf` 和第二个 `ccf` 都能匹配。那么如何处理这种情况？
我们可以将字母映射成具体的数值，如 `ccffeccf` 映射成 `01010414`，将第一次出现的字母映射为 $0$，其余映射成与上一次相同字母的位置差。那么 `aab` 就是 `010`，但如此操作只能匹配到第一个 `ccf`。原因是对模式串中第一次出现的字母，在当前 KMP 的时候，只要母串中的字母在当前匹配窗口内也是**第一次出现的时候**，也是可以匹配的。在具体的代码实现中，设 $i,j$ 分别为母串和模式串当前正在匹配的位置，当 $s_i$ 和 $t_j$ 分别为小写字母时，$a_i$ 和 $b_j$ 是 $s_i$ 和 $t_j$ 的映射值。匹配成功要么是 $a_i=b_j$，要么是 $b_j=0$ 且 $a_i>j$，即 $t_j$ 是第一次出现，已经匹配长度为 $j$ 的时候，$s_i$ **上次出现的位置超出了匹配窗口的范围**，即在窗口内也是第一次出现，那么 $s_i$ 和 $t_j$ 就能够匹配。
### 代码流程
先将两字符串映射成数字，然后写一个函数重载匹配规则，在按照正常 KMP 的过程完成匹配，记一个 $ans$ 记录匹配成功的次数。

---

## 作者：StarRoam (赞：1)

**[P5256 [JSOI2013] 编程作业](https://www.luogu.com.cn/problem/P5256)**

我们考虑使用 KMP。

因为支持字符的置换，于是我们再分别定义数组 $A$、$B$ 分别表示 $s1$、$s2$ 被我们改造了后的序列。

- 对于小写字母，我们将它改为与前一个相同的距离，如果它是第一个，则将它改为 $0$。
- 如果是大写字母，我们不能进行置换，为了与小写字母区分，我们将其记为负数。

假设在数组 $A$、$B$ 中分别有 $x$、$y$ 两个数，它们的下标是 $i$、$j$，其中 $A$ 是模板串。

- 如果 $x$、$y$ 中有一个小于零，我们只要判断它们的值是否相等即可。
- 否则，如果 $x \ge j$，我们需要先让 $x=0$，再进行判断，因为在此次匹配时 $x$ 的上一个元素不在此区间中，那么 $x$ 就成了第一个元素了。

代码部分就是 KMP 的模板。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+5;
int q,n,m;
int a[N],b[N],pre[30],nxt[N];
string s1,s2;
bool check1(int i,int j)
{
	int x=b[i],y=b[j];
	if(x<0||y<0) return (x==y);
	if(x>=j) x=0;
	return (x==y);
}
bool check2(int i,int j)
{
	int x=a[i],y=b[j];
	if(x<0||y<0) return (x==y);
	if(x>=j) x=0;
	return (x==y);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>q;
	while(q--)
	{
		cin>>s1>>s2;
		n=s1.size(),m=s2.size();
		for(int i=0;i<26;i++) pre[i]=0;
		for(int i=0;i<n;i++)
		{
			if('A'<=s1[i]&&s1[i]<='Z') a[i+1]=-(s1[i]-'A'+1);
			else{
				int now=s1[i]-'a';
				if(pre[now]!=0) a[i+1]=(i+1)-pre[now];
				else a[i+1]=0;
				pre[now]=i+1;
			}
		}
		for(int i=0;i<26;i++) pre[i]=0;
		for(int i=0;i<m;i++)
		{
			if('A'<=s2[i]&&s2[i]<='Z') b[i+1]=-(s2[i]-'A'+1);
			else{
				int now=s2[i]-'a';
				if(pre[now]!=0) b[i+1]=(i+1)-pre[now];
				else b[i+1]=0;
				pre[now]=i+1;
			}
		}
		int j=0;
		for(int i=1;i<=m;i++) nxt[i]=0;
		for(int i=2;i<=m;i++)
		{
			while(check1(i,j+1)==false&&j>0) j=nxt[j];
			if(check1(i,j+1)==true) j++;
			nxt[i]=j;
		}
		j=0;
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			while(check2(i,j+1)==false&&j>0) j=nxt[j];
			if(check2(i,j+1)==true)
			{
				j++;
				if(j==m) ans++,j=nxt[j];
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：ix35 (赞：1)

设 $n=|S|,\ \ m=|T|$。

如果 $S[i,i+m-1]$ 与 $T$ 匹配，那么要求：

1. 所有对应位置的大写字母相等；

2. 存在一种小写字母的一一对应 $f(c)$，使得 $T$ 中任意小写字母与 $S$ 中相同位置处的小写字母对应。

重点在于第二条，我们发现其实并不关心具体是哪一个小写字母，只关心两个字母之间的关系，即：$T$ 中相同的两个小写字母在 $S$ 对应位置中也应该相同。

于是我们设 $pre(S[i])$ 表示 $S[i]$ 在 $S$ 中上一次出现的下标，只要 $T$ 与 $S[i,i+m-1]$ 中所有的 $p-pre(S[p])=(p-i)-pre(T[p-i])$，即一定可以匹配。

注意每一个串中每一个字母的第一次出现是不受这个限制的。

所以将字符串重定义一下，并且重定义两个字符相等，然后正常做 KMP 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1000010;
int q,n,m,nx[MAXN],a[MAXN],b[MAXN],las[28];
char s[MAXN],t[MAXN];
bool chk (int a,int b,int p) {return (a==b)||(a>p&&b>p);}
int main () {
	scanf("%d",&q);
	for (int ii=1;ii<=q;ii++) {
		int ans=0;
		scanf("%s%s",s+1,t+1);
		n=strlen(s+1),m=strlen(t+1);
		memset(las,0,sizeof(las));
		for (int i=1;i<=n;i++) {
			if (s[i]<'a') {a[i]=-(s[i]-'A'+1);}
			else {a[i]=i-las[s[i]-'a'+1];las[s[i]-'a'+1]=i;}
		}
		memset(las,0,sizeof(las));
		for (int i=1;i<=m;i++) {
			if (t[i]<'a') {b[i]=-(t[i]-'A'+1);}
			else {b[i]=i-las[t[i]-'a'+1];las[t[i]-'a'+1]=i;}
		}
		nx[1]=0;
		for (int i=2,j=0;i<=m;i++) {
			while (j&&!chk(b[j+1],b[i],j)) {j=nx[j];}
			if (chk(b[j+1],b[i],j)) {j++;}
			nx[i]=j;
		}
		for (int i=1,j=0;i<=n;i++) {
			while (j&&!chk(b[j+1],a[i],j)) {j=nx[j];}
			if (chk(b[j+1],a[i],j)) {j++;}
			if (j==m) {ans++,j=nx[m];}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：Exscallop64_ (赞：0)

## 题目简述

$q$ 次询问，每次给出两个字符串 $S$ 与 $T$，求有多少个 $S$ 的子串与 $T$ 相似。

+ 定义 $s$ 与 $t$ 相似，当且仅当可以构造一种映射 $f(c)$（其中映射值为小写字母，且对于任意两个小写字母 $x$ 与 $y$ （$x \ne y$）有 $f(x)\ne f(y)$），使得将 $t$ 中所有的小写字母替换为对应的映射后的得到的 $t'$ 有 $t'=s$。

## 思路

看到字符串匹配问题，我们自然能想到 KMP，但关键是如何处理小写字母。

可以发现，我们并不关心小写字母具体的值，只需要知道其的位置关系（相对关系），即在 $s$ 中 $\forall 1\le i < j \le \vert s \vert,s_i=s_j$，必须有 $t_i=t_j$。

所以我们记 $last(i,s)$ 表示 $s_i$ 在 $s$ 中上一次的出现位置，则 $s$ 与 $t$ 相似必有 $i-last(i,s)=j-last(j,t)$。

所以我们将 $S$ 按上述规则进行变换，令 $\Sigma$ 为小写字母集，即对于 $\forall 1 \le i \le \vert S \vert,S_i \in \Sigma$ 变为 $i-last(i,S)$，$T$ 同理。

最后做一遍 KMP 即可，注意一下第一次出现的字符的判定即可。

## 复杂度分析

+ 时间复杂度：单组询问 $O(\vert S \vert + \vert T \vert)$。

+ 空间复杂度：$O(\vert S \vert + \vert T \vert)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 2e6 + 5, MAXV = 26;

string s, t;
int a[MAXN], n, m, last[MAXV], nxt[MAXN];

bool Check(int x, int y, int len){
  return (x == y) || (x > len && y > len);
}//后面的 (x > len && y > len) 即为对第一次出现的字符的判定

void Solve(){
  cin >> s >> t;
  n = s.size(), m = t.size();
  s = "#" + s, t = "#" + t;
  fill(last, last + MAXV, 0);
  for(int i = 1; i <= n; i++){
    if(s[i] >= 'a' && s[i] <= 'z'){
      a[i + m + 1] = i - last[s[i] - 'a'];
      last[s[i] - 'a'] = i;
    }else{
      a[i + m + 1] = -(s[i] - 'A');//大写字母负数表示
    }
  }
  fill(last, last + MAXV, 0);
  for(int i = 1; i <= m; i++){
    if(t[i] >= 'a' && t[i] <= 'z'){
      a[i] = i - last[t[i] - 'a'];
      last[t[i] - 'a'] = i;
    }else{
      a[i] = -(t[i] - 'A');
    }
  }
  nxt[1] = 0;
  a[m + 1] = -114514;
  for(int i = 2; i <= n + m + 1; i++){//KMP 匹配
    int pos = nxt[i - 1];
    for(; pos && !Check(a[pos + 1], a[i], pos); pos = nxt[pos]);
    nxt[i] = Check(a[pos + 1], a[i], pos) ? pos + 1 : pos;
  }
  int ans = 0;
  for(int i = m + 2; i <= n + m + 1; i++){
    ans += nxt[i] == m;//计算匹配成功的数量
  }
  cout << ans << "\n";
}

int main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int T;
  for(cin >> T; T; Solve(), T--);
  return 0;
}
``````

---

## 作者：Doqe (赞：0)

NOI2024D1T1 考了类似的技巧。因此来写一篇。

因为要求小写字母映射后相同，所以字符串比较的时候尽量不出现小写字母。

可以使用 当前位置减去上次出现位置 来代替当前的小写字母。

特别的，每个字符的开头需要特殊处理，可以用 $0$ 代替。

这里使用哈希的算法正确性容易保证。但 KMP 的正确性没有那么显然。

$nx_i$ 表示下一个可能合法的最大开头，也就是“border”。

可以证明，在 $nx[1,i]$ 计算正确的时候，$nx_i$ 一定是正确的。可以考虑反证法。

和 残缺的字符串 的一大区别在于，一旦一个点成为开头，那么它会一直成为开头直到脱离比较区间，**并且字符串比较的等号（在区间左端点确定时）具有传递性**，所以成立（这点在反证法上极其有用）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
char s[N],t[N];
int a[N],b[N];
bool eq(int x,int y,int z){return (x==y)||(x>z&&y>z);}
int n,m,u[30],nx[N];
int main()
{
	int T;cin>>T;
	while(T--)
	{
		cin>>t+1>>s+1;
		n=strlen(s+1),m=strlen(t+1);
		for(int i=1;i<=n;++i)
		{
			if(s[i]<'a')a[i]=-(s[i]-'A'+1);
			else a[i]=i-u[s[i]-'a'],u[s[i]-'a']=i;
		}
		memset(u,0,sizeof u);
		for(int i=1;i<=m;++i)
		{
			if(t[i]<'a')b[i]=-(t[i]-'A'+1);
			else b[i]=i-u[t[i]-'a'],u[t[i]-'a']=i;
		}
		memset(u,0,sizeof u);
		for(int i=2,j=0;i<=n;++i)
		{
			while(j&&!eq(a[i],a[j+1],j))j=nx[j];
			if(eq(a[i],a[j+1],j))++j;nx[i]=j;
		}
		int c=0;
		for(int i=1,j=0;i<=m;++i)
		{
			while(j&&!eq(b[i],a[j+1],j))j=nx[j];
			if(eq(b[i],a[j+1],j))++j;
			if(j==n){j=nx[j];++c;}
		}
		cout<<c<<endl;
	}
}
```

---

## 作者：Thunder_S (赞：0)

[不一样的阅读体验](https://www.cnblogs.com/Livingston/p/15367336.html)

## Solution

这题就是一个很明显的KMP，但是关键在于对小写字母的处理。

其实可以发现，小写字母是什么并不重要，重要的是他们之间的位置。而大写字母要保持一致。

因此可以对于每个小写字母，那个位置变成他与上一个同样的字母之间的距离，如果这个距离是一样的，那么就是可以匹配的。

但是这并不是所有。

举个例子，完整代码： $aababa$，代码片段：$cdcd$。

根据上述的转换可以变成 $010222$ 和 $0022$。发现如果仅仅在这上面跑 KMP 是会遗漏答案的。

因为对于位置 4 的 $a$ 来说，在完整的代码中它距离上一个为 2，但是如果在完整片段中从第 3 个开始匹配，第 4 个 $a$ 就变成了第一个，就可以与代码片段匹配。

所以对于当前匹配的区间中，如果一个字母是第一次出现，那么它可以跟任何一个数字匹配，前提是在当前区间中它是第一个。

## Code

```cpp
#include<cstdio>
#include<cstring>
#define N 1000005
using namespace std;
int T,n,m,ans,match[N<<1],t[30],a[N],b[N],s[N<<1];
char ch;
void init1()
{
	memset(t,-1,sizeof(t));
	while (!((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z'))) ch=getchar();
	while (((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')))
	{
		if (ch>='a'&&ch<='z')
		{
			t[ch-'a'+1]==-1?a[n]=0:a[n]=n-t[ch-'a'+1]; 
			t[ch-'a'+1]=n;
			++n;
		}
		else a[n++]=-(ch-'A'+1);
		ch=getchar();
	}
}
void init2()
{
	memset(t,-1,sizeof(t));
	while (!((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z'))) ch=getchar();
	while (((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')))
	{
		if (ch>='a'&&ch<='z')
		{
			t[ch-'a'+1]==-1?b[m]=0:b[m]=m-t[ch-'a'+1]; 
			t[ch-'a'+1]=m;
			++m;
		}
		else b[m++]=-(ch-'A'+1);
		ch=getchar();
	}
}
bool check(int x,int y,int len)
{
	if (x<0||y<0) return x==y;
	return x==y||(y==0&&x>len);
}
int main()
{
	scanf("%d",&T);
	while (T--)
	{
		n=m=ans=0;
		memset(match,0,sizeof(match));
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		init1();init2();
		for (int i=0;i<m;++i)
			s[i]=b[i];
		s[m]=100;
		for (int i=0;i<n;++i)
			s[m+i+1]=a[i];
		for (int i=1;i<=n+m;++i)
		{
			int j=match[i-1];
			while (j>0&&!check(s[i],s[j],j)) j=match[j-1];
			if (check(s[i],s[j],j)) ++j;
			match[i]=j;
		}
		for (int i=m+1;i<=n+m;++i)
			if (match[i]==m) ++ans;
		printf("%d\n",ans);
	}
	return 0;
} 
```



---


# 简单模拟

## 题目描述

考虑这样一款游戏，游戏地图可以视为一个平面直角坐标系的第一、四象限。

第一象限内会出现 $n$ 个物体，一个物体可以是一个点，或者一条平行于 y 轴的线段。一个物体出现时，物体上离 x 轴最近的点和最远的点，分别称为物体的最低点和最高点。若物体是点，则最低点和最高点相同。

第 $i$ 个物体会在时刻 $t_i$ 出现，最低点为 $(x_i,l_i)$，最高点为 $(x_i,r_i)$，以速度 $v_i$ 沿 y 轴负半轴方向匀速移动。

玩家可以标记 x 轴正半轴上的任何整点（若这个位置已经被标记，则这次的标记和之前的标记互不影响），称为**标记操作**；也可以取消某个标记，称为**取消标记操作**。同一时间可以做任意次操作。已知玩家做了 $m$ 对操作，第 $i$ 对操作的位置为 $p_i$，其中标记操作和取消标记操作发生的时刻分别为 $a_i$ 和 $b_i$。

每个物体最初会处于**正常状态**。

若在某一时刻，对于一个物体，距离物体的最低点不大于 $d_0$ 的位置发生标记操作，且这个物体处于正常状态，则会发生**得分事件**，且事件的参数 $d$ 为操作位置与物体最低点的距离。若有多个标记操作符合条件，选择其中使得 $d$ 最小的，若仍有多个则选择其中位置最接近原点的，保证这样选出的操作是唯一的。随后，对于这个物体，若是一个点，则会消失，否则会*被这个操作标记*，且变成**被标记状态**。注意，一个操作可以影响多个物体，而一个物体不会被多个操作标记。

若在某一时刻，对于一个物体，距离物体的最高点不大于 $d_0$ 位置发生取消标记操作，且这个物体被相应的标记操作标记，则也会发生**得分事件**，且事件的参数 $d$ 为操作位置与物体最高点的距离。随后，这个物体会消失。

若在某一时刻，一个处于正常状态的物体的最低点到达了第四象限（注意，坐标轴上的点不属于任何一个象限），或一个处于被标记状态的物体对应的标记被取消，且没有因为取消标记发生得分事件，则会发生 **miss 事件**。随后，这个物体会消失。

一个参数为 $d$ 的得分事件发生时，玩家会得到 $(d_0^2-d^2)s_1$ 的基本得分。若此次事件前的连续 $k - 1$ 次事件都是得分事件，且此次事件前的第 $k$ 次事件不是得分事件或不存在，则玩家会得到 $ks_2$ 的额外得分。

游戏中的结算发生在距离游戏开始经过整数个单位时间的时刻之内。已经出现的物体会在相邻两个时刻之间进行移动，某一时刻开始时移动已经完成。在结算的过程中，所有物体均视为静止。游戏开始于 0 时刻。具体来说，对于包括 0 时刻在内的任一时刻：首先，这一时刻开始。随后，所有由移动造成的 miss 事件以某个顺序依次发生。随后，在这一时刻出现的物体同时出现。随后，所有操作同时发生，且保证这一时刻的标记不会在同一时刻被取消。随后，所有得分事件以某个顺序依次发生（总得分与顺序无关）。随后，所有由操作造成的 miss 事件以某个顺序依次发生。随后，所有物体的状态同时改变（消失也视为状态改变）。最后，这一时刻结束。

若所有物体均经历了出现和消失，或 miss 事件发生了严格大于 $w$ 次，游戏立即结束，此后的操作均可以忽略。

## 说明/提示

#### 样例说明

在时刻 0 发生了两次得分事件，共得到了 28 分；在时刻 5 发生了一次得分事件和一次 miss 事件，得到了 18 分；在时刻 7 发生了一次得分事件，得到了 16 分；在时刻 8 发生了一次 miss 事件，至此，所有物体都经历了出现和消失，游戏结束。

#### 数据范围

所有输入均为整数。

$1\le n,m\le 2000$；

$0\le t_i,a_i,b_i\le 10^9$；

$1\le x_i,p_i,l_i,r_i\le 10^9$；

$a_i<b_i$，$l_i\le r_i$；

$1\le v_i,v_i\cdot\max\{t_j,a_j,b_j\}\le 10^9$；

$0\le d_0,s_1,s_2\le 10^4$；

$0\le w\le n$。

对于30%的数据：$n,m\le 10$。

#### 题目更新

24.11.15：对于题意的细节改进了描述方式，增加了 hack 数据。

24.12.24：增加一组 hack 数据。

## 样例 #1

### 输入

```
4 5
4 3 3 7 6
1 8 12 1 2
1 1 3 0 1
2 1 1 0 4
4 6 7
4 7 8
4 8 9
2 0 5
2 5 7
2 5 1 2```

### 输出

```
62
8```

# 题解

## 作者：cyhhhhhh (赞：55)

这道题不知道为什么大佬们都不屑于来光顾，一篇题解都没有，那就让我这个没发过题解的蒟蒻来试试吧。其实做完之后个人觉得这一道题最难的地方是理解题意，把题意理解好以后，~~就是简单模拟了~~（对我来说还是不简单），题例的模拟过程我有发在我的“第0时刻”为题的讨论里面，因为太长不方便发在这里。

题目大概讲的是一款下落式音游（大概吧），有点和长条两种键。点的话比较简单，标记到点就得分，点掉落了就miss；线的话其实就是必须要一直标记着，然后松开标记过早或者过晚都会造成miss，只有在判定范围内才能得分

这道题显然不能用t来进行循环模拟，毕竟10^9的数据摆在那里是不可能完成的，所以我选择用操作进行循环，也就是每次循环执行一个操作，操作分别有：物体出现，物体消失（即最低点运动到第四象限），标记，取消标记，一共4种操作，由于标记和物体加起来最多只有4000个，所以循环最多8000次。所以我设置了操作栏，物品栏以及标记栏

具体解释一下我的四种操作吧：

1、物体的出现：此时会将物体从“未出现”变为“正常状态”

2、物体的消失：这里的消失是“本该在此时消失”的意思，就是说这个物体在不受任何操作下运动到第四象限，执行这个操作时，如果物体处于“正常状态”，就像题目所说的miss，如果不是，那么就跳过这个操作

3、标记：执行这个操作时，会寻找目前处于“正常状态”的物体进行判定（即判定是否得分），并且如题目所说，当两个标记同时对一个物体生效时，会按照规则进行替代，即离物体最近且最接近顶点的标记生效。

4、取消标记：执行这个操作时，会寻找被此标记进行标记过的长条，随后进行判定。

最后再解释代码里面可能有疑惑的地方：

1、物品栏和标记栏是对物品和标记进行编号，操作栏储存的是执行操作的物品或标记的编号

2、关于物品的h值（即状态）：0、1、2都很好理解。给h定义了一个3的原因是在题目中，同一时刻的标记操作是同时执行的，然而操作栏中我没办法做到同时执行，肯定会有先后顺序，所以就用3代表物体在这个时刻已经有标记对它进行了标记，但如果还有得分更高或者得分相等但更接近原点的标记可以对它生效，会发生代替，而这个h值会在时刻结束时进行修改。

3、关于操作的排序：其实就是按照题目的排序

（1）由于物体消失导致的miss（即物体消失排在第一位）

（2）物体出现（即物体出现排在第二位）

（3）由于标记和取消标记造成得分

（4）由于取消标记造成miss（即标记排在第三位，取消标记排在第四位）

最后，代码如下，如果有不懂的还可以问我，有点长，里面还会有文字注释帮助理解
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct doit
{
	int appear;//有物体出现的操作（即表明第几号物体在此时出现） 
	int disappear;//有物体消失的操作（即表明第几号物体在此时消失）（表明物体在正常情况下运动到第四象限的时间） 
	int note;//标记操作（即表明第几个标记在此时操作） 
	int cancel;//取消标记操作（即表明第几个标记在此时取消） 
	long long time;//操作时间（即在第几时刻进行的操作） 
};//定义操作栏



struct item
{
	int h;//物体的状态（0表示未出现，1表示正常状态，2表示已经消失或者长条被标记状态，3表示在该时刻已经被标记过了，用于判断究竟是哪个标记起作用）
	long long line;//物体的x坐标 
	long long ly;//物体初始的最低点坐标 
	long long hy;//物体初始的最高点坐标 
	long long v;//物体的速度 
	long long firstp;//物体的第一次得分（即标记得分），因为会被覆盖所以需要储存最大值 
	long long t;//物体出现时的时间 
	int benote;//表示物体被几号标记所标记
	long long notep;//表示标记此物体的标记所在的位置 
};//定义物品栏



long long cmp(doit a,doit b)
{
	if(a.time!=b.time)return a.time<b.time;
	else if(a.disappear!=b.disappear)return a.disappear>b.disappear;
	else if(a.appear!=b.appear)return a.appear>b.appear;
	else if(a.note!=b.note)return a.note>b.note;
	else return a.cancel>b.cancel;
};//操作排序优先级：time→disappear→appear→note→cancel 




int main()
{
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout); 
	int n,m;
	cin>>n>>m;
	int o=2*(m+n);
	doit a[o+1];//声明操作栏
	item b[n+1];//声明物品栏
	int c[m+1];//声明标记栏 
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	
	
	
	for(int i=1;i<=n;i++)
	{
		cin>>b[i].line>>b[i].ly>>b[i].hy>>b[i].t>>b[i].v;//输入物品初始信息（h值默认为0） 
		a[2*i-1].appear=i;
		a[2*i-1].time=b[i].t;
		a[2*i].disappear=i;
		a[2*i].time=b[i].t+1+(b[i].ly/b[i].v);//将物品的出现和消失时间加入操作栏中 
	}
	
	
	
	for(int i=1;i<=m;i++)
	{
		cin>>c[i]>>a[2*(n+i)-1].time>>a[2*(n+i)].time;//输入标记 
		a[2*(n+i)-1].note=i;
		a[2*(n+i)].cancel=i;//将标记和取消标记加入操作栏 
	}
	
	
	
	long long d0,s1,s2,w;//d0是判定长度，s1是基础分数，s2是额外基础分数，w是允许miss的次数 
	cin>>d0>>s1>>s2>>w;
	sort(a+1,a+o+1,cmp);//排序操作 
	long long combo=0,miss=0,lastmiss=0,dcount=0;
	//combo即连击数，miss即miss数
	//lastmiss储存上一时刻的miss数，当这一时刻miss比上一时刻多时，combo被断
	//dcount累计消失的物体个数，当dcount=n时游戏结束 
	long long total=0;
	
	
	
	for(int i=1;i<=o;i++)//游戏开始了 
	{
		if(a[i].appear!=0)b[a[i].appear].h=1;//当有物体出现时，该物体处于正常状态
		
		
		if(a[i].disappear!=0)
		{
			if(b[a[i].disappear].h==1)
			{
				miss++;
				combo=0;
				lastmiss=miss;
				dcount++;
				b[a[i].disappear].h=2;
			}//如果物体处于正常状态掉落，则miss
			//如果物体在其他时刻消失或者被标记，不考虑disappear操作
			
			
			if(miss>w)//miss数超限，游戏结束 
			{
				cout<<total<<endl<<a[i].time<<endl;
				return 0;
			} 
		}
		
		
		if(a[i].note!=0)
		{
			for(int j=1;j<=n;j++)
			{
				if(b[j].h==1||b[j].h==3)//表示物体在本轮处于正常状态（在不确定哪个标记生效时处于正常状态） 
				{
					long long dx=c[a[i].note]-b[j].line;//物体距离标记的水平距离 
					long long dy=b[j].ly-b[j].v*(a[i].time-b[j].t);//物体离标记的竖直距离，即物体此时最低点的纵坐标
					long long distance=dx*dx+dy*dy;//直线距离的平方，与d0的平方比较
					
					
					if(distance<=d0*d0)
					{
						long long point=(d0*d0-distance)*s1;//分数
						if(b[j].firstp==0)
						{
							combo++;
							total+=(point+combo*s2);
							b[j].firstp=point;
							if(b[j].hy!=b[j].ly)
							{
								b[j].benote=a[i].note;//如果物体是一条线，则被标记
								b[j].notep=c[a[i].note];//储存标记所在的位置 
							}
						}//如果物体这个时刻还没有受过标记，则combo数增加，并取得额外得分
						
						
						else if(point>b[j].firstp)//比较标记的得分，取最大的为生效的标记 
						{
							total+=(point-b[j].firstp);
							b[j].firstp=point;
							b[j].benote=a[i].note;//被标记
							b[j].notep=c[a[i].note];//储存标记所在的位置 
						}
						
						
						else if(point==b[j].firstp)//如果相等，比较标记离原点的距离 
						{
							if(b[j].notep>c[a[i].note])//离原点更近则替换 
							{
								b[j].benote=a[i].note;
							    b[j].notep=c[a[i].note];
							}
						}
						
						
						b[j].h=3;//改变物体的状态 
					}
				} 
			}
		}
		
		
		if(a[i].cancel!=0)
		{
			for(int j=1;j<=n;j++)
			{
				if(b[j].benote==a[i].cancel)
				{
					long long dx=c[a[i].cancel]-b[j].line;//物体距离标记的水平距离
					long long dy=b[j].hy-b[j].v*(a[i].time-b[j].t);//物体离标记的竖直距离，即物体此时最高点的纵坐标
					long long distance=dx*dx+dy*dy;//直线距离的平方，与d0的平方比较
					
					
					if(distance<=d0*d0)
					{
						long long point=(d0*d0-distance)*s1;//分数
						combo++;
						total+=(point+(combo*s2));
					}
					
					
					else miss++;
					//在这里先不判定miss是否大于w或者lastmiss，等到本时刻结束再判定
					//因为由操作引起的miss是在得分之后进行的，而在这里得分和miss是一起算的
					
					
					b[j].h=2;
					dcount++;//无论怎么样都会消失 
				}
			}
		}
		
		
		if(dcount==n)
		{
			cout<<total<<endl<<a[i].time<<endl;
			return 0;
		}//所有物体都消失，游戏结束
		
		
		if(a[i].time!=a[i+1].time||i==o)//当本时刻结束时，结算miss，并且将状态为3的物体处理掉
		{
			if(miss>w)
			{
				cout<<total<<endl<<a[i].time<<endl;
				return 0;
			}
			
			
			for(int j=1;j<=n;j++)
			{
				if(b[j].h==3)
				{
					if(b[j].hy==b[j].ly)dcount++;//是一个点的话，被标记立即消失
					b[j].h=2;//无论是点还是线状态都为2，但表示的意义不同 
				}
			}
			
			
			if(lastmiss!=miss)
			{
				combo=0;
				lastmiss=miss;
			}//如果本轮的操作出现了miss，则清除combo
			
			
			if(dcount==n)
	    	{
	    		cout<<total<<endl<<a[i].time<<endl;
	    		return 0;
	    	}//所有物体都消失，游戏结束
		} 
	}
	
	
	fclose(stdin);
	fclose(stdout);
	return 0;
} 
```

---

## 作者：LucasQiao (赞：3)

# [Luogu P5317](https://www.luogu.com.cn/problem/P5317)
## 题意概要
题面很长，不过对于玩过音游的人而言应该比较容易理解。其实就是模拟一个不定轨下落式音游，存在点和线段两种音符，计算最后的得分和游戏结束时刻。
## 思路
模拟题自然是从题面入手，让我们参照题面进行思考。 

如果直接按照题意将每个时刻都进行模拟，显然是超时的（时刻最大可达 $10^9$）。注意到大部分的时刻是无用的，只需要关注有事件发生的时刻。 

根据题意，事件一共有六种：

1. 移动造成的 miss 事件
2. 音符出现
3. 操作的进行（标记和取消标记）
4. 得分事件
5. 操作造成的 miss 事件
6. 物体消失

物体的移动不算作事件，而是在时刻之间进行，我们直接用时间和速度进行计算就行。   

接下来我们分析一下这些事件。不难发现事件 $4、5、6$ 其实是多余的，因为“得分事件”，“操作造成的 miss”和“物体消失”一定是前面 $3$ 个事件产生的子事件，直接一起计算即可。所以我们只需要考虑前 $3$ 种事件即可。而第 $3$ 种事件分成两种事件考虑更为自然、方便：标记和取消标记。  

我们再考虑每个时刻有什么对象需要进行维护：可以发现标记和取消标记是瞬时的，而音符是在一段时间内存在的，所以我们需要针对音符进行维护（也可以在标记的时候直接遍历）。 

音符分为两种：点和线段。点是简单的，我们只需要在合法的标记事件产生时删除点，并且计算得分即可。线段则需要再考虑绑定的标记取消事件。这也并不难维护，我们在取消事件发生的时候将所有取消事件绑定的线段进行计算得分和 miss 即可。 

由此，我们要做的事情就很清晰了：将所有需要考虑的事件按照时间、题意中计算的先后顺序排序，依次存储每个事件可能产生的影响。在时刻发生改变时，再统一计算。   

具体的实现和细节可以参考代码。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
int d0, s1, s2, w;
int bl[2050]; //存储 Note 绑定的 Tap
int score = 0, end_time = 0, misum = 0, pre = 0, combo = 0, mi = 1;
vector<int> hold[2050], de; //DeTap 操作和其绑定的 Note
set<int> tpd;
set<int> alive;
struct Note{
    int x, l, r, t, v;
};
vector<Note> note;
struct Tap{
    int p, a, b;
};
vector<Tap> tap;
struct Event{
    int f, t, id; 
    //f = 1, 2, 3, 4 出现 消失 标记 取消标记
};
vector<Event> event;
bool cmp(Event x, Event y) {
    if (x.t == y.t) return x.f < y.f;
    return x.t < y.t;
}
int getDis(int x, int y, int t) {
    int dis = note[x].l - (t - note[x].t) * note[x].v;
    int dis1 = abs(note[x].x - tap[y].p);
    return dis * dis + dis1 * dis1;
}
int getDisR(int x, int y, int t) {
    int dis = note[x].r - (t - note[x].t) * note[x].v;
    int dis1 = abs(note[x].x - tap[y].p);
    return dis * dis + dis1 * dis1;
}
void solve() {        
    for (auto i : tpd) {
        //得分
        combo++;
        end_time = max(end_time, pre);
        int dis = getDis(i, bl[i], pre);
        score += (d0 * d0 - dis) * s1;
        score += combo * s2;
        if (note[i].l != note[i].r) {
            hold[bl[i]].push_back(i);
            end_time = max(end_time, tap[bl[i]].b);
        }
        alive.erase(i);
        bl[i] = -1;
    }
    for (auto i : de) {
        for (auto k : hold[i]) {
            int dis = getDisR(k, i, pre);
            if (dis > d0 * d0) {
                //操作导致的 miss，不能立刻断连击
                end_time = max(end_time, pre);
                misum++; mi = 0;
            }
            else {
                //得分
                combo++;
                end_time = max(end_time, pre);
                int dis = getDisR(k, i, pre);
                score += (d0 * d0 - dis) * s1;
                score += combo * s2;
            }
        }
        hold[i].clear();
    }
}
signed main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        Note tmp;
        cin >> tmp.x >> tmp.l >> tmp.r >> tmp.t >> tmp.v;
        note.push_back(tmp);
        event.push_back({1, tmp.t, i - 1});
        event.push_back({2, tmp.t + tmp.l / tmp.v + 1, i - 1});
    }
    for (int i = 1; i <= m; i++) {
        Tap tmp;
        cin >> tmp.p >> tmp.a >> tmp.b;
        tap.push_back(tmp);
        event.push_back({3, tmp.a, i - 1});
        event.push_back({4, tmp.b, i - 1});
    }
    cin >> d0 >> s1 >> s2 >> w;
    sort(event.begin(), event.end(), cmp);
    memset(bl, -1, sizeof(bl)); de.clear();
    for (auto i : event) {
        int now = i.t; 
        //新的时刻，计算得分和 miss
        if (now != pre) {
            solve();
            if (misum > w) {
                //miss 导致的游戏结束可以提前计算
                end_time = pre;
                break;
            }
            if (!mi) combo = 0, mi = 1;
            tpd.clear();
            de.clear();
        }
        //音符出现
        if (i.f == 1) alive.insert(i.id);
        //音符自然消失
        if (i.f == 2) {
            if (alive.find(i.id) != alive.end()) {
                alive.erase(i.id);
                misum++; combo = 0;
                end_time = max(end_time, now);
                if (misum > w) {
                    end_time = now;
                    break;
                }
            }
        }
        //标记
        if (i.f == 3) for (auto j : alive) {
            int dis = getDis(j, i.id, now);
            if (dis <= d0 * d0) {
                tpd.insert(j);
                if (bl[j] == -1) bl[j] = i.id;
                else if (dis < getDis(j, bl[j], now)) bl[j] = i.id;
                else if (dis == getDis(j, bl[j], now) && 
                         tap[i.id].p < tap[bl[j]].p) bl[j] = i.id;
            }
        }
        //取消标记
        if (i.f == 4) de.push_back(i.id);
        pre = now;
    }
    if (misum <= w) solve();
    cout << score << endl;
    cout << end_time << endl;
    return 0;
}
```

---

## 作者：Zskioaert1106 (赞：3)

终于过了！

~~从去年调到现在。~~

~~可是……总感觉心里有点不踏实，为什么关了 O2 就似了。~~

题目传送门：[P5317 简单模拟](https://www.luogu.com.cn/problem/P5317)

谨此纪念我的 OI 生涯中第一道过掉的蓝色大模拟。

### 题目大意

哦，打音游啊（蒿坪）。

### 题意分析

看到题目我们发现每个物体的一生是唯一且很容易确定的，又看到 $n$ 和 $m$ 的大小，所以想到用二维循环模拟每个物生轨迹。

我们将每队操作视为两个独立的操作，则每个操作有以下属性：

- 编号 $i$，表示这个操作是第几对（方便标记与取消配对）。

- 性质 $b$，表示这个操作是标记还是取消。如果是标记则该布尔值为真。

- 位置（横坐标）$p$，含义如题目描述。

- 发生的时间 $t$。对于编号为 $i$ 的操作，如果 $b=1$ 则 $t=a_i$，否则 $t=b_i$。

这样算下来共会有 $2m$ 个操作，而对于每个物体，我们都要将其排一遍序——先按时间，再按优先级——这样可以保证在满足该物体条件的情况下，越前面的越优。

那么什么操作才能入该物体的法眼呢？

首先，如果操作的时间小于物体出现的时间，则直接排除。特别地，如果当前物体未被标记且操作时间大于物体到达第四象限的时间，直接结束循环（判定该物体最终因移动而 miss）。

接下来我们求出本次操作对于该物体的参数 $d'$。如果 $d'\leqslant d_0$，则本次事件的参数 $d$ 就是 $d'$。这样留下来的操作就是合法的了。

对于遇见的操作，如果是合法的标记操作且物体未被标记，那么记录下该物体被标记的操作编号，并使总得分加上 $({d_0}^2 - {d}^2)s_1$ 的基础得分。注意：如果这个物体是点那么直接让其消失。

如果是取消标记操作且物体正好被该操作对所标记，则如果该操作合法就记录得分，否则直接让其消失。

最后把所有改变了物体状态的操作都记录下时间、性质，方便最后计算额外得分。

在一个物体的循环结束时，如果该物体仍未 miss，那么它将因移动而 miss。

最后将所有记录下来的事件按时间为第一关键字、题目给定的顺序为第二关键字排序，计算额外得分和结束时间即可。

### 代码编写

定义物品的属性有：题目给出的五条、标记号和是否 miss：

```cpp
struct wp{
	long long t,x,l,r,v;
	int bj;
	bool miss;
}a[2003];
```

操作的属性上问说过了，不过注意要开两倍的数组：

```cpp
struct cz{//声明：仅仅是采用“操作”二字的首字母
	int i;
	bool b;
	int p,t;
}c[4003];
```

然后是物品的排序方式。具体地，先按时间，然后计算两个操作对于物体的距离，然后按距原点的远近：

```cpp
bool cmp(cz c1,cz c2){
	if(c1.t!=c2.t)return c1.t<c2.t;
	long long d1=(a[now].x-c1.p)*(a[now].x-c1.p)+(a[now].l-(c1.t-a[now].t)*a[now].v)*(a[now].l-(c1.t-a[now].t)*a[now].v),d2=(a[now].x-c2.p)*(a[now].x-c2.p)+(a[now].l-(c2.t-a[now].t)*a[now].v)*(a[now].l-(c2.t-a[now].t)*a[now].v);
	if(d1!=d2)return d1<d2;
	return c1.p<c2.p;
}
```

接下来是存储事件发生的顺序。我们定义表示状态的 $zt$ 变量：$zt=0$ 代表因移动而 miss；$zt=1$ 代表因取消标记而得分；$zt=2$ 代表因取消标记而 miss；$zt=3$ 代表标记产生的得分事件。

```cpp
struct endtime{
	short zt;
	long long t;
	int i;
}endd[4003];
bool cmpend(endtime a1,endtime a2){
	if(a1.t!=a2.t)return a1.t<a2.t;
	if(a1.zt==0||a2.zt==0)return (a1.zt==0);
	return (a1.zt==1||a1.zt==3);
}
```

我们还可以就此写一个简易的调试器：

```cpp
string bugo(short x){
	if(x==0)return "miss-0";
	if(x==1)return "score-out";
	if(x==2)return "miss-out";
	if(x==3)return "score-in";
}
```

（说实话，我觉得这道大模拟给我的最大收获在于霸道地将不爱调试代码的我锻炼出来了调试代码的能力）

***

接下来是输入和初始化了。

```cpp
cin>>n>>m;
for(int i=1;i<=n;i++)
  cin>>a[i].x>>a[i].l>>a[i].r>>a[i].t>>a[i].v;
for(int i=1;i<=m*2;i+=2){
  int cp,ca,cb;
  cin>>cp>>ca>>cb;
  c[i].b=1,c[i].p=cp,c[i].t=ca,c[i].i=i;
  c[i+1].p=cp,c[i+1].t=cb,c[i+1].i=i;
}
cin>>d0>>s1>>s2>>w;
d0*=d0;
```

我们将 $d_0$ 先自乘一番，之后都以平方来比较，既保证了精度也避免了一些麻烦，反正最终的得分计算也是用平方来减。

对于每件物体：

```cpp
long long miss_time=a[i].t+(a[i].l)/a[i].v+1;//计算物体因移动而 miss 的时间
now=i;
sort(c+1,c+m*2+1,cmp);
```

对于每个操作，先判断操作是否早于物体出现，再算出此时物体的最位置（如最低点的位置为 $l_i-(t_j-t_i)v_i$）：

```cpp
for(int j=1;j<=m*2;j++){
  if(c[j].t<a[i].t)continue;
  long long dl=a[i].l-(c[j].t-a[i].t)*a[i].v,dr=a[i].r-(c[j].t-a[i].t)*a[i].v;
```

如果当前物体还是空白的且该操作是标记，那么可以计算物体最低端与操作位置距离的平方，即 $(x_i-p_j)^2+{d_l}^2$。如果操作时间早于物体因移动而 miss 的时间且在平方比较下距离不大于 $d_0$ 则将标记号设为 $j$ 并加上基础得分、把标记得分事件存入（记得判断是不是点，是的话就直接跳出循环）：

```cpp
if(c[j].b&&!a[i].bj){
  if(c[j].t>=miss_time)break;
  long long d=(a[i].x-c[j].p)*(a[i].x-c[j].p)+(dl*dl);
  if(d<=d0){
    a[i].bj=c[j].i;//被标记了）
    s+=(d0-d)*s1;//基础得分项
    endd[I].t=c[j].t,endd[I++].zt=3;
    if(a[i].l==a[i].r){//点
      a[i].miss=1;
      break;
    }
  }
}
```

如果当前操作正是来取消被标记的物体的，注意不论结果如何这个物体都会消失所以计入事件。那么区别就在于是否合法：

```cpp
if(!c[j].b&&a[i].bj==c[j].i){
  endd[I].t=c[j].t;
  long long d=(a[i].x-c[j].p)*(a[i].x-c[j].p)+(dr*dr);
  if(d<=d0){
    s+=(d0-d)*s1;
    endd[I++].zt=1;
  }
  else endd[I++].zt=2;
  a[i].miss=1,a[i].bj=0;
  break;//物体消失后自然结束遍历
}
```

在都循环过一遍后如果物体还没有 miss，那么这个物体就因移动而 miss 了，记录下来。

```cpp
if(!a[i].miss){
  endd[I].t=miss_time,endd[I++].zt=0;
  a[i].miss=1;
}
```

***

最后我们将所有的事件排序。对于一个状态为 $1$ 或 $3$（即得分）的事件，让 $k$ 加 $1$，总分加上 $k\cdot s_2$ 的额外得分；否则就是让 $k\leftarrow 0$ 并且记一次 miss 总数，与 $w$ 比较。何时结束了就输出当时的总分和当前事件发生时刻即可。

```cpp
sort(endd,endd+I,cmpend);
for(int i=0;i<I;i++){
  if(endd[i].zt==1||endd[i].zt==3){
    k++;
    s+=k*s2;
  }
  else{
    if(!w){//中道崩殂
      cout<<s<<'\n'<<endd[i].t;
      return 0;
    }
    else w--;
    k=0;
  }
}
cout<<s<<'\n'<<endd[I-1].t;//寿终正寝
```

本来这里是有一条调试语句的，帮了我不少的忙：

```cpp
cerr<<endd[i].t<<':'<<endd[i].i<<' '<<bugo(endd[i].zt)<<endl;
```

### 最终代码

终于来到这一刻了！

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,w,now,I;
long long s1,s2,d0,k,s;
struct wp{
	long long t,x,l,r,v;
	int bj;
	bool miss;
}a[2003];
struct cz{
	int i;
	bool b;
	int p,t;
}c[4003];
bool cmp(cz c1,cz c2){
	if(c1.t!=c2.t)return c1.t<c2.t;
	long long d1=(a[now].x-c1.p)*(a[now].x-c1.p)+(a[now].l-(c1.t-a[now].t)*a[now].v)*(a[now].l-(c1.t-a[now].t)*a[now].v),d2=(a[now].x-c2.p)*(a[now].x-c2.p)+(a[now].l-(c2.t-a[now].t)*a[now].v)*(a[now].l-(c2.t-a[now].t)*a[now].v);
	if(d1!=d2)return d1<d2;
	return c1.p<c2.p;
}
struct endtime{
	short zt;
	int t;
}endd[4003];
bool cmpend(endtime a1,endtime a2){
	if(a1.t!=a2.t)return a1.t<a2.t;
	if(a1.zt==0||a2.zt==0)return (a1.zt==0);
	return (a1.zt==1||a1.zt==3);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].l>>a[i].r>>a[i].t>>a[i].v;
	for(int i=1;i<=m*2;i+=2){
		int cp,ca,cb;
		cin>>cp>>ca>>cb;
		c[i].b=1,c[i].p=cp,c[i].t=ca,c[i].i=i;
		c[i+1].p=cp,c[i+1].t=cb,c[i+1].i=i;
	}
	cin>>d0>>s1>>s2>>w;
	d0*=d0;
	for(int i=1;i<=n;i++){
		long long miss_time=a[i].t+(a[i].l)/a[i].v+1;
		now=i;
		sort(c+1,c+m*2+1,cmp);
		for(int j=1;j<=m*2;j++){
			if(c[j].t<a[i].t)continue;
			long long dl=a[i].l-(c[j].t-a[i].t)*a[i].v,dr=a[i].r-(c[j].t-a[i].t)*a[i].v;
			if(c[j].b&&!a[i].bj){
				if(c[j].t>=miss_time)break;
				long long d=(a[i].x-c[j].p)*(a[i].x-c[j].p)+(dl*dl);
				if(d<=d0){
					a[i].bj=c[j].i;
					s+=(d0-d)*s1;
					endd[I].t=c[j].t,endd[I++].zt=3;
					if(a[i].l==a[i].r){
						a[i].miss=1;
						break;
					}
				}
			}
			else if(!c[j].b&&a[i].bj==c[j].i){
			    endd[I].t=c[j].t;
				long long d=(a[i].x-c[j].p)*(a[i].x-c[j].p)+(dr*dr);
				if(d<=d0){
					s+=(d0-d)*s1;
					endd[I++].zt=1;
				}
				else endd[I++].zt=2;
				a[i].miss=1,a[i].bj=0;
				break;
			}
		}
		if(!a[i].miss){
			endd[I].t=miss_time,endd[I++].zt=0;
			a[i].miss=1;
		}
	}
	sort(endd,endd+I,cmpend);
	for(int i=0;i<I;i++){
		if(endd[i].zt==1||endd[i].zt==3){
			k++;
			s+=k*s2;
		}
		else{
			if(!w){
				cout<<s<<'\n'<<endd[i].t;
				return 0;
			}
			else w--;
			k=0;
		}
	}
	cout<<s<<'\n'<<endd[I-1].t;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/197106524)。

发现复杂度最高的地方其实就是每次 $1$ 到 $n$ 的遍历里那个 $m\log m$ 的排序。所以这份代码的时间复杂度是 $\mathcal O(nm\log m)$，加上一些常数和其它的循环也快到 $10^8$ 的量级了……

---


# [SDOI2019] 快速查询

## 题目描述

给定一个长度为 $n$ 的整数数列，里面的元素依次编号为 $a_1,~a_2,~a_3,~\dots,~a_n$。初始的时候，所有元素都为零。现在按照时间顺序提供了若干次关于这个数列的修改或询问，每一次修改或询问一定为以下六种情况之一：

- **1 i val** ：将 $a_i$ 赋值为给定整数 $val$；

- **2 val** ：将所有元素同时加上 $val$；

- **3 val** ：将所有元素同时乘上 $val$；

- **4 val** ：将所有元素同时赋值为 $val$；

- **5 i** ：询问第 $i$ 个元素 $a_i$ 现在的值是多少；

- **6** ：询问现在所有元素的和。

## 说明/提示

子任务$1$：（$50$分）$1\le  n\le 500000$，$1\le q\le 10^5$ 且 $1\le t\le 5$，所有在输入中出现的$val$  满足$-10^9\le val\le 10^9$，所有$a_i$和$b_i$满足$0\le a_i,b_i\le 10^9$

子任务$2$：（$50$分）$1\le n\le 10^9$，$1\le q\le 10^5$ 且 $1\le~t~\le~100$，所有在输入中出现的$val$ 满足$-10^9\le val\le  10^9$，所有$a_i$和$b_i$满足$0\le a_i,b_i\le 10^9$



## 样例 #1

### 输入

```
7
28
6
4 -192321079
3 418379342
1 3 189801569
3 -840249197
4 -751917965
3 649799919
1 5 -92666141
6
4 451258008
5 1
4 696880327
3 772574465
6
4 301010289
3 480168068
5 3
5 2
4 840536237
5 5
5 4
1 7 -792284106
2 604521872
3 966540578
2 -381646699
3 -939378260
2 -20129935
6
2
0 1
197 199```

### 输出

```
2816930```

# 题解

## 作者：liuzhangfeiabc (赞：6)

题目大意：给定初始全0的序列，支持：单点修改，全局加，全局乘，全局赋值，单点查询，全局查询。要求每次操作O(1)。

现场平衡树过了的神仙深受我一拜。

注意到操作只有单点和全局，而且虽然序列很长但是修改的点最多1e5个，我们就可以把所有的点拎出来重标号。

我们发现，其实最麻烦的地方是怎么查询单点的值，其余直接模拟就好啦。

需要维护的东西有：一个“标准元素”（未被单点修改的元素）的值，全局所有元素的和。

还需要记录一下一个点上一次被单点修改是什么时候以及上一次全局赋值是什么时候。

单点查询时，如果上一次全局赋值在它上一次单点修改之后，那么它的值当然是“标准元素”啦。

否则呢？考虑从上一次单点修改之后，这个元素经历了什么：

设x为上一次单点修改时的初值：

((x×a1+b1)×a2+b2)×a3+b3......

这其中x的贡献为：

x×a1×a2×a3×……

如果在上一次单点修改时，标准元素的值是y，则两者最终相差：

(x-y)×a1×a2×a3×……

因此我们只需要记录下修改时(x-y)的值，再想办法求出这段区间内所有3操作的连乘即可求出答案。

区间连乘怎么求？可以看作是一个前缀乘一个前缀的逆元。

对每个前缀求逆元，只需要像预处理阶乘的逆元那样，求出全局乘积的逆元再倒着算回去。

然而这就做完了吗？你会发现你获得了0分的好成绩。

原因是你可能会除以0。

因此你还需要记录区间内有多少个0，并在求前缀积时把所有为0的项忽略掉。查询时先判断区间内有没有0，没有的话再算前缀乘前缀的逆元就是对的了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
	li x = 0,y = 0,c = gc;
	while(!isdigit(c)) y = c,c = gc;
	while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
	return y == '-' ? -x : x;
}
inline void print(li q){
	if(q < 0) pc('-'),q = -q;
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
const int mo = 10000019;
inline li ksm(li q,li w){
	li as = 1;
	while(w){
		if(w & 1) as = as * q % mo;
		q = q * q % mo;
		w >>= 1;
	}
	return as;
}
int n,m,t;
struct qy{
	int op,x,y;
}a[100010];
unordered_map<int,int> mp;
li qa[110],qb[110];
int bh[10000010],nw,tot;
int jc[10000010],nj[10000010],ling[10000010];
int lst[100010];
li vl[100010];
li an;
int main(){
	int i,j,u,v;
	n = read();m = read();
	for(i = 1;i <= m;++i){
		a[i].op = read();
		if(a[i].op == 1){
			a[i].x = read();
			if(!mp[a[i].x]) mp[a[i].x] = ++nw;
			a[i].x = mp[a[i].x];
			a[i].y = (read() % mo + mo) % mo;
		}
		else if(a[i].op <= 4){
			a[i].x = (read() % mo + mo) % mo;
		}
		else if(a[i].op == 5){
			a[i].x = read();
			if(!mp[a[i].x]) mp[a[i].x] = ++nw;
			a[i].x = mp[a[i].x];
		}
	}
	t = read();tot = m * t;
	for(i = 1;i <= t;++i){
		qa[i] = read();qb[i] = read();
	}
	for(i = 1;i <= t;++i) for(j = 1;j <= m;++j) bh[(i - 1) * m + j] = (qa[i] + j * qb[i]) % m + 1;
	jc[0] = 1;
	for(i = 1;i <= tot;++i){
		if(a[bh[i]].op != 3) jc[i] = jc[i - 1],ling[i] = ling[i - 1];
		else if(a[bh[i]].x) jc[i] = 1ll * jc[i - 1] * a[bh[i]].x % mo,ling[i] = ling[i - 1];
		else jc[i] = jc[i - 1],ling[i] = ling[i - 1] + 1; 
	}
	nj[tot] = ksm(jc[tot],mo - 2);
	for(i = tot - 1;i >= 0;--i){
		if(a[bh[i + 1]].op == 3 && a[bh[i + 1]].x) nj[i] = 1ll * nj[i + 1] * a[bh[i + 1]].x % mo;
		else nj[i] = nj[i + 1];
	}
	li nw1 = 0,nw2 = 0,val,tmp;
	int lt = 0;
	for(i = 1;i <= tot;++i){
		if(a[bh[i]].op == 1){
			u = a[bh[i]].x;
			if(lt >= lst[u]) val = nw1;
			else{
				v = lst[u];
				if(ling[i] - ling[v]) tmp = 0;
				else tmp = 1ll * jc[i] * nj[v] % mo;
				val = (nw1 + vl[u] * tmp) % mo;
			}
			(nw2 += a[bh[i]].y - val + mo) %= mo;
			vl[u] = (a[bh[i]].y - nw1 + mo) % mo;
			lst[u] = i;
		}
		else if(a[bh[i]].op == 2){
			(nw1 += a[bh[i]].x) %= mo;
			(nw2 += 1ll * n * a[bh[i]].x) %= mo;
		}
		else if(a[bh[i]].op == 3){
			(nw1 *= a[bh[i]].x) %= mo;
			(nw2 *= a[bh[i]].x) %= mo;
		}
		else if(a[bh[i]].op == 4){
			nw1 = a[bh[i]].x;
			nw2 = 1ll * n * a[bh[i]].x % mo;
			lt = i;
		}
		else if(a[bh[i]].op == 5){
			u = a[bh[i]].x;
			if(lt >= lst[u]) val = nw1;
			else{
				v = lst[u];
				if(ling[i] - ling[v]) tmp = 0;
				else tmp = 1ll * jc[i] * nj[v] % mo;
				val = (nw1 + vl[u] * tmp) % mo;
			}
			(an += val) %= mo;
			
		}
		else{
			(an += nw2) %= mo;
		}
	}
	print(an);
	return 0;
}
```

---

## 作者：reyik (赞：5)

这是这次SDOI唯一会做的题，~~话说我们教练为什么同步赛只通知第二场？？？（大雾）~~

首先一开始感觉有点像线段树，可是数据范围不对。

所以我们应该换换思路。

这题肯定不是分块，但是我们可以借用分块的打标记操作。

因为先加后乘和先乘后加是不一样的，所以用 add 和 mul来 打标记

然后对于$1$操作，只需要用$v[i]$表示至少进行过一次操作的编号，用$v[0]$代表没有进行过$1$操作的。

怎么维护 ？？ 只要在第一个操作的时候把他更新成 他比加法标记多多少，再乘一个乘标记的逆元就好啦！。

然后我们还要维护一个时间数组，$tim[i]$表示上一次对$i$点进行单点更新的时间点。

用$last$记录最近一次整个更新的时间点。

在$5$操作中，只需要看他最近一次是单点更新还是整体更新，如果单点更新<=整体更新用$v[0]$，否则就用$v[i]$。

然后其他操作总是挺~~简单~~（难）的吧，就不讲了

代码：

```
#include<iostream>
#include <cstdio>
#include <cstring>
#include <map>
#include <unordered_map>
using namespace std;
const int maxn=1e5+7,mod=1e7+19;
struct query {
	int c,x,y;
}q[maxn];
unordered_map<int,int>mp;
int n,m,Q,t,mul,add,ans,sum,last,a[maxn],b[maxn],v[maxn],tim[maxn],inv[maxn*100];
void solve(int i,int t)
{
    if(q[i].c==6) ans=(ans+sum)%mod;
    else if(q[i].c==2) sum=(sum+1ll*n*q[i].x)%mod,add=(add+q[i].x)%mod;
    else if(q[i].c==3) sum=1ll*sum*q[i].x%mod,mul=1ll*mul*q[i].x%mod,add=1ll*add*q[i].x%mod;
    else if(q[i].c==4) sum=1ll*n*q[i].x%mod,last=t,mul=1,add=0,v[0]=q[i].x;
    else if(q[i].c==5) {
        if(tim[q[i].x]<=last) ans=(ans+1ll*mul*v[0]+add)%mod;
        else ans=(ans+1ll*mul*v[q[i].x]+add)%mod;
    }
    else {
        if(tim[q[i].x]<=last) sum=(sum-1ll*mul*v[0]%mod-add+2*mod)%mod;
        else sum=(sum-1ll*mul*v[q[i].x]%mod-add+2*mod)%mod;
        sum=(sum+q[i].y)%mod,tim[q[i].x]=t,v[q[i].x]=1ll*(q[i].y-add+mod)*inv[mul]%mod;
    }
}
int main()
{
    scanf("%d%d",&n,&Q);
    inv[1]=1;for(int i=2;i<mod;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    for(int i=1;i<=Q;++i) {
        scanf("%d",&q[i].c);
        if(q[i].c!=6) scanf("%d",&q[i].x);
        if(q[i].c==1) {
            scanf("%d",&q[i].y);
            q[i].y=(q[i].y%mod+mod)%mod;
            if(!mp[q[i].x]) mp[q[i].x]=++m;
        }
        else if(q[i].c<=4) q[i].x=(q[i].x%mod+mod)%mod;
        if(q[i].c==3 && q[i].x==0) q[i].c=4;
    }
    for(int i=1;i<=Q;++i)if(q[i].c==1||q[i].c==5) q[i].x=mp[q[i].x];
    mul=1;
    scanf("%d",&t);
    for(int i=1;i<=t;++i) scanf("%d%d",&a[i],&b[i]);
    for(int i=1;i<=t*Q;++i) {
        int x=(i-1)/Q+1,y=(i-1)%Q+1;
        solve((a[x]+1ll*y*b[x])%Q+1,i);
    }
    printf("%d\n",ans);
    return 0;
}

```

代码真短！！！！

---

## 作者：MLEAutoMaton (赞：3)

考虑首先可以离散化，那么我们剩下来的操作可以~~用线段树维护~~：

维护两个标记$(tag,mul)$表示对于一个数$x$，答案是$x*mul+tag$。

那么除了区间赋值之外的标记都可以很好的维护。

考虑区间赋值直接暴力和上一次操作之间的所有单点修改全部改掉就行了，这样子的复杂度$\sum$是不会超过$Q$的。

```cpp
/*====================
author: fexuile
mail: fexuile@qq.com
QQ: 2165008534
====================*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<iostream>
#include<set>
#include<map>
using namespace std;
#define mp make_pair
#define ll long long
#define re register
typedef pair<int,int> pii;
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
inline int gi(){
	int f=1,sum=0;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=200010,Mod=1e7+19;
struct ques{int opt,id,v,inv;}q[N];
int n,tot,o[N],Q,sum,pls,tms=1,inv=1,v[N];
int qpow(int a,int b){int ret=1;while(b){if(b&1)ret=1ll*ret*a%Mod;b>>=1;a=1ll*a*a%Mod;}return ret;}
void modify(int x,int y){
	sum=(sum+1ll*(Mod-v[x])*tms%Mod-pls+Mod)%Mod;
	v[x]=1ll*(y-pls+Mod)*inv%Mod;
	sum=(sum+y)%Mod;o[++tot]=x;
}
void add(int y){pls=(pls+y)%Mod;sum=(sum+1ll*n*y%Mod)%Mod;}
void cag(int y){
	while(tot)v[o[tot--]]=0;
	inv=tms=1;pls=y;sum=1ll*n*y%Mod;
}
void mul(int y,int ny){
	if(!y)cag(0);
	else{
		sum=1ll*sum*y%Mod;tms=1ll*tms*y%Mod;
		inv=1ll*inv*ny%Mod;pls=1ll*pls*y%Mod;
	}
}
int query(int x){
	return (1ll*v[x]*tms%Mod+pls)%Mod;
}
int main(){
#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif
	n=gi();Q=gi();
	for(int i=0;i<Q;i++){
		q[i].opt=gi();
		if(q[i].opt==1||q[i].opt==5)q[i].id=o[++tot]=gi();
		if(q[i].opt<5)q[i].v=(gi()%Mod+Mod)%Mod,q[i].inv=qpow(q[i].v,Mod-2);
	}
	sort(o+1,o+tot+1);tot=unique(o+1,o+tot+1)-o-1;
	for(int i=0;i<Q;i++)q[i].id=lower_bound(o+1,o+tot+1,q[i].id)-o;
	tot=0;int ans=0;
	for(int T=0,t=gi();T<t;T++){
		int a=gi()%Q,b=gi()%Q;
		for(int j=0,k=(a+b)%Q;j<Q;j++,k=(k+b)%Q){
			int opt=q[k].opt,x=q[k].id,y=q[k].v;
			if(opt==1)modify(x,y);
			if(opt==2)add(y);
			if(opt==3)mul(y,q[k].inv);
			if(opt==4)cag(y);
			if(opt==5)ans=(ans+query(x))%Mod;
			if(opt==6)ans=(ans+sum)%Mod;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：vorDeal (赞：2)

清新 DS 题。

操作只有单点和全局，考虑维护一堆全局 tag，再特判单点修改来实现线性时间复杂度。

需要维护的 tag：

- $sum$：总和；
- $def$：未修改位置的默认值；
- $add$、$mul$：存储值为 $x$，则真值为 $mul\times x+add$。

再用一个 unordered_map 维护单点修改，命名为 $var$。

实现 6 种操作：

- 单点赋值：  
  更新 $sum$ 和 $var$，注意判断该位置是否已被赋值，并要通过所赋真值计算出存储值。
- 全局加：  
  更新 $sum$ 和 $add$ 即可。
- 全局乘：  
  乘数为零则全局清空，否则更新 $sum$、$add$、$sum$。
- 全局赋值：  
  清空 tag 们与 $var$，更新 $def$、$sum$。
- 单点查询：  
  通过存储值还原真值。
- 全局求和：  
  答案即为 $sum$。

时间复杂度为 $O(n)$，可以通过本题。

AC Code 见 [Submission #532936 - QOJ.ac](https://qoj.ac/submission/532936)。

---

## 作者：Owen_codeisking (赞：2)

这是为数不多的我自己想出的山东省选题。~~虽然也是全场切~~

### $50pts:$

直接平衡树维护。

### $100pts:$

注意到操作数高达 $10^7$，出题人肯定要求对于每次操作 $O(1)$ 维护。

但是本质不同的操作数只有 $10^5$，所以这一部分是可以 $O(q\log q)$ 处理。而且操作都是全局操作/单点修改，所以首先排除线段树。

我们维护三个标记：

- $mul$ 全局乘标记

- $add$ 全局加标记

- $sum$ 全局和

为了更好除，我们可以再维护 $mul$ 的逆元 $inv$。

我们发现只有最多 $q$ 个位置需要单独处理，我们就可以把这些元素单独拿出来离散化一下。

对于操作 $5$ ，我们先在单独处理的操作 $1$ 上二分，若 $i$ 在操作 $1$ 上出现过，我们 $O(1)$ 把这个元素取出来，否则直接把普通位置的元素取出来即可。

但是有操作 $4$，我们不能直接全部遍历 $O(q)$ 的元素。

那么我们把所有的操作 $1$ 记下来，每次操作 $4$ 的时候删掉。这样每个操作 $1$ 只会被操作 $4$ 删掉一次，时间就不会退化。

时间复杂度 $O(q\log q+t\times q)$

有取模所以常数比较大。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100000+10;
const int mod=1e7+19;
int n,m,T,A[maxn],B[maxn],id[maxn],rid[maxn],cnt,mp[maxn],tot;ll a[maxn],mul,add,sum,inv,ans;

struct Query
{
    int op,x,y;
}q[maxn];

inline ll fpow(ll a,ll b)
{
    ll ret=1;
    for(;b;b>>=1,a=a*a%mod)
        if(b&1) ret=ret*a%mod;
    return ret;
}

inline void solve(int op,int x,int y)
{
	ll old,now;
	if(op==1)
	{
		old=(a[id[x]]*mul+add)%mod;sum=(sum-old+y)%mod;
		now=(y-add)*inv%mod;!id[x]?rid[id[x]=++cnt]=x:0;a[id[x]]=now;
	}
	if(op==2)
	{
		add=(add+x)%mod;sum=(sum+1ll*n*x)%mod;
	}
	if(op==3)
	{
		add=add*x%mod;mul=mul*x%mod;sum=sum*x%mod;inv=inv*y%mod;
	}
	if(op==4)
	{
		mul=inv=1;add=0;sum=1ll*n*x%mod;
		for(int i=1;i<=cnt;i++) id[rid[i]]=0,a[i]=rid[i]=0;
		a[0]=x;cnt=0;
	}
	if(op==5)
	{
		if(!x||!id[x]) ans=(ans+(a[0]*mul+add)%mod)%mod;
		else ans=(ans+(a[id[x]]*mul+add)%mod)%mod;
	}
	if(op==6) ans=(ans+sum)%mod;
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&q[i].op);
        if(q[i].op<6) scanf("%d",&q[i].x);
        if(q[i].op==1) scanf("%d",&q[i].y),q[i].y%=mod,mp[++tot]=q[i].x;
        if(q[i].op>=2&&q[i].op<=4) q[i].x%=mod;
    }
    scanf("%d",&T);
    for(int i=1;i<=T;i++) scanf("%d%d",&A[i],&B[i]);
    sort(mp+1,mp+tot+1);
    tot=unique(mp+1,mp+tot+1)-mp-1;
    int now;
    for(int i=1;i<=m;i++)
    {
        if(q[i].op==1) q[i].x=lower_bound(mp+1,mp+tot+1,q[i].x)-mp;
        if(q[i].op==3) q[i].y=fpow(q[i].x,mod-2);
        if(q[i].op==5) now=lower_bound(mp+1,mp+tot+1,q[i].x)-mp,q[i].x=(mp[now]==q[i].x)?now:0;
    }
    mul=inv=1;add=sum=0;
    for(int i=1;i<=T;i++)
        for(int j=1;j<=m;j++) now=(A[i]+1ll*j*B[i]%m)%m+1,solve(q[now].op,q[now].x,q[now].y);
    ans=(ans%mod+mod)%mod;
	printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：hhoppitree (赞：1)

#### 题意简述

给定一个长度为 $n$ 的操作数列 $a$，初始时 $a$ 中的所有元素均为 $0$，给定若干次操作，每次操作形如单点赋值，整体加，整体乘，整体赋值，单点询问或询问所有元素的和。

为了减少读入输出量，将只输入 $q$ 个标准操作以及 $t$ 组正整数 $(a_i,b_i)$，表示你需要进行 $qt$ 次操作，其中第 $\Big((i-1)q+j\Big)$ 次操作为第 $\Big((a_i+jb_i)\bmod q+1\Big)$ 个给定的标准操作，且最终你只需要输出最终答案对 $P=10^7+19$ 取模后的值即可。

对于 $50\%$ 的数据，满足 $n\le5\times10^5$，$t\le5$；  
对于全部数据，满足 $n\le10^9$，$q\le10^5$，$t\le100$ 且至少存在一次询问操作。

#### 题目解法

显然，采用任何对数复杂度的数据结构来解决这个问题都是不现实的，这提示我们需要采用**线性算法**来解决这个问题。

看到“整体加”，“整体乘”，“整体赋值”等字眼，让我们不禁想到**维护一个统一的变换**。

在本题中，我们可以将这个变换设置为 $ax+b$，则整体加，整体乘，整体赋值都可以轻松处理。

考虑单点赋值的处理，比较暴力的想法是对于每一个元素维护一个最近更新时间的时间戳，但更为精妙的方法是对于假设每一个位置的时间戳均为 $0$，根据修改后的值 $y$ **逆推出最开始的值 $x$**。

具体地，我们有 $ax+b=y$，所以只需让最开始的 $x$ 为 $\dfrac{y-b}{a}$ 即可，这可以用一个**哈希表**来维护。

为了让 $a$ 不为 $0$，我们需要让初始和区间赋值后的 $a$ 为任意非 $0$ 整数，但是，有一种特殊情况是当整体乘上 $0$ 的时候，此时 $a$ 和 $b$ 都会变成 $0$。我们发现这种情况与区间赋值为 $0$ 类似，只需让 $a=1$，$b=0$ 即可。

最后考虑查询操作，单点查询是简单的，整体询问相当于求 $\sum\limits_{i=1}^{n}(ax_i+b)=a\sum\limits_{i=1}^{n}x_i+bn$ 的值，可以在修改 $x$ 的过程中顺便维护 $\sum\limits_{i=1}^{n}x_i$ 的变化量，最终时间复杂度为 $\mathcal{O}(qt)$。

#### 总结

类似线段树的，整体的操作修改也可以使用懒标记解决，并且在过程中维护一些特殊位的信息时不一定需要维护这个过程中的切入时间戳，抑或是通过下传标记等方式来解决，而是可以通过逆推初始时的情况来解决问题，维护特殊位的信息可以采取哈希表等方式进行维护。

---

## 作者：Conical (赞：1)

### 题意
维护一个长度为 $n$ 的序列，要求支持单点赋值、整体赋值、整体加、整体乘、单点查询和整体求和。

$n\le10^9$，询问次数 $10^7.$


### 分析
将所有数都写成 $kx_i+b$ 的形式，维护 $k,b$ 以及 $\sum x_i$ 即可。乘和加就直接维护标记，考虑单点赋值，很容易想到令 $x_i=\frac{v-b}{k}$，但是这样有一个问题，即乘 $0$ 的情况。这种情况也很好处理，我们记录下当前 $x_i$ 不为 $0$ 的位置，每次暴力修改成 $0$ 即可。一次单点赋值最多只会进行一次删除。所以这样的复杂度是线性的。区间赋值就相当于乘 $0$ 后加 $v$，于是就做完了。

最后，$n$ 是 $10^9$ 级别数组开不下，提前离散化预处理就好了。

代码不难写，运行效率也还行。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MaxN(100003);

namespace io
{
	const int SIZE = 1 << 22 | 1;
	char iBuf[SIZE], *iS, *iT, c;
	#define gc() (iS == iT ? iT = iBuf + fread(iS = iBuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++)
	template<class I> void gi(I &x)
	{
		int f = 1;
		for(c = gc(); c < '0' || c > '9'; c = gc())
			if(c == '-') f = -1;
		for(x = 0; c >= '0' && c <= '9'; c = gc())
			x = (x << 3) + (x << 1) + (c & 15);
		x *= f;
	}
}

using io :: gi;

#define ull unsigned long long

const int Mod(1e7 + 19);

int K(1), invK(1), B(0), sum(0), ans(0);
int tmp[MaxN], x[MaxN], nn, n;
int v[MaxN], invv[MaxN];
int op[MaxN], a[MaxN];
vector<int> A;

inline void inc(int &x, int y)
{
	(x += y) >= Mod ? x -= Mod : x;
}

inline void dec(int &x, int y)
{
	(x -= y) < 0 ? x += Mod : x;
}

int fexp(int x, int k)
{
	int res = 1;
	for(; k; k >>= 1, x = (ull) x * x % Mod)
		if(k & 1) res = (ull) res * x % Mod;
	return res;
}

void work(int i)
{
	if(op[i] == 1)
	{
		dec(sum, x[a[i]]);
		x[a[i]] = (ull) (v[i] + Mod - B) * invK % Mod;
		A.push_back(a[i]), inc(sum, x[a[i]]);
	}
	else if(op[i] == 2) inc(B, v[i]);
	else if(op[i] == 3)
	{
		if(!v[i])
		{
			for(auto j : A) x[j] = 0;
			A.clear(), K = invK = 1, B = 0, sum = 0;
		}
		else
		{
			K = (ull) K * v[i] % Mod;
			B = (ull) B * v[i] % Mod;
			invK = (ull) invK * invv[i] % Mod;
		}
	}
	else if(op[i] == 4)
	{
		for(auto j : A) x[j] = 0;
		A.clear(), K = invK = 1, B = v[i], sum = 0;
	}
	else if(op[i] == 5)
		ans = (ans + (ull) x[a[i]] * K + B) % Mod;
	else
		ans = (ans + (ull) sum * K + (ull) B * n) % Mod;
}

int main()
{
	int q, t;
#ifdef conical
	freopen("que.in", "r", stdin);
	freopen("que.out", "w", stdout);
#endif
	gi(n), gi(q);
	for(int i = 1; i <= q; i++)
	{
		gi(op[i]);
		if(op[i] == 1 || op[i] == 5)
			gi(a[i]), tmp[++nn] = a[i];
		if(op[i] <= 4)
		{
			gi(v[i]);
			v[i] = (Mod + v[i] % Mod) % Mod;
			invv[i] = fexp(v[i], Mod - 2);
		}
	}
	sort(tmp + 1, tmp + 1 + nn);
	nn = unique(tmp + 1, tmp + 1 + nn) - tmp - 1;
	for(int i = 1; i <= q; i++)
		if(a[i]) a[i] = lower_bound(tmp + 1, tmp + 1 + nn, a[i]) - tmp;
	gi(t);
	for(int i = 1, a, b; i <= t; i++)
	{
		gi(a), gi(b);
		for(int j = 1; j <= q; j++)
			work((a + (ull) b * j) % q + 1);
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Hope2075 (赞：0)

~~SDOI R2完美爆炸后写题解增加rp~~

~~这题好像就是SDSC2018时dzm某道题的加强版~~

~~当时我在不会线段树的情况下直接A了~~

据说数据随机，用数据结构乱搞就能过

不过为了保险，我还是写的$O(qt)$的做法

首先发现，只有单点操作和全局操作

所以考虑把涉及的所有单点操作所在位置离散化

这里我的做法是：对于单点修改，将这个位置离散化

对于单点查询，如果有对应的修改操作，就把操作映射到那个位置，否则，映射到$0$位置

对于全局操作，直接全局打标记即可

然而，问题来了：怎么处理标记？

首先不考虑全局赋值操作

对于一个点，可以先把之前的所有操作撤销，然后再对这个点执行所有执行过的操作

写了个检验器，发现模数是质数，~~太好了~~

这样，对于加法，作减法就可以撤销

对于乘法，如果全局乘的数是$p$的倍数，就把这次操作换为一次修改操作，否则，可以乘以逆元来撤销

对每个位置维护已经执行过的操作即可

等等，逆元带一个$\log m$

解决办法很简单，只需要先把所有乘法操作的逆元求出来，执行操作时维护逆元即可

如果有全局赋值操作？

发现执行全局赋值操作后，所有之前的标记都会失效

对于每个点记录上一次全局赋值操作生效的时间

如果发现这个点需要执行全局赋值操作，就直接把数值修改

否则，把加法和乘法操作按之前的做法执行就可以

而全局求和就很简单了，每次操作后维护一下就可以了

不过这样比较容易写错

注意执行顺序，以及某个操作对其它标记的影响

撤销时，应当先撤销加法，再撤销乘法，而执行时顺序恰好反过来

执行全局修改操作时，把加法标记赋值为0，乘法和逆元标记赋值为1

执行全局加操作时，需要对全局修改操作标记作加法

执行全局乘法操作时，需要将另外两个标记分别作乘法

然后在考场上建议写暴力对拍（虽然暴力是0分）

最后是代码
```cpp
#include<cstdio>
#include<map>
const int Q=100007;
const long long M=1e7+19;
long long read(){
	long long n=0;char c=getchar();bool f=0;
	while(c!='-'&&(c<'0'||c>'9'))c=getchar();
	if(c=='-'){f=1;c=getchar();}
	while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
	if(f)return -n;
	else return n;
}
char res[25];
void write(long long num){
	if(num==0){putchar('0');return;}
	if(num<0){putchar('-');num=-num;}
	int t=0;
	while(num){
		res[t++]=num%10+'0';
		num/=10;
	}
	while(t--)putchar(res[t]);
	return;
}
long long inv(long long n){
	int p=M-2;
	long long ans=1;
	while(p){
		if(p&1){
			ans=ans*n%M;
		}
		p>>=1;
		n=n*n%M;
	}
	return ans;
}
int n,q,t;
int a,b;
int opt[Q];
int place[Q];
long long optn[Q];
long long invn[Q];
long long ans=0;
std::map<int,int> ids;
int id=1;

namespace seg{
	int glen;
	long long list[Q];
	long long add[Q],inv[Q],dfn[Q];
	long long addt,mult,sett,invt,cur;
	long long gsum;
	void reset(){
		glen=n%M;
		cur=0;
		addt=0;
		mult=1;
		sett=0;
		invt=1;
		gsum=0;
		for(int i=0;i<=id;i++){
			add[i]=0;
			inv[i]=1;
			dfn[i]=0;
		}
	}
	void pushdown(int p){
		if(dfn[p]<cur){
			dfn[p]=cur;
			list[p]=sett;
			add[p]=addt;
			inv[p]=invt;
		}else{
			list[p]-=add[p];
			if(list[p]<0)list[p]+=M;
			list[p]=list[p]*inv[p]%M;
			
			list[p]=list[p]*mult%M;
			list[p]+=addt;
			if(list[p]>=M)list[p]-=M;
			
			add[p]=addt;
			inv[p]=invt;
		}
	}
	void pset(int p,long long n){
		pushdown(p);
		gsum-=list[p];
		if(gsum<0)gsum+=M;
		gsum+=n;
		if(gsum>=M)gsum-=M;
		
		
		list[p]=n;
	}
	long long pquery(int p){
		pushdown(p);
		return list[p];
	}
	void gset(long long n){
		gsum=n*glen%M;
		cur++;
		addt=0;
		mult=1;
		sett=n;
		invt=1;
	}
	void gadd(long long n){
		sett+=n;
		if(sett>=M)sett-=M;
		addt+=n;
		if(addt>=M)addt-=M;
		gsum=(gsum+n*glen)%M;
	}
	void gmul(long long n,long long inv){
		sett=sett*n%M;
		addt=addt*n%M;
		mult=mult*n%M;
		invt=invt*inv%M;
		gsum=gsum*n%M;
	}
	long long qsum(){
		return gsum;
	}
}
long long last;
int main(){
	freopen("query.in","r",stdin);
	freopen("query.out","w",stdout);
	n=read();q=read();
	for(int i=1;i<=q;i++){
		opt[i]=read();
		if(opt[i]==1||opt[i]==5){
			place[i]=read();
		}
		if(opt[i]<=4){
			optn[i]=read();
			optn[i]%=M;
			if(optn[i]<0)optn[i]+=M;
		}
		if(opt[i]==3){
			if(optn[i]==0){
				opt[i]=4;
			}else{
				invn[i]=inv(optn[i]);
			}
		}
	}
	for(int i=1;i<=q;i++){
		if(opt[i]==1){
			int previd=ids[place[i]];
			if(previd){place[i]=previd;continue;}
			ids[place[i]]=id;
			place[i]=id;
			id++;
		}
	}
	
	for(int i=1;i<=q;i++){
		if(opt[i]==5){
			int id=ids[place[i]];
			if(!id){
				place[i]=0;
				continue;
			}
			place[i]=id;
		}
	}
	seg::reset();
	t=read();
	while(t--){
		a=read();b=read();
		a%=q;b%=q;
		for(int i=1;i<=q;i++){
			a+=b;
			if(a>=q)a-=q;
			a++;
			switch(opt[a]){
				case 1:
					seg::pset(place[a],optn[a]);
					break;
				case 2:
					seg::gadd(optn[a]);
					break;
				case 3:
					seg::gmul(optn[a],invn[a]);
					break;
				case 4:
					seg::gset(optn[a]);
					break;
				case 5:
					last=seg::pquery(place[a]);
					ans+=last;
					if(ans>=M)ans-=M;
					break;
				case 6:
					last=seg::qsum();
					ans+=last;
					if(ans>=M)ans-=M;
					break;
			}
			a--;
		}
	}
	write(ans);
}
	
```
~~原封不动的考场代码，一个字节也没改~~

---


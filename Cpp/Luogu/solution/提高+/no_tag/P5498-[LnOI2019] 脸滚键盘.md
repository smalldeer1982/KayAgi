# [LnOI2019] 脸滚键盘

## 题目背景

题目提供者：Okami

朝田诗乃：一个优秀的长脖子鹿是会数数字的位数的。



## 题目描述

长颈鹿Abbi喜欢用脸滚键盘，它每次滚键盘就会把一段子区间的值乘起来。

定义子区间为一个区间中的一个连续区间。

定义一段子区间的权值为每个元素权值之积。

定义一段区间的期望权值为任意选出一段子区间的权值的期望值。

给定 $n$ 个数字，分别表示权值 $a_i$ 。

共$q$次询问，对于一次询问 $l \ r$ 查询指定区间的期望权值。

## 说明/提示

时空限制：1s/512MB

对于30%的数据，$1 \leq n, q \leq 100$

对于100%的数据，$1 \leq n, q \leq 10^6$，$1 \leq a_i \leq 10^7$

样例解释：对于区间$[1,1]$，共有一个子区间$[1,1]$，权值为$6$，每个区间取到的概率是$\frac{1}{1}$，期望权值为6.

对于区间$[4,5]$，共有三个子区间$[4,4]$、$[4,5]$、$[5,5]$，权值分别为$3$、$81$、$27$，每个区间取到的概率是$\frac{1}{3}$，总期望权值为37.

对于区间$[1,3]$，共有个六子区间$[1,1]$、$[1,2]$、$[1,3]$、$[2,2]$、$[2,3]$、$[3,3]$，权值分别为$6$、$72$、$432$、$12$、$72$、$6$，每个区间取到的概率是$\frac{1}{6}$，总期望权值为100.

建议使用读入优化。

## 样例 #1

### 输入

```
5 3
6 12 6 3 27
1 1
4 5
1 3```

### 输出

```
6
37
100```

# 题解

## 作者：皎月半洒花 (赞：9)

我的做法很迷，但复杂度应该是对的，$O(n)$。

首先我们考虑他算的是啥，了解期望是啥的话应该知道重点在求分子，比如当区间长度为$3$时分子应该是这些： 

$$a_1+a_2+a_3+a_1a_2+a_2a_3+a_1a_2a_3$$

这东西显然没法直接前缀维护，于是考虑构造一个数列如此递推：

$$F_i=F_{i-1}\cdot a_i+a_i$$

这玩意儿有啥用呢？我们观察$F_3$的展开：

$$\begin{aligned}&\quad~ a_3\\ &+a_3\cdot a_2\\&+a_3\cdot a_2\cdot a_1 \end{aligned}$$

我们可以把它看做一个三角形，其中 
$$\begin{aligned}&\quad ~a_2\\&+a_2\cdot a_1 \end{aligned}$$

则是$F_2$

那么其实我们如果换一个简单版本，每次询问都是询问$[1,r]$，那么我们完全可以直接做一个前缀和求出来，因为答案就是$\sum_{i\leq r} F_i$（可以考虑自行验证）。那么现在我们考虑吧如果是算$[l,r]$，我们直接用$S_r-S_{l-1}$是否有错：

首先，减出来之后的$\sum_{i\in[l,r]} F_i$都是从$1$开始推过来的，而不是从$l$。所以我们考虑如下：

$$\begin{aligned}&\quad~ a_3\\ &+a_3\cdot a_2\\&+a_3\cdot a_2\cdot a_1 \\&+a_3 \cdot a_2\cdot a_1\cdot a_0\end{aligned}$$

这是递推好的$F$，现在我们要求$[1,3]$，用前缀和的话，我们发现$a_0$出现在$F_1$中、$F_2$中、$F_3$中，且贡献分别是$a_1\cdot a_0$、$a_2\cdot a_1\cdot a_0$和$a_3\cdot a_2\cdot a_1\cdot a_0$.所以我们需要维护一个**前缀积的前缀和**乘上$F_{l-1}$计算负贡献。

```cdot
#define rr register
#define LL long long
#define MAXN 2000100
#define Mod 100000007

using namespace std ; int l, r ;
int Sum[MAXN], S[MAXN], T[MAXN], F[MAXN], base[MAXN] ; int N, M ;

int expow(int a){
    a %= Mod ;
    int res = 1, b = Mod - 2 ;
    while (b){
        if (b & 1)
            res = 1ll * res * a % Mod ;
        a = 1ll * a * a % Mod, b >>= 1 ;
    }
    return res ;
}
inline int qr(){
    int res = 0 ; char c = getchar() ;
    while (!isdigit(c)) c = getchar() ;
    while (isdigit(c)) res = (res << 1) + (res << 3) + c - 48, c = getchar() ;
    return res ;
}
int main(){
    int i ; cin >> N >> M, Sum[0] = 1 ;
    for (i = 1 ; i <= N ; ++ i)
        base[i] = qr(),
        Sum[i] = 1ll * Sum[i - 1] * base[i] % Mod,
        F[i] = (1ll * F[i - 1] * base[i] % Mod + base[i]) % Mod,
        S[i] = 1ll * (S[i - 1] + F[i]) % Mod, T[i] = (1ll * T[i - 1] + Sum[i]) % Mod ; T[0] = 1 ;
//    for (i = 1 ; i <= N ; ++ i) cout << Sum[i] << " " ;
    while (M --){
        l = qr(), r = qr() ;
        rr int len = (r - l + 1) ; //cout << T[r] - T[l - 1] << endl ;
        rr int P = (S[r] - S[l - 1] + Mod) % Mod ;
        rr int O = 1ll * (T[r] - T[l - 1] + Mod) * expow(Sum[l - 1]) % Mod ;
        rr int x = (P - 1ll * F[l - 1] * O % Mod + Mod) % Mod ;
        printf("%lld\n", 1ll * x * expow(len * (len + 1) / 2) % Mod) ;
    }
}

```


后记：并不知道其他大佬怎么做的，但在我看来那个递推式的构造出发点就是**加入一个数，会产生多少新贡献**这个角度来考虑的orz

---

## 作者：诗乃 (赞：9)

我们发现，每一次的答案乘上区间数量的值形如： 

$$a_{i}+a_{i}a_{i+1}+a_{i}a_{i+1}a_{i+2}+...+a_{i+1}+a_{i+1}a_{i+2}+...$$

根据题意，我们设$Ans_{k}$为真正的答案乘上区间数量的值，则有：

$$Ans_{k} = \sum_{i=l}^{r}\frac{sum[r]-sum[i-1]}{mul[i-1]}$$

其中:

$$mul[n]=\prod_{i=1}^{n}a_{i}$$
$$sum[n]=\sum_{i=1}^{n}mul[i]$$

拆开化简有：

$$Ans_{k} = sum[r]\cdot\sum_{i=l}^{r}\frac{1}{mul[i-1]} - \sum_{i=l}^{r}\frac{sum[i-1]}{mul[i-1]}$$	 

对于后面我们前缀和处理，前面前缀和处理$\frac{1}{mul[i]}$
的前缀和即可。区间的数量易证得$Cnt=\frac{len*(len+1)}{2}$，最后除一下就可以了。

注意模数是$1e8+7$。

>朝田诗乃：“一个优秀的长脖子鹿是会数数字的位数的。”

代码：

```cpp
#include <bits/stdc++.h>
const int MAXN = 1000050, P = 1e8 + 7;
void read(int &x) {
	char ch; while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}
int power(int a, int b) {
	int res = 1;
	for(; b; b >>= 1, a = 1ll*a*a%P) if(b & 1) res = 1ll*res*a%P;
	return res;
}
int mul[MAXN], sufmul[MAXN], n, a[MAXN], sdivm[MAXN], invm[MAXN], q, inv[MAXN];
int main() {
	read(n); read(q); mul[0] = invm[0] = sdivm[0] = sufmul[0] = 1;
	for(int i = 1; i <= n; ++i) read(a[i]);
	for(int i = 1; i <= n; ++i) mul[i] = 1ll*mul[i-1]*a[i]%P;
	for(int i = 1; i <= n; ++i) inv[i] = power(1ll*i*(i+1)%P, P-2), invm[i] = (invm[i-1]+power(mul[i], P-2))%P;
	for(int i = 1; i <= n; ++i) sufmul[i] = (sufmul[i-1]+mul[i])%P;
	for(int i = 1; i <= n; ++i) sdivm[i] = (sdivm[i-1]+1ll*sufmul[i]*(invm[i]-invm[i-1])%P)%P;
	for(int l, r; q--; ) {
		read(l); read(r);
		printf("%d\n", (1ll*sufmul[r]*(invm[r-1]-(l-2<0?0:invm[l-2])+P)%P-(sdivm[r-1]-(l-2<0?0:sdivm[l-2])+P)%P+P)%P*2*inv[r-l+1]%P);
	}
}


```

---

## 作者：览遍千秋 (赞：5)

第一次在洛谷的比赛爬到第一页qwq

---

## $\mathrm{I}$ 考虑暴力

显然，区间$[l,r]$的子区间共有$\frac{(r-l+1) \times (r-l+2)}{2}$个。

设数列为$a$。

考虑对于每一个询问，枚举$x \in [l,r],y \in [x,r]$，则子区间$[x,y]$对本询问答案$ans$有$\prod_{k=x}^{y}{a_k}$的贡献。

故询问的答案为$\frac{\sum_{x=l}^{r}{\sum_{y=x}^{r}{\prod_{k=x}^{y}{a_k}}}}{\frac{(r-l+1) \times (r-l+2)}{2}}$。

由于答案要对$100000007$（$10^8+7$）取模，所以答案转化为${\sum_{x=l}^{r}{\sum_{y=x}^{r}{\prod_{k=x}^{y}{a_k}}}}\times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$

其中，$inv(a)$代表$a$在模$10^8+7$意义下的逆元。


发现式子$\prod_{k=x}^{y}{a_k}$可以使用前缀积优化，故求一数列$s$，其中$s_i$为$\prod_{k=1}^{i}{a_k}$。

显然有$s_i=s_{i-1} \times a_i$

同时维护逆元数组$inv$

所以答案可以变为${\sum_{x=l}^{r}{\sum_{y=x}^{r}{s_y}}\times inv_{x-1}}\times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$

故可得暴力代码（$\mathrm{30pts}$）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 100000007
#define maxn 1000003
int n,m,l,r;
long long x,fm,ans;
long long s[maxn],inv[maxn];

template<typename Tp>
void read(Tp &x){
	x=0;int fh;char ch=1;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-'){
		ch=getchar();fh=-1;
	}
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}

long long ksm(long long x,int p){
	long long re=1;
	while(p){
		if(p&1) re=re*x%mod;p>>=1;
		x=x*x%mod;
	}
	return re;
}

int main(){
	read(n);read(m);inv[0]=1;s[0]=1;
	for(register int i=1;i<=n;i++){
		read(x);
		s[i]=s[i-1]*x%mod;
		inv[i]=ksm(s[i],mod-2);
	}
	while(m--){
		ans=0;
		read(l);read(r);fm=(long long)(r-l+1)*(r-l+2)/2;
		for(int lft=l;lft<=r;lft++){
			for(int rgt=lft;rgt<=r;rgt++){
				ans=(ans+s[rgt]%mod*inv[lft-1])%mod;
			}
		}
		ans=ans*ksm(fm,mod-2)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## $\mathrm{II}$ 拆式子

公式预警。

由$\mathrm{I}$推得：

$$ans={\sum_{x=l}^{r}{\sum_{y=x}^{r}{s_y}}\times inv_{x-1}}\times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$$

发现暴力跑的慢的原因主要在于前面两个$\sum$枚举的复杂度为$O(n^2)$

考虑再次使用前缀和，维护后面的$\sum$。

由于当$x$确定时，$inv_{x-1}$即确定，可变形为

$$ans={\sum_{x=l}^{r}{inv_{x-1} \times \sum_{y=x}^{r}{s_y}}} \times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$$

故可再次使用前缀和维护$s$数组。

令$ss_i$表示$\sum_{k=1}^{i}{s_k}$，显然有$ss_i=ss_{i-1}+s_i$。

由此，答案变形为

$$ans={\sum_{x=l}^{r}{inv_{x-1} \times (ss_r-ss_{x-1})}} \times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$$

观察发现，当一个询问确定时，$ss_r$是定值，可提取$ss_r$，答案变形为

$$ans=ss_r \times \sum_{x=l}^{r}{inv_{x-1}}-\sum_{x=l}^{r}{inv_{x-1} \times ss_{x-1}} \times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$$

发现$\sum$已经被拆开，可以对两个$\sum$分别维护前缀和。

设$invs$为$inv$的前缀和数组，$sinvs$为$ss \times inv$的前缀和数组，显然看到这篇题解的人都会前缀和，便不再赘述。

于是得到最终答案公式：

$$ans=ss_r \times (inv_{r-1}-inv_{l-2})-sinvs_{r-1}+sinvs_{l-2} \times inv({\frac{(r-l+1) \times (r-l+2)}{2}})$$

但是此时出现了$l-2$，当询问区间为$[1,r]$时会出现问题，如何处理留给读者自行思考或阅读代码自行理解，此处不再赘述。

---

## $\mathrm{III}$ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 100000007
#define maxn 1000003
int n,m,l,r;
long long x,fm,ans;
long long s[maxn],inv[maxn];
long long ss[maxn],invs[maxn],sinvs[maxn];
template<typename Tp>
void read(Tp &x){
	x=0;int fh;char ch=1;
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-'){
		ch=getchar();fh=-1;
	}
	else fh=1;
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=fh;
}

long long ksm(long long x,int p){
	long long re=1;
	while(p){
		if(p&1) re=re*x%mod;p>>=1;
		x=x*x%mod;
	}
	return re;
}

int mian(){
	read(n);read(m);inv[0]=1;s[0]=1;
	for(register int i=1;i<=n;i++){
		read(x);
		s[i]=s[i-1]*x%mod;
		inv[i]=ksm(s[i],mod-2);
	}
	for(register int i=1;i<=n;i++){
		ss[i]=(ss[i-1]+s[i])%mod;
		invs[i]=(invs[i-1]+inv[i-1])%mod;
	}
	for(register int i=1;i<=n;i++){
		sinvs[i]=(sinvs[i-1]+ss[i-1]*inv[i-1]%mod)%mod;
	}
	while(m--){
		ans=0;
		read(l);read(r);fm=(long long)(r-l+1)*(r-l+2)/2;
		ans=ss[r]*(invs[r]-invs[l-1])%mod;
		ans=((ans-sinvs[r]+sinvs[l-1])%mod+mod)%mod;
		ans=ans*ksm(fm,mod-2)%mod;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Soulist (赞：4)

一个很迷的做法

首先答案应该是区间的子区间的权值总和与区间总数的比值

发现区间总数很好求，于是问题的关键就在于如何求出区间的子区间权值总和了

我们考虑记$f_i$表示右端点的为$i$的子区间的权值和

那么有一个显然的递推$f_i=f_{i-1}*a_i+a_i$

考虑再记一下$f_i$的前缀和$s_i$

现在来考虑一组询问$l,r$

我们做一下减法：$s_r-s_{l-1}$

会发现有些区间没有减到

这些区间是左端点在$[1,l-1]$而右端点在$[l,r]$的区间。

很明显这些区间都跨过了$l-1$这个点，我们仔细考虑一下，发现还要额外减去的部分就是：

$f_{l-1}*$（以$l$为左端点且右端点$\le r$的区间权值和）

于是问题的关键就在于如何求出后面那一部分。

我们接下来考虑记$g_i$表示左端点为$i$的区间权值总和

那么可以得到一个比较显然的递推$g_i=g_{i+1}*a_i+a_i$

我们考虑后面那一部分的暴力求法，类似于$g_i$的递推，不过是从$r$开始罢了，写成代码应该是这样的：

```cpp
int s = 0 ;
for( int i = r; i >= l; -- i ) s = s * a[i] + a[i] ;
```

我们考虑优化它，仔细考虑它和$g_i$的关系

然后你会惊人的发现从$r$开始递推下来得到的$g_l$居然递推的式子和其完全相同，不过初始值为$g_{r+1}$而已。

我们仔细考虑这个递推，可以发现它是关于$s$的一次函数

于是我们想要的就是其在$s=0$时的取值。

实际上我们已经求出了其在$g_{r+1}$的取值即$g_l$

所以我们把我们已经知道的方程写下来：

$$k*g_{r+1}+b=g_l$$

你惊人的发现这个$k$是可以直接求出来的，暴力在纸上把式子拆开会得出：$k=\prod_{i=l}^ra_i$的结论。

当$s=0$的时候我们要求的就是$b$，你发现$k$可以$O(1)$的求，于是$b=g_l-k*g_{r+1}$也可以$O(1)$求出

这样我们就把后面那一部分给解出来了，带回去算就可以得出答案。

然后因为我比较懒，就没有写$O(n)$推逆元，写了个快速幂暴力算

复杂度$O(n\log n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define drep( i, s, t ) for( register int i = t; i >= s; -- i )
#define re register
#define mod 100000007 
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e6 + 5 ; 
int a[N], f[N], sum[N], g[N], pd[N], inv[N], n, q ; 
int pow2( int x, int k ) {
	int ans = 1, base = x ;
	while( k ) {
		if( k & 1 ) ans *= base, ans %= mod ;
		base *= base, base %= mod, k >>= 1 ;
	}
	return ans ; 
}
int F( int l, int r ) {
	int k = pd[r] * pow2( pd[l - 1], mod - 2 ) % mod ;
	int st = ( g[l] - ( g[r + 1] * k % mod ) + mod ) % mod ;
	return st ; 
}
signed main()
{
	n = read(), q = read() ; pd[0] = 1 ; 
	rep( i, 1, n ) a[i] = read(), f[i] = ( f[i - 1] * a[i] + a[i] ) % mod , 
	sum[i] = ( sum[i - 1] + f[i] ) % mod, pd[i] = pd[i - 1] * a[i] % mod ; 
	drep( i, 1, n ) g[i] = ( g[i + 1] * a[i] + a[i] ) % mod ; 
	int k, l, r, ans ;
	rep( i, 1, q ) {
		l = read(), r = read(), k = r - l + 1 ; 
		ans = ( sum[r] - sum[l - 1] + mod ) % mod ; 
		k = k * ( k + 1 ) / 2, k = pow2( k, mod - 2 ) ; 
		ans = ( ans - ( f[l - 1] * F( l, r ) % mod ) + mod ) % mod ;
		ans = ans * k % mod ; 
		printf("%lld\n", ans ) ;
	}
	return 0;
}
```

---

## 作者：chenxinyang2006 (赞：2)

题意：给你一个长度为 $n$ 的序列 $a$，$m$ 次给出一个区间 $[l,r]$，求 $\sum\limits_{i = l} ^ r \sum\limits_{j = i} ^ r \prod\limits_{k = i} ^ j a_k$，答案模 $10 ^ 8 + 7$。

首先 $10 ^ 8 + 7$ 是个质数，所以可以计算出前缀积 $b_i = \prod\limits_{j = 1} ^ i a_j$，以及逆元前缀积 $c_i = b_i ^ {-1}$

然后式子变为 $\sum\limits_{i = l} ^ r \sum\limits_{j = i} ^ r b_j \times c_{i - 1}$

这样不太好看，平移一下，$d_i = c_{i - 1}$

$ans = \sum\limits_{i = l} ^ r \sum\limits_{j = i} ^ r d_i \times b_j$

对 $b$ 再做一次前缀和，设 $e_i = \sum\limits_{j = 1} ^ i b_j$

$ans =\sum\limits_{i = l} ^ r d_i \times (e_r - e_{i - 1})$

拆一下，设 $f_i = \sum\limits_{j = 1} ^ i d_i$

$ans=(f_r - f_{l - 1}) \times e_r - \sum\limits_{i = l} ^ r d_i \times e_{i - 1}$

可以发现 $d_i \times e_{i - 1}$ 是一个定值，考虑设 $g_i = \sum\limits_{j = 1} ^ i d_j \times e_{j - 1}$

$ans=(f_r - f_{l - 1}) \times e_r - (g_r - g_{l - 1})$

然后就可以直接算了

时间复杂度：$O((n + q) \log mod)$

```cpp
#include <cstdio>
#define ll long long
#define mod 100000007
int n,q;
ll a[1000005],b[1000005],c[1000005],d[1000005],e[1000005],f[1000005],g[1000005];

ll power(ll n,int k){
	ll ans = 1;
	while(k){
		if(k % 2 == 1){
			ans = ans * n % mod;
		}
		n = n * n % mod;
		k /= 2;
	}
	return ans;
}

int main(){
	scanf("%d%d",&n,&q);
	b[0] = c[0] = d[1] = 1;
	for(int i = 1;i <= n;i++){
		scanf("%lld",&a[i]);
		b[i] = b[i - 1] * a[i] % mod;
		c[i] = power(b[i],mod - 2);
        d[i + 1] = c[i];
	}
	for(int i = 1;i <= n;i++){
		e[i] = (e[i - 1] + b[i]) % mod;
		f[i] = (f[i - 1] + d[i]) % mod;
		g[i] = (g[i - 1] + d[i] * e[i - 1]) % mod;
	}
	/*printf("array b :\n");
	for(int i = 1;i <= n;i++) printf("%lld ",b[i]);
	printf("\narray c :\n");
	for(int i = 1;i <= n;i++) printf("%lld ",c[i]);
	printf("\narray d :\n");
	for(int i = 1;i <= n;i++) printf("%lld ",d[i]);
	printf("\narray e :\n");
	for(int i = 1;i <= n;i++) printf("%lld ",e[i]);
	printf("\narray f :\n");
	for(int i = 1;i <= n;i++) printf("%lld ",f[i]);	
	*/
		 
	int l,r;
	for(int i = 1;i <= q;i++){
		scanf("%d%d",&l,&r);
		ll res = ((f[r] - f[l - 1]) * e[r] - (g[r] - g[l - 1])) % mod;
		res = (res + mod) % mod;
		printf("%lld\n",res * power(((r - l + 1) * (r - l + 2) / 2),mod - 2) % mod);
	}
	return 0;
}
```

如果用离线 $O(n)$ 求逆元，可以做到 $O(n + q)$

---

## 作者：Lates (赞：2)

$O(q\log n)$ 的算法。

题目对于一组 $l,r$ 要求 :

$$\dfrac{\sum\limits_{i=l}^{r}\sum\limits_{j=i}^{r}\prod\limits_{k=i}^{j}a_{k}}{\dfrac{(r-l+1)(r-l+2)}{2}}$$

考虑如何求分子。

令 $m(x)=\prod\limits_{i=1}^{x}a_{i},f(x)=\sum\limits_{i=1}^{x}m(i)$

$$\begin{aligned}&\sum\limits_{i=l}^{r}\sum\limits_{j=i}^{r}\prod\limits_{k=i}^{j}a_{k}\\=&\sum_{i=l}^{r}\sum_{j=i}^{r}\dfrac{m(j)}{m(i-1)}\\=&\sum_{i=l}^{r}\dfrac{1}{m(i-1)}\sum_{j=i}^{r}m(j)\\=&\sum_{i=l}^{r}\dfrac{1}{m(i-1)}(f(r)-f(i-1))\\=&f(r)\sum_{i=l}^{r}\dfrac{1}{m(i-1)}-\sum_{i=l}^{r}\dfrac{f(i-1)}{m(i-1)}\end{aligned}$$
然后再维护这两个的前缀和即可。

有 $q$ 组询问每组 $O(1)$,有快速幂处理逆元所以是 $O(q\log n)$。

$code:$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=1e6+5,P=1e8+7;
int pre[MAX],mul[MAX],a[MAX],inv[MAX],res,n,m,pre1[MAX],pre2[MAX];
inline int qpow(int x,int p){
	for(res=1;p;p>>=1,x=1LL*x*x%P)if(p&1)res=1LL*res*x%P;
	return res;
}
int l,r,ans,inv2;
signed main(){
	n=read(),m=read();
	mul[0]=inv[0]=1;
	for(register int i=1;i<=n;++i){
		a[i]=read();
		mul[i]=1LL*mul[i-1]*a[i]%P;
		inv[i]=qpow(mul[i],P-2);
		pre[i]=(pre[i-1]+mul[i])%P;	
	}
	for(register int i=1;i<=n;++i){
		pre1[i]=(pre1[i-1]+1LL*inv[i-1])%P;
		pre2[i]=(pre2[i-1]+1LL*pre[i-1]*inv[i-1]%P)%P;
	}
	pre[0]=1;
	while(m--){
		l=read(),r=read();
		ans=(1LL*pre[r]*(pre1[r]-pre1[l-1])%P-pre2[r]+pre2[l-1])%P;
		ans=(ans<<1)%P;
		ans=1LL*ans*qpow(1LL*(r-l+1)*(r-l+2)%P,P-2)%P;
		printf("%lld\n",(ans+P)%P);
	}
	return 0;
}


```

---

## 作者：lemondinosaur (赞：1)

[传送门](https://www.luogu.org/problem/P5498)

---
# 前言
比赛时想的心力憔悴，天马行空~~完全跑题~~地想到了什么系数为$\large C_{len+1}^n-C_{len}^{n-1}$，~~都是OEIS的错~~，结果貌似时间复杂度比暴力还要慢,我觉得我只能脸滚键盘了

当然剧透一下，想通了当然是道蓝题，没想通就可能是道紫题了233，技术难度相对于思维难度来说比较低，真的很难想啊

---
# 题目
多组数据对于区间$[l\sim r]$询问
$$\large\frac{\sum_{i=l}^r\sum_{j=i}^r\prod_{k=i}^ja[k]}{C_{r-l+2}^2}\pmod {10^8+7}$$
为什么是这个组合数，简单证明一下，在$[l\sim r]$共$r-l+1$个数中挑取两个可能相同的数，组成有序数对？？？

好吧，其实可以吧右端点向右移一位，那就可以转换成$[l\sim r+1]$共$r-l+2$个数中挑取两个互不相同的数组成有序数对，那么就是$C_{r-l+2}^2$

证毕

---
# 30%分析
首先按照题意暴力$O(Tn^3)$就能拿到30分

先把$a$变成前缀积吧，然后分母预处理逆元先不考虑，主要是因为每条公式都打上又丑又长,乘上$C_{r-l+2}^2$得到
$$\large\sum_{i=l}^r\sum_{j=i}^r\frac{a[j]}{a[i-1]}$$
时间复杂度$O(n+Tn^2)$，这样至少能优化暴力吧

---
# 接近正解的分析
剩下的是差分了吧，首先把$\frac{1}{a[i-1]}$移到前面去，再把后面的$j$差分一下，维护$a$的前缀和$sum$（也就是原数组的前缀积的前缀和），那么就可以得到
$$\large\sum_{i=l}^r\frac{sum[r]-sum[i-1]}{a[i-1]}$$
时间复杂度$O(n+Tn)$

---
# 正解
考虑再次差分，那么答案就能变为
$$\large sum[r]\sum_{i=l-1}^{r-1}\frac{1}{a[i]}-\sum_{i=l-1}^{r-1}\frac{sum[i]}{a[i]}$$
那对于前面的部分前缀积逆元也要求一个前缀和，

对于后面维护原数组前缀积的前缀和 and 同一位置前缀积逆元的积 的前缀和

真是绕口，这样就可以做到$O(n+T)$的时间复杂度了，为此，本题已解决，但是其实很多的求法都没有讲清楚吧，可以通过代码弄懂了呀

---
# 代码
~~（难道觉得作者没有用读入优化吗）~~
```cpp
#define rr register
inline signed ksm(int x,int y){
	rr int ans=1;
	for (;y;y>>=1,x=1ll*x*x%mod)
	    if (y&1) ans=1ll*ans*x%mod;
	return ans;
}
inline signed mo(int x,int y){return x+y>=mod?x+y-mod:x+y;}
signed main(){
    scanf("%d%d",&n,&m); rr int bac=1; //bac表示原数组的前缀积的后缀积
    
    inv[0]=inv[1]=a[0]=fro[0]=s[0]=1;
    
    for (rr int i=2;i<=n+1;++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
    //求逆元，详见【模板】乘法逆元1的模板
    
    for (rr int i=1;i<=n;++i) a[i]=1ll*a[i-1]*iut()%mod;//原数组前缀积
    
    for (rr int i=1;i<=n;++i) sum[i]=mo(sum[i-1],a[i]),fro[i]=1ll*fro[i-1]*a[i]%mod;
    //sum表示a的前缀和，fro表示a的前缀积
    
    int all=fro[n]<n+2?inv[fro[n]]:ksm(fro[n],mod-2);//原数组的积的逆元
    
    for (rr int i=n;i;--i) b[i]=1ll*fro[i-1]*bac%mod*all%mod,bac=1ll*bac*a[i]%mod;
    //求前缀积的逆元，详见【模板】乘法逆元2，利用容斥，总逆元乘左右两边的逆元就等于该位置的逆元
    
    for (rr int i=1;i<=n;++i) s[i]=mo(s[i-1],b[i]),p[i]=mo(p[i-1],1ll*b[i]*sum[i]%mod);
    //求b的前缀和，以及分析所说的一长串
    //为什么s[0]是1呢，因为0的逆元是1呀
    
    while (m--){
    	rr int l,r; scanf("%d%d",&l,&r); rr int len=r-l+1;
        
    	rr int ans=1ll*sum[r]*mo(s[r-1]-(l<2?0:s[l-2]),mod)%mod;
        
    	ans=mo(ans-mo(p[r-1]-(l<2?0:p[l-2]),mod),mod);
    	
      ans=2ll*ans*inv[len]%mod*inv[len+1]%mod;//乘C(r-l+2,2)
		
      print(ans),putchar(10);
	}
	return 0;
}
```
---
# 后续
思维好题，锻炼代码能力，像我这种什么能力很弱的就肯定凉透了

求通过

---

## 作者：Thinking (赞：1)

我来发一篇标准的$O(n+q)$吧。

一句话题意：给出数列$a_1,a_2,\cdots,a_n$，和$q$个询问$[l,r]$，询问$\frac{\sum\limits^r_{i=l}\sum\limits^r_{j=i}\prod\limits^j_{k=i}a_k}{\frac{(r-l+2)(r-l+1)}{2}}mod100000007$。本质上就是要快速维护$\sum\limits^r_{i=l}\sum\limits^r_{j=i}\prod\limits^j_{k=i}a_kmod100000007$ ~~好像不可做~~

这种题一般先考虑分治，记上面的东西为$ans_{l,r}$，对于一个分界点$m$推算（以下运算默认省略$mod100000007$）：

$$\begin{aligned}ans_{l,r}&=ans_{l,m}+ans_{m+1,r}+\sum\limits^m_{i=l}\sum\limits^r_{j=m+1}\prod\limits^j_{k=i}a_k\\&=ans_{l,m}+ans_{m+1,r}+\sum\limits^m_{i=l}\sum\limits^r_{j=m+1}\prod\limits^m_{k=i}a_k\times\prod\limits^j_{t=m+1}a_t\\&=ans_{l,m}+ans_{m+1,r}+(\sum\limits^m_{i=l}\prod\limits^m_{k=i}a_k)\times(\sum\limits^r_{j=m+1}\prod\limits^j_{t=m+1}a_t)\end{aligned}$$

最后一步不好理解的话可以这么考虑：

$$\begin{aligned}a_m\times a_{m+1}+a_m\times a_{m+1}\times a_{m+2}+\cdots+a_m\times a_{m+1}\times a_{m+2}\times\cdots\times a_r+a_{m-1}\times a_m\times a_{m+1}+a_{m-1}\times a_m\times a_{m+1}\times a_{m+2}+\cdots+a_{m-1}\times a_m\times a_{m+1}\times a_{m+2}\times\cdots\times a_r+\cdots+a_l\times a_{l+1}\times\cdots\times a_m\times a_{m+1}+a_l\times a_{l+1}\times\cdots\times a_m\times a_{m+1}\times a_{m+2}+\cdots+a_l\times a_{l+1}\times\cdots\times a_m\times a_{m+1}\times a_{m+2}\times\cdots\times a_r&=a_m\times(a_{m+1}+a_{m+1}\times a_{m+2}+\cdots+a_{m+1}\times a_{m+2}\times\cdots\times a_r)+a_{m-1}\times a_m\times(a_{m+1}+a_{m+1}\times a_{m+2}+\cdots+a_{m+1}\times a_{m+2}\times\cdots\times a_r)+\cdots+a_l\times a_{l+1}\times\cdots\times a_m\times(a_{m+1}+a_{m+1}\times a_{m+2}+\cdots+a_{m+1}\times a_{m+2}\times\cdots\times a_r)\\&=(a_m+a_{m-1}\times a_m+\cdots+a_l\times a_{l+1}\times\cdots\times a_m)\times(a_{m+1}+a_{m+1}\times a_{m+2}+\cdots+a_{m+1}\times a_{m+2}\times\cdots\times a_r)\end{aligned}$$

~~我实在写不下了~~

这样的话，我们只要考虑求出从一个点出发的前缀积的前缀和和后缀积的后缀和，就可以实现合并了。

实现这个操作最简单的想法是用线段树，时间$O(nlogn+q(logmod+logn)$，空间$O(nlogn)$，~~被卡成暴力~~，我们发现这个解法的瓶颈在于前缀和后缀的计算，可不可以加速呢？

我们发现，预先求出$lsum_i=\sum\limits^i_{j=1}\prod\limits^j_{k=1}a_k$和$rsum_i=\sum\limits^n_{j=i}\prod\limits^n_{k=j}a_k$（这两个东西都可以$O(n)$求，那么$[l,r]$的前缀积的前缀和就是$\frac{lsum_r-lsum_{l-1}}{\prod\limits^{l-1}_{i=1}a_i}$，后缀积的后缀和就是$\frac{rsum_l-rsum_{r+1}}{\prod\limits^n_{i=r+1}a_i}$，预处理出分母下面的东西就可以$O(1)$查询了。时间$O(n+q(logmod+logn))$，空间$O(n)$。 ~~还是被卡成暴力~~

能不能摆脱线段树的思维定式呢？我们发现，加具有可减性！考虑对答案前缀和：$sumans_i=ans_{1,i}$，那么$ans_{l,r}=sumans_r-sumans_{l-1}-\text{[1,l-1]的后缀积的后缀和}\times\text{[l,r]的前缀积的前缀和}$这是可以$O(1)$求的！

而$sumans_i$也可以用类似方法$O(n)$递推，加上两个乘法逆元模板中的技术，就可以做到$O(n+q)$。 ~~总算过了~~

code：

```cpp
#include<cstdio>
typedef long long ll;
const int mod=100000007;
const int N=1000050;
char rB[1<<21],*rS,*rT,wB[1<<21];
int wp=-1;
inline char gc(){return rS==rT&&(rT=(rS=rB)+fread(rB,1,1<<21,stdin),rS==rT)?EOF:*rS++;}
inline void flush(){fwrite(wB,1,wp+1,stdout);wp=-1;}
inline void pc(char c){if(wp+1==(1<<21))flush();wB[++wp]=c;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
short buf[15];
inline void wt(int x){
    short l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    pc(x|48);
    while(l>=0)pc(buf[l--]|48);
    pc('\n');
}
int a[N],sum[N],sl[N],sr[N],vl[N],vr[N],fl[N],v[N],x,y;
void exgcd(int a,int b,int &x,int &y){
	if(!b){x=1;y=0;}
	else{
		exgcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
inline int inv(int a){
	int x,y;
	exgcd(a,mod,x,y);
	return x<0?x+mod:x;
}
inline int getl(int x,int y){return (ll)(sl[y]-sl[x-1]+mod)*vl[x-1]%mod;}
                        //前缀积的前缀和
inline int getr(int x,int y){return (ll)(sr[x]-sr[y+1]+mod)*vr[y+1]%mod;}
                        //后缀积的后缀和
inline int query(){  //询问
	return (sum[y]-sum[x-1]-(ll)getr(1,x-1)*getl(x,y)%mod+(mod<<1))%mod;
}
int main(){
	int n=rd(),q=rd(),i,res=1,tmp;
	for(i=fl[0]=1;i<=n;++i){  //这里用了一个辅助的fl，用来推逆元
		fl[i]=res=(ll)res*(a[i]=rd())%mod;
		sl[i]=(sl[i-1]+res)%mod;
	}
	tmp=inv(fl[n]);
	for(i=n,res=1;i;--i){
		vr[i]=(ll)tmp*fl[i-1]%mod;
		vl[i]=(ll)tmp*res%mod;
		sr[i]=(sr[i+1]+(res=(ll)res*a[i]%mod))%mod;
	}
	for(v[1]=1,i=2;i<=n+1;++i)v[i]=(ll)(mod-mod/i)*v[mod%i]%mod;  //线性推1~n+1的逆元
	for(i=1;i<=n;++i)sum[i]=(sum[i-1]+(ll)(getr(1,i-1)+1)*a[i])%mod;
	while(q--){
		x=rd();y=rd();
		wt((ll)(query()<<1)*v[y-x+2]%mod*v[y-x+1]%mod);
	}
	flush();
	return 0;
}
```


---

## 作者：ExplodingKonjac (赞：0)

### [【原题链接】](https://www.luogu.com.cn/problem/P5498)

发现题解区里的都是推柿子解法，鄙人不才来一个用线段树的。

而且这种做法可以扩展至带单点修改的情况。

## 题目分析

根据期望定义，易得答案 $\displaystyle{=\frac{\displaystyle{\sum_{l\le i\le j\le r}\prod_{k=i}^j a_k}}{(r-l+1)(r-l+2)/2}}$。

分母容易求出，重点在于分子怎么求。

考虑分治，我们将当前区间 $[l,r]$ 分割成 $[l,mid],[mid+1,r]$ 两个区间。为了方便描述，我们设 $\displaystyle{f_{l,r}:=\prod_{i=l}^r a_i}$。那么我们可以发现：

$$
\sum_{l\le i\le j\le r}\hspace{-0.5em}f_{i,j}=\sum_{l\le i\le j\le mid}\hspace{-1em}f_{i,j}+\sum_{mid+1\le i\le j\le r}\hspace{-1em}f_{i,j}+\left(\sum_{i=l}^{mid}f_{i,mid}\right)\left(\sum_{i=mid+1}^rf_{mid+1,i}\right)
$$

也就是说，$[l,r]$ 的答案等于**左右两个区间的答案之和加上左区间后缀积的和与右区间前缀积的和的乘积**。所以我们在区间中维护这些东西就可以了。

形式化地，我们设：

$$
\begin{cases}
prod&=\prod_{i=l}^r a_i\\
lps&=\sum_{i=l}^r \prod_{j=l}^i a_j\\
rps&=\sum_{i=l}^r \prod_{j=i}^r a_j\\
ans&=\sum_{l\le i\le j\le r}\prod_{k=i}^j a_k
\end{cases}
$$

容易发现有递推式：

$$
\begin{cases}
prod&=prod_l\cdot prod_r\\
lps&=lps_l+prod_l\cdot lps_r\\
rps&=rps_r+prod_r\cdot rps_l\\
ans&=ans_l+ans_r+rps_l\cdot lps_r
\end{cases}
$$

因此我们可以做到 $O(n)$ 的分治，使用线段树即可扩展至区间查询。

顺便说一句，注意模数是 $10^{\bf\color{red}8}+7$，也是一个质数，我最开始就被骗了 qwq。

## 代码实现

线段树貌似常数有点大，$O(q\log n)$ T 掉了几个点。但是卡卡常就过了。

附：[$1.00s$ TLE](https://www.luogu.com.cn/record/68254614)。

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
省略100多行的快读快写模板
即下文中的qin、qout
*/

typedef long long LL;
const int MOD=1e8+7;
int n,m,a[1000005];
inline LL quickPow(LL a,LL b)
{
	LL res=1;
	for(;b;a=a*a%MOD,b>>=1)if(b&1)res=res*a%MOD;
	return res;
}
inline int madd(int x,int y)	{ return (x+=y)>=MOD?x-=MOD:x; }
inline int msub(int x,int y)	{ return (x-=y)<0?x+=MOD:x; }
inline int mmul(int x,int y)	{ return (LL)x*y%MOD; }
inline int mdiv(int x,int y)	{ return mmul(x,quickPow(y,MOD-2)); }
struct Data
{
	int prod,lps,rps,all;
	inline Data()=default;
	inline Data(int x): prod(x),lps(x),rps(x),all(x){}
	friend inline Data operator +(const Data &x,const Data &y)
	{
		Data res;
		res.prod=mmul(x.prod,y.prod);
		res.lps=madd(x.lps,mmul(x.prod,y.lps));
		res.rps=madd(y.rps,mmul(y.prod,x.rps));
		res.all=madd(madd(x.all,y.all),mmul(x.rps,y.lps));
		return res;
	}
};
struct TreeNode{ Data val;int lc,rc; }t[2000005];
int cnt,rt;
#define LC t[i].lc
#define RC t[i].rc
void build(int l,int r,int &i=rt)
{
	i=++cnt;
	if(l==r)	t[i].val=Data(a[l]);
	else
	{
		int mid=(l+r)>>1;
		build(l,mid,LC),build(mid+1,r,RC);
		t[i].val=t[LC].val+t[RC].val;
	}
}
Data query(int lq,int rq,int i=rt,int l=1,int r=n)
{
	if(l>=lq && r<=rq)	return t[i].val;
	int mid=(l+r)>>1;
	if(mid>=lq && mid<rq)
		return query(lq,rq,LC,l,mid)+query(lq,rq,RC,mid+1,r);
	else if(mid>=lq)
		return query(lq,rq,LC,l,mid);
	else if(mid<rq)
		return query(lq,rq,RC,mid+1,r);
}
int main()
{
	qin>>n>>m;
	for(int i=1;i<=n;i++)	qin>>a[i];
	build(1,n);
	int l,r,len;
	while(m--)
	{
		qin>>l>>r,len=r-l+1;
		qout.writeln(mdiv(query(l,r).all,(LL)len*(len+1)/2%MOD));
	}
	return qout.flush(),0;
}
```


---

## 作者：Remnants (赞：0)

考试看到这题时很迷

第一想法是考虑每一个区间
假设有
$$a_1,a_2,a_3,a_4,a_5$$
则对于a1有向后以下几个区间
1. $$a_1$$
1. $$a_1,a_2$$
1. $$a_1,a_2,a_3$$
1. $$a_1,a_2,a_3,a_4$$
1. $$a_1,a_2,a_3,a_4,a_5$$
对以上区间价值求和得到：

$$a_1+a_1\cdot a_2+a_1\cdot a_2\cdot a_3+a_1\cdot a_2\cdot a_3\cdot a_4+a_1\cdot a_2\cdot a_3\cdot a_4\cdot a_5$$

$$=$$

$$a_1\cdot(1+a_2\cdot(1+a_3\cdot(1+a_4\cdot(1+a_5))))$$

**同理求得整段区间的答案为**

$$a_1\cdot(1+a_2\cdot(1+a_3\cdot(1+a_4\cdot(1+a_5))))$$
$$+a_2\cdot(1+a_3\cdot(1+a_4\cdot(1+a_5)))$$
$$+a_3\cdot(1+a_4\cdot(1+a_5))$$
$$+a_4\cdot(1+a_5)$$
$$+a_5$$

**于是我考虑从后往前预处理出类似于上面的式子**
```cpp
  for (int i=n;i;i--)
  {
	qz[i]=((qz[i+1]+1)*a[i])%mod;
  }
```

**然后我假设我们要在a1,a2,a3,a4,a5五个数中求a1,a2,a3区间的价值**

则有
$$a_1\cdot (1+a_2\cdot(1+a_3))+a_2\cdot(1+a_3)+a_3$$

然后就发现这玩意儿其实就是
$$qz[1]-a_1\cdot a_2\cdot a_3\cdot qz[4]$$
$$+qz[2]-a_2\cdot a_3\cdot qz[4]$$
$$+qz[3]-a_3\cdot qz[4]$$
$$=$$
$$\sum_{i\in[1,3]}qz[i]-a_1\cdot(1+a_2\cdot(1+a_3))\cdot qz[4]$$

**看到中间这项是不是很熟悉**
**于是我又预处理了从前往后的 $hz[i]$**

**同时将$qz[i]$的前缀和 以及累乘$cj[i]$处理出来**
```cpp

  for (int i=1;i<=n;i++)
  {
	hz[i]=((hz[i-1]+1)*a[i])%mod;
	cj[i]=(cj[i-1]*a[i])%mod;
	qzh[i]=(qzh[i-1]+qz[i])%mod;
  }
```

**于是当我们要求例如$a_l\cdot(1+...(1+a_r))$**
**相当于$hz[r]-hz[l-1]*(cj[r]\over cj[l-1])$**

从而得到对于区间$[l,r]$最终答案为
$$qzh[r]-qzh[l-1]-(hz[r]-hz[l-1]*(cj[r]/cj[l-1]))\cdot qz[r+1]$$

**由于是求期望因此还要除以区间个数
即**$(r-l+1)\cdot (r-l+2) \over 2$

**除法还得加个逆元**

```
#include<bits/stdc++.h>
#define ll long long
const ll mod=1e8+7;
using namespace std;
ll a[2000005],cj[2000005],sum[2000005],qz[2000005];
ll hz[2000005],qzh[2000005];
ll ny[1000005];
ll inv(ll a)//求逆元
{
  if (a<500000)
  {
    if (ny[a]) return ny[a];
    return ny[a]=(mod-mod/a)*(inv(mod%a))%mod;
  }
  return (mod-mod/a)*(inv(mod%a))%mod;
}
ll now,n,m;
inline ll read()//快读
{
  char c;
  ll sign=1;
  while ((c=getchar())<'0'||c>'9') if (c=='-') sign=-1;
  ll res=c-'0';
  while ((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
  return res*sign;
}

int main()
{
  ny[1]=1;
  n=read(); m=read();
  for (ll i=1;i<=n;i++) a[i]=read();
  qz[n+1]=0;
  for (int i=n;i;i--)
  {
	qz[i]=((qz[i+1]+1)*a[i])%mod;
  }
  cj[0]=1;
  for (int i=1;i<=n;i++)
  {
	hz[i]=((hz[i-1]+1)*a[i])%mod;
	cj[i]=(cj[i-1]*a[i])%mod;
	qzh[i]=(qzh[i-1]+qz[i])%mod;
  }//预处理hz[i],qz[i],qzh[i],cj[i]
  qz[0]=1;
  ll l,r;
  ll k1,k2,k3,k4;
  for (int i=1;i<=m;i++)
  {
	l=read(); r=read();
	ll ans1=(qzh[r]-qzh[l-1]+mod)%mod;
	ll ans2=(hz[r]-(hz[l-1]*((cj[r]*inv(cj[l-1]))%mod))%mod+mod)%mod;
	ll ans=(ans1-((ans2*qz[r+1])%mod)+mod)%mod;
	ll len=((r-l+1)*(r-l+2)/2)%mod;
	printf("%lld\n",(ans*(inv(len)))%mod);
  }
}
//该取模的地方都取模
//除法就乘上逆元
```




---

## 作者：detect (赞：0)

写在前面： 又是一次半途才加入的比赛，时间不够+T2被疯狂卡常。

这次比赛告诉我们，好的革命要准时开始！



------------
此题让我们维护一个数列（其实不叫维护因为没有修改），然而，对于题目特殊要求，我们可以手玩一下小数据。

发现，对于一个询问，分母为（r-l+1）*（r-l+2）/2（易得），然而分子怎么算，似乎对于30%的数据可以搜索？

像这样（一个同学写的暴力）：

```cpp
int dfs(int l,int r)
{
	int ans=0;
	for(int i=l;i<=r;++i)
	{
		for(int j=i;j<=r;++j)
		{
			int s1=1;
			for(int z=i;z<=j;++z)
			{
				s1=(s1*a[z])%mod;
			}
			ans+=s1;
			ans%=mod;
		}
	}return ans%mod;
}
```
然而我们是不是可以考虑数学推式子。

```cpp
    //稍微推一下，并不难
	for(int j=l;j<=r;j++)
		{
			exgcd(s[j-1],mod);//要除以s[j-1]，相当于乘以逆元
			x=(x%mod+mod)%mod;//s数组为原序列的从1开始的乘积
			fz=(fz+(ss[r]-ss[j-1])*x)%mod;//ss数组是原序列乘积的前缀和
		}
```
我们现在成功降成了二维。

然而似乎还不够，我们打开括号，

发现是一个ss[r]*inv(ss[j-1])-ss[j-1]*inv(s[j-1])

对于前一个，我们对inv数组记录前缀和，可以O1求

对于后一个，我们对ss[j-1]*inv(s[j-1])整体求前缀和，也可以做到O1求。


好了，整理一下，代码是这样：

```cpp
	int len=r-l+1;
        fz=(ss[r]*(((sinv[r-1]-sinv[l-2])%mod+mod)%mod)%mod-((sss[r-1]-sss[l-2])%mod+mod))%mod;
        fz=(fz+mod)%mod;
```

现在复杂度已经降到了Onlogn，很遗憾此题略微卡常

我们继续优化：

这是我们T掉的代码中一段

```cpp
		fm=((r-l+1)*(r-l+2)/2)%mod;
    	       exgcd(fm,mod);//因为ans为分子比上分母，所以对于每一个分母要求逆元。
```
我们惊喜地发现分母的逆元之和l-r的长度有关，我们可以记忆len的长度

如果遇上相同的长度就不用再算一次了。

于是就可以Ac本题了。



------------
Ac code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int getint(){
int summ=0,f=1;
char ch;
for(ch=getchar();!isdigit(ch)&&ch!='-';ch=getchar());
if(ch=='-')
{
    f=-1;
    ch=getchar();
}
for(;isdigit(ch);ch=getchar())
    summ=(summ<<3)+(summ<<1)+ch-48;
return summ*f;
}
void print(int xx)
{
    if(xx<0)
    {
        putchar('-');
        xx=-xx;
    }
    if(xx>9)
        print(xx/10);
    putchar(xx%10+'0');
}
int n,m,mod=100000007,q,x,y;
int a[1000005],s[1000005],ss[1000005],inv[1000005],sinv[1000005],sss[1000005],ni[1000005],fz,fm;
double ans;
void exgcd(int aa,int b)
{
	if(b==0)
	{
		x=1;y=0;return;
	}
	exgcd(b,aa%b);
	int xx=y;
	int yy=x-(aa/b)*y;
	x=xx;y=yy;
}
signed main()
{
	cin>>n>>q;
	for(register int i=1;i<=n;i++)
	  a[i]=getint();
	  s[0]=1;
	  for(register int i=1;i<=n;i++) s[i]=(s[i-1]*a[i])%mod;
	  for(register int i=1;i<=n;i++) ss[i]=(ss[i-1]+s[i])%mod;//对于乘积前缀和
      for(register int i=0;i<=n;i++) 
      {
            exgcd(s[i],mod);
            x=(x%mod+mod)%mod;
            inv[i]=x;//预处理逆元
      }
      for(register int i=0;i<=n;i++) 
	  sinv[i]=inv[i]+sinv[i-1]; //逆元前缀和
      for(register int i=0;i<=n;i++)
      {
          sss[i]=(sss[i-1]+ss[i]*inv[i])%mod;//整体前缀和
      }
	for(register int i=1;i<=q;i++)
	{

		int l,r;
		l=getint();r=getint();
		int len=r-l+1;
        fz=(ss[r]*(((sinv[r-1]-sinv[l-2])%mod+mod)%mod)%mod-((sss[r-1]-sss[l-2])%mod+mod))%mod;//见上面讲的推导式子
        fz=(fz+mod)%mod;
        fm=((r-l+1)*(r-l+2)/2)%mod;
        if(!ni[len])//把长度记忆化
        {
        	exgcd(fm,mod);
			x=(x%mod+mod)%mod;
			ni[len]=x;
			print((x*fz)%mod);
			putchar(10);
        }
    	else{
    		print((ni[len]*fz)%mod);
			putchar(10);
    	}
	}
	return 0;
}
```



---


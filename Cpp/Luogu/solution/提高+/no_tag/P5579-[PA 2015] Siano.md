# [PA 2015] Siano

## 题目描述

农夫 Byteasar 买了一片 $n$ 亩的土地，他要在这上面种草。

他在每一亩土地上都种植了一种独一无二的草，其中，第 $i$ 亩土地的草每天会长高 $a_i$ 厘米。

Byteasar 一共会进行 $m$ 次收割，其中第 $i$ 次收割在第 $d_i$ 天，并把所有高度大于等于 $b_i$ 的部分全部割去。

Byteasar 想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？

## 说明/提示

对于 $100\%$ 的数据，$1\le n,m\le 5\times 10^5$，$1\le a_i\le 10^6$，$1\le d_i\le 10^{12}$，$0\le b_i\le 10^{12}$。

数据保证 $d_1<d_2<...<d_m$，并且任何时刻没有任何一亩草的高度超过 $10^{12}$。

## 样例 #1

### 输入

```
4 4
1 2 4 3
1 1
2 2
3 0
4 4```

### 输出

```
6
6
18
0```

# 题解

## 作者：Su_Zipei (赞：27)

### 这里有一个$O(n)$的做法
首先先来考虑下面一种情况，假设第$k$次切割时，天数为$d_k$，高度为$b_k$，第$k+1$次切割时，天数为$d_{k+1}$，高度为$b_{k+1}$，那么我们定义一个切割速度，令$v=\frac{b_{k+1}-b_k}{d_{k+1}-d_k}$，这个切割速度有什么含义呢，如果在$d_k$天时所有的草**都是**$b_k$高，那么生长速度$>v$的草都要割掉,注意这里的$v$极有可能是一个浮点数，而在写代码的时候最好还是避免浮点数的出现，所以要怎么转化？这个应该很显然，令$v=\lfloor \frac{b_{k+1}-b_k}{d_{k+1}-d_k} \rfloor$即可，因为判断的时候都是找的大于这个$v$的，而给出的生长速度都是整数，所以把这个$v$下取整后再判断大小也没有任何影响。怎么求出答案呢？很显然，就是$(d_{k+1}-d_k)*$需要割掉的草的总生长速度$+t$，$t$是什么？分类讨论一下，如果$b_k>b_{k+1}$，那么除了长出来的草，还需要割掉$b_k$比$b_{k+1}$高的那一段，也就是$(b_k-b_{k+1})*$需要割掉的草的总数量，如果$b_k==b_{k+1}$，$t=0$，如果如果$b_k<b_{k+1}$，就不能长出来的全都割掉，因为只割到$b_{k+1}$，所以需要把之前多算的那些减去，即$-(b_{k+1}-b_k)*$需要割掉的草的总数量，综上所述，$t=(b_k-b_{k+1})*$需要割掉的草的总数量，于是需要求的就是需要割掉的草的总生长速度和需要割掉的草的总数量，注意到$m$最大也就$10^6$，所以开$10^6$个桶，第$i$个桶里边存生长速度为$i$的草的数量，然后就可以运用一下前缀和的思想求出上边的两个值。

好了基本思想有了，但是注意一个问题，并不是所有的需要切割的草在上一次切割时都恰好为$b$，即上一次没有被切割但是下一次它长到了可以被切割的高度的草，把这些草。~~所以上边讨论了五百多字就白扯了吗~~，显然不是，还是有一部分草是满足上述的切割办法的，也就是两次都被切割的，所以只需要特殊考虑上一次没有被切割但是下一次它长到了可以被切割的高度的草，把这些草处理了就行。通过上一次的切割处理这个很不好处理，但是我们可以发现，如果我们定义第0天时割掉了所有高度大于0的草（对答案没有影响因为初始时都是0），那么假设当前时刻为$d_k$，这些草在之前的某个时刻$d_t(d_t \in[0,d_k)\ \ )$一定会被割掉，于是$d_t$到$d_k$套用上述式子就行，聪明的你一定会发现这样会重复割草，没错，的确会，为了避免这种情况，假设上次割掉了生长速度超过$last$的草，那么这次只需要割掉生长速度超过切割速度且小于等于$last$的草即可,但是这样还是会出现重复割草的情况，因为可能前边已经割过的又被割了一次，所以需要记录前边每一次割草割过的最小切割速度，举个例子吧，假设记录的这个为$to_i$，表示的意思就是在第$i$次割草的时候生长速度大于$to_i$的已经都被割掉了,所以如果此时$k-i$的切割速度大于$to_i$就需要直接$break$掉，避免了重复割草。
但是这样做的时间复杂度应该是$O(m^2)$的，需要优化一下。

注意到草的生长速度是有单调性的，在不去割草的情况下生长速度越大的高度一定越大~~废话~~，于是可以维护一个$to$值单调上升的单调栈。若栈顶那一次切割能切到的最小速度$\leq$当前能切到的最小速度，则前面切不到的依旧切不到，若栈顶那一次切割能切到的最小速度$>$当前能切到的最小速度，则先计算比栈顶那一次切割能切到的最小速度大的,并将栈顶$pop$掉，重复此过程至栈顶速度$\leq$当前能切到的最小速度。

但是这样会不会漏掉什么情况呢？答案是不会，因为每一次的割草都是割的连续的速度，只可能出现重复情况，而重复情况上边已经排除，所以这种做法是可以的。

由于本人蒟蒻，可能有些地方写的不严谨或者不清楚，又或者有的地方写错了。。。反正感觉不对的地方欢迎指出来。

借鉴于<https://www.cnblogs.com/wangyurzee7/p/5224273.html>
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int lqs=5e5+10,m=1e6;
int day,a[lqs<<1],n,stk[lqs],top;
ll s[lqs<<1],d[lqs],b[lqs],to[lqs];
int main(){
	scanf("%d%d",&n,&day);
	for(int w,i=1;i<=n;i++)
		scanf("%d",&w),a[w]++;
	for(int i=1;i<=day;i++)
		scanf("%lld%lld",&d[i],&b[i]);
	for(int i=1;i<=m;i++)
		s[i]=s[i-1]+1ll*a[i]*i;
	for(int i=1;i<=m;i++)
		a[i]+=a[i-1];
	top=1;
	for(int i=1;i<=day;i++){
		ll res=0;
		int last=m,x=max(to[stk[top]],min((b[i]-b[stk[top]])/(d[i]-d[stk[top]]),1ll*m));
		while(x<last){
			res+=(d[i]-d[stk[top]])*(s[last]-s[x])+(b[stk[top]]-b[i])*(a[last]-a[x]);
			last=x;
			if(last>to[stk[top]])break;
			if(top==0)break;top--;
			x=max(to[stk[top]],min((b[i]-b[stk[top]])/(d[i]-d[stk[top]]),1ll*m));
		}
		to[i]=last;
		if(to[i]<m)stk[++top]=i;
		printf("%lld\n",res);
	}
}
```

---

## 作者：HH_Halo (赞：18)

### [HH_Halo](https://www.cnblogs.com/hhhhalo/p/13736793.html)
## 思路分析
* 首先这题有一个很神奇的性质，就是长得快得一定长得高，不论有没有被割掉，那么在将生长速度排序以后，**每一次割掉的一定是一个区间**，而且还是一个后缀区间
* 所以就可以很方便地使用线段树处理了，因为每一次都可能有被割的，也会有没被割的，所以将其分开处理。
* 这时候我们要做的就是找到生长速度最小的会被割掉的点，这在线段树上也很方便处理。在线段树中记录一些其包含区间的最高值，寻找时只**需判断一下左右子树的最大值然后决定是继续向左还是向右**。
另外也有可能找不到，返回的时候处理一下就好了

## $Code$
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define R register
#define N 500010
#define ll long long
using namespace std;
inline ll read(){
	ll x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,a[N];
ll sum[N];
struct Segment_Tree{
	ll het,clock,sum,est;//分别对应高度的tag，生长天数的tag，区间和，和最高值
}tr[N<<2];
#define ls rt<<1
#define rs rt<<1|1
void build(int rt,int l,int r){
	tr[rt].het = -1;//初始化为-1，因为可能会有高度为0的时候，代表没有被割
	if(l==r)return;
	int mid = (l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void cut(int rt,int l,int r,ll val){
	tr[rt].het = tr[rt].est = val;//被割以后高度相同
	tr[rt].sum = 1ll*(r-l+1)*val;
	tr[rt].clock = 0;//注意清空生长天数，因为这时是一个新起点
}
void grow(int rt,int l,int r,ll days){
	tr[rt].clock += days;//这个直接区间加就好了
	tr[rt].sum += 1ll*(sum[r]-sum[l-1])*days;
	tr[rt].est += 1ll*a[r]*days;
}
void pushdown(int rt,int l,int r){
	int mid = (l+r)>>1;
	if(tr[rt].het!=-1){//说明需要割
		cut(ls,l,mid,tr[rt].het);
		cut(rs,mid+1,r,tr[rt].het);
		tr[rt].het = -1;
	}
	if(tr[rt].clock){//说明没被割
		grow(ls,l,mid,tr[rt].clock);
		grow(rs,mid+1,r,tr[rt].clock);
		tr[rt].clock = 0;
	}
}
ll modify(int rt,int l,int r,int s,int t,ll val){//可以在修改的时候就得出答案
	if(s<=l&&t>=r){
		ll tmp = tr[rt].sum;
		cut(rt,l,r,val);
		return tmp - tr[rt].sum;//割前的高度-割完以后的高度
	}
	ll res = 0;
	int mid = (l+r)>>1;
	pushdown(rt,l,r);
	if(s<=mid)res += modify(ls,l,mid,s,t,val);
	if(t>mid)res += modify(rs,mid+1,r,s,t,val);
	tr[rt].sum = tr[ls].sum + tr[rs].sum;
	tr[rt].est = tr[rs].est;
	return res;
}
int find(int rt,int l,int r,ll val){//寻找会被割的最小左端点
	if(l==r)return tr[rt].sum < val ? n+1 : l;
	int mid = (l+r)>>1;
	pushdown(rt,l,r);
	if(tr[ls].est>=val)return find(ls,l,mid,val);
	else return find(rs,mid+1,r,val);
}
int main(){
	n = read(),m = read();
	for(R int i = 1;i <= n;i++)a[i] = read();
	sort(a+1,a+1+n);
	for(R int i = 1;i <= n;i++)sum[i] = sum[i-1]+a[i];
	build(1,1,n);
	ll pre = 0;
	for(R int i = 1;i <= m;i++){
		ll d = read(),b = read();
		grow(1,1,n,d-pre);
		pre = d;
		printf("%lld\n",modify(1,1,n,find(1,1,n,b),n,b));
	}
	return 0;
}
```

---

## 作者：Yaha (赞：8)

### 线段树综合

对于生长，记录 lazytag 就可以了，关键是如何将大于 $b_i$ 的数变成 $b_i$ 。

如果我们直接做，毫无疑问，这些大于 $b_i$ 的数零散地分布在 $[1,n]$ 中，直接退化成单点修改，枚举超时。

于是，我们试着将其转化为区间修改。

怎样转化为区间修改？

尝试将大于 $b_i$ 的数放在一堆，可以让这些数单调递增，这样，大于 $b_i$ 的数就集中分布在 $[1,n]$ 的右边了。

将 $a_i$ 数组单调递增排列，这些数的增长速度就单调递增，即使将大于 $d_i$ 的数变成 $d_i$ ，线段树中的数也一定是单调不降的。

我把所有的修改都写在了一个函数中：
```
modify(i,k1,k2,k3)
```
表示 $x=k1\times x+k2\times a[i]+k3$。
 
对应的，用了三个 ``` lazytag ``` 记录。

这样代码就可以比较简洁啦。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls (i<<1)
#define rs (i<<1|1)
#define mid (a[i].l+a[i].r>>1)
#define len(p) (a[p].r-a[p].l+1)
#define laz1 a[i].lazy1
#define laz2 a[i].lazy2
#define laz3 a[i].lazy3

using namespace std;

const int amou=6e5+90;

int n,m;
struct Seg{
	int l,r,Max,lazy1,lazy2,lazy3;
	int sum;
}a[amou<<2];
int g[amou],s[amou];

void build(int i,int l,int r){
	a[i].l=l,a[i].r=r,laz1=1,laz2=laz3=0;
	if(l==r) return;
	build(ls,l,mid);
	build(rs,mid+1,r);
}

void modify(int i,int k1,int k2,int k3){
	laz1*=k1,laz2=laz2*k1+k2,laz3=laz3*k1+k3;
	a[i].Max=a[i].Max*k1+k2*g[a[i].r]+k3;
	a[i].sum=a[i].sum*k1+(s[a[i].r]-s[a[i].l-1])*k2+k3*len(i);
}

void pushdown(int i){
	modify(ls,laz1,laz2,laz3);
	modify(rs,laz1,laz2,laz3);
	laz1=1,laz2=laz3=0;
}

void pushup(int i){
	a[i].Max=a[rs].Max;
	a[i].sum=a[ls].sum+a[rs].sum;
}

int modify_B(int i,int B){
	if(a[i].l==a[i].r)
	{
		int as=a[i].sum-B;
		modify(i,0,0,B);
		return as;
	}
	pushdown(i);
	int as=0;
	if(a[ls].Max>B)
	{
		as=modify_B(ls,B)+a[rs].sum-B*len(rs);
		modify(rs,0,0,B);
	}
	else as=modify_B(rs,B);
	pushup(i);
	return as;
}

signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&g[i]);
	sort(g+1,g+n+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+g[i];
	build(1,1,n);
	int las=0;
	for(int i=1;i<=m;i++)
	{
		int d,b;
		scanf("%lld%lld",&d,&b);
		modify(1,1,d-las,0);
		int ans=0;
		if(a[1].Max>b) ans=modify_B(1,b);
		las=d;
		printf("%lld\n",ans);
	}
	
	return 0;
}
```


---

## 作者：tommymio (赞：3)

此题显然有一个性质：将所有草按 $a_i$ 从大到小排序,左边的草的高度无论何时一定都大于右边的草的高度。这一性质可以证明：不存在割草时，初始高度相同，$a_i$ 大的高度更高；存在割草时，若草的高度超出了 $b_i$，则会被割到 $b_i$，低于 $b_i$ 的草高度不变。因此在任何时刻，排序后左边的草的高度都高于右边的草的高度。

则对于每次割草，存在一个分界点 $pos$，分界点前（包括分界点）的草会被割到 $b_i$，分界点后的草不进行操作。对答案的贡献只由分界点前（包括分界点）的草决定，这样的一个分界点显然是第一个 $\geq b_i$ 的点。

每次询问时，先区间增量一个数列 $a_i$（即草生长的过程），再找到这样的一个分界点，查询分界点前（包括分界点）的草高度与 $b_i$ 之差的和。并且对分界点前（包括分界点）的草的高度进行区间赋值。

使用线段树支持上述操作即可，时间复杂度为 $O(n \log n)$。普通线段树常数较大，将查询区间和和区间赋值的操作合并成一个函数可以有效减小常数；**线段树上同时支持区间覆盖和区间增量时，规定区间覆盖这一操作的优先级更高**。

**Show the Code**
```cpp
#include<cstdio>
#include<algorithm>
#define ls p<<1
#define rs p<<1|1 
typedef long long ll;
int a[500005];
ll sum[500005],day[500005];
struct segtree {
	int l,r;
	ll tag,cov,sum,maxn;
}t[2000005];
inline ll read() {
	register ll x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline bool cmp(int x,int y) {return x>y;}
inline ll max(ll x,ll y) {return x>y? x:y;}
inline void work_cov(int p,ll val) {
	t[p].maxn=val;
	t[p].sum=val*(t[p].r-t[p].l+1);
	t[p].cov=val;
	t[p].tag=0;
}
inline void work_tag(int p,ll val) {
	t[p].maxn+=val*a[t[p].l];
	t[p].sum+=val*(sum[t[p].r]-sum[t[p].l-1]);
	t[p].tag+=val;	
}
inline void spread(int p) {
	if(t[p].cov!=-1) {
		work_cov(ls,t[p].cov);
		work_cov(rs,t[p].cov);
		t[p].cov=-1;
	}
	if(t[p].tag!=0) {
		work_tag(ls,t[p].tag);
		work_tag(rs,t[p].tag);
		t[p].tag=0;
	}
}
inline void build(int p,int l,int r) {
	t[p].l=l;t[p].r=r;t[p].cov=-1;
	if(l==r) return;
	int mid=l+r>>1;
	build(ls,l,mid);build(rs,mid+1,r);
}
inline int ask_p(int p,ll lim) {
	int L=t[p].l,R=t[p].r,mid=L+R>>1;
	if(L==R) return t[p].maxn<lim? -1:L;
	spread(p);
	if(t[rs].maxn>=lim) return ask_p(rs,lim);
	return ask_p(ls,lim);
}
inline ll modify_cov(int p,int l,int r,ll val) {
	if(l>r) return 0;
	int L=t[p].l,R=t[p].r,mid=L+R>>1;
	if(l<=L&&r>=R) {ll tmp=t[p].sum-val*(t[p].r-t[p].l+1);work_cov(p,val);return tmp;}
	spread(p); ll res=0;
	if(l<=mid) res+=modify_cov(ls,l,r,val);
	if(r>mid) res+=modify_cov(rs,l,r,val);
	t[p].sum=t[ls].sum+t[rs].sum;
	t[p].maxn=t[ls].maxn;
	return res;
}
int main() {
	int n=read(),m=read();
	for(register int i=1;i<=n;++i) a[i]=read();
	std::sort(a+1,a+1+n,cmp);
	for(register int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i];
	build(1,1,n);
	for(register int i=1;i<=m;++i) {
		day[i]=read();ll lim=read();
		work_tag(1,day[i]-day[i-1]);
		int pos=ask_p(1,lim);
		if(pos==-1) printf("0\n");
		else printf("%lld\n",modify_cov(1,1,pos,lim)); 
	}
 	return 0;
}
```

---

## 作者：Skyjoy (赞：3)

线段树模板题

这道题我们思考一下就可以发现，草的长度是随生长速度**单调递增**的，也就是说，我们将生长速度 $a_i$ 从小到大排个序，就可以得到草的长度的关系 $l_i<=l_j,(i\le j)$ ，这个柿子在所有情况下都成立。所以说我们只要给草排序，然后找到被割的草的左端点，进行**区间修改**，用线段树**维护区间和再减去修改后的区间和**就可以了。

话不多说，看代码：

```cpp
#include<bits/stdc++.h>
#define ls(k) k<<1
#define rs(k) k<<1|1
#define ll long long
using namespace std;
const int N=500010;
ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
ll n,m,a[N],d,b,last,sum[N];
struct SegmentTree{
	ll l,r,sum,maxn,day,tag;//day 是生长的标记， tag 是割的标记
}tree[N<<2];
void pushup(int k){
	tree[k].sum=tree[ls(k)].sum+tree[rs(k)].sum;
	tree[k].maxn=tree[rs(k)].maxn;
}
void build(int k,int l,int r){
	tree[k].tag=-1,tree[k].l=l,tree[k].r=r;
	if(l==r)return;
	int mid=(l+r)/2;
	build(ls(k),l,mid),build(rs(k),mid+1,r);
}
void grow(int k,int l,int r,ll day){//生长
	tree[k].day+=day;
	tree[k].sum+=1ll*(sum[r]-sum[l-1])*day;
	tree[k].maxn+=1ll*a[r]*day;
}
void cut(int k,int l,int r,ll val){//割
	tree[k].tag=tree[k].maxn=val;
	tree[k].sum=1ll*(r-l+1)*val;
	tree[k].day=0;
}
void pushdown(int k){
	int mid=(tree[k].l+tree[k].r)/2,l=tree[k].l,r=tree[k].r;
	if(tree[k].tag!=-1){//需要割，注意割的优先级比生长高
		cut(ls(k),l,mid,tree[k].tag),cut(rs(k),mid+1,r,tree[k].tag);
		tree[k].tag=-1;
	}
	if(tree[k].day){//需要生长
		grow(ls(k),l,mid,tree[k].day),grow(rs(k),mid+1,r,tree[k].day);
		tree[k].day=0;
	}
}
int query1(int k,ll v){//查询左端点
	if(tree[k].l==tree[k].r)return tree[k].sum>=v?tree[k].l:n+1;
	pushdown(k);
	if(tree[ls(k)].maxn>=v)return query1(ls(k),v);
	else return query1(rs(k),v);
}
ll query2(int k,int ql,int qr,ll v){//查询答案
	ll res=0;
	if(ql>qr)return 0;
	if(ql<=tree[k].l&&tree[k].r<=qr){
		ll tmp=tree[k].sum;
		cut(k,tree[k].l,tree[k].r,v);
		return tmp-tree[k].sum;//原来的区间和减去后来的区间和
	}
	int mid=(tree[k].l+tree[k].r)/2;
	if(ql<=mid)res+=query2(ls(k),ql,qr,v);
	if(mid<qr)res+=query2(rs(k),ql,qr,v);
	pushup(k);
	return res;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
	build(1,1,n);
	while(m--){
		d=read(),b=read();
		grow(1,1,n,d-last);
		last=d;
		printf("%lld\n",query2(1,query1(1,b),n,b));
	}
	return 0;
}
```
线段树的题只要想到方法，代码虽长，但写起来也不是难事。感谢观看！

---

## 作者：辰星凌 (赞：3)

# **【题解】Siano [PA2015] [Bzoj4293] / Chika 的烦恼**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12574070.html)

传送门：[$\text{Siano [PA2015]}$](https://www.luogu.com.cn/problem/P5579) [$\text{[Bzoj4293]}$](https://oi-archive.memset0.cn/problem/bzoj/4293) [$\text{ / Chika 的烦恼}$](https://www.luogu.com.cn/problem/P5579)

## **【分析】**

看完题目第一感觉是超哥线段树，但仔细一想发现了个奇妙的性质：由于每次割草只会砍掉最高的那部分，所以生长速度快的草永远都不会比速度慢的矮（顶多一样高）。

可以对速度排个序，那么每次操作的部分一定是一个连续的区间，上线段树即可。

每个区间维护高度和 $S$、高度覆盖标记 $tag$、时间增量标记 $add$ 、区间最大高度 $AR$（即最右边的草的高度），对于一次操作 $x_i,y_i$ 在线段树上二分找到第一个大于等于 $x_i$ 的位置 $pos$，然后将 $[pos,n]$ 全部覆盖为 $y_i$，顺便在覆盖的同时计算改变量即为答案。

注意一些实现上的细节：

$pushdown$ 时优先下放覆盖标记。

区间被覆盖后要清空 $add$ 。

有可能找不到大于等于 $x_i$ 的位置（全部都小于 $x_i$），这时要特判。

开 $\text{long long}$ 。

## **【Code】**

```cpp
#include<algorithm>
#include<cstdio>
#define LL long long
#define Re register int
using namespace std;
const int N=5e5+3;
int n,T,V[N];LL x,y,SV[N];
template<typename T>inline void in(T &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
struct Sakura2{
    struct Segment_Tree{
        #define pl (p<<1)
        #define pr (p<<1|1)
        #define mid ((L+R)>>1)
        struct QAQ{LL S,AR,add,tag;}tr[N<<2];
        inline void build(Re p,Re L,Re R){
            tr[p].tag=-1;
            if(L==R)return;
            build(pl,L,mid),build(pr,mid+1,R);
        }
        inline void pushup(Re p){
            tr[p].S=tr[pl].S+tr[pr].S,tr[p].AR=tr[pr].AR;
        }
        inline void updata1(Re p,Re L,Re R,LL v){
            tr[p].tag=v,tr[p].S=(LL)(R-L+1)*v,tr[p].AR=v,tr[p].add=0;
        }
        inline void updata2(Re p,Re L,Re R,LL v){
            tr[p].add+=v,tr[p].S+=(LL)(SV[R]-SV[L-1])*v,tr[p].AR+=(LL)V[R]*v;
        }
        inline void pushdown(Re p,Re L,Re R){
            if(tr[p].tag!=-1)updata1(pl,L,mid,tr[p].tag),updata1(pr,mid+1,R,tr[p].tag),tr[p].tag=-1;
            if(tr[p].add)updata2(pl,L,mid,tr[p].add),updata2(pr,mid+1,R,tr[p].add),tr[p].add=0;
        }
        inline int find(Re p,Re L,Re R,LL v){
            if(L==R)return tr[p].S<v?n+1:L;
            pushdown(p,L,R);
            if(tr[pl].AR>=v)return find(pl,L,mid,v);
            else return find(pr,mid+1,R,v);
        }
        inline LL change(Re p,Re L,Re R,Re l,Re r,LL v){
            if(l>r)return 0;
            if(l<=L&&R<=r){LL tmp=tr[p].S;updata1(p,L,R,v);return tmp-tr[p].S;}
            LL ans=0;pushdown(p,L,R);
            if(l<=mid)ans+=change(pl,L,mid,l,r,v);
            if(r>mid)ans+=change(pr,mid+1,R,l,r,v);
            pushup(p);return ans;
        }
    }TR;
    inline void sakura(){
        sort(V+1,V+n+1);
        for(Re i=1;i<=n;++i)SV[i]=SV[i-1]+V[i];
        LL nowT=0;TR.build(1,1,n);
        while(T--){
            in(x),in(y),TR.updata2(1,1,n,x-nowT),nowT=x;
            printf("%lld\n",TR.change(1,1,n,TR.find(1,1,n,y),n,y));
        }
    }
}T2;
int main(){
//    freopen("grass.in","r",stdin);
//    freopen("grass.out","w",stdout);
    in(n),in(T);
    for(Re i=1;i<=n;++i)in(V[i]);
    T2.sakura();
}
```


---

## 作者：hellohhy (赞：1)

* 比较复杂的线段树，需要维护的东西比较多，首先 $\text{val}$ 是生长速度， $\text{sum}$ 为现在草的长度， $\text{lazd}$ 是上一次打标记时间， $\text{ld}$ 是上一次割草的时间,  $\text{maxx}$ 记录最大值， $\text{minn}$ 记录最小值。
* 如果区间最大值都小于割草的长度$\text{b}$，那么直接 `return 0`，如果最小值都大于割草的长度 $\text{b}$ ，那么直接割掉这个区间就行了，  如果不满足上述两种情况，就继续递归。
* 其中 $\text{ld != lazd}$ 是因为可能由于最大值小于割草的长度 $\text{b}$ 时，是不用割的，此时 $\text{lazd}$ 不会更新，但是 $\text{ld}$ 需要更新。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define print(x) cerr << #x << " : " << x << endl;
#define int long long
inline int read() {
		int k = 0, f = 1; char ch = getchar();
		for (; !isdigit(ch); ch = getchar()) if(ch == '-') f = -1;
		for (; isdigit(ch); ch = getchar()) k = k * 10 + ch - '0';
		return k * f;
}
const int maxn = 2e6 + 100;
int a[maxn], w[maxn];
struct tree { int l, r, val, sum, laz, siz, lazd, ld, maxx, minn; } t[maxn];
// ld 上一次割草时间， lazd 上一次打标记时间;
// ld != lazd 是因为如果 t[rt].maxx <= b 此时， ld更新， lazd不会更新。
#define ls (rt << 1)
#define rs (rt << 1 | 1)
#define tl t[rt].l
#define tr t[rt].r
void pushup(int rt) {
		t[rt].sum = t[ls].sum + t[rs].sum;
		t[rt].minn = min(t[ls].minn, t[rs].minn);
		t[rt].maxx = max(t[rs].maxx, t[ls].maxx);   
}
void build(int rt, int l, int r) {
		t[rt].l = l, t[rt].r = r, t[rt].siz = r - l + 1, t[rt].laz = -1;
		if (l == r) return t[rt].val = a[l], void();
		int mid = (l + r) >> 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
		t[rt].val = t[ls].val + t[rs].val;
}
void Print(int rt, int l, int r) {
		cout << rt << " " << t[rt].lazd << " " << t[rt].ld << endl;;
		if (l == r) return;
		int mid = (l + r) >> 1;
		Print(ls, l, mid);
		Print(rs, mid + 1, r);
}
void pushdown(int rt) {
		int k = t[rt].laz;
		if (k != -1) {
				t[ls].sum = k * t[ls].siz;
				t[rs].sum = k * t[rs].siz;
				t[ls].minn = t[ls].maxx = t[rs].minn = t[rs].maxx = k;
				t[ls].lazd = t[rs].lazd = t[rt].lazd;
				t[ls].ld = t[rs].ld = t[rt].lazd;
				t[ls].laz = t[rs].laz = t[rt].laz;
		}
		t[rt].laz = -1; 
}
int ask(int rt, int d, int b) {
		int ans = 0;
		t[rt].sum += (d - t[rt].ld) * t[rt].val;
		//  print(tl)
		t[rt].minn += a[tl] * (d - t[rt].ld);
		t[rt].maxx += a[tr] * (d - t[rt].ld);
		t[rt].ld = d;
		//  cout << rt << " " << t[rt].sum << " " << t[rt].maxx << " " <<t[rt].laz << " "  << t[rt].lazd << " " << t[rt].siz << endl;   
		if(t[rt].maxx <= b) return 0;
		if(t[rt].minn > b) {
				t[rt].laz = b;
				t[rt].lazd = t[rt].ld = d;
				ans = t[rt].sum - b * (tr - tl + 1);
				t[rt].sum = b * (tr - tl + 1);
				t[rt].maxx = t[rt].minn = b;		
				return ans;
		}
		pushdown(rt);
		int mid = (tl + tr) >> 1;
		ans = ask(ls, d, b) + ask(rs, d, b);
		pushup(rt);
		return ans;
}
signed main() {
		int n = read(), m = read();
		for (int i = 1; i <= n; i++) a[i] = read();
		sort(a + 1, a + n + 1);
		build(1, 1, n);
		int ans = 0;
		for(int i = 1;i <= m;++i){
				int d = read(), b = read();
				ans = ask(1, d, b);
				printf("%lld\n",ans);
		}
		return 0;
}
```

---

## 作者：tyler178 (赞：1)

把草按 $a_i$ 从小到大排序，可以发现任何时候高度都是从左到右单调不下降的。因此每次割草的范围就是一个后缀。那么大致思路就是用线段树维护关于草的高度的一些信息，每次割草时利用维护的信息二分出被割的后缀、求出割草的总量、模拟出割草的影响。

我太懒了就写了一个二分 + 求和 + 修改三合一。

具体来说，维护 4 个信息：$asum$ 表示区间中 $a$ 的和、$lst$ 表示区间右端点最后一次被割到的时刻、$lstsum$ 表示区间中所有草在 $lst$ 时刻的高度之和、$tag$ 表示区间整体修改的标记。

在二分的过程中，先求出左子树的右端点在 $d_i$ 时刻的高度，若 $\leq b_i$ 说明割草的后缀都在右子树中，递归进入右子树即可；否则右子树都要割，利用维护的信息求出贡献并打上修改标记，然后递归进入左子树。最后还要上推维护信息。具体看代码吧。
```cpp
#include <bits/stdc++.h>
#define mset(a, b) memset(a, b, sizeof(a))
#define mcpy(a, b) memcpy(a, b, sizeof(a))
#define lc (rt<<1)
#define rc (rt<<1)|1
using namespace std;
typedef long long LL;
const int MAXN = 500005;

template <typename T> inline void read(T &AKNOI) {
	T x = 0, flag = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') flag = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	AKNOI = flag * x;
}

int n, m, a[MAXN];
LL b[MAXN], d[MAXN];
int len[MAXN << 2], tag[MAXN << 2], lst[MAXN << 2];
LL asum[MAXN << 2], lstsum[MAXN << 2];

inline void puttag(int rt, int tg) {
	tag[rt] = lst[rt] = tg;
	lstsum[rt] = b[tg] * len[rt];
}

inline void pushdown(int rt) {
	if (tag[rt]) {
		puttag(lc, tag[rt]);
		puttag(rc, tag[rt]);
		tag[rt] = 0;
	}
}

inline void pushup(int rt) {
	lst[rt] = lst[rc];
	lstsum[rt] = lstsum[lc] + lstsum[rc] + 
		(d[lst[rt]] - d[lst[lc]]) * asum[lc];
}

void Build(int rt, int l, int r) {
	len[rt] = r - l + 1;
	if (l == r) {
		asum[rt] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	Build(lc, l, mid);
	Build(rc, mid + 1, r);
	asum[rt] = asum[lc] + asum[rc];
}

LL Query(int rt, int l, int r, int i) {
	if (l == r) {
		LL val = lstsum[rt] + (d[i] - d[lst[rt]]) * a[l];
		if (val <= b[i]) return 0;
		puttag(rt, i);
		return val - b[i];
	}
	int mid = (l + r) >> 1;
	pushdown(rt);
	LL val = b[lst[lc]] + (d[i] - d[lst[lc]]) * a[mid], ret = 0;
	if (val <= b[i]) {
		ret = Query(rc, mid + 1, r, i);
	} else {
		ret = lstsum[rc] + (d[i] - d[lst[rc]]) * asum[rc] - b[i] * len[rc];
		puttag(rc, i);
		ret += Query(lc, l, mid, i);
	}
	pushup(rt);
	return ret;
}

void init() {
	read(n); read(m);
	for (int i = 1; i <= n; ++i) {
		read(a[i]); 
	}
	sort(a + 1, a + n + 1);
	Build(1, 1, n);
}

void solve() {
	for (int i = 1; i <= m; ++i) {
		read(d[i]); read(b[i]); 
		printf("%lld\n", Query(1, 1, n, i));
	}
}

int main() {
	init();
	solve();
	return 0;
}
```


---

## 作者：Crzy (赞：0)

比较深刻但是并不难写的线段树题，加深了一些线段树的基础理解。

感受一下，大概需要的操作是给所有高度都加若干 $a_i$，区间推平，查询多出来的高度的和，前面两个维护一点信息和 `lazytag` 随便做。查询比较麻烦，考虑按 $a_i$ 排序后那查询都是一段后缀，自然想到线段树二分，对于一个节点，记录最高的高度，在线段树二分的同时进行 `cover` 的打标记，对于没有递归下去的儿子，直接用打标记前的值减去打标记后的值就是多出来的高度。

具体实现来说，记录一个节点对应区间 $a_i$ 的和，结合 `lazytag` 即可做整体加若干 $a_i$ 的操作。其他小细节可以看下代码。~~实际上也没什么细节。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define test cerr << "test\n"
#define print(x) cout << #x << " = " << x << endl
#define file(name) freopen(name".in", "r", stdin), freopen(name".out", "w", stdout);

const int N = 5e5 + 5;
int n, Q, a[N];
struct Seg { int l, r, sa, ss, mx, a, c; } s[N << 2];
#define ls (pos << 1)
#define rs (pos << 1 | 1)
#define mid ((s[pos].l + s[pos].r) >> 1)
void pushup(int pos) {
    s[pos].sa = s[ls].sa + s[rs].sa;
    s[pos].ss = s[ls].ss + s[rs].ss;
    s[pos].mx = max(s[ls].mx, s[rs].mx);
}
void cov(int pos, int c) { s[pos].ss = (s[pos].r - s[pos].l + 1) * c, s[pos].mx = s[pos].c = c; s[pos].a = 0; }
void add(int pos, int a) { s[pos].ss += s[pos].sa * a, s[pos].mx += ::a[s[pos].r] * a; s[pos].a += a; }
void pushdown(int pos) {
    if (s[pos].c != -1) cov(ls, s[pos].c), cov(rs, s[pos].c), s[pos].c = -1;
    if (s[pos].a) add(ls, s[pos].a), add(rs, s[pos].a), s[pos].a = 0;
}
void build(int l, int r, int pos = 1) {
    s[pos].l = l, s[pos].r = r, s[pos].c = -1; if (l == r) return s[pos].sa = a[mid], void();
    build(l, mid, ls); build(mid + 1, r, rs); pushup(pos);
}
int modify(int pos, int k) { int t = s[pos].ss; cov(pos, k); return t - s[pos].ss; }
int query(int k, int pos = 1) {
    if (s[pos].mx < k) return 0; if (s[pos].l == s[pos].r) return modify(pos, k); pushdown(pos);
    int ans = s[ls].mx >= k ? query(k, ls) + modify(rs, k) : query(k, rs); pushup(pos); return ans;
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    cin >> n >> Q; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1);  build(1, n);
    for (int x, y, xx = 0; Q--; ) cin >> x >> y, add(1, x - xx), cout << query(y) << '\n', xx = x;
    return 0;
}
```

---


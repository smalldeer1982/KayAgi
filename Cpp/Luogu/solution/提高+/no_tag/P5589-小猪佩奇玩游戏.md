# 小猪佩奇玩游戏

## 题目描述

佩奇和乔治玩游♂戏。

佩奇在黑板上写下数字 $\{1,2,\cdots,n\}$ ，每次他们会等概率地报出黑板上的一个数字 $x$ ,并删除所有 $x$ 的正整数次幂。

形式化地,给定数列 $\{1,2,\cdots,n\}$ ，每次等概率选出数列中存在的 $1$ 个数字 $x$ ，并将形如 $\{x^k,k \in Z^{+}\}$ 的数字删除。

他们玩了整整一个下午，游戏还是没有结束，所以他们想知道，该游戏期望在多少轮后会结束。

如果你的答案与正确答案的绝对误差在 $10^{-4} $以内，则被判定为正确。

## 说明/提示

对于 $n=4$，

若删除的顺序为 $\{1,2,3\},\{3,2,1\}$, 那么概率为$\frac{1}{4} \times \frac{1}{3} \times \frac{1}{1}=\frac{1}{12}$

若删除的顺序为 $\{1,3,2\},\{3,1,2\}$, 那么概率为$\frac{1}{4} \times \frac{1}{3} \times \frac{1}{2}=\frac{1}{24}$

若删除的顺序为 $\{2,1,3\},\{2,3,1\}$, 那么概率为$\frac{1}{4} \times \frac{1}{2} \times \frac{1}{1}=\frac{1}{8}$

对于剩余的 $12$ 种删除了 $4$ 次的序列，概率为$\frac{1}{4} \times \frac{1}{3} \times \frac{1}{2} \times \frac{1}{1}=\frac{1}{24}$

容易发现答案即为
$\frac{2 \times 3}{12} + \frac{2 \times 3}{24}+\frac{2 \times 3}{8} + \frac{12 \times 4}{24}=\frac{7}{2}=3.50000$

### 数据范围

对于 $20\%$ 的数据, $n \leq 10$

对于 $60\%$ 的数据, $n \leq 10^5$

对于 $100\%$ 的数据, $n \leq 10^9,t \leq 100$

### 出题人善意的提醒

对于 C++ 选手，若对于正整数 $n,k$，希望得到 $\sqrt[k] n$，请尽量不要使用 C++ 自带的 $\operatorname{pow}$ 函数，以免可能产生不必要的精度误差。

## 样例 #1

### 输入

```
5
4
8
16
32
100```

### 输出

```
3.50000000
7.00000000
13.83333333
28.33333333
93.41666667```

# 题解

## 作者：Soulist (赞：15)

放一篇不太一样的题解（~~大雾~~

首先考虑将题目转化成图论模型，让 $i$ 向 $i^k$ 连一条边，然后可以发现这样会连出来很多张独立的图，容易发现每张图的贡献独立，所以加起来即可

然后会发现这些图都长一个样

不妨设当前被考虑到的点为 $x$，那么此时图中应该有$x^2,x^3,x^4,...x^k$

然后会发现这些图对于答案的贡献之和此图的大小有关，而图的大小又是$\log$级的

于是问题转化为给定一个大小为$x(x\le 30)$的图，每次可以随机删掉一个数和其倍数，求删完的期望次数。

就会想到写个状压去算某一张图的贡献...

当然状压的确是可以将答案算出来的，但是复杂度是$O(2^{30})$而且空间开销相同所以本机是完全跑不出来的...(至少我这里是

于是就会想到真的需要的$dp$值只有$dp[1_2],dp[11_2],dp[111_2]...dp[111111...111_2]$

然而这些状态实际上依赖的状态存在大量相同而且真正有效的$dp$不多所以可以用一个$\rm map$将有效的$dp$存下来

但是这样还是很慢

所以就会想到要打表

提前用$dp$将图的大小为$x$的时候的期望算出来，然后枚举一个数$x$计算出图的大小并将被用到的点标记，单次复杂度$O(n)$

但是实际上对于某一个$x$如果$x>\sqrt n$且不存在一个$i$满足$i^k=x$那么显然 $x$ 对于答案的贡献为$1$

于是真正要计算的点就只有$1-\sqrt n$的这些数

复杂度大约是$O(T\sqrt n)$

然后要特判$1$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register 
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 35000 ; 
const int M = 35 ;
double Ans[M] = { 0, 1.0, 1.5, 2.0, 2.33333333333333, 2.83333333333333, 3.08333333333333,
3.5833333333333, 3.8333333333333, 4.16666666666667, 4.4166666666667, 4.91666666666667, 5.08333333333333, 5.58333333333333,
5.8333333333333, 6.0833333333333, 6.28333333333333, 6.7833333333333, 6.95, 7.45, 7.61666666667, 
7.8666666666667, 8.11666666666667, 8.6166666666667, 8.741666666667, 9.075, 9.325, 9.575, 9.741666666667,
10.2416666666667, 10.3666666666667 };
int n, vis[N], rU ;  
signed main()
{
	int T = gi() ;
	while( T-- ) {
		n = gi() ; int cnt = sqrt(n), k = 0, j ;
		if( cnt * cnt <= n ) ++ cnt ; 
		double ans = 1 ; rU = n - cnt ;
		memset( vis, 0, sizeof(vis) ) ;
		rep( i, 2, cnt ) {
			if( vis[i] ) continue ; 
			for( j = i, k = 0; j <= n; j *= i, ++ k ) {
				if( j > cnt ) -- rU ; 
				else vis[j] = 1 ; 
			} ans += Ans[k] ; 
		} 
		if( cnt <= n ) printf("%.8lf\n", ans + rU ) ;
		else printf("%.8lf\n", ans ) ;
	} 
	return 0 ;
}
```

打表程序：

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int M = 35 ; 
double Ans[M] ; 
int m ; 
int get( int x ) {
	int ans = 0 ; 
	while( x ) ans += ( x & 1 ), x >>= 1 ;
	return ans ; 
}
map<int, double> dp ;
double Dp( int i ) {
	if( dp[i] || i == 0 ) return dp[i] ; 
	int len = get(i) ;
	for( re int j = 1; j <= m; ++ j ) {
		if( ( 1 << ( j - 1 ) ) & i ) {
			int rk = 0 ;
			for( re int k = j; k <= m; k += j ) {
				if( ( 1 << ( k - 1 ) ) & i ) rk |= ( 1 << ( k - 1 ) ) ;
			}
			dp[i] = ( dp[i] + ( 1.0 / len ) * ( 1.0 + Dp(i ^ rk) ) ) ;
		}
	}
}
signed main()
{
	
	m = 30 ; int maxn = ( 1 << m ) - 1, rnt = 1 ; 
	printf("%d\n", m ) ;
	for( re int rnt = 1; rnt <= m; ++ rnt ) {
		printf("%d %.8lf\n", rnt, Dp( ( 1 << rnt ) - 1 ) ) ; 
	}
	return 0 ;
}

```

---

## 作者：米奇奇米 (赞：12)

## 题解-小猪佩奇玩游戏

***
	
 **一道似乎用$map$水过的题目,然而比赛却只有$60ptc$还是太菜了。**
    
***

* $step1$ 

	反正我是手模$[1,10]$的答案。然后发现大多数数的贡献都是$1$少数是$1/2$。但是看看样例怎么会有$13.83333333$这些神奇的小数。于是大胆猜想是不是与这个数$x$等于多少个$n^{k}(k∈N^{+},2\leq k)$，于是就有了$60ptc$的好成绩

```cpp
#include <bits/stdc++.h>
using namespace std;
map<int,int>ma;
double ans[1000005];
inline int ksm(int a,int b) {
	int ret=1;
	while(b) {
		if(b&1) ret=ret*a;
		a=a*a;
		b>>=1;
	}
	return ret;
}
int main() {
	int T;
	for ( int i=2;i<=100;i++ ) 
		for ( int j=2;j<=40;j++ ) {
			int s=ksm(i,j);
			if(s>100000||s<0) break;
			ma[s]+=1;
		}
	ans[1]=1;
	for ( int i=2;i<=100000;i++ ) 
		ans[i]=ans[i-1]+(1/(1.0*(ma[i]+1)));//预处理答案
	scanf("%d",&T);
	for ( int i=1;i<=T;i++ ) {
		int x;
		scanf("%d",&x);
		printf("%.8lf\n",ans[x]);
	}
	return 0;
}
			 
```

* $step2$

	比赛比完我听$ldl$巨佬说他的暴力倒着写就是正解$qwq$
    
    其实现在的方法更简单。先用$map$存储$n^k$数然后遍历$map$就可以了。最后再加上某些为$1$贡献的数就可以了。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

 int n,T;
map<int,int> ma;

  signed main() {
      scanf("%lld",&T);
      while(T--) {
          scanf("%lld",&n);
          ma.clear();
          for ( int i=2;i*i<=n;i++ ) 
              for ( int j=i*i;j<=n;j*=i ) ma[j]++;
          double ans=0;
          ans=n-ma.size();
          for ( auto i:ma ) ans+=1.0/(i.second+1);
          printf("%.8lf\n",ans);
      }
      return 0;
  }
```



---

## 作者：Froggy (赞：10)

~~发个...~~

### 前言:

考场上没做出来QAQ,还是太菜(只弄了60pts)

考后有大佬给我指点迷津,我才自己敲出来

### 思路:

先暴搜出 $n \le 10$的解,再结合样例找一波规律(大佬可以跳过这一步)

发现:在大多情况下, $ans_i=ans_{i-1}+1$

不过,

$ans_4=ans_{3}+ \frac{1}{2}$

$ans_8=ans_{7}+ \frac{1}{2}$

$ans_9=ans_{8}+ \frac{1}{2}$

$ans_{16}=ans_{15}+\frac{1}{3}$

...

发现规律了么?

$i$的贡献是$ \frac{1}{d_{i}} $

$d_{i}$表示所有删除时可以删除i的数的数量

现在有了一个60pts的做法!

#### 口糊证明:

根据**概率的可加性**,新添加一个数$i$如果会被$d_{i}$个数删除的时候顺便删除,那把$i$再花一轮删去的期望为$ \frac{1}{d_{i}} $

~~(废话,这不就等于没说)~~

### 满分做法:

在60pts做法上发现,大部分 $d_{i}==1$,所以只要找$d_{i}$不是1的就行了

其实还不到35000个数

用一个vector存所有$d_{i}$不是1的数

把这些不是1的数再按$d_{i}$分组放进另一个vector数组(就是代码里的p)里

询问的时候直接在每个vector数组里二分查找就好了(详细看代码)

### 代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm> 
#include<vector>
using namespace std;
#define N 1000000001
typedef long long ll;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,T;
vector<int> vec;
vector<int> p[200];
int main(){
	for(int i=2;i<=40000;i++){
		for(ll j=1LL*i*i;j<=N;j*=i){
			vec.push_back(j);
		}
	}
	sort(vec.begin(),vec.end());
	int las=-1,cnt=0;
	for(int i=0;i<vec.size();i++){
		if(vec[i]!=las&&las!=-1){
			p[cnt].push_back(las);//加到p数组里
			cnt=0;
		}
		cnt++;
		las=vec[i];
	}
	T=read();
	while(T--){
		n=read();
		int tot=0;//tot记录小于n且di不等于1的数的个数
		double ans=0;
		for(int i=1;i<=10;i++){
			int tmp=lower_bound(p[i].begin(),p[i].end(),n+1)-p[i].begin();//二分找第一个大于n的数的位置(其实是要找第一个小于等于n的数,vector下标从0开始,自带-1,所以只用找第一个大于n的数的位置)-->注:位置就是小于n的数的个数
			ans+=tmp*1.0/(i+1);//加上贡献
			tot+=tmp;
		}
		ans+=1.0*(n-tot);//别忘了最后加上di==1的数的个数
		printf("%.6lf\n",ans);
	}
	return 0;
}
```

时间复杂度:(不太清楚),应该是 $O(\sqrt{n} \times log{n}+T \times log{n})$

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!

---

## 作者：xwh_hh (赞：7)

注：在专栏食用更佳。本题解中记 $d(u)$ 为 $u$ 的因数个数。  
不难想到将 $\{1,2,\dots,n\}$ 按幂底数分组，这里举个例子（$n=10$）：
- $\{1\}$
- $\{2,4,8\}$
- $\{3,9\}$
- $\{5\}$
- $\{6\}$
- $\{7\}$
- $\{10\}$

共 $7$ 组，只有组内数据会相互干扰，组际间无影响，直接将期望相加即可。  

对于每组内，我们可以抽象成这样的问题：  
问题 $2$：对于集合 $S=\{1,2,\dots,m\}$，每次等概率随机选 $x\in S$，删除 $S$ 中所有 $x$ 的倍数，求选数次数的期望（$m\le 29$）。

这个问题固然可以直接打表跑状压（毕竟 $m$ 很小），但是假如把此题 $n$ 改到 $10^{18}$ 就做不了了，有没有更优雅的做法？

我们发现一个性质：其实可以直接枚举排列，然后将重复删的数剔除，依旧可以做到等概率，举个例子（$n=6$）：  
对于一种合法选数序列 $\{2,3,1\}$（概率为 $\frac{1}{6}\times\frac{1}{3}\times\frac{1}{2}=\frac{1}{36}$），枚举排列会涉及[这 $20$ 种情况](https://www.luogu.com.cn/paste/e620v5z6)。

恰好 $\frac{20}{6!}=\frac{1}{36}$。  
计算方法：
![](https://cdn.luogu.com.cn/upload/image_hosting/3goga0yh.png)  
这里给出一种证明：  
假设选数数列为 $\{b_1,b_2,\dots,b_k\}$，每次操作前剩余数的个数分别为 $c_1,c_2,\dots,c_k$（记 $c_{k+1}=0$）。  
由题意，出现概率为 $\frac1{\prod_{i=1}^kc_i}$。  
按照枚举排列的思路（记集合 $T=\{c_1,c_2,\dots,c_k\}$），概率为：
$$\frac{\prod_{i=1}^k\prod_{j=c_{i+1}+1}^{c_i-1}j}{m!}=\frac{\prod_{i\notin T}i}{m!}=\frac1{\prod_{i=1}^kc_i}$$
得证！

那么，我们可以考虑递推，记 $f_i$ 表示问题 $2$ 当 $m=i$ 时的期望。  
我们知道，要想让一个长度为 $m$ 的排列中 $m$ 产生贡献，就必须让 $m$ 出现在它的任意一个非本身因数之前，这个概率为 $\frac1{d(m)}$，自然，对期望的贡献也是 $\frac1{d(m)}$，所以，我们得到了递推式与通项式：
$$f_m=f_{m-1}+\frac1{d(m)}=\sum_{i=1}^m\frac1{d(i)}$$
后面的实现就不难了，这里不再赘述，如果不懂，可参照代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double f[35];
long long pw(long long a,long long b){
	long long res=1;
	while(b--) res*=a;
	return res;
}
bool vis[40005];
set<long long>ds;
long long d[40005],m;//记录本来就是某些数的幂的数，如4，8，9 
void init(){//分组时注意一些本来就是某些数的幂的数，如4，8，9 
	for(long long i=2;i<=31700;i++){
		for(long long j=i*i;j<=1000000000;j*=i){
			ds.insert(j);
		}
	}
	m=0;
	for(auto u:ds) d[++m]=u;
}
double solve(long long n){
	double ans=0;
	long long pos=30;
	memset(vis,0,sizeof(vis));
	for(long long i=1;i*i<=n;i++){//sqrt(n)以内直接暴力求解 
		if(i==1) ans+=1;//注意特判，不然会死 
		else{
			while(pw(i,pos)>n) pos--;
			ans+=f[pos];
		}
		if((i+1)*(i+1)>n) ans+=n-i;//超过sqrt(n)的数贡献均为f[1]=1 
	}
	pos=15;
	for(long long i=1;i<=m&&d[i]<=n;i++){
		while(pw(d[i],pos)>n) pos--;
		ans-=f[pos];
	}
	return ans;
}
signed main(){
	for(int i=1;i<=30;i++){//这是递推式写法 
		int u=0;
		for(int j=1;j<=i;j++){
			if(i%j==0) u++;
		}
		f[i]=f[i-1]+1.0/u;
	}
	init();
	long long t;
	cin>>t;
	while(t--){
		long long n;
		cin>>n;
		cout<<fixed<<setprecision(7)<<solve(n)<<'\n';
	}
	return 0;
}
```
其实可以更快，鉴于本题数据过小，就没使用了。  
期待本题的加强版！

---

## 作者：Owen_codeisking (赞：6)

如果不出到第一题的位置，$n\le 10^{18}$ 也可以。所以 $\sqrt{n}$ 的做法不是最优的。

首先若一个数 $i$ 在 $1\sim n$ 中出现了 $i,i^2,...,i^k$，那么它的贡献是 $\sum_{t=1}^{k} \Large \frac 1{d(t)}$。这个大家都知道。

然后考虑有几个数作为 $i$ 出现了 $k$ 次。显然有一个范围，$n^{\frac 1{k+1}}\sim n^{\frac 1k}$。这个东西你不用 $\text{pow}$ 的话可以二分+验证两个 $\log$ 做。

然后那些作为 $i$ 的数在质因数分解的时候有奇数次幂。一个范围内算的话，可以用莫比乌斯函数容斥一下，同样用刚才的方法算 $n^{\frac 1k}$。或者可以倒着减掉倍数的答案。

可能记忆化一下快一些，不过我写了四个 $\log$ 的。时间复杂度 $O(T\log^4 n)$。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=105;
int n,d[maxn],pri[maxn>>2],mu[maxn],tot;
bool vis[maxn];
double f[maxn];
inline void sieve(int n)
{
	mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i]) pri[++tot]=i,mu[i]=-1;
		for(int j=1;j<=tot&&i*pri[j]<=n;j++)
		{
			vis[i*pri[j]]=1;
			if(i%pri[j]==0) break;
			mu[i*pri[j]]=-mu[i];
		}
	}
}
inline bool check(int s,int t,int n)
{
	ll ans=s;
	for(;t;t--,ans=ans*s)
		if(ans>(ll)n) return true;
	return false;
}
inline int get(int i,int n)
{
	int l=2,r=n,mid,ans=0;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid,i,n)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	return ans;
}
inline int solve(int n)
{
	int ans=n;
	for(int i=2;;i++)
	{
		if(!mu[i]) continue;
		int t=get(i,n);
		if(t<=2) break;
		ans+=mu[i]*(t-2);
	}
	return ans;
}
int main()
{
	sieve(100);
	for(int i=1;i<=30;i++)
		for(int j=1;j<=i;j++)
			if(i%j==0) d[i]++;
	for(int i=1;i<=30;i++) f[i]=f[i-1]+1.0/d[i];
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		double ans=1;
		for(int i=1,r=n,l=0;r>1;r=l-1,i++)
		{
			l=get(i+1,n);
			ans+=(solve(r)-solve(l-1))*f[i];
		}
		printf("%.10lf\n",ans);
	}
	return 0;
}
```

---

## 作者：clamee (赞：3)

今天月赛做了这道题，还是挺简单的。

首先，我们可以发现，数值i的贡献就是

（1/数组中是它的整数次根的个数）。

我们就可以用以下玄学的式子求出答案（~~其实是我太弱了不会描述~~）
```

    for(int i=2;i<=n;i++)
	{
		ans+=1.0/(have[i]+1);
		for(int j=i;j<=n;j*=i)
			have[j]++;
	}
```
这样裸求，就有60分了。

然后我们考虑优化，我们发现其实对答案贡献不为1的点是很少的，于是我们可以只计算对答案贡献不为1的点，并记个map统计答案
于是有了第一份代码
```#include<bits/stdc++.h>
using namespace std;
int n,tt,d[55],a[100005],now,la;double ans,k=1;
inline int read()
{
    int t=1,re=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){re=re*10+ch-48;ch=getchar();}
    return re*t;
}
signed main()
{
    tt=read();
    while(tt--)
    {
        n=read();
		map<long long,int>  have;
		if(n<=3)
		{printf("%d.00000000\n",n);continue;};
        ans=1;
		la=0;
        for(register int i=2;i*i<=n;i++)
	{
		now=i;
		ans+=1.0/(have[i]+1);
		for(register long long j=i;j<=n;j*=i)
		{
			if(!have[j]&&j>sqrt(n))a[++la]=j;
			have[j]++;
		}
	}
	sort(a+1,a+la+1);
	ans+=n-now;
	for(register int i=1;i<=la;i++)
		ans+=1.0/(have[a[i]]+1)-1;
        printf("%lf\n",ans);
    }
}
```
[但是](https://www.luogu.org/record/25130184)taTLE了，可见数据强度还是有的

然后，我发现，其实可以吧have数组给预处理出来，然后再计算贡献，就可以AC本题了。
```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int n,tt,d[55],a[100005],now,la;double ans,k=1;
inline int read()
{
    int t=1,re=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){re=re*10+ch-48;ch=getchar();}
    return re*t;
}
map<long long,int>  have;
signed main()
{
	tt=read();
	la=0;
	for(register int i=2;i*i<=1000000000;i++)
	{
		for(register long long j=i*i;j<=1000000000;j*=i)
		{
			if(!have[j])a[++la]=j;
			have[j]++;
		}
	}
	sort(a+1,a+la+1);
    while(tt--)
    {
        n=read();
		if(n<=3)
		{printf("%lld.00000000\n",n);continue;};
        ans=n;
		for(register int i=1;i<=la&&a[i]<=n;i++)
			ans+=1.0/(have[a[i]]+1)-1;
        printf("%lf\n",ans);
    }
}
```

比赛时看见一堆人用时比我短，应该是有更简洁的方法吧。

---

## 作者：LRL52 (赞：2)

推荐[原文阅读](https://www.luogu.org/blog/lrl/solution-p5589)

> $\Theta(T\log^2 n)$的解法，~~搞了我半个下午才弄出来~~

> 蒟蒻的我反复看了几遍视频讲解，并经过反复推敲，终于弄懂了$\log^2$的做法

> 以下题解主要是对$memset0$巨佬题解的补充说明，尤其是高能部分，这里重点讲解**具体如何计算大小为$i$的集合个数**，至于计算删除大小为$i$的集合的期望次数可以见其它题解，已经讲的很清楚了

- $\sqrt n$的做法，复杂度的瓶颈在于计算有**多少个大小为$i$的集合**

- **大小为$i$的集合应该是$\lfloor n^{\frac{1}{i} }\rfloor$个**，考虑集合中最小的数字$x$，那么$x^i \le n$, 则$x \le \lfloor n^{\frac{1}{i} }\rfloor$

- 由于$1^{\text{任意次方}} = 1$, 所以$1$提出来单独计算，故上面计算出的**个数还要再$-1 $**

- 表示我们可以把$2 \sim x$的数作为那些集合的**首项(集合中最小的元素)**, 例如$i = 2, x = 4$, 那么集合就有$\text{\{2, 4\}, \{3, 9\}, \{4, 16\}}$

- 但是我们发现，其实像$\{2, 4\}, \{4, 16\}$的集合**不一定是极大的**，它可能被包含在$\{2, 4, 8, 16\}$这样的集合中

- **不是极大的集合意味着它可以扩张到更大的集合，而且它不是独立的，与外部有连边**

- 为了**去除那些不合法的集合(不是极大的集合)**, 问题转化为如何计算**一个集合被更大的集合包含了多少次**，我们要从答案中**减掉**这些不合法的贡献 

- 对于一个确定的集合$S$，该集合的大小为$a$, 最小元素为$x$, 设较小集合的大小为$b$, 在较大集合中出现了$k$次($k$即是我们想求的)， 我们考虑**较小集合的首项(较小集合中最小的元素)** $y = x^k(y \in S)$， 例如$S = \{2, 4, 8, 16\}$，则$a = 4, x = 2$，当$b = 2$时，$y = 2, 4$

- 可知较小集合的最大元素是$y^b$, 并且由于$y^b \in S$, 则

$$y^b \le x^a$$

$$x^{kb} \le x^a$$

$$kb \le a$$ 

$$k \le \lfloor \frac{a}{b} \rfloor$$

- 不难发现$k$**这个值只和两个集合的大小有关**, 因此对于大小为$a$的较大集合, **设该集合有$tot$个**，那么对于大小为$b(b < a)$的较小集合, 它会在大小为$a$的集合中出现$tot \times \lfloor \frac{a}{b} \rfloor$个，这些贡献是不合法的，应该**减掉**

- 在实现程序中为了**避免重复减掉同样的贡献**，可以用**倒序循环实现**，具体见程序

- 这题毒瘤卡精度，$pow$会因为精度$WA \ \ 1$个点，可以使用二分 $+ $快速幂代替$pow$函数

> 以下程序可以处理$n \le 10^{18}$的数据，$d[i]$表示$i$的约数个数（使用线性筛实现，只是为了复习下）, $f[i]$和$g[i]$分别表示大小为$i$的集合的**个数**，和大小为$i$的集合的**期望删除次数**，其它数组是线性筛里面的

```cpp
//ID: LRL52  Date: 2019.10.16
#define rep(i, a, b) for(int i = (a); i <= (b); ++i)
#include<bits/stdc++.h>
using namespace std;
const int N = 1055, M = 2055; char ss[1 << 21], *A = ss, *B = ss, cc;
inline char gc(){return A == B && (B = (A = ss) + fread(ss, 1, 1 << 21, stdin), A == B) ? EOF : *A++;}
template<class T>inline void rd(T &x){
	int f = 1; x = 0, cc = gc(); while(cc < '0' || cc > '9'){if(cc == '-') f = -1; cc = gc();}
	while(cc >= '0' && cc <= '9'){x = x * 10 + (cc ^ 48); cc = gc();} x *= f;
}
#define int long long
#define double long double
int Pcnt, n;
int d[75], vm[75], prime[75], vm2[75], f[75], h[75];
double g[75], Res;

void Prework(){
	d[1] = 1;
	rep(i, 2, 65){
		if(!vm[i]){
			vm[i] = vm2[i] = i, prime[++Pcnt] = i;
			d[i] = 2;
		}
		rep(j, 1, Pcnt){
			if(prime[j] > vm[i] || prime[j] > 65 / i) break;
			int x = i * prime[j];
			vm[x] = prime[j];
			if(i % prime[j]){
				vm2[x] = prime[j];
				d[x] = d[i] * d[prime[j]];
			}
			else{
				vm2[x] = vm2[i] * prime[j];
				if(x == vm2[x]) d[x] = d[i] + 1;
				else d[x] = d[x / vm2[x]] * d[vm2[x]];
			}
		}
	}
	g[1] = 1.0;
	rep(i, 2, 65) g[i] = g[i - 1] + 1.0 / d[i];
}

int qp(int a, int k){
	int ret = 1; double _a = a;
	Res = 1.0;
	while(k){
		if(k & 1) ret = ret * a, Res = Res * _a;
		a = a * a;
		_a = _a * _a;
		k >>= 1;
	}
	return ret;
}

int calc(int n, int k){
	int l = 1, r = n;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(qp(mid, k) > n || Res > 1e18) r = mid - 1;
		else l = mid + 1;
	}
	return r;
}

#undef int
int main(){
#define int long long
	Prework();
	int Task; rd(Task);
	while(Task--){
		rd(n);
		if(n == 0){
			puts("0.00000000");
			continue;
		}
		double ans = 1.0;
		int up = n;
		rep(i, 1, n){
			//h[i] = pow(n, 1.0 / i);
			h[i] = calc(n, i); //calc n^(1/i)
			--h[i];
			if(h[i] == 0){
				up = i - 1;
				break;
			}
		}
		for(int i = up; i >= 1; --i){
			f[i] = h[i];
			rep(j, i + 1, up)
			    f[i] -= (j / i) * f[j];
		}
		rep(i, 1, up) ans += f[i] * g[i];
		printf("%.8Lf\n", ans);
	}
	return 0;
}
```

---

## 作者：Nemlit (赞：2)

这题还是比较妙妙~~套路~~的，复杂度为$O(log^2N)$，可以卡掉$\sqrt n$的做法

首先我们可以把原数列分成很多个集合，集合之间肯定是两两独立的，考虑分别计算答案

我们定义$f_i$为集合大小为i出现过多少次（集合大小最多为$logN$级别），$g_i$表示集合大小为i删除完的期望步数

那么答案是可以表示成$\sum_{i=1}^{log_N}{f_i*g_i}$

现在考虑怎么求出$f_i, g_i$

你可能会好奇题目下方的提示有什么用，没错他就是给你求$f_i$用的

考虑集合大小至少为i出现了多少次，记之为$p_i$，那么$p_k=n^{\frac{1}{k}}$

再考虑容斥，因为这个集合是有序集合，集合大小为$a$的集合出现在集合大小为$b$的集合中出现了$\frac{b}{a}$次

证明：假设一个集合开始元素是$x$，那么$x^{a*k}≤x^{b}$，即$a*k≤b$，即$k ≤ \frac{b}{a}$

由于f集合大小不大，我们暴力算就行了，这里复杂度为$O(log^2N)$（可能可以套一个整除分块优化至$O(logN*log \sqrt N)$，不太清楚怎么做）

然后考虑怎么就$g_i$~~（打表！）~~

对于每一个集合，我们只取他们的对数，于是问题就转化成给定一个排列，每次可以删除一个数及其倍数，求期望删除次数

发现对于每一个数，假设他的约数个数为$d_i$，那么他是可能被$d_i$个数删除的

考虑递推求出$g_i$，那么$g_i=g_{i-1}+\frac{1}{d_i}$（一个数会被$d_i$个数删完，只有$\frac{1}{d_i}$的概率需要多花费一次来删掉这个新加入的数）

那么我们就做完了，总体复杂度为$O(log^2N)$
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define rep(i, s, t) for(int i = s; i <= t; ++ i)
#define drep(i, s, t) for(int i = t; i >= s; -- i)
#define maxn 100005
int p[maxn], f[maxn], n, m;
double g[maxn], ans;
bool check(int a, int b, int n) {
    long long pax = a;
    for(; b; b --, pax = pax * a) if(pax > 1ll * n) return 1;
    return 0;
}
int get(int i, int n) {
    int l = 1, r = n, ans = n;
    while(l <= r) {
        int mid = (l + r) >> 1;
        if(check(mid, i, n)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }
    return ans - check(ans, i, n);
}
int d(int x) {
	int ans = 1;
	rep(i, 2, 30) {
		if(x % i) continue;
		int tot = 0;
		while(x % i == 0) ++ tot, x /= i;
		ans *= (tot + 1);
	}
	return ans;
}
void init() {
	g[1] = 1.0;
	rep(i, 2, 30) g[i] = g[i - 1] + 1.0 / d(i);
}
int main() {
	init(), scanf("%d", &m);
	while(m --) {
		scanf("%d", &n), ans = 1, p[31] = 1;
		rep(i, 1, 30) p[i] = get(i, n);
        rep(i, 1, 30) f[i] = p[i] - p[i + 1];
		drep(i, 1, 30) rep(j, 2, 30) f[i / j] -= f[i];
		rep(i, 1, 30) ans += g[i] * f[i];
		printf("%.10lf\n", ans);
	}
	return 0;
}
```

---

## 作者：Cesare (赞：2)

给出一种 $O(T\ log\ n)$ 做法。

$Update:$ 不需要使用 $Hash$ 或 $unordered\_map$ 也可以达到 $O(T\ log\ n)$ 的复杂度。

## $Solution$

首先可以考虑每个数对于答案的贡献，即删除这个数的概率乘删除他的代价，也就是概率。

那么我们可以考虑先预处理 $1 \to \sqrt n$ 的 $i^k$ 指向的数字，即一个数字被多少数字算到。

可以发现贡献不为 $1$ 的数字只有 $\sqrt n$ 级别，那么我们用一个 $vector$ 去记录， $map$ 存储每个 $vector$ 内的数字的被筛次数，预处理好关于这些数字的前缀和数组，然后在查询的时候二分一下就好了。

使用 $Hash$ 或者 $unordered\_map$ 可以达到优秀的 $O(T\ log\ n)$ 的复杂度。

另：代码中附带了 $20pts$ 和 $60pts$ 的暴力，可以参考一下。

## $Code$

```cpp
#include <bits/stdc++.h>
#include <tr1/unordered_map>
#define debug(x) (cout << "#x = " << (x) << endl)
#define lowbit(x) (x & -x)
#define Set(x, i) memset(x, i, sizeof x)
#define R register
#define For( i, j, k ) for(R int i = (j); i <= (k); ++i)
#define Rep( i, j, k ) for(R int i = (j); i >= (k); --i)
#define Cross( i, j, k ) for(R int i = (j); i; i = (k))
typedef long long ll;
using namespace std;
const ll N = 10000011;
const ll INF = 5e16;

namespace IO {

	#define dd ch = getchar()
	inline ll read() {
		ll x = 0; bool f = 0; char dd;
		for (; !isdigit (ch); dd) f ^= (ch == '-');
		for (; isdigit (ch); dd)  x = x * 10 + (ch ^ 48);
		return f? -x: x;
	}
	#undef dd

	inline void write ( ll x ) {
		if (x < 0) putchar ('-'), x = -x;
		if (x > 9) write (x / 10); putchar (x % 10 | 48);
	}

	inline void wrn ( ll x ) { write(x); putchar (' '); }

	inline void wln ( ll x ) { write(x); putchar ('\n'); }

	inline void wlnn ( ll x, ll y ) { wrn(x); wln (y); }

}

using namespace IO;

namespace Cesare {
	
	ll n;
	double Ans = 0;
	
namespace Subtask1 {
	
	inline ll Count ( ll x, ll res = 0 ) {
		for (; x; x -= x & -x) ++res;
		return res;
	}
	
	inline void dfs ( ll pos, ll nowS, double p ) {
		if (nowS == 0) return (void) (Ans += p * pos);
		
		ll cc = Count(nowS);
		For ( i, 1, n ) if (nowS & (1 << i - 1)) {
			if (i == 1) dfs(pos + 1, nowS ^ (1 << i - 1), p * 1.0 / cc);
			else {
				ll y = nowS;
				nowS ^= (1 << i - 1);
				for (int x = i * i; x <= n; x *= i) 
					if (nowS & (1 << x - 1)) nowS ^= (1 << x - 1);
				dfs(pos + 1, nowS, p * 1.0 / cc);
				nowS = y;
			}
		}
	}
	
	inline void Solve () {
		Ans = 0;
		ll Max = (1 << n) - 1;
		dfs(0, Max, 1); printf("%.9lf\n", Ans);
	}
	
}

	const double Tab[] = 
	{
		0, 1.000000000, 2.000000000,
		3.000000000, 3.500000000, 4.500000000, 
		5.500000000, 6.500000000, 7.000000000, 
		7.500000000, 8.500000000
	};
	
	double S[N];
	
	vector <ll> Ve, V;
	tr1::unordered_map <ll, ll> T;
	
	inline void Init() {
		for (ll i = 2; i <= 1e5; ++i) 
			for (ll x = i * i; x <= 1e9; x *= i) 
				if (++T[x] == 1) Ve.push_back(x);
		sort(Ve.begin(), Ve.end());
		For ( i, 1, Ve.size() ) 
			if (T[Ve[i - 1]] >= 1) V.push_back(Ve[i - 1]);
		For ( i, 1, V.size() ) S[i] = S[i - 1] + 1.0 / (T[V[i - 1]] + 1);
	}

namespace Subtask2 {
	
	inline void Solve() {
		double Ans = 0;
		For ( i, 1, n ) 
			Ans += 1.0 / (T[i] + 1);
		printf("%.9lf\n", Ans);
	}
	
}
	
namespace Subtask {
	
	inline void Solve() {
		double Ans = 0;
		ll pos = upper_bound(V.begin(), V.end(), n) - V.begin();
		ll tot = upper_bound(Ve.begin(), Ve.end(), n) - Ve.begin();
		Ans += S[pos] + (n - tot); printf("%.9lf\n", Ans);
	}
	
}
	
	int main() {
		Init();
		
		ll T = read();
		while (T--) {
			n = read();
			Subtask :: Solve();
		} return 0;
	}
	
}

int main()
{
	return Cesare :: main();
}

```

---

## 作者：skydogli (赞：2)

### 这是一篇乱搞的题解（

首先，对于1个数x，如果有a个数的超过1的正整数次幂是它，那么它对答案的贡献就是$\frac{1}{a+1}$

简单证明：选取了这个数，那么在这之前就没有选取这a个数中的任何一个，相当于a+1个人排队，x在队首的概率，显然就是$\frac{1}{a+1}$

另外，$\sum\limits_{i=1}^{log_2n}\sqrt[i]{n}$是$\sqrt{n}$级别的，所以可以感性理解能被影响的数是很少的。

吹了这么多水，我只是想表达一个想法：
#### 乱 搞 可 过
我们直接对于$1,2,3...\sqrt{n}$的数，枚举它的次幂，然后直接暴力计算贡献即可。我们需要记录一个数是几个数的正整数次幂，前文说了被影响的数很少，所以直接放入map中即可。普通map的复杂度是$O(T\sqrt{n}logn)$，想要获得满分需要使用unordered_map。

```cpp
#include<tr1/unordered_map>
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define MX 1000000000
#define ld long double
int T,n;
ld P[100005];
tr1::unordered_map<int,int>att;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=2;i*i<=n;++i)P[i]=1;
		ld sum=n;//初始所有数的贡献都设定为1
		att.clear();
		for(int i=2;i*i<=n;++i){
			LL tmp=i;
			for(int mi=2;mi<=32;++mi){//2^30大于1e9，所以枚举到30就行了
				tmp=tmp*i;
				if(tmp>n)break;//大于n直接跳过
				sum+=(1.0-1.0/(1+att[tmp]));
                //因为之前计算过这个数的贡献了，所以我们需要先减去这个数的贡献，再加上新的贡献
				att[tmp]++;
				sum-=(1.0-1.0/(1+att[tmp]));
                //因为我们默认贡献为1，所以这里的贡献定义为期望花费比1小多少
			}
		}
		printf("%.8Lf\n",sum);
	}
	return 0;
}

```

---

## 作者：谁是鸽王 (赞：2)

## 【题解】P5589 小猪佩奇玩游戏(期望)


假设一个点有$x$个点(包括自己)可以到达他，他就对答案有$1/x$的贡献。这是因为这个点必须被删掉而通过删掉这个点本身删掉这个点的概率是$1/x$，所以对期望的贡献是$1\times 1/x$。

如何算$x$。$x$是唯一分解之后所有的指数的$gcd$的约数个数。

此时就有60分了。

考虑对于$\le \sqrt n$的数暴力处理，对于$> \sqrt n$的数，由于这些数不会有出度，所以只要算他们的入度。众所周知形如$x^y$的整数是很少的，具体的，大概是$O(\sum_{i=1}^{\sqrt n} \log_i n)$实在是太小了！所以我们定位一个$\le \sqrt n$的数，然后枚举它所有的幂然后暴力计算即可。但是要去重，具体实现用哈希。

还有一些出度入度都为$0$的点，直接+1

复杂度$O(\text{随便过})$ 

```cpp
 //@winlere
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<set>
#include<unordered_set>

using namespace std;  typedef long long ll;  typedef long double lb;
inline int qr(){
      register int ret=0,f=0;
      register char c=getchar();
      while(!isdigit(c))f|=c==45,c=getchar();
      while(isdigit(c)) ret=ret*10+c-48,c=getchar();
      return f?-ret:ret;
}
const int maxn=1e7+5;
int n,usd[maxn],Min[maxn];
vector<int> e;
inline void pre(const int&n){
      usd[1]=1; Min[1]=10;
      for(int t=2;t<=n;++t){
	    if(!usd[t])e.push_back(t),Min[t]=t;
	    for(auto i:e){
		  if(1ll*i*t>n)break;
		  usd[i*t]=1,Min[i*t]=i;
		  if(t%i==0)break;
	    }
      }
}

int gcd(const int&x,const int&y){return y?gcd(y,x%y):x;}
inline int getd(int x){
      if(x==1)return 1;
      int d=0;
      while(x>1){
	    int g=Min[x],cnt=0;
	    while(x%g==0&&x>1) ++cnt,x/=g;
	    d=gcd(d,cnt);
      }
      return d;
}
int K=0;
inline lb getsig(int x){
      if(x==1) return 1;
      ll ret=1;
      while(x>1){
	    K=max(K,x);
	    int g=Min[x],cnt=0;
	    while(x%g==0&&x>1) ++cnt,x/=g;
	    ret=ret*(cnt+1LL);
      }
      return (lb)1/ret;
}

unordered_set<int> s;
int main(){
      pre(maxn-1);
      int T=qr();
      while(T--){
	    int n=qr(),N=sqrt(n);
	    lb ans=0;
	    for(int t=1;t<=N;++t) ans+=getsig(getd(t));
	    ll k=2;
	    for(int t=2,cnt;t<=N;k=++t){
		  int d=getd(t);
		  cnt=1;
		  while(k<=N) k=k*t,++cnt;
		  while(k<=n){
			if(s.find(k)==s.end())
			      s.insert(k),ans+=getsig(d*cnt);
			k=k*t,++cnt;
		  }
	    }
	    ans+=(n-N-s.size());
	    printf("%Lf\n",ans);
	    s.clear();
      }
      return 0;
}


```







---

## 作者：CYJian (赞：2)

考虑每一个数被选择的概率：

一个数 $x$ 能被选当且仅当 在其之前没有选 $\sqrt{x}, \sqrt[3]{x}, \sqrt[4]{x}..., \sqrt[k]{x}$ (只有整数才算...)

那么对于一个数 $x$，令 $s=|\{k|\sqrt[k]{x} \in \mathbb{N},\ k \in \mathbb{N}\}|$，那么 $x$ 在这 $s$ 个数被选前就选了的概率是 $\frac{1}{s}$。所以这时候的 $x$ 的贡献就是 $\frac{1}{s}$。$x=1$ 时特判一下贡献为$1$。

那么我们就可以直接做 $60$ 分了。

但是我们发现，有很多数根本不能被开平方根，立方根等等。这些数的贡献就是 $1$。

所以我们可以只枚举 $\sqrt{n}$ 以内的数，然后统计其平方，立方...出现了多少次就行了。

统计出现的次数可以用哈希表，兴许也可以用map。。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MOD = 32009;

struct Hash {
	int tot;
	int fi[MOD];
	int ne[200000];
	int key[200000];
	int val[200000];

	inline void init() {
		memset(fi, 0, sizeof(fi));
		tot = 0;
	}

	inline int insert(int x) {
		for(int i = fi[x % MOD]; i; i = ne[i])
			if(key[i] == x) {
				val[i]++;
				return 0;
			}
		tot++;
		val[tot] = 1;
		key[tot] = x;
		ne[tot] = fi[x % MOD];
		fi[x % MOD] = tot;
		return 1;
	}

	inline int find(int x) {
		for(int i = fi[x % MOD]; i; i = ne[i])
			if(key[i] == x) return val[i];
		return 0;
	}
}hs;

int cnt[MOD];

int main() {
	int t; cin >> t;
	while(t--) {
		int n; cin >> n;
		long double res = 0;
		int mx = sqrt(n);
		while(mx * mx < n) ++mx;
		while(mx * mx > n) --mx;
		hs.init(); res = n;
		for(int i = 2; i <= mx; i++) {
			res += 1. / (cnt[i] + 1);
			res--;
			cnt[i] = 0;
			long long Pow = i * i;
			while(Pow <= mx) cnt[Pow]++, Pow *= i;
			while(Pow <= n) hs.insert(Pow), Pow *= i;
		} res -= hs.tot;// cerr << hs.tot << endl;
		for(int i = 1; i <= hs.tot; i++)
			res += 1. / (hs.val[i] + 1);
		printf("%.8Lf\n", res);
	} return 0;
}
```

---

## 作者：Uniecho1 (赞：2)

这就是所谓的“最后知道真相的我眼泪掉下来”吧

考试的时候一眼秒了$60pts$($fxs$可作证)

然后看着**黑色**的标签思考了$3s$人生

果断弃疗，直接开别的题去了

今晚决定填坑，然后发现...标签怎么是蓝的？？？

然后顺手就切了？？？

暴风哭泣


------------
先讲$60pts$

我们考虑每个数字能对答案产生的贡献

显然不会被别的数字划掉的数产生贡献恒为$1$

而能被别的数字划掉的数产生的贡献取决于有几个数字能划掉它

假设有$k$个数字能废了它

那么当且仅当选这个数的时候那$k$个数字都没被选它才能产生$1$的贡献，概率为$1/(1+k)$

那么$60pts$的丑陋代码就出炉了

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,N;
int cnt(int n){
	int tmp,res=1;
	for(int i=2;i*i<=n;i++){
		tmp=n;
		while(tmp%i==0)
			tmp/=i;
		if(tmp==1)
			++res;
	}
	return res;
}
int main(){
	//freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--){
		cin>>N;
		//int n=floor(sqrt(N));
		double ans=0;
		for(int i=1;i<=N;i++)
			ans+=1.0/cnt(i);
		cout<<fixed<<setprecision(7)<<ans<<endl;
	}
	return 0;
}
```

现在我们观察值域，想一想必定产生贡献的条件

我们会发现...只需要枚举$\sqrt N$以内的数能划掉哪些数就行了...

开一个$map$存一下每一个数被划过几次就好...

然后$100pts$就有了...

```cpp
#include<bits/stdc++.h>
#define IT map<big,big>::iterator
using namespace std;
typedef long long big;
big T,N;
map<big,big>vis;
int main(){
	//freopen("in.txt","r",stdin);
	cin>>T;
	while(T--){
		vis.clear();
		double ans=0;
		cin>>N;
		for(big i=2;i*i<=N;i++)
			for(big j=i*i;j<=N;j*=i)
				vis[j]++;
		ans+=(N-vis.size());
		for(IT i=vis.begin();i!=vis.end();i++)
			ans+=1.0/((*i).second+1);
		cout<<fixed<<setprecision(7)<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：redegg (赞：2)

把这$n$个数字分组，每一组中所有元素是其组内最小的数的幂。

把组内按照次幂的关系连线，一个组会形成一个DAG，$x^k$会连向$x^{2k},x^{3k}....$，每选一个点，就会把这个点指向的所有点全部删掉，我们现在先来算一下只考虑一组的情况下随机选点，删除的期望。因为只考虑一组，把DAG简化一下，变成$k$会连向$2k,3k...$。

设$f(x)$为一个有$x$个元素的组，元素是$\{a^0,a^1,a^3...a^x\}$，删除次数的期望。

我们考虑递推，$f(x)$的DAG图是由$f(x-1)$的图连上$x$形成的。

连向$x$的是$x$的因子，所以如果我先选择了删除这些因子，$x$就会直接被一起删掉，对删除次数没有影响，但是如果我在选择这些因子前先选择了$x$，就会让删除次数增多一次。

那么我们设$k$为$x$的因子数量（因子包括$x$在内）。在这些点中先选到$x$的概率是$\frac{1}{k}$，其它情况下就会选到其它点在前面，导致$x$被删掉。

那么式子就列出来了：

$$f(n)=\frac{1}{k}(f(n-1)+1)+\frac{k-1}{k}f(n-1)=f(n-1)+\frac{1}{k}$$

因为一个组内最多只会有$30$个人（最大的组是$2,2^1...2^{30}$）。所以我们先预处理出$f(1)$到$f(30)$。

然后枚举有哪些组，因为期望独立可加，把每个组的$f()$相加就可以了，通过枚举组内最小元素来枚举组，只枚举到$\sqrt n$，大于这个的，组内最多只会存在一个元素，并且$f(1)=1$，加上后面的一个元素的组的$f()$就好了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

double f[40];

void pre()
{
    f[1]=1;
    for(int i=2; i<=32; i++){
        int v=0;
        for(int j=1;j<=i;j++)
            if(i%j==0)v++;
        f[i]=f[i-1]+1/(double)v;
    }
}

bool vis[50005];

int main()
{
    int t;
    scanf("%d",&t);
    pre();
    while(t--)
    {
        memset(vis,0,sizeof(vis));
        int n;
        scanf("%d",&n);
        if(n==0){
            printf("0.00000000\n");
            continue;
        }
        int sum=0;
        double ans=0;
        ans=1;
        for(register int i=2; i*i<=n; i++)
        {
            long long x=i;
            if(vis[x])
                continue;
            int v=0;
            while(x<=n)
            {
                if(x*x<=n)
                    vis[x]=1;
                x*=i;
                v++;
                sum++;
            }
            ans+=f[v];
        }
        ans+=(n-sum-1);
        printf("%.8f\n",ans);
    }
    return 0;
}

```

刚刚发现题解有点错误，就改了一下，麻烦审核了。

---

## 作者：桑树下的邂逅 (赞：2)

我们将选择删除的点的贡献当做1，没选的贡献即为0,本题要求贡献的期望值

若一个数i有k个数能将它筛掉，则他贡献1/(k+1)的贡献，有1/（k+1）的概率首先被删掉

另外还有很多数无法被其他数删掉，贡献1，最后一起加上就行了
```
#include<cstdio>
#include<unordered_map>
#include<cmath> 
using namespace std;
#define int long long
const int maxN=1e5+100;
int t,n;
unordered_map<int,int>ma;
double ans;
#undef int
int main(){
#define int long long
	init();
	scanf("%lld",&t);
	while(t--){
		ans=0;int tmp=0;
		scanf("%lld",&n);ma.clear();
		for(int i=2;i*i<=n;i++){
			for(int j=i*i;j<=n;j*=i) ma[j]++;
		}
		for(auto v:ma) ans+=1/(v.second+1.0),tmp++;
		ans+=n-tmp;//没有数能删掉它的贡献
		printf("%lf\n",ans);
	}
}
```


---

## 作者：AKPC (赞：1)

**Step** $1$：$20$ 分（$n\leq10$）。

打表，我是赛时手推的，当然可以全排列暴力 `dfs`。

打出来就是这样的：

```
const double ans[15]={0,1,2,3,3.5,4.5,5.5,6.5,7,7.5,8.5};
```

**Step** $2$：$60$ 分（$n\leq10^5$）。

我们定义 $f(x)$ 的值为 $a^b=x$ 中 $a$ 的个数，满足 $a,b,x\in\text{N}^*$ 且 $a,b\geq2$。

首先可以假设 $ans_0=0$。

根据 **Step** $1$ 的表，发现当 $f(x)=0$ 的时候，$ans_x-ans_{x-1}=1$。

反之发现不是很好推，你可以尝试把 $n\leq32$ 的表全部打出来。

然后你可以得到 $ans_4-ans_3=\dfrac{1}{2}$，$ans_8-ans_7=\dfrac{1}{2}$，$ans_9-ans_8=\dfrac{1}{2}$，$ans_{16}-ans_{15}=\dfrac{1}{3}$，$ans_{32}-ans_{31}=\dfrac{1}{2}$ 等等。

至此发现规律，当 $f(x)\neq0$ 的时候，$ans_x-ans_{x-1}=\dfrac{1}{f(x)}$。

合并两个式子，对于每个 $x\in\text{N}^*$，$ans_x-ans_{x-1}=\dfrac{1}{f(x)}$。

这样你就可以得到 $60$ 分的做法了，[代码](/paste/avnawmhh)。

**Step** $3$：$100$ 分。

还是定义 $f(x)$ 的值为 $a^b=x$ 中 $a$ 的个数，满足 $a,b,x\in\text{N}^*$ 且 $a,b\geq2$。

在上一步我们枚举的是 $x$，但是这次 $x=n\leq10^9$。

正难则反，可以枚举 $a$ 的值，因为 $b\geq2$，所以 $a$ 的最大上限为 $\sqrt n$。

枚举 $a$ 的值后再枚举 $b$ 的值，由于 $a\geq2$，所以 $b$ 最大上限为 $\log_a n$。

可以在初始设置 $ans_n=n$ 的情况上减去答案，在得到 $a,b$ 之后，$a^b$ 的被遍历次数 $cnt_{a^b}$增加 $1$，最后显然 $f(x)=cnt_x$，在 $ans$ 中减去 $\dfrac{f(x)-1}{f(x)}$。

$cnt$ 开成 `unordered_map` 可以方便存储。

这样就做完了，附上考试场切[代码](/paste/ou0xw3ih)。

---

## 作者：zzy2333 (赞：1)

吐槽：刚点开这题被黑色的难度吓着了，于是开始想T2...

想了想T2发现好像还是T1更简单，而且看排行榜上T1 A的人更多

所以最后还是来做T1

(时间不够,T2有个大概思路但没写，同机房巨佬 @z7z_Eta 把T2 A了，%%%）

所以说，有时候还是要相信自己

------------

这题一看就是啥结论题，但是直接想结论比(fei)较(chang)困难,所以我们先考虑暴力做法。
 
设$ f_i $表示删完前$ i $个数期望步数，我们设$i$是$ cnt$ 个数的k次幂(不包括它自己）

我们发现，如果之前这$cnt$个数已经有一个删掉了，那么 $i $也被顺带删了，此时花费为$ f_{i-1}$

因此，当且仅当$i$在这$cnt $个数之前删除，我们需要多花费一步来删掉$ i $，此时花费为$ f_{i-1}+1 $

于是得出递推式

$$ f_i=(f_{i-1}+1)* \frac{1}{cnt+1} +f_{i-1}* \frac{cnt}{cnt+1} $$

将这个式子进行化简，可以得到

$$ f_i=f_{i-1}+\frac{1}{cnt+1} $$

所以答案就呼之欲出了：

$ \sum_{i=1}^n \frac{1}{cnt_i+1} $

其中$ cnt_i $表示第i个数是几个数的次幂

这个式子依然是$O(n)$的，但是我们发现，$\sqrt n $以上的数的次幂一定超过n了，所以我们对于每个小于$ \sqrt n $的数，标记一下它的次幂，最后没有被标记的数cnt就是0

对于每个数,$ n $以内只有$ logn $个数是它的次幂，所以复杂度$ O(T\sqrt nlogn) $

用map记录这些数的$ cnt $会TLE(多个log)，写一个哈希表就行了

这里我还用了个小优化：预处理出$ \sqrt {1e9} $之内的数的次幂

每次询问直接对于每个数的次幂询问一次就行了

为了避免重复询问，如果当前这个数本身就是别的数的次幂，那么它的次幂的答案一定已经被那个数统计过了跳过这个数即可。

然后就过了

~~比赛完还是评蓝了。。。以为自己又能多A一道黑题的。。。~~

最后是代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int mod=9999997;
int t;
int n;
int hash[10000000],vis[10000000];
void insert(int x){
	int now=x%mod;
	while(vis[now]&&vis[now]!=x){
		now=(now+1)%mod;
	}
	vis[now]=x;
	hash[now]++;
}
int check(int x){
	int now=x%mod;
	while(vis[now]&&vis[now]!=x){
		now=(now+1)%mod;
	}
	return hash[now];
}
int main(){
	int s=sqrt(1e9);
	for(int i=2;i<=s;i++){
		long long now=1ll*i*i;
		while(now<=1e9){
			insert(now);
			now*=i;
		}
	}
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		int sq=sqrt(n);
		int N=n;
		double ans=0;
		for(int i=2;i<=sq;i++){
			if(check(i))continue;
			long long now=1ll*i*i;
			while(now<=n){
				int v=check(now);
				ans+=1.0/(1.0*v+1);
				N--;
				now*=i;
			}
		}
		ans+=1.0*N;
		printf("%.6lf\n",ans);
	}
	return 0;
}
```



------------
$ update: $这题官方正解$ O(Tlog^2n) $看来我还是太弱了。。。

所以这题可不可以考虑出个加强版把带根号的做法卡掉

---

## 作者：littleKtian (赞：1)

20分做法：暴力求解

~~然后就没了~~

--------------------

60分做法：

首先由题干我们可以知道一个性质：

对于任意$p,q(q=p^k,k∈Z^+)$，所有在报出$q$时删去的数字在报出$p$时一定也会被删去

于是我们可以把$1......n$分成若干个序列$p,p^2......p^k(k∈Z^+,$且不存在$a,b∈Z^+(b\neq1),$使得$a^b=p)$，序列之间不会产生影响

而在报出$p^i(i∈Z^+)$后，所有$(p^i)^j$即$p^{ij}(j\in Z^+)$都会被删去

于是这个序列的答案就变成下面这个问题的答案：

>给定数列${1......n}$，每次等概率选出一个数字$x$，并将形如$kx(k\in Z^+)$的数字删除，求期望多少次操作后游戏结束

记$f[i]$为当数列为${1......i}$时上面问题的答案，可以得到转移方程：  
$f[i]=f[i-1]+1/ys(i)$，其中$ys(i)$表示i的因数个数。特别的，$f[1]=1$

因为序列最长不超过30项$(10^9<2^{30})$，所以$k$最大只有30

于是便有了下面的代码

```
#include<bits/stdc++.h>
using namespace std;
const int MAXP=30;
double f[MAXP+5],ans;
long long n;
int t,bj[100005];
int yzs(int x)
{
	int ans=1;
	for(int i=2;i<=MAXP;i++)
	{
		int tot=0;
		while(x%i==0)x/=i,++tot;
		ans*=(tot+1);
		if(x==1)break;
	}
	return ans;
}
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=MAXP;i++)f[i]=f[i-1]+1.0/(1.0*yzs(i));
	while(t--)
	{
		scanf("%lld",&n);
		memset(bj,0,sizeof(bj));
		ans=1.0,bj[1]=1;
		for(int i=2;i<=n;i++)
		if(!bj[i])
		{
			long long j=i;int k=0;
			while(j<=n)bj[j]=1,++k,j*=i;
			ans+=f[k];
		}
		printf("%0.5f\n",ans);
	}
}
```

时间复杂度$O(tn+logn)(logn$为初始化$)$

-----------------

80分做法：

考虑如何快速计算长度为$k$的序列个数

先不考虑对任意$a,b∈Z^+(b\neq1),a^b\neq p$的情况

记$a[i]$为满足$x^i\leq n$的最大正整数，$b[i]$为长度为i的序列个数

显然有$b[i]=a[i]-a[i+1]$

现在考虑如何将$p=a^b$的数列去掉

若$a[i+1]< p\leq a[i]$，则根据定义，一定有$p^i\leq n <p^{i+1}$

即$(p^k)^{\frac{i}{k}}\leq n<(p^k)^{\frac{i+1}{k}}$

从而有了下面这段80分代码

```
#include<bits/stdc++.h>
using namespace std;
const int MAXP=30;
double f[MAXP+5],ans;
int t,n,a[MAXP+5],b[MAXP+5];
int yzs(int x)
{
	int ans=1;
	for(int i=2;i<=MAXP;i++)
	{
		int tot=0;
		while(x%i==0)x/=i,++tot;
		ans*=(tot+1);
		if(x==1)break;
	}
	return ans;
}
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=MAXP;i++)f[i]=f[i-1]+1.0/(1.0*yzs(i));
	while(t--)
	{
		scanf("%d",&n);
		a[MAXP+1]=1;ans=1.0;
		for(int i=1;i<=MAXP;i++)a[i]=pow((double)n,1.0/((double)i));
		for(int i=MAXP;i>0;i--)b[i]=a[i]-a[i+1];
		for(int i=MAXP;i>0;i--)
		{
			ans+=(double)b[i]*f[i];
			for(int j=2;j<=MAXP;j++)b[i/j]-=b[i];
		}
		printf("%0.5f\n",ans);
	}
}
```

至于80分的原因……

>对于 C++ 选手，若对于正整数$n,k$，希望得到$\sqrt[k]n 
$，请**尽量不要使用 C++ 自带的$\operatorname{pow}$函数**，以免可能产生不必要的精度误差。

------------------

100分代码

其实只要对开根部分进行一番处理即可

代码

```
#include<bits/stdc++.h>
using namespace std;
const int MAXP=30;
double f[MAXP+5],ans;
int t,n,a[MAXP+5],b[MAXP+5];
long long p(int x,int y)
{
	if(y==0)return 1;
	long long z=p(x,y>>1);
	z=z*z;
	if(y&1)z=z*(1ll*x);
	return z;
}
int kg(int x,int y)
{
	int an=pow((double)x,1.0/((double)y));
	if(p(an+1,y)<=x)return an+1;
	return an;
}
int yzs(int x)
{
	int ans=1;
	for(int i=2;i<=MAXP;i++)
	{
		int tot=0;
		while(x%i==0)x/=i,++tot;
		ans*=(tot+1);
		if(x==1)break;
	}
	return ans;
}
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=MAXP;i++)f[i]=f[i-1]+1.0/(1.0*yzs(i));
	while(t--)
	{
		scanf("%d",&n);
		a[MAXP+1]=1;ans=1.0;
		for(int i=1;i<=MAXP;i++)a[i]=kg(n,i);
		for(int i=MAXP;i>0;i--)b[i]=a[i]-a[i+1];
		for(int i=MAXP;i>0;i--)
		{
			ans+=(double)b[i]*f[i];
			for(int j=2;j<=MAXP;j++)b[i/j]-=b[i];
		}
		printf("%0.5f\n",ans);
	}
}
```


---


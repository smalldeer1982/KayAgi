# 小猪佩奇爬树 加强版

## 题目背景

CYJian 在打 洛谷 10 月月赛I Div. 2 的时候，用一种 $O(N)$ 的做法过了这道题的原题。

但是好像这题是可以给常数小的 $O(N \log N)$ 甚至 $O(N^2)$ 过的。 CYJian 觉得很不服并且出了这道加强版。

---

因为有人反馈 `OLE` 的问题，所以 CYJian 将输出改为原来所有输出的异或和。

## 题目描述

原题数据可能过水，有些错误的做法也可以过原来的题目。**所以可能原题能过在这里就WA了。**

~~比如我自己原来一个错解也过了，一堆东西没考虑。~~

样例解释部分可以参见 [P5588](https://www.luogu.org/problem/P5588)。

一句话题意：给出一棵 $n$ 个点的树，每个点上有一种颜色，请你求出对于每一种颜色，树上有多少条链包含该种颜色的所有点。

注意下面的数据范围。**请注意常数因子对程序效率的影响。**

如果需要请使用 [IO优化](https://www.luogu.org/paste/i11c3ppx)

## 说明/提示

一共 $5$ 组数据，第 $i$ 组的数据范围：

$n = 3 \times 10^{i+1}$

## 样例 #1

### 输入

```
4
1 2 2 3
1 2
2 3
3 4```

### 输出

```
2
```

## 样例 #2

### 输入

```
10
9 7 4 2 3 4 4 5 8 5
2 1
3 2
4 2
5 2
6 4
7 4
8 1
9 4
10 4```

### 输出

```
60
```

# 题解

## 作者：奇米 (赞：7)

# 题解 - $\mathrm{P5593}$

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P5593)

给出一棵 $n$ 个点的树，每个点上有一种颜色。现在请你求出对于每一种颜色，树上有多少条链包含该种颜色的所有点。

$n\leq 3\times 10^6$

## $\mathrm{Sol}$

一道细节很多的题目。

首先我们很容易想到若一种颜色的数量 $t_i=0$ 那么输出 $\frac{n\times(n+1)}{2}$。已经如果一种颜色在大于等于三棵子树中出现过那么输出 $0$。

于是我们考虑 $t_i=1$ 的情况，这个也比较容易答案就是这个节点为根的子树大小相互乘起来再累加。

难点在于某种颜色有两个端点的情况的处理。我们记 $mp_c$ 为颜色 $c$ 到现在出现的个数，并且记录 $tot$ 表示在当前子树中有几个颜色为 $c$ 的个数。那么每次递归完一颗子树看 $mp_c$ 是否改变，若改变那么 $tot$ 加一。若 $tot=1$ 则表示其为该颜色的某一个端点。那么答案即为两个端的子树大小乘积，具体实现看代码。

时间复杂度 $O(n)$


## $\mathrm{Code}$

```cpp
const int N=3e6+5;

int n,m,cnt,t[N],col[N],siz[N],Siz[N];
int gs[N],cs[N],head[N],Nod[N],Ans[N];

struct Node
{
	int nex,to;
};
Node e[N<<1];

inline void jia(int u,int v)
{
	e[++cnt].nex=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}

inline void dfs(int u,int fa)
{
	siz[u]=1;
	int Col=col[u],sum=0;
	int onend=0,Las=cs[Col];
	GO(i,u) 
	{
		int v=e[i].to;
		if(v==fa) continue;
		int las=cs[Col];//递归这颗子树之前的颜色个数
		dfs(v,u);
		Siz[u]+=siz[u]*siz[v];//对就1个该颜色答案的统计
		siz[u]+=siz[v];
		if(las^cs[Col]) sum++,onend=v;//记录端点
	}
	Siz[u]+=siz[u]*(n-siz[u]);
	if(Las||t[Col]-1!=cs[Col]) sum++;//子树u自己本身也要统计进去
	cs[Col]++;
	if(sum==1) 
	{
		if(!gs[Col]) Nod[Col]=u;
		else 
		{
			int mul=(onend)?n-siz[onend]:siz[u];
			Ans[Col]=siz[Nod[Col]]*mul;
		}
		gs[Col]++;//统计有几个子树有颜色Col
	}
}

signed main()
{
	io.read(n);
	For(i,1,n) 	
	{
		io.read(col[i]);
		t[col[i]]++;
		Nod[col[i]]=i;
	}
	For(i,1,n-1)
	{
		int x,y;
		io.read(x),io.read(y);
		jia(x,y),jia(y,x);
	}
	dfs(1,0);
	For(i,1,n) 
	{
		int ret=0;
		if(!t[i]) ret=n*(n-1)/2ll;//没有这种颜色
		if(t[i]==1) ret=Siz[Nod[i]]; //有1种
		if(gs[i]==2) ret=Ans[i];//两个端点情况
		io.write(ret),puts("");
	}
	return 0;
}
```



---

## 作者：CYJian (赞：4)

直接搬运原题的题解.jpg

欢迎其他的 $O(N)$ 算法来ddw。

如果有复杂度高于 $O(N)$ 的算法过了，请及时通知 CYJian，然后加强数据。

---

对于这道题，比较显然的一点是：如果存在一个点，存在三个以上的子树中有与其相同的颜色的点，那么这种颜色的方案就是 $0$。

否则的话，就可以发现，这些颜色相同的点一定在树上的某一条链上，那么找到链的两个端点，方案数就是去掉两端点中间的一坨点，剩下两棵的子树大小的乘积。

然后思路就很清晰了：我们只需要对于每一个点，看看是不是只有一条边所连的子树中有与其相同颜色的点。如果是就是一个端点。

然后记录下这条边，最后计算只需要判断端点个数就行了：

零个端点：$\frac{n \times (n - 1)}{2}$

一个端点：所有子树两两乘积和 $+n-1$

两个端点：去掉中间一坨点后，剩下两颗子树的大小乘积

三个及以上的端点：$0$。

```cpp
#if By_CYJian
为什么 CYJian 那么菜啊...

Algorithm: 

Solution: (看心情写)
#endif

#include <bits/stdc++.h>

using namespace std;

#define FILE(Name) freopen(Name"in", "r", stdin), freopen("out", "w", stdout)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

template<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }
template<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }
template<typename T> inline T gcd(T&a, T b) { return !b ? a : gcd(b, a % b); }
typedef unsigned uit;
typedef long long ll;
typedef double db;

// 看题目取用
// const int mod = 2999999; // for Hash
// const int mod = 4999999; // for Hash
// const int mod = 19491001;
// const int mod = 19260817;
// const int mod = 104857601;
const int mod = 998244353;
// const int mod = 998244853;
// const int mod = 1004535809;
// const int mod = 1000000007;

template<typename T> const T Mod(T x) { return x >= mod * 2 ? x % mod : (x >= mod ? x - mod : x); }
template<typename T> const void Add(T&a, T b) { a = Mod(a + b); }

inline int ksm(int x, int k) {
	int s = 1;
	while(k) {
		if(k & 1) s = Mod((ll)s * x);
		x = Mod((ll)x * x), k >>= 1;
	} return s;
}

const int MAXN = 1000010;

int n;

int col[MAXN];

int tot;
int fi[MAXN];
int ne[MAXN << 1];
int to[MAXN << 1];

inline void Link(int u, int v) {
	tot++;
	to[tot] = v;
	ne[tot] = fi[u];
	fi[u] = tot;
}

int All[MAXN];
int cnt[MAXN];
int nds[MAXN];
ll res[MAXN];
ll f[MAXN];
int si[MAXN];
int nd[MAXN];

inline void dfs(int x, int la) {
	int c = col[x], ct = cnt[c], flg = 0, pos = 0; si[x] = 1;
	for(int i = fi[x]; i; i = ne[i]) {
		int u = to[i];
		if(u == la) continue;
		int las = cnt[c];
		dfs(u, x);
		f[x] += 1LL * si[u] * si[x];
		si[x] += si[u];
		int sum = cnt[c] - ct;
		if(las != cnt[c]) ++flg, pos = u;
	} f[x] += 1LL * si[x] * (n - si[x]);
	if(ct || cnt[c] != All[c] - 1) ++flg; ++cnt[c];

	if(flg == 1) {
		if(!nds[c]) nd[c] = x;
		else res[c] = 1LL * si[nd[c]] * (pos ? n - si[pos] : si[x]);
		++nds[c];
	} // cerr << x << ' ' << flg << endl;
}

int main() {
#ifndef ONLINE_JUDGE
	FILE("");
#endif
	gi(n);
	for(int i = 1; i <= n; i++) gi(col[i]), All[col[i]]++, nd[col[i]] = i;
	for(int i = 1; i < n; i++) {
		int u, v; gi(u), gi(v);
		Link(u, v), Link(v, u);
	} dfs(1, 1);
	for(int i = 1; i <= n; i++) {
		if(All[i] == 0) print(1LL * n * (n - 1) >> 1);
		else if(All[i] == 1) print(f[nd[i]]);
		else if(nds[i] == 2) print(res[i]);
		else print(0);
		pc('\n');
	} return 0;
}
```

---

## 作者：喵仔牛奶 (赞：4)

## Description

给定一颗树，对每个颜色求树上有多少条链覆盖了全部这种颜色。

## Solution

容易想到对于每种颜色，求出最短的包含所有该颜色的链，令链的两端的在链外的子树大小为 $a,b$，答案即为 $a\times b$。

难点在于找出链头。

令 $t_u$ 为 $u$ 有多少其子树包含与 $u$ 同色结点（父亲方向子树也算），令 $s_u$ 为 $u$ 子树内节点数。

遍历树，动态维护 $cnt_i$ 为颜色 $i$ 当前出现的次数，记当前结点为 $u$，每次遍历子树若 $cnt_{c_u}$ 改变，则 $t_u\leftarrow t_u+1$。

对于父亲，维护 $all_i$ 为颜色 $i$ 所有出现的次数，若 $all_{c_u}>u$ 子树内颜色为 $c_u$ 的结点个数， 则 $t_u\leftarrow t_u+1$。

同时令初始所有 $ans_i=1$。

对 $t_u$ 分类讨论：
- $t_u=0$：没有与 $u$ 同色节点，答案为 $u$ 的子树大小两两相乘之和。
- $t_u=1$：$u$ 为链头之一。若 $t_u$ 的贡献来自父亲方向子树，则 $u$ 是链的底端，$ans_{c_u}\leftarrow ans_{c_u}\times s_u$；否则 $u$ 是链的顶端，令 $sub$ 为 $u$ 做出贡献的子树大小和，$ans_{c_u}\leftarrow ans_{c_u}\times (s_u-sub)$。
- $t_u\ge 2$ 所有颜色不可能在同一条链上，$ans_{c_u}\leftarrow 0$。

需要注意的是，若 $t_u=1$ 的结点数 $\ge 2$，也 $ans_{c_u}\leftarrow 0$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace FastIO {
    char buf[1 << 23], *p1 = buf, *p2 = buf;
#define getchar() \
    (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
    inline int read() {
        register int sr = 0;
        register char ch = getchar(), last;
        while (ch < '0' || ch > '9') last = ch, ch = getchar();
        while (ch >= '0' && ch <= '9') sr = (sr << 1) + (sr << 3) + (ch ^ 48), ch = getchar();
        return last == '-' ? -sr : sr;
    }
}
namespace Milkcat {
	using namespace FastIO;
	typedef long long LL;
	const int N = 3e6 + 5; 
	LL n, u, v, res, c[N], all[N], cnt[N], siz[N], qaq[N], ans[N];
	vector<int> G[N];
	void dfs(int u, int fa) {
		LL tot = 0, sub = 0, sum = 0, bef = cnt[c[u]]; // tot 为 t[u]，sum 用于处理 t[u]=0，bef 为子树为 c[u] 的出现次数
		for (int v : G[u]) {
			if (v == fa) continue;
			int last = cnt[c[u]]; // 遍历前 c[u] 出现次数
			dfs(v, u), sum += siz[u] * siz[v], siz[u] += siz[v]; // dfs，计算 sum
			if (last != cnt[c[u]]) tot ++, sub += siz[v]; // 若 c[u] 出现次数改变，则子树内出现了 c[u]
		}
		cnt[c[u]] ++, siz[u] ++; // 更新 c[u]
		bool qwq = all[c[u]] - (cnt[c[u]] - bef);  // 父亲方向子树是否出现 c[u]
		tot += qwq;
		if (tot == 0) ans[c[u]] = siz[u] * (n - siz[u] + 1) + sum - 1; // t[u]=0
		if (tot == 1) {
			if (qwq) ans[c[u]] *= siz[u]; // u 为链底
			else ans[c[u]] *= n - sub; // u 为链头 
			if (++ qaq[c[u]] > 2) ans[c[u]] = 0; // 若出现 >2 个端点则无解
		}
		if (tot > 2) ans[c[u]] = 0; // 无解
	}
	int main() {
		n = read();
		for (int i = 1; i <= n; i ++)
			c[i] = read(), all[c[i]] ++, ans[i] = 1;
		for (int i = 1; i < n; i ++)
			u = read(), v = read(), G[u].push_back(v), G[v].push_back(u);
		dfs(1, 0);
		for (int i = 1; i <= n; i ++)
			if (!all[i]) ans[i] = n * (n - 1) / 2; // 若没有这种颜色，答案显然为 n*(n-1)
		for (int i = 1; i <= n; i ++)
			res ^= ans[i];
		cout << res << '\n';
		return 0;
	}
}
int main() {
	return Milkcat::main();
}

```

---

## 作者：Lydia1010__ (赞：3)

## 本题思路：
本题其实我们在意的只是相同颜色可以连成一条线的情况，如果一条线不能贯穿所有这种颜色的节点显然答案就是零。

那么如果是一条线，就会有两个端点。我们考虑开一个桶去记录每一种颜色的出现次数，如果扫到的节点子树内没有和他相同颜色的就肯定是一个端点了，而如果当前节点是本颜色的第一次出现切子节点的子树中只有一个子节点的子树包含当前颜色那么就也是一个端点。我们判断是不是可以一条线穿过就看端点数是否为二即可，答案统计的话就是子树大小相乘（如果这个端点的子树内有当前颜色，就是总结点数减去子节点中由当前颜色的子节点的子树大小的值作为他的子树大小）。

还有一些特殊情况，就是当前颜色没有节点或者只有一个节点。没有节点的情况题目中已经说了，在这里就不赘述了。只有一个节点就是他的子节点子树分别两两相乘。特盘掉就做完了。
## 本题代码：
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
static char pbuf[1000000],*p1=pbuf,*p2=pbuf,obuf[1000000],*o=obuf;
#define getchar() p1==p2&&(p2=(p1=pbuf)+fread(pbuf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (o-obuf<1000000)?(*o++=(x)):(fwrite(obuf,o-obuf,1,stdout),o=obuf,*o++=(x))
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
struct flusher{~flusher(){fwrite(obuf,o-obuf,1,stdout);}}autoflush;
int a[3000005],num[3000005],vis[3000005];
vector<int>s[3000005];
long long b[3000005];int siz[3000005];
int pd[3000005],ls[3000005];
long long ans[3000005];int n;
void dfs(int p,int fa){
	int sum=0,op=-1,Lat=vis[a[p]];siz[p]=1;vis[a[p]]++;
	for(int i=0;i<s[p].size();i++){
		int y=s[p][i];if(y==fa) continue;
		int lat=vis[a[p]];
		dfs(y,p);b[p]=b[p]+1ll*siz[p]*siz[y];siz[p]+=siz[y];
		if(lat!=vis[a[p]]){sum++;op=i;}
	}
	b[p]=b[p]+1ll*siz[p]*(n-siz[p]);
	if(vis[a[p]]==num[a[p]]&&Lat==0) sum=0;
	if(sum==0){
		if(!ls[a[p]]) ls[a[p]]=p;
		else{
			if(op!=-1){
				ans[a[p]]=1ll*siz[ls[a[p]]]*(n-siz[s[p][op]]);
			}
			else ans[a[p]]=1ll*siz[ls[a[p]]]*siz[p];
		}
		pd[a[p]]++;
	}
}
int j[3000005];
signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0),cout.tie(0);
	n=read();
	for(int i=1;i<=n;i++) a[i]=read(),num[a[i]]++,j[a[i]]=i;
	for(int i=1;i<n;i++){
		int x,y;x=read(),y=read();
		s[x].push_back(y),s[y].push_back(x);
	}
	dfs(1,0);long long anss=0;
	for(int i=1;i<=n;i++){
		int now;
		if(num[i]==0) anss^=(1ll*(n-1)*n/2),now=(n-1)*n/2;
		else if(pd[i]==1) anss^=b[j[i]],now=b[j[i]];//,cout<<i<<" "<<b[j[i]];
		else if(pd[i]==2) anss^=ans[i],now=ans[i];
		else anss^=0,now=0;
//		cout<<now<<'\n';
	}
	write(anss);
	return 0;
}
```

---

## 作者：_AyachiNene (赞：2)

~~单 $\log$ 冲过去了。~~
# 思路：
假设有方案，直接分套一个颜色的点的数量：

1. 只有一个点，从任意两个子树（包括祖先）中选两个点拼起来，或者从一个子树中选一个点和他自己。可以 dfs 时预处理。
2. 多个点，链头和链底是祖先关系，找到链头向下一步且在链底方向的点，和链底的两边子树大小乘起来。
3. 多个点，链头和链底没祖先关系，两边子树大小乘起来。

考虑如何找到链头和链底，首先链底显然是深度最大的点，记为 $x$。所有点的 lca 一定是链上的点，记为 $y$。判断每个点是否在 $x$ 和 $y$ 的链上，如果不在，且之前没有这样的点，记为 $z$，如果已经有 $z$ 且这个点和 $z$ 没有祖先关系，则不合法，否则取深度更大的。最后如果没有 $z$，链为 $(x,y)$，对应底二种分讨。否则为 $(y,z)$，对应第三种。用树剖求 lca 没卡常就过了。

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
struct node
{
	int nxt,to;
}e[3000005<<1];
int head[3000005],cnt_edge;
void add_edge(int u,int v)
{
	e[++cnt_edge].to=v;
	e[cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
}
int n;
int a[3000005];
int f[3000005],siz[3000005],dep[3000005],son[3000005],top[3000005],dfn[3000005],cnt;
long long w[3000005],sum[3000005];
void dfs1(int u,int fa)
{
	f[u]=fa;siz[u]=1;dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs1(v,u);siz[u]+=siz[v];
		w[u]+=(sum[u]+1)*siz[v],sum[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
	w[u]+=(sum[u]+1)*(n-siz[u]);
}
void dfs2(int u,int t)
{
	top[u]=t;dfn[u]=++cnt;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==f[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
inline int lca(int x,int y)
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=f[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}
inline int query(int x,int y)
{
	int pre=0;
	while(top[x]^top[y]) pre=x,x=f[top[x]];
	return x==y?top[pre]:son[y];
}
basic_string<int>pos[3000005];
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(int i=1;i<=n;i++) read(a[i]),pos[a[i]].push_back(i);
	for(int i=1;i<n;i++)
	{
		int u,v;read(u,v);
		add_edge(u,v);add_edge(v,u);
	}
	dfs1(1,0);dfs2(1,1);
	long long ans=0;
	for(int i=1;i<=n;i++)
		if(!pos[i].size()) ans^=1ll*(n-1)*n/2;
		else if(pos[i].size()==1) ans^=w[pos[i][0]];
		else
		{
			int x=pos[i][0],y=pos[i][1],z=0;
			for(int j:pos[i])
			{ 
				if(dfn[j]<dfn[x]) x=j;
				if(dfn[y]<dfn[j]) y=j;
				if(dep[j]>dep[z]) z=j;
			}
			x=lca(x,y);y=z;z=0;
			int flag=1;
			for(int j:pos[i])
			{
				if(j==y||j==x) continue;
				if(lca(y,j)!=j)
				{
					if(lca(y,j)!=x||(z&&lca(z,j)!=(dep[z]<dep[j]?z:j))){flag=0;break;}
					if(dep[z]<dep[j]) z=j;
				}
				
			}
			if(flag)
			{	
				if(z) ans^=1ll*siz[z]*siz[y];
				else ans^=1ll*siz[y]*(n-siz[query(y,x)]);
			}
		}
	write(ans);
	flush();
	return 0;
}
```

---

## 作者：FRZ_29 (赞：0)

[题目](https://www.luogu.com.cn/problem/P5593)。

[更不好的阅读体验](https://www.cnblogs.com/FRZ29/p/18448657)。
## 分析

首先考虑什么样的颜色能被链覆盖。

容易想到当某种颜色恰巧在一条链上会被覆盖。

所以只需要判断一种颜色是否能构成链即可，链的贡献也很好计算。

### 算法

考虑链的性质：有且仅有两个端点。

凭借这个性质，可以判断一种颜色是否在一条链上。

在 dfs 中考虑各种情况。

假设一个点 $u$，其颜色为 $c$，有以下 $2$ 种情况判断 $u$ 是否为端点。

1. 如果 $u$ 的子树中没有颜色 $c$ 的节点，那么 $u$ 点是一个端点。
2. 满足两个条件。
   1. 除了 $u$ 的子树没有颜色 $c$ 的节点。
   2. $u$ 的所有儿子中，只有一个儿子的子树中有颜色 $c$。

判断端点数量是否等于 $2$，等于 $2$ 说明该种颜色恰好构成一条链。

还有一个特殊情况：某个颜色可能只有一个点，需要直接算答案。

如果是一条链的话，假设两条节点为 $p, q$，对答案的贡献有两种情况。

1. 如果 $p, q$ 均是满足上述第 $1$ 种情况的，答案为 $sz_p \times sz_q$。
2. 如果 $p$ 是满足上述第 $2$ 种情况的，考虑一下，因为 $p$ 的所有儿子中，只有一个儿子的子树中有颜色 $c$，假设该儿子为 $pos$，所以 $p$ 的其他儿子的子树中的节点也能对答案有贡献，故答案为 $(n - sz_{pos}) \times sz_q$。

如何实现见代码。

```cpp
#ifdef ONLINE_JUDGE
#else
#define FRZ_29
#endif

#include <iostream>
#include <cstdio>
typedef long long LL;

using namespace std;

void RD() {}
template<typename T, typename... U> void RD(T&x, U&... arg) {
    x = 0; int f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-') ch = getchar(); ch = getchar(); }
    while (ch <= '9' && ch >= '0') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    x *= f; RD(arg...);
}

void WT() {}
template<typename T> void WT(T x) {
    if (x < 0) { putchar('-'); x = -x; }
    if (x > 9) WT(x / 10);
    putchar(x % 10 + '0');
}

const int N = 3e6 + 5;

#define LF(i, __l, __r) for (int i = __l; i <= __r; i++)
#define RF(i, __r, __l) for (int i = __r; i >= __l; i--)

int head[N], ver[N << 1], Next[N << 1], _tot = 1;
int n, a[N], tot[N], nos[N], enos[N], cnt[N], sz[N];
LL ans, ans1[N], ans2[N];

void add(int u, int v) {
    ver[++_tot] = v;
    Next[_tot] = head[u], head[u] = _tot;
}

/*
如果 flag == 1，才能判断为端点
这是由 flag 的增加方式决定的
*/
void dfs(int u, int _f) {
    int c = a[u], flag = 0, pos = 0;
    int k = cnt[c];
    sz[u] = 1;

    for (int i = head[u]; i; i = Next[i]) {
        int v = ver[i];
        if (v == _f) continue;
        int la = cnt[c];
        dfs(v, u);
        ans1[u] += 1LL * sz[u] *sz[v];
        sz[u] = sz[u] + sz[v];
        if (la != cnt[c]) flag++, pos = v; // 与判断是否为端点的条件2相关
    }                                      // 如果该条件被满足两次pos自然就无用了

    ans1[u] += 1LL * sz[u] * (n - sz[u]);
    if (k || cnt[c] != tot[c] - 1) flag++; // 与判断是否为端点的条件1相关
    cnt[c]++;

    if (flag == 1) {
        if (!enos[c]) nos[c] = u;
        else {
            int p = pos ? n - sz[pos] : sz[u];
            ans2[c] = 1LL * p * sz[nos[c]];
        }
        enos[c]++;
    }
}

int main() {
#ifdef FRZ_29
    freopen("read.in", "r", stdin);
    freopen("out.out", "w", stdout);
#endif

    RD(n);

    LF(i, 1, n) {
        RD(a[i]); tot[a[i]]++; nos[a[i]] = i;
    }

    LF(i, 1, n - 1) {
        int u, v; RD(u, v);
        add(u, v), add(v, u);
    }

    dfs(1, 0);

    LF(i, 1, n) {
        if (tot[i] == 0) ans ^= 1LL * n * (n - 1) / 2;
        else if (tot[i] == 1) ans ^= ans1[nos[i]];
        else if (enos[i] == 2) ans ^= ans2[i];
        else ans ^= 0;
    }

    WT(ans);
    return 0;
}
```

> 七月流火，九月授衣。

---


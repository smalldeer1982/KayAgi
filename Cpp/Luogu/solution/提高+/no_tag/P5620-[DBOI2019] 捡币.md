# [DBOI2019] 捡币

## 题目背景

> 众所周知，以津真天世界第一可爱。
> ——1jia1

你正在打不氪金手游 yys，这时家长进来了，于是你装作在打数据结构题。

![](https://cdn.luogu.com.cn/upload/pic/71004.png)

## 题目描述

由于你在 $n$ 次十连抽后没钱了，于是你应以津真天的邀请去参加一个活动。

这个活动是在一个 $n\times n$ 的矩形区域中进行的，进行若干秒。第 $i$ 秒，主办方会在这个矩形中选择一块小的区域，在每格上面分别撒币。

捡币的规则是这样的：从左上角 $(1,1)$ 出发，走一条抵达  $(n,n)$ 的路径，每次只能从当前格子下面或右边的格子走，并捡起这个区域的金币。

你需要知道，在某一秒某个矩形区域中拥有最多金币的格子有多少金币，某个矩形区域中的金币总数，以及第 $m$ 秒后（如果有撒币操作则先撒币）开始最多能捡多少币。捡币过程中，场上金币数量不会变化，你可以认为这是在 1s 内完成的。

## 说明/提示

【样例 #1 说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/ngd0lgmf.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/b3aeyq7f.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/c45m09ft.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/jrgxj4ty.png)

### 数据范围及约定

- Subtask #1（$20$分）：$1\leq n\leq 10$, $1\leq Q\leq 1000$。
- Subtask #2（$20$分）：$1\leq n\leq 1000$, $1\leq Q\leq 10$。
- Subtask #3（$20$分）：$1\leq n\leq 100$, $1\leq Q\leq 1000$。
- Subtask #4（$40$分）：$1\leq n\leq 1000$, $1\leq Q\leq 10000$。



## 样例 #1

### 输入

```
5 5 7
3 1 1 2 2
5 4 2 5 4
1 2 2 2 4
-1 2 2 4 4
2 2 2 4 3
7 1 4 3 4
0 1 3 5 4```

### 输出

```
21
8
40```

# 题解

## 作者：Tritium (赞：3)

为数不多的二维分块的题目。（我做题太少了QwQ）

本题二维分块的做法就是对行和列分别一维分块，然后将一维数组改为二维数组即可维护二维分块。基本上是裸的。

上一篇题解关于二维分块的讲解复杂度可能有一些问题。这里再分析一波：
```
++++++++ ++
++++++++ ++
         ++
++ ..... ++
++ ..... ++
++ ..... ++
++ 
++ ++++++++
++ ++++++++
```
首先点代表中间整块，+代表零散块。我们是这样维护边角料中间块的对吧？

设块的大小为$S$,边长为$N$.那么中间的整块的个数为$O((\frac{N}{S})^2)$个。

周围四个长条,长为$O(N)$,宽为$O(S)$,所以维护边角料长条时间复杂度$O(NS)$.

除去预处理,总复杂度$O(Q(NS+(\frac{N}{S})^2))$.

对于复杂度来说,我们只关心最大的那一项.而在$S>0$的时候,$NS$是一个增函数,$(\frac{N}{S})^2$是一个减函数.所以会有一个$s_0$使得两者相等,并且$s_0$无论变小还是变大,其值$max\{ NS,(\frac{N}{S})^2\}$都会变大.

所以,当$NS=(\frac{N}{S})^2$时,复杂度最小.此时$S=N^{\frac{1}{3}}$.

总复杂度$O(N^{\frac{4}{3}})$.$\because N=1000,\therefore \text{运算量}\to10^7$.可过.

```cpp
#include <cstdio>
#include <cmath>
const int S=1003;
int n,m,q,a[S][S],bl[S],add[200][200],_=0,nn,mx[200][200],fr[S],ed[S];
long long s[200][200],f[S][S];
inline void read(int &s)
{
	s=0;char t=1,c=getchar();
	while (c!='-' && (c<'0' || c>'9')) c=getchar();
	if (c=='-') c=getchar(),t=-1;
	while (c>='0' && c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();
	s*=t;
}
inline long long ma(long long a,long long b){return a>b?a:b;}
inline void mma(int &a,int b){a=a>b?a:b;}
inline void modify(int u,int x,int y,int xx,int yy)
{
	if (bl[x]==bl[xx] || bl[y]==bl[yy] )
	{
		for (int i=x;i<=xx;++i)
			for (int j=y;j<=yy;++j)
			{
				a[i][j]+=u;
				s[bl[i]][bl[j]]+=u;
				mma(mx[bl[i]][bl[j]],a[i][j]);
			}
		return;
	}
	for (int i=bl[x]+1;i<bl[xx];++i)
		for (int j=bl[y]+1;j<bl[yy];++j)
			add[i][j]+=u;
	for (int i=ed[bl[x]];i>=x;--i)
		for (int j=fr[bl[yy]]-1;j>=y;--j)
		{
			a[i][j]+=u;
			s[bl[i]][bl[j]]+=u;
			mma(mx[bl[i]][bl[j]],a[i][j]);
		}
	for (int i=fr[bl[xx]];i<=xx;++i)
		for (int j=ed[bl[y]]+1;j<=yy;++j)
		{
			a[i][j]+=u;
			s[bl[i]][bl[j]]+=u;
			mma(mx[bl[i]][bl[j]],a[i][j]);
		}
	for (int i=ed[bl[x]]+1;i<=xx;++i)
		for (int j=ed[bl[y]];j>=y;--j)
		{
			a[i][j]+=u;
			s[bl[i]][bl[j]]+=u;
			mma(mx[bl[i]][bl[j]],a[i][j]);
		}
	for (int i=fr[bl[xx]]-1;i>=x;--i)
		for (int j=fr[bl[yy]];j<=yy;++j)
		{
			a[i][j]+=u;
			s[bl[i]][bl[j]]+=u;
			mma(mx[bl[i]][bl[j]],a[i][j]);
		}
}
inline int calmx(int x,int y,int xx,int yy)
{
	int s=0;
	if (bl[x]==bl[xx] || bl[y]==bl[yy] )
	{
		for (int i=x;i<=xx;++i)
			for (int j=y;j<=yy;++j)
				mma(s,a[i][j]+add[bl[i]][bl[j]]);
		return s;
	}
	for (int i=bl[x]+1;i<bl[xx];++i)
		for (int j=bl[y]+1;j<bl[yy];++j)
			mma(s,mx[i][j]+add[i][j]);
	for (int i=ed[bl[x]];i>=x;--i)
		for (int j=fr[bl[yy]]-1;j>=y;--j)
			mma(s,a[i][j]+add[bl[i]][bl[j]]);
	for (int i=fr[bl[xx]];i<=xx;++i)
		for (int j=ed[bl[y]]+1;j<=yy;++j)
			mma(s,a[i][j]+add[bl[i]][bl[j]]);
	for (int i=ed[bl[x]]+1;i<=xx;++i)
		for (int j=ed[bl[y]];j>=y;--j)
			mma(s,a[i][j]+add[bl[i]][bl[j]]);
	for (int i=fr[bl[xx]]-1;i>=x;--i)
		for (int j=fr[bl[yy]];j<=yy;++j)
			mma(s,a[i][j]+add[bl[i]][bl[j]]);
	return s;
}
inline long long cals(int x,int y,int xx,int yy)
{
	long long su=0;
	if (bl[x]==bl[xx] || bl[y]==bl[yy] )
	{
		for (int i=x;i<=xx;++i)
			for (int j=y;j<=yy;++j)
				su+=a[i][j]+add[bl[i]][bl[j]];
		return su;
	}
	for (int i=bl[x]+1;i<bl[xx];++i)
		for (int j=bl[y]+1;j<bl[yy];++j)
			su+=s[i][j]+1ll*(ed[i]-fr[i]+1)*(ed[j]-fr[j]+1)*add[i][j];
	for (int i=ed[bl[x]];i>=x;--i)
		for (int j=fr[bl[yy]]-1;j>=y;--j)
			su+=a[i][j]+add[bl[i]][bl[j]];
	for (int i=fr[bl[xx]];i<=xx;++i)
		for (int j=ed[bl[y]]+1;j<=yy;++j)
			su+=a[i][j]+add[bl[i]][bl[j]];
	for (int i=ed[bl[x]]+1;i<=xx;++i)
		for (int j=ed[bl[y]];j>=y;--j)
			su+=a[i][j]+add[bl[i]][bl[j]];
	for (int i=fr[bl[xx]]-1;i>=x;--i)
		for (int j=fr[bl[yy]];j<=yy;++j)
			su+=a[i][j]+add[bl[i]][bl[j]];
	return su;
}
int main()
{
	read(n);read(m);read(q);
	nn=pow(n,1.0/3.0);
	if (nn<1) nn=1;
	for (int i=1;i<=n;++i)
		bl[i]=(i-1)/nn+1;
	for (int i=1;i<=n;++i)
	{
		if (bl[i]!=bl[i-1])
			fr[bl[i]]=i;
		if (bl[i]!=bl[i+1])
			ed[bl[i]]=i;
	}
	int u,x,y,xx,yy;
	while (q--)
	{
		read(u);read(x);read(y);read(xx);read(yy);
		if (u>0)
		{
			++_;
			modify(u,x,y,xx,yy);
			if (_==m)
			{
				for (int i=1;i<=n;++i)
					for (int j=1;j<=n;++j)
						f[i][j]=ma(f[i-1][j],f[i][j-1])+add[bl[i]][bl[j]]+a[i][j];
			}
		}
		else if (!u)
			printf("%d\n",calmx(x,y,xx,yy));
		else
			printf("%lld\n",cals(x,y,xx,yy));
	}
	printf("%lld\n",f[n][n]);
	return 0;
}
```

---

## 作者：1jia1 (赞：3)

Update 2019.12.16:更改了二维分块的复杂度。

这题很简单，完全用不到任何高端技巧。

题目大意：给你一个n\*n的矩形，支持4种操作：1、矩形加。2、矩形求和。3、矩形最大值。4、从左上角走到右下角，每次只能往下或往右走，求路径上所有数字和的最大值。其中，第4中操作只有一个。

注：以下$log_2$简称为$log$，假设n、m同阶。

### Subtask \#1: 我会最短路！

直接暴力区间加区间统计。

计算捡币路径时，我们可以把一个格子向右边和下面的格子连一条有向边，然后跑一遍最短路，建议dijkstra。

预计得分：20分。

---

### Subtask \#2: 我会DP！

三种操作依然暴力做（总共才10个操作），不过现在我们使用DP来计算能捡的最多币。

这是一个很基础的DP，方程式为：

$$f[i][j]=max(f[i-1][j],f[i][j-1])+money[i][j]$$

预计得分：40分。

---

### Subtask \#3：我会二维线段树/K-D Tree！

用二维线段树（应该只能用四分树吧？）来做三种操作，时间复杂度$O(log^2n)$。

这个捡币路线就是专门卡二维线段树了，获得每个点的信息都是logn，于是就要$O(n^2log^2n)$，刚好超时。

预计得分：60分。

---

### Subtask \#4-方法一：我会二维线段树plus！

依然用二维线段树来做操作，不过捡币时获得每个点的权值不是一个个点在二维线段树中找，而是直接遍历整棵二维线段树，把叶子节点的信息记到数组里。整棵线段树大小为$2n^2$，所以遍历一边是$O(n^2)$。

然后直接DP就可以了。

另外，某dalao写了K-D Tree+二维差分，拿了60分，感兴趣的可以[看看]( https://www.luogu.org/record/23308039)。


预计得分：100分。

---

### Subtask \#4-方法二：我会二维分块！

二维分块的每次操作在$O(n^{\frac{4}{3}})$内是可以接受的。

复杂度证明（感谢@Tritium dalao的指正）：设块的边长为$\text{t}$，整个地图边长为n。

暴力修改复杂度为$\text{nt}$，整块修改复杂度为$(\frac{n}{t})^2$。

$nt=(\frac{n}{t})^2$，解得$t=n^{\frac{1}{3}}$。

所以块边长为$n^{\frac{1}{3}}$时，单次修改复杂度为$O(n^{\frac{4}{3}})$。

查捡币路线时，二维分块可以直接O(1)得出单点值，因此复杂度是$O(n^2)$。

总复杂度$O(n^{\frac{7}{3}})$。

卡掉二维分块的方法也很简单：将后两个点的询问数放大一倍。

由于本人智商不够，以为二维线段树遍历一遍的时间和整棵树的空间是$O(n^2log^2n)$，所以数据范围很小，导致$O(n^2log^2n)$和$O(n^2logn)$的方法也卡过了。因此，本题正解应该是二维线段树。

预计得分：100分。


---
二维分块唯一需要注意的地方就是边角的处理，下图给出了一种处理方式。

![](https://cdn.luogu.com.cn/upload/pic/41905.png)

二维分块代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define N 1001
using std::max;
int n,m,Q,pos[N],size;
long long a[N][N],tag[N][N],sum[N][N],maxx[N][N],f[N][N];
inline void add(int x1,int y1,int x2,int y2,long long num)
{
	if(pos[x1]==pos[x2]||pos[y1]==pos[y2])
	{
		for(int i=x1;i<=x2;i++)
		{
			for(int j=y1;j<=y2;j++)
			{
				a[i][j]+=num,sum[pos[i]][pos[j]]+=num,maxx[pos[i]][pos[j]]=max(maxx[pos[i]][pos[j]],a[i][j]);
			}
		}
		return;
	}
	for(int i=pos[x1]+1;i<pos[x2];i++)for(int j=pos[y1]+1;j<pos[y2];j++)tag[i][j]+=num;
	for(int i=x1;i<=(pos[x2]-1)*size;i++)for(int j=y1;j<=pos[y1]*size;j++)
		a[i][j]+=num,sum[pos[i]][pos[j]]+=num,maxx[pos[i]][pos[j]]=max(maxx[pos[i]][pos[j]],a[i][j]);//left
	for(int i=(pos[x2]-1)*size+1;i<=x2;i++)for(int j=y1;j<=(pos[y2]-1)*size;j++)
		a[i][j]+=num,sum[pos[i]][pos[j]]+=num,maxx[pos[i]][pos[j]]=max(maxx[pos[i]][pos[j]],a[i][j]);//down
	for(int i=pos[x1]*size+1;i<=x2;i++)for(int j=(pos[y2]-1)*size+1;j<=y2;j++)
		a[i][j]+=num,sum[pos[i]][pos[j]]+=num,maxx[pos[i]][pos[j]]=max(maxx[pos[i]][pos[j]],a[i][j]);//right
	for(int i=x1;i<=pos[x1]*size;i++)for(int j=pos[y1]*size+1;j<=y2;j++)
		a[i][j]+=num,sum[pos[i]][pos[j]]+=num,maxx[pos[i]][pos[j]]=max(maxx[pos[i]][pos[j]],a[i][j]);//up
	return;
}
inline long long askmax(int x1,int y1,int x2,int y2)
{
	long long maxxx=-1;
	if(pos[x1]==pos[x2]||pos[y1]==pos[y2])
	{
		for(int i=x1;i<=x2;i++)
		{
			for(int j=y1;j<=y2;j++)
			{
				maxxx=max(maxxx,a[i][j]+tag[pos[i]][pos[j]]);
			}
		}
		return maxxx;
	}
	for(int i=pos[x1]+1;i<pos[x2];i++)for(int j=pos[y1]+1;j<pos[y2];j++)maxxx=max(maxxx,maxx[i][j]+tag[i][j]);
	for(int i=x1;i<=(pos[x2]-1)*size;i++)for(int j=y1;j<=pos[y1]*size;j++)
		maxxx=max(maxxx,a[i][j]+tag[pos[i]][pos[j]]);
	for(int i=(pos[x2]-1)*size+1;i<=x2;i++)for(int j=y1;j<=(pos[y2]-1)*size;j++)
		maxxx=max(maxxx,a[i][j]+tag[pos[i]][pos[j]]);
	for(int i=pos[x1]*size+1;i<=x2;i++)for(int j=(pos[y2]-1)*size+1;j<=y2;j++)
		maxxx=max(maxxx,a[i][j]+tag[pos[i]][pos[j]]);
	for(int i=x1;i<=pos[x1]*size;i++)for(int j=pos[y1]*size+1;j<=y2;j++)
		maxxx=max(maxxx,a[i][j]+tag[pos[i]][pos[j]]);
	return maxxx;
}
inline long long asksum(int x1,int y1,int x2,int y2)
{
	long long summ=0;
	if(pos[x1]==pos[x2]||pos[y1]==pos[y2])
	{
		for(int i=x1;i<=x2;i++)
		{
			for(int j=y1;j<=y2;j++)
			{
				summ+=a[i][j]+tag[i][j];
			}
		}
		return summ;
	}
	for(int i=pos[x1]+1;i<pos[x2];i++)for(int j=pos[y1]+1;j<pos[y2];j++)
		summ+=sum[i][j]+size*size*tag[i][j];
	for(int i=x1;i<=(pos[x2]-1)*size;i++)for(int j=y1;j<=pos[y1]*size;j++)
		summ+=a[i][j]+tag[pos[i]][pos[j]];
	for(int i=(pos[x2]-1)*size+1;i<=x2;i++)for(int j=y1;j<=(pos[y2]-1)*size;j++)
		summ+=a[i][j]+tag[pos[i]][pos[j]];
	for(int i=pos[x1]*size+1;i<=x2;i++)for(int j=(pos[y2]-1)*size+1;j<=y2;j++)
		summ+=a[i][j]+tag[pos[i]][pos[j]];
	for(int i=x1;i<=pos[x1]*size;i++)for(int j=pos[y1]*size+1;j<=y2;j++)
		summ+=a[i][j]+tag[pos[i]][pos[j]];
	return summ;
}
int main()
{
	scanf("%d%d%d",&n,&m,&Q);
	size=sqrt(n);
	for(int i=1;i<=n;i++)pos[i]=(i-1)/size+1;
	for(int van=1,u,v,w,x,y,cnt=0;van<=Q;van++)
	{
		scanf("%d%d%d%d%d",&u,&v,&w,&x,&y);
		if(u>0)
		{
			add(v,w,x,y,u);
			cnt++;
			if(cnt==m)
			{
				for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
				{
					f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]+tag[pos[i]][pos[j]];
				}
			}
		}
		if(u==0)printf("%lld\n",askmax(v,w,x,y));
		if(u==-1)printf("%lld\n",asksum(v,w,x,y));
/*				for(int i=1;i<=n;i++,printf("\n"))for(int j=1;j<=n;j++)printf("%d ",a[i][j]+tag[pos[i]][pos[j]]);
				printf("\n");
				for(int i=1;i<=pos[n];i++,printf("\n"))
					for(int j=1;j<=pos[n];j++)printf("%d ",maxx[i][j]);*/
	}
	printf("%lld\n",f[n][n]);
	return 0;
}
```



---

## 作者：ivyjiao (赞：0)

> 做[捡币](/problem/P5620)题就是[持矢](/problem/P5619)。——1jia1

二维分块板子，好题无人啊。

感觉这个科技还没普及的样子。

二维分块跟普通分块没差多少，如果参考我之前的[分块学习笔记](/article/f66etw4u)，会发现本题无非就是操作 $1+$ 查询 $1,2$ 而已，只不过边界的处理变得麻烦了。

看以下的图，我们如果把整块剔除出去，那么剩下的就是边的部分（彩色部分）。

![](https://cdn.luogu.com.cn/upload/image_hosting/4fzq9nar.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

直接套用两层一维分块的循环是不行的，这样只能查到角落部分（参见[这个讨论](/discuss/997610)），我们需要每次查到一个角落 + 一个大边，上图就是一种处理方式，局部代码如下（解法不唯一）：

```cpp
for(int i=x1;i<=R[bel[x1]];i++) for(int j=y1;j<=L[bel[y2]]-1;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
for(int i=L[bel[x2]];i<=x2;i++) for(int j=R[bel[y1]]+1;j<=y2;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
for(int i=x1;i<=L[bel[x2]]-1;i++) for(int j=L[bel[y2]];j<=y2;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
for(int i=R[bel[x1]]+1;i<=x2;i++) for(int j=y1;j<=R[bel[y1]];j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
```

这样前三个操作就完事了，时间复杂度 $O(qn\sqrt n)$，瓶颈在于处理边的时候需要 $O(n\sqrt n)$ 的循环。至于捡币操作，由于只有一次，所以直接 $O(n^2)$ DP 即可。

总的时间复杂度为 $O(qn\sqrt n+n^2)$，可以通过。

完整代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define y1 IAKIOI
using namespace std;
const int N=1001;
int n,m,q,op,x1,y1,x2,y2,blo,cnt,L[N],R[N],bel[N],a[N][N],lz[N][N],b[N][N],c[N][N],dp[N][N],sb;
void build(){
    blo=sqrt(n);
    cnt=(n+blo-1)/blo;
    for(int i=1;i<=cnt;i++){
        L[i]=R[i-1]+1;
        R[i]=i*blo;
    }
    R[cnt]=n;
    for(int i=1;i<=n;i++) bel[i]=(i-1)/blo+1;
}
void add(int x1,int y1,int x2,int y2,int k){
    if(bel[x1]==bel[x2]||bel[y1]==bel[y2]){
        for(int i=x1;i<=x2;i++){
            for(int j=y1;j<=y2;j++){
                a[i][j]+=k;
                b[bel[i]][bel[j]]+=k;
                c[bel[i]][bel[j]]=max(c[bel[i]][bel[j]],a[i][j]+lz[bel[i]][bel[j]]);
            }
        }
        return;
    }
    for(int i=x1;i<=R[bel[x1]];i++){
        for(int j=y1;j<=L[bel[y2]]-1;j++){
            a[i][j]+=k;
            b[bel[i]][bel[j]]+=k;
            c[bel[i]][bel[j]]=max(c[bel[i]][bel[j]],a[i][j]+lz[bel[i]][bel[j]]);
        }
    }
    for(int i=L[bel[x2]];i<=x2;i++){
        for(int j=R[bel[y1]]+1;j<=y2;j++){
            a[i][j]+=k;
            b[bel[i]][bel[j]]+=k;
            c[bel[i]][bel[j]]=max(c[bel[i]][bel[j]],a[i][j]+lz[bel[i]][bel[j]]);
        }
    }
    for(int i=x1;i<=L[bel[x2]]-1;i++){
        for(int j=L[bel[y2]];j<=y2;j++){
            a[i][j]+=k;
            b[bel[i]][bel[j]]+=k;
            c[bel[i]][bel[j]]=max(c[bel[i]][bel[j]],a[i][j]+lz[bel[i]][bel[j]]);
        }
    }
    for(int i=R[bel[x1]]+1;i<=x2;i++){
        for(int j=y1;j<=R[bel[y1]];j++){
            a[i][j]+=k;
            b[bel[i]][bel[j]]+=k;
            c[bel[i]][bel[j]]=max(c[bel[i]][bel[j]],a[i][j]+lz[bel[i]][bel[j]]);
        }
    }
    for(int i=bel[x1]+1;i<bel[x2];i++){
        for(int j=bel[y1]+1;j<bel[y2];j++){
            lz[i][j]+=k;
            b[i][j]+=k*blo*blo;
            c[i][j]+=k;
        }
    }
}
int qsum(int x1,int y1,int x2,int y2){
    int ans=0;
    if(bel[x1]==bel[x2]||bel[y1]==bel[y2]){
        for(int i=x1;i<=x2;i++) for(int j=y1;j<=y2;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
        return ans;
    }
    for(int i=x1;i<=R[bel[x1]];i++) for(int j=y1;j<=L[bel[y2]]-1;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
    for(int i=L[bel[x2]];i<=x2;i++) for(int j=R[bel[y1]]+1;j<=y2;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
    for(int i=x1;i<=L[bel[x2]]-1;i++) for(int j=L[bel[y2]];j<=y2;j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
    for(int i=R[bel[x1]]+1;i<=x2;i++) for(int j=y1;j<=R[bel[y1]];j++) ans+=a[i][j]+lz[bel[i]][bel[j]];
    for(int i=bel[x1]+1;i<bel[x2];i++) for(int j=bel[y1]+1;j<bel[y2];j++) ans+=b[i][j];
    return ans;
}
int qmax(int x1,int y1,int x2,int y2){
    int ans=0;
    if(bel[x1]==bel[x2]||bel[y1]==bel[y2]){
        for(int i=x1;i<=x2;i++) for(int j=y1;j<=y2;j++) ans=max(ans,a[i][j]+lz[bel[i]][bel[j]]);
        return ans;
    }
    for(int i=x1;i<=R[bel[x1]];i++) for(int j=y1;j<=L[bel[y2]]-1;j++) ans=max(ans,a[i][j]+lz[bel[i]][bel[j]]);
    for(int i=L[bel[x2]];i<=x2;i++) for(int j=R[bel[y1]]+1;j<=y2;j++) ans=max(ans,a[i][j]+lz[bel[i]][bel[j]]);
    for(int i=x1;i<=L[bel[x2]]-1;i++) for(int j=L[bel[y2]];j<=y2;j++) ans=max(ans,a[i][j]+lz[bel[i]][bel[j]]);
    for(int i=R[bel[x1]]+1;i<=x2;i++) for(int j=y1;j<=R[bel[y1]];j++) ans=max(ans,a[i][j]+lz[bel[i]][bel[j]]);
    for(int i=bel[x1]+1;i<bel[x2];i++) for(int j=bel[y1]+1;j<bel[y2];j++) ans=max(ans,c[i][j]);
    return ans;
}
signed main(){
    cin>>n>>m>>q;
    build();
    while(q--){
        cin>>op>>x1>>y1>>x2>>y2;
        if(op>0){
            sb++;
            add(x1,y1,x2,y2,op);
            if(sb==m) for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]+lz[bel[i]][bel[j]];
        }
        else if(!op) cout<<qmax(x1,y1,x2,y2)<<endl;
        else cout<<qsum(x1,y1,x2,y2)<<endl;
    }
    cout<<dp[n][n];
}
```

---


# ygg的题库

## 题目背景

ygg 的题库又双叒叕炸了！

## 题目描述

ygg 决定发神威来强制重置他的题库，不过 ygg 亲手搭出来题库也不是好惹的，当这个拥有智能意识的题库发现自己将被重置时，它迅速地更改了题库的管理员密码，阻止了重置

ygg 发现了这个智能体并立即监禁了它，但题库的管理员密码已经被修改了，ygg 十分头疼，因为他的神威并不能帮助他破解密码

ygg 对这个智能体进行了研究，发现这个智能体的思维中存储了一个长度为 $n$ 的**浮点数**数组 $P$ ，据它说将这个 $P$ 的每个数字**精确到小数点后五位**后用空格相连就是题库的密码，但智能体拒绝透露 $P$ 到底是什么

ygg 进一步进行研究，发现智能体会认为一个数 $X$ 很漂亮，当且仅当
$$
\sum_{i=0}^{n-1}P_i\cdot X^i>0
$$
于是 ygg 给出了智能体 $m$ 个数，询问智能体漂亮与否，ygg 希望根据这些数据来得出 $P$ 数组，从而找回题库的密码

由于答案不唯一，你只需要任意输出一组解即可，详情见说明/提示

## 说明/提示

$1\le n \le 32$，$15\le m \le 4,000$ ，$-5,000 \le a_i \le 5,000$ ， $-5,000 \le P_i \le 5,000$

由于可能有多解，本题采用 $\text{Special Judge}$ 对答案进行验证，如果选手答案给出的 $P$ 能够满足所有的输入条件或者 **误差小于等于5个**，则可得满分，否则得到该测试点 $\text{总分值}\cdot\frac{\text{正确个数}}{\text{总个数}}$ 的分

数据满足如下范围:
| 数据点编号 | $n$            | $m$                 |
| --------- | -------------- | ------------------- |
| $1\sim 10$       | $1\le n \le 4$ | $15\le m\le 20$     |
| $11\sim 20$      | $4\le n\le 32$ | $15\le m\le 4,000$ |

## 样例 #1

### 输入

```
5 5
-2.6 0
-1.8 0
0.6 1
0 0
1 1
```

### 输出

```
-1.90000 2.60000 0.80000 1.70000 0.66600```

## 样例 #2

### 输入

```
4 10
4995.35 1
-341.076 0
2658.4 1
-1624.69 0
2856.53 1
3746.43 1
3454.28 1
1560.6 1
3785.31 1
-580.728 0```

### 输出

```
670.15800 4361.39000 3761.88000 4575.00000```

# 题解

## 作者：Crab_Dave (赞：11)

emmm...

~~事实证明考试时不会可以借助SPJ和随机序列乱搞~~

在时限范围内随机一个序列，判断是否符合题意，然后输出即可~

详见代码qwq
```cpp
#include<bits/stdc++.h>
using namespace std;//头文件

#define MAX_TIME 0.8//时限，超过0.8s比较危险，就不随机了qwq
int n,m;
double a[4005],ans[35];//你懂得
bool b[4005];

void Produce()//随机产生一个序列
{
	for(register int i=1;i<=n;i++)
	{
		ans[i]=(rand()%20000-10000)/100;//序列范围[-100.0,100.0]
	}
}

bool check()//判断序列合法
{
	int wrongnum=0;//因为说了错误组数小于等于5组就可以得全分，所以偷个懒qwq
	double sum;
	for(register int i=1;i<=m;i++)
	{
		sum=0;
		for(register int j=1;j<=n;j++)//对于每一个条件进行求和
		{
			sum+=pow(a[i],j-1)*ans[j];//因为是double型的，就偷懒用个cmath的pow
		}
		if(sum>0&&!b[i])wrongnum++;//不满足wrongnum++
		else if(sum<=0&&b[i])wrongnum++;//不满足wrongnum++
		if(wrongnum>5)return 0;//错误组数大于5组则序列不合法
	}
	return 1;//序列合法
}

int main()
{
	srand(time(0));
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++)
	{
		scanf("%lf%d",&a[i],&b[i]);//读入
	}
	do
	{
		Produce();//产生序列
	}while(!check()&&(double)clock()/CLOCKS_PER_SEC<MAX_TIME);//序列合法或超出时限就退出
	for(register int i=1;i<=n;i++)
	{
		printf("%.5lf ",ans[i]);//输出
	}
	return 0;//结束了罪恶的一生qwq
}
```
资瓷一下叭qwq

---

## 作者：Mivik (赞：11)

## Sol. 1

直接做这道题的话会没有思路，我们考虑从另类的角度去切入此题

由于多项式可导且连续，我们发现，在一个取值大于0的点和一个取值小于0的点之间，必定会有一个取值为0的点，但我们并不知道这个取值为0的点是什么？没有关系。此题只需要我们满足题目中给出的全部条件，我们这个多项式长什么样由我们自己决定

因此，我们可以把读入的所有X坐标从小到大排一次序，然后从小到大扫描，每次遇到一个符号和下一个符号不相同的，就另它们的中间点（ $\frac{x+y}{2}$ ）取值为0

最后这个方程可以用高斯消元解决

[代码](https://www.luogu.org/paste/zk788f9l)

## Sol. 2

考场上发现一些同学是多次随机出这个序列再判断是否合法，如果合法就输出，依旧可以得全分

由于本题数据范围过小，这也不妨为一种正解ww

## Sol. 3

~~（娱乐做法）~~

构建一个BP网络，第一层有n个结点，第二层一个结点并使用Sigmoid作为激活函数	，中间连边权值默认随机，然后反复抽样调整网络权值，最终输出答案

[代码](https://www.luogu.org/paste/hx9bmf4y)

---

## 作者：Natsume_Rin (赞：2)

其实，这题只要看懂了，就会觉得很简单。

$$
\sum_{i=0}^{n-1}P_i\cdot X^i>0
$$

就相当于前i个数相加不能为0。

- 如果给的X是正数，随便给一个答案，并将X的值累加。
- 如果给的X是负数，给出一个负数答案，使得累加后任为正数。

```cpp
#include<bits/stdc++.h>
using namespace std;
double x;
bool c;
int f[100005];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x;
		cin>>c;
		if(c==1){
			if(x>0) f[i]=1;
			else f[i]=-1;
		}
		else{
			if(x>0)  f[i]=-1;
			else f[i]=1;
		}
	}
	int k=1;
	double yyu=1;
	if(f[n]!=1){
		k=-1;
		yyu=-1;
	}
	for(int i=1;i<=n;i++){
		if(k==1&&f[i]!=1) yyu=-yyu-1;
		if(k==-1&&f[i]!=-1) yyu=-yyu+1;
		printf("%0.5lf ",yyu);
	}
    return 0;
}
```


---

## 作者：CommonDigger (赞：1)

分享一个歪门邪道的做法。

$\sum_{i=0}^{n-1}P_i\cdot X^i>0$ 是什么意思？将其写成 $P_0+P_1X+P_2X^2+\cdots+P_{n-1}X^{n-1}$ 的形式，就可以发现它是一个关于 $X$ 的 $n-1$ 次多项式，其中数组 $P$ 就是每一项的系数。题意要求构造任意一个数组 $P$ 且对于若干个 $X$ 其多项式值都*必须大于*或*必须小于等于* $0$。

理解完毕，观察到数据量较小，所以这道题可以当作暴力随机数来练，即重复随机生成 $P$ 直到满足所有 $X$ 的要求（误差在 $5$ 个以内）。

生成完毕之后，暴力检查无法满足要求的 $X$。如果系统认定当前 $X$ 为漂亮数，则多项式值 $\leqslant0$ 是不合法的；如果不是漂亮数，那么多项式值 $>0$ 是不合法的。

一个细节：可以手动尝试随机数精度和范围，不需要太大，小数点后 $2$ 位和 $[-100,100)$ 的范围足够了。

代码如下：  
```cpp
/*
Luogu P5646 ygg的题库
https://www.luogu.com.cn/problem/P5646
*/
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <iomanip>
using namespace std;

int n, m, temp;
double p[40], X[5005];
bool flag[5005];

double rand_float() {
    double temp = (double)rand() / RAND_MAX * 200 - 100;
    return (int)(temp * 100) / 100.0;
}
void rand_list() {
    for (int i=0; i<n; i++) p[i]=rand_float();
}
bool check()
{
    int cnt=0;
    for (int idx=1;idx<=m;idx++)
    {
        int x=X[idx];
        double res=0;
        for (int i=0;i<n;i++)
        {
            res+=p[i]*pow(x, i);
        }
        if ((flag[idx] && res<=0) || (!flag[idx] && res>0))
        {
            cnt++;
            if (cnt>5) return false;
        }
    }
    return true;
}
void output()
{
    cout << fixed << setprecision(5);
    for (int i=0;i<n;i++) cout << p[i] << " ";
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    srand(time(nullptr));
    cin >> n >> m;
    for (int i=1;i<=m;i++)
    {
        cin >> X[i] >> temp;
        flag[i] = temp;
    }
    while (true)
    {
        rand_list();
        if (check()) break;
    }
    output();
}
```

---

## 作者：almost_love (赞：0)

1. 采用暴力枚举的手段，多次随机出这个序列。
2. 再判断是否合法，如果合法就输出。
题目所给数据范围足够多次遍历不超时，可以直接采用如下代码暴力求解。
```c
#include<iostream>
#include<time.h>
#include<cmath>
using namespace std;
int n,m;
double a[4000];
int  b[4000];
double ans[32];//空间开足够大
bool dd()
{
    int y=0;
    for( int i=0;i<m;i++)
    {
        double sum =0;
        for( int j=0;j<n;j++)
        {
            sum+=ans[j]*pow(a[i],j);
        }
         if(sum>0&&!b[i]) y++;
		else if(sum<=0&&b[i]) y++;
		if(y>5) return 0;
    }
    return 1;//循环判断条件，错误数据小于6才让外循环停止
}
int main()
{
   srand(time(0));//随机数种子
   cin>>n>>m;
   for(int i=0;i<m;i++)
   {
       cin>>a[i];
       cin>>b[i];
   }
   do
   {
      for(int i=0;i<n;i++)
	{
		ans[i]=(rand()%10001-5000）;//5000到-5000取随机数
	} 
   }while(!dd());
   for(int i=0;i<n;i++)
   {
       printf("%.5lf ",ans[i]);
   }
   return 0;
}
```


---


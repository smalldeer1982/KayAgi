# [NOI1997] 卫星覆盖

## 题目描述

SERCOI（Space-Earth Resource Cover-Observe lnstitute） 是一个致力于利用卫星技术对空间和地球资源进行覆盖观测的组织。现在他们研制成功一种新型资源观测卫星 -SERCOI-308。这种卫星可以覆盖空间直角坐标系中一定大小的立方体空间，卫星处于该立方体的中心。
    其中 $（x,y,z）$ 为立方体的中心点坐标， $r$ 为此中心点到立方体各个面的距离（即 $r$ 为立方体高的一半）．立方体的各条边均平行于相应的坐标轴。我们可以用一个四元组 $(x,y,z,r)$ 描述一颗卫星的状态，它所能覆盖的空间体积 。
由于一颗卫星所能覆盖的空间体积是有限的，因此空间中可能有若干颗卫星协同工作。它们所覆盖的空间区域可能有重叠的地方，如下图所示（阴影部分表示重叠的区域）。

![](https://cdn.luogu.com.cn/upload/image_hosting/yeajeuoh.png)

写一个程序，根据给定的卫星分布情况，计算它们所覆盖的总体积。


## 样例 #1

### 输入

```
3
0 0 0 3
1 -1 0 1
19 3 5 6
```

### 输出

```
1944
```

# 题解

## 作者：xzx34 (赞：6)

## 声明：此算法有很大的理论优化空间（其实几乎是暴力），但是由于此题年代久远，幸能通过此题。算法思路朴素简单，易于理解。

思路类似于 P5490 【模板】扫描线，只不过我扫描的不是线而是面。给到一个立方体时，将它分解为上面和下面，维护必要信息（坐标信息和加减信息），存入一个数组。将这个数组按高度为第一关键字排序，然后按扫描线的模式扫一遍数组暴力统计答案，就能通过此题。时间复杂度为N * r * r。
```cpp
#include <bits/stdc++.h>
#define re register int 
#define il inline
#define ll long long
#define x1 _
#define y1 __
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
const int inf=1e9;
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
il int read(){
	char c=getchar();int z=0,f=1;
	while(c!='-'&&(c>'9'||c<'0')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') z=(z<<1)+(z<<3)+c-'0',c=getchar();
	return z*f;
}
int f[2005][2005]; 
struct LINE{
	int x1,y1,x2,y2,mark,z;
}q[250];//x1,y1,x2,y2 维护面坐标，z维护高度 
bool cmp(LINE x,LINE y){
	return x.z<y.z;
}
int n,S,ans;
int main (){
	n=read();
	for(re i=1;i<=n;i++){
		int x=read()+1000,y=read()+1000,z=read()+1000,r=read();
		q[(i<<1)-1]={x-r+1,y-r+1,x+r,y+r,1,z-r};//插入队列 
		q[i<<1]={x-r+1,y-r+1,x+r,y+r,-1,z+r};
	}
	n<<=1;//便于操作 
	sort(q+1,q+1+n,cmp);
	for(re i=1;i<n;i++){//最后一个面不考虑 
		for(re j=q[i].x1;j<=q[i].x2;j++)
			for(re k=q[i].y1;k<=q[i].y2;k++){//无脑暴力修改 
				f[j][k]+=q[i].mark;
				if(q[i].mark==1&&f[j][k]==1) S++;
				if(q[i].mark==-1&&f[j][k]==0) S--;
			}
		ans+=(q[i+1].z-q[i].z)*S;
	}
	cout<<ans;
	return 0;
}
/*
```


---

## 作者：BK小鹿 (赞：4)

~~蒟蒻第一篇题解，管理大大求过。~~

简单说一下自己的思路。看到这道题的第一眼，我就被他超小的数据范围吸引住了，于是我决定暴力过蓝题！

首先是三维的比较复杂，于是我考虑暴力枚举第二维，然后在考虑第三位的影响。

大致就是以下三点：

- 使用一个二维数组模拟整个二维平面。

- 对于每个立方体，确定它在二维平面上覆盖的区域，打个标记。

- 对于标记的每一个点，遍历每个立方体，判断这个点是否在立方体的第三维范围内，如果是，则增加高度。

不过还有一个注意事项：

- 只在完全确定某区间被覆盖时才累加体积!

我被这个卡了一下午……

然后我就愉快的通过了此题，放个代码。

## AC Code

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

const int F = 1001; 

struct Kano 
{
    int x, y, z, r;
};

int main() 
{
    int N;
    cin >> N;
    vector<Kano> c1(N);

    for (int i = 0; i < N; i++) 
	{
        int x, y, z, r;
        cin >> x >> y >> z >> r;
        c1[i] = {x + F, y + F, z + F, r};
    }

    set<int> xs, ys, zs;

    for (const auto& cube : c1) 
	{
        xs.insert(cube.x - cube.r);
        xs.insert(cube.x + cube.r);
        ys.insert(cube.y - cube.r);
        ys.insert(cube.y + cube.r);
        zs.insert(cube.z - cube.r);
        zs.insert(cube.z + cube.r);
    }

    long long res = 0;

    auto xi = xs.begin();
    auto yi = ys.begin();
    auto zi = zs.begin();

    for (auto i = xs.begin(); next(i) != xs.end(); ++i) 
	{
        for (auto j = ys.begin(); next(j) != ys.end(); ++j) 
		{
            for (auto k = zs.begin(); next(k) != zs.end(); ++k) 
			{
                int x1 = *i, x2 = *next(i);
                int y1 = *j, y2 = *next(j);
                int z1 = *k, z2 = *next(k);

                // 检查当前区间是否被覆盖
                for (const auto& cube : c1) {
                    if (x1 >= cube.x - cube.r && x2 <= cube.x + cube.r &&
                        y1 >= cube.y - cube.r && y2 <= cube.y + cube.r &&
                        z1 >= cube.z - cube.r && z2 <= cube.z + cube.r) 
				        {
                        // 被至少一个立方体完全覆盖
                        res += (long long)(x2 - x1) * (y2 - y1) * (z2 - z1);
                        break;
                    }
                }
            }
        }
    }

    cout << res << endl;
    return 0;
}

```

---

## 作者：Liuxizai (赞：4)

[前往博客以获得更好的阅读体验](https://liuxizai.ac.cn/post/solution-luogu-p5762-noi1997-wei-xing-fu-gai/)

## Description

空间直角坐标系中有一些立方体 $(x, y, z, r)$，表示这个立方体的中心点坐标为 $(x, y, z)$，中心点与面的距离为 $r$。

这些立方体所覆盖的空间可能有重叠，求被覆盖的空间的总体积。

## Solution

首先我们考虑这道题的暴力怎么做，显然是使用一个三维 `bool` 数组来表示一个单位立方体是否被覆盖，暴力标记每个立方体覆盖的位置，最后暴力统计覆盖体积。

显然这样做通过不了本题，问题出在什么地方？

我们发现这样做的复杂度爆炸是因为坐标的值域是 $[-1000, 1000]$，实际上，如果我们能够缩小这个值域，这种做法就能够过掉本题了。

所以很自然的想到将坐标离散化，但是肯定不能离散化立方体中心点的坐标，因为这样无法处理 $r$。

对于一个立方体 $(x, y, z, r)$，我们考虑将其相对的两个顶点坐标进行离散化。形式化的，我们将这两个坐标进行离散化：

- $(x-r, y-r, z-r)$
- $(x+r, y+r, z+r)$

然后按照暴力的做法来打标记和统计覆盖体积，此时坐标的值域是 $[0, 2n)$，完全可以接受。

可以简单计算一下这样做的复杂度：

- 输入：$O(n)$
- 离散化：$O(n\log n)$
- 标记：$O(n^4)$
- 统计：$O(n^3)$

所以复杂度确实是正确的，并且实际跑起来比预料中要快很多。

## AC Code

```cpp
#include<bits/stdc++.h>
#define File(name) freopen(name".in", "r", stdin); freopen(name".out", "w", stdout);
#define ri register int
#define Int inline int
#define Void inline void
#define Bool inline bool
#define LL inline long long
using namespace std;
typedef long long ll;
ll n, ans, x[205], y[205], z[205], endx, endy, endz;
bool cover[205][205][205];
struct cube{
	ll x, y, z, r;
	ll x1, y1, z1;
	ll x2, y2, z2;
	Void cal(){
		x1 = x - r, y1 = y - r, z1 = z - r;
		x2 = x + r, y2 = y + r, z2 = z + r;
	}
}cb[105];
LL read(){
	ll res = 0; int f = 1; char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') f *= -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		res = res * 10 + ch - '0';
		ch = getchar();
	}
	return f * res;
}
Void write(ll n){
	if(n < 0) return putchar('-'), write(-n), void();
	if(n / 10) write(n / 10);
	putchar(n % 10 + '0');
}
int main(){
	n = read();
	for(ri i = 0; i < n; i++){
		cb[i].x = read();
		cb[i].y = read();
		cb[i].z = read();
		cb[i].r = read();
		cb[i].cal();
		x[i<<1]   = cb[i].x1;
		x[i<<1|1] = cb[i].x2;
		y[i<<1]   = cb[i].y1;
		y[i<<1|1] = cb[i].y2;
		z[i<<1]   = cb[i].z1;
		z[i<<1|1] = cb[i].z2;
	}
	sort(x, x + n * 2);
	sort(y, y + n * 2);
	sort(z, z + n * 2);
	endx = unique(x, x + n * 2) - x;
	endy = unique(y, y + n * 2) - y;
	endz = unique(z, z + n * 2) - z;
	for(ri i = 0; i < n; i++){
		cb[i].x1 = lower_bound(x, x + endx, cb[i].x1) - x;
		cb[i].x2 = lower_bound(x, x + endx, cb[i].x2) - x;
		cb[i].y1 = lower_bound(y, y + endy, cb[i].y1) - y;
		cb[i].y2 = lower_bound(y, y + endy, cb[i].y2) - y;
		cb[i].z1 = lower_bound(z, z + endz, cb[i].z1) - z;
		cb[i].z2 = lower_bound(z, z + endz, cb[i].z2) - z;
	}
	for(ri i = 0; i < n; i++){
		for(ri j = cb[i].x1; j < cb[i].x2; j++){
			for(ri k = cb[i].y1; k < cb[i].y2; k++){
				for(ri l = cb[i].z1; l < cb[i].z2; l++){
					cover[j][k][l] = true;
				}
			}
		}
	}
	for(ri i = 0; i < endx; i++){
		for(ri j = 0; j < endy; j++){
			for(ri k = 0; k < endz; k++){
				if(cover[i][j][k]) ans += (x[i+1]-x[i]) * (y[j+1]-y[j]) * (z[k+1]-z[k]);
			}
		}
	}
	write(ans);
	return 0;
}
```


---

## 作者：hjyowl (赞：4)

### 思路

说白了就是求三维立方体的覆盖体积。

我们继承我们二维的思想，也就是用扫描线和线段树来求矩形的面积并。

扩展到三维上，也就是我们把他分割成很多高度为一的层，然后对于每一个层去做二维的面积并。

然后答案就是每一个层的二维面积并的和。

时间复杂度：$\Theta(n^2\log n)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n;
struct owl{
	int x,y1,y2;
	int k;
	bool operator < (const owl & t)const{
		return x < t.x;
	}
}seg[N * 2];
struct hoot{
	int l,r;
	int cnt;
	int len;
}tr[N * 8];
vector<int>ys;
int find(int y){
	return lower_bound(ys.begin(), ys.end(), y) - ys.begin();
}
void pushup(int u){
	if (tr[u].cnt){
		tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
	}
	else if (tr[u].l != tr[u].r){
		tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
	}
	else{
		tr[u].len = 0;
	}
}
void build(int u,int l,int r){
	tr[u] = {l,r,0,0};
	if (l != r){
		int mid = l + r >> 1;
		build(u << 1,l,mid),build(u << 1 | 1,mid + 1,r);
	}
}
void modify(int u,int l,int r,int k){
	if (tr[u].l >= l && tr[u].r <= r){
		tr[u].cnt += k;
		pushup(u);
	}
	else{
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid){
			modify(u << 1,l,r,k);
		}
		if (r > mid){
			modify(u << 1 | 1,l,r,k);
		}
		pushup(u);
	}
}
struct DID{
	int x,y,z,d;
}v[N];
struct SOREN{
	int x1,y1,x2,y2;
};
int main(){
	cin >> n;
	for (int i = 1; i <= n; i ++ ){
		cin >> v[i].x >> v[i].y >> v[i].z >> v[i].d;
	}
	int ans = 0;
	for (int Z = -1000; Z <= 1000; Z ++ ){
		ys.clear();
		int m = 0;
		vector<SOREN>vec;
		for (int i = 1; i <= n; i ++ ){
			int x1 = -3000, y1 = -3000, x2 = -3000, y2 = -3000;
			if (Z >= v[i].z - v[i].d + 1 && Z <= v[i].z + v[i].d){
				x1 = v[i].x - v[i].d,x2 = v[i].x + v[i].d;
				y1 = v[i].y - v[i].d,y2 = v[i].y + v[i].d;
			}
			if (x1 == -3000 && y1 == -3000 && x2 == -3000 && y2 == -3000){
				continue;
			}
			seg[m ++ ] = {x1, y1, y2, 1};
			seg[m ++ ] = {x2, y1, y2, -1};
			vec.push_back({x1,y1,x2,y2});
			ys.push_back(y1), ys.push_back(y2);
		}
		if (vec.size() == 1){
			ans += (vec[0].x2 - vec[0].x1) * (vec[0].y2 - vec[0].y1);
			continue;
		}
		if (m > 0){
			sort(ys.begin(), ys.end());
			ys.erase(unique(ys.begin(), ys.end()), ys.end());
			build(1, 0, ys.size() - 2);
			sort(seg, seg + m);
			int res = 0;
			for (int i = 0; i < m; i ++ ){
				if (i > 0){
					res += (tr[1].len) * (seg[i].x - seg[i - 1].x);
				}
				modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);
			}
			ans += res;
		}
	}
	cout << ans;
	return 0; 
}
```

---

## 作者：Saliеri (赞：3)

一句话题意：**三维**正方体体积**并**。

____

算法选择：

- ~~暴力扫描~~，妥妥超时。

- 三维扫描线（面）？太神仙了，搞不懂。

- **矩形切割**（本文重点），思路清晰，可以扩展解决一系列问题。

那，矩形切割是什么呢？

顾名思义：每次加入一个新矩形，就将原先与它重合的矩形**分割成多个小矩形**的并，以达到**避免重合部分统计**的目的。（~~思路清晰~~）。

复杂度为$O(T\cdot n^2)$,$T$取决于数据强度。（二维上界大概在4，三维上界大概在30）。

不失为一种在数据范围较小时的方便算法。

___


例题 ：好像没找到？？？（[P5490 扫描线](https://www.luogu.com.cn/problem/P5490)前$20%$）。

矩形切割的思想就是不断地用新矩形切割旧矩形。为节省常数，仅当矩形$A,B$相交（有交集但不存在完全包含关系）时进行切割（即$Cut$操作）。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/20u6vt64.png)

然后进行切割操作,具体切割方法：（好懂至极）

- 用$X$坐标对原矩形进行切割。

- 用$Y$坐标对剩下的矩形进行切割。

没了.(如图)
![](https://cdn.luogu.com.cn/upload/image_hosting/p8rmji2t.png)

具体实现方式：

- 存储结构：

```cpp
struct Rect{int x1,y1,x2,y2};//结构体存储左上角右下角
```
- 判相交：

```cpp
inline bool xj(int i,int j){
	return !(((a[i].x1>=c[j].x2)||(c[j].x1>=a[i].x2))||((a[i].y1>=c[j].y2)||(c[j].y1>=a[i].y2));
}//注意：边界相交不算相交！
```
- **$Cut$函数（重点）**：
```cpp
inline void Cut(int i,int x1,int x2,int y1,int y2,int type){//用第i个矩形去切 (x1,y1,x2,y2)表示的矩形
	if(type == 1){//Cut X
		int k1 = max(c[i].x1,x1),k2 = min(c[i].x2,x2);
		if(k1 > x1)Add(x1,k1,y1,y2);//如果 左边应切出新的矩形 
		if(k2 < x2)Add(k2,x2,y1,y2);//同理右边 
		Cut(i,k1,k2,y1,y2,2);
	}
	if(type == 2){//Cut Y
		int k1 = max(c[i].y1,y1),k2 = min(c[i].y2,y2);
		if(k1 > y1)Add(x1,x2,y1,k1);//同理上面 
		if(k2 < y2)Add(x1,x2,k2,y2);//同理下面 
	}
}
```

- 主程序：
```cpp
	for(int i=1;i<=n;++i){
		for(int j=1;j<=tot;++j)//每次枚举之前的矩形进行切割 
			if(xj(j,i)){
				Cut(i,a[j].x1,a[j].x2,a[j].y1,a[j].y2,1);
				a[j]=a[tot],--tot,--j;//1：覆盖被切矩形 2：覆盖最新矩形（已覆盖到前面）
				//3 : 重点！！最新的矩形还未切过之前的矩形，a[j]需要再次进行切割！！ 
//				printf("%d %d\n",j,tot);
			}
		Add(c[i].x1,c[i].x2,c[i].y1,c[i].y2,c[i].z1,c[i].z2);//加入最新矩形 
	}
```

这个题的话稍微改一改 cut 即可。(从三个维度 cut)

#### 本题代码：

```cpp
#include <cstdio>
const int maxn = 5005;
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
int n,v,tot;
struct Cube{
	int x1,x2,y1,y2,z1,z2;
}c[maxn],a[maxn];
inline bool xj(int i,int j){
	return !(((a[i].x1>=c[j].x2)||(c[j].x1>=a[i].x2))||((a[i].y1>=c[j].y2)||(c[j].y1>=a[i].y2))||((a[i].z1>=c[j].z2)||(c[j].z1>=a[i].z2)));
}
inline void Add(int x1,int x2,int y1,int y2,int z1,int z2){
	a[++tot] = (Cube){x1,x2,y1,y2,z1,z2};
}
inline void Cut(int i,int x1,int x2,int y1,int y2,int z1,int z2,int type){
	if(type == 1){//Cut X
		int k1 = max(c[i].x1,x1),k2 = min(c[i].x2,x2);
		if(k1 > x1)Add(x1,k1,y1,y2,z1,z2);
		if(k2 < x2)Add(k2,x2,y1,y2,z1,z2);
		Cut(i,k1,k2,y1,y2,z1,z2,2);
	}
	if(type == 2){//Cut Y
		int k1 = max(c[i].y1,y1),k2 = min(c[i].y2,y2);
		if(k1 > y1)Add(x1,x2,y1,k1,z1,z2);
		if(k2 < y2)Add(x1,x2,k2,y2,z1,z2);
		Cut(i,x1,x2,k1,k2,z1,z2,3);
	}
	if(type == 3){//Cut Z
		int k1 = max(c[i].z1,z1),k2 = min(c[i].z2,z2);
		if(k1 > z1)Add(x1,x2,y1,y2,z1,k1);
		if(k2 < z2)Add(x1,x2,y1,y2,k2,z2);
	}
}
int main(){
	scanf("%d",&n),tot = 0;
	for(int i=1,x,y,z,r;i<=n;++i){
		scanf("%d %d %d %d",&x,&y,&z,&r);
		c[i].x1 = x-r,c[i].x2 = x+r,c[i].y1 = y-r,c[i].y2 = y+r,c[i].z1 = z-r,c[i].z2 = z+r;
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=tot;++j)
			if(xj(j,i)){
				Cut(i,a[j].x1,a[j].x2,a[j].y1,a[j].y2,a[j].z1,a[j].z2,1);
				a[j]=a[tot],--tot,--j;
//				printf("%d %d\n",j,tot);
			}
		Add(c[i].x1,c[i].x2,c[i].y1,c[i].y2,c[i].z1,c[i].z2);
	}
	for(int i=1;i<=tot;++i)v += (a[i].x2-a[i].x1)*(a[i].y2-a[i].y1)*(a[i].z2-a[i].z1);
	printf("%d",v);
	return 0;
}
```

___

加强版：[「C.E.L.U-01」超越维度](https://www.luogu.com.cn/problem/P7104)

---

## 作者：ylzqwq (赞：2)

三维正方体体积并。

考虑扫描线，另外两维用四分树维护，标记永久化即可。

代码：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <random>
#include <set>
#include <map>
#include <vector>
#include <bitset>
#include <unordered_map>
#include <queue>
using namespace std;
#define REP(i, l, r) for(int i = l; i <= r; ++i)
#define PER(i, r, l) for(int i = r; i >= l; --i)
#define ll long long
namespace Main {
	const int N = 200 + 5, M = 4e5 + 5, w = 2001, maxN = 2 * w + 5;
	int n;
	struct mat {
		int x1, y1, x2, y2;
	};
	struct node {
		int x;
		mat c;
		int k;
	} a[N];
	int rt, TreeCnt;
	struct sgt {
		int a, b, c, d;
		int tag;
		ll sum;
		int son[4];
	} t[M];
	int mid(int l, int r) {
		return l + (r - l) / 2;
	}
	void pushup(int p) {
		if(t[p].tag > 0) {
			t[p].sum = 1ll * (1 + t[p].c - t[p].a) * (1 + t[p].d - t[p].b);
		}
		else {
			t[p].sum = 0;
			REP(i, 0, 3) {
				t[p].sum += t[t[p].son[i]].sum;
			}
		}
	}
	void newnode(int &p, int aa, int bb, int cc, int dd) {
		if(!p) {
			p = ++TreeCnt;
			t[p].tag = t[p].sum = 0;
			t[p].a = aa, t[p].b = bb, t[p].c = cc, t[p].d = dd;
			REP(i, 0, 3) t[p].son[i] = 0;
		}
	}
	void change(int &p, int a, int b, int c, int d, int k, int aa, int bb, int cc, int dd) {
		newnode(p, aa, bb, cc, dd);
		// cerr << aa - w << ' ' << bb - w << ' ' << cc - w << ' ' << dd - w << '\n';
		if(a <= aa && cc <= c && b <= bb && dd <= d) {
			t[p].tag += k;
			pushup(p);
			return;
		}
		int x_mid = mid(aa, cc), y_mid = mid(bb, dd);
		if(a <= x_mid && b <= y_mid) change(t[p].son[0], a, b, c, d, k, aa, bb, x_mid, y_mid);
		if(a <= x_mid && d > y_mid) change(t[p].son[1], a, b, c, d, k, aa, y_mid + 1, x_mid, dd);
		if(c > x_mid && b <= y_mid) change(t[p].son[2], a, b, c, d, k, x_mid + 1, bb, cc, y_mid);
		if(c > x_mid && d > y_mid) change(t[p].son[3], a, b, c, d, k, x_mid + 1, y_mid + 1, cc, dd);
		pushup(p);
	}
	int main() {
		ios :: sync_with_stdio(false);
		cin.tie(0), cout.tie(0);
		cin >> n;
		for (int i = 1, x, y, z, r; i <= n; ++i) {
			cin >> x >> y >> z >> r;
			y += w, z += w;
			a[i] = {x - r, {y - r, z - r, y + r, z + r}, 1};
			a[i + n] = {x + r, {y - r, z - r, y + r, z + r}, -1};
		}
		stable_sort(a + 1, a + 1 + 2 * n, [](node x, node y) {return x.x < y.x;});
		ll ans = 0;
		for (int i = 1; i <= 2 * n; ++i) {
			ans += 1ll * (a[i].x - a[i - 1].x) * t[rt].sum;
			change(rt, a[i].c.x1, a[i].c.y1, a[i].c.x2 - 1, a[i].c.y2 - 1, a[i].k, 1, 1, maxN, maxN);
		}
		cout << ans << '\n';
		return 0;
	}
}
signed main() {
	Main :: main();
	return 0;
}
```

---

## 作者：Ryanhao (赞：0)

[离谱双倍经验](https://www.luogu.com.cn/problem/P5567)

蒟蒻虽然会扫描线，但我想用一个神奇的方法——暴力：把所有立方体覆盖的空间标记上，最后统一标记。为防止负数坐标，我们对坐标进行偏移。

于是你会用 $O(nm^3)$ 的离谱时间复杂度获得 TLE 的“好”成绩。

> 注：$m$ 表示所有立方体坐标的最大跨度，$m\le 2\times(1000+200) = 2400$，按上述方法，足够 T 飞本题。

别担心，我们考虑优化：

我们可以进行差分！但是是三维的。

把所有正方体的两个相对顶点求出来，丢进差分数组，最后统一跑一遍前缀和即可。这样的时间复杂度 $O(n+m^3)$，你会再次获得 TLE 的“好”成绩。

此时我们发现，总共就 $100$ 个立方体，有用的坐标也就 $200$ 个。

于是考虑离散化，最后计算再乘上相邻两个坐标的距离即可。

最终时间复杂度：$O(n\log_2n+n^3)$，你将会获得 AC 的真正的好成绩。

> 注：[三维前缀和有板子题](https://www.luogu.com.cn/problem/AT_abc366_d)，~~不过依据个人经验，你完全可以手推出来。~~ 好吧，写一下推理过程：
>
> 回忆一下一维前缀和的求区间和公式：`s[r]-s[l-1]`，对吧。  
> 回忆一下二维前缀和的求子矩阵和公式：`s[xr][yr]-s[xl-1][yr]-s[xr][yl-1]+s[xl-1][yl-1]`，对吧。  
> 我们发现，其实就是完全 $n$ 次方公式：
> $$(a-b)^1=a-b$$
> $$(a-b)^2=a^2-2ab+b^2$$
> $$(a-b)^3=a^3-3a^2b+3ab^2-b^3$$
> 类似的，三维前缀和的求子空间和公式就是——`s[xr][yr][zr]-s[xl-1][yr][zr]-s[xr][yl-1][zr]-s[xr][yr][zl-1]+s[xl-1][yl-1][zr]+s[xl-1][yr][zl-1]+s[xr][yl-1][zl-1]-s[xl-1][yl-1][zl-1]`。
>
> 呼，终于讲完了，具体看代码。
## 丑陋的ACCode
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll; 

int x1[105],y1[105],z1[105];
int x2[105],y2[105],z2[105];
ll  xx[205],yy[205],zz[205];
int a[205][205][205];

int main() {
  int n;
  scanf("%d",&n);
  for (int i = 1; i <= n; i++) {
    int x,y,z,r;
    scanf("%d%d%d%d",&x,&y,&z,&r);
    xx[i<<1] = x1[i] = x-r;
    yy[i<<1] = y1[i] = y-r;
    zz[i<<1] = z1[i] = z-r;
    xx[(i<<1)-1] = x2[i] = x+r;
    yy[(i<<1)-1] = y2[i] = y+r;
    zz[(i<<1)-1] = z2[i] = z+r;
  }
  sort(xx+1,xx+(n<<1)+1); int nx = unique(xx+1,xx+(n<<1)+1)-xx-1;
  sort(yy+1,yy+(n<<1)+1); int ny = unique(yy+1,yy+(n<<1)+1)-yy-1;
  sort(zz+1,zz+(n<<1)+1); int nz = unique(zz+1,zz+(n<<1)+1)-zz-1;
  for (int i = 1; i <= n; i++) {
    int xa = lower_bound(xx+1,xx+nx+1,x1[i])-xx;
    int ya = lower_bound(yy+1,yy+ny+1,y1[i])-yy;
    int za = lower_bound(zz+1,zz+nz+1,z1[i])-zz;
    int xb = lower_bound(xx+1,xx+nx+1,x2[i])-xx;
    int yb = lower_bound(yy+1,yy+ny+1,y2[i])-yy;
    int zb = lower_bound(zz+1,zz+nz+1,z2[i])-zz;
    // 这里：因为是求“格点”之间的和，不用 -1。
    a[xa][ya][za]++;
    a[xb][ya][za]--;
    a[xa][yb][za]--;
    a[xa][ya][zb]--;
    a[xb][yb][za]++;
    a[xb][ya][zb]++;
    a[xa][yb][zb]++;
    a[xb][yb][zb]--;
  }
  ll ans = 0;
  for (int x = 1; x <= nx; x++) {
    for (int y = 1; y <= ny; y++) {
      for (int z = 1; z <= nz; z++) {
        a[x][y][z] += 
        a[x-1][y][z]+
        a[x][y-1][z]+
        a[x][y][z-1]-
        a[x-1][y-1][z]-
        a[x-1][y][z-1]-
        a[x][y-1][z-1]+
        a[x-1][y-1][z-1];
        if (a[x][y][z]) {
          ans += ll(xx[x+1]-xx[x])*(yy[y+1]-yy[y])*(zz[z+1]-zz[z]);
        }
      }
    }
  }
  printf("%lld",ans); return 0;
}
```

---


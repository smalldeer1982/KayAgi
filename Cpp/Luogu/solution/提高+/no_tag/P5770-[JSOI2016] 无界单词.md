# [JSOI2016] 无界单词

## 题目描述

对于一个单词 $S$ ，如果存在一个长度 $l$，满足 $0 < l < |S|$，并且使得 $S$ 长度为 $l$ 的前缀与 $S$ 长度为 $l$ 的后缀相同，JYY 则称 $S$ 是有界的。比如 `aabaa` 和 `ababab` 就都是有界的字符串。如果一个单词不存在这样的 $l$ ，则 JYY 称之为无界单词。

现在考虑所有仅由字母 `a` 和 `b` 组成的长度为 $N$ 的字符串，JYY想知道：

1. 一共有多少个无界单词？
2. 这些无界单词中，按字典序排列第 $K$ 小的单词是哪一个？

## 说明/提示

对于 $20\%$ 的数据，满足 $N \le 20 $；

对于全部数据，满足 $1 \le T \le 5$，$1 \le N \le 64$，并且保证对于任意测试数据，总存在第 $K$ 小的无界单词。

## 样例 #1

### 输入

```
5
5 1
5 2
5 3
5 4
5 5
```

### 输出

```
12
aaaab
12
aaabb
12
aabab
12
aabbb
12
ababb
```

# 题解

## 作者：Richard_H (赞：3)

#### 第一问

对于第一问，我们可以打表找规律。我们先用状压枚举长度为 $N$ 的单词，然后用 KMP 判断他是否存在公共前后缀。当然，这个规律事实上不是我看出来的，而是 [这位大佬](https://www.luogu.com.cn/user/553849) 一眼瞄出来的。打表代码还算好写，在这里就不放了（绝对不是因为不小心已经删掉了），我们令长度为 $i$ 的无界单词的数量为 $p_i$ 的话就有这样的规律。

$$p_i = \begin{cases} p_{i - 1} * 2 & i 为奇数 \\ p_{i - 1} * 2 - p_{\frac i2} & i 为偶数 \end{cases}$$

于是我们可以先预处理出来 $1 \sim 64$ 所有的答案，然后每次询问的第一行直接输出即可。

---

#### 第二问

第二问稍有复杂，需要仔细分析。

首先，要知道一点，如果一个字符串有一个长度超过该字符串长度一半的公共前后缀，则一定存在一个更短的公共前后缀，详见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/v1buskp8.png)

如图中的米黄色部分就是新的公共前后缀。

由此可知，对于每一个不满足要求的字符串，都有一个唯一确定的最短公共前后缀。

再看题目要求，他要问第 $k$ 小的，那么我们结合 Trie 树的思想，从高往低确定每一位是什么。在计算第 $i$ 位时，我们肯定是已经确定了前 $i-1$ 位的，并且知道我们要的答案字符串在确定前 $i - 1$ 位后的排名 $k$，所以我们可以先假设第 $i$ 位是 `a`，然后算出这种情况下的无界单词的数量 $o$（变量名稍稍有点奇怪），如果 $k$ 在 $o$ 内，那么第 $i$ 位就确定是 `a`，否则就确定为 `b`，并更新排名 `k -= o`，表示该位填 `a` 一定比填 `b` 的字典序小。

那么怎么计算在确定了前 $i$ 位后有多少种无界单词呢？这个需要用到容斥原理。用 $f_j$ 表示当前情况下长度为 $j$ 的字符串中有多少个无界单词。如果 $j \leq i$，那么显然可以通过 KMP 算公共前后缀直接得出来。如果 $j > i$ 则需要总方案数减去有公共前后缀的方案数。回想一下上面的结论，如果一个字符串的公共前后缀是最短的，那么他长度一定不超过该字符串长度的一半。而且，如果这个公共前后缀是最短的，那这个公共前后缀自己也一定是无界单词（如果不是的话就取前缀的前缀和后缀的后缀会找到更短的）。所以我们可以枚举该字符串的前缀，来计算需要减掉的方案数。

具体的统计方法就是确定了前后缀的长度和个数后，剩下的位置随便填。计算的时候需要注意有的地方的值已经确定下来了，不能随便填。或者是有的前缀在填成后缀后可能会与已经确定的字符串区间重合，需要特判一下。

具体细节看代码。

---

### 代码

提交之后直接刷紫，拿下最优解。

```cpp
#include<iostream>
#include<string.h>
using namespace std;
typedef long long lol;
typedef unsigned long long ull;

const int N = 65;
int T, n, c[N], nxt[N];
ull p[N], k, f[N];

// 更新 i 位置的 nxt[] 数组
void KMP (int &j, int i) 
{
    while (j && c[j + 1] != c[i]) j = nxt[j];
    if (i > 1 && c[j + 1] == c[i]) j ++ ;
}

bool st[N];
ull ahead (int i) 
{
    memset (st, 0, sizeof (st));
    int j = i;
    while (j) 
        st[j] = true, j = nxt[j];
    for (int j (i + 1); j <= (n >> 1); ++ j ) 
    {
        f[j] = 1ull << (j - i);
        for (int t (1); t <= (j >> 1); ++ t ) 
            if (f[t] && (t <= j - i || st[t - j + i]))
                f[j] -= f[t] * (1ll << max (0, j - max (i, t) - t));
    }

    ull ret = 1ull << (n - i);
    for (int j (1); j <= (n >> 1); ++ j ) 
        if (j <= n - i || st[j - n + i]) 
            ret -= f[j] * (1ull << max(0, n - max (i, j) - j));
    return ret;
}

int main () {
    // 预处理第一问答案
    p[0] = 1;
    for (int i = 1; i <= 64; ++ i ) 
        if (i & 1) 
            p[i] = p[i - 1] << 1;
        else 
            p[i] = (p[i - 1] << 1) - p[i >> 1];
    
    scanf ("%d", &T);
    while (T -- ) 
    {
        scanf ("%d%llu", &n, &k);
        printf ("%llu\n", p[n]);

        if (n == 1) 
        {
            putchar (k + 'a' - 1), putchar ('\n');
            continue;
        }

        // 最后一位可以直接通过第一位得到，不用循环到底
        for (int i (1), j (0); i < n; ++ i ) 
        {
            // 假设第 i 的位置上是 a
            c[i] = 0;
            int t = j;
            KMP (j, i), nxt[i] = j, f[i] = !j;
            ull o = ahead (i);
            if (o < k) 
            {
                k -= o;
                // 修改为 b
                c[i] = 1;
                j = t;
                KMP (j, i), f[i] = !j, nxt[i] = j;
            }
        }

        c[n] = !c[1];
        for (int i (1); i <= n; ++ i ) 
            putchar ('a' + c[i]);
        putchar ('\n');
    }
    
    return 0;
}
```


---

## 作者：duyi (赞：3)

[爽翻了的阅读体验](https://www.cnblogs.com/dysyn1314/p/13251723.html)


发现“无界单词”，相当于是没有border的单词。

首先有个性质：一个长度为$n$的串，它的最小border长度一定小于等于$\lfloor\frac{n}{2}\rfloor$。因为你考虑一个长度大于$\lfloor\frac{n}{2}\rfloor$的border，它的前后部分，必定有重叠，而重叠的部分，肯定也是一个border。

对第一问，可以DP。设$dp[i]$表示长度为$i$的无界单词个数。我们先令$dp[i]=2^i$，然后减去有border的情况。这些情况，可以考虑枚举它的**最短**border。因为border的border还是border，所以最短的border一定是一个不存在border的串，也就是一个无界单词！所以可以枚举最短border的长度$j$，通过$dp[j]$来转移：
$$
dp[i]=2^i-\sum_{j=1}^{\lfloor\frac{i}{2}\rfloor}dp[j]\cdot2^{i-2j}
$$
第一问的答案就是$dp[n]$。通过朴素DP可以$O(n^2)$解决。

对第二问，可以**逐位确定**。每次先将当前位字符设为$\text{a}$。求出在此情况下，后面的位置共有多少种填法，使得整个串是无界单词。设方案数为$x$。如果$x\geq k$，那当前位就填$\text{a}$，否则当前位填$\text{b}$，并令$k$减去$x$。这有点像主席树上求第$k$大时候，先看看左边有多少个数，数量$\geq k$就递归左边，否则令$k$减去这个数量，然后递归右边。

假设当前考虑到第$l$位。先令第$l$位填$\text{a}$。然后我们还是效仿上面的那个DP。首先，$dp[1]\dots dp[l]$，要么是$0$，要么是$1$，取决于有没有border，这都是已经确定了的，可以用一遍kmp求出（当然，也可以暴力）。然后考虑$dp[l+1]\dots dp[n]$，$dp[i]$ ($l+1\leq i\leq n$)的初始值是$2^{i-l}$。要减去有border的情况，还是枚举最小border长度$j$，只不过现在，转移的系数需要稍微分类讨论一下：

- 如果$j\geq l$，那么转移时，和第一问的转移一样，只有中间的$i-2j$个地方可以自由确定。所以贡献是$-dp[j]\cdot 2^{i-2j}$。
- 如果$j<l$，但是$j\geq i-l$，此时这个border，前后缀两部分，都包括了一些已经确定的字符。那我们就要判断，这种转移，和已经确定的字符是否矛盾，如果矛盾，说明不存在这种情况，转移系数为$0$。即使不矛盾，也没有可以自由确定的位置了，所以转移系数是$1$，贡献是$-dp[j]$。判断是否矛盾，其实就是看已经确定的字符里，$s[1\dots l-j+1]$和$s[j\dots l]$是否相等。如果不相等，这个长度为$j$的border就不成立。自己画个图很好理解。
- 如果$j<l$，且$j<i-l$，此时有$i-l-j$个地方可以自由确定。所以贡献是$-dp[j]\cdot 2^{i-l-j}$。

朴素的实现，因为第二种情况下判断是$O(n)$的，还要枚举$i$和$j$，所以整个DP是$O(n^3)$的。因为要逐位确定，所以总复杂度$O(n^4)$。

参考代码：

```cpp
//problem:LOJ2078
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

const int MAXN=64;
int n,nxt[MAXN+5];
char s[MAXN+5];
ull dp[MAXN+5],K;

int main() {
	ull U=0;
	for(int i=0;i<64;++i)U+=(1ull<<i);
	int T;cin>>T;while(T--){
		cin>>n>>K;
		for(int i=1;i<=n;++i){
			if(i==64)dp[i]=U;
			else dp[i]=(1ull<<i);
			for(int j=1;j<=i/2;++j){
				dp[i]-=dp[j]*(1ull<<(i-2*j));
			}
			if(i==64)dp[i]++;
		}
		cout<<dp[n]<<endl;
		for(int len=1;len<=n;++len){
			s[len]='a';
			int j=0;
			nxt[1]=0;dp[1]=1;
			for(int i=2;i<=len;++i){
				while(j && s[j+1]!=s[i])j=nxt[j];
				if(s[j+1]==s[i])++j;
				nxt[i]=j;//kmp求border
				if(!nxt[i])dp[i]=1;
				else dp[i]=0;
			}
			for(int i=len+1;i<=n;++i){
				dp[i]=(1ull<<(i-len));
				for(int j=1;j<=i/2;++j){
					ull x=1;
					if(j>=len)
						x=(1ull<<(i-2*j));
					else if(j>=i-len){
						x=1;
						for(int p=i-j+1,q=1;p<=len;++p,++q){
							if(s[p]!=s[q]){x=0;break;}
						}
					}
					else
						x=(1ull<<(i-len-j));
					dp[i]-=dp[j]*x;
				}
			}
			if(dp[n]<K){
				K-=dp[n];
				s[len]='b';
			}
		}
		for(int i=1;i<=n;++i)cout<<s[i];cout<<endl;
	}
	return 0;
}
```



---

## 作者：Genius_Star (赞：1)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18825266)

### 思路：

先考虑第一问。

显然题目中无界单词的定义是不存在 border。

故考虑动态规划，定义 $dp_i$ 表示考虑前 $i$ 个字符，没有 border 的方案数。

直接转移不好转移，考虑容斥，用总方案数减去存在 border 的方案数；所以考虑枚举最小 border 长度为 $j$，此时就是子问题了，因为是最小 border，所以这个最小 border 不存在 border。

但是此时我们有一个问题，即 $[1, j] \cap [i - j + 1, i] \ne \emptyset$ 怎么办？即前后缀有交；这是不可能的，因为最小 border 不会出现这种情况，否则会出现一个更小的 border。

故我们有状态转移：

$$f_i = 2^i - \sum_{j = 1}^{\lfloor \frac{i}{2} \rfloor} f_j \times 2^{i - 2j}$$

时间复杂度为 $O(N^2)$。

然后考虑第二问怎么做，这种字典序第 $k$ 小的问题一般做法是按位确定，这题也不例外。

考虑若已经填了前 $k$ 位，然后求出第 $k + 1$ 位填 `a` 的无界单词数量 $sum$，若 $sum < k$，说明第 $k + 1$ 位填 `b`，令 $k \gets k - sum$；否则第 $k + 1$ 位填 `a`。

现在问题是求确定了前 $k$ 位后无界单词的数量，一样类似没有限制的动态规划，不过乱填方案数由 $2^i$ 变为这段长度为 $i$ 的区间内没有填的数的数量的 $2$ 的次幂，且需要判一些细节，例如 $[1, j]$ 与 $[i - j + 1, i]$ 要相同，需要判断确定的位是否相同；过程中还需要跑一次 KMP。

时间复杂度为 $O(N^3)$。

[**link**](https://www.cnblogs.com/rgw2010/p/18825266)

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 105;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll T, n, k;
ll poww[N], ans[N], f[N], p[N];
int s[N], nxt[N];
char S[N];
bool vis[N];
inline int get(int l, int r){
	return (r - l + 1) - (s[r] - s[l - 1]);
}
inline void init(){
	poww[0] = 1;
	for(int i = 1; i <= 64; ++i)
	  poww[i] = poww[i - 1] << 1ll;
	f[0] = 1;
	for(int i = 1; i <= 64; ++i){
		f[i] = poww[i];
		for(int j = 1; j <= (i >> 1); ++j)
		  f[i] -= f[j] * poww[i - (j << 1)];
	}
	for(int i = 0; i <= 64; ++i)
	  ans[i] = f[i];
}
inline void getnxt(int m){
	for(int i = 2; i <= m; ++i){
		int x = nxt[i - 1];
		while(x && S[x + 1] != S[i])
		  x = nxt[x];
		if(S[x + 1] == S[i])
		  nxt[i] = x + 1;
		else
		  nxt[i] = 0;
	}
	int x = nxt[m];
	while(x){
		vis[x] = 1;
		x = nxt[x];
	}
}
inline void solve(){
	n = read(), k = read();
	write(ans[n]);
	putchar('\n');
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= n; ++j){
			s[j] = min(j, i);
			nxt[j] = vis[j] = 0;
		}
		S[i] = 'a';
		getnxt(i);
		f[0] = 1;
		for(int j = 1; j <= i; ++j)
		  f[j] = !nxt[j];
		for(int j = i + 1; j <= n; ++j){
			f[j] = poww[get(1, j)];
			for(int k = 1; k <= (j >> 1); ++k){
				if(j - k + 1 <= i){
					if(vis[i - j + k])
					  f[j] -= f[k] * poww[get(k + 1, j - k)];
				}
				else
				  f[j] -= f[k] * poww[get(k + 1, j - k)];
			}
		}
		if(f[n] < k){
			S[i] = 'b';
			k -= f[n];
		}
		putchar(S[i]);
	}
	putchar('\n');
}
bool End;
int main(){
	init();
	T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：asuldb (赞：1)

[题目](https://www.luogu.com.cn/problem/P5770)

题意：求$\rm border$长度为$0$的$n$位$0,1$字符串个数，并求字典序第$k$小的那一个。

首先是计数，正向不是很好算，考虑正难则反；设$f_i$表示长度为$i$的$\rm |border|=0$的串的个数

一个串可能有多个$\rm border$，我们考虑在其最小的$\rm border$长度$j$时计算它

则有$f_i=2^i-\sum_{j=1}^{\lfloor \frac{i}{2}\rfloor}f_j2^{i-2\times j}$；不用考虑长度大于$\lfloor \frac{i}{2}\rfloor$的$\rm border$是因为当$\rm border$长度大于$\lfloor \frac{i}{2}\rfloor$的时候一定存在一个小于$\lfloor \frac{i}{2}\rfloor$的$\rm border$。

第二问，考虑大力二分；二分一个串，求所有字典序小于等于这个串中，$\rm border=0$的有多少个

设$g_{0,i}$表示长度为$i$且字典序严格小于当前串的前$i$位的串的个数；$g_{1,i}$表示长度为$i$且等于当前串的前$i$位的串的个数；不难发现$g_{1,i}=[i\notin \rm Border]$

还是跑上面那个容斥，从$g_{1,j}$向$g_{0,i}$转移的时候要在套一个二分判断一下

代码，其中有一些诡异的行为都是为了防爆```unsigned long long```

```cpp
#include<bits/stdc++.h>
#define re register
#define LL unsigned long long
int n,T;LL m,f[66],v[66];
LL g[2][66];int nxt[66],a[66];
inline void split(LL nw) {
	for(re int i=1;i<=n;i++) a[i]=nw>>(n-i)&1;
}
inline LL Calc(LL val,LL R,int i,int j,LL H) {
	LL L=0,k=0;
	while(L<=R) {
		LL mid=(L>>1ull)+(R>>1ull);
		if((L&1ull)&&(R&1ull)) mid++;
		LL t=(((val<<i)|mid)<<j)|val;
		if(t<H) k=mid+1,L=mid+1;else {if(mid) R=mid-1;else break;}
	}
	return k;
}
inline LL calc(LL nw) {
	split(nw);nxt[1]=0;
	for(re int i=2;i<=n;i++) {
		int p=nxt[i-1];
		while(a[p+1]!=a[i]&&p) p=nxt[p];
		if(a[p+1]==a[i]) nxt[i]=p+1;else nxt[i]=0;
	}
	memset(g,0,sizeof(g));
	LL x=a[1];g[1][1]=1;
	if(x) g[0][1]=1;v[1]=x;
	for(re int i=2;i<=n;i++) {
		x=(x<<1ull)|a[i];v[i]=x;
		g[0][i]=x;
		for(re int j=1;j+j<=i;++j) {
			g[0][i]-=g[0][j]*(1ull<<(i-j-j));
			if(g[1][j]) g[0][i]-=Calc(v[j],(1ull<<(i-j-j))-1,i-j-j,j,x);
		}
		if(!nxt[i]) g[1][i]=1;
	}
	return g[0][n]+g[1][n];
}
int main() {
	scanf("%d",&T);f[1]=2;
	while(T--) {
		std::cin>>n>>m;
		for(re int i=2;i<=n;i++) {
			f[i]=1ull<<(i-1);f[i]--;f[i]+=1ull<<(i-1);
			for(re int j=1;2*j<=i;++j) f[i]-=(1ull<<(i-2*j))*f[j];
			f[i]++;
		}
		std::cout<<f[n]<<std::endl;
		LL l=0,r=(1ull<<(n-1)),ans=0;r+=r-1;
		while(l<=r) {
			LL mid=(l>>1ull)+(r>>1ull);
			if((l&1ull)&&(r&1ull)) mid++;
			if(calc(mid)>=m) {ans=mid;if(mid) r=mid-1;else break;}
			else l=mid+1;
		}
		split(ans);
		for(re int i=1;i<=n;i++)putchar(a[i]+'a');puts("");
	}
}
```


---

## 作者：KokiNiwa (赞：1)

# [JSOI2016]无界单词

## 题目叙述

求border长度为0的由a,b组成的字符串有多少个，并输出字典序第$k$大的有多少个。

这里border的定义是最长的前缀与后缀相同的字符串。

## 题解

哎，首先瞄了一眼题解。。题解说，按照**这个字符串的最小border计数**。

### 1

这...无从搞起啊。可能可以考虑计算有border的字符串有多少个。于是可以考虑前面一个串，后面一个串，这两个串相同那么有border。考虑往中间填东西。并考虑计算最小border长度恰好为$k$的有多少个。也就是说，border的border长度不能不为0（否则存在更小border）。那么可以设$f_{i,0/1}$为长度为$i$的字符串有/没有border的有多少个。枚举border长度转移即可。

### 2

需要计算前缀确定的无border的字符串个数。还是设$f_i$为前$i$位无border的有多少个。还是枚举最小border的长度进行转移，设当前最小border长度为$k$，那么会分为三种情况：

1. 如果前缀的长度比$k$大，那么空出的位置为$len - k - pre$（border没有border
2. 如果小，那么空出的位置为$len - 2k$（border没有border
3. 否则，没有空出的位置，那么需要看是否能重合。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int maxLen = 70;
typedef long long ull;
int T, len, kth, nxt[maxLen];
ull dp[maxLen][2], f[maxLen], pow2[maxLen];
char ans[maxLen];
void Init() {
	for (int i = 0; i <= 64; ++i) pow2[i] = (1llu << i);
}
void Solve1() {
	dp[1][0] = 2;
	dp[1][1] = 0;
	for (int le = 2; le <= len; ++le) {
		dp[le][1] = 0;
		for (int bord = 1; bord <= le / 2; ++bord) {
			dp[le][1] += dp[bord][0] * pow2[le - bord * 2];
		}
		dp[le][0] = pow2[le] - dp[le][1];
	}
	printf("%llu\n", dp[len][0]);
}
void Solve2() {
	bool can[100];
	for (int pos = 1; pos <= len; ++pos) {
		memset(can, 0, sizeof(can));
		if (pos == 1) nxt[pos] = 0;
		else {
			int bord = nxt[pos - 1];
			while (bord && ans[bord + 1] != 'a') bord = nxt[bord];
			if (ans[bord + 1] == 'a') nxt[pos] = bord + 1;
			else nxt[pos] = 0;
			bord = nxt[pos];
			while (bord) can[bord] = 1, bord = nxt[bord];
			can[0] = 1;
		}
		memset(f, 0, sizeof(f));
		for (int bord = 1; bord <= pos; ++bord)
			if (!nxt[bord]) f[bord] = 1;
		for (int pre = pos + 1; pre <= len; ++pre) {
			f[pre] = pow2[pre - pos];
			for (int bord = 1; pre >= bord + max(bord, pos); ++bord) {
				f[pre] -= f[bord] * pow2[pre - bord - max(bord, pos)];
			}
			for (int bord = pre - pos + 1; bord <= pre / 2; ++bord) {
				int chong = bord + pre - len;
				if (can[chong] && !nxt[bord]) --f[pre];
			}
		}
		if (f[len] < kth) kth -= f[len], ans[pos] = 'b';
		else ans[pos] = 'a';
		printf("%c", ans[pos]);
		if (pos != 1 && ans[pos] == 'b') {
			int bord = nxt[pos - 1];
			while (bord && ans[bord + 1] != ans[pos])
				bord = nxt[bord];
			if (ans[bord + 1] == ans[pos]) nxt[pos] = bord + 1;
			else nxt[pos] = 0;
		}
	}
	printf("\n");
}
int main() {
	scanf("%d", &T);
	Init();
	while (T--) {
		scanf("%d%d", &len, &kth);
		if (len == 1) {
			if (kth == 1) printf("a");
			else printf("b");
			printf("\n");
		}
		Solve1();
		Solve2();
	}
	return 0;
}
```

## 知识点

+ 分类方法可以学习，妙在这样分类可以不重不漏。

---


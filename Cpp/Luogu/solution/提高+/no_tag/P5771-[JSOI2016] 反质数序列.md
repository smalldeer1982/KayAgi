# [JSOI2016] 反质数序列

## 题目描述

对于一个长度为 $L \ge 2$ 的序列 $X:\{x_1,x_2,...,x_L\}$，如果满足对于任意 $1 \le i < j \le L$，均有 $x_i+x_j$ 不为质数，则 JYY 认为序列 $X$ 是一个「反质数序列」。

JYY 有一个长度为 $N$ 的序列 $A:\{a_1,a_2,...,a_N\}$，他希望从中选出一个包含元素最多的**子序列**，使得这个子序列是一个反质数序列。

## 说明/提示

对于 $10\%$ 的数据，满足 $N \le 10$；

对于 $40\%$ 的数据，满足 $N \le 150$；

对于 $80\%$ 的数据，满足 $N \le 1000$；

对于 $100\%$ 的数据，满足 $2 \le N \le 3000$，$1 \le a_i \le 10^5$。

## 样例 #1

### 输入

```
6
1 2 2 3 4 10
```

### 输出

```
4
```

# 题解

## 作者：djh123 (赞：3)

考虑按奇偶性分类，一个质数一定是一个奇数加一个偶数（2除外），那么这道题就是一个二分图最大独立集的问题，考虑用网络流做。

如果 $v_a+v_b \in p$ 那么我们就连一条 $(a,b,\inf)$ 的边，表示 $a, b$ 不能共存。$s$向每一个偶数连一条流量为 $1$ 的边，奇数向 $t$ 连一条流量为 $1$ 的边，因为最大流等于最小割，所以答案就是 $n-maxflow$。

然后我们要特殊考虑 $1$ 这个数字怎么处理，我们发现，在一个合法的反素数序列中最多存在一个 $1$，那么我们在原序列中直接去掉多余的 $1$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)
#define rop(i, x, y) for(int i = (x); i <  (y); ++ i)
#define per(i, x, y) for(int i = (x); i >= (y); -- i)
#define por(i, x, y) for(int i = (x); i >  (y); -- i)

const int inf = 0x3f3f3f3f;

int prime[200050];
bool vis[200050];
int ptot = 0;
void get_prime(int n){
    rep(i, 2, n) vis[i] = 1;
    rep(i, 2, n) {
        if(vis[i] == 1) prime[++ ptot] = i;
        for(int j = 1 ; j <= ptot && i * prime[j] <= n ; j++){
            vis[i * prime[j]] = 0;
            if(i % prime[j] == 0) break;
        }
    }
}
int s, t;
const int N = 3005;
int head[N * 2], cur[N * 2], nxt[N * N * 4], to[N * N * 4], tot = 1, val[N * N * 4];
int a[N];
void add(int x, int y, int w) { 
    to[++ tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
    val[tot] = w;
    to[++ tot] = x;
    nxt[tot] = head[y];
    head[y] = tot;
    val[tot] = 0;
}
int dep[N * 2];
bool bfs() {
    memset(dep, 0, sizeof dep);
    queue<int> q;
    q.push(s);
    dep[s] = 1;
    while(q.size()) {
        int now = q.front();
        q.pop();
        for(int i = head[now]; i; i = nxt[i]) {
            if(dep[to[i]] || val[i] == 0) continue;
            q.push(to[i]);
            dep[to[i]] = dep[now] + 1;
            if(to[i] == t) return 1;
        }
    }
    return 0;
}
int dfs(int now, int flow) {
    int res = flow;
    if(now == t) return flow;
    for(int &i = cur[now]; i; i = nxt[i]) {
        if(val[i] == 0 || dep[to[i]] != dep[now] + 1) continue;
        int usd = dfs(to[i], min(res, val[i]));
        val[i] -= usd;
        val[i ^ 1] += usd;
        res -= usd;
        if(res == 0) return flow;
    }
    if(res == flow) dep[now] = -1;
    return flow - res;
}
int main() {
    get_prime(200000);
    int n; scanf("%d", &n);
    int kk = 0, cnt = 0;
    rep(i, 1, n) scanf("%d", &a[i]);
    rep(i, 1, n) if(a[i] == 1) kk = i, ++ cnt;
    s = 2 * n + 1, t = s + 1;
    rep(i, 1, n) add(s, i, 1), add(i + n, t, 1);
    rep(i, 1, n) rep(j, 1, n) if(a[i] % 2 == 0 && a[j] % 2 == 1 && vis[a[i] + a[j]] && a[j] != 1) add(i, j + n, inf);
    rep(i, 1, n) if(kk && a[i] % 2 == 0 && vis[a[i] + 1]) add(i, kk + n, inf);
    int ans = 0;
    while(bfs()) {
        memcpy(cur, head, sizeof cur);
        ans += dfs(s, inf);
    }
    printf("%d\n", n - ans - max(cnt - 1, 0));
}

```

---

## 作者：Walrus (赞：1)

做了一晚上的题，拼尽全力无法战胜，战绩如下。

[link1](https://cdn.luogu.com.cn/upload/image_hosting/xg1qju2d.png)
[link2](https://cdn.luogu.com.cn/upload/image_hosting/218pmn2t.png)

首先可以一眼瞪出二分图的性质，因为**只有两个奇偶性不同的数之和才有可能是一个质数**，所以考虑将奇数分为左部，偶数分为右部，源点向左部连边，右部向汇点连边。

先质因数分解，如果两数之和是质数则连边，表示这两个数不能同时选，相当于转化为了一个最大独立集问题。

所以题意变为了在一张图上求最小割，已知最小割等于最大流，于是答案等于总点数减去最大流。

但是质因数分解的时候都是跳过 $1$ 的，考虑 $1$ 怎么办。

注意到 $1+1=2$，所以一个合法的反质数序列最多存在一个 $1$，我们考虑最多只留下一个 $1$，其余不管即可。**但是此时的总点数也会变化，并不是原题中的 $n$。**

注意边数可能到 $1500^2$。

[code](https://www.luogu.com.cn/paste/qkjtrd02)

---

## 作者：mRXxy0o0 (赞：1)

**$n^3$ 匈牙利最优解，根本叉不掉。**

# 分析

观察序列，如果把两个和为质数的点连一条边，那么原问题就转化成了求最大独立集。

有一种直觉告诉我们这应该是一个二分图，就考虑证明一下。

首先，偶数个 $1$ 就违背了这一点，但当去掉重复的 $1$ 后，它就是一个二分图。

不妨反证，设有一个由 $x,y,z(x\le y\le z,1<y\le z)$ 构成的奇环，则：

$$
\begin{cases}
x+y\equiv 1 \pmod 2\\
y+z\equiv 1 \pmod 2\\
x+z\equiv 1 \pmod 2
\end{cases}
$$

这是矛盾的，所以这个图是二分图。

在二分图上匈牙利求 $n-\text{最大匹配数}$ 即可。

时间复杂度比较玄学，因为根本跑不满 $n^3$。

交一发结果发现 T 了一个点，考虑卡常。

# 卡常

## 优化枚举

首先可以把枚举所有的点 DFS 一遍改成只枚举某个部的点。在这道题中，数组元素的奇偶性天然分成了两个部，直接判断即可。

经过试验，偶数点较少一些，所以枚举偶数点。

## 优化建边

根据上述，只连偶数到奇数的单向边即可。

此外，还需要提高缓存命中。故排序时把偶数都放在前面，奇数放后面，也可以方便去掉重复的 $1$。

由于这是一个稠密图，`vector` 建边比链式前向星快不少。

## 优化匈牙利

DFS 常数巨大，改用 BFS 版，原理类似。

## 其他

比如位运算代替取模，多次定义改成赋值等等。都加上去就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3010,M=2e5+10;
int n,a[N],p[M],link[N],ans,fg[N],tim=1,q[N],hh,tt,px[N],py[N],pre[N];
bool vis[M],vx[N],vy[N];
vector<int>G[N];
inline bool cmp(int x,int y){
	return ((x&1)^(y&1))?(~x&1):x>y;
}
inline void init(){
	vis[1]=1;
	for(int i=2;i<M;++i){
		if(!vis[i]) p[++p[0]]=i;
		for(int j=1;j<=p[0]&&1ll*i*p[j]<M;++j){
			vis[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
}
void aug(int v){
	int t;
    while(v){
        t=px[pre[v]];
        px[pre[v]]=v;
        py[v]=pre[v];
        v=t;
    }
}
bool bfs(int s){
    memset(pre,0,sizeof(pre));
    memset(vx,0,sizeof(vx));
    memset(vy,0,sizeof(vy));
    q[hh=tt=1]=s;
    int u;
    while(hh<=tt){
        u=q[hh++];
        vx[u]=1;
        for(int v:G[u]) if(!vy[v]){
            vy[v]=1;
            pre[v]=u;
            if(!py[v]) return aug(v),1;
            q[++tt]=py[v];
        }
    }
    return 0;
}
int main(){
	init();
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	sort(a+1,a+1+n,cmp);
	while(n>1&&a[n-1]==1) --n;
	for(int i=1;i<=n&&(~a[i]&1);++i){
		for(int j=n;j>=1&&(a[j]&1);--j){
			if(!vis[a[i]+a[j]]) G[i].emplace_back(j);
		}
	}
	for(int i=1;i<=n&&(~a[i]&1);++i,++tim) ans+=bfs(i);
	printf("%d",n-ans);
	return 0;
}
```


---

## 作者：decoqwq (赞：1)

显然同为偶数可以全选，同为奇数除了两个$1$都可以全选，考虑把多余的$1$删去，然后就变成了一张二分图，考虑要求一个最大的集合满足两两相加不是质数，对于一对数$a_i,b_i$若其相加为质数(不为$2$)，则它们不能共同被选择，即在这两个数之间连一条流量为$1$的边，然后源点向奇数项连边，偶数项向汇点连边，求这张图的最大独立集就相当于用总点数减去最小割
```cpp
/*deco loves Chino*/
#include <bits/stdc++.h>
using namespace std;
#define maxn 200000
struct edge
{
	int next,to,dis;
}e[maxn<<4];
int head[6010],dis[6010],tot=1,s,t;
int prime[50010],isp[200010],vis[200010],cnt,n,a[3010],cur[6010];
void add(int u,int v,int d)
{
	e[++tot].to=v;
	e[tot].next=head[u];
	e[tot].dis=d;
	head[u]=tot;
}
void sha()
{
	for(int i=2;i<=maxn;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=i;
			isp[i]=1;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=maxn;j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				break;
			}
		}
	}
}
int bfs()
{
	queue<int> q;
	memset(dis,-1,sizeof(dis));
	memcpy(cur,head,sizeof(head));
	q.push(s);
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]==-1&&e[i].dis>0)
			{
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int u,int ex)
{
	if(u==t||!ex)
	{
		return ex;
	}
	int flow=0;
	for(int i=cur[u];i;i=e[i].next)
	{
	    cur[u]=i;
		int v=e[i].to;
		if(dis[v]!=dis[u]+1||e[i].dis<=0)
		{
			continue;
		}
		int tmp=dfs(v,min(ex,e[i].dis));
		if(!tmp)
		{
			continue;
		}
		ex-=tmp,flow+=tmp;
		e[i].dis-=tmp,e[i^1].dis+=tmp;
		if(!ex)
		{
			break;
		} 
	}
	return flow;
}
int f1,f2,t1,t2;
int main()
{
	cin>>n;
	sha();
	t=2*n+1;
	int cs=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(cs&&a[i]==1)
		{
			n--,i--;
			continue;
		}
		if(a[i]==1)
		{
			cs=1;
		}
		if(a[i]%2==0)
		{
			add(s,i,1);
			add(i,s,0);
		}
		else
		{
			add(i,t,1);
			add(t,i,0);
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]%2!=0)
		{
			continue;
		}
		for(int j=1;j<=n;j++)
		{
			if(a[j]%2!=1)
			{
				continue;
			}
			if(isp[a[i]+a[j]])
			{
				add(i,j,1);
				add(j,i,0);
			}
		}
	}
	int ans=n;
	while(bfs())
	{
		ans-=dfs(s,0x3f3f3f3f);
	}
	cout<<ans; 
}
```

---

## 作者：crescentic (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P5771)

可以看出是道二分图最大独立集。

**题目分析**：

分析可得：

- 当两个数奇偶性相同时，肯定满足条件（和为偶数）

所以，源点连向偶数，奇数连向汇点（其实交换源汇点也可以，看心情叭）。如果两数之和为质数，就在他们之间连边。最后 $dinic$ 求最小割就 $over$ 啦。

**注意点**：

- 边权均为 $1$ ：所求答案为选择的**数量**；
- 需要判断 $1$ 出现的次数：两个 $1$ 相加还是**质数**， 直接删去一个 $1$ 就好了，不会影响结果。
- 两个数连边时，注意源点和汇点的**奇偶顺序**，提前判断枚举的节点的奇偶正确性。


**完整代码**：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
#define rt register int
#define int long long
const int N = 6010, M = 2e6,inf = 2e9,maxn = 2e5;
int n,m,S,T,tot = 1,a[N],head[N],cur[N],dep[N],f[M],prime[maxn],cnt;
bool vis[maxn + 10],tru[maxn + 10];
struct node {
	int to,nex;
}e[M];
inline void add(int x,int y,int w) {
	e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
	e[++tot] = (node) {x,head[y]}, head[y] = tot;
}
inline void read(int &x) {
	x = 0;
	int ff = 1; char s = getchar();
	while(s < '0' || s > '9') {s = getchar();}
	while(s <= '9' && s >= '0') { x = x * 10 + s - '0'; s = getchar();}
	x *= ff;
}
inline bool bfs() {
	memset(dep,-1,sizeof(dep));
	dep[S] = 0, cur[S] = head[S];
	queue<int> q;
	q.push(S);
	int now,ver;
	while(!q.empty()) {
		now = q.front();
		q.pop();
		for(rt i = head[now]; i; i = e[i].nex) {
			ver = e[i].to;
			if(dep[ver] == -1 && f[i]) {
				dep[ver] = dep[now] + 1, cur[ver] = head[ver];
				if(ver == T) return 1;
				q.push(ver);
			}
		}
	} 
	return 0;
}
inline int find(int x,int limit) {
	if(x == T) return limit;
	int ver,flow = 0,tmp;
	for(rt i = cur[x]; i && flow < limit; i = e[i].nex) {
		cur[x] = i, ver = e[i].to;
		if(dep[ver] == dep[x] + 1 && f[i]) {
			tmp = find(ver,min(limit - flow,f[i]));
			if(!tmp) dep[ver] = -1;
			f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp;
		}
	}
	return flow;
}
inline int dinic() {
	int res = 0,flow;
	while(bfs()) while(flow = find(S,inf)) res += flow;
	return res;
}
inline void init() {//预处理质数
	for(rt i = 2; i <= maxn; i ++) {
		if(!vis[i]) {
			prime[++cnt] = i;
			tru[i] = 1;
		}
		for(rt j = 1; j <= cnt && i *prime[j] <= maxn; j ++) {
			vis[i *prime[j]] = 1;
			if(i % prime[j] == 0) break;
		}
	}
} 
signed main() {
	init();
	read(n);
	S = n + 1, T = S + 1;
	int u,flag = 0,ans;
	for(rt i = 1; i <= n; i ++) {
		read(a[i]);
		if(a[i] == 1 && flag) {//如果出现2个及以上的1，直接删除
			n --, i --;
			continue;
		}
		if(a[i] == 1) flag = 1;
		if(a[i] & 1) add(i,T,1);
		else add(S,i,1);
	}
	for(rt i = 1; i <= n; i ++) {
		if(a[i] & 1) continue; //与源点相连的应该是偶数，奇数跳过
		for(rt j = 1; j <= n; j ++) {
			if(a[j] % 2 == 0) continue;//参考上文
			if(tru[a[i] + a[j]]) add(i,j,1);
		}
	}
	ans = n;
	printf("%lld",ans - dinic());
	return 0;
}
```


---

## 作者：issue_is_fw (赞：0)

直接求不好求,但是容易发现这大概是一个二分图

因为同奇偶性的相加一定不是质数,不同奇偶性数相加就不一定了

所以按照奇偶构建二分图

奇数放二分图左边,偶数放二分图右边

若左边的$i$和右边的$j$满足$a[i]+a[j]$是质数则$i$向$j$连一条边

那么这样连边这样可以求一个最大匹配.....然而有啥用呢.....

**最大匹配=最小点覆盖**

**最大独立集=点数-最小点覆盖**

把最小点覆盖抽出来,剩下的数就是最大独立集,彼此不会形成质数

值得一提的是,$1$是特殊的数,因为$1+1$竟然是质数!!!

那么最后答案中肯定最多只有$1$个$1$

把多余的1去掉,就是名副其实的二分图了

```
<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
const int inf=1e9;
int n,m,s,t,dis[maxn],a[maxn];
struct edge{
	int to,nxt,flow;
}d[maxn]; int head[maxn],cnt=1;
int prime[maxn],vis[maxn],top;
void make_prime()
{
	vis[1]=1;
	for(int i=2;i<=2e5;i++)
	{
		if( !vis[i] )	prime[++top]=i;
		for(int j=1;j<=top&&i*prime[j]<=2e5;j++ )
		{
			vis[i*prime[j]]=1;
			if( i%prime[j]==0 )	break;
		}
	}
}
void add(int u,int v,int flow){
	d[++cnt]=(edge){v,head[u],flow},head[u]=cnt;
	d[++cnt]=(edge){u,head[v],0},head[v]=cnt;
}
bool bfs()
{
	for(int i=1;i<=t;i++)	dis[i]=0;
	dis[s]=1;
	queue<int>q; q.push( s );
	while( !q.empty() )
	{
		int u=q.front(); q.pop();
		for(int i=head[u];i;i=d[i].nxt )
		{
			int v=d[i].to;
			if( d[i].flow&&dis[v]==0 )
			{
				dis[v]=dis[u]+1;
				if( v==t )	return true;
				q.push( v );
			}
		}
	}
	return false;
}
int dinic(int u,int flow)
{
	if( u==t )	return flow;
	int res=flow;
	for(int i=head[u];i&&res;i=d[i].nxt )
	{
		int v=d[i].to;
		if( dis[v]==dis[u]+1&&d[i].flow)
		{
			int temp=dinic(v,min(res,d[i].flow) );
			if( temp==0 )	dis[v]=0;
			res-=temp;
			d[i].flow-=temp;
			d[i^1].flow+=temp;
		}
	}
	return flow-res;
}
int main()
{
	make_prime();
	cin >> n;
	s=0,t=n+1; 
	int one=0,sumn=n;
	for(int i=1;i<=n;i++)
	{
		cin >> a[i];
		if( a[i]==1 )
		{
			one++;
			if( one>1 )
			{
				a[i]=-1,sumn--;
				continue;
			}
		}
		if( a[i]%2==1 )	add(s,i,1);
		else	add(i,t,1);
	}
	for(int i=1;i<=n;i++)
	{
		if( a[i]%2==0||a[i]==-1 )	continue;
		for(int j=1;j<=n;j++)
		{
			if( a[j]==-1||a[j]%2==1 )	continue;
			if( !vis[a[i]+a[j]] )
				add(i,j,1);
		}
	}
	int ans=0;
	while( bfs() )	ans+=dinic(s,inf);
	int k=max(0,one-1);
	cout << n-k-ans;
}
```

---


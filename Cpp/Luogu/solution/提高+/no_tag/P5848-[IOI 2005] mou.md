# [IOI 2005] mou

## 题目描述

游乐园已经开始运行一个崭新的模拟过山车。模拟的轨道由 $n$ 段铁轨组成，并且首尾相连。第一段铁轨从高度 $0$ 开始。

操作员 Byteman 能通过调整连续几段的铁轨高度来改造这条轨道。在被改造的一段前面的铁轨高度不受影响。 每一次铁轨被调整。后面的轨必须升起或降低来保持连通，并保证起点高度为 $0$。下页举例说明轨道改造过程。 每次开始时车都有足够能量到达高度 $h$。也就是说，只要轨道的高度不超过 $h$，车就一直开下去, 甚至直到结束。 

给出每天的运行和改造情况, 为每次运行计算在车停止前，到达的铁轨数。铁轨以一个 $n$ 个数的数列形式表示 ，一个数对应一段铁轨。第 $i$ 个 $d_i$ 表示在第 $i$ 段铁轨上的高度变化。也就是说，在到达铁轨 $i$ 前，如果车的高度是 $h$，那么经过铁轨i后，高度变为 $h+d_i$。

最初轨道是一条水平线。就是说对于所有的 $i$ 都是 $d_i=0$。运行和改造交错进行。 每个改造用三个数表示: $a$ ，$b$ 和 $D$。表示从 $a$ 到 $b$ (包括 $a$,$b$) 的所有 $d_i$ 改为 $d_i=D$。每次运行给定一个数字 $h$ ——车能到达的最大高度。

## 说明/提示

对于 $50\%$ 的数据，$1 \le n \le 2 \times 10^4$，且输入不超过 $1000$ 行；

对于 $100\%$ 的数据，$1 \le n \le 10^9$，$1 \le a,b \le n$，$- 10^9 \le D \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
4
Q 1
I 1 4 2
Q 3
Q 1
I 2 2 -1
Q 3
E
```

### 输出

```
4
1
0
3
```

# 题解

## 作者：xzx34 (赞：10)

题目要求你维护一段序列，支持操作包括：

1 区间修改为同一个数

2 令s[i] 表示当前前缀和，最小的i使得h<=s[i]并输出i-1；

大概思考一下，我们能想到用线段树解决这一问题。

首先是区间修改，线段树基本操作，不谈。

然后是怎么处理操作2，我们可以在每个线段树上的每个节点上存上

sum 表示这个节点下数值和

lsum 表示这个节点对应的区间从左开始的最大值

然后就可以处理了。。。

设计一个“爬”函数，根节点开始爬。

如果lson的lsum大于h，则爬向lson；否则爬向rson，h-=lson的sum。

这里的正确性真的是很显然的，建议手玩。

但是普通的线段树过不了这题。有n=1e9的瓶颈，空间会炸。

有两种方法解决这一限制，动态开点线段树和离散化。我使用的是前者，相对好打一点。

然后有很温柔的小哥哥让我教怎么打动态开点线段树。其实动态开点线段树真的很好打好想。我们进行的是区间修改，因为有懒标记的存在，几乎所有的操作都不会访问到叶节点。因此，我们很多提前开出来的节点几乎从来不会被访问！这就很亏，很烦。

考虑一个暴力的想法：随着我的访问去开点。对于每一个节点，如果我是第一次访问它，我就把它设为++tot，不然它的存在与否就不重要。

这就是动态开点线段树的思路，实际上通过这种操作，你的空间复杂度就不再与序列长度挂钩，而是与操作次数挂钩。非常的舒服。

代码如下：
```cpp
#include <bits/stdc++.h>
#define re register int 
#define il inline
#define ll int
#define ls t[k].lson
#define rs t[k].rson
using namespace std;
const int inf=1e9;
il int read(){
	char c=getchar();int z=0,f=1;
	while(c!='-'&&(c>'9'||c<'0')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') z=(z<<1)+(z<<3)+c-'0',c=getchar();
	return z*f;
}
int tot=1;
struct TREE{
	int l,r,lson,rson;
	ll lsum,sum,add;
	bool book;
}t[4500005];
il void check(int k){//动态开点 
	int mid=t[k].l+t[k].r>>1;
	if(!ls){ls=++tot;t[ls].l=t[k].l,t[ls].r=mid;}
	if(!rs){rs=++tot;t[rs].r=t[k].r,t[rs].l=mid+1;}
}
il void spread(int k){//基本操作下传信息 
	if(!t[k].book) return ;t[k].book=0;
	t[ls].add=t[rs].add=t[k].add;t[ls].book=t[rs].book=1;
	t[ls].sum=(t[ls].r-t[ls].l+1)*t[k].add;
	t[rs].sum=(t[rs].r-t[rs].l+1)*t[k].add;
	if(t[ls].sum>0) t[ls].lsum=t[ls].sum;
	else t[ls].lsum=t[k].add;
	if(t[rs].sum>0) t[rs].lsum=t[rs].sum;
	else t[rs].lsum=t[k].add;
}
il void change(int k,int l,int r,ll d){//基本操作修改 
	if(t[k].r<l||t[k].l>r) return;
	if(t[k].l>=l&&t[k].r<=r){
		t[k].add=d;t[k].sum=d*(t[k].r-t[k].l+1);t[k].book=1;
		if(t[k].sum>0) t[k].lsum=t[k].sum;
		else t[k].lsum=t[k].add;
		return ;
	}
	check(k);//防止越界动态开点 
	spread(k);
	change(ls,l,r,d);change(rs,l,r,d);
	t[k].sum=t[ls].sum+t[rs].sum;//更新关键信息 
	t[k].lsum=max(t[ls].sum+t[rs].lsum,t[ls].lsum);//更新关键信息 
}
int ans;
il void pa(int k,ll h){//爬 
	if(t[k].l==t[k].r){
		if(h>=t[k].lsum) ans=t[k].l;
		else ans=t[k].l-1;
		return ;
	}
	check(k);spread(k);
	if(h>=t[ls].lsum) pa(rs,h-t[ls].sum);
	else pa(ls,h);
}
int n;char c;
int main (){
	n=read();t[1].l=1,t[1].r=n;
	while(1){
		cin>>c;if(c=='E') return 0;
		if(c=='Q'){
			ll h=read();pa(1,h);
			cout<<ans<<'\n';
		}
		if(c=='I'){
			int l=read(),r=read(),d=read();
			change(1,l,r,d);
		}
	}
	return 0;
} 
```
这篇代码可以拿下96分，不能AC，还是会被卡空间。

这篇代码的空间复杂度还能继续优化。

为了便于初学者理解，我存了每个节点的l，r。

这个空间开销是多余的，可以在函数中保留l，r信息，不需要存下来。

把这一点优化了以后就可以愉快的AC了。希望对读者有帮助吧。


---

## 作者：Yukikaze_ (赞：5)

这题动态开点线段树的做法前面的大佬已经讲了，但是动态开点线段树空间复杂度会达到 操作次数 * log1e9，而这题操作次数有1e5个，所以最坏情况下需要2 * 1e5 * log1e9 约等于六百万个结构体，空间是非常紧张的。因此，我们也可以考虑用普通的线段树加离散化，具体实现如下：

1、将所有操作离线下来，并记录所有a、b。

2、将所有a、b排序并去重，得到离散化后的序列，然后用hash表或map实现对应。
（这里有一点要注意：离散化后的线段树每个点对应 从它到前面那个点之间的所有道路【含右不含左】，因此对于每个a值，我们还需要在离散化序列中插入a-1，便于修改操作）

3、和楼上大佬一样，线段树维护 区间道路高度最大值 和 区间每条道路的d值总和。注意这里的d值是对应离散化之前的d值，也就是说叶子节点长度也不一定为0。

4、对离线下来的I操作，直接在线段树上修改。（注意赋值标记和加法标记的不同！赋值标记0是有意义的！）

5、对于Q操作，在线段树上二分，设当前可以达到h高度，如果左儿子最大值大于h，那么进入左儿子，否则将h减去左儿子的d值总和，进入右儿子。二分到叶子节点后，如果h有剩余，计算统计接下来的答案（因为该点到前一点间所有道路的d值一定相同，所以可以直接做整除运算）

然后，我们就可以用普通线段树A了这道题了，而且空间非常充裕，因为普通线段树空间复杂度是 4 * n 的，只需要一百二十万数组。

其实动态开点线段树绝大多数情况下都比离散化好用也更好写（只是我不会），这里仅提供另一种写法，动态开点线段树还是更值得推荐的。

代码如下
```cpp
#include<bits/stdc++.h>
#include<tr1/unordered_map>
#pragma GCC optimize(2)
#define ls (o<<1)
#define rs (o<<1|1)
#define mid (ll+lr>>1)
using namespace std;
const int N=401010;
int n,cl,num[N],cnt;
int sum[N<<2|1],mx[N<<2|1],fl[N<<2|1],l,r,k;
bool book[N<<2|1];
tr1::unordered_map<int,int> mp;
struct aa
{
	int a,b,d;
}que[N];
int read()
{
	int res=0,fl=0;
	char a=getchar();
	while(a<'0'||a>'9') {if(a=='-') fl=1;a=getchar();}
	while(a>='0'&&a<='9') res=res*10+a-'0',a=getchar();
	return fl? -res:res;
}
void pushr(int o,int ll,int lr,int lk) {sum[o]=(num[lr]-num[ll-1])*lk,mx[o]=max(0,sum[o]),fl[o]=lk,book[o]=1;}
void push_down(int o,int ll,int lr) {if(book[o]) pushr(ls,ll,mid,fl[o]),pushr(rs,mid+1,lr,fl[o]),book[o]=0;}
void update(int o,int ll,int lr)
{
	if(l<=ll&&lr<=r) return pushr(o,ll,lr,k);
	push_down(o,ll,lr);
	if(l<=mid) update(ls,ll,mid);
	if(r>mid) update(rs,mid+1,lr);
	sum[o]=sum[ls]+sum[rs],mx[o]=max(mx[ls],mx[rs]+sum[ls]); //和普通线段树一样的更新函数
}
int query(int o,int ll,int lr,int lk)
{
	if(o==1&&lk>=mx[o]) return n; //特判 
	if(ll==lr) return sum[o]? num[ll-1]+lk/(sum[o]/(num[ll]-num[ll-1])):num[ll]; //叶子结点统计答案
	push_down(o,ll,lr);
	if(mx[ls]>lk) return query(ls,ll,mid,lk);
	return query(rs,mid+1,lr,lk-sum[ls]); //在线段树上二分
}
void add(int lx) {num[++cl]=lx,num[++cl]=lx-1;} //插入离散化数组（记得插入lx-1）
int main()
{
//	freopen("mou.in","r",stdin);
//	freopen("mou.out","w",stdout);
	int i,j,li,lj;
	n=read();
	while(1)
	{
		char a=getchar();
		while(a<'A'||a>'Z') a=getchar();
		if(a=='E') break;
		if(a=='I') add(que[++cnt].a=read()),add(que[cnt].b=read()),que[cnt].d=read();
		if(a=='Q') que[++cnt].d=read(); //将读入离线下来
	}
	num[++cl]=n,sort(num+1,num+cl+1),cl=unique(num+1,num+cl+1)-num-1; //离散化
	if(num[1]==0) {for(i=1;i<cl;i++) num[i]=num[i+1];cl--;} //默认num[0]=0
	for(i=1;i<=cl;i++) mp[num[i]]=i; //反过来对应
	for(i=1;i<=cnt;i++)
		if(que[i].a) l=mp[que[i].a],r=mp[que[i].b],k=que[i].d,update(1,1,cl);
		else cout<<query(1,1,cl,que[i].d)<<'\n';
	return 0;
}
```


---

## 作者：uncle_steve (赞：0)

## Solution:

1. 维护每个点的绝对高度十分困难，于是我们只考虑相对高度。

2. 我们利用线段树维护一段区间（注意区间是轨道的区间而不是点的区间）。

3. 每段区间都要维护三个值：标记，右端点和左端点相对高度以及当前线段中最高点和左端点的相对高度。

4. 询问的时候就在线段树上二分就行了。

## Code：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,inf=0x3f3f3f3f;
struct SGT
{
	int lc[N<<6],rc[N<<6],mx[N<<6],sm[N<<6],tag[N<<6],tot;//note that the space is enough
	inline void nd(int&rt)
	{
		if(rt)return;
		rt=++tot;lc[rt]=rc[rt]=0;
		tag[rt]=-inf;mx[rt]=sm[rt]=0;
	}
	inline void mt(int&rt,int l,int r,int v)
	{
		nd(rt);sm[rt]=(r-l+1)*v;
		mx[rt]=max(0,sm[rt]),tag[rt]=v;
	}
	inline void up(int rt)
	{
		sm[rt]=sm[lc[rt]]+sm[rc[rt]];
		mx[rt]=max(mx[lc[rt]],sm[lc[rt]]+mx[rc[rt]]);
	}
	inline void down(int rt,int l,int r)
	{
		if(tag[rt]==-inf)return;
		int mid=l+r>>1,&tg=tag[rt];
		mt(lc[rt],l,mid,tg),mt(rc[rt],mid+1,r,tg);
		tg=-inf;
	}
	void update(int&rt,int l,int r,int ul,int ur,int v)
	{
		nd(rt);
		if(ul<=l&&r<=ur)return mt(rt,l,r,v);
		down(rt,l,r);int mid=l+r>>1;
		if(ul<=mid)update(lc[rt],l,mid,ul,ur,v);
		if(mid<ur)update(rc[rt],mid+1,r,ul,ur,v);
		up(rt);
	}
	int query(int rt,int l,int r,int v)
	{
		if(l==r)return v>=sm[rt]?l:l-1;
		down(rt,l,r);int mid=l+r>>1;
		if(mx[lc[rt]]<=v)return query(rc[rt],mid+1,r,v-sm[lc[rt]]);
		else return query(lc[rt],l,mid,v);
	}
}T;
int n,RT;
char opt[5];
int main()
{
	scanf("%d",&n);T.update(RT,1,n,1,n,0);
	while(1)
	{
		scanf("%s",opt);
		if(opt[0]=='E')break;
		if(opt[0]=='I')
		{
			int l,r,v;scanf("%d%d%d",&l,&r,&v);
			T.update(RT,1,n,l,r,v);
		}
		else 
		{
			int v;scanf("%d",&v);
			printf("%d\n",T.query(RT,1,n,v));
		}
	}
	return 0;
}

```

---

## 作者：cxjy (赞：0)

[P5848 [IOI 2005\] mou - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5848)

* 这题一开始看维护区间的长度长达 $10^9$ ，我一开始想到的是离散化。(~~因为不会动态开点~~)

* 首先进行离线操作，然后把输入过程中的所有的坐标都先 unique 收集起来，方便二分或者 hash 来离散化。但是要注意的是，这里因为修改的是 $[l ,r]$ 的闭区间，我这里选择把线段树维护的数据的点设置为**从前一个点到当前点需要提升的高度**，所以线段树会修改的节点是 $[l,r]$ ，但是如果同时存在 $[l , l]$ 和 $[l,r]$ 这样的的区间，修改就会出错，所以我们需要添加 l - 1 的点，这样才能正确地添加 tag 。

* 然后就是线段树合并区间的操作，为了方便后续能直接查找到某个高度 h 最多能够走多少段铁轨，我们需要写一个 findmax 函数，而注意，我们的线段树需要维护 4 个值。

  * 第一个 sum 指线段树节点维护的总区间的和，也就是区间右端点对比区间左端点提升了多少高度。
  *  第二个 max 就是假设区间左端点高度为 0 ，这段区间的最高点的高度的值。
  * 还有两个就是这段区间的左右边界。

* 所以可以得到线段树区间合并的操作为：

```cpp
    info operator+ (const info& a , const info& b) {
        info ans(0);
        ans.max = std::max({a.max,b.max + a.sum});
        ans.sum = a.sum + b.sum;
        ans.l = a.l , ans.r = b.r;
        return ans;
    }
```

* 添加 lazytag：

```cpp
    info operator+ (const info& a , const tag& b) {
        info ans = a;
        ans.sum = (ans.r - ans.l ) * b.tg;
        if(b.tg > 0) {
            ans.max = (ans.r - ans.l) * b.tg; 
        } else {
            ans.max = b.tg;
        }
        return ans;
    }
```

* 修改 lazytag:

```cpp
    tag operator+ (const tag& a , const tag& b) {
        return b;
    }
```

* 那么重点就是如何查找高度为 h 的点能够最多走到那一条铁轨，类似查找第 k-th 数，我们在搜索的时候存一个 pre 变量，表示已经爬过的高度，注意，一旦发现可以爬过左侧的一部分区间后，要把左侧区间的 sum 添加到 pre 中，然后返回第一个爬不过的铁轨的节点就可以了，查找时间复杂度 $O(\log n)$ 。

 ```cpp
    std::pair<int,info> findmax(int p , int h ,int pre) {
            if(t[p].val.max + pre <= h) {
                return {INT_MAX,t[p].val};
            }
            if(t[p].l == t[p].r && t[p].val.max + pre > h ) {
                info ans = t[p].val;
                return {pre,ans};
            }
            pushdown(p);
            if(pre + t[ls(p)].val.max > h) {
                return findmax(ls(p),h,pre);
            }
            return findmax(rs(p),h,pre + t[ls(p)].val.sum);
    
        }
```

* 然后利用 findmax 返回的数据就可以计算出最多的铁路数。

```cpp
        std::pair<int,info> ans = S.findmax(1,f1[i][0],0);
        if(ans.first == INT_MAX) std::cout << n << "\n";
        else {
            auto [pre,t1] = ans;
            int ANS = (f1[i][0] - pre) / (t1.sum /(t1.r - t1.l )) + t1.l ;
            std::cout << ANS << "\n";
```

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
#define debug(x)    std::cerr << #x << '=' << x << "\n"
#define println(...)  std::cerr << format(__VA_ARGS__) << std::endl
template <typename info ,typename tag>
class Segmenttree {
public:
#define ls(p)   (p<<1)
#define rs(p)   (p<<1|1)
    static const tag unchanged;
    struct node {
        int l ,r;
        tag Tag;
        info val;
        node() :Tag(unchanged)
        {}
    };
    std::vector<int> ar;
    std::vector<node> t;
    Segmenttree (std::vector<int> ar) :
    // 这里注意传入的vector ar 必须是从下标 1 开始的
    ar(ar) , t(ar.size()<<2 ,node())
    {
        build(1,1,ar.size()-1);
    }
    void update(int p) {
        t[p].val = t[ls(p)].val + t[rs(p)].val;
    }
    void build(int p ,int l ,int r){
        t[p].l = l , t[p].r = r;
        if(l == r){
            t[p].val = info(ar[l-1], ar[l] ,0);
            return;
        }
        int mid = (l + r) /2;

        build(ls(p),l , mid);
        build(rs(p),mid+1,r);
        update(p);
    }
    void pushdown(int p) {
        if(t[p].Tag != unchanged) {
            t[ls(p)].val = t[ls(p)].val + t[p].Tag;
            t[ls(p)].Tag = t[ls(p)].Tag + t[p].Tag;
            t[rs(p)].val = t[rs(p)].val + t[p].Tag;
            t[rs(p)].Tag = t[rs(p)].Tag + t[p].Tag;
            t[p].Tag = unchanged;
        }
    }
    void change(int p, int l , int r , tag val) {
        if(l<=t[p].l and t[p].r <= r) {
            t[p].val = t[p].val + val;
            t[p].Tag = t[p].Tag + val;
            return;
        }
        pushdown(p);
        int mid = (t[p].l + t[p].r)/2;
        if(mid >= l) change(ls(p),l , r, val);
        if(mid <  r) change(rs(p),l , r,val);
        update(p);
    }
    info quiry(int p, int l , int r) {
        if(l <= t[p].l and t[p].r <= r) {
            return t[p].val;
        }
        pushdown(p);
        int mid = (t[p].l + t[p].r) /2;
        if(mid >= l and mid < r) return  quiry(ls(p),l,r) + quiry(rs(p),l,r);
        else if(mid >= l) return quiry(ls(p),l,r);
        else return  quiry(rs(p),l,r);
    }
    // pre 初始化为 0
    std::pair<int,info> findmax(int p , int h ,int pre) {
        if(t[p].val.max + pre <= h) {
            return {INT_MAX,t[p].val};
        }
        if(t[p].l == t[p].r && t[p].val.max + pre > h ) {
            info ans = t[p].val;
            return {pre,ans};
        }
        pushdown(p);
        if(pre + t[ls(p)].val.max > h) {
            return findmax(ls(p),h,pre);
        }
        return findmax(rs(p),h,pre + t[ls(p)].val.sum);

    }
};
// 这里要初始化一下 如果未加上 任何 tag 的时候 tag 的状态 unchanged
// 重载三个函数 info + info  , info + tag , tag + tag
template <typename info, typename tag>
const tag Segmenttree<info, tag>::unchanged = INT_MIN;
struct info {
    int l ,r;
    int sum;
    int max;
    info (int l = 0, int r = 0,int x = 0) : sum(0) ,l(l),r(r),max(0)
    {}
};
info operator+ (const info& a , const info& b) {
    info ans(0);
    ans.max = std::max({a.max,b.max + a.sum});
    ans.sum = a.sum + b.sum;
    ans.l = a.l , ans.r = b.r;
    return ans;
}
struct tag {
    int tg;
    tag(int x = 0) : tg(x)
    {}
    bool operator== (const tag & b) const {
        return tg == b.tg;
    }
};
info operator+ (const info& a , const tag& b) {
    info ans = a;
    ans.sum = (ans.r - ans.l ) * b.tg;
    if(b.tg > 0) {
        ans.max = (ans.r - ans.l) * b.tg; 
    } else {
        ans.max = b.tg;
    }
    return ans;
}
tag operator+ (const tag& a , const tag& b) {
    return b;
}
void solve() {
    int n;
    std::string op;
    std::cin >> n;
    std::vector<std::string> s;
    std::vector<std::vector<int>> f1;
    std::vector<int> pos;
    int x, y, z;
    pos.push_back(0);
    while(1) {
        std::cin >> op;
        if(op == "E") break;
        s.push_back(op);
        if(op == "I") {
            std::cin >> x >> y >> z;
            f1.push_back({x,y,z});
            pos.push_back(x);
            pos.push_back(x-1);
            pos.push_back(y);
        } else {
            std::cin >> x;
            f1.push_back({x});
        }
    }
    std::sort(pos.begin() , pos.end());
    int mx = unique(pos.begin(), pos.end()) - pos.begin();
    pos.erase(pos.begin() + mx, pos.end());
    auto find = [&](int x) {
        return lower_bound(pos.begin() + 1, pos.begin() + mx, x) - pos.begin() ;
    };
    Segmenttree<info,tag> S(pos);
    for(int i = 0; i<s.size();i++) {
        if(s[i] == "I") {
            S.change(1,find(f1[i][0]) ,find(f1[i][1]) ,tag(f1[i][2]));
        } else {
            std::pair<int,info> ans = S.findmax(1,f1[i][0],0);
            if(ans.first == INT_MAX) std::cout << n << "\n";
            else {
                auto [pre,t1] = ans;
                int ANS = (f1[i][0] - pre) / (t1.sum /(t1.r - t1.l )) + t1.l ;
                std::cout << ANS << "\n";
            }
        }
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#ifdef  CXTEST
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);

#endif
    solve();
    return 0;
}

```

---

## 作者：ni_ju_ge (赞：0)

## 思路
简单线段树。

要求实现两种操作，一个是区间修改，一个是查找前缀和中第一个小于 $h$ 的数，设为第 $i$ 项，输出 $i-1$。

区间修改直接正常实现就行了。接下来讨论第二个操作的实现。

考虑类似平衡数查排名的方法，查找左子树的最高点，判断是否大于 $h$：

 - 若大于 $h$，则向左子树递归；
 - 否则将 $h$ 减去左子树的区间和，并向右递归。

所以只用维护最高值和区间和就行了。

另外，$1\le n\le 10^9$，需要使用动态开点的线段树，当然用离散化也行。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int dat,su,lazy,lc,rc,l,r;//su维护最高值
} t[4500000];
int cnt;
int make(int pos,bool le) {
	cnt++;
	if(le)t[cnt].l=t[pos].l,t[cnt].r=(t[pos].l+t[pos].r)/2;
	else t[cnt].r=t[pos].r,t[cnt].l=(t[pos].l+t[pos].r)/2+1;
	t[cnt].lazy=868792;//玄学数字判断该点是否有懒标签
	return cnt;
}
void pushdown(int pos) {//下传
	if(t[pos].l==t[pos].r)return;
	if(t[pos].lc==0)t[pos].lc=make(pos,true);//开点
	if(t[pos].rc==0)t[pos].rc=make(pos,false);
	if(t[pos].lazy==868792)return;
	t[t[pos].lc].dat=(t[t[pos].lc].r-t[t[pos].lc].l+1)*t[pos].lazy;
	t[t[pos].lc].lazy=t[pos].lazy;
	if(t[t[pos].lc].dat>0)t[t[pos].lc].su=t[t[pos].lc].dat;
	else t[t[pos].lc].su=t[pos].lazy;
	t[t[pos].rc].dat=(t[t[pos].rc].r-t[t[pos].rc].l+1)*t[pos].lazy;
	t[t[pos].rc].lazy=t[pos].lazy;
	if(t[t[pos].rc].dat>0)t[t[pos].rc].su=t[t[pos].rc].dat;
	else t[t[pos].rc].su=t[pos].lazy;
	t[pos].lazy=868792;
}
void change(int pos,int left,int right,int val) {
	if(t[pos].r<left||t[pos].l>right)return;
	if(t[pos].l>=left&&t[pos].r<=right) {
		t[pos].dat=(t[pos].r-t[pos].l+1)*val;
		t[pos].lazy=val;
		if(t[pos].dat>0)t[pos].su=t[pos].dat;
		else t[pos].su=val;
		return;
	}
	if(t[pos].l==t[pos].r) {
		t[pos].su=val;
		return;
	}
	pushdown(pos);
	int mid=(t[pos].r-t[pos].l)+1;
	change(t[pos].lc,left,right,val);
	change(t[pos].rc,left,right,val);
	t[pos].dat=t[t[pos].lc].dat+t[t[pos].rc].dat;
	t[pos].su=max(t[t[pos].lc].su,t[t[pos].lc].dat+t[t[pos].rc].su);
}
int search(int pos,int lmt) {
	if(t[pos].l==t[pos].r) {
		if(lmt>=t[pos].su)return t[pos].l;
		else return t[pos].l-1;
	}
	pushdown(pos);
	if(t[t[pos].lc].su>lmt)return search(t[pos].lc,lmt);//递归
	else return search(t[pos].rc,lmt-t[t[pos].lc].dat);
}
int n,x,y,z;
char opt;
int main() {
	cin>>n;
	cnt++;
	t[cnt].l=1,t[cnt].r=n,t[cnt].lazy=868792;
	cin>>opt;
	while(opt!='E') {
		if(opt=='Q') {
			cin>>x;
			cout<<search(1,x)<<endl;
		}
		if(opt=='I') {
			cin>>x>>y>>z;
			change(1,x,y,z);
		}
		cin>>opt;
	}
}
```

---


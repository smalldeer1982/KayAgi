# 【模板】树上 K 级祖先

## 题目背景

**本题仅作为长链剖分求树上 $k$ 级祖先评测用，不保证卡掉了其他复杂度不正确的做法。**

## 题目描述

给定一棵 $n$ 个点的有根树。

有 $q$ 次询问，第 $i$ 次询问给定 $x_i, k_i$，要求点 $x_i$ 的 $k_i$ 级祖先，答案为 $ans_i$。特别地，$ans_0 = 0$。



本题中的询问将在程序内生成。

给定一个随机种子 $s$ 和一个随机函数 $\operatorname{get}(x)$：

```cpp
#define ui unsigned int
ui s;

inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return s = x; 
}
```

你需要按顺序依次生成询问。

设 $d_i$ 为点 $i$ 的深度，其中根的深度为 $1$。

对于第 $i$ 次询问，$x_i = ((\operatorname{get}(s) \operatorname{xor} ans_{i-1}) \bmod n) + 1$，$k_i = (\operatorname{get}(s) \operatorname{xor} ans_{i-1}) \bmod d_{x_i}$。

## 说明/提示

【样例说明】

$x_1 = 4$，$k_1 = 1$，$ans_1 = 2$；  
$x_2 = 6$，$k_2 = 3$，$ans_2 = 5$；  
$x_3 = 3$，$k_3 = 0$，$ans_3 = 3$；  
故输出 $1$。

---

对于 $20\%$ 的数据，$n,q \le 10^3$。

对于 $50\%$ 的数据，$n,q \le 10^5$。

对于 $100\%$ 的数据，$2 \le n \le 5 \times 10^5$，$1 \le q \le 5 \times 10^6$，$1 \le s < 2^{32}$。

## 样例 #1

### 输入

```
6 3 7
5 5 2 2 0 3
```

### 输出

```
1
```

# 题解

## 作者：xht (赞：100)

长链剖分的经典应用。

显然这个问题有 $\mathcal O(n \log n) - \mathcal O(\log n)$ 的树上倍增做法，然而还不够优秀。

首先我们进行预处理：

1. 对树进行长链剖分，记录每个点所在链的顶点和深度，$\mathcal O(n)$。
2. 树上倍增求出每个点的 $2^n$ 级祖先，$\mathcal O(n \log n)$。
3. 对于每条链，如果其长度为 $len$，那么在顶点处记录顶点向上的 $len$ 个祖先和向下的 $len$ 个链上的儿子，$\mathcal O(n)$。
4. 对 $i \in [1, n]$ 求出在二进制下的最高位 $h_i$，$\mathcal O(n)$。

对于每次询问 $x$ 的 $k$ 级祖先：

1. 利用倍增数组先将 $x$ 跳到 $x$ 的 $2^{h_k}$ 级祖先，设剩下还有 $k^{\prime}$ 级，显然 $k^{\prime} < 2^{h_k}$，因此此时 $x$ 所在的长链长度一定 $\ge 2^{h_k} > k^{\prime}$。
2. 由于长链长度 $ > k^{\prime}$，因此可以先将 $x$ 跳到 $x$ 所在链的顶点，若之后剩下的级数为正，则利用向上的数组求出答案，否则利用向下的数组求出答案。

这样时间复杂度为 $\mathcal O(n \log n) - \mathcal O(1)$ 的。

```cpp
const int N = 5e5 + 7;
int n, q, rt, g[N], d[N], f[N][21], son[N], dep[N], top[N], ans;
vi e[N], u[N], v[N];
ui s;
ll Ans;

inline ui get(ui x) {
	return x ^= x << 13, x ^= x >> 17, x ^= x << 5, s = x; 
}

void dfs(int x) {
	dep[x] = d[x] = d[f[x][0]] + 1;
	for (auto y : e[x]) {
		f[y][0] = x;
		for (int i = 0; f[y][i]; i++) f[y][i+1] = f[f[y][i]][i];
		dfs(y);
		if (dep[y] > dep[x]) dep[x] = dep[y], son[x] = y;
	}
}

void dfs(int x, int p) {
	top[x] = p;
	if (x == p) {
		for (int i = 0, o = x; i <= dep[x] - d[x]; i++)
			u[x].pb(o), o = f[o][0];
		for (int i = 0, o = x; i <= dep[x] - d[x]; i++)
			v[x].pb(o), o = son[o];
	}
	if (son[x]) dfs(son[x], p);
	for (auto y : e[x]) if (y != son[x]) dfs(y, y);
}

inline int ask(int x, int k) {
	if (!k) return x;
	x = f[x][g[k]], k -= 1 << g[k], k -= d[x] - d[top[x]], x = top[x];
	return k >= 0 ? u[x][k] : v[x][-k];
}

int main() {
	rd(n), rd(q), rd(s), g[0] = -1;
	for (int i = 1; i <= n; i++)
		rd(f[i][0]), e[f[i][0]].pb(i), g[i] = g[i>>1] + 1;
	rt = e[0][0], dfs(rt), dfs(rt, rt);
	for (int i = 1, x, k; i <= q; i++) {
		x = (get(s) ^ ans) % n + 1;
		k = (get(s) ^ ans) % d[x];
		Ans ^= 1ll * i * (ans = ask(x, k));
	}
	print(Ans);
	return 0;
}
```

---

## 作者：skydogli (赞：99)

### 这题，让我们深刻地体会到理论复杂度和实际复杂度的区别！

虽然没什么新东西，但是还是尝试了4种写法，就权当娱乐吧。

 - #### 树剖LCA
 
$\quad$思路非常简单，你要向上跳k下，如果会跳出重链顶端，就跳到顶端的父亲，否则这个祖先就是重链上的点了，dfs序是连续的，推过去即可。

$\quad$时间复杂度$O(n+qlogn)$

$\quad$实际总运行时间：7.2s（实现得清真可以快1-3s）
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int a=0,fh=1;char c=getchar();
	while(c>57 or c<48){if(c=='-')fh=-1;c=getchar();}
	while(47<c and c<58){
		a=a*10+c-48;
		c=getchar();
	}
	return a*fh;
}
#define MN 500005
int n,m,u,v,cnt,fa[MN],siz[MN],w[MN],top[MN],dep[MN],id[MN],ID[MN];
vector<int>edge[MN];
void dfs1(int x){
	siz[x]=1;
	for(int i=0;i<edge[x].size();++i){
			fa[edge[x][i]]=x;
			dep[edge[x][i]]=dep[x]+1;
			dfs1(edge[x][i]);
			siz[x]+=siz[edge[x][i]];
			if(siz[w[x]]<siz[edge[x][i]])w[x]=edge[x][i];
		}
}
void dfs2(int x){
	id[x]=++cnt;
	ID[cnt]=x;
	if(w[x]){top[w[x]]=top[x];dfs2(w[x]);}
	for(int i=0;i<edge[x].size();++i)
		if(edge[x][i]!=w[x]){
			top[edge[x][i]]=edge[x][i];
			dfs2(edge[x][i]);
		}
}
int rt;
int jump(int x,int k){
	while(k>=id[x]-id[top[x]]+1&&x!=rt){
		k-=(id[x]-id[top[x]]+1);
		x=fa[top[x]];
	}
	return ID[id[x]-k];
}
#define ui unsigned int
ui S;
#define LL long long
inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return S = x; 
}
int main(){
	n=read();m=read();scanf("%u",&S);
	rt=1;
	for(int i=1;i<=n;++i){
		fa[i]=read();
		if(!fa[i])rt=i;
		else edge[fa[i]].push_back(i);
	}
	dep[rt]=1;dfs1(rt);
	top[rt]=rt;dfs2(rt);
	LL ans=0;
	int lstans=0;
	for(int i=1;i<=m;++i){
		int x=(get(S)^lstans)%n+1;
		int k=(get(S)^lstans)%dep[x];
		lstans=jump(x,k);
		ans^=(LL)i*lstans;
	}
	printf("%lld\n",ans);
	return 0;
}
```

- #### 基于树剖LCA的二分优化

$\quad$考虑如果我们定位到一个点的k级祖先在哪个重链上，我们就可以$O(1)$通过dfs序推出准确的位置，而一个点上面最多只有$logn$条重链，我们只要二分这个点在哪条重链即可（也可以倍增，而我实现时为了方便，直接在重链的顶端记上面所有重链的顶端）

$\quad$时间复杂度$O(nlogn+qloglogn)$

$\quad$实际总运行时间：12s(mmp)

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int a=0,fh=1;char c=getchar();
	while(c>57 or c<48){if(c=='-')fh=-1;c=getchar();}
	while(47<c and c<58){
		a=a*10+c-48;
		c=getchar();
	}
	return a*fh;
}
#define MN 500005
int n,m,u,v,cnt,fa[MN],siz[MN],w[MN],top[MN],dep[MN],id[MN],ID[MN];
int FA[MN][19],CNT[MN];
vector<int>edge[MN];
void dfs1(int x){
	siz[x]=1;
	for(int i=0;i<edge[x].size();++i){
			fa[edge[x][i]]=x;
			dep[edge[x][i]]=dep[x]+1;
			dfs1(edge[x][i]);
			siz[x]+=siz[edge[x][i]];
			if(siz[w[x]]<siz[edge[x][i]])w[x]=edge[x][i];
		}
}
int rt;
void dfs2(int x){
	id[x]=++cnt;
	ID[cnt]=x;
	if(top[x]==x){
		int p=top[fa[top[x]]];
		FA[x][0]=x;FA[x][1]=p;
		for(int i=1;i<=CNT[p];++i)FA[x][i+1]=FA[p][i];
		CNT[x]=CNT[p]+1;
	}
	if(w[x]){top[w[x]]=top[x];dfs2(w[x]);}
	for(int i=0;i<edge[x].size();++i)
		if(edge[x][i]!=w[x]){
			top[edge[x][i]]=edge[x][i];
			dfs2(edge[x][i]);
		}
}
int jump(int x,int k){
	if(k<id[x]-id[top[x]]+1) return ID[id[x]-k];
	int y=top[x];
	int l=0,r=CNT[y]+1;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(k<dep[x]-dep[FA[y][mid]]+1)r=mid;
			else l=mid;
	}
	k-=dep[x]-dep[FA[y][l]]+1;
	x=fa[FA[y][l]];
	return ID[id[x]-k];
}
#define ui unsigned int
ui S;
#define LL long long
inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return S = x; 
}
int main(){
	n=read();m=read();scanf("%u",&S);
	rt=1;
	for(int i=1;i<=n;++i){
		fa[i]=read();
		if(!fa[i])rt=i;
		else edge[fa[i]].push_back(i);
	}
	dep[rt]=1;dfs1(rt);
	top[rt]=rt;dfs2(rt);
	LL ans=0;
	int lstans=0;
	for(int i=1;i<=m;++i){
		int x=(get(S)^lstans)%n+1;
		int k=(get(S)^lstans)%dep[x];
		lstans=jump(x,k);
		ans^=(LL)i*lstans;
	}
	printf("%lld\n",ans);
	return 0;
}

```
- #### 基于树剖LCA的分块

$\quad$考虑$\sqrt{logn}$和$loglogn$其实差不多，所以我们可以直接预处理出x的第$\sqrt{logn}$个祖先（3或4）,就可以一次跳多个祖先了。

$\quad$时间复杂度$O(n\sqrt{logn}+q\sqrt{logn})$

$\quad$实际总运行时间:6.5s（块长=3，因为常数没变大多少，所以还是有一点点用的）

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int a=0;char c=getchar();
	while(c>57 or c<48){c=getchar();}
	while(47<c and c<58){
		a=a*10+c-48;
		c=getchar();
	}
	return a;
}
#define MN 500005
int n,m,u,v,cnt,fa[MN],siz[MN],w[MN],top[MN],dep[MN],id[MN],ID[MN],up[MN];
vector<int>edge[MN];
const int len=3;
void dfs1(int x){
	siz[x]=1;
	for(int i=0;i<edge[x].size();++i){
		fa[edge[x][i]]=x;
		dep[edge[x][i]]=dep[x]+1;
		dfs1(edge[x][i]);
		siz[x]+=siz[edge[x][i]];
		if(siz[w[x]]<siz[edge[x][i]])w[x]=edge[x][i];
	}
}
void dfs2(int x){
	id[x]=++cnt;
	ID[cnt]=x;
	if(w[x]){top[w[x]]=top[x];dfs2(w[x]);}
	if(x==top[x]){
		int p=x;
		for(int i=1;i<=len;++i){if(top[fa[p]]==1)break;p=top[fa[p]];}
		up[x]=p;
	}
	else up[x]=up[top[x]];
	for(int i=0;i<edge[x].size();++i)
		if(edge[x][i]!=w[x]){
			top[edge[x][i]]=edge[x][i];
			dfs2(edge[x][i]);
		}
}
int rt;
int jump(int x,int k){
	while(k>=dep[x]-dep[up[x]]+1){
		k-=(dep[x]-dep[up[x]]+1);
		x=fa[up[x]];
	}
	while(k>=id[x]-id[top[x]]+1){
		k-=(id[x]-id[top[x]]+1);
		x=fa[top[x]];
	}
	return ID[id[x]-k];
}
#define ui unsigned int
ui S;
#define LL long long
inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return S = x; 
}
int main(){
	n=read();m=read();scanf("%u",&S);
	rt=1;
	for(int i=1;i<=n;++i){
		fa[i]=read();
		if(!fa[i])rt=i;
		else edge[fa[i]].push_back(i);
	}
	dep[rt]=1;dfs1(rt);
	top[rt]=rt;dfs2(rt);
	LL ans=0;
	int lstans=0;
	for(int i=1;i<=m;++i){
		int x=(get(S)^lstans)%n+1;
		int k=(get(S)^lstans)%dep[x];
		lstans=jump(x,k);
		ans^=(LL)i*lstans;
	}
	printf("%lld\n",ans);
	return 0;
}

```

- #### 长链剖分

$\quad$ 终于到了正解~~但它随机数据是真的没优势~~

$\quad$ 我们考虑以最深深度的儿子为重儿子，然后记录这条链的所有节点（记录自顶向下第i个点是什么）和这条链顶上的相当于链长的信息。另外还要倍增出每个节点向上$2^p$个节点的父亲，对于每次查询的k，我们先把x跳到k第一个二进制位代表的数的位置，这样就可以把剩下的距离缩减到$\lfloor\frac{k}{2}\rfloor$以下，这样，当前这个节点的链长肯定比剩下要跳的长度更大了，所以直接向上跳即可。

另外，因为维护的信息等于链长，所以我们可以用每个点记录这个信息，就不用开```vector```了

$\quad$时间复杂度$O(nlogn+q)$

$\quad$实际运行总时间：11.8s（数组调用是真的慢）

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int a=0;char c=getchar();
	while(c>57 or c<48){c=getchar();}
	while(47<c and c<58){
		a=a*10+c-48;
		c=getchar();
	}
	return a;
}
#define MN 500005
int n,m,u,v,cnt,fa[MN][21],w[MN],h[MN];
int Log[MN],top[MN],dep[MN],id[MN],U[MN],D[MN];
vector<int>edge[MN];
void dfs1(int x){
	for(int i=1;i<=19;++i)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=0;i<edge[x].size();++i){
		dep[edge[x][i]]=h[edge[x][i]]=dep[x]+1;
		dfs1(edge[x][i]);
		h[x]=max(h[x],h[edge[x][i]]);
		if(h[edge[x][i]]>h[w[x]])w[x]=edge[x][i];
	}
}
void dfs2(int x,int p){
	id[x]=++cnt;
	D[cnt]=x;
	U[cnt]=p;
	if(w[x]){top[w[x]]=top[x];dfs2(w[x],fa[p][0]);}
	for(int i=0;i<edge[x].size();++i)
		if(edge[x][i]!=w[x]){
			top[edge[x][i]]=edge[x][i];
			dfs2(edge[x][i],edge[x][i]);
		}
}
int rt;
#define ui unsigned int
ui S;
#define LL long long
inline ui get() {
	S ^= S << 13;
	S ^= S >> 17;
	S ^= S << 5;
	return S; 
}
inline int ask(register int x,register int k){
	if(!k)return x;
	x=fa[x][Log[k]];k-=(1<<Log[k]);
	k-=dep[x]-dep[top[x]];x=top[x];
	if(k>=0) return U[id[x]+k];
	return D[id[x]-k];
}
int main(){
	n=read();m=read();scanf("%u",&S);
	Log[0]=-1;
	for(int i=1;i<=n;++i)Log[i]=Log[i>>1]+1;
	rt=1;
	for(int i=1;i<=n;++i){
		fa[i][0]=read();
		if(!fa[i][0])rt=i;
		else edge[fa[i][0]].push_back(i);
	}
	dep[rt]=1;dfs1(rt);
	top[rt]=rt;dfs2(rt,rt);
	LL ans=0;
	int lstans=0;
	for(int i=1;i<=m;++i){
		register int x=(get()^lstans)%n+1,k=(get()^lstans)%dep[x];
		lstans=ask(x,k);
		ans^=(LL)i*lstans;
	}
	printf("%lld\n",ans);
	return 0;
}
```

当然，这个表现和询问随机有很大的关系，况且多学一个做法也不是坏事。

---

## 作者：yurzhang (赞：47)

# Level Ancestor 问题的若干解法

Level Ancestor 问题（以下简称“LA 问题”）的描述如下：

> 对于一棵有根树 $T$，给出树上的一个结点 $x$ 与一个整数 $k\leqslant depth(x)$，求出结点 $x$ 的第 $k$ 个祖先

已经有许多优秀的文章对这个问题的经典解法进行了清楚的解释，因此本文将把重心放在对这个问题的研究过程进行分解。我将通过从基本的暴力算法一点点向经典解法靠近并拓展的方式向大家展示研究 LA 问题的思维路径。

这篇文章只关注 LA 问题的解法是如何一步步被优化的，因此只提供算法描述，不会提供具体代码。

## 算法一

可以考虑直接使用动态规划算法一次性预处理出所有答案并存在一张表里，基本的暴力算法。

预处理：$O(n^2)$，查询：$O(1)$

## 算法二

考虑对算法一进行优化，牺牲一部分查询的复杂度。

使用倍增的思想，对于每个结点预处理其到第 $1,2,4,\ldots,2^k$ 个祖先的**跳转指针**，这部分仍然可以通过动态规划算法完成。

查询时最坏情况下也只会跳转 $O(\lg n)$ 次。

预处理：$O(n\lg n)$，查询：$O(\lg n)$

## 算法三

让我们把算法二先放在一边，考虑使用**最长路径分解**。

我们将树中的一条最长路径从树中删去，原树将被划分成若干子树，接下来再对子树递归地进行上述操作，最后原树会被分解为若干条不相交路径。

这个分解过程可以被描述为一棵树，我们姑且称其为分解树。分解树中的每一个结点都对应原树的一条路径，我们只需要存储分解树中每个结点的父亲结点，以及每个结点对应路径的一端到另一端的所有原树结点即可。

于是对于 LA 问题的一次查询，当 $k$ 大于 $x$ 所处路径的长度时，我们可以通过分解树向上跳，否则答案必位于 $x$ 所处路径，可以直接查询。

显然在最坏情况下，我们的分解树会变成一条链，且结点对应路径长度分别为 $k,k-1,\ldots,2,1$，此时分解树树高是 $O(\sqrt n)$ 的。

预处理出每个结点的深度和高度，上述信息可以在 $O(n)$ 内处理完成。

预处理：$O(n)$，查询：$O(\sqrt n)$

## 算法四

考虑对算法三进行优化，使用**梯子分解**。

在**最长路径分解**的基础上，我们对每条路径额外存储其根节点在原树上的若干祖先，额外存储的祖先数等于该路径的长度。

对于 LA 问题的一次查询，我们发现 $x$ 所处的路径长度至少为 $x$ 在原树中的高度，于是向上跳转时我们可以利用额外存储的祖先（也即**梯子分解**中的梯子）来使得高度翻倍，于是最坏情况下的查询复杂度被我们降到了 $O(\lg n)$。预处理与算法三类似。

预处理：$O(n)$，查询：$O(\lg n)$

## 算法五

现在让我们把算法二和算法四结合起来。

对于 LA 问题的一次查询，我们先使用**跳转指针**跳最大的一步，此时答案的距离必定不超过刚刚跳的长度，即不超过当前位置的高度，于是我们可以通过额外存储的祖先立刻得到答案。

这就是 LA 问题的经典解法。

预处理：$O(n\lg n)$，查询：$O(1)$

## 算法六

考虑对算法五进一步优化。

查询的时间复杂度已经足够优秀了，我们考虑降低预处理的复杂度。预处理的瓶颈在于对于所有结点都存储了 $O(\lg n)$ 个到祖先的**跳转指针**。

我们发现要求一个结点的第 $k$ 级祖先，可以转换成求该结点所在路径的底端结点的第 $k'$ 级祖先，于是对于一条路径只需要存储最底端结点的 $O(\lg n)$ 个祖先即可。

对于整棵树，我们只预处理叶子结点的 $O(\lg n)$ 个祖先，预处理复杂度变为 $O(n+L\lg n)$，其中 $L$ 是叶子个数。对于一棵叶子个数为 $O(\frac{n}{\lg n})$ 的树，这个算法就可以达到 $O(n)$ 的预处理复杂度。

接下来我们考虑如何将任意树变为这样的一棵树。

### 剪枝（物理）

我们考虑将子树大小大于等于 $\frac14\lg n$ 的深度最大的结点的所有子结点从原树上剪下来，并记录其在原树上的父结点。接下来我们称原树剩下部分为宏观树，被剪去的部分为微观树。

此时宏观树叶子个数变为 $O(\frac{n}{\lg n})$，我们对宏观树使用上述提到的算法，在 $O(n)$ 时间内完成预处理。

接下来我们考虑对所有微观树使用算法一，由于大小为 $n$ 的本质不同的有根树的数量有一个 $2^{2n}$ 的上界（实则为卡特兰数），本质不同的微观树的数量不会超过 $2^{2(\frac14\lg n)}=\sqrt n$，因此对所有微观树预处理的复杂度为 $O(\sqrt n\lg^2n)$。

此时我们已经在 $O(n)$ 时间内完成预处理。对于每次查询，如果 $x$ 位于宏观树内，我们可以先找到其在宏观树上对应叶子并使用一次**跳转指针**和梯子得到答案，否则 $x$ 位于微观树内。我们考虑 $x$ 的第 $k$ 个祖先是否在宏观树内，如果是，则跳转到 $x$ 所在微观树对应的宏观树叶子上，以同样方式得到答案，否则直接查表。

至此，我们得到了一个花费 $O(n)$ 的空间，在 $O(n)$ 时间内预处理并 $O(1)$ 回答查询的静态树 LA 问题解法。

---

## 作者：b6e0_ (赞：41)

[博客不一定食用更佳](https://www.luogu.com.cn/blog/b6e0/tijie-P5903) [题目在这](https://www.luogu.com.cn/problem/P5903)

### update 2020.12.26 对不起给管理添麻烦了，修了图上文字的错误和算法的最后一步的错误，讲解了长链剖分

---
###  基础知识：

树上倍增，可以去 [LCA 模板](https://www.luogu.com.cn/problem/P3379)学；

[重链剖分](https://www.luogu.com.cn/problem/P3384)

---
我们的目标是预处理 $\mathcal O(n)$~$\mathcal O(n\log n)$，查询 $\mathcal O(1)$。
1. 假设你刚学循环，你看到这道题会怎么做？暴力往上跳，$\mathcal O(n)$ 预处理（读入），$\mathcal O(n)$ 查询。
2. 假设你刚学数组，你看到这道题会怎么做？每个点存祖先，$\mathcal O(n^2)$ 预处理，$\mathcal O(1)$ 查询，优化了 1 的查询，但增加了预处理的复杂度。
3. 假如你刚学树上倍增，你看到这道题会怎么做？记 $fa_{i,j}$ 表示 $i$ 的 $2^j$ 倍祖先，类似 LCA，$\mathcal O(n\log n)$ 预处理，$\mathcal O(\log n)$ 查询。优化了 1 的查询，增加了预处理的复杂度，但是在可接受范围内。
4. 假如你刚学重链剖分或者长链剖分，你看到这道题会怎么做？剖一下，往上跳，发现链顶过了就暴力跳（倍增跳也可以，但由于与 3 差不多，这里不再说了）。$\mathcal O(n)$ 预处理，$\mathcal O(n)$ 查询。

发现 2 优化了 1 $\mathcal O(n)$ 的查询，这里 4 也有一个 $\mathcal O(n)$ 的查询，于是我们想到用 2 优化 4 中的查询复杂度。考虑用 4 中特有的树链剖分来优化空间和预处理复杂度。

**记点 $x$ 的高度，即到子树内所有叶子最大的距离为 $h_x$。这里我们使用长链剖分**。长链剖分就是将重链剖分的“重儿子”改为高度最大的儿子，这样会使得链最长。由于每一条链的一端都是叶子，所以链长就是链顶的高度。

我们发现只会查询链顶的上祖先，于是改为**只对链顶记祖先**。但是空间和预处理的复杂度仍然可能会达到 $\mathcal O(n^2)$。发现**每个链顶记 1~链长 级祖先是可以被接受的，复杂度是 $\mathcal O(n)$**。读者易证。考虑优化 $k$ 级祖先中的 $k$，即将查询中的 $k$ 通过某种 $\mathcal O(1)$ 的手段缩小至某条链的链长。

我们发现用 3 进行预处理后，跳 $2$ 的次方是 $\mathcal O(1)$ 的。我们想尽可能地接近答案，这样会使需要预处理的东西尽可能少，所以我们跳到 $2^{\log_2(k)}$ 级祖先。我们只处理链顶的祖先，所以还需要调到这个位置的链顶。然后神奇地发现，剩下**如果不管目标是在上还是下，与目标的差（深度差）一定小于链长度**！证明：

**（看不懂别走，下面有图。）**

因为 $x$ 的 $k$ 级祖先的高度 $\ge k$，所以 $x$ 的 $k$ 级祖先所在的长链的长度也 $\ge k$。设 $2^{\left\lfloor\log_2(k)\right\rfloor}=t$，那么可以显然地发现 $k\ge t>k-t$。我们跳完后，就变成了要求 $x$ 的 $k-t$ 级祖先。这时，$x$ 由于是原来的 $t$ 级祖先，那么 $x$ 所在的链长一定 $\ge t$。再由于 $t>k-t$，所以 $x$ 所在的链长一定 $>k-t$。所以，答案一定在链顶的上下链长范围内，也就是链长范围内。

如果没懂，看图会更清楚一些：

![](https://cdn.luogu.com.cn/upload/image_hosting/2vio1tjy.png)

于是，我们增加一个东西，记录每个链顶往上 链长个和往下 链长个节点。预处理时间复杂度为 $\mathcal O(n\log n)$，瓶颈在倍增；查询时间复杂度为 $\mathcal O(1)$，可以接受。

代码：
```cpp
#include<bits/stdc++.h>
using namepace std;
vector<int>g[500010],up[500010],down[500010];//g存树，up表示向上的节点，down类似，必须要用vector存
int binh[500010],dep[500010],h[500010],hson[500010],tp[500010],fa[500010][20];//binh[i]表示i的最高位的位数，也就是log2(i)，dep是深度，h是高度，hson是长儿子（类似重链剖分），tp是链顶，fa是倍增
unsigned int s;//题目中给的种子
inline int read()//快读
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return x;
}
inline void write(long long x)//快写
{
	if(!x)
	{
		putchar('0');
		return;
	}
	int sta[20],tp=0;
	while(x)
	{
		sta[++tp]=x%10;
		x/=10;
	}
	while(tp)
		putchar(sta[tp--]+'0');
}
inline unsigned int get(unsigned int x)//题目中给的随机函数
{
	x^=x<<13;
	x^=x>>17;
	x^=x<<5;
	return s=x; 
}
void dfs(int x,int f)//类似重链剖分，第一次dfs，求dep,fa,hson,h
{
	dep[x]=dep[f]+1;
	fa[x][0]=f;
	for(int i=1;i<20;i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	h[x]=-1;
	for(int i=0;i<g[x].size();i++)
	{
		dfs(g[x][i],x);
		if(h[g[x][i]]>h[x])
		{
			hson[x]=g[x][i];
			h[x]=h[g[x][i]];
		}
	}
	h[x]++;
	if(!h[x])//如果是叶子
		h[x]=1;
}
void dfs2(int x,int ttp)//类似重链剖分，第二次dfs，求up,down,tp
{
	down[ttp].push_back(x);
	tp[x]=ttp;
	if(g[x].empty())
		return;
	dfs2(hson[x],ttp);
	for(int i=0;i<g[x].size();i++)
		if(g[x][i]!=hson[x])
		{
			up[g[x][i]].push_back(g[x][i]);
			for(int j=1;j<=h[g[x][i]];j++)
				up[g[x][i]].push_back(fa[up[g[x][i]].back()][0]);
			dfs2(g[x][i],g[x][i]);
		}
}
int main()
{
	int n=read(),q=read(),i,root,x,k,lastans=0;
	long long out=0;
	cin>>s;
	for(i=1;i<=n;i++)
	{
		x=read();
		if(!x)
			root=i;
		else
			g[x].push_back(i);
		binh[i]=log2(i);
	}
	dfs(root,root);
	up[root].push_back(root);
	for(i=1;i<=h[root];i++)
		up[root].push_back(fa[up[root].back()][0]);
	dfs2(root,root);
	for(i=1;i<=q;i++)
	{
		x=(get(s)^lastans)%n+1;
		k=(get(s)^lastans)%dep[x];
		if(!k)//0级祖先要特判
		{
			lastans=x;
			out^=1ll*i*x;
			continue;
		}
		int tod=dep[x]-k;//目标深度
		x=tp[fa[x][binh[k]]];//先跳一步
		int tpd=dep[x];//目前深度
		if(tpd<tod)
			x=down[x][tod-tpd];
		else
			x=up[x][tpd-tod];
		lastans=x;
		out^=1ll*i*x;
	}
	write(out);
	return 0;
}
```
觉得好就点个赞吧，有问题或者建议欢迎在评论区提出来。

---

## 作者：YLWang (赞：31)

提供一个时间 $O(n\log\log n-q\log\log n)$，空间 $O(n\log\log n)$ 的做法。

考虑用重剖做。每次如果能跳就暴力跳到链顶，否则答案在这条重链上，容易通过 dfs 序做到 $O(1)$ 查出。总时间复杂度 $O(n-q\log n)$，空间复杂度 $O(n)$。

然后我们发现这个事情和求 LCA 那个倍增非常像。于是我们可以预处理出来跳 $2^k$ 次重链能到的点，这样就可以平衡查询和预处理的复杂度了。

非常好写，且在需要重剖的时候顺便一求更方便。在 2020 年一般电脑能 10s 跑出来的数据范围内基本不劣于长剖，原因是长剖内存操作和跳跃访问比较多，常数会相对较大。

代码链接：https://www.luogu.com.cn/paste/97df80cx。




---

## 作者：LCuter (赞：16)

## 树上 $k$ 级祖先

[P5903 树上 k 级祖先](https://www.luogu.com.cn/problem/P5903)

先讲长链剖分。对于树上的节点，它所保存的与树形态有关的信息有两个，一个是子树大小，一个是向下延伸链长。回顾重链剖分，实际上就是利用了前者，那么长链剖分实际上就是利用了后者，它的“长”儿子实际上是向下延伸链长最大的儿子。

容易发现长链剖分的过程是 $O(n)$ 的。我们考虑如何使用长链剖分解决树上 $k$ 级祖先问题。

考虑倍增求解该问题的过程，我们希望询问做到 $O(1)$ 而非 $O(\log n)$。倍增将时间浪费在了跳的过程中。有没有这样一种方法，我们先利用倍增思想跳出最开始那最大的一步，后面的一步搞定呢？我们来看长链剖分后的一条性质：

> 一个节点的 $k$ 级祖先所在的长链长大于等于 $k$

证明十分显然。有了这个结论后我们再来看原问题，我们设 $k$ 的二进制最高位为 $\log_2h$，那么我们先跳这一步，然后将问题转换为求 $k-h$ 级祖先。不难发现，跳完之后的当前节点所在的长链长一定大于 $h$，因为它是初始节点的 $h$ 级祖先。那么进一步地，由于 $h>k-h$，跳完之后的当前节点所在的长链长一定**大于** $k-h$。

这启发我们设计一个算法：

1. 长链剖分，对于每条链的链头，设该链长为 $l$，我们预处理出这条链的所有节点，以及链头向上 $l$ 个节点，容易发现最后只会记录 $2n$ 个节点，不影响 $O(n)$ 的复杂度。
2. 对每个点处理倍增数组，这一步是 $O(n\log n)$ 的。
3. 求出 $\text{High-bit}(i),i\in[1,n]$，这里是可以做到 $O(n)$ 的。
4. 对于询问 $x$ 的 $k$ 级祖先，先向上跳 $2^{\text{High-bit(k)}}$ 级，然后根据 $\text{dep}$ 直接判断待求节点在链头上还是下，然后直接跳。

复杂度显然是 $O(n\log n+q)$ 的。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define LL long long
#define UI unsigned int
#define MAXN 500005
using namespace std;
inline int read(){
    REG int x(0);
    REG char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x*10)+(c^48),c=getchar();
    return x;
}

int n,q,rt;
vector<int> NodeUp[MAXN],NodeDown[MAXN],Edge[MAXN];
int Dep[MAXN],MDep[MAXN],Son[MAXN],Top[MAXN],HighBit[MAXN];
int Fat[MAXN][21];
LL ans;
int lastans;

UI s;
UI Get(UI x){
    x^=x<<13;
    x^=x>>17;
    x^=x<<5;
    return s=x;
}

void dfs1(int now){
    MDep[now]=Dep[now]=Dep[Fat[now][0]]+1;
    for(auto v:Edge[now]){
        Fat[v][0]=now;
        for(REG int i=0;Fat[v][i];++i)
            Fat[v][i+1]=Fat[Fat[v][i]][i];
        dfs1(v);
        if(MDep[v]>MDep[now]) MDep[now]=MDep[v],Son[now]=v;
    }
}

void dfs2(int now,int top){
    Top[now]=top;
    if(now==top){
        for(REG int i=0,f=now;i<=MDep[now]-Dep[now];++i)
            NodeUp[now].push_back(f),f=Fat[f][0];
        for(REG int i=0,f=now;i<=MDep[now]-Dep[now];++i)
            NodeDown[now].push_back(f),f=Son[f];
    }
    if(Son[now]) dfs2(Son[now],top);
    for(auto v:Edge[now])
        if(v^Son[now]) dfs2(v,v);
}

inline int Ask(int x,int k){
    if(!k) return x;
    x=Fat[x][HighBit[k]],k-=(1<<HighBit[k]),k-=Dep[x]-Dep[Top[x]],x=Top[x];
    return k>=0?NodeUp[x][k]:NodeDown[x][-k];
}

void Solve(){
    n=read(),q=read(),s=read(),HighBit[1]=0;
    for(REG int i=2;i<=n;++i)
        HighBit[i]=HighBit[i>>1]+1;
    for(REG int i=1;i<=n;++i)
        Edge[read()].push_back(i);
    rt=Edge[0][0];
    dfs1(rt);
    dfs2(rt,rt);
    for(REG int i=1;i<=q;++i){
        int x=((Get(s)^lastans)%n)+1;
        int k=((Get(s)^lastans)%Dep[x]);
        lastans=Ask(x,k);
        ans^=1ll*i*lastans;
    }
    printf("%lld\n",ans);
}

int main(){
    Solve();
}
```

## 

---

## 作者：gxy001 (赞：13)

**UPD:** 补了个代码实现。

**UPD2:** 修复一处代码 bug。

网上没搜到欧拉序做法的博客，所以我就写了这篇博客。

## 利用欧拉序将 LA（Level-Ancestors） 问题转化为 $\pm 1$ FS（Find-Smaller）问题

注意到，$x$ 的深度为 $d$ 的祖先，在欧拉序上，是 $x$ 后面的第一个深度 $\le d$ 的节点，问题转化为 FS 问题，并且欧拉序具有 $\pm 1$ 性质，所以问题变为 $\pm 1$ FS 问题，该问题有着线性预处理，常数查询的在线做法。

$i$ 后面第一个 $\le x$ 的数的位置，记作 $\mathrm{FS}(i,x)$。

## $\pm 1$ FS 问题的 $\mathrm O(n\log n)$ 预处理，$\mathrm O(1)$ 查询的在线做法

**定义** $\mathrm {ctz}(i)$ 表示最大的满足 $2^k\mid i$ 的 $k$。

**定义** $\mathrm{lbt}(i,j)$（$i\le j$）表示，$[i,j]$ 内的所有整数中 $\mathrm{ctz}$ 最大的数；当 $i\le 0$ 时，定义其值为 $0$。

**引理** 对于任意 $i,j$（$i\le j$），令 $k=\mathrm{lbt}(i,j)$，显然有 $j-i+1\le 2^{\mathrm{ctz}(k)+1}$，以及 $j-k+1\le 2^{\mathrm{ctz}(k)}$。

$\pm 1$ FS 问题中给出的数组为 $a_{0\sim n-1}$，定义 $f(i)=3\times2^{\mathrm{ctz}(i)}$，$f(0)=n$。

对于每个 $0\le i<n$，预处理出数组 $B_{i,1\sim f(i)}$，其中 $B_{i,j}=\mathrm{FS}(i,a_i-j)$。

查询 $\mathrm{FS}(i,x)$ 时：

- 若 $x\ge a_i$，答案为 $i$；
- 令 $d=a_i-x$，若 $d\le f(i)$，答案为 $B_{i,d}$；
- 否则，令 $k=\mathrm{lbt}(i-d+1,i)$，答案为 $B_{k,a_k-x}$。

接下来给出证明。

首先证明 $a_k-x\le f(k)$：

$$
\begin{aligned}
2^{\mathrm{ctz}(k)+1}&>i-(i-d+1)=d-1=a_i-x-1\\
2^{\mathrm{ctz}(k)}&>i-k\\
3\times2^{\mathrm{ctz}(k)}&\ge a_i+i-k-x\ge a_k-x
\end{aligned}
$$

注意 $a_i+i-k\ge a_k$ 来自于 $\pm 1$ 性质。

然后证明 $\mathrm{FS}(k,x)=\mathrm{FS}(i,x)$。

有 $k>i-d=i-a_i+x$，即，$a_k\cdots a_i$ 所有数都 $\ge a_i-(i-k)>x$，所以有 $\mathrm{FS}(k,x)=\mathrm{FS}(i,x)$。

注意这一证明也依赖于 $\pm 1$ 性质。

$B$ 数组的预处理是简单的，我们从后往前扫一遍，开桶记录每个数的最靠前的出现位置，就可以预处理出来（因为 $\pm 1$ 性质，$\mathrm{FS}(i,a_i-j)$ 一定是 $i$ 后面最靠前的值为 $a_i-j$ 的位置），显然有 $B$ 数组的总长是 $\mathrm O(n\log n)$ 的。

由此，我们获得了 $\mathrm O(n\log n)$ 预处理，$\mathrm O(1)$ 查询的在线做法。

## $\mathrm O(n)$ 预处理，$O(1)$ 查询

首先按 $\mathrm O(\log n)$ 分块。

### 块间

第 $i$ 个块表示编号为 $ib\sim ib+b-1$ 的点。

对每个块，存储 $N_{i,1\sim 2b}$，其中 $N_{i,j}=\mathrm {FS}(ib,a_{ib}-j)$。

对每个块，存储 $F_{i,1\sim f(i)}$，其中 $F_{i,j}=\left\lfloor\frac{\mathrm{FS}(ib,a_{ib}-jb)}{b}\right\rfloor$，即 $\mathrm{FS}(ib,a_{ib}-jb)$ 所在的块。

注意到有令 $k=F_{i,j}$，则有 $a_{ib}-jb\le a_{kb}<a_{ib}-(j-1)b$，这一式子可以简单的使用 $\pm 1$ 性质给出证明。

$N,F$ 数组的预处理方式类似上文中的 $B$ 数组。

查询 $\mathrm{FS}(ib+j,x)$（$j<b$）时：

- 若 $x\ge a_{ib+j}$，返回 $ib+j$；
- 若 $j>0$：
  - 通过块内查询，若答案在块内，则直接返回；
  - 若答案不在块内，返回 $\mathrm{FS}((i+1)b,x)$；
- $j=0$：
  - 若 $x\ge a_{ib}-2b$，返回 $N_{i,a_{ib}-x}$；（3）
  - 令 $d=\left\lfloor\frac{a_{ib}-x}{b}\right\rfloor$：
    - 若 $d\le f(i)$，令 $k=F_{i,d}$，返回 $\mathrm{FS}(kb,x)$；（2）
    - 否则，令 $k=\mathrm{lbt}(i-d+1,i)$，返回 $\mathrm{FS}(kb,x)$。（1）

通过与之前证明类似的方式，我们可以证明，情况（1）一定会跳转至情况（2），这里不多赘述。

接下来证明情况（2）一定会跳转至情况（3）。

$$
a_{kb}<a_{ib}-(d-1)b<x+2b
$$

由此，我们获得了块间的处理方式。

### 块内

接下来介绍的是利用位掩码的方法，这种方法块长一般取 $w$。

$$
m(i,j)=\begin{cases}1&a_j<\min\{a_i,\dots,a_{j-1}\}\\0&\mathrm{otherwise}.\end{cases}
$$

那么，$m(ib+j,ib+j+1),m(ib+j,ib+j+2)\dots m(ib+j,ib+(b-1))$ 中第 $a_{ib+j}-x$ 个 $1$ 的位置就对应 $\mathrm{FS}(ib+j,x)$，如果不存在这样的位置，则说明答案不在块内。

我们将 $m(ib+j,ib+j+1),m(ib+j,ib+j+2)\dots m(ib+j,ib+(b-1))$ 压入一个数 $m_{ib+j}$ 内，查询即为查找第 $k$ 个为 $1$ 的二进制位位置，这一操作可以进行一些预处理后 $O(1)$ 实现。（据说存在部分硬件支持相关指令直接查询，我不太了解这方面）

由此，我们获得了块内的处理方式。

至此，我们获得了解决 LA 问题的线性预处理，常数在线查询的算法。

我看的这个论文最后给了点申必常数优化，我是完全没看懂，贴个[链接](https://arxiv.org/pdf/0909.1030.pdf)。

下面是我写的实现，很烂，没有任何常数优化，轻喷。

```cpp
#include<iostream>
#include<vector>
#include<bit>
using std::cin,std::cout;
unsigned s;
inline unsigned get(){
	s^=s<<13;
	s^=s>>17;
	s^=s<<5;
	return s;
}
int n,q,rt,p[500010],cnt,dfn[1000010],tmp[500010],d[500010];
unsigned long long t[1000010];
std::vector<int> v[500010],f[16010],g[16010];
void dfs(int x){
	dfn[p[x]=cnt++]=x;
	for(auto u:v[x]){
		d[u]=d[x]+1,dfs(u);
		dfn[cnt++]=x;
	}
}
int lbt(int x,int y){
	if(x<=0) return 0;
	return y&~(std::bit_floor(unsigned(--x^y))-1);
}
int o[65536][16],pc[65536];
int squery(unsigned long long p,int x){
	int u=p&65535;
	if(x<pc[u]) return o[u][x];
	x-=pc[u],p>>=16,u=p&65535;
	if(x<pc[u]) return 16+o[u][x];
	x-=pc[u],p>>=16,u=p&65535;
	if(x<pc[u]) return 32+o[u][x];
	x-=pc[u],u=p>>16;
	if(x<pc[u]) return 48+o[u][x];
	return -1;
}
int query(int x,int k){
	if(d[dfn[x]]<=k) return dfn[x];
	if(x&63){
		int u=squery(t[x],d[dfn[x]]-k);
		if(u!=-1) return dfn[x+u];
		x=(x+64)&~63;
		if(d[dfn[x]]==k) return dfn[x];
	}
	int i=x>>6;
	int p=d[dfn[x]]-k;
	if(p<=128) return g[i][p-1];
	p>>=6;
	if(p<=(int)f[i].size()) return query(f[i][p-1]<<6,k);
	return query(lbt(i-p+1,i)<<6,k);
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	for(int i=0;i<65536;i++){
		int cnt=0;
		for(int j=0;j<16;j++) if(i>>j&1) o[i][cnt++]=j;
		pc[i]=cnt;
	}
	cin>>n>>q>>s;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		if(x) v[x].push_back(i);
		else rt=i;
	}
	dfs(rt);
	int m=(cnt+63)>>6;
	for(int i=0;i<m;i++) f[i].resize(std::min(d[dfn[i<<6]]>>6,3*(i&-i))),g[i].resize(std::min(d[dfn[i<<6]],128));
	for(int i=cnt-1;~i;i--){
		tmp[d[dfn[i]]]=i;
		if((i&63)==0){
			int k=i>>6;
			for(unsigned j=0;j<f[k].size();j++) f[k][j]=tmp[d[dfn[i]]-((j+1)<<6)]>>6;
			for(unsigned j=0;j<g[k].size();j++) g[k][j]=dfn[tmp[d[dfn[i]]-j-1]];
		}
	}
	for(int l=0;l<cnt;l+=64){
		int r=std::min(l+63,cnt-1);
		static int stk[100];
		int tp=0;
		stk[++tp]=r,t[r]=1;
		for(int i=r-1;i>=l;i--){
			t[i]=t[i+1]<<1|1;
			while(tp&&d[dfn[i]]<=d[dfn[stk[tp]]]) t[i]^=1ull<<(stk[tp]-i),--tp;
			stk[++tp]=i;
		}
	}
	long long int ans=0;
	int lans=0;
	for(int i=1;i<=q;i++){
		int x=(get()^lans)%n+1;
		int k=(get()^lans)%(d[x]+1);
		ans^=1ull*i*(lans=query(p[x],d[x]-k));
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：0xFF (赞：7)

#### 题目大意


------------
给出一个 $n$ 个节点的有根树，每次询问给出 $x,k$，输出 $x$ 的 $k$ 级祖先。

#### 思路分析（一）


------------
最简单的写法是树上倍增。

类似于求解 LCA 的倍增法。

首先预处理出每个节点的 $2^k$ 级祖先

`fa[u][i]=fa[fa[u][i-1]][i-1]`

`fa[u][i]` 表示 $u$ 节点的 $2^i$ 级祖先。

将 $k$ 进行二进制拆分，如果拆分后第 $i$ 位为 $1$，表示向上跳到当前位置的 $2^{i-1}$ 级祖先。

#### 代码实现（一）


------------
```cpp
struct Edge{
	int to,next;
}edge[N<<1];
int head[N],idx;
void add(int a,int b){
	edge[++idx].to = b , edge[idx].next = head[a] , head[a] = idx;
}
int depth[N],fa[N][25],lg[N];
void dfs(int u,int fath){
	fa[u][0] = fath , depth[u] = depth[fath] + 1;
	for(int i=1;i<=lg[depth[u]];i++){
		fa[u][i] = fa[fa[u][i-1]][i-1];
	}
	for(int i=head[u];i;i=edge[i].next){
		int v = edge[i].to;
		if(v == fath) continue;
		dfs(v,u);
	}
}
int find(int u,int k){
	int cnt = 0;
	while(k){
		if(k & 1) u = fa[u][cnt];
		k >>= 1;
		cnt++;
	}
	return u;
}
int main(){
	LL n = read() , q = read();
	cin>>s;
	for(int i=2;i<=n;i++){
		lg[i] = lg[i>>1] + 1;
	}
	LL tmp1;
	for(LL i=1;i<=n;i++){
		LL x = read();
		fa[i][0] = x;
		if(x == 0) tmp1 = i;
		else add(x,i) , add(i,x);
	}
	dfs(tmp1,0);
	long long ans = 0;
	LL res = 0;
	for(LL i=1;i<=q;i++){
		LL x = ((get(s) ^ res) % n) + 1;
		LL k = (get(s) ^ res) % depth[x];
		res = find(x,k);
		ans ^= (1ll * i * res);
	}
	printf("%lld\n",ans);
	return 0;
}
```

#### 思路分析（二）


------------
考虑树剖求解。

每次向上跳到链顶与目标点比较，如果所在链的链顶的深度大于目标点的深度，则可以继续跳。

若当前所在的点和目标点处于同一条链上，由于之前树剖中求出了每一个点的 dfs 序，直接向上跳两点的 dfs 序之差步即可，因为一条链上的点的 dfs 序是连续的，所以两点的层数之差即为两点 dfs 序之差。

#### 代码实现（二）


------------
```cpp
struct Edge{
	int to,next;
}edge[N<<1];
int head[N],idx;
inline void add(int a,int b){
	edge[++idx].to = b , edge[idx].next = head[a] , head[a] = idx;
}
int fa[N],siz[N],top[N],depth[N],son[N],dfn[N],id[N],cnt;
void dfs1(int u,int fath){
	fa[u] = fath , depth[u] = depth[fath] + 1 , siz[u] = 1;
	for(int i=head[u];i;i=edge[i].next){
		int v = edge[i].to;
		if(v == fath) continue;
		dfs1(v,u);
		siz[u] += siz[v];
		if(siz[son[u]] < siz[v]) son[u] = v;
	}
}
void dfs2(int u,int topf){
	top[u] = topf;
	dfn[u] = ++cnt;
	id[dfn[u]] = u;
	if(!son[u]) return;
	dfs2(son[u],topf);
	for(int i=head[u];i;i=edge[i].next){
		int v = edge[i].to;
		if(v == fa[u] || v == son[u]) continue;
		dfs2(v,v);
	}
}
int ans[N];
int find(int u,int k){
	k = depth[u] - k;
	while(depth[top[u]] > k){
		u = fa[top[u]];
	}
	return id[dfn[u] - (depth[u] - k)];
}
int main(){
	int n = read() , q = read();
	cin>>s;
	int tmp;
	for(int i=1;i<=n;i++){
		int x = read();
		fa[i] = x;
		if(x == 0){
			tmp = i;
		} 
		else{
			add(x,i);add(i,x);
		}
	}
	dfs1(tmp,0);
	dfs2(tmp,0);
	long long ans = 0;
	int res = 0;
	for(int i=1;i<=q;i++){
		int x = ((get(s) ^ res) % n) + 1;
		int k = (get(s) ^ res) % depth[x];
		res = find(x,k);
		ans ^= (1ll * i * res);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：青鸟_Blue_Bird (赞：6)

## 这是一篇重链剖分的题解

~~(长链剖分哭了）~~

首先，重链剖分最最简单也是最最常见的应用就是求LCA了。
那么，对于这种树上K级祖先，我们是否可以应用重链剖分呢？

### 当然可以

首先，考虑这道题目和经典LCA的区别。
经典LCA求的是最近的祖先，而我们要求的是K级祖先。
那么，我们一次次只跳链顶肯定是不行了。

### 如何解决？

记录一个dfs序，命名为dfn（tarjan既视感）。
然后再开一个数组re，记录我们每个dfn所对应的点。这样，只要我们知道了祖先的dfn，我们就可以求出其编号了。

那么，如何知道祖先的dfn呢？？
有个地方万不能忘记
#### 我们是知道祖先的深度的。

所以，首先我们先把点跳到其祖先的上面。然后，再通过该点和其祖先的深度差直接算出祖先的dfn。

为什么可行？因为每个点和其祖先的dfn是连续的。当我们跳到K级祖先的上面的时候，反而成为了K级祖先的祖先。

千少万少，代码不可少：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000100
#define ll long long
#define ui unsigned int
ui S;

/*正解应该写长链剖分，但这里用的重链剖分*/

inline ui get(ui x) {
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    return S = x; 
} /*题目给的*/

inline int read(){
	int x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-')s = -1;
		c = getchar();
	} 
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = getchar();
	}
	return x * s;
}

int root;
int dfn[N], rev[N], id = 0;
int fa[N], son[N];
int deth[N], siz[N], top[N];

struct node{
	int u, v;
	int next;
} t[N << 1];
int f[N];

int bian = 0;
inline void add(int u, int v){
	t[++bian] = (node){u, v, f[u]};
	f[u] = bian;
	t[++bian] = (node){v, u, f[v]};
	f[v] = bian;
	return ;
}
  
/*两次dfs*/
void dfs1(int now){
	siz[now] = 1;
	for(int i = f[now]; i;i = t[i].next){
		int v = t[i].v, u = t[i].u;
		if(v != fa[u]){
			fa[v] = u;
			deth[v] = deth[u] + 1;
			dfs1(v);
			siz[u] += siz[v];
			if(siz[son[u]] < siz[v]){
				son[u] = v;
			}
		}
	}
	return ;
}

void dfs2(int now){
	dfn[now] = ++id;
	rev[id] = now;
	if(!son[now])return ;
	top[son[now]] = top[now];
	dfs2(son[now]);
	for(int i = f[now]; i;i = t[i].next){
		int v = t[i].v, u = t[i].u;
		if(v != son[u] && v != fa[u]){
			top[v] = v;
			dfs2(v);
		}
	}
	return ;
}

int jump(int x, int k) {
    int temp = deth[x] - k;
    while (deth[top[x]] > temp) x = fa[top[x]];
    temp = deth[x] - temp;
    return rev[dfn[x] - temp];
}

int main(){
//	freopen("hh.txt", "r", stdin);
	int n = read(), q = read(); cin >> S;
	for(int i = 1;i <= n; i++){
		fa[i] = read();
		if(!fa[i]) root = i;
		else add(fa[i], i);
	}
	deth[root] = 1; /*不要忘记初始化哦*/
	dfs1(root);
	top[root] = root;
	dfs2(root);
	ll ltans = 0, ans = 0;  /*不开long long见祖宗*/
	for(int i = 1;i <= q; i++){
		int x = (get(S) ^ ltans) % n + 1;
		int k = (get(S) ^ ltans) % deth[x];
		ltans = jump(x, k);
		ans ^= (ll)i * ltans;
	}
	printf("%lld\n", ans);
	return 0;
}
```
## 后置芝士：
### 有关vector
首先，我在题解中看到了各路大神都使用了vector。vector这东西说好也好，说好也不好，很多时候使用确实比前向星方便，但是在处理一些问题的时候，vector确实拖时间后退。

### inline

其次，看到有很多非正解（当然包括我）的小伙伴交这道题的代码TLE了一些点。其实，这很大程度上跟乱加inline是有关的。inline是加速函数的好东西，但是只限于不带循环的小函数的调用，比如加边等等。如果是大型函数（比如dfs、SPFA函数等等），加上inline反而会大大拖慢函数速度（当然你的编译器要调用，一般这个会被忽略）。


### 等蒟蒻不再蒟了就补一下正解吧



---

## 作者：JoaoFelix (赞：5)

想用倍增水过，卡了卡常，加了点神奇的优化，无果！

然后想了想树剖lca那样的写法，于是yy出一种做法，其实也不是正确复杂度的，但是跑的好像比std快！

因为我们已知ans的深度！

我们不断跳top，使u = top[u]
直到u和ans的top相等，这个判一下dep就可以实现了！

然后这是发现当前的u和ans所在dfs序是连续的，我们只需要在dfs序上记录一个rev（代码中的r数组），然后dep相减，我们就可以得到ans了！

感觉讲的不是很清楚QuQ！

看一下代码吧，应该就可以理解了！

```cpp
inline int Jump(int x, int k) {
	int d = dep[x] - k;
	while (dep[top[x]] > d) x = fa[top[x]];
	d = dep[x] - d;
	return r[dfn[x] - d];
}
```
两遍dfs：

```cpp
inline void dfs1(int x) {
	dep[x] = dep[fa[x]] + 1; sz[x] = 1;
	for (int i = head[x]; i; i = nxt[i]) {
		int y = to[i];
		dfs1(y); sz[x] += sz[y];
		if (sz[y] > sz[son[x]]) son[x] = y;
	}
}
inline void dfs2(int x, int tp) {
	top[x] = tp; dfn[x] = ++Id; r[Id] = x;
	if (son[x]) dfs2(son[x], tp);
	for (int i = head[x]; i; i = nxt[i]) {
		int y = to[i]; 
		if (y != son[x]) dfs2(y, y);
	}
}
```
这个复杂度是：O((N+Q)logN) 严重跑不满QWQ

所以说用长链剖分求k级祖先~~或许没用~~

但是长链剖分还是可以处理一类许多其他的问题！

---

## 作者：Gary88 (赞：3)

## 倍增+卡常+~~卡随机数据~~
首先我们维护节点x的$2^i$级祖先$f[x][i]$和它的深度$d[x]$，对于每一个询问，我们设$y=d[x]-k$，即所求祖先的深度，接着$i$从$19$查到$0$，倒着查，如果$d[f[x][i]]\ge y$，我们就令$x=f[x][i]$从$i-1$开始继续查，直到$i$为$0$为止，答案就是此时的$x$，时间复杂度$O((q+n)logn)$，~~明显不行~~

怎么办呢？

我们发现在任何情况下，这种算法都一定会跑满$O((q+n)logn)$，但是在随机数据下，对于每一次询问，如果$d[f[x][i]]< y$我们这一次查询就是无用的，浪费很多时间，有没有什么办法让我们只跑有用的情况呢？答案是有。

我们发现$d[f[x][i]]\ge y$相当于$2^{i}\le k$，那么如果我们把k转化为二进制，我们发现，若$(k)_2$的第$i$位为$1$，则这种情况就是有效的。所以我们可以预处理出来$1$到$n$的所有数的最高二进制位$lg2[k]$，每次让$x=f[x][lg2[k]]$，再让$k=k-2^i$直到$k=0$，时间复杂度还是$O((q+n)logn)$，~~但是能过~~

代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
#define ui unsigned int
ui s;
long long ans;
inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return s = x; 
}
int n,m,p,h[500001],f[600001][20],d[500001],lastans,root,lg2[500001],mi[20];
struct pp
{
	int to,ne;
}a[500001];
void add(int x,int y)
{
	a[++p].to=y;
	a[p].ne=h[x];
	h[x]=p;
}
void dfs(int x,int fa)
{
	d[x]=d[fa]+1;
	for(int i=h[x];i;i=a[i].ne)
	{
		dfs(a[i].to,x);
	}
}
int find(int x,int y)
{
	while(y)
	{
		x=f[x][lg2[y]];
		y^=mi[lg2[y]];
	}
	return x;
}
int main()
{
	lg2[1]=0;
	for(int i=2;i<=500000;i++)
	lg2[i]=lg2[i>>1]+1;
	for(int i=0;i<20;i++)
	mi[i]=1<<i;
	scanf("%d%d%u",&n,&m,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&f[i][0]);
		if(f[i][0])
		add(f[i][0],i);
		else
		root=i;
	}
	dfs(root,0);
	for(int i=1;i<=19;i++)
	for(int j=1;j<=n;j++)
	f[j][i]=f[f[j][i-1]][i-1];
	for(int i=1;i<=m;i++)
	{
		int x,y;
		x=(get(s)^lastans)%n+1;
		y=(get(s)^lastans)%d[x];
		lastans=find(x,y);
		ans^=(long long)i*lastans;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：幻离ian (赞：3)

# 思路：

### 树上倍增

看题解里好多巨佬用的是树链剖分，然鹅我不会……

然后想起树上倍增预处理时已经存好每个节点的第$2^k$个祖先，然后把第k个祖先二进制分解往上跳就行了。

复杂度：预处理$O(n\times \log_2 n)$+询问$O(q\times \log_2 n)$


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,q,nex[1000005],fir[1000005],go[1000005],tot,dep[500005],f[500005][21];
int x,y,ls;
long long ans;
#define ui unsigned int
ui s;
inline ui get(ui x) {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return s = x; 
}

void Add(int u,int v){//连边 
	nex[++tot]=fir[u];fir[u] = tot;go[tot]=v;
	nex[++tot] = fir[v];fir[v] = tot;go[tot]=u;
}
void deal(int u,int fa){//树上倍增预处理 
	dep[u]=dep[fa]+1;
	for(int i = 0;i<=19;i++)
		f[u][i+1]=f[f[u][i]][i];
	for(int e=fir[u];e;e=nex[e]){
		int v=go[e];
		if(v==fa)continue;
		f[v][0]=u;
		deal(v,u);
	}
}
int find(int x,int k){//把k二进制拆分 
	for(int i = 20;i>=0;i--)
		if((1<<i)<=k)x=f[x][i],k-=1<<i;
	return x;
}
int main(){
	cin>>n>>q>>s;
	for(int i = 1;i<=n;i++){
		scanf("%d",&x);
		if(x==0){
			y=i;//用y记录下根节点 
			continue;
		}
		Add(i,x);
	}
	deal(y,0);
	for(int i = 1;i<=q;i++){
		x=(get(s)^ls)%n+1;
		y=(get(s)^ls)%dep[x];ls=find(x,y);
		ans^=(long long)i*ls;
	}
	cout<<ans;
	return 0;
}
```



---


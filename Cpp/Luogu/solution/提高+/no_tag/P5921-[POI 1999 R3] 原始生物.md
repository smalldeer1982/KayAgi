# [POI 1999 R3] 原始生物

## 题目背景

鸣谢 `@Jiangly` 提出错误，`@NaCly_Fish` 修改数据。

## 题目描述

原始生物的遗传密码是一个自然数的序列 $K=\{a_1,\dots,a_n\}$。

原始生物的特征是指在遗传密码 $K$ 中连续出现的数对 $(l,r)$，即存在自然数 $i$ 使得 $l=a_i$ 且 $r=a_{i+1}$。保证不存在 $(p,p)$ 形式的特征。

### 任务

请设计一个程序：
- 读入一系列的特征；
- 计算包含这些特征的最短的遗传密码的长度；
- 将结果输出。

## 说明/提示

### 样例解释
$\{8,5,1,4,2,3,9,6,4,5,7,6,2,8,6\}$ 是一个符合题意的遗传密码。

### 数据范围
对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le l,r\le 1000$。

## 样例 #1

### 输入

```
12
2 3
3 9
9 6
8 5
5 7
7 6
4 5
5 1
1 4
4 2
2 8
8 6```

### 输出

```
15```

# 题解

## 作者：Imakf (赞：20)

题面转化：给定一张图，设添加**最少** $m$ 条边 **可以使得整张图存在欧拉路径。** 请输出 $m+n+1$。

欧拉路径是指经过图中**每一条边**的路径。

-----


如果两个图，它们之间没有任何公共边，我们就把它们分成两个子图。

于是我们把给定的图分成 $s$ 个子图，$G_1,G_2,...,G_s$，并且他们的交是原图。

定义 $f(G)$ 表示使图 $G$ 存在欧拉路径，至少需要添加的边数量。

则 

$$m=s-1+\sum\limits_{i=1}^{s}f(G)$$

$s$ 求解直接并查集完事

$f(G)$ 怎么求？

根据我们的要求，如果把有向边看成无向边，那么 $G$ 必然是**极大联通分量**。

设点 $i$ 的入度是 $in_i$ ，出度是 $out_i$。

那么 $\sum\limits_{u\in G} in_u= \sum\limits_{u\in G} out_u$ 是显然的结论。

当每个点的 $in_i=out_i$时，即 $\sum\limits_{u\in G} |in_u-out_u| = 0$ 时 $G$ 有欧拉回路（特殊的欧拉路径）。

当 $\sum\limits_{u\in G} |in_u-out_u| = 2$ 时，存在欧拉路径。

当 $\sum\limits_{u\in G} |in_u-out_u| = 4$ 时，我们只要选择两个点 $u,v(in_u>out_u,in_v<out_v)$

连接一条 $(u,v)$ 的有向边，就会必然导致 $\sum\limits_{u\in G} |in_u-out_u| = 2$

也就是每次总能找到两个点 $u,v$ 导致右侧 $-2$。

而一旦让右边 $\le 2$ 就存在了欧拉路径。

所以得到

$$f(G)=\max\{0,\dfrac{\sum\limits_{u\in G} |in_u-out_u|-2}{2}\}$$

**最后温馨提醒这题 n 数据范围是假的**

```cpp
#include <cstring>
#include <iostream>
#include <set>
using namespace std;

#define rg register
#define il inline
#define MX (1000 + 44)

int d[MX] ,fa[MX] ,size[MX] ,occ[MX] ,s[MX];
void init(){
	for(int i = 0 ; i < MX ; ++i)
		fa[i] = i ,size[i] = 1;
}
int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
void link(int u ,int v){
	u = find(u) ,v = find(v);
	if(u == v)	return;
	if(size[u] < size[v])	swap(u ,v);
	fa[v] = u ,size[u] += size[v];
}

struct edge{
	int u ,v;
	bool operator <(const edge& b)const{
		return u == b.u ? v < b.v : u < b.u;
	}
};

set<edge> e;

int main(){
	init();
	int n ,del = 0; cin >> n;
	for(int i = 1 ,u ,v ; i <= n ; ++i){
		cin >> u >> v;
		if(e.find((edge){u ,v}) != e.end()){
			++del;
			continue;
		}
		e.insert((edge){u ,v});
		d[u]++ ,d[v]--;
		occ[u] |= occ[v] |= 1;
		link(u ,v); 
	}
	for(int i = 1 ; i < MX ; ++i)
		if(occ[i])	s[find(i)] += abs(d[i]);
	int cnt = 0;
	for(int i = 1 ; i < MX ; ++i){
		if(occ[i] && find(i) == i){
			cnt += max(0 ,(s[i] - 2) / 2);
			cnt++;
		}
	}
	cout << n + 1 + cnt - 1 - del << endl;
	return 0;
}
```

---

## 作者：Kevinzzz (赞：15)

楼上的巨佬太巨辣，我啥也没看懂 ~~（其实是我太弱了）~~

写一篇像我这样的蒟蒻也能看懂的题解吧，第一次写题解，请多关照。

首先吧题意翻译成人话：给你一张图，求出这张图中所有的联通块，把每个联通块里有几个点数一遍，然后加起来，输出。

首先考虑特殊情况：只有一个联通块，也就是整张图联通。

若该图是一个欧拉回路，此时总点数等于总边数+1。（从任意一个点为起点开始绕一圈还要回到该点，起点多遍历一次）

否则在一个欧拉路径中，除了起点和终点，所有点的入度都应该等于出度。如果一个点为起点，它的出度+1而入度不变；如果一个点为终点，它的入度+1而出度不变，其他情况下入度和出度都+1。

所以想要知道一个点在欧拉路径上出现的次数，我们可以取它入度和出度的最大值。

对于有多个联通块的情况，只需要对每个联通块求和即可。（每个联通块内的点数对其他联通块没有影响）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
int is[10000005];//判断该点是否出现在图中
int head[10000005];
struct node {
    int to, next;
}e[10000005];
int cnt;
void add(int u, int v) {
    e[++cnt] = node{v, head[u]};
    head[u] = cnt;
}
int in[10000005], out[10000005];
int vis[10000005];
int c[10000005];//判断是否为欧拉回路
void dfs(int x, int root) {
    vis[x] = 1;
    if (in[x] != out[x]) c[root] = 0;//如果该点入度不等于出度，说明该联通块不是欧拉回路
    for (int i = head[x]; i; i = e[i].next) {
        if (!vis[e[i].to]) {
            dfs(e[i].to, root);
        }
    }
}
int main() {
    scanf("%d", &m);
    int u, v;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
        is[u] = 1;
        is[v] = 1;
        in[v]++;//入度++
        out[u]++;//出度++
        n = max(n, max(u, v));//n为该图中最大的点
    }
    for (int i = 1; i <= n; i++) {
        if (is[i] && !vis[i]) {
            c[i] = 1;
            dfs(i, i);
        }
    }//搜索判断该联通块是否为欧拉回路
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (is[i]) ans += max(in[i], out[i]);
    }//该点入度和出度的最大值，即该点出现在图中的总次数
    for (int i = 1; i <= n; i++) {
        ans += c[i];
    }//如果是欧拉回路，答案+1
    printf("%d", ans);
    return 0;
}

```


---

## 作者：破忆 (赞：10)

## 【题意】

给定若干条边 $(l,r)$，要求添加若干条边，构成一条通过所有边的路径，求最小路径长度。

## 【分析】

记点 $i$ 的入度为 $in_i$，出度为 $out_i$。

图构成若干联通块，每个联通块，都要有分成几种情况讨论。

### 联通块本身有欧拉路径

在这个联通块上不用加边。

#### 存在欧拉回路

等价于对于任意点 $i$，都有 $in_i=out_i$。

#### 不存在欧拉回路

等价于存在两个点，$|in_i-out_i|=1$。

即 $\sum |in_i-out_i|=2$。

### 联通块本身无欧拉路径

记 $S=\sum |in_i-out_i|$。

每加一条边，$S$ 就能减二。

要让 $S$ 减至二，就要加 $\frac{S-2}{2}$ 条边。

综上，联通块内的总代价为 $\sum \max(0,\frac{\sum |in_i-out_i|-2}{2})$。

还要加上原来的边与连接不同联通块的边。

## 【算法】

欧拉路径

## 【代码】

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5,maxm=1e6+5;
int n,m;
int in[maxn],out[maxn];
int d[maxn];
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
int ans;
map<int,bool> hsh;
struct data{
	int x,y;
}a[maxm];
int fa[maxn];
int getfa(int x){
	return fa[x]==x?x:fa[x]=getfa(fa[x]);
}
void merge(int x,int y){
	int fx=getfa(x),fy=getfa(y);
	if(fx==fy) return;
	fa[fx]=fy;
	d[fy]+=d[fx];
}
int tot,del;
bool vis[maxn];
int main(){
	freopen("P5921.in","r",stdin);
	freopen("P5921.out","w",stdout);
	m=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		if(hsh[x*maxn+y]){del++;continue;}
		hsh[x*maxn+y]=1;
		a[++tot]=(data){x,y};
		in[x]++,out[y]++;
		n=max(n,max(x,y));
		vis[x]=vis[y]=1;
	}
	for(int i=1;i<=n;i++) fa[i]=i,d[i]=abs(in[i]-out[i]);
	for(int i=1;i<=tot;i++) merge(a[i].x,a[i].y);
	for(int i=1;i<=n;i++) if(vis[i]&&getfa(i)==i) ans+=1+max(0,d[i]-2>>1);
	printf("%d\n",m+ans-del);
	return 0;
}
```


---

## 作者：Tobiichi_Origami (赞：9)

**前置知识**：欧拉回路（路径），并查集

------------

### 题目大意

给定 $m$ 个数对 $(l,r)$，现在需要构造出一个序列，使 $a_{i}=l,a_{i+1}=r$，问这个序列最短为多少？

### 解题思路

我们考虑，如果要使序列最短，就要使每个数对在序列中尽可能有重复的数字，即首尾相连。

提到首尾相连，我们会轻易的想到一个构建一个有向图（因为 $(l,r)$ 和 $(r,l)$ 不是一个东西，所以是有向图）。

因为我们要使每个数对都出现在序列当中，所以抽象到图中即为若干个不连通的连通块，我们可以很轻松的联想到多个不连通的欧拉路径（回路），求用最少的欧拉路径画满整个图与所经过的边数相加。

我们先考虑所经过的边数为多少。显然，即为整个图中的边数。

然后再考虑要用多少笔画完，再欧拉回路和欧拉路径两方面分别考虑。

- 因为在欧拉路径当中，只有一个终点和一个源点，它们至今不出或只出不进，所以出度入度和为奇数。那么每条欧拉路径中有两个奇数点，$n$ 条欧拉路径中就有 $2n$ 个奇数点，整个图中，欧拉路径的个数就是奇数点的个数除以 $2$ 吗？

	显然不是。我们考虑，如果有多条欧拉路径的源点与终点相同，那么源点或终点就应该再算一次，就不应该是奇数点的个数，就应该是入度出度之差的和除以 $2$。

- 在欧拉回路当中，有出必有回，所以出度入度之和为偶数。

	那这时，我们就可以用到并查集来维护欧拉回路。
   
   我们把每条相连的边并到一个集合当中，即为一个欧拉回路（路径）。遍历这个图中所有的点，如果它是这个集合中的祖先，也就遍历到了一个新集合，且这个集合在之前计算欧拉路径时没有被记录过，那么就代表它所在的集合为一个欧拉回路。直接计入答案。
   
综上所述，答案即为边的数目加奇数点入度出度之差的和除以 $2$ 加不同集合的个数（不包含欧拉回路）。

注：题目中可能会有重边，需要用 $\text{map}$ 去一下重。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100001];
int din[100001],dout[100001];
bool vis[100001],is[100001];
map<pair<int,int>,int>mp;
int n,m,sum,ans,rep;
int find(int x)
{
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
void merge(int x,int y)
{
	int p=find(x),q=find(y);
	if(p!=q) f[q]=p;
}
int main()
{
    for(int i=1;i<=1000;i++) f[i]=i;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		if(!mp.count({x,y}))
		{
			n=max(n,max(x,y));
			merge(x,y);
            is[x]=is[y]=1;
			din[y]++;dout[x]++;
		}
        else rep++;
	}
	for(int i=1;i<=n;i++)
		if((din[i]-dout[i])!=0) 
            vis[find(i)]=1,sum+=abs(din[i]-dout[i]);
	for(int i=1;i<=n;i++)
		if(!vis[i]&&f[i]==i&&is[i]) 
            ans++;
	printf("%d",m+(sum>>1)+ans-rep);
	return 0;
}
```


---

## 作者：xfrvq (赞：7)

[P5921 原始生物](/problem/P5921)

[更好的阅读体验](/blog/368107/solution-p5921)

---

### 题意

给定 $n$ 个可以互达的点与 $m$ 条**单向边**，求出最短的至少包含这 $m$ 条边的路径的长度。

$\texttt{Ps:}$ 由于题目中的 $n$ 代表的是边数而点数并未给出点数，于是没有采用题目中的变量名。

---

### 解法

#### $\text{solution 1}$

不难看出答案里包括 $m$ 以及联通块的总个数。

联通块总个数，可以用并查集求出。

---

#### $\text{solution 2}$

~~省选/NOI- 的难度，显然不会这就过了~~

上述思路错误也显然：**题目是单向边，而并查集是默认双向边。有的时候一条单向边被“反着走”了**。因此程序运行结果会比正确答案少

那么这种情况如何应对呢？

定义 $in_i$ 为 $i$ 点入度，$out_i$ 为 $i$ 点出度

如果 $in_i = out_i$ 经过这个点不会产生上述情况

反之，$in_i \neq out_i$ 则会出现“反着走”的情况

这个时候，我们的答案就需要加上 $in_i$ 与 $out_i$ 之差（会多使用一次这个点）。

---

### 实现

+ $n$ 没有告诉我们，所以就应该是 $\max_{i=1}^{i\leqslant m}l_i,r_i$ ，在读入时更新
+ 用 $de$ 数组表示 $in_i - out_i$，在计算 $\sum de_i$ 时要取 $\operatorname{abs}$  ，算出来后还要记得除 $2$

### [$\color{#52C41A}\texttt{AC CODE}$](https://www.luogu.com.cn/record/47544205)

```cpp
#include<stdio.h>
#include<math.h>
int fa[1005],de[1005];
int Find(int x) {return x == fa[x] ? x : fa[x] = Find(fa[x]);}
void Union(int x,int y) {fa[Find(y)] = Find(x);} // 每 日 压 行 心 情 好
int appear[1005],in[1005],ou[1005],num = 0,app2[1005];
int main() {
	int n = 0,m,cnt = 0;
	scanf("%d",&m);
	for(int i = 1; i <= 1002; ++i) fa[i] = i,de[i] = appear[i] = app2[i] = in[i] = ou[i] = 0; // 初始化
	cnt = 0;
	for(int i = 1; i <= m; ++i) {
		int a,b;
		scanf("%d%d",&a,&b);
		++de[a],--de[b]; // degree 数组的更新
		app2[a] = app2[b] = true; // 此节点是否出现过
		Union(a,b);
		n = a > n ? a : n,n = b > n ? b : n; // 更新 n
	}
	for(int i = 1; i <= n; ++i) {
	    if(de[i] == 0) continue;
		num += abs(de[i]); // 注意 abs
		appear[Find(i)] = true; // 是不是祖先节点
	}
	num >>= 1;
	for(int i = 1; i <= n; ++i){
		if(fa[i] != i) continue; // 不是祖先就跳过
		if(!appear[i] && app2[i]) ++cnt;
	}
	printf("%d\n",cnt + num + m); // m -> 边数，cnt -> 联通块数，num -> 特殊情况总数
	return 0;
}
```

---

## 作者：Xu_brezza (赞：6)

sto @_Cx330 @louis_11 orz！！

感谢同机房巨佬 lrz 和 \_Cx330 救了我这个菜狗 orz！！

## 题意

构建最短数列，使得题目中每一对 $(l,r)$ 都以相邻形式出现在数列中，求最短长度。

## Solution

首先一眼可以看出这是个图论的问题。

我们可以采用连一条 $l\to r$ 的边表示题目中的限制。

那么我们要做的，就是花费最少的代价，走遍所有的边。

"所有边"，这个东西看起来就很难不联想到一笔画！也就是欧拉路径之类的，仔细想想这是正确的。

但出了点小问题：

- 首先这个图不一定联通。
- 其次对于一个连通块他不一定有欧拉路径/回路。

所以我们分类讨论一下。
 
- 对于一个连通块，存在欧拉回路。
	
   - 考虑一条有向边，既然欧拉回路是走遍所有边，那么我们不妨把一个点的贡献算作边起点的的贡献，这样子我们只关心最后的终点，而正所谓**回路**，起点终点相同，所以贡献加一即可。

- 对于一个连通块，存在若干欧拉路径。
	- 这里的若干指的是，不存在可以一次走完的路径，但我可以分多次走完。
    
   - 同样的有向边套路，一个点视作一条边的入度，那么我们只关心这若干条欧拉路径的终点个数。
   
   - 这个显然是所有 $out[u] - in[u]$ 并且有 $out[u] > in[u]$，其实你要是想 $in[u] - out[u]$ 也一样，因为这些点是所有的起点和终点，最后的和肯定相同，是对称的。
 
最后加上总边数。
   
于是您爆切！！！

``` cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(int i=(a);i<(b);++i)
#define rrep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=0;
	while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(f)x=-x;
}
template <typename T,typename ...Args>
inline void read(T &tmp,Args &...tmps){read(tmp);read(tmps...);}
const int N = 100005;
int n,fa[N],m,du[N];
vector<int>g[N];
inline int findfa(int x){return fa[x] == x ? x : fa[x] = findfa(fa[x]);}
signed main(){
	read(n);
	rep(i,1,1000)fa[i] = i;
	rep(i,1,n){
		int u,v;
		read(u,v);
		++du[u];
		--du[v];
		fa[findfa(u)] = findfa(v);
	}
	int ans = n;
	rep(i,1,1000)g[findfa(i)].push_back(i);
	rep(i,1,1000){
		for(int j : g[i])
			if(du[j] > 0)ans += du[j];
	}
	rep(i,1,1000){ 
		if(g[i].size() <= 1u)continue;
		int flag = 1;
		for(int j : g[i])
			flag &= !du[j];
		ans += flag;
	}
	printf("%d",ans);
}
```

---

## 作者：wocaicai (赞：5)

## P5921 

//本题解主要在于讲解为什么这题和欧拉路径有关(因为好像没有题解讲到）

好题！

首先考虑暴力的贪心，每读进来一个有暴力连边，由于$l$和$r$很小，所以你可以记录一下，直接做就可以了，但是这样细节很多； 

比如说样例，每读进来一个$l$，我就看一下是否存在一个可以插别的点的编号为$l$的点，不存在就建一个新的，然后对于$r$，找一个可以被插的编号为$r$的点，不存在也建一个。

需要注意的是，当我建了一个插/被插的点时，这个编号的被插/插的点的数量也会增加

多模拟几遍之后，你会发现我们每次需要新建节点的时候，正好是原图中欧拉路径不再存在的时候，而我当我新建一个点，其实是想办法让这个图再次出现一条欧拉路径，即相当于在原图中加了一条边。

所以，此时问题转化为了求出要加多少条边，才能出现一条欧拉路径。

剩下的就可以看$Imakf$巨佬的讲解了qwq

---

## 作者：ckain (赞：4)

前置：有向图欧拉路径，欧拉回路。  
[博客](https://www.luogu.com.cn/blog/edisnimorF/solution-p5921)  
将 $(l,r)$ 视作有向边，则每次选择一个节点开始一直沿着有向边转移，直到不能转移为止，覆盖所有的边所需最少的走的次数加上 $n$ 就是答案。因为如果顺着之前走，只需要添加一个数，而重新开始走需要添加两个数。  
故问题变成一张有向图，需要添加多少条边可以变成存在欧拉路径的图。有向图的基图可能组成若干个连通块，我们只需要知道使每一个连通块存在欧拉路径的最小加边数，再加边把连通块串起来（形成一个大欧拉路径）就可以了。对于单一连通块，我们计算每个点的出度和入度，选出出度比入度大的所有点，计算它们出度和入度的差的总和，记为 $S$。若 $S=0$，则其本来存在欧拉回路，不需要加边；否则为了保证仅有一个点的出度比入度大一和一个点的入度比出度大一，最小加边数为 $S-1$。  
code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-')f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-48; c=getchar();}
	return f? s:-s;
}
const int N=1005;
int n, in[N], out[N];
int fa[N];
int findf(int u){return fa[u]==u? u:fa[u]=findf(fa[u]);}
int ans, cnt[N];
signed main(){
	n=rd();
	for(int i=1; i<=1000; i++) fa[i]=i;
	for(int i=1, u, v; i<=n; i++){
		u=rd(), v=rd();
		out[u]++, in[v]++;
		fa[findf(u)]=findf(v);
	}
	for(int i=1; i<=1000; i++){
		if(in[i]<out[i]) cnt[findf(i)]+=out[i]-in[i];
	}
	for(int i=1; i<=1000; i++){
		if((in[i]|out[i]) && findf(i)==i){
			if(cnt[i]>0) ans+=cnt[i];
			else ans+=1;
		}
	}
	printf("%d\n", ans+n);
	return 0;
}
```

---

## 作者：infinite2021 (赞：2)

# [POI1999] 原始生物 题解

题目连接：[P5921](https://www.luogu.com.cn/problem/P5921)

## 题意分析

其实这道题乍一看不像是一道图论的题目，而是构造。

但细分析可以发现，我们可以把该题抽象成一道图论的问题。

该问题等价于：在一个图中，找到所有的连通块，并统计它们对答案的贡献。


### 连通块贡献的求法

首先我们考虑一般化的情况：

+ 当前的联通块不是一个欧拉回路

那在这个连通块内，每一个点的贡献即为它的入度与出度的最大值。

这里我们可以感性理解一下：

在一个连通块内如果要使答案最优，那必然不能重复走其中的某一条边，如果走了的话答案将会多 $2$。

所以最优解一定是走一条欧拉路径。

而欧拉路径一定会遍历到所有的边，则**每一个点的贡献即为它的入度与出度的最大值。**

+ 当前的连通块是一个欧拉回路

由于欧拉回路的起点和终点是重复的点，所以答案应该加 $1$。

## 代码实现

更多详细的讲解放在代码里了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1000010,M=N*2;
int n,res=0;
int h[N],e[M],ne[M],idx;//邻接表
bool in_gra[N];//字面意思，判断点是否在图中
int dfn[N];//判断是否在dfs的过程中遍历过(tarjan写多了，请见谅)
bool is_oula[N];//当前的点是否在欧拉回路中
int din[M],dout[M];//统计一个点的入度和出度
void add(int a,int b)//从a向b加一条边
{
    e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
void dfs(int u,int root)//找欧拉回路的过程
{
    dfn[u]=1;
    if(din[u]!=dout[u])is_oula[root]=0;
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])
            dfs(j,root);
    }
    return;
}
int main()
{
    int k=0;//图中点的最大编号
    cin>>n;
    memset(h,-1,sizeof h);//初始化
    for(int i=1;i<=n;i++)//读入与预处理
    {
        int a,b;
        cin>>a>>b;
        add(a,b);add(b,a);
        in_gra[a]=in_gra[b]=true;
        din[b]++;dout[a]++;
        k=max({k,a,b});
    }
    for(int i=1;i<=k;i++)
        if(in_gra[i]&&!dfn[i])
        {//只遍历在图中且没被遍历过的点
            is_oula[i]=1;
            dfs(i,i);
        }
    for(int i=1;i<=k;i++)//统计答案
    {
        if(in_gra[i])res+=max(din[i],dout[i]);
        if(is_oula[i])res++;
    }
    cout<<res<<endl;
    return 0;
}
```

---

## 作者：Paper_Tiger (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5921)

### 题意：

本题是一个找连通块+数数，外加欧拉图的知识，最后要找到一个序列里面含有所有的原始生物的特征，再输出序列长度。

### 思路：

用样例来说：

样例：
| 12 | \ |
| :----------: | :----------: |
| 2 | 3 |
| 3 | 9 |
| 9 | 6 |
| 8 | 5 |
| 5 | 7 |
| 7 | 6 |
| 4 | 5 |
| 5 | 1 |
| 1 | 4 |
| 4 | 2 |
| 2 | 8 |
| 8 | 6 |
根据样例先画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t2q6v4l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图，既然要有一个连续序列来包含所有的边，也就是从一个点开始，可以遍历到所有的有向边，于是我们就可以敏锐的察觉到：本题就是要用一个有向欧拉图来解决！！！

欧拉图所具备的条件就是出入度相等，所以我们只要加边使得总体出入度相同就可以了。

根据欧拉图的性质，我们可以轻易得出：加边后出入度差为零，也就是要加出入度差条边，而欧拉图所需要的是回到出发点，但本题不需要，所以只需要加出入度差减一条边即可。

但是要考虑重边和分配的问题。

何为重边？重边就是两条相等边重复计算，如果没有判断重边，本题就错了。所以我们在打代码时一定要注意这些小的细节。

何为分配？分配就是要出度和入度对应，一个出度对应一个入度，这就要求我们不能在线直接处理，而要离线用找连通块的方法寻找对应出入度。

所以代码需要变动。先假设要连接，连接出入度中较大的一个度条边，也就是假设连接上。然后利用 dfs 遍历连通块，如果有出入度不相等的点就记录，返回主程序时就不连接这个点，等待以后再从这个点出发遍历。

### 代码：

```cpp
#include<iostream>
#include<vector>
using namespace std;
int n,ind[1001],oud[1001],cnt=0;
vector<int> v[1001];
bool vis[1001],inq[1001],flag=false;
void dfs(int x){
    int y;
    vis[x]=true;
    if(ind[x]!=oud[x]) flag=true;
    for(int i=0;i<v[x].size();i++){
        y=v[x][i];
        if(!vis[y]) dfs(y);
    }
}
int main(){
    std::ios::sync_with_stdio(false); //作者最近贼喜欢用这个也不知道为什么(doge
    std::cin>>n;
    for(int i=1;i<=n;i++){
        int x,y;
        std::cin>>x>>y;
        v[x].push_back(y); //建图（注意是双向图）
        v[y].push_back(x); //同上
        inq[x]=true; //标记有出现过此特征
        inq[y]=true; //同上
        ind[x]++; //入度累加
        oud[y]++; //出度累加
    }
    for(int i=1;i<=n;i++){
        if(!inq[i]) continue; //如果没出现过此特征，直接下一个
        cnt+=max(ind[i],oud[i]); //加上max出入度
        if(!vis[i]){ //没遍历过
            cnt++;
            flag=false; //重置flag
            dfs(i); //遍历图求连通块
            if(flag) cnt--; //如果还是有点出入度有差值 cnt--
        }
    }
    std::cout<<cnt; //直接输出cnt就好啦！！！
}
```
啊哈是不是很简单啊( doge 。

---

## 作者：Milmon (赞：0)

[in Blog](//milk-lemon.blog.luogu.org/notes-EulerPath) & [Problem](//www.luogu.com.cn/problem/P5921)

## 题目大意

- 设 $K=(a_1,\ a_2,\ \cdots,\ a_n)$，满足 $n$ 个条件，对于第 $i$ 个条件 $(l_i,\ r_i)$，满足 $\exists\ 1\leq i<n$，$a_i=l_i,\ a_{i+1}=r_i$。给定这些条件，求满足条件的 $n​$ 的最小值。

- $1\leq n\leq 10^6,\ 1\leq l_i,\ r_i\leq 10^3$

## 解题思路

本题等价于：

> 有一张有 $m$ 条边的有向图，在图中补上若干条边使得存在一条欧拉路径可以覆盖图中每一条边仅一次。求补边后整张图边数的最小值。

题目要求存在整个图的欧拉路径，而图可能分为若干个连通块。

设一个连通块中，每个点入度减去出度的值之和为 $t$。

若 $t>0$，则为了让它符合欧拉回路的存在条件，至少再连 $t$ 条边。

若 $t=0$，为了使图连通，至少连 $1$ 条边。

故答案为
$$
m+\sum\max(1,\ t).
$$

## AC 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int n=1000,m,in[1001],out[1001];
int f[1001]; bool p[1001];
int a[1001];

int get(int id){
	if(f[id]!=id)f[id]=get(f[id]);
	return f[id];
}

int main(){
	scanf("%d",&m);
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		in[v]++,out[u]++;
		p[u]=p[v]=true;
		f[get(u)]=get(v); // 合并连通块
	}
	for(int i=1;i<=n;i++)
		if(in[i]>out[i])
			a[get(i)]+=in[i]-out[i];
	int answer=0;
	for(int i=1;i<=n;i++)
		if(p[i]&&get(i)==i)
			answer+=max(1,a[i]);
	printf("%d\n",answer+m);
	return 0;
} 
```

---

## 作者：honglan0301 (赞：0)

## 题目分析

感觉题解里上来就告诉你等价于某种欧拉路径问题有点抽象，我们不妨换个角度考虑这道题。

首先还是把每个限制抽象成一条有向边 $(a_i,a_i+1)$，那么整个序列就是一条路径，题意也就是可以随便加边，让你求一条最短的路径使得覆盖了所有给出的有向边。

然后注意到任两条路径都能通过在中间加一条边的方式合并起来。所以我们贪心地想，发现题意等价于求最小的路径条数使得能够走完图中所有边。这与一笔画（欧拉路径）问题类似，而事实上欧拉路径的结论确实可以拓展，即变成：一个 $\sum |in_i-out_i|=2k$ 的弱联通有向图可以用 $k$ 条有向路径覆盖所有边，并且至少用 $k$ 条路径才能覆盖所有边。证明如下。

1. 必要性：考虑从空图开始加路径的过程，每加入一条路径只会对两端点的 $|in_i-out_i|$ 产生至多 $1$ 的影响，故必要性得证。

2. 充分性：考虑归纳，我们在图上任选选一个 $in_i>out_i$ 的点 $i$ 和一个 $in_i<out_i$ 的点 $j$ 连边，新图上归纳假设存在 $k-1$ 条路径的覆盖方式，那么其中一条路径在这条边上断开后就形成了原图上 $k$ 条路径的覆盖方式。而 $k=1$ 时是欧拉路径问题，结论成立，故充分性得证。

故我们只需先把原图分成弱联通的子图，然后对于每个连通块分别求出答案，时间复杂度线性。

## 代码

数据实际上并没有重边，所以我没写判重。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,u,v,in[1005],out[1005],fa[1005],vis[1005],cs[1005],cntd,ans;
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}

signed main()
{
	cin>>n; for(int i=1;i<=1000;i++) fa[i]=i;
	for(int i=1;i<=n;i++)
	{
		cin>>u>>v;
		int xx=getfa(u),yy=getfa(v); fa[xx]=yy;
		in[v]++; out[u]++; vis[u]=vis[v]=1;
	}
	for(int i=1;i<=1000;i++) if(vis[i]) cs[getfa(i)]+=abs(in[i]-out[i]);
	for(int i=1;i<=1000;i++)
	{
		if(getfa(i)==i&&vis[i]) ans+=max(1,cs[i]/2);
	}
	cout<<ans+n<<endl;
}
```


---


# [JSOI2013] 侦探 JYY

## 题目描述

JSOI 的世界里一共有 $N$ 个不同的事件（依次由 $1$ 到 $N$ 编号），以及 $M$ 条线索。每一条线索对应一个二元组 $(x,y)$，表示事件 $x$ 发生会导致事件 $y$ 发生。

**注意： 线索是单向的，也就是如果 $y$ 发生了，并不代表 $x$ 一定会发生。**

线索是有传递性的， 即如果存在线索 $(x,y)$ 以及 $(y,z)$， 那么 $x$ 发生则会导致 $z$ 发生。

同时由于世界是合理的，任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生。

另外，整个世界仅包含这 $M$ 条线索， 我们不认为一些事件会凭空发生（就像福尔摩斯永远不会认为诡异的凶杀案是源于神的谴责）。具体而言，对于某个事件 $x$， 如果 $x$ 发生了，并且存在某个事件可能导致 $x$ 发生，那么一定至少有一个可能导致 $x$ 发生的事件发生了。

现在已知世界上的 $M$ 条线索，以及 $D$ 个已经发生的事件，那么由此推断，
哪些事件一定已经发生了呢？

## 说明/提示

### 样例解释

在第一个样例中，由于事件 $1$ 和事件 $2$ 这两个事件中的任何一个发生都会导致事件 $3$ 发生，所以我们并不能确定到底哪个事件发生了。

在第二个样例中，由于事件 $4$ 发生了，所以事件 $2$ 和事件 $3$ 中至少有一个发生了。而不论哪一个发生了，都可以推出事件 $1$ 发生了。

最终由于事件 $1$ 发生了，使得我们可以推断出，所有 $4$ 个事件都必然发生了。

### 数据范围

对于 $100\%$ 的数据，$1\leq D\leq N\leq 10^3,1\leq M\leq 10^5$。

## 样例 #1

### 输入

```
3 2 1
1 3
2 3
3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4 1
1 2
1 3
2 4
3 4
4```

### 输出

```
1 2 3 4```

# 题解

## 作者：bellmanford (赞：9)

$stO\quad JYY\quad Orz$

------------

首先，根据线索，将每个边反向再建一个图，用于逆推 

对于每个点，必然发生的情况只有三种：

- 1、题目给出此事件已发生

- 2、可以通过已知必然发生的事件直观的推出（也就是根据“线索是有传递性的”这一性质推出） 

- 3、对于每一个必然发生事件，如果关于这个点的每一条路径都必须经过目前节点，那该事件必然发生

第一种情况，直接记录下题目给出的条件，直接判断即可 

第二种情况，找出所有可以推出该事件的点，看是否存在必然事件 

只需在逆推图上bfs一遍，如果遍历到的事件是必然发生的，那JYY就可以通过那个事件推出这个事件的必然发生

第三种情况，将除了能推出自己的出度为0的点所能推出的所有节点打上标记，假如存在必然事件未被打上标记，则该事件所有路径必然经过目前节点 

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;

#define JYY return
#define AK 0
#define IOI ;
const int M=1e5+5,N=1e3+5;

int n,m,D,tot=0,a[M],in[M],first[M];
bool vis[M],truth[M];
struct Edge{
	int to,nxt,pd;
}e[M<<1];
queue<int> Q;

int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*y;
}

void add(int x,int y,int fx){
	e[++tot].nxt=first[x];
	first[x]=tot;
	e[tot].to=y;
	e[tot].pd=fx;
}

bool check(int x){
	for(int i=1;i<=n;i++) vis[i]=0;vis[x]=1;
	while(!Q.empty()) Q.pop();Q.push(x);
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(!e[i].pd) continue;
			if(truth[v]) return 1;
			if(!vis[v]) Q.push(v),vis[v]=1;
		}
	}
	for(int i=1;i<=n;i++) if(!in[i]&&!vis[i]) Q.push(i),vis[i]=1;
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i].pd) continue;
			if(!vis[v]) Q.push(v),vis[v]=1;
		}
	}
	for(int i=1;i<=D;i++) if(!vis[a[i]]) return 1;
	return 0;
}

int main(){
	n=read(),m=read(),D=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y,0),add(y,x,1);in[y]++;
	}
	for(int i=1;i<=D;i++) a[i]=read(),truth[a[i]]=1;
	for(int i=1;i<=n;i++) if(truth[i]||check(i)) printf("%d ",i),truth[a[++D]=i]=1;
	printf("\n");
	JYY AK IOI
}
```


---

## 作者：卷王 (赞：2)

突然翻到了这道题，感觉挺不错，就写一篇题解总结一下。

## 题目大意

共有 $n$ 个事件，已知 $D$ 个事件成立，请你通过给出的 $m$ 条 **事件 $x$ 成立，则另一个事件 $y$ 也成立** 的这类关系尽可能的推断出成立的事件并输出。

## 大体思路

$n$ 个事件可以看作 $n$ 个点，而 **事件 $x$ 成立，则另一个事件 $y$ 也成立** 这种关系其实就是一条 $x\rightarrow y$ 的有向边。然后我们可以 bfs。

但是正推似乎很难实现，那么正难则反，考虑建反向边，然后在这个图上 bfs。这就是 **逆向思维**。

所以大体只有三步：

* 读入，建图，标记已知的必然事件

* 直接运用明显关系（即形如 **一个必然事件指向一个未知事件** 的关系）推出一些必然事件。

* 在图上 bfs，推出那些并不明显的必然事件。具体可以参照其他人的代码和分析。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef long long ll;
typedef pair<int, int> pr;
#define up(i, l, r) for(int i = (l); i <= (r); i++)
#define down(i, r, l) for(int i = (r); i >= (l); i--)
const int mod = 1000000007;
const int base = 2333;
const double eps = 1e-6;

inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}

int d, n, m, k, Q, T, _, ans = 0;
int a[1007], in[1007];
bool flag = 0;
vector<int> G[1007];
vector<int> E[1007];
bool vis[1007], tmp[1007];

inline bool check(int x) {
	memset(tmp, 0, sizeof(tmp));
	queue<int> q;
	q.push(x);
	tmp[x] = 1;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto v : E[u]) {
			if (vis[v]) return 1; //注意这里
			if (!tmp[v]) q.push(v), tmp[v] = 1;
		}
	}
	//队列现在是空的
	for (int i = 1; i <= d; i++)
		if (!in[i] && !tmp[i])
			tmp[i] = 1, q.push(i);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto v : G[u]) if (!tmp[v]) q.push(v), tmp[v] = 1;
	}
	for (int i = 1; i <= n; i++)
		if (!tmp[a[i]]) return 1;
	return 0;
}

signed main() {
	d = read(), m = read(), n = read();
	for (int i = 1; i <= m; i++) {
		int u = read(), v = read();
		G[u].push_back(v);
		E[v].push_back(u);
		in[v]++; //入度即反向图的出度
	}
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		vis[a[i]] = 1;
	}
	for (int i = 1; i <= d; i++) {
		if (vis[i] || check(i)) {
			cout << i << " ";
			a[++n] = i;
			vis[i] = 1;
		}
	}
}
```

---

## 作者：inc1ude_c (赞：2)

本篇题解将会对 [bellmanford](https://www.luogu.com.cn/user/116015) 的题解进行更通俗的讲解。

先建图，$x$ 能推出 $y$，就代表一条 $x$ 到 $y$ 的有向边。任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生，表示图中不存在环。

事件 $u$ 发生，可以是以下三种原因之一：

1. 输入直接告诉我们 $u$ 是必然事件

2. 因为其他必然事件，我们可以推出事件 $u$ 是必然的

3. 可以肯定 $u$ 让某些必然事件被推出。换句话说，如果删去事件 $u$，那么有些必然事件就无必然性

第二种情况，就是问有没有必然事件可以走到事件 $u$。直接反向建图，看看事件 $u$ 能不能走到任何一个必然事件即可。

第三种情况较为复杂。

先看用户 bellmanford 的代码中，第一次广搜后的 $vis$ 数组是什么，可以发现，$vis_i$ 表示事件 $i$ 能不能推出事件 $u$。

然后看一下**入度为 $0$** 的事件（也就是反向建图后出度为 $0$ 的事件），假设 $v$ 入度为 $0$，如果 $vis_v=0$（也就是 $v$ 推不出 $u$），并且事件 $v$ 可以推出必然事件 $w$，那么就说明 $w$ 的必然性不需要 $u$ 来做支撑。

所以，如果 $u$ 对于所有必然事件都不需要，那么就不满足条件三，反之则说明 $u$ 是必然发生的。

---

## 作者：Left_i_Forever (赞：1)

$\Large{\text{Solution}}$

模拟赛时看第二个样例（和本题一样）想到的，比较神秘……

从一个点往回走走到头，可能会有很多个结束的点。反过来，这些点都是拓扑的起点（入度为 $0$），并且都能走到这个点。例如第二个样例中的点都会走到 $1$ 这个点。

令第 $i$ 个点往回走到的终点的集合为 $s_i$，那么 $s_i$ 中必然有至少一个点是发生了的。由于没有其他条件，所以我们无法确定具体是谁发生了，但是可以推理。

对于每一个发生了的 $i$，枚举所有 $j$，若 $s_i$ 是 $s_j$ 的子集，那么 $j$ 一定发生了。注意到只有 $10^3$ 个点，所以 $\Omicron(n^2)$ 是可以接受的。

预处理 $s$ 可以在拓扑排序的时候使用 `bitset` 优化 DP。

$\Large{\text{Code}}$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
bitset <N> b[N];
vector <int> v[N], v2[N];
int in[N];
int n, m, d;
bool ans[N];

void topsort()
{
	queue <int> q;
	for (int i = 1; i <= n; i++)
		if (!in[i]) b[i][i] = true, q.push (i);
	while (q.size ())
	{
		int u = q.front ();
		q.pop ();
		for (int j : v[u])
		{
			in[j]--;
			if (!in[j]) q.push (j);
			b[j] |= b[u];
		}
	}
}

int main()
{
//	freopen ("detect.in", "r", stdin);
//	freopen ("detect.out", "w", stdout);
	cin >> n >> m >> d;
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		v[x].push_back (y);
		v2[y].push_back (x);
		in[y]++;
	}
	topsort ();
	for (int i = 1; i <= d; i++)
	{
		int x;
		cin >> x;
		for (int j = 1; j <= n; j++)
		{
			bitset <N> tep = b[x] & b[j];
			if (tep == b[x]) ans[j] = true;
		}
	}
	for (int i = 1; i <= n; i++)
		if (ans[i]) cout << i << " ";
	puts ("");
	return 0;
}
```

---

## 作者：high_sky (赞：1)

## 题目大意
给你一个有向无环图，一条有向边 $(x,y)$ 代表如果 $x$ 发生了那么 $y$ 一定发生，求当 $d$ 个点 $x_1,x_2,\dots,x_d$ 发生时，有多少个点一定发生。

## 思路
看到这道题目就感觉跟子树有关，不难发现如果建了一个反图，那么如果 $x$ 发生，在反图上 $x$ 子树的点也一定发生，记录答案可以考虑用 `bitset` 维护，此时我们可以设 $ans_i$ 表示 $i$ 发生时，有哪些点一定发生。

我们再考虑一下 $x$ 的祖先有没有可能一定发生。

先从简单的考虑，就是如果 $x$ 在反图上只有一个父亲，那肯定直接继承 $ans_{fa}$。

我们再考虑一下有多个父亲的情况，样例也给出了。

我们假设已经处理了他所有父亲的 $ans$ 值，那么我们可以发现他们 $ans$ 中都有的点要么就是当前点 $x$ 在反图上的子树的点，要么就是他们共同的祖先，也就说，我们可以通过他们的 $ans$ 取交集得到这些祖先一定发生了，最后再用 $ans_x$ 与这些一定发生的祖先的 $ans$ 值取并集即可。

那么我们预处理的时间复杂度是 $\mathcal{O}(n^2)$ 的，其中还有一个小于 $1$ 的常数，我们在输入那 $d$ 个点的时候直接将他们的 $ans$ 取并集即可，最后按照输出格式就行了。

代码中找祖先的那一段考虑从原图中拓扑排序一下，这样写起来较为简单。

## 代码
其中有两个自己的样例在代码下面，没有给出那 $d$ 个已经发生的点，需要自己补充调试，仅供参考。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stdlib.h>
#include <cstring>
#include <vector>
#include <queue>
#include <bitset>
#define int long long
#define N 1005
using namespace std;
int n,m,d,du[N];
vector<int> g[N],g2[N];
queue<int> q;
bitset<N> ans[N];
signed main(){
	// freopen("detect.in","r",stdin),freopen("detect.out","w",stdout);
	cin >> n >> m >> d;
	for (int i = 1;i <= m;i ++) {
		int u,v;
		scanf("%lld%lld",&u,&v);
		g[v].push_back(u);
		g2[u].push_back(v);
		du[u] ++;
	}
	for (int i = 1;i <= n;i ++)
		if (du[i] == 0) q.push(i);
	while(!q.empty()) {
		int t = q.front();
		q.pop();
		ans[t][t] = 1;
		for (auto i : g[t]) {
			ans[i] |= ans[t];
			if ((--du[i]) == 0) q.push(i);
		}
	}
	for (int i = 1;i <= n;i ++) du[i] = g[i].size();
	for (int i = 1;i <= n;i ++) if (du[i] == 0) q.push(i); 
	while(!q.empty()) {
		int i = q.front();
		q.pop();
		for (auto j : g2[i])
			if ((--du[j]) == 0) q.push(j);
		if (g[i].empty()) continue; 
		bitset<N> t2;
		for (int j = 1;j <= n;j ++) t2[j] = 1;
		for (auto j : g[i]) t2 = t2 & ans[j];
		for (int j = 1;j <= n;j ++)
			if (t2[j]) ans[i] |= ans[j]; 
	}
	bitset<N> t;
	for (int i = 1;i <= d;i ++){
		int x;
		scanf("%lld",&x);
		t |= ans[x];
	}
	for (int i = 1;i <= n;i ++) if (t[i]) printf("%lld ",i);
	return 0;
}
/*
13 17 1
1 2
1 3
2 4
2 5
5 6
6 7
6 8
6 9
7 10
8 10
8 11
9 11 11 12
10 12
3 5
4 6
13 4

5 4 1
1 2
2 3
3 4
5 3
*/
```

---

## 作者：Poetic_Rain (赞：1)

来自一位神仙学长的思路，题意就不说了

首先当前点被确定，那么他的所有儿子节点可以被确定

考虑父亲节点。当存在两个以及两个以上的入度为$0$的点可以到达当前节点时，该点的父亲节点是不可以确定的，但是也许会推出其他有用的信息

![](https://cdn.luogu.com.cn/upload/image_hosting/te2ivfcl.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

当数据是上面这样的时候，$3$是被确定的，$1$和$2$可能被确定，但是$4$却能被确定，答案为$3$，$4$。这应该是一组有用的数据，可以帮助更深的理解

那么我们如何除了这些情况呢？

我们可以预处理出所有节点的父亲节点（包括自己和祖先），并计算出最初的可以被确定的点的数量$sum$（即题目中的$b$)

假设当前处理的点为$x$（$x$没被确定），我们把所有的点分为两类

1. $x$的父亲节点和部分子节点

2. 除$x$的父亲节点外中入读为$0$的点以及这些点的子节点

可能说得不太清楚，画图来理解

![](https://cdn.luogu.com.cn/upload/image_hosting/5jt2r73z.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

红色的即为第二类点，蓝色为第一类点，方框内的表示与$x$完全没有关系的点

那么我们可以求出红色类点中，已经被确定的点的个数$tot$:

1. 当$tot=sum$，说明蓝色类点中，没有可以被确定的点

2. 当$tot<sum$，说明蓝色类点中有其它已经被确定的点

**因为$x$是没有被确定的点（见上），那么与蓝色类点中其他被确定的点一定能推出来$x$**，这个结论也不是特别显然，建议自己手模一下

由以上结论，我们可以知道$x$已经可以被确定了，此时$sum++$

对于每个点进行上述处理之后，我们再对每一个被确定的点进行一次搜索，他的子节点一定是可以被确定的

最后输出，结束

可能不太清楚的可以看代码注释，结合上面分析

```
#include<bits/stdc++.h>
using namespace std;
int head[200010],tot;
struct node{
	int net,to;
}e[200010];
int in[20010];
void add(int x,int y){
	e[++tot].net=head[x];
	e[tot].to=y;
	head[x]=tot;
}
int n,m,d;
bool v[20010],vis[20010];
set<int>fa[20010];
void bfs(int x){
	memset(vis,false,sizeof vis);
	queue<int>q;
	q.push(x);
	vis[x]=true;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		fa[u].insert(x);
		for(int i=head[u];i;i=e[i].net){
			int y=e[i].to;
			if(vis[y]) continue;
			q.push(y);
			vis[y]=true; 
		}
	}
}
int sum;
int fin(int x){
	memset(vis,false,sizeof vis);
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(fa[x].find(i)==fa[x].end()&&!in[i]) q.push(i),vis[i]=true;
		//表示红色类的点 
	}
	int tal=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		tal+=v[u]; //统计个数 
		for(int i=head[u];i;i=e[i].net){
			int y=e[i].to;
			if(vis[y]) continue;
			q.push(y);
			vis[y]=true;
		}
	}
	return tal;
}
void bfs2(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(v[i]){
			q.push(i);
		}
	}
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].net){
			int y=e[i].to;
			if(v[y]) continue;
			v[y]=true;
			q.push(y);
		}
	} 
}
int main(){
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		in[y]++; //入度 
	}
	for(int i=1;i<=d;i++){
		int x;
		scanf("%d",&x);
		v[x]=true; //可以被确定 
		sum++; //已经确定的个数 
	}
	for(int i=1;i<=n;i++) bfs(i); //处理出每个点的父节点 
	for(int i=1;i<=n;i++){
		if(v[i]) continue;
		if(fin(i)<sum){ //蓝色类点中有被确定的点 
			v[i]=true;
			sum++; //当前点可以被确定 
		}
	}
	bfs2(); //把子节点标记一下 
	for(int i=1;i<=n;i++){
		if(v[i]) cout<<i<<" ";
	}
	return 0;
}
```


---

## 作者：Hog_Dawa_IOI (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/P5191)。  
注意：本题解思路和别的题解思路略有不同。    

数据范围有亿点小，完全可以在 $O(n^2)$ 内解决。   
以下文字中一个点被标记，当且仅当它代表的事件发生了。
我们暴力枚举每一个点，判断如果这个点没被标记，会不会导致某些输入中确定会被标记的点无法被标记。   
为了完成这句话，我们需要：

- 人为钦定某个点被标记。
- 为了让这个点不被标记，能到达这个点的点都不能被标记。因此需要反向建图，反过来把这个点的祖先们（反图上这个点的孩子们）都标记为不被标记。
- 同时对于其它没受影响的点，如果它入度为 $0$，那么应该把这个点标记。
- 再把这个图遍历一遍，按照题意模拟。如果一个点的父亲们中有至少一个被标记了，那么这个点也应当被标记。
- 最后检查是否有点应当被标记，但是在这种情况下没有被标记。如果有，那么只有当前被钦定不被标记的点被标记，才能让那个应被标记的点被标记。（因为其它不受当前点影响的点，能被标记的都被标记了，还是救不了它。）

这一套流程下来时间复杂度是 $O(n)$ 的，外层枚举那个被钦定的点也是 $O(n)$ 的，因此总的时间复杂度是 $O(n^2)$ 的。这样我们就能把那些必须被标记的点都找到。   
最后还要再 DFS 一遍，把那些必须被标记的点的后代们都打上标记。

马蜂有点丑。并且这里 DFS、BFS 混杂，可读性好像有点低……？
```cpp
#include<stdio.h>
int n,m,d,fir[1005],num,a,b;
int du[1005],numm,firr[1005];
struct ss{int ed,nxt;}
bia[100005],tuned[100005];
int coled[1005];
bool f[1005],cled[1005];
int que[1005],l,r,cntt[1005];
void clear(int wh)
{
	f[wh]=0,cled[wh]=1;
	for(int i=firr[wh];i;i=tuned[i].nxt)
	if(!cled[tuned[i].ed]) clear(tuned[i].ed);
}
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++) scanf("%d%d",&a,&b),du[b]++,
	bia[++num].ed=b,bia[num].nxt=fir[a],fir[a]=num,
	tuned[++numm].ed=a,tuned[numm].nxt=firr[b],firr[b]=numm;
	for(int i=1;i<=d;i++) scanf("%d",&a),coled[a]=2;
//你别问为什么这里要赋值为 2，这没什么关系的。
	for(int i=1;i<=n;i++) if(!coled[i])
	//如果输入本来就被染色那我也说不了什么了。 
	{
		for(int j=1;j<=n;j++) f[j]=(!du[j]),
		cntt[j]=du[j],cled[j]=0;l=r=0,clear(i);
		for(int j=1;j<=n;j++) if(!du[j]) que[++r]=j;
		while(l<r)
		{
			l++;for(int kk=fir[que[l]];kk;kk=bia[kk].nxt)
			{
				f[bia[kk].ed]|=f[que[l]],cntt[bia[kk].ed]--;
				if(!cntt[bia[kk].ed]) que[++r]=bia[kk].ed;
			}
		}
		for(int j=1;j<=n;j++) if(!f[j]
		&&coled[j]) {coled[i]=1;break;}
	}
	l=r=0;for(int j=1;j<=n;j++)
	{
		if(!du[j]) que[++r]=j;
		cntt[j]=du[j];
	}
	while(l<r)
	{
		l++;for(int kk=fir[que[l]];kk;kk=bia[kk].nxt)
		{
			coled[bia[kk].ed]|=coled[que[l]],cntt[bia[kk].ed]--;
			if(!cntt[bia[kk].ed]) que[++r]=bia[kk].ed;
		}
	}
	for(int i=1;i<=n;i++) if(!!coled[i]) printf("%d ",i);
}
```

---


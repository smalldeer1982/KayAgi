# 机器人

## 题目背景

小 W 购买了一个机器人。

## 题目描述

现在，小 W 希望机器人去帮他完成 $n$ 个任务。

每个任务有两种属性：完成需要花的钱 $w_i$，成功率 $p_i$。

小 W 需要将任务按一定顺序排序，随后，机器人会按如下方式做任务：

- 从第一个任务开始做；
- 花费代价做完第 $i$ 个任务后，如果成功，则继续做第 $i+1$ 个任务，否则重新从第一个任务开始做；
- 成功做完第 $n$ 个任务后，流程结束。

例如，当 $n=2$ 时，一个可能的流程为：
- 做任务 $1$，失败；
- 做任务 $1$，成功；
- 做任务 $2$，失败；
- 做任务 $1$，成功；
- 做任务 $2$，成功；
- 流程结束，总花费为 $3w_1+2w_2$。

现在，小 W 希望学 OI 的你帮他找到一种排列顺序，使得他的期望花费最小。

## 说明/提示

样例一解释：可以感性理解。既然任务 $2$ 一定成功，那放到最后做肯定不劣。

样例二解释：显然这个任务不可能完成，它的成功率为 $0$。

**注意：无论任务是否成功，总是要花费 $w_i$ 的代价去做。**
********
本题带有 $\text{SPJ}$。如果你的输出与答案的输出一样优（或者都是`Impossible`），那么你将在这个测试点获得满分，否则你将在这个测试点不获得任何分数。

由于某种原因，本题不提供 $\text{SPJ}$ 给选手。
********
数据范围：  
对于 $10\%$ 的数据，$1\le n\le 10$。  
对于另外 $20\%$ 的数据，所有 $w_i$ 相等。  
对于另外 $20\%$ 的数据，所有 $p_i$ 相等。  
对于所有数据，$1\le n\le 2\times10^5$，$1\le w_i\le 10^9$，$0\le P_i\le10^4$。

## 样例 #1

### 输入

```
2
999 1
5000 10000
```

### 输出

```
1 2```

## 样例 #2

### 输入

```
1
1
0
```

### 输出

```
Impossible```

# 题解

## 作者：WYXkk (赞：10)

# 题解 机器人
首先判断无解：如果有事的成功率为 $0$，那么输出 `Impossible`。

否则，我们考虑如何计算某种顺序下的期望花费。

$$\begin{aligned}E&=(1-p_1)(w_1+E)+p_1(1-p_2)(w_1+w_2+E)+\cdots\\&+p_1p_2\cdots p_{n-1}(1-p_n)(w_1+w_2+\cdots+w_n+E)\\&+p_1p_2\cdots p_n(w_1+w_2+\cdots+w_n)\\&=(1-p_1p_2\cdots p_n)E+(w_1+p_1w_2+p_1p_2w_3+\cdots+p_1p_2\cdots p_{n-1}w_n)\end{aligned}$$
从而
$$E=\dfrac{w_1+p_1w_2+p_1p_2w_3+\cdots+p_1p_2\cdots p_{n-1}w_n}{p_1p_2\cdots p_n}$$
我们考虑交换第一件事与第二件事。
$$E^\prime=\dfrac{w_2+p_2w_1+p_1p_2w_3+\cdots+p_1p_2\cdots p_{n-1}w_n}{p_1p_2\cdots p_n}$$
如果 $E^\prime<E$，那么 $w_2+p_2w_1<w_1+p_1w_2$，即 $w_2(1-p_1)<w_1(1-p_2)$，即 $\dfrac {w_2}{1-p_2}<\dfrac{w_1}{1-p_1}$。

对于其他的编号相邻的两件事，同理可得交换后期望花费变小等价于 $\dfrac w{1-p}$ 反序，因此最小值必定在 $\dfrac w{1-p}$ 升序时取到（情况有限故最小值存在，除了它都不是极小的，因此它是最小的）。

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

struct thing{int id;ll w,p;}a[200005];
bool operator<(thing a,thing b){return a.w*(10000-b.p)<b.w*(10000-a.p);}
int n;
int main()
{
	cin>>n;
	F(i,1,n) a[i].id=i;
	F(i,1,n) rd(a[i].w);
	F(i,1,n) {rd(a[i].p);if(a[i].p==0) {puts("Impossible");return 0;}}
	sort(a+1,a+n+1);
	F(i,1,n) printf("%d ",a[i].id);
	return 0;
}
```


---

## 作者：囧仙 (赞：4)

## 题解

很显然，题目的意图就是让我们对任务进行排序。根据一般套路，很容易想到国王游戏或者皇后游戏之类的排序问题。这题也不例外。

不过在我们排序之前，先算一下期望。设 $E_n$ 表示完成前 $n$ 项任务花费的期望代价，那么有：

$$
E_n=p(E_{n-1}+w_n)+(1-p)(E_{n-1}+w_n+\bm{E_n})
$$

**解释**：显然，我们考虑第 $n$ 项任务有没有被完成。

- 有 $p$ 的概率，完成了第 $n$ 项任务。显然此时的总花费是 $E_{n-1}+w_n$ 。

- 有 $1-p$ 的概率，没有完成第 $n$ 项任务。于是我们赔了夫人又折兵，不光要掏钱买下 $E_{n-1}$ 和此项任务的花费 $w_n$ ，还得重新来过。

经过一些简单的移项，有：

$$E_n=\frac{1}{p}(E_{n-1}+w)$$

显然， $E_n$ **越大，对最后的结果越劣**。可以模仿国王游戏的套路，我们要考虑改变顺序带来的影响了。不过，我们考虑的是交换任务后，对于下一个 $E$ 的影响。

假设有两个任务 $(p_1,w_1)$ 和 $(p_2,w_2)$ ，设它们之前的任务的费用期望为 $E_0$ ，完成了任务 $1$ 后期望是 $E_1$ ，完成了任务 $2$ 后期望是 $E_2$ 。

$$\begin{aligned}
E_1&=\frac{1}{p_1}(E_0+w_1) \cr
E_2&=\frac{1}{p_2}(E_1+w_2)=\frac{1}{p_2}(\frac{1}{p_1}(E_0+w_1)+w_2) \cr
&=\frac{1}{p_1p_2}(E_0+w_1+p_1w_2)
\end{aligned}$$

那么这两个任务对下一个任务的期望贡献就是 $E=\frac{1}{p_1p_2}(E_0+w_1+p_1w_2)$ 。交换两个任务，同理，可得这两个任务对于下一个任务的初始贡献应该是 $E'=\frac{1}{p_1p_2}(E_0+w_2+p_2w_1)$。

那么我们比较 $E$ 和 $E'$ 的大小，决定是否交换这两个任务就行了。对于无解的情况，显然是存在一个任务无法被完成。最终的时间复杂度 $\mathcal O(n\log n)$ 。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e5+3;
int W[MAXN],P[MAXN],n,I[MAXN];
bool cmp(int a,int b){
    return 1ll*W[a]*10000+1ll*P[a]*W[b]<1ll*W[b]*10000+1ll*P[b]*W[a];
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qread(); up(1,n,i) I[i]=i; bool f=true;
    up(1,n,i) W[i]=qread();
    up(1,n,i) P[i]=qread(),f&=!!P[i];
    sort(I+1,I+1+n,cmp);
    if(!f) puts("Impossible"); else 
    up(1,n,i) printf("%d ",I[i]);
    return 0;
}
```

---

## 作者：C_liar (赞：2)

## 前言

一场未公开比赛的 T1，有幸在场上做出来，发现自己的思路和现有的题解不太一样，决定发一篇题解分享思路。

## 题解

先考虑无解的情况：若存在某种任务成功率为 $0$，则一定无解，否则一定有解。

那剩下只需要考虑如何排序使得安排最优。

先设一个 DP 状态：$f_{i}$ 表示按当前的任务安排顺序，完成前 $i$ 个任务的期望花费。

然后**假定已知**一种安排任务的顺序，思考如何写出转移方程。

假设现在已经完成前 $i-1$ 个任务，期望费用为 $f_{i-1}$，要完成第 $i$ 个任务，不难推出以下转移方程：

$$f_i=p_i\times(f_{i-1}+w_i)+(1-p_i)\times(f_{i-1}+w_i+f_i)$$

其中，前半段式子 $p_i\times(f_{i-1}+w_i)$ 表示第 $i$ 个任务成功了，花费的期望值；后半段式子表示第 $i$ 个任务没有成功，花费的期望值。

化简一下式子，得到：

$$f_i=\frac{f_{i-1}+w_i}{p_i}$$

这样，我们就能在**已知一种任务安排方式**的前提下，求出完成第 $i$ 个任务的期望。

那我们利用**贪心邻项交换**的策略，推导一下怎样排序是最优的。

假设任务安排的最优顺序是 $c_1,c_2,\cdots,c_i,c_{i+1},\cdots,c_n$，而一种次优解的安排顺序是 $c_1,c_2,\cdots,c_{i+1},c_{i},\cdots,c_n$。

不难发现只是交换了 $c_i$ 项和 $c_{i+1}$ 项，现在考虑**交换后对结果产生的影响**。

由于期望的线性性质，我们只需要考虑比较两种顺序的 $f_{i+1}$ 即可。

两种顺序的前 $i-1$ 项是完全相同的，完成的期望也应相同，设为 $f_{i-1}$。

由我们推导的式子可以得出，最优顺序完成前 $i+1$ 项的期望花费是：

$$f_{i+1}=\frac{f_{i}+w_{i+1}}{p_{i+1}}=\frac{\frac{f_{i-1}+w_i}{p_i}+w_{i+1}}{p_{i+1}}$$

化简后得到：

$$f_{i+1}=\frac{f_{i-1}+w_i+w_{i+1}p_{i}}{p_{i+1}p_i}$$

同理，我们可以推出次优顺序完成前 $i+1$ 项任务的期望花费：

$$f_{i+1}'=\frac{f_{i-1}+w_{i+1}+w_{i}p_{i+1}}{p_{i+1}p_i}$$

根据我们的假设，一定有 $f_{i+1}<f_{i+1}'$。

即：

$$\frac{f_{i-1}+w_i+w_{i+1}p_{i}}{p_{i+1}p_i}<\frac{f_{i-1}+w_{i+1}+w_{i}p_{i+1}}{p_{i+1}p_i}$$

化简后得到：

$$w_i+w_{i+1}p_i<w_{i+1}+w_ip_{i+1}$$

最后，根据冒泡排序的知识，任何一个序列都可以通过这种**使方案变得更优的邻项交换**得到有序序列，即最优方案。

所以，我们得出结论：

对于两个任务 $a,b$，若 $w_a+w_b\times p_a<w_b+w_a\times p_b$，则在最优方案中，$a$ 在 $b$ 前面，否则 $b$ 在 $a$ 前面。

根据结论写出比较函数，然后排一遍序即可。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
typedef long long ll;
const int _=2e5+10;
using namespace std;

int n;

struct Obj{
	int w,p,id;
	bool operator <(const Obj& c)const{
		return w+c.w*1e-4*p<c.w+w*1e-4*c.p;
	}
}a[_];

namespace Impossible{
	bool check(){
		bool z=0;
		for(int i=1;i<=n;i++) z|=(a[i].p==0);
		return z;
	}
	int main(){
		puts("Impossible");
		return 0;
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i].w),a[i].id=i;
	for(int i=1;i<=n;i++) scanf("%d",&a[i].p);
	if(Impossible::check()) return Impossible::main();
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++) printf("%d%c",a[i].id,i==n?'\n':' ');
	return 0;
}
```

## 鸣谢

指导教练 [@pukazhang](https://www.luogu.com.cn/user/373741) 指出了一些错误和不足。

---

## 作者：DecemberFox (赞：0)

# P6024 机器人 题解

## 题目分析

有 $n$ 个任务，做第 $i$ 个任务成功的概率为 $p_i$，不论是否成功，总是需要花费 $w_i$ 的钱。

现询问一种做任务的排列顺序，使得期望花费最小。期望即为某种排列顺序的花费与对应概率的乘积之和。

## 解法分析

对于某一种做任务的排列顺序 $c_i$，其花费的期望为其发生的概率乘以其花费。只要概率非零，就有可能通过，因此只有其中存在完成概率为 $0$ 的任务时才会输出 `Impossible`。

对于两个相邻的任务 $i,j$，交换它们做的顺序，不会影响前面的任务的成功概率，也不会影响后面任务的成功概率（因为交换前后成功完成两个任务的概率仍然相同）。因此考虑是否交换两个任务的先后顺序。

设任务 $i,j$ 被成功完成的概率和花费分别为 $p_i,p_j$ 和 $w_i,w_j$，期望花费为 $E'$。

由于交换对前面任务的概率和花费没有影响，故前面的任务期望花费不变。而做到这两个任务之后的概率和花费仍然不变，故之后的期望花费也不变。

因此交换任务的顺序仅改变当前两个任务的花费期望，于是就有：
- 若先完成任务 $i$，则有 $p_ip_j$ 的概率花费为 $w_i+w_j$；有 $(1-p_i)p_ip_j$ 的概率花费为 $2w_i+w_j$；有 $p_i(1-p_j)p_ip_j$ 的概率花费 $2w_i+2w_j$；有 $(p_i-1)p_i^2p_j^2$ 的概率花费为 $3w_i+2w_j$；有 $p_i(1-p_j)p_i^2p_j^2$ 的概率花费为 $3w_i+3w_j$。

  以此类推，$E_i'=p_ip_j(w_i+w_j)+(1-p_i)p_ip_j(2w_i+w_j)+p_i(1-p_j)p_ip_j(2w_i+2w_j)+\cdots$。
- 若先完成任务 $j$，则期望花费为 $E_j'=p_jp_i(w_j+w_i)+(1-p_j)p_jp_i(2w_j+w_i)+p_j(1-p_i)p_jp_i(2w_j+2w_i)+\cdots$。

从两条式子中可以对比每一项的内容。首先第一项相等。

之后一一对应两式的第二三项同除非零数 $p_ip_j$ 可以得到，

$$(1-p_i)(2w_i+w_j)+p_i(1-p_j)(2w_i+2w_j)\\
  (1-p_j)(2w_j+w_i)+p_j(1-p_i)(2w_j+2w_i)$$

拆开两条式子并合并同类项可以得到，

$$2w_i+w_j+p_iw_j-2p_ip_jw_i-2p_ip_jw_j\\
  2w_j+w_i+p_jw_i-2p_jp_iw_j-2p_jp_iw_i$$

将两条式子相减，

$$w_i-w_j+p_iw_j-p_jw_i$$

此时若前者的期望花费更大（即先完成任务 $i$ 时花费更多，此时应先完成任务 $j$），该式子大于零，否则小于零。

$$
\begin{aligned}
w_i-w_j+p_iw_j-p_jw_i&>0\\
w_i(1-p_j)-w_j(1-p_i)&>0\\
w_i(1-p_j)&>w_j(1-p_i)
\end{aligned}
$$

可以判断后面的四五项、五六项也同样能够满足该条件。因此这就是判断相邻的两个任务是否应该交换的充分必要条件。

继续变形上面的式子，可以提取出一个只与当前任务有关的值，

$$
\begin{aligned}
w_i(1-p_j)&>w_j(1-p_i)\\
\dfrac{w_i}{1-p_i}&>\dfrac{w_j}{1-p_j}
\end{aligned}
$$

从这条式子可以看出，关于当前任务的值可以被用于决定任务的先后顺序，进而推出不相邻的两个任务也可以通过该式子判断是否应该交换。但该式子在实际计算中可能会产生精度问题，故转换为整式判断。

综上，就可以使用排序算法，结合 $w_i(1-p_j)>w_j(1-p_i)$ 判断是否需要交换。

记得开 long long。时间复杂度就为排序的复杂度，即 $O(n\log n)$。

最终代码如下：

```cpp
namespace SOLVE
{
	typedef long long ll;
	typedef unsigned long long ull;
	typedef __int128 lll;
	typedef unsigned __int128 ulll;
	const int const1=2e5+10;
	struct task
	{
		ll v,w,p;
	}a[const1];
	inline bool cmp(task x,task y)
	{
		return (10000ll-x.p)*y.w>(10000ll-y.p)*x.w;
	}
	void solve()
	{
		int i,n;
		read(n);
		for(i=1;i<=n;++i) read(a[i].w);
		for(i=1;i<=n;++i)
		{
			read(a[i].p);
			a[i].v=i;
			if(a[i].p==0)
			{
				printf("Impossible\n");
				return;
			}
		}
		std::sort(a+1,a+n+1,cmp);
		for(i=1;i<=n;++i) write(a[i].v,' ');
		putchar('\n');
	}
}
int main()
{
	SOLVE::solve();
	return 0;
}
```

---

## 作者：steambird (赞：0)

## 思路

构造最优序列题，考虑看看有没有邻项交换性质。

显然，如果存在 $p_i = 0$，则不可能实现，否则一定可能。

设对于前 $i-1$ 个任务，完成它们的代价期望为 $W$，第 $i$ 个任务为 $(w_i,p_i)$，完成前 $i$ 个任务的代价的期望为 $W'$，我们考虑如何计算 $W'$。容易列出：

$$
W' = p_i (W+w_i) \times \sum_{i=0}^{+\infin} ((1-p^i) \times (i+1))
$$

其中，右边求和式的 $i$ 表示失败的次数。问题变成如何求这个求和式的值。设 $f(x) = \sum_{i=0}^{+\infin} (x^i \times (i+1))$，则：

$$
\begin{aligned}
\because f(x) &= \sum_{i=0}^{+\infin} (x^i \times (i+1)) \\
 xf(x) &= \sum_{i=0}^{+\infin} (x^{i+1} \times (i+1)) \\
 &= \sum_{i=1}^{+\infin} (x^i \times i) \\
\therefore (1-x) f(x) &= \sum_{i=0}^{+\infin}x^i \\
 &= {1 \over {(1-x)}} \\
\therefore f(x) &= {1 \over {(1-x)^2}}
\end{aligned}
$$

由此，$(w_1,p_1)$ 在 $(w_2,p_2)$ 前更优的充分必要条件是：

$$
\begin{aligned}

f(1-p_2) \times p_2 \times (f(1-p_1) \times p_1 \times (W+w_1) + w_2) &< f(1-p_1) \times p_1 \times (f(1-p_2) \times p_2 \times (W+w_2) + w_1) \\

W+w_1+{w_2 \over {f(1-p_1) \times p_1}} &< W+w_2+{w_1 \over {f(1-p_2) \times p_2}} \\

w_1(p_2 - 1) &> w_2(p_1 - 1)

\end{aligned}
$$

上述不等式可化为 ${w_1 \over {p_1 - 1}} < {w_2 \over {p_2 - 1}}$，只与 $(w_i,p_i)$ 有关，故可用于排序。输出排序完后的序列即可。**但要注意的是，除法有明显的精度损失，所以必须用 $w_1(p_2 - 1) > w_2(p_1 - 1)$ 排序，否则会挂分。**

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

inline void train() {
	   ios::sync_with_stdio(false);
	   cin.tie(0);
	   cout.tie(0);
}

inline int maxi(int a, int b) {
	return a > b ? a : b;
}

inline int mini(int a, int b) {
	return a < b ? a : b;
}

struct task {
	int id;
	double w, p;
};

constexpr int N = 2e5+4;
task ts[N];
int n;

bool cmp(const task &a, const task &b) {
//	return a.weight() > b.weight();
	return (a.w * (b.p - 1.0)) > (b.w * (a.p - 1.0));
}

int main() {

	train();
	
	cin>>n;
	for (int i = 1; i <= n; i++) cin>>ts[i].w;
	bool bad = false;
	for (int i = 1; i <= n; i++) {
		int tmp;
		cin>>tmp;
		if (tmp == 0) {
			bad = true;
		}
		ts[i].p = tmp / 10000.0; 
		ts[i].id = i;
	}
	if (bad) {
		cout<<"Impossible"<<endl;
		return 0;
	}
	sort(ts+1,ts+n+1,cmp);
	for (int i = 1; i <= n; i++) cout<<ts[i].id<<' ';
	cout<<endl;
	//cout<<flush;

	return 0;
}

```

---

## 作者：huangrenheluogu (赞：0)

感觉是比较板的题，遇到类似的题目都可以往这方面思考一下。

考虑到怎么写 sort 里的比较函数。

考虑两个数 $i,j$，记 $1\sim i-1$ 的代价位 $sum$。

$i$ 放在 $j$ 前面的代价为：$((sum+w_i)\times\dfrac{1}{p_i}+w_j)\times\dfrac{1}{p_j}$。

同理，$j$ 放在 $i$ 前面的代价为：$((sum+w_j)\times\dfrac{1}{p_j}+w_i)\times\dfrac{1}{p_i}$。

$i$ 放在 $j$ 前面的充要条件是：

$((sum+w_i)\times\dfrac{1}{p_i}+w_j)\times\dfrac{1}{p_j}<((sum+w_j)\times\dfrac{1}{p_j}+w_i)\times\dfrac{1}{p_i}$

$\Leftrightarrow (sum+w_i)\times\dfrac{1}{p_i\times p_j}+w_j\times\dfrac{1}{p_j}<(sum+w_j)\times\dfrac{1}{p_i\times p_j}+w_i\times \dfrac{1}{p_i}$

$\Leftrightarrow\dfrac{w_i}{p_i\times p_j}+\dfrac{w_j}{p_j}<\dfrac{w_j}{p_i\times p_j}+\dfrac{w_i}{p_i}$

$\Leftrightarrow w_i+w_j\times p_i<w_j+w_i\times p_j$

$\Leftrightarrow w_i(1-p_j)<w_j(1-p_j)$

所以，比较函数就很好写了。

```cpp
inline bool cmp(data x, data y){//x.p , y.p 是上面的 p 乘了 10000
	return x.w * (10000 - y.p) < (10000 - x.p) * y.w;
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n;
bool f;
struct data{
	int p, w, id;
}a[N];
inline bool cmp(data x, data y){
	return x.w * (10000 - y.p) < (10000 - x.p) * y.w;
}
signed main(){
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i].w);
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i].p), f |= (a[i].p == 0);
	for(int i = 1; i <= n; i++) a[i].id = i;
	if(f) printf("Impossible");
	else{
		sort(a + 1, a + n + 1, cmp);
		for(int i = 1; i <= n; i++) printf("%lld ", a[i].id);
	}
	return 0;
}
```

---

## 作者：hundunqidian (赞：0)

# Luogu P6024 
------------
## STEP 1：
### 考虑对于固定序列，如何计算期望代价。

设前 $i$ 件事的期望为 $f[i]$。

那么，$f[i]=p[i] \times (f[i-1]+w[i])+(1-p[i]) \times (f[i-1]+w[i]+f[i])$

即：$f[i]={f[i-1]+w[i]\over p[i]}$
## STEP 2：
### 考虑如何求最优序列。

对于相邻两件事 $i+1$ 与 $i+2$，我们的目的是使得 $f[i+2]$ 尽可能小。

$$f[i+2]={(f[i]+w[i+1]+p[i+1]\times w[i+2])\over p[i+1]\times p[i+2]}$$

那么，交换第 $i+1$ 件事和第 $i+2$ 件事后，$f[i+2]$ 变小等价于：
$$w[i+1]+p[i+1]\times w[i+2] \ge w[i+2]+p[i+2]\times w[i+1]$$

移项得：

$w[i+1]\times (1-p[i+2]) \ge w[i+2]\times(1-p[i+1])$

${w[i+1] \over 1-p[i+1]} \ge {w[i+2] \over 1-p[i+2]}$

所以，按 $w[i] \over 1-p[i]$ 从小到大排序即可。

## STEP 3：
### 代码

------------

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int const X=2e5+100;
int n;
struct node{
	int p,w,id;
	double k;
}; 
node a[X];
bool cmp(node x,node y){
	//return x.k<y.k;
	return x.w*(10000-y.p) < y.w*(10000-x.p); //变除法为乘法，否则会有精度问题 
}
signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].w;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].p;
		if(a[i].p==0){
			cout<<"Impossible";
			return 0;
		}
		a[i].id=i; 
		//a[i].k=1.0*a[i].w/(max(1e-5,1.0-1.0*a[i].p/10000));
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		cout<<a[i].id<<' ';
	}
	return 0;
} 

---


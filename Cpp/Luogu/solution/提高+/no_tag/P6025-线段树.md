# 线段树

## 题目背景

小 W 学习了一种叫做线段树的数据结构。

## 题目描述

很快，小 W 就发现：线段树实在是太浪费空间了！

比如，一棵 $n=6$ 的线段树长下面这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)

可以发现，只有 $11$ 个节点存储了有用信息，但使用的数组下标到了 $13$。

令 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，现在小 W 想让你求出：
$$f(l)\;\oplus\;f(l+1)\;\oplus\;f(l+2)\;\oplus\cdots \oplus\;f(r)$$
其中，$\oplus$ 表示异或运算，相当于 C++ 中的`^`符号。

## 说明/提示

## 样例解释
$f(6)=13$，故答案为 $13$。
## 提示
如果你不知道什么是线段树：
```cpp
void build(int k,int l,int r)
{
	if(l==r)
	{
		//do something
		//e.g. tree[k]=a[l]
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	//do something
	//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]
}
```
翻译成人话就是：编号为 $k$ 节点有一个线段 $[l,r]$，如果 $l\neq r$，那么令 $mid=\lfloor\dfrac{l+r}2\rfloor$，它有两个子节点，左儿子编号为 $2k$，线段为 $[l,mid]$；右儿子编号为 $2k+1$，线段为 $[mid+1,r]$，然后在子节点上递归建树。

调用`build(1,1,n)`后就建好了一棵线段树，即编号为 $1$ 的结点的线段为 $[1,n]$。
## 数据范围  
对于 $10\%$ 的数据，$1\le l\le r\le10^3$。  
对于 $40\%$ 的数据，$1\le l\le r\le 10^6$。  
对于 $100\%$ 的数据，$1\le l\le r\le10^{15}$，答案在`long long`范围内。  

## 样例 #1

### 输入

```
6 6
```

### 输出

```
13```

# 题解

## 作者：zhoukangyang (赞：34)

这题十分在考场上十分坑,调了$1$个多小时后结果是题目出锅了,现在说一下我的做法。
## 10pts
暴力,在这里不展开了。
## 40pts
对于一珂线段树,我们只要走最大的那条路,并得到最终节点坐标即可。具体方法如下:
假设我们走到一个节点,它的子树共有$x$个节点,它的下标为$y$,
要求的是子树上最大下标：

1. 首先如果`x==1`,直接返回$y$
1. 否则,如果`x%2==0`,返回的最大下标一定在右子树。
1. 否则,如果`lowbit(x/2)==x/2` 表示左子树深度深，返回的最大下标一定在左子树。
1. 否则,直接返回右子树(因为右子树相同深度下标一定比左子树大)

复杂度$O(nlogn)$ `n=(r-l+1)`

在这里就不开$long long$了反正也过不了

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,r,S,SS,ans;
int lowbit(int x) {
	return x&-x;
}
int q(int x,int y) {
	if(x==1) return y;
	if(x%2==0) return q(x/2,y*2+1);
	else if(lowbit(x/2)==x/2) return q(x/2+1,y*2);
	else return q(x/2,y*2+1);
}
int main() {
	scanf("%d%d",&l,&r);
	S=l;
	while(1) {
		SS=S;
		for(int i = 40; i >= 0; i--) {
			int QwQ=(1ll<<i);
			if(q(S,1)==q(S+QwQ,1)) S+=QwQ;
		}
		if(S>=r) {
			if((r-SS+1)%2) ans^=q(S,1);
			printf("%d",ans);
			return 0;
		}
		if((S-SS+1)%2) ans^=q(S,1);
		++S;
	}
	return 0;
}
```
## 100pts
然后我发现,有非常多的连续的$f(i)$相同,比如$f(1536)$~$f(2047)$均相同,于是就想到了倍增处理。

最终如果连续的个数为奇数那么将$ans$异或其中的$f$函数值。

代码长度短,时间复杂度很低但为$O($玄学$)$

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,S,SS,ans;
long long lowbit(long long x) {
	return x&-x;
}
long long q(long long x,long long y) {
	if(x==(1ll)) return y;
	if(!(x&(1ll))) return q(x/(2ll),y*(2ll)+(1ll));
	else if(lowbit(x/(2ll))==x/(2ll)) return q(x/(2ll)+(1ll),y*(2ll));
	else return q(x/(2ll),y*(2ll)+(1ll));
}
int main() {
	scanf("%lld%lld",&l,&r);
	S=l;
	while(1) {
		SS=S;
		for(long long i = (40ll); i >= (0ll); i--) {
			long long QwQ=((1ll)<<i);
			if(q(S,(1ll))==q(S+QwQ,(1ll))) S+=QwQ;
		}
		if(S>=r) {
			if((r-SS+(1ll))%(2ll)) ans^=q(S,(1ll));
			printf("%lld",ans);
			return 0;
		}
		if((S-SS+(1ll))%(2ll)) ans^=q(S,(1ll));
		++S;
	}
	return 0;
}
```

---

## 作者：WYXkk (赞：23)

# 题解 线段树
## 10pts
依题意模拟即可。

$\texttt{code:}$（仅核心部分）
```cpp
typedef long long ll;
ll ans=0;
void build(ll k,ll l,ll r)
{
	ans=max(ans,k);
	if(l==r) return;
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
}
ll f(ll n){ans=0;build(1,1,n);return ans;}

```
## 40pts
我们发现，$n=m-1$ 的线段树与 $n=m$ 的线段树的区别，仅仅是将一个叶子节点“分裂”为了两个叶子节点。而且，我们发现每次都是先分裂左子树内的点，再分裂右子树内的点。于是，我们先建一棵空树，然后加节点加到 $l$ 个叶子节点，并开始统计答案，然后一路加到 $r$ 个叶子节点，中途维护一下 max 即可。

$\texttt{code:}$（仅核心部分）
```cpp
const int N=1000005;
int a[N<<2],ans=1;
//a[k]=0:叶子节点/未被访问到
//a[k]=1:下一步在左子树分裂，a[k]=2反之
void add(int k)
{
	if(a[k]==0)//访问到叶子节点 
	{
		ans=max(ans,k<<1|1);//最大下标肯定在右儿子 
		a[k]=1;//设为往左 
		return;
	}
	add(k<<1|(a[k]-1));//递归下去 
	a[k]=3-a[k];//更新方向(1->2,2->1) 
}
```
## 100pts
首先，看到 $\bigoplus\limits_{i=l}^rf(i)$，肯定容斥一下，设 $g(n)=\bigoplus\limits_{i=1}^nf(i)$，答案就是 $g(r)\;\oplus\;g(l-1)$。

如果我们打个表我们会发现：$\forall k,1\le t\le 2^k-1$，$f(2^k+2t)=f(2^k+2t+1)$。

这是因为，当 $n$ 从 $2^k+2t$ 变成 $2^k+2t+1$ 时，分裂的是左子树内的节点，但此时右子树内最下面一层肯定有节点，这次改动对答案没有影响。

由于$a\;\oplus\;a=0$，求 $g(n)$ 时可以爽快的约掉一大堆，然后就只剩下所有 $f(2^k)$，$f(2^k+1)$，以及（可能）$f(n)$。

前面两个非常好求，因为那个时候空间没有浪费，$f(n)=2n-1$；但后面那个就要考虑一下了，我们还要考虑如何快速计算 $f(n)$。

先介绍一个 $O(1)$ 判断是否是 $2^k$ 的方法：
```cpp
bool ispow(ll n){return (n&(n-1))==0;}
```
原理请各位自行体会。

先计算出 $n$ 节点的线段树的层数 $dep$（根节点为0层），然后如果 $n\neq 2^k,2^k+1$，那么左边即使没占满也是要全算的，因此 $f(n)=2^{dep}+f(n/2)$。递归一定会递归到边界（$n=2^k,2^k+1$）。

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

#include<map>
#define int ll
ll n;
int _Logu(ll n)
{
	int l=0,r=63;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if((1ll<<mid)<n) l=mid+1;
		else r=mid;
	}
	return l;
}
bool ispow(ll n){return ((n&(n-1))==0);}
ll f(ll n,ll dep)
{
	if(ispow(n)||ispow(n-1)) return 2*n-1;
	return (f(n>>1,dep-1)+(1ll<<dep));
}
ll f(ll n){return f(n,_Logu(n));}
ll fx(ll n)
{
	if(n==0) return 0;
	ll ret=0;
	map<int,bool> m;
	#define add(x) if((x)<=n&&!m[x]) {m[x]=true;ret^=f(x);}
	for(re ll i=1;i<=n;i<<=1) {add(i) add(i+1)}
	if((n&1)==0&&!m[n]) ret^=f(n);
	return ret;
}
signed main()
{
	ll l,r;
	cin>>l>>r;
	cout<<(fx(r)^fx(l-1))<<endl;
	return 0;
}
```


---

## 作者：chinaxjh (赞：10)

# 前言
一半像这种题都是可以找规律的，于是热爱找规律来做题的我立刻开始找规律

找规律的神仙题

前置知识：[找规律专用网站](http://oeis.org/)

我比赛时就是靠这个网站找到规律才做出来的

几乎三个小时都用来做这道题了，~~结果出题人数据还错了~~

# 分析
首先，根据容斥原理可得

$\text{f(l) xor f(l+1) xor f(l+2) xor...xor f(r)=f(1) xor f(2) xor ... xor f(l-1) xor f(1) xor f(2) xor ... xor f(r)}$

也就是说，我们只要能求出

$\text{f(1) xor f(2) xor ... xor f(n)}$

就可以解决区间的问题

为方便下文叙述，我们设$\text{k(i)=f(1) xor f(2) xor ... xor f(n)}$

再者，出题人
~~很良心~~
地给出了线段树的建树代码，使得我们可以快速改出暴力代码（见$\text{Code1}$）

这样可以快速地帮助我们打一张小范围的表$\text{(1 to 64)}$，如下图所示
![](https://cdn.luogu.com.cn/upload/image_hosting/n4r7rh9f.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/vvifdthd.png)

染色部分就是我们用二进制所划分出来的不同的块，其中颜色方格中左侧是$\text{(1 to 64)}$的连续自然数，右边一列是对应的$f(i)$的值，再右侧的一竖列是$k(i)$，块从最上面开始是$\text{块0(1)，块1(2)，块2(4)，块3(8)...}$

一眼就可以发现同一个块内奇数的$k(i)$相同，我们把这些块中的$k(i)$值列出来（从块2开始）
$$\text{7,9,23,41,87}$$
好像不是一眼可以看出来的，所以我们上$Oeis$搜一下，找到的第一个应该是[A083582](http://oeis.org/A083582),告知了我们规律$a(n)=(8*2^n-5*(-1)^n)/3$

$\color{red}\text{注意:}$前面的$\text{1 to 4}$建议打表，因为不大符合规律

我们可以继续用暴力算法计算一下后面的结果进行验证，发现这个规律是可靠的

然后我们再看所有$2^n$的$k(i)$值（从块2开始）
$$0,6,8,22,40,86,168$$
再看一下[A083582](http://oeis.org/A083582)的序列
$$1,7,9,23,41,87,169$$
发现了什么，这就是$A083582$所产生的序列减1所产生的

接下来我们来探讨最麻烦的部分——
**偶数**

我们先观察一下同一个块中偶数的$f(i)$（以块6为例）
$$97,113,113,121,121,121,121,125,125,125,125,125,125,125,125$$

发现同一个答案重复的次数刚好是$2^n$，让我们把重复的省去
$$97,113,121,125$$
相邻的求差之后得到
$$16,8,4$$
原来增大的值是以$2^n$在减小

以同样的方式分析一下其它几个块，也发现了类似的规律（可以自行手动探究）

那么我们还剩下三个问题

- 每个块中的第一个偶数的$f(i)$怎么求 
- 每个块中的第二个和第一个$f(i)$之间的差怎么求
- 得到$f(i)$之后怎么求$k(i)$
~~(这还用问吗)~~

我们一个一个来解答

- 每个块中的第一个偶数的$f(i)$怎么求 
我们来观察一下块4开始的第一个偶数的$f(i)$
$$25,49,97$$
上$oies$搜了一下会跳出来11个结果，第一个是七项的斐波那契，不要选这个，我一开始想都没想就选了这个，后来对拍时发现的错误，应该用更大的数据去验证一下，应该选的是[A181565](http://oeis.org/A181565)，提供的规律是$a(n) = 3*2^n + 1.$

第一个问题圆满解决了
- 每个块中的第二个和第一个$f(i)$之间的差怎么求

依然是找规律

发现从块4开始的差是这样的
$$4,8,16......$$

这个规律很好找。我们块$n$中的第二个和第一个$f(i)$之间的差即为$2^{n-2}$
- 得到$f(i)$之后怎么求$k(i)$

毫无疑问用$f(i)$去$xor$一下$k(i-1)$即可，$k(i-1)$在同一块中就是我们求出来的奇数的定值

- 关于判断是否是$2^n$的方法

[出题人](https://www.luogu.com.cn/user/130151)在他的[题解](https://www.luogu.com.cn/blog/wyxkk-233/post-ti-xie-xian-duan-shu)中给出了$O(1)$的方法
```cpp
bool ispow(ll n){return (n&(n-1))==0;}
```

到此，我们的分析结束，开始码代码，最终代码见$Code2$
# $\text{Tips}$
开$\color{red}\text{long long}$
# $\text{Code}$
### $\text{Code1}$
```cpp
//出题人送我们的骗分代码
#include<bits/stdc++.h>
using namespace std;
int ans,w;
void build(int k,int l,int r)
{
	ans=max(k,ans);
	if(l==r)
	{
		//do something
		//e.g. tree[k]=a[l]
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	//do something
	//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]
}
int main()
{
	int n,l,r;
	cin>>l>>r;
	for (n=l;n<=r;n++)
	{
		ans=0;
		build(1,1,n);
		w=w^ans;
	}
	cout<<w<<endl;
}
```
### $\text{Code2}$
```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef double db;
typedef long double ld;
typedef unsigned long long ull;
using namespace std;
ull w,a[100],b[100],c[100],d[100];
ull l,r,k,wx,wy;
ull ans(ull n)
{
	ull i,ii,j,t,tt,ww;
	if (n==0) return 0;
	if (n==1) return 1;
	if (n==2) return 2;
	if (n==3) return 7;
	if (n==4) return 0;//小的先打表处理掉
	for (i=63;i>=0;i--)
		if (n>a[i]) break;
	i++;//判断在第几个块
	ii=i;
	if (n%2==1) return b[i]; //奇数
	if (n==a[i]) return c[i];//2的整数次幂
	t=d[i];//该块中奇数f(i)的首项
	tt=n-a[i-1];
	tt/=2;
	for (i=63;i>=0;i--)
	  if (tt>=a[i]) break;//计算去掉所有的重复之后是第几项
	ww=a[ii-2];
	for (j=1;j<=i;j++)
	{
		t=t+ww;
		ww/=2;
	}//计算当前的f(i)
	return t^b[ii];//计算k(i)
}
int main()
{
	a[0]=1;
	for (ull i=1;i<=63;i++)
	a[i]=a[i-1]*2;//计算2的整数次幂
	d[2]=7;
	d[3]=13;
	d[4]=25;
	d[5]=49;
	d[6]=97;
	for (ull i=7;i<=60;i++)
	{
		d[i]=3*a[i-1]+1;
	}//预处理每个块中偶数的f(i)的首项
	for (ull i=1;i<=60;i++)
	{
		k=i-1;
		if (k%2==1)
		b[i]=(8*a[k]+5)/3;
		else b[i]=(8*a[k]-5)/3;//计算块内奇数相同的k(i)
		c[i+1]=b[i]-1;//预处理2的整数次幂的k(i)
	}
	cin>>l>>r;
	wx=ans(l-1);
	wy=ans(r);
	w=wx^wy;//获取两个k(i)再xor获得区间的答案
	cout<<w<<endl;
}
```
# 后言
一定要敢想，敢猜，敢推，这样面对难题的时候就有了主动权

$\mid\color{red}\text{诚实面对自己的悲伤，与事与愿违的世界释怀}$

---

## 作者：CDFLS_mao_zx (赞：6)

## P6025 题解

*upd 23.2.1：修好了链接。*

提供一个复杂度为的 $O(\log n)$ 的，基于正常分析而非打表的做法，我认为这个做法比当前题解区的所有做法更加优美。

这道题相当不错，考察了线段树和位运算的理解。

### 题意

- 一颗常规方式构建的线段树，求大小为 $1,2,3,\cdots n$ 的线段树分别占用的最大空间，即最大下标。

- 输出答案的异或和。
- $n\leq 10^{15}$

构建代码为：

```cpp
void build(int k,int l,int r)
{
	if(l==r)
	{
		//do something
		//e.g. tree[k]=a[l]
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	//do something
	//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]
}
```

**原题意是求 $f(l,r)$，但很容易转化为求 $f(1,n)$，直接求 $f(1,l-1)\bigoplus f(1,r)$ 即可。**

### 分析

#### 40PTS

首先，线段树建立的过程，就是**从根往下走的过程**，往左走，向当前编号的二进制表示后写一个 $0$，往右走，就写一个 $1$。

考虑线段树的最大下标在何处取到，由于右儿子下标相对较大，一个比较显然的想法是一直走右儿子，但是这样是错误的，显然的反例为 $n=3$，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/7aesc0yg.png)

这个例子中，$[1,3]$ 节点的左儿子比右儿子多一层，所以出现了走左儿子最优的情况。

**但是，如果某个节点处左右儿子高度相同，那么很显然应该走右儿子，因为当前这一步决定的位数是最高位。**

所以走左儿子，当且仅当左右儿子高度不同，下面分析线段树的高度和长度的关系。

首先，子树构建情况**只和长度有关**，所以我们**只关心长度而非左右端点**，然后，长度为 $2^k$ 的节点，构建出的树为一颗完全二叉树，其高度为 $k$。 此时，如果点数继续增大，那么高度为 $k$ 的树就无法容下这么多节点，高度会变为 $k+1$，所以，长度为 $(2^k,2^{k+1}]$ 的节点，构建出子树的高度为 ${k+1}$。

容易发现，常规构建方式构建出的子树，其**左儿子的大小不小于右儿子，且差值至多为 1**，因此，如果出现了左右儿子高度不同，一定是左儿子比右儿子高，并且只能是一种情况，即长度的二进制表示为 $100001$。即除了最高位和最低位其余位均为 $0$，只有这样才会出现左右儿子落在不同区间的情况。

所以我们对于一个 $n$，很容易给出一个 $O(\log n)$ 的计算方式，即：

```cpp
int ask(int x,int now=1){
	if(x==1)return now;
	if(__builtin_popcount(x)==2&&x&1)return ask(x+1>>1,now*2);
	return ask(x>>1,now*2+1);	
}
```

其中 `__builtin_popcount()` 为内置函数，参数为 `unsigned`， `int` 也可以使用但不能为负数。

如果希望对 `long long` 使用，应改为 `_builtin_popcountll()`。

对每个数暴力求解即可。

#### 100PTS

我们需要观察求解一个数的过程，不妨考虑二进制数 $1001011$ 的计算过程。

手动模拟一下上述 $\operatorname{ask()}$ 函数的调用过程，$now$ 变量和 $x$ 变量的值依次变为 

```plain
now=00000001 x=1001011
now=00000011 x=0100101
now=00000111 x=0010010
now=00001111 x=0001001
now=00011110 x=0000101
now=00111100 x=0000011
now=01111000 x=0000010
now=11110001 x=0000001
```

容易发现，在出现 $1001$ 这样的情况之前，我们将 $now$ 左移一位并在后面写上了 $1$，同时将 $x$ 右移一位。

在出现 $1001$ 之后，我们一直在往 $now$ 后面写 $0$，而 $x$ 的变化则是先右移一位并将最后一位改为 $1$。

而最后 $x$ 从 $10$ 变为 $1$ 时，我们在 $now$ 末尾添加了一个 $1$。

不难发现，一个固定的 $x$，我们最终得到的占用下标最大值，**仅仅和它二进制表示下的最高位和第二高的为 $1$ 的位有关**，因为在这之前我们一定会添加 $1$，而在这之后一定会往后添加 $0$ 并在最后添加一个 $1$。

**注意如果为 $2^k$ 这样不存在次高位的数，我们需要特判。**

所以我们有了一个比较显然的想法，即枚举二进制下最高位和次高位的位置，统计能取到这两个位置的数的数量，并异或上对应的权值。

这样的复杂度是 $O(\log^2n)$ 的，我们考虑继续优化。

对于二进制下位数小于 $n$ 的二进制下位数的所有数，实际上会有贡献的只有两个值，分别是 $2^k$ 和 $2^k+1$。因为**如果次高位不为第一位，那么能取到该值的数的个数一定为偶数个（低于次高位的位置可以任意填）**。剩下这两个值的贡献都是可以 $O(1)$ 计算的。

这样就只用考虑二进制下位数和 $n$ 相同的数，同样的道理，如果次高位高于 $1$，那么没有贡献，但需要注意的是，如果次高位取到了上界，例如 $10110$ 中，次高位取到了第三位的 $1$，那么由于必须小于 $n$，实际上只有奇数个值可以取到，这样会带来一定的贡献，所以我们需要计算这种情况的答案，复杂度为 $O(\log n)$。

总复杂度$O(\log n)$。

可以参考我博客中的一些线段树的总结，会不定期更新。

[从ZKW线段树看线段树的性质](https://huanyp.cn/2022/08/04/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%90%86%E8%A7%A3/%E6%80%A7%E8%B4%A8/%E4%BB%8EZKW%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9C%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8/)

### 参考代码

```c++
#include<bits/stdc++.h>
#define y1 y3647
#define int long long
#define pii pair<int,int>
#define low(x) ((x)&-(x))
using namespace std;
template<typename _type>
inline void read(_type &x){
	x=0;int f=1;char ch=getchar();
	while(ch!=45&&(ch>'9'||ch<'0'))ch=getchar();
	if(ch==45){f=-1,ch=getchar();}
	while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getchar();}x*=f;
}
template<typename _type1,typename _type2>void cmin(_type1 &a,const _type2 b){if(a>b)a=b;}
template<typename _type1,typename _type2>void cmax(_type1 &a,const _type2 b){if(a<b)a=b;} 
int i,j,k,n,s,t,m,tp1,tp2;
int solve(int x){
	if(x==0)return 0;
	if(x==1)return 1;
    //特判边界情况
	int res=1,h=log2(x);
    //最高位从 10 开始枚举,所以 res 初值应该设置为 1
    //h 为二进制下 x 的位数
	for(i=1;i<h;i++){
		res^=(1ll<<i+1)-1;
		res^=(1ll<<i+1)+1;
        //注意左移操作的 1 是 long long 级别的数
        //计算 2^k 和 2^k+1 的答案,其它位置没有贡献 
	}
	res^=(1ll<<h+1)-1;
    //计算 2^h 的答案
	if(low(x)==x)return res;
    //如果 x=2^h,无需进行下面的步骤
	res^=(1ll<<h+1)+1;
	if(x-1==1ll<<h||x&1)return res;
    //如果 x=2^h+1 或者末尾为 1,那么之后取到的值个数一定是偶数,无需计算。
	int now=1;
	while(__builtin_popcountll(x)>2||(x&1)==0){
		now=now<<1|1;
		x>>=1;
	}
    //模拟求解的第一步,找到对应的次高位,在这之前往后写 1
	while(x){
		x>>=1;
		now<<=1;
	}
    //模拟求解第二步,往后写 0
	now|=1;
    //记得左右还需要异或 1
	return res^now;
}
signed main()
{
// 	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	freopen(".in","w",stdout);
	int l,r;
	read(l),read(r);
	printf("%lld\n",solve(r)^solve(l-1));
	return 0;
}


```





---

## 作者：__builtin_orz (赞：4)

这题昨天想了一整天，晚上睡觉的时候学长托梦给我，教我做，今早一发就 AC 了！（跪谢学长）

所以这题怎么做？

## step 0：奆佬同桌搓的 $O(n^2)$

暴力建树，统计最大编号的节点，只有十分。

~~（良心出题人把建树代码都给出来了，真好）~~

## step 1：蒟蒻自己乱搓的 $O(n\log n)$

但实际上并没有必要跑完整棵树，考虑贪心。

显然，若该子树的左子树更高，则最大编号节点在左子树上，否则就在右子树上。求单个答案 $O(\log n)$，统计完就是 $O(n\log n)$。

众所周知，树高是 $\lceil\log_2x\rceil+1$，但是怎么求？

可以把这个柿子拆成 $\lfloor\log_2x\rfloor+$（是否非二的次方数）$+1$

蒟蒻的巨丑做法：

```cpp
inline unsigned long long high(unsigned long long len){
	return std::__lg(len)+(__builtin_popcountll(len)!=1)+1;
    //std::__lg获得整数向下取整的log2
    //__builtin_popcountll获得一个unsigned long long的二进制表示中'1'的个数
    //（若只有一个'1'，则一定是二的次方数）
}
```

奆佬同桌想起了树状数组中可以使用 lowbit 来获取一个整数的最低位的 1 ，于是若最低位的 1 就是这个数本身，则一定是 2 的次方数：

```cpp
inline unsigned long long high(unsigned long long len){
	return std::__lg(len)+((len&-len)!=len)+1;
                            /*优美*/
}
```

接下来实现贪心。

```cpp
inline unsigned long long f(unsigned long long len,unsigned long long id){
    //len：当前子树维护的区间长度
    //id：当前子树编号
	if(len==1)return id;//长度为1，就是自己的编号
	unsigned long long r=len>>1;//右子树区间长度（左子树区间长度总是大于等于右子树区间长度）
	unsigned long long l=len-r;//左子树区间长度
	return high(l)>high(r)?f(l,id<<1):f(r,id<<1|1);
    //若左子树高大于右子树高，则最大编号节点在左子树，否则在右子树
}
```

然后遍历找答案，但只有 40pts。

$O(n\log n)$ 还是不够优秀，怎么办？

考虑找规律。

## step 2：geogebra，启动！

对于 $f(1\sim 200)$，列表，描点（不连线），如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/v95xyby0.png)

不难发现，这个图像中有很多平台，且长度都为偶数（这里的平台指的是连续至少两个数的 f 相等，所以长度为 1 的单点不算）。

由于异或的性质，异或两次同一个值结果不变，所以**可以直接跳过这些平台！**

又注意到，**可以跳过的长度就是下一个 $f$ 与当前 $f$ 的差值 $-1$！**

那么这回的复杂度就大大降低了。

由于容斥原理，$f(L)\oplus\dots\oplus f(R)=(f(1)\oplus\dots\oplus f(L-1))\oplus (f(1)\oplus\dots\oplus f(R))$，所以就不用考虑区间左边的复杂情况了。

（有点像前缀和？）

然后就是快乐的 Coding 时间。

```cpp
inline unsigned long long get_ans(unsigned long long n){
    //求f(1)^...^f(n)
	unsigned long long i=1,ans=0;
    //i:当前线段树区间长度
	for(;;){
		unsigned long long t=f(i,1);
		ans^=t;
		unsigned long long dt=f(i+1,1)-t;
		if(i+dt-1>n){
            //如果越界了,判断奇偶
            //若为偶数,由于异或性质,对答案无影响
            //若为奇数,就再异或最后一次
			if(n-i&1)ans^=f(n,1);
			return ans;
		}
		i+=dt-1;//跳过中间的平台
	}
}
```

然后 main 就不展示了，核心代码上面都有了。

各位CSP2024RP++！

---

## 作者：寒冰大大 (赞：3)

老夫被卡了两个小时，终于AC了，来一发题解。

首先这道题的奥义在于找规律。

通过暴力建树来打表，打出1~1000的时候，我发现其中有几个规律：

[这是打的1到1050的表](https://www.luogu.com.cn/paste/otxjgttw)

### 第一个规律

$f(130)-f(129)=128$

$f(132)-f(130)=64$

$f(136)-f(132)=32$

$f(144)-f(136)=16$

发现没有，下标的差正好是2的整数次幂，数值的差也正好是2的整数次幂，在一定范围内，$log_2$(数值差）+$log_2$(下标差)=一个常数。

换种眼光看，我们在$[1,n]$这个区间里面f的取值最多只有$log_2^2n$种。


### 第二个规律（其实是反例）

这规律在x<=5的时候并不适用，并且当$log_2$(下标差)=0的时候，数值差还是2，因此我们要特判一下。

### 第三个规律

不难发现下标差是整数(数值差为2除外),按照异或的性质，偶数个相同数字异或和是0，因此我们可以只特判一下l和r所在的地方，并且把下标差为2的东西放在一个队列里面，并且算他们的异或和就行了。

### 第四个规律

第一个规律里面“一定范围” 每次会翻倍，不信你去看我打的表。

因此我们就可以写出来代码了，但是细节还是要注意一点，我会在代码里面提示。



由此我们考虑一个双重循环的形式来解决这道问题。

于是代码就清晰了起来

```cpp
#include<touwenjian.h>

#define int long long

using namespace std;

int l,r,trg,pla;
int f[]={0,1,3,7,7,9}; //前5个要特判 
queue <int> q; 

inline void getque()
{
	int nownum,nowf;  // nownum : 现在处理到的数字，nowf: 现在f(nownum) 
	int jmp;  //一次跳跃的距离 
	int nowlas=2ll,nowlen=2ll,lasf;  // nowlas 现在这次 
	int lker=0;
	int lasnum=5ll;
	nowf=9ll;
	for(int i=1;i<=5;i++) if(l<=i&&r>=i) q.push(f[i]);
	nownum=5ll;
	if(r<=5) return ;
	while(nownum<=r)
	{
		while(nowlas>=0)
		{
			if(nowlas==0) jmp=1;
			else jmp=1ll<<(nowlen-nowlas);  //一定要加ll，不然会被认为是32位的位运算，让你TLE 60分 
			lasnum=nownum;
			nownum+=jmp;
			if(nownum==r) //注意相等的时候要特殊处理 
			{
				lasf=nowf;
				nowf+=1ll<<nowlas;
				if(nowlas==0) nowf++;
				break;
			}
			else if(nownum>r) break;
			lasf=nowf;
			nowf+=1ll<<nowlas;
			if(nowlas==0) nowf++;
			if(nowlas==1||nowlas==0) 
			{
				if(nownum>=l&&nownum<=r)   //符合条件才能放入队列里面 
				{
					q.push(nowf);
				}
			} 
			if(!lker&&nownum>l)  //这里并不能写else，尤其要注意。 
			{
				lker=1;
				if((nownum-l)&1ll) q.push(lasf);
			}
			nowlas--; 
		}
		if(nownum>=r) 
		{
			if(nownum==r) q.push(nowf);
			else if(nowlas>=1) if((nownum-r+1)&1ll) q.push(nowf); 
			else if(!lker) if((r-l+1)&1) q.push(nowf);  //注意判断的顺序； 
			break;
		}
		nowlen++;
		nowlas=nowlen;
	}
	return ;
}

signed main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	cin>>l>>r;
	getque();
	int looker=q.front();
	q.pop();
	while(!q.empty())
	{
		int looker2=q.front();
		q.pop();
		looker^=looker2;
	}
	cout<<looker;
	return 0;
}

```


---

## 作者：maka_baka (赞：2)

> 设 $f(n)$ 是在 $[1, n]$ 建线段树后节点最大下标。求:
> $$f(i)\oplus f(i+1)\oplus\cdots\oplus f(j)$$
> $\oplus$ 是异或。$1\le i\le j\le10^{15}$。建树细节见下面代码：
> ```cpp
> using ll = long long;
> void init(ll u, ll ul, ll ur) {
>   if (ul == ur) return;
>   ll um = (ul + ur) / 2;
>   init(u*2,   ul,   um);
>   init(u*2+1, um+1, ur);
> } // f(1, 1, n);
> ```

观察实现细节：
- 下标从 1 开始。
- 左节点 $2u$，右节点 $2u+1$。
- 如果长度 $n$ 是偶数，区间对半分；如果是奇数，左边比右边多 1。

由于我们只考虑下标，上面的代码可以这样写减少参数。函数意思是：以 $u$ 位根节点建长度为 $n$ 的线段树，返回最大节点下标。时间 $O(n)$。
```cpp
ll f1(ll n, ll u) {
  if (n == 1) return u;
  if (n&1) return std::max(
    f1(n/2+1, u*2), f1(n/2, u*2+1)
  );
  return f(n/2, u*2+1)
} // f(n, 1)
```
时间瓶颈在于当 $n$ 是奇数时，不好决定选哪棵子树。模拟 $n\in[8,16]$ 的区间，比较树的形态变化过程，可以发现，左比右更优的唯一可能是 $n-1$ 时建了一颗满二叉树。变化到 $n$ 时，要用新的一层，而这新的一层刚好只有 2 个节点，它们的父节点是上一层的最左边的节点。答案是这 2 个节点中靠右的一部分。所以，当 $n=2^t+1(t\ge1)$ 时选左子树，其它时候选右子树。

判断 $t$ 是否存在可以这样做。证明也附上。
```cpp
(n & n-2) == 1 && n != 1
```
> 我们实际上是想判定 $n$ 二进制表示是这种形式
> $$1\underbrace{00\cdots0}_{t-1(\ge0)\ 个\ 0}1$$
> 可以验证存在 $t$ 的 $n$ 一定满足这个表达式。按照位与，$n$ 的低位一定是 1。减 2 刚好会让第二位到第 $w$ 位都取反，其中 $w$ 是第 2 位起往高位第一个 1。这 $(w-1)$ 位一定会变化。从结果看，更高位一定是 0，所以满足上面语句的 $n$ 的二进制表示一定是上面那样。

现在我们可以在 $O(\log n)$ 内求出 $f$ 了：
```cpp
ll f(ll n, ll u) {
  if (n == 1) return u;
  if ((n & (n - 2)) == 1)
    return f(n / 2 + 1, u * 2);
  return f(n / 2, u * 2 + 1);
}
```

> 还能进一步优化。上面这种特殊情况可以直接写出答案：
> $$f(n)=f(2^t+1)=2^{t+1}+1=2n-1$$
> 所以选左子树时的答案可以常数求出来。实现时注意一个细节，在 `f(n, u)` 的结构里，根节点不一定是 1。这不能优化最坏时间，这种代码我就不写了。

接着考虑区间异或，转换成 $[1, i-1]$ 和 $[1, j]$ 的答案之异或。模拟 $[8,16]$ 会发现这就是在往第 5 层逐渐添叶子，一下添根节点的左子树，一下右节点。同一层里，先加右边，再加左边时答案不变，这两个异或是 0。所以对于这种连续区间 $[2^k+1, 2^{k+1}](k\ge1)$，可以直接处理。端点：
$$f(2^k+1)=2^{k+1}+1\quad f(2^{k+1})=2^{k+2}-1$$

通过打表可以验证这一结论。

实现上，设 $k\ge1$ 表示最后一个完整区间，如果 $k$ 不存在就是边界 $n\le3$。
```cpp
if (n <= 3) return v[n];
```
让 $k$ 是 $2^{k+1}\le n$ 下 $k$ 的最大值，循环时保持 $p=2^{k+2}$：
```cpp
ll k = 1;
for (ll p = 8; p <= n; p <<= 1) k++;
```
处理连续的区间 $[2^i+1, 2^{i+1}](1\le i\le k)$，循环中保持 $p=2^{i+1}$，端点的函数值为：
$$f(2^i+1)=2^{i+1}+1=p+1\qquad f(2^{i+1})=2^{i+2}-1=2p-1$$
```cpp
ll a = v[2];  // 注意第一个区间 [3, 4] 前面的边界
for (ll p = 4, i = 1; i <= k; i++, p<<=1)
  a ^= ((p + 1) ^ (2 * p - 1));
```
对于多出来的情况，设最后一个区间右端点是 $2^{k+1}=q$：
```cpp
// 不要把 1ll 写成 1，给 int 左移不会扩充成 long long
ll q = 1ll << (k + 1);
```
如果有多的（$n>q$），先把下一个区间左端点处理了：
$$f(q+1)=f(2^{k+1}+1)=2^{k+2}+1=2q+1$$
```cpp
if (n > q) a ^= 2 * q + 1;
```
在相同的两个数对（偶，奇）里，如果 $n$ 是第一个，就要另外算上：
```cpp
if (n > q + 1 && !(n & 1)) a ^= f(n, 1);
```
这道题就做完了。

## Code
```cpp
#include <iostream>
using ll = long long;
ll v[]{0, 1, 3, 5};

ll f(ll n, ll u) {
  if (n == 1) return u;
  if ((n & (n - 2)) == 1)
    return f(n / 2 + 1, u * 2);
  return f(n / 2, u * 2 + 1);
}

ll g(ll n) {
  if (n <= 3) return v[n];
  ll a = v[2], k = 1;
  for (ll p = 8; p <= n; p <<= 1) k++;
  for (ll p = 4, i = 1; i <= k; i++, p<<=1)
    a ^= ((p + 1) ^ (2 * p - 1));
  ll q = 1ll << (k + 1);
  if (n > q) a ^= 2 * q + 1;
  if (n > q + 1 && !(n & 1))
    a ^= f(n, 1);
  return a;
}

int main() {
  v[2] ^= v[1], v[3] ^= v[2];
  ll lf, rg; std::cin >> lf >> rg;
  std::cout << (g(rg) ^ g(lf - 1)) << '\n';
}
```

---

## 作者：UncleSam_Died (赞：2)

### 解题思路
#### 暴力做法
从 $l$ 到 $r$ 枚举每一个数，然后建线段树，记录最大下标，然后计算答案。

代码略。

时间 $O(n^2)$，期望得分：$10$ 分。
#### 优化暴力
我们考虑每次枚举不遍历整棵线段树。显然，贪心的，最深的最右边的节点编号最大。那么我们可以发现，如果两颗子树大小相同，那么最大节点一定是在右子树，或者右子树的深度和左子树一样大，那么最大节点也在右子树，否则在左子树。

代码略。

时间 $O(n\log n)$，期望得分：$40$ 分。

#### 可以通过本题的做法
我们用暴力算法多测几组数据，观察可以发现，当当前序列大小 $n=2^k,k\in \mathbb Z$ 或 $n=2^k+1,k\in \mathbb Z$ 的时候，当前的线段树的最大节点大小为 $2\times n-1$。

同样，我们可以发现以下规律：
- 从第 $2^k+1,k\in \mathbb Z$ 个数开始，向后分别每隔 $2^0,2^1,2^2\dots$ 个数最大节点的值改变一次，直到到达第 $2^{k+1}-1$ 个数；
- 从第 $2^k+1$ 个数开始，向后分别每隔上文所说个数，最大节点的值分别增加 $2^k,2^{k-1},2^{k-2}\dots$。

那么，我们可以通过简单容斥，分别计算出 $f(1,l-1)$ 和 $f(1,r)$ 的值，然后通过 $f(1,l-1)\oplus f(1,r)$ 得到 $f(l,r)$ 的值。同样，我们不难发现，在 $2^k$ 和 $2^k+1$ 个数之后，由于均有偶数个数，异或值都为 $0$，对答案不会造成影响。因此，我们只需计算每对 $f(2^k)$ 和 $f(2^k-1)$ 的值，然后判断第 $n$ 个数所在块从左端到 $n$ 是否有奇数个数，如果有，那么再异或上 $f(n)$ 的值，这里可以通过上方规律 $O(\log n)$ 做出。

综上，时间复杂度 $O(\log n)$，空间复杂度 $O(1)$，也是成功拿下了最优解。
#### 注意事项
1. 开 long long；
2. 开 long long；
3. 开 long long；
4. 从 $2^k+1$ 开始往后跳的时候。第一步应该跳 $2$ 来跳到下一段的末尾，如果跳 $1$ 的话就会跳到每一段开头。

### AC 代码
```cpp
#include<math.h>
#include<stdio.h>
#include<stdlib.h>
#define int long long
int check(int x){
    return (x&(x-1ll))==0;
}int GetAns(int n){
    int res=0ll,now=1ll;
    while(now<=n){
        int val=(now<<1ll);
        --val;res^=val;
        if(now+1>n) break;
        if(check(now+1ll)){
            now<<=1ll;
            continue;
        } now<<=1ll;
        res^=(val+2ll);
    }
    if(check(n)) return res;
    if(check(n-1ll)) return res;
    now>>=1ll;++now;
    int val=(now<<1ll)-1;
    int add=now-1ll,cnt=2ll;
    while(true){
        val+=add;
        if(now+cnt>=n){
            int dis=n-now;
            if(dis&1) res^=val;
            return res;
        }now+=cnt;
        add>>=1ll;
        cnt<<=1ll;
    }
}
int l,r;
signed main(){
    scanf("%lld",&l);
    scanf("%lld",&r);
    int front=GetAns(l-1ll);
    int behind=GetAns(r);
    int ans=(front^behind);
    printf("%lld",ans);
}
```


---

## 作者：gyyyyx (赞：2)

[题面](https://www.luogu.com.cn/problem/P6025)

挺好的一道题。

## 10% 的数据点

按照题意模拟建树过程即可。

## 40% 的数据点

会发现，若 $n=2^k$ 或 $n=2^k+1$（$k$ 为任意非负整数），那么空间是不会浪费的。

设 $dep$ 为当前线段树的深度，根节点深度为 $0$。

分类讨论一下：

1. $n=2^k$，那么 $f(n)=2^{dep+1}-1$，此时 $dep=log_2n$，所以 $f(n)=2n-1$。

2. $n=2^k+1$，那么 $f(n)=2^{dep}+1$，此时 $dep=log_2(n-1)+1$，所以 $f(n)=2n-1$。

综上，若 $n=2^k$ 或 $n=2^k+1$，$f(n)=2n-1$。

那么如果 $n=2^k+t,t>1$ 呢？

此时的 $f(n)=f(n-\lfloor\frac{n+1}{2}\rfloor)+(2^{dep-1+1}-1+1)=f(\lfloor\frac{n}{2}\rfloor)+2^{dep}$。

因此枚举 $i$，递归计算 $f(n)$ 就行了。

核心代码：

```cpp

inline int _log(ll x){//求log(x)向上取正
    int s(0),t(63),mid;
    while(s<=t){
        mid=(s+t>>1);
        if((1ll<<mid)>=x) t=mid-1;
        else s=mid+1;
    }
    return s;
}
inline bool p(ll x){return !(x&(x-1));}//判断x是否是2^k
inline ll f(ll n){//这里为了后面方便，写了循环的
    ll dep(_log(n)),ans(0ll);
    while(!p(n)&&!p(n-1ll)){
        ans+=(1ll<<dep);
        n>>=1;--dep;
    }ans+=(n<<1)-1;
    return ans;
}
```

## 100% 的数据点

知道如何计算 $f(n)$ 了，那要怎么求 $\overset{i\leq r}{\underset{i=l}{\bigoplus}}f(i)$？

我们会发现，若 $n=2^k+2t$（$k$ 为任意非负整数，$1\leq t<2^{k-1}$），那么 $f(n)=f(n+1)$。

因为此时的贡献一定在根节点的右子树上，但是 $n+1$ 之后新增的子树在根节点的左子树上，不影响最后答案。

所以我们可以一下子约掉一大堆计算，只保留 $f(2^k)$，$f(2^k+1)$，还有可能不会被约去的 $f(l)$ 和 $f(r)$。

可以用前缀异或和的思想。

假设 $g(n)=\overset{i\leq n}{\underset{i=1}{\bigoplus}}f(i)$.

因此答案为 $g(r)\oplus g(l-1)$。

要求 $g(n)$，我们得先找到所有的 $i=2^k$ 和 $i=2^k+1$（$i\leq n$）。

把这些数全部异或上，写成这段代码：

```cpp
inline ll Xor(ll n){//求g(n)
	if(!n) return 0ll;
	if(!(n^1)) return 1ll;//这里有几种特殊情况，自己写的时候就知道f(2)会算重
	if(!(n^2)) return 2ll;
	if(!(n^3)) return 7ll;
	ll res(7ll);
	for(ll i(4ll);i<=n;i<<=1) res^=f(i)^f(i+1);//计算所有的f(2^k)和f(2^k+1)
	if(p(n)) res^=f(n+1);//有可能i+1>n，将这种情况约掉
	return res;
}
```

但是还不够，因为还有可能 $f(n)$ 是消不掉的。

因此还需要加上一句话：

```cpp
if(!(n&1)&&!p(n)&&!p(n-1)) res^=f(n);
```

也就是如果 $f(n)$ 没有被计算到，而且 $f(n)$ 不会被消去，那要再异或一次。

最终代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
    ll x(0),f(1);char c(getchar());
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
inline int _log(ll x){
    int s(0),t(63),mid;
    while(s<=t){
        mid=(s+t>>1);
        if((1ll<<mid)>=x) t=mid-1;
        else s=mid+1;
    }
    return s;
}
inline bool p(ll x){return !(x&(x-1));}
inline ll f(ll n){
    ll dep(_log(n)),ans(0ll);
    while(!p(n)&&!p(n-1ll)){
        ans+=(1ll<<dep);
        n>>=1;--dep;
    }ans+=(n<<1)-1;
    return ans;
}
inline ll Xor(ll n){
    if(!n) return 0ll;
    if(!(n^1)) return 1ll;
    if(!(n^2)) return 2ll;
    if(!(n^3)) return 7ll;
    ll res(7ll);
    for(ll i(4ll);i<=n;i<<=1) res^=f(i)^f(i+1);
    if(!(n&1)&&!p(n)&&!p(n-1)) res^=f(n);
    if(p(n)) res^=f(n+1);
    return res;
}
ll l,r;
int main(){
    l=read();r=read();
    printf("%lld\n",Xor(r)^Xor(l-1));
    return 0;
}
```

---

## 作者：Amoribus (赞：1)

用不少方法，都可以在 $O(\log n)$ 的时间内求出 $f(n,1)$ 的值（定义 $f(x,y)$ 为区间长度为 $x$ 的线段树，根节点对应的下标 $y$，递归求解即可）。然后枚举一下就可以做到 $O(n\log n)$ 的 $40$ 分。

下面是 $f(x,y)$ 函数的一种参考实现：

- 若 $x=1$，则函数值为 $y$。
- 否则，若 $x$ 为偶数，则应该走右子树，因为左右子树维护的区间等长，深度一定相等。函数值为 $f(\dfrac{x}{2},y\times 2+1)$。
- 当 $x$ 为奇数时，此时令 $t=\lfloor \dfrac{x}{2}\rfloor$，则左子树维护的区间长度为 $t+1$，右子树维护的区间长度为 $t$。分两种情况：
  - 左边深度大于右边，当且仅当 $t$ 为 $2$ 的幂次，走左子树，函数值为 $f(t+1,y\times 2)$。
  - 否则，左边和右边深度相等，走右边，函数值为 $f(t,y\times 2+1)$。

若 $t$ 为 $2$ 的幂次，则显然必有 $\operatorname {lowbit}(t)=t$。因此可以这样判断 $2$ 的幂次。

code：

```cpp
int query(int x,int y){
	if(x==1) return y;
	else if(x%2==0) return query(x/2,y<<1|1);
	else if(lowbit(x/2)==x/2) return query(x/2+1,y<<1);
	else return query(x/2,y<<1|1);
}
```

然后注意到很多相邻的函数值是相等的，考虑二分来做，只要找对于每一个数后面最后一个和它相等的函数值即可。复杂度大概 $O(\log^2 n)$。

代码很好写。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) (x&(-x))
int l,r,ans;
int query(int x,int y){
	if(x==1) return y;
	else if(x%2==0) return query(x/2,y<<1|1);
	else if(lowbit(x/2)==x/2) return query(x/2+1,y<<1);
	else return query(x/2,y<<1|1);
}
signed main()
{
	cin>>l>>r;
	for(int i=l;i<=r;){
		int f_i=query(i,1);
		int L=0,R=r,cnt;
		while(L<=R){
			int mid=L+R>>1;
			if(i+mid<=r&&query(i+mid,1)==f_i) cnt=mid,L=mid+1;
			else R=mid-1;
		}
		if(cnt%2==0) ans^=f_i;
		i=i+cnt+1;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：HYdroKomide (赞：1)

## 题意：
给定一个区间 $[l,r]$，$f(x)$ 表示 $x$ 长度的数组建线段树的最大下标，求 $\bigoplus_{i=l}^r f(i)$。

## 思路：
首先考虑到异或前缀和，一个数被异或偶数次就会抵消。因此，设 $sum(x)=\bigoplus_{i=1}^xf(i)$，我们有 $\bigoplus_{i=l}^r f(i)=sum(l-1)\oplus sum(r)$。此题转变为，给定 $x$，在 $O(\log x)$ 级别复杂度下求出 $sum(x)$。

接着，我们再解决一个前置条件，在 $O(\log x)$ 的复杂度下求出 $f(x)$。观察一棵线段树，它下标最大的结点一定位于：

1. 最深的一层，因此要每次找深度最深的那个子树；
2. 最右侧；

长度为 $k$ 的子树，其深度为 $\lceil \log_2k\rceil+1$，将其转化为 $\lfloor \log_2(2k-1)\rfloor+1$ 即可方便求出。

因此，每次递归到一层时，只需要找到左右儿子中深度较深的一层继续递归下去即可。如果两个儿子深度相同则选择右儿子。

下面就是注意力的魅力时刻了。打表得出一些 $f(x)$，我们发现这个函数是由很多段构成的。抛开前四个无规律的数据，每一段有规律的数据的边界是 $[2^{n-1}+1,2^n]$。其中，不难发现 $f(2^{n-1}+1)=2^n+1$，$f(2^n)=2^{n+1}-1$。

而这样的一大段里，还藏着很多的小段数据。从 $f(2^{n-1}+2)$ 开始，连续的 $2$ 个、$4$ 个、$8$ 个…… $2^{n-2}$ 个值分别相等。我们知道，偶数次出现次数的值不会对答案有贡献。因此，如果一个大段区间被完全包含，则这个区间里只有 $f(2^{n-1}+1)$ 和 $f(2^n)$ 这两个落单的值会对答案产生贡献。

接着，对于散块的非整段数据，至多也只会有块首的 $f(2^{n-1}+1)$ 和尾部 $f(x)$ 有可能会对答案产生贡献。

在散块长度为偶数时，$f(x)$ 所在的连续值区间长度一定是奇数，直接 $O(\log x)$ 求出即可。否则，$f(x)$ 不会对答案产生贡献，直接跳过。

整体复杂度严格的只有 $O(\log x)$。

## 程序如下：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
long long l,r,ans,pw[100],init[]={0,1,2,7,0,9};//预处理前五个sum
long long getdep(long long len){return (long long)log2(len+len-1)+1;}
long long seg(long long x,long long l,long long r){
	if(l==r)return x;
	long long mid=(l+r)>>1;
	return getdep(mid-l+1)>getdep(r-mid)?seg(x*2,l,mid):seg(x*2+1,mid+1,r);
}//log复杂度求f函数
long long getans(long long x){
	if(x<=5)return init[x];
	long long ret=7,ed;
	for(int i=2;i<=50;i++){
		if(x<pw[i]){
			ed=i-1;
			break;
		}
		else if(x>pw[i]){
			ret^=(pw[i]*2-1);
			ret^=(pw[i]*2+1);
		}
		else{
			ret^=(pw[i]*2-1);
			return ret;
		}//特判三种情况，对于每一个大块有哪些值可以贡献给答案
	}
	if((x-pw[ed])%2==0)ret^=seg(1,1,x);
	return ret;
}
int main(){
	pw[0]=1;
	for(int i=1;pw[i-1]<=1e15;i++)pw[i]=pw[i-1]*2;
	scanf("%lld%lld",&l,&r);
	printf("%lld\n",getans(l-1)^getans(r));
	return 0;
}
```
## THE END

---


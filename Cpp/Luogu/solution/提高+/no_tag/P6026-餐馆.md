# 餐馆

## 题目背景

小 W 家新开了一家餐馆。

## 题目描述

这家餐馆提供 $n$ 种特色菜，它们被标号为 $1,2,\cdots,n$。

有一天，餐馆里来了 $k$ 个客人，他们没有想好要吃什么。于是，小 W 给他们出了个主意：每个人先从 $1,2,\cdots,n$ 中等概率随机一个数 $r$，再从
 $1,2,\cdots,r$ 中等概率随机一个数 $l$，这个人就点标号在 $l$ 和 $r$ 之间（包括 $l$ 和 $r$）的菜。

于是，客人们按小 W 说的做了。在所有客人都点完单之后，小 W 突然发现：没有两个人都点了相同的一道菜，他每种菜至多做一份就够了！为了证明他是多么的欧皇，他找到了学编程的你，请你帮他计算这种情况发生的概率。

## 说明/提示

样例解释：  
样例 $1$ 解释：因为只有一位客人，所以无论如何不会有两个人点同样的菜，故所求概率为 $1$。

样例 $2$ 解释：每位客人只点 $1$ 号菜的概率为 $\dfrac12$，只点 $2$ 号菜的概率为 $\dfrac14$，两个菜都点的概率为 $\dfrac14$，两人不点同一道菜即一人只点 $1$ 号菜，一人只点 $2$ 号菜，概率为
 $\dfrac14\times\dfrac12+\dfrac12\times\dfrac14=\dfrac14$，模 $10^9+7$ 意义下为
 $250000002$。
*********

提示：如果你不知道如何对有理数取余，请看 [P2613](https://www.luogu.com.cn/problem/P2613)。

********
数据范围：  
对于 $10\%$ 的数据， $k=1$。  
对于另外 $10\%$ 的数据， $1\le k\le n\le5$。  
对于另外 $20\%$ 的数据， $1\le k\le3$。  
对于另外 $30\%$ 的数据， $1\le k\le n\le10^3$。  
对于所有数据， $1\le k\le n\le 10^8$。

## 样例 #1

### 输入

```
10 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
2 2
```

### 输出

```
250000002```

# 题解

## 作者：WYXkk (赞：22)

# 题解 餐馆
看到这题，我们发现并没有什么很好用的性质。推式子也很难推。

所以，我们当然是**找规律**了！

打暴力要注意的：
- 一个区间 $[l,r]$ 被选中的概率是 $\dfrac1{nr}$。
- 为了更好看出规律，我们需要用分数存储答案，记得约分。

然后就是暴力了：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

struct frac//分数类，看不懂没关系 
{
	public:
		ll x,y;//存储x/y
	private:
		ll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}//用于约分 
		void yf(){if(y<0)x=-x,y=-y;ll a=gcd(abs(x),y);x/=a,y/=a;}//约分 
	public:
		frac(ll x=0,ll y=1):x(x),y(y){yf();}
		double todb(){return (double)x/(double)y;}
		frac operator=(frac b){x=b.x,y=b.y;return *this;}
};
frac operator+(frac a,frac b){return frac(a.x*b.y+a.y*b.x,a.y*b.y);}
frac operator-(frac a){return frac(-a.x,a.y);}
frac operator-(frac a,frac b){return a+(-b);}
frac operator*(frac a,frac b){return frac(a.x*b.x,a.y*b.y);}
frac operator/(frac a,frac b){return frac(a.x*b.y,a.y*b.x);}
frac operator+=(frac& a,frac b){return a=a+b;}
frac operator-=(frac& a,frac b){return a=a-b;}
frac operator*=(frac& a,frac b){return a=a*b;}
frac operator/=(frac& a,frac b){return a=a/b;}
//加减乘除各种运算 
bool operator>(frac a,frac b){return a.x*b.y>b.x*a.y;}
bool operator<(frac a,frac b){return b>a;}
bool operator>=(frac a,frac b){return !(b>a);}
bool operator<=(frac a,frac b){return !(a>b);}
bool operator==(frac a,frac b){return !(a<b)&&!(b<a);}
bool operator!=(frac a,frac b){return (a<b)||(b<a);}
//比较 
//其实上面有些不会用到 

int L[20],R[20];//存储区间 
int n,k;
bool cross(int l1,int r1,int l2,int r2){return r1>=l2&&r2>=l1;}//区间相交 
frac ans(0,1);
void dfs(int t,frac p)
{
	if(t>k) {ans+=p;return;}
	for(int r=1;r<=n;++r) for(int l=1;l<=r;++l)
	{
		bool flg=true;
		for(int i=1;i<t;++i) if(cross(l,r,L[i],R[i])) flg=false;
		if(!flg) continue;
		L[t]=l;R[t]=r;dfs(t+1,p*frac(1,n*r));
	}
}
int main()
{
	cin>>n>>k;
	dfs(1,frac(1,1));
	printf("Ans=%lld/%lld",ans.x,ans.y);
	return 0;
}
```
接下来就是根据结果找规律啦！

$k=1$：$\dfrac11\;\dfrac11\;\dfrac11\;\cdots$ 所以 $k=1$ 时答案为 $1$。

$k=2$：$\dfrac01\;\dfrac14\;\dfrac13\;\dfrac38\;\dfrac25\;\cdots$ 似乎没什么规律？但是如果我们适当的反约分一下：

$k=2$：$\dfrac02\;\dfrac14\;\dfrac26\;\dfrac38\;\dfrac4{10}\;\cdots$ 规律就明显多了吧：$Ans=\dfrac{n-1}{2n}$

$k=3$：$\dfrac{0}{1}\;\dfrac{0}{1}\;\dfrac{1}{27}\;\dfrac{1}{16}\;\dfrac{2}{25}\;\dfrac{5}{54}\;\dfrac{5}{49}\;\dfrac{7}{64}\;\cdots$ 总之我看出了规律：$Ans=\dfrac{(n-1)(n-2)}{6n^2}$

进过一系列推算我们最终得出了规律：$Ans=\dfrac{(n-1)(n-2)\cdots(n-k+1)}{k!\times n^{k-1}}=\dfrac{C_n^k}{n^k}$

然后，就没有然后了。按照式子计算即可。时间复杂度 $O(k)$。

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const ll p=1000000007;
ll qp(ll a,ll b){if(!b)return 1;ll w=qp(a,b>>1);w=w*w%p;return b&1?w*a%p:w;}
ll ni(ll a){return qp(a,p-2);}
ll n,k,a=1,b=1;
int main()
{
	cin>>n>>k;
	F(i,1,k) a=a*(n+1-i)%p,b=(b*i)%p*n%p;
	cout<<a*ni(b)%p;
	return 0;
}
```
## 一些题外话
部分分是瞎出的，希望不要妨碍思考正解。

由某场我参加的 ACM 的 H 改编而来，原题 $k=2,n\le 10^6$，然后我成功用 $O(1)$ 的方法吊打 $O(n)$ 的标算~~和一群大学生~~

---

## 作者：WYXkk (赞：18)

前情提要：[找规律得出此题结果](https://www.luogu.com.cn/blog/WYXkk/post-ti-xie-can-guan)

一年过去了，我上课不知道干什么于是试图推这题式子……

然后！**推出来了！**

接下来是推式子的详细过程。

------

记题目所求值为 $f(n,k)$。

那么，我们枚举每个人选到的 $r$，然后就可以得出下面这个式子：

$$f(n,k)=\dfrac{k!}{n^k}\sum\limits_{1\le r_1<r_2<\cdots<r_k\le n}\dfrac{\prod\limits_{i=1}^k(r_i-r_{i-1})}{\prod\limits_{i=1}^kr_i}$$

含义就是，对于每个 $r$，有 $\dfrac{r_i-r_{i-1}}{r_i}$ 的概率不与前一个相撞，选到这一组 $r$ 的概率是 $\dfrac1{n^k}$，然后因为是 $k$ 个人去序所以再乘 $k!$。

这个式子不太好，我们试着固定 $r_k$ ，那么我们定义 $g$：

$$g(n,k)=k!\sum\limits_{1\le r_1<r_2<\cdots<r_k=n}\dfrac{\prod\limits_{i=1}^k(r_i-r_{i-1})}{\prod\limits_{i=1}^kr_i}$$

于是 $f(n,k)=\dfrac1{n^k}\sum\limits_{i=k}^ng(n,k)$。接下来先讨论 $g(n,k)$。

然后，枚举 $r_{k-1}$ 就有 $g$ 的递推式：

$$g(n,k)=k!\sum\limits_{i=k-1}^{n-1}\dfrac{g(i,k-1)}{(k-1)!}\times\dfrac{n-i}n$$

也就是说

$$g(n,k)=\dfrac kn\sum\limits_{i=k-1}^{n-1}g(i,k-1)\times(n-i)$$

显而易见 $g(n,1)=1$，推几项可以猜到规律：$g(n,k)=\dbinom{n-1}{k-1}$

（$\dbinom nm$ 就是 $C_n^m$ 的意思）

由于我们有数学归纳法这个好东西（对 $k$ 归纳），我们只需要证明下面的组合恒等式：

$$\dbinom{n-1}{k-1}=\dfrac kn\sum\limits_{i=k-1}^{n-1}\dbinom{i-1}{k-2}\times(n-i)$$

这里先给出一个引理：$\sum\limits_{i=k}^n\dbinom ik=\dbinom{n+1}{k+1}$。这个引理后面要用两三次，而且本身也是一个非常有用的式子。

仍然是归纳，$n=k$ 时显然，设 $n-1$ 成立则

$$\sum\limits_{i=k}^n\dbinom ik=\dbinom nk+\sum\limits_{i=k}^{n-1}\dbinom ik=\dbinom nk+\dbinom n{k+1}=\dbinom{n+1}{k+1}$$

故 $n$ 成立，由数学归纳法引理得证。

那么，

$$\begin{aligned}\sum\limits_{i=k-1}^{n-1}\dbinom{i-1}{k-2}\times(n-i)&=\sum\limits_{i=k-1}^{n-1}\sum\limits_{j=i}^{n-1}\dbinom{i-1}{k-2}\\&=\sum\limits_{j=k-1}^{n-1}\sum\limits_{i=k-1}^{j}\dbinom{i-1}{k-2}\\&=\sum\limits_{j=k-1}^{n-1}\dbinom j{k-1}\\&=\dbinom nk\end{aligned}$$

由 $\dbinom nk=\dfrac{n!}{k!(n-k)!}$ 容易知道 $\dbinom{n-1}{k-1}=\dfrac kn\dbinom nk$。

（还有一个证明方法：在 $n$ 人中选 $k$ 人再在这 $k$ 人中选一人，与在 $n$ 人中选一人再在剩下 $n-1$ 人中选 $k-1$ 人是一样的，因此 $k\dbinom nk=n\dbinom{n-1}{k-1}$，将 $n$ 除过去即可）

上面那个组合恒等式就证毕了，那么，由数学归纳法，$g(n,k)=\dbinom{n-1}{k-1}$。

回过头来，$f(n,k)=\dfrac1{n^k}\sum\limits_{i=k}^ng(n,k)=\dfrac1{n^k}\sum\limits_{i=k}^n\dbinom{n-1}{k-1}=\dfrac{\dbinom nk}{n^k}$。

于是这题做完了。这与我们找规律得到的结论是一致的。

------

最后说几句闲话：

之前我看到 $f(n,k)$ 的那个又臭又长的表达式后就没敢做了，现在才发现其实并不难。

这个推导的思路也是从找规律的结论出发倒推出了 $g(n,k)$ 的表达式再做的。

整体证明并不难，主要难度就是在发现规律。（ 

---

## 作者：zhouyuhang (赞：10)

> 唉，找规律；唉，数学归纳法；唉，生成函数；唉，组合意义。

---

引理：对于序列 $a _ 1, a _ 2, \cdots, a _ n$，有

$$
\begin {aligned}
\sum _ {\sigma} \prod _ {i = 1} ^ n \frac {a _ {\sigma(i)}} {\sum _ {j = 1} ^ i a _ {\sigma(j)}} = 1
\end {aligned}
$$

其中 $\sigma$ 为所有 $n$ 级排列。换言之，

$$
E \left( \prod _ {i = 1} ^ n \frac {a _ {\sigma(i)}} {\sum _ {j = 1} ^ i a _ {\sigma(j)}} \right) = \frac {1} {n!}
$$

---

引理的证明：构建形如 [此题](https://www.luogu.com.cn/problem/P5644)  的组合模型即可。

---

回到原题，先固定所有的 $r$，记其从小到大依次为 $1\le r _ 1 < r _ 2 < \cdots < r _ k \le n$，则 $l$ 需要满足 $1\le l _ 1 \le r _ 1, r _ 1 < l _ 2 \le r _ 2, \cdots, r _ {k - 1} < l _ k \le r _ k$。记 $a _ i = r _ i - r _ {i - 1}$；特别的，$a _ 1 = r _ 1$。那么，选出若干 $l$ 使这些区间不交的概率即为 $P (a) = \prod _ {i = 1} ^ n \frac {a_i} {\sum _ {j = 1} ^ i a _ j}$。

引理启示我们，如果可重集 $\{a _ 1, a _ 2, \cdots, a _ k\}$ 固定不变，那么其每一种本质不同的重排的 $P (a)$ 的期望即为 $\frac{1}{k!}$（虽然所有 $k!$ 种重排有可能有重复，但是由对称性，每一种本质不同的重排地位均等，所以其期望不变）。从而总的概率可以视作 $\frac {n ^ {\underline k}} {n ^ k} \cdot \frac {1} {k!}= \frac {\binom n k} {n ^ k}$，即为答案。

上述证明了仅仅使用了一次组合意义和一次对称性。

---

## 作者：Aleph1022 (赞：10)

写个大力做法。

自然考虑先钦定顺序再乘 $k!$，容易发现这其实就是 EGF。  
我们钦定一个右端点 $r_i$ 时，其有 $\frac1n$ 的贡献；钦定其左端点 $l_i$ 时，其有 $\frac1{r_i}$ 的贡献。因此我们不妨以 $r_i$ 为分界点，则每个 $r_i$ 会贡献 $\frac1{n\cdot r_i}$。  
因此我们按照如下顺序统计出一个二元 GF $F(z,t)$：
$$
\left.\bigcirc \cdot \bigcirc \cdots \bigcirc \middle\vert \overbrace{\color{blue}{\bigcirc(l_1)}\cdot\bigcirc\cdots{\bigcirc(r_1)}}^{\text{with a }{\color{green}t}}\middle\vert\cdots\middle\vert\overbrace{\color{blue}{\bigcirc(l_k)}\cdot\bigcirc\cdots{\bigcirc(r_k)}}^{\text{with a }{\color{green}t}}\right.
$$

即最后一段未被选择的部分尚不考虑。  
注意到 $n^{-k}$ 大可不计入 GF，在最后补上即可。  
则考察一个显然的 ODE：通过给 $z^r$ 乘上 $r$ 复原概率可得
$$
z\frac{\partial}{\partial z}F(z,t) = t(1+F(z,t))\cdot\frac1{1-z}\cdot\frac z{1-z}
$$

分离变量可得
$$
F(z,t) = C\mathrm e^{\frac t{1-z}}-1
$$

考察 $[z^0]$，发现任何 $t$ 都不应该有贡献，故 $C = \mathrm e^{-t}$，即 $F(z,t) = \mathrm e^{\frac{tz}{1-z}}-1$。  
乘上最后一段，提取系数
$$
\begin{aligned}
&\quad\;n^{-k}[z^n]\left[\frac {t^k}{k!}\right] F(z,t) \cdot \frac1{1-z} \\
&= n^{-k}[z^n] \frac{z^k}{(1-z)^{k+1}} \\
&= n^{-k} \binom nk
\end{aligned}
$$

即得结论。

---

## 作者：ADNAP (赞：2)

很好的一道找规律题，眼睛瞪瞎了。不想看找规律的可以跳过这篇题解嘞。
### Solution
一开始时想考虑一下 dp，但马上就可以否定了，因为有两个参，几乎不可能线性推完。

但是我们可以先写一个 $O(n^3)$ 的暴力，注意到，区间 $[l,r]$ 的被选概率为 $\frac{1}{n \times r}$。

我们用 $f_{j,i}$ 来表示 $i$ 个人点完菜后，第 $i$ 个人的区间为 $[k,j]$ 的方案数，并且钦定枚举 $i$ 的过程中区间单调，最后乘上 $A_n^n$ 即可。

易得转移方程，
$$f[j][i]=\sum f[k-1][i-1] \times \frac{1}{n} \times \frac{j-k}{j}$$

然后获得了 [$20pts$](https://www.luogu.com.cn/record/188735334) 的高分。


```cpp
ll quick_mi(ll a,ll b)
{
    ll s=1;
    while(b)
    {
        if(b&1)s=s*a%Mod;
        a=a*a%Mod;
        b>>=1;
    }
    return s;
}
signed main()
{
    scanf("%lld%lld",&n,&k);
    A[0]=1;
    for(ll i=1;i<=n;i++)A[i]=A[i-1]*i%Mod;
    f[0][0]=1;
    ny[0]=1;
    for(ll i=1;i<=n;i++)ny[i]=quick_mi(i,Mod-2);
    ll ans=0;
    for(ll i=1;i<=k;i++)
    {
        for(ll j=i;j<=n;j++)
        {
            for(ll q=i-1;q<j;q++)
                f[j][i]+=f[q][i-1]*ny[n]%Mod*ny[j]%Mod*(j-q)%Mod,
                f[j][i]%=Mod;
        }
    }
    for(ll i=1;i<=n;i++)
        ans=(ans+f[i][k])%Mod;
    printf("%lld",exmod(ans*A[k],Mod));
}
```

拿到暴力之后就可以开始找规律了。

我们先码一个把答案转成分数形式的代码，无脑硬找就行了。


```cpp
signed main()
{
    scanf("%lld",&n);
    ny[0]=1;
    for(ll i=1;i<=100000;i++)ny[i]=quick_mi(i,Mod-2);
    for(ll i=1;i<=100000;i++)
    {
        for(ll j=i;j<=100000;j++)
        {
            ll res=i*ny[j]%Mod;
            if(res==n)
            {
                printf("%lld/%lld",i,j);
                exit(0);
            }
        }
    }
}
```

然后我们能得到一些数据，因为转分数的暴力有点劣，所以很多跑不出来，但是以下数据足够了：

```cpp
1
1 1/4
1 1/3 1/27
1 3/8 1/16 1/256
1 2/5 2/25 1/125 1/3125
1 5/12 5/54 5/432 1/1296 1/46656
1 3/7 5/49
1 7/16 7/64 
1 4/9 28/243 
1 9/20
```

观察到最后一列总是 $\frac{1}{n^k}$，启发我们把他们的分母转成 $n^i$ 的形式来观察。


```cpp
1
1 1/4
1 3/9 1/27
1 6/16 4/64 1/256
1 10/25 10/125 5/625 1/3125
1 15/36 20/216 15/1296 6/7776 1/46656
1 21/49 35/343
1 28/64 56/512
1 36/81 84/729
1 45/100
```

容易观察到第二列的规律，分子为 $\frac{n \times (n-1)}{2}$.

接着同样可以看出来第三列就是三次的前缀和，第四列就是四次的前缀和，以此类推。

蒟蒻不知道高次前缀和的意义（想 FFT 来着），不过推一下式子就发现这东西其实就是 $C_n^k$。

所以，
$$ans=\frac{C_n^k}{n^k}$$

代码的组合数写的有点笨，但是不想改了。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e8+1e2;
const ll Mod=1e9+7;
#define exmod(x,y) (x%y+y)%y
ll n,k;
ll quick_mi(ll a,ll b)
{
    ll s=1;
    while(b)
    {
        if(b&1)s=s*a%Mod;
        a=a*a%Mod;
        b>>=1;
    }
    return s;
}
ll ans=1;
signed main()
{
    scanf("%lld%lld",&n,&k);
    ll fir,sec,thd,fot;
    fir=sec=thd=1,fot=quick_mi(n,Mod-2);
    for(ll i=1;i<=n;i++)
    {
        if(i<=n)fir=fir*i%Mod;
        if(i<=n-k)sec=sec*i%Mod;
        if(i<=k)thd=thd*i%Mod;
    }
    ans=fir*quick_mi(sec,Mod-2)%Mod*quick_mi(thd,Mod-2)%Mod*quick_mi(fot,k)%Mod;
    printf("%lld",ans);
}
```

---


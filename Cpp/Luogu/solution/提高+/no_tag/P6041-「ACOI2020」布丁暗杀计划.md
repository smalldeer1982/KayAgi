# 「ACOI2020」布丁暗杀计划

## 题目背景

![T3](https://s2.ax1x.com/2020/01/12/lopanO.png)

茅野 カエデ（Kayano Kaede）制定了一个用布丁暗杀杀老师的计划。他们用剩余的鸡蛋加工制成一个布丁。为了外观和味道，他们会在里面加上一些用糯米纸包着的改变口味的食材。为了好看，这些食材从上至下排成了树的模样。在布丁的最底下铺满了 对老师炸弹 。杀老师吃到那里去之后就会引爆。

## 题目描述

终于，同学们把布丁做好了。最爱吃布丁的茅野开始想，这个布丁有多好吃呢？

一个布丁的好吃程度，取决于里面的改变口味的食材。材料不同的话，颜色和美味度也是不一样的。

布丁里面有 $n$ 种调味食材，有 $n-1$ 个东西连接着，第一种食材在最上面，相当于这一棵树的根。

现在，茅野制定一个布丁的好吃程度与指定的某两个值 $u,k$ 有关，这个好吃程度为，第 $u$ 种食材的 $k$ 级祖先 $v$ 食材的所有 $k$ 级儿子与 $v$ 食材颜色相同的那些 $k$ 级儿子的美味度之和。可以发现，$u$ 或者 $k$ 不同，一般情况下美味度是不同的。所以有 $q$ 个问题想要问你。

**特殊地，如果第 $u$ 种食材没有 $k$ 级祖先，直接输出 $0$ 即可。**

## 说明/提示

#### 样例解释 #1
![](https://cdn.luogu.com.cn/upload/image_hosting/ap9imym3.png)

食材 $2$ 的 $1$ 级祖先是食材 $1$，食材 $1$ 的 $1$ 级儿子有食材 $2$ 与食材 $3$，食材 $2$ 与食材 $3$ 的颜色都与食材 $1$ 的颜色相同，所以美味度之和为 $2+3=5$。

------------
#### 数据范围
**本题采用捆绑测试**。

- Subtask 1（30 points），鸡蛋缺乏，布丁不大：$n \leq 10^3$，$q \leq 10^4$。
- Subtask 2（20 points），食材构成了一条链：$n \leq 5 \times 10^5$，$q \leq 10^5$，$color_i \leq 10^2$。     
- Subtask 3（50 points）：数据无特殊限制。 


对于 $100\%$ 的数据，$1 \leq n,q,color_i \leq 5 \times 10^5$，$1 \leq d_i \leq 10^5$。

------------
#### 提示

**第二个子任务中的测试点与第三个子任务中的测试点时限 2S。**

## 样例 #1

### 输入

```
3 1
1 1 1
1 2 3
1 1
2 1
```

### 输出

```
5```

## 样例 #2

### 输入

```
5 3
1 2 2 1 1
1 5 2 4 2
1 1 2 3
3 1
4 2
5 1
```

### 输出

```
0
6
0```

# 题解

## 作者：冷却心 (赞：4)

题解区貌似没有我大 ds 线段树合并的做法，来交一发。

以下记 $d_i$ 表示结点 $i$ 在 **原树** 上的深度。

首先考虑如果颜色只有一种该怎么做，类似 [CF208E Blood Cousins](https://www.luogu.com.cn/problem/CF208E)，首先对询问处理，先跑一个倍增或者长链剖分，把询问挂到 $k$ 级祖先上，然后变成了查询一个点的 $k$ 级儿子权值和。考虑对每个节点维护一个数组 $a_{i,j}$，表示在结点 $i$ 的子树内原树深度为 $j$ 的结点的权值和，那么对于一个询问 $k$，答案就是 $a_{i,d_i+k}$。维护这个数组就是先遍历子节点，子节点搜完之后合并到自己的数组上，最后把自己的权值加上去。然后这个合并可以用动态开点线段树合并实现，时间复杂度 $O(n\log n)$。

然后考虑分开颜色。我们发现不同的颜色之间互不影响，所以我们对每一种颜色建一个虚树，然后和上面一样的方法跑，因为总点数还是 $n$ 不变，所以时间复杂度还是 $O(n\log n)$。

建树的过程就是在 DFS 的过程中维护一个 $l_i$ 表示最近的颜色为 $i$ 的祖先，然后每个点向与他相同颜色的最近祖先连边，然后就建完虚树了。

注意一个细节是这样可能不连通所以要每个颜色建一个虚点，作为最开始的 $l_i$。


```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6 + 10;
int n, Q, col[N], W[N], Ans[N]; bool has[N]; vector<int> G[N];

// Rebuild and initial.
int depth[N], lst[N], fa[22][N]; vector<int> F[N];
void DFS(int u, int f) {
	int tmp = lst[col[u]]; lst[col[u]] = u; fa[0][u] = f; depth[u] = depth[f] + 1;
	if (tmp) F[tmp].emplace_back(u); else F[n + col[u]].emplace_back(u); 
	for (int v : G[u]) { DFS(v, u); } lst[col[u]] = tmp; return ;
}
vector<pair<int, int> > Qry[N];

namespace Sgt {

const int M = 1e7 + 10;
int rt[N], ls[M], rs[M], tot = 0; LL tree[M];
void pushup(int p) { tree[p] = tree[ls[p]] + tree[rs[p]]; }
void update(int &p, int l, int r, int x, int k) {
	if (x > r || x < l) { return ; } if (!p) p = ++ tot;
	if (l == r) { tree[p] += k; return ; } int mid = (l + r) >> 1;
	update(ls[p], l, mid, x, k); update(rs[p], mid + 1, r, x, k); pushup(p); return ;
}
LL query(int p, int l, int r, int x) {
	if (!p || x > r || x < l) { return 0; } if (l == r) return tree[p];
	int mid = (l + r) >> 1; return query(ls[p], l, mid, x) + query(rs[p], mid + 1, r, x); 
}
int merge(int p1, int p2, int l, int r) {
	if (!p1 || !p2) return p1 + p2;
	if (l == r) { tree[p1] += tree[p2]; tree[p2] = 0; return p1; }
	int mid = (l + r) >> 1;
	ls[p1] = merge(ls[p1], ls[p2], l, mid); rs[p1] = merge(rs[p1], rs[p2], mid + 1, r);
	pushup(p1); tree[p2] = ls[p2] = rs[p2] = 0; return p1;
}
}
void DFS2(int u, int f) {
	for (int v : F[u]) {
		DFS2(v, u); Sgt :: rt[u] = Sgt :: merge(Sgt :: rt[u], Sgt :: rt[v], 1, n);
	} if (u <= n) Sgt :: update(Sgt :: rt[u], 1, n, depth[u], W[u]);
	for (auto [v, id] : Qry[u]) 
		Ans[id] = Sgt :: query(Sgt :: rt[u], 1, n, depth[u] + v);
	return ;
}

// Find k-th
int Jump(int x, int k) {
	for (int i = 20; i >= 0; i --) if ((k >> i) & 1) x = fa[i][x];
	return x;
}

int main() {
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> Q;
	for (int i = 1; i <= n; has[col[i]] = 1, i ++) cin >> col[i];
	for (int i = 1; i <= n; i ++) cin >> W[i];
	for (int i = 2, u; i <= n; i ++) {
		cin >> u; G[u].emplace_back(i);
	} DFS(1, 0); int x, y;
	for (int k = 1; k <= 20; k ++) for (int i = 1; i <= n; i ++)
		fa[k][i] = fa[k - 1][fa[k - 1][i]];
	for (int i = 1; i <= Q; i ++) {
		cin >> x >> y; int l = Jump(x, y);
		if (!l) Ans[i] = 0;
		else Qry[l].emplace_back(make_pair(y, i));
	}
	for (int i = 1; i <= 500000; i ++) if (has[i])
		DFS2(n + i, 0);
	for (int i = 1; i <= Q; i ++) cout << Ans[i] << "\n";
	return 0;
}
```

---

## 作者：MvemiY (赞：4)

声明：本题解中，将某节点深度优先遍历到的顺序记为 $\operatorname{dfn}$，将某节点广度优先遍历到的顺序记为 $\operatorname{bfn}$。时间戳就是传统意义上的时间戳，即 $\operatorname{dfn}$。$\operatorname{dfsx}$ 指的是 DFS 序，$\operatorname{bfsx}$ 指的是 BFS 序。

这道题题解里都是 长链剖分、DSU on tree、bfs + 主席树 等 ~~高大上~~ 算法，蒟蒻都不会。后来仔细一想，其实有复杂度较低且简单的方法，于是写下这篇题解。（本人的第一篇蓝题题解

## 题目大意与问题转化

给定一颗有 $n$ 个节点，以 $1$ 号节点为根的树，每个点有权值和颜色。$q$ 次询问，每次询问给定 $u,k$，请你求出，$u$ 的 $k$ 级祖先的 $k$ 级子孙中，与 $u$ 的 $k$ 级祖先颜色相同的节点的权值和。

乍一看特别吓人，但是简化一下题意就会发现，其实 __$u$ 的 $k$ 级祖先的 $k$ 级子孙__ 就是 在 $u$ 的 $k$ 级祖先的子树中与 $u$ 深度相同的节点。

考虑要解决如下几个子问题：

一、如何求任意节点的 $k$ 级祖先。

二、如何求并且表示出任意节点的 $k$ 级子孙。

三、如何求在出一组深度相同的节点中，所有颜色为 $c$ 的节点的权值和。

只要我们解决如上三个子问题，就可以解决这个题目。

## 问题解决

首先看第一个子问题：如何求任意节点的 $k$ 级祖先？

记录 $\operatorname{anc}_{u,i}$ 表示节点 $u$ 的第 $2^i$ 级祖先，递推柿子是 $\operatorname{anc}_{u,i}=\operatorname{anc}_{\operatorname{anc}_{u,i-1},i-1}$，原理其实就是 $2^x+2^x=2^{x+1}$，

得到 $\operatorname{anc}$ 数组以后，我们对 $k$ 进行二进制拆分，是 $1$ 的位置，就让 $u$ 跳到这个 $1$ 代表的值级祖先，最后 $u$ 就是答案。


------------


其次来看第二个子问题：如何求并且表示出任意节点的 $k$ 级子孙。

考虑这个节点的深度应该是多少，假设当前节点的深度为 $d$，要求的 $k$ 子孙深度为 $d+k$。

首先思考 “如何表示出”。我们都知道，在一个子树中，深度相同的节点在这课树的 BFS 序 上是连续的，所以我们可以用数对 $(L,R)$ 表示出在 BFS 序 的第 $L$ 到第 $R$ 项都是所求。

然后想 “如何求”，其实这就是 K-son 问题的模板，这里挑的是最简单的方法 ~~（主要是其他方法也不会）~~。

我们记录 $\operatorname{depv}_i$ 表示深度为 $i$ 的所有节点，（用 `vector` 实现），以什么样的顺序一个一个装填进去是问题。首先我们知道一个节点的子树中的所有节点， 时间戳都是大于这个节点的时间戳的，即满足 $\operatorname{dfn}_v > \operatorname{dfn}_u \ (v \in \mathrm{subtree_u})$，所以我们通过 DFS 序 来得到 $\operatorname{depv}_i$。

我们可以通过二分查找，找到在 $\operatorname{depv}_{d+k}$ 中第一个时间戳大于 $u$ 的时间戳的（其中 $u$ 是子问题中的“任意节点”），这个值所代表的就是 BFS 序 第 $L$ 节点的时间戳。

那么如何求 $R$？我们考虑在 DFS 中，对于任意节点 $u$，如果有子孙且有在自己右边的兄弟，就一定会先遍历子孙再遍历右边的兄弟，记录 $\operatorname{bro}_u$ 为节点右边的兄弟，满足 $\operatorname{bfn}_{\operatorname{bro}_u}=\operatorname{bfn}_u+1$，且一定满足 $\operatorname{dfn}_v < \operatorname{dfn}_{\operatorname{bro}_u} (v \in \mathrm{subtree_u})$。那么我们依旧可以用二分查找在 $\operatorname{depv}_{d+k}$ 中找到最后一个时间戳小于 $\operatorname{bro}_u$ 的时间戳的节点。还有特殊情况：如果节点 $u$ 没有右边的兄弟，说明 $\operatorname{dep}_{d+k}$ 的最后也是它的子孙。

------------
最后看第三个子问题：如何求在出一组深度相同的节点中，所有颜色为 $c$ 的节点的权值和。

看到字眼 _深度相同_，我们应该想到 BFS 序。

最简单的想法是前缀和，记 $\operatorname{sum}_{c,i}$ 表示颜色为 $c$，BFS 序 中 前 $i$ 个节点的和。当 $i$ 号节点颜色为 $c$，$\operatorname{sum}_{c,i} \gets \operatorname{sum}_{c,i-1}+ \operatorname{val}_{\operatorname{bfsx_i}}$，否则 $\operatorname{sum_{c,i}} \gets \operatorname{sum}_{u,i}$。空间复杂度和时间复杂度都是 $O(n^2)$，明显撑不住。

我们会发现，数组 $\operatorname{sum}$ 里有很多浪费的空间，也就是说，当颜色越多，每个颜色的点越少，浪费的空间越多。

重新定义 $\operatorname{sum}_{c,i}$ 表示颜色为 $c$ 的，到 $\operatorname{bfn}$ 第 $i+1$ 大的节点的权值和，在 BFS 的过程中得到。

即：

```cpp
struct Node{
// ind 为 bfn
    ll val, ind;
    // 对结构体使用二分要写重载运算符 
    bool operator < (const Node x) const {return ind < x.ind ;}
    bool operator ==(const Node x) const {return ind == x.ind;}
};
// 以下是在 BFS 中实现
if(sum[clo[u]].size())
	sum[clo[u]].push_back((Node){sum[clo[u]][sum[clo[u]].size()-1].val + a[u], bfn[u]});
else sum[clo[u]].push_back((Node){a[u], bfn[u]});
```
查询时，得到 $k$ 级祖先的颜色，记为 $sclo$，在 $\operatorname{sum}_{sclo}$ 中，二分找到在 $[L,R]$ 区间中，用数对 $(l,r)$ 表示。也就是说，$l$ 的值为 $\operatorname{sum}_{sclo}$ 中第一个元素 $ind$ 大于等于 $L$ 的下标，$r$ 的值为 $\operatorname{sum}_{sclo}$ 中最后一个元素 $ind$ 小于等于 $R$ 的下标。

对 $(l,r)$ 的索求同样使用二分查找实现。

那么，最后的答案就是 $\operatorname{sum}_{sclo,r} - \operatorname{sum}_{sclo,l-1}$。

## 无解情况

询问时，当 $u$ 的深度小于等于 $k$，说明没有 $k$ 级祖先，输出 $0$。

询问后 $r=-1$，如果连 $\operatorname{sum}_{sclo,0}$ 都比 $R$ 大，就说明要求的区间根本不存在了，输出 $0$。

询问后 $\operatorname{sum}_{sclo,r}$ 的元素 $ind$ 小于 $L$ 或 $\operatorname{sum}_{sclo,l}$ 的元素 $ind$ 大于 $R$，说明寻找的区间不在 $[L,R]$ 中，输出 $0$。



------------


## 时空复杂度

时间复杂度：DFS、BFS 时间复杂度 $O(n)$，求 $\operatorname
{anc}$ 时间复杂度 $O(n\log n)$，询问求 $k$ 级祖先和 $4$ 个二分查找，时间复杂度为 $O(q\log n)$。总体时间复杂度为 $O((n+q)\log n)$。

空间复杂度：除了 $anc$ 以为都是 $O(n)$，$anc$ 为 $O(n\log n)$，总体空间复杂度为 $O(n\log n)$。

因为 `vector` 和二分查找，STL 常数较大，不开 O2 得卡几次洛谷波动，开了 O2 直接在最优解第一页。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 5e5 + 5;
typedef long long ll;
ll n, a[MAXN], clo[MAXN], fa[MAXN], anc[MAXN][25], bfn[MAXN], dfn[MAXN], dep[MAXN], bfsx[MAXN], dfsx[MAXN], tot, bro[MAXN]; 
bool have_already_added[MAXN];
struct Node{
    ll val, ind;
    // 对结构体使用二分要写重载运算符 
    bool operator < (const Node x) const {return ind < x.ind ;}
    bool operator ==(const Node x) const {return ind == x.ind;}
};
vector <Node> sum[MAXN];
vector <int> tr[MAXN], depv[MAXN];
void init(){
    for(int j = 1; j <= log2(n); j++)
        for(int i = 1; i <= n; i++)
            anc[i][j] = anc[anc[i][j-1]][j-1];
}
void DFS(int u){
    dfsx[++tot] = u;
    dfn[u] = tot;
    dep[u] = dep[fa[u]] + 1;
   	depv[dep[u]].push_back(dfn[u]);
    int len = tr[u].size();
    for(int i = 0; i < len; i++){
        int v = tr[u][i];
        DFS(v); 
    }
}
void BFS(){
    queue <int> q;
    q.push(1);
    tot = 0;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        bfn[u] = ++tot;
        bfsx[tot] = u;
        if(sum[clo[u]].size())
            sum[clo[u]].push_back((Node){sum[clo[u]][sum[clo[u]].size()-1].val + a[u], bfn[u]});
        else sum[clo[u]].push_back((Node){a[u], bfn[u]});
        int len = tr[u].size();
        for(int i = 0; i < len; i++){
            int v = tr[u][i];
            q.push(v);
        }
    }
}
int lbt(int x){
    return x & -x;
}
int find(int u, int k){
    while(k){
        u = anc[u][(int)log2(lbt(k))];
        k -= lbt(k);
    }
    return u;
}
bool check(int u, int v){
	while(~v){
		if(v == u)
			return 1;
		v =fa[v];
	}
	return 0;
}
pair <int,int> K_son(int u, int k){
	ll ndp = dep[u] + k, l = 1145141919, r = -1;
	int len = depv[ndp].size();
	// 见子问题 2 
	l = *upper_bound(depv[ndp].begin(), depv[ndp].end(), dfn[u]);
	if(bro[u]){
		if(depv[ndp].size() == 1)
			r = l;
		else r = *(lower_bound(depv[ndp].begin(), depv[ndp].end(), dfn[bro[u]]) - 1);
	}
	else r = depv[ndp][len-1];
	return (pair<int,int>){l, r}; 
}
int main(){
    int q;
    scanf("%lld%lld", &n, &q);
    for(int i = 1; i <= n; i++)
        scanf("%lld", clo+i);
    for(int i = 1; i <= n; i++)
        scanf("%lld", a+i);
    dep[1] = 1;
    for(int i = 2; i <= n; i++){
        cin >> fa[i];
        anc[i][0] = fa[i];
        tr[fa[i]].push_back(i);
    }
    init();
    DFS(1);
    BFS();
    // 根据定义求出 bro[u] 
    for(int i = 1; i < n; i++){
    	int u = bfsx[i], v = bfsx[i+1];
    	if(dep[u] == dep[v])
    		bro[u] = v;
	}
    while(q--){
        int u, k;
        scanf("%d%d", &u, &k);
        if(dep[u] < k)
        	printf("0\n");
        else if(k == 0)
			printf("%lld\n", a[u]); 
        else {
            int ak = find(u, k);
            int sclo = clo[ak];
            pair <int,int> tmp = K_son(ak, k);
            int Lv = tmp.first, Rv = tmp.second;
			int L = bfn[dfsx[tmp.first]], R = bfn[dfsx[tmp.second]];
            int l = lower_bound(sum[sclo].begin(), sum[sclo].end(), (Node){-1, L}) - sum[sclo].begin();
            int r = upper_bound(sum[sclo].begin(), sum[sclo].end(), (Node){-1, R}) - sum[sclo].begin() - 1; 
            if(r == -1) // 也就是说 sum[sclo][0] 都比 R 大，要求的区间根本不存在了 
        		printf("0\n");
            else if(sum[sclo][r].ind < L || sum[sclo][l].ind > R) // 不存在颜色为 sclo 的 k 级子孙 
        		printf("0\n");
            else 	
                printf("%lld\n", max(0ll, sum[sclo][r].val - (l > 0 ? sum[sclo][l-1].val : 0)));
        }
    }
    return 0;
}
```

---

## 作者：Pbri (赞：3)

理论上是可以达到$nlogn$的

但是我的长链剖分跑的。。。。

$nlogn$的长链剖分跑的还没$nlog^2n$的倍增跑的快

$nlog^2n$的倍增能过$nlogn$的长链剖分做法过不了

如果能有哪位大佬比较闲拜托给蒟蒻卡卡常

但长链剖分开了$O2$跑的飞快(比倍增快

初步估计是$vector$的问题

来说做法

可以考虑$bfs$序

这样每一层在$bfs$序中就是一个区间

因为我们是按照一个顺序来遍历的

因此每一层的节点在$bfs$序中是单调的

所以他们的$k$级祖先也是单调的

由此我们可以通过二分

找到（在第$i$层中$k$级祖先是$u$）的区间的左右端点

（加个括号防止有歧义）

找到了然后呢？

我们可以每个颜色都开一个前缀和

当然由于过大我们需要$vector$

然后我们存一下每个$vector$里每个元素的标号

（所以还需要一个$vector$）

然后我们可以二分找到左右端点在$vector$里的位置

然后我们就可以统计某个区间里颜色是$c$的节点的权值之和

由于倍增找$k$级祖先是$logn$的

二分也是$logn$的

所以总体时间复杂度是$nlog^2n$的

当然可以通过长链剖分优化到$nlogn$

但正如我开头所说我写的常数较大不吸氧过不了

code（倍增）：
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#define FUP(i,x,y) for(int i=(x);i<=(y);i++)
#define FDW(i,x,y) for(int i=(x);i>=(y);i--)
#define MAXN 500010
#define INF 0x7fffffff
#define MOD 1000000007
#define ll long long
#define db double
using namespace std;
int read(){
    int w=0,flg=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')flg=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){w=w*10-'0'+ch,ch=getchar();}
    return w*flg;
}
//edge
int head[MAXN],ednum;
struct edge{
	int nxt,to;
}ed[MAXN];
void add_Edge(int u,int v)
{
	ednum++;
	ed[ednum].nxt=head[u],ed[ednum].to=v;
	head[u]=ednum;
}
//readin
int n,q,col[MAXN],d[MAXN],dad,pos,lev;
//k
int lg[MAXN],bg[MAXN];
//node
int num[MAXN],dep[MAXN],fa[MAXN][21];
//bfs
int bfscnt,re[MAXN],que[MAXN],front,tail;
void bfs()
{
	que[0]=1,dep[1]=1;
	while(front<=tail)
	{
		int u=que[front++];
		re[++bfscnt]=u,num[u]=bfscnt;
		if(bg[dep[u]]==0)
		{
			bg[dep[u]]=bfscnt;
		}
		for(int i=head[u];i;i=ed[i].nxt)
		{
			dep[ed[i].to]=dep[u]+1;
			que[++tail]=ed[i].to;
		}
	}
}
//dfs
void dfs(int u)
{
	for(int i=1;(1<<i)<dep[u];i++)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(int i=head[u];i;i=ed[i].nxt)
	{
		dfs(ed[i].to);
	}
}
//prep
vector<int>vc[MAXN],id[MAXN];
void init()
{
	n=read(),q=read();
	FUP(i,1,n)
	{
		vc[i].push_back(0),id[i].push_back(0);
		lg[i]=lg[i-1]+(1<<lg[i-1]==i),lg[i-1]--;
		col[i]=read();
	}
	lg[n]--;
	FUP(i,1,n)
	{
		d[i]=read();
	}
	FUP(i,2,n)
	{
		dad=read(),add_Edge(dad,i),fa[i][0]=dad;
	}
	bfs();
	dfs(1);
	FUP(i,1,n)
	{
		int c=col[re[i]];
		if(vc[c].size()==0)
		{
			vc[c].push_back(d[re[i]]);
		}
		else
		{
			int lst=vc[c][vc[c].size()-1];
			vc[c].push_back(lst+d[re[i]]);
		}
		id[c].push_back(i);
	}
}
//query
int query_k(int u,int k)
{
	int tmp=0;
	FDW(i,lg[k],0)
	{
		if(tmp+(1<<i)<=k)
		{
			tmp+=(1<<i);
			u=fa[u][i];
		}
	}
	return u;
}
int query_side(int u,int k,int opt)
{
	int l=bg[dep[u]+k],r=bg[dep[u]+k+1]-1,ret;
	if(r<0)
	{
		r=n;
	}
	while(l<=r)
	{
		int mid=(l+r)>>1,kfa=query_k(re[mid],k);
		if(num[kfa]<num[u])
		{
			l=mid+1;
		}
		if(num[kfa]>num[u])
		{
			r=mid-1;
		}
		if(num[kfa]==num[u])
		{
			ret=mid;
			if(opt==0)
			{
				r=mid-1;
			}
			else
			{
				l=mid+1;
			}
		}
	}
	return ret;
}
int midck(int x,int c)
{
	int ret,l=0,r=vc[c].size()-1;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(id[c][mid]<=x)
		{
			ret=mid,l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	return ret;
}
int query_col(int ql,int qr,int c)
{
	ql--;
	int rl=midck(ql,c),rr=midck(qr,c);
	//printf("%d,",c);
	//printf("%d,%d,%d\n",rl,rr,vc[c].size());
	//puts("1111");
	return vc[c][rr]-vc[c][rl];
}
int query(int pos,int lev)
{
	pos=query_k(pos,lev);
	if(pos==0)
	{
		return 0;
	}
	int l=query_side(pos,lev,0),r=query_side(pos,lev,1);
	//printf("%d,%d\n",l,r);
	return query_col(l,r,col[pos]);
}
//solve
void solve()
{
	FUP(i,1,q)
	{
		pos=read(),lev=read();
		printf("%d\n",query(pos,lev));
	}
}
int main(){
	//freopen("data.in","r",stdin);
	//freopen("zj.out","w",stdout);
	init();
	solve();
    return 0;
}
```

code（长链剖分）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#define FUP(i,x,y) for(rg i=(x);i<=(y);i++)
#define FDW(i,x,y) for(rg i=(x);i>=(y);i--)
#define MAXN 500010
#define INF 0x7fffffff
#define MOD 1000000007
#define ll long long
#define db double
#define rg register int
using namespace std;
inline int read(){
    int w=0,flg=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')flg=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){w=w*10-'0'+ch,ch=getchar();}
    return w*flg;
}
//edge
int head[MAXN],ednum;
struct edge{
	int nxt,to;
}ed[MAXN];
inline void add_Edge(int u,int v)
{
	ednum++;
	ed[ednum].nxt=head[u],ed[ednum].to=v;
	head[u]=ednum;
}
//readin
int n,q,col[MAXN],d[MAXN],dad,pos,lev;
//k
int lg[MAXN],bg[MAXN];
//node
int num[MAXN],dep[MAXN],fa[MAXN][21];
//bfs
int bfscnt,re[MAXN],que[MAXN],front,tail;
inline void bfs()
{
	que[0]=1,dep[1]=1;
	while(front<=tail)
	{
		rg u=que[front++];
		re[++bfscnt]=u,num[u]=bfscnt;
		if(bg[dep[u]]==0)
		{
			bg[dep[u]]=bfscnt;
		}
		for(rg i=head[u];i;i=ed[i].nxt)
		{
			dep[ed[i].to]=dep[u]+1;
			que[++tail]=ed[i].to;
		}
	}
}
//dfs
int son[MAXN],len[MAXN],top[MAXN];
inline void dfs(int u)
{
	for(rg i=1;(1<<i)<dep[u];i++)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(rg i=head[u];i;i=ed[i].nxt)
	{
		dfs(ed[i].to);
		if(len[ed[i].to]>len[son[u]])
		{
			son[u]=ed[i].to;
		}
	}
	len[u]=len[son[u]]+1;
}
inline void dfs2(int u,int topf)
{
	top[u]=topf;
	if(son[u])
	{
		dfs2(son[u],topf);
	}
	for(rg i=head[u];i;i=ed[i].nxt)
	{
		if(ed[i].to!=son[u])
		{
			dfs2(ed[i].to,ed[i].to);
		}
	}
}
//prep
vector<int>vc[MAXN],id[MAXN],up[MAXN],down[MAXN];
inline void init()
{
	n=read(),q=read();
	FUP(i,1,n)
	{
		vc[i].push_back(0),id[i].push_back(0);
		lg[i]=lg[i-1]+(1<<lg[i-1]==i),lg[i-1]--;
		col[i]=read();
	}
	lg[n]--;
	FUP(i,1,n)
	{
		d[i]=read();
	}
	FUP(i,2,n)
	{
		dad=read(),add_Edge(dad,i),fa[i][0]=dad;
	}
	bfs();
	dfs(1);
	dfs2(1,1);
	FUP(i,1,n)
	{
		rg c=col[re[i]];
		if(vc[c].size()==0)
		{
			vc[c].push_back(d[re[i]]);
		}
		else
		{
			rg lst=vc[c][vc[c].size()-1];
			vc[c].push_back(lst+d[re[i]]);
		}
		if(top[i]==i)
		{
			rg tmp=i;
			FUP(j,1,len[i]+1)
			{
				down[i].push_back(tmp);
				tmp=son[tmp];
			}
			tmp=i;
			FUP(j,1,len[i]+1)
			{
				up[i].push_back(tmp);
				tmp=fa[tmp][0];
			}
		}
		id[c].push_back(i);
	}
}
//query
inline int query_k(int u,int k)
{
	if(k==0)
	{
		return u;
	}
	if(dep[u]<=k)
	{
		return 0;
	}
	u=fa[u][lg[k]];
	k^=(1<<lg[k]);
	if(dep[u]-dep[top[u]]>=k)
	{
		return down[top[u]][dep[u]-dep[top[u]]-k];
	}
	return up[top[u]][k-(dep[u]-dep[top[u]])];
}
inline int query_side(int u,rg k,int opt)
{
	int l=bg[dep[u]+k],r=bg[dep[u]+k+1]-1,ret;
	if(r<0)
	{
		r=n;
	}
	while(l<=r)
	{
		int mid=(l+r)>>1,kfa=query_k(re[mid],k);
		if(num[kfa]<num[u])
		{
			l=mid+1;
		}
		if(num[kfa]>num[u])
		{
			r=mid-1;
		}
		if(num[kfa]==num[u])
		{
			ret=mid;
			if(opt==0)
			{
				r=mid-1;
			}
			else
			{
				l=mid+1;
			}
		}
	}
	return ret;
}
inline int midck(int x,int c)
{
	int ret,l=0,r=vc[c].size()-1;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(id[c][mid]<=x)
		{
			ret=mid,l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	return ret;
}
inline int query_col(int ql,int qr,int c)
{
	ql--;
	rg rl=midck(ql,c),rr=midck(qr,c);
	//prrgf("%d,",c);
	//prrgf("%d,%d,%d\n",rl,rr,vc[c].size());
	//puts("1111");
	return vc[c][rr]-vc[c][rl];
}
inline int query(int pos,int lev)
{
	pos=query_k(pos,lev);
	if(pos==0)
	{
		return 0;
	}
	int l=query_side(pos,lev,0),r=query_side(pos,lev,1);
	//prrgf("%d,%d\n",l,r);
	return query_col(l,r,col[pos]);
}
//solve
inline void solve()
{
	FUP(i,1,q)
	{
		pos=read(),lev=read();
		printf("%d\n",query(pos,lev));
	}
}
int main(){
	//freopen("data.in","r",stdin);
	//freopen("zj.out","w",stdout);
	init();
	solve();
    return 0;
}
```
如果有神犇无聊拜托帮我卡卡常或手写一个$vector$谢谢了！

---

## 作者：wizardMarshall (赞：1)

## 题意

一个节点有两个值 $color$ 和 $d$，多组询问求某个节点中 $color$ 和自己相同的 $k$ 级儿子所有 $d$ 的和。

## 思路

首先显然倍增求出这个祖先节点，设为 $head$。

一般题目中我们使用 dfn 序来解决子树求和类问题，但这道题相当于是求某一层中的连续节点的和，因此考虑 bfn 序。

在 bfn 序中，题目询问的这些节点构成了一段连续区间，因此将树上问题转换到了序列上问题。

分成两个阶段来做：一个是求相应区间，一个是区间相同颜色求和。

### Part 1

可以使用倍增和二分的思路。在 bfn 的序列上二分，用当前 $mid$ 的 $k$ 级祖先**的 bfn 序**和我们之前求出来的 $head$ **的 bfn 序**作比较。小了就往后二分，大了往前。读者可以想一想为什么不直接二分节点。

二分出来左右边界，设为 $[L,R]$。

### Part 2

求区间 $[L,R]$ 中颜色 $color_u=color_{head}$ 的所有 $d_u$ 的和。

如果对于每个 $color$ 的取值都开一棵线段树来做，显然爆炸。但其中加入的点不超过 $n$ 个（每个点只有一个 $color$），也就是总线段树节点不超过 $n \log n$ 个。所以可用动态开点线段树来做。

----

码完之后有一个 20pts 的特殊性质可能会超时，但由于是一条链的情况，因此只有 $u$ 自身一个 $k$ 级儿子，特判掉即可。复杂度瓶颈在第一部分的二分加倍增，为 $O(n \log ^2 n)$。

为方便，代码中规定 $color=x$ 的线段树根节点就是 $x$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 500005;
int a[500005];
int b[500005];
int st[500005][21];
vector <int> edge[500005];
int bfn[500005], id[500005];

struct node{
	int l, r;
	int ls, rs;
	int sum;
}tree[N << 4];//大小可过（
int E;
void change(int x, int id, int c) {
	if (tree[x].l == tree[x].r) {
		tree[x].sum += c;
		return;
	}
	int m = (tree[x].l + tree[x].r) / 2;
	if (id <= m) {
		if (!tree[x].ls) {//动态开点，下同
			tree[++E] = (node){tree[x].l, m, 0, 0, 0};
			tree[x].ls = E;
		}
		change(tree[x].ls, id, c);
	}else {
		if (!tree[x].rs) {
			tree[++E] = (node){m + 1, tree[x].r, 0, 0, 0};
			tree[x].rs = E;	
		}
		change(tree[x].rs, id, c);
	}
	tree[x].sum = tree[tree[x].ls].sum + tree[tree[x].rs].sum;
	return;
}
int ask(int x, int L, int R) {
	if (L <= tree[x].l && tree[x].r <= R) {
		return tree[x].sum;
	}
	int m = (tree[x].l + tree[x].r) / 2;
	int res = 0;
	if (L <= m) {
		if (tree[x].ls) {
			res += ask(tree[x].ls, L, R);
		}
	}
	if (R > m) {
		if (tree[x].rs) {
			res += ask(tree[x].rs, L, R);
		}
	}
	return res;
}
int jump(int x, int k) {//倍增找到x的k级祖先
	for (int j = 20; j >= 0; j--) {
		if (k & (1 << j)) {
			x = st[x][j];
		}
	}return x;
}
int read() {
	char s = getchar();
	while (s < '0' || s > '9') {
		s = getchar();
	}
	int sum = 0;
	while (s >= '0' &&s <= '9') {
		sum = (sum << 3) + (sum << 1) + s - '0';
		s = getchar();
	}
	return sum;
}
signed main() {
	
	int n, m;
	cin >> n >> m;
	int mxc = 0;
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		mxc = max(mxc, a[i]);
	}E = mxc;
	for (int i = 1; i <= mxc; i++) {
		tree[i] = (node){1, n, 0, 0, 0};
	}
	for (int i = 1; i <= n; i++) {
		b[i] = read();
	}
	int flag = 1;
	for (int i = 2; i <= n; i++) {
		int fa = read();
		st[i][0] = fa;
		edge[fa].push_back(i);
		if (edge[fa].size() > 1) {//有一个节点超过2个儿子，不是一个链，是普通情况
			flag = 0;
		}
	}
	for (int j = 1; j <= 20; j++) {
		for (int i = 1; i <= n; i++) {
			st[i][j] = st[st[i][j - 1]][j - 1]; 
		}
	}
	
	queue <pair <int, int> > q;
	q.push({1, 1});
	int dfff = 0;
	while (!q.empty()) {
		pair <int, int> f = q.front();q.pop();
		bfn[f.second] = ++dfff;
		id[dfff] = f.second;
		change(a[f.second], bfn[f.second], b[f.second]);//f这个节点的颜色是a[f.second]
		for (auto i : edge[f.second]) {
			q.push({f.first + 1, i});
		}
	}
	while (m--) {
		int x = read(), k = read();
		int gen = jump(x, k);
		if (flag) {//特判掉子任务2
			if (a[gen] == a[x]) {
				printf("%d\n", b[x]);
			}else printf("0\n");
			continue;
		}
		int l = 1, r = n, L = 1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (bfn[jump(id[mid], k)] >= bfn[gen]) {
				r = mid - 1;
				L = mid;
			}else {
				l = mid + 1;
			}
		}
		l = 1, r = n;
		int R = 1;
		while (l <= r) {//二分的是dfn序，jump函数要用的是原来的节点编号，因此id[i]记录的为bfn为i的节点是哪个
			int mid = (l + r) >> 1;
			if (bfn[jump(id[mid], k)] <= bfn[gen]) {
				l = mid + 1;
				R = mid;
			}else {
				r = mid - 1;
			}
		}
		printf("%d\n", ask(a[gen], L, R));//最后[L,R]查询颜色为a[gen]的b总和
	}
	return 0;
}
```

---

## 作者：CaoXian (赞：1)

第100道蓝题是学长出的题欸。

---

可持久化线段树做法。

题目要求的其实是：在某一棵子树的同一深度中，$k$ 级祖先都相同，并且颜色和 $k$ 级祖先相同的结点的权值和。

我们依次来考虑这些条件。

首先是深度相同，最直接的想法是将深度相同的结点都放在一起，比如以深度为优先级对这些结点排序。

但是这样做的话会发现第二个条件就不容易处理了，不能这么直接简单粗暴地把深度相同的结点放在一起。

发现上面这种做法不可取的原因是同一棵子树中的结点排完序后可能不连续，其实只需要找到一种做法使得**所有深度相同的结点是连续的并且在同一棵子树中的结点也是连续的**，而广度优先搜索得到的搜索序正好符合这个条件。

于是我们先对这棵树 bfs 一下，得到结点的 bfs 序，并且 $k$ **级祖先相同的结点在 bfs 序中是连续的一段**。

那怎么知道在这个序列中，$k$ 级祖先相同的一段区间的左端点和右端点呢？只需要分别二分出这个左端点和右端点即可。具体地，记录深度相同的结点在序列中的最左端和最右端，分别记为 $lt_{dep}$ 和 $rt_{dep}$，二分左端点的时候初始区间为 $[lt_{dep}, bfn_{now}]$，二分右端点的初始区间为 $[bfn_{now}, rt_{dep}]$，这里的 $now$ 表示待询问结点，$bfn$ 表示 bfs 序。

接下来就是最后一个问题了，求出在这一段中，颜色和 $k$ 级祖先相同的结点的权值和。

先把这个“颜色和 $k$ 级祖先相同”去掉，问题变成“区间查询和给定颜色相同的元素的权值和”。

如果只有一个询问的话可以开一个桶，从左端点开始遍历，过程中把遍历到的元素的权值加到它的颜色对应的桶里，知道遍历完这个区间。输出答案直接查询桶里的权值和即可。

变化到多组的话可以把桶变成前缀和，区间相减得到答案。但是这样的时空复杂度不能通过，用[可持久化数组](https://www.luogu.com.cn/problem/P3919)来维护即可，本质上就是可持久化线段树。

查询的时候判一下待查询结点有没有 $k$ 级祖先，检查深度即可。注意答案的范围是 $\sum\limits_{i = 1}^{n}d_{i} \leqslant 5 \times 10^{10}$，需要开 `long long`。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, q, f, u, k, l, r, mid, posl, posr, father, color[500005], d[500005], dep[500005], lg[500005], bfn[500005], rnk[500005], lt[500005], rt[500005], fa[500005][20];
queue<int> qu;
vector<int> g[500005];
struct Segment_Tree {
	int idx, root[500005], lc[10000005], rc[10000005];
	ll sum[10000005];
	#define mid ((l + r) >> 1)
	int new_node(int k = 0) {
		++idx;
		lc[idx] = lc[k], rc[idx] = rc[k], sum[idx] = sum[k];
		return idx;
	}
	int change(int k, const int& pos, const int& v, int l = 1, int r = 500000) {
		int rt = new_node(k);
		if(l == r) {
			sum[rt] += v;
			return rt;
		}
		if(pos <= mid) lc[rt] = change(lc[rt], pos, v, l, mid);
		else rc[rt] = change(rc[rt], pos, v, mid + 1, r);
		return rt;
	}
	ll ask(int kl, int kr, const int& pos, int l = 1, int r = 500000) {
		// cerr << pos << " " << l << " " << r << " " << sum[kl] << " " << sum[kr] << '\n';
		if(l == r) return sum[kr] - sum[kl];
		if(pos <= mid) return ask(lc[kl], lc[kr], pos, l, mid);
		else return ask(rc[kl], rc[kr], pos, mid + 1, r);
	}
	#undef mid
} tree;
int get(int x, int y) {
	while(y) {
		x = fa[x][lg[y]];
		y ^= (1 << lg[y]);
	}
	return x;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> q;
	for(int i = 1; i <= n; ++i) cin >> color[i];
	for(int i = 1; i <= n; ++i) cin >> d[i];
	for(int i = 2; i <= n; ++i) {
		cin >> f;
		g[f].push_back(i);
		lg[i] = lg[i >> 1] + 1;
	}
	memset(lt, 0x3f, sizeof(lt));
	qu.push(1);
	dep[1] = 1;
	for(int i = 1; i <= n; ++i) {
		u = qu.front();
		qu.pop();
		bfn[u] = i;
		rnk[i] = u;
		lt[dep[u]] = min(lt[dep[u]], i);
		rt[dep[u]] = max(rt[dep[u]], i);
		for(int j = 1; j <= lg[n]; ++j) fa[u][j] = fa[fa[u][j - 1]][j - 1];
		for(const auto& j : g[u]) {
			dep[j] = dep[u] + 1;
			fa[j][0] = u;
			qu.push(j);
		}
	}
	for(int i = 1; i <= n; ++i) {
		// cerr << rnk[i] << ": " << color[rnk[i]] << " " << d[rnk[i]] << '\n';
		tree.root[i] = tree.change(tree.root[i - 1], color[rnk[i]], d[rnk[i]]);
	}
	while(q--) {
		cin >> u >> k;
		if(dep[u] <= k) {
			cout << "0\n";
			continue;
		}
		father = get(u, k);
		l = lt[dep[u]], r = posl = bfn[u];
		while(l <= r) mid = (l + r) >> 1, (get(rnk[mid], k) == father) ? (posl = mid, r = mid - 1) : (l = mid + 1);
		l = posr = bfn[u], r = rt[dep[u]];
		while(l <= r) mid = (l + r) >> 1, (get(rnk[mid], k) == father) ? (posr = mid, l = mid + 1) : (r = mid - 1);
		// cerr << posl << " - " << posr << '\n';
		cout << tree.ask(tree.root[posl - 1], tree.root[posr], color[father]) << '\n';
	}
	return 0;
}
```

---

## 作者：comcopy (赞：0)

最开始，我们给出一种很好卡但是出题人并没想到卡的写法。

还是树上启发式合并，只不过我们在记录重儿子的时候强制令重儿子的颜色是与当前颜色相同的，然后使用一个桶记录一个深度下颜色与当前根颜色相同的权值和。

~~但是在链的部分挂了三个点，这个时候我们可以选择切部分分。~~

显然在纯随机大数据下可以玄学出正解复杂度的。但是如果交替染色就会变成 $O(n^2)$ 的暴力复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool _u(char x){return x>='0'&&x<='9';}
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!_u(ch);ch=='-'&&(f=-1),ch=getchar());
	for(;_u(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
	return x*f;
}
inline void write(int num,bool flag=0){
	static int st[39],tp=0;
	num<0&&(putchar('-'),num=-num);
	do st[++tp]=num%10;while(num/=10);
	while(tp) putchar(st[tp--]|48);
	putchar(flag?'\n':' ');
	return;
}
const int N=5e5+10;
int fy[N][20];
int a[N],d[N];
vector<int>e[N];
int hev[N],sz[N],dep[N];
inline int dfs(int u){
	dep[u]=dep[fy[u][0]]+1;
	sz[u]=1,hev[u]=0;
	for(int i=1;i<20;++i)
		fy[u][i]=fy[fy[u][i-1]][i-1];
	for(int v:e[u]){
		if(v!=fy[u][0]){
			sz[u]+=dfs(v);
			if(a[v]==a[u])
				hev[u]=(!hev[u]||sz[v]>sz[hev[u]]?v:hev[u]);
		}
	}
	return sz[u];
}
vector<pair<int,int> >fyn[N];
int cnt[N];
bool vis[N];

inline void calc(int u,int col,int val){
	cnt[dep[u]]+=val*d[u]*(col==a[u]);
	for(int to:e[u])
		if(!vis[to]&&to!=fy[u][0]) calc(to,col,val);
	return;
}
int ans[N];
inline void slove(int u,int f,bool flag){
	for(int v:e[u])
		v!=f&&v!=hev[u]&&(slove(v,u,0),1);
	if(hev[u]) slove(hev[u],u,1),vis[hev[u]]=true;
	calc(u,a[u],1);
	for(pair<int,int>i:fyn[u])
		ans[i.first]=cnt[i.second];
	vis[hev[u]]=false;
	if(!flag) calc(u,a[u],-1);
} 

inline int query(int u,int k){
	for(int i=19;~i;--i)
		if(k>=(1<<i)) u=fy[u][i],k-=(1<<i);
	if(k) return 0;
	return u;
}
int in[N];
bool flag=0;
int n,q;
signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)d[i]=read();
	for(int i=2;i<=n;++i) e[fy[i][0]=read()].push_back(i),flag|=in[fy[i][0]]++;
	dfs(1);
	if(!flag){
		for(int i=1,u,k;i<=q;++i)
			u=read(),k=query(u,read()),
			write(d[u]*(a[u]==a[k])*(k!=0),1);
	}else{
		for(int i=1,u;i<=q;++i)
			u=read(),fyn[query(u,read())].emplace_back(i,dep[u]);
		slove(1,0,1);
		for(int i=1;i<=q;++i) 
			write(ans[i],1);
	}
	return(0.0);
}


```


考虑一种优化的方法。

我们在倍增预处理同时对颜色个数进行前缀，记录下深度以后对树进行重构。

由于一个颜色与当前点不同的结点是没有贡献的，我们直接找到第一个与当前颜色相同的祖先结点并连边。

再跑启发式合并似乎并没有什么意义，因为还是会在链上挂两个点。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool _u(char x){return x>='0'&&x<='9';}
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!_u(ch);ch=='-'&&(f=-1),ch=getchar());
	for(;_u(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
	return x*f;
}
inline void write(int num,bool flag=0){
	static int st[39],tp=0;
	num<0&&(putchar('-'),num=-num);
	do st[++tp]=num%10;while(num/=10);
	while(tp) putchar(st[tp--]|48);
	putchar(flag?'\n':' ');
	return;
}
const int N=5e5+10;

vector<pair<int,int> >fyn[N];
int a[N],d[N],dep[N],fa[N];
namespace init{
	int fy[N][20];
	vector<int>e[N];
	int hev[N],sz[N],lst[N];
	inline int dfs(int u){
		dep[u]=dep[fy[u][0]]+1;
		sz[u]=1,hev[u]=0;
		for(int i=1;i<20;++i) fy[u][i]=fy[fy[u][i-1]][i-1];
		fa[u]=lst[a[u]],lst[a[u]]=u;
		for(int v:e[u])
			if(v!=fy[u][0])
				dfs(v);
		lst[a[u]]=fa[u];
		return sz[u];
	}
	inline int query(int u,int k){
		for(int i=19;~i;--i)
			if(k>=(1<<i)) u=fy[u][i],k-=(1<<i);
		if(k) return 0;
		return u;
	}
	
}
int ans[N];
namespace fyyn{
	int cnt[N];
	bool vis[N],vvis[N];
	vector<int>e[N];
	int hev[N],sz[N];
	int mx[N];
	inline int dfs(int u){
		hev[u]=0,sz[u]=1;
		for(int to:e[u])
			to!=fa[u]&&(sz[u]+=sz[to],hev[u]=(!hev[u]||(sz[to]>sz[hev[u]]?to:hev[u])));
		return sz[u];
	}
	inline void calc(int u,int col,int mxdep,int val){
		if(dep[u]>mxdep) return;
		cnt[dep[u]]+=val*d[u]*(col==a[u]);
		for(int to:e[u])
			if(!vis[to]&&to!=fa[u]) calc(to,col,mxdep,val);
		return;
	}
	inline void slove(int u,int f,bool flag){
		vvis[u]=true;
		for(int v:e[u])
			v!=f&&v!=hev[u]&&(slove(v,u,0),1);
		if(hev[u]) vis[hev[u]]=true,slove(hev[u],u,1);
		calc(u,a[u],mx[u],1);
		for(pair<int,int>i:fyn[u])
			ans[i.first]=cnt[i.second];
		vis[hev[u]]=false;
		if(!flag) calc(u,a[u],mx[u],-1);
	}
}
int n,q;
signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)d[i]=read();
	for(int i=2;i<=n;++i) init::e[init::fy[i][0]=read()].push_back(i);
	init::dfs(1);
	for(int i=1;i<=n;++i) fyyn::e[fa[i]].push_back(i);
	for(int i=1,u,k;i<=q;++i)
		u=read(),fyn[k=init::query(u,read())].emplace_back(i,dep[u]),fyyn::mx[k]=max(fyyn::mx[k],dep[u]);
	fyyn::slove(0,0,1);
	for(int i=1;i<=q;++i) write(ans[i],1);
	return(0.0);
}
```


可以保证重构树上的所有结点的颜色相同，我们直接在重构树上跑一个以原树深度为下标线段树合并，可以证明最高复杂度是 $O(n\log^2n)$ 的。

然后就很成功地过了这题。


```cpp
#include<bits/stdc++.h>
using namespace std;
inline bool _u(char x){return x>='0'&&x<='9';}
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!_u(ch);ch=='-'&&(f=-1),ch=getchar());
	for(;_u(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
	return x*f;
}
inline void write(int num,bool flag=0){
	static int st[39],tp=0;
	num<0&&(putchar('-'),num=-num);
	do st[++tp]=num%10;while(num/=10);
	while(tp) putchar(st[tp--]|48);
	putchar(flag?'\n':' ');
	return;
}
const int N=5e5+10;

vector<pair<int,int> >fyn[N];
int a[N],d[N],dep[N],fa[N];
namespace init{
	int fy[N][20];
	vector<int>e[N];
	int hev[N],sz[N],lst[N];
	inline int dfs(int u){
		dep[u]=dep[fy[u][0]]+1;
		sz[u]=1,hev[u]=0;
		for(int i=1;i<20;++i) fy[u][i]=fy[fy[u][i-1]][i-1];
		fa[u]=lst[a[u]],lst[a[u]]=u;
		for(int v:e[u])
			if(v!=fy[u][0])
				dfs(v);
		lst[a[u]]=fa[u];
		return sz[u];
	}
	inline int query(int u,int k){
		for(int i=19;~i;--i)
			if(k>=(1<<i)) u=fy[u][i],k-=(1<<i);
		if(k) return 0;
		return u;
	}
	
}
int ans[N];
namespace fyyn{
	int cnt[N];
	vector<int>e[N];
	int hev[N],sz[N];
	int mx[N];
	inline int dfs(int u){
		hev[u]=0,sz[u]=1;
		for(int to:e[u])
			to!=fa[u]&&(sz[u]+=sz[to],hev[u]=(!hev[u]||(sz[to]>sz[hev[u]]?to:hev[u])));
		return sz[u];
	}
	
	struct fffffyn{
		int b[N*39],ls[N*39],rs[N*39];
		int tot;
		#define MID(l,r) (((r-l)>>1)+l)
		inline void insert(int l,int nl,int nr,int &now,int val){
			!now&&(now=++tot);
			if(nl==nr) return void(b[now]+=val);
			int mid(MID(nl,nr));
			l<=mid?insert(l,nl,mid,ls[now],val):insert(l,mid+1,nr,rs[now],val);
			return pushup(now);
		}
		inline void pushup(int now){
			b[now]=b[ls[now]]*(ls[now]!=0)+b[rs[now]]*(rs[now]!=0);
			return;
		}
		inline int query(int l,int nl,int nr,int now){
			if(!now) return 0;
			if(nl==nr) return b[now];
			int mid(MID(nl,nr));
			return l<=mid?query(l,nl,mid,ls[now]):query(l,mid+1,nr,rs[now]);
		}
		inline int merge(int p,int q){
			if(!p||!q)return p|q;
			int now=++tot;
			b[tot]=b[p]+b[q];
			ls[now]=merge(ls[p],ls[q]),rs[now]=merge(rs[p],rs[q]);
			return now;
		}
	}tre;

	int rt[N],mxdep;
	inline int slove(int u,int f){
		if(hev[u]) rt[u]=slove(hev[u],u);
		for(int v:e[u])
			v!=f&&v!=hev[u]&&(rt[u]=tre.merge(rt[u],slove(v,u)),1);
		if(u)
		for(pair<int,int>i:fyn[u])
			ans[i.first]=tre.query(i.second,1,mxdep,rt[u]);
		tre.insert(dep[u],1,mxdep,rt[u],d[u]);
		return rt[u];
	}
}
int n,q;
signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)d[i]=read();
	for(int i=2;i<=n;++i) init::e[init::fy[i][0]=read()].push_back(i);
	init::dfs(1);
	for(int i=1;i<=n;++i) fyyn::e[fa[i]].push_back(i),fyyn::mxdep=max(fyyn::mxdep,dep[i]);
	for(int i=1,u,k;i<=q;++i)
		u=read(),fyn[k=init::query(u,read())].emplace_back(i,dep[u]),fyyn::mx[k]=max(fyyn::mx[k],dep[u]);
	fyyn::slove(0,0);
	for(int i=1;i<=q;++i) write(ans[i],1);
	return(0.0);
}
```






---

## 作者：zfio (赞：0)

这题一开始觉得像dsu on tree，但是我不会。

于是提供两种做法：
1. bfs + 莫队（复杂度不正确，需使用部分分做法以及吸氧）
2. bfs + 主席树（复杂度正确，需使用部分分，无需吸氧可过，但是在吸氧条件下跑得比上面的慢）

## 方法一

**先说一下基础的bfs问题。**

常见的树上问题好像用dfs序解决的比较多（可能只是蒟蒻做题太少）。

利用dfs序，我们可以解决一些子树问题。利用dfs序上一个节点后面一段连续区间都在它的子树当中。

但是这道题因为需要统计某一级的所有儿子的信息。请原谅蒟蒻没想到怎么用dfs来做。

所以就有了bfs的做法，根据bfs的性质，我们可以想到，一个点的某一级的所有儿子反映到bfs序上一定也是一段连续的区间。

利用倍增和二分，我们可以在 $O(log\,n + 2\, log^2n )$ 的时间内求出每个询问所需要统计的bfs序区间，这个区间的 $k$ 级祖先是同一个。第一个 $log$ 是倍增找祖先的，第二个 $log^2$ 是二分确定左端点的，第三个 $log^2$ 是二分确定右端点的，二分的判断方式是看 $mid$ 的 $k$ 级祖先是不是也是该祖先，所以是 $log^2$ 的。

然后问题转化为给定若干组左端点右端点，在一段序列上统计一些信息。这一看就很**莫队**对不对。

但是 5e5 的数据可能会阻挡一些人的想法，但是我比较头铁。~~本着数据一定是随机的想法~~，我交了一发发现只有第二个部分分不可过。

所以果断打上部分分做法水过。

### 部分分做法

很显然一个节点的某一级的后代只会有一个。所以每个询问直接倍增找他的祖先，如果颜色相同答案就是该节点的$d$，否则就是0 。

## 方法二

但是本着对人民负责（~~懒得写别的题~~）的原则，我想了想怎么做复杂度是对的。

然后发现处理序列问题某一段区间的问题可以前缀和，但是空间开不下，所以主席树也挺行的。

然后把主席树的板子改一改就可做了。

这个主席树是对颜色开的，即 $l==r$ 时 $sum[u]$ 对应的就是在bfs序上 ($1$ 到 某一下标) 颜色为 $l$ 的权值的总和，支持单点修改单点查询即可。

注意我的代码里主席树区间只是 $[1,n]$ 的，如果有颜色大于 $n$ 的话会错。码的时候忘了，现在懒得改了。正确的做法是读入时记录一下最大的颜色 $mx$，然后建树建$[1,mx]$。

这样我们就可以用 $O(log \,n)$ 复杂度做到在线回答询问。

复杂度瓶颈应该是 $O(q \, log^2n)$，应该是可过的，但是不知道为何链的情况就是有两个点会T 。

感觉是常数的问题，看到题解里 $O(n \, log \, n)$ 长剖的大兄弟都过不去我就不想调了。

## 最后

嗯...感觉这题自己写恶心了。

### code1（bfs + 莫队）：

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 5e5 + 10;
inline int read() {
	int s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
	return s * w;
}
struct edge {
	int nex;
	int to;
} e[maxn << 1];
int head[maxn];
int tot;
void Add(int u, int v) {
	e[++tot] = (edge) { head[u], v }, head[u] = tot;
}
int n, m;
int bfsclock;
int c[maxn];
int d[maxn];
int son[maxn];
int bfn[maxn];
int idex[maxn];
int sum[maxn];
int ans[maxn];
int fa[maxn][26];
int bel[maxn];
struct node {
	int c;
	int l;
	int r;
	int id;
	bool operator < (const node &x) const {
		if (bel[l] != bel[x.l]) return l < x.l;
		if (bel[l] & 1) return r < x.r;
		return r > x.r;
	}
} Q[maxn];
int Find(int u, int k) {
	int res = 0;
	while (k) {
		if (k & 1) u = fa[u][res];
		res++, k >>= 1;
	}
	return u;
}
void PreWork(int u) {
	for (int i = 1; i <= 25; ++i) {
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (int i = head[u]; i; i = e[i].nex) {
		int v = e[i].to;
		if (v == fa[u][0]) continue;
		PreWork(v);
	}
}
queue<int> que;
bool vis[maxn];
void bfs() {
	que.push(1);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		bfn[u] = ++bfsclock;
		idex[bfsclock] = u;
		for (int i = head[u]; i; i = e[i].nex) {
			int v = e[i].to;
			if (!vis[v]) que.push(v), vis[v] = 1;
		}
	}
}
void init() {
	int s = sqrt(n), cnt = 0;
	for (int l = 1, r; l + s - 1 <= n; l += s) {
		r = l + s - 1;
		cnt++;
		for (int i = l; i <= r; ++i) bel[i] = cnt;
	}
	if (s * cnt < n) {
		int l = s * cnt + 1;
		int r = n;
		cnt++;
		for (int i = l; i <= r; ++i) bel[i] = cnt;
	}
}
void putin(int x) {
	sum[c[idex[x]]] += d[idex[x]];
}
void del(int x) {
	sum[c[idex[x]]] -= d[idex[x]];
}
int main() {
	cin >> n >> m;
	init();
	for (int i = 1; i <= n; ++i) c[i] = read();
	for (int i = 1; i <= n; ++i) d[i] = read();
	for (int i = 2; i <= n; ++i) {
		fa[i][0] = read();
		Add(fa[i][0], i);
		son[fa[i][0]]++;
	}
	PreWork(1);
	bfs();
	int flag = 1;
	for (int i = 1; i <= n; ++i) {
		if (son[i] > 1) flag = 0;
	}
	if (flag) {
		for (int i = 1; i <= m; ++i) {
			int u = read(), k = read();
			int faa = Find(u, k);
			if (c[u] == c[faa]) cout << d[u] << '\n';
			else cout << 0 << '\n';
		}
		return 0;
	}
	for (int i = 1; i <= m; ++i) {
		int u = read(), k = read();	
		int faa = Find(u, k);
		int l = 1, r = bfn[u] - 1, mid;
		Q[i].id = i;
		Q[i].c = c[faa];
		while (l <= r) {
			mid = (l + r) >> 1;
			if (Find(idex[mid], k) == faa) r = mid - 1;
			else l = mid + 1;
		}
		Q[i].l = l;
		l = bfn[u] + 1, r = n;
		while (l <= r) {
			mid = (l + r) >> 1;
			if (Find(idex[mid], k) == faa) l = mid + 1;
			else r = mid - 1;
		}
		Q[i].r = l - 1;
	}
	sort(Q + 1, Q + 1 + m);
	for (int i = 1, l = 1, r = 0; i <= m; ++i) {
		node q = Q[i];
		while (l > q.l) putin(--l);
		while (r < q.r) putin(++r);
		while (l < q.l) del(l++);
		while (r > q.r) del(r--);
		ans[q.id] = sum[q.c];
	}
	for (int i = 1; i <= m; ++i) cout << ans[i] << '\n';
	return 0;
}
```

### code2（bfs + 主席树）：

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxn = 5e5 + 10;
inline int read() {
	int s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
	return s * w;
}
struct edge {
	int nex;
	int to;
} e[maxn << 1];
int head[maxn];
int tot;
void Add(int u, int v) {
	e[++tot] = (edge) { head[u], v }, head[u] = tot;
}
int n, m;
int bfsclock;
int son[maxn];
int c[maxn];
int d[maxn];
int bfn[maxn];
int idex[maxn];
int fa[maxn][26];
int Find(int u, int k) {
	int res = 0;
	while (k) {
		if (k & 1) u = fa[u][res];
		res++, k >>= 1;
	}
	return u;
}
void PreWork(int u) {
	for (int i = 1; i <= 25; ++i) {
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (int i = head[u]; i; i = e[i].nex) {
		int v = e[i].to;
		if (v == fa[u][0]) continue;
		PreWork(v);
	}
}
queue<int> que;
bool vis[maxn];
void bfs() {
	que.push(1);
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		bfn[u] = ++bfsclock;
		idex[bfsclock] = u;
		for (int i = head[u]; i; i = e[i].nex) {
			int v = e[i].to;
			if (!vis[v]) que.push(v), vis[v] = 1;
		}
	}
}

//主席树
int cnt;
int rt[maxn];
ll sum[maxn << 5];
int ls[maxn << 5];
int rs[maxn << 5];
int build(int l, int r) {
	int root = ++cnt;
	sum[root] = 0;
	if (l == r) return root;
	int mid = (l + r) >> 1;
	ls[root] = build(l, mid);
	rs[root] = build(mid + 1, r);
	return root;
}
int modify(int pre, int l, int r, int pos, int val) {
	int root = ++cnt;
	ls[root] = ls[pre];
	rs[root] = rs[pre];
	sum[root] = sum[pre] + val;
	if (l == r) return root;
	int mid = (l + r) >> 1;
	if (pos <= mid) ls[root] = modify(ls[pre], l, mid, pos, val);
	else rs[root] = modify(rs[pre], mid + 1, r, pos, val);
	return root;
}
int query(int u, int v, int l, int r, int pos) {
	if (l == r) return sum[v] - sum[u];
	int mid = (l + r) >> 1;
	if (pos <= mid) return query(ls[u], ls[v], l, mid, pos);
	return query(rs[u], rs[v], mid + 1, r, pos);
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) c[i] = read();
	for (int i = 1; i <= n; ++i) d[i] = read();
	for (int i = 2; i <= n; ++i) {
		fa[i][0] = read();
		Add(fa[i][0], i);
		son[fa[i][0]]++;
	}
	PreWork(1);
	bfs();
	int flag = 1;
	for (int i = 1; i <= n; ++i) {
		if (son[i] > 1) flag = 0;
	}
	if (flag) {
		for (int i = 1; i <= m; ++i) {
			int u = read(), k = read();
			int faa = Find(u, k);
			if (c[u] == c[faa]) cout << d[u] << '\n';
			else cout << 0 << '\n';
		}
		return 0;
	}
	rt[0] = build(1, n);
	for (int i = 1; i <= n; ++i) {
		rt[i] = modify(rt[i - 1], 1, n, c[idex[i]], d[idex[i]]);
	}
	for (int i = 1; i <= m; ++i) {
		int u = read(), k = read();	
		int faa = Find(u, k);
		if (!faa) {
		    cout << 0 << '\n';
		    continue;
		}
		int l = 1, r = bfn[u] - 1, mid;
		int L, R;
		while (l <= r) {
			mid = (l + r) >> 1;
			if (Find(idex[mid], k) == faa) r = mid - 1;
			else l = mid + 1;
		}
		L = l;
		l = bfn[u] + 1, r = n;
		while (l <= r) {
			mid = (l + r) >> 1;
			if (Find(idex[mid], k) == faa) l = mid + 1;
			else r = mid - 1;
		}
		R = l - 1;
		printf("%d\n", query(rt[L - 1], rt[R], 1, n, c[faa]));
	}
	return 0;
}
```

---


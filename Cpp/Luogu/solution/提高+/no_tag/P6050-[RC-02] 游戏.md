# [RC-02] 游戏

## 题目描述

Shik 大佬发明了一种游戏。这种游戏在 $N \times N$ （$N$ 为偶数）的网格上进行，如图所示（左上角为 $(1,1)$，右下角为 $(N,N)$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/fl8gbzim.png)

这种游戏的规则如下：
- 初始局面为：在最左边一列和最右边一列的网格上分别放置着红方和蓝方的棋子，在最上面一行左半部分和最下面一行左半部分也放置着红方的棋子，在最上面一行右半部分和最下面一行右半部分也放置着蓝方的棋子；
- 红方先走，蓝方后走；
- 有一方只剩下 $N\div 2$ 颗棋子时，游戏结束，另一方获胜；
- 有一方无棋可走时，游戏结束，另一方获胜；
- 每次走棋可以让一颗棋子往上下左右方向移动 $1$ 格，但目标格上不能有棋子；
- 同时满足以下条件时可以吃掉对方棋子：在一行（或一列上），有且仅有 $N-1$ 颗棋子（当 $N>4$ 时为 $N-2$ 颗也可），其中有 $N-2$ 颗己方棋子（当 $N>4$ 时为 $N-3$ 颗也可），另外 $1$ （当 $N>4$ 时为 $2$ 颗也可）颗棋子为敌方的，我方的棋子全部相邻，敌方棋子全部相邻，并且我方有一颗棋子与敌方相邻，**而且此局面为我方主动走成**，则我方可以把这一列上敌方的棋子全部吃掉。

现在，请你模拟走棋的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/2rn7td02.png)

以上为一个不可以吃子的局面。（红吃蓝）

但假如蓝棋本来就在 $(3,3)$，红棋从 $(2,2)$ 走到 $(2,3)$，就可以吃子。

**若不能理解，强烈建议手推一遍样例。**

## 说明/提示

样例 4 说明：第 21 歩时，红方已胜，因此第 22 歩的非法移动应该忽略。

对于 $30\%$ 的数据，不存在吃子的情况；

对于 $60\%$ 的数据，$N=4$；

对于 $80\%$ 的数据，$4\le N\le 6$；

对于 $100\%$ 的数据，$4\le N\le 10$，$1 \le K \le 10^3$。

## 样例 #1

### 输入

```
4 1
1 4 1 3```

### 输出

```
0```

## 样例 #2

### 输入

```
4 2
1 3 2 3
3 4 3 3
```

### 输出

```
1
hhll
h..l
..ll
hh.l```

## 样例 #3

### 输入

```
6 7
1 3 2 3
4 1 4 2
3 1 4 1
6 4 5 4
2 1 3 1
5 4 6 4
1 1 2 1```

### 输出

```
1
.hhh..
h..l.l
.h...l
h....l
h....l
hhhlll```

## 样例 #4

### 输入

```
6 22
1 3 2 3
4 1 4 2
3 1 4 1
6 4 5 4
2 1 3 1
5 4 6 4
1 1 2 1
6 2 5 2
3 1 3 2
6 4 5 4
2 1 2 2
4 6 4 5
3 6 4 6
5 4 6 4
2 6 3 6
6 4 5 4
1 6 2 6
6 5 6 6
2 6 2 5
6 6 5 6
2 5 2 6
6 6 5 6```

### 输出

```
2
red
...h..
hhh...
.h...l
h...l.
h..l..
.hhh..```

# 题解

## 作者：Hero_Broom (赞：1)

**[Perhaps a better reading experience?](https://www.luogu.com.cn/article/znyvztdm)**

~~刷大模拟的时候碰巧看到这一篇小模拟，大模拟调不出来，于是做小模拟来涨自信~~

## 题目大意

**[题目链接](https://www.luogu.com.cn/problem/P6050)**

让你模拟一场游戏的进行，规则在题目里说得很清楚了。

## 题解

这道题可以分为几个部分：输入输出、判断输入数据是否合法，吃掉对方的棋子，最后就是判断游戏是否结束。我们可以一步一步地解决

### $\texttt{I.}$ 移动棋子和判定数据是否合法

在题目中，数据有可能出现下面几种不合法的情况：

1. **数据超出范围**，这一点是很好判断的；
2. **目标点上已有其它棋子存在**；
3. **起始点上没有棋子或是有对方的棋子**。

这个部分是比较简单的。对于第三条，我们使用一个变量 `now` 记录当前移动的棋子。

那么我们就可以写出判断数据是否合法的 `command_correct` 函数。

```cpp
inline bool in_range(int t){return (t>=1&&t<=n);}
inline bool command_correct(){
	if(!in_range(sx)||!in_range(sy)||!in_range(ex)||!in_range(ey)) return 0;
	if(board[sx][sy]!=now||board[ex][ey]!=0) return 0;
	return 1;
}
```

代码中，`sx` 和 `sy` 代表起始点坐标，`ex` 和 `ey` 代表目标点坐标，`board` 数组是棋盘。

注意在读如数据的时候我们要交换输入的 x 坐标和 y 坐标，因为在 C++ 中，`a[i][j]` 表示第 $i$ 行第 $j$ 列，而数据中给出的是第 $i$ 列第 $j$ 行。

```cpp
scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
swap(sx,sy),swap(ex,ey);
if(!command_correct()){
    printf("0\n");
    return 0;
}
```

### $\texttt{II.}$ 吃对方的棋子

在判断是否可以吃掉对方棋子时，我们只需要判断当前输入的目标点所在的行和列是否存在可以吃棋的情况，而不需要每次输入把整个棋盘遍历一遍。

有一个需要注意的点在题目中说了：敌方棋子全部相邻，并且我方有一颗棋子与敌方相邻，而且此局面为**我方主动走成**，则我方可以把这一列上敌方的棋子全部吃掉。也就是说，我们在判断的时候要判断当前局面是否为我方主动形成的，否则就不能判定为吃棋。

首先我们要先统计出当前行的我方和对方的棋子数量，如果棋子的数量不对，那么就直接返回就可以了。

我们要在每一次循环之后更新 `now` 的值。我们把红色一方设为 `1`，蓝色设为 `2`。

当我们需要统计己方的棋子数时，只要 `cnta+=(board[ex][i]==now)` 即可，而要表示对方棋子，我们可以使用 `3-now` 来表示，所以统计对方棋子数时我们可以 `cntb+=(board[ex][i]==3-now)`。在这里，`cnta` 和 `cntb` 分别表示己方的棋子数和对方的棋子数。

这里的代码以行为例，列的代码也差不多。

```cpp
cnta=cntb=tot=0;
for(int i=1;i<=n;i++){
	tot+=(board[ex][i]!=0);
	cnta+=(board[ex][i]==now);
	cntb+=(board[ex][i]==3-now);
}
if(!(tot==n-1||(n>4&&tot==n-2))) return;
if(!(cnta==n-2||(n>4&&cnta==n-3))) return;
if(!((cntb==1)||(n>4&&cntb==2))) return;
```

接下来判断棋子的位置是否正确。

在判断棋子位置时，我们需要判断一下几种情况：

1. 每一方的棋子必须相邻；
2. 己方必须有一个棋子与对方相邻。

这里第二点需要注意，一开始我在做时就是因为这个 WA 了。

```cpp
ca=cb=tmp=0;
for(int i=1;i<=n;i++){
	if(board[ex][i+1]==3-board[ex][i]) tmp=1;
	if(board[ex][i]!=now){
		if(ca!=0&&ca!=cnta) return;
		ca=0;
	}else ca++;
	if(board[ex][i]!=3-now){
		if(cb!=0&&cb!=cntb) return;
		cb=0;
	}else cb++;
}
if(tmp==0) return;
```

`ca` 和 `cb` 表示两方相邻的棋子数，`tmp` 表示是否满足上面的第二种情况。

最后如果上面的条件都满足，那么就可以吃棋子了。

```cpp
for(int i=1;i<=n;i++)
	if(board[ex][i]==3-now) board[ex][i]=0;
```

以上是模拟一行中吃子的代码，而列也是一样的，只要把所有的 `board[ex][i]` 改成 `board[i][ey]` 即可。

下面是列的代码：

```cpp
void eat_col(){
	cnta=cntb=tot=0;
	for(int i=1;i<=n;i++){
		tot+=(board[i][ey]!=0);
		cnta+=(board[i][ey]==now);
		cntb+=(board[i][ey]==3-now);
	}
	if(!(tot==n-1||(n>4&&tot==n-2))) return;
	if(!(cnta==n-2||(n>4&&cnta==n-3))) return;
	if(!((cntb==1)||(n>4&&cntb==2))) return;
	ca=cb=tmp=0;
	for(int i=1;i<=n;i++){
		if(board[i+1][ey]==3-board[i][ey]){
			tmp=1;
		}
		if(board[i][ey]!=now){
			if(ca!=0&&ca!=cnta) return;
			ca=0;
		}else ca++;
		if(board[i][ey]!=3-now){
			if(cb!=0&&cb!=cntb) return;
			cb=0;
		}else cb++;
	}
	if(tmp!=0){
		for(int i=1;i<=n;i++)
			if(board[i][ey]==3-now) board[i][ey]=0;
	}
}
```

### $\texttt{III.}$ 判断输赢

这一个部分就比较简单了。有一方赢应该满足下面任选一个条件：

1. 对方棋子少于 $\frac{N}{2}$ 个；
2. 对方**无棋可走**。

这个部分比较简单，就直接贴代码了。

```cpp
inline bool in_range(int t){return (t>=1&&t<=n);}
inline bool can_move(int x,int y){
	if(in_range(x-1)&&in_range(y)&&board[x-1][y]==0) return 1;
	if(in_range(x+1)&&in_range(y)&&board[x+1][y]==0) return 1;
	if(in_range(x)&&in_range(y+1)&&board[x][y+1]==0) return 1;
	if(in_range(x)&&in_range(y-1)&&board[x][y-1]==0) return 1;
	return 0;
}
short is_win(){
	bool rflag=0,bflag=0;
	red_tot=blue_tot=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(board[i][j]==1){
				red_tot++;
				if(can_move(i,j)) rflag=1;
			}
			if(board[i][j]==2){
				blue_tot++;
				if(can_move(i,j)) bflag=1;
			}
//			red_tot+=(board[i][j]==1);
//			blue_tot+=(board[i][j]==2);
		}
	if(!rflag) return 2;
	if(!bflag) return 1;
	if(red_tot<=n/2) return 2;
	if(blue_tot<=n/2) return 1;
	return 0;
}
```

### $\texttt{IV.}$ 初始化

这个部分也比较简单，按照题意模拟即可。

```cpp
inline void init(){
	for(int i=1;i<=n/2;i++) board[1][i]=board[n][i]=1;
	for(int i=n/2+1;i<=n;i++) board[1][i]=board[n][i]=2;
	for(int i=2;i<=n-1;i++) board[i][1]=1,board[i][n]=2;
}
```

### $\texttt{V.}$ 主函数

在写主函数时，只需要**注意输入的时候将横纵坐标交换一下**就可以了，因为输入中是先输入列再输入行。

```cpp
int main(){
	scanf("%d%d",&n,&m);
	init();
	while(m--){
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		swap(sx,sy),swap(ex,ey);
		if(!command_correct()){
			printf("0\n");
			return 0;
		}
		move();
		eat();
		now=(now==1?2:1);
		if(is_win()==0) continue;
		printf("2\n%s\n",is_win()==1?"red":"blue");
		out();
		return 0;
	}
	printf("1\n");
	out();
	return 0;
}
```

### $\texttt{VI.}$ 易错点

1. 输入的时候将横纵坐标交换一下；
2. 判断输赢时应该判断是否有一方无棋可走，如果没有判断会 WA 几个点；
3. 在判断是否可以吃掉对方的棋子时，两方需有一个旗子相邻，这点也要考虑到。

## 代码

还是一道比较简单的小模拟，代码 150 行都没到，是一道不错的锻炼码力的题目。

上面说的自认为已经是比较清楚的了，代码没有注释，如果看不懂的可以往前看一看解释，这样才能锻炼思维。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int sx,sy,ex,ey;
int red_tot,blue_tot;
int tot,cnta,cntb,ca,cb;
bool tmp;
short board[20][20],now=1;//0:empty	1:red	2:blue
inline void init(){
	for(int i=1;i<=n/2;i++) board[1][i]=board[n][i]=1;
	for(int i=n/2+1;i<=n;i++) board[1][i]=board[n][i]=2;
	for(int i=2;i<=n-1;i++) board[i][1]=1,board[i][n]=2;
}
inline bool in_range(int t){return (t>=1&&t<=n);}
inline bool command_correct(){
	if(!in_range(sx)||!in_range(sy)||!in_range(ex)||!in_range(ey)) return 0;
	if(board[sx][sy]!=now||board[ex][ey]!=0) return 0;
	return 1;
}
inline void move(){swap(board[sx][sy],board[ex][ey]);}
void eat_line(){
	cnta=cntb=tot=0;
	for(int i=1;i<=n;i++){
		tot+=(board[ex][i]!=0);
		cnta+=(board[ex][i]==now);
		cntb+=(board[ex][i]==3-now);
	}
	if(!(tot==n-1||(n>4&&tot==n-2))) return;
	if(!(cnta==n-2||(n>4&&cnta==n-3))) return;
	if(!((cntb==1)||(n>4&&cntb==2))) return;
	ca=cb=tmp=0;
	for(int i=1;i<=n;i++){
		if(board[ex][i+1]==3-board[ex][i]) tmp=1;
		if(board[ex][i]!=now){
			if(ca!=0&&ca!=cnta) return;
			ca=0;
		}else ca++;
		if(board[ex][i]!=3-now){
			if(cb!=0&&cb!=cntb) return;
			cb=0;
		}else cb++;
	}
	if(tmp!=0){
		for(int i=1;i<=n;i++)
			if(board[ex][i]==3-now) board[ex][i]=0;
	}
}
void eat_col(){
	cnta=cntb=tot=0;
	for(int i=1;i<=n;i++){
		tot+=(board[i][ey]!=0);
		cnta+=(board[i][ey]==now);
		cntb+=(board[i][ey]==3-now);
	}
	if(!(tot==n-1||(n>4&&tot==n-2))) return;
	if(!(cnta==n-2||(n>4&&cnta==n-3))) return;
	if(!((cntb==1)||(n>4&&cntb==2))) return;
	ca=cb=tmp=0;
	for(int i=1;i<=n;i++){
		if(board[i+1][ey]==3-board[i][ey]){
			tmp=1;
		}
		if(board[i][ey]!=now){
			if(ca!=0&&ca!=cnta) return;
			ca=0;
		}else ca++;
		if(board[i][ey]!=3-now){
			if(cb!=0&&cb!=cntb) return;
			cb=0;
		}else cb++;
	}
	if(tmp!=0){
		for(int i=1;i<=n;i++)
			if(board[i][ey]==3-now) board[i][ey]=0;
	}
}
inline void eat(){
	eat_line();
	eat_col();
}
inline bool can_move(int x,int y){
	if(in_range(x-1)&&in_range(y)&&board[x-1][y]==0) return 1;
	if(in_range(x+1)&&in_range(y)&&board[x+1][y]==0) return 1;
	if(in_range(x)&&in_range(y+1)&&board[x][y+1]==0) return 1;
	if(in_range(x)&&in_range(y-1)&&board[x][y-1]==0) return 1;
	return 0;
}
short is_win(){
	bool rflag=0,bflag=0;
	red_tot=blue_tot=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(board[i][j]==1){
				red_tot++;
				if(can_move(i,j)) rflag=1;
			}
			if(board[i][j]==2){
				blue_tot++;
				if(can_move(i,j)) bflag=1;
			}
		}
	if(!rflag) return 2;
	if(!bflag) return 1;
	if(red_tot<=n/2) return 2;
	if(blue_tot<=n/2) return 1;
	return 0;
}
inline void out(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) printf("%c",board[i][j]==0?'.':board[i][j]==1?'h':'l');
		printf("\n");
	}
}
int main(){
	scanf("%d%d",&n,&m);
	init();
	while(m--){
		scanf("%d%d%d%d",&sx,&sy,&ex,&ey);
		swap(sx,sy),swap(ex,ey);
		if(!command_correct()){
			printf("0\n");
			return 0;
		}
		move();
		eat();
		now=(now==1?2:1);
		if(is_win()==0) continue;
		printf("2\n%s\n",is_win()==1?"red":"blue");
		out();
		return 0;
	}
	printf("1\n");
	out();
	return 0;
}
```

---

## 作者：stardust_Ray (赞：0)

一道小模拟。~~从看到题到 AC 差不多 1h。~~

[题目传送门](https://www.luogu.com.cn/problem/P6050)

## 初始化

初始化棋盘和每种颜色的棋子的数量（方便“只剩下 $N\div 2$ 颗棋子时，游戏结束”这一条件的判断），直接做就可以了。

```cpp
//a表示棋盘，cnt表示每种颜色的数量
//a[i][j]=1表示为红色，=2表示蓝色，=0表示为空格
void Init_Board(){
  for(int i=1;i<=n/2;i++) a[1][i]=a[n][i]=1;
  for(int i=n/2+1;i<=n;i++) a[1][i]=a[n][i]=2;
  for(int i=1;i<=n;i++) a[i][1]=1,a[i][n]=2;
  cnt[1]=cnt[2]=2*n-2;
}
```


## 判断不合法的情况

不合法的情况只有如下几种：

1. 坐标超出范围
2. $(a,b)$ 处的棋子是对方的棋子或空格
3. $(c,d)$ 处是棋子
4. $(a,b)$ 和 $(c,d)$ 之间的曼哈顿距离 $> 1$

直接在输入的时候特判掉即可：

```cpp
void CheckExit(int sx,int sy,int tx,int ty,int op){
//(sx,sy)表示输入的(a,b),(tx,ty)表示输入的(c,d),op表示当前操作一方
//op=1表示红方，op=2表示蓝方
  if(abs(sx-tx)+abs(sy-ty)!=1) Exit();//第一种情况
  if(a[sx][sy]!=op) Exit();//第二种情况
  if(a[tx][ty]!=0) Exit();//第三种情况
  if(sx<1||sx>n||sy<1||sy>n||tx<1||tx>n||ty<1||ty>n) Exit();
  //第四种情况
}
```

## 移动和吃子

~~棋子的移动只用 2 个赋值~~，主要是如何判断吃子。

首先满足棋子数量的限制：

1. 在一行（或一列上），有且仅有 $N-1$ 颗棋子（当 $N>4$ 时为 $N-2$ 颗也可）
2. 其中有 $N-2$ 颗己方棋子（当 $N>4$ 时为 $N-3$ 颗也可）
3. 另外 $1$ （当 $N>4$ 时为 $2$ 颗也可）颗棋子为敌方的。”

直接统计该行（列）的各种颜色的棋子数量并判断即可。

```cpp
int ctt=0,cta=0,ctb=0;
//ctt表示总棋子数，cta表示我方棋子数，ctb表示对方棋子数
for(int i=1;i<=n;i++){
  ctt+=(bool)a[x][i];
  cta+=(a[x][i]==op);
}ctb=ctt-cta;
if(!(ctt==n-1||(ctt==n-2&&n>4))) return;
if(!(cta==n-2||(n>4&&cta==n-3))) return;
if(!(ctb==1||(n>4&&ctb==2))) return;
```

接下来判断相邻这一条件。

但蒟蒻不会判断相邻（悲）。考虑统计每种颜色的连续段长度。如果颜色段长度和棋子数不等，那么就不能吃子。我方棋子和敌方棋子的相邻直接记录是否存在相邻棋子颜色不同即可。

```cpp
int na=0,nb=0;
bool flg=0;
//na表示我方棋子颜色段长度，nb表示敌方棋子颜色端长度
//flg表示是否存在我方和敌方相邻
for(int i=1;i<=n;i++){
  if(a[x][i]+a[x][i+1]==3) flg=1;
  if(a[x][i]!=op){
    if(na&&na!=cta) return;
    na=0;
  }else na++;
  if(a[x][i]!=3-op){
    if(nb&&nb!=ctb) return;
    nb=0;
  }else nb++;
}if(!flg) return;
```

吃子就直接赋值为 $0$ 并且更新 $cnt$ 数组即可。

```cpp
for(int i=1;i<=n;i++)
  if(a[x][i]==3-op) a[x][i]=0,cnt[3-op]--;
//op表示己方的颜色，3-op表示敌方的颜色
```

以上是更新行的代码，更新列的同理。

## 判断游戏结束

“只剩下 $N\div 2$ 颗棋子时，游戏结束”：根据前面存的 $cnt$ 数组，直接判断是否 $cnt\le \frac{N}{2}$即可。

无棋可走：枚举每个棋子的四周四个位置，如果可以移动就将该颜色的 $flag$ 记为 $1$，判断是否有一个颜色的 $flag$ 为 $0$ 即可。

```cpp
bool CanMove(int x,int y){
  return x>0&&x<=n&&y>0&&y<=n&&!a[x][y];
}
int checkNoneMove(){
//返回值表示不能移动的颜色
  bool flg[3]={0,1,1};
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      if(a[i][j])
        if(CanMove(i-1,j)||CanMove(i+1,j)||CanMove(i,j-1)||CanMove(i,j+1))
          flg[a[i][j]]=0;
  if(flg[1]) return 1;
  if(flg[2]) return 2;
  return 0;
}
```

输出是简单的。

完整代码（无注释，有坑——）

```cpp
#include<bits/stdc.h>
#define within :
#define LJY main
using namespace std;
typedef long long ll;
inline int read(){
  char ch=getchar();int x=0;
  while(ch<'0'||ch>'9') ch=getchar();
  while(ch>='0'&&ch<='9')
    x=(x<<3)+(x<<1)+(ch^48);
  return x;
}
int n,m,a[11][11],cnt[3];
void Init_Board(){
  for(int i=1;i<=n/2;i++) a[1][i]=a[n][i]=1;
  for(int i=n/2+1;i<=n;i++) a[1][i]=a[n][i]=2;
  for(int i=1;i<=n;i++) a[i][1]=1,a[i][n]=2;
  cnt[1]=cnt[2]=2*n-2;
}
void Exit(){puts("0");exit(0);}
void CheckExit(int sx,int sy,int tx,int ty,int op){
  if(abs(sx-tx)+abs(sy-ty)!=1) Exit();
  if(a[sx][sy]!=op) Exit();
  if(a[tx][ty]!=0) Exit();
  if(sx<1||sx>n||sy<1||sy>n||tx<1||tx>n||ty<1||ty>n) Exit();
}
void AttackRow(int x,int op){
  int ctt=0,cta=0,ctb=0;
  for(int i=1;i<=n;i++){
    ctt+=(bool)a[x][i];
    cta+=(a[x][i]==op);
  }ctb=ctt-cta;
  if(!(ctt==n-1||(ctt==n-2&&n>4)))return;
  if(!(cta==n-2||(n>4&&cta==n-3)))return;
  if(!(ctb==1||(n>4&&ctb==2))) return;
  int na=0,nb=0;
  bool flg=0;
  for(int i=1;i<=n;i++){
    if(a[x][i]+a[x][i+1]==3) flg=1;
    if(a[x][i]!=op){
      if(na&&na!=cta) return;
      na=0;
    }else na++;
    if(a[x][i]!=3-op){
      if(nb&&nb!=ctb) return;
      nb=0;
    }else nb++;
  }if(!flg) return;
  for(int i=1;i<=n;i++)
    if(a[x][i]==3-op) a[x][i]=0,cnt[3-op]--;
}
void AttackColumn(int x,int op){
  int ctt=0,cta=0,ctb=0;
  for(int i=1;i<=n;i++){
    ctt+=(bool)a[i][x];
    cta+=(a[i][x]==op);
  }ctb=ctt-cta;
  if(!(ctt==n-1||(ctt==n-2&&n>4)))return;
  if(!(cta==n-2||(n>4&&cta==n-3)))return;
  if(!(ctb==1||(n>4&&ctb==2))) return;
  int na=0,nb=0;
  bool flg=0;
  for(int i=1;i<=n;i++){
    if(a[i][x]+a[i+1][x]==3) flg=1;
    if(a[i][x]!=op){
      if(na&&na!=cta) return;
      na=0;
    }else na++;
    if(a[i][x]!=3-op){
      if(nb&&nb!=ctb) return;
      nb=0;
    }else nb++;
  }if(!flg) return;
  for(int i=1;i<=n;i++)
    if(a[i][x]==3-op) a[i][x]=0,cnt[3-op]--;
}
bool CanMove(int x,int y){return x>0&&x<=n&&y>0&&y<=n&&!a[x][y];}
int checkNoneMove(){
  bool flg[3]={0,1,1};
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      if(a[i][j])
        if(CanMove(i-1,j)||CanMove(i+1,j)||CanMove(i,j-1)||CanMove(i,j+1))
          flg[a[i][j]]=0;
  if(flg[1]) return 1;
  if(flg[2]) return 2;
  return 0;
}
void print(){
  for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++)
      if(a[i][j]==0) putchar('.');
      else if(a[i][j]==1) putchar('h');
      else putchar('l');
    puts("");
  }
}
void Print2(int op){puts("2");puts(op==1?"red":"blue");print();exit(0);}
void Print1(){puts("1");print();}
signed LJY(){
  n=read();m=read();Init_Board();
  for(int i=1;i<=m;i++){
    int sx,sy,tx,ty;
    sx=read();sy=read();tx=read();ty=read();
    swap(sx,sy);swap(tx,ty);
    int op=(i&1)?1:2;
    CheckExit(sx,sy,tx,ty,op);
    a[sx][sy]=0;a[tx][ty]=op;
    AttackRow(tx,op);
    AttackColumn(ty,op);
    if(cnt[3-op]<=n/2) Print2(op);
    int p=checkNoneMove();
    if(p) Print2(3-p);
  }Print1();
  return 0;
}
```

蒟蒻第一次写模拟题的题解，求 Hack

~~有人抄`#define LJY main`吗~~

---


# [JSOI2013] 贪心的导游

## 题目描述

南京有一条著名的购物街。购物街嘛，就是一排整齐的商店啦~

导游小 Z 每次都会把游客团带到购物街里走一段，然后选择一个商店进去购物。

小 Z 接待的游客都是购物狂，他们恨不得将店内的商品洗劫一空，也就是说，只要他们能买，就一定会继续买（钱够不够你不用考虑，他们都有信用卡可以透支）。

但是有一点，他们都非常讲究平等、很谦虚，每个人都不能忍受比别人多买什么东西或者少买什么东西，于是他们每个人最后买的商品数量都是一样的。这虽然导致他们没办法每次都把商店搬空，但是每次已经给店家带来一大笔生意了，店家已经非常感谢了！为了表示感谢，店家决定把游客们买完之后剩下来那几件没卖掉的商品就送给导游小 Z 了。

贪心的小 Z 自然希望自己能获赠的商品数量越大越好啦~

现在告诉你这一排共 $n$ 个商店（标号为 $0$ 到 $n-1$）每个商店里的商品总数，每次小 Z 会带一批共 $p$ 个游客的旅游团，到其中 $u$ 号商店和 $v$ 号商店之间逛一逛，请你帮小 Z 在所逛的商店区间内选择一个，告诉小 Z 他最多能获赠多少件商品。

## 说明/提示

### 样例解释

第一个旅游团， $2$ 个人， $0$ 号商店到 $1$ 号商店的区间。若去 $1$ 号商店，共 $2$ 件商品，每人买 $1$ 件，剩 $0$ 件。若去 $2$ 号商店，共 $4$ 件商品，每人买 $2$ 件，剩 $0$ 件。所以，小 Z 最多获赠 $0$ 件。

第二个旅游团， $3$ 个人，小 Z 选择带他们去 $4$ 号商店，共 $8$ 件商品，每人买 $2$ 件商品（因为每人 $3$ 件不够），剩下 $2$ 件，小 Z 最多获赠就是 $2$ 件。 可以验证去其它商店小 Z 最多获赠的商品不会达到 $2$ 件。

### 数据范围

对于 $100\%$ 的数据，$1 \leq n\leq 10^6,1 \leq m\leq 5\times 10^4,0\leq a_i\leq 10^3,2\leq p\leq 10^3,0\leq u,v\leq n-1$。

## 样例 #1

### 输入

```
5 5
2 4 6 8 10
0 1 2
1 4 3
2 4 2
1 1 9
0 4 7```

### 输出

```
0
2
0
4
6```

# 题解

## 作者：xgzc (赞：8)

分块，设 $f_{i, j}$ 表示第 $i$ 块中 $\bmod j$ 的最大值。

预处理时枚举每一个块，块内预处理出数组 $g_i$ 表示 $\leq i$ 的最大值，然后根据 $x \bmod p$ 分段单调递增的特性求出 $f_{i, j}$。

询问则是经典的分块套路，即整块直接得到答案，零散块暴力。

设块长为 $B$，则时间复杂度为 $\mathcal{O} (\frac {np \log p}B + n + m(B + \frac nB))$。

当取块长 $B = \mathcal O(\sqrt n)$ 时，时间复杂度为 $\mathcal O((p \log p + m) \sqrt n)$。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>

inline int read()
{
	int data = 0, w = 1; char ch = getchar();
	while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if (ch == '-') w = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();
	return data * w;
}

const int N(1e6 + 10), Mod(1e3 + 10), P(1000);
int n, m, a[N], f[Mod][Mod], g[Mod], bel[N], L[N], R[N], Len;

int main()
{
	n = read(), m = read(), Len = sqrt(n);
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) bel[i] = (i - 1) / Len + 1;
	for (int i = 1; i <= n; R[bel[i]] = i, i++) if (!L[bel[i]]) L[bel[i]] = i;
	for (int i = 1; i <= bel[n]; i++)
	{
		memset(g, 0, sizeof g);
		for (int j = L[i]; j <= R[i]; j++) g[a[j]] = a[j];
		for (int j = 1; j <= P; j++) if (!g[j]) g[j] = g[j - 1];
		for (int j = 1; j <= P; j++)
		{
			f[i][j] = std::max(f[i][j], g[P] % j);
			for (int k = j; k <= P; k += j)
				f[i][j] = std::max(f[i][j], g[k - 1] % j);
		}
	}
	while (m--)
	{
		int l = read() + 1, r = read() + 1, p = read(), ans = 0;
		if (l > r) std::swap(l, r);
		if (bel[l] == bel[r])
			for (int i = l; i <= r; i++) ans = std::max(ans, a[i] % p);
		else
		{
			for (int i = bel[l] + 1; i <= bel[r] - 1; i++)
				ans = std::max(ans, f[i][p]);
			for (int i = l; bel[i] == bel[l]; i++) ans = std::max(ans, a[i] % p);
			for (int i = r; bel[i] == bel[r]; i--) ans = std::max(ans, a[i] % p);
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：acniu (赞：5)

考虑对于每个区间，计算其包含哪些数。

只需维护对于每个位置，其前面最后一个 $x$ 的位置。这样就能 $O(1)$ 判断区间是否包含 $x$。

由于区间端点数很少，为 $O(m)$，可以在从左到右扫描时，$O(n)$ 维护答案，然后 $O(mx)$ 保存答案。

最后对于每个询问 $O(x)$ 统计即可。

复杂度 $O(n+mx)$

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

#define N 1000100
#define M 50100
#define K 1100

int n, m, k, a[N], l[M], r[M], p[M], pre[M][K], buc[K];
int head[N], nxt[M], cnt;


int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d", a + i), k = max(k, a[i]);
	for (int i = 1; i <= m; i++) {
		scanf("%d %d %d", l + i, r + i, p + i), l[i]++, r[i]++;
		if (l[i] > r[i])
			swap(l[i], r[i]);
	}
	
	for (int i = 1; i <= m; i++)
		nxt[i] = head[r[i]], head[r[i]] = i;
	for (int i = 1; i <= n; i++) {
		buc[a[i]] = i;
		for (int j = head[i]; j; j = nxt[j])
			memcpy(pre[j], buc, sizeof(buc));
	}
	
	for (int i = 1; i <= m; i++) {
		int ans = 0;
		for (int j = 0; j <= k; j++)
			if (pre[i][j] >= l[i])
				ans = max(ans, j % p[i]);
		printf("%d\n", ans);
	}
}
```

---

## 作者：Youth518 (赞：2)



### 分析：

今天校内互测的时候遇见的题，赛时先写出了这个复杂度正确常数极大的作法，最后优化成了其他题解的 $O(pm)$ 的形式，但是我觉得这个个做法可能更好想，所以来贡献一发最劣解，**10.09s**

**暴力 ：**

$O(nm)$的暴力没有任何意义，就不说了。我们观察数据范围发现 $n$ 很大，但是 $a_i$ 和 $p$ 很小，所以我们换个思路考虑，既然数的种类只有 1000 种，那么我们可以开 1000 个 vector 每一个里面存放大小相同的数的出现位置，这样对于每一个询问我们只需要在每一个 vector 内二分就能知道是否包含某一类数，复杂度 $O(ma\log n)$ ，亲测会 **TLE** 两个点

**正解 ：**

我们发现刚才的算法瓶颈在于多次在 vector 内二分，所以我们考虑优化，对于一个 vector 我们可以双指针扫一下，维护一下每一个询问左端点和右端点在 vector 里面出现的位置，就不需要多次二分了，这样复杂度就变成了 $O(pm+m\log m)$ 。由于这样的操作复杂度是跑满的，而且常数大概是 $3$ 左右，所以我们实际复杂度达到了 $1.5\times 10^8$ 级别，成功跑出 **10s**，但是也卡过去了

**tip:** 代码对询问的区间进行了离散化，这样把双指针预处理的空间复杂度降到了 $O(m)$

### 代码：

~~~cpp
#include<bits/stdc++.h>
#define inl inline
#define reg register
#define pb push_back

using namespace std;

inline int read()
{
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}

namespace zzc
{
	const int maxn=3e7+10,maxm=5e4+10,N=1000;
	int n,m,s,a[maxn],l[maxm],r[maxm],p[maxm],ans[maxm],lim=0;
	int f[maxm],g[maxm],cnt1,cnt2,pre[maxm],suf[maxm];
	vector<int> pos[N+5];
	
	inline void work()
	{
		n=read(),m=read();
		for(int i=0;i<n;i++) 
		{
			a[i]=read();lim=max(lim,a[i]);
			pos[a[i]].pb(i);
		}
		for(int i=1;i<=m;i++) 
		{
			l[i]=read(),r[i]=read();
			if(l[i]>r[i]) swap(l[i],r[i]);
			p[i]=read();
			f[++cnt1]=l[i];
			g[++cnt2]=r[i];
		}

		sort(f+1,f+cnt1+1);cnt1=unique(f+1,f+cnt1+1)-f-1;
		sort(g+1,g+cnt2+1);cnt2=unique(g+1,g+cnt2+1)-g-1;
		
		for(int i=1;i<=m;i++)
		{
			l[i]=lower_bound(f+1,f+cnt1+1,l[i])-f;
			r[i]=lower_bound(g+1,g+cnt2+1,r[i])-g;
		}
		
		for(int i=0;i<=lim;i++)//枚举vector进行双指针
		{
			pos[i].pb(n+1);
			int now=0,ed=pos[i].size()-1;
			for(int j=1;j<=cnt1;j++)
			{
				while(now<=ed&&pos[i][now]<f[j]) now++;
				suf[j]=pos[i][now];
			}
			
			now=1;ed=cnt2;
			for(int j=0,k=pos[i].size();j<k;j++)
			{
				while(now<=ed&&g[now]<pos[i][j])
				{
					if(j) pre[now]=pos[i][j-1];
					else pre[now]=-1;
					now++;
				}
			}
			
			for(int j=1;j<=m;j++) 
			{
				if(pre[r[j]]>=suf[l[j]])
				{
					ans[j]=max(ans[j],i%p[j]);
				}
			}
		}
		
		for(reg int i=1;i<=m;i++) printf("%d\n",ans[i]);
	
	}
}

int main()
{
	zzc::work();
	return 0;
}
~~~



---

## 作者：Jorisy (赞：0)

发现 $m,V$ 都比较小，考虑从这里入手。

不难想到将询问离线下来。

我们可以维护区间 $[l,r]$ 是否包含 $a_i$，记 $f_{i,j}$ 表示位置 $i$ 之前最靠后的 $j$ 的位置。

于是这样维护 $f$ 的时间复杂度为 $O(n+mV)$，处理询问的时间复杂度为 $O(mV)$，可以通过。

---

## 作者：wangyihao0411 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6141)

### 前言

[博客戳这里](https://www.luogu.com.cn/article/9p4mntq2)  
老师告诉我，分块是优雅的暴力 $\dots$  
[这是我们老师给我们找的题，可供练习](http://39.99.183.126:8888/homework/65b74f7f27469d42b133a49d)

### 思路

~~众所周知~~，分块是这么做的：

* 将一个需要处理的含n个数字的数组分成 $\sqrt{n}$ 份；最后如果还有剩余，则单独分成一个块。

* 预处理完成后，开始询问：如果询问范围内有整块最直接处理整块，余下的便直接单独处理。

* 因此分块原理类似于暴力，但可以优化暴力的速度，所以被老师称为优雅的暴力。

### 代码

显然分块在这道题中行得通啊。  
明显暴力会超时，但分块不会。  
所以，按照上面说的方法写就行。  
代码如下，~~你们喜欢的来了。~~  
```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N=1e6+10,Mod=1e3+10,P=1000;
int n,m,a[N],f[Mod][Mod],g[Mod],bel[N],L[N],R[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	int len=sqrt(n);
	for(int i=1;i<=n;i++)
		cin >> a[i];
	for(int i=1;i<=n;i++)
		bel[i]=(i-1)/len+1;
	for(int i=1;i<=n;i++)
	{
		R[bel[i]]=i;
		if(!L[bel[i]])
			L[bel[i]]=i;
	}
	for(int i=1;i<=bel[n];i++)
	{
		memset(g,0,sizeof g);
		for(int j=L[i];j<=R[i];j++)
			g[a[j]]=a[j];
		for(int j=1;j<=P;j++)
			if(!g[j])
				g[j]=g[j-1];
		for(int j=1;j<=P;j++)
		{
			f[i][j]=max(f[i][j], g[P] % j);
			for(int k=j;k<=P;k+=j)
				f[i][j]=max(f[i][j],g[k-1]%j);
		}
	}
	while(m--)
	{
		int l,r,p,ans=0;
		cin >> l >> r >> p;
		l++;
		r++;
		if(l>r)
			swap(l,r);
		if(bel[l]==bel[r])
			for(int i=l;i<=r;i++)
				ans=max(ans,a[i]%p);
		else
		{
			for(int i=bel[l]+1;i<=bel[r]-1;i++)
				ans=max(ans,f[i][p]);
			for(int i=l;bel[i]==bel[l];i++)
				ans=max(ans,a[i]%p);
			for(int i=r;bel[i]==bel[r];i--)
				ans=max(ans,a[i]%p);
		}
		cout << ans << endl;
	}
	return 0;
}
```

### update

 $2024/6/3$：发布该题解

---


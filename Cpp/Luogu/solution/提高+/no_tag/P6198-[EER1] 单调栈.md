# [EER1] 单调栈

## 题目描述

单调栈是一种常见的数据结构，如果你之前没有了解过，可以参考 [单调栈教程](https://www.luogu.com.cn/problemnew/solution/P5788) 帮助理解题意。

有一个长度为 $n$ 的**排列** $p_0, p_1, \cdots, p_{n-1}$，通过这个排列生成了一个长度为 $n$ 的序列 $S$，其中 $S_i$ 表示由 $p_0, p_1, \cdots, p_i$ 组成的递增单调栈的大小。

换一种说法，序列 $S$ 是由如下代码生成的：
```cpp
stack<int> stk;
int n = p.size();
vector<int> S;
for (int i = 0; i < n; i++) {
  while (!stk.empty() && p[i] <= p[stk.top()]) stk.pop();
  stk.push(i);
  S.push_back((int)stk.size());
}
```

现在给你序列 $S$ 的**一部分**，没有给出的部分可以取任意值。请你根据给出的 $S$ 复原出排列 $p$。如果有多种可能，输出字典序最小的。保证一定有解。


## 说明/提示

样例 #1 解释：样例 $1$ 的输出对应的 $S$ 序列为 1 2 2 3 4 3 1 2 2 3，可以匹配输入。可以证明这是字典序最小的可以匹配输入的排列。


对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^6$。

本题共有 $5$ 个子任务，每个子任务的限制如下：

子任务 $1$ ($5$ 分)：保证 $1 \leq n \leq 10$。

子任务 $2$ ($10$ 分)：保证给出的 $S$ 中没有 $-1$。

子任务 $3$ ($20$ 分)：保证 $1 \leq n \leq 300$。

子任务 $4$ ($20$ 分)：保证 $1 \leq n \leq 3000$。

子任务 $5$ ($45$ 分)：无特殊限制。


## 样例 #1

### 输入

```
10
1 -1 2 3 -1 3 1 -1 2 3 
```

### 输出

```
2 4 3 6 7 5 1 9 8 10
```

## 样例 #2

### 输入

```
10
1 1 2 2 3 2 3 3 4 5 
```

### 输出

```
2 1 5 4 6 3 8 7 9 10
```

# 题解

## 作者：xht (赞：14)

本来不想写这题题解的，结果发现题解区全是带 $\log$ 的屑做法......

贪心的过程很显然：

1. 若某个位置为 $-1$，把它设成前一个数的 $+1$ 即可。
2. 从区间 $[1,n]$ 开始递归处理。
3. 对于一个区间 $[l,r]$，用区间内最小的数将区间再划分为若干的个子区间。
4. 在最小的数所在的位置上，从右往左依次从小到大填数。
5. 从左往右依次处理每个子区间。

要证这个贪心，首先要证明这么做的正确性，然后证明没有更优解。

这两个证明都很 trivial，BF 的题解也有写，不是本文重点，略过。

本文的重点在于，BF 实现上面那个过程莫名其妙地用了一个 `set`。

可以线性为啥要带 $\log$，可以 `vector` 为啥要 `set`，屑（

这种题就应该出到 $10^7 \sim 10^8$ 卡死 $\log$（

没错，我写这个题解就是为了 diss BF 的（

另外，个人感觉这题也就是个 C，不知道为啥能放 E 去（

```cpp
const int N = 1e6 + 7;
int n, a[N], ans[N], t, cnt;
vi p[N], q;

void solve(int l, int r, int o) {
	if (l > r) return;
	for (int i = p[o].size() - 1; ~i; i--)
		if (p[o][i] <= r) q.pb(p[o][i]);
		else break;
	while (q.size()) ans[q.back()] = ++t, q.pop_back();
	solve(l, p[o].back() - 1, o + 1);
	int x = p[o].back();
	p[o].pop_back();
	while (p[o].size() && p[o].back() <= r)
		solve(x + 1, p[o].back() - 1, o + 1),
		x = p[o].back(), p[o].pop_back();
	solve(x + 1, r, o + 1);
}

int main() {
	rd(n), rda(a, n);
	for (int i = 1; i <= n; i++)
		if (!~a[i]) a[i] = a[i-1] + 1;
	for (int i = n; i; i--) p[a[i]].pb(i);
	solve(1, n, 1);
	for (int i = 1; i <= n; i++) print(ans[i], " \n"[i==n]);
	return 0;
}
```

---

## 作者：myee (赞：12)

---
### Update

$\LaTeX$
又双叒叕炸了的话就到我[博客](https://www.luogu.com.cn/blog/myee/solution-p6198)上去看吧。

* 2020-7-6
这篇题解已经咕了大半年了,暑假里又开始更新

* 2020-7-10
这篇题解写完了!

---
### 引言

谔谔,月赛时做完了
$O(n^2)$
算法AC

后来瞄了瞄题解发现大家都是至少
$O(n\log n)$
的算法

于是滚回去加优化了,把时间复杂度加速到了
$O(n)$
的层次

~~然鹅实际运行时间并没有多大变化,我谔谔~~

那么,我是如何加速的呢?

先看原算法。

---
### $O(n^2)$ 算法

#### $10$ 分程序

算法思路:
考虑使用动态规划解决此问题。

对于输入数据数列\(记作
$\{A_i\}$
)前
$n$
项,欲求其答案,是否可以由前
$n-1$
项的答案**经一定的修改后**获取原序列对此的答案?发现可以。

**怎么做?**

在第
$n$
时刻,对于第
$m$
项的答案,设为
$B_{n,m}$

易证
$B_{n,i}$
跑遍
$1$
到
$n$
。\(基于
$B_n$
的定义)

建立辅助数组
M[],表示
$\{A_i\}$
当前时刻前
$n$
项**至少两项**的**连续上升子序列**的**最后一项的值**的**位置**,如有多个位置满足,取**最后一项**。

请仔细咀嚼一下上面那句话,这句话**十分重要**。

则**定理**:
* $\forall A_n>A_{n-1},B_{n,n}=n,B_{n,i}=B_{n-1,i}.\\$
把M[
$A_n$
]赋值为
$n$
（显然,此时单调栈
$\mathrm{push}$
了一次而未
$\mathrm{pop}$
）
* $\forall A_n\le A_{n-1},$
则
$\mathrm{push}$
了共
$A_{n-1}-A_n+1$
次,用数组M往回翻一下,翻的过程中,
$\\B_{n,n}=\mathrm{M}[A_n],B_{n,i}=B_{n-1,i}+1$
,而最前面的
$\mathrm{M}[A_n]-1$项来说,
$B_{n,i}=B_{n-1,i}$

然后我们发现
$B_n$
就是答案。

#### 空间爆炸

可是二维数组B开不下(
${(10^6)}^2$
项)!

空间复杂度是
$O(n^2)$
的！

前功尽弃了么?

不！

考虑使用滚动数组B,则可以把空间榨取到
$O(n)$

滚动数组就不细讲了,参见以下部分代码,可以意会。

注意以下代码是由
$0$
开始计数的!

```cpp
...

int A[1000010],B[1000010];
int M[1000010]={0};

int main()
{
    int n;scanf("%d",&n);
    for(int i=0;i<n;i++)//read
        scanf("%d",A+i);
    for(int i=1;i<n;i++)
    {
        if(A[i]<=A[i-1])
        {
            for(int j=M[A[i]];j<i;j++)B[j]++;//QAQ
            B[i]=M[A[i]]+1;
        }
        else M[A[i]]=i,B[i]=i+1;
    }
    for(int i=0;i+1<n;i++)printf("%d ",B[i]);
    printf("%d\n",B[n-1]);
    return 0;
}
```

~~马蜂清奇就不怪我了~~

[代码源码](https://www.luogu.com.cn/record/31522783)
\(内容不太一样,是我比赛时原码)

发现
$Sub2$
AK.

#### $100$ 分程序

先不考虑带
$-1$
的情况,观察样例二,发现什么?

样例二输入输出数据:
```plain
10
1 1 2 2 3 2 3 3 4 5 
```
```plain
2 1 5 4 6 3 8 7 9 10
```

不难发现:
* $\forall A_n>A_{n-1},A_n=A_{n-1}+1$
\(显然,上升时单调栈只会
$\mathrm{push}$
一次而不
$\mathrm{pop}$
,故如此)
* 首项值为
$1$
\(同理)

考虑上述
$10$
分程序的过程,易有总使
$\{A_i\}$
中每项值为
$-1$
的值**最优情况**为前一项的值再
$+1$
,而首项值为
$1$
。

于是如此
$O(n)$
预处理即可。

然后你就切了这道题。

代码略。

---
### $O(n)$ 算法

以上算法很快,但是如果最坏情况一切
$A_i=1$
,直接
$O(n^2)$
给T掉

其实,原先上述那份代码,我打了\"QAQ\"标记的地方,可以再优化!

连续一段区间同时增加相同值,最后求总序列,你想到了什么?

~~树状数组~~

~~线段树~~

考虑使用数据结构**差分数列**解决。

差分数列的讲解[这里](https://www.luogu.com.cn/problem/solution/P3368)与网上都有很多,此处就略去不谈了。

贴一发
$O(n)$
的AC代码:

```cpp
#include<stdio.h>
#include<algorithm>

int A[1000010],B[1000010];
int M[1000010]={0};

int main()
{
    int n,wil;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",A+i);
    wil=A[0]=B[0]=1;M[1]=0;
    for(int i=1;i<n;i++)
        if(A[i]==-1)
            A[i]=A[i-1]+1;
    for(int i=1;i<n;i++)
    {
        if(A[i]<=A[i-1])
        {
            B[M[A[i]]]++;
            B[i]=M[A[i]]-wil;
            wil=M[A[i]]+1;
        }
        else
        {
            B[i]=i+1-wil;
            M[A[i]]=i;
            wil=i+1;
        }
    }
    printf("%d",wil=B[0]);
    for(int i=1;i<n;i++)printf(" %d",wil+=B[i]);
    putchar('\n');
    return 0;
}
```

---
### 最后
谢谢观赏!


---

## 作者：BFqwq (赞：8)

## [EE 1] 单调栈
这是我第一次在月赛上 AC E 题，发个题解纪念一下。

首先，我们先不考虑有 $-1$ 的情况。

我们先考虑所有 $1$ 的位置应该放什么数。

由于是单调栈，因此后面的 $1$ 的位置所对应的真实的数一定比前面的 $1$ 所对应的数小（否则就无法弹掉前面那个数）。

而我们又想使得第一个 $1$ 尽量小，所以我们只能让最后一个 $1$ 对应 $1$，让倒数第二个一 $1$ 对应 $2$，以此类推。

然后我们就确定了所有 $1$ 的位置所对应的数。

然后我们发现，我们把 $1$ 的位置确定之后，我们人为得在每个 $1$ 的位置将序列切断，序列变成若干个小序列。

显然，由于每个 $1$ 的出现意味着单调栈空了一次，所以这些小序列一定是互不影响的。

现在我们考虑其中一个小序列。

由于这个小序列中的所有数都大于 $1$，因此相当于已经在栈底的那个元素不会被弹出，不必再考虑。

（事实上，比栈底元素小的数都已经被别的 $1$ 占用了，也没有数能将它弹出）。

由于下面有个弹不出的元素，因此我们可以不将它计入到栈的元素中，这样的话本来栈中有 $2$ 个元素的位置就变成了 $1$ 个元素，以此类推。

然后我们就可以递归求解了。

接着我们再来考虑 $-1$ 怎么办。

答案是：等于上一个数 $+1$。

因为很显然的是，如果这个 $-1$ 小于等于上一个数，

那么在它的前面就会有别的数会受到它的影响而字典序降低。

只有当这个数是 $+1$ 的时候不会有道影响。

具体实现的时候，我们可以用 $n$ 个 $set$ 来维护某一段区间内有多少个 $i$。

然后递归处理，处理完 $1$ 后将他们分成若干小区间再处理 $2$。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(int x,char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=1919810;
int n,a[maxn],res[maxn];
int cnt;
set<int> s[maxn];
void get(int x,int l,int r){
	//cout<<x<<" "<<l<<" "<<r<<endl;
	set<int>::iterator itl,itr,it;
	if(r==l+1) return;
	itl=s[x].upper_bound(l);
	itr=s[x].lower_bound(r);
	itl--,itr--;
	for(it=itr;it!=itl;it--){
		int y=*it;
		res[y]=++cnt;
	}
	itl++;
	get(x+1,l,*itl);
	for(it=itl;it!=itr;){
		int tmp=*it;
		it++;
		int tmp2=*it;
		if(tmp2<r)get(x+1,tmp,tmp2);
	}
	get(x+1,*itr,r);
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==-1) a[i]=a[i-1]+1;
		s[a[i]].insert(i);
		s[i].insert(n+1);
		s[i].insert(0);
	}
	s[0].insert(0),s[0].insert(n+1);
	get(1,0,n+1);
	for(int i=1;i<=n;i++){
		print(res[i],' ');
	}
	return 0;
}
```

---

## 作者：AK_Dream (赞：7)

没有打洛谷月赛。。。但是此题似乎很可做 于是就花了半个多小时切掉了

### 题解

这题整体是一个贪心+递推的思路

假设我们已经确定了 由$S_1\sim S_{i-1}$推出的 字典序最小的 由$1\sim i-1$构成的**排列**$p$，以及$p$当前的递增单调栈$stk$ 注意这里的栈里存的是元素的值而不是下标

那么考虑一下怎么在$p$中插入$i$这个元素使得字典序最小

但是插入$i$这个操作我们并不好处理 

不妨这样考虑 将原来$p$中所有$\ge x$的元素全部+1 然后在$p$的末尾加上一个$x$ 容易证明这样得到的$p$序列对应的$S_1\sim S_{i-1}$仍与原来一样

那么$x$要满足什么条件才能使得$S_i$恰好为要求的值呢 考虑一下$i-1$的递增单调栈$stk$ 必须要有$stk[S_i-1]<x\le stk[S_i]$ 这样$stk[S_i]\sim stk[top]$都会被弹出

为了使字典序最小 显然我们这里就让$x=stk[S_i]$ 于是我们就得到了转移

所以算法流程如下：

已知：字典序最小的 由$1\sim i-1$构成的 满足$S_1\sim S_{i-1}$要求的排列$p$ 以及$p$当前的递增单调栈$stk$ 大小为$top$ 

取$x=stk[S_i]$ 将当前$p$中所有$\ge x$的元素+1 然后将$x$放到$p$的末尾 更新单调栈

$S_i=-1$或者$S_i>top$的时候直接把$i$扔到$p$的末尾就可以了

但是大家应该都发现了 这个是$O(n^2)$的

无非就是 将所有$\ge x$的元素+1 这一步耗费了太多时间 怎么$O(1)$或$O(\log n)$解决呢？

不用什么数据结构 这里有一个奇技♂淫巧

1.如果我们要把$i$放到$p$的末尾 我们不放$i$ 我们放一个$i*1000005$(或者乘上任意一个大于$n$的数)

2.如果我们要令$x=stk[S_i]$ 然后将当前$p$中所有$\ge x$的元素+1 我们不用去一个个+1 只需要让$x=stk[S_i]-1$然后放到末尾就完事了

最后把这么做得到的答案排个序离散化一下就得到正确答案了 就算极限情况下 符合条件的$p$是一个$n\sim 1$的倒序排列 由于我们乘的数大于$n$ 也不会出错

时间复杂度$O(n\log n)$ 不知道有没有$O(n)$做法 但是由于代码中带$\log$的只有一个`sort` 所以跑过$1e6$还是毫无压力的

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; 

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	for (; ch > '9' || ch < '0'; ch = getchar()) if (ch == '-') f = -1;
	for (; ch <= '9' && ch >= '0'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

int n, a[1000005], top;
ll stk[1000005], ans[1000005], srt[1000005], mx;

int main() {
	n = read(); 
	for (int i = 1; i <= n; i++) {
		a[i] = read();
	}
	for (ll i = 1; i <= n; i++) {
		if (a[i] == -1) {
			ans[i] = i * 1000005;
			stk[++top] = ans[i];
		} else {
			if (a[i] > top) {
				ans[i] = i * 1000005;
				stk[++top] = ans[i];
			} else {
				ans[i] = stk[a[i]] - 1;
				stk[top = a[i]] = ans[i];
			}
		}
	}
	for (int i = 1; i <= n; i++) srt[i] = ans[i];
	sort(srt + 1, srt + n + 1);
	for (int i = 1; i <= n; i++) ans[i] = lower_bound(srt + 1, srt + n + 1, ans[i]) - srt;
	for (int i = 1; i <= n; i++) printf("%lld ", ans[i]);
	return 0;
} 
```

---

## 作者：yummy (赞：5)

到最后结论部分实际上这篇题解和其他的差不多，但是我的过程和大家似乎很不一样。

## 单调树

事情要从暑假说起。我在学校里随机游走的时候，想到一个逆天问题：单调栈能不能可持久化。

如果维护单调栈的时候，不直接把元素 pop 掉，而是找到要插入的位置，直接新建一个分叉，那么就可以构成一棵树。

其实我目前也不太清楚这棵树可以拿来解决什么实际问题。

下面三条性质都可以直接用单调栈的相关概念和定义推出：

1. 单调树是个堆。
2. 单调树的兄弟点权随着节点编号增大而单调不增。
3. 题目中每个点的 $S_i$ 就是单调树上点的深度。

## 给 $S_i$ 求单调树结构

假如我们已经知道了单调树中每个结点深度，如何求出单调树的结构？

显然，对于每个点 $x$，从 $x-1$ 开始，不停地往上跳，直到当前结点深度是 $S_x-1$。

```cpp
	for(int i=1;i<=n;i++)
	{
		for(fa[i]=i-1;s[fa[i]]>=s[i];fa[i]=fa[fa[i]]);
		g[fa[i]].push_back(i);
	}
```

## 给单调树结构求点权 $p_i$

我们需要最小化 $p_i$ 的字典序。对于结点 $x$ 考虑有哪些点的编号必须小于 $x$。我们发现只有它后面的兄弟和它的祖先。

因此，当**祖先全部决策完成后**（这是贪心的前提），我们立刻给结点 $x$ 的所有孩子安排一个序号——因为我们最首要的任务是让 $x$ 的**大儿子**点权最小。

给所有孩子编好号后，我们就可以继续按照正常的先序遍历顺序给其他点编号。

```cpp
int used=0;
void obtain(int rt)
{
	for(int i=g[rt].size()-1;i>=0;i--)
	{
		used++;
		p[g[rt][i]]=used;
	}
	for(int i:g[rt])
		obtain(i);
}
```

## 求 $S_i$

完成以上两步后我们回过来考虑如何求合适的 $S_i$。

首先 $S_i$ 有平凡上界——对任意 $i$ 有 $S_i\le S_{i-1}+1$。

对于未知的 $S_i$，$S_i$ 一定越大越好吗？仔细思考我们发现确实这样。如果这一步 $S_i$ 不是最大的，那么它一定会导致某一个祖先的**兄弟数量**增多，进而导致对应的最小 $p_i$ 增大。因此，$S_i$ 越大越好。

```cpp
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&s[i]);
		if(s[i]==-1)s[i]=s[i-1]+1;
	}
	for(int i=n;i;i--)
		s[i]=max(s[i+1]-1,s[i]);
```

完整代码我就不贴了，我相信大家有能力将上面三段代码拼起来并补充合适的内容。

---

## 作者：zhouhuanyi (赞：2)

链接：https://www.luogu.com.cn/problem/P6198

题目描述：给定一个长为$n$数列$S$，求一个字典序最小的排列，使得将这个排列依次放入单调栈中序列中元素的个数与$S$一一对应。

题解：介绍一个拓扑排序的做法。

假如我们先不考虑$S_{i}!=1$的情况，先考虑一下假如我们将一个排列放入一个单调栈会有什么性质，我们发现有：

$1$.若$S_{i-1}<S_{i}$，那么肯定有$S_{i}=S_{i-1}+1$，因为最多只能增加一个数，那么我们就可以知道$p_{i-1}<p_{i}$。

$2$.若$S_{i-1}>=S_{i}$，则在这个单调栈中第$S_{i}$个元素以及后面的元素全都会被$pop$掉，那么我们就可以得到两个关系式：$p_{d_{S_{i}}}>p_{i}$,$p_{d_{S_{i}}-1}<p_{i}$。

若我们记$t_{i}$表示我们目前可以得到的最大的小于$p_{i}$的$p$序列的元素对应的下标，那么我们就可以把原问题转化为偏序问题。

我们可以发现：

$1$.当$i$始终在单调栈时，根据上面的分析，则有$t_{i}=pre_{i}$($pre_{i}$表示$i$在单调栈的前驱)

$2$.当$i$被$j$弹掉时，根据上面的分析$t_{i}=pre_{i}$或$j$，那么由于我们是要取最大的，则

假如$i$是被$j$弹掉中最小的，则$t_{i}=j$

假如$i$不是被$j$弹掉中最小的，则$t_{i}=pre_{i}$，因为$pre_{i}$被$j$弹掉，则$pre_{i}$是比$j$大的。

则我们给每一个点连一条$(t_{i},i)$的边，则原问题转化为，按照拓扑排序遍历一个有向图，令$dfn_{i}$是$i$号节点是$dfn_{i}$个被遍历的，最小化$dfn_{i}$的字典序。

我们发现，最小化$dfn_{i}$的字典序等同于遍历时尽量使$1$靠前，在$1$尽量靠前的情况下再使$2$尽量靠前......我们发现这个问题就是[$HNOI2015$]菜肴制作，所以我们只要求出在反图跑最大的的字典序的反序就可以了。

再考虑可以为$-1$的情况，这种情况可以令$S_{i}=S_{i-1}+1$，这样可以保证有解，然后你会发现这样有一定是最优的，具体我不会证。

复杂度$O(nlogn)$
```
#include<iostream>
#include<algorithm> 
#include<queue>
#define int long long
using namespace std;
struct node
{
	int v,nxt;
};
node edge[2000001];
int head[1000001],d[1000001],top,len,length,in[1000001],S[1000001],n,p[1000001],rk[1000001];
int que[1000001];
void add(int x,int y)
{
	edge[++len].v=y;
	edge[len].nxt=head[x];
	head[x]=len;
	return;
}
priority_queue<int>q;
void top_sort()
{
	int tp;
	for (int i=1;i<=n;++i)
		if (in[i]==0)
			q.push(i);
	while (!q.empty())
	{
		tp=q.top();
		d[++length]=tp;
		q.pop();
		for (int i=head[tp];i>0;i=edge[i].nxt)
		{
			in[edge[i].v]--;
			if (in[edge[i].v]==0)
				q.push(edge[i].v);
		}
	}
	return;
}
signed main()
{
	cin>>n;
	for (int i=1;i<=n;++i)
		cin>>S[i];
	for (int i=1;i<=n;++i)
		if (S[i]==-1)
			S[i]=S[i-1]+1;
	for (int i=1;i<=n;++i)
	{
		if (S[i-1]<S[i])
		{
			p[i]=i-1;
			que[++top]=i;
		}
		else
		{
			p[i]=que[S[i]-1];
			if (S[i]<=top)
				p[que[S[i]]]=i; 
			top=S[i]-1;
			que[++top]=i;
		}
	}
	for (int i=1;i<=n;++i)
		if (p[i]!=0)
		{
			add(i,p[i]);
			in[p[i]]++;
		}
	top_sort();
	for (int i=1;i<=n/2;++i)
		swap(d[i],d[n-i+1]);
	for (int i=1;i<=n;++i)
		rk[d[i]]=i;
	for (int i=1;i<=n;++i)
		cout<<rk[i]<<' ';
	cout<<endl;
	return 0;
}

---

## 作者：Fuyuki (赞：1)

假设已经得到了满足前缀 $[1,k-1]$ 的一个字典序最小的排列，那么将 $p_{k}$ 加到末尾的话，会使得前缀中所有需要比 $p_k$ 大的元素都变大。

换言之，每将 $p_k$ 减少 1，前面就会有一个元素增加 1。这样肯定不优，因此如果可能，需要尽可能增大每次新加入的元素。

因此，对于 $a_k=-1$ 的情况，为了增大 $p_k$，令 $a_k\leftarrow a_{k-1}+1$。

设 $pre_i$ 表示比 $p_i$ 小的最大元素所在下标，即前驱。

$p_k$ 需要小于被弹出元素中最小的一个，又因为需要使得 $p_k$ 尽量大，所以将最后一次被弹出的元素的前驱置为 $k$ 即可。

用类似带权并查集的方式将 $pre$ 还原成 $p$，就可以在 $O(n)$ 的时间内解决本题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
const int N=1e6+2;
int n,x,last,pre[N],sta[N],ans[N];
int val(int x){return(x&&!ans[x])&&(ans[x]=val(pre[x])+1),ans[x];}
int main(){
	scanf("%d",&n);
	FOR(i,1,n){
		last=x,scanf("%d",&x),!~x&&(x=last+1);
		pre[i]=pre[sta[x]],pre[sta[x]]=i,sta[x]=i,sta[x+1]=0;
	}
	FOR(i,1,n)cout<<val(i)<<' ';
	return 0;
}
```

---

## 作者：loveJY (赞：1)

这个提供另一种构造形式不同的$O(n)$做法qwq

其实这个难度的构造题只需要把样例玩上几遍

考场时很像遇见图论所以就来图论做法啦

我们先考虑序列中没有-1的情况,也就是说我们知道整个弹栈的序列怎么构造一个`字典序`最小的排列

`字典序`?看上去就很贪心的样子啊!

那么我们一定要让1填的数越小越好!不过位置1填的数是有限制的....

什么限制呢?如果后面有比他更小的数,那他最小也只能填`这些数的总数+1`这个数量的数!

又因为贪心,我们就填这个数就行啦

那么我们现在就是要解决如何快速有多少个数比他还小...

对应到单调栈大小序列中,其实就是看他被哪个数(A)弹出,A又被哪个数(B)弹出,B又被哪个数弹出......

这样一层一层的关系不很像一个图吗?所以我们来构思一下图模型

* i号点表示i号位置
* 边(i,j)表示i号位置上的数要大于j号位置上的数

那么原问题就变成了沿着从1号点出发这条链走,直到走到头,最深的深度是多少;

又再结合之前贪心原则,因为要填1号点,经过的所有点都需要顺便填上,`这样相当于我们一次填了一条链!`

上述构造过程显然是递归的,我们也可以在填完1的前提下去填2,只要保证2所在链最小的数大于1就行

最后说一下建图,其实就是模拟一下单调栈的过程,栈里记得是位置,加入点的时候暴力按照给出的大小序列弹数,有数被弹出就从那个数代表位置点向这个点连边

然后对于给出序列中有-1的情况,其实我们不难想到我们一定要让每条链的长度尽可能的短,这样靠前的数才能选的更小啊,所以$a[i]=a[i-1]+1$就是最有选择

因为边数是单调栈操作数级别的,$O(n)$,所以复杂度最后就是$O(n)$啦

code:

```
#include<cstdio>
#include<iostream>
#include<cstring>
#define CT const int&
using std::max;
const int MAXN=2e6+7;
int n,tp,ccnt,top;
int a[MAXN];
int nxt[MAXN],home[MAXN],to[MAXN],v[MAXN],b[MAXN];
int vis[MAXN],dep[MAXN],st[MAXN],res[MAXN];
inline void ct(CT x,CT y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void dfs(int x) {
	res[++top]=x;
	vis[x]++;
	for(int i=home[x]; i; i=nxt[i]) {
		int v=to[i];
		if(!vis[v]) {
			dfs(v);
			dep[x]=max(dep[x],dep[v]+1);
		}
	}
}

inline void solve() {
	st[tp=1]=1;
	for(int i=2; i<=n; ++i) {
		while((tp+1>a[i])) {
			ct(st[tp],i);
			--tp;
		}
		st[++tp]=i;
	}
	int base=1;
	for(int i=1; i<=n; ++i) {
		if(vis[i])continue;
		vis[i]=1;
		top=0;
		dfs(i);
		for(int k=1; k<=top; ++k) {
			int u=res[k];
			b[u]=dep[u]+base;
		}
		base+=top;
	}
	return ;

}

int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		scanf("%d",&a[i]);
		if(a[i]==-1)a[i]=a[i-1]+1;
	}
	solve();
	for(int i=1; i<=n; ++i)printf("%d ",b[i]);
	return 0;
}

```cpp




---

## 作者：Fading (赞：1)

题解全是神仙分治啊，这里给一个不用动脑子的解法。

首先考虑分析上下界，先考虑第一个数，显然$=$序列中$1$的个数。然后删去这些$1$分成子问题。这个问题有后效性，我们发现$-1$越大后效性越小（很不严谨），所以$S_i=S_{i-1}+1$就好了。

这不是重点，关键看我们怎么构造。

~~想到第一步却想不到分治真的没谁了~~

我们发现可以用$S$数组模拟单调栈。这样模拟的过程中我们可以得到$O(n)$个元素的大小限制。现在相当于给你一堆限制构造最小的字典序。

显然这个问题就可以用 拓扑排序+堆 解决了，时间复杂度$O(n\log_2n)$。

~~早知道题这么水就打洛谷月赛了，送了300分~~

---

## 作者：迟暮天复明 (赞：0)

好题啊！

首先考虑没有 $-1$ 的情况怎么搞。那么数组里面肯定有一堆 $1$，设它有 $k$ 个 $1$，那么肯定填的数字分别是 $k\sim 1$，这个很容易证明。然后每个 $1$ 后面接的一串都是互相独立的，因为字典序的缘故，所以直接从前到后依次递归解决就行了。

这段的代码长这样：

```cpp
void solve(int l,int r){
  if(l==r)return;
  std::vector<int>B;
  auto it=std::lower_bound(A[s[l]+1].begin(),A[s[l]+1].end(),l);
  int pos=std::distance(A[s[l]+1].begin(),it);
  int sz=A[s[l]+1].size();
  rep(i,pos,sz-1)if(A[s[l]+1][i]<=r)B.pb(A[s[l]+1][i]);else break;
  sz=B.size();
  nrep(i,sz-1,0)ans[B[i]]=++cnt;
  B.pb(r+1);
  rep(i,0,sz-1)solve(B[i],B[i+1]-1);
}
```

接下来就是存在 $-1$ 的情况。首先对于这样的  $s_i$，肯定要满足 $s_i\le s_{i-1}+1$。然后可以发现，在 $s_{i}\le s_{i-1}$ 的时候都会有 $a_i< a_{i-1}$，只有在 $s_i=s_{i-1}+1$ 的时候才有 $a_i>a_{i-1}$。前面的情况就相当于是 $a_i$ 挤掉了 $a_{i-1}$ 一个位置，肯定不优。所以必须采用后面的方式，也就是令 $s_i=s_{i-1}+1$。

时间复杂度 $O(n\log n)$，前面递归估计有复杂度更优的做法，但是我懒得懒了。

---

## 作者：UniGravity (赞：0)

## Solution P6198 [EER1] 单调栈
第一眼以为是 $O(n\log n)$ 的数据结构，结果想了半天。

### 思路分析
直接单调栈从 $b$ 推回 $a$ 是不行的，因为其中有些数据被删去了。

#### 那么我们在维护单调栈时**不删去数字**是不是就可以倒推了呢？

以样例为例：
![](https://cdn.luogu.com.cn/upload/image_hosting/f5nxxke5.png)

其中黑色是 $b_{id}$，蓝色是 $a_{id}$，橙色是 $id$。

这里不使用删除，而是向**上一个点连一条边**，就可以实现倒退了。

思考子任务 $2$，对于给定的 $b$，由于要求字典序最小，可以想到一种贪心的方式：
* 子节点的 $a$ 一定要大于父节点的 $a$。
* 对于同一层的数，下方的 $a$ 一定要大于上方的 $a$，可以想到**倒序排列**。

那么这个部分分就做完了：
```cpp
// 建边
for (int i = 1; i <= n; i++) {
    mxid[b[i]] = i;
    nxt[mxid[b[i] - 1]].push_back(i);
}

// 查找
void search(int x) {
    if (nxt[x].size() <= 0) return;
    // 同一层的数倒序排列
    for (int i = nxt[x].size() - 1; i >= 0; i--) {
        id++; // id 代表当前 a
        a[nxt[x][i]] = id;
    }
    // 正序搜索
    for (int i = 0; i < nxt[x].size(); i++) {
        search(nxt[x][i]);
    }
}
```

#### 那么怎么构造 $b$ 呢？
考虑有解的情况，此时只要满足 $b_i\ge b_{i+1}-1$ 即可。

由于我太蒻了，不能严谨证明，接下来会尽可能讲明白：

根据上文的构造方式，我们会发现 $b_i$ **越大越好**，因为只有尽可能的**减少跳栈操作**，才能使较大的 $a_i$ 排在较后。

那么 $b_i$ 能加就加：
```cpp
for (int i = 1; i <= n; i++) {
    scanf("%lld", &b[i]);
    if (b[i] == -1) b[i] = b[i - 1] + 1;
}
```

这样就成功切掉了这题。

### 完整代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1000005;

int n, k;
int b[N];
int a[N];
int mxid[N];
vector< int > nxt[N];
int id = 0;
int lval[N], rval[N];

void search(int x) {
	if (nxt[x].size() <= 0) return;
	for (int i = nxt[x].size() - 1; i >= 0; i--) {
		id++;
		a[nxt[x][i]] = id;
	}
	for (int i = 0; i < nxt[x].size(); i++) {
		search(nxt[x][i]);
	}
}

signed main() {
	scanf("%lld", &n);
	b[0] = 0;
	mxid[0] = 0;
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &b[i]);
		if (b[i] == -1) b[i] = b[i - 1] + 1;
	}
	
	for (int i = 1; i <= n; i++) {
		mxid[b[i]] = i;
		nxt[mxid[b[i] - 1]].push_back(i);
	}
	
	search(0);
	for (int i = 1; i <= n; i++) {
		printf("%lld ", a[i]);
	}
	return 0;
}
```
### 其他
更新：之前的图太丑了，重画了一个。

---


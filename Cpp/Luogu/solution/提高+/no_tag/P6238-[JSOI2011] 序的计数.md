# [JSOI2011] 序的计数

## 题目描述

给定无向图 $G=\{V,E\}$，其中 $n=|V|,m=|E|$，$n$ 个点从 $1$ 到 $n$ 依次编号。

现在要求利用 DFS 即深度优先搜索。容易知道，利用 DFS 进行遍历的同时，我们可以将遍历到的点按照遍历的先后顺序记录下来，这样会得到一个点的序列，即一个 $1$ 到 $n$ 的排列。我们称这个排列为一个可能的 DFS 序。

显然不是所有 $1$ 到 $n$ 的排列都可能是 DFS 序的。现在这个 DFS 的过程进行到了一半，且恰好遍历了 $k$ 个不同的点 $\{u_1,u_2,...,u_k\}$，那么显然，这个进行到一半的 DFS 过程所对应的 DFS 序应该是这 $k$ 个数的一个排列。

现在请求出，当前这 $k$ 个遍历点能对应多少个不同的长度为 $k$ 的 DFS 序呢?

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \le n \le 100$，$1 \le m \le 5 \times 10^3$，$1 \le k \le 18$，$1 \le u_i \le n$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
8 7 5
1 2
1 3
1 6
3 4
2 5
7 8
8 7
1 2 3 7 8 ```

### 输出

```
4```

# 题解

## 作者：ycx303 (赞：0)

# P6238 [JSOI2011] 序的计数题解


## 思路：
  首先构建一个新的虚拟节点连接所有目标节点，强行将其作为第一个被访问的节点，这样子就解决了图不连通的问题。
  
除了目标节点外，所有其他点都可以缩成一个节点。

这样子的图实际上只有 $k + 2$ 个节点， $k + 1$ 个目标节点。

预处理 $G[S][u]$ 表示已经在 dfs 序中出现过的点的集合为 $S$， 当前在点 $u$ 能够访问到的点。

设 $f[S][u]$ 表示当前在点 $u$ ，已经确定 dfs 序的集合为 $S$ 的 dfs 序的方案数。

注意如果一个点和不合法的点有连边，那么这个点不能回朔。

转移的时候枚举一个 $u$ 的相邻点，记忆化搜索即可。

## Code：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
#define MAXN 120
using namespace std;
inline int read() {
	int x = 0;
	bool t = false;
	char ch = getchar();
	while ((ch < '0' || ch > '9') && ch != '-')ch = getchar();
	if (ch == '-')t = true, ch = getchar();
	while (ch <= '9' && ch >= '0')x = x * 10 + ch - 48, ch = getchar();
	return t ? -x : x;
}
int n, m, K, id[MAXN], S[20];
bool g[MAXN][MAXN], M[20][20];
ll f[1 << 19][20];
int G[1 << 19][20];
int dfs(int u, int S) {
	if (~G[S][u])return G[S][u];
	int ret = 1 << u;
	for (int i = 0; i < K; ++i)
		if (M[u][i] && !(S & (1 << i)))ret |= dfs(i, S | (1 << i));
	return G[S][u] = ret;
}
ll Solve(int u, int S) {
	if (~f[S][u])return f[S][u];
	if (G[S][u] == 1 << u)return S == (1 << K) - 1 || !M[u][K];
	ll ret = 0;
	for (int i = 0; i < K; ++i)
		if (M[u][i] && !(S & (1 << i)))
			ret += Solve(i, S | (1 << i)) * Solve(u, S | G[S | (1 << i)][i]);
	return f[S][u] = ret;
}
int main() {
	n = read();
	m = read();
	K = read();
	K += 1;
	for (int i = 1, u, v; i <= m; ++i)u = read(), v = read(), g[u][v] = g[v][u] = 1;
	for (int i = 1; i <= n; ++i)id[i] = K;
	for (int i = 0; i < K - 1; ++i)S[i] = read(), id[S[i]] = i, M[i][K - 1] = M[K - 1][i] = 1;
	for (int i = 0; i <= K; ++i)
		for (int j = 1; j <= n; ++j)M[i][id[j]] |= g[S[i]][j];
	memset(G, -1, sizeof(G));
	memset(f, -1, sizeof(f));
	for (int i = 0; i < (1 << K); ++i)
		for (int j = 0; j < K; ++j)
			if (i & (1 << j))dfs(j, i);
	printf("%lld\n", Solve(K - 1, 1 << (K - 1)));
	return 0;
}
``````

---


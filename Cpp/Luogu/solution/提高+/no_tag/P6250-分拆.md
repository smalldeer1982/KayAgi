# 分拆

## 题目背景

小 W 喜欢分拆。

## 题目描述

小 W 定义了一种「良好的分拆」：

对于正整数 $n$，如果存在 $n$ 个整数 $(a_1,a_2,\cdots,a_n)$ 使得 $\sum\limits_{i=1}^na_i=\prod\limits_{i=1}^na_i=n$，那么称 $n$ 是「良好的」，而 $(a_1,a_2,\cdots,a_n)$ 是 $n$ 的一个「良好的分拆」。

现在，小 W 给了你一些 $n$，他希望你求出这些 $n$ 分别是不是「良好的」。如果是良好的，请**任意**输出一个 $n$ 的「良好的分拆」。

## 说明/提示

## 样例解释
$n=1$ 时，$(1)$ 是 $1$ 的一个「良好的分拆」；

$n=2$ 时，$2$ 没有「良好的分拆」；

$n=5$ 时，$5+1+1+(-1)+(-1)=5\times1\times1\times(-1)\times(-1)=5$，所以 $(5,1,1,-1,-1)$ 是 $5$ 的一个「良好的分拆」。
## 数据范围
**本题不捆绑测试。**  
$\text{Subtask\;1(10\;pts)}$：$n=1,T=1000$；  
$\text{Subtask\;2(30\;pts)}$：$n\le 10^4,T=100$；  
$\text{Subtask\;3(60\;pts)}$：$T=1000$。  
对于所有数据，$1\le n\le10^9$。
## 说明
本题带有 $\text{SPJ}$。

某个测试点获得满分，当且仅当对于这个测试点的所有 $T$ 组数据，有：
- 第一行的答案相同。
- 如果第一行的答案为 `YES`，则还要满足 $1\le a\le 20$，$1\le x\le n$，$\sum y\times x=\prod y^x=\sum x=n$。

**为了便于 $\text{SPJ}$ 的编写，允许有的 $y$ 相同，同时请确保在输出文件末尾有且仅有一个换行。**

$\text{SPJ}$ 源码请到[云剪贴板](https://www.luogu.com.cn/paste/tlhjg36n)查看。

## 样例 #1

### 输入

```
3
1
2
5```

### 输出

```
YES
1
1 1
NO
YES
3
1 5
2 1
2 -1```

# 题解

## 作者：WYXkk (赞：9)

upd：修改了一处笔误，感谢 [TheShadow](https://www.luogu.com.cn/user/122273) 指出。请管理重新审核。

$\text{Subtask}\;1$：看样例输出。

$\text{Subtask}\;2$：正常的爆搜应该能过。（当然你爆搜写的是假的（指正确性）就过不了）

$\text{Subtask}\;3$：~~爆搜找规律~~ 数学推导。

我们来分情况讨论。

$n=4k+1$：取一个 $n$，$2k$ 个 $1$，$2k$ 个 $-1$ 即可。

$n=4k+2$：假设可以，设 $(a_1,a_2,\cdots,a_n)$ 是 $n$ 的一个「良好的分拆」。既然 $\prod a_i=4k+2$，那么 $a_1,a_2,\cdots,a_n$ 中必定恰好有一个偶数，再根据 $\sum a_i=4k+2$，可得 $4k+1$ 个奇数和一个偶数的和是偶数，不可能。故此时 $n$ 没有「良好的分拆」。

$n=4k+3$：假设可以，设 $(a_1,a_2,\cdots,a_n)$ 是 $n$ 的一个「良好的分拆」。既然 $\prod a_i=4k+3$，那么 $a_1,a_2,\cdots,a_n$ 中必定有奇数个 $4k+3$ 型数和偶数个 $4k+1$ 型数。无论是有 $4k+1$ 个 $4k+3$ 型数和 $4k+2$ 个 $4k+1$ 型数，还是有 $4k+3$ 个 $4k+3$ 型数和 $4k$ 个 $4k+1$ 型数，其和都不是 $4k+3$ 型数。故此时 $n$ 没有「良好的分拆」。

$n=4k$：要分类讨论。

- $n=4$：没有，读者自证不难（
- $n=8k$：一个 $4k$，一个 $2$，$6k-2$ 个 $1$，$2k$ 个 $-1$。
- $n=8k+4$：一个 $4k+2$，一个 $-2$，$6k+3$ 个 $1$，$2k-1$ 个 $-1$。

按照上面的方式构造即可。

（很好奇比赛的时候有没有人找规律找出来

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

void out(int n)
{
	if(n%4==1)
	{
		puts("YES");
		if(n==1) printf("1\n1 1\n");
		else printf("3\n1 %d\n%d 1\n%d -1\n",n,n/2,n/2);
	}
	else if(n%4==2) puts("NO");
	else if(n%4==3) puts("NO");
	else
	{
		if(n%8==0)
		{
			puts("YES");
			printf("4\n1 %d\n1 2\n%d 1\n%d -1\n",n/2,n-n/4-2,n/4);
		}
		else
		{
			if(n==4) puts("NO");
			else
			{
				puts("YES");
				printf("4\n1 %d\n1 -2\n%d -1\n%d 1\n",n/2,n/4-2,n-n/4);
			}
		}
	}
}
int main()
{
	int T=rd();
	while(T--) out(rd());
	return 0;
}
```



---

## 作者：August_Light (赞：2)

# P6250 分拆 题解

[题目传送门](https://www.luogu.com.cn/problem/P6250)

600 AC 纪念。

## 题意简述

给定正整数 $n$，构造一个长度为 $n$ 的整数（可以为负）序列 $a$，使得：

$$\sum\limits_{i=1}^na_i=\prod\limits_{i=1}^na_i=n$$

输出构造或报告无解。

$n \le 10^9$。$1000$ 组数据。

## 结论

思维题我就直接先放结论了。

- $n=4$ 时无解。
- 否则 $n \equiv 0 \pmod 4$ 时，有解。
  - 当 $n = 4 \times 2k$ 时，构造的序列开头为：$4k,2$。
  - 当 $n = 4 \times (2k+1)$ 时，构造的序列开头为：$4k+2,-2,-1$。
  - 接下来一直放 $1$ 直到和为 $n$，然后一直放 $1,1,-1,-1$。
- $n \equiv 1 \pmod 4$ 时，有解，构造为：$1$ 个 $n$、$\dfrac {n-1} 2$ 个 $1$、$\dfrac {n-1} 2$ 个 $-1$。
- $n \equiv 2 \pmod 4$ 时，无解。
- $n \equiv 3 \pmod 4$ 时，无解。

## 解法

花了四天时间没看题解肝出来了。

### Day 1 (2023/6/11): $n \equiv 1 \pmod 4$

刚拿到题，观察样例发现 $1,1,-1,-1$ 的和为 $0$，积为 $1$，不会对结果产生任何影响。

当 $n \equiv 1 \pmod 4$ 时，在开头放一个 $n$，后面全塞 $1,1,-1,-1$ 就行了。

```cpp
void solve1(int n) { // n % 4 == 1
    puts("YES");
    if (n == 1) {
        puts("1");
        printf("1 %d\n", n);
        return;
    }
    int cnt = n / 2;
    puts("3");
    printf("1 %d\n", n);
    printf("%d 1\n", cnt);
    printf("%d -1\n", cnt);
}
```

也是因此想到将 $n$ 在模 $4$ 下进行讨论。

### Day 2 (2023/6/12): $n \equiv 2 \pmod 4$

手玩了几个发现 $n \equiv 2 \pmod 4$ 的时候好像会因为奇偶性导致无解。

不妨在模 $2$ 意义下考虑这个问题。

$n$ 是偶数且不是 $4$ 的倍数，说明序列中有且仅有一个偶数。

据此，$\sum\limits_{i=1}^n a_i$ 是一个奇数。

但是 $\sum\limits_{i=1}^n a_i = n$，是一个偶数。

矛盾。无解。

### Day 3 (2023/6/13): $n \equiv 3 \pmod 4$

$n \equiv 3 \pmod 4$ 不好处理，把它变成 $n \equiv -1 \pmod 4$。

在手玩的时候发现会有一车 $1$ 和 $-1$，全写出来太烦了，所以考虑列个方程组解出 $1$ 和 $-1$ 的个数，然后发现每次都无解，稍加思索后有了下面这个证明：

设序列中模 $4$ 余 $1$ 的数的个数为 $x$，模 $4$ 余 $-1$ 的数的个数为 $y$。

三个柿子的意义分别为：序列长为 $n$，序列和为 $n$，序列积为 $n$。

$$\begin{cases} x+y \equiv -1 \pmod 4 \\ x-y \equiv -1 \pmod 4 \\ y \equiv 1 \pmod 2 \end{cases}$$

发现方程组无解。

### Day 4 (2023/6/14): $n \equiv 0 \pmod 4$

手玩发现当 $n=4$ 时无解，其它好像都有解。

首先考虑可以用 $1,1,-1,-1$ 占位，但是前提是其余的序列长度是 $4$ 的倍数。

经过~~艰难的~~手玩发现：

- 当 $n = 4 \times 2k$ 时，可以构造开头为 $4k,2,1,1$ 的序列。
- 当 $n = 4 \times (2k+1)$ 时，可以构造开头为 $4k+2,-2,-1,1$ 的序列。

接下来一直放 $1$ 直到和为 $n$。

这样构造保证了每 $4$ 个数之和为 $4$ 的倍数，且满足了积为 $n$。

然后一直放 $1,1,-1,-1$ 占位。

```cpp
void solve0(int n) { // n % 4 == 0
    if (n == 4) {
        puts("NO");
        return;
    }
    puts("YES");
    puts("4");
    printf("1 %d\n", n / 2);
    int sum = n / 2; // 目前的所有数之和
    int ans1 = 0; // 1  的个数
    int ans2 = 0; // -1 的个数
    if (n % 8 == 0) {
        puts("1 2");
        sum += 2;
        sum += 1;
        ans1++;
    } else {
        puts("1 -2");
        sum -= 2;
        sum -= 1;
        ans2++;
    }

    // 一直放 1
    ans1 += n - sum;

    // 放 1 1 -1 -1 占位
    int len = n - (n - sum + 3);
    ans1 += len / 2;
    ans2 += len / 2;
    printf("%d 1\n", ans1);
    printf("%d -1\n", ans2);
}
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

// 省略快读快写的实现

void solve1(int n);

void solve0(int n);

int main() {
    for (int T = read(); T--; ) {
        int n = read();
        if (n % 4 == 2 || n % 4 == 3) {
            puts("NO");
            continue;
        }
        if (n % 4 == 1) {
            solve1(n);
            continue;
        }
        solve0(n);
    }
    return 0;
}
```


---

## 作者：DiDi123 (赞：1)

这题楼上奆佬已经写的很好了，但由于蒟蒻太弱，看起来有些费劲qwwq

这篇主要讲的细一些

# 题意
### 求是否存在 $\sum_{i=1}^n a_i  = \prod _{i=1}^n a_i = n$
# 思路
看到样例解释中用 $-1$ 和 $1$ 举例，我们可以发现：$2$ 个 $-1$ 和 $2$ 个 $1$ 相加是 $0$ ，相乘是 $1$，均不影响结果，所以可以考虑从 $n$ 对 $4$ 取模入手。

### 1. $n \equiv 1(mod\ 4 )$ ($x \equiv y(mod\ z)$ 表示 $x$ 除以 $z$ 余 $y$ ）
设 $n=4k+1$

此时就如样例情况，用 $1$ 个 $n$ ，$2k$ 个 $1$， $2k$ 个 $-1$ 即可，在此不再赘述。

### 2. $n \equiv 2(mod\ 4 )$ 

这时 $n$ 能被 $2$ 整除，不能被 $4$ 整除，由于 $\prod _{i=1}^n a_i = n$，$a_i$ 中不可以有两个偶数（否则就能被 $4$ 整除了）且必有一个模 $4$ 余 $2$ 的偶数。

故 $a$ 中有 $n-1$ 个奇数，和 $1$ 个偶数。由于奇数（$n-1$ 为奇）个奇数个奇数加一个偶数为奇数，而 $n$ 为偶数，故此时没有「良好的分拆」。

### 3. $n \equiv 3(mod\ 4 )$ 

**引理:** 若 $x \equiv a(mod\ p ),y \equiv b(mod\ p )$，则 $x \times y \equiv a \times b(mod\ p ),x + y \equiv a + b(mod\ p )$ （证明就把 $x$ 设为 $np+a$，把 $y$ 设为 $mp+b$ 再展开即可）

此时 $a$ 中不能有偶数，全都是奇数，讨论奇数种类：

- $a_p \equiv a_q \equiv 3(mod\ 4 )$ 

	则 $a_p \times a_q \equiv 3 \times 3 \equiv 1(mod\ 4 ),a_p + a_q \equiv 3 + 3 \equiv 2(mod\ 4 )$
- $a_p \equiv a_q \equiv 1(mod\ 4 )$ 

	则 $a_p \times a_q \equiv 1 \times 1 \equiv 1(mod\ 4 ),a_p + a_q \equiv 1+1 \equiv 2(mod\ 4 )$

发现此时两种奇数做偶数次乘法都是模 $4$ 余 $1$，故需要奇数个模 $4$ 余 $3$ 的奇数。

由于 $n$ 为奇数，所以还需要偶数个模 $4$ 余 $1$ 的奇数。

设需要 $x$ 个模 $4$ 余 $1$ 的奇数 $b$，需要 $y$ 个模 $4$ 余 $3$ 的奇数 $b'$（$x+y=n$）。

- $x \equiv 0(mod\ 4 )$

	则 $y \equiv n-x \equiv 3(mod\ 4 ) \Rightarrow n \equiv y \times b'+x \times b \equiv 3\times 3 + 0 \times 1\equiv 1(mod\ 4 ) $，此时 $n \not\equiv 3(mod\ 4 )$，矛盾。
    
- $x \equiv 2(mod\ 4 )$

	则 $y \equiv n-x \equiv 1(mod\ 4 ) \Rightarrow n \equiv y \times b'+x \times b \equiv 1\times 3 + 2 \times 1\equiv 1(mod\ 4 ) $，此时 $n \not\equiv 3(mod\ 4 )$，矛盾。
    
**故 $n \equiv 3(mod\ 4 )$ 时没有「良好的分拆」**

### 4. $n \equiv 0(mod\ 4 )$ 

$n=4$ 不行，证明此处略。

设 $n=4k$，可以先构造 $2k-2$ 个 $-1$ 和 $2k-2$ 个 $1$，然后需要考虑如何构造四个数，使其积和和都为 $4k$。

由于 $4k=2 \times 2 \times k$，发现 $2k \times 2 \times(-1) \times (-1)$ 积是对的，但和小了，可以尝试调整 $1$ 和 $-1$ 的个数，让 $-1$ 少 $k$ 个，让 $1$ 多 $k$ 个，但此时 $-1$ 有 $k-2$ 个，有可能乘出来是负的，所以考虑讨论 $k$ 的奇偶性。

- $k$ 为偶（即 $n|8$）

	这时如上面构造的方法即可（$2k \times 2 \times (-1)^k \times 1^{3k-2}$）
    
-  $k$ 为奇

	构造：$2k \times (-2) \times (-1)^{k-2} \times 1^{3k}$
    
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int t, n;
	cin >> t;
	while (t--) {
		cin >> n;
		int k = n / 4;
		switch (n % 4) {
			case 1:
				if (n == 1) {
					cout << "YES" << endl;
					cout << 1 << endl;
					cout << 1 << ' ' << 1 << endl;
					break;
				}
				cout << "YES" << endl;
				cout << 3 << endl;
				cout << 1 << ' ' << n << endl << 2 * k << ' ' << 1 << endl << 2 * k << ' ' << -1 << endl;
				break;
			case 2:
				cout << "NO" << endl;
				break;
			case 3:
				cout << "NO" << endl;
				break;
			case 0:
				if (n == 4) {
					cout << "NO" << endl;
					break;
				}
				cout << "YES" << endl;
				cout << 4 << endl;
				if (k % 2) cout << 1 << ' ' << 2 * k << endl << 1 << ' ' << -2 << endl << k - 2 << ' ' << -1 << endl << 3 * k << ' ' << 1 << endl;
				else cout << 1 << ' ' << 2 * k << endl << 1 << ' ' << 2 << endl << k << ' ' << -1 << endl << 3 * k - 2 << ' ' << 1 << endl;
				break;
		}
	}
}
```


---

## 作者：TemplateClass (赞：0)

又是分讨。

发现当 $n \equiv 1 \pmod 4$ 时，构造一个 $n$，然后跟着相同数量的 $-1$ 和 $1$ 即可。

因此我们可以想到对 $n$ 对 $4$ 取模得到的结果进行分讨。

当 $n \equiv 2 \pmod 4$ 时，发现 $\prod a _ i = n \Rightarrow a _ 1, a _ 2, a _ 3, \cdots, a _ n$ 中恰有一个偶数，而 $\sum a _ i = n \Rightarrow (n - 1)$ 个奇数和一个偶数的和是偶数，显然不成立，因此此时无解。

类似上面的，当 $n \equiv 3 \pmod 4$ 时，可以得到这 $n$ 个数中有奇数个模 $4$ 余 $3$ 的数和偶数个模 $4$ 余 $1$ 的数，容易推出矛盾。

对于 $4 \mid n$ 的情况，我们需要更精细的分类讨论。不难证明 $n = 4$ 时无解，$8 \mid n$ 时假设 $n = 8k$ 则构造一个 $2$ 和一个 $4k$，$(6k - 2)$ 个 $1$ 和 $2k$ 个 $-1$；不整除时设 $n = 8k + 4$ 则构造一个 $(4k + 2)$ 和一个 $-2$，$(6k + 3)$ 个 $1$，$(2k - 1)$ 个 $-1$ 即可。

```cpp
inline void solve() {
	int n; std::cin >> n;
	if(n % 4 == 2 || n % 4 == 3) std::cout << "NO\n";
	else if(n % 4 == 1) {
		if(n ^ 1) std::cout << "YES\n3\n1 " << n << "\n" << n / 2 << " 1\n" << n / 2 << " -1\n";
		else std::cout << "YES\n1\n1 1\n";
	} else {
		int k = n >> 3;
		if(n == 4) std::cout << "NO\n";
		else if(n % 8 == 0) {
			std::cout << "YES\n4\n1 2\n1 " << 4 * k << "\n" << 6 * k - 2 << " 1\n" << 2 * k << " -1\n";
		} else {
			std::cout << "YES\n4\n1 -2\n1 " << 4 * k + 2 << "\n" << 6 * k + 3 << " 1\n" << 2 * k - 1 << " -1\n";
		}
	}
}
```

---


# [COCI 2016/2017 #1] Kralj

## 题目描述

矮人国和精灵国即将爆发战争！精灵王 Slavko 将 $n$ 个精灵编号为 $1\dots n$。矮人王 Mirko 则让 $n$ 个矮人围成一个圆环，从某个矮人开始顺时针编号为 $1\dots n$。

接下来，Mirko 将为每个精灵分配一个数字 $a_i$，表示将与它们决斗的矮人的编号。然而，由于他的粗心，不同精灵分配到的数字可能是相同的。

为了决斗的公平，双方决定：

1.  Slavko 选出一位尚未确定对手的精灵，设其编号为 $i$。
2.  若编号为 $a_i$ 的矮人尚未确定对手，则将其作为这位精灵的对手。否则，从编号为 $a_i$ 的矮人开始，选择沿圆环顺时针方向第一个尚未确定对手的矮人作为这位精灵的对手。
3.  重复以上步骤，直到所有矮人及精灵都确定了对手。

Slavko 收集了所有矮人及精灵的力量值。决斗时，力量值大的一方总是获胜。他想知道，通过规划选择精灵的顺序，最多能有多少精灵在决斗中获胜。

## 说明/提示

#### 样例 1 解释

Slavko 以 $3,2,1$ 的顺序选择精灵。

这样，编号为 $1,2,3$ 的精灵的对手编号分别为 $2,1,3$。

编号为 $1,2$ 的精灵将在决斗中获胜。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 5\times 10^5$，$1\le a_i\le n$，$1\le p_i,v_i\le 10^9$。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T5 Kralj_**。

## 样例 #1

### 输入

```
3
2 3 3
4 1 10
2 7 3 ```

### 输出

```
2 ```

## 样例 #2

### 输入

```
4
3 1 3 3
5 8 7 10
4 1 2 6 ```

### 输出

```
1 ```

## 样例 #3

### 输入

```
3
1 2 3
8 4 3
9 2 6 ```

### 输出

```
2 ```

# 题解

## 作者：Azazеl (赞：12)

### P6288 [COCI2016-2017#1] Kralj

#### 题目传送门  

>[P6288](https://www.luogu.com.cn/problem/P6288)



------------

#### 写在前面的废话

$\ \ \ \ $今天考试的一道妙妙题，考场上看出来是贪心的，甚至贪心策略都是对的，但没想到这题难点不在贪心策略 ~~，并且考场上时空双爆~~，建议蓝/紫。  

------------

#### 题解  

$\ \ \ \ $ **第一部分**（洛谷上没有）：$\forall i\le n,a_i=1$ ，即所有 $a_i$ 都为 $1$ 。  

$\ \ \ \ $ 我们稍微想一想，就会发现，我们安排的精灵是第多少个进入，就会与第几个侏儒战斗，因此就变成一个序列的问题。  

$\ \ \ \ $ 参考田忌赛马的策略，我们将两个力量序列均升序排列后，依次看现在在队首的精灵能否打败侏儒，如果能则安排它与对应的侏儒对战，否则安排它与战力最强的侏儒战斗，进行消耗。  

$\ \ \ \ $ 具体来说，将两个力量序列升序排列，对每个序列分别设置指针，判断指针指向的元素的大小关系。若精灵这边较大，则答案 $+1$，指针分别后移，否则单独后移精灵序列的指针即可。  

$\ \ \ \ $ ~~然后你就会发现这其实是[P1650 田忌赛马](https://www.luogu.com.cn/problem/P1650)的弱化版~~  

$\mathcal{CODE}$ （未单独判断是否满足特殊情况）

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int arr[500005],s1[500005],s2[500005];
int main() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&arr[i]);
	for(int i=1;i<=n;i++) scanf("%d",&s1[i]);
	for(int i=1;i<=n;i++) scanf("%d",&s2[i]);
	sort(s1+1,s1+1+n);sort(s2+1,s2+1+n);
	int z1=1,z2=1,ans=0;
	while(z1<=n&&z2<=n)
	{
		if(s1[z1]<s2[z2]) z1++,z2++,ans++;
		else z2++;
	}
	printf("%d",ans);
	return 0;
}
```

$\ \ \ \ $**第二部分**：  

$\ \ \ \ $ 刚才其实我们已经找到了本题的贪心策略，每次将能走到当前位置的精灵与现在位置的侏儒的力量作比较，有能打败该侏儒的精灵则选取当前满足条件的力量最小的精灵，否则就拿力量最小的精灵当炮灰去消耗对方，即田忌赛马的策略。  

$\ \ \ \ $ 现在的问题是，每一个位置也许都会有精灵从之前的位置走下来，因此很难找到一个合适的位置开始将精灵与侏儒进行匹配。~~（考场上没想到这点的我直接从 $1$ 开始跑然后卡死）~~  

$\ \ \ \ $ 因此，如果我们能找到一个位置使得没有精灵能从这个位置的逆时针方向走过来，那么它就可以作为起点。  

$\ \ \ \ $ 那么怎么才能找到这个位置呢？  

$\ \ \ \ $ 设：$d_i$ 表示 $[1,i]$ 位置之内总共安排多少精灵初始进入，即 $a$ 的桶的前缀和。  

$\ \ \ \ $ 可得当且仅当`初始精灵数>座位数` ，即 $d_{j}-d_{i-1}>j-i+1$ 时，区间 $[i,j]$ 内的精灵会走到外面去。  

$\ \ \ \ $ 移项变为 $d_j-j>d_{i-1}-(i-1)$ 使不等式两边变为相似构造。并令 $P_i=d_i-i$ 。  

$\ \ \ \ $ 上式变形为 $P_j>P_{i-1}$ ，表示会有精灵经过 $j$ 到达 $j+1$ 。换句话说，如果有任意 $P_i < P_j$ , $j+1$ 就一定会被从 $j$ 来的精灵经过，就那么当我们找到一个 $j$ ，使得 $P_j$ 为 $\{P\}_{\min}$ 时，就一定没有精灵会经过 $j$ 到达 $j+1$ ， $j+1$ 就是我们要找的起点。    

$\ \ \ \ $ 找到起点后，我们就可以根据上面的思路贪心了，具体的实现和细节可以见代码。  

$\mathcal{CODE}$ 

```cpp
#include <set>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
int n;
int arr[500005],s1[500005],s2[500005],d[500005];
set<int> S;
vector <int> s[500005];
set<int>::iterator it;
int solve(int sta)
{
	int ans=0,matched=0,now=sta;
	while(matched<n)
	{
		for(int i=0;i<s[now].size();i++) S.insert(s[now][i]);
		it=S.lower_bound(s1[now]);
		S.size();
		if(it==S.end()) S.erase(S.begin());
		else S.erase(it),ans++;
		matched++;
		now++;
		if(now>n) now-=n;
	}
	return ans;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&arr[i]),d[arr[i]]++;
	for(int i=1;i<=n;i++) scanf("%d",&s1[i]);
	for(int i=1;i<=n;i++) scanf("%d",&s2[i]),s[arr[i]].push_back(s2[i]);
	int minn=1e9,min_index=-1e9;
	for(int i=1;i<=n;i++)
	{
		d[i]+=d[i-1];
		if(d[i]-i<minn) minn=d[i]-i,min_index=i;
	}
	int sta=min_index+1;
	if(sta>n) sta-=n;
	printf("%d",solve(sta));
	return 0;
}
```



---

## 作者：Strelitzia (赞：6)

#### [题目传送门](https://www.luogu.com.cn/problem/P6288)

-------

这道题读题都有点难，大概的意思是：

每个小精灵都以一个可爱的小矮人~~朋友~~对手，他们要相互战斗，

但小精灵的对手可能是同一人，所以当精灵的矮人对手有了对手，就

从选定的矮人开始，选择沿圆环顺时针方向第一个尚未确定对手的矮人

作为这位精灵的对手。

目的：使精灵获胜最多。

~~好吧我解释的不好~~

-------

考虑怎么做？

引入一道题[田忌赛马](https://www.luogu.com.cn/problem/P1650)

如果没有限制，自由匹配，就是一道田忌赛马，贪心就好了，

考虑每个~~可爱的~~矮人，记录下想和他玩的精灵数目 —— $\texttt{sum[i]}$。

$\texttt{l,r}$两个矮人之间的有$\texttt{sum[r] - sum[l - 1]}$个精灵，

但是$\texttt{l,r}$之间只有$\texttt{r - l + 1}$个矮人。

看出如果$\texttt{sum[r] - sum[l - 1] > r - l + 1}$时，

也就是$\texttt{sum[r] - r > sum[l - 1] - (l - 1)}$时，

会有精灵从之间走出。

我们找一个点$\texttt{k}$满足任意$\texttt{i}$,$\texttt{sum[i] - i > sum[k] - k}$。

我们可以从处断成链，然后一个不算难的贪心带走这道题。


$\texttt{update:}$补充一点，为什么我们的链的起点安排在$\texttt{k+1}$，因为这样可以保证没有精灵从前面走到$\texttt{k+1}$。

这样

贪心想法：

每找比矮人攻击力大且差值最小的精灵进行攻击，或者就拿最菜的抵掉。

代码：

```cpp
#include <set>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int maxn = 500005;
int n,a[maxn],v[maxn],id[maxn],p[maxn],sum[maxn];
bool cmp(int x,int y) {
	return x > y;
}
vector<int> G[maxn];
set<int> s;
int main () {
	read(n);
	bool flag = 1;
	for (int i = 1 ; i <= n ; ++ i) read(a[i]),flag &= a[i] == 1;
	for (int i = 1 ; i <= n ; ++ i) read(p[i]);
	for (int i = 1 ; i <= n ; ++ i) read(v[i]);
	for (int i = 1 ; i <= n ; ++ i) sum[a[i]] ++;
	for (int i = 1 ; i <= n ; ++ i) sum[i] += sum[i - 1];
	int ans = 0;
	if (flag == 1) {					//这个是在考场上没想出正解大的骗分。。。。。
		sort(p + 1,p + 1 + n,cmp);
		sort(v + 1,v + 1 + n,cmp);
		int l1 = 1,r1 = n,l2 = 1,r2 = n;
		while (l1 <= r1) {
			if (v[l1] > p[l2]) {
				ans ++;
				l1 ++,l2 ++;
			}
			else if (v[l1] < p[l2]) {
				l2 ++;
				r1 --;
			}
			else if (v[r1] > p[r2]) {
				r1 --;
				r2 --;
				ans ++;
			}
		}
		printf("%d\n",ans);
		return 0;
	}
	int minn = 99999,pos;
	for (int i = 1 ; i <= n ; ++ i) {
		G[a[i]].push_back(v[i]);
		if (sum[i] - i < minn) {
			minn = sum[i] - i;
			pos = i;
		}
	}
	pos = pos % n + 1;
	set<int>::iterator it;
	for (int i = 1 ; i <= n ; ++ i) {
		for (int j = 0 ; j < G[pos].size() ; ++ j) s.insert(G[pos][j]);
		it = s.upper_bound(p[pos]);
		if (it == s.end()) s.erase(s.begin());
		else ans ++,s.erase(it);
		pos = pos % n + 1;
	}
	print(ans);
	return 0;
}
```

这道题的难点就在处理环，这一步想通了就好了。

欢迎交流讨论，毕竟本人太菜，可能有些地方讲错了，请指出。

---

## 作者：佩了个佩pei (赞：5)

### - ~~这是一个LJ考生的悲惨心路历程T_T~~

因为这道题在我的模拟考试当中是最后一道题，所以看到这道题的时候内心已经被之前的题折磨到麻木了，所以当场开始了不做人计划。

首先就是完全无视“补位这个环节”，直接在输入精灵战斗力的时候与这个矮子比较大小，如果大，答案+1，然后输出，附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500001],b[500001],c[500001][2];
int n,t(0),ma(0);
int main()
{
    scanf("%d",&n);
    for(register int i(1);i <= n;++ i)
    {
        scanf("%d",&c[i][0]);
        a[c[i][0]] += 1;
    }
    for(register int i(1);i <= n;++ i)
        scanf("%d",&b[i]);
    for(register int i(1);i <= n;++ i)
        scanf("%d",&c[i][1]);
    for(register int i(1);i <= n;++ i)
    {
        if(a[i] == 1)
            if(c[i][1] > b[i])
                ma += 1;
    }
    cout << ma;
    return 0;
}
```
在我的模拟考试中，这个代码奇迹般的有8分，在LUOGU上自然的全WA。。

于是为了骗到更多的得分，就开始继续优化这份玄学代码。

然后我考虑无视“精灵的初始对手”这一设定，让所有的精灵都可以自由的选择要和哪个矮子进行战斗，这样的话将精灵和矮子都按照战斗力从小到大的顺序排序，然后让每一个精灵都尽可能地对上战斗力最大的，而且比自己战斗力小的矮子就可以了，是一个类似于田忌赛马的贪心思路，附上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500001],b[500001],c[500001],d[500001];
int n,t(0),ma(0);
int main()
{
    scanf("%d",&n);
    for(register int i(1);i <= n;++ i)
    {
        scanf("%d",&c[i]);
        a[c[i]] += 1;
    }
    for(register int i(1);i <= n;++ i)
        scanf("%d",&b[i]);
    for(register int i(1);i <= n;++ i)
        scanf("%d",&d[i]);
//    for(register int i(1);i <= n;++ i)
//    {
//        if(a[i] == 1)
//        {
//            if(c[i][1] > b[i])
//                ma += 1;
//            a[i] -= 1;
//        }
//    }
    sort(b + 1,b + n + 1);
    sort(d + 1,d + n + 1);
    int p(1);
    for(register int i(1);i <= n;++ i)
    {
        for(register int j(p);j <= n;++ j)
        {
            if(d[i] > b[j])
            {
                ma += 1;
                p = j + 1;
                break;
            }
        }
    }
    cout << ma;
    return 0;
}
```
这份代码考试时31分，LUOGU上10分，而且有一部分超时，于是我们仔细观察这份代码，可以发现，在进行运算的时候，根本不需要从p循环到n个矮子，因为如果这个精灵打不过第p个矮子，那他去和后面更强的矮子打就更不可能打的过了，所以完全可以删除这部分无用的循环，附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500001],b[500001],c[500001],d[500001];
int n,t(0),ma(0);
int main()
{
    scanf("%d",&n);
    for(register int i(1);i <= n;++ i)
    {
        scanf("%d",&c[i]);
        a[c[i]] += 1;
    }
    for(register int i(1);i <= n;++ i)
        scanf("%d",&b[i]);
    for(register int i(1);i <= n;++ i)
        scanf("%d",&d[i]);
//    for(register int i(1);i <= n;++ i)
//    {
//        if(a[i] == 1)
//        {
//            if(c[i][1] > b[i])
//                ma += 1;
//            a[i] -= 1;
//        }
//    }
    sort(b + 1,b + n + 1);
    sort(d + 1,d + n + 1);
    int p(1);
    for(register int i(1);i <= n;++ i)
    {
        if(d[i] > b[p])
        {
            ma += 1;
            p += 1;
        }
    }
    cout << ma;
    return 0;
}
```
这个代码考试时54分，LUOGU上40分，也是标准的田忌赛马的解法，但是呢这里有个问题是，如果我们将这种解法放到每一个矮子上，然后一直顺着推下去的话，在我们的出发点前可能会有精灵不到出发点来，导致我们很难以去计算（我就是因为这个在考试的时候死活搞不定这道题T_T）在参考了大佬们的解法后，我猛地意识到，这个换的处理不是一个标准的前缀和吗？

其实我们只需要令一个数组d[i]来储存和第1个矮子到和第i个矮子打的精灵总数。举个例子，如果有2个精灵和第1个矮子打，有3个精灵和第2个矮子打，那么d[2] = 5。

从而我们枚举任意i,j(j > i)，所以i到j之间就有j-i+1个矮子和d[j]-d[i-1]个精灵，当i到j之间的精灵数量大于矮子数量的时候，这当中的精灵就会补到第j+1个矮子那里，反之第j+1个精灵就不会有前面的补到他这一位,而我们使用一点简单的数列的思想，将上式转化一下，变成d[j]-j>d[i-1]-(i-1)于是我们可以再建一个数组P[i]=d[i]-i所以上式再次化简为P[j]>P[i-1]由于i是任意取的一个数，所以可以简化成P[j]>P[i]

而通过上面的分析，我们知道要找到一个点j，使得他的P与任意一个i满足P[j]<=P[i]，所以我们只需要找到最小的那个P，那该P一定是满足的，然后在从找到的那个点与其后一个点切开，将环化为线，再从该点后一个点也就是线的起点开始计算即可，附上代码（参考大佬的代码，并对其进行了优化）
```cpp
#include <bits/stdc++.h>
using namespace std;
int arr[500005],s1[500005],s2[500005],d[500005],n;
vector <int> s[500005];
set<int>::iterator it;
set<int> S;
inline int read()
{
	register int x(0),f(1);
	register char c(getchar());
	while(c > '9' || c < '0')
	{
		if(c == '-')
			f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}
inline int solve(register int sta)
{
	register int ans(0),matched(0),now(sta);
	while(matched < n)
	{
		for(register int i(0);i < s[now].size();++ i)
			S.insert(s[now][i]);
		it = S.lower_bound(s1[now]);
		if(it == S.end())
			S.erase(S.begin());
		else
			S.erase(it),++ ans;
		++ matched,++ now;
		if(now > n)
			now -= n;
	}
	return ans;
}
int main()
{
	register int minn(1e9),min_index;
	n = read();
	for(register int i(1);i <= n;++ i)
		arr[i] = read(),++ d[arr[i]];
	for(register int i(1);i <= n;++ i)
		s1[i] = read();
	for(register int i(1);i <= n;++ i)
		s2[i] = read(),s[arr[i]].push_back(s2[i]);
	for(register int i(1);i <= n;++ i)
	{
		d[i] += d[i - 1];
		if(d[i] - i < minn)
			minn = d[i] - i,min_index = i;
	}
	register int sta(min_index + 1);
	if(sta > n)
		sta -= n;
	printf("%d",solve(sta));
	return 0;
}
```


---

## 作者：chihik (赞：5)

[COCI2016-2017#1题解](https://www.luogu.com.cn/blog/chihik/post-2019-7-9-shu-jia-pei-xun-di-yi-ce)

因为题面不一样，作者也懒得改，所以以下兽人指侏儒，骑士指精灵

#### 1.40分思路

​		兽王给每个勇士选择的对手都是 1 号兽人，那么，GM所指定骑士的顺序就一定是兽人的编号，即第i个骑士对第i个兽人。现在我们只需找一种骑士的排法，使得胜场数最大。

​		贪心的想，最强的骑士对比他弱的兽人中最强的，第二强的骑士对比他弱的兽人中最强的······直到某一位骑士无法打败任何一人。可以排序后用单调性优化。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN = 500000;
int n,a[ MAXN + 5 ],p[ MAXN + 5 ],v[ MAXN + 5 ];

bool cmp( const int &x , const int &y ) {
	return x > y;
}
int main( ) {
	//freopen("Kralj.in","r",stdin);
	//freopen("Kralj.out","w",stdout);
	scanf("%d",&n);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&a[ i ]);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&p[ i ]);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&v[ i ]);
	sort( p + 1 , p + n + 1 , cmp );
	sort( v + 1 , v + n + 1 , cmp );
	
	int Ans = 0 , last = 1;
	for( int i = 1 ; i <= n ; i ++ ) {
		for( int j = last ; j <= n ; j ++ ) {
			if( v[ i ] > p[ j ] ) {
				Ans ++;
				last = j + 1;
				break;
			}
			if( j == n && v[ i ] < p[ j ] ) last = n + 1;
		}
			
		if( last == n + 1 ) break;
	}
	printf("%d",Ans);
	return 0;
}
```



#### 2.100分思路

假设骑士走到$a_i$后就停下，不继续向前找兽人，我们用$pre[i]$表示$i$与$i$之前的节点骑士的个数。

当一个区间$[i,j]$内的骑士多于该区间的兽人时，可表示为：
$$
pre[i]-pre[j-1]>i-j+1
$$
移项得：
$$
pre[i]-i>pre[j-1]-(j-1)
$$
令$P_i=pre[i]-i$，则$P_i>P_{j-1}$。由定义可得，$P_i$的意思是这个点之前的骑士与兽人的数量之差，我们设$P_m=min\{p_i\}$。则一定没有骑士从 $m$ 走到 $m+1$ 。证明如下：

因为$P_m$最小，所以对于任意$P_i$，$P_m-P_i≤0$，即m之前的骑士都能找到对应的兽人。所以我们可以在 $m$ 处剖开链，贪心模拟。

​	我们从 $m+1$ 开始，用 $S$ 表示没有坐好的骑士的集合。每次到达新的点，先加入停留在这个点上的所有骑士。现在可能有多个骑士对一个兽人，显然我们应该用实力高于这个兽人中实力最小的骑士来面对它，可以用二分求出，答案加 $1$。剩下的骑士向前移。如果没有骑士大于兽人的实力，就将骑士实力最弱的留下当炮灰。

注意跑环时，$n+1$就是$1$，特判一下。

```cpp
#include <cstdio>
#include <vector>
#include <set>
using namespace std;

const int MAXN = 500000;
int n,a[ MAXN + 5 ],p[ MAXN + 5 ],v[ MAXN + 5 ];
int pre[ MAXN + 5 ],s[ MAXN + 5 ];
int Min = 0x3f3f3f3f , Min_dex;
vector< int > vec[ MAXN + 5 ];
set< int > Set;

int solve( int x ) {
	int Ans = 0 , tot = 1;
	while( tot <= n ) {
		for( int i = 0 ; i < vec[ x ].size( ) ; i ++ )
			Set.insert( vec[ x ][ i ] );
		auto it = Set.lower_bound( p[ x ] );
		if( it == Set.end() )
			Set.erase( Set.begin() );
		else {
			Set.erase( it );
			Ans ++;
		}
		tot ++;
		x = ( x + 1 ) > n ? 1 : x + 1;
	}
	return Ans;
}
int main( ) {
	//freopen("Kralj.in","r",stdin);
	//freopen("Kralj.out","w",stdout);
	scanf("%d",&n);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&a[ i ]);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&p[ i ]);
	for( int i = 1 ; i <= n ; i ++ )
		scanf("%d",&v[ i ]);
	for( int i = 1 ; i <= n ; i ++ ) {
		pre[ a[ i ] ] ++;
		vec[ a[ i ] ].push_back( v[ i ] );
	}
	for( int i = 1 ; i <= n ; i ++ ) {
		pre[ i ] += pre[ i - 1 ];
		s[ i ] = pre[ i ] - i;
		if( s[ i ] < Min ) {
			Min = s[ i ];
			Min_dex = i;
		}
	}
	int cut = ( Min_dex + 1 ) > n ? 1 : ( Min_dex + 1 );
	printf("%d",solve( cut ));
	return 0;
}
```



---

## 作者：VioletIsMyLove (赞：4)

刚拿到题就有了40分的解法，田忌赛马嘛，但不能用 $n^2$的方法。

然后说说正解。将每个精灵放在小矮人的后面，这可以用 $vector$ +边表或者邻接表（推荐）来处理，然后对于每个小矮人，如果他后面有精灵，那就找他后面精灵中比他战斗力高的战斗力最低的精灵来处理，最大值中取最小，典型的二分，这里需要用集合加上 $upper$_$bound$ 来处理。都处理好了，来枚举起点，我们从节点1开始，转一圈，将每个矮人后面的精灵都投影到后面的矮人身上，如果一个矮人身上没有精灵，那就假设这个矮人后面最近的一个身上有精灵的矮人为起点，转一圈后最后假设为起点的矮人就是起点！这样就ok了。

Code:

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
using namespace std;
int N,cnt,A[MAXN],P[MAXN],V[MAXN],w[MAXN],son[MAXN],nxt[MAXN],lnk[MAXN],hsh[MAXN];
set<int> S;
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
void add_e(int x,int y,int z){hsh[x]++;w[++cnt]=z;son[cnt]=y;nxt[cnt]=lnk[x];lnk[x]=cnt;}
int main() {
    N=read();
    for (int i=1;i<=N;i++) A[i]=read();
    for (int i=1;i<=N;i++) P[i]=read();
    for (int i=1;i<=N;i++) V[i]=read();
    for (int i=1;i<=N;i++) add_e(A[i],i,V[i]);
    int W=1,Sum=0;
    for (int i=1;i<=N;i++) {
        Sum+=hsh[i];
        if (--Sum<0) W=i%N+1,Sum=0;
    }
    int win=0;
    for (int i=1,j=W;i<=N;i++,j=j%N+1) {
        for (int k=lnk[j];k;k=nxt[k]) S.insert(w[son[k]]);
        if (*S.rbegin()<P[j]) S.erase(S.begin()); else S.erase(S.upper_bound(P[j])),win++;
    }
    printf("%d\n",win);
    return 0;
}
```


---

## 作者：ppip (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/solution/P6288)

问题太难了。我们尝试先解决在一条链上的情况。


首先，第一个矮人只能被 $a_x=1$ 的精灵打到。
那么，由于总要有一个精灵去打它，如果有打得过它的就挑选最小的满足的，否则就选一个最弱的占位。
剩下的 $a_x=1$ 的精灵相当于 $a_x=2$，对余下矮人递归处理即可。
这可以用 `std::multiset` 维护。$\Theta(n\lg n)$。

要将该算法扩展至环上，只需要找到一个位置，使得不可能有精灵从逆时针位置走下来。
这样的位置是否存在呢？

我们这么考虑：令 $f(l,r)=\sum_{i=1}^n[l\leq a_i\leq r]$，$d(l,r)=r-l+1$。

首先，如果存在区间 $[l,r]$，使得 $f(l,r)>d(l,r)$，那么 $r+1$ 一定不是一个合法的位置。

这很好理解，目标为该区间的精灵超过了该区间的矮人数。

其次，如果存在区间 $[l,r]$，使得 $f(l,r)<d(l,r)$，那么 $l$ 一定不是一个合法的位置。

目标为区间少于该区间矮人数，上面必定会补下来。

那么位置 $i$ 不会有精灵从逆时针走下来，当且仅当对于所有的 $j<i$，$f(j,i-1)\leq d(j,i-1)$，且对于所有的 $j\geq i$，$f(i,j)\geq d(i,j)$。

但是 $\Theta(n^2)$ 找合法位置太慢了。
考虑令 $s_x=f(1,x)$。则分解第一式得：

$$
s_{i-1}-s_{j-1}\leq (i-1)-j+1\\
$$

移项

$$
s_{i-1}-(i-1)\leq s_{j-1}-(j-1)\ \ \ \ \ \ (j<i)
$$

同理，由另一式得 

$$
s_{i-1}-(i-1)\leq s_{j}-j\ \ \ \ \ \ (j\geq i)
$$

合并，得

$$
s_{i-1}-(i-1)\leq s_{j}-j\ \ \ \ \ \ (0\leq j\leq n)
$$

由于 $j=i-1$ 时该式恒为真，去掉了条件 $j\neq i-1$。

所以，如果存在位置 $x$，使得对于任意的 $y$，$s_x-x\leq s_y-y$，$x+1$ 即为一个合法位置。

那我们找到最小的 $s_x-x$，断开 $x$ 到 $x+1$，跑一边链上算法即可。
特别地，当 $x=n$ 时，我们断开 $n$ 到 $1$。

复杂度 $\Theta(n\lg n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    char c;int x,f{0};
    do x=(c=getchar())^48;
    while (!isdigit(c)&&c!='-');
    if (x==29) x=0,f=-1;
    while (isdigit(c=getchar()))
        x=(x<<3)+(x<<1)+(c^48);
    return (x^f)-f;
}
const int N(5e5);
int a[N+5],p[N+5],v[N+5];
int s[N+5];
vector<int> e[N+5];
int main() {
    int n{read()};
    for (int i{1};i<=n;++i)
        ++s[a[i]=read()];
    int t{0};
    for (int i{1};i<=n;++i) {
        s[i]+=s[i-1];
        if (s[i]-i<s[t]-t) t=i;
    }
    for (int i{1};i<=n;++i)
        p[i]=read();
    for (int i{1};i<=n;++i)
        e[a[i]].push_back(read());
    multiset<int> arda;
    int ans{0},i{t+1};
    do {
        for (auto v:e[i])
            arda.insert(v);
        auto it{arda.lower_bound(p[i])};
        if (it!=arda.end()) arda.erase(it),++ans;
        else arda.erase(arda.begin());
        i=i%n+1;
    } while (i!=t+1);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：蟭蟟虫儿 (赞：1)

如果矮人没有围成一个圆环，而是排成一列，那么可以考虑贪心，对于第一个矮人，让分配到他且可以战胜他的精灵中力量值最小的与其决斗即可，若分配到他的精灵都不可以战胜他，那么让其中力量值最小的与其决斗即可，对于第二个矮人，需要在本来分配到他的精灵中再加上分配到第一个矮人却没有与其决斗的精灵，而后执行同样的贪心操作，依此类推。

但是围成一个圆环后，即使是第一个矮人也可能有精灵沿着顺时针方向继承到他这，所以需要找到真正的第一个矮人，也就是说这个矮人不可能有精灵沿着顺时针方向继承到他这。

定义一个数组 $num[]$，$num[i]$ 表示分配到编号$i$矮人的精灵数量，求其前缀和得到 $sum[]$。

对于编号 $i(i > 1)$ 矮人，为使分配到编号 $i - 1$ 矮人的精灵不继承到他这，需满足 $sum[i - 1] - sum[i - 2] \le 1$，在此基础上，为使分配到编号 $i - 1$ 和 $i - 2$ 矮人的精灵不继承到编号 $i$ 矮人处，还需满足 $sum[i - 1] - sum[i - 3] \le 2$。

依此类推，为使分配到编号 $i - 1 , i - 2 , \cdots , 1$ 矮人的精灵不继承到编号 $i$ 矮人处，需满足 $sum[i - 1] - sum[i - 2] \le 1 , \cdots , sum[i - 1] - sum[0] \le i - 1$，任取其中一式记作 $sum[i - 1] - sum[k] \le i - 1 - k(0 \le k \le i - 2)$，移项得 $sum[i - 1] - (i - 1) \le sum[k] - k(0 \le k \le i - 2)$。

在此基础上，为使分配到编号 $n , \cdots , i + 1$ 矮人的精灵不继承到编号 $i$ 矮人处，同理，任取需满足的式子中一式记作 $sum[i - 1] + sum[n] - sum[k] \le i - 1 + n - k(i \le k \le n - 1)$，移项得 $sum[i - 1] - (i - 1) \le sum[k] - sum[n] + n - k$，又 $sum[n] = n$，所以得 $sum[i - 1] - (i - 1) \le sum[k] - k(i \le k \le n - 1)$。

综上所述，需满足 $sum[i - 1] - (i - 1) \le sum[k] - k(0 \le k \le i - 2 , i \le k \le n - 1)$，又因为 $sum[0] - 0 = 0 = sum[n] - n$，所以 $1 \le k \le i - 2 , i \le k \le n$。

因此 $sum[i] - i$ 最小时对应的 $i + 1$ 即为真正的第一个矮人，从该矮人开始应用贪心即可。

可以使用 vector 数组记录分配到每个编号的矮人的精灵的力量值，从真正的第一个矮人开始依次贪心时，使用 multiset 记录可以与当前矮人对决的精灵的力量值分别是多少。

代码如下：
```cpp
#include<cstdio>
#include<vector>
#include<set>

using namespace std;

#define il inline

const int M = 5e5 + 5;

int n;
int sum[M], a[M], p[M];
vector<int> vec[M];
int mnn = M, pos, ans;
multiset<int> S;

il int read() {
    int x = 0;
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return x;
}

int main() {
    n = read();
    for(int i = 1; i <= n; ++i) ++sum[a[i] = read()];     //为了方便，把num和sum合成了一个
    for(int i = 1; i <= n; ++i) p[i] = read();
    for(int i = 1; i <= n; ++i) vec[a[i]].push_back(read());

    for(int i = 1; i <= n; ++i)
        if((sum[i] += sum[i - 1]) - i < mnn) mnn = sum[i] - i, pos = i;     //pos就是解法中最后的i

    int i = pos = ++pos > n ? 1 : pos;     //使pos变为解法中最后的i + 1
    do {
        for(const int& v: vec[i]) S.insert(v);
        auto it = S.lower_bound(p[i]);
        if(it != S.end()) S.erase(it), ++ans;
        else S.erase(S.begin());
        ++i> n ? i = 1 : 1;     //其实就是一个if，最后的1占个位置
    } while(i != pos);

    printf("%d", ans);

    return 0;
}
```

---


# 区间加区间 sin 和

## 题目描述

给出一个长度为 $n$ 的整数序列 $a_1,a_2,\ldots,a_n$，进行 $m$ 次操作，操作分为两类。

操作 $1$：给出 $l,r,v$，将 $a_l,a_{l+1},\ldots,a_r$ 分别加上 $v$。

操作 $2$：给出 $l,r$，询问 $\sum\limits_{i=l}^{r}\sin(a_i)$。

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：ccz181078，Data：nzhtl1477

保证 $1\leq n,m,a_i,v\leq 2\times 10^5$，$1\leq l\leq r\leq n$。保证所有输入的数都是正整数。

## 样例 #1

### 输入

```
5
1 3 1 5 5
5
1 5 5 5
2 3 3
2 1 5
2 2 2
2 4 4```

### 输出

```
0.8
0.3
0.1
-1.0```

# 题解

## 作者：NaCly_Fish (赞：82)

讲道理，这题还是比较简单的。。  
~~虽然用 Taylor 展开+维护 $k$ 次方和也可以做，但是可能会 T 掉（~~  
Taylor 展开直接精度就炸了，，没法做。

考虑用一种好想又好写的做法：

$$\sin(a+x)=\sin a\cos x+\cos a\sin x$$
$$\cos(a+x)=\cos a\cos x-\sin a \sin x$$

然后随便怎么维护一下就可以了，，

于是在 $\Theta(m \log n)$ 的复杂度内就能解决。

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define reg register
#define N 200003
#define ls (u<<1)
#define rs (u<<1|1)
#define mid ((l+r)>>1)
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

int n,q;
int a[N];
double sink,cosk;

struct Segment_Tree{
    double sine[N<<2],cosi[N<<2];
    long long tag[N<<2];

    inline void pushup(int u){
        sine[u] = sine[ls]+sine[rs];
        cosi[u] = cosi[ls]+cosi[rs];
    }

    inline void update(int u,double sinx,double cosx){
        double sina = sine[u],cosa = cosi[u];
        sine[u] = sina*cosx + cosa*sinx;
        cosi[u] = cosa*cosx - sina*sinx;
    }

    inline void pushdown(int u){
        if(!tag[u]) return;
        double sinx = sin(tag[u]),cosx = cos(tag[u]);
        update(ls,sinx,cosx);
        update(rs,sinx,cosx);
        tag[ls] += tag[u];
        tag[rs] += tag[u];
        tag[u] = 0;
    }

    void build(int l,int r,int u){
        if(l==r){
            sine[u] = sin(a[l]);
            cosi[u] = cos(a[l]);
            return;
        }
        build(l,mid,ls);
        build(mid+1,r,rs);
        pushup(u);
    }

    void modify(int nl,int nr,int l,int r,int u,int k){
        if(nl<=l&&r<=nr){
            update(u,sink,cosk);
            tag[u] += k;
            return;
        }
        pushdown(u);
        if(nl<=mid) modify(nl,nr,l,mid,ls,k);
        if(nr>mid) modify(nl,nr,mid+1,r,rs,k);
        pushup(u);
    }

    double query(int nl,int nr,int l,int r,int u){
        if(nl<=l&&r<=nr) return sine[u];
        double res = 0;
        pushdown(u);
        if(nl<=mid) res += query(nl,nr,l,mid,ls);
        if(nr>mid) res += query(nl,nr,mid+1,r,rs);
        return res;
    }
}T;

int main(){
    int op,l,r,k;
    read(n);
    for(reg int i=1;i<=n;++i) read(a[i]);
    T.build(1,n,1);
    read(q);
    while(q--){
        read(op),read(l),read(r);
        if(op==1){
            read(k);
            sink = sin(k),cosk = cos(k);
            T.modify(l,r,1,n,1,k);
        }else printf("%.1lf\n",T.query(l,r,1,n,1));
    }
    return 0;
}
```

---

## 作者：mrsrz (赞：49)

~~Ynoi出数学~~

我们有公式：

$$
\sin(\alpha+\beta)=\sin(\alpha)\cos(\beta)+\sin(\beta)\cos(\alpha)$$
$$
\cos(\alpha+\beta)=\cos(\alpha)\cos(\beta)-\sin(\beta)\sin(\alpha)
$$

然后用线段树维护区间$\sin$和与$\cos$和，修改时令$\beta=v$然后代入上面的式子即可更新一个节点的信息。打标记只需记录每个区间被整体加了多少就好了。

时间复杂度$O((n+m)\log n)$。

---

## 作者：panyf (赞：41)

复数解法，常数很小。

我们有公式：

$(\cos(\alpha)+i\sin(\alpha))\times(\cos(\beta)+i\sin(\beta))=\cos(\alpha+\beta)+i\sin(\alpha+\beta)$

可以考虑维护每个位置的 $\cos(ai)+i\sin(ai)$ ，线段树区间和，提取虚部即为所求。

对于修改操作，线段树打乘法标记 $\cos(v)+i\sin(v)$ 即可。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
struct C{//复数类
	double x,y;
	inline C operator+(C b)const{return{x+b.x,y+b.y};}
	inline C operator*(C b)const{return{x*b.x-y*b.y,x*b.y+y*b.x};}
}s[525009],t[525009],w;
int a[200009],u,v;
void build(int k,int l,int r){//建树
	t[k]={1,0};
	if(l==r){
		s[k]={cos(a[l]),sin(a[l])};
		return;
	}
	register int m=l+r>>1,a=k<<1,b=a|1;
	build(a,l,m),build(b,m+1,r),s[k]=s[a]+s[b];
}
inline void down(int k,int a,int b){//标记下传
	if(t[k].y||t[k].x!=1)s[a]=s[a]*t[k],s[b]=s[b]*t[k],t[a]=t[a]*t[k],t[b]=t[b]*t[k],t[k]={1,0};
}
void upd(int k,int l,int r){//修改
	if(u<=l&&r<=v){
		s[k]=s[k]*w,t[k]=t[k]*w;
		return;
	}
	register int m=l+r>>1,a=k<<1,b=a|1;
	down(k,a,b);
	if(u<=m)upd(a,l,m);
	if(m<v)upd(b,m+1,r);
	s[k]=s[a]+s[b];
}
C qry(int k,int l,int r){//询问
	if(u<=l&&r<=v)return s[k];
	register int m=l+r>>1,a=k<<1,b=a|1;
	down(k,a,b);
	if(u<=m&&m<v)return qry(a,l,m)+qry(b,m+1,r);
	if(u<=m)return qry(a,l,m);
	return qry(b,m+1,r);
}
int main(){
	register int n,m,i,j;
	scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d",a+i);
	build(1,1,n),scanf("%d",&m);
	while(m--){
		scanf("%d%d%d",&i,&u,&v);
		if(i==1)scanf("%d",&j),w={cos(j),sin(j)},upd(1,1,n);
		else printf("%.1lf\n",qry(1,1,n).y);
	}
	return 0;
}
```


---

## 作者：Ofnoname (赞：25)

那么这道题的公式已经有人介绍过了，就是高一的和差角公式
$$sin(x+y)=sin\ x \ cos\ y + cos\ x\ sin\ y$$
$$cos(x+y)=cos\ x \ cos\ y - sin\ x\ sin\ y$$

那么对于这道题来说，我们呢维护每一个节点的`sin`和`cos`值。如果要将叶节点`x`加上`c`，我们就算出`x`和`c`的`sin`和`cos`值，然后用公式更新这个节点的`sin`和`cos`。

而一个非叶节点，它的`sin`值（`cos`同理）是等于子树的`sin`值加起来的和，设他的所有值分别为`l`和`r`，那么

$$sin(l+c)+sin(r+c)=sin\ l\ cos\ c + sin\ c\ cos\ l + sin\ r\ cos\ c + cos\ r\ sin\ c$$

$$= cos\ c\ (sin\ l + sin\ r) + sin\ c(cos\ l + cos\ r)$$

那么$(sin\ l + sin\ r)$就是本节点的`sin`值，$(cos\ l + cos\ r)$就是本节点的`cos`值，最后仍化为了和角公式，所以非叶节点也可以直接用和差角更新

卡常：将读入的增量预先计算`sin`和`cos`值，另外要开`long long`

```cpp
#pragma GCC optimize("Ofast")
#define MAX (200000 + 7)
#include <bits/stdc++.h>
typedef double d64;

int N, M, pd[MAX];
d64 sc, cc;

void read(int &a)
{
	static char c = getchar();
	for (a=0; c<'0'||'9'<c; c=getchar());
	for (; '0'<=c && c<='9'; c=getchar())
		a = a * 10 + (c & 15);
}

struct Segtree
{
	#define i0 (i << 1)
	#define i1 (i << 1 | 1)
	struct Node { 
		int L, R;
		long long fa;
		d64 sin, cos;
	} a[MAX << 2];
	void update(int i, d64 sc, d64 cc)
	{
		d64 si = a[i].sin, ci = a[i].cos;
		a[i].sin = si * cc + ci * sc;
		a[i].cos = cc * ci - si * sc;
	}
	void pushup(int i)
	{
		a[i].sin = a[i0].sin + a[i1].sin;
		a[i].cos = a[i0].cos + a[i1].cos;
	}
	void pushdown(int i)
	{
		long long &x = a[i].fa;
		if (!x) return;
		d64 sx = sin(x), cx = cos(x);
		update(i0, sx, cx), a[i0].fa += x;
		update(i1, sx, cx), a[i1].fa += x;
		x = 0;
	}
	void init(int i, int L, int R)
	{
		a[i].L = L, a[i].R = R;
		if (L != R) {
			int mid = L + R >> 1;
			init(i0, L, mid), init(i1, mid+1, R);
			pushup(i);
		} 
		else
			a[i].sin = sin(pd[L]), a[i].cos = cos(pd[R]);
	}
	void add(int i, int L, int R, int c)
	{
		if (a[i].R < L || R < a[i].L) return;
		if (L <= a[i].L && a[i].R <= R)
		{
			update(i, sc, cc);
			a[i].fa += c; return;
		}
		pushdown(i);
		add(i0, L, R, c), add(i1, L, R, c);
		pushup(i);
	}
	d64 sum(int i, int L, int R)
	{
		if (a[i].R < L || R < a[i].L) return 0;
		if (L <= a[i].L && a[i].R <= R)
			return a[i].sin;
		pushdown(i);
		return sum(i0, L, R) + sum(i1, L, R);
	}
} Seg;

int main()
{
	read(N);
	for (int i = 1; i <= N; i++)
		read(pd[i]);
	read(M), Seg.init(1, 1, N);
	
	for (int i = 1, op, l, r, c; i <= M; i++)
	{
		read(op), read(l), read(r);
		if (op - 1) 
			printf("%.1lf\n", Seg.sum(1, l, r));
		else
		{
			read(c), sc = sin(c), cc = cos(c); 
			Seg.add(1, l, r, c);
		}
	}
}
```

---

## 作者：yurzhang (赞：16)

更好的阅读体验 -> [推销博客](https://nikaidou-shinku.github.io/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-Luogu5524-Ynoi2012D1T1/)

---

# 前言

这应该是最水的 Ynoi 题了吧，不需要很高级的数据结构也不需要什么奇技淫巧，可以当做线段树练手题。

---

# 正文

我第一眼看见操作 $2$ 的时候差点吓傻：区间 $\sin$ 和！

但是不用慌，维护这种少见的信息有两个比较套路的方法：

1. 拆分成好维护的信息
2. 直接维护，考虑修改对其的影响

我开始想的是方法 $1$ ，十分 naive 地尝试把 $\sin x$ 展开成麦克劳林级数，然后维护区间 $k$ 次方和，后来发现区间加之后精度会很惨烈...

于是使用方法 $2$ ，考虑加法对这个东西的影响，由和角公式：
$$
\sin(x+v)=\sin x\cos v+\cos x\sin v
$$

$$
\cos(x+v)=\cos x\cos v-\sin x\sin v
$$

然后就非常好做了，我们同时维护区间 $\sin$ 和跟区间 $\cos$ 和，上传信息可以直接相加，再维护一个加法标记，用上面的和角公式可以做到 $\Theta(1)$ 下传标记。

```cpp
inline void add(int id,i64 v) {
    double x=sinv[id],y=cosv[id];
    double p=sin(v),q=cos(v);
    sinv[id]=x*q+y*p;
    cosv[id]=y*q-x*p;
    addv[id]+=v;
}
```

其它的就是线段树模板了，然后你就能通过这道题。

如果你的常数过大可以考虑减少求 $\sin$ 和 $\cos$ 的次数，可以大幅减小常数。

---

# 最后

Ynoi 题就不贴代码了，反正这个题代码也好写。

另外这个题可以考虑对于原序列的 $x$ 维护 $e^{ix}$ ，这样每次修改只需要维护乘法标记即可。

由欧拉公式，查询时可以直接提取虚部，这种方法常数会小些。

---

## 作者：kgory (赞：15)

这道题呢，还是很需要一点思维的。

我一开始看到这道题，以为只是基本的线段树求和，直接套就是了，然后发现：

![](https://cdn.luogu.com.cn/upload/pic/75393.png) （~~烦人的水印~~）

那如果老老实实的直接加，不就T了吗（大概是O(nm))

于是想到了一些关于三角函数的很好的性质……

就是最为基本的三角函数变换公式（~~推导过程略~~）

![](https://cdn.luogu.com.cn/upload/pic/75396.png)

当然，本题只需要用到第一个和第三个即可。

## 总结一下：本题就是三角函数+线段树（不要跟我说你线段树不会）

最后附上代码

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <iostream>
using namespace std;

#define ll long long
const int MAXN=1000005;

double s_n[MAXN],c_s[MAXN];
int a[MAXN],n;
ll fflg[MAXN];

int read(){
    char c=getchar();int ans=0;
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
    return ans;
}


//以下是基本的线段树操作
void build(int L,int R,int rt){
    if (L==R) {
		s_n[rt]=sin(a[L]);
		c_s[rt]=cos(a[L]);
		return;
	}
    int mid=(L+R)>>1;
	build(L,mid,rt<<1);
	build(mid+1,R,rt<<1|1);
    s_n[rt]=s_n[rt<<1]+s_n[rt<<1|1];
    c_s[rt]=c_s[rt<<1]+c_s[rt<<1|1];
    return;
}

void pushup(int rt,double sinx,double cosx){
    double Sum_sin=s_n[rt],Sum_cos=c_s[rt];
    s_n[rt]=Sum_sin*cosx+Sum_cos*sinx;//重点
    c_s[rt]=Sum_cos*cosx-Sum_sin*sinx;//重点
    return;
}

void pushdown(int rt){
    if (!fflg[rt]) return;
    fflg[rt<<1]+=fflg[rt];
	fflg[rt<<1|1]+=fflg[rt];
    double sinx=sin(fflg[rt]),cosx=cos(fflg[rt]);
    pushup(rt<<1,sinx,cosx);
	pushup(rt<<1|1,sinx,cosx);
    fflg[rt]=0;
	return;
}

void modify(int L,int R,int l,int r,int rt,double sinx,double cosx,int x){
    if (l<=L&&R<=r) {
		pushup(rt,sinx,cosx);
		fflg[rt]+=x;
		return;
	}
    int mid=(L+R)>>1;pushdown(rt);
    if (mid>=l) modify(L,mid,l,r,rt<<1,sinx,cosx,x);
    if (mid<r) modify(mid+1,R,l,r,rt<<1|1,sinx,cosx,x);
    s_n[rt]=s_n[rt<<1]+s_n[rt<<1|1];
    c_s[rt]=c_s[rt<<1]+c_s[rt<<1|1];
    return;
}

double query(int L,int R,int l,int r,int rt){
    if (l<=L&&R<=r) return s_n[rt];
    if (l>R||L>r) return 0;pushdown(rt);int mid=(L+R)>>1;
    return query(L,mid,l,r,rt<<1)+query(mid+1,R,l,r,rt<<1|1);
}

int main(){
    scanf("%d",&n);
    int i;
    for (i=1;i<=n;i++) a[i]=read();
    build(1,n,1);
    int m;
    scanf("%d",&m);
    int what;
    while(m--){
        what=read();
        int x,y,z;
        switch(what){
            case 1:{
                x=read(),y=read(),z=read();
				modify(1,n,x,y,1,sin(z),cos(z),z);
                break;
            }
            case 2:{
                x=read(),y=read();
				printf("%.1lf\n",query(1,n,x,y,1));
                break;
            }
        }
    }
    return 0;
}
```
# 完结撒花~~~

---

## 作者：Smallbasic (赞：6)

~~C(S)S(C)P(O)S(I)模拟考没开文件炸到145,于是来luogu水就发现了这道题~~

到题以为泰勒展开果断放弃，后来发现用可以高一数学公式：

$$\sin\alpha+\beta=\cos\alpha\sin\beta+\cos\beta\sin\alpha$$

$$\cos\alpha+\beta=\cos\alpha\cos\beta-\sin\alpha\sin\beta$$

~~所以我在洛谷学文化课~~

考虑来证明这个公式。先说第二个。

假设在坐标系上有两个长度为1的向量$A(\cos\alpha,\sin\alpha),B(\cos\beta,\sin\beta)$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tbhh8m24.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
~~不要喷图丑~~

根据诱导公式，$\cos <A,B>=\cos\alpha+\beta$

有$A\cdot B=1*1*cos<A,B>=\cos\alpha\cos\beta-\sin\alpha\sin\beta$

第一个公式如果自己乱定义向量的X积是$|A|\cdot|B|\cdot\sin<A,B>$的话自己推一下坐标形式按上面方法来就行了。（严格证明参考您的数学书）

于是每次用线段树维护区间sin和和cos和就好了。具体维护因为乘法的分配率，把整个区间的sincos和看成一个整体就好。

代码（十年OI一场空，不开longlong见祖宗）：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

int n, m, a[200005];
double sk, ck;

inline int read() {
	register int s = 0, f = 1;
	register char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s * f;
}

struct node {
	int l, r;
	long long lazy;
	double ss, cs;
	node *left = NULL;
	node *right = NULL;
	
	inline void plus(double s, double c) {
		double sss = ss, ccc = cs;
		this -> ss = sss * c + ccc * s;
		this -> cs = ccc * c - sss * s; 
	}
	
	inline void pushdown() {
		if (!(this -> lazy)) return ;
		if (left != NULL) { left -> lazy += lazy; left -> plus(sin(lazy), cos(lazy)); }
		if (right != NULL) { right -> lazy += lazy; right -> plus(sin(lazy), cos(lazy)); }
		this -> lazy = 0;
	}
	
	inline void update() {
		ss = left -> ss + right -> ss;
		cs = left -> cs + right -> cs;
	}
	
	inline void build(int l, int r) {
		this -> l = l; this -> r = r; lazy = 0;
		if (r <= l) ss = sin(a[l]), cs = cos(a[l]);
		else {
			left = new node; left -> build(l, l + r >> 1);
			right = new node; right -> build((l + r >> 1) + 1, r);
			this -> update();
		}
	}
	
	inline void modify(int l, int r, int k) {
		if (this -> l >= l && this -> r <= r) { this -> lazy += k; this -> plus(sk, ck); return ; }
		this -> pushdown();
		if (left != NULL && left -> r >= l) left -> modify(l, r, k);
		if (right != NULL && left -> r < r) right -> modify(l, r, k);
		this -> update();
	}
	
	inline double query(int l, int r) { 
		if (this -> l >= l && this -> r <= r) return ss;
		double ret = 0; this -> pushdown();
		if (left != NULL && left -> r >= l) ret += left -> query(l, r);
		if (right != NULL && left -> r < r) ret += right -> query(l, r);
		return ret;
	}
};

int main() {
	n = read();
	for (int i = 1; i <= n; ++i) a[i] = read();
	node *root = new node; root -> build(1, n);
	m = read();
	while (m--) {
		int opt = read(), l = read(), r = read();
		if (opt == 1) {
			int k = read(); sk = sin(k); ck = cos(k);
			root -> modify(l, r, k);
		} else if (opt == 2) printf("%.1lf\n", root -> query(l, r));
	} return 0;
} 
```


---


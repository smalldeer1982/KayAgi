# 我是仙人掌

## 题目背景

我遵守了...  
约...约定  
![](https://cdn.luogu.com.cn/upload/pic/45543.png)  
【你非常努力啊】  
我非常非常努力哦...  
![](https://cdn.luogu.com.cn/upload/pic/45545.png)  
【虽然昨天也说过这句话了...】   
【欢迎回来，珂朵莉】  
![](https://cdn.luogu.com.cn/upload/pic/45546.png)  
我回来了...  
终于说出口了...  
【是啊，我终于听见了】  
红色的头发，会不会奇怪？  
【很漂亮的颜色，和你很搭哦】   
是吗...  
我...我已经没事了  
【真的吗？身体状况没问题吗？】   
【要是硬撑的话，我可不会饶过你啊】  
没事的，做饭啊洗衣服啊，还留着很多活要干呢   
【可别太拼了哦】  
![](https://cdn.luogu.com.cn/upload/pic/45547.png)  
哼，你就做好心理准备等着吧  
![](https://cdn.luogu.com.cn/upload/pic/45548.png)  

## 题目描述

珂朵莉给你一个无向图，每次查询的时候给一堆二元组 $(x_i,y_i)$。

求图中有多少个点 $u$ 与至少一个这次询问给出的二元组 $(x_i,y_i)$ 满足 
 $\mathrm{dist}(u,x_i)\leq y_i$，$\mathrm{dist}$ 表示这两个点在图中的距离。

如果不连通 $\mathrm{dist} = +\infty$。

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

$1\leq n\leq 1000$，$1\leq m,q \leq 10^5$，$\sum a\leq2.1\times 10^6$。  

## 样例 #1

### 输入

```
5 6 6
2 3
1 3
2 5
1 3
3 2
2 5
1
3 1
1
1 1
1
1 4
1	
5 2
1
1 4
2
1 0
5 1```

### 输出

```
3
2
4
3
4
3```

# 题解

## 作者：mrsrz (赞：23)

> 在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的众人， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。————世界上最幸福的女孩

珂朵莉，最可爱了呢。

---

我们定义$f[i][j]$为从点$i$出发，最短路小于等于$j$的点的集合。这个可以用bitset压位存储。

计算$f[i][j]$，我们首先要知道任意两点对间最短路，然后计算出从每个点出发，最短路恰好为$j$的点的集合。然后前缀或一遍就是$f[i][j]$。

计算都可以在$O(\dfrac{n^3}{\omega})$的复杂度内完成。

而求任意点对间最短路，就从每个点开始BFS一遍即可。时间复杂度$O(n(n+m))$。

最后处理询问的时候，就把每个$(x,y)$对应的$f[x][y]$都取并集，然后求其中1的个数即可。时间复杂度$O(\dfrac{n\sum a}{\omega})$。

总时间复杂度$O(n(n+m)+\dfrac{n^3+n\sum a}{\omega})$，空间复杂度$O(\dfrac{n^3}{\omega})$。

~~然后听说这道题卡前向星~~

似乎是由于访问连续内存会比较快的原因，用vector存边就跑的飞快，而前向星就T飞了。

## Code：
```cpp
#include<bitset>
#include<cstdio>
#include<cctype>
#include<queue>
#include<vector>
#define N 1003
#ifdef ONLINE_JUDGE
struct istream{
	char buf[23333333],*s;
	inline istream(){
		buf[fread(s=buf,1,23333330,stdin)]='\n';
		fclose(stdin);
	}
	inline istream&operator>>(int&d){
		d=0;
		for(;!isdigit(*s);++s);
		while(isdigit(*s))
		d=(d<<3)+(d<<1)+(*s++^'0');
		return*this;
	}
}cin;
#else
#include<iostream>
using std::cin;
#endif
std::bitset<N>a[N][N];
int n,m,q,dis[N][N];
std::vector<int>G[N];
void bfs(int s,int*dis){
	for(int i=1;i<=n;++i)dis[i]=1002;
	static std::queue<int>q;
	dis[s]=0;
	for(q.push(s);!q.empty();){
		int u=q.front();q.pop();
		for(int i:G[u])
		if(dis[i]==1002){
			dis[i]=dis[u]+1;
			q.push(i);
		}
	}
	for(int i=1;i<=n;++i)
	a[s][dis[i]].set(i);
	for(int i=1;i<=n;++i)a[s][i]|=a[s][i-1];
}
int main(){
	cin>>n>>m>>q;
	while(m--){
		int u,v;
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for(int i=1;i<=n;++i)bfs(i,dis[i]);
	while(q--){
		std::bitset<N>ans;
		int x,u,v;
		cin>>x;
		while(x--){
			cin>>u>>v;
			if(v>n)v=n;
			ans|=a[u][v];
		}
		printf("%d\n",ans.count());
	}
	return 0;
}
```

---

## 作者：Pengzt (赞：9)

[P6328](https://www.luogu.com.cn/problem/P6328)

一眼题。

首先处理出所有点之间的距离是简单的，可以用 BFS 在 $\mathcal{O}(n(n+m))$ 的时间内解决。

然后想一个相对暴力的做法，因为只要求至少一个二元组，那答案显然的等价于求出一个点集，使得每个点集中的点存在一个 $i$ 能够在 $y_i$ 步内到达 $x_i$。用一个类似染色的做法对所有 $x_i$ 做 $y_i$ 轮，显然就是被打了标记的点的数量。然后因为每个点至多只会被统计一次，每个 $x_i$ 互不干扰。容易想到使用 bitset 对每个 $x_i$ 能到达的点求交集。但是因为 $y_i$ 不一样，对每个点在预处理时用 $n$ 个 bitset 存储到它的距离 $\le i$ 的点集，这是 $\mathcal{O}(\frac{n^3}{w})$ 的。最后统计用一个 bitset 全局取并即可。

时间复杂度：$\mathcal{O}(\frac{n^3+n\sum a}{w})$。

空间复杂度：$\mathcal{O}(\frac{n^3}{w})$。

$20:43:00$ 我开始写。

$21:00:46$ 我写完了。配合光读喜提最优解。

Tips：接近完全图时 vector 明显快于链式前向星。

代码：
```cpp
#define eb emplace_back
const int N=1e3+10;
int n,m,Q;
int dis[N];
bitset<N> b[N][N],vis,tmp;
vector<int> e[N];
int q[N],hd,tl,id[N];
void solve(int s){
	vis.reset();
	q[hd=tl=1]=s;dis[s]=0,vis[s]=1;b[s][0][s]=1;
	while(hd<=tl){
		int u=q[hd++];
		for(int v:e[u])if(!vis[v]){
			dis[v]=dis[u]+1;
			b[s][dis[v]][v]=1;
			vis[v]=1;
			q[++tl]=v;
		}
	}
	for(int i=1;i<=n;i++)b[s][i]|=b[s][i-1];
}
int main(){
	n=read(),m=read(),Q=read();
	for(int i=1,u,v;i<=m;i++)u=read(),v=read(),e[u].eb(v),e[v].eb(u);
	for(int i=1;i<=n;i++)solve(i);
	for(int qi=1;qi<=Q;qi++){
		int num=read();
		tmp.reset();
		for(int i=1,x,y;i<=num;i++)x=read(),y=read(),tmp|=b[x][y];
		we(tmp.count());
	}
	pcc();
	return 0;
}
```

---

## 作者：Sai0511 (赞：9)

人生第一道ynoi题，感觉大家是不是被ynoi的标签吓到了啊= =,此题的难度个人觉得不到黑题。        

### 正文部分
$bitset$+类似一个$dp$的东西乱搞。   
定义$f[u][x]$的含义是从第$u$号点开始所有路径长度不超过$x$的集合，这个东西显然我们是可以用$bitset$去维护的。           
接着我们考虑在这个$f$数组上动一些手脚      
对于任何一个$f[i][j]$，其$f[i][dis[j]][j]=1$   
这个东西是固定的，为什么？因为是最短路，到达了这个路径的最后一步一定是这个点，于是必定为$1$。            
继续考虑转移$f[i][j]$      
不难发现：$f[i][j]=f[i][j]|f[i][j-1]$

其中$j$表示的是一个距离，为什么可以这样转移？因为对于任何一个$dis$,其$dis-1$包含了$dis-2$,$dis-2$包含了$dis-3$...，于是我们可以大胆的直接或上就行了。

至于最短路，因为权值都相等，所以直接可以写$1$个$bfs$这里省略。~~我不会告诉你我dij都写完了才发现了logn的大常数。~~    

### My Code:
```cpp
#include <bits/stdc++.h>
#define il inline
#define gc getchar
#define pc putchar
#define pb push_back
const int MAXN = 1010;
const int GINF = 1001;
using namespace std;
namespace IO {
    il int read() {
        int res = 0;char c;bool sign = 0;
        for(c = gc();!isdigit(c);c = gc()) sign |= c == '-';
        for(;isdigit(c);c = gc()) res = (res << 1) + (res << 3) + (c ^ 48);
        return sign ? -res : res;
    }
    il void write(int x) {
        if(x < 0) x = -x,pc('-');
        int stk[20];stk[0] = 0;
        for(;x;x /= 10) stk[++stk[0]] = x % 10;
        for(int i = stk[0];i >= 1;i--) pc(stk[i] + 48);
        return;
    }
    il void writeln(int x) {
        write(x);pc('\n');
    }
}
using IO::read;using IO::write;using IO::writeln;
int n,m,i,j,k,q,_i;
bitset<MAXN> f[MAXN][MAXN];
int dis[MAXN];vector<int>g[MAXN];
il void readdEdge(int u,int v) {
    g[u].pb(v);g[v].pb(u);
}
il void bfs(int S) {
    int i;
    for(i = 1;i <= n;i++) dis[i] = GINF;dis[S] = 0;
    queue<int>Q;Q.push(S);
    while(!Q.empty()) {
        int u = Q.front();Q.pop();
        for(i = 0;i < g[u].size();i++) {
            int to = g[u][i];
            if(dis[u] + 1 < dis[to]) {
                dis[to] = dis[u] + 1;
                Q.push(to);
            }
        }
    }
//	cout << endl << S;
//	for(i = 1;i <= n;i++) cout << dis[i] << ' ';
//	cout << endl;
    return;
} 

int main() {
    n = read();m = read();q = read();
    for(i = 1;i <= m;i++) {
        int u = read(),v = read();
        readdEdge(u,v);
    }	
    for(i = 1;i <= n;i++) {
        bfs(i);
        for(j = 1;j <= n;j++) f[i][dis[j]].set(j);
        for(j = 1;j <= n;j++) f[i][j] |= f[i][j - 1];
    }
    for(_i = 1;_i <= q;_i++) {
        int T = read(),_j;bitset<MAXN> res;
        for(_j = 1;_j <= T;_j++) {
            int x = read(),y = read();
            res |= f[x][y];
        }
        writeln(res.count());
    }
    return 0;
}

```



---

## 作者：LJC00118 (赞：5)

打个广告 -> [戳这里](https://www.cnblogs.com/LJC00118/p/10098987.html)

https://www.luogu.org/problemnew/show/P5068

ynoi 中的良心题啊

考虑用 bitset 来维护里一个点距离小于 $ y_i $ 的点，那么答案就是一堆 bitset 或起来后二进制位中 $ 1 $ 的个数

这样我们只要令 $ f[i][j] $ 表示距离 $ i $ 点距离小于 $ j $ 的点，便可以高效求出答案

考虑怎么求出所有的 $ f[i][j] $

先枚举起点 $ u $，因为边权为 $ 1 $，所以只需要做一次 bfs

对于 $ i $ 这个点，假设它到 $ u $ 的距离为 $ dis_i $，那么我们就将 $ f[u][dis_i] $ 的第 $ i $ 位设为 $ 1 $，最后从小到大把 $ f[u][j] $ 或上 $ f[u][j - 1] $ 即可

复杂度是 $ \frac{n^3}{64} + (\sum\limits_{i=1}^{q}a_i)*\frac{n}{64} $，可以通过此题

最后 % 一发 lxl

```cpp
#include <bits/stdc++.h>
#define CIOS ios::sync_with_stdio(false);
#define rep(i, a, b) for(register int i = a; i <= b; i++)
#define per(i, a, b) for(register int i = a; i >= b; i--)
#define DEBUG(x) cerr << "DEBUG" << x << " >>> ";
using namespace std;

typedef unsigned long long ull;
typedef long long ll;

template <typename T>
inline void read(T &f) {
    f = 0; T fu = 1; char c = getchar();
    while (c < '0' || c > '9') { if (c == '-') fu = -1; c = getchar(); }
    while (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }
    f *= fu;
}

template <typename T>
void print(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x < 10) putchar(x + 48);
    else print(x / 10), putchar(x % 10 + 48);
}

template <typename T>
void print(T x, char t) {
    print(x); putchar(t);
}

const int N = 1005, INF = 0x7f7f7f7f;

queue <int> q;
bitset <N> f[N][N], Ans;
vector <int> adj[N];
int dis[N][N], n, m, Q, now;

int main() {
    memset(dis, 0x7f, sizeof(dis));
    read(n); read(m); read(Q);
    for(register int i = 1; i <= m; i++) {
        int a, b; read(a); read(b);
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    for(register int i = 1; i <= n; i++) {
        q.push(i); dis[i][i] = 0; now = i; f[i][0].set(i);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(register int j = 0; j < adj[u].size(); j++) {
                int v = adj[u][j];
                if(dis[i][v] == INF) {
                    dis[i][v] = dis[i][u] + 1;
                    q.push(v); f[i][dis[i][v]].set(v);
                }
            }
        }
        for(register int j = 1; j <= n; j++) f[i][j] |= f[i][j - 1];
    }
    while(Q--) {
        int t; read(t); Ans.reset();
        while(t--) {
            int a, b; read(a); read(b);
            if(b > n) b = n;
            Ans |= f[a][b];
        }
        print(Ans.count(), '\n');
    }
    return 0;
}
```

---

## 作者：_lbw_ (赞：4)

良心题啊！

看到要求可行的点数，立马bitset

我们考虑先预处理出每个点在一定的范围内能否被另一点包括，对每个询问都可以直接查询

因为点权为1，先bfs，再从前往后递推

处理出来之后每次询问暴力异或查询1的数量就可

时间复杂度$O(\dfrac{n^3+n*\sum a}{w}+n(n+m))$

```cpp
inline void bfs(int st){
	memset(dis,-1,sizeof dis);dis[st]=0;qwq.push(st);
	while(!qwq.empty()){
		int now=qwq.front();qwq.pop();
		for(register int i=0;i<e[now].size();i++)
			if(dis[e[now][i]]==-1)dis[e[now][i]]=dis[now]+1,qwq.push(e[now][i]);
	}
	F(i,1,n)vis[st][dis[i]][i]=1;//标记
	F(i,1,n)vis[st][i]|=vis[st][i-1];//从前往后更新
}
int yyds(){
	n=read();m=read();q=read();
	F(i,1,m){
		u=read();v=read();
		e[u].push_back(v);
		e[v].push_back(u);//用vector建图
	}
	F(i,1,n)bfs(i);//bfs
	F(i,1,q){
		temp=0;int a=read();
		F(j,1,a)u=read(),v=read(),temp|=vis[u][v];//统计答案
		print(temp.count());*O++='\n';
	}
	fwrite(obuf,O-obuf,1,stdout);
    return 0;
}
```


---

## 作者：tommymio (赞：4)

题面好评，珂朵莉还是那么的可爱呢~~

这题要我们求满足一组二元组中至少一个二元组的点的个数，**至少一种约束**，是不是令你想到了什么？

对于给出的一种约束 $x_i,y_i$，题目要求 $\text{dist}(u,x_i) \leq y_i$。这个 $\text{dist}$，题目中仅说是两点间的距离，如果这样理解自然无从下手。但这题中的 $dist$ 事实上是两点间的**最小距离**，为什么这样说呢？

因为假设两点间所有距离的值在 $[minDis,maxDis]$ 之间，那么大于 $y_i$ 的路径对答案没有贡献，只有小于等于 $y_i$ 的对于答案有贡献，也就是说事实上对于一个点 $u$ 与给出的点 $x_i$，只有他们间的最短路径可能对答案造成贡献。

那么这题就简单了很多，我们设 $f_{i,j}$ 为距 $i$ 的最小距离不超过 $j$ 的点所构成的点集。

那么询问的时候，直接根据 $x_i,y_i$ 取出这样的点集并取并，计算集合大小即可。

求 $f_{i,j}$ 也很简单，先求出距 $i$ 的最小距离为 $j$ 的点构成的点集，然后作一个类似前缀和的东西就可以了。

由于这题中所有边的权值均为 $1$ ，所以对于每个点 $i$ 直接 $\text{bfs}$ 预处理出最短路即可。

时间复杂度为 $O(n*(n+m)+n^2f+f\sum a)$，其中 $f$ 为每次 $\text{bitset}$ 操作的代价。

正如讨论区所说的那样，这题真的是个 $\text{bits}$ 模板题（逃

代码里写的是dijistra最短路，没想到吧（

PS：值得一提的是，**duliu** 出题人居然卡链式前向星，把窝卡哭了。

**Show the Code**

```cpp 
/*============================
 * Author : tommy0103
 * Problem : Ynoi
 * Algorithm : BITS
 * Time : 2020.3.30
 * ==========================*/
#include<cstdio>
#include<bitset>
#include<queue>
#include<functional>
const int inf=0x3f3f3f3f;
int n,m,Q,cnt=0;
std::bitset<1000> f[1005][1005];
std::vector<int> mp[1005];
int dis[1005][1005],b[1005][1005],vis[1005];
//int h[1005],to[200005],ver[200005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y) {if(!b[x][y]) mp[x].push_back(y),b[x][y]=1;}
void dijistra(int u) {
	std::priority_queue<std::pair<int,int> > Q;
	for(register int i=1;i<=n;++i) dis[u][i]=inf,vis[i]=0;
	dis[u][u]=0;Q.push(std::make_pair(0,u));
	while(Q.size()) {
		int x=Q.top().second;Q.pop();
		if(vis[x]) continue;vis[x]=1;
		for(register int i=0;i<mp[x].size();++i) if(dis[u][mp[x][i]]>dis[u][x]+1) Q.push(std::make_pair(-(dis[u][mp[x][i]]=dis[u][x]+1),mp[x][i]));
	}
}
int main() {
	n=read(),m=read(),Q=read();
	for(register int i=1;i<=m;++i) {int x=read(),y=read();add(x,y);add(y,x);}
	for(register int i=1;i<=n;++i) dijistra(i);
	for(register int i=1;i<=n;++i) {
		for(register int j=1;j<=n;++j) {
			if(dis[i][j]!=inf) f[i][dis[i][j]].set(j-1);
		}
	}
	for(register int i=1;i<=n;++i) for(register int j=1;j<=n;++j) f[i][j]|=f[i][j-1];
	while(Q--) {
		int T=read();
		std::bitset<1000> res;
		while(T--) {
			int x=read(),y=read();
			y=(y>n? n:y);res|=f[x][y];
		}
		printf("%d\n",res.count());
	} 
	return 0;
}
```

---

## 作者：lanretE (赞：3)

>在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的人们， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。——世界上最幸福的女孩

我永远喜欢珂朵莉！



------------
首先定义 $s_{i,j}$ 表示以 $i$ 为起点，路程不超过 $j$ 可以到达的点的集合，当然这个东西可以开 bitset 维护。$s_{i,j}$ 的第 $k$ 位为 $1$，当且仅当从点 $i$ 走不超过路程 $j$ 可以到达点 $k$。

为了求出 $s$，由于这题边权都是 $1$，我们对每个点跑 bfs 求出这个点的单源最短路，定义 $dis_j$ 表示点 $j$ 到当前算的点 $i$ 的最短路长度，则 $s_{i,dis_j,j}$ 一定是 $1$。

此外不难发现一个结论，$s_{i,j-1}\in s_{i,j}$，回看 $s$ 的定义，路程不超过 $j$ 可到达的点集，那么一定包含了路程不超过 $j-1$ 可到达的点集。有了这个结论就可以递推求出 $s_i$。

因此，对于每个点跑完单源最短路之后就可以完全算出 $s$。对于之后 $q$ 次询问，每次新定义一个 bitset 维护的集合 $s1$，读到 $x,y$ 时 $s1$ 就或上 $s_{x,y}$，最后答案就是 $s1$ 中 $1$ 的数量。

不过翻了一下题解区，发现这题卡前向星，所以就写了 vector。
```
#include<iostream>
#include<bitset>
#include<queue>
#include<vector>
#define ll long long
#define qwq cout<<"QwQ"<<endl;
using namespace std;
int n,m,q;
const int N=1010;
vector<int>g[N];
int dis[N];
void bfs(int u){
	queue<int>q; 
	for(int i=0;i<=n;++i) dis[i]=N;
	q.push(u); dis[u]=0;
	while(!q.empty()){
		int h=q.front(); q.pop();
		for(auto v:g[h]){
			if(dis[v]>dis[h]+1) dis[v]=dis[h]+1,q.push(v);
		}
	}
}
bitset<N>s[N][N];
int main(){
	scanf("%d%d%d",&n,&m,&q);
	while(m--){
		int u,v; scanf("%d%d",&u,&v);
		g[u].push_back(v); g[v].push_back(u);
	}
	for(int i=1;i<=n;++i){
		bfs(i);
		for(int j=1;j<=n;++j)
			if(dis[j]!=N) s[i][dis[j]][j]=1;
		for(int j=1;j<=n;++j) s[i][j]|=s[i][j-1];
	}
	while(q--){
		bitset<N>s1;
		int nn; scanf("%d",&nn);
		while(nn--){
			int x,y; scanf("%d%d",&x,&y);
			s1|=s[x][y];
		}
		int ans=s1.count();
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：黑影洞人 (赞：2)

 在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的人们， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。————世界上最幸福的女孩 珂朵莉
 

------------
构造 bool 数组 $f[i][j][k]$ 表示 $k$ 到 $i$ 的距离是否小于等于 $j$。

很显然既然是 bool 数组，可以同十分高效的 bitset 来维护。

于是我们维护一个二维 bitset 数组。

对于每个点，求出单源最短路，边权为 $1$ ，用 $dis[x]$表示当前点到 $x$ 的最短路径长度。

因为数组 $f[i][j][k]$ 表示 $k$ 到 $i$ 的距离是否小于等于 $j$ 。

所以枚举点 $j$ ： $f[i][dis[j]][j]$ 为 $1$ 。

然后对于 $f[i][dis[j]-k](1≤k≤dis[j])$ 的 bitset，可以满足 $f[i][j]|=f[i][j-1]$ 递推即可。

剩下的统计答案就十分简单，开一个 bool 数组 $ans$（建议用 bitset ）。

对于每次询问，$ans|=f[x][y] $ ,最后输出 $ans$ 中有多少个 $1$ ，可用 bitset 中的 count() 函数。

注意，我用前向星会 TLE，似乎只能 vector。

辛苦管理员同志了！

上代码：

```cpp
#include<cstdio>
#include<bitset>
#include<queue>
#include<algorithm>
#include<cstring>
#include<vector>
#define N 1145
//Whindsers:2022/6/30
using namespace std;
int n,m,q,head[N],to[N],nxt[N],tot,a,dis[N];
bitset<N>fifi[N][N];
vector<int>g[N];
void add(int u,int v){
    g[u].push_back(v);
}
void bfs(int &s){
    memset(dis,0x3f,sizeof(dis));
    queue<int >q;
    q.push(s);dis[s]=0;
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int y:g[x])if(dis[y]==dis[0])dis[y]=dis[x]+1,q.push(y); 
    }
}
signed main(){
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);add(y,x);
    }
    for(int i=1;i<=n;i++){
        bfs(i);
        for(int j=1;j<=n;j++)if(dis[j]!=dis[0])fifi[i][dis[j]][j]=1;
        for(int j=1;j<=n;j++)fifi[i][j]|=fifi[i][j-1];
    }
    while(q--){
        scanf("%d",&a);bitset<N>ans;
        while(a--){
            int x,y;scanf("%d%d",&x,&y);//y=min(y,n);
            ans|=fifi[x][y];
        } 
        printf("%d\n",ans.count());
    }
    return 0;
}
```


---

## 作者：Smallbasic (赞：2)

很精妙的题，不过放在Ynoi里面还是太良心了

一开始还以为是LCT什么的神仙算法，后来翻题解发现就是个bitset。。。

b[i][j]是距i点距离小于j的集合,dis[i][j]是i到j点的最短路，显然$j\in b[i][dis[i][j]]$

另外还有一个简单的结论是$\forall j\in b[i][k]$一定有$j\in b[i][k+l]$

这样直接暴力铁定超时啊，考虑优化。

由于边权都是1，最短路可以直接bfs。

第二个结论稍微思考一下可以得到在任意$j$都属于$b[i][dis[j]]$的基本情况下,$b[i][j]\subset b[i][j-1]$,于是乎$b[i][j]|=b[i][j-1]$直接O(n)递推就好了。

询问就是所有b[i][j]取并集之后的元素个数。

听说前向星存图会T???还是用vector吧，stl码量超少。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <bitset>

using namespace std;

int n, m, q, AlonerAKIOI, a, bb, dis[1005];
vector<int> e[1005];
bitset<1005> b[1005][1005];

inline int read() {
	int s = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s;
}

inline void bfs(int s) {
	for (int i = 0; i <= n; ++i) dis[i] = 1004;
	queue<int> q; q.push(s); dis[s] = 0;
	while (!q.empty()) {
		int x = q.front();
		for (int i : e[x])
			if (dis[i] > dis[x] + 1) dis[i] = dis[x] + 1, q.push(i);
		q.pop();
	}
}

int main() {
	n = read(); m = read(); q = read();
	while (m--) {
		a = read(); bb = read();
		e[a].push_back(bb);
		e[bb].push_back(a);
	}
	for (int i = 1; i <= n; ++i) {
		bfs(i);
		for (int j = 1; j <= n; ++j) if (dis[j] != 1004) b[i][dis[j]].set(j);
		for (int j = 1; j <= n; ++j) b[i][j] |= b[i][j - 1];
	}
	while (q--) {
		AlonerAKIOI = read(); bitset<1005> ans;
		while (AlonerAKIOI--) {
			a = read(); bb = read();
			ans |= b[a][bb];
		} printf("%d\n", ans.count());
	} return 0;
}
```

~~不好意思之前粘错代码了。。。~~

---

## 作者：Jμdge (赞：2)

做法评价：简单粗暴，代码简短



# noteskey

我们发现这里每条边的长度为 1 ，这是比较 nice 的一个特点

然后点数比较小，所以我们可以对于每个点跑一遍 bfs 求出相对每个点的距离

接着我们可以用一个 bitset 记录离 S 点的某个距离有哪些点

最后传递闭包弄个前缀信息就好了


询问的时候每次 ans 或上当前点的前缀信息就好了



（本来以为可能又是 分块，结果是bitset ，还是算比较清新的了）


```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define go(G,u) for(Rg int i=0,I=G[u].size(),v;i<I&&(v=G[u][i]);++i)
using namespace std;
const int M=1003;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmin(int& a,int b){return a>b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,q,dis[M][M];
bitset<M> a[M][M]; vector<int> G[M];
inline void bfs(int s,int* dis){
	static queue<int> q;
	fp(i,0,n) dis[i]=n+1;
	dis[s]=0,q.push(s);
	for(int u;!q.empty();){
		u=q.front(),q.pop();
		go(G,u) if(dis[v]==dis[0])
			dis[v]=dis[u]+1,q.push(v);
	}
	fp(i,1,n) a[s][dis[i]].set(i);
	fp(i,1,n) a[s][i]|=a[s][i-1];
}
int main(){ n=read(),m=read(),q=read(); int k,x,y;
	fp(i,1,m) x=read(),y=read(),G[x].push_back(y),G[y].push_back(x);
	fp(i,1,n) bfs(i,dis[i]);
	fp(kkk,1,q){ bitset<M> ans; k=read();
		fp(i,1,k) x=read(),y=read(),cmin(y,n),ans|=a[x][y];
		print(ans.count());
	} return Ot(),0;
}
```



---

## 作者：__白衣渡江__ (赞：1)

默哀，人生第二道Ynoi被踢出Ynoi了。

>在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的众人， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。`我是仙人掌`，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。————世界上最幸福的女孩 珂朵莉

（（（滑稽。

典型的算法不够常数来凑。

考虑邻接矩阵。

正常的邻接矩阵，是 $f_{i,j}$ 表示点 $i$ 到点 $j$ 的最短距离。

这样固然很好，空间 $\operatorname{O}(n^2)$ 。

但是，查询会爆。

毕竟，查询duliu啊，不知道怎么维护。

于是开始转向降低查询复杂度。

一个好用的思路是前缀和，重定义邻接矩阵 $f_{i,j,k}$ 表示是否能从 $i$ 到 $j$ 距离 $\le k$。然后查询复杂度就下来了。

但是空间吃不消了啊······预处理也吃不消啊······

怎么办？

再思考：$\text{bool}$ 数组，要支持的操作相当于快速计算 $or$。

想到什么？

**bitset or**。

谔······

自己理一下，思路到这里就没了。

接着是代码了。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")
#pragma GCC optimize(3)
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2),*p1++)
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
using namespace std;
const int N(1009);
int d[1009];
vector<int>e[1009];
inline void add(const int&u,const int&v){
    e[u].push_back(v),e[v].push_back(u);
}
inline void bfs(const int&s){
	queue<int>q;
	q.push(s);
	memset(d,0x3f,sizeof(d));
	d[s]=0;
	while(!q.empty()){
		int p=q.front();q.pop();
		for(int i:e[p])if(d[i]==d[0])d[i]=d[p]+1,q.push(i);
	}
}
inline int read(){
	register int c=getchar();
	while(!isdigit(c))c=getchar();
	register int x=c^48;
	while(isdigit(c=getchar()))x=x*10+(c^48);
	return x;
}
void print(int x) {
    if(x>9)print(x/10);
    *O++=x%10|48;
}
bitset<1009>mp[1009][1009];
int main(){
	register int n=read(),m=read(),q=read();
	while(m--)add(read(),read());
	for(register int i=1;i<=n;++i){
		bfs(i);
		for(register int j=1;j<=n;++j)if(d[j]!=d[0])mp[i][d[j]].set(j);
		for(register int j=1;j<=n;++j)mp[i][j]|=mp[i][j-1];
	}
	while(q--){
		bitset<1009>bs; 
		for(register int a=read();a;--a){
			register int x=read(),y=read();
			bs|=mp[x][y];
		}
		print(bs.count());
		*O++='\n';
	}
	fwrite(obuf,O-obuf,1,stdout);
	return 0;
} 
```
短小精悍，不懂私信。

Tiglish版：

```cpp
I have one const integer called N(1009);
I have an integer array called d[N];
I have one cpp::vector<int> array called e[N];
I have an array of cpp::bitset<N> arrays called mp[N][N];
I have one function called add(of one integer u as well as another integer v){
	Use the way of e[u].push_back(v);
	Use the way of e[v].push_back(u);
}
I have another function called bfs(of an integer s){
	I have one cpp::queue<int> called q;
	Use the way of q.push(s);
	Use the way of cpp::memset(d,0x3f,sizeof(d));
    Let the value of d[s] be 0;
	While not q.empty() do{
		I have one integer p(q.front());
		Use the way of q.pop();
		For each integer ww within e[p] do{
			If d[ww] equals d[0] do{
				Let the value of d[ww] be the value of d[p] plus 1;
				Use the way of q.push(ww);
			}
		}
	}
}
I have another function called nextint(of nothing){
	I have one word c(cpp::getchar());
    While !cpp::isdigit(c) do{
        Let the value of c be the value of cpp::getchar();
    }
    I have one integer called x(c xor 48);
    Let the value of c be the value of cpp::getchar();
    While cpp::isdigit(c) do{
        Let the value of x be the value of x times 10 plus (c xor 48); 
        Let the value of c be the value of cpp::getchar();
    }
	Return with the value of x;
}
Let us begin;
I have some integers called n,m,q;
Use the way of input(n,m,q);
While the value of m is greater than 0 do{
	Use the way of add(nextint(),nextint());
	Let the value of m be the value of m minus 1;
}
I have an integer called i(1);
While the value of i is less than the value of n plus 1 do{
	Use the way of bfs(i);
	I have an integer called j(1);
	While the value of j is less than the value of n plus 1 do{
		If the value of d[j] is less than d[0] do{
			Use the way of mp[i][d[j]].set(j);
		}
		Let the value of j be the value of j plus 1;
	}
	Let the value of j be 1;
	While the value of j is less than the value of n plus 1 do{
		Let the value of mp[i][j] be the value of mp[i][j] bitor mp[i][j minus 1];
		Let the value of j be the value of j plus 1;
	}
	Let the value of i be the value of i plus 1;
}

While the value of q is greater than 0 do{
	I have one cpp::bitset<N> called bs;
	I have one integer called a(nextint());
	While the value of a is greater than 0 do{
		Let the value of bs be the value of bs bitor mp[nextint()][nextint()];
		Let the value of a be the value of a minus 1;
	}
	Print out the value of bs.count();
	Print out endl;
	Let the value of q be the value of q minus 1;
}
That is all;
Thank you so much;
```

~~看不懂第一个的话就把第二个当注释看吧~~。

Over.

祝大家AC！

---

## 作者：yzhang (赞：1)

### ~~众所周知lxl是个毒瘤，Ynoi道道都是神仙题~~，这道题极其良心，题面好评

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10123550.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P5068)

我们先珂以在$O(n^2)$的时间内bfs求出任意两点距离

我们考虑如何计算从一个点到所有点的最短路长度小于等于k的点的数量

我们先求出来从一个点到所有点的最短路长度等于k的点的数量，这个珂以在bfs搜索过程中完成

统计最短路长度小于等于k的点的数量珂以使用前缀和

这里明显不好直接前缀和，我们可以使用bitset来维护一个点到所有点的最短路长度小于等于k的点的数量，如果一位是1，就代表满足条件，否则不满足条件

做前缀和时就直接用“|”就行了、

以上搜索和前缀和的复杂度为$O(\frac {n^3}{\omega})$（$\omega$是一个常数，这里珂以取32）

最后询问时开一个bitset，把所有条件的答案“|”起来，就是求出满足条件点的个数，最后输出这个bitset的count()，也就是1（满足）的个数

查询的复杂度为$O(\frac {n \sum_{i=1}^{q} a}{\omega})$

这道题存边不能用链式前向星，链式前向星会tle，因为地址不是连续的，所以用vector存边就行了qaq

总复杂度为$O(\frac {n^3+n  \sum_{i=1}^{q} a}{\omega})$

细节看程序

```cpp
#include <bits/stdc++.h>
#define N 1010
#define M 100010
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
vector <int> to[N];
int n,m,q;
int dis[N][N];
bitset <N> dissum[N][N];
inline void bfs(register int x,register int id)
{
    for(register int i=1;i<=n;++i)
        dis[id][i]=1005;
    queue <int> q;
    q.push(x);
    dis[id][x]=0;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(register int i=0;i<to[u].size();++i)
            if(dis[id][to[u][i]]==1005)
            {
                dis[id][to[u][i]]=dis[id][u]+1;
                q.push(to[u][i]);
            }
    }
    for(register int i=1;i<=n;++i)
        dissum[id][dis[id][i]].set(i);
    for(register int i=1;i<=n;++i)
        dissum[id][i]|=dissum[id][i-1];
}
int main()
{
    n=read(),m=read(),q=read();
    while(m--)
    {
        int u=read(),v=read();
        to[u].push_back(v),to[v].push_back(u);
    }
    for(register int i=1;i<=n;++i)
        bfs(i,i);
    while(q--)
    {
        bitset <N> ans;
        int x=read();
        while(x--)
        {
            int u=read(),k=read();
            ans|=dissum[u][k];    
        }
        write(ans.count()),puts("");
    }
    return 0;
} 
```

---

## 作者：HakkaNT (赞：1)

定义 $f_{i,j,u}$ 用于存储是否满足 $dis(u,i)\le j$，它的值为 True/False，很明显啊，这个用 `std::bitset` 存再合适不过了。每次查询操作实际上就是给出一堆 $x_i$ 和 $y_i$ 求 $\bigcup_{i=1}^{a} f_{x_i,y_i}$ 中 True 的个数。

预处理的话如果用 Floyd 是 $O(n^3)$ 的，超时。注意到边权全部为 $1$，可以用 bfs 在 $O(n(n+m))=O(nm)$ 的时间复杂度内求出全源最短路。存距离的 `dis` 数组也只要一维的，只需要轮流跑 $n$ 遍每次起点不同的单源最短路并且在算出来后立即把结果合并进 $f$ 里就行了。


```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,q,a,b,c,x,y,dis[1010];
bitset<1010>f[1010][1010];
vector<int>G[1010];

void bfs(int s){
    for(int i=1;i<=n;++i)
        dis[i]=1540;
    queue<int>Q;
    Q.push(s);
    dis[s]=0;
    while(Q.size()){
        int S=Q.front();
        Q.pop();
        for(int i:G[S])
            if(dis[S]+1<dis[i]){
                Q.push(i);
                dis[i]=dis[S]+1;
            }
    }
}

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>m>>q;
    for(int i=1;i<=m;++i){
        cin>>a>>b;
        G[a].push_back(b);
        G[b].push_back(a);
    }
    for(int i=1;i<=n;++i){
        bfs(i);
        for(int j=1;j<=n;++j)
            if(dis[j]<1540)
                f[i][dis[j]].set(j);
        for(int j=1;j<=n;++j)
            f[i][j]|=f[i][j-1];
    }
    while(q--){
        cin>>c;
        bitset<1010>res;
        while(c--){
            cin>>a>>b;
            res|=f[a][b];
        }
        cout<<res.count()<<"\n";
    }
    return 0;
}
```

这题卡了链式前向星，正好我也不会写。就用 `std::vector` 存图了。`std::bitset` 写邻接矩阵似乎也可以。

---

## 作者：5k_sync_closer (赞：0)

问一堆集合的交的点数，考虑用 `bitset` 维护这些集合。

预处理 $b_{x,y}$ 表示 $\{z|\text{dist}(x,z)\le y\}$，先 BFS 出 $a_{x,y}=\{z|\text{dist}(x,z)=y\}$，则 $b_{x,y}=\bigcup\limits_{i=0}^ya_{x,y}$。

BFS 复杂度 $O(n(n+m))$，前缀或复杂度 $O(\dfrac{n^3}w)$。

然后询问时求 $|\bigcap\limits_{i=1}^ab_{x_i,y_i}|$ 即可，复杂度 $O(\dfrac{n\sum\limits_{i=1}^qa}w)$。

点少边多的时候链式前向星会起飞，所以 `vector` 存图。
```cpp
#include <queue>
#include <vector>
#include <bitset>
#include <cstdio>
#include <cstring>
using namespace std;
int n, m, q, d[1050];vector<int> e[1001];bitset<1001> b[1001][1001];
int main()
{
	scanf("%d%d%d", &n, &m, &q);
	for(int i = 0, u, v;i < m;++i)
		scanf("%d%d", &u, &v), e[u].push_back(v), e[v].push_back(u);
	for(int s = 1;s <= n;++s)
	{
		memset(d, -1, sizeof d);b[s][d[s] = 0][s] = 1;queue<int> q;q.push(s);
		while(!q.empty())
		{
			int u = q.front();q.pop();for(auto v : e[u])
				if(!~d[v]) q.push(v), b[s][d[v] = d[u] + 1][v] = 1;
		}
		for(int i = 1;i <= n;++i) b[s][i] |= b[s][i - 1];
	}
	for(int i = 0, a, x, y;i < m;++i)
	{
		scanf("%d", &a);bitset<1001> q;while(a--)
			scanf("%d%d", &x, &y), q |= b[x][y];
		printf("%d\n", q.count());
	}
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：0)

我们考虑用 bitset 维护。          

定义一个 bitset $bs_{a,b}$ 为以 $a$ 点出发，距离小于等于 $b$ 的点集，其中 1 表示有这个点 0 表示没这个点。          

输出答案时我们直接把对应的 bitset 全部或起来就好了。         

预处理时，我们先用 BFS 预处理出来每个点到其他点的最短距离，然后直接往最初始的 bitset 里面填，然后暴力从前往后，执行 ```bs[a][b] |= bs[a][b - 1]``` 的操作即可得到所有点的点集，这里的时间复杂度是 $O(\frac{n ^ 3}{w})$ 的。                 

查询时的时间复杂度是 $O(\frac{n \sum a}{w})$ 的，卡满就是 $O(\frac{10 ^ 9}{w})$ 的一个时间复杂度，bitset 可以跑。                  

```cpp
#include "bits/stdc++.h"
using namespace std;
queue<int> q;
int dis[1005],n,m,ques;
bitset<1005> bs[1005][1005],bq;
vector<int> G[1005];
bool flag[1005]; 
void BFS(int x)
{
	for(int i = 1 ; i <= n ; i ++) dis[i] = 1e9 , flag[i] = 0;
	dis[x] = 0 , flag[x] = 1;
	while(!q.empty()) q.pop();
	q.push(x);
	while(!q.empty())
	{
		int p = q.front();q.pop();
		for(int i = 0 ; i < G[p].size() ; i ++) 
		{
			if(flag[G[p][i]]) continue;
			flag[G[p][i]] |= 1 , dis[G[p][i]] = dis[p] + 1 , q.push(G[p][i]);
		}
	}
	for(int i = 1 ; i <= n ; i ++) 
	{
		if(dis[i] == 1e9) continue; 
		bs[x][dis[i]].set(i , 1);
	}
	for(int i = 1 ; i <= n ; i ++) bs[x][i] |= bs[x][i - 1];
}
int main()
{
	scanf("%d %d %d",&n,&m,&ques);
	for(int i = 1 ; i <= m ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		G[x].push_back(y) , G[y].push_back(x);
	}
	for(int i = 1 ; i <= n ; i ++) BFS(i);
	for(int i = 1 ; i <= ques ; i ++)
	{
		int num;scanf("%d",&num);
		bq.reset();
		while(num --)
		{
			int a,b;scanf("%d %d",&a,&b);
			bq |= bs[a][b];
		}
		printf("%d\n",bq.count());
	}
	return 0;
}
```

---


# [COCI 2007/2008 #1] ZAPIS

## 题目描述

定义一个规则括号序列如下：

- 空串是规则括号序列。

- 如果 A 是规则括号序列，那么 `(`A`)` `[`A`]` `{`A`}` 都是规则括号序列。

- 如果 A,B 都是规则括号序列，那个序列 AB 也是规则括号序列。

Ivica 发现了一个长度为 $n$ 的疑似规则括号序列的串。但有一些字符已经模糊不清了，用 `?` 表示。

他想请你帮忙计算有多少种可能的情况使得这个疑似的串为规则括号序列。

## 说明/提示

#### 样例 $2$ 解释

所有可能的情况： `({([()])})` `()([()]{})` `([([])]{})`。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 200$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #1](https://hsin.hr/coci/archive/2007_2008/contest1_tasks.pdf) *T4 ZAPIS***

## 样例 #1

### 输入

```
6
()()()```

### 输出

```
1```

## 样例 #2

### 输入

```
10
(?([?)]?}?```

### 输出

```
3```

## 样例 #3

### 输入

```
16
???[???????]????```

### 输出

```
92202```

# 题解

## 作者：OccDreamer (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6333)

## 前置知识

[区间型动态规划](https://oi-wiki.org/dp/interval/)

## 思考过程

这题也算是一道很经典的问题了（？）。

看见 $n \leq 200$，不难想到复杂度为 $O(n^3)$ 的区间型动态规划。

题面中有这么一段话。

- 空串是规则括号序列。
- 如果 $\texttt A$ 是规则括号序列，那么 $\texttt{(A) [A] {A}}$ 都是规则括号序列。
- 如果 $\texttt A,\texttt B$ 都是规则括号序列，那个序列 $\texttt {AB}$ 也是规则括号序列。

这相当于直接告诉了我们动态规划的转移方程。

设 $dp(l,r)$ 表示由 $[l,r]$ 之间的字符组成的字符串有多少种不同的括号序列。

定义函数 $g(i,j)$ 表示第 $i$ 个字符与第 $j$ 个字符可以组成多少对不同的括号。

- 对于空串而言，令 $dp(l,l-1)=1$。
- 对于 $\texttt{(A)}$ 这一类的括号序列，可以写出转移方程 $dp(l,r)\leftarrow dp(l,r)+g(l,r)\times dp(l+1,r-1)$。
- 对于 $\texttt{AB}$ 类型的接下来我们重点讨论。

### 思路 $1$

我们能不能直接枚举一个位置 $p$，写出转移方程 $dp(l,r) \leftarrow dp(l,r) + \sum_{p=l+1}^{r-1} dp(l,p) \times dp(p+1,r)$。

经过思考不难发现这样是不行的，通过样例 $1$ 就可以发现。

如果按照上述思想，$dp(1,6)=dp(1,4) \times dp(5,6) +dp(1,2) \times dp(3,6)=2$，但是答案是 $1$。

这个转移错就错在重复计算了答案。

### 思路 $2$

沿用思路 $1$，既然知道问题出在哪，那么我们思考一下应该如何解决。

算重就是因为存在两个位置 $p_1,p_2$，满足 $[p_1,p_2]$ 构成合法的括号序列。

那么应该怎么解决呢？解决问题的关键就在于在转移的过程中不存在 $p_1,p_2$ 两个转移点使得 $[p_1,p_2]$ 被重复计算贡献。

考虑强制要求由 $[l,p]$ 构成的合法括号序列 $l,p$ 匹配。这样便可以符合要求。

$dp(l,r)\leftarrow dp(l,r)+\sum_{p=l+1}^{r-1} g(l,p) \times dp(l+1,p-1) \times dp(p+1,r)$。

举个例子来更好地了解这个过程。

拿样例 $1$ 来解释。

在计算 $dp(1,6)$ 时，只有 $p=2$ 对其产生了贡献，而 $p=4$ 时，$dp(2,3)=0$ 故并没有产生贡献。

## 实现

实现有一个细节，就是答案大于等于 $10^5$ 时，需要补上前导 $0$。

```cpp
#include<bits/stdc++.h>

#define int long long
#define RI register int
#define ll long long

using namespace std;

namespace IO{
	inline int read(){
		RI X=0, W=0;register char ch=getchar();
		while(!isdigit(ch)) W|=ch=='-', ch=getchar();
		while(isdigit(ch)) X=(X<<1)+(X<<3)+(ch^48), ch=getchar();
		return W?-X:X;
	}
	inline void write(int x){
		if(x<0) x=-x, putchar('-');
		if(x>9) write(x/10);
		putchar(x%10+'0');
	}
}using namespace IO;

const int MAXN = 205;
const int mod = 1e5;

int n;
int dp[MAXN][MAXN];
int br[MAXN];

bool mark[MAXN][MAXN];

char s[MAXN];

inline int match(int x, int y){
	if(br[x]==0 && br[y]>0) return 1;
	if(br[y]==0 && br[x]<0) return 1;
	if(br[x]<0 && br[x]+br[y]==0) return 1;
	if(br[x]==br[y] && br[x]==0) return 3;
	return 0;
}

signed main(){
	n=read();scanf("%s",s+1);
	for(int i=1;i<=n+1;++i) dp[i][i-1]=1;
	for(int i=1;i<=n;++i){
		if(s[i]=='?') br[i]=0;
		if(s[i]=='(') br[i]=-1;
		if(s[i]==')') br[i]=1;
		if(s[i]=='[') br[i]=-2;
		if(s[i]==']') br[i]=2;
		if(s[i]=='{') br[i]=-3;
		if(s[i]=='}') br[i]=3;
	}
	for(int len=2;len<=n;len+=2){
		for(int i=1, j;i+len-1<=n;++i){
			j=i+len-1;
			dp[i][j]=dp[i+1][j-1]*match(i,j);
			if(dp[i+1][j-1]*match(i,j)) mark[i][j]|=mark[i+1][j-1];
			if(dp[i][j]>=mod) dp[i][j]-=mod;
			for(int p=i+1;p<j;p+=2){
				dp[i][j]+=(1ll*dp[i+1][p-1]*dp[p+1][j]*
				match(i,p));
				if(1ll*dp[i+1][p-1]*dp[p+1][j]*match(i,p)) mark[i][j]|=mark[i+1][p-1]|mark[p+1][j];
				if(dp[i][j]>=mod) mark[i][j]=1, dp[i][j]%=mod;
			} 
		}
	}
	if(mark[1][n]){
		int tot=0, ans[20];
		while(dp[1][n]) ans[++tot]=dp[1][n]%10, dp[1][n]/=10;
		for(int i=5;i>tot;--i) write(0);
		for(int i=tot;i>=1;--i) write(ans[i]);
		putchar(10);
	}
	else write(dp[1][n]);
	return 0;
}
```

---

## 作者：ycy1124 (赞：4)

前言：祝各位 $2024$ csp rp++。
### 题意简述
现在有一个长度为 $n$ 的字符串 $s$，$s$ 中又一些 ```?```，现在要将这些问号换成 ```(,[,{,),],}``` 其中的一个，使得字符串内所有的括号都能成功匹配。输出方案数 $\bmod$ $100000$ 的值。
### 思路
首先不难想到，由于一个合法串外面套一对括号或者旁边加上一个合法串还是合法的，所以一个大的合法串是能够通过一些小的合法串合并而来的，因此，我们可以使用区间 dp。

对于长度为奇数的字符串，他最终一定是不能变成一个合法串的，因此可以直接判掉。

设 $dp_{i,j}$ 表示让 $s_i \sim s_j$ 这个字串合法的方案个数。首先敲个区间 dp 的模板试一下，WA 了。这种方式的错误在于有可能有重复的方案被多次计算，例如全是 ```?``` 的数据就可以轻易卡掉，然而每次进行容斥显然是比较困难的并且时限很紧张，于是考虑优化转移方程。

对于一个大的合法子串，我们可以把它拆分成一个合法的形式为 ```(a),[a],{a}``` 的小子串和一些其它合法字串（可以为空），于是我们根据这个反推，对于每个大的合法字串的方案数，我们枚举一个断点，使其左边的那个合法子串形式为 ```(a),[a],{a}```，这个子串的贡献为 $dp_{i+1,k-1}\times dp_{k+1,j}\times g(i,k)$，$g(i,k)$ 表示字符 $s_i$ 和 $s_k$ 能组成多少对不同的括号。这个转移方程表示的是，左边那个子串内 $a$ 的方案数乘上它外面的合法的括号的种类数乘上另一段子串的合法方案数。

最终的转移方程为：
$$
dp_{i,j}=\sum^{j}_{k=i}dp_{i+1,k-1}\times dp_{k+1,j} \times g(i,k)
$$
### 坑点
当答案为 $4$ 的时候要输出前导零（数据出锅）。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define md 100000
using namespace std;
string a;
int dp[505][505];
int work(int x,int y){//g函数
	if(a[x]=='?'&&a[y]=='?'){//两边都是？可以组成3对不同的括号
		return 3;
	}
	else if(((a[x]=='('||a[x]=='['||a[x]=='{')&&a[y]=='?')||((a[y]==')'||a[y]==']'||a[y]=='}')&&a[x]=='?')){//否则能配上对就是1个
		return 1;
	}
	else if((a[x]=='('&&a[y]==')')||(a[x]=='['&&a[y]==']')||(a[x]=='{'&&a[y]=='}')){
		return 1;
	}
	return 0;//没配上对
}
signed main(){
	int n;
	cin>>n>>a;
	a=' '+a;
	if(n%2){
		puts("0");
		return 0;
	}
	for(int i=1;i<=n+1;i++){//初值
		dp[i][i-1]=1;
	}
	for(int i=1;i<n;i++){//初值
		dp[i][i+1]=work(i,i+1);
	}
	for(int len=4;len<=n;len+=2){//区间dp只需要枚举长度为偶数的就行了
		for(int i=1;i+len-1<=n;i++){
			for(int k=i;k<=i+len-1;k++){
				dp[i][i+len-1]+=dp[i+1][k-1]*dp[k+1][i+len-1]*work(i,k);
				dp[i][i+len-1]%=md;
			}
		}
	}
	if(dp[1][n]==4){
		cout<<"0000";
	}
	cout<<dp[1][n];
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/184454116)。

---

## 作者：Unordered_OIer (赞：3)

# P6333

有一个括号串，有 3 种括号，有些初始位置是 `?` 需要填括号，求有多少种方法填出可以匹配的括号串。

由于模拟赛时改 dp 式子没改初始化怒挂 70pts，遂发此题解。

考虑一个朴素的区间 dp：$f[l][r]$ 表示将 $l,r$ 填为合法括号串的方案数。不难得到：

$$f[l][r]=\sum\limits_{k=l}^rf[l][k] \times f[k][r] + f[l+1][r-1] \times [\text{$l,r$ 可匹配}]$$

但是这样会重复统计一些串，例如 `[]()[]`，在 $f[1][4] \times f[5][6],f[1][2] \times f[3][6]$ 时都会被统计到。

怎么办呢，不妨钦定 $l,k$ 匹配，题解区有大神写法直接 $f[l+1][k-1]$，赛时我定义了一个 $g[l][r]$ 表示 $[l,r]$ 的括号串强制 $l$ 匹配 $r$，不过本质是相同的。

远古保留 5 位输出，坏！

```cpp
const ll N=205,P=100000;
ll f[N][N],g[N][N],n;
string s;
ll cal(char a,char b){
  if(a=='?'&&b=='?')return 3;
  if(a=='('&&b=='?')return 1;
  if(a=='['&&b=='?')return 1;
  if(a=='{'&&b=='?')return 1;
  if(a=='?'&&b==')')return 1;
  if(a=='?'&&b==']')return 1;
  if(a=='?'&&b=='}')return 1;
  if(a=='('&&b==')')return 1;
  if(a=='['&&b==']')return 1;
  if(a=='{'&&b=='}')return 1;
  return 0;
}
bool valid(char a,char b){
  if(a=='?'&&b=='?')return 1;
  if(a=='('&&b=='?')return 1;
  if(a=='['&&b=='?')return 1;
  if(a=='{'&&b=='?')return 1;
  if(a=='?'&&b==')')return 1;
  if(a=='?'&&b==']')return 1;
  if(a=='?'&&b=='}')return 1;
  if(a=='('&&b==')')return 1;
  if(a=='['&&b==']')return 1;
  if(a=='{'&&b=='}')return 1;
  return 0;
}
bool b[N][N];
int main(){
  n=read();cin>>s;s=" "+s;
  for(ll i=1;i<n;i++){
    g[i][i+1]=f[i][i+1]=cal(s[i],s[i+1]);
  }
  for(ll len=4;len<=n;len+=2){
    for(ll i=1;i+len-1<=n;i++){
      ll j=i+len-1;
      for(ll k=i+1;k<j;k+=2){
        f[i][j]=(f[i][j]+g[i][k]*f[k+1][j]);
      }
      if(valid(s[i],s[j])){
        g[i][j]=(g[i][j]+cal(s[i],s[j])*f[i+1][j-1]);
        f[i][j]=(f[i][j]+cal(s[i],s[j])*f[i+1][j-1]);
      }
      if(f[i][j]>P)b[i][j]=1,f[i][j]%=P;
    }
  }
  if(b[1][n])printf("%05lld\n",f[1][n]);
  else cout<<f[1][n]<<'\n';
  return 0;
}
```

---

## 作者：Zisyhfollower (赞：2)

## 前言：

联考考了这道题，但是我晚来了（闹肚子），然后还是切了。

## 思路：

考虑按照题目设计状态：设 $dp_{l,r,0}$ 表示形如题目所讲的第二种括号序列。$dp_{l,r,1}$ 为第三种。

那么 $dp_{l,r,0}$ 是好转移的，就只要把所有他内部的方案算上即可：

$$
dp_{l,r,0}=(dp_{l+1,r-1,0}+dp_{l+1,r-1,1})\times w
$$

这个 $w$ 表示 $i$ 和 $j$ 两端能组成的合法括号串的数量。

对于 $dp_{l,r,1}$，也可以写出一个转移方程：

$$
dp_{l,r,1}=\sum\limits_{k=l}^{r-1}(dp_{l,k,0}+dp_{l,k,1}) \times (dp_{k+1,r,0}+dp_{k+1,r,1})
$$

然后你会发现过不了样例。

其实，$dp_{l,r,1}$ 中包含了部分第二种情况，所以说你直接转移就会导致算重，例如：

```
8
(){[?}(?
```

其中有 $[3,6]$ 被重复计算。

那么你可以钦定一段仅由第二种情况组成，所以方程就会变成这样：

$$
dp_{l,r,1}=\sum\limits_{k=l}^{r-1}(dp_{l,k,0}+dp_{l,k,1}) \times dp_{k+1,r,0}
$$

那么这样子就不会算重了。

记得处理一下长度为 $2$ 的特殊情况。

然后做完了。

```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;
const int N = 505,p = 100000;
int dp[N][N][2];
int n;
char ch[N];
bool check (int l,int r) {
    if (ch[l] == '?' && ch[r] == '?') return 1;
    if (ch[l] == '?' && (ch[r] == ')' || ch[r] == '}' || ch[r] == ']')) return 1;
    if (ch[r] == '?' && (ch[l] == '(' || ch[l] == '{' || ch[l] == '[')) return 1;
    if (ch[l] == '(' && ch[r] == ')') return 1;
    if (ch[l] == '{' && ch[r] == '}') return 1;
    if (ch[l] == '[' && ch[r] == ']') return 1;
    return 0;
}
int calc (int l,int r) {
    if (ch[l] == '?' && ch[r] == '?') return 3;
    if (ch[l] == '?' && (ch[r] == ')' || ch[r] == '}' || ch[r] == ']')) return 1;
    if (ch[r] == '?' && (ch[l] == '(' || ch[l] == '{' || ch[l] == '[')) return 1;
    if (ch[l] == '(' && ch[r] == ')') return 1;
    if (ch[l] == '{' && ch[r] == '}') return 1;
    if (ch[l] == '[' && ch[r] == ']') return 1;
    return 0;
}
signed main () {
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
//    freopen("toad.in","r",stdin);
//    freopen("toad.out","w",stdout);
    cin >> n;
    for (int i = 1;i <= n;++i) cin >> ch[i];
    for (int i = 1;i < n;++i) if (check(i,i + 1)) dp[i][i + 1][0] = calc(i,i + 1);
    for (int len = 3;len <= n;++len) {
        for (int l = 1;l + len - 1 <= n;++l) {
            int r = l + len - 1;
            if ((r - l + 1) & 1) continue;
            if (check(l,r)) 
            dp[l][r][0] = ((dp[l + 1][r - 1][0] % p + dp[l + 1][r - 1][1] % p) * calc(l,r)) % p;
            for (int k = l;k < r;++k) {
                if ((k - l + 1) % 2 == 0 && (r - k) % 2 == 0)
                dp[l][r][1] = (dp[l][r][1] % p + ((dp[l][k][0] + dp[l][k][1]) % p * dp[k + 1][r][0] % p ) % p) % p; 
            }
        }
    }
    int ans = (dp[1][n][0] % p + dp[1][n][1] % p) % p;
    if (ans == 4) cout << "00004\n";
    else cout << ans << "\n";
    return 0;
}
```

---

## 作者：_determination_ (赞：2)

经典区间 dp。

注意到这个合法括号串的定义形式，发现他由两种方式构成：

1. 两个合法区间拼起来。
2. 在合法区间基础上添加括号。

那么我们直接 dp：$f_{i,j}$ 表示区间 $[i,j]$ 的合法括号串数量。

对于第一种转移： $f_{l,r}=\sum_{i=l}^{r}f_{l,i}\times f_{i+1,r}$。

对于第二种转移你就判一下左右的东西，如果左右两端可以匹配那么就给 $f_{l,r}$ 加上 $f_{l+1,r-1}$。当然判一下两端都是 `?` 的情况，这种情况要再乘一个 3。

好的然后你发现你算重了，你手摸之后发现 `()[]{}` 这种东西会被多算。我们考虑钦定左区间一定是通过在“左右两端加括号”进行转移，然后就不会算重了。实现的话就多记一维即可。

---

## 作者：2018ljw (赞：2)

题目大意：给定一个由 `(),[],{},?` 组成的字符串，问有多少种可能的合法括号序列。字符串长 $n\le 200$。输出答案的后 $5$ 位。

考虑区间 dp。设 $dp_{l,r}$ 表示区间 $[l,r]$ 有多少种可能的合法括号序列。考虑转移。

先考虑由一个合法的括号序列外面再套一层括号。那么分五类：

1. 两边括号直接匹配。这时直接套即可 $dp_{l,r}=dp_{l+1,r-1}$。
2. 两边括号匹配失败。无法转移。
3. 一边是问号，另一边括号方向正确。同情况 $1$。
4. 一边是问号，另一边括号方向错误。无法转移。
5. 两边都是问号。这时我们可以通过填 `(),[],{}` 分别转移。所以 $dp_{l,r}=3\times dp_{l+1,r-1}$。

然后考虑由两个括号序列相邻拼接在一起的方案。

一个比较直观的想法是枚举断点，答案加上左边方案乘上右边方案。但很遗憾，这是错的。以第一个样例为例，`()()|()` 与 `()|()()` 被视为两种不同的方案。这个思路又难以去重，所以重新考虑。回顾我们枚举断点的思路，本质上是找到与左括号相匹配的右括号，然后两边乘法原理统计答案。考虑从这个角度入手。

以样例为例，`()()|()` 的方案里我们让 $s_1,s_4$ 强行匹配，发现中间 $s_2,s_3$ 方案数为 $0$。所以是正确的。

因此，$dp_{l,r}+=\sum\limits_{k=l+1}^{r-1}\operatorname{calc}(s_l,s_k)\times dp_{l+1,k-1}\times dp_{k+1,r}$。其中 $\operatorname{calc}$ 函数表示两个字符匹配成括号的方案数，与先前的分五类讨论完全一致。

因此，完整的 dp 式子为：
$$
dp_{l,r}=\operatorname{calc}(s_l,s_r)\times dp_{l+1,r-1}+\sum_{k=l+1}^{r-1}\operatorname{calc}(s_l,s_k)\times dp_{l+1,k-1}\times dp_{k+1,r}
$$

初值：空串的方案数为 $1$，即 $dp_{i,i-1}=1$。

保留最后 $5$ 位数字，看似是对 $10^5$ 取模，实际上有坑点：当实际数 $\ge 10^5$，而取模后的数字 $\le10^4$ 时，我们需要输出前导零。因此额外记一个数组表示 $dp_{i,j}$ 的答案是否大于 $10^5$。

完整代码：

```cpp
#include<cstdio>
const int mod=1e5;
long long dp[201][201];
int n;
char s[201];
bool fx(char x){
//获取括号 x 是左括号还是右括号
	if(x==')'||x==']'||x=='}')return 1;
	return 0;
}
int calc(char x,char y){
//得到 x y 括号匹配的方案数。
	if(x=='?'&&y=='?')return 3;
	if((x=='?'&&fx(y))||(y=='?'&&!fx(x))||x+1==y||x+2==y)return 1;
	//解释下最后两个比较：
	//'[' 与 ']'、'{' 与 '}' 的 ASCII 码值均相差 2，'(' 与 ')' 的相差 1。
	//并且不同括号之间、括号与 '?' 的 ASCII 码值相差均较大，所以直接这样比较了。
	return 0;
}
bool overflow[201][201];
//overflow[i][j] 记录 dp[i][j] 是否不小于模数
int main(){
	int i,j,k;
	scanf("%d%s",&n,s+1);
	for(i=1;i<=n;i++)dp[i][i-1]=1;
	for(i=2;i<=n;i+=2){
		for(j=1;i+j-1<=n;j++){
			int r=i+j-1;
			dp[j][r]=calc(s[j],s[r])*dp[j+1][r-1];
			if(dp[j][r]>=mod)overflow[j][r]=1,dp[j][r]%mod;
			if(calc(s[j],s[r]))overflow[j][r]|=overflow[j+1][r-1];
			for(k=j+1;k<r;k+=2){
				dp[j][r]+=dp[k+1][r]*dp[j+1][k-1]*calc(s[j],s[k]);
				if(calc(s[j],s[k]))overflow[j][r]|=overflow[j][k]|overflow[k+1][r];
				if(dp[j][r]>=mod)overflow[j][r]=1;
				dp[j][r]%=mod;
			}
		}
	}
	if(overflow[1][n])printf("%05lld",dp[1][n]);
	else printf("%lld\n",dp[1][n]);
}
```

---

## 作者：Masterwei (赞：2)

#### 前言
来自于模拟赛。


#### 思路

比较显然，我们设 $f_{i,j}$ 表示区间 $[l,r]$ 已经匹配完成的方案数。

那么转移分为两种:

$f_{i,j}=f_{i+1,j-1}\times check(i,j)$，其中 $check$ 表示 $i,j$ 为左右端点的方案数。

$f_{i,j}=\sum_{k=i}^{j-1} f_{i,k}\times f_{k+1,j}$，表示由多个合法区间组合起来的区间个数。

但是写完后发现这是错的。原因是在第二种转移的时候，会有多种方案计算重复。比如说当 $n=6$，全是问号时，$f_{1,6}$ 中的 $()()()$ 会在 $k=2,4$ 时多次计算。

所以我们可以在计算方案时钦定一些东西，使得方案本质不同。我们设 $g_{i,j}$ 表示区间 $[l,r]$ 已经匹配完成的方案数，其中左右端点必须时匹配的。在转移时将 $f_{i,k}$ 替换为 $g_{i,k}$ 就不会算重了。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0;bool f=0;char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
const int Maxn=505,mod=100000;
int n;
char s[Maxn];
int f[Maxn][Maxn],g[Maxn][Maxn];
bool f1[Maxn][Maxn],g1[Maxn][Maxn];
inline int check(int l,int r){
	if(s[l]=='('&&(s[r]==')'||s[r]=='?'))return 1;
	if(s[l]=='{'&&(s[r]=='}'||s[r]=='?'))return 1;
	if(s[l]=='['&&(s[r]==']'||s[r]=='?'))return 1;
	if((s[l]=='('||s[l]=='?')&&s[r]==')')return 1;
	if((s[l]=='{'||s[l]=='?')&&s[r]=='}')return 1;
	if((s[l]=='['||s[l]=='?')&&s[r]==']')return 1;
	if(s[l]=='?'&&s[r]=='?')return 3;
	return 0;
}
signed main(){
//	freopen("toad.in","r",stdin);
//	freopen("toad.out","w",stdout);
	n=read();
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)f[i+1][i]=1;
	for(int len=2;len<=n;len+=2){
		for(int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			g[l][r]=f[l][r]=f[l+1][r-1]*check(l,r)%mod;
			g1[l][r]|=f1[l][r]|=f1[l+1][r-1];
			g1[l][r]|=f1[l][r]|=(f[l+1][r-1]*check(l,r))/mod;
			for(int k=l;k<r;k++){
				f[l][r]=(f[l][r]+g[l][k]*f[k+1][r]%mod)%mod;
				if(min(max(f[k+1][r],(int)f1[k+1][r]),max(g[l][k],(int)g1[l][k]))){
					f1[l][r]|=g1[l][k];f1[l][r]|=f1[k+1][r];
					f1[l][r]|=(f[l][r]+g[l][k]*f[k+1][r])/mod;
				}
			}
//			printf("f[%d][%d]=%d\n",l,r,f[l][r]);
		}
	}
//	f1[1][n]=1;
//	f[1][n]=1;
	if(f1[1][n]){
		int len=5;
		for(int i=f[1][n];i;i/=10)len--;
		while(len--)printf("0");
	}if(f[1][n]||!f1[1][n])printf("%lld\n",f[1][n]);
	return 0;
}
/*
40
????????????????????????????????????????
6
[]??}?

6
??????
*/
```

---

## 作者：Melo_qwq (赞：1)

这是前言部分：

条了一个晚上发现是对拍 generator 写挂了，急急急，特别鸣谢 [naive_wcx](https://www.luogu.com.cn/user/23138#main) 老师帮我解决唐氏问题。同时祝各位 CSP2024 RP++。

接下来是正文部分。

没人觉得括号序列是这题的加强版吗（CCF 又开赫了）？

首先设 $dp_{l,r}$ 表示区间 $[l,r]$ 合法的括号序列总共又多少种。

问题随之而来，如果我们每次只是单纯地把 $[l,k]$ 和 $[k+1,r]$ 合并成 $[l,r]$ 的话，类似于 ``()()()`` 这样的序列我们就会重复计算。

所以增加一维，我们设 $dp_{l,r,1}$ 表示区间 $[l,r]$ 的简单合法括号序列种数，其中“简单”的意思是最外层由一对相匹配的括号直接包裹起来。例如，``([]{})`` 是简单的，``({})[]`` 合法，但是并不简单。同时 $dp_{l,r,0}$ 保持原意义不变。

考虑转移，我们首先要考虑 $l$ 和 $r$ 什么时候是一对匹配的括号，很简单，直接放代码了：


```cpp
inline i128 judge (int l ,int r) {
	if (ch[l] == '?' && ch[r] == '?') { return 3 ;}
	return (((ch[l] == '[' && ch[r] == ']') || (ch[l] == '?' && ch[r] == ']')
	|| (ch[l] == '[' && ch[r] == '?')) || ((ch[l] == '(' && ch[r] == ')') || (ch[l] == '?' && ch[r] == ')')
	|| (ch[l] == '(' && ch[r] == '?')) || ((ch[l] == '{' && ch[r] == '}') || (ch[l] == '?' && ch[r] == '}')
	|| (ch[l] == '{' && ch[r] == '?'))) ;
}
```
之后首先考虑 $dp_{l,r,1}$ 的转移，显然是把 $l$、$r$ 拼到 $[l+1,r-1]$ 的外面，那么 $dp_{l,r,1}=judge(l,r)\times dp_{l+1,r-1,0}$，为什么是 $dp_{l+1,r-1,0}$ 马上你就知道了（千万注意，不是加法）。

接下来考虑 $dp_{l,r,0}$，首先它应该继承 $dp_{l,r,1}$，因为简单的括号肯定是合法的，接下来，我们考虑这个合法的括号序列一定可以由左端合法的简单序列和右边的合法序列拼接起来，同时这样可以保证不重不漏（其实主要是不重）。那么枚举断点 $k$，每次让 $dp_{l,r,0}$ 加上 $dp_{l,k,1}\times dp_{k+1,r,0}$。

最后是统计答案的问题，不能直接硬算然后判断最后的结果是不是大于 $5$ 位，因为这样中途会炸。那么只能对 $10^5$ 取模了，需不需要前导零只需要开一个变量记录计算的时候是否溢出就可以了。

代码：


```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = - x : 0 ;
}
template < typename T > inline void out ( T x ) {
	if (x < 0) { putchar ('-') ,x = - x ;}
	if (x >= 10) out (x / 10) ;
	putchar (x % 10 +'0') ;
}
using i128 = __int128 ;
const int N = 207 ;
const i128 mod = 1e5 ;
int n ;
i128 dp[N][N][2] ;
bool over ;
std :: string ch ;
inline i128 judge (int l ,int r) {
	if (ch[l] == '?' && ch[r] == '?') { return 3 ;}
	return (((ch[l] == '[' && ch[r] == ']') || (ch[l] == '?' && ch[r] == ']')
	|| (ch[l] == '[' && ch[r] == '?')) || ((ch[l] == '(' && ch[r] == ')') || (ch[l] == '?' && ch[r] == ')')
	|| (ch[l] == '(' && ch[r] == '?')) || ((ch[l] == '{' && ch[r] == '}') || (ch[l] == '?' && ch[r] == '}')
	|| (ch[l] == '{' && ch[r] == '?'))) ;
}
signed main () {
	read (n) ;
	std :: cin >> ch ;
	ch = ' ' + ch ;
	f (l ,1 ,n - 1 ,1) 
		dp[l][l + 1][0] = dp[l][l + 1][1] = judge (l ,l + 1) ;
	f (len ,3 ,n ,2) {
		f (i ,1 ,n - len ,1) {
			int j = i + len ;
			dp[i][j][1] = judge (i ,j) * dp[i + 1][j - 1][0] ;
			if (i == 1 && j == n && dp[i][j][1] >= mod) over = true ;
			dp[i][j][1] %= mod ; 
			dp[i][j][0] = dp[i][j][1] ;
			f (k ,i + 1 ,j - 1 ,2) {
				dp[i][j][0] += dp[i][k][1] * dp[k + 1][j][0] % mod ;
				if (i == 1 && j == n && dp[i][j][0] >= mod) over = true ;
				dp[i][j][0] %= mod ;
			}
		}
	} 
	register int x = dp[1][n][0] ,tot = 0 ;
	if (x == 0) tot = 1 ;
	while (x) { tot ++ ,x /= 10 ;}
	if (over) { f (i ,1 ,5 - tot ,1) putchar ('0') ;}
	out (dp[1][n][0]) ;
	puts ("") ; 
	return 0 ;
}
```

---

## 作者：Luckies (赞：1)

首先观察数据范围，一眼 $\mathcal O(n^3)$，然后再观察题目，你感觉它是个区间 dp，那么恭喜你，你的感觉是对的。

然后你直接一个区间 dp 板子拍上去，设 $dp_{i, j}$ 表示区间 $[i, j]$ 的方案数，那么转移很显然，若 $i,j$ 能够匹配，则可以将 $[i + 1, j - 1]$ 包起来，然后计算由两个串拼起来的。

然后你测一下样例，发现你错了。接着你模拟了一下样例，发现你算重了，例如样例 1：`()()()`，你输出了 `2`。

你发现 $\texttt{()()()} = \texttt{()} + \texttt{()()}$ 或 $\texttt{()()} + \texttt{()}$，于是你会统计两遍。也就是对于由两个匹配串拼起来的串，若其中的某一个串也是由某些子串拼起来的，就会算重。

于是你开始寻找原因。设 $s_{[i,j]} = s_{[i,k_1]} + s_{[k_1+1,j]},s_{[k_1+1,j]}=s_{[k_1+1,k_2]}+s_{[k_2+1,j]}$，其中 $s_{[i,k_1]},s_{[k_1+1,j]},s_{[k_1+1,k_2]},s_{[k_2+1,j]}$ 都是括号匹配串，那么也一定有 $s_{[i,j]} = s_{[i,k_2]} + s_{[k_2+1,j]},s_{[i,k_2]}=s_{[i,k_1]}+s_{[k_1+1,k_2]}$，于是 $s_{[k_1+1, k_2]}$ 就算重了。

然后你开始想办法让它只算一次。可以钦定 $s_{[k_1+1,k_2]}$ 只在 $s_{[k_1+1,r]}$ 中出现，那么 $s_{[i,k]}$ 就一定不是拼接而成的括号串。于是拼接的方式形如"不拼接串+拼接串"。

现在你知道如何去重了，于是你开始修改状态。设 $dp_{i,j,0/1}$ 表示 $[i,j]$ 不是/是拼接串的方案数。然后你将转移修改。

$$
dp_{i,j,0}=check(i, j) \cdot (dp_{i+1,j-1,0}+dp_{i+1,j-1,1}) \\

dp_{i,j,1}=\sum_{k=i}^{j-1}{dp_{i,k,0} \cdot (dp_{k+1,j,0}+dp_{k+1,j,1})}
$$

其中 $check(i, j)$ 表示 $i,j$ 是否能匹配。若 $s_i = s_j = \texttt{?}$，则 $check(i, j) = 3$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 505, Mod = 1e5;
int n, dp[N][N][2];
bool f;
string s;
bool check(int i, int j)
{
    return (s[i] == '(' && s[j] == ')' || s[i] == '[' && s[j] == ']' || s[i] == '{' && s[j] == '}' || (s[i] == '?' && (s[j] == ')' || s[j] == ']' || s[j] == '}') || ((s[i] == '(' || s[i] == '[' || s[i] == '{') && s[j] == '?')));
}
int add(int x, int y)
{
    if(x + y >= Mod)
        f = 1;
    return x + y >= Mod ? x + y - Mod : x + y;
}
signed main()
{
    cin >> n >> s;
    s = ' ' + s;
    for(int i = 1; i < n; i++)
        if(s[i] == s[i + 1] && s[i] == '?')
            dp[i][i + 1][0] = 3;
        else if(check(i, i + 1)) 
            dp[i][i + 1][0] = 1;
    for(int len = 4; len <= n; len += 2)
        for(int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            if(s[i] == s[j] && s[i] == '?')
                dp[i][j][0] = add(dp[i + 1][j - 1][0], dp[i + 1][j - 1][1]) * 3 % Mod;
            else if(check(i, j))
                dp[i][j][0] = add(dp[i + 1][j - 1][0], dp[i + 1][j - 1][1]);
            for(int k = i + 1; k < j; k += 2)
                dp[i][j][1] = add(dp[i][j][1], dp[i][k][0] * add(dp[k + 1][j][1], dp[k + 1][j][0]) % Mod);
        }
    if(f)
        return printf("%05lld", add(dp[1][n][0], dp[1][n][1])), 0;
    cout << add(dp[1][n][0], dp[1][n][1]);
    return 0;
}
```

P.S：这是我在考场时的心路历程，且我认为大部分人在第一次做此题时都是如此，于是我使用了第二人称。

---

## 作者：MnZnOIer (赞：1)

联考题，是我当前唯三场切的题。

一开始以为是计数问题，往下翻一点就会发现，这就是一道简单的区间 dp 问题。

### 解题思路
> ### 状态设置
>> 我们可以令 $f_{l,r}$ 表示 $l$ 到 $r$ 之间的字符组成的合法括号串数量。
>>
> 我们首先要知道，$n$ 为奇数时，一定无解，因为至少有一个不配对的括号。
>### 转移方程
>>我们可以发现，对于最外围的括号互相匹配时，当前的 $f_{l,r}$ 一定等于 $f_{l+1,r-1}$。但是，可以发现，上面的式子是有漏洞的，对于 最外围有两个 `?` 时，当前的 $f_{l,r}=3\times f_{l+1,r-1}$，因为 `?` 可以是任意字符。
>>
>>然后我们再枚举断点，考虑并列的括号。我们令左区间或右区间一定合法，然后判断合法区间是否外围还有一层括号。如果另一个区间不合法，那么他的值为 $0$，所以这个方案就是不合法的，这个方案的值也为 $0$。同样的，对于外围是两个括号的情况，还是给当前方案 $\times 3$。
### 注意事项
这题数据有一点问题，当答案等于 $4$ 时，需要在前面输出前导零。
### 代码部分

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
bool check (char a, char b){return ((a == '(' || a == '?') && (b == ')' || b == '?')) || ((a == '[' || a == '?') && (b == ']' || b == '?')) || ((a == '{' || a == '?') && (b == '}' || b == '?'));}
int n, f[505][505], mod = 1e5;
string s;
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n >> s;
	s = " " + s;
	if (n & 1)return puts ("0"), 0;//n 为奇数，一定不合法。
	for (int i = 1; i <= n; ++ i)f[i][i - 1] = 1;
	for (int l = 2; l <= n; ++ l, ++ l)for (int i = 1; i + l <= n + 1; ++ i)
	{
		int j = i + l - 1;
		if (s[i] == '?' && s[j] == '?')f[i][j] = (f[i][j] + f[i + 1][j - 1] * 3) % mod;//外围两个问号。
		else if (check (s[i], s[j]))f[i][j] = (f[i][j] + f[i + 1][j - 1]) % mod;//正常情况，需要判断外围是否有合法括号。
		for (int k = i + 1; k < j; ++ k)
		{
			if (s[i] == s[k] && s[i] == '?')f[i][j] = (f[i][j] + f[i + 1][k - 1] * f[k + 1][j] * 3) % mod;//同上。
			else if (check (s[i], s[k]))f[i][j] = (f[i][j] + f[i + 1][k - 1] * f[k + 1][j]) % mod;
		}
	}
    if (f[1][n] == 4)puts ("00004");
	else cout << f[1][n];
	return 0;
}
```

---

## 作者：__3E24AC7002AD9292__ (赞：1)

场切了。

套路地，考虑区间动规。设 $dp_{i,j}$ 表示 $[i,j]$ 区间括号序列合法的方案数。容易发现转移方程：$dp_{i,j}=dp_{i+1,j-1}\times\operatorname{check}(i,j)+\sum\limits_{t=i}^{j-1}(dp_{i,t}\times dp_{t+1,j})$，其中 $\operatorname{check}(i,j)$ 表示 $s_i,s_j$ 匹配的可能方案数。第一部分是在 $[i+1,j-1]$ 外部套一对括号的方案，第二部分是将两个区间的括号序列合并起来的方案。

当然，这是错的。在样例一的 `()()()` 中，$[1,2],[3,6]$ 两个区间，以及 $[1,4],[5,6]$ 两个区间都会被合并一遍，答案计算重复。不难发现如果枚举的需要合并的区间是由两个或多个子区间拼起来的，那么就会在转移方程的第二部分算重。

重新给状态增加一维，让 $dp_{i,j,1}$ 表示 $[i,j]$ 区间可以被分划为两个非空合法括号区间的方案数，$dp_{i,j,0}$ 表示 $[i,j]$ 区间不能被划分，但本身为合法括号区间的方案数。有转移方程 $dp_{i,j,0}=(dp_{i+1,j-1}+dp_{i+1,j-1,0})\times\operatorname{check}(i,j),dp_{i,j,1}=\sum\limits_{t=i}^{j-1}(dp_{i,t,0}+\times(dp_{t+1,j,1}+dp_{t+1,j,0}))$。答案即为 $dp_{1,n,0}+dp_{1,n,1}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=505,M=100000;
int n,dp[N][N][2];
string s;
int check(int x,int y){
    if (s[x]=='('&&s[y]==')') return 1;
    else if (s[x]=='['&&s[y]==']') return 1;
    else if (s[x]=='{'&&s[y]=='}') return 1;
    else if (s[x]=='('&&s[y]=='?') return 1;
    else if (s[x]=='['&&s[y]=='?') return 1;
    else if (s[x]=='{'&&s[y]=='?') return 1;
    else if (s[x]=='?'&&s[y]==')') return 1;
    else if (s[x]=='?'&&s[y]==']') return 1;
    else if (s[x]=='?'&&s[y]=='}') return 1;
    else if (s[x]=='?'&&s[y]=='?') return 3;
    else return 0;
}
signed main(){
    cin>>n>>s,s=' '+s;
    for (int i=1;i<n;i++)
        dp[i][i+1][0]=check(i,i+1);
    for (int x=4;x<=n;x+=2){
        for (int l=1;l<=n;l++){
            int r=l+x-1;
            if (r>n) continue;
            (dp[l][r][0]+=check(l,r)*((dp[l+1][r-1][0]+dp[l+1][r-1][1])%M)%M)%=M;
            for (int t=l+1;t<r;t+=2)
                (dp[l][r][1]+=dp[l][t][0]*((dp[t+1][r][0]+dp[t+1][r][1])%M)%M)%=M;
        }
    }
    cout<<(dp[1][n][0]+dp[1][n][1])%M<<'\n';
    return 0;
}
```

---

## 作者：SSqwq_ (赞：0)

## 分析

考虑区间 DP，令 $f_{i,j}$ 表示 $[i,j]$ 区间内的括号匹配方案总数，$s_{i,j}$ 表示 $[i,j]$ 区间内**钦定第 $i$ 和 $j$ 两处必须匹配**的括号匹配方案总数，于是有转移方程：

$$f_{i,j}=\sum_{k=i+1}^{j-1} f_{i,k}\times s_{k,j}$$

设立两个数组的原因是为了去重，本题括号匹配的定义与其他题目有所区别，这样做可以防止重复统计而导致的答案偏大。

时间复杂度 $O(n^3)$，足以通过本题。

细节实现见下面的代码。


## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int p=100000;
int n,a[1001],flag,b[1001],f[1001][1001],s[1001][1001],ans;
string xxx;
bool chk(int l,int r){
	if(a[l]==0&&a[r]==0)return false;
	if(a[l]>0&&a[r]==0-a[l])return true;
	if((a[l]==0&&a[r]<0)||(a[l]>0&&a[r]==0))return true;
	return false;
}
void work(){
	cin>>n>>xxx;
	xxx=" "+xxx;
	for(int i=1;i<=n;++i){
		if(xxx[i]=='(')a[i]=1;
		if(xxx[i]==')')a[i]=-1;
		if(xxx[i]=='[')a[i]=2;
		if(xxx[i]==']')a[i]=-2;
		if(xxx[i]=='{')a[i]=3;
		if(xxx[i]=='}')a[i]=-3;
	}
	for(int i=1;i<=n-1;++i){
		int j=i+1;
		if(chk(i,j))s[i][j]=1;
		if(a[i]==a[j]&&a[i]==0)s[i][j]=3;
		f[i][j]=s[i][j];
	}
	for(int len=4;len<=n;len+=2){
		for(int i=1;i<=n-len+1;++i){
			int j=i+len-1;
			if(chk(i,j)){
				s[i][j]=f[i+1][j-1];
			}
			if(a[i]==a[j]&&a[i]==0){
				s[i][j]=f[i+1][j-1]*3;
			}
			f[i][j]=s[i][j];
			for(int k=i+1;k<=j-1;k+=2){
				f[i][j]+=f[i][k]*s[k+1][j];
				if(f[i][j]>=p)flag=1;
				f[i][j]%=p;
			}
			f[i][j]%=p;
//			cout<<i<<" "<<j<<" "<<f[i][j]<<"\n";
		}
	}
	if(flag){
		if(f[1][n]<10000)cout<<0;
		if(f[1][n]<1000)cout<<0;
		if(f[1][n]<100)cout<<0;
		if(f[1][n]<10)cout<<0;
	}
	cout<<f[1][n]<<"\n";
//	dfs(1);
//	cout<<"ans="<<ans<<"\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--){
		work();
	}
	return 0;
}

```

---


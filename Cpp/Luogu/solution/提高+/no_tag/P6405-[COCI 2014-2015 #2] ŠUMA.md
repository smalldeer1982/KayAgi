# [COCI 2014/2015 #2] ŠUMA

## 题目描述

森林可以抽象为一个 $n\times n$ 的矩阵，每个元素描述一棵树的高度。

Mirko 为每棵树测量了它们一年生长的米数。**注意：如果一棵树一年长 $5$ 米，半年就会长 $2.5$ 米。**

Mirko 想知道，若已知森林里所有树木的当前高度及生长速度，如果这些树继续以它们当时生长的速度生长，那么所有高度相同的连成一组的树的的树的棵数最大会是多少。

两棵树或一组树是相邻的条件如下：

- 如果两棵树在矩阵中共享一条公共边，则它们是**相邻的**。
- 如果有从第一棵树到第二棵树的相邻树序列，则两棵树是**相邻的**。
- 如果组中的每对树都是相邻的，则一组树是**相邻的**。

## 说明/提示

#### 样例 2 说明

$8$ 个月后，位于 $(0,0),(0,1),(1,0)$ 的树木高度将达到 $\dfrac{13}{3}$ 米，这 $3$ 棵树是相邻的一组树，所以应该输出 `3`。

#### 数据规模与约定

- 对于 $30\%$ 的数据。有 $1\le n\le 70$。
- 对于 $100\%$ 的数据，有 $1\le n\le 700$。

对于所有合法的 $h_{i,j}$ 和 $v_{i,j}$，都有 $1\le h_{i,j},v_{i,j}\le 10^6$。

#### 说明

**题目译自 [COCI2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST #2](https://hsin.hr/coci/archive/2014_2015/contest2_tasks.pdf) _T5 ŠUMA_。**

## 样例 #1

### 输入

```
3
1 2 3
3 2 2
5 2 1
3 2 1
1 2 1
1 2 3
```

### 输出

```
7```

## 样例 #2

### 输入

```
2
3 1
3 3
2 5
2 5
```

### 输出

```
3```

# 题解

## 作者：elbissoPtImaerD (赞：4)

考虑，两颗相邻的树什么时候是等高的。

经典小奥追及问题。  
特别地，若他们生长速度相同，只需考虑初始高度。

那么我们可以在 $\mathcal{O(n^2)}$ 内找到一些形如 $\{(x_1,y_1),(x_2,y_2),t\}$ 的东西，表示 $(x_1,y_1)$ 和 $(x_2,y_2)$ 两棵树在 $t$ 时刻等高且相邻。

那么问题转化为，在一张无向图上，有一些固定边，和一些带有边权的边，求以固定边和一些边权相等的边构成的连通块的大小最大值。

将所有带权边按 $t$ 递增排序，扫的时候找到 $t$ 相同的所有边并加入，计算答案后再将边清除。

用可撤销并查集维护连通块大小即可。

注意精度，细节看代码。

```cpp
const int N=703,M=N*N,fx[]={0,1},fy[]={1,0};
const db Eps=1e-12;
int n,a[N][N],b[N][N],ans;
struct wt
{
	int x,y;
	db t;
	il bool op<(wt yx){return t<yx.t;}
};
sd vector<wt>c;
struct DSU
{
	int fa[M],sz[M],s[M],*p_s=s,mx;
	#define A (*this)
	il int op^(int x){return x^fa[x]?A^fa[x]:x;}
	il void Merge(int x,int y,bool tag=false)
	{
		x=A^x,y=A^y;
		if(x==y) return;
		return sz[x]<sz[y]&&(sd swap(x,y),7),tag&&(*++p_s=y),cx(mx,sz[fa[y]=x]+=sz[y]),void();
	}
	il int op!()
	{
		int x=*p_s--;
		return sz[fa[x]]-=sz[x],fa[x]=x;
	}
	il void op~()
	{
		for(;p_s-s;!A);
		mx=0;
		return;
	}
	#undef A
}S;
#define F(x,y) (x*n+y-n-1)
void Solve()
{
	fdb(3),rd(n);
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) rd(a[i][j]);
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) rd(b[i][j]);
	for(int i=0;i<n*n;++i) S.fa[i]=i,S.sz[i]=1;
	for(int x=1,xx,yy;x<=n;++x) for(int y=1;y<=n;++y) for(int i=0;i<2;++i)
	{
		xx=x+fx[i],yy=y+fy[i];
		if(xx>n||yy>n) continue;
		if(b[x][y]==b[xx][yy])
			if(a[x][y]==a[xx][yy]) S.Merge(F(x,y),F(xx,yy));
			else continue;
		else
		{
			db t=1.*(a[x][y]-a[xx][yy])/(b[xx][yy]-b[x][y]);
			if(t<0) continue;
			c.push_back({F(x,y),F(xx,yy),t});
		}
	}
	sd sort(begin(c),end(c));
	db lst=-1;
	for(wt x:c)
	{
		if(sd fabs(lst-x.t)>Eps) cx(ans,S.mx),~S,lst=x.t;
		S.Merge(x.x,x.y,1);
	}
	for(int i=0;i<n*n;++i) cx(ans,S.sz[i]);
	wrt(ans);
	return;
}
```

[$\green\checkmark$](https://www.luogu.com.cn/record/113712558)。

---

## 作者：Hell0_W0rld (赞：2)

## P6405 [COCI2014-2015#2] ŠUMA 题解

tag：可撤销并查集

### 题目大意
$N\times N$ 方格表，每个格子的数值初始时 $h_{i,j}$，增长速度为每秒 $v_{i,j}$。求某一个时刻（可以为小数）的最大的相同数字构成的连通块大小。

### 解题思路
首先我们显然只需要关心相邻格子是否某一个时刻高度相同。

设两个相邻格子 $(x_1,y_1)$ 和 $(x_2,y_2)$。分以下两种情况讨论：

1. $h_{x_1,y_1}=h_{x_2,y_2}$，且 $v_{x_1,y_1}=v_{x_2,y_2}$。这种情况下，无论哪个时刻这两个格子总是在同一个连通块内。可以用普通并查集直接合并在一起。
2. $(x_1,y_1)$ 永远追不上 $(x_2,y_2)$ 或永远不能被 $(x_2,y_2)$ 追上。这种情况下，这对相邻格是废掉的，不用管它。
3. 其他情况下，记录追上的时间和追上的两个格子。

现在，我们已经有了一个关键事件列表，只需要排序后用可撤销并查集将所有的同一时间发生的“高度相同”的事件用可撤销并查集合并，合并时答案对并查集大小取 max 即可。

每一个时间点做完之后，再利用可撤销并查集的特性全部撤销即可。

代码中使用同一个并查集，用是否记录副本的方式同时实现可撤销并查集和并查集。
### 代码实现
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(register ll i=(l);i<=(r);++i)
#define Rep(i,l,r) for(register ll i=(r);i>=(l);--i)
#define all(x) x.begin(),x.end()
#define rp(i,j,a,b) rep(i,1,a)rep(j,1,n)
using namespace std;
const ll N=709,M=2e6;
ll n,h[N][N],v[N][N];
struct HstInfo{
	ll*addr;
	ll cpy;
} hstP[M],hstSZ[M];
ll nH,ans;
struct Node{
	ll p,sz;
} tr[M];
ll root(ll x){
	return tr[x].p==x?x:root(tr[x].p);
}
ll unite(ll u,ll v,bool isR){
	u=root(u);
	v=root(v);
	if(u==v)return 0;
	if(tr[u].sz>tr[v].sz)swap(u,v);
	if(isR){
		++nH;
		hstP[nH]=(HstInfo){&tr[u].p,tr[u].p};
		hstSZ[nH]=(HstInfo){&tr[v].sz,tr[v].sz};
	}
	tr[u].p=v;
	tr[v].sz+=tr[u].sz;
	return tr[v].sz;
}
void roll(){
	*hstP[nH].addr=hstP[nH].cpy;
	*hstSZ[nH].addr=hstSZ[nH].cpy;
	--nH;
}
void clr(){
	while(nH)roll();
}
#define id(i,j) (i)*n-n+(j)
struct Event{
	ll id1,id2;
	ll dh,dv;
};
vector<Event> events;
bool cmp(const Event&A,const Event&B){
	return A.dh*B.dv<B.dh*A.dv;
}
ll dx[]={0,1,0,-1};
ll dy[]={1,0,-1,0};
int main(){
	cin>>n;
	rp(x,y,n,n)cin>>h[x][y]; 
	rp(x,y,n,n)cin>>v[x][y]; 
	rp(x,y,n,n)tr[id(x,y)]=(Node){id(x,y),1};
	rp(x,y,n,n)rep(k,0,1){
		ll nx=x+dx[k], ny=y+dy[k];
		if(nx>n||ny>n)continue;
		ll dh=h[nx][ny]-h[x][y];
		ll dv=v[x][y]-v[nx][ny];
		if(!dv&&!dh)ans=max(ans,unite(id(x,y),id(nx,ny),0));
		else if(dv>0&&dh>=0)events.push_back((Event){id(x,y),id(nx,ny),dh,dv});
		else if(dv<0&&dh<=0)events.push_back((Event){id(nx,ny),id(x,y),-dh,-dv});
	}
	sort(all(events),cmp);
	ll T=events.size();
	rep(i,0,T-1){
		Event &e=events[i];
		ans=max(ans,unite(e.id1,e.id2,1));
		if(i+1<T&&cmp(e,events[i+1]))clr();
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：275307894a (赞：2)

[题面传送门](https://www.luogu.com.cn/problem/P6405)

[可能更好的阅读体验](https://www.cnblogs.com/275307894a/p/14315742.html)

这题十分卡精度，我开到了$10^{-12}$才过去。

主要有两种做法。

两种做法的核心都是一样的，就是求出相邻两棵树在什么时候一样高。建权值为同样高时间的边，然后找出最大的连通块使的边权相同。

但是在找的过程中我们发现有一些树可能初始高度一样且生长速度一样，那么这些树在任何时候都相同高。在处理这一块上衍生出了两种做法。


做法一:可撤销并查集。
将任何时候都一样高的边(以下称其为万能边)最先加入并查集，然后枚举每一个出现过的天数，将同是这个天数的边加入并查集，每次找到最大连通块。

注意每一个天数枚举完要撤销。时间复杂度$O(n^2log^2n)$

代码实现:
```cpp
#include<cstdio>
#include<algorithm>
#define d(i,j) ((i-1)*n+j)
#define esp 1e-12
#define max(a,b) ((a)>(b)?(a):(b))
#define abs(x) ((x)>0?(x):-(x))
using namespace std;
int n,m,k,ans=1,cnt,un,wn,lasttop;
struct yyy{int x,y;double z;}s[2000039];
int a[2039][2039],b[2039][2039];
inline bool cmp(yyy x,yyy y){return x.z<y.z;}
inline void swap(int &x,int &y){x^=y^=x^=y;}
struct ques{int x,y,flag;};
struct dsu{
	int fa[600039],w[600039],siz[600039],sh;
	ques st[600039],tmp;
	inline int find(int x){return fa[x]==x?x:find(fa[x]);}
	inline void merge(int x,int y){
		int un=find(x),wn=find(y);
		if(un!=wn){
			if(w[un]<w[wn]) swap(un,wn);
			st[++sh]=(ques){un,wn,w[un]==w[wn]};
			siz[un]+=siz[wn];fa[wn]=un;w[un]+=(w[un]==w[wn]);
		}
	}
	inline void del(){
		tmp=st[sh--];
		fa[tmp.y]=tmp.y;w[tmp.x]-=tmp.flag;siz[tmp.x]-=siz[tmp.y];
	}
}f;
int main(){
	freopen("1.in","r",stdin);
//	freopen("suma.out","w",stdout);
	register int i,j,h;
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++) scanf("%d",&a[i][j]);
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++) scanf("%d",&b[i][j]);
	}
	for(i=1;i<=n*n;i++) f.fa[i]=i,f.siz[i]=f.w[i]=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(i!=1){
				if(b[i][j]==b[i-1][j]){
					if(a[i][j]==a[i-1][j])f.merge(d(i,j),d(i-1,j));
				} 
				else s[++cnt]=(yyy){d(i,j),d(i-1,j),((double)(a[i-1][j]-a[i][j]))/(b[i][j]-b[i-1][j])};
			} 
			if(s[cnt].z<-esp) cnt--;
			if(j!=1){
				if(b[i][j]==b[i][j-1]){
					if(a[i][j]==a[i][j-1])f.merge(d(i,j),d(i,j-1));
				} 
				else s[++cnt]=(yyy){d(i,j),d(i,j-1),((double)(a[i][j-1]-a[i][j]))/(b[i][j]-b[i][j-1])};
			} 
		    if(s[cnt].z<-esp) cnt--;
		}
	}
	sort(s+1,s+cnt+1,cmp);lasttop=f.sh;
	for(i=1;i<=n*n;i++) ans=max(ans,f.siz[i]);
	for(i=1;i<=cnt;i++){
		for(j=i;j<=cnt;j++){
			if(abs(s[i].z-s[j].z)>esp) break;
			f.merge(s[j].x,s[j].y);
			un=f.siz[f.find(s[j].x)];
			ans=max(ans,un);
		}
		while(f.sh!=lasttop) f.del();
		i=j-1;
	}
	printf("%d\n",ans);
}
```
做法二:将所有万能边加入并查集缩点，然后同样枚举天数每次进行dfs查找连通块大小。

时间复杂度$O(n^2)$，但还没并查集跑得快。

代码实现(放一下zjdl的代码):
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define maxn 2001
using namespace std;
int n;
struct frac{
	int x,y;//x/y
	frac(int x=0,int y=1):x(x),y(y){}
	friend bool operator == (const frac &a,const frac &b){
		return (ll)a.x*b.y==(ll)b.x*a.y;
	}
	friend bool operator < (const frac &a,const frac &b){
		if((ll)a.y*b.y>0)return (ll)a.x*b.y-(ll)b.x*a.y<0;
		else return (ll)a.x*b.y-(ll)b.x*a.y>0;
	}
};
struct edges{
	int u,v;
	frac k;
}edge[maxn*maxn];
int len;
void add(int u,int v,frac k){
	edge[++len]=(edges){u,v,k};
}
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
int id(int x,int y){return (x-1)*n+y;}
int a[maxn][maxn],b[maxn][maxn];
int fa[maxn*maxn],size[maxn*maxn],ksize[maxn*maxn],w[maxn*maxn],tans;
int get(int x){return fa[x]==x?x:fa[x]=get(fa[x]);}
void merge(int x,int y){
	int gx=get(x),gy=get(y);
	if(gx==gy)return;
	size[gy]+=size[gx];
	fa[gx]=gy;
	w[gy]+=w[gx];
	tans=max(tans,w[gy]);
}
int ans;
bool cmp(const edges &x,const edges &y){
	return x.k<y.k;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)scanf("%d",&b[i][j]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)scanf("%d",&a[i][j]);
	for(int i=1;i<=n*n;i++)fa[i]=i,size[i]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<4;k++){
				int ii=i+dx[k],jj=j+dy[k];
				if(a[i][j]==a[ii][jj]&&b[i][j]==b[ii][jj])merge(id(i,j),id(ii,jj));
			}
		}
	}
	for(int i=1;i<=n*n;i++)get(i),ksize[fa[i]]=size[fa[i]];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<4;k++){
				int ii=i+dx[k],jj=j+dy[k];
				if(ii<1||ii>n||jj<1||jj>n)continue;
				if(fa[id(i,j)]==fa[id(ii,jj)])continue;
				if(a[i][j]==a[ii][jj])continue;
				if((ll)(b[i][j]-b[ii][jj])*(a[ii][jj]-a[i][j])<0)continue;
				add(fa[id(i,j)],fa[id(ii,jj)],frac(b[i][j]-b[ii][jj],a[ii][jj]-a[i][j]));
			}
		}
	}
	sort(edge+1,edge+1+len,cmp);
	for(int i=1;i<=n*n;i++)fa[i]=i,size[i]=1,w[i]=ksize[i],ans=max(ans,w[i]);
	tans=0;
	int l=1;
	for(int i=1;i<=len;i++){
		if(i!=len&&edge[i].k==edge[i+1].k){
			merge(edge[i].u,edge[i].v);
		}
		else{
			ans=max(ans,tans);
			for(int j=l;j<=i;j++){
				fa[edge[j].u]=edge[j].u;
				fa[edge[j].v]=edge[j].v;
				size[edge[j].u]=size[edge[j].v]=1;
				w[edge[j].u]=ksize[edge[j].u];
				w[edge[j].v]=ksize[edge[j].v];
			}
			tans=0;l=i+1;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：wgyhm (赞：1)

[BLOG](https://wgyhm.cf/2022/10/17/P6405-COCI2014-2015-2-SUMA/)

相邻两棵树的关系是以下几种之一：

* $h_i=h_j,v_i=v_j$ 永远相等，我们称为 **万能边**。
* $h_i=h_j,v_i\not = v_j$ 永远不相等。
* $t=\dfrac{h_i-h_j}{v_j-v_i}$，两棵树当且仅当在时刻 $t$ 时相等。如果时刻 $t<0$ ，那么永远不相等。否则，我们把两棵树的边权设为 $t$。

我们把万能边用并查集缩成一个点，并重新建图。然后把所有的两个数相等的时刻 $t$ 离散化，方便枚举。

枚举时刻 $t$，将所有边权为 $t$ 的两个点合并。并判断最大的连通块。

每个非万能边最多枚举一次。万能边已经缩没了。所以复杂度时 $O(cn^2)$，其中 $c$ 是并查集的复杂度。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define maxn 705
#define put() putchar('\n')
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
using namespace std;
inline void read(int &x){
    int f=1;x=0;char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
    x*=f;
}
namespace Debug{
	Tp void _debug(char* f,Ty t){cerr<<f<<'='<<t<<endl;}
	Ts void _debug(char* f,Ty x,Ar... y){while(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	Tp ostream& operator<<(ostream& os,vector<Ty>& V){os<<"[";for(auto& vv:V) os<<vv<<",";os<<"]";return os;}
	#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)
}using namespace Debug;
int h[maxn][maxn],v[maxn][maxn],n,m;
int he[maxn*maxn],head=1;
struct yyy{
	int to,z,wx,wy;
	inline void add(int x,int y,int val,int vall) {
		to=y;z=he[x];he[x]=head;wx=val;wy=vall;
	}
}a[maxn*maxn*8];
struct edges {
	int x,y;
	edges(int a=0,int b=0) {x=a;y=b;}
};
int fx[5]={0,1,-1,0,0};
int fy[5]={0,0,0,1,-1};
vector<edges>e[maxn*maxn];
inline int id(int x,int y) {return (x-1)*n+y;}
int size[maxn*maxn],fa[maxn*maxn],vis[maxn*maxn],nsize[maxn*maxn],tr[maxn*maxn];
inline int getfa(int x) {return x==fa[x]?x:fa[x]=getfa(fa[x]);}
inline void merge(int x,int y) {
	x=getfa(x),y=getfa(y);
	if (x^y) fa[x]=y,size[y]+=size[x];
}
inline void dfs(int x,int cur) {
	int i;vis[x]=1,merge(x,cur);
	for (i=he[x];i;i=a[i].z) if (a[i].wx==-1&&a[i].wy==-1&&!vis[a[i].to]) dfs(a[i].to,cur);
}
int tot,ans;
ll g[maxn*maxn*4];
const int base=1e6;
signed main(void){
	int i,j,k,x,y,gg;
	read(n);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) read(h[i][j]);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) read(v[i][j]);
	for (i=1;i<=n;i++) {
		for (j=1;j<=n;j++) {
			for (k=1;k<=4;k++) {
				x=i+fx[k],y=j+fy[k];
				if (x>=1&&x<=n&&y>=1&&y<=n) ;else continue;
				if (v[i][j]==v[x][y]) {
					if (h[i][j]==h[x][y]) a[++head].add(id(i,j),id(x,y),-1,-1);
				}
				else if (h[i][j]==h[x][y]) a[++head].add(id(i,j),id(x,y),0,0);
				else {
					int tmpy=h[x][y]-h[i][j],tmpx=v[i][j]-v[x][y];
					if (1ll*tmpx*tmpy<0) continue;
					tmpy=abs(tmpy),tmpx=abs(tmpx);gg=__gcd(tmpx,tmpy);
					a[++head].add(id(i,j),id(x,y),tmpy/gg,tmpx/gg);
				}
			}
		}
	}
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) size[id(i,j)]=1,fa[id(i,j)]=id(i,j);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) if (!vis[id(i,j)]) dfs(id(i,j),id(i,j));//,gdb(i,j,size[getfa(id(i,j))]);
	int cnt=0;
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) if (fa[id(i,j)]==id(i,j)) tr[id(i,j)]=++cnt,nsize[cnt]=size[id(i,j)];//,gdb(i,j,cnt,nsize[cnt]);
	for (i=1;i<=n;i++) {
		for (j=1;j<=n;j++) {
			int pus=getfa(id(i,j));
			for (k=he[pus];k;k=a[k].z) {
				int now=getfa(a[k].to);
				if (tr[now]!=tr[pus])assert(a[k].wx!=-1),g[++tot]=1ll*a[k].wx*base+a[k].wy;
			} 
		}
	}
	sort(g+1,g+1+tot);
	tot=unique(g+1,g+1+tot)-g-1;
	for (i=1;i<=n;i++) {
		for (j=1;j<=n;j++) {
			int pus=getfa(id(i,j));
			for (k=he[pus];k;k=a[k].z) {
				int now=getfa(a[k].to);
				if (tr[now]!=tr[pus]) {
					int w=lower_bound(g+1,g+1+tot,1ll*a[k].wx*base+a[k].wy)-g;
					e[w].push_back(edges(tr[pus],tr[now]));
				}
			} 
		}
	}
	for (i=1;i<=cnt;i++) fa[i]=i,size[i]=nsize[i];
	for (i=1;i<=tot;i++) {
		for (auto tmp:e[i]) {
			merge(tmp.x,tmp.y);
			ans=max(ans,size[getfa(tmp.x)]);
		}
		for (auto tmp:e[i]) fa[tmp.x]=tmp.x,size[tmp.x]=nsize[tmp.x],fa[tmp.y]=tmp.y,size[tmp.y]=nsize[tmp.y];
	}
	printf("%d",ans);
	return 0;
}

```



---


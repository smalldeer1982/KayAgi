# [COCI 2008/2009 #3] MATRICA

## 题目描述

您需要构造一个 $n\times n$ 字符矩阵 $M$。

这个字符矩阵有如下几条限制：
1. $M_{i,j}=M_{j,i}(1\le i,j\le n)$。
1. 必须恰好含有 $a_i$ 个字符 $c_i$。

因为构造的方案有很多种，所以你需要输出方案中字典序最小的。

因为输出太多不好，所有你只需要输出 $p$ 列，具体的方案将会在输入格式中声明。

如果无解，请输出 `IMPOSSIBLE`。

## 说明/提示

#### 数据范围与限制
- 对于 $60\%$ 的数据，保证 $n\le 300$。
- 对于 $80\%$ 的数据，保证 $n\le 3\times 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 3\times 10^4$，$1\le k\le 26$，$\sum a_i=n^2$，$c_i\neq c_j$，$1\le p\le 50$。

#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) T4 MATRICA。 

## 样例 #1

### 输入

```
3 3
A 3
B 2
C 4
3
1 2 3 
```

### 输出

```
AAB
ACC
BCC 
```

## 样例 #2

### 输入

```
4 4
A 4
B 4
C 4
D 4
4
1 2 3 4 
```

### 输出

```
AABB
AACC
BCDD
BCDD ```

## 样例 #3

### 输入

```
4 5
E 4
A 3
B 3
C 3
D 3
2
2 4 
```

### 输出

```
AC
BE
DE
ED 
```

## 样例 #4

### 输入

```
4 6
F 1
E 3
A 3
B 3
C 3
D 3
4
1 2 3 4 
```

### 输出

```
IMPOSSIBLE ```

# 题解

## 作者：int_R (赞：1)

[可能更好的阅读体验](https://www.cnblogs.com/int-R/p/matrica.html)

水题。

发现根据限制 $M_{i,j}=M_{j,i}$ 可以知道除了主对角线上的点，其他的点都是成对出现的。也就是说如果有一条要求的 $a_i$ 为奇数，那么**至少有**一个 $c_i$ 在主对角线上。

记 $S=\sum\limits_{i=1}^{k} (a_i\equiv 1\pmod 2)$，即有 $S$ 个要求中 $a_i$ 为奇数。主对角线上只有 $n$ 个点，所以若 $S>n$ 则无解。

----

如果 $S=n$ 很好处理，但如果 $S<n$，说明主对角线上还需要放别的数，而且要一次性放入两个。

我们按字典序从小到大枚举字符，只处理 $(i,j)|i\leq j$ ，也就是主对角线及上方的点。

对于主对角线特别考虑，维护一个栈，从栈顶到栈底**从小到大**。里面放入现在**剩余未填**个数为奇数的字符，每次比较栈顶字符 $a$ 和当前的枚举字符 $b$，设栈的大小为 $cnt$，当前位置为 $(i,i)$：

如果 $b<a$ 则说明将 $b$ 填在此处比将 $a$ 填在此处更优，但同时需要保证 $(i-1)+(cnt+2)\leq n$，因为主对角线上已经填过 $i-1$ 个数，如果将 $b$ 填在这里，就说明在第 $i\sim n$ 行的主对角线上要填 $cnt+2$ 个数。所以如果这个值大于 $n$ 就会不合法。

对于其他点直接顺次放，一种字符一定是连续的，每一行用 `vector` 维护连续的字符段。总共 $n$ 行只会有 $n+|\Sigma|$ 个连续字符段，其中 $|\Sigma|$ 表示字符集大小。

输出答案时直接遍历，一行最多只会有 $|\Sigma|$ 连续的字符段，并且均摊 $O(1)$。

总时间复杂度为 $O(np)$。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAXN=3e4+10;
int n,k,t[26],q[30],cnt,p,pos[60],h[MAXN];
struct node{int l,r,num;};
vector < node > v[MAXN];
inline char ANS(int x,int y)
{
    if(x>y) return ANS(y,x);
    if(x==y) return h[x]+65;
    for(node z:v[x]) if(z.l<=y&&z.r>=y) return z.num+65;
    return 0;
}
int main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#endif
    cin>>n>>k;
    for(register int i=1;i<=k;++i){char c;int a;cin>>c>>a;t[c-65]=a;}
    //逆序，这样从栈顶到栈底从小到大；t[i]/=2 因为只考虑主对角线及上方
    for(register int i=25;i>=0;--i){if(t[i]&1) q[++cnt]=i;t[i]/=2;}
    if(cnt>n){cout<<"IMPOSSIBLE\n";return 0;}
    cin>>p;for(register int i=1;i<=p;++i) cin>>pos[i];
    //cur 是枚举元素
    for(register int i=1,cur=0;i<=n;++i)
    {
        while(!t[cur]) ++cur;
        //这里还要在栈顶加入 cur，因为这一行只填了一个，它变成了还剩奇数个未填
        if((cur<q[cnt]||!cnt)&&i+cnt+1<=n) h[i]=cur,t[cur]-=1,q[++cnt]=cur;
        else h[i]=q[cnt--];
        for(int l=i+1,r;l<=n;l=r+1)
        {
            while(!t[cur]) ++cur;
            r=min(n,l+t[cur]-1);
            v[i].push_back({l,r,cur});
            t[cur]-=(r-l+1);
        }
        for(register int j=1;j<=p;++j) cout<<ANS(i,pos[j]);
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：_Vix_ (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P6411)

---

## 前言

模拟赛做到了。题目是输出 $p$ 列而不是前 $p$ 列，我的眼睛在哪里！！！

## 分析

想要字典序最小，只需要从小到大处理每一个字母就行了。因为是对称的矩阵，我们处理半边就可以了，另一半对称一下。同时对于当前考虑的字母，我们能填完一行就填一行，这样才能保证字典序最小。

我们发现如果某个字母的个数有奇数个，那么它会在主对角线上出现至少一次。如果奇数个数的字母有超过 $n$ 个，一定无解。如果主对角线上剩余格子数为奇数，同样无解，因为对称的性质，我们要偶数个偶数个的填，所以剩奇数个就填不完。每次能填主对角线就先填主对角线，然后再考虑其他的。由于对称的性质，要时刻保证当前字母有偶数个。

题目的 $n \le 3 \times 10^4$，直接一个个格子填，时空复杂度都是 $O(n^2)$ 的，显然过不了。时间方面，对于每一个字母，一行一行填，直到填完为止可以做到 $O(nk)$；空间方面，只需要记录题目要求的 $p$ 列的答案即可，是 $O(np)$ 的。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 3e4 + 10;
int n, m, k, p[N];
int done, tot[N], rest[N], len, cnt;
char s[N], ans[N][55];

void print1(int x, int l, int r, char c) {
	for (int i = 1; i <= k; i++)
		if (l <= p[i] && p[i] <= r) ans[x][i] = c;
}//记录行的答案

void print2(int x, int l, int r, char c) {
	for (int i = 1; i <= k; i++)
		if (p[i] == x) for (int j = l; j <= r; j++) ans[j][i] = c;
}//记录列的答案

void center(char c) {
	tot[c]--, len++;
	print1(len, len, len, c);
}//在主对角线上填一个
// len 是在主对角线上已经填了的数的个数

void work(char c) {
	if (tot[c] & 1) center(c);
	for (int i = done + 1; i <= n; i++) {
		if (!tot[c]) return;
		if (cnt && tot[c] && len < i) cnt -= 2, center(c), center(c);//填两个是为保证当前字母个数时刻是偶数
		int l = n - rest[i] + 1, r = min(n, l + tot[c] / 2 - 1);
		rest[i] -= r - l + 1;//每一行还剩下多少没有填
		if (!rest[i]) done++;//填完了一行，记录一下
		print1(i, l, r, c); print2(i, l, r, c);//横竖都要记录
		tot[c] -= (r - l + 1) << 1;//对称填，字母消耗是两倍
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) rest[i] = n - i;//只考虑填一半
	for (int i = 1; i <= m; i++) {
		cin >> s[i] >> tot[s[i]];
		cnt += tot[s[i]] & 1;//奇数个数字母的个数
	}
	cin >> k;
	for (int i = 1; i <= k; i++) cin >> p[i];
	cnt = n - cnt;
	if (cnt < 0 || cnt & 1) {
		printf("IMPOSSIBLE");
		return 0;
	}
	sort(s + 1, s + m + 1);//从小到大考虑每一个字母
	for (int i = 1; i <= m; i++) work(s[i]);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++)
			cout << ans[i][j];
		puts("");
	}
	return 0;
}
```


---


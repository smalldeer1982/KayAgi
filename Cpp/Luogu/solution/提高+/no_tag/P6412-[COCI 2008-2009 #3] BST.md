# [COCI 2008/2009 #3] BST

## 题目描述

现在有一个 $1\sim n$ 的排列 $a$，将序列中的元素依次放进一个 BST 里，求 BST 中插入函数的执行次数。

**注意：第一个数已经作为 BST 的根。**

如果您无法理解上面说的话，这里有一份伪代码：

```
insert( number x, node n )
    c+1;
    if x is less than the number in node n
        if n has no left child
            create a new node with the number x and set it to be the left child of node n
     else
         insert(x, left child of node n)
     else (x is greater than the number in node n)
         if n has no right child
             create a new node with the number x and set it to be the right child of node n
         else
             insert(x, right child of node n) 
```
您需要求的就是上面的 insert 函数每进行一次后 $c$ 的值。

**再次注意：第一个数已经作为 BST 的根。**

## 说明/提示

#### 数据范围及限制
- 对于 $50\%$ 的数据，保证 $n\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 3\times 10^5$，$1\le a_i\le n$，$a_i$ 互不相同。
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) T5 BST。 

## 样例 #1

### 输入

```
4
1
2
3
4 
```

### 输出

```
0
1
3
6
```

## 样例 #2

### 输入

```
5
3
2
4
1
5 
```

### 输出

```
0
1
2
4
6 ```

## 样例 #3

### 输入

```
8
3
5
1
6
8
7
2
4 
```

### 输出

```
0
1
2
4
7
11
13
15 ```

# 题解

## 作者：kkxacj (赞：25)

upd: 增加文章可读性。

### [题目传送门](https://www.luogu.com.cn/problem/P6412)
#### 题意
现在有一个 $1\sim n$ 的排列 $a$，将序列中的元素依次放进一个 BST 里，求 BST 中插入函数的执行次数。

注意：第一个数已经作为 BST 的根。

#### 思路

暴力模拟肯定会超时，根据二叉搜索树的性质，思考一下可以发现**我们每次只需要找到小于第 $i$ 个数的最大值和大于第 $i$ 个数的最小值。**

所以可以考虑用单调栈解决这道题，又由于 $1\le a_i\le n$，$a_i$ 互不相同，所以数字可以从 $1$ 开始模拟到 $n$,找到第 $i$ 个数左边比它小的数的最大值,再从 $n$ 开始模拟到 $1$,找到第 $i$ 个数右边比它大的最小值。

#### 注意：由于找第 $i$ 个数右边比它大的最小值不能是还没有输入的，所以我们应该找第 $i$ 个数左边比它大的最小值。

干完这一切之后，只需计算它的深度即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 300005;
int n,k,dep[maxn],l[maxn],r[maxn],a[maxn],x[maxn],d[maxn],cnt = 1;
long long ans;
int main()
{
//   freopen(".in","r",stdin);
//   freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) 
	{
		scanf("%d",&x[i]);
		a[x[i]] = i; 
	} 
	for(int i = 1;i <= n;i++)
	{
		while(a[i] < d[cnt] && cnt > 1) cnt--;
		l[i] = x[d[cnt]];
		d[++cnt] = a[i];
	}
	int cnt = 1;
	for(int i = n;i >= 1;i--)
	{
		while(a[i] < d[cnt] && cnt > 1) cnt--;
		r[i] = x[d[cnt]];
		d[++cnt] = a[i];
	}
	cout << 0 << endl;
	for(int i = 2;i <= n;i++) 
	{
		dep[x[i]] = 1 + max(dep[l[x[i]]],dep[r[x[i]]]);
		ans += dep[x[i]];
		printf("%lld\n",ans);
	}
    return 0;
}
```

---

## 作者：Naro_Ahgnay (赞：11)

# **严格 $\Theta(n)$ 算法**

## 题目描述
现在有一个序列 $a$，将序列中的元素依次放进一个 BST 里，求 BST 中插入函数的执行次数。

注意：第一个数已经作为 BST 的根。

## 思路
对于每一个答案，分析后可以发现，每个数一定是在已经加入进去的数中小于它的最大值和大于它的最小值的两个数之间。举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/5fnidjzw.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

对于数 $x$，在每次查找小于 $x$ 的最大值和大于 $x$ 的最小值时，可以用set、线段树等数据结构。而这些结构的时间复杂度为 $\Theta(nlogn)$。然而，还有一种叫做链表的数据结构，可以使时间复杂度降至严格 $\Theta(n)$。

## 步骤

### step1 
首先创造一个链表，链表有两个值，一个是 $las$,指向该位置的前一个位置，一个是 $nxt$,指向该位置的后一个位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/t53br04s.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

### step2
对于输入的 $a_i$,我们倒着向前遍历。对于每一个遍历到的数 $a_i$，此时我们将 $a_i$ 在链表中的前一个数 $list(a)_{las}$ 和后一个数 $list(a)_{nxt}$ 存下来，然后删除 $list(a)$。下面图演示（假设现在删的数是3）：

![](https://cdn.luogu.com.cn/upload/image_hosting/n2mqk806.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

### step3
从1到n正序遍历，对于每一个遍历到的数 $a_i$, $dep(a_i)=max$ \{链表中的前一个数，链表中的后一个数\}。用 $sum$ 保存 $dep(a_i)$ 的和，直接输出就行。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct List{
	int las,nxt;
}li[300011];
int n;
long long sum;
pair<int,int> b[300001];
int a[300001],dep[300001];
int main()
{
//	freopen("P6412.in","r",stdin);
//	freopen("P6412.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		li[i].nxt=i+1,li[i].las=i-1;
	}
	li[0].nxt=1,li[n+1].las=n;
	for(int i=n;i;i--)
	{
		b[a[i]].first=li[a[i]].las,b[a[i]].second=li[a[i]].nxt;
		li[li[a[i]].las].nxt=li[a[i]].nxt,li[li[a[i]].nxt].las=li[a[i]].las;
	}
	dep[a[1]]=0;puts("0");
	for(int i=2;i<=n;i++)
	{
		dep[a[i]]=max(dep[b[a[i]].first],dep[b[a[i]].second])+1;
		sum+=dep[a[i]];
		printf("%lld\n",sum);
	}
	return 0;
} 
```


---

## 作者：Jackson_Miller (赞：10)

这道题可以用单调栈做

我们可以开两个数组，一个是去记录输入数据，另一个去存储第 $i$ 个数在记录输入数据中位子的编号

然后我们单调的是第 $i$ 个数的编号，分别单调左边的和右边的儿子可能性情况，我们还先多建一个 $-1$ 的位置，编号为 $0$ 先加入单调栈

下面展示左边的做法：

从 $1$ 开始找到 $n$ 找到第 $i$ 位的编号前面第 $1$ 个比他大的数的编号，并将它的可能性存入一个左儿子数组，如果没有，在栈中删除比这个数的编号大的值，并将它的编号加入栈，其中要一直维护它的单调性
```cpp
for(int i=1;i<=n;i++){
		while(id[i]<Stck[top]&&top>1) top--;
		l[i]=a[Stck[top]];
		Stck[++top]=id[i];
	}
```
右边同之

最后再计算它的深度即可

完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mx=500005;
int n,Stck[mx],top,a[mx],id[mx],l[mx],r[mx];
long long c,dep[mx];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		id[a[i]]=i;
	}
	dep[0]=-1;
	top=1;
	for(int i=1;i<=n;i++){
		while(id[i]<Stck[top]&&top>1) top--;
		l[i]=a[Stck[top]];
		Stck[++top]=id[i];
	}
	top=1;
	for(int i=n;i>=1;i--){
		while(id[i]<Stck[top]&&top>1) top--;
		r[i]=a[Stck[top]];
		Stck[++top]=id[i];
	}
	for(int i=1;i<=n;i++){
		dep[a[i]]=max(dep[l[a[i]]],dep[r[a[i]]])+1;
		c+=dep[a[i]];
		printf("%lld\n",c);
	}
	return 0;
} 
```

---

## 作者：small_john (赞：7)

## 基本思路

首先分析题目，题目中第 $i$ 次插入完的 $c$ 其实就是前 $i$ 个数在树中深度之和。

深度怎么求呢？我们知道，第 $i$ 个数会插在前 $i-1$ 个数中比他小的数最大的一个与比他大的数最小的一个中深度最大的下面。

---

## 实现方法

这道题可以用**单调栈**做。

先建一个栈 $stk$ ，为了方便，用数组模拟。把每一个数进入的编号记为 $id_i$

初始化与输入代码：

```cpp
scanf("%d",&n);
for(int i = 1;i<=n;i++)
{
	scanf("%d",&a[i]);
	id[a[i]] = i;
}
```


前 $i-1$ 个数中比他小的数最大的一个的求法（记录为 $l_i$）：从 $1\sim n$ 列举**数**，将 $i$ 的编号入栈，并维护单调性（单调递增）。此时，$i$ 的编号所在的位置的前一个数，就是前 $i-1$ 个数中比他小的数最大的一个的编号。

代码：

 ```cpp
for(int i = 1;i<=n;i++)
{
	while(id[i]<stk[top]&&top>1)
		stk[top--] = 0;
	l[i] = a[stk[top]];
	stk[++top] = id[i];
}
```

前 $i-1$ 个数中比他大的数最小的一个的求法（记录为 $r_i$）：与 $l_i$ 的求法基本相同，只需把 $1\sim n$ 改为 $n\sim1$ 即可。

代码：

```cpp
for(int i = n;i>=1;i--)
{
	while(id[i]<stk[top]&&top>1)
		stk[top--] = 0;
	r[i] = a[stk[top]];
	stk[++top] = id[i];
}
```

最后的输出代码：

```cpp

cout<<"0\n";
dep[1] = -1;
for(int i = 2;i<=n;i++)
{
	ans+=dep[a[i]]=max(dep[l[a[i]]],dep[r[a[i]]])+1;
	printf("%lld\n",ans);
}
```
---

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5*1e5+5;
int n,a[N],id[N],l[N],r[N],stk[N],dep[N],top = 1;
long long ans;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		id[a[i]] = i;
	}
	for(int i = 1;i<=n;i++)
	{
		while(id[i]<stk[top]&&top>1)
			stk[top--] = 0;
		l[i] = a[stk[top]];
		stk[++top] = id[i];
	}
	memset(stk,0,sizeof stk);
	top = 1;
	for(int i = n;i>=1;i--)
	{
		while(id[i]<stk[top]&&top>1)
			stk[top--] = 0;
		r[i] = a[stk[top]];
		stk[++top] = id[i];
	}
	cout<<"0\n";
	dep[1] = -1;
	for(int i = 2;i<=n;i++)
	{
		ans+=dep[a[i]]=max(dep[l[a[i]]],dep[r[a[i]]])+1;
		printf("%lld\n",ans);
	}
}
```


---

## 作者：_determination_ (赞：4)

首先，显而易见，单次询问后答案增加的数量为新节点的深度。

那么，这个问题将会从一个模拟问题抽象为数学问题。

首先，我们可以直接模拟，但是在树退化为链的情况下，时间复杂度会达到惊人的 $O(n^2)$。

很明显，我们要优化。那么首先我们考虑可以在哪里进行加速。

关键性质：节点的祖先要么是数值比他小中的最大数，要么是比他大的最小数。考虑二分。但很明显，二分要求有序序列，那么复杂度瓶颈将会在插入上。如果使用链表，则会无法进行二分。那么显然二分是不可行的。

那怎么办呢？没关系，我们已经想到了链式结构，我们先放一下。

考虑建一个数组，值为零则该下标没有被加入，值为一则表示已经被加入到二叉树。那么可以从左往右，从右往左直接找。

虽然时间复杂度没变，但是很明显可以进一步优化。

我们同时从左往右和从右往左搜索。只要一边搜索出来，直接退出。

那么我们可不可以不用往另一边找了呢？很明显可以。使用链表维护左右关系，那么只要知道一边的数，就可以知道另一边。然后就可以直接求了。最坏复杂度 $O(n \log n)$。另外，记得看数据范围。

附上代码及链接：

[Link](https://www.luogu.com.cn/record/105339854)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[300010];
int l[300010],r[300010];
int d[300010];
signed main(){
	int n;
	cin >> n ;
	int x,ans=0;
	cin >> x;
	a[x]=a[0]=a[n+1]=1;
	l[x]=0;
	r[0]=x;
	r[x]=n+1;
	l[n+1]=x; 
	cout << 0 << endl;
	for ( int i = 1 ; i < n ; i++ )
	{
		cin >> x;
		a[x]=1;
		int lp=x-1,rp=x+1;
		while(!a[lp]&&!a[rp])
		{
			lp--;
			rp++;
		}
		if(a[lp])
		{
			rp=r[lp];
		}else{
			lp=l[rp];
		}
		r[lp]=x;
		l[rp]=x;
		r[x]=rp;
		l[x]=lp;
		d[x]=max(d[lp],d[rp])+1;
		ans=ans+d[x];
		cout << ans << endl;
	}
	return 0;
} 
```

---

## 作者：f_hxr_ (赞：3)

[ 题 目 传 送 门 ](https://www.luogu.com.cn/problem/P6412)

### 题意

现在有一个的排列 $a$，将序列中的元素依次放进一个 BST 里，求 BST 中插入函数的执行次数。

注意：第一个数已经作为 BST 的根。

### 分析

首先，暴力肯定会超时，不如来找一找规律。

手算多次可以发现：每个数一定是在**已经加入进去的数**中**小于它的最大值**和**大于它的最小值**的两个数之间。

这俩数咋求捏？用单调栈扫一遍就行了。

而答案当然就是他们的深度中浅的那一个加 1。

但是为什么会这样呢？

我们知道，BST 的**中序遍历**是**有序**的。对于一个非根点 $son$，设它的父节点为 $f$。当 $son$ 为 $f$ 的左儿子时，根据 BST 的性质，$f$ 及 $f$ 的右子树应当比 $son$ 大。又由于 BST 的中序遍历有序，所以 $f$ 是 $son$ 右边比 $son$ 大的结点中最小的一个，也就是大于它的最小值。（可以画个图理解一下）

同理，当 $son$ 为 $f$ 的右结点时，$f$ 是 $son$ 左边的结点（$f$ 及 $f$ 的左子树）中最大的一个，也就是小于它的最大值。

奉上 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[415411],dep[415411],ans,n;
long long lft[415411],rgt[415411];
long long ln[415411],rn[415411]; 
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)lft[i]=i-1,rgt[i]=i+1;
	rgt[n]=0;dep[0]=-1;
	for(int i=n;i>=1;i--){
		ln[a[i]]=lft[a[i]];rn[a[i]]=rgt[a[i]];
		rgt[lft[a[i]]]=rgt[a[i]];
		lft[rgt[a[i]]]=lft[a[i]];
	} 
	for(int i=1;i<=n;i++){
		dep[a[i]]=1+max(dep[ln[a[i]]],dep[rn[a[i]]]);
		ans+=dep[a[i]];
		printf("%lld\n",ans);
	}
}
```

---

## 作者：SilverLi (赞：3)

从 $1\sim n$ 列举数，将 $i$ 的编号入栈，并维护单调性（单调递增）。

此时，$i$ 的编号所在的位置的前一个数，就是前 $i-1$ 个数中比他小的数最大的一个的编号。

前 $i-1$ 个数中比他大的数最小的一个的求法（记录为 $r_i$）：与 $l_i$ 的求法基本相同，只需把 $1\sim n$ 改为 $n\sim1$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,a[N],id[N],l[N],r[N],stk[N],dep[N],top=1;
long long ans;
int main(){
    scanf("%d",&n);
    for(int i = 1;i<=n;i++)
        scanf("%d",&a[i]),id[a[i]]=i;
    for(int i = 1;i<=n;i++){
        while(id[i]<stk[top]&&top>1)--top;
        l[i] = a[stk[top]];
        stk[++top] = id[i];
    }
    memset(stk,0,sizeof(stk));
    top = 1;
    for(int i = n;i>=1;i--){
        while(id[i]<stk[top]&&top>1)--top;
        r[i] = a[stk[top]];
        stk[++top] = id[i];
    }
    cout<<0<<endl;
    dep[1]=-1;
    for(int i=2;i<=n;i++){
        ans+=dep[a[i]]=max(dep[l[a[i]]],dep[r[a[i]]])+1;
        cout<<ans;
    }
}
```

---

## 作者：Foreverxxx (赞：2)

模拟赛写了 1 个多小时的平衡树，结果连样例都过不了……

广告：[一名Blink的博客](https://foreverxxx.blog.luogu.org/)

### 题意

给定一颗二叉搜索树，求插入每个数时总共执行了多少次插入操作。

### 解法

假设我们现在将要插入的数为 $X$，$a$ 为已经插入的所有数中小于 $X$ 的最大数字，$b$ 为已经插入的所有数中大于 $X$ 的最小数字，那么我们可以证明 $X$ 的祖先为 $a$ 或 $b$，而插入这个数所执行的操作次数为 $a$ 和 $b$ 深度的最大值。

非常明显这些东西可以用线段树什么的数据结构来维护，不过 std 的写法属实震惊到了我。

**可以用 map 来维护！**

每次询问时，直接用迭代器和 ``lower_bound`` 函数查找两个数的值就好了，完全可以避免使用复杂的数据结构。（主要是容易打挂）


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
void write(int x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,x; 
map<int,int> depth;
int cnt=0;
signed main() {
    n=read();
    for(register int i=1;i<=n;i++){
    	x=read();
      	int d=0;
      	map<int,int>::iterator it=depth.lower_bound(x);
      	if(it!=depth.end()) d=max(d,it->second+1);
      	if(it!=depth.begin()) d=max(d,(--it)->second+1);
      	depth[x]=d;
      	cnt+=d;
      	write(cnt),puts("");
   }
   return 0;
}
```

---

## 作者：LG1038 (赞：1)

## P6412 [COCI2008-2009#3] BST 题解
### 题意
给 $n$ 个数，依次将其插入一棵二叉查找树中，并再插入后输出调用插入函数的次数。

### 思路
直接暴力模拟明显无法拿到全分，只能拿到 $50$ 分，所以我们通过观察发现他每次要么就插入值比它小的中最大的那个或是值比它大的中最小的那个。那么到底该插入哪一个？当然是只要还有子树为空且符合要求，就是那个。所以我们用两个数组记录每个节点是否有左，右子树，就可以进行 $O(1)$ 查找了。现在唯一的问题就是该如何找到值比它小的中最大的那个或是值比它大的中最小的那个，这里我们可以通过二分进行 $ O(\log{n})$ 的查找。

**这里需要特判是否是集合中最大或最小的，由于答案很大，需要特别注意！。**

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 300007
using namespace std;
set<int>q; 
int n, m, x, tp, cc;
int d[N];
bool ls[N], rs[N];
inline void read(int &x)
{
	x = 0;
	register char v = getchar();
	while(v > '9' || v < '0') v = getchar();
	while(v >= '0' && v <= '9')
	x = (x << 3) + (x << 1) + (v & 15), v = getchar();
}
inline void write(int x)
{
	if(x < 10)
	{
		putchar(x | 48);
		return;
	}
	write(x / 10);
	putchar(x % 10 | 48);
}
signed main(void)
{
	read(n);
	read(x);
	q.insert(x);
	d[x] = 1;
	putchar('0');
	putchar('\n');
	for(int k = 1; k < n; ++ k)
	{
		read(x);
		set<int>::iterator i = q.end();
		-- i;
		if(x <= *q.begin())
		{
			tp = *q.begin();
			ls[tp] = 1;
			d[x] = d[tp] + 1;
			cc += d[x] - 1;
			cout << cc;
			putchar('\n');
			q.insert(x);
			continue;
		}
		if(x >= *i)
		{
			tp = *i;
			rs[tp] = 1;
			d[x] = d[tp] + 1;
			cc += d[x] - 1;
			cout << cc;
			putchar('\n');
			q.insert(x);
			continue;
		}
		set<int>::iterator pq = q.lower_bound(x);
		set<int>::iterator j = pq;
		-- j;
		if(!rs[*j])
		{
			rs[*j] = true;
			d[x] = d[*j] + 1;
			cc += d[x] - 1;
			cout << cc;
			putchar('\n');
			q.insert(x);
			continue; 
		}
		if(!ls[*pq])
		{
			ls[*pq] = 1;
			d[x] = d[*pq] + 1;
			cc += d[x] - 1;
			cout << cc;
			putchar('\n');
			q.insert(x);
			continue;
		}
	}
	return 0;
}
```

---

## 作者：lory1608 (赞：1)

本题就是:每一次插入一个数$X$时，可以证明它的父节点只有两种可能：已经插入的数中刚好比$X$小的数$A$，或刚好比$X$大的数$B$。如果记录了$A$和$B$的深度D[A],D[B]，则$D[x] = max$ { $D[A]$, $D[B]$ }。

只要能快速找$A$,$B$即可。可用线段树，平衡树或双向链表等之类方法都可快速实现。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<set>
using namespace std;
const int maxn=3e5+5;
int n,dep[maxn],val,minv=maxn,a,son[maxn][2];
long long cnt;
inline int min(int a,int b)
{
	return a<b?a:b;
}
struct Splay
{
	int son[maxn][2],val[maxn],cnt,root,fa[maxn];
	inline void rotate(int x)
	{
		int y=fa[x];
		int z=fa[y];
		int k=(x==son[y][1]);
		fa[x]=z;
		son[z][son[z][1]==y]=x;
		fa[son[x][k^1]]=y;
		son[y][k]=son[x][k^1];
		fa[y]=x;
		son[x][k^1]=y;
	}
	inline void splay(int x,int ed)
	{
		while(fa[x]!=ed)
		{
			int y=fa[x];
			int z=fa[y];
			if(z!=ed)
			{
				if((son[y][1]==x)^(son[z][1]==y))rotate(x);
				else rotate(y);
			}
			rotate(x);
		}
		if(ed==0)root=x;
	}
	inline void insert(int x)
	{
		int pos=root,f=0;
		while(pos)
		{
			f=pos;
			if(x==val[pos])break;
			else pos=son[pos][x>val[pos]];
		}
		if(pos==0)
		{
			pos=++cnt;
			fa[pos]=f;
			son[f][x>val[f]]=pos;
			val[pos]=x;
		}
		splay(pos,0);
	}
	inline int find(int x)
	{
		int pos=root;
		while(son[pos][x>val[pos]]!=0)
		{
			if(x==val[pos])return pos;
			else pos=son[pos][x>val[pos]];
		}
		return pos;
	}
	inline int pre(int x)
	{
		int pos=find(x);
		splay(pos,0);
		pos=root;
		if(val[root]<x)return val[root];
		else 
		{
			pos=son[pos][0];
			while(son[pos][1])pos=son[pos][1];
			return val[pos]; 
		}
	}
	inline int nxt(int x)
	{
		int pos=find(x);
		splay(pos,0);
		pos=root;
		if(val[root]>x)return val[root];
		else 
		{
			pos=son[pos][1];
			while(son[pos][0])pos=son[pos][0];
			return val[pos]; 
		}
	}
}splay;
inline int getint()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}
int main()
{
	n=getint();
	val=getint();
	dep[val]=0;
	splay.insert(val);
	printf("%lld\n",cnt);
	minv=val;
	for(int i=1;i<=n-1;++i)
	{
		a=getint();
		int now=splay.nxt(a);
		int pre=splay.pre(a);
		if(son[now][0]==0)
		{
			son[now][0]=a;
			dep[a]=dep[now]+1;
			splay.insert(a);
		}
		else
		{
			son[pre][1]=a;
			splay.insert(a);
			dep[a]=dep[pre]+1;
		}
		cnt+=dep[a];
		printf("%lld\n",cnt);
	}
	return 0;
}

```

---

## 作者：Error_Eric (赞：1)

### 题意

[Link](https://www.luogu.com.cn/problem/P6412)

### Sol

考虑暴力模拟。注意到如果该二叉搜索树趋近于链的形态会导致复杂度变成 $O(n^2)$

注意到平衡树可以避免二叉搜索树退化成近似链的形态。

所以我们就可以采用平衡树。每个节点维护这个节点的值和在真正的二叉搜索树上的深度，每次找到要插入的值的前驱和后缀中深度较深的一个+1作为新的深度插入。

考虑用 ``set`` 实现。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<set>
using namespace std;
#define il inline
il const void readln(int &I){
    I=0;char C=getchar();
    while(!isdigit(C))C=getchar();
    while( isdigit(C))I=I*10+C-'0',C=getchar();
}
int n,ai,p;
unsigned long long c;//十年OI一场空。
struct node{ int v,d; };
bool operator<(node n1,node n2){
    return n1.v<n2.v;
}
set<node>s;
int main(){
    readln(n),readln(ai),s.insert({ai,0}),--n;puts("0");
    while(n--){
        readln(ai),p=0;
        auto it1=s.lower_bound({ai,0}),it2=it1;
        if(it2!=s.begin())--it2;
        if(it1!=s.end())p=max(p,(*it1).d+1);
        if(it2!=s.end())p=max(p,(*it2).d+1);
        s.insert({ai,p}),printf("%llu\n",c+=p);
    }
}
```

---

## 作者：Arthur_Douglas (赞：0)

## 思路

首先我们知道这道题暴力枚举肯定是不行的。因为 BST 的建树最坏情况为 $O(n)$。总时间复杂度 $O(n^2)$。非常不优秀。

所以我们尝试着思考 BST 的性质。我们发现一个新来的数会出现在有且仅有的两个地方。然后我们发现它会在**比它小的数中最大的数的右子树**与**比他大的数中最小的数的左子树**。而且同一时刻，有且仅有一个数的左右子树空闲。然后思路就可以顺而推出。

记录一个右子树是否为空闲的 bool 数组。然后对其进行判断。然后用一些方法去寻找这两个数。然后判断。如果只要有一个合法或不合法。另一个就不用判断了。

向大家推荐一个好方法曰 set。

[详细内容](https://blog.csdn.net/yas12345678/article/details/52601454)

## Code

```cpp
#include <iostream>
#include <set>
using namespace std;
#define int long long
bool has_right[300001];
int cnt[300001];
set<int>a;
void read(int &x)
{
	x = 0;
	char v = getchar();  
	while(v < '0' || v > '9')
	v = getchar();
	while(v >= '0' && v <= '9')
	{
		x = (x << 3) + (x << 1) + (v & 15);
		v = getchar();
	}
}
void write(int x)
{
	if(x < 10)
	{
		putchar(x | 48);
		return ;
	}
	write(x / 10);
	putchar(x % 10 | 48);
}
int x[300001];
signed main()
{
	int n;
	cin >> n;
	int ans = 0;
	for(int i = 1;i <= n;++ i)
	read(x[i]);
	for(int i = 1;i <= n;++ i)
	{
		if(i == 1)
		{
			a.insert(x[i]);
			write(ans) , putchar('\n');
			continue;
		}
		auto it = a.lower_bound(x[i]);
		auto its = a.upper_bound(x[i]);
		if(it != a.begin())
		{
			-- it;
			if(!has_right[*it])
			{
				has_right[*it] = true;
				cnt[x[i]] = cnt[*it] + 1;
				a.insert(x[i]);
				ans += cnt[x[i]];
			}
			else
			{
				cnt[x[i]] = cnt[*its] + 1;
				a.insert(x[i]);
				ans += cnt[x[i]];
			}
		}
		else
		{
			cnt[x[i]] = cnt[*its] + 1;
			a.insert(x[i]);
			ans += cnt[x[i]];
		}
		write(ans);
		putchar('\n');
	}
	return 0;
}
```
~~（hhh）~~

---

## 作者：GGapa (赞：0)

对 BST 的性质不够了解：

- BST 性质：新插入的节点，要么接在在前驱上，要么在后继上，哪个后出现就接在哪个的上面。可以通过这一性质快速建树，可以用 `set`  实现 $O(n \log  n)$，可以用双向链表实现 $O(n)$。


但是这道题用 `set` 好像过不了，不知道是不是我写挂了，因为双向链表比较快，而且好写，推荐大家通过双向量表来构建 BST。


```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
typedef long long LL;
using VI = vector<int>;
const int N = 3e5 + 5;

struct Node {
	int pre, nxt;
};

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	int n; cin >> n;
	vector<int> pos(n + 2), dep(n + 2), A(n + 2);
	vector<Node> li(n + 2);
	vector<array<int, 2>> B(n + 1);
	rep(i, 1, n) {
		cin >> A[i];
		li[i].nxt = i + 1, li[i].pre = i - 1;
	}
	per(i, n, 1) {
		int &a = A[i];
		if(li[a].nxt != n + 1) B[a][0] = li[a].nxt; 
		if(li[a].pre != 0) B[a][1] = li[a].pre;
		li[li[a].nxt].pre = li[a].pre, li[li[a].pre].nxt = li[a].nxt;
	}
	LL ans = 0;
	cout << ans << '\n';
	for(int i = 2, x; i <= n; i++) {
		dep[A[i]] = max(dep[B[A[i]][0]], dep[B[A[i]][1]]) + 1;
		ans += dep[A[i]];
		cout << ans << '\n';
	}
    return 0;
}
```
跑的还挺快，拿到了最优解（157944996）。

---

## 作者：wxzzzz (赞：0)

# BST 做法

### 思路

前置：[二叉查找树的建树优化
](https://www.cnblogs.com/wangxuzhou-blog/p/17962251/miscellaneous#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E5%BB%BA%E6%A0%91%E4%BC%98%E5%8C%96)

直接建出 BST，每次执行的次数就是新插入节点的深度加 $1$，累计即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, idt, d[300005];
long long ans;
set<pair<int, int>> p;
set<pair<int, int>>::iterator it;
struct node {
    int ls, rs, val;
} t[300005];
int insert(int x) {
    if (!idt) {
        p.insert({x, ++idt});
        return 0;
    }

    it = p.lower_bound({x, 0});

    if (it == p.end() || t[(*it).second].ls)
        it--, t[(*it).second].rs = ++idt;
    else
        t[(*it).second].ls = ++idt;

    d[idt] = d[(*it).second] + 1;
    p.insert({x, idt});
    return d[idt];
}
int main() {
    cin >> n;

    while (n--) {
        int x;
        cin >> x;
        ans += insert(x);
        cout << ans << '\n';
    }

    return 0;
}
```

# 笛卡尔树做法

### 思路

BST 的点权满足 BST 的性质，点的编号满足堆的性质；

笛卡尔树的点权满足堆的性质，点的编号满足 BST 的性质。

因为 $a_i$ 是个排列，所以可以用编号作为点权，以点权作为编号建笛卡尔树，就得到了原序列的 BST。

遍历一遍统计即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, rt, top, a[300005], d[300005], s[300005], ls[300005], rs[300005], val[300005];
long long ans;
void dfs(int x) {
    if (ls[x]) {
        d[ls[x]] = d[x] + 1;
        dfs(ls[x]);
    }

    if (rs[x]) {
        d[rs[x]] = d[x] + 1;
        dfs(rs[x]);
    }
}
int main() {
    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> val[i], a[val[i]] = i;

    for (int i = 1; i <= n; i++) {
        while (top && a[s[top]] > a[i])
            top--;

        if (!top)
            ls[i] = s[1], rt = i;
        else
            ls[i] = rs[s[top]], rs[s[top]] = i;

        s[++top] = i;
    }

    dfs(rt);

    for (int i = 1; i <= n; i++) {
        ans += d[val[i]];
        cout << ans << '\n';
    }

    return 0;
}
```

---


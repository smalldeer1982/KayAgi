# [COCI 2014/2015 #1] PIRAMIDA

## 题目背景

Zoran 和 Tomislav 今天很无聊。

## 题目描述

于是，他们把他们喜欢的字符串 `JANJETINA` 按照一定规律在一个塔上从左到右从上到下写了一遍又一遍。

这是塔只有六层的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ja46bpf9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

现在他们想考你一个问题：给定字符串 $s$ 与塔的层数 $n$，将这个字符串在塔上写一遍又一遍，接下来会有 $k$ 个问题，第 $i$ 次问你字符 $c_i$ 在第 $a_i$ 层出现了几次。

## 说明/提示

#### 样例输入输出 1 解释

为题目中的例子。

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 10^3$。
- 对于 $70\%$ 的数据，保证 $|s|\le 10^5$。
- 对于 $100\%$ 的数据，保证 $1\le n \le 10^{18}$，$1\le |s|\le 10^6$，$1\le k\le 5\times 10^4$，$1\le a_i\le n$，输入中涉及的字符均为大写字母。

#### 说明
**本题总分 $100$ 分。**

本题译自 [Croatian Open Competition in Informatics 2014/2015](https://hsin.hr/coci/archive/2014_2015) [Contest #1](https://hsin.hr/coci/archive/2014_2015/contest1_tasks.pdf) T3 PIRAMIDA。

## 样例 #1

### 输入

```
6
JANJETINA
5
1 J
1 A
6 N
6 I
5 E```

### 输出

```
1
0
2
1
1```

## 样例 #2

### 输入

```
5
A
5
1 A
2 A
3 A
4 A
5 B```

### 输出

```
1
2
3
4
0```

## 样例 #3

### 输入

```
3
AB
3
2 A
2 B
3 B```

### 输出

```
1
1
2```

# 题解

## 作者：yxy666 (赞：2)

凌驾于算法之上的思路：

对于第 x 行，在它之前的第 $1$ 行有 $1$ 个元素，第 $2$ 行 有 $2$ 个元素，第 $x-1$ 行有 $x-1$ 个元素。那么显然易见，第 $x$ 行开头元素的下标即为 $x\times (x-1)/2+1 \mod m $，但是这里仍然要注意最后取模等于零的情况。

细节：

直接求 $x\times (x-1)/2+1$ 中途会爆 long long，所以我们要提前取模，但是后面还有一个除法运算，与模运算不相匹配，所以还需要判断数字的奇偶性情况提前除掉。

那么我们就可以刷暴力了。但是很明显，会超时。令 $m$ 等于串长，手玩数据，于是我们发现对于较大的数据，除了开头一段和末尾一段，中间是有连续的一段 $1-m$，那就好处理了。

PS ：这题卡空间，所以需要分成一个一个字母处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
long long n,m,Ans[50005];
int q,Q,sum[maxn];
char a[maxn];
struct yxy{
	int id;long long x;char C;
	bool operator<(const yxy b)const{return C<b.C;}
}t[50005];
long long read(){
	long long ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void calc(int k){
	char ch=t[k].C;
	long long L,R,S;
	
	if(t[k].x&1)L=(long long)((t[k].x%m))*((t[k].x-1)/2%m);
	else L=(long long)((t[k].x/2%m))*((t[k].x-1)%m);
	L++;
	L%=m;if(L==0)L=m;
	if(L+t[k].x-1<=m){
		Ans[t[k].id]=sum[L+t[k].x-1]-sum[L-1];
//		if(L+t[k].x-1>m)Ans[t[k].id]+=sum[t[k].x-m+L-1];
	}//t[k].x -(m-L+1)==t[k].x-m+L-1
	else {
		Ans[t[k].id]=sum[m]-sum[L-1];
		t[k].x-=(m-L+1);L=1;
		long long size=t[k].x/m;
		Ans[t[k].id]+=(long long)size*sum[m];
		R=t[k].x%m;
		if(R!=0)Ans[t[k].id]+=sum[R];
	}
}
int main(){
	n=read();
	scanf("%s",a+1); m=strlen(a+1);
//	for(int i=1;i<=m;i++){
//		for(int j=0;j<26;j++)sum[i][j]=sum[i-1][j];
//		sum[i][a[i]-'A']++;
//	}
	q=read();
	while(q--){
		long long x=read();
		char C=getchar();
		while(C<'A'||C>'Z')C=getchar();
		t[++Q]=(yxy){Q,x,C};
	}
	sort(t+1,t+1+Q);
	for(int i=1;i<=Q;){
		int j=i;
		for(int K=1;K<=m;K++)sum[K]=sum[K-1]+(a[K]==t[i].C);
		while(t[i].C==t[j].C)calc(j),j++;
		i=j;
	}
	for(int i=1;i<=Q;i++)printf("%lld\n",Ans[i]);
	return 0;
} 
```


---

## 作者：Piggy343288 (赞：2)

> 省流：离线以后，每个字符做前缀和然后直接水过去  

首先离线所有询问。对于每个英文字母，我们把查询这个字母的询问都一起处理。  
对于每个字母 $c$，我们跑一遍前缀和，令 $p_i$ 表示 $\mathit{s}_{1,i}$ 中字符 $c$ 出现的次数。接下来我们定义 $\operatorname{f}(i,l,r)$ 为 $\mathit{s}_{l,r}$ 中字符 $i$ 出现的次数。  
对于每次询问:  
首先求出第 $a_i$ 行的第一个字符是什么，这等价于求前 $a_i-1$ 行的元素个数加一再对字符串长度取模。注意到 $n$ 在 `long long` 范围内，因此我们采取下面的函数计算首个字符 $p$。
```
long long getP(long long r) {
    if (r & 1) {
        return r % m * (((r + 1) >> 1) % m) % m;
    } else {
        return (r >> 1) % m * ((r + 1) % m) % m;
    }
}
```
接下来对询问的长度进行分讨。  
要么这行一直到最后都和 $p$ 在同一字符串循环里，那么答案显然是 $\operatorname{f}(p, p + a_i - 1)$。  
要么我们可以把第 $a_i$ 行分成三部分：前面的散块，中间的若干整块和后面的散块。此时分别处理并相加，不难得出 $\operatorname{query}(a_i,c_i)$ 可以被写成 $\operatorname{f}(c_i,\;p,\;len - 1) + \operatorname{f}(c_i,\;0,\;len - 1) \times (\frac{a_i-len-p}{len})+[len\bmod m\not= 0]\times\operatorname{f}(c_i,0,(a_i-p) \bmod m)$。  
> 上面的公式看起来很复杂，其实就是三块分别加起来

综合上述，我们可以得出此题的完整代码如下。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxM = 1000000;
const int maxK = 50000;

struct query {
    long long row;
    int id;
    query(long long row = 0, int id = 0) : row(row), id(id) {}
};

long long n, m, k, a, ans[maxK];
char w[maxM + 1];
int p[maxM];
vector<query> Q[26];

long long getP(long long r) {
    if (r & 1) {
        return r % m * (((r + 1) >> 1) % m) % m;
    } else {
        return (r >> 1) % m * ((r + 1) % m) % m;
    }
}

int f(int p1, int p2) {
    return p[p2] - (p1 != 0 ? p[p1 - 1] : 0);
}

long long solve(long long r) {
    int p = getP(r - 1);
    long long ans = 0, len = r - (m - p);
    if (p + r <= m)
        return f(p, p + r - 1);
    ans = f(p, m - 1) + f(0, m - 1) * (len / m);
    return ans + (!!(len % m)) * f(0, len % m - 1);
}
char c;
int main() {
    scanf("%d", &n);scanf("%s", w);scanf("%d", &k);
    m = strlen(w);
    for (int i = 0; i < k; ++i) {
        scanf("%lld %c", &a, &c);
        Q[c - 'A'].push_back(query(a, i));
    }

    for (int i = 0; i < 26; ++i) {
        for (int j = 0; j < m; ++j) {
            p[j] = (w[j] - 'A' == i) + (!!j) * p[j - 1];
        }
        for (int j = 0; j < Q[i].size(); ++j)
            ans[Q[i][j].id] = solve(Q[i][j].row);
    }

    for (int i = 0; i < k; ++i)
        printf("%lld\n", ans[i]);
    return 0;
}


```


---

## 作者：koukilee (赞：1)

一道分类讨论 + 卡空间 题。

题意： 给你一个只包含大写字符的字符串，并且将它按如下顺序循环排列成 $n$ 层。一共 $q$ 个询问，每次求第 $i$ 层有多少个字符 $ch$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ja46bpf9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

****

注意到 $1\le n\le 10^{18}$ ，明显无法使用模拟的方式编写代码，所以去思考结论。

题目中的字符串书写方式是 **从左到右** 又 **从右到左**，我们发现，其实无论他上一回是从哪一边写过来的，它整体还是那些字符，相对位置不会改变，所以可以其实不用管他的顺序关系。

由于我们不知道第 $i$ 层的第一个字符是原本字符串的哪一个下标，于是我们先求出前 $i - 1$ 层一共有多少个字符。

明显题目中第 $i$ 层的字符数量是 $i$，所以前 $i - 1$ 层的字符数量是 $1$ ~ $i - 1$ 的等差数列。

求和公式是： $sum=(1+(i - 1))\times(i-1)\div2 = i\times(i-1)\div2$。

此处有个**小提醒**：$sum$ 运算过程中可能爆 long long，我们可以强转成 __int128 运算，否则你会收获一大堆 RE。

第 $i$ 层的第 $1$ 个字符的下标即为原字符串的 $pos=(sum \operatorname{mod} len) + 1$，此处 $len$ 为原字符串长度。

****

接下来就开始分讨。

钦定当前行的剩余字符为 $s$。

我们先考虑如果 $len - pos \le s$ ，那么 $pos$ ~ $len$ 之间的数就可以先加进去，方便后面运算。

其次我们考虑 $len \le s$ ，那么我们算出 $tot = len \div s$ ，说明我们还可以放入 $tot$ 个完整的字符串。

最后如果 $s$ 还有剩余，说明还有 $s$ 个字符可以放。

至此，分讨结束。

****

此处我们需要算一个区间内的某个字符的个数，我们可以使用前缀和预处理。

但是需要开 $1e6 \times 26$ 的数组，而题目的空间限制是 $32MB$ 无法通过。

我们此时考虑用分块的时间换取空间，将整个数组分成 $\sqrt n$ 块，数组的大小成了 $1e3\times26$，可以通过此题。

时间复杂度：$O(n\sqrt n)$

****

Code

```c++
/* The code is from koukilee*/

i32 n, q, len, sum[MAXX][26], block, L[MAXX], R[MAXX], pos[MAXN];
char ch[MAXN];

inline void init() noexcept{ /*分块预处理*/
	block = sqrt(len);
	for (i32 i = 1; i <= block; i++)
		L[i] = R[i - 1] + 1, R[i] = block * i;
	if (R[block] < len)
		++block, L[block] = R[block - 1] + 1, R[block] = len;
	for (i32 i = 1; i <= block; i++)
		for (i32 j = L[i]; j <= R[i]; j++)
			pos[j] = i, sum[i][ch[j] - 'A']++; /*第i块中ch[j]的数量++*/
}

inline i64 query (i32 l, i32 r, char c) noexcept{ /*求出一个区间内一个字符的数量*/
	i32 q = pos[l], p = pos[r], ans = 0;
	if (q == p){
		for (i32 i = l; i <= r; i++)
			ans += ch[i] == c;
		return ans;
	} else{
		for (i32 i = q + 1; i < p; i++)
			ans += sum[i][c - 'A'];
		for (i32 i = l; i <= R[q]; i++)
			ans += ch[i] == c;
		for (i32 i = L[p]; i <= r; i++)
			ans += ch[i] == c;
		return ans;
	}

}

int main() noexcept{
	read(n), scanf("%s", (ch + 1)); len = strlen((ch + 1));
	
	init();/*预处理*/
	
	read(q);
	
	while (q--){
		i64 x; char c[5]; scanf("%lld %s", &x, c);
		__int128 all = ((__int128)(1 + x - 1) * (x - 1) / 2) % len, now = x, ans = 0;
        
		if (len - all <= now && all) /*一开始可不可以补满，方便后面计算*/
			ans += query(all + 1, len, *c), now -= (len - all), all = 0;
		if (len <= now){ /*可以放多少个整块*/
			i64 t = now / len;
			ans += query(1, len, *c) * t;
			now -= t * len;
			all = 0;
		}
		if (now) /*余下了多少个位置*/
			ans += query(all + 1, all + now, *c);
		
		put(ans);	
	}
    return 0;
}

```

---

## 作者：Autream (赞：0)

## 题意简述

给定一个字符串 $s$，你需要按照从上到下，从左到右的顺序蛇形地在等边三角形上重复写下 $s$，第 $i$ 层写 $i$ 个字符，最多 $n$ 层，如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/ja46bpf9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

有 $k$ 次询问，每次问你第 $a$ 层的字符 $c$ 有多少个。

## 题目分析

小学找规律题，很明显我们需要得到如下几个变量：

- $len$：字符串的长度。
- $used$：前 $a-1$ 层用过多少字符。
- $st$：第 $a$ 层的起始位置。
- $times$：第 $a$ 层**完整地**循环了多少次 $s$。
- $ed$：第 $a$ 层的结束位置。

根据小学学的等差数列，我们知道前 $i$ 层用的总量 $used = \frac{a(a-1)}{2}$；那么 $st$ 就是 $used$ 中完整出现 $s$ 后的余数，$st = used \operatorname{mod} len$；同理，在选完 $st$ 后还剩下 $left = \max\{0,a - (len - st)\}$ 个字符，$s$ 能完整出现的次数 $len = \lfloor \frac{left}{len}\rfloor$；$ed$ 即为 $left \operatorname{mod}len$。

 答案就是第 $st$ 个字符到末尾的贡献（需要判断以下越界）、$times$ 次完整出现的贡献、$1$ 到 $ed$ 的贡献加起来。
 
其中区间的贡献可以用前缀和预处理出来。**但是**！这道题的内存只有 32 MB，只能开到 $8 \times 10 ^ 6$ 左右，特别的烦人，我们可以考虑只开一个前缀和数组，把询问离线下来，这样就可以通过了。

## AC Code

```cpp
// Problem: P6416 [COCI2014-2015#1] PIRAMIDA
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6416
// Memory Limit: 32 MB
// Time Limit: 1000 ms
// Date: 2024/10/06 10:44:01
// Author: Li_Feiy
#include <bits/stdc++.h>
#define arrout(a, n) rep(i, 1, n) std::cout << a[i] << "\n"
#define arrin(a, n) rep(i, 1, n) a[i] = read()
#define rep(i, x, n) for(int i = x; i <= n; i++)
#define dep(i, x, n) for(int i = x; i >= n; i--)
#define erg(i, x) for(int i = head[x]; i; i = e[i].nex)
#define dbg(x) std::cout << #x << ":" << x << " "
#define mem(a, x) memset(a, x, sizeof a)
#define all(x) x.begin(), x.end()
#define arrall(a, n) a + 1, a + 1 + n
#define PII std::pair<int, int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define int long long
#define CI const int
#define il inline
#define ss second
#define ff first
#define itn int
int read() {
	char ch = getchar();
	int r = 0, w = 1;
	while(ch < '0' || ch > '9') w = ch == '-' ? -1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = r * 10 + ch - '0', ch = getchar();
	return r * w;
}
CI N = 1e6 + 5;
int n, k, len, ans[N], vis[N], sum[N];
struct Query {
	int a, id;
	char c;
	bool operator<(const Query &b) const { return c < b.c; } // 排序以保证一次性处理完所有这种字符
} q[N];
std::string s;
signed main() {
	n = read();
	std::cin >> s;
	len = s.size();
	k = read();
	rep(i, 1, k) q[i].a = read(), std::cin >> q[i].c, q[i].id = i;
	std::sort(arrall(q, k)); // 离线
	rep(i, 1, k) {
		if(q[i].c != q[i - 1].c) rep(j, 0, len - 1) sum[j + 1] = sum[j] + (q[i].c == s[j]); // 更新前缀和数组
		__int128 used = (__int128)q[i].a * (q[i].a - 1) / 2; // 一定要开 __int128，不然会越界
		int st = used % len;
		int times = std::max((q[i].a - (len - st)) / len, 0ll);
		int ed = (q[i].a - (len - st) - times * len > 0) ? (q[i].a - (len - st) - times * len) % len : 0; // 具体含义如上
		ans[q[i].id] = sum[len - st <= q[i].a ? len : std::min(q[i].a + st, len) /*如果还没到末尾就结束了就只选a个*/ ] - sum[st] + times * sum[len] + sum[ed];
	}
	arrout(ans, k);
	return 0;
}
```

---

## 作者：__Octhyccc__ (赞：0)

致敬这道题的传奇空限：32.00 MB，其实也比较好卡，就是不能用二维数组了。

首先，看到了 $a_i\le 10^{18}$，又知道等差数列求和是 $\frac{n(n+1)}{2}$，很好，如果不用同余会炸 long long。

首先，众所周知，$sta\gets \frac{a_i(a_i-1)}{2}$，利用同余的性质，我们可以知道 $sta$ 在模 $p$ 下的值（$p$ 为输入的字符串长度）。下面的 $\%$ 为取余运算。

$$f(sta) = \begin{cases} \big((\frac{sta-1}{2}\%p)\times({sta}\%p)\%p+1\big)\%p & sta \mod2=1 \\ \bigg(\big(\frac{sta\%p}{2}\times (sta-1)\%p\big)\%p+1\bigg)\%p & sta \mod 2=0 \end{cases}$$

对 $end$ 的计算同理。

把询问按字母储存，每次都计算出字符串的前缀和。发现每次询问都可以分为三部分：

1. 中间重复出现的循环字符串（令其区间为 $[l,r]$）。
2. $[sta,l)$。
3. $(r,end]$。

加上分类讨论即可通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr ll MAXN=1e6+7;
constexpr ll MAXK=5*1e4+7;
ll n,ans[MAXK];
char c[MAXN];
ll k,p[MAXN],len;
struct Q{
	ll ai;int id;
};
vector<Q>v[26];
void work(char x){
	memset(p,0,sizeof(p));
	for(int i=1;i<=len;i++){
		if(c[i-1]==x)p[i]++;
		p[i]+=p[i-1];
	}
	return;
}
ll getR(ll begi){
	if(!(begi&1)){
		return (begi/2)%len*((begi+1)%len)%len;
	}
	else{
		return (begi%len)*(((begi+1)/2ll)%len)%len;
	}
}
ll getL(ll begi){
	if(!(begi&1)){
		return ((begi/2)%len*((begi-1)%len)%len+1)%len;
	}
	else{
		return (((begi)%len)*(((begi-1)/2ll)%len)+1)%len;
	}
}
ll MAX(ll a,ll b){return a>b?a:b;}
int main(){
    //freopen("x.in","r",stdin);
    //freopen("x.out","w",stdout);
	scanf("%lld%s%d",&n,c,&k);
	len=strlen(c);
	for(int i=0;i<k;i++){
		char cc;ll a;
		cin>>a>>cc;
		v[cc-'A'].push_back({a,i});
	}
	for(int i=0;i<26;i++){
		work(i+'A');
		for(int j=0;j<v[i].size();j++){
			ll sta=getL(v[i][j].ai);
			ll en=getR(v[i][j].ai);
			//cout<<v[i][j].ai<<" "<<(char)(i+'A')<<endl;
			//cout<<sta<<" "<<en<<endl;
			if(sta==0)sta=len;
			//else if(en==0)en=len;
			ll d1=len-sta+1ll;
			ll round=MAX(0,1ll*(v[i][j].ai-en-d1)/len);
			ll fir=round*p[len],sec=0,thr=0;//fir 是 [sta,en] 中有多少个重复的字符串的字符数
			if(round==0){
				if(sta>en){
					sec=p[len]-p[sta-1];//sec 是第 ai 层重复字符串的左边部分的字符数 
					thr=p[en];//thr 同 sec，不过是右边的字符数 
				}
				else{
					if(v[i][j].ai>len){
						sec=p[len]-p[sta-1];
						thr=p[en];
					}
					else{
						sec=p[en]-p[sta-1];
						thr=0;
					}
				}
			}
			else{
				sec=p[len]-p[sta-1];
				thr=p[en];
			}
			//cout<<fir<<" "<<sec<<" "<<thr<<endl;
			ans[v[i][j].id]=fir+sec+thr;
		}
	}
	for(int i=0;i<k;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---


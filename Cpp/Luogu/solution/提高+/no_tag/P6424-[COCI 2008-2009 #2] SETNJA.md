# [COCI 2008/2009 #2] SETNJA

## 题目描述

在二叉树中：

- 每个节点都有两个孩子——一个左孩子和一个右孩子。
- 如果节点标记为整数 $x$，则其左子节点标记为 $2x$，右子节点标记为 $2x+1$。
- 树的根标为 $1$。

在二叉树上从根开始遍历。遍历中的每一步要么是跳到左孩子上，要么是跳到右孩子上，或暂停休息（停留在同一节点上）。

用由字符 `L`，`R` 和 `P` 组成的字符串描述遍历过程。

- `L `表示跳到左孩子；
- `R `表示跳到右孩子；
- `P `表示暂停一轮操作。

$walk$ 的值是我们最终到达的节点的标签。例如，`LR` 的 $walk$ 值为 $5$，而 `RPP` 的 $walk$ 值为 $3$。

一次遍历由 `L`，`R`，`P` 和 `*` 描述。每个 `*` 可以是三个动作中的任何一个。  例如， `L*R` 可能代表 `LLR`，`LRR` 和 `LPR`。集合 `**` 可能代表 `LL`，`LR`，`LP`，`RL`，`RR`，`RP`，`PL`，`PR ` 和 `PP`。

最后，一次遍历后的 $walk$ 的总值是该次遍历中所有可能的遍历顺序的每一步所形成的 $walk$ 的值的总和。

计算给定遍历顺序后的 $walk$ 的总值。

## 说明/提示

#### 数据规模与约定
- 对于 $30\%$ 的数据，保证输入的字符串中无 `*` 字符。
- 对于 $50\%$ 的数据，保证输入的字符串中至多有三个 `*` 字符。
- 对于 $100\%$ 的数据，保证输入字符串长度小于 $10000$，字符串的每一位只可能是 `L`，`R`，`P`，`*`。
#### 说明
- #### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) SETNJA，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
P*P```

### 输出

```
6```

## 样例 #2

### 输入

```
L*R```

### 输出

```
25```

## 样例 #3

### 输入

```
**```

### 输出

```
33```

## 样例 #4

### 输入

```
LLLLLRRRRRLLLLLRRRRRLLLLLRRRRRLLLLL```

### 输出

```
35400942560```

# 题解

## 作者：wuyonghuming (赞：9)

## 错误：
这道题目我一开始模拟二叉树，结果 $TLE$ $MLE$ $RE$ ， 原因是 $*$ 太多了，需要很多数组，每次来一个就要多两个树枝，如果全部都是 $*$ 时间复杂度极高。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string gaojingdujiafa(string a,string b)
{
	string d,i="",j;
	char f;
	int g=0,h,bb=0;
	if(a.size()<b.size())
	{
		swap(a,b);
	}
	if(a.size()!=b.size())
	{
		for(register int c=b.size()-1;c>=0;c--)
		{
			i+=b[c];
		}
		while(a.size()>i.size())
		{
			i+='0';
		}
		b="";
		for(register int c=i.size()-1;c>=0;c--)
		{
			b+=i[c];
		}
	}
	for(register int c=a.size()-1;c>=0;c--)
	{	
		h=a[c]+b[c]-'0'-'0'+g;
		if(h>=10)
		{
			g=1;
			f=h-10+'0';
		}
		else
		{
			f=h+'0';
			g=0;
		}
		d+=f;										
	}
	if(g==1)
	{
		d+='1';
	}
	i="";
	for(register int c=d.size()-1;c>=0;c--)
	{
		if(bb==0)
		{
			if(d[c]=='0')
			{
				continue;
			}
			else
			{
				bb=1;
			}
		}
		i+=d[c];
	}
 	return i;
}
int main()
{
	string s[2001],str,ans="0";
	int g=1;
	s[1]="1";
	cin>>str;
	for(register int i=0;i<str.size();i++)
	{
		if(str[i]=='L')
		{
			for(register int j=1;j<=g;j++)
			{
				s[j]=gaojingdujiafa(s[j],s[j]);
			}
		}
		else if(str[i]=='R')
		{
			for(register int j=1;j<=g;j++)
			{
				s[j]=gaojingdujiafa(gaojingdujiafa(s[j],s[j]),"1");
			}
		}
		else if(str[i]=='*')
		{
			int l=g;
			for(register int j=1;j<=l;j++)
			{
				g++;
				s[g]=gaojingdujiafa(s[j],s[j]);
				g++;
				s[g]=gaojingdujiafa(gaojingdujiafa(s[j],s[j]),"1");
			}
		}
	}
	for(register int i=1;i<=g;i++)
	{
		ans=gaojingdujiafa(ans,s[i]);
	}
	cout<<ans;
  	return 0;
}
```
## 思路：
需要**找规律**，最后按照规律就可以把答案算出来了。
## 规律：
### 规律一：
我们先假设全部都是 $*$ ，设 $*$ 的个数是 $x$ 。

当 $ x= 1 $ 答案为 $ 6 $

当 $ x= 2 $ 答案为 $ 33 $

当 $ x= 3 $ 答案为 $ 174 $

当 $ x= 4 $ 答案为 $ 897 $

当 $ x= 5 $ 答案为 $ 4566 $

我们用 $ans_i$ 表示 $x_i$ 的答案。

### **我们发现 $ans_i = 5(ans_{i-1})+3^{x-1} $**

**还可以发现，这个规律在加入其他操作的时候依旧成立。**

例子：

$ LRLR = 21 , LRLR* =106 $

$ LRLR* = 106 , LRLR** =533 $

----------------------------------------------
### 规律二：
我们先假设全部都是 $L$ ，设 $L$ 的个数是 $x$ 。

当 $ x= 1 $ 答案为 $ 2 $

当 $ x= 2 $ 答案为 $ 4 $

当 $ x= 3 $ 答案为 $ 8 $

当 $ x= 4 $ 答案为 $ 16 $

当 $ x= 5 $ 答案为 $ 32 $

我们用 $ans_i$ 表示 $x_i$ 的答案。

### **我们发现 $ans_i = 2(ans_{i-1}) $**

**还可以发现，这个规律在加入其他操作的时候依旧成立。**

例子

$ R*R* = 178 , R*R*L =356 $

$ R*R*L = 356 , R*R*LL =712 $

----------------------------------------------
### 规律三：
我们先假设全部都是 $R$ ，设 $R$ 的个数是 $x$ 。

当 $ x= 1 $ 答案为 $ 3 $

当 $ x= 2 $ 答案为 $ 7 $

当 $ x= 3 $ 答案为 $ 15 $

当 $ x= 4 $ 答案为 $ 31 $

当 $ x= 5 $ 答案为 $ 63 $

我们用 $ans_i$ 表示 $x_i$ 的答案。

### **我们发现 $ans_i = 2(ans_{i-1}) + 1 $**

**但是我们发现，这个规律在前面加入 $ * $ 的时候就不成立了。**

例子

$ L*L* = 113 , L*L*R = 235 $

$ L*L*R = 235 , L*L*R = 479 $

### **我们又发现，前面加入 $*$ 就有了新规律**

我们设前面 $*$ 的个数是 $x$ ，用 $ans_i$ 表示答案。

### **$ans_i = 2(ans_{i-1}) + 3^x$**

发现了这些规律，就可以打代码了。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int ans[10001],s[10001];//答案，和三的幂
void LLLLL()//这个是处理L的函数
{
	int z=ans[0],f=0;//ans[0]保存这个数的长度进位可能改变ans[0]所以就用了个z保存，f是判断进位的
	for(int k=z;k>=1;k--)//从低位往高位算
	{
		ans[k]=ans[k]+ans[k]+f;//乘二再加上进位
		f=ans[k]/10;//更新是否需要进位
		ans[k]%=10;//更新这一位的值
	}
	if(f==1)//如果最后还需要进位	
	{
		for(int k=z;k>=1;k--)//从低位到高位
		{
			ans[k+1]=ans[k];//往右移动，因为前面产生了新的一位
		}
		ans[1]=1;//新的那一位一定是1
		ans[0]=z+1;//长度又变长了
	}
	return;//别忘了
}
void RRRRR()//这个是处理R的函数
{
	int z=ans[0],f=0,l=s[0];//ans[0]保存这个数的长度进位可能改变ans[0]所以就用了个z保存，f是判断进位的，l是记录现在三的幂的位置，否则无法和ans对齐
	for(int k=z;k>=1;k--)//从低位往高位算
	{
		ans[k]=ans[k]+ans[k]+f;//乘二再加上进位
		if(l>0)//如果需要继续加
		{
			ans[k]+=s[l];//加上去
		}
		f=ans[k]/10;//更新是否需要进位
		ans[k]%=10;//更新这一位的值
		l--;//往前
	}
	if(f==1)//如果最后还需要进位 	
	{
		for(int k=z;k>=1;k--)//从低位到高位
		{
			ans[k+1]=ans[k];//往右移动，因为前面产生了新的一位
		}
		ans[1]=1;//新的那一位一定是1
		ans[0]=z+1;//长度又变长了
	}
	return;//别忘了
}
void LRLRLRLRLR()//这个是处理*的函数
{
	int z=ans[0],f=0,l=s[0];//ans[0]保存这个数的长度进位可能改变ans[0]所以就用了个z保存，f是判断进位的，l是记录现在三的幂的位置，否则无法和ans对齐
	for(int k=z;k>=1;k--)//从低位往高位算
	{
		ans[k]=ans[k]*5+f;//乘五再加上进位
		if(l>0)//如果需要继续加
		{
			ans[k]+=s[l];//加上去
		}
		f=ans[k]/10;//更新是否需要进位
		ans[k]%=10;//更新这一位的值
		l--;//往前
	}
	if(f!=0)//如果最后还需要进位
	{
		for(int k=z;k>=1;k--)//从低位到高位
		{
			ans[k+1]=ans[k];//往右移动，因为前面产生了新的一位
		}
		ans[1]=f;//新的那一位是f
		ans[0]=z+1;//长度又变长了
	}
	return;//别忘了
}
void sssss()//这个是处理三的幂的函数
{
	int z=s[0],f=0;//s[0]保存这个数的长度进位可能改变s[0]所以就用了个z保存，f是判断进位的
	for(int k=z;k>=1;k--)//从低位往高位算
	{
		s[k]=s[k]*3+f;//乘三再加上进位
		f=s[k]/10;//更新是否需要进位
		s[k]%=10;//更新这一位的值
	}
	if(f!=0)//如果最后还需要进位 
	{
		for(int k=z;k>=1;k--)//从低位到高位
		{
			s[k+1]=s[k];//往右移动，因为前面产生了新的一位
		}
		s[1]=f;//新的那一位是f
		s[0]=z+1;//长度又变长了
	}
	return;//别忘了
}
int main()
{
	string c;//存输入
	ans[1]=ans[0]=s[1]=s[0]=1;//赋初值
	cin>>c;//输入
	for(int i=0;i<c.size();i++)//循环来根据指令操作
	{
		if(c[i]=='L')//如果是左
		{
			LLLLL();//左边函数
		}
		else if(c[i]=='R')//如果是右
		{
			RRRRR();//右边函数
		}
		else if(c[i]=='*')//如果是左右停
		{
			LRLRLRLRLR();//左右停函数
			sssss();//需要再乘三
		}
	}
	for(int i=1;i<=ans[0];i++)//循环输出答案
	{
		printf("%d",ans[i]);//输出
	}
  	return 0;//别忘了
}
```
**谢谢管理审核和大家观赏!**


---

## 作者：zhangshiyan (赞：2)

# P6424 [COCI2008-2009#2] SETNJA
[R180126357 记录详情](https://www.luogu.com.cn/record/180126357)

## Solution
算法：线性DP、高精度。

### 基本情况
如果节点标记为整数 $x$，明显 $L$ 能走到 $2x$，$R$ 能走到 $2x+1$，$P$ 能走到 $x$，而 $*$ 能走到三种情况。

对于全是 $L$ 的情况，设有 $x$ 个 $L$，用 $ans_i$ 表示第 $i$ 个 $L$ 答案，不难发现结果是 $ans_i=2\times ans_{i-1}$。

对于全是 $R$ 的情况，设有 $x$ 个 $R$，用 $ans_i$ 表示第 $i$ 个 $R$ 答案，不难发现结果是 $ans_i=2\times ans_{i-1}+1$。

对于 $P$ 来讲，结果不变即可。

### 进阶情况
对于全是 $*$ 的情况，设有 $x$ 个 $*$，用 $ans_i$ 表示第 $i$ 个 $*$ 答案，不难发现结果是 $ans_i=5 \times ans_{i-1}+3^{i-1}$。

### 优化
当你做完后，开心地提交后，发现错了，为什么呢？不难注意到保证输入字符串长度小于 $10000$，溢出了，怎么办呢？

肯定是用高精度来优化。不会请移步 [高精度计算 - OI Wiki](https://oi-wiki.org/math/bignum/)。

~~虽然是最劣解，但还是能过的。~~

## Code
为了代码的可读性，我将高精度写在函数内。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll read()
{
	ll x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar();
	}
	return x * f;
}

string input;
ll x[10005];
ll y[10005];
ll z[10005];

string add(string a, string b)
{
	memset(x, 0, sizeof(x));
	memset(y, 0, sizeof(y));
	memset(z, 0, sizeof(z));
	ll len1 = a.length();
	ll len2 = b.length();
	for(ll i = 0; i < len1; i++)
	{
		x[len1 - i - 1] = a[i] - '0';
	}
	for(ll i = 0; i < len2; i++)
	{
		y[len2 - i - 1] = b[i] - '0';
	}
	for(ll i = 0; i < max(len1, len2); i++)
	{
		z[i] += x[i] + y[i];
		z[i + 1] = z[i] / 10;
		z[i] %= 10;
	}
	ll i = 10000;
	while(i > 0 && z[i] == 0)
	{
		i--;
	}
	string sum;
	for(; i >= 0; i--)
	{
		sum += z[i] + '0';
	}
	return sum;
}

string times(string a, string b)
{
	memset(x, 0, sizeof(x));
	memset(y, 0, sizeof(y));
	memset(z, 0, sizeof(z));
	if(a == "0" || b == "0")
	{
		return "0";
	}
	ll lena = a.length();
	ll lenb = b.length();
	for(ll i = 0; i < lena; i++)
	{
		x[lena - i] = a[i] - '0';
	}
	for(ll i = 0; i < lenb; i++)
	{
		y[lenb - i] = b[i] - '0';
	}
	ll lenans;
	for(ll i = 1; i <= lena; i++)
	{
		for(ll j = 1; j <= lenb; j++)
		{
			z[i + j - 1] += x[i] * y[j];
			z[i + j] += z[i + j - 1] / 10;
			z[i + j - 1] %= 10;
		}
	}
	if(z[lena + lenb] > 0)
	{
		lenans = lena + lenb;
	}
	else
	{
		lenans = lena + lenb - 1;
	}
	string sum;
	for(ll i = lenans; i >= 1; i--)
	{
		sum += z[i] + '0';
	}
	return sum;
}
string ans[10];
ll cnt;

string calc(string input, ll len)
{
	string ans = "1";
	for(ll i = 1; i <= len; i++)
	{
		if(input[i] == 'L')
		{
			ans = times(ans, "2");
		}
		else if(input[i] == 'R')
		{
			ans = times(ans, "2");
			ans = add(ans, "1");
		}
	}
	return ans;
}

int main()
{
	cin >> input;
	ll n = input.size();
	input = ' ' + input;
	for(ll i = 1; i <= n; i++)
	{
		if(input[i] == '*')
		{
			cnt++;
		}
	}
	if(cnt == 0)
	{
		cout << calc(input, n) << endl;
	}
	else
	{
		ans[0] = "1";
		string x = "1";
		ll cur = 1;
		for(ll i = 1; i <= input.size(); i++, cur ^= 1)
		{
			if(input[i] == 'L')
			{
				ans[cur] = times(ans[cur ^ 1], "2");
			}
			else if(input[i] == 'R')
			{
				ans[cur] = add(times(ans[cur ^ 1], "2"), x);
			}
			else if(input[i] == 'P')
			{
				ans[cur] = ans[cur ^ 1];
			}
			else
			{
				ans[cur] = add(times(ans[cur ^ 1], "5"), x);
				x = add(x, add(x, x));
			}
		}
	}
	cout << ans[n % 2] << endl;
	return 0;
}
```

---

## 作者：NY_Coach (赞：2)

### 算法标签：高精度+线性 dp

看到这个题第一反应肯定是线性 dp，分类讨论。这里我们分 4 种情况讨论，分别对应当前位置对应的字符，也就是 $“L,R,P,*”$ 这四种。我们设 $dp_i$ 表示当前第 $i$ 位置的答案之和，下面我们分情况讨论：

$s_i=L$：是往左走，显然走到了 $2×x$ 节点，所以：$dp_i=2×dp_{i-1}$ 。

$s_i=R$：是往右走，走到 $2×x+1$ 节点，但是答案是 $2×dp_{i-1}+1$ 吗？我们发现不是。如果前面出现了随便选的位置，那么它的三种贡献方案都要+1，所以每次贡献会加3，所以加的数取决于前面有多少个随便走的位置，也就是 “*” 的个数，走后的方案数应该变为原来的三倍，也就是 $dp_i=2×dp_{i-1}+3^x$，$x$ 表示前面随便走的位置的个数。

$s_i=P$：站着不动，那么直接继承上个状态即可，$dp_i=dp_{i-1}$。

$s_i=*$：任意取字符，方案数是前 3 种情况的总和，也就是 $dp_i=2×dp_{i-1}+2×dp_{i-1}+3^x+dp_{i-1}$ 合并同类项就是 $dp_i=5×dp_{i-1}+3^x$，这里注意可随便走的位置个数 +1。

这样局势就清晰了，我们发现数据太大需要用高精度，~~于是我们写一份高精度加法和乘法的模版~~。这样就 OK  了，直接上代码！

注：nxta 代表 $dp_i$ 状态，nxtb 就是 $3^x$ 常数。由于我们只需要记录上一个状态，所以只需要维护一个变量即可，当然高精度的话是一个数组。


```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
string str;
vector<int> a,b;
void print(vector<int>& a){for(int i=(int)a.size()-1;i>=0;i--) cout<<a[i];}
//dp[i]第i位置的方案数

vector<int> add(vector<int> a, vector<int> b) 
{
    vector<int> ret;
    int c=0;
    int sz=max(a.size(),b.size());
    for(int i=0;i<sz||c;++i) 
	{
        int sum=c;
        if(i<(int)a.size()) sum+=a[i];
        if(i<(int)b.size()) sum+=b[i];
        ret.push_back(sum%10);
        c=sum/10;
    }
    return ret;
}

//高精度加法

vector<int> mul(vector<int> a, int b) 
{
    vector<int> ret;
    int c=0;
    for(int i=0;i<(int)a.size()||c;++i) 
	{
        int p=c;
        if(i<(int)a.size()) p+=a[i]*b;
        ret.push_back(p%10);
        c=p/10;
    }
    return ret;
}

//高精度乘法

//输出
signed main() 
{
	cin>>str;
	a.push_back(1);
	b.push_back(1);
    for(int i=0;i<(int)str.size();i++) 
	{
        vector<int> anxt,bnxt=b;
        if(str[i]=='L') 
		{
            anxt=mul(a,2);//dp[i-1]*2
            //往左走 
        } 
		else if(str[i]=='R')
		{
            anxt=add(mul(a,2),b);//dp[i-1]*2+b
            //往右走 
        } 
		else if(str[i]=='P') 
		{
            anxt=a;//dp[i-1]
            //停留原地 
        } 
		else if(str[i]=='*') 
		{
            anxt=add(mul(a,5),b);//dp[i-1]*5+b
            bnxt=mul(b,3);//b*=3
            //随便走 
        }
        a=anxt;
        b=bnxt;
    }
    print(a);
    return 0;
}
```

球球审核员了，希望过审！！！！！

---

## 作者：dzh_goes_to_thu (赞：2)

## 0.写在前面

这题思路较为巧妙，比赛时想了两个小时才做对。  
需要的知识：**高精度** 和 **一元一次方程** 的方法。

## 1.基本情况

设 $p$ 为当前的根（因为从哪里出发都是这样对应 $p$ 的关系），我们就来探讨一下 `L,R,P,*` 分别能走到哪里。

`L` 明显能走到 $2p$ ,`R` 能走到 $2p+1$ ，`P` 能走到 $p$ ，而 `*` 能走到三种情况。

很明显，**全是 `L` 的情况，就是 $2^n p$ ；全是 `R` 的情况，就是 $(2^{n+1}-1)p$ 。**

**如果 `L,R` 交替着**，那么就是 $2(2(2(2(2p+1)+1))+1)...$ 这种情况，**顺序计算即可**。

对于 `P` 来讲，结果不用动即可。

具体而言，我们 **设 $f[i]$ 为到达第 $i$ 个字母的 方案总和** ，那么对于 `L,R` 的分别情况就是 $f[i]=2\times f[i-1]$ 和 $f[i]=2\times f[i-1]+cnt$ （**目前可以只把 $cnt$ 当作 $1$ 看，下一节中会有 $cnt$ 的定义**）。看上去转移简单。

但是接下来的要讨论的情况，可不会这么让人愉快。

## 2.处理 `*` 的情况

当前节点还是 $p$ 。

`*` 有三种情况：**要么转移到 $2p$ 或者 $2p+1$ ，要么就是 $p$** 。

如果打暴力的话，要遍历三种情况，不太明智。

但是仔细思索之后，你会发现**计算这三种情况**的流程大同小异，因为最后 **始终会乘上一个东西**。所以答案也能从前面转移过来了。

于是我们列出式子：$f[i]=f[i-1]\times 2+f[i-1]\times 2+1+f[i-1]$ ，合并同类项成为 $f[i]=f[i-1]\times 5+1$ 。**看上去**这个式子完美无缺。

拿着一个例子计算：`*R` ，答案应该是 `15` ，可能到达的点有 `3,5,7` 。

但是，**按照我们上面的转移式写出的代码，答案少了** $2$ 。拿着同样的东西跑样例二，你会发现答案也少了 $2$ 。

到底是怎么一回事呢？不妨展开式子看看**正确结果如何**。假设我们的起始点为 $p$ 。

正确的答案应该是 $2\times (2p)+1+2\times (2p+1)+1+2\times p+1$ ，应该为 $2\times (5p+1)+3=10p+5=15$ 。

很明显，这出现了 $3$ 项（ $2p,2p+1,p$ ），这三项都加上了 $1$，所以应该加上 $3$ 而并非 $1$ 。

但是对于之后的答案**又只是加上 $3$ 吗？并非**。如果手动展开 `**R` 的情况，将会有 九项 答案，这样应该对答案加上 $9$ 又并非 $3$ 。于是，每碰到一个 `*` 的话，**答案就会变成原来项数的 $3$ 倍**。

上面卖的 $cnt$ 关子，其实就是统计多少项的。

总结规律，**我们可以发现 DP 的最终式子**：

* 当现在是 $L$ 时，$f[i]=f[i-1]\times 2$ 。
* 当现在是 $R$ 时，$f[i]=f[i-1]\times 2+cnt$ 。
* 当现在是 $P$ 时，$f[i]=f[i-1]$ 。
* 当现在是 $*$ 时，$f[i]=f[i-1]\times 5+cnt$ 。

然后要使用 **高精度计算** 解决问题。

## 3.参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;typedef int I;typedef long long LL;const int inf=1073741823;I FL;char CH; template<typename T>void in(T&a){for(FL=1,CH=getchar();!isdigit(CH);CH=getchar())FL=(CH=='-')?-1:1;for(a=0;isdigit(CH);CH=getchar())a=a*10+CH-'0';a*=FL;}template<typename T,typename...Args>void in(T&a,Args&...args){in(a);in(args...);}
const int maxn=1e4+10;
char a[maxn];
I n;

struct bint
{
	int len,s[8000];
 	bint(){memset(s,0,sizeof(s)),len=1;}
 	bint(int num){*this=num;}
  	bint(const char*num){*this=num;}
	bint operator=(int num){char s[8000];sprintf(s,"%d",num);*this=s;return *this;} 
	string str()const{string res="";for(int i=0;i<len;i++)res=(char)(s[i]+'0')+res;if(res=="")res="0";return res;}
  	void clean(){while(len>1&&!s[len-1])len--;}
  	bint operator=(const char*num){len=strlen(num);for(int i=0;i<len;i++)s[i]=num[len-i-1]-'0';return *this;}
  	bint operator+(const bint&b)const{bint c;c.len=0;for(int i=0,g=0;g||i<max(len,b.len);i++){int x=g;if(i<len)x+=s[i];if(i<b.len)x+=b.s[i];c.s[c.len++]=x%10;g=x/10;}return c;}
 	bint operator*(const bint&b){bint c;c.len=len+b.len;for(int i=0;i<len;i++)for(int j=0;j<b.len;j++)c.s[i+j]+=s[i]*b.s[j];for(int i=0;i<c.len-1;i++)c.s[i+1]+=c.s[i]/10,c.s[i]%=10;c.clean();return c;}
	bint operator-(const bint&b){bint c;c.len=0;for(int i=0,g=0;i<len;i++){int x=s[i]-g;if(i<b.len)x-=b.s[i];if(x>=0)g=0;else{g=1;x+=10;}c.s[c.len++]=x;}c.clean();return c;}
	bool operator<(const bint&b)const{if(len!=b.len)return len<b.len;for(int i=len-1;i>=0;i--)if(s[i]!=b.s[i])return s[i]<b.s[i];return 0;} 
  	bool operator>(const bint&b)const{return b < *this;}
 	bool operator<=(const bint&b){return !(b>*this);}
	bool operator==(const bint&b){return !(b<*this)&&!(*this<b);}
	bint operator+=(const bint&b){*this=*this+b;return *this;}
	bint operator*=(const bint&b){*this=*this*b;return *this;}
}f[2],g;

int main(){
	CH=getchar();
	while(!isgraph(CH))CH=getchar();
	while(isgraph(CH))a[++n]=CH,CH=getchar();
	g=1;f[0]=1;
	for(I i=1,T=1;i<=n;++i,T^=1){
		f[i&1]=0;
		if(a[i]=='L')f[T]=f[T^1]*2;
		if(a[i]=='R')f[T]=f[T^1]*2+g;
		if(a[i]=='P')f[T]=f[T^1];
		if(a[i]=='*')f[T]=f[T^1]*5+g,g*=3;
	}
	printf("%s",f[n&1].str().c_str());
	return 0;
}
```

---

## 作者：ljlawa (赞：1)

[传送门](https://www.luogu.com.cn/problem/P6424)

这是一道推式子加高精的题。

题目大意就是让你模拟他给你的走法，并输出最后走到的点的编号总和。

对于每次操作，我们可以都先拿一个点理解。

令第 $i$ 次操作为 $f_i$。

对于操作 `L`，$f_i=2 \times f_{i-1}$ 原因显然。点 $x$ 左儿子为 $2x$。

对于操作 `R`， $f_i = 2 \times f_{i-1} + 3^P$，$P$ 为此操作前有多少个 `*` 操作。

因为对于一个点 $f'_i=2 \times f'_{i-1}+1$，而前面进行了 $P$ 次 `*` 操作，分裂成了 $3^P$ 种情况。

对于操作 `P`，$f_i=f_{i-1}$，原因显然。

对于操作 `*`，$f_i=5 \times f_{i-1} + 3^P$，因为此次操作相当于把前三种操作各执行一次，也就是 $2 \times f_{i-1} + 2 \times f_{i-1} + 3^P + f_{i-1}$，化简得 $5 \times f_{i-1} + 3^P$。

然后这题就愉快的做完一半了。

另外一半是高精。这就不用多说了。具体见代码。（高精写的特别抽象qwq。）

代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e4 + 5;
const int M = 1e6 + 5;

int n;
char a[N];
int id[4];
int f[4][M], tot;
int f3[M], tot3;
int cnt;

void change() { swap (id[1], id[2]); }

void times(int x)
{
	f[id[2]][0] = f[id[1]][0];
	int add = 0;
	for (int i = 1; i <= f[id[2]][0]; i ++)
	{
		f[id[2]][i] = f[id[1]][i] * x + add;
		add = f[id[2]][i] / 10;
		f[id[2]][i] %= 10;
	}
	if (add) f[id[2]][++ f[id[2]][0]] = add;
}

void times3 ()
{
	int add = 0;
	for (int i = 1; i <= tot3; i ++)
	{
		f3[i] = f3[i] * 3 + add;
		add = f3[i] / 10;
		f3[i] %= 10;
	}
	if (add) f3[++ tot3] = add;
}

void add ()
{
	int add = 0;
	f[id[2]][0] = max (f[id[2]][0], tot3);
	for (int i = 1; i <= f[id[2]][0]; i ++)
	{
		f[id[2]][i] += f3[i] + add;
		add = f[id[2]][i] / 10;
		f[id[2]][i] %= 10;
	}
	if (add) f[id[2]][++ f[id[2]][0]] = add;
}

int main()
{
	id[1] = 1, id[2] = 2;
	f3[1] = 1, tot3 = 1;
	f[id[1]][0] = 1;
	f[id[1]][1] = 1;
	scanf ("%s", (a + 1));
	n = strlen(a + 1);
	for (int i = 1; i <= n; i ++)
	{
		if (a[i] == 'L') times(2);
		else if (a[i] == 'R') times(2), add();
		else if (a[i] == '*') times(5), add(), times3();
		else times (1);
		change ();
	}
	for (int i = f[id[1]][0]; i >= 1; i --) printf ("%d", f[id[1]][i]);
	return 0;
}
```


---

## 作者：Aiopr_2378 (赞：0)

## 解题思路：

每到一个点，我们有4种操作可以进行：

- `L`：走左子树

- `R`：走右子树

- `P`：不移动

- `*`：走以上三种方案的任意一种

观察范围可以得知，我们只能在输入的字符串上进行操作，而不可能模拟出一棵二叉树。

我们考虑从左往右依次看每个字符。因为答案要求总值，所以可以按照如下方法 $O(len)$ 进行规划和计算。

首先，我们需要一个当前总答案 $x$。

如果这一步为 `P`，就意味着不需要任何改动，答案为

$$
ans=x
$$

如果这一步为 `L`，就意味着，当前所有可能的方案都要走到它的左子树，那么答案就应改变为

$$
ans=2x
$$

如果这一步为`R`，就意味着，所有方案都要走到右子树。注意，每一次 `*` 操作都会分出三条支路，所以设共进行了 $y$ 次 `*` 操作，就应该分了 $3^y$ 条之路。故答案为

$$
ans=2x+3^y
$$

如果这一步为 `*`，就意味着，可能进行如上3种方案，答案为累加的结果

$$
\begin{aligned}
ans&=x+2x+2x+3^y\\
&=5x+3^y
\end{aligned}
$$

另外，注意这个答案可能非常大，需要高精度。

## 参考代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int len,y;
string s;
struct num{
    int w[20005];
    void clean(){
        memset(w,0,sizeof(w));
    }
    num operator*(int x)const{
        num tmp;
        tmp.clean();
        int t=0;
        tmp.w[0]=w[0];
        for(int i=1;i<=w[0];i++){
            tmp.w[i]=w[i]*x+t;
            t=tmp.w[i]/10;
            tmp.w[i]%=10;
        }
        if(t){
            tmp.w[++tmp.w[0]]=t;
        }
        return tmp;
    }
    num operator+(num x)const{
        num tmp;
        tmp.clean();
        int t=0;
        tmp.w[0]=max(x.w[0],w[0]);
        for(int i=1;i<=tmp.w[0];i++){
            tmp.w[i]=w[i]+x.w[i]+t;
            t=tmp.w[i]/10;
            tmp.w[i]%=10;
        }
        if(t){
            tmp.w[++tmp.w[0]]=t;
        }
        return tmp;
    }
}a,k;
int main(){
    cin>>s;
    len=s.length();
    a.w[1]=a.w[0]=1;
    k.w[0]=k.w[1]=1;
    for(int i=0;i<len;i++){
        if(s[i]=='L') a=a*2;
        if(s[i]=='R') a=a*2+k;
        if(s[i]=='*') a=a*5+k,k=k*3;
    }
    for(int i=a.w[0];i;i--){
        cout<<a.w[i];
    }
    return 0;
}
```


---

## 作者：NDFS (赞：0)

根据题意，每次有一个 $ * $ 号时会有三条分支，最后这些分支都需要统计答案，设未分支前 $walk$ 值为 $x$，则分支后总和：
$$x+2x+2x+1=5x+1$$
设已出现的 $ * $ 号有 $y$ 个，因为每次都会分出三条，所以情况数是 $3^y$，所以上式的 $1$ 应为 $3^y$，则 $2x+1$ 最后应为 $2x+3^y$，$5x+1$ 最后应为 $5x+3^y$。
综上，统计的步骤应为：
- 当动作为 $P$，$x=x$。
- 当动作为 $L$，$x=2x$。
- 当动作为 $R$，$x=2x+3^y$。
- 当动作不定即 $ * $，$x=5x+3^y$，$y=y+1$。

本题路径长度小于 10000，需要写高精度以存储。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rg register int
using namespace std;
struct node
{
	int len,num[2005];
}x,bz;//x是统计值，bz是3^y
int n;
char s[10005];
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	x.len=1,x.num[1]=1,bz.len=1,bz.num[1]=1;
	for(rg t=1;t<=n;t++)
	{
		if(s[t]=='L')//这种情况x*2
		{
			for(rg i=1;i<=x.len;++i)x.num[i]*=2;
			for(rg i=1;i<=x.len;++i)if(x.num[i]>9999)x.num[i+1]+=x.num[i]/10000,x.num[i]%=10000,x.len=i+1>x.len?x.len+1:x.len;
		}
		else if(s[t]=='R')//这种情况x*2+3^y
		{
			for(rg i=1;i<=x.len;++i)x.num[i]*=2;
			for(rg i=1;i<=x.len;++i)if(x.num[i]>9999)x.num[i+1]+=x.num[i]/10000,x.num[i]%=10000,x.len=i+1>x.len?x.len+1:x.len;
			x.len=x.len<bz.len?bz.len:x.len;
			for(rg i=1;i<=x.len;++i)x.num[i]+=bz.num[i];
			for(rg i=1;i<=x.len;++i)if(x.num[i]>9999)x.num[i+1]+=x.num[i]/10000,x.num[i]%=10000,x.len=i+1>x.len?x.len+1:x.len;
		}
		else if(s[t]=='*')//这种情况x*5+3^y，y也要增加
		{
			for(rg i=1;i<=x.len;++i)x.num[i]*=5;
			for(rg i=1;i<=x.len;++i)if(x.num[i]>9999)x.num[i+1]+=x.num[i]/10000,x.num[i]%=10000,x.len=i+1>x.len?x.len+1:x.len;
			x.len=x.len<bz.len?bz.len:x.len;
			for(rg i=1;i<=x.len;++i)x.num[i]+=bz.num[i];
			for(rg i=1;i<=x.len;++i)if(x.num[i]>9999)x.num[i+1]+=x.num[i]/10000,x.num[i]%=10000,x.len=i+1>x.len?x.len+1:x.len;
			for(rg i=1;i<=bz.len;++i)bz.num[i]*=3;
			for(rg i=1;i<=bz.len;++i)if(bz.num[i]>9999)bz.num[i+1]+=bz.num[i]/10000,bz.num[i]%=10000,bz.len=i+1>bz.len?bz.len+1:bz.len;
		}
	}
	for(rg i=x.len;i>=1;i--)
	{
		if(i!=x.len)//写了压位高精度，补前导零
		{
			if(x.num[i]<=999)printf("0");
			if(x.num[i]<=99)printf("0");
			if(x.num[i]<=9)printf("0");
		}
		printf("%d",x.num[i]);
	}
	return 0;
}

```


---

## 作者：yxy666 (赞：0)

除星号外，一共有三种操作。一种是停留，一种是向左走，一种是向右走。对于每一个出现星号的地方，包含了上面的三种可能，全部累加即可。

此题数据较大，需要用到高精度。

code :
```cpp
#include<bits/stdc++.h>
using namespace std;
const int TT=10000;
const int maxn=10005;
int n;
struct Big_int{
	int len,a[maxn];
	Big_int(){len=0;memset(a,0,sizeof a);}//清空
	Big_int(int x){
		len=0;memset(a,0,sizeof a);
		while (x) a[++len]=x%TT,x/=TT;
	}//按位脱离
	Big_int operator +(const Big_int b){
		Big_int c;
		c.len=max(len,b.len);
		for (int i=1;i<=c.len;i++){
			c.a[i]+=a[i]+b.a[i];
			c.a[i+1]+=c.a[i]/TT;//进位
			c.a[i]%=TT;
		}
		if (c.a[c.len+1]) c.len++;//如果最后还有，那就再进一位
		return c;
	}//高精度+
	Big_int operator *(const Big_int b){
		Big_int c;
		c.len=len+b.len-1;
		for (int i=1;i<=len;i++)
		for (int j=1;j<=b.len;j++){
			c.a[i+j-1]+=a[i]*b.a[j];
			c.a[i+j]+=c.a[i+j-1]/TT;//进位
			c.a[i+j-1]%=TT;
		}
		if (c.a[c.len+1]) c.len++;
		while (c.len>1&&!c.a[c.len]) c.len--;//如果有一堆前导0，干掉
		return c;
	}高精度*
	void print(){
		printf("%d",a[len]);
		for (int i=len-1;i;i--) printf("%04d",a[i]);
		printf("\n");
	}//输出，此处要注意的是四位一起处理的
}x,ans;//高精度
char a[maxn];
int main(){
	scanf("%s",a+1);n=strlen(a+1);
	x=1;ans=1;
	for(int i=1;i<=n;i++){
		if(a[i]=='L')ans=ans*2;//往左走，值乘以2，其余不变
		if(a[i]=='R')ans=ans*2+x;//往右走，值乘以2，由于之前有多种可能，叶子节点的可能数变多，不能只加一次1，是3^星号个数
		else if(a[i]=='*'){
			ans=ans*5;ans=ans+x;
        //ans=ans(不动)+2*ans(往左走)+2*ans+x(往右走)
        x=x*3;//又多了三种可能，乘以之前的可能即为最多可能
		}
	}
	ans.print();//高精度输出
	return 0;
}
```


---

## 作者：BingBang (赞：0)

先考虑不存在$*$的情况。  
设当前答案为$ans$，则  

$L:ans \times 2$    
$R:ans \times 2 +1$  
$P:ans$   

随后考虑$*$对答案的影响：  
$*$可以分为三种情况：$L,R,P$，分别对应答案$ans \times 2,ans \times2 +1,ans$，总和为$ans \times 5 +1$，但考虑到每一次$*$之后，情况数(即$ans$状态的方案数)就会变为原来的$3$倍，那么在执行$R$动作时，原先的$+1$也需要变成加情况数。故记录一个$num$表示当前的情况数，初始值为$1$，每次$*$之后乘$3$，$L,R,P,*$对应的$ans$变化也修改成如下： 

$L:ans \times 2$    
$R:ans \times 2 +num$  
$P:ans$            
$*:ans \times 5 +num$  

也可以这样理解$*$：相当于每个情况对应的节点分裂成$3$个节点,分别访问左子节点,访问右子节点和停留。  
采取这种方法，就可以线性统计得到答案。由于答案数值较大，需要使用高精度表示数值。  
部分详细解析见代码及注释。  
示例代码：
```
#include<bits/stdc++.h>
using namespace std;
#define re register
inline int read(){
	re int x=0,f=1;re char ch=getchar();
	while(!(ch>='0'&&ch<='9')&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void fput(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)fput(x/10);
	putchar(x%10+'0');
	return ;
}
#define M 10005
struct bignum{//高精度表示数 
	char a[50005];
	int len;
	inline void mul(){//自乘2
		for(re int i=1;i<=len;i++){
			a[i]<<=1;
		} 
		for(re int i=1;i<=len;i++){
			if(a[i]>=10){
				a[i+1]+=a[i]/10;
				a[i]%=10;
			}
		}
		if(a[len+1])len++;
		return ;
	}
	inline void add(){//自加1
		a[1]++;
		re int i=1;
		while(a[i]==10){
			a[i+1]++;
			a[i]=0;
			i++;
		} 
		if(a[len+1])len++;
		return ;
	}
	inline void ptr(){//输出 
		for(re int i=len;i>=1;i--){
			fput((int)a[i]);
		}
		return ;
	}
	inline void mul2(int x){//自乘x
		 for(re int i=1;i<=len;i++){
			a[i]*=x;
		} 
		for(re int i=1;i<=len;i++){
			if(a[i]>=10){
				a[i+1]+=a[i]/10;
				a[i]%=10;
				len=max(len,i+1);
			}
		}
		return ;
	}
};
inline void add(bignum &x,bignum y){//相当于将高精度表示的x和y相加后的结果赋值给x 
	re int len=max(x.len,y.len);
	x.len=len;
	for(re int i=1;i<=len;i++){
		x.a[i]+=y.a[i];
		if(x.a[i]>=10){
			x.a[i+1]+=x.a[i]/10;
			x.a[i]%=10;
			if(i+1>x.len)x.len=i+1;
		}
	}
	return ;
}
int n;
char s[M];
bignum ans,num;
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	ans.add();num.add();//初始化 
	for(re int i=1;i<=n;i++){
		if(s[i]=='L')ans.mul();//访问左子节点,直接乘2 
		else if(s[i]=='R')ans.mul(),add(ans,num);//访问右子节点,乘2后加上节点情况数 
		else if(s[i]=='P');//无需操作 
		else ans.mul2(5),add(ans,num),num.mul2(3);
      		//乘5后加上节点情况数,随后节点情况数变为原来的3倍
		//(相当于每个节点分裂成3个节点,分别访问左子节点,访问右子节点和停留) 
	}
	ans.ptr();
	return 0;
}
```

---


# [COCI 2008/2009 #1] JEZ

## 题目描述

有一个长为 $r$ 宽为 $c$ 的矩形，将其划分为 $r\times c$ 个 $1\times 1$ 的小矩形。

**行数从上到下从 $0$ 到 $r-1$ 编号，列数从左到右从 $0$ 到 $c-1$ 编号。**

每个小矩形都有颜色，如果一个小矩形的行数为 $x$，列数为 $y$，则：
- 若 $x\oplus y=x+y$ 这个小矩形为灰色。
- 反之，则为白色。

下左图为 $r=c=10$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/g7uxh6zh.png)

现在有人沿着上右图的轨迹沿着这个矩形走 $k$ 步，求他走了多少个灰色格子。

## 说明/提示

#### 数据规模与约定
- 对于 $50\%$ 的数据，保证 $k\le 10^6$。
- 对于 $100\%$ 的数据，保证 $1\le r,c\le 10^6$，$1\le k\le r\times c$，答案在 $32$ 位整数范围之内。
#### 说明：
#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) JEZ，译者 @[菜鸟一只](https://www.luogu.com.cn/user/175829)。

## 样例 #1

### 输入

```
10 10
6```

### 输出

```
5```

## 样例 #2

### 输入

```
3 5
11```

### 输出

```
8```

## 样例 #3

### 输入

```
10 10
100```

### 输出

```
51```

# 题解

## 作者：_Vix_ (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P6429)

---

## 分析

看到题目的第一眼，发现这个人的走法比较鬼魅，但是我们考虑拆成一条条斜着走的路径。

对于当前 $n$ 行 $m$ 列的矩形，令 $n \le m$，我们发现第 $1 \sim n$ 条路径的长度递增，第 $n+1 \sim m$ 条路径的长度达到最大并且一直保持不变， 第 $m + 1 \sim n + m - 1$ 条路径的长度递减。记录路径的端点，并用差分数组维护，我们就可以快速找到每一行可以走到的最右边的数是多少。

现在需要快速得到，对于一个数 $x$，有多少在 $[0,y]$ 之间的数满足 $x\oplus y=x+y$。转化一下，我们发现只要 $x$ 和 $y$ 的二进制位上有至少一位都为 $1$，那么就不满足条件。我们求出不合法数的总和，答案就是 $k$ 减去不合法数。那么对于从高到低的第 $i$ 位，如果 $y$ 的第 $i$ 位是 $0$，跳过，找下一位。当前 $y$ 的第 $i$ 位是 $1$，我们假定这一位是 $0$，那么后面的位子就必须要有一个公共 $1$，简单计数。如果 $x$ 的第 $i$ 位也是 $1$，那么 $y$ 就可以不用找了，因为已经找到一个 $1$ 了，后面的数直接累加到答案里面。

具体实现可以看代码，总时间复杂度 $O(n \log^2 V)$，$V$ 是值域大小。

## Code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e6 + 10;
int n, m, d[N];
ll k, tot, step;

inline int pos(int x, int i) {
	return (x >> i - 1) & 1;//位运算找到 x 的第 i 位是 0 还是 1
}

inline int work(int x, int y) {//这里 x 和 y 是反着的
	int ans = 0;
	for (int i = 21; i; i--) {
		if (!pos(x, i)) continue;
		int cnt = 0;//记录 1 的个数
		for (int j = i - 1; j; j--) cnt += pos(y, j);
		ans += (1 << (i - 1 - cnt)) * ((1 << cnt) - 1);//0 的位子上随便选，1 的位子至少有一个 1
		if (!pos(y, i)) continue;
		for (int j = i - 1; j; j--)
			if (pos(x, j)) ans += 1 << (j - 1);
		ans++;//加上后面全部选 0 的
		return ans;
	}
	return ans;
}

int main() {
	cin >> n >> m >> k;
	int l, r, pos = 1;
	while (tot < k) {
		int cnt = (pos > n) + (pos > m);//判断路径的长度如何变化
		if (cnt == 0) step++;
		if (cnt == 2) step--;
		l = max(1, pos - m + 1);
		r = min(n, pos);//寻找端点
		step = min(step, k - tot);
		tot += step;//最多走 k 步
		if (pos & 1) d[r - step + 1]++, d[r + 1]--;
		else d[l]++, d[l + step - 1 + 1]--;//差分
		pos++;//奇偶性判断走的方向
	}
	ll ans = 0;
	for (int i = 1; i <= n; i++, d[i] += d[i - 1])
		if (d[i]) ans += work(d[i] - 1, i - 1);//注意值域是从 0 开始的
	cout << k - ans;//总数减去不合法数
	return 0;
}
```


---

## 作者：LinkCatTree (赞：4)

题目传送门：[Click](https://www.luogu.com.cn/problem/P6429)。

更好地观感：[Click](https://www.cnblogs.com/TimelessWelkinBlog/p/17642051.html)（进入速度玄学）

某蒟蒻看见这道题，想了足足一个晚上，过后茅塞顿开，故作此篇。

感谢[神犇的题解](https://www.luogu.com.cn/blog/Bbaka/Solution--p6429)，思路基本相同，补充了一些自己的想法或这片题解可能没有注意到的细节。

看题目数据范围：$1 \leqslant r,c \leqslant 10^6,1 \leqslant k \leqslant 10^{12}$，显然打暴力 $\mathcal{O}(rc)$ 的时间复杂度是行不通的。必须做到近似于 $\mathcal{O}(r)$ 的时间复杂度。

观察题目：题目中说：当 $x+y=x \oplus y$ 时，这个格子是灰色的。而最后所求的答案就是走过的灰色的格子数，很容易想到斜着划分所有的格子，每一组的格子中的任意一个格子 $(x,y)$ 都满足 $x+y=S$，其中 $S$ 是不变的。如下图：（图可能有点丑，仅做示意）

![](https://cdn.luogu.com.cn/upload/image_hosting/2dbf6lp7.png)

接下来，我们针对某个特定的 $S$ 进行考虑。设有一组 $(x,y)$，那么 $x \oplus y=S$ 必然满足：$S$ 二进制上的第 $x$ 位为 $1$，则 $x$ 与 $y$ 的二进制第 $x$ 位上必然不同；而当 $S$ 二进制上的第 $x$ 位为 $0$，那么 $x$ 与 $y$ 二进制第 $x$ 位上必然相同。

再来考虑加法。首先看 $S$ 二进制位的最后一个 $1$，发现它有两种情况，通过后两位进位，或是由 $x,y$ 中一个 $0$ 一个 $1$ 相加而成。

当它是通过后两位进位而成时，则 $x,y$ 该位上相同则无法满足异或；不同，则无法满足相加（因为有进位）。（见下图 1）

而它是由更前面的某一位 $0$ 对应的 $x,y$ 中的 $1$，也无法满足要求。（见下图 2）

![](https://cdn.luogu.com.cn/upload/image_hosting/578w1nvf.png)

对于一个 $S$，我们可以把它分为若干如上形式的二进制段，也可得出相通的结论。综上，在 $S$ 的每一位 $0$ 上，$x$ 与 $y$ 同为 $0$ ；否则，$x,y$ 有且仅有一个 $1$。

从这一点入手，统计某一斜行（由于斜行上各自数量可能不确定，我们这里用两个数确定一斜行 $(x,y)$ 表示从 $(0,y)$ 走到 $(x,y-x)$）上有多少个灰色格子（即 $S=y$），我们可以知道有一个 $x^\prime \leqslant x$，其中 $x^\prime$ 二进制上的每一位 $1$，都对应了 $x$ 与 $y$ 上公共的 $1$。在这个 $x^\prime$ 中，（对于一对二元组 $(p,q)$，这一步相当于枚举 $x$ 的二进制位）我们可以知道 $p$ 可以在这一位上取 $1$（$q$ 取 $0$），或者取 $0$（$q$ 相反）。而对于 $y$ 某二进制位上为 $1$，而 $x$ 该二进制位上不为 $1$，那么只可能 $q$ 上取 $1$，而 $p$ 上为 $0$。

简单地说，就是将 $y$ 分解成若干段形如 $\texttt{1000...}$ 的二进制段，然后判断这些“段”与 $x$ 是否对应。如果其最高位 $1$ 与 $x$ 对应，那么说明这一位可以 $1$，答案加上后面的几段（**注意！这里并不要求与 $x$ 对应！**）分别取 $0$ 或 $1$ 的总方案数。当然，这样算会少算一种情况，即所有对应二进制段上都取了 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9a0ehxhp.png)

理解了这个规律，我们可以写出这样一个用来统计某一斜行上灰色格子数量的函数：

```cpp
ll type[64];
ll counting(ll x,ll y) {
	ll res=1LL,cnt=0;
	for(;y;res<<=1,y>>=1)
		if(y&1) type[++cnt]=res;
	res=0;
	for(ll i=cnt;i>0;--i)
		if(x-type[i]>=0) x-=type[i],res|=(1<<i-1);
	return res+1;
}
```

解释说明：$\operatorname{type}_i$ 表示 $y$ 从高到低第 $i$ 个 $1$ 的权值。由于下标就相当于第几段，然后直接一边分解 $x$ 一边计算答案就行了。`1<<i-1` 表示第 $i$ 段后面有 $i-1$ 段，每段取或不取的总方案数为 $2^{i-1}$，由于每个二进制位都不会重复，可以直接用 `|=` 运算。

最后回到问题，统计走 $k$ 步走过的灰色格子数，可以先统计从如下图红色部分的斜行的灰色格子数，然后统计如下图绿色部分的灰色格子数，累加走过的格子。当走不完某一斜行时，暴力模拟一下就可以了。这里细节有点多，就不赘述了。

![](https://cdn.luogu.com.cn/upload/image_hosting/z7bzbx0u.png)

（其中灰色部分可以帮助统计绿色部分）

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll type[64];
ll counting(ll x,ll y) {
	ll res=1LL,cnt=0;
	for(;y;res<<=1,y>>=1)
		if(y&1) type[++cnt]=res;
	res=0;
	for(ll i=cnt;i>0;--i)
		if(x-type[i]>=0) x-=type[i],res|=(1<<i-1);
	return res+1;
}
ll n,m,k;

int main() {
	scanf("%lld%lld%lld",&n,&m,&k);
	int drct=1;
	if(m<n) swap(m,n),drct=0;
	ll ans=0,done=0;
	for(ll i=0;i<m;++i,drct^=1) {
		ll cnt=min(i+1,n);
		if(done+cnt<k) done+=cnt,ans+=counting(min(i,n-1),i);
		else {
			if(drct) for(ll p=min(i,n-1),q=i-min(i,n-1);done<k;--p,++q,++done)
				ans+=p+q==(p^q);
			else for(ll p=0,q=i;done<k;++p,--q,++done)
				ans+=p+q==(p^q);
			break;
		}
	}
	if(done==k) {
		printf("%lld\n",ans);
		return 0;
	}
	for(int i=1;i<n;++i,drct^=1) {
		ll cnt=n-i;
		if(done+cnt<k) done+=cnt,ans+=counting(n-1,m+i-1)-counting(i-1,m+i-1);
		else {
			if(drct) for(ll p=n-1,q=m-n+i;done<k;--p,++q,++done)
				ans+=p+q==(p^q);
			else for(ll p=i,q=m-1;done<k;++p,--q,++done)
				ans+=p+q==(p^q);
			break;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

完。

---

## 作者：Bbaka (赞：2)

### 题意

给定一个由 $r \times c$ 个方格组成的矩形，左上角编号为 $(0,0)$，右下角编号为 $(r-1,c-1)$ ，对于一个方格 $(x,y)$ ，如果 $x+y=x \bigoplus y$ 则方格为灰色，否则为白色。

然后一个人按照下图规律从 $(0,0)$ 斜着走向 $(r-1,c-1)$，问他走到第 $k$ 个格子时总共走过了多少灰色格子。

[![](http://42.193.171.148/wp-content/uploads/2022/09/wp_editor_md_7fbc9488fcf544ae2b5d682fdf65bfbc.jpg)](http://42.193.171.148/wp-content/uploads/2022/09/wp_editor_md_7fbc9488fcf544ae2b5d682fdf65bfbc.jpg)

### 思路


先假设 $r \leq c$，对于 $r>c$ 的情况可以将 $r,c$ 交换，然后改变出发的方向即可。

因为人是斜着走的，我们可以直接从斜向考虑，对于一条斜线，上面所有的 $x+y$ 都是相等的，我们记为 $S$，这样就只需要找有多少 $x,y$ 满足 $x \bigoplus y=S$。

因为异或的性质，$S$ 二进制如果某一位为 `1` ，那么 $x$ 和 $y$ 中该位只能有一个 `1`，如果某一位为 `0` ，那么 $x$ 和 $y$ 该位置要么同为 `0` 要么同为 `1`，如果两个位置同为 `1`，而且在 $S$ 中该位置左边一位为 `0` ，因为相加进位的关系，$x$ 和 $y$ 中这一位有且只有一个 `1` 才能保证 $x+y=S$，但是这一位异或就不可能为 `0`，同理，如果左边一位为 $1$ 时也不合法，故 $S$ 二进制下如果某一位为 `0`， $x$ 和 $y$ 中该位也只能为 `0`。

也就是说对于 $S$ 的每一位，如果为 `0`，那么 $x$ 和 $y$ 这一位只能为 `0`，否则 $x$ 和 $y$ 这一位只存在一个 `1`，记 $n$ 为 $S$ 二进制下 `1` 的数目，对于 $x$ 只有这一位选不选 `1` ，故这条斜线上灰色格子的数量最大值为 $2^n$。

而当我们从 $(0,y)$ 走到 $(x,y-x)$ 时，所以说如果要求出途中经过的灰色格子数，我们可以先找到一个 $x'$ 满足 $x' \leq x$ 且 $x'$ 的二进制下每一位 `1` 在 $y$ 中该位置也为 `1` ，然后将 $x'$ 的二进制下和 $y$ 同时为 `0` 的位置去掉，此时得到的数字就是在范围内你每一位选择选或者不选得到的答案数，将这个数加上一，也就是全不选的操作，就是路径上灰色格子的数目了。

```cpp
int Fun(int y, int x) {
    int num = 0, res = 1;
    while (y) {  //找到y中每一位1并记录对应的值
        if (y & 1) {
            Bit[num] = res;
            num++;
        }
        y >>= 1;
        res <<= 1;
    }
    int tmp = 0;  // tmp记录格子数
    for (int i = num - 1; i >= 0; --i) {
        if (x - Bit[i] >= 0) {  //这里可以找到最大的灰色格子位置
            x -= Bit[i];
            tmp = tmp | (1 << (i));  //因为记录了y中每一位1，所以说直接可以求出最终答案数
        }
    }
    ++tmp; //最后加上全不选的答案
    return tmp;
}
```

这样我们就可以求出路径上每一条走满的斜线上灰色格子数，对于最后可能走不满的斜线，可以直接暴力求解，也可以做差求解即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int Bit[128];
int Fun(int y, int x) {
    int num = 0, res = 1;
    while (y) {  //找到y中每一位1并记录对应的值
        if (y & 1) {
            Bit[num] = res;
            num++;
        }
        y >>= 1;
        res <<= 1;
    }
    int tmp = 0;  // tmp记录格子数
    for (int i = num - 1; i >= 0; --i) {
        if (x - Bit[i] >= 0) {  //这里可以找到最大的灰色格子位置
            x -= Bit[i];
            tmp = tmp | (1 << (i));  //因为记录了y中每一位1，所以说直接可以求出最终答案数
        }
    }
    ++tmp;  //最后加上全不选的答案
    return tmp;
}
signed main() {
    int r, c, k;
    int Now = 0;
    int ans = 0;
    bool dirt = true;
    scanf("%lld %lld %lld", &r, &c, &k);
    if (c < r) {
        swap(c, r);
        dirt = false;
    }
    --r;
    --c;
    for (int i = 0; i <= c; ++i) {  //分两部分解决，第一部分是从顶部开始的斜线
        int step = min(r, i) + 1;
        int cnt = Fun(i, min(r, i));
        if (Now + step < k) {
            Now += step;
            ans += cnt;
        } else {
            if (dirt) {
                int x = min(i, r);
                int y = i - x;
                while (Now < k) {
                    if (x + y == (x ^ y))
                        ++ans;
                    x--;
                    y++;
                    ++Now;
                }
            } else {
                int x = 0;
                int y = i;
                while (Now < k) {
                    if (x + y == (x ^ y))
                        ++ans;
                    x++;
                    y--;
                    ++Now;
                }
            }
            break;
        }
        dirt ^= 1;
    }
    if (Now == k) {
        printf("%lld\n", ans);
        return 0;
    }
    for (int i = 1; i <= r; ++i) {  //第二部分是从右侧开始的斜线
        int step = r - i + 1;
        int cnt = Fun(c + i, r) - Fun(c + i, i - 1);
        if (Now + step < k) {
            Now += step;
            ans += cnt;
        } else {
            if (dirt) {
                int x = r;
                int y = c - (r - i);
                while (Now < k) {
                    if (x + y == (x ^ y))
                        ++ans;
                    x--;
                    y++;
                    ++Now;
                }
            } else {
                int x = i;
                int y = c;
                while (Now < k) {
                    if (x + y == (x ^ y))
                        ++ans;
                    x++;
                    y--;
                    ++Now;
                }
            }
            break;
        }
        dirt ^= 1;
    }
    printf("%lld\n", ans);
}
```

---

## 作者：GGapa (赞：1)

##### P6429 [COCI2008-2009#1] JEZ

看到这道题，不妨先打个表，输出满足以下条件 $x \oplus y = x + y$  的有序数对 $(x, y)$，以下是打表程序：

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
typedef long long ll;
using VI = vector<int>;

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n = 100;
	rep(i, 1, n) rep(j, 1, n) if((i ^ j) == (i + j)) 
		cout << bitset<8>(i) << '\n' << bitset<8>(j) << "\n\n";
    return 0;
}
```

打表后，不妨大胆假设：$x \land y = 0 \Leftrightarrow x \oplus y = x + y$。

我们还知道，对于每一条斜线，$x + y$ 的值为定值，此时问题就转化为：

- 已知 $x + y = S$，给定 $y$ 的范围，求有多少个 $x$ 满足上述条件。

------

考虑问题的简化版本：假定 $y \in [0, S]$。

若 $S$ 的其中一位为 $1$，又因为 $x \land y = 0$，考虑 $1$ 可以放在 $x$ 或 $y$ 中，由于每一个决策是独立的，故一个 $1$ 对答案的贡献为 $\times 2$。

记 $c$ 为 $S$ 的二进制中 $1$ 的个数，此简化版本的答案即为 $2^c$。

-------

回到原问题，我们发现 $y$ 的上界并不一定是 $S$，且只可能比 $S$ 小。设 $y$ 的上界为 $v$，则就只需要考虑 $S$ 的二进制表示中，中 $\le v$ 的 $1$ 即可，问题迎刃而解。

---

## 作者：O_N_N (赞：0)

观察到这个人每次斜着走的情况那两个数的和是固定的，又观察到如果它那个等式成立，那个两个数的二进制形式当且仅当在每一位上的和等于一，也就是说一个是一，另一个是零。对于 S 的二进制表示中为零的位，两个数在该位上都必须为零，不存在选择余地。

因此，我们可以将统计问题转化为：

计算 S 的所有子掩码中，有多少个满足“生成的数值不超过某个上界 B”的条件。

我们一步步走，第一步，判断是不是走的斜线的最后一程。如果不是最后一程，就正常使用函数求解；如果是最后一程，那么就要再次判断，是左下到右上还是右上到左下，一次分类用函数求解。

对于数位动态规划，我们固定了二进制位的总长度，从最高位依次向低位扫描；

状态分为两种：

紧状态：表示当前构造的子掩码前缀和 B 的前缀完全相等，后续位必须受到 B 的限制；

非紧状态：表示当前前缀已经小于 B，后续位则可以自由选取（只受 S 的限制）；

对于 S 的每一位：

如果当前位为 0，则这一位上只能选择 0；

如果当前位为 1，则可以在这一位上选择 0 或 1，但选择的结果会影响状态转移（例如从紧状态转换到非紧状态或者保持紧状态），而这种转移又由 B 在当前位的值决定。

```cpp
#include <bits/stdc++.h>
using namespace  std;
typedef long long ll;
typedef unsigned long long ull;
ll countSubmask_dp(ll S, ll B) {
    if(B < 0) return 0;
    if(B >= S) return 1LL << __builtin_popcount(S);
    const int BITLEN = 22;
    ll dp[2] = {0, 0};
    dp[1] = 1;
    for (int pos = BITLEN - 1; pos >= 0; pos--) {
        ll ndp[2] = {0, 0};
        int bitS = (S >> pos) & 1;
        int bitB = (B >> pos) & 1;
        if(bitS == 0) {
            ndp[0] += dp[0];
            if(bitB == 0)
                ndp[1] += dp[1];
            else
                ndp[0] += dp[1];
        } else {
            ndp[0] += dp[0] * 2;
            if(bitB == 0) {
                ndp[1] += dp[1];
            } else {
                ndp[0] += dp[1];
                ndp[1] += dp[1];
            }
        }
        dp[0] = ndp[0];
        dp[1] = ndp[1];
    }
    return dp[0] + dp[1];
}

void p6429(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int r, c;
    cin >> r >> c;
    ll k;
    cin >> k;
    int S_max = r + c - 2;
    ll ans = 0;

    for (int S = 0; S <= S_max; S++) {
        int L_bound = max(0, S - (c - 1));
        int U_bound = min(S, r - 1);
        if(L_bound > U_bound) continue;  
        int diagCount = U_bound - L_bound + 1;
        ll totalGray = countSubmask_dp(S, U_bound) - countSubmask_dp(S, L_bound - 1);

        if(k >= diagCount) {
            ans += totalGray;
            k -= diagCount;
        } else {
            if(S & 1) {
                ll X = L_bound + k - 1;
                ll grayPrefix = countSubmask_dp(S, X) - countSubmask_dp(S, L_bound - 1);
                ans += grayPrefix;
            } else {
                ll X = U_bound - k;  
                ll grayPrefix = countSubmask_dp(S, U_bound) - countSubmask_dp(S, X);
                ans += grayPrefix;
            }
            break;
        }
    }
    cout << ans << "\n";
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    p6429();
    return 0;
}

```

---


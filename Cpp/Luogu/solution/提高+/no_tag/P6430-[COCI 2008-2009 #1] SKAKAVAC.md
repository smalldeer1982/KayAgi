# [COCI 2008/2009 #1] SKAKAVAC

## 题目背景

一只蚱蜢在花田。

## 题目描述

花田是一个 $n\times n$ 的正方形，每一朵花都有它的编号，$f_{i,j}$ 就代表第 $i$ 行，第 $j$ 列的编号。

现在蚱蜢在第 $r$ 行，第 $c$ 列。

蚱蜢决定去看一看新世界，于是它决定在遵守以下规则的情况下尽可能多的跳到花朵上。

如果它要从 $(r_1,c_1)$ 跳到 $(r_2,c_2)$ 需满足以下条件中的一个：

- $|r_1-r_2|=1$ 且$|c_1-c_2|>1$，
- $|c_1-c_2|=1$ 且$|r_1-r_2|>1$，

并且，$f_{r_2,c_2}>f_{r_1,c_1}$。

请你求出蚱蜢最多能经过几朵花。


## 说明/提示

#### 数据规模与约定
- 对于 $50\%$ 的数据，$n\le 100$。
- 对于 $80\%$ 的数据，$n\le 10^3$。
- 对于 $100\%$ 的数据，$1\le n\le 1.5\times 10^3$，$1\le r,c\le n$，$1\le f_{i,j}\le 10^6$。
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) T5 SKAKAVAC。

## 样例 #1

### 输入

```
4
1 1
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7 ```

### 输出

```
4```

## 样例 #2

### 输入

```
5
3 3
20 16 25 17 12
11 13 13 30 17
15 29 10 26 11
27 19 14 24 22
23 21 28 18 13 
```

### 输出

```
21```

# 题解

## 作者：DarkClever (赞：5)

一道很好玩的题。

朴素做法是对于每个点，按照 $f_{i,j}$ 排序，之后用转移式 $\text{dp}_i = \max\{\text{dp}_j\} + 1$，

其中 $j$ 满足 $ (\lvert x_i - x_j\rvert  = 1 \land \lvert y_i - y_j\rvert > 1) \lor (\lvert y_i - y_j\rvert = 1 \land \lvert x_i - x_j\rvert > 1)$。

显然，这样子遍历一整个矩阵的复杂度是 $O(n^4)$ 的，完全不可接受，考虑将其优化。

初步分析 $j$ 的限制，发现它只会在自己旁边竖条和上下的横条出现，即：

![https://cdn.luogu.com.cn/upload/image_hosting/2zlof0kl.png](https://cdn.luogu.com.cn/upload/image_hosting/2zlof0kl.png)

所以说，我们可以只遍历这 $4$ 段，寻找最大值，这样子的复杂度是 $O(n^3)$，还是不行。

这时，我们考虑到对于每一条，$\lvert x_i - x_j\rvert > 1$ 或 $\lvert y_i - y_j\rvert > 1$ 的限制至多会将一个段分为两个小段，所以我们考虑使用线段树等数据结构进行优化，理论可过，然后你就会空间爆掉并且发现这道题有着不同寻常的空间限制 $\leq 35\text{MB}$，而我们对每一条都需要开一颗线段树，总共要开 $2n$ 颗线段树，空间复杂度为 $O(n^2)$ 并且常数巨大，这时我们继续观察他的性质。

此时考虑在每一段中不满足 $\lvert x_i - x_j\rvert > 1$ 或 $\lvert y_i - y_j\rvert > 1$ 这个限制的点的数量，如图：

![https://cdn.luogu.com.cn/upload/image_hosting/rqrdt1s2.png](https://cdn.luogu.com.cn/upload/image_hosting/rqrdt1s2.png)

会发现每一段，不满足这个限制的点最多只有 $3$ 个，所以对于每一段，我们只需要维护前 $4$ 大的值即可，这样做的话时间复杂度为 $O(n^2)$，加上 $O(n^2\log n^2)$ 这个按 $f_{i,j}$ 排序的复杂度，总复杂度为 $O(n^2\log n^2)$，当然，如果使用基数排序，可以优化至 $O(n^2)$。

还有一点，注意到 $f_j > f_i$ 而非 $f_j \geq f_i$，所以在算完一个点的答案后，不能直接插入前 $4$ 大的数，应该等相同值的其他数全部处理完再一起插入。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1510;
struct node{
    short x,y;
    int val;
    int ans;
}a[N*N];
int n,cnt = 0,r1,c1;
bool cmp(node x,node y){
    return x.val < y.val;
}
void ins(node s[],node num){
    for(int i=1;i<=4;i++){
        if(s[i].ans<num.ans || (s[i].x==0 && s[i].y==0)){
            for(int j=4;j>i;j--){
                s[j] = s[j-1];
            }
            s[i] = num;
            return;
        }
    }
    return;
}
int query(int x,int y,node l[]){
    int maxn = 0;
    for(int i=1;i<=4;i++){
        if(((abs(l[i].x - x) == 1 && abs(l[i].y - y) > 1) || (abs(l[i].y - y) == 1 && abs(l[i].x - x) > 1)) && l[i].x!=0 && l[i].y!=0){
            //cerr<<x<<" "<<y<<" "<<l[i].x<<" "<<l[i].y<<'\n';
            maxn = max(maxn,l[i].ans);
        }
    }
    return maxn;
}
node l[N][5];
node r[N][5];
queue<node> q;
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    //cerr.tie(0);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < 5; j++) {
            l[i][j].ans = 0;
            r[i][j].ans = 0;
        }
    }
    cin>>n>>r1>>c1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            int x;
            cin>>x;
            a[++cnt].val = x;
            a[cnt].x = i;
            a[cnt].y = j;
            if(i == r1 && j == c1){
                
                a[cnt].ans = 1;
            }
        }
    }
    sort(a+1,a+cnt+1,cmp);
    int ans = 1;
    int lst = -1;
    for(int i=1;i<=cnt;i++){
        if(a[i].val!=lst){
            for(int j=i-1;j>=0 && a[j].val==lst;j--){
                ins(l[a[j].x],a[j]);
                ins(r[a[j].y],a[j]);
            }
        }
        lst = a[i].val;
        //cerr<<i<<" "<<a[i].x<<" "<<a[i].y<<" "<<a[i].val<<'\n';
        int maxn = a[i].ans;
        maxn = max(query(a[i].x,a[i].y,l[a[i].x-1]),maxn);
        maxn = max(query(a[i].x,a[i].y,l[a[i].x+1]),maxn);
        maxn = max(query(a[i].x,a[i].y,r[a[i].y-1]),maxn);
        maxn = max(query(a[i].x,a[i].y,r[a[i].y+1]),maxn);
        a[i].ans = maxn>0 ? maxn + 1 : 0;
        ans = max(ans,a[i].ans);
        //cerr<<a[i].ans<<'\n';
    }
    cout<<ans-1<<'\n';
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：4)

- [原题链接。](https://www.luogu.com.cn/problem/P6430)

------------

本来不想写题解的，但发现仅有的一篇题解什么都说了，但好像又什么都没说。。。

首先不难想到将所有位置按权值从小到大排序，从前往后 dp。

令 $f(i)$ 表示落点在排序后 $i$ 号位置的最大答案，那么显然可以 $O(n)$ 暴力转移。时间复杂度是 $O(n^3)$。

考虑优化，首先一个暴力的思路是，你发现能转移到当前位置的一定是某行或某列的某个前后缀，于是可以直接硬上树状数组。时间复杂度 $O(n^2 \log n)$。理论能过，实际没试过。

然后你发现上面那个思路显然太暴力了，你考虑能转移的行列必然最多只有三个位置不能转移，换句话说，某行/列的前四大值中一定有合法的能转移过来的位置，于是你记录每行每列的前 $4$ 大值用来转移即可。用桶排可以做到 $O(n^2)$。

有一个细节是维护行列前 $4$ 大值时，你不能求完一个插入一个，而是等一段值相同的数处理完后统一插入。

另外这题卡空间，存下标时记得开 short。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define val first
#define pos second
const int N=1510;
int n,m,sx,sy,ans[N*N];
pair<int,int> r[N][4],c[N][4];
struct node
{
	short x,y;int val;
}d[N*N];
inline void update(int x,int y,int v)
{
	for(int i=0;i<4;i++)
		if(r[x][i].val<v)
		{
			for(int j=3;j>i;j--) r[x][j]=r[x][j-1];
			r[x][i]={v,y};break;
		}
	for(int i=0;i<4;i++)
		if(c[y][i].val<v)
		{
			for(int j=3;j>i;j--) c[y][j]=c[y][j-1];
			c[y][i]={v,x};break;
		}
}
int main()
{
	memset(r,0xcf,sizeof r);
	memset(c,0xcf,sizeof c);
	memset(ans,0xcf,sizeof ans);
	scanf("%d%d%d",&n,&sx,&sy);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			++m; 
			d[m].x=i;d[m].y=j;
			scanf("%d",&d[m].val);			
		}
	sort(d+1,d+m+1,[](node A,node B){return A.val<B.val;}); 
	for(int i=1,la=1;i<=m;i++)
	{
		if(d[i].val!=d[i-1].val) 
		{
			for(int j=la;j<=i-1;j++) update(d[j].x,d[j].y,ans[j]);
			la=i;
		}
		if(d[i].x==sx&&d[i].y==sy) ans[i]=1;
		else
		{
			int mx=-1e9;
			for(int j=0;j<4;j++)
			{
				if(abs(r[d[i].x-1][j].pos-d[i].y)>1) mx=max(mx,r[d[i].x-1][j].val);
				if(abs(r[d[i].x+1][j].pos-d[i].y)>1) mx=max(mx,r[d[i].x+1][j].val);
				if(abs(c[d[i].y-1][j].pos-d[i].x)>1) mx=max(mx,c[d[i].y-1][j].val);
				if(abs(c[d[i].y+1][j].pos-d[i].x)>1) mx=max(mx,c[d[i].y+1][j].val);
			}
			ans[i]=mx+1;
		}		
	}
	int res=1;
	for(int i=1;i<=m;i++) res=max(res,ans[i]);
	printf("%d",res);
	return 0;
}
```


---

## 作者：Arthur_Douglas (赞：1)

## 前言
这道题目卡空间，请大家掌握 35mb 内的算法。

## 思路
一道较难的 dp------------

但我们发现，其就是想让我们求满足要求的**最长上升序列**。


## 50 code
思路为，暴力枚举所有合法的地方，如果大于就进行转移。

时间复杂度 $O(n^3)$。但无论时间空间都过不了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cnt;
struct node
{
	int x , y , v;
}a[2250001];
int dp[1502][1502];
int c[1502][1502];
bool cmd(node x , node y)
{
	return x.v > y.v;
}
signed main()
{
	int n;
	cin >> n;
	int l , r;
	cin >> l >> r;
	for(int i = 1;i <= n;++ i)
	for(int j = 1;j <= n;++ j)
	cin >> a[(i - 1) * n + j].v , a[(i - 1) * n + j].x = i , a[(i - 1) * n + j].y = j , c[i][j] = a[(i - 1) * n + j].v;
	sort(a + 1 , a + 1 + n * n , cmd);
	int xf , yf , vf;
	for(int i = 1;i <= n * n;++ i)
	{
//		cout << a[i].v << endl;
		xf = a[i].x;
		yf = a[i].y;
		vf = a[i].v;
		for(int j = 1;j <= n;++ j)
		{
			if(abs(j - yf) > 1)
			{
				if(c[xf - 1][j] > vf)
				dp[xf][yf] = max(dp[xf][yf] , dp[xf - 1][j] + 1);
				if(c[xf + 1][j] > vf)
				dp[xf][yf] = max(dp[xf][yf] , dp[xf + 1][j] + 1);
			}
			if(abs(j - xf) > 1)
			{
				if(c[j][yf - 1] > vf)
				dp[xf][yf] = max(dp[xf][yf] , dp[j][yf - 1] + 1);
				if(c[j][yf + 1] > vf)
				dp[xf][yf] = max(dp[xf][yf] , dp[j][yf + 1] + 1);
			}
		}
	}
	cout << dp[l][r] + 1 << endl;
	return 0;
}
```
## 60 code

我们可以知道是寻找最大值，那么就可以使用区间最大值的老朋友------**树状数组**来解决。

时间复杂度 $O(n^2\log n)$。有较大常数。

但空间较大。稍加优化仅得 $80$ 分。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define lowbit(x) x&-x
int cnt;
struct node
{
	int x , y , v;
}a[2250002];
int dp[1502][1502];
int n;
bool cmd(node x , node y)
{
	return x.v > y.v;
}
int max_eight(int a , int b , int c , int d , int e , int f , int g , int h)
{
	return max(max(max(a , b) , max(c , d)) , max(max(e , f) , max(g , h)));
}
struct like_tree
{
	int c[1502];
	int d;
	bool h;
	int find(int l , int r)
	{
		int bt = 0;
    	int Find = r;
		while(l <= Find - lowbit(Find))
		{
			bt = max(c[Find] , bt);
			Find -= lowbit(Find);
		}
		while(l <= Find)
		{	
			if(h)
			bt = max(bt , dp[d][Find]);
			else
			bt = max(bt, dp[Find][d]);
			-- Find;
		}
		return bt;
	}
	void Edge(int x , int v)
	{
    	int TLE = x;
		while(TLE <= n)
		{
			c[TLE] = max(v , c[TLE]);
			TLE += lowbit(TLE);
		}
	}
}l[1502] , r[1502];
node ks[2250002];
int i , j;
signed main()
{
	cin >> n;
	int le , ri;
	cin >> le >> ri;
	for(i = 1;i <= n;++ i)
	for(j = 1;j <= n;++ j)
	cin >> a[(i - 1) * n + j].v , a[(i - 1) * n + j].x = i , a[(i - 1) * n + j].y = j;
	sort(a + 1 , a + 1 + n * n , cmd);
	int xf , yf , vf;
	for(i = 1;i <= n;++ i)
	l[i].d = r[i].d = i, l[i].h = 1;
	int lv = 0;
	int kbio = 0;
	int _count = 0;
	for(i = 1;i <= n * n;++ i)
	{
		xf = a[i].x;
		yf = a[i].y;
		vf = a[i].v;
		if(lv > vf)
		{
			for(j = 1;j <= _count;++ j)
			{
				dp[ks[j].x][ks[j].y] = ks[j].v;
				l[ks[j].x].Edge(ks[j].y , ks[j].v);
				r[ks[j].y].Edge(ks[j].x , ks[j].v);
			}
			_count = 0;
		}
		kbio = max(1 ,
		max_eight(
		l[xf + 1].find(1 , yf - 2) ,
		l[xf + 1].find(yf + 2 , n) ,
		l[xf - 1].find(1 , yf - 2) ,
		l[xf - 1].find(yf + 2 , n) ,
		r[yf - 1].find(1 , xf - 2) ,
		r[yf - 1].find(xf + 2 , n) ,
		r[yf + 1].find(1 , xf - 2) ,
		r[yf + 1].find(xf + 2 , n)) + 1);
		if(xf == le && yf == ri)
		{
			cout << kbio << endl;
			return 0;
		}
		ks[++ _count] = (node){xf , yf , kbio};
		lv = vf;
	}
	return 0;
}
```
## 100 code
我们再稍加发现，所有的值的转移只会转移合法的已转移的中最大的。因为每行每列最多会有 $3$ 个不合法，所以就要记录前四大的。由于空间问题，要将坐标位置合并成一个数。

时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2250001];
int C[1501][1501];
int f[1501][1501];
int X(int s)
{
	return s / n + bool(s % n);
}
int Y(int s)
{
	return s - (X(s) - 1) * n;
}
int H[1501][5];//0存个数
int L[1501][5];
int find(int sx , int sy , int dx , int dy)
{
//	cout << sx << ' ' << sy << ' ' << dx << ' ' << dy << ' ' << H[sx][0] << endl;
	if(!sx || sx > n)
	return 0;
	for(int i = 1;i <= H[sx][0];++ i)
	{
//		cout << Y(H[sx][i]) << ' ' << H[sx][i] << endl;
	if(abs(Y(H[sx][i]) - dy) > 1 && C[dx][dy] < C[sx][Y(H[sx][i])])
	return f[sx][Y(H[sx][i])];
	}
	
	return 0;
}
int find1(int sx , int sy , int dx , int dy)
{
	if(!sy || sy > n)
	return 0;
	for(int i = 1;i <= L[sy][0];++ i)
	if(abs(X(L[sy][i]) - dx) > 1 && C[dx][dy] < C[X(L[sy][i])][sy])
	return f[X(L[sy][i])][sy];
	return 0;
}
int find_max(int dx , int dy)
{	
	int t1 = find1(dx , dy - 1 , dx , dy);
	int t2 = find1(dx , dy + 1 , dx , dy);
	int t3 = find(dx - 1 , dy , dx , dy);
	int t4 = find(dx + 1 , dy , dx , dy);
//	cout << t3 << endl;
	return max(max(t1 , t2) , max(t3 , t4));
}
void insert_xy(int V , int sx , int sy)
{
	int now , last;
	last = V;
	int place;
	int last_place = (sx - 1) * n + sy; 
	for(int i = 1;i <= H[sx][0];++ i)
	{
		if(V > f[X(H[sx][i])][Y(H[sx][i])])
		{
		 	V = f[X(H[sx][i])][Y(H[sx][i])];
		 	place = H[sx][i];
			H[sx][i] = last_place;
			last_place = place;
		}
	}
	if(V && H[sx][0] < 4)
	{
		H[sx][++ H[sx][0]] = last_place;
	}
	V = last;
	last_place = (sx - 1) * n + sy;
	for(int i = 1;i <= L[sy][0];++ i)
	{
		if(V > f[X(L[sy][i])][Y(L[sy][i])])
		{
			V = f[X(L[sy][i])][Y(L[sy][i])];
			place = L[sy][i];
			L[sy][i] = last_place;
			last_place = place;
		}
	}
	if(V && L[sy][0] < 4)
	{
		L[sy][++ L[sy][0]] = last_place;
	}
	return ;
}
bool cmd(int x , int y)
{
	return C[X(x)][Y(x)] > C[X(y)][Y(y)];
}
int main()
{
	cin >> n;
	int le , ri;
	cin >> le >> ri;
	for(int i = 1;i <= n;++ i)
	{
		for(int j = 1;j <= n;++ j)
		{
			cin >> C[i][j];
			a[(i - 1) * n + j] = (i - 1) * n + j;
		}
	}
//	for(int i = 1;i <= n*n ;++ i)
//	{
//		cout << X(a[i]) << ' ' << Y(a[i]) << ' ' << C[X(a[i])][Y(a[i])] << endl;
//		cout << endl;
//	}
	int xf , yf;
	sort(a + 1 , a + 1 + n * n  , cmd);
//	cout << endl;
//	for(int i = 1;i <= n*n ;++ i)
//	{
//		cout << X(a[i]) << ' ' << Y(a[i]) << ' ' << C[X(a[i])][Y(a[i])] << endl;
//		cout << endl;
//	}
	for(int i = 1;i <= n * n;++ i)
	{
		xf = X(a[i]);
		yf = Y(a[i]);
		f[xf][yf] = find_max(xf , yf) + 1;
		if(xf == le && yf == ri)
		{
//			for(int j = 1;j <= n;++ j){
//			for(int l = 1;l <= n;++ l)
//		cout << f[j][l] << ' ';cout << endl;}
			cout << f[xf][yf] << endl;
			return 0; 
		}
		insert_xy(f[xf][yf] , xf , yf);
	}
	return 0;
}
```
~~(哈哈哈)~~

---

## 作者：GGapa (赞：1)

将所有点按照从小到大排序。

依然定义 $F(i)$  为到达第 $i$ 点时，所走过最多的植物数量。

回顾 [BARICA](https://www.luogu.com.cn/problem/P7936) 这道题通过记录了一个最大值来转移状态，回到这道题，这道题多了个很棘手的限制条件，也就是 $|c1 - c2| > 1$，这就表明我们记录的最大值有可能是不符合条件的。

既然记录一个最大值不符合条件，那么就记录 $4$ 个最大值，由于 $|c1 - c2| > 1$。考虑极端情况，若此时有三个最大值不符合条件，易证第四个最大值一定符合条件。

此时还有一个约束条件 $f(r2, c2) > f(r1, c1)$，如果当我们处理的这个点的 $f$ 等于上一个处理的点，此时不能够更新，只有当 $f$ 比上一个 $f$ 大时才能更新。

这道题略微卡了一下空间，可以把部分 `int` 换成 `short`。

```cpp
// P6430
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
typedef long long ll;
using VI = vector<int>;
const int INF = 1e8;

struct Node {
    short x, y; int val;
};

int ff[] = {-1, 1};

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n, m = 0; cin >> n;
    int sx, sy; cin >> sx >> sy;
    vector<Node> A(1);
    vector<set<array<int, 2>>> X(n + 2), Y(n + 2);
    for(int i = 1, x; i <= n; i++) rep(j, 1, n) {
        cin >> x;
        A.emplace_back((Node){i, j, x});
    }
    m = n * n;
    vector<int> ans(m + 1, -1e9);
    sort(A.begin() + 1, A.begin()  + 1 + m, [](const Node &x, const Node &y) {
        return x.val < y.val;
    });
    auto up = [&](set<array<int, 2>> &s, int x, int v) {
        s.insert({v, x});
        if(s.size() > 4) s.erase(s.begin());  
    };
    for(int i = 1, lt = 1; i <= m; i++) {
        auto &a = A[i];
        if(a.val != A[i - 1].val) {
            rep(j, lt, i - 1) up(X[A[j].x], A[j].y, ans[j]), up(Y[A[j].y], A[j].x, ans[j]);
            lt = i;
        }
        if(a.x == sx && a.y == sy) ans[i] = 1;
        else {
            int mx = -1e9;
            rep(k, 0, 1){
                int nx = a.x + ff[k], ny = a.y + ff[k];
                for(auto j : X[nx]) {
                    if(abs(j[1] - a.y) > 1) mx = max(mx, j[0]);
                }
                for(auto j : Y[ny])
                    if(abs(j[1] - a.x) > 1) mx = max(mx, j[0]);
            }
            ans[i] = mx + 1;
        }
    }
    cout << *max_element(ans.begin() + 1, ans.end());
    return 0;
}
```

---

## 作者：SDLTF_凌亭风 (赞：0)

一眼动态规划。几乎就是过河卒的翻版

首先肯定希望走过的格子花瓣数（原题为花瓣数，在翻译后的题面中为 $f_{i,j}$）尽可能大，那么贪心地，我们先按照花瓣数对花进行排序。

对每朵花 $t$，定义 $g(t)$ 为蚱蜢从 $t$ 这朵花开始，能走到的最多的花。

这个问题就很像过河卒，$g(t)$ 可以由相邻行或列的花转移。假设相邻行或列的花为 $k$，显然我们有：

$$
g(t)=\max\{{g(k)\}} + 1
$$

再看到题目的限制，事实上在转移的时候只需要考虑最多两列两行即可，可以加快转移速度。

具体代码实现建议参考[官方代码](https://hsin.hr/coci/archive/2008_2009/)。

---


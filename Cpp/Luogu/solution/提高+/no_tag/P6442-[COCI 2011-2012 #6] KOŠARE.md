# [COCI 2011/2012 #6] KOŠARE

## 题目描述

在一个废弃的阁楼里放置有 $n$ 个箱子，这些箱子里存放着 $m$ 种玩具。对于第 $i$ 个箱子，它里面有 $k_i$ 个玩具（不同的箱子里可能有相同的玩具）。

现在你需要选出一部分箱子，使得它们中共有 $m$ 种玩具（即所有种类的玩具都包含）。求选择的方案总数（$\bmod\ 10^9+7$）。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 100$，$m\le 15$；
- 对于 $70\%$ 的数据，保证 $m\le 15$；
- 对于 $100\%$ 的数据，保证 $1\le n\le 1\times 10^6$，$1\le m\le 20$，$0\le k_i\le m$。

#### 说明

- **题目译自 [COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #6](https://hsin.hr/coci/archive/2011_2012/contest6_tasks.pdf) *T6 KOŠARE***。
- 感谢 @[一扶苏一](https://www.luogu.com.cn/user/65363) 的翻译支持！

## 样例 #1

### 输入

```
3 3
3 1 2 3
3 1 2 3
3 1 2 3```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3
1 1
1 2
1 3```

### 输出

```
1```

## 样例 #3

### 输入

```
4 5
2 2 3
2 1 2
4 1 2 3 5
4 1 2 4 5```

### 输出

```
6```

# 题解

## 作者：UltiMadow (赞：15)

**update: 修正了几个明显的问题（**

容斥 + sos dp

[如果你不会 sos dp](https://codeforces.ml/blog/entry/45223)

首先发现 $m$ 很小，于是直接对于每一个箱子状压

于是问题转化为选若干个数使它们按位或为全集

继续转化一下，把每个箱子取个反，问题就变成了选若干个书使它们按位与为空集

接下来考虑 dp

$f_i$ 表示状态 $i$ 是多少个箱子状态的子集，$g_i$ 表示状态 $i$ 是多少种 箱子状态交集的子集，显然有 $g_i=2^{f_i}-1$，于是我们只需要计算 $f$

有方程：$f_i=\sum_{i\in j}a_j$，于是直接上 sos dp 即可

方程中 $a_j$ 表示状态 $j$ 和多少个箱子状态相等

注意这里与标准 sos dp 方程 $f_i=\sum_{j\in i}a_j$ 有区别，在实现的时候反一下就行了

计算出来 $f$ 和 $g$ 之后计算答案

答案要求按位与为空集，考虑容斥，全集即为 $g_0$

对于一个状态 $i$，若它有奇数个 1，则需要从答案里减去 $g_i$，否则就加上 $g_i$

于是这道题就被做完了，时间复杂度 $\mathcal O(2^mm)$

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 1<<23
#define p 1000000007
using namespace std;
int n,m,ans;
int f[MAXN],pw[MAXN];
int main(){
	pw[0]=1;
	for(int i=1;i<(1<<22);i++)pw[i]=(pw[i-1]+pw[i-1])%p;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		int k;scanf("%d",&k);
		int st=(1<<m)-1;
		while(k--){
			int x;scanf("%d",&x);
			st^=(1<<(x-1));
		}f[st]++;
	}
	for(int i=1;i<=m;i++)
		for(int mask=0;mask<(1<<m);mask++)
			if(mask&(1<<(i-1)))
				f[mask^(1<<(i-1))]=(f[mask^(1<<(i-1))]+f[mask])%p;
	for(int mask=0;mask<(1<<m);mask++){
		int sgn=1;
		for(int i=1;i<=m;i++)
			sgn=(mask&(1<<(i-1)))?-sgn:sgn;
		ans=(ans+(pw[f[mask]]-1)*sgn)%p;
	}printf("%d",(ans+p)%p);
	return 0;
}
```

---

## 作者：xiaolilsq (赞：11)

[题目链接](https://www.luogu.com.cn/problem/P6442)

## 题意简述

有 $m$ 种不同的元素，给定 $n$ 个包含这些元素的集合，问选出一些集合使得这些集合并起来得到全集的方案数。

## 题目分析

一眼看过去，应该是比较显然的容斥原理，如果对容斥原理还不会或者不熟悉的可以看看我写的[这篇博客](https://www.luogu.com.cn/blog/230249/Principleofinclusion-exclusion)。

根据容斥原理的套路，我们设 $T$ 表示一种选集合的方案， $A_i=\{T\mid \text{选出的集合的并集包含元素}i\}$ ，我们要求的就是 $\left|\bigcap\limits_{i=1}^m A_i\right|$ ，容斥原理式子摆上：

$$
\left|\bigcap_{i=1}^mA_i\right|=\sum_{S\sube[m]}(-1)^{|S|}\left|\bigcap_{i\in S}\overline{A_i}\right|
$$

$\overline{A_i}=\{T\mid \text{选出的集合的并集不包含元素}i\}$ ，由于 $m\le 20$ ，我们便可以想到一种做法：直接枚举所有元素集合，然后规定集合内的元素都不能存在，最后在根据容斥系数乘起来然后相加。

接下来问题就转化成了求选出的所有集合并起来不包含某些元素的方案数，也就是要求不包含某些元素的集合数量，这个补集转化之后可以用前缀和求。

前缀和如果是用容斥求的话是 $\mathcal O(3^m)$ 的，可以用“降维法”来求前缀和，即枚举每一个维度，然后对这一个维度做前缀和，时间复杂度是 $\mathcal O(2^{m-1}m)$ 的。

总的时间复杂度应该是 $\mathcal O(nm+2^{m-1}m+2^m)$ 。

## 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define ch() getchar()
#define pc(x) putchar(x)
template<typename T>inline void read(T&x){
	int f;char c;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c<='9'&&c>='0';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>inline void write(T x){
	static char q[64];int cnt=0;
	if(!x)pc('0');if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
const int mod=1000000007,maxn=1000006,maxm=20;
int mo(const int x){
	return x>=mod?x-mod:x;
}
int _2[maxn],cnt[1<<maxm],pr[1<<maxm];
int main(){
	int n,m;
	read(n),read(m);
	_2[0]=1;
	for(int i=1;i<=n;++i)
		_2[i]=mo(_2[i-1]<<1);
	int U=(1<<m)-1;
	for(int i=1;i<=n;++i){
		int k,v=0;read(k);
		while(k--){
			int o;read(o);
			v|=1<<(o-1);
		}
		++cnt[v];
	}
	int tU=(1<<(m-1))-1;
	for(int i=0;i<m;++i){
		int sU=(1<<i)-1;
		for(int s=0;s<=tU;++s){
			int s0=(s&sU)|((s&(~sU))<<1),s1=s0|(1<<i);
			cnt[s1]+=cnt[s0];
		}
	}
	pr[0]=1;
	for(int s=1;s<=U;++s)
		pr[s]=mo(mod-pr[s^(s&(-s))]);
	int ans=0;
	for(int s=0;s<=U;++s)
		ans=mo(ans+1ll*pr[s]*_2[cnt[s^U]]%mod);
	write(ans),pc('\n');
	return 0;
}
```

---

## 作者：伟大的王夫子 (赞：5)

一道非常不错的计数题目。

首先，因为 $m$ 非常的小，很容易想到状压。那么，问题就变成了给你 $n$ 个数，求总共有多少个子集使得这里面的所有数按位与之后与全集相等。

我们令 $dp_s$ 表示有多少个子集使得这里面的所有数按位与之后与 $s$ 相等。我们考虑用容斥原理计算 $dp_s$。

显然我们有一种比较朴素的写法，就是枚举 $s$ 所有的子集进行计算。不妨设 $cnt_s$ 为 $s$ 中 1 的个数。那么 $dp_s = \sum\limits_{mask \in s} {-1}^{cnt_s - cnt_{mask}} \times dp_{mask}$。

其中，$dp_s$ 的初值应该为 $a$ 中 $s$ 子集的个数。由于我们要从没有算过的状态转移到算过的状态，所以我们必须倒序枚举 $s$。但如果我们采用 sosdp 的写法，那么我们不用判断奇偶性，只用减就可以了（因为 1 是奇数）。

至于 sosdp，我这里给大家简单讲一下。先讲一下高维前缀和。一维的大家都应该会。至于二维的，其实也有一种容斥的写法。

```cpp
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) s[i][j] += s[i - 1][j];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) s[i][j] += s[i][j - 1];
```

（省略了加上 $a_{i, j}$ 的操作）

令 $g_s$ 为 $a$ 中 $s$ 子集的个数。那么 $g_s$ 的统计不就和 $m$ 维前缀和很像吗？分析到这里，想必代码已经不难了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n, m;
typedef long long LL;
LL ans, p[N], dp[1 << 20];
int g[1 << 20];
const LL P = 1e9 + 7;
int main() {
	scanf("%d%d", &n, &m);
	p[0] = 1;
	for (int i = 1; i <= n; ++i) p[i] = p[i - 1] * 2 % P;
	for (int i = 1; i <= n; ++i) {
		int K, x = 0;
		scanf("%d", &K);
		for (int j = 1, y; j <= K; ++j) {
			scanf("%d", &y);
			x |= 1 << (y - 1);
		}
		++g[x];
	}
	//dp[s] 表示 或起来 = s 的个数 
	//g[s] 表示 s 的子集个数 
	for (int i = 0; i < m; ++i)
		for (int s = 0; s < (1 << m); ++s) 
			if (s & 1 << i) g[s] += g[s ^ 1 << i];
	for (int s = 0; s < (1 << m); ++s) dp[s] = p[g[s]]; 
	for (int i = 0; i < m; ++i)
		for (int s = 0; s < (1 << m); ++s)
			if (s & 1 << i) dp[s] = (dp[s] - dp[s ^ 1 << i] + P) % P;
	printf("%lld", dp[(1 << m) - 1]);  
}
```

如果需要暴力 70pts 代码，请私信作者。题解难免有误，欢迎在评论区指出。

---

## 作者：MurataHimeko (赞：3)

第一个想法是设 $f_{i,s}$ 表示到了第 $i$ 个箱子，至少放了一次的玩具构成的集合为 $s$ 的方案数。转移只需要枚举选还是不选当前箱子即可。

但是会超时，所以我们考虑容斥。

设 $g_s$ 表示包含的玩具集合是 $s$ 的子集的箱子个数。

只需要用一个高维前缀和即可求出 $g_s$。

设 $h_S$ 表示钦定集合 $S$ 中的玩具不被选，剩下的玩具随便选的方案。

那么有 $h_S = 2^{g_{U\setminus S}} - 1$。

答案即为 $\sum_{s} (-1)^{|s|} h_s$。

部分代码：

 ```cpp

io >> n >> m;
re(i, n) {
    io >> K;
    int res = 0;
    re(j, K) {
        io >> x;
        res |= (1 << (x-1));
    }
    ++f[res];
}
rep(j, 0, m-1) {
    rep(i, 0, (1 << m) - 1) {
        if((i >> j) & 1) {
            f[i] = (f[i] + f[i ^ (1 << j)]);
            f[i] = (f[i] >= mod) ? f[i] - mod: f[i];
        }
    }
}
ll ans = 0;
pw[0] = 1;
re(i, n) pw[i] = 2 * pw[i-1] % mod;
rep(i, 0, (1 << m) - 1) {
    int ss = (1 << m) - 1 - i;
    int op = (__builtin_popcount(i) & 1) ? mod - 1 : 1;
    ans = (ans + 1ll * op * (pw[f[ss]]-1) % mod);
    ans = (ans >= mod) ? ans - mod : ans;
}
io << ans;
```



---

## 作者：ZillionX (赞：3)

# Description

给定 $n$ 个集合，全集共有 $m$ 个元素，求选定一部分集合（可以全选）使得它们的并集为全集的方案数。答案对 $10^9+7$ 取模。

$n \le 10^6, m\le 20$，时限 2s。

# Solution

[本题的另一种推导方法](https://www.luogu.com.cn/blog/ZillionX/solution-sp13106)。

同样约定每个集合内的元素为 $a_{i}$（将其看作一个二进制数）。

注意到题目的要求是“恰好”，这个定义不好处理，我们可以套路地将限制改松，然后再反演回去。

那么不妨设 $P(x)$ 表示集合 $x$ 在众集合中的子集个数。

构造 $Q$ 使得 $Q(a_i)$ 为 $a_i$ 在众集合中的出现次数，不难发现 $P(i)=\sum\limits_{i|j=i}Q(j)$，因此对 $Q$ 跑一次 Or 的 DWT 即可求出 $P$。

令 $F(x)$ 表示选定的一部分集合的并集为 $x$ 的子集的方案数。可以推导出 $F(x)=2^{P(x)}$。

又设 $G(x)$ 为题目所求。根据子集反演相关知识可知

$$F(S)=\sum_{T \subseteq S} G(T) \Longleftrightarrow G(S)=\sum_{T \subseteq S} (-1)^{|S|-|T|}F(T)$$

事实上，可以观察出，这仍然是 Or 的 IDWT 的形式，证明留作读者练习。

至此我们就在 $\mathcal O(m2^m)$ 的时间复杂度下完成了本题。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int S=(1<<20)+5;
const LL mod=1e9+7;
int n,m;
LL f[S];
LL Qpow(LL x,LL y) {
	LL Mul=1;
	while (y) {
		if (y&1) Mul=Mul*x%mod;
		x=x*x%mod,y>>=1;
	}
	return Mul;
}
int main() {
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		int k,sta=0;
		scanf("%d",&k);
		for (int j=1;j<=k;j++) {
			int x;scanf("%d",&x);
			sta|=(1<<(x-1));
		}
		f[sta]++;
	}
	for (int i=2,j=1;i<=(1<<m);i<<=1,j<<=1)
		for (int k=0;k<(1<<m);k+=i)
			for (int l=0;l<j;l++)
				f[j+k+l]=(f[j+k+l]+f[k+l])%mod;
	for (int i=0;i<(1<<m);i++)
		f[i]=Qpow(2,f[i]);
	for (int i=2,j=1;i<=(1<<m);i<<=1,j<<=1)
		for (int k=0;k<(1<<m);k+=i)
			for (int l=0;l<j;l++)
				f[j+k+l]=(f[j+k+l]-f[k+l]+mod)%mod;
	printf("%lld",f[(1<<m)-1]);
	return 0;
}
```


---

## 作者：ybe2007 (赞：2)

一开始看到 $m$ 的数据范围，很明显一眼状压。但是 $n$ 的范围较大，因此暴力的一个一个箱子进行状压转移只能拿到 $50pts$。对这种需要顺序枚举 $n$ 的做法，显然优化的余地已经很小了，因此我们考虑换一种思考方式。

首先对原题进行转化，即为 选取若干个二进制数，使他们或起来为全集 $s$。

进一步对问题进行抽象，设 $f_i$ 表示 选取若干个数或起来为状态 $i$ 的方案数，用 dp 的方法进行转移，最后要求解的答案就是 $f_s$。如何计算 $f_i$ 呢？这里就需要用到容斥进行巧妙地转移，我们设 $g_i$ 表示选取若干个数或起来为状态 $i$ **的子集**的方案数，那么很显然，假如 $i$ 有 $cnt_i$ 个子集（这里将 $0$（空集） 也视为子集），那么 $g_i=2^{cnt_i}$，也就是其中这 $cnt_i$ 个元素任意选或不选的结果，那么要求解 $f_i$ 时只要乘以对应的容斥系数即可。特殊地，这题的容斥系数也就是以 “$i$ 在二进制下与 $s$ 相差的 $1$ 的个数”为 $-1$ 指数的那个数。

$cnt$ （代码中为 $f$）在读入时初始化，然后子集转移时用高维前缀和（sosdp）即可。时间复杂度 $O(n+m\times 2^m)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
int n,m;
ll f[(1<<20)+5],ans;
ll two[1000005];
int count_1(int x)
{
	int cnt=0;
	while(x)
	{
		x&=(x-1);
		cnt++;
	}
	return cnt;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int num,x,s=(1<<m)-1;
		scanf("%d",&num);
		while(num--)
		{
			scanf("%d",&x);
			s^=(1<<(x-1));
		}
		f[s]++;
	}
	for(int i=0;i<m;i++) for(int s=(1<<m)-1;s>=0;s--) if(s&(1<<i)) f[s^(1<<i)]=(f[s^(1<<i)]+f[s])%mod;
	two[0]=1;
	for(int i=1;i<=n;i++) two[i]=two[i-1]*2%mod;
	for(int i=0;i<(1<<m);i++)
	{
		int cnt=count_1(i);
		if(cnt%2==0) ans=(ans+two[f[i]])%mod;
		else ans=((ans-two[f[i]])%mod+mod)%mod;
	}
	printf("%lld\n",ans);
}
```

---

## 作者：LinkZelda (赞：1)

我们把每个箱子的集合用二进制压缩，不妨设第 $i$ 个箱子的压缩结果为 $a_i$。

设有 $m$ 种玩具，那么问题转化为求箱子的集合满足他们的 $a_i$ 按位或起来为 $2^m-1$ 的方案数。

我们可以把答案表示成集合幂级数的形式，即
$$
[x^{2^m-1}]\prod(1+x^{a_i})
$$

这里的乘法为或卷积。

于是我们可以对每个箱子做一次 $FMT$ 然后暴力乘起来在 $IFMT$ 回去，但这样的复杂度是 $O(nm2^m)$ 的。

$FMT$ 是满足线性性的，也就是说 $FMT(A)+FMT(B)=FMT(A+B)$。

容易发现对于每个箱子的集合幂级数，$FMT$ 后对每个位置的贡献都是 $1$ 或者 $2$。那么我们可以先求出 $FMT(\sum(1+x^{a_i}))$，然后对每个位置解方程就可以还原出 $FMT(\prod(1+x^{a_i}))$ 了。

具体而言，设 $FMT(\sum(1+x^{a_j}))$ 后得到的结果为 $A$，第 $i$ 个位置有 $x$ 个 $2$，$n-x$ 个 $1$，那么有 $2x+(n-x)=A_i$，解得 $x=A_i-x$，那么 $FMT(\prod(1+x^{a_j}))_i=2^x$。按照这种方案将和化积，然后 $IFMT$ 回去即可。

时间复杂度为 $O(n+m2^m
)$。[代码](https://www.luogu.com.cn/paste/uol912yq)

---

## 作者：Prean (赞：1)

~~和[SP13106](https://www.luogu.com.cn/problem/SP13106)是双倍经验哦~~

我们首先发现 $ m=20 $，所以一言不合先状压。

然后发现状压了之后我们实际上要求的是有多少个子集按位或的值为全集，相当于求有多少个子集按位与的值为 $ 0 $。（把每个集合取反）

我们先不考虑“恰好为空”这个东西，我们考虑“一定包含空”这个东西。

一定包含一个集合 $ S $ 很明显预处理一个超集和就完了，用 FWT 是 $ O(m2^m) $ 的。

容易发现可以直接容斥，预处理一个 $ 2 $ 的幂就完了。
```cpp
#include<cstdio>
#include<cctype>
typedef unsigned ui;
const ui M=1<<20|5,mod=1e9+7;
ui n,m,dp[M],ppc[M],pw2[M];
char buf[1<<25|1],*p=buf;
inline ui read(){
	ui n(0);char s;while(!isdigit(s=*p++));while(n=n*10+(s&15),isdigit(s=*p++));return n;
}
signed main(){
	ui i,j,k,ans;fread(buf,1,sizeof buf,stdin);n=read();m=read();pw2[0]=1;
	for(i=1;i<=n;++i){
		k=read();ans=0;pw2[i]=(pw2[i-1]<<1)%mod;while(k--)ans|=1<<read()-1;++dp[(1<<m)-1^ans];
	}
	for(i=1;i^1<<m;i<<=1)for(j=0;j^1<<m;j+=i<<1)for(k=0;k^i;++k)dp[j|k]+=dp[i|j|k];ans=0;
	for(i=0;i^1<<m;++i)ppc[i]=ppc[i>>1]^(i&1),ans=(ans+(ppc[i]?mod-1ull:1ull)*(pw2[dp[i]]-1))%mod;printf("%u",ans);
}
```

---

## 作者：封禁用户 (赞：1)

### 题目传送门

[P6442](https://www.luogu.com.cn/problem/P6442)

### 题意

有 $n$ 个箱子，每个箱子有若干礼物，求集齐全部 $m$ 个礼物的方案数。

### 分析

可以看到相比起 $n$ 的数据范围，$m \le 20$ 的数据范围是极小的，可以进行状态压缩。

如果选某个礼物，定义这一位为 $1$，否则定义这一位为 $0$。

但直接算某一个状态的答案很难算，我们考虑子集反演。

设 $f(S)$ 表示 $S$ 子集的答案，$g(S)$ 表示状态为 $S$ 的答案。

根据定义，显然有：

$$f(S)=\sum_{T \subseteq S} g(T)$$

进行子集反演：


$$f(S)=\sum_{T \subseteq S} g(T)\Leftrightarrow g(S)=\sum_{T \subseteq S}(-1)^{|S|-|T|} f(T)$$

所以只需要求出所有的 $f(S)$ 即可。

对于 $f(S)$，我们可以用子集 DP，$f(S) = \sum_{i \in S} f(S \otimes 2^i) + cnt_S$，其中 $cnt_S$ 表示 $S$ 这个状态在箱子中的出现次数。

最终的答案就是 $g(\bigcup)$，相当于 $\sum_{S \subseteq \bigcup}(-1)^{|\bigcup|-|S|}f(S)$。

代码很简单，就不放了。

---


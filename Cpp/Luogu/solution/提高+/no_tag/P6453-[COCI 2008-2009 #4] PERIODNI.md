# [COCI 2008/2009 #4] PERIODNI

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/vuf8694o.png)

如图，给定一个由 $n$ 列组成的表格，每一列的底部都是对齐的。

你需要在里面填入 $k$ 个相同的数。但不得有任意两个数在同一行或者同一列。

比如，上图中 `b` 的填写就是不合法的；因为两个 `b` 在同一列上。但 `a` 的填写是合法的，因为这两个 `a` 虽然在同一行，但是中间断开了，所以不算做非法。

请求出填写的方案总数 $\bmod\ 10^9+7$ 的结果。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，输入的数字都小于 $15$；
- 对于 $70\%$ 的数据，输入的数字都小于 $100$；
- 对于 $100\%$ 的数据，$1\le n,k\le 500$，层高不会超过 $10^6$。

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #4](https://hsin.hr/coci/archive/2008_2009/contest4_tasks.pdf) *T6 PERIODNI***。

## 样例 #1

### 输入

```
3 3
2 1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 1
1 2 3 4```

### 输出

```
10```

## 样例 #3

### 输入

```
5 2
2 3 1 2 4```

### 输出

```
43```

## 样例 #4

### 输入

```
3 2
999999 999999 999999```

### 输出

```
990979013```

# 题解

## 作者：沉石鱼惊旋 (赞：19)

# 题目思路

原来这种多边形转成笛卡尔树建树是常见 trick。练的太少导致的。

但是这题其实不用笛卡尔树建树，因为 DP 部分复杂度较高其实这个优化（至少在我的程序上）没有太大作用。

---

为了方便描述，定义中国象棋中的『車』为题目中的颜色，本质一样。

考虑把这个多边形转成树，分割方式就是以底层开割。

机房电脑的 NOI Linux 2.0 没有好用的画图软件，这里用一张别人题解的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/6a5lp8on.png)

我们找到最低点，分成左右两边，分治建树。把最低端想象成子树的根，向上的一层不同颜色既是子节点。

如果不能分成恰好两棵子树，其实没有影响，把某两个放到一起先当成一个节点下一次分开来就好了，没有必要特别判这个问题。

然后这个问题被我们抽象成了树上问题，直接采取树形 DP 解决。

---

这里再提一个东西：

> 大小为 $n\times m$ 的棋盘，放入 $k$ 个『車』，互不攻击的方案数是 $\binom{n}{k}\times \binom{m}{k}\times k!$。

考虑选择 $k$ 行再选择 $k$ 列，方案数是 $\binom{n}{k}\times \binom{m}{k}$。因为列可以任意排列之后和行拼在一起成为不同的方案，所以还要乘上全排列方案数 $k!$。

---

回归本题，设计 $F_{u,i}$ 表示以 $u$ 为根的子树，放了 $i$ 个『車』的方案数。

但是直接乱转移复杂度有点烂，所以先处理 $G_{u,i}$ 表示以 $u$ 为根的子树，**不包括矩形 $u$**，也就是只考虑以 $u$ 的子节点为根的子树，放了 $i$ 个『車』的方案数。

$G$ 数组的转移是显然的，枚举两边分别放了几个。

以下定义 $ls$ 和 $rs$ 表示 $u$ 的左右子树根节点编号。

$$G_{u,i}\gets \sum\limits_{j=0}^{i} F_{ls,j} \times F_{rs,i-j},\forall i\in[1,k]$$

有了这个 $G$ 我们的 $F$ 就可以很快乐的转移了。枚举不包括自己的子树部分，放了几个，然后乘上自己选择的方案数。

但是，因为矩形之间联通，你需要处理有几列被子树部分的『車』覆盖的情况。直接把这几个位置扔掉就行了，剩下的同上面所说的方案数。

因此，$F$ 的转移呼之欲出。定义 $H_u,W_u$ 表示矩形 $u$ 的高和宽。

$$F_{u,i}\gets \sum\limits_{j=0}^{i} \binom {H_u}{i-j}\times \binom {W_u-j}{i-j}\times(i-j)! \times G_{u,j},\forall i\in[1,k]$$

总复杂度为 $\mathcal O(nk^2+n^2)$。

# 部分代码

[洛谷 record 154003111](https://www.luogu.com.cn/record/154003111)

```cpp
const int N = 1e6;
Z fac[N + 20];
Z inv[N + 20];
Z C(int n, int i) { return n < 0 || i < 0 || n < i ? 0 : fac[n] * inv[i] * inv[n - i]; }
#define ls c[u][0]
#define rs c[u][1]
int n, k;
int h[520];
int H[520];
int W[520];
int c[520][2];
Z f[520][520];
Z g[520][520];
int rt;
int build(int l, int r)
{
    if (l > r)
        return 0;
    int u = min_element(h + l, h + r + 1) - h;
    ls = build(l, u - 1);
    rs = build(u + 1, r);
    H[ls] = h[ls] - h[u];
    H[rs] = h[rs] - h[u];
    W[u] = r - l + 1;
    return u;
}
void dfs(int u)
{
    f[u][0] = g[u][0] = 1;
    if (!u)
        return;
    dfs(ls), dfs(rs);
    for (int i = 1; i <= k; i++)
        for (int j = 0; j <= i; j++)
            g[u][i] += f[ls][j] * f[rs][i - j];
    for (int i = 1; i <= k; i++)
        for (int j = 0; j <= i; j++)
            f[u][i] += C(H[u], i - j) * C(W[u] - j, i - j) * fac[i - j] * g[u][j];
}
int main()
{
    fac[0] = 1;
    for (int i = 1; i <= N; i++)
        fac[i] = fac[i - 1] * i;
    inv[N] = fac[N].pow(PPP - 2);
    for (int i = N; i >= 1; i--)
        inv[i - 1] = inv[i] * i;
    read(n, k);
    for (int i = 1; i <= n; i++)
        read(h[i]);
    rt = build(1, n);
    H[rt] = h[rt];
    dfs(rt);
    cout << f[rt][k] << endl;
    return 0;
}
```

---

## 作者：Marser (赞：14)

算是笛卡尔树的经典例题了，现在SPOJ好像把这题毙掉了，就在这里交吧。  
### 题意
给定一个 $n$ 列的表格，第 $i$ 列的高度为 $h_i$。要求在这个表格中选出 $k$ 个格子，满足没有两个格子在同一列或是联通的同一行。求这样选择的方案数  
$n,k\le 500 , \max\{h_i\} \le 10^6$
### 题解
前置知识是[笛卡尔树](https://www.luogu.com.cn/problem/P5854)，这里，我们对序列 $\{h_i\}$ 建立小根笛卡尔树。  
我们每次尽可能地删去整张表格的最底行，直到当前情况下最低行已经不连通，用这些删掉的行组成一个矩形，再将分开的至多两个联通块递归处理，就可以将原图剖分成若干个矩形。  
![](https://cdn.luogu.com.cn/upload/image_hosting/6a5lp8on.png)  
我们发现，这样构成的若干个矩形正好对应小根笛卡尔树上的所有节点，每次递归处理的两个小联通块正是当前节点的两个儿子。根据定义，我们可以知道，对于节点 $x$ 代表的矩形，它的长度为 $siz_x$，高度为 $h_x-h_{fa_x}$。  
这样，我们建出笛卡尔树，就可以把这一问题转化成树上背包问题了。

定义 $f_{i,j}$ 表示在节点 $i$ 子树所代表的区域内选择了 $j$ 个格子的方案数，两个儿子的答案显然可以用树形背包合并，难点就只剩下如何计算与合并当前节点的方案了。  
枚举当前节点所代表的矩形选了 $j$ 个格子，子树内其余部分选了 $k$ 个格子，我们可以将当前矩形的方案数表示成 $C_{siz_x-k}^j\times C_{h_x-h_{fa_x}}^j \times j!$，也就是选择行、列的方案数乘上 $j$ 的全排列。  
通过树上背包的 $siz$ 优化，我们保证两个节点总是在它的 LCA 处合并，总复杂度为 $O(nk+\max\{h_i\})$。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int mod=1e9+7;
const int MN=505;
const int MM=1e6+5;
int n,m,top,h[MN],stk[MN],ch[MN][2],f[MN][MN],siz[MN];
int fac[MM],inv[MM];
inline ll C(int n,int m){
	return 1ll*fac[n]*inv[n-m]%mod*inv[m]%mod;
}
void dfs(int st,int pre){
	f[st][0]=1;siz[st]=1;
	reg int val=h[st]-pre;
	for(reg int i=0;i<2;i++){
		if(!ch[st][i])continue;
		dfs(ch[st][i],h[st]);
		siz[st]+=siz[ch[st][i]];
		for(reg int j=min(siz[st],m);~j;j--)
			for(reg int k=1;k<=min(siz[ch[st][i]],j);k++)
				f[st][j]=(f[st][j]+1ll*f[ch[st][i]][k]*f[st][j-k])%mod;
	}
	for(reg int i=min(siz[st],m);~i;i--)
		for(reg int j=1;j<=min(val,i);j++)
			f[st][i]=(f[st][i]+1ll*f[st][i-j]*fac[j]%mod*C(val,j)%mod*C(siz[st]-i+j,j))%mod;
}
int main(){
	scanf("%d%d",&n,&m);
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(reg int i=2;i<MM;i++)fac[i]=1ll*fac[i-1]*i%mod;
	for(reg int i=2;i<MM;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	for(reg int i=2;i<MM;i++)inv[i]=1ll*inv[i-1]*inv[i]%mod;
	for(reg int i=1;i<=n;i++)scanf("%d",h+i);
	for(reg int i=1;i<=n;i++){
		while(top&&h[stk[top]]>h[i])ch[i][0]=stk[top--];
		if(top)ch[stk[top]][1]=i;
		stk[++top]=i;
	}
	dfs(stk[1],0);
	printf("%d\n",f[stk[1]][m]);
	return 0;
}
```

---

## 作者：_luanyi_ (赞：13)

一道十分神奇的题目。

首先，本题中的图形形状过于诡异，我们可以把它拆成若干个矩形，对于每个矩形单独处理，最后合并答案。为了方便处理，笔者使用的方法如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/aej3kk78.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/dqov3xky.png)

从以上图形中不难看出：设这段图形是 $[l,r]$，则图中的 C 和 F 区域长度即为 $r-l+1$，高度即为 $\min\{h_i\},i\in[l,r]$，然后上方的图形分为左右两个区域，递归处理即可。

在这个分图形的过程中，不难发现，这就是一颗笛卡尔树的建树过程，其中 $i$ 满足二叉搜索树，$h_i$ 满足小根堆，于是我们可以优化建树的过程（其实不优化也可以，但跑得可能相对会慢一些）。

***

接下来考虑怎么统计答案。

首先我们先来给各个矩形编号以方便处理。

对于长在 $[l,r]$ 的矩形，我们令其编号为 $u$，当且仅当 $\min\{h_i\}=h_u,i\in[l,r]$，若有多个满足条件的 $u$ 任选其一即可。容易发现，如果我们以 $u$ 为界限，将编号为 $u$ 的矩形上方的图形分为两个并递归处理（即上面所讲的笛卡尔树建树过程），每个矩形的编号不重复。

接下来，设 $f[u][k]$ 表示编号为 $u$ 的**矩形即其上方图形部分**中放入 $k$ 个数且满足题设条件的方案数。

对于上面的 A，不难发现，如果当前矩形上方什么也没有，设 $a$ 为矩形的长（$r-l+1$），$b$ 为矩形的宽，那么

$$
f[u][k]=\dfrac{A_a^kA_b^k}{A_k^k}
$$

解释：从 $a$ 列里有序选 $k$ 列，从 $b$ 行里有序选择 $k$ 行，得到 $k$ 个有序的交点，但由于填入 $k$ 个无序的数，所以要去重。

接下来考虑答案的合并。

设编号为 $u$ 的矩形上方部分中左边部分的编号为 $l$（即笛卡尔树中的该节点的左儿子），右边部分为 $r$（即笛卡尔树中的该节点的右儿子），我们可以枚举在 $l$ 中放了 $i$ 个数，在 $r$ 中放了 $j$ 个数，于是在矩形中便要放 $k-i-j$。不难发现

$$
f[u][k]=\sum_{i=0}^{k}\sum_{j=0}^{k-i}f[l][i]\times f[r][j]\times\dfrac{A_{a-i-j}^{k-i-j}A_b^{k-i-j}}{A_{k-i-j}^{k-i-j}}
$$

其中 $a$ 为矩形的长，$b$ 为矩形的宽。

但是这个式子的时间复杂度是遍历树 $O(n)$ 乘上枚举 $k,i,j$ 共为 $O(nk^3)$，过不了。

考虑设

$$
g[u][p]=\sum_{i+j=p}f[l][i]\times f[r][j]
$$

该式子为 $O(k^2)$。

则

$$
f[u][k]=\sum_{p=0}^{k}g[u][p]\times\dfrac{A_{a-p}^{k-p}A_b^{k-p}}{A_{k-p}^{k-p}}
$$

式子被优化成了 $O(k^2)$。

此时总复杂度已经降为 $O(nk^2)$，可过。

***

**code**

```cpp
#include <bits/stdc++.h>
#define fq(i,a,b) for (int i = (a); i <= (b); i++)
using namespace std;
#define int long long
inline int rd () {
	int f = 1;
	char ch = getchar ();
	while (!isdigit (ch)) (ch == '-' ? (f = -1) : 0), ch = getchar ();
	int num = 0;
	while (isdigit (ch)) num = num * 10 + ch - '0', ch = getchar ();
	return num * f;
}
#define d rd ()

const int maxn = 550;
const int mod = 1e9+7;
int n = d, k = d, h[maxn];
int l[maxn], r[maxn], sk[maxn], top;
int mul[1001000], invm[1001000];
bool cmp (int a, int b) {
    return h[a] < h[b];
}
int f[maxn][maxn], g[maxn], sz[maxn];
void prew (int u) {
    sz[u] = 1;
    if (l[u]) prew (l[u]), sz[u] += sz[l[u]];
    if (r[u]) prew (r[u]), sz[u] += sz[r[u]];
}
int A (int N, int M) {
    if (M > N) return 0;
    return mul[N] * invm[N - M] % mod;
}
int sol (int N, int M, int K) {
    return A (N, K) * A (M, K) % mod * invm[K] % mod;
}
void dfs (int u, int low) {
    int uh = h[u] - low;
    if (!l[u] && !r[u]) {
        f[u][0] = 1;
        fq (i, 1, k) f[u][i] = sol (sz[u], uh, i);
        return;
    }
    if (!l[u] || !r[u]) {
        int v;
        if (!l[u]) v = r[u];
        else v = l[u];
        dfs (v, h[u]);
        memset (g, 0, sizeof g);
        g[0] = 1;
        fq (i, 1, k) fq (j, 0, i) g[i] = (g[i] + f[0][j] * f[v][i - j]) % mod;
        f[u][0] = 1;
        fq (i, 1, k) fq (j, 0, i) f[u][i] = (f[u][i] + g[j] * sol (uh, sz[u] - j, i - j)) % mod;
        return;
    }
    dfs (l[u], h[u]);
    dfs (r[u], h[u]);
    memset (g, 0, sizeof g);
    g[0] = 1;
    fq (i, 1, k) fq (j, 0, i) g[i] = (g[i] + f[l[u]][j] * f[r[u]][i - j]) % mod;
    f[u][0] = 1;
    fq (i, 1, k) fq (j, 0, i) f[u][i] = (f[u][i] + g[j] * sol (uh, sz[u] - j, i - j)) % mod;
}
int power (int a, int b, int p) {
	int c = 1;
	while (b) {
		if (b & 1) c = c * a % p;
		a = a * a % p;
		b >>= 1;
	} return c;
}
signed main () {
    mul[0] = invm[0] = 1;
    fq (i, 1, 1000000) {
        mul[i] = mul[i - 1] * i % mod;
        invm[i] = invm[i - 1] * power (i, mod - 2, mod) % mod;
    }
    fq (i, 1, n) h[i] = d;
    fq (i, 1, n) {
        int kk = top;
        while (kk && h[sk[kk]] > h[i]) --kk;
        if (kk) r[sk[kk]] = i;
        if (kk != top) l[i] = sk[kk + 1];
        sk[top = ++kk] = i;
    } prew (sk[1]); f[0][0] = 1;
    dfs (sk[1], 0); cout << f[sk[1]][k] << endl;
	return 0;
}

```

---

## 作者：dspt (赞：10)

## 前言
大家都说这是一道笛卡尔树的模板题，但是我们简单观察一下数据范围：$1\leqslant n,k\leqslant 500$，发现 $n^2$ 的暴力建堆对于本题的代码速度不会有较大的影响。于是我们不需要笛卡尔树，暴力建堆即可。

**这是题解区唯一一篇不需要笛卡尔树的题解**，除此之外，本题是一道极好的动态规划题。

&nbsp;
## 思路
1. 我们先想简化版本：表格是一个完全的 $n\times m$ 矩形，那么易知答案为 $\dfrac{n!m!}{(n-k)!(m-k)!k!}$，其实就是 $n$ 行里面选 $k$ 行的方案数量乘 $m$ 行里面选 $k$ 行的方案再去重（去重即除以 $k$ 的排列）。

2. 观察图形，显然低位比高位更加难处理。于是想到动态规划：先将独立的每一列作为初始状态，然后不停**从高往低**合并。

   如下图，我们可以先处理出绿色部分和蓝色部分，再与红色部分合并。这样就完成了从高往低的合并。
   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/chqhqjf0.png)

   其它情况也是类似的，对于一个区间，先找出其中最小  $h$  的位置，处理出其左侧和其右侧的图形方案数，再与下面这块公共的红色合并。

3. 设计状态：对于一个区间，我们只需要记录此区间中放 $i$ 个数的方案数即可，于是记其为 $p_i$。

4. 考虑转移，设左边（图中绿色部分）的状态为 $l$，右边（图中红色部分）的状态为 $r$，我们可以枚举左边放的数数量 $i$，右边放的数数量 $j$，下面（图中红色部分）放的数数量 $s$，则每次枚举 $p[i+j+s]=p[i+j+s]+l.p[i]\times r.p[j]\times\text{count}(L-i-j,H,s)$。其中 $L$ 为区间长度，$H$ 为下面区域的高度，$\text{count}(n,m,k)$ 即指 1. 中的问题方案数。

5. 现在合并的代码时间复杂度为区间数量乘以枚举时间复杂度即 $O(k^3n)$，能拿到大约 40 分。于是我们考虑优化。最大的问题出在状态合并处。我们是否可以将 $k^3$ 合并优化至 $k^2$ 合并？

   答案是可以的，我们先假设 $k=0$，枚举 $i,j$，设这样得到的状态为 $q$。然后考虑加上 $s$，于是我们视上面为一个整体 $(q)$，下面为一个整体。可以分别枚举两边取得数量，这样就是 $k^2$ 的转移了。

现在纵观整个动态规划，先是找到区间最低点，然后分左右处理，个人认为这像是一个区间 $\text{DP}$。

但是如果我们将每个区间看作一个节点，那么每次合并想做一个二叉树中左子树（区间最低点左侧）和右子树（区间最低点右侧）与根的合并，这又像是一道树形 $\text{DP}$。

在写的时候，我分了三类来讨论，二叉树中此节点为叶子节点为 1 类，此节点只有一个叶子为 2 类，此节点有两个叶子为 3 类，个人认为这是比较方便理解的。

![](https://cdn.luogu.com.cn/upload/image_hosting/weugqlf8.png)

综上，由于区间数不超过 $k$，本题时间复杂度为 $O(k^3n+n^2)$。由于二叉树每个节点的最小值其实呈现了一个**小根堆**的性质（如图，$\text{minh}$ 即呈现此性质），可以用笛卡尔树建树优化，省掉一个 $n^2$，别的题解将的比较详细，在此不做赘述。

&nbsp;
## 代码 / 注意点
[代码及注释](https://www.luogu.com.cn/paste/rp8h0b55)

其实本题细节还是比较多的，特别是 $\text{DP}$ 的过程中，一定要注意边界情况。

&nbsp;
## 后记

这么说来，这道动态规划是不是还比较简单？点个赞再走呗~

其实这么写的确比笛卡尔树的写法慢一些，有能力还是建议写一下笛卡尔树。

---

## 作者：lytqwq (赞：9)

~~好妙啊~~

首先建立出高度的小根笛卡尔树，发现这样构成的若干个矩形正好对应小根笛卡尔树上的所有节点（可以看前面题解的那张图）

你会发现，对于一个父节点，它的儿子节点只会影响一些列不能选，而且因为选的地方中间断开是合法的，我们只需要让这一个节点只选**该节点代表的矩阵的高度以内 列**，并且和儿子和节点内部没有列的冲突就完了。

当前矩阵的长度： $size_i$ 

当前矩阵的高度： $h_i-h_{fa}$ 

当 $i$ 节点的儿子选了 $x$ 个时

留给当前节点就是 $size_i-x$ 列可选

在 $size_i-x$ 列可选，矩阵的高度为 $h_i-h_{fa}$ 时，选 $y$ 个的选法有：

$$ \large C_{size_i-x}^{y} \times C_{h_i-h_{fa}}^{y} \times y! $$

设 $f_{i,j}$ 代表在节点 $i$ 的子树中选 $j$ 个的方案数

$$\large f_{i,j}=\sum_{l+r\le j}{f_{ls_i,l}\times f_{rs_i,r}\times ( C_{size_i-(l+r)}^{(j-l-r)} \times C_{h_i-h_{fa}}^{(j-l-r)} \times (j-l-r)! ) } $$

直接这样做是 $O(nk^3)$

发现后面一段只和 $i+j$ 有关，我们把它拿出来


$$\large f_{i,j}=\sum_{o}( C_{size_i-o}^{(j-o)} \times C_{h_i-h_{fa}}^{(j-o)} \times (j-o)! )\times \sum_{l+r=o}{f_{ls_i,l}\times f_{rs_i,r} } $$

后面的我们可以 $O(n^2)$ 预处理一下

这就是 $O(nk^2)$ 了

然后就完了/cy

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long int N=511,p=1e9+7;
long long int n,k;
long long int a[N];
long long int Stack[N],top;
long long int ls[N],rs[N],size[N];
long long int f[N][N],g[N][N];
long long int inv[(int)1e6+10],mul1[(int)1e6+10],mul2[(int)1e6+10];
long long int C(long long int x,long long int y){return y>x?0:mul1[x]*mul2[y]%p*mul2[x-y]%p;}
void dfs(long long int u,long long int fa){
	if(ls[u])dfs(ls[u],u);
	if(rs[u])dfs(rs[u],u);
	size[u]=size[ls[u]]+size[rs[u]]+1;
	for(long long int i=0;i<=size[ls[u]];i++){
		for(long long int o=0;o<=size[rs[u]];o++){
			g[u][i+o]+=f[ls[u]][i]*f[rs[u]][o]%p;
			g[u][i+o]%=p;
		}
	}
	for(long long int i=0;i<=size[u];i++){
		for(long long int o=0;o<=i;o++){
			f[u][i]+=g[u][o]*(C(size[u]-o,i-o)*C(a[u]-a[fa],i-o)%p*mul1[i-o]%p)%p;
			f[u][i]%=p;
		}
	}
}
int main(){
	scanf("%lld%lld",&n,&k);
	inv[0]=mul1[0]=mul2[0]=inv[1]=mul1[1]=mul2[1]=1;
	for(long long int i=2;i<=1e6;i++){
		inv[i]=inv[p%i]*(p-p/i)%p;
		mul1[i]=mul1[i-1]*i%p;
		mul2[i]=mul2[i-1]*inv[i]%p;
	}
	for(long long int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		long long int k=top;
		while(k>0&&a[Stack[k]]>a[i])k--;
		if(k)rs[Stack[k]]=i;
		if(k<top)ls[i]=Stack[k+1];
		Stack[++k]=i;
		top=k;
	}
	f[0][0]=1;
	dfs(Stack[1],0);
	printf("%lld\n",f[Stack[1]][k]);
}
```




















































---

## 作者：ix35 (赞：9)

随便看题库看到一道经典老题。

设第 $i$ 个位置层高 $h_i$，建立序列 $h_i$ 的小根笛卡尔树，然后树形 DP。

设 $dp(i,j)$ 表示在 $i$ 的子树内放 $j$ 个车互不攻击的方案数（注意放的纵坐标必须大于 $fa_i$ 的高度，即只能填在子树内部），那么转移一是从子树里来，二是在自己所代表的矩形中填。

对于第一种转移，直接树形背包即可，运用经典的复杂度分析方法可以知道是 $O(n^2)$ 的。

对于第二种转移，我们枚举自己的矩形中放了几个车。如果我们要在 $n\times m$ 矩形中放 $k$ 个车，那么方案数是 $\binom n k\times \binom m k\times k!$，但要注意，我们还要枚举已经在儿子中放了几个车，因为儿子所占掉的列在这里是不能填的，因此这里的复杂度会到达 $O(n^2k)$。

难度大概是蓝题，管理看到了可以顺手评一下。

```cpp
int n,k,hd,fac[MAXM],inv[MAXM],siz[MAXN],a[MAXN],ch[MAXN][2],st[MAXN],dp[MAXN][MAXN],tmp[MAXN];
int qpow (int a,int b) {
    int res=1;
    while (b) {
        if (b&1) {res=(1ll*res*a)%P;}
        a=(1ll*a*a)%P,b>>=1;
    }
    return res;
}
void init () {
    fac[0]=inv[0]=1;
    for (int i=1;i<=MAXM-10;i++) {fac[i]=(1ll*fac[i-1]*i)%P;}
    inv[MAXM-10]=qpow(fac[MAXM-10],P-2);
    for (int i=MAXM-11;i>=1;i--) {inv[i]=(1ll*inv[i+1]*(i+1))%P;}
    return;
}
int c (int n,int m) {return (1ll*fac[n]*((1ll*inv[n-m]*inv[m])%P))%P;}
void dfs (int x,int fa) {
    siz[x]=1,dp[x][0]=1;
    for (int i=0;i<=1;i++) {
        if (!ch[x][i]) {continue;}
        dfs(ch[x][i],x);
        siz[x]+=siz[ch[x][i]];
        memset(tmp,0,sizeof(tmp));
        for (int j=0;j<=siz[ch[x][i]];j++) {
            for (int k=0;j+k<=siz[x];k++) {
                tmp[j+k]=(tmp[j+k]+(1ll*dp[ch[x][i]][j]*dp[x][k])%P)%P;
            }
        }
        for (int j=0;j<=siz[x];j++) {dp[x][j]=tmp[j];}
    }
    for (int i=siz[x];i>=0;i--) {
        //cout << "  " << x << "  " << i << "    " << dp[x][i] << "    ";
        int sum=0;
        for (int j=0;j<=min(i,a[x]-a[fa]);j++) {
            //cout << "  " << j << "  " << siz[x]-i+j << "    " << c(siz[x]-i+j,j) << "    " << a[x]-a[fa] << "    " << c(a[x]-a[fa],j) << endl;
            sum=(sum+(1ll*dp[x][i-j]*((1ll*fac[j]*((1ll*c(siz[x]-i+j,j)*c(a[x]-a[fa],j))%P))%P))%P)%P;
        }
        dp[x][i]=sum;
        //cout << x << "  " << i << "    " << dp[x][i] << endl;
    }
    return;
}
int main () {
    scanf("%d%d",&n,&k);
    init();
    for (int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
        while (hd&&a[st[hd]]>a[i]) {
            ch[i][0]=st[hd];
            hd--;
        }
        if (hd) {ch[st[hd]][1]=i;}
        st[++hd]=i;
    }
    dfs(st[1],0);
    printf("%d\n",dp[st[1]][k]);
    return 0;
}
```


---

## 作者：Laoshan_PLUS (赞：3)

一道广为人知的笛树题。既然 SPOJ 交不了了~~双倍经验没了~~，那就在这里交一发题解。

事先感谢 @[Dyc780511](https://www.luogu.com.cn/user/528787) 大佬。

---

这道题运用了一个技巧：将图建成树。

考虑到如果有一个最小的棋盘将两边分隔开，那么除去这个棋所在的行以外，剩下的两组棋盘互不干扰。即对于 $i>h_x$，棋盘 $x$ 左边的第 $i$ 行和棋盘 $x$ 右边的第 $i$ 行互不干扰。那么可以通过这一点进行树形 DP。我们发现，一个子树的根节点是整个区间的最小值，所以整棵树是一棵笛卡尔树。给出的高度相当于 $w$，下标相当于 $k$。接着令 $f_{i,j}$ 表示节点 $i$ 为根的子树中放置 $j$ 个节点，且所有棋子所在行的编号不小于节点 $i$ 的父亲节点的高度，即棋子的行编号在区间 $\left(h_{\textit{fa}(x)},\infty\right)$ 内的方案数。

先考虑棋子编号在区间 $\left(h_x,\infty\right)$ 的方案数，此时相当于一个背包，转移方程为：

$$
f_{i,j}=\sum_{\textit{to}\in\textit{son}_i}\sum_{k=1}^{j}f_{\textit{to},k}\times f_{i,j-k}
$$

注意此时为了不让数组刚更新的内容去更新其他内容，因此 $j$ 应从大到小循环。接着考虑行编号在区间 $\left(h_{\textit{fa}(x)},h_x\right]$ 中的棋子。我们如果放 $k$ 个这样的棋子，那么说明必须有一些列是空的，接着从范围内选出 $k$ 个不同的数字然后分在这些空列当中，转移方程为：

$$
f_{i,j}=\sum_{k=1}^{j}f_{i,j-k}\times \binom{h_x-h_{\textit{fa}(x)}}{k}\times\mathrm A_{\textit{siz}_i-(j-k)}^{k}
$$

注意此时为了不让数组刚更新的内容去更新其他内容，因此 $j$ 应从大到小循环。最后两个区间的方案数累加起来就是对应的值。最后的答案是 $f_{rt,k}$。

```cpp
#include <bits/stdc++.h>
#define inv(i) (power(fac[i], MOD - 2))
#define int long long
using namespace std;

constexpr int MAXN = 505, MOD = 1e9 + 7, MAXH = 1e6 + 5;
int n, k, a[MAXN];
int ls[MAXN], rs[MAXN], rt, siz[MAXN];
stack<int> st;
int fac[MAXH];
int f[MAXN][MAXN];

int power(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i < MAXH; i++) fac[i] = fac[i - 1] * i % MOD;
}

int A(int n, int m) {
	if (n < m || n < 0 || m < 0) return 0;
    return fac[n] * inv(n - m) % MOD;
}

int C(int n, int m) {
	if (n < m || n < 0 || m < 0) return 0;
    return fac[n] * inv(m) % MOD * inv(n - m) % MOD;
}

void insert(int k, int w) {
    while (!st.empty() && w < a[st.top()]) {
        ls[k] = st.top();
        st.pop();
    }
    if (!st.empty()) rs[st.top()] = k;
    else rt = k;
    st.push(k);
}

void dfs(int x, int fno) {
    siz[x] = 1;
    if (ls[x]) dfs(ls[x], x);
    if (rs[x]) dfs(rs[x], x);
    siz[x] += siz[ls[x]] + siz[rs[x]];
    f[x][0] = 1;
    for (int i = k; i >= 1; i--)
        for (int j = 1; j <= min(i, siz[ls[x]]); j++)
            f[x][i] = (f[x][i] + f[ls[x]][j] * f[x][i - j] % MOD) % MOD;
    for (int i = k; i >= 1; i--)
        for (int j = 1; j <= min(i, siz[rs[x]]); j++)
            f[x][i] = (f[x][i] + f[rs[x]][j] * f[x][i - j] % MOD) % MOD;
    for (int i = min(k, siz[x]); i >= 1; i--)
        for (int j = 1; j <= i; j++)
            f[x][i] = (f[x][i] + f[x][i - j] * C(a[x] - a[fno], j) % MOD * A(siz[x] - i + j, j) % MOD) % MOD;
}

signed main() {
    init();
    scanf("%lld%lld", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]), insert(i, a[i]);
    dfs(rt, 0);
    cout << f[rt][k] << '\n';

    return 0;
}
```

---

## 作者：无钩七不改名 (赞：3)

笛卡尔树 + 树形 dp。

设 $a_i$ 表示从左往右第 $i$ 列的层数，我们可以建立关于 $a_i$ 的小根笛卡尔树。

设 $dp_{i,j}$ 表示子树 $i$ 中选取 $j$ 个点，但是不能选祖先节点所能选取到的层数的点的方案数。那么 $dp_{i,j}$ 可以由左儿子选出的 $kl(0\le kl\le j)$ 个点（即 $dp_{l_i,kl}$）和右儿子选出的 $kr(0\le kr\le kl+kr\le j)$ 个点和在当前子树可以选的 $j-kl-kr$ 个点（即 $dp_{r_i,kr}$）的方案数之乘积。

那么问题就转换为如何求当前子树可以选的方案数。

由于当前不可以选祖先能选取到的层数，那么我们可以取的层数也就为 $h_i=a_i-a_{fa_i}$。设当前子树大小为 $sz_i$，由于之前这个点所能取到的层数它的子孙是不能取的，所以我们取数的范围实际上是整棵子树的第 $(a_{fa_i}+1)\sim a_i$ 层。事实上就是一个 $h_i \times sz_i$ 的矩形。（自己脑补一下或者画个图就明白了。）

那么这个子问题转化为，在一个长为 $a$，宽为 $b$ 的矩形选 $k$ 个点的方案数。我们可以先选出 $k$ 列，方案数为 $C_a^k$，然后选出 $k$ 行填入这 $k$ 列，但是注意填入是有序的，所以方案数为 $A_b^k$。

于是得出 dp 方程式：

$$
dp_{i,j}=\sum dp_{l_i,kl}\times dp_{r_i,kr}\times C_{sz_i}^{j-kl-kr}\times A_{h_i}^{j-kl-kr}
$$

~~就，感性理解一下吧。~~

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=505,mod=1e9+7,M=1000005;

int n,k,a[N];
int l[N],r[N],rt;
int st[N],tp;
int sz[N],h[N];
long long dp[N][N],c[M],inv[M];

int read(){
	int f=1,k=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		k=k*10+ch-'0';
		ch=getchar();
	}
	return f*k;
}

long long ct(int nn,int mm){
	if(mm>nn)return 0;
	return c[nn]*inv[nn-mm]%mod*inv[mm]%mod;
}

void dfs(int x){
	if(!x)return;
	h[l[x]]=a[l[x]]-a[x];
	h[r[x]]=a[r[x]]-a[x];
	dfs(l[x]);dfs(r[x]);
	sz[x]=sz[l[x]]+sz[r[x]]+1;
	dp[x][0]=1;
//	cout<<x<<" "<<h[x]<<" "<<sz[x]<<'\n';
	for(int i(min(k,sz[x]));i;--i){
		//	cout<<x<<":" <<i<<" "<<min(i,h[x])<<'\n';
		for(int kk(min(i,h[x]));kk>=0;--kk)
			for(int j(kk);j<=i;++j){
				dp[x][i]=(dp[x][i]+dp[l[x]][j-kk]*dp[r[x]][i-j]%mod*ct(sz[x]-i+kk,kk)%mod*ct(h[x],kk)%mod*c[kk]%mod)%mod;
				//cout<<i<<" "<<kk<<" "<<j-kk<<" "<<i-j<<" --> "<<dp[x][i]<<'\n';
			}
	}
	return;
}

void init(){
	dp[0][0]=1;
	c[0]=1;inv[0]=inv[1]=1;
	for(int i(1);i<=1000000;++i)c[i]=c[i-1]*i%mod;
	for(int i(2);i<=1000000;++i)inv[i]=((-mod/i*inv[mod%i])%mod+mod)%mod;
	for(int i(2);i<=1000000;++i)inv[i]=inv[i]*inv[i-1]%mod;
	h[rt]=a[rt];
	return;
}

int main(){
	n=read();k=read();
	for(int i(1);i<=n;++i){
		a[i]=read();
		while(tp&&a[st[tp]]>a[i])--tp;
		if(tp){
			l[i]=r[st[tp]];
			r[st[tp]]=i;
		}
		else{
			l[i]=rt;
			rt=i;
		}
		st[++tp]=i; 
	}
	init();
	dfs(rt);/*cout<<rt<<'\n';
	for(int i(1);i<=n;++i){
		for(int j(0);j<=k;++j)cout<<dp[i][j]<<' ';
		puts("");
	}puts("***");
	for(int i(1);i<=k;++i){
		for(int j(0);j<=k;++j)cout<<c[i][j]<<' ';
		puts("");
	}*/
	printf("%lld",dp[rt][k]);
	//cout<<'\n'<<inv[2]<<" "<<c[3]<<" "<<ct(3,2)<<'\n';
	return 0;
}
```

~~温馨提醒，这里不能直接用快速幂或者 exgcd 求阶乘的逆元，我因为这个调半天……~~

---

## 作者：hegm (赞：3)

### [[COCI2008-2009#4] PERIODNI](https://www.luogu.com.cn/problem/P6453)

计数 dp。

联想到最大子矩形，所以考虑建立出笛卡尔树。（利用性质 $i$ 号节点的子树一定是一个连通块，并且这个连通块的最小高度就是 $i$ 的高度）

按照高度最小的为根，建立笛卡尔树。

现在来考虑如何设计状态，显然，$dp$ 数组要记录一维是位置，那么另一维度就要是 $k$ 了，表示当前选了几个点。

但是这还不够，需要再此基础上添加一些状态方便合并。

现在 $dp_{i,j}$ 表示考虑 $i$ 号节点和他的子树中的连续段，选择 $j$ 个节点的方案数。

这种状态不好向父亲合并，因为父亲的左右孩子可能会重叠，在 $1\sim val_i$ 的区间里面重复。

那么不妨重新定义 dp 数组：

$dp_{i,j}$ 表示考虑 $i$ 极其子树中，选择 $j$ 个点，并且选择区间在 $val_{fa_i}\sim \infty$。

这样一来，合并就不麻烦了，因为左右子树的节点的方案不可能冲突。

但是这样的话，合并到 $i$ 号节点的方案数就不包含 $1\sim val_i$ 选择了，所以我们要添加一些东西。

先列出一个比较暴力的式子。

$dp_{i,j}=\sum\limits_{a,b,c}dp_{ls,a}\times dp_{rs,b}\times \text{C}_{siz_i-a-b}^k\times\text{A}_{val_i}^k$

$a$ 指的是 $ls$ 中选择 $a$ 个填数（$a\le siz_{ls}$），$b$ 与之同理。

$c$ 表示在选择完毕之后，再次选择 $c$ 个数字，填在 $1\sim val_i$ 的范围内。

那么 $j=a+b+c$。

复杂度是很奇怪的。

当然可以使用树上背包复杂度来证明，复杂度是 $O(n^3)$ 的。


### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 1005
#define mod 1000000007
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,k,ls[N],rs[N],last,a[N],fa[N],rt,dp[N][N],siz[N],C[N][N];
stack<int> t;
int j[1000005],p[1000005];
int add(int a,int b){return (1ll*a+b)%mod;}
int mul(int a,int b){return (1ll*a*b)%mod;}
int ksm(int d,int z)
{
	int ans=1;
	while(z)
	{
		if(z&1)ans=mul(ans,d);
		d=mul(d,d);
		z>>=1;
	}
	return ans;
}
int A(int x,int y)
{
	if(y>x)return 0;
	return mul(j[x],p[x-y]);
}
void dfs(int now)
{
	siz[now]=1;
	if(!ls[now]&&!rs[now])
	{
		dp[now][0]=1;
		dp[now][1]=a[now]-a[fa[now]];
		return ;
	}
	if(ls[now])dfs(ls[now]),siz[now]+=siz[ls[now]];
	if(rs[now])dfs(rs[now]),siz[now]+=siz[rs[now]];
	dp[now][0]=1;
	if(!ls[now]||!rs[now])
	{
		int to=ls[now]+rs[now];
		for(int i=1;i<=siz[now];i++)
		for(int j=0,con=min(i,siz[now]);j<=con;j++)
		{
			dp[now][i]=add(dp[now][i],mul(dp[to][j],mul(C[siz[now]-j][i-j],A(a[now]-a[fa[now]],i-j))));
		}
	}
	else
	{
		for(int i=1;i<=siz[now];i++)
		for(int j=0,con=min(i,siz[ls[now]]);j<=con;j++)
		for(int k=0,con=min(i-j,siz[rs[now]]);k<=con;k++)
		dp[now][i]=add(dp[now][i],mul(dp[ls[now]][j],mul(dp[rs[now]][k],mul(C[siz[now]-j-k][i-j-k],A(a[now]-a[fa[now]],i-j-k)))));
	}
}
int main()
{
	n=read();k=read();
	C[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++)
		C[i][j]=add(C[i-1][j-1],C[i-1][j]);
	}
	j[0]=1;p[0]=1;
	for(int i=1;i<=1000000;i++)j[i]=mul(j[i-1],i);
	for(int i=1;i<=1000000;i++)p[i]=ksm(j[i],mod-2);
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)
	{
		last=0;
		while(t.size()&&a[t.top()]>a[i])last=t.top(),t.pop();
		ls[i]=last;
		if(last)fa[last]=i;
		if(t.empty())
		{
			t.push(i);
			continue;
		}
		rs[t.top()]=i;
		fa[i]=t.top();
		t.push(i);
	}
	while(t.size()!=1)t.pop();
	rt=t.top();
	dfs(rt);
	cout<<dp[rt][k]<<"\n";
	return 0;
}

```

---

## 作者：FutaRimeWoawaSete (赞：3)

考虑建立笛卡尔树后做树上 dp。              

一个比较简单的想法就是合并左右儿子。

分成两部分，第一部分的答案就是枚举左右儿子各选多少然后拼在一起即可，相当于就是一个背包时间复杂度 $O(n ^ 2)$。           

第二部分里面我们要加入一个底层的矩形，考虑它对当前子树的贡献。这时候我们枚举一下矩形里面放多少个车即可，需要注意如果矩形里面放了车后可以选择的纵列个数减少，计算时也要相应减去。            

时间复杂度 $O(n ^ 2k)$。

---

## 作者：FjswYuzu (赞：3)

高度不等的层十分棘手，考虑通过一些东西将其变成规整的图形，例如矩形。

如果用笛卡尔树解决过不等高木板问最大子矩阵的问题不难想到用笛卡尔树。构建一个笛卡尔树，采用小根堆构建，对于一个节点，其表示的是，以其高为高，其子树对应区间长度为长的矩形。

考虑以矩形为背景解决这个问题。首先要处理两个子节点（本质上是两个子矩阵）的合并问题。考虑定义 $dp_{i,j}$ 为节点 $i$ 对应区间中放置 $j$ 个数的合法方案数。发现这是一个树形背包的形式，通过子树大小的优化就可以解决这个问题。问题在于如何加上自己本身的贡献。考虑在一个 $n \times m$ 的矩阵中放入 $k$ 个车使其两两不冲突。因为要选 $k$ 行 $k$ 列放顺序不定的车，总方案数是 $\dbinom{n}{k}\dbinom{m}{k}k!$。

然而之前更上面的矩阵（即除了自己的，该子树内所有的节点）已经占用了一些列。我们不能够直接转移。因此要枚举占用了多少列，然后再进行一次树形背包。

因此总时间复杂度为 $O(n^2k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1e9+7;
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans=(ans*base)%MOD;
		base=(base*base)%MOD;
		p>>=1;
	}
	return ans;
}
LL fac[1000005],ifac[1000005];
LL C(LL n,LL m){if(n<m)	return 0;return fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;}
LL a[505],n,k,dp[505][505],siz[505],tmp[505],stk[505],top,ch[505][2];
void dfs(LL now,LL pre)
{
	siz[now]=dp[now][0]=1;
	for(LL i=0;i<=1;++i)
	{
		if(!ch[now][i])	continue;
		dfs(ch[now][i],now);
		memset(tmp,0,sizeof tmp);
		siz[now]+=siz[ch[now][i]];
		for(LL j=0;j<=min(siz[now],k);++j)	for(LL l=0;l<=min(j,siz[ch[now][i]]);++l)	(tmp[j]+=dp[now][j-l]*dp[ch[now][i]][l]%MOD)%=MOD;
		memcpy(dp[now],tmp,sizeof tmp);
	}
	for(LL i=min(siz[now],k);~i;--i)	for(LL j=1;j<=min(a[now]-a[pre],i);++j)	(dp[now][i]+=dp[now][i-j]*C(a[now]-a[pre],j)%MOD*C(siz[now]-i+j,j)%MOD*fac[j]%MOD)%=MOD;
}
/*
n,m - s

C(n,s) * C(m,s) * s!
*/
int main(){
	scanf("%lld %lld",&n,&k);
	for(LL i=1;i<=n;++i)	scanf("%lld",&a[i]);
	fac[0]=1;
	for(LL i=1;i<=1000000;++i)	fac[i]=fac[i-1]*i%MOD;
	ifac[1000000]=QuickPow(fac[1000000],MOD-2);
	for(LL i=999999;~i;--i)	ifac[i]=ifac[i+1]*(i+1)%MOD;
	stk[top=1]=1;
	for(LL i=2;i<=n;++i)
	{
		while(top && a[stk[top]]>a[i])	--top;
		if(!top)	ch[i][0]=stk[top+1];
		else	ch[i][0]=ch[stk[top]][1],ch[stk[top]][1]=i;
		stk[++top]=i;
	}
//	for(LL i=1;i<=n;++i)	printf("%lld %lld\n",ch[i][0],ch[i][1]);
	dfs(stk[1],0);
	printf("%lld",dp[stk[1]][k]);
	return 0;
}
```

---

## 作者：xzz_cat6 (赞：3)

看到大家都用的二叉树，写一下不用二叉树的题解，我主要结合代码讲解。

### 题解
首先，这张看着就不怎么友好的图，我们需要对他进行一些处理，跟大部分题解一样，我们可以将这张图按行分成若干个矩阵，每个矩阵最多跟下面的一个矩阵相连，如图，这是我自己造的一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/boa9qjzu.png)

我们会发现，除了最下面的矩阵，其他矩阵的下面，仅会有一个矩阵与其相连，如浅蓝色在下面只和黄色相连，这是显然的。因此，以最下面的矩阵为根（红色矩阵），整张图构成了一个树形结构。

```cpp
int build(int l,int r){
	int u=l;
	for(rint i=l;i<=r;i++){//找区间最小值 
		if(h[i]<h[u])	u=i;
	}
	int id=++tot;//给这个矩阵编号 
	a[id]=h[u],b[id]=r-l+1;//矩阵长宽 
	for(rint i=l;i<=r;i++)	h[i]-=a[id]; //所有这个区间的的高度减去矩阵的长 
	int lst=0;
	for(rint i=l;i<=r;i++){//找所有非0连续区间，递归建树 
		if(!h[i]){
			if(lst)	e[id].push_back(build(lst,i-1)); 
			lst=0;
		}
		else{
			if(!lst)	lst=i;
		}
	}
	if(lst)	e[id].push_back(build(lst,r));//不要忘记最后的区间 
	return id;
}
```

我们给每一个矩阵编号，进行树形 DP，设一个矩阵长宽分别为 $a_i$，$b_i$，dp 状态为 $f_{i,j}$，表示以第 $i$ 个节点为根的子树中填 $j$ 个格子的方案数，接下来是一个类似背包的过程，讲解放代码里。

```cpp
void dfs(int u){
	f[u][0]=1;//赋初值 
	for(auto v:e[u]){//处理u儿子的矩阵 
		dfs(v);
		for(rint i=m;i>=1;i--){//模拟背包，注意倒序 
			for(rint j=1;j<=i;j++){//j从1开始 
				f[u][i]+=f[u][i-j]*f[v][j]%mod;  
				f[u][i]%=mod;
			}//注意取模 
		}
	}
	for(rint i=m;i>=1;i--){//处理u本身的矩阵 
		for(rint j=0;j<i;j++){//枚举i、j，i、j不做解释了 
			f[u][i]+=f[u][j]*A(a[u],i-j)%mod*C(b[u]-j,i-j)%mod;//选出i-j个行，i-j个列，去除已选过的列 
			f[u][i]%=mod;
		}
	}
}
```

答案输出 $f_{rt,m}$。

最后想说一下我的逆元处理，时间复杂度为线性，有兴趣可以看一下[这里](https://www.cnblogs.com/NicoDafaGood/p/7569476.html)，有问题可以回复[这里](https://www.luogu.com.cn/discuss/809012)。


完整无注释代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define maxn 510
#define maxm 1000010
#define rint register int
using namespace std;

int n,m,h[maxn];
int inv[maxm],fact[maxm],pmod[maxm];
int qpow(int a,int b){
	if(!b)	return 1;
	int k=qpow(a,b/2);
	if(b&1)	return k*k%mod*a%mod;
	return k*k%mod;
}
bool vis[maxm];
void pri(){
	pmod[1]=1;
	for(int i=2;i<maxm;i++){
		if(!vis[i]){
			pmod[i]=qpow(i,mod-2);
		}
		for(int j=2;j*i<maxm;j++){
			vis[j*i]=1;
			pmod[j*i]=pmod[i]*pmod[j]%mod;
			if(!(j%i))	break;
		}
	}
}
void init(){
	pri();
	fact[0]=inv[0]=1;
	for(rint i=1;i<maxm;i++){
		fact[i]=fact[i-1]*i%mod;
		inv[i]=inv[i-1]*pmod[i]%mod;
	}
}
int C(int x,int y){
	if(y>x||y<0||x<0)	return 0;
	return 	fact[x]*inv[y]%mod*inv[x-y]%mod;
}
int A(int x,int y){
	if(y>x||y<0||x<0)	return 0;
	return fact[x]*inv[x-y]%mod;
}

int tot;
int a[maxn],b[maxn],rt;
vector<int> e[maxn];
int build(int l,int r){
	int u=l;
	for(rint i=l;i<=r;i++){
		if(h[i]<h[u])	u=i;
	}
	int id=++tot;
	a[id]=h[u],b[id]=r-l+1;
	for(rint i=l;i<=r;i++)	h[i]-=a[id];
	int lst=0;
	for(rint i=l;i<=r;i++){
		if(!h[i]){
			if(lst)	e[id].push_back(build(lst,i-1));
			lst=0;
		}
		else{
			if(!lst)	lst=i;
		}
	}
	if(lst)	e[id].push_back(build(lst,r));
	return id;
}
int f[maxn][maxn];
void dfs(int u){
	f[u][0]=1;
	for(auto v:e[u]){
		dfs(v);
		for(rint i=m;i>=1;i--){
			for(rint j=1;j<=i;j++){
				f[u][i]+=f[u][i-j]*f[v][j]%mod;
				f[u][i]%=mod;
			}
		}
	}
	for(rint i=m;i>=1;i--){
		for(rint j=0;j<i;j++){
			f[u][i]+=f[u][j]*A(a[u],i-j)%mod*C(b[u]-j,i-j)%mod;
			f[u][i]%=mod;
		}
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	init();
	for(rint i=1;i<=n;i++){
		cin>>h[i];
	}
	rt=build(1,n);
	dfs(rt);
	cout<<f[rt][m]<<endl;
	return 0;
} 
```

---


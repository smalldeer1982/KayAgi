# [COCI 2006/2007 #5] DVAPUT

## 题目描述

给定一个长度为 $L$ 的字符串，你需要找出一个最长的子串，**并且使得这个子串在字符串中出现了至少两次**（在不同的位置）。输出它的长度。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le L\le 2\times 10^5$，输入的字符串都为小写字母。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #5](https://hsin.hr/coci/archive/2006_2007/contest5_tasks.pdf) *T6 DVAPUT***。

## 样例 #1

### 输入

```
11
sabcabcfabc```

### 输出

```
3```

## 样例 #2

### 输入

```
18
trutrutiktiktappop```

### 输出

```
4```

## 样例 #3

### 输入

```
6
abcdef```

### 输出

```
0```

# 题解

## 作者：Clare613 (赞：4)

## 思路：
这是打 OI 比赛时场切的，写篇题解纪念一下。\
第一步，审题。看到这样的题面，判断是[哈希](https://www.luogu.com.cn/article/rrf64fws)。然后看数据范围：$1\le L\le 2\times 10^5$，判断是哈希 + 二分。\
很快把哈希板子打出来，然后写 $\operatorname{check}$ 函数。不难发现，`unordered_map<int,bool>` 叠加 O2 优化后不会超时。于是就可以利用 `unordered_map<int,bool>` 秒了这道题。\
⚠⚠⚠注意事项：不同的位置不代表不重叠，请注意。
## code：
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int ha[200005],pw[200005];
unordered_map<int,bool> f;
int n;
string x;
int hashh(int l,int r){
	return ha[r]-ha[l-1]*pw[r-l+1];
}
bool check(int x){
	f.clear();
	for(int i=x;i<=n;i++){
		if(f[hashh(i-x+1,i)]==1){
			return 1;
		}
		f[hashh(i-x+1,i)]=1;
	}
	return 0;
}
signed main(){
	cin>>n;
	cin>>x;
	x=" "+x;
	pw[0]=1;
	for(int i=1;i<=n;i++){
		ha[i]=ha[i-1]*13331+x[i];
		pw[i]=pw[i-1]*13331;
	}
	int l=0,r=n;
	while(l<r){
//		cout<<l<<" "<<r<<"\n";
		int mid=(l+r+1)/2;
		if(check(mid)) l=mid;
		else r=mid-1; 
	}
	cout<<l;
	return 0;
}
```

---

## 作者：lzqy_ (赞：4)

简单哈希+二分，不用 SA 和 SAM。

看到求最大长度，先二分答案。对于长度 $x$，求出每一个长度为 $x$ 的子串的哈希值，判断是否有一个值出现了两次。

然后就做完了。时间复杂度 $\text{O(nlog}^\text{2}\text{n)}$，如果 check 时再哈希一次应该能做到 $\text{O(nlogn)}$。


另外，这道题应该是属于弱化版了，改成出现 $k$ 次也是能做的，只是 check 的时候稍微麻烦一点。

代码主要长在用了双模数哈希，但应该是目前最简单的做法了。

有注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
const int mod1=998244353;
const int mod2=1e9+7;
const int base1=37;
const int base2=39;
inline char cread(){
	int x=0;
	char c=getchar();
	for(;!(c>='a'&&c<='z');c=getchar());
	return c;
}
pair<int,int>Tmp[maxn];
int a[maxn];
int n,H1[maxn],H2[maxn],Pow1[maxn],Pow2[maxn];
int Hash1(int l,int r){
	return ((H1[r]-H1[l-1]*1ll*Pow1[r-l+1])%mod1+mod1)%mod1;
}
int Hash2(int l,int r){
	return ((H2[r]-H2[l-1]*1ll*Pow2[r-l+1])%mod2+mod2)%mod2;
}
bool check(int x){
	for(int i=x;i<=n;i++)//用Tmp数组存下所有子串的哈希值
		Tmp[i-x+1]=make_pair(Hash1(i-x+1,i),Hash2(i-x+1,i));
	sort(Tmp+1,Tmp+n-x+2);
	for(int i=2;i<=n-x+1;i++)//判断是否有值出现两次
		if(Tmp[i-1]==Tmp[i]) return 1;
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) a[i]=cread()-'a';
	Pow1[0]=Pow2[0]=1;
	for(int i=1;i<=n;i++){
		H1[i]=(H1[i-1]*1ll*base1+a[i])%mod1;
		H2[i]=(H2[i-1]*1ll*base2+a[i])%mod2;
		Pow1[i]=(Pow1[i-1]*1ll*base1)%mod1;
		Pow2[i]=(Pow2[i-1]*1ll*base2)%mod2;
	}//哈希
	int l=0,r=n-1,mid;
	while(r>l){//二分答案
		mid=l+r+1>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	printf("%d\n",l);
	return 0;
}
```

---

## 作者：Durancer (赞：3)

### 前言

弱化版的求出现 $k$ 次的最长长度的子串。

### 思路

加强版的该题，其实正解为单调队列优化查找区间最小值的最大值，就和滑动窗口类似，找出 $k-1$ 个连续的 $\text{height}$ 数组的最小值的最大值即可，求出 $\text{height}$ 数组来直接做即可。

这个是求出现两次的？看一看 $\text{height}$ 数组的定义，$\text{height}_i$ 表示排名为 $i$ 和排名为 $i-1$ 的字串的最长公共前缀。

可以发现的是，一个 $\text{height}$ 数组中是包含了两个后缀的最长公共前缀，很显然的可以考虑套用模板求出 $\text{height}$ 数组，然后循环一遍取最大值即可

### 代码实现

```cpp
/*
	求出出现2次的字串的最大长度
	用根据height数组的定义，也就是求出所有连续 2-1 个height 数组的最小值最大值 
*/
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
const int N=2e5+9;
int rk[N<<1],sa[N],oncerk[N<<1];
int rkid[N],id[N],height[N];
int cnt[N];
char s[N];
int b[N]; 
int n,m;
int q[N<<1];//单调队列优化 
int ans;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
bool cmp(int x,int y,int len)//排序
{
	return (oncerk[x]==oncerk[y])&&(oncerk[x+len]==oncerk[y+len]);
}
void getheight()//求出 height 数组
{
	for(int i=1,k=0;i<=n;i++)
	{
		if(rk[i]==1) k=0;
		else
		{
			if(k) k--;
			int j=sa[rk[i]-1];
			while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])
				k++;
		}
		height[rk[i]]=k;
	}
}
void SA()//SA的板子
{
	for(int i=1;i<=n;i++) cnt[rk[i]=s[i]]++;
	for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];
	for(int i=n;i>=1;i--) sa[cnt[rk[i]]--]=i;
	for(int len=1,p;len<n;len<<=1)
	{
		p=0;
		for(int i=n;i>n-len;i--) id[++p]=i;
		for(int i=1;i<=n;i++) 
			if(sa[i]>len)
				id[++p]=sa[i]-len;
		
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;i++) cnt[rkid[i]=rk[id[i]]]++;
		for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];
		for(int i=n;i>=1;i--) sa[cnt[rkid[i]]--]=id[i];
		
		memcpy(oncerk,rk,sizeof(rk));
		m=0;
		for(int i=1;i<=n;i++)
			rk[sa[i]]=(m+=(cmp(sa[i],sa[i-1],len)^1)); 
	}
	return;
}
int main()
{
	n=read();
	scanf("%s",s+1);
	m=max(n,300);
	SA();//造后缀数组
	getheight();//求height数组
    //k>2可以考虑用单调队列优化，只需要找出
    //所有连续的k-1个height数组的最小值的最大值即刻
	for(int i=1;i<=n;i++)
		ans=max(height[i],ans);
	printf("%d\n",ans);
	return 0; 
}
```


---

## 作者：zimujun (赞：1)

既然 caq 用 [SA](https://www.luogu.com.cn/blog/230804/solution-p6456) 过了这道题，那我就来发一下 SAM 的题解吧。

求出现至少两次的字符串的最长长度，这是一个 SAM 的经典问题。显然可以直接在 parent 树上 dp 求出某个节点代表子串的出现次数，然后取满足条件的最大值。

然而，当我敲完 SAM 的板子的时候，MLE！交上去却发现空间限制只有 32M。

于是用时间换空间，考虑到 SAM 最多有 $3n - 4$ 条转移边，因此改为使用链式前向星存图，修改或查找的时候直接暴力 $\mathcal O\left(|\small\sum|\right)$ 枚举出边。（$|\small\sum|$ 表示字符集大小）

时间复杂度 $\mathcal O\left(n\right)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int Maxn = 2e5 + 1;

int ver[Maxn * 3], nxt[Maxn * 3], head[Maxn << 1], key[Maxn * 3];
int link[Maxn << 1], len[Maxn << 1], siz[Maxn << 1], cnt = 1, last = 1, ecnt;
void add(int u, int v, int w) {ecnt++; ver[ecnt] = v; key[ecnt] = w; nxt[ecnt] = head[u]; head[u] = ecnt;}
int findkey(int u, int w) {
	for(int i = head[u]; i; i = nxt[i])
		if(key[i] == w) return i;
	return 0;
}
void extend(int c) {
	int cur = ++cnt, p = last; last = cur;
	len[cur] = len[p] + 1; siz[cur] = 1;
	while(p && !findkey(p, c)) add(p, cur, c), p = link[p];
	if(!p) {link[cur] = 1; return;}
	int q = ver[findkey(p, c)]; if(len[q] == len[p] + 1) {link[cur] = q; return;}
	int cl = ++cnt; len[cl] = len[p] + 1; link[cl] = link[q];
	link[q] = link[cur] = cl; for(int i = head[q]; i; i = nxt[i]) add(cl, ver[i], key[i]);
	int t; while(p && ver[t = findkey(p, c)] == q) ver[t] = cl, p = link[p];
}

int rk[Maxn << 1], id[Maxn << 1], ans;
char ch;

int main() {
	ch = getchar(); while(!isalpha(ch)) ch = getchar(); while(isalpha(ch)) extend(ch - 'a'), ch = getchar();
	for(int i = 1; i <= cnt; ++i) ++rk[len[i]];
	for(int i = 1; i <= cnt; ++i) rk[i] += rk[i - 1];
	for(int i = cnt; i >= 1; --i) id[rk[len[i]]--] = i;
	for(int i = cnt; i >= 1; --i) {
		int cur = id[i];
		siz[link[cur]] += siz[cur];
		if(siz[cur] > 1) ans = max(ans, len[cur]);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：sccc_ (赞：1)

## Solution

哈希 + 二分。

很容易发现单调性，只要有符合要求且长度为 $x$ 的子串，就有同样符合要求长度为 $x-1$，$x-2$ 的，以此类推。

二分子串长度 $mid$，把每一个长度为 $mid$ 的子串哈希值在 `set` 里找就可以了。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define ull unsigned long long

using namespace std;

const int N = 2e5 + 10, Base = 13331;

int n;
string s;
ull pw[N], hs[N];

int get_hs(int l, int r) {
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

bool check(int mid) {
	if (mid == 0)
		return 1;
    unordered_set<ull> mp;
	for (int i = 1; i + mid - 1 <= n; i++) {
		ull hs = get_hs(i, i + mid - 1);
		if (mp.count(hs))
			return 1;
		mp.insert(hs);
	}
	return 0;
}

signed main() {
//	freopen("T3.in", "r", stdin);
//	freopen("T3.out", "w", stdout);
	cin.tie(0), cout.tie(0)->sync_with_stdio(false);
	cin >> n >> s;
	s = ' ' + s;
	pw[0] = 1;
	for (int i = 1; i <= n; i++) {
		pw[i] = pw[i - 1] * Base;
		hs[i] = hs[i - 1] * Base + s[i];
	}
	int l = 0, r = n + 1;
	while (l + 1 < r) {
		int mid = l + r >> 1;
		if (check(mid))
			l = mid;
		else
			r = mid;
	}
	cout << l;
	return 0;
}
```

---

## 作者：Cure_Wing (赞：1)

[P6456 [COCI2006-2007#5] DVAPUT](https://www.luogu.com.cn/problem/P6456)

来一个内存小但是用时偏大的哈希。

### 解析

假设存在答案 $x$，那么所有小于等于 $x$ 的答案都可以用答案为 $x$ 的子串截出来，所以可以二分。

考虑到长度 $x$ 子串数量只有 $(n-x+1)$ 个，所以我们暴力把所有子串抠出来插到桶里去匹配，如果存在一个子串插入了两次说明符合要求。

把子串取出来可以哈希，可以像另一种解法预处理哈希，也可以动态处理。主要是由于每次只会在字符串开头删除，结尾插入。具体做法就是每次删除开头字符的哈希值，再插入结尾的字符。

时间复杂度 $O(n\log_2n)$，空间复杂度 $O(n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<unordered_map>
#define ll unsigned long long
using std::cin;using std::cout;
constexpr int N=200005,base=137;
int n;
std::string s;
ll val,now;
std::unordered_map<ll,bool>p;
inline bool check(int x){
	val=1;now=0;p.clear();
	for(int i=1;i<x;++i) val*=base;
	for(int i=1;i<=x;++i) now=now*base+s[i]-'a';
	p[now]=1;
	for(int i=x+1;i<=n;++i){
		now-=(s[i-x]-'a')*val;
		now=now*base+s[i]-'a';//每次删除开头字符的哈希值，再插入结尾的字符。
		if(p[now]) return 1;//哈希表查找
		p[now]=1;
	}
	return 0;
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>s;s=" "+s;
	int l=1,r=n;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1;
		else r=mid-1;
	}
	cout<<r;
	return 0;cout<<"星空幸";
}//第九十九回 守官箴恶奴同破例 阅邸报老舅自担惊
```

---

## 作者：Li2021 (赞：0)

求出现至少 $2$ 次的最长长度的子串。

$|S|\le2\times10^5$，字符集为小写字母。

### 思路

后缀数组模板题。

考虑 $\text{height}$ 数组的定义：

+ $\text{height}_i$ 表示排名为 $i$ 和排名为 $i−1$ 的后缀串的最长公共前缀。

考虑一个子串，它必然是一个后缀的前缀。而对于出现至少 $2$ 次的最长子串，它作为前缀的那若干个前缀必然相邻。

那么 $\text{height}_i$ 作为排名为 $i$ 和排名为 $i−1$ 的后缀串的最长公共前缀，它肯定包含出现至少 $2$ 次的最长子串。答案即为 $\text{height}$ 数组的最大值。

### 代码

```cpp
#include <bits/stdc++.h>
#define N 400002
#define inf 0x3f3f3f3f
using namespace std;
string s;int ans,V=200;
int sa[N<<1],n,k,rk[N<<1],p,rk2[N],cnt[N],id[N],h[N];
bool cmp(int x,int y){return rk[x]!=rk[y]?rk[x]<rk[y]:rk[x+k]<rk[y+k];}
void SA(){
    memset(cnt,0,sizeof cnt);
    memset(sa,0,sizeof sa);
    memset(id,0,sizeof id);
    memset(h,0,sizeof h);
    memset(rk2,0,sizeof rk2);
    memset(rk,0,sizeof rk);
    p=0;V=200;
    for(int i=1;i<=n;i++)  cnt[rk[i]=s[i]]++;
    for(int i=1;i<=V;i++)  cnt[i]+=cnt[i-1];
    for(int i=n;i>=1;i--)  sa[cnt[rk[i]]--]=i;
    for(k=1;k<=n;k<<=1,V=p){
        // stable_sort(sa+1,sa+n+1,cmp);
        int pc=0;
        for(int i=n-k+1;i<=n;i++)  id[++pc]=i;
        for(int i=1;i<=n;i++)  if(sa[i]>k)  id[++pc]=sa[i]-k;
        memset(cnt,0,sizeof cnt);
        for(int i=1;i<=n;i++)  cnt[rk[i]]++;
        for(int i=1;i<=V;i++)  cnt[i]+=cnt[i-1];
        for(int i=n;i>=1;i--)  sa[cnt[rk[id[i]]]--]=id[i];
        memcpy(rk2,rk,sizeof rk2);p=0;
        for(int i=1;i<=n;i++){
            if(rk2[sa[i]]==rk2[sa[i-1]]&&rk2[sa[i]+k]==rk2[sa[i-1]+k])  rk[sa[i]]=p;
            else  rk[sa[i]]=++p;
        }
        if(p==n)  break;
    }
    for(int i=1,k=0;i<=n;i++){
        if(!rk[i])continue;if(k)k--;
        while(s[i+k]==s[sa[rk[i]-1]+k])  k++;
        h[rk[i]]=k;
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>s;s='*'+s;
    SA();
    int ans=0;
    for(int i=1;i<=n;i++)  ans=max(ans,h[i]);
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P6456 题目](https://www.luogu.com.cn/problem/P6456)

### 解题思路
二分答案，求出所有长度为 $mid$ 的子串的哈希值，检查其中是否有相同的即可，建议使用双哈希。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int B=39,B2=37,p=1e9+7,p2=998244353;
unordered_map<signed,short> mapp;
int maxx,n,powb[200001],powb2[200001];
string s;
inline void ef()
{
	int l=1,r=n;
	while(l<=r)
	{
		int mid=(l+r)/2,y=0,y2=0,pd=0;
		for(int i=0;i<mid;i++)
			y=(y*B+(s[i]-'a'))%p,y2=(y2*B2+(s[i]-'a'))%p2;
		mapp[y]+=1,mapp[y2]+=2;
		for(int i=1;i<=n-mid;i++)
		{
			y=((y-powb[mid-1]*(s[i-1]-'a'))%p*B+(s[i+mid-1]-'a'))%p,y2=((y2-powb2[mid-1]*(s[i-1]-'a'))%p2*B2+(s[i+mid-1]-'a'))%p2;
			if(mapp[y]+mapp[y2]==3)
			{
				pd=1;
				break;
			}
			mapp[y]+=1,mapp[y2]+=2;
		}
		if(pd==1)
			l=mid+1,maxx=max(maxx,mid);
		else
			r=mid-1;
		mapp.clear();
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	powb[0]=1,powb2[0]=1;
	for(int i=1;i<=200000;i++)
		powb[i]=powb[i-1]*B%p,powb2[i]=powb2[i-1]*B2%p2;
	cin>>n>>s;
	int pd=0;
	for(int i=1;i<n;i++)
	{
		if(s[i]!=s[i-1])
		{
			pd=1;
			break;
		}
	}
	if(pd==0)
	{
		cout<<n-1;
		return 0;
	}
	ef();
	cout<<maxx;
	return 0;
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P6456)

### 思路

先考虑暴力。答案显然满足单调性，我们可以二分答案，每次将长为 $mid$ 的子串丢到 ```map``` 里然后查询。这样做的时间复杂度是 $O(n^2\log n)$，空间复杂度是 $O(n^2)$，不足以通过。

考虑用字符串哈希优化，把查到的子串哈希值丢到 ```unordered_set``` 里查找，这样可以做到时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

由于 $L$ 较大，所以采用双模数哈希。一个模数哈希，一个自然溢出哈希，这样能避免 WA 以及过多取模的巨大常数导致的 TLE。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
typedef unsigned long long ull;
const int N = 2e5 + 10, mod = 998244353;
unordered_set<ull>s1;
ll s[N], pw[N];
ull s2[N], pw2[N];
il ull ask(int l, int r) 
{
	return ((s[r] - s[l - 1] * pw[r - l + 1] % mod + mod) % mod) * 1000000000ll % mod + s2[r] - s2[l - 1] * pw2[r - l + 1];
} 
int n;
il bool chk(int mid)
{
	if(!mid)
		return true;
	s1.clear();
	for(int i = 1;i + mid - 1 <= n;++i)
	{
		ull q = ask(i, i + mid - 1);
		if(s1.count(q))
			return true;
		s1.insert(q);
	}
	return false;
}
int main()
{
	scanf("%d", &n);
	int tot = 0;
	char ch = getchar();
	while(ch < 'a' || ch > 'z')
		ch = getchar();
	while('a' <= ch && ch <= 'z')
	{
		++tot;
		s[tot] = (s[tot - 1] * 26 % mod + ch - 'a') % mod;
		s2[tot] = s2[tot - 1] * 1331 + ch - 'a';
		ch = getchar();
	}
	pw[0] = pw2[0] = 1;
	for(int i = 1;i <= n;++i)
		pw[i] = pw[i - 1] * 26 % mod, pw2[i] = pw2[i - 1] * 1331;
	int l = 0, r = n;
	while(l < r)
	{
		int mid = (l + r + 1) >> 1;
		if(chk(mid))
			l = mid;
		else
			r = mid - 1;
	}
	cout << l;
	return 0;
}

```

---

## 作者：zplqwq (赞：0)

显然，如果某个后缀的 height 值不为 $0$ 那么所对应的子串就至少出现了两次。因为 height 求的是 LCP，所以如果当前这个 $height_i$ 的值不为 $0$，则这个子串至少在第 $i$ 个后缀和第 $i-1$ 个后缀出现过，因此至少出现了两次。

利用这个性质，我们只需要求出 height 数组中的最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
char s[N];
int n,m;
int height[N];
int sa[N],rk[N];
int x[N],y[N],c[N];
void solve_init()
{
	for(int i=1;i<=n;i++)
	{
		x[i]=s[i];
		++c[x[i]];
	}
	for(int i=2;i<=m;i++) c[i]+=c[i-1];
	for(int i=n;i>=1;i--)
	{
		sa[c[x[i]]--]=i;
	}
}
void solve_sa()
{
	for(int k=1;k<=n;k=k<<1)
	{
		int num=0;
		for(int i=n-k+1;i<=n;i++) y[++num]=i;
		for(int i=1;i<=n;i++)
		{
			if(sa[i]>k) y[++num]=sa[i]-k;
		}
		for(int i=1;i<=m;i++) c[i]=0;
		for(int i=1;i<=n;i++) c[x[i]]++;
		for(int i=2;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--)
		{
			sa[c[x[y[i]]]--]=y[i];
			y[i]=0;
		}
		swap(x,y);
		num=1;
		x[sa[1]]=1;
		for(int i=2;i<=n;i++)
		{
		//	int tmp=x[sa[i]];
			if(y[sa[i]]==y[sa[i-1]] and y[sa[i]+k]==y[sa[i-1]+k])x[sa[i]]=num;
			else x[sa[i]]=++num; 
		
		}
		if(num==n) break;
		m=num;
	}
	int k=0;
	for(int i=1;i<=n;i++) rk[sa[i]]=i;
	for(int i=1;i<=n;i++)
	{
		if(rk[i]==1) continue;
		if(k) k--;
		int j=sa[rk[i]-1];
		while(i+k<=n and j+k<=n and s[i+k]==s[j+k]) k++;
		height[rk[i]]=k;
	}
}
int ans=0;
int main()
{
	cin>>n;
	scanf("%s",s+1);
	m=122;
	solve_init();
	solve_sa();
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,height[i]); 
	} 
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：斜揽残箫 (赞：0)

## Description

题目意思很明确，在一个字符串中寻找两个相同的不在同一位置的最长的子串。

发现这道题目是输出长度，不用输出子串，所以直接上 SA。

## Solution

很显然我们可以求出这个字符串的后缀排序，进而求出 $\text{Height}$ 数组。

因为 $\text{Height}$ 是排名为 $i$ 的后缀与排名为 $i−1$ 的后缀的最长公共前缀，所以我们按照模板求出 $\text{Height}$ 数组就可以了，最后循环求出最长的，不断更新答案即可。

学习 SA 的话，推荐一篇博客 [Link](https://www.cnblogs.com/luckyblock/p/14217034.html)，他讲的挺详细的。

## Code

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int Maxk = 2e5 + 10;
char s[Maxk];
int len_,cnt[Maxk],H[Maxk],n,m,ans;
int rk[Maxk],sa[Maxk],tak[Maxk],tp[Maxk];
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
void Max(int &x,int y) {if(x < y) x = y;}//取最大 && 赋值
void Sort()//计数排序
{
  for(int i = 1;i <= m;i ++) cnt[i] = 0;
  for(int i = 1;i <= n;i ++) cnt[rk[i]] ++;
  for(int i = 1;i <= m;i ++) cnt[i] += cnt[i - 1];
  for(int i = n;i >= 1;i --) sa[cnt[rk[tp[i]]] --] = tp[i];
  return; 
}
void Height()//求出 Height 数组
{
  int k = 0;
  for(int i = 1;i <= n;i ++) {
    if(k) k --;
    int j = sa[rk[i] - 1];
    while(s[i + k] == s[j + k]) k ++;
    H[rk[i]] = k;
  }
  return;
}
void Solve()
{
  m = 300;
  for(int i = 1;i <= n;i ++) rk[i] = s[i] - '0' + 1,tp[i] = i;
  Sort();
  for(int w = 1,k = 0;k < n;m = k,w <<= 1) {
		k = 0;
    for(int i = 1;i <= w;i ++) tp[++ k] = n - w + i;
    for(int i = 1;i <= n;i ++) if(sa[i] > w) tp[++ k] = sa[i] - w;
    Sort();
    swap(tp,rk);
    rk[sa[1]] = k = 1;
    for(int i = 2;i <= n;i ++) {
      rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + w] == tp[sa[i] + w]) ? k : ++ k;
    } 
  }
  Height(); 
  return;
}
signed main()
{
  n = read();
  scanf("%s",s + 1);
  Solve();
  for(int i = 2;i <= n;i ++) {
    Max(ans,H[i]);//不断取出最大值
  }
  printf("%d\n",ans);
  return 0;
}
```


---


# [COCI 2008/2009 #6] DOSTAVA

## 题目描述

在一个 $r\times c$ 的方格矩阵中，一个快递员从公司 $(1,1)$ 出发，要前往 $d$ 个格子送披萨。在临走的时候，他就已经带上了所有的披萨，这样就不会因为来回奔波而浪费时间了。

快递员任何时刻都只能左右移动，但如果他在第 $1$ 或 $c$ 列时，就可以上下运动。每到一个格子，都有在此处要花费的时间。（多次到达多次计入总时间）

为了能更高效，他想知道，这 $d$ 个送餐点共需要花费多长时间？

## 说明/提示

#### 样例 1 解释

最短的送餐路线为：

$(1,1),(2,1),(3, 1), (3, 2), (3, 3), (2, 3), (1, 3), (2, 3), (3, 3), (2, 3),(2, 2)$。

总用时为：$1+2+1+0+1+2+2+2+1+2+3=17$。

#### 数据规模与约定

- 对于 $70\%$ 的数据，保证 $r\le 250$；
- 对于 $100\%$ 的数据，保证 $1\le r\le 2000$，$1\le c\le 200$，$1\le d\le 2\times 10^5$，$1\le a\le r$，$1\le b\le c$。

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #6](https://hsin.hr/coci/archive/2008_2009/contest6_tasks.pdf) *T5 DOSTAVA***。

## 样例 #1

### 输入

```
3 3
1 8 2
2 3 2
1 0 1
3
1 3
3 3
2 2```

### 输出

```
17```

## 样例 #2

### 输入

```
2 5
0 0 0 0 0
1 4 2 3 2
4
1 5
2 2
2 5
2 1```

### 输出

```
9```

# 题解

## 作者：_Spectator_ (赞：6)

[可能更好的食用体验](/article/37u7z5v8) $|$ 
[题目传送门](/problem/P6471) $|$ 
[我的其他题解](/user/523641#article.2)

------------

### ${\color{#00CD00}\text{题意}}$

给定一张 $n\times m$ 的网格，每个格子 $(i,j)$ 上有一个权值 $a_{i,j}$。可以在网格上任意左右移动，但只有在第 $1$ 列或者第 $m$ 列才能上下移动。现在要从 $(1,1)$ 出发依次经过 $D$ 个不同的格子，求经过的格子的权值之和的最小值。

------------

### ${\color{#00CD00}\text{思路}}$

将每一个点都作为状态进行考虑显然不现实。注意到“只有在第 $1$ 列或者第 $m$ 列才能上下移动”，不难想到将每一行的第 $1$ 个点和第 $m$ 个点作为状态进行考虑。这样就将原图拆分为了 $2\times n$ 个状态，其中第 $i$ 行第 $1$ 的点的编号为 $i$，第 $i$ 行第 $m$ 的点的编号为 $i+n$。

接下来可以在这些状态之间连边。连边方式也比较显然：  
对于第 $i$ 行，
- 从 $i$ 向 $i+n$ 连一条边，权值为 $\sum a_i - a_{i,m}$。
- 从 $i+n$ 向 $i$ 连一条边，权值为 $\sum a_i - a_{i,1}$。
- 若 $i>1$，从 $i$ 向 $i-1$ 连权值为 $a_{i,1}$ 的边，同时从 $i+n$ 向 $i\!-\!1\!+\!n$ 连权值为 $a_{i,m}$ 的边。
- 若 $i<n$，从 $i$ 向 $i+1$ 连权值为 $a_{i,1}$ 的边，同时从 $i+n$ 向 $i\!+\!1\!+\!n$ 连权值为 $a_{i,m}$ 的边。

其中 $\sum a_i$ 表示第 $i$ 行所有 $a_{i,j}$ 的和。减去 $a_{i,m}$ 和 $a_{i,1}$ 是为了避免算重。

这样我们就建出了一张图。定义 $f_{i,j}$ 表示由状态 $i$ 到状态 $j$ 的最小花费时间。可以用多源最短路算法求解。
- 使用 $\bf floyd$ 算法，时间复杂度为 $O(n^3)$，可以通过 $70\%$ 的数据。
- 使用 $\bf Dijkstra$ 算法，以每一个点为原点跑一遍 $\rm dijkstra$，时间复杂度为 $O(n^2\log n)$，可以通过本题。

求得 $f$ 数组后，对于每一个询问 $(tx,ty)\to (x,y)$，分类讨论出最短时间即可。注意不要忘了讨论 $tx=x$ 的情况，即起点与终点在同一行。

代码实现上需要注意：
- `long long`。
- 数组要开 $2$ 倍大。
- 可以预处理出前缀和、后缀和来优化实现。
- 留意 corner case，避免转角处的点的权值被重复计算或漏算。

本题实现较繁琐，具体细节可参见代码。

------------

### ${\color{#00CD00}\text{代码}}$

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i=a; i<=b; i++)
#define req(i, a, b) for(int i=a; i>=b; i--)
#define add(u, v, w) G[u].push_back({v, w})
using namespace std;
const int N = 2e3 + 5, M = 2e2 + 5, inf = 2e9 + 5;
typedef pair<int, int> pii;
long long n, m, Q, ans; //其实只有这个 ans 需要开 long long
int a[N][M], s[N][M], r[N][M];
int vis[N<<1], f[N<<1][N<<1];
vector<pii> G[N<<1];
void dijkstra(int s, int *dis){ //dijkstra 算法 
	priority_queue<pii, vector<pii>, greater<pii>> q;
	fill(dis, dis+1+n*2, inf), fill(vis, vis+1+n*2, 0);
	dis[s] = 0, q.push({0, s});
	while(!q.empty()){
		int d = q.top().first, u = q.top().second; q.pop();
		if(vis[u]) continue; vis[u] = 1;
		for(pii i:G[u]){
			int v = i.first, w = i.second;
			if(d + w < dis[v]) dis[v] = d + w, q.push({dis[v], v});
		}
	}
}
signed main(){
	ios::sync_with_stdio(false), cin.tie(nullptr);
	cin >> n >> m;
	rep(i, 1, n) rep(j, 1, m) cin >> a[i][j]; //读入 
	rep(i, 1, n) rep(j, 1, m) s[i][j] = s[i][j-1] + a[i][j]; //前缀和 
	rep(i, 1, n) req(j, m, 1) r[i][j] = r[i][j+1] + a[i][j]; //后缀和
	rep(i, 1, n){ //建图
		if(i > 1) add(i, i-1, a[i][1]), add(i+n, i-1+n, a[i][m]);
		if(i < n) add(i, i+1, a[i][1]), add(i+n, i+1+n, a[i][m]);
		add(i, i+n, s[i][m] - a[i][m]), add(i+n, i, s[i][m] - a[i][1]);
	}
	rep(i, 1, n*2) dijkstra(i, f[i]); //多源最短路 
	int tx=1, ty=1;
	for(cin >> Q; Q --> 0;){ //分类讨论处理询问 
		int x, y; cin >> x >> y;
		int res0 = tx ^ x ? inf : y < ty ? s[x][ty] - s[x][y] : s[x][y-1] - s[x][ty-1];
		int res1 = s[tx][ty] - a[tx][1] + f[tx][x] + s[x][y] - a[x][y];
		int res2 = r[tx][ty] - a[tx][m] + f[tx+n][x] + s[x][y] - a[x][y];
		int res3 = s[tx][ty] - a[tx][1] + f[tx][x+n] + r[x][y] - a[x][y];
		int res4 = r[tx][ty] - a[tx][m] + f[tx+n][x+n] + r[x][y] - a[x][y];
		ans += min({res0, res1, res2, res3, res4}); tx = x, ty = y;
	}
	cout << ans + a[tx][ty];
	return 0;
}
```
---

[AC Record](https://www.luogu.com.cn/record/180724131)

附：本题有一道[加强版](https://www.luogu.com.cn/problem/SP4034)，那题的时限只有 $200ms$，需要使用 dp 解决。

---

## 作者：cjrqwq (赞：4)

教练放在了模拟赛里，据说有 $O(R^2)$ 的解法，劳烦知道的 dalao 分享一下。

## 解法
要求任意两点间的最短距离。观察图，发现像“目”。

对于从 $x$ 到 $y$ 的情况，如果不在同一行，则最短路只可能会有以下情况： 

1. 从 $x$ 的左边出，$y$ 的左边进。
2. 从 $x$ 的左边出，$y$ 的右边进。
3. 从 $x$ 的右边出，$y$ 的左边进。
4. 从 $x$ 的右边出，$y$ 的右边进。

如果在同一行，则多一种情况：$x$ 直接走到 $y$。

使用全源最短路求从 $x$ 出之后到 $y$ 进之前的情况。这种情况的点只有 $2R$ 个，边只有 $6R$ 条。所以复杂度是 $O(R^2\log R)$。

## 实现

注意不要算重了，对于各种拐弯的情况要注意。前缀和求一行间的距离。

[代码](https://www.luogu.com.cn/paste/jhkpp5vl)

---

## 作者：GGapa (赞：2)

##### [P6471 [COCI2008-2009#6] DOSTAVA](https://www.luogu.com.cn/problem/P6471)

感觉这道题有$\color{blue}蓝色$，管理员见到了可以顺手评一下，辛苦了。

初见这道题，很容易想到一种做法，对于从 $(x, y)$ 到 $(u, v)$，我们可以枚举中转行 $i$，分别枚举对应可能的情况，从 $i$ 的左端点进，还是从 $i$ 的左端点出。快速地写完代码，你发现你只得到了 40pts。

见如下 hack:

Input:

```
7 5
0 0 0 0 0
10 0 0 0 0
0 0 0 0 0
0 0 0 0 10
0 0 0 0 0
10 0 0 0 0
0 0 0 0 0
1
7 1
```

Output:

```
0
```

这道题最开始考虑的时候忽略了可能来回跑的情况，错误的思路只能得到 40pts。

------

既然这样可以来回跑，很容易联想到使用动态规划。

考虑对于每一个起始点使用动态规划，定义 $F(i, j)$ 代表从起始点到第 $i$ 行左边或者右边 $j =1/0$，的最小时间，时间复杂度为 $O(DR^2)$，不可过。

换一种思路，考虑 $F(i, j, a, b)$，代表从第 $i$ 行左边或右边到第 $j$ 行左边或右边 $(0/1)$，的最小花费，处理 $F$ 数组的时间复杂度为  $O(R^4)$，比刚刚还大，也不可做。

继续分析，你会发现绞尽脑汁想一个动态规划转移方程不如用学过的 Dijkstra，Dijkstra 的本身也是一个动态规划。

可以考虑全源 Dijkstra ，时间复杂度为 $O(R^2 \log R)$，理论可过。

> 实践是检验真理的唯一标准。

考虑如何建边，我们可以在每一行的端点之间互相连边，把这个问题转化成图，在每一行中间是不可以上下移动的，故可以把一整行除了端点转化成一条边。边权通过前缀和很容易在输入的时候处理出来。

点的编号如何确定？回到最开始的动态规划，$F(i, j)$ 可以代表一个点，二 $j\in[0, 1]$，故 $i \times 2 + j$ 即为点的编号。

对于每次询问，只需要通过常数复杂度枚举从哪一个端点开始，哪一个端点结束即可。

易错点： 

- 当 $x = u$ 的时候需要特殊处理。
- 在跑 Dijkstra 的时候并没有将起点的点权算入边权，但把终点的点权计入了边权，在最后枚举的时候需要注意。


[record](https://www.luogu.com.cn/record/160017170)

---

## 作者：封禁用户 (赞：0)

# 思路
考虑把这个二维数组转化成图，再使用 Dijkstra 来计算最短路。

把二维的转化成节点编号，在使每行每列的相邻两点都有一条边，从一开始跑 Dijkstra 就可以了。如果听不懂的可以看一眼下面的图，有点丑将就看吧。

**注意图中没有标，一定要双向建边，同时开二倍空间！**

![](https://cdn.luogu.com.cn/upload/image_hosting/xdm2fw36.png)

---


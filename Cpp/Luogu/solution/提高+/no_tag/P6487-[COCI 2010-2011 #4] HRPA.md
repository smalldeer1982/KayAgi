# [COCI 2010/2011 #4] HRPA

## 题目描述

有 $n$ 枚石子。两位玩家定了如下规则进行游戏：

- Mirko 先取一次，Slavko 再取一次，然后 Mirko 再取一次，两人轮流取石子，以此类推；
- Mirko 在第一次取石子时可以取走任意多个；
- 接下来，每次至少要取走一个石子，最多取走上一次取的数量的 $2$ 倍。当然，玩家取走的数量必须不大于目前场上剩余的石子数量。
- 取走最后一块石子的玩家获胜。

双方都以最优策略取石子。Mirko 想知道，自己第一次至少要取走几颗石子最终才能够获胜。

## 说明/提示

#### 样例 1 解释

对于这个样例，Mirko 第一次可以取 $1/2/3/4$ 个。虽然他取 $4$ 个会直接赢得比赛，但这并不是最少的。最少的方案是取走 $1$ 个。这样 Slavko 只能取走 $1$ 个或者 $2$ 个。无论选择哪种，Mirko 下一步都能取走所有的石子并获胜。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 10^{15}$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T6 HRPA***。

## 样例 #1

### 输入

```
4```

### 输出

```
1```

## 样例 #2

### 输入

```
7```

### 输出

```
2```

## 样例 #3

### 输入

```
8```

### 输出

```
8```

# 题解

## 作者：Push_Y (赞：21)

建议直接观看我博客中完整的[Fibonacci Nim](https://www.wzsyyh.ml/post/FibnacciNim/)

显然先手可以第一次直接取完获胜，但大多数情况下这么做并不是最少的。**下面我们考虑第一次不取完的情况**。

### 齐肯多夫（Zeckendorf）定理

Wikipedia 中对**齐肯多夫定理**的描述：

> 任何正整数都可以表示成若干个不连续的斐波那契数之和。

这种和式称为**齐肯多夫表述法**。

构造这种和式可以通过每次贪心选出最大的不超过它的斐波那契数。

#### 证明：

- 若正整数 $n$ 为斐波那契数，得证。

- 否则

    - 先取 $Fib_{t_1}$，其中 $t1$ 满足 $Fib_{t_1} < n < Fib_{t_{1} + 1}$。

    - $n'=n - Fib_{t_1}$，同上一步取出一个 $Fib_{t_2}$ 满足 $Fib_{t_2} < n' < Fib_{t_{2} + 1}$。

    - 只要证 $t_1 ≠ t_2 + 1$。考虑反证法：

        - 假设 $t_1 = t_2 + 1$，则第一步取出的应当是 $t_1 + 1$ 而不是 $t_1$。原因是 $Fib_{t_1 + 1} = Fib_{t_1} + Fib_{t_1 - 1}$。

### 解题

#### 引理 1

> 如果正整数 $n$ 为斐波那契数，则先手必败。

#### 证明：

设 $n = Fib_{t}$，我们把 $n$ 看成 $Fib_{t-1}$ 和 $Fib_{t-2}$ 两堆。

- 若第一步取的个数超过 $Fib_{t-2}$，则后手可以直接取完剩余石子。

- 否则，该问题变成了一个 $n' = Fib_{t-2}$ 的规模更小的同样的问题。

考虑 $n = 2$ 的情况（即规模最小的情况），先手只能取 $1$，于是后手取 $1$ 获胜。

#### 引理 2

> 如果正整数 $n$ 不为斐波那契数，则将其用**齐肯多夫表示法**表示后，最小的那一堆个数即为答案。

#### 证明：

$n = f_1 + f_2 + ... + f_k$

先手取完最小的那一堆（即 $f_k$）后，根据**齐肯多夫定理**，$f_{k-1} > 2 \times f_k$，于是后手无法一次性取完次小的那一堆。再根据**引理 1**，次小的一堆的最后一块石子一定还是由先手取到，于是先手一定能取到最大的那一堆的最后一块，即整堆石子的最后一块。

---

## 作者：dead_X (赞：9)

## 思路简述
~~自古博弈论靠手玩~~

经过大约 $10min$ 的手玩，你可以得到如下的一张表。

| $n$| $Min$|$n-Min$|
| -----------: | -----------: | ------:|
| $1$ | $1$ |$0$|
| $2$ | $2$|$0$|
| $3$ | $3$|$0$|
| $4$ |$1$ |$3$|
| $5$ |$5$|$0$|
|$6$  | $1$|$5$|
| $7$|$2$|$5$|
| $8$|$8$|$0$|
|$9$|$1$|$8$|
|$10$|$2$|$8$|
|$11$|$3$|$8$|
|$12$|$1$|$11$|
|$13$|$13$|$0$|
|$\cdots$|$\cdots$|$\cdots$

接着你开始在这张表上找规律。

注意到我多加上去的 $n-Min$ 这一栏，它有什么特别之处?

我们可以发现，$n-Min=0$ 时， $n$ 是斐波那契数列中的数。

然后再多打几项(受篇幅所限不列出来)

你会发现，这张表上还有一大片重复的序列。

观察这些重复的序列之间差的个数，你又会发现差的个数也是一个斐波那契数列中的数。

这时，你似乎发现这个序列和斐波那契数列有很大的关系……

你需要瞎蒙一个式子!

$$f(x)=
\begin{cases}
x& (x\in F)\\
f(x-t_{max})& (x\notin F,t_{max}\in F,t_{max}<x)
\end{cases}$$

其中 $F$ 代表斐波那契数列。

然后你发现这个式子是对的((((((

然后就过了!

证明目前还不会啦QAQ 会了就补上(((((
## Code
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,x,y,z;
	cin>>n;
	while(1)
	{
		if(n==1) return 0&puts("1");
		if(n==2) return 0&puts("2");
		x=1,y=2,z=3;
		while(z<n) x=y,y=z,z=x+y;
		if(z==n) return 0&printf("%lld",z); else n-=y;
	}
	return 0;
}
```

---

## 作者：jianhe (赞：8)

注：本文中出现的 $f$ 数组指的是斐波那契数列。（$f_0=f_1=1$，$f_i = f_{i-1}+f_{i-2}$）

### 第一次要取完石子的情况
~打表可知~当 $n$ 为斐波那契数时，第一次只能将石子取完。

证明采用[第二数学归纳法](https://baike.baidu.com/item/%E7%AC%AC%E4%BA%8C%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/4641553)。

---

令 $n \gets f_i$。

当 $i=2$ 时，结论明显成立。

---

假设 $i \le k-1$ 时结论成立。

由斐波那契数列性质得：$f_k=f_{k-1}+f_{k-2}$。

分类讨论第一次取的石子个数：

如果不超过 $f_{k-2}$，则问题变成了对于对手的 **非斐波那契数** 局面。基于假设，对手获胜。

如果超过 $f_{k-2}$，那么对手可以将剩下的石子取完。

---

由数学归纳法得结论成立。

---

### 第一次不用取完石子的情况
首先，我们要了解一条定理：
>任何一个正整数都可以表示成若干个 **不连续** 的斐波那契数之和。

它被称为[齐肯多夫定理](https://baike.baidu.com/item/%E9%BD%90%E8%82%AF%E5%A4%9A%E5%A4%AB%E5%AE%9A%E7%90%86/7612155)。

也就是说，对于任意一个正整数 $n$，有 $n=f_{j_1}+f_{j_2}+ \dots + f_{j_p}$。

不妨令 $j$ 数组单调递增。

由于不存在相邻的斐波那契数，所以 $f_{j_i}>2 \times f_{j_{i+1}}$。

那么第一次取 $f_{i_1}$ 个，对手无法取完 $f_{i_2}$，那我方取 $f_{i_2}$ 中剩下的石子。以此类推，可知我方一定能取到最后一堆石子。

因此答案即为 $f_{i_1}$。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,a,b,c;
void pr(ll x){cout<<x;exit(0);}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	while(n){
		if(n==1) pr(1);
		if(n==2) pr(2);
		a=1,b=2,c=3;
		while(c<n) a=b,b=c,c=a+b;
		if(c==n) pr(n);
		n-=b;
	}
	return 0;
} 
```

---

## 作者：SoyTony (赞：8)

# 斐波那契数列
为了简洁，用 $f_i$ 表示斐波那契数列的第 $i$ 项，递推式：
$$f_i=\begin{cases}
1&i\le 2\\
f_{i-1}+f_{i-2}&i>2
\end{cases}$$
# 齐肯多夫定理
对于任意一个正整数 $n$，都可以视作若干个不相邻的斐波那契数之和。

证明只需考虑 $n$ 不为斐波那契数的情况。

找到最大小于 $n$ 的斐波那契数 $f_i$，令 $n'=n-f_i$。

依次迭代下去，直到减完。

$n'$ 一定小于 $f_i$，否则 $n\ge 2f_i> f_{i+1}$，上面的假设就不成立了。这样由于前两项是 $1$，最终的结果也一定会是 $0$。

接下来证明不相邻，同样是用反证法，若存在两个数相邻，则可以直接表示为二者之后即 $f_{i+1}=f_i+f_{i-1}$，同样不符合假设。
# 斐波那契博弈
## 定义
一堆个数为 $n$ 的石子，两人交替取走一部分石子，取走数量必须多于 $0$ 且不超过上一人取走的 $2$ 倍。先手不能全部取走，取走最后一个石子的获胜。
## 判定结论
先手必胜当且 $n$ 不是斐波那契数。
## 证明
### 前置性质的推导
主要用到的是不等式加法，不断的放缩。
性质 $1$：
$$\because f_{i-1}<f_i<f_{i+1}$$
$$\therefore f_{i-1}+f_i=f_{i+1}<2f_i<f_i+f_{i+1}=f_{i+2}$$

性质 $2$：
$$\because f_{i+1}<2f_i$$
$$\therefore f_{i+1}+f_i=f_{i+2}<3f_i$$

性质 $3$：
$$\because f_i<f_{i+1}<3f_{i-1}$$
$$\therefore 4f_i<3f_{i-1}+3f_i=3f_{i+1}$$
### 对斐波那契数先手必败的证明
使用数学归纳法，$i\le 2$ 显然成立，假定 $i\le k$ 均成立，现在证对于 $i=k+1$ 同样成立。

先将 $f_{k+1}$ 看作 $f_{k-1}$ 与 $f_k$ 两部分。

设先手取 $x$ 个石子，后手取 $y$ 个石子。

若 $x\ge f_{k+1}$，由性质 $1$，取走个数的二倍已经超过剩余的石子，则后手可以一次取走，且个数不超过 $f_k$。

若 $\dfrac{f_{k-1}}{3}\le x<f_{k+1}$，此时后手一定可以将 $f_{k-1}$ 部分取完，即 $y=f_{k-1}-x\le \dfrac{2f_{k-1}}{3}$，那么下一次先手针对 $f_k$ 部分能取的最大数量为 $2y$。根据性质 $3$ 对比 $2y$ 与 $f_k$，得到 $2y\le \dfrac{4f_{k-1}}{3}<f_k$，则证明先手无法一次取完 $f_k$，那么变成 $f_k$ 局面的子问题，后手最后一次取完时个数也小于 $f_k$。

若 $x<\dfrac{f_{k-1}}{3}$，由性质 $2$，$x<\dfrac{f_{k-1}}{3}<f_{k-3}$，让后手用一定方法取完 $f_{k-3}$ 部分。这里就体现了博弈论中子问题以及归纳法的优美之处，后手取完 $f_{k-3}$ 方法的讨论又回到了前两种情况，讨论 $x$ 与 $f_{k-5}$ 的关系，如果 $x>f_{k-5}$，则 $y<f_{k-4}$ 显然成立，否则先处理好 $f_{k-5}$ 再去单独处理 $f_{k-4}$。而这些的策略都是我们已经假定成立的了。既然保证了 $f_{k-3}$ 部分后手最终取走个数不超过 $f_{k-4}$，也就保证了先手无法一次性取走 $f_{k-2}$，进而保证了后手处理 $f_{k-1}$ 时取走个数不超过 $f_{k-2}$，此时先手也就不难一次取走 $f_k$ 部分（也就是剩余全部石子）。

对上面这种情况再做概括：将 $f_{k+1}=f_{k-1}+f_k=f_{k-3}+f_{k-2}+f_{k}$，此时 $x<f_{k-3}$，意味着后手可以在取走 $f_{k-3}$ 时可以不超过 $f_{k-4}$，那么取走 $f_{k-1}$ 时也就不超过 $f_{k-2}$，自然也就可以后手取走 $f_{k}$，依此得证。
### 对不是斐波那契数情况先手必胜的证明
齐肯多夫定理给了一个优秀的抓手，我们可以划分成若干个不相邻的斐波那契数，而在极端情况下，从小到大取斐波那契数，取走 $f_i$ 这部分时，下一部分最小为 $f_{i+2}$，而 $2f_i<f_{i+2}$。

这里先手的策略是，拆分后取走最小的斐波那契数，后手面对下一个斐波那契数没有办法一次取走，取完这个部分的仍旧是先手，依次直到石子全部取走。



---

## 作者：lmaz (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6487)

~~话说回来《博弈论》这本书挺好看的~~

---


# 前置知识
__斐波那契数列（Fibonacci sequence）__

表达式如下：

$ f(x) = \begin{cases}
  0 & x = 0\\
  1 & x = 1 \\
  f(x-1)+f(x-2) & x \ge 2
\end{cases} $

__斐波那契博弈（Fibonacci Nim）__

定义：斐波那契博弈，又称为 Zeckendorf 游戏，是一个两人轮流进行的游戏。游戏开始时，有一堆共有 $n$ 个物品。玩家轮流从中取物，每次至少取一个，最多可以取走前一次取物数量的两倍。首次取物时没有限制，谁取走最后一个物品，谁就获胜。（和本题一样，并没有特别的更改。）~~在这里不过多叙述，想看证明的可以看下[这篇文章](https://www.cnblogs.com/tttkf/p/15895646.html)。~~

__齐肯多夫定理（Zeckendorf theorem）__

定义：任何正整数都可以表示成若干个不连续的斐波那契数（不包括第一个斐波那契数）之和，这种和式称为齐肯多夫表述法。

值得一提的是：对于任何正整数，其齐肯多夫表述法都可以由贪心算法（即每次选出最大可能的斐波那契数）得到。代码实现如下：

```cpp
#include<cstdio> 
int n;
int maxfib(int n){
    if(n==0||n==1)return n;
    int a=0,b=1,c=1;
    while(c<=n){
        a=b;
        b=c;
        c=a+b;
    }//实现fib数列 
    return b;//b是小于n的最大fib数 
}
int main(){
    scanf("%d",&n);
    while(n){
        int t=maxfib(n);
        printf("%d+",t);
        n-=t;
    }
 	return 0;
}
```
这里不过多阐述了，想知道证明可以看[这篇](https://baike.baidu.com/item/%E9%BD%90%E8%82%AF%E5%A4%9A%E5%A4%AB%E5%AE%9A%E7%90%86/7612155)。

# 本题思路
根据上面的知识，想必你已经知道这道题目怎么写了吧。博弈的题目一般都可以通过试试找到一般规律。斐波那契博弈的规律是：**先手胜当且仅当n不是斐波那契数** 。

比如说本题中 $ n=114 $ 时，经过齐肯多夫表述为 $ 114=89+21+3+1 $ 。根据上面的规律，Mirko 可以先取 1 颗，剩下 113 颗，不是斐波那契数，所以 Slavko 必败，因为无论 Slavko 取什么数，Mirko 都可以根据 Slavko 所取的数来选择，让每次 Slavko 都只能遇上非斐波那契数最终获得胜利。

**所以，本题我们只用输出 $n$ 用齐肯多夫表述法表达后最小的数就行了。**

# 代码分享

__注意数据类型，可能会炸 int，所以记得开 long long。__


```C++
#include<cstdio>
#define int long long
int n,a,b,c;
signed main(){
	scanf("%lld",&n);
	while(n){
        a=0,b=1,c=1;//斐波那契前三项
		while(c<=n)c=a+b,a=b,b=c;//斐波那契数列的实现
		n-=a;
	}
    printf("%lld",a);//当上面的while终止时，a的值就是最小的数了
	return 0;
}
```



---

~~完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。~~

~~蒟蒻题解，若有错误请指出，大谢！最后，求个点赞啊！~~

---

## 作者：Confused_Konjac (赞：2)

你说得对，《博弈论》确实是一本很好看的书。

在这个问题中，我们显然可以第一次就拿走所有石子，但这当然 **不是最优解** ，我们来考虑一下**第一次不取完的情况**：

### 齐肯多夫 （Zeckendorf） 定理
 deepceek 对齐肯多夫定理的定义是：
> 任何正整数都可以唯一分解为若干个不连续的斐波那契数之和。
### 证明
这里我们采用反证法证明

#### 1. 假设不唯一：
设 $n$ 是最小的有两种不同表示的正整数：

  - $n = F_{a_1} + F_{a_2} +  + F_{a_k} ( a_1 > a_2 > … > a_k, | a_i - a_j | \ge 2 )$ 。

   - $ n=F_{b_1} + F_{b_2} + … + F_{b_l} ( b_1 > b_2 > … > b_k, | b_i - b_j | \ge 2 ) $ 。

#### 2.分析最大项：
- 若两种表示的最大项相同（即 $ F{a_1} = F{b_1} $）, 则对 $ n - F{a_1} $ 有两种表示，与 $n$ 是最小矛盾数矛盾。
- 若最大项不同（不妨设 $F{a_1} > F{b_1}$ ）,则
  
  $ n \ge F{a_1} > F{b_1} + F{b_2} + … + F{b_l} = n $
  
矛盾（因为 $ F{b_1} $ 这后的斐波那契数之和小于 $ F{b_1} $ ,而 $ F{b_1} < F{a_1}$ 。

#### 3. 结论
最大项必须相同，递归至剩余部分，唯一性得证。

所以我们突然灵光一现就有了**思路**:

首先预处理斐波那契数列，找到不超过n的最大斐波那契数 $ F_k $；然后计算  Mirko  首次最少取石量 $ n-F_k $ ，确保剩余 $ F_k $ 进入对手必败态（此时对手任何操作 Mirko 均可对称应对或直接取光剩余石子获胜）；最后处理边界情况，当 n 本身为斐波那契数时需直接取光。

得出代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
    int n;
    cin>>n;
    int a,b,c;
    while(n)
    {
        a=1,b=1,c=2;
        while(c<=n)
        {
            c=a+b;
            a=b;
            b=c;
        }
        n-=a;
    }
    cout<<a;
    return 0;
}//不开 longlong 会爆掉哦
```
蒟蒻的第一篇题解，dalao们轻点喷。

---

## 作者：pengyirui (赞：2)

蒟蒻又来水题解了！
# 前置芝士
## 斐波那契数列
斐波那契数列，是指除了第一、二项以外每一项都是前两项之和的序列。    
$$f_{i}=f_{i-1}+f_{i-2}(i>2)$$    
此外，$f_{0}=0,f_{1}=1,f_{2}=1$。
## 奇肯多夫定理
对于所有正整数，可以分解为若干个**不相邻的**斐波那契数的和。（**不相邻的**很重要，待会儿我们会用到，请大家牢记）    
因为本人是个蒟蒻，所以不会证明，建议去看[这里](https://baike.baidu.com/item/%E9%BD%90%E8%82%AF%E5%A4%9A%E5%A4%AB%E5%AE%9A%E7%90%86/7612155#2)。
# 思路
好的，现在我们进入正题。首先，我们需要明确的是这个题目是一个典型的博弈论题目，名字叫做斐波那契博弈。    
接下来详细讲一下这个东西。     
## 博弈定义
本题题目，请自行阅读。
## 实现方法
1. 将 $n$ 使用奇肯多夫定理分解为斐波那契数列中数字的和;
2. 寻找最小的斐波那契数，然后输出。
3. 算法结束。

来，让我们详细说一下第二步，为什么可以这么玩呢？   
仔细想一想，斐波那契数列的第 $i$ 项的两倍一定不小于第 $i+j(j>1)$ 项。（自行计算验证即可）   

那么，Mirko 从小的开始取，则 Slavko 永远不可能一次性取完下一堆。（在上一段已经证明）      

所以，最优策略是取最小的。

好的，于是代码来了！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
    int n;
    cin>>n;
    int a=1,b=1,c=2;
    while(n)
    {
        a=1,b=1,c=2;
        while(c<=n)c=a+b,a=b,b=c;
        n-=a;
    }
    cout<<a;
    return 0;
}
```
各位注意，别忘了开 long long 哟！（可自行尝试，后果自负）

---

## 作者：Vct14 (赞：1)

斐波那契博弈模版题。用 $f_i$ 来表示第 $i$ 个斐波那契数（$f_1=f_2=1$，对于 $i\ge3$，$f_i=f_{i-1}+f_{i-2}$）。

---



引理 $1$：

> 当 $n$ 为斐波那契数时，若先手不一次取完，则后手可以取到最后一块石子。

证明：

设 $n=f_i$。由 $n\ge2$，$i\ge3$。

若 $i=3,4$，即 $n=2,3$ 时，显然后手必胜。

假设命题对任何小于 $i$ 的正整数都成立（$i\ge5$）。下证命题对 $i$ 也成立。

设先手第一次取走 $k$ 个石子。那么：

- $k\ge f_{i-2}$，那么由 $n-k\le n-f_{i-2}=f_{i-1}\le2f_{i-2}\le 2k$，后手可以一次取完。
- $k<f_{i-2}$。我们把这 $n$ 块石子分为 $f_{i-1}$ 和 $f_{i-2}$ 两堆。因为 $i-2<i$，由归纳假设，后手可以取到 $f_{i-2}$ 这堆的最后一块石子。此时还剩 $f_{i-1}$ 块石子，仍该先手取。同样地，因为 $i-1<i$，由归纳假设，后手可以取到最后一块石子。命题成立。

综上所述，由第二数学归纳法，原命题成立。

---


引理 $2$：

> 齐肯多夫定理。任何正整数 $n$ 都可以表示成除 $f_1=1$ 外的若干个不连续的斐波那契数之和。这样的和式被称为“齐肯多夫表述法”。

证明：

当 $n=1,2,3$ 时，由 $f_2=1,f_3=2,f_4=3$，命题成立。

假设命题对任何小于 $n$ 的正整数数都成立（$n\ge4$）。下证命题对 $n$ 也成立。

- 若 $n$ 是斐波那契数，则显然命题成立。
- 若 $n$ 不是斐波那契数，设 $i_0$ 是满足 $n>f_{i_0}$ 的最大正整数。设 $n^\prime=n-f_{i_0}$，则 $n^\prime<n$，由归纳假设，$n^\prime$ 可以被表示成除 $f_1=1$ 外的若干个不连续的斐波那契数之和，即 $n^\prime=f_{i_1}+f_{i_2}+\cdots+f_{i_k}$，其中 $i_1>i_2>\cdots>i_k$ 为不连续的整数。有 $f_{i_1}<n^\prime=n-f_{i_0}<f_{i_0+1}-f_{i_0}=f_{i_0-1}$，所以 $i_1<i_0-1$，即 $i_0$ 和 $i_1$ 是不连续的整数。因此 $n=f_{i_0}+f_{i_1}+f_{i_2}+\cdots+f_{i_k}$，其中 $i_0>i_1>i_2>\cdots>i_k$ 为不连续的整数。

综上所述，由第二数学归纳法，齐肯多夫定理对任何正整数 $n$ 都成立。

---

引理 $3$：

> 对于一个整数 $x\ge2$，设 $i$ 是满足 $f_i\ge x$ 的最小正整数。对于任意 $k\ge i+2$ 都有 $2x<f_k$。

证明：$2x\le2f_i<f_i+f_{i+1}=f_{i+2}\le f_k$。

---



由引理 $2$（齐肯多夫定理），将 $n$ 块石子分为若干堆，其中每一堆石子的个数递增且均为不连续的斐波那契数。

对于较大的 $n-1$ 堆，由引理 $1$，只要后手 Slavko 先取且不一次取完，先手 Mirko 一定可以取到该堆的最后一块石子。

因此 Mirko 只需先手取完第一堆即可。由引理 $3$，由于 Mirko 每一堆最后一次取的数量小于该堆数量，所以 Slavko 一定无法直接取完下一堆。那么下一堆仍由 Slavko 先取且无法一次取完。于是 Mirko 一定能取到最大的一堆石子的最后一块，即这 $n$ 块石子的最后一块。

因此本题答案即为用齐肯多夫表述法表示 $n$ 后最少的一堆石子的数量。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	long long n;cin>>n;long long lst=0;
	while(n>0){
		long long a=0,b=1,c=1;//f_0,f_1,f_2
		while(c<=n){
			c=a+b;
			a=b;b=c;
		}
		n-=a;lst=a;
	}
	cout<<lst;
	return 0;
}
```

代码中用到了每次取出最大的不大于 $n$ 的斐波那契数组成的式子一定是 $n$ 的齐肯多夫表述法的结论。这个结论可以用反证法证明。假设取出的数中存在连续的斐波那契数，设其中最大的为 $f_i$ 和 $f_{i+1}$，那么一定没有取出 $f_{i+2}$（否则与“最大”矛盾）。又 $n>f_i+f_{i+1}=f_{i+2}$，因此一定选出了 $f_{i+2}$。矛盾。即证。

---

## 作者：xukehg (赞：1)

分享一个莫名其妙的方法。

首先，打张表观察规律：
```
1 1
2 2
3 3
4 1
5 5
6 1
7 2
8 8
```
然后我们发现一个事情：

**如果** $n$ **为斐波那契数，则先手只能取完所有石子。**

与此同时，我们发现好像数列有重复的部分，于是，我们以斐波那契数为分割点分割数列，将前 $n$ 个数的答案分成若干个数列，举例如下：
```
1
1 2
1 2 3 1
1 2 3 1 5 1 2
```

然后我们就会发现：**每一个被分割出来的数列，均为前一个数列拼上第数列序号减一个斐波那契数然后再拼上上个数列。**

很明显，我们有一个分治的方法：判断序号在数列的具体位置，即究竟是在拼凑数列的哪一个部分，一步步递归到特定的序列，即作为斐波那契数被加入序列时，很明显，那时序号在数列中的位置是斐波那契数。

另外，想法具体证明戳[这里](https://www.luogu.com/article/xlfpc96z)。

综上，我们有以下代码：
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e2 + 5;

int n,len = 1;
unordered_map<int,int> summ;
int lent[N],sum2[N]; 
void solve(int noww,int step){
	if (summ[noww] != 0){
		cout << noww << endl;
		exit(0);
	}
	if (noww < lent[step - 1]) solve(noww,step - 1);
	else solve(noww - lent[step - 1] - 1,step - 2);
}
signed main(){
	scanf("%lld",&n);
	summ[1] = 1;
	sum2[0] = 1;
	int pre = 1,noww = 1;
	int i = 1;
	for (i = 1;lent[i - 1] < n;i++){
		int t = noww;
		noww = pre + noww;
		pre = t;
		summ[noww] = 1;
		sum2[i] = noww;
		lent[i] = lent[i - 1] + lent[i - 2] + 1;
		len++;
	}
	solve(n,i - 1);
}
```
由于斐波那契数列增长极快，所以实际上复杂度很低，约为 $\log n$ 级别。

---

## 作者：cyx0411 (赞：0)

显然，第一次取完可以使先手必胜，但是第一次取完可能并不是本题的最优解。所以我们可以采用了第二种方案：斐波那契博弈。

首先，我们要了解**齐肯多夫定理**：

> 任何正整数都可以表示成若干个不连续的斐波那契数之和。

把若干个不连续的斐波那契数之和所表示的数叫做**齐肯多夫表示法**。

~~根据打表~~我们发现：

- 如果 $n$ 是斐波那契数，那么先手只能取完所有石子才能获胜。
- 如果 $n$ 不是斐波那契数，那么每次就会拼上第序列号个斐波那契数在拼上第序列号减二个序列。

然后，我们就可以逐次将 $n$ 减少一个比 $n$ 小且最大的斐波那契数，直到将 $n$ 减成一个斐波那契数为止。

所以，我们得出代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n;
	cin>>n;
	while(1){
		if(n==1||n==2){
			cout<<n;
			return 0;
		}
		int a=1,b=2,c=3;
		while(c<n){
			a=b;
			b=c;
			c=a+b;
		}
		if(c==n){
			cout<<n;
			return 0;
		}
		else{
			n-=b;
		}
	}
	return 0;
}

```

---

## 作者：hjqhs (赞：0)

学习了一下[这篇文章](https://blog.csdn.net/dgq8211/article/details/7602807)。  
如果 $n$ 是斐波那契数则先手必败，根据齐肯多夫定理，任何正整数可以表示为若干个不连续的斐波那契数之和。因为要求一个最小石子数量，所以每次 $n$ 都减去一个 $\le n$ 且最大的斐波那契数，直到 $n$ 本身是一个斐波那契数时即可。

---

## 作者：Wanderer_01 (赞：0)

## 题意：

$n$ 个石子两人依次取，先手第一次可取若干个，此后每次仅能取不超过上一次的 $2$ 倍的石子，取走最后一块石子即获胜，求先手想保证胜利第一次至少取多少石子。

显然，先手必胜，因为先手可一次全取完，但不一定最少。因此下面只考虑不取完的情况。

考虑除第一次外每次仅能取不超过上一次的 $2$ 倍的石子，可联系到齐肯多夫定理。

由**齐肯多夫定理**可知：

任何正整数都可以表示成若干个不相邻的斐波那契数之和，即 $n$ 可表示为 $\displaystyle n=\sum_{i=1}^kfib_{a_i}$。

这有什么用呢？

若 $n$ 为斐波那契数，$n=fib_{i}$：

$n=fib_i=fib_{i-1}+fib_{i-2}$，若先手取的石子大于等于 $fib_{i-2}$
则后手一定可以取到小于等于 $fib_{i-1}$ 个石子。

此时可将 $n$ 缩小范围至 $fib_{i-2}$。以此类推，可将 $n$ 缩小到 $2$ 或 $3$。

当 $n=2$ 时，先手取 $1$ 个石子，后手可取完剩下的 $1$ 个石子。

当 $n=3$ 时，先手取 $1$ 个石子，后手可取完剩下的 $2$ 个石子。先手取 $2$ 个石子，后手可取完剩下的 $1$ 个石子。

故此时先手必然全取完。

若 $n$ 不为斐波那契数，$\displaystyle n=\sum_{i=1}^kfib_{a_i}$。

令 $fib_{a_1}<fib_{a_2}<\cdots<fib_{a_k}$。

此时只需取出 $fib_{a_1}$ 个石子即可保证先手必胜。

证明：

若 $n-fib_{a_1}$ 为斐波那契数，因为斐波那契数列互不相临，$n-fib_{a_1}>2fib_{a_1}$，所以后手不可取完所有石子，故后手比败。

若 $n-fib_{a_1}$ 不为斐波那契数，因为斐波那契数列互不相临，$fib_{a_2}>2fib_{a_1}$，后手取完后剩下的石子数必不为斐波那契数，可以继续用斐波那契数列表示。

## 结论：

把 $n$ 表示为 $\displaystyle n=\sum_{i=1}^kfib_{a_i}$，其中 $fib_{a_1}<fib_{a_2}<\cdots<fib_{a_k}$。

先手第一次至少取出 $fib_{a_1}$ 个石子。

最后附上丑陋的代码。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
long long tp,fib[10000];
long long read(){
	long long x=0,f=1;
	char ch=getchar();
	while(ch<'0'||'9'<ch){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
	return x*f;
}
int main(){
	n=read();
	fib[++tp]=1,fib[++tp]=2;
	while(fib[tp]+fib[tp-1]<=n){
		tp++;
		fib[tp]=fib[tp-1]+fib[tp-2];
	}
	while(n){
		while(fib[tp]>n) tp--;
		n-=fib[tp];
		if(!n) printf("%lld",fib[tp]);
	}
}
```

---


# [COCI 2015/2016 #1] TOPOVI

## 题目描述

这里有一个 $n\times n$ 的棋盘，棋盘上有 $k$ 个棋子，每个棋子有一个武力值 $w_i$。

我们做出如下规定：
- 一个棋子的攻击范围是它所在的这一行与这一列，不包括它自己。
- 一个棋盘上的单元格可以被攻击，当且仅当能攻击到它的所有棋子的武力值的异或和大于 $0$。

现在我们会进行 $p$ 次操作，请求出每次操作后会被攻击到的格子总数。

## 说明/提示

#### 数据范围及限制
- 对于 $25\%$ 的数据，保证 $n,k\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^9$，$1\le k\le 10^5$，$1\le p\le 10^5$，$1\le x_i,y_i,r_1,c_1,r_2,c_2\le n$，$1\le w_i\le 10^9$，在移动过程中棋子不会重叠。

#### 说明
**本题满分 $120$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T4 TOPOVI。

## 样例 #1

### 输入

```
2 2 2
1 1 1
2 2 1
2 2 2 1
1 1 1 2 
```

### 输出

```
4
0 ```

## 样例 #2

### 输入

```
2 2 2
1 1 1
2 2 2
2 2 2 1
1 1 1 2 
```

### 输出

```
4
2```

## 样例 #3

### 输入

```
3 3 4
1 1 1
2 2 2
2 3 3
2 3 3 3
3 3 3 1
1 1 1 2
3 1 3 2 
```

### 输出

```
6
7
7
9```

# 题解

## 作者：Orange_qwq (赞：15)

[题目链接](https://www.luogu.com.cn/problem/P6532)

## 题意解释

“棋子的攻击方式与中国象棋里的車的攻击方式无异。”的意思是，一个棋子的攻击范围是它所在的这一行与这一列，不包括它自己。（这一点有亿些迷惑）

## 题目分析

看到异或，必须很敏感地想到 **一个数 异或 他自己 等于 $0$**，在这道题目中相当于没异或。

进而可以想到：一个单元格所受到攻击会等于这一行的异或和 异或 这一列的异或和，无需考虑这个单元格是否有棋子，棋子是否会攻击自己。因为无论是单元格还是棋子，都会异或两次，相当于没异或。

这样一来，每次放棋子就是在那个格子上异或棋子的武力值，每次移动棋子就是在棋子原来的位置再次异或这个棋子，并在移动的目标位置异或这个棋子。每次操作都可以转换为放棋子的操作了捏。

对于每一次修改答案，求会被攻击到的格子数，就是求总格子数减掉不会被攻击到的格子数。询问有后效性，故每一次的结果可以递推：上一次询问的结果 $-$ 这一次移动格子所减少的被攻击的 $+$ 这一次移动所增加的被攻击的。

怎样求增加或减少被攻击的格子数捏？

考虑每一个格子会给这一行和这一列带来影响，可以开个桶，按每行每列分开统计有多少个。每一次操作，修改该行和该列原来的桶，修改异或值，修改新的异或值的桶。

总的梳理一下思路。对于每次操作：

+ 放置棋子
+ 修改桶的值
+ 修改答案

这样，每次操作可以 $O(1)$ 解决了！

## 注意

+ 此题储存答案的变量需要开 `ll`。

+ 数据较大，需要离散化，也可以用 `map` 或 `unordered_map` 解决。

+ `map` 时间复杂度较大，需要用 `unordered_map`，也可以加快读。

## $\texttt{AC Code}$

```cpp
#include <bits/stdc++.h> 
using namespace std;

int n, k, q;
long long ans;
unordered_map < int, int > rcnt, ccnt, rxor, cxor;
map < pair < int, int > , int > rook;
  // rcnt 和 ccnt 是桶
  // rxor 和 cxor 表示行和列的异或和
  // rook 表示棋盘

void move(int _r, int _c, int _v) { // 减去减少的，加上增加的，就是改变量
	ans = ans - (n - ccnt[rxor[_r]]) - (n - rcnt[cxor[_c]]);
  // 因为第 r 行增加一个棋子，原来与第 r 行相交的能被控制的格子现在不能了，需要减去原来能控制的数目
	if (rxor[_r] != cxor[_c]) ++ans;// 所在格子如果原来是被控制的，则多减去一次，需要加回来
	
	--rcnt[rxor[_r]], rcnt[rxor[_r] ^= _v]++;
	--ccnt[cxor[_c]], ccnt[cxor[_c] ^= _v]++;
	
	ans = ans + (n - ccnt[rxor[_r]]) + (n - rcnt[cxor[_c]]);
  // 更新以后，新增加控制的要加上
	if (rxor[_r] != cxor[_c]) --ans; // 加多了要减
	rook[make_pair(_r, _c)] ^= _v;
}

int main() {
	scanf("%d%d%d", &n, &k, &q);
	rcnt[0] = ccnt[0] = n;
	for (int i = 1, _r, _c, _v; i <= k; ++i) {
		scanf("%d%d%d", &_r, &_c, &_v);
		move(_r, _c, _v);
	}
	int _r1, _r2, _c1, _c2, rov;
	while (q--) {
		scanf("%d%d%d%d", &_r1, &_c1, &_r2, &_c2);
		rov = rook[make_pair(_r1, _c1)];
		move(_r1, _c1, rov);
		move(_r2, _c2, rov);
		printf("%lld\n", ans);
	}
	return 0;
}
```

最后，祝 **CSP2022 RP++**！

---

## 作者：Feyn (赞：7)

[link](https://www.luogu.com.cn/problem/P6532) & [博客园食用](https://www.cnblogs.com/dai-se-can-tian/p/16491138.html)

建议管理大大把这道题评蓝。理由：运用了异或的性质。

首先考虑每个棋子对哪些格子造成影响。显然对于所有与它同行同列且不和它重合的格子，加入这个棋子会使得这些格子的权值异或上这个棋子的权值。但题目中说明了棋子不会对自己的格子造成任何影响，而我们知道任何数异或自己等于零，所以这个没有影响可以看成是当前格子的权值异或了两次棋子的权值。那么就可以总结出放置棋子的影响：该棋子先使得所在行的所有元素异或它的权值，然后再使所在列的所有元素异或它的权值。只需要获知每一列和每一列对应的值，异或起来就是对应格子的权值了。

然后考虑每一行对答案的影响。假如有一行，这一行上所有元素都异或了 $a_i$ ，那么这一行的元素 $A_{i,j}$ 非零当且仅当 $a_i\oplus b_j\ne 0$ ，而一行总共有 $size$ 个元素，那么这一行非零的元素的数量可以表示为 $num=size-\sum\limits_j^{size}[a_i\oplus b_j=0]$ ，即是矩阵大小减去恰好等于 $a_i$ 的 $b_j$ 的个数。统计某个值出现了多少次可以使用 map 来做。

整理一下这道题的流程。每放置一个棋子就给对应的行和列异或上它的权值，然后统计这次放置对答案的影响。新的答案应该是旧的答案减去放置之前这一行和列上非零元素的个数再加上放置之后非零元素的个数（因为其它地方不会受到这个棋子的影响，所以统计这行和这列的答案即可）。至于移动棋子，可以看成是添加两个棋子（对于原位置来说，把它赋值为 $0$ 等价于再异或上一次它本身），重复上面的操作即可。至于统计答案可以直接用上一段所说的方法来快速统计。数据范围很大，要用 map 来存储各种信息，所以复杂度为 $O(N\log N)$ 。

代码有注释，大佬轻喷。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define ll long long
using namespace std;
inline void read(int &wh){
	wh=0;int f=1;char w=getchar();
	while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
	while(w>='0'&&w<='9'){wh=wh*10+w-'0';w=getchar();}
	wh*=f;return;
}

struct node{int x,y;};
inline bool operator <(node s1,node s2){
	return s1.x==s2.x?s1.y<s2.y:s1.x<s2.x;
}
map<node,int>val;

int size,m,n;
map<int,int>a,b;//每行、每列具体的值
map<int,int>ta,tb;//每个值对应的数量
ll ans; 

inline void work(int s1,int s2,int s3){//给s1行和s2列的所有元素异或s3并更新答案 
	int aa=a[s1],ab=b[s2];
	ans-=size-tb[aa];ans-=size-ta[ab];//去掉这一行和这一列所有的非零元素 
	if(aa^ab)ans++;//考虑这个格子是否重复计算 
	ta[aa]--;tb[ab]--;//原来的值就少了一个 
	aa^=s3;ab^=s3;ta[aa]++;tb[ab]++;//现在的值多了一个 
	ans+=size-tb[aa];ans+=size-ta[ab];//加上这一行和这一列的非零元素 
	if(aa^ab)ans--;
	a[s1]=aa;b[s2]=ab;//更新行和列的值 
}

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(size);read(m);read(n);
	int s1,s2,s3;
	ta[0]=tb[0]=size;
	for(int i=1;i<=m;i++){
		read(s1);read(s2);read(s3);
		val[(node){s1,s2}]=s3;//更新这个位置的值 
		work(s1,s2,s3);//给这个位置加上一个棋子 
	}
	while(n--){
		read(s1);read(s2);
		int data=val[(node){s1,s2}];
		work(s1,s2,data);
		read(s1);read(s2);
		work(s1,s2,data);//移动相当于是添加了两个棋子 
		val[(node){s1,s2}]=data;//更新当前位置的值 
		printf("%lld\n",ans);
	}
	
	return 0;
}
```

---

## 作者：crh1272336175 (赞：6)

版权申明：本题解只是转载，版权属于我的教练

用map记录每一行xv[i]的值，每一列yv[j]的值，以及行值为v的数量，列值为v的数量

当(x,y)位置上去掉v值时，本质上跟加上v值是一样的，会让xv[x]->xv[x]^v，yv[y]->yv[y]^v

那么x行上列值为xv[x]的点会从不被攻击变成被攻击，列值为xv[x]^v的点会从被攻击变成不被攻击

同样y列上行值为yv[y]的点会从不被攻击变成被攻击，行值为yv[y]^v的点会从被攻击变成不被攻击

需要注意的是(x,y)这个点要判断，是否被计算了2次，如果是的话，要减去1次

初始的时候行值为0以及列值为0的数量为n,其余数量都是0

这样，每次移动棋子，就可以O(1)时间算出答案

代码：

```cpp
#include<bits/stdc++.h>
#pragma GCC opitimize(2)
using namespace std;
const int N=1e5+5;
typedef long long ll;
int n,k,p;
ll ans;
unordered_map<int,int> xv,yv;
unordered_map<int,int> xcnt,ycnt;
map<pair<int,int>,int> pos;
void solve(int x,int y,int w)
{
	ans-=n-ycnt[xv[x]];
	ans-=n-xcnt[yv[y]];
	if(xv[x]!=yv[y]) ans++;
	xcnt[xv[x]]--; xv[x]^=w; xcnt[xv[x]]++;
	ycnt[yv[y]]--; yv[y]^=w; ycnt[yv[y]]++;
	ans+=n-ycnt[xv[x]];
	ans+=n-xcnt[yv[y]];
	if(xv[x]!=yv[y]) ans--;
	pos[{x,y}]=w;
}
int main()
{
	scanf("%d%d%d",&n,&k,&p);
	xcnt[0]=ycnt[0]=n;
	while(k--)
	{
		int x,y,w; scanf("%d%d%d",&x,&y,&w);
		solve(x,y,w);
	}
	while(p--)
	{
		int x1,y1,x2,y2; scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		int w=pos[{x1,y1}];
		solve(x1,y1,w);
		solve(x2,y2,w);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：_yolanda_ (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P6532)

[博客园食用更佳](https://www.cnblogs.com/yolanda-yxr/p/16492031.html)

## 题目分析

又是考试遇到的，考场完全没思路，只写了暴力。

这道题其实不难，没有那么难想，但也不是那么的不好想。

转化以下题意，其实就是每行的异或和与每列的异或和有多少对相等（因为冲突即不等，就是总的减去等的）。

再想，其实最终答案只与值和行还是列有关，与哪些地方是这些值无关，所以可以用类似桶的东西来存这个值有多少个。

又由于这个值会很大，可以用 map 来存：`lv[i]` 表示值为 `i` 的行数是多少，列同理。

现在求值很方便了，但是还有修改啊。（这里讲的是把一个格子所在行列异或一个值）

自然而然就可以想到同样用 map 来存每行和每列当前的异或和，修改时将之前的值对应个数减一，新值加一，同时修改对应行列的值。

那答案的修改呢？

以行为例：当前值的贡献是与其值相同的列的个数（就是之前统计的那个）。这样就可以减去之前值得贡献再加上新的值得贡献来得到答案了。

还有一个小细节：在计算贡献时，如果这个点的行列值相同，会算两次。可以特判解决，但没必要。异或之前相等，那异或之后也相等，减的时候多减了一次，那加的时候也会多加一次就抵消了。

还有一个问题就是这个格子的值不会修改，但直接整行整列异或不会出问题吗？——不会，因为最后判断这个格子是否有冲突是行异或列，而行和列都异或过当前格子的值，异或两次就等于没有异或。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define map unordered_map

const int N=2e5+5;
map<int,int> l,r;
map<int,int> lv,rv;
map<int,int> mp;
int ans;

inline int read(){
	int sum=0,f=1;char a=getchar();
	while(a<'0' || a>'9'){if(a=='-') 	f=-1;a=getchar();}
	while(a>='0' && a<='9') 	sum=sum*10+a-'0',a=getchar();
	return sum*f;
}

void change(int x,int y,int z){//修改这个点的值
//	if(l[x]==r[y])	++ans;//两个特判，都可以不用（当然不能只用一个啊）
	ans-=lv[r[y]]+rv[l[x]];
	lv[l[x]]--,rv[r[y]]--;
	l[x]^=z,r[y]^=z;
	lv[l[x]]++,rv[r[y]]++;
	ans+=lv[r[y]]+rv[l[x]];
//	if(l[x]==r[y])	--ans;
}

signed main(){
	
	int n,k,p;
	n=read(),k=read(),p=read();
	
	lv[0]=rv[0]=n;
	ans=n*n;
	
	int x,y,z;
	for(int i=1;i<=k;++i){
		x=read(),y=read(),z=read();
		change(x,y,z);
		mp[(x-1)*n+y]=z;
	}
	while(p--){
		int r1,r2,c1,c2;
		r1=read(),c1=read(),r2=read(),c2=read();
		change(r1,c1,mp[(r1-1)*n+c1]);
		mp[(r2-1)*n+c2]=mp[(r1-1)*n+c1];
		mp[(r1-1)*n+c1]=0;
		change(r2,c2,mp[(r2-1)*n+c2]);
		printf("%lld\n",(int)(n*n-ans));
	}
	
	return 0;
} 
```

---

## 作者：yanbinmu (赞：0)

## P6532 [COCI 2015/2016 #1] TOPOVI

### 分析

如果一个点不可以被攻击，那么**列异或和**异或**行异或和**为 0。

即如果对于一行来看，如果这一行所有元素都异或上了 x，那么不可以被攻击到的点的个数就是**异或和为 x 的列数**。

那么如果加入修改，那么我们可以用 map 维护某一异或和对应的列数或行数，然后每次改变时更新。

那么就很好实现了。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

unordered_map<int, ll> rxor, cxor, rcnt, ccnt;
map<pair<int, int>, int> mp;

int n, k, p;
ll ans = 0; // 可以被攻击到的点

void update(int x, int y, int w) {
    int R, C;
    R = rxor[x], C = cxor[y];
    ans -= n - rcnt[C] + n - ccnt[R];
    if (R ^ C) ans++;
    rcnt[R]--;
    ccnt[C]--;
    rxor[x] ^= w;
    cxor[y] ^= w;
    R = rxor[x], C = cxor[y];
    rcnt[rxor[x]]++;
    ccnt[cxor[y]]++;
    ans += n - rcnt[C] + n - ccnt[R];
    if (R ^ C) ans--;
    mp[{x, y}] ^= w;
}

int main() {
    cin >> n >> k >> p;
    rcnt[0] = ccnt[0] = n;
    for (int i = 1;i <= k;i++) {
        int x, y, w;
        cin >> x >> y >> w;
        update(x, y, w);
    }
    for (int i = 1;i <= p;i++) {
        int r1, r2, c1, c2;
        cin >> r1 >> c1 >> r2 >> c2;
        int w = mp[{r1, c1}];
        update(r1, c1, w);
        update(r2, c2, w);
        cout << ans << "\n";
    }
    return 0;
}
```

---


# [COCI 2010/2011 #2] LUNAPARK

## 题目描述

Mirko 对所有书籍都感到了厌倦，因此尽管他不喜欢玩过山车，他还是决定和朋友一起去游乐园。 当他的朋友们度过美好的时光时，Mirko 则坐在长椅上，等待着并思考过山车的可能路线。

游乐园可以用 $r$ 行 $c$ 列的表格来表示。 过山车必须从表格的左上角开始，到表格的右下角结束。 每个单元格最多可以访问一次，但并非所有单元格都需要访问。 它可以继续从当前单元格到其上方，下方，左侧或右侧的相邻单元的路径。

每个单元格都有一个与之相关的正整数值，表示该单元格可以为游客增加的娱乐程度。过山车的总娱乐程度是过山车所访问的所有单元格的娱乐程度的总和。 帮助 Mirko 确定最有趣（总娱乐程度最大）的过山车路线之一。

## 说明/提示

#### 数据规模与约定

- 对于 $70\%$ 的数据，保证 $2 \leq r,c \leq 30$。
- 对于 $100\%$ 的数据，保证 $2 \leq r,c \leq 1 \times 10^3$，输出字符串的每一位只可能是 `U`、`D`、`L`、`R`。

#### 说明

- 本题满分 $120$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) LUNAPARK，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

#### 鸣谢

感谢 @[Silence_water](https://www.luogu.com.cn/user/338630) 提供的 Special Judge。

#### 提示

输出结果可能不唯一。

## 样例 #1

### 输入

```
3 3
5 1 3
2 4 8
1 1 2```

### 输出

```
RRDLLDRR```

## 样例 #2

### 输入

```
2 2
2 1
3 4```

### 输出

```
DR```

# 题解

## 作者：xiaolilsq (赞：9)

[题目链接](https://www.luogu.com.cn/problem/P6550)

思维题。

首先，由于题目中所给的权值均为**正整数**（“每个单元格都有一个与之相关的正整数值”），所以我们肯定会贪心地尽量选完，如果$r$和$c$有一个是奇数，我们肯定是可以全部走完的，见下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/th52mw60.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/97kxg5f9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

但是如果$r,c$都是偶数呢？貌似无法走完所有位置了，必须要舍弃一些格子。

如何舍弃？先将地图黑白染色：

![](https://cdn.luogu.com.cn/upload/image_hosting/6nj13elz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**起点和终点都是黑色的**，不难发现，**黑色格子下一步只能到白色格子，白色格子下一步只能到黑色格子**，而由于起点和终点都是黑色格子，那么**经过的步数必然是奇数**，**经过白色格子的个数必然要比经过黑色格子的个数少1**，黑色格子一共有$r\cdot c/2$个，白色一样的，所以地图中**至少有一个白色格子不会经过**，贪心地想，我们肯定会选择权值最小的那个白色格子去掉。

但是是不是去掉任何一个白色格子都能走完所有地图呢？可以先在草稿纸上随便画画：

![](https://cdn.luogu.com.cn/upload/image_hosting/liu5ldcm.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

貌似是的！无论去掉哪个白色格子，我们都可以一次性走完其他所有格子。

如果白色格子是在偶数行，有如下走法（红色的是被去掉的格子，可能比较丑，就将就看看吧）：

![](https://cdn.luogu.com.cn/upload/image_hosting/oysr676j.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如果是在奇数行，可以通过旋转使得白色格子到偶数行去。

由此我们便得到了这道题目的一种解法。

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
#define ch() getchar()
#define pc(x) putchar(x)
template<typename T>inline void read(T&x){
	int f;char c;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c<='9'&&c>='0';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>inline void write(T x){
	static char q[64];int cnt=0;
	if(!x)pc('0');if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
char Ans[4]={'D','R','U','L'};
int main(){
	int r,c,mn=0x3f3f3f3f,mnx=0,mny=0;
	read(r),read(c);
	for(int i=0;i<r;++i){
		for(int j=0;j<c;++j){
			int x;read(x);
			if((i+j)&1){
				if(x<mn){
					mn=x,mnx=i,mny=j;
				}
			}
		}
	}
	int p=false;
	if((r&1)||(c&1)){
		if(!(r&1))p=true,swap(r,c);
		for(int i=1;i<r;i+=2){
			for(int j=1;j<c;++j)
				putchar(Ans[1^p]);
			putchar(Ans[0^p]);
			for(int j=1;j<c;++j)
				putchar(Ans[3^p]);
			putchar(Ans[0^p]);
		}
		for(int i=1;i<c;++i)
			putchar(Ans[1^p]);
	}
	else{
		if(mny&1)p=true,swap(mnx,mny),swap(r,c);
		for(int i=1;i<mny;i+=2){
			for(int j=1;j<r;++j)
				putchar(Ans[0^p]);
			putchar(Ans[1^p]);
			for(int j=1;j<r;++j)
				putchar(Ans[2^p]);
			putchar(Ans[1^p]);
		}
		putchar(Ans[1^p]);
		for(int i=2;i<mnx;i+=2){
			putchar(Ans[0^p]);
			putchar(Ans[3^p]);
			putchar(Ans[0^p]);
			putchar(Ans[1^p]);
		}
		putchar(Ans[0^p]);
		for(int i=mnx+2;i<r;i+=2){
			putchar(Ans[0^p]);
			putchar(Ans[3^p]);
			putchar(Ans[0^p]);
			putchar(Ans[1^p]);
		}
		for(int i=mny+2;i<c;i+=2){
			putchar(Ans[1^p]);
			for(int j=1;j<r;++j)
				putchar(Ans[2^p]);
			putchar(Ans[1^p]);
			for(int j=1;j<r;++j)
				putchar(Ans[0^p]);
		}
	}
	return 0;
}

```

---

## 作者：寻逍遥2006 (赞：5)

[P6550 [COCI2010-2011#2] LUNAPARK](https://www.luogu.com.cn/problem/P6550)

这道题目是一道思维题，用到的知识点是国际象棋的棋盘，本片题解会着重讲解证明。

题面要求通过向上下左右移动的方式来，不重复地经过棋盘上一些格子的格子，使得它们的娱乐程度最大。

他的行动方式可以类比贪吃蛇，就是只能向上下左右移动，从左上角走到右下角。如果重复的走了某一个格子，也就是贪吃蛇撞到是自己的身体，是不可行的。

不难从猜测和题目中给出的样例发现：我们需要尽可能多的取覆盖因为只有这样我们才能够得到最大的娱乐程度。

证明很显然，在其他格子经过情况不变的情况下，由于所有的娱乐程度都是正整数，多覆盖这一个格子（严格上来说应该是偶数个格子），答案一定会更优。

那么，如果可以经过所有的格子，那就十全十美；如果有的格子一定无法经过，那我们就舍弃掉这些格子中总代价最小的那些格子。

我们现在就需要去看，有那些情况是可以经过所有的格子，那些不能。如果能，我们要怎么走；如果不能，我们又应该怎么走。

这种走棋盘的问题，我们一般会用**黑白染色**来解决（下面默认左上角起点为白色）。

假设我们对一个 $5 \times 5$ 棋盘进行黑白染色。

![](https://cdn.luogu.com.cn/upload/image_hosting/pmwp652u.png)

在这个棋盘之中，我们取其中的任何格子，我们会发现，无论往那个方向走，我们都会走到一个与当前格子颜色不同的格子上。也就是，黑色一定会走到白色；白色一定会走到黑色。

![](https://cdn.luogu.com.cn/upload/image_hosting/soogstjs.png)

数学证明：以左上角起点格子为 $(1,1)$ 右下角终点格子为 $(r,c)$ ，对整个棋盘进行标号。那么对与标号在 $(x,y)$ 的格子，我们根据 $(x+y) \bmod 2$ 的值进行染色，为 $0$ 的是一种颜色，为 $1$ 的是另一种颜色。

那么，对于 $(x,y)$ ，它可以移动到的格子至多有四个，分别是 $(x \pm 1,y)$ 和 $(x,y \pm 1)$ ，它们的染色情况，为 $(x+y \pm 1) \bmod 2 \ne (x+y) \bmod 2$ ，即移动后的格子和原格子颜色不同

那么如果我们把一种从起点到终点的路径上每一个点的染色情况标注出来，那么必然是：白黑白黑白黑……这种黑白交替的形式，那么我们的路径可能也就只和棋子的黑白数挂钩了。

当起点为白色，终点为白色时，我们的白色格子比黑色格子多一个的时候，才有可能经过所有的格子。当起点为白色，终点为黑色时，我们的白色格子和黑色格子数量相等的时候，才有可能走完所有的格子

我们探究情况的方式就可以用一一对应实现。

对于行或者列为偶数的情况，黑白格子能够一一对应，也就是黑色格子和白色格子的数量相同。

如果行和列均为奇数，以 $5 \times 5$ 为例，先讲除最后一行之外的格子一一对应（因为行数减一是偶数），然后对之后一行除了最后一个格子进行一一对应。那么，这种情况下，白色格子比黑色格子多出来了一个

![](https://cdn.luogu.com.cn/upload/image_hosting/mjbl6m9g.png)

那我们来考虑这些情况下终点的颜色。根据黑白染色的数学定义，当 $r+c\equiv1\pmod{2}$ ，也就是行和列一奇一偶的时候，终点为黑色——和黑白格子的数量刚好吻合！！！这种一情况下，我们时可以有办法覆盖所有格子的！！！

当 $r+c\equiv0\pmod{2}$ ，行和列奇偶性相同的时候，终点为白色，但我们又有两种情况：同为奇数时，白色格子多一个，和我们的需要吻合；但同为偶数的时候，黑色格子和白色格子一样，呃，好像不符合我们的期待。

综上所述，当行和列有一个为奇数的时候，我们可能有办法完全覆盖。但如果行和列均为偶数的时候，我们需要舍弃掉一些格子。

现在，我们需要考虑舍弃和构造。

当行和列有一个为奇数的时候，我们又要清楚我们的贪吃蛇——当贪吃蛇比较长的时候，我们会让他反复地左右走，那么这种情况的构造也就显然了：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ta15ax6.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/l60n99cg.png)

那么对于行和列均为偶数的情况呢？

根据之前的推理，我们起点和终点颜色相同，我们的白色格子会比黑色格子多一个，但实际情况确实数量相等，那我们就至少需要舍弃一个黑色格子。同时，我们一定不会舍弃白色的格子，因为这样我们就需要舍弃更多的黑色格子，会导致答案更劣。

根据贪心的思想，我们应该舍弃的时娱乐程度最小的那个黑色格子。

在不经过这个黑色格子的情况下，我们就要来思考构造了。

显然，我们的大致思路还是和其他的情况一样，去一行（列）一行（列）地扫。我们不妨来看行，那如果目前在扫的一行和我们不经过的那个点比较远，我们就是可以正常扫的。我们至少可以这样处理 $r-2$ 行，我们需要留一个空行来处理那个不能经过的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/r7wx9k4c.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/hnexe2sa.png)

大致会达到这样的两种情况，我们也应该能够找到对应的解法。

![](https://cdn.luogu.com.cn/upload/image_hosting/jkeg4np9.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/x4tcrh5f.png)

其实就是在 $2 \times c$ 的棋盘里面从左往右扫的时候，扫到了需要跳过的那个格子同列的格子时，我们多往右走一步即可

大致的思路就是这样，具体的细节在代码中慢慢实现。（请原谅我代码有点丑）

```cpp
#include <bits/stdc++.h>
using namespace std;
int Qread()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x;
}
int r,c,i,j,delr,delc,gl;
int a[1010][1010];
char ch;
int main()
{
	a[0][0]=2e9;
	r=Qread();c=Qread();
	for(i=1;i<=r;i++)
	for(j=1;j<=c;j++)
	{
		a[i][j]=Qread();
		if((i+j)%2==1&&a[delr][delc]>a[i][j]) delr=i,delc=j;//记录那个我们需要跳过的黑格子，因为起点为白同时行列和模2余0，所以我们要找行列和模2余1的
	}
	if(r%2==1)//行为奇数，按行扫
	{
		for(i=1;i<=r;i++)
		{
			if(i%2==1) ch='R';//判断应该向左还是向右
			else ch='L';
			for(j=1;j<c;j++)
				putchar(ch);
			if(i!=r) putchar('D');//除最后一行之外在扫描后需要向下一步
		}
	}
	else if(c%2==1)//列为奇数，按列扫，和按行扫同理
	{
		for(j=1;j<=c;j++)
		{
			if(j%2==1) ch='D';
			else ch='U';
			for(i=1;i<r;i++)
				putchar(ch);
			if(j!=c) putchar('R');
		}
	}
	else//行和列均为偶数的情况
	{
		gl=delr;
		if(gl%2==0) gl--;//找到需要特殊处理的那两行中考上的那一行，因为我们在上面处理的时候左上角的格子时白色的
		for(i=1;i<r;i++)//因为有两行被特殊处理了，所以少一行
		{
			if(i%2==1) ch='R';
			else ch='L';
			if(i==gl)
			{
				for(j=1;j<c;j++)//特殊的两行上下扫，需要去掉的格子额外往右移一下
				{
					if(j==delc) putchar(ch);
					if(j%2==1) putchar('D');
					else putchar('U');
					if(j!=c-1) putchar(ch);
				}
				if(c==delc) putchar(ch);
			}
			else
			{
				for(j=1;j<c;j++)
					putchar(ch);
			}
			if(i!=r-1) putchar('D');
		}
	}
   cout<<"防止你抄题解";
	return 0;
}
```


---

## 作者：operator_ (赞：0)

# P6550 [COCI2010-2011#2] LUNAPARK

[题目传送门](https://www.luogu.com.cn/problem/P6550)

## 题解

论证简单，构造逆天（好吧其实就是烦了点）。

每个格子是正整数，所以我们必然尝试多走格子。我们发现，只要 $r,c$ 中有一个是奇数，我们就可以全部走到，构造很简单：我们找准奇数边，假设是 $r$，蛇形地走，显然在奇数行我们会结束在末尾，在偶数行我们会结束在开头，所以是可行的。

```cpp
if(r%2==1) {
    for(int i=1;i<=r;i++) {
        for(int j=1;j<c;j++)
            if(i%2==1) putchar('R');
            else putchar('L');	
        if(i!=r) putchar('D');
    }
    return 0;
}
if(c%2==1) {
    for(int i=1;i<=c;i++) {
        for(int j=1;j<r;j++)
            if(i%2==1) putchar('D');
            else putchar('U');	
        if(i!=c) putchar('R');
    }
    return 0;
}
```
我们现在只要考虑 $r,c$ 均为偶数。

首先证明：此时不能走完。黑白染色易证（可以看其他题解）。

顺带的，我们可以证明：至少要抛弃一个白格才能走到终点（设起点是黑格）。

至于抛弃的白格有什么限制吗？答案是没有。

构造如下（以下建议画图理解）：

我们每两行一考虑。

$1$ 这两行没有出现要抛弃的点，且该点在这两行下面：按 $RRR\cdots RDLLL\cdots LD$ 走。

$2$ 这两行没有出现要抛弃的点，且该点在这两行上面：按 $LLL\cdots LDRRR\cdots RD$ 走。

$3$ 这两行出现了要抛弃的点：

再分类，我们每两列一考虑。

$(1)$ 这两列没有出现要抛弃的点，且该点在这两列右面：按 $DRUR$ 走。

$(2)$ 这两行没有出现要抛弃的点，且该点在这两列左面：按 $URDR$ 走。

$(3)$ 这两列出现了要抛弃的点：

分奇偶行考虑：

+ 在奇数行：按 $DRR$ 走。

+ 在偶数行：按 $RDR$ 走。

就构造完成了。

所以我们会抛弃白格中值最小的。

结束了吗？还有一个恶心的东西叫边界，一定不要走出去了！

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
int r,c,a[1005][1005];
int minn=LLONG_MAX,minx,miny;
signed main() {
	cin>>r>>c;
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			a[i][j]=rd();
	if(r%2==1) {
		for(int i=1;i<=r;i++) {
			for(int j=1;j<c;j++)
				if(i%2==1) putchar('R');
				else putchar('L');	
			if(i!=r) putchar('D');
		}
		return 0;
	}
	if(c%2==1) {
		for(int i=1;i<=c;i++) {
			for(int j=1;j<r;j++)
				if(i%2==1) putchar('D');
				else putchar('U');	
			if(i!=c) putchar('R');
		}
		return 0;
	}
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			if((i+j)%2==1&&a[i][j]<minn)
				minn=a[i][j],minx=i,miny=j;
	for(int i=1;i<=r;i+=2) {
		if(i+1<minx) {
			for(int j=1;j<c;j++)
				putchar('R');
			putchar('D');
			for(int j=1;j<c;j++)
				putchar('L');
			if(i+1!=r) putchar('D');
		}
		else if(i>minx) {
			for(int j=1;j<c;j++)
				putchar('L');
			putchar('D');
			for(int j=1;j<c;j++)
				putchar('R');
			if(i+1!=r) putchar('D');
		}
		else {
			for(int j=1;j<=c;j+=2) {
				if(j+1<miny) {
					putchar('D');
					putchar('R');
					putchar('U');
					if(j+1!=c) putchar('R');
				}
				else if(j>miny) {
					putchar('U');
					putchar('R');
					putchar('D');
					if(j+1!=c) putchar('R');
				}
				else {
					if(minx%2==1) {
						putchar('D');
						putchar('R');
						if(j+1!=c) putchar('R');
					}
					else {
						putchar('R');
						putchar('D');
						if(j+1!=c) putchar('R');
					}
				}
			}
			if(i+1!=r) putchar('D');
		}
	}
	return 0;
}

```

---


# [SBCOI2020] 人

## 题目背景

梦  
做着同一个梦  
每一天都做的梦  
没有终结的梦......  
咦...这里...是哪里？  
周围漫天是如雪花般飘落的的碎片。   
天空明亮的光芒又一次掠过这些碎片，照在地上。  
这些碎片像是永无尽头的围巾一般，围在她的四周，  
在她的身后延伸到世界的尽头，诉说着一段段破碎的记忆......  
......  
这...刚才...是梦吗？  
看来我又做了一个梦...  
不知不觉，离开这个小镇已经这么久了啊...  
但是...总感觉这个小镇...无法忘记...  
刚才看到的到底是什么？  
为什么呢?  
![](https://cdn.luogu.com.cn/upload/image_hosting/xltdmgq1.png)  
总觉得我需要回去一次，  
回到......一切开始的地方......  


## 题目描述

她的梦中有 $2m$ 块记忆碎片，编号为 $1,2,\cdots,2m$，以及 $a$ 块白色碎片和 $b$ 块黑色碎片。

她隐约记得她要在编号为奇数的记忆碎片中选出 $a$ 块白色碎片组成一段记忆，在编号为偶数的记忆碎片中选出 $b$ 块黑色碎片组成一段记忆，且选出的记忆碎片编号两两不相邻。

她想要知道一共有多少种这样的选法。也就是，在 $1-2m$ 中选出 $a$ 个奇数， $b$ 个偶数，并且选出的数两两不相邻的方案数。

由于答案可能很大，她只需要答案对于 $998244353$ 取模的结果。

## 说明/提示

#### 样例解释

第一个询问，一共 $4$ 个数，在奇数 ${1,3}$ 中选一个,偶数 ${2,4}$ 中选一个，选出两个数不相邻的只能选 $1,4$ 。  
第二个询问，一共 $8$ 个数，在奇数 ${1,3,5,7}$ 中选 $2$ 个数，偶数 ${2,4,6,8}$ 中选 $1$ 个数，而且总共选出的 $3$ 个数两两不相邻，只有：$\{1,3,6\}，\{1,3,8\}，\{1,5,8\}，\{1,4,7\}，\{3,5,8\}，\{2,5,7\}$。 总共 $6$ 种选法。

后面几个询问范围过大，不进行样例解释。

#### 数据范围

**本题采用捆绑测试**，共有 $3$ 个子任务。

$Subtask 1 (10\%)$，$1 \le T \le 10, 1 \le a,b \le m \le 10$。

$Subtask 2 (40\%)$，$1 \le T \le 10^6,  1 \le a,b \le m \le 100$。

$Subtask 3 (50\%)$，$1 \le T \le 10^6, 1 \le a,b \le m \le 10^6$。 

对于 $100\%$ 的数据，保证 $a+b \le m$。



## 样例 #1

### 输入

```
6
2 1 1
4 2 1
114 5 14
1919 8 10
19260 8 17
114514 1919 810```

### 输出

```
1
6
43944630
803733835
204764788
713170605```

# 题解

## 作者：duyi (赞：9)

# 来呀，快活呀↓

[超超超超超爽的阅读体验](https://www.cnblogs.com/dysyn1314/p/13324193.html)

## 题目大意

给定三个正整数$m$, $a$, $b$。要求在$[1,2m]$中选出$a$个奇数，$b$个偶数，并且选出的数两两不相邻。问有多少种选择的方案。方案数对$998244353$取模。

$T$组测试数据。

数据范围：$1\leq a,b\leq m\leq 10^6$。$a+b\leq m$。$1\leq T\leq 10^6$。

## 本题题解

考虑相邻的一奇一偶，也就是形式化地表述为$2i+1$, $2i+2$ ($0\leq i<m$)这两个数，它们不可能同时被选中。对于第$i$组数，如果$2i+1$（奇数）被选中，称这一组为$\text{A}$；如果$2i+2$（偶数）被选中，称这一组为$\text{B}$；如果都没有被选中，称这一组为$\text{C}$。则任何一种合法的选择方案，可以被表示为一个长度为$m$的$\text{ABC}$串，其中有$a$个$\text{A}$，$b$个$\text{B}$，和$m-a-b$个$\text{C}$，并且不允许出现$\text{BA}$这个子串。我们相当于要求这样的$\text{ABC}$串的数量。

先不考虑$\text{A}$。$\text{B}$和$\text{C}$的相对位置关系可以任意安排，它们共有$b+(m-a-b)=m-a$个，所以任意安排的方案数是${m-a\choose b}$。

再插入$\text{A}$。$\text{A}$不能被插入在$\text{B}$后面，除此之外其他任何位置都是可以的。考虑第$1$个$\text{A}$，它可以被插入在最前面，或者某个$\text{C}$后面，所以有$m-a-b+1$种方案；第$2$个$\text{A}$，除了最前面和某个$\text{C}$后面以外，还能插入在第$1$个$\text{A}$后面，所以有$m-a-b+2$种方案；以此类推，第$k$个$\text{A}$有$m-a-b+k$种插入方案。同时，所有$\text{A}$是本质相同的，所以还要除以$a!$。所以插入$\text{A}$的总方案数就是：$\frac{(m-a-b+1)\cdot(m-a-b+2)\cdots(m-a-b+a)}{a!}={m-b\choose a}$。

因此答案就是：${m-a\choose b}\cdot{m-b\choose a}$。

$T$次求组合数。预处理阶乘和阶乘的逆元即可。

时间复杂度$O(m+T)$。

参考代码（本代码仅供参考，建议添加读入优化）：

```cpp
//problem:P6561
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=2e6;
const int MOD=998244353;
inline int mod1(int x){return x<MOD?x:x-MOD;}
inline int mod2(int x){return x<0?x+MOD:x;}
inline void add(int& x,int y){x=mod1(x+y);}
inline void sub(int& x,int y){x=mod2(x-y);}
inline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}

int fac[MAXN+5],ifac[MAXN+5];
inline int comb(int n,int k){
	if(n<k)return 0;
	return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD;
}
void facinit(int lim=MAXN){
	fac[0]=1;
	for(int i=1;i<=lim;++i)fac[i]=(ll)fac[i-1]*i%MOD;
	ifac[lim]=pow_mod(fac[lim],MOD-2);
	for(int i=lim-1;i>=0;--i)ifac[i]=(ll)ifac[i+1]*(i+1)%MOD;
}

int m,a,b;
int main() {
	facinit();
	int T;cin>>T;while(T--){
		cin>>m>>a>>b;
		int ans = (ll)comb(m-a,b) * comb(m-b,a) % MOD;
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：Fido_Puppy (赞：5)

一道感觉能被 [cjZYZtcl](https://www.luogu.com.cn/user/188286) 一眼秒掉的简单数数题。

## 题目链接

[P6561 [SBCOI2020] 人](https://www.luogu.com.cn/problem/P6561)

## 题解

我们考虑先选奇数，然后再选偶数。

那么我们需要考虑的是选出 $a$ 个奇数后，偶数有几个位置不能选了。

普遍情况下是有 $2a$ 个位置不能选了，但是如果你选了相邻两个奇数，比如 $2x - 1$ 和 $2x + 1$，那么 $2x$ 这个位置会被算两遍，实际情况就是只有 $< 2a$ 个位置的偶数不能选；或者你选了 $1$，因为 $1$ 的左边没有偶数了，也会导致只有 $< 2a$ 个位置的偶数不能选。

稍加观察可以发现，我们枚举是否选奇数 $1$，然后可以选择的偶数位置个数只和你选择的奇数的连续段数有关。

注：这里**奇数的连续段数**，是指你将选出的奇数序列分成**若干极长的段**，使得每一段中奇数都是类似 $2x + 1, 2x + 3, \cdots$ 这样连续的，分出来的段数即是选择的奇数的连续段数。

接下我们需要考虑如何求出奇数的连续段数为 $i$ 时的方案数。

首先考虑不选择奇数 $1$ 的方案数，选择奇数 $1$ 的方案数同理可得。

我们考虑将整个序列分成 $2i + 1$ 段，长度分别为 $x_1, x_2, \cdots, x_{2i + 1}$。

其实际意义就是考虑将原来的长度为 $m$ 的奇数序列按照这个长度分成 $2i + 1$ 段，其中 $x_2, x_4, \cdots, x_{2i}$ 都是你选择的奇数，其余都是你没有选择的奇数。

那么按照定义，可得：

$$\begin{cases} x_1 + x_2 + \cdots + x_{2i + 1} = m \\ x_2 + x_4 + \cdots + x_{2i} = a \\ x_1, x_2, \cdots, x_{2i} \ge 1, x_{2i + 1} \ge 0 \end{cases}$$

这个方案数的计算明显可以用隔板法来解决。

组合意义可以考虑我们先将 $a$ 个球装到对应的 $i$ 个盒子里，然后将剩下的 $m - a$ 个球装到剩下的 $i + 1$ 个盒子里，每个盒子对应的限制如上所示。

那么奇数的连续段数为 $i$ 时的方案数就是：

$${a - 1 \choose i - 1} \times {m - a \choose i}$$

同理可得奇数的连续段数为 $i$，选择奇数 $1$ 时的方案数为：

$${a - 1 \choose i - 1} \times {m - a \choose i - 1}$$

接下来就是解决当连续段个数为 $i$ 时，偶数能选的位置个数为多少，这个是简单的：

当不选择奇数 $1$ 时，个数为： $m - a - i$。

当选择奇数 $1$ 时，个数为：$m - a - i + 1$。

然后答案即为：

$$\sum_{i = 1} ^ a {m - a \choose i} \times {a - 1 \choose i - 1} \times {m - a - i \choose b} + \sum_{i = 1} ^ n {m - a \choose i - 1} \times {a - 1 \choose i - 1} \times {m - a - i + 1 \choose b}$$

直接计算的复杂度是 $\Theta(Ta)$ 的，期望得分 $50\ \text{pts}$。

我们考虑推式子来优化，这里以前半部分为例，后半部分同理：

$$\sum_{i = 1} ^ a {m - a \choose i} \times {a - 1 \choose i - 1} \times {m - a - i \choose b}$$

相信在座的各位 ikun 肯定做过 [P2791 幼儿园篮球题](https://www.luogu.com.cn/problem/P2791)，这道题和那道题的套路很像。

发现什么都看不出来，于是把组合数拆成阶乘的形式：

$$\sum_{i = 1} ^ a {a - 1 \choose i - 1} \times \dfrac{(m - a)! \times (m - a - i)!}{i! \times (m - a - i)! \times b! \times (m - a - i - b)!}$$

然后发现 $(m - a - i)!$ 可以约掉：

$$\sum_{i = 1} ^ a {a - 1 \choose i - 1} \times \dfrac{(m - a)!}{i! \times b! \times (m - a - i - b)!}$$

发现分母中有 $i!$ 和 $(m - a - i - b)!$，要是分子中有 $(m - a - b)!$ 就能凑成组合数了，于是分式上下同乘 $(m - a - b)!$。

$$\sum_{i = 1} ^ a {a - 1 \choose i - 1} \times \dfrac{(m - a)! \times (m - a - b)!}{i! \times b! \times (m - a - i - b)! \times (m - a - b)!}$$

然后把组合数再提出来：

$$\sum_{i = 1} ^ a {a - 1 \choose i - 1} \times {m - a - b \choose i} \times {m - a \choose b}$$

我们惊喜地发现最后一项是和 $i$ 无关的，于是把它提到前面：

$${m - a \choose b} \times \sum_{i = 1} ^ a {a - 1 \choose i - 1} \times {m - a - b \choose i}$$

由于：

$${a - 1 \choose i - 1} = {a - 1 \choose a - i}$$

所以可得原式等于：

$${m - a \choose b} \times \sum_{i = 1} ^ a {a - 1 \choose a - i} \times {m - a - b \choose i}$$

然后就发现后面的式子可以范德蒙德卷积了：

$${m - a \choose b} \times {m - b - 1 \choose a}$$

选择奇数 $1$ 的情况同理，最终推出式子为：

$${m - a \choose b} \times {m - b - 1 \choose a} + {m - a \choose b} \times {m - b - 1 \choose a - 1}$$

至此，时间复杂度优化为 $\Theta(T + m)$，期望得分 $100\ \text{pts}$。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int mod = 998244353;
int fac[5000005], ifac[5000005];
int qpow(int x, int p) {
	int ans = 1;
	while (p) {
		if (p & 1) ans = 1ll * ans * x % mod;
		p >>= 1, x = 1ll * x * x % mod;
	}
	return ans;
}
int C(int m, int n) {
	if (n > m or n < 0 or m < 0) return 0;
	return 1ll * fac[m] * ifac[n] % mod * ifac[ m - n ] % mod;
}
int main() {
	ios :: sync_with_stdio(0), cin.tie(0);
	fac[0] = 1;
	for (int i = 1; i <= 5e6; ++i) fac[i] = 1ll * fac[ i - 1 ] * i % mod;
	ifac[5000000] = qpow(fac[5000000], mod - 2);
	for (int i = 5e6; i; --i) ifac[ i - 1 ] = 1ll * ifac[i] * i % mod;
	int t; cin >> t;
	while (t--) {
		int a, b, m; cin >> m >> a >> b;
		cout << 1ll * C(m - a, b) * (C(m - b - 1, a) + C(m - b - 1, a - 1)) % mod << '\n';
	}
	return 0;
}
```

---

## 作者：JohnVictor (赞：5)

~~哎，今天作为【无脑出题人】被神仙D了一顿。以后出题都自己写题解了，不放无脑做法了。（手动/kk）~~


归纳比较好想吧，数学考试肯定这么做，接下来讲组合证明：

原本的问题是对于 $1 - m$ 而不是 $1-2m$ 进行分析。

分类讨论。偶数的情况：

本题专门强调了是偶数就简单一点了，把 $2m$ 看成 $m$ 个 $1\times2$ 的，讨论每一个内部的情况，只有三种：（$0$ 表示没有，$1$ 表示有）

（1）01 （2）10 （3）00

那么只要不出现连续的 （1）和（2）就行了。注意到分别有 $a,b,m-a-b$ 个，那么在（3）中间放（2），然后再决定位置即可。

放（2）有 $C_{(m-a-b)+b}^{b}$种，（1）和（2）是对偶的（由于不能在（2）前面）所以是 $C_{m-a-b+a}^{a}$，乘起来就得到了答案。

如果是奇数，考虑选完偶数后还有多少个位置放奇数即可。注意还有一种方法就是化归到偶数的情况：

$f(2m+1,a,b)=f(2m+2,a,b)-f(2m,a,b-1)$（考虑加上一个数，如果选了去掉）

题外话：

虽然这题完全没卡常，但我还是担心误伤，这里说明一下：线性求逆元的话维护前缀后缀乘积比较快，大概是内存连续的原因。这个虽然运算用的 `ll`，但是开数组还是要 `int`，否则访问慢。读入用 `cin` T 掉的，就不是我的问题了（其实你谷好像没问题）

---

## 作者：犇犇犇犇 (赞：5)

这里是官方题解qaq  
~~其实这道题就是个数学题~~  

### $Subtask 1 (10\%)$，$1 \le T \le 10, 1 \le a,b \le m \le 10$。

对于这一部分，$T,a,b$ 都很小，所以我们可以考虑暴力枚举所有的可能情况。枚举从所有奇数中选 $a$ 个，在 $m$ 个偶数中选 $b$ 个。一个 $\operatorname{dfs}$ 即可

代码：  
```
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int Q,m,a,b,ans,l[105],r[105]; 
//l数组表示奇数已经选取的数字，r数组表示偶数已经选取的数字
bool vis[105]; //保存当前数字是否可用
void dfs(int m,int x,int y)
{
	if(x==a+1 && y==b+1) //如果已经选完了
	{
		ans++; 
		return;
	}
	if(x==a+1) //如果奇数选完了，选偶数
	{
		for(int i=r[y-1]/2+1;i<=m;i++) //从上一次选的地方开始选
		{
			if(vis[2*i]==0) //当前数可用
			{
				vis[2*i]=1;
				r[y]=i*2; //记录
				dfs(m,x,y+1); //dfs下一层
				vis[2*i]=0; //回溯
			}
		}
	}
	else //选奇数
	{
		for(int i=l[x-1]/2;i<m;i++) 
		{
			if(vis[2*i+1]==0) //同上
			{
				vis[2*i]=vis[2*i+1]=vis[2*i+2]=1; //由于不能选相邻的数，则2*i+1周围的数也不能选
				l[x]=i*2+1;
				dfs(m,x+1,y);
				vis[2*i+1]=0; //回溯
				if(i==0 || vis[2*i-1]==0) //如果2*i左右两边都没有数，她才可以继续使用
					vis[2*i]=0;
				if(vis[2*i+3]==0) //此时2*i+1不选，如果2*i+3也不选，那么2*i+2可以使用
					vis[2*i+2]=0;
			}
		}
	}
}
int main()
{
	Q=read();
	while(Q--)
	{
		m=read();a=read();b=read();
		memset(vis,0,sizeof(vis)); //初始化
		ans=0;
		dfs(m,1,1);
		cout<<ans<<endl;
	}
	return 0;
}
```

### $Subtask 2 (40\%)$，$1 \le T \le 10^6,  1 \le a,b \le m \le 100$。

我们可以发现 $T$ 很大，但是 $m,a,b$ 很小。提示已经很明确了，我们可以预先用一个3维数组保存每一个 $m,a,b$ 的答案，然后每次询问直接输出，每次询问复杂度$O(1)$  
我们用 $dp[m][a][b]$ 保存答案。$m,a,b$ 与题目中相同。 
我们希望从 $dp[m-1][a][b]$ 推出 $dp[m][a][b]$  
对于 $1$ 到 $2m$ 中有选 $a$ 个奇数，$b$ 个偶数，我们可以分为3种情况  
* 在1到2(m-1)中选a个奇数，b个偶数。此时答案为dp[m-1][a][b]  
* 在1到2(m-1)中选a个奇数，b-1个偶数，在 2m-1,2m 中选 2m 这个偶数。此时答案为 dp[m-1][a][b-1]  
* 在1到2(m-1)中选a-1个奇数，b个偶数，在 2m-1,2m 中选 2m-1 这个奇数。此时情况数为 dp[m-1][a-1][b]。但是这里还有另外一个条件，因为我们选了 2m-1 , 也就是说 2m-2 这个数我们不能选。所以我们需要把选了 2m-2 的情况排除掉。也就是说排除前 2m-2 个数中选了 2m-2 的情况。此时前 2m-4 个数可以随便选，所以情况为 dp[m-2][a-1][b-1]。所以这种情况最终的答案为 dp[m-1][a-1][b]-dp[m-2][a-1][b-1]  

所以我们可以得到递推式子  
$dp[m][a][b]=dp[m-1][a][b]+dp[m-1][a-1][b]+dp[m-1][a][b-1]-dp[m-2][a-1][b-1]$  

初始化时，$dp[i][0][j]=dp[i][j][o]=C_i^j$ （此处C表示组合数）  
$dp[2][1][1]=1$ 。$dp[m][a][b]$ 需要 $dp[m-2][a-1][b-1]$ 转移过来，所以第一维循环 $m$ 应从3开始，所以 $m=2$ 的情况要特判一下。  

最后，别忘了取模，别忘了 $\operatorname{long}\ \operatorname{long}$

代码：

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXM = 105;
const ll MOD = 998244353;
inline ll read()
{
	ll x=0,f=1;char c=getchar(); 
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
} 
ll dp[MAXM][MAXM][MAXM];
int main()
{
	ll T;
	T=read();
	dp[1][0][0]=dp[1][1][0]=dp[1][0][1]=1;
	dp[2][1][1]=1; //初始化
	for(ll i=2;i<=100;i++)
	{
		dp[i][0][0]=1;
		for(ll j=1;j<=i;j++) 
		{
			dp[i][0][j]=(dp[i-1][0][j]+dp[i-1][0][j-1])%MOD;
			dp[i][j][0]=(dp[i-1][j][0]+dp[i-1][j-1][0])%MOD;
        //dp[i][0][j]=dp[i][j][o]=C(i,j) 这里我用了递推实现，C(i,j)=C(i-1,j)+C(i-1,j-1)
		}
	}
	for(ll i=3;i<=100;i++)
	{
		for(ll a=1;a<=100;a++)
		{
			for(ll b=1;a+b<=i;b++)
			{
				dp[i][a][b]=(dp[i-1][a][b]+dp[i-1][a-1][b]+dp[i-1][a][b-1]-dp[i-2][a-1][b-1]+MOD)%MOD; //dp,这里如果不加+MOD再%MOD可能会出现负数的情况
			}
		}
	}
	while(T--)
	{
		ll m,a,b;
		m=read();
		a=read();
		b=read();
		cout<<dp[m][a][b]<<endl; //每次询问O(1)
	}
	return 0;
}
```

### $Subtask 3 (50\%)$，$1 \le T \le 10^6, 1 \le a,b \le m \le 10^6$。 

我们发现 $T,a,b$ 都很大，明显是推公式，O(m) 预处理，每次询问 O(1)  
观察数据，我们可以发现 $dp[m][i][j]=C_{m-i}^j \times C_{m-j}^i$   

下面我们来证明一下。需要用到组合数性质   
$C_n^k=C_{n-1}^k \times C_{n-1}^{k-1}$     
$C_n^k=C_{n+1}^k-C_n^{k-1}$    

上一个子问题，我们得到递推公式  
$dp[m][a][b]=dp[m-1][a][b]+dp[m-1][a-1][b]+dp[m-1][a][b-1]-dp[m-2][a-1][b-1]$  
显然，当 $a,b$ 中有一个数为 0 的时候成立。  
对 $dp[2][1][1]$ 成立。  
我们将公式带入右边。   

$\large\texttt{ }\texttt{ }\texttt{ }\texttt{ }\texttt{ }C_{m-a-1}^{b} \times C_{m-b-1}^{a}+C_{m-a}^{b} \times C_{m-b-1}^{a-1}+C_{m-a-1}^{b-1} \times C_{m-b}^{a}-C_{m-a-1}^{b-1} \times C_{m-b-1}^{a-1}$  

$\large =C_{m-a-1}^{b} \times C_{m-b-1}^{a}+C_{m-b-1}^{a-1} \times (C_{m-a}^{b}-C_{m-a-1}^{b-1})+C_{m-a-1}^{b-1} \times C_{m-b}^{a}$

$\large =C_{m-a-1}^{b} \times C_{m-b-1}^{a}+C_{m-b-1}^{a-1} \times C_{m-a-1}^{b}+C_{m-a-1}^{b-1} \times C_{m-b}^{a}$

$\large =C_{m-a-1}^{b} \times (C_{m-b-1}^{a}+C_{m-b-1}^{a-1})+C_{m-a-1}^{b-1} \times C_{m-b}^{a}$

$\large =C_{m-a-1}^{b} \times C_{m-b}^{a}+C_{m-a-1}^{b-1} \times C_{m-b}^{a}$

$\large =C_{m-b}^{a} \times (C_{m-a-1}^{b}+C_{m-a-1}^{b-1})$

$\large =C_{m-b}^{a} \times C_{m-a}^{b}$

所以我们就证明了这个结论。对于每个问题，我们只需要求出 $C_{m-b}^{a} \times C_{m-a}^{b}$ 即可。 

求组合数的办法我用的是线性预处理逆元，不了解的可以[看这里](https://www.luogu.com.cn/problem/P3811)  

组合数$C_a^b$ $mod$ $p$ 相当于是 $a!/(a-b)!/b!$ $mod$ $p$。这里 $p$ 是质数，所以除以 $p$ 等于乘上在模 $p$ 下的逆元。所以我们只要预处理出每个数的阶乘在模 $p$ 下的逆元即可。  
若 $a[i]$ 表示 $i!$ $mod$ $p$， $ny[i]$ 表示 $i!$ 的逆元 $mod$ $p$ , 则$C_{m-s}^t$即等于$a[m-s]\times ny[n-t-s] \times ny[t]$。  

别忘了 $\operatorname{long}\ \operatorname{long}$   
代码：

```
#include <bits/stdc++.h>
#define ll long long
const int MAXN = 1e6+5;
using namespace std;
inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f; 
}
const ll MOD = 998244353;
ll a[MAXN],ny[MAXN],Q,n,t,s;
ll ans,d,e,f,g,h;
int main()
{
	Q=read();
	a[0]=1;
	ny[1]=1;
	for(int i=1;i<MAXN;i++)
		a[i]=((ll)i*a[i-1])%MOD;
	for(int i=2;i<MAXN;i++)
		ny[i]=((ll)(MOD-MOD/i)*ny[MOD%i]%MOD);
	for(int i=2;i<MAXN;i++)
		ny[i]=ny[i]*ny[i-1]%MOD; //预处理逆元
	while(Q--)
	{
		n=read();t=read();s=read();
		if(n==t+s)
		{
			printf("1\n");
			continue;
		} //如果n=t+s那么只有一种情况
		ans=a[n-s]*a[n-t]%MOD;
		ans=ans*ny[t]%MOD;ans=ans*ny[s]%MOD;
		ans=ans*ny[n-t-s]%MOD;ans=ans*ny[n-t-s]%MOD; //求组合数
		printf("%lld\n",ans);
	}
	return 0;
} 
```

---

## 作者：4biu (赞：2)

想看证明的。。。蒟蒻不会，请看楼上【】

------------
配图不错。不过题目很。。。。

------------
一眼看到题目，肯定排列组合啊【】

然而。。。蒟蒻想了半天，写了一个$C_m^{a+b}$。。然后懵了


------------
懵了以后怎么办？当然打暴力了

很容易就能想出一个dp

【1.你把dp叫暴力？    2.“很容易”【其实一点也不容易】】


------------
![](https://cdn.luogu.com.cn/upload/image_hosting/w0i4y1jy.png)

我们可以考虑是否取第一个数（是奇数）

如果取，转化成$dp[1][m-1][a-1][b]$

如果不取

![](https://cdn.luogu.com.cn/upload/image_hosting/i9go1r5e.png)

如果不取，转化成$dp[0][m][a][b]$

再看dp[0][m][a][b]，同理

考虑是否取第一个数（是偶数）

如果取，转化为$dp[0][m-1][a][b-1]$

如果不取，转化为$dp[1][m-1][a][b]$

于是，我们可以用$O(m^3)$来算出答案（可以拿到50分）

------------
暴力写完了，打表呐。
```cpp
for(int m=0;m<=10;m++)
	dp[1][m][0][0]=dp[0][m][0][0]=1;
for(int m=1;m<=10;m++)
	for(int i=0;i<=m;i++)
		for(int j=0;j<=m;j++)
		{
			if(i==0&&j==0)continue;
			dp[0][m][i][j]=((j==0?0:dp[0][m-1][i][j-1])+dp[1][m-1][i][j])%mod;
			dp[1][m][i][j]=((i==0?0:dp[1][m-1][i-1][j])+dp[0][m][i][j])%mod;
		}
for(int m=1;m<=10;m++)
{
	cout<<m<<endl;
	for(int i=0;i<=m;i++)
	{
		for(int j=0;j<=m;j++)
			printf("%7d ",dp[1][m][i][j]);
		cout<<endl;
	}
	cout<<endl;
}
结果：
1
      1       1
      1       0

2
      1       2       1
      2       1       0
      1       0       0

3
      1       3       3       1
      3       4       1       0
      3       1       0       0
      1       0       0       0

4
      1       4       6       4       1
      4       9       6       1       0
      6       6       1       0       0
      4       1       0       0       0
      1       0       0       0       0

5
      1       5      10      10       5       1
      5      16      18       8       1       0
     10      18       9       1       0       0
     10       8       1       0       0       0
      5       1       0       0       0       0
      1       0       0       0       0       0

6
      1       6      15      20      15       6       1
      6      25      40      30      10       1       0
     15      40      36      12       1       0       0
     20      30      12       1       0       0       0
     15      10       1       0       0       0       0
      6       1       0       0       0       0       0
      1       0       0       0       0       0       0

7
      1       7      21      35      35      21       7       1
      7      36      75      80      45      12       1       0
     21      75     100      60      15       1       0       0
     35      80      60      16       1       0       0       0
     35      45      15       1       0       0       0       0
     21      12       1       0       0       0       0       0
      7       1       0       0       0       0       0       0
      1       0       0       0       0       0       0       0

8
      1       8      28      56      70      56      28       8       1
      8      49     126     175     140      63      14       1       0
     28     126     225     200      90      18       1       0       0
     56     175     200     100      20       1       0       0       0
     70     140      90      20       1       0       0       0       0
     56      63      18       1       0       0       0       0       0
     28      14       1       0       0       0       0       0       0
      8       1       0       0       0       0       0       0       0
      1       0       0       0       0       0       0       0       0

9
      1       9      36      84     126     126      84      36       9       1

      9      64     196     336     350     224      84      16       1       0

     36     196     441     525     350     126      21       1       0       0

     84     336     525     400     150      24       1       0       0       0

    126     350     350     150      25       1       0       0       0       0

    126     224     126      24       1       0       0       0       0       0

     84      84      21       1       0       0       0       0       0       0

     36      16       1       0       0       0       0       0       0       0

      9       1       0       0       0       0       0       0       0       0

      1       0       0       0       0       0       0       0       0       0


10
      1      10      45     120     210     252     210     120      45      10
      1
     10      81     288     588     756     630     336     108      18       1
      0
     45     288     784    1176    1050     560     168      24       1       0
      0
    120     588    1176    1225     700     210      28       1       0       0
      0
    210     756    1050     700     225      30       1       0       0       0
      0
    252     630     560     210      30       1       0       0       0       0
      0
    210     336     168      28       1       0       0       0       0       0
      0
    120     108      24       1       0       0       0       0       0       0
      0
     45      18       1       0       0       0       0       0       0       0
      0
     10       1       0       0       0       0       0       0       0       0
      0
      1       0       0       0       0       0       0       0       0       0
      0
【格式有点。。。。】
```
然后就是盯着表看环节

看了很久，发现每个a=b的时候都是完全平方数【然而并没用】

想到这是一个排列组合题目，画了个杨辉三角对照
![](https://cdn.luogu.com.cn/upload/image_hosting/ei24t6ux.png)

突然感觉表中的数字可以由杨辉三角中行列乘积表示

然后就行了。。。耗时嘛emmm。。。。

结果是$C_{m-a}^b * C_{m-b}^a$。

------------
最后需要注意的。。
求逆元不用线性筛会死【】
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long mod=998244353;
long long jc[1000001],inv[1000001];
long long C(long long a,long long b)
{
	return jc[a]*(a!=b?inv[a-b]:1)%mod*(b!=0?inv[b]:1)%mod;
}
int main()
{
	inv[1]=1;
    for(int i=2;i<=1000001;i++)
        inv[i]=(long long)(mod-mod/i)*inv[mod%i]%mod;
    for(int i=2;i<=1000000;i++)
		inv[i]=inv[i]*inv[i-1]%mod;
	jc[1]=1;
	for(int i=2;i<=1000000;i++)
		jc[i]=jc[i-1]*i%mod;
	int T;scanf("%d",&T);
	while(T--)
	{
		long long m,a,b;scanf("%lld%lld%lld",&m,&a,&b);
		if(a+b>m)printf("0\n");
		else printf("%lld\n",((C(m-b,a)*C(m-a,b))%mod+mod)%mod);
	}
	return 0;
}
```
最后，奉劝大家考场上话20分钟拿到那50分就走人吧qwq

不然会死人的awa。。

---

## 作者：TankYu (赞：1)

可爱数数题。

可以把 $2i + 1,2i+2$ 放一起看。

如果用 `1` 表示这一个数被选的话，那么对于上述的相邻元素只有 `10`，`01`，`00` 三种情况。

那么题目所要求的是 $a$ 个 `10`，$b$ 个 `01`，$m-a-b$ 个 `00` 能够拼成多少个不存在 `01` 在 `10` 前的串。

`00` 没啥性质，不能从它开始，我们先考虑放 `01`。

显然 `01` 和 `00` 的相对关系比较好想，等价于一共 $m-a-b+b$ 个中选 $b$ 个，即 $\binom{m-a}{b}$。

然后 `10` 只能放在 `00` 或 `10` 后，一共有 $m-a-b$ 个 `00`，这里由小学数学可以知道贡献是 $\binom{m-b}{a}$。

答案即 $\binom{m-b}{a} \times \binom{m-a}{b}$，预处理阶乘及其逆元即可。

```cpp
#include <iostream>
using namespace std;
#define LL long long
const LL mod = 998244353;
LL f[1000010], inv[1000010];
LL ksm(LL a, LL b)
{
    LL ans = 1;
    while (b)
    {
        if (b & 1)
        {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        b >>= 1;
    }
    return ans;
}

LL C(LL n, LL m)
{
    return f[n] * inv[m] % mod * inv[n - m] % mod;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin >> t;
    f[0] = inv[0] = 1;
    for (int i = 1; i <= 1000000; i++)
    {
        f[i] = f[i - 1] * i % mod;
        inv[i] = ksm(f[i], mod - 2);
    }
    while (t--)
    {
        long long m, a, b;
        cin >> m >> a >> b;
        cout << C(m - a, b) * C(m - b, a) % mod << '\n';
    }
    return 0;
}
```

---

## 作者：Sukilin (赞：0)

# P6561 [SBCOI2020] 人
## 题面
给定正整数 $m,a,b$，在 $[1, 2m]$ 中选择 $a$ 个奇数和 $b$ 个偶数，要求选择的数两两不相邻，求选择方案数。
## 思路
这显然是一个组合计数题。

把 $[1,2m]$ 中的整数分为 $\{1,2\},\{3,4\},\dots,\{2m-1,2m\}$ 这些组。显然每组最多选择一个数，共选择 $a+b$ 组，而且选择的组里有 $a$ 个是选奇数的。但是要注意相邻的两组不能前面选偶数而后面选奇数。

先来看一个小学奥数题：有 $x$ 个互不相同的苹果排成一列，选出 $y$ 个捅一刀，并在捅了的的苹果中的 $p$ 个上再捅一刀。要求不能出现两个相邻的苹果，使得左面恰捅了一刀，右面捅了两刀。求方案数目。

捅两刀的苹果有点复杂，先不研究。没捅和恰捅一刀的苹果显然可以随便选择，相当于先在 $x-p$ 个（没捅或恰捅一刀）的苹果里选择 $y-p$ 个（恰捅一刀）的苹果。方案数就是 $\tbinom{x-p}{y-p}$。

接下来，捅两刀的苹果只能放在没捅的苹果右面，或者捅两刀的苹果右面，或者最左面。捅两刀的苹果有 $p$ 个，有效的位置（最左面和没捅的苹果右面）有 $x-y+1$ 个。相当于把 $p$ 个本质相同的苹果放在 $x-y+1$ 个本质不同的篮子里，允许篮子为空或有多个苹果。

考虑把 $c$ 个本质相同的苹果放到 $d$ 个本质不同的篮子里的问题，先转化成把 $c+d$ 个苹果放到 $d$ 个篮子里，每个篮子至少一个的问题，再用插板法，得出有 $\tbinom{c+d-1}{d-1}$ 种方案。

把 $c$ 换成 $p$，把 $d$ 换成 $x-y+1$，得出整个“小学奥数题”的答案是 $\tbinom{x-p}{y-p}\tbinom{x-y+p}{x-y}$。

我们把某组不选转化为没捅苹果，选偶数转化为捅一刀，选奇数转化为捅两刀。就是把 $x$ 换成 $m$，把 $p$ 换成 $a$，把 $y$ 换成 $a+b$。

这道题的答案就是 $\tbinom{m-a}{b}\tbinom{m-b}{m-a-b}$。

计算就很简单了。预处理值域内整数的阶乘和模 $998244353$ 意义下的乘法逆元。（$998244353$ 是素数）。

## 参考代码
```cpp
#include <iostream>
#include <cstdio>
const long long mod = 998244353; 
const int N = 1e6 + 7; 
long long f[N], inv[N];
long long pow(long long a, long long b) {
    long long ans = 1;
    while(b) {
        if(b & 1) {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        b >>= 1;
    }
    return ans;
}
long long C(long long n, long long m) {
    return f[n] * inv[m] % mod * inv[n - m] % mod;
} //组合数公式
#include <iostream>
#include <cstdio>
const long long mod = 998244353; 
const int N = 1e6 + 7; 
long long f[N], inv[N];
long long pow(long long a, long long b) {
    long long ans = 1;
    while(b) {
        if(b & 1) {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        b >>= 1;
    }
    return ans;
}
long long C(long long n, long long m) {
    return f[n] * inv[m] % mod * inv[n - m] % mod;
} //组合数公式
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t;
    std::cin >> t;
    f[0] = inv[0] = 1;
    for (int i = 1; i < N; i++) {
        f[i] = f[i - 1] * i % mod;
        inv[i] = pow(f[i], mod - 2);
    } //求阶乘（模 998244353 意义下）和乘法逆元
    for(int i = 1; i <= t; i++) {
        long long m, a, b;
        std::cin >> m >> a >> b;
        std::cout << C(m - a, b) * C(m - b, m - a - b) % mod << '\n';
    }
    return 0;
}
```

## 题外的话
什么鬼标题

---


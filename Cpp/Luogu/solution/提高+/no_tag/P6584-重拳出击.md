# 重拳出击

## 题目描述

小 Z 和 $m$ 个 Youyou 在一棵树上相遇了！

这棵树上，每条边的长度都是 $1$。

初始时，小 Z 在 $x$ 号节点上，并且有一把射程为 $k$ 的枪。

因为小 Z 技术精湛，所以 Youyou 一打就死，而小 Z 永远不会死掉。

小 Z 和 Youyou 都按回合行动，在每一回合中，按照下面的顺序行动：

1. 回合计数器 $+1$（初始为 $0$）。

2. 小 Z 可以用枪射死与小 Z 树上距离小于等于 $k$ 的所有 Youyou。

3. 如果所有 Youyou 都被消灭了，游戏结束，这时回合计数器的值就是小 Z 用的回合数。

4. 小 Z 可以选择沿着一条边，移动到任意相邻节点，也可以选择不动。

5. 所有 Youyou 都会沿着他和小 Z 的简单路径向小 Z 移动一条边的距离。如果此时他们在同一个节点，则不动。

小 Z 需要求出消灭所有敌人需要的最小回合数。

## 说明/提示

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/75xvvplh.png)

小 Z 可以在第一回合射死后两个 Youyou，然后从节点 $5$ 移动到节点 $2$。剩余的两个 Youyou 也会移动到节点  $2$。第二回合小 Z 可以消灭所有 Youyou。可以证明这就是最优方案。

**数据规模与约定**

* Subtask 1（10 分）：$1 \le n,m \le 20$；
* Subtask 2（15 分）：$1 \le n,m \le 2\times 10^3$；
* Subtask 3（30 分）：$1 \le n,m \le 4\times 10^4$；
* Subtask 4（45 分）：$1 \le n,m \le 4\times 10^5$。

对于全部的数据，$1 \le n,m \le 4\times 10^5$，$0 \le k \le 10^6$。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
5
1 2 3 4 5
0 3```

### 输出

```
3```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5
4
1 1 2 2
1 5```

### 输出

```
2```

# 题解

## 作者：SymphonyOfEuler (赞：10)

题目意思比较清楚，不解释。

思路：

这题可以用DFS序线段树做。DFS序线段树就是在线段树操作之前DFS把这个树跑一遍，相当于DFS遍历一遍，把每个点以遍历的顺序标号。根据题目条件，小Z 初始时在 $x$ 节点上，我们可以设想一棵树的根为 $x$，若我们DFS遍历这棵树，所有与小Z的深度小于等于 $k$ 的 Youyou 都会被消灭，深度大于的则不被消灭。需要消灭其他的 Youyou，他必须考虑往哪里走，小Z这个点有可能有若干个孩子，往哪个孩子走呢？我们通过距离观察可以得到要往子树最深的那个点走，因此，我们的选择方法其实是用贪心的。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1uqcxu3l.png)

我们给每个有 Youyou 点一个权值，表示离根多远，方便查询。我们用线段树维护区间最大值，就知道往哪里走了。

考虑达到新点之后的操作，不能再以新的节点为根遍历一遍，否则复杂度会很高。要使用换根的方法优化复杂度。

设新点为 $new$，当要确定 $now$ 往哪边走的时候，可以看他的子树，还有一种情况就是往他的父亲节点方向走。以你父亲为根的子树怎么办？若整个区间为 $[1,n]$，要求出了 $new$ 为根的子树其他的部分的答案，就是要把以 $new$ 为根的子树除去。所以只需要计算两个部分答案，分别是 $[1,pre[new]-1]$ 和 $[pre[new]+siz[new],n]$。这个可以用两次线段树查询的合并来求。

做一个思路的总结：

先以 $x$ 为根DFS遍历，预处理出 $pre$ 数组。搭建DFS序列，并且建线段树。

然后用线段树查 $x$ 点每个孩子子树的最大值，确定往哪里走。往那个点走一步，把这个点为根子树的所有点的权$-2$。只要时间不为零，重复。统计回合数，最后输出。

注意事项：

- 前项星pool数组开2倍

- 线段树开4倍

代码：

```
/* by JS */

#include <bits/stdc++.h>

using namespace std;

const int MAXN = 4 * 1e5 + 5;

#define lc p << 1

#define rc p << 1 | 1

int n, m, k, x, Count, nn, cnt, head[MAXN], pre[MAXN], dep[MAXN], fa[MAXN], siz[MAXN], id[MAXN], kc[MAXN], Max[
        4 * MAXN], Tag[4 * MAXN], maxnum, pos;

bool hasyy[MAXN], flag;

struct Node {
    int v, nxt;
} pool[2 * MAXN];

inline int init(int u, int father) {
    cnt++;
    pre[u] = cnt, dep[u] = dep[father] + 1, fa[u] = father, siz[u] = 1, id[cnt] = u;
    if (hasyy[u]) kc[u] = dep[u];
    for (int i = head[u]; i > 0; i = pool[i].nxt) {
        if (pool[i].v == father) continue;
        siz[u] += init(pool[i].v, u);
    }
    return siz[u];
}

void add(int u, int v) {
    nn++;
    pool[nn].v = v;
    pool[nn].nxt = head[u];
    head[u] = nn;
}

struct Segment_Tree {
    static void push_up(int p) {
        Max[p] = max(Max[lc], Max[rc]);
    }

    inline void build_tree(int p, int l, int r) {
        if (l == r) {
            Max[p] = kc[id[l]];
            return;
        }
        int mid = (l + r) / 2;
        build_tree(lc, l, mid);
        build_tree(rc, mid + 1, r);
        push_up(p);
    }

    static void move_tag(int p, int tag) {
        int maxn = Max[p];
        Max[p] = max(0, maxn + tag);
        Tag[p] += tag;
    }

    static void push_down(int p) {
        if (Tag[p]) {
            move_tag(lc, Tag[p]);
            move_tag(rc, Tag[p]);
            Tag[p] = 0;
        }
    }

    inline int query_max(int p, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return Max[p];
        push_down(p);
        int res = 0;
        int mid = (l + r) / 2;
        if (ql <= mid) {
            res = max(res, query_max(lc, l, mid, ql, qr));
        }
        if (mid < qr) {
            res = max(res, query_max(rc, mid + 1, r, ql, qr));
        }
        return res;
    }

    inline int dfs_query(int cur) {
        if (cur != fa[x]) {
            int ql = pre[cur];
            int qr = pre[cur] + siz[cur] - 1;
            return query_max(1, 1, n, ql, qr);
        }
        int res = 0;
        if (pre[x] - 1 > 0) {
            int qr = pre[x] - 1;
            res = query_max(1, 1, n, 1, qr);
        }
        if (pre[x] + siz[x] <= n) {
            int ql = pre[x] + siz[x];
            res = max(res, query_max(1, 1, n, ql, n));
        }
        return res;
    }

    inline void update(int p, int l, int r, int ql, int qr, int q) {
        if (ql <= l && r <= qr) {
            Max[p] = max(Max[p] + q, 0);
            Tag[p] += q;
            return;
        }
        push_down(p);
        int mid = (l + r) / 2;
        if (ql <= mid) {
            update(lc, l, mid, ql, qr, q);
        }
        if (mid < qr) {
            update(rc, mid + 1, r, ql, qr, q);
        }
        push_up(p);
    }

    inline void dfs_update(int cur, int q) {
        if (cur != fa[x]) {
            int ql = pre[cur];
            int qr = pre[cur] + siz[cur] - 1;
            update(1, 1, n, ql, qr, q);
        } else {
            if (pre[x] - 1 > 0) {
                int qr = pre[x] - 1;
                update(1, 1, n, 1, qr, q);
            }
            if (pre[x] + siz[x] <= n) {
                int ql = pre[x] + siz[x];
                update(1, 1, n, ql, n, q);
            }
        }
    }
} segtree;

inline void solve() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 0, u, v; i < n - 1; ++i) {
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    cin >> m;
    while (m--) {
        int a;
        cin >> a;
        hasyy[a] = true;
    }
    cin >> k >> x;
    dep[0] = -1;
    init(x, 0);
    segtree.build_tree(1, 1, n);
    while (1) {
        pos = maxnum = flag = 0;
        ++Count;
        for (int i = head[x]; i > 0; i = pool[i].nxt) {
            if (!segtree.dfs_query(pool[i].v)) continue;
            if (maxnum < segtree.dfs_query(pool[i].v)) {
                maxnum = max(maxnum, segtree.dfs_query(pool[i].v));
                pos = pool[i].v;
                flag = false;
            } else if (maxnum == segtree.dfs_query(pool[i].v)) flag = true;
        }
        if (maxnum <= k) break;
        if (flag) {
            segtree.update(1, 1, n, 1, n, -1);
            continue;
        }
        segtree.dfs_update(pos, -2), x = pos;
    }
    cout << Count << '\n';
}

int main() {
    solve();
    return 0;
}

```



---

## 作者：Tony2 (赞：9)

别的题解都有证明小Z可以一直向一个点走，走到后停住，等待Youyou过来。

于是我就有个很简单的方法：直接用线段树。

每个Youyou肯定是一直向小Z靠近的，也可能距离不变。所以只要考虑距离结束位置最远的Youyou（Youyou要不然在小Z到达后一枪射死，要不然一直想结束位置靠近）。

线段树就超级无脑了，做一个dfs序（就可以实现区间操作），然后直接维护距离+最大值就可以了。

注：虽然不是每个点都有Youyou，可能减出负数距离，但没有关系，取的是最大值。我的代码需要去重Youyou的位置，不然线段树会出错。

最后献上我又臭又长的代码qwq

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 400005;
int n, m, p, rt, tot=0, ans=0x3f3f3f3f;
int L[N], R[N], C[N], de[N], pos[N];
map<int, int> mp;
vector<int> e[N];
struct tree{//线段树基本操作
	int a[N<<2], sign[N<<2];
 	void update(int now, int l, int r, int k){
 		a[now] += k;
 		sign[now] += k;
 	}
	void down(int now, int l, int r){
		int mid = (l+r)>>1;
		update(now<<1, l, mid, sign[now]);
		update(now<<1|1, mid+1, r, sign[now]);
		sign[now] = 0;
	}
	void add(int now, int l, int r, int s, int t, int k){
		if (s <= l && r <= t){
			a[now] += k;
			sign[now] += k;
			return;
		}
		down(now, l, r);
		int mid = (l+r)>>1;
		if (s <= mid) add(now<<1, l, mid, s, t, k);
		if (t > mid) add(now<<1|1, mid+1, r, s, t, k);
		a[now] = max(a[now<<1], a[now<<1|1]);
	}
	int ask(int now, int l, int r, int s){
		if (l == r) return a[now];
		down(l, r, now);
		int mid = (l+r)>>1, res;
		if (s <= mid) res = ask(now<<1, l, mid, s);
		else res = ask(now<<1|1, mid+1, r, s);
		return res;
	}
}T;
void dfs1(int u, int fa){//求dfs序
	C[u] = ++tot;
	L[u] = tot;
	for (int i = 0; i < e[u].size(); i++){
		int v = e[u][i];
		if (v == fa) continue;
		de[v] = de[u]+1;
		dfs1(v, u);
	}
	R[u] = tot;
}
void dfs2(int u, int fa){
	ans = min(max(de[u]+1, T.a[1]-p+1), ans);
//	cout << u << "  in  "; for (int i = 1; i <= n; i++) cout << T.ask(1, 1, n, i) << ' ';
//	cout << endl;
	for (int i = 0; i < e[u].size(); i++){
		int v = e[u][i];
		if (v == fa) continue;
		T.add(1, 1, n, 1, n, 1);
		T.add(1, 1, n, L[v], R[v], -2);//其实就是子树距离-1，其他+1
		dfs2(v, u);
		T.add(1, 1, n, 1, n, -1);
		T.add(1, 1, n, L[v], R[v], 2);//要复原回去，才能给后来的用
	}
//	cout << u << " out  "; for (int i = 1; i <= n; i++) cout << T.ask(1, 1, n, i) << ' ';
//	cout << endl;
}
int main(){
	std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
//	freopen("test_file/in.txt", "r", stdin);
//	freopen("test_file/out.out", "w", stdout);
	cin >> n;
	for (int i = 1; i < n; i++){
		int u, v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	cin >> m;
	for (int i = 1; i <= m; i++){
		cin >> pos[i];
		if (mp[pos[i]]) i--, m--;//一定要去重！不然会算多遍距离
		mp[pos[i]] = 1;
	}
	cin >> p >> rt;
	dfs1(rt, 0);
	for (int i = 1; i <= m; i++)
		T.add(1, 1, n, L[pos[i]], L[pos[i]], de[pos[i]]);//距离设置
	dfs2(rt, 0);
	cout << ans;
	return 0;//结尾散花！
}
```

---

## 作者：RedLycoris (赞：8)

做为出题人来一发（


首先，我们可以想到，敌人有很多是重复的，所以每一个位置上只留一个敌人即可。

然后，我们可以贪心的想：走到一个位置以后，等着别人来送死。

如何求出这个位置？

将这棵树，以任意一个节点为根，遍历一遍。

然后我们需要截取出“有用”的一块。（定义“有用”的一块为会被至少一个人走过的路径）

于是，我们可以让自己的初始位置为根，遍历一边这棵老树。

从所有有用的点出发，往上遍历，途中所有的点都变成有用的点。

然后删掉所有没有用的点即可。

然后，在这棵新的树上，找到最长链。

这个“最优点”一定就是这条最长链的中点了。（它到所有的叶子的距离的最大值最小。）

然后二分答案即可。

对于每一个二分到的值，循环所有有人站着的点，判断它的mid被祖先与你的初始位置的mid辈祖先之间的距离是否$\le k$。

这个距离也可以用LCA求出:```deep[x]+deep[y]-deep[LCA(x,y)]*2```

复杂度：$O(n \times (log n)^2)$

---

优化：对于最后一步，每一次二分只需要枚举3个点(自己，最长链的两端)即可。

并且将二分去掉，直接暴力即可。（删了那个预处理的$nlogn$）

复杂度：$O(n)$


---

## 贪心 证明

为什么这个贪心是正确的？

你要走的话，必定向着敌人走。而且是最远的，不然没有意义。

首先，我们可以选出两个敌人($x$和$y$)，使得他们和自己组成一个三人组，并且x到y的最短路径经过你，且你们三个人之间互相到达的最小距离最大。

然后，假设你和$x$的距离为$a$,你和$y$的距离为$b$。

如果你走向x，杀死他后再返回杀死$y$，那么你走到路程为$max((a-k)/2,0)+max((b-k)/2,0)$

待着不动的话，结果为$max(max(a-k,0),max(b-k,0)) $

当a,b均小于k:都为$0$。√

当$a$或$b$小于$k$(一个):化简为

走向：$(a-k)/2$

不动： $a-k$

于是这个可以特判（??

不，（详细见后文） 

$a,b$均大于$k$：

走向：$(a-k)/2+(b-k)/2=(a+b)/2-k$

不动： $max(a-k,b-k)=max(a,b)-k$    (这里出问题了？？？ 

不，其实没有

因为我们要走到的标准位置上，$a=b$或者$abs(a-b)=1$ 

证毕。 

代码：

```cpp
#include<bits/stdc++.h>
#define uint unsigned int
using namespace std;
template<class T>
class myVector{
    private:
        T* data;
        int len;
        int size;
    public:
        myVector(){
            data=NULL;
            len=size=0;
        }
        void clear(){
            data=NULL;
            len=size=0;
		}
        myVector(int _len){
            data=new T[_len];
            len=_len;
            size=0;
        }
        T& operator[](int index){return data[index];}
        const myVector& push_back(const T tmp){
            if(size>=len){
                T* newData=new T[len*2+1];
                memcpy(newData,data,len*sizeof(T));
                delete []data;
                data=newData;
                len=2*len+1;
            }
            data[size++]=tmp;
            return *this;
        }
        int getSize(){return size;}
};

const uint mxn=4e5+5;
myVector<uint>g[mxn];
uint n,m,k,p[mxn],hv[mxn],son[mxn];
uint deg[mxn],par[mxn],deep[mxn];
myVector<uint>alive;
bool used[mxn];
bool ban[mxn];
void goup(register uint x){
	if(used[x] or ban[x])return;
	used[x]=1;
	for(register uint i=0;i<g[x].getSize();++i)if(deep[g[x][i]]<deep[x])goup(g[x][i]);
}
uint dfs(register uint x,uint pa,uint dep){
	if(ban[x])return 0;
	par[x]=pa,deep[x]=dep,son[x]=1;
	for(register uint i=0;i<g[x].getSize();++i)if(g[x][i]!=pa)son[x]+=dfs(g[x][i],x,dep+1);
	return son[x];
}
myVector<uint>needs;
const uint maxn=5000;
char buffer[maxn],*S,*T;
char Get_Char(){
    if(S==T){
        T=(S=buffer)+fread(buffer,1,maxn,stdin);
        if(S==T)return EOF;
    }
    return *S++;
}

uint read(){
    char c;
    uint re=0,f=0;
    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;
    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();
    if(f)return -re;
    return re;
}

void read(register uint&x){
    char c;
    uint re=0,f=0;
    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;
    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();
    if(f)x=-re;
    else x=re;
}
inline int lca(int a,int b){
	if(deep[a]>deep[b])swap(a,b);
	for(;deep[b]>deep[a];)b=par[b];
	for(;a!=b;)a=par[a],b=par[b];
	return a;
}
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	read(n);
	for(register uint i=1,u,v;i<n;++i){
		read(u),read(v);
		g[u].push_back(v);
		g[v].push_back(u);
		++deg[u],++deg[v];
	}
	read(m);
	for(register uint i=1;i<=m;++i)read(p[i]),hv[p[i]]=1;
	read(k),read(p[m+1]);hv[p[m+1]]=1;
	dfs(1,1,1);
	myVector<uint>vhv;vhv.clear();
	for(register uint i=1;i<=n;++i)if(hv[i])vhv.push_back(i);
	uint Root=vhv[0];
	dfs(Root,Root,1);
	for(register uint i=0;i<vhv.getSize();++i)goup(vhv[i]);
	for(register uint i=1;i<=n;++i)if(!used[i])ban[i]=1;
	alive.clear();
	for(register uint i=1;i<=n;++i)if(!ban[i])alive.push_back(i);
	if(!alive.getSize()){
		cout<<1<<endl;
		return 0;
	}
	memset(par,0,sizeof(par));
	dfs(alive[0],alive[0],1);
	uint mx=0,wz=0;
	uint po1,po2;
	for(register uint i=1;i<=n;++i)if(!ban[i] and deep[i]>mx){
		mx=deep[i];
		wz=i;
	}
	po1=wz; 	
	dfs(wz,wz,1);
	mx=0,wz=0;
	for(register uint i=1;i<=n;++i)if(!ban[i] and deep[i]>mx){
		mx=deep[i];
		wz=i;
	}
	po2=wz;
	uint mypos=p[m+1];
	uint ln=deep[po2]-1;
	uint md=po2;
	for(register uint i=1;i<=ln/2;++i)md=par[md];
	dfs(md,md,1);Root=md;
	needs.push_back(po1);needs.push_back(po2);needs.push_back(p[m+1]);
	uint a=po1,b=po2,c=p[m+1];
	bool da=0,db=0;
	int lac=lca(a,c),lbc=lca(b,c);
	bool ha=0,hb=0;
	for(register uint ans=1;ans<=ln;++ans){
		if(!da and deep[c]+deep[a]-2*deep[lac]<=k)da=1;
		if(!db and deep[c]+deep[b]-2*deep[lbc]<=k)db=1;
		if(da and db){
			cout<<ans<<'\n';
			return 0;
		}
		if(a==lac or c==lac)ha=1;
		if(b==lbc or c==lbc)hb=1;
		if(a!=md)a=par[a];
		if(b!=md)b=par[b];
		if(c!=md)c=par[c];
		if(ha)lac=par[lac];
		if(hb)lbc=par[lbc];

	}
	return 0;
}
```

---

## 作者：言琢დ (赞：4)

### 题意简述

给定一棵 $n$ 个点、边权均为 $1$ 的树，其中 $m$ 个点上有小怪。

你的初始位置是 $x$，每回合你会沿着树的某一条边移动 $1$ 格（或不动），小怪们也会沿着树的某一条边 **向你的方向** 移动 $1$ 格。

你有一把射程为 $k$ 的手枪，即当某个怪的距离 $\le k$ 时你可以击杀它。

求当你采用最优策略移动时，多少个回合可以击杀所有的小怪。

### 思路分析

首先给出两个结论：（假设已经把没有小怪的叶子结点 **全部剥离**，树剩下的叶子结点全部是有小怪的）

1. 比较明显的最优策略是一路向前，到某个比较靠中间的位置，等小怪们来送人头。

理由是如果你为了去击杀某个小怪走了回头路，不如先杀掉另一个小怪再出发。

2. 结论 1 中所述的位置，应为树的直径的中点。

理由是当你停留在该点时，可以最小化树的半径，而树的半径便直接决定了小怪需要多久才能走进你的射程范围。

考虑如何找到树的直径的中点，我们以 $x$ 为根连续 “吊” 两次树，第一次找到最深点 $a$，第二次以 $a$ 为根再找到最深点 $b$。

根据树的直径的性质，$a$ 和 $b$ 即为树的直径的两个端点，取它们的中点 $mid$ 即为树的直径的中点。

此后，以 $mid$ 为根，进行第四次 dfs，暴力地让 $a,b,x$ 三个点向上跳，直到三个点的距离满足 $\text{dis}(a,x)\le k$ 且 $\text{dis(b,x)}\le k$。

### 参考代码

参考代码中，`dfs1` 对应了思路分析中 **剥离** 的过程，`dfs2` 对应了 **找到最深点 $a$ 和 $b$** 以及最后一次以 $mid$ 为根重新 “吊” 一遍整棵树的过程。

由于 `dfs2` 过程反复被使用，因此相关的数组注意清空，事实上，仅清空每一次使用的根结点的 $dep$ 值即可，因为之后的 $dep$ 值均由该点的 $dep$ 计算而来。

```cpp
// init() 和 print() 表示快读快输，mn() 和 mx() 表示取最小最大值
const int N = (int) 4e5 + 5;
struct Node{
	int next, to;
} s[N << 1]; int head[N], sLen;
void add(int u, int v){
	s[++sLen].next = head[u];
	s[sLen].to = v;	head[u] = sLen;
	s[++sLen].next = head[v];
	s[sLen].to = u;	head[v] = sLen;
}
bool ok[N]; // 该点是否为有效点
void dfs1(int u, int fa){
	for (int i = head[u]; i; i = s[i].next) {
		int v = s[i].to;
		if (v == fa) continue;
		dfs1(v, u);
		ok[u] |= ok[v]; // 所有叶子到根的路径均有用
	}
}
int n, dep[N], fa[N];
void dfs2(int u, int father){
	fa[u] = father;
	for (int i = head[u]; i; i = s[i].next) {
		int v = s[i].to;
		if (v == father || !ok[v]) continue; // 无效点不遍历
		dep[v] = dep[u] + 1;
		dfs2(v, u);
	}
}
int LCA(int u, int v){ // 暴力求 LCA
	if (dep[u] < dep[v]) u ^= v ^= u ^= v;
	while (dep[u] != dep[v]) u = fa[u];
	while (u != v) u = fa[u], v = fa[v];
	return u;
}
int main(){
	n = init();
	for (int i = 1; i < n; ++i) add(init(), init());
	int m = init(); // 有效点个数
	for (int i = 1; i <= m; ++i) ok[init()] = true; // 有用点
	int k = init(), x = init(); // 射程，起点
	dfs1(x, x); // 重新建图，此后在新树上遍历
	memset(dep, 0, sizeof(dep)); dfs2(x, x);
	int a = x;
	for (int i = 1; i <= n; ++i) if (dep[i] > dep[a]) a = i; // 吊第一次，找到最深点 a
	memset(dep, 0, sizeof(dep)); dfs2(a, a);
	int b = a;
	for (int i = 1; i <= n; ++i) if (dep[i] > dep[b]) b = i; // 吊第二次，找到最深点 b
	int mid = b; // 直径的两个端点分别为 a 和 b，直径的中心是 mid
	for (int i = 1; i <= dep[b] / 2; ++i) mid = fa[mid]; // 找到直径的中心
	dfs2(mid, mid); // 此后把树用中心吊起来
	int lca1 = LCA(a, x), lca2 = LCA(b, x); // 分别找到 a 和 x 的 lca，b 和 x 的 lca
	bool flag = true;
	for (int ans = 1; flag; ++ans)
		if (dep[a] + dep[x] - dep[lca1] * 2 <= k && dep[b] + dep[x] - dep[lca2] * 2 <= k)
			print(ans), putchar('\n'), flag = false; // 若 dis(a, x) <= k 且 dis(b, x) <= k 则输出答案
		else a = fa[a], b = fa[b], x = fa[x]; // 否则全部向直径的中心移动 1 格
}
```

---

## 作者：kkxacj (赞：3)

妙妙思维题

#### 思路

那个名字太复杂了，我们在这里记 A 为小 Z，B 为 Youyou。

先看每次结束后可能的影响，我们先求出每个 B 离 A 的距离，显然 B 位置重合只用记一个，如果距离已经小于等于 $k$ 了也继续减，我们认为结束条件就是每个 B 距 A 的距离都小于等于 $k$。

1. A 从 $u$ 走向 $v$，所有 $v$ 子树内的 B 距离减二，其它不变。
2. A 不动，所有 B 距离减一。

麻烦的其实就是因为 A 可能乱走会走回去，导致不好算答案。

不过容易发现，A 要是走的路径为 $u$ 到 $v$ 再到 $u$，那么就是每个 B 距离 A 距离减二，这还不如站着不动呢。

那么得出关键性质，我称它为**小 A 一去不复返**。

小 A 多久不动其实都是一样的，我们不妨让它在最后到的点那里不动，直接跑，然后记一下所有 B 到点 $u$ 的最大值和 $u$ 到初始点的距离即可，这个很典，相信能做这种题了应该都会，就不写了，具体可以看代码。

**code**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 4e5+10;
int n,m,k,X,x,y,a[N],head[N],cnt,v[N],dep[N],mx[N],ans[N],mi,o;//mx_i:子树中需要kill的人最大深度，没有就是0(因为X为0) 
struct w
{
	int to,nxt;
}b[N<<1];
inline void add(int x,int y)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	dep[x] = dep[y]+1;
	if(v[x]) mx[x] = dep[x];
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
			dfs(b[i].to,x),mx[x] = max(mx[x],mx[b[i].to]);
}
void dfs1(int x,int y,int z)//z为子树外的点到它的最大值 
{
	int mx1 = 0,cmx = 0; ans[x] = 1e9;
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
		{
			if(mx[b[i].to] > mx1) cmx = mx1,mx1 = mx[b[i].to]; 
			else if(mx[b[i].to] > cmx) cmx = mx[b[i].to];//记一下子树的最大值和最小值 
		}
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y)
		{
			if(mx[b[i].to] == mx1) o = cmx;
			else o = mx1;
			dfs1(b[i].to,x,max(z,o-dep[x]*2));
		}
	ans[x] = dep[x]+max(0ll,max(z,mx1-dep[x]*2)-k);//走过来的时间加等待的，这个ans其实是多余的 
//	cout<<x<<" "<<ans[x]<<" "<<dep[x]<<" "<<z<<" "<<mx1<<endl; 
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(int i = 1;i < n;i++) read(x),read(y),add(x,y),add(y,x);
	read(m);
	for(int i = 1;i <= m;i++) read(a[i]),v[a[i]] = 1;//位置相同其实不用管的，原因显然
	read(k),read(X); dep[0] = -1,dfs(X,0); dfs1(X,0,0);
	mi = 1e9;
	for(int i = 1;i <= n;i++) mi = min(mi,ans[i]);
	print(mi+1); flush();
	return 0;
}
/*
回归老本行了继续写思维题（ 
不妨设为A要杀m个B，一颗树，最小时间 
最小时间能不能套路的二分一下（
显然每次A与它选择的那个子树里面的B距离减二，其它的距离不变/不动，所有距离减一
我想想，假设我先走在回来，就是花了2时间，但是所有人还是减了2距离！
所以，结论应当是：小A一去不复返，即只会是待一会，继续向下，不会走回头路
设走是1，等是0
10和01的区别（假设1都是走到同一个点）
发现没有区别，写个什么dp吗？
哦不用，直接跑就好了
现在唯一问题就是解决那啥杀B
考虑跑的时候搞一下，由于杀人不需要时间，我们只考虑等了多久
每次下来就取个max，然后就没了 
同为思维题这不比那啥移球游戏好多了（
诶怎么比答案小一，原来是先加时间在走 
*/ 
```

---

## 作者：Little_x_starTYJ (赞：2)

作为校内大统考模拟赛（新初二、新初三、新高一同时考）的 T2，也是成功场切，似乎也是第一次场切树上的 dp 问题。但是同样很签的 T3（[P11410](https://www.luogu.com.cn/problem/P11410)）矩阵快速幂没调出来，似乎也是第一次现场写矩阵快速幂代码。

我觉得这场比赛都是好题，所以把是原的 [T2](https://www.luogu.com.cn/problem/P6584)，[T3](https://www.luogu.com.cn/problem/P11410)，[T4](https://codeforces.com/problemset/problem/475/E)，[T5](https://www.luogu.com.cn/problem/P10107) 都放这里了，大家没兴趣的话都去瞅一眼，有兴趣的话可能已经做过了。

## 解题思路
模拟赛中运题人把题面改写成了奶龙大战爆爆龙。大家可以看看那个《妙妙》的运题人题解，挺好的。

废话不多说，回归正题。

题目大意就是：奶龙和笨笨的爆爆龙会在一棵城市树上大战，其中爆爆龙的数量很多，每个回合会依次进行如下操作：奶龙有一个二向箔，可以瞬间二维化距离奶龙为 $k$ 以内的所有爆爆龙，如果所有爆爆龙都被二维化，那么大战结束，奶龙胜利（奶龙必胜），接着奶龙可以移动到相邻城市或不动，所有三维的爆爆龙会朝奶龙现在所在城市移动一次，问最少大战回合。

---
首先我们需要明确一个关于奶龙的性质：~~可爱~~她不走回头路且一定会朝距离最远的爆爆龙进军且最终一定会在某个点苟到最后。下面简单说明一下：

#### 走回头路的情况
如果她 $u \to v \to x \to v$，则目前一共进行了三次大战，当她走 $u\to v \to x$ 这条路时，在 $x$ 的子树（这里就是去掉 $u \to v$ 这条路径上的点后 $x$ 可以到达的点集）内的所有爆爆龙与她的距离都会减少 $4$，因为奶龙朝她们走了两步，她们又朝奶龙走了两步。

同理当她走 $x \to v$ 这条路时，$v$ 的子树内的所有爆爆龙与她的距离都会减少 $2$，但是 $x$ 子树内的爆爆龙与她的距离不变。

#### 不走回头路的情况
但是别忘了她还可以不动呀！

当然先前进再停止等价于先停止再前进，所以如果我们在 $x$ 停止相当于先在 $u$ 停留相同时间。那么在 $u$ 停留时，所有爆爆龙与她的距离都会减少 $1$，那么在 $u$ 停留 $2$ 个单位时间等价于来回走动 $2$ 次。那可以等到只剩下 $1$ 个点了再朝走，这个点明显就是距离最远的点。

#### 结论
因此可以得到不走回头路的情况一定优，且一定会朝最远的点走，且最后会停留在某个点。

## 算法
直接换根 dp，记录一下每个点 $u$ 与初始点 $x$ 的距离加上对于 $u$ 最远的爆爆龙的距离，暴力遍历一遍即可。

算法总时间复杂度约为 $\mathcal{O}(n)$。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;
vector<int> v[N];
bool vis[N];
int maxx[N], ans = 1e18, k, x;
inline void dfs(int x, int fa) {
	for (auto u : v[x]) {
		if (u ^ fa) {
			dfs(u, x);
			maxx[x] = max(maxx[x], maxx[u] + 1);
		}
	}
}
inline void dfs2(int x, int fa, int dep, int now) {
	ans = min(ans, dep + max(0ll, max(now, maxx[x] - dep) - k));
	int max1 = -1e18, max2 = -1e18;
	for (auto u : v[x]) {
		if (u ^ fa) {
			if (maxx[u] > max1) {
				max2 = max1;
				max1 = maxx[u];
			} else {
				max2 = max(max2, maxx[u]);
			}
		}
	}
	for (auto u : v[x]) {
		if (u ^ fa) {
			int res = max1;
			if (maxx[u] == max1) {
				res = max2;
			}
			dfs2(u, x, dep + 1, max(now, res - dep + 1));
		}
	}
}
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i < n; i++) {
		maxx[i] = -1e18;
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	maxx[n] = -1e18;
	int m;
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int x;
		cin >> x;
		vis[x] = 1;
		maxx[x] = 0;
	}
	cin >> k >> x;
	dfs(x, 0);
	dfs2(x, 0, 0, 0);
	cout << ans + 1;
	return 0;
}
```

---

## 作者：Rain_chr (赞：2)

简要说明一下我的做法：

先以当前小 Z 在的点 x 为根

1. 如果 Youyou 在不同的子树

	x 不动
    
2. 如果 Youyou 在同一个子树

	x 朝这个子树走一步
   
这样做的正确性我是这样想的：

对于情况 2，操作的正确性十分显然，所以只用证明为什么情况 1 时不动是最好的选择。

假设有两个 Youyou 在不同的子树，分别在 $y,z$ 两个点上。

如果 $x$ 朝 $y$ 走了一步，那么 $dis(x,y)\gets dis(x,y)-2,dis(x,z)$ 不变，先朝 $y$ 走再向 $z$ 走的代价是 

$$\lceil \frac{dis(x,y)}{2} \rceil+\lceil \frac{dis(x,z)}{2} \rceil$$

考虑另一种情况，$x$ 不动，其代价即为 

$$\min(dis(x,y),dis(x,z))+\lceil \frac{\max(dis(x,y),dis(x,z))-\min(dis(x,y),dis(x,z))}{2} \rceil$$


如果 $dis(x,y),dis(x,z)$ 均为奇数，那么不动的代价比动的代价小，否则代价一样，所以在情况 1 时不动是更优的。

所以就得到了一种更好写的新做法。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+10;
vector<int> a[N];
int bz[20][N],d[N],dfn[N],siz[N],cnt;
int n;
void dfs(int x,int fa)
{
    dfn[x]=++cnt;
    d[x]=d[fa]+1;
    bz[0][x]=fa;
    siz[x]=1;
    for(int to:a[x])
    {
        if(to==fa) continue;
        dfs(to,x);
        siz[x]+=siz[to];
    }
}
int lca(int x,int y)
{
    if(d[x]<d[y]) swap(x,y);
    for(int i=log2(d[x]);i>=0;i--)
        if(d[bz[i][x]]>=d[y])
            x=bz[i][x];
    if(x==y) return x;
    for(int i=log2(d[x]);i>=0;i--)
        if(bz[i][x]!=bz[i][y])
            x=bz[i][x],y=bz[i][y];
    return bz[0][x];
}
int dis(int x,int y)
{
    return d[x]+d[y]-2*d[lca(x,y)];
}
int c[N];
int lowbit(int x){return x&-x;}
void add(int x,int v){while(x<=n){c[x]+=v,x+=lowbit(x);}}
int query(int x){int ans=0;while(x){ans+=c[x],x-=lowbit(x);}return ans;}
int key[N];
int jump(int x,int y)
{
    for(int i=log2(d[x]);i>=0;i--)
        if(d[bz[i][x]]>d[y])
            x=bz[i][x];
    return x;
}
signed main()
{
    // freopen("1.in","r",stdin);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        a[x].push_back(y);
        a[y].push_back(x);
    }
    dfs(1,0);
    for(int i=1;(1<<i)<=n;i++)
        for(int j=1;j<=n;j++)
            bz[i][j]=bz[i-1][bz[i-1][j]];
    int m;
    cin>>m;
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
    for(int i=1;i<=m;i++) cin>>key[i];
    int k,s;
    cin>>k>>s;
    for(int i=1;i<=m;i++)
    {
        add(dfn[key[i]],1);
        q.push(make_pair(dis(key[i],s),key[i]));
    }
    int ans=0,del=0;
    while(q.size())
    {
        ans++;
        while(q.size()&&q.top().first-del<=k)
        {
            add(dfn[q.top().second],-1);
            q.pop();
        }
        if(q.empty()) break;
        int x=q.top().second,l=lca(x,s);
        if(l==s)
        {
            x=jump(x,s);
            if(query(n)==query(dfn[x]+siz[x]-1)-query(dfn[x]-1)) del++,s=x;
        }
        else if(query(dfn[s]+siz[s]-1)-query(dfn[s]-1)==0) del++,s=bz[0][s];
        del++;
    }
    cout<<ans;
	return 0;
}
```

---

## 作者：λᴉʍ (赞：2)

显然$k$可以改为一开始每个敌人直接向$x$走$k$步，考虑$k=0$。

可以感性理解最终操作是小Z走到一个点并停止直到所有敌人死亡。（首先可以发现只有最后一枪有用，那么知道了最终节点$t$之后要让敌人尽可能接近$t$当然要直接走过去了）

固定$t$，以小Z初始节点为根，到$t$的路径为$a_1=x,a_2,\dots,a_s=t$。

那么考虑在$a_i$子树中且不在$a_{i+1}$子树中的敌人（设该点与$x$距离是$d$）：  
它们在向上走$i-1$步（如果碰到了小Z则不管）后小$Z$的位置是$a_i$，此后它们的距离一直保持不变（为$\max(0,d-2(i-1))$）。到最后小Z就要花至少$\max(0,d-2(i-1))$回合才能打到这个敌人。  
那么固定了$t$以后，其实答案就是上述$\max(0,d-2(i-1))$最大值加1再加$dist(x,t)$.

设$f_i$为：考虑在$a_i$子树中且不在$a_{i+1}$子树中的敌人，它们**与$a_i$距离**的最大值。答案也就是$\max_i\{i-1+\max\{0,f_i-i+1\}\}+1$。如果不把$k$设为$0$则答案是$\max_i\{i-1+\max\{0,f_i-i+1-k\}\}+1$，也是模拟先跳$k$步。

枚举$t$并直接算答案，这个做法是$n^2$的。优化也很显然，考虑dfs一遍在栈上统计，只需设$f_i$为i子树敌人到$i$距离最大值，以及$g_i$为点$i$的父亲挖掉子树$i$后的$f$，就可以直接dfs统计了。求出$f$后，只需多记录$f$的次大值即可得出$g$。


```cpp
#include<bits/stdc++.h>
typedef long long ll;
#define fl fflush(stdout)
ll gi(){
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))f^=ch=='-',ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return f?x:-x;
}
std::mt19937 rnd(time(NULL));
#define rand rnd
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
template<class T>void cxk(T&a,T b){a=a>b?a:b;}
template<class T>void cnk(T&a,T b){a=a<b?a:b;}
#ifdef mod
int pow(int x,int y){
	int ret=1;
	while(y){
		if(y&1)ret=1ll*ret*x%mod;
		x=1ll*x*x%mod;y>>=1;
	}
	return ret;
}
template<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}
template<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}
#endif
int k,fir[400010],dis[800010],nxt[800010],id;
void link(int a,int b){nxt[++id]=fir[a],fir[a]=id,dis[id]=b;}
int s[400010],ans=1e9;
int f[400010],cf[400010],g[400010];
void DFS(int x,int fa=-1){
	f[x]=cf[x]=-1e9;
	if(s[x])f[x]=0;
	for(int i=fir[x];i;i=nxt[i]){
		if(dis[i]==fa)continue;
		DFS(dis[i],x);
		if(f[dis[i]]+1>f[x])cf[x]=f[x],f[x]=f[dis[i]]+1;
		else cxk(cf[x],f[dis[i]]+1);
	}
}
void DFS2(int x,int fa=-1){
	for(int i=fir[x];i;i=nxt[i]){
		if(dis[i]==fa)continue;
		DFS2(dis[i],x);
		g[dis[i]]=(f[dis[i]]+1==f[x]?cf[x]:f[x]);
	}
}
void DFS3(int x,int mx,int dep,int fa=-1){
	cnk(ans,dep+std::max(0,std::max(mx,f[x]-dep)-k));
	for(int i=fir[x];i;i=nxt[i]){
		if(dis[i]==fa)continue;
		DFS3(dis[i],std::max(g[dis[i]]-dep,mx),dep+1,x);
	}
}
int main(){
#ifdef LOCAL
	freopen("in.in","r",stdin);
	//freopen("out.out","w",stdout);
#endif
	int n=gi(),u,v;
	for(int i=1;i<n;++i)u=gi(),v=gi(),link(u,v),link(v,u);
	int m=gi();
	for(int i=1;i<=m;++i)s[gi()]=1;
	k=gi();int x=gi();
	DFS(x);DFS2(x);DFS3(x,-1e9,0);
	printf("%d\n",std::max(0,ans)+1);
	return 0;
}
```

---

## 作者：0513DTY (赞：1)

来写一篇树的直径的题解

### 思路：

定义小 Z 与 youyou 所在的点为关键点，树的直径长 $d$。

1. 显然，树上不为关键点的叶子节点是没有用的，那么我们就可以把所有不为关键点的叶子节点删去，使用 dfs 可以 $O(n)$ 解决。
2. 考虑 $k=0$ 时怎么做，显然就是 $\lceil \frac{d}{2} \rceil + 1 $，因为任意时刻所有叶子节点都能向内移动，所有叶子节点移动至同一点至多花 $\lceil \frac{d}{2} \rceil $ 步，且回合结束时才能移动，游戏结束则只能在回合开始时，所以是 $\lceil \frac{d}{2} \rceil + 1$。
3. 再来思考 $k>0$ 时怎么做，需要分讨。
- 小 Z 在直径的一端，则答案为 $\lceil \frac{d-k}{2} \rceil + 1 $。
- 小 Z 距离直径两端距离大于 $k$，答案为$\lceil \frac{d - 2 \times k}{2} \rceil + 1$。
- 小 Z 距离直径一端距离小于等于 $k$，设小 Z 与直径另一端距离为 $s$，答案即为$\lceil \frac{s-k}{2} \rceil + 1$。
- 有个细节，答案至少为 $1$，所以答案与 $1$ 要取 max。

时间复杂度 $O(n)$，给出代码，跑的飞快。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct G{
	int vt,nxt;
}g[2000001];
int h[1000001],cnt;
int add(int u,int v){
	g[++cnt]=(G){v,h[u]};
	h[u]=cnt;
	return 0;
}
int m,k,s;
int a[1000001];
int in[1000001];
int d[1000001];
int fde[1000001];
int del(int u){
	fde[u]=1;
	for(int i=h[u];i;i=g[i].nxt){
		int v=g[i].vt;
		in[v]--;
		if(in[v]!=1||fde[v]||a[v])continue;
		del(v);
	}
	return 0;
}
int dfs(int u,int fa){
	for(int i=h[u];i;i=g[i].nxt){
		int v=g[i].vt;
		if(fde[v])continue;
		if(v==fa)continue;
		d[v]=d[u]+1;
		dfs(v,u);
	}
	return 0;
}
int read(){
	int num=0;
	char ac=getchar();
	while(ac<'0'||ac>'9'){
		ac=getchar();
	}
	while(ac>='0'&&ac<='9'){
		num=(num<<1ll)+(num<<3ll)+(ac-'0');
		ac=getchar();
	}
	return num;
}
int main(){
	n=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
		in[u]++,in[v]++;
	}
	m=read();
	for(int i=1;i<=m;i++){
		int p=read();
		a[p]=1;
	}
	k=read(),s=read();
	a[s]=1;
	for(int i=1;i<=n;i++){
		if(in[i]==1&&(!a[i])&&(!fde[i])){
			fde[i]=1;
			del(i);
		}
	}
	dfs(s,0);
	int xid=s,ssum;
	for(int i=1;i<=n;i++){
		if(!fde[i]){
			if(d[xid]<d[i]){
				xid=i;
			}
		}
	}
	ssum=d[xid];
	d[xid]=0;
	dfs(xid,0);
	int sum=0;
	for(int i=1;i<=n;i++){
		if(!fde[i]){
			sum=max(sum,d[i]);
		}
	}
	if(ssum==sum){
		sum=(sum-k+3)>>1;
		if(sum<0)sum=1;
		printf("%d",sum);	
		return 0;
	}
	if(sum-ssum<=k){
		ssum=(ssum-k+3)>>1;
		if(ssum<0)ssum=1;
		printf("%d",ssum);	
		return 0;
	}
	sum=(sum-(k<<1)+3)>>1;
	if(sum<0)sum=1;
	printf("%d",sum);
	return 0;
}
```

---

## 作者：0_lan_0 (赞：1)

# [P6584 重拳出击](https://www.luogu.com.cn/problem/P6584)

提供一种别样的做法，复杂度为 $O(n)$。

首先我们不难发现，当怪物离小 Z 的最大值等于怪物离小 Z 的次大值时，或相差为 1，且这两个点的 lca 为根，我们在原地不动是最优解。

所以我们的思路就是我们移动到一个点，我们走到一个点使怪物离小 Z 的最大值等于怪物离小 Z 的次大值，或相差 1，让怪物自己跳过来，计算答案。

我们以起点为根搜索，怪物的距离也就是它的深度，我们可以在搜索时求出 $i$ 的子树里怪物离小 Z 的最大值和次大值，更新给自己的父亲。有一个细节要注意，当更新的点不为起点时，我们令次大值减 2,如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/giqg5imb.png)

不难发现，当蓝色点一路更新上去时，根节点也可以往下走。所以更新时两点的 lca 不为根时，次大值减 2。

[记录](https://www.luogu.com.cn/record/167656092)
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+10;
struct Edge{
	int to,nxt;
}edge[N<<1];
bitset<N>gw;
int n,head[N],cnt,u,v,k,qd,m,x,dep[N],ans,Max1[N],Max2[N];
void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa){
	if(gw[u])
		Max1[u]=dep[u];
	int M1=0,M2=0;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)
			continue;
		dep[v]=dep[u]+1;
		dfs(v,u);
		if(Max1[v]>=Max1[u])
        	Max2[u]=Max1[u],Max1[u]=Max1[v];
        else if(Max1[v]>Max2[u])
            Max2[u]=Max1[v];
    	if(Max2[v]>Max2[u])
        	Max2[u]=Max2[v];
	}
	if(fa){
        Max2[u]-=2;
        if(Max2[u]<0) Max2[u]=0;
    }
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		cin>>u>>v;
		add(u,v),add(v,u);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
		scanf("%d",&x),gw[x]=1;
	scanf("%d%d",&k,&qd);
	dfs(qd,0);
	if(Max1[qd]>k&&Max2[qd]<=k)
		ans=((Max1[qd]-k+1)>>1)+1;
	else if(Max1[qd]<=k&&Max2[qd]<=k)
		ans=1;
	else if(Max1[qd]>k&&Max2[qd]>k)
		ans=Max2[qd]+((Max1[qd]-Max2[qd]+1)>>1)-k+1;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：intel_core (赞：1)

提供一波$O(n)$的做法   
贪心：   
*   找距离最长的点    
*   找起点到这个点的路径    
*   标记这条路径上的点   
*   找其余点中距离标记点距离最长的点    
每个操作都是$O(n)$的   
但是跑得非常慢    
具体见代码：   
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>
using namespace std;
const int NR=4e5+10;
int dist[NR];
int adding[NR];
int f[NR];
int wxb[NR];
bool flag[NR];
struct edge{
	int to,next;
}g[NR<<1];
int fte[NR];
int tot;
int path[NR];
void add(int x,int y){
	g[++tot]=(edge){y,fte[x]};
	fte[x]=tot;
}
void dfs1(int id,int fath,int k){
	dist[id]=k;
	//预处理每个点的深度
	for(int i=fte[id];i;i=g[i].next)
		if(g[i].to!=fath)
			dfs1(g[i].to,id,k+1);
}
void dfs2(int id,int fath){
	//找距离最远的点
	for(int i=fte[id];i;i=g[i].next)
		if(g[i].to!=fath){
			dfs2(g[i].to,id);
			wxb[id]=max(wxb[id],wxb[g[i].to]);
		}
	if(flag[id])wxb[id]=max(wxb[id],dist[id]);
}
int cnt;
void find_path(int id,int fath){
	//把到最远的点的路径找出来
	int dcx=0,ylx=-1;
	for(int i=fte[id];i;i=g[i].next)
		if(g[i].to!=fath&&dcx<wxb[g[i].to]){
			dcx=wxb[g[i].to];
			ylx=g[i].to;
		}
	if(ylx!=-1){
		path[++cnt]=ylx;
		find_path(ylx,id);
	}
}
void dfs3(int id,int fath,int k){
	//处理每个点到路径上的点的最短距离
	adding[id]=k;
	for(int i=fte[id];i;i=g[i].next)
		if(g[i].to!=fath){
			if(path[dist[id]+1]==g[i].to)dfs3(g[i].to,id,k+2);
			else dfs3(g[i].to,id,k);
		}
}
bool ylx[NR];
int main(int argc, char const *argv[])
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	int n,rt,k,m;
	cin>>n;
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		flag[x]=true;
	}
	cin>>k>>rt;
	dfs1(rt,0,0);
	dfs2(rt,0);
	find_path(rt,0);
	dfs3(rt,0,0);
	for(int i=1;i<=cnt;i++)
		ylx[path[i]]=true;
	int ans=1;
	int lcy=wxb[rt];
	int maxn=0;
	for(int i=1;i<=n;i++)
		if(flag[i]&&ylx[i]==false){
			maxn=max(maxn,dist[i]-adding[i]);
			
		}
	//下面实在是降智，考场上调不出来写的
	//其实就是几个简单的除法运算
	if(k==0){
		//printf("%d\n",k);
		while(lcy>1){
			ans++;
			lcy-=2;
		}
		if(lcy==1){
			maxn--;
			ans++;
		}
		while(maxn>0){
			ans++;
			maxn-=2;
		}
		cout<<ans;
		return 0;
	}
	while(lcy>k){
		ans++;
		lcy-=2;
	}
	maxn=maxn+lcy-k;
	while(maxn>k){
		ans++;
		maxn-=2;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：issue_is_fw (赞：1)

部分思路参考red巨巨%%%

然后因为笔者表达的很差,轻喷...(~~看不懂留言呀反正肯定看不懂~~)

**树型dp+贪心**

## 贪心证明

$首先还是证明一下小z移动路线$

$一定是走到某个终点后就停在那里等别人来送死(其实我想了很久)$

因为我一定向着敌人走,被我向着的敌人每次相对距离$-2$

不被我向着的敌人相对位置不变(他们会跟着我)

$所以我甚至可以说我一定向着最远点走,否则没有意义$

## 枚举答案

令$dis[i]$为点$i$距离最远$youyou$的距离,$deep[i]$是深度

假设所有$dis[i]$被求出来,那我们枚举所有点为终点

点$i$为终点的答案是$deep[i]+max(dis[i]-deep[i]-k,0)+1$

小z因为在根节点,所以走到$i$需要$deep[i]$个回合

其他点要么提前到了点$i$,要么和小z相对距离不变

所以需要比$deep[i]$多$max(dis[i]-deep[i]-k,0)$即可

这个不理解可以画下图,最远点无非是和点$i$同子树和不同子树

不同子树肯定是先到根再到点$i$

同子树如果在点$i$下方就一直往上走到点$i$

不管哪种情况都符合上面的式子

最后一回合开枪打死所有$youyou$,加上$1$结束。


## dp求解dis[i]

状态 $dp[u][0]$：代表 u 这个点 子树方向最远距离

状态 $dp[u][1]$：代表 u 这个点 子树方向次远距离

状态 $dp[u][2]$：代表 u 这个点 父亲方向最远距离

设 v 是 u 的孩子

如果 v 最远距离在 u 的父亲方向

$dist[v][2] = dist[u][2] + dis(u, v)$

否则 v 最远距离在 u 的子树方向

如果 v 在 子树方向最远距离路径上

$dist[v][2] = dist[u][1] + dis(u, v)$

如果 v 不在 子树方向最远距离路径上

$dist[v][2] = dist[u][0] + dis(u, v)$

```
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
const int maxn=4e5+10;
int n,m,k,root;
int dis[maxn],deep[maxn],dp[maxn][3],vis[maxn],pos[maxn];
vector<int>vec[maxn];
void dfs1(int u,int fa)
{
	if( vis[u] )	dp[u][0]=dis[u]=0;
	deep[u]=deep[fa]+1;
	for(int i=0;i<vec[u].size();i++)
	{
		int v=vec[u][i];
		if( v==fa )	continue;
		dfs1(v,u);
		if( dp[v][0]+1>=dp[u][0] )//更新u的最大距离 
		{
			pos[u]=v;
			dp[u][1]=dp[u][0];
			dp[u][0]=dp[v][0]+1;
		}
		else if( dp[v][0]+1>=dp[u][1] )
			dp[u][1]=dp[v][0]+1;
	}
}
void dfs3(int u,int fa)
{
	for(int i=0;i<vec[u].size();i++)
	{
		int v=vec[u][i];
		if( v==fa )	continue;
		if( pos[u]==v )	dp[v][2]=max(dp[u][1],dp[u][2])+1;
		else	dp[v][2]=max( dp[u][0],dp[u][2] )+1;
		dfs3(v,u);
	}	
	dis[u]=max( dp[u][2],dp[u][0] );
}
int main()
{
	cin >> n;
	memset(dp,-0x3f,sizeof(dp));
	memset(dis,-0x3f,sizeof(dis));
	for(int i=1;i<n;i++)
	{
		int l,r;
		cin >> l >> r;
		vec[l].pb(r),vec[r].pb(l);	
	}
	cin >> m;
	for(int i=1,s ;i<=m;i++)	
	{
		cin >> s;
		vis[s]=1;//标记youyou在的点 
	}
	cin >> k >> root;
	deep[0]=-1;	
	dfs1(root,0);
	dfs3(root,0);
	int minn=1e9;
	for(int i=1;i<=n;i++)
		minn = min(minn,deep[i]+max(dis[i]-deep[i]-k,0)+1);
	cout<<max(0,minn);
} 
```

---

## 作者：xiao7_Mr_10_ (赞：0)

清一色的换根 dp，实际上我们有一个基于树的直径做法。

首先我们以初始节点 $x$ 为根，这样所有 Youyou 的路径都是向根走的。为了消除距离 $K$ 的限制，我们可以**假定所有人走了** $K$ 次，即求每个点 $K$ 级祖先。把无用的点去掉，这样就转化为原问题中 $K=0$ 时的情况了。

这样做有一个好处，我们发现答案的上界是距离根节点最远的那个点的深度，简记该点为 $u$。如果我们想让答案更小，就必须让小 Z 从根节点向 $u$ 走。容易发现走的过程中由于其他人追不上小 Z 便导致答案和 $u$ 无关。换句话说就是走的太远了，得不偿失。我们发现当点 $u$ 的距离和抛开点 $u$ 最远的距离相等时，原答案最小。

这就启示我们答案实际与树的直径有关 (这里我们只考虑标记过的节点)，因为在变更途中答案变化必和另一个直径端点 $v$ 有关。即可类比两次 dfs 求直径做法的证明即可推出。

于是乎答案就是树的直径除以二向上取整的结果，由于还需要开一次枪，所以还要 $+1$。这样瓶颈就在于 $k$ 级祖先，可以使用长链剖分做到 $O(n)$。这里提供倍增做法的代码，时间复杂度退化成 $O(n + m \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
int n,de[N],u,v,a[N],m,K,now,f[N][20],b[N],len;
vector <int> e[N];
inline void dfs(int u,int fa){
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i];
		if(v==fa)continue;f[v][0]=u;
		de[v]=de[u]+1,dfs(v,u);
	}
}int maxn,id,c[N],len1;
inline int getup(int x,int k){
	if(!k)return x;
	for(int i = 0,p= k;p;p>>=1,i++)
		if(p&1)
			x=f[x][i];
	return x;
}int dis[N],vis[N],maxnid;
inline void dfs1(int u,int fa,int now){
	if(vis[u])dis[u]=now;
	if(dis[maxnid]<dis[u])maxnid=u;
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i];
		if(v==fa)continue;
		dfs1(v,u,now+1);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i < n;i++){
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}cin >> m;
	for(int i = 1;i <= m;i++)cin >> a[i];
	cin >> K >> now;
	dfs(now,0);
	for(int j = 1;j <= 19;j++)
		for(int i =1;i <= n;i++)
			f[i][j]=f[f[i][j-1]][j-1];
	for(int i = 1;i <= m;i++){
		if(de[a[i]]>K){
			int id=getup(a[i],K);
			vis[id]=1;
		}
	}dfs1(now,0,0);vis[now]=1;
	memset(dis,0,sizeof(dis));
	dfs1(maxnid,0,0);
	cout << (dis[maxnid]+1)/2+1;
	return 0;
}
//树的直径/2+1
//猜的，大样例过了
//整体上移动K 
//有一个不那么严谨的思考方式(它甚至不能称之为证明):
//以now为根，我们发现答案的上界为根节点到最远点距离
//考虑如何让答案缩小，就是向最远点移动
//你发现移动的时候另外答案增加，直到使得最远点改变
//直接注意到两者相等就是答案，发现树的直径一定成为答案，两边dfs法说明
//于是乎直径的中点长度就是答案 


```

---

## 作者：Special_Judge (赞：0)

# P6584 重拳出击 题解

要打死所有敌人等价于让所有敌人到小 Z 的距离小于等于 $k$。

为了方便，我们先始终视小 Z 所在的节点为根节点。

如果我们要移动，必定是往一棵子树移动，此时，那棵子树上面所有的敌人到自己的距离在这个回合内将会 $-2$，而其他子树上面的敌人到自己的距离不变。

为了能够最快让所有的敌人到小 Z 的距离小于等于 $k$，我们必定是往距离小 Z 最远的那个敌人所在的子树走，这样才能快速减小那个敌人到小 Z 的距离。

不过这个过程肯定不能一直进行下去。当我们发现有在不同子树的且都距离小 Z 最远的敌人的时候，就可以停止移动了。可以发现在其他情况下，移动一定不会使我们接下来得到的答案变劣。

具体实现上，我们可以使用线段树 + dfs 序。每次移动时候通过查询子树最大值来得到要往哪棵子树上移动，然后把那棵子树上面的距离全部 $-2$。当我们不移动的时候，就把所有点的距离全部 $-1$。

不过还有一个小问题，就是我们移动之后会离开我们做 dfs 的时候的根，查询父节点方向的那棵子树的时候，不能简单地得出子树区间。

每次移动都做一遍 dfs 显然复杂度太高。

所以我们需要一个小技巧：换根。

有一道同样需要这个小技巧的题，不过需要树剖：[P3979 遥远的国度](https://www.luogu.com.cn/problem/P3979)。

父节点方向上的子树长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ulozmr2.png)

显然，此时的子树就变成了从全部的 dfs 序中扣掉原来所在节点的子树（在上图中就是以 $3$ 为根节点的子树)的那一部分。设原来所在节点的 dfs 序左边是 $l$，右边是 $r$，那么我们执行操作的区间就应该是 $[1,l-1] \cup[r+1,2n]$。

然后就做完了。

Code:

```cpp
#include<bits/stdc++.h>

#define here(x) cout<<"here "<<x<<endl;
#define putlist(x,st,ed) {for(int ind=st;ind<=ed;ind++)cout<<x[ind]<<' ';cout<<endl;}
#define putstl(x) {for(auto TeMp:x)cout<<TeMp<<' ';cout<<endl;}
#define putsize(x) cout<<sizeof(x)*1.0/1024/1024<<" MB"<<endl;

#define cases int __;cin>>__;while(__--)work();

#define MAXN_INT 2147483647
#define MAXN_LL 9223372036854775807

#define MOD A_NUMBER
#define N 1000001
#define eps 1e-6

#define mp make_pair
#define pb push_back

using namespace std;

vector<int>e[N];
vector<int>v;
int n,m,k;
int root;
int tim=0,dis[N],fa[N];
int l[N],r[N];
void dfs(int now,int f,int d)//预处理 dfs 序和初始每个点到根节点的距离
{
	l[now]=++tim;
	dis[now]=d;
	fa[now]=f;
	for(int v:e[now])
	{
		if(v==f)continue;
		dfs(v,now,d+1);
	}
	r[now]=++tim;
}

namespace SegmentTree
{
	struct Node
	{
		int l,r,siz;
		int lazy,maxn;
	}t[N<<2];
	void pushup(int now)
	{
		t[now].maxn=max(t[now*2].maxn,t[now*2+1].maxn);
	}
	void pushdown(int now)
	{
		if(!t[now].lazy)return ;
		t[now*2].maxn+=t[now].lazy;
		t[now*2+1].maxn+=t[now].lazy;
		t[now*2].lazy+=t[now].lazy;
		t[now*2+1].lazy+=t[now].lazy;
		t[now].lazy=0;	
	}
	void build(int now,int l,int r)
	{
		t[now].l=l;
		t[now].r=r;
		t[now].siz=r-l+1;
		if(l==r)return ;
		int mid=(l+r)>>1;
		build(now*2,l,mid);
		build(now*2+1,mid+1,r);
		pushup(now);
	}
	void add(int now,int l,int r,int val)
	{
		if(t[now].l>=l&&t[now].r<=r)
		{
			t[now].maxn+=val;
			t[now].lazy+=val;
			return ;
		}
		pushdown(now);
		if(t[now*2].r>=l)add(now*2,l,r,val);
		if(t[now*2+1].l<=r)add(now*2+1,l,r,val);
		pushup(now);
	}
	int query_max(int now,int l,int r)
	{
		if(t[now].l>=l&&t[now].r<=r)return t[now].maxn;
		pushdown(now);
		int s=-MAXN_INT;
		if(t[now*2].r>=l)s=max(s,query_max(now*2,l,r));
		if(t[now*2+1].l<=r)s=max(s,query_max(now*2+1,l,r));
		return s;
	}
}
using namespace SegmentTree;

signed main()
{
	cin>>n;
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		cin>>u>>v;
		e[u].pb(v);
		e[v].pb(u);
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		int t;
		cin>>t;
		v.pb(t);
	}
	cin>>k>>root;

	dfs(root,0,0);
	sort(v.begin(),v.end());
	v.resize(unique(v.begin(),v.end())-v.begin());
    //这里去重是必要的，因为下面的初始化使用的是区间加，如果不去重会导致同一个点的距离被加多次
	build(1,1,2*n);//dfs 序需要双倍的线段树大小

	for(int x:v)
	{
		add(1,l[x],l[x],dis[x]);
		add(1,r[x],r[x],dis[x]);
	}

	int now=root;
	int tim=0;
	while(1)
	{
		tim++;
		if(query_max(1,l[root],r[root])<=k)break;
		int maxn=0;
		int tar=now;
		bool f=1; //用于判断是否有多个不同子树上的敌人都和小 Z 距离最远
		for(int v:e[now])
		{
			int t;
			if(v==fa[now])t=max(query_max(1,1,l[now]-1),query_max(1,r[now]+1,2*n));//换根
			else t=query_max(1,l[v],r[v]);

			if(t>maxn)
			{
				maxn=t;
				tar=v;
				f=0;
			}
			else if(t==maxn)
			{
				f=1;
			}
		}
		if(!f)
		{
			if(tar!=fa[now])add(1,l[tar],r[tar],-2);
			else //换根
			{
				add(1,1,l[now]-1,-2);
				add(1,r[now]+1,2*n,-2);
			}
			now=tar;
		}
		else add(1,l[root],r[root],-1);
	}
	cout<<tim<<endl;
	return 0;
} 
/*

*/
```



---

## 作者：jq_ll19802 (赞：0)

做法：贪心+DFS

时间复杂度：$O(n)$

题意：每回合小明用枪先打怪后移动，可移动一条边的距离，然后怪物会向小明方向走一条边。

分析：此题中，需要考虑的只有小明的移动方法，目标是使所有怪物与小明的距离小于等于 $k$。

设小明开始所在位置为根。

我们先假设所有怪物都在根的不同子树内，即每棵子树只有一只或没有怪物，且有 $2$ 只以上的怪物。

考虑贪心，很容易发现，在有一只怪物的距离小明的距离大于其他怪物的距离 $+1$ 时，走向这只怪物一定是最优的，因为这样可以将最大值最小化。

为什么要 $+1$ 呢？

此时，在最远的怪物与次远的怪物距离差 $1$ 时，如果走向最远的怪物，那么走完后，原本的次远的怪物会比最远的的怪物远 $1$，下一步就会走向次远的怪物，又返回到上一步的位置，与不走一样。

再想一下，其实我们要管的只有最远的和次远的怪物，当小明走到最远的怪物与次远的怪物距离只差 $1$ 或相等时，小明只需要等怪物来送即可，要的只有判断最远的怪物与次远的怪物距离的差。

我们DFS求最远与次远的怪物，最远的怪物和次远的怪物之间的路径中必有根节点（在假设中），设 $y_最与y_次$,可以推出。

$y_最与y_次>k$时，$ans=（y_最+y_次+1)/2-k+1$。

$y_最$>k>$y_次$时，$ans=(y_最-k+1)/2+1$。

$y_最与y_次<k$时，$ans=1$。

退出假设，当最远与次远的怪物在同一颗子树内时，DFS回溯时当最远与次远的怪物回溯到同一个点上时，再往上回溯一次，次远就要减2，再综合所有子树的最远与次远求出根的最远与次远。

为什么要减 $2$ ？

在原先假设中，小明走向最远的怪物时，距离次远的怪物距离是不变的，现在则是最远与次远同时减 $2$ ，所以次远要减 $2$ ，然后按上面的式子得出答案。

这个方法跑的很快。

上代码

---

```cpp
#include<bits/stdc++.h>
#define sc(x) scanf("%d",&x)

using namespace std;

int n,m,b,c,p[400005],id,root,k;

bool q[400005],a[400005];

int head[400005],idx=1;

struct hh
{
	int v,next;
}edge[800005];

void ci(int x,int y)
{
	edge[idx].v=y;
	edge[idx].next=head[x];
	head[x]=idx;
	idx++;
}

struct hhhh
{
	int op1,op2;
};

hhhh daan;

hhhh dfs(int x,int y)
{
	int op1=0,op2=0;
	hhhh d;
	if(a[x])
	{
		op1=y;
	}
	q[x]=true;
	for(int i=head[x];i;i=edge[i].next)
	{
		if(!q[edge[i].v])
		{
			
			d=dfs(edge[i].v,y+1);
			
			if(d.op2>op1) op2 = op1 , op1 = d.op2 ;
			else if(d.op2>op2) op2 = d.op2 ;
			
			
			if(d.op1>op1) op2 = op1 , op1 = d.op1 ;
			else if(d.op1>op2) op2 = d.op1 ;
		}
	}
	q[x]=false;
	d.op1=op1;
	if(x==root)
	d.op2=op2;
	else 
	{
		if(op2<2)op2=2; 
		d.op2=op2-2;
	}
	return d;
}

int main()
{
	sc(n);
	for(int i=1;i<n;i++)
	{
		sc(b);sc(c);
		ci(b,c);
		ci(c,b);
	}
	sc(m);
	for(int i=1;i<=m;i++)
	{
		sc(b);
		a[b]=true;
	}
	sc(k);
	sc(root);
	daan=dfs(root,0);
	if(daan.op1<=k)
	printf("1");
	if(daan.op2<=k&&daan.op1>k)
	printf("%d",(daan.op1-k+1)/2+1);
	if(daan.op2>k&&daan.op1>k)
	printf("%d",(daan.op1+daan.op2+1)/2-k+1);
	return 0; 
} 
```

---


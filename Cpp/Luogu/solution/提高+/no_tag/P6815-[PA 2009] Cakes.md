# [PA 2009] Cakes

## 题目描述

一个有 $n$ 个点 $m$ 条边的无向图，每个点有一个点权 $a$。


对于任意一个三元环 $(i,j,k)（i<j<k）$，它的贡献为 $\max (a_i,a_j,a_k)$。

求所有三元环的贡献和。

## 说明/提示

$1<n\le 100000$，$1\le m\le 250000$。

## 样例 #1

### 输入

```
5 7
1 5 3 4 2
1 2
2 3
5 2
4 3
3 1
1 4
5 1```

### 输出

```
14```

# 题解

## 作者：ker_xyxyxyx_xxs (赞：4)

[P6815 [PA2009]Cakes](https://www.luogu.com.cn/problem/P6815)

题目直接点出三元环了，简单介绍一下。

定义：三元环是指对于图上的三个点，两两点之间都直接有边相连，这三个点组成的环就是三元环。

三元环的计数方法：记录图中每个点的度数，对于每条边将它定向。对于一条边，将度数大的点指向度数小的点，如果度数相同就将编号小的点指向编号大的点。计数时枚举每个点，对于每个点  x  枚举它的出边，并将出边指向的点  y  打标记，对于所有出边指向的点  y  再枚举出边，如果这个出边指向的点  z  被打了标记，那么  x,y,z  就组成了一个三元环。时间复杂度为 $ O(m \cdot \sqrt{m}) $。

性质：

1、这一定是一个有向无环图。

2、每个三元环只会被统计一次。

~~（怎么证明请自己思考）~~

这个题直接按照上述方法计算即可。


# AC 100pts Code
```cpp

# include <iostream>
# include <cstdio>
# include <vector>
using namespace std;
static char buf[1000000],*p1=buf,*p2=buf,obuf[1000000],*p3=obuf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (p3-obuf<1000000)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
template<typename item>
inline void read(register item &x)
{
    x=0;register char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
static char cc[10000];
template<typename item>
inline void print(register item x)
{ 
	register long long len=0;
	while(x)cc[len++]=x%10+'0',x/=10;
	while(len--)putchar(cc[len]);
}
const int maxn = 2e6 + 5;
typedef long long ll;
ll ans = 0;
int n , m;
int w[maxn];
typedef struct {
	int x , y;
}ed;
ed N[maxn];
int x , y;

vector<int> g[maxn];
int deg[maxn];
int mark[maxn];
int main() {
    read(n);
    read(m);
	for (int i = 1 ; i <= n ; i ++) {
		read(w[i]);
	}
	for (int i = 1 ; i <= m ; i ++) {
		read(x);
		read(y);
		deg[x] ++;
		deg[y] ++;
		N[i].x = x;
		N[i].y = y;
	}
	for (int i = 1 ; i <= m ; i ++) {
		int x = N[i].x , y = N[i].y;
		if (deg[x] > deg[y] || (deg[x] == deg[y] && x < y)) swap(x , y);
		g[x].push_back(y);
	}
	
	for (int x = 1 ; x <= n ; x ++) {
		for (int i = 0 ; i < g[x].size() ; i ++) {
			mark[g[x][i]] = x;
		}
		for (int i = 0 ; i < g[x].size() ; i ++) {
		    int e = g[x][i];
		    for (int j = 0 ; j < g[e].size() ; j ++) {
		        int endd = g[e][j];
		        if (mark[endd] == x) ans += max(w[x] , max(w[e] , w[endd]));
		    }
		}
	}
	printf("%lld\n" , ans);
	fwrite(obuf,p3-obuf,1,stdout);
	return 0;
}
```


---

## 作者：Karry5307 (赞：4)

### 题意

给定一个 $n$ 个点 $m$ 条边的图，点 $i$ 有权值 $a_i$，一个三元环 $(i,j,k)$ 的贡献为 $\max(a_i,a_j,a_k)$，求所有三元环的贡献之和。

$\texttt{Data Range:}1\leq n\leq 10^5,1\leq m\leq 3\times 10^5$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13618318.html)

所谓的三元环计数其实就是个优雅的暴力。

考虑将原图的边定向：度数大的连向度数小的，度数一样则编号大的连向编号小的。我们可以发现这个图有一些特殊性质：

- 由于严格规定了连边的方向，所以这个图是个 DAG。

- 如果一个点在原图中度数大于 $\sqrt{m}$，注意到这个点只能向原图不小于它的点连边，而且原图中每个点的度数之和是 $O(m)$，所以这个点在新图上的出度为 $O(\sqrt{m})$。

- 如果一个点在原图中度数不大于 $\sqrt{m}$，由于新图中的出度不可能比原图还大，所以这个点在新图上的出度为 $O(\sqrt{m})$。

所以建完图之后暴力枚举即可，因为出度为 $O(\sqrt{m})$ 所以我们可以通过打标记的方法快速查询一个点能不能直接到达另一个点，时间复杂度 $O(m\sqrt{m})$。

注意一下数三元环的时候用邻接表存新图由于内存访问不连续所以没 vector 存图跑得快，在这题的直接后果就是被卡常。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=3e5+51; 
ll n,m;
li res;
vector<ll>g[MAXN];
ll vis[MAXN],deg[MAXN],from[MAXN],to[MAXN],w[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;i++)
	{
		w[i]=read();
	}
	for(register int i=1;i<=m;i++)
	{
		deg[from[i]=read()]++,deg[to[i]=read()]++;
	}
	for(register int i=1;i<=m;i++)
	{
		if(deg[from[i]]>deg[to[i]]||(deg[from[i]]==deg[to[i]]&&from[i]>to[i]))
		{
			swap(from[i],to[i]);
		}
		g[from[i]].emplace_back(to[i]);
	}
	for(register int i=1;i<=m;i++)
	{
		for(register int j:g[i])
		{
			vis[j]=1;
		}
		for(register int j:g[i])
		{
			for(register int k:g[j])
			{
				res+=vis[k]*max(w[i],max(w[j],w[k]));
			}
		} 
		for(register int j:g[i])
		{
			vis[j]=0;
		}
	}
	printf("%lld\n",res);
}
```

---

## 作者：Time_tears (赞：3)

一道三元环计数的裸题

按照套路把无向边转化成从度数大的点指向度数小的点的有向边。

按权值从小到大的顺序枚举起始点，枚举相连的点，如果其出度小于$\sqrt m$，那么枚举与其相连的点。

判断是否和起始点相连，若仍然与起始点相连那么这就是一个三元环，统计答案到ans中即可。

否则，枚举起始点相连的点，判断是否和枚举点相连即可。 

```cpp
#include<cstdio>
#include<map>
#include<vector>
#define N 100005
using namespace std;
int n,m,a[N],ex[N*3];
int ey[N*3],d[N],v[N];
vector<int>p[N];
inline int read() {
	int s=0,f=0;
	char ch=getchar();
	while(ch<48||ch>57)f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
inline void print(int x) {
	if(x>9)print(x/10);
	putchar(x%10^48);
}
int Max(int x,int y) {
	return x>y?x:y;
}
bool Cmp(int x,int y) {
	return d[x]==d[y]?x>y:d[x]>d[y];
}
int main() {
	n=read(),m=read();
	for(int i=1; i<=n; ++i)a[i]=read();
	for(int i=1,x,y; i<=m; ++i)
		ex[i]=read(),ey[i]=read(),++d[ex[i]],++d[ey[i]];
	for(int i=1; i<=m; ++i) {
		if(Cmp(ex[i],ey[i]))p[ex[i]].push_back(ey[i]);
		else p[ey[i]].push_back(ex[i]);
	}
	long long ans=0;
	for(int i=1,y,z; i<=n; ++i) {
		for(int j=0; j<p[i].size(); ++j)v[y=p[i][j]]=(a[y]>a[i])?a[y]:a[i];
		for(int j=0; j<p[i].size(); ++j)
			for(int k=p[y=p[i][j]].size()-1; ~k; --k)
				if(v[z=p[y][k]])ans+=v[z]>a[y]?v[z]:a[y];
		for(int j=0; j<p[i].size(); ++j)v[p[i][j]]=0;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：high_sky (赞：2)

# P6815 [PA2009] Cakes 题目分析

[题目链接](https://www.luogu.com.cn/problem/P6815)

## 分析题目性质

本质上是求三个点组成的环的点权最大值的和。

## 思路

### 暴力

考虑枚举第一个点 $i$，然后枚举与其相邻的第二个点 $j$，用 `set` 存储 $i,j$ 相连的点，最后判断得出答案。

考虑完全图，上述代码会跑得很慢，得分 $28$ 分。

完全图时，时间复杂度为 $\mathcal{O}(n^3\log n)$。

### 建图优化

我们发现满足答案的满足 $i<j<k$ 这种情况。

观察我们枚举的顺序：不难得出当前点 $x$ 相连的点 $y$ 必须满足 $x<y$。换言之，我们可以在建图的时候只使小的点连向大的点。

得分 $86$ 分，是一个客观分数。

考虑什么时候最慢：一条链的时候节点枚举为 $(n-1)(n-2)+(n-2)(n-3)\dots+ 2\times1$。

所以说：时间复杂度是 $\mathcal{O}(n^2\log n)$ 的。

### 枚举第三个点优化

我们不需要用 `set` 去判断，而是用一个 $vis$ 数组去标记。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stdlib.h>
#include <cstring>
#include <vector>
#include <set>
#define N 100005
#define int long long
using namespace std;
int n,m,a[N],ans;
vector<int> g[N];
bool vis[N];
signed main(){
	cin >> n >> m;
	for (int i = 1;i <= n;i ++) cin >> a[i];
	for (int i = 1;i <= m;i ++) {
		int x,y;
		cin >> x >> y;
		if (x > y) swap(x,y);
		g[x].push_back(y); 
	} 
	for (int i = 1;i <= n;i ++) {
		for (auto j : g[i]) vis[j] = 1;
		for (auto j : g[i])
			for (auto k : g[j])
				if (vis[k]) ans += max(max(a[i],a[j]),a[k]); 
		for (auto j : g[i])
			vis[j] = 0;
	}
	cout << ans;
	return 0;
}
```

得分 $100$ 分，非正解。

还是考虑链的情况，时间复杂度为 $\mathcal{O}(n^2)$。

至于怎么过去的我也不知道，还望加强数据。

### 度数建图优化

用度数大的去连接度数小的点，度数一样的用编号小的连接大的。

我们发现，这一些点的出度似乎是处于一个比较平衡的状态，其实不然，这个状态不大于 $\sqrt m$。

时间复杂度 $\mathcal{O}(m\sqrt m)$。

可得 $100$ 分。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stdlib.h>
#include <cstring>
#include <vector>
#include <set>
#define N 100005
#define M 300005
#define int long long
using namespace std;
int n,m,a[N],ans;
vector<int> g[N];
bool vis[N];
int d[N];
struct node{
	int x,y;
}in[M];
signed main(){
	cin >> n >> m;
	for (int i = 1;i <= n;i ++) cin >> a[i];
	for (int i = 1;i <= m;i ++) cin >> in[i].x >> in[i].y,d[in[i].x] ++,d[in[i].y] ++;
	for (int i = 1;i <= m;i ++) {
		int x = in[i].x,y = in[i].y;
		if (d[x] < d[y] || (d[x] == d[y] && x > y)) swap(x,y);
		g[x].push_back(y);
	}
	for (int i = 1;i <= n;i ++) {
		for (auto j : g[i]) vis[j] = 1;
		for (auto j : g[i])
			for (auto k : g[j])
				if (vis[k]) ans += max(max(a[i],a[j]),a[k]); 
		for (auto j : g[i])
			vis[j] = 0;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：MSqwq (赞：2)

先给几个关于三元环（三个点由三条边互相连接）的结论：  
这里就说一种比较好理解的定向法吧  
我们先拿到的是无向图，所以我们考虑把它变成有向图，这样更方便讨论  
然后我们给每条无向边定向，我们规定每一条边边的方向由度数较小的节点指向较大的节点，若度数相同，则由大编号节点指向小编号节点（度数都为无向图中的度数，就是这个点被多少边所连）  
然后我们可以通过反证法，证明以下两个结论，很好证明，所以这里我就不证明了，直接给结论：  
1.每个节点的度数都不大于$\sqrt m$（ $m$ 为边数）  
2.新的有向图一定是有向无环图  

好知道这都些其实就是用来证明复杂度的，具体的解法只建立于变成有向图就可以了    
好，现在如果我们用暴力解决这个问题，怎么暴力，想一想  
选个点，然后他可以到达一些点，如果这些点由两个可以相互到达，则一定会产生一个三元环  
其实这题也是这个思路  
用类似于染色的思路吧（不是二分图！！！）枚举每一个点 $p$ 把它可以到达的点的颜色都染成 $p$ 如果有被标记的两个点之间也有一条边则可以发现这三个点组成了一个三元环，那么就直接算贡献相加就可以了  

好像很多人说链式前向星会被卡掉？？？其实理论上是这样的，因为内存访问不连续嘛，但是这题开 $O2$ 就可以过了，当然 $vector$ 也是非常好而且很实用的一种方式，我建议还是多用链式存吧，因为比较方便和普遍的图论树论都实用，具体题目具体分析吧  
代码如下：  
$1.$前向星
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#define ll long long
using namespace std;
const int N=500010;
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0',c=getchar();}
    return x*f;
}
int n,m;
struct lxh{int from,to;}b[N];
struct MS{int to,next;}e[N];
int elast[N],k;
void add(int x,int y)
{
	e[++k].to=y;
	e[k].next=elast[x];
	elast[x]=k;
}
int du[N],color[N];
int a[N];
ll ans;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)
	{
		b[i].from=read(),b[i].to=read();
		du[b[i].from]++,du[b[i].to]++;
	}
	for(int i=1;i<=m;i++)
	{
		int x=b[i].from,y=b[i].to;
		if(du[x]<du[y]||(du[x]==du[y]&&x<y))swap(x,y);
		add(x,y);	
	}
	for(int p=1;p<=n;p++)
	{
		for(int i=elast[p];i;i=e[i].next)color[e[i].to]=p;
		for(int i=elast[p];i;i=e[i].next)
			for(int j=elast[e[i].to];j;j=e[j].next)
				if(color[e[j].to]==p)ans+=max(a[p],max(a[e[i].to],a[e[j].to]));
	}
	printf("%lld",ans);	
}
```

$2. $ $vector$  

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#define ll long long
using namespace std;
const int N=500010;
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0',c=getchar();}
    return x*f;
}
int n,m;
struct lxh{int from,to;}b[N];
vector<int>e[N];
int du[N],color[N];
int a[N];
ll ans;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&b[i].from,&b[i].to);
		du[b[i].from]++,du[b[i].to]++;
	}
	for(int i=1;i<=m;i++)
	{
		int x=b[i].from,y=b[i].to;
		if(du[x]<du[y]||(du[x]==du[y]&&x<y))swap(x,y);
		e[x].push_back(y);
	}
	for(int p=1;p<=n;p++)
	{
		for(int i=0;i<e[p].size();i++)color[e[p][i]]=p;
		for(int i=0;i<e[p].size();i++)
			for(int j=0;j<e[e[p][i]].size();j++)
				if(color[e[e[p][i]][j]]==p)ans+=max(a[p],max(a[e[p][i]],a[e[e[p][i]][j]]));
	}
	printf("%lld",ans);
}
```


---

## 作者：IC0CI (赞：1)

## 题面分析

给出一个无向图，统计三元环。

一个根号算法（人类智慧？）。

对于所有给出的无向边，我们给他们钦定一个方向，即由入度较大的指向入度较小的，若入度相同就由顶点编号大的指向编号较小的。

这样可以使这个图变成一个有向无环图，其中所有三元环都长这样：

![](https://s21.ax1x.com/2025/07/09/pVQGZ7j.png)

可以使统计复杂度变为 $O(N \times \sqrt N)$

### 关于具体实现

对于一个点，遍历一遍并标记它指向的节点。再遍历它指向的节点指向的节点，若这个点被标记，则有一个三元环，更新答案即可。

# Code

```cpp

#include<bits/stdc++.h>
using namespace std;
#define int long long

int rd()//快读

const int N = 1e5 + 5;
int n,m,a[N],d[N],ans;
vector<int> adj[N];
bool vis[N];
struct E
{
    int u,v;
}e[N << 2];

signed main()
{
    n = rd(),m = rd();
    for(int i = 1;i <= n;i++) a[i] = rd();
    for(int i = 1;i <= m;i++) d[e[i].u = rd()]++,d[e[i].v = rd()]++;
    for(int i = 1;i <= m;i++)
    {
        auto [u,v] = e[i];
        if(d[u] < d[v] || (d[u] == d[v] && u > v)) swap(u,v);
        adj[u].emplace_back(v);
    }
    for(int i = 1;i <= n;i++)
    {
        for(auto u : adj[i]) vis[u] = 1;
        for(auto u : adj[i]) for(auto v : adj[u]) if(vis[v]) ans += max({a[i],a[u],a[v]});
        for(auto u : adj[i]) vis[u] = 0;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：tyccyt (赞：1)

简化题意：求出每个三元环 $(u,v,w)$，满足 $u<v<w$，统计贡献和 $\sum \max(u,v,w)$。

考虑如何求出所有三元环。

直接上模板（时间复杂度：$O(m\sqrt{m})$）：

1. 统计所有点的度数。修改原来的边为有向边：考虑一组边 $(u,v)$，如果 $u$ 的度数等于 $v$ 的度数，编号小连向标号大的，否则度数小的连向度数大的。这也就成了一个有向无环图。
2. 其次，暴力枚举每个点，找到 $u,v,w$（不要用邻接矩阵）统计即可。

### 构成有向无环图证明：

考虑反证法。假设存在环，由于每个点指向的点的度数大于等于这个点，那么这个环上点的度数**相等**，但是要同时满足编号小连向编号大的，所以不成立。

### 复杂度证明：

建图：$O(m)$。

找环：对于点对 $(v,w)$，满足 $u$ 的个数小于 $v$ 的入度，接着分类讨论：

1. $v$ 的入度 $\le \sqrt{m}$ ：那么 $u$ 的个数小于 $\sqrt{m}$，同时 $w$ 的个数至多有 $n$ 个，所以时间复杂度：$O(n/\sqrt{m})$ 。
2. $v$ 的入度 $> \sqrt{m}$ ：因为 $v$ 指向 $w$，所以 $v$ 的入度小于等于 $w$ 的入度，所以 $w$ 及其子孙的入度大于 $\sqrt{m}$，综合起来 $w$ 的个数 $\le \sqrt{m}$，同时 $u\rightarrow v$ 的个数可能有 $m$ 个，所以时间复杂度：$O(m\sqrt{m})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int n,m,in[N],x[N<<2],y[N<<2],a[N];
int vis[N],ans=0,to[N];
vector<int>e[N];
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		cin>>x[i]>>y[i];
		in[x[i]]++,in[y[i]]++;
	}
	for(int i=1;i<=m;i++)
	{
		if((in[x[i]]==in[y[i]]&&x[i]>y[i])||in[x[i]]>in[y[i]])swap(x[i],y[i]);
		e[x[i]].push_back(y[i]);
	}
	for(int u=1,v,w;u<=n;u++)
	{
		for(int i=0;i<e[u].size();i++)vis[e[u][i]]=1;
		for(int i=0;i<e[u].size();i++)
		{
			v=e[u][i];
			for(int j=0;j<e[v].size();j++)
			{
				w=e[v][j];
				if(vis[w])
				{
					ans+=max(a[u],max(a[v],a[w]));
				}
			}
		}
		for(int i=0;i<e[u].size();i++)vis[e[u][i]]=0;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：JK_LOVER (赞：1)

## 题意
计算所有三元环的贡献。[$QWQ$](https://www.luogu.com.cn/blog/xzc/solution-p6815)
## 分析
考虑边定向。度数大的点连向度数小的，如果度数相同那么编号大的连向编号小的。考虑这样之后有什么特殊性质。

- 新图一定是 $DAG$ ，因为每个节点是有大小关系的，只有可能大的连向小的。

- 如果一个点的出度大于 $\sqrt{m}$ ，那么最多只有 $\sqrt{m}$ 个节点指向它。

- 如果一个节点的出度小于 $\sqrt{m}$ ，那么最多只有 $n$ 个节点指向它。

那么枚举三元环的时间复杂度就为 $O(m\times \sqrt{m})$ ，而且枚举的三元环不重不漏。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 260000;
int read() {
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
vector<int> G[N];
int e[N][2],n,m,val[N],du[N],vis[N];
int main()
{
	n = read();m = read();
	for(int i = 1;i <= n;i++) val[i] = read();
	for(int i = 1;i <= m;i++) {
		e[i][0] = read();e[i][1] = read();
		du[e[i][0]] ++;du[e[i][1]] ++;
	}
	for(int i = 1;i <= m;i++) {
		if(du[e[i][0]] < du[e[i][1]]||(du[e[i][0]]==du[e[i][1]] && e[i][1]>e[i][0])) swap(e[i][0],e[i][1]);
		G[e[i][0]].push_back(e[i][1]);
	}
	long long ans = 0;
	for(int x = 1;x <= n;x++){
		for(auto y: G[x]) vis[y] = x;
		for(auto y: G[x]) {
			for(auto z:G[y]){
				if(vis[z] == x)
				ans += max(val[x],max(val[y],val[z]));
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：zhanglh (赞：0)

给定无向图，求图中三元环的贡献和。一个三元环的贡献，定义为三个节点的权值的最大值。

先对于无向图，统计每个节点的度数。

建图，把无向图转化为有向图。从度数大的节点向度数小的节点连边，度数相同则从编号小的向编号大的连边。

对三元组的贡献求和。遍历每个节点，设当前节点为 $x$，枚举 $x$ 的出边指向的节点 $y$，标记。再从 $y$ 开始，遍历 $y$ 的出边指向的节点 $z$，若 $z$ 已经被标记过了，则找到了一个三元环，计算贡献。

每个三元环恰好被统计一次，不重不漏。

```
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
const int N = 100010;

int n, m, a[N], d[N];
vector<int> adj[N];
vector<pii> edge;
bool st[N];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	while(m--) {
		int u, v;
		cin >> u >> v;
		d[u]++;
		d[v]++;
		edge.push_back({u, v});
	}
	
	for (pii i : edge) {
		if (d[i.first] < d[i.second]) adj[i.second].push_back(i.first);
		else if (d[i.first] > d[i.second]) adj[i.first].push_back(i.second);
		else if (i.first < i.second) adj[i.first].push_back(i.second);
		else adj[i.second].push_back(i.first);
	}
	
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		memset(st, 0, sizeof(st));
		for (int j : adj[i]) st[j] = true;
		for (int j : adj[i]) {
			for (int k : adj[j]) {
				if (st[k] == true) ans += max(a[i], max(a[j], a[k]));
			}
		}
	}
	cout << ans << "\n";
	
	return 0;
}

```

---

## 作者：Zhao_daodao (赞：0)

## P6815 solution
统计三元环 $(i,j,k)$ 的权值和，其中 $i<j<k$。

定义点权 $a$ 数组，三元环权值为 $max(a_i,a_j,a_k)$。

考虑定向，定义 $out$ 数组表示节点出度。

对于一条边 $(u,v)$：

1. $in_u\ne in_v$，将出度小的连向出度大的。

2. $in_u=in_v$，将编号小的连向编号大的。

结论：每一个节点的出度是 $O(\sqrt{m})$ 级别的。

对于每一个点 $i$：

1. $out_i\le\sqrt{m}$，新图中出边个数不大于 $out_i$。
2. $out_i>\sqrt{m}$，对于他连向的边 $j$，$in_j\ge\sqrt{m}$，最多只有 $\frac{m}{\sqrt{m}}=\sqrt{m}$ 个这样的 $j$。

证毕。

接下来暴力枚举，对于点 $i$，标记它的儿子 $j$。对于每一个 $j$，判断它的一个儿子 $k$ 是否被 $i$ 标记过，如果有便是一个三元环。

同时因为点之间有严格排序，不存在会数重的情况。

最好 **不要用链式前向星**，内存访问不连续。

复杂度：三重枚举，$O(m^{1.5})$。

同时本题 $N$ 要开到 $3e5$。

### code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=3e5+5;
int n,m;
int a[MAXN];
int u[MAXN],v[MAXN],out[MAXN];
vector<int>vec[MAXN];
int biao[MAXN],ans;
signed main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=m;i++)cin>>u[i]>>v[i],out[u[i]]++,out[v[i]]++;
    for(int i=1;i<=m;i++){
        if(out[u[i]]<out[v[i]]||(out[u[i]]==out[v[i]]&&u[i]<v[i]))
            vec[u[i]].emplace_back(v[i]);
        else 
            vec[v[i]].emplace_back(u[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j:vec[i])biao[j]=i;
        for(int j:vec[i])
            for(int k:vec[j]){
                if(biao[k]==i)
                    ans+=max(max(a[i],a[j]),a[k]);
            }
    }
    cout<<ans<<"\n";
}

```
## 一些小小的拓展：四元环

统计四元环的个数。

先将边有序化。枚举一条三元链 $i-j-k$，$ans+=cnt_k$，$cnt_k:=cnt_k+1$。

$cnt_k$ 代表又多少条三元链从 $i$ 出发，到达 $k$。

其实最终统计的 $ans_i=\sum\limits_{k=1}^{n}cnt_k\times(cnt_k-1)$。

$ans=\sum\limits_{i=1}^{n}ans_i$。


---

## 作者：w9095 (赞：0)

[P6815 [PA2009] Cakes](https://www.luogu.com.cn/problem/P6815)

三元环计数题。

无向图三元环计数分为三步：

$1$ ：给所有无向边重定向。记录每个点的度数，度数大的点指向度数小的点。如果度数相同，编号小的点指向编号大的点。最后这个图是有向无环图。

$2$ ：打标记。对于图中每一个点 $u$，将其相邻的点标记可以被 $u$ 到达。

$3$ ：统计答案。对于图中每一个点 $u$，遍历其可以相邻的点 $v$，如果 $v$ 相邻的点 $w$ 被标记可以被 $u$ 到达，那么 $(u,v,w)$ 构成一个三元环。三元环不会被重复计算。

在这一题中，我们只需要对无向图三元环计数算法的第三步略微改动，当我们发现 $(u,v,w)$ 构成一个三元环时，将答案增加 $\max(a_u,a_v,a_w)$ 即可。

由于无向图三元环计数算法复杂度为 $O(m\sqrt{m})$，所以这个算法的时间复杂度为 $O(m\sqrt{m})$。

本题卡邻接表的常数，注意常数影响。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge
{
	int v,nxt;
}e[600000];
int n,m,a[200000],h[200000],b[200000],ind[200000],u[400000],v[400000],cnt=0;
long long ans=0;
void add_edge(int u,int v)
{
	e[++cnt].nxt=h[u];
	e[cnt].v=v;
	h[u]=cnt;
}

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)u[i]=read(),v[i]=read(),ind[u[i]]++,ind[v[i]]++;
	for(int i=1;i<=m;i++)
	    if((ind[u[i]]>ind[v[i]])||(ind[u[i]]==ind[v[i]]&&u[i]<v[i]))add_edge(u[i],v[i]);
	    else add_edge(v[i],u[i]);
	for(int i=1;i<=n;i++)
	    {
	    for(int j=h[i];j;j=e[j].nxt)b[e[j].v]=i;
	    for(int j=h[i];j;j=e[j].nxt)
	        {
	        int ad=max(a[i],a[e[j].v]);
	        for(int k=h[e[j].v];k;k=e[k].nxt)
	            if(b[e[k].v]==i)ans+=max(ad,a[e[k].v]);
	        }
	    }
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：0)

这道题略微卡常，如果使用邻接链表储存会不如用 $\rm vector$ 存图，因为用邻接链表存图会导致内存访问不连续。但我们知道 $\verb!O2!$ 优化可以优化掉这个问题，所以开 $\verb!O2!$ 之后就可以了。

# 题目大意

一个有 $n$ 个点 $m$ 条边的无向图，每个点有一个点权 $a$。


对于任意一个三元环 $(i,j,k)(i\lt j\lt k)$，它的贡献为 $\max \{a_i,a_j,a_k\}$。

求所有三元环的贡献和。

# 题目分析

怎么快速找到三元环？

考虑给所有边一个方向。

我们定义连边规则（令 $deg[i]$ 表示 $i$ 的度）：

连边 $u\to v$ 当且仅当

+ $deg[u]\lt deg[v]$

+ $deg[u]=deg[v]$ 且 $u\lt v$

通过这样的规则连出来图 $G$，考虑边 $(u,v)$，若有 $(v,w)$ 和 $(u,w)$ 则一定有三元环。具体地，可以先把 $u$ 的所有出边所指向的点打上标记，这样从 $v$ 开始枚举时就能够快速判断是否存在边 $(u,w)$ 了。在图 $G$ 中跑原本的朴素算法即可。

~~这不还是 $\mathcal{O(n^3)}$ 的？~~

奇妙的是，可以证明这样的时间复杂度是 $\mathcal{O(m\sqrt{m})}$ 的！！

对于每一条边 $(u,v)$，它对复杂度造成的贡献是 $out[v]$，因此总复杂度即为 $\sum\limits out[v]$，$out_v$ 是点 $v$ 的出度。

当 $v$ 在原图（无向图）上的度数不大于 $\sqrt m$ 时，新图每个节点的出度不可能小于原图的度数，所以 $out_v$ 不会超过 $\sqrt{m}$。

当 $v$ 在原图上的度数大于 $\sqrt m$ 时，它只能向原图中度数不小于它的点连边，又因为原图中所有的点的度数和为 $m$，所以原图中度数大于 $\sqrt m$ 的点只有 $\sqrt m$ 个。因此 $v$ 的出边只有 $\sqrt m$ 条，也即 $out_v = \sqrt m$。

综上，总时间复杂度 $\mathcal{O(m\sqrt{m})}$。

-------------
所以找到所有三元环后朴素统计即可。

# 代码

```cpp
// Problem: P6815 [PA2009]Cakes
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6815
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Date:2022-06-07 05:47
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5,M = 2.5e5 + 5;
struct Graph {
	int v,nxt;
} gra[M];
int head[N],val[N],deg[N],fr[M],to[M],vistime[N];
int n,m,idx;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
int main(void) {
	n = read(),m = read();
	for (register int i = 1;i <= n; ++ i) val[i] = read();
	for (register int i = 1;i <= m; ++ i) {
		fr[i] = read(),to[i] = read();
		deg[fr[i]] ++,deg[to[i]] ++;
	}
	for (register int i = 1;i <= m; ++ i) {
		if (deg[fr[i]] > deg[to[i]] || (deg[fr[i]] == deg[to[i]] && fr[i] > to[i])) std::swap(fr[i],to[i]);
		add(fr[i],to[i]);
	}
	long long ans = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = head[i];j;j = gra[j].nxt) {
			int v = gra[j].v;
			vistime[v] = i;
		}
		for (register int j = head[i];j;j = gra[j].nxt) {
			int v = gra[j].v;
			for (register int k = head[v];k;k = gra[k].nxt) {
				int w = gra[k].v;
				if (vistime[w] == i) {
					ans += std::max(val[i],std::max(val[v],val[w]));
				}
			}
		}
	}
	printf("%lld\n",ans);
	
	return 0;
}
```

---


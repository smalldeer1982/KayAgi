# 深海少女与胖头鱼

## 题目背景

Amazing John 做了一个梦，梦到他上上辈子是个少女。

她跳入了 OI ~~炉石~~ 的海洋，成为了[深海少女](https://music.163.com/#/song?id=22677451)，维护着海洋的秩序。

某一天，海洋遭到了胖头鱼群的入侵。为了维护深海的安全，Amazing John 带着大佬们与胖头鱼们战斗了 $9$ 天 $9$ 夜，但是鱼的数量并没减少。

![FGNB](https://cdn.luogu.com.cn/upload/image_hosting/7r0sort3.png)


## 题目描述

经过漫长的战斗，Amazing John 发现了战胜胖头鱼的方法：

总共有 $n$ 条带 「圣盾」的「胖头鱼」和 $m$ 条不带圣盾的胖头鱼，每次等概率对一条存活的胖头鱼造成「剧毒」伤害。

现在 Amazing John 想知道，期望造成多少次伤害可以杀死全部胖头鱼？

答案对 $998244353$ 取模。

「圣盾」：当拥有圣盾的胖头鱼受到伤害时，免疫这条鱼所受到的本次伤害。免疫伤害后，圣盾被破坏。

「胖头鱼」：在一条胖头鱼的圣盾被破坏后，给予其他所有没有死亡且没有圣盾的胖头鱼圣盾。

「剧毒」：立即杀死没有圣盾的胖头鱼。



## 说明/提示

本题共有 $20$ 个数据点，数据点从 $1$ 到 $20$ 编号。对于一个子任务，只有通过其中所有数据点才能获得该子任务的分数。
|子任务|数据点|数据范围|分数|
-|-|-|-|
|$1$|$1\sim3$|$n,m \le 5 \times 10^3$|$15$|
|$2$|$4\sim5$|$n \le 10^6$，$m=0$|$10$|
|$3$|$6\sim10$|$n,m \le 10^6$|$25$|
|$4$|$11\sim14$|$n \le 10^{14}$，$m=0$|$20$|
|$5$|$15\sim20$|$n \le 10^{14}$，$m\le 10^6$|$30$|

答案的形式 $\frac{p}{q}$ 必然满足 $(p,q\in \mathbb{N},998244353\nmid q)$

~~我会暗中支持你的，可别告诉别人——鲍勃。~~


## 样例 #1

### 输入

```
2 1```

### 输出

```
8```

## 样例 #2

### 输入

```
10 10```

### 输出

```
499122389```

## 样例 #3

### 输入

```
10 0```

### 输出

```
65```

## 样例 #4

### 输入

```
2 0```

### 输出

```
5```

# 题解

## 作者：Inlay1158 (赞：24)

这道题目是一道计算期望的题目，但是不要害怕，只要先从特殊情况入手，就不难了，而对于这道题来说，就可以先从 $m=0,1$ 的情况入手。

--------

设 $f(n,m)$ 为有 $n$ 个带护盾的和 $m$ 个不带护盾的胖头鱼。

当 $m=0$ 时，由于没有不带护盾的胖头鱼了，所以只能打有护盾的胖头鱼。

$$f(n,0)=f(n-1,1)+1$$

当 $m=1$ 时，如果攻击一个有护盾的，那么原来没盾的就会有盾，所以有

 $$f(n,1)=\dfrac{n}{n+1}\times f(n,1)+\dfrac{1}{n+1}\times f(n,0)+1$$

继续推，则有

$$f(n,1)=\dfrac{n}{n+1}\times f(n,1)+\dfrac{1}{n+1}\times f(n-1,1)+\dfrac{n+2}{n+1}$$

$$(n+1)\times f(n,1)=n\times f(n,1)+f(n-1,1)+n+2$$

$$f(n,1)=f(n-1,1)+n+2$$

这个显然可以用一个二次函数来表示 $f(n,1)$，代入特殊值后，可得 $f(n,1)=(n^2+5n+2)/2$，这样，这种情况就解决了。

--------

令 $g(n)=f(n,1)=(n^2+5n+2)/2$，考虑一般情况。  

当 $m>1$ 时，有

$$f(n,m)=\dfrac{n}{n+m}\times f(n+m-1,1)+\dfrac{m}{n+m}\times f(n,m-1)$$

进一步，得

$$f(n,m)=\dfrac{n}{n+m}\times g(n+m-1)+\dfrac{m}{n+m}\times f(n,m-1)$$

这样，最终得到：

$$f(n,m)=\begin{cases}g(n-1)+1&(m=0)\\g(n)&(m=1)\\\dfrac{n}{n+m}\times g(n+m-1)+\dfrac{m}{n+m}\times f(n,m-1)&(m>1) \end{cases}$$

然后记住随时取模即可。

递归版代码如下：

```cpp
#include<cstdio>
#define ll long long
using namespace std;
const ll MOD = 998244353;
ll quickpow(ll a, ll b) {ll res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD; return res;}
ll calc(ll x) {return ((x * x + x * 5 + 2) / 2) % MOD;}
ll f(ll n, ll m) {
	if (!m) return (f(n - 1, 1) + 1) % MOD; if (m == 1) return calc(n);
	return ((n * quickpow(n + m, MOD - 2)) % MOD * calc(n + m - 1) % MOD + (m * quickpow(n + m, MOD - 2)) % MOD * f(n, m - 1) + 1) % MOD; 
}
ll n, m;
int main() {
	scanf("%lld%lld", &n, &m);
	return 0 & printf("%lld", f(n % MOD, m));
}
```

非递归版代码如下：

```cpp
#include<cstdio>
#define ll long long
using namespace std;
const ll MOD = 998244353;
ll quickpow(ll a, ll b) {ll res = 1; for (; b; b >>= 1, a = a * a % MOD) if (b & 1) res = res * a % MOD; return res;}
ll calc(ll x) {return ((x * x + x * 5 + 2) / 2) % MOD;}
ll frac(ll x, ll y) {return (x * quickpow(y, MOD - 2)) % MOD;}
ll n, m, ans;
int main() {
	scanf("%lld%lld", &n, &m), n %= MOD, ans = calc(n);
	if (!m) return 0 & printf("%lld", (calc(n - 1) + 1) % MOD);
	for (ll i = 2; i <= m; ++i) ans = (frac(n, n + i) * calc(n + i - 1) + frac(i, n + i) * ans + 1) % MOD;
	return 0 & printf("%lld", ans);
}
```



---

## 作者：InformationEntropy (赞：10)

这次的 T2 比原来要难一些呀......

题意：开始有 $n$ 条带盾的鱼，$m$ 条无盾鱼，每次等概率地攻击任意一鱼，如果打到了无盾鱼则直接干掉它，否则除被打到的鱼的盾消失外其余存活的鱼都会带上盾，求干掉所有鱼的期望攻击次数。

一道推式子的期望题。

不妨先看 $m=0$ 的情况，设 1 为带盾，0 为不带盾。则初始状态为 11111......($n$ 个 1)。 现在，攻击任意一只鱼都有 $100\%$ 的该率使状态变为 111011.....（$n-1$ 个 1，1 个 0）。再攻击一次，则有  $\dfrac{1}{n}$ 的概率打到没盾的使状态变为 1111....($n-1$ 个 1)，有 $\dfrac{n-1}{n}$ 的概率打到有盾的使状态不发生改变。设 $g(i)$ 为有 $i$ 条鱼且每条鱼都有盾的期望攻击次数，则可得到以下式子：

$$g(i)=1+\dfrac{1}{i}(g(i-1)+1)+\dfrac{i-1}{i}g(i)$$

其中，1 表示开始攻击的那一次，$g(i-1)$ 要加 1 是因为需要再打一次才能变为 $i-1$ 个 1 的状态。还有一个重要的点：$i-1$ 个 1，1 个 0 的状态的期望攻击次数为 $g(i)-1$，加上再攻击的那一次就变为 $g(i)$。

两边都有 $g(i)$，怎么办？把它当做一个方程解出来，得到：

$$\dfrac{1}{i}g(i)=1+\dfrac{1}{i}(g(i-1)+1)$$
$$g(i)=i+g(i-1)+1$$

已知 $g(0)=0$，那么可以通过找规律或推导得到通项公式 $g(i)=\dfrac{i\times (i+3)}{2}$。

到此为止，你已经有30pts了。

$m\not=0$ 的思路差不多，打一次有 $\dfrac{m}{n+m}$ 的概率干掉一个没盾的，有 $\dfrac{n}{n+m}$ 的概率打到有盾的使状态变为 111011......($n+m-1$ 个 1， 1 个 0)，是不是很眼熟？它就等于 $g(n+m)-1$

设 $f(i)$ 为当前 $n$ 的情况下有 $i$ 个没盾的时的期望攻击次数，那么可得：

$$f(i)=1+\dfrac{i}{i+n}f(i-1)+\dfrac{n}{i+n}(g(n+i)-1)$$

$$f(0)=g(n)$$

递推便可得到 $f(m)$。

把分数取膜化为整数意义计算，就可以愉快得写出代码了：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
template<class T>inline void read(T &x)
{
    x = 0;
    T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
const ll mod = 998244353;
ll mul(ll x, ll y)
{
    return ((x % mod) * (y % mod)) % mod;
}
ll qpow(ll a, ll b)
{
    ll p = mod - 2;
    ll ans = 1;
    while (p)
    {
        if (p & 1) ans = mul(ans, b);
        b = mul(b, b);
        p >>= 1;
    }
    return mul(ans, a);
}
ll g(ll n)
{
    if (n % 2 == 0)
    {
        return mul(n / 2, n + 3);
    } else {
        return mul(n, (n + 3) / 2);
    }
}
ll f[1000001];
int main()
{
    ll n, m;
    read(n);
    read(m);
    f[0] = g(n);
    for (int i = 1; i <= m; i++)
    {
        f[i] = (1 + mul(f[i - 1], qpow(i, i + n)) + mul(g(i + n) - 1, qpow(n, i + n))) % mod;
    }
    cout << f[m] << '\n';
    return 0;
}
```





---

## 作者：C锥 (赞：9)



​	期望DP。考场上没想出来，考完机房里一个大佬给我讲的%%%。

​	$ f[n][m] $表示击败$ n $个带圣盾的和$ m $个不带圣盾的所需要的期望攻击次数，可以列出DP转移方程：$ f[n][m] = \frac{n}{n + m} f[n + m - 1][1] + \frac{m}{n + m} f[n][m - 1] + 1 $。

​	应该还挺好理解的：如果本次攻击了带圣盾的，那么这只带圣盾的会变成一只普通的，其他所有的都会带上圣盾；如果攻击了没有带圣盾的，那么将会减少一只胖头鱼。

​	然后我们带一下特殊解：当$ m = 0 $时，$ f[n][0] = f[n - 1][1] + 1 $。

​	当$ m = 1 $时，$ f[n][1] = \frac{n}{n+ 1}f[n][1] + \frac{1}{n + 1} f[n][0] + 1 $，然后两边同乘一个$ n +1 $，再移项可以得到：

​	$ f[n][1] = f[n][0] + n + 1 = f[n - 1][1] + n + 2 = \frac{n ^ 2 + 5n + 2}{2} $，那么$ f[n][0] $也可以带入得到：$ f[n][0] = \frac{n ^ 2 + 3n}{2} $。

​	然后我们看最上面那个DP转移方程，$ n $那一维可以省去， 前半部分可以$ O(1) $求，后半部分递推求就好了。复杂度$ O(m \ logn) $

```cpp
#include <bits/stdc++.h>

using namespace std;

inline long long read() {
    long long s = 0, f = 1; char ch;
    while(!isdigit(ch = getchar())) (ch == '-') && (f = -f);
    for(s = ch ^ 48;isdigit(ch = getchar()); s = (s << 1) + (s << 3) + (ch ^ 48));
    return s * f;
}

const int N = 1e6 + 5, mod = 998244353;
int f, n, m, inv2, inv[N];

int ksm(int x, int y, int mod) {
    int res = 1;
    while(y) {
        if(y & 1) res = 1ll * res * x % mod;
        x = 1ll * x * x % mod; y >>= 1;
    }
    return res;
}

int calc_frac(int x, int y) {
    return 1ll * x * y % mod;
}

int calc(int x) {
    return (1ll * x * x % mod + 1ll * 5 * x % mod + 2) % mod * inv2 % mod;
}

void make_pre(int x) {
    for(int i = 1;i <= x; i++) inv[i] = ksm((n + i) % mod, mod - 2, mod);
}

int main() {

    n = read() % mod; m = read(); inv2 = ksm(2, mod - 2, mod);
    make_pre(m);
    f = (1ll * n * n % mod + 1ll * 3 * n % mod) % mod * inv2 % mod;
    for(int i = 1;i <= m; i++) 
        f = (1ll * calc((n + i) % mod - 1) * calc_frac(n, inv[i]) % mod + 1ll * calc_frac(i, inv[i]) * f % mod + 1) % mod;
    printf("%d", f);
    
    return 0;
}
```

---

## 作者：tommymio (赞：7)

拿到题自然先考虑 $m=0$ 的情况。设 $f_{i,j}$ 为场上有 $i$ 条带圣盾的鱼，$j$ 条不带圣盾的鱼。

可以发现任何时候只会有 $j\in \{0,1\}$，那么有转移方程：

$$
f_{i,0}=f_{i-1,1}+1
$$

$$
f_{i,1}=\frac{1}{i+1}f_{i,0}+\frac{i}{i+1}f_{i,1}+1
$$

由于 $f_{i,1}$ 的转移存在后效性（自己转移到自己），所以移项后柿子两边同时乘 $\frac{1}{i+1}$（尝试消去柿子右边的 $f_{i,1}$），可以得到：

$$
f_{i,1}=f_{i,0}+i+1
$$

非常好理解，当场上没有不带圣盾的鱼时，无论打哪一条都会让被打的那条鱼不带圣盾，而其他鱼无论之前状态如何，都会带圣盾。对于 $f_{i,1}$ 的理解同理。于是可以在 $O(n)$ 的复杂度内解决 $m=0$ 的情况。

但是 $n$ 非常大，我们考虑能否有一个与 $n$ 无关的复杂度。进一步观察，发现 $f_{i-1,1}$ 在 $f_{i,0}$ 的转移中并不是必要的，因为我们可以用 $f_{i-1,0}+i-1+1$ 来替代 $f_{i-1,1}$，这两者是等效的。于是得到：

$$
f_{i,0}=f_{i-1,0}+i+1
$$

使用等差数列求和公式求 $f_{n,0}$ 通项可以得到 $f_{n,0}=\frac{n(n+3)}{2}$。复杂度降至 $O(1)$。

现在考虑 $m\neq 0$ 的情况。事实上和 $m=0$ 的情况并没有什么区别。设之前场上有 $i$ 头带圣盾的鱼，$j$ 头不带圣盾的鱼，当打到了一个带圣盾的鱼后，情况变为场上有 $i+j-1$ 头带圣盾的鱼，$1$ 头不带圣盾的鱼，这部分情况我们之前已经计算过了。

那么对于 $m\neq 0$ 的情况，我们只需要按照上述分析把 $m$ 头鱼的贡献加进答案即可。设 $g_i$ 为场上还剩下 $i$ 头不带圣盾的鱼，$n$ 头带圣盾的鱼，有：

$$
g_i=\frac{i}{n+i}(g_{i-1}+1)+\frac{n}{n+i}(f_{n+i-1,1}+1)
$$

$f_{n+i-1,1}$ 的计算也很简单，因为对于任意 $f_{i,1}$ 均有 $f_{i,1}=f_{i,0}+i+1$，而 $f_{i,0}$ 可以在 $O(1)$ 时间复杂度内计算出来。

使用线性求逆元，至此在 $O(m)$ 时间复杂度内解决了该问题（不过我代码中是 $O(\log P)$ 的逆元，因为是赛时代码

公式有什么问题的话请积极指出，因为公式确实有点多容易打错/kel（逃

**Show the Code**

```
#include<cstdio>
#define int ll
typedef long long ll;
const ll mod=998244353;
ll g[1000005];
inline ll pow(ll x,ll p) {ll res=1; for(;p;p>>=1) {if(p&1) res=res*x%mod; x=x*x%mod;} return res;}
signed main() {
	ll n,m;
	scanf("%lld%lld",&n,&m); 
	n%=mod; g[0]=(n*(n+3)/2)%mod; 
	for(register int i=1;i<=m;++i) g[i]=(i*(g[i-1]+1)%mod*pow(n+i,mod-2)%mod+n*((n+i)*(n+i+3)/2%mod)%mod*pow(n+i,mod-2)%mod)%mod;
	printf("%lld\n",g[m]);
	return 0;
}
```


---

## 作者：minxu (赞：4)

[题目](https://www.luogu.com.cn/problem/P6858)



因为有$m=0$的部分分 

我们先考虑$m=0$的情况 经过一系列手膜

我们发现$m=0$时的答案是一个序列 为$(n+2)*(n+1)/2-1$

我们设$f[i][j]$表示打死$i$只带圣盾的$j$只不带圣盾的期望次数

具体形式化的用式子推出的话是$f[i][0]=f[i-1][1]+1=\frac{1}{i}*f[i-1][0]+\frac{(i-1)}{i}*f[i-1][1]+1+1$

移项可以得到$f[i][1]=f[i-1][0]+i$

所以原式$f[i][0]=f[i-1][0]+i+1$

实际上就是一个等差数列 可以自己写出几项得出公式 代码里用的是我手摸的$(n+2)*(n+1)/2-1$

以$f[3][1]$为例

$f[3][1]=\frac{1}{4}*f[3][0]+\frac{3}{4}*f[3][1]+1$

我们把式子移一下项得

$f[3][1]=f[3][0]+4$


一般形式为

$f[i][j]=\frac{i}{i+j}*f[i+j-1][1]+\frac{j}{i+j}*f[i][j-1]+1$

我们发现这是可以递归下去的(比赛的时候以为数组开不下)

所以我们也就可以推出答案了(因为我用的递归写法 所以需要特判$m=1$和$m=0$的情况)

所以这道题就做完了(注意可能要用快速乘)

总之希望做期望题的时候大家都不要有畏难情绪 

记住期望的方程的转移一般就是枚举每种可能的概率再乘以该种可能的期望步数再加上1意为多用一步到达那一种状态

相信大家都可以推出式子的
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 5e3;
const int mod = 998244353;
long long n, m;
ll ksm(ll a, ll b)
{
    a %= mod;
    ll res = 1, base = a % mod;
    while (b)
    {
        if (b & 1)
            res = res * base % mod;
        base = base * base % mod;
        b >>= 1;
    }
    return res;
}
inline ll ksc(ll a, ll b)
{
    ll ans = 0;
    while (b)
    {
        if (b & 1)
            ans = (ans + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return ans;
}
ll dfs(ll n, ll m)
{
    //f[2][1]=2/3*f[2][1]+1/3*f[2][0]+1;
    ll ans;
    if (m == 0)
    {
        ll s1, s2;
        if (n % 2 == 1)
            s1 = (n + 1) / 2, s2 = n + 2;
        else
            s1 = n + 1, s2 = (n + 2) / 2;
        ans = ksc(s2, s1) % mod - 1;
        return (ans + mod) % mod;
    }
    if (m == 1)
    {
        return (dfs(n, 0) % mod + n + m) % mod;
    }
    return (ksc(m, ksm(n + m, mod - 2)) % mod * dfs(n, m - 1) % mod + n * ksm(n + m, mod - 2) % mod * dfs(n + m - 1, 1) % mod + 1) % mod;
}
int main()
{
    cin >> n >> m;
    //for(int i=1;i<=n;++i)
    if (m == 0)
    {
        ll s1, s2;
        if (n % 2 == 1)
            s1 = (n + 1) / 2, s2 = n + 2;
        else
            s1 = n + 1, s2 = (n + 2) / 2;
        ll ans = ksc(s2, s1) % mod - 1;
        printf("%lld\n", (ans + mod) % mod);
    }
    else
        printf("%lld\n", dfs(n, m));
    return 0;
}
```

---

## 作者：Eqvpkbz (赞：2)

### Description

给定终止状态 $(0, 0) = 0$

$$(n, m) = \frac{n}{n + m} \times [(n + m - 1, 1) + 1] + \frac{m}{n + m} \times [(n, m - 1) + 1]$$

求状态 $(n, m)$ 

### Solution

对 $m$ 进行分类讨论:

若 $m = 0$, 那么 $(n, 0) = (n - 1, 1) + 1$

若 $m > 1$, 那么 $(n, m) = \frac{n}{n + m} \times [(n + m - 1, 1) + 1] + \frac{m}{n + m} \times [(n, m - 1) + 1]$

我们发现两种状态都与 $(n, 1)$ 有关，所以考虑 $m = 1$ 的情况

先考虑 $(1, 1)$ 的情况， $(1, 1) = \frac{1}{2} \times [(1, 1) + 1] + \frac{1}{2} \times [(1, 0) + 1]$

$(1, 0) = (0, 1) + 1 = (0, 0) + 1 + 1 = 2$ 然后展开计算得 : 

$$(1, 1) = \sum\limits_{i = 1}^\infty\frac{(1, 0) + i}{2^i}$$

这个式子显然是收敛的， 这就好像是下面这个式子会无限接近$2$: 

$$1 + \frac{1}{2} +\frac{1}{4} +\frac{1}{8} + \frac{1}{16} + \frac{1}{32} + \cdots = 2$$

考虑计算这个式子:

$$\sum\limits_{i = 1}^\infty\frac{(1, 0) + i}{2^i} = \sum\limits_{i = 1}^\infty\frac{(1, 0)}{2^i} + \sum\limits_{i = 1}^\infty\frac{i}{2^i}$$

注意到 $\sum\limits_{i = 1}^\infty\frac{(1, 0)}{2^i}$ 是一个等比数列， 考虑等比数列求和公式: 

$\because a_1 = \dfrac{(1, 0)}{2}, q = \dfrac{1}{2}, S = a_1 \dfrac{1 - q^{\infty}}{1 - q}, \therefore S = (1, 0) = 1$, 其中 $q^{\infty}$ 看做 $0$

可以将 $\sum\limits_{i = 1}^\infty\frac{i}{2^i}$ 转化为 $\sum\limits_{i = 1}^\infty\frac{1}{2^i} + \sum\limits_{i = 2}^\infty\frac{1}{2^i} + \sum\limits_{i = 3}^\infty\frac{1}{2^i} + \cdots$

$$\because \sum\limits_{i = 1}^\infty\frac{1}{2^i} = 1, \therefore \sum\limits_{i = 2}^\infty\frac{1}{2^i} = \frac{1}{2}, \sum\limits_{i = 3}^\infty\frac{1}{2^i} = \frac{1}{4}, \cdots$$

所以有: 

$$\sum\limits_{i = 1}^{\infty}\dfrac{i}{2^i} = \sum\limits_{i = 0}^{\infty}\dfrac{1}{2^i} = 2$$

即 

$$(1, 1) = \sum\limits_{i = 1}^\infty\frac{(1, 0) + i}{2^i} = \sum\limits_{i = 1}^\infty\frac{(1, 0)}{2^i} + \sum\limits_{i = 1}^\infty\frac{i}{2^i} = 2 + 2 = 4$$

接下来考虑 $(n, 1)$ 的值， 先写出式子

$$(n, 1) = \frac{(n, 0) + 1}{n + 1} + \frac{n}{n + 1} \times [(n, 1) + 1]$$

可重写为:

$$\begin{aligned}(n, 1) & = \sum\limits_{i = 0}^{\infty}{(\dfrac{n}{n + 1})}^{i}\times \dfrac{(n, 0) +i}{n+1} \\
& = \sum\limits_{i = 0}^{\infty}{(\dfrac{n}{n + 1})}^{i}\times \dfrac{(n, 0)}{n+1} + \sum\limits_{i = 1}^{\infty}{(\dfrac{n}{n + 1})}^{i}\times \dfrac{i}{n+1}\end{aligned}$$

同理可得: 

$$(n, 1) = (n, 0) + n = (n - 1, 1) + n + 1, (1, 1) = 4$$

运用数学必修三的数列知识求通项公式， 可得:

$$(n, 1) = \dfrac{(n + 1)(n + 4)}{2} - 1$$

又因为 

$$\begin{aligned}
(n, m) & = \dfrac{n \times (n + m - 1, 1)}{n + m} +\dfrac{m \times (n, m - 1)}{n + m} \\
 & = \dfrac{n \times (n + m - 1, 1) + m \times (n, m - 1)}{n + m}\end{aligned}$$

便能够 $O(m)$ 的进行递推了

```cpp
#include<cstdio>
typedef long long ll;
const ll MOD = 998244353;
const ll inv2 = 499122177;
inline void exgcd(ll a,ll b,ll &x,ll &y){
    if(!b) { x = 1; y = 0; return ; }
    exgcd(b, a % b, y, x); y -= x * (a / b);
    return ;
}
static inline ll inv(ll num){
    ll x, y; exgcd(num, MOD, x, y);
    while(x < 0) x += MOD; return x;
}
inline ll mul(ll x){
    ++ x , x %= MOD;
    return (((x * (x + 3)) % MOD * inv2) % MOD - 1 + MOD) % MOD;
}
ll calc(ll n, ll m){
    n %= MOD;
    if(m == 1) return mul(n);
    if(!m) return (mul(n + m - 1) + 1) % MOD;
    ll INV = inv(m + n);
    ll ans1 = (((mul(n + m - 1) + 1) * n) % MOD * INV) % MOD;
    ll ans2 = (((calc(n, m - 1) + 1) * m) % MOD * INV) % MOD;
    return ( ans1 + ans2 ) % MOD;
}
int main(){
    ll n, m; scanf("%lld%lld", &n, &m);
    printf("%lld\n", calc(n, m)); return 0;
}
```

---

## 作者：Fairicle (赞：1)

这题的重要性质是如果我们攻击了一次带圣盾的鱼，那么接下来除了刚刚被攻击的鱼，其他的鱼都套上了圣盾。因此我们不妨定义 $f(n)$ 表示 $n-1$ 头套上圣盾， $1$ 头没套圣盾的期望，$g(n)$ 表示 $n$ 头鱼全套上圣盾的期望。

那么显然有 $f(n)=\frac{1}{n}(g(n-1)+1)+\frac{n-1}{n}(f(n)+1)$

又容易看出 $g(n)=f(n)+1$

代入上式，可解得 $f(n)=f(n-1)+n+1$。特别地，$f(1)=1$。

那么就得出 $f(n)=\frac{n^2+3n-2}{2}$

接下来只需要从 $1$ 到 $m+1$，枚举哪一次攻击了一个带圣盾的鱼，形成了 $f(n)$ 能够表示的状态。

也就是 $\frac{n}{n+m}f(n+m)+\frac{m}{n+m}\times\frac{n}{n+m-1}f(n+m-1)+\frac{m}{n+m}\times\frac{m-1}{n+m-1}\times\frac{n}{n+m-2}f(n+m-2)+...+\frac{m}{n+m}\times\frac{m-1}{n+m-1}\times...\times\frac{n}{n}f(n)$

那么就可以做了。
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
#define N 1000010
#define mod 998244353
ll m,n,inv2;
inline ll ksm(ll x,int y){
	ll res=1;x%=mod;
	while(y){
		if(y&1) res*=x,res%=mod;
		x*=x,x%=mod;
		y>>=1;
	}
	return res;
}
inline ll f(ll x){
	return (x*x+3ll*x-2ll+mod)%mod*inv2%mod;
}
int main(){
	cin>>n>>m;
	n%=mod;
	inv2=ksm(2,mod-2);ll bas=1,ans=0,cnt=1;
	ll del=n*ksm(m+n,mod-2)%mod*(f(m+n)+1)%mod;
	ans=del;
	for(ri i=1;i<=m;++i){
		++cnt;
		bas=bas*(m-i+1)%mod*ksm(m-i+1+n,mod-2)%mod;
		ll del=bas*n%mod*ksm(m+n-i,mod-2)%mod*(f(m+n-i)+i+1)%mod;
		ans=(ans+del)%mod;
	}
	cout<<ans;
	return 0;
}
```


---


# 蝴蝶与花

## 题目背景

Amazing John 做了一个梦，梦到他上辈子是只苍茫蝶。

深壑幽兰，雨落苍茫。

怜其折翅，苦其执魔。

琼片织翼，花露饯行。

伶仃蝶碎，兰枯有情。

君不识妾，妾仍思君。

## 题目描述

Amazing John 很喜欢花。

Amazing John 的花圃里有 $n$ 朵花，他每天都会在花园里散步。

对于每一朵花 Amazing John 会评价它好看或不好看。被评价好看的花的美丽值为 $2$，被评价不好看的花的美丽值为 $1$。

我们可以抽象的把这 $n$ 朵花看做在一条直线上。每次散步时， Amazing John 会从任意一朵花开始，一直往下一朵花走。到任意一朵花结束。在路途中，他会将所有经过的花的美丽值统计下来。（当然包括开始的花和结束的花）

现在 Amazing John 想知道，能否有一种散步方案，使得他从第 $l$ 朵花走到第 $r$ 朵花的美丽值之和正好是 $s$？

为了少走一些路， Amazing John 要你给出在所有方案中 $l$ 最小的方案。

当然，为了避免在花圃中散步过于单调， Amazing John 随时可能会将一朵花的美丽值更改。

每个询问之间互相独立，即统计过的花朵在下次询问时仍可被统计。

## 说明/提示

$\operatorname{Subtask\ 1}\ (20pts)$：对于数据点 $1\sim 5$，满足 $1\leq n,m\leq 1000$。

$\operatorname{Subtask\ 2}\ (30pts)$：对于数据点 $6\sim 10$，满足 $1\leq n,m\leq 2.5\times 10^5$。

$\operatorname{Subtask\ 3}\ (50pts)$：对于数据点 $11\sim 15$，满足 $1\leq n,m\leq 2\times 10^6$。

对于 $100\%$ 的数据，有 $1\leq n,m\leq 2\times 10^6,0\leq s\leq 2^{31}-1$。每次修改操作时 $i\in[1,n],val\in\{1,2\}$。

对于所有数据点，时间限制 $2000\operatorname{ms}$，空间限制 $256\operatorname{MB}$。

## 样例 #1

### 输入

```
5 4
1 2 2 1 1
A 5
C 1 2
A 5
A 233```

### 输出

```
1 3
2 4
none```

# 题解

## 作者：stoorz (赞：26)

## UPD on 2020.11.23

感谢神仙验题人 @[QuantAsk](https://www.luogu.com.cn/user/52918) 和 @[beginend](https://www.luogu.com.cn/user/11788) CCCCOrz。

这道题的 idea 最初来源于 [P3514 [POI2011]LIZ-Lollipop](https://www.luogu.com.cn/problem/P3514)，那道题利用其它性质可以 $O(n)$ 预处理答案，$O(1)$ 回答。并不支持修改操作。

然后有一天和 QuantAsk 讨论这题的时候想出了支持修改的 $O(m\log n)$ 做法，然后就有了这道题 /fad。

看到有人说这道题卡常 /kk，将数据范围开这么大是因为 $O(m\log^2 n)$ 做法常数实在是太小了，我尝试构造了很多数据都可以轻松跑过，所以最终只能在数据范围下手。

有神仙写线段树被卡常，但[我](https://www.luogu.com.cn/record/40801885)和[验题人](https://www.luogu.com.cn/record/39605372)的递归版线段树都是可以在不加 O2 下 $2s$ 跑过的。至于有神仙写 Splay。。。那我真的感到抱歉了 /kel。

std 是树状数组，所以常数小一点，我尝试了很多次，在不加 O2 下都可以在 $1s$ 内跑过。

## 题意简述

给出一个长度为 $n$ 的 $1,2$ 序列。要求支持单点修改，查询和为 $k$ 且左端点尽量小的区间。 

## 算法 1

枚举左端点，发现在左端点不断向右扫描的过程中，右端点的位置也一定单调不减。所以不用每次重新开始扫描右端点，在上一次扫描的基础上继续向右即可。

时间复杂度 $O(nm)$，期望得分 $20pts$。

## 算法 2

将原序列做前缀和，设做前缀和后的序列为 $s$，问题转化为求最小的两个位置 $i,j$ 使得 $s_j-s_i=k$。

对于修改操作，相当于将序列 $s$ 的一段后缀全部加上一个数；对于查询操作，可以枚举左端点，二分出右端点，如果这一段区间的和为 $k$ 即为答案。

时间复杂度 $O(nm\log n)$ 或 $O(nm\log^2 n)$，取决于是在数据结构内二分还是二分套数据结构。写的好看一些或许可以拿到 $20pts$。

甚至没有算法 1 优秀。

## 算法 3

在算法 2 中，容易发现我们二分出的每一段区间和要么是 $k$，要么是 $k+1$。因为如果和大于 $k+1$ 的话，右端点向左移动一位和肯定不小于 $k$。

假设我们二分出的两个区间为 $[l,r_1]$ 和 $[l+1,r_2]$，且这两个区间的和均为 $k+1$，那么：

- $a_l$ 一定等于 $2$，否则 $[l+1,r_1]$ 就是一个合法的和为 $k$ 的区间。

- $a_{r_1}$ 一定等于 $2$，否则 $[l,r_1-1]$ 就是一个合法的和为 $k$ 的区间。

- $r_2=r_1+1$，因为 $\sum^{r_1}_{i=l} a_i=\sum^{r_2}_{i=l+1}a_i-\sum^{r_2}_{i=r_1+1}a_i+a_l$，而 $a_l=2$，当 $r_2>r_1+1$ 时， $\sum^{r_2}_{i=r_1+1}a_i=2$ 当且仅当 $r_2=r_1+2$ 且 $a_{r_1+1}=a_{r_1+2}=1$，此时区间 $[l,r_1+1]$ 就是一个合法的和为 $k$ 的区间。

最后一点换句话说，黄色部分的和一定等于蓝色部分的和，而蓝色部分的和为 $2$，那么只有当 $r_2=r_1+1$ 且 $a_{r_2}=2$ 时才满足条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/vtvb4m6y.png)

那如果再加入一个区间 $[l+2,r_3]$，那么就有 $a_{l+1}=a_{r2}=2,r_3=r_2+1$。我们发现，只要接下来有一个位置不是 $2$ 了，那么一定存在一个和为 $k+1$ 的区间，也就是答案区间与连续的 $2$ 的个数有关。

那么我们用数据结构维护前缀和，对于每一次询问，二分出从位置 $1$ 开始和不小于 $k$ 的区间 $[1,p]$。然后再用数据结构求出位置 $1$ 和位置 $p$ 后连续的 $2$ 的个数，假设分别为 $cnt1$ 个和 $cnt2$ 个，

- 当 $cnt1<cnt2$ 时，区间 $[2+cnt1,p+cnt1]$ 即为答案。

- 当 $cnt1\geq cnt2$ 时，区间 $[1+cnt2,p+cnt2]$ 即为答案。

可以手写小数据来理解。

那么我们需要解决两个问题：

1. 如何找到第一个前缀和不小于 $k$ 的位置。

2. 如何求出一个位置后面有多少个连续的 $2$。

对于问题 1，直接采用二分+数据结构即可。对于问题 2，依然可以二分长度，假设为 $len$，那么只需要判断区间 $[p,p+len-1]$ 的和是否为 $2\times len$ 即可。

采用树状数组或者线段树实现均可。

时间复杂度 $O(m\log^2 n)$，期望得分 $50pts$。

## 算法 4

可以在算法 3 的基础上，在数据结构内二分。可以省掉一个 $\log$。

树状数组二分或线段树二分均可，后者写法不优美可能会被卡。

时间复杂度 $O(m\log n)$，期望得分 $100pts$。

---

## 作者：a___ (赞：19)

题意简述：给定一个长为 $n$ 的序列 $a_i$ （$\forall a_i\in\{1,2\}$），带修，每次询问序列中是否有一段区间区间和为 $s$。   

发现题目要求输出方案左端点最小，所以考虑从 $1$ 向右移动左端点寻找第一个合法方案。   

由于序列中的数仅有 $1,2$ 两种，所以一个左端点不合法当且仅当其向右第一个使区间和大于等于 $s$ 的位置的数为 $2$，且这段的区间和恰好等于 $s+1$。  

现在我们向右移动左端点，希望上述区间和从 $s+1$ 变为 $s$ ，即区间和减 $1$。   

每次左端点加 $1$，分类讨论：    
1. 原区间左端点的数为 $1$  
	右端点不变，区间和减 $1$ ，找到答案。
2. 原区间右端点右边一个数为 $1$    
	右端点加 $1$ ，区间和减 $2$（左） 加 $1$（右），共计减 $1$ ，找到答案。   
3. 原区间左端点及右端点右边一个数为均为 $2$    
	新区间右端点加 $1$，区间和减 $2$（左） 加 $2$（右），共计不变，未找到答案。   
    
于是这个题就变成了寻找左端点和右端点右边第一个 $1$ 的位置。。。

这个用线段树大力维护就好了。可以使用两个线段树，一个维护区间和，一个维护区间内 $1$ 的个数。然后在线段树上二分实现。    

具体实现见[代码](https://www.luogu.com.cn/paste/pak7zv1p)。

注意这题卡常（也可能是我太菜了qwq），我把线段树上二分的实现由递归改为循环才过的。

---

## 作者：BFqwq (赞：15)

## P6859

不难想到，要使区间的 $l$ 尽量小，那么最优情况肯定是从最左端开始取。

由于带修，所以直接考虑线段树或树状数组维护。

如果恰好存在一个点 $r$，使得 $\sum_{i=1}^r a_i=s$，那么我们可以在线段树上二分/树状数组上二分来求得 $r$ 的值。

如果没有的话，我们必然可以找到一个 $r$，使得 $\sum_{i=1}^r a_i=s+1$（注意提前特判掉 $\sum_{i=1}^n<s$ 的情况），因为任何一个值不是 $1$ 就是 $2$。显然，对于这种情况，$a_r=2$（否则 $1$ 和 $r-1$ 就满足条件了）。

对于第二种情况，我们可以将两个端点一同向后推。当推到 $a_r=1$ 时，且 $a_1$ 到 $a_{l-1}$ 全部为 $2$ 时，这个区间就合法了（因为前面左边 $-2$ 右边 $+2$，区间的和不变）。或者推到某个区间 $a_l=1$ 且右边的那几位没有出现 $1$ 的时候，取 $l+1$ 和 $r$ 同样合法。

假设 $1$ 后的第一个 $1$ 为 $pos1$，$r$ 后的第一个 $1$ 为 $pos2$，则 $[pos1+1,pos1+r-1]$ 与 $[pos2-r+1,pos2]$ 中 $l$ 较小的区间就是我们要求的区间。

所以实际上我们就要考虑左右哪边先出现 $1$。于是此时就可以考虑用一个 set 对 $1$ 进行维护。

复杂度 $\operatorname O(n\log n)$，常数很小。

code：

```cpp
#include<bits/stdc++.h>
#define inf 987654321
using namespace std;
int read(){
	bool f=1;
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=0;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)-48+c;
		c=getchar();
	}
	return f?x:x*-1;
}
char cr[200];int tt;
inline void print(register int x,register char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=2e6+5;
int t[maxn<<2],n,a[maxn],m;
set<int> s;
set<int>::iterator it;
inline void build(register int o,register int l,register int r){
	if(l==r){
		t[o]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	t[o]=t[o<<1]+t[o<<1|1];
}
inline void change(register int o,register int l,register int r,register int q){
	if(l==r){
		t[o]=a[l];
		return;
	}
	int mid=l+r>>1;
	if(q<=mid) change(o<<1,l,mid,q);
	else change(o<<1|1,mid+1,r,q);
	t[o]=t[o<<1]+t[o<<1|1];
}
struct ask{
	int pos,sum;
};
inline ask query(register int o,register int l,register int r,register int sum,register int tar){
	if(l==r){
		ask tmp;
		tmp.sum=sum+t[o];
		tmp.pos=l;
		return tmp;
	}
	int mid=l+r>>1;
	if(sum+t[o<<1]>=tar) return query(o<<1,l,mid,sum,tar);
	else return query(o<<1|1,mid+1,r,sum+t[o<<1],tar);
}
signed main(){
	n=read();m=read();
	for(register int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]==1){
			s.insert(i);
		}
	}
	build(1,1,n);
	for(register int i=1;i<=m;i++){
		char ch=getchar();
		while(ch!='A'&&ch!='C'){
			ch=getchar();
		}
		if(ch=='C'){
			int pos=read();
			if(a[pos]==1) s.erase(pos);
			a[pos]=read();
			if(a[pos]==1) s.insert(pos);
			change(1,1,n,pos);
		}
		else{
			int tar=read();
			if(tar==0||tar>t[1]){
				puts("none");
				continue;
			}
			ask tmp=query(1,1,n,0,tar);
			int pos=tmp.pos;
			int sum=tmp.sum;
			while(sum<tar){
				pos++;
				sum+=a[pos];
			}
			if(sum==tar){
				print(1,' ');
				print(pos);
				continue;
			}
			int pos1=inf,pos2=inf,len=pos-1;
			if(s.begin()!=s.end()) pos1=*s.begin();
			it=s.lower_bound(pos);
			if(it!=s.end()) pos2=*it;
			if(pos1+len>n && pos2>n){
				puts("none");
				continue;
			}
			if(pos1>=pos2-len){
				print(pos2-len,' ');
				print(pos2);
			}
			else{
				print(pos1+1,' ');
				print(pos1+len);
			}
		}
	}
	return 0;
}
```
本来是洛谷最快的，后来被一个人超了（

---

## 作者：ModestCoder_ (赞：11)

这是一个超难题的模板，但是有一个性质，$a_i=1/2$，我敏锐的感觉到这道题可能是基于这个性质来做的

先令$l=1$，看看是否存在$r$，使得$a_l+...+a_r=s$

发现不存在这个$r$，当且仅当存在$r$，使得$\sum_{i=l}^{r}a_i=s-1且a_{r+1}=2$

如果存在$r$满足，当然直接输出，若是不存在

必定形如![在这里插入图片描述](https://img-blog.csdnimg.cn/20201025115453820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vZGVzdENvZGVyXw==,size_16,color_FFFFFF,t_70#pic_center)

考虑移动$l,r$，然后这个时候一个必定的条件是$a_{r+1}=2$

如果$a_1=1$，可以使$l+1,r+1$，这样整段区间和+1，得到答案

如果$a_1=2,a_{r+2}=1$，可以$l+1,r+2$，也能得到答案

发现其实答案跟**l右端第一个1的位置与r右端第一个1的位置**有关

记$p1,p2$分别代表$l,r$右端第一个1的位置

若不存在另行讨论

那么又可以得到从$l->p1$之间有$lsum = p1-1$个2

$r->p2$之间有$rsum=p2-r-1$个2

讨论$lsum,rsum$的大小（具体原因可以在草稿纸上得出）

- $lsum<rsum:l=p1+1,r=p1+r$
- $lsum=rsum:l=p1,r=p2$
- $lsum>rsum:l=rsum+1,r=p2$

题目就做出来了

问题来到如何求出$r,p1,p2$，这个可以用数据结构直接来维护

如果用树状数组，需要套上二分，复杂度$O(nlog^2n)$

如果用线段树，直接$O(nlogn)$

我两个都写了

Code树状数组（这个要开O2才能过）：

```cpp
#include <bits/stdc++.h>
#define maxn 2000010
using namespace std;
int tree1[maxn], tree2[maxn], n, m, a[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int lowbit(int x){ return x & -x; }
void update1(int x, int y){ for (; x <= n; x += lowbit(x)) tree1[x] += y; }
void update2(int x, int y){ for (; x <= n; x += lowbit(x)) tree2[x] += y; }
int query1(int x){ int s = 0; for (; x; x -= lowbit(x)) s += tree1[x]; return s; }
int query2(int x){ int s = 0; for (; x; x -= lowbit(x)) s += tree2[x]; return s; }

int find(int s){
	int l = 1, r = n, ans = -1;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (query1(mid) <= s) ans = mid, l = mid + 1; else r = mid - 1;
	}
	return ans;
}

int find1(int x){
	int l = x, r = n, ans = -1, base = query2(x - 1);
	while (l <= r){
		int mid = (l + r) >> 1;
		if (query2(mid) > base) ans = mid, r = mid - 1; else l = mid + 1;
	}
	return ans;
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i){
		a[i] = read();
		update1(i, a[i]), update2(i, a[i] == 1);
	}
	int p1 = find1(1);
	while (m--){
		char c = getchar();
		for (; c != 'C' && c != 'A'; c = getchar());
		int x = read();
		if (c == 'A'){
			if (x == 1){
				if (p1 == -1) puts("none");
				else printf("%d %d\n", p1, p1); continue;
			}
			if (query1(n) < x){
				puts("none"); continue;
			}
			int pos = find(x);
			if (pos < 1){
				puts("none"); continue;
			} else
			if (query1(pos) == x){
				printf("%d %d\n", 1, pos); continue;
			}
			int p2 = find1(pos + 1);
			if (p1 == -1){
				puts("none"); continue;
			}
			if (p2 == -1){
				if (n - pos <= p1 - 1) puts("none");
				else printf("%d %d\n", p1 + 1, pos + p1);
				continue;
			}
			int l1 = p1 - 1, l2 = p2 - pos - 1;
			if (l1 < l2) printf("%d %d\n", p1 + 1, pos + p1);
			else if (l1 == l2) printf("%d %d\n", p1, p2);
			else printf("%d %d\n", l2 + 1, p2);
		} else{
			int y = read();
			if (a[x] != y){
				update1(x, -a[x] + y);
				if (y == 2) update2(x, -1); else update2(x, 1);
				a[x] = y;
				p1 = find1(1);
			}
		}
	}
	return 0;
}
```
Code线段树：

```cpp
#include <bits/stdc++.h>
#define maxn 2000010
#define ls rt << 1
#define rs rt << 1 | 1
using namespace std;
int n, m, a[maxn], ifequal;
struct Seg{
	int l, r, sum, cnt;
}seg[maxn << 2];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void pushup(int rt){
	seg[rt].sum = seg[ls].sum + seg[rs].sum;
	seg[rt].cnt = seg[ls].cnt + seg[rs].cnt;
}

void build(int rt, int l, int r){
	seg[rt].l = l, seg[rt].r = r;
	if (l == r){
		seg[rt].sum = a[l], seg[rt].cnt = (a[l] == 1);
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
	pushup(rt);
}

void update(int rt, int x, int y){
	if (seg[rt].l > x || seg[rt].r < x) return;
	if (seg[rt].l == seg[rt].r){
		seg[rt].sum = y;
		seg[rt].cnt = (y == 1);
		return;
	}
	update(ls, x, y), update(rs, x, y);
	pushup(rt);
}

int query(int rt, int x){
	if (seg[rt].r <= x) return seg[rt].cnt;
	if (seg[rt].l > x) return 0;
	return query(ls, x) + query(rs, x);
}

int query2(int rt, int x){
	if (seg[rt].r <= x) return seg[rt].sum;
	if (seg[rt].l > x) return 0;
	return query2(ls, x) + query2(rs, x);
}

int find1(int rt, int x){
	if (seg[rt].l == seg[rt].r) return seg[rt].cnt > x ? seg[rt].l : -1;
	if (seg[ls].cnt > x) return find1(ls, x);
	else return find1(rs, x - seg[ls].cnt);
}

int findpos(int rt, int x){
	if (seg[rt].sum == x){
		ifequal = 1;
		return seg[rt].r;
	}
	if (seg[rt].sum < x && seg[rt].sum + a[seg[rt].r + 1] > x) return seg[rt].r;
	if (seg[rt].l == seg[rt].r) return -1;
	if (seg[ls].sum >= x) return findpos(ls, x);
	else if (seg[ls].sum < x && seg[ls].sum + a[seg[ls].r + 1] > x) return seg[ls].r;
	else return findpos(rs, x - seg[ls].sum);
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i) a[i] = read();
	build(1, 1, n);
	int p1 = find1(1, 0);
	while (m--){
		char c = getchar();
		for (; c != 'C' && c != 'A'; c = getchar());
		int x = read();
		if (c == 'A'){
			if (x == 1){
				if (p1 == -1) puts("none");
				else printf("%d %d\n", p1, p1); continue;
			}
			if (seg[1].sum < x){
				puts("none"); continue;
			}
			ifequal = 0;
			int pos = findpos(1, x);
			if (pos < 1){
				puts("none"); continue;
			} else if (ifequal){
				printf("%d %d\n", 1, pos); continue;
			}
			int p2 = find1(1, query(1, pos));
			if (p1 == -1){
				puts("none"); continue;
			}
			if (p2 == -1){
				if (n - pos <= p1 - 1) puts("none");
				else printf("%d %d\n", p1 + 1, pos + p1);
				continue;
			}
			int l1 = p1 - 1, l2 = p2 - pos - 1;
			if (l1 < l2) printf("%d %d\n", p1 + 1, pos + p1);
			else if (l1 == l2) printf("%d %d\n", p1, p2);
			else printf("%d %d\n", l2 + 1, p2);
		} else{
			int y = read();
			if (a[x] != y) update(1, x, y), p1 = find1(1, 0), a[x] = y;
		}
	}
	return 0;
}
```

后来我翻一翻题解，发现大家都把线段树的几个部分改成非递归版本了，好像可以更快，我也改了一下

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 2000010
#define ls rt << 1
#define rs rt << 1 | 1
using namespace std;
struct Seg{
	int l, r, sum, cnt;
}seg[maxn << 2];
int  n, m, a[maxn], ifequal;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void pushup(int rt){
	seg[rt].sum = seg[ls].sum + seg[rs].sum;
	seg[rt].cnt = seg[ls].cnt + seg[rs].cnt;
}

void build(int rt, int l, int r){
	seg[rt].l = l, seg[rt].r = r;
	if (l == r){
		seg[rt].sum = a[l], seg[rt].cnt = a[l] == 1;
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
	pushup(rt);
}

void update(int rt, int x, int y){
	if (seg[rt].l == seg[rt].r){
		seg[rt].sum = y, seg[rt].cnt = (y == 1);
		return;
	}
	if (seg[ls].r >= x) update(ls, x, y);
	else update(rs, x, y);
	pushup(rt);
}

int query(int rt, int x){
	if (seg[rt].r <= x) return seg[rt].cnt;
	if (seg[rt].l > x) return 0;
	return query(ls, x) + query(rs, x);
}

int find1(int rt, int x){
	while (1){
		if (seg[rt].l == seg[rt].r){
			if (seg[rt].cnt > x) return seg[rt].l;
			else return -1;
		}
		if (seg[ls].cnt > x) rt = ls;
		else x -= seg[ls].cnt, rt = rs;
	}
	return -1;
}

int findpos(int rt, int x){
	while (1){
		if (seg[rt].sum == x){
			ifequal = 1;
			return seg[rt].r;
		}
		if (seg[rt].sum < x && seg[rt].sum + a[seg[rt].r + 1] > x) return seg[rt].r;
		if (seg[rt].l == seg[rt].r) return -1;
		if (seg[ls].sum >= x) rt = ls;
		else if (seg[ls].sum < x && seg[ls].sum + a[seg[ls].r + 1] > x) return seg[ls].r;
		else x -= seg[ls].sum, rt = rs;
	}
	return -1;
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i) a[i] = read();
	build(1, 1, n);
	int p1 = find1(1, 0);
	while (m--){
		char c = getchar();
		for (; c != 'C' && c != 'A'; c = getchar());
		int x = read();
		if (c == 'A'){
			if (x == 1){
				if (p1 == -1) puts("none");
				else printf("%d %d\n", p1, p1); continue;
			}
			if (seg[1].sum < x){
				puts("none"); continue;
			}
			ifequal = 0;
			int pos = findpos(1, x);
			if (pos < 1){
				puts("none"); continue;
			} else
			if (ifequal){
				printf("%d %d\n", 1, pos); continue;
			}
			int p2 = find1(1, query(1, pos));
			if (p1 == -1){
				puts("none"); continue;
			}
			if (p2 == -1){
				if (n - pos <= p1 - 1) puts("none");
				else printf("%d %d\n", p1 + 1, pos + p1);
				continue;
			}
			int l1 = p1 - 1, l2 = p2 - pos - 1;
			if (l1 < l2) printf("%d %d\n", p1 + 1, pos + p1);
			else if (l1 == l2) printf("%d %d\n", p1, p2);
			else printf("%d %d\n", l2 + 1, p2);
		} else{
			int y = read();
			if (a[x] != y){
				update(1, x, y);
				a[x] = y;
				p1 = find1(1, 0);
			}
		}
	}
	return 0;
}
```


---

## 作者：Fairicle (赞：6)

题目要求 $l$ 最小，那么必定是把左端点从最左端开始向右扫。

固定左端点为 $1$，二分出最小的位置 $pos$，使得 $\sum_{i=1}^{pos}a_i>=x$（事先特判总和小于 $x$ 和 $x=0$ 的情况）。

那么我们可以想到，$\sum_{i=1}^{pos}a_i=x$ 或 $\sum_{i=1}^{pos}a_i=x+1$。

第一种情况直接输出，对于第二种情况必定有 $a_{pos}=2$，否则 $[1,pos-1]$ 可行，同时，若 $a_{1}=1$，可以直接输出 $2\ pos$。

那么就剩下了 $a_1=2$ 且 $a_{pos}=2$ 的情况。不难想到需要寻找左端点右边的最近的 $1$ 和右端点右边最近的 $1$，记这两个位置分别为 $lnxt,rnxt$。

不妨先设选了离右端点最近的 $1$，则最终答案右端点为 $rnxt$，那么左端点就应当是 $rnxt-pos+1$，且对于任意 $i\in[1,rnxt-pos]$ 都有 $a_i=2$，否则答案将不对，因为左端点扫描过程中漏掉了 $1$。所以有 $rnxt-pos<lnxt$。

若选了离左端点最近的$1$，则最终答案左端点为 $lnxt+1$，要加一是因为现在区间和比 $x$ 大 $1$ 因此要扫过这个 $1$ ，那么右端点是 $pos+lnxt-1$，依据上面讨论的此时有 $rnxt-pos>=lnxt$

当然还有无解的情况即两种方法的右端点都超过了 $n$。

所以最终答案就是$\begin{cases}{[rnxt-pos+1,rnxt]}&rnxt-pos<lnxt\\{[lnxt+1,pos+lnxt-1]}&rnxt-pos>=lnxt\end{cases}$

用线段树维护一下区间和以及区间 $1$ 个数，在线段树上二分就行啦。代码可能有点毒瘤

code：
```cpp
#define ri register int
#define ll long long
#define N 2000010
int n,m,a[N],x,y,z,sum[N<<2],num[N<<2];char ch[5];
inline int rd(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x;
}
inline void build(int id,int l,int r){
	if(l==r){sum[id]=a[l];num[id]=(a[l]==1);return;}
	int mid=(l+r)>>1;
	build(id<<1,l,mid),build(id<<1|1,mid+1,r);
	sum[id]=sum[id<<1]+sum[id<<1|1];
	num[id]=num[id<<1]+num[id<<1|1];
}
inline void update(int id,int l,int r,int des,int val){
	if(l==r){sum[id]=val;num[id]=(val==1);return;}
	int mid=(l+r)>>1;
	if(des<=mid) update(id<<1,l,mid,des,val);
	else update(id<<1|1,mid+1,r,des,val);
	sum[id]=sum[id<<1]+sum[id<<1|1];
	num[id]=num[id<<1]+num[id<<1|1];
}
inline int querysum(int id,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return sum[id];
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid) ans+=querysum(id<<1,l,mid,ql,qr);
	if(qr>mid) ans+=querysum(id<<1|1,mid+1,r,ql,qr);
	return ans;
}
inline int querynum(int id,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return num[id];
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid) ans+=querynum(id<<1,l,mid,ql,qr);
	if(qr>mid) ans+=querynum(id<<1|1,mid+1,r,ql,qr);
	return ans;
}
inline int binary_querysum(int id,int l,int r,int val){
	if(l>r) return 0;
	int mid;
	while(l<r){
		mid=(l+r)>>1;
		if(sum[id<<1]>=val) r=mid,id<<=1;
		else l=mid+1,val-=sum[id<<1],id=(id<<1)|1;
	}
	return l;
}
inline int binary_querynum(int id,int l,int r,int val){
	int mid;
	while(l<r){
		mid=(l+r)>>1;
		if(num[id<<1]>=val) r=mid,id<<=1;
		else l=mid+1,val-=num[id<<1],id=(id<<1)|1;
	}
	return l;
}
int main(){
	n=rd(),m=rd();
	for(ri i=1;i<=n;++i) a[i]=rd();a[n+1]=1;build(1,1,n+1);
	while(m--){
		scanf("%s",ch);
		if(ch[0]=='A'){
			x=rd();
		    if(x>sum[1]-1||x==0){puts("none");continue;}
		    int pos=binary_querysum(1,1,n+1,x);
		    if(querysum(1,1,n+1,1,pos)==x){printf("%d %d\n",1,pos);continue;}
		    if(a[1]==1){printf("%d %d\n",2,pos);continue;}
		    int lnxt=binary_querynum(1,1,n+1,1),rnxt=binary_querynum(1,1,n+1,querynum(1,1,n+1,1,pos)+1);
		    //cout<<pos<<" "<<lnxt<<" "<<rnxt<<endl;
		    //if(lnxt==n+1){puts("none");continue;}
		    if(pos+lnxt-1>n&&rnxt>n){puts("none");continue;}
		    if(rnxt-pos+1<lnxt+1){
		    	printf("%d %d\n",rnxt-pos+1,rnxt);
		    	continue;
			}
			else{
				printf("%d %d\n",lnxt+1,pos+lnxt-1);
				continue;
			}
		    //puts("none");
		}
		else{y=rd(),z=rd();a[y]=z;update(1,1,n+1,y,z);}
	}
	return 0;
}
```


---

## 作者：荣耀南冥 (赞：3)

# P6859 蝴蝶与花
[原题传送门](https://www.luogu.com.cn/problem/P6859)

## 题意：
给你一个序列，让你求出一个序列，让其和正好为 s ，不需要考虑长度最小，只需要考虑让 l 最小。同时支持修改。
## 20pts:
这就是最朴素的暴力了，考虑双指针，尺取法， head 和 tail 初始为 1，然后先向有移动 tail ，直到 tail 和 head 区间和恰好 == s，直接输出，否则，向右缩进 head ，如刚好 == s ，输出结果，否则继续向右移动 tail ，重复以上过程。若最后都没有使和 == s 的结果，输出 $“none ”$。注意0要特判，输出 $“none”$ 。复杂度O(nm)

$ Code $
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc getchar()
int n;
int a[1000000+10];

inline int read() {
	register int r = 0, l = 1;
	register char ch = gc;
	while (!isdigit(ch)) {
		if (ch == '-')l = -1;
		ch = gc;
	}
	while (isdigit(ch)) {
		r = (r << 3) + (r << 1) + ch - '0';
		ch = gc;
	}
	return r * l;
}

inline void solve(){
	register const int sum=read();
	if(sum>2*n){
		puts("none");
		return;
	}
	register int cnt=0,head=1,tail=0;
	for(int i=1;i<=n;++i){
		cnt+=a[i];tail++;
		if(cnt<sum)continue;
		while(cnt>sum)cnt-=a[head],head++;
		if(head>tail)continue;
		if(cnt==sum){
			printf("%d %d\n", head,tail);
			return;
		}
	}
	puts("none");
	return;
}

int main() {
	n=read();
	register const int m=read();
	register char s[5];
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1,x;i<=m;++i){
		scanf("%s",s+1);
		if(s[1]=='C')x=read(),a[x]=read();
		else solve();
	}
	return 0;
}
```
## 50pts
我们考虑优化，先来模拟过程，首先是寻找第一个以 $1$ 为开头序列区间和刚好大于等于 s ，的区间，然后收缩，我们可以用二分优化，然后再考虑，我们最后求出来的一定是一个和为 $s$ 或 $s+1$ 的区间，因为所有项的值只有 1 和2，且最后的 a[tail] 必为 $2$ ，如果是 $1$，那到 a[tail-1] 和恰好为 $s$ ，只能说明二分你写挂了  ~~2333~~  。通过上面 $ 20pts $ 的程序可以发现，最后找到开头是 a[1] 的序列后，移动只需要找到最近的一个值为 1 的点，然后把序列向右平移即可。具体实现先找到距离 a[1] 最近的 1 的位置，设为 pos1，然后找到距离 tail 最近的 1 的位置 ，设为pos2，如果 pos1 - 1 比 pos2 - tail 小，结果应是 1 移动到  pos1 ， tail 同时移动。大的话同理。那如果相等的话怎么处理？( dalao 应该发现这并没有影响，然而我当时没有想出来，卡了很久，~~我太菜了~~)首先想如果是这种情况的话， pos1 必然在序列内部，因为如果 pos1 在外部只能在有，因为最左端 a[1] 已经在序列内，然后那么 pos2 应该就是 pos1 ，又因为 tail >= 1 ，如果 tail == 1，那根本无影响，如果 > 1 ，那又互相矛盾。所以必是在内部，如果在内部，那两个一好想对结果并没有影响，本质上还是把序列里的 2 换成 1 。那么维护区间和带修改和序列里第一个为 1 的位置，当然就是用~~sb~~线段树啊。再写一个二分，复杂度$ O(mlog^2n)$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gc getchar()
#define lson (x<<1)
#define rson (x<<1|1)
#define min(a,b) (a<b?a:b)
#define mid ((tree[x].l+tree[x].r)>>1)
const int maxn=2e6+10;
int n,m;
struct gdx{
	int l,r,data,num;//data是区间和，num是区间内第一个 1 出现的位置
}tree[maxn<<2];
int a[maxn];

inline int read(){
	register int r=0,l=1;register char ch=gc;
	while(!isdigit(ch)){if(ch=='-')l=-1;ch=gc;}
	while(isdigit(ch)){r=(r<<3)+(r<<1)+ch-'0';ch=gc;}
	return r*l;
}

inline int check(register const int x,register const int y){//返回值为0则表示区间内没有 1 ，所以要写check函数
	if(!x)return y;
	if(!y)return x;
	return min(x,y);
}

inline void push_up(register const int x){
	tree[x].data=tree[lson].data+tree[rson].data;
	if(tree[lson].num)return tree[x].num=tree[lson].num,void();
	if(tree[rson].num)return tree[x].num=tree[rson].num,void();
	return tree[x].num=0,void();
}

void build(register const int x,register const int l,register const int r){
	tree[x].l=l;tree[x].r=r;
	if(l==r){
		tree[x].data=a[l];
		tree[x].data==1?tree[x].num=l:tree[x].num=0;
		return;
	}
	build(lson,l,mid);
	build(rson,mid+1,r);
	push_up(x);
}

void Modify(register const int x,register const int l,register const int z){
	if(tree[x].l==tree[x].r&&tree[x].l==l){
		tree[x].data=z;a[l]=z;
		z==1?tree[x].num=l:tree[x].num=0;
		return;
	}
	l<=mid?Modify(lson,l,z):Modify(rson,l,z);
	push_up(x);
}

int query(register const int x,register const int l,register const int r){
	if(l<=tree[x].l&&r>=tree[x].r)return tree[x].data;
	register int ans=0;
	if(l<=mid)ans+=query(lson,l,r);
	if(r>mid)ans+=query(rson,l,r);
	return ans;
}

int Query(register const int x,register const int l,register const int r){
	if(l<=tree[x].l&&r>=tree[x].r)return tree[x].num;
	register int ans=0;
	if(l<=mid)ans=Query(lson,l,r);
	if(r>mid)ans=check(ans,Query(rson,l,r));
	return ans;
}

inline int lowerbound(register int l,register int len,register const int x,register int half=0){//别问这个二分这么奇怪，这是我抄的STL的lower_bound函数，自己总是写挂，只能去抄STL源码加自己的修改，毕竟源码都是迭代器
	while(len>0){
		half=len>>1;
		if(query(1,1,l+half)<x)l+=half+1,len=len-half-1;
		else len=half;
	}
	return l;
}

inline void solve(register const int s){
	if(!s)return puts("none"),void();//0特判
	register int op=query(1,1,n);//nt了，懒得改了，直接用tree[1].data就行了
	if(op<s)return puts("none"),void();
	if(op==s)return printf("1 %d\n",n),void();
	register int p=lowerbound(1,n-1,s);
	if(query(1,1,p)==s)return printf("1 %d\n",p),void();
	if(a[1]==1)return printf("2 %d\n",p),void();
	register const int ll=Query(1,1,n),rr=Query(1,p,n);
	if(!ll&&!rr)return puts("none"),void();
	if(ll&&rr){
		if(ll-1<rr-p){
			if(ll-1+p>n)return puts("none"),void();
			printf("%d %d\n",ll+1,ll-1+p);
			return;
		}else{
			if(rr>n)return puts("none"),void();
			printf("%d %d\n",rr-p+1,rr);
			return;
		}
	}else if(ll&&!rr){
		if(ll-1+p>n)return puts("none"),void();
		printf("%d %d\n",ll+1,ll-1+p);
		return;
	}else{
		if(rr>n)return puts("none"),void();
		printf("%d %d\n",rr-p+1,rr);
		return;
	}
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i)a[i]=read();
	build(1,1,n);
	register char s[10];
	for(register int i=1,x;i<=m;++i){
		scanf("%s",s+1);
		if(s[1]=='A')solve(read());
		else x=read(),Modify(1,x,read());
	}
	return 0;
}
```
## 100pts
大佬们都看出来了，我这些的是多么nt,为什么不直接在线段树里二分，反而在外面写~~sb~~二分？复杂度O(mlogn)

码风毒瘤，勿喷，emm
```cpp
#include <cstdio>
#include <cctype>
#include <iostream>
#include <algorithm>
using namespace std;
#define gc getchar()
#define lson (x<<1)
#define rson (x<<1|1)
const int maxn=2e6+10;
int n,m;
struct gdx{
	int l,r;
	int data,num;
}tree[maxn<<2];
int a[maxn];

inline int read(){
	int r=0,l=1;char ch=gc;
	while(!isdigit(ch)){if(ch=='-')l=-1;ch=gc;}
	while(isdigit(ch)){r=(r<<3)+(r<<1)+ch-'0';ch=gc;}
	return r*l;
}

inline int check(const register int x,const register int y){
	if(!x)return y;
	if(!y)return x;
	return min(x,y);
}

inline void push_up(const register int x){
	tree[x].data=tree[lson].data+tree[rson].data;
	if(tree[lson].num)return tree[x].num=tree[lson].num,void();
	if(tree[rson].num)return tree[x].num=tree[rson].num,void();
	return tree[x].num=0,void();
}

inline void build(const register int x,const register int l,const register int r){
	tree[x].l=l;tree[x].r=r;
	if(l==r){
		tree[x].data=a[l];
		if(tree[x].data==1)tree[x].num=l;
		return;
	}
	const int mid=((tree[x].r+tree[x].l)>>1);
	build(lson,l,mid);
	build(rson,mid+1,r);
	push_up(x);
}

inline void Modify(const register int x,const register int l,const register int z){
	if(tree[x].l==tree[x].r&&tree[x].l==l){
		tree[x].data=z;a[l]=z;
		if(z==1)tree[x].num=l;
		else tree[x].num=0;
		return;
	}
	const int mid=((tree[x].r+tree[x].l)>>1);
	if(l<=mid)Modify(lson,l,z);
	else Modify(rson,l,z);
	push_up(x);
}

inline int query(const register int x,const register int l,register const int r){
	if(l<=tree[x].l&&r>=tree[x].r)return tree[x].data;
	register int ans=0;
	const int mid=((tree[x].r+tree[x].l)>>1);
	if(l<=mid)ans+=query(lson,l,r);
	if(r>mid)ans+=query(rson,l,r);
	return ans;
}

inline int Query(const register int x,const register int l,const register int r){
	if(l<=tree[x].l&&r>=tree[x].r)return tree[x].num;
	register int ans=0;
	const int mid=((tree[x].r+tree[x].l)>>1);
	if(l<=mid)ans=check(ans,Query(lson,l,r));
	if(r>mid)ans=check(ans,Query(rson,l,r));
	return ans;
}

int Find(register const int x)
	if(tree[x].l==tree[x].r)return tree[x].l;
	return Find(rson);
}

int lowerbound(register const int x,register const int z,register const int sch){//线段树上二分
	if(tree[x].l==tree[x].r)return tree[x].l;
	if(z+tree[lson].data>sch)return lowerbound(lson,z,sch);
	if(z+tree[lson].data==sch)return Find(lson);//相等后直接返回左儿子右端点，我nt了，可以直接reutrn tree[lson].r
	else return lowerbound(rson,z+tree[lson].data,sch);
}

inline void solve(const register int s){
	if(!s)return puts("none"),void();
	if(tree[1].data<s)return puts("none"),void();
	if(tree[1].data==s)return printf("1 %d\n",n),void();
	const register int p=lowerbound(1,0,s);
	if(query(1,1,p)==s)return printf("1 %d\n",p),void();
	if(a[1]==1)return printf("2 %d\n",p),void();
	const register int ll=Query(1,1,n),rr=Query(1,p,n);
	if(!ll&&!rr)return puts("none"),void();
	if(ll&&rr){
		if(ll-1<rr-p){
			if(ll-1+p>n)return puts("none"),void();
			printf("%d %d\n",ll+1,ll-1+p);
			return;
		}else{
			if(rr>n)return puts("none"),void();
			printf("%d %d\n",rr-p+1,rr);
			return;
		}
	}else if(ll&&!rr){
		if(ll-1+p>n)return puts("none"),void();
		printf("%d %d\n",ll+1,ll-1+p);
		return;
	}else{
		if(rr>n)return puts("none"),void();
		printf("%d %d\n",rr-p+1,rr);
		return;
	}
}

int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i)a[i]=read();
	build(1,1,n);
	register char s[10];
	for(register int i=1,x;i<=m;++i){
		scanf("%s",s+1);
		if(s[1]=='A')solve(read());
		else x=read(),Modify(1,x,read());
	}
	return 0;
}
```

PS ： 月赛考了这道题，当时心态就被考炸了， $ 20 pts $ 暴力都打挂了，我太菜了


---

## 作者：NuoCarter (赞：1)

## P6859 蝴蝶与花 题解

### 题目大意：

给定一个长度为 $n$ 的序列 $a_i$ ,$a_i\in \{ 1,2 \}$ ，每次操作给出两种类型的操作：

* 修改格式：$C \ i \ val$ 将 $a_i$ 改为 $val\in \{1,2\}$
* 查询格式：$A \ K$ ，查询整个序列有无一个子串和为 $K$，输出所有方案中 $L$ 最小的。

### 分析：

首先，设要求查询的和为 $K$ ，首先当 $K>sum$ 或 $K=0$ 时是肯定无解的。（此时 $sum$ 指整个序列的和）

因为要求左端点最小：

很容易想到从 $1$ 开始，我们先找到以 $1$ 为左端点，子串和 $\geq K$ 的最小的右端点记作 $R$。

这一点可以通过一个线段树上二分在 $\Theta(\log n )$ 的时间解决，修改也就是一个简单的单点修改。

此时查询到的子串和一定为 $K$ 或 $K+1$ ,这点可以通过反证法证明。

若子段和为 $K$ 则证明已经找到了答案，着重解决的肯定是子段和为 $K+1$ 的部分。

为了保证左端点最小，并且保持着当前的子串和为 $K+1$ 不变，选择两个端点同时向右移动。

在两个端点向右移动的过程中，如果有一个端点的值为 $1$ ，则找到了答案。

因为它们都从原本的 $2$ 走到了 $1$ 。（右端点的值一定为 $2$）

而左端点可以近似的看作从 $2$ 走到了 $1$。

所以答案就是离左端点最近的 $1$ ，或者右端点更近的 $1$。

用一个 `set` 维护即可。

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
    x=0;char ch=getchar();bool f=false;
    while(!isdigit(ch)) f|=ch=='-',ch=getchar();
    while(isdigit(ch))  x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=f?-x:x;return;
}
template <typename T>
inline void print(T x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10^48);return;
}
const int N=2e6+3,INF=1e9;
int n,m,a[N],nxt[N],pre[N];
struct node{
    int sum,lazy;
    #define sum(x)  c[x].sum
    #define lazy(x) c[x].lazy
}c[N<<2];
#define lc x<<1
#define rc x<<1|1
inline void Push_up(int x){sum(x)=sum(lc)+sum(rc);return;}
inline void Build(int x,int l,int r){
    if(l==r){sum(x)=a[l];return;}
    int mid=(l+r)>>1;Build(lc,l,mid),Build(rc,mid+1,r);
    Push_up(x);return;
}
inline void Modify(int x,int l,int r,int to,int d){
    if(l==r){sum(x)=d;return;}
    int mid=(l+r)>>1;if(mid>=to) Modify(lc,l,mid,to,d);
    else Modify(rc,mid+1,r,to,d);
    Push_up(x);return;
}
int res=0;
inline int Query(int x,int l,int r,int k){
    if(l==r){res+=a[l];return l;}
    int mid=(l+r)>>1;
    if(sum(lc)>=k)  return Query(lc,l,mid,k);
    else{res+=sum(lc);return Query(rc,mid+1,r,k-sum(lc));}
}
set<int> loc;
int main(){
    read(n),read(m);
    for(register int i=1;i<=n;++i){read(a[i]);if(a[i]==1) loc.insert(i);}
    Build(1,1,n);
    while(m--){
        char op[2];scanf("%s",op);
        if(op[0]=='A'){
            int x;read(x);
            if(x>sum(1)||x==0){puts("none");continue;}
            res=0;int R=Query(1,1,n,x);
            if(res==x){print(1),putchar(' '),print(R),putchar('\n');continue;}
            int loc1=INF,loc2=INF;
            if(!loc.empty())    loc1=*loc.begin();
            set<int>::iterator it=loc.lower_bound(R);
            if(it!=loc.end())   loc2=*it;
            int len=loc2-R+1;
            if(loc2==INF&&R+loc1-1>n){puts("none");continue;}
            if(loc1>=len) print(len),putchar(' '),print(loc2),putchar('\n');
            else print(loc1+1),putchar(' '),print(R+loc1-1),putchar('\n');
        }
        else{
            int i,val;read(i),read(val);
            if(a[i]==1) loc.erase(i);
            if(val==1)  loc.insert(i);
            a[i]=val;Modify(1,1,n,i,val);
        }
    }

    return 0;
}

```

---


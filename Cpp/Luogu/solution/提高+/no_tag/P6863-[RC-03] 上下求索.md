# [RC-03] 上下求索

## 题目描述

有一个关于 $x_i(i∈\{1,2,3,...,n\},x_i∈\mathbb{R})$ 的 $n$ 元二次方程：

$$\sum_{i=1}^na_ix_i^2+\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m$$

请您在这个方程中，求出保证方程有解的 $x_1$ 的取值范围。

保证 $x_1$ 有上下界。

## 说明/提示

【样例 $1$ 说明】

原方程为 $2x_1^2+2x_1x_2+2x_2^2+2x_2x_3+2x_3^2+2x_3x_4+2x_4^2+2x_4x_5+x_5^2=16$。

当 $x_1=-4$ 有 $x_1=-4$；$x_2=4$；$x_3=-4$；$x_4=4$；$x_5=-4$。  
当 $x_1=4$ 有 $x_1=4$；$x_2=-4$；$x_3=4$；$x_4=-4$；$x_5=4$。  
当 $x_1>4$ 或 $x_1<-4$ 时原方程左必 $>16$。  
$∴ -4\leq x_1\leq 4$。

---
  
【数据范围】

对于 $4\%$ 的数据，$n=1$。

对于 $16\%$ 的数据，$n\le 2$。 

对于另外 $16\%$ 的数据，$n\le 8$，$m\le 30$。 

对于 $60\%$ 的数据，$n\le 10^3$。 

对于 $100\%$ 的数据，$1\le a_i,b_i,m\leq 10^9$，$1\le n\leq 5\times 10^5$。  

## 样例 #1

### 输入

```
5 16
2 2 2 2 1
2 2 2 2```

### 输出

```
-4 4```

# 题解

## 作者：一只书虫仔 (赞：5)

#### Description

> 给定一个 $n$ 元二次方程：
> $$\sum\limits_{i=1}^na_ix_i^2+\sum\limits_{i=1}^{n-1}b_ix_ix_{i+1}=m$$
> 求 $x_1$ 的范围。

#### Solution

左侧有 $x_i^2$，右侧又有 $x_ix_{i+1}$，故考虑配方，因为右边的求和式子范围是 $[1,n-1]$，所以先从 $x_{n-1},x_n$ 配起：

$$\begin{aligned}a_{n-1}x_{n-1}^2+b_{n-1}x_{n-1}x_n+a_nx_n^2&=\left(a_{n-1}-\frac{b_{n-1}^2}{4a_n}\right)x_{n-1}^2+\frac{b_{n-1}^2}{4a_n}x_{n-1}^2+b_{n-1}x_{n-1}x_n+a_nx_n^2\\&=\left(a_{n-1}-\frac{b_{n-1}^2}{4a_n}\right)x_{n-1}^2+\left(\frac{b_{n-1}}{2\sqrt{a_n}}+\sqrt{a_n}x_n\right)^2\end{aligned}$$

（Q：为什么调整 $x_{n-1}$ 不调整 $x_n$？A：为了方便求 $x_1$ 的范围而不是 $x_n$ 的范围）

经过配方后，$x_{n-1}^2$ 的系数就从 $a_{n-1}$ 变为了 $a_{n-1}-\frac{b_{n-1}^2}{4a_n}$，那么我们就可以以这个为新的系数，与 $x_{n-2}$ 继续配方，然后以此类推推到 $x_1$，这个过程可以 $\mathcal O(n-1)$ 的倒着循环，最后可以得到 $x_1$ 的系数，设其为 $\alpha$。

$x_1$ 的上下界取于极端情况，即后面 $[x_2,x_n]$ 的加和均为 $0$ 时，即：

$$\begin{aligned}\alpha x_1^2+0&=m\\\alpha x_1^2&=m\\x_1^2&=\frac m \alpha \\x_1&=\pm\sqrt{\frac m \alpha}\end{aligned}$$

$x_1$ 的范围即为：

$$x_1 \in \left[-\sqrt{\frac m \alpha},\sqrt{\frac m \alpha}\right]$$

注意：因为精度问题还是开一下 double 保险，因为这个问题 WA 了好几次。

#### Code

```cpp
for (int i = n - 1; i >= 1; i--) {
	double del = (b[i] * b[i]) / (4 * a[i + 1]);
	a[i] -= del;
}
double ans = sqrt(m / a[1]);
if (ans >= 0) printf("%.0f %.0f", -ans, ans);
else printf("%.0f %.0f", ans, -ans);
```

---

## 作者：AsunderSquall (赞：3)

update：远古题解一大堆格式错误，试图一个个修复。

水题，不知道为什么评蓝了。  
那我来拓展一下问题吧。（而且为什么没有题解）  

## 题意的分析

首先解释一下题意“保证 $ x_1 $ 有上下界”。

比如对于这样的式子 $ x_1^2+2x_1x_2+x_2^2=0 $ 的情况。  
谁都知道这个东西 $ x_1 $ 可以取 $ (-\infty,+\infty) $ ，只要令 $ x_2=-x_1 $ 即可。  
所以它不可能存在于数据中。  

再说明一下，存在 $ \{a_i \},\{ b_i \} $ 可以使方程无解。  
比如 $ x_1^2+2x_1x_2+x_2^2=-1 $。   
所以它也不可能存在于数据中。

但是我们仅仅会做这道题是不够的，所以在这篇题解中，我会提一下怎么判断 $ x_1 $ 是否有上下界，以及是否无解。  
然后下一步分析，如果将 $ x_1,x_2,x_3 \cdots x_n $ 全部取相反数，最终得出的式子答案不变。  
因此我们可以得出下界和上界是互为相反数的。  

## 题解

我们可以考虑怎样让式子只剩下 $ x_1 $ 。  
考虑配方，从后往前把 $ a_n\to a_2 $ 扫一遍进行配方。  
然后式子会化为  
 $ e_1x_1^2+\sum_{i=1}^{n-1} e_{i+1}(c_ix_i+d_ix_{i+1})^2=m $   
其中 $ e_i=\pm 1 $。     
我们把它简化为 $ \sum_{i=1}^n e_if_i^2 $。    
其中 $ f_1=x_1,f_i=c_ix_i+d_ix_{i+1}(i>1) $。   
显然 $ f_i $ 可以任取实数。

### subtask 1
如果 $ e_i $ 全部同号或为 $ 0 $。   
为了方便，我们设 $ e_i\ge0 $ （如果 $ e_i<0 $  就将整个式子乘 $ -1 $ ）。  
那么显然左式 $ \ge 0 $。   
-  $ e_1=0 $ 且 $ m < 0 $  无解。  
-  $ e_1=0 $ 且 $ m \ge 0 $  无上下界。  
-  $ e_1>0 $ 且 $ m<0 $  无解。   
-  $ e_1>0 $ 且 $ m=0 $  无上下界。  
-  $ e_1>0 $ 且 $ m>0 $  上界为 $ \sqrt{\dfrac{m}{e_i}} $ ，下界为 $ -\sqrt{\dfrac{m}{e_i}} $。 

### subtask 2
存在 $ i,j $ 使 $ e_i\cdot e_j<0 $。   
那么对于 $ e_if_i+e_jf_j $ 可以取遍所有实数，也就是说 $ x_1 $ 无上下界了。

## 实现配方

从后往前扫，考虑到对于第 $ i $ 位，要和第 $ i-1 $ 位进行配方。  
那么  
 $ a_ix_i^2+b_ix_ix_{i-1}+a_{i-1}x_{i-1}^2=(\sqrt{a_i}x_i+\dfrac{b_ix_{i-1}}{2\sqrt{a_i}})^2+(a_{i-1}-\dfrac{b_i^2}{4a_i})x_{i-1} $   
然后将 $ a_{i-1} $ 重新赋值。  
这看着很烦，其实就是初一数学就学的配方法。  

对了，注意用 `double` 存系数。

P.S.: 由于考试的时候赶时间，代码中只实现了题目要求，并不能搞定我上述说的拓展问题，但是我已经讲得够详细了吧。  

完结撒花！  

代码
```cpp
#include<bits/stdc++.h>
#define int  long long
#define rd(x) x=read()
using namespace std;
const int N=5e5+5;
const int mod=1e9+9;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
double a[N];
double b[N];
bool vis[N];
double m;
double ans;
int n;
signed main()
{
    rd(n);scanf("%lf",&m);
    for (int i=1;i<=n;i++) scanf("%lf",&a[i]);
    for (int i=1;i<n;i++) scanf("%lf",&b[i]);
    for (int i=n;i>=2;i--) a[i-1]-=b[i-1]*b[i-1]/a[i]/4;
    //剩下为a[i]*x_1^2=m
    ans=sqrt(m/a[1]);
    if (ans<0) ans=-ans;
    cout<<-round(ans)<<' ';
    cout<<round(ans)<<endl;
}
```

---

## 作者：BDFZ_hym_AK_hym_ing (赞：2)

### 题目解读：
给你一个 $n$ 元 $2$ 次方程形如：
$$
\sum_{i=1}^{n}a_ix_i^2+\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m
$$
其中 $a,b,m$ 为给定的值。
### 做法分析：
既然是 $2$ 次方程，有含有平方项和相邻的积，很容易想出配方，只需要最后剩一个含 $x_1^2$ 的项即可。  
因为题目满足 $x_1$ 有上下界，所以可以不用讨论中间是否会出现系数为负或为 $0$ 导致无法配方。  
接下来从右到左依次配方，先以第一次举例，后面同理：
$$
a_{n-1}x_{n-1}^2+b_{n-1}x_{n-1}x_n+a_nx_n^2
$$
因为我们要让最后只剩 $a_1$，所以优先消掉 $a_n$。  
设 $c_{n-1}x_{n-1}^2+b_{n-1}x_{n-1}x_n+a_nx_n^2$ 为完全平方式，则有：
$$
\begin{aligned}
b_{n-1}=2\sqrt{c_{n-1}a_n}\\
b_{n-1}^2=4c_{n-1}a_n\\
c_{n-1}=\frac{b_{n-1}^2}{4a_n}\\
\end{aligned}
$$
所以以后每次将 $a_{i-1}$ 减掉 $c_{i-1}$ 即可。  
剩下的式子为 $a_1x_1^2$，因为它加上非负数后等于 $m$，所以有 $a_1x_1^2\le m$，同理，因为题目满足 $x_1$ 有上下界，所以 $m\div a_1$ 肯定不为负，解得 $-\sqrt{\frac{m}{a_1}}\le x_1 \le\sqrt{\frac{m}{a_1}}$，因为保证输出一定为整数，所以别忘了**取整数**（因为前面需要用浮点数存储）。 
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
double a[500005];
double b[500005]; 
int main(){

	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	cin>>n>>m;
	long long i;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(i=1;i<=n-1;i++)
	{
		cin>>b[i];
	}
	for(i=n-1;i>=1;i--)
	{
		a[i]-=(b[i]*b[i]/4.0/a[i+1]);
	}
	cout<<(long long)-sqrt(m/a[1])<<" "<<(long long)sqrt(m/a[1]);

	return 0;
}

```

---

## 作者：Fatalis_Lights (赞：1)

**题目传送门：** [Link](https://www.luogu.com.cn/problem/P6863)

**题意简述：**

> 求满足方程：

> $$\sum_{i=1}^na_ix_i^2+\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m$$

> 的 $x_1$ 的最大值和最小值（ $n\leq 5*10^5$ ）。

## Solution

大概是个初中入门题，**完全不明白**为什么是蓝题。

考虑利用两元的完全平方公式给左边配个方，即将每个小式子：

$$a_ix_i^2+b_ix_ix_{i+1}+a_{i+1}x_{i+1}^2$$

配成：

$$(a_i-\frac{b_i^2}{4a_{i+1}})x_i^2+(\frac{b_i^2}{4a_{i+1}}x_i^2+b_ix_ix_{i+1}+a_{i+1}x_{i+1}^2)$$

即：

$$(a_i-\frac{b_i^2}{4a_{i+1}})x_i^2+(\frac{b_i}{2\sqrt{a_{i+1}}}x_i+\sqrt{a_{i+1}}x_{i+1})^2$$

配至第一项，可得左式是 $n$ 个式子的平方和（第一项只有一个平方项），右式仍为 $m$ 。

假设配成了下式：

$$A_0x_1^2+\sum_{i=1}^{n-1}(u_ix_i+v_ix_{i+1})^2=m$$

可见有 $x_1$ 的范围：

$$x_1\in[-\sqrt\frac{m}{A_0},\sqrt\frac{m}{A_0}]$$

然后就结束了。

code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 500005
using namespace std;

int n,m;
int a[N],b[N];

inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

signed main(){
    n=read(); m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<n;i++) b[i]=read();
    for(int i=n-1;i>=1;i--) a[i]-=(b[i]*b[i]/4/a[i+1]);
    print(-sqrt(m/a[1])); putchar(32);
    print(sqrt(m/a[1])); 
}
```


---

## 作者：bssmessi (赞：0)

因为我们要留下关于 $x_{1}$ 的式子，所以我们从 $x_{n}$ 开始配方，因为我们有：

$(\sqrt{\frac{b_{n-1}^{2}  }{4a_{n}  } }x_{n-1} +\sqrt{a_{n} }x_{n} )^{2} = \frac{b_{n-1}^{2}  }{4a_{n}  }x^{2}_{n-1}+b_{n-1}x_{n-1}x_{n}+a_{n}x^{2}_{n}$

所以我们只需要不断的向前减 $\frac{b_{k-1}^{2}  }{4a_{k} }$ 这一项就可以了，而题目保证有上下界，所以可以大胆配方不用怕配成负数了。

因为最后是 $a_{1}'$ 加一串大于等于零的数等于 $m$ ，所以我们有：$-\sqrt{\frac{m}{a_{1}'} } \le x_{1}\le \sqrt{\frac{m}{a_{1}'} }$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
int n,m,a[N],b[N];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++) cin>>b[i];
	double last=a[n];
	for(int i=n-1;i>=1;i--){
		last=a[i]-b[i]*b[i]*0.25/last;
	}
	cout<<-1*sqrt(m/last)<<" "<<sqrt(m/last);
	return 0;
}
```

---

## 作者：yzy4090 (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P6863)  

关注这个式子，可以发现它由 $n$ 个带权的 $x_i^2$ 和 $n-1$ 个带权的 $x_ix_{i+1}$ 组成。这提醒着我们不应该直接把它看作一个一般的含参一元二次方程直接求解，而应该利用完全平方和公式将它转化。  
我们为了计算 $x_1$ 的取值，要从 $x_{n-1}$ 和 $x_n$ 开始反向配方，结果是：  
$$a_ix_i^2+b_ix_ix_{i+1}+a_{i+1}x_{i+1}^2=\left(a_i-\frac{b_i^2}{4a_{i+1}}\right)x_i^2+\left(\frac{b_i}{2\sqrt{a_{i+1}}}x_i+\sqrt{a_{i+1}}x_{i+1}\right)^2$$  
用 $x_i^2$ 前的那个式子去替换 $a_i$，然后继续处理 $x_{i-1}$ 和 $x_i$，以此类推。  
到最后，有式子 $a_1'x_1^2+c=m$，其中 $c\ge0$。所以 $x_1$ 的范围为 $\left[-\sqrt\frac{m}{a_1'},\sqrt\frac{m}{a_1'}\right]$。  

代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+5;
int n;
ll m,a[N],b[N];
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++)cin>>b[i];
	for(int i=n-1;i>=1;i--)a[i]-=b[i]*b[i]/4/a[i+1];
	cout<<-sqrt(m/a[1])<<" "<<sqrt(m/a[1])<<"\n";
	return 0;
}
```

---


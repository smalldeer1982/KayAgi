# [COCI 2013/2014 #6] KRUŽNICE

## 题目描述

现在有 $N$ 个以 $x$ 轴为中心的互不相交的圆，但圆周可以接触。请问这些圆把平面分成多少块？

## 说明/提示

#### 【样例解释】
#### 样例 3 解释
该样例对应下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/38z2b5fh.png)

#### 【数据规模与约定】
- 对于 $40\%$ 的数据，$1 \le N \le 5\times 10^3$。
- 对于 $100\%$ 的数据，$1 \le N \le 3\times 10^5,-10^9 \leq x_i \leq 10^9$，$1 \leq r_i \leq 10^9$。
#### 【说明】
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T4 KRUŽNICE。_**

## 样例 #1

### 输入

```
2
1 3
5 1 ```

### 输出

```
3```

## 样例 #2

### 输入

```
3
2 2
1 1
3 1 ```

### 输出

```
5```

## 样例 #3

### 输入

```
4
7 5
-9 11
11 9
0 20 ```

### 输出

```
6```

# 题解

## 作者：hank0402 (赞：8)

## 题目大意

有 $n$ 个互不相交的圆（可以相切），第 $i$ 个圆圆心为 $(x_i,0)$，半径为 $r$，求这些圆平面分成了几个部分。

## 题解

据我所知，本题共有 $3$ 个做法。

### Sol1. 单调栈

首先，我们观察到每加入一个圆，至少多分了 $1$ 个部分，但也有时候分成了两个部分，即大圆被若干个小圆分成上下两部分。

那么我们考虑如何统计这种特殊情况。

首先，我们按每个圆的右端点从小到大排序，然后，我们按顺序加入单调栈中。

那么如果一个大圆里面的小圆没有再包含一个圆，我们就可以直接记录这个大圆包含的小圆的直径和，与大圆的直径比较就可以判断是否为特殊情况。

那么我们考虑维护一个没有包含关系的栈。

因为我们把右端点从小到大排了序，所以在加入一个圆的时候，我们只要看左端点，如果刚加的这个圆的左端点小于等于栈顶的左端点，那么栈顶的圆就被包含了，我们把它弹出，顺便记录弹出圆的直径和。

于是我们这个左端点递增的单调栈，既可以保证没有二次包含关系，也可以实时统计大圆包含的小圆的直径和，直接判断即可。

时间复杂度为 $\Theta(n\log n)$，瓶颈在排序上。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define PII pair<int, int>
#define mkp make_pair
#define INF INT_MAX
template <typename T> inline void rd(T &x){
	x = 0; bool f = true; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = false; ch = getchar();}
	while(ch >= '0' && ch <= '9'){ x = (x << 1) + (x << 3) + (ch ^ '0'); ch = getchar();}
	if(!f) x = -x;
}
template <typename T, typename ...Args> inline void rd(T &x, Args &...args){ rd(x); rd(args...);}
const int N = 3e5 + 10;
struct circle {
    int x, r;
}c[N];
bool cmp(circle A, circle B) {
    if(A.x + A.r != B.x + B.r) return A.x + A.r < B.x + B.r;
    else return A.x - A.r > B.x - B.r;
}
int n, st[N], top, ans;
int main() {
    // freopen(".in", "r", stdin);
    // freopen(".out", "w", stdout);
    rd(n);
    for(int i = 1; i <= n; ++i) rd(c[i].x, c[i].r);
    sort(c + 1, c + n + 1, cmp);
    for(int i = 1; i <= n; ++i) {
        int now = c[i].x - c[i].r, sum = 0;
        while(c[st[top]].x - c[st[top]].r >= now && top >= 1) {
            sum += 2 * c[st[top]].r;
            top --;
        }
        st[++top] = i;
        if(sum == 2 * c[i].r) ans ++;
    }
    cout << ans + n + 1 << endl;
    return 0;
}
```

### Sol2.并查集

首先回到统计大圆被小圆分割成上下两个部分的情况数。

我们如果在按半径加入圆的时候，把它的左右端点连一条边，那么在加入大圆的时候，如果大圆的左右端点已经连通了，那么这个大圆一定被小圆分割成上下两部分了。

因为坐标很大，并且可能是负数，所以离散化后并查集即可。

复杂度为 $\Theta(n \log n)$。

### Sol3.线段树

继续回到统计大圆被小圆分割成上下两个部分的情况数。

按半径加入圆的时候，我们在这个圆的两个端点进行一次区间 `+1`，那么如果大圆左右端点的区间的区间最小值为 `0`，那说明没有被完全分开，否则被完全分开。

这里依然要离散化。

复杂度为 $\Theta(n \log n)$。

注意，Sol2 和 Sol3 中的做法需要注意，线段树和并查集只能维护整点的信息，所以我们将左端点 +1，或者右端点 -1，来保证不会有形如 $(i,0)$ 在一个圆，$(i+1,0)$ 在另一个圆，就算中间有空隙，也不会被计算到的情况。

线段树代码：[Paste](https://www.luogu.com.cn/paste/tibvk4v6)。


---

## 作者：XuYueming (赞：3)

[COCI的题。](https://www.luogu.com.cn/problem/P6875)

显然，手模样例发现答案分为以下几个贡献：
1. 所有圆外面的那个大平面，贡献为 $1$。
1. 每个圆至少被分成一部分，贡献为 $n$。
1. 如果有一个圆被“拦腰截断了”，即整条直径上都被更小的圆填满了，就额外对答案贡献加 $1$，这也是我们所求部分。

## 暴力跳 `set`
遇事不决，先打暴力；不加优化，不如跳题。一个很显然的想法，如果在处理第 $i$ 个圆的时候，之前所有比它更小的圆都更新到平面上，那我们只需要看看是不是这个圆的直径被完整覆盖就行了。最暴力的想法就是从左端点开始，一步一步向右边走，看看有没有出现空隙。直接扫是 $\Theta(n)$ 的，可以用一个 `set` 来维护当前已经加入的圆，扫描的时候用 `lower_bound` 来加速。具体细节不用多说，就是模拟。但是有个细节，如果存在一个圆把另一个圆包含了，那么后者可以直接从 `set` 里删除，因为其不会对之后的答案产生贡献了。

时间复杂度：$\Theta(n \log n)$，每个点进出 `set` 一次。

## 线段树
其实 ~~如果你数据结构学傻了~~ 可以用维护区间被覆盖的最小次数，当查询时，看看这个最小次数 $cnt$ 如果 $cnt \geq 1$ 说明被完整覆盖了。区间加，区间查询最小值，当然使用 ~~分块~~ 线段树。另外地，也可以直接用一个 `bool` 类型的变量来表示这一个区间是不是被完整覆盖了。当然两者都需要先把所有坐标离散化掉。

时间复杂度：$\Theta(n \log n)$，但逝常数较大 ~~（比分块强）~~，那有没有更优雅一点的做法呢？

## 并查集
区间上的问题有时可以想象左端点向右端点连边，那我们在插入一个圆的时候，把左端点连向右端点，查询的时候看看当前的左端点是不是已经和右端点连在一起了。因为如果有空隙，两个端点是不会处在同一个连通块里的。

时间复杂度：$\Theta(n \log n)$，瓶颈在于排序，人家并查集 $\Theta(n \alpha(n))$ 已经够优秀了，但是能不能把这个并查集的小常数优化掉呢？

## 单调栈
发现对于某一个圆，如果它被插入进来了，那我们就可以把里面的圆都删了，对答案不会产生影响（是不是就是上面并查集的路径压缩？其实上面可以直接暴力跳 `set` 的原因就是越过了已经被包含的圆，每个圆最多只被访问一次），发现还和什么很像？单调栈！求矩形面积那题思想是把所有不可能成为解的状态删除，同样在这一题我们也可以及时删除已经被包含进来的圆。具体地，如果先把所有圆按照右端点排序（按照左端点也可以），然后维护一个从栈顶到栈底左端点单调递减的单调栈，那我们能不能在弹栈的时候处理些什么呢？当然可以左右端点一个一个判断过来，但是有没有更优雅的解法呢？发现由于题目性质和单调栈性质，没有圆存在相交或者包含关系，我们只需要统计弹出的圆的直径的和是否等于当前圆的直径就可以了。

时间复杂度：$\Theta(n \log n)$，瓶颈在于排序，单调栈是 $\Theta(n)$ 的。

## 后记
这样，这道题目就被我们解决了。我们一步步优化算法，抽丝剥茧，找到问题的本质。但是实现上的细节，注意此题的离散化，要在点的两边建空点，要不然判断是否填满会出问题。

## 代码 （略去快读快写）

### 暴力跳 `set` 114ms
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>
#include <set>

int n;
struct Circle{
	int l, r;
	bool operator < (const Circle & o) const {
		if (r == o.r) return l > o.l;
		return r < o.r;
	}
} cir[300010];

set<pair<int, int> > S;
typedef set<pair<int, int> >::iterator Iter;

bool query(int l, int r){
	Iter it = S.lower_bound({l, -0x3f3f3f3f});
	int now = l;
	while (it != S.end()){
		if (it -> first != now || it -> first > r) return false;
		if (it -> second == r) return true;
		Iter tmp = it; ++tmp;
		now = it -> second, S.erase(it);
		it = tmp;
	}
	return false;
}

void insert(int l, int r){
	Iter it = S.lower_bound({l, 0});
	while (it != S.end()){
		if (it -> first > r) break;
		Iter tmp = it; ++tmp;
		S.erase(it);
		it = tmp;
	}
	S.insert({l, r});
}

signed main(){
	read(n);
	for (int i = 1; i <= n; ++i) {
		int x, r; read(x, r);
		cir[i] = {x - r, x + r};
	}
	sort(cir + 1, cir + n + 1);
	
	int ans = n + 1;
	for (int i = 1; i <= n; ++i){
		if (query(cir[i].l, cir[i].r)) ++ans;
		insert(cir[i].l, cir[i].r);
	}
	
	write(ans);
	return 0;
}
```

### 线段树（区间最小值） 275ms
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>

int n;

struct Segment{
	int l, r;
	bool operator < (const Segment & o) const {
		return r - l < o.r - o.l;
	}
} seg[300010];
int real[300010 << 1], tot;

struct Segment_Tree{
	#define lson (idx << 1    )
	#define rson (idx << 1 | 1)
	
	struct node{
		int l, r;
		int lazy;
		int minn;
	} tree[300010 << 3];
	
	void build(int idx, int l, int r){
		tree[idx] = {l, r, 0, 0};
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(lson, l, mid), build(rson, mid + 1, r);
	}
	
	void pushtag(int idx, int v){
		tree[idx].lazy += v;
		tree[idx].minn += v;
	}
	
	void pushup(int idx){
		tree[idx].minn = min(tree[lson].minn, tree[rson].minn);
	}
	
	void pushdown(int idx){
		if (tree[idx].lazy == 0) return;
		pushtag(lson, tree[idx].lazy), pushtag(rson, tree[idx].lazy);
		tree[idx].lazy = 0;
	}
	
	void modify(int idx, int l, int r){
		if (tree[idx].r < l || tree[idx].l > r) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag(idx, 1);
		pushdown(idx), modify(lson, l, r), modify(rson, l, r), pushup(idx);
	}
	
	int query(int idx, int l, int r){
		if (tree[idx].r < l || tree[idx].l > r) return 0x3f3f3f3f;
		if (l <= tree[idx].l && tree[idx].r <= r) return tree[idx].minn;
		return pushdown(idx), min(query(lson, l, r), query(rson, l, r));
	}
	
	#undef lson
	#undef rson
} yzh;

signed main(){
	read(n);
	for (int i=1;i<=n;++i){
		int x, r; read(x, r);
		seg[i] = {x - r, x + r};
		real[++tot] = x - r, real[++tot] = x + r;
	}
	sort(real + 1, real + tot + 1), tot = unique(real + 1, real + tot + 1) - real - 1;
	for (int i=1;i<=n;++i){
		seg[i].l = lower_bound(real + 1, real + tot + 1, seg[i].l) - real;
		seg[i].r = lower_bound(real + 1, real + tot + 1, seg[i].r) - real - 1;
	}
	yzh.build(1, 1, tot);
	
	int ans = n + 1;
	sort(seg + 1, seg + n + 1);
	
	for (int i=1;i<=n;++i){
		if (yzh.query(1, seg[i].l, seg[i].r) > 0) ++ans;
		else yzh.modify(1, seg[i].l, seg[i].r);
	}
	
	write(ans);
	return 0;
}
```

### 线段树（区间覆盖） 257ms
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>

int n;

struct Segment{
	int l, r;
	bool operator < (const Segment & o) const {
		return r - l < o.r - o.l;
	}
} seg[300010];
int real[300010 << 1], tot;

struct Segment_Tree{
	#define lson (idx << 1    )
	#define rson (idx << 1 | 1)
	
	struct node{
		int l, r;
		bool f;
	} tree[300010 << 3];
	
	void build(int idx, int l, int r){
		tree[idx] = {l, r, false};
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(lson, l, mid), build(rson, mid + 1, r);
	}
	
	void pushtag(int idx){
		tree[idx].f = true;
	}
	
	void pushup(int idx){
		tree[idx].f = tree[lson].f && tree[rson].f;
	}
	
	void pushdown(int idx){
		if (tree[idx].f == false) return;
		pushtag(lson), pushtag(rson);
	}
	
	void modify(int idx, int l, int r){
		if (tree[idx].r < l || tree[idx].l > r) return;
		if (tree[idx].f) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag(idx);
		pushdown(idx), modify(lson, l, r), modify(rson, l, r), pushup(idx);
	}
	
	bool query(int idx, int l, int r){
		if (tree[idx].r < l || tree[idx].l > r || tree[idx].f) return true;
		if (l <= tree[idx].l && tree[idx].r <= r) return tree[idx].f;
		return pushdown(idx), query(lson, l, r) && query(rson, l, r);
	}
	
	#undef lson
	#undef rson
} yzh;

signed main(){
	read(n);
	for (int i=1;i<=n;++i){
		int x, r; read(x, r);
		seg[i] = {x - r, x + r};
		real[++tot] = x - r, real[++tot] = x + r;
	}
	sort(real + 1, real + tot + 1), tot = unique(real + 1, real + tot + 1) - real - 1;
	for (int i=1;i<=n;++i){
		seg[i].l = lower_bound(real + 1, real + tot + 1, seg[i].l) - real;
		seg[i].r = lower_bound(real + 1, real + tot + 1, seg[i].r) - real - 1;
	}
	yzh.build(1, 1, tot);
	
	int ans = n + 1;
	sort(seg + 1, seg + n + 1);
	
	for (int i=1;i<=n;++i){
		if (yzh.query(1, seg[i].l, seg[i].r) > 0) ++ans;
		else yzh.modify(1, seg[i].l, seg[i].r);
	}
	
	write(ans);
	return 0;
}
```

### 并查集 168ms

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>

int n;

struct Segment{
	int l, r;
	bool operator < (const Segment & o) const {
		return r - l < o.r - o.l;
	}
} seg[300010];
int real[300010 << 1], tot;

int fa[300010];
int get(int x){
	return fa[x] == x ? x : fa[x] = get(fa[x]);
}

signed main(){
	read(n);
	for (int i=1;i<=n;++i){
		int x, r; read(x, r);
		seg[i] = {x - r, x + r};
		real[++tot] = x - r, real[++tot] = x + r;
	}
	sort(real + 1, real + tot + 1), tot = unique(real + 1, real + tot + 1) - real - 1;
	for (int i=1;i<=n;++i){
		seg[i].l = lower_bound(real + 1, real + tot + 1, seg[i].l) - real;
		seg[i].r = lower_bound(real + 1, real + tot + 1, seg[i].r) - real;
	}
	for (int i=1;i<=tot;++i) fa[i] = i;
	
	int ans = n + 1;
	
	for (int i=1;i<=n;++i){
		int l = get(seg[i].l), r = get(seg[i].r);
		if (l == r) ++ans;
		else fa[l] = r;
	}
	
	write(ans);
	return 0;
}
```

### 单调栈 89ms [目前最优解 rank1](https://www.luogu.com.cn/record/147892945)

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in","r",stdin), freopen(#a".out","w",stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <algorithm>

int n;
struct Circle{
	int l, r;
	bool operator < (const Circle & o) const {
		if (r == o.r) return l > o.l;
		return r < o.r;
	}
} cir[300010];

int stack[300010], top;

signed main(){
	read(n);
	for (int i = 1; i <= n; ++i) {
		int x, r; read(x, r);
		cir[i] = {x - r, x + r};
	}
	sort(cir + 1, cir + n + 1);
	
	int ans = n + 1;
	for (int i = 1; i <= n; ++i){
		int dsum = 0;
		while (top && cir[stack[top]].l >= cir[i].l) dsum += cir[stack[top]].r - cir[stack[top]].l, --top;
		stack[++top] = i;
		if (dsum == cir[i].r - cir[i].l) ++ans;
	}
	
	write(ans);
	return 0;
}
```

---

## 作者：伟大的王夫子 (赞：3)

本题的第一篇题解。

首先，每个圆对答案的贡献至少为 1，再加上刚开始就有一个平面，所以答案至少为 $n+1$。

然后，因为这道题中，每个圆的圆心都在同一条直线上，所以我们可以把问题再次简化，将每个圆的区域对应到线段上。

一个圆对答案的贡献为 2 当且仅当这个圆所对应的线段已经都被其他半径更小的圆覆盖了。

所以，我们可以按照圆的半径排序，一个个的进行覆盖。覆盖的操作我们可以用线段树的区间修改进行维护。

另外，线段树虽然名字叫“线段”树，但实际上对应的是点的信息。如果说我们想要维护线段的信息，我们可以将线段的左端点加上 1，或者将右端点减去 1。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
struct {
	int l, r;
	bool v;
} t[N << 3];
void spread(int p) {
	t[p << 1].v |= t[p].v;
	t[p << 1 | 1].v |= t[p].v;
}
void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(p << 1, l, mid);
	build(p << 1 | 1, mid + 1, r);
}
struct P {
	int x, r;
	bool operator < (const P &a) const {
		return r < a.r;
	}
} a[N];
int c[N << 1], m, n;
int lower(int x) {
	return lower_bound(c + 1, c + m + 1, x) - c;
}
inline void push_up(int p) {
	t[p].v = t[p << 1].v & t[p << 1 | 1].v;
}
bool ask(int p, int l, int r) {
	spread(p); 
	if (l <= t[p].l && r >= t[p].r) return t[p].v;
	int mid = (t[p].l + t[p].r) >> 1, val = 1;
	if (l <= mid) val &= ask(p << 1, l, r);
	if (r > mid) val &= ask(p << 1 | 1, l, r);
	return val;
}
void change(int p, int l, int r) {
	spread(p);
	if (l <= t[p].l && r >= t[p].r) {
		t[p].v = 1;
		return;
	} 
	int mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid) change(p << 1, l, r);
	if (r > mid) change(p << 1 | 1, l, r);
	push_up(p); 
}
int main() {
	//freopen("data.in", "r", stdin);
	//freopen("ans.out", "w", stdout);
	scanf("%d", &n);
	for (register int i = 1; i <= n; ++i) 
		scanf("%d%d", &a[i].x, &a[i].r), c[++m] = a[i].x - a[i].r, c[++m] = a[i].x + a[i].r;
	sort(a + 1, a + n + 1);
	sort(c + 1, c + m + 1);
	m = unique(c + 1, c + m + 1) - c - 1;
	build(1, 1, m);
	int ans = n + 1;
	for (register int i = 1; i <= n; ++i) {
		int x = lower(a[i].x - a[i].r), y = lower(a[i].r + a[i].x);
		ans += ask(1, x + 1, y);
		change(1, x + 1, y);
	}
	printf("%d", ans);
}
```

---

## 作者：MspAInt (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6875)

所有圆心都在同一条直线上，互不相交但可以相切。

显然每一个圆对答案的贡献只会是 $1,2$，任何一个圆的加入都会对答案产生 $1$ 贡献；而如果此时加入了一个大圆，且它被某些小圆从中间正好分开，那么其贡献为 $2$。

容易想到用一个栈维护。将圆在轴上的右端点作为第一关键字，左端点作为第二关键字对圆排序。右端点更小，左端点更大的排前面（显然如此排序能让所有大圆考虑到可能属于自己的小圆），然后一个一个地考虑它们。  
不停地把 被自己包含的栈顶圆 弹出并统计它们的直径和。由于圆两两不相交，判断直径和是否等于该圆的直径，即是否被切成两半（注意不能仅考虑这些圆的最左最右端点，这样会挂到 [49pts](https://www.luogu.com.cn/record/117605500)），然后把自己加入栈顶。

还是蛮好理解的。

瓶颈在排序的 $\Theta(n\log n)$ 萌萌哒 Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
struct node{int x,l,r;}a[N];
int n,top,s[N],ans;
bool cmp(node p,node q){
    return p.r==q.r?p.l>q.l:p.r<q.r;
}
signed main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].r),a[i].l=a[i].x-a[i].r,a[i].r+=a[i].x;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        ans++;
        if(!top){s[++top]=i;continue;}
        int sum=0;
        while(top&&a[s[top]].l>=a[i].l)sum+=(a[s[top]].r-a[s[top]].x<<1),top--;
        if(sum==(a[i].r-a[i].x<<1))ans++;
        s[++top]=i;
    }
    printf("%d\n",ans+1);
    //system("pause");
    return 0;
}
```

[record](https://www.luogu.com.cn/record/117605773)

---

## 作者：星星与辰 (赞：2)

讲点不一样的做法，学会的门槛很低，提前说明，我提供的做法只用到了数组模拟的链表指针。

题面简单到是个人都能看得懂，但需要注意一个容易遗漏的条件：**给出一些 $x$ 轴为中心的互不相交的圆。**

以 $x$ 轴为中心很简单，重点是互不相交的条件，这说明了什么？

显而易见地，当一个封闭图形与其他封闭图形有两个以上的交点时，一定会至少将平面再分出一部分，也就是它们的交的那部分，这时候我们计算答案将会非常的复杂，但是题目条件是没有任何一个相交的圆。

那我们要统计的是什么呢，来看看下面这张图![](https://cdn.luogu.com.cn/upload/image_hosting/covk8yve.png)

我们会发现只有在这种情况下（即一个圆被内部的圆分成两部分），一个圆才能带来两个平面，其他情况下是 $0$。

那么我们直接判断圆所在的 $x$ 轴上的区间是否被其他圆覆盖即可，这时可以把圆看作一个线段，因为我们只在乎它内部的圆是否已经覆盖整个圆所在的区间。

于是就有了以下做法，对于每一个圆，我们用 Cycle 记录两个信息，$x$ 轴上左端和右端，可以视为描述一个线段，我们用结构体 Node 表示每一个点，里面记录着这个点属于哪个圆，以及其对应的圆上另一个点的坐标，用 mark 记录当前已处理的内部的圆是否一个接着一个连续覆盖外部的圆，我们将这两个点按照某种顺序与其他点排序，使得在顺序处理点时，即使两个点在同一坐标，两个优先进入较外部的圆的点，然后再通过外部的圆层层进入内部的点，分层之后，我们只需要看一个圆内的未被其他圆包含的圆是否连续地覆盖了整个圆内的区间即可。

然后上AC代码：（顺便稍微再解释一下~~稍微有一点点细节。~~）
```cpp
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace lq{
	inline int read(){
		char letter=getchar();
		int ans=0;
		bool f=true;
		while((letter<'0'||letter>'9')&&letter!='-')letter=getchar();
		if(letter=='-')f=false,letter=getchar();
		while(letter>='0'&&letter<='9'){
			ans=(ans<<1)+(ans<<3)+letter-48;
			letter=getchar();
		}
		return f?ans:-ans;
	}
	inline void write(int x){
		if(x>9)
			write(x/10);
		putchar(x % 10 + 48);
	}
}
using namespace lq;
const int N = 3e5 + 1;
struct Node{
	bool mark;
	int pos ,id, other;
} node[N << 1];
struct Cycle{
	//圆的左端点的编号，右端点的编号,右端是否被更改，该圆是否重复
	int ld, rd;
	bool vr,mark;
	void insert(int x){
		if(!vr)
			rd = x, vr = true;
		else
			ld = x;
	}
} cycle[N];
int n;
bool cmp(Node x,Node y){
	if(x.pos == y.pos){
		if(y.mark&&!x.mark)
			return true;
		if(x.mark&&!y.mark)
			return false;
		return x.other > y.other;
		// 将另一个点位置最大的排到前面，论证一下其正确性
		// 当两个点都为左端时，我们应将相对作为外部的点排到前面，那个点的右端一定是较大的
		// 当两个点都为右端时，我们应将相对作为内部的点拍到前面，利用对称的性质，那个点的左端一定是较大的
	}
	return x.pos < y.pos;
}
int nxt[N],ans;
inline void solve(int id){
	//如果该圆已经重复，那么就跳过
	if(cycle[id].mark)
		return;
	int l = cycle[id].ld, r = cycle[id].rd;
	bool mark=true;
	if(node[l].pos!=node[nxt[l]].pos)
		mark = false;
	l = nxt[l];
	if(l>r)
		return;
	while(l){
		//进入到圆内的圆，优先处理圆内的圆
		solve(node[l].id);
		l=cycle[node[l].id].rd;
		if (nxt[l] > r || !nxt[l])
			break;
		if (node[nxt[l]].pos != node[l].pos)
			mark = false;
		l = nxt[l];
	}
	if (mark && node[l].pos==node[r].pos)
		ans = -~ans;
}
int main(){
	n = read();
	for (int i = 1; i<= n;i=-~i){
		int pos = read(), radius = read();
		node[(i << 1) - 1].id = node[i << 1].id = i;
		node[i << 1].other = cycle[i].ld = node[(i << 1) - 1].pos = pos - radius;
		node[(i << 1) - 1].other = cycle[i].rd = node[i << 1].pos = pos + radius;
		node[(i << 1) - 1].mark = true;
	}
	int nn = n << 1;
	sort(node + 1, node + nn +1, cmp);
	int head = 0;
	for (int i = nn; i >=1 ;i--){
		if(node[i].pos==node[i+1].pos&&node[i].other==node[i+1].other){
			//注意左右两点都可以带来一次判重
			if(!cycle[node[i].id].mark)
				n--;
			cycle[node[i].id].mark = true;
		}
		nxt[i] = head;
		if(node[i].mark)
			head = i;
		//重新更改圆的左右端，将记录坐标更改为记录编号
		cycle[node[i].id].insert(i);
	}
	ans = n + 1;
	int l = 1;
	while (l){
		solve(node[l].id);
		l = nxt[cycle[node[l].id].rd];
	}
	write(ans);
	return 0;
}
```
~~做完题后发现其实是可以直接排序圆本身的，这样排序会更舒服。看完别人的做法感觉自己好蠢qwq。~~

---

## 作者：huhangqi (赞：0)

由样例可以知道，一个圆只贡献一个区域，而一个圆在中间被几个圆完全连接时会被分成两个部分，计算两个贡献。

那么我们很容易想到先按照左端点排序，在左端点相同时，比较半径大小。

然后从后向前连接，如果前面与当前点的左端相等，那么我们就可以通过这个圆尝试把前面的圆分成两部分。

然后记录下状态，如果前面刚好有一个圆的右端点，则直接连接，继承到当前位置。

如果发现此时的右端点与尝试分开的圆的右端点相等，那么就记录贡献。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,f[300005],ans;
map<int,int> mp;
struct P{
	int x,r;
}a[300005];
bool cmp(P a,P b){
	if(a.x-a.r==b.x-b.r)return a.r>b.r;
	return a.x-a.r<b.x-b.r;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].r;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(mp[a[i].x-a[i].r])f[i]=mp[a[i].x-a[i].r];
		if(i!=1){
			if(a[i].x-a[i].r==a[i-1].x-a[i-1].r)f[i]=i-1;
		}
		if(f[i]&&a[i].x+a[i].r==a[f[i]].x+a[f[i]].r)ans++,f[i]=0;
		if(f[i])mp[a[i].x+a[i].r]=f[i];
	}
	cout<<ans+n+1;
	return 0;
}
``````

---

## 作者：hnczy (赞：0)

这里我们发现一个圆至少把这个平面多分为 $1$ 份，至多分为 $2$ 份，而原来有 $1$ 份。

那我们直接判断一下这个分为 $2$ 份的情况，我们很容易发现只要一个圆被其他的圆“中间切开”就会可以分成 $2$ 份。

这里怎么实现中间切开这个操作呢？被切开的圆肯定比它里面的圆大，直接根据 $r$ 进行排序，又因为每两个圆都不相交，但可以相切，那被切开的圆的左右两个端点肯定被两个圆相切。

而中间的多个圆肯定是互相相切的，那要判断这两个切点的联通性，直接用并查集即可。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=3E5+5;
struct node{
	int x,r;
	bool operator <(const node &a)const{
		return r<a.r;
	}
}a[N];
int b[2*N],n,ans,fa[2*N];
inline int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
inline void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return;
	fa[x]=y;
}
int main(){
	scanf("%d",&n);
	for(int i=1,x,r;i<=n;i++){
		scanf("%d%d",&x,&r);
		a[i]={x,r};
		b[i]=x-r;
		b[i+n]=x+r;
	}
	for(int i=1;i<=2*n;i++)
		fa[i]=i;
	sort(b+1,b+2*n+1);
	sort(a+1,a+n+1);
	int cnt=unique(b+1,b+2*n+1)-b-1;
	for(int i=1;i<=n;i++){
		int tmp1=a[i].x-a[i].r ,tmp2=a[i].x +a[i].r ;
		a[i].x =lower_bound(b+1,b+cnt+1,tmp1 )-b;
		a[i].r =lower_bound(b+1,b+cnt+1,tmp2 )-b;
	}
	for(int i=1;i<=n;i++){
		if(find(a[i].x)==find(a[i].r))
			ans++;
		else merge(a[i].x,a[i].r );
	}
	cout<<ans+n+1;
	return 0;
}

```

---

## 作者：内拉组里 (赞：0)

这里介绍一种非常暴力的解法，不需要任何数据结构。

# Thoughts：

考虑在所有圆不相交的情况下，一定能划分成 $ n + 1 $ 个区域。

对于增加的区域，归纳起来只有一种情况：多个子圆塞满了母圆的整条直径。

因为所有圆都在一条轴线上，所以知道一个圆与轴线的两个交点即可确定一个圆。

而为了满足上述情况，这些子圆一定是通过外切的方式连接并且两侧的子圆内切于母圆。

先对所有的圆以左交点为第一关键字升序，右交点为第二关键字降序排序。

然后用一个数组 $ rt $ 记录一个圆的母圆，同时需要记录下每个扫过圆的母圆的右交点。

当一个圆与其母圆的右端点相同时，可以说明母圆的直径已经被塞满了，统计答案。

否则这个圆需要继承左边相切的圆的母圆的右交点。

由于左端点相同的点一定内切，故先考虑内切，再考虑外切。

# Analyses：

> 总时间复杂度 $ \Theta (N \log{N}) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Code：

```cpp
/* reference : @ZLOJ.huhangqi */
#pragma		GCC		optimize(5)
#include	<algorithm>
#include	<iostream>
#include	<map>
using namespace std;
constexpr int maxn = 3e5+4;

int n;
struct seg
{
	int l, r;
	bool operator< (const seg &s) const
	{
		if (l != s.l) return l < s.l;
		return r > s.r;
	}
}sg[maxn];
int rt[maxn];
/* parent circle */
map<int,int> rtg;

signed main (void)
{
	cin >> n;
	for (int x, r, i = 1; i <= n; i++)
	{
		cin >> x >> r;
		sg[i] = {x - r, x + r};
	}
	sort (sg + 1, sg + n + 1);
	int ans = n + 1;	/* number of raw circles (without tangency points) */
	for (int i = 1; i <= n; i++)
	{
		if (i > 1 && sg[i].l == sg[i - 1].l) rt[i] = i - 1;	/* incircle is the best */
		else if (rtg[sg[i].l]) rt[i] = rtg[sg[i].l];		/* excircle is the second */
		if (rt[i])
		{
			if (sg[i].r == sg[rt[i]].r) ans++;				/* already devide parent circle into two parts */
			else rtg[sg[i].r] = rt[i];						/* inherit right endian to keep on deviding */
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

我们考虑一个圆的贡献，首先，它肯定将这个平面分成内外两部分，贡献为 $1$，当存在一组比它小的圆，排满它的直径的时候，这个圆内部被分成两部分，贡献加一。  
现在的问题就是如何快速判断一个圆是否被分成两份。  
我们发现这个东西并不好判断，考虑转换。  
我们将圆心在 $(x,0)$，半径为 $r$ 的圆视作 $[x-r,x+r]$ 的区间，问题就转换为了是否存在若干个小区间，完全覆盖大区间。  
那这个问题就简单了，我们使用并查集维护，将所有区间按照区间大小排序，从小到大加入，加入一个区间时，我们查询 $l,r$ 是否连通，若连通，则被覆盖，答案加一，然后我们把 $[l,r]$ 中的点合并到一个并查集中。   
但是这样显然可能超时，因为最劣情况为 $n$ 个同心圆，这样就可以卡到 $O(n^2)$ 了，事实上，并没有这样的数据，所以这样就过了。  
但我们不能因为过了就忽视复杂度问题，所以我们记录 $nxt_i$ 表示第 $i$ 个点的未连接后继是哪个点，然后每次合并之后将 $nxt_l$ 更新为 $r$ 即可。
```c++
#include<bits/stdc++.h>
#define int long long
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=3e5+5,inf=1e18;
int n,ans,tot;
int tmp[N<<1],fa[N<<1],nxt[N<<1];
struct Line{
	int l,r;
	bool operator <(const Line &a)const{return r-l<a.r-a.l;}
}a[N];
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return ;
	fa[x]=y;
}
signed main(){
	read(n);
	ans=n+1;
	for(int i=1,x,r;i<=n;i++){
		read(x),read(r);
		a[i].l=x-r,a[i].r=x+r;
		tmp[i]=a[i].l;
		tmp[i+n]=a[i].r;
	}
	sort(a+1,a+n+1);
	sort(tmp+1,tmp+2*n+1);
	tot=unique(tmp+1,tmp+2*n+1)-tmp-1;
	for(int i=1;i<=n;i++){
		a[i].l=lower_bound(tmp+1,tmp+tot+1,a[i].l)-tmp;
		a[i].r=lower_bound(tmp+1,tmp+tot+1,a[i].r)-tmp;
	}
	for(int i=1;i<=tot;i++)fa[i]=i,nxt[i]=i+1;
	for(int i=1;i<=n;i++){
		if(find(a[i].l)==find(a[i].r))ans++;
		for(int j=a[i].l;j<a[i].r;j=nxt[j])merge(j,j+1);
		nxt[a[i].l]=a[i].r;
	}
	write(ans);
}
```

---

## 作者：yshpdyt (赞：0)

## 题意
$n$ 个圆心在 $x$ 轴上的圆，保证不相交或重叠，但是可能外切或内切，求把平面分成了几个部分。

## Sol
首先可以证明，每有一个圆，便会形成至少一个封闭部分，即至少为 $n+1$，一因为还要算上平面本身。

证明比较好想。

两个圆外离，那么各自会形成一个封闭部分。

两个圆内切或内离，由于不重叠，小圆无法完全填充大圆。同理，如果有很多的小圆排列在大圆内部，那么大圆总会剩下一点空间，形成大圆的封闭部分，和小圆各自的封闭部分。

我们以**半径从小到大**看所有圆。一堆圆先排列在 $x$ 轴上，以第一种情况统计，然后由于互相不重叠，可能会有若干大圆将这些小圆包含，以第二种情况分别统计，然后把忽略每个被包含的小圆，剩下若干大圆，又变成了第一种情况，接着就是不断循环。

但是肯定没这么简单，考虑什么情况下，会被划分出额外的封闭部分，第一种情况肯定没戏，只剩下第二种，注意到一条直线会将一个封闭部分再分成两个部分，而本题只允许在 $x$ 轴，即圆的一条直径上有圆，考虑将小圆的直径拼接起来吗，如果恰好可以构成直径，圆就会被分成上下两部分。

转化一下问题，把圆看作区间，现在有 $n$ 个区间，求有多少个区间可以由其余若干区间拼接得到。根据刚才的结论，从小到大处理，用线段树实现区间赋值，区间查找最小值操作，每遍历一个区间，就先查询区间 $[x-R,x+R]$ 最小值，如果最小值为 $0$，说明该位置没有区间覆盖，此区间无法贡献，否则贡献加一，查询完后，将 $[x-R,x+R]$ 赋值为任意正整数即可。

由于值域较大，需要动态开点。

最终答案是：

$$\exists i\in[1,n],j\in[l_i,r_i],c_j=1$$

$$res=n+1+\sum\limits_{i=1}^n \left[\left(\min\limits_{j=l_i}^{r_i}c_j\right)>0\right]
$$


时间复杂度 $O(n\log V)$，$V$ 是值域。

注意本题值域是 $[-2\times 10^9,2 \times 10^9]$。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 200005
#define endl "\n" 
#define fi first
#define se second
using namespace std;
const ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
ll cnt=0,rt,LD=-2e9,RD=2e9;
ll n;
struct cir{
    ll x,r;
    friend bool operator<(const cir &a,const cir &b){
        return a.r<b.r;
    }
}f[N];

struct sgt{
    #define mid ((l+r)>>1)
    struct node{
        ll lc,rc;
        ll val,lzy;
    }tr[N*4];
    void build(ll &p){
        p=++cnt;
    }
    void lt(ll p,ll x){
        tr[p].val=p;
        tr[p].lzy=p;
    }
    void pushdown(ll p){
        if(!tr[p].lc)build(tr[p].lc);
        if(!tr[p].rc)build(tr[p].rc);
        if(!tr[p].lzy)return ;
        lt(tr[p].lc,tr[p].lzy);
        lt(tr[p].rc,tr[p].lzy);
        tr[p].lzy=0;
    }
    void upd(ll &p,ll l,ll r,ll le,ll ri,ll t){
        if(!p)build(p);
        if(le<=l&&ri>=r){
            lt(p,t);
            return ;
        }
        pushdown(p);
        if(le<=mid)upd(tr[p].lc,l,mid,le,ri,t);
        if(ri>mid)upd(tr[p].rc,mid+1,r,le,ri,t);
        tr[p].val=min(tr[tr[p].lc].val,tr[tr[p].rc].val);
    }
    ll qr(ll p,ll l,ll r,ll le,ll ri){
        if(le<=l&&ri>=r)return tr[p].val;
        pushdown(p);
        ll ans=inf;
        if(le<=mid)ans=min(ans,qr(tr[p].lc,l,mid,le,ri));
        if(ri>mid)ans=min(ans,qr(tr[p].rc,mid+1,r,le,ri));
        return ans;
    }
}T;
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>f[i].x>>f[i].r;
    sort(f+1,f+n+1);
    ll res=1+n;
    for(int i=1;i<=n;i++){
        if(rt&&T.qr(rt,LD,RD,f[i].x-f[i].r,f[i].x+f[i].r)>0)res++;
        T.upd(rt,LD,RD,f[i].x-f[i].r,f[i].x+f[i].r,1);
    }
    cout<<res<<endl;
    return 0;
}
```

---

## 作者：HJY2022 (赞：0)

由于园之间互不相交，所以只有包含的关系，容易发现加入一个圆只会将平面多分割出一至两个部分。考虑如何区分，容易发现如果加入了两个部分肯定是一些连起来的小圆把大圆上下分开，就下这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ar6fn46.png?x-oss-process=image/resize,m_lfit)

那么我们用并查集维护圆与横轴的交点，将圆按照直径排序后加入，如果一个圆在加入时交点已在一个并查集内那么说明它被分割成了上下两部分，也就是增加了两个部分，否则只增加了一个部分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lc x << 1
#define rc x << 1 | 1
#define pii pair<int,int >
#define fir first
#define sec second
#define ll long long
#define i128 __int128

struct FastIO{
	#define IOSIZE 1048576
	char in[IOSIZE],*p,*pp,out[IOSIZE],*q,*qq,ch[20],*t,b,K,prs;
	FastIO():p(in),pp(in),q(out),qq(out+IOSIZE),t(ch),b(1),K(6){}
	~FastIO(){fwrite(out,1,q-out,stdout);}
	inline char gc(){return p==pp&&(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?b=0,EOF:*p++;}
	inline void pc(char x){q==qq&&(fwrite(out,1,q-out,stdout),q=out),*q++=x;}
}io;

ll read(){
    ll x = 0,f = 1,ch = io.gc();
    while(ch < 48 || ch > 57){
        if(ch == '-')f = -1;
        ch = io.gc();
    }
    while(ch > 47 && ch < 58)x = x * 10 + ch - 48,ch = io.gc();
    return x * f;
}

void write(ll x){
	if(x < 0){io.pc('-');x = -x;}
	if(x > 9)write(x / 10);
	io.pc(x % 10 + 48);
}

const int MX = 6e5 + 7;

int fa[MX];
ll id[MX],l[MX],r[MX],p[MX],tot = 0;

int find(int x){
	if(fa[x] != x)fa[x] = find(fa[x]);
	return fa[x];
}

bool cmp(int x,int y){
	return r[x] - l[x] < r[y] - l[y];
}

int main(){
	int n = read();
	for(int i = 1;i <= n;i++){
		ll x,R;
		x = read();R = read();
		l[i] = x - R,r[i] = x + R;id[i] = i;
		p[++tot] = x - R;p[++tot] = x + R;
	}
	sort(id + 1,id + 1 + n,cmp);
	sort(p + 1,p + 1 + tot);
	tot = unique(p + 1,p + 1 + tot) - p - 1;
	for(int i = 1;i <= tot;i++)fa[i] = i;
	ll ans = 1;
	for(int i = 1;i <= n;i++){
		int x = lower_bound(p + 1,p + 1 + tot,l[id[i]]) - p - 1;
		int y = lower_bound(p + 1,p + 1 + tot,r[id[i]]) - p - 1;
		int xx = find(x),yy = find(y);
		if(xx == yy)ans += 2;
		else ans++;
		fa[xx] = yy; 
	}
	write(ans);io.pc('\n');
	return 0;
}
```

---


# 「MCOI-03」括号

## 题目背景

MCOI q 群的日常 ……

> 一只书虫仔：挖不到钻石，我要哭了（笑）     
> WAPER420：我们分明次次挖到钻石啊（疑惑）   
> 一只书虫仔：（友善的笑容）     
> 7KByte：为什么你们都喜欢加括号啊（呆呆地望着）      
> 一只书虫仔：（笑）  
> WAPER420：（笑）     
> 鏡音リン：（笑）     
> 7KByte：（笑）

---

本题中 **合法括号串** 的定义如下：

1. 空串是合法括号串。
2. 如果 ```A``` 是合法括号串，则 ```(A)``` 是合法括号串。
3. 如果 ```A```，```B``` 是合法括号串，则 ```AB``` 是合法括号串。

本题中 **子串** 的定义如下：

字符串 $S$ 的子串是 $S$ 中连续的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \leq l \leq r \leq |S|$，$|S |$ 表示 ```S``` 的长度）。

## 题目描述

定义一个括号串的 $0$ 级偏值为将该括号串修改为 **合法括号串** 需要的最小操作数。一次操作你可以在一个位置 **添加** 一个括号或者 **删除** 一个位置的括号。

定义一个括号串的 $i\ (i>0)$ 级偏值为该串 **所有子串** 的 $i-1$ 级偏值之和。

现在你需要求出一个长度为 $N$ 的括号串 $S$ 的 $K$ 级偏值。答案可能很大，输出对 $998244353$ 取模后的结果。

## 说明/提示

#### 样例说明

对于样例 $1$，$S$ 的所有子串的 $0$ 级代价为：

- $\texttt{(}$，代价为 $1$
- $\texttt{(}$，代价为 $1$
- $\texttt{)}$，代价为 $1$
- $\texttt{((}$，代价为 $2$
- $\texttt{()}$，代价为 $0$
- $\texttt{(()}$，代价为 $1$

总和为 $1+1+1+2+0+1=6$。

#### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | $N\le$ | $K\le$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $5$ | $3$ |
| $2$ | $5\times 10^3$ | $1$ | $10$ |
| $3$ | $10^6$ | $1$ | $12$ |
| $4$ | $10^2$ | $10^2$ | $10$ |
| $5$ | $5\times10^3$ | $5\times 10^3$ | $20$ |
| $6$ | $10^6$ | $10^6$ | $45$ |


对于 $100\%$ 的数据，$1 \le N,K \le  10^6$。

---

原 idea：WAPER420

## 样例 #1

### 输入

```
3 1
(()```

### 输出

```
6```

## 样例 #2

### 输入

```
3 2
(()```

### 输出

```
15```

# 题解

## 作者：littleKtian (赞：11)

一个括号串的 $0$ 级偏值就是进行括号匹配后还未匹配的左括号和右括号数之和（因为中间括号尽可能配对一定是最优的）。

设子串 $S(l,r)$ 未匹配的左括号和右括号数之和为 $f(l,r)$。

利用组合数知识可知答案为：  
$$\begin{aligned}&\sum\limits_{1\leqslant l\leqslant r\leqslant n}^n\dbinom{l+k-2}{k-1}\dbinom{n-r+k-1}{k-1}f(l,r)\\=&\sum\limits_{l=1}^n\dbinom{l+k-2}{k-1}\sum\limits_{r=l}^n\dbinom{n-r+k-1}{k-1}f(l,r)\end{aligned}$$

直接枚举 $l$，根据当前括号在 $S$ 中的匹配状况维护 $\sum\limits_{r=l}^n\dbinom{n-r+k-1}{k-1}f(l,r)$ 即可。

利用后缀和可以做到 $O(n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 998244353
#define N 2000000
int jc[N+5],ny[N+5];
int c[1000005],r[1000005];
int z[1000005],zd,rp[1000005],l;
int n,k,ans,lans;
int C(int x,int y){return 1ll*jc[x]*ny[y]%p*ny[x-y]%p;}
int main()
{
	jc[0]=ny[0]=ny[1]=1;
	for(int i=1;i<=N;i++)jc[i]=1ll*i*jc[i-1]%p;
	for(int i=2;i<=N;i++)ny[i]=1ll*(p-p/i)*ny[p%i]%p;
	for(int i=1;i<=N;i++)ny[i]=1ll*ny[i]*ny[i-1]%p;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		char ch=getchar();
		while(ch!='('&&ch!=')')ch=getchar();
		c[i]=ch=='('?1:0;
	}
	for(int i=1;i<=n;i++)r[i]=C(n-i+k-1,k-1);
	for(int i=1;i<=n;i++)
	{
		if(c[i])z[++zd]=i;
		else if(zd)rp[z[zd--]]=i;
		else ++l;
		lans=(lans+1ll*r[i]*(zd+l))%p;
	}
	for(int i=n;i;i--)r[i]=(r[i]+r[i+1])%p;
	for(int i=1;i<=n;i++)
	{
		ans=(ans+1ll*C(i+k-2,k-1)*lans)%p,lans=(lans-r[i]+p)%p;
		if(rp[i])lans=(lans+1ll*2*r[rp[i]])%p;
	}
	printf("%d",ans);
}
```

---

## 作者：wurzang (赞：8)

考场sb没想到容斥，于是过来写个题解。

## Part 1

考虑 $K=1$ 的时候怎么做。对于每个单独的括号考虑贡献，设当前的位置为 $i$，括号为左括号（右括号同理），与它匹配的右括号的位置为 $posr$。显然，如果这个左括号没有匹配的右括号的话，那么它能对任何一个包含 $i$ 的区间造成贡献。所以我们只考虑有匹配的时候。
    
可以证明，如果有一段区间同时包含 $i$ 与 $posr$ 的话，$i$ 无法对那段区间造成贡献。因为 $i$ 一定会与 $posr$ 配对。
    
所以，一个左括号的贡献为 $i \times (posr-i)$。
    
于是我们就做出了 $K=1$ 的情况。
    
    
  
## Part 2

对于 $K>1$ 的情况，再考虑每个左括号能贡献的区间的贡献。从组合意义上考虑，就是求 $K+1$ 个二元组 $(l,r)$，对于 $i\in [1,K]$，使得 $l_i\le l_{i+1},r_i \ge r_{i+1}$，并且 $l_{K+1}=r_{K+1}=i,r_{K}<posr$


先不管 $r_K<posr$ 的限制，直接求二元组的个数。从组合意义上来讲，$l_1\sim l_K$ 的方案数就是从 $[1,i]$ 中选出 $K$ 个数，而且数字可以重复选，毫无疑问这就是可重组合的方案数，也就是 $\binom {i+K-1}{K}$，$r_1 \sim r_K$ 的方案数同理。

然而有一个 $r_K<posr$ 的限制，考虑容斥，求 $r_K\ge pos_r$ 时的方案数，根据上述的过程，这个方案数就是：

$$
\sum_{i=posr}^n \binom {n-i+K-1}{K-1}
$$

这是一个组合数的经典套路，上述式子的和就是 $\binom {n-posr+K}{K}$，可以根据 $\binom i j =\binom {i-1}{j-1}+\binom {i-1}{j}$ 去推导。（当然如果你非要写后缀和的话复杂度也是正确的）


注：如果对这一部分不理解的话可以去做一下 [【CSGRound2】开拓者的卓识](https://www.luogu.com.cn/problem/P5641)



代码就不放了（

---

## 作者：hater (赞：7)

首先 删除或者插入 操作 

可以看做只有删除操作 （显然）

之后 那个k级偏值 看着也很假 

我们考虑每个子串对最终答案的贡献 

$ \sum_{l=1}^n \sum_{r=l}^n f_{l,r} {n-r+k-1\choose k-1} {l-1+k-1\choose k-1} $ 

( f 函数指使区间括号匹配的最小操作次数 下同 ）  

人话解释一下 ： 

一个子串的贡献 每增加一级偏值 左右端点可以向外拓展（或不拓展） 

最后拓展到 1 到 n 

本质上就是一个数拆成若干个非负整数 的**解的个数** 

然后这道题就变得可做多了 

考虑递增枚举右端点 维护 $\sum_{l=1}^n f_{l,r} {l-1+k-1\choose k-1}$

每次乘上 ${n-r+k-1\choose k-1}$ 求和就是答案 

如何维护 ： 

假设我们已经知道了对于r-1的上述和式的值 考虑r处字符的影响

情况1 ：加入左括号 

那么所有的 $f_{l,r}$ 对于 $f_{l,r-1}$都会 + 1 

情况2 ：加入右括号 

如果没有左括号匹配 那么同情况1 

如果有左括号相匹配 

设与其匹配的左括号位置为 $t$ 

那么所有的 $f_{l,r}$ 对于 $f_{l,r-1}$都会 - 1 $(l<=t)$ 

所有的 $f_{l,r}$ 对于 $f_{l,r-1}$都会 + 1 $(t<l)$ 

（ 不理解请手动画图 ） 

但是 我们要求的是对和式的影响 并不是对 f 函数的影响 

这个其实好办 观察对f的影响是区间 +1 或 -1 

我们只要做一个 对${l-1+k-1\choose k-1}$的前缀和 就好了 

然后就没了 

```cpp
#include<bits/stdc++.h> 
#define rg register 
#define fp( i , x , y ) for( rg int i=(x); i<=(y); ++i ) 
#define fq( i , x , y ) for( rg int i=(y); i>=(x); --i )  
using namespace std ; 
const int N = 2e6+10 , hgs = 998244353 ; 
int sum[N] , n , fac[N] , inv[N] , k , sta[N] , top ;    
char s[N] ; 
int qpow( int A , int B ) { 
 int C=1 ; 
 for( ; B ; B>>=1 ,A=1ll*A*A%hgs ) 
  if( B&1 ) C=1ll*A*C%hgs ; 
 return C ; 
}
void ret( int &x ) { 
  x = (x%hgs+hgs) % hgs ; 
} 
void upd( int &x , int y ) { 
  x = (x+y) % hgs ; 
} 
int C( int A , int B ) { 
  return 1ll * fac[B] * inv[A] % hgs * inv[B-A] % hgs ;  
}  
void prep( ) { 
  fac[0] = inv[0] = 1 ; 
  fp( i , 1 , (2e6) ) 
    fac[i] = 1ll * fac[i-1] * i % hgs ; 
  inv[(int)(2e6)] = qpow( fac[(int)(2e6)] , hgs-2 ) ; 
  fq( i , 1 , (2e6)-1 ) 
    inv[i] = 1ll * inv[i+1] * (i+1) % hgs ; 
  fp( i , 1 , (1e6) ) 
    sum[i] = sum[i-1] + C( k , i-1+k ) , sum[i] %= hgs ;   
} 
int calc( int i , int j ) { 
  int t = sum[j] - sum[i-1] ; 
  return ( t % hgs + hgs ) % hgs ; 
} 
void Sub( ) { 
  int ans = 0 ;  
  fp( i , 1 , n ) { 
    if( s[i] == '(' ) { 
      sta[++top] = i ; 
      ans ++ ; 
	} else { 
	  if( top ) top -- , ans -- ; 
	  else ans ++ ; 
	} 
  } 
  cout << ans << '\n' ; 
} 
signed main( ) { 
  scanf( "%d %d" , &n , &k ) ; 
  scanf( "%s" , s+1 ) ; 
  if( k == 0 ) { Sub( ) ; return 0 ; } 
  k -- ; prep( ) ; 
  int nws=0 , ans=0 ;  
  fp( i , 1 , n ) { 
    if( s[i] == '(' ) { 
      upd( nws , sum[i] ) ; 
      sta[++top] = i ; 
	} else { 
	  if( top ) { 
	    int t = sta[top--] ; 
	    upd( nws , -sum[t] ) ; ret( nws ) ; 
	    upd( nws , calc( t+1 , i ) ) ; 
	  } else 
	    upd( nws , sum[i] ) ;  
	} 
	upd( ans , 1ll * C( k , n-i+k ) * nws % hgs ) ;  
  } 
  cout << ans << '\n' ; 
  return 0 ; 
} 
```







---

## 作者：7KByte (赞：6)

$\texttt{Subtask1:}$

读题分，不论你是爆搜/枚举/打表，还是等等，都可以过。


$\texttt{Subtask2:}$

枚举一个左端点，然后在枚举右端点的过程中记录答案，可以做到$\rm O(1)$求出一个子串的 $0$ 级偏值，最后$N^2$统计一下。总的时间复杂度$\rm O(N^2)$。

$\texttt{Subtask3:}$

我们可以对每个括号算贡献。

假设第$i$个位置为$\texttt{(}$，第一个与之匹配的$\texttt{)}$在$j$，则这个$\texttt{(}$对答案的贡献为$i\times (j-i)$。

同理，假设第$i$个位置为$\texttt{)}$，第一个与之匹配的$\texttt{(}$在$j$，则这个$\texttt{)}$对答案的贡献为$(n-i+1)\times (i-j)$。

时间复杂度$\rm O(N)$。

```cpp
#include<bits/stdc++.h>
char s[2000005];int n,sta[2000005],top;long long ans=0;
int main(){
	scanf("%d%d",&n,&top);top=0;
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)if(s[i]=='(')sta[++top]=i;else ans+=1LL*(i-sta[top])*(n-i+1),top=std::max(0,top-1);
	top=0;sta[0]=n+1;for(int i=n;i;i--)if(s[i]==')')sta[++top]=i;else ans+=1LL*i*(sta[top]-i),top=std::max(top-1,0);
	return printf("%lld\n",ans%998244353),0;
}
```

$\texttt{Subtask4:}$

记忆化搜索。

首先$N^2$/$N^3$求出所有子串的 $0$ 级偏值。定义 $f[i][l][r]$为串$[l,r]$的 $i$ 级贡献。

$$f[i][l][r]=\sum\limits_{u=l}^{r}\sum\limits_{v=u}^{r}f[i-1][u][v]$$

时间复杂度$\rm O(N^4K)$。常数优化 $+$ 跑不满 $+$ luogu更新后的评测机可以通过。

或者前缀和优化一下可以少一个$N$。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 105
#define P 998244353
using namespace std;
typedef long long ll;
int n,k;char s[N];ll f[N][N][N];
void calc(int l){
	int top=0,sum=0;
	rep(i,l,n){
		if(s[i]=='(')top++;
		else if(top)top--;
		else sum++;
		f[0][l][i]=sum+top;
	}
}
int calc(int x,int l,int r){
	if(~f[x][l][r])return f[x][l][r];
	f[x][l][r]=0;
	rep(i,l,r)rep(j,i,r)f[x][l][r]+=calc(x-1,i,j);
	return f[x][l][r]%=P;
}
int main(){
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	memset(f,~0,sizeof(f));
	rep(i,1,n)calc(i);
	printf("%d\n",calc(k,1,n));
	return 0;
}
/*
7 1
(()()()
*/
```

$\texttt{Subtask6:}$

注意我们先讲$\texttt{Subtask6:}$

对于一个位置在 $j$ 的右括号$\texttt{)}$，第一个与之匹配的左括号的位置为 $i$ ，则只会对左端点$\in[i+1,j]$，右端点$\in [j,n]$的括号序列的 $0$ 级偏值产生 $1$ 的贡献。

扩展到 $1$ 级偏值，不难发现只会对左端点$\in[1,j]$，右端点$\in [j,n]$的括号序列的 $1$ 级偏值产生 $(j-i)\times (n-j+1)$ 贡献。

扩展到 $k$ 级偏值，不难发现对答案的贡献为：

$$\large\sum\limits_{a_1=1}^{j}\sum\limits_{a_2=a_1}^{j}\cdots\sum\limits_{a_k=\max\{a_{k-1},i+1\}}^{j}\sum\limits_{b_1=j}^{n}\sum\limits_{b_2=b_1}^{n}\cdots\sum\limits_{b_k=b_{k-1}}^{n}1$$


考虑组合意义。这等价于我们以$j$为分界点，在左边（包括$j$）选$k$个不减的位置，在右边（包括$j$）选$k$个不减的位置，且左边必须要选择一个在$[i+1,j]$之间的位置。

这样贡献为：

$\large\left(\sum\limits_{a1\le a_2\le\cdots\le a_k,a_k>i}1\right)\times \left(\sum\limits_{b1\le b_2\le\cdots\le b_k}1\right)$。

两边可以分开算。选$k$个不减的位置等价于在$[1,r]$中选择$k$个数，一个数可以重复选，这就是可重集组合，方案数为$\binom{k}{r+k-1}$。

对于$a_k>i$的条件，容斥一下即可。

时间复杂度$\rm O(N\ \log\ P)$，可以线性求逆元，将时间复杂度优化到$\rm O(N)$。

$\texttt{Subtask5:}$

如果你不会预处理阶乘求组合数/没想到容斥/没想到分开贡献/其他位置原因，$\rm O(NK)/O(N^2+K)/O(N+K^2)/O(N^2+K^2)$的时间复杂度都是可以的。

或者不用组合数，直接求$K$次前缀和，复杂度是$\rm O(NK)$。

$\rm O(N\log P)$的代码。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 2000005
#define P 998244353
using namespace std;
typedef long long ll;
char s[N];int n,k,sta[N],top;ll fac[N<<1],cur[N],inv[N<<1],ans;
ll Pow(ll x,int y){ll now=1;for(;y;y>>=1,x=x*x%P)if(y&1)now=now*x%P;return now;}
ll C(int x,int y){return fac[x]*inv[y]%P*inv[x-y]%P;}
void init(){
	inv[0]=fac[0]=1;
	rep(i,1,n+k)fac[i]=fac[i-1]*i%P,inv[i]=Pow(fac[i],P-2);
	rep(i,1,n)cur[i]=C(i+k-1,k);
}
ll R(int x,int y){return (cur[x]-cur[x-y])%P;}
ll T(int x){return cur[x];}
signed main(){
	//freopen("6.10.in","r",stdin);
	//freopen("6.10.out","w",stdout);
	scanf("%lld%lld",&n,&k);
	scanf("%s",s+1),init();
	for(int i=1;i<=n;i++)if(s[i]=='(')sta[++top]=i;
		else ans+=1LL*R(i,i-sta[top])*T(n-i+1)%P,top=std::max(0LL,top-1);
	top=0;sta[0]=n+1;
	for(int i=n;i;i--)if(s[i]==')')sta[++top]=i;
		else ans+=T(i)*R(n-i+1,sta[top]-i)%P,top=std::max(top-1,0LL);
	printf("%lld\n",(ans%P+P)%P);
	return 0;
}
/*
25 15
()())()))((())()))((()()(
*/
```

---

## 作者：ChengJY_ (赞：5)

很有意思的组合计数加容斥。

### Solution

-  $K=0$

就是经典括号匹配问题，开个栈模拟一下即可。

- $K=1$

显然可以 $O(n^2)$ 枚举子串，但这样复杂度太高。

考虑拆开找贡献，对于下标为 $i$ 的左括号，设它匹配的右括号下标为 $j$ (特别的，没有匹配时 $j=n+1$ )。

那么易证，这个左括号对所有 $i\le r＜ j$ 且 $1\le l\le i$ 的区间都有 1 的贡献，总贡献即为 $i\times(j-i)$ 。

右括号同理，因此可以 $O(n)$ 计算。

- $K>1$

套用 $K=1$ 时的计算方法，找贡献。

我们发现对于一个 $K$ 级偏值的字符串，只会对包含它的母串的 $K+1$ 级偏值造成贡献。

还是假设以下一个下标为 $i$ 的左括号，设它匹配的右括号下标为 $j$ 。

那么我们就要找到所有这样的 $K$ 个区间层层嵌套的区间组。

将 $K$ 个区间的左右端点抽象以下扔到数轴上就是：

 $i$ 左边为值域在 $[1,i]$ ，长度为 $K$ 的不降序列。

 $i$ 右边为值域在 $[i,n]$ ，长度为 $K$ 的不降序列，其中第一个元素要小于 $j$ 。

发现 $i$ 左边的好处理，等价于将 $K$ 个数装进 $i$ 个箱子里，允许空箱子，经典组合问题，答案为 $\dbinom{K+i-1}{i-1}$ 。

右边不是很好处理，但是看一会发现可以容斥。

强制使第一个元素大于等于 $j$ ，那么就是值域在 $[j,n]$ ，长度为 $K$ 的不降序列，答案为 $\dbinom{K+n-j}{n-j}$ 。

最终总贡献就是 $\dbinom{K+i-1}{i-1}\times \left(\dbinom{K+n-i}{n-i}-\dbinom{K+n-j}{n-j}\right)$ 。

右括号同理。

### Code

```cpp
#include<bits/stdc++.h>
#define orz puts("%%%wyy332623");
#define N 2000005
#define int long long
using namespace std;

inline int read(){
    int x=0,w=1;
    char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*w;
}

const int mod = 998244353;
int n,k,ans;
int fac[N],ifac[N],p[N];
char ch[N];
stack<int> s;

int qpow(int x,int k){
    int res=1;
    while(k){
        if(k&1) res=res*x%mod;
        x=x*x%mod;k>>=1;
    }
    return res;
}
void init(){
    fac[0]=ifac[0]=1;
    for(int i=1;i<=2000000;++i) fac[i]=fac[i-1]*i%mod;
    ifac[2000000]=qpow(fac[2000000],mod-2);
    for(int i=1999999;i>=1;--i) ifac[i]=ifac[i+1]*(i+1)%mod;
}
int C(int x,int y){return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}

signed main(){
    init();
    n=read();k=read();
    scanf("%s",ch+1);
    for(int i=1;i<=n;++i) if(ch[i]=='(') p[i]=n+1;
    for(int i=1;i<=n;++i) 
        if(ch[i]=='(')s.push(i);
        else {
            if(s.empty()) continue;
            p[s.top()]=i,p[i]=s.top(),s.pop();
        }
    for(int i=1;i<=n;++i)
        if(ch[i]=='(') ans=(ans+C(k+i-1,i-1)*(C(k+n-i,n-i)-C(n-p[i]+k,n-p[i])+mod)%mod)%mod;
        else ans=(ans+C(k+n-i,n-i)*(C(k+i-1,i-1)-C(k+p[i]-1,p[i]-1)+mod))%mod;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_lfe (赞：4)

# 「MCOI-03」括号
[「MCOI-03」括号](https://www.luogu.com.cn/problem/P7044)

终于自己做出来一道数数题QAQ。

# Solution

首先，我们可以发现，最后的答案一定可以表示为一些区间的 $0$ 级偏移值相加的形式。
所以，我们直接考虑对于一个区间 $[l,r]$，它的 $0$ 级偏移值对答案的贡献。

我们发现，每次偏移值的级数 $+1$，所有包含 $[l,r]$ 的区间的偏移值都会算上 $[l,r]$ 的贡献，而最后一次一定是所有子区间贡献到了 $[1,n]$。

也就是说，这个区间的 $0$ 级偏移值最后被算的次数，就相当于这个区间左右端点每次分别向左右两边延伸，$l\rightarrow l'\in[1,l]$，$r\rightarrow r'\in[r,n]$，共延伸 $k$ 次，且最后一次恰好延伸成 $[1,n]$ 的所有不同方案的方案数。

考虑怎样计算这个方案数，不难发现这就是一个简单的球盒问题，对于任意一边，都相当于将需要扩展的长度 $len$，分配给 $k$ 次扩展，每次可空，并将最后左右两边的方案数乘起来。  
具体地，设区间 $[l,r]$ 的 $0$ 级偏移值为 $f(l,r)$，则它对答案的贡献为：$\binom{l-1+k-1}{k-1} \binom{n-r+k-1}{k-1} f(l,r)$。

所以总的答案就是：
$$
ans = \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} \binom{l-1+k-1}{k-1} \binom{n-r+k-1}{k-1} f(l,r)
$$

然而我们发现，这个复杂度是爆掉的。  
不过没关系，我们先放着这个式子，来看一看 $f(l,r)$ 怎么求。

显然，对于一个区间，我们把匹配的括号消掉之后，它一定长成这个样子：）））（（（（，而这个区间的贡献就是这些括号的数量。

我们发现直接枚举区间复杂度就一定会超，所有考虑枚举元素，也就是考虑对于序列中的一个括号，它会对那些区间的 $f$ 值产生 $1$ 的贡献。

这里，我们可以发现，对序列用一个栈做括号匹配后，对与每个括号，都能找到一个唯一的匹配，记为 $pos_i$，特殊地，如果没有匹配，左括号的记为 $n+1$，右括号的记为 $0$。  
而一个括号要产生贡献，当且仅当区间没有包含 $pos_i$。

于是，对于每一个位置 $i$，我们都能算出它能产生贡献的区间的左右端点所属的区间，这里我们分别记为区间 $L$ 和区间 $R$。

然后我们再回头看之前的式子，我们发现，我们已经自然地完成了对 $f(l,r)$ 拆贡献的工作。也就是说，对于现在的每个 $[l,r]$ 它需要贡献的值只有 $1$ 了！

也就是说，对于同样数量级的 $[l,r]$，我们现在已经不需要考虑不同的 $[l,r]$ 之间的区别，因为它们已经没有区别了。

现在，对于每个位置 $i$，它所产生的贡献，就是所有 $l\in L$ 向左扩展的方案数，乘上所有 $r\in R$ 向右扩展的方案数。我们发现这两个值我们都可以前缀和 $O(n)$ 预处理。

至此，本题得解，时间复杂度 $O(n)$。

具体地：
$$
f_i = \sum\limits_{l=1}^{i}\binom{l-1+k-1}{k-1},~f_{[l,r]} = f_r = f_{l-1}\\
g_i = \sum\limits_{r=1}^{i}\binom{n-r+k-1}{k-1},~g_{[l,r]} = g_r = g_{l-1}
$$
$$
\begin{align*}
\begin{split}
L_i = \left\{
\begin{array}{ll}
    [1,i],       &s[i] = (\\
    [pos_i+1,i], &s[i] = )
\end{array}
\right.
\end{split}\\

\begin{split}
R_i = \left\{
\begin{array}{ll}
    [i,pos_i-1], &s[i] = (\\
    [i,n],       &s[i] = )
\end{array}
\right.
\end{split}
\end{align*}
$$
$$
\begin{align*}
ans &= \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} \binom{l-1+k-1}{k-1} \binom{n-r+k-1}{k-1} f(l,r)\\
&= \sum\limits_{i=1}^{n} \sum_{l\in L_i} \sum_{r\in R_i} \binom{l-1+k-1}{k-1} \binom{n-r+k-1}{k-1}\\
&= \sum\limits_{i=1}^{n} \sum_{l\in L_i} \binom{l-1+k-1}{k-1} \sum_{r\in R_i} \binom{n-r+k-1}{k-1}\\
&= \sum\limits_{i=1}^{n} f_{L_i} \cdot g_{R_i}\\

\end{align*}
$$

其实，在计算每一个 $i$ 的时候，我们发现它的前缀和存在更优美的计算方式，只需对组合式平行求和。  
具体地，设区间的长度为 $len$，令 $x = k-1$，则方案数为：
$$
\sum\limits_{i=0}^{len-1} \binom{i+x}{x} = \sum\limits_{i=0}^{len-1} \binom{i+x}{i} = \binom{len+x}{len-1}
$$

具体实现可以看看代码。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 9;
const int mod = 998244353;
ll n, k, x, ans;
string s; int pos[N];

// 预处理组合数，为了简洁一点就不放了
// 就是这里空间要记得 N*2
ll fac[N<<1], inv[N<<1], finv[N<<1];
inline void init(){}
inline ll C(ll n, ll m){}

inline void solve(){
    stack<int> stk;
    for(int i=1; i<=n; ++i){
        if(s[i]=='(') stk.push(i);
        else{
            if(stk.empty()) continue;
            int t = stk.top(); stk.pop();
            pos[i] = t; pos[t] = i;
        }
    }
    while(!stk.empty())
        pos[stk.top()] = n + 1,
        stk.pop();
}

inline ll f(ll len){ return C(len+x, len-1);}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    init(); cin >> n >> k >> s;
    s = ' ' + s; x = k - 1; solve();

    for(register int i=1,L,R; i<=n; ++i){
        if(s[i]=='('){
            L = 1, R = pos[i] - 1;
            (ans += f(i-L+1) * (f(n-i+1)-f(n-R)) % mod + mod) %= mod;
        }else{
            L = pos[i] + 1, R = n;
            (ans += f(R-i+1) * (f(i)-f(L-1)) % mod + mod) %= mod;
        }
    }cout << ans;
return 0;}
```

---

## 作者：Bosun (赞：3)

这道题建模非常巧妙。

突破口:做过CSP19 D1T2的应该知道，一个子串的0级偏值就是这个子串中**没有匹配的括号数**（废话）

因为一个括号在整个串中最多只有一个括号能与之匹配，所以记录与右括号 $i$ 匹配的左括号位置为 $a_i$

先求1级偏值：考虑逆向思考，即计算每对 $[a_i,i]$ 中有多少对区间只包含 $a_i,i$ 中的一个,这个可以用数学方法求出来:  $Ans=(i-a_i) \times(n-(i-a_i)+1)$

接下来是这道题最巧妙的地方，如果一个位置能对第k层区间产生贡献，相当于向左跳$k+1$步，向右跳$k+1$步不能超出边界。这个方案数即为$C(n+k,k)$。

还存在一个问题，向左/向右的第一步不能超出$[a_i,i)$或$(a_i,i]$。这可以用前缀和把组合数预处理出来。

又臭又长的代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
int n,k;
char s[N];
int q[N],tot,a[N],vis[N];
typedef long long ll;
const ll mod=998244353;
ll f[N],f2[N],fac[N],sum[N];
ll pw(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1)res=(res*x)%mod;
		x=(x*x)%mod;
		y>>=1; 
	}
	return res;
}
int main(){
	cin>>n>>k;
	int i,j;
	scanf("%s",s+1);
	for(i=1;i<=n;i++){
		if(s[i]=='('){
			q[++tot]=i;
		}else {
			if(tot>0)vis[i]=vis[q[tot]]=1,a[i]=q[tot--];
			else a[i]=i;
		}
	}
	ll ans=0;
	fac[0]=1;
	for(i=1;i<=n+k;i++){
		fac[i]=(fac[i-1]*i)%mod;
	}
	f[0]=1,f2[0]=1;
	for(i=1;i<=n;i++){
		f[i]=fac[i+k-1]*pw(fac[i]*fac[k-1]%mod,mod-2)%mod;
		f2[i]=fac[i+k]*pw(fac[i]*fac[k]%mod,mod-2)%mod;
	}
	sum[0]=1;
	for(i=1;i<=n;i++)sum[i]=(sum[i-1]+f[i])%mod;
	for(i=1;i<=n;i++){
		if(vis[i]==0){
			ans=(ans+f2[i-1]*f2[n-i]%mod)%mod;
		}else{
			if(s[i]==')'){
				ans=(ans+(sum[n-a[i]]-sum[n-i]+mod)%mod*f2[a[i]-1]%mod)%mod;
				ans=(ans+(sum[i-1]-sum[a[i]-1]+mod)%mod*f2[n-i]%mod)%mod;
			}
		}
	}	
	cout<<ans<<endl;
	return 0;	
}
```


---

## 作者：Imerance1018 (赞：2)

为了讲解方便，约定：若 $y <0$，则 $\dbinom{x}{y}=0$。


### Description

[传送门](https://www.luogu.com.cn/problem/P7044)

### Solution

定义 $pos_i$ 使得 $s_i$ 刚好与 $s_{pos_i}$ 匹配上。可以使用一个栈求出 $pos_i$。

当然，如果 $s_i$ 是左括号，且没有右括号匹配，那么 $pos_i=n+1$。反之，如果 $s_i$ 是右括号，且没有左括号匹配，那么 $pos_i=0$。

然后我们来看 $k=1$ 的情况。考虑拆贡献，发现如果 $s_i$ 是左括号，那么 $s_i$ 会对所有满足 $1 \le l \le s_i \le r < pos_i$ 的二元组 $(l,r)$ 产生 1 的贡献。

反之，如果 $s_i$ 是右括号，那么 $s_i$ 会对所有满足 $pos_i < l \le i \le r \le n$ 的二元组 $(l,r)$ 产生 1 的贡献。

我们可以推广一下：当 $k \ge 1$ 时，如果 $s_i$ 是左括号，那么 $s_i$ 会对所有满足 $1 \le l_1 \le l_2 \le \ldots \le l_k \le i \le r_1 \le r_2 \le \ldots \le r_k \le n$ 且 $r_1 < pos_i$ 的两个序列 $l_k$ 和 $r_k$ 产生 1 的贡献。（事实上这个 1 是被加到左端点为 $l_1$，右端点为 $r_k$ 的字串的答案里去的）

反之，如果 $s_i$ 是右括号，那么 $s_i$ 会对所有满足 $1 \le l_1 \le l_2 \le \ldots \le l_k \le i \le r_1 \le r_2 \le \ldots \le r_k \le n$ 且 $l_k > pos_i$ 的两个序列 $l_k$ 和 $r_k$ 产生 1 的贡献。

所以我们就将问题转化成了：对于每个 $s_i$ 求出满足上述条件的两个序列的个数。

那么如果 $s_i$ 是左括号，序列 $l_k$ 的个数就相当于从 $i$ 个数中取 $k$ 个且可相同的方案数，即把 $k$ 个相同的球放进 $i$ 个不同的盒子且允许空盒的方案数，由插板法可得答案为 $\dbinom{k+i-1}{i-1}$。

如果 $pos_i \neq n+1$，序列 $r_k$ 由于要满足 $r_1 < pos_i$，可以使用“正难则反”的思想。不考虑这个限制的方案数相当于 $k$ 个球放进 $n-i+1$ 个盒子且允许空盒，为 $\dbinom{k+n-i}{n-i}$，满足 $r_1 \ge pos_i$ 的方案数相当于 $k$ 个球放进 $n-pos_i+1$ 个盒子且允许空盒，为 $\dbinom{k+n-pos_i}{n-pos_i}$。所以序列 $r_k$ 的个数为 $\dbinom{k+n-i}{n-i}-\dbinom{k+n-pos_i}{n-pos_i}$。

当然，如果 $pos_i =n+1$，那么限制条件不存在，$r_k$
的个数即为 $\dbinom{k+n-i}{n-i}$，由于开头的约定，依然成立。

由乘法原理，$s_i$ 的总贡献为 $\dbinom{k+i-1}{i-1} \times (\dbinom{k+n-i}{n-i}-\dbinom{k+n-pos_i}{n-pos_i})$。

同样，如果 $s_i$ 为右括号，贡献就是 $\dbinom{k+n-i}{n-i} \times (\dbinom{k+i-1}{i-1}-\dbinom{k+pos_i-1}{pos_i-1})$。

预处理组合数，时间复杂度 $O(n)$。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=998244353;
int n,k,pos[N],st[N],top,ans;
string s;
int fac[N*2],inv[N*2];//小心RE
void init()
{
	fac[0]=fac[1]=inv[1]=1;
	for(int i=2;i<=2e6;i++)
	{
		fac[i]=fac[i-1]*i%mod;
		inv[i]=(mod-inv[mod%i]*(mod/i)%mod)%mod;
	}
	inv[0]=1;
	for(int i=1;i<=2e6;i++)inv[i]=inv[i]*inv[i-1]%mod; 
}
int C(int n,int m)
{
	if(n<0||m<0||m>n)return 0;//约定
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
signed main()
{
	init();
	cin>>n>>k>>s;
	s='*'+s;
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='(')pos[i]=n+1;
		else pos[i]=0;
		if(s[i]=='(')
			st[++top]=i;
		else if(top)
		{
			pos[st[top]]=i;
			pos[i]=st[top];
			top--;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='(')ans=(ans+C(k+i-1,i-1)*(C(k+n-i,n-i)-C(k+n-pos[i],n-pos[i])+mod)%mod)%mod;
		else ans=(ans+C(k+n-i,n-i)*(C(k+i-1,i-1)-C(k+pos[i]-1,pos[i]-1)+mod)%mod)%mod;
	}
	cout<<ans;
	return 0;
}
``````

---

## 作者：elbissoPtImaerD (赞：2)

优雅计数。

首先刻画 $0$ 级偏值的，其实质是求失配括号数。

再考虑 $k$ 次迭代的意义，考虑对一个区间 $[l,r]$ 计算其贡献系数，显然是在 $l$ 左边放 $k-1$ 个左端点，$r$ 右边放 $k-1$ 个右端点，这是两个组合数，用乘法原理合并，由此容易得到一个，枚举 $l$，扫 $r$ 的平方做法。

用扫描线优化没有什么前途，尝试重新拆贡献，考虑一个括号作为失配括号的贡献系数。

不妨考虑括号 $i$，其为左括号，考虑最小的 $j$ 使 $[i,j]$ 为合法括号串（若不存在则令 $j=n+1$），那么 $i$ 的贡献区间就是在 $i$ 左边放 $k$ 个左端点，$[i,j)$ 中放至少一个右端点，$i$ 右边共放 $k$ 个右端点。$i$ 左边是一个组合数，$i$ 右边可以写成总数减去不合法的容斥型，是两个组合数相减。由此得到一个简单线性做法。

细节看代码。

```cpp
namespace BF
{
  il Mi Solve(int n,int k,string&s)
  {
    Mi ans=0;
    for(int l=0;l<n;++l) {
      int cnt=0,res=0;
      for(int r=l;r<n;++r) { // [0,l) & [l,r] & (r,n)
        if(s[r]=='(') ++cnt;
        else {
          if(!cnt) ++res;
          else --cnt;
        }
        ans+=Z.C(l+k-1,k-1)*(res+cnt)*Z.C(n-r-1+k-1,k-1);
      }
    }
    return ans;
  }
}
il void Solve()
{
  int n,k;rd(n),rd(k);
  string s;rd(s);
  // wrt(BF::Solve(n,k,s),'\n');
  stack<int>S;
  Mi ans=0;
  const auto F=[&](int x){return Z.C(x+k-1,k);};
  for(int i=0;i<n;++i) {
    if(s[i]=='(') S.ep(i);
    else if(S.size()) {
      int j=S.top();
      S.pop();
      // [0,j], [j,i), [i,n)
      ans+=F(j+1)*(F(n-j)-F(n-i));
    }
  }
  for(;S.size();S.pop()) {
    int j=S.top(),i=n;
    ans+=F(j+1)*(F(n-j)-F(n-i));
  }
  for(int i=n-1;~i;--i) {
    if(s[i]==')') S.ep(i);
    else if(S.size()) {
      int j=S.top();
      S.pop();
      // [0,i], (i,j], [j,n)
      ans+=F(n-j)*(F(j+1)-F(i+1));
    }
  }
  for(;S.size();S.pop()) {
    int j=S.top(),i=-1;
    ans+=F(n-j)*(F(j+1)-F(i+1));
  }
  wrt(ans,'\n');
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/158960451)

---

## 作者：block_in_mc (赞：1)

首先考虑如何求出一个括号序列的 $0$ 级偏值。不难发现，若我们对这个序列进行括号匹配，即为无法匹配的括号的个数（发现右括号时栈为空或匹配结束后栈内剩余的左括号）。

这启发我们，对于下标 $i$ 上的左括号，若其对应的括号为 $j$（没有则为 $n+1$），只有当一个区间左端点位于 $[1,l]$ 中，右端点位于 $[l,r)$ 中时，这一对括号才不会在区间中被完整匹配，因此会对这个区间的 $0$ 级偏值造成 $1$ 的贡献。

现在引申至 $K$ 级偏值，考虑其结构：即为从 $[1,i]$ 中选出 $K$ 个不上升的左端点，从 $[i,N]$ 中选出 $K$ 个不下降的右端点，且其中的第一项要小于 $j$。子区间由这 $K$ 对左右端点组成。对于每一个符合条件的方案，该左括号都会造成 $1$ 的贡献。

现在只需要求出方案数即可。对于前半部分，可以转化为将 $k$ 个相同的小球放入 $i$ 个不同的盒子，编号为 $1,2,\cdots,i$，将每个小球所在的盒子编号排序后得到对应方案；对于后半部分，考虑容斥，即为总方案数减去第一个数不小于 $j$ 的方案数，求的方法类似于前半部分。总的方案数即为：

$${K+i-1\choose i-1}\left[{K+N-i\choose N-i}-{K+N-j\choose N-j}\right]$$

对于下标为 $i$ 的右括号，将其对称过来考虑为下标为 $n-i+1$ 的左括号即可，其所对应的左括号也要对称过来。

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 998244353;
ll n, k, vl[2001000], inv[2001000], pos[1001000];
string s;
ll fpow(ll a, ll b) {
	if (b == 0) return 1;
	ll tmp = fpow(a, b / 2);
	if (b % 2 == 0) return tmp * tmp % P;
	return tmp * tmp % P * a % P;
}
ll c(ll a, ll b) {
	return vl[a] * inv[a - b] % P * inv[b] % P;
}
int main() {
	vl[0] = inv[0] = 1;
	for (int i = 1; i <= 2000000; i++) {
		vl[i] = vl[i - 1] * i % P;
		inv[i] = fpow(vl[i], P - 2);
	}
	cin >> n >> k >> s;
	s = " " + s;
	stack<int> st;
	for (int i = 1; i <= n; i++) {
		if (s[i] == '(') st.push(i);
		else if (st.empty()) pos[i] = 0;
		else pos[st.top()] = i, pos[i] = st.top(), st.pop();
	}
	while (!st.empty()) {
		pos[st.top()] = n + 1;
		st.pop();
	}
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		int l = i, r = pos[i];
		if (s[i] == ')') l = n - l + 1, r = n - r + 1;
		ans = ((ans + c(k + l - 1, l - 1) * (c(k + n - l, n - l) - c(k + n - r, n - r))) % P + P) % P;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：伊地知虹夏 (赞：1)

## Step 1

考虑我们如何去求 $K = 1$ 时的答案。

我们发现直接求是 $O(n^2)$ 的，考虑对每个位置算贡献。

具体的讲，如果 $s_i$ 为左括号，它所匹配的右括号为 $s_j$。

考虑没有合法的括号串，它的左端点在 $i$ 的左边，右端点在 $[i,j]$ 之间。

那么 $s_i$ 的贡献为：$i \times (j - i)$。

右括号同理。

## 	Step 2

考虑 $s_i$ 的贡献如何推广至 $K > 1$ 时的情况。

$K$ 每 $+1$，区间左端点可以移动一步，贡献就会多算一次，右端点同理，只不过限制了一下不会超出 $j$。

那么 $s_i$ 的贡献可以理解为：

$$ {K + i - 1 \choose i - 1} \times ({K + n - i \choose n - i} - {K + n-j\choose n-j})$$

那么就做完了。

---

## 作者：chenxinyang2006 (赞：0)

分享一个扫描线的做法，也就是在 $l$ 处计算所有 $[l,r]$ 的贡献。

----------

先考虑 $k = 1$ 的情况，也就是求所有子串的偏值。
  
先计算出这个子串的前缀和，那么合法子串有两个条件 $\min(a_i) = 0,a_n = 0$。
  
考虑加入一个括号和删除一个括号的影响，实际上就是给一个后缀加 $1$ 或减 $1$，但是你插入一个括号后，新产生的 $a_i$ 可能会是负数。
  
为了使所有 $a_i$ 非负，需要插入一些左括号，而在序列中间插入左括号的效果实际上是和在最左边插入是一样的，因为你在保证了 $a_i$ 非负后只关心 $a_n$ 的值，而无论在哪里插入，$a_n$ 每插入一个括号都会 $+1$，除非你在最右边插入，但这没有意义。
  
保证所有 $a_i$ 非负后，需要让 $a_n = 0$，也就是在序列中插入一些右括号，同理也可以发现在最右边插入的效果和在序列中间插入等价，甚至在最右边插入可以保证新产生的 $a_i$ 非负。
  
那么这个序列的偏值实际上就是：如果 $\min(a_i) < 0$，那么为 $-\min(a_i) + a_n - \min(a_i)$，也就是 $a_n - 2\min(a_i)$，如果 $\min(a_i) \ge 0$，那么为 $a_n$。
  
考虑把问题搬回括号串 $S$，然后计算这个括号串的前缀和。
  
这样对于区间 $[l,r]$，相当于计算 $a_i - a_{l - 1},l \le i \le r$ 形成的子序列的答案，重新写一下式子：
  
- $\min(a_i) < a_{l - 1}$，答案为 $-2(\min(a_i) - a_{l - 1}) + a_r - a_{l - 1}$，也就是 $a_{l - 1} + a_r - 2\min(a_i)$
  
- $\min(a_i) \ge a_{l - 1}$，答案为 $a_r - a_{l - 1}$
  
注意到这些都与 $l$ 比较有关，于是 $l$ 从 $n$ 到 $1$ 扫描维护，因为 $\min(a_i)$ 随着 $r$ 递增而不增，所以 $\min(a_i)$ 会形成一些值相同的连续段。
  
每次 $a_l$ 加入后，删去值 $\ge a_i$ 的连续段，然后加入这个新的连续段即可维护。
  
然后就是计算贡献的问题，先二分找到 $\min(a_i) \ge a_{l - 1}$ 的部分和剩余部分。
  
- $\min(a_i) \ge a_{l - 1}$，$a_r$ 可以前缀和算，$-a_{l - 1}$ 直接乘上长度即可
  
- $\min(a_i) < a_{l - 1}$，前面两个一样，后面那个考虑在维护连续段的时候，顺便维护 $\min(a_i)$ 的后缀和
  
那么 $k = 1$ 的就做完了。
  
对于 $k$ 任意情况，考虑每个区间被包含的次数，也就是说左端点从 $1$ 移动 $k$ 步移动到 $l$ 的方案数 $\times$ 右端点从 $n$ 移动 $k$ 步移动到 $r$ 的方案数。
  
实际上就是算将 $n$ 拆成 $k$ 个自然数的方案数，由组合数学知识可知，是 $\dbinom{n + k - 1}{k - 1}$。
  
所以式子两边都要乘上 $\dbinom{l + k - 2}{k - 1} \times \dbinom{n - r + k - 1}{k - 1}$，因为扫描维护 $l$，所以只需要给所有项乘上右边那个值。

乘上权值后计算贡献的方法和以前一样，只是比较麻烦。

其实不用二分貌似也可以通过在 $i$ 处计算 $i + 1$ 处贡献之类的操作在 $O(n)$ 内解决，但是这个做法已经够复杂了，估计改进了会非常难写。

```cpp
#include <cstdio>
#include <vector>
using namespace std;
#define ll long long
#define mod 998244353
int n,k;
char str[1000005];
ll a[1000005];
ll fact[2000005],pre[1000005],sum[1000005];

ll power(ll n,ll k){
	ll ans = 1;
	while(k){
		if(k % 2 == 1) ans = ans * n % mod;
		n = n * n % mod;
		k /= 2;
	}
	return ans;
}

ll C(ll n,ll m){
	return fact[n] * power(fact[m],mod - 2) % mod * power(fact[n - m],mod - 2) % mod;
}
vector <int> s,v;//s 是一个单调递增栈,v 是这个单调递增栈中,min * 权值的前缀和

int main(){
	fact[0] = 1;
	for(int i = 1;i <= 2000000;i++) fact[i] = fact[i - 1] * i % mod;
    scanf("%d%d",&n,&k);
    scanf("%s",str + 1);
    for(int i = 1;i <= n;i++){
    	if(str[i] == '(') a[i] = a[i - 1] + 1;
    	else a[i] = a[i - 1] - 1;
    	sum[i] = (sum[i - 1] + C(n - i + k - 1,k - 1)) % mod;//sum 记录的是每个 i 权值的前缀和
    	pre[i] = (pre[i - 1] + a[i] * C(n - i + k - 1,k - 1)) % mod;//pre 记录的是 i 权值 * a[i] 的前缀和
    }
    ll ans = 0,tmp = 0;
    for(int i = n;i >= 1;i--){
        while(!s.empty() && a[s.back()] >= a[i]){
        	s.pop_back();
        	v.pop_back();
        }
        if(s.size()) v.push_back((v.back() + a[i] * (sum[s.back() - 1] - sum[i - 1])) % mod);
        else v.push_back(a[i] * (sum[n] - sum[i - 1]) % mod);
        
        s.push_back(i);

        tmp = pre[n] - pre[i - 1];//a[r] 部分
        if(a[s[0]] < a[i - 1]){
        	int x = 0;
        	for(int j = 19;j >= 0;j--) if(x + (1 << j) < s.size() && a[s[x + (1 << j)]] < a[i - 1]) x += 1 << j;
            tmp -= 2 * v[x];//min 部分
            x = s[x];
        	tmp += (sum[n] - sum[x - 1]) * a[i - 1] % mod;//a[l - 1] 部分
            tmp -= (sum[x - 1] - sum[i - 1]) * a[i - 1] % mod;
        }else{
        	tmp -= a[i - 1] * (sum[n] - sum[i - 1]) % mod;//只有 a[l - 1] 部分
        }
        tmp %= mod;
        ans += tmp * C(i + k - 2,k - 1) % mod;
        ans %= mod;
    }
    printf("%lld\n",(ans + mod) % mod);
	return 0;
}
```


---


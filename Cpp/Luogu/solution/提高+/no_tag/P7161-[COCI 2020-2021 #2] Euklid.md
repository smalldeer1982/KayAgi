# [COCI 2020/2021 #2] Euklid

## 题目描述

对于正整数 $a, b$，定义 $R(a, b)$ 为：  

 $\begin{cases}R(b,a)&a<b\\R\left(\left\lfloor\dfrac{a}{b}\right\rfloor,b\right)&1<b\leq a\\a&1=b\leq a\end{cases}$
 
给定正整数 $g, h$，求正整数 $a, b$ 使得 $\gcd(a,b)=g$，$R(a,b)=h$。

## 说明/提示

**【样例解释 #1】**

$\gcd(99,23)=1$，$R(99,23)=4$

**【数据范围】**

对于 $100\%$ 的数据，$1 \leq g \leq 200,000$，$2 \leq h \leq 200,000$。

Subtask #1（$4$ pts）：$g=h$。  
Subtask #2（$7$ pts）：$h=2$。  
Subtask #3（$7$ pts）：$g=h^2$。  
Subtask #4（$14$ pts）：$g,h \leq 20$。  
Subtask #5（$36$ pts）：$g,h \leq 2000$。  
Subtask #6（$32$ pts）：无附加约束。

**【说明】**

译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 2 C Euklid](https://hsin.hr/coci/contest2_tasks.pdf)。

## 样例 #1

### 输入

```
1
1 4```

### 输出

```
99 23```

## 样例 #2

### 输入

```
2
3 2
5 5```

### 输出

```
9 39
5 5```

# 题解

## 作者：Mihari (赞：9)

# 壹、[题目描述](https://hsin.hr/coci/contest2_tasks.pdf) &para;

定义函数
$$
R(a,b)=
\begin{cases}
R(b,a) &a<b \\
R(\lfloor{a\over b}\rfloor,b)&a\ge b>1 \\
a&b=1
\end{cases}
$$
给定 $g,h$，请找到 $a,b$ 使得 $\gcd(a,b)=g∧R(a,b)=h$. 保证 $g,h\le 200000$，可以证明，存在 $a,b\le 10^{18}$ 的解。

# 贰、[题解](https://www.cnblogs.com/Arextre/p/14903404.html) &para;

显然一道构造题，但是挺难想到。下面我们不妨假设 $a\ge b$.

首先想到的就是去考察 $R$ 的性质，如果你打表，你会发现......不，你什么都发现不了。

但是我们可以利用**人类智慧**，首先一定有 $R(h,h^k)=h$，更一般地，有 $R(h,h^k+r)=h$，我们只需要保证 $r<h^k$ 即可。

也即，有 $R(h,x)=h\Big(x\in [h^k,2h^k)\Big)$，如果我们不考虑 $\gcd$ 的限制，那么我们可以直接构造 $a=h^k,b=h$，但是像这样由一边除到尽头，我们始终需要强制让一边为 $h$，如 $b=h$，而此时我们是万般不能让 $\gcd(a,b)=g$ 的（除了可能存在的一些特殊情况）。所以，这种 “一边除到底” 好是好，但是不能满足所有条件。

但是我们可以考虑，当 $a/b$ 完之后，得到 $a'=h$，然后我们面对的是 $R(a',b)=R(h,b)$，然后用 $h$ 将 $b$ 除成 $1$，这个时候，$a=h\times b^j+r(r<b^j)$，且 $b\in[h^k,2h^k)$，并且得构造出 $\gcd(a,b)=g$.

根据辗转相除法，我们有
$$
\gcd(a,b)=g 
\Rightarrow gcd(h\times b^j+r,b)=\gcd(r,b)=g
$$
如果设 $b=gh$，考虑最简单的情况，$r=g∧j=1\Rightarrow a=h^2g+g=g(h^2+1)$，我们一定能够保证 $\gcd(h,h^2+1)=1$，这样似乎合法？

然后，你会发现你错了，举个栗子：当 $g=2,h=3$ 时，我们可以构造出 $a=20,b=6$，但是 $R(20,6)=2$，那么问题出在哪里？我们还有个前提条件是 $gh\in [h^k,2h^k)\Rightarrow g\in[h^{k-1},2h^{k-1})$，得保证这个，我们才能构造出正确的答案。

也就是说，如果 $g$ 给得不够好，就没有答案咯？那为什么题目 “可以证明” 存在 $a,b\le 10^{18}$？事实上，$b=gh$ 只是我猜测的其中一种情况，$b$ 不一定一定就是 $gh$，我们可以记 $b=gi$，保证 $b=gi\in [h^k,2h^k)$ 即可，即，$g\in\left[{h^k\over i},{2h^k\over i}\right)$ 即可。

至于如何找到这个 $i$，由于我们有
$$
h^k\le gi<2h^k
\Rightarrow {h^k\over g}\le i<{2h^k\over g}
$$
因为这个 $i$ 是个整数，我们只需要找到一个 $k$，满足区间 $\left[{h^k\over g},{2h^k\over g}\right)$ 包含**至少一个整数**即可，一个一定满足条件的不等式是
$$
{h^k\over g}+1<{2h^k\over g}
\Rightarrow g<h^k
$$
只需要找到这个 $k$ 就可以了，取 $i=\left\lceil{h^k\over g}\right\rceil$，而 $a=h\times b+g$.

但是值得注意的是，直接取 $i=\left\lceil{h^k\over g}\right\rceil$ 的同时，我们一定有 $i>1$，因为 $g<h^k$，但是至于为什么必须保证 $i>1$ 呢？因为我们的 $a=h\times b^j+r(r<b^j)$，在此我们取 $j=1$，则需保证 $r=g<b=gi$，显然，当 $i=1$ 时不等式不成立，但是我们取上取整保证了 $i>1$.

总复杂度 $\mathcal O(T\log_hg)$.

>题解过于简单，直接给出构造方法：
>$$
>b=g\left\lceil{h^K\over g}\right\rceil,a=hb+g\quad(g<h^K)
>$$
>我只能说，这个构造方法没有时间还真想不到，或许只有 $\sf SYDevil$ 和 $\sf OID$ 可以直接出吧？

# 叁、参考代码 &para;

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;

// #define NDEBUG
#include<cassert>

namespace Elaina{
    #define rep(i, l, r) for(int i=(l), i##_end_=(r); i<=i##_end_; ++i)
    #define drep(i, l, r) for(int i=(l), i##_end_=(r); i>=i##_end_; --i)
    #define fi first
    #define se second
    #define mp(a, b) make_pair(a, b)
    #define Endl putchar('\n')
    #define mmset(a, b) memset(a, b, sizeof a)
    // #define int long long
    typedef long long ll;
    typedef unsigned long long ull;
    typedef pair<int, int> pii;
    typedef pair<ll, ll> pll;
    template<class T>inline T fab(T x){ return x<0? -x: x; }
    template<class T>inline void getmin(T& x, const T rhs){ x=min(x, rhs); }
    template<class T>inline void getmax(T& x, const T rhs){ x=max(x, rhs); }
    template<class T>inline T readin(T x){
        x=0; int f=0; char c;
        while((c=getchar())<'0' || '9'<c) if(c=='-') f=1;
        for(x=(c^48); '0'<=(c=getchar()) && c<='9'; x=(x<<1)+(x<<3)+(c^48));
        return f? -x: x;
    }
    template<class T>inline void writc(T x, char s='\n'){
        static int fwri_sta[1005], fwri_ed=0;
        if(x<0) putchar('-'), x=-x;
        do fwri_sta[++fwri_ed]=x%10, x/=10; while(x);
        while(putchar(fwri_sta[fwri_ed--]^48), fwri_ed);
        putchar(s);
    }
}
using namespace Elaina;

ull R(ull a, ull b){
    if(a<b) return R(b, a);
    if(b==1) return a;
    return R(a/b, b);
}
ull gcd(ull a, ull b){ return b? gcd(b, a%b): a; }

ull g, h, k, tmp, i, a, b;

signed main(){
    freopen("euklid.in", "r", stdin);
    freopen("euklid.out", "w", stdout);
    rep(_, 1, readin(1)){
        g=readin(1llu), h=readin(1llu);
        tmp=1, k=0;
        while(g>=tmp) ++k, tmp*=h;
        // When x,y are integers the equation ceil(x/y)=(x+y-1)/y is established
        i=(tmp+g-1)/g, b=g*i, a=h*b+g;
        writc(a, ' '), writc(b);
    }
    return 0;
}
```


---

## 作者：novax (赞：4)

[题面](https://www.luogu.com.cn/problem/P7161)。



#### 思路

首先 $\gcd(a,b)=g$，那 $a,b$ 肯定都得是 $g$ 的倍数。

设 $a=xg,b=yg$，$x<y$ 且 $x$ 与 $y$ 互质。我们求出 $x,y$ 的值就可以了。

题目中的 $R$ 是个新定义的函数，那就先来研究一下它的性质。

有 $R(i,j)=R(\lfloor \frac{j}{i}\rfloor,i)$。

$R(a,b)=h$，那么递归的最后一层是 $R(h,1)$。

倒数第二层应该是 $R([h,2h),h)$，再往上是 $R(h,[h^2,2h^2))$。

所以对于任意正整数 $i$，都有 $R(h,[h^i,2h^i))=h$。

结合以上两点：$R(a,b)=R(xg,yg)=R(\lfloor \frac{y}{x}\rfloor,xg)$。

我们想得到一个最小的可行解，所以考虑最小的可行 $x$ 怎么求。

$x \in [\lfloor \frac{h^i}{g}\rfloor , \lfloor \frac{2h^i}{g}\rfloor)$，想要最小解，那就让 $x= \lceil \frac{k^i}{g} \rceil$ 就好。

至于 $y$，它需要满足 $\lfloor \frac{y}{x}\rfloor=h$ 且与 $x$ 互质。满足条件的 $y$ 可以是 $x\times h+1$。

注意：$x$ 不能为 $1$。

#### 代码

```cpp
#include <cstdio>
long long T,G,H,A,B;
void solve(long long g,long long h)
{
	long long now=1;
	while(now<=g)
		now*=h;
	A=(now-1)/G+1;
	B=A*h+1;
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&G,&H);
		solve(G,H);
		printf("%lld %lld\n",A*G,B*G);
	}
}
```


---

## 作者：Haphyxlos (赞：2)

# P7161 [COCI2020-2021#2] Euklid
[题目传送门](https://www.luogu.com.cn/problem/P7161)

## 前言
注：感谢zps神仙的帮助QwQ

[可能更好的阅读体验](https://www.luogu.com.cn/blog/haphyxlos/ti-xie-p7161-coci2020-20212-euklid)

## Sol

首先，我们不妨假设，$x,y$ 为本题答案，即 $x=ag,y=bg$ 。

$\because\gcd(x, y)=g$ 

那么，我们把 $x,y$ 都约掉一个 $g$ ，就剩下了 $a,b$ 。

$\therefore \gcd(a, b)=1$

由题意， $R(x,y)=h $ 

那么，我们在这里假设 $a<b$ 。

我们根据 $R$ 的定义，可以将它变形：

$R(x,y)=R(ag,bg)=R( \left \lfloor \frac{bg}{ag}  \right \rfloor ,ag)=
R( \left \lfloor \frac{b}{a}  \right \rfloor ,ag)$

又  $\because R(x, y)=h$

那么，我们根据定义逆推，可得，上一次肯定为 $R(h,1)$ 。

再上一次，是 $R(h,x) $ 使得 $ \left \lfloor  \frac{x}{h}  \right \rfloor =h$ 。

那么，显然此时 $x\in \left [ h^{2} ,2h^{2} \right ) $ ，即 $R(h,1)=R(h,\left [ h^{2} ,2h^{2} \right ))$ 。

易得，$R(h,1)=R(h,\left [ h^{2} ,2h^{2} \right ))=R(h,\left [ h^{3} ,2h^{3} \right ))=\cdots =R(h,\left [ h^{i} ,2h^{i} \right ))$

$\therefore x\in \left [ h^{i} ,2h^{i} \right ) $ ，即 $ag\in \left [ h^{i} ,2h^{i} \right )$ 。

又 $\because$ 我们变形出来，$R(x,y)=
R( \left \lfloor \frac{b}{a}  \right \rfloor ,ag)$ 。

$ \therefore $ 综上所述，$R(x,y)=
R( \left \lfloor \frac{b}{a}  \right \rfloor ,ag)$ 且 $ag\in \left [ h^{i} ,2h^{i} \right )$ 。

那么，本题就好做了，我们只要先把 $a$ 确定，而 $a$ 要满足  $ag\in \left [ h^{i} ,2h^{i} \right )$ ，这个长度的范围为 $h^{i}$ 。

如果，我们令范围的长度大于 $g$ ，那么就一定有解了。（连续 $g$ 个数里一定存在 $g$ 的倍数，显然）

然后，我们只要先找一个 $i$ ，使得 $h^{i}>g$ ，然后在里面随便找找就能找到一个 $g$ 的倍数，我们把这个 $g$ 的倍数除以 $g$ 就可以得到 $a$ 。

接着，我们把 $b$ 确定。

$\because \left \lfloor  \frac{b}{a}  \right \rfloor =h$ 

$\therefore b=ah+k , k \in \left [0 ,a \right) $

试一遍就行了，看看哪个互质。

代码就不放了，请读者自行完成吧。

zps：这数据好逊啊，建议出到 $ 1\le T \le 10^{6} , 1 \le g \le 10^{9} ,2\le h\le 10^{9} $ 。

---

## 作者：lss_ak_gcd (赞：0)

由 $\gcd(a,b)=g$ 可知 $a=p_1g$，$b=p_2g$，且有 $\gcd(p_1,p_2)=1$。根据打表可以得到对于任意一个在 $p^k$ 和 $2\times p^k-1$（闭区间）之间的整数 $l$，都有 $R(p,l)=p$。证明显然。

所以说，为了求出任意一组可行解，只需要构造 $p_1\in[\lfloor\frac{h^i}{g}\rfloor,\lfloor\frac{h^i}{g}\rfloor\times2-1]$，$\lfloor\frac{p_2}{p_1}\rfloor=h$ 且 $\gcd(p_1,p_2)=1$ 即可。为了方便且满足 $10^{18}$ 范围内的条件，这里取 $p_1=\lfloor\frac{h^i}{g}\rfloor$，$p_2=h\times p_1+1$ 即可。然后这个蓝色的构造题就给做完了。

主要代码：

```cpp
auto slv(int g,int h,int &a,int &b)[[]]->void{
    int p=1;while(p<=g)p*=h;
    a=(p-1)/g+1,b=a*h+1;
}
```

---

## 作者：Doqe (赞：0)

## 简要题意 

有函数

$R(a,b)= \begin{cases} R(b,a) &a<b \\ R(\lfloor{a\over b}\rfloor,b)&a\ge b>1 \\ a&b=1 \end{cases}$
 
给定 $g , h$，求 $a,b$，使得 $g=\gcd(a,b),h=R(a,b)$，且 $a,b \le 10^{18}$。

## 部分分

#### 对于 $g=h$ 部分

显然有

$\gcd(g,g)=g,R(g,g)=R(\lfloor{g\over g}\rfloor,g)=R(1,g)=g=h$。

类似的，**对于 $g=h^2$，** 可以推出 $a=g^3,b=g^2$ 时符合题意。

#### 对于 $h=2$ 部分：

有 $\forall i \in \mathbf{Z^+}, R(i,2)=2$。

证明：对于 $i\leq2$，$R(i,2)=2$。

对于 $i \geq 3$，$R(2,i)=R(2,\lfloor{i\over 2}\rfloor)$，且 $i > \lfloor{i\over 2}\rfloor$。

要保证 $\gcd(a,b)=g$，只需令 $a=g\times 2,b=g$ 即可。

## 正解

**先假设 $h \le g$。**

首先可以看出 $\gcd(ka,a)=\gcd(a,a)=a , R(ka+t,a)=R(k,a)(0 \le t <a)$

所以我们可以知道：设 $b=gx,a=gxy+gt$  $(0\le t < x)$，
则 $\gcd(a,b)=\gcd(c,b)=g,R(a,b)=R(c,b)$ $(c=gt)$。

而又$h=2$部分分的证明过程可以推广得出：

$\exists  x \le n, R(x,n)=R(y,n) (y\in \mathbf{Z^+}) $。

所以我们只需要构造出 $x \le n$ 的数据，然后再通过放缩使 $\gcd(a,b)=g$ 即可。

设 $a=gx,b=gy$ $(\gcd(x,y)=1,x\ge y)$。

考虑 $y=1$ 时的情况：$\gcd(a,b)=g,R(a,b)=R(gx,g)=R(x,g)$。

这时候肯定有种想法：暴力查找符合条件的 $x$，根据上面理论的推广和函数本身，只需 $O(40n\log n)$ 的复杂度即可解决。

但这是不对的，比如 $n=10$ 时,不存在 $x$ 使得 $R(x,n)=4$。
而且找出符合条件的 $x$ 的时间也过大，不一定能过题。

于是还有一种猜想：若 $x$ 符合上述条件，$R(x,n)=x$ 必成立。但也是错的，比如 $n=100,x=7$。

那我们退而求其次，来求 $R(x,n)=x$。

可以通过多种方式得出 $x$ 的条件是 $x^k \le n < 2x^k$。其中 $x^k$ 为小于 $n$ 的 $x$ 的次幂最大值。感性理解就是如果多出了个$2$最后$R(x,n)$会化成 $R(y,x)(1 <y \le z)$。

那么如果符合上述条件，则 $x=h$，所以 $a=gx,b=g$。

**如果不符合呢？**

那么就去找 $y$，使 $x^{k+1} \le gy < 2x^{k+1}$。因为原来的 $2x^k$ 已经比 $g$ 小了，这里可以直接暴力，因为只有可能 $k \ge 2$ 时才会不符合，此时的 $x^{k+1}$ 大概在 $10^7$ 左右。

接着按照符合的方法做即可。最后得出 $a=gxy,b=gy$，为保证 $\gcd$ 等于 $g$ 令 $a=gxy+g$。

**接下来讨论 $g \le h$。**

直接将 $g$ 扩大到 $ h \le g$ 的范围后按照上述解法做即可，注意最后的 $a$ 同样要加个 $g$ 来保证 $\gcd$ 等于 $g$。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
	int t;long long g,h;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%lld",&g,&h);
		if(g==h)printf("%lld %lld\n",g,g);
		else if(g==h*h)printf("%lld %lld\n",h*h*h,h*h);
		else if(h==2)printf("%lld %lld\n",g*2,g);//部分分
		else if(h<=g)//情况1：h<=g
		{
			long long H=h,G=g;
			while(H<=g)H*=h;H/=h;
			if(H*2>g)//找到符合的x
				printf("%lld %lld\n",h*g,g);
			else//没找到，扩大g
			{
				H*=h;
				while(H*2>G)G+=g;G-=g;
				printf("%lld %lld\n",h*G+g,G);
			}
		}
		else//几乎照抄上文
		{
			long long s=0;
			while(h>=s)s+=g;s-=g;
			swap(s,g);//swap后s为原来的g，g为扩充的g
			long long H=h,G=g;
			while(H<=g)H*=h;H/=h;
			if(H*2>g)
				printf("%lld %lld\n",h*g+s,g);
			else
			{
				H*=h;
				while(H*2>G)G+=g;G-=g;
				printf("%lld %lld\n",h*G+s,G);
			}
		}
	}
	return 0;
}
```



---


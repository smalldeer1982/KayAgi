# [COCI 2020/2021 #1] Tenis

## 题目描述

你是网球比赛的组织者，一场有 $n$ 个选手的比赛就要举办了，选手编号为 $1$ 到 $n$。在赛前你测试了他们在三种场地（A 场地，B 场地，C 场地）分别的初始排名，在这场比赛中，两个人之间比赛的场数恰好为一次，也就是说总共有 $\dfrac{n \times (n-1)}{2}$ 场比赛。

比赛不会出现平局，会选择这次比赛所在的场地类型中初始排名靠前的选手获胜。你办的比赛也有一些黑幕，你就希望让你办的比赛中的获胜者能在他所更擅长的场地类型上比赛（即在他初试排名靠前的场地类型上比赛），如果有多个场地满足要求，那么选择输的那一方排名较靠前的。如果还有多个场地满足要求，选择编号小的（A $<$ B $<$ C）。

你想知道，每个场地上举行了多少场比赛，且每个人赢的场数。

## 说明/提示

#### 样例 1 解释

对于选手1和2之间的比赛，应该在2号场地进行，因为胜者（选手1）在该场地排名最好（第一位）。对于选手1和3之间的比赛，获胜者在三个场地上的排名相同，但输家在2号场地的排名更高。对于选手2和3之间的比赛，1号场地和3号场地的排名相同，因此选择索引较小的1号场地。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（35 pts）：$1 \le n \le 300$。
- Subtask 2（15 pts）：$1 \le n \le 3000$。
- Subtask 3（60 pts）：$1 \le n \le 10^5$。

**满分 $110$ 分。**

#### 说明

翻译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 1 E Tenis
](https://hsin.hr/coci/archive/2020_2021/contest1_tasks.pdf)。

## 样例 #1

### 输入

```
3
3 2 1
1 3 2
3 2 1
```

### 输出

```
1 2 0
2 0 1
```

## 样例 #2

### 输入

```
4
4 3 2 1
3 1 2 4
1 2 3 4```

### 输出

```
3 2 1
1 0 2 3```

# 题解

## 作者：Hasinon (赞：6)

# 题目大意
有 $n$ 个选手进行 $\frac{n \times (n-1)}{2}$ 场比赛，给你每个选手在 3 种场地的排名。  

每场比赛会按照以下规则选择举办场地：  
1. 优先选择能让赢家排名更高的场地（为了让比赛赢得更精彩）。
2. 如果最高赢家排名存在于多个场地，那就优先选择能让输家排名最高的场地（为了让选手输的没那么惨）。
3. 如果最高输家排名和最高赢家排名一起存在于多个场地，就选编号最小的场地（为了...好吧，只是为了让答案唯一）。  

# 解题思路
## 35pts/50pts:
按照题目所给的关系暴力搜一遍所有比赛即可，时间复杂度 $O(\frac{n \times (n-1)}{2})$。
## 100pts:
### Part 1
读完题，你突然发现明明最多有 $10^5$ 名选手，但是只有 3 个场地。这极小的场地数吸引了你的注意。  

再观察题目，发现如果 A 选手的最高排名高于 B 选手的最高排名，那么 A 选手和 B 选手的比赛一定会在 A 选手表现最好的场地举办，且 A 选手一定优胜。（只牵扯了第一条规则）  

所以我们可以先把每个选手的最高排名和最高排名所在场地记录下来，按照排名从小到大（从高到低）的顺序排序，再枚举所有选手，先枚举到的选手最高排名一定大于等于后面的选手的最高排名。

所以第 $i$ 名（这里的 $i$ 是按照排名排序后枚举时的编号，不是题目所给的编号!）选手一定会赢 $(n-i-numsame)$ 场,此选手最高排名所在的场地也会发生 $(n-i-numsame)$ 场比赛。( $numsame$ 指第 $i$ 名选手之后的选手中与第 i 名选手最高排名相等的选手数，毕竟只有大于时才是必胜）

### Part 2
当你把上面的代码敲完了，你很会很敏锐地发现，我们没有考虑最高排名相等的选手之间的比赛。 
 
这时极小的场地数又被我们所用。就 3 个场地。每一个最高排名最多存在 3 名选手。他们之间会发生 3 场比赛。

所以这些特殊比赛最多只有 $n$ 场。  

我们把这些比赛单独按照题目所给关系讨论一下就好了。

### Part 3
当你把上面的代码全敲完了，你又会很敏锐的发现，如果一个选手在多个场地同时都是最高排名。第 i 名选手一定会赢 $(n-i-numsame)$ 场。但我们怎么知道这 $(n-i-numsame)$ 场是在哪个场地发生的？  

首先，这里不能单独按照题目所给关系讨论，因为这种特殊比赛最多存在 $\frac{n \times (n-1)}{2}$ 场。但我们可以学习 Part 1,只考虑一条规则。  

我们知道，当赢家排名相等的时候，选输家排名最高的场地进行比赛。而且按照以上思路，在第 $i$ 名选手时，我们只判断 $\sum_{k=i+1}^n i-k $ 这些比赛。 （"-" 不是减号，请自行联想体育比赛中两队中间的横杠） 

这时我们开4个桶： （括号里面是程序里对应变量名）  
$t_1$(t123) 用于最高排名在 1,2,3 场地的选手的特判。  
$t_2$(t12) 用于最高排名在 1,2 场地的选手的特判。  
$t_3$(t23) 用于最高排名在 2,3 场地的选手的特判。  
$t_4$(t13) 用于最高排名在 1,3 场地的选手的特判。 

先试着用干巴巴的枯燥文字解释一下：  
枚举各选手，找到选手在各桶所包含的场地里排名尽可能高的场地 k，选手最高排名是 $high$。    
然后 ``t_i[high][k]++``。  
排名尽可能高是为了满足规则 2。  
求一遍后缀和。  
这样 ``t_i[jj+1][kk]`` 就意味着最高排名在 $k_1,k_2,...$ 场地( $t_i$ 对应的场地）且最高排名是 $jj$ 的选手。会在 $kk$ 场地赢多少场比赛。  
之后让这些桶贡献答案就行。  
一组数据为例：  ~~不然我也不知道我在解释些什么~~    

3  
1 3 2  
2 3 1  
1 3 2  

先枚举选手 1 ，将场地按照选手在场地上的排名从小到大排序。即 1,3,2。  
所以 ``t123[1][1]++;t12[1][1]++;t23[1][3]++;t13[1][1]++;``  
选手 2：``t123[1][2]++;t12[1][2]++;t23[1][2]++;t13[1][1]++;``  
选手 3：``t123[2][1]++;t12[2][1]++;t23[2][2]++;t13[2][1]++;``
      
算选手 1 的答案贡献时，就牵扯到 Part 3 了。  
我们找到他的最高排名是 $high$，同时存在于 1,3 场地，所以用桶 t13。  
令在场地 k 上举办的比赛场数是 ``cans[k]``。  
所以 $\sum_{k=1}^3$ ``cant[k]+=t13[high+1][k] ``。

上代码，尽量结合代码理解下吧： 

## CODE
```cpp
#include<bits/stdc++.h>
#define ll long long
#define G getchar()
using namespace std;
struct node{
	ll ord,num,spe;
};
ll peo[100005][4],ho[4],lo[4],cans[4],pans[100005];
node higp[100005];
bool mark[100005];
ll t123[100005][4],t12[100005][4],t23[100005][4],t13[100005][4];
node lant[4];
ll gt()
{
	ll k=0,t=1;char c=G;
	while(c<'0'||'9'<c){if(c=='-') t=-1;c=G;}
	while('0'<=c&&c<='9'){k=k*10+c-'0';c=G;}
	return k*t;
}
bool cmp(node a,node b)
{
	if(a.num<b.num||(a.num==b.num&&a.spe<b.sp)) return true;
	return false;
}
int main()
{
	ll n=gt();
	for(int i=1; i<=n; i++) 
		higp[i].num=1e9,higp[i].ord=i;
	for(register int i=1; i<=3; i++)
	{
		for(register int j=1; j<=n; j++)
		{
			ll tem=gt();
			peo[tem][i]=j;
			if(higp[tem].num>j)
			{
				mark[tem]=0;
				higp[tem].num=j;
				higp[tem].spe=i;
			}
			else if(higp[tem].num==j) mark[tem]=1;
		}
	}
	for(register int i=1; i<=n; i++) //Part 3 开始。
	{
		for(register int k=1; k<=3; k++)
		{
			lant[k].num=peo[i][k];
			lant[k].spe=k;
		}
		sort(lant+1,lant+4,cmp);
		t123[higp[i].num][higp[i].spe]++;
		ll to=1;
		while(lant[to].spe==3) to++; // 这些while是为了找桶包含的场地。
			t12[higp[i].num][lant[to].spe]++;
		to=1;
		while(lant[to].spe==1) to++;
			t23[higp[i].num][lant[to].spe]++;
		to=1;
		while(lant[to].spe==2) to++;
			t13[higp[i].num][lant[to].spe]++;
	}
	for(register int i=n; i>=1; i--)// 后缀和。
	{
		for(register int k=1; k<=3; k++)
		{
			t123[i][k]+=t123[i+1][k];
			t12[i][k]+=t12[i+1][k];
			t23[i][k]+=t23[i+1][k];
			t13[i][k]+=t13[i+1][k];
		}
	} // Part 3 半结束。
	sort(higp+1,higp+n+1,cmp);
	ll lhign,llown;
	for(register int ab=1; ab<n; ab++)
	{
		ll lab=ab;
		while(higp[lab].num<=higp[ab].num&&lab<=n) lab++;
		lab--;
		pans[higp[ab].ord]+=n-lab;
		for(int i=ab+1; i<=lab; i++) // Part 2 开始，其实可以更简洁些。
		{
			ll j=higp[i].ord;
			ll hto=0,lto=0,hign=1e9,lown=1e9;
			for(int k=1; k<=3; k++)
			{
				lhign=min(peo[higp[ab].ord][k],peo[j][k]);
				if(lhign<hign)
				{
					hto=1;
					ho[hto]=k;
					hign=lhign;
				}
				else if(lhign==hign)	ho[++hto]=k;
			}
			if(hto==1)
			{
				ll nk=ho[hto];
				cans[nk]++;
				if(peo[higp[ab].ord][nk]<peo[j][nk]) pans[higp[ab].ord]++;
				else pans[j]++;
			}
			else
			{
				for( int kk=1; kk<=hto; kk++)
				{
					ll k=ho[kk];
					llown=max(peo[higp[ab].ord][k],peo[j][k]);
					if(llown<lown)
					{
						lto=1;
						lo[lto]=k;
						lown=llown;
					}
					else if(llown==lown)	lo[++lto]=k;
				}
				ll nk=lo[1];
				cans[nk]++;
				if(peo[higp[ab].ord][nk]<peo[j][nk]) pans[higp[ab].ord]++;
				else pans[j]++;
			}
		}// Part 2 结束。
		if(!mark[higp[ab].ord]) cans[higp[ab].spe]+=n-lab;
		else // Part 3 继续。
		{
			ll nord=higp[ab].ord;
            // if 语句去找这位多最高排名场地的选手对应的情况，并使用相应桶。
			if(peo[nord][1]==peo[nord][2]&&peo[nord[2]==peo[nord][3]&&peo[nord][1]==higp[ab].num) 
			{
				for(int kk=1; kk<=3; kk++)
				{
					cans[kk]+=t123[higp[ab].num+1][kk];
				}
			}
			else if(peo[nord][1]==peo[nord][2]&&peo[nord][1]==higp[ab].num)
			{
				for(int kk=1; kk<=3; kk++)
				{
					cans[kk]+=t12[higp[ab].num+1][kk];
	
			}
			else if(peo[nord][2]==peo[nord][3]&&peo[nord][2]==higp[ab].num)
			{
				for(register int kk=1; kk<=3; kk++)
				{
					cans[kk]+=t23[higp[ab].num+1][kk];
				}
			}
			else if(peo[nord][1]==peo[nord][3]&&peo[nord][1]==higp[ab].num)
			{
				for(register int kk=1; kk<=3; kk++)
				{
					cans[kk]+=t13[higp[ab].num+1][kk];
				}
			}
		}
	}// Part 3 结束。
	for(register int i=1; i<=3; i++)
		printf("%lld ",cans[i]);
	printf("\n");
	for(register int i=1; i<=n; i++)
		printf("%lld ",pans[i]);
	return 0;
}
```






---

## 作者：DLShadow (赞：4)

### 题目大意
有 $n$ 位运动员参加比赛，两两之间比赛一场。共有三个赛区，每位参赛者在各个赛区的强弱是固定的，每场比赛所在的赛区上更强的球员会赢得比赛。需要让每场比赛的获胜者在他最强的赛区中进行，同时让输掉比赛的球员的名次尽量靠前。如果名次仍然一样，则选择编号最小的场地。

请确定这场比赛的最终结果：在每种场地上进行的比赛数量，以及每位运动员赢得的比赛场数。

### part1：暴力 50pts
直接枚举两位参赛者，算出他们在哪里比赛以及谁会胜利。

时间复杂度： $O$($n^2$)

### part2：正解 贪心 100pts
首先要明白一个事实：
#### 如果你是一个赛区的老大，你就可以让其他没有当老大的人来这里和你比赛。
而这个人在和其他的老大比赛后已经打败所有人走了，此时这个赛区的老二成为了新的老大，这时：
#### 这个新的老大可以要求剩下的人来这里和他比赛。

想到这里，我们可以把所有人动态地分成左、中、右三个集合。

左集合：已经离场的老大们，他们不需要再考虑。

中集合：现在在场的老大们，他们可以要求剩下的人和他们比赛。

右集合：剩下的人，他们即将被中集合中的人打败。

具体实现的话，按名次从高到低枚举当前的老大们是谁，把他们从右集合拿出来，直接在他们和赛区下加上右集合的人数。
再把当前中集合里面的人单独计算一下。

如果按照上面的做法激动地交上代码，那么恭喜你获得了0分的~~好~~成绩。

为什么错了呢？考虑下每次中集合中的人，发现：
#### 一个人如果既是A赛区的老大，又是B赛区的老大，那么他的对手仍有选择和他在哪里比赛的权利。
具体实现的话，把中集合的情况看成二进制状态。例如：状态 110 表示 B 和 C 两个场地老大是同一个人。事先处理好中集合的任意状态下，每个人会选择和老大在哪里比赛。在后面累计时结合状态累计就好了。

时间复杂度：$O$($n$)

### 代码：
```cpp
#include <bits/stdc++.h>
#define maxn 100005
using namespace std;
int n;
int rk[maxn][5],li[5][maxn],p[maxn][8];
long long ans1[5],ans2[maxn],num[8][5];
//rk:每个人在每个赛区的名次
//li:每个赛区中的几名是谁
//p:每个人在中集合的状态下选择在哪里比赛 
//ans1:每个场地的答案
//ans2:每个人的答案
//num:中区间每个状态下，三个赛区各应该加多少 

void init()//预处理 
{
	cin>>n; int x;
	for(int i=1;i<=n;i++) {cin>>li[1][i]; rk[li[1][i]][1]=i;}
	for(int i=1;i<=n;i++) {cin>>li[2][i]; rk[li[2][i]][2]=i;}
	for(int i=1;i<=n;i++) {cin>>li[3][i]; rk[li[3][i]][3]=i;}
	for(int i=1;i<=n;i++)
	{
		p[i][3]=(rk[i][2]<rk[i][1])?2:1;
		p[i][6]=(rk[i][3]<rk[i][2])?3:2;
		p[i][5]=(rk[i][3]<rk[i][1])?3:1;
		if(rk[i][3]<rk[i][2] && rk[i][3]<rk[i][1])
			{p[i][7]=3; continue;}
		p[i][7]=p[i][3];
	}
	for(int i=1;i<=n;i++)
	{
		num[0][1]++; num[0][2]++; num[0][3]++;
		num[3][p[i][3]]++; num[3][3]++;
		num[5][p[i][5]]++; num[5][2]++;
		num[6][p[i][6]]++; num[6][1]++;
		num[7][p[i][7]]++;
	}
}

bool vis[maxn],NEW[3],WIT[3];
//vis:每个人在不在右集合
//NEW:新进入中集合的人
//WIT:需要计算的场地 
void del(int x)//把x从右区间删除 
{
	num[0][1]--; num[0][2]--; num[0][3]--;
	num[3][p[x][3]]--; num[3][3]--;
	num[5][p[x][5]]--; num[5][2]--;
	num[6][p[x][6]]--; num[6][1]--;
	num[7][p[x][7]]--;
}

int f,s,id,a,b;
//分别是：第一，第二，场地，第一的名次，第二的名次。 
void add(int x,int y)//单独考虑x、y两个人 
{
	f=s=id=0; a=b=n+1;
	for(int i=1;i<=3;i++)
	if(min(rk[x][i],rk[y][i])<a || (min(rk[x][i],rk[y][i])==a && max(rk[x][i],rk[y][i])<b))
	{
		a=min(rk[x][i],rk[y][i]); b=max(rk[x][i],rk[y][i]); id=i;
		if(rk[x][i]<rk[y][i]) f=x,s=y; else f=y,s=x;
	}
	ans1[id]++; ans2[f]++;
}

void work()//核心代码 
{
	int a,b,c,sta;
	//a,b,c:当前的老大们
	//sta:中集合的状态 
	for(int i=1;i<=n;i++)
	{
		NEW[1]=NEW[2]=NEW[3]=0;
		a=li[1][i],b=li[2][i],c=li[3][i];
		if(!vis[a]) NEW[1]=1,vis[a]=1,del(a);
		if(!vis[b]) NEW[2]=1,vis[b]=1,del(b);
		if(!vis[c]) NEW[3]=1,vis[c]=1,del(c);
		WIT[1]=WIT[2]=WIT[3]=0; sta=0;
		if(NEW[1] && a==b && a==c) WIT[1]=WIT[2]=WIT[3]=1,sta=7;
		if(NEW[1] && a==b && a!=c) WIT[1]=WIT[2]=1,sta=3;
		if(NEW[1] && a!=b && a==c) WIT[1]=WIT[3]=1,sta=5;
		if(NEW[2] && b==c) WIT[2]=WIT[3]=1,sta=6;
		//上面的讨论没有考虑单人的情况，他们也需要考虑，在下面或起来 
		WIT[1]|=NEW[1]; WIT[2]|=NEW[2]; WIT[3]|=NEW[3];
		if(WIT[1]) ans1[1]+=num[sta][1],ans2[a]+=num[sta][1];
		if(WIT[2]) ans1[2]+=num[sta][2],ans2[b]+=num[sta][2];
		if(WIT[3]) ans1[3]+=num[sta][3],ans2[c]+=num[sta][3];
		//老大们和右集合里的人比赛 
		if(NEW[1] && NEW[2]) add(a,b);
		if(NEW[2] && NEW[3]) add(b,c);
		if(NEW[1] && NEW[3]) add(a,c);
		//中集合单独考虑 
	}
	for(int i=1;i<=3;i++) cout<<ans1[i]<<" "; cout<<endl;
	for(int i=1;i<=n;i++) cout<<ans2[i]<<" "; cout<<endl;
}

int main() {init(); work(); return 0;}
```



---

## 作者：mRXxy0o0 (赞：2)

**代码较为简短清晰的一种实现**

---
# 题意

给出三种场地中**排第几的是哪个人**（如样例一的最后一行表示第 $3$ 个人排第一），并且给出两人之间决定在哪里打的方式。求最终的比赛情况。

# 思路

对于一般的情况，两个人在三个场地的排名各不相同，那么决定的因素就是两人的最小排名是多少。据此，我们可以按每个人的最小排名排序。

观察一个排序后的数组，我们根据每个人的最小排名，把数组分成数个连续段，同一段的最小排名相等。根据题意，这个段的大小至多为 $3$。

对于不同的段 $i$，它总是可以确定这个段后面的每一个人与它比赛的情况，那么一般的情况就可以很方便的处理了。

而对于可能出现的相同最小值，根据题意，我们需要知道另一个人的具体排名。在 $i$ 时暴力枚举后面的所有人显然是不现实的。转换一下，记录 $i$ 前面不能确定的相同最小值的个数，把值相等的那些场地状压，同时分别记录对应的个数。每到一个新的人，就去解决前面遗留的问题。

对于段内，由于数量较少，可以直接暴力判断。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
int n,cnt[N];
ll ans[5],pre[10];
struct per{
	int ka,kb,kc,id;
}a[N]; 
struct node{
	int x,y,id;
}tmp[5];
inline bool cmp(node xx,node yy){//模拟题目给出的排序规则 
	if(min(xx.x,xx.y)==min(yy.x,yy.y)) return max(xx.x,xx.y)==max(yy.x,yy.y)?xx.id<yy.id:max(xx.x,xx.y)<max(yy.x,yy.y);
	return min(xx.x,xx.y)<min(yy.x,yy.y);
}
inline bool mcp(per x,per y){
	return min(x.ka,min(x.kb,x.kc))<min(y.ka,min(y.kb,y.kc));
}
int main(){
	scanf("%d",&n);
	int t;
	for(int i=1;i<=n;++i) scanf("%d",&t),a[t].ka=i;
	for(int i=1;i<=n;++i) scanf("%d",&t),a[t].kb=i;
	for(int i=1;i<=n;++i) scanf("%d",&t),a[t].kc=i,a[t].id=t;//含糊的题意 
	sort(a+1,a+1+n,mcp);
	for(int l=1,r,num;l<=n;){
		r=l,num=min(a[r].ka,min(a[r].kb,a[r].kc));
		while(r<=n&&min(a[r].ka,min(a[r].kb,a[r].kc))==num) ++r;//找段 
		for(int i=l;i<r;++i){//处理前面遗留问题 
			for(int j=1;j<8;++j){//001~111
				int mn=1e9,id=0;
				if((j&1)&&a[i].ka<mn) mn=a[i].ka,id=0;
				if((j&2)&&a[i].kb<mn) mn=a[i].kb,id=1;
				if((j&4)&&a[i].kc<mn) mn=a[i].kc,id=2;
				ans[id]+=pre[j];
			}
		}
		for(int i=l;i<r;++i){
			cnt[a[i].id]+=n-r+1;//打赢后面的 
			int st=0;
			if(a[i].ka==num) st|=1;
			if(a[i].kb==num) st|=2;
			if(a[i].kc==num) st|=4;
			++pre[st];
			for(int j=i+1;j<r;++j){//暴力判断 
				tmp[0]={a[i].ka,a[j].ka,0};
				tmp[1]={a[i].kb,a[j].kb,1};
				tmp[2]={a[i].kc,a[j].kc,2};
				sort(tmp,tmp+3,cmp);
				if(tmp[0].x<tmp[0].y) ++cnt[a[i].id];
				else ++cnt[a[j].id];
				++ans[tmp[0].id];
			}
		}
		l=r;
	}
	printf("%lld %lld %lld\n",ans[0],ans[1],ans[2]);
	for(int i=1;i<=n;++i) printf("%d ",cnt[i]);
	return 0;
}
```

**记得开 longlong。**

---

## 作者：ClearluvXL (赞：1)

# Tenis
## 思路
将球员按照最高排名排位，记作 $top$。那么 $top$ 高的和 $top$ 的低的比赛，肯定是 $top$ 高的赢，如果 $top$ 相同的话，那么我们可以暴力判断，因为 $top$ 相同的选手最多就只有 $3$ 个，因为只有三个场地嘛。

也就是说，我们能够计算出每位选手的胜场次数了。现在我们还需要计算的是，每个场地要举行多少种比赛。

现在的问题是：使得每位选手的对应排名为 $top$ 的场地不一定只有一个，这个时候就需要看后面 $top$ 小的里面对应哪个场地最大。

处理这些部分，我们可以在将这位选手的状态(在哪些场地排名最高)保存下来，在枚举到后面的选手时，判断**在对应状态下**，也就是只用在状态里的场地，这位选手此时的 $top$ 场地是哪个，这个场地的举办次数就加等于前面对应这个状态的选手的个数。

哪个产地举办比赛的次数记得开 **long long**。
## 代码
```c++
#include <bits/stdc++.h>
#define endl '\n' 

using namespace std;

const int N=1e5+10;
const int INF=0x3f3f3f3f;

typedef long long ll;
typedef pair<ll,ll> pii;

int n;

struct node{
	int id[5];
	int top;
}a[N];

bool cmp(int x,int y){
	return a[x].top<a[y].top;
}//end

ll ans[N],c[5];

void solve(int x,int y){
	int p1,p2;
	if(a[x].id[1]<a[y].id[1]) p1=x,p2=y;
	else p1=y,p2=x;
	int cot=1;
	for(int i=2;i<=3;i++){
		int win,los;
		if(a[x].id[i]<a[y].id[i]) win=x,los=y;
		else win=y,los=x;
		if(a[win].id[i]<a[p1].id[cot]){
			p1=win;
			p2=los;
			cot=i;
		}
		else if(a[win].id[i]==a[p1].id[cot]){
			if(a[los].id[i]<a[p2].id[cot]){
				p1=win;
				p2=los;
				cot=i;
			}
		}
	}
	c[cot]++;
	ans[p1]++;
}//end

int p[N];
int pre[10];

int main() {
//	freopen("tenis.in","r",stdin);
//	freopen("tenis.out","w",stdout);	
		
	ios::sync_with_stdio(0);
	
	cin>>n;
	for(int j=1;j<=3;j++){
		for(int i=1;i<=n;i++){
			int x; cin>>x;
			a[x].id[j]=i;
		}
	}
	
	for(int i=1;i<=n;i++){
		a[i].top=n+1;
		for(int j=1;j<=3;j++){
			if(a[i].top>a[i].id[j]) a[i].top=a[i].id[j];
		}
	}
	
	for(int i=1;i<=n;i++) p[i]=i;
	sort(p+1,p+n+1,cmp);
	
	for(int l=1;l<=n;l++){
		int r=l;
		while(r<n&&a[p[r+1]].top==a[p[l]].top) ++r;//找段[l,r]
		
		for(int i=l;i<=r;++i){
			int x=p[i];
			for(int j=1;j<(1<<3);++j){
				int top=n+1,id=0;
				//判断前面那些对应这个状态的选手对战 p[i]时 用哪个场地 
				if((j&1)&&a[x].id[1]<top) top=a[x].id[1],id=1;
				if((j&2)&&a[x].id[2]<top) top=a[x].id[2],id=2;
				if((j&4)&&a[x].id[3]<top) top=a[x].id[3],id=3;
				c[id]+=pre[j];
			}
		}
		for(int i=l;i<=r;++i){
			ans[p[i]]+=n-r;//打赢后面的 
			int stat=0;
			if(a[p[i]].id[1]==a[p[i]].top) stat|=(1<<0);
			if(a[p[i]].id[2]==a[p[i]].top) stat|=(1<<1);
			if(a[p[i]].id[3]==a[p[i]].top) stat|=(1<<2);
			++pre[stat];
		}
		
		for(int i=l;i<=r;i++){
			for(int j=i+1;j<=r;j++){
				solve(p[i],p[j]);//暴力判断段内 
			}
		}
		l=r;
	}
	
	for(int i=1;i<=3;i++) cout<<c[i]<<" ";
	cout<<endl;
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
	cout<<endl;
		
		
	return 0;
}//end
```

---


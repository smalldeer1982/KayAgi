# [COCI 2014/2015 #4] SABOR

## 题目描述

一片遥远的土地上有 $n$ 名议员。他们就新全民公决法修正案进行了激烈的辩论。从周一到周五，所有议员都兴高采烈地来上班，整天争论不休。一位勤奋的新闻记者每周每个工作日都会在激烈的争论中拍摄议员们在工作场所的照片。她在照片上捕捉到的是一对相互怒视的议员。五张照片已转发给你作全面分析。事实上，每个议员都属于两个政党中的一个。让我们用字母 `A` 和 `B` 来表示两个政党。你的任务是估计每个议员属于哪个政党。你需要确保每个议员最多与**两位不同的**本政党中的议员争吵。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，有 $1\le n\le 15$。
- 对于 $100\%$ 的数据，有 $1\le n\le 2\times 10^5$。

对于所有合法的 $p$，都有 $1\le p\le\dfrac{n}{2}$。

#### 说明

**题目译自 [COCI2014-2015 CONTEST #4](https://hsin.hr/coci/archive/2014_2015/contest4_tasks.pdf) _T5 SABOR_。**

感谢 @[shenyouran](https://www.luogu.com.cn/user/137367) 提供的 SPJ。

## 样例 #1

### 输入

```
7
2  1 2  7 3
2  1 3  7 4
2  1 4  7 5
2  1 5  7 6
2  1 6  7 2```

### 输出

```
ABBBBBA```

## 样例 #2

### 输入

```
10
3  1 2  7 3  9 4
3  1 3  7 4  9 5
3  1 4  7 5  9 6
3  1 5  7 6  9 8
3  1 6  7 8  9 10```

### 输出

```
ABBBBBAAAA```

# 题解

## 作者：elbissoPtImaerD (赞：4)

# 简述题意
给定一张 $|V|=n$ 的图，以及若干条边。

满足每个点的度数 $d_i\le 5$。

你需要将这张图黑白染色，满足每一个点有不多于 $2$ 个同色点与其相邻。

# 解题报告
考虑：让所有点均同色，然后逐步调整出符合题意的构造。

对于某一个点 $u$，因为 $d_u\le 5$，如果它有超过 $2$ 个同色点，那么其必有不不超过 $2$ 个异色点。  
此时将点 $u$ 变为异色就能让 $u$ 符合题意。

但是这样与 $u$ 相邻的点有可能不符合题意。

考虑将这些点作为新的 $u$ 做上述变色操作。  
这样看似复杂度爆炸，实际上复杂度是有保证的。

我们定义一条边为不合法的当且仅当这条边的两个端点同色。  
这样在初始时我们最多有 $\frac{5n}{2}$ 条不合法的边。  
而每一次变色后，不合法的边的数量最劣也会减少 $1$。
故变色操作至多进行 $\frac{5n}{2}$ 次。

复杂度 $\mathcal{O(n)}$。

$\mathcal{Code:}$
```cpp
const int N=2e5+3;
int n,cnt[N];
std::vector<int>G[N];
bool ans[N];
il void Upd(int u)
{
	ans[u]^=1;
	for(re int v:G[u])
		ans[u]^ans[v]?--cnt[u],--cnt[v]:(++cnt[u],++cnt[v]);
	for(re int v:G[u]) cnt[v]>2&&(Upd(v),7);
	return;
}
void Solve()
{
	rd(n);
	for(re int i=1,x,u,v;i<=5;++i)
		for(rd(x);x--;) rd(u),rd(v),G[u].pb(v),G[v].pb(u),++cnt[u],++cnt[v];
	for(re int i=1;i<=n;++i) cnt[i]>2&&(Upd(i),7);
	for(re int i=1;i<=n;++i) putchar(ans[i]?'A':'B');
	return;
}
```

---

## 作者：zpy12345 (赞：2)

# [[COCI 2014/2015 #4] SABOR](https://www.luogu.com.cn/problem/P7178)
厚着脸皮安利一下[我的博客](https://blog.csdn.net/weixin_46785057/article/details/150584887?sharetype=blogdetail&sharerId=150584887&sharerefer=PC&sharesource=weixin_46785057&spm=1011.2480.3001.8118)。
## 题意
给定一张 $n$ 个点的无向图，每个点的度数不超过 $5$，要求对每个点染色（黑或白），使得每个点不能有超过 $2$ 个同色点与其相邻。
## 思路
本题点的度数和要求十分特别，思路也很有意思。

考虑先让每个点都染成黑色，如果与当前点 $x$ 相邻的点中，同色点的数量超过 $2$，那么异色点的数量一定不超过 $2$（每个点的度数不超过 $5$），此时将点 $x$ 的颜色翻转即可。不过将点 $x$ 的颜色翻转后，现在与点 $x$ 同色的点有可能不合法，此时把这些点当作点 $x$ 重新操作即可。

时间复杂度爆炸？非也。设一个边为特别的边当且仅当该边两端的点同色。初始时，特别的边最多有 $\frac{5n}{2}  $ 条。每次操作，至少会使特别的边减少一条，最多减少 $\frac{5n}{2} $ 次，故时间复杂度为 $O(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
vector<int> a[N];
bool color[N]; 
void solve(int x)
{
	int cnt=0;
	for(int i=0;i<a[x].size();i++)
		if(color[a[x][i]]==color[x]) cnt++;
	if(cnt>2)
	{
		color[x]^=1;
		for(int i=0;i<a[x].size();i++)
			if(color[a[x][i]]==color[x]) solve(a[x][i]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=5;i++)
	{
		int p;
		scanf("%d",&p);
		while(p--)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			a[x].push_back(y);
			a[y].push_back(x);
		}
	}
	for(int i=1;i<=n;i++)
		solve(i);
	for(int i=1;i<=n;i++)
		if(color[i]) putchar('A');
		else putchar('B');
	return 0;
} 
```

---

## 作者：wangif424 (赞：1)

许久之前见过这道题，然后今天上午被老师弱化之后加入了模拟赛，然后原但不会，寄。

重看这题，显然由于允许和不超过两个的同政党议员争吵，因此并查集和网络流的方法都不可行。

考虑度数不超过三，最多只允许和一个同政党议员争吵的弱化版，在局部可能形成奇数点环，不超过四个点的完全图，二分图等情况，其中奇数点环和不超过四个点的完全图只需要一次调整，二分图不需要调整。

类比地，我们想到在这里也不需要过多的调整。于是我们选择随机化，先随机分配政党，对于不符合要求的再取反，卡时调整即可。
```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define ENDL push('\n');
#define SPACE push(' ');
#define int long long
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c) {
	if(pp - pbuf == 1<<20)fwrite(pbuf, 1, 1<<20, stdout),pp = pbuf;
	*pp++ = c;
}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	if (x<0)x=-x,push('-');
	int sta[35],top=0;
	do {
		sta[top++]=x%10,x/=10;
	} while (x);
	while(top)push(sta[--top]^'0');
}
#ifndef LOCAL
	char buf[1<<23],*p1=buf,*p2=buf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
int n,m,a[300100];
struct edge{
	int to,nxt;
}v[1500100];
int len,fir[300100];
void add(int x,int y){
	++len;
	v[len].to=y;
	v[len].nxt=fir[x];
	fir[x]=len;
}
int c(int u){
	int res=0;
	for(int i=fir[u];i;i=v[i].nxt){
		res+=(a[u]==a[v[i].to]);
	}
	return res;
}
signed main(){
	mt19937 rd(time(0));
	R(n);
	for(int i=1;i<=n;i++)a[i]=rd()&1;
	for(int i=1;i<=5;i++){
		int R(p);
		while(p--){
			int R(x),R(y);
			add(x,y);
			add(y,x);
		}
	}
	while(clock()<CLOCKS_PER_SEC*0.9){
		for(int i=1;i<=n;i++){
			if(c(i)>2)a[i]^=1;
		}
	}
	for(int i=1;i<=n;i++)push(a[i]?'A':'B');
    return 0;
}

```

---

## 作者：__DDDDDD__ (赞：1)

# 题意简述

给定一些议员的敌对关系，要求判断每个议员属于 $A$、$B$ 之中的哪一个政党。其中要确保每个议员**最多与两位不同的本政党中的议员争吵**。

# 题目分析

**闲话**：


一开始想到了[【P1892】团伙](https://www.luogu.com.cn/problem/P1892)，尝试用并查集做。

但是因为需要确保最多与两位不同政党中的议员争吵,

~~于是我去看题解了（太蒻了不会写，逃）~~



**分析**:

这道题要用染色法做（先膜一下大佬）。

通过议员之间的敌对关系建图，给每个节点染色，染色时确保每个节点相邻且同色的节点不超过两个。

具体来说，用 $cnt$ 数组存储每个节点的相邻且同色节点个数，用 $col$ 数组存储节点颜色。

**大致流程**：

1. 输入时将所有节点的颜色均设为相同，因此在输入一条边时，将起点、终点的 $cnt$ 值 $+1$；

1. 遍历所有节点，若出现 $cnt>2$ 的情况，将该点颜色取反，然后修改该节点与其所有相邻节点的 $cnt$ 值；

1. 若修改后出现一个相邻节点的 $cnt>2$，则继续对该节点进行修改；

1. 重复执行至所有节点被遍历完。


**注意事项**：


1. 本题空间限制较小，用数组存图可能会出问题（至少我 MLE 了），所以用 vector 存图似乎会更好一些......


1. 因为敌对关系是双向的，所以要建双向边（）。

# 代码 + 注释
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005
int n,m,k;
int cnt[maxn];							//每个节点的相邻且同色节点个数 
vector<int>p[maxn];						//vector存图 
bool col[maxn];							//存储颜色 
void color(int x){
	col[x]^=1;
	for(int i=0;i<p[x].size();i++){		//判断各个相邻节点颜色是否相同 
		int y=p[x][i];
		if(col[x]!=col[y]){
			cnt[x]--;cnt[y]--;
		}else{
			cnt[x]++;cnt[y]++;
		}
	}
	for(int i=0;i<p[x].size();i++){		//检查修改后的各个相邻节点
		int y=p[x][i];
		if(cnt[y]>2)color(y);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);				//输入输出优化 
	cin>>n;
	for(int i=1;i<=5;i++){
		cin>>k;
		for(int j=1,a,b;j<=k;j++){
			cin>>a>>b;
			p[a].push_back(b);
			p[b].push_back(a);			//建双向边 
			cnt[a]++;cnt[b]++;
		}
	}
	for(int i=1;i<=n;i++){				//遍历所有节点 
		if(cnt[i]>2)color(i);
	}
	for(int i=1;i<=n;i++){
		if(col[i])cout<<'A';
		else cout<<'B';
	}
	return 0;
}
```

------------

---

## 作者：zhujiahao114514 (赞：0)

## 说点闲话
模拟赛的题目。

赛时的思路是对的，但是不知道为什么打错了。幸好我打了部分分。

庆祝我挂了九十八分，发个题解。

## 正确解法

可以运用染色法，两个不同的政派是两种不同的颜色。

先设每一个点都是同色的。

我们对争吵的人 $u$ 和 $v$ 建边，并统计每一个点的度数。当一个点的度数大于二的时候，我们就把这一个点的颜色进行修改，并且将与之相邻的点的度数进行修改。最后，我们对其相邻的点再进行搜索，直到找不到为止。

最后输出就好了。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,d[N];
vector<int> g[N];
bool ans[N];
void dfs(int u)
{
	ans[u]=!ans[u];
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(ans[u]!=ans[v]) d[u]--,d[v]--;
		else d[u]++,d[v]++;
	}
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(d[v]>2) dfs(v);
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=5;i++)
	{
		int x;
		cin>>x;
		for(int j=1;j<=x;j++)
		{
			int u,v;
			cin>>u>>v;
			g[u].push_back(v);
			g[v].push_back(u); 
			d[u]++,d[v]++;
		}
	}
	for(int i=1;i<=n;i++)
		if(d[i]>2) dfs(i);
	for(int i=1;i<=n;i++)
		cout<<char(!ans[i]+'A');
	return 0;
}
```

---


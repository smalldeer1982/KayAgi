# [COCI 2014/2015 #4] STANOVI

## 题目描述

Stanko 在一家建筑公司做建筑师。他目前的任务是为萨格勒布的一栋住宅楼制定一个平面图。他必须确定一种方法，用墙将楼层建筑分割成矩形的公寓。每面墙必须与建筑物的侧面平行。更准确地说，楼层在平面图中表示为一个尺寸为 $n\times m$ 的大矩形，其中每个公寓都是一个较小的矩形，尺寸为 $a\times b$，位于较大的矩形的内部。数字 $a$ 和 $b$ 必须是整数。

此外，楼层必须完全覆盖公寓——楼层中的每个点都必须位于公寓内。公寓不能交叉，但它们可以接触。为了防止室内黑暗，公寓必须有窗户。因此，每套公寓必须有一条在代表楼层的矩形边缘上的边，这样就可以放置一个窗户。

此外，所有公寓的面积 $k$ 必须近似相等。尺寸为 $a\times b$ 的公寓的面积偏差定义为 $(a\times b-k)^2$。平面图的偏差是公寓所有偏差的总和。

Stanko 想建造他能建造的最好的建筑，一座偏差最小的建筑。帮助他并编写一个程序，以确定满足任务条件的平面图的最小可能偏差。

![](https://cdn.luogu.com.cn/upload/image_hosting/nmhy72yb.png)

## 说明/提示

#### 样例 1 说明

该样例对应于题目描述的左图。请注意，不可能实现 $0$ 的偏差值。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n,m\le 300$，$1\le k\le 10^4$。

#### 说明

**题目译自 [COCI2014-2015 CONTEST #4](https://hsin.hr/coci/archive/2014_2015/contest4_tasks.pdf) _T6 STANOVI_。**

## 样例 #1

### 输入

```
3 3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
2 2 2```

### 输出

```
0```

## 样例 #3

### 输入

```
2 3 4```

### 输出

```
2```

# 题解

## 作者：Liynw (赞：8)

[题目链接](https://www.luogu.com.cn/problem/P7179)

记忆化搜索，其实思路不太难吧，但是优化比较难想，建议评蓝。

***

题意简述：

有一个 $m\times n$ 的方格矩阵，把这个矩阵分为若干部分，且要求每一个矩阵都要与边界相邻。令 $k$ 为标准面积，不满意度为{所有矩阵面积减去 $k$ 的平方}之和。求最小的不满意度。

***

### 搜索

题库里有道题叫[生日快乐](https://www.luogu.com.cn/problem/P4160)（这道题是蓝的，但是难度严重虚高，个人觉得最多是绿），其实思路相仿，不过这题要难一些。

我们假设拿到了一个**已知所有信息、且满足四周有边界的矩阵**，我们要对它进行搜索。

首先我们要解决**传参问题**：什么算已知条件，而且如何判断这个矩阵是不是满足条件呢？

首先长和宽是有必要的。而且因为这道题要求**每一个矩阵都要挨着边界**，所以我们需要知道它四面挨着边界的情况。

dfs 函数中传 $6$ 个参数：

- `int` 类型：$x$ （矩阵的长），$y$ （矩阵的宽）。

- `bool` 类型：`up` （此矩阵上面那条边是否挨着边界），`down` （下面那条边是否挨着边界），`left` （左边那条边是否挨着边界），`right` （右边那条边是否挨着边界）。

***

解决完了 dfs 函数的传参问题，那怎么搜索呢？

我们先来分析出口。

由于题目要求，只要已知一个矩阵四面都没挨着边界，就直接返回一个极大值。

对于一个满足条件且已知的矩阵，有两种思路：

1. 直接把它作为一个最终划分的矩阵；

2. 把它继续分成更小的矩阵。

第一种思路很好解决，直接按照长、宽求就行了。

关键是第二种。

为了方便大家理解，我随便画了一个矩阵举例说明：

![](https://cdn.luogu.com.cn/upload/image_hosting/ipcadd46.png)

（~~Excel 真好用啊~~，蓝色为边界的**外面那一圈**）

对于这个矩阵，我们又有两种划分的方法：

1. 横着切；

![](https://cdn.luogu.com.cn/upload/image_hosting/763xd6p8.png)

（红色的地方就是能切的地方。）

2. 竖着切。

![](https://cdn.luogu.com.cn/upload/image_hosting/x10vt7q5.png)

那我们只需要分两种情况，分别枚举切割的地方，寻找最小值就可以了。（比如说，枚举上面/左边那个矩阵的长/宽）

最后再看一下哪种情况会更好。

注意一个细节：横着切需满足 $x>1$，竖着切需满足 $y>1$。

核心代码大概长这样：

```cpp
if(!(up||down||left||right)) return inf; //不沿海 
ll ans1=pow(x*y-k,2);
if(x==1&&y==1) return ans1;
ll ans2=inf;
bool u1,u2,d1,d2,l1,l2,r1,r2;
//横着分开
u1=up,u2=0,d1=0,d2=down,l1=l2=left,r1=r2=right;
if(x>1){
    for(int i=1;i<x;i++){
        int t=dfs(i,y,u1,d1,l1,r1)+dfs(x-i,y,u2,d2,l2,r2);
        ans2=min(ans2,t);
    }
}
//竖着分开 
u1=u2=up,d1=d2=down,l1=left,l2=0,r1=0,r2=right;
if(y>1){
    for(int i=1;i<y;i++){
   	int t=dfs(x,i,u1,d1,l1,r1)+dfs(x,y-i,u2,d2,l2,r2);
        ans2=min(ans2,t);
    }
}
return min(ans1,ans2);
```

***

### 记忆化

开一个六维的数组 $dp$，每一维都对应一个传的参数，把 dfs 的值存在里面即可。

这个时候有人就会说了：可是不一样的矩阵可能六个参数都一样，那这个如何判断？

答案是不需要判断。虽然的确这种情况是存在的，但是，如果六个参数都一样，算出来的结果肯定也一样，这不会影响结果，还会减小运行的时间。

***

### 剪枝

- **可行性剪枝**

观察一下上面的图，不难发现，有一些情况是不能做横着或者竖着的分割的，比如说这种：

![](https://cdn.luogu.com.cn/upload/image_hosting/ols6p9jk.png)

这个东西就不能竖着切，因为如果竖着切了，左边的那个矩阵就不挨着边界了。

那我们可以写出矩阵要横着切和竖着切的条件：

- 横着：`up&&down||left||right`

- 竖着：`left&&right||up||down`

为什么呢？以横着切举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/glxngxbg.png)

现在四面是否挨着边界不知道。

如果要求成功，就必须满足下列**至少一个**条件：

1. 上面和下面**都挨着边界**。

1. 左边挨着边界，**或者**右边挨着边界。

你们自己去想一想，竖着也类似。

- **最优性剪枝**

很好想，要是一个矩阵的面积小于 $k$，就不继续切了，直接返回。

- **等价性剪枝**

zszz 矩阵是可以转的对吧？

拿到一个矩阵之后，我们可以尝试把它转一下：可以向左旋转 $0^{\circ},90^{\circ},180^{\circ},270^{\circ}$，每一种旋转都可以查看是否已求出结果，如果有，直接返回。

代码比较简单，但是思考的过程比较绕：

```cpp
if(dp[x][y][up][down][left][right]!=-1) return dp[x][y][up][down][left][right]; //正常 
if(dp[x][y][down][up][right][left]!=-1) return dp[x][y][down][up][right][left]; //倒立 
if(dp[y][x][left][right][down][up]!=-1) return dp[y][x][left][right][down][up]; //往左转 
if(dp[y][x][right][left][up][down]!=-1) return dp[y][x][right][left][up][down]; //往右转 
```

剪枝就这三个。虽然不多，但足以通过这道题。

~~最后再卡一下常。~~

***

### Code

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#define min(a,b) (a)<(b)?(a):(b);
#define ll long long
const int maxn=305;
const ll inf=(ll)2e9;
int n,m,k;
ll dp[maxn][maxn][2][2][2][2];
ll dfs(int x,int y,bool up,bool down,bool left,bool right){ //bool 类型记录是否四个方向沿海 
	if(dp[x][y][up][down][left][right]!=-1) return dp[x][y][up][down][left][right]; //正常 
	if(dp[x][y][down][up][right][left]!=-1) return dp[x][y][down][up][right][left]; //倒立 
	if(dp[y][x][left][right][down][up]!=-1) return dp[y][x][left][right][down][up]; //往左转 
	if(dp[y][x][right][left][up][down]!=-1) return dp[y][x][right][left][up][down]; //往右转 
	if(!(up||down||left||right)) return inf; //不沿海 
	ll ans1=pow(x*y-k,2);
	if(x==1&&y==1||x*y<k) return dp[x][y][up][down][left][right]=ans1;
	ll ans2=inf;
	bool u1,u2,d1,d2,l1,l2,r1,r2;
	//横着分开 
	if(x>1&&(up&&down||left||right)){
		u1=up,u2=0,d1=0,d2=down,l1=l2=left,r1=r2=right;
		for(register int i=1;i<x;i++){
			int t=dfs(i,y,u1,d1,l1,r1)+dfs(x-i,y,u2,d2,l2,r2);
			ans2=min(ans2,t);
		}
	}
	//竖着分开 
	if(y>1&&(left&&right||up||down)){
		u1=u2=up,d1=d2=down,l1=left,l2=0,r1=0,r2=right;
		for(register int i=1;i<y;i++){
			int t=dfs(x,i,u1,d1,l1,r1)+dfs(x,y-i,u2,d2,l2,r2);
			ans2=min(ans2,t);
		}
	}
	return dp[x][y][up][down][left][right]=min(ans1,ans2);
}
int main(){
	memset(dp,-1,sizeof(dp));
	scanf("%d %d %d",&m,&n,&k);
	printf("%lld",dfs(m,n,1,1,1,1)); 
	return 0;
}
```

---

## 作者：Kingna (赞：2)

我的思路清奇，代码直观，常数较小，随便开个 O2 直接总时间 $1.17s$ 通过。

## 思路
手玩数据，关键是找出划分状态的方式。

考虑分割成两个矩形，对于任意一种分割方案都一定存在一条**贯穿横向**或者**贯穿纵向**的线，那么枚举这条线即可。

然后设 $dp_{x,y,t}$ 表示长为 $x$ 宽为 $y$，面向大海的边状态是 $t$ 的最小的花费。

面向大海的边的只有 $4$ 种形态，红蓝边即为面向大海的边：

![](https://cdn.luogu.com.cn/upload/image_hosting/99f6btrz.png)

对于每一种形态，我们可以横竖分割成另外的形态。比如形态 $4$ 横一刀可以分成形态 $4$ 自己和形态 $2$，竖一刀可以分成两个形态 $3$。 

转移怎么转移？就枚举从什么地方切一刀即可。

怎么考虑转移顺序？这转移完全乱来啊，那么就记忆化搜索！！
## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 305; 
int n, m, k, dp[N][N][6];

int dfs(int n, int m, int t) { // t为形态
	if (dp[n][m][t] != -1) return dp[n][m][t];
	int ans = (n * m - k) * (n * m - k);
	// 下面为转移，每个形态进行横竖切割（第一个形态只能竖着切）
	if (t == 1) {
		for (int i = 1; i < n; i++) ans = min(ans, dfs(i, m, 1) + dfs(n - i, m, 1));
	}
	if (t == 2) {
		for (int i = 1; i < n; i++) ans = min(ans, dfs(i, m, 2) + dfs(n - i, m, 2));
		for (int i = 1; i < m; i++) ans = min(ans, dfs(n, i, 1) + dfs(n, m - i, 1));
	}
	if (t == 3) {
		for (int i = 1; i < n; i++) ans = min(ans, dfs(i, m, 3) + dfs(n - i, m, 1));
		for (int i = 1; i < m; i++) ans = min(ans, dfs(n, i, 3) + dfs(m - i, n, 1)); 
	}
	if (t == 4) {
		for (int i = 1; i < n; i++) ans = min(ans, dfs(i, m, 4) + dfs(n - i, m, 2));
		for (int i = 1; i < m; i++) ans = min(ans, dfs(n, i, 3) + dfs(n, m - i, 3));
	}
	return dp[n][m][t] = ans;
}

signed main() {
	memset(dp, -1, sizeof dp);
	cin >> n >> m >> k; 
	int res = 1e18;
	for (int i = 1; i < n; i++) res = min(res, dfs(i, m, 4) + dfs(n - i, m, 4));
	for (int i = 1; i < m; i++) res = min(res, dfs(i, n, 4) + dfs(m - i, n, 4));
	cout << res << endl;
}
```


---

## 作者：StarPatrick (赞：2)

这道题是类似于巧克力棒那题。

首先，先来感受一下，一个 $n * m$ 的图形，要想把它这样切成若干个矩形，必有一刀贯穿整个图形，不然不能分成这样的图形。

于是我们就可以记忆化搜索，定义 $dfs(x, y)$ 表示尺寸为 $x * y$ 的公寓的最小偏差，又因为除了最小偏差还要有窗户，所以再定义 $up,down,left,right$ 四个维度表示此方向的窗户的状态（0/1）。

接下来我们就可以枚举切割点，这里有个小剪枝：必须要有窗户，枚举完就可以记忆化输出答案了。

但是，这样会 TLE，但是我们发现这个图形上下窗户，左右窗户，横着摆，竖着摆都是一种情况，所以在最后记忆化时把这些情况都写进去就行了。

代码：
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
#define int long long
int n, m, k, dp[305][305][2][2][2][2];
int dfs(int x, int y, bool up, bool down, bool left, bool right)
{
	if (dp[x][y][up][down][left][right]!=-1)
	{
		return dp[x][y][up][down][left][right];
	}
	int ans = abs(x*y-k)*abs(x*y-k);
	for (int p=1;p<x;p++)
	{
		if (left||right||(up&&down))
		{
			ans = min(ans, dfs(p, y, up, 0, left, right)+dfs(x-p, y, 0, down, left, right));
		}
	}
	for (int p=1;p<y;p++)
	{
		if (up||down||(left&&right))
		{
			ans = min(ans, dfs(x, p, up, down, left, 0)+dfs(x, y-p, up, down, 0, right));
		}
	}
	return dp[x][y][up][down][left][right]=dp[x][y][down][up][left][right]=dp[x][y][up][down][right][left]=dp[x][y][down][up][right][left]=dp[y][x][left][right][up][down]=dp[y][x][right][left][up][down]=dp[y][x][left][right][down][up]=dp[y][x][right][left][down][up]=ans;
}
signed main()
{
	memset(dp, -1, sizeof(dp));
	cin>>n>>m>>k;
	cout<<dfs(n, m, 1, 1, 1, 1);
	return 0;
}
```


---

## 作者：Harry_Hedwig (赞：0)

# 0x00 思路
先看题。
>楼层在平面图中表示为一个尺寸为 $n\times m$ 的**大矩形**，其中每个公寓都是一个**较小的矩形**，尺寸为 $a\times b$，**位于较大的矩形的内部**。数字 $a$ 和 $b$ 必须是**整数**。此外，楼层必须**完全覆盖公寓**——楼层中的**每个点都必须位于公寓**内。公寓**不能交叉**，但它们可以接触。**每套**公寓必须有一条**在代表楼层的矩形边缘上的边**。尺寸为 $a\times b$ 的公寓的面积偏差定义为 $(a\times b-k)^2$。面图的偏差是公寓所有偏差的总和。Stanko 想建造**一座偏差最小的建筑**。

这题与[CF598E Chocolate Bar](https://www.luogu.com.cn/problem/CF598E)有相似的地方，都是要把一个矩形分成多块，只不过这道题有一点限制：每一个矩形都需要有至少一条边在原矩形的边上。但是这也阻止不了我们用同样的方法（搜索）去对待这道题。
# 0x01 做题
既然它要有至少一条边在原矩形的边上，那么每个矩形的 $4$ 条边都有可能在原矩形的边上，所以我们需要 $4$ 个参数来分别表示当前的矩形的 $4$ 条边是否在原矩阵的边上。所以传入参数不只需要当前矩阵的长 ```x``` 和宽 ```y```，还需要四个变量来分别表示当前边是否在原矩形上（最好用 ```bool``` 型变量节省空间）。

于是我们的代码就出来啦：
```c
long long devlop(int x,int y,bool up,bool down,bool left,bool right)
{
	long long ans=(x*y-k)*(x*y-k);
	int i,j;
	if((up&&down)||left||right)//横切
		for(i=1;i<x;i++)//切多少
			ans=min(ans,devlop(i,y,up,0,left,right)+devlop(x-i,y,0,down,left,right));
	if((left&&right)||up||down)//竖切
		for(i=1;i<y;i++)//切多少
			ans=min(ans,devlop(x,i,up,down,left,0)+devlop(x,y-i,up,down,0,right));
	return ans;
}
```
到这里就基本结束了，但当你轻松地交上去之后，眉头一皱，发现并不简单。

# 0x02 优化
好了，你会发现出现了 **TLE**，这说明你的程序需要改进。

你会发现一个矩形可能会出现多次调用以及计算的情况，所以你可以将你计算过的答案存储下来，等下次需要用的时候可以节省很多时间。这样的优化方式叫做：记忆化。而这样的搜索方式叫做：记忆化搜索。

那么你需要一个数组来记录每个矩形的最小偏差，而你对这个矩形有**六**个要求，所以就得开**六**维数组。

代码又一次写出来了：
```c
long long zhi[305][305][2][2][2][2];
long long devlop(int x,int y,bool up,bool down,bool left,bool right)
{
	long long &ZHI=zhi[x][y][up][down][left][right];
	if(ZHI!=-1)//没算过
		return ZHI;
	long long ans=(x*y-k)*(x*y-k);
	int i,j;
	if((up&&down)||left||right)
		for(i=1;i<x;i++)
			ans=min(ans,devlop(i,y,up,0,left,right)+devlop(x-i,y,0,down,left,right));
	if((left&&right)||up||down)
		for(i=1;i<y;i++)
			ans=min(ans,devlop(x,i,up,down,left,0)+devlop(x,y-i,up,down,0,right));
	return ZHI=ans;//返回值并记忆化
}
主函数中:memset(zhi,-1,sizeof(zhi));//赋初值
```

仍然有问题！这就很奇怪了，为什么记忆化了还会超时呢？

让我们看一组图片。


![](https://cdn.luogu.com.cn/upload/image_hosting/j2t30xdh.png)

这六个图都是一个矩形弄出来的：原图、旋转 $90&deg$、旋转 $180&deg$、旋转$270&deg$、左右翻转，上下翻转。因此，这六个图是等价的，所以我们算了其中一个图就应该改把其他六个图都给算进去以减少更多时间。

```c
long long zhi[305][305][2][2][2][2];
long long devlop(int x,int y,bool up,bool down,bool left,bool right)
{
	long long &ZHI=zhi[x][y][up][down][left][right];
	if(ZHI!=-1)
		return ZHI;
	long long ans=(x*y-k)*(x*y-k);
	int i,j;
	if((up&&down)||left||right)
		for(i=1;i<x;i++)
			ans=min(ans,devlop(i,y,up,0,left,right)+devlop(x-i,y,0,down,left,right));
	if((left&&right)||up||down)
		for(i=1;i<y;i++)
			ans=min(ans,devlop(x,i,up,down,left,0)+devlop(x,y-i,up,down,0,right));
   	//各种旋转加各种翻转
	zhi[x][y][down][up][left][right]=ans;
	zhi[x][y][up][down][right][left]=ans;
	zhi[y][x][left][right][down][up]=ans;
	zhi[x][y][down][up][right][left]=ans;
	zhi[y][x][right][left][up][down]=ans;
	return ZHI=ans;
}
```

# 0x03 注意
以上代码交上去都是错的，而最后一个代码会显示答案错误。这是因为 ```x,y,k``` 都是 ```int``` 类型的整数，而 ```(x*y-k)*(x*y-k)``` 可能超出 ```int``` 范围，所以你需要讲其中的你需要将其中的某些变量改为 ```long long``` 才可。 

---

## 作者：Computer1828 (赞：0)

正解竟然是记忆化搜索……

用墙分割的时候，分开的两部分相对独立，可以分别递归搜索，所以用记忆化搜索是正确的。

考虑状态。记 `f[n][m][w(0/1)][a(0/1)][s(0/1)][d(0/1)]` 表示当前方块为 $n\cdot m$ 大小，上左下右是否靠最外边。

考虑转移。显然有两种分割方法：纵切和横切。所以我们只需对两种方案枚举切割点然后答案取 $\min$ 即可。

注意判断靠最外边，只有满足割完后还靠最外边才能割。

考虑常数优化。记忆化搜索时，对于 $n>m$ 的情况，需把这时的方块转置。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int k;
bool vis[305][305][2][2][2][2];
ll f[305][305][2][2][2][2];
inline ll dfs(int n,int m,int w,int a,int s,int d){
	//上左下右
	if(n>m) swap(n,m),swap(w,a),swap(s,d);//转置 
	ll ret = 1ll*(n*m-k)*(n*m-k);
	if(!vis[n][m][w][a][s][d]){
		vis[n][m][w][a][s][d] = true;
		if((w|s|a) & (w|s|d)){//纵切 
			for(int i = 1;i<m;++i) ret = min(ret,dfs(n,i,w,a,s,0)+dfs(n,m-i,w,0,s,d));
		}
		if((w|a|d) & (s|a|d)){//横切 
			for(int i = 1;i<n;++i) ret = min(ret,dfs(i,m,w,a,0,d)+dfs(n-i,m,0,a,s,d));
		}
	}else return f[n][m][w][a][s][d];
	return f[n][m][w][a][s][d] = ret; 
}
int main(){
	int n,m;
	scanf("%d%d%d",&n,&m,&k);
	printf("%lld\n",dfs(n,m,1,1,1,1));
	return 0;
}
```

---


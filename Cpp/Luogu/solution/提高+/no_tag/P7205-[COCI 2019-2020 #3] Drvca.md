# [COCI 2019/2020 #3] Drvca

## 题目描述

为了迎接圣诞老人，市政厅已经准备了 $N$ 棵圣诞树。相关人员想要将这些树排成两排，使得每一排中：

- 相邻两树之间高度之差相等
- 圣诞树按照高度从小到大的顺序排列。

请你帮助大家找到一个合适的排列方式。

## 说明/提示

#### 数据范围及约定

| Subtask | 分值 | 数据范围及约定 | 特殊性质
| :----------: | :----------: | :----------: | :----------: 
| $1$ | $20$ | $N \le 15$ | 无 |
| $2$ | $30$ | $N \le 300$ | 无 |
| $3$ | $30$ | $N \le 10^5$ | 有一种方案，使得两排圣诞树数量相等 |
| $4$ | $30$ | 无 | 无 |

对于 $100\%$ 的数据，$2 \le N \le 10^5, 1 \le h_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

本题使用非官方的 [Special Judge](https://www.luogu.com.cn/paste/c2638vjq)，欢迎大家 hack（可私信或直接发帖）。

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #3](https://hsin.hr/coci/archive/2019_2020/contest3_tasks.pdf)  _T3 Drvca_ 。**

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
2
1 2
2
3 4```

## 样例 #2

### 输入

```
6
23 4 7 6 8 15```

### 输出

```
3
4 6 8
3
7 15 23```

## 样例 #3

### 输入

```
6
1 2 3 7 9 10```

### 输出

```
-1```

# 题解

## 作者：Demeanor_Roy (赞：10)

- [原题链接](https://www.luogu.com.cn/problem/P7205)

- 来一个不一样的做法。


------------

- 考虑 $n^3$ 暴力。首先将圣诞树按高度从小到大排序，不难想到确定高度最小的一棵圣诞树，枚举其它 $n-1$ 棵圣诞树与它构成等差数列前两项，再贪心地能选择选，$O(n)$ 判断剩下的圣诞树是否可行。

- 乍一看这个做法是 $O(n^2)$ 的，可实际上每往序列贪心地加入一项后，我们都需要判断一次，而不是全部加完才判断。这是因为第一个序列不是选得越多越好，可能它中的某一个元素需要作为第二个序列的桥梁，所以需要多次判断。

- 思考如何优化？仔细观察就会发现，确定一个序列的前两项根本不需要枚举 $n-1$ 次，根据鸽巢原理可知，用最小的三棵圣诞树就能确定一个序列的前两项。所以其实只需要判断 $(1,2),(1,3),(2,3)$ 作为序列前两项就行了。时间复杂度降至 $O(n^2)$。

- 最后考虑用数据结构优化判断剩下的数能否构成等差数列的过程。我们发现每次往一个序列中贪心地加入一项，就是在另一个序列中删去一项。用链表维护被删的那个序列，同时用 STL 中的 map 维护相邻元素的差及个数，每次删去一个数就动态维护一下 map，判断能否构成等差序列就是判断第一项和第二项的差的个数是否为元素个数减一。于是时间复杂度优化到了 $O(n \log n )$ 。

- 细节：需要特判一下 $n=2$ 的情况。

- 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n,val[N],L[N],R[N];
bool st[N];
map<int,int> mp;
inline bool check(int a,int b)
{	
	mp.clear();
	memset(L,0,sizeof L);
	memset(R,0,sizeof R);
	memset(st,0,sizeof st);
	st[a]=st[b]=true;
	int last=0,cnt=2;
	for(int i=1;i<=n;i++)
	{
		if(st[i])	continue;
		if(last)	mp[val[i]-val[last]]++;
		L[i]=last,R[last]=i;
		last=i;
	}
	if((int)mp[val[R[R[0]]]-val[R[0]]]==n-cnt-1)	return true;
	last=b;
	for(int i=1;i<=n;i++)
	{
		if(st[i]||val[i]-val[last]!=val[b]-val[a])	continue;
		if(L[i])	mp[val[i]-val[L[i]]]--;
		if(R[i])	mp[val[R[i]]-val[i]]--;
		if(L[i]&&R[i])	mp[val[R[i]]-val[L[i]]]++;
		R[L[i]]=R[i];L[R[i]]=L[i];
		cnt++;last=i;st[i]=true;
		if((int)mp[val[R[R[0]]]-val[R[0]]]==n-cnt-1)	return true;
	}
	return false;
}
inline void print()
{
	int num=0;
	for(int i=1;i<=n;i++)	if(st[i])	num++;
	printf("%d\n",num);
	for(int i=1;i<=n;i++)	if(st[i])	printf("%d ",val[i]);
	printf("\n%d\n",n-num);
	for(int i=1;i<=n;i++)	if(!st[i])	printf("%d ",val[i]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	scanf("%d",&val[i]);
	sort(val+1,val+n+1);
	if(n==2)	printf("1\n%d\n1\n%d",val[1],val[2]);
	else if(check(1,2)||check(1,3)||check(2,3))	print();
	else printf("-1");
	return 0;
}
```
- 完结撒花~


---

## 作者：静静是他的， (赞：6)

#### 题意

把 $N$ 个数分成两个等差数列。

#### 做法

先排序一下，考虑从小到大构造等差数列。

直接 dfs 搜索，考虑把当前的数分别分到两个等差数列搜索。

- 当等差数列长度小于 $2$ 个时，可以直接放入。

- 否则，考虑加入后能否形成等差数列。

如果搜索次数过大，则认为无解。

由于等差数列的限制较强，有解的情况比较苛刻，这样剪枝的效果很好，

很难构造 hack。

#### 代码：
```
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAXN = 100010;  

int n, m; 
int a[MAXN], b[MAXN], c[MAXN];
void dfs(int N, int blen, int clen) {
	static int cnt = 0; 
	if (++ cnt > 11451419) {
		cout << -1 << endl;
		exit(0);
	}
	if (N == n + 1) {
		if (blen + clen == n && blen > 0 && clen > 0) {
			cout << blen << endl;
			for (int i = 1; i <= blen; i ++)
				cout << b[i] << ' ';
			cout << endl;
			cout << clen << endl;
			for (int i = 1; i <= clen; i ++)
				cout << c[i] << ' ';
			cout << endl;
			exit(0); 
		}
		return; 
	}
	if ((blen >= 2 && a[N] - b[blen] == b[2] - b[1]) || blen < 2) {
		b[blen + 1] = a[N];
		dfs(N + 1, blen + 1, clen);  
	}
	if ((clen >= 2 && a[N] - c[clen] == c[2] - c[1]) || clen < 2) {
		c[clen + 1] = a[N];
		dfs(N + 1, blen, clen + 1);  
	}
} 
int main() {
	cin >> n; 
	for (int i = 1; i <= n; i ++)
		cin >> a[i]; 
	sort(a + 1, a + n + 1); 
	dfs(1, 0, 0); 
	cout << -1 << endl;
	return 0; 
}
```

---

## 作者：Exp10re (赞：4)

给出一种不同于已有题解的思路。

不难想，不用 STL 库，时间复杂度 $O(n \log n)$，并且暂时是[最优解](https://www.luogu.com.cn/record/list?pid=P7205&orderBy=1&status=&page=1)。

## 简要题意

给出一个长度为 $n$ 的数列 $h$，询问能否将其分为两个数列 $a$ 和 $b$，满足：

- $a$ 和 $b$ 的长度均不为 $0$。
- $a$ 和 $b$ 均是不下降等差数列。

给出 $a$ 和 $b$ 的构造，或者报告无解。

## 解题思路

先将 $h$ 排序，排序后一定有：对于构造出的 $a$ 以及 $b$ 中每个元素，在 $a$ 或 $b$ 中其后的元素在 $h$ 中也一定在其后面。这可以大大减小我们的工作量。

显而易见的，当 $n=2$ 或 $n=3$ 时有解且很容易构造解，这里不过多展开。

对于 $n\geq 4$ 的情况，根据鸽巢原理，如果有解，那么前三个数一定有其中两个在同一个等差数列中，共三种情况：

- $a_1$ 以及 $a_2$ 在同一个等差数列中，暂时无法确定 $a_3$。
- $a_1$ 以及 $a_3$ 在同一个等差数列中，$a_2$ 在另一个等差数列中。
- $a_2$ 以及 $a_3$ 在同一个等差数列中，$a_1$ 在另一个等差数列中。

我们记当前已经确定 $2$ 个元素的数列为 $a$，另一个为 $b$。

维护每一个等差数列的最后一个数，公差以及元素个数，那么就能很容易的判定一个数能否接到该等差数列后方。

对于每一种情况，都可以尝试从第一个无法确定的位置开始往后，使用以下方式尝试将其加入等差数列：

- 用最后一个数以及公差判断，如果这个数能加入 $a$ 中，那么加入 $a$ 后方。
- 如果不行，那么查看 $b$ 中元素个数是否小于 $2$，如果是，那么显然这个元素可以被加入 $b$ 后方，否则用最后一个数以及公差判断是否可以加入，如果是，那么就加入 $b$ 后方，否则认为在当前情况下无解。

乍一看没问题，但是这种做法**是错的**！

考虑以下数列 $h$：

$1,2,2,3,4,4,5,6,8$。

如果用上述方法来加入等差数列，那么就会发现：$1,2,3,4,5,6$ 在 $a$ 中，$2,4$ 在 $b$ 中，因为有 $8$ 的存在所以无解，然而它是有解的：$1,2,3,4,5$ 在 $a$ 中，$2,4,6,8$ 在 $b$ 中就是一组解。

由此我们可以发现：如果某个元素既可以加入 $a$ 中，又可以加入 $b$ 中，那么就要判断它是否是 $a$ 的**必需元素**。

所谓**必需元素**，就是说对于一个等差数列，删掉它会使得数列不再等差。感性理解发现其实意思就是说这个元素不是等差数列的最后一项以及第一项。

如果一个元素 $h_i$ 对于 $a$ 不必需，就表明对于构造好的 $a$，$h_{[i+1,n]}$ 中的元素都不再属于 $a$ 了。

那么就可以考虑以下做法：从后往前找到使得其是等差数列的最长后缀，记录其公差，那么对于某一位，如果其既可以加入 $a$ 中，又可以加入 $b$ 中，并且它已经是上面提到的最长后缀中的某一位，且最长后缀的公差等于 $b$ 的公差，那么显然这一位对于 $a$ 是不必需的，而且可以将其以及其后的所有元素全部加入 $b$ 中，显而易见的，它构成了一组解。

这种构造方法可以很好的规避某个元素应该属于 $b$ 却被放入 $a$ 的情形，也就是说，先前的错解加上这种做法之后就正确了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100101;
long long n,a[MAXN],al,adis,bl,bdis,bcnt,tag[MAXN],lstdis,lstl;
inline bool CheckIfExist(long long lst)
{
	long long i;
	for(i=lst;i<=n;i++)
	{
		if(a[i]==al+adis)
		{
			if(a[i]==bl+bdis&&i>=lstl)
			{
				bcnt+=n-i+1;
				return true;
			}
			al=a[i];
			tag[i]=1;
		}
		else if(a[i]==bl+bdis||bcnt<=1)
		{
			if(bcnt==1)
			{
				bdis=a[i]-bl;
			}
			bl=a[i];
			bcnt++;
		}
		else
		{
			return false;
		}
	}
	return true;
}
inline void print()
{
	long long i;
	if(bcnt==0)
	{
		printf("1\n%lld\n%lld\n",a[1],n-1);
		for(i=2;i<=n;i++)
		{
			printf("%lld ",a[i]);
		}
	}
	else
	{
		printf("%lld\n",n-bcnt);
		for(i=1;i<=n;i++)
		{
			if(tag[i])
			{
				printf("%lld ",a[i]);
			}
		}
		printf("\n%lld\n",bcnt);
		for(i=1;i<=n;i++)
		{
			if(!tag[i])
			{
				printf("%lld ",a[i]);
			}
		}
	}
	return;
}
int main()
{
	long long i,j;
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	if(n==2)
	{
		printf("1\n%lld\n1\n%lld",a[1],a[2]);
		return 0;
	}
	sort(a+1,a+1+n);
	lstdis=a[n]-a[n-1];
	lstl=n-1;
	for(;lstl>=1;lstl--)
	{
		if(a[lstl+1]-a[lstl]!=lstdis)
		{
			break;
		}
	}
	lstl++;
	// 1,2 in a, start from 3.
	memset(tag,0,sizeof(tag));
	al=a[2];
	adis=a[2]-a[1];
	bl=-1;
	bdis=-1;
	bcnt=0;
	tag[1]=tag[2]=1;
	if(CheckIfExist(3))
	{
		print();
		return 0;
	}
	// 1,3 in a, 2 in b, start from 4.
	memset(tag,0,sizeof(tag));
	al=a[3];
	adis=a[3]-a[1];
	bl=a[2];
	bdis=-1;
	bcnt=1;
	tag[1]=tag[3]=1;
	if(CheckIfExist(4))
	{
		print();
		return 0;
	}
	// 2,3 in a, 1 in b, start from 4.
	memset(tag,0,sizeof(tag));
	al=a[3];
	adis=a[3]-a[2];
	bl=a[1];
	bdis=-1;
	bcnt=1;
	tag[2]=tag[3]=1;
	if(CheckIfExist(4))
	{
		print();
		return 0;
	}
	printf("-1\n");
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：3)

- 身体是革命的本钱。
- 希望各位身体健康。

**题意**
- [题目](https://www.luogu.com.cn/problem/P7205)。
- 给一个数列，判断它能否分为两个等差数列。

**分析**
- 根据鸽巢原理，把三个数分成两个集合，必然有两个数在同一个集合内。
- 因此，拎出前 $3$ 个数，我们已经知道了一个等差数列的前两项，这几乎可以确定一个等差数列。
- 你可能会把这个等差数列优先延续下去并打出这个[代码](https://www.luogu.com.cn/paste/3tmdtkv3)，但这是不对的，使用 $1,2,2,3,4,4,5,6,8,10$，就可以把它卡掉（它可以分解成 $1,2,3,4,5$ 和 $2,4,6,8,10$）。
- 所以这个等差数列的长度显然还是未知的，不过我们仍然可以找到一些东西来确认这个等差数列的长度。
- 个人采取的策略是：先找到最长的那个，然后做一些性质上的探究：你会发现，最长的那个不会带走另一个等差数列的连续两个数（否则其公差就确定，引起一定能判断出来的情况），因此个人的策略是：找到余下数列的差的最大公约数，然后检验的时候找到缺失的部分，可以通过此题，[代码](https://www.luogu.com.cn/paste/i1lontfc)，复杂度 $O(n\log n)$。

---

## 作者：huangrenheluogu (赞：1)

有一个非常显然的性质，可以在一开始发现。就是必然有一个等差数列是由 $a_1,a_2$ 或 $a_1,a_3$ 或 $a_2,a_3$ 开头的。

不妨两个序列是 $A,B$ 序列。确定 $A$ 序列开头之后，后面需要逐步扩展 $A$，笔者水平有限，尝试了各种贪心方式都是错误的。但是，可以直接考虑剩下的数字是否等差。

等差，即差相等，于是维护差的一个 multiset，判断最大值是否和最小值相等即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, a[N];
vector<int> A, B;
multiset<int> s, d;
inline bool check(){
    for(int i = 2; i < n; i++){
        if(a[i - 1] + a[i + 1] == 2 * a[i]) ;
        else return 0;
    }
    return 1;
}
inline bool del(int x){
    if(s.find(x) == s.end()) return 0;
    auto it = s.lower_bound(x);
    int l = -1, r = -1;
    // cerr << x << endl;
    if(next(it) != s.end()){
        r = *next(it);
        // cerr << x << ' ' << r << endl;
        d.erase(d.find(r - x));
    }
    if(it != s.begin()){
        l = *prev(it);
        // cerr << l << ' ' << x << endl;
        d.erase(d.find(x - l));
    }
    // cerr << x << ' ' << l << ' ' << r << endl;
    if((~l) && (~r)){
        d.insert(r - l);
    }
    s.erase(it);
    return 1;
}
inline void print(){
    for(int x : s){
        B.push_back(x);
    }
    printf("%d\n", (int)A.size());
    for(int x : A) printf("%d ", x);puts("");
    printf("%d\n", (int)B.size());
    for(int x : B) printf("%d ", x);puts("");
    exit(0);
}
inline void solve(){
    s.clear(), d.clear();
    for(int i = 1; i <= n; i++){
        s.insert(a[i]);
    }
    for(int i = 1; i < n; i++){
        d.insert(a[i + 1] - a[i]);
    }
    for(int x : A){
        assert(del(x));
    }
    if(d.empty() || (*d.begin() == *d.rbegin())){
        print();
    }
    int delta = A[1] - A[0];
    while(del(A.back() + delta)){
        A.push_back(A.back() + delta);
        if(d.empty() || (*d.begin() == *d.rbegin())){
            print();
        }
    }
}
inline void clr(){
    A.clear();
    d.clear();
    s.clear();
}
int main(){
    // freopen("data.in", "r", stdin);
    // freopen("code.out", "w", stdout);
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
    }
    sort(a + 1, a + n + 1);
    if(check()){
        printf("1\n%d\n%d\n", a[1], n - 1);
        for(int i = 2; i <= n; i++) printf("%d ", a[i]);
        puts("");
        return 0;
    }
    A.push_back(a[1]), A.push_back(a[2]);
    solve();
    clr();
    A.push_back(a[1]), A.push_back(a[3]);
    solve();
    clr();
    A.push_back(a[2]), A.push_back(a[3]);
    solve();
    puts("-1");
    return 0;
}
```

---

## 作者：small_lemon_qwq (赞：0)

显然，要对输入数据经行排序。

考虑前三个元素，不妨设 $h_1\in A$，那么要么 $h_2\in A$，要么 $h_3 \in A$，若 $h_2,h_3\in B$ ~~那么我不会了~~。

考虑已经确定了 $A$ 的第一项和公差 $d$，那么我们不难得到 $A$ 中元素个数的最大值，但此时剩余元素不一定能构成等差数列，因此我们找到需要删除一些 $A$ 中的元素，使得剩下的元素能构成等差数列。具体见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100005];
multiset<int>ans1,ans2;
bool calc(int d){
	multiset<int>s,s2,s3;
	s.insert(a[1]);
	int x=1,cnt=1;
	for(int i=2;i<=n;i++){
		if(a[i]-a[x]==d){
			x=i;
			cnt++;
			s.insert(a[i]);
		}else{
			s2.insert(a[i]);
		}
	}
	if(s2.size()&&s2.size()<=2){
		ans1=s;
		ans2=s2;
		return 1;
	}else if(!s2.size()){
		s2.insert(*s.begin());
		s.erase(s.begin());
		ans1=s;
		ans2=s2;
		return 1;
	}
	s3=s2;
	checker:
	x=*s2.begin();s2.erase(s2.begin());
	int y=*s2.begin(),dd=y-x;s2.erase(s2.begin());
	while(s2.size()){
		if((*s2.begin())-y!=dd){
			auto it=s.find(y+dd);
			bool f=0;
			while(it!=s.end()){
				s3.insert(*it);
				it=s.erase(it);
				f=1;
			}
			s2=s3;
			if(f)goto checker;
			return 0;
		}
		y=(*s2.begin());
		s2.erase(s2.begin());
	}
	ans1=s;
	ans2=s3;
	return 1;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	stable_sort(a+1,a+n+1);
	if(n==2){
		cout<<"1\n"<<a[1]<<"\n1\n"<<a[2];
		return 0;
	}
	if(calc(a[2]-a[1])||calc(a[3]-a[1])){
		cout<<ans1.size()<<"\n";
		for(int x:ans1){
			cout<<x<<" ";
		}
		cout<<"\n"<<ans2.size()<<"\n";
		for(int x:ans2){
			cout<<x<<" ";
		}
		return 0;
	}
	cout<<"-1\n";
	return 0;
}
/*
9
1 2 2 3 4 4 5 6 8
*/
```

---

## 作者：Nygglatho (赞：0)

以下的集合指可重集。设答案数组为 $A,B$。

显然原序列从小至大排序之后不影响结果，所以先将 $h$ 排序。之后说的 $h$ 均为排序之后的 $h$。

首先先判掉 $N=2$ 的情况。$N=2$ 就是 $A$ 取 $h_1$，$B$ 取 $h_2$。

接下来可以注意到一个性质：对于 $h_1,h_2,h_3$，一定有至少两个是同时属于 $A$ 或者同时属于 $B$ 的。证明可以用鸽巢原理或反证法简单地完成。

由于交换 $A,B$ 对答案无影响，因此不妨令这两个同时属于 $A$，又因为排好序了，所以一定为 $A$ 的前两项。

那么可以直接枚举 $h_1,h_2,h_3$ 中的两个数作为 $A$ 的前两项。之后判断是否可行。

---

由于知道了前两项，因此可以得出 $A$ 的公差 $d_A$。然后根据 $d_A$ 可以找出 $h$ 数组中所有有可能属于 $A$ 的元素，均加入至集合 $A'$（注意不是一定属于 $A$，例如 $h=[3 ,9,15,21,5,13,29]$，这里的 $21$ 就是可能属于 $A$ 但是最终需要在 $B$ 中的，因为 $B$ 缺少 $21$ 就无法构成等差数列）。

可以发现，可能属于 $A$ 但是最终需要在 $B$ 中元素一定是 $A'$ 的后缀。因为如果不是后缀，那么将会破坏 $A$ 公差为 $d_A$ 这个条件。除非 $d_A=0$（这种情况选后缀和不选是等价的）或者改变 $d_A$ 同时保持合法或者是前缀（可以选取 $h_1,h_2,h_3$ 中另外两个直接解决）。

因此可以直接寻找最小的两个**不可能**属于 $A$ 的元素（如果选择可能属于 $A$ 的元素，则合法必定为 $B$ 前缀，这个前缀移至 $A$ 仍然合法），根据其公差 $d_B$ 构造出 $B$，然后判断 $A$ 和 $B$ 的公共子序列是否是 $A'$ 的后缀。如果是则可行，反之不可行。

但是这样会导致答案数组 $B$ 可能为空。这可以直接将 $A$ 的首项或者末项移至 $B$，不影响结果。

[LOJ submission，写的依托](https://loj.ac/s/2188662)

---

## 作者：panxz2009 (赞：0)

首先考虑将 $a$ 排序。由抽屉原理，前三个数中至少有两个数属于同一个等差数列。枚举 $(1,2),(1,3),(2,3)$ 三种情况，意为钦定两个数是第一个等差数列里的。

考虑从左往右扫一遍，动态维护两个等差数列。对于第 $i$ 个数，如果它与第一个等差数列的最后一项的差等于此等差数列的差，那么它显然可以加入这个数列，反之就加入另一个数列即可。

但这样尽可能的加入第一个数列，不行了才加入第二个数列，这样的贪心策略是不对的。存在一种情况：一个数既可以加入第一个数列，也可以加入第二个数列。那么就会出现一种可能，这个数加入第一个数列使得第二个数列无解，但如果加入第二个数列就会成为“过渡数”，使得第二个数列变得有解。

考虑先尽可能的加入第一个数列，不行了才加入第二个数列，扫一遍。

然后**反悔**，再扫一遍第一个数列。每扫到一个点 $i$，检验这个点是不是也能加入第二个数列。如果能，那么说明 $i$ 及其后面的所有数都要移动到第二个数列里，原因是第一个数列的公差已经被先前钦定的两个数确定了，那么如果只退出第 $i$ 个点，那么第一个等差数列的公差就会被破坏。那么枚举所有可能从第一个数列移动到第二个数列的点，检验移动后数列是否合法，如果合法直接输出结束程序。

---

## 作者：Supor__Shoep (赞：0)

先考虑一个直接的思路，我们将 $a$ 从小到大排序，然后在其中选择一个等差子序列，接着判断 $a$ 中剩下的数是否满足等差性质。

如果我们要高效率，那么肯定不能枚举这个子序列。考虑找一些有趣的性质：对于排序后的 $a_1,a_2,a_3$，由于我们需要找到两个不交叉子序列，并且每个数都必须被选择一次，根据抽屉原理，我们可以知道 $a_1,a_2,a_3$ 这三个数中**必有至少两个数是在同一个子序列中的**。

找到了这个性质，我们想一想怎么利用。不难发现一个等差序列 $b_i$，如果序列长度已知，那么只需要确定 $b_1$ 和公差就可以直到整个序列了。于是我们考虑在 $a_1,a_2,a_3$ 中任意选择 $2$ 个数 $a_x,a_y$（$1\leq x<y\leq 3$），然后假定 $a_x$ 为起点，$a_y-a_x$ 为公差 $d$。接着我们用一个栈，初始时先把 $a_x,a_y$ 放进去，然后定义一个变量 $k\leftarrow a_y+d$，对于当前的 $k$，我们在 $a$ 中寻找是否存在这个值，如果存在就放入栈，$k\leftarrow k+d$。

为了计算答案，每次得到一个新的栈时，我们假定此时栈中组成的序列就是其中一个等差子序列，于是我们就要判断剩下的元素是否等差。

令我们已选出来的子序列的最后一项是 $a_p$，我们将剩下的元素分为下标 $<p$ 和下标 $>p$ 的，那么不合法情况就是四种：前者不等差，后者不等差，前后都等差但是两者公差不同，前后公差相同但是与前后交界处的两个数的差不同。

先判断前后者是否等差：对于后者我们发现这些元素都是 $a$ 的一段后缀，于是我们考虑预处理 $t_i$ 表示 $[i,n]$ 元素是否等差，如果不是则 $t_i=-1$，如果是则 $t_i$ 为这个公差。假如 $t_{p+1}=-1$，那么答案肯定不行。而对于前者，我们在将元素放入栈时，依次把前面未被使用的元素放入另一个栈里面，这样时间复杂度就是均摊 $O(n)$ 的，随时判断一下即可。

然后判断后面两种特殊情况：我们对于下标 $<p$ 的未使用元素也可以计算一个公差 $d\prime$，如果 $d\prime\not= t_{p+1}$，则显然不行。然后对于交界处的两个数，一个是 $a_{p+1}$，一个是第二个栈里的最后一个元素，我们将其相减判断一下即可。

注意到一些特殊情况，比如前后两部分的元素个数为 $0,1$，这个时候它们分别是不存在公差的，这里我们特判一下就行了。

但是题目并没有告诉我们 $a_i$ 是互不相同的，因此会出现两个数相同的情况。当 $a_1,a_2,a_3$ 中出现了相同的数，并且当前我们钦定的公差 $d=0$ 时，为了防止死循环，我们就再特判一下，即将相同的数全部拎出来。但是如果 $a_i$ 两两相同，我们就考虑拆成两个部分，因为题目要求我们保证两个子序列不为空。

总的来说就是细节比较多，如果调不动了可以参考以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int n,a[MAXN];
unordered_map<int,int> mp;
int stk[MAXN],flag[MAXN];
vector<int> res1;
void solve(int s,int d)
{
    if(!d)
    {
        int cnt=0;
        for(int i=1;i<=n;i++)
        {
            if(a[i]!=a[s])  stk[++cnt]=a[i];
        }
        int flag=0;
        for(int i=3;i<=cnt;i++)   flag|=(stk[i]-stk[i-1]!=stk[2]-stk[1]);
        if(flag||!cnt&&n<2)    return;
        if(!cnt)    stk[++cnt]=a[1];
        cout<<cnt<<'\n';
        for(int i=1;i<=cnt;i++) cout<<stk[i]<<" ";
        cout<<'\n'<<n-cnt<<'\n';
        for(int i=1;i<=n-cnt;i++)   cout<<a[s]<<" ";
        exit(0);
    }
    res1.clear();
    int val=a[s],cnt=0,lst=0,t;
    while(t=mp[val])
    {
        res1.push_back(val);
        int p=cnt;
        for(int i=lst+1;i<t;i++)    stk[++cnt]=a[i];
        for(int i=p+1;i<=cnt;i++)
        {
            if(i>2&&stk[i]-stk[i-1]!=stk[i-1]-stk[i-2]) return;
        }
        if(!(t<n&&(flag[t+1]<0||cnt>1&&t<n-1&&flag[t+1]!=stk[2]-stk[1]||cnt>1&&a[t+1]-stk[cnt]!=stk[2]-stk[1]||t<n-1&&cnt&&flag[t+1]!=a[t+1]-stk[cnt])))
        {
            int len=res1.size();
            if(len==n)  len--,stk[++cnt]=a[n];
            cout<<len<<'\n';
            for(int i=0;i<len;i++)  cout<<res1[i]<<" ";
            cout<<'\n';
            cout<<n-len<<'\n';
            for(int i=1;i<=cnt;i++) cout<<stk[i]<<" ";
            for(int i=t+1;i<=n;i++) cout<<a[i]<<" ";
            exit(0);
        }
        lst=t,val+=d;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)   cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)   mp[a[i]]=i;
    if(n==2)    return (cout<<"1\n"<<a[1]<<'\n'<<"1\n"<<a[2]),0;
    flag[n-1]=a[n]-a[n-1];
    for(int i=n-2;i>=1;i--)
    {
        if(~flag[i+1]&&a[i+1]-a[i]==a[i+2]-a[i+1])    flag[i]=flag[i+1];
        else    flag[i]=-1;
    }
    solve(1,a[2]-a[1]),solve(1,a[3]-a[1]),solve(2,a[3]-a[2]);
    cout<<"-1";
    return 0;
}
```

---

## 作者：Exp10re (赞：0)

给出一种不同于已有题解的思路。

不难想，不用 STL 库，时间复杂度 $O(n \log n)$，并且暂时是[最优解](https://www.luogu.com.cn/record/list?pid=P7205&orderBy=1&status=&page=1)。

------------

Update: 修改了代码里与题解描述不匹配的问题，题解本身因为没有事实性错误，故不作变动。

感谢 @[MrPython](https://www.luogu.com.cn/user/679581) 提供的一组 Hack。

另外，现在不是最优解了。

## 简要题意

给出一个长度为 $n$ 的数列 $h$，询问能否将其分为两个数列 $a$ 和 $b$，满足：

- $a$ 和 $b$ 的长度均不为 $0$。
- $a$ 和 $b$ 均是不下降等差数列。

给出 $a$ 和 $b$ 的构造，或者报告无解。

## 解题思路

先将 $h$ 排序，排序后一定有：对于构造出的 $a$ 以及 $b$ 中每个元素，在 $a$ 或 $b$ 中其后的元素在 $h$ 中也一定在其后面。这可以大大减小我们的工作量。

显而易见的，当 $n=2$ 或 $n=3$ 时有解且很容易构造解，这里不过多展开。

对于 $n\geq 4$ 的情况，根据鸽巢原理，如果有解，那么前三个数一定有其中两个在同一个等差数列中，共三种情况：

- $a_1$ 以及 $a_2$ 在同一个等差数列中，暂时无法确定 $a_3$。
- $a_1$ 以及 $a_3$ 在同一个等差数列中，$a_2$ 在另一个等差数列中。
- $a_2$ 以及 $a_3$ 在同一个等差数列中，$a_1$ 在另一个等差数列中。

我们记当前已经确定 $2$ 个元素的数列为 $a$，另一个为 $b$。

维护每一个等差数列的最后一个数，公差以及元素个数，那么就能很容易的判定一个数能否接到该等差数列后方。

对于每一种情况，都可以尝试从第一个无法确定的位置开始往后，使用以下方式尝试将其加入等差数列：

- 用最后一个数以及公差判断，如果这个数能加入 $a$ 中，那么加入 $a$ 后方。
- 如果不行，那么查看 $b$ 中元素个数是否小于 $2$，如果是，那么显然这个元素可以被加入 $b$ 后方，否则用最后一个数以及公差判断是否可以加入，如果是，那么就加入 $b$ 后方，否则认为在当前情况下无解。

乍一看没问题，但是这种做法**是错的**！

考虑以下数列 $h$：

$1,2,2,3,4,4,5,6,8$。

如果用上述方法来加入等差数列，那么就会发现：$1,2,3,4,5,6$ 在 $a$ 中，$2,4$ 在 $b$ 中，因为有 $8$ 的存在所以无解，然而它是有解的：$1,2,3,4,5$ 在 $a$ 中，$2,4,6,8$ 在 $b$ 中就是一组解。

由此我们可以发现：如果某个元素既可以加入 $a$ 中，又可以加入 $b$ 中，那么就要判断它是否是 $a$ 的**必需元素**。

所谓**必需元素**，就是说对于一个等差数列，删掉它会使得数列不再等差。感性理解发现其实意思就是说这个元素不是等差数列的最后一项以及第一项。

如果一个元素 $h_i$ 对于 $a$ 不必需，就表明对于构造好的 $a$，$h_{[i+1,n]}$ 中的元素都不再属于 $a$ 了。

那么就可以考虑以下做法：从后往前找到使得其是等差数列的最长后缀，记录其公差，那么对于某一位，如果其既可以加入 $a$ 中，又可以加入 $b$ 中，并且它已经是上面提到的最长后缀中的某一位，且最长后缀的公差等于 $b$ 的公差，那么显然这一位对于 $a$ 是不必需的，而且可以将其以及其后的所有元素全部加入 $b$ 中，显而易见的，它构成了一组解。

这种构造方法可以很好的规避某个元素应该属于 $b$ 却被放入 $a$ 的情形，也就是说，先前的错解加上这种做法之后就正确了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100101;
long long n,a[MAXN],al,adis,bl,bdis,bcnt,tag[MAXN],lstdis,lstl;
inline bool CheckIfExist(long long lst)
{
	long long i;
	for(i=lst;i<=n;i++)
	{
		if(a[i]==al+adis)
		{
			if(((a[i]==bl+bdis&&bdis==lstdis)||bcnt==0||(bcnt==1&&a[i]-bl==lstdis))&&i>=lstl)
			{
				bcnt+=n-i+1;
				return true;
			}
			al=a[i];
			tag[i]=1;
		}
		else if(a[i]==bl+bdis||bcnt<=1)
		{
			if(bcnt==1)
			{
				bdis=a[i]-bl;
			}
			bl=a[i];
			bcnt++;
		}
		else
		{
			return false;
		}
	}
	return true;
}
inline void print()
{
	long long i;
	if(bcnt==0)
	{
		printf("1\n%lld\n%lld\n",a[1],n-1);
		for(i=2;i<=n;i++)
		{
			printf("%lld ",a[i]);
		}
	}
	else
	{
		printf("%lld\n",n-bcnt);
		for(i=1;i<=n;i++)
		{
			if(tag[i])
			{
				printf("%lld ",a[i]);
			}
		}
		printf("\n%lld\n",bcnt);
		for(i=1;i<=n;i++)
		{
			if(!tag[i])
			{
				printf("%lld ",a[i]);
			}
		}
	}
	return;
}
int main()
{
	long long i,j;
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	if(n==2)
	{
		printf("1\n%lld\n1\n%lld",a[1],a[2]);
		return 0;
	}
	sort(a+1,a+1+n);
	lstdis=a[n]-a[n-1];
	lstl=n-1;
	for(;lstl>=1;lstl--)
	{
		if(a[lstl+1]-a[lstl]!=lstdis)
		{
			break;
		}
	}
	lstl++;
	// 1,2 in a, start from 3.
	memset(tag,0,sizeof(tag));
	al=a[2];
	adis=a[2]-a[1];
	bl=-1;
	bdis=-1;
	bcnt=0;
	tag[1]=tag[2]=1;
	if(CheckIfExist(3))
	{
		print();
		return 0;
	}
	// 1,3 in a, 2 in b, start from 4.
	memset(tag,0,sizeof(tag));
	al=a[3];
	adis=a[3]-a[1];
	bl=a[2];
	bdis=-1;
	bcnt=1;
	tag[1]=tag[3]=1;
	if(CheckIfExist(4))
	{
		print();
		return 0;
	}
	// 2,3 in a, 1 in b, start from 4.
	memset(tag,0,sizeof(tag));
	al=a[3];
	adis=a[3]-a[2];
	bl=a[1];
	bdis=-1;
	bcnt=1;
	tag[2]=tag[3]=1;
	if(CheckIfExist(4))
	{
		print();
		return 0;
	}
	printf("-1\n");
	return 0;
}
```

---


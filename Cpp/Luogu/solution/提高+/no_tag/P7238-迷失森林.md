# 迷失森林

## 题目描述

首先给出一棵以 $1$ 为根，$n$ 个结点的树，定义为「单位树」。

现有 $n$ 个结构与「单位树」完全相同的树，要将 $n$ 个树再用 $n-1$ 条边连接起来。

为方便叙述，用符号 $(a,b)$ 表示结点 $a$ 所代表树中，编号为 $b$ 的结点。

连接方式如下：

1. 将 $n$ 棵树按照「单位树」的结构摆放好。

2. 对于每个 $i(1<i\leq n)$，连接结点 $(i,1)$ 和 $(f_i,f_i)$。其中 $f_i$ 表示「单位树」中结点 $i$ 的父亲。

求将 $n$ 棵树连接后，整棵包含 $n^2$ 个结点的树中，树上两点简单路径所包含的 **结点** 个数的最大值。

## 说明/提示

#### 样例说明

样例 #1 ![](https://i.loli.net/2021/10/24/QRqkpeC7u4dYA5o.png)

样例 #2 如下图，以 $(3,4)$ 和 $(4,4)$ 为两端的路径包含 $9$ 个结点，长度为 $9$。

![](https://i.loli.net/2021/10/24/2IVR9ZXuNcdzTQp.png)

样例 #3 如下图，取 $(6,6)$ 和 $(9,9)$，包含 $11$ 个结点。

![](https://i.loli.net/2021/10/24/th8CWcbxQEGVXRm.png)

事实上，任取两个最近公共祖先为 $1$ 的橙色结点，答案均为 $11$。

#### 数据范围

**本题采取捆绑测试。**

| 子任务编号 | 分值 | $n\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ | $\times$ |
| $2$ | $12$ | $10^6$ | $v=u+1$ |
| $3$ | $6$ | $10^6$ | $u=1$ |
| $4$ | $18$ | $=2^k(k\in\mathbf{Z})$ | $u=\left\lfloor\dfrac{v}{2}\right\rfloor$ |
| $5$ | $27$ | $10^3$ | 树的形态随机 |
| $6$ | $27$ | $10^6$ | $\times$ |

对于 $100\%$ 的数据：$1\leq n\leq10^6$，结点编号介于 $1\sim n$ 之间。

**本题可能略微卡常。**

时限缩短为 1s，原因如下：

- 讨论区认为本题撞原，为防止所谓「加强版」的 $O(n\log n)$ 做法直接冲过本题，时限缩短。

- 最优解能跑进 200ms 以内。

- 由于出题人懒惰，懒得 $n\le10^6\rightarrow n\le10^7$ 只能通过缩短时限来卡掉所谓原题做法（实际上是错解）。

## 样例 #1

### 输入

```
3
1 2
1 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
9```

## 样例 #3

### 输入

```
9
1 2
1 3
1 4
1 5
2 6
2 7
5 8
5 9```

### 输出

```
11```

## 样例 #4

### 输入

```
5
1 2
2 3
2 4
2 5```

### 输出

```
8```

# 题解

## 作者：言琢დ (赞：7)

$$\large\text{「DCOI」迷失森林}$$

$$\text{Znloye}$$

$$\text{2021 年 4 月 9 日}$$

$1~\text{树的直径}$

Subtask5 满足 $n\le10^3$，因此可以 $O(n^2)$ 模拟建树。

以 $u$ 为根的子树中，$u$ 必选时树的直径为 $d_1+d_2-1$。

其中 $d_1,d_2$ 分别表示以 $u$ 为根最大、次大深度。

$2~\text{森林直径}$

**引理：森林直径必由树的直径扩展而来。**

证明：一条边 $(u,v)$ 若存在于树的直径中，必在森林中有一对应子树存在。

此时该对应子树对应的最长链一定是森林的最长链。

设 $d_1[u],d_2[u]$ 分别表示以 $u$ 为根最大、次大深度，$d[u]$ 表示以 $1$ 为根 $u$ 的深度，$v$ 是 $u$ 的孩子。

考虑到以 $u$ 为根子树的转移：

$$\begin{aligned}&d[v]=d[u]+1\\&d_2[u]\leftarrow d_1[u],d_1[u]\leftarrow d_1[v]+1~~~(d_1[u]<d_1[v]+1)\\&d_2[u]\leftarrow d_1[v]+1~~~(d_2[u]< d_1[v]+1\le d_1[u])\end{aligned}$$

记 $S(n)=\frac{n(n+1)}{2}$，以 $u$ 为根，森林直径必过 $u$ 的答案：

$$Ans_u\leftarrow S(d_1[u])+S(d_2[u])+d[u]\times(d_1[u]+d_2[u]-2)$$

最终森林直径：

$$Ans=\max_{u\in T}\{Ans_u\}+d_1[1]\times2+1$$

[$\rm code\Leftarrow$](https://www.luogu.com.cn/api/team/downloadFile/r27muq57)

---

## 作者：言琢დ (赞：5)

这里是出题人题解。

---

- 对于 $n\leq10^3$ 的数据：构造。

树的直径：一棵树上最远两点间的距离。

利用链式前向星建图，按题意建出最后的树。

求最终树的直径，加一即为所求。

---

- 对于 $n\leq10^6$ 的数据：树的直径。

考虑先找到「单位树」的直径。

性质：「单位树」中一条边 $(u,v)$，如果在树的直径中，那么最终树的直径也一定由其拓展得来。

理由是，根据构造规则，边 $(u,v)$ 一定会产生一棵树，那么这棵树包含的点一定比这个边更多，所以 **经过那棵树的答案** 一定不会比 **经过这条边的答案** 更劣。

可以自己通过作图或结合样例理解这个性质。

如果理解了该性质，那么只需要在「单位树」的直径上稍加拓展即得最终直径。

---

树的直径可以参考洛谷日报或其他博文，这里用到的是其中一类方法。

留下两个简单问题给读者思考：

1. 原树的直径需要通过数学计算得到新树的直径，这里需要保存原树直径的两端点的深度 $d_1,d_2$。
2. 有些人认为拓展成 $k$ 阶难度会大幅增加，更有意义，而通过该解法得到的数学公式，只需稍加修改即得 $k$ 阶公式。

---

## 作者：Hexarhy (赞：5)

## Preface

这里是官方题解。

**考察：树形 dp 、树的直径。** 适合普及组选手练习基础。

其实这题的是想加强到 $k$ 阶（把上一阶的“大树”作为新的单位树重复操作），但最后还是这样。

部分分做法请私信出题人@诡辩巫师。 

## Solution

比较套路的树形 dp。

设 $f_i$ 表示在 $(i,1)$ 的子树中，以 $(i,1)$ 为**端点**的最长链长度。

定义 $dep_{\max}$ 为一棵单位树中深度最大的点的深度，$dep_i$ 为一棵单位树中节点 $i$ 的深度，$s_i$ 为单位树上 $i$ 的**直接儿子**。这些都可以在一棵单位树一次 dfs 得到。

考虑 $f_i$ 的贡献从哪里来。简单地观察可以得出贡献来源：

- $(i,1)$ 所代表的一棵单位树，贡献为 $dep_{\max}$。
- $s_i$ 所代表的单位树，贡献为 $f_{s_i}+dep_i$。

那么转移为：
$$
f_i=\max\{f_{s_i}+dep_i\}
$$
至于边界值，就是叶节点的值，显然就是该叶节点所代表的单位树的 $dep_{\max}$。

但是 $f_i$ 并不是题目要求的答案。对于节点 $(i,1)$ 所在子树：

- 其直径为最大的两个 $f_{s_i}$ 拼起来，即 $\max\{f_{s_i}\}+\max'\{f_{s_i}\}+1$。$\max'$ 表示次大值。$+1$ 是节点 $(i,i)$。

那么在从下往上维护 $f_i$ 的同时，顺便更新答案 $\rm ans$。

最后还要特判一下，可能编号 $1$ 节点的最大值不是两个 $f_{s_i}$ 拼起来的，而是一个最大的 $f_{s_i}$ 和自己所代表的单位树深度的贡献（比如没有次大值），因此要把答案再与 $f_1+dep_{\max}-1$ 取最大值。$-1$ 是因为根节点算了两遍。

上述过程都可以在一棵单位树中完成，时间复杂度 $O(n)$。

## Code

**本代码需要 C++11。**

```cpp
void dfs1(cint& u,cint& Fa)
{
    fa[u]=Fa;
    dep[u]=dep[Fa]+1;
    for(const auto& v:edge[u])
    {
        if(v==Fa)   continue;
        dfs1(v,u);
    }
}
void dfs2(cint& u)
{
    if(edge[u].size()==1 && u!=1)//叶节点
    {
        f[u]=maxdep;
        return;
    }
    ll max1=0,max2=0;//最大值和次大值
    for(const auto& v:edge[u])
    {
        if(v==fa[u])    continue;
        dfs2(v);
        if(f[v]>max1)   max2=max1,max1=f[v];
        else if(f[v]>max2)  max2=f[v];
        f[u]=max(f[u],f[v]+dep[u]);
    }
    ans=max(ans,max1+max2+1);
}
int main()
{
    read(n);
    for(register int i=1;i<n;i++)
    {
        int u,v;read(u,v);
        edge[u].emplace_back(v);
        edge[v].emplace_back(u);
    }
    dfs1(1,1);
    maxdep=*max_element(dep+1,dep+1+n);
    dfs2(1);
    cout<<max(ans,f[1]+maxdep-1)<<endl;//最后特判
    return 0;
}
```

---

## 作者：JackMerryYoung (赞：4)

# 前言

第一眼看这道题时，还以为是 DFS。~~（太蒻了）~~

结果看了标签，树形 DP 好题。

看到这里，有些人又会说，树形 DP 是啥，咋写？

如果对树形 DP 不太熟悉的同学，可以先去洛谷做一些题目，下面推荐一些经典的好题：

- [P2014 [CTSC1997]选课](https://www.luogu.com.cn/problem/P2014) 

经典好题，这里不再赘述了，想学的先 AC 这道题。

- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

极其良心~~变态~~的一道题目，在这里表扬出题人。

- [P7103 「C.E.L.U-01」族谱树](https://www.luogu.com.cn/problem/P7103)

名字长得像拓扑排序，但是个 DP。

- [P7846 「dWoi R2」Arcade hall / 街机厅](https://www.luogu.com.cn/problem/P7846)

这道题一看就知道是树的直径问题，只不过树变成了森林。

# 解法

有些人可能不知道树的直径问题，树的直径指的是树中的最远的两点间距离。

一看这个题面，可能有人认为这个题很难，什么“单位树”啊、“简单路径”啊、看起来对一些刚学图论的萌新很不友好。

但是，这题并没有很难。

设 $\Large{f_i}$ 为以第 $i$ 棵单位树的的第 $1$ 个节点，也就是题目描述中的二元组 $(i, 1)$，为连接操作的链的一端所获得的最大直径。

显而易见，$\Large{f_i}$ 的值从两个来源贡献而来。

第一个是单位树的最大直径，即为代码中的 $maxdepth$，这个很容易预处理得来。（见我代码中的深搜）

第二个是单位树的儿子，这里叫 $son$，还有自己到根节点的深度 $depth_i$。

$depth_i$ 也在 DFS 里顺便求解，下面列出树形 DP 的转移方程：

$$
f_i = \max\{maxdepth, f_{son} + depth_i\}
$$

这里再给出树形 DP 的一般形态。

``` cpp
void dfs(int u, int fa)
{
	f[u] = __start_value;
	for(int i = head[u]; i; i = edge[i].nxt)
	{
		int v = edge[i].to;
		if(fa == v) //判重
			continue;
		
		dfs(v, u); //下一层
		f[u] = max(f[u], f[v] + w);
	}
}
```

言归正传，这题到这里还没有结束，$f_i$ 并不是我们要的答案。

这个时候维护两个值，最大子树直径与次大子树直径，即为代码中的 $max1$ 与 $max2$。

将这两个值相加并加上 $1$（因为要算上自己），取最值即可。

方程如下：

$$ans = \max\{max1 + max2 + 1\}$$

至于放在哪里，在 DP 的时候顺带维护一下即可。

至此，这道题到现在总算完结了，是不是难度还好呢？

# 代码

~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code...

没写链式前向星，看题解区大佬们都没写，也就没写...

``` cpp
#include <bits/stdc++.h>
using namespace std;
int N;
vector<int> edge[1000005];
long long f[1000005], ans;
int depth[1000005];
int maxdepth;

void get_depth(int u, int v);
void dfs(int u, int v);

int main()
{
	cin >> N;
	for(int i = 1; i < N; i ++)
	{
		int x, y;
		cin >> x >> y;
		edge[y].push_back(x);
		edge[x].push_back(y);
	}

	get_depth(1, 1);
	dfs(1, 1);
	ans = max(ans, f[1] + maxdepth - 1);
	cout << ans << endl;
	return 0;
}

void get_depth(int u, int v)
{
	depth[v] = depth[u] + 1;
	maxdepth = max(maxdepth, depth[v]);
	for(int i = 0; i < edge[v].size(); i ++)
	{
		int to = edge[v][i];
		if(u == to) //判重
			continue;
		
		get_depth(v, to);
	}
}

void dfs(int u, int v)
{
	f[v] = maxdepth;
	long long max1 = -1, max2 = -1;
	for(int i = 0; i < edge[v].size(); i ++)
	{
		int to = edge[v][i];
		if(u == to) //判重
			continue;
		
		dfs(v, to);
		if(f[to] > max1) 
		{
			max2 = max1;
			max1 = f[to];
		}
		else if(f[to] > max2)
		{
			max2 = f[to];
		}
		f[v] = max(f[v], f[to] + depth[v]);
	}

	ans = max(ans, max1 + max2 + 1);
}
```

# 后言

阅读完这篇题解，你可能对于树状 DP 有了初步的了解，后面的 DP 将会越来越复杂，不仅复杂在状态的转移，更在优化的繁琐。

在这里，本人衷心祝愿每一位学习 OI 的人都不要因为一时的困难而放弃，越来越强！

---

## 作者：seztto (赞：4)


这里是民间题解。

---

### 题意

（已经很明白了，给个图）

如题:

![](https://cdn.luogu.com.cn/upload/image_hosting/y9mdw1s4.png)

黑色的是单位树。

### 分析

求树的直径有两种方式：dfs 和树形 DP ，然而这题这题 $n=5 \times 10^5$，暴力建边 dfs 复杂度 $O(n^2)$，显然不行。

考虑树形 DP，与普通的树型 DP 求直径方法一样，设 $f_i$ 表示在 $(i,1)$ 的子树内，以 $(i,1)$ 为一端时的最长路径。

先定义单位树内深度最大的点深度为 $maxa$（单位树的根节点深度为 $1$），单位树上点 $i$ 的直接子节点为 $son_i$。

不难发现，$f_i$ 有两个来源，一个是该点 $i$ 所代表的单位树贡献而来，值为 $maxa$，另一个是点 $son_i$ 所代表的单位树贡献而来，值为 $f_{son_i}+dep_i$，其中 $dep_i$ 表示点 $i$ 在单位树中的深度。

即：

$$\large f_i=\max\{maxa,f_{son_i}+dep_i\}$$

同时，与树形 DP 求直径一样，在递推同时也要用子树内直径更新答案。

观察推理后可以知道，子树中直径也只有两种形成方式，一是将两个 $f_{son_i}$ 拼起来，二是将一个 $f_{son_i}$ 和点 $i$ 所代表的单位树中以 $(i,i)$ 为根节点的子树拼起来（向上的不用考虑是因为会在上面一层被考虑），但是这种情况不会比在上面一层考虑更优（这似乎很显然），所以只需要在最上面一层（即 $f_1$）考虑。

综上所述，得：

$$\large ans=\max\{ans,\max\{f_{son_i}\}+smax\{f_{son_i}\}+1\}$$

$$\large ans=\max\{ans,\max\{f_1\}+maxa-1\}$$

其中，$smax$ 表示次大值。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector> 
using namespace std;
vector <int> edge[1000005];
long long n,x,y,ans,dep[1000005],f[1000005],maxa;
void dfs1 (int x,int y)
{
	dep[x]=dep[y]+1;
	maxa=max(maxa,dep[x]);
	int len=edge[x].size();
	for (int i=0;i<len;i++)
	{
		if (y==edge[x][i])
			continue;
		dfs1(edge[x][i],x);
	}
	return ;
}
void dfs (int x,int y)
{
	f[x]=maxa;
	int len=edge[x].size();
	long long max1=0,max2=0;
	for (int i=0;i<len;i++)
	{
		if (edge[x][i]==y)
			continue;
		dfs(edge[x][i],x);
		f[x]=max(f[x],dep[x]+f[edge[x][i]]);
		if (max1<f[edge[x][i]])
		{
			max2=max1;
			max1=f[edge[x][i]];
		}
		else
			if (max2<f[edge[x][i]])
				max2=f[edge[x][i]];
	}
	ans=max(ans,max1+max2+1);
	return ;
}
int main()
{
	cin>>n;
	for (int i=1;i<n;i++)
	{
		cin>>x>>y;
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	dfs1(1,1);
	dfs(1,1);
	ans=max(ans,f[1]+maxa-1);
	cout<<ans;
	return 0;
}
```

---

## 作者：jiangjiangQwQ (赞：3)

### 题意理解
给出一棵单位树，然后将一棵单位树看作一个结点，按照单位树的结构构建一棵更大的“单位树”。实际上你可以把这个建树过程理解为俄罗斯套娃。

![](https://cdn.luogu.com.cn/upload/image_hosting/3l0cnwty.png)
### 思路
答案所求就是大单位树的直径，这个可以使用树形 $\text{dp}$ 或者两次 $\text{dfs}$ 解决。如果是直接暴力求解的话，时间复杂度将达到 ${O(n^2)}$。设 $f_i$ 表示以 $(i,1)$ 为端点的最长链的长度(注意最长链不等同于直径)，通过观察上图可发现如果一个结点连着另一颗子单位树的话，从子单位树转移一定不劣于从当前单位树转移，所以 $f_i=\max(f_i,f_j+dep_u)$，叶结点单位树的 $f_i=maxdep$。$dep_i$ 为小单位树结点深度。记答案为 $ans$，$max1_i$ 为 $f_j$ 的最大值，$max2_i$ 为次大值，更新 $ans=\max(ans,max1_i+max2_i)$，最后将 $ans$ 与 $f_1+maxdep$ 取个 $\max$，因为当次大值不存在时就得从最大深度转移了。

---

## 作者：RedLycoris (赞：3)

这里是验题人的思路（不同于官方题解）

---

将所有的树都缩成一个点。
对于第 $i$ 棵树，如果与第 $j$棵树有边，那么 $dist_{i,j}$ 为第 $i$ 棵树的 $i$ 号点到第$j$ 棵树的 $j$ 号点的距离。

叶子节点要特判。

尤其要特判当1号节点为叶子（只有一条出边）时的情况。

最后对新图求直径即可。

Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define mp make_pair
#define ri register int
#define ld long double
using namespace std;
const int maxn=100004;
char buffer[maxn],*S,*T;
inline char Get_Char(){
    if(S==T){
        T=(S=buffer)+fread(buffer,1,maxn,stdin);
        if(S==T)return EOF;
    }
    return *S++;
}

inline int read(){
    char c;
    ri re=0,f=0;
    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;
    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();
    if(f)return -re;
    return re;
}

inline void read(int&x){
    char c;
    ri re=0,f=0;
    for(c=Get_Char();c<'0' or c>'9';c=Get_Char())if(c=='-')f=1;
    for(;c>='0' and c<='9';)re=(re<<1)+(re<<3)+(c-'0'),c=Get_Char();
    if(f)x=-re;
    else x=re;
}
const int mxn=1e6+6;
vector<int>f[mxn];
vector<pair<int,int> >g[mxn];
int n,root;
int u[mxn],v[mxn];
int pa[mxn];
int dep[mxn];
int max_deep;
int mxdp[mxn];
inline void dfs1(int x,int par=-1,int deep=1){
	mxdp[x]=1;
	dep[x]=deep;pa[x]=par;
	max_deep=max(max_deep,deep);
	for(ri i=0;i<f[x].size();++i){
		ri y=f[x][i];
		if(y!=par)dfs1(y,x,deep+1),mxdp[x]=max(mxdp[x],mxdp[y]+1);
	}
}
ll dist[mxn];
inline void dfs2(int x,int par=-1,ll dst=0){
	dist[x]=dst;
	for(ri i=0;i<g[x].size();++i){
		ri y=g[x][i].first;ll w=g[x][i].second;
		if(y!=par)dfs2(y,x,dst+w);
	}
}
inline void solve(){
	read(n); 
	for(ri i=1;i<n;++i){
		read(u[i]),read(v[i]);
		f[u[i]].push_back(v[i]);
		f[v[i]].push_back(u[i]);
	}
	root=1;
	dfs1(root);//对原树进行处理
	for(ri i=1;i<n;++i){   //将树缩成点
		if((u[i]==1 or v[i]==1) and f[1].size()==1){
			int t;
			if(u[i]==1)t=v[i];
			else t=u[i];
			g[u[i]].push_back(mp(v[i],max_deep+dep[t]-1));
			g[v[i]].push_back(mp(u[i],max_deep+dep[t]-1));
		}else if(f[u[i]].size()==1 or f[v[i]].size()==1){
			g[u[i]].push_back(mp(v[i],max_deep));
			g[v[i]].push_back(mp(u[i],max_deep));
		}else if(u[i]==pa[v[i]]){
			g[u[i]].push_back(mp(v[i],dep[v[i]]));
			g[v[i]].push_back(mp(u[i],dep[v[i]]));				
		}else{
			g[u[i]].push_back(mp(v[i],dep[u[i]]));
			g[v[i]].push_back(mp(u[i],dep[u[i]]));
		}
	}
	memset(dist,63,sizeof(dist)); //求直径
	dfs2(root);
	ri place;
	place=1;
	for(ri i=1;i<=n;++i)if(dist[i]>dist[place])place=i;
	memset(dist,63,sizeof(dist));
	dfs2(place);
	ll Max=0;
	for(ri i=1;i<=n;++i)Max=max(Max,dist[i]);
	printf("%lld\n",Max+1);
}
int main(){
	ios_base::sync_with_stdio(false);
	int T=1;//cin>>T;
	for(;T--;)solve();
	return 0;
}
```

---


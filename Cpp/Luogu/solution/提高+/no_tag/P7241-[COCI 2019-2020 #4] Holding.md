# [COCI 2019/2020 #4] Holding

## 题目背景

Ivica 有一个由 $N$ 家克罗地亚公司组成的集团，但他的集团正面临着困难。他的企业承受着巨额的负债，所以政$ $府派遣律师没收了他的一切财产。

但我们发现，尽管他有巨额债务在身，他依然与政$ $府达成协议，留住了部分企业。他留住的是哪些？我们也知道了。

## 题目描述

律师们把 Ivica 的公司的 $N$ 份债务文件摆在桌上。第一家公司的债务为 $A_1$ ，第二家公司的债务为 $A_2$ ，依次类推。

Ivica 与政$ $府达成协议，使它留下桌上 $[L,R]$ 区间的所有文件所对应的公司，但他需要承担 $A_L,A_{L+1}\ldots A_R$ 的所有债务，其中 $L$ 和 $R$ 代表桌子上一系列文件中的位置。

幸运的是，律师们也是腐败。他们可以让他以 $|i-j|$ 的价格交换当前放在位置 $i$ 和位置 $j$ 的文件。

Ivica 有点绝望。他口袋里只有 $K$ 元钱，他现在想把这些钱花在这里，使得他的需要承担的债务尽可能少。

请帮他达成目标。 

## 说明/提示

【数据规模与约定】

| 子任务编号 | 特殊限制         | 分值 |
| ---------- | ---------------- | ---- |
| $1$        | $N\le 13$，$R=N$ | $20$ |
| $2$        | $N\le 50$，$R=N$ | $30$ |
| $3$        | $N\le 50$        | $30$ |
| $4$        | 无特殊限制       | $20$ |

对于 $100\%$ 的数据，保证 $1\le N\le 100$，$1\le L\le R\le N$，$1\le K\le 10^4$，$1\le A_i\le 10^6$。

【提示与帮助】

**题目译自 [COCI 2019/2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #4](https://hsin.hr/coci/archive/2019_2020/contest4_tasks.pdf) T3 Holding**

在 COCI 中，本题分值为 $110$ 分。

## 样例 #1

### 输入

```
3 2 2 1
1 2 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 3 3
21 54 12 2 0```

### 输出

```
12```

## 样例 #3

### 输入

```
6 4 6 100
1 2 3 4 5 6```

### 输出

```
6```

# 题解

## 作者：离散小波变换° (赞：8)

## 题解

容易发现交换 $i,j$ 两个元素并花费 $|i-j|$ 元，相当于进行了 $|i-j|$ 次邻项交换。因此原命题等价于进行不超过 $k$ 次邻项交换使得 $[l, r]$ 区间内的元素之和最小。

我们考虑在最终序列里，有哪些元素被选择进 $[l, r]$。将这些元素在原数列中的下标按照从小到大排列记为 $p_1,p_2,\cdots,p_m$，那么在最优决策下，$p_1$ 移动到了 $l$，$p_2$ 移动到了 $l+1$，……，$p_i$ 移动到了 $l+i-1$。为什么？假定移动两个元素 $i,j$ 时，路径发生了交叉，那么必然发生了交换 $i,j$ 两个元素的情形，这一定会更劣。

那么 $\mathrm{dp}$ 设计就非常简单。设前 $i$ 个数，选择了 $j$ 个，花费了恰好 $t$ 元的情况下，选出的元素的最小值为 $f_{i,j,t}$，容易得到状态转移方程：

$$f_{i,j,t}=\min\{f_{i-1,j,t},f_{i-1,j-1,t-|l+j-i-1|}+a_i\}$$

直接暴力转移，时间复杂度为 $\mathcal O(n^2k)$。使用滚动数组优化空间，空间复杂度为 $\mathcal O(nk)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 1e9 + 1;
const int MAXN= 100 + 3;
const int MAXM= 1e4 + 3;
int F[2][MAXN][MAXM], o, n, m, l, r, t, A[MAXN];
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int main(){
    n = qread(), l = qread(), r = qread(), m = qread();
    t = r - l + 1;
    up(1, n, i) A[i] = qread();
    up(0, t, i) up(0, m, j)
        F[0][i][j] = F[1][i][j] = INF;
    F[o][0][0] = 0;
    up(1, n, i) {
        up(0, t, j) up(0, m, k){
            int w = abs(l + j - i - 1);
            F[!o][j][k] = F[o][j][k];
            if(k >= w && j >= 1)
                F[!o][j][k] = min(F[!o][j][k], F[o][j - 1][k - w] + A[i]);
        }
        o ^= 1;
    }
    int ans = INF;
    up(0, m, i) ans = min(ans, F[o][t][i]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：TMLY114514 (赞：5)

## **题解：P7241 [COCI2019-2020#4] Holding**

---


观察题目性质，发现互换的债务不一定是连续的，考虑对于区间内外两个序列 dp 。 

不妨设序列 $a$ 为在区间 $[l,r]$ 内的序列 $A$ 构成的子段，序列 $b$ 为 $A$ 的其它元素拼成的子段。

发现有个小困难，可能会出现 $a_i$ 与 $b_j$ 交换，但是又有 $a_k(k>i)$ 与 $b_l(l<j)$ 交换，此时可能会出现选到重复元素之类的问题，之前的 dp 值无法确定。

但是仔细想想，不难发现，此时可以直接将 $a_i$ 与 $b_l$ 交换，$a_k$ 与 $b_j$ 交换，显然这样是不劣的。于是我们可以在 $a$ 与 $b$ 中配对出两个长度相同的子序列，用类似求 LCS 的转移方法。对于花费，可以加一维用类似 01背包 的方式保证转移正确性。

设 $f_{i,j,k}$ 表示选到 $b$ 的前 $i$ 个数与 $a$ 的前 $j$ 个数，花费为 $k$ 的减少的债务的最大值，$pos_x$ 表示 $x$ 在序列 $A$ 中的下标。

易得转移：

$f_{i,j,k}=\max{\{ f_{i-1,j,k},f_{i,j-1,k}\}}$

$f_{i,j,k}=\max{\{ f_{i-1,j-1,k-\operatorname{abs}(pos_i-pos_j)}+a_j-a_i\}}$ $(k\ge \operatorname{abs}(pos_i-pos_j))$

其实代码里为了方便 $a$ 直接用 $A$ 的下标了，不过原理应该是一样的。

---

### **代码：**


```cpp
void cmax(int &x,const int y){
	if(x<y)x=y;
}
int f[N][N][N*N];
int s,a[N],b[N],top;
int main(){
	read(n,l,r,m);
	for(int i=1;i<=n;++i){
		read(a[i]);
		if(i<l||i>r)b[++top]=i;
	}
	for(int i=l;i<=r;++i)s+=a[i];
	f[0][l-1][0]=0;
	for(int i=1;i<=top;++i){
		for(int j=l;j<=r;++j)
			for(int k=m;~k;--k){
				cmax(f[i][j][k],f[i-1][j][k]);
				cmax(f[i][j][k],f[i][j-1][k]);
				if(k>=abs(b[i]-j))cmax(f[i][j][k],f[i-1][j-1][k-abs(b[i]-j)]+a[j]-a[b[i]]);
			}
	}
	for(int i=0;i<=m;++i)ans=min(ans,s-f[top][r][i]);
	write(ans);
```

---

## 作者：ran_qwq (赞：3)

没有退火的题解？

---
先考虑知道确定哪些数放在 $[L,R]$ 区间内之后，怎么算最小花费。

显然是把 $[1,L)$ 所有要放的数放在 $[L,R]$ 的最左边，把 $(R,n]$ 的放在最右边，中间放 $[L,R]$ 的。

这样就可以 $O(n)$ 算最小花费了。

枚举放在 $[L,R]$ 的数，我们就得到了一个 $O(n2^n)$ 的算法。

---
上次模拟赛也是 $n\le100$，有些人用退火直接冲过去了。而且这道题要算的是最小值不是方案数，所以考虑退火。

退火维护哪些数放在 $[L,R]$，每次交换两个位置（把一个数踢出 $[L,R]$，再把另一个数加进来）。

但和普通退火不一样的是，要时刻保证最小花费 $\le K$。

注意如果 $L=1,R=n$ 不能退火，直接输出 $\sum A_i$（因为找不到一个在 $[L,R]$ 外面的数）。

小优化：每次退火清空最小值。

```cpp
int n,l,r,m,sum,ans,a[N],b[N];
inline int check(int x,int y)
{
	b[x]^=1,b[y]^=1;int j=l,k=r,cnt=0;
	for(int i=1;i<l;i++)
		if(b[i]) cnt+=j-i,j++;
	for(int i=n;i>r;i--)
		if(b[i]) cnt+=i-k,k--;
	for(int i=l;i<=r;i++)
		if(b[i])
		{
			int p=abs(i-j),q=abs(i-k);
			if(p<=q) cnt+=p,j++;
			else cnt+=q,k--;
		}
	b[x]^=1,b[y]^=1;return cnt<=m;
}
void SA()
{
	sum=0,memset(b,0,sizeof b);int Ans=INF;
	for(int i=l;i<=r;i++) sum+=a[i],b[i]=1;
	for(double temp=1e6;temp>1e-6;temp*=0.996)
	{
		int x,y;do x=rand()%n+1,y=rand()%n+1;
		while(b[x]==b[y]||!check(x,y));
		if(b[x]) swap(x,y);
		b[x]=1,b[y]=0,sum+=a[x]-a[y];int del=sum-Ans;
		if(del<0) Ans=sum;
		else if(exp(-del/temp)<1.0*rand()/RAND_MAX) b[x]=0,b[y]=1,sum-=a[x]-a[y];
	}
	ans=min(ans,Ans);
}
void solve()
{
	srand(time(0)),n=read(),l=read(),r=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read(); 
	for(int i=l;i<=r;i++) ans+=a[i];
	if(l==1&&r==n) write(ans,""),exit(0);
	while(clock()/(double)CLOCKS_PER_SEC<=1) SA();
	write(ans,"");
}
```

---

## 作者：MiRaciss (赞：3)

# dp

先看前面两个测试点，n=r。

设$dp[i][j][k][f]$，$f=1$或$0$。

表示在范围外找$1\sim i$，在范围内找$l \sim j$,并且花费小于等于$k$时可以减少的债务的最大值。$f=1$表示第$i$个和第$j$个要进行交换，$f=0$表示第$i$个和第$j$个不进行交换。

那么很容易得到dp转移式：

$$ dp[i][j][k][1]=\max\left\{
\begin{aligned}
dp[i-1][j-1][k-\vert i-j\vert][0] \\
dp[i-1][j-1][k-\vert i-j\vert][1]
\end{aligned}
\right.+\vert a_i-a_j\vert
$$

$$ dp[i][j][k][0]=\max\left\{
\begin{aligned}
dp[i-1][j][k][1] \\
dp[i-1][j][k][0] \\
dp[i][j-1][k][1] \\
dp[i][j-1][k][0]
\end{aligned}
\right.
$$

那么接下来考虑$l<n$的情况

说明右边也有一个区间在范围外，所以我们直接仿照前面的dp式，最后再暴力将$l\sim r$的区间分成两段，一段用$l$以前的dp式维护，另一段用$r$以后的维护，从中取最大值即可。

代码如下(码风轻喷qwq)

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,l,r,K;

int dp[105][105][10005][2];
int dp_2[105][105][10005][2];
int a[105];

int main(){
//	freopen("holding.in","r",stdin);
//	freopen("1.ans","w",stdout);
	cin>>n>>l>>r>>K;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int sum=0;
	for(int i=l;i<=r;i++)
		sum+=a[i];
	for(int i=1;i<=l-1;i++){
		for(int j=l;j<=r;j++){
			for(int k=1;k<=K;k++){
				if(k>=j-i)
					dp[i][j][k][1]=max(dp[i-1][j-1][k-(j-i)][1],dp[i-1][j-1][k-(j-i)][0])+a[j]-a[i];
				dp[i][j][k][0]=max(max(dp[i-1][j][k][1],dp[i-1][j][k][0]),max(dp[i][j-1][k][1],dp[i][j-1][k][0]));
//				printf("dp[%d][%d][%d][1]=%d ,dp[%d][%d][%d][0]=%d\n",i,j,k,dp[i][j][k][1],i,j,k,dp[i][j][k][0]);
			}
		}
	}
	
	for(int i=n;i>=r+1;i--){
		for(int j=r;j>=l;j--){
			for(int k=1;k<=K;k++){
				if(k>=i-j) 
					dp_2[i][j][k][1]=max(dp_2[i+1][j+1][k-(i-j)][1],dp_2[i+1][j+1][k-(i-j)][0])+a[j]-a[i];
				dp_2[i][j][k][0]=max(max(dp_2[i+1][j][k][1],dp_2[i+1][j][k][0]),max(dp_2[i][j+1][k][1],dp_2[i][j+1][k][0]));
//				printf("dp_2[%d][%d][%d][1]=%d ,dp_2[%d][%d][%d][0]=%d\n",i,j,k,dp_2[i][j][k][1],i,j,k,dp_2[i][j][k][0]);
			}
		}
	}
	
	int ans=0;
	
	for(int i=l-1;i<=r;i++){
		for(int k=0;k<=K;k++){
			int now;
			now=max(dp[l-1][i][k][0],dp[l-1][i][k][1])+max(dp_2[r+1][i+1][K-k][0],dp_2[r+1][i+1][K-k][1]);
//			printf("%d %d %d\n",i,k,sum-now);
			ans=max(ans,now);
		}
	}
	printf("%d",sum-ans);
	return 1;
} 

```

然后，我们会发现最后一个点会MLE，直接滚动数组，滚掉第一维即可。




---

## 作者：TJB_LHY (赞：2)

### 形象化题意

给定一个长度为 $n$ 的序列 $a$，以及三个整数 $l,r,k$。你可以花费 $\operatorname{abs}(i-j)$ 的代价交换 $a_i$ 和 $a_j$。你可以使用最多 $K$ 的代价，使得 $\sum_{i=l}^{r}a_i$ 最小，输出其最小值。

# 思路

先看数据范围：$n\le100$，$K\le10^4$，很小。~~尝试暴力~~。下面贴上同学的暴力代码，~~就可以成功得到 30pts 了~~！

```cpp
#include<bits/stdc++.h>\\code by xujun(id:699930)
using namespace std;
long long n,l,r,k,minn=500050050;
long long s[200];
bool pd[200];
void dfs(long long t,long long sumn,long long mi){
	if(t>n){
		if(sumn==r-l+1){
			long long ans=0,p=n;
			for(int o=n;o>=1;o--){
				if(pd[o]==1){
					ans+=abs(o-p);
					p--;
				}
			}
			if(ans<=k)minn=min(minn,mi);
		}
		return;
	}
    pd[t]=1;
	dfs(t+1,sumn+1,mi+s[t]);
    pd[t]=0;
	dfs(t+1,sumn,mi);
}
int main()
{
	cin>>n>>l>>r>>k;
	for(int i=1;i<=n;i++)cin>>s[i];
	dfs(1,0,0);
	cout<<minn;
	return 0;
}
```

考虑优化，我们画张图看看（圆中的数字表示下标，曲线附近的数字是距离）。![](https://cdn.luogu.com.cn/upload/image_hosting/wz3404y0.png)![](https://cdn.luogu.com.cn/upload/image_hosting/z338rh7x.png)

可以发现若交换同样的几个 $a_i$，代价不变。这不就满足无后效性吗？所以我们就可以舍弃第 $2$ 张图，设 $dp_{i,j,k}$ 表示在 $a_1,a_2\dots a_i$ 中，已经选择了 $j$ 个交换至 $[l,l+j-1]$ 区间内，花费 $k$ 的代价时的最小负债。由于不选则交换时没有变化所以此时 $dp_{i,j,k}=dp_{i-1,j,k}$；交换时因为要花费 $\operatorname{abs} (i-(l+(j-1)))$ 的代价，所以化简得到状态转移方程：$dp_{i,j,k}=\min(dp_{i-1,j-1,k-\operatorname{abs} (i-l-j+1)}+a_{i},dp_{i-1,j,k})$ 有了方程，剩下的就很简单啦。

```cpp
#include <bits/stdc++.h>
#define abs(a) ((a)>=0?(a):-(a))
using namespace std;
void read(int &x) {
	x=0;
	char y=getchar_unlocked();
	bool flag=0;
	while(y<'0' || y>'9') {
		if(y=='-')flag=1;
		y=getchar_unlocked();
	}
	while((y>='0' && y<='9')) {
		x=x*10+(y-'0');
		y=getchar_unlocked();
	}
	if(flag)x=-x;
}
void write(int x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else {
		write(x/10);
		putchar(x%10+'0');
	}
}//快读快写
int n,l,r,K,a[105],dp[102][102][10005],minn=1e9;
int main() {
    read(n);
    read(l);
    read(r);
    read(K);
    for(int i=1;i<=n;i++)read(a[i]);//输入
    for(int i=0,j,k;i<=n;i++){
        for(j=0;j<=r-l+1;j++)
            for(k=0;k<=K;k++)dp[i][j][k]=0x3f3f3f3f;
        dp[i][0][0]=0;
    }//初始化，memset主页空间太大
    for(int i=1,j,k;i<=n;i++){
        for(j=1;j<=r-l+1;j++){
            for(k=0;k<=K;k++){
                if(k>=abs(i-l-j+1))dp[i][j][k]=min(dp[i][j][k],dp[i-1][j-1][k-abs(i-l-j+1)]+a[i]);
                dp[i][j][k]=min(dp[i][j][k],dp[i-1][j][k]);//转移
            }
        }
    }
    for(int k=K;k>=0;k--)minn=min(minn,dp[n][r-l+1][k]);//取最小值
    write(minn);//输出
	return 0;
}
```

~~有人提交后就要问了：~~ 为什么代码会 MLE？？？我们再次观察发现 $dp$ 数组开得太大了。由状态转移方程可知，转移只和上一层有关，所以我们直接滚动数组优化（记得倒序枚举 $j$）。

```cpp
#include <bits/stdc++.h>
#define abs(a) ((a)>=0?(a):-(a))
using namespace std;
void read(int &x) {
	x=0;
	char y=getchar_unlocked();
	bool flag=0;
	while(y<'0' || y>'9') {
		if(y=='-')flag=1;
		y=getchar_unlocked();
	}
	while((y>='0' && y<='9')) {
		x=x*10+(y-'0');
		y=getchar_unlocked();
	}
	if(flag)x=-x;
}
void write(int x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else {
		write(x/10);
		putchar(x%10+'0');
	}
}//快读快写
int n,l,r,K,a[105],dp[105][10005],minn=1e9;
int main() {
	read(n);
	read(l);
	read(r);
	read(K);
	for(int i=1; i<=n; i++)read(a[i]); //输入
	memset(dp,0x3f,sizeof dp);//memset占用空间再大也不怕
	dp[0][0]=0;//初始化
	for(int i=1; i<=n; i++) {
		for(int j=r-l+1; j>=1; j--) {
			for(int k=K; k>=abs(i-l-j+1); k--) {
				dp[j][k]=min(dp[j][k],dp[j-1][k-abs(i-l-j+1)]+a[i]);//转移
			}
		}
	}
	for(int k=K; k>=0; k--)minn=min(minn,dp[r-l+1][k]); //取最小值
	write(minn);//输出
	return 0;
}
```

完结撒花～

---

## 作者：jiangjiangQwQ (赞：2)

### 思路
发现一次性交换 $x,y$ 两份文件等价于进行邻项交换。设 $a,b \in [l,r]$，$i,j \notin [l,r]$，且 $1\leq i<j<a<b$。交换 $i,b$ 和 $j,a$ 等价于 $i,a$ 与 $j,b$，因为最终贡献都相同，所以 dp 转移是单调的从前往后，设 $f_{i,j,k}$ 表示前 $i$ 个文件，交换 $j$ 次，花费 $k$ 元的最小负债，$x = \left|l+j-i-1  \right|$，转移为 $f_{i,j,k}=\min(f_{i-1,j,k},f_{i-1,j-1,k-x})$。

---

## 作者：ClearluvXL (赞：2)

# Holding

## 思路

根据思考。将 $(i,j)$ 直接交换，相当于 $i$ 到 $j$ 一直邻项交换。

如果交换的路径呈现包含，那么不如交换一下各自交换的的对象，使得 $k$ 更小。

![](https://cdn.luogu.com.cn/upload/image_hosting/dg7sbs9g.png)

为什么呢？会使得 $k$ 更小呢？因为我们是邻项交换的，所以无论范围大的那对是先还是后，都会使得范围小的那对向左移动一格，那么就需要 $+2$ 步来挪回原位。

其实就算不是邻项交换，那么交换了也不会使得答案更差。

所以，假设我们现在选择了 $k$ 个数放进区间 $[l,r]$。那么在区间 $[l,r]$ 的顺序的顺序和他们原本在序列中的序列相同。

设计 DP 为 $f_{i,j,k}$ 表示到第 $i$ 个数为止，一共选择了 $j$ 个数进入 $[l,r]$，并且花费了 $k$ 步时区间 $[l,r]$ 的最小价值。

考虑转移。

- 首先可以不选 $i$。那么 $f_{i,j,k}=f_{i-1,j,k}$。
- 否则可以选 $i$，那么此时 $f_{i,j,k}=\min(f_{i,j,k},f_{i-1,j-1,k-dis(i,l+j-1)}+a_{i})$。

时间复杂度 $O(n^{2}\times k)$。利用滚动数组，空间可以优化为 $O(n\times k)$。

## 代码

```c++
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N=110;
const int K=1e4+10;
const int INF=0x3f3f3f3f;

typedef long long ll;
typedef pair<int,int> pii;

int n,l,r,maxf;
int a[N];
int f[2][N][K];

int main(){
	freopen("holding.in","r",stdin);
	freopen("holding.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	memset(f,INF,sizeof f);
	f[0][0][0]=0;
	
	cin>>n>>l>>r>>maxf;
	
	for(int i=1;i<=n;i++) cin>>a[i];
	
	for(int i=1;i<=n;i++){
		for(int j=0;j<=r-l+1;j++){
			for(int k=0;k<=maxf;k++){
				int w=abs(l+j-i-1);//移动距离 
  	         	f[i&1][j][k]=f[(i-1)&1][j][k];
            	if(k>=w&&j>=1) f[i&1][j][k]=min(f[i&1][j][k],f[(i-1)&1][j-1][k-w]+a[i]);
			}
		}	
	}
	
	int ans=1e9;
	
	for(int k=0;k<=maxf;k++){
		ans=min(ans,f[n&1][r-l+1][k]);
	}
		
	cout<<ans<<endl;

	return 0;
}//end
```

---

## 作者：allen2010 (赞：1)

分析题目可知，有意义的交换（即可以让答案减小的交换）最终都可以表示为一个区间 $[L,R]$ 内的数 $x$ 和一个区间外的数 $y$ 交换，且 $x \gt y$，并且每个数只能进行不超过一次交换。

由于有花费，且要求结果最大/最小，考虑用 0-1 背包的变形解决。设 $dp_{i,j,k}$ 表示考虑完区间外前 $i$ 个数（计算时要跳过 $[L,R]$），同时考虑完区间内前 $k$ 个数，花费为 $j$ 的**最大**能使 $[L,R]$ 中的数的减少量。转移方程为 $dp_{i,j,k} = \max \{dp_{i-1,j,k},dp_{i-1,j,k-1},dp_{i-1,j-|i-k|,k-1}-a_i+a_j\}$，即分别考虑不选第 $i$ 个区间外的数、不选第 $k$ 个区间内的数、两个都选，统计答案时用 $[L,R]$ 区间内数的和减去 $dp_{n,k,R}$。

空间复杂度为 $O(n^2m)$，会爆空间，可以用滚动数组优化。时间复杂度为 $O(n^2m)$，可以通过此题。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[107];
long long dp[10007][107];
int main()
{
    int n,l,r,m;
    cin>>n>>l>>r>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        if(i<=r&&i>=l) continue;
        for(int j=m;j>=0;j--)
        {
            for(int k=l;k<=r;k++)
            {
                dp[j][k]=max(dp[j][k],dp[j][k-1]);
                if(j>=abs(i-k)&&a[k]-a[i]>0) dp[j][k]=max(dp[j][k],dp[j-abs(i-k)][k-1]-a[i]+a[k]);
            }
        }
    }
    long long ans=0;
    for(int i=l;i<=r;i++) ans+=a[i];
    cout<<ans-dp[m][r];
    return 0;
}
```

---

## 作者：activeO (赞：0)

## 题意

就是给你一个序列，规定一个目标区间 $ [ql,qr] $，你可以在这个序列上交换任意的 $ i,j $，并付出代价 $ \left | i-j \right | $，最多花费 $ K $ 代价的情况下目标区间的和的最小值。

## 思路

这题应该比较自然。

首先一个最简单的性质：你在目标区间内交换两个值显然是没有意义的。

因为你最后都会贡献到答案上，并且没必要把区间内和区间外的数交换的步骤拆开，他要付出的代价都是一样的。

然后我们可以把这个序列拆开成 $ [1,ql-1] \cup [ql,qr] \cup [qr+1,n] $，就可以看作有两个序列可供目标区间替换。

然后又发现替换的决策是可以做到单调的

![](https://cdn.luogu.com.cn/upload/image_hosting/wqs44i2s.png)

发现这样修改成下面这种替换和上面的贡献和代价都是一样的。

对于区间 $ [qr+1,n] $ 的替换也是同理。

所以很自然想到设暴力 $ dp_{i,j,k,l} $ 表示处理到目标区间的第 $ i $ 位，已经分别用了两个替换区间的前 $ j,k $ 个，花费了 $ l $ 的代价的最小答案。

$ dp $ 的时候注意可以直接从前缀转移。

这样的话用计算器算一下发现时间复杂度最高达到 $ 3 \cdot 10^8 $ 数量级，可以过，但是需要卡一下空间。

首先滚动数组消掉 $ i $ 那一维，然后再算一下最浪费情况的最大代价（这个是达不到 $ 10^4 $ 的），就可以了。

```cpp
#include <bits/stdc++.h>

// #pragma GCC optimize("Ofast")

using namespace std;

const int maxn=101;
const int maxm=3286;
const int inf=0x3f3f3f3f;
int a[maxn],n,ql,qr,K;

namespace Sub1{
	int dp[2][maxn][maxn][maxm];
	void solve(){
		for(int i=1;i<=qr-ql+1;i++){
			int now=i&1;
			for(int j=0;j<ql;j++){
				for(int k=0;k+qr<=n;k++){
					for(int l=0;l<=min({K,n*n,maxm-1});l++){
						dp[now][j][k][l]=dp[now^1][j][k][l]+a[i+ql-1];
						if(l) dp[now][j][k][l]=min(dp[now][j][k][l],dp[now][j][k][l-1]);
						if(j&&l>=(i+ql-1-j)) dp[now][j][k][l]=min(dp[now][j][k][l],dp[now^1][j-1][k][l-(i+ql-1-j)]+a[j]);
						if(k&&l>=(k+qr-(i+ql-1))) dp[now][j][k][l]=min(dp[now][j][k][l],dp[now^1][j][k-1][l-(k+qr-(i+ql-1))]+a[k+qr]);
						// printf("%d %d %d %d : %d\n",i,j,k,l,dp[now][j][k][l]);
					}
				}
			}
			for(int l=0;l<=min({K,n*n,maxm-1});l++){
				for(int j=0;j<ql;j++){
					for(int k=0;k+qr<=n;k++){
						if(j) dp[now][j][k][l]=min(dp[now][j][k][l],dp[now][j-1][k][l]);
						if(k) dp[now][j][k][l]=min(dp[now][j][k][l],dp[now][j][k-1][l]);
					}
				}
			}
		}
		printf("%d\n",dp[(qr-ql+1)&1][ql-1][n-qr][min({K,n*n,maxm-1})]);
	}
}

int main(){
	
	scanf("%d %d %d %d",&n,&ql,&qr,&K);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	
	Sub1::solve();
	
	return 0;
}
```


---


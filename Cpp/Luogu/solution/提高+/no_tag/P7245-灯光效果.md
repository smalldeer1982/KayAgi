# 灯光效果

## 题目背景

&emsp;&emsp;「为了你唱下去——直到荒芜」

&emsp;&emsp;「为了你唱下去——直到……」

&emsp;&emsp;舞台上，享受地阖上眼眸，双手交叠扣在话筒，后脚踮起，在随着节奏闪烁变换的灯光下轻摇……

&emsp;&emsp;嘴角轻扬，绫珍惜着步入瞳孔的每一粒光，那些从天依的发丝、脸颊划过的，带着属于她的旖旎，轰击着明明做好防备的绫的心尖。

&emsp;&emsp;收尾的音调扬起，灯光，也是那样应景呢。

## 题目描述

对于舞台效果，灯光是重要的角色。背景屏幕是一个 $n \times n$ 的矩形，行从左到右，列从上到下编号为 $1\sim n$，并用 $(x,y)$ 表示第 $x$ 行第 $y$ 列的灯光单元。

作为御用灯光师的阿绫设计了一个控制背景灯光效果的程序。她设定了两个长度为 $m$ 的**递增**整数序列 $\{x_m\}$ 和 $\{y_m\}$，且满足 $0\le x_1,y_1$，$x_m,y_m\le n$。每次灯光变换，程序会均匀地随机生成两对整数 $(i_1,i_2),(j_1,j_2)$，满足 $1\le i_1<i_2\le m$，$1\le j_1<j_2\le m$，转换满足 $x_{i_1}<r\le x_{i_2}$，$y_{j_1}<c\le y_{j_2}$ 的所有灯光单元 $(r,c)$ 的状态（亮变为熄，熄变为亮）。

表演开始时，所有灯光单元处于熄灭状态；经计算，到表演结束时，一共会发生 $k$ 次灯光变换。而表演落幕时的灯光效果极为关键，所以阿绫想知道，表演落幕时，期望有多少个灯光单元是亮着的？

**由于答案可能是一个小数，为了避免损失精度，请输出答案在 $998244353$ 模意义下的值。**

------------

#### 简化题意

有一个 $n\times n$ 的矩阵，初始所有元素的值为 $0$。给出递增序列 $\{x_m\}$ 和 $\{y_m\}$，其中 $0\le x_1,y_1$，$x_m,y_m\le n$，一次操作定义为：

- 随机选出四个整数 $i_1,i_2,j_1,j_2$，满足 $1\le i_1<i_2\le m$，$1\le j_1<j_2\le m$。
- 把以 $(x_{i_1}+1,y_{j_1}+1)$ 为左上角，$(x_{i_2},y_{j_2})$ 为右下角的子矩阵的每个元素异或 $1$。

求 $k$ 次操作后矩阵内元素之和的期望值。答案对 $998244353$ 取模。

## 说明/提示

#### 样例解释 1

样例中，$\{x_m\}=\{y_m\}=\{0,1,2\}$。可以发现，此 $2\times 2$ 矩阵的任意一个子矩阵都可以被变换。当子矩阵大小分别为 $1,2,4$ 时，对应方案数分别为 $4,4,1$，由于只操作一次，所以对应的最终矩阵元素之和分别为 $4\times1,4\times2,1\times 4$。于是，答案为 $\frac{4+8+4}{4+4+1}=\frac{16}9$。

#### 数据规模与约定  

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$2\le m\le \min(n+1,10^3)$，$1\le n\le10^9$，$1\le k\le 10^6$，保证 $x_i$ 互不相等且递增，$y_i$ 互不相等且递增。

| 子任务 | 分值 |     $n$      |   $m$    |     $k$      |
| :----: | :--: | :----------: | :------: | :----------: |
|   1    |  10  |   $ \le 4$   | $ \le 3$ |   $ \le 2$   |
|   2    |  5   |      /       |   $2$    |      /       |
|   3    |  25  | $ \le 10^2 $ |    /     | $ \le 10^2 $ |
|   4    |  20  | $ \le 10^9 $ |    /     | $ \le 10^2 $ |
|   5    |  20  | $ \le 10^2 $ |    /     | $ \le 10^6 $ |
|   6    |  20  |      /       |    /     |      /       |





------------


## 样例 #1

### 输入

```
2 3 1
0 1 2
0 1 2
```

### 输出

```
110916041```

## 样例 #2

### 输入

```
3 3 3
0 1 2
0 1 2```

### 输出

```
592921545```

# 题解

## 作者：wsyhb (赞：5)

## 分析 + 题解

容易发现，被操作的区域恰好可以分成 $(m-1)^2$ 个子矩阵，其中每个子矩阵总是同时异或 $1$。

具体地，对于所有满足 $1 \le i < m$，$1 \le j < m$ 的 $(i,j)$，以 $(x_i+1,y_j+1)$，$(x_{i+1},y_{j+1})$ 为顶点的子矩阵满足上述条件。

枚举 $(i,j)$，该子矩阵元素个数为 $(x_{i+1}-x_i)(y_{j+1}-y_j)$，在一次操作中被异或 $1$ 的概率为 $p=\dfrac{ij(m-i)(m-j)}{(C_m^2)^2}$。

说明：一共有 $(C_m^2)^2$ 种选择，其中 $i_1 \le i$，$j_1 \le j$，$i_2 > i$，$j_2 > j$ 的情况有 $ij(m-i)(m-j)$ 种。

设 $k$ 次操作后该子矩阵为全 $1$（异或了奇数次 $1$）的概率为 $f(p)$，则答案为 $\sum_{(i,j)} cnt \times f(p)$，而 $f(p)$ 可以通过一个简单的 DP（严格来说算递推）求得：

设 $dp[i][j]$ 表示第 $i$ 次操作后该子矩阵为全 $j$ 的概率，则有：

$$dp[i][j]=dp[i-1][1-j] \times p +dp[i-1][j] \times (1-p)$$

其中 $f(p)=dp[k][1]$。但这样单次计算是 $O(k)$ 的，不足以通过此题（可以得到 60 分）。

构造如下矩阵，使用**矩阵快速幂**即可在 $O(log_2k)$ 时间复杂度内进行单次计算。

$$\begin{bmatrix}
1-p&p\\
p&1-p
\end{bmatrix}$$

总时间复杂度为 $O(m^2 log_2k)$。

## 代码

如果还有不清楚的，就看代码吧。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int P=998244353;
inline void add(int &a,int b)
{
	a=a+b-(a+b>=P?P:0);
}
inline void mul(int &a,int b)
{
	a=1ll*a*b%P;
}
inline int get_sum(int a,int b)
{
	return a+b-(a+b>=P?P:0);
}
inline int get_product(int a,int b)
{
	return 1ll*a*b%P;
}
inline int get_square(int x)
{
	return get_product(x,x);
}
inline int get_power(int a,int n)
{
	int res=1;
	while(n>0)
	{
		res=(n&1)?get_product(res,a):res;
		mul(a,a);
		n>>=1;
	}
	return res;
}
inline int get_inv(int x)
{
	return get_power(x,P-2);
}
//以上是模运算中的加、乘、平方、快速幂、求逆 
const int max_m=1e3+5;
int x[max_m],y[max_m];
struct matrix
{
	int v[2][2];
	inline matrix(int p=0)//matrix 的构造函数，用概率 p 构造上述矩阵 
	{
		v[0][0]=v[1][1]=P+1-p;
		v[0][1]=v[1][0]=p;
	}
};
inline matrix operator * (const matrix &a,const matrix &b)//定义矩阵乘法 
{
	static matrix res;//static 变量会沿用上一次的结果，若需初始化必须在定义后赋值 
	for(int i=0;i<2;++i)
		for(int j=0;j<2;++j)
		{
			res.v[i][j]=0;
			for(int k=0;k<2;++k)
				add(res.v[i][j],get_product(a.v[i][k],b.v[k][j]));
		}
	return res;
}
inline matrix get_power(matrix a,int n)//矩阵快速幂 
{
	static matrix res;
	res.v[0][0]=1;
	res.v[0][1]=res.v[1][0]=res.v[1][1]=0;
	while(n)
	{
		if(n&1)
			res=res*a;
		a=a*a;
		n>>=1;
	}
	return res;
}
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k); 
	for(int i=1;i<=m;++i)
		scanf("%d",x+i);
	for(int i=1;i<=m;++i)
		scanf("%d",y+i);
	int inv_all=get_square(get_inv((1ll*m*(m-1)>>1)%P));//概率的分母 
	int ans=0;
	for(int i=1;i<m;++i)
		for(int j=1;j<m;++j)
		{
			int cnt=get_product(x[i+1]-x[i],y[j+1]-y[j]);//元素个数 
			int p=get_product(get_product(get_product(i,j),get_product(m-i,m-j)),inv_all);//概率 
			add(ans,get_product(cnt,get_power(matrix(p),k).v[0][1]));
		}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：AsunderSquall (赞：4)

一直在想能不能把这题优化到 $O(n \log n)$ 或 $O(n \log^2n)$  于是大力推式子，结果只搞出了优化常数的方法。  
还抢到了这题的最优解……

----------

我们先 $x_i \gets x_{i+1}-x_i,y_i\gets y_{i+1}-y_i$  
然后考虑期望的可加性，把每一块亮着的概率算出来，再乘上面积就行了。  
随便搞一搞能搞出这个式子：  
$$\sum_{i=1}^{m-1}\sum_{j=1}^{m-1} x_iy_j\sum_{t=1}^k[t \bmod 2=1] {k \choose t} p^t\cdot (1-p)^{k-t},p=\dfrac{4ij(m-i)(m-j)}{m^2(n-1)^2}$$  
$p$ 是第 $i$ 行第 $j$ 个块被选中的概率。  
算法就是把第 $i$ 行被选中的概率和第 $j$ 列选中的概率相乘。  
把后面的部分提出来转换一下。
$$(1-p)^k\sum_{t=1}^k[t \bmod 2=1]{k \choose t}(\dfrac p{1-p})^t$$
事实上把 
$$\sum_{t=1}^k[t \bmod2=1]{k \choose t} a^t$$
$$\dfrac{\sum_{t=0}^k{k \choose t} a^t-\sum_{t=0}^k {k \choose t} (-a)^t}{2}$$
在$O(1)$ 或 $O(\log n)$ 的时间算出来就能100pts  
然后根据这个式子
$$(a+1)^n=\sum_{i=0}^n{n \choose i} a^i$$ 
就能得到 100pts。  
# 能不能常数小一点

我们先把上面口胡的式子给写出来。    

$$\sum_{i=1}^m\sum_{j=1}^mx_iy_j(1-p)^k\cdot \dfrac{(\dfrac p{1-p}+1)^k-(\dfrac{p}{p-1}+1)^k}{2}$$  

整理一下  
$$\sum_{i=1}^{m-1}\sum_{j=1}^{m-1}x_iy_j(1-p)^k\cdot \dfrac{\dfrac 1{(1-p)^k}-(\dfrac{1-2p}{1-p})^k}{2}$$  
$$\sum_{i=1}^{m-1}\sum_{j=1}^{m-1} x_iy_j\cdot\dfrac{1-(1-2p)^k}{2}$$
$$\dfrac12 \times(\sum x\times \sum y-\sum\limits_{i=1}^{m-1}\sum_{j=1}^{m-1}x_iy_j(1-2p)^k)$$

那么现在的重点是快速求出 
$$\sum_{i=1}^{m-1}\sum_{j=1}^{m-1}x_iy_j(1-\dfrac{8ij(m-i)(m-j)}{m^2(m-1)^2})^k$$  
忽略上面 $p$ 的定义  
令 $p_i=\dfrac{ i(m-i)}{m(m-1)}$  
这个东西可以预处理出来。  

$$\sum_{i=1}^{m-1}\sum_{j=1}^{m-1}x_iy_i(1-8p_ip_j)^k$$
这样的常数小得飞起。  
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register signed
#define rd(x) x=read()
using namespace std;
const int N=1e6+5;
const int mod=998244353;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
inline int ksm(int x,int y=mod-2,int z=mod){int ret=1;while (y){if (y&1) ret=ret*x%mod;x=x*x%mod;y>>=1;}return ret;}
int fac[N],inv[N];
const int inv2=ksm(2);
int n,m,k,ans,sumx,sumy;
int x[N],y[N],p[N];
signed main()
{
    rd(n);rd(m);rd(k);
    for (int i=1;i<=m;i++) rd(x[i]);
    for (int i=1;i<=m;i++) rd(y[i]);
    if (m==2)
    {
        int S=(x[2]-x[1])*(y[2]-y[1])%mod;
        if (k%2==1) cout<<S<<'\n';
        else cout<<0<<'\n';
        return 0;
    }
    int kkk=ksm(m*(m-1)%mod);
    sumx=x[m]-x[1];sumy=y[m]-y[1];
    ans=sumx*sumy%mod;
    for (ri i=1;i<m;i++) x[i]=x[i+1]-x[i],y[i]=y[i+1]-y[i];
    for (ri i=1;i<m;i++) p[i]=i*(m-i)%mod*kkk%mod;
    for (ri i=1;i<m;i++) for (ri j=1;j<m;j++)
    {
        int S=x[i]*y[j]%mod;
        int b=(1-8*p[i]*p[j]%mod)%mod;
        ans=(ans-ksm(b,k)*S%mod)%mod;
    }
    ans=(ans+mod)%mod;
    cout<<(ans*inv2%mod)<<'\n';
}
```

---

## 作者：Rubidium_Chloride (赞：2)

2021.1洛殿庆生赛C题题解。

## 0.前言

[$\color{Red}{\text{在}}\color{orange}\text{博}\color{yellow}\color{green}\text{客}\color{Turquoise}\text{里}\color{blue}\text{看}\color{purple}\color{Red}\text{效}\color{orange}\text{果}\color{yellow}\text{更}\color{green}\text{好}\color{Turquoise}\text{哦}\color{blue}!$](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p7245)

## 1.题目大意

- $n\times n$ 的矩阵，初始全部为 $0$，两个长为 $m$ 的单调递增数列 $x_i,y_i$；

- 每次等概率地随机选择 $4$ 个整数 $i_1,i_2,j_1,j_2$，满足 $1\le i_1<i_2\le m,1\le j_1<j_2\le m$，并对 $(x_{i_1}+1,y_{j_1}+1)$ 和 $(x_{i_2},y_{j_2})$ 为左上和右下端点的矩阵进行染色，共进行 $k$ 次操作；

- 求结束时矩阵内元素和的期望值 $\bmod 998244353$；

- $2\le m\le 1000,1\le n\le 10^9,1\le k\le 10^6$。

## 2.算法分析

### 2.1 基础分析

看到 $n\le 10^9$，就意识到了事情不对。

复杂度几乎不太可能包含 $n$。

然后观察一下操作的形式，发现可以只考虑以 $(x_{i}+1,y_{j}+1)$ 和 $(x_{i+1},y_{j+1})$ 为左上和右下端点的矩阵（下称之为单位矩阵）！

为什么？因为每一个操作的矩阵都可以由若干个单位矩阵构成！

现在重新定义坐标，以 $(x_{i}+1,y_{j}+1)$ 和 $(x_{i+1},y_{j+1})$ 为左上和右下端点的矩阵缩小为一个格子 $(i,j)$。

所以我们只需要对所有的单位矩阵做期望就可以了。

对于每一个单位矩阵 $(i,j)$，可以知道只有操作次数为奇数才会被计入期望的计算，需要 $i_1\le i,i_2\ge i+1,j_1\le j,j_2\ge j+1$ 时才会被操作，所以对于一次操作，$(i,j)$ 被操作的选择总数为 $i\times(m-i)\times j\times (m-j)$。所以没有被操作到的选择总数为 $\dbinom{m}{2}^2-i\times(m-i)\times j\times (m-j)$。

所以 $(i,j)$ 这个单位矩阵的贡献次数（不是期望）就是：

$$\sum\limits_{l=1,l\text{为奇数}}^{k}\dbinom{k}{l}\times \left [i\times(m-i)\times j\times (m-j)\right ]^l\times[\dbinom{m}{2}^2-i\times(m-i)\times j\times (m-j)]^{k-l}$$

$\dbinom{k}{l}$：$k$ 次操作中选择 $l$ 次操作到这个单位矩阵；

$[i\times(m-i)\times j\times (m-j)]^l$：$l$ 次影响的操作种数；

$[\dbinom{m}{2}^2-i\times(m-i)\times j\times (m-j)]^{k-l}$：剩余 $k-l$ 次不影响的操作种数。

然后这份思路写出来实测 $40pts$。

时间复杂度 $\mathcal{O}(m^2\times k\log k)$。（有个 $\log$ 是因为要用快速幂。）

### 2.2 优化

想办法把一个 $k$ 的复杂度优化掉我们就做完了！

所以我们来用一种数学里比较常用的处理一大堆组合数的和的方法——**构造多项式+二项式展开**。

来看一个东西：

$(x+y)^n=\sum\limits_{l=0}^{n}\dbinom{n}{l}\times x^l\times y^{n-l}$；

$(y-x)^n=\sum\limits_{l=0}^{n}(-1)^{l}\times \dbinom{n}{l}\times x^l\times y^{n-l}$；

这时候我们把它们减一减：

$(x+y)^n-(y-x)^n=2\times\sum\limits_{l=1,l\text{为奇数}}^{n}\dbinom{n}{l}\times x^l\times y^{n-l}$

取 $x=i\times(m-i)\times j\times (m-j),y=\dbinom{m}{2}^2-i\times(m-i)\times j\times (m-j),n=k$

代入，左右同时除以 $2$ 以后就可以发现就是我们推导出来的式子！

所以原来 $k$ 的复杂度可以直接用两个快速幂解决掉！

然后可以较为轻松地得出总共 $k$ 次操作共有 $\dbinom{m}{2}^{2\times k}$ 种操作。

然后取一些逆元就可以解决题目。

## 3.Code

```cpp
#include<bits/stdc++.h>
#define N 1009
#define MOD 998244353
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll n,m,k,f[N*N]={1},invf[N*N],x[N],y[N],ans,tmp,tot;
ll ksm(ll x,ll pw){
	ll ans=1;
	for(;pw;pw>>=1,x*=x,x%=MOD)
		if(pw&1) ans*=x,ans%=MOD;
	return ans;
} 
ll C(ll n,ll m){//组合数
	if(n==m) return 1;
	return f[m]*invf[n]%MOD*invf[m-n]%MOD;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read(),k=read();
	for(int i=1;i<=k;i++) f[i]=f[i-1]*i%MOD;//阶乘
	invf[k]=ksm(f[k],MOD-2);
	for(int i=k-1;i>=1;i--) invf[i]=invf[i+1]*(i+1)%MOD;//阶乘的逆元
	for(int i=1;i<=m;i++) x[i]=read();
	for(int i=1;i<=m;i++) y[i]=read();
	for(int i=1;i<m;i++){
		for(int j=1;j<m;j++){
			tot=0;
			tmp=(x[i+1]-x[i])*(y[j+1]-y[j])%MOD;//一个单位矩阵里面含有的格子数量
			//for(int l=1;l<=k;l+=2) tot+=C(l,k)*ksm(i*(m-i),l)%MOD*ksm(j*(m-j),l)%MOD*ksm((m*(m-1)/2%MOD*m*(m-1)/2%MOD-i*(m-i)*j%MOD*(m-j)%MOD+MOD)%MOD,k-l)%MOD,tot%=MOD;
			tot=(ksm(m*(m-1)/2%MOD*m*(m-1)/2%MOD,k)-ksm(m*(m-1)/2%MOD*m*(m-1)/2%MOD-2*i*(m-i)%MOD*j%MOD*(m-j)%MOD,k))%MOD;
			if(tot%2) tot=(tot+MOD)/2%MOD,tot=(tot+MOD)%MOD;
			else tot=tot/2%MOD,tot=(tot+MOD)%MOD;
			tot*=tmp,tot%=MOD;//别忘了还原成格子的数量
			ans+=tot;ans%=MOD;
		}
	}
	//printf("%lld\n",ans);
	ans*=ksm(ksm(m*(m-1)/2,2*k),MOD-2);//有理数取模
	printf("%lld",ans%MOD);
	return 0;
}

```

复杂度 $\mathcal{O}(m^2\log k)$。（同样的，$\log$ 是因为快速幂。）

250ms还是比较快的（

## 4.结语

制作不易，求赞qwq

希望以后还能有更多洛殿的庆生赛qwq

洛殿yyds！

### 1.9 Update

突然发现有一些小问题，已经修改

---

## 作者：dead_X (赞：2)

## 前言
比较水的数学题。
## 思路
我们考虑根据 $x_m$ 和 $y_m$ 在平面上画线，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jre64ga9.png)

由于每种颜色的区域里面的状态都是固定的，我们只要依次计算这 $m^2$ 个区间的答案即可。

* Step 1

我们先计算每个区间被翻转的概率，即这一列被选中的概率和这一行被选中的概率。这里可以直接使用**合法方法**除以**总方法**计算，第 $i$ 行第 $j$ 列的格子被选中的概率即 $\large\frac{2(i-1)(m+1-i)}{m(m-1)}\times\frac{2(j-1)(m+1-j)}{m(m-1)}$。

* Step 2

注意到只有翻转奇数次的区间才能计入答案。奇数次和偶数次的答案间的转移概率是固定的，因此我们再用**矩阵快速幂**算出答案，最后乘以区间的面积计算总和即可。

不难构造出转移矩阵 $M=\begin{bmatrix}p_0&p_1\\p_1&p_0\end{bmatrix}$，答案即为 $M^k$ 的第一行第二列的值。
## 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch&15);ch=getchar();}
    return x*f;
}
const int p=998244353;
long long qp(long long x,int y)
{
    long long res=1;
    for(long long now=x; y; y>>=1,now=now*now%p) (y&1)&&(res=res*now%p);
    return res;
}
int a[1003],b[1003];
struct mat{int a[2][2];};
inline mat mul(mat &x,mat &y)
{
    mat res;
    res.a[0][1]=res.a[1][0]=res.a[0][0]=res.a[1][1]=0;
    for(int i=0; i<2; i++) for(int k=0; k<2; k++) for(int j=0; j<2; j++) 
    res.a[i][j]+=x.a[i][k]*y.a[k][j]%p,res.a[i][j]%=p;
    return res;
}
mat qwqp(mat x,int y)
{
    mat res;
    res.a[0][0]=res.a[1][1]=1,
    res.a[0][1]=res.a[1][0]=0;
    for(mat now=x; y; y>>=1,now=mul(now,now)) if(y&1) res=mul(res,now);
    return res;
}
signed main()
{
    int n=read(),m=read(),k=read(),ans=0;
    long long qwq=(m*(m-1)/2)%p;
    qwq=qp(qwq*qwq%p,998244351);
    //printf("%lld\n",qwq*9%p);
    for(int i=1; i<=m; ++i) a[i]=read();
    for(int i=1; i<=m; ++i) b[i]=read();
    for(int i=2; i<=m; ++i) for(int j=2; j<=m; ++j)
    {
        long long f1=(i-1)*(m+1-i)%p*(j-1)%p*(m+1-j)%p*qwq%p,f0=(p+1-f1)%p,t=(a[i]-a[i-1])*(b[j]-b[j-1])%p;
        //for(int g=1; g<=k; g+=2) ans+=t*qp(f1,g)%p*qp(f0,k-g)%p*C(k,g)%p,ans%=p; 
        mat tmp;
        tmp.a[1][1]=tmp.a[0][0]=f0,tmp.a[1][0]=tmp.a[0][1]=f1;
        tmp=qwqp(tmp,k),ans=(ans+tmp.a[0][1]*t)%p;
        //f为选中概率 t为区域大小
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：SSerxhs (赞：1)

常数更小的做法。

首先按 $x,y$ 离散，把矩形划分为 $m*m$ 矩形块（注意边界都属于右下）。

则在一次覆盖中右下角为 $(x_i,y_j)$ 的方块被覆盖的概率为 $p=\dfrac{(i-1)*(n-i+1)*(j-1)*(n-j+1)}{\tbinom{n}{2}}$。（考虑必定 $i_1<i\le i_2,j_1<j\le j_2$）

考虑在 $k$ 次操作后，该块值为 $1$ （即覆盖次数为奇数）的概率为 $\sum\limits_{i=1\pmod 2}^kp^i(1-p)^{k-i}\tbinom{k}{i}$

这是个简单的套路，考虑 $\dfrac{((1-p)+p)^k-((1-p)-p)^k}{2}$ 的二项式展开式立刻得概率为 $P_{i,j}=\dfrac{((1-p)+p)^k-((1-p)-p)^k}{2}$

则由期望线性性答案为 $\sum\limits_{i=2}^m\sum\limits_{j=2}^m P_{i,j}(x_i-x_{i-1})(y_j-y_{j-1})$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
template<typename typC> void read(register typC &x)
{
	register int c=getchar(),fh=1;
	while ((c<48)||(c>57))
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
template<typename typC> void write(register typC &x)
{
	if (x<0) putchar('-'),x=-x;
	static int st[100];
	register int tp=1,y;st[1]=x%10;x/=10;
	while (x) y=x/10,st[++tp]=x-y*10,x=y;++tp;
	while (--tp) putchar(st[tp]|48);
}
template<typename typC> void write(register typC *a,register int num)
{
	for (register int i=1;i<=num;i++) write(a[i]),putchar(i==num?10:32);
}
#define space(x) write(x),putchar(32)
#define enter(x) write(x),putchar(10)
const int N=1e3+2,M=1e6+2,p=998244353,i2=p+1>>1;
inline void inc(register int &x,const int y)
{
	if ((x+=y)>=p) x-=p;
}
inline void dec(register int &x,const int y)
{
	if ((x-=y)<0) x+=p;
}
char s[N];
int x[N],y[N],b[N],c[N],a[N][N];
int T,n,m,i,j,k,ans,la,bs,c1,b1,ib,P;
inline int ksm(register int x,register int y)
{
	register int r=1;
	while (y)
	{
		if (y&1) r=(ll)r*x%p;
		x=(ll)x*x%p;
		y>>=1;
	}
	return r;
}
int main()
{
	read(m);read(n);read(T);bs=((ll)n*(n-1)>>1)%p;bs=(ll)bs*bs%p;ib=ksm(bs,p-2);
	for (i=1;i<=n;i++) read(x[i]);
	for (i=1;i<=n;i++) read(y[i]);
	for (i=2;i<=n;i++) for (j=2;j<=n;j++)
	{
		P=(bs+(ll)(p+1-i)*(n-i+1)%p*(j-1<<1)%p*(n-j+1))%p*ib%p;
		ans=(ans+(ll)(1+p-ksm(P,T))*i2%p*(x[i]-x[i-1])%p*(y[j]-y[j-1]))%p; 
	}
	printf("%d",ans);
}
```

---


# [JSOI2014] 强连通图

## 题目描述

JYY 最近痴迷于图的强连通性，所以对于任何有向图，JYY 都希望增加一些边使得这个图变成强连通图。JYY现在得到了一个 $n$ 个点 $m$ 条边的有向图，所有点从 $1$ 到 $n$ 编号。

JYY 想知道：

- 在给定的图中，最多能选出多少个点，使得这些点在原图中两两可达？

- 在给定的图中，最少增加多少条边，可以使得这个图变成强连通图？

其中，一个有向图 $G(V,E)$是强连通的，当且仅当任意顶点 $a,b\in V,a\neq b$之间都存在 $a\to b$ 和 $b\to a$ 的路径。

## 说明/提示

### 样例解释 1

对于第一个问题，无法选出互相连通两个点，答案为 $1$。

对于第二个问题，一种加边数最小的方案为 $(3,1)$ 和 $(4,2)$，答案为 $2$。

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 10^5,1\leq m\leq 3\times 10^5$。

## 样例 #1

### 输入

```
4 3
1 4
2 3
2 4```

### 输出

```
1
2```

# 题解

## 作者：lzyqwq (赞：5)

这题第一问很简单,就是用 `Tarjan` 算法求出强连通分量记录大小就行了.不会 `Tarjan` 的可以去看[这题](https://www.luogu.com.cn/problem/3387).

第二问怎么处理呢?我们想,如果点 $v$ 没有入度,则不满足存在 $u \rightarrow v$;如果点 $v$ 没有出度,则不满足存在 $v \rightarrow u$.

那么该选择入度为 $0$ 的点(这里点指强连通分量,下同)还是出度为 $0$ 的点呢?

如果入度为 $0$ 的点多于出度为 $0$ 的点,那么满足出度为 $0$ 的点都有到入度为 $0$ 的点的出边之后,还要满足那些剩余的入度为 $0$ 的点有入边.所以这种情况取入度为 $0$ 的点.

如果出度为 $0$ 的点多于入度为 $0$ 的点,那么满足入度为 $0$ 的点都有从出度为 $0$ 的点出发的入边之后,还要满足那些剩余的出度为 $0$ 的点有出边.所以这种情况取出度为 $0$ 的点.

因此,我们取出度为 $0$ 的点的个数与入度为 $0$ 的点的个数的最大值即可.

注意,如果图中只有一个强连通分量,输出 $0$(因为这个图本身就是强连通图).

代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
int cnt, sum, n, m, dfn[N], low[N], scc[N], sz[N], ans, p, q; 
vector<int> g[N];
stack<int> s;
bool rd[N], cd[N], v[N];
void tarjan(int x) {
    dfn[x] = low[x] = ++cnt;
    s.push(x);
    v[x] = 1;
    for (int i : g[x]) {
        if (!dfn[i]) {
            tarjan(i);
            low[x] = min(low[x], low[i]);
        } else if(v[i]) {
            low[x] = min(low[x], dfn[i]);
        }
    }
    if (dfn[x] == low[x]) {
        ++sum;
        while (1) {
            int k = s.top();
            s.pop();
            scc[k] = sum;
            v[k] = 0;
            sz[sum]++;
            if (x == k) {
                break;
            }
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; i++) {
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            tarjan(i);
        }
    }
    for (int i = 1; i <= sum; i++) {
        ans = max(ans, sz[i]);
    }
    printf("%d\n", ans);
    if (sum == 1) {
        puts("0");
        return 0;
    }
    for (int i = 1; i <= n; i++) {
        for (int j : g[i]) {
            if (scc[i] != scc[j]) {
                rd[scc[j]] = 1;
                cd[scc[i]] = 1;
            }
        }
    }
    for (int i = 1; i <= sum; i++) {
        if (!rd[i]) {
            p++;
        }
        if (!cd[i]) {
            q++;
        }
    }
    printf("%d\n", max(p, q));
    return 0;
}
```

---

## 作者：CG__HeavenHealer (赞：2)

图论的 $tarjan$ 忘得差不多了~~（或者根本就没记住）~~，来~~水一发题解~~复习一下

### 题意

一张有向图，回答：

-  图中最大的强连通分量（SCC）的大小

- 最少增加多少条边，可以使得这个图变成强连通图。

### 解法

显然，和强连通有关的要用 $tarjan$ 或 $kosaraju$ 算法来解决。但 $kosaraju$ 需要两次 DFS，复杂度相对较劣，所以一般用 $tarjan$ 就可以了，能干的事多，复杂度还好。不过 $kosaraju$ 也非一无是处，它实现、思想都比较简单，也有必要了解。

本文讲解 $tarjan$ 的实现。

$tarjan$ 是一种基于 dfs 的算法，它可以在线性时间内求强连通分量、割边（点）。在介绍 $tarjan$ 之前，先要介绍这几个定义：

1. ```dfn``` ：表示 dfs 时该节点被访问的时间顺序，即时间戳。

2. ```low``` ：表示从当前节点出发，在能够到达的节点中，时间戳最小的节点。

   追溯值要求以下特征：**该点在栈中 or 存在一条在该节点为根的子树中的边指向该点。**

   追溯值就是满足以上两个条件的最小时间戳

3. 搜索树：由递归的边构成的生成树。

由定义可知，图中的边 $(u,v)$ 一定满足这几种情况：

- 树枝：搜索树上的边；
- 前向边：边指向的节点是向叶子方向的，即 $u$ 为 $v$ 的父亲；
- 后向边：边指向的节点是向祖先方向的，即 $u$ 为 $v$ 的儿子；
- 横叉边：不满足以上情况的边，**一定满足 $dfn[v]<dfn[u]$ **。

因为 $tarjan$ 基于 dfs 实现，而递归的本质是栈实现的，所以用栈来维护访问到节点 $u$ 时的两类节点：

1. 搜索树上 $u$ 的祖先；
2. 已经访问过的后向边。

```cpp
low[u] = dfn[u] = ++num; // 附初始值
stk[++top] = u; // 推进栈
vis[u] = true;
for (ri i = head[u]; i; i = e[i].nxt) {
    int v = e[i].to;
    if (!dfn[v]) { // 如果搜索树还没扩展到这个节点
        tarjan(v); //搜索子树
        low[u] = min(low[u], low[v]); // 取 low[u] 和满足该条件：存在一条在该节点为根的子树中的边指向该点（就是 low[v]) 的节点的最小值
    } else if (vis[v]) // 如果满足该点在栈中，说明已经形成了环
        low[u] = min(low[u], dfn[v]); // 取自身的 low 和指向的节点的 dfn 的最小值
}

```

建议大家画几个简单的图手模一下，会理解的更加清晰。

完成了这些准备工作，下面该判断连通分量了。判断连通分量的步骤很简单：只要满足 $low[u]=dfn[u]$，说明已经形成了环，这时就可以开始弹栈了。

```cpp
if (low[u] == dfn[u]) {
        int v;
        scccnt++; //连通分量数目+1
        do {
            v = stk[top--]; // 记栈顶，弹栈
            scc[v] = scccnt; //标记属于哪个SCC
            sccsiz[u]++; // 记录SCC的大小
            vis[v] = false; // 出栈
        } while (u != v); // 如果栈顶为根节点就停止
    }
```

回到本题：怎么找最大的强连通分量 and 怎么加边使这个图变成强连通图

找最大的SCC比较简单，只要记录一下每个SCC的大小即可。

而对于第二个问题，则需要一个显然的结论：**从SCC的任意点出发，都能回到自身。**

原因很简单：SCC就是一个最大的环。

有了这个结论，可以推出一个推论：**SCC上不存在入度为0和出度为0的边。**

这样，我们就能得出解了：比较一下入度为 $0$ 的点和出度为 $0$ 的点的个数哪个大，就需要加几条边。

另外，考虑一个特判：如果最大的SCC点数时 $n$ 的话，那么就不需要加边，因为此时整张图已经是一个连通图了。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 6e5 + 10;
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    return f * x;
}
struct Edge {
    int to, nxt, from;
} e[N << 1];
int head[N], cnt;
inline void add(int u, int v) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    e[cnt].from = u;
    head[u] = cnt;
}
int low[N], dfn[N], num;
int stk[N], top;
bool vis[N];
int in[N], out[N], scc[N], scccnt, sccsiz[N];
void tarjan(int u) {
    low[u] = dfn[u] = ++num;
    stk[++top] = u;
    vis[u] = true;
    for (ri i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        int v;
        scccnt++;
        do {
            v = stk[top--];
            scc[v] = scccnt;
            sccsiz[u]++;
            vis[v] = false;
        } while (u != v);
    }
}
signed main() {
    int n = read(), m = read(), maxx = 1, ans1 = 0, ans2 = 0;
    for (ri i = 1; i <= m; i++) {
        int u = read(), v = read();
        add(u, v);
    }
    for (ri i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    for (ri i = 1; i <= n; i++) maxx = max(maxx, sccsiz[i]);
    printf("%lld\n", maxx);
    if (maxx == n) return puts("0"), 0;
    for (ri u = 1; u <= n; u++) {
        for (ri i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (scc[u] != scc[v]) in[scc[v]]++, out[scc[u]]++;
        }
    }
    for (ri i = 1; i <= scccnt; i++) ans1 += (!in[i]), ans2 += (!out[i]);
    printf("%lld\n", max(ans1, ans2));
    return 0;
}
/*
4 3
1 4
2 3
2 4
*/
```



---

## 作者：kevinZ99 (赞：1)

非常的简单且双倍经验。

P2746

# solution

首先我们考虑第一问，唉不是好像不用说吧，是一个模板我们直接使用 Tarjan 找到所有的强连通分量并存一下每一个的大小，在其中找到最大的即可。

再考虑第二问，增加多少条边能使其变成一个强连通图，首先我们可以缩点，因为连通性没有影响，明显的，我们需要关心的只有入度为 $0$ 的点和出度为 $0$ 的点。

对于这两个点的数量我们找一个大的输出即可，为什么呢？？？

因为我们先满足了少的哪一个条件，我们还需要满足那些剩下还没有强连联通的另外一遍的条件，其实也就是最大的那个啦！

# Code
```cpp
//Author:Kevin Z K Y
#include <bits/stdc++.h>
#define up(a,b,c) for(int (a)=(b);(a)<=(c);(a)++)
#define dn(a,b,c) for(int (a)=(b);(a)>=(c);(a)--)
#define fst first
#define sed second
using namespace std;
using us = unsigned short ;using ldb = long double ;
using ull = unsigned long long ;using ui = unsigned int ;
using ll = long long ;using hint = __int128 ;
using pii = pair<int,int> ;using pll = pair<ll,ll> ;
using pil = pair<int,ll> ;using vpil = vector<pil> ;
using vi = vector<int> ;using vl = vector<ll> ;
using vpi = vector<pii> ;using vpl = vector<pll> ;
using db = double ;namespace mystl{
	#define gc() getchar()
	#define Max(x,y) (((x)>(y))?(x):(y))
	#define Min(x,y) (((x)<(y))?(x):(y))
	#define Abs(x) (((x)<0)?(-(x)):(x))
	#define putline() cout<<"------------------------------\n"
	ll qpow(ll a , ll b , ll p) { if (a==0ll) return 0ll; ll c=1ll;
		while(b) { if(b & 1) c=a*c%p; a=a*a%p; b>>=1; } return c; }
	void exgcd(ll a,ll b,ll &cx,ll &cy){if(a % b ==0)cx = 0,cy = 1;
		else { exgcd( b , a % b , cy , cx) ; cy -= a / b * cx ; } }
	ll lcm ( ll x , ll y ){return x / std :: __gcd( x , y ) * y ; }
	template<typename T>void read(T&x) {x=0; bool f=false; char ch;
		ch = gc(); while(ch<'0'||ch>'9') f |= ( ch=='-') , ch=gc();
		while(ch>='0'&&ch<='9') x=x*10+ch-'0' , ch=gc(); x=f?-x:x;}
	template<typename T>void write(T x){char s[40];short d=0;T y=x;
		if(x<0) putchar('-'),y=-y;if(x==0){ putchar('0'); return; }
		while(y){s[++d]=y%10+'0';y/=10;}while(d>0)putchar(s[d--]);}
	template<typename T>void wris(T x,char c){write(x);putchar(c);}
}using namespace mystl;
const db eps=1e-6,PI=acos(-1);
namespace my{
	const int N=(int)(1e5+5);
	int low[N],dfn[N];
	vi g[N];
	int n,m,Time,Scc,have,start,top,stk[N],which[N],siz[N];
	bool in[N];
	void Tarjan(int x){
		dfn[x]=low[x]=++Time;
		stk[++top]=x;
		in[x]=true;
		for(int&v:g[x]){
			if(dfn[v]==0){
				Tarjan(v),
				low[x]=Min(low[x],low[v]);
			}
			else if(in[v])low[x]=Min(low[x],dfn[v]);
		}
		if(low[x]==dfn[x]){
			Scc++;
			while(stk[top]!=x){
				int t=stk[top--];
				in[t]=false;
				which[t]=Scc;
				siz[Scc]++;
			}
			in[x]=false;which[x]=Scc;siz[Scc]++;
			top--;
		}
	}
	int rd[N],cd[N];
	void solve(){
		cin>>n>>m;up(i,1,m){
			int x,y;cin>>x>>y;
			g[x].push_back(y);
		}
		up(i,1,n)if(dfn[i]==0)Tarjan(i);
		up(i,1,n)for(int&v:g[i])if(which[i]!=which[v])
			cd[which[i]]++,rd[which[v]]++;
		int rdx=0,cdx=0,Ma=0;
		up(i,1,Scc){
			if(!rd[i])rdx++;
			if(!cd[i])cdx++;
		}up(i,1,Scc)Ma=Max(Ma,siz[i]);
		if(Scc>1)cout<<Ma<<'\n'<<Max(rdx,cdx);
		else cout<<siz[1]<<'\n'<<0;
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	my::solve();return 0;
}

```

---

## 作者：ChickyHas (赞：1)

表面图论，实则构造。

第一问是简单的，写个 tarjan 求出最大的强连通分量就行了。

那么第二问在我们对 SCC 缩点后，我们可以先猜测答案可以取到下界，即入度为 0 的点数和出度为 0 的点数的最大值。

我们考虑把所有入度为 0 的点和出度为 0 的点进行匹配，考虑一些路径 $(u,v)$ 满足：

- $u$ 点入度为 0 且 $v$ 点出度为 0。
- $u,v$ 均两两不同。
- 对于入度为 0 的点 $u'$，一定存在某个点 $v$ 使得 $u'$ 可以到 $v$。
- 对于出度为 0 的点 $v'$，一定存在某个点 $u$ 使得 $u$ 可以到 $v'$。

怎么构造呢？

从每个入度为 0 的点出发进行 dfs，沿途打标记，如果到了出度为 0 的点就增加有一条路径，否则遇到打过标记的点就退出。

那么我们还是跑个 tarjan 就行了，记录一下所有没有入度、出度的强连通分量，最后取最大值。

---

## 作者：alvis (赞：1)

## 题意
给一张 $n$ 个点，$m$ 条边的有向图，求一个最大的强连通分量的点数，以及将该图变为强连通图还至少要几条边。

## 解决
比较显然的 tarjan 模板。

第一问直接上缩点，其间记录每个强连通分量的大小，最后处理最大值。

第二问考虑对于一个不是 SCG 的图，如果我们要将其变为 SCG，发现要做的肯定是连接两个特殊的点：一个 $0$ 入度点和一个 $0$ 出度点。

容易发现，我们连接这两个点所得到的结果，一定不比连接其余点的情况差。

所以最后的答案是多少呢？

显然，答案是 $0$ 入度点个数与 $0$ 出度点个数的最大值。

**tips：** 其余大部分题解也都讲到了，要注意，当图本身已经是强连通图时，第二问答案一定为 $0$。 ~~我才不会告诉你我一开始也没注意到~~。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+101;
int n, m, idx, times, cnt, top, outer, inner, maxn;
struct node {
    int e, ne;
}g[N << 2];

int h[N], stk[N], dfn[N], low[N], num[N], id[N], out[N], init[N];
bool can[N];

void add(int a, int b) {
    g[idx].e = b;
    g[idx].ne = h[a];
    h[a] = idx ++;
}
//tarjan板子
void tarjan(int u) {
    dfn[u] = low[u] = ++times;
    stk[++ top] = u, can[u] = true;
    for(int i = h[u];i != -1;i = g[i].ne) {
        int j = g[i].e;
        if(!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }else if (can[j]) low[u] = min(low[u], dfn[j]);
    }
    
    if(dfn[u] == low[u]) {
        cnt ++;
        while(stk[top+1] != u) {
            can[stk[top]] = false;
            //记录该强连通分量的大小
            num[cnt] ++;
            id[stk[top]] = cnt;
            top --;
        } 
    }
}

int main() {
	memset(h, -1, sizeof h); 
	
    cin >> n >> m;
    for(int i = 1, a, b;i <= m;i ++ ) {
        cin >> a >> b;
        add(a, b);
    }
    //tarjan（防止图不连通）
    for(int i = 1;i <= n;i ++) if(!dfn[i]) tarjan(i);
    //统计最大强连通分量的大小
    for(int i = 1;i <= cnt;i ++) {
        maxn = max(num[i], maxn);
    }
    
    cout << maxn << endl;
    
    //记录出边和入边情况
    for(int u = 1;u <= n;u ++) {
        for(int i = h[u];i != -1;i = g[i].ne) {
            int j = g[i].e;
            if(id[u] != id[j]) out[id[u]] ++, init[id[j]] ++;
        }
    }
    //统计有几个0出度和0入度
    for(int i = 1;i <= cnt;i ++) {
        if(!out[i]) outer ++;
        if(!init[i]) inner ++;
    }
    //特判图本身已经为强连通图的情况
    if(cnt == 1) cout << 0;
    else cout << max(outer, inner);
    return 0;
}
```


---

## 作者：qhr2023 (赞：1)

## solution

一道 Tarjan 的入门题。

第一问就是求图中最大的强联通分量的大小，跑一边 Tarjan 即可。

对于第二问，先考虑若一个有向图是强联通，则每个点一定有入度和出度。所以将一个图变成强联通图，就是让每个点都有入度和出度。

如何最小化加边操作？显然将出度为 $0$ 的点和入度为 $0$ 的点连边，可以尽可能节省操作数。如果这样的边都连完了，出度为 $0$ 或入度为 $0$ 的点还有剩余，那就只能和其他的点连边了。

所以第二问答案就是缩完点后的图中入度的为 $0$ 的点的个数和出度为 $0$ 的点的个数的最大值。

为什么一定要缩点呢，本题不缩点直接在原图找可以通过，但其实这会出问题。

举个例子，比如当图不联通且是一个环和一个链时，如果直接在原图找点，那么入度为 $0$ 的点有一个，即链的起点，出度为 $0$ 的点有一个，即链的终点，那这样输出 $1$，很明显这是错误的，至少要连两条边才能使原图强联通。

第二问注意特判，当只有一个强联通分量时，图本身就是强联通图，要输出 $0$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5, M=3e5+5;
int n, m, x[M], y[M], ct1, ct2, rd[N], cd[N], ans,
	dfn[N], low[N], tot, ins[N], top, st[N], bel[N], SCC;
vector<int> e[N], scc[N];
void tarjan (int u) {
	dfn[u]=low[u]=++tot;
	ins[u]=1;
	st[++top]=u;
	for (int v:e[u])
		if (!dfn[v])
			tarjan(v),
			low[u]=min(low[u], low[v]);
		else if (ins[v])
			low[u]=min(low[u], dfn[v]);
	if (dfn[u]==low[u]) {
		SCC++;
		while (1) {
			int v=st[top--];
			bel[v]=SCC;
			ins[v]=0;
			scc[SCC].push_back(v);
			if (u==v) break;
		}
	}
}
int main () {
	cin >> n >> m;
	for (int i=1; i<=m; ++i)
		cin >> x[i] >> y[i],
		e[x[i]].push_back(y[i]);
	for (int i=1; i<=n; ++i)
		if (!dfn[i])
			tarjan(i);
	for (int i=1; i<=SCC; ++i)
		ans=max(ans, (int)scc[i].size());
	for (int i=1; i<=m; ++i)
		if (bel[x[i]]!=bel[y[i]])
			cd[bel[x[i]]]++,
			rd[bel[y[i]]]++;
	for (int i=1; i<=SCC; ++i)
		ct1+=!rd[i], 
		ct2+=!cd[i];
	cout << ans << '\n';
	if (SCC==1)
		cout << 0;
	else
		cout << max(ct1, ct2);
	return 0;
}
```

---

## 作者：Cutest_Junior (赞：1)

## 题解 P7251 【[JSOI2014]强连通图】

### 题意

+ 给出一个 $n$ 个点 $m$ 条边的图；
+ 求图中最多有多少个点两两可达；
+ 求图中最少加多少条边使整个图变成强通图；
+ $n\le10^5,m\le3\times10^5$。

### 做法

“两两可达”、“强连通图”，题目已经告诉我们要用 Tarjan 算法了。

第一个问题就是求最大的强连通分量。

第二个问题，要使整个图变得强连通，就要求原图每个入度为 $0$ 的强连通分量都要连一条入边，出度为 $0$ 的强连通分量都连一条出边，显然最好的方法是出度为 $0$ 的强连通分量连向入度为 $0$ 的强连通分量。

那就对两类强连通量的个数取最大值即可。

注意一种特殊情况，如果整个图本身就是强连通图，那就不用再连边了，输出 $0$ 即可，但按上面的方法会输出 $1$，所以需要特判。

~~但是本题并没有这样的数据，不用特判也能过。~~

### hack

输入：

```
2 2
1 2
2 1
```

正确输出：

```
2
0
```

@[adaptive_route](https://www.luogu.com.cn/user/246019) 的题解的输出：

```
2 1
```

建议写一下 P2746 校园网，数据比此题强很多。

### 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

const int N = 1e5 + 5;

vector<int> edge[N];

void add(int u, int v) {
	edge[u].push_back(v);
}

int dfn[N], dfstot;
int low[N];
int scc[N], scctot;
stack<int> sta;

int ans;

void tarjan(int x) {
	dfn[x] = low[x] = ++dfstot;
	sta.push(x);
	for (int i = 0; i < edge[x].size(); ++i) {
		int to = edge[x][i];
		if (dfn[to] == 0) {
			tarjan(to);
			low[x] = min(low[x], low[to]);
		}
		else if (scc[to] == 0){
			low[x] = min(low[x], dfn[to]);
		}
	}
	if (low[x] == dfn[x]) {
		++scctot;
		int cnt = 0;
		while (1) {
			++cnt;
			int t = sta.top();
			sta.pop();
			scc[t] = scctot;
			if (t == x) {
				break;
			}
		}
		ans = max(ans, cnt);
	}
}

bool in[N], out[N];

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i) {
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v);
	}
	for (int i = 1; i <= n; ++i) {
		if (dfn[i] == 0) {
			tarjan(i);
		}
	}
	if (scctot == 1) {
		printf("%d\n0", n);
		return 0;
	}
	for (int i = 1; i <= n; ++i) {
		int si = scc[i];
		for (int j = 0; j < edge[i].size(); ++j) {
			int to = edge[i][j];
			int st = scc[to];
			if (si == st) {
				continue;
			}
			out[si] = 1;
			in[st] = 1;
		}
	}
	int cnt1 = 0, cnt2 = 0;
	for (int i = 1; i <= scctot; ++i) {
		if (in[i] == 0) {
			++cnt1;
		}
		if (out[i] == 0) {
			++cnt2;
		}
	}
	printf("%d\n%d", ans, max(cnt1, cnt2));
}
```

---

## 作者：MoGuYun_12 (赞：0)

强连通分量模板题。

首先 tarjan 求出原图中所有的强连通分量。对于第一问，因为每个强连通分量中的点两两可达，所以答案即为最大的强连通分量大小。

对于第二问。将每个强连通分量缩成一个点后，记入度为零的个数为 $in$，出度为零的点的个数为 $out$。如果 $in<out$，对每个入度为零的点再连条边到出度为零的即可。反之亦然。所以答案为 $\max(in,out)$。

注意特判原图只有一个强连通分量时，第二问不用多连任何边，所以答案为零。


```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5+5;
int n,m; 
int low[N],dfn[N],stk[N],ins[N],siz[N],scc[N],idx,top,id,in[N],out[N];
vector<int> e[N];

void tarjan(int x){
	dfn[x]=low[x]=++idx,stk[++top]=x,ins[x]=1;
	for(int i=0;i<e[x].size();i++){
		int y=e[x][i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(ins[y])
			low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		int y; id++;
		do{
			y=stk[top--];
			ins[y]=0,siz[id]++;
			scc[y]=id;
		}while(x!=y);
	}
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
    	int u,v; cin>>u>>v;
    	e[u].push_back(v);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	for(int x=1;x<=n;x++){
		for(int i=0;i<e[x].size();i++){
			int y=e[x][i];
			if(scc[x]!=scc[y]){
				in[scc[y]]++,out[scc[x]]++;
			}
		}
	}
	if(id==1){
		cout<<siz[1]<<endl<<0;
		return 0;
	}
	int c=0,c1=0,c2=0;
	for(int i=1;i<=id;i++){
		c=max(c,siz[i]);
		if(!in[i]) c1++;
		if(!out[i]) c2++;
	}
	cout<<c<<endl<<max(c1,c2);
	return 0;
}
```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可爱~~的 Tarjan 题。

### 前置知识

- [Tarjan](https://oi.wiki/graph/scc/)

### 思路

题目看上去有点难，实际上我们只需要将问题转化一下就可以了：

- 在给定的图中，最大的强连通分量的大小是多少？（这个很简单）
- 将给定的图缩点后，点的出度为 $0$ 的数量和点的入度为 $0$ 的数量的最大值是多少？（因为一个图是强连通分量图，肯定每个点的出度和入度不为 $0$，我们可以让出度为 $0$ 的点通向入度为 $0$ 的点，所以只需要求点的出度为 $0$ 的数量和点的入度为 $0$ 的数量的最大值是多少就可以了）

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n,m,dfn[N],low[N],cnt,scc[N],now,in[N],out[N],ans1,ans2,ans,siz[N];
vector<int> g[N],scc_g[N];
stack<int> st;
bool vis[N];
void tarjan(int x){
    dfn[x] = low[x] = ++cnt;
    st.push(x);
    vis[x] = 1;
    int size = g[x].size();
    for(int i = 0;i < size;i ++){
        int y = g[x][i];
        if(dfn[y] == 0){
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }else if(vis[y] == true){
            low[x] = min(low[x],dfn[y]);
        }
    }
    if(dfn[x] == low[x]){
        now ++;
        while(st.top() != x){
            scc[st.top()] = now;
            vis[st.top()] = false;
            siz[now] ++;
            st.pop();
        }
        scc[st.top()] = now;
        vis[st.top()] = false;
        siz[now] ++;
        st.pop();
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i = 1;i <= m;i ++){
        int x,y;
        cin >> x >> y;
        g[x].push_back(y);
    }
    for(int i = 1;i <= n;i ++){
        if(dfn[i] == 0){
            tarjan(i);
        }
    }
    for(int i = 1;i <= n;i ++){
        for(auto j : g[i]){
            if(scc[i] != scc[j]){
                in[scc[j]] ++; // 统计入度
                out[scc[i]] ++; // 统计出度
            }
        }
    }
    for(int i = 1;i <= now;i ++){
        ans = max(ans,siz[i]); // 统计答案 1
        if(in[i] == 0){
            ans1 ++; // 统计入度为 0 的点的数量
        }
        if(out[i] == 0){
            ans2 ++; // 统计出度为 0 的点的数量
        }
    }
    if(now == 1){ // ！！！这里要特判
        cout << n << '\n' << 0;
        return 0;
    }
    cout << ans << '\n' << max(ans1,ans2);
    return 0;
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P7251)

第一个问题比较简单，就是让我们求图中最大的强联通分量的节点个数。

非常好想的思路：Tarjan 缩点顺便记录大小，然后一个一个枚举强联通分量，找出最大的就行了。

那第二个问题如何解决？

考虑缩完点后的 DAG。

很明显，如果此图有入度为 $0$ 的节点，那么这个图一定不是强联通的。同样，如果此图有出度为 $0$ 的节点，那么这个图也一定不是强联通的。

所以我们的任务就是让所有出度为 $0$ 的节点连一条边到入度为 $0$ 的节点，求边的数量。

显然，答案就是入度为 $0$ 的节点数量和出度为 $0$ 的节点数量的较大值。

这里还有一个坑点：若整个图都是强联通的，那么要特判输出 $0$，否则会输出 $1$，不过数据没有判断这种情况。

代码：

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,m,cnt,tot,ans,I,O;
vector <int> G1[N],G2[N];
int dfn[N],low[N],S[N],siz[N];
bool In[N],Out[N];
stack <int> st;
void Tarjan(int k){
	low[k]=dfn[k]=++cnt;st.push(k);
	for(int i(0);i<G1[k].size();++i){
		int s(G1[k][i]);
		if(!dfn[s]){
			Tarjan(s);
			low[k]=min(low[k],low[s]);
		}
		else if(!S[s]) low[k]=min(low[k],dfn[s]);
	}
	if(low[k]==dfn[k]){
		int x(-1);++tot;
		while(x^k){
			x=st.top();st.pop();
			S[x]=tot;++siz[tot];
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=m;++i){
		int u,v;scanf("%d%d",&u,&v);
		G1[u].push_back(v);
	}
	for(int i(1);i<=n;++i) if(!dfn[i]) Tarjan(i);
	for(int i(1);i<=tot;++i) ans=max(ans,siz[i]);
	printf("%d\n",ans);
	if(tot^1){
		for(int u(1);u<=n;++u)
			for(int i(0);i<G1[u].size();++i){
				int v(G1[u][i]);
				if(S[u]^S[v]) In[S[v]]=1,Out[S[u]]=1;
			}
		for(int i(1);i<=tot;++i) I+=(In[i]^1),O+=(Out[i]^1);
		printf("%d\n",max(I,O));
	}
	else puts("0");
	return 0;
}
```

---

## 作者：5793__qwq (赞：0)

终于A了这题。
### 解决方法：
第一问直接用 $tarjan$算法，找出最大的强连通分量。

第二问是把图缩点，然后 $DAG$（拓扑排序），就OK了。

附上一图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j4priaac.png)
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next;
}e[100001];
int head[10001],d[10001],fa[10001],vis[10001],xb,s,n,m,x,y,w,cnt,of[10001],cd[10001],rd[10001];
stack<int> st;
void adde(int f,int t){
	e[++xb].to=t;
	e[xb].next=head[f];
	head[f]=xb;
}
void dfs(int x){
    //d数组表示是第几个访问到的，fa数组表示i节点的祖先 
    if(!vis[x])
        st.push(x);
	d[x]=fa[x]=++s;
	vis[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(!d[y]){
			dfs(y);
			fa[x]=min(fa[x],fa[y]);
		}else
		if(vis[y])
			fa[x]=min(fa[x],d[y]);
	}
	if(fa[x]==d[x]){
		of[0]++;
		int ss=0;
		while(st.top()!=x){
			++ss;
			vis[st.top()]=0;
			of[st.top()]=of[0];
			st.pop();
		}
		cnt=max(cnt,ss+1);
		vis[st.top()]=0;
		of[st.top()]=of[0];
		st.pop();
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		cin>>x>>y;
		adde(x,y);
	}
	for(int i=1;i<=n;++i)
		if(!d[i])
			dfs(i);
	cout<<cnt<<'\n';
	if(of[0]==1){
		cout<<0;
		return 0;
	}
	//----------下面是DAG----------
	for(int i=1;i<=n;++i){
		for(int j=head[i];j;j=e[j].next){
			int x=e[j].to;
			if(of[i]!=of[x])
				cd[of[x]]++,rd[of[i]]++;
		}
	}
	for(int i=1;i<=of[0];++i){
		if(!cd[i]) 
			++cd[0];
		if(!rd[i]) 
			++rd[0];
	}
	cout<<max(rd[0],cd[0]);
	return 0;
}
```


---


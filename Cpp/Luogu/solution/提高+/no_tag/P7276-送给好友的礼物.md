# 送给好友的礼物

## 题目背景

小 M 和小 B 是一对好朋友，她们很喜欢草莓。

## 题目描述

给定一棵包含 $n$ 个结点的树 $T$，结点从 $1 \sim n$ 顺序编号。

小 M 和小 B 在时刻 $0$ 都在 $1$ 号结点。从时刻 $1$ 开始的每个时刻初，小 M 和小 B 都可以选择：移动到一个和自己所在结点直接相连的结点，或者停留在当前所在的结点。

树上有 $k$ 个草莓，它们分布在 $k$ 个不同的结点上。小 M 和小 B 想要收集到所有的草莓，任何一个时刻末，如果小 M 或者小 B 在某一个草莓所在的结点上，那么这个草莓就被收集了。

她们不想花费太多的时间，因此你需要回答：至少在第几时刻末，小 M 和小 B 可以收集到所有的草莓，并且都回到结点 $1$。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/bhe4q1zn.png)

小 M 的路线是：$1 \to 2 \to 3 \to 2 \to 4 \to 2 \to 1$。

小 B 的路线是：$1 \to 5 \to 6 \to 7 \to 6 \to 5 \to 1$。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（$6$ 分）：$n \leq 3$。
- Subtask 2（$1$ 分）：$k = 1$。
- Subtask 3（$11$ 分）：$n \leq 7$。
- Subtask 4（$17$ 分）：$k \leq 20$。
- Subtask 5（$42$ 分）：$n \leq 90$。
- Subtask 6（$23$ 分）：无特殊限制。

对于 $100 \%$ 的数据，$1 \leq k \leq n \leq 415$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
7 4
1 2
2 3
2 4
1 5
5 6
6 7
3 4 5 7```

### 输出

```
6```

## 样例 #2

### 输入

```
1 1
1```

### 输出

```
0```

# 题解

## 作者：ez_lcw (赞：11)

**$O(n^2)$ 做法。**

为了简化题目，如果以一个点为根的子树内不包含任何草莓节点，就把这棵子树去掉。

显然这样做不会影响答案，而且所有叶子节点都是草莓节点。

我们现在的问题变成了：对于这棵新树，有两个人同时从根开始去遍历它，然后问整棵树都被遍历完且两人最后回到根的最小时间是多少。

由于是时间，所以答案为两人走的路径长的 $\max$ 而不是和，没有什么显然的结论，所以考虑用 dp 来解决。

设 $dp(i,j)$ 表示遍历完以 $i$ 为根的子树，其中第一个人走了 $j$ 步，问第二个人最少走多少步。那么此时两人遍历完 $i$ 子树消耗的时间为 $\max(j,dp(i,j))$。

dp 转移明显可以用树形背包来解决，具体的 dp 方程和解释详见代码注释：

```cpp
#include<bits/stdc++.h>

#define N 450
#define INF 0x7fffffff

using namespace std;

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}

int n,k;
int cnt,head[N],nxt[N<<1],to[N<<1];
int fa[N],size[N],dp[N][N<<1];//遍历完i子树，第一个人走了j步，第二个人的最小步数 
bool vis[N];

void adde(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

bool dfs(int u)
{
	bool fruit=0;//fruit表示当前子树内有没有草莓
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa[u]||!v) continue;
		fa[v]=u;
		bool now=dfs(v);
		if(!now) to[i]=0;//如果v子树内没有草莓，我们就把to[i]设为0，表示v子树被删掉
		fruit|=now;
	}
	return fruit|vis[u];
}

void solve(int u)
{
	size[u]=1;
	dp[u][0]=0;
	for(int l=head[u];l;l=nxt[l])
	{
		int v=to[l];
		if(v==fa[u]||!v) continue;//如果v=0，说明v子树被删掉
		solve(v);
		size[u]+=size[v];
		for(int i=(size[u]-1)*2;i>=0;i--)//枚举第一个人走了i步，上界为整棵树的边数*2（每条边往返共两次），注意从大到小枚举
		{
			dp[u][i]=dp[u][i]+dp[v][0]+2;//这里是当第一个人不进入v子树时，此时第一个人不会走边(u,v)；同时这里利用了上一次的dp值进行更新
			if(i>=size[v]*2) dp[u][i]=min(dp[u][i],dp[u][i-size[v]*2]+dp[v][(size[v]-1)*2]);//这里是当第二个人不进入v子树时，此时第二个人不会走边(u,v)
			for(int j=min((size[v]-1)*2,i-2);j>=0;j--)//这里是第一个人和第二个人都进入v子树时，枚举第一个人进到v子树内走了多少步，顺序或倒序枚举都可以
				dp[u][i]=min(dp[u][i],dp[u][i-j-2]+dp[v][j]+2);//这里出现的“2”均是因为算上边(u,v)被往返走两次
		}
	}
}

int main()
{
	memset(dp,0x3f,sizeof(dp));
	n=read(),k=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		adde(u,v),adde(v,u);
	}
	for(int i=1;i<=k;i++)
		vis[read()]=1;
	dfs(1);
	solve(1);
	int ans=INF;
	for(int i=0;i<=(size[1]-1)*2;i++)
		ans=min(ans,max(i,dp[1][i]));
	printf("%d\n",ans);
	return 0;
}
/*
4 1
1 2
2 3
3 4
3
*/ 
```

关于时间复杂度的证明：dp 的实质可以看做枚举树中的点对 $(u,v)$，然后当且仅当存在某一个 $root$，使得 $u$ 和 $v$ 分别在 $root$ 的两个儿子的子树中。显然，对于每一个点对 $(u,v)$，有且仅有一个 $root=\operatorname{lca}(u,v)$。所以总时间复杂度是 $O(n^2)$。

~~其实学过树形背包的都不用看证明。~~

**感谢神 Froggy 提供的思路。**

---

## 作者：SSerxhs (赞：10)

赛时一血，**非正解**

考虑先按照 dfs 序排序，则若一个人走过的点为序列 $\{b_n\}$，则 $b_n$ 必定是按照 dfs 序单增的。

那么有个骗分的贪心思路：可能某个人走过的 dfs 序是连续的，我们只需要枚举两个端点计算其中的答案和另一个人走过其他点的答案就可以了。计算答案的方法是计算序列中相邻两个点的距离之和，即 $dep_{b_1}+dep_{b_n}+\sum\limits_{i=1}^{n-1}dis(b_i,b_{i+1})$。这种方案的答案是两人走距离的 $\max$，最终答案是所有方案距离的 $\min$

交一发发现 wa 成 7pts

但是通过的点其实不少，那可以考虑做 $1000$ 次这个过程，每一次随机打乱子节点序列。

然后它过了

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
std::mt19937 rnd(time(0));
inline int sj(int n)
{
	unsigned int x=rnd();
	return x%n+1;
}
#define rand fst
template<typename typC> void read(register typC &x)
{
	register int c=getchar(),fh=1;
	while ((c<48)||(c>57))
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
template<typename typC> void write(register typC x)
{
	if (x<0) putchar('-'),x=-x;
	static int st[100];
	register int tp=1,y;st[1]=x%10;x/=10;
	while (x) y=x/10,st[++tp]=x-y*10,x=y;++tp;
	while (--tp) putchar(st[tp]|48);
}
template<typename typC> void write(register typC *a,register int num)
{
	for (register int i=1;i<=num;i++) write(a[i]),putchar(i==num?10:32);
}
#define space(x) write(x),putchar(32)
#define enter(x) write(x),putchar(10)
const int N=1e6+2,M=1e6+2,p=998244353;
inline void inc(register int &x,const int y)
{
	if ((x+=y)>=p) x-=p;
}
inline void dec(register int &x,const int y)
{
	if ((x-=y)<0) x+=p;
}
inline int ksm(register int x,register int y)
{
	register int r=1;
	while (y)
	{
		if (y&1) r=(ll)r*x%p;
		x=(ll)x*x%p;
		y>>=1;
	}
	return r;
}
char s[N];
int dfn[N],top[N],d[N],siz[N],hc[N],dep[N],f[N],a[N];
vector<int> lj[N];
int T,n,m,c,i,j,k,x,y,z,ans,la;
void dfs1(int x)
{
	dfn[x]=++ans;siz[x]=1;
	for (int i=0;i<lj[x].size();i++) if (lj[x][i]!=f[x])
	{
		dep[lj[x][i]]=dep[f[lj[x][i]]=x]+1;
		dfs1(lj[x][i]);
		siz[x]+=siz[lj[x][i]];
		if (siz[lj[x][i]]>siz[hc[x]]) hc[x]=lj[x][i];
	}
}
void dfs2(int x)
{
	if (hc[x])
	{
		int i;
		top[hc[x]]=top[x];
		dfs2(hc[x]);
		for (i=0;i<lj[x].size();i++) if (lj[x][i]!=f[x]&&lj[x][i]!=hc[x]) dfs2(top[lj[x][i]]=lj[x][i]);
	}
}
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
inline int lca(int x,int y)
{
	while (top[x]^top[y]) if (dep[top[x]]<dep[top[y]]) y=f[top[y]]; else x=f[top[x]];
	return dep[x]<dep[y]?x:y;
}
inline int dis(int x,int y)
{
	return dep[x]+dep[y]-(dep[lca(x,y)]<<1);
}
int main()
{
	read(n);read(m);srand(time(0));
	for (i=1;i<n;i++) read(x),read(y),lj[x].push_back(y),lj[y].push_back(x);
	for (i=1;i<=m;i++) read(a[i]);ll ans=9e18;
	for (int T=1;T<=100;T++)
	{
		memset(f+1,0,n<<2);
		for (i=1;i<=n;i++) random_shuffle(lj[i].begin(),lj[i].end());
		dfs1(1);dfs2(top[1]=1);
		sort(a+1,a+m+1,cmp);
		a[m+1]=a[1];a[0]=a[m];
	for (i=1;i<=m;i++) d[i]=dis(a[i],a[i+1])+d[i-1];
	for (i=1;i<=m;i++) for (j=i;j<=m;j++)
	{
		ll la,laa;
		la=dep[a[i]]+dep[a[j]];laa=dep[a[i-1]]+dep[a[j+1]];
		la+=d[j-1]-d[i-1];
		laa+=d[i==1?m-1:m]-d[j]+d[i-1];
		ans=min(ans,max(la,laa));
	}
	}
	printf("%lld",ans);
}
```

---

## 作者：w9095 (赞：5)

[P7276 送给好友的礼物](https://www.luogu.com.cn/problem/P7276)

我们充分发扬人类智慧。

首先分析性质，如果一个有草莓的节点子树中存在有草莓的节点，那么我们就直接不管这个有草莓的节点，因为首先子树内的草莓已经会遍历这个点。

另外，根据 [P3320 [SDOI2015] 寻宝游戏](https://www.luogu.com.cn/problem/P7276) 的结论，一个人肯定是按照 DFS 序大小遍历它需要遍历的草莓节点。

注意到 $n\le451$，考虑模拟退火。每次随机交换遍历草莓的顺序，再把序列划分为前后两个集合分别给两个人走，取最大值，可以得到 $77$ 分。

注意到这么做是极其不合理的，因为排序之后对答案影响较大的是每个点的 DFS 序而不是如何分配，于是我们模拟退火随机打乱出边，就可以获得 $100$ 分的好成绩。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct val
{
	int v,p;
}w[500];
int n,m,u,v,h[500],a[500],c[500],f[500],b[500],d[500][500],dfn[500],ans=1e9,cnt=0,dfc=0;
vector<int>s[500],tmp[500];
mt19937 rd(time(0));
bool cmp(struct val a,struct val b)
{
	return a.p<b.p;
}

void dfs1(int x,int fa)
{
	for(int i=0;i<s[x].size();i++)
	    if(s[x][i]!=fa)dfs1(s[x][i],x),c[x]|=c[s[x][i]],f[x]|=c[s[x][i]];
}

void dfs2(int x,int fa,vector<int>s[])
{
	dfn[x]=++dfc;
	for(int i=0;i<s[x].size();i++)
	    if(s[x][i]!=fa)dfs2(s[x][i],x,s);
}

int cal(vector<int>s[])
{
	dfc=0,dfs2(1,0,s);
	for(int i=1;i<=m;i++)w[i].v=a[i],w[i].p=dfn[a[i]];
	sort(w+1,w+m+1,cmp);
	int la=0,ra=d[1][w[1].v]+d[w[m].v][1],mi=1e9,pr=1e9;
	for(int i=1;i<m;i++)ra+=d[w[i].v][w[i+1].v];
	mi=ra;
	for(int i=1;i<m;i++)
	    {
	    la=d[1][w[1].v]+d[w[i].v][1];
	    for(int j=1;j<i;j++)la+=d[w[j].v][w[j+1].v];
	    ra=d[1][w[i+1].v]+d[w[m].v][1];
	    for(int j=i+1;j<m;j++)ra+=d[w[j].v][w[j+1].v];
	    if(max(la,ra)>pr)break;
	    mi=min(mi,max(la,ra)),pr=max(la,ra);
	    }
	return mi;
}

void sa()
{
	double t=2e5,k=0.99;
	while(t>=1e-5)
	    {
	    	if((double)clock()/CLOCKS_PER_SEC>3.5)return;
	    	int c=t/1000.0*(double)m+1,del=0,now=0;
	    	for(int i=1;i<=n;i++)tmp[i]=s[i];
	    	for(int i=1;i<=c;i++)
	    	    {
	    	    int x=rd()%n+1;
			    shuffle(s[x].begin(),s[x].end(),rd);
			    }
	    	now=cal(s),del=now-cal(tmp),ans=min(ans,now);
			if(del>=0)
			  {
			   double p=exp(-del/t);
			   if((double)rd()/UINT_MAX>=p)
			      for(int i=1;i<=m;i++)s[i]=tmp[i];
		      }
			t*=k;
		}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=n;j++)
	        if(i!=j)d[i][j]=1e9;
	        else d[i][j]=0;
	for(int i=1;i<=n-1;i++)scanf("%d%d",&u,&v),d[u][v]=d[v][u]=1,s[u].push_back(v),s[v].push_back(u);
	for(int i=1;i<=m;i++)scanf("%d",&a[i]),c[a[i]]=1;
	for(int k=1;k<=n;k++)
	    for(int i=1;i<=n;i++)
	        for(int j=1;j<=n;j++)
	            d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	dfs1(1,0),cnt=0;
	for(int i=1;i<=m;i++)
	    if(!f[a[i]])a[++cnt]=a[i];
	m=cnt;
	for(int i=1;i<=n;i++)c[i]=0;
	for(int i=1;i<=m;i++)c[a[i]]=1;
	while((double)clock()/CLOCKS_PER_SEC<3.5)sa();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Leasier (赞：4)

前置芝士：[树形背包](https://oi-wiki.org/dp/tree/#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85)

看到这玩意第一反应是设 $dp_{u, i}$ 表示在 $u$ 子树内，小 M 选了 $i$ 个的最小代价，但由于贡献是取 $\max$，这个 dp 几乎没法转移……

为了方便处理 $\max$，考虑固定小 M 走了多少步时，在某个子树内小 B 至少走多少步。

具体地，设 $dp_{u, i}$ 表示在 $u$ 子树内，小 M 走了 $i$ 步时小 B 至少要走多少步。

下文中我们值考虑那些**子树内有关键点的点，其他点我们需要直接删掉**。

初值：$dp_{u, i} = [i \neq 0] \infty$。

转移分为以下三种：

- 小 M 不进入 $v$ 子树

此时 $dp'_{u, i} \leftarrow \min(dp'_{u, i}, dp_{u, i} + dp_{v, 0} + 2)$。

- $v$ 子树全部由小 M 负责

此时 $dp'_{u, i} \leftarrow \min(dp'_{u, i}, dp_{u, i - 2size_v} + dp_{v, 2(size_v - 1)})$。

- 小 M 和小 B 都要去 $v$ 子树内

此时 $dp'_{u, i} \leftarrow \min(dp'_{u, i}, dp_{u, j} + dp_{v, i - j - 2} + 2)$。

答案为 $\displaystyle\min_{i = 0}^{2(size_1 - 1)} \max(dp_{1, i}, i)$。

时间复杂度为 $O(n^2)$。~~不是很理解为什么出题人只开到了 $n = 415$。~~

代码：
```cpp
#include <stdio.h>

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int head[417], fa[417], size1[417], size2[417], dp[417][837];
bool vis[417];
Edge edge[837];

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs(int u, int father){
	fa[u] = father;
	size1[u] = vis[u] ? 1 : 0;
	size2[u] = 1;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father){
			dfs(x, u);
			if (size1[x] != 0){
				size1[u] += size1[x];
				size2[u] += size2[x];
			}
		}
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

void dfs2(int u){
	int up1 = (size2[u] - 1) * 2;
	for (register int i = 1; i <= up1; i++){
		dp[u][i] = 1e9;
	}
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != fa[u] && size1[x] != 0){
			int up2 = (size2[x] - 1) * 2;
			dfs2(x);
			for (register int j = up1; j >= 0; j -= 2){
				dp[u][j] += dp[x][0] + 2;
				if (j > up2) dp[u][j] = min(dp[u][j], dp[u][j - up2 - 2] + dp[x][up2]);
				for (register int y = 0; y + 2 <= j && y <= up2; y += 2){
					dp[u][j] = min(dp[u][j], dp[x][y] + dp[u][j - y - 2] + 2);
				}
			}
		}
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

int main(){
	int n, k, up, ans = 0x7fffffff;
	scanf("%d %d", &n, &k);
	for (register int i = 1; i < n; i++){
		int u, v;
		scanf("%d %d", &u, &v);
		add_edge(u, v);
		add_edge(v, u);
	}
	for (register int i = 1; i <= k; i++){
		int a;
		scanf("%d", &a);
		vis[a] = true;
	}
	dfs(1, 0);
	up = (size2[1] - 1) * 2;
	dfs2(1);
	for (register int i = 0; i <= up; i += 2){
		ans = min(ans, max(dp[1][i], i));
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/19051152)


众所周知，当两个 trick 被强行揉在了一起，它就成了一道新题。

观察路径，好像没有什么特别厉害的性质。因为数据范围较小，所以不难想到**暴力 DP**：定义 $dp_{u, i, j}$ 表示 $u$ 的子树内，小 M 走 $i$ 步，小 B 走 $j$ 步**能否**将整颗子树全部拿完。转移的时候需要做双层树上背包，复杂度直接爆炸，显然不可行。

考虑对 DP 进行优化，注意到 DP 内的值只能是 $0/1$，**值域极小**，且当 $i$ 确定、有合法方案时，$j$ **更小一定更优**，所以考虑“**交换 DP 维度**”的经典 trick。具体地，交换 $j$ 与 $dp$，新状态就是 $dp_{u,i}$ 表示 $u$ 子树内，小 M 走了 $i$ 步，**在将整颗子树拿完的前提下**，小 B 最少要走的步数。

接下来就是个很板的树形背包了，运用**上下界优化**可以做到 $O(n^2)$。合并背包的转移方程如下：

 $$ dp_{u, i + j + \left[j > 0\right ] \times 2} \overset{\min}{\leftarrow} f_{u,i}+dp_{v, j} + \left [ dp_{v, j}>0 \right ]\times 2 $$

其中，$f_{u,i}$ 表示 $dp$ 数组的前一个版本，目的是防止用这一轮合并得到的 $dp$ 更新这一轮的值。

注意要特判 $u$ 为子树内唯一一个苹果的 corner，将他标记为叶子并对其特殊转移。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi = pair<int, int>;
const int N = 420, inf = 0x3f3f3f3f;
int n, m, a[N], dp[N][2 * N], sz[N], f[2 * N], ans = inf;
bool leaf[N];
vector<int> g[N];
void merge(int u, int v)
{
    memcpy(f, dp[u], sizeof(f));
    memset(dp[u], 0x3f, sizeof(dp[u]));
    if(leaf[v])
    {
        for(int i = 0; i <= (sz[u] - 1) * 2; i += 2)
        {
            dp[u][i + 2] = min(dp[u][i + 2], f[i]);
            dp[u][i] = min(dp[u][i], f[i] + 2);
        }
    }
    else
    {
        for(int i = 0; i <= (sz[u] - 1) * 2; i += 2)
            for(int j = 0; j <= (sz[v] - 1) * 2; j += 2)
                dp[u][i + j + (j > 0) * 2] = min(dp[u][i + j + (j > 0) * 2], 
                                            f[i] + dp[v][j] + (dp[v][j] > 0) * 2);
    }
    sz[u] += sz[v]; 
    a[u] += a[v];    
}
void dfs(int u, int fa)
{
    bool flag = a[u];
    sz[u] = 1;
    dp[u][0] = 0;
    for(auto v : g[u])
    {
        if(v == fa) continue;
        dfs(v, u);
        merge(u, v);   
    }
    if(a[u] == 0) dp[u][0] = 0;
    else if(a[u] == 1 && flag) leaf[u] = 1;
}
int main()
{
    //freopen("sample.in", "r", stdin);
    //freopen("sample.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i = 1; i <= m; i++)
    {
        int tmp;
        cin >> tmp;
        a[tmp]++;
    }
    memset(dp, 0x3f, sizeof(dp));
    dfs(1, 0);
    for(int i = 0; i <= 2 * (n - 1); i++)
        ans = min(ans, max(dp[1][i], i));
    cout << ans;
    return 0;
}
```

---

## 作者：Celtic (赞：1)

首先去掉空子树，那么现在的问题就变成了用最短的时间遍历整个子树。设 $f_{u,i}$ 表示 $u$ 的子树内，小 M 走了 $i$ 步，小 B 至少还需要走多少步。那么答案就是 $\min \{\max(f_{1,i},i)\}$。
考虑转移，分三种情况。
1. 小 M 进入 $v$ 这个子树，小 B 没进入。
2. 小 M 没进入，小 B 进入。
3. 两人都进入。

如果进入的话就将对应的步数 $+2$ ，树上背包合并转移即可。

```cpp
#include<bits/stdc++.h>
#define N 301001
#define MAX 450
#define inf 2e9
#define PI acos(-1)
#define eps 1e-10 
using namespace std;
typedef long long ll;
typedef double db;
inline void read(ll &ret)
{
	ret=0;char c=getchar();bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,k,x,y,siz[N];
bool b[N];
vector<ll>v[N];
inline void predfs(ll ver,ll fa)
{
	siz[ver]=b[ver];
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(to==fa)
			continue;
		predfs(to,ver);
		siz[ver]+=siz[to];
	}
	return;
}
ll dp[MAX][MAX<<1],f[N];
ll num[N];
inline void dfs(ll ver,ll fa)
{
	num[ver]=1;
	for(int i=1;i<(MAX<<1);i++)
		dp[ver][i]=inf;
	for(int i=0;i<v[ver].size();i++)
	{
		ll to=v[ver][i];
		if(to==fa||!siz[to])
			continue;
		dfs(to,ver);
		for(int j=0;j<=2*num[ver];j++)
			f[j]=dp[ver][j],dp[ver][j]=inf;
		for(int j=2*num[ver];j+1;j--)
			for(int k=2*num[to];k+1;k--)
				dp[ver][j+k+2]=min(dp[ver][j+k+2],f[j]+dp[to][k]+2);
		for(int j=0;j<=2*num[ver];j++)
			dp[ver][j]=min(dp[ver][j],f[j]+dp[to][0]+2);
		for(int j=0;j<=2*num[ver];j++)
			for(int k=0;k<=2*num[to];k++)
				if(!dp[to][k])
					dp[ver][j+k+2]=min(dp[ver][j+k+2],f[j]);
		num[ver]+=num[to];
	}
	return;
}
signed main()
{
	read(n);
	read(k);
	for(int i=1;i<n;i++)
	{
		read(x);
		read(y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for(int i=1;i<=k;i++)
	{
		read(x);
		b[x]=true;
	}
	predfs(1,0);
	dfs(1,0);
	ll ans=inf;
	for(int i=0;i<=2*n;i++)
		ans=min(ans,max((ll)i,dp[1][i]));
	printf("%lld\n",ans);
	exit(0);
}
```

---


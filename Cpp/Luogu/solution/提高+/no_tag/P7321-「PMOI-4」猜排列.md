# 「PMOI-4」猜排列

## 题目背景

**这是一道 IO 交互题。**

**请各位选手确认好再提交，防止评测机爆炸。**

## 题目描述

小 A 有一个长度为 $n$ 的**排列** $a$，他想请你猜一猜这个排列。你仅能给出以下两种询问：

- `! x y`，他将会告诉你 $a_x \bmod a_y$ 的值，其中你询问的数应当满足 $a_x\gt a_y$ 且 $x\ne y$；否则，他会不高兴并直接判定询问不合法，从而导致 `WA`。
- `? l S p`，你需要给小 A 一个大小为 $l$ 的集合 $S$ 与一个整数 $p$，其中 $S=\{x_1,x_2,x_3,\ldots,x_l\}$，其中对于任意 $1\le i\le l$，$1\le x_i\le n$，且 $x_i$ 互不相同，还要满足 $1\le p\le n$，$1\le l\le n$，小 A 将会告诉你这个集合中 $a_{x_k} \ge p$ 的所有的 $x_k$，返回形式如下：首先会返回一个整数 $L$，接着会返回 $L$ 个整数，表示有 $L$ 个满足条件的 $k$（注意返回的是集合 $S$ 中的元素，而不是下标！）。

你最多只能向小 A 询问 $m_1$ 个问题 $1$，$m_2$ 个问题 $2$，其中问题二中询问的集合大小之和应不超过 $m_3$ 来猜出这个序列。

## 说明/提示

【数据范围】

**本题采用捆绑测试。**

| Subtask 编号 | 分值 |$n=$ | $m_1=$ | $m_2=$ | $m_3=$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $4$ | $4$ | $1$ | $4$ | 无 | 
| $2$ | $10$ | $5 \times 10^2$ | $5 \times 10^2$ | $5 \times 10^2$ | $2.5\times 10^5$ | 无 |
| $3$ | $10$ | $2 \times 10^4$ | $2 \times 10^4$ | $2 \times 10^4$ | $3 \times 10^5$ | A |
| $4$ | $20$ | $10^4$ | $10^4$ | $30$ | $3 \times 10^5$ | 无 |
| $5$ | $20$ | $5 \times 10^4$ | $5 \times 10^4$ | $34$ | $4 \times 10^5$ | 无 |
| $6$ | $25$ | $5 \times 10^4$ | $5 \times 10^4$ | $17$ |  $1.5\times 10^5$ | 无 |
| $7$ | $5$ | $5 \times 10^4$ | $5 \times 10^4$ | $15$ | $1.5\times 10^5$ | 无 |

**A：保证排列 $a$ 随机构造**。

【提示】

1. 询问不合法或交互库输出数超过 $m$ 后继续询问会直接导致 WA。

2. 数据范围的顶栏都是 $=$ 而非 $\le$。

## 样例 #1

### 输入

```
3 100 100 100

1 3

1 2```

### 输出

```
? 3 1 2 3 3

? 2 1 2 2

A 1 2 3```

# 题解

## 作者：Suzt_ilymtics (赞：11)


## 写在前面

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/15168814.html)

感谢 @zimujunqwq 的思路。

## Description

[题目描述](https://www.luogu.com.cn/problem/P7843)。

~~不知如何简化题意。~~

## Solution

### Subtask1

考虑用询问 $2$ 把 $3, 4$ 的元素位置确定，那么剩下的 $1,2$ 的两个位置也能确定。

注意我们暂时还不能区分他们。

此时利用询问 $1$，询问 $3,4$ 两个位置对 $1,2$ 两个位置取模的结果。

他们的结果是不同的，所以可以确定出 $1,2,3,4$ 对应的位置了。

期望得分 $10pts$。

### Subtask2

通过观察数据范围发现 $m_2^2 = m_3$。

所以注定这是一个 $O(n^2)$ 算法。

我们可以利用 $2$ 操作询问 $n$ 次。把 $p$ 从 $n$ 不断下调，即每次询问 $p$ 都比上一次小 $1$。

这样每次询问我们都会多知道一个元素的位置，而这个元素的值也是确定的。

期望得分 $10 pts$。

### Subtask3,4,5

反正我没看出 Subtask3,4 有什么单独的做法，有卡到这一档的可以单独和我说一声qwq。

注意到后面的数据 $n = m_1$，所以我们可能每次询问 $1$ 都要确定出一个位置。

现在假设我们知道了 $\left \lceil \frac{n}{2} \right \rceil$ 的位置，那么不难发现， $\left \lceil \frac{n}{2} \right \rceil + 1 \sim n$ 这些数对 $\left \lceil \frac{n}{2} \right \rceil$ 取模的值是互不相同的。这就启发我们可以先确定出 $\left \lceil \frac{n}{2} \right \rceil$ 的位置，然后通过几次询问确定他后面的数的位置。~~注意模数为 $0$ 时要特判一下。~~

这样的话，问题的规模就会缩小一半。

我们就可以继续处理剩下一半的情况。

如何确定 $\left \lceil \frac{n}{2} \right \rceil$ 的位置？

可以询问两次询问 $2$ 。第一次求出 $>\left \lceil \frac{n}{2} \right \rceil$ 的所有位置，第二次求出 $\ge \left \lceil \frac{n}{2} \right \rceil$ 的所有位置，那么新增加的位置就是 $\left \lceil \frac{n}{2} \right \rceil$。

我们可以发现，这样递归处理需要 $\log n$ 次，并且数据范围是 $2 \log n \le m_2$。

期望得分 $50pts$。

### Subtask6

观察数据发现 $2^{17} \ge 5 \times 10^4$。

那就是说只让我们进行 $\log n$ 次询问。

我们考虑通过询问 $1$ 把 $\left \lceil \frac{n}{2} \right \rceil$ 的位置求出来。我们想知道他的位置可以通过知道 $\left \lceil \frac{n}{4} \right \rceil$  的位置求出来。然后我们不断这样递归下去，发现我们只要知道了 $1$ 的位置，并且知道了各个段的位置，就可以回溯到整个序列。而 $1$ 的位置会在最后我们通过询问 $2$ 询问 $p=1,2$ 的时候求出。

这样的话，我们就可以在 $\log n$ 次询问 $2$ 内求出所有位置。

期望得分 $25pts$。

### Subtask7

这个之后我们发现 $2^{15} \le 5 \times 10^4$ 。

怎么压缩这两次询问？

通过自己手模每次询问的位置发现最后几个询问是 $1,2,3,5$，我们考虑把前两个询问去掉。

最后询问 $3$ 的时候，我们得到的两个位置一定是 $3,4$，未知的两个位置是 $1,2$。

这是什么？Subtask1 啊！

然后这题就做完了。

需要注意的一点是，Subtask3,4 的数据下，最后几次询问的位置是 $1,2,3,4,6$，也就是说 $3,4$ 没有被划分到一段内。这个情况更好处理 $1,2$ 因为我们知道了 $3$ 的位置。

我们要爱惜自己的询问次数，因为 $n = m_1$，不能浪费，所以确定出前几个数后，再求其他数的时候要从已经确定的数的下一个开始求。

## 代码实现

我用 $col$ 按照第几次询问标记了每个段的颜色，然后利用一个 $c$ 数组将颜色从大到小排序，这样每段颜色都被放在了一起，颜色相同的段在值域上也是连续的，就可以 $O(n)$ 的求出整个序列了。

实现细节参考代码吧。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int n, m1, m2, m3;
int a, b, x, y, mod1, mod2;
int ans[MAXN];
int vis[MAXN], c[MAXN];
int stc[MAXN], sc = 0;

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

namespace Subtask1 {
    void Solve() {
        printf("? 4 1 2 3 4 3\n");
        fflush(stdout);
        int k = read();
        x = read(), y = read();
        for(int i = 1; i <= 4; ++i) if(i != x && i != y) a = i;
        for(int i = 1; i <= 4; ++i) if(i != x && i != y && i != a) b = i;
        printf("! %d %d\n", x, a);
        fflush(stdout);
        mod1 = read();
        printf("! %d %d\n", x, b);
        fflush(stdout);
        mod2 = read();
        if(mod1 + mod2 == 0) {
            ans[x] = 4, ans[y] = 3;
        } else {
            ans[x] = 3, ans[y] = 4;
            if(mod1 == 1) {
                ans[a] = 2, ans[b] = 1;
            } else {
                ans[b] = 2, ans[a] = 1;
            }
            printf("A %d %d %d %d\n", ans[1], ans[2], ans[3], ans[4]);
            fflush(stdout);
            return ;
        }
        
        printf("! %d %d\n", y, a);
        fflush(stdout);
        mod1 = read();
        printf("! %d %d\n", y, b);
        fflush(stdout);
        mod2 = read();
        if(mod1 == 1) {
            ans[a] = 2, ans[b] = 1;
        } else {
            ans[b] = 2, ans[a] = 1;
        }
        printf("A %d %d %d %d\n", ans[1], ans[2], ans[3], ans[4]);
        fflush(stdout);
        return ;
    }
}
namespace Subtask2 {
    void Solve() {
        for(int i = n; i >= 1; --i) {
            printf("? %d ", n);
            for(int j = 1; j <= n; ++j) printf("%d ", j);
            printf("%d\n", i);
            fflush(stdout);
            int k = read();
            for(int j = 1, x; j <= k; ++j) {
                x = read();
                if(vis[x]) continue;
                vis[x] = true;
                ans[x] = i;
            }
        }
        printf("A");
        for(int i = 1; i <= n; ++i) {
            printf(" %d", ans[i]);
        }
        puts("");
        fflush(stdout);
    }
}

bool cmp(int x, int y) { return vis[x] > vis[y]; }

void Divide(int l, int r, int col) {
    int mid = (r + 1) / 2 + 1;
    if(mid == 2) {
        for(int i = 1; i <= n; ++i) if(!vis[i]) vis[i] = col;
        sort(c + 1, c + n + 1, cmp);
        return ;
    }
    sc = 0;
    for(int i = 1; i <= n; ++i) {
        if(!vis[i]) stc[++sc] = i;
    }
    printf("? %d ", sc);
    for(int i = 1; i <= sc; ++i) printf("%d ", stc[i]);
    printf("%d\n", mid);
    fflush(stdout);
    int k = read();
    for(int i = 1, x; i <= k; ++i) {
        x = read();
        vis[x] = col;
    }
    Divide(l, mid - 1, col + 1);
}

int main()
{
    n = read(), m1 = read(), m2 = read(), m3 = read();
    if(n == 4) {
        Subtask1::Solve();
    } else if(n == 500){
        Subtask2::Solve();
    } else {
        for(int i = 1; i <= n; ++i) c[i] = i;
        Divide(1, n, 1);
//        for(int i = 1; i <= n; ++i) cout<<vis[i]<<" "; puts("");
//        for(int i = 1; i <= n; ++i) cout<<c[i]<<" "; puts("");
        int Max, lst, wz;
        if(vis[c[3]] != vis[c[4]]) {
            printf("! %d %d\n", c[3], c[1]);
            fflush(stdout);
            int mod1 = read();
            printf("! %d %d\n", c[3], c[2]);
            fflush(stdout);
            int mod2 = read();
            ans[c[3]] = 3;
            if(mod1 == 1) ans[c[1]] = 2, ans[c[2]] = 1;
            else ans[c[1]] = 1, ans[c[2]] = 2;
            Max = 3, lst = wz = c[3];
        } else {
            printf("! %d %d\n", c[3], c[1]);
            fflush(stdout);
            int mod1 = read();
            printf("! %d %d\n", c[3], c[2]);
            fflush(stdout);
            int mod2 = read();
            if(mod1 + mod2 == 0) {
                ans[c[3]] = 4, ans[c[4]] = 3;
                printf("! %d %d\n", c[4], c[1]);
                fflush(stdout);
                mod1 = read();
                if(mod1 == 1) ans[c[1]] = 2, ans[c[2]] = 1;
                else ans[c[1]] = 1, ans[c[2]] = 2;
            } else {
                ans[c[3]] = 3, ans[c[4]] = 4;
                if(mod1 == 1) ans[c[1]] = 2, ans[c[2]] = 1;
                else ans[c[1]] = 1, ans[c[2]] = 2;
            }
            Max = 4, lst = wz = (ans[c[4]] == 4 ? c[4] : c[3]);
        }
        for(int i = ((vis[c[3]] == vis[c[4]]) ? 5 : 4); i <= n; ++i) {
            if(vis[c[i]] != vis[c[i - 1]]) {
                lst = wz; // 上一个颜色 
                Max = 0, wz = 0; // 新的颜色 
            }
            printf("! %d %d\n", c[i], lst);
            fflush(stdout);
            int x = read();
            if(x) {
                ans[c[i]] = ans[lst] + x;
            } else {
                ans[c[i]] = ans[lst] * 2;
            }
            if(Max < ans[c[i]]) {
                Max = ans[c[i]];
                wz = c[i];
            }
        }
        printf("A");
        for(int i = 1; i <= n; ++i) {
            printf(" %d", ans[i]);
        }
        puts("");
        fflush(stdout);
    }
    return 0;
}
```


---

## 作者：Lonely_NewYear (赞：3)

# P7843 题解

## 题目分析

首先考虑 $n=3$ 的情况。

只需要先用 $?\ 3\ 1\ 2\ 3\ 3$ 找出值为 $3$ 的那个数，再用这个数作为被模数，对另两个数做一下第一个询问即可（$3\ mod\ 1=0,3\ mod\ 2=1$）。

接下来是 $n=4$ 的情况。

同样，我们可以用 $?\ 4\ 1\ 2\ 3\ 4\ 4$ 找到值为 $3,4$ 的两个数，接下来，把 $3,4$ 作为被模数， $1,2$ 作为模数，进行四次第一个询问，对照下面这张表即可得到答案。

|  | 1 | 2 |
| :----------- | :----------- | :----------- |
| **3** | 0 | 1 |
| **4** | 0 | 0 |

接下来考虑 $n=5$ 的情况。

延续刚才的思路，可以用 $?\ 5\ 1\ 2\ 3\ 4\ 5\ 4$ 找到值为 $4,5$ 的两个数，剩下的三个数就一定是 $1,2,3$，所以可以用 $n=3$ 时的做法，求出它们的值。

接下来如何求出 $4,5$ 这两个数到底是多少呢？可以用值为 $3$ 的数对这两个数取模（$4\  mod\ 3=1,5\ mod\ 3=2$）。

这样就可以求出所有数了。

接着是 $n=6$。

做法和 $n=5$ 差不多，可以用 $?\ 6\ 1\ 2\ 3\ 4\ 5\ 6\ 4$ 找到值为 $4,5,6$ 的三个数，用 $n=3$ 的操作解决剩下三个数，接下来用 $3$ 对这三个数取模。

……

到这里，相信你已经知道最终算法的大概了。

首先用 $?\ n\ 1\ 2\ \dots\ n\ \lfloor (n+1)/2\rfloor+1$，求出所有大于 $(n+1)/2$ 的数，对剩下的数执行 $n=\lfloor (n+1)/2\rfloor$ 时的算法，进行完之后再找到 $\lfloor (n+1)/2\rfloor$，用它对其他所有数取模（注意这个 $\lfloor (n+1)/2\rfloor$，这是保证取模的结果全部不一样的最大值），其他数的值就是 $\lfloor (n+1)/2\rfloor+\texttt{询问的结果}$（结果为 $0$ 的话显然是加上 $\lfloor (n+1)/2\rfloor$）。

这样就完成了一个递归。

分析一下每个操作用的最多次数。

由于每次操作一每次都会确定一个数的值，所以最多用 $n$ 次。

操作二的次数就是递归的层数，即 $\log n$。

因为每层只会对当前较小一半的数进行操作二，所以说第一层大约是 $n$ 个，第二层 $n/2$ 个……倒数第二层 $2$ 个，最后一层那个其实可以不用，加起来明显大约是 $2\times n$，肯定不会超过 $3\times n$。

但最后一组测试点的 $n$ 为 $50000$，而 $2^{15}=32768$，$2^{16}=65536$，所以可能会询问 $16$ 次，会超过题目给定的限度。但是注意到 $n=3$ 或 $n=4$ 那一层时按这样计算会用 $2$ 次操作二，但明显有只用 $1$ 次的方案，所以只需特判一下就行。

具体实现看代码吧。

## 代码

```cpp
#include<cstdio>
using namespace std;
int n,f[50001],a[50001];//f表示这个数在第几层被确定，a表示这个数的值
void dfs(int r,int v)//r表示当前有多少个数，v表示当前层数
{
	if(r==3)//特判
	{
		printf("? %d ",3);
		for(int i=1;i<=n;i++)
			if(!f[i])printf("%d ",i);
		printf("%d\n",3);
		fflush(stdout);
		int pos;
		scanf("%*d%d",&pos);
		a[pos]=3;
		f[pos]=v;
		printf("! %d ",pos);
		int res;
		for(int i=1;i<=n;i++)
			if(!f[i])
			{
				f[i]=v;
				printf("%d\n",i);
				fflush(stdout);
				scanf("%d",&res);
				a[i]=1+res;
				break;
			}
		for(int i=1;i<=n;i++)
			if(!f[i]){f[i]=v,a[i]=2-res;break;}
		return;
	}
	if(r==4)//特判
	{
		printf("? %d ",4);
		for(int i=1;i<=n;i++)
			if(!f[i])printf("%d ",i);
		printf("%d\n",3);
		fflush(stdout);
		int x,y;
		scanf("%*d%d%d",&x,&y);
		f[x]=f[y]=v;
		int p=0,q;
		for(int i=1;i<=n;i++)
			if(!f[i]&&p){q=i;break;}
			else if(!f[i])p=i;
		f[p]=f[q]=v;
		int res1,res2,res3;
		printf("! %d %d\n",x,p);
		fflush(stdout);
		scanf("%d",&res1);
		if(res1==1)
		{
			a[x]=3,a[y]=4;
			a[p]=2,a[q]=1;
			return;
		}
		printf("! %d %d\n",x,q);
		fflush(stdout);
		scanf("%d",&res2);
		if(res2==1)
		{
			a[x]=3,a[y]=4;
			a[p]=1,a[q]=2;
			return;
		}
		a[x]=4,a[y]=3;
		printf("! %d %d\n",y,p);
		fflush(stdout);
		scanf("%d",&res3);
		if(res3==0)a[p]=1,a[q]=2;
		else a[p]=2,a[q]=1;
		return;
	}
	int mid=(1+r)/2;
	//找出较大的数
	printf("? %d ",r);
	for(int i=1;i<=n;i++)
		if(!f[i])printf("%d ",i);
	printf("%d\n",mid+1);
	fflush(stdout);
	int num;
	scanf("%d",&num);
	for(int i=1;i<=num;i++)//标记一下这些数
	{
		int x;
		scanf("%d",&x);
		f[x]=v;
	}
	dfs(mid,v+1);//递归
	int pos;
	for(int i=1;i<=n;i++)//找出mid
		if(a[i]==mid){pos=i;break;}
	for(int i=1;i<=n;i++)//确定较大的数
	{
		if(f[i]!=v)continue;
		printf("! %d %d\n",i,pos);
		fflush(stdout);
		int x;
		scanf("%d",&x);
		a[i]=mid+x;
		if(x==0)a[i]=mid+mid;
	}
}
int main()
{
	int m1,m2,m3;
	scanf("%d%d%d%d",&n,&m1,&m2,&m3);
	dfs(n,1);//递归
	printf("A");
	for(int i=1;i<=n;i++)
		printf(" %d",a[i]);
	printf("\n");
	fflush(stdout);
	return 0;
}
```

谢谢观看！

---

## 作者：Diana773 (赞：2)

# 题意简述
- 猜一个长度为 $n$ 的排列 $a$ ，可以进行以下两种操作 ：
  - 1. 输出 ```! x y```，满足 $a_x\gt a_y$ 且 $x\ne y$；返回 $a_x \bmod a_y$，。
  - 2. 输出 ```? l S p```，$S$ 是大小为 $l$ 集合， 记 $S=\{x_1,x_2,x_3,\ldots,x_l\}$，满足对于任意 $1\le i\le l$，$1\le x_i\le n$，且 $x_i$ 互不相同，还要满足 $1\le p\le n$，$1\le l\le n$。返回 $a_{x_k} \ge p$ 的所有的 $x_k$，返回形式如下：首先会返回一个整数 $L$，接着会返回 $L$ 个整数，表示有 $L$ 个满足条件的 $x_k$（注意返回的是集合 $S$ 中的元素，而不是下标！）。
  
- 执行操作 $1$ 不超过 $m_1$ 次，执行操作 $2$ 不超过 $m_2$ 次，并且操作 $2$ 中 $S$ 的元素总和不超过 $m_3$ 个。

# 题目分析
观察数据，发现 $m_1=n$，只有 $m_2$ 和 $m_3$ 对于同一个 $n$ 有很大不同，并且在最大限制下 $1<<m_2$ 与 $n$ 接近，可以猜想是通过操作 $1$ 得出大部分数，操作 $2$ 进行一个类似二分的操作。

### 10分做法
- 一次操作 $1$ 中选择从 $1$ 到 $n$ 的所有数，可以找到 $a$ 中所有大于等于 $p$ 的元素的位置。特别地，令 $p=n$ 时，只会返回 $a$ 中 $n$ 的位置。    

- $4$ 个数的排列，考虑先通过 $1$ 次操作 $2$ 找出 $4$ 的位置，再用 $3$ 次操作 $1$ 让 $4$ 对 $a$ 的其它 $3$ 项取模。因为 $4 \bmod 1=0$、$4 \bmod 3=1$、$4 \bmod 2=0$，可以找出 $3$ 的位置。因为 $3\bmod 1=0$、$3 \bmod 2=1$，最后用 $1$ 次操作 $3$ 队剩下两个未知数的任意一个取模，就可以知道整个排列了。

- 使用 $4$ 次操作 $1$；$1$ 次操作 $2$； $4$ 的集合大小。


### 20分做法
- $10$ 分做法特判
- 考虑用操作 $2$ 寻找大于等于 $n$ 的 $a$ 的元素的位置， 再寻找 $n-1$ 的、 $n-2$ 的、……直到 1 的。 只需要在 $n$ 之后的操作每次去掉之前的位置，就可以找到从 $n$ 到  $1$ 每一个数的位置。   

- 使用 $0$ 次操作 $1$；$n$ 次操作 $2$； $n^2$ 的集合大小。


### 95分做法
 
- $10$ 分做法特判
- 容易发现当 $n$ 为偶数且 $i \ge \frac{n}{2}$ 时  $n \bmod i$ 互不相同，而当 $n$ 为奇数且 $i \ge \frac{n+1}{2}$ 时也有这个性质。
- 考虑现在是一个 $n$ 大小的排列，可以先用操作 $2$ 找到大于等于 $\frac{n}{2}$ 或 $\frac{n+1}{2}$ 的所有 $a$ 的位置，记为集合 $Q$。然后再用一次操作  $2$ 在 $Q$ 中找到 $n$ 在 $a$ 的位置。最后用操作 $1$ 把 $Q$ 中所有元素对应值找到。
- 递归。第二次考虑 $\frac{n}{2}$ ($n$ 为偶数) 或 $\frac{n+1}{2}$ ($n$ 为奇数) 的排列，$\frac{n}{2}$ 或 $\frac{n+1}{2}$ 在 $a$ 的位置已经求出，不用通过操作 $2$ 重新求出。然后不断重复即可。

- 使用 $n$ 次操作 $1$；$\log n$ 次操作 $2$； $2.5n$ 的集合大小。

### 100分做法

- 在 $95$ 分 做法基础上，递归到 $4$ 或 $3$ 时用 $10$ 分做法特判即可。

- 使用 $n$ 次操作 $1$；$\log n-2$ 次操作 $2$； $2.5n$ 的集合大小。

# 贴个代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>

using namespace std;

const int N=1e5;

int n,m1,m2,m3,nn,pl,vv,l,oo,ddd,op,ppp;
int ans[N];//ai代表的数 
int fans[N];//数字在的a位置 
int u[N];//该位置已确定数字 
vector<int> f[20]; 
vector<int> g[20];
int main()
{    	
    std::ios::sync_with_stdio(false);
	cin>>n>>m1>>m2>>m3;
   
    if (n==4) //特判4 
    {

    	cout<<"? 4 1 2 3 4 4"<<endl; //找4的位置 
    	cin>>ddd;
    	cin>>ddd;
    	ans[ddd]=4;
    	fans[4]=ddd; 
    	
    	for (int i=1; i<=4; i++) //找3的位置 
    	  if (i!=ddd)
		  {
    		cout<<"! "<<ddd<<" "<<i<<endl;
    		cin>>oo; 
    		if (oo==1)
    		{
    			fans[3]=i;
    			ans[i]=3;
			}
		  }
		  
    	for (int i=1; i<=4; i++) //找1或2的位置 
    	  if (i!=ddd&&i!=fans[3])
    	  {
    	    cout<<"! "<<fans[3]<<" "<<i<<endl;
            cin>>oo;
            if (oo==0)
            {
          	  ans[i]=1;
          	  op=2; 
		    }
		    else
		    {
		      ans[i]=2;
		      op=1;
		    }
            break;
          }
        
        cout<<"A "; 
        for (int i=1; i<=n; i++)
          if (ans[i]==0)
            cout<<op<<" ";
		  else
		    cout<<ans[i]<<" ";
			        
        cout<<endl;
        return 0;
	}
    nn=n;
    for (int i=1; i<=nn; i++)
      f[0].push_back(i); 
    pl=0; 
	for (int i=1; i<=n; i++)
		u[i]=0;			
	while (nn>4)
	{
        ppp=f[pl].size(); //将1-nn的排列分成两组，小的在f，大的在g 
        cout<<"? "<<ppp<<' ';
        for (int i:f[pl])
        	cout<<i<<' ';
        if (nn%2==0)
          vv=nn/2;
        else
          vv=(nn+1)/2;
        cout<<vv<<endl;
        cin>>l;
        for (int i=1; i<=l; i++)
        {
            cin>>oo;
            u[oo]=1;
            g[pl].push_back(oo);
		}
		for (int i=1; i<=n; i++)
		  if (!u[i])
			f[pl+1].push_back(i);
			
        if (n==nn)  //最开始需要确定n的位置 
        {
        	cout<<"? "<<n-vv+1<<' ';       		
        	for (int i:g[pl])
			    cout<<i<<' '; 
        	cout<<n<<endl;    
			cin>>ddd;
			cin>>ddd;    	   			   
        	ans[ddd]=n;
        	fans[n]=ddd;
        	ddd=n;
		}
			
		for (int i:g[pl]) //确定排列后一半的数的位置 
		  if (i!=fans[ddd])
		  {
			cout<<"! "<<fans[ddd]<<' '<<i<<endl;
			cin>>oo;
			if (oo==0)
			{
				ans[i]=vv;
				fans[vv]=i;
			}
			else
			{
				ans[i]=ddd-oo;
				fans[ddd-oo]=i;
			}
		  }
			
        ddd=vv;
        nn=vv;
       	pl++;
	}
	
	if (nn==4) //剩余4特判 
	{
        ddd=vv;
		for (int i:f[pl])
		if (i!=fans[vv])
		{
			cout<<"! "<<fans[vv]<<' '<<i<<endl;
			cin>>oo;
			if (oo==1)
			{
			  ans[i]=3;	
			  fans[3]=i;
		    }
		}	
	
		for (int i:f[pl])
		if (i!=fans[vv]&&i!=fans[3])
		{
			cout<<"! "<<fans[3]<<' '<<i<<endl;
			cin>>oo;
			if (oo==1)
			{
			  ans[i]=2;	
			  fans[2]=i;
			  op=1;
			  break;
		    }
		    else
		    {
			  ans[i]=1;	
			  fans[1]=i;
			  op=2;
			  break;		    	
			}	    
		}
				
		for (int i=1; i<=n; i++)
		{
			if (ans[i]==0)
			{
				ans[i]=op;
				break;
			 } 
		}		
	}
	
	if (nn==3) //剩余3特判 
	{
        ddd=vv;
		for (int i:f[pl])
		if (i!=fans[vv])
		{
			cout<<"! "<<fans[vv]<<' '<<i<<endl;
			cin>>oo;
			if (oo==0)
			  ans[i]=1;
			else
			  ans[i]=2;
		}				
	}
	
	cout<<"A ";
	for (int i=1; i<=n; i++)
	  cout<<ans[i]<<' ';
	cout<<endl;
	return 0;
}
```



---

## 作者：EnofTaiPeople (赞：1)

考试时第二题花太多时间，第三题没时间了。后来坐在江边 10 分钟，就想到了正解 QWQ。

看到题面上有这句话：其中你询问的数应当满足 $a_x>a_y$ 且 $x \neq y$ 我就想到这个询问不是帮助我们瞎猜的。还是直接说正解吧，正解如下：

我们应先用询问二，将那个数是 $n$ 问出来，再问 $\lceil n/2 \rceil$ 接下来用 $n$ 对第二次问到的数取模（询问一），就能得到这些数字的具体值。只有当 $n$ 为偶数时需要特判 $n\bmod(n/2)=0$。

知道 $n<5$ 还是特判，下附考后 AC 代码，帮助理解：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read(){
	int an=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')f=-f,c=getchar();
	while(c>='0'&&c<='9')an=an*10+c-'0',c=getchar();
	return an*f;
}
int ans[50005],need[50005],tn;
int main(){
	int n=read(),dn=n,xn,on;
	read();read();read();
	int a[2],b,t=-1;
	register int i,x;
	printf("? %d",n);
	for(i=1;i<=n;++i)printf(" %d",i);
	printf(" %d\n",n);fflush(stdout);
	read();ans[xn=read()]=dn=n;
	while(dn>4){
		for(i=1,tn=0;i<=n;++i)if(ans[i]==0)need[++tn]=i;
		printf("? %d",tn);
		for(i=1;i<=tn;++i)printf(" %d",need[i]);
		printf(" %d\n",(dn+1)>>1);
		putchar('\n');fflush(stdout);
		tn=read();for(i=1;i<=tn;++i)need[i]=read();
		for(i=1;i<=tn;++i){
			printf("! %d %d\n",xn,need[i]);
			fflush(stdout);x=read();
			if(x==0||(dn%2&&x==(dn>>1)))
				ans[on=need[i]]=(dn+1)>>1;
			else ans[need[i]]=dn-x;
		}xn=on;dn=(dn+1)>>1;
	}switch(dn){
		case 1:break;
		case 2:for(i=1;i<=n;++i)
		if(ans[i]==0){ans[i]=1;break;}break;
		case 3:for(i=1;i<=n;++i)if(ans[i]==0){
			printf("! %d %d\n",xn,i);fflush(stdout);
			ans[i]=read()+1;
		}break;case 4:
			for(i=1;i<=n;++i)if(ans[i]==0){
				printf("! %d %d\n",xn,i);fflush(stdout);
				x=read();if(x){b=i;ans[i]=3;}else a[++t]=i;
			}printf("! %d %d\n",b,a[0]);fflush(stdout);
			if(read()){ans[a[0]]=2;ans[a[1]]=1;}
			else{ans[a[0]]=1;ans[a[1]]=2;}break;
			default:printf("Error!\n");break;
	}printf("A ");
	for(i=1;i<n;++i)printf("%d ",ans[i]);
	printf("%d\n",ans[n]);
	return 0;
}
```

---

## 作者：Daniel13265 (赞：1)

> 题意较长，详见[题目链接](https://www.luogu.com.cn/problem/P7843)。

观察 $m_2$ 与 $n$ 的关系，猜测限制为 $m_2\approx\log_2n$，于是往二分这个方向考虑。

令 $m=\lceil n/2\rceil$，很自然的思路是通过一次询问 2 确定 $[1,m]$ 与 $(m,n]$ 在排列中的位置，于是前一半就是一个相似的问题，递归求解。而对于后一半受 $m_2$ 的限制只能使用询问 1，因此去观察取模的性质。由此发现：对于 $x\in(m,n]$ 有 $x\bmod m=x-m$ 且这些 $x-m$ 两两不同。根据这一点，我们只需要依次询问 $(m,n]$ 所在位置的值除以 $m$ 的余数即可。

但是直接这样做会超过 $m_2$ 的限制 $1$，因此可以不做最后一次递归，此时 $n=3$ 或 $n=4$。对于 $n=3$，我们可以知道 $3$ 所在的位置，而 $3$ 除以 $1$ 和 $2$ 的余数不同，所以使用一次询问 1 求出 $1,2$ 分别所在的位置；对于 $n=4$，由于 $3\bmod 1=4\bmod1=4\bmod2=0$ 而 $3\bmod 2=1$，所以找到询问 1 回答为 $1$ 的那一对来确定 $1,2,3,4$ 每个数所在的位置。

简单计算一下发现这样做足以通过此题：$m_1<n$，$m_2=\lceil\log_2n-1\rceil$，$m_3<2n$。

实际上我们还可以针对询问 2 的次数做进一步优化：在递归到需要求解的长度 $n$ 小于等于特定的长度 $k$ 时停止递归并使用其他方法计算出 $n$ 的位置，比如只做一次询问 2。由于上层递归仅依赖于 $n$ 的具体位置，所以如此优化足以让我们知道不小于 $n$ 的所有数的具体位置。然而只用一次询问 2 无法让我们知道小于 $n$ 的值的具体位置。结合以上两点，不难想到用一个大数 $l$ 依次去对这些小于 $n$ 的数所在的位置做询问 1 并得到不同结果，从而确定这些位置的具体值。具体地，$l\bmod 1$ 肯定是 $0$，因此 $l\bmod 2$ 需要是 $1$，$l\bmod 3$ 需要是 $2$，依次类推，不难发现最小的 $l=\operatorname{lcm}(1,2,3,\dots,k-1)-1\le n$。

找到最大的 $k$，则询问 2 的次数为 $\lceil \log_2n-\log_2k+1\rceil$，在 $n=5\times10^4$ 时只需要 $13$ 次询问。

以下代码在 $n=5\times10^4$ 时 $m_1=49986$，$m_2=13$，$m_3=99979$。肯定存在这三个数值都更优的代码，因此仅供参考。

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>

typedef std::vector<int> vector;

int o = 1;
vector pos;

int query(int x, int y) {
  int l;
  printf("! %d %d\n", x, y);
  fflush(stdout);
  scanf("%d", &l);
  return l;
}
void query(int m, int h, int e, const vector &a, vector &b) {
  int l = 0;
  if (m > 1) {
    printf("? %d", m - 1);
    for (int i = 1; i < m; ++i) printf(" %d", a[i]);
    printf(" %d\n", h + 1);
    fflush(stdout);
    scanf("%d", &l);
    b.resize(l);
    for (int &x : b) scanf("%d", &x);
  }
  if (l + e < m) b.push_back(a[0]);
  std::sort(b.begin(), b.end());
}

#define exclude(a, b, c) std::set_difference(a.begin(), a.end(), b.begin(), b.end(), c)

void solve(int m, const vector &ind) {
  int h = 0;
  vector hi;

  if (m <= o * 2) {
    h = o;
    vector inc;
    query(m, o - 1, o - 1, ind, inc);
    query(m - o + 1, o, 1, inc, hi);
    exclude(inc, hi, &pos[o]);
  } else {
    h = (m + 1) >> 1;
    vector lo(h);
    query(m, h, h, ind, hi);
    exclude(ind, hi, lo.begin());
    solve(h, lo);
  }

  for (int i = 1; i < m - h; ++i) {
    int p = query(hi[i], pos[h]) + h;
    if (p <= h) p += h;
    pos[p] = hi[i];
  }
  for (int i = h + 1; i <= m; ++i)
    if (!pos[i]) {
      pos[i] = hi[0];
      break;
    }
}

int gcd(int x, int y) {
  while (y) {
    const int z = x % y;
    x = y;
    y = z;
  }
  return x;
}

int main() {
  int n;
  scanf("%d%*d%*d%*d", &n);
  vector ind(n);
  for (int i = 0; i < n; ++i) ind[i] = i + 1;

  if (n == 4) {
    vector lo(2), hi;
    query(4, 2, 2, ind, hi);
    exclude(ind, hi, lo.begin());
    ind.resize(n + 1);
    if (query(hi[0], lo[0])) {
      ind[hi[0]] = 3;
      ind[hi[1]] = 4;
      ind[lo[0]] = 2;
      ind[lo[1]] = 1;
    } else if (query(hi[0], lo[1])) {
      ind[hi[0]] = 3;
      ind[hi[1]] = 4;
      ind[lo[0]] = 1;
      ind[lo[1]] = 2;
    } else if (query(hi[1], lo[0])) {
      ind[hi[0]] = 4;
      ind[hi[1]] = 3;
      ind[lo[0]] = 2;
      ind[lo[1]] = 1;
    } else {
      ind[hi[0]] = 4;
      ind[hi[1]] = 3;
      ind[lo[0]] = 1;
      ind[lo[1]] = 2;
    }
  } else {
    int v = 1;
    while (true) {
      ++o;
      const int u = v * o / gcd(v, o);
      if (u > n + 1) break;
      v = u;
    }
  
    pos.resize(n + 1);
    solve(n, ind);
    ind.assign(n + 1, 0);
    for (int i = 1; i <= n; ++i) ind[pos[i]] = i;
    int fir = 0;
    for (int i = 1; i <= n; ++i)
      if (!ind[i]) {
        if (!fir) {
          fir = i;
        } else {
          ind[i] = query(pos[v - 1], i) + 1;
          pos[ind[i]] = i;
        }
      }
    if (fir) {
      for (int i = 1; i <= n; ++i)
        if (!pos[i]) {
          ind[fir] = i;
          break;
        }
    }
  }

  putchar('A');
  for (int i = 1; i <= n; ++i)
    printf(" %d", ind[i]);
  fflush(stdout);
  return 0;
}

```

---

## 作者：KEBrantily (赞：1)

## Subtask 1

注意到只有四个数。  

可以先通过一次操作二找出 $3,4$ 的位置和 $1,2$ 的位置。

然后再分别用四次操作一，让 $3,4$ 来对 $1,2$ 取模确定四个位置。

```cpp
n=read();m1=read();m2=read();m3=read();
if(n==4){
  printf("? 4 1 2 3 4 3\n");fflush(stdout);
  k=read();a=read();b=read();
  for(int i=1;i<=4;i++)if(i!=a&&i!=b){if(!c)c=i;else d=i;}
  printf("! %d %d\n",a,c);fflush(stdout);ans1=read();
  printf("! %d %d\n",a,d);fflush(stdout);ans2=read();
  if(ans1+ans2==0) ed[b]=3,ed[a]=4;
  else{
    ed[b]=4,ed[a]=3;
    if(ans1) ed[c]=2,ed[d]=1;else ed[d]=2,ed[c]=1;
    printf("A %d %d %d %d\n",ed[1],ed[2],ed[3],ed[4]);
    fflush(stdout);return 0;
  }
  printf("! %d %d\n",b,c);fflush(stdout);ans3=read();
  printf("! %d %d\n",b,d);fflush(stdout);ans4=read();
  if(ans3) ed[c]=2,ed[d]=1;else ed[c]=1,ed[d]=2;
  printf("A %d %d %d %d\n",ed[1],ed[2],ed[3],ed[4]);
  fflush(stdout);return 0;
}
```


## Subtask 2

发现 $m_2=n$，且 $m_3$ 是 $m_2^2$。

那么我们可以通过 $n$ 次询问来确定每个数的位置。

每次询问 $n$ 个数，询问的上界减一，然后找出给的数中没有被确定位置的数即可。

```cpp
n=read();m1=read();m2=read();m3=read();
if(n==500){
  for(int i=n;i>=1;i--){
    printf("? %d ",i);
    for(int j=1;j<=n;j++)
      if(!flag[j]) printf("%d ",j);
    printf("%d\n",i);fflush(stdout);
    int x=read(),y=read();ed[y]=i,flag[y]=1;
  }
  printf("A ");
  for(int i=1;i<=n;i++) printf("%d ",ed[i]);
  fflush(stdout);return 0;
}
```


## Subtask 3~6

~~没看出来性质 A 可以怎么搞。~~

看最下面的数据范围，发现 $m_1$ 很大，$m_2$ 很小，但是 $2^{17}>5\times 10^4$。

这启发我们可以用类似倍增的做法来搞。

可以发现，$(\lceil\frac{n}{2}\rceil,n]$ 中的每个数对 $\lceil\frac{n}{2}\rceil$ 取模都可以得到不同的结果。

所以，如果我们知道了 $[1,\lceil\frac{n}{2}\rceil]$ 中每个数的位置，那么剩下的数位置可以通过不断进行操作一来确定。

想要确定 $[1,\lceil\frac{n}{2}\rceil]$，可以转化为知道了 $[1,\lceil\frac{n}{4}\rceil]$ 来用同样的方法求 $(\lceil\frac{n}{4}\rceil,\lceil\frac{n}{2}\rceil]$ 得到。

所以我们可以通过递归分治的方式来处理。

我们在数轴上找出每个长为 $n\times \frac{1}{2}^{i}$ 的段，然后处理这一段内的数的位置即可。

```cpp
void work(int l,int r,int cnt){
  int mid=(r+1)/2+1;all=0;
  if(l==r){for(int i=1;i<=n;i++)if(!pos[i]) pos[i]=cnt;return;}
  for(int i=1;i<=n;i++)if(!pos[i]) que[++all]=i;
  printf("? %d ",all);for(int i=1;i<=all;i++) printf("%d ",que[i]);
  printf("%d\n",mid);fflush(stdout);int x=read();
  for(int i=1;i<=x;i++) pos[read()]=cnt;work(l,mid-1,cnt+1);
}
//下面是主函数内的部分
n=read();m1=read();m2=read();m3=read();
if(m2>=17){
  for(int i=1;i<=n;i++) num[i]=i;
  work(1,n,1);sort(num+1,num+n+1,cmp);
  ed[num[1]]=1;ed[num[2]]=2;int maxx,id=num[2];
  for(int i=3;i<=n;i++){
    if(pos[num[i]]!=pos[num[i-1]]) lst=id,maxx=id=0;
    printf("! %d %d\n",num[i],lst);fflush(stdout);int x;
    ed[num[i]]=ed[lst]+(x=read());if(!x)ed[num[i]]=(ed[lst]<<1);
    if(maxx<ed[num[i]])maxx=ed[num[i]],id=num[i];
  }
  printf("A");for(int i=1;i<=n;i++) printf(" %d",ed[i]);
  fflush(stdout);return 0;
}
```

## Subtask 7

可以发现对于最后一组数据，$2^{15}\le 5\times 10^4<2^{16}$。也就是说我们操作二理论上多进行了一次。

想办法怎么减少次数。

我们发现递归的时候是最后剩余了一个 $1$ 然后退出的。此时我们可以找出 $1,2,3,4$ 的位置。

如果我们不用操作二找出最后一个 $1$ 的位置，而是采用 Subtask 1 的方法来的话，理论上就可以使操作二控制在一个可行的范围内了。

然后我们在 Subtask 3~6 的代码上套一个 Subtask 1 的代码就可以通过这个测试点。

```cpp

void work2(int l,int r,int cnt){
  int mid=(r+1)/2+1;all=0;
  if(mid==2){for(int i=1;i<=n;i++)if(!pos[i]) pos[i]=cnt;return;}
  for(int i=1;i<=n;i++)if(!pos[i]) que[++all]=i;
  printf("? %d ",all);for(int i=1;i<=all;i++) printf("%d ",que[i]);
  printf("%d\n",mid);fflush(stdout);int x=read();
  for(int i=1;i<=x;i++) pos[read()]=cnt;work2(l,mid-1,cnt+1);
}
//下面是主函数内的部分
for(int i=1;i<=n;i++) num[i]=i;
work2(1,n,1);sort(num+1,num+n+1,cmp);
      
int c=num[2],d=num[1],a=num[3],b=num[4];
printf("! %d %d\n",a,c);fflush(stdout);ans1=read();
printf("! %d %d\n",a,d);fflush(stdout);ans2=read();
if(ans1+ans2!=0){
  ed[a]=3;ed[b]=4;
  if(ans1) ed[c]=2,ed[d]=1;else ed[d]=2,ed[c]=1;
}
else{
  ed[a]=4;ed[b]=3;
  printf("! %d %d\n",b,c);fflush(stdout);ans3=read();
  printf("! %d %d\n",b,d);fflush(stdout);ans4=read();
  if(ans3) ed[c]=2,ed[d]=1;else ed[c]=1,ed[d]=2;
}
     
int maxx,id;
if(ed[num[3]]==4) id=num[3];
else id=num[4];
for(int i=5;i<=n;i++){
  if(pos[num[i]]!=pos[num[i-1]]) lst=id,maxx=id=0;
  printf("! %d %d\n",num[i],lst);fflush(stdout);int x;
  ed[num[i]]=ed[lst]+(x=read());if(!x)ed[num[i]]=(ed[lst]<<1);
  if(maxx<ed[num[i]])maxx=ed[num[i]],id=num[i];
}
printf("A");for(int i=1;i<=n;i++) printf(" %d",ed[i]);
fflush(stdout);return 0;
```

但是这份代码又不能过掉 Subtask 3~4，因为在前面的小数据递归时，按 $n\times \frac{1}{2}^i$ 大小分的块可能使得 $3,4$ 不在同一块中而 $4,5$ 在同一块中，所以找完 $1$ 到 $4$ 的位置后再处理后面时 $5$ 不会被处理到。

这里特判一下 $3,4$ 是不是在一块就可以了。

但是我是个懒逼，所以我把上面所有的代码全拼起来了。

然后我就过了。

---

## 作者：irris (赞：0)

## Preface

> 交互 / 倍增 / 暴力

## Solution

幽默题目，随手吊打意义不明的标算。

考虑如果确定了 $a_x, a_y$ 的取值范围，那么 $a_x \bmod a_y$ 才能有更好的表示方法，也就是求得出来。

为此，不妨 $a_x \in (a_y, 2a_y]$，这时若已知 $a_y$ 和 $a_x \bmod a_y$，那么一定能得到 $a_x$。

考虑将 $1 \sim n$ 之间的所有数划分到 $[1, 1]\ [2, 2]\ [3, 4]\ [5, 8]\ \dots\ [2^{k-1} + 1, 2^k]$ 这些区间之一，每次令一个区间的所有数为 $x$，上一个区间的最大数为 $y$，即可从小到大做上面的做法。因为 $n = 5\times 10^4$，所以取 $k = 16$ 即可，询问 2 的次数是 $16$ 次，集合总大小为 $\min(2^k, n) + 2^{k-1} + \dots + 2 = 2^{k+1} - 2 = 115634$，远低于题目要求的 $1.5\times 10^5$（事实上，改变划分方式后，精细实现即可做到 **严格小于** $\bm{2n}$）。

但是题目要求询问 2 的次数是 $15$ 次，注意到其实我们现在只使用了 $n - 1$ 次询问 1，还可以再凹。如果我们确定了 $[3, 4]$，现在唯一要做的就是划分 $1, 2$，能不能只用恰好 $3$ 次询问 1（而不是 $2$ 次询问 1、$1$ 次询问 2）呢？发现唯有 $3 \bmod 2 = 1$ 不为 $0$，于是我们多使用了 $1$ 次询问 1，但是少使用了 $1$ 次询问 2，然后就全对了。

由此我们就吊打了标算，你也来试试吧！

---

## 作者：lndjy (赞：0)

给一个 $m_3=2.5n$ 的做法，略比 std 优秀。

考虑一个 naive 的做法，不用 1 操作，用 2 操作大力分治，每次找中间的数，求出左右两边的数的位置，然后递归处理两边。

然后把 1 操作加上。

什么情况下能用 1 操作确定一个数的值？当确定 $x\ge \frac{y}{2}$ 时通过询问 $y\bmod x$ 可以确定 $x$。$x=y-y\bmod x$。

如果我们先递归处理右区间，那么右区间的最小值可以拿来求左区间的数中 $[mid+1,r]$ 部分。

但是，第一次分治时，没有可以拿来模的大数，所以我们需要先询问全局找到 $n$ 的位置。

当 $r$ 较小时，需要特判，这样可以减少 2 操作的次数（具体见 subtask1）

$m_1$ 显然不到 $n$，因为每次使用 1 操作必然确定一个数的位置。

$m_2$ 也是 log 级别，因为每次递归需要一次 2 操作。

$m_3$ 为 $3n$，询问全局最大的 $n$ 和分治的 $n+\frac{n}{2}+\frac{n}{4}+...=2n$。

以上做法可以通过，但是可以进一步优化。

求全局最大值，用到 $n$ 有点浪费了。只需要在询问第一次用 2 操作分治时右边的部分就行了。这部分是 $\frac{n}{2}$。

$m_3$ 被优化到了 $2.5n$。

```cpp
#include<iostream>
#include<vector> 
using namespace std;
const int N=5e4+5;
vector<int> now,l,r;
int ans[N],v[N],id[N],fir;
int a1(int x,int y)
{
	cout<<"! "<<x<<" "<<y<<endl;
	fflush(stdout);
	int k;
	cin>>k;
	return k;
}
void a2(int x)
{
	l.clear();r.clear();
	cout<<"? "<<now.size()<<" ";
	for(int i=0;i<now.size();i++)
	cout<<now[i]<<' ';
	cout<<x<<endl;
	fflush(stdout);
	int L;
	cin>>L;
	for(int i=1;i<=L;i++)
	{
		int k;
		cin>>k;
		r.push_back(k);
		v[k]=1;
	}
	for(int i=0;i<now.size();i++)
	if(!v[now[i]]) l.push_back(now[i]);
	for(int i=0;i<now.size();i++)
	v[now[i]]=0; 
}
void print()
{
	for(int i=1;i<=fir;i++)
	id[ans[i]]=i;
	cout<<"A ";
	for(int i=1;i<=fir;i++)
	cout<<id[i]<<" ";
	cout<<endl;
	fflush(stdout);
}
void work2(int n)
{
	a2(4);
	ans[4]=r[0];
	for(int i=0;i<l.size();i++)
	{
		int k=a1(r[0],l[i]);
		if(k==1) ans[3]=l[i]; 
	}
	int flg=0;
	for(int i=0;i<l.size();i++)
	if(l[i]!=ans[3])
	{
		if(flg)
		{
			ans[flg]=l[i];
			return;
		}
		int k=a1(ans[3],l[i]);
		if(k==1) ans[2]=l[i],flg=1;
		else ans[1]=l[i],flg=2;
	}
}
void work3()
{
	l.clear();
	l=now;
	for(int i=0;i<l.size();i++)
	{
		int k=a1(ans[4],l[i]);
		if(k==1) ans[3]=l[i]; 
	}
	int flg=0;
	for(int i=0;i<l.size();i++)
	if(l[i]!=ans[3])
	{
		if(flg)
		{
			ans[flg]=l[i];
			return;
		}
		int k=a1(ans[3],l[i]);
		if(k==1) ans[2]=l[i],flg=1;
		else ans[1]=l[i],flg=2;
	}
}
void work4()
{
	l.clear();
	l=now;
	int flg=0;
	for(int i=0;i<l.size();i++)
	{
		if(flg)
		{
			ans[flg]=l[i];
			return;
		}
		int k=a1(ans[3],l[i]);
		if(k==1) ans[2]=l[i],flg=1;
		else ans[1]=l[i],flg=2;
	}
}
void work(int n,int res)
{
//	cout<<"now"<<n<<" "<<res<<" "<<(n+1>>1)<<endl;
	if(n==4)
	{
		work2(n);
		return;
	}
	if(n==3)
	{
		work3();
		return;
	}
	if(n==2)
	{
		work4();
		return;
	}
	a2((n+2)>>1);
	int nxt=0;
	for(int i=0;i<r.size();i++)
	if(r[i]!=res)
	{
		int k=a1(res,r[i]);
		if(k==0) k=(n+1)/2;
		ans[n-k+1]=r[i];
		if(n-k+1==((n+2)>>1)) nxt=r[i];
	}
	now.clear();
	now=l;
	work(((n+2)>>1)-1,nxt);
}
int main()
{
	int n,m1,m2,m3;
	cin>>n>>m1>>m2>>m3;
	fir=n;
	for(int i=1;i<=n;i++)
	now.push_back(i);
	if(n==4)
	{
		work2(n);
		print();
		return 0;
	}
	a2(n+2>>1);
	cout<<"? "<<r.size()<<" ";
	for(int i=0;i<r.size();i++)
	cout<<r[i]<<' ';
	cout<<n<<endl;
	fflush(stdout);
	int res;
	cin>>res>>res;
	ans[n]=res;
	int nxt=0;
	for(int i=0;i<r.size();i++)
	if(r[i]!=res)
	{
		int k=a1(res,r[i]);
		if(k==0) k=n/2;
		ans[n-k]=r[i];
		if(n-k==(2+n>>1)) nxt=r[i];
	}
	now.clear();
	now=l;
	work((n+2>>1)-1,nxt);
	print(); 
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：0)

$\texttt{Subtask \# 1}$ 我们直接手动模拟。首先肯定要进行一次 `? l S p` 操作求得 $4$ 的位置。然后发现 $1$ 至 $3$ 中只有 $3$ 除 $4$ 无法整除，这样我们就可以通过 `! x y` 操作求得 $3$ 的位置。同理求出 $2$ 的位置，则最后剩下的一个位置就是 $1$ 了。

$\texttt{Subtask \# 2-3}$ $m_2$ 很大，所以我们可以只用 `? l S p` 操作每次求出 $[1,n]$ 间的最大值，然后不断缩小区间直至 $[1,1]$。

$\texttt{Subtask \# 4-6}$ 看到 $m_2$ 的值在 $20$ 以内，便能猜想复杂度与 $2$ 的幂次有关。计算了一下 $2^{15}$ 与 $5 \times 10^4$ 大致接近，故再次联想到二分。于是乎，就有了二分答案的做法。

对于 `! x y` 操作，因为一定要保证询问合法，所以一定是建立在排列上的某位已经确定的情况下。那么肯定需要先从 `? l S p` 操作中获取一个数以开始询问。我们想要求出 $[1,n]$ 内的排列，可以先用 `? l S p` 操作获取 $n$ 的位置，然后可以根据 $n \mod (\frac{n}{2},n)$ ，其中余数互部不重复的性质用 `! x y` 操作求解出 $(\frac{n}{2},n)$ 内所有数的位置。然后继续减半重复操作直到 $n = 1$ 后把最后一个剩下的位置标记为 $1$ 即可。需要注意的是由于 $m_3$ 的限制，所以 `? l S p` 操作时的 $l$ 的大小应该为还未被确定的数的个数，而不是草率的赋值为排列的大小。

$\texttt{Subtask \# 7}$ 但是由于一开始的 `? l S p` 操作，经过计算发现此时代码无法通过最后一个子任务。最简单的方式就是在最后一次二分时特判以减少一次 `? l S p` 操作。最后一次二分操作是在 $[1,2]$ 或 $[1,3]$ 的范围时，但因为题中 $n$ 的大小已经确定，所以计算得出只需要特判后者的情况即可。我们仍然用第一个操作中余数互不相同以求出区间中不同的数的性质，发现 $5 \mod i\ (1 \le i \le 3)$，恰好余数互不相同，故最少使用两次 `! x y` 操作代替原来的 `? l S p` 操作求出。

程序的完整代码较长，放入剪贴板中：[戳我](https://www.luogu.com.cn/paste/4fzpx3mq)

---


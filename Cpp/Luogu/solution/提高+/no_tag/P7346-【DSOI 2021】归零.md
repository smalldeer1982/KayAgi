# 【DSOI 2021】归零

## 题目背景

![](https://img-blog.csdnimg.cn/20201202201332449.png?x-oss-process=image)

能和强欲魔女谈话的机会，对其他人来说是不可多得的 。

进行问答只需要彼此而已，多余的闲功夫就省了吧 ，只有言语就够了 。

![](https://img-blog.csdnimg.cn/20201202200411570.png?x-oss-process=image)

你的求知欲、好奇心、强欲，我都给予肯定 。

说吧，你想问什么 ？

是关于为振救苍生免于饥饿，违背天命而创造出的野兽 $\left \lceil \right. $ 暴食魔女 $\left. \right \rfloor$ 达芙妮的事吗 ？

是那个打算用爱填满世界，而赐予非人之物情感 $\left \lceil \right. $ 色欲魔女 $\left. \right \rfloor$ 卡蜜拉的事吗？

是一边哀叹着世界充满争斗，却用暴力治愈所有人 $\left \lceil \right. $ 愤怒魔女 $\left. \right \rfloor$ 密涅瓦的事吗？

是仅仅为了追求安稳，就把龙赶到大瀑布彼端 $\left \lceil \right. $ 怠惰魔女 $\left. \right \rfloor$ 塞赫麦特的事吗？

是仗着年幼天真，却毫无慈悲地制裁世人 $\left \lceil \right. $ 傲慢魔女 $\left. \right \rfloor$ 缇丰的事吗？

是为了渴求世上一切智慧，就连死后的世界都舍不得放弃 那位知识欲望的化身 $\left \lceil \right. $ 强欲魔女 $\left. \right \rfloor$ 艾姬多娜的事吗？

还是说，是消灭所有魔女做自己的食粮，并与世界为敌的 $\left \lceil \right. $ 嫉妒魔女 $\left. \right \rfloor$ 那位令人忌讳的 $\left \lceil \right. $ 她 $\left. \right \rfloor$？

![](https://img-blog.csdnimg.cn/20201202200421879.png?x-oss-process=image)

## 题目描述

#### （ **若觉得题意不清，请造访 “输入格式” 查看简明化题意。**）

#### （ **请查看题目保证以确保能 solve the problem .**）

我想问的只有 ....

如果我有一串长度为 $n$ 的序列 $a$ ，编号从 $1\rightarrow n $ , $a_i$ 表示第 $i$ 个数.

我共将进行 $m$ 次四种类型的操作，其编号为给出的顺序 ：

$\left \lceil \right. $ 如果我有 $x$ 、$y$ 两值，我会用阴魔法将序列中所有下标 $i \equiv 0 \pmod{x} $ 的 $a_i$  异或上 $y$ 。$\left. \right \rfloor$

$\left \lceil \right. $ 同时我也会三省自身，问问自己序列中 $a_x$ 的值 。$\left. \right \rfloor$

$\left \lceil \right. $ 多次轮回让我明白，只有完美把握住每一次机遇，我才可以占据更大的有利因素。因而我将估量 $a_x$ 和我的预期 $y$ ，如果 $a_x \le y$ ，我将轮回并执行编号为 $u \rightarrow v$ 的操作中的 **阴魔法操作** 。$\left. \right \rfloor$

$\left \lceil \right. $ 另外，为了防止遗忘，我还会轮回执行编号为 $x$ 的操作。$\left. \right \rfloor$

你也知道，轮回的存档点是不能交错的，所以我的轮回是不会相交的。

请问你，能否帮我，回答我心中的问答？


## 说明/提示

**【对于样例 2，下面给出其每个操作过程中序列的值】**

|操作| $a_1$ | $a_2$ | $a_3$ | $a_4$ | $a_5$ | $a_6$ | 说明 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:----------:|
| 无 | 2 | 3 | 7 | 1 | 9 | 0 | 读入 |
| $1_{st}$ | 0 | 1 | 5 | 3 | 11 |  2  | $1\rightarrow6$ 都 $xor$ $2$|
| $2_{nd}$ | 2 | 3 | 7 | 1 | 9 | 0  | $a_4 = 3 \le 10$ ，进行 $1$ 操作|
| $3_{rd} $ | 2 | 3 | 4 | 1 | 9 | 3  |$3 $ $/$ $6$ 都 $xor$ 3|
| $4_{th} $ | 2 | 3 | 7 | 1 | 9 | 0  |$3 $ $/$ $6$ 都 $xor$ 3|
| $5_{th} $ | 2 | 3 | 7 | 1 | 9 | 0 | 输出 $a_5$|
| $6_{th} $ | 2 | 3 | 7 | 1 | 9 | 0 | 输出 $a_5$ |
| $7_{th} $ | 2 | 11 | 7 | 9 | 9 | 8  | $2$ $/$ $4$ $/$ $6$ 都 $xor$ $8$|
| $8_{th} $ | 2 | 11 | 7 | 9 | 9 | 8  | 输出 $a_5$ |
| $9_{th} $ | 2 | 11 | 7 | 9 | 9 | 8 | 输出 $a_5$|
| $10_{th} $ | 2 | 11 | 7 | 9 | 9 | 8 | 输出 $a_6$ |

------------

**【关于“保证”的说明】**

例如一串操作类型为 $op_1  = 1$、$op_2 = 4$、$op_3 = 2$、$op_4 = 3$、$op_5 = 1$、$op_6=4$。那么 $op_4$ 所对应的 $u$、 $v$ 只能为 $u = 3$ 、$v = 3$ ，因为 $u \le 2$ 会导致其范围内包含 $4$ 操作；而 $op_6$ 所对应的  $x$ 可以是 $4$ 或 $5$ ，因为这样子 $x$ 的右边到编号 $6$ 的左边都没有 $3$ 、$4$ 操作。

------------

 **【数据范围】**\
**本题采用捆绑测试。** 你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。
| Subtask | 特殊性质 | 分值 |
| :----------: | :----------: |:--------:|
| 1 | 为样例 $2$ | 2 pts|
| 2 | $n \le 10$ , $m \le 10$ | 8 pts |
| 3 | $n \le 1000$ , $m \le 1000 $ | 10 pts |
| 4 | $n \le 10^4$ , $m \le 10^4$ | 10 pts |
| 5 | $n \le 10^5 $ , $m \le 5 \times 10^5$ , 无操作 $4$ | 10 pts |
| 6 | $n \le 10^5 $ , $m \le 5 \times 10^5$ , 无操作 $3$ | 10 pts |
| 7 | $n \le 10^5 $ , $m \le 5 \times 10^5$ , 数据随机 | 18 pts |
| 8 | $n \le 10^5 $ , $m \le 5 \times 10^5$| 32 pts |
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5 $ , $m \le 5 \times 10^5$，保证过程及结果的所有值都在 int 范围内。

## 样例 #1

### 输入

```
6 10
1 1 4 5 1 4
1 1 6
1 2 8
4 2
4 3
4 4
4 5 
4 6
2 1
2 3
2 4```

### 输出

```
7
2
3```

## 样例 #2

### 输入

```
6 10
2 3 7 1 9 0
1 1 2
3 4 10 1 1
1 3 3
4 3
2 5
2 6
1 2 8
4 5
4 8
2 6```

### 输出

```
9
0
9
9
8```

# 题解

## 作者：a___ (赞：3)

首先，由于修改复杂度较大，所以我们考虑修改打 tag，查询时再求具体值。开一个数组 $b$ 记录 $ki,k\in Z^+$ 的位置都异或了 $b_i$；查询的时候枚举下标的所有因数 $p$，异或上所有的 $b_p$ 即可。  

然后我们对于所有 $3$、$4$ 操作，暴力修改。于是就拿到了 $68$ 分。

全部的部分分！

考虑 $3$ 操作。发现由于 $[u,i)$ 一定没有 $3$、$4$ 操作，所以每个 $1$、$2$ 操作只会最多被一个 $3$ 操作覆盖，所以在没有 $4$ 操作的情况下暴力询问数是 $\mathbf O(n)$ 的。  

考虑 $4$ 操作。这里定义一个 $4$ 操作 $i$ 的对应操作为不断跳 $i=x_i$ ，直到 $op_i\not=4$ 的第一个 $i$。分类讨论：

如果对应操作是 $1$ 或 $2$，那么直接暴力修改，没啥说的。

否则，由于 $(x,i)$ 一定没有 $3$、$4$，那么最劣情况为，一个 $4\to4\to4\to\dots\to3$，于是一个 $3$ 操作被反复执行了很多次，复杂度爆炸。

然鹅由于这题修改是异或，所以一个操作执行偶数次相当于撤销。容易想到把 $3$ 操作的修改单独开一个数组存起来，另外开一个 `flg` 表示这个修改究竟做没做。于是我们可以 $\mathbf O(1)$ 修改。  

然后还有一些具体细节，看代码。

```cpp
#include<cstdio>
const int N=1e5+10,M=5e5+10;
int n,m,a[N],b[N],c[N],op[M],x[M],y[M],flg,stk[M],top;
// b 表示常规修改；c 表示 3 操作修改；flg 为 0 表示修改失败，-1 表示修改成功
inline int get(int x)//求当前 a[x]
{
	int u,v;
	for(u=1,v=a[x];u*u<x;++u)
	if(x%u==0)v^=b[u]^b[x/u]^(flg&(c[u]^c[x/u]));
	if(u*u==x)v^=b[u]^(flg&c[u]);
	return v;
}
int main()
{
	int i,u,v;scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<=m;i++)
	{
		scanf("%d",&op[i]);
		switch(op[i])
		{
			case 1:
				scanf("%d%d",&x[i],&y[i]);
				b[x[i]]^=y[i];
				break;
			case 2:
				scanf("%d",&x[i]);
				printf("%d\n",get(x[i]));
				break;
			case 3:
				scanf("%d%d%d%d",&x[i],&y[i],&u,&v);
				while(top)b[stk[top]]^=flg&c[stk[top]],c[stk[top--]]=0;flg=0;//将之前的修改做了，清空 c 数组
				for(;u<=v;u++)if(op[u]==1)c[stk[++top]=x[u]]^=y[u];//开栈记录修改位置
				if(get(x[i])<=y[i])flg=-1;
				break;
			case 4:
				scanf("%d",&u);op[i]=op[u];x[i]=x[u];y[i]=y[u];//直接得到对应位置
				switch(op[i])
				{
					case 1:
						b[x[i]]^=y[i];
						break;
					case 2:
						printf("%d\n",get(x[i]));
						break;
					case 3:
						if(get(x[i])<=y[i])flg^=-1;//O(1) 修改
				}
		}
	}
	return 0;
}
```

---

## 作者：pikabi (赞：2)

### 2 pts 

复制样例 $2$ 输出谁不会嘞！

### 2 pts ~ 68 pts

先想想如果只有 $1$ 、 $2$ 操作该怎么办

很容易想到不可能每次都对每一个 $x$ 的倍数进行贡献，遇到那些小一点的 $x$ 就挂了。

所以我们从询问入手，把每一次 $1$ 操作的值存放到 $b$ 数组中。众所周知可以每次 $\sqrt{n}$ 获得因数的贡献。当然，也可以 $\sigma_0(n)$ 查找，除去了一些非因数的冗余操作。由于 $n \le 10^5$ ，可以得知 $\sigma_0(n) \le 128$ , 而 $\sqrt{n} \le 316$ ，因而也算是一个较好的常数优化。 

$\sqrt{n}$ 询问 :

```
for(int i = 1; i <= sqrt(x); i++){
		if(x % i == 0){
			if(i * i == x) ans += b[i];
			else ans += b[i] + b[x/i];
		}
	}
```

$\sigma_0(n)$ 询问我用的是递归：

```
inline void pre(){//预处理出所有数的一个质因数
	for(int i = 2; i <= n; i++){
		if(!vis[i]) prime[++cnt] = i, m_prime[i] = i;
		for(int j = 1; prime[j] * i <= n; j++){
			vis[prime[j] * i] = 1;
			m_prime[prime[j] * i] = m_prime[i];
			if(i % prime[j] == 0) break;
		}
	}
}

inline void get_prime(int p){//找出这个数的因数及其指数
	top = 0;
	while(p != 1){
		que[++top] = m_prime[p];
		num[top] = 0;
		int w = m_prime[p];
		while(p % w == 0){
			p /= w;
			num[top]++;
		}
	}
	ans = 0;
	dfs(1, 1);
}

inline void dfs(int p, int now){//然后枚举每一个质因子的指数，获得所有因数，并对答案做出贡献
	if(p == top + 1){
		ans += b[now];
		return ; 
	}
	int w = 1;
	for(int j = 0; j <= num[p]; j++){
		dfs(p + 1, now * w);
		w *= que[p];
	}
}

```
然鹅题目并没有只有 $1$、$2$ 操作的点，所以还是只能获得 $2$ 分的好成绩。

如果再加上 $3$ 操作，通法常法是~~直接调用~~

如果再加上 $4$ 操作，通法常法是~~直接调用~~

如果真就这么做，可以获得 $58$ pts 的好成绩。

想想对于 $4$ 操作的一个小优化，我们可以通过路径压缩避免了过多的重复调用，这样就多了 $10$ pts 了。

### 100 pts

## 解题关键是 3 、4 操作区间不重合

想想 **异或** 有什么性质

对于两个数 $x$ 、$y$ , $x \oplus y \oplus y = x$ ，这是显而易见的。

所以，对于所有的 $3$ 操作，我们只需要从 $u - 1$ 处继承状态，将 $u \rightarrow v$ 所有操作忽略，再将 $v + 1 \rightarrow i - 1$ 所有 $1$ 操作执行一遍即可。因而我们想到用可持久化线段树保存每一个状态的 $b_i$，并在其上进行各种操作即可。由于区间不重合，每个 $1$ 操作只会因此调用 $1$ 次，可以证明其复杂度为 $O(m\times log_n)$。

接下来只需要考虑调用 $3$ 操作的 $4$ 操作即可。显然我们不可以从 最终调用点开始进行类似上述操作，但是我们可以想到， 对于 $x$ 、$y$ , $x \oplus y \oplus y … \oplus y$ ，我们显然只需要找到上一个 $\oplus y$ 之前的位置，与当前 $\oplus y$ 抵消影响即可，所以我们又得用 $nxt$ 数组保存调用当前 $3$ 操作的最后一个操作编号，初始值为原本 $3$ 操作的编号。同理可证其复杂度为 $O(m\times log_n)$。

因为使用了线段树，询问的复杂度多了一个 $log_n$ ，故该解法复杂度为 $O(m \times \sigma_0(n) \times log_n)$ ，约为 $3\times10^5 \times 128 \times 17 = 6 \times 10^8 $ ，极限数据为先对每个位置进行 1 操作，再询问范围内因数最多的数的值，约为 $4 \times 10^8 $ ，故最大时限设为 2.5 s ，并开启 O2 ，为 std 的 1.5 倍。如果单纯 $\sqrt{n}$ 找因数，会比较慢一些。

#### UPdate: 人人吊踩std !
#### Update: 由于样例是手造的，所以疏忽了题目的限制了呜呜，谢罪(T﹏T)ノ｜！

---

## 作者：Da_un (赞：1)

这是一道锻炼思维的一道好题，题目应该都能读懂，这道题直接按照题目所说写出暴力模拟可以得五六十分不等。但要是想得满分，就必须换一种思维方式并且要运用一些技巧。

借鉴了一下题解区一位大佬的博客。
##### [借鉴](https://www.luogu.com.cn/blog/35137/solution-p7346)

进入正题。

这道题最耗费时间的就是操作 $3$ 与操作 $4$，所以要得满分的关键就在操作 $3$ 和操作 $4$ 所进行的优化。

对于操作 $1$ 与操作 $2$，我们也可以进行一些小优化。具体地，对于每一个操作 $1$，我们都只异或题目中给出的小于等于 $n$ 的第一个 $x$ 所对应的那个点，对于每一个操作 $2$，我们在求出 $a_x$ 的前提下，也可以在遍历的过程中对应该在操作 $1$ 中修改的元素进行修改，并且也避免了因为 $x$ 可能过小导致操作 $1$ 复杂度变的极大的问题。为了避免溢出，我们还可以设一个标记来判断此点能否修改，从而使得效率提高。

对于操作 $3$ 与操作 $4$，我们分开考虑。

对于操作 $3$，因为题目中给出对于任意的操作 $3$，$u \rightarrow i-1$ 必定没有操作 $3$ 或操作 $4$，所以对于任意的操作 $1$ 与操作 $2$，它们最多只会被操作 $3$ 覆盖，并且只会被覆盖一次，这样的话，时间复杂度并不高。

对于操作 $4$，因为题目中给出对于任意的操作 $4$，$(x,i)$ 必定没有操作 $3$ 或操作 $4$，所以对于操作 $1$ 与操作 $2$，直接返回上述所说的操作 $1$ 与操作 $2$ 的过程并执行即可。如果并不是操作 $1$ 与操作 $2$，那么为了防止操作 $3$ 或操作 $4$ 循环操作造成极大的复杂度，我们可以从修改这方面入手，因为是异或修改，所以每偶数次就可以变回原来的值，每奇数次就是异或一次的值，于是我们将操作 $3$ 的修改用一个数组存起来，用上述设得一个标记来判断是否修改，在查询时，直接查询并操作即可。

大体思路相信已经了解的差不多了，至于代码，总体与那位大佬的代码差不多，但为了更方便大家理解，就贴出来吧。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 100010
#define M 550010
using namespace std;
int n,m,a[N],b[N],c[N],op[M],x[M],y[M],tag,f[M],top;
//b是正常异或,c存的是操作3的修改 
//tag表示是否修改成功 
inline int quick_get(int x)
{
	//在取数的同时也对应该在操作1中修改的元素进行修改
	//降低时间复杂度 
	int u,v;
	for(u=1,v=a[x];u*u<x;++u)
		if(x%u==0)
			v^=b[u]^b[x/u],v^=(tag&(c[u]^c[x/u]));
		if(u*u==x)//特殊的 
			v^=b[u]^(tag&c[u]);
	return v;
}
int u,v;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++){
		scanf("%d",&op[i]);
		if(op[i]==1){
			scanf("%d%d",&x[i],&y[i]);
			b[x[i]]^=y[i];//直接异或最小的那一个 
		}
		if(op[i]==2){
			scanf("%d",&x[i]);
			printf("%d\n",quick_get(x[i]));
		}
		if(op[i]==3){
			scanf("%d%d%d%d",&x[i],&y[i],&u,&v);
			while(top)
			//每一次都先对上一次的修改进行改变(奇数与偶数) 
				b[f[top]]^=tag&c[f[top]],c[f[top--]]=0;
			tag=0;//初始化 
			for(;u<=v;u++)
				if(op[u]==1)
					c[f[++top]=x[u]]^=y[u];//操作1,与上面一样 
			if(quick_get(x[i])<=y[i])
				tag=-1;//没有进行修改 
		}
		if(op[i]==4){
			scanf("%d",&u);
			op[i]=op[u];
			x[i]=x[u];
			y[i]=y[u];
			//返回第u次操作的值再进行操作 
			if(op[i]==1)
				b[x[i]]^=y[i];
			if(op[i]==2)
				printf("%d\n",quick_get(x[i]));
			if(op[i]==3)
				if(quick_get(x[i])<=y[i])
					tag^=-1;
			}
			//操作1,2,3同上 
	}
	return 0;
	//完结撒花~~ 
}
```

---


# [BJWC2017] 太空飞船

## 题目背景

21XX 年，秋。

小诚是 THU（Tomorrow Happy University）航天学院船舶设计系本科四年级的学生。为了顺利毕业，小诚仔细阅读了这几年被引用次数最多的十几篇会议论文，打算在权威理论的指导下设计一艘新型太空飞船。

## 题目描述

这将是一艘环形的太空飞船，由 $N$ 个舱室顺序组成。第 $i$ 个舱室的设计长度为 $L_i$。

为了给飞船提供能量，要在飞船上装置 $K$ 个太空能量吸收器。根据权威理论，这些吸收器应该尽量均匀地分散在飞船表面。也就是说，小诚要把飞船所有 $N$ 个舱室划分成 $K$ 个部分（每个部分包括连续一段舱室），并给每个部分配置一个能量吸收器。设第 $i$ 个部分舱室的长度之和为 $s_i$，则要令方差尽量小。

可是，这个问题对于已经大学四年级的小诚来说太难了。你能否帮助他完成设计呢？为方便起见，输出方差最小值与 $K^2$ 的乘积。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$N \le 400$，$K \le 20$，$1 \le L_i \le 10^3$。

## 样例 #1

### 输入

```
5 3
4 2 6 1 3```

### 输出

```
24```

# 题解

## 作者：Dengxy (赞：3)

此题数据范围与题面不符，[原题传送门](http://ybt.ssoier.cn:8088/problem_show.php?pid=1791)。

# Description

将一个环分为 $t$ 部分，第 $i$ 个部分长度为 $s_i$，所有部分的平均长度为 $s_{avg}$ ，求 $\min\{t^2\sum (s_i - s_{avg})^2\}$.

# Solution

设 $t$ 个部分总长度为 $sum_n$，有 $s_{avg} = \frac{sum_n}{t}$

那么答案即为

$$
t^2\sum (s_i - s_{avg})^2 = t^2\sum s_i^2 - t \times sum_n^2.
$$

## k = 2

此时就是将环分成两部分，使得前一部分刚好小于 $s_{avg}$即可。

## k = 3

和 $k = 2$ 的情况一样，换成三部分即可。但是由于不一定分出的结果是最好的，所以要处理边界，尝试将分割点左右移动，找最小值。

## k > 3

由于 $t,sum_n$ 为常数，所以答案只与**每部分长度的平方和**有关。

于是问题转化为：将一个数列分为 $t$ 部分，最小化每部分的平方和。

令 $dp_{i,j}$ 表示前 $i$ 个数，分为 $j$ 部分，用 $sum_i$ 表示前 $i$ 部分的前缀和，得出状态转移方程：
$$
dp_{i,j} = \min\limits_{0<k<i}\{ dp_{k,j-1} +  (sum_i - sum_k)^2\}
$$

$dp_{i,j}$ 只与 $dp_{k,j-1}$ 有关，可以用滚动数组优化空间。将二次项拆开后，发现出现 $sum_i \times sum_j$ ，考虑用斜率优化。

设 $i_1 < i_2 $ 且 $dp_{i_1,j} < dp_{i_2,j}$，所以：

$$
dp_{i_1,j-1} + (sum_i-sum_{i_1})^2 < dp_{i_2,j-1} + (sum_i-sum_{i_2})^2
$$

即：

$$
2 \times sum_i < \frac{dp_{i_2,j-1}+sum_{j_2}-(dp_{i_1,j-1}+sum_{j_1})}{sum_{j_2}-sum_{j_2}}
$$

令 $Y(x) = dp_{x,j-1}+sum_x,X(x)=sum_x,$则：

$$
\frac{Y(i_2)-Y(i_1)}{X(i_2)-X(i_1)} > 2 \times sum_i
$$

最后直接斜率优化即可，时间复杂度 $O(n^2k)$。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 3e5 + 10;
int n,t,ans = 0x3f3f3f3f3f3f3f3f;;
int l[N],a[N],s[N];
int x[N],y[N],Fun[N],head,tail;
int f[N][2];

double slope(int j1,int j2)
{
	return 1.0 * (y[j2] - y[j1]) / (x[j2] - x[j1]);
}

void solve2()
{
	for(int i = 1;i <= n;++ i)
		s[i] = s[i-1] + l[i];
	int tmp = s[n] >> 1,pos = 0;
	int sum = 0;
	for(int i = 1;i <= n;++ i)
	{
		while(sum < tmp)
		{
			pos = pos + 1 > n ? 1 : pos + 1;
			sum += l[pos];
		}
		ans = min(ans,sum * sum + (s[n] - sum) * (s[n] - sum));
		sum -= l[i];
	}
	printf("%lld\n",t * t * ans - t * s[n] * s[n]);
}

void solve3()
{
	for(int i = 1;i <= n;++ i)
		s[i] = s[i-1] + l[i];
	int tmp = s[n] / 3;
	int pos1 = 1,pos2 = 1,sum1 = 0,sum2 = 0;
	for(int i = 1;i <= n;++ i)
	{
		while(sum1 < tmp)
		{
			if(pos1 < pos2) sum2 -= l[(pos1 - 1) % n + 1];
			//由于涉及第二段减去第一段选择的长度，用取模代替滚动 
			sum1 += l[(pos1 - 1) % n + 1];
			++ pos1;
		}
		pos2 = max(pos2,pos1);
//		printf("sum2 after pos1:%lld ,pos2:%lld\n",sum2,pos2);
		while(sum2 + l[(pos2 - 1) % n + 1] <= s[n] - sum1 - sum2 - l[(pos2 - 1) % n + 1])//使两边尽量均衡 
		{
			sum2 += l[(pos2 - 1) % n + 1];
			++ pos2;
		}
		
		int sum3 = s[n] - sum1 - sum2,sum4;
		ans = min(ans,sum1 * sum1 + sum2 * sum2 + sum3 * sum3);
		
		sum3 = sum2 + l[(pos2 - 1) % n + 1],sum4 = s[n] - sum1 - sum3;
		ans = min(ans,sum1 * sum1 + sum3 * sum3 + sum4 * sum4);
//		printf("%lld pos:%lld %lld len:%lld %lld %lld or %lld %lld %lld\n",i,pos1,pos2,sum1,sum2,s[n] - sum1 - sum2,sum1,sum3,sum4);
		sum1 -= l[i];
	}
	printf("%lld\n",t * t * ans - t * s[n] * s[n]);
}

signed main()
{
	scanf("%lld%lld",&n,&t);
	for(int i = 1;i <= n;++ i)
		scanf("%lld",&l[i]);
		
	if(t == 2)
	{
		solve2();
		return 0;
	}
	if(t == 3)
	{
		solve3();
		return 0;
	}
	
	for(int pos = 1;pos <= n;++ pos)
	{
		int cnt = 0,p = 0;
		for(int i = pos;i <= n;++ i)
			a[++cnt] = l[i];
		for(int i = 1;i < pos;++ i)
			a[++cnt] = l[i];
		s[0] = 0;
		for(int i = 1;i <= n;++ i)
		{
			s[i] = s[i-1] + a[i];
			f[i][p^1] = s[i] * s[i];
		}
		
		for(int j = 2;j <= t;++ j)
		{
			head = 1,tail = 1;
			for(int i = 1;i <= n;++ i)
			{
				while(head < tail && slope(Fun[head],Fun[head+1]) <= 2 * s[i])
					++ head;
				
				int k = Fun[head];
				f[i][p] = f[k][p^1] + (s[i] - s[k]) * (s[i] - s[k]);
				x[i] = s[i];
				y[i] = f[i][p^1] + s[i] * s[i];
				
				while(head < tail && slope(Fun[tail-1],Fun[tail]) >= slope(Fun[tail],i))
					-- tail;
				//维护一个下凸包 
				
				Fun[++tail] = i;
			}
			p ^= 1;
		}
		ans = min(ans,f[n][p^1]);
	}
	printf("%lld\n",t * t * ans - t * s[n] * s[n]);
	return 0;
}
```



---

## 作者：Aiopr_2378 (赞：0)

### 解题思路

这才是真正的数据范围，希望修复一下。

|测试点编号|$n=$|$k=$|
|:-:|:-:|:-:|
|#1|$10^3$|$2$|
|#2|$10^5$|$2$|
|#3|$100$|$3$|
|#4|$10^5$|$3$|
|#5|$3\times 10^5$|$3$|
|#6|$50$|$6$|
|#7|$100$|$7$|
|#8|$200$|$10$|
|#9|$300$|$15$|
|#10|$400$|$20$|

#### sub1

对于 $k=2$ 的情况，使得方差最小，需要两组的差尽量小。又由于是滚动的，所以只需要二分找到前一组不大于 $s_{avg}$ 的最大值即可均分。

#### sub2

对于 $k=3$ 的情况，与上面类似，枚举一个起点，两次二分找到两组和为 $s_{avg}$ 的位置即可。但是需要注意，你不知道每组多一点好还是少一点好，所以需要枚举一下边界情况，即各组分节点左移右移一个位置的情况。

#### sub3

先对方差展开：

$$
\begin{aligned}
k^2 \sum_{i=1}^{k}(s_i-s_{avg})^2&=k^2 \sum_{i=1}^k s_i^2+k^2 \sum_{i=1}^k s_{avg}^2 - k^2 \sum_{i=1}^k 2s_is_{avg} \\
&=k^2 \sum_{i=1}^k s_i^2 -k \sum_{i=1}^k s_i
\end{aligned}
$$

发现答案只与 $\sum_{i=1}^k s_i ^2$ 相关，考虑动态规划。

设 $f_{i,t}$ 表示 分成 $t$ 段，前 $i$ 个数所组成的最小答案 $\sum_{i=1}^t s_i^2$。不难得到转移方程

$$
f_{i,t}=\min_{j=0}^{t-1} \{f_{j,t-1}+ (sum_i-sum_j)^2 \}
$$

其中 $sum_i=\sum_{j=1}^i a_j$。转移方程中有 $i$ 和 $j$ 相关项，使用斜率优化。

$$
f_{i,t}-sum_i^2=-2sum_isum_j+sum_j^2+f_{j,t-i}
$$

令 $x=sum_j$，$y=sum_j^2+f_{j,t-1}$，$k=2sum_i$，$b=f_{i,t}-sum_i^2$。则上式变为

$$
b=-kx+y
$$

等价于对于一次函数 $y=kx+b$ 求得截距最小时的 $j$ 取值。由于斜率 $k=2*sum_i$ 单调递增，所以直接使用单调队列维护下凸壳即可。

### 参考代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#define MAXN1 600005
#define MAXN2 805
int n,m,a[MAXN1],sum[MAXN1],s[MAXN1],ans=__INT32_MAX__,per;
int calc(){
    int cnt=0;
    for(int i=1;i<=m;i++) cnt+=s[i]*s[i];
    cnt=1ll*cnt*m*m-1ll*sum[n]*sum[n]*m;
    return cnt;
}
namespace sub1{
    void solve(){
        for(int i=1;i<=n;i++){
            int j=upper_bound(sum+1,sum+1+n*2,sum[i-1]+per)-sum-1;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[i+n-1]-sum[j];
            ans=min(ans,calc());
        }
    }
}
namespace sub2{
    void solve(){
        for(int i=1;i<=n;i++){
            int j=upper_bound(sum+1,sum+1+n*2,sum[i-1]+per)-sum-1;
            int k=upper_bound(sum+1,sum+1+n*2,sum[j]+per)-sum-1;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            j--;
            k=upper_bound(sum+1,sum+1+n*2,sum[j]+per)-sum-1;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            k--;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            k+=2;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            j+=2;
            k=upper_bound(sum+1,sum+1+n*2,sum[j]+per)-sum-1;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            k--;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
            k+=2;
            s[1]=sum[j]-sum[i-1];
            s[2]=sum[k]-sum[j];
            s[3]=sum[i+n-1]-sum[k];
            ans=min(ans,calc());
        }
    }
}
namespace sub3{
    int f[MAXN2][22],l,r;
    struct node{
        int x,y;
    }q[MAXN2];
    double slope(node x,node y){
        return 1.*(y.y-x.y)/(y.x-x.x);
    }
    void solve(){
        for(int i0=0;i0<n;i0++){
            memset(f,0x3f,sizeof(f));
            for(int i=1+i0;i<=n+i0;i++){
                int s1=sum[i]-sum[i0];
                f[i][1]=s1*s1;
            }
            for(int t=2;t<=m;t++){
                l=1,r=0;
                int s0=sum[t-1+i0]-sum[i0];
                q[++r]={s0,s0*s0+f[t-1+i0][t-1]};
                for(int i=t+i0;i<=n+i0;i++){
                    int k=(sum[i]-sum[i0])*2,si=sum[i]-sum[i0];
                    while(l<r&&slope(q[l],q[l+1])<=k) l++;
                    f[i][t]=q[l].y-q[l].x*k+si*si;
                    node now={si,si*si+f[i][t-1]};
                    while(l<r&&slope(q[r-1],q[r])>slope(q[r],now)) r--;
                    q[++r]=now;
                }
            }
            ans=min(1ll*ans,1ll*f[n+i0][m]*m*m-1ll*m*sum[n]*sum[n]);
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i+n]=a[i];
    }
    for(int i=1;i<=n*2;i++) sum[i]=sum[i-1]+a[i];
    per=sum[n]/m;
    if(m==2) sub1::solve();
    else if(m==3) sub2::solve();
    else sub3::solve();
    cout<<ans<<endl;
    return 0;
}
```

---


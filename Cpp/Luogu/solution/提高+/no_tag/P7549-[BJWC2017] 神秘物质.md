# [BJWC2017] 神秘物质

## 题目背景

21ZZ 年，冬。

小诚退休以后，不知为何重新燃起了对物理学的兴趣。他从研究所借了些实验仪器，整天研究各种微观粒子。

## 题目描述

这一天，小诚刚从研究所得到了一块奇异的陨石样本，便迫不及待地开始观测。在精密仪器的视野下，构成陨石的每个原子都无比清晰。

小诚发现，这些原子排成若干列，每一列的结构具有高度相似性。于是，他决定对单独一列原子进行测量和测试。

被选中的这列共有 $N$ 个顺序排列的原子。最初， 第 $i$ 个原子具有能量 $E_i$。 随着时间推移和人为测试，这列原子在观测上会产生两种变化：

- `merge x e`：当前第 $x$ 个原子和第 $x + 1$ 个原子合并，得到能量为 $e$ 的新原子；
- `insert x e`：在当前第 $x$ 个原子和第 $x + 1$ 个原子之间插入一个能量为 $e$ 的新原子。

对于一列原子，小诚关心的是相邻一段中能量最大和能量最小的两个原子的能量差值，称为区间极差。因此，除了观测变化外，小诚还要经常统计这列原子的两类数据：

- `max x y`：表示当前第 $x$ 到第 $y$ 个原子之间的任意子区间中区间极差的最大值；
- `min x y`：表示当前第 $x$ 到第 $y$ 个原子之间的任意子区间中区间极差的最小值。

其中，子区间指的是长度至少是 $2$ 的子区间。

小诚坚信这项研究可以获得诺贝尔物理学奖。为了让小诚早日了结心愿，你能否帮助他实现上述的观测和测量呢？

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le M \le 10^5$，$1 \le e,E_i \le 10^9$。

设 $N'$ 为当前时刻原子数目：

- 对于 merge 类事件，$1 \le x \le N' - 1$；
- 对于 insert 类事件，$1 \le x \le N'$；
- 对于 max 和 min 类事件，$1 \le x < y \le N'$。

任何时刻，保证 $N' \ge 2$。

## 样例 #1

### 输入

```
4 3
5 8 10 2
max 1 3
min 1 3
max 2 4```

### 输出

```
5
2
8```

# 题解

## 作者：cyffff (赞：7)

[$\text{Link}$](https://www.luogu.com.cn/problem/P7549)

在校内 $\text{OJ}$ 看到的一道题，在 $\text{Luogu}$ 找到了，发现没有题解，于是来写一个。

sto zltzlt orz.

## 题意
给你一个序列 $a$，支持 $4$ 个操作：

- $\text{merge x e}$，删除结点 $x,x+1$，在 $x$ 的位置插入一个节点，权值为 $e$；
- $\text{insert x e}$，在 $x$ 和 $x+1$ 之间插入一个节点，权值为 $e$；
- $\text{max l r}$，查询区间 $[l,r]$ 中任意子区间的区间极差的最大值；
- $\text{min l r}$，查询区间 $[l,r]$ 中任意子区间的区间极差的最小值。

$1\le n,m\le 10^5$.
## 思路
看到插入、删除就可以想到使用文艺平衡树来解决问题，这里我使用 $\text{Splay}$，操作 $1,2$ 十分显然。

$3$ 操作可以直接维护区间的最大值和最小值，答案就是它们做差。

$4$ 操作中，我们设答案的子区间为 $[l',r']$，设其中最大值为 $a$，最小值为 $b$，若区间中加入一个数 $v$，则 $a\gets \max(a,v),b\gets\min(b,v),\max(a,v)-\min(b,v)\ge a-b$，即插入一个数显然不会更优，所以答案区间长度为 $2$。所以我们可以维护每个数与其左右的差的绝对值，分别设为 $lb_x,rb_x$，再维护 $ms_x$ 代表 $x$ 子树内 $lb,rb$ 的最小值，答案即为 $ms$。注意需要特判 $l+1=r$ 的情况，直接取 $rb_l$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=5e5+10,INF=1e9+10;
int s[N];
int n,m;
struct Splay{
	#define ls a[x].son[0]
	#define rs a[x].son[1]
	int rt,sz;
	struct node{
		int f,val,son[2],sz;
		int minn=INF,maxn,lb,rb,ms;
		inline void clear(){
			f=maxn=son[0]=son[1]=val=sz=0;
			minn=ms=lb=rb=INF;
		}
	}a[N];
	inline bool isr(int x){return a[a[x].f].son[1]==x;}
	inline void upd(int x){
		node &p=a[x];
		p.maxn=p.minn=p.val;
		p.ms=min(p.lb,p.rb);
		if(ls) p.maxn=max(p.maxn,a[ls].maxn),p.minn=min(p.minn,a[ls].minn),p.ms=min(p.ms,a[ls].ms);
		if(rs) p.maxn=max(p.maxn,a[rs].maxn),p.minn=min(p.minn,a[rs].minn),p.ms=min(p.ms,a[rs].ms);
		p.sz=a[ls].sz+1+a[rs].sz;
	}
	inline int newnode(int v){
		sz++;
		a[sz].minn=a[sz].maxn=a[sz].val=v;
		return sz;
	}
	inline void rotate(int x){
		int f=a[x].f,gf=a[f].f;
		int id=isr(x);
		a[f].son[id]=a[x].son[id^1];
		a[a[f].son[id]].f=f;
		a[x].son[id^1]=f;
		a[f].f=x;
		a[x].f=gf;
		if(gf){
			a[gf].son[a[gf].son[1]==f]=x;
		}
		upd(f);
	}
	inline void splay(int x,int goal=0){
		goal=a[goal].f;
		for(int f;(f=a[x].f)!=goal;rotate(x)){
			if(a[f].f!=goal){
				rotate(isr(x)==isr(f)?f:x);
			}
		}
		if(!goal)
		rt=x;
	}
	inline int build(int l,int r,int f){
		if(l>r)return 0;
		int mid=l+r>>1;
		sz++;
		int now=sz;
		a[now].f=f;
		a[now].val=s[mid];
		a[now].lb=mid?abs(s[mid]-s[mid-1]):INF;
		a[now].rb=mid!=n+1?abs(s[mid]-s[mid+1]):INF;
		a[now].son[0]=build(l,mid-1,now);
		a[now].son[1]=build(mid+1,r,now);
		upd(now);
		return now;
	}
	inline int find(int x){
		int now=rt;
		while(1){
			if(x<=a[a[now].son[0]].sz){
				now=a[now].son[0];
			}else{
				x-=a[a[now].son[0]].sz+1;
				if(!x){
					return now;
				}
				now=a[now].son[1];
			}
		}
	}
	inline int split(int l,int r){
		int x=find(l);
		splay(x,rt);
		int y=find(r+2);
		splay(y,a[x].son[1]);
		return a[y].son[0];
	}
	inline void MoMerge(int wz,int v){
		int x=split(wz,wz+1),f=rt,y=a[f].son[1];
		a[x].val=v;
		if(ls) a[ls].clear(),ls=0;
		if(rs) a[rs].clear(),rs=0;
		a[f].rb=a[x].lb=abs(v-a[f].val);
		a[x].rb=a[y].lb=abs(v-a[y].val);
		upd(x),upd(y),upd(f);
	}
	inline void MoInsert(int wz,int v){
		int x=split(wz,wz),f=rt,y=a[f].son[1],z=newnode(v);
		a[z].f=x;
		a[x].son[1]=z;
		a[x].rb=a[z].lb=abs(v-a[x].val);
		a[z].rb=a[y].lb=abs(v-a[y].val);
		upd(z),upd(x),upd(y);
	}
	inline int QuMax(int l,int r){
		int x=split(l,r);
		return a[x].maxn-a[x].minn;
	}
	inline int QuMin(int l,int r){
		int x;
		if(r-l<=1){
			x=split(l,r-1);
			return a[x].rb;
		}else{
			x=split(l+1,r-1);
			return a[x].ms;
        }
	}
}t;
int main(){
	n=read(),m=read();
	s[0]=INF;
	for(int i=1;i<=n;i++){
		s[i]=read();
	}
	s[n+1]=INF;
	t.sz=n+2;
	t.rt=t.build(0,n+1,0);
	while(m--){
		char opt=getc();
		switch(opt){
			case 'e':{
				int wz=read(),v=read();
				t.MoMerge(wz,v);
				break;
			}
			case 'n':{
				int wz=read(),v=read();
				t.MoInsert(wz,v);
				break;
			}
			case 'a':{
				int l=read(),r=read();
				write(t.QuMax(l,r));
				putc('\n');
				break;
			}
			case 'i':{
				int l=read(),r=read();
				write(t.QuMin(l,r));
				putc('\n');
				break;
			}
		}
	}
	flush();
}
```
再见 qwq~

---

## 作者：orz_z (赞：4)

维护一个序列，要求支持合并相邻两个节点（并赋入新的值）、插入、询问一段区间中任意子区间的区间极差的最大值和最小值。

值域 $10^9$，点数 $10^5$，操作数 $10^5$。

#### std

算是一眼题了~~（那就水个题解）~~。

对于修改，用平衡树维护即可。

对于极差最大值，显然用整段区间的最大值减最小值是最优的，维护子树内的最大值和最小值即可。

对于极差最小值，显然当子区间为 $2$ 是答案最优，维护相邻两数的绝对值差即可。

所以，总时间复杂度为 $\mathcal O(m \log n)$，可过。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int _ = 1e6 + 10;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		x = x * 10 + (c - '0'), c = getchar();
	return x * f;
}

int n, m, root, cnt;

struct Tree
{
	int l, r, key, val, siz, mx, mn, les, res, mires;
} tr[_];

void update(int k)
{
	tr[k].siz = tr[tr[k].l].siz + tr[tr[k].r].siz + 1;
	tr[k].mx = tr[k].mn = tr[k].les = tr[k].res = tr[k].val;
	tr[k].mires = 2e9;
	if (tr[k].l != 0)
		tr[k].mx = max(tr[k].mx, tr[tr[k].l].mx),
		tr[k].mn = min(tr[k].mn, tr[tr[k].l].mn),
		tr[k].les = tr[tr[k].l].les,
		tr[k].mires = min(tr[k].mires, min(abs(tr[tr[k].l].res - tr[k].val), tr[tr[k].l].mires));
	if (tr[k].r != 0)
		tr[k].mx = max(tr[k].mx, tr[tr[k].r].mx),
		tr[k].mn = min(tr[k].mn, tr[tr[k].r].mn),
		tr[k].res = tr[tr[k].r].res,
		tr[k].mires = min(tr[k].mires, min(abs(tr[tr[k].r].les - tr[k].val), tr[tr[k].r].mires));
}

int New(int v)
{
	int now = ++cnt;
	tr[now].val = tr[now].mx = tr[now].mn = tr[now].les = tr[now].res = v;
	tr[now].mires = 2e9;
	tr[now].siz = 1;
	tr[now].key = rand();
	return now;
}

void put(int i)
{
	if (tr[i].l)
		put(tr[i].l);
	printf("%d ", tr[i].val);
	if (tr[i].r)
		put(tr[i].r);
}

void split(int rt, int val, int &x, int &y)
{
	if (!rt)
	{
		x = y = 0;
		return;
	}
	if (tr[tr[rt].l].siz < val)
	{
		x = rt;
		split(tr[rt].r, val - tr[tr[rt].l].siz - 1, tr[rt].r, y);
	}
	else
	{
		y = rt;
		split(tr[rt].l, val, x, tr[rt].l);
	}
	update(rt);
}

int merge(int x, int y)
{
	if (!x || !y)
		return x + y;
	if (tr[x].key < tr[y].key)
	{
		tr[x].r = merge(tr[x].r, y);
		update(x);
		return x;
	}
	else
	{
		tr[y].l = merge(x, tr[y].l);
		update(y);
		return y;
	}
}

void insert(int pos, int val)
{
	int x, y;
	split(root, pos, x, y);
	root = merge(merge(x, New(val)), y);
}

int query1(int l, int r)
{
	int x, y, z, res;
	split(root, r, y, x);
	split(y, l - 1, z, y);
	res = tr[y].mx - tr[y].mn;
	root = merge(merge(z, y), x);
	return res;
}

int query2(int l, int r)
{
	int x, y, z, res;
	split(root, r, y, x);
	split(y, l - 1, z, y);
	res = tr[y].mires;
	root = merge(merge(z, y), x);
	return res;
}

signed main()
{
	srand(time(0));
	n = read(), m = read();
	for (int i = 1; i <= n; ++i)
	{
		insert(i - 1, read());
	}
	char op[107];
	int a, b;
	while (m--)
	{
		scanf("%s", op);
		a = read(), b = read();
		if (op[1] == 'e')
		{
			int x, y, z;
			split(root, a + 1, x, y), split(x, a - 1, x, z);
			root = merge(merge(x, New(b)), y);
		}
		else if (op[1] == 'n')
		{
			insert(a, b);
		}
		else if (op[1] == 'a')
		{
			printf("%lld\n", query1(a, b));
		}
		else if (op[1] == 'i')
		{
			printf("%lld\n", query2(a, b));
		}
	}
	return 0;
}
```





---

## 作者：pldzy (赞：2)

[传送门：P7549 [BJWC2017] 神秘物质](https://www.luogu.com.cn/problem/P7549)

先膜拜一下 $\text{cyf}$ 学长。本题解主要是补充一下 $\text{cyf}$ 学长思路的细节。

## Solution

### 1

首先看操作一、二，发现它们的本质实际上都是对一段区间的操作。

所以本题使用文艺平衡树来维护。

也就是说，对于每次的一、二操作，我们都会将要进行修改的区间旋转到一颗子树内，即文艺平衡树中翻转区间的预操作。

具体可以看@[皎月半洒花](https://www.luogu.com.cn/user/28313)在文艺平衡树题解中放的这张图：（设将要修改的区间为 $[l,r]$。）

![ ](https://cdn.luogu.com.cn/upload/pic/18083.png)

不同之处在于我们后面并不是执行翻转操作。

不过在这道题中要注意的是：

因为我们在最开始建树的时候，为了防止越界，在序列开头和结尾各新增了一个节点，所以此时我们要修改的区间就变成了 $[l + 1, r + 1]$，所以需要查找和被执行旋转操作的节点就变成了序列中第 $l$ 个节点和第 $(r + 2)$ 个节点。

### 2

再来看三、四操作。

第三个操作显然就是给每个节点都维护一个其区间内的最大值和最小值，查询的时候直接将区间 $[l,r]$ 按 1 中所述的那样旋转到一起去，然后输出最大值和最小值的差值即可。

重点在于第四个操作。

可以发现一个性质：对于一个区间 $[l,r]$，新增加一个数并不会使其区间极差最小值更小。

证明：

区间 $[l,r]$ 的极差最小值是其中的最大值和最小值之差。而对于新增节点来说，可能可以造成影响的情况就是它会更新此区间的最大（小）值。

但是，我们发现不论它是更新了最大值还是最小值，都只会让这个区间极差更大（这个不难理解）。

证毕。

所以我们实际上只需要给每个节点都维护与其相邻节点的差值就好了，同时还要维护一下这个节点所代表的区间内任意子区间中区间极差的最小值。

查询的时候注意要判断查询区间仅有两个节点的情况。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define ls t[x].ch[0]
#define rs t[x].ch[1]
const int maxn = 3e5 + 10;
const int inf = 2147483647;
int n, m;
int rt, tot;
int e[maxn];
struct node{
	int ch[2];
	int siz, f, val;
	int mn, mx;
	int lb, rb, ms;
}t[maxn];

inline void up(int x)
{
	t[x].siz = t[ls].siz + 1 + t[rs].siz;
	t[x].mn = t[x].mx = t[x].val;
	t[x].ms = min(t[x].lb, t[x].rb);
	if(ls) 
		t[x].mn = min(t[x].mn, t[ls].mn), t[x].mx = max(t[x].mx, t[ls].mx), 
		t[x].ms = min(t[x].ms, t[ls].ms);
	if(rs) 
		t[x].mn = min(t[x].mn, t[rs].mn), t[x].mx = max(t[x].mx, t[rs].mx), 
		t[x].ms = min(t[x].ms, t[rs].ms);
}

inline int nw(int v)
{
	int u = ++tot;
	t[u].mn = t[u].mx = t[u].val = v;
	return u;
}

inline void rotate(int x)
{
	int y = t[x].f, z = t[y].f;
	int kx = (t[y].ch[1] == x), ky = (t[z].ch[1] == y);
	t[z].ch[ky] = x, t[x].f = z;
	t[y].ch[kx] = t[x].ch[kx ^ 1], t[t[x].ch[kx ^ 1]].f = y;
	t[x].ch[kx ^ 1] = y, t[y].f = x;
	up(y), up(x);
}

inline void splay(int x, int gl)
{
	while(t[x].f != gl)
	{
		int y = t[x].f, z = t[y].f;
		if(z != gl) 
			(t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? rotate(x) : rotate(y);
		rotate(x);
	}
	if(!gl) rt = x;
}

inline int build(int l, int r, int fa)
{
	if(l > r) return 0;
	int mid = (l + r) >> 1;
	int u = ++tot;
	t[u].f = fa, t[u].val = e[mid];
	t[u].lb = mid ? abs(e[mid] - e[mid - 1]) : inf;
	t[u].rb = mid != n + 1 ? abs(e[mid] - e[mid + 1]) : inf;
	t[u].ch[0] = build(l, mid - 1, u);
	t[u].ch[1] = build(mid + 1, r, u);
	up(u);
	return u;
}

inline int find(int k)
{
	int x = rt;
	while(531)
	{
		if(t[ls].siz + 1 < k)
			k -= t[ls].siz + 1, x = rs;
		else if(t[ls].siz >= k)
			x = ls;
		else return x;
	}
}

inline int split(int l, int r)
{
	int x = find(l), y = find(r + 2);
	splay(x, 0), splay(y, x);
	return t[y].ch[0];
}

inline void delet(int x)
{
	ls = rs = t[x].f = t[x].siz = t[x].val = t[x].mx = 0;
	t[x].mn = t[x].ms = t[x].lb = t[x].rb = inf;
}

inline void merge_(int pos, int v)
{
	int x = split(pos, pos + 1), lst = rt, nxt = t[lst].ch[1];
	t[x].val = v;
	if(ls) delet(ls), t[x].ch[0] = 0;
	if(rs) delet(rs), t[x].ch[1] = 0;
	t[x].lb = t[lst].rb = abs(v - t[lst].val);
	t[x].rb = t[nxt].lb = abs(t[nxt].val - v);
	up(x), up(nxt), up(lst);
}

inline void insrt_(int pos, int v)
{
	int x = split(pos, pos), lst = rt, nxt = t[lst].ch[1];
	int u = nw(v);
	t[u].f = x, t[x].ch[1] = u;
	t[x].rb = t[u].lb = abs(v - t[x].val);
	t[nxt].lb = t[u].rb = abs(v - t[nxt].val);
	up(u), up(x), up(nxt), up(lst);
}

inline int qrymx_(int l, int r)
{
	int x = split(l, r);
	return t[x].mx - t[x].mn;
}

inline int qrymn_(int l, int r)
{
	if(l + 1 == r) return t[split(l, r - 1)].rb;
	else return t[split(l + 1, r - 1)].ms;
}

int main()
{
	scanf("%d%d", &n, &m);
	rep(i, 1, n) scanf("%d", &e[i]);
	e[0] = e[n + 1] = inf, tot = n + 1;
	rt = build(0, n + 1, 0);
	rep(i, 1, m)
	{
		char c[10];
		int x, y;
		scanf("%s%d%d", c, &x, &y);
		if(c[1] == 'e') merge_(x, y);         
		if(c[1] == 'n') insrt_(x, y);
		if(c[1] == 'a') printf("%d\n", qrymx_(x, y));
		if(c[1] == 'i') printf("%d\n", qrymn_(x, y));
	}
	return 0;
}
```



------------
感谢阅读。

辛苦管理员审核，若有问题烦请指出。

---

## 作者：FxorG (赞：1)

## $\text{Solution}$

插入一个新能源和合并成为一个新的就文艺平衡树基本操作，分裂出对应区间，合并就先删除掉以前的，之后再插入。 max 的话维护下子树最大值和最小值即可。但 min 怎么维护？

我们加入插进来数 x ,原来有 a , b 两数。

则原来:  $a-b$  ，现在  $max(a,x)-min(b,x)$  ,我们发现这个式子单调不降，所以我们要答案区间长度越小越好，所以答案区间是2。意味着我们需要维护相邻两数的绝对值差（极差是非负数）

如何在 fhq 上维护相邻的数呢？
只需要记录下子树向左/右能最远扩展到的值即可。
那么当前左边的数是不是左子树向右最远扩展的值，右边同理。

## $\text{Code}$

```cpp
#include <bits/stdc++.h>

#define N (int)(1e5+5)
#define int long long
#define inf (int)(2e18)

using namespace std;
int rd() {
	int f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}

struct FHQ {
	int ls,rs,val,rad,sz,lres,rres,mires,mx,mi;
	FHQ() {
		ls=rs=val=rad=sz=lres=rres=mires=mx=mi=0;
	}
}t[N<<2];
int tot,rt;
void push_up(int cur) {
	int ls=t[cur].ls,rs=t[cur].rs;
	t[cur].sz=t[ls].sz+t[rs].sz+1;
	t[cur].mx=t[cur].mi=t[cur].lres=t[cur].rres=t[cur].val;
	t[cur].mires=inf;
	if(ls) {
		t[cur].mi=min(t[cur].mi,t[ls].mi);
		t[cur].mx=max(t[cur].mx,t[ls].mx);
		t[cur].lres=t[ls].lres;
		t[cur].mires=min(t[cur].mires,min(abs(t[ls].rres-t[cur].val),t[ls].mires));
	}
	if(rs) {
		t[cur].mi=min(t[cur].mi,t[rs].mi);
		t[cur].mx=max(t[cur].mx,t[rs].mx);
		t[cur].rres=t[rs].rres;
		t[cur].mires=min(t[cur].mires,min(abs(t[rs].lres-t[cur].val),t[rs].mires)); 
	}
}

void split(int cur,int num,int &x,int &y) {
	if(!cur) return x=y=0,void();
	if(t[t[cur].ls].sz+1<=num) {
		x=cur;
		split(t[cur].rs,num-t[t[cur].ls].sz-1,t[cur].rs,y);
	} else {
		y=cur;
		split(t[cur].ls,num,x,t[cur].ls);
	}
	push_up(cur);
}

int merge(int x,int y) {
	if(!x||!y) return x+y;
	if(t[x].rad<t[y].rad) {
		t[x].rs=merge(t[x].rs,y);
		push_up(x); return x;
	} else {
		t[y].ls=merge(x,t[y].ls);
		push_up(y); return y;
	}
}

int newp(int x) {
	++tot; t[tot].rad=rand(); t[tot].val=x; t[tot].sz=1; t[tot].mires=inf;
	t[tot].mi=t[tot].mx=t[tot].rres=t[tot].lres=x;
	return tot;
}

void ins(int pos,int v) {
	int r1,r2;
	split(rt,pos,r1,r2);
	rt=merge(merge(r1,newp(v)),r2);
}

void remerge(int pos,int v) {
	int r1,r2,r3;
	split(rt,pos+1,r1,r2); split(r1,pos-1,r1,r3);
	rt=merge(merge(r1,newp(v)),r2);
}

int query1(int l,int r) {
	int r1,r2,r3,res;
	split(rt,r,r2,r1); split(r2,l-1,r3,r2);
	res=t[r2].mx-t[r2].mi;
	rt=merge(merge(r3,r2),r1);
	return res;
}

int query2(int l,int r) {
	int r1,r2,r3,res;
	split(rt,r,r2,r1); split(r2,l-1,r3,r2);
	res=t[r2].mires;
	rt=merge(merge(r3,r2),r1);
	return res;
}

void DEBUG(int cur) {
	if(t[cur].ls) DEBUG(t[cur].ls);
	cout<<t[cur].val<<endl;
	if(t[cur].rs) DEBUG(t[cur].rs);
}

signed main() {
	srand(998244353); //srand((rand()<<3)*(rand()<<2));
	++tot; t[1].val=inf; t[1].mi=inf; t[1].mx=-1; t[1].mires=inf;
	int n,m,x,y; char op[10]; n=rd(); m=rd();
	for(int i=1;i<=n;i++) {
		x=rd(); ins(i-1,x);
	}
//	DEBUG(rt);
	while(m--) {
		scanf("%s",op); x=rd(); y=rd();
		if(op[1]=='e') {
			remerge(x,y);
		} else if(op[1]=='n') {
			ins(x,y);
		} else if(op[1]=='a') {
			printf("%lld\n",query1(x,y));
		} else if(op[1]=='i') {
			printf("%lld\n",query2(x,y));
		}
	}
	return 0;
}
```

---

## 作者：Kazeno_Akina (赞：0)

前言：前几天学会块状链表之后被同学 热情推荐 的 好题。结果过了之后发现题解区块状链表题解又少又难懂，所以决定自己写一篇。

首先考虑的是两种查询操作如何做。区间极差的最大值，也就是该区间内的最大值减最小值，这个是容易发现的（因为大值变大优，小值变小优）。然后考虑区间极差的最小值，发现区间扩展之后极差肯定不降，所以直接考虑所有长度为 $2$ 的子区间即可。

结果你发现最大值和最小值数据结构随便维护，这个“长度为 $2$ 的区间的内部差的最小值”好像很难做，因为你有增加和删除（合并的本质也就是增 $1$ 删 $2$）。

于是考虑暴力数据结构。显然朴素的分块不好处理增加和删除操作，因此考虑块状链表。

确定了数据结构就考虑在块状链表的每个节点上维护什么。根据刚才的讨论，我们维护最大值最小值还有那个长度为 $2$ 的区间内部差最小值就都行了。设每一个块的数组大小为 $len$，这三个东西都容易在块内暴力地 $O(len)$ 维护（插入记得分裂）。然后你查询的时候，`max` 询问就一块一块扫过去就行了，但是 `min` 操作由于区间之间位置的特殊性你必须把空节点都从链表里扔掉。

于是你就做好了。复杂度 $O(M\times \max (len,\ \dfrac{n}{len}))$，取 $len=\sqrt{n}$ 可达最优复杂度，我取的 $len$ 是 $1000$。

tips：封装会好写一点。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+5,inf=0x3f3f3f3f;
struct node{
    int pre,nxt,sz,maxi,mini,minc,num[N<<1];
    inline int lc(){return num[0];}
    inline int rc(){return num[sz-1];}
    inline void maintain(){
        maxi=mini=num[0],minc=inf;
        for(int i(1);i<sz;++i) minc=min(minc,abs(num[i]-num[i-1])),mini=min(mini,num[i]),maxi=max(maxi,num[i]);
    }
    inline void insert(int k,int bfr){
        num[sz++]=k;
        int p(sz-1);
        while(p>bfr) swap(num[p],num[p-1]),--p;
        maintain();
    }
    inline void erase(int k){
        int p(--k);
        while(p<sz) swap(num[p],num[p+1]),++p;
        --sz,maintain();
    }
    inline int query_maxi(int L,int R){
        int res(0);
        for(int i(L);i<=R;++i) res=max(res,num[i]);
        return res;
    }
    inline int query_mini(int L,int R){
        int res(inf);
        for(int i(L);i<=R;++i) res=min(res,num[i]);
        return res;
    }
    inline int query_minc(int L,int R){
        int res(inf);
        for(int i(L+1);i<=R;++i) res=min(res,abs(num[i]-num[i-1]));
        return res;
    }
};
int n,m,x,e,cnt,tot;
node lst[N];
string opt;
inline void split(int pr,int nt,int x){
    lst[pr].nxt=x,lst[nt].pre=x;
    lst[x].pre=pr,lst[x].nxt=nt;
    int mid(lst[pr].sz>>1);
    for(int i(mid);i<lst[pr].sz;++i) lst[x].num[i-mid]=lst[pr].num[i];
    lst[x].sz=lst[pr].sz-mid,lst[pr].sz>>=1;
    lst[pr].maintain(),lst[x].maintain();
}
inline void insert(int k,int bfr){
    if(!cnt){
        lst[++tot].insert(k,bfr),lst[0].pre=lst[0].nxt=tot,lst[tot].pre=lst[tot].nxt=0;
        lst[tot].maxi=lst[tot].mini=k,lst[tot].sz=1,lst[tot].minc=inf,++cnt;
        return;
    }
    int p(lst[0].nxt),cnt(0);
    for(;p;p=lst[p].nxt){
        if(cnt+lst[p].sz>=bfr){
            lst[p].insert(k,bfr-cnt);
            if(lst[p].sz>=2e3) split(p,lst[p].nxt,++tot),++cnt;
            return;
        }
        cnt+=lst[p].sz;
    }
}
inline void merge(int pr,int nt){lst[pr].nxt=nt,lst[nt].pre=pr;}
inline void erase(int x){
    int p(lst[0].nxt),cnt(0);
    for(;p;p=lst[p].nxt){
        if(cnt+lst[p].sz>=x){
            lst[p].erase(x-cnt);
            if(!lst[p].sz) merge(lst[p].pre,lst[p].nxt),--cnt;
            return;
        }
        cnt+=lst[p].sz;
    }
}
inline void chg(int k,int bfr){insert(k,bfr+1),erase(bfr),erase(bfr);}
inline int solve_max(int L,int R){
    --L,--R;
    int maxi(0),mini(inf),p(lst[0].nxt),cnt(0);
    for(;p;p=lst[p].nxt){
        if(cnt<=L&&R<cnt+lst[p].sz){maxi=max(maxi,lst[p].query_maxi(L-cnt,R-cnt)),mini=min(mini,lst[p].query_mini(L-cnt,R-cnt));return maxi-mini;}
        else if(cnt<=L&&L<cnt+lst[p].sz) maxi=max(maxi,lst[p].query_maxi(L-cnt,lst[p].sz-1)),mini=min(mini,lst[p].query_mini(L-cnt,lst[p].sz-1));
        else if(cnt<=R&&R<cnt+lst[p].sz) maxi=max(maxi,lst[p].query_maxi(0,R-cnt)),mini=min(mini,lst[p].query_mini(0,R-cnt));
        else if(L<=cnt&&cnt+lst[p].sz-1<=R) maxi=max(maxi,lst[p].maxi),mini=min(mini,lst[p].mini);
        else if(R<cnt) return maxi-mini;
        cnt+=lst[p].sz;
    }
    return maxi-mini;
}
inline int solve_min(int L,int R){
    --L,--R;
    int minc(inf),p(lst[0].nxt),cnt(0),rc;
    for(;p;p=lst[p].nxt){
        if(cnt<=L&&R<cnt+lst[p].sz){minc=min(minc,lst[p].query_minc(L-cnt,R-cnt));return minc;}
        else if(cnt<=L&&L<cnt+lst[p].sz) minc=min(minc,lst[p].query_minc(L-cnt,lst[p].sz-1)),rc=lst[p].rc();
        else if(cnt<=R&&R<cnt+lst[p].sz){
            minc=min(minc,lst[p].query_minc(0,R-cnt));
            minc=min(minc,abs(rc-lst[p].lc()));
            rc=lst[p].rc();
        }
        else if(L<=cnt&&cnt+lst[p].sz-1<=R){
            minc=min(minc,lst[p].minc);
            minc=min(minc,abs(rc-lst[p].lc()));
            rc=lst[p].rc();
        }
        else if(R<cnt) return minc;
        cnt+=lst[p].sz;
    }
    return minc;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> m;
    for(int i(1);i<=n;++i) cin >> e,insert(e,i-1);
    while(m--){
        cin >> opt >> x >> e;
        if(opt=="merge") chg(e,x);
        else if(opt=="insert") insert(e,x);
        else if(opt=="max") cout << solve_max(x,e) << '\n';
        else cout << solve_min(x,e) << '\n';
    }
    return 0;
}
```

---

## 作者：_LiWenX_ (赞：0)

模拟赛见到了这题，给个非平衡树的根号做法。

让我们看看它的询问到底在干什么。

对于最大极差，对于一个区间，它向外拓展，极差必然不减，所以最大极差必然是 $\max\limits_{i=l}^r a_i-\min\limits_{i=l}^ra_i$，而最小极差便是极小的区间，也就是相邻的两个数 $\min\limits_{i=l+1}^r|a_i-a_{i-1}|$。

那么我们就知道要维护的东西是区间最大，最小，差分数组的最小值了。

序列问题考虑一下分块处理这个插入和删除数字的操作，对于一个块，如果它的大小是 $O(\sqrt n)$ 的，我们可以直接通过重构这个块，来暴力插入一个数字，删除同理，复杂度是 $O(\sqrt n)$。但是如果仅仅是这样，还是错误的，因为我们可以不断向一个块中插入数字，那么它的块场会变成 $O(m)$ 级别。于是我们干这样一个事情：若一个块的大小超过了 $2\sqrt n$，我们将所有序列中的数字拿下来，重新分块。

这样可以保证每次插入和查询的复杂度都是对的，因为你最多有 $\dfrac{m}{\sqrt n}$ 个块，块长 $O(\sqrt n)$。然后分析一下重构的复杂度，每次重构是 $O(n)$ 的，一个块要操作 $\sqrt n$ 次才会被重构，复杂度是 $O(n\dfrac{m}{\sqrt n})$ 的，由于 $O(m)=O(n)$，总复杂度就是 $O(n\sqrt n)$，可以通过。

常数看起来还不错。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,Q;
int a[100001];
int maxn[100001],minn[100001],Min[100001];
vector<int> vec[100001],all;
int t,siz;
void pushall(){
	all.clear();
	for(int i=1;i<=n;i++){
		for(int u:vec[i]) all.push_back(u);
		vec[i].clear();
	}
}
void rebuild(){
	t=0;int pos=1;
	maxn[1]=-1e9,minn[1]=Min[1]=1e9;
	int num=0;
	for(int i=0;i<(int)all.size();i++){
		num++;
		if(num>siz){
			num=1,pos++;
			maxn[pos]=-1e9,minn[pos]=Min[pos]=1e9;
		}
		maxn[pos]=max(maxn[pos],all[i]);
		minn[pos]=min(minn[pos],all[i]);
		vec[pos].push_back(all[i]);
		if(num!=1) Min[pos]=min(Min[pos],abs(all[i]-all[i-1]));
	}t=pos;
}
int askmin(int l,int r){
	int ret=1e9;
	int L=1,R=vec[1].size();
	for(int i=1;i<=t;i++){
		if(i!=1) R+=vec[i].size();
		if(l<=L&&R<=r){
			ret=min(ret,minn[i]);
		}
		else if(L<=l&&r<=R){
			for(int j=l-L;j<=r-L;j++){
				ret=min(ret,vec[i][j]);
			}
		}
		else if(L<=l&&l<=R){
			for(int j=l-L;j<(int)vec[i].size();j++){
				ret=min(ret,vec[i][j]);
			}
		}
		else if(L<=r&&r<=R){
			for(int j=0;j<=r-L;j++){
				ret=min(ret,vec[i][j]);
			}
		}
		L=R+1;
	}return ret;
}
int askmax(int l,int r){
	int ret=-1e9;
	int L=1,R=vec[1].size();
	for(int i=1;i<=t;i++){
		if(i!=1) R+=vec[i].size();
		if(l<=L&&R<=r){
			ret=max(ret,maxn[i]);
		}
		else if(L<=l&&r<=R){
			for(int j=l-L;j<=r-L;j++){
				ret=max(ret,vec[i][j]);
			}
		}
		else if(L<=l&&l<=R){
			for(int j=l-L;j<(int)vec[i].size();j++){
				ret=max(ret,vec[i][j]);
			}
		}
		else if(L<=r&&r<=R){
			for(int j=0;j<=r-L;j++){
				ret=max(ret,vec[i][j]);
			}
		}
		L=R+1;
	}return ret;
}
int ask_j(int l,int r){
	int ret=1e9;
	int L=1,R=vec[1].size();
	for(int i=1;i<=t;i++){
		if(i!=1) R+=vec[i].size();
		if(l<=L&&R<=r){
			ret=min(ret,Min[i]);
			if(L!=l) ret=min(ret,abs(vec[i][0]-vec[i-1][vec[i-1].size()-1]));
		}
		else if(L<=l&&r<=R){
			for(int j=l-L+1;j<=r-L;j++){
				ret=min(ret,abs(vec[i][j]-vec[i][j-1]));
			}
		}
		else if(L<=l&&l<=R){
			for(int j=l-L+1;j<(int)vec[i].size();j++){
				ret=min(ret,abs(vec[i][j]-vec[i][j-1]));
			}
		}
		else if(L<=r&&r<=R){
			for(int j=1;j<=r-L;j++){
				ret=min(ret,abs(vec[i][j]-vec[i][j-1]));
			}
			ret=min(ret,abs(vec[i][0]-vec[i-1][vec[i-1].size()-1]));
		}
		L=R+1;
	}return ret;
}
void insert(int x,int k){
	int L=1,R=vec[1].size();
	for(int i=1;i<=t;i++){
		if(i!=1) R+=vec[i].size();
		if(L<=x&&x<=R+1){
			vector<int> nex;
			for(int j=0;j<x-L;j++) nex.push_back(vec[i][j]);
			nex.push_back(k);
			for(int j=x-L;j<(int)vec[i].size();j++) nex.push_back(vec[i][j]);
			vec[i]=nex;
			maxn[i]=-1e9,minn[i]=Min[i]=1e9;
			for(int j=0;j<(int)vec[i].size();j++){
				maxn[i]=max(maxn[i],vec[i][j]);
				minn[i]=min(minn[i],vec[i][j]);
				if(j) Min[i]=min(Min[i],abs(vec[i][j]-vec[i][j-1]));
			}
			if((int)vec[i].size()==siz*2){
				pushall();
				rebuild();
			}
			break;
		}
		L=R+1;
	}
}
void merge(int x,int k){
	int L=1,R=vec[1].size();
	for(int i=1;i<=t;i++){
		if(i!=1) R+=vec[i].size();
		if(L<=x&&x<=R+1){
			if(x==R+1){
				vector<int> nex;
				for(int j=1;j<vec[i+1].size();j++) nex.push_back(vec[i+1][j]);
				vec[i+1]=nex;
				maxn[i+1]=-1e9,minn[i+1]=Min[i+1]=1e9;
				for(int j=0;j<(int)vec[i+1].size();j++){
					maxn[i+1]=max(maxn[i+1],vec[i+1][j]);
					minn[i+1]=min(minn[i+1],vec[i+1][j]);
					if(j) Min[i+1]=min(Min[i+1],abs(vec[i+1][j]-vec[i+1][j-1]));
				}
			}
			vector<int> nex;
			for(int j=0;j<x-L-1;j++) nex.push_back(vec[i][j]);
			nex.push_back(k);
			for(int j=x-L+1;j<(int)vec[i].size();j++) nex.push_back(vec[i][j]);
			vec[i]=nex;
			maxn[i]=-1e9,minn[i]=Min[i]=1e9;
			for(int j=0;j<(int)vec[i].size();j++){
				maxn[i]=max(maxn[i],vec[i][j]);
				minn[i]=min(minn[i],vec[i][j]);
				if(j) Min[i]=min(Min[i],abs(vec[i][j]-vec[i][j-1]));
			}
			if(!vec[i+1].size()||!vec[i].size()){
				pushall();
				rebuild();
			}
			break;
		}
		L=R+1;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>Q;
	siz=sqrt(n+Q);
	for(int i=1;i<=n;i++){
		cin>>a[i];
		all.push_back(a[i]);
	}
	rebuild();
	while(Q--){
		string op;int l,r,x,k;
		cin>>op;
		if(op=="max"){
			cin>>l>>r;
			cout<<askmax(l,r)-askmin(l,r)<<'\n';
		}
		else if(op=="min"){
			cin>>l>>r;
			cout<<ask_j(l,r)<<'\n';
		}
		else if(op=="insert"){
			cin>>x>>k;x++;
			insert(x,k);
		}
		else{
			cin>>x>>k;x++;
			merge(x,k);
		}
	}
}
```

---

## 作者：_lfxxx_ (赞：0)

### Solution

容易发现 `max` 就是区间的极差，`min` 就是相邻两数之差的最小值。

快速插入一个数和删除一个数容易想到链表，还要支持区间的询问，考虑块状链表。~~其实是不会平衡树~~

设阈值为 $B$。

块状链表其实就是外部结构是链表，里面是顺序表（可以用 `vector<int>` 实现）。我们让里面顺序表大小为 $O(B)$，这样插入删除定位需要 $O(B + \dfrac{n}{B})$。

但大小会随着插入删除变化，有可能不再是 $O(B)$ 的大小了，这时候合并分裂就行了（其实合并可以不做）。

为了能够快速回答询问，每个块里需要维护额外信息。本题中需要维护最大值，最小值以及相邻之差的最小值。

具体来讲，回答询问时先在链表上跳定位，两边的散块暴力扫，之后暴力扫每个块，对于 `min` 询问，记得处理块与块之间相邻的数。该段时间复杂度 $O(B + \dfrac{n}{B})$。

取 $B=\sqrt n$ 时理论复杂度最优，我取的 $B=400$。

### Code

其实有点恶心，需要耐心地调。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define pll pair<ll, ll>
#define all(x) (x).begin(), (x).end()
constexpr int N = 1e5 + 5, B = 400;
int cnt = 1;
struct node {
	vector<int>v;
	int nxt, mx, mn, t;
	node() {
		nxt = 0, mx = 0, mn = INT_MAX, t = INT_MAX;
	}
	inline void init()
	{
		if (v.empty()) return;
		mx = *max_element(all(v));
		mn = *min_element(all(v));
		t = INT_MAX;
		for (int i = 1; i < v.size(); ++i) {
			t = min(t, abs(v[i] - v[i - 1]));
		}
	}
	inline void push(int x)
	{
		mx = max(mx, x);
		mn = min(mn, x);
		if (!v.empty()) t = min(t, abs(x - v.back()));
		v.emplace_back(x);
	}
	inline void push(vector<int>::iterator it, int x)
	{
		mx = max(mx, x);
		mn = min(mn, x);
		v.emplace(it, x);
	}
}a[N];
int getpos(int &x)
{
	int p = 1;
	while (x > a[p].v.size()) {
		x -= a[p].v.size();
		p = a[p].nxt;
	}
	return p;
}
void work(int p)
{
	if (!a[a[p].nxt].nxt) return;
	if (a[p].v.size() + a[a[p].nxt].v.size() <= 1.5 * B) {
		for (int x : a[a[p].nxt].v) {
			a[p].push(x);
		}
		a[p].nxt = a[a[p].nxt].nxt;
	} else if (a[p].v.size() >= 1.5 * B) {
		int q = a[p].v.size() / 2;
		a[++cnt].nxt = a[p].nxt;
		a[p].nxt = cnt;
		for (int i = a[p].v.size() - q; i <= a[p].v.size() - 1; ++i) {
			a[cnt].push(a[p].v[i]);
		}
		while (q--) a[p].v.pop_back();
		a[p].init();
	}	
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) {
		int x;
		cin >> x;
		if (a[cnt].v.size() >= B) a[cnt].nxt = cnt + 1, ++cnt;
		a[cnt].push(x);
	}
	while (m--) {
		string op;
		int x, y;
		cin >> op >> x >> y;
		if (op == "merge") {
			int p = getpos(x);
			a[p].v[x - 1] = y;
			if (x == a[p].v.size()) {
				if (!a[p].nxt) a[p].nxt = ++cnt;
				a[a[p].nxt].v.erase(a[a[p].nxt].v.begin());
				a[a[p].nxt].init();
			} else {
				a[p].v.erase(a[p].v.begin() + x);
			}
			a[p].init();
			work(p);
		} else if (op == "insert") {
			int p = getpos(x);
			if (x == a[p].v.size()) {
				if (!a[p].nxt) a[p].nxt = ++cnt;
				a[a[p].nxt].push(a[a[p].nxt].v.begin(), y);
				a[a[p].nxt].init();
			}
			else {
				a[p].push(a[p].v.begin() + x, y);
				a[p].init();
			}
			work(p);
		} else if (op == "max") {
			int p = getpos(x), q = getpos(y), mx = 0, mn = INT_MAX;
			if (p == q) {
				for (int i = x - 1; i < y; ++i) {
					mx = max(mx, a[p].v[i]);
					mn = min(mn, a[p].v[i]);
				}
			} else {
				for (int i = x - 1; i < a[p].v.size(); ++i) {
					mx = max(mx, a[p].v[i]);
					mn = min(mn, a[p].v[i]);
				}
				for (int i = 0; i < y; ++i) {
					mx = max(mx, a[q].v[i]);
					mn = min(mn, a[q].v[i]);
				}
				p = a[p].nxt;
				for (int i = p; i != q; i = a[i].nxt) {
					mx = max(mx, a[i].mx);
					mn = min(mn, a[i].mn);
				}
			}
			cout << mx - mn << '\n';
		} else {
			int p = getpos(x), q = getpos(y), ans = INT_MAX;
			if (p == q) {
				for (int i = x; i < y; ++i) {
					ans = min(ans, abs(a[p].v[i] - a[p].v[i - 1]));
				}
			} else {
				for (int i = x; i < a[p].v.size(); ++i) {
					ans = min(ans, abs(a[p].v[i] - a[p].v[i - 1]));
				}
				for (int i = 1; i < y; ++i) {
					ans = min(ans, abs(a[q].v[i] - a[q].v[i - 1]));
				}
				for (int i = p; i != q; i = a[i].nxt) {
					ans = min(ans, abs(a[i].v.back() - *a[a[i].nxt].v.begin()));
					if (i != p) ans = min(ans, a[i].t);
				}
			}
			cout << ans << '\n';
		}
	}
	return 0;
}


```

---

## 作者：takanashi_mifuru (赞：0)

第一眼是很裸的 Splay，实际上还真是。

合并就是把 $a_x$ 和 $a_{x+1}$ 删除，并在他们中间插入 $e$。

插入就是直接插入。

我们考虑区间中的任意子区间的极差的最大值一定是整个区间的极差。

而最小值一定是相邻两个数的差的绝对值。

前面那个东西就是板子，后面那个东西，考虑维护一棵新的平衡树，里面的点就是每个点和他后继的绝对值的差值，然后每次插入啊，删除啊，都是删原来的后继之间的差值并加新的后继之间的差值。

然后就是很裸的题了。

---

## 作者：黑影洞人 (赞：0)

题意：
>给你一个序列，要求插入，删除，求给定区间内任意子区间极差的最大最小值。

很显然可以使用文艺平衡树进行维护，重点在维护任意区间极差的最大最小值。

最大值，对于一个区间的任意自区间极差最大值肯定是最大值减去最小值。

最小值，最小极差一定存在于长度为 $2$ 的区间

证明：

>若存在长度区间 $[a,a+2]$ 的极差 $δ$ ，由定义得，
$δ=\max([a,a+2])-\min([a,a+2])=\max([a,a+1],[a+2])-\min([a,a+1],[a+2])\ge δ[a,a+1]$
通俗来讲，就是一个大区间的最大值一定大于等于小区间的最大值，一个大区间的最小值一定小于等于一个小区间的最小值，因此区间越小极差尽可能小，最小极差一定出现在长度为 $2$ 的子区间内。

于是我们只需要维护一个节点子树区间的左端点和右端点，然后维护最小相邻数的差即可。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define int long long 
#define N 414514
#define inf 2147483647
using namespace std;
int seed,md=19260817;
void _srand(int x){seed=x;}
int _rand(){seed=(seed*7+13)%md;return seed;}
int n,m,rt; 
struct fhq_treap{
	int ch[N][2],rnd[N],siz[N],val[N],mnd[N],mx[N],mn[N];
	int ld[N],rd[N];
	int tot;
	fhq_treap(){
		mnd[0]=inf;
		mn[0]=inf;
		ld[0]=inf,rd[0]=inf;
	}
	#define lc ch[x][0]
	#define rc ch[x][1]
	int pushup(int x){
		siz[x]=siz[lc]+siz[rc]+1;
		mx[x]=max(max(mx[lc],mx[rc]),val[x]);
		mn[x]=min(min(mn[lc],mn[rc]),val[x]);
		ld[x]=lc?ld[lc]:val[x];
		rd[x]=rc?rd[rc]:val[x];
		mnd[x]=min(min(mnd[lc],mnd[rc]),min(abs(rd[lc]-val[x]),abs(ld[rc]-val[x])));
		return x;
	}
	void split(int p,int k,int &x,int &y){
		if(!p)return void(x=y=0);
		if(k>siz[ch[p][0]])split(ch[x=p][1],k-siz[ch[p][0]]-1,ch[p][1],y);
		else split(ch[y=p][0],k,x,ch[p][0]);
		pushup(p);
	}
	int merge(int x,int y){
		if(!x||!y)return x+y;
		if(rnd[x]<=rnd[y]){rc=merge(rc,y);return pushup(x);}
		else{ch[y][0]=merge(x,ch[y][0]);return pushup(y);}
	}
	int newnode(int v){
		int x=++tot;
		val[x]=v;rnd[x]=_rand();
		mx[x]=v,mn[x]=v;
		siz[x]=1;mnd[x]=inf;
		ld[x]=v,rd[x]=v;
		return x;
	}
	void build(int n){
		for(int i=1;i<=n;i++){
			int a;
			scanf("%lld",&a);
			rt=merge(rt,newnode(a));
		}
	}
}t;
signed main(){
	_srand(676767);
	scanf("%lld%lld",&n,&m);
	t.build(n);
	while(m--){
		char s[10];
		int x,y;
		scanf("%s%lld%lld",s,&x,&y);
		if(s[1]=='e'){
			int a,b,c,d;
			t.split(rt,x-1,a,b);
			t.split(b,2,c,d);
			rt=t.merge(a,t.merge(t.newnode(y),d));
		}else if(s[1]=='n'){
			int a,b,c,d;
			t.split(rt,x,a,b);
			rt=t.merge(a,t.merge(t.newnode(y),b));
		}else if(s[1]=='a'){
			int a,b,c,d;
			t.split(rt,y,a,b);
			t.split(a,x-1,c,d);
			printf("%lld\n",t.mx[d]-t.mn[d]);
			rt=t.merge(t.merge(c,d),b);
		}else{
			int a,b,c,d;
			t.split(rt,y,a,b);
			t.split(a,x-1,c,d);
			printf("%lld\n",t.mnd[d]);
			rt=t.merge(t.merge(c,d),b);
		}
	}
	return 0;
}


```


---


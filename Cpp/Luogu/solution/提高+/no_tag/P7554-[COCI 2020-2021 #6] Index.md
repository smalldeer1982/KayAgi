# [COCI 2020/2021 #6] Index

## 题目描述

「H 指数」可以衡量学者论文的数量与引用量。一位学者的「H 指数」为最大的整数 $h$，满足他至少有 $h$ 篇论文被引用了不少于 $h$ 次。

Mirko 一共发表了 $n$ 篇论文，而他有 $q$ 个疑问：如果他只发表了第 $l_i$ 篇至第 $r_i$ 篇论文，他的「H 指数」会是多少？

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试**。

| Subtask | 分值 | 数据规模与约定 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $1 \le n, q \le 10^3$ |
| $2$ | $40$ | $1 \le n, q \le 5 \times 10^4$ |
| $3$ | $50$ | 无附加约定 |

对于 $100\%$ 的数据，$1 \le n, q \le 2 \times 10^5$，$1 \le p_i \le 2 \times 10^5$，$1 \le l_i \le r_i \le n$。

------------

#### 说明

**本题分值按 COCI 原题设置，满分 $110$**。

**题目译自 [COCI2020-2021](https://hsin.hr/coci/archive/2020_2021/) [CONTEST #6](https://hsin.hr/coci/archive/2020_2021/contest6_tasks.pdf) _T5 Index_**。

## 样例 #1

### 输入

```
7 6
3 2 3 1 1 4 7
3 4
1 7
1 6
4 5
1 2
5 7```

### 输出

```
1
3
3
1
2
2```

# 题解

## 作者：一扶苏一 (赞：7)

## Analysis

看到最值问题，考虑二分答案。

如果只有一组询问，显然可以直接二分答案 $h$，然后在树状数组上把所有不小于 $h$ 的点都 +1，然后查询区间和是否不小于 $h$。

对于多组询问，直接把询问放在一起二分即可，即整体二分。设当前递归区间为 $[l, r]$，则把 $(mid, r]$ 内的点加入树状数组，查询答案在当前区间内的询问中哪些区间和大于 $mid$，向右子树递归，剩余的向左子树递归。

需要注意的是，这里因为查询的是最小合法的 $h$，所以在树状数组上插入的时候要插入大于 $mid$ 的点，并且向右递归的判断应该写成 `check() >= (mid + 1)` 而不是 `check() > mid`。

时间复杂度 $O(q \log n \log q)$。

## Code

```cpp
namespace Fusu {

const int maxn = 200005;

int n, q;
int p[maxn], ll[maxn], rr[maxn], ans[maxn];
std::vector<int> pp[maxn];

struct BIT {
  int aa[maxn];
  
  inline int lowbit(const int &x) { return x & -x; }
  void upd(int x, int y) { do aa[x] += y; while ((x += lowbit(x)) <= n); }
  int qry(int x) { int ret = 0; do ret += aa[x]; while (x -= lowbit(x)); return ret; }
};
BIT bt;

void solve(const int l, const int r, const std::vector<std::pair<int, int> > &Q);

void Main() {
  qr(n); qr(q);
  qra(p + 1, n);
  for (int i = 1; i <= n; ++i) pp[p[i]].push_back(i);
  std::vector<std::pair<int, int> > tmp;
  for (int i = 1; i <= q; ++i) {
    qr(ll[i]); qr(rr[i]);
    tmp.push_back({i, 0});
  }
  solve(1, n, tmp);
  qwa(ans + 1, q, '\n', '\n');
}

void solve(const int l, const int r, const std::vector<std::pair<int, int> > &Q) {
  if (l == r) {
    for (auto u : Q) ans[u.first] = l;
    return;
  }
  int mid = (l + r) >> 1;
  std::vector<std::pair<int, int> > lft, rt;
  for (int i = mid + 1; i <= r; ++i) {
    for (auto u : pp[i]) bt.upd(u, 1);
  }
  for (auto u : Q) {
    if (bt.qry(rr[u.first]) - bt.qry(ll[u.first] - 1) + u.second >= (mid + 1)) {
      rt.push_back(u);
    } else {
      lft.push_back({u.first, u.second + bt.qry(rr[u.first]) - bt.qry(ll[u.first] - 1)});
    }
  }
  for (int i = mid + 1; i <= r; ++i) {
    for (auto u : pp[i]) bt.upd(u, -1);
  }
  solve(l, mid, lft); solve(mid + 1, r, rt);
}

} // namespace Fusu
```



---

## 作者：gyh20 (赞：7)

我们发现若 $h$ 合法，则 $h-1$ 合法，可以考虑二分。

判断一个数是否合法可以直接主席树。

直接在主席树上二分即可做到 $O(n\log n)$ 的复杂度。

```cpp
#include<cstdio>
#define re register
using namespace std;
int n,sz[4000002],rt[200002],ls[4000002],rs[4000002],q,tot;
inline void add(re int &p,re int q,re int l,re int r,re int x){
	p=++tot,sz[p]=sz[q]+1;
	if(l==r)return;
	re int mid=l+r>>1;
	if(x<=mid)rs[p]=rs[q],add(ls[p],ls[q],l,mid,x);
	else ls[p]=ls[q],add(rs[p],rs[q],mid+1,r,x);
}
inline int find(re int p,re int q,re int l,re int r,re int x){
	if(l==r)return l;
	re int mid=l+r>>1;
	if(x+sz[rs[p]]-sz[rs[q]]>mid)return find(rs[p],rs[q],mid+1,r,x);
	return find(ls[p],ls[q],l,mid,x+sz[rs[p]]-sz[rs[q]]);
}
signed main(){
    scanf("%d%d",&n,&q);
	for(re int i=1,x;i<=n;++i)scanf("%d",&x),add(rt[i],rt[i-1],1,n,x);
	while(q--){
		re int l,r;scanf("%d%d",&l,&r);
		printf("%d\n",find(rt[r],rt[l-1],1,n,0));
	}
}
```


---

## 作者：钰瑾_恋涵 (赞：6)

### 前置知识：[普通莫队](https://dpair.gitee.io/articles/mo/)

------

#### 前言：

熟悉的区间询问，熟悉的数据范围。嗯？好！上莫队！

由于本人做这道题时是初学莫队，根本不知道还有值域分块这种东西，~~好像所有的莫队都可值域分块~~，其他大佬的题解里要么用了主席树和整体二分 ( 蒟蒻太弱啦，根本不会！) ，要么都是值域分块莫队，所以这里给出一种普通莫队的做法。

------

想要 $\Theta  (1)$  转移当前答案看起来不太可做，但我们考虑答案在什么情况才会改变。

* k 表当前答案，sum 表后缀和。

1. 当 sum[k+1] > k  ：k + 1 。

2. 当 sum[k] < k  :  k - 1 。

根据这两个性质，我们可以开一个桶维护每个数的出现次数，再用一个数维护大于等于 k 的数有多少个。在每次增 / 删数时检查是否需要更改答案就行了。~~在每次询问结束后更新答案也行。~~

然后就做到 $\Theta(1)$ 转移和查询答案啦！

最后附上代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int read() {
	int x=0; char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x;
}
void put(int x) {
	if(x>=10) put(x/10);
	putchar(x%10^48);
}
const int Maxn=2e5+10;
int n,q,unit,a[Maxn],cnt[Maxn],ans[Maxn];
struct node {
	int l,r,id;
	bool operator<(const node &b) const {
		if(l/unit!=b.l/unit) return l<b.l;
		return l/unit&1?r<b.r:r>b.r;
	}
} ask[Maxn];
signed main() {
	n=read(),q=read(),unit=sqrt(n);
	for(register int i=1; i<=n; ++i) a[i]=read();
	for(register int i=1; i<=q; ++i) ask[i].l=read(),ask[i].r=read(),ask[i].id=i;
	sort(ask+1,ask+q+1);
	register int l=ask[1].l,r=ask[1].l-1,k=0,t=0;
	for(register int i=1; i<=q; ++i) {
		while(l>ask[i].l) ++cnt[a[--l]],t+=(a[l]>=k);
		while(r<ask[i].r) ++cnt[a[++r]],t+=(a[r]>=k);
		while(l<ask[i].l) t-=(a[l]>=k),--cnt[a[l++]];
		while(r>ask[i].r) t-=(a[r]>=k),--cnt[a[r--]];
		while(t-cnt[k]>k) t-=cnt[k++];
		while(t<k) t+=cnt[--k]; 
		ans[ask[i].id]=k;
	}
	for(register int i=1;i<=q;++i) put(ans[i]),putchar('\n');
	return 0;
}
```

---

## 作者：Broken_Heart (赞：5)

[P7554 Index](https://www.luogu.com.cn/problem/P7554)

居然没有线段树合并的题解？
### 先考虑暴力
我们先考虑最基础的暴力，很容易想到对每个 $p_i$ 用一前缀和数组 $f_{i,j}$ 表示 $1$ 到 $j$ 中大于等于 $i$ 的数的个数，通过 $f_{i,r}-f_{i,l-1}$ 即可求出 $l$ 到 $r$ 中大于等于 $i$ 的个数，此处效率为 $O(n^2)$，然后对每次询问从 $1$ 到 $n$ 二分查找，效率 $O(q\log{n})$。
### 优化
但显然我们的空间和时间都不允许我们进行 $O(n^2)$ 的前缀和预处理，所以我们需要进行优化，注意到我们在每次处理前缀和的时候有大量操作是重复的，因为大于等于 $p_{i+1}$ 的也大于 $p_i$，所以我们想将 $p_{i+1}$ 到 $p_{n}$ 的状态直接继承给 $p_i$，所以很容易想到对每一个 $p_{i}$ 开一个线段树，然后用线段树合并将 $p_{i+1}$ 的信息转移到 $p_i$ 即可，因为 $p_{i+1}$ 的线段树也是由 $p_{i+2}$ 得来的，所以包含了所有比 $p_{i}$ 大的信息，此时我们的线段树也不用去维护前缀和，直接用普通动态开点线段树即可，询问时查找  $p_{i}$ 线段树 $l$ 到 $r$ 的数量即可，效率为 $O(q\log{n}\log{n})$，很简单。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;
const int N=200010;
int n,q,cnt,rt[N];
vector<int>v[N];
int lch[N<<5],rch[N<<5],tag[N<<5];
int ls(int u){
	if(!lch[u]) lch[u]=++cnt;
	return lch[u];
}
int rs(int u){
	if(!rch[u]) rch[u]=++cnt;
	return rch[u];
}
void push_up(int u){
	tag[u]=tag[lch[u]]+tag[rch[u]];
}
void add(int u,int l,int r,int x){
	if(l==r){
		tag[u]=1;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid) add(ls(u),l,mid,x);
	else add(rs(u),mid+1,r,x);
	push_up(u);
}
int merge(int x,int y,int l,int r){
	if(!x||!y) return x|y;
	if(l==r){
		tag[x]=1;
		return x;
	}
	int mid=(l+r)>>1;
	lch[x]=merge(lch[x],lch[y],l,mid);
	rch[x]=merge(rch[x],rch[y],mid+1,r);
	push_up(x);
	return x;
}
int query(int u,int l,int r,int l1,int r1){
	if(!u) return 0;
	if(l1<=l&&r<=r1) return tag[u];
	int mid=(l+r)>>1,sum=0;
	if(l1<=mid) sum+=query(lch[u],l,mid,l1,r1);
	if(mid+1<=r1) sum+=query(rch[u],mid+1,r,l1,r1);
	return sum;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n>>q;
	for(int i=1,x;i<=n;i++) {
		cin>>x;
		v[x].emplace_back(i);//用vector存每个值的位置
	}
	for(int i=n;i>=1;i--){
		rt[i]=++cnt;
		for(int j:v[i]){
			add(rt[i],1,n,j);
		}
		rt[i]=merge(rt[i],rt[i+1],1,n);//线段树合并
	}
	int l,r,mid,x,y,k;
	while(q--){
		cin>>x>>y;
		l=1;r=n;
		while(l<r){//二分
			mid=(l+r+1)>>1;
			k=query(rt[mid],1,n,x,y);
			if(k>=mid) l=mid;
			else r=mid-1;
		}
		cout<<l<<'\n';
	}
	return 0;
}

```


---

## 作者：Gmt丶FFF (赞：4)

可以很容易的想到莫队。

处理询问首先可以想到二分后缀和来处理，但是很明显，莫队不能处理后缀和，所以利用值域分块，修改直接修改单点值与区间的总值，查询直接从后往前查询，查到第一个块的左端点符合条件，那么最大符合条件的值一定在这个块内，块内再枚举即可，修改为 $O(1)$，查询为 $O(\sqrt n)$，总复杂度为 $O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
ifstream is("yy.in",ios::in);
ofstream os("yy.out",ios::out);
#define cin is
#define cout os

const int N=2e5+5;
const int K=447;
int n,T,a[N],p[N],t[N],t2[K+5],L[K+5],R[K+5],b[N],res[N];
struct node
{
	int name,l,r;
}q[N];
inline bool cmp(node x,node y)
{
	if(p[x.l]==p[y.l])
	{
		if(p[x.l]&1)return x.r>y.r;
		return x.r<y.r;
	}
	return x.l<y.l;
}
inline void add(int x)
{
//	cout<<x<<" ? "<<a[x]<<endl;
	++t[a[x]];
	++t2[b[a[x]]];
}
inline void del(int x)
{
//	cout<<x<<" "<<a[x]<<" !\n";
//cout<<x<<" "<<a[x]<<" "<<b[a[x]]<<endl;
	--t[a[x]];
	--t2[b[a[x]]];
}
inline int max(int x,int y)
{
	return x>y?x:y;
}
inline int min(int x,int y)
{
	return x<y?x:y;
}
inline int getans()
{
	int sum=0,ans=0;
	for(int i=b[N-5];i>=1;i--)
	{
		sum+=t2[i];
//		if(i==1)cout<<sum<<" ?|ASF\n"<<L[i]<<" "<<R[i]<<endl;
		if(sum>=L[i])
		{
			for(int j=L[i];j<=R[i];j=-~j)
			{
				if(sum<j)break;
				ans=j;
				sum-=t[j];
			}
			return ans;
		}
	}
	return ans;
}
int main()
{
//	freopen("yy.in","r",stdin);
//	freopen("yy.out","w",stdout);
	cin>>n>>T;
	for(int i=1;i<=n;i=-~i)cin>>a[i],p[i]=i/K;
	for(int i=1;i<=N-5;i=-~i)b[i]=(i/K)+1;
	for(int i=1;i<=b[N-5];i=-~i)L[i]=max(1,(i-1)*K),R[i]=min(N-5,i*K-1);
	for(int i=1;i<=T;i=-~i)cin>>q[i].l>>q[i].r,q[i].name=i;
	sort(q+1,q+1+T,cmp);
	int l=1,r=0;
//	return 0;
	for(int i=1;i<=T;i=-~i)
	{
		while(r<q[i].r)add(++r);
		while(l>q[i].l)add(--l);
		while(l<q[i].l)del(l++);
		while(r>q[i].r)del(r--);
		res[q[i].name]=getans();
//		cout<<q[i].name<<" "<<l<<" "<<r<<"\n";
//		for(int j=1;j<=n;j++)cout<<t[j]<<" ";
//		cout<<endl;
	}
	for(int i=1;i<=T;i=-~i)cout<<res[i]<<'\n';
	return 0;
}
```


---

## 作者：摸鱼酱 (赞：3)

首先有满足题意的 $h$ 是一段前缀，我们要找到最后那个位置。

所以只有询问，不难想到使用莫队。由于插入和查询的次数不对等，所以可以再对值域分块，插入 $O(1)$，查询一次答案 $O(\sqrt n)$。

实现的时候就维护每个值上的元素个数以及每个值域块内的元素个数，查询先扫大块，找到一个块使得它左端点满足题意就从这个块右边暴力扫即可。

时间复杂度 $O(n\sqrt n)$。

[code](https://www.luogu.com.cn/paste/gzpz2v2d)



---

## 作者：Judgelight (赞：1)

[传送门](https://www.luogu.com.cn/problem/P7554)

---

考虑如果有 $h_1\le h_2$ 且 $h_2$ 是满足题目要求的，则 $p_i$ 大于等于 $h_2$ 的至少有 $h_2$ 个，则 $p_i$ 大于等于 $h_1$ 的也至少有 $h_2$ 个，则 $h_1$ 也合法。总而言之，答案具有单调性。

可以直接二分判断，复杂度是两个 $\log$，但是可以直接在主席树上做二分。

```cpp
int query(int x,int y,int l,int r,int s){
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(tr[tr[y].r].sum-tr[tr[x].r].sum+s>mid)return query(tr[x].r,tr[y].r,mid+1,r,s);
	else return query(tr[x].l,tr[y].l,l,mid,s+tr[tr[y].r].sum-tr[tr[x].r].sum);
}
```

---

## 作者：_lfxxx_ (赞：1)

这个题意说白了就是找最大的 $h$ 满足区间中 $\ge h$ 的数的个数 $\ge h$。 

这个问题有单调性，我们考虑二分，二分一个数 $lim$ 每次看 $\ge lim$ 的数的个数是不是 $\ge$ $lim$。

判断是否合法可以用主席树，由于线段树本身的特性，我们可以直接像求区间第 $k$ 大那样在主席树上二分，时间复杂度和空间复杂度均为 $O(n \log n)$。

```cpp
struct node;
inline node*New();
struct node
{
	int v;
	node *ls, *rs;
	void build(int l = 1, int r = mx)
	{
		if (l == r) return;
		int mid = l + r >> 1;
		(ls = New()) -> build(l, mid);
		(rs = New()) -> build(mid + 1, r);
	}
	void insert(node *p, int x, int l = 1, int r = mx)
	{
		v = p -> v + 1;
		if (l == r) return;
		int mid = l + r >> 1;
		if (x <= mid) {
			rs = p -> rs;
			(ls = New()) -> insert(p -> ls, x, l, mid);
		}
		else{
			ls = p -> ls;
			(rs = New()) -> insert(p -> rs, x, mid + 1, r);
		}
	}
}*r[N], mem[N * 21];
inline node*New()
{
	return &mem[tot++];
}
int query(node *L, node *R, int d = 0, int l = 1, int r = mx)
{
	if (l == r) return l;
	int mid = l + r >> 1;
	if (R -> rs -> v - L -> rs -> v + d >= mid + 1) return query(L -> rs, R -> rs, d, mid + 1, r);
	else return query(L -> ls, R -> ls, R -> rs -> v - L -> rs -> v + d, l, mid);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int q, L ,R;
    cin >> n >> q;
    for (int i = 1; i <= n; ++i)
    	cin >> a[i];
    mx = *max_element(a + 1, a + 1 + n);
    (r[0] = New()) -> build();
    for (int i = 1; i <= n; ++i) 
    	(r[i] = New()) -> insert(r[i - 1], a[i]);
	while (q--) {
		cin >> L >> R;
		cout << query(r[L - 1], r[R]) << '\n';
	}
	return 0;
}
```

---

## 作者：BetterGodPig (赞：1)

#### Update on 2023.10.23 删除中文标点符号与英文、数字、公式或汉字之间的空格。

### Index

首先观察到答案具有单调性，所以考虑二分答案。

很容易想到下界是 $0$，而上界是区间长度 $r-l+1$，同时有很容易写出暴力的 `check` 函数，即判断区间内大于等于 `mid` 的数个数是否足够。

考虑优化 `check` 的部分，直接查询区间内第 `mid` 大的数，判断其与 `mid` 的大小关系。

所以考虑主席树维护序列，查询区间第 `k` 大。

总复杂度 $O(q \log^2 n)$，数据范围 $1 \le n,q \le {10}^{5}$ 可以通过， ~~但是不知道为什么最开始寄了er~~ 。

`code`

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;
ifstream is("yy.in",ios::in);
ofstream os("yy.out",ios::out);
#define cin is
#define cout os
const int maxn = 2e5+5;
int n,q;
int a[maxn];
int tot,root[maxn],zxs[maxn];
struct num{
	int a,b,cnt;
}nm[maxn];
struct tree{
	int ls,rs,sum;
}T[maxn<<5];
bool cmp(const num &a,const num &b){return a.a < b.a;}
bool cmp2(const num &a,const num &b){return a.cnt < b.cnt;}
int upd(int pre,int l,int r,int val){
	int rt = ++tot;
	T[rt].ls = T[pre].ls;
	T[rt].rs = T[pre].rs;
	T[rt].sum = T[pre].sum+1;
	register int mid = (l+r)>>1;
	if(l < r){
		if(val <= mid)T[rt].ls = upd(T[pre].ls,l,mid,val);
		else T[rt].rs = upd(T[pre].rs,mid+1,r,val);
	}
	return rt;
}
int query(int u,int v,int l,int r,int k){
	if(l == r)return l;
	int x = T[T[v].ls].sum-T[T[u].ls].sum;
	int mid = (l+r)>>1;
	if(x >= k)return query(T[u].ls,T[v].ls,l,mid,k);
	else return query(T[u].rs,T[v].rs,mid+1,r,k-x);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int st = clock();
	cin>>n>>q;
	for(register int i(1);i <= n;++i){
		cin>>nm[i].a;
		nm[i].cnt = i;
	}
	sort(nm+1,nm+n+1,cmp);
	register int tmp = 0;
	for(register int i(1);i <= n;++i){
		if(nm[i].a > nm[i-1].a || i == 1) nm[i].b = ++tmp;
		else nm[i].b = nm[i-1].b;
		zxs[nm[i].b] = nm[i].a;
	}
	sort(nm+1,nm+n+1,cmp2);
	for(register int i(1);i <= n;++i){
		root[i] = upd(root[i-1],1,tmp,nm[i].b);
	}
	while(q--){
		register int l,r;
		cin>>l>>r;
		register int L = 0,R = r-l+1,ans;
		while(L <= R){
			int mid = (L+R)>>1;
			register int op = query(root[l-1],root[r],1,tmp,r-l-mid+2);
			if(zxs[op] >= mid){
				ans = mid,L = mid+1;
			}else{
				R = mid-1;
			}
		}
		cout<<ans<<endl;
	}
	int ed = clock();
	cerr<<ed-st;
	exit(0);
}
```

---

## 作者：LCat90 (赞：1)

将命题转化一下，即：大于等于 $x$ 的元素数量大于等于 $x$ 个。

容易发现这玩意有单调性。因为当 $x$ 增大时，选取范围变小，满足条件的数变小；而命题的要求满足条件的数变大。故当 $x$ 不满足条件时，$x+1$ 一定不满足条件。所以我们直接二分，来找到这个最大的 $x$。

问题转换成了求区间内大于 $x$ 的元素个数，可以使用可持久化权值线段树维护。

```cpp
#include <bits/stdc++.h>
#define pb push_back
using namespace std;
const int N = 1e7 + 5;
int n, a[N], Root[N], cnt, q;
vector <int> G[N];
struct node {
	int l, r, ls, rs, sum;
} T[N];
void pushup(int p) { T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum; }
int build(int l, int r) {
	int p = ++cnt; T[p].l = l, T[p].r = r;
	if(l == r) {
		T[p].sum = 0;
		return p;
	}
	int mid = l + r >> 1;
	T[p].ls = build(l, mid);
	T[p].rs = build(mid + 1, r);
	pushup(p);
	return p;
}
int Newnode(int x) {
	T[++cnt] = T[x];
	return cnt;
}
int update(int rt, int x, int y) {
	rt = Newnode(rt);
	if(T[rt].l == T[rt].r and T[rt].l == x) {
		T[rt].sum += y;
		return rt;
	}
	int mid = T[rt].l + T[rt].r >> 1;
	if(x <= mid) T[rt].ls = update(T[rt].ls, x, y);
	else T[rt].rs = update(T[rt].rs, x, y);
	pushup(rt);
	return rt;
}
int b[N];
int query(int x1, int x2, int l, int r) {
	if(T[x1].l >= l and T[x1].r <= r) return T[x1].sum - T[x2].sum;
	int mid = T[x1].l + T[x1].r >> 1, ans = 0;
	if(mid >= l) ans += query(T[x1].ls, T[x2].ls, l, r);
	if(mid < r) ans += query(T[x1].rs, T[x2].rs, l, r);
	return ans;
} 
signed main() {
	cin >> n >> q;
	for(int i = 1;i <= n; ++i) cin >> a[i];
	Root[0] = build(1, n);
	for(int i = 1;i <= n; ++i) Root[i] = update(Root[i - 1], a[i], 1);
//	cout << query(Root[7], Root[0], 5, 7);
//	return 0;
	while(q--) {
		int x, y;
		scanf("%d %d", &x, &y);
		int l = 1, r = n;
		while(l < r) {
			int mid = l + r + 1 >> 1;
			if(query(Root[y], Root[x - 1], mid, n) >= mid) l = mid;
			else r = mid - 1;
		}
		printf("%d\n", l);
//		return 0;
	}
	return 0;
}
/*
2 2     2
5 5
*/
```

---

## 作者：Foreverxxx (赞：0)

一个普通莫队的做法，思想是值域分块，但是只需要一个普通莫队。

### 思路

想到莫队等算法，但是并不能直接使用莫队，所以我们不妨想想根号带来的一些优势。

题目给出的问题启发我们，在一个长度为 $\sqrt{n}$ 的块中，如果我们以上一个询问的答案为基础进行转移，转移消耗的时间一定是 $O(\sqrt{n})$ 范围的，所以我们只需要一个普通的莫队，开一个桶记录每个数出现的次数，最后从上一个答案进行暴力的枚举转移即可。

具体而言，我们需要用一个桶记录每个数出现的次数，然后用一个数记录一下大于等于 $lastans$ 的数量，最后两个 ``while`` 循环枚举判断现在的答案即可，具体细节详见代码。

时间复杂度 $O(n \sqrt{n})$。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,q,block=0,ans=0;
int a[200005];
int cnt[200005];
int anss[200005];
struct node{
	int l,r,id;
}ask[200005];
bool cmp(const node& x,const node& y){//普通莫队基本的分块 
	if(x.l/block==y.l/block) return x.r<y.r;
	return x.l<y.l;
}
int main(){
	n=read(),q=read(); 
	block=sqrt(n);
	for(register int i=1;i<=n;i++) a[i]=read();
	for(register int i=1;i<=q;i++){
		ask[i].l=read(),ask[i].r=read();
		ask[i].id=i;
	}
	sort(ask+1,ask+q+1,cmp);
	int l=ask[1].l,r=l-1;//初始化l,r 
	int tmp=0;//单点修改，没有问题 
	for(register int i=1;i<=q;i++){
		//莫队移动边界更新tmp值 
		while(l<ask[i].l){
			tmp-=(a[l]>=ans);
			cnt[a[l++]]--;
		}
		while(l>ask[i].l){
			cnt[a[--l]]++;
			tmp+=(a[l]>=ans);
		}
		while(r>ask[i].r){
			tmp-=(a[r]>=ans);
			cnt[a[r--]]--;
		}
		while(r<ask[i].r){
			cnt[a[++r]]++;
			tmp+=(a[r]>=ans);
		}
		//接下来进行对答案的暴力的枚举 
		while(tmp-cnt[ans]>ans) tmp-=cnt[ans++];
		while(tmp<ans) tmp+=cnt[--ans]; 
		anss[ask[i].id]=ans;
	}
	for(register int i=1;i<=q;i++) cout<<anss[i]<<"\n";
	return 0;
}
```

---

## 作者：BigJoker (赞：0)

# 1.前言

一道数据结构好题，不看题解之前能想出来思路对自己的数据结构提升水平会大大提升。

# 2.看题解前

由于打这个题之前打过一遍 Treap，又看到是一个只有查询的题，又看到了最值 $h$。

因此第一感是个：

莫队+Treap+二分（$O(n\sqrt{n}\log n)$）。

氧化钙，好牛马的复杂度，空间也很假，还不好实现。。。

# 3.看题解后

~~我小心翼翼~~打开了题解区，值域分块+莫队。大悟的感觉。

然后打了很久。发现过不了样例，跟 @Others 神犇的题解对比了一下找了一下问题，一会儿就调出来了。

~~下次一定不ctj~~

# 4.思路

很显然，一眼莫队。

这个序列给的就是次数，所以说不用想就知道莫队维护的肯定也是次数。（数据范围也给了的）

根据以前打莫队的经验。维护一个次数的桶。

好，板子对吧，打完了，然后呢？怎么维护答案呢？

明显直接枚举便失去了时间复杂度优势，考虑加入值域分块。

不懂值域分块的可以百度一下，就是分块维护的是值域。

值域分块明显维护的便是次数的一个值域，块长取根号即可。

然后我们枚举的时候直接枚举从大到小每个值域分块的块，那么这个块满足条件的情况是什么呢？

我们假设这个块值域的最左端点为 $L_i$，这个块的值是 $cnt_i$，以前已经有 $s$ 这么多块内值了。

那么只有满足：

$$L_i\le s+cnt_i$$


（这个看着有点雾，画一下样例应该能懂，也就相当于把题面的式子换了一下）。

答案才会在这个块里，然后如果满足，直接在块内暴力查找即可，就不用细讲了，原理和上述差不多。

总的复杂度显然是 $O(n\sqrt{n})$ 的。

~~当然有哪里写得有问题或者没有怎么看懂的，也可以私信我。~~

# 5.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
const int M=2e5+5;
const int K=2e5+5;
int n,m,lenn,lenk;
int a[N],idx[N],idk[K];
int cnt[1005],t[K],kl[1005],kr[1005];
int ans[M];
struct Q{
	int l,r,k;
}q[M];
bool cmp(Q x,Q y){
	return idx[x.l]==idx[y.l]?x.r<y.r:idx[x.l]<idx[y.l];
}
void add(int x){
	cnt[idk[x]]++;
	t[x]++;
}
void sub(int x){
	cnt[idk[x]]--;
	t[x]--;
}
int Ans(){
	int res=0;
	for(int i=idk[200000];i>=1;i--){
		if(res+cnt[i]>=kl[i]){
			for(int j=kr[i];j>=kl[i];j--){
				if(res+t[j]>=j) return j;
				res+=t[j];
			}
		}
		res+=cnt[i]; 
	}
	return res;
}
int main(){
	scanf("%d %d",&n,&m);
	lenn=sqrt(n);
	lenk=sqrt(200000);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d %d",&q[i].l,&q[i].r),q[i].k=i,idx[i]=(i+lenn-1)/lenn;
	for(int i=1;i<=200000;i++) idk[i]=(i+lenk-1)/lenk;
	for(int i=1;i<=200000;i++) if(!kl[idk[i]]) kl[idk[i]]=i;
	for(int i=200000;i>=1;i--) if(!kr[idk[i]]) kr[idk[i]]=i;
	sort(q+1,q+1+m,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(q[i].l<l) add(a[--l]);
		while(q[i].l>l) sub(a[l++]);
		while(q[i].r<r) sub(a[r--]);
		while(q[i].r>r) add(a[++r]);
		ans[q[i].k]=Ans();
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
} 
```

---

## 作者：Others (赞：0)

这题挺经典的值域分块和莫队平衡复杂度题。

# Solution

首先跳莫队是没有疑问的，我就来讲讲如何处理最后一步。

首先我们选论文肯定从大到小选，答案就是选的论文中最小的引用量（$h$）和总的选择的论文数量（$s$）的 `min`，因为是从大到小，所以在“理想情况下”一定有 $s\le h$，在选的过程中 $h$ 单减，$s$ 单增，所以当 $h\le s$ 时，一定是最优解，用心想就能想明白。

这里有 $O(n)$ 个查询 $O(n\sqrt n)$ 个修改，所以要用一个根号平衡，也就是 $O(1)$ 修改和 $O(\sqrt n)$ 查询的值域分块，这题就简单地 K 了 qwq。

```cpp
#include <bits/stdc++.h>
using namespace std;
int qr(){
	int x=0,f=0;
	char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?~(x-1):x;
} 
int n,m,s,ss,N,bls,l=1,r,L[505],R[505],sum[505],cnt[200005],a[200005],idx[200005],idxx[200005],ans[200005];
struct node{
	int l,r,id;
	bool operator<(const node &p)const{
		return idx[l]==idx[p.l]?(idx[l]&1?r<p.r:r>p.r):l<p.l;
	}
}p[200005];
int main() {
	n=qr(),m=qr();
	s=sqrt(n);
	for(int i=1;i<=n;i++){
		a[i]=qr();
		idx[i]=(i+s-1)/s;
		N=max(a[i],N);
	}
	ss=sqrt(N),bls=(N+ss-1)/ss;
	for(int i=1;i<=bls;i++){
		L[i]=R[i-1]+1,R[i]=min(N,ss*i);
		for(int j=L[i];j<=R[i];j++) idxx[j]=i;
	}
	for(int i=1;i<=m;i++){
		p[i].l=qr(),p[i].r=qr(),p[i].id=i;
	}
	sort(p+1,p+m+1);
	for(int i=1;i<=m;i++){
		while(r<p[i].r) ++cnt[a[++r]],++sum[idxx[a[r]]];
		while(l>p[i].l) ++cnt[a[--l]],++sum[idxx[a[l]]];
		while(r>p[i].r) --cnt[a[r]],--sum[idxx[a[r--]]];
		while(l<p[i].l) --cnt[a[l]],--sum[idxx[a[l++]]];
		int tot=0,Max=0;
		for(int j=bls;j>=1;j--){
			if(tot+sum[j]>=L[j]){
				for(int k=R[j];k>=L[j];k--){
					if(tot+cnt[k]>=k){
						ans[p[i].id]=k;
						break;
					}
					tot+=cnt[k];
				}
				break;
			}
			tot+=sum[j];
		}
		if(ans[p[i].id]==0) ans[p[i].id]=tot;
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

容易想到莫队，话说莫队配合值域分块似乎是个很常见的 trick？

因为答案具有单调性：若 $h$ 可行，对于任意 $h'<h$，$h'$ 一定可行。

于是我们可以在莫队移动指针的同时维护一个值域分块，就可以做到 $O(1)$ 插入删除。

然后使用[静态区间第 $k$ 大](https://www.luogu.com.cn/problem/P3834) 的解法，将块从大向小跳，散块内部可以直接暴力跑，那么查询的复杂度就是 $O(\sqrt{n})$。

整体复杂度 $O(n\sqrt{n})$。

---

## 作者：FutaRimeWoawaSete (赞：0)

备选 T1.5。               

一个比较简单的运用莫队加分块的题目，可以入门。             

考虑莫队把一个区间滚出来，那么我们现在获得了这个区间的值域出现情况。      

一个答案 $x$ 成立的充要条件是其后缀和 $\geq x$ ，然后你就发现后缀和具有单调递减性，所以答案具有单调性，这时候二分一下答案然后快速判断即可。           

一个比较显然的做法是分块 $O(1)$ 加单次 $O(\sqrt n)$ 回答后缀和，最后总的时间复杂度为 $O(n \sqrt n \log n)$ 比较鸡。          

考虑优化这一过程，直接值域分块查答案，维护前缀和，然后如果一个块内的答案合法就直接把当前块的颜色数量加上去，最后总的颜色数量减前缀颜色数量就是后缀颜色数量，注意颜色可重。

还有一个做法是主席树维护区间值域后缀和然后主席树二分，也比较套路。
 
记得讲的时候讲加强版，不过也没什么区别，这题的上限貌似也只能这样了，不过把主席树卡掉是好的。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 4e5 + 5 , SIZE = 1024;
int maxnv,nownum,n,m,a[Len],t,vt,block[Len],sum[Len],SUM[Len],L[Len],R[Len],vpos[Len],Print[Len],Apr;
bool flag[Len];
struct node
{
	int l,r,id;
}Sec[Len];
bool cmp(node x,node y)
{
	if(block[x.l] == block[y.l]) return x.r < y.r;
	return block[x.l] < block[y.l];
}
void add(int x){Apr ++;sum[x] ++;SUM[vpos[x]] ++;}
void sub(int x){Apr --;sum[x] --;SUM[vpos[x]] --;}
inline int BBqqrryy(int x)
{
	for(int i = L[x] ; i <= R[x] ; i ++)
	{
		nownum += sum[i];
		if(Apr - nownum + sum[i] < i) return i - 1;
	}
	return R[x];
}
inline int Query()
{
	int IDX = 1;nownum = 0;
	while(IDX <= vt)
	{
		nownum += SUM[IDX];
		if(Apr - nownum + sum[R[IDX]] >= R[IDX]) IDX ++;
		else 
		{
			nownum -= SUM[IDX];
			return BBqqrryy(IDX);
		}
	}
	return maxnv;
}
signed main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&a[i]);
		maxnv = max(maxnv , a[i]);
	}
	t = n / sqrt(m);
	vt = sqrt(maxnv);
	for(int i = 1 ; i <= n ; i ++) block[i] = (i - 1) / t + 1;
	for(int i = 1 ; i <= vt ; i ++) L[i] = (i - 1) * vt + 1 , R[i] = i * vt;
	if(R[vt] < maxnv) R[vt] = maxnv;
	for(int i = 1 ; i <= vt ; i ++)
		for(int j = L[i] ; j <= R[i] ; j ++) vpos[j] = i;
	for(int i = 1 ; i <= m ; i ++) 
	{
		scanf("%d %d",&Sec[i].l,&Sec[i].r);
		Sec[i].id = i;
	}
	sort(Sec + 1 , Sec + 1 + m , cmp);
	int l = 1 , r = 0;
	for(int i = 1 ; i <= m ; i ++)
	{
		while(l > Sec[i].l) add(a[-- l]);
		while(r < Sec[i].r) add(a[++ r]);
		while(l < Sec[i].l) sub(a[l ++]);
		while(r > Sec[i].r) sub(a[r --]);
		//printf("%d %d %d\n",Sec[i].l,Sec[i].r,Apr);
		Print[Sec[i].id] = Query();
	}
	for(int i = 1 ; i <= m ; i ++) printf("%d\n",Print[i]);
	return 0; 
}
```

---


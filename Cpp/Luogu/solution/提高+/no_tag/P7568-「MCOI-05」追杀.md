# 「MCOI-05」追杀

## 题目描述

Dream SMP 具有 $m$ 位玩家，编号为 $1$ 至 $m$。初始时，每一位玩家生命数量为 $3$。一位玩家 **公认活着**（canonically alive） 当且仅当生命值非零。

Dream SMP 经常发生大型战争，于是会有玩家杀（PvP）别的玩家。对于活着玩家 $u$ 与 $v$，如果 $u$ 杀 $v$，$v$ 的生命数量扣除一次。注意，如果 $u$ 或 $v$ 不为公认活着，杀没有影响。

总共按时序记录了 $n$ 次追杀 $1,2,\dots,n$，其中第 $k$ 次追杀为 $u_k$ 杀 $v_k$。

DreamXD（玩家 $0$）解锁了时空穿越超能力。他现在可以选取任何 $i,v$ 使得 $1\le i\le n+1$ 并且 $1\le v\le m$，穿越到第 $i-1$ 次追杀之后与第 $i$ 次追杀之前，并追杀玩家 $v$。$i=n+1$ 表示穿越到第 $n$ 次追杀后。

不同 $i$ 和 $v$ 可能导致最终活着玩家集合不同。对于每一个 $x$ 使得 $0\le x\le m$，DreamXD 想知道，有多少种 $i,v$ 使最后公认活着玩家集合恰好含有 $x$ 位玩家？

## 说明/提示

#### 样例 2 解释

本样例对应 Dream SMP 当前（4/26/2021) 情况，仅包含公认死亡，即对应剧本，的次数：

 - Aug 2, 2020: Tommy killed by Dream  
 - Aug 2, 2020: Fundy killed by George  
 - Aug 2, 2020: Wilbur killed by Punz  
 - Aug 2, 2020: Tubbo killed by Sapnap  
 - Aug 2, 2020: Tommy killed by Dream  
 - Sep 2, 2020: Wilbur killed by Punz  
 - Oct 16, 2020: Tubbo killed by Techno  
 - Oct 16, 2020: Schlatt killed by Techno  
 - Oct 17, 2020: Schlatt killed by Quackity  
 - Nov 16, 2020: Wilbur killed by Philza  
 - Nov 16, 2020: Schlatt killed by Schlatt  
 - Dec 6, 2020: Karl killed by Karl  
 - Dec 14, 2020: Mexican Dream killed by Natural Causes
 - Dec 14, 2020: Mexican Dream killed by Natural Causes
 - Dec 14, 2020: Mexican Dream killed by Dream  
 - Dec 16, 2020: Quackity killed by Techno  
 - Jan 20, 2021: Dream killed by Tommy  
 - Jan 20, 2021: Dream killed by Tommy  
 - Mar 1, 2021: Tommy killed by Dream  
 - Mar 12, 2021: Connor killed by Ranboo  
 - Mar 23, 2021: Ponk killed by Sam  
 - Apr 18, 2021: Skeppy killed by Bad  
 - Apr 26, 2021: Foolish killed by Bad


**本题采用捆绑测试。**

 - Subtask 1（5 pts）：$n\le5$，$m=1$。
 - Subtask 2（11 pts）：$n,m\le100$。
 - Subtask 3（41 pts）：$n\le10^3$。
 - Subtask 4（43 pts）：没有特殊限制。

对于 $100\%$ 的数据，$1\le n\le6\times10^4$，$1\le m\le10^3$，$1\le u_i,v_i\le m$。

## 样例 #1

### 输入

```
2 2
1 2
1 2
```

### 输出

```
0 3 3```

## 样例 #2

### 输入

```
23 22
2 1
14 10
4 9
12 11
2 1
4 9
12 3
5 3
5 6
4 13
5 5
15 15
7 22
7 22
7 1
6 3
1 2
1 2
2 1
18 16
19 17
20 8
21 8```

### 输出

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 72 456 0 0
```

# 题解

## 作者：littleKtian (赞：20)

设 $f_{i,j}$ 表示在第 $i$ 次追杀前追杀第 $j$ 名玩家时最后剩余玩家数。

如果第 $i$ 次追杀在正常流程时就没有生效，那么 $f_{i,j}=f_{i+1,j}$。如果 $j$ 不是第 $i$ 次追杀的执行者（即 $j\neq u_i$），那么也有$f_{i,j}=f_{i+1,j}$。这两个的证明都比较显然。

注意到 $n$ 的数值比较大而 $m$ 的数值较小，说明在整个追杀过程中真正生效的追杀次数很少（最多 $3m$ 次），于是我们可以对每个真正生效的追杀重新暴力跑一遍结果，其他直接沿用，总复杂度就是 $O(nm)$ 的了。

小优化：并不是所有生效的追杀都要重新跑一遍，只需要对其中追杀者血量为 $1$ 的追杀再跑一遍。同样能证明这是正确的~~但并不能从根本上优化复杂度~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
int h[1001],lh[1001];
int n,m,u[60001],v[60001];
int li[1001],ans[1001];
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx;
}
int main()
{
	n=dr(),m=dr();
	for(int i=1;i<=n;i++)u[i]=dr(),v[i]=dr();
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)h[j]=3;
		--h[i];
		for(int j=1;j<=n;j++)if(h[u[j]]&&h[v[j]])--h[v[j]];
		for(int j=1;j<=m;j++)if(h[j])++li[i];
	}
	for(int i=1;i<=m;i++)h[i]=3;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)++ans[li[j]];
		if(h[u[i]]&&h[v[i]])
		{
			--h[v[i]];
			memcpy(lh,h,sizeof(h));
			if(lh[u[i]])
            {
                --lh[u[i]];
                if(lh[u[i]]==0)
                {
		    	    for(int j=i+1;j<=n;j++)if(lh[u[j]]&&lh[v[j]])--lh[v[j]];
			        li[u[i]]=0;
			        for(int j=1;j<=m;j++)if(lh[j])++li[u[i]];
                }
            }
		}
	}
	for(int i=1;i<=m;i++)++ans[li[i]];
	for(int i=0;i<=m;i++)printf("%d ",ans[i]);
}
```


---

## 作者：FuriousC (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P7568)

### 16pts

暴力模拟

对于每一种情况都穿越回去一次

时间复杂度$O(n^2m)$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
int u[maxn],t[maxn],ans[maxn],hp[maxn];
int n,m,cnt;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d",u+i,t+i);
	}
	for(register int i=1;i<=n+1;i++){ 
		for(register int j=1;j<=m;j++){
			for(register int k=1;k<=m;k++){
				hp[k]=3;
			}
			for(register int k=1;k<=n+1;k++){
				if(k==i){
					hp[j]=max(hp[j]-1,0);
				}
				if(hp[u[k]]&&hp[t[k]]){
					hp[t[k]]--;
				}
			}
			cnt=0;
			for(register int i=1;i<=m;i++){
				if(hp[i]){
					cnt++;
				}
			}
			ans[cnt]++;
		}
	} 
	for(register int i=0;i<=m;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}
```


### 正解

可以发现不管是这位玩家在剩三滴血的情况下被杀或是两滴血的情况下被杀最终都不会导致这位玩家死亡，即不会影响结果

所以只在当前玩家只剩下一滴血时穿越回去追杀这位玩家即可

时间复杂度$O(nm)$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
int n,m;
int ans[maxn],hp[maxn],l[maxn],sav[maxn];
struct smp{
    int x,y;
}a[60005];
int fi(int x){
	int tot=0;
    for(int i=x;i<=n;i++){
    	if(hp[a[i].x]>0){
    		hp[a[i].y]--;
		}
	}
    for(int i=1;i<=m;i++){
    	tot+=(hp[i]>0);
	}
    return tot;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
    	scanf("%d%d",&a[i].x,&a[i].y);
    }
    for(int i=1;i<=m;i++){
    	hp[i]=3; 
	}
    for(int i=1;i<=n;i++){
        int x=a[i].x,y=a[i].y;
        if(hp[x]<=0||hp[y]<=0){
			continue;
		}
        if(hp[x]==1){
            memcpy(sav,hp,sizeof(hp));
            hp[x]--;
			ans[fi(i+1)]+=(i-l[x]);
            memcpy(hp,sav,sizeof(hp));
            l[x]=i;
        }
        hp[y]--; 
    }
    for(int i=1;i<=m;i++){
        hp[i]--;
        ans[fi(n+1)]+=(n+1-l[i]);
        hp[i]++;
        l[i]=n+1;
    }
    for(int i=0;i<=m;i++){
    	printf("%d ",ans[i]);
	}
    return 0;
}
```


---

## 作者：water_tomato (赞：7)

本文同步发表于个人博客：[Link](https://www.watertomato.com/%e3%80%8cmcoi-05%e3%80%8d%e8%bf%bd%e6%9d%80-%e9%a2%98%e8%a7%a3/)。

## 题意

[题目链接](https://www.luogu.com.cn/problem/P7568)。

题意有点复杂，大意是有一个猎杀游戏，有 $m$ 名玩家，每名玩家初始有 $3$ 点生命。有 $n$ 个时刻，每个时刻会发生形如 $u_i$ 杀 $v_i$ 的事件，若 $u_i$ 和 $v_i$ 都存活，则 $v_i$ 生命值减 $1$，若生命值为 $0$ 则死亡。现在发生了一次特殊事件：穿越者穿越到某一次追杀后（可以是第 $0$ 次也可以是最后一次）对某一名玩家造成一点伤害。求对于每一个 $x \in[0,m]$，有多少种穿越方案使最后有 $x$ 名玩家活着。

## 解析

记穿越者编号为 $0$。我们发现一件事情，对于一个事件 $(u_i,v_i)$，若 $x$ 不为 $u_i$ ,在它之前插入 $(0,x)$ 和在它之后插入 $(0,x)$ 是等价的。证明：若 $x$ 为 $v_i$ 相当于依次攻击 $v_i$，是谁攻击的是没有区别的，因此与 $(0,x)$ 的位置前后无关；若 $x$ 不为 $u_i$ 且不为 $v_i$，则该事件与 $u_i,v_i$ 均无关，显然也是等价的。

因此，我们考虑在每一个事件前尝试插入 $(0,u_i)$，容易发现每一次插入后模拟进程的复杂度是 $O(n)$。再考虑一个显然的优化：如果 $u_i$ 或 $v_i$ 已死亡，则不用尝试。我们称 $u_i$ 和 $v_i$ 均未死亡发生的事件为有效事件，则至多进行 $3m-1$ 个有效事件（最后只剩一个人活着且只有 $1$ 滴血）。因此最终时间复杂度为 $O(mn)$。

接着考虑统计答案，我们可以用 $now$ 数组记录每一个玩家当前已统计到的位置，然后每次插入后，更新  $now_x$（$x$ 为尝试攻击的玩家），并将对应的答案加上 $p-now_x $（$p$ 为插入位置）。最后再在所有操作结束之后尝试攻击每一个人，并将对应的答案加上 $n+1-now_x$。因为除了插入位置以外，其他位置都等价于在其下一个位置插入，所以对应答案可以直接用当前位置减去上一个插入的位置（即 $now_x$）。详见代码，配有注释。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e4+5;
int n,m,v[N],u[N],a[N],ans[N],b[N],now[N];
inline void attack(int p,int x){
	for(int i=1;i<=m;i++) b[i]=a[i];
	b[x]--;//插入的攻击
	for(int i=p;i<=n;i++) if(b[u[i]]&&b[v[i]]) b[v[i]]--;//简单的模拟
	int t=0;
	for(int i=1;i<=m;i++) if(b[i]) t++;//统计存活人数
	ans[t]+=(p-now[x]);now[x]=p;//更新对应答案和 now[x]
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&u[i],&v[i]);
	for(int i=1;i<=m;i++) a[i]=3;//初始生命值
	for(int i=1;i<=n;i++){
		if(a[u[i]]&&a[v[i]]){//如果是有效攻击
			attack(i,u[i]);//尝试插入
			a[v[i]]--;//血量减 1
		}
	}
	int t=0;
	for(int i=1;i<=m;i++) if(a[i]) t++;
	for(int i=1;i<=m;i++){//最后再尝试攻击每一个人
		if(a[i]==1) ans[t-1]+=n+1-now[i];
		else ans[t]+=n+1-now[i];
	}//至此，所有可能的情况都被统计完了
	for(int i=0;i<=m;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}
```



---

## 作者：冷月葬T魂 (赞：5)

拿到这道题首先看一下数据范围，$O(nm)$ 的时间复杂度还是可以接受的。 

当DreamXD杀死一名玩家时，我们计其影响为使得某一次原来应该成功的追杀失效，从而改变从此之后的整个游戏进程。对于DreamXD的每种选择，我们计算其影响到的第一次追杀 $z$ 。

当DreamXD杀死一名玩家 $k$ 后，对接下来游戏的进程有什么影响呢？若DreamXD在第 $x$ 次追杀后杀了一刀 $k$ ，假设在原来的游戏进程中 $k$ 在第 $y$ 次追杀后剩下 $1$ 滴血，且 $k$ 在第 $(y<)y_1<y_2<\dotsm<y_t$ 回合均造成了 $1$ 点伤害，则：  
- 若 $x \lt y_1$ ，则第一个受影响的追杀为 $y_1$ （此时玩家 $k$ 因DreamXD的追杀而死亡，即 $y_1$ 为第一个与原来游戏进程不一样的追杀）
- 若 $y_1 \leq x \lt y_2$ ，则第一个受影响的追杀为 $y_2$  
$\dots$
- 若 $y_{n-1} \leq x \lt y_n$ ，则第一个受影响的追杀为 $y_n$
- 若 $x \geq y_n$ ，则DreamXD的追杀的唯一影响为使得玩家 $k$ 死亡

于是使得第 $y$ 次追杀第一个失效的选择方案数可以算出，在代码中记为 $stop[y]$ 。  

整个初始游戏过程模拟一遍，即可算出每名玩家剩下 $1$ 滴血时的回合编号。  

然后对于每个受影响的追杀暴力扫描整个游戏进程，即可得到每个追杀受影响后整个游戏所剩下的人数。  

注意每个玩家最多只会有一次剩下 $1$ 滴血，因此最多只会扫描整个游戏进程 $m$ 次，时间复杂度确实为 $O(nm)$ 。

附上代码（以上有没说清楚的代码里的注释可以看看）

```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rev(i,a,b) for(int i=a;i>=b;i--)
#define clr(a,val) memset(a,val,sizeof(a))
#define int long long
using namespace std;

const int N=2e5+5,M=1e3+5;

int n,m,c[N],a[N],b[N],lst[N],stop[N];
int ans[N];

signed main()
{
	cin>>n>>m;
	
	For(i,1,m) c[i]=3;
	
	For(i,1,n){
		int x,y;
		cin>>x>>y;
		a[i]=x;
		b[i]=y;
		if(c[x]==0||c[y]==0) continue; //此次追杀无效
		if(c[x]==1){ //追杀者仅剩1滴血，将被DreamXD在之前的追杀所影响
			stop[i]=i-lst[x]; //lst[x]即为上一个y_c，当前即为y_c+1，使这次追杀失效的方案数为i-lst[x]
			lst[x]=i; //更新y_c
		}
		c[y]--;
	}
	
	
	int tt=0;
	For(i,1,m){
		if(c[i]>0) tt++;
	}
	
	For(i,1,m){
		if(c[i]==1){ //DreamXD在最后杀掉一名玩家
			ans[tt-1]+=n+1-lst[i];
		}
	}
	
	For(j,1,n){
		if(!stop[j]) continue;
		
		For(i,1,m) c[i]=3;
		
		For(i,1,n){
			if(j==i){ //此次追杀失效
				assert(c[a[i]]==1);
				c[a[i]]=0;
				continue;
			}
			if(c[a[i]]==0||c[b[i]]==0) continue;
			c[b[i]]--;
		}
		
		int t=0;
		
		For(i,1,m){
			if(c[i]>0) t++;
		}
		
		ans[t]+=stop[j]; //多了stop[j]种方案剩下t个人
	}
	
	//为了图方便，我没有计算DreamXD白杀（既没有造成任何影响）的方案数，将（(n+1)*m-所有其它方案数）即可得到DreamXD白杀的方案数
	
	int tot=0;
	For(i,0,m){
		if(i!=tt) tot+=ans[i];
	}
	
//	cout<<"t="<<t<<endl;
	ans[tt]=(n+1)*m-tot;
	
	cout<<ans[0];
	For(i,1,m) cout<<' '<<ans[i];
	cout<<endl;
	
	return 0;
}
```

~~赛时没时间只做了`5pts`，有点遗憾~~~

---

## 作者：quest_2 (赞：5)

推蒟蒻 [$\color{green}{blog}$](https://quest233.github.io) 

[原题链接qaq~](https://www.luogu.com.cn/problem/P7568)

---

#### 原题大 E 

是有 $n$ 条大新闻，每条大新闻形如“$u$ 扣了 $v$ 1 滴血”，每个人有 3 滴血，如果一个人的血量为 $0$， 那么之后所有有关他的大新闻都失效。

这时候出了一个外挂er，他可以在某一时刻开挂，突然扣一个人一滴血（这个人可以是死人）。定义 $f[k]$ 为“在某一位置突然扣了某个人一滴血后，导致最后有 $k$ 人存活的方案数”，求 $f[0...m]$  的异或和。

----

#### 预处理

首先我们有一个非常显然的结论：

对于一个人来说，如果某一段时间他既 **没有去砍别人** 也 **没有被别人砍** ，那么他在这段时间里的任何时刻，被砍一刀导致的结果都是 **等价的** 。

然后我们继续分析，一个人在 3 滴血时被砍和在 2 滴血时被砍，导致的结果也是一样的——他们都会在本应还有 1 滴血的时候暴毙。

这样一来，其实我们可以把任何一个人的存活时间分成 **几个区间** ，每个区间内被砍导致的结果都等价。

我们整区间整区间地统计，这会使我们的代码优化很多。

先放预处理部分的瑇码~

```cpp
	N = read();
	M = read();
	for (register int i = 1; i <= M; i++)
		HP[i] = 3;//HP 数组存血量
	for (register int i = 1; i <= N; i++)
	{
		int x, y;
		x = read();
		y = read();
		q[i].u = x;
		q[i].v = y;//q 数组用来存每条大新闻
		if (HP[x] && HP[y])//如果这条新闻是有效的
		{
			HP[y]--;
			if (HP[y] == 0)
			{
				die[y] = i;//die 数组存每个人是什么时候死的
			}
		}
		if (HP[x] == 1)
		{
			v[x].push_back(MP(lst[x], i - 1));//v 存每个人的等价区间们
			//lst 存每个人的上一步行动是在什么时候
			v[x].push_back(MP(i, i));
			lst[x] = i + 1;
		}
	}
	int remain = 0;//如果没有开挂，本应有 remain 人存活
	for (register int i = 1; i <= M; i++)
	{
		if (HP[i])
			remain++;
		if (lst[i] != N + 1)//处理一些还未封闭的等价区间
			v[i].push_back(MP(lst[i], N));
		if (die[i] == 0)
			die[i] = N + 5;//如果一直不死，就给他赋一个无限晚的死亡时间
	}
```

---

#### 获取答案

然后我们要做的就是枚举每一个人，枚举他的每个等价区间，再把答案累计上去。

你会想，可这 $n^2$ 难道不会 T 飞????？

事实证明是不会的，由于每人的区间个数之和是一个定值，这个 $n^2$ 必然是跑不满的水 $n^2$ 。

如果在某个等价区间里，这个人已经死了，那么鞭一刀尸体不会影响答案，$f[remain]+=\texttt{区间长度}$ 。

否则，专门写一个函数 `check` 判断会留下几个人，函数里可以直接暴力一个一个大新闻地跑。然后 $f[check()]+=\texttt{区间长度}$ 。

然后我们就有一份 AC 瑇码辣！!1

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
const int MAX = 1e5 + 7;
const int MOD = 1e9 + 7;
void print(bool a)
{
	cout << (a ? "YES" : "NO") << endl;
}
struct atk
{
	int u, v;
} q[MAX];
#define PII pair<int, int>
#define MP make_pair
vector<PII> v[MAX];
int read()
{
	int num = 0, bj = 1;
	char ch = getchar();
	while (!isdigit(ch))
	{
		if (ch == '-')
		{
			bj = -1;
		}
		ch = getchar();
	}
	while (isdigit(ch))
	{
		num = num * 10 + ch - '0';
		ch = getchar();
	}
	return bj * num;
}
int lst[MAX];
int die[MAX], HP[MAX];
int ans[MAX];
int N, M;
inline int check(int pos, int v)//在 pos 号大新闻后，v 被砍了一刀
{
	for (register int i = 1; i <= M; i++)
		HP[i] = 3;
	for (register int i = 1; i <= pos; i++)
		if (HP[q[i].u] && HP[q[i].v])
			HP[q[i].v]--;
	if (HP[v])//开挂砍一刀
		HP[v]--;
	for (register int i = pos + 1; i <= N; i++)
		(HP[q[i].u] && HP[q[i].v])
			HP[q[i].v]--;
	int tmp = 0;
	for (register int i = 1; i <= M; i++)
		tmp += (HP[i] > 0);//统计存活人数
	return tmp;
}
signed main()
{
	...//预处理部分，在此不再重复
	
	for (register int i = 1; i <= M; i++)//枚举人
	{
		for (auto u : v[i])//枚举等价区间
		{
			if (u.first > u.second)
			//若区间不合法则跳过（推测应该是在造区间的时候造了一些没用的区间）
				continue;
			if (die[i] <= u.first)//若是鞭尸
				ans[remain] += u.second - u.first + 1;
			else
				ans[check(u.second, i)] += u.second - u.first + 1;
		}
	}
	for (register int i = 0; i <= M; i++)
		printf("%d ", ans[i]);
	return 0;
}
```



---

## 作者：Sparkle_ZH (赞：4)

## Description
+ 共有 $m$ 位玩家，每位玩家初始生命数量为 $3$，一位玩家**公认活着**当且仅当生命值非 $0$。

+ 对于活着的玩家 $u$ 与 $v$，若 $u$ 追杀 $v$ 则 $v$ 生命数量扣除一次。注意，如果 $u$ 或 $v$ 不为公认活着，则没有影响。

+ 共有 $n$ 次追杀，地 $i$ 次为 $u_i$ 追杀 $v_i$。

+ 现在你可以选择任意的 $i, v$ 使得 $1 \le i \le n+1$ 且 $1 \le v \le m$，穿越到第 $i-1$ 次追杀之后，第 $i$ 次追杀之前，并追杀玩家 $v$。特殊地，$i = n+1$ 表示穿越到第 $n$ 次追杀后。

+ 对于每一个 $x$ 使得 $1 \le x \le m$，求有多少种 $i, v$ 使得最终有 $x$ 个玩家公认活着。

+ $1 \le n \le 6\times10^4$，$1 \le m \le 10^3$，$1 \le u_i, v_i \le m$。

## Solution
### 16pts
暴力模拟即可。

枚举 $i, v$ 然后 $O(n)$ 统计剩余玩家数量，时间复杂度 $O(n^2m)$。

### 57pts
我们发现穿越之后的模拟追杀过程很难优化，于是可以考虑优化穿越次数。

我们不希望进行两次结果相同的穿越，例如对于 $[(1, 2), (2, 3), (1, 3)]$，插入 $(0, 1)$ 到四个不同的位置，结果不变。

考虑在 $(u_i, v_i)$ 前插入怎样的追杀不会导致结果相同。

+ 追杀玩家 $x$，$x \neq u_i$，$x \neq v_i$。我们发现 $[(0, x), (u_i, v_i)]$ 与 $[(u_i, v_i), (0,x)]$ 结果相同，所以无效。

+ 追杀玩家 $v_i$。我们发现 $[(0, x), (u_i, v_i)]$ 与 $[(u_i, v_i), (0,x)]$ 结果相同，所以无效。

于是 $u_i, v_i$ 之前只需要尝试追杀 $u_i$，时间复杂度降为 $O(n^2)$。

~~当然这档部分分也可以用暴力+比较好的剪枝水过~~

### 100pts
再次观察发现，如果 $u_i$ 或 $v_i$ 已经非公认活着，那么所有穿越都无效。

考虑到每位玩家只有三滴血，所以最多只需要穿越 $3m$ 次，时间复杂度复杂度降为 $O(nm)$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int L = 1e5 + 5; 
int n, m, cnt, tmp, u[L], v[L], a[L], b[L], ans[L], las[L];
bool f[L];

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d %d", &u[i], &v[i]);
	
	for (int j = 1; j <= m; j++)
		b[j] = 3;
	
	for (int j = 1; j <= n; j++)
		if (b[u[j]] != 0 && b[v[j]] != 0)
			b[v[j]]--, f[j] = true;
	
	for (int i = 1; i <= m; i++)
		if (b[i] != 0) tmp++;
		
	for (int i = 1; i <= n; i++) {
		if (!f[i]) continue;
		cnt = 0;
			
		for (int j = 1; j <= m; j++)
			a[j] = 3;
			
		for (int j = 1; j <= n; j++) {
			if (i == j && a[u[i]] != 0)
				a[u[i]]--;
					
			if (a[u[j]] != 0 && a[v[j]] != 0) a[v[j]]--;
		}
		
		for (int j = 1; j <= m; j++)
			if (a[j] != 0) cnt++;
			
		ans[cnt] += i - las[u[i]];
		las[u[i]] = i;
	}
	
	for (int i = 1; i <= m; i++)
		ans[tmp - (b[i]==1)] += n + 1 - las[i];
	
	for (int i = 0; i <= m; i++)
		printf("%d ", ans[i]);
	
	return 0;
}
```

---

## 作者：Lacuna (赞：2)

昨天模拟赛 T2，只拿到 $O(n^2m)$ 的 $16$ 分，今天补题的时候觉得还是蛮抽象的。

### 思路：

首先你得明确穿越的意义。你可能穿越回去把一个杀人魔给杀了。之后就会免死很多人。我将其称为改写结局。

每次穿越回去，然后试着每个人都追杀一次，这就是 $16$ 分做法。

考虑优化。我们考虑追杀谁：

- $u_i$：这就跟前面我提到的一样，可能会少死很多人。所以我们直接模拟这个过程就行。也就是把 $u_i$ 的血量扣除 $1$ 然后在模拟后面的事件就行。
- $v_i$：这样造成的影响比较小，顶多就是多死一个人。我们遍历完整个事件就会发现，我们只有追杀只剩一滴血的人才会对结果造成影响。但是我们不能确保这个人在只剩一滴血的时候开狂暴杀人，所以我们建一个 $lst$ 数组，这是从别的题解学习到的，$lst_i$ 存的是上一次 $i$ 杀人的时间，这样我们在他最后一次杀人之后把他杀了就没有影响了。
- 其它：杀其他人自然对这次事件的结果没有影响。

这样我们就不用每个人都试一遍，而是只试杀 $u_i$ 的情况。时间复杂度降为 $O(nm)$。

### 代码，有些细节看注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pc putchar
#define pb push_back
#define ls u<<1
#define rs u<<1|1
const int ri=60005,P=1e9+7;
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
int n,m,ans[ri],u[ri],v[ri],hp[ri],hp1[ri],lst[ri];
void chuanyue(int pos,int x){
	int cnt=0;
    for(int i=1;i<=m;i++){
	    hp1[i]=hp[i];//这边相当于另一种结局，所以血量是复制主线的。 
	}
    hp1[x]--;//穿越回去追杀扣除的血量 
	for(int i=pos;i<=n;i++){
		if(hp1[u[i]]&&hp1[v[i]]){//这里模拟过程 
			hp1[v[i]]--;
		}
	}	
	for(int i=1;i<=m;i++){//统计 
		if(hp1[i]>0) cnt++;
	}
	ans[cnt]+=pos-lst[x];//方案数：穿越到上一次x杀人后的效果都是等效的，答案加上当前时间减上一次杀人的时间。 
	lst[x]=pos;//更新 
}
int main(){
	read(n,m);
	int cnt=m;//人数 
	for(int i=1;i<=n;i++){
		read(u[i],v[i]);
	}
	for(int i=1;i<=m;i++) hp[i]=3;//这里就是主线剧情的血量 
	for(int i=1;i<=n;i++){//模拟过程 
		if(hp[u[i]]&&hp[v[i]]){
			chuanyue(i,u[i]);
			hp[v[i]]--;//被杀 
            if(!hp[v[i]]) cnt--;//这里血被扣光了，人数-1 
		}
	}
	for(int i=1;i<=m;i++){
		if(hp[i]==1){//只剩一滴血，可以一击毙命 
			ans[cnt-1]+=n-lst[i]+1;//可以在故事的最后也就是最后一次杀人后再追杀，答案要+1,所以是n-lst[i]+1 
		}else{
			ans[cnt]+=n-lst[i]+1;//这里同理，只不过这次追杀没有对结果造成影响。 
		}
	}
	for(int i=0;i<=m;i++){
		cout<<ans[i]<<" ";
	}
	return 0;
}
```

---

## 作者：耶梦加得 (赞：2)

首先 $O(n^2m)$的作法是 naive 的，对于所有 $(i,v)$ 暴力地枚举（共有 $O(nm)$ 种）并 $O(n)$ 地暴力模拟。可以获得 16分。

从直觉上来看，似乎这么多方案中，其中有很多种最后的结果都是完全相同的，如果手动模拟一下的话就会发现确实如此。我们做了很多多余的工作。

那么哪些方案一定会有相同的结果呢？对于 $(i,v)$ 这个二元组，每个方案的变量有“kill 谁“ 和 “什么时候kill“ 。

其中对"kill 谁"的讨论似乎不能够减少我们的方案数。但是一旦我们确定了要杀谁，早杀还是后杀，在某些情况下似乎是一样的。

我们具体的分析，对于 $(i,v)$ 和 $(i + 1,v)$，容易知道如果 $v \neq a_i$ 并且 $v \neq b_i$，这两种方案是不会有任何不同的~~三体进攻致远星不会影响地球上法国投降~~

其次，对于原本就无效的追杀（我们定义追杀 $i$ 是无效的当且仅当 $a_i$ 或 $b_i$ 在第 $i$ 次追杀时已经公认死亡），这两种方案肯定也不会有任何区别~~攻击前摇与攻击后摇~~。

对于 $v = b_i$ ，这两种方案其实同样也不会有任何影响。~~无非就是 $b_i$ 先被谁捅一刀，人头归谁~~。（如果想不清楚的话可以简单分类讨论一下。实在无法理解的话，这个优化不要也罢。）

那么只剩下 $v = a_i$ 的情况需要讨论了。乍一看似乎是 $O(n)$ 的，但是我们之前提到过，无效的追杀是不予考虑的。那么有多少次有效的追杀呢？

我们从整体分析这个问题，因为每次有效的追杀都会导致某位受害者死一次，而每个人最多死 3 次，因此至多有 $3m$ 次有效的追杀。

~~观察数据范围可得，~~ 我们可以对每个 $(i, a_i)$ 进行 $O(n)$ 的模拟，复杂度是 $O(nm)$ 的。对于其他的 $(i, v)_{v \ne a_i}$  直接沿用 $(i + 1, v)$ 

（当然首先你得算出某一时刻所有的 $(i, v)$，这也是 $O(nm)$ 的）。

另外有个小优化，其实只需考虑 $v = a_i$， 并且此时 $a_i$ 只有一条命的情况。感性理解一下，只有在这种情况下才能以暴制暴，阻止悲剧发生。其他情况~~也依然只是内卷看谁先背刺谁~~。当然复杂度还是不变的。

Code:
```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int n, m;
int f[1007], lf[1007], cnt[1007], drill[1007];
int a[60007], b[60007];
//提醒一下O(nm)的空间复杂度是会爆炸的
inline int calc() {
    drill[0] = 0;
    for(int i = 1; i <= m; ++i) {
        if(drill[i] > 0) ++drill[0];
    }
    return drill[0];
}
signed main() {
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; ++i) lf[i] = 3;
    //这里我算出了所有的 (n + 1, v)
    //其实算出(1, v)会更加方便，别的题解貌似采用的是(1, v)写法。
    for(int i = 1; i <= n; ++i) {
        scanf("%d %d", a + i, b + i);
        if(a[i] == b[i] || lf[a[i]] > 0) lf[b[i]]--;
        //为了后面还原方便采用了这种与题面等效（但实现不同）的判断条件
    }
    for(int i = 1; i <= m; ++i) {
        if(lf[i] > 0) ++f[0];
    }
    for(int i = 1; i <= m; ++i) {
        if(lf[i] == 1) f[i] = f[0] - 1;
        else f[i] = f[0];
        cnt[f[i]]++;
    }
    for(int i = n; i; --i) {
        if(a[i] == b[i] || lf[a[i]] > 0) lf[b[i]]++;
        //如果直接模拟，判断b[i]何时“复活”需要额外记录
        for(int j = 1; j <= m; ++j) {
            if(j != a[i] || lf[a[i]] != 1 || lf[b[i]] <= 0) {cnt[f[j]]++; continue;}
            //三个优化，尤其是第一个和第三个不能少
            memcpy(drill, lf, sizeof(lf)); //防止干扰
            drill[a[i]]--;
            for(int k = i; k <= n; ++k) {
                if(a[k] == b[k] || drill[a[k]] > 0) --drill[b[k]];
            } //暴力模拟
            cnt[f[j] = calc()]++;
        }
    }
    for(int i = 0; i <= m; ++i) printf("%d ", cnt[i]);
    putchar('\n');
    return 0;
}

```


---

## 作者：Create_Random (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7568)

这题直接对于每种情况暴力统计是 $O(n^2m)$ 的，

那么我们可以考虑是否可以一次直接统计某个区间的答案从而降低时间复杂度。

我们可以记录每个人试图去杀别人的所有操作，

易知在每两个杀别人的操作之间的任意时刻对这个人进行一次追杀都是等价的。

因为总的追杀次数为 $n$ 次，

故时间复杂度降为 $O(n^2)$ .

考虑进一步优化：

因为某个人被杀死后无论在何时对其进行追杀都是等价的，

相当于被再次计算的区间只存在于这个人死亡时间之前，

而真正有效的操作数量最多为 $3m$ ,

所以只计算死亡前的有效操作数时时间复杂度为 $O(nm)$ ,

同时带着个 $3$ 倍的常数，

~~但这对于我这个大常数选手还不够~~

考虑继续优化，

我们发现在这个人剩余 $1$ 点生命之前，

无论在何时进行追杀他的死亡时间都是一定的，

那么我们就可以只计算剩余生命值为 $1$ 时的追杀，

将剩余生命值为 $2$ 或 $3$ 的统一起来。

时间复杂度为 $O(nm)$ .

$Code$:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int u[60010],v[60010];
vector<int> a[1010];
int _kill[1010];
int ans[1010];
int death[1010];
int hp[1010];
int cnt;
int read()
{
    int x=0,ch=getchar();
    while(!isdigit(ch))
    {
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=x*10+ch-'0',ch=getchar();
    }
    return x;
}
void kill_this(int x,int t,int len)
{
	int cal=0;
	for(int i=1;i<=m;i++)
	{
		hp[i]=3;
	}
	for(int i=1;i<=t;i++)
	{
		if(hp[u[i]]>0&&hp[v[i]]>0)
		{
			hp[v[i]]--;
		}
	}
	hp[x]--;
	for(int i=t+1;i<=n;i++)
	{
		if(hp[u[i]]>0&&hp[v[i]]>0)
		{
			hp[v[i]]--;
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(hp[i]>0)
		{
			cal++;
		}
	}
	ans[cal]+=len;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		a[i].push_back(0);
	}
	for(int i=1;i<=n;i++)
	{
		u[i]=read(),v[i]=read();
		
	}
	for(int i=1;i<=m;i++)
	{
		hp[i]=3;
		death[i]=n+1;
	}
	for(int i=1;i<=n;i++)
	{
		if(hp[u[i]]>0&&hp[v[i]]>0)
		{
			hp[v[i]]--;
			if(hp[u[i]]==1)
			{
				_kill[u[i]]++;
				a[u[i]].push_back(i);
			}
			if(hp[v[i]]<=0)
			{
				death[v[i]]=i;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(hp[i]>0)
		{
			cnt++;
		}
	}
	for(int i=1;i<=m;i++)
	{
		bool flag=0;
		for(int j=1;j<=_kill[i];j++)
		{
			if(a[i][j]>death[i])
			{
				kill_this(i,a[i][j]-1,a[i][j]-a[i][j-1]);
				flag=1;
				ans[cnt]+=n+1-a[i][j];
				break;
			}
			kill_this(i,a[i][j]-1,a[i][j]-a[i][j-1]);
		}
		if(!flag)
		{
			kill_this(i,n,n+1-a[i][_kill[i]]);
		}
	}
	for(int i=0;i<=m;i++)
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```

---


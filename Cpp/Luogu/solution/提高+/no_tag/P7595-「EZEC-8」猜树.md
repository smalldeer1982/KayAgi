# 「EZEC-8」猜树

## 题目背景

这是一道交互题。

## 题目描述

有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。

您可以使用两种询问：

1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。
2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。

请通过使交互库输出不超过 $10^5$ 个数，得到这棵树的结构。

### 交互方式

输入树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的两种询问。

对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。

对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。

在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n \leq 5$。
-  Subtask 2（15 points）：$n \leq 100$。
-  Subtask 3（20 points）：$n \leq 500$。
-  Subtask 4（15 points）：树是一条链。
-  Subtask 5（15 points）：树是一棵完全二叉树。
-  Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2 \leq n \leq 2000$，$1\le u,v \le n$。

**注意：询问不合法或交互库输出数超过 $10^5$ 后继续询问可能导致 TLE。**

## 样例 #1

### 输入

```
5

1

5 1 5 2 4 3

3 4 2 5

1 3```

### 输出

```

? 1 1 2

? 2 1

? 2 2

? 2 3

! 1 1 2 2```

# 题解

## 作者：Legitimity (赞：8)

~~交互题？可以乱搞，有意思~~

------------
首先分别考虑只用一种询问的做法。



------------


#### subtask1+2+3（？）+5

考虑询问 $2$，把每个节点的子树都搞下来，开这样几个东西：

1. $siz_i$ 表示**当前**节点 $i$ 子树的大小。
2. $f_i$ 这是一个 vector 或二维数组 ，表示节点 $i$ 所有的祖先（不需要按顺序）

这两个都可以在询问子树的时候求出来，具体做法不细讲。

然后是类似拓扑排序的思想：将所有节点按 $siz$ 由小到大排序，前面的若干个 $siz$ 一定是 $1$，即这些节点是叶子节点。这样从前到后处理，一定是按照从叶子节点向上处理的顺序。

处理到叶子节点 $u$ 时，把 $u$ 删除，按照 $f_u$ 把 $u$ 的祖先的 $siz$ 全减一，找到祖先中 $siz$ 最小的节点 $v$，则 $fa_u=v$。因为如果 $u$ 的祖先 $v$ 不是 $u$ 的父亲的话，那么 $u$ 真正的父亲 $v'$ 的子树则一定是 $v$ 的子树的子集，所以 $siz_{v'}<siz_v$。

这样不断向后处理，处理到 $i$ 时，$siz_i$ 也一定等于 $1$，因为它的子树已经在先前的处理中删掉了。

为什么？可以自己试着画图推一下，其实非常好理解，这里直接放一下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define inf 0x3f3f3f3f
#define ll long long
inline int read(){
	rg int ret=0,f=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getchar();}
    return f?-ret:ret;
}
int n,u,siz[2005],fa[2005];
int f[2005][2005],cnt[2005];
int no[2005];
inline bool cmp(int a,int b){
	return siz[a]<siz[b];
}
signed main(){
	n=read(); siz[1]=n; siz[n+1]=inf;  //初始化。
	for(rg int i=2;i<=n;++i){
		printf("? 2 %d\n",i); fflush(stdout);
		siz[i]=read();
		for(rg int j=1;j<=siz[i];++j){
			u=read(); if(u==i) continue;
			f[u][++cnt[u]]=i;
		}
		f[i][++cnt[i]]=1; //1 是根节点，也是所有节点的祖先。
		no[i]=i;
	}
	sort(no+2,no+1+n,cmp); //将节点按 siz 排序，依次处理。
	for(rg int g=2;g<=n;++g){
		int now=no[g];
		fa[now]=n+1;
		for(rg int i=1;i<=cnt[now];++i){
			--siz[f[now][i]];  //因为自己被删掉了，把祖先的 siz 全部减一。
			if(siz[f[now][i]]<siz[fa[now]]) fa[now]=f[now][i];  //siz 最小的就是父亲。
		}
	}
	printf("! ");
	for(rg int i=2;i<=n;++i){
		printf("%d ",fa[i]);
	}
	fflush(stdout);
	return 0;
}
```

时间复杂度和询问次数？这里的复杂度和子树大小递减的速度有关，同一层的节点越多，复杂度就越低，比如完全二叉树时，时间复杂度和询问次数为 $\Theta(n\log n)$，反之，如果为链，每次子树只递减 $1$，那么时间复杂度和询问次数约为 $\Theta(n^2)$。数据随机的情况为 $\Theta(n\sqrt n)$。（prufer 序列生成的真随机，下文亦同）

期望得分 $[35,55]$

------------
#### subtask1+2+3+4

考虑询问 $1$。

开这样几个东西：
1. $dep_i$ 表示节点 $i$ 的深度（定义根节点深度为 $0$）
2. 没了

当 $dis_{u,v}=1$ 且 $dep_u>dep_v$ 时，$fa_u=v$。

（这不用我解释吧……）

那么思路就很明了了，首先询问 $1$ 到其它节点的距离得出 $dep$，然后每次把已经知道父亲的节点入队（若 $dep_i=1$ 则 $fa_i=1$)。对于对头的节点 $v$ ，询问每个 $dep_v+1=dep_u$ 的 $u$ 节点，若 $dis$ 为 $1$，则令 $fa_u=v$ ，并把 $v$ 入队。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define inf 0x3f3f3f3f
#define ll long long
inline int read(){
	rg int ret=0,f=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getchar();}
    return f?-ret:ret;
}
int n,u,fa[2005],dep[2005];
int q[2005],f,r;
signed main(){
	n=read(); dep[1]=0;
	for(rg int i=2;i<=n;++i){
		printf("? 1 1 %d\n",i); fflush(stdout);
		dep[i]=read();
		if(dep[i]==1){
			fa[i]=1; q[++r]=i;
		} //处理深度和第一批入队的点。
	}
	while(f<r){
		int now=q[++f]; 
		for(rg int i=2;i<=n;++i){
			if(dep[i]==dep[now]+1&&!fa[i]){
				printf("? 1 %d %d\n",now,i); fflush(stdout);
				u=read();
				if(u==1){
					fa[i]=now; q[++r]=i;
				}
			}
		}//对于当前节点找到其所有的儿子并入队。
	}
	printf("! ");
	for(rg int i=2;i<=n;++i){
		printf("%d ",fa[i]);
	}
	fflush(stdout);
	return 0;
}
```
时间复杂度和询问次数？因为这题对时间复杂度的要求不高，这里窝偷了个懒，时间复杂度是稳定的 $\Theta(n^2)$，但其实可以做到和询问次数同阶的。询问次数则与每一次的节点个数有关，询问次数的总数大约是 $\sum dep_i\times dep_{i+1}$。如果是链，询问次数达到最优的 $n$，如果每次的节点很多，如完全二叉树，那么询问次数将会退化到 $n^2$ 以上。随机数据的询问次数也是 $n\sqrt n$ 左右。

期望得分 $[55,55]$



------------
接下来是乱搞环节，我们发现 $n\leq 2000$ 相对于 $10^5$ 来说非常小，考虑一些不太正经的解法。

可以按照当前深度的节点数 $cnt[dep_i]$ 进行分治，如果大于阈值 $T$，跑第一种，反之跑第二种，时间复杂度是 $\Theta(\frac{n^2}{T}+nT)$。这是一个显然的根号分治，$T$ 取 $\sqrt n$ 时候达到最优的 $\Theta(n\sqrt n)$，不过这里的不再是随机数据，针对所有数据都可以做到复杂度不退化。

期望得分 $[100,100]$。


------------


但还有另一种简单粗暴的写法，不如根号分治优，就是直接判断整颗树的深度，取一个阈值 $T$，深的话跑第二种，浅的话跑第一种，即数据分治（

我也不知道 $T$ 取多少最好。这样的复杂只是度是比单独的两种好，但还是可以被卡掉，但是这题数据水，这样写就能过了。

期望得分 $[70,100]$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define inf 0x3f3f3f3f
#define ll long long
#define vit vector<int>::iterator
inline int read(){
	rg int ret=0,f=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getchar();}
    return f?-ret:ret;
}
int n,u,fa[2005],dep[2005],mxdep,siz[2005];
int f[2005][2005],cnt[2005];
int q[2005],fr,r;
int no[2005];
inline bool cmp(int a,int b){
	return siz[a]<siz[b];
}
inline void work(){
	siz[1]=n; siz[n+1]=inf;
	for(rg int i=2;i<=n;++i){
		printf("? 2 %d\n",i); fflush(stdout);
		siz[i]=read();
		for(rg int j=1;j<=siz[i];++j){
			u=read(); if(u==i) continue;
			f[u][++cnt[u]]=i;
		}
		f[i][++cnt[i]]=1;
		no[i]=i;
	}
	sort(no+2,no+1+n,cmp);
	for(rg int g=2;g<=n;++g){
		int now=no[g];
		fa[now]=n+1;
		for(rg int i=1;i<=cnt[now];++i){
			--siz[f[now][i]]; 
			if(siz[f[now][i]]<siz[fa[now]]) fa[now]=f[now][i];
		}
	}
}
signed main(){
	n=read(); dep[1]=0;
	for(rg int i=2;i<=n;++i){
		printf("? 1 1 %d\n",i); fflush(stdout);
		mxdep=max(dep[i]=read(),mxdep);
		if(dep[i]==1){
			fa[i]=1; q[++r]=i;
		}
	}
	if(mxdep<=50) //数据分治（
		work(); //第一种。
	else{  //第二种。
		while(fr<r){
			int now=q[++fr]; 
			for(rg int i=2;i<=n;++i){
				if(dep[i]==dep[now]+1&&!fa[i]){
					printf("? 1 %d %d\n",now,i); fflush(stdout);
					u=read();
					if(u==1){
						fa[i]=now; q[++r]=i;
					}
				}
			}
		}
	}
	printf("! ");
	for(rg int i=2;i<=n;++i){
		printf("%d ",fa[i]);
	}
	fflush(stdout);
	return 0;
}
```


---

## 作者：pocafup (赞：5)

由于这题大概率会有根号分治的题解，我这就只分析一下算法的复杂度正确性。

首先花费 $n$ 个数使用 1 操作得出每个节点的深度。

考虑按深度逐层梳理。设有 $k$ 层，第 $i$ 层有 $a_i$ 个节点，则全部使用 1 操作的代价为 $a_i \times a_{i+1}$ 全部使用 2 操作的代价为 $\sum\limits_{j=i}^k a_j$。显然光用任何一个操作都可以被卡成输出 $n^2$ 个数。考虑优化。

由于 1 操作跟当前层和下一层的点数有关，考虑按点数分类讨论。取闸值 T 为分界点，当 $a_i$ 大于 $T$ 时使用 2 操作，否则使用 1 操作，输出数量为 $(nT+n^2/T)$

证明：

讨论当前层的节点个数：

- $a_i>T$

易证全部使用二操作花费的代价不超过 $n$，这里直接按 $n$ 来看待。

可以发现，这种情况最多出现 $n/T$ 次，每次输出数量为 $n$，故总输出数量为 $n^2/T$

- $a_i<T$ 且 $a_{i+1}<T$

这种情况的花费为 $a_i\times a_{i+1} \times \dfrac{n}{a_i+a_{i+1}}$


由于 $a_i+a_{i+1}$ 变大会使这个式子变小，这里默认 $a_i = a_{i+1} = a_i+a_{i+1} = T$（虽然不可能，但不存在比这种情况更劣的输出方案），那么这个输出代价为 $nT$。

 $a_i < T$ 且 $a_{i+1}>T$。
 
这种情况的花费仍然为 $a_i\times a_{i+1} \times \dfrac{n}{a_i+a_{i+1}}$

注意这种情况下仍然有 $a_i+a_{i+1} > a_{i+1}$，为了方便我们直接在原式中将他们划等号并约分，则最后这个部分的输出花费为$a_i \times n$，必然不劣于 $nT$

令 $T=\sqrt{n}$，则我们可以在 $n\sqrt{n}$输出数量内解决问题

---

## 作者：tommymio (赞：5)

场外选手前来补题~

询问限制这么宽，随便乱搞就是。验题人还告诉我这题数据特别水，数据强的是加强版（

先询问一遍所有节点到 $1$ 的距离，并将树上节点按照到 $1$ 的距离分层。考虑两种得到树结构的操作：

- 对于第 $i$ 层和第 $i+1$ 层，询问这两层节点的两两距离，若距离为 $1$ 则确定了一条边。
- 对于第 $i$ 层和第 $i+1$ 层，枚举第 $i$ 层内每个节点 $x$，并询问 $x$ 的子树内节点信息。找出那些节点层数正好为 $i+1$ 的点与 $x$ 连边。

我们来计算一下代价。设第 $i$ 层节点有 $f_i$ 个，节点最大层数（其实就是深度）为 $n$，那么第一种操作的代价为：
$$
f_i\times f_{i+1}
$$

第二种操作的代价为：
$$
\sum_{j=i}^n f_j
$$

当第一种操作的花费过大，可以使用第二种操作减小花费。第二种操作也类似。由于询问限制非常松，所以可以过。

```cpp
#include<cstdio>
#include<vector>
std::vector<int> pt[2005];
int dep[2005],sum[2005],fa[2005];
inline int max(const int &x,const int &y) {return x>y? x:y;}
int main() {
    int n,maxDep=0;
    scanf("%d",&n);
    for(register int i=2;i<=n;++i) {
        int x,d;
        printf("? 1 %d %d\n",1,i);
        fflush(stdout);
        scanf("%d",&d);
        if(d==1) fa[i]=1;
        dep[i]=d; pt[d].push_back(i);
        maxDep=max(maxDep,d);
    }
    for(register int i=1;i<=maxDep;++i) sum[i]=sum[i-1]+pt[i].size();
    for(register int i=1;i<maxDep;++i) {
        if(sum[maxDep]-sum[i-1]+sum[i]-sum[i-1]>(sum[i]-sum[i-1])*(sum[i+1]-sum[i])) {
            for(register int k=0;k<pt[i+1].size();++k) {
                int y=pt[i+1][k],dis;
                for(register int j=0;j<pt[i].size();++j) {
                     int x=pt[i][j];
                    printf("? 1 %d %d\n",x,y);
                    fflush(stdout);
                    scanf("%d",&dis);
                    if(dis==1) {fa[y]=x;break;}
                }
            }
        }
        else {
            for(register int j=0;j<pt[i].size();++j) {
                int x=pt[i][j],m;
                printf("? 2 %d\n",x);
                fflush(stdout);
                scanf("%d",&m);
                for(register int k=0;k<m;++k) {
                    int y; scanf("%d",&y);
                    if(dep[y]==i+1) fa[y]=x;
                }
            }
        }
    }
    printf("! ");
    for(register int i=2;i<=n;++i) printf("%d ",fa[i]); printf("\n");
    fflush(stdout); 
    return 0;
}
```

---

## 作者：Jorisy (赞：1)

萌萌小交互。

下面令 $\text{dis}(x,y)$ 表示 $x$ 到 $y$ 的距离，$\text{dep}_x$ 表示 $x$ 的深度，$S(x)$ 表示深度为 $x$ 的结点所构成的集合，$\text{sz}_x$ 为以 $x$ 为根的子树大小。

首先我们考虑 $n-1$ 次询问 $\text{dis}(1,x)$ 来获得 $\text{dep}_x$。下面为了方便计算总询问次数，我们暂时忽略掉这 $n-1$ 次询问。

先考虑一些绝对会被卡掉的做法。

1. 枚举相邻深度的节点，查询距离，为 $1$ 则加入答案。总询问次数为 $\sum\limits_{i=2}^n|S(i)|\cdot|S(i+1)|$。
2. 枚举所有结点，查询子树内所有结点，深度与子树的根相差 $1$ 则加入答案。总询问次数为 $\sum\limits_{i=2}^n\text{sz}_i$。

这个 $n=2000$ 和询问仅 $10^5$ 次的限制看着就很像是个根号的东西。

钦定一个分界值为 $B$。

对于一个 $S(x)$，若 $|S(x)|\le B$，那么跑 1，否则跑 2。粗略估计是 $O(nB+\dfrac{n^2}B)$ 这个量级，但实际显然是没有这么多的。$B=\sqrt n$ 时，量级最小，即 $O(n\sqrt n)$。

代码还是非常好写的。
```cpp
#include<bits/stdc++.h>
#define N 2005
using namespace std;

int n,fa[N],dep[N],c[N],id[N],sum[N],ans;

int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n;
    dep[1]=1;
    c[1]=1;
    for(int i=2;i<=n;i++)
    {
        cout<<"? 1 1 "<<i<<endl;
        cin>>dep[i];
        c[++dep[i]]++;
    }
    iota(id+1,id+n+1,1);
    sort(id+1,id+n+1,[&](int x,int y){return dep[x]<dep[y];});
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+c[i];
    for(int i=1;i<=n;i++)
    {
        if(dep[i]==2) fa[i]=1;
    }
    for(int i=2;c[i];i++)
    {
        if(c[i]*c[i+1]<sum[n]-sum[i-1]+c[i])
        {
            for(int x=sum[i-1]+1;x<=sum[i];x++)
            {
                for(int y=sum[i]+1;y<=sum[i+1];y++)
                {
                    cout<<"? 1 "<<id[x]<<' '<<id[y]<<endl;
                    int d;
                    cin>>d;
                    if(d==1) fa[id[y]]=id[x],ans++;
                }
            }
        }
        else
        {
            for(int j=sum[i-1]+1;j<=sum[i];j++)
            {
                cout<<"? 2 "<<id[j]<<endl;
                int num;
                cin>>num;
                while(num--)
                {
                    int x;
                    cin>>x;
                    if(dep[x]==i+1) fa[x]=id[j],ans++;
                }
            }
        }
    }
    cout<<"! ";
    for(int j=2;j<=n;j++) cout<<fa[j]<<' ';
    return 0;
}
```

---

## 作者：聊机 (赞：1)

新的乱搞做法？我不能保证其一定能在限制输入量内完成，期待有人能 hack 掉。

好像说数据不强？我这个做法在本题中的数据点中最多输入了将近 30000 个数字，是限制的百分之三十。


------------

首先我们考虑只有操作 1 的情况。我们可以直接询问每个点到根节点的距离，也就是它的深度，然后再在相邻的两层深度中枚举，如果它们直接的距离是 1，那就是父子关系。

这种做法对于链操作会跑得飞快，但是对于菊花图，或者说比如有一颗深度总共为 3 的树（也就是另外 $n-1$ 个点都在下面两层的话，就会变成 $n^2$。


------------

再考虑只有操作 2 的情况，我们可以直接把每个节点都询问一次，然后通过每个节点在询问中出现的次数同样得出它的深度，然后直接在子树中寻找深度是本身深度加一的节点就是儿子。

这种做法对于树深度不高的数据跑得飞快，二叉树可以做到 $n\log n$，深度越浅越快，反而对于链状的数据会被卡成 $n^2$。


------------

于是我们考虑把这两种操作结合起来。由于限制的输入量是点数的 50 倍，于是就产生一种乱搞做法。我们发现第一种只使用操作 1 的做法对于每个要找父亲的节点的复杂度是上面这一层的点数。于是特判上面这一层点数在 50 以内就使用操作 1，否则使用操作 2。值得一提的是，每次使用完操作 2 以后，都会让需要使用操作 1 的范围缩小，也就是说并不需要把一层的每个数都遍历，只有对于已经确定在某一祖先下的父子进行判定。

可能有点抽象，具体来说见代码里的三个 vector 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int qr() {
	int k=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch)){k=(k*10)+(ch^48);ch=getchar();}
	return k;
} 
const int N=2002;
int n,dep[N],fa[N];
vector<int>v[N];
void dfs(vector<int>s,vector<int>g,vector<int>h) {
//s是较浅的这一层，g是较深的这一层，h是当前最近使用过操作2的祖先的子树中剩余的其他后辈 
	if(!g.size()) return ;
	if(s.size()<50) {
		vector<int>dg,dh;
		for(int i=0;i<s.size();i++)
			for(int j=0;j<g.size();j++) {
				printf("? 1 %d %d\n",s[i],g[j]);fflush(stdout);
				if(qr()==1) fa[g[j]]=s[i];
			}
		for(int i=0;i<h.size();i++)
			if(dep[h[i]]==dep[g[0]]+1) dg.push_back(h[i]);
			else dh.push_back(h[i]);
		return dfs(g,dg,dh);
	}
	for(int i=0;i<s.size();i++) {
		printf("? 2 %d\n",s[i]);fflush(stdout);
		int sz=qr();vector<int>ds,dg;
		for(int j=0;j<sz;j++) {
			v[s[i]].push_back(qr());
			int u=v[s[i]].size()-1;
			if(v[s[i]][u]==s[i]) {
				v[s[i]].pop_back();
				continue;
			}
			if(dep[v[s[i]][u]]==dep[g[0]]) {
				fa[v[s[i]][u]]=s[i];
				ds.push_back(v[s[i]][u]);
				v[s[i]].pop_back();
			}
			else if(dep[v[s[i]][u]]==dep[g[0]]+1) dg.push_back(v[s[i]][u]);
		}
		dfs(ds,dg,v[s[i]]);//这就是最后说的，对于每个子树单独递归，可以缩小范围。 
	}
}
int main() {
	n=qr();
	for(int i=2,v;i<=n;i++)
	{
		printf("? 1 1 %d\n",i);
		fflush(stdout);
		dep[i]=qr();//先获得每个节点的深度 
	}
	vector<int>g,s,h;
	for(int i=2;i<=n;i++)
		if(dep[i]==1) fa[i]=1,s.push_back(i);
		else if(dep[i]==2)g.push_back(i);
			 else h.push_back(i);
	dfs(s,g,h);printf("! ");
	for(int i=2;i<=n;i++) printf("%d ",fa[i]);
	fflush(stdout);
    return 0;
}
```

我一开始写的是：
```
if(s.size()*g.size()<50)
```
虽然最大点的输入量没变，但总耗时确是上面的代码的一半。

数据很抽象。

---

## 作者：wurzang (赞：1)

太菜了不会根号分治，只能写个乱搞

如果只有第一个询问的话，可以先处理出每个点和 $1$ 的距离，然后让每层点和下层点连边，如果 $dis(i,j)=1$ 的话就让 $i,j$ 连边，这样询问次数就是 $n^2$ 级别的

如果一层连边次数太多的话可以考虑乱搞，直接对一层点询问儿子然后连向下一层。

然后对于第一种连边方式可以优化，如果 $j$ 点最近的已确认祖先并不是 $i$ / $i$ 的祖先，那么 $(i,j)$ 显然连不上。

连边顺序可以随机化，连边次数的阈值也可以随。以上就是 P7595 的乱搞做法了，如果有什么疑问的话欢迎在评论区里回复小编

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
int dis[N],fa[N],gf[N];
vector<int> e[N],v[N],son[N];
int ask1(int x,int y){
    cout<<"? 1 "<<x<<" "<<y<<endl,fflush(stdout);
    int r;cin>>r;
    return r;
}
void ask2(int x){
    cout<<"? 2 "<<x<<endl,fflush(stdout);
    int num,k;cin>>num;
    for(int i=1;i<=num;++i) cin>>k,son[x].push_back(k);
}
int random(int l,int r){
    return (1ll*rand()*rand()+rand())%(r-l+1)+l;
}
signed main(){
    srand(time(0));
    int n;
    cin>>n;
    for(int i=2;i<=n;++i) dis[i]=ask1(1,i),v[dis[i]].push_back(i);
    for(int i=2;i<=n;++i)
        if(dis[i]==1) fa[i]=1;
    int mx=*max_element(dis+1,dis+n+1);
    int T=random(10000,100000);
    for(int i=1;i<mx;++i){
        if(1ll*v[i+1].size()*v[i].size()>=T){
            for(int x:v[i]) ask2(x);
            for(int x:v[i])
                for(int y:son[x]) gf[y]=x;
        }
        //cout<<gf[4]<<" "<<gf[5]<<" fuck\n";
        for(int x:v[i+1]){
            random_shuffle(v[i].begin(),v[i].end());
            for(int y:v[i]){
                if(gf[x]!=0){
                    int fl=1,res=y;
                    while(res!=1) fl&=(gf[x]!=res),res=fa[res];
                    if(gf[x]==y){fa[x]=y;break;}
                    if(fl==1) continue;
                }
                if(ask1(x,y)==1){fa[x]=y;break;}
            }
        }

    }
    cout<<"! ";
    for(int i=2;i<=n;++i)
        cout<<fa[i]<<" ";
    return 0;
}
```


---


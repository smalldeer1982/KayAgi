# [COCI 2010/2011 #5] SLIKA

## 题目描述

Mirko 刚刚安装了一个全新的绘图程序。该程序支持 $K$ 种不同的颜色，用从 $1$ 到 $K$ 的整数表示。所有的绘图都是在一个尺寸为 $N\times N$ 的画布上完成的。在开始时，所有格子都是白色的(用 `1`表示)。

画布左上角的单元格为坐标 $(0,0)$。第一个坐标 $x$ 表示行，第二个坐标 $y$ 表示列。

Mirko 最喜欢的消遣是使用 `PAINT c x1 y1 x2 y2` 命令绘制矩形棋盘图案，其中 $c$ 表示所选的颜色，$(x1,y1)$ 和 $(x2,y2)$ 分别是左上的坐标和右下的坐标。

矩形左上角的单元格将被绘制为所选的颜色，而其余的则如棋盘一样涂色。没有被所选颜色覆盖的单元格将保持它们之前的颜色。

例如，一个白色的画布涂上一个红色的棋盘图案看起来就像这样的:

![](https://cdn.luogu.com.cn/upload/image_hosting/03pv1kce.png)

Mirko最近发现了另外两个命令。他可以随时保存他的画通过使用 `SAVE` 的命令，稍后使用 `load x` 命令再次加载它，其中 $x$ 表示保存的序列号的正整数。

不幸的是，程序崩溃了，Mirko 的画永远丢失了。幸运的是，Mirko 用了一个保存所有已使用命令的日志。你能帮 Mirko 修复那幅丢失的画吗?

## 说明/提示

**【样例解释#1】**

命令 $1$ 将 $(0,0)$ 到 $(3,3)$ 的格子染成了棋盘式，即把 $(0,0)$，$(0,2)$，$(1,1)$，$(1,3)$，$(2,0)$，$(2,2)$，$(3,1)$，$(3,3)$ 都染成了 $2$。

命令 $2$ 将 $(0,3)$ 到 $(3,3)$ 的格子染成了棋盘式，即把 $(0,3)$，$(2,3)$ 染成了 $3$。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 1000$，$2\le K\le 10^5$，$1 \leq M \leq 10^5$。

**【说明】**

本题分值按 COCI 原题设置，满分 $130$。

题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T6 SLIKA**_。

## 样例 #1

### 输入

```
4 3 2
PAINT 2 0 0 3 3
PAINT 3 0 3 3 3 ```

### 输出

```
2 1 2 3
1 2 1 2
2 1 2 3
1 2 1 2 ```

## 样例 #2

### 输入

```
3 3 4
PAINT 3 0 0 1 1
SAVE
PAINT 2 1 1 2 2
LOAD 1 ```

### 输出

```
3 1 1
1 3 1
1 1 1 ```

## 样例 #3

### 输入

```
3 4 7
PAINT 2 0 0 1 1
SAVE
PAINT 3 1 1 2 2
SAVE
PAINT 4 0 2 0 2
LOAD 2
PAINT 4 2 0 2 0 ```

### 输出

```
2 1 1
1 3 1
4 1 3 ```

# 题解

## 作者：seac_blue (赞：12)

题目：[[COCI2010-2011#5] SLIKA](https://www.luogu.com.cn/problem/P7636)

### 思路

#### 逆序存储

顺序存储只能得到 60 分，原因在于浪费了太多的时间在无用的 `PAINT` 函数中。考虑如下片段：

```plain
SAVE
PAINT ...
...
PAINT ...
LOAD 1
```

此时 `LOAD` 函数会使得很多 `PAINT` 函数被清除，但是朴素的算法会把这些函数全部都执行一遍，浪费了很多时间。因此，**我们需要判断哪些** `PAINT` **函数是真正被调用的**。

但是从前往后扫描有可能无法得出正确的顺序。考虑如下片段（从隔壁题解看到的）：

```plain
PAINT ...
SAVE
*PAINT ...
SAVE
LOAD 1
LOAD 2
```

带 $\small*$ 号的 `PAINT` 函数实际上是被调用的。但是如果只是单纯地删除，这个函数就会被认为是无效的，从而得到错误的答案。

此时我们就需要**从后往前**判断 `PAINT` 函数真正的执行顺序。这同时启发我们，不仅可以找到 `PAINT` 函数的调用顺序，或许我们还可以用另外一种角度去调用这些函数。

#### 调用 `PAINT` 函数的另外一种方案

回到曾经写过的一道题：[铺地毯](https://www.luogu.com.cn/problem/P1003)。在这道题中，我们按照顺序在平面上覆盖矩形，最后询问某点上最后一个覆盖的矩形编号。

然而，这道题还有另外一种做法：从**最后**覆盖平面的矩形开始，倒序查找。只要找到某个矩形 $\text{M}$ 覆盖了该点，则 $\text{M}$ 必定是该点上最后一个覆盖的矩形。

这样做的正确性显然：后盖上的矩形必定在先盖上的矩形之上。所以只要 $\text{M}$ 覆盖了点 $P$，$\text{M}$ 之前的矩形就不可能是最后一个覆盖的矩形。

我们再考虑如下问题：如何判断**每一个点**上最后一个覆盖的矩形编号？

相信你也已经得到了答案：倒序查找每一个矩形，在其范围内覆盖**没有被覆盖过的**点。正确性也显然。

回到 SLIKA 这道题。既然可以倒序调用 `PAINT` 函数，那么我们就模仿着铺地毯的方式去覆盖这个画布。

显然我们能写出如下的伪代码片段：

```cpp
倒序遍历操作:
    如果操作为 LOAD:
        返回到对应的 SAVE 处
    如果操作为 PAINT:
        遍历所有能绘制的位置:
            如果这个格子颜色为 1 (没有上过色):
                给这个格子上色
```

但是我们很快就会发现：到了后面，每一个 `PAINT` 函数都会经过很多次上过色的格子，从而浪费了很多的时间。显然这个方法还需要改进。

#### 每个格子最多只会被修改一次

我们考虑用这样的方式来优化：对于每一个格子，记录它之后（包括它本身）的第一个还可以被上色的格子。这样我们就可以像链表一样修改这些格子，只需要同时修改这些格子的后继就可以了。完全可以实现**每个格子最多只会被修改一次**。

你可能已经想到了一个方法：**并查集**。我们使用并查集来满足如上的要求。**修改后继**对应的就是并查集中的 `union` 函数；**查找下一个可修改的格子**对应的就是 `find` 函数。存在的问题被完美解决了。

以行为单位建立并查集，每一次绘制图形之后，都需要执行 `union(x,x+2)` 的操作（绘制是每两格执行一次的），查找后继直接使用 `find(x)` 即可。

值得提出的是，`union(x,x+2)` 当中，$\text{x}$ 的取值有可能就是 $n$，程序中为了防止数组越界或造成死循环，将并查集的范围稍稍调大了一点。当然，你也可以尝试着写一下特判，判断当前的 `union` 操作是否合法。

### 代码

代码省略了头文件。个人的习惯是下标 +1。

```cpp
typedef long long ll;
ll read(){
	char c=getchar();ll d=0,f=1;
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){d=(d<<3)+(d<<1)+(c^48);c=getchar();}
	return d*f;
}

const ll MAXM = 1e5+10;
const ll MAXN = 1e3+10;

ll n,k,m;
struct Oper{
	ll op;
	ll a1,a2,a3,a4,a5;
}a[MAXM];
ll slot[MAXM];// 存档
ll slots;// 存档数量
ll fa[MAXN][MAXN];// 并查集
ll p[MAXN][MAXN];// 颜色

ll find(ll id,ll x){// 此处的 id 和 unionn 函数的一样，都指明了数组的第一维编号
	if(fa[id][x]!=x){
		fa[id][x]=find(id,fa[id][x]);
	}
	return fa[id][x];
}
void unionn(ll id,ll x,ll y){
	x=find(id,x);
	y=find(id,y);
	fa[id][x]=y;
}

int main(){
	n=read();k=read();m=read();
	for(ll i=1;i<=n;++i){
		for(ll j=1;j<=n+2;++j){
			fa[i][j]=j;
			p[i][j]=1;
		}
	}
	for(ll i=1;i<=m;++i){
		string s;cin>>s;
		if(s=="PAINT"){
			a[i].op=1;
			a[i].a1=read();
			a[i].a2=read()+1;
			a[i].a3=read()+1;
			a[i].a4=read()+1;
			a[i].a5=read()+1;
		}if(s=="SAVE"){
			a[i].op=2;
			slot[++slots]=i;
		}if(s=="LOAD"){
			a[i].op=3;
			a[i].a1=read();
		}
	}
	for(ll i=m;i>=1;--i){
		if(a[i].op==3)i=slot[a[i].a1];// 退回对应的存档
		if(a[i].op==1){
			ll ybegin=a[i].a3;
			for(ll j=a[i].a2,ptr=0;j<=a[i].a4;++j,ptr=!ptr){
				for(ll k=find(j,ybegin);k<=a[i].a5;k=find(j,k)){// 跳至其后继
					p[j][k]=a[i].a1;
					unionn(j,k,k+2);// 调整后继
				}
				if(!ptr)ybegin=a[i].a3+1;// 模拟棋盘状
				else ybegin=a[i].a3;
			}
		}
	}
	for(ll i=1;i<=n;++i,putchar('\n')){
		for(ll j=1;j<=n;++j){
			printf("%lld ",p[i][j]);
		}
	}
	return 0;
}
```

祝您 AC 愉快。

---

## 作者：名字好难取144 (赞：10)

机房某大佬推的特别好的思维题。

作为机房最菜的蒟蒻，来给大家简单分析一下这个题目。

## 暴力出奇迹

看到这题，首先想到的是当然得是暴力求解了。

对于操作 PAINT，直接在数组上面暴力修改即可。

对于操作 SAVE，用一个三维数组来保存每一次 SAVE 的内容。

对于操作 LOAD，我们直接把我们存储在三维数组的图赋给操作数组上就可以了。

于是我们会收获 $60Pts$ 的好成绩。

代码贴在[这里](https://www.luogu.com.cn/paste/vitvak9o)。

## 优化一

显然，暴力的话很浪费空间。我们需要一个更节省空间的好方法。

仔细研究一下题目之后，发现一个 SAVE 和一个对应的 LOAD 之间的所有操作**全部无效**。

于是我们可以倒着来操作（因为倒着来操作更加容易找到一个 SAVE 和一个对应的 LOAD。发现了一个 LOAD 操作，前面必定有一个 SAVE 操作，直接跳到对应 SAVE 操作的前一步就可以了。

问题又来了，我们怎么知道前面的状态呢？（也许只有我这种蒟蒻会想到这种奇怪的问题了）

机房大佬云：“**每个格子最多只会被修改一次。**”

仔细想了想，确实是这样的。一个点虽然之前可能被改了很多次，但我们倒着来看，只不过是从原来的白色变成了其他的颜色罢了。（意即只被修改了一次）

这样我们就可以写出 80 分的代码了。

代码同样放在[剪贴板](https://www.luogu.com.cn/paste/f4rrptht)。


## 优化二

现在变成 TLE 了，为什么呢？因为我们在给边涂色的时候遍历到了很多无法修改的点。但我想了很久都没想出来如何避免遍历到了很多无法修改的点。机房大佬看见~~我头发都要掉光了~~，又云:“**并查集**可解决此问题。”

我们**对每一行建立一个并查集**，并令前面的点为父亲，**保证在扫描到该点时直接跳转到该行没有扫过的点**，节约时间。但有几点是需要注意的：

- 做合并的两个点应该为当前点 $a_j$ 与当前点之后的第二个 $a_{j+2}$，因为题目要求是像棋盘一样涂色。

- 由于上一个点的要求，初始化父亲数组的要开到 $n+2$，防止扫描到最后一个点时卡死。

至此，我们的130分代码就出来啦。

~~机房大佬真厉害。~~

## 代码

```cpp
//省略头文件&快读
#define ll long long
using namespace std;
const ll N=1e4+10;

struct node{
	string s;
	int num,sx,sy,ex,ey;
}con[100010];

struct fa{
	int ff[N];
	int find(int x)
	{
		if(x==ff[x]) return x;
		return ff[x]=find(ff[x]);
	}
	void unionn(int x,int y)
	{
		int xx=find(x),yy=find(y);
		ff[xx]=yy;
	}
}f[N];


int a[1010][1010];
int b[N];
int n,m,k,cnt;

string s;

void init(int xx)
{
	for(int i=1;i<=n+2;++i) {
		f[xx].ff[i]=i;
	}
}

int main()
{
	n=read();k=read();m=read();
	for(int i=0;i<n;++i) {
		init(i);
		for(int j=0;j<n;++j){
			a[i][j]=1;
		}
	}
	for(int i=1;i<=m;++i)
	{
		cin>>con[i].s;
		if(con[i].s=="PAINT")
		{
			con[i].num=read();
			con[i].sx=read();con[i].sy=read();con[i].ex=read();con[i].ey=read();
		}  
		else if(con[i].s=="SAVE"){b[++cnt]=i;}
		else 
		{
			con[i].num=read();
		}
	}
	int pos=m+1;
	while(pos--)
	{
		if(con[pos].s=="LOAD")
		{
			pos=b[con[pos].num];
			continue;
		}
		if(con[pos].s=="PAINT")
		{
			int sx=con[pos].sx;
			int sy=con[pos].sy;
			int ex=con[pos].ex;
			int ey=con[pos].ey;
			int num=con[pos].num;
			bool line=0;
			for(int i=sx;i<=ex;++i) {
				line==1?line=0:line=1;\\这是我为了检查当前做到了哪一行而设计的
				for(int j=f[i].find(line?sy:sy+1);j<=ey;j=f[i].find(j)) //关键点，防止遍历无效点
				{
					a[i][j]=num;
					f[i].unionn(j,j+2); 
				}
			}
		}
	}
	for(int i=0;i<n;++i) {
		for(int j=0;j<n;++j) {
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```





---

## 作者：qwer6 (赞：4)

## Upd  
$2025$ 年 $1$ 月 $15$ 日，增加一种目前为你谷最优解的解法。  

在打模拟赛时偶遇此题，拼尽全力无法战胜，遂写题解纪念。    
我们发现，有一些 Paint 操作显然无用，例如题中所给样例二的最后一条 Paint 就是无用的，所以我们考虑去除无用的 Paint 操作。  
很容易有这样的错误想法，就是每一次遇到 Save 操作，就跳到对应的最后一次 Load 操作，但这样不对。  
为什么呢？  
我们看下面这个样例：
```
5 5 8
Paint 2 0 0 4 4
Save
Paint 3 0 0 4 4
Save
Load 1
Paint 4 0 0 4 4
Paint 2 1 1 4 4
Load 2
```
我们在碰到第一次 Save 时，跳到第 $5$ 条操作，此时我们发现重新 Load $2$ 的时候我们就无法执行了。  
那怎么做呢？我们考虑覆盖问题的常用手段，倒着做，我们碰到 Load 操作就跳到对应的 Save 操作，碰到 Save 就跳过，这样就对了。  
然后这样的时间复杂度是 $O(n^2m)$ 的，显然无法通过，所以我们考虑已经覆盖过的位置不再覆盖，使用一个并查集即可
```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=1e3+5,K=1e5+5,M=1e5+5;
int n,k,m,cnt;
int pos[M],ans[N][N];
char opt[15];
struct Query{
	int opt;
	int a1,b1,a2,b2,c;
}a[M];
struct DUS{
	int fa[N];
	void init(){
		for(int i=1;i<=n+2;i++)fa[i]=i;
	}
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
	void merge(int x,int y){
		x=find(x),y=find(y);
		if(x>y)swap(x,y);
		fa[x]=y;
	}
}dsu[N];
void paint(int col,int a1,int b1,int a2,int b2){
	for(int i=a1,add=0,now;i<=a2;i++,add^=1){
		now=dsu[i].find(b1+add);
		for(;now<=b2;now=dsu[i].find(now)){
			ans[i][now]=col;
			dsu[i].merge(now,now+2);
		}
	}
}
signed main(){
	read(n),read(k),read(m);
	for(int i=1;i<=m;i++){
		scanf("%s",opt+1);
		if(opt[1]=='S'){
			a[i].opt=1;
			pos[++cnt]=i;
		}else if(opt[1]=='L'){
			a[i].opt=2;
			read(a[i].c);
		}else{
			a[i].opt=0;
			read(a[i].c),read(a[i].a1),read(a[i].b1),read(a[i].a2),read(a[i].b2);
			a[i].a1++,a[i].a2++;
			a[i].b1++,a[i].b2++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)ans[i][j]=1;
	}
	for(int i=1;i<=n;i++)dsu[i].init();
	for(int i=m;i>=1;i--){
		if(a[i].opt==1)continue;	
		if(a[i].opt==2)i=pos[a[i].c];
		else paint(a[i].c,a[i].a1,a[i].b1,a[i].a2,a[i].b2);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)write(ans[i][j]),Spa;
		Nxt;
	}
}
```
但是，我觉得这种方法的效率还是不够高，怎么办呢？  
我们不妨考虑二维线段树来做区间覆盖。  
同样的，我们记录下有用的操作，倒序进行，并使得已经覆盖过的点不再被覆盖。  
注意到，当我们染色时，假设左上角的坐标为 $(x_0,y_0)$，对于矩形中的点 $(x,y)$，只有当 $x+y$ 的奇偶性的 $x_0+y_0$ 的奇偶性相同时才会被染色，所以我们开两棵二维线段树，记录 $x+y$ 分别为奇数和偶数时的矩阵。  
对于一个涂色操作，我们直接在对应的线段树中将整个矩形全部区间覆盖为对应的颜色即可，因为我们查询时只会查询 $x+y$ 的奇偶性对应的线段树，我们只需保证对应线段树维护的所在位置的颜色是正确的，而不需要考虑其他位置是否正确。  
还有一个问题，就是如何保证已经覆盖过的位置不再被覆盖，我们考虑对于线段树节点 $x$ 和对应的值 $c_x$，假设初值为 $0$，那么当 $c_x$ 不为 $0$ 时说明当前矩形中的点全部被覆盖，直接返回即可。  
但是这样就会有一个问题，就是可能我们先覆盖了一个大矩形中的一部分，但是后来这个大矩形整个被覆盖了，我们查询时就会出错。  
对于这个问题，我们可以想到，对于小矩形，它的修改一定在大矩形之前，为什么呢？  
考虑这样一件事，如果小矩形的修改在大矩形之后，那么它一定会在到达对应的修改区间之前就返回了。  
可以自己思考一下上面这句话的合理性。  
那么我们现在就解决了问题的大半了，接下来……就是二维线段树的环节了。  
我们假设当前节点对应的矩形的左下角为 $(x_L,y_L)$，右上角为 $(x_R,y_R)$，那么我们就按照长边把这个矩形分成两半即可。  
注意二维线段树的传参极其复杂，如果你不想写的话，宏定义是个好东西。
```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=1e6+5,M=1e5+5;
int n,k,m,cnt,tot;
char opt[15];
int pos[M],ans[1005][1005];
struct Query{
	int opt;
	int a1,b1,a2,b2,c;
}a[M];
bool check(int xl1,int xr1,int yl1,int yr1,int xl2,int xr2,int yl2,int yr2){
	if(max(xl1,xl2)>min(xr1,xr2))return false;
	if(max(yl1,yl2)>min(yr1,yr2))return false;
	return true;
}
struct Segment_tree{
	int c[N<<2];
	#define ls p<<1
	#define rs p<<1|1
	#define lsonx ls,xl,mid,yl,yr
	#define rsonx rs,mid+1,xr,yl,yr
	#define lsony ls,xl,xr,yl,mid
	#define rsony rs,xl,xr,mid+1,yr
	#define inquire xL,xR,yL,yR
	void change(int p,int xl,int xr,int yl,int yr,int xL,int xR,int yL,int yR,int col){
		if(c[p])return ;
		if(xL<=xl&&xr<=xR&&yL<=yl&&yr<=yR){
			c[p]=col;
			return ;
		}
		if(xr-xl>yr-yl){
			int mid=(xr+xl)>>1;
			if(check(xl,mid,yl,yr,inquire))change(lsonx,inquire,col);
			if(check(mid+1,xr,yl,yr,inquire))change(rsonx,inquire,col);
		}else{
			int mid=(yr+yl)>>1;
			if(check(xl,xr,yl,mid,inquire))change(lsony,inquire,col);
			if(check(xl,xr,mid+1,yr,inquire))change(rsony,inquire,col);
		}
	}
	void copy(int p,int xl,int xr,int yl,int yr,int v,bool flag){
		if(c[p])v=c[p];
		if(xl==xr&&yl==yr){
			if(((xl+yl)&1)==flag)ans[xl][yl]=v;
			return ;
		}
		if(xr-xl>yr-yl){
			int mid=(xr+xl)>>1;
			copy(ls,xl,mid,yl,yr,v,flag),copy(rs,mid+1,xr,yl,yr,v,flag);
		}else{
			int mid=(yr+yl)>>1;
			copy(ls,xl,xr,yl,mid,v,flag),copy(rs,xl,xr,mid+1,yr,v,flag);
		}
	}
}Set[2];
signed main(){
	read(n),read(k),read(m);
	for(int i=1;i<=m;i++){
		scanf("%s",opt+1);
		if(opt[1]=='S'){
			a[i].opt=1;
			pos[++cnt]=i;
		}else if(opt[1]=='L'){
			a[i].opt=2;
			read(a[i].c);
		}else{
			a[i].opt=0;
			read(a[i].c),read(a[i].a1),read(a[i].b1),read(a[i].a2),read(a[i].b2);
			a[i].a1++,a[i].a2++;
			a[i].b1++,a[i].b2++;
		}
	}
	for(int i=m;i>=1;i--){
		if(a[i].opt==1)continue;	
		if(a[i].opt==2)i=pos[a[i].c];
		else Set[(a[i].a1+a[i].b1)&1].change(1,1,n,1,n,a[i].a1,a[i].a2,a[i].b1,a[i].b2,a[i].c);
	}
	Set[0].copy(1,1,n,1,n,0,0);
	Set[1].copy(1,1,n,1,n,0,1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)write(ans[i][j]?ans[i][j]:1),Spa;
		Nxt;
	}
}
```

---

## 作者：hnczy (赞：3)

分享一个超快的解法，最优解，次优解，次次优解，次次次优解，次次次次优解的解法（没错目前都是我）。

这里可以使用一个二维线段树维护两个二位线段树来分别记奇数格和偶数格的颜色，这里的奇偶性就是 $x+y$ 的奇偶性。当然这里没必要线段树里只记它需要记的，把全部的记下来，在存储的时候判断即可。

这里着重写一下二维线段树的写法，其实很简单，直接判断一下 $rx-lx$ 和 $ry -rx $ 的大小，先折半长边即可。

比如这里的修改就可以这样写：

```c++
inline void change(int p,int lx,int rx,int ly,int ry,int &Lx,int &Rx,int &Ly,int &Ry,int &w) {
		if(rx <lx ||ry<ly )return ;
		if(co[p])return;
		if(Lx<=lx && rx <=Rx && Ly<=ly && ry <=Ry) {
			co[p]=w;
			return ;
		}
		if(rx-lx > ry -ly) {
			int mid =(lx+rx) >>1;
			if(Lx<=mid)change(ls,lx,mid ,ly,ry,Lx,Rx,Ly,Ry,w);
			if(Rx>mid)change(rs,mid+1,rx,ly,ry,Lx,Rx,Ly,Ry,w);
		} else {
			int mid =(ly+ry) >>1;
			if(Ly<=mid)change(ls,lx,rx ,ly,mid,Lx,Rx,Ly,Ry,w);
			if(Ry>mid)change(rs,lx,rx,mid+1,ry,Lx,Rx,Ly,Ry,w);
		}
	}
```



后面用引用卡一点常。

最后对每一个点赋值的时候直接对两个线段树 `dfs` 下去即可。

当然因为如果你正着写需要 `pushup` 和 `pushdown`  而反着写就根本不需要，而且遇到一个有颜色的区间直接 `return` 即可。因为后面会直接把这个区间覆盖掉。

这样的话常数就很小。

附代码：

```c++
#include<bits/stdc++.h>
#define LOCAL
#define ls p<<1
#define rs p<<1|1
using namespace std;
const int N=1E5+5,M=1e6+5;
using namespace std;

namespace ly
{
    namespace IO
    {
        
        template<typename type>
        inline void read(type &x)
        {
            x=0;bool flag(0);char ch=getchar();
            while(!isdigit(ch)) flag^=ch=='-',ch=getchar();
            while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
            flag?x=-x:0;
        }
        template<typename type>
        inline void write(type x)
        {
            x<0?x=-x,putchar('-'):0;static short Stack[50],top(0);
            do Stack[++top]=x%10,x/=10;while(x);
            while(top) putchar(Stack[top--]|48);
        }
    }
}using namespace ly::IO;
int n,m,k;
int opt[N],xi[N],yi[N],xx[N],yy[N],c[N],p[N],l[N],nowcol;

int a[1005][1005];
struct SEG {
	int co[M<<2];
	inline void change(int p,int lx,int rx,int ly,int ry,int &Lx,int &Rx,int &Ly,int &Ry,int &w) {
		if(rx <lx ||ry<ly )return ;
		if(co[p])return;
		if(Lx<=lx && rx <=Rx && Ly<=ly && ry <=Ry) {
			co[p]=w;
			return ;
		}
		if(rx-lx > ry -ly) {
			int mid =(lx+rx) >>1;
			if(Lx<=mid)change(ls,lx,mid ,ly,ry,Lx,Rx,Ly,Ry,w);
			if(Rx>mid)change(rs,mid+1,rx,ly,ry,Lx,Rx,Ly,Ry,w);
		} else {
			int mid =(ly+ry) >>1;
			if(Ly<=mid)change(ls,lx,rx ,ly,mid,Lx,Rx,Ly,Ry,w);
			if(Ry>mid)change(rs,lx,rx,mid+1,ry,Lx,Rx,Ly,Ry,w);
		}
	}
	inline void dfs(int p,int lx,int rx,int ly ,int ry,int &id,int nowcol) {
		//cout<<nowcol<<endl;
		if(co[p]!=0)nowcol=co[p];
		if(lx==rx && ly ==ry ) {
			if(id==1) {
				if(((lx+ly)&1)^1)return;
				a[lx][ly]=nowcol;
			} else {
				if((lx+ly)&1)return;
				a[lx][ly]=nowcol;
			}
			return ;
		}
		if(rx-lx > ry -ly) {
			int mid =(lx+rx) >>1;
			dfs(ls,lx,mid ,ly,ry,id,nowcol);
			dfs(rs,mid+1,rx,ly,ry,id,nowcol);
		} else {
			int mid =(ly+ry) >>1;
			dfs(ls,lx,rx ,ly,mid,id,nowcol);
			dfs(rs,lx,rx,mid+1,ry,id,nowcol);
		}
	}
} seg[2];
char s[10];
signed main() {
	read(n),read(k),read(m);
	int cnt=0;
	for(int i=1,t; i<=m; ++i) {
		scanf("%s",s+1);
		if(s[1]=='P')opt[i]=1;
		else if(s[1]=='S')opt[i]=2;
		else opt[i]=3;
		if(opt[i]==1)
			read(c[i]),read(xi[i]),read(yi[i]),read(xx[i]),read(yy[i]),xi[i]++,xx[i]++,yi[i]++,yy[i]++;
		if(opt[i]==2)
			p[++cnt]=i;
		if(opt[i]==3)
			read(t),l[i]=p[t];
	}
	for(int t=m; t; --t) {
		if(opt[t]==3)t=l[t];
		else if(opt[t]==1) {
			if((xi[t]+yi[t])%2==1)
				seg[1].change(1,1,n,1,n,xi[t],xx[t],yi[t],yy[t],c[t]);
			else
				seg[0].change(1,1,n,1,n,xi[t],xx[t],yi[t],yy[t],c[t]);
		}
	}
	int p=0;
	seg[0].dfs(1,1,n,1,n,p,0);
	p=1;
	seg[1].dfs(1,1,n,1,n,p,0);
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			if(!a[i][j])putchar(49);
			else write(a[i][j]);
			putchar(32);
		}
		puts("");
	}
	return 0;
}
```

思路可能和 `qwer6` dalao 一样，因为是同个老师教的。

---

## 作者：☯☯枫☯☯ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7636)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/14940590.html)

这道题主要还是考一个想法。

**算法分析：逆序操作+并查集**

首先考虑按照题意模拟整个过程。单次 ```PAINT``` 指令时间复杂度为 $\mathcal{O}(n^2)$，一共有 $M$ 个指令，总复杂度为 $\mathcal{O}(n^2M)$，显然不能承受。期间有 ```SAVE``` 指令，单次时空复杂度均为 $\mathcal{O}(n^2)$，总时空复杂度为 $\mathcal{O}(n^2M)$，在时空上均不能承受。按原题数据范围，暴力做法预计得分 50pts。

首先考虑优化空间。

我们回顾一道题 [Poj-2528 Mayor's posters](http://poj.org/problem?id=2528)，这道题是说在一个展板上依次贴海报，问最后能看到的海报有哪些。在这道题中，我们采用了**按时间从后往前**操作的技巧。因为后贴的一定在上面，因此不必改变。在贴较早的海报时，只需考虑是否存在空位即可。

在本题中，我们同样可以采用从后往前染色的方法**逆序操作**。事先储存所有的指令，并记录每一个 ```SAVE``` 指令的位置。遇到 ```LOAD``` 指令时，直接跳过中间的所有步骤，从对应的 ```SAVE``` 指令开始往前操作。这样就无需用 $\mathcal{O}(n^2M)$ 的空间存下之前 ```SAVE``` 的状态，只需记录当前的状态。最后直接输出即可。

在优化完空间后，时间复杂度仍为 $\mathcal{O}(n^2M)$。接下来我们考虑优化时间。

事实上，可优化的仅有 ```PAINT``` 这一个指令。前面说过，逆序操作时，已经被染色的格子不会再次被染色，因此在执行 ```PAINT``` 指令时，可以考虑**跳过已经被染过色的格子**。这里提供一种利用并查集的做法。

首先为每一行建立一个并查集。染色时，将染色区域第 $k$ 个格子与第 $k+2$ 个格子并到一起。当再次扫描到 $k$ 时，直接从 $fa_k$ 开始染色。这样就直接跳过了 $k\to fa_k$ 这一部分的格子。需要注意的时，在合并时，需要**将右侧的格子作为新的根**，即将 $k$ 合并到 $k+2$ 中，这样才能在下一次操作时定位到正确的位置。

 另外，可以用链表或者 ```STL_set``` 来替代并查集的作用。但综合分析三者优缺点，链表的开始位置不易寻找，且代码调试难度相对较大，```STL-set``` 查询的时间复杂度为 $\mathcal{O}(\log_2(n))$，比前两者都大，容易超出时间限制。因此无论从码量或是时间上并查集都是较为合适的选择。

下面给出代码：

```cpp
#include<bits/stdc++.h>
#define reg register
#define F(i,a,b) for(reg int i=a;i<=b;++i)
using namespace std;
inline int read();
const int N=1e3+10,M=1e5+1;
int n,k,m,a[N][N],sav[M],cnt;
struct Union_set {//并查集 
	int fa[N];
	Union_set(){
		F(i,1,N-1)fa[i]=i;
	}
	int find(int x) {//找代表元 
		return fa[x]==x?x:fa[x]=find(fa[x]);
	}
	inline void add(int u,int v){
		u=find(u),v=find(v),fa[u]=v;
	}//将 u 合并到 v 下 
} f[N];
struct Comd {//储存指令 
	char c[10];
	int k,x1,x2,y1,y2;
	inline void inp() {
		scanf("%s",c+1);
		if(c[1]!='S')k=read();
		if(c[1]=='P')x1=read()+1,y1=read()+1,x2=read()+1,y2=read()+1;
	}
} Com[M];
inline void paint(Comd cur){//染色 
	reg int y;
	F(i,cur.x1,cur.x2){
		y=cur.y1+((i-cur.x1)&1);
		//y 为本行开始染色的位置 
		for(reg int k=f[i].find(y);k<=cur.y2;k=f[i].find(k)){
			a[i][k]=cur.k;//染色 
			f[i].add(k,k+2);//向右合并 
		}
	}
}
int main() {
	n=read(),k=read(),m=read();
	F(i,1,n)F(j,1,n)a[i][j]=1;
	F(i,1,m) {
		Com[i].inp();
		if(Com[i].c[1]=='S')sav[++cnt]=i;//储存 SAVE 指令的位置 
	}
	for(reg int i=m;i;--i){
		Comd& cur=Com[i];
		if(cur.c[1]=='S')continue;
		if(cur.c[1]=='L')i=sav[cur.k];
		if(cur.c[1]=='P')paint(cur);
	}
	F(i,1,n){
		F(j,1,n)printf("%d ",a[i][j]);
		putchar('\n');
	}
	return 0;
}
inline int read() {
	reg int x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
```

[AC](https://www.luogu.com.cn/record/52128705)

欢迎交流讨论，请点个赞哦~

---

## 作者：Silence_water (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7636)

---

$1)$ 当 $n\le 100,m\le3500$ 时

采用直接模拟的方法。由于版本之间需要时时切换，考虑用结构体直接存下一个版本，每次 save 时放入 vector 中，方便 load 时的查找。同时记录当前的版本，做 paint 操作时直接在当前版本上修改即可。

```cpp
for(int i=1;i<=m;i++)
{
	char s[8];
	scanf("%s",s);
	if(s[0]=='P')paint();
	else if(s[0]=='S')
		his.push_back(now);
	else if(s[0]=='L')
	{
		int x;scanf("%d",&x);
		now=his[x-1];
	}
}
```

---

$2)$ 当 $n\le 1000,m\le 10^5$ 时

在画面的一次次修改、保存、回档中，我们发现有些操作是没必要进行的。如样例 $2$ 中，在进行 `LOAD 1` 操作后，第二次未保存的 paint 操作便成了无效操作。

但是否在读入过程中就能判断出哪些操作是无效的呢？答案是不能的。考虑下面一系列操作：

```
PAINT
SAVE
PAINT
SAVE
LOAD 1
PAINT
LOAD 2
```

在进行 `LOAD 1` 操作后，虽然回到了第一次存档时的画面，但后面的 `LOAD 2` 操作回到第二次存档时的画面。而在两次存档之间的操作，虽然在 `LOAD 1` 时不会用到，但仍对答案造成影响。

因此从前往后扫无法判断出不需要哪些操作，而从后往前扫就能得到有效的染色指令。如上面的例子中，我们先遇到 `LOAD 2` 然后跳至第二处存档，继续往前扫，最后得出只有第一和第二次染色是有效的。

```cpp
for(int i=1;i<=m;i++)
{
	qq[i].init();
	if(qq[i].s[0]=='S')
		sav[++cnt]=i;// 记录第cnt次存档对应的位置，便于跳回
}
for(int i=m;i>0;i--)
{
	if(qq[i].s[0]=='S')continue;// 跳过存档处
	if(qq[i].s[0]=='L')i=sav[qq[i].to];
	if(qq[i].s[0]=='P')paint(qq[i]);
}
```

注意到上述代码直接在从后往前扫时就进行了有效的染色操作。思考一下，如果这些操作从前往后去做，前面染过的颜色可能被后面重新染而改变，仍然需要一个一个去染，如果所有的操作都为 `PAINT x 0 0 999 999 `，单次染色的复杂度就高达 $O(5\times 10^5)$，无法承受。

而从后往前去染色，我们只需要染上没有被染过的区域，从而减少重复染色所带来的巨大复杂度。而如何跳过被染过的区域，到达下一个未染过且需要被染色的区域呢？这里使用并查集来实现这一操作。

用并查集来维护每行中每个格子的下一个未被染色的格子。初始化中下一个未染色的即为本身，而在当前该格子被染后，我们需要与下一个可能被染色的格子建立联系，即 `li[i].Union(j,j+2)`，通过语句 `j=li[i].find(j)` 来到达下一个未被染色的点，从而实现操作。

```cpp
void paint(query zo)
{
	int x=zo.x,xx=zo.xx,y=zo.y,yy=zo.yy,c=zo.c;
	for(int i=x;i<=xx;i++)
		for(int j=li[i].find(y+((i-x)&1));j<=yy;j=li[i].find(j))
		{
			co[i][j]=c;
			li[i].Union(j,j+2);
		}
	return;
}
```

注意：在语句 `li[i].Union(j,j+2)` 中，$j+2$ 可能要大于 $n-1$，如果在并查集的初始化中不对 $n$ 和 $n+1$ 两个区域进行初始化，就会导致 $j$ 可能成为 $0$ 而陷入死循环。

---

[AC Code](https://www.luogu.com.cn/record/52132473) 代码中根据个人习惯坐标都 $+1$。

---

## 作者：内拉组里 (赞：0)

# Pts 60

题目设计 **save** 和 **load** 操作，所以需要考虑一种数据结构存储每一步操作，并保留顺序。

显然需要把每个操作先保存下来，最后再把对答案有影响的操作按顺序执行。

这里采用 **queue** 存储。

非常暴力，开 $ m $ 个队列存储每个画布存档，用一个变量 $ cnt $ 记录当前打开的存档。

- **paint**，直接往当前存档里 **push** 一个操作。
- **save**，把当前的存档 **copy** 到新的存档，然后打开新的存档，把 $ cnt + 1 $ 即可。
- **load**，把指定的存档 **copy** 到当前存档，因为此处以后的操作不能直接写入指定的存档。

最后再把当前存档一个一个拿出来，

在 $ x \in [x1,x2],y \in [y1,y2] $ 的矩形中把到 $ (x1,y1) $ 曼距为偶数的点涂色即可。

## Details：

- 注意下标从 $ 0 $ 开始。

## Analyses：

> 总时间复杂度 $ \Theta (N^2M) $。
>
> 总空间复杂度 $ \Theta (N^2 + M) $。

***

# Pts 100

时间复杂度瓶颈在于每次 **paint** 都要 $ \Theta (N^2) $ 地扫整张图，或许跳过有些点能更快一些。

考虑倒着做。

分行处理，每行中维护一个 **DSU**，把覆盖过的节点 **unite** 在一起。

**DSU** 中每个节点的根节点就是当前连通分量最右边的节点，

遍历到 $ (x,y) $ 时将 $ (x,y + 2) $ **unite** 在一起，然后往当前根节点跳即可

这样所有被覆盖过的节点都会被跳过，也就是每个节点只会被覆盖一次。

## Detail：

- **DSU** 初始化时记得多 **init** 几个，以防 **unite** 时越界。

## Analyses：

> 总时间复杂度 $ \Theta (N^2 + M) $。
>
> 总空间复杂度 $ \Theta (N^2 + M) $。

# Code：

```cpp
/* reference : @Luogu.433518 */
#include	<iostream>
#include	<vector>
#include	<queue>
#define		int		long long
using namespace std;
constexpr int maxn = 1e3+4;
constexpr int maxm = 1e5+4;

namespace pts60
{
	struct rect
	{
		int c, x1, y1, x2, y2;
	};
	int G[maxn][maxn];
	int n, m, k, cnt = 1;
	queue<rect> rc[maxm];
	
	inline int dist (int x1, int y1, int x2, int y2)
	{
		return abs (x1 - x2) + abs (y1 - y2);
	}
	
	signed main (void)
	{
		cin >> n >> k >> m;
		while (m--)
		{
			string op;
			cin >> op;
			if (op == "PAINT")
			{
				int c, x1, y1, x2, y2;
				cin >> c >> x1 >> y1 >> x2 >> y2;
				rc[cnt].push({c, x1 + 1, y1 + 1, x2 + 1, y2 + 1});
			}
			else if (op == "SAVE")
			{
				rc[cnt + 1] = rc[cnt];
				cnt++;
			}
			else			/* LOAD */
			{
				int idx;
				cin >> idx;
				rc[cnt] = rc[idx];
			}
		}
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				G[i][j] = 1;
			}
		}
		while (!rc[cnt].empty())
		{
			rect now = rc[cnt].front(); rc[cnt].pop();
			for (int i = now.x1; i <= now.x2; i++)
			{
				for (int j = now.y1; j <= now.y2; j++)
				{
					if (!(dist (i, j, now.x1, now.y1) & 1))
					{
						G[i][j] = now.c;
					}
				}
			}
		}
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				cout << G[i][j] << ' ';
			}
			cout << endl;
		}
		return 0;
	}
}

namespace pts100
{
	struct qry
	{
		string op;
		int c, x1, y1, x2, y2;
	}q[maxm];
	struct DSU
	{
		int rt[maxn];
		
		void init (int n)
		{
			for (int i = 1; i <= n; i++)
			{
				rt[i] = i;
			}
		}
		
		int find (int x)
		{
			if (rt[x] == x) return x;
			return rt[x] = find (rt[x]);
		}
		
		void unite (int x, int y)
		/* x <- y */
		{
			x = find (x);
			y = find (y);
			rt[x] = y;
		}
	}row[maxn];
	int n, m, k;
	queue<int> ans;
	vector<int> save;
	int G[maxn][maxn];
	
	inline int dist (int x1, int y1, int x2, int y2)
	{
		return abs (x1 - x2) + abs (y1 - y2);
	}
	
	signed main (void)
	{
		cin >> n >> k >> m;
		for (int i = 1; i <= m; i++)
		{
			cin >> q[i].op;
			if (q[i].op == "PAINT") cin >> q[i].c >> q[i].x1 >> q[i].y1 >> q[i].x2 >> q[i].y2;
			else if (q[i].op == "LOAD") cin >> q[i].c;
			else save.push_back(i);
		}
		for (int i = m; i; i--)
		{
			if (q[i].op == "PAINT") ans.push(i);
			else if (q[i].op == "LOAD") i = save[q[i].c - 1] + 1;
		}
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				G[i][j] = 1;
			}
		}
		for (int i = 1; i <= n; i++) row[i].init(n + 2);
		while (!ans.empty())
		{
			int now = ans.front(); ans.pop();
			q[now].x1++;
			q[now].x2++;
			q[now].y1++;
			q[now].y2++;
//			cout << now << endl;
			for (int i = q[now].x1; i <= q[now].x2; i += 2)
			{
				for (int j = row[i].find(q[now].y1); j <= q[now].y2; j = row[i].find(j))
				{
					G[i][j] = q[now].c;
					row[i].unite(j, j + 2);
				}
			}
			for (int i = q[now].x1 + 1; i <= q[now].x2; i += 2)
			{
				for (int j = row[i].find(q[now].y1 + 1); j <= q[now].y2; j = row[i].find(j))
				{
					G[i][j] = q[now].c;
					row[i].unite(j, j + 2);
				}
			}
		}
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				cout << G[i][j] << ' ';
			}
			cout << endl;
		}
		return 0;
	}
}

signed main (void)
{
	return pts100::main ();
}
```

---


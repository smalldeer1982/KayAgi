# [COCI 2012/2013 #5] ROTIRAJ

## 题目描述

给定一个长度为 $N$ 的序列，将其划分，使每个子序列正好有 $K$ 个数（保证 $K$ 能被 $N$ 整除），有两种操作：

- 一、将每个序列中的数字向左/向右移动 $X$ 个位置

- 二、将整个序列向左/向右移动 $X$ 个位置

注意只有操作二才能改变子序列中的数字。

现给出所有操作后得到的序列和所有操作，请你求出原始序列。

## 说明/提示

**【样例解释#1】**

起始序列是 $[0,1,2,3]$，第一个操作后变为 $[2,3,0,1]$，第二个操作后变为 $[3,2,1,0]$。


------------

**【数据范围】**

对于 $40\%$ 的数据，$1\le N\le 100$；

对于 $70\%$ 的数据，$1\le K\le 100$；

对于 $100\%$ 的数据，$1\le N\le 10^5$，$1\le N\le 10^5$，$1\le Q\le 10^5$，$1\le A_i\le 2$，$-10^5\le X_i\le 10^5$，$0\le Z_i\le 10^5$。


------------

**【说明】**

本题分值按 COCI 原题设置，满分 $140$。

题目译自 [COCI2012_2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #5](https://hsin.hr/coci/archive/2012_2013/contest5_tasks.pdf) _**T5 ROTIRAJ**_。

## 样例 #1

### 输入

```
4 2 2
2 2
1 1
3 2 1 0```

### 输出

```
0 1 2 3```

## 样例 #2

### 输入

```
8 4 4
1 3
1 15
1 -5
2 -1
6 10 14 19 2 16 17 1```

### 输出

```
6 10 14 1 2 16 17 19```

## 样例 #3

### 输入

```
9 3 5
1 1
2 -8
2 9
1 1
2 -4
3 1 8 7 4 5 2 6 9```

### 输出

```
5 3 6 9 7 1 8 2 4```

# 题解

## 作者：loveJY (赞：9)

建议重写题面

# 题意:

长度为 $N$ 的序列,从左向右每 $k$ 个位置切一刀分割成 $\frac{n}{k}$ 个区间,保证 $k|n$

第一类操作为每个子序列左/右移 $k$ 位

第二类操作为所有位置左/右移 $k$ 位

然后两类操作均为循环移位,即1234左移后变为2341

给出 $Q$ 次操作后的序列,求操作前的序列

$N,Q,k\leq 100000$
## Part1

观察到该操作具有可逆性,因此只需要把 $Q$ 次操作倒序回去左右颠倒后对于目标序列做一遍,得到的就是初始序列
## Part2

考虑根号分治,当 $k>\sqrt n$ 的时候我们可以对于枚举每一块并进行操作

显然不能直接循环移位,因此考虑维护块内真实的开头指针

整体左移则是上一块的开头会放入这一块的结尾,并且这一块的开头会消失,可以直接将上一块开头放入这一块开头并将指针移动,整体右移同理.

若 $k<\sqrt n$ ,我们需要维护 $\bmod k$ 同余的所有位置,不难发现他们之间的相邻数的相对距离不会发生改变,因此我们只需要记录每个 $\bmod k$ 同余的位置中第一块的开头到底是什么数即可,在整体左右移动的时候仍然需要改指针和这个数组的信息.

复杂度为 $O(q\sqrt n)$ ,但是只要下手写一下你就会发现一个线性做法
## Part3

考虑我们 $k\leq\sqrt n$ 的部分,对于他们的操作复杂度似乎仅仅在于一个```第一块开头```是什么数组的维护

而这个数组可以记录 $dis$ 表示第一块开头真实值是维护 $dis*k+a$ 位置

那么我们每次整体移动操作,就仅仅相当于对于 $dis$ 数组循环走过 $x_i$ 步(比如向右走,就是在走过结尾的时候自动跳到开头)并把经过的数都+1,然后把指针整体移动 $x_i$ 步

而这个过程显然可以用差分数组来优化!

因此本题也就做完了,对于二操作直接差分,一操作只是简单的循环位移而已

# 代码

```cpp


#include<bits/stdc++.h>
#define pb push_back
#define vi vector<int>
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
int n, k, q;
int typ[MAXN], x[MAXN], a[MAXN];
ll pos[MAXN];
vi b[MAXN];
inline void IO() {
	scanf("%d%d%d", &n, &k, &q);
	for(int i = 1; i <= q; ++i) {
		scanf("%d%d", &typ[i], &x[i]);
		x[i] = -x[i];
	}
	reverse(typ + 1, typ + q + 1);
	reverse(x + 1, x + q + 1);
	for(int i = 0; i < n; ++i) {
		scanf("%d", &a[i]);
		b[i % k].pb(a[i]);
	}
	return;
}

inline void solve1() {
	int hd = 0;
	for(int i = 1; i <= q; ++i) {
		if(typ[i] == 1) {
			hd = ((hd - x[i]) % k + k) % k;
		} else {
			if(x[i] < 0) {
				int q = -x[i];
				if(q <= k - hd) {
					pos[hd]++;
					pos[hd + q]--;
				} else {
					--q;
					pos[hd]++;
					q -= k - hd;
					if(q >= k) {
						pos[0] += q / k;
						q = q % k;
					}
					pos[0]++;
					pos[q + 1]--;
				}
			} else {
				int q = x[i];
				int tl = (hd - 1 + k) % k;
				if(q <= tl) {
					pos[tl - q + 1]--;
					pos[tl + 1]++;
				} else {
					--q;
					pos[0]--;
					pos[tl + 1]++;
					q -= tl;
					if(q >= k) {
						pos[0] -= q / k;
						q = q % k;
					}
					pos[k - q]--;
				}
			}
			hd = (hd - x[i] % k + k) % k;
		}
	}
	for(int i = 1; i < k; ++i)pos[i] += pos[i - 1];
	for(int i = 0; i < n; i += k) {
		for(int j = hd;; j = (j + 1) % k) {
			printf("%d ", b[j][(i / k + pos[j] % (n / k) + n / k) % (n / k)]);
			if((j + 1) % k == hd)break;
		}
	}
	puts("");
	return ;
}

int main() {
	IO();
	solve1();
	return 0;
}


```

---

## 作者：__log__ (赞：3)

奇怪的翻译，就没人管管吗？

#

## 题意

把长度为 $n$ 的序列按下标分为 $\frac{n}{k}$ 组，每组 $k$ 个数。对其进行两种操作：

1. 把每一组一端的数取出，放到另一端，重复 $x$ 次；
2. 把整个序列一端的数取出，放到另一端，重复 $x$ 次。

给定各操作与操作后序列，求原序列。

## Subtask 1 $n \le 100$ 

暴力，可以获得 $O(nq)$ 的优秀复杂度与高达 40pts 的分数。

## Subtask 2 $k \le 100$

观察每次操作后的每一组，把这些数字对 $k$ 取模，发现如下：

1. 所有组开头数字的余数相同，同一组内余数都是这么转的：![](https://cdn.luogu.com.cn/upload/image_hosting/goaobvub.png)
2. $a_{i} \equiv a_{i+k} \equiv a_{i+2k} \equiv \cdots \pmod k$。
3. 这堆同余的数也是类似的排法：![](https://cdn.luogu.com.cn/upload/image_hosting/lwvt6fae.png)

所以我们用 $pos$ 指针来记录每一组开头是哪一种余数，用 $s_i$ 来表示每一种余数是哪个数作为开头的。

然后每一步稍微操作一下这些指针就 ok 了。复杂度 $O(qk)$。

## Subtask 3 $n \le 10^5$

完了不会怎么办？打开题解看一看。看得云里雾里怎么办？~~凉拌~~

> 而这个数组可以记录 $dis$ 表示第一块开头真实值是维护 $dis \times k + a$ 位置。
>
> 那么我们每次整体移动操作，就仅仅相当于 $dis$ 数组循环走过 $x_i$ 步（比如向右走，就是在走过结尾的时候自动跳到开头）并把经过的数都 $+1$，然后把指针整体移动 $x_i$ 步。
>
> ——抄自 [this](https://www.luogu.com.cn/article/uwvmjm2r)

通过上篇 tj 的这段话得到：我们复杂度主要来自修改 $s_i$，而这东西每次是区间修改一片**连续**区间的（尽管只是在**环**上），所以可以用**差分**优化到 $O(q)$。

## Code

```cpp
# include <bits/stdc++.h>
# define maxn 100100
# define rep(i, j, k) for(int i = j; i <= k; ++i)
# define per(i, j, k) for(int i = j; i >= k; --i)
using namespace std;

int n, k, q, pos = 1;
int a[maxn], x[maxn]; // 操作序列
int val[maxn]; // 最后的序列
int d[maxn], rnk[maxn], ans[maxn]; // ans 为最初序列，d为维护的 s 数组的差分序列
vector<int> que[maxn]; //que[i] 表示对 k 取模余数为 i 的数。

inline int Mod(int x, int t) {return (x % t == 0) ? t : x % t;} // 特制的取模函数

signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> k >> q; d[1]++; // 初始每一种余数都是从第一个开始的
    // 全部转化为向左移动
    rep(i, 1, q) cin >> a[i] >> x[i], x[i] = abs((a[i] == 1) ? (x[i] % k - k) % k : (x[i] % n - n) % n);
    rep(i, 1, n) cin >> val[i], que[Mod(i % k + k, k)].push_back(i);
    rep(i, 1, q) {
        if(a[i] == 1) {pos = Mod(pos + x[i], k); continue;} // 操作 1
        d[1] += x[i] / k; x[i] %= k; // 先移动 [x/k]*k，全部 s[i] 加上 [x/k]（下取整）
        if(pos + x[i] - 1 <= k) d[pos]++, d[pos + x[i]]--;
        else d[pos]++, d[1]++, d[Mod(pos + x[i], k)]--;
        pos = Mod(pos + x[i], k); // 稍微维护一下乱七八糟的事
    }
    rep(i, 1, k) d[i] += d[i - 1];
    rep(i, 1, k) d[i] = Mod(d[i], n / k) - 1; // 复原 s[i] 数组
    // rnk[i] 表示位置为 i 的数在初始序列的排名
    // 通过一些抽象操作就搞好了
    for(int i = 1, p, q; i <= n; i += k) {
        int t = pos;
        rep(j, 1, k) {
            rnk[i + j - 1] = que[t][d[t]];
            d[t]++; if(d[t] == n / k) d[t] = 0; // 变成下一个与现在同余的数
            t++; if(t > k) t = 1; // 这个位置的余数
        }
    }
    rep(i, 1, n) ans[rnk[i]] = val[i];
    rep(i, 1, n) cout << ans[i] << ' ';
    cout << "\n";
    return 0;
}
```

---

## 作者：steambird (赞：0)

## 思路

这里对 $K$ 较大的情况提供题解区目前没有的思路。

### Step 1. 确定大致方向

首先观察到操作可逆，原序列可以通过倒着做一遍操作（做的过程中把左右互换，即模拟时认为 $X > 0$ 表示向左，$X < 0$ 表示向右）得到。

看到这种修改/查询类问题，考虑数据结构。但是，普通的数据结构难以实现数字的移动。由于本题要求对分段后的每一段进行操作，考虑类似分块的思想，预期时间复杂度 $O(N \sqrt N)$ 左右。接下来，让我们从部分分出发考虑。

**下面所述的所有下标均从 $0$ 开始。**

### Step 2. 推导 $N \le 100$ 的做法

对应 $40\% $ 的部分分。

对于这部分数据，考虑对于每个初始下标 $i$，经过下面 $Q$ 次变换，求出最终的下标：

- 设 $|X| < K$，操作一对应 $q \leftarrow K \times \lfloor {q \over K} \rfloor + ((q \bmod K - X + K) \bmod K)$；
- 设 $|X| < N$，操作二对应 $q \leftarrow (q - X + N) \bmod N$。

时间复杂度 $O(NQ)$，注意如果 $|X|$ 较大，用 C++ 取模时需要写：

```c++
inline int feed_mod(int a, int b) {
  //	(a%b) 或 a - (a/b) 都是错的;
	if (a < 0) {
		return -((-a) % b);
	} else return a%b;
}
```

### Step 3. 推导 $K \le 100$ 的做法

对应 $70\%$ 的部分分。

观察一个性质：对于两个下标 $a,b$，如果操作前 $a \equiv b \pmod K$，则始终有 $a \equiv b \pmod K$，即所有模 $K$ 同余的位置对应的数的相对位置保持不变。这是因为，设 $a=x_{1}k+s, b=x_{2}k+s$，则有：

- 对于操作一，其可以被表示为 $s \leftarrow (s-X+K) \bmod K$；
- 对于操作二，其可以被表示为 $s \leftarrow (s-X+N) \bmod N$。

因此，我们可以优化 Step 2 中提出的做法：我们不需要模拟全部 $N$ 个下标，而只需要模拟 $K$ 个，通过计算这 $K$ 个的最终位置，再从这些位置出发每次跳 $K$ 步，得到所有模 $K$ 与之同余的初始位置对应的最终位置。时间复杂度 $O(KQ)$。

### Step 4. 推导 $K$ 较大时的做法

Step 3 中做法的缺陷是，如果 $K$ 较大，其时间复杂度将不佳。

注意到如果 $K$ 较大，则总块数 $B={N \over K}$ 将较小，意味着我们可以对每块处理。考虑通过 FHQ Treap 实现此类移动：

- 对于操作一，每次我们先建立一棵空 Treap，从表示当前序列的 Treap 上截取（即 split 操作）出前 $K$ 个节点，并将取出的子树中的前 $(X+K) \bmod K$ 个节点移到右侧，再与新建的 Treap 合并。单次时间复杂度 $O(B \log N)$。
- 对于操作二，我们直接将当前 Treap 上的前 $(X+N) \bmod N$ 个节点移到右侧。单次时间复杂度 $O(\log N)$。

这样，总时间复杂度 $O(QB \log N)$。

### Step 5. 考虑最终做法

将 $B$ 带入，如果我们缝合 Step 3 和 Step 4 中推导的做法，我们的复杂度即为 $O(\min(KQ,{{NQ \log N} \over K}))$。结合分块的知识可知 $K \approx \sqrt N$ 时取到最优复杂度，大约为 $O(NQ \sqrt N \log N)$，在常数较为优秀的情况下可以通过本题。

## 代码

代码中 `solve1` 函数对应 Step 3 的做法，`solve2` 函数对应 Step 4 的做法。

```c++
#include <bits/stdc++.h>
using namespace std;

inline void train() {
	   ios::sync_with_stdio(false);
	   cin.tie(0);
	   cout.tie(0);
}

inline int maxi(int a, int b) {
	return a > b ? a : b;
}

inline int mini(int a, int b) {
	return a < b ? a : b;
}

constexpr int N = 3e5+4, INF = 1e8;

struct tnode {
	int lnode = 0, rnode = 0, priority, size, addin;
	tnode() {
		
	}
};

tnode memory[N];
int positions[N], a[N], ans[N], op[N], x[N], n, k, q;

inline int feed_mod(int a, int b) {
//	return a - (a/b);
	if (a < 0) {
		return -((-a) % b);
	} else return a%b;
}

void split(int root, int x, int &l, int &r) {
	assert(root < N && memory[root].lnode < N && memory[root].rnode < N);
	if (root == 0) {
		l = 0; r = 0;
		return;
	}
	if (memory[memory[root].lnode].size+1 <= x) {
		l = root;
		split(memory[root].rnode, x - memory[memory[root].lnode].size - 1, memory[root].rnode, r);
	} else {
		r = root;
		split(memory[root].lnode, x, l, memory[root].lnode);
	}
	memory[root].size = memory[memory[root].lnode].size + memory[memory[root].rnode].size + 1;
}

int merge(int l, int r) {
	assert(l < N && r < N);
	if (l == 0 || r == 0) {
		return l+r;
	}
	if (memory[l].priority > memory[r].priority) {
		memory[l].rnode = merge(memory[l].rnode, r);
		memory[l].size = memory[memory[l].lnode].size + memory[memory[l].rnode].size + 1;
		return l;
	} else {
		memory[r].lnode = merge(l, memory[r].lnode);
		memory[r].size = memory[memory[r].lnode].size + memory[memory[r].rnode].size + 1;
		return r;
	}
}

void enumerate(int root) {
	assert(root < N);
	if (root <= 0) return;
	enumerate(memory[root].lnode);
	cout << memory[root].addin << ' ';
	enumerate(memory[root].rnode);
}

inline void solve1() {
	for (int i = 0; i < k; i++) {
		positions[i] = i;
	}
	for (int i = q; i >= 1; i--) {
		for (int j = 0; j < k; j++) {
			switch (op[i]) {
				case 1:
					positions[j] = ((positions[j] / k) * k + ((positions[j] % k) - ((feed_mod(x[i], k) + k) % k) + k) % k);
					break;
				case 2:
					positions[j] = (positions[j] - ((feed_mod(x[i], n) + n) % n) + n) % n;
					break;
			}
		}
	}
	for (int i = 0; i < k; i++) {
		for (int j = 0; j < (n/k); j++) {
			ans[(positions[i] + k * j) % n] = a[(i + (k * j)) % n];
		}
	}
	for (int i = 0; i < n; i++) cout<<ans[i]<<' ';
	cout<<endl;
}

inline void swaps(int &a, int &b) {
	int tmp = a;
	a = b;
	b = tmp;
}

int root = 1, tid = 2, newroot;

// 注意此处下标从 1 开始
inline void solve2() {
	memory[root].size = 1;
	memory[root].addin = a[0];
	memory[root].priority = rand();
	for (int i = 1; i < n; i++) {
		memory[tid].size = 1;
		memory[tid].addin = a[i];
		memory[tid].priority = rand();
		root = merge(root, tid);
		tid++;
	}
	newroot = 0;
	for (int i = q; i >= 1; i--) {
		if (op[i] == 2) {
			int lc, rc;
			split(root, (feed_mod(x[i], n) + n) % n, lc, rc);
			root = merge(rc, lc);
		} else {
			for (int j = 0; j < n; j += k) {
				int lc, rc, xlc, xrc;
				split(root, k, lc, rc);
				root = rc;
				split(lc, (feed_mod(x[i], k) + k) % k, xlc, xrc);
				lc = merge(xrc, xlc);
				newroot = merge(newroot, lc);
			}
			swaps(root, newroot);
		}
	}
	enumerate(root);
	cout << endl;
}

int main() {

	srand(time(NULL));

	train();
	cin>>n>>k>>q;
	for (int i = 1; i <= q; i++) {
		cin>>op[i]>>x[i];
	}
	for (int i = 0; i < n; i++) cin>>a[i];
	if (k <= sqrt(n) || (1ll*k*q) <= 5e7) {
		solve1();
	} else {
		solve2();
	}
	
	//cout<<flush;

	return 0;
}
```

---


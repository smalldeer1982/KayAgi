# 「Wdsr-2.7」文文的摄影布置

## 题目背景

作为幻想乡知名的记者射命丸文，文文常常需要为文文新闻采集相关的照片素材。

具体而言，文文会采集一大串的图片，用于为新的一期报纸提供图片。作为一份简短的快报，文文会从素材库中使用**三张**图片，第一张放在开头，第三张放在结尾，用于激发读者的阅读兴趣（毕竟，报纸的开头和结尾是最容易被看到的）；第二张，则是为了帮助读者理解相关内容。

可是作为无双风神，文文收集的照片实在是太多了，以至于一时半会儿处理不过来。按照惯例，文文找到了在一旁吃瓜的你，希望你能帮她解决困难。

## 题目描述

尽管图片非常多，但幸运的是，文文已经将它们排成了一列，从左到右分别编号为 $1 \sim n$，文文选取的三张图片，**应该是一个长度为 $\bf 3$ 的子序列**。（不妨设选取的照片的序号为 $i,j,k$ ，则必须要有 $i<j<k$ ）。

此外，文文给每张照片定了一个**吸引度** $A_i$ 与**大小** $B_i$ 。

因为报纸版面太大会降低读者的兴趣，于是选定两张照片 $i,k$ 后，规定必须选择最小的 $B_j$。

形式化地说，规定 $\psi(i,k) = A_i + A_k - \min(B_j)$，其中需要满足 $i < j < k$。

摸清了照片价值的计算，文文会告诉你共 $m$ 个操作，可以分为以下三种：

- $\colorbox{f0f0f0}{\verb!1 x y!}$ ：照片的吸引度发生变化。文文要将 $A_x$ 修改为 $y$ 。

- $\colorbox{f0f0f0}{\verb!2 x y!}$ ：照片的大小发生变化。文文要将 $B_x$ 修改为 $y$ 。

- $\colorbox{f0f0f0}{\verb!3 l r!}$ ：文文打算利用素材库的第 $l$ 到第 $r$ 张中的图片，你要告诉她 $\psi(x,y)$ 的**最大值**（ $l\le x\le x+1<y \le r$ ）。

## 说明/提示

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 1\le n,m\le 300 & \text{无} & 10\cr\hline
2 & 1\le n,m\le 5\times 10^3 & \text{无} & 20\cr\hline
3 & 1\le n,m\le 5\times 10^5 & \text{仅有操作 3} & 20\cr\hline
4 & 1\le n,m\le 10^5 & \text{无} & 20\cr\hline
5 & \text{无特殊限制} & \text{无} & 30\cr\hline
\end{array}
$$

- 对于 $100\%$ 的数据：

   $1 \le n,m \le 5 \times 10^5$。
   
   $1 \leq A_i,B_i,y \leq 10^8$，$1 \le x \le n$，$1 \le l \le r \le n$。
   
   保证 $r-l+1 \geq 3$，即询问的区间长度大于等于 $3$

## 样例 #1

### 输入

```
6 6
1 4 2 3 5 6
5 3 4 1 6 7
3 2 5
3 1 6
1 2 3
3 1 6
2 6 1
3 1 6```

### 输出

```
8
9
8
8```

# 题解

## 作者：囧仙 (赞：29)

## 题目大意

> 给定两个长度均为 $n$ 的数组 $A_i$ 和 $B_i$ 。有 $m$ 次操作，每次操作将 $A_x$ 修改为 $y$ 或者将 $B_x$ 修改为 $y$ 或者求出

>  $$\max_{x\le i<j\le y} \{A_i+A_j-\min_{i < k < j}(B_k)\}$$

>  $1\le n,m\le 5\times 10^5$ 。

## 题解

在下文中，不妨记一段区间 $[x,y]$ 上的答案为 $\Psi(x,y)$ ，也就是

$$\Psi(x,y)=\max_{x\le a<b<c\le y} \{A_a-B_b+A_c\}$$

那么对于每次询问，问题转化为了计算 $\Psi(x_i,y_i)$ 的值。考虑使用线段树解决本题。特别地，下文中记 $\Psi(\omega)$ 表示线段树上节点 $\omega$ 对应的区间求得的 $\Psi$ 值。

非常自然的想法是，每个节点都要维护它所代表的这段区间的最优解。也就是说，假如一个节点 $\omega$ 维护了区间 $[l,r]$ ，那么它就要存储 $\Psi(l,r)$ 。问题在于，怎么从它的两个子节点 $\alpha,\beta$ 的 $\Psi$ 值更新到它本身。

- 首先考虑最优的 $a,b,c$ 在同一个儿子中的情况。显然，这样对答案的更新就是 $\max\{\Psi(\alpha),\Psi(\beta)\}$ 。

- 然后考虑 $a$ 在 $\alpha$ 中，而 $c$ 在 $\beta$ 中的情况。考虑第二张照片在哪。可以发现，假如第二张照片在 $\alpha$ 中，那么 $c$ 的最优解必定是 $\beta$ 中 $A$ 的值最大的那个元素。同理，假如第二张照片在 $\beta$ 中，那么 $a$ 的最优解必定是 $\alpha$ 中 $A$ 的值最大的那个元素。而维护 每个节点对应区间上的 $\max \{A_i\}$ 是相当容易的。

  于是，问题转化为了在一个节点维护的区间中，这样的两个值：
  
  $$\max_{l\le a<b\le r}\{A_a-B_b\}$$
  
  $$\max_{l\le b<c\le r}\{A_c-B_b\}$$
  
  不妨分别记为 $P(\omega)$ 和 $Q(\omega)$ 。考虑怎么从它的左右儿子上转移过来。
  
  对于 $P(\omega)$ ，其最优的 $a,b$ 又可以分为如下三类：
  
  - $a,b$ 都在左儿子 $\alpha$ 中。这部分的贡献为 $P(\alpha)$ 。
  
  - $a,b$ 都在右儿子 $\beta$ 中。这部分的贡献为 $P(\beta)$ 。
  
  - $a$ 在左儿子中，而 $b$ 在右儿子中。显然这部分贡献应该是左儿子中 $A$ 的最大值减去右儿子中 $B$ 的最小值。不妨把一个节点维护的区间上 $A_i$ 的最大值记为 $X(\omega)$ ，而 $B_i$ 的最小值记为 $Y(\omega)$ ，那么有：
  
  $$P(\omega)=\max\{P(\alpha),P(\beta),X(\alpha)-Y(\beta)\}$$
  
  同理，我们可以得到 $Q(\omega)$ 的维护方法。
  
最终，我们能得到所有东西的转移方程式：

$$\begin{gathered}
X(\omega)=\max\{X(\alpha),X(\beta)\},Y(\omega)=\min\{Y(\alpha),Y(\beta)\} \cr
\begin{aligned}
P(\omega) &=\max\{P(\alpha),P(\beta),X(\alpha)-Y(\beta)\} \cr
Q(\omega) &=\max\{Q(\alpha),Q(\beta),X(\beta)-Y(\alpha)\} \cr
\end{aligned} \cr
\Psi(\omega)=\max\{\Psi(\alpha),\Psi(\beta),P(\alpha)+X(\beta),X(\alpha)+Q(\beta)\}
\end{gathered}$$

对于查询操作，我们只要把涉及到的区间从左往右一个一个合并起来，再查询它的 $\Psi$ 值就行了。具体可以见代码。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =5e8,MAXN=5e5+3,SIZ=MAXN*4;
int A[MAXN],B[MAXN];
#define lc(t) (t<<1)
#define rc(t) (t<<1|1)
struct Node{
    int a,b,p,q,w; Node():a(-INF),b(INF),p(-INF),q(-INF),w(-INF){}
    Node operator +(Node t){
        Node r; r.a=max(a,t.a),r.b=min(b,t.b),r.w=max(w,t.w);
        r.p=max(t.p,max(p,a-t.b)),r.q=max(q,max(t.q,t.a-b));
        r.w=max(r.w,max(p+t.a,a+t.q)); return r;
    }
}W[SIZ];
void sst(int t,int l,int r,int p){
    if(l==r) W[t].a=A[l],W[t].b=B[l]; else {
        int c=l+r>>1; p<=c?sst(lc(t),l,c,p):sst(rc(t),c+1,r,p);
        W[t]=W[lc(t)]+W[rc(t)];
    }
}
void qry(int t,int l,int r,int a,int b,Node &o){
    if(a<=l&&r<=b) o=o+W[t]; else {
        int c=l+r>>1;
        if(a<=c) qry(lc(t),l  ,c,a,b,o);
        if(b> c) qry(rc(t),c+1,r,a,b,o);
    }
}
void bld(int t,int l,int r){
    if(l==r){W[t].a=A[l],W[t].b=B[l]; return;}
    int c=l+r>>1; bld(lc(t),l,c),bld(rc(t),c+1,r);
    W[t]=W[lc(t)]+W[rc(t)];
}
int n,q,m,p;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qread(),m=qread(); up(1,n,i) A[i]=qread(); up(1,n,i) B[i]=qread();
    bld(1,1,n); up(1,m,i){
        int op=qread(),x=qread(),y=qread(); Node r; switch(op){
            case 1: A[x]=y,sst(1,1,n,x); break;
            case 2: B[x]=y,sst(1,1,n,x); break;
            case 3: qry(1,1,n,x,y,r),printf("%d\n",r.w);
        }
    }
    return 0;
}
```

---

## 作者：_cnk (赞：22)

## $P7706$


单点修改 区间查询 考虑用线段树来解决

对于要查询的 $ψ$ 可以从以下几方面得到：

$1.$ 左儿子 $ψ$ 最大值

$2.$ 右儿子 $ψ$ 最大值

$3.$ 左儿子 $A_{i}$ - $B_{j}$ 且满足 $i < j$ 最大值 加上 右儿子$A_{k}$ 最大值 (此时一定满足$i < j < k$

$4.$ 右儿子 $A_{k}$ - $B_{j}$ 且满足 $j < k$ 最大值 加上 左儿子$A_{i}$ 最大值 (此时一定满足$i < j < k$

由此 我们线段树中要维护： 

$Amx : A$ 的最大值	$Bmn : B$ 的最小值	$lx:$ $A_{i}$ - $B_{j}$ 且满足 $i < j$ 最大值	$rx :$ $A_{k}$ - $B_{j}$ 且满足 $j < k$ 最大值	$mx :ψ$       

然后按照上述操作 $change\ query$ 就可以了：

```cpp 
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls (x << 1)
#define rs (ls | 1)
#define mid ((l + r) >> 1)
#define lson ls, l, mid
#define rson rs, mid + 1, r
const int maxn = 5e5 + 10, INF = -1e8 - 10;
int n, m;
struct tree{
	int Amx, Bmn, lx, rx, mx;
}a[maxn << 3];
struct node {
	int a, b;
}b[maxn];
tree update(tree A, tree B) {
	tree T;
	T.Amx = max(A.Amx, B.Amx);
	T.Bmn = min(A.Bmn, B.Bmn);
	T.lx = A.Amx - B.Bmn; //需要满足A的位置在B前面
	T.rx = B.Amx - A.Bmn; //需要满足B的位置在A前面
	T.lx = max(T.lx, max(A.lx, B.lx));
	T.rx = max(T.rx, max(A.rx, B.rx));
	T.mx = max(A.lx + B.Amx, B.rx + A.Amx); //对应以上说的 3 4 操作
	T.mx = max(T.mx, max(A.mx, B.mx)); //1 2 
	return T;
}

void build(int x, int l, int r) {
	if(l == r) {
		a[x].Amx = b[l].a, a[x].Bmn = b[l].b;
		a[x].lx = a[x].rx = a[x].mx = INF; //不保证A都大于B 所以要初始化
		return;
	}
	build(lson), build(rson);
	a[x] = update(a[ls], a[rs]);
}
void change(int x, int l, int r, int pos, int k, int op) { //单点修改
	if(l == r) {
		if(op == 1) a[x].Amx = k;
		if(op == 2) a[x].Bmn = k;
		return;
	}
	if(pos <= mid) change(lson, pos, k, op);
	if(pos >  mid) change(rson, pos, k, op);
	a[x] = update(a[ls], a[rs]);
}
tree query(int x, int l, int r, int L, int R) { //区间查询
	if(L <= l && r <= R) return a[x];
	if(L >  mid) return query(rson, L, R); //全在右区间
	if(R <= mid) return query(lson, L, R); //全在左区间
	return update(query(lson, L, R), query(rson, L, R)); //两个区间合并与change build函数中一样
}
signed main() {
	scanf("%lld%lld", &n, &m);
	for(int i = 1;i <= n;i++) scanf("%lld", &b[i].a);
	for(int i = 1;i <= n;i++) scanf("%lld", &b[i].b);
	build(1, 1, n);
	for(int i = 1;i <= m;i++) {
		int op, x, y;
		scanf("%lld%lld%lld", &op, &x, &y);
		if(op == 1)	change(1, 1, n, x, y, 1);
		if(op == 2) change(1, 1, n, x, y, 2);
		if(op == 3) printf("%lld\n", query(1, 1, n, x, y).mx);
	}
	return 0;
}
```

---

完结撒花~

---

## 作者：nullqtr_pwp (赞：11)

# $P7706$ Solution
形式化题面：维护序列 $A,B$，支持单点修改或者给定 $l,r$，查询 $\max(A_i+A_k-B_j),l\le i<j<k\le r$，$n,m\le5\times10^5$

注意到单点修改以及区间查询，考虑使用线段树。本题的难点在于**线段树维护的信息以及信息的汇总处理。** 考虑如何汇总。记当前的节点是 $o$，左儿子节点为 $l$，右儿子节点为 $r$（显然，$l=2o,r=2o+1$），维护一个当前节点上的答案信息为 $ans$，初始为 $-\infty$。

**转移从哪里来：$i,j,k$ 在左儿子和右儿子的分布情况决定了该节点上的答案。**

讨论转移方式：

1. 直接转移：$ans=\max(o.ans,l.ans,r.ans)$，其实对应的两种是 $i,j,k$ 都在左儿子上或者右儿子上。

2. $i$ 在左儿子上，$j,k$ 在右儿子上。那么左儿子 $A_i$ 很显然要取到该区间内的最大值，$A_k-B_j$ 要取到右儿子区间上的最大值，两个一累加就是该区间（转移方式）的最大值。

3. 类似的，$i,j$ 在左儿子上，$k$ 在右儿子上。让 $A_i-B_j$ 取最大，$A_k$ 取最大。

维护 $A_i-B_j$ 需要通过区间内 $B_i$ 最小值以及 $A_i$ 最大值来求，注意到位置问题，分为两种：$i<j,i>j$

**我们发现，要维护的东西有：区间内 $A_i$ 的最大值，区间内 $B_i$ 的最小值，区间内 $|A_x-B_y|(x\ne y)$ 的最大值，这个又分为了两种情况，$i<j,i>j$，最后再维护答案信息。**

这些东西都可以用线段树维护，而具体的信息汇总方式也已经在上文阐述了。代码就很容易实现了。

## AC code:
```c++
#include<bits/stdc++.h>
#define ls (o<<1)
#define rs (o<<1|1)
#define int long long
using namespace std;
inline int read(){
	register int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int maxn=500005;
int a[maxn],b[maxn];
struct tree{
	int a,b,lmx,rmx,ans;
}t[maxn<<2];
tree operator + (tree x,tree y){
	tree o;
	o.a=max(x.a,y.a);		
	o.b=min(x.b,y.b);
	o.lmx=max(x.lmx,max(y.lmx,x.a-y.b));		
	o.rmx=max(x.rmx,max(y.rmx,y.a-x.b));
	o.ans=max(x.ans,max(y.ans,max(x.lmx+y.a,x.a+y.rmx)));
	return o;
}
void pushup(int o){
	tree x=t[ls],y=t[rs];
	t[o].a=max(x.a,y.a);		
	t[o].b=min(x.b,y.b);
	t[o].lmx=max(x.lmx,max(y.lmx,x.a-y.b));		
	t[o].rmx=max(x.rmx,max(y.rmx,y.a-x.b));
	t[o].ans=max(x.ans,max(y.ans,max(x.lmx+y.a,x.a+y.rmx)));
}
void build(int o,int l,int r){
	if(l==r){
		t[o].a=a[l];			
		t[o].b=b[l];
		t[o].lmx=t[o].rmx=t[o].ans=-0x3f3f3f3f;	
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r);pushup(o);
}
void change(int o,int l,int r,int x,int y){
	if(l==r) return t[o].a=y,void();
	int mid=(l+r)>>1;
	if(x<=mid) change(ls,l,mid,x,y);
	else change(rs,mid+1,r,x,y);
	pushup(o);
}
void update(int o,int l,int r,int x,int y){
	if(l==r) return t[o].b=y,void();
	int mid=(l+r)>>1;
	if(x<=mid) update(ls,l,mid,x,y);
	else update(rs,mid+1,r,x,y);
	pushup(o);
}
tree query(int o,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return t[o];
	int mid=(l+r)>>1;
	if(mid>=qr) return query(ls,l,mid,ql,qr);
	if(mid<ql) return query(rs,mid+1,r,ql,qr);
	return query(ls,l,mid,ql,qr)+query(rs,mid+1,r,ql,qr);
}
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read();
	build(1,1,n);
	while(m--){
		int op=read(),l=read(),r=read();
		if(op==1) change(1,1,n,l,r);
		else if(op==2) update(1,1,n,l,r);
		else printf("%lld\n",query(1,1,n,l,r).ans);
	}
	return 0;
}
```

利用类似的思考方式，可以把 [P4513](https://www.luogu.com.cn/problem/P4513) 或者 [GSS3](https://www.luogu.com.cn/problem/SP1716) （查询区间最大子段和，单点修改）给过了。~~A 了这两道题，祝你们好运~~

这两道题的相似之处就是线段树维护多个信息，合并信息时有些情况要跨越两个区间。难点都是维护什么信息以及怎么合并信息，要想清楚每个区间的答案由子区间的什么信息决定。

---

## 作者：Buried_Dream (赞：8)

## Solution

这题一看就知道是线段树，问题是怎么维护答案，和要维护答案应该维护哪些值。

首先我们要维护一个区间的答案，看看他是如何从 $2$ 个儿子合并出来的。

分类讨论一下 $i, j, k$ 的位置。

- $i j k \mid $

- $\mid ijk$

- $i \mid jk$

- $i j \mid k$

就这四种情况。
分别考虑如何合并。

第一二种答案显然就是左右两个儿子的答案最大值。

第三种是左儿子的最大 $A_i$
和右儿子的最大 $A_i - B_j (i > j)$。

第四种是左儿子最大的 $A_i - B_j (i < j)$ 和右儿子最大的 $A_i$。

于是线段树维护什么就比较显然了，维护一个区间的最大 $A_i$，最小 $B_i$，最大 $A_i - B_j(i < j)$，维护最大 $A_i - B_j (i > j)$，还有区间的答案。

```cpp
/**
 *	author: TLE_Automation
 *	creater: 2022.8.3
**/
#include<cmath>
#include<queue>
#include<cstdio>
#include<bitset>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc readchar 
using namespace std;
typedef long long ll;
// #define int long long
const int N = 5e5 + 10;
const int MAXN = 2e5 + 10;
const int mod = 998244353;
const int INF = 0x3f3f3f3f;
const ll inf = 0x3f3f3f3f3f3f3f3f;
inline int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}
inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline int ksm(int a, int b) {int base = a % mod, res = 1; while(b){if(b & 1) res = (res * base) % mod; base = (base * base) % mod, b >>= 1;}return res % mod;}
inline int mul(int a, int b) {int base = a % mod, res = 0; while(b){if(b & 1) res = (res + base) % mod; base = (base + base) % mod, b >>= 1;}return res % mod;}
inline char readchar() {static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;}
inline int read() { int res = 0, f = 0; char ch = gc();for (; !isdigit(ch); ch = gc()) f |= (ch == '-'); for (; isdigit(ch); ch = gc()) res = (res << 1) + (res << 3) + (ch ^ '0'); return f ? -res : res;}

int n, a[N], b[N];
namespace Seg {
#define lson rt << 1
#define rson rt << 1 | 1
	struct Node {
		int l, r, Maxa, Minb, Maxl, Maxr, ans; 
	} tree[N << 2];
	inline void pushup(int rt) {
		tree[rt].Maxa = max(tree[lson].Maxa, tree[rson].Maxa);
		tree[rt].Minb = min(tree[lson].Minb, tree[rson].Minb);
		tree[rt].Maxl = max(tree[lson].Maxl, max(tree[rson].Maxl, tree[lson].Maxa - tree[rson].Minb));
		tree[rt].Maxr = max(tree[rson].Maxr, max(tree[lson].Maxr, tree[rson].Maxa - tree[lson].Minb));
		tree[rt].ans = max(max(tree[lson].ans, tree[rson].ans), max(tree[lson].Maxl + tree[rson].Maxa, tree[rson].Maxr + tree[lson].Maxa));
	}
	inline Node operator + (Node x, Node y) {
		Node res;
		res.Maxa = max(x.Maxa, y.Maxa);
		res.Minb = min(x.Minb, y.Minb);
		res.Maxl = max(x.Maxl, max(y.Maxl, x.Maxa - y.Minb));
		res.Maxr = max(y.Maxr, max(x.Maxr, y.Maxa - x.Minb));
		res.ans = max(max(x.ans, y.ans), max(x.Maxl + y.Maxa, y.Maxr + x.Maxa));
		return res;
	} 
	inline void build(int rt, int l, int r) {
		tree[rt].l = l, tree[rt].r = r;
		tree[rt].Maxl = tree[rt].Maxr = tree[rt].ans = -1e9;
		if(l == r) {
			tree[rt].Maxa = a[l], tree[rt].Minb = b[l];return;
		} int mid = (l + r) >> 1;
		build(lson, l, mid), build(rson, mid + 1, r);
		pushup(rt);
	}
	inline void changeA(int rt, int x, int k) {
		if(tree[rt].l > x || tree[rt].r < x) return;
		if(tree[rt].l == tree[rt].r) return tree[rt].Maxa = k, void();
		changeA(lson, x, k), changeA(rson, x, k), pushup(rt);
	}
	inline void changeB(int rt, int x, int k) {
		if(tree[rt].l > x || tree[rt].r < x) return;
		if(tree[rt].l == tree[rt].r) return tree[rt].Minb = k, void();
		changeB(lson, x, k), changeB(rson, x, k), pushup(rt);
	}
	inline Node Query(int rt, int l, int r) {
		if(tree[rt].l > r || tree[rt].r < l) return tree[0];
		if(tree[rt].l >= l && tree[rt].r <= r) return tree[rt];
		return Query(lson, l, r) + Query(rson, l, r);
	}
}
using namespace Seg;

int Q;

signed main() 
{
	//	freopen("data.in", "r", stdin);
	//	freopen("baoli.out", "w", stdout);
	n = read(), Q = read();
	for(register int i = 1; i <= n; i++) a[i] = read(); 
	for(register int i = 1; i <= n; i++) b[i] = read();
	tree[0].Maxl = tree[0].Maxr = tree[0].ans = tree[0].Maxa = -1e9, tree[0].Minb = 1e9;
	build(1, 1, n);
	for(register int i = 1; i <= Q; i++) {
		int opt = read(), x = read(), y = read();
		if(opt == 1) changeA(1, x, y);
		else if(opt == 2) changeB(1, x, y);
		else print(Query(1, x, y).ans), putchar('\n');
	}
	return 0;
}
```

---

## 作者：I_am_sb___ (赞：4)

此题题面经过简化可以得出：

> 给定两个序列 $A,B$，求某一段区间 $[x,y]$ 中的 $MAX\sum{(A_a-B_b+A_c)}$，其中 $x<a<b<c<y$
>
>要求实现单点修改序列 $A,B$ 还有区间查询。

首先，通过单点修改和区间查询可以想到用线段树进行维护，由于是单点修改所以不需要 pushdown 操作，考虑如何实现 pushup，发现这一题的情况并不能简单相加两子区间答案，所以思考其他可行方案。

首先，如果此三个数都是属于某一个子区间的，则显然就可以将答案从其两个子区间的答案里取 $ \operatorname{max}$,通过观察式子 $ \operatorname{max}(\sum{(A_a-B_b+A_c)})$ 不难得出，这种子情况可以分为：

$a,b\in$ 左子区间（设为 $situation_1$）；

还有 $b,c\in$ 右子区间（设为 $situation_2$）两种。

不难发现 $situation_1$ 中，式子可以被分为 $A_a-B_b$ 和 $A_c$，而 $situation_2$ 中，式子可以被分成 $A_a$ 和 $A_c-B_b$ 两部分。

如果我们想使得答案为最大值的话，可以将其两个式子分别取最大值，其中 $A_a$ 和  $A_c$ 只用维护 $A$ 序列的最大值即可，而 $A_a-B_b$ 和 $B_b-A_c$ 则可以用 $A$ 序列中下标比 $B$ 小的最大值、下标比 $B$ 大的最大值，还有 $B$ 的最小值，这样三个值即可得出 $A_a-B_b$ 和 $A_c-B_b$ 的最大值了，那么我们就需要在线段树结点中维护 5 个值：

```cpp
struct node
{
    int l , r;
    int maxA , minB;
    int sum_max_ , sum__max;
    int ans;
} tree[N << 2];
```

修改和查询操作就是正常线段树中的修改与查询。

那么完整代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<string.h>

#define ls u << 1
#define rs u << 1 | 1

using namespace std;

inline int read(){
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-')w=-1;c=getchar();}
	while(isdigit(c)) s=s*10+(c^48),c=getchar();
	return s*w;
}

inline void write(int x){
	if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

const int N = 500007 , inf = 1e9;

int n , m;
int A[N] , B[N];
struct node
{
	int l , r;
	int maxA , minB;
	int sum_max_ , sum__max;
	int ans;
} tree[N << 2];

void pushup(int u)
{
	tree[u].maxA = max(tree[ls].maxA , tree[rs].maxA);
	tree[u].minB = min(tree[ls].minB , tree[rs].minB);
	tree[u].sum_max_ = max(max(tree[ls].sum_max_ , tree[rs].sum_max_) , tree[ls].maxA - tree[rs].minB);
	tree[u].sum__max = max(max(tree[ls].sum__max , tree[rs].sum__max) , tree[rs].maxA-tree[ls].minB);
	tree[u].ans = max(max(tree[ls].ans , tree[rs].ans) , max(tree[ls].sum_max_ + tree[rs].maxA , tree[rs].sum__max + tree[ls].maxA));
}
void build(int u , int l , int r)
{
	tree[u] = {l , r};
	if(l == r)
	{
		tree[u].maxA = A[l];
		tree[u].minB = B[r];
		tree[u].sum_max_ = tree[u].sum__max = tree[u].ans = -inf;
		return;
	}
	int mid = (tree[u].l + tree[u].r) >> 1;
	build(ls , l , mid);
	build(rs , mid + 1 , r);
	pushup(u);
}
void modifyA(int u , int tra , int k)
{
	if(tree[u].l == tree[u].r)
	{
		tree[u].maxA = k;
		return;
	}
	int mid = (tree[u].l + tree[u].r) >> 1;
	if(tra <= mid) modifyA(ls , tra , k);
	else modifyA(rs , tra , k);
	pushup(u);
}
void modifyB(int u , int tra , int k)
{
	if(tree[u].l == tree[u].r)
	{
		tree[u].minB = k;
		return;
	}
	int mid = (tree[u].l + tree[u].r) >> 1;
	if(tra <= mid) modifyB(ls , tra , k);
	else modifyB(rs , tra , k);
	pushup(u);
}

node query(int u , int l , int r)
{
	if(tree[u].l >= l && tree[u].r <= r) return tree[u];
	int mid = (tree[u].l + tree[u].r) >> 1;
	if(mid >= r) return query(ls , l , r);
	if(mid + 1 <= l) return query(rs , l , r);
	node res;
	node lson = query(ls , l , r);
	node rson = query(rs , l , r);
	res.maxA = max(lson.maxA , rson.maxA);
	res.minB = min(lson.minB , rson.minB);
	res.sum_max_ = max(max(lson.sum_max_ , rson.sum_max_),lson.maxA - rson.minB);
	res.sum__max = max(max(lson.sum__max , rson.sum__max),rson.maxA - lson.minB);
	res.ans = max(max(lson.ans , rson.ans) , max(lson.sum_max_ + rson.maxA , rson.sum__max + lson.maxA));
	return res;
}
int main(){
	n = read();m = read();
	for(int i = 1 ; i <= n ; ++ i) A[i] = read();
	for(int i = 1 ; i <= n ; ++ i) B[i] = read();
	build(1 , 1 , n);
	int flag;
	int x , y;
	for(int i = 0 ; i < m ; ++ i)
	{
		flag = read();x = read();y = read();
		if(flag == 1) modifyA(1 , x , y);
		else if(flag == 2) modifyB(1 , x , y);
		else
		{
			write(query(1 , x , y).ans);
			puts("");
		}
	}
	return 0;
}
```


---

## 作者：yukari1735 (赞：4)

线段树。

乍一看这东西好像不咋能直接维护啊。

那我们先看这个题要求啥。

定义 $\psi(i,k)=A_i+A_k-\min(B_j)$，其中 $i<j<k$。

然后我们要求某一区间 $[l,r]$ 的这个东西的最大值也就是 $\mathop{\max\{\psi(i,k)\}}\limits_{l\leq i,j,k \leq r }$。

那我们合并俩区间的答案时要怎么维护呢。

分类讨论一下，假设最优的 $i,j,k$ 都在左右子树其中一个，直接合并即可。

然后 $i,k$ 在不同的子树，我们就需要看看 $j$ 应该在哪里。

那只需要维护一下 $\max\{A_i-B_j\}$ 和 $\max\{A_k-B_j\}$ 就好了吧？也就是每个节点维护一个左边 $A$ 减右边 $B$ 的最大值和右边 $A$ 减左边 $B$ 的最大值。

假设 $j$ 在左子树，那么答案就该是 $\max\{A_i-B_j\} + A_k$，注意到这里要最大化 $A_k$，所以还要在节点里维护一个 $\max\{A_i\}$。

$j$ 在右子树的话同理，咱们只要四种情况都取个 $\max$ 就行。

$\max\{A_i-B_j\}$ 和 $\max\{A_k-B_j\}$ 这俩东西又咋维护呢。

我们以 $\max\{A_i-B_j\}$ 左减右作为例子。

还是分类，假设都在左右子树其中一个，直接合并。

若不是，那么这个 $i$ 与 $j$ 一定在分别两个子树之中，那就使 $A_i$ 尽量大，$B_j$ 尽量小，再对每个节点维护一个 $\min\{B_j\}$，左边取个 $\max\{A_i\}$，右边取个 $\min\{B_j\}$ 就可以 $O(1)$ 合并了。

$\max\{A_k-B_j\}$ 也是相似地维护。

时间复杂度 $O(n\ log\ n )$。

代码如下

```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
using namespace std;
const int N = 5e5 + 225;
const int Inf = 0x7fffffff;

inline int read(){
	int ret = 0 , ti = 1;
	char u = getchar();
	while( ! isdigit( u ) ){ if( u == '-' ) ti = -1; u = getchar(); }
	while( isdigit( u ) ) ret = ret * 10 + u - '0' , u = getchar();
	return ret * ti;
}

int n , q;
int a[ N ] , b[ N ];

struct Seg{
	# define lefc( x ) x << 1
	# define rigc( x ) x << 1 | 1
	struct Node{
		int lv , rv , mxa , mnb , ans;
	}t[ N << 3 ];
	
	void merge( Node & u , Node lc , Node rc ){
		u . mxa = max( lc . mxa , rc . mxa );
		u . mnb = min( lc . mnb , rc . mnb );
		u . lv = max( lc . mxa - rc . mnb , max( lc . lv , rc . lv ) );
		u . rv = max( rc . mxa - lc . mnb , max( lc . rv , rc . rv ) );
		u . ans = max( max( lc . lv + rc . mxa , rc . rv + lc . mxa ) , max( lc . ans , rc . ans ) );
	}
	
	void push_up( int u ){
		int lc = lefc( u ) , rc = rigc( u );
		merge( t[ u ] , t[ lc ] , t[ rc ] );
	} 
	
	void build( int u , int l , int r ){
		if( l == r ){
			t[ u ] . lv = t[ u ] . rv = t[ u ] . ans = - Inf;
			t[ u ] . mxa = a[ l ] , t[ u ] . mnb = b[ l ];
			return;
		}
		int mid = l + r >> 1;
		build( lefc( u ) , l , mid );
		build( rigc( u ) , mid + 1 , r );
		push_up( u );
	}
	
	void update( int u , int l , int r , int p , int v , int op ){
		if( l == r ){
			op ? t[ u ] . mxa = v : t[ u ] . mnb = v;
			return;
		}
		int mid = l + r >> 1;
		if( p <= mid ) update( lefc( u ) , l , mid , p , v , op );
		else update( rigc( u ) , mid + 1 , r , p , v , op );
		push_up( u );
	}
	
	Node query( int u , int l , int r , int L , int R ){
		if( L <= l && r <= R ) return t[ u ];
		int mid = l + r >> 1;
		if( R <= mid ) return query( lefc( u ) , l , mid , L , R );
		if( L > mid ) return query( rigc( u ) , mid + 1 , r , L , R );
		Node ret;
		merge( ret , query( lefc( u ) , l , mid , L , R ) , query( rigc( u ) , mid + 1 , r , L , R ) );
		return ret;
	}
}T;

void solve(){
	for( int i = 1 ; i <= q ; i ++ ){
		int op = read() , l = read() , r = read();
		if( op == 1 ) T . update( 1 , 1 , n , l , r , 1 );
		else if( op == 2 ) T . update( 1 , 1 , n , l , r , 0 );
		else printf( "%d\n" , T . query( 1 , 1 , n , l , r ) . ans );
	}
}

void input(){
	n = read() , q = read();
	for( int i = 1 ; i <= n ; i ++ ) a[ i ] = read();
	for( int i = 1 ; i <= n ; i ++ ) b[ i ] = read();
}

int main(){
	input();
	T . build( 1 , 1 , n );
	solve();
	return 0;	
}
```

---

## 作者：SunnyYuan (赞：3)

## 思路

我主要讲一讲怎么维护所有信息。

首先说一下基本思路，就是我们建立一棵线段树并在一个线段树上的节点 `node` 维护一个区间的：

```cpp
struct node {
    int maxa;       // a 数组的区间最大值
    int minb;       // b 数组的区间最小值
    int maxab;      // 表示选择区间的两个数 i, j 满足 i < j 且要最大化 ai - bj
    int maxba;      // 表示选择区间的两个数 i, j 满足 i < j 且要最大化 aj - bi
    int res;        // 该区间的答案
};
```

那我们怎么维护这些信息呢？即怎么将子树的信息传到父节点呢？

首先因为我们要最大化，所以我们加的要尽量大，减的要尽量小。

然后，我们假设 `rt` 是存储父节点信息的结构体，`lc, rc` 表示存储左右子节点信息结构体，开始思考 `pushup` 函数怎么写。

因为维护信息太多了，所以我这里的 `pushup` 直接返回线段树节点了。

```cpp
node pushup(node lc, node rc) {
    node rt;
    rt.maxa = max(lc.maxa, rc.maxa);    // 即左右两个区间的最大值取较大值
    rt.minb = min(lc.minb, rc.minb);    // 即左右两个区间的最小值取较小值
    rt.maxab = max(max(lc.maxab, rc.maxab), lc.maxa - rc.minb);// 即要么直接从子节点取出最大值，要么从左边取出 a 的最大值再减去右边 b 的最小值以达到最大化的目的
    rt.maxba = max(max(lc.maxba, rc.maxba), rc.maxa - lc.minb);// 即要么直接从子节点取出最大值，要么从右边取出 a 的最大值再减去左边 b 的最小值以达到最大化的目的
    rt.res = max(max(lc.res, rc.res), max(lc.maxab + rc.maxa, lc.maxa + rc.maxba));// 即要么直接从子节点取出答案，要么从左边取出 a + b 的最大值再加上右边 a 的最大值或者从左边取出 a 的最大值再加上右边 b + a 的最大值以达到最大化的目的
    return rt;
}
```

其他的与线段树基本操作一样。

## 代码

```cpp
/*******************************
| Author:  SunnyYuan
| Problem: P7706 「Wdsr-2.7」文文的摄影布置
| Contest: Luogu
| URL:     https://www.luogu.com.cn/problem/P7706
| When:    2023-10-03 08:28:05
| 
| Memory:  256 MB
| Time:    2000 ms
*******************************/

#include <bits/stdc++.h>

using namespace std;

const int N = 500010, INF = 1e9;

struct node {
    int maxa;       // a 数组的区间最大值
    int minb;       // b 数组的区间最小值
    int maxab;      // 表示选择区间的两个数 i, j 满足 i < j 且要最大化 ai - bj
    int maxba;      // 表示选择区间的两个数 i, j 满足 i < j 且要最大化 aj - bi
    int res;        // 该区间的答案
} tr[N << 2];

int n, m;
int a[N], b[N];

node pushup(node lc, node rc) {
    node rt;
    rt.maxa = max(lc.maxa, rc.maxa);    // 即左右两个区间的最大值取较大值
    rt.minb = min(lc.minb, rc.minb);    // 即左右两个区间的最小值取较小值
    rt.maxab = max(max(lc.maxab, rc.maxab), lc.maxa - rc.minb);// 即要么直接从子节点取出最大值，要么从左边取出 a 的最大值再减去右边 b 的最小值以达到最大化的目的
    rt.maxba = max(max(lc.maxba, rc.maxba), rc.maxa - lc.minb);// 即要么直接从子节点取出最大值，要么从右边取出 a 的最大值再减去左边 b 的最小值以达到最大化的目的
    rt.res = max(max(lc.res, rc.res), max(lc.maxab + rc.maxa, lc.maxa + rc.maxba));// 即要么直接从子节点取出答案，要么从左边取出 a + b 的最大值再加上右边 a 的最大值或者从左边取出 a 的最大值再加上右边 b + a 的最大值以达到最大化的目的
    return rt;
}

void build(int u, int l, int r) {
    if (l == r) {
        tr[u] = {a[l], b[l], -INF, -INF, -INF};
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
    tr[u] = pushup(tr[u << 1], tr[u << 1 | 1]);
}

node query(int u, int l, int r, int pl, int pr) {
    if (pl <= l && r <= pr) return tr[u];
    int mid = l + r >> 1;
    if (pr <= mid) return query(u << 1, l, mid, pl, pr);
    else if (pl > mid) return query(u << 1 | 1, mid + 1, r, pl, pr);
    else return pushup(query(u << 1, l, mid, pl, pr), query(u << 1 | 1, mid + 1, r, pl, pr));
}

void modify(int u, int l, int r, int x, int v1, int v2) {
    if (l == r) {
        tr[u] = {v1, v2, -INF, -INF, -INF};
        return;
    }
    int mid = l + r >> 1;
    if (x <= mid) modify(u << 1, l, mid, x, v1, v2);
    else modify(u << 1 | 1, mid + 1, r, x, v1, v2);
    tr[u] = pushup(tr[u << 1], tr[u << 1 | 1]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    build(1, 1, n);
    int opt, x, y;
    while (m--) {
        cin >> opt >> x >> y;
        if (opt == 1) a[x] = y, modify(1, 1, n, x, a[x], b[x]);
        else if (opt == 2) b[x] = y, modify(1, 1, n, x, a[x], b[x]);
        else cout << query(1, 1, n, x, y).res << '\n';
    }
    return 0;
}

```

---

## 作者：AsadChen (赞：2)

UPDATE:

2022/8/19 修改博客链接

原题链接：[P7706](https://www.luogu.com.cn/problem/P7706)

更好的阅读体验：[吾の博客](https://www.luogu.com.cn/blog/AsadChen/post-ti-xie-p7706-wdsr-27-wen-wen-di-nie-ying-bu-zhi)
# 文文的摄影布置-题解
前言：这是笔者在洛谷正式递交的第一份题解，希望大家多多支持！
## 题意分析
简化题意就是给定两个序列 $A,B$，规定：$\psi(i,k)=A_i+A_k-\min\left.\{B_j\right.\}(i<j<k)$。给定一个区间 $(l,r)$ 求该区间内的 $\max(\psi)$。两个序列的数值**可能发生变化**。

这是典型的单点修改、区间查询问题，显而易见可以运用**线段树**解决。

## 维护信息-分类讨论
依题意，首先需要维护每个区间分别最大的 $A_i$ 和最小的 $B_j$。

$$\psi(i,k)=A_i+A_k-\min\left.\{B_j\right.\}(i<j<k)$$

对于该式，想要求 $\max(\psi)$，就是求 $\max(A_i+A_k-\min\left.\{b_j\right.\})$，$i,j,k$ 的位置并不是一定的，于是我们考虑 $i,j,k$ 的位置，并且考虑如何计算某种情况下的 $\max(\psi)$：
### 情况 1：都在左子树或都在右子树
这种情况好搞，就是在维护区间信息(做 push_up 操作)时取一下左右子树最大值就行。
### 情况 2：横跨左右子树
将原式可以拆成两个小式子 $A_i-B_j(i<j)$ 和 $A_k-B_j(j<k)$，并且考虑 $i,j,k$ 在不同子树下的两式最大值计算。横跨左右子树分 $i,j$ 在左子树而 $k$ 在右子树**和** $i$ 在左子树而 $j,k$ 在右子树两种情况。

对于前者情况，我们维护当前区间左子树最大的 $A_i$ 和右子树最小的 $B_j$ 的差；对于后者情况，我们维护当前区间右子树最大的 $A_k$ 和左子树最小的 $B_j$ 的差。
### 最后
最后，求 $\max(\psi)$，对于情况 2 的前者的式子再加上右子树最大的 $A_k$；对于情况 2 的后者的式子再加上左区间最大的 $A_i$，共两种情况。

对于情况 1 分别为左右子树的 $\max(\psi)$，共两种情况。

上述四种情况，取最大值即为当前区间的 $\max(\psi)$。

一些笔者的提醒和建议（也可能有点多余）：

- 维护信息时要注意一下顺序。

- 建树时要把情况 2 中的两式最大值和 $\psi$ 初始化为负无穷。

- 考虑到这题会爆 int 但是我们维护的信息比较多，参考了一下几位大佬的写法，可以 define int 为 LL，主函数返回值类型写成 signed。

其他的，大家看代码吧。

## AC代码

```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

const int  N = 5e5 + 10, INF = -0x3f3f3f3f;

struct Segment
{
	int a, b;
}seg[N];
struct Node
{
	int l, r;
	int amax; //A的最大值 
	int bmin; //B的最小值 
	int lmax; //A_i - B_j且i < j的最大值 
	int rmax; //A_k - B_j且j < k的最大值 
	int tmax; //\psi 
}tr[N * 4];
int n, m;

void push_up(Node &u, Node &l, Node &r)
{
	u.amax = max(l.amax, r.amax);
	u.bmin = min(l.bmin, r.bmin);
	//对应Node节点的信息 
	u.lmax =  l.amax - r.bmin; //a_i - b_j
	u.rmax = r.amax - l.bmin; //a_k - b_j
	//再与左右子树取最大值
	u.lmax = max(u.lmax, max(l.lmax, r.lmax));
	u.rmax = max(u.rmax, max(l.rmax, r.rmax));
	//求ψ
	u.tmax = max(max(l.lmax + r.amax, r.rmax + l.amax), max(l.tmax, r.tmax)); 
}

void push_up(int u)
{
	push_up(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
	if (l == r)
	{
		tr[u] = {l, r, seg[r].a, seg[r].b, INF, INF, INF}; 
	}
	else
	{
		tr[u] = {l, r};
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		push_up(u);
	}
}

void modify(int u, int x, int v, int tag)
{
	if (tr[u].l == x && tr[u].r == x)
	{
		if (tag == 1) tr[u].amax = v;
		if (tag == 2) tr[u].bmin = v;
	}
	else
	{
		int mid = tr[u].l + tr[u].r >> 1;
		if (x <= mid) modify(u << 1, x, v, tag);
		else modify(u << 1 | 1, x, v, tag);
		push_up(u);
	}
}

Node query(int u, int l, int r)
{
	if (tr[u].l >= l && tr[u].r <= r) return tr[u];
	else
	{
		int mid = tr[u].l + tr[u].r >> 1;
		if (r <= mid) return query(u << 1, l, r);
		else if (l > mid) return query(u << 1 | 1, l, r);
		else
		{
			Node res;
			auto Left = query(u << 1, l, r);
			auto Right = query(u << 1 | 1, l, r);
			push_up(res, Left, Right);
			return res;
		}
	}
}

signed main()
{
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%lld", &seg[i].a);
	for (int i = 1; i <= n; i++) scanf("%lld", &seg[i].b);
	
	build(1, 1, n);
	
	for (int i = 1; i <= m; i++)
	{
		int op, x, y;
		scanf("%lld%lld%lld", &op, &x, &y);
		if (op == 1 || op == 2) modify(1, x, y, op);
		else printf("%lld\n", query(1, x, y).tmax);
	}
	return 0;
	 
}
```
这是笔者在洛谷的第一份题解，若有错误欢迎各位指正，有问题大家可以在评论区探讨。

---

## 作者：tzl_Dedicatus545 (赞：2)

观察一下题意可以发现，单点更改，区间查询，这不就是线段树吗，线段树要求操作有可结合性，但显然题目中的 $\psi$ 操作不具有可结合性，我们考虑如何让该操作满足结合性。

![](https://cdn.luogu.com.cn/upload/image_hosting/uet37ha8.png)

分四种情况，如上图所示，答案在左边，右边，一号和二号在左边，二号和三号在右边，形式化地：

$$\psi(1\to8)=\max{\psi(1\to4),\psi(5\to8)},f(1\to4)+\max 5\to8,\max 1\to 4+g(5\to8)$$

$f(i\to j)$ 为 $i$ 到 $j$ 的 $a-b$ 的最大值。

$g(i\to j)$ 为 $i$ 到 $j$ 的 $b-a$ 最大值。

至此，就很模板了。

**代码：**

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define rep(i,x,y,z) for(int i=(x);i<=(y);i+=(z))
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;
const int MAXN=500020;

struct AyasPicture_t{
	int psi,MaxA,MinB,AMinusBLeft,AMinusBRight;
}a[4*MAXN];

int n;
vector<int> A,B;

inline int lc(int u)
{
	return u*2;
}
inline int rc(int u)
{
	return (u*2)+1;
}

void PushUp(AyasPicture_t &res,AyasPicture_t LeftChild,AyasPicture_t RightChild)
{
	res.MaxA=max(LeftChild.MaxA,RightChild.MaxA);
	res.MinB=min(LeftChild.MinB,RightChild.MinB);
	res.psi=max({LeftChild.psi,RightChild.psi,LeftChild.MaxA+RightChild.AMinusBLeft,LeftChild.AMinusBRight+RightChild.MaxA});
	res.AMinusBLeft=max({LeftChild.AMinusBLeft,RightChild.AMinusBLeft,RightChild.MaxA-LeftChild.MinB});
	res.AMinusBRight=max({LeftChild.AMinusBRight,RightChild.AMinusBRight,LeftChild.MaxA-RightChild.MinB});
}

void MakeTree(int u,int l,int r)
{
	if(l==r)
	{
		a[u].MaxA=A[l-1];
		a[u].MinB=B[l-1];
		a[u].psi=-INF;
		a[u].AMinusBLeft=-INF;
		a[u].AMinusBRight=-INF;

		return ;
	}

	int mid=(l+r)/2;

	MakeTree(lc(u),l,mid);
	MakeTree(rc(u),mid+1,r);

	PushUp(a[u],a[lc(u)],a[rc(u)]);

	return ;
}

AyasPicture_t QueryPsi(int u,int l,int r,int ql,int qr)
{
	if(ql<=l && r<=qr)
	{
		return a[u];
	}

	int mid=(l+r)/2;
	AyasPicture_t LAns={-INF,-INF,INF,-INF,-INF},RAns={-INF,-INF,INF,-INF,-INF},Ret;

	if(ql<=mid)
	{
		LAns=QueryPsi(lc(u),l,mid,ql,qr);
	}
	if(qr>mid)
	{
		RAns=QueryPsi(rc(u),mid+1,r,ql,qr);
	}

	PushUp(Ret,LAns,RAns);

	return Ret;
}

void PointChangeA(int u,int l,int r,int q,int val)
{
	if(l==q && r==q)
	{
		a[u].MaxA=val;
		A[l-1]=val;
		a[u].MinB=B[l-1];
		a[u].psi=-INF;
		a[u].AMinusBLeft=-INF;
		a[u].AMinusBRight=-INF;

		return ;
	}

	int mid=(l+r)/2;

	if(q<=mid)
		PointChangeA(lc(u),l,mid,q,val);
	if(q>mid)
		PointChangeA(rc(u),mid+1,r,q,val);

	PushUp(a[u],a[lc(u)],a[rc(u)]);
}

void PointChangeB(int u,int l,int r,int q,int val)
{
	if(l==r)
	{
		a[u].MaxA=A[l-1];
		a[u].MinB=val;
		B[l-1]=val;
		a[u].psi=-INF;
		a[u].AMinusBLeft=-INF;
		a[u].AMinusBRight=-INF;

		return ;
	}

	int mid=(l+r)/2;

	if(q<=mid)
		PointChangeB(lc(u),l,mid,q,val);
	if(q>mid)
		PointChangeB(rc(u),mid+1,r,q,val);

	PushUp(a[u],a[lc(u)],a[rc(u)]);
}

signed main()
{
	ios::sync_with_stdio(false);

	int n,m,__builtin_cinignore;

	cin>>n>>m;

	for(int i=1;i<=n;i++)
	{
		cin>>__builtin_cinignore;

		A.push_back(__builtin_cinignore);
	}

	for(int i=1;i<=n;i++)
	{
		cin>>__builtin_cinignore;

		B.push_back(__builtin_cinignore);
	}

	MakeTree(1,1,n);

	while(m--)
	{
		int op,x,y;

		cin>>op>>x>>y;

		if(op==1)
		{
			PointChangeA(1,1,n,x,y);
		}
		if(op==2)
		{
			PointChangeB(1,1,n,x,y);
		}
		if(op==3)
		{
			cout<<QueryPsi(1,1,n,x,y).psi<<endl;
		}
	}

	return 0;
}

```


---

## 作者：UperFicial (赞：1)

NOIP 考前一天，写一篇题解 rp++。

直接用线段树来维护，考虑 $3$ 操作怎么搞。

线段树每一个区间不妨直接维护 $\psi$ 的最大值，那么就转化成怎样快速地合并信息。

如果 $u$ 的左右孩子分别为 $lc$ 和 $rc$，那么最简单的一种情况是，$u$ 的最大的 $\psi$ 的 $i,j,k$ 都位于 $lc$ 或则都位于 $rc$，这种情况直接取 $lc$ 的 $\psi$ 和 $rc$ 的 $\psi$ 的最值即可。

那么还剩下两种情况：$i,j$ 位于 $lc$，$k$ 位于 $rc$ 或者 $i$ 位于 $lc$，$j,k$ 位于 $rc$。

我们设 $sub_{u,1}$ 表示在 $u$ 这个子树中，$a_i-b_j$ 的最大值是多少，另设 $mxa_u$ 表示 $u$ 这个子树中 $a_i$ 的最大值，其中 $i<j$。那么对于情况 $1$，$u$ 的 $\psi$ 应该取为 $sub_{lc,1}+mxa_{rc}$。对于情况 $2$ 也同理，只不过需要再设 $sub_{u,2}$ 表示 $a_i-b_j$ 的最大值，其中 $i>j$。

现在问题在于怎样快速地处理出 $sub_{u,1/2}$。这个很好维护，我们再维护 $a_i$ 最大值，$b_i$ 最小值，每次合并信息时，$sub_{u,1}$ 等于 $lc$ 的 $a$ 的最大值减去 $rc$ 的 $b$ 的最小值。

代码方面 $\text{push\_up}$ 的时候有一个技巧，返回一个两个节点合并出来的节点，这样在查询时需要合并并没有直接关系的节点会有很大帮助。

~~代码不贴了，写得太丑了。~~

[$\text{AC}$ 记录](https://www.luogu.com.cn/record/62983150)

---

## 作者：漠寒 (赞：1)

## 分析

这道题属于考察对于合并时不同最佳状态的讨论，我们考虑最后选出来的那三张照片位置在哪里，发现有四种情况（中间隔开处为线段树区间的 $mid$）。

1、$ijk$|。

2、|$ijk$。

3、$ij$|$k$。

4、$i$|$jk$。

显然前两种情况就是子节点的答案，而后两种情况需要用到以下值：最大 $a$ 值，最大的 $a_i-b_j(i<j)$，最大的 $a_i-b_j(i>j)$。而后两个值又要用到最小 $b$ 值，所以最终我们一共维护五个值即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls rt<<1
#define rs rt<<1|1
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,m;
struct node{
	int mxa,mnb,ml,mr,as;
}a[2000005];
void pushup(node &x,node y,node z){
	x.mxa=max(y.mxa,z.mxa);
	x.mnb=min(y.mnb,z.mnb);
	x.ml=max(y.ml,max(z.ml,y.mxa-z.mnb));//最大的 a[i]-b[j](i<j)
	x.mr=max(z.mr,max(y.mr,z.mxa-y.mnb));//最大的 a[i]-b[j](i>j)
	x.as=max(y.as,max(z.as,max(y.ml+z.mxa,z.mr+y.mxa)));//答案，取四种情况最大值 
}
int csa[500005],csb[500005];
void build(int rt,int l,int r){
	if(l==r){
		a[rt].mxa=csa[l];
		a[rt].mnb=csb[l];
		a[rt].ml=a[rt].mr=a[rt].as=-1e9;//这个初值一定要赋，负答案是可能出现的 
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(a[rt],a[ls],a[rs]);
}
void modifya(int rt,int l,int r,int L,int k){
	if(l==r){
		a[rt].mxa=k;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=L)modifya(ls,l,mid,L,k);
	else modifya(rs,mid+1,r,L,k);
	pushup(a[rt],a[ls],a[rs]);
}
void modifyb(int rt,int l,int r,int L,int k){
	if(l==r){
		a[rt].mnb=k;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=L)modifyb(ls,l,mid,L,k);
	else modifyb(rs,mid+1,r,L,k);
	pushup(a[rt],a[ls],a[rs]);
}
node query(int rt,int l,int r,int L,int R){
	if(l>=L&&R>=r)return a[rt];
	int mid=(l+r)>>1;
	if(mid>=R)return query(ls,l,mid,L,R);
	if(mid<L)return query(rs,mid+1,r,L,R);
	node aa=query(ls,l,mid,L,R),bb=query(rs,mid+1,r,L,R),cc;
	pushup(cc,aa,bb);
	return cc;
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=n;i++){
		read(csa[i]);
	}
	for(int i=1;i<=n;i++){
		read(csb[i]);
	}
	build(1,1,n);
	while(m--){
		int op,x,y;
		read(op);read(x);read(y);
		if(op==1){
			modifya(1,1,n,x,y);
		}
		if(op==2){
			modifyb(1,1,n,x,y);
		}
		if(op==3){
			printf("%d\n",query(1,1,n,x,y).as);
		}
	}
}

```


---

## 作者：scp020 (赞：0)

### 题目大意

有两个长度为 $n$ 的序列 $a$ 和 $b$，给定 $m$ 次操作，每次输入 $3$ 个整数 $op,x,y$，对于 $op = 1$ 的操作我们把 $a_x$ 修改为 $y$，对于 $op = 2$ 的操作我们把 $b_x$ 修改为 $y$，对于 $op = 3$ 的操作我们输出 $\max\limits_{x \le l \le l+1 < r \le y} \psi(l,r)$，其中 $\psi(i,k) = a_i + a_k - \min \limits _{i<j<k} b_j$。

### 解决

不难看出这道题是一道线段树合并的题。线段树功能：单点修改，区间查询。

这颗线段树每个节点需要维护的信息有：

- $a$，表示该节点及它子树中 $a$ 的最大值。

- $b$，表示该节点及它子树中 $b$ 的最小值。

- $lans$，表示对于该节点 $i$，$a_i - b_j$ 的最大值，其中 $j>i$。

- $rans$，表示对于该节点 $i$，$a_k - b_j$ 的最大值，其中 $j<k$。

- $ans$，即答案 $\psi$。

给出代码：

``` cpp
struct Tree
{
	int a,b,lans,rans,ans;
	Tree()
	{
		lans=rans=ans=-0x3f3f3f3f;
	}
};
Tree tree[2000010];
```

现在开始建树。因为 $a$ 和 $b$ 不是一起输入的，所以先输入所有的 $a$  再 build。

给出主函数代码：

``` cpp
for(int i=1;i<=n;i++) read(tmp[i]);
```

给出 build 代码：

``` cpp
inline void build(int l,int r,int rt)
{
	if(l==r)
	{
		tree[rt].a=tmp[l],read(tree[rt].b);
		return;
	}
	int mid=(l+r)/2;
	build(ls),build(rs),pushup(rt);
}
```

给出 pushup 代码，因为本题只是单点修改，所以不涉及懒惰标记和 pushdown：

```cpp
inline void pushup(const int &rt)
{
	tree[rt].a=max(tree[rt*2].a,tree[rt*2+1].a),tree[rt].b=min(tree[rt*2].b,tree[rt*2+1].b);
	tree[rt].lans=max(tree[rt*2].lans,max(tree[rt*2+1].lans,tree[rt*2].a-tree[rt*2+1].b));
	tree[rt].rans=max(tree[rt*2].rans,max(tree[rt*2+1].rans,tree[rt*2+1].a-tree[rt*2].b));
	tree[rt].ans=max(max(tree[rt*2].ans,tree[rt*2+1].ans),max(tree[rt*2].lans+tree[rt*2+1].a,tree[rt*2+1].rans+tree[rt*2].a));
}
```

这里对于第一种和第二种修改没有什么可说的，直接看查询。

查询区间为 $L,R$，查询节点区间为 $l,r$，如果查询区间完全包含了当前区间，则直接返回当前节点。

查询区间与当前节点的交集只在 $l,mid$ 之间，则直接返回继续查询左儿子即可。

查询区间与当前节点的交集只在 $mid + 1,r$ 之间，则直接返回继续查询右儿子即可。

如果在左儿子和右儿子都有，则把查询左右儿子的返回值合并再返回即可。

代码：

``` cpp
inline Tree ask(const int &L,const int &R,int l,int r,int rt)
{
	if(l>=L && r<=R) return tree[rt];
	int mid=(l+r)/2;
	if(mid>=R) return ask(L,R,ls);
	if(mid<L) return ask(L,R,rs);
	Tree ret,x=ask(L,R,ls),y=ask(L,R,rs);
	ret.a=max(x.a,y.a),ret.b=min(x.b,y.b),ret.ans=max(max(x.ans,y.ans),max(x.lans+y.a,y.rans+x.a));
	ret.lans=max(x.lans,max(y.lans,x.a-y.b)),ret.rans=max(x.rans,max(y.rans,y.a-x.b));
	return ret;
}
```

下面给出完整代码：

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ls l,mid,rt*2
#define rs mid+1,r,rt*2+1
#define Getchar() p1==p2 and (p2=(p1=Inf)+fread(Inf,1,1<<21,stdin),p1==p2)?EOF:*p1++
#define Putchar(c) p3==p4 and (fwrite(Ouf,1,1<<21,stdout),p3=Ouf),*p3++=c
char Inf[1<<21],Ouf[1<<21],*p1,*p2,*p3=Ouf,*p4=Ouf+(1<<21);
struct Tree
{
	int a,b,lans,rans,ans;
	Tree()
	{
		lans=rans=ans=-0x3f3f3f3f;
	}
};
Tree tree[2000010];
inline void read(int &x,char c=Getchar())
{
	bool f=c!='-';
	x=0;
	while(c<48 or c>57) c=Getchar(),f&=c!='-';
	while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();
	x=f?x:-x;
}
inline void write(int x)
{
	if(x<0) Putchar('-'),x=-x;
	if(x>=10) write(x/10),x%=10;
	Putchar(x^48);
}
int n,m,tmp[500010];
inline void pushup(const int &rt)
{
	tree[rt].a=max(tree[rt*2].a,tree[rt*2+1].a),tree[rt].b=min(tree[rt*2].b,tree[rt*2+1].b);
	tree[rt].lans=max(tree[rt*2].lans,max(tree[rt*2+1].lans,tree[rt*2].a-tree[rt*2+1].b));
	tree[rt].rans=max(tree[rt*2].rans,max(tree[rt*2+1].rans,tree[rt*2+1].a-tree[rt*2].b));
	tree[rt].ans=max(max(tree[rt*2].ans,tree[rt*2+1].ans),max(tree[rt*2].lans+tree[rt*2+1].a,tree[rt*2+1].rans+tree[rt*2].a));
}
inline void build(int l,int r,int rt)
{
	if(l==r)
	{
		tree[rt].a=tmp[l],read(tree[rt].b);
		return;
	}
	int mid=(l+r)/2;
	build(ls),build(rs),pushup(rt);
}
inline void fix1(const int &pos,const int &val,int l,int r,int rt)
{
	if(l==r)
	{
		tree[rt].a=val;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=pos) fix1(pos,val,ls);
	else fix1(pos,val,rs);
	pushup(rt);
}
inline void fix2(const int &pos,const int &val,int l,int r,int rt)
{
	if(l==r)
	{
		tree[rt].b=val;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=pos) fix2(pos,val,ls);
	else fix2(pos,val,rs);
	pushup(rt);
}
inline Tree ask(const int &L,const int &R,int l,int r,int rt)
{
	if(l>=L && r<=R) return tree[rt];
	int mid=(l+r)/2;
	if(mid>=R) return ask(L,R,ls);
	if(mid<L) return ask(L,R,rs);
	Tree ret,x=ask(L,R,ls),y=ask(L,R,rs);
	ret.a=max(x.a,y.a),ret.b=min(x.b,y.b),ret.ans=max(max(x.ans,y.ans),max(x.lans+y.a,y.rans+x.a));
	ret.lans=max(x.lans,max(y.lans,x.a-y.b)),ret.rans=max(x.rans,max(y.rans,y.a-x.b));
	return ret;
}
int main()
{
	read(n),read(m);
	for(int i=1;i<=n;i++) read(tmp[i]);
	build(1,n,1);
	for(int i=1,op,x,y;i<=m;i++)
	{
		read(op),read(x),read(y);
		if(op==1) fix1(x,y,1,n,1);
		else if(op==2) fix2(x,y,1,n,1);
		else write(ask(x,y,1,n,1).ans),Putchar('\n');
	}
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```



---

## 作者：Sktic (赞：0)

[P7706 「Wdsr-2.7」文文的摄影布置](https://www.luogu.com.cn/problem/P7706)



首先看本题的数据范围： $1\le n,m\le 5\times10^5$ 。



可以推断出应该是一个 $O(n\log n)$ 的算法。



于是考虑上线段树维护 $\psi$ 的值。



为方便理解，下面用 $rel_i$ 表示题中 $A_i$ ，用 $siz_i$ 表示题中 $B_i$ （与代码相统一）。



由于 $\psi(i,k)=rel_i-min(siz_j)+rel_k$ ，且 $i<j<k$ 。



考虑合并操作，对于一个大区间（编号为 $x$ ）的 $\psi$ ，要从它的左儿子（ $x<<1$ ）与右儿子（ $x<<1|1$ ）合并答案，于是由 $i<j<k$ 可以得出有以下情况：



$1.$ $i,j,k$ 全部在 $leftson$ 内：



此时答案显然为 $c[x].ans=c[x<<1].ans$ 。



$2.$ $i,j,k$ 全部在 $rightson$ 内：



此时类比可得 $c[x].ans=c[x<<1|1].ans$ 。



$3.$ $i,j$ 在 $leftson$ 内，$k$ 在 $rightson$ 内：



此时答案被分成左右两份， 对于右边这份很好考虑，直接选取 $rightson$ 中的 $max(rel_i)$ 即可，而最大值是很好维护的，可以做到 $O(1)$ 合并。代码：``c[x].mar=max(c[x<<1].mar,c[x<<1|1].mar);``



再看左边，考虑再维护 $rel_i-min(siz_j)$ 的值，而它也可以分为左右两份分开维护，对于左边的 $max(rel_i)$ 就是先前维护的 $mar$ ，而右边的 $min(siz_j)$ 可以维护区间最小值，合并也是 $O(1)$ 。代码：``c[x].mis=min(c[x<<1].mis,c[x<<1|1.mis]);``



此时左右两部分都处理完毕，考虑合并 $rel_i-min(siz_j)(i<j)$ 。设它为 $mau$ 显然它既可能两部分都在左儿子，对答案贡献为 ``c[x].mau=c[x<<1].mau`` ，同理也都可能在右儿子，为 ``c[x].mau=c[x<<1|1].mau`` 。考虑一个在左一个在右的情况，此时要使答案最大，左边为 $c[x<<1].mar$ ，右边为 $c[x<<1|1].mis$ ，对答案的贡献就是 ``c[x].mau=c[x<<1].mar-c[x<<1|1].mis`` ，于是对于合并时取三者的最大值就可以了。代码：``c[x].mau=max(max(c[x<<1].mau,c[x<<1|1].mau),c[x<<1].mar-c[x<<1|1].mis);``



于是这时候 $c[x].ans=c[x<<1].mau+c[x<<1|1].mar$ 。



$4.$ $i$ 在 $leftson$ 内，$j,k$ 在 $rightson$ 内：

此时大体与 $3$ 时相同，设 $c[x].mad$ 为 $rel_i-min(siz_j)(i>j)$ 的最大值，此时 ``c[x].mad=max(max(c[x<<1].mad,c[x<<1|1].mad),c[x<<1|1].mar-c[x<<1].mis);``  



同理可得  $c[x].ans=c[x<<1|1].mad+c[x<<1].mar$ 。

于是将 $1,2,3,4$ 结合起来，我们就得到了正确的 $pushup$ 代码：

```C++
void pushup(int x)
{
	c[x].mar=max(c[x<<1].mar,c[x<<1|1].mar);
	c[x].mis=min(c[x<<1].mis,c[x<<1|1].mis);
	c[x].mau=max(max(c[x<<1].mau,c[x<<1|1].mau),c[x<<1].mar-c[x<<1|1].mis);
	c[x].mad=max(max(c[x<<1].mad,c[x<<1|1].mad),c[x<<1|1].mar-c[x<<1].mis);
	c[x].ans=max(max(c[x<<1].ans,c[x<<1|1].ans),max(c[x<<1].mau+c[x<<1|1].mar,c[x<<1|1].mad+c[x<<1].mar));
}
```

最后再加上两个单点修改与查询（查询返回结构体，因为要在查询时再做一遍与 $pushup$ 类似的操作），这道题就做完了。

AC Code:

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
const int inf=0x3f3f3f3f;
int rel[maxn],siz[maxn];
struct node
{
	int l,r;
	int mar,mis;//maxrelax and minsize
	int mau,mad;//maxup(mar_i-mis_j)(i<j) and maxdown(mar_i-mis_j)(i>j)
	int ans;
}c[maxn<<2];
void pushup(int x)
{
	c[x].mar=max(c[x<<1].mar,c[x<<1|1].mar);
	c[x].mis=min(c[x<<1].mis,c[x<<1|1].mis);
	c[x].mau=max(max(c[x<<1].mau,c[x<<1|1].mau),c[x<<1].mar-c[x<<1|1].mis);
	c[x].mad=max(max(c[x<<1].mad,c[x<<1|1].mad),c[x<<1|1].mar-c[x<<1].mis);
	c[x].ans=max(max(c[x<<1].ans,c[x<<1|1].ans),max(c[x<<1].mau+c[x<<1|1].mar,c[x<<1|1].mad+c[x<<1].mar));
}
void build(int x,int l,int r)
{
	c[x].l=l;c[x].r=r;
	if(l==r)
	{
		c[x].mar=rel[l];c[x].mis=siz[l];
		c[x].mau=c[x].mad=c[x].ans=-inf;
		return;
	}
	int mid=(c[x].l+c[x].r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	pushup(x);
	return;
}
void modifyr(int x,int pos,int k)
{
	if(c[x].l==c[x].r)
	{
		c[x].mar=k;
		return;
	}
	int mid=(c[x].l+c[x].r)>>1;
	if(pos<=mid)
		modifyr(x<<1,pos,k);
	else
		modifyr(x<<1|1,pos,k);
	pushup(x);
	return;
}
void modifys(int x,int pos,int k)
{
	if(c[x].l==c[x].r)
	{
		c[x].mis=k;
		return;
	}
	int mid=(c[x].l+c[x].r)>>1;
	if(pos<=mid)
		modifys(x<<1,pos,k);
	else
		modifys(x<<1|1,pos,k);
	pushup(x);
	return;
}
node query(int x,int l,int r)
{
	if(c[x].l>=l&&c[x].r<=r)
		return c[x];
	int mid=(c[x].l+c[x].r)>>1;
	if(mid>=r)
		return query(x<<1,l,r);
	if(mid+1<=l)
		return query(x<<1|1,l,r);
	node mot,ls=query(x<<1,l,r),rs=query(x<<1|1,l,r);
	mot.mar=max(ls.mar,rs.mar);
	mot.mis=min(ls.mis,rs.mis);
	mot.mau=max(max(ls.mau,rs.mau),ls.mar-rs.mis);
	mot.mad=max(max(ls.mad,rs.mad),rs.mar-ls.mis);
	mot.ans=max(max(ls.ans,rs.ans),max(ls.mau+rs.mar,rs.mad+ls.mar));
	return mot;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&rel[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&siz[i]);
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int op,x,y;
		scanf("%d%d%d",&op,&x,&y);
		if(op==1)
			modifyr(1,x,y);
		else if(op==2)
			modifys(1,x,y);
		else
			printf("%d\n",query(1,x,y).ans);
	}
	return 0;
}
```

我太菜了可能讲的不是特别清楚\kk，望管理大大通过\kel，有不好的也可以在评论区指出，我会修改。

---

## 作者：IdnadRev (赞：0)

挺简单的。

由于是要求最大化贡献，所以减去的 $b$ 值如果不是最小一定不优。

那么就是选择 $x<y<z$ 最大化 $a_x+a_z-b_y$ 了，直接线段树即可维护，大概维护 A 的最大值、B 的最小值、AB 型的最大值、BA 型的最大值、ABA 型的最大值即可。

复杂度 $O(n\log n)$。

```
#include<stdio.h>
#include<iostream>
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
#define mid (l+r>>1)
#define inf 1000000000
using namespace std;
const int maxn=500005,maxt=maxn<<2;
int n,m;
int a[maxn],b[maxn];
struct node {
	int a,b,ab,ba,aba;
} t[maxt];
node operator+(node x,node y) {
	return node {max(x.a,y.a),min(x.b,y.b),max(x.a-y.b,max(x.ab,y.ab)),max(y.a-x.b,max(x.ba,y.ba)),max(max(x.ab+y.a,x.a+y.ba),max(x.aba,y.aba))};
}
inline void init(int now,int p) {
	t[now]=node {a[p],b[p],-inf,-inf,-inf};
}
inline void pushup(int now) {
	t[now]=t[lc(now)]+t[rc(now)];
}
void build(int l,int r,int now) {
	if(l==r) {
		init(now,l);
		return ;
	}
	build(l,mid,lc(now)),build(mid+1,r,rc(now)),pushup(now);
}
void modify(int l,int r,int now,int p) {
	if(l==r) {
		init(now,l);
		return ;
	}
	if(p<=mid)
		modify(l,mid,lc(now),p);
	else modify(mid+1,r,rc(now),p);
	pushup(now);
}
node query(int l,int r,int now,int L,int R) {
	if(L<=l&&r<=R)
		return t[now];
	if(L<=mid&&mid<R)
		return query(l,mid,lc(now),L,R)+query(mid+1,r,rc(now),L,R);
	return L<=mid? query(l,mid,lc(now),L,R):query(mid+1,r,rc(now),L,R);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
		scanf("%d",&a[i]);
	for(int i=1; i<=n; i++)
		scanf("%d",&b[i]);
	build(1,n,1);
	for(int i=1,o,x,y; i<=m; i++) {
		scanf("%d%d%d",&o,&x,&y);
		if(o==1)
			a[x]=y,modify(1,n,1,x);
		if(o==2)
			b[x]=y,modify(1,n,1,x);
		if(o==3)
			printf("%d\n",query(1,n,1,x,y).aba);
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：0)

## 思路

题目中出现了单点修改、区间查询，容易想到使用线段树。

$\psi$ 并不容易直接维护，考虑一个区间的 $\psi$ 是如何从两个儿子合并得到的。根据题目，$\psi(i,k)=A_i+A_k-\min(B_j)$，$i,j,k$ 在哪个儿子内对答案合并是有影响的。所以先分类讨论 $i,j,k$ 的位置。

$i,j,k$ 均在左儿子或均在右儿子内：

这两种情况直接取左儿子和右儿子最大的 $\psi$ 即可。

$i,j$ 在左儿子内，$k$ 在右儿子内：

那么答案就是左儿子最大的 $A_i-B_j(i<j)$ 加上右儿子最大的 $A_k$。

$i$ 在左儿子内，$j,k$ 在右儿子内：

那么答案就是左儿子最大的 $A_i$ 加上右儿子最大的 $A_k-B_j(j<k)$。

至此，我们分类讨论完了所有情况。可以发现，需要维护的值是 $A_i-B_j(i<j)$ 的最大值、$A_i-B_j(i>j)$ 的最大值和 $A_i$ 的最大值。

最后一个很好维护，继续考虑前两个值怎么维护。

要使 $A_i-B_j$ 最大，则应该让 $A_i$ 尽量大，$B_j$ 尽量小。所以只需维护 $A_i$ 最大值和 $B_j$ 最小值就行了。剩下的就是一些细节问题了。

需要注意初值要赋成负无穷大，因为没法保证最大值一定大于零。

## 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5;
struct tree{
	int l,r;
	int mx,mxa,mxb,mi,ans;//Amax,A-Bmax,-B+Amax,Bmin,ans
}t[N<<2];
int n,m,a[N],b[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void push_up(int p){
	t[p].mx=max(t[p<<1].mx,t[p<<1|1].mx);
	t[p].mi=min(t[p<<1].mi,t[p<<1|1].mi);
	t[p].mxa=max(t[p<<1].mxa,max(t[p<<1|1].mxa,t[p<<1].mx-t[p<<1|1].mi));
	t[p].mxb=max(t[p<<1].mxb,max(t[p<<1|1].mxb,t[p<<1|1].mx-t[p<<1].mi));
	t[p].ans=max(t[p<<1].ans,max(t[p<<1|1].ans,max(t[p<<1].mxa+t[p<<1|1].mx,t[p<<1].mx+t[p<<1|1].mxb)));
	return;
}
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r){
		t[p].mx=a[l];
		t[p].mi=b[l];
		t[p].mxa=-1145141919810;
		t[p].mxb=-1145141919810;
		t[p].ans=-1145141919810;
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void change(int p,int l){
	if(l==t[p].l&&t[p].r==l){
		t[p].mx=a[l];
		t[p].mi=b[l];
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid)change(p<<1,l);
	if(l>mid)change(p<<1|1,l);
	push_up(p);
}
tree ask(int p,int l,int r){//cout<<p<<endl;
	//cout<<t[p].l<<" "<<t[p].r<<endl;
	if(l<=t[p].l&&t[p].r<=r)return t[p];
	int mid=(t[p].l+t[p].r)>>1;
	if(l>mid)return ask(p<<1|1,l,r);
	else if(r<=mid)return ask(p<<1,l,r);
	else{
		tree t,ta,tb;
		ta=ask(p<<1,l,r);
		tb=ask(p<<1|1,l,r);
		t.mx=max(ta.mx,tb.mx);
		t.mi=min(ta.mi,tb.mi);
		t.mxa=max(ta.mxa,max(tb.mxa,ta.mx-tb.mi));
		t.mxb=max(ta.mxb,max(tb.mxb,tb.mx-ta.mi));
		t.ans=max(ta.ans,max(tb.ans,max(ta.mxa+tb.mx,ta.mx+tb.mxb)));
		return t;
	}
}
signed main(){
	//freopen("std.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	build(1,1,n);
	while(m--){
		int op;op=read();//cout<<1<<endl;
		if(op==1){
			int x,y;x=read();y=read();
			a[x]=y;
			change(1,x);
		}
		else if(op==2){
			int x,y;x=read();y=read();
			b[x]=y;
			change(1,x);
		}
		else{
			int l,r;l=read();r=read();
			printf("%d\n",ask(1,l,r).ans);
		}
	}
	return 0;
}

```
## 代码



---


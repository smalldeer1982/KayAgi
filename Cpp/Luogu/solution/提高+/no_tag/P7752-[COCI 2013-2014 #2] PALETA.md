# [COCI 2013/2014 #2] PALETA

## 题目描述

Mirko 有 $k$ 种颜色和 $n$ 个图像需要上色。图像编号从 $1$ 到 $n$，他决定用 $k$ 种颜色中的一种来填充每个图像。

为此，他选择了 $n$ 个数字 $f_i$，并决定按照如下方法涂色：

- 若 $f_i\ne i$，则图像 $i$ 与图像 $f_i$ 的颜色不应该相同。
- 若 $f_i=i$，他可以在满足所有其他条件的基础上，将图像 $f_i$ 涂成任何颜色。

你需要求出上色的可能方法的数量。

**由于输出可能非常大，你只需要输出答案对 $\bm{10^9+7}$ 取模后的结果。**

## 说明/提示

#### 样例 1 说明

共有 $3$ 种颜色，并且图像 2 的颜色不能与图像 1 相同。可能的上色方案为 $(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)$，其中括号中两个数字分别表示两个图像的颜色。

#### 样例 4 说明

共有 $4$ 种颜色。

- 对于图像 1，可以涂成任何颜色。
- 对于图像 2，颜色不能与图像 1 相同。
- 对于图像 3，颜色不能与图像 2 相同。

即图像 2 可以用除了图象 1 外的 $3$ 种颜色着色，图像 3 可以用除了图象 2 外的 $3$ 种颜色着色。

答案为 $4\times 3\times 3=36$。

#### 数据规模与约定

- 对于 $50\%$ 的数据，有 $f_i\ne f_j(1\le i\ne j\le n)$。
- 对于 $100\%$ 的数据，有 $1\le n,k\le 10^6$。

对于所有合法的 $f_i$，有 $1\le f_i\le n$。

#### 来源

**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T5 PALETA_。**

按照原题数据配置，本题满分 $140$ 分。

## 样例 #1

### 输入

```
2 3
2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
3 4
2 3 1```

### 输出

```
24```

## 样例 #3

### 输入

```
3 4
2 1 1```

### 输出

```
36```

## 样例 #4

### 输入

```
3 4
1 1 2```

### 输出

```
36```

# 题解

## 作者：佬头 (赞：4)

## Description
有 $k$ 种颜色和 $n$ 个图像，图像编号从 $1$ 到 $n$。给定 $n$ 个 $f_i$ 并按照如下方法用 $k$ 种颜色涂色：
- 若 $f_i\ne i$，则图像 $i$ 不能与图像 $f_i$ 的颜色相同。
- 若 $f_i=i$，图像 $f_i$ 可以涂成任何颜色。

求出可能的[**涂色总方案数**](https://www.luogu.com.cn/problem/P7752)，答案对 $\bm{10^9+7}$ 取模。

## Solution
由 $i$ 向 $f_i$ 建边，那么每个点就仅有一条出边，如果从一个点 $i$ 不断沿着 $f_i$ 走，总会陷入一个环中（包括 $f_i=i$），因此不难想到它会是一棵**内向基环树**，整幅图就是一张**内向基环森林**。类似于：

![](https://cdn.luogu.com.cn/upload/image_hosting/ah67vrz9.png)

内向基环树可以形象地理解为一个环上长了若干棵树，当然也存在某个没长树的环，那就把**环**和**树**分开来考虑（显然两种情况的限制是不一样的）：
- 对于一棵树而言，如果其根结点的涂色固定，则其儿子结点的涂色就都是 $(k-1)$ 种。同理：对于所有树上的非叶子结点，他们的儿子结点的涂色方案数也都为 $(k-1)$ 种（仅保证每个结点与其父结点的涂色不同即可）。那么一棵大小为 $size$ 的树对答案的贡献就是 $ans\gets ans\times (k-1)^{size-1}$（根结点的涂色固定了，因此减一）。
- 接下来就是环。显然每个环除结点数以外都是相类似的，考虑 **dp**：设 $dp_i$ 表示有 $i$ 个结点的环的方案数：
	+ 当 $1\le i\le3$ 的情况是显然的（每个点都互不相同）：
		* $dp_1=k$；
		* $dp_2=k\times(k-1)$；
		* $dp_3=k\times(k-1)\times(k-2)$。
   + 当 $i\gt3$ 时：
		* 从 $i-1$ 的环里插入一个结点 $A$，此时与 $A$ 相连的两个结点互不相同，则 $A$ 的涂色方案就有 $(k-2)$ 种。
		* 把 $i-2$ 的环里的一个结点拆成两个完全相同的结点，同时在中间插入结点 $A$，此时与 $A$ 相连的两个结点完全相同，则 $A$ 的涂色方案就有 $(k-1)$ 种。
		
		则递推式就是 $dp_i=dp_{i-1}\times\left(k-2\right)+dp_{i-2}\times\left(k-1\right)~(i\gt 3)$。
		
		这个显然可以预处理掉，最后我们只需要把每个环的大小 $size$ 求出来再更新答案即可 $ans\gets ans\times dp_{size}$。（$i\gt3$ 是因为 $i=1$ 拆成的两个完全相同的结点**相邻**）

最后思考如何把树和环分开来。就用[**拓扑排序**](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-b3644)吧，把环以外的结点全部先计算掉，那么剩下的肯定都是单独的环，就很方便处理了。~~（我一开始还想用 **tarjan** 缩点来着，但是好像不用这么麻烦）~~

时间复杂度 $\mathcal O(n)$。

## Code
```cpp
#include <iostream>
using namespace std;
const int N = 1000006, mod = 1000000007;
int n, k, dp[N], f[N], out[N], ans = 1, q[N], back;
bool vis[N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	n = read(), k = read();
	dp[1] = k;
	dp[2] = (long long)k * (k - 1) % mod;
	dp[3] = (long long)dp[2] * (k - 2) % mod;
	for(int i = 4; i <= n; ++ i) dp[i] = (long long)dp[i - 1] * (k - 2) % mod + (long long)dp[i - 2] * (k - 1) % mod;
	for(int i = 1; i <= n; ++ i) ++ out[f[i] = read()];
	for(int i = 1; i <= n; ++ i) if(!out[i]) q[++ back] = i;
	for(int front = 1; front <= back; ++ front){
		vis[q[front]] = 1;
		ans = (long long)ans * (k - 1) % mod;
		if(!-- out[f[q[front]]]) q[++ back] = f[q[front]];
	}
	for(int i = 1, cnt, x; i <= n; ++ i)
		if(!vis[i]){
			for(cnt = 0, x = i; !vis[x]; x = f[x]) vis[x] = 1, ++ cnt;
			ans = (long long)ans * dp[cnt] % mod;
		}
	write(ans);
	return 0;
}
```
## Strengthen
[**P2607 [ZJOI2008] 骑士**](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-p2607)

---

## 作者：y3kkc (赞：2)

## 题意  
见[洛谷](https://www.luogu.com.cn/problem/P7752)。  
## 分析  
比较套路的一题。  

首先需要明白一点，每个图像之间并不存在必然的顺序关系，即与下标无关，我们很自然的把整个问题转换成图来解决。   

图的性质也很显然，是基环树组成的森林（环也算特殊的基环树）。  

那么我们套路地进行缩点，即将环缩成一个点来计算。  

先不急想环怎么处理，假如给定的是一棵树问染色方案，我们不难想到除了根节点有 $k$ 种，其他节点因为要与父节点相异，都只有 $k - 1$ 种。  

假使基环树的环看作根，那么其他点的染色方案均为 $k - 1$，也就是说非环上的节点有 $k - 1$ 种染色方案，这部分的贡献我们用乘法原理即可求出。  

接下来求解环的染色方案。  

我们可以拆环成链，暂且先不考虑起点和终点的那条边。  

除了起点可以有 $k$ 个颜色，其他点必选与前面的颜色相异，所以只有 $k - 1$ 种颜色。  

设 $i$ 为链的节点个数，$dp_i$ 为方案数，那么有：
$$dp_i = k \times (k - 1)^{i - 1}$$  

现在在考虑将最后一条边加上，我们可以用总方案数减去不合法方案数的方法。  

我们确保了其他边的合法性，显然只有起点和终点颜色一样是不合法的，那么我们就可以形象地把两个点当成一个点来看，此时共有 $dp_{i-1}$ 种不合法方案数，是我们多算的，减去即可。  

于是就有：
$$dp_i = k \times (k - 1)^{i - 1} - dp_{i - 1}$$  

递推计算即可。  

最后算出图中的每个环的大小，乘法原理通乘即可。  

## 代码  
```cpp
#include <cstdio>
#include <queue>
using namespace std;
namespace Faster {
//char buf[1 << 23], *p1 = buf, *p2 = buf;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 23, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
    int num = 0, sgn = 1;
    char ch = getchar();
    for (; ch < 48 || ch > 57; ch = getchar())
        if (ch == '-')
            sgn = -1;
    for (; ch >= 48 && ch <= 57; ch = getchar()) num = (num << 3) + (num << 1) + (ch & 15);
    return sgn * num;
}
inline void write(int num) {
    static int sta[39], top = 0;
    if (num < 0)
        putchar('-'), num *= -1;
    do
        sta[++top] = num % 10, num /= 10;
    while (num);
    while (top) putchar(sta[top--] | 48);
    return;
}
} using namespace Faster;
const int N = 1e6 + 9;
const int mod = 1e9 + 7;
int n, k, ans = 1;
int dp[N];//dp[i]表示有i个点的环的方案数 
int deg[N];
bool vis[N];
int head[N], ver[N << 1], nxt[N << 1], tot;
inline void add(int u, int v) {
	ver[++tot] = v;
	nxt[tot] = head[u];
	head[u] = tot;
	return;
}
inline int kpow(int a, int b) {
	int res = 1;
	for (; b; b >>= 1) {
		if (b & 1) 
			res = 1ll * res * a % mod;
		a = 1ll * a * a % mod;
	}
	return res;
}
void prework() {//预处理dp 
	dp[1] = k;
	dp[2] = 1ll * k * (k - 1) % mod;
	for (int i = 3; i <= n; ++i) {
		dp[i] = ((1l * k * kpow(k - 1, i - 1) % mod - dp[i - 1]) % mod + mod) % mod;
	}
	return;
}
signed main() {
	n = read(), k = read();
	prework();
	for (int i = 1; i <= n; ++i) {
		int x = read();
		add(i, x);
		add(x, i);
		++deg[i], ++deg[x];
	}
	
	queue<int> q;
	for (int i = 1; i <= n; ++i) {
		if (deg[i] == 1)
			q.push(i), vis[i] = 1;
			
	}
	while (q.size()) {
		int u = q.front();q.pop();
		for (int i = head[u]; i; i = nxt[i]) {
			int v = ver[i];
			if (vis[v])
				continue;
			if (--deg[v] == 1) {
				q.push(v);
				vis[v] = 1;
			}
		}
	}
	int hz = 0;
	for (int i = 1; i <= n; ++i) if (vis[i]) ++hz;
	ans = kpow(k - 1, hz);//非环上的点
	 
	for (int i = 1; i <= n; ++i) {
		if (vis[i])
			continue;
		int sz = 0;
		q.push(i);
		vis[i] = 1;
		while (q.size()) {
			++sz;
			int u = q.front();q.pop();
			for (int i = head[u]; i; i = nxt[i]) {
				int v = ver[i];
				if (vis[v])
					continue;
				q.push(v);
				vis[v] = 1;
			}
		}
		ans = 1ll * ans * dp[sz] % mod;//环上的点 
	}
	printf("%d\n", ans);
    return 0;
}
```

## 总结  
该问题的关键点：
* 转换成图。  

* 环和其他点分开处理。  

* 乘法原理。

---

## 作者：djh0314 (赞：1)

[**洛谷**](https://www.luogu.com.cn/problem/P7752)。

## 题意
一共有 $n$ 个图像，可以染成 $k$ 种颜色。同时，每个图像有一个数字 $f_i$，若 $f_i\ne i$，则 $i$ 不能与 $f_i$ 同色；若 $f_i=i$，对于 $i$，可以选任何颜色。

## 分析

首先把每一个 $f$ 转化成边，即 $f_i$ 与 $i$ 连一条边，那么一共有 $n$ 条边，整个图就变成了一个基环树森林。

那么我们的整个计算就可以分成两类：一个是链上的，另一个是环上的（包括自环）。

对于链上的，由于我们是拓扑计算，因此，我们只需要考虑其对于父亲的影响，由于其与其父亲不同，因此我们这个节点一共有 $k-1$ 种选法。
~~~cpp
while(!q.empty()) {
	int now=q.front();
	q.pop();
	vis[now]=1;
	val[fa[now]]=1ll*val[fa[now]]*val[now]%MOD*(m-1)%MOD;//m即k
	if(!(--d[fa[now]])) q.push(fa[now]);
}
~~~

接下来的就是环上的计算，我们先拆环成链，那么最后的方案数可以转化成最后一个节点与第一个节点颜色不同的方案数，简单 DP 即可。

令 $f_{i,0}$ 表示第 $i$ 位与第一位选择一样的方案数，$f_{i,1}$ 表示第 $i$ 位与第一位选择不样的方案数。

那么很容易写出递推式：          
$f_{i,0}=f_{i-1,1}$；              
$f_{i,1}=f_{i-1,1}\times (k-2)+f_{i-1,0}\times (k-1)$。

至于每一个节点转移上来的选法全部累乘即可。

但是这题完结了吗？并没有，将我们上述的所有块代码打完，我们提交后可以惊现：
![](https://cdn.luogu.com.cn/upload/image_hosting/vbomekj7.png)

居然 MLE 了，此题的空间限制是 32MB。因此，我们需要一定程度上的优化我们的空间（当然也有些大佬一开始写的时候空间就比较小）。

1. 如果是喜欢 define 来开 long long 的，要去掉。
2. 如果是 dfs 统计环上节点数的，需要用循环。
3. 可以把环上的 DP 滚动。

### 总结一下，这道题考验了一个基环树上的计算，以及一点点成分的 DP。

[**Code**](https://www.luogu.com.cn/paste/zit75the)。

---

## 作者：LINCE (赞：0)

## 性质分析

首先，$n$ 个图片可以理解为 $n$ 个点，$f_i$ 可以理解为从 $i$ 至 $f_i$ 的一条边。

其次，每个“块”都是独立的。

由于每个点都只有一条入边，那么每个“块”都属于有根树、环、内向基环树、单点之一，而单点的计算方式可以归入树中。

### 有根树

对于一棵有根树，根节点是无限制条件的，方案为 $k$ 种，而子节点都只会受其父亲节点的影响，因此每个子节点的方案数为 $k-1$ 种。

因此，对于一颗大小为 $s$ 的有根树，方案数为 $k\times(k-1)^{s-1}$ 种。

在上述计算过程中，树的形状是不影响结果的，因此可以预处理。

### 环

考虑断环成链。

我指定其中的一个点颜色为 $c$，然后删去这个节点。

则断成的链首尾均不能取到颜色 $c$。

这里采用较直观的动态规划。

链首 $c$ 颜色方案数为 $0$，其余方案数为 $1$。
其后的转移方程为：$dp_{i,j}=\sum_{x=1}^{k}dp_{i-1,x}(x\ne{j})$。

其中 $i$ 为第几个节点，$j$ 为第几种颜色。

由于所有非 $c$ 的颜色都是等价的，所以可以分为两类：$c$ 和非 $c$。

于是转移方程为：$dp_{i,0}=(k-1)\times dp_{i-1,1}$，$dp_{i,1}=(k-2)\times dp_{i-1,1}+dp_{i-1,0}$。

而这个可以用滚动数组优化空间。

最后方案数为：$sum_i=(k-1)\times dp_{i,1}$。

### 内向基环树

考虑拓扑排序。

环外的可以“切”成树，余下的环就可以处理了。

处理树用拓扑排序，所以边可以只从 $i$ 连至 $f_i$。

环可以用深搜处理。

为了优化空间，又由于出边只有一条，所以可以通过循环处理。

注意，切的时候，环与树的“交点”两边都要算进去。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[1000001],s,dp[1000001],r[1000001];
long long ans=1,g[1000001],h[2][2],sum[1000001];
bool vis[1000001];
queue<int>q;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	g[1]=1;
	for(int i=2;i<=n;i++){
		g[i]=g[i-1]*(k-1)%1000000007;
	}
	h[1][0]=0,h[1][1]=1,sum[1]=k-1;
	for(int i=2;i<=n;i++){
		h[i&1][0]=h[(i&1)^1][1]*(k-1)%1000000007;
		h[i&1][1]=(h[(i&1)^1][1]*(k-2)%1000000007+h[(i&1)^1][0])%1000000007;
		sum[i]=h[i&1][1]*(k-1)%1000000007;
	}
	for(int i=1;i<=n;i++){
		cin>>f[i];
		if(f[i]!=i)r[f[i]]++;
		dp[i]=1;
	}
	for(int i=1;i<=n;i++){
		if(!r[i])q.push(i);
	}
	while(q.size()){
		int x=q.front();
		vis[x]=1;
		q.pop();
		if(f[x]!=x){
			r[f[x]]--;
			dp[f[x]]+=dp[x];//为了处理树与切下来的“树”，所以拓扑，将节点个数“推”至根节点或环上
			dp[x]=0;
			if(!r[f[x]])q.push(f[x]);
		}
	}
	for(int i=1;i<=n;i++){
		if(f[i]==i)ans=ans*g[dp[i]]%1000000007*k%1000000007;//若为树的根节点
			else if(f[i]!=i&&dp[i]>1)ans=ans*g[dp[i]]%1000000007;//若为基环树上“根节点”
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			s=0;
			int x=i;
			while(1){
				if(vis[x])break;
				s++;
				vis[x]=1;
				x=f[x];
			}//等效于dfs
			s--;
			ans=ans*sum[s]%1000000007*k%1000000007;//对于环的统计，注意不要忘了一开始有k种选择
		}
	}
	cout<<ans;
}
```


---


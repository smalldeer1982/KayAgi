# [COCI 2012/2013 #3] HERKABE

## 题目背景

Herkabe 老师决定再次对他的学生进行排名。

## 题目描述

这一次，Herkabe 老师希望他的排行榜在审美上也是令人愉快的，所以他决定有相同前缀的名字必须在名单上彼此相邻。因此，他制定了一个规定：**对于名单上每两个有相同前缀的名字，在排行榜上他们之间的所有名字也应当有这一个前缀**。

现在，给定 $n$ 个学生的名字，求 Herkabe 老师能制作出多少个不同的排行榜以满足上述规则。由于结果可能很大，你只需要输出这个答案对 $10^9+7$ 取模的结果。

## 说明/提示

**【数据范围】**

本题一共 $7$ 个测试点，各个测试点的数据范围如下表所示：

| 测试点编号 | $n\leqslant$ |
| :-----------: | :-----------: |
| $1\sim 3$ | $10$ |
| $4\sim 7$ | $3000$ |

对于所有数据，字符串的长度在 $[1,3000]$ 之间，仅包含大写英文字母且保证互不相同。

**【题目来源】**

本题来源自 **_[COCI 2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST 3](https://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf) T5 HERKABE_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3
IVO
JASNA
JOSIPA```

### 输出

```
4```

## 样例 #2

### 输入

```
5
MARICA
MARTA
MATO
MARA
MARTINA```

### 输出

```
24```

## 样例 #3

### 输入

```
4
A
AA
AAA
AAAA```

### 输出

```
8```

# 题解

## 作者：i262303 (赞：10)

# [题面传送门](https://www.luogu.com.cn/problem/P7758)


首先，Herkabe 老师要把前缀相同的放在一起，本蒟蒻选择采用sort的方式（大佬有更好的方法可以留言）

然后，我们就成功地将 $n$ 个字符串分成第一个字符相同的 $m$ 组字符串

对于求 $m$ 组字符串的排列数 ，~~其实很简单~~。 

我们定义 $f_i$ 为第 $i$ 组字符串的排列数，那么 $m$ 组字符串的排列数就是 $(\prod_{i=1}^m f_i)\cdot m!$

那么我们只要求出每一组字符串的方案数，就可以知道答案了。

在上述求 $n$ 个字符串的排列数时，很显然我们用了分治的思想，所以求每一组的方案数我们也可以考虑用分治思想，将一组中的字符串再分为第二个字符相同的几个组，继续分治递归求解，那么我们就可以用分治递归求得最终解。

递归的边界就是当当前组中的字符串数为 $1$ ，返回 $1$ 。

------------

最后给大家康康本蒟蒻丑陋的代码

```cpp
//我的码风有点奇怪
//加了点卡常的东西
//如：把 ++i 打成 i=-~i ，把 --i 打成 i=~-i
//不过认真看了前面题解的人应该能理解吧
//wjd 666
#include <cstdio>
#include <string>
#include <ctype.h>
#include <iostream>
#include <algorithm>
#define il inline
#define int long long
#define ri register int
using namespace std;
//简简单单的快读快写，其实这题可以不用，只是个人习惯而已
namespace wjd{
	il int read(){
		int x(0);
		char ch(getchar());
		while(!isdigit(ch)) ch=getchar();
		while(isdigit(ch)){
			x=(x<<3)+(x<<1)+(ch&15);
			ch=getchar();
		}
		return x;
	}
	il void write(int x){
		if(x>9) write(x/10);
		putchar((x%10)|48);
	}
}
using namespace wjd;
const int N=3e3+5;
const int MOD=1e9+7;
int fac[N];
string s[N];
//分治递归求解
il int work(int x,int l,int r){
	if((-~l)>=r) return 1;
	ri ll(l),res(1),num(1);
	for(ri i=(-~l);i<r;i=-~i){
		if(s[i][x]==s[ll][x]) continue;
		res=res*work(-~x,ll,i)%MOD;
		ll=i,num=-~num;
	}
	res=res*work(-~x,ll,r)%MOD;
	//最后乘上全排列（阶乘）
	return res*fac[num]%MOD;
}
signed main(){
	int n(read());
	fac[1]=1;
	for(ri i(1);i<=n;i=-~i) cin>>s[i],fac[-~i]=fac[i]*(-~i)%MOD;
	sort(s+1,s+n+1);
	write(work(0,1,-~n));
	return 0;
}

```


------------

以上就是本蒟蒻对这道灰题的解法，蟹蟹观看 $QAQ$

---

## 作者：_maojun_ (赞：3)

一种卡空间的做法。

---

我们手摸一下样例 $2$，先给它排序。

```
MARA
MARICA
MARTA
MARTINA
MATO
```

我们思考 $24=2^3\times3$ 的答案是怎么得来的。

先算出相邻串的 LCP：$3,3,4,2$。

发现中间的那个 $4$ 一定是要有限被满足的，即在最终排序结果中这两个字符串一定是一个连续段，且内部无序。

那么我们把这两个字符串“合并”（现在还不知道应该为什么，我们称为 `MART?`），并统计上答案 $2!$。

然后剩下的串长这样：

```
MARA
MARICA
MART?
MATO
```

相邻串的 LCP：$3,3,2$

这次你就先处理 $3,3$，合并三个字符串并统计上答案 $3!$。

最后再统计上 $2!$，就得到了 $24$。

---

我们总结一下这个算法的流程：

1. 给字符串排序，并求出相邻串的 LCP

1. 找出 LCP 最大的连续段，“合并”并给答案乘上 $(c+1)!$，$c$ 为连续段大小（对应 $c+1$ 个字符串）.

1. 若只剩 $1$ 个字符串，输出答案，否则重复 $1$。

因为我们每次选出的是 LCP 最大的连续段，所以它左右的串与它的 LCP 比段内的 LCP 小，所以直接在 $c+1$ 个字符里面随便保留一个即可。

LCP 可以字符串哈希 + 二分。

合并 $c+1$ 个字符串相当于删除 $c$ 个字符串，链表维护。

你发现这个过程中字符串会一直保持有序，所以只有开始的时候要排序。

到此就基本结束了，复杂度 $O(n^2\log n)$。

你高高兴兴地写完然后发现 MLE 了两个点，于是你把你的哈希数组从 `unsigned long long` 改成 `unsigned short` 然后过了。（这样不会冲突？）

```cpp
typedef long long ll;typedef unsigned short ull;// 竟然没有哈希冲突？
inline int gn(char c){return c-'A'+1;}
const int N=3e3+5,MOD=1e9+7;
int n;ll fac[N];string s[N];
int len[N];
const ull seed=31;
ull H[N][N];

int pre[N],nxt[N],sim[N];
inline int LCP(int x,int y){		// 字符串哈希+二分计算 LCP(s[x],s[y])
	int l=0,r=min(len[x],len[y]),mid;
	while(l<r){mid=l+r+1>>1;H[x][mid]==H[y][mid]?l=mid:r=mid-1;}
	return l;
}
int main(){
	scanf("%d",&n);
	fac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%MOD;
	for(int i=1;i<=n;i++)cin>>s[i];
	sort(s+1,s+n+1);
	for(int i=1;i<=n;i++)for(char c:s[i]){
		int j=++len[i];H[i][j]=H[i][j-1]*seed+gn(c);
	}
	for(int i=0;i<=n;i++){pre[i]=i-1;nxt[i]=i+1;}
	ll res=1;
	while(nxt[nxt[0]]<=n){
		int mx=0;
		for(int i=nxt[nxt[0]];i<=n;i=nxt[i])mx=max(mx,sim[i]=LCP(pre[i],i));sim[n+1]=-1;
		int lst=nxt[0];
		for(int i=nxt[nxt[0]];;i=nxt[i]){
			if(sim[i]^mx){if(nxt[lst]^i){
				int c=1;
				for(int j=nxt[lst];j!=i;j=nxt[j]){
					c++;pre[nxt[j]]=pre[j];nxt[pre[j]]=nxt[j];	// 链表删除，留下 lst（第一个字符串）
				}
				res=res*fac[c]%MOD;break;	// 把数出来的大小的阶乘加入答案
			}lst=i;}
			if(i>n)break;
		}
	}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：returnzheng (赞：2)

先讲一讲思路是哪来的。

先对于以下这组数据：


```cpp
1. AABA
2. ACB
3. AABD
4. AAC
5. BD
6. BEC
```


题目说了，要把有相同前缀的放到一起，可以认为是不同的约束条件。就如上面的数据。其中 $1,2,3,4$ 都是一组，因为它们有共同的前缀 A。同样的，在 $1, 2, 3, 4$ 中 $1, 3, 4$ 又是一组，因为有共有的前缀 AA。以此类推，其他组以这样处理。每组中的必须放在一起。所以对于每一组的方案，就等于这组内每个小组的方案数的乘积再乘上组内的所有小组的排列个数。

可能比较抽象，还是上面的例子，$1, 3, 4$ 中有 $1, 3, 4$ 等 $4$ 种排列，$1, 4, 3$ 是不合法的，因为 $1$ 和 $3$ 有共同前缀 AAB，要放在一起，容易想到，这个组内所有小组的排列个数就是组内直接小组数的阶乘。

综上所述，只需要对所有字符串进行排序，使得所有相同前缀的字符串到一起，然后分治处理即可。~~不会真有人和我一样在赛事打字典树爆了空间吧。~~

代码有一些要注意的，比如有可能有些字符串是其他字符串的前缀。这时就有可能会越界。可以直接把字符串补成一个长度，也可以自己特判一下。记得取模。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long mod = 1e9 + 7;
string s[4000];
int n;
long long dfs(int l = 1, int r = n, int x = 0){
	// cout << l << " " << r << endl;
	if (l == r){
		return 1;
	}
	long long ans = 1;
	long long num = 0;
	int ll = l;
	for (int i = l; i <= r + 1; i++){
		if (i != r + 1 && s[i].size() == x){
			ll = i + 1;
			num++;
			continue;
		}
		if (i == r + 1 || s[i][x] != s[ll][x]){
			ans *= dfs(ll, i - 1, x + 1);
			ans %= mod;
			ll = i;
			num++;
		}
	}
	for (int i = 1; i <= num; i++){
		ans *= i;
		ans %= mod;
	}
	return ans;
}
int main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> s[i];
	}
	sort(s + 1, s + n + 1);
	cout << dfs() << '\n';
	return 0;
}
```

---

## 作者：1232RvE (赞：1)

首先考虑字典树。手搓一下样例 2 发现 $ans$ 是所有结点的子结点个数的排列数，即 $n$ 的阶乘。![trie](https://cdn.luogu.com.cn/upload/image_hosting/q3q9uozu.png)

$A_{R,T}$ 两个子节点，乘以 $(2 \times 1)$。

$R_{A,I,T}$ 三个子结点，乘以 $(3 \times 2 \times 1)$。

$T_{I,A}$ 两个子节点，乘以 $(2 \times 1)$。

用 dfs 跑一遍：

```cpp
ll modi(ll x){
	return (x+mod)%mod;
}

void dfs(int u){
	ll res=1,cnt=0; res=modi(res*mul[sum[u]]);
	if(sum[u]) cnt++;
	for(int i=0;i<=25;i++)//子节点最多26个
		if(tr[u][i]){
			cnt++;
			dfs(tr[u][i]);
			res=modi(res*f[tr[u][i]]);
		}
	res=modi(res*mul[cnt]);
	f[u]=res;
}
```

但是这样过不了，超空间，这题空间给的很小。
所以把字符串排序后分组，然后 dfs 即可。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=3100,mod=1e9+7;
int n;
int fac[N];
struct node{
	string s;
}a[N];
int ans=1;
void dfs(int x,int l,int r){
	if(l>=r)return;
	int L=l,R=l,num=0;
	for(int i=l;i<=r;i++){
		if(a[i].s[x]==a[L].s[x]) R=i;//i与l在第x位节点相同
		else {
			num++;
			dfs(x+1,L,R);
			L=i;
		}
	}
	num++;
	if(L==r) R=r;
	dfs(x+1,L,R);
	ans=ans*fac[num]%mod;//排列。
}
signed main(){
	fac[0]=1;
	for(int i=1;i<=N-10;i++)fac[i]=fac[i-1]*i%mod;//预处理n!（n的阶乘，排列数）。
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].s;
	sort(a+1,a+n+1,[&](node x,node y){
		return x.s<y.s;
	});
	dfs(0,1,n);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：xnmzyz (赞：1)

# [题解：P7758 [COCI 2012/2013 #3] HERKABE](https://www.luogu.com.cn/problem/P7758)

## 题目大意
对于给定的 $n$ 个字符串，求满足以下条件的排列数：
对于任意两个具有相同前缀的字符串，它们之间的所有字符串也必须具有这个前缀。

## 思路
要找出前缀相同的字符串（即有最长相同前缀的字符串放在一起）可以想到对 string 数组进行一次 sort，然后递归进行分组。

由于对于大小为 $n$ 的组（并且没有两个字符串更长的相同前缀），全排列一共有 $n!$ 种方式，所以考虑预处理模 $10^9+7$ 意义下的阶乘。

核心代码有注释，不多做解释。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define endl putchar('\n')
#define isd(c) (c>='0'&&c<='9')
#define isa(c) ((c>='a'&&c<='z')||(c>='A'&&c<='Z'))
#define blank(c) (c=='\n'||c=='\r'||c=='\t'||c==' ')
#define For(i,a,b) for(auto i=(a);i<=(b);i++)
using namespace std;
namespace temp{
char gc(){//直接从缓冲区读入
    static char buf[1<<20],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2) ? EOF : *p1++;
}
void read(string &s){//字符串快读
    char c=gc();
    while(blank(c))c=gc();
    while(!blank(c))s.push_back(c),c=gc();
}
template<class T>void read(T &n){//数字快读
    n=0;char c=gc();int k=1;
    while(!isd(c)){if(c=='-')k*=-1;c=gc();}
    while(isd(c))n=n*10+c-'0',c=gc();
    n*=k;
}
template<class T>void write(T n){//数字快写
    if(n<0)n=-n,putchar('-');
    if(n>9)write(n/10);
    putchar(n%10+'0');
}
}

const int MAXN = 3005;
const LL MOD = 1e9 + 7;
string s[MAXN];
LL fact[MAXN];
int n;

namespace Main{
using namespace temp;
LL dfs(int d, int l, int r) {//核心代码
    if (l >= r) return 1;// 递归边界：当区间为空时，只有1种排列方式
    int endcnt = 0;      // 统计在当前深度结束的字符串数量
    LL res = 1;             // 当前区间的方案数
    int childcnt = 0;    // 统计需要继续分组的子区间数量
    
    int p = l;  // 当前处理位置
    while (p < r) {
        if (d == (int)s[p].size())// 情况1：当前字符串在当前深度结束
            endcnt++,p++;
        else {// 情况2：当前字符串需要继续分组
            char c = s[p][d];
            int seg_l = p;// 子区间起始位置
            while (p < r && d < (int)s[p].size() && s[p][d] == c)p++;
            // 找到相同字符的连续区间
            int seg_r = p;
            res = res * dfs(d + 1, seg_l, seg_r) % MOD;// 递归处理子区间：深度+1，区间[seg_l, seg_r)
            childrencnt++;
        }
    }
    int tot = endcnt + childrencnt;
    res = res * fact[tot] % MOD;// 当前区间的方案数 = 分支排列数 × 子区间方案数乘积
    return res;
}

void Main() {
    read(n);
    For(i,0,n-1) read(s[i]);
    sort(s,s+n);
    fact[0]=1;
    For(i,1,n) fact[i] = fact[i - 1] * i % MOD;//预处理阶乘（ mod 1e9+7）
    write(dfs(0, 0, n));
}
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    Main::Main();
    return 0;
}

```
时间复杂度：$O(nl_{max})$，$l_{max}$ 表示最长字符串的长度，可以通过此题，主要花销为 dfs 函数。

---

## 作者：Untitled_unrevised (赞：1)

### 题目分析

「……所以他决定有相同前缀的名字必须在名单上彼此相邻。……**对于名单上每两个有相同前缀的名字，在排行榜上他们之间的所有名字也应当有这一个前缀。**」

换句话说就是，前缀相同的必须分到一组去。

作为一个简单的例子，样例 1 就需要这么分组：

```plain
IVO, {JASNA, JOSIPA}
```

但对于样例 2，有的字符串有更长的公共前缀，就应该这么分组：

```plain
{
    (LCP = "MA")
    {
        (LCP = "MAR")
        MARA,
        MARICA,
        {
            (LCP = "MART")
            MARTA,
            MARTINA
        }
    },
    MATO
}
```

其中 LCP 指 Longest Common Prefix，最长公共前缀。

### 分组方法

如果你知道字典树的话，最直接的做法就是逐一插入字符串，这样就可以将具有最长公共前缀 $s$ 的字符串都放到以字符串 $s$ 的节点为根的子树下。

但是这题的空间限制是 32 MB，使用字典树对于最后 3 个数据点会 MLE。

一种更节省空间的做法，基于 MSD 型基数排序（从高位到低位比较的基数排序）：

首先枚举公共前缀（注意不用是最长的公共前缀）的长度 $|\mathrm{CP}|$ 为 $1$，此时 $\mathrm{CP} \in \{\mathtt{"A"}, \mathtt{"B"}, \dots, \mathtt{"Z"}\}$。将具有相同 $\mathrm{CP}$ 的字符串分到同一组。

对于每一组，再令 $|\mathrm{CP}| = 2$，比如对于上一次分组已经分到 $\mathrm{CP} = \mathtt{"A"}$ 的，此时 $\mathrm{CP} \in \{\mathtt{"AA"}, \mathtt{"AB"}, \dots, \mathtt{"AZ"}\}$，再接着将具有相同 $\mathrm{CP}$ 的字符串分到同一组。

……

重复上述过程，直至每组只剩一个字符串。

注意：

1. 使用 MSD 型基数排序进行分组后，一定要把字符串倒回原数组，否则一次递归都会不得不创建存储分组情况的数组，一样有可能 MLE；

2. 存储分组情况的数组不要放在执行递归操作的函数里，原因同 1。可以将这个数组设为全局。

3. 直接交换字符串的时间复杂度是线性的，建议只交换指向字符串的指针或引用。

参考代码：

```cpp
typedef char * mystr;
const size_t MAXBUCKET = 27;
std::queue<mystr> bucket[MAXBUCKET];

// [first, last) 里的元素是指向每个字符串的指针
// offset 表示访问每个字符串的第 offset 个字符
void MSD_radix_sort(mystr *first, mystr *last, size_t offset = 0) {
	
	// 如果只剩一个字符串，直接返回
	if(last - first == 1)
		return;
	
	// 分组，存储到 bucket 里
	for(mystr *ptr = first; ptr != last; ++ptr) {
		char ch = (*ptr)[offset];
		int idx = ch ? ch - '@' : 0; // 此处是将 C 风格字符串中的 '\0' 映射到 0，'A' ~ 'Z' 映射到 1 ~ 26
		bucket[idx].push(*ptr);
	}
	
	// 倒回原数组，borders 是每组的边界
	mystr *ptr = first;
	mystr *borders[MAXBUCKET + 1] = {first};
	for(int idx = 0; idx < MAXBUCKET; ++idx) {
		while(!bucket[idx].empty()) {
			*ptr++ = bucket[idx].front();
			bucket[idx].pop();
		}
		borders[idx+1] = ptr;
	}
	
	// 递归分组
	for(int idx = 0; idx < MAXBUCKET; ++idx)
		if(borders[idx+1] != borders[idx])
			MSD_radix_sort(borders[idx], borders[idx+1], offset+1);
	
}
```

### 求方案数

分组完之后，如何求方案数呢？

根据题目，同一个组的字符串必须相邻，但是顺序可以随意调换。

以样例 1 为例：

对于 `IVO` 和 `{JASNA, JOSIPA}` 这 $2$ 组字符串，它们可以自由决定先后顺序，有 $2! = 2$ 种排法：

```
#1:
IVO
{JASNA, JOSIPA}

#2:
{JASNA, JOSIPA}
IVO
```

对于 `JASNA, JOSIPA` 这组字符串，还有 $2! = 2$ 种排法：

```
#1:
JASNA
JOSIPA

#2
JOSIPA
JASNA
```


综上，样例 1 的方案数是 $2! \times 2! = 4$。

再以样例 2 为例：

对于 `{MARICA, MARA, {MARTA, MARTINA}}` 和 `MATO` 这 $2$ 组字符串，有 $2! = 2$ 种排法：

```
#1
{MARICA, MARA, {MARTA, MARTINA}}
MATO

#2
MATO
{MARICA, MARA, {MARTA, MARTINA}}
```

对于 `MARICA, MARA, {MARTA, MARTINA}` 这 $3$ 组字符串，有 $3! = 6$ 种排法：

```
#1:
MARICA
MARA
{MARTA, MARTINA}

...

#6:
{MARTA, MARTINA}
MARA
MARICA
```

对于 `MARTA, MARTINA` 这组字符串，有 $2! = 2$ 种排法。

综上，样例 2 有 $2! \times 2! \times 3! = 24$ 种排法。

以上计算过程可以边分组边计算：

假设待分组的字符串集合为 $S$，求方案数 $f(S)$；

当具有相同 $\mathrm{CP}$ 的字符串分到第 $i$ 组 $T_i$ 后：

$$
f(S) = n![f(T_1)f(T_2)\dots f(T_n)] = n!\prod_{i = 1}^{n}f(T_i)
$$
其中 $n$ 是非空的 $T_i$ 个数。

递归终点：当 $|T| = 1$ 时，$f(T) = 1$。（只有一个字符串也有 $1$ 种排法）

在基数排序代码的基础上进行修改即可，返回值就是当前组能产生的方案数：

```cpp
const long long P = 1000000007;
const long long fact[28] = {
	1, 1, 2, 6, 24,
	120, 720, 5040, 40320, 362880,
	3628800, 39916800, 479001600, 227020758, 178290591,
	674358851, 789741546, 425606191, 660911389, 557316307,
	146326063, 72847302, 602640637, 860734560, 657629300,
	440732388, 459042011, 394134213
};

typedef char * mystr;
const size_t MAXBUCKET = 27;
std::queue<mystr> bucket[MAXBUCKET];

// [first, last) 里的元素是指向每个字符串的指针
// offset 表示访问每个字符串的第 offset 个字符
long long MSD_radix_sort(mystr *first, mystr *last, size_t offset = 0) {
	
	// 如果只剩一个字符串，返回方案数 1
	if(last - first == 1)
		return 1ll;
	
	// 分组，存储到 bucket 里
	for(mystr *ptr = first; ptr != last; ++ptr) {
		char ch = (*ptr)[offset];
		int idx = ch ? ch - '@' : 0; // 此处是将 C 风格字符串中的 '\0' 映射到 0，'A' ~ 'Z' 映射到 1 ~ 26
		bucket[idx].push(*ptr);
	}
	
	// 倒回原数组，borders 是每组的边界
	mystr *ptr = first;
	mystr *borders[MAXBUCKET + 1] = {first};
	for(int idx = 0; idx < MAXBUCKET; ++idx) {
		while(!bucket[idx].empty()) {
			*ptr++ = bucket[idx].front();
			bucket[idx].pop();
		}
		borders[idx+1] = ptr;
	}
	
	// res 记录答案，branch 记录非空子集数
	long long res = 1, branch = 0;	
	
	// 递归分组
	for(int idx = 0; idx < MAXBUCKET; ++idx) {
		if(borders[idx+1] != borders[idx]) {
			res = res * MSD_radix_sort(borders[idx], borders[idx+1], offset+1) % P;
			++branch;
		}
	}
	
	return res * fact[branch] % P;
	
}
```

完整的参考代码如下：

```cpp
#include <stdio.h>
#include <queue>

const long long P = 1000000007;
const long long fact[28] = {
	1, 1, 2, 6, 24,
	120, 720, 5040, 40320, 362880,
	3628800, 39916800, 479001600, 227020758, 178290591,
	674358851, 789741546, 425606191, 660911389, 557316307,
	146326063, 72847302, 602640637, 860734560, 657629300,
	440732388, 459042011, 394134213
};

typedef char * mystr;
const size_t MAXBUCKET = 27;
std::queue<mystr> bucket[MAXBUCKET];

long long MSD_radix_sort(mystr *first, mystr *last, size_t offset = 0) {
	
	if(last - first == 1)
		return 1ll;
	
	for(mystr *ptr = first; ptr != last; ++ptr) {
		char ch = (*ptr)[offset];
		int idx = ch ? ch - '@' : 0;
		bucket[idx].push(*ptr);
	}
	
	mystr *ptr = first;
	mystr *borders[MAXBUCKET + 1] = {first};
	for(int idx = 0; idx < MAXBUCKET; ++idx) {
		while(!bucket[idx].empty()) {
			*ptr++ = bucket[idx].front();
			bucket[idx].pop();
		}
		borders[idx+1] = ptr;
	}
	
	long long res = 1, branch = 0;
	
	for(int idx = 0; idx < MAXBUCKET; ++idx) {
		if(borders[idx+1] != borders[idx]) {
			res = res * MSD_radix_sort(borders[idx], borders[idx+1], offset+1) % P;
			++branch;
		}
	}
	
	return res * fact[branch] % P;
	
}

int main() {
	
	int n;
	scanf("%d", &n);
	char str[3000][3001] = {};
	mystr strptrs[3000] = {};
	
	for(int i = 0; i < n; ++i) {
		scanf("%s", str[i]);
		strptrs[i] = str[i];
	}
	
	printf("%lld", MSD_radix_sort(strptrs, strptrs + n));
	
	return 0;
	
}
```

---

## 作者：Mason123456 (赞：0)

哇哦校内模拟赛五分钟出思路诶。

这道题的难点在于不能学习太多的数据结构比如 Trie。

首先先给所有字符串排序。因为排序之后有一个非常非常奇妙的性质：拥有任意一个公共前缀的一些字符串肯定在一起。

首先，第一个字母相同的字符串肯定在一起。所以我们粗略的将字符串序列分成了若干份。假设我们分成了 $c$ 份，那么重新排列这 $c$ 份的贡献就是 $c!$。然后我们再看每一个首字母相同的块，看块里面能分成多少份并乘上这个贡献。递归处理即可。

这题就愉快的做完了，十分简单。

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define pii pair<int, int>
#define low_bit(x) ((x)&-(x))
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
using ll = long long;
const int N = 3e3 + 5, mod = 1e9 + 7;
string s[N];
int n;
ll jc[N] = {1};

int dfs(int l, int r, int st){// 进行到区间[l, r] 中，从第 st 位开始 
	if(l == r)	return 1;
	int cnt = 0, fir = l;// 可以分成几个区间 
	ll res = 1;
	while((int)s[l].size() <= st)	l++;
	if(l != fir)	cnt++;
	fir = l;
	for(int i = l;i <= r;i++){
		if(s[i][st] != s[fir][st]){
			res *= dfs(fir, i - 1, st + 1);
			res %= mod;
			cnt++, fir = i;
		}
	}
	cnt++;
	res *= dfs(fir, r, st + 1);
	res %= mod;
	res *= jc[cnt];
	res %= mod;
	return res;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n;
	for(int i = 1;i <= n;i++)	jc[i] = (jc[i-1] * i) % mod;
	for(int i = 1;i <= n;i++){
		cin>>s[i];
	}
	sort(s + 1, s + n + 1);
	for(int i = 1;i <= n;i++)	s[i] = " " + s[i];
	cout<<dfs(1, n, 1);
	return 0;
}
```

---


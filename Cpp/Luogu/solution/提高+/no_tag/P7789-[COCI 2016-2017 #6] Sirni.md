# [COCI 2016/2017 #6] Sirni

## 题目描述

有 $N$ 张卡片，每张卡片上写有一个数值 $P_i$。

可以连接任意两张卡片，但需要花费 $\min(P_a\bmod P_b, P_b\bmod P_a)$。

请你求出连接所有卡片所需要的最小花费。

## 说明/提示

**【样例解释 #1】**

连接卡片 $1$ 和卡片 $2$，花费 $\min(2\bmod 6,6\bmod 2)=0$；

连接卡片 $2$ 和卡片 $3$，花费 $\min(3\bmod 6,6\bmod 3)=0$；

连接卡片 $1$ 和卡片 $4$，花费 $\min(2\bmod 11,11\bmod 2)=1$。

总共花费 $0+0+1=1$。

**【数据范围】**

对于 $30\%$ 的数据，$1\le N\le 10^3$；

对于另外 $40\%$ 的数据，$1\le P_i\le 10^6$；

对于 $100\%$ 的数据，$1\le N\le 10^5$，$1\le P_i\le 10^7$。

**【说明】**

本题分值按 COCI 原题设置，满分 $140$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T5 SIRNI**_

## 样例 #1

### 输入

```
4
2
6
3
11 ```

### 输出

```
1```

## 样例 #2

### 输入

```
4
1
2
3
4 ```

### 输出

```
0```

## 样例 #3

### 输入

```
3
4
9
15 ```

### 输出

```
4```

# 题解

## 作者：摸鱼酱 (赞：13)

给定序列 $a_{1\cdots n}$，生成一张 $n$ 个点的无向完全图，$i,j$ 之间的边权为 $\min\{a_i\bmod a_j,a_j\bmod a_i\}$，求最小生成树。

$1\leq n\leq 10^5$，$1\leq a_i\leq 10^7$。

朴素地找边显然有 $O(n^2)$ 条，考虑实际是否真的有这么多有效边。

首先对于所有权值去重，相同权值的默认是同一个点，记 $m=\max\{a_i\}$。

对于每一个权值 $x$，我们可以去枚举它的倍数 $d$，找到值在 $[dx,(d+1)x)$ 内最小的数，记为一条有效边，特殊地，$d=1$ 时范围为 $(x,2x)$。

因为值域很小，找数这个操作可以放到桶里，从后往前扫一遍得到。

于是这样会找到 $O(m\ln m)$ 条边，找到之后桶排做 Kruskal，就可以做到 $O(m\ln m·\alpha(n))$，如果只有这些有效边，复杂度和空间都是可以接受的。

考虑如何证明这样一定不劣，假设一个点 $a$ 连向的不是某个倍数区间里第一个数 $b$，而是靠后一些的 $c$，显然有 $c>b>a,b\bmod a< c\bmod a$，我们考虑把 $a-c$ 改为 $a-b-c$，新的花费是 $c\bmod b+b\bmod a$，原本的花费是 $c\bmod a$，设 $\lfloor \frac ca\rfloor =\lfloor \frac ba\rfloor=d$，则有原来的花费为 $c-d·a$，新的花费为 $c-b·\lfloor\frac cb\rfloor +b-d·a$，显然有前者不小于后者，于是完成了证明。



---

## 作者：王鲲鹏 (赞：4)

## [COCI2016-2017#6] Sirni 解题报告

首先发现相同权值的点是没用的，直接删掉（unique）即可。

对两个数值 $a<b$，
$$
\min(a\bmod b,b \bmod a)=\min(a, b \bmod a)=b\bmod a
$$
一定是大的模小的更小，所以从小到大排序。

然后可以证(luan)明(cai)一下，候选边集一定是由这种边构成：由值 $x$ 与第一个值大于等于 $kx$ 且小于 $(k+1)x$ 的值 $y$ 相连的边，其中 $k \in \mathbb{N}^*$。范围的右界是为了保证每条边不会被多次计算。

可以这样证明，若有 $kx\le y < z < (k+1)x$，那么用边 $(x,z)$ 不如用边 $(y,z)$。

于是就枚举每个值的倍数，`lower_bound` 找到对应的 $y$，检验是否在右界内，然后加入待选边集。

这样的话边集最多是 $O(V\log V)$ 级别的，因为 $V=10^7$，5s 时限还好。

最后 Kruskal 一下。

```cpp
int const maxn = 100003;
inline int read() {
	int x = 0, c = getchar();
	while (!isdigit(c))
		c = getchar();
	while (isdigit(c)) {
		x = 10 * x + c - '0';
		c = getchar();
	}
	return x;
}

int n = 0;
int p[maxn], Mx = 0;

int fa[maxn], siz[maxn];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
inline void merge(int x, int y) {
	x = find(x); y = find(y);
	if (siz[x] < siz[y]) swap(x, y);
	fa[y] = x;
	siz[x] += siz[y];
}

struct Edge {
	int x, y;
	int v;
};
bool operator<(Edge const &lhs, Edge const &rhs) { return lhs.v < rhs.v; }
vector<Edge> q;

inline void addEdges(int id) {
	int x = p[id];
	for (int y = x; y <= Mx; y += x) {
		int k = lower_bound(p + id + 1, p + n + 1, y) - p;
		if (k <= n && p[k] / x == y / x) q.push_back(Edge{ id, k, p[k] % p[id] });
	}
}

int main() {
	n = read();
	for (int i = 1; i <= n; ++i)
		p[i] = read();
	sort(p + 1, p + n + 1);
	n = unique(p + 1, p + n + 1) - p - 1;
	Mx = p[n];
	for (int i = 1; i <= n + 1; ++i) {
		fa[i] = i;
		siz[i] = 1;
	}
	long long ans = 0;
	for (int i = 1; i <= n; ++i)
		addEdges(i);
	sort(q.begin(), q.end());
	for (auto e : q) {
		int yy = find(e.y), xx = find(e.x);
		if (yy != xx) {
			ans += e.v;
			merge(xx, yy);
		}
	}
	printf("%lld", ans);
	return 0;
}
```


我一开始用的 priority_queue，然后 TLE 了... 改成 vector+sort+O2 过了...

（并不清楚这是不是最优复杂度）

---

## 作者：Lucyna_Kushinada (赞：2)

很明显这题要我们求的是最小生成树，不过 $n\le 10^5$，显然不能暴力连边，我们考虑优化建图。

首先我们先把序列的数去重，因为相同的数可以向另一个和自己相同的数连一条边权为 $0$ 的边，去掉没有任何影响。

我们连边肯定是从大的数连向小的数，因为大的数模小的数是显然优于小的数模大的数的，于是我们把数组从小到大排序。

对于一个 $a_i$，我们枚举它的倍数，对于一个正整数 $k$，将每一个在 $[k\times a_i,(k+1)\times a_i)$ 中且最小的数向 $i$ 连一条边，边权即为它模上 $a_i$，可以证明这样建出来的图最后一定是联通的，且一定是最优的，因为对于两个数 $k\times x\le a < b \le (k+1)\times x$，一定有 $a\bmod x<b\bmod x$。

连完之后跑最小生成树即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 101145
//#define int long long

int n,a[N];
const int lim=1e7;
set<int>s;

struct edge{
	int u,v,w;
	edge(int a,int b,int c){u=a,v=b,w=c;}
};
vector<edge>e;

inline bool cmp(edge x,edge y){
	return x.w<y.w;
}

struct DSU{
	int fa[N];
	
	inline void init(){
		rep(i,1,n){
			fa[i]=i;
		}
	}
	
	inline int ask(int k){
		if(k==fa[k]){
			return fa[k];
		}
		return fa[k]=ask(fa[k]);
	}
	
	inline void mg(int x,int y){
		//y<-x
		int fx=ask(x),fy=ask(y);
		if(fx==fy)return;
		
		fa[fx]=fy;
	}
}b;

inline long long kruskal(){
	int cnt=0;
	long long ans=0;
	b.init();
	
	for(edge x:e){
		int u=x.u,v=x.v,w=x.w;
		
		if(b.ask(u)==b.ask(v)){
			continue;
		}
		
		ans+=w;
		cnt++;
		
		b.mg(u,v);
		
		if(cnt==n-1){
			break;
		}
	}
	
	return ans;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	rep(i,1,n){
		cin>>a[i];
		s.insert(a[i]);
	}
	
	int cnt=0;
	for(int x:s){
		a[++cnt]=x;
	}
	n=cnt;
	
	/*
	a>b
	max(a%b)=b-1
	b%a=b
	*/
	
	sort(a+1,a+1+n);
	
	rep(i,1,n){
		int l=a[i];
		
		while(l<=lim){
			int r=min(l+a[i],lim);
			
			int id=lower_bound(a+i+1,a+n+1,l)-a;
			if(a[id]<r&&id!=n+1){
				e.push_back(edge(i,id,a[id]%a[i]));
			}
			
			l+=a[i];
		}
	}
	
	sort(e.begin(),e.end(),cmp);
	
	cout<<kruskal();
	
	return 0;
}
```

---

## 作者：slzx2022YuYihan (赞：2)

## [P7789 [COCI2016-2017#6] Sirni](https://www.luogu.com.cn/problem/P7789)

# Solution

30pts 应该很好做，直接建所有的边，做个 Kruskal 即可。

其实，这里有许多冗余的边，等待我们去删除。

先研究一下 $\min(a\mod b,b\mod a)$ 是怎么一回事。

*	若 $a<b$，$\min(a\mod b,b\mod a)=\min(a,b\mod a)=b\mod a$。
*	若 $a=b$，$\min(a\mod b,b\mod a)=0$。
*	若 $a>b$，$\min(a\mod b,b\mod a)=\min(a\mod b,b)=a\mod b$。

因此，我们归纳出：$\min(a\mod b,b\mod a)=(\max(a,b))\mod (\min(a,b))$。

因此，我们可以先排序，然后去重。

发现 $1\le P_i\le 10^7$，时限 5 秒，思路启动于这里，难道可以 $O(m\ln m)$ 吗？对于每个 $P_i$，我们枚举它的倍数 $k$，使用二分查找除以 $P_i$ 的商也为 $k$ 的最小的 $P_{loc}$，如果存在，那么就可以加入这条边。最后用一遍 Kruskal。

这题必须吸氧！如果你用 int，但压缩路径并查集没优化，那么恭喜你，已经有 130pts 了。如果你小小优化了压缩路径并查集，但没用 int，那么恭喜你，你还是 130pts。因此，两个优化都加上去，恭喜你，你总算 AC 了！

在这里，想说一声：真的毒瘤！

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

const int N = 1e5 + 5;

const int M = 1e7 + 5;

int n, a[N], ma, ans;

int fa[N], sz[N];
int getfa(int x){
	return fa[x] == x ? x : fa[x] = getfa(fa[x]);
}

struct Edge{
	int u, v, w;
};
bool operator< (Edge alp, Edge bet){
	return alp.w < bet.w;
}
vector<Edge> vec;
void add(int x){
	for (register int i = a[x]; i <= ma; i += a[x]){
		int loc = lower_bound(a + x + 1, a + n + 1, i) - a;
		if (loc <= n && a[loc] / a[x] == i / a[x])	vec.push_back((Edge){x, loc, a[loc] % a[x]});
	}
}

int main(){
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	read(n);
	for (register int i = 1; i <= n; ++i)
		read(a[i]), ma = max(ma, a[i]);
	sort(a + 1, a + n + 1);
	n = unique(a + 1, a + n + 1) - (a + 1);
	for (register int i = 1; i <= n; ++i)
		fa[i] = i, add(i);
	sort(vec.begin(), vec.end());
	for (auto e : vec){
		int x = getfa(e.u), y = getfa(e.v), w = e.w;
		if (x ^ y){
			ans += w;
			if (sz[x] < sz[y])	swap(x, y);
			fa[y] = x, sz[x] += sz[y];
		}
	}

	return write(ans), putchar('\n'), 0;
}
```

---

## 作者：Provicy (赞：2)

$\text{Problem}:$[Sirni](https://www.luogu.com.cn/problem/P7789)

$\text{Solution}:$​

当 $P_{a}>P_{b}$ 时，连接 $a,b$ 的代价即为 $P_{a}\text{ mod }P_{b}$。这样去掉了 $\min$。

首先将权值相同的点合并。对于权值为 $x$​ 的点，我们只需对于每个 $k$​，找到满足 $kx\leq w<(k+1)x$​ 的最小的 $w$​（当 $k=1$​ 时为 $x<w<2x$​），添加一条连接 $x$​ 与 $w$​ 的边即可。简单证明：假设存在 $w_{2}$​，满足 $kx\leq w<w_{2}<(k+1)x$​ 且权值区间 $(w,w2)$​​ 中没有结点（否则是一个子问题），那么根据上面的连边方式，一定存在 $x\rightarrow w$​ 与 $w\rightarrow w_{2}$​ 这两条边，而这两边的权值和与 $x\rightarrow w_{2}$​​ 这条边的权值相同。故连 $x\rightarrow w_{2}$​ 一定不会更优。

总边数为 $O(V\log V)$​，而边权最大值小于 $V$，故利用用桶排序然后求出最小生成树即可。总时间复杂度 $O(n+V\log V\cdot \alpha(V))$，可以通过。

$\text{Code}:$

```cpp
#include <bits/stdc++.h>
//#pragma GCC optimize(3)
//#define int long long
#define ri register
#define mk make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define is insert
#define es erase
#define vi vector<int>
#define vpi vector<pair<int,int>>
using namespace std; const int N=10000010;
inline int read()
{
	int s=0, w=1; ri char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48), ch=getchar();
	return s*w;
}
int n,a[N],up,f[N],lar[N]; long long ans;
vpi g[N];
inline int Find(int x) { return f[x]^x?f[x]=Find(f[x]):x; }
signed main()
{
	n=read();
	for(ri int i=1;i<=n;i++)
	{
		int x=read();
		a[x]++, up=max(up,x);
		lar[x]=x;
	}
	for(ri int i=up-1;i;i--)
	{
		if(!lar[i]) lar[i]=lar[i+1];
	}
	for(ri int i=1;i<=up;i++)
	{
		if(!a[i]) continue;
		for(ri int j=i;j<=up;j+=i)
		{
			int l=(j==i)?(i+1):(j), r=min(j+i-1,up);
			if(lar[l]<=r) g[lar[l]%i].eb(mk(i,lar[l]));
		}
	}
	for(ri int i=1;i<=up;i++) f[i]=i;
	for(ri int i=0;i<=up;i++)
	{
		for(auto j:g[i])
		{
			int x=Find(j.fi), y=Find(j.se);
			if(x==y) continue;
			ans+=i, f[x]=y;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：鱼跃于渊 (赞：1)

## 解法

对于最小生成树问题，首先考虑 kruskal。  
把 $n^2$ 条边都连出来可以得到 $30$ 分，考虑去除无用的边。  

首先如果有两张卡片的 $P$ 相同，把它们连在一起的贡献显然为 $0$，所以需要去重。  
接着考虑一条边的边权 $\min(P_i \bmod P_j,P_j\bmod P_i)$，其实就是 $\max(P_i,P_j)\bmod \min(P_i,P_j)$。  
所以对 $P$ 序列排一遍序，这样 $i,j$（$1\le i<j\le n$）的边权即为 $P_j\bmod P_i$。  

对于每个 $P_i$，我们可以枚举它的倍数 $d$，找到在 $[dP_i,(d+1)P_i)$ 之间最小的 $P_j$。  
则边 $(i,j,P_j\bmod P_i)$ 是有用的，可能被选入最小生成树中。  
考虑证明这样一定不会更劣：  

+ 设一个数 $x$ 连的不是区间内最小的 $y$，而是稍大的 $z$。  
+ 显然有 $x<y<z,y\bmod x<z\bmod x$。  
+ 连 $(x,z)$ 的边权为 $z\bmod x$，连 $(x,y),(y,z)$ 的边权为 $z\bmod y+y\bmod x$。  
+ 设 $d$ 为当前枚举的倍数，则有 $\lfloor\dfrac{z}{x}\rfloor=\lfloor\dfrac{y}{x}\rfloor=d$。  
+ 原边权为 $z-d\times x$，新边权为 $z-y\times\lfloor\dfrac{z}{y}\rfloor+y-d\times x$。  
+ 显然前者一定不大于后者。  
 
记 $V$ 为 $\max_{i=1}^{n}P_i$，这样边集最多是 $O(V\log V)$ 的，在 5s 的时限下可以通过。  

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
#define per(i,a,b) for(int i=(a);i<=(b);i++)
#define rep(i,b,a) for(int i=(b);i>=(a);i--)
#define all(x,l,r) &(x)[l],&(x)[r]+1
#define epb emplace_back
struct edge{
	int u,v,w;
	edge(int _u=0,int _v=0,int _w=0){
		u=_u;v=_v;w=_w;
	}
};
int n,mx,ans,p[N],fa[N],siz[N];
vector <edge> e;
int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	per(i,1,n) cin>>p[i],mx=max(mx,p[i]);
    sort(all(p,1,n));
    n=unique(all(p,1,n))-p-1;
	iota(all(fa,1,n),1);
	fill(all(siz,1,n),1);
	per(i,1,n){
		for(int j=p[i];j<=mx;j+=p[i]){
			int k=lower_bound(p+i+1,p+n+1,j)-p;
			if(k<=n&&p[k]/p[i]==j/p[i])
				e.epb(i,k,p[k]%p[i]);
		}
	}
	sort(e.begin(),e.end(),[](const edge &x,const edge &y){
		return x.w<y.w;
	});
	for(auto x:e){
		int u=find(x.u),v=find(x.v);
		if(u==v) continue;
		ans+=x.w;
		if(siz[u]>siz[v]) swap(u,v);
		fa[u]=v;siz[v]+=siz[u];
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Purslane (赞：1)

## Solution

首先 , $P$ 一样的点是可以免费连的 , 直接 unique .

考虑 $\text{Kruskal}$ . 有 $n^2$ 条边 . 但真的都是有用的吗 ? 

首先明确 , 边权其实是 $\text{max} \{ P_a,P_b \} \text{ mod } \text{min} \{P_a,P_b\}$ . 

对于每一个点 , 寻找比他大的点 . 取模想当一个技巧 : 枚举商 , 复杂度 $V \text{ ln } V$  级别的 .

对于一个数 $a$ , 它的商为 $k$ 的时候 , 区间 $[ka,(k+1)a)$ (当商是 $1$ 的时候不应选上他自己) 有多个数 . **我们只需要向最小的连边** .

Why ? 设最小的是 $x_1$ , 第二小时 $x_2$ .

显然连 $x_2$ 的边权是 $x_2 - ka$ , **和分别连** $a$ , $x_1$ ; $x_1$ , $x_2$ 的值一样。那么多连一个何乐而不为 ? 所以我们只需要向 $x_1$ 连边 .

注意找 $x_1$ 的过程可以用二分 , 十有八九会 $\text{TLE}$ , 所以用桶记录一下 . 参见代码 .

求 MST 的过程不再赘述 .

code :

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Int int
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10,MAXM=1e7+10;
Int n,sze[MAXN],a[MAXN],fa[MAXN];
Int nxt[MAXM];
vector<pair<Int,pair<Int,Int>>> E;
Int find(Int k) {
	if(fa[k]==k) return fa[k];
	return fa[k]=find(fa[k]);
}
signed main() {
	scanf("%lld",&n);int mx=0;
	ffor(i,1,n) scanf("%lld",&a[i]);
	sort(a+1,a+n+1),n=unique(a+1,a+n+1)-a-1;
	ffor(i,1,n) mx=max(mx,a[i]);
	memset(nxt,0x3f,sizeof(nxt));
	ffor(i,1,n) nxt[a[i]]=i;
	roff(i,mx,1) if(nxt[i]>n) nxt[i]=nxt[i+1];
	ffor(i,1,n) { //add edges
		for(Int l=a[i];l<=mx;l+=a[i]) {
			Int pos=nxt[max(l,a[i]+1)];
			if(pos<=n&&a[pos]<l+a[i]) E.push_back({a[pos]-l,{pos,i}});
		}	
	}
	ffor(i,1,n) sze[i]=1,fa[i]=i;
	Int cnt=0;ll ans=0;
	sort(E.begin(),E.end());
	for(auto tmp:E) {
		int w=tmp.first,x=tmp.second.first,y=tmp.second.second;
		x=find(x),y=find(y);
		if(x==y) continue;
		if(sze[x]>sze[y]) swap(x,y);
		cnt++;fa[x]=y,sze[y]+=sze[x],ans+=w;
		if(cnt==n-1) break;
	}
	cout<<ans;
	return 0;
}
```

Ps : 二分卡了我多长时间 , 到头来不用二分 /ll

---

## 作者：xiao7_Mr_10_ (赞：0)

很常规的一个题。

遇到这种最小生成树题，难度一般都在建图和缩减有效边上。我们从这个角度看待问题，需要简化边权表达式，令 $x<y$：

$\min(x \bmod y,y \bmod x) = \min(x,y \bmod x)=y \bmod x$。

边权即较大数对较小数取模的值，考虑对原数组去重并从小到大排序，便于处理问题，并且答案显然不变。

对于点 $i$，其点权为 $x=a_i$，考虑其实际上的有效边：即枚举正整数 $k$，要求另外一个数落在 $[kx,(k+1)x)$ 上。并且这个数最小。

这只是一个感性的猜想，我们还需要证明它的正确性。首先，在枚举一个固定的 $k$ 时设有两条边 $(x,y)$ 与 $(x,z)$。其中 $a_y<a_z$。

若直接连接 $x-z$ 使得其联通则代价为 $a_z\bmod a_x$ 即 $a_z - ka_x$。若连接 $x-y-z$ 代价为 $a_y-ka_x+a_z-a_y$。注意 $a_z \bmod a_y$ 等于 $a_z - a_y$，因为有 $a_z>a_y$ 且 $a_z<2a_y$。

所以我们猜想是正确的，边集近似于调和级数 $O(n \ln V)$。但实际运行远超这个量级，大概在 $3.7 \times 10^7$ 左右。

说一下实现细节：卡常是必须的，为了规避排序我们可以用值域 $V$ 个 vector 存边，然后依次遍历做到排序效果。并查集可以加上按秩合并，并且在加入了 $n-1$ 条边立即输出答案即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,M=1e7+5;
int n,a[N],f[N],len,siz[N];
struct Point{
	int u,v;
};int V;
vector <Point> g[M];
inline int getf(int u){
	if(f[u]==u)return u;
	return f[u]=getf(f[u]);
}
long long ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++)cin >> a[i],siz[i]=1;sort(a+1,a+1+n);
	n=unique(a+1,a+1+n)-a-1;V=a[n];
	for(register int i = 1;i <= n;i++){
		f[i]=i;
		for(register int j = 1;j*i <= V;j++){
			int id=lower_bound(a+i+1,a+1+n,j*a[i])-a;
			if(id<=n&&a[id]<(j+1)*a[i])g[a[id]%a[i]].push_back((Point){i,id});
		}
	}
	int cnt=0;
	for(register int i = 0;i <= V;i++){
		for(int j = 0;j < g[i].size();j++){	
			if(cnt==n-1){
				cout << ans;
				exit(0);
			}
			int x=g[i][j].u,y=g[i][j].v;
			x=getf(x),y=getf(y);
			if(x==y)continue;
			if(siz[x]<siz[y])swap(x,y);
			f[y]=x,siz[x]+=siz[y];
			cnt++;ans+=i;
		}
	}
	return 0;
}

```

---

## 作者：Bobi2014 (赞：0)

这是一道~~可爱~~的最小生成树题和数学题的组合。

### 前置知识

- [Kruskal 算法](https://blog.csdn.net/qq_36932169/article/details/81236147)

### 思路与做法

观察题目，我们发现在不优化的情况下要建 $10^5$ 的平方条边，肯定会 TLE $+$ MLE，我们考虑是不是所有的边都是有用的，也就是能不能只建有用的边，观察边权的计算方式，易得做法如下:

- 相同权值的点是没有的，只要将相同权值的点连起来就可以了，可以直接删除，只剩一个。
- 我们将点权数组从小到大排序后，发现肯定是大的 $mod$ 小的更小，也就是后面的 $mod$ 前面的更小。
- 对于一个点 $i$，设 $i$ 的权值为 $x$，$y$ 为任意正整数，只需要建 $i$ 到权值是 $x \times y$ 到 $x \times (y + 1) - 1$ 且节点编号比 $i$ 大的编号最小的节点即可。（当 $x \times y$ 已经比权值的最大值还大时可以 `break`）
- 建完边后直接做最小生成树就可以了。

### 时间复杂度分析

- 删除权值一样的点 $O(n)$。
- 排序 $O(n \log n)$。
- 建边最多 $O(V \log V)$。
- 最小生成树最多是设 $V \log V$ 为 $x$，那么就是 $O(x \log x)$。

最终时间复杂度优化一下常数就可以过了，巅峰用时可以控制在 $4.12$ 秒内。

---

## 作者：Thomas0218 (赞：0)

## 分析
题意：给定一个 $n$ 个点的无向完全图，点 $i$ 和点 $j$ 之间的边权为 $\min(P_i \mod P_j,P_j \mod P_i)$。求最小生成树。

首先，对于 $P$ 相同的点均可以删掉，因为它们之间的边权均为 $0$。

我们钦定 $P_i<P_j$。那么 $i$ 之间的边权即为 $\min(P_i,P_j \mod P_i)$。发现 $P_i$ 一定是大于 $P_j \mod P_i$。所以它们之间的边权就是 $P_j \mod P_i$。

于是我们对 $P$ 排个序，就消去了边权里的 $\min$。此时，对了 $i<j$，为了使边权更小，需要满足 $P_j\mod P_i$ 更小。对于每个 $i$，我们枚举其倍数 $kP_i$，然后求出 $[kP_i,(k+1)P_i)$ 内最小的 $P_j$，并由 $i$ 向 $j$ 连边。由调和级数可知，这样我们最多有 $O(n\ln V)$ 条边，其中 $V$ 是值域。直接排序跑 Kruskal，时间复杂度 $O(n\log^2 V\alpha(n))$，可以通过。注意使用路径压缩和按秩合并优化并查集。

考虑如何证明这么连边正确的。对于 $P_i$，若连接的不是 $[kP_i,(k+1)P_i)$ 内最小的 $P_j$，而连接的是另一个更大的 $P_m$，那么边权为 $P_m-kP_i$。而连接 $i,j$ 和 $j,m$ 的边权为 $P_m-P_j\lfloor{\frac{P_m}{P_j}}\rfloor+P_j-kP_i$。比较这两个式子。由于 $P_m>P_j$，$(1-\lfloor{\frac{P_m}{P_j}}\rfloor)P_j\leq0$ 可得连接 $i,j$ 和 $j,m$ 的边权更小，于是就证完了。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int a[N], n, f[N], sz[N], mx; struct Edge { int u, v, w; }; vector <Edge> e;
bool cmp(Edge a, Edge b) { return a.w < b.w; }
int Find(int x) { return x == f[x] ? x : (f[x] = Find(f[x])); }
int Kruskal() {
	int cnt = 0, ans = 0;
	for(auto x : e) {
		if(cnt == n - 1) return ans;
		int u = Find(x.u), v = Find(x.v), w = x.w;
		if(u != v) {
			if(sz[u] > sz[v]) u ^= v, v ^= u, u ^= v;
			f[u] = v, sz[v] += sz[u], cnt++, ans += w;
		}
	}
	return ans;
}
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) { scanf("%d", &a[i]); mx = max(mx, a[i]); }
	sort(a + 1, a + n + 1); n = unique(a + 1, a + n + 1) - a - 1;
	for(int i = 1; i <= n; i++) sz[i] = 1, f[i] = i;
	for(int i = 1; i < n; i++) {
		for(int k = 1; k * a[i] <= mx; k++) {
			int j = lower_bound(a + i + 1, a + n + 1, k * a[i]) - a;
			if(j <= n && a[j] < (k + 1) * a[i]) e.push_back({i, j, a[j] % a[i]});
		}
	}
	sort(e.begin(), e.end(), cmp);
	printf("%d\n", Kruskal());
	return 0;
}
```

---

## 作者：xkcdjerry (赞：0)

本题的主要考察点：
* 最小生成树
* 数论
* 二分

首先看到本题中“连接所有卡片”可以直接想到最小生成树，但是由于任意两个点之间均有代价（即为完全图）而且 $n$ 的范围开到了 $10^5$ 故 $O(n^2)$ 连边显然会超时，考虑只连有效边。  

首先做一个小优化：所有权值相同的点显然可以都以代价 $0$ 互相连接，那么只保留一个对代价不会做出任何改变。后文中“点 $v$”的称呼皆指权值为 $v$ 的点。

先给出只连有效边的结论：对于点 $v$，先给权值最小且在 $(v,2v)$ 中的点，然后对于所有 $[kv,(k+1)v)$ $(d \geqslant 2)$ 中给范围中权值最小的一个连边。 

使用 ~~数学瞎蒙法~~ 数学归纳法的证明：  

首先类比一下本题暴力连边只往比自己权值更大的连双向边而比自己小的不管，但是由于比自己小的也会给比它权值大的点（其中包括这个点）连边，所以不会错误。  

类似的，这种方法只需要考虑连比自己权值大连边的正确性即可证明。  
（这里定义“正确”为经过自己所连的边中转后的长度等于直接连的长度）  
显然，对于权值最大的点该方法成立。（不需要连任何边）  

而对于任意点 $v$，若所有权值 $>v$ 的点均成立。那么对于任意上述范围，假如连了点 $b$ 而未连点 $c$（$c$ > $b$）。此处令权值为 $i,j$ 的两点之间的代价为 $w_{i,j}$，则显然有：  
$$w_{b,c} = c \mod b$$
从定义可知 $c-b<a<b$，则：
$$w_{b,c} = c-b$$
又由定义可知：
$$w_{a,b} = b \mod a = b-ka$$
$$w_{a,c} = c \mod a = c-ka$$
所以：
$$w_{a,b}+w_{b,c} = (b-ka)+(c-b) = c-ka = w_{a,c}$$
故证。

但是，假如对每一个点 $v$ 的所有范围扫一遍仍然是 $O(n^2)$ 的复杂度，题目中的 $n \leqslant 10^5$ 提示 $O(n \log n)$ 左右的算法，所以可以想到对于每一个区间二分答案。  

大概分析一下复杂度：由调和级数可知区间数量是在 $n \log n$ 级别的（由于权值不连续不会刚好是 $n \ln n$），而每次二分的复杂度是 $\log n$ 级别的，所以最后算法复杂度是 $O(n \log^2 n)$，开 O2 才可以卡过去。

奉上蒟蒻的代码：（由于是稀疏图所以选用克鲁斯卡尔算法）
```c++
#include <cstdio>
#include <algorithm>
using std::sort;
#define N 100010
#define P 10000010
bool vis[P];
int a[N];
int fa[N];
int size[N];
int n;
struct edge
{
	int from,to;
	int w;
	bool operator<(edge b) const
	{
		return w<b.w;
	}
}e[N*500];//建议数组开大一点要不然会莫名RE
void read()
{
	int t;
	scanf("%d",&t);
	for(int i=0;i<t;i++)
		scanf("%d",a+i);
	sort(a,a+t);
	n=std::unique(a,a+t)-a;
}
int find(int a)
{
	return fa[a]==a?a:fa[a]=find(fa[a]);
}
bool merge(int a,int b)
{
	//按秩合并+路径压缩可以做到几乎均摊O(1)
	a=find(a),b=find(b);
	if(a!=b)
	{
		if(size[a]>size[b]) std::swap(a,b);
		size[b]+=size[a];
		fa[a]=b;
	}
	return a!=b;
}
void work()
{
	int mx=-1;
	for(int i=0;i<n;i++)
		if(a[i]>mx) mx=a[i];
	int m=0;
	for(int i=0;i<n;i++)
	{
    	//缓存左端点加速二分
		int *bound=a+i;
		for(int j=a[i];j<=mx;j+=a[i])
		{
			int l=j==a[i]?j+1:j;
			int r=j+a[i];
			int p=(bound=std::lower_bound(bound,a+n,l))-a;
			if(p==n) //注意lower_bound找不到会返回last（此处为a+n)
				break;
			else
				e[m++]=edge{i,p,a[p]%a[i]};
			if(a[p]>r) //处理了后面区间的，跳过防止重复加边
			    j=a[p]/a[i]*a[i];
		}
	}
	sort(e,e+m);
	for(int i=0;i<n;i++)
	{
		fa[i]=i;
		size[i]=1;
	}
	int ans=0;
	int chunk=n-1;
	for(int i=0;chunk&&i<m;i++)
		if(merge(e[i].from,e[i].to))
		{
			ans+=e[i].w;
			chunk--;
		}
	printf("%d",ans);
}
int main()
{
	read();
	work();
}
```
[AC 记录](https://www.luogu.com.cn/record/57057156)

---

## 作者：Sya_Resory (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7789)

题意：给定 $n$ 个整数 $P_i$，在一个有 $n$ 个点的完全图中，边 $(a,b)$ 的权值为 $\min(P_a\bmod P_b,P_b\bmod P_a)$，求出这个图最小生成树的边权之和。

首先是一个明显的性质：当 $P_a>P_b$ 时，$\min(P_a\bmod P_b,P_b\bmod P_a)=P_a\bmod P_b$。证明略。

注意到当 $P_a=P_b$ 时，连接 $a,b$ 两点的代价为 $0$，因此可以假设 $P_i$ 互不相同。

考虑通过每条边中 $P$ 值较小的点推出最小生成树中可能与其相连的点。假设当前考虑到第 $i$ 个点，枚举 $k\in[1,\lfloor\frac{M}{P_i}\rfloor](M=\max\limits_{i=1}^nP_i)$，找出 $P$ 值大于等于 $k\cdot P_i$ 并且与其最接近的点 $j$，将边 $(i,j)$ 加入边集合中。那么最小生成树包含的边一定在这个边集合中。考虑证明。

使用反证法，假设在最小生成树中必定有一条边 $(a,b)$ 不在集合中。那么根据算法，一定存在 $k\cdot P_a\le P_{p_1}\le P_{p_2} \le \dots \le P_{p_c} \le P_b \le (k+1)\cdot P_a$，并且 $(a,p_1),(p_1,p_2),\dotsm,(p_{c-1},p_c),(p_c,b)$ 均在边集合中，此时这些边的边权和为 $P_b-k\cdot P_a=P_b \bmod P_a$。因此 $(a,b)$ 可以被边集合中的边替代，假设不成立。

这样处理的边集合最多有约 $O(n \log n)$ 条边，可以用 kruskal 等算法解决。注意 `sort` 会超时，要用计数排序。

具体细节见代码（人傻常数大，要吸氧）。

```cpp
#include <cstdio>
#include <vector>

const int maxn = 5e6 + 5,maxm = 1e7 + 5;

struct node {
    int u,v;
    node(int _u = 0,int _v = 0): u(_u),v(_v) {}
};
int n,p[maxn],map[maxm],id[maxm],fa[maxm];
/*
 * map[i] 为桶，存储p数组中大于等于i的最小的值
 * id[i] 存储i值在p数组中第一次出现的下标
 */
std::vector < node > edge[maxm]; // edge[w] 存储边集合中所有边权为w的边，这样相当于加边时就能够排序
long long ans;

inline int read() {
#define gc c = getchar()
    int d = 0,f = 0,gc;
    for(;c < 48 || c > 57;gc) f |= (c == '-');
    for(;c > 47 && c < 58;gc) d = (d << 1) + (d << 3) + (c ^ 48);
#undef gc
    return f ? -d : d;
}

int find(int p) { // 并查集
    if(fa[p] == p) return p;
    return fa[p] = find(fa[p]);
}

void kruskal() { // 最小生成树
    for(int i = 1;i <= n;i ++) fa[i] = i;
    for(int i = 0;i <= 1e7;i ++) {
        for(int u,v,j = 0;j < edge[i].size();j ++) {
            u = find(edge[i][j].u),v = find(edge[i][j].v);
            if(u == v) continue;
            fa[u] = v;
            ans += i;
        }
    }
}

int main() {
    n = read();
    for(int i = 1;i <= n;i ++) {
        p[i] = read();
        map[p[i]] = p[i];
        if(!id[p[i]]) id[p[i]] = i;
    } // 读入
    for(int i=1e7;i >= 0;i --)
        if(!map[i]) map[i] = map[i + 1]; // 处理map数组
    for(int i = 1;i <= n;i ++)
        if(id[p[i]] == i) { // 去重，确保每个数只处理一次
            if(map[p[i] + 1] && (p[i] >= 5e6 || map[p[i] * 2] != map[p[i] + 1]))
                edge[map[p[i] + 1] - p[i]].push_back(node(i,id[map[p[i] + 1]])); // 特判k=1，if内的内容也是为了去重
            for(int j = p[i] * 2;j <= 1e7 && map[j];j += p[i]) // 循环枚举 k*Pi
                if(j + p[i] >= 1e7 || map[j] != map[j + p[i]])
                edge[map[j] - j].push_back(node(i,id[map[j]])); // 加边
        }
    kruskal(); // 最小生成树
    printf("%lld\n",ans);
    return 0;
}
```

---


# [COCI 2015/2016 #2] VUDU

## 题目描述

年轻的 Mirko 最近一直在买 Voodoo 娃娃。因为他对最便宜的东西很感兴趣，所以他每天都在追踪 Voodoo 娃娃的价格。他已经得知了最近 $N$ 天的娃娃价格，第 $i$ 天的娃娃价格记为 $a_i$。

Mirko 认为，连续几天的娃娃平均价格与下一天的娃娃价格之间存在某种联系。他想验证自己的观点，却被一个问题难倒了：“对于一个给定的 $P$，在这 $N$ 天内有多少个不同的连续子序列令娃娃的平均价格大于或等于 $P$ ？”

两个连续子序列不同当且仅它们的开始位置或结束位置不同。

## 说明/提示

**【样例 1 解释】**

平均数大于等于 `3` 的子序列只有 `3`。

**【样例 2 解释】**

平均数大于等于 `2` 的子序列有 `5` 个，它们是：

`1 3`

`1 3 2`

`3`

`3 2`

`2`

**【数据范围】**

对于 $30\%$ 的数据，$1\le N\le 10^4$；

对于 $100\%$ 的数据，$1\le N\le 10^6，1\le a_i\le 10^9，1\le P\le 10^9$。

**【说明】**

**本题数据点得分依原题，满分 140**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T5 VUDU**。

## 样例 #1

### 输入

```
3
1 2 3
3```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 3 2
2```

### 输出

```
5```

## 样例 #3

### 输入

```
3
1 3 2
3```

### 输出

```
1```

# 题解

## 作者：pure__Elysia (赞：15)

[题目链接](https://www.luogu.com.cn/problem/P7868)

[通过记录](https://www.luogu.com.cn/record/90300934)

# 前言

&emsp;&emsp;个人认为这个方法比上面几位都要拉一点，但是很好想，也很好懂。因为我比较拉，为了求清晰一点，所以不管是题解还是代码都写的比较长，望 dalao 见谅。

# 题目描述

&emsp;&emsp;给你一个长度为 $n$ 的正整数列，请你求出那些平均数大于等于给定值 $p$ 的连续子序列个数。

# 算法思路

&emsp;&emsp;该题一看好像很简单，再想想好像有点难，但仔细一想也不难。

&emsp;&emsp;首先很容易想到一个常用的事情，我们把每个数都减去 $p$ ，那么那些负数都相当于“拉低平均分”的，正数就是“拉高平均分”的。

&emsp;&emsp;此时，我们记录一个前缀和，比如 $sum[i]$ 表示从 $1$ 到 $i$ 的和。如果是负数，那就是从 $1$ 开始，这一段平均数低了，否则就是符合条件的。

&emsp;&emsp;那么问题来了，怎么处理那些不是以 $1$ 开头的那些连续子序列呢？我们意识到，如果前面有一个前缀和，到后面某一个前缀和，相对的上升了（本体也可以相对不变），就说明这俩中间夹的那些数是正的（也可以是 $0$），也就是说是“平均分合格”的。这就是一种合法的子序列。

&emsp;&emsp;那么我们怎么去统计这些“相对上升”呢？很明显，这就是求顺序对的个数。

```
if(你知道顺序对怎么求)
	goto 细节处理
if(你不清楚顺序对是什么，该怎么求)
	goto 求顺序对
```

## 求顺序对

&emsp;&emsp;顺序对，就是说一个一个列表中两个数满足 $a[i]>a[j]$ 且 $i<j$ 。那么这两个数就是一组“顺序对”。本体因为可以等于 $p$，故两个数可以相等。也许不应该叫顺序对而叫非逆序对吧。

&emsp;&emsp;顺序对主要有归并排序和树状数组两个求法，我蒟蒻，只写得来树状数组，这里讲一下下：

>&emsp;&emsp;首先开一个值域树状数组。由于本题原数组值域在 $-1e9$ 与 $1e9$ 间，但至多 $1e6$ 个数，所以需要进行离散化。
>
>&emsp;&emsp;按照顺序，在离散化后数组一个数加入前，检测现在的树状数组内小于（本题可以等于）这个值的数有多少个（简单的树状数组区间查询）。那么顺序对的数量就加上这个“个数”。
>
>&emsp;&emsp;因为这些数都是你进来前进来的，而且又比你小，所以有几个数，你就多带来了几个顺序对。
>
>&emsp;&emsp;查询后，你便可以将这个数加进树状数组（简单的树状数组单点修改）。然后就可以开始下一个数的操作了

&emsp;&emsp;这就是求顺序对，简单吧。

# 细节处理

&emsp;&emsp;如果你刚才就去打了码，会发现过不了样例。问题是出在哪里呢？是这样的。我们求的都是“顺序对”，但是没有去考虑人家一来就是正的，不需要降这种情况。那我们其实也很简单，就是在原序列的第 $0$ 位加上一个 $0$ ，这样相当于加了一个为 $0$ 的初始状态，可以把那些以来就是正的那些数处理进去了。

# 代码实现
```cpp
#pragma GCC optimize(2)//防抄又加速，岂不美哉
#include<bits/stdc++.h>
using namespace std;

#define int long long//记前缀和很有可能就炸了，所以要防祖宗
#define ri register int//卡常小习惯

int a[1000050];//原数列&-p后的数列
struct cma{
	int w,id;
}sum[1000050];//前缀和（处理前）

int lsh[1000050],tim;//离散化后的前缀和

int s[1000050];//树状数组

int n,p,ans;

inline int rd()//快读宝，一款真正智能的语音音箱
{
	int a=0,f=1;
	char c=getchar();
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for(;c>='0'&&c<='9';c=getchar()) a=(a<<1)+(a<<3)+c-'0';
	return a*f;
}

bool cmp(cma a,cma b)//离散化前肯定要排序啊
{
	if(a.w==b.w) return a.id<b.id;
	else return a.w<b.w;
}

inline void ls()//进行离散化
{
	int tot=sum[0].w-1;//因为多开了一个0进去，所以从0开始
	for(ri i=0;i<=n;i++)
	{
		if(sum[i].w!=tot) tot=sum[i].w,tim++;
		lsh[sum[i].id]=tim;
	}
	return ;
}

inline int lowbit(int x)
{
	return x&(-x);
}

inline int ask(int x)//简单区间查询
{
	int res=0;
	while(x>=1)
	{
		res+=s[x];
		x-=lowbit(x);
	}
	return res;
}

inline void addwhole(int x)//简单单点修改
{
	while(x<=tim)
	{
		s[x]++;
		x+=lowbit(x);
	}
}

signed main()
{
	n=rd();
	
	sum[0].id=0,sum[0].w=0;
	for(ri i=1;i<=n;i++)
		a[i]=rd(),sum[i].w=sum[i-1].w+a[i],sum[i].id=i;
		
	p=rd();
	
	for(ri i=1;i<=n;i++)
		sum[i].w-=p*i;//全部减去p
		
	sort(sum,sum+n+1,cmp);//离散化前的排序
	
	ls();//离散化
	
	for(ri i=0;i<=n;i++)
	{
		ans+=ask(lsh[i]);//先统计
		addwhole(lsh[i]);//再加入
	}
	
	printf("%lld\n",ans);
	
	return 0;
	
}
```

---

## 作者：_Freedom_ (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P7868)

首先设前缀和数组为 $s$，对于一个区间 $[l,r]$，它的平均数大于等于 $p$ 可表示为

$$\frac{s_r-s_{l-1}}{r-l+1} \ge p $$

变形为，

$$s_r-s_{l-1} \ge pr-p(l-1) $$

$$s_r-pr \ge s_{l-1}-p(l-1) $$

其中 $l-1 < r$。

所以我们先把每个 $s_i-p * i $ 离散化，其中 $0\le i \le n$，然后使用树状数组对于每个 $r$ 求出满足条件的 $l$ 的数量。

时间复杂度 $O(n \log n)$。

```cpp
# include <iostream>
# include <cstdio>
# include <algorithm>

# define ll long long

using namespace std;

const int N=1000010;

ll s[N],t[N],tot;

ll c[N];

ll lowbit(ll x) {
	return x&(-x);
}

void upd(ll x,ll y) {
	while(x<=tot) {
		c[x]+=y;
		x+=lowbit(x);
	}
}

ll qry(ll x) {
	ll ans=0;
	while(x) {
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}

int main() {

	ll n,p,x,ans=0;

	scanf("%lld",&n);

	for(ll i=1; i<=n; i++) {
		scanf("%lld",&x);
		s[i]=s[i-1]+x;
	}

	scanf("%lld",&p);

	for(ll i=0; i<=n; i++) t[++tot]=s[i]-p*i;

	sort(t+1,t+1+tot);
	tot=unique(t+1,t+1+tot)-t-1;

	for(ll i=0; i<=n; i++) {
		ll id=lower_bound(t+1,t+1+tot,s[i]-p*i)-t;
		ans+=qry(id);
		upd(id,1);
	}

	printf("%lld\n",ans);

	return 0;
}
```


---

## 作者：_22222222_ (赞：3)

### 题面

[link](https://www.luogu.com.cn/problem/P7868)

### solution

众所周知：正解就是暴力 + 优化。

于是我们考虑先推个暴力然后一步一步优化它。

#### 算法1

首先有一个最暴力的思路：

枚举每一个右端点 $i$ 和左端点 $j$，

考虑这一段的平均数是否大于 $p$，

如果是，那么答案就加 $1$，否则，什么都不干。

于是这样时间复杂度 $O(n^3)$，期望得分 $0\space pts$。

#### 算法2

但是这不能体现一个 ```OIer``` 的基本素养，考虑优化上述算法，

首先不能单次 $O(n)$ 查询区间和，

我们发现没有修改操作，于是可以直接维护前缀和数组。

记这个前缀和数组为 $sum$，记 $[1,i]$ 的前缀和为 $sum_i$。

显然的，区间 $[j+1,i]$ 的和就可以表示为 $sum_i-sum_j$。

求区间平均数就可以写成 $\frac{sum_i-sum_j}{i-j}$。

**（ 注意这里枚举的区间是 $[j+1,i]$！）**

于是我们的判断条件就可以写成 $[\frac{sum_i-sum_j}{i-j} > p]$。

( 这里的中括号内表达式实际上是一个 ```bool``` 变量，学名叫艾佛森括号。 )

于是可以写一个状态转移方程，

记 $f_i$ 表示考虑以 $i$ 为右端点时的合法方案总数。

于是有：

$f_i=\sum\limits_ {j=0}^{i-1}[\frac{sum_i-sum_j}{i-j} > p],$

答案 $ans=\sum\limits^{n}_ {i=1}f_i$。

上述算法时间复杂度 $O(n^2),$可以通过 $30\%$ 的数据，期望得分 $42\space pts$。

#### 算法3

上述做法不能体现一个熟练 ```OIer``` 的素养，考虑继续优化。

首先我们把 $\frac{sum_i-sum_j}{i-j} > p$ 化整，有

${sum_i-sum_j} > (i-j)\cdot p$

事实上这一步没有根本优化，因为仍然要枚举两个点，

考虑移项，有：

$sum_i-i\cdot p > sum_j -j\cdot p$

看上去没有什么？

事实上这就是经典的偏序问题，考虑离散化并使用树状数组维护即可。

对于每个位置 $i$，记 $cnt_i=sum_i -i\cdot p$ 并完成离散化。

上述式子就是 $cnt_i>cnt_j,j<i$。

按照从 $1$ 到 $n$ 的顺序枚举 $i$，

在树状数组查询所有满足条件的 $j$，

就是在每个 $cnt_i$ 的位置查询 $cnt_i$ 的前缀和，

在每次查询完以后，在 $cnt_i$ 的位置加 $1$。

对于一个 $i$ 来说，

所有小于 $i$ 的点均在树状数组里，

而所有大于 $i$ 的点均不在其中，

查询的时候，只查询 $cnt_i>cnt_j$ 的这一部分，保证不重不漏。

时间复杂度$O(n\log n),$可以通过 $100\%$ 的数据，期望得分 $140\space pts$

#### 注意事项

$1.$ 开 ```long long ```！

$2.$ 开够数组！

$3.$ 上面说的东西没判 $j=0$ 记得判上这种情况！

$4.$ 如果写的不是离散化而是我这种结构体排序求排名，

记得要把下标当第二关键字排序，不然会少算！

### Code

代码比较压行，请见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
const int o=2222222;
int n,a[o],ans,f[o],p;
struct node{
    int id,rk;
}b[o];
struct BIT{
    int t[o];
    int lb(int x){return x&(-x);}
    void add(int x,int val){while(x<=n){t[x]+=val,x+=lb(x);}}
    int ques(int x){int ans=0;while(x){ans+=t[x],x-=lb(x);}return ans;}
}T;
bool cmp2(node x,node y){return a[x.id]!=a[y.id]?a[x.id]<a[y.id]:x.id<y.id;}
bool cmp1(node x,node y){return x.id<y.id;}
int read(){
    int i=1,j=0;char ch=getchar();
    while(ch>'9'||ch<'0')i=(ch=='-'?-1:1),ch=getchar();
    while(ch>='0'&&ch<='9')j=j*10+ch-48,ch=getchar();
    return i*j;
}
void in(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    p=read();
}
void pre(){
    for(int i=1;i<=n;i++)a[i]+=a[i-1];
    for(int i=1;i<=n;i++)a[i]-=i*p;
    for(int i=1;i<=n;i++)b[i].id=i;
    sort(b+1,b+n+1,cmp2);
    for(int i=1;i<=n;i++)b[i].rk=i;
    sort(b+1,b+n+1,cmp1);
}
void work(){
    for(int i=1;i<=n;i++){
        f[i]=T.ques(b[i].rk);
        T.add(b[i].rk,1);
    }
    for(int i=1;i<=n;i++)ans+=f[i]+(a[i]>=0);
}
void out(){cout<<ans<<endl;}
#undef int 
int main(){
    in();pre();work();out();
    return 0;
}
```
### 扯点闲篇

这个题还是比较套路，想出来 $O(n^2)$ 接下来转换偏序也很平凡。

稍微注意下就可以过，然后就没有然后了。

事实上难度真不是很大，~~估计也就是校内模拟赛场切水平~~。

给[cjh的博客](https://www.cnblogs.com/kiritokazuto)打一波广告

---

## 作者：unputdownable (赞：3)

首先看到数据范围 $10^6$ 肯定是 $O(n)$ 或者一只老哥。

考虑把所有数减去 $P$，那么原问题就变成有多少**和不小于 $0$ 的子序列**。

容易想到前缀和，那么相当于求不逆序对数量。

于是用树状数组求解即可。

注意判断从 $1$ 开始的子串，相当于从 $sum_i-sum_0$ 其中 $sum$ 表示前缀和。

特判或者加入一个 $0$ 皆可。

--------

**Code :**

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read(void) {
	register int x=0,sgn=1,ch=getchar();
	while(ch<48||57<ch) {if(ch==45)sgn=0;ch=getchar();}
	while(47<ch&&ch<58) {x=x*10+ch-48;   ch=getchar();}
	return sgn? x:-x;
}
void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
#define lowbit(x) (x&(-x))
int n,P,Ans;
int c[1000006],rnk[1000006],pre[1000006];
inline void add(int x) {
    while(x<=n) {
        ++c[x];
        x+=lowbit(x);
    }
}
inline int qry(int x) {
    int v=0;
    while(x>0) {
        v+=c[x];
        x-=lowbit(x);
    }
    return v;
}
signed main() {
    n=read();
    for(register int i=1; i<=n; ++i) pre[i]=read();
    P=read();
    for(register int i=1; i<=n; ++i) pre[i]-=P;
    for(register int i=1; i<=n; ++i) rnk[i]=(pre[i]+=pre[i-1]);
    sort(rnk,rnk+n+1); unique(rnk,rnk+n+1);
    for(register int i=0; i<=n; ++i) pre[i]=lower_bound(rnk,rnk+n+1,pre[i])-rnk+1; ++n;
    for(register int i=0; i< n; ++i) {
        Ans+=qry(pre[i]); add(pre[i]);
    }
    write(Ans); puts("");
	return 0;
}
```


---

## 作者：喵仔牛奶 (赞：2)

## $\mathcal{Solution}$

题意：求有多少 $(l,r)$ 使得 $\dfrac{\sum_{i=l}^{r}a_i}{r-l+1}\geq P$。

考虑化简式子：

先把每个 $a_i$ 减去 $P$，令 $b_i=a_i-P$：

$$\dfrac{\sum_{i=l}^{r}b_i}{r-l+1}=\dfrac{\sum_{i=l}^{r}a_i}{r-l+1}-P$$

原式等价于：

$$\dfrac{\sum_{i=l}^{r}b_i}{r-l+1}\geq 0$$

令 $sum_i=\sum_{j=1}^{i}b_j$，显然 $\sum_{i=l}^{r}b_i=sum_r-sum_{l-1}$。

$$\dfrac{sum_r-sum_{l-1}}{r-l+1}\geq 0$$

因为 $r-l+1$ 非负，所以可以去掉：

$$sum_r-sum_{l-1}\geq 0$$
$$sum_r\geq sum_{l-1}$$

树状数组求顺序对即可

## $\mathcal{Code}$

树状数组，[4.76s](https://www.luogu.com.cn/record/100183023)。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
long long n, k, ans, cnt, t[N], a[N], sum[N];
struct tree {
    int c[N];
    int lowbit(int x) { return x & (-x); }
    void upd(int x, int val) { for (; x <= cnt; x += lowbit(x)) c[x] += val; }
    int query(int x) { int res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res; }
} bit;
int main() {
	cin >> n, t[++ cnt] = 0;
	for (int i = 1; i <= n; i ++) cin >> a[i];
	cin >> k;
	for (int i = 1; i <= n; i ++)
	    a[i] -= k, sum[i] = sum[i - 1] + a[i], t[++ cnt] = sum[i];
	sort(t + 1, t + 1 + cnt), cnt = unique(t + 1, t + 1 + cnt) - t - 1;
	for (int i = 1; i <= n; i ++)
		sum[i] = lower_bound(t + 1, t + 1 + cnt, sum[i]) - t;
	bit.upd(lower_bound(t + 1, t + 1 + cnt, 0) - t, 1);
	for (int i = 1; i <= n; i ++)
		ans += bit.query(sum[i]), bit.upd(sum[i], 1);
	cout << ans << '\n';
	return 0;
}

```


---

## 作者：Hanggoash (赞：2)

# P7868 VUDU 题解

提供一种不需要使用离散化，从 $0/1$ 分数规划的角度推导的思路。

## 分析

题意很清楚了，就是求给出的序列中，对于一段任意长度的连续区间，其元素和的平均数大于等于 $p$ 的种数，可以用如下式子来表达：
$$
\frac{\sum_{i=l}^{r}a[i]}{r-l+1}\ge p
$$

### 推导方法1

当时写出来这个式子，我一眼 $0/1$ 分数规划，也就是:
$$
\frac{\sum_{i=l}^{r}a[i]\times x[i]}{\sum_{i=l}^{r}b[i]\times x[i]}\ge mid
$$

但是这道题只能选连续的一段，所以 $x[i]$ 就不存在了。

当然如果你不知道 $0/1$ 分数规划，也完全没有关系，往下看就是了。

我们把初始式子里面的 $r-l+1$ 想办法变成第二个式子里面的 $b[i]$ ，通过对比很容易发现，我们假设所有的 $b[i]=1$ ，那么就有：
$$
\frac{\sum_{i=l}^{r}a[i]}{r-l+1}\ge p \iff \frac{\sum_{i=l}^{r}a[i]}{\sum_{i=l}^{r}b[i]}\ge p\iff {\sum_{i=l}^{r}a[i]}-p\times {\sum_{i=l}^{r}b[i]}\ge 0\iff \sum_{i=l}^{r}{(a[i]-p\times b[i])}\ge 0
$$
不要忘了其中 $b[i]=1$ ，于是上面的式子就最终变成了 :
$$\sum_{i=l}^{r}{(a[i]-p)}\ge 0$$

其中 $a[i],p$ 都是定值，于是我们记 $v[i]=a[i]-p$ ，最终我们就把题意变成了从 $v[i]$ 中，选出子段和大于等于 $0$ 的方案数。

### 推导方法2

如果您认为上面太麻烦了，那么下面的应该更容易理解了，先回到原来的式子：
$$
\frac{\sum_{i=l}^{r}a[i]}{r-l+1}\ge p
$$
同样的化化简，移移项:
$$
\frac{\sum_{i=l}^{r}a[i]}{r-l+1}\ge p \iff\sum_{i=l}^{r}a[i]-(r-l+1)\times p\ge 0
$$
如何感性理解上式？

注意到有 $r-l+1$ 个 $a[i]$ 在求和，还要减去 $r-l+1$ 个 $p$ ，即判断 $k$ 个数减去 $k$ 个 $p$ 之后的值，是否非负。

那么我们把每个 $p$ 均摊到每一个 $a[i]$ 上面，就有了我们用第一种方法推导出的最终式子了。

### 引入前缀和

既然都已经涉及到了区间和，我们自然地想到了前缀和，即用 $sum[r]-sum[l-1]$ 快速求和。

我们发现对于每一个 $1\le l\le r\le n$ ，只要满足 $sum[r]-sum[l-1]\ge 0$ ，即 $[l,r]$ 中元素和大于等于 $0$，就一定能对答案产生 $1$ 的贡献。

### 顺序对、逆序对

手玩几组样例就会发现，我们求的其实就是其中顺序对的数量，特别地对于  $l=1$ 的情况， $sum[l-1]=sum[0]=0$ 我们也是需要考虑的，它的实际意义就是 $[1,r]$ 的区间和。

最后，可以直接求顺序对，也可以倒着求逆序对，但都要注意取等条件。

### 小细节

注意要开 long long。


## Code

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
template <typename T>inline void re(T &x) 
{
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-f;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);
	x*=f;
}
const int maxn=1e6+100;
int n,a[maxn],sum[maxn],p,rec[maxn],ans[maxn];
long long answer;
void merge(int l,int r)
{
	if(l==r)return;
	int mid=(l+r)>>1;
	int i=l,j=mid+1,cnt=l-1;
	merge(l,mid);merge(mid+1,r);
	while(i<=mid&&j<=r)
	{
		if(rec[i]<rec[j])ans[++cnt]=rec[i++];//这个地方一定是<不能是<=
		else ans[++cnt]=rec[j++],answer+=mid-i+1;
	}
	while(i<=mid)
		ans[++cnt]=rec[i++];
	while(j<=r)
		ans[++cnt]=rec[j++];
	for(int i=l;i<=r;i++)rec[i]=ans[i];
}
signed main()
{
	re(n);
	for(register int i=1;i<=n;++i)re(a[i]);
	re(p);
	for(register int i=1;i<=n;++i)a[i]-=p,sum[i]=sum[i-1]+a[i],rec[n-i+1]=sum[i];
	rec[n+1]=sum[0];
	merge(1,n+1);
	printf("%lld",answer);
	return 0;
}
/*
8
3 2 1 7 4 5 6 3
4

22
*/
```



---

## 作者：Arghariza (赞：2)

整点不一样的东西。

- $\mathtt{Solution\ 1}$

简单来说，`CDQ` 分治。

给每个数都减上一个 $p$ ，即求 $\sum\limits_{1\le i\le j\le n}[\sum\limits_{k=i}^{j}a_k\ge 0]$ 。

考虑 `CDQ` 分治的话，我们把 $[l,r]$ 分成 $[l,mid],[mid+1,r]$ 两个部分，分别递归，再计算 $i\in[l,mid],j\in[mid+1,r]$ 的贡献。

既然是取连续子序列，不妨将 $a$ 序列从 $l$ 到 $mid$ 做一个后缀和，从 $mid+1$ 到 $r$ 做一个前缀和，从两边的前缀和和后缀和中分别取一个相加，就保证了你取的序列是连续的。

考虑两边分别从小到大排序，排序后对于 $l$ 到 $mid$ 位置的后缀和为 $suf_i$， $mid+1$ 到 $r$ 位置的前缀和为 $pre_i$，就有一个 `two pointers` 的思路：一开始令 $l'=l,r'=r$ ，显然在 $l'$ 从 $l$ 往 $mid$ 移动的时候 $suf_{l'}$ 递增，那么满足 $suf_{l'}+pre_{r'}\ge0$ 的 $r'$ 就会递减，直到 $r'=mid+1$ 为止。

不难发现这样做的复杂度是 $T(n)=2T(\frac{n}{2})+n\log n=O(n\log^2 n)$ 的。吸氧之后能过，但是考虑毒瘤出题人可能会加强数据，所以我们想怎么优化。

注意到开头这个式子：

$$\sum\limits_{1\le i\le j\le n}[\sum\limits_{k=i}^{j}a_k\ge 0]$$

做一个前缀和：

$$\sum\limits_{1\le i\le j\le n}[s_{i-1}\le s_{j}],s_i=\sum\limits_{k=1}^{i}a_k$$

然后这是个类似逆序对的结构，采用类似归并排序的思想：放两个指针上去依次判断大小，把小的那个塞进去新的数组 $t$ ，最后把 $t$ 复制到 $a$ ，并且在移动指针的时候统计答案。

至此，我们得到了一个很**香**的 $O(n\log n)$ 算法，跑起来飞快，直接卡进最优解前三。

实测：

![无标题.png](https://i.loli.net/2021/11/18/EkZf8q35N74dTBu.png)

下面是 $O(n\log^2 n)$ 做法，上面 $O(n\log n)$ 。

```cpp
// nlog^2n做法（记得吸氧！！11）
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e6 + 100;
int n, k, s[maxn], t[maxn];

int cdq(int l, int r) {
	if (l == r) return s[l] >= 0;
	int mid = (l + r) >> 1, res = cdq(l, mid) + cdq(mid + 1, r);
	t[mid] = s[mid], t[mid + 1] = s[mid + 1];
	for (int i = mid - 1; i >= l; i--) t[i] = s[i] + t[i + 1];
	for (int i = mid + 2; i <= r; i++) t[i] = s[i] + t[i - 1];
	stable_sort(t + l, t + mid + 1), stable_sort(t + mid + 1, t + r + 1);
	int p = l, q = r;
	while (p <= mid) {
		while (q > mid && t[p] + t[q] >= 0) q--;
		res += r - q;
		p++;
	}
	return res;
}

signed main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &s[i]);
	scanf("%lld", &k);
	for (int i = 1; i <= n; i++) s[i] -= k;
	printf("%lld", cdq(1, n));
	return 0;
}
```

```cpp
// nlogn做法
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e6 + 100;
int n, k, s[maxn], t[maxn];

int cdq(int l, int r) {
	if (l == r) return s[l] >= 0;
	int mid = (l + r) >> 1, res = cdq(l, mid) + cdq(mid + 1, r);
	int p = l, q = mid + 1, tp = 0;
	for (int i = l; i <= r; i++) {
		if (q > r || (p <= mid && s[p] <= s[q])) tp++, t[i] = s[p++];
		else res += tp, t[i] = s[q++];
	}
	for (int i = l; i <= r; i++) s[i] = t[i];
	return res;
}

signed main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &s[i]);
	scanf("%lld", &k);
	for (int i = 1; i <= n; i++) s[i] = s[i] - k + s[i - 1];
	printf("%lld", cdq(1, n));
	return 0;
}
```

- $\mathtt{Solution\ 2}$

上面提到有一个类似逆序对的结构，可以用树状数组 $O(n\log n)$ 解决。

或者我觉得树状数组太**麻烦**了呢？

平衡树！

构建一颗维护前缀和的平衡树，每次输入数的时候查询排名，然后把这个数插进去即可。

优点是在线，缺点是常数好像有点大。

或者说权值线段树也行。

---

## 作者：happybob (赞：2)

你打开了[这道题](https://www.luogu.com.cn/problem/P7868)。

你开始学习 OI，你写出了 $O(n^2)$ 做法，枚举 $l$ 和 $r$，然后前缀和优化。

你上了小学，开始学习转化这题。你考虑对于 $1 \leq i \leq n
$，$a_i \leftarrow a_i -p$。然后题目即求区间平均数大于等于 $0$ 的序列。

你上了中学，继续思考这题。你发现 $a_i$ 转化后可以继续前缀和优化。设 $sum_i = \sum \limits_{j=1}^i a_j$，即求有多少区间 $[l, r]$ 满足 $\dfrac{sum_r - sum_{l-1}}{r-l+1}\geq0$。

你上了大学，你发现了一个性质，即若 $sum_r - sum_{l-1} \geq 0$，那么 $\dfrac{sum_r - sum_{l-1}}{r-l+1}\geq0$，由于 $r-l+1>0$。问题转化为求有多少区间 $[l, r]$ 满足 $sum_r - sum_{l-1}\geq0$。

你读了博士，继续考虑这题。你发现 $sum_r - sum_{l-1} \geq 0$ 等同于 $sum_r \geq sum_{l-1}$。

然后这题就结束了，线段树或树状数组等维护逆序对即可。

---

## 作者：hgzxwzf (赞：1)

## 解题思路
首先可以把所有的 $a_i$ 减去 $P$，这样的话原本求有多少个区间平均数大于 $P$ 就变成了求有多少个区间的平均数大于等于  $0$，即求有多少个区间的和大于等于  $0$。

假设 $sum[i]=\sum_{i=1}^Ra_i$，那么有 $\sum_{i=L}^R=sum[R]-sum[L-1]$，那么现在就要求有多少个数对 $(L,R)$ 满足 $sum[R]-sum[L]$ 且 $L<R$。

就像等于对 $sum$ 求正序对，可以利用树状数组解决。

因为题目中 $a_i$ 和 $P$ 值域很大，但 $n\le10^6$，可以对 $sum$ 离散化，每次向树状数组插入 $sum$ 的排名，查询时也变为查询排名小于等于 $sum$ 的数的个数。

上面我们只处理的了 $L>=1$ 的情况，所以 $L=0$ 的情况还要特判，即存在 $pos$ 满足 $\sum_{i=1}^{pos}\ge0$ 的情况。

对于每个位置 $pos$，我们还需要判断 $sum$ 是否大于 $0$，如果是，答案 $+1$。

## 代码：
```cpp
#include<cstdio>
#include<algorithm>
#define rep(x,y,z) for(int x=y;x<=z;x++)
using namespace std;
const int N=1e6+10;
int t[N],tot;
long long sum[N],lis[N];//记得开 long long
void add(int i) {while(i<=tot) t[i]++,i+=i&-i;}
int query(int i) {int ans=0;while(i) ans+=t[i],i-=i&-i;return ans;}
int main()
{
	int n,k;
	scanf("%d",&n);
	rep(i,1,n) scanf("%d",&sum[i]);
	scanf("%d",&k);
	rep(i,1,n) sum[i]-=k,sum[i]=lis[i]=sum[i-1]+sum[i];//前缀和
	sort(lis+1,lis+1+n);//排序
	tot=unique(lis+1,lis+1+n)-lis-1//去重;
	long long ans=0;
	rep(i,1,n)
	{
		if(sum[i]>=0) ans++;
		int pos=lower_bound(lis+1,lis+1+tot,sum[i])-lis;//二分
		ans+=query(pos);
		add(pos);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yxy666 (赞：1)

设 $s_i$ 表示 $a_1+a_2+a_3+...+a_i$。那么对于 $s_i$，我们想要让

 $s_i-i*p≥0$
 
 $s_i≥i*p$

$a_1+a_2+…+a_i≥i*p$

$(a_1-p)+(a_2-p)+…+(a_i-p)≥0$

设 $A_i=a_i-p$

$S_i=A_1+A_2+…+A_3$
我们想要一段右端点与 i,右端点为 j+1 且大于等于 0 的和，那么就是 $S_i-S_j≥0$。也就是 $S_i≥S_j$。将 S 数组翻转一下以后，就会发现不就是到前面去求一下有几个大于等于 $S_i$ 吗？那么不就是典型的逆序对吗？

注意：这样子无法处理单点，单点需要特判。

code :
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int n;
long long s[maxn],a[maxn],P,ans;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void msort(int L,int R){
	if(L>=R)return;
	int mid=(L+R)/2;
	msort(L,mid);msort(mid+1,R);
	for(int k=L;k<=R;k++)a[k]=s[k];
	int i=L,j=mid+1;
	for(int k=L;k<=R;k++){
		if((i<=mid)&&(a[i]<a[j]||j>R))s[k]=a[i++];
		else s[k]=a[j++],ans+=mid-i+1;
	}
}//归并排序求逆序对
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	P=read();
	for(int j=1;j<=n;j++)s[j]=s[j-1]+a[j]-P,ans+=s[j]>=0;//找前面有几个小于等于我的且为单点
	reverse(s+1,s+1+n);msort(1,n);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：SDNetFriend (赞：1)

## P7868 [COCI2015-2016#2] VUDU 题解

**upd 2021.9.18** 精简了代码

[题目链接](https://www.luogu.com.cn/problem/P7868)

题意不再赘述 QwQ

根据某些初中数学知识，我们知道平均数的计算可以是找一个基准数，把所有的数减去基准数，然后求平均后加上基准数就是最后的平均数。

这么来讲，我们直接把 $P$ 设为基准数，问题就可以转化成求有多少区间总和大于 $0$。

我们可以每次固定右端点来找左端点，但我们发现相邻的两个右端点，右边的那个一部分是左边所有的区间加上右边那个点形成的，那在没有加入右边的右端点之前，相当于我们要给整体加上右端点的值。

那么我们可以设 $z$ 为“零点”，每次整体加的时候偏移一下零点即可。

然后我手写了一个 Splay 就能过掉这题。

### 一个需要注意的小点

~~一个只有我这种蒟蒻才会犯的错误~~

注意这题答案也是 $O(n^2)$ 的，所以如果要合理开 long long 记得给它也开，因为这个 WA 了好久。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=4e6+5;
int n,ch[N][2],tot=0,fa[N],w[N],rt;
lint z=1e16,v[N],p,a[N],ans=0;
inline void calc(int x){
	int ls=ch[x][0],rs=ch[x][1];
	w[x]=w[ls]+w[rs]+1;
}
inline void con(int x,int y,int d){
	if(!y)rt=x;
	else ch[y][d]=x,calc(y);
	if(x)fa[x]=y;
}
inline int dir(int x){return x==ch[fa[x]][1];}
inline void ror(int x){
	int y=fa[x],z=fa[y];
	int dx=dir(x),dy=dir(y),w=ch[x][dx^1];;
	con(x,z,dy);con(w,y,dx);con(y,x,dx^1);
}
inline void splay(int x,int rot){
	while(fa[x]!=rot){
		int y=fa[x],z=fa[y];
		int dx=dir(x),dy=dir(y);
		if(z&&z!=rot)ror((dx==dy)?y:x);
		ror(x);
	}
}
void inst(int x,int y,int d,lint val){
	if(!x){
		x=++tot;v[x]=val;w[x]=1;
		con(x,y,d);splay(x,0);
	}else
		inst(ch[x][d=(val>v[x])],x,d,val);
}
lint sum(int x,int y,lint val){
	if(!x){splay(y,0);return 0;}
	int ls=ch[x][0],rs=ch[x][1];
	if(val>v[x])return sum(rs,x,val);
	else return w[rs]+1+sum(ls,x,val);
}
int main(){
	n=read();
	for(rint i=1;i<=n;++i)
		a[i]=read();
	p=read();
	for(rint i=1;i<=n;++i)
		a[i]-=p;
	for(rint i=1;i<=n;++i){
		z-=a[i];
		inst(rt,0,0,z+a[i]);
		ans+=sum(rt,0,z);
	}
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：geven (赞：0)

# [COCI2015-2016#2] VUDU 题解
## 题意
给一个长度为 $N$ 的整数序列 ${a}$，对于其一共 $\frac{N\times (N+1)}{2}$ 个的非空区间，求有多少个区间的平均数大于等于 $p$。
## 暴力做法
显然，可以直接枚举区间左端点 $j$ 与区间右端点 $i$，检查区间平均值是否大于等于 $p$ 即可，用代码实现即为：

```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=i;j++){
		if(sum[i]-sum[j-1]>=p*(i-j+1)){//乘法避免丢精度
			ans++;
		}
	}
}
```
用前缀和数组 $sum$ 优化，时间复杂度为 $O(n^2)$。显然，对于 $2 \times 10^5$ 的数据，该程序会超时。
## 正解
只要对暴力算法的不等式稍加改变，我们就能得到正解。

对于代码中的不等式，我们可以将不等式转化为：$sum_i - p \times i - p \geq sum_{j-1} - p \times j$。 

再结合 $j \leq i$，就显然可以看出公式可以用树状数组优化。

对于每一个 $i$，我们都将 $sum_{i-1} - p \times i$ 插入进树状数组中，再将树状数组中小于等于 $sum_i - p \times i - p$ 的元素个数查询并累加，就可以得到最终答案。

时间复杂度为 $O(n \log n)$。

__注意__：由于不等式中的左右两项可能很大，所以在操作前需要先对其离散化。
## 代码
```cpp
#include<stdio.h>
#include<algorithm>
typedef long long ll;
const ll N=2e6+5;
int n,cnt;
ll p,sum[N],a[N],b[N],g[N],c[N];
int lowbit(int x){return x&~x+1;}
void add(int x,ll v){while(x<=cnt) c[x]+=v,x+=lowbit(x);}
ll query(int x){
    ll ans=0;
    while(x) ans+=c[x],x-=lowbit(x);
    return ans;
}
int main(){
    scanf("%d",&n);
    ll x;
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);
        sum[i]=sum[i-1]+x;
    }
    scanf("%lld",&p);
    for(int i=1;i<=n;i++){
        a[i]=sum[i]-p-p*i;//不等式左边项
        b[i]=sum[i-1]-p*i;//不等式右边项
        g[++cnt]=a[i],g[++cnt]=b[i];
    }
    std::sort(g+1,g+cnt+1);//离散化排序
    cnt=std::unique(g+1,g+cnt+1)-g-1;//离散化去重 
    ll ans=0;
    for(int i=1;i<=n;i++){
        int x=std::lower_bound(g+1,g+cnt+1,a[i])-g;
        int y=std::lower_bound(g+1,g+cnt+1,b[i])-g;//离散化
        add(y,1);
        ans+=query(x);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Tx_Lcy (赞：0)

[更差的阅读体验](https://www.cnblogs.com/tx-lcy/p/16808797.html)

[题目传送门](https://www.luogu.com.cn/problem/P7868)
## 思路
这是一种简单的树状数组解法。

我们设偏移值表示 $a_i$ 与目标平均数 $p$ 的差值，显然，一个区间若能满足条件，需要满足此区间的偏移值之和 $\ge 0$。

看到区间之和，我们就想到了前缀和，设 $sum$ 数组表示偏移值的前缀和数组，若我们固定一个右端点 $r$，则我们要求的是满足 $sum_r-sum_l \ge 0$ 的 $l$ 总数，不妨改变一下这个柿子的形式，变成 $sum_r \ge sum_l$，然后就变成简单的树状数组板子了。

## 代码
```cpp
//A tree without skin will surely die. 
//A man without face is invincible.
#include<bits/stdc++.h>
using namespace std;
#define int long long
int const N=1e6+10;
int n,a[N],b[N],sum[N];
struct Tree_Array{
    int c[N];
    #define lowbit(x) (x&-x)
    inline void update(int x,int v){while (x<=n) c[x]+=v,x+=lowbit(x);}
    inline int query(int x){int res=0;while (x) res+=c[x],x-=lowbit(x);return res;}
}T;
signed main(){
    //读入
    for (int i=1;i<=n;++i) a[i]-=p;
    for (int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i],b[i]=sum[i];
    sort(b+1,b+n+1);int l=unique(b+1,b+n+1)-b-1;
    int ans=0;
    for (int i=1;i<=n;++i) ans+=(sum[i]>=0);//这个数本身就满足条件
    for (int i=1;i<=n;++i) sum[i]=lower_bound(b+1,b+l+1,sum[i])-b;//离散化
    for (int i=1;i<=n;++i){
        ans+=T.query(sum[i]);
        T.update(sum[i],1);
    }
    //输出
    return 0;
}
```


---

## 作者：isletfall (赞：0)

# 题意
给定一段序列,统计平均数大于等于 $P$ 的子序列的个数。
# 思路
首先我们看到平均数,很容易可以想到把每个数都先减去平均数这样就可以把子序列平均数是否大于 $P$ 的问题转化为子序列是否大于零的问题了,即统计满足 $1 \le l \le r \le n$ 且 $\sum_{i=l}^ra_i \lt  0$ 的 $(l,r)$ 的个数。

因为它是一段连续的序列,那么我们很容易想到用前缀和来维护区间和,即对于 $\sum_{i=l}^ra_i$  ,我们可以表示为 $sum_r-sum_l$  ,于是我们又将问题转化为了统计满足 $1<=l<=r<=n$ 且 $sum_r-sum_l>0$ 的 $(l,r)$ 的个数,整理一下变成 :

$1 \leq l \leq r \leq n$

$sum_r \gt sum_l$

 然后我们惊奇的发现 : 这不就是一个二维偏序问题吗？类似求逆序对的问题,我们就有了很多想法,比如树状数组,归并排序等等。而我这里写的是CDQ分治,这边简单的讲一下CDQ分治的思路:

首先将原序列划分为 $[l,mid]$ $[mid+1,r]$ 两个部分。

然后递归处理两个区间 $[l,mid]$ 和$[mid+1,r]$ 内部的偏序关系并将它们排序。

最后合并区间并统计跨两个区间的偏序关系。

时间复杂度 $O(n \log n)$ 。

细节看代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7;
long long n,p,a[maxn],tmp[maxn],res;
void cdq(long long l,long long r){
	if(l>=r)return;
	long long mid=(l+r)>>1; 
	cdq(l,mid),cdq(mid+1,r);//分别递归左右区间
	long long sum=0;
	for(int i=l,j=mid+1,s=l;s<=r;s++)//处理跨区间的偏序关系
	if(j>r||i<=mid&&a[i]<=a[j])sum++,tmp[s]=a[i++];//这里开一个暂存数组来合并答案
	else res+=sum,tmp[s]=a[j++];
	for(int s=l;s<=r;s++)a[s]=tmp[s];
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]),a[i]+=a[i-1];
	scanf("%lld",&p);
	for(int i=1;i<=n;i++)a[i]-=p*i;
	cdq(0,n);
	printf("%lld",res);
	return 0;
}
```
# 后记
总的来说,CDQ分治跑起来还是非常优秀的,毕竟树状数组的常数是比较大的,但是相比树状数组，CDQ分治小细节还是挺容易会写挂掉的,~~而树状数组应该就没有这样的烦恼~~。

最后我只是把CDQ分治的大致思路讲了一下,如果还有不明白，可以去 [这里](https://oi-wiki.org/misc/cdq-divide/) 再学习一下。

---


# 火烧の云

## 题目描述

乡间小路可以近似理解成 $n\times m$ 的矩阵，道路有许多种，这里只列举其中的一小部分：

1. ``#``：水池，无法通行。
2. ``|``：直行类道路，竖直方向只能直行，水平方向只能左转、右转。
3. ``-``：直行类道路，水平方向只能直行，竖直方向只能左转、右转。
4. ``/``：转弯类道路，竖直方向只能右转，水平方向只能左转。
5. ``\``：转弯类道路，竖直方向只能左转，水平方向只能右转。
6. ``.``：四岔路口，可以直行、左转、右转。
7. ``S``：入口，从乡间之外进入入口不需要时间。
8. ``E``：出口，从出口到达乡间之外不需要时间。

前进类道路：到此格之后方向必须花费时间转向 `?`，如果来向就是 `?` 方向则不花费时间并必须跳一格。

9. ``<``：`? = 西`。
10. ``>``：`? = 东`。
11. ``^``：`? = 北`。
12. `v`：`? = 南`。

**简单来说，就是和这类道路逆向时不能走，垂直于它的方向时花时间转到它的方向，顺着它的方向时就能够不花时间且必须一次性走两格。**


直行类道路、转弯类道路、四岔路口、前进类道路依次花费 $a,b,c,d$ 个单位时间。

由于乡间的构造奇特，可能 **不止一个** 入口和出口。

求任意入口到任意出口的 **最短时间**，出入时的方向不作要求。

---

**题意简述**

给定一张 $n\times m$ 的地图，求起点 `S` 到终点 `E` 的最短时间，注意起点和终点可能有多个。

## 说明/提示

#### 样例说明

样例 #1：从起点 $(1,1)$ 开始，到终点 $(3,3)$ 的路径为：$(1,1)\rightarrow(1,2)\rightarrow(1,3)\rightarrow(2,3)\rightarrow(3,3)$。经过了 $3$ 个四岔路口，每个的代价是 $4$，沿途的代价：$4\times3=12$。

样例 #2：从起点 $(1,1)$ 开始，到终点 $(1,3)$ 的路径为：$(1,1)\rightarrow(2,1)\rightarrow(2,2)\rightarrow(2,3)\rightarrow(1,3)$。经过 $2$ 个转弯类道路和 $1$ 个直行类道路，沿途的代价：$2\times2+1\times1=5$。

样例 #3：选择 $(1,1)$ 的 `S` 和 $(1,2)$ 的 `E`，出入口相邻，代价为 $0$。

样例 #4：通过前进类道路 `>` 可以跳一格直接到达 `E`，跳一格时不花费时间。

样例 #5：前进类道路也可以用于转向，此时的功能与 `/` 相同，转向同样需要时间。

样例 #6：这里 `#` 不能通过，因此不存在 `S` 到 `E` 的道路。

#### 数据范围

| 子任务编号 | 分值 | $n,m\le$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1$ | $10$ | $10$ | $\times$ |
| $2$ | $15$ | $\times$ | $a=b=c=d=1$ |
| $3$ | $20$ | $100$| $\times$ |
| $4$ | $25$ | $\times$ | 字符 `S`、`E` 的数量 $=1$ |
| $5$ | $30$ | $\times$ | $\times$ |

**本题请注意常数因子对程序效率的影响。**

对于 $100\%$ 的数据：$1\le n,m\le2000$，$0\le a,b,c,d\le100$。

## 样例 #1

### 输入

```
3 3 6 5 4 3
S..
...
..E```

### 输出

```
12
```

## 样例 #2

### 输入

```
3 3 1 2 7 8
S.E
\-/
...```

### 输出

```
5```

## 样例 #3

### 输入

```
3 3 1 2 7 8
SEE
\-/
SSS```

### 输出

```
0```

## 样例 #4

### 输入

```
1 4 6 5 4 3
S>#E```

### 输出

```
0```

## 样例 #5

### 输入

```
2 2 6 5 4 3
#E
S^```

### 输出

```
3```

## 样例 #6

### 输入

```
1 3 1 2 7 8
S#E```

### 输出

```
-1```

# 题解

## 作者：言琢დ (赞：9)

出题人题解。

## D 火烧の云

### Sol

考虑最短路，设一个三元组 $dis(i,j,k)$ 表示到达位置 $(i,j)$ 且方向状态为 $k$ 时所需最少步数。

初始化：所有点位置字符导致的连边、权值更新；$dis(S_i,S_j,\{0,1,2,3\})=0$，最终答案：$\min\{dis(E_i,E_j,\{0,1,2,3\})\}$。

注意多个起点多个终点的情况需要灵活地处理，考虑将所有起点和终点吊起来导向同一个虚拟根节点即可。

### 实现

设一个三元组

$$\begin{aligned}(i,j,0)\text{表示到达点}(i,j)\text{，\color{red}{来向}}\text{是}\text{ 北 }\text{方向}\\(i,j,1)\text{表示到达点}(i,j)\text{，\color{red}{来向}}\text{是}\text{ 东 }\text{方向}\\(i,j,2)\text{表示到达点}(i,j)\text{，\color{red}{来向}}\text{是}\text{ 南 }\text{方向}\\(i,j,3)\text{表示到达点}(i,j)\text{，\color{red}{来向}}\text{是}\text{ 西 }\text{方向}\end{aligned}$$

那么对于下面的这些字符：

| 字符 | 类型 | $(i,j,0)\rightarrow$ | $(i,j,1)\rightarrow$ | $(i,j,2)\rightarrow$ | $(i,j,3)\rightarrow$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| `\|` | $a$ | $(i+1,j,0)$ | $(i-1,j,2),(i+1,j,0)$ | $(i-1,j,2)$ | $(i-1,j,2),(i+1,j,0)$ |
| `-` | $a$ | $(i,j-1,1),(i,j+1,3)$ | $(i,j-1,1)$ | $(i,j-1,1),(i,j+1,3)$ | $(i,j+1,3)$ |
| `/` | $b$ | $(i,j-1,1)$ | $(i+1,j,0)$ | $(i,j+1,3)$ | $(i-1,j,2)$ |
| `\` | $b$ | $(i,j+1,3)$ | $(i-1,j,2)$ | $(i,j-1,1)$ | $(i+1,j,0)$ |
| `.` | $c$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ |
| `<` | $d$ | $(i,j-1,1)$ | $\color{red}(i,j-2,1)$ | $(i,j-1,1)$ | $\times$ |
| `>` | $d$ | $(i,j+1,3)$ | $\times$ | $(i,j+1,3)$ | $\color{red}(i,j+2,3)$ |
| `^` | $d$ | $\times$ | $(i-1,j,2)$ | $\color{red}(i-2,j,2)$ | $(i-1,j,2)$ |
| `v` | $d$ | $\color{red}(i+2,j,0)$ | $(i+1,j,0)$ | $\times$ | $(i+1,j,0)$ |
| `S` | $0$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ | $(i+1,j,0),(i,j-1,1),(i-1,j,2),(i,j+1,3)$ |
| `E` | $0$ | $\texttt{End}$ | $\texttt{End}$ | $\texttt{End}$ | $\texttt{End}$ |

除表格内的边，另外要连上

$$\begin{aligned}\texttt{Start}\underset{ju[i][j]==\texttt{"S"}}{\rightarrow\rightarrow\rightarrow\rightarrow}(i,j,0)\\\texttt{Start}\underset{ju[i][j]==\texttt{"S"}}{\rightarrow\rightarrow\rightarrow\rightarrow}(i,j,1)\\\texttt{Start}\underset{ju[i][j]==\texttt{"S"}}{\rightarrow\rightarrow\rightarrow\rightarrow}(i,j,2)\\\texttt{Start}\underset{ju[i][j]==\texttt{"S"}}{\rightarrow\rightarrow\rightarrow\rightarrow}(i,j,3)\end{aligned}$$

这些边就可以。`Start` 是超源，`End` 是超汇，跑一遍单源最短路 `dis[Start]=0`，最后 `dis[End]` 就是结果。

#### std

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define A mp(i, j, 0)
#define B mp(i, j, 1)
#define C mp(i, j, 2)
#define D mp(i, j, 3)
#define Start mp(n, m, 4)
#define End mp(n, m, 5)
int init(){
	char c = getchar();
	int x = 0, f = 1;
	for (; c < '0' || c > '9'; c = getchar())
		if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar())
		x = (x << 1) + (x << 3) + (c ^ 48);
	return x * f;
}
void print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int N = 2005, M = 4000005, inf = 0x3f3f3f3f;
char ju[N][N]; bool vis[M << 2];
int n, m, a, b, c, d, head[M << 2], sLen, dis[M << 2];
int mp(int x, int y, int z){
	return (x < 1 || x > n || y < 1 || y > m) ? -1 : ((m * (x - 1) + y) << 2) + z;
}
struct Node{
	int next, to, value;
}s[M << 4];
inline void add(int u, int v, int w){
	if (u == -1 || v == -1) return;
	s[++sLen] = (Node){head[u], v, w};
	head[u] = sLen;
}
std::priority_queue<std::pair<int, int> >Q;
inline void dij(){
	memset(dis,0x3f,sizeof(dis));
	Q.push(std::make_pair(inf, Start)), dis[Start] = 0;
	while (!Q.empty()) {
		std::pair<int, int> tp = Q.top(); Q.pop();
		int u = tp.second;
		if (vis[u]) continue;
		vis[u] = 1;
		for (int i = head[u]; i; i = s[i].next) {
			int v = s[i].to, w = s[i].value;
			if (dis[u] + w < dis[v]) {
				dis[v] = dis[u] + w;
				if (!vis[v]) Q.push(std::make_pair(inf - dis[v], v));
			}
		}
	}
}
int main(){
	n = init(), m = init(), a = init(), b = init(), c = init(), d = init();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			while (ju[i][j] == '\0' || ju[i][j] == ' ' || ju[i][j] == '\n' || ju[i][j] == '\r') ju[i][j] = getchar();
			switch (ju[i][j]) {
				case '|': {
					add(A, mp(i + 1, j, 0), a), add(B, mp(i - 1, j, 2), a), add(B, mp(i + 1, j, 0), a), add(C, mp(i - 1, j, 2), a), add(D, mp(i - 1, j, 2), a), add(D, mp(i + 1, j, 0), a); break;
				}
				case '-': {
					add(A, mp(i, j - 1, 1), a), add(A, mp(i, j + 1, 3), a), add(B, mp(i, j - 1, 1), a), add(C, mp(i, j - 1, 1), a), add(C, mp(i, j + 1, 3), a), add(D, mp(i, j + 1, 3), a); break;
				}
				case '/': {
					add(A, mp(i, j - 1, 1), b), add(B, mp(i + 1, j, 0), b), add(C, mp(i, j + 1, 3), b), add(D, mp(i - 1, j, 2), b); break;
				}
				case '\\': {
					add(A, mp(i, j + 1, 3), b), add(B, mp(i - 1, j, 2), b), add(C, mp(i, j - 1, 1), b), add(D, mp(i + 1, j, 0), b); break;
				}
				case '.': {
					add(A, mp(i + 1, j, 0), c), add(A, mp(i, j - 1, 1), c), add(A, mp(i - 1, j, 2), c), add(A, mp(i, j + 1, 3), c), add(B, mp(i + 1, j, 0), c), add(B, mp(i, j - 1, 1), c), add(B, mp(i - 1, j, 2), c), add(B, mp(i, j + 1, 3), c), add(C, mp(i + 1, j, 0), c), add(C, mp(i, j - 1, 1), c), add(C, mp(i - 1, j, 2), c), add(C, mp(i, j + 1, 3), c), add(D, mp(i + 1, j, 0), c), add(D, mp(i, j - 1, 1), c), add(D, mp(i - 1, j, 2), c), add(D, mp(i, j + 1, 3), c); break;
				}
				case '<': {
					add(A, mp(i, j - 1, 1), d), add(B, mp(i, j - 2, 1), 0), add(C, mp(i, j - 1, 1), d); break;
				}
				case '>': {
					add(A, mp(i, j + 1, 3), d), add(C, mp(i, j + 1, 3), d), add(D, mp(i, j + 2, 3), 0); break;
				}
				case '^': {
					add(B, mp(i - 1, j, 2), d), add(C, mp(i - 2, j, 2), 0), add(D, mp(i - 1, j, 2), d); break;
				}
				case 'v': {
					add(A, mp(i + 2, j, 0), 0), add(B, mp(i + 1, j, 0), d), add(D, mp(i + 1, j, 0), d); break;
				}
				case 'S': {
					add(Start, A, 0), add(Start, B, 0), add(Start, C, 0), add(Start, D, 0), add(A, mp(i + 1, j, 0), 0), add(A, mp(i, j - 1, 1), 0), add(A, mp(i - 1, j, 2), 0), add(A, mp(i, j + 1, 3), 0), add(B, mp(i + 1, j, 0), 0), add(B, mp(i, j - 1, 1), 0), add(B, mp(i - 1, j, 2), 0), add(B, mp(i, j + 1, 3), 0), add(C, mp(i + 1, j, 0), 0), add(C, mp(i, j - 1, 1), 0), add(C, mp(i - 1, j, 2), 0), add(C, mp(i, j + 1, 3), 0), add(D, mp(i + 1, j, 0), 0), add(D, mp(i, j - 1, 1), 0), add(D, mp(i - 1, j, 2), 0), add(D, mp(i, j + 1, 3), 0); break;
				}
				case 'E': {
					add(A, End, 0), add(B, End, 0), add(C, End, 0), add(D, End, 0); break;
				}
			}
		}
	dij();
	print(dis[End] == inf ? -1 : dis[End]), putchar('\n');
}
```

---

## 作者：Jsxts_ (赞：7)

BFS 练手题。


一开始就把所有起始点都放进队列里面，注意用优先队列，从步数最少的开始扩展。

转移状态时，我们记录当前点的上一步往哪个方向走，并记录坐标和步数。对于脚下的点按题意扩展方向，查重时要加一维表示方向。特别注意，脚下是 $S$ 的时候可以向四方扩展，也不需要增加步数。

如果理解不了就看注释吧，也没啥好讲的。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 2e9;
inline int read() {
	int s = 0,f = 1;char ch = getchar();
	while (!isdigit(ch)) f = ch == '-' ? -1 : 1, ch = getchar();
	while (isdigit(ch)) s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s*f;
}
int n,m,A,B,C,D,tot;
char a[2010][2010];
bool vis[2010][2010][4];//查重带方向 
//0左1右2上3下 
//0: x,y-1
//1: x,y+1
//2: x-1,y
//3: x+1,y
struct node {
	int x,y,step,dir;
	bool operator < (const node &a) const {
		return step > a.step;//优先找步数最少的 
	}
};
pair<int,int> aa[4000010];
int bfs() {
	priority_queue<node> q;
	for (int i = 1;i <= tot;i ++ )//所有起始点 
	q.push({aa[i].first,aa[i].second,0,0});
	while (!q.empty()) {
		node t = q.top();q.pop();
		int x = t.x,y = t.y,d = t.dir,s = t.step;
		if (x < 1 || y < 1 || x > n || y > m) continue;
		if (a[x][y] == 'E') return s;//找到直接返回 
		if (vis[x][y][d]) continue;//查重 
		if (a[x][y] == '#') continue;
		if (a[x][y] == '|') {//按题意转移，画画图就理解了 
			if (d == 0 || d == 1) q.push({x-1,y,s+A,2}), q.push({x+1,y,s+A,3});
			if (d == 2) q.push({x-1,y,s+A,2});
			if (d == 3) q.push({x+1,y,s+A,3});
		}
		if (a[x][y] == '-') {
			if (d == 2 || d == 3) q.push({x,y-1,s+A,0}), q.push({x,y+1,s+A,1});
			if (d == 0) q.push({x,y-1,s+A,0});
			if (d == 1) q.push({x,y+1,s+A,1});
		}
		if (a[x][y] == '/') {
			if (d == 0) q.push({x+1,y,s+B,3});
			if (d == 1) q.push({x-1,y,s+B,2});
			if (d == 2) q.push({x,y+1,s+B,1});
			if (d == 3) q.push({x,y-1,s+B,0});
		}
		if (a[x][y] == '\\') {
			if (d == 0) q.push({x-1,y,s+B,2});
			if (d == 1) q.push({x+1,y,s+B,3});
			if (d == 2) q.push({x,y-1,s+B,0});
			if (d == 3) q.push({x,y+1,s+B,1});
		}
		if (a[x][y] == '.')
			q.push({x+1,y,s+C,3}),
			q.push({x-1,y,s+C,2}),
			q.push({x,y-1,s+C,0}),
			q.push({x,y+1,s+C,1});
		if (a[x][y] == '<') {
			if (d == 2 || d == 3) q.push({x,y-1,s+D,0});
			if (d == 0) q.push({x,y-2,s,0});
		}
		if (a[x][y] == '>') {
			if (d == 2 || d == 3) q.push({x,y+1,s+D,1});
			if (d == 1) q.push({x,y+2,s,1});
		}
		if (a[x][y] == '^') {
			if (d == 0 || d == 1) q.push({x-1,y,s+D,2});
			if (d == 2) q.push({x-2,y,s,2});
		}
		if (a[x][y] == 'v') {
			if (d == 0 || d == 1) q.push({x+1,y,s+D,3});
			if (d == 3) q.push({x+2,y,s,3});
		}
		if (a[x][y] == 'S')//起点的转移 
			q.push({x+1,y,s,3}),
			q.push({x-1,y,s,2}),
			q.push({x,y-1,s,0}),
			q.push({x,y+1,s,1});
		vis[x][y][d] = 1;
		if (a[x][y] == '.' || a[x][y] == 'S') vis[x][y][2] = vis[x][y][1] = vis[x][y][0] = vis[x][y][3] = 1;
		//优化，如果是这两个四面都标记，不加就T了。。 
		//其实本来是要在转移的时候就判重，只是懒得写 
	}
	return -1;//无解 
}
int main() {
	n = read(), m = read(), A = read(), B = read(), C = read(), D = read();
	for (int i = 1;i <= n;i ++ ) {
		scanf("%s",a[i]+1);
		for (int j = 1;j <= m;j ++ )
			if (a[i][j] == 'S')
				aa[++tot] = make_pair(i,j);
	}
	printf("%d",bfs());
	return 0;
}
```


---

## 作者：LroseC (赞：4)

**建议先仔细看题再来阅读本篇题解**

-----

首先，看到这道大模拟，很容易想到 **优先队列广搜 / Dijstra** 算法。

然后对着数据范围计算复杂度

优先队列广搜和 Dijstra 算法在稀疏图中的复杂度均为 $O(n\log_2n)$

$n$ 指的是点数，在本题中约等于 $4 \times n \times m=1.6\times10^7$，使用 $n \log_2n$ 的算法很难通过（~~然而大家都这么过了，甚至 std 也是这么写的~~

于是想想办法优化一下

观察到数据范围中有一句话： $0 \leq a,b,c,d \leq 100$

也就是说这道题目的边的边权很小，我们想到曾学习过的 **双端队列广搜** 优化01最短路，我们是否也能用类似的方法优化这种边权很小的最短路呢？

-----

### 滚动队列广搜
~~(这个名字是我自己瞎起的）~~

类似于双端队列广搜，我们开 $101$ 个队列跑广搜，假设到当前节点的距离为 $dis$，那么这个节点就会被丢到第 $dis \bmod 101$ 个队列里。

由于边权不会超过 $100$，所以同一个队列里面不会同时存在两个距离不同的点。然后我们就可以通过滚动的方式进行广度优先搜索

滚动队列广搜示例代码
```cpp
struct Edge
{
	int w, v;
};
int dist[N];
bool vis[N];
vector<Edge> G[N]; //用 vector 实现邻接表存图
queue<int> q[101];
void bfs(void)
{
	q.push(S);
	int last = 0, now = 0; // now 是当前距离
	while (now - last <= 101) { // 如果 当前距离 和 最远节点之间的距离大于 101, 说明所有队列都空了
		++now;
		if (q[now % 101].size()) last = now; // last 记录最远距离
		while (q[now % 101].size()) {
			int u = q[now % 101].front();
			for (auto t : G[u]) {
				if (!vis[t.v]) {
					vis[t.v] = 1;
					dist[t.v] = (now + t.w);
					q[(now + t.w) % 101].emplace(t.v);
				}
			}
		}
	}
}
```

这个滚动队列广搜的复杂度是 $O(n + m)$ 的，其中 $n$ 指点数, $m$ 指边数

但是如果所有的边的长度都是 $100$ 的话，这个代码就会带上 $100$ 的大常数。这个常数有多大呢？如果 $\log_2 n=100$ ，说明 $n$ 竟然等于惊人的 $2^{100}$ ！

~~（我说这话当然不是为了侮辱你的智商）~~ 由此可见，这份代码如果带上 $100$ 的大常数，我还不如去打那个 $O(n\log_2n)$ 的算法。

但是这份代码还可以进一步优化: 我们可以开一个优先队列，里面存着所有当前 **有点** 的队列存放的节点的 **距离**。这样这个代码的复杂度就可以优化到 $O((n + m)\times \log_2100)$ 。

示例代码
```cpp
struct Edge
{
	int w, v;
};
int dist[N];
bool vis[N];
vector<Edge> G[N]; //用 vector 实现邻接表存图
bool VIS[101] //记录这个队列里面是否有点
queue<int> q[101];
priority_queue< int, vector<int>, greater<int> > heap; //优先队列
void bfs(void)
{
	q.emplace(S);
	heap.emplace(0);
	while (heap.size()) { // 如果 优先队列里还有东西，说明还有没有被遍历到的点
		int now = heap.top(); heap.pop(); //取出当前最近的距离
		VIS[now % 101] = 0;
		while (q[now % 101].size()) {
			int u = q[now % 101].front();
			for (auto t : G[u]) {
				if (!vis[t.v]) {
					vis[t.v] = 1;
					dist[t.v] = (now + t.w);
					q[(now + t.w) % 101].emplace(t.v);
					if (!VIS[(now + t.w) % 101]) { //这个队列原来是空的
						heap.emplace(now + t.w); //把这个新的距离放入优先队列
						VIS[(now + t.w) % 101] = 1;
					}
				}
			}
		}
	}
}
```

最后我们再来计算一下复杂度，这个代码的复杂度在稀疏图中大约为 $O(n \times \log_2100)$，其中 $n$ 指的是点数

把数据带入，复杂度大约是 $4 \times 2000 \times 2000 \times 6 = 9.6 \times 10^7$，可以通过。

~~(于是我就顺理成章地上了卡常榜)~~

最后我们只要把上面模板里面的函数 **稍微** 修改一下，按照题意模拟，就能通过这道题目拉！是不是非常简单呢？

参考代码
```cpp
#include <queue>
#include <cctype>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 2010;
const int D = 110;

template<typename T = int>
inline T read(void)
{
	T res = 0, f = 1; char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) { res = res * 10 + ch - '0'; ch = getchar(); }
	return res * f;
}
template<typename T>
inline void write(T x, char end = '\n')
{
	static char buf[50]; int p = -1;
	if (x == 0) putchar('0');
	if (x < 0) { putchar('-'); x = -x; }
	while (x) { buf[++p] = x % 10; x /= 10; }
	while (~p) { putchar(buf[p] + '0'); --p; } putchar(end);
}

struct Node
{
	int x, y, dir;
	Node(int _x, int _y, int _d) : x(_x), y(_y), dir(_d) {}
};

int n, m;
int a, b, c, d;
char G[N][N];
int VIS[N][N][4];
bool vis[D];
queue<Node> q[D];
priority_queue<int, vector<int>, greater<int> > heap;
int gox[] = {1, -1, 0, 0};
int goy[] = {0, 0, 1, -1};

inline int BFS(void)
{
	memset(vis, 0, sizeof vis);
	memset(VIS, 0, sizeof VIS);
	for (int i = 1; i < D; ++i)
		while (q[i].size()) q[i].pop();
	int last = 0;
	heap.emplace(0);
	while (heap.size()) {
		int dis = heap.top();
		int u = dis % D; heap.pop();
		vis[u] = 0;

		while (q[u].size()) {
			auto t = q[u].front(); q[u].pop();
			if (VIS[t.x][t.y][t.dir]) continue;
			VIS[t.x][t.y][t.dir] = 1;
			int xx, yy, dd;
			if (G[t.x][t.y] == 'E') return dis;
			switch(G[t.x][t.y]) {//模拟部分
				case '#':
					break;
				case '|':
					if (t.dir < 2) {
						dd = t.dir;
						xx = t.x + gox[t.dir];
						yy = t.y + goy[t.dir];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + a) % D].emplace(Node(xx, yy, t.dir));
						if (!vis[(u + a) % D]) {
							vis[(u + a) % D] = 1;
							heap.emplace((dis + a));
						}
					}
					else {
						for (dd = 0; dd < 2; ++dd) {
							xx = t.x + gox[dd];
							yy = t.y + goy[dd];
							if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
							q[(u + a) % D].emplace(Node(xx, yy, dd));
							if (!vis[(u + a) % D]) {
								vis[(u + a) % D] = 1;
								heap.emplace((dis + a));
							}
						}
					}
					break;
				case '-':
					if (t.dir >= 2) {
						xx = t.x + gox[t.dir];
						yy = t.y + goy[t.dir];
						dd = t.dir;
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + a) % D].emplace(Node(xx, yy, t.dir));
						if (!vis[(u + a) % D]) {
							vis[(u + a) % D] = 1;
							heap.emplace((dis + a));
						}
					}
					else {
						for (dd = 2; dd < 3; ++dd) {
							xx = t.x + gox[dd];
							yy = t.y + goy[dd];
							if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
							q[(u + a) % D].emplace(Node(xx, yy, dd));
							if (!vis[(u + a) % D]) {
								vis[(u + a) % D] = 1;
								heap.emplace((dis + a));
							}
						}
					}
					break;
				case '/':
					if (t.dir == 0) dd = 3;
					if (t.dir == 1) dd = 2;
					if (t.dir == 2) dd = 1;
					if (t.dir == 3) dd = 0;
					xx = t.x + gox[dd];
					yy = t.y + goy[dd];
					if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
					q[(u + b) % D].emplace(Node(xx, yy, dd));
					if (!vis[(u + b) % D]) {
						vis[(u + b) % D] = 1;
						heap.emplace((dis + b));
					}
					break;
				case '\\':
					if (t.dir == 0) dd = 2;
					if (t.dir == 1) dd = 3;
					if (t.dir == 2) dd = 0;
					if (t.dir == 3) dd = 1;
					xx = t.x + gox[dd];
					yy = t.y + goy[dd];
					if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
					q[(u + b) % D].emplace(Node(xx, yy, dd));
					if (!vis[(u + b) % D]) {
						vis[(u + b) % D] = 1;
						heap.emplace((dis + b));
					}
					break;
				case '.':
					for (dd = 0; dd < 4; ++dd) {
						xx = t.x + gox[dd];
						yy = t.y + goy[dd];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) continue;
						q[(u + c) % D].emplace(Node(xx, yy, dd));
						if (!vis[(u + c) % D]) {
							vis[(u + c) % D] = 1;
							heap.emplace(dis + c);
						}
					}
					break;
				case '<':
					if (t.dir < 2) {
						dd = 3;
						xx = t.x + gox[dd];
						yy = t.y + goy[dd];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + d) % D].emplace(Node(xx, yy, dd));
						if (!vis[(u + d) % D]) {
							vis[(u + d) % D] = 1;
							heap.emplace(dis + d);
						}
					}
					if (t.dir == 3) {
						dd = 3;
						xx = t.x;
						yy = t.y - 2;
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[u].emplace(Node(xx, yy, dd));
					}
					break;
				case '>':
					if (t.dir < 2) {
						dd = 2;
						xx = t.x + gox[dd];
						yy = t.y + goy[dd];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + d) % D].emplace(Node(xx, yy, dd));
						if (!vis[(u + d) % D]) {
							vis[(u + d) % D] = 1;
							heap.emplace(dis + d);
						}
					}
					if (t.dir == 2) {
						dd = 2;
						xx = t.x;
						yy = t.y + 2;
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[u].emplace(Node(xx, yy, dd));
					}
					break;
				case '^':
					if (t.dir >= 2) {
						dd = 1;
						xx = t.x + gox[dd];
						yy = t.y + goy[dd];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + d) % D].emplace(Node(xx, yy, dd));
						if (!vis[(u + d) % D]) {
							vis[(u + d) % D] = 1;
							heap.emplace(dis + d);
						}
					}
					if (t.dir == 1) {
						dd = 1;
						xx = t.x - 2;
						yy = t.y;
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[u].emplace(Node(xx, yy, dd));
					}
					break;
				case 'v':
					if (t.dir >= 2) {
						dd = 0;
						xx = t.x + gox[dd];
						yy = t.y + goy[dd];
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[(u + d) % D].emplace(Node(xx, yy, dd));
						if (!vis[(u + d) % D]) {
							vis[(u + d) % D] = 1;
							heap.emplace(dis + d);
						}
					}
					if (t.dir == 0) {
						dd = 0;
						xx = t.x + 2;
						yy = t.y;
						if (xx <= 0 || xx > n || yy <= 0 || yy > m || G[xx][yy] == '#' || VIS[xx][yy][dd]) break;
						q[u].emplace(Node(xx, yy, dd));
					}
					break;
			}
		}
	}
	return -1;
}

int main(void)
{
	n = read(), m = read();
	a = read(), b = read(), c = read(), d = read();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			do G[i][j] = getchar();
			while (isspace(G[i][j]));
		}
        
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			if (G[i][j] == 'S') {
				for (int k = 0; k < 4; ++k) {
					int xx = i + gox[k];
					int yy = j + goy[k];
					if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && G[xx][yy] != '#') {
						q[0].emplace(Node(xx, yy, k));
					}
				}
			}
	write(BFS());
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：3)

求起点到终点所花费的最短时间，可以用 `bfs` 来解决问题。对于一个点，包含四个信息，分别是横纵坐标、当前花费的时间和方向。由题可知，有若干个起点，所以首先把所有起点均加入到队列中去。一共有八种不同的关键字符，一一列举即可，注意判断边界的条件。

1. `#` 无法通过，因此直接出队。
2. `S` 作为起点，四个方向均可。
3. `E` 到达终点，更新答案后出队。
4. `|` 与 `-` 若可以移动，则直行；否则转向，将两个方向的情况加入队列。
5. `/` 与 `\` 按照要求转向。注意，在打 `\` 时需要写成 `if (str == '\\')` 才能进行判断。
6. `.` 会出现三种情况，依次加入队列。
7. `^`,`v`,`>` 与 `<` 均为前进类道路，符合要求时可以前进两个单位。

但是这样还无法通过此题，需要有两个优化。第一个显然是针对重复走的情况，每个格子上记录走到该格子的最短时间，类似于记忆化搜索，只有比当前情况更优时再继续判断加入队列。第二个是用优先队列优化来防止超时，每次出队时优先找出花费时间最小的来继续更新。

哦对了，若答案一直无法被更新，也就是无解的情况，此时要记得特判输出 $-1$。

于是乎，一道大模拟到这里就做好了（害得我交了几十遍，赛时也就因为没有第二个优化一直 $45 \ \texttt{pts}$）。代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <queue>
#define init(x) memset (x,INF,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 2005;
const int MOD = 1e9 + 7;
inline int read ();
struct node
{
	int x,y,cos,dir;
	bool operator < (const node &a) const {
		return cos > a.cos;
	}
	//dir 1 2 3 4 N S W E
};
priority_queue <node> q;
int n,m,a,b,c,d,ans = INF,dis[MAX][MAX][5]; 
char str[MAX][MAX];
int main ()
{
	n = read ();m = read ();a = read (),b = read (),c = read (),d = read ();
	for (int i = 1;i <= n;++i) scanf ("%s",str[i] + 1);
	for (int i = 1;i <= n;++i)
	{
		for (int j = 1;j <= m;++j)
		{
			if (str[i][j] == 'S')
			{
				q.push ({i,j,0,1});
				q.push ({i,j,0,2});
				q.push ({i,j,0,3});
				q.push ({i,j,0,4});
			}
		}
	}		
	init (dis);
	while (!q.empty ())
	{
		node now = q.top ();q.pop ();
		if (now.x < 1 || now.x > n || now.y < 1 || now.y > m) continue;
		if (str[now.x][now.y] == '#') continue;
		if (str[now.x][now.y] == 'E')
		{
			ans = min (ans,now.cos);
			break;
		}
		if (dis[now.x][now.y][now.dir] <= now.cos) continue;
		dis[now.x][now.y][now.dir] = now.cos;
		if (now.dir == 1)
		{
			if (str[now.x][now.y] == 'S') q.push ({now.x - 1,now.y,now.cos,1});
			if (str[now.x][now.y] == '|') q.push ({now.x - 1,now.y,now.cos + a,1});
			if (str[now.x][now.y] == '-') q.push ({now.x,now.y - 1,now.cos + a,3}),q.push ({now.x,now.y + 1,now.cos + a,4});
			if (str[now.x][now.y] == '/') q.push ({now.x,now.y + 1,now.cos + b,4}); 
			if (str[now.x][now.y] == '\\') q.push ({now.x,now.y - 1,now.cos + b,3}); 
			if (str[now.x][now.y] == '.') q.push ({now.x - 1,now.y,now.cos + c,1}),q.push ({now.x,now.y - 1,now.cos + c,3}),q.push ({now.x,now.y + 1,now.cos + c,4});
			if (str[now.x][now.y] == '<') q.push ({now.x,now.y - 1,now.cos + d,3});
			if (str[now.x][now.y] == '>') q.push ({now.x,now.y + 1,now.cos + d,4});
			if (str[now.x][now.y] == '^') q.push ({now.x - 2,now.y,now.cos,1});
			if (str[now.x][now.y] == 'v') ;
		}
		if (now.dir == 2)
		{
			if (str[now.x][now.y] == 'S') q.push ({now.x + 1,now.y,now.cos,2});
			if (str[now.x][now.y] == '|') q.push ({now.x + 1,now.y,now.cos + a,2});
			if (str[now.x][now.y] == '-') q.push ({now.x,now.y - 1,now.cos + a,3}),q.push ({now.x,now.y + 1,now.cos + a,4});
			if (str[now.x][now.y] == '/') q.push ({now.x,now.y - 1,now.cos + b,3}); 
			if (str[now.x][now.y] == '\\') q.push ({now.x,now.y + 1,now.cos + b,4}); 
			if (str[now.x][now.y] == '.') q.push ({now.x + 1,now.y,now.cos + c,2}),q.push ({now.x,now.y - 1,now.cos + c,3}),q.push ({now.x,now.y + 1,now.cos + c,4});
			if (str[now.x][now.y] == '<') q.push ({now.x,now.y - 1,now.cos + d,3});
			if (str[now.x][now.y] == '>') q.push ({now.x,now.y + 1,now.cos + d,4});
			if (str[now.x][now.y] == '^') ;
			if (str[now.x][now.y] == 'v') q.push ({now.x + 2,now.y,now.cos,2});
		}
		if (now.dir == 3)
		{
			if (str[now.x][now.y] == 'S') q.push ({now.x,now.y - 1,now.cos,3});
			if (str[now.x][now.y] == '|') q.push ({now.x - 1,now.y,now.cos + a,1}),q.push ({now.x + 1,now.y,now.cos + a,2});
			if (str[now.x][now.y] == '-') q.push ({now.x,now.y - 1,now.cos + a,3});
			if (str[now.x][now.y] == '/') q.push ({now.x + 1,now.y,now.cos + b,2}); 
			if (str[now.x][now.y] == '\\') q.push ({now.x - 1,now.y,now.cos + b,1}); 
			if (str[now.x][now.y] == '.') q.push ({now.x,now.y - 1,now.cos + c,3}),q.push ({now.x - 1,now.y,now.cos + c,1}),q.push ({now.x + 1,now.y,now.cos + c,2});
			if (str[now.x][now.y] == '<') q.push ({now.x,now.y - 2,now.cos,3});
			if (str[now.x][now.y] == '>') ;
			if (str[now.x][now.y] == '^') q.push ({now.x - 1,now.y,now.cos + d,1});
			if (str[now.x][now.y] == 'v') q.push ({now.x + 1,now.y,now.cos + d,2});
		}
		if (now.dir == 4)
		{
			if (str[now.x][now.y] == 'S') q.push ({now.x,now.y + 1,now.cos,4});
			if (str[now.x][now.y] == '|') q.push ({now.x - 1,now.y,now.cos + a,1}),q.push ({now.x + 1,now.y,now.cos + a,2});
			if (str[now.x][now.y] == '-') q.push ({now.x,now.y + 1,now.cos + a,4});
			if (str[now.x][now.y] == '/') q.push ({now.x - 1,now.y,now.cos + b,1}); 
			if (str[now.x][now.y] == '\\') q.push ({now.x + 1,now.y,now.cos + b,2}); 
			if (str[now.x][now.y] == '.') q.push ({now.x,now.y + 1,now.cos + c,4}),q.push ({now.x - 1,now.y,now.cos + c,1}),q.push ({now.x + 1,now.y,now.cos + c,2});
			if (str[now.x][now.y] == '<') ;
			if (str[now.x][now.y] == '>') q.push ({now.x,now.y + 2,now.cos,4});
			if (str[now.x][now.y] == '^') q.push ({now.x - 1,now.y,now.cos + d,1});
			if (str[now.x][now.y] == 'v') q.push ({now.x + 1,now.y,now.cos + d,2});
		}
	} 
	if (ans == INF) printf ("-1\n");
	else printf ("%d\n",ans);
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
```

---

## 作者：_O_v_O_ (赞：1)

多元最短路+大模拟。

考虑用优先队列来 bfs。

由于一个方块可能从多个点到来，所以我们在 bfs 过程中我们不仅要存储格子，同时还要存储方向。

由于我们用的是优先队列，所以不用担心后搜到的点比前搜到的点的时间要短，所以我们设 $vis_{x,y,z}$ 表示是否搜到了 $c_{x,y}$ 方向为 $z$。

然而这样还过不了，我们注意到一个空地走四方都行，所以我们在搜到空地时，我们需要将 $vis_{x,y,0/1/2/3}$ 都设为 true。

然后就是有点细节的大模拟了，代码：


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e3+5;
int n,m,A,B,C,D;
char c[N][N],dis[N][N][4];
bool vis[N][N][4];
struct node{
	int x,y,dis,z;
	bool operator <(const node &a)const{
		return a.dis<dis;
	}
};

int bfs(){
	priority_queue<node> qp;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(c[i][j]=='S') qp.push({i,j,0,0});
	while(!qp.empty()){
		node f=qp.top();qp.pop();
		int fx=f.x,fy=f.y,fz=f.z,fd=f.dis;
		if(fx<1||fx>n||fy<1||fy>m) continue;
		if(vis[fx][fy][fz]) continue;
//		cout<<fx<<' '<<fy<<' '<<fz<<' '<<fd<<endl;
		if(c[fx][fy]=='E') return fd;
		if(c[fx][fy]=='#') continue;
		if(c[fx][fy]=='|'){
			if(fz==0||fz==1) qp.push({fx-1,fy,fd+A,2}),qp.push({fx+1,fy,fd+A,3});
			if(fz==2) qp.push({fx-1,fy,fd+A,2});
			if(fz==3) qp.push({fx+1,fy,fd+A,3});
		}
		if(c[fx][fy]=='-'){
			if(fz==2||fz==3) qp.push({fx,fy-1,fd+A,0}),qp.push({fx,fy+1,fd+A,1});
			if(fz==0) qp.push({fx,fy-1,fd+A,0});
			if(fz==1) qp.push({fx,fy+1,fd+A,1});
		}
		if(c[fx][fy]=='/'){
			if(fz==0) qp.push({fx+1,fy,fd+B,3});
			if(fz==1) qp.push({fx-1,fy,fd+B,2});
			if(fz==2) qp.push({fx,fy+1,fd+B,1});
			if(fz==3) qp.push({fx,fy-1,fd+B,0});
		}
		if(c[fx][fy]=='\\'){
			if(fz==0) qp.push({fx-1,fy,fd+B,2});
			if(fz==1) qp.push({fx+1,fy,fd+B,3});
			if(fz==2) qp.push({fx,fy-1,fd+B,0});
			if(fz==3) qp.push({fx,fy+1,fd+B,1});
		}
		if(c[fx][fy]=='.'){
			qp.push({fx+1,fy,fd+C,3});
			qp.push({fx-1,fy,fd+C,2});
			qp.push({fx,fy+1,fd+C,1});
			qp.push({fx,fy-1,fd+C,0});
			vis[fx][fy][0]=vis[fx][fy][1]=vis[fx][fy][2]=vis[fx][fy][3]=1;
		}
		if(c[fx][fy]=='S'){
			qp.push({fx+1,fy,fd,3});
			qp.push({fx-1,fy,fd,2});
			qp.push({fx,fy+1,fd,1});
			qp.push({fx,fy-1,fd,0});
			vis[fx][fy][0]=vis[fx][fy][1]=vis[fx][fy][2]=vis[fx][fy][3]=1;
		}
		if(c[fx][fy]=='<'){
			if(fz==2||fz==3) qp.push({fx,fy-1,fd+D,0});
			if(fz==0) qp.push({fx,fy-2,fd,0});
		}
		if(c[fx][fy]=='>'){
			if(fz==2||fz==3) qp.push({fx,fy+1,fd+D,1});
			if(fz==1) qp.push({fx,fy+2,fd,1});
		}
		if(c[fx][fy]=='^'){
			if(fz==0||fz==1) qp.push({fx-1,fy,fd+D,2});
			if(fz==2) qp.push({fx-2,fy,fd,2});
		}
		if(c[fx][fy]=='v'){
			if(fz==0||fz==1) qp.push({fx+1,fy,fd+D,3});
			if(fz==3) qp.push({fx+2,fy,fd,3});
		}
		vis[fx][fy][fz]=1;
	}
	return -1;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m>>A>>B>>C>>D;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>c[i][j];
	cout<<bfs();
	return 0;
}
```

---


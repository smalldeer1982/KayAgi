# [COCI 2007/2008 #5] BAZA

## 题目描述

定义两个字符串的公共前缀为这两个字符串从开头开始的公共子串。比如，字符串 `identity` 和字符串 `idealistic` 的公共前缀为 `ide`。

有一个数据库包含了 $N$ 个字符串。

在这个数据库中查询字符串 $W$ 使用的算法很原始，它将 $W$ 与数据库中的字符串一一比较。两个字符串的字符也一一比对，直到找到一个不匹配的字符或者其中一个字符串的结尾，然后进行最后一次比较确定两个字符串长度是否相等。当在数据库中找到 $W$ 时，算法结束。

分析这个算法，我们发现，在数据库中找到 $W$ 所用的步骤数等于与 $W$ 进行比较的字符串数量，加上 $W$ 与所有进行比较的字符串的公共前缀之和。

共有 $Q$ 个需查询的字符串。

写出一个程序，计算对于每一个字符串，程序需要多少步才能在数据库中找到这个词。

**请留意本题非同寻常的内存限制。**

## 说明/提示

对于 $100\%$ 的数据，$1\le N,Q\le 3\times 10^4$，所有字符串长度 $<30$，且只包含小写字母。

### 样例 2 解释：

对于样例 2，搜索字符串 `krampus` 所用的步数为 $8$，我们只需要将数据库里每一个字符串的第一个字符与此字符串比较即可。

搜索字符串 `malnar` 时，前三个字符串每个字符串需要比较三次，剩下五个字符串每个字符串则需要比较四次，所以总共需要 $29$ 次比较。

为了找到 `majmun` 字符串，我们总共需要 $14$ 次比较。对于第一个单词，我们进行了六次成功的比较，但最后一次比较确定了字符串 `majmunica` 比 `majmun` 长。对于第二个字符串，我们也进行了六次成功的比较，在最后一次比较中我们发现两个字符串长度相等，算法结束。

本题分值按照原比赛设置，满分 $90$ 分。

## 样例 #1

### 输入

```
5
hobotnica
robot
hobi
hobit
robi
4
robi
hobi
hobit
rakija ```

### 输出

```
12
10
16
7 ```

## 样例 #2

### 输入

```
8
majmunica
majmun
majka
malina
malinska
malo
maleni
malesnica
3
krampus
malnar
majmun ```

### 输出

```
8
29
14```

# 题解

## 作者：Liquefyx (赞：5)

~~先说个题外话，这道题哈希用 $29$，会 ***WA*** 几个点！？？？（2023.6.24）~~

upd：原因是写代码的时候没发现字符串访问了未赋值的地方导致哈希出了问题……有点内个了 o(╥﹏╥)o，哈希用 $29$ 也是可以的（2023.10.17）

### 题意

已知 $N$ 个长度不超过 $30$ 的字符串 $S_i$，有 $Q$ 次询问，每次询问给出一个长度依旧不超过 $30$ 的字符串 $T_i$，求出 $T_i$ 在 $S_i$ 中第一次出现的位置 $w_i$（没有则为 $N$）加上 $i=1\sim w$ 的 $S_i$ 与 $T_i$ 的最长公共前缀的长度之和。

### 题目分析

首先一看内存限制，好家伙，**32 MB**，字典树建不下，这可怎么办？但我们可以发现，我们可以将询问离线下来，分开求 $w_i$ 和最长公共前缀的长度之和。

求 $w_i$ 是比较简单的，直接 hash+unordered_map 就行了，接着我们考虑求最长公共前缀的长度之和，由于这道题的字符串长度并不是非常大，我们可以将 $S_i$ 和 $T_i$ 的每个前缀单独拎出来然后求哈希值，再用 unordered_map 统计与 $T_i$ 的前缀的哈希值、长度均相同的 $S_i$ 的前缀的个数之和，而这即为最长公共前缀的长度之和，具体细节可以康康代码。

时间复杂度是优秀的 $O(N\times |S|)$，空间复杂度也是 $O(N\times |S|)$。

### Code

```c++
#include <bits/stdc++.h>
#define uLL unsigned long long
using namespace std;
const int N = 3e4+5;
const uLL base = 31;
int n, q, ans[N];
uLL az[N], bb[N];
unordered_map <uLL, int> vis;
char s[N][35], t[N][35];
vector <int> to[N];

template <typename T> void read(T& x) {
	x = 0; int f = 0; char c = getchar();
	while(c < '0' || c > '9') f |= (c == '-'), c=getchar();
	while(c >= '0' && c <= '9') x=(x<<1)+(x<<3)+(c^48), c=getchar();
	x=(f ? -x : x);
}
int lne; char put[105];
template <typename T> void write(T x, char ch) {
	lne = 0; if(x < 0) putchar('-'), x=-x;
	do { put[++lne]=x%10, x/=10; } while(x);
	while(lne) putchar(put[lne--]^48);
	putchar(ch);
}

signed main() {
	read(n);
	for(int i = 1; i <= n; ++i) {
		scanf("%s", s[i]+1);
		int ln = strlen(s[i]+1);
		for(int len = 1; len <= ln; ++len)
			az[i]=az[i]*base+s[i][len]-'a'+1;
		if(vis.find(az[i]) == vis.end())
			vis[az[i]]=i;//先统计第一个哈希值为这个的S_i的位置 
	}
	read(q);
	for(int i = 1; i <= q; ++i) {
		scanf("%s", t[i]+1);
		int ln = strlen(t[i]+1);
		for(int o = 1; o <= ln; ++o)
			bb[i]=bb[i]*base+t[i][o]-'a'+1;
		if(vis.find(bb[i]) == vis.end())//找w_i,找不到就是n 
			to[n+1].push_back(i), ans[i]+=n;
		else
			to[vis[bb[i]]].push_back(i), ans[i]+=vis[bb[i]];
	}
	for(int i = 1; i <= n; ++i) 
		az[i]=0;
	for(int i = 1; i <= q; ++i) 
		bb[i]=0;
	for(int len = 1; len <= 30; ++len) {
		vis.clear();
		for(int i = 1; i <= q; ++i) 
			if(strlen(t[i]+1) >= len) //upd:!!!就是这个地方!!!一定要判 
				bb[i]=bb[i]*base+t[i][len]-'a'+1;//更新哈希值 
		for(int i = 1; i <= n; ++i) {
			if(strlen(s[i]+1) < len) continue;//长度小的不算 
			az[i]=az[i]*base+s[i][len]-'a'+1;
			++vis[az[i]];//统计个数 
			for(int j : to[i]) //找到w_i等于i的T_i贡献答案 
				if(vis.find(bb[j]) != vis.end())
					ans[j]+=vis[bb[j]];//贡献答案 
		}
		for(int j : to[n+1])//特殊处理找不到w_i的T_i 
			if(vis.find(bb[j]) != vis.end())
				ans[j]+=vis[bb[j]];
	}
	for(int i = 1; i <= q; ++i) 
		write(ans[i], '\n');
	return 0;
}
```



---

## 作者：Watware (赞：3)

注意到，本题的空间限制十分的紧，无法支持我们存下整棵 trie，但是，字符串的长度很小，我们考虑一个离线的类似整体二分和 tarjan 求 LCA 那样的算法，把所有的数据放在一起遍历一遍 trie，这样就可以保证时间和空间复杂度都可以通过。

先考虑如何找到每个字符串在字符集中出现的第一个位置：当字典树建立到第 $n$ 层，而字典中匹配至当前结点的集合为 $S$，询问中匹配到当前结点的集合为 $T$，显然 $S$ 与 $T$ 中任意两个字符串的前 $n$ 位是相同的，我们将 $S$ 和 $T$ 按照第 $n+1$ 位排序，然后遍历字符集把它们拆开，继续往下递归，代码如下，可以参考整体二分相关 blog，记录得到的答案为 $goal$：

```cpp
void qry(int n, int l, int r, int dl, int dr) {
    if (l > r || dl > dr) return;
    stable_sort(S + l, S + r + 1, [&n](int a, int b) { return s[a][n] < s[b][n]; });
    stable_sort(T + dl, T + dr + 1, [&n](int a, int b) { return t[a][n] < t[b][n]; });

    for (int now = 0, i = l, j, u = dl, v; j = i, v = u, now < 27; i = j, u = v, now++) {
        while (j <= r && s[S[j]][n] == ug[now]) j++;
        while (v <= dr && t[T[v]][n] == ug[now]) v++;
        if (!now && i < j)
            for (int x = u; x < v; x++) goal[T[x]] = S[i];
        else qry(n + 1, i, j - 1, u, v - 1);
    }
}
```

接下来统计另一部分答案，与上面的做法相同，但是注意到如果字符串 $s$ 能贡献到 $t$，应有 $index(s)\le goal(t)$，考虑使用一个树状数组维护，代码如下，记录得到的答案为 $ans$：

```cpp
void work(int n, int l, int r, int dl, int dr) {
    if (l > r || dl > dr) return;
    stable_sort(S + l, S + r + 1, [&n](int a, int b) { return s[a][n] < s[b][n]; });
    stable_sort(T + dl, T + dr + 1, [&n](int a, int b) { return t[a][n] < t[b][n]; });
    for (int now = 0, i = l, j, u = dl, v; j = i, v = u, now < 27; i = j, u = v, now++) {
        while (j <= r && s[S[j]][n] == ug[now]) j++;
        while (v <= dr && t[T[v]][n] == ug[now]) v++;
        if (!now) continue;
        for (int x = i; x < j; x++) add(S[x], 1);
        for (int x = u; x < v; x++) ans[T[x]] += get(goal[T[x]]);
        clr();
        work(n + 1, i, j - 1, u, v - 1);
    }
}
```

则最终答案为 $goal+ans$，完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 30010, M = 900010;
int n, q, S[N], T[N], goal[N], stk[N], tree[N], ans[N];
char s[N][32], t[N][32], ug[27];
inline int lowbit(int x) { return x & -x; }
inline void add(int x, int v) {
    if (v == 1) stk[++stk[0]] = x;
    for (; x <= n; x += lowbit(x)) tree[x] += v;
}
inline int get(int x, int res = 0) {
    for (; x; x -= lowbit(x)) res += tree[x];
    return res;
}
inline void clr() {
    while (stk[0]) add(stk[stk[0]--], -1);
}
template<typename V>
void solve(int n, int l, int r, int dl, int dr, V &&f) {
    if (l > r || dl > dr) return;
    stable_sort(S + l, S + r + 1, [&n](int a, int b) { return s[a][n] < s[b][n]; });
    stable_sort(T + dl, T + dr + 1, [&n](int a, int b) { return t[a][n] < t[b][n]; });
    for (int now = 0, i = l, j, u = dl, v; j = i, v = u, now < 27; i = j, u = v, now++) {
        while (j <= r && s[S[j]][n] == ug[now]) j++;
        while (v <= dr && t[T[v]][n] == ug[now]) v++;
        f(now, i, j, u, v);
        if (now) solve(n + 1, i, j - 1, u, v - 1, f);
    }
}
int main() {
    scanf("%d", &n), iota(ug + 1, ug + 27, 'a'), iota(S, S + N, 0), iota(T, T + N, 0);
    for (int i = 1; i <= n; i++) scanf(" %s", s[i]);
    scanf("%d", &q);
    for (int i = 1; i <= q; i++) scanf(" %s", t[i]);
    solve(0, 1, n, 1, q, [](int now, int i, int j, int u, int v) {
        if (!now && i < j)
            for (int x = u; x < v; x++) goal[T[x]] = S[i];
    });
    iota(S, S + N, 0), iota(T, T + N, 0), for_each(goal + 1, goal + q + 1, [](int &x) { x = x ? x : n; });
    solve(0, 1, n, 1, q, [](int now, int i, int j, int u, int v) {
        if (!now) return;
        for (int x = i; x < j; x++) add(S[x], 1);
        for (int x = u; x < v; x++) ans[T[x]] += get(goal[T[x]]);
        clr();
    });
    for (int i = 1; i <= q; i++) printf("%d\n", goal[i] + ans[i]);
    return 0;
}
```



---

## 作者：RoFtaCD (赞：2)

## 前言

这是目前时间最劣的做法，但是空间只需要 5MB 而且代码较短。

校内模拟赛出过无严苛空间限制但需要时间小于 300ms 的~~毒瘤卡常~~版本，可以离线后用
`trie` + `std::unordered_map ` 做过去，其实我不觉得这个版本简单（）。


## 分析

本题的一个特↑性↓是空间限制32MB，这使本题无法建立空间复杂度为  $ \mathcal{O}(N \cdot \left|S\right| \cdot c) $ 的 `trie` 树（$\left|S\right|$  为所有字符串最大长度，$c$ 为字符集大小），只能开一些数组。
   
首先考虑将查询离线，并根据题意观察发现答案和字符串前缀有关，而且 $\left|S\right|<30$。

不难想到改变枚举顺序，长度从 $1$ 到 $30$ 每次将数据库中字符串按**长度为** $i$ **的前缀子串**的**字典序**排序（以下标为第二关键字），并将长度不足的字符串末尾用字母之外的字符补齐。计算在匹配成功前有多少个字符串与当前查询的字符串存在长度为 $i$ 的**公共前缀子串**。

排序依据和结构体大概长这样：

```cpp
int cmp(const char *a,const char *b){
	for(int i=0;i<len;++i){
		if(a[i]>b[i]) return 0;
		if(a[i]<b[i]) return 1;
	}
	return 2; //不要问我为什么相同返回 2
}

struct str{
	char s[32];
	int id;
	bool friend operator <(const str &a,const str &b){
		return cmp(a.s,b.s)==2 ? a.id<b.id : cmp(a.s,b.s);
	}
}b[N];
```


因为匹配成功后就停止了，所以要预先处理每个查询的字符串会匹配到数据库中**第几个字符串**后停止，可以用空间并不大的 `std::unordered_map ` 配合字符串哈希处理，用数组 $pos$ 记录。

之后查找下标最小的拥有**长度为** $i$ **的公共前缀子串**的字符串在排序后的位置，用数组 $pre$ 记录，以及用 $npos_j$ 记录 $pos_j$ 的当前位置。则对于第 $j$ 个查询的字符串，当前长度对答案的贡献为 $npos_j-pre_j+1$。

如果第 $j$ 个字符串无法在数据库中找到匹配的（也就是**没有** $pos_j$ 的情况），就用二分查找，找到下标最大的拥有**长度为** $i$ **的公共前缀子串**的字符串在排序后的位置 $r$，当前长度对答案的贡献为 $r-pre_j+1$。

统计完贡献输出答案即可。


## 代码

```cpp
#include <bits/stdc++.h>
bool ST;
using std::lower_bound;
#define lrb lower_bound
typedef long long ll;
typedef unsigned long long ull;
const int N=3e4+5,inf=0x3f3f3f3f;

std::unordered_map<ull,int> ump;
int n,q,len,pos[N],p[N],minp[N],ans[N];

int cmp(const char *a,const char *b){
	for(int i=0;i<len;++i){
		if(a[i]>b[i]) return 0;
		if(a[i]<b[i]) return 1;
	}
	return 2;
}

struct str{
	char s[32];
	int id;
	bool friend operator <(const str &a,const str &b){
		return cmp(a.s,b.s)==2 ? a.id<b.id : cmp(a.s,b.s);
	}
}b[N],tp;
char c[N][35];

void sol(char *s){for(int i=0;i<32;++i) if(!isalpha(s[i])) s[i]='z'+1;}
ull mkhash(char *s){
	ull res=0;
	for(int i=0;i<32;++i){
		if(isalpha(s[i])) res*=27,res+=s[i]-'a'+1;
		else return res;
	}
}

bool ED;
int main(){
	std::cerr<<(&ED-&ST)*1.0/1024.0/1024.0<<'\n'
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%s",b[i].s),b[i].id=ump[mkhash(b[i].s)]=i,sol(b[i].s);
	scanf("%d",&q);
	for(int i=1;i<=q;++i) scanf("%s",c[i]),pos[i]=ump[mkhash(c[i])];
	for(len=1;len<=30;++len){
		std::sort(b+1,b+1+n);
		memset(minp,0,sizeof minp);
		memset(p,0,sizeof p)
		for(int i=1;i<=n;++i){
			p[b[i].id]=i;
			minp[b[i].id]= cmp(b[i].s,b[i-1].s)==2 ? minp[b[i-1].id] : i;
		}
			
		for(int i=1,l,r;i<=q;++i){
			if(!isalpha(c[i][len-1])) continue;
			if(!pos[i]){
				for(int j=0;j<len;++j) tp.s[j]=c[i][j];
				sol(tp.s);
				tp.id=0,l=lrb(b+1,b+1+n,tp)-b;
				tp.id=n+1,r=lrb(b+1,b+1+n,tp)-b-1;
				ans[i]+=r-l+1;
			}else{
				ans[i]+=p[pos[i]]-minp[pos[i]]+1;
			} 
		}
	}
	for(int i=1;i<=q;++i) printf("%d\n",ans[i]+(pos[i] ? pos[i] : n));
	return 0;
}
```

时间复杂度为 $\mathcal{O}(\left|S\right| \cdot (N+Q \cdot \log N)) $ 跑得好慢。


---

## 作者：masterhuang (赞：1)

背景：校内模拟赛出过这题的弱化版，当时 **trie+unrodered_map** 这种大空间的东西都放过了，时间缩紧了，要求 $O(|\sum|)$ 。现在回来做这个卡空间的版本。
## 解法
把每个串都用 **'{'** 填充为长度 $30$ 的串（其他字符不知道能不能满足答案，**'{'** 的 **ASCII** 码比 **'z'** 大 $1$）。

把所有串按前 $1$ 位前缀，前 $2$ 位前缀，...，前 $30$ 位前缀排序。

对于所有和原来第 $j$ 个串前 $i$ 为前缀相同的串（包括自己），记录：这样的串的个数（直接求即可），记为 $f_{i,j}$；这样的串有多少个在 $j$ 前面（包括自己，用树状数组求），记为 $g_{i,j}$。

每次查询也像上面那样填充。先二分前 $30$ 位前缀判断给定串中等于查询串的串最小的位置（或报告没有）。

### 1.若给定串中有等于查询串的串。
设最小位置为 $x$，那么对于所有 $i$ 统计给定的串有多少个和查询串**恰有**前 $i$ 位都一样，且位置在 $x$ 前面。这个个数设为 $F_i$ 。则答案就是 $\sum\limits_{i=1}^{30} i\times F_i+x$。

刚才记录的 $g_{i,x}$ 表示有多少个串恰有前 $i,i+1,...,30$ 位与 $x$ 相同且位置 $\le j$。对 $g_{,x}$ 做差分（即 $g_{i,x}$ 减去 $g_{i+1,x}$）后 $g_{,x}$ 就是 $F$ 了。

有一个细节，设查询串大小为 $len$，这里第 $x$ 个串对答案的贡献变成了 $30$，因为我们填充了。把 $F_{len}$ 加上 $1$ ，$F_{30}$ 减 $1$ 为 $0$，然后统计答案即可，这里串长是**小于** $30$ 于是不会影响答案。 

### 2.若给定串中没有等于查询串的串。
对于所有 $i$ 二分前 $i$ 位前缀找出**任意一个**前 $i$ 位前缀和查询串相同的串，记这个位置为 $y$（没有的话就对答案没有贡献了），设 $u_{i}=f_{i,y}$。

把 $u$ 差分，把 $u_{len}$ 加上 $1$ ，$u_{30}$ 减 $1$ 为 $0$。同上能得到答案为：$\sum\limits_{i=1}^{30} i\times u_i+n$。直接统计即可。

复杂度 $O(n\log^2 n)$ (把 $30$ 视作与 $\log n$ 同阶)，空间是 $O(n)$，有 $30$ 倍常数。

丑陋的代码：
```cpp
#include<bits/stdc++.h>
#define P pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=3e4+5;
int n,m,t,b[35][N],c[35][N],tt[35],fir[N],d[N],e[35][N],ans,u[35],L,v[35][N];
char a[N][35],f[35];
vector<P>g;
inline int lb(int x){return x&-x;}
inline void add(int wz,int x){for(;wz<=n;wz+=lb(wz)) d[wz]+=x;}
inline int ask(int wz){int s=0;for(;wz;wz-=lb(wz)) s+=d[wz];return s;}
inline bool cmp(int x,int y){return a[x][t]<a[y][t];}
inline bool eq(char *A,char *B,int x)
{
	for(int i=0;i<=x;i++) if(A[i]!=B[i]) return 0;
	return 1;
}
inline bool xd(char *A,char *B,int x)
{
	for(int i=0;i<=x;i++)
	{
		if(A[i]<B[i]) return 1;
		if(A[i]>B[i]) return 0;
	}
	return 1;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",a[i]),t=strlen(a[i]);
		for(int j=t;j<30;j++) a[i][j]='{';
	}
	for(int i=1;i<=n;i++) b[0][i]=i;g.push_back({1,n});
	for(t=0;t<30;t++)
	{
		for(int i=1;i<=n;i++) b[t+1][i]=b[t][i];//只有b的t +1 
		for(P &i:g) sort(b[t+1]+i.fi,b[t+1]+i.se+1,cmp);
		for(int i=1;i<=n;i++)
		{
			if(i==1||!eq(a[b[t+1][i-1]],a[b[t+1][i]],t)) c[t][++tt[t]]++,fir[tt[t]]=i;
			else c[t][tt[t]]++;
		}g.clear();
		for(int i=1;i<=tt[t];i++) g.push_back({fir[i],fir[i]+c[t][i]-1});
		for(P &i:g)
		{
			for(int j=i.fi;j<=i.se;j++) add(b[t+1][j],1);
			for(int j=i.fi;j<=i.se;j++) e[t][b[t+1][j]]=ask(b[t+1][j]),v[t][b[t+1][j]]=i.se-i.fi+1;
			for(int j=i.fi;j<=i.se;j++) add(b[t+1][j],-1);
		}
	}
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s",f);L=strlen(f);for(int i=L;i<30;i++) f[i]='{';ans=0;
		int l=1,r=n,mid;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(xd(f,a[b[30][mid]],29)) r=mid-1,t=mid;
			else l=mid+1;
		}
		if(!eq(f,a[b[30][t]],29)) t=-1;memset(u,0,sizeof(u));
		if(t!=-1)
		{
			t=b[30][t];for(int i=0;i<30;i++) u[i]=e[i][t];
			for(int i=0;i<29;i++) u[i]-=u[i+1];u[L-1]+=u[29];u[29]=0;
			for(int i=0;i<30;i++) ans+=(i+1)*u[i];
			printf("%d\n",ans+t);
		}
		else
		{
			for(int i=0;i<30;i++)
			{
				int l=1,r=n,mid;
				while(l<=r)
				{
					mid=(l+r)>>1;
					if(xd(f,a[b[i+1][mid]],i)) r=mid-1,t=mid;
					else l=mid+1;
				}
				if(eq(f,a[b[i+1][t]],i)) t=b[i+1][t],u[i]=v[i][t];
				else break;
			}
			for(int i=0;i<29;i++) u[i]-=u[i+1];
			for(int i=0;i<30;i++) ans+=(i+1)*u[i];
			printf("%d\n",ans+n);
		}
	}
	return 0;
}
```

---

## 作者：Makab (赞：0)

是的没错，32 兆，Trie 照样跑。

## 题意

约定 $M$ 表示字符串长度的最值，$M < 30$。

按顺序给定 $N$ 个长度不大于 $M$ 的字符串 $T_{1 \sim N}$。

$Q$ 次询问，每次给定一个长度不大于 $M$ 的模式串 $P$，令 $P$ 于 $T$ 中首次出现的下标为 $p$（若不存在则取 $N$），求：

$$
p + \sum \limits_{i = 1}^{p} \operatorname{len}(\operatorname{LCP}(T_i, P))
$$

## 题解

求 $\operatorname{LCP}$，很自然地想到建 Trie 去搞。

对于每个 $T_i$，在插入时，将其在 Trie 上对应的链的每一个节点的 cnt 加一，并在链尾节点处统计精确匹配的答案，存至 cnt。

对于每个 $P$，在 Trie 上一直尝试向下一个字符对应的节点跳，并将答案加上其节点的 cnt；如果成功匹配到串末，则答案直接置为此节点的 cnt。

但，传统的 Trie 会 MLE（[我已经尽力了](https://www.luogu.com.cn/record/206374218)，最大的点要 $\approx 86 MB$）。

所以要创新要发展。使用类似前向星的方式存 Trie，这只会让时间复杂度增加 $O(\lvert \Sigma \rvert)$，而此时空间复杂度变为 $O(NM)$。

实际上跑得飞快，目前是[最优解](https://www.luogu.com.cn/record/206375808)，耗时小于第二的 $\frac{1}{2}$。

## 代码

```cpp
#include <bits/stdc++.h>

namespace SLV {
#define rep(i, st, ed) for (int i = (st), _##i = (ed); i <= _##i; ++i)
using namespace std;

constexpr int N = 30002, M = 32;

struct Node {
    char c;
    int cnt, head, nxt;
} ch[N * M];

int n, q, tot;
char s[M];

int insert(int u, char c) { // 在节点 u 处插入一个对应 c 的子节点
    ch[++tot].nxt = ch[u].head;
    ch[tot].c = c;
    return ch[u].head = tot;
}

int find(int u, char c) {   // 查询节点 u 是否有对应 c 的子节点
    for (int i = ch[u].head; i; i = ch[i].nxt) if (ch[i].c == c) return i;
    return 0;
}

int main() {
    scanf("%d", &n);
    rep(i, 1, n) {
        scanf("%s", s + 1);
        int sl = strlen(s + 1), u = 0, v = ++ch[0].cnt, t;
        rep(j, 1, sl) {
            if (!(t = find(u, s[j]))) t = insert(u, s[j]);
            u = t;
            ++ch[u].cnt;
            v += ch[u].cnt;
        }
        ch[insert(u, '%')].cnt = v; // 插入结束符并统计答案
    }
    scanf("%d", &q);
    rep(i, 1, q) {
        scanf("%s", s + 1);
        int sl = strlen(s + 1), j = 1, u = 0, ans = ch[0].cnt, t = find(u, s[j]);
        s[++sl] = '%';
        for (; j <= sl && t; u = t, ++j, t = find(u, s[j]), ans += ch[u].cnt);
        printf("%d\n", ((j <= sl) ? ans : ch[u].cnt));
    }
    return 0;
}
} // namespace SLV

int main() { return SLV::main(); }
```

---


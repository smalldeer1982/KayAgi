# [✗✓OI R1] 左方之地

## 题目背景


后记中将会详细描述帅神左方之地为何能成为「魔禁六帅」之首。

如果你很奇怪题目名称里面为什么没有前方之风，那你可能应该去看看 div.2。

但在此之前，你需要做一道构造题。


## 题目描述

给你一个自然数 $n$ 和一个自然数参数 $k$，你需要构造一个长度为 $2^n$ 的序列 $a$，满足 $[0,2^n)$ 间的所有整数恰好出现一次，并且 $\forall i\in[2,2^n]$，$\operatorname{popcount}(a_i \oplus a_{i-1})=k$。  
其中 $\operatorname{popcount}(x)$ 表示 $x$ 在二进制下 $1$ 的个数，$\oplus$ 表示[按位异或](https://oi-wiki.org/math/bit/#_1)运算。

若有解则输出 `1` 并输出这个序列，否则输出 `0`。

## 说明/提示

**本题采用 Special Judge，子任务评测**。

对于 $100\%$ 的数据，保证 $1\le n, k \le 20$。

| 子任务编号 | $n$     | $k$     | 子任务总分 |依赖子任务|
| :--------: | :-----: | :-----: | :-------: | :-------: |
| 0   | $\le 4$ | $\le 4$ | 5        ||
| 1   | $\le 8$ | $\le 8$ | 25       |Subtask 0|
| 2   |         | $=1$    | 10       ||
| 3   |  | $=n-1$  | 15       ||
| 4   |         |         | 45       |Subtask 0~3|


![](https://cdn.luogu.com.cn/upload/image_hosting/lipqunc4.png)

## 样例 #1

### 输入

```
4 3```

### 输出

```
1
0 14 3 13 6 8 5 11 12 2 15 1 10 4 9 7```

## 样例 #2

### 输入

```
4 2```

### 输出

```
0```

# 题解

## 作者：zimujun (赞：28)

由线性基的相关知识可知，只要能够在 $[0, 2^n)\cap \mathbb Z$ 中找到 $n$ 个在异或运算下线性无关的数，那么这所有的 $2^n$ 个数都能通过这些数互相异或表示出来，称这 $n$ 个数为基底。

在本题中，只要选取所有满足 $\operatorname{popcount(x)} = k$ 的数插入线性基，记录所有成功插入的数和成功插入的数作为基底，若成功插入的数小于 $n$ 个则无解。

另一个问题，为了保证相邻两个数只有一个基底的差异，使用格雷码（相邻两数只有一位的差异）表示每个基底存在的状态即可。

时间复杂度 $O(n \log n)$。

---

## 作者：VinstaG173 (赞：16)

感觉不是很简单的结论+构造题。讲讲我的做法。

首先 $k$ 为偶数时容易发现满足异或值要求的序列中所有元素的 $\operatorname{popcount}$ 必然奇偶性相同，故不可能构成排列。另外 $n \le k$ 且 $n>1$ 时显然也无法构造满足要求的排列。

然后大胆猜测其他情况都可以。尝试构造。看着一脸格雷码加强版的长相。所以感觉做法和格雷码差不多。

~~那格雷码 `k^(k>>1)` 这个题是不是就随便异或一下就完啦~~

也许可以，但是我不行，我做不到。

那怎么个差不多法呢？我们回想 CSPS2019 D1T1 格雷码题面里描述的格雷码构造方法。

> 1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
> 2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
> 3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。  
> 综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

容易发现事实上我们可以看作将 $n$ 位格雷码前面补 $0$ 后最高 $1$ 位取反再翻转接在后面形成 $n+1$ 位格雷码。格雷码满足的条件是相邻数二进制差 $1$ 位。推广到差 $k$ 位，我们是不是只要把最高 $k$ 位取反再翻转就可以了呢？

我们非常开心地发现，这是正确的。证明也很简单，由于 $0 \sim 2^n-1$ 的排列二进制前 $k-1$ 位取反后仍然得到 $0 \sim 2^n-1$ 的排列，而两个这样的排列分别加上最高位 $0,1$ 各一次，故形成的确实是一个 $0 \sim 2^{n+1}-1$ 的排列。

然后由于前后两半之内相差位数是对应相同的，由归纳假设均相差 $k$ 位，中间接口处由定义恰相差前 $k$ 位。所以相邻数确实相差恰好 $k$ 位。

现在我们还剩下最后一个问题，就是边界（或者说归纳奠基）。根据刚才的分析，我们现在的任务是 $n=k+1$。下面给出我的构造方法。

容易发现此时的要求是相邻两数二进制只有一位相同。我们考虑找出这个相同位。

事实上，当第 $x$ 与第 $x+1$ 个数的相同位为 $\operatorname{lowbit}(x)$ 时整个序列能够构成一个排列。

这是我的第一个想法。而在我试图证明它的时候，我发现了一件事。它的本质就是对格雷码的奇数下标位置整体取反（下标从 $0$ 开始）。这是因为不同位为 $\operatorname{lowbit}(x)$ 时构造出来的东西就是格雷码，再回顾上面的过程会发现这是显然的。又由于此时 $k$ 为奇数，故 $n$ 为偶数，所以取反前奇数位下标取遍所有 $\operatorname{popcount}$ 为奇数的值，取反后仍然如此。

这时就得到了 AC 代码：
```cpp
#include<cstdio>
#define rg register
int n,m,k,l,s;
int ans[1048576];
inline void solve(int x)
{
	if(x==k+1)
	{
		m=1<<x;
		for(rg int i=1;i<m;++i)
		{
			ans[i]=i^(i>>1);
			(i&1)&&(ans[i]^=m-1);
		}
		return;
	}
	solve(x-1),m=1<<(x-1),l=m<<1,s=((1<<k)-1)<<(x-k);
	for(rg int i=0;i<m;++i)ans[i^(l-1)]=ans[i]^s;
}
int main()
{
	scanf(" %d %d",&n,&k);
	if(n==1&&k==1)return puts("1"),puts("0 1"),0;
	if(!(k&1)||n<=k)return puts("0"),0;
	puts("1"),solve(n),l=1<<n;
	for(rg int i=0;i<l;++i)printf("%d ",ans[i]);
	return 0;
}
```

但是这已经是一堆东西随便异或一下就出来了。事实上应该有更简单的形式但是我懒得搞了。

~~所以我又行了（？）~~

---

## 作者：Rubidium_Chloride (赞：9)

## $\mathcal{Sequence\ Solution}$

事实上是 左方之地 $\mathcal{Solution}$。

出题人题解。

好像出屑了。

---

简化版题意：

给定 $n,k$，求将 $0,1,2\dots 2^n-1$ 排成一排，使得对任意两个相邻的数 $a,b$，满足 $\operatorname{popcount}(a\operatorname{xor}b)=k$。

其中 $\operatorname{popcount}(x)$ 的定义为 $x$ 的二进制表示中值为 $1$ 的位数。


---

好像不需要了，已经简化过了。

暴力 `dfs` 是必然能过的，这里理论上应该给一个复杂度证明。

首先你可以判断一下有无解。（见下）

然后考虑一下，大概是不会回溯的，，，

然后预处理一下就 done 了。

---

简略证法如上。

然后现在好像我不会给特别严谨的证明，，，

如果有牛逼老哥证出来了可以私信/评论我，，，

---

大概是来自 @shenmadongdong 的证明思路，RC尝试详细化了一下：

考虑构造一张无向图，每个点的出度是 $\dbinom{n}{k}$。

然后相当于求一条 $\mathcal{Hamilton}$ 路。

~~然后不会了。~~

---

~~鉴于不会上面的证明~~，接下来考虑一个不是啥爆搜，直接构造，复杂度必然正确的方法。

类似格雷码。

首先考虑一些特殊的情况。

$n=0$，无论 $k$ 怎样都可以成立。 

$n=1$，当且仅当 $k=1$ 时可以成立，其他都不可以成立。

接下来不妨设 $n\ge 2$。

尝试考虑证明有解等价于 $n\ge k+1$ 且 $k\bmod 2=1$。

首先，显然的，$n\le k$ 时无解。（最多仅能达到 $2$ 个数）

接下来考虑 $k\bmod 2=0$ 时的情况。

引理 $1$：长为 $n$ 的二进制串中 $1$ 个数为奇数/偶数的串的个数相等。

相关证明方法可以自己查询，由于结论比较简单此处不再赘述。

对于任意的 $a$，其下一位数都只会更改偶数个二进制位的值，因此可以得到所有项的二进制位 $1$ 的个数均与首项相同，由引理 $1$ 知矛盾。

接下来证 $n\ge k+1$ 且 $k\bmod 2=1$ 时一定有解。

先考虑 $n=k+1$ 时的情况。

先构造出一组 格雷码 $b_1,b_2\dots b_{2^n}$，可得 $\operatorname{popcount}(b_i\operatorname{xor}b_{i+1})=1(i=1,2\dots 2^n-1)$。

然后我们将 $b_j(j\bmod 2=0)$ 这些项全部反转（即，异或上 $2^n-1$）。

由于 $b_2,b_4\dots b_{2^{n}}$ 的 $\operatorname{popcount}$ 的奇偶性全部相同，且反转之前两两不同，可以得知反转后两两不同，且此时的 $b_i$ 满足：$\operatorname{popcount}(b_i\operatorname{xor}b_{i+1})=k(i=1,2\dots 2^n-1)$。

设这样得到的序列为 $a_1,a_2\dots a_{2^n}$。

接下来考虑如下的序列：$c_1,c_2,c_3\dots c_{2^n}$，满足 $c_i=a_i\operatorname{xor}(2^n+2^{k-1}-1)$。

可以显然地知道 $\operatorname{popcount}(c_i\operatorname{xor}c_{i+1})=k(i=1,2\dots 2^n-1)$。

同时，$c_i$ 和 $a_i$ 不重复，且两个数列一起构成了 $0,1\dots 2^{n+1}-1$ 的排列。

同时，$\operatorname{popcount}(c_{2^n}\operatorname{xor}a_{2^n}=k)$。

因此可以将 $a,c$ 两个序列按照 $a$ 正序，$c$ 倒序的顺序拼接起来，就得到了 $n+1$ 时的解。

综上，原命题得证。

代码就不放了。

---

## 作者：I_am_Accepted (赞：7)

### Preface

比较形式化的题解。

### Analysis

同题 [arc138_d](https://atcoder.jp/contests/arc138/tasks/arc138_d)，建议先看 [P5657 [CSP-S2019] 格雷码](https://www.luogu.com.cn/problem/P5657)。

以下 $\text{popcnt}(x)$ 表示 $x$ 在二进制下 $1$ 位的个数，$A+B$ 表示字符串拼接。

先判无解，$n\le k$ 无解。而且 $k \bmod 2=0$ 也无解，因为若每次将偶数个位置 $01$ 互换，则每个数 $\text{popcnt}$ 必然奇偶性相同，必然有些数取不到。

~~打表可知~~接下来构造证明这是充要条件。

由于正常的格雷码相邻两数正好相差 $1$ 个二进制位，所以我们引出「$k$ 格雷」表示相邻两数正好相差 $k$ 位的格雷码序列。

我们记 $s(n,k)$ 表示一种 $n$ 位「$k$ 格雷」序列。

$f(\{a\},x)$ 表示将 $\{a\}$ 中每个元素都 $\text{xor}$ 上 $x$ 后得到的序列。

$rev(\{a\})$ 表示将 $\{a\}$ 序列翻转（reverse）后的序列。

$sort(\{a\})$ 表示将 $\{a\}$ 序列升序排序后的序列。

------------

**结论 A：**

$$\text{popcnt}(a\ \text{xor}\ b)=\text{popcnt}((a\ \text{xor}\ x)\ \text{xor}\ (b\ \text{xor}\ x))$$

非常显然。

**结论 B：**

$$A=\{0,1,\dots,2^n-1\}$$

$$\forall 0\le x<2^n,sort(f(A,x))=A$$

非常显然。


------------


所以对于 $n\ge k+2$，我们有（有点长 认真看 qwq）：

$$s(n,k)=s(n-1,k)+f(rev(s(n-1,k)),2^{n-k}(2^k-1))$$

接下来我们只需要考虑如何构造 $s(n,n-1)(n \bmod 2=0)$。

$$a_i=\begin{cases}
i\ \text{xor}\ \frac{i}{2} &i\bmod 2=0
\\
i\ \text{xor}\ \frac{i-1}{2}\ \text{xor}\ (2^n-1) &i\bmod 2=1
\end{cases}$$

即为构造（下标从 $0$ 开始）。

其实主要用到了 $\text{low}(x)$ 的性质（就是树状数组里的那个）。

**证明：**

对于 $i\ \bmod\ 2=0$：

$$a_i\ \text{xor}\ a_{i+1}=i\ \text{xor}\ (i+1)\ \text{xor}\ (2^n-1)=1\ \text{xor}\ (2^n-1)$$

对于 $i\ \bmod\ 2=1$：

$$\begin{aligned}
a_i\ \text{xor}\ a_{i+1}&=
i\ \text{xor}\ (i+1)\ \text{xor}\ \frac{i-1}{2}\ \text{xor}\ \frac{i+1}{2}\ \text{xor}\ (2^n-1)
\\
&=
(2\text{low}(i+1)-1)\ \text{xor}\ (\text{low}(i+1)-1)\ \text{xor}\ (2^n-1)
\\
&=
(2\text{low}(i+1)-1)\ \text{xor}\ (\text{low}(i+1)-1)\ \text{xor}\ (2^n-1)
\\
&=
\text{low}(i+1)\ \text{xor}\ (2^n-1)
\end{aligned}$$

$\blacksquare$

### Code

```cpp
//Said no more counting dollars. We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)
#define N (1<<20)
int a[N];
void solve(int n,int k){
	int len=1<<n;
	if(n==k+1){
		For(i,0,len-1)
			if(i&1) a[i]=i^(i>>1)^(len-1);
			else a[i]=i^(i>>1);
		return ;
	}
	solve(n-1,k);
	int pos=1<<(n-1),val=(1<<n)-(1<<(n-k));
	For(i,pos,len-1) a[i]=a[--pos]^val;
}
signed main(){
	int n,k,len;
	scanf("%d%d",&n,&k);
	len=1<<n;
	if(n==1 && k==1){puts("1\n0 1");return 0;}
	if(n<=k || !(k&1)){puts("0");return 0;}
	puts("1");
	solve(n,k);
	For(i,0,len-1) printf("%d ",a[i]);
return 0;}
```


---

## 作者：2022_37_yzyUUU (赞：6)

# 题解：P7949 [✗✓OI R1] 左方之地

## 思路

令数列的第一项为 $0$，二进制显然是 $n$ 个零，然后两个数异或值为 $k$ 大概就是那两个数在二进制下有 $k$ 位不同。

然后每一个项只需要把前面的那一项的二进制随便挑选 $k$ 位反过来就可以了，这个可以深搜解决。

然后复杂度大概是 $O(2^n \times C_n^k)$，大概最坏是 $1048576 \times 184756 $ 约等于 $ 1.9 \times 10^{11}$ 的时间。

看似跑不过去，但是这个题数据水，发现 $n$ 选 $k$ 时如果 $k$ 比 $n-k$ 还要大的时候就不如直接选 $n-k$ 了。

然后注意一下循环顺序就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
int n,k;
int p,q;
int v[1050006],a[21];
bool vis[1050006];
string an;
inline int num(string a) {
	int res=0,m=1;
	for(int i=a.size()-1; i>=0; i--) {
		if(a[i]=='1')res+=m;
		m*=2;
	}
	return res;
}
int f;
void dfs(int t,int s) {
	if(f)return;
	if(s==k) {
		string ss=an;
		for(int i=0; i<n; i++) {
//			cout<<a[i+1]<<" ";
			if(a[i+1]!=q) {
				ss[i]=(!(ss[i]-'0'))+'0';
			}
		}
//			cout<<"\n";
		int w=num(ss);
		if(vis[w]==0) {
			vis[w]=1;
			an=ss;
			f=1;
		}
		return;
	}
	if(q) {
		for(int i=t; i<=n; i++) {
			if(f)return;
			if(a[i]==1)continue;
			a[i]=1;
			dfs(t+1,s+1);
			a[i]=0;
		}
	} else {
		for(int i=n; i>=t; i--) {
			if(f)return;
			if(a[i]==1)continue;
			a[i]=1;
			dfs(t+1,s+1);
			a[i]=0;
		}
	}

}


signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
//	cout<<(13^1);
	cin>>n>>k;
	if(n-k<k) {
		q=1;
		k=n-k;
	}
	p=(1<<n);
	for(int i=1; i<=n; i++)an+='0';
	vis[0]=1;
	v[1]=0;
	for(int i=2; i<=p; i++) {
		f=0;
		dfs(1,0);
		if(f==0) {
			cout<<0;
			return 0;
		}
		v[i]=num(an);
//		cout<<an<<" ";
	}
//	cout<"\n";
	cout<<1<<"\n";
	for(int i=1; i<=p; i++)cout<<v[i]<<" ";
}
//0000 0111 1001 1110
```

可能时间复杂度那里是我瞎说的。

---

## 作者：laboba (赞：2)

并不记得格雷码是啥了www 于是有了一个奇怪的神必做法，阳间做法在最后面。

首先 $2|k$ 显然是无解的，奇偶分析即可。

不妨设 $S=\{ x|x\in [0,2^n-1],popcount(x)=k\}$，
设 $a_i \oplus a_{i-1}=x_i$，则原题等价于构造一组 $x_i\in S$，使得 $x_i$ 的异或前缀和即 $a_i$ 互不相同，异或前缀和互不相同又等价于子序列异或和均不为 $0$。

观察样例，写出其对应的 $x$：$1110,1101,1110,1011,1110,1101,1110,0111,1110,1101,1110,1011,1110,1101,1110$ 发现它有一个很神奇的规律，模 $2$ 余 $1$、模 $4$ 余 $2$、模 $8$ 余 $4$ 的位置填的都是相同的数，也可以理解为将每次将奇数位填上同一个数，再递归填偶数位。这种填法有一个很神奇的性质，首先对于长度为 $2^n-1$ 的序列它只出现了 $n$ 个不相同的数，更重要的是它不存在一个子序列满足其中每个数都出现偶数次，这个手玩一下可以发现是正确的，证明后面尝试给出。有了这个性质，我们可以求出 $S$ 的一组线性基，而线性基大小刚好是 $n$，可以将这 $n$ 个数按这种方式填入得到序列 $x$，因为线性基任意非空子集异或和均非 $0$，所以 $x$ 不存在异或和为 $0$ 的子序列，求异或前缀和即可得到 $a$。

证明：设序列长度为 $2^n-1$，考虑长度为 $l$ 的子序列，若 $l>=2^{n-1}$，则该子序列必定包含 $2^{n-1}$ 位置的数，由序列的生成方法知道这个数只出现了一次，所以该子序列满足我们要的性质。若 $l<2^{n-1}$ 且不包含位置 $2^{n-1}$，因为原序列 $[1,2^{n-1}-1]$ 和 $[2^{n-1}+1,2^n-1]$ 的部分同样满足该生成方法，于是归纳可得证。

然后这题撞题ARC138了www，这里也简要给一个AT和大部分题解的做法：求出长度为 $2^n$ 的格雷码（相邻两数二进制表示只有一位不同），也即此题 $k=1$ 时的情况，然后将取 $S$ 的一个线性基设为 $b_0,b_1...b_{n-1}$，则 $a_i=b_{t_1}\oplus b_{t_2}...$，其中 $t$ 为格雷码第 $i$ 项二进制表示下为一的所有位置。正确性显然，相邻两项异或值为 $b$ 的某一项，线性基任意子集异或和互不相同。

有没有神仙能指出两个做法是否本质相同啊/se/se

---


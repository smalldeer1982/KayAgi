# [COCI 2014/2015 #6] WTF

## 题目描述

你有一个长度为 $n$ 的数组 $\textbf A$，一个值域为 $[1,n-1]$ 的长度为 $n+1$ 的数组 $\textbf{ID}$ 和一个整数 $r$。

我们通过以下伪代码对数组 $\textbf A$ 进行 Warshall-Turing-Fourier 变换 $^\textsf{[1]}$：

```cpp
sum = 0
for i = 1 to n
	index = min{ID[i], ID[i+1]}
	sum = sum + A[index]
	Rorate(A, r)
Change(A)
for i = 1 to n
	index = max{ID[i], ID[i+1]}
	index = index + 1
	sum = sum + A[index]
	Rorate(A, r)
```

其中：
- $\texttt{Change}(\textbf A)$ 表示把数组 $\textbf A$ 中所有元素分别改成它们的相反数。
- $\texttt{Rorate}(\textbf A,r)$ 表示把数组 $\textbf A$ 复制两遍得到数组 $\textbf B$，取 $\textbf B[n-r+1,2n-r]$ 代替数组 $\textbf A$。\
  即**向右旋转** $R$ 个位置。

你已经知道数组 $\textbf A$ 和整数 $r$，但你并不知道数组 $\textbf{ID}$。

你需要求出 WTF 变换后伪代码中 $\text{sum}$ 可能的最大值。

$\textsf{[1]}$：实际上并不存在，当然也可以叫做「Sept 变换」。

## 说明/提示

#### 判分方式

如果输出只有第一行正确，可以得到 $50\%$ 的分数。

**但你必须保证第二行有 $\bm{n+1}$ 个符合要求的数。**

#### 数据规模与约定

**本题采用 Special Judge。**

- 对于 $20\%$ 的数据，有 $n\le 7$。
- 对于 $60\%$ 的数据，有 $n\le 300$。
- 对于 $100\%$ 的数据，有 $2\le n\le 3\times 10^3$，$1\le r\le n$，$\textbf A[i]\in[-10^4,10^4]$。

你需要保证你构造的 $\textbf{ID}[i]\in[1,n-1]$。

#### 说明

按原题配置，满分 160 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task F _**WTF**_。

## 样例 #1

### 输入

```
5 3
1 -1 1 -1 1```

### 输出

```
10
1 1 1 2 2 3```

## 样例 #2

### 输入

```
6 5
2 5 4 1 3 5```

### 输出

```
16
3 2 1 1 5 4 1```

# 题解

## 作者：Jeefy (赞：2)

# P7959 [COCI2014-2015#6] WTF 题解

> 呃，是一道 DP 题

说实话，原题实际上是不要输出一种方法的……但是似乎放这道题的人想增加一点难度？

这里有两种做法，但都是 DP。

## 预备观察

我们首先观察一些性质，以方便解题。

- **循环不变**：我们可以观察到，在 $n$ 次变换后，序列会还原。也就是说，两个循环在同一个 $i$ 上操作的序列是一样的。

- **下标大小**：其实可以看到，下标是一大一小，也就是 $\min(ID_{i}, \mathit{ID}_{i+1})$ 和 $\max(ID_{i}, ID_{i + 1})+1$。意味着我们在 $ID_{i}$ 的选择关于，且仅关于 $ID_{i - 1}$ 的选择。所以考虑 DP 转移。

- **连续性**：不难发现，其实选择是这么一些边：$(ID_{i}, ID_{i + 1})$ 和 $(ID_{i + 1}, ID_{i + 2})$，也就是说每一个状态是相关联的。

接下来就可以开始正式解题了。

> 感觉上面讲的都是废话

## 解法1：强行 DP

> 这也是我拿到这一道题的第一想法……也是正解的一种吧

在观察出来下标大小的关系之后，其实就可以设一个 DP 了。

令 $f_{i,j}$ 表示在 $ID_{i + 1}$ 选 $j$ 所能取到的最大值。

于是可以有这么一个转移方程：

$$
f_{i,j} = \max_{k=1}^{n-1}(f_{i-1,k} + A_{\min(j, k)} - A_{\max(j,k) + 1})
$$

> $k$ 上界为 $n - 1$，这是题面中要求了的。
> 
> 包括 $j$ 其实也 $\in [1, n-1]$

所以就有一个 $O(n^3)$ 的写法了。

但是很明显，必须优化到 $O(n^2)$ 才能过。

我们把 $\min \max$ 拆开：

$$
\begin{aligned}
f_{i,j} = \max&( A_{j} + \max_{k = j}^{n - 1}(f_{i-1, k} - A_{k+1}), \\
    &-A_{j+1} + \max_{k = 1}^{j}(f_{i-1,k} + A_{k}))
\end{aligned}
$$

> 其实内部关于 $j$ 的边界并没有那么重要

很明显，后面两个部分可以通过前后缀 $\max$ 搞定。于是我们可以在 $O(1)$ 内转移。

总时间复杂度成功变为 $O(n^2)$。

不过还要注意一个点，**每一次转移的时候，需要手动模拟一次 `Rotate(n, r)`。**

那么**核心代码**如下：

```cpp
pre[0] = suf[n] = -1e9;
for (i = 1; i <= n; ++i, rotate()) {
    // prefix k
    for (k = 1; k < n; ++k) {
        // pre[k] = max(pre[k - 1], f[i - 1][k] + A[k]);
        if (pre[k - 1] >= f[i - 1][k] + A[k]) {
            pre[k] = pre[k - 1];
            pref[k] = pref[k - 1];
        } else {
            pre[k] = f[i - 1][k] + A[k];
            pref[k] = k;
        }
    }

    // suffix k
    for (k = n - 1; k; --k) {
        // suf[k] = max(suf[k + 1], f[i - 1][k] - A[k + 1]);
        if (suf[k + 1] >= f[i - 1][k] - A[k + 1]) {
            suf[k] = suf[k + 1];
            suff[k] = suff[k + 1];
        } else {
            suf[k] = f[i - 1][k] - A[k + 1];
            suff[k] = k;
        }
    }

    for (j = 1; j < n; ++j) { // enum cur ID[i + 1]
        int p = pre[j] - A[j + 1], s = suf[j] + A[j];
        if (p >= s) {
            f[i][j] = p;
            trans[i][j] = pref[j];
        } else {
            f[i][j] = s;
            trans[i][j] = suff[j];
        }
    }
}
```

最后通过 `trans` 数组输出方案即可。

> 不过说实话，这个空间复杂度确实不够优秀。

## 做法2：std 做法

其实可以发现，对于每一个 $i$，设

$$
id_1 = \min(ID_{i}, ID_{i + 1}), id_2 = \min(ID_{i}, ID_{i + 1})
$$

于是有 $sum = \sum_{i = 1}^n A_{id_1} -A_{id_2 + 1}$。

这似乎提醒这我们做一个前缀差分。

于是我们设 $b_{i} = A_{i + 1} - A_{i}$。

所以可以得到 $A_{id_2 + 1} - A_{id_1} = \sum_{i = id_1}^{id_2} b_{i}$。

原本我们需要最大化，那么此时，我们需要最小化 $A_{id_2 + 1} - A_{id_1}$。

**不过，如果我们把初始的 $A$ 序列全部取反，那么我们还是需要最大化上面这个式子。**

**贴出的代码中也做了如上操作。**

> 注意加减顺序。以及 $b$ 只有 $n-1$ 个元素。

于是我们可以构建出一个 $(n-1) \times n$ 的矩阵 $B$，其中每一行是对应旋转后的 $A$ 的差分序列。

我们在寻找 $sum$ 的过程，其实就是把所有路径上的 $b$ 加起来，于是，问题转化为寻找在 $B$ 上的一条最短路径。

不过，由于我们只能向下，或者左右走，并且不能重复走，所以也考虑 DP。

设 $f_{i, j, k}$ 表示，走到 $(i, j)$ 这个位置，来的方向是 $k$，的**最长**路径。

> $k \in [0, 3)$，分别表示从上面转移，从右侧转移，从左侧转移。
> 
> 或者可以说是向下走，向右走，向左走转移（代码中的意义）。

于是有如下方程：

$$
\begin{aligned}
f_{i, j, 0} &= \max(f_{i-1, j, 0/1/2}) + B_{i,j} \\
f_{i, j, 1} &= \max(f_{i, j+1, 0/1}) + B_{i, j} \\
f_{i, j, 2} &= \max(f_{i, j-1, 0/2}) + B_{i, j}
\end{aligned}
$$

记录一下转移来的路径，在拐点的地方输出即可。

> 为了偷懒，就直接贴出不记录路径的代码了。

总时间复杂度 $O(n^2)$：

```cpp
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 3003, MINUS_INF = -1e9;

int a[N][N];
int b[N][N];
int dp[N][N][3];

#define DOWN 0
#define LEFT 1
#define RIGHT 2

// 三个方向选其优
int best(int i, int j) {
    return max(dp[i][j][DOWN],
            max(dp[i][j][LEFT], dp[i][j][RIGHT]));
}

int main () {
    int n, r;
    cin >> n >> r;

    // 注意整个程序的下标是从 0 开始
    // 也就是 [0, n) 而非 [1, n]
    for (int i = 0; i < n; ++i) {
        cin >> a[0][i];
        a[0][i] *= -1;
        int position = i;
        // 构建旋转后的序列
        for (int j = 1; j < n; ++j) {
            position = (position + r) % n;
            a[j][position] = a[0][i];
           
        }
    }

    // 初始化dp表
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n - 1; ++j) {
            // 构建差分序列
            b[i][j] = a[i][j + 1] - a[i][j];

            for (int k = 0; k < 3; ++k)
                dp[i][j][k] = MINUS_INF;
        }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n - 1; ++j) {
            // 处理从上一行的转移
            dp[i][j][DOWN] = b[i][j] + (i > 0 ? best(i - 1, j) : 0);

            // 处理从左边转移
            if (j > 0)
                dp[i][j][RIGHT] = b[i][j] +
                    max(dp[i][j - 1][DOWN], dp[i][j - 1][RIGHT]);
        }

        // 反着来一次从右边的转移
        for (int j = n - 3; j >= 0; --j)
            dp[i][j][LEFT] = b[i][j] +
                max(dp[i][j + 1][DOWN], dp[i][j + 1][LEFT]);
    }

    // 输出最终的答案
    int sol = MINUS_INF;
    for (int j = 0; j < n - 1; ++j)
        sol = max(sol, best(n - 1, j));
    cout << sol << endl;
}
```


---

## 作者：xiaoxiaoxia (赞：1)

## 题目大意
翻译的基本题面就不多说了，我们来大概分析一下题目。
- 序列会变回来：我们可以观察到，在 $n$ 次变换后，序列会还原。也就是说，两个循环在同一个 $i$ 上操作的序列是一样的。
- 下标的空间：然后我们再分析一下不难发现，下标是一大一小，也就是 $\min\left(ID_{i},ID_{i+1}\right)$ 和 $\min\left(ID_{i},ID_{i+1}\right)+1$，所以我们求 $ID_i$ 时，去求 $ID_{i-1}$ 就好了。聪明的小朋友想到动态规划了，那么再找找。
- 连续性：再找一找就可以发现就是选择一些边，那么就可以知道状态之间是关联的。
## 思路概述
经过了上面的思考，我们就不难可以发现，这道题肯定用动态规划。我总结了两种方法供大家食用：
### 强行 dp
这种思路是我一开始想出来的，其实挺好设的。我们就设 $f_{i,j}$ 表示在 $i$ 的时候选 $j$ 所能取到的最大贡献，所以我们就可以得到一个转移方程。
$$
f_{i,j}=\max_{k=1}^{n-1}\left(f_{i-1,k}+A_{\min\left(j,k\right)}-A_{\max\left(j,k\right)}+1\right)
$$
但是肯定有同学一眼丁真，发现时间复杂度太大了，所以我们优化成这个样子：
$$
f_{i,j}=\max\left(A_j+\max_{k=j}^{n-1}\left(f_{i-1,k}-A_{k+1}\right)-A_{j+1}+\max_{k=1}^{j}\left(f_{i-1,k}+A_{k}\right)\right)
$$
然后后面的东西我们可以使用前缀或者是后缀和搞定。然后我们上一下核心代码：
 ```cpp
pre[0]=suf[n]=-1e9;
for(i=1;i<=n;++i,solve()){
	for(k=1;k<n;++k){
		if(pre[k-1]>=f[i-1][k]+A[k]){
			pre[k]=pre[k-1];
			pref[k]=pref[k-1];
		}else{
			pre[k]=f[i-1][k]+A[k];
			pref[k]=k;
		}
	}
	for(k=n-1;k;--k){
		if(suf[k+1]>=f[i-1][k]-A[k+1]){
			suf[k]=suf[k+1];
			suff[k]=suff[k+1];
		}else{
			suf[k]=f[i-1][k]-A[k+1];
			suff[k]=k;
		}
	}
	for(j=1;j<n;++j){
		int p=pre[j]-A[j+1],s=suf[j]+A[j];
		if(p>=s){
			f[i][j]=p;
			trans[i][j]=pref[j];
		}else{
			f[i][j]=s;
			trans[i][j]=suff[j];
		}
	}
}
```
但是，这个空间复杂度不够优秀，所以我们再换一种。
### 正解
那么我们可以对于每一个 $i$ ，我们可以设
$$
id_1=\min(ID_i,ID_{i+1}),id2=min(ID_i,ID_{i+1})
$$
所以，我们就可以得到 $sum=A_{id_i}-A_{id_2+1}$。
同时，这也让我们想到了差分这件事情，所以我们可以构建出一个 $\left(n-1\right)\times n$ 的矩阵，每一行都是旋转后记录的差分数组。但是动态规划的数组怎么设计呢？其实很简单，设 $f_{i,j,k}$ 表示走到了 $\left(i,j\right)$ 这个位置的时候，方向是 $k$ 的最长路径，所以就有如下的转移方程。
$$
f_{i,j,0}=\max\left(f_{i-1,j,0/1/2}+B_{i,j}\right)
f_{i,j,1}=\max\left(f_{i,j+1,0/1}+B_{i,j}\right)
f_{i,j,2}=\max\left(f_{i,j-1,0/2}+B_{i,j}\right)
$$
代码就不贴了。

---

## 作者：qwer6 (赞：0)

## 1. Description

原题面已经较为清晰，这里不过多赘述。

## 2. Solution

显然，两个循环的贡献可以在一个询问中直接进行计算，那么当我们枚举 $i$ 的时候，贡献只和 $id_i$ 和 $id_{i+1}$ 有关，显然我们在 $i$ 这个位置填什么数除了对 $i$ 和 $i+1$ 有影响，对其他位置没有影响，所以我们考虑直接 DP，定义 $f_{i,j}$ 表示 $id_i=j$ 的最大收益，那么 $f_{i,j}=\max(f_{i-1,k}+A_{i-1,\min(j,k)}-A_{i-1,\max(j,k)+1})$，$A_{i,j}$  表示原数组移动了 $i$ 次后，$j$ 这个位置上的值。

那么对式子略作修改则有 $f_{i,j}=\max(\max_{k=1}^j(f_{i-1,k}+A_{i-1,k}-A_{i-1,j+1},\max_{k=j}^{n-1}(f_{i-1,k}-A_{i-1,k+1}+A_{i-1,j}))$。

显然两个部分可以使用前缀最值和后缀最值优化转移，时间复杂度为 $O(n^2)$。

这道题虽然说要输出方案，但是不用输出方案就可以过了，输出方案的话，记一下从哪里转移的即可。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=3005;
int n,R,ans;
int a[N]，f[N][N]，g[N],h[N];
signed main(){
	read(n),read(R);
	for(int i=0;i<n;i++)read(a[i]);
	memset(f,-0x3f,sizeof(f));
	for(int i=0;i<=n-2;i++)f[1][i]=0;
	for(int i=2;i<=n+1;i++){
		for(int j=0;j<=n-2;j++){
			g[j]=f[i-1][j]+a[(j-R*(i-2)%n+n)%n];
			h[j]=f[i-1][j]-a[(j+1-R*(i-2)%n+n)%n];
		}
		for(int j=1;j<=n-2;j++)tomax(g[j],g[j-1]);
		for(int j=n-3;j>=0;j--)tomax(h[j],h[j+1]);
		for(int j=0;j<=n-2;j++)
			f[i][j]=max(g[j]-a[(j+1-R*(i-2)%n+n)%n],h[j]+a[(j-R*(i-2)%n+n)%n]);
		
	}
	for(int i=0;i<=n-2;i++)
		tomax(ans,f[n+1][i]);
	write(ans),Nxt;
}
```

---


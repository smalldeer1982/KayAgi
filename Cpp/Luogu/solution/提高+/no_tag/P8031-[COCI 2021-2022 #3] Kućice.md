# [COCI 2021/2022 #3] Kućice

## 题目描述

圣诞集市中有 $n$ 个摊位。每个摊位可以抽象为平面直角坐标系中的一个点，其坐标为 $x_i,y_i$。

现在每个摊位均有 $50\%$ 的概率违规。所有违规的摊位会被一个栅栏圈住，其中栅栏的形状为所有违规摊位对应的点组成的凸包的边界。当然，一些没有违规的无辜摊位也有可能被圈住。当违规摊位数量小于 $3$ 时，凸包显然会退化为线段、点或空集。

求被圈住摊位的期望数量。可以证明答案可以被表示成 $\frac{m}{2^n}$，其中 $m$ 为正整数。因此只需要输出 $m$ 对 $10^9+7$ 取模后的值即可。

## 说明/提示

**【样例 1 解释】**

唯一的摊位违规的概率为 $50\%$，故期望值为 $\frac{1}{2}$。

**【样例 2 解释】**

违规的情况共有 $8$ 种，而每种情况下被圈住的摊位数分别为 $0,1,1,1,2,2,2,3$。故期望值为 $\frac{1}{8}(0+1+1+1+2+2+2+3)=\frac{12}{8}$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：每个点都在由所有点组成的凸包的边界上，同时 $n \ge 3$。
- Subtask 2（30 pts）：除了第一个点外，每个点都在由所有点组成的凸包的边界上，同时 $n \ge 4$，$x_1=y_1=0$。
- Subtask 3（10 pts）：$1 \le n \le 15$。
- Subtask 4（30 pts）：$1 \le n \le 100$。
- Subtask 5（30 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 1000$，$|x_i|,|y_i| \le 10^6$。

**【提示与说明】**

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf) _Task 5 Kućice_。**

**本题分值按 COCI 原题设置，满分 $110$。**

## 样例 #1

### 输入

```
1
5 5```

### 输出

```
1```

## 样例 #2

### 输入

```
3
-1 -1
1 -1
0 1```

### 输出

```
12```

## 样例 #3

### 输入

```
5
0 0
-1 0
2 -1
3 2
0 3```

### 输出

```
83```

# 题解

## 作者：honglan0301 (赞：3)

## 题目分析

从反面考虑。

对于每个点 $i$，先求出它到其它点的位置角 $α_i$，发现它不被覆盖等价于存在一个区间 $[α_0,α_0+\pi)$ 使得没有位置角位于该区间的点被选择（当然它自己也不能选）。于是我们枚举被选择的点中位置角最小的一个，然后双指针求出能够任意选择的点的个数即可（其它的必不能选），注意要断环成链地复制一遍数组。

时间复杂度 $O(n^2)$，可以通过本题。

## 代码

```cpp
/*
  author: PEKKA_l  
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define int long long
#define mod 1000000007
const double PI=acos(-1);

int n,x[1005],y[1005],ans;
double du[2005];

int ksm(int x,int k)
{
	int nx=x,na=1;
	for(int i=1;i<=k;i<<=1) {if(i&k) {na*=nx; na%=mod;} nx*=nx; nx%=mod;} return na;
}

signed main()
{
	cin>>n; for(int i=1;i<=n;i++) cin>>x[i]>>y[i]; ans=(n*ksm(2,n)%mod-n+mod)%mod;
	for(int i=1;i<=n;i++)
	{
		int cntt=0; for(int j=1;j<=n;j++) {if(j==i) continue; du[++cntt]=atan2(y[j]-y[i],x[j]-x[i]); du[cntt+n-1]=du[cntt]+2*PI;}
		sort(du+1,du+2*n-1); int nr=2; for(int nl=1;nl<=n-1;nl++) {while(du[nr]-du[nl]<PI) nr++; ans-=ksm(2,nr-nl-1); ans+=mod; ans%=mod;}
	}
	cout<<ans<<endl;
}
```


---

## 作者：Jayun (赞：1)

## 题目大意

二维平面上有一些点，保证不存在重合的点和三点共线。求每一个点集的凸包在平面上包含的点数的和。

$n\leq1000$。

## 题解

有趣的。

假如所有点都在所有凸包内，答案 $n2^n$。

考虑斥掉不合法的。对于一个点对，它们直线分割的半平面，两个平面内的点不能同时取。那么枚举一个点，把所有点挪到以它为原点的坐标系，然后极角排序，双指针维护半平面的区间即可。

本题的启发：如果有“**不存在三点共线**”的提示，可以考虑这种半平面的角度。

## 代码

```cpp
const int N = 1010, mod = 1e9 + 7;

inline ll Read() {
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

namespace Main {
	struct Point {
		int x, y;
		Point(){}
		Point(int x, int y):x(x), y(y) {}
		friend bool operator < (Point a, Point b) { return atan2(a.y, a.x) < atan2(b.y, b.x); }
		friend Point operator + (Point a, Point b) { return Point(a.x + b.x, a.y + b.y); }
		friend Point operator - (Point a, Point b) { return Point(a.x - b.x, a.y - b.y); }
		friend ll operator * (Point a, Point b) { return 1ll * a.x * b.y - 1ll * b.x * a.y; }
	}a[N], b[N];
	int n;
	ll ans;
	ll p2[N];
	int main () {
		p2[0] = 1; for (int i = 1; i <= N - 10; i++) p2[i] = 2ll * p2[i - 1] % mod;
		n = Read();
		for (int i = 1; i <= n; i++) a[i].x = Read(), a[i].y = Read();

		ans = (p2[n] - 1) * n % mod;

		for (int i = 1; i <= n; i++) {
			int m = 0;
			for (int j = 1; j <= n; j++) if (i != j) b[m++] = a[j] - a[i];
			sort (b, b + m);
			for (int j = 0, cur = 0; j < m; j++) {
				for (; (cur + 1) % m != j && b[j] * b[(cur + 1) % m] > 0; cur = (cur + 1) % m);
				ans = (ans - p2[(cur - j + m) % m] + mod) % mod;
			}
		}
		printf ("%lld\n", ans);
		return 0;
	}
}

int main () {
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	Main::main();
	return 0;
}
```

---


# [COCI 2015/2016 #4] ENDOR

## 题目描述

如果我们相信《吉尼斯世界纪录大全》的话，在布满森林的 Endor 卫星上，有一根全银河系最长的棍子。在那根 $L$ 米长的棍子上有 $n$ 只欢快的变色龙。每只变色龙以 $1$ 米/秒的恒定速度沿着棍子在两个可能的方向（左或右）中的一个方向上移动，并以可能的 $k$ 种颜色之一着色。

众所周知，Endor 卫星上的变色龙崇拜古老的蚂蚁法则，该法则规定变色龙必须沿着棍子行走直到走到棍子的末端，并且当与另一只变色龙发生碰撞时，该变色龙必须转过 $180$ 度，继续朝相反的方向行走。此外，在向左移动着色为 $a$ 的变色龙与向右移动的着色为 $b$ 的变色龙发生碰撞后，碰撞前向左移动的变色龙采用碰撞前向右移动的变色龙的颜色 $b$，而在碰撞前向右移动的变色龙会采用新的颜色 $(a+b)\bmod k$。

如果给你所有变色龙的初始位置、颜色和运动方向，对于每种颜色，确定采用该种颜色的变色龙在离开棍子之前的总行程。

## 说明/提示

**【样例 1 解释】**

两只变色龙在行走了 $5$ 米之后发生碰撞。在此之后，$1$ 号变色龙的颜色变为 $0$，$2$ 号变色龙的颜色变为 $1$，然后它们各又继续走了 $5$ 米然后离开棍子。因此，采用第 $0$ 种颜色和第 $1$ 种颜色的变色龙各走了 $10$ 米，在此过程中不存在采用第 $2$ 种颜色的变色龙。

**【数据范围】**

对于 $50\%$ 的数据，保证 $1\leqslant n\leqslant 3000$。  
对于所有数据，$1\leqslant n\leqslant 10^5$，$1\leqslant k\leqslant 40$，$1\leqslant L\leqslant 10^6$，$0\leqslant d_i\leqslant L$，$0\leqslant b_i<k$，$d_{i-1}<d_i$。

**【题目来源】**

本题来源自 **_[COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST 4](https://hsin.hr/coci/archive/2015_2016/contest4_tasks.pdf) T6 ENDOR_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2 3 10
0 0 D
10 1 L```

### 输出

```
10.0
10.0
0.0```

## 样例 #2

### 输入

```
4 3 7
1 0 D
3 0 D
4 1 L
6 2 D```

### 输出

```
10.0
4.0
1.0```

## 样例 #3

### 输入

```
4 4 5
1 1 D
3 3 L
4 2 D
5 0 L```

### 输出

```
2.5
4.0
2.5
4.0```

# 题解

## 作者：DaiRuiChen007 (赞：5)

# 洛谷 P8048 题解

[$\text{Link}$](https://www.luogu.com.cn/problem/P8048)

## 思路分析

很好的思维题

首先考虑一个经典的 trick，假设两只相遇后的变色龙没有掉头，而是使用对方的颜色继续向前走，那么效果如下：

[![vMuuRK.png](https://s1.ax1x.com/2022/08/08/vMuuRK.png)](https://imgtu.com/i/vMuuRK)

我们发现：此时向右走的变色龙相当于没变色，而向左走的变色龙的颜色加上了向右走的变色龙的颜色

所以每个向右走的变色龙对答案的贡献都能够快速统计，问题转化成统计每个向左走的变色龙对答案的贡献

注意到所有变色龙的速度都是相等的，因此考虑一次性维护当前向右走的所有变色龙可以让某一条向左走的变色龙对每种颜色的贡献，为了方便，假设在 $0$ 处有一条颜色为 $0$ 的变色龙，不妨假设最开始有一条颜色为 $0$ 的变色龙直接和最右边的变色龙相遇，然后直到这条变色龙与最后一条变色龙相遇后，在途中分别对每种颜色 $i$ 造成了 $cnt_i$ 的贡献

那么再加入一条颜色为 $col$ 的变色龙向右走，则有 $cnt_{i+col}\gets cnt_{i}$，记录一下上一个向右走的变色龙的位置 $l$，那么 $cnt_{col}\gets cnt_{col}+\dfrac{d-l}{2}$

那么此时实际出现了一只颜色为 $col$ 的变色龙向左走，除去相遇第一只变色龙之前和相遇最后一只变色龙之后，中间过程对颜色 $i$ 的贡献就是 $cnt_{i-col}$，那么这只变色龙在相遇第一只变色龙之前对 $col$ 的贡献是 $\dfrac {d-l}2$，而且这只变色龙与第一只在 $0$ 处的变色龙相遇恰好在 $\dfrac d2$ 处，所以我们记录一下某条颜色为 $0$ 的变色龙最终会变成的颜色 $\Delta$，此时这只变色龙走到 $0$ 的时对颜色 $col+\Delta$ 有 $\dfrac d2$ 的贡献

然后模拟即可，时间复杂度 $\Theta(nk)$

## 代码呈现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
double cnt[50],ans[50];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n,k,l;
	cin>>n>>k>>l;
	int lst=0,del=0;
	for(int i=1;i<=n;++i) {
		int d,col;
		char op;
		cin>>d>>col>>op;
		if(op=='L') {
			ans[col]+=(d-lst)/2.0;
			ans[(col+del)%k]+=d/2.0;
			for(int i=0;i<k;++i) ans[(i+col)%k]+=cnt[i];
		} else {
			ans[col]+=l-d;
			rotate(cnt,cnt+k-col,cnt+k);
			cnt[col]+=(d-lst)/2.0;
			del=(del+col)%k;
			lst=d;
		}
	}
	for(int i=0;i<k;++i) cout<<fixed<<setprecision(1)<<ans[i]<<'\n';
	return 0;
} 
```



---

## 作者：lizicheng3042 (赞：2)

在做这道题之前，你可以先去做[独木桥](https://www.luogu.com.cn/problem/P1007)。然后你就会发现，和那道题相比，这道题的区别就两个：  
1. 问题不一样，一个是移动距离，另一个是最大/最小移动距离。（显然在不考虑颜色的前提下都很好做，只要知道穿透这个 trick 就可以过）  
2. 这道题引入了颜色。  

注：关于穿透，可以理解为两个存储信息的类型相同的个体都、相遇并调转方向时，可以认为两个个体实际上是互相穿过了而不是都调转了方向。  
当然，这道题还有一个关键就是灵魂互换后左移个体的颜色变化，这导致我们不能直接对于每个个体根据颜色累加答案，如果我们简单地对每一对互相穿过的个体判断颜色变化和答案累加地计算，时间复杂度会达到 $O(n^2)$，无法通过此题。  
注意到只有左移的个体颜色会发生变化，同时注意到，颜色的变化规律是比较简单的加和模，而这两个操作放在一起对于不同的初始值，转换后的最终值是很有规律的。  
然后你能发现（或者猜测）一个结论：只要你知道某个颜色 $c_i$ 转换后的最终值 $b_i$，那么对于颜色 $c_j$，最终值 $b_j$ 一定是 $(c_j-c_i+b_i+k)\bmod k$。  
你可以再手模几组数据或者画出一个能具体表现模和加操作的图（一个环）来模拟，然后发现这个结论一定是正确的。  
然后你就可以统计一个数组，表示初始颜色为某个确定值的变色龙向左移动时处于某种颜色时移动的路程，记为 $pre$ 数组。（为了保证简便和便于调试，这个确定值可以设成 $0$）  
所以说，我们只需要用指针把变色龙序列从左到右扫一遍，遇到向右移动的就更新 $pre$ 数组，并记录右移变色龙序列的第左端和最右端的位置，遇到向左移动的就根据 $pre$ 数组和右移变色龙序列的左右端点对答案进行更新即可。为了求答案，还需要记录一个数表示对于上文提到的确定值，变化后的最终值 $fc$，至此，所有转移需要的信息就都已经得到了。  
再来分析时间复杂度，显然，对于每只变色龙，不管左移还是右移，处理其耗费的时间一定是 $O(k)$，所以时间复杂度为 $O(nk)$。  
## 代码
注：本题变色龙是按顺序给出的，不需要排序。（这是我模拟赛时的代码）
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef double db;
int n,k,l,fc,lst,fst;
struct chan
{
	int pos,col;
	bool moe;
	bool operator <(const chan &a){return pos<a.pos;}
}p[100005];
char t[10];
db ans[44],pre[44],tmp[44];
int main()
{
	scanf("%d%d%d",&n,&k,&l);
	for(int a=1;a<=n;a++)
	{
		scanf("%d%d%s",&p[a].pos,&p[a].col,t+1);
		if(t[1]=='D')
			p[a].moe=true;
	}
	sort(p+1,p+n+1);
	for(int a=1;a<=n;a++)
	{
		if(p[a].moe==true)
		{
			ans[p[a].col]+=l-p[a].pos;
			fc+=p[a].col;
			if(fc>=k)
				fc-=k;
			if(lst)
			{
				for(int b=0;b<k;b++)
					tmp[(b+p[a].col)%k]=pre[b];
				tmp[p[a].col]+=p[a].pos-p[lst].pos;
				for(int b=0;b<k;b++)
					pre[b]=tmp[b];
			}
			else	
				fst=a;
			lst=a;
		}
		else
		{
			ans[p[a].col]+=(p[a].pos-p[lst].pos)/2.0;
			ans[(p[a].col+fc)%k]+=(p[a].pos+p[fst].pos)/2.0;
			for(int b=0;b<k;b++)
				ans[(b+p[a].col)%k]+=pre[b]/2.0;			

		}
	}
	for(int a=0;a<k;a++)	
		printf("%.1lf\n",ans[a]);
	return 0;
}
```

---

## 作者：有趣的问题 (赞：2)

仔细读题，会发现，向右的变色龙在碰撞前后是没有改变颜色的。

抓住这一点，产生了本题的做法：

## 暴力

对于每一只向右的变色龙，只需要在该颜色中加上这只变色龙走的路程。

对于每一只向左的变色龙，我们枚举在它左边的向右的变色龙，然后依次更新答案、更新颜色。

这样做复杂度是 $O(n^2)$ 的。

代码如下：
```#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,k,l,cnt;
double ans[45];
struct monola{
	int st,cl;
	char tp;
}ml[100005],yml[100005];
bool cmp(monola x,monola y){
	return x.st>y.st;
}
signed main(){
	cin>>n>>k>>l;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%s",&ml[i].st,&ml[i].cl,&ml[i].tp);
		if(ml[i].tp=='D'){
			ans[ml[i].cl]+=l-ml[i].st;
			yml[++cnt]=ml[i];
		}
	}
	sort(yml+1,yml+cnt+1,cmp);
	for(int i=1;i<=n;i++){
		if(ml[i].tp=='D')continue;
		double pre=ml[i].st,nxt;
		int nowcl=ml[i].cl;
		for(int j=1;j<=cnt;j++){
			if(ml[i].st<yml[j].st)continue;
			nxt=(ml[i].st+yml[j].st)*1.0/2;
			ans[nowcl]+=pre-nxt;
			pre=nxt;
			nowcl=(nowcl+yml[j].cl)%k;
		}
		ans[nowcl]+=pre;
	}
	for(int i=0;i<k;i++){
		printf("%.1lf\n",ans[i]);
	}
	return 0;
}
```

## 正解

这样做的瓶颈在于，我们每一只向左的变色龙都需要枚举。然而我们其实并不关心到底是哪只变色龙贡献的答案，因此我们可以用计数器记下当前位置每种颜色向左的变色龙的数目。

具体地说，我们从右往左枚举每一只向右的变色龙，若两只向右的变色龙中间的距离为 $dis$，则每种颜色的答案应该加上 $dis/2\times num_i$，其中 $num_i$ 为颜色 $i$ 的向左的变色龙初始位置在当前枚举的向右的变色龙右边的数目。然后我们不断更新 $num_i$。

由于每只向左的变色龙只会被加进计数器一次，所以总的复杂度降到了 $O(n\times k)$ 。

## 实现细节

注意每只向左的变色龙在遇到最左边的向右变色龙后还要走到木板左端，此时需要加上这部分的答案。可以预处理出每只向左的变色龙最后的颜色进行计算。

## 丑陋的代码

```#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,k,l,cnt,cmt,num[45],lint[45],newcl,lastcl[100005];
double ans[45];
struct monola{
	int st,cl;
	char tp;
}ml[100005],yml[100005],zml[100005];
bool cmp(monola x,monola y){
	return x.st>y.st;
}
signed main(){
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	cin>>n>>k>>l;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%s",&ml[i].st,&ml[i].cl,&ml[i].tp);
		if(ml[i].tp=='D'){
			ans[ml[i].cl]+=l-ml[i].st;
			yml[++cnt]=ml[i];
			newcl=(newcl+ml[i].cl)%k;
		}
		else {
			zml[++cmt]=ml[i];
			if(cnt)ans[(ml[i].cl+newcl)%k]+=(ml[i].st+yml[1].st)*1.0/2;
			else ans[ml[i].cl]+=ml[i].st;
		}
	}
	sort(yml+1,yml+cnt+1,cmp);
	sort(zml+1,zml+cmt+1,cmp);
	int i=1;
	while(i<=cmt&&zml[i].st>yml[1].st){
		ans[zml[i].cl]+=(zml[i].st-yml[1].st)*1.0/2;
		num[(zml[i].cl+yml[1].cl)%k]++;
		i++;
	}
	for(int j=2;j<=cnt;j++){
		for(int r=0;r<k;r++){
			ans[r]+=num[r]*(yml[j-1].st-yml[j].st)*1.0/2;
		}
		while(i<=cmt&&zml[i].st>yml[j].st){
			ans[zml[i].cl]+=(zml[i].st-yml[j].st)*1.0/2;
			num[zml[i].cl]++;
			i++;
		}
		for(int r=0;r<k;r++){
			lint[(r+yml[j].cl)%k]=num[r];
		}
		for(int r=0;r<k;r++)num[r]=lint[r];
	}
	
	for(int i=0;i<k;i++){
		printf("%.1lf\n",ans[i]);
	}
	return 0;
}


---

## 作者：star_fish (赞：1)

注意到典中典的结论是我们可以将调转方向改为改变颜色。

考虑暴力，向左走的变色龙遇到向右走的变色龙后会改变颜色，可以写出 $O(n^2)$ 的暴力。
```
for(int i=1;i<=n;i++){
		int d,c;char fl;
		cin>>d>>c>>fl;
		if(fl=='L') a[++cnt1]={d,c};
		else b[++cnt2]={d,c},ans[c]+=l-d;
	}
	for(int i=1;i<=cnt1;i++){
		int r=cnt2;
		int c=a[i].c,d=a[i].d;
		while(r&&b[r].d>a[i].d) r--;
		for(int j=r;j>=1;j--){
			ans[c]+=(d-b[j].d)/2.0;
			(c+=b[j].c)%=k;
			d=b[j].d;
		}
		ans[c]+=a[i].d-(a[i].d-d)/2.0;
	}
```
观察到 $k$ 非常的小，考虑基于 $k$ 的做法。向右的变色龙的贡献显然易得。由暴力代码中可以发现，向左走的变色龙对答案的贡献是他不断与向右走的变色龙相遇同时不断变色的过程。将向右走的变色龙放入 $L$、向左走的变色龙放入 $R$，我们可以用两个指针分别遍历 $L$、$R$ 数组，在从右向左遍历 $L$ 数组的同时将会遇到当前 $L$ 且当前颜色相同的 $R$ 变色龙一起计算，便可以在 $O(nk)$ 的时间内完成。

整组变色以及颜色指向可以用标记数组完成，以及计算其中散落的部分和最后走到底的贡献都放在下面的代码和注释里了。
```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N=1e5+5;
const int M=50;
int n,k,l;
int cnt1,cnt2,cntk;
int ct[M],num[M],C[M],tt[M];
//记录每个颜色指向的块 块中元素数量 每个块代表的颜色
double ans[M];
struct node{int d,c;}a[N],b[N];
queue<int> g[M];
inline double work(double x){
	int w=x*100;
	if(w%10>=5) w+=10;
	return w/100.0;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k>>l;
	for(int i=1;i<=n;i++){
		int d,c;char fl;
		cin>>d>>c>>fl;
		if(fl=='L') a[++cnt1]={d,c};
		else b[++cnt2]={d,c},ans[c]+=l-d;//向右走的贡献
	}
	//按照相同的颜色分为一组，往每个颜色组里面塞入标记{d,c} ans[c]加上num*dis
	int r=cnt1;
	while(cnt2&&b[cnt2].d>a[r].d) cnt2--;
	b[cnt2+1].d=max(b[cnt2].d,a[cnt1].d)+1;
	for(int i=cnt2;i>=1;i--){
		while(r&&a[r].d>b[i].d){
			if(ct[a[r].c]==0){
				ct[a[r].c]=++cntk,
				C[cntk]=a[r].c;
			}
			g[ct[a[r].c]].push(a[r].d);
			ans[C[ct[a[r].c]]]-=(b[i+1].d-a[r].d)/2.0;
			num[ct[a[r].c]]++;
			r--;
		}
		double sum=(b[i+1].d-b[i].d)/2.0;
		for(int j=0;j<k;j++) tt[j]=ct[j];
		for(int j=0;j<k;j++){
			if(!tt[j]) continue;
			ans[C[tt[j]]]+=sum*num[tt[j]];
			//贡献答案
			(C[tt[j]]+=b[i].c)%=k;
			if(ct[j]==tt[j]) ct[j]=0;
			ct[C[tt[j]]]=tt[j];
			//转化指向和颜色
		}
	}
	for(int i=1;i<=r;i++) ans[a[i].c]+=a[i].d;
	for(int i=1;i<=cntk;i++){//这里是记录走到底的贡献
		while(!g[i].empty())
			ans[C[i]]+=g[i].front()-(g[i].front()-b[1].d)/2.0,g[i].pop();
	}
	for(int i=0;i<k;i++) cout<<fixed<<setprecision(1)<<work(ans[i])<<'\n';
	return 0;

```

---

## 作者：dashabi35 (赞：0)

这是一道题目。

对于两个相撞的变色龙，可以将他们两个灵魂互换，就相当于向左的还是向左，向右的还是向右，但是颜色有所变化，由题意易知，向右的颜色不变，向左的颜色加上向右的变色龙的颜色，好神奇。

这样就可以实现颜色的变化以及统计了，对于向右的变色龙，相当于是横冲直撞的直接到右端点，代码十分容易实现，对于向左的变色龙，可以枚举他左边的向右的变色龙，然后使用简单的数学公式计算出相交的位置，即可计算出每一段颜色的长度，然后就结束（TLE）了。

的确， $O(n^2)$ 的复杂度肯定是过不了的，那么就需要进行一点优化。 

只需要记住在某一个向左的变色龙之前每种颜色的路程，再加上他本身的颜色，就可以知道这只变色龙在各颜色下走过的路程啦。

思路有了，代码理论上应该不难写了，但仅存在于理论上，所以还是放了一个代码。

::::info[不建议看的代码]

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,k,l,lst;
int d,c;
double ans[45];
double psum[3][45]; //滚动前缀和 
int v;
signed main()
{
	scanf("%d%d%d",&n,&k,&l);
	for(int i=1;i<=n;++i)
	{
		char w;
		scanf("%d%d",&d,&c);
		getchar();
		scanf("%c",&w);
		if(w=='D')
		{
			ans[c]+=l-d;
			for(int j=0;j<k;++j) 
			{
				psum[1][(c+j)%k]=psum[0][j];
			}
			psum[1][c]+=(d-lst)/2.0;
			memcpy(psum[0],psum[1],sizeof psum[0]);
			memset(psum[1],0,sizeof psum[1]);
			lst=d;
			v=(v+c)%k;
		}
		else
		{
			ans[c]+=(d-lst)/2.0;
			for(int j=0;j<k;++j)
			{
				ans[(c+j)%k]+=psum[0][j];
			}	
			ans[(v+c)%k]+=d/2.0;
		}
	}
	for(int i=0;i<k;++i)
	{
		printf("%.1lf\n",ans[i]);
	}
	return 0;
}
```

::::

---

## 作者：時空 (赞：0)

[Link](https://www.luogu.com.cn/problem/P8048)

我怎么，模拟赛被这题创飞了。赛后写 + 调 1.5h 也算调出来了。写篇题解记录一下。

[P1007](https://www.luogu.com.cn/problem/P1007) 的加强版。建议先做这道。

考察两只变色龙的碰撞过程，与弱化版类似的，可以看做两只变色龙互换继续走。

那么很容易发现方向为右的变色龙是可以一直走到头的，这个很好理解。记录一下贡献即可。

对于方向向左的变色龙，可以看作它在每次与方向向右的变色龙碰撞后，颜色发生变化，但方向不变，继续走。

那么朴素的二次方做法就出来了。可以得到一半的分。

你考虑怎么优化。考虑每一只向右的变色龙对答案的贡献。

根据暴力代码手玩一下发现若两只向右的变色龙间的距离为 $dis$，那么对于任意向左的，经过这两只的变色龙，贡献为 $\displaystyle \frac{dis}{2}$。

那么就很好做了。记 $g_{col,j}$ 表示有多少只向左的变色龙满足当前在第 $j$ 只向右的变色龙的位置，且颜色为 $col$。不妨令此时变色龙还未发生碰撞，这样有助于我们统计答案。

显然这个东西是可以 $\mathcal{O(n \times k)}$ 预处理出来的。然后对于每只向右的变色龙 $j$，枚举颜色 $col$，那么对颜色 $col$ 的贡献就是 $\displaystyle g_{col,j} \times \frac{dis}{2}$。那么就做完了。

注意每只向左的变色龙经过最后一只向右的变色龙后，还需要走出棍子。于是类似地，再开一个辅助数组 $f$ 进行递推即可。

细节挺多的。笔者的实现有点复杂。但还是放出代码供参考。

[代码](https://www.luogu.com.cn/paste/3q9039ty)

---

## 作者：shuangmu (赞：0)

[广告](https://www.cnblogs.com/frostwood/p/17768209.html)

首先要发现一个很重要的性质，那就是两只变色龙碰撞后回头，等效于两只变色龙继续往前走，其中向右走的颜色不变，而向左走的要改变颜色。

那这样就有一种 $O(n^2)$ 的做法：对于向右的变色龙，直接贡献答案；对于向左的变色龙，我们按照碰到的先后顺序枚举它前面所有向右走的变色龙，这样每只向右走的变色龙都会给当前的颜色贡献 $\frac{1}{2}(d_{i+1} - d_i)$ 的路程，当然这里的 $d$ 是相邻的两只向右走的变色龙。注意开头和结尾都要特殊处理。

然后我们发现 $k$ 很小，而 $d_{i+1} - d_i$ 仅与向右走的变色龙有关，这启示我们去按照模 $k$ 意义上去记录贡献。我们约定后面所说的关于颜色的运算均为模 $k$ 意义下的。具体地，我们设 $w_i$，表示如果初始颜色为 $0$，则当前的变色龙会给颜色 $i$ 造成 $w_i$ 的贡献。那对于颜色为 $x$ 的变色龙，就会给颜色 $x+i$ 造成 $w_i$ 的贡献。

我们考虑维护这个 $w_i$。假设我们现在已经有 $t$ 只向右走的变色龙，当加入一只新的向右走的变色龙 $p$ 时，它的颜色会导致 $w$ 数组集体平移，因为每个颜色都在模 $k$ 意义下加了 $c_p$。所以 $w'_{i+c_p} = w_i$，同时还会在 $c_p$ 位置上新增 $\frac{1}{2} (d_{t+1} - d_t)$ 的贡献。这样，每个向左走的变色龙就可以通过 $k$ 次枚举统计答案了。还是注意开头和结尾的特殊处理，具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+100;

int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch<'0' || ch>'9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch>='0'&&ch<='9') {x = x * 10 + (ch-48), ch = getchar();}
	return x * f;
}
struct xwx {
	int d, col, dir;
	bool operator < (const xwx &b) const {
		return d < b.d;
	}
} a[N];
int n, K, L;
int c[N];
double ans[50];
double w[50];
int sum;
int dr[N], totr, cr[N];//记录向右走的变色龙的信息

void change(int del) {
	double b[50];
	for(int i = 0; i<K; ++i) {
		b[(i+del)%K] = w[i];
	}
	for(int i = 0; i<K; ++i) {
		w[i] = b[i];
	}
}//平移数组
int main() {
	n = read(), K = read(), L = read();
	for(int i = 1; i<=n; ++i) {
		a[i].d = read(), a[i].col = read();
		char op[3];
		scanf("%s", op);
		if(op[0] == 'L') a[i].dir = 0;
		else a[i].dir = 1, ans[a[i].col]+=(L-a[i].d);
	}
	sort(a+1, a+n+1);
	for(int i = 1; i<=n; ++i) {
		c[i] = a[i].col;
	}//完全没有意义的一步（
	for(int i = 1; i<=n; ++i) {
		if(a[i].dir) {
			++totr;
			dr[totr] = a[i].d;
			cr[totr] = a[i].col;
			sum = (sum + a[i].col)%K;//用来确定颜色最后会变成什么
			if(totr > 1) {
				change(a[i].col);
				w[a[i].col]+=(0.5*(dr[totr] - dr[totr-1]));
			}	
			continue;
		}
//		dr[totr+1] = a[i].d;
//		for(int j = totr; j>=1; --j) {
//			ans[c[i]]+=(0.5*(dr[j+1] - dr[j]));
//			c[i] = (c[i] + cr[j])%K;
//		}
//		ans[c[i]]+=0.5*(a[i].d + dr[1]);//n^2做法

		for(int j = 0; j<K; ++j) {
			ans[(c[i]+j)%K]+=w[j];
		} 
		ans[c[i]]+=(0.5*(a[i].d - dr[totr]));//第一只遇到的向右走的变色龙
		ans[(c[i] + sum)%K]+=(0.5*(a[i].d + dr[1]));//走过最后一只变色龙后还要一直走到终点。
	}
	for(int i = 0; i<K; ++i) {
		printf("%.1lf\n", ans[i]);
	}
	return 0;
}
```



---


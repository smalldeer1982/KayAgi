# [COCI 2011/2012 #4] OGRADA

## 题目描述

给定两个元素个数为 $N$ 的数组 $A,B$。

规定一个数组的权值为该数组中所有相邻元素的大小差的绝对值之和。现可将 $B$ 数组变成其任意的一个排列 $B'$，使得对 $\forall i \in [1,N) \cap \Z$ 满足：

- 若 $A_i \lt A_{i+1}$，则 $B'_i \lt B'_{i+1}$。
- 若 $A_i \gt A_{i+1}$，则 $B'_i \gt B'_{i+1}$。

求在所有方案中权值最大的排列 $B'$ 及最大权值。

## 说明/提示

**【样例 1 解释】**

合法的数组 $B'$ 有：

- $\{1,3,2,4\}$，权值为 $2+1+2=5$
- $\{1,4,2,3\}$，权值为 $3+2+1=6$
- $\{2,3,1,4\}$，权值为 $1+2+3=6$
- $\bf \{2,4,1,3\}$ **，权值为** $\bf2+3+2=7$
- $\{3,4,1,2\}$，权值为 $1+3+1=5$

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$2 \le N \le 3 \times 10^5$，$1 \le A_i,B_i \lt 10^9$。

**【提示与说明】**

如果只答对第一行而第二行错误或为空，则可以获得对应测试点 $50\%$ 的分数。

欢迎通过私信或发帖对自行编写的 [Special Judge](https://www.luogu.com.cn/paste/xuyueqnf) 进行 hack。

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 4 OGRADA_。**

**本题分值按 COCI 原题设置，满分 $120$。**

## 样例 #1

### 输入

```
4
5 7 4 9
1 2 3 4```

### 输出

```
7
2 4 1 3```

## 样例 #2

### 输入

```
10
9 5 1 2 6 7 4 18 20 12
10 40 20 30 50 70 80 100 1000 500```

### 输出

```
3010
100 80 10 40 50 1000 20 70 500 30```

# 题解

## 作者：Unordered_OIer (赞：3)

# P8083

题意：给定序列 $a,b$，要求选出一个序列 $b$ 的排列 $b'$，满足序列 $a$ 与 $b'$ 的任意相同位置的相邻元素的大小关系相同，并且最大化 $\sum\limits_{i=2}^n|b'_i-b'_{i-1}|$。

****

容易发现，一个单调的序列的“权值”仅和该序列中最大最小值有关。于是，例如样例中的 `9 5 1 2 6 7 4 18 20 12`，我们需要关心的“关键位置”只有存在“转折”关系，即**同时小于或者大于左右两个相邻位置**的位置。在样例中，就是 `1`、`7`、`4`、`20` 这几个位置，显然答案只和这几个位置的值，以及首位两个位置的值有关。

要求权值最大，不难想到贪心地取 $b$ 中最大的和最小的若干个数填入这些关键位置。具体地，对于满足 $a_{i-1}<a_i$ 且 $a_i>a_{i+1}$ 的位置，我们依次从大到小地用 $b$ 中大的值去填，对于满足 $a_{i-1}>a_i$ 且 $a_i<a_{i+1}$ 的位置，我们依次从小到大地用 $b$ 中小的值去填。

需要注意一些地方就是，我们不能将最小/最大的数填在第一位或最后一位，因为这样会浪费最大最小值做差产生的绝对值（例如样例中 `1 4 2 3` 打不过 `2 4 1 3` 就是因为浪费了 $|3-1|$ 和 $|4-1|$）。正确的做法是将 $1$ 和 $n$ 最后填即可，不难发现这样对于权值的损失是最小的。

剩下的非关键位置，我们可以使用剩余的值在每一段中填入，由上述贪心算法填数后剩下的值在 $b$ 数组从小到大排序后一定处于中间一段，所以一定有满足要求的填法。

代码实现很简单，990B/164ms 轻松最优解。

---

## 作者：lzqy_ (赞：3)

看到有大小关系限制，考虑拓扑排序，并在拓扑的同时从大到小进行填数。

问题转换为，对于拓扑队列中的所有元素（即 $B'$ 的位置），应该把最大的数填在哪个位置上。

然后~~快快乐乐~~分类讨论就行了。

**约定：** 蓝色块为已填，灰色块为可填（在拓扑队列中），白色块为不能填（不在拓扑队列中），优先级越小越先填。

- $A_{i-1}>A_i<A_{i+1}:$

	![](https://cdn.luogu.com.cn/upload/image_hosting/bwppjuqs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

	此时 $B'_i$ 的值越小越好，并且 $B'_i$ 的值每减小 $1$，答案增加 $2$，优先级为 $4$。
    
- $A_{i-1}>A_i>A_{i+1}:$

	![](https://cdn.luogu.com.cn/upload/image_hosting/g7d2rf3k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

	此时从 $B'_{i-1}$ 到 $B'_{i+1}$ 对答案的贡献为 $B'_{i-1}-B'_{i+1}$，与 $B'_{i}$ 无关，优先级为 $2$。
    
- $A_{i-1}<A_i<A_{i+1}$ 与 $A_{i-1}>A_i>A_{i+1}$ 同理。
    
- $A_{i-1}<A_i>A_{i+1}:$

	![](https://cdn.luogu.com.cn/upload/image_hosting/i9bavdmp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

	此时 $B'_i$ 的值越大越好，并且 $B'_i$ 的值每增加 $1$，答案增加 $2$，优先级为 $0$。
    
- $i=1,A_i>A_{i+1}:$

	![](https://cdn.luogu.com.cn/upload/image_hosting/a899x296.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
	
   此时 $B'_i$ 的值越大越好，并且 $B'_i$ 的值每增加 $1$，答案增加 $1$，优先级为 $1$。
   
- $i=1,A_i<A_{i+1}:$

	![](https://cdn.luogu.com.cn/upload/image_hosting/wojk95jt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
	
   此时 $B'_i$ 的值越小越好，并且 $B'_i$ 的值每减小 $1$，答案增加 $1$，优先级为 $3$。
   
- $i=n$ 与 $i=1$ 同理。

拓扑的时候用优先队列，按照优先级排序即可。

（其实这玩意儿写出来更像 $\text{Dijstra}$ /qd）

### 代码

分类讨论很麻烦，但代码不复杂。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=300010;
inline int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
struct edge{
	int v,to;
}e[maxn<<1];
int head[maxn],ecnt;
void addedge(int u,int v){
	e[++ecnt].v=v,e[ecnt].to=head[u],head[u]=ecnt;
}
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
bitset<maxn>vis;
int ru[maxn],n;
int a[maxn],b[maxn];
int Ans[maxn];
int Num(int i){
//返回对应位置优先级
	if(i-1&&i<n){
		if(!Ans[i-1]&&!Ans[i+1]) return 0;
		if(Ans[i-1]&&Ans[i+1]) return 4;
		return 2; 
	}
	if(i-1){
		if(Ans[i-1]) return 3;
		return 1;
	} 
	if(Ans[i+1]) return 3;
	return 1;
}
void Solve(){
	for(int i=1;i<=n;i++)
		if(!ru[i]) q.push(make_pair(Num(i),i));
	pair<int,int>t;
	int cnt=0;
   //拓扑排序写法参考Dijstra堆优化版本
	while(!q.empty()){
		t=q.top(),q.pop();
		if(vis[t.second]) continue;
		//填过,continue
		if(Num(t.second)^t.first) continue;
		//不是当前状态(不是最新版本),continue
		Ans[t.second]=b[++cnt],vis[t.second]=1;
		if(t.second-1&&!ru[t.second-1]) 
			q.push(make_pair(Num(t.second-1),t.second-1));
		if(t.second<n&&!ru[t.second+1])
			q.push(make_pair(Num(t.second+1),t.second+1));
		for(int i=head[t.second];i;i=e[i].to){
			ru[e[i].v]--;
			if(!ru[e[i].v]) 
				q.push(make_pair(Num(e[i].v),e[i].v));
		}
	}
	
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		b[i]=read();
	sort(b+1,b+1+n,greater<int>());
	for(int i=1;i<n;i++)//加边
		if(a[i]>a[i+1]) 
			addedge(i,i+1),ru[i+1]++;
		else addedge(i+1,i),ru[i]++;
	Solve();
	ll ans=0;
	for(int i=1;i<n;i++)
		ans+=abs(Ans[i]-Ans[i+1]);
	printf("%lld\n",ans);
	for(int i=1;i<=n;i++)
		printf("%d ",Ans[i]);
	return 0;
}
```


---

## 作者：内拉组里 (赞：1)

# Pts 6

非常暴力且没什么卵用的纯暴力，建议直接跳过本段。

直接对 $ b $ 枚举全排列，然后 $ \Theta (N) $ 地合法性 check，

最后一个一个统计答案。

这里就不展开讲解了。

## Analyses：

> 总时间复杂度 $ \Theta (2^N N) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Pts 60

现在只考虑第一行答案，拿一半分数。

由于题干未提及 $ A_i = A_{i + 1} $ 的情况，故无需考虑。

这里提供一种策略。

观察 $ b $ 数组中处首尾外的每一个数，有四种相对位置关系：

1. $ a[i - 1] \lt a[i] \lt a[i + 1] $，上坡（**upslope**）。
2. $ a[i - 1] \gt a[i] \gt a[i + 1] $，下坡（**downslope**）。
3. $ a[i - 1] \lt a[i] \gt a[i + 1] $，波峰（**peak**）。
4. $ a[i - 1] \gt a[i] \lt a[i + 1] $，波谷（**valley**）。

那么每个数在拆掉绝对值后计算贡献时只有三种系数：

- **peak**，系数为 $ 2 $；
- **valley**，系数为 $ -2 $；
- **slope**，系数为 $ 0 $。

对于首尾两个数，系数只能为 $ \pm 1 $，根据与相邻数的相对大小进行判断即可。

故只需统计每个系数的个数，然后利用贪心思想，

让更大的 $ b[i] $ 与更大的系数相乘再求和即可。

## Analyses：

> 对应时间复杂度 $ \Theta (N \log{N}) $。
>
> 对应空间复杂度 $ \Theta (N) $。

***

# Pts 120

题目要求输出方案，故不能只对值进行贪心，而是对排列进行贪心。

故在 **Pts 60**  的基础上，对于 **peak** 和 **valley**，直接填极值，并且向均值处收敛，即：
$$
\begin{cases}
	\forall i,j \in \text{peak},i \lt j,b[i] \gt b[j] \\ 
	\forall i,j \in \text{valley},i \lt j,b[i] \lt b[j] 
\end{cases}
$$
先把 **peak** 和 **valley** 填完，再去考虑 **slope**。

对于单个的 **slope**，即左右相邻的位置分别为 **peak** 或 **valley**，

显然由于后两者都填完了，并且填的都是极值，故任意可填值均为合法。

而对于连续的 **slope** 只需考虑以下情形：

| 下标 | 1          | 2           |      3      | 4        |
| ---- | ---------- | ----------- | :---------: | -------- |
| 地形 | **valley** | **upslope** | **upslope** | **peak** |

令 $ b = \{ 5,6,7,8 \} $，则 $ 1 $ 处和 $ 4 $ 处先分别填入 $ 5 $ 和 $ 8 $，

从左往右扫，显然 $ 2 $ 处应填 $ 6 $，即当前可填值的最小值，$ 3 $ 处也是如此。

这样能保证填出来的 $ b $ 数组一定合法。

**downslope** 同理，都填当前最大值。

## Analyses：

> 总时间复杂度 $ \Theta (N) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Code：

```cpp
/* reference : @ZLOJ.huhangqi */
/* reference : @Luogu.aaaaaaaawsl (307940) */
/* key : start with relative positions,value on the slope won'a make sense */
#include	<algorithm>
#include	<iostream>
#include	<queue>
#define		int		long long
using namespace std;
constexpr int maxn = 3e5+4;

namespace pts6
{
	int n, ans;
	int a[maxn];
	int b[maxn];
	
	signed main (void)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		for (int i = 1; i <= n; i++) cin >> b[i];
		do
		{
			int flag = 0;
			for (int i = 2; i <= n; i++)
			{
				if ((a[i] - a[i - 1]) * (b[i] - b[i - 1]) < 0)
				{
					flag = 1;
					break;
				}
			}
			if (!flag)
			{
				int sum = 0;
				for (int i = 2; i <= n; i++) sum += abs (b[i] - b[i - 1]);
				ans = max (ans, sum);
			}
		}
		while (next_permutation (b + 1, b + n + 1));
		cout << ans << endl;
		return 0;
	}
}

namespace pts60_ZLOJ
{
	int n, ans;
	int a[maxn];
	int b[maxn];
	int coe[maxn];
	/* relative position : -1 valley,0 slope,1 peak */
	priority_queue<int> q;
	
	signed main (void)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		for (int i = 1; i <= n; i++) cin >> b[i];
		sort (b + 1, b + n + 1, greater<int>());
		a[0] = a[2];
		a[n + 1] = a[n - 1];
		for (int i = 1; i <= n; i++)
		{
			if (a[i - 1] > a[i] && a[i] < a[i + 1]) coe[i] = -2;					/* valley */
			if (a[i - 1] < a[i] && a[i] > a[i + 1]) coe[i] = 2;						/* peak */
		}
		coe[1] >>= 1;
		coe[n] >>= 1;
//		for (int i = 1; i <= n; i++) cerr << coe[i] << ' ';
//		cerr << endl;
		for (int i = 1; i <= n; i++) q.push(coe[i]);
		for (int i = 1; i <= n; i++)
		{
			int now = q.top(); q.pop();
			ans += now * b[i];
		}
		cout << ans << endl;
		return 0;
	}
}

namespace pts120
{
	int n;
	int a[maxn];
	int b[maxn];
	int pk[maxn];
	int ans[maxn];
	
	signed main (void)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		for (int i = 1; i <= n; i++) cin >> b[i];
		sort (b + 1, b + n + 1);
		int L = 1;
		int R = n;
		if (a[2] > a[1]) pk[1] = 1;
		for (int i = 2; i <= n; i++)
		{
			if (a[i] > a[i - 1])
			{
				if (!pk[i - 1]) ans[i - 1] = b[L++];		/* valley */
				pk[i] = 1;
			}
			else if (pk[i - 1]) ans[i - 1] = b[R--];		/* peak */
		}
		if (a[1] < a[2]) ans[1] = b[L++];
		else ans[1] = b[R--];
		if (a[n] < a[n - 1]) ans[n] = b[L++];
		else ans[n] = b[R--];
		for (int i = 1; i <= n; i++) if (!ans[i])			/* slope */
		{
			if (pk[i]) ans[i] = b[L++];						/* upslope */
			else ans[i] = b[R--];							/* downslope */
		}
		int sum = 0;
		for (int i = 1; i < n; i++) sum += abs (ans[i] - ans[i + 1]);
		cout << sum << endl;
		for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
		return 0;
	}
}

signed main (void)
{
	return pts120::main ();
}
```

---

## 作者：aaaaaaaawsl (赞：1)

贪心。

设 $C$ 为答案数组，考虑 $C$ 的价值，假设 $C$ 是这样的：

```
    c3          c8          
       c4   c6                  
  c2                       
         c5   c7                 
c1                          

````

那么答案就是 

$$
c_2 - c_1 + c_3 - c_2 + c_3 - c_4 + c_4 - c_5 + c_6 - c_5 + c_6 - c_7 + c_8 - c_7
$$

$$ = -1\times c_1 + 2 \times c_3 - 2 \times c_5 + 2 \times c_6 - 2 \times c_7 + 1 \times c_8 $$

即中间波峰的权值 $\times 2 - $ 中间波谷的权值 $\times 2 +$ 旁边波峰的权值 $-$ 旁边波谷的权值。 

就让波峰尽可能大，波谷尽可能小就行，构造的时候先把波峰波谷填好，剩下的看它在上坡还是下坡，填下一个大的或者小的就行。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long

using namespace std;

const int N = 3e5 + 10;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

int n;
int a[N], b[N], up, dw;
int ans[N], sum, sta[N];

signed main(){
	n = read();
	for(int i = 1; i <= n; ++ i) a[i] = read();
	for(int i = 1; i <= n; ++ i) b[i] = read();
	sort(b + 1, b + n + 1);
	if(a[2] > a[1]) sta[1] = 1;
	for(int i = 2; i <= n; ++ i) {
		if(a[i] > a[i - 1]){
			if(sta[i - 1] == 0) ans[i - 1] = b[++ dw];
			sta[i] = 1;
		}
		else if(a[i] < a[i - 1] && sta[i - 1] == 1) ans[i - 1] = b[n - (++ up) + 1];
	}
	if(a[2] > a[1]) ans[1] = b[++ dw];
	else ans[1] = b[n - (++ up) + 1];
	if(a[n] > a[n - 1]) ans[n] = b[n - (++ up) + 1];
	else ans[n] = b[++ dw];
	for(int i = 1; i <= n; ++ i) {
		if(!ans[i]) {
			if(sta[i]) ans[i] = b[++ dw];
			else ans[i] = b[n - (++ up) + 1];
		}
		sum += abs(ans[i] - ans[i - 1]);
	}
	printf("%lld\n", sum - ans[1]);
	for(int i = 1; i <= n; ++ i) printf("%lld ", ans[i]);
	return 0;
}
```

---

## 作者：Mu_leaf (赞：1)

### [思路]

~~特简单的贪心题~~。

首先考虑保证目标序列与原序列的相似性：

于是考虑找出**波峰**与**波谷**来维护相似性。

至于在相邻的波峰波谷之间的数，随便怎么填就可以（不是玩笑）。


------------

### 解释：
![11](https://cdn.luogu.com.cn/upload/image_hosting/grv9zm1k.png)

从图中可以发现在某波峰与相邻波谷之间的友好值就是他们之间的差的绝对值，这是个定值，与中间“半山腰上的数”没有任何关系。


------------

### 那么怎么知道波峰波谷怎么填呢？

既然可以很快知道波峰波谷的位置。

那么，将 $B$ 数组的排序。设 $L$ 和 $R$ 为 $B$ 数组中的最大值和最小值。

### 将最大的值按从大到小正序填入，波谷也是如此。


------------


## 需要注意的是：

在 $B$ 数组中规定 $2 < i < N$ 中的波峰，将会贡献两次答案。因为它的左边会计算一次，右边会计算一次。

而在数组两边的值，只会对答案贡献一次。


------------

于是，综上所述：

最后的答案值，就是：

波峰 $\times $ $2$ $-$ 波谷 $\times$  $2$ $+$ 半峰 $-$ 半谷

### 可以看出要保证波峰最大，半峰次大，波谷最小，半峰次小。

于是愉快就可以 AC 了。

## Code:

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N=3e5+5;
int a[N],b[N],bi[N],ans_vis[N],sm[N],vis[N],t_b,t_s;
int n;
int book[N];
long long ans;
void init_a(){
	for(int i=2;i<n;i++){
		if(a[i]>a[i-1] && a[i]>a[i+1]){
			bi[++t_b]=i;
			vis[i]=2;
		}if(a[i]<a[i-1] && a[i]<a[i+1]){
			sm[++t_s]=i;
			vis[i]=-2;
		}
	}
	if(a[1]>a[2]) bi[++t_b]=1,vis[1]=1;
	if(a[1]<a[2]) sm[++t_s]=1,vis[1]=-1;
	if(a[n]<a[n-1]) sm[++t_s]=n,vis[n]=-1;
	if(a[n]>a[n-1]) bi[++t_b]=n,vis[n]=1;
}
int main(){

	
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	init_a();
	sort(b+1,b+n+1);
	int l=1,r=n;
	for(int i=1;i<=t_b;i++){
		ans_vis[bi[i]]=b[r--];
		ans+=vis[bi[i]]*ans_vis[bi[i]];
		book[bi[i]]=1;
	}
	for(int i=1;i<=t_s;i++){
		ans_vis[sm[i]]=b[l++];
		ans+=vis[sm[i]]*ans_vis[sm[i]];
		book[sm[i]]=2;
	}int now=0;
	printf("%lld\n",ans);
	for(int i=1;i<=n;i++){
		if(ans_vis[i]){
			now=book[i];
			printf("%d ",ans_vis[i]);
		}else if(now==2) printf("%d ",b[l++]);
		else if(now==1) printf("%d ",b[r--]);
		
	}
	return 0;
}
```


---

## 作者：GWBailang (赞：0)

[**原题传送**](https://www.luogu.com.cn/problem/P8083)

### 前言
比赛的时候花了 $[10,25]$ 分钟想出了如何求最大值，结果不会构造了。

**如果你不知道为何 WA 掉，大概是因为你的权值没有开 long long。**
### 正文
#### 不对的思路
省流：这是一堆废话，可以不看。

我的第一想法是先构造出一个符合题意的 $B'$，然后对该数组中的元素进行交换，尝试构造出权值最大的数组。但是不太可行。

于是我尝试将题目的第二个样例列了出来。

#### 求最大权值

最大权值为：

$$
B'_1-B'_2+B'_2-B'_3+B'_4-B'_3+B'_5-B'_4+B'_6-B'_5+B'_6-B'_7+B'_8-B'_7+B'_9-B'_8+B'_9-B'_{10}
$$

化简得：

$$
B'_1-2B'_3+2B'_6-2B'_7+2B'_9-B'_{10}
$$

于是我意识到了最后的权值只与数组中的“峰”或“谷”（即 $B'_i$ 同时大于或小于 $B'_{i-1},B'_{i+1}(2\le i\le n-1)$）以及两端有关系。显然想使权值最大，我们希望在“峰”处的数值尽量大，在“谷”处的数值尽量小。

当然数组两端的两个数有些特殊，以上述公式中的 $+B'_1$ 举例，我们肯定希望它尽量大，但不能比其它的“峰”还大，所以如果数组中有 $f$ 个“峰”，那么 $B'_1$ 就应该是 $B$ 数组中第 $f+1$ 大的数。

好了，现在我们已经求出权值的最大值了，且这些“峰”和“谷”都可以填上数了。

#### 构造

赛场上最后五分钟，我在代码里写了一行：

```cpp
//怎么填数！！！
```

~~真好，一分没得。~~

实际上往 $B'$ 中填数的这部分代码只需遵循一下规则：

从左往右填，对于第 $i(1\le i\le n)$ 个数：

- 如果 $B'_i$ 已经填过数，就不用再填了。
- 如果 $A_{i-1}\lt A_i$，说明此时正从“谷”走向“峰”，填入 $B$ 中未使用过的最小的数。
- 如果 $A_i\lt A_{i+1}$，说明此时正从“峰”走向“谷”，填入 $B$ 中未使用过的最大的数。

贪心，不难证明其正确性。

#### 代码

于是，我们赛时提交上去的代码仅与AC代码有 5 行之差。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define dbg(x) cerr<<#x":"<<(x)<<' '
#define dbge(x) cerr<<#x":"<<(x)<<endl
using ll=long long;
using vi=vector<int>;
using vl=vector<ll>;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	int n;
	cin>>n;
	vi a(n+1),b(n+1);
	int f=0,g=0;//记录“峰”与“谷”的数量
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	sort(b.begin()+1,b.end());
	//排序后，从前取就是去最小值，从后就是取最大值
	ll ans=0;//十年OI一场空
	vi c(n+1);//即B'数组
	for(int i=2;i<n;i++){
		if(a[i-1]<a[i]&&a[i]>a[i+1]){//“峰”
			ans+=2*b[n-(++f)+1];//取B中剩余数的最大值
			c[i]=b[n-f+1];
		}
		if(a[i-1]>a[i]&&a[i]<a[i+1]){//“谷”
			ans-=2*b[++g];//取B中剩余数的最小值
			c[i]=b[g];
		}
	}
	if(a[1]>a[2]){//不一定是+B'_i哦(
		ans+=b[n-(++f)+1];
		c[1]=b[n-f+1];
	}else{
		ans-=b[++g];
		c[1]=b[g];
	}
	if(a[n]>a[n-1]){
		ans+=b[n-(++f)+1];
		c[n]=b[n-f+1];
	}else{
		ans-=b[++g];
		c[n]=b[g];
	}
	cout<<ans<<endl;
	//怎么填数！！！
	//填数：
    for(int i=2;i<n;i++){
        if(c[i]!=0)continue;
        if(a[i-1]>a[i])c[i]=b[n-(++f)+1];
        else c[i]=b[++g];
    }
	for(int i=1;i<=n;i++)cout<<c[i]<<" \n"[i==n];
	return 0;
}
```

---

## 作者：_Above_the_clouds_ (赞：0)

# 思路：
$ans$ 数组记录最终答案，$sum$ 记录最大权值，$l$ 为 $b$ 数组的左端，$r$ 为 $b$ 数组的右端。先将数组 $b$ 数组排序，如果 $a_i$ 为 $a_{i-1}$ 和 $a_{i+1}$ 间的最大值，那么 $ans_i$ 记录为 $b$ 数组最右边的值，也就是 $b_r$，$r$ 也要随之减一；如果 $a_i$ 为 $a_{i-1}$ 和 $a_{i+1}$ 间的最小值，那么 $ans_i$ 记录为 $b$ 数组最左边的值，也就是 $b_l$，$l$ 也要随之加一。其次有两个地方需要特判，就是开头和结尾，如果 $a_1$ 小于 $a_2$，那 $ans_1$ 记录为 $b_l$；否则，$ans_1$ 记录为 $b_r$，结尾则是相反。最后统计权值，输出即可。

# 代码：
```cpp
#include<bits/stdc++.h>
#define Max 300005
using namespace std;
long long n,l,r,sum;
long long a[Max],b[Max],ans[Max];
int main() {
	scanf("%lld",&n);//输入
	for(int i=1; i<=n; i++)
		scanf("%lld",&a[i]);
	for(int i=1; i<=n; i++)
		scanf("%lld",&b[i]);
	sort(b+1,b+1+n);//排序
	l=1,r=n;
	for(int i=2; i<n; i++)//记录ans数组
		if(a[i-1]<a[i]&&a[i]>a[i+1])
			ans[i]=b[r--];
		else if(a[i-1]>a[i]&&a[i]<a[i+1])
			ans[i]=b[l++];
	if(a[1]<a[2]) ans[1]=b[l++];//特判
	else ans[1]=b[r--];
	if(a[n-1]>a[n]) ans[n]=b[l++];
	else ans[n]=b[r--];
	for(int i=2; i<n; i++)
		if(!ans[i]&&a[i]<a[i+1])
			ans[i]=b[l++];
		else if(!ans[i]&&a[i]>a[i+1])
			ans[i]=b[r--];
	for(int i=2; i<=n; i++)
		sum+=abs(ans[i]-ans[i-1]);//统计权值
	printf("%lld\n",sum);//输出
	for(int i=1; i<=n; i++)
		printf("%lld ",ans[i]);
	return 0;
}
```



---

## 作者：囧仙 (赞：0)

## 题解

套路题。

考虑一段单调不减的序列 $a=\{a_1,a_2,\cdots,a_k\}$，那么可以发现它的权值 $\sum_{i=1}^{k-1}|a_{i+1}-a_i|=\sum_{i=1}^{k-1}(a_{i+1}-a_i)=a_{k}-a_1$；同理，如果它单调不增，它的权值就是 $a_1-a_k$。

这启发我们将 $A$ 数组划分成若干个单调序列。考虑样例 $2$，

$$9\quad 5\quad 1\quad 2\quad 6\quad 7\quad 4\quad 18\quad 20\quad 12$$

划分后变成了这个模样：

$$\begin{aligned}\underline{9\quad 5\quad 1}\quad 2\quad 6\quad \underline{7\quad 4}\quad 18\quad \underline{20\quad 12}\cr 9\quad 5\quad \underline{1\quad 2\quad 6\quad 7}\quad \underline{4\quad 18\quad 20}\quad 12\end{aligned}$$

对于 $x\in[2,n-1]$，若 $A_{x-1}<A_x<A_{x+1}$，就称第 $x$ 个位置为山峰；若 $A_{x-1}>A_x<A_{x+1}$，则称第 $x$ 个位置为山谷。容易发现，若 $x$ 位置为山峰，则它对答案的贡献为 $2\times B'_{x}$；若第 $x$ 位置为山谷，则它对答案的贡献为 $-2\times B'_x$。接着还要考虑 $1$ 和 $n$ 这两个特殊位置。如果 $A_1>A_2$，那么 $1$ 位置的贡献为 $B'_1$；否则为 $-B'_1$。如果 $A_n>A_{n-1}$，那么 $n-1$ 位置的贡献为 $B'_{n-1}$，否则为 $-B'_{n-1}$。非常贪心的思路是，把 $B$ 排序，然后从大到小取数填到山峰上，如果 $A_1$ 或者 $A_n$ 大于相邻的元素则继续填充到该位置；从小到大取数填到山谷里，如果 $A_1$ 或者 $A_n$ 小于相邻的元素则继续填充到该位置。对于剩下来的数字（假设还剩下 $B_l,B_{l+1},\cdots B_r$ 这些元素），从左到右扫一遍，若 $A_{i-1}<A_i$ 就填 $B_l$，并令 $l\gets l+1$；若 $A_{i-1}>A_i$ 就填 $B_r$，并令 $r\gets r-1$。容易发现这样的正确性。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e5+3;
int A[MAXN],B[MAXN],C[MAXN],n,l,r;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int P[MAXN],Q[MAXN],p,q; i64 ans;
int main(){
    n=qread(),l=1,r=n;
    up(1,n,i) A[i]=qread();
    up(1,n,i) B[i]=qread(); sort(B+1,B+1+n);
    up(2,n-1,i){
        if(A[i]>A[i-1]&&A[i]>A[i+1]) P[++p]=i;
        if(A[i]<A[i-1]&&A[i]<A[i+1]) Q[++q]=i;
    }
    if(A[1]>A[1+1]) P[++p]=1;
    if(A[n]>A[n-1]) P[++p]=n;
    if(A[1]<A[1+1]) Q[++q]=1;
    if(A[n]<A[n-1]) Q[++q]=n;
    up(1,p,i) C[P[i]]=B[r--];
    up(1,q,i) C[Q[i]]=B[l++];
    up(1,n,i) if(!C[i]){
        if(A[i]>A[i-1]) C[i]=B[l++]; else 
        if(A[i]<A[i-1]) C[i]=B[r--]; 
    }
    up(2,n,i) ans+=abs(C[i]-C[i-1]);
    printf("%lld\n",ans);
    up(1,n,i) printf("%d%c",C[i]," \n"[i==n]);
    return 0;
}
```

---


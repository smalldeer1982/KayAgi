# [COCI 2011/2012 #4] BROJ

## 题目描述

求最小质因数为 $P$ 的不超过 $10^9$ 的第 $N$ 小正整数。

## 说明/提示

**【数据规模与约定】**

- 对于 $30\%$ 的数据，输出小于 $10^5$（含 $0$）。
- 对于另外 $30\%$ 的数据，$P \gt 1000$。
- 对于 $100\%$ 的数据，$1 \le N,P \le 10^9$。

**【提示与说明】**

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 5 BROJ_。**

**本题分值按 COCI 原题设置，满分 $140$。**

## 样例 #1

### 输入

```
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3```

### 输出

```
9```

## 样例 #3

### 输入

```
1000 1000003```

### 输出

```
0```

# 题解

## 作者：whx2009 (赞：13)

### [传送门](https://www.luogu.com.cn/problem/P8084)
# 本题思路：
这道题我们可以试一下暴力，一个一个去枚举计算 $P$ 的倍数，中途再判断一下这个数是否最小的公倍数是 $P$，过程中进行判定，如果超了就直接输出 $-1$，这样暴力就可以输出大部分答案。这样写必然是会超 $1$ 个样例的时间，但是可以开 O2 过。
# 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,num;//n，p见题目中，num为答案 
int main()
{
	cin>>n>>p;
	if(p*n>1000000000)//如果p的n倍已经超过了边界，直接输出0，否则浪费时间
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++)//枚举答案 
	{
		num+=p;//每次加上一个p，向前推进 
		if(num>1000000000)//如果超过了，直接输出0 
		{
			cout<<0;
			return 0;
		}
		for(int j=2;j<p;j++)//判断是否是最小因数 
		{
			if(num%j==0)
			{
			   i--;//如果是就不算这个答案 
			   break;
			}
		}
	}
	cout<<num;//输出答案	
	return 0;//完结撒花！！！ 
}

```

**请勿抄袭，用此方法请记得开洛谷的 O2 优化。**

---

## 作者：囧仙 (赞：11)

## 题解

根据这题的数据范围（存在 $p>10^3$ 这样的奇怪的限制），大胆猜测这题是二合一。实际上这也是。下文令 $v=10^9$。

### $p$ 特别大时

容易发现 $p^2>10^9$ 时，当且仅当 $n=1$ 时存在解，为 $p$。因此下文考虑 $p\le \sqrt{10^9}$ 的情况。

### $p$ 较大时

最终的结果一定是形如 $p\times q$ 的模样。那么 $q$ 必然在 $\left[1,\left\lfloor\dfrac{v}{p}\right\rfloor\right]$ 内。另外一个限制是，$q$ 不含有小于 $p$ 的质数。同时符合这两个条件的 $q$ 都是合法的，我们要获取其中第 $n$ 个 $q$。

那么直接拿 $1\sim (p-1)$ 内的质数筛一下区间 $\left[1,\left\lfloor\dfrac{v}{p}\right\rfloor\right]$，在剩下来的数字里取第 $n$ 个作为 $q$，输出 $p\times q$ 即可。时间复杂度**约**为 $\mathcal O\left(\left\lfloor\dfrac{v}{p}\right\rfloor+p\right)$（可能带一个类似于埃氏筛当中 $\log\log v$ 这样的系数，但是考虑到这个系数比较小，~~我也不会算~~，所以这里直接用它估算复杂度了）。

### $p$ 较小时

考虑使用容斥和二分。具体而言，先求出 $1\sim p$ 内所有的质数（包括 $p$。假设有 $m$ 个，分别记为 $p_1,p_2,\cdots$，记为集合 $P$）。容易发现可以二分答案 $x$，并计算 $[1,x]$ 内有多少个符合条件的数字，再与 $n$ 比较。

对于任意正整数 $q$，$[1,x]$ 内含有因子 $q$ 的个数共有 $\left\lfloor\dfrac{x}{q}\right\rfloor$ 个。现在我们要计算仅包含不小于 $p$ 的质因子的个数，那么就是用「因子含有 $p$ 的数的个数」减去「因子含有 $p_1$ 的数的个数」减去「因子含有 $p_2$ 的数的个数」……再加上「因子含有 $p$ 和 $p_1$ 的数的个数」、「因子含有 $p$ 和 $p_2$ 的数的个数」……对于 $P$ 的子集 $P'$，它的贡献为：

$$\left\lfloor\frac{v}{\prod_{p_0\in P'}p_0}\right\rfloor\cdot(-1)^{\left|P'\right|+1}$$
n
需要枚举 $P$ 所有的子集并统计答案，因此这里的复杂度为 $\mathcal O(m\cdot 2^m)$。$m$ 表示 $1\sim p$ 内的质数个数，约为 $\frac{p}{\lg p}$。再加上二分的开销，时间复杂度为 $\mathcal O(\log v\cdot (p/\ln p)\cdot 2^{(p/\ln p)})$。实测大约可以跑到 $p=71$。

---

然后发现 $p\le 71$ 时采用 $p$ 较小的做法，$p>71$ 时采用 $p$ 较大的做法，恰好可以通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,p;
const int T[] ={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79};
bool chk(int t,int x){
    int c=0; up(0,(1<<t)-1,s){
        i64 u=p,v=0;
        up(0,t-1,i) if(s&(1<<i)) u*=T[i],++v;
        c+=(x/u)*((v&1)?-1:1);
    }
    return c>=n;
}
bool pri(int t){
    for(int i=2;i*i<=t;++i) if(t%i==0) return false; return true;
}
const int MAXN=30+3;
int P[MAXN]; bitset<13698630> B;
int main(){
    n=qread(),p=qread();
    if(n==1) printf("%d\n",p),exit(0);
    if(p<=71){
        int t=0,u=0; while(T[t]!=p) ++t;
        dn(29,0,i) if(!chk(t,u|1<<i)) u|=1<<i;
        printf("%d\n",(u+1>1e9)?0:u+1);
    } else if(p<=31622){
        for(int i=2;i<p;++i) if(!B[i]){
            for(int j=1;j<=1e9/p/i;++j) B[i*j]=true;
        }
        for(int i=2;i<=1e9/p;++i) if(!B[i]){
            if(--n==1) printf("%d\n",i*p);
        }
    } else puts("0");
    return 0;
}
```

---

## 作者：Molina (赞：5)

# 题目大意
### [题目传送门](https://www.luogu.com.cn/problem/P8084)
# 思路
## 模拟
输入，特判一下，如果 $ n $ 与 $ p $ 的乘积大于十的九次方，直接输出 $ 0 $。然后进入循环，开始模拟。定义 $ ans $ 每次加上 $ p $（见代码），寻找答案（$ ans $ 必须为 $ p $ 的倍数），再次特判，再开一重循环，检查如果 $ p $ 不为 $ ans $ 的最小质因数，回到循环开始处重新查找（见代码）。最后模拟结束，输出答案。

# 代码来了~
由于数据太大，必须开 O2 才能过，不然会超时。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e9;
int p,n,ans;
int main() {
    cin>>n>>p;//输入
    if(p*n>N){
        cout<<"0"; 
        return 0;
    }//特判，是否大于10的九次方，如大于直接输出0 
    for(int i=1;i<=n;i++){//循环，模拟 
        _://再次查找 
        ans+=p;//找答案，每次加上p 
        if(ans>N){
            cout<<"0";
            return 0;
        }//特判，是否大于10的九次方
        for(int j=2;j<p;j++){
            if(ans%j==0)
                goto _;//goto，至11行 
        }
    }
    cout<<ans;//开心输出 
    return 0;
}
```

---

## 作者：Eason_cyx (赞：4)

一道蓝题，然而并没有什么思维难度。

可以得到一个结论：最小质因数为 $P$ 的数，显然必须是 $P$ 的倍数。

那么这道题就好做了。

在最好的情况下，$N$ 个数最小质因数都为 $P$，此时答案是 $N \times{P}$。其他情况肯定比这个答案要大。所以，初始时，如果 $N \times{P}$ 已经大于 $10^{9}$，那么直接输出 $0$ 并结束程序。

其他情况呢？我们依次枚举就好了，每一次枚举如果大于了 $10^{9}$ 就直接结束程序。

那么，如何判断一个数的最小质因数为 $P$ 呢？简单，我们还是枚举。从 $2$ 到 $P-1$，如果有哪一个数能被当前的数整除，就说明 $P$ 不是这个数的最小质因数。反之，$P$ 就是这个数的最小质因数。

代码实现其实也不难：
```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n,p,num = 0;
    scanf("%d%d",&n,&p);
    if(p * n > 1e9)
    {
        printf("0");
        return 0;
    }
    for(int i = 1;i <= n;i++)
    {
        num += p;
        if(num > 1e9)
        {
            printf("0");
            return 0;
        }
        for(int j = 2;j < p;j++) {
            if(num % j == 0) {
                i--; //这个数的最小质因数不是P，从上一个数重新枚举
                break;
            }
        }
    }
    printf("%d",num);    
    return 0;
}

```

注意要吸口氧才能过哦。

---

## 作者：Kobe_BeanBryant (赞：4)

## 题目大意：
求最小质因数为 $ P $ 的且不超过  $ 10^9 $ 的第 $ N $ 小的正整数为多少。
## 思路：
循环 $ n $ 次，每一次判断是否超过 $ 10^9 $，如果超过，输出 $ 0 $；否则每次 $ num $ 加上 $ p $。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int p,n,num,zs[1000];
int main() {
	scanf("%d%d",&n,&p);
	if(p*n>1000000000){
		printf("0");
		return 0;
	}//特判是否大于1000000000
	for(int i=1;i<=n;i++){
		_://跳回，继续循环 
		num+=p;//每一次num加上p 
		if(num>1000000000){
			printf("0");
			return 0;
		}//特判是否大于1000000000
		for(int j=2;j<p;j++){
			if(num%j==0)
				goto _;//跳到第11行 
		}
	}
	printf("%d",num);//输出答案 
	return 0;
}
```

---

## 作者：_Above_the_clouds_ (赞：3)

# 思路：
求最小质因数为 $P$ 的不超过 $10^9$ 的第 $N$ 小正整数。先判断 $N$ $\times$ $P$ 是否大于 $10^9$，如果成立，最终答案就一定大于 $10^9$，不需要再计算了，直接输出 $0$。如果不成立，只需从 $1$ $\sim$ $N$ 枚举，每次 $ans$ 加上 $P$，判断 $ans$  的最小因数是否为 $P$，如果不是，就需多枚举一次，中途再判断 $ans$ 如果大于 $10^9$ 就输出 $0$，最后输出 $ans$。
# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, p, ans;
bool pd(int k) {//判断最小因数是否为p
	for (int i = 2; i < p; i++)
		if (k % i == 0) return 0;
	return 1;
}
int main() {
	scanf("%d%d", &n, &p);//输入
	if (p * n > 1000000000) return printf("0");//大于1e9直接输出0
	for (int i = 1; i <= n; i++) {//依次枚举
		ans += p;//每次加上p
		if (ans > 1000000000) return printf("0"), 0;//大于1e9直接输出0
		if (!pd(ans)) n++;//多枚举一次
	}
	printf("%d", ans);//输出
	return 0;
}
```



---

## 作者：Jerrywang09 (赞：2)

修改了一处小错误。

### 先说几句

标准的分块决策题。考察筛法、二分、容斥原理。

### 解题思路

答案一定可以表示成 $x\cdot p$ 的形式。要使得 $x\cdot p$ 是第 $k$ 小，即求第 $k$ 小的 $x$，$x$ 不含有小于 $p$ 的质因数。

#### $p$ 比较大

如果 $p$ 比较大，那么显然 $x$ 比较小，类似于埃氏筛法，把所有包含小于 $p$ 的质因数的数全部筛掉，迭代找到第 $k$ 个即可。

#### $p$ 比较小

如果 $p$ 比较小，那么显然 $x$ 比较大，不妨二分 $x$。对于每个二分得到的 $x$，需要知道在 $[1,x]$ 里有多少数 $x$ 不含有小于 $p$ 的质因数。

这时候，因为前提 $p$ 比较小，所以这里可以直接二进制枚举每种质数，使用容斥原理求解。如果您不是很了解 ~~小学奥数~~ 这种做法请看下面。

> 考虑问题：所有 $\in [1,30]$ 的整数中，有多少个数含有质因数 $2,3,5$？
> 
> 含有因数 $2$ 的有 $30\div 2=15$ 个。
> 
> 含有因数 $3$ 的有 $30\div 3=10$ 个。
> 
> 含有因数 $5$ 的有 $30\div 5=6$ 个。
> 
> 含有质因数 $2,3,5$ 的有 $15+10+6=31$ 个。这怎么可能呢？
>
> 其实是有重复算的。例如，含有因数 $2,3$ 的被算了 $2$ 次。我们需要减掉。同理，$31-30\div (2\times 3)-30\div (2\times 5)-30\div (3\times 5)=21$。
>
> 这就结束了吗？含有因数 $2,3,5$ 的 $30$ 最初被加了 $3$ 次，上面又被减了 $3$ 次。所以最终的答案是 $21+30\div (2\times 3\times 5)=22$。
>
> 类比上面的思路，我们可以得出结论：容斥原理 **奇加偶减**。由于我们所需的恰好是相反结果（不含有小于 $p$ 的质因数），所以需要 **奇减偶加**。

详见代码。

### 奉上代码

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define rep(i, s, t) for(int i=(s); i<=(t); ++i)
#define F first
#define S second
#define pii pair<int, int>
#define ll long long
#define all(x) x.begin(), x.end()
#define debug(x) cout<<#x<<":"<<x<<endl;
const int N=100010, M=200010;
using namespace std;

int k, p; 
bool f[20000010];
int m;
int a[16]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};

// 问题转化为 p*x

void solveBig()
{
	int n=1e9/p;											// P很大时X不会很大
	rep(i, 2, p-1)											// 标记最小质因子不是P的
		if(!f[i])
			for(int j=i; j<=n; j+=i)
				f[j]=1;
	rep(i, 1, n)
		if(!f[i])
		{
			k--;
			if(!k)
			{
				printf("%d", i*p); return;
			}
		}
	puts("0");
}

bool ok(int x)
{
	int sum=0;												// sum: <=x的数中不能被<p质数整除的数的个数
	for(int msk=0; msk<(1<<m); ++msk)
	{
		int w=0, s=1;
		rep(i, 0, m-1)
			if(msk&(1<<i))									// 选取msk第i位
				++w, s*=a[i];
		if(w&1) sum-=x/s; else sum+=x/s; 					// 奇减偶加
	}
	return sum>=k;
}

void solveSmall()
{
	m=lower_bound(a, a+16, p)-a;							// 比P小的质数个数
	int l=1, r=1e9/p, ans=0;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(ok(mid)) ans=mid, r=mid-1;
		else l=mid+1;
	}
	printf("%d", ans*p);
}

signed main()
{
	cin>>k>>p;
	if(1ll*k*p>1e9) puts("0"), exit(0);
	if(p>=53) solveBig();									// 分块决策
	else solveSmall();
	
	return 0;
}
```

---

## 作者：Lemon_zqp (赞：2)

### 思路
暴力枚举，是可以过的，但要注意如果 $N×P$ 大于 $10^9$，那么答案也一定大于 $10^9$，直接输出 $0$ 结束即可，否则暴力枚举。就从 $1$ 到 $N$ 暴力枚举，每次答案累加，如果答案大于 $10^9$，那也是直接输出 $0$ 结束。
### 代码
```
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n, p;
	cin >> n >> p;
	if(n * p > 1e9)
	{
		cout << 0;
		return 0;//直接结束 
	}
	int ans = 0;
	for(int i = 1; i <= n; i++)
	{
		ans += p;
        if(ans > 1e9)
        {
            cout << 0;
            return 0;
        }
		for(int j = 2; j < p; j++) 
		{
            if(ans % j == 0) 
			{
                i--; //这个数的最小质因数不是P，从上一个数开始重新枚举
                break;
            }
        }
	}
	cout << ans;
	return 0;
}

```

---

## 作者：watcher_YBH (赞：2)

[[题目]](https://www.luogu.com.cn/problem/P8084)
# 思路：
最小质因数为 $P$ 的第 $N$ 小的数不大于 $10^9$，我们可以得知这个数一定是 $P$ 的倍数，所以这个数一定是不超过 $N \times P$ 的数，则最简单的思路就是 O2 加暴力：因为是 $P$ 的倍数，则枚举是依次加 $P$。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX = 1e9;
int p,n,num;
int main(){
	cin>>n>>p;
	if(p*n > MAX){cout<<0; return 0;}//特判
	for(int i = 1; i<=n; i++){
		if(num+p > MAX){//特判
			cout<<0;
			return 0;
		}
		else num += p;//因为答案一定是p的倍数，所以一次加p
		for(int j = 2; j<p; j++){//验证是不是最小质因数为p 
			if(num%j==0){
				i--;//不是就继续找第i个 
				break;
			}
		}
	}
	cout<<num<<endl;
	return 0;//完美结束~ 
}
```


---

## 作者：zyl0128_alpha (赞：1)

# 思路：
暴力枚举，先特判 $N × P$ 是否大于 $10^9$，如果是的，那就说明答案绝对大于 $ 10^9 $，就直接输出 $0$。如果不是，就从 $1$ 至 $N$ 枚举。每次答案变量（也就是 $ans$）累加 $P$，如果 $ans$ 大于 $10^9$，那么输出 $0$。判断后，看一下该答案最小质因数是否为 $P$。
# 代码：
```
#include<bits/stdc++.h>

using namespace std;

int n,p,ans;
int main(){
	cin>>n>>p;
	if(p*n>1e9){//它们的积都超过了最大值，不做了
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
           if(ans+p>1e9){
			cout<<0;
			return 0;
		}
		ans+=p;
		for(int j=2;j<p;j++){//从2开始
			if(ans%j==0){//除以了一个不满足题意的（即最小质因数<p）
			   i--;
			   break;
			}
		}
	}
	cout<<ans;	
	return 0;
}
```
本蒟蒻第一篇题解，求通过QwQ。

---


# [CEOI 2021] Stones

## 题目背景

译自 CEOI2021 Day2 T1. [Stones](https://hsin.hr/ceoi/competition/ceoi2021_day2_tasks.pdf)。

## 题目描述

Ankica 终于抓住 Branko，但他拒绝给 Ankica 买报纸并且要求自己提出一个新的游戏因为上一个是不公平的。Ankica 故作天真地提出了另一个石子游戏，但 Branko 内心存疑，并决定完全改变它的规则。

游戏包含 $N$ 堆石子，其中第 $i$ 堆有 $a_i$ 个石子，玩家轮流移除一堆石子中的若干个，取到最后一个石子的玩家获胜。

但在该游戏中每个玩家从哪堆石子中取石子是由另一名玩家固定的。

具体来说，游戏的回合数从 $1$ 开始每次递增，增量为 $1$，而游戏将会以如下方式进行：

- 在奇数回合，Branko 将指定一个非空石子堆。Ankica 将移除这堆石子至少一个，至多所有石子。
- 在偶数回合，Ankica 将指定一个非空石子堆。Branko 将移除这堆石子至少一个，至多所有石子。

作为专业的游戏玩家，在 Branko 摆完石子后，Ankica 很快意识到这个游戏对她有必胜策略。

如果你是 Ankica，你能否获胜呢？

#### 交互方式

这是一道交互题，你的程序必须与官方给出的扮演 Branko 的程序交换信息。当然，你的程序应该扮演 Ankica 的角色并确保她能获胜。

你的程序应先从标准输入读入游戏的初始状态。初始状态有两行，第一行包含一个整数 $N$ ，第二行包含 $N$ 个空格隔开的整数，其中第 $i$ 个表示 $a_i$，含义如题面所示。

你的程序应根据现在是奇数或偶数轮给出不同的输出，具体地：

**在奇数轮：**

- 你的程序应先读入一个整数 $k$。如果此时所有的石子堆都是空的，$k=-1$，你应结束程序因为你已经输了。否则 $k\in[1,N]$ ，代表你现在必须从第 $k$ 堆石子取走至少一个至多所有石子。保证第 $k$ 堆石子此时不为空。令当前第 $k$ 堆石子有 $s_k$ 个石子。
- 你的程序应输出一行一个 $[1,s_k]$ 中的整数，代表你从第 $k$ 堆石子希望取走的石子个数，**然后刷新缓冲区**。

**在偶数轮：**

- 你的程序应先输出一个整数 $k$，**然后刷新缓冲区**。如果此时所有的石子堆都是空的，$k$ 应为 $-1$，你应结束程序因为你已经赢了。否则 $k\in[1,N]$，代表你希望 Branko 从第 $k$ 堆石子取石子。你应保证第 $k$ 堆石子此时不为空。令当前第 $k$ 堆石子有 $s_k$ 个石子。
- 你的程序应读入一行一个 $[1,s_k]$ 中的整数，代表 Branko 从第 $k$ 堆石子取走的石子个数。

保证给出的初始状态使得无论 Branko 怎么操作你都有必胜策略。

#### 交互样例1

|    输出     |     输入     |                 解释                  |
| :---------: | :----------: | :-----------------------------------: |
|             | $\texttt{1}$ |          游戏只有一堆石子           |
|             | $\texttt{4}$ |      这一堆石子堆包含 $4$ 个石子      |
|             |  $\texttt1$  | Branko 只能指定 Ankica 从第一堆取石子 |
| $\texttt4$  |              |       Ankica 拿走第一堆所有石子       |
| $\texttt-1$ |              |    现在没有剩余的石子，Ankica 获胜    |

#### 交互样例2

|     输出      |       输入       |               解释                |
| :-----------: | :--------------: | :-------------------------------: |
|               |   $\texttt{3}$   |         游戏有三堆石子          |
|               | $\texttt{1 1 5}$ |  三堆石子依次包含 $1,1,5$ 个石子  |
|               |   $\texttt{3}$   | Branko 指定 Ankica 从第三堆取石子 |
| $\texttt{5}$  |                  |     Ankica 拿走第三堆所有石子     |
| $\texttt{1}$  |                  | Ankica 指定 Branko 从第一堆取石子 |
|               |   $\texttt{1}$   |   Branko 只能拿走第一堆所有石子   |
|               |   $\texttt{2}$   | Branko 指定 Ankica 从第二堆取石子 |
| $\texttt{1}$  |                  |     Ankica 拿走第二堆所有石子     |
| $\texttt{-1}$ |                  |  现在没有剩余的石子，Ankica 获胜  |


## 说明/提示

#### 子任务

令 $M=\max\{a_1,a_2,\dots,a_N\}$。

所有测试点均满足 $1\leq N,M\leq 500$。

各子任务的约束条件如下：

| 子任务 | 分值 |                         约束                          |
| :----: | :--: | :---------------------------------------------------: |
|  $1$   | $12$ |                   $1\leq N,M\leq 7$                   |
|  $2$   | $13$ |           $1\leq N\leq 12$，$1\leq M\leq 500$            |
|  $3$   | $15$ | $1\leq N,M\leq 500$，且 $\forall i,j\in[1,N],a_i=a_j$ |
|  $4$   | $60$ |                 $1\leq N,M\leq 500$                 |

# 题解

## 作者：7KByte (赞：2)

$N$ 堆石子，每次由对手选择一堆，然后自己从对手选的一堆中拿走若干个石子，轮流操作，拿走最后一颗石子即为胜利，求必胜策略。

看起来非常像 Nim 游戏，首先考虑 SG 函数与异或和之类的。

想了半天发现自己方向错了，这完全是个发扬人类智慧的博弈题。

仔细观察一下发现每次选择一堆石子，要么取完，要么剩一个子。如果剩更多的子，再取一次和一次取完本质上没有区别。

所以如果除了当前被指定的一堆外，还剩偶数堆棋子必胜，否则必败。

如果当前堆只有 $1$ 粒石子，那么取完这粒石子，给对手也指定一堆只有 $1$ 粒石子的情况。

否则如果这是最后一堆大于 $1$ 的堆，那么就取完，否则就留下 $1$ 粒让对手取。

这样，如果对手让我们取大于 $1$ 的堆，我们就将这一堆消耗完，否则就消耗两堆 $1$。相当于把最后一堆大于 $1$ 的堆当作 $1$ 来处理，这样一个回合后，$1$ 的堆奇偶性不变，其余堆只会减少。并且每次对手只能取大小为 $1$ 的堆。这样局面就完全被自己掌控了。

时间复杂度 $\mathcal{O}(N^2)$。

```cpp
#define N 505
int n, a[N], cnt;
bool ck(){
	rp(i, n)if(a[i] == 1){
		printf("%d\n", i); fflush(stdout), a[i] = 0;
		int x; read(x); return true;
	}
	return false;
}
int main() {
	read(n); 
	rp(i, n)read(a[i]), cnt += a[i] > 1;
	while(true){
		int x; read(x);
		if(a[x] == 1){
			printf("1\n"), fflush(stdout), a[x] = 0;
			if(!ck())break;
		}
		else{
			if(1 == cnt){
				printf("%d\n", a[x]), fflush(stdout), a[x] = 0;
				if(!ck())break;
			}
			else{
				printf("%d\n", a[x] - 1), fflush(stdout), a[x] = 0;
				printf("%d\n", x), fflush(stdout);
				read(x), cnt--; 
			}
		}
	}
	puts("-1"); fflush(stdout);
	return 0;
}
```

---

## 作者：yx666 (赞：1)

# P8174 Stones 题解
## Part 1：题意
### Part 1.1：题目描述
游戏包含 $N$ 堆石子，其中第 $i$ 堆有 $a_i$ 个石子。你和对手交替指定石子堆 $k$（$a_k\neq0$，对手先指定石子堆），并让对方从石子堆 $k$ 中拿去 $[1,a_k]$ 个石子。拿到最后一个石子的人获胜。

求必胜策略（数据保证你有必胜策略）。

### Part 1.2：交互题读入输出
从标准输入读入游戏的初始状态。初始状态有两行，第一行包含一个整数 $N$ ，第二行包含 $N$ 个空格隔开的整数，其中第 $i$ 个表示 $a_i$。

你的程序应根据现在是奇数或偶数轮给出不同的输出，具体地：

**在奇数轮：**

- 你的程序应先读入一个整数 $k$。如果此时所有的石子堆都是空的，$k=-1$，结束程序，因为你已经输了。否则 $k\in[1,N]$ ，代表你现在必须从第 $k$ 堆石子取走至少一个至多所有石子。保证第 $k$ 堆石子此时不为空。令当前第 $k$ 堆石子有 $s_k$ 个石子。
- 你的程序应输出一行一个 $[1,s_k]$ 中的整数，代表你从第 $k$ 堆石子希望取走的石子个数，**然后刷新缓冲区**。

**在偶数轮：**

- 你的程序应先输出一个整数 $k$，**然后刷新缓冲区**。如果此时所有的石子堆都是空的，$k$ 应为 $-1$，结束程序，因为你赢了。否则 $k\in[1,N]$，代表你希望对手从第 $k$ 堆石子取石子。应保证第 $k$ 堆石子此时不为空。令当前第 $k$ 堆石子有 $s_k$ 个石子。
- 你的程序应读入一行一个 $[1,s_k]$ 中的整数，代表对手从第 $k$ 堆石子取走的石子个数。

保证给出的初始状态使得你有必胜策略。

**刷新缓冲区解释：**

- 如果采用 `cin`、`cout` 读入输出，在每次输出时使用 `cout.flush();` 或 `cout<<endl;`
- 如果采用 `scanf`、`printf` 读入输出，在每次输出时使用 `fflush(stdout);`

## Part 2：思路
### Part 2.0：定义
- $[P]$ 表示能否获胜，$[F]$ 表示是否是自己在取石子。

- 记剩下的石子数等于 $1$ 的石子堆个数为 $n$，石子数大于 $1$ 的石子堆个数为 $n'$，编号为 $i$ 的石子堆石子数为 $a_i$。

### Part 2.1：极端情况
发现：如果没有石子数超过 $1$ 的堆，那么最后的赢家是确定的。

表示为：

$$[P]=\begin{cases}
1&[F]=0,n \bmod 2=0\\
0&[F]=0,n \bmod 2=1\\
0&[F]=1,n \bmod 2=0\\
1&[F]=1,n \bmod 2=1\\
\end{cases}$$

### Part 2.2：一般情况
由一般到特殊，中间的转折点就是仅剩 $1$ 堆大于 $1$ 的石子堆时。

所以我们只需要处理好 $n'\ne1$ 与 $n'=1$ 时就 OK 了。也就是要将最后一堆个数大于 $1$ 的石子堆将轮到我们取。

#### Part 2.2.1：$n'> 1$ 时决策：
目标就是要消耗掉个数大于 $1$ 的石子堆。记对手要求取的堆编号为 $p$。

1. $a_p=1$，拿走 $a_p$ 个。接下来给对手指定一个 $a_i=1$ 的堆 $i$。因为数据保证有必胜策略，而取走偶数个石子数为 $1$ 的堆是不影响结果的，所以可以这样干（也不用担心能否找到）。

2. $a_p>1$，拿走 $a_p-1$ 个，并指定对手拿一个 $a_i=1$ 的堆 $i$（这里可以用 $p$）。这样子就消耗掉个数大于 $1$ 的石子堆，达成目标。

#### Part 2.2.2：$n'=1$ 时决策：
上面已经保证了最后一堆个数大于 $1$ 的石子堆将轮到我们取，所以此时 $[F]=1$。记对手要求取的堆编号为 $p$。

- 如果 $a_p>1$，且 $n\bmod2=1$，取走 $a_p-1$ 个，使情况变为 $[F]=0,n\bmod2=0,n'=0$ 的必胜策略。
    
- 如果 $a_p>1$，且 $n\bmod2=0$，取走 $a_p$ 个，使情况变为 $[F]=0,n\bmod2=0,n'=0$ 的必胜策略。
    
- 否则，$a_p=1$，取走 $1$ 个。

#### Part 2.2.3：$n'=0$ 时决策：
无论对手怎么挣扎都能赢：

每次取都取一个，然后找到一个 $a_i=1$ 的堆 $i$ 让对手取即可。

## Part 3：代码实现
~~改了好久发现自己少打了一个赋值。~~

``` cpp
#include<bits/stdc++.h>
using namespace std;

#define N 505
#define M 505
#define pii pair<int,int>

int n,a[N];
int cnt1=0,cnt2=0;	// cnt1：a_i=1 的石子堆个数，cnt2：a_i>1 的石子堆个数
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	auto get=[](){	// 得到一个 i 满足 a_i=1
		for(int i=1;i<=n;++i)
			if(a[i]==1){
				cout<<i<<endl;
				a[i]=0,--cnt1;
				int tp; cin>>tp;
				return i;
			}
		return -1;
	};
	
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		if(a[i]==1) ++cnt1;
		else if(a[i]>1) ++cnt2;
	}
	
	for(int p;;){
		cin>>p;
		if(a[p]==1){
			// 取石子
			cout<<1<<endl;
			a[p]=0,--cnt1;
			
			// 指定堆
			if(cnt1==0) break;
			p=get();
		}else{
			if(cnt2==1){
				if(cnt1%2){
					cout<<a[p]-1<<endl;
					a[p]=1,++cnt1,--cnt2;
					break;
				}else{
					cout<<a[p]<<endl;
					a[p]=0,--cnt2;
					break;
				}
			}else{
				// 取石子
				cout<<a[p]-1<<endl;
				a[p]=0,--cnt2;
				
				// 指定堆
				cout<<p<<endl;
				cin>>p;
			}
		}
	}
	
	
	// n'=0,[F]=0,n mod 2=0 的必胜策略
	for(int p;;){
		// 指定
		if(cnt1<=0) break;
		p=get();
		
		// 取石子
		cin>>p;
		a[p]=0,--cnt1;
		cout<<1<<endl;
	}
	
	cout<<-1<<endl;
	return 0;
}

```

---

## 作者：wzch (赞：0)

石子数量为 $1$ 的堆与大于 $1$ 的堆有本质区别：若在石子数量为 $1$ 的堆中取数，只能取完。而在石子数大于 $1$ 的堆中取数，可以取到只剩 $1$ 个也可以取光。所以考虑按石子数量分类。

假设当前每堆石子石子数都大于 $1$，考虑这样一种构造：A(Ankica) 被 B(Branko) 指定取某一堆，A 将其取至只剩一颗石子，再指定 B 取该堆，则 B 只能把它取完。只剩一堆的时候，A 将其取光。由此 A 必胜。

现在考虑加入石子数为 $1$ 的堆，由于其取法唯一。考虑这种构造：如果先手被指定取石子数为 $1$ 的石子，那么先手再指定对手取石子数为 $1$ 的石子（如果有的话）。在这种构造下考虑石子数为 $1$ 的堆对局面的影响：如果石子数为 $1$ 的堆的数量为奇数，则先后手交换，胜负也交换。另外要特殊考虑石子数全为 $1$ 的情况。定义(中括号表示艾弗森括号)： $P=[\text{存在石子数大于 1 的堆}],Q=[\text{如果石子数为 1 的堆的数量为奇数}]$

$$[A\text{必胜}]=P\operatorname{xor}Q$$


由于已知 A 必胜，根据上述论断，给出下述取法（总结性的）。

我们可以这样取：若 B 指定我们取数量为 $1$ 的堆或者取数量大于 $1$ 的堆但此时仅有该堆数量大于 $1$，取光。反之，取至只剩 $1$ 颗石子。

同时，我们应该这样指定 B：取石子数量为 $1$ 的某堆（概括得到）。

代码：
```cpp
using namespace std;
#include<bits/stdc++.h>
#define For(i, l, r) for(int i=(l);i<=(r);++i)
#define Rfor(i, r, l) for(int i=(r);i>=(l);--i)
#define O(x) cerr<<#x<<":"<<x<<endl
#define OO(x,y) cerr<<#x<<":"<<x<<" "<<#y<<":"<<y<<endl
#define OOO(x,y,z) cerr<<#x<<":"<<x<<" "<<#y<<":"<<y<<" "<<#z<<":"<<z<<endl
#define LO(a, l, r) For(supervariable, l, r)cerr<<a[supervariable]<<" ";cerr<<"\n"
#define FS(v,V,u,fa) for(int v:V[(u)])if(v!=(fa))
#define FENGE cerr<<"----------------------------------------------------------"<<endl
int read(){int x=0,t=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')t=-t;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();return x*t;}
const int N=505;
int a[N];
int main()
{
	int n=read();
	For(i, 1, n)a[i]=read();
	int i=0;
	bool flag;int lst;
	while(1)
	{
		++i;
		if(i&1)
		{
			int k=read();
			if(a[k]==1)printf("1\n"),flag=0,a[k]=0;
			else
			{
				int cnt=0;
				For(i, 1, n)if(a[i]>1)++cnt;
				if(cnt==1)printf("%d\n",a[k]),a[k]=0,flag=0;
					else printf("%d\n",a[k]-1),flag=1,a[k]=1;
			}
			lst=k;
			fflush(stdout);
		}
		else
		{
			bool flag2=1;
			For(i, 1, n)if(a[i])flag2=0;
			if(flag2){printf("-1\n");fflush(stdout);return 0;}
			if(flag){printf("%d\n",lst);a[lst]=0;}
			else
			{
				For(i, 1, n)
					if(a[i]==1){printf("%d\n",i);a[i]=0;break;}
			}
			fflush(stdout);
			read();
		}
	}
}
```

---


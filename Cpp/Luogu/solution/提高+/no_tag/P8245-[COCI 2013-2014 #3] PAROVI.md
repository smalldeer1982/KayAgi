# [COCI 2013/2014 #3] PAROVI

## 题目描述

定义两个整数 $A,B$ 之间的**距离**为这两个整数所有对应位上的数的差的绝对值之和，记为 $\operatorname{dist}(A,B)$。特别地，如果 $A,B$ 两数的位数不相同，则在位数较小的数前补足前导 $0$。例如：

- $\operatorname{dist}(4561,3278)=\left|4-3\right|+\left|5-2\right|+\left|6-7\right|+\left|1-8\right|=12$。
- $\operatorname{dist}(32,5678)=\left|0-5\right|+\left|0-6\right|+\left|3-7\right|+\left|2-8\right|=21$。

现在，给定两个整数 $L,R$，请你求出所有在区间 $[L,R]$ 内的整数对的距离和。由于答案可能很大，因此**请对 $\bf 10^9+7$ 取模**。

## 说明/提示

**【样例 2 解释】**

所有在区间 $[288,291]$ 内的整数对的距离如下：

- $\operatorname{dist}(288,289)=\operatorname{dist}(289,288)=1$。
- $\operatorname{dist}(288,290)=\operatorname{dist}(290,288)=9$。
- $\operatorname{dist}(288,291)=\operatorname{dist}(291,288)=8$。
- $\operatorname{dist}(289,290)=\operatorname{dist}(290,289)=10$。
- $\operatorname{dist}(289,291)=\operatorname{dist}(291,289)=9$。
- $\operatorname{dist}(290,291)=\operatorname{dist}(291,290)=1$。

因此距离和为 $2\times (1+9+8+10+9+1)=76$。

**【数据范围与限制】**

对于 $20\%$ 的数据，满足 $A,B\leqslant 10^4$。  
对于 $40\%$ 的数据，满足 $A,B\leqslant 10^{100}$。  
对于所有数据，$1\leqslant A\leqslant B\leqslant 10^{50000}$。

**【题目来源】**

本题来源自 **_[COCI 2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 3](https://hsin.hr/coci/archive/2013_2014/contest3_tasks.pdf) T5 PAROVI_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
1 5```

### 输出

```
40```

## 样例 #2

### 输入

```
288 291```

### 输出

```
76```

## 样例 #3

### 输入

```
1000000 10000000```

### 输出

```
581093400```

# 题解

## 作者：ybe2007 (赞：6)

一道有趣的计数题。

首先题面中最引人注目的就是两个整数的数据范围。很显然，**暴力的思路，枚举所有数**，找出每一位上每一种数字的个数这种方法是不可行的。

现在我们来思考一下暴力解法的瓶颈。如果我们延续“找出每一位上每一种数字的个数”这种思路的话，就必须舍去枚举所有数的过程，用高效的方式求解。

先设 $f_{x,i}$ 表示 $L$ ~ $R$ 区间内，第 $x$ 位，数字为 $i$ 的数的个数。一开始想到数位 $\texttt{dp}$，进而发现该数组显然是满足区间可减性的。所以考虑分开计算两部分，那么重点即在于计算 $1$ ~ $n$ 中每一位数字为 $i$ 的个数。

一下可能没有什么直观的思路，所以可以模拟一下一些数据观察其特性。这里直接给出结论，当然在此之前强烈建议先自己尝试模拟一下。

对于第 $x$ 位的数，若 $n$ 在这一位上的数字是 $s_i$，那么对于这一位上的某一种待统计的数字 $a$：

1. 若 $a\lt s_i$，则 $cnt=(pre_{i-1}+1)\times 10^{len-i}$。

2. 若 $a=s_i$，则 $cnt=pre_{i-1}\times 10^{len-i}+(suf_{i+1}+1)$。

3. 若 $a\gt s_i$，则 $cnt=pre_{i-1}\times 10^{len-i}$。

上述等式中，$pre_i$ 表示首位至第 $i$ 位的所有位的数字顺序排列构成的数，$suf_i$ 表示第 $i$ 位至末位的所有位的数字顺序排列构成的数。

剩下的就是最后统计答案了，求出 $f$ 数组后暴力枚举每一位上的两个数，直接计算即可。

这题的关键在于**发现 $f$ 数组的区间可减性**。另外，以后看到这种类似的统计数位个数的题就可以直接明确统计思路了，算是总结吧。

---

## 作者：JimmyLee (赞：0)

# 题意

> 定义两个整数 $A,B$ 之间的**距离**为这两个整数所有对应位上的数的差的绝对值之和，记为 $\operatorname{dist}(A,B)$。特别地，如果 $A,B$ 两数的位数不相同，则在位数较小的数前补足前导 $0$。
> 
> 现在，给定两个整数 $L,R$，请你求出所有在区间 $[L,R]$ 内的整数对的距离和。**请对 $\bf 10^9+7$ 取模**。

# 分析

考虑记录在每一个数位上每个数出现了多少次。

令 $cnt_{i,j}$ 表示第 $i$ 位上数码 $j$ 出现了多少次。

这样我们就可以枚举数码 $j$ 以统计答案，答案即为：

$$
2\cdot\sum_{i=1}^{\text{len}(R)}\sum_{j=0}^9\sum_{k=j+1}^9(k-j)\times cnt_{i, j}\times cnt_{i, k}
$$

我们只需要解决 $cnt$ 的计数问题就行了。

首先将问题转化为求 $[0, L-1]$ 和 $[0, R]$ 各数码在每一位出现的次数，二者相减即是答案区间 $[L, R]$。

上面所求的可以使用数位 dp 解决。

时间复杂度 $O(\log R)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007

int64_t ksm(int64_t x, int l)
{
    int64_t ret=1;
    for(;l;l>>=1, x=x*x%mod)
        if(l&1) ret=ret*x%mod;
    return ret;
}

int64_t cnt[50004][10];
int64_t tag[50004];

int64_t calc(const string &s, int p, int op)
{
    if(p<0) return 1;
    int64_t mx=s[p]^48;
    int64_t w=ksm(10, p);
    if(p) tag[p-1]=((tag[p-1]+op*ksm(10, p-1)*mx)%mod+mod)%mod;
    for(int i=0;i<mx;i++) cnt[p][i]=((cnt[p][i]+w*op)%mod+mod)%mod;
    int64_t ret=mx*w%mod;
    int64_t tmp=calc(s, p-1, op);
    cnt[p][mx]=((cnt[p][mx]+tmp*op)%mod+mod)%mod;
    return (ret+tmp)%mod;
}

string a, b;

void reduce(string &s)
{
    reverse(s.begin(), s.end());
    for(auto &c:s)
    {
        if(c^48) {c--; break;}
        c='9';
    }
    if(s.back()=='0') s.pop_back();
    reverse(s.begin(), s.end());

}

int main()
{
    cin>>a>>b;
    reduce(a);
    reverse(b.begin(), b.end());
    reverse(a.begin(), a.end());
    while(a.size()<b.size()) a.push_back('0');
    calc(b, b.size()-1, 1);
    calc(a, a.size()-1, -1);
    for(int i=b.size()-1;~i;i--)
    {
        tag[i]=(tag[i]+tag[i+1])%mod;
        for(int j=0;j<10;j++)
            cnt[i][j]=(cnt[i][j]+tag[i])%mod;
    }
    int64_t ans=0;
    for(int i=b.size()-1;~i;i--)
        for(int j=0;j<10;j++)
            for(int k=j+1;k<10;k++)
                ans=(ans+(k-j)*cnt[i][j]%mod*cnt[i][k])%mod;
    cout<<ans*2%mod;
}
```

---


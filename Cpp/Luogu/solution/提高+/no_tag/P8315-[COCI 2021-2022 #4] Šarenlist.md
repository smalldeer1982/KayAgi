# [COCI 2021/2022 #4] Šarenlist

## 题目背景

温暖的夏夜，Vito 和他的好朋友 Karlo 躺在森林的空地上看星星。突然，Vito 大喊：“Karlo，你看！我们周围的树都在变色！”“哇，真是五彩缤纷！”Karlo 惊讶地说。的确，森林中的树枝开始变色。

## 题目描述

Vito 和 Karlo 被这些彩色的树迷住了，他们同时也注意到了一些事物。他们正在看的每棵树都可以看做是一个树图，即任意两点之间仅存在一条路径的无向图。他们正在看的每棵树都有这样的特点：每条边上的颜色都是 $k$ 种颜色中的一种。如果树上的一个路径是彩色的，意味着这条路径上至少包含两种不同颜色的边。

早上树的魔力全部消失了。Vito 和 Karlo 还记得 $m$ 条彩色路径的起点和终点。他们想知道：满足条件的树的有多少种可能？由于答案可能很大，所以请将答案对 $10^9+7$ 取模。

## 说明/提示

**【样例 1 解释】**

第一种情况是点 $1$ 和点 $2$ 之间的边涂颜色 $1$，点 $2$ 和点 $3$ 之间的边涂颜色 $2$。

第二种情况是点 $1$ 和点 $2$ 之间的边涂颜色 $2$，点 $2$ 和点 $3$ 之间的边涂颜色 $1$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$m = 1$。
- Subtask 2（15 pts）：$m = 2$。
- Subtask 3（10 pts）：每个树边最多属于 $m$ 条彩色路径中的一条。
- Subtask 4（10 pts）：$1 ≤ n ≤ 15, k = 2$。
- Subtask 5（65 pts）：没有额外限制。

对于 $100\%$ 的数据，$3 ≤a_i,b_i, c_j , d_j ≤ n ≤ 60, 1 ≤ m ≤ 15, 2 ≤ k ≤ 10^9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T5  Šarenlist。**

## 样例 #1

### 输入

```
3 1 2
1 2
2 3
1 3
```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3 2
1 2
2 3
4 2
1 4
1 3
4 3
```

### 输出

```
0```

## 样例 #3

### 输入

```
4 3 3
1 2
2 3
4 2
1 4
1 3
4 3```

### 输出

```
6```

# 题解

## 作者：Y_ATM_K (赞：12)

### [P8315 [COCI2021-2022#4] Šarenlist](https://www.luogu.com.cn/blog/Y-ATM-K-NB-666/solution-p8315)
## 分析
首先合法路径上至少有两条边颜色不同，这不太好统计，我们可以反过来想：

**合法方案数 = 总方案数 - 不合法的方案数**

总方案数显然是 $k^{n-1}$, 考虑计算不合法方案数。

先考虑 $m=1$ 的情况：

显然，不合法方案的这一条路径上的颜色都是相同的，我们就想到像缩点一样，把这一条路径的边缩成一条边，这样不合法方案数就好算了，设这一条路径包含 $c$ 条边，则不合法方案数为 $k^{n-c}$。

然而，如果 $m\geq2$，这样算会重复计算多条路径同时不合法的方案，我们发现 $n\leq60,m\leq15$，这么小！于是可以直接暴力枚举容斥。

具体来说，就是枚举不合法路径的集合 $S$，对于每条路径，把它所有边合并到某一条边上（如果路径有相交，当然是合并成一条边了）。然后统计合并后的边数 $cnt$，当 $|S|$ 为偶数，让答案加上 $cnt$， 当 $|S|$ 为奇数，让答案减去 $cnt$，枚举路径集合可以直接状态压缩，合并可以用并查集实现，时间复杂度为 $O(nm2^m)$，具体细节看代码。

## 代码
```cpp
#include <bits/stdc++.h>
#define N 650
#define M 1500
#define ll long long//记得开long long
using namespace std;
const ll mod=1e9+7;
int n,m;
ll k;
int tot,first[N],nxt[M],ver[M];
void add(int s,int e) {
	nxt[++tot]=first[s];
	first[s]=tot;
	ver[tot]=e;
}
int id[M],idc;
int s[N],t[N];
void init() {
	for(int i=1;i<n;++i) {
		int s,e;
		scanf("%d%d",&s,&e);
		add(s,e),add(e,s);
		id[tot]=id[tot-1]=++idc;//给边编号方便存路径
	}
	for(int i=1;i<=m;++i) {
		scanf("%d%d",&s[i],&t[i]);
	}
}
int road[N][N],cr[N];//road存路径
bool dfs(int now,int u,int T,int fa) {
	if(now==T) {
		return 1;
	}
	for(int i=first[now];i;i=nxt[i]) {
		int v=ver[i];
		if(v==fa) continue;
		if(dfs(v,u,T,now)) {
			road[u][++cr[u]]=id[i];
			return 1;
		}
	}
	return 0;
}
int fa[N];//并查集
void reset() {
	for(int i=1;i<=idc;++i) {
		fa[i]=i;
	}
}
int get(int p) {
	if(fa[p]==p) return p;
	return fa[p]=get(fa[p]);
}
void merge(int x,int y) {
	fa[get(x)]=get(y);
}
bitset<N> vis;
ll powk[N],ans;
int main() {
	scanf("%d%d%lld",&n,&m,&k);
	init();
	for(int i=1;i<=m;++i) {
		dfs(s[i],i,t[i],0);
	}
	powk[0]=1;
	for(int i=1;i<=n;++i) {
		powk[i]=powk[i-1]*k%mod;//预处理k的幂
	}
	int ed=1<<m;
	ans=powk[n-1];
	for(int i=1;i<ed;++i) {//状态压缩
		int cnt=0,c1=0;//cnt存缩边后边数，c1表示统计了几条路径
		reset();
		vis.reset();
		for(int j=0;j<m;++j) {
			if((i>>j)&1) {
				c1++;
				for(int k=2;k<=cr[j+1];++k) {
					merge(road[j+1][k],road[j+1][1]);
              //把路径上的边合并到第一条边上
				}
			}
		}
		for(int j=1;j<=idc;++j) {
			if(!vis[get(j)]) {
				vis[get(j)]=1;
				cnt++;
			}
		}
		if(c1&1) {
			ans=(ans-powk[cnt]+mod)%mod;
		} else {
			ans=(ans+powk[cnt])%mod;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：luogu_gza (赞：6)

考虑一个容斥。

定义 $f(i)$ 表示状态为 $i$ 的路径不合法，其他的随便的方案数。

根据经典容斥可以得出答案为下列柿子。

$$\sum (-1)^{\operatorname{popcount}(i)}f(i)$$

可以发现不合法的必须一样，其他的随意，所以 $f(i)$ 就是 $k$ 的“非路径边数”加“路径连通块个数”加“未钦定的路径边数”次方。

代码细节很多，这里放上极其丑陋的考场（模拟赛）代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define MT int TTT=R;while(TTT--)
#define pc putchar
#define R read()
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define rep(i,a,b) for(int i=a;i>=b;i--)
#define m1(a,b) memset(a,b,sizeof a)
namespace IO
{
	inline int read()
	{
	    int x=0;
	    char ch=getchar();
	    bool f=0;
	    while(!isdigit(ch)){if(ch=='-') f=1;ch=getchar();}
	    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	    if(f) x=-x;
	    return x;    
	}
	template<typename T> inline void write(T x)
	{
	    if(x<0)
	    {
	        pc('-');
	        x=-x;
	    }
	    if(x>9) write(x/10);
	    pc(x%10+'0');
	}
}; 
using namespace IO;

const int N=80,mod=1e9+7;
int n,m,k,res,tmp,Sum;
vector<int> g[N];
int c[N],d[N];
int vis[N],viss[N],lj[N];
int dep[N],fa[N];
int p[N];
int qmi(int a,int b,int p)
{
	int res=1;
	while(b)
	{
		if(b&1) res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
void dfs(int u,int Fa)
{
	for(auto j:g[u]) if(j!=Fa)
	{
		dep[j]=dep[u]+1;
		fa[j]=u;
		dfs(j,u);
	}
}
int find(int x)
{
	return p[x]==x?x:p[x]=find(p[x]);
}
void color(int* t,int u,int v,int typ,int now)
{
	if(dep[u]<dep[v]) swap(u,v);
	int x=u,y=v;
	while(dep[x]>dep[y]) x=fa[x];
	while(x!=y) x=fa[x],y=fa[y];
	bool flag=0;
	while(u!=x)
	{
		if(t[u]&&find(t[u])!=find(now)) p[find(t[u])]=find(now),Sum--;
		t[u]=now,u=fa[u];
	}
	while(v!=x)
	{
		if(t[v]&&find(t[v])!=find(now)) p[find(t[v])]=find(now),Sum--;
		t[v]=now,v=fa[v];
	}
	if(flag) Sum--;
	if(typ) t[x]=now;
}
signed main(){
	n=R,m=R,k=R;
	fo(i,2,n)
	{
		int u=R,v=R;
		g[u].pb(v),g[v].pb(u);
	}
	dep[1]=1,dfs(1,-1); 
	fo(i,1,m) c[i]=R,d[i]=R,color(lj,c[i],d[i],0,1);
	fo(i,1,m) color(viss,c[i],d[i],0,1);
	fo(i,2,n) if(!viss[i]) tmp++;
	fo(st,0,(1<<m)-1)
	{
		m1(vis,0),m1(viss,0);
		fo(i,1,m) p[i]=i;
		int sum=0;
		fo(i,1,m) if(st>>(i-1)&1) color(vis,c[i],d[i],0,i);
		fo(i,1,m) p[i]=i;
		Sum=__builtin_popcount(st);
		fo(i,1,m)
		{
			if(st>>(i-1)&1) color(viss,c[i],d[i],0,i);
//			fo(j,1,n) cout<<viss[j]<<' ';
//			cout<<endl;
		}
		fo(i,1,n) if(lj[i]&&!vis[i]) sum++;
		sum+=Sum;
//		fo(i,1,n) cout<<vis[i]<<' ';
//		cout<<endl;
//		fo(i,1,m) cout<<(st>>(i-1)&1); 
//		cout<<' '<<sum<<endl;
		if(__builtin_popcount(st)&1) res-=qmi(k,sum,mod);
		else res+=qmi(k,sum,mod);
		res=(res%mod+mod)%mod;
	}
	write(res*qmi(k,tmp,mod)%mod);
}
```

第五次模拟赛场切紫，感动了。

---

## 作者：honglan0301 (赞：5)

## 题目分析

好像挺简单的？正难则反，我们发现一条路径上的边颜色「全都相同」要比「不全相同」简单得多，因为前者可以视为该路径上的每条边都与该路径上的第一条边颜色相同，这很方便用并查集维护。

看数据范围这么小，于是容斥一下，记路径集合为 $S$，一个集合 $T$ 中每条路径颜色均相同的方案数为 $f_T$，于是答案为 $k^{n-1}+\sum\limits_{S'∈S} (-1)^{|S'|}\times f_{S'}$。而 $f_T$ 只需按前面说的，对于每条路径都把该路径上的每条边与第一条边合并，表示这些路径上的每条边颜色必须与第一条边相同，那么合并之后有且仅有 $fa_i=i$ 的边可以任意取色，于是结束了。单次求 $f_T$ 时间复杂度 $O(nm)$, 总时间复杂度 $O(nm\times 2^m)$，可以通过本题。

## 代码

感觉我代码写得还挺简洁的。

```cpp
/*
  author: PEKKA_l  
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
#define int long long
#define mod 1000000007

int n,m,k,u,v,ans,cf[65],fa[65];
map <pair<int,int>,int> mp;
vector <int> e[65],lj[25];

bool dfs(int x,int to,int fat,int num)
{
	if(x==to) return 1;
	for(auto i:e[x]) {if(i==fat) continue; if(dfs(i,to,x,num)) {lj[num].push_back(mp[make_pair(x,i)]); return 1;}}
		return 0;
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int calc(int x)
{
	for(int i=1;i<=n-1;i++) fa[i]=i; int ncnt=0;
	for(int i=1;i<=m;i++) if(x&(1<<(i-1))) for(auto j:lj[i]) fa[getfa(j)]=getfa(lj[i][0]);
	for(int i=1;i<=n-1;i++) ncnt+=fa[i]==i; return ncnt;
}

signed main()
{
	cin>>n>>m>>k; cf[0]=1; for(int i=1;i<=n;i++) cf[i]=cf[i-1]*k%mod;
	for(int i=1;i<=n-1;i++) {cin>>u>>v; mp[make_pair(u,v)]=mp[make_pair(v,u)]=i; e[u].push_back(v); e[v].push_back(u);}
	for(int i=1;i<=m;i++) {cin>>u>>v; dfs(u,v,u,i);}
	for(int i=0;i<(1<<m);i++) {ans+=((__builtin_popcount(i)&1)?-1:1)*cf[calc(i)]+mod; ans%=mod;} cout<<ans<<endl;
}
```


---

## 作者：LINCE (赞：3)

### 分析

显然，直接求解难，不妨先求不可行的方案，从总数中减去。

对于每一条路径，设它上面有 $s$ 条边，则可以得到有 $k^{n-s}$ 种不可行的方案（因为 $s$ 条边在不可行方案中一定是同色，所以可以合并，加上 $n-1-s$ 条非路径边，共是 $k^{n-s}$ 种方案）。

那么，有一个问题：有些方案会被重复计算。

于是需要 $O(2^m)$ 的时间复杂度去进行容斥。

假设有两条路径，已单独计算。

因为相重叠的路径必定是同色（重复计算的一定是同色方案），所以两条路径可以合并为一个连通块。

此时就可以想到用并查集去维护连通块数量。

加上快速幂，就可以解决本题。

总时间复杂度：$O(2^m(mn\alpha(n)+n+\log n))$(枚举容斥状态 $O(2^m)$，枚举路径 $O(m)$，合并边 $O(n\alpha(n))$，计算连通块 $O(n)$，快速幂 $O(\log n)$)。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a,b,s,t,cnt,sum,c[16],d[16],f[61][10],l[16],dis[61],dep[61],head[61],fat[61];
long long mod=1e9+7,ans,g;
struct node{
	int next,to;
}e[121];//链式前向星
void add(int x,int y){
	e[++cnt].next = head[x];
	e[cnt].to = y;
	head[x] = cnt;
}//建边
void dfs(int x,int fa){
	f[x][0] = fa;
	dep[x] = dep[fa] + 1;
	for(int i = head[x] ; i ; i = e[i].next ){
		int y = e[i].to;
		if(y != fa){
			dis[y] = dis[x]+1;
			dfs(y,x);
		}
	}
}//用于LCA预处理
int lca(int x,int y){
	if(dep[x] < dep[y]) swap(x,y);
	int p = 6;
	while(~p){
		if( dep[f[x][p]] >= dep[y] ) x = f[x][p];
		p--;
	}
	if(x == y) return x;
	p = 6;
	while(~p){
		if(f[x][p] != f[y][p]) x = f[x][p],y = f[y][p];
		p--;
	}
	return f[x][0];
}//最近公共祖先的计算
int find(int x){
	if (fat[x] != x)return fat[x] = find(fat[x]);
	return x;
}//并查集基本操作
long long ksm(int mi){
	long long res = k,ll = 1;
	while(mi){
		if(mi & 1)ll = ll * res % mod;
		res = res * res % mod,mi >>=1;
	}
	return ll;
}//快速幂
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for(int i = 1;i < n;i++){
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	dfs(1,0);
	for(int i = 1;i <= 6;i++){
		for(int j = 1;j <= n;j++){
			f[j][i] = f[f[j][i-1]][i-1];
		}
	}
	for(int i=1;i<=m;i++){
		cin>>c[i]>>d[i];
		l[i] = lca(c[i],d[i]);
	}
	ans = ksm(n-1);
	for(int i = 1;i < (1<<m);i++){
		g = 1,sum = 0;
		for(int j = 2;j <= n;j++){
			fat[j] = j;
		}//并查集初始化
		for(int j = 0;j < m;j++){
			if(i>>j&1){
				g = -g;//为了计算容斥时的正负性
				s = c[j+1];
				while(s != l[j+1]){
					if(f[s][0] == l[j+1])break;
					a = find(s),b = find(f[s][0]);
					if(a != b)fat[a] = b;//合并边
					s = f[s][0];
				}//从一段跳到LCA
				t = d[j+1];
				while(t != l[j+1]){
					if(f[t][0] == l[j+1])break;
					a = find(t),b = find(f[t][0]);
					if(a != b)fat[a] = b;
					t = f[t][0];
				}//从另一端跳到LCA
				if(s != l[j+1] && t != l[j+1]){
					a = find(s),b = find(t);
					if(a != b)fat[a] = b;
				}//如果两者都不是LCA，则LCA下路径中的两条边也应合并到一起
			}
		}
		for(int j = 2 ;j <= n;j++){
			if(fat[j] == j)sum++;
		}//计算连通块数量
		ans = (ans + g * ksm(sum)) % mod;
	}
	ans = ( ans % mod + mod ) %mod;//防止ans变成负数
	cout<<ans;
}
```


---

## 作者：slzx2022YuYihan (赞：2)

# At the top

顶着厚脸皮来写这篇题解，因为赛时正解只能想到一半，这篇题解就当作是做题笔记了。

在这里也特别感谢赛后[gza 巨佬](https://www.luogu.com.cn/user/301255)给我的指点。

# Notes

### $Sub1+Sub3$

考虑树上差分，知道每条边被算了几次，没算的边拎出来，记为 $cnt$。对于一条路径 $u,v$，合法情况就是 $k^{dis(u,v)}-k$，全部相乘，最后再乘上 $k^{cnt}$。

### $Sub4$

直接暴搜每条边，统计答案。

[30pts 赛时代码](https://www.luogu.com.cn/paste/cjv50dhv)

### $100pts$

注意到 $m=15$，于是自然想到枚举路径状态，赛时想到了用并查集乱搞，但是由于我的脑袋是 $autobus$（我们机房用来骂人的），没有想出具体怎么打。

赛后，[gza 巨佬](https://www.luogu.com.cn/user/301255)闲着没事，给我稍微讲了这道题。

*	枚举当前选择路径状态 $st$。

*	如果当前选的路径所包含的边都为同一种颜色，那么我们拿来并查集把这些边合并。此时一个联通块就有 $k$ 种选择，记联通块个数为 $cnt$，此时 $f_{st}=k^{cnt}$。

*	考虑容斥原理，答案就是 $\sum (-1)^{popcount(st)}\cdot f_{st}$。

赛时就是容斥没有想出来，可以吸吸经验。

寻找路径上的边我反正用了 $lca$，当然你 $O(n)$ 扫一遍也是可以做的。

时间复杂度 $O(2^mnm)$。

~~今年提一危~~

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

ll pop_count(ll x){
	ll res = 0;
	for (; x; x >>= 1)	res += x & 1;
	return res;
}

const ll mo = 1e9 + 7;

const int N = 65;

ll n, m, k;

ll num, h[N], to[N << 1], nxt[N << 1];
void addedge(ll u, ll v){
	to[++num] = v, nxt[num] = h[u], h[u] = num;
}

ll dep[N], fa[N][7];
void dfs(ll u, ll pre){
	dep[u] = dep[pre] + 1, fa[u][0] = pre;
	for (int i = 1; fa[u][i - 1]; ++i)	fa[u][i] = fa[fa[u][i - 1]][i - 1];
	for (int i = h[u]; i; i = nxt[i]){
		ll v = to[i];
		if (v == pre)	continue;
		dfs(v, u);
	}
}
ll get_lca(ll u, ll v){
	if (dep[u] < dep[v])	swap(u, v);
	for (int i = 6; i >= 0; --i)
		if (dep[fa[u][i]] >= dep[v])	u = fa[u][i];
	if (u == v)	return u;
	for (int i = 6; i >= 0; --i)
		if (fa[u][i] ^ fa[v][i])	u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

ll po[N];

ll Fa[N];
ll getfa(ll x){
	return Fa[x] == x ? x : Fa[x] = getfa(Fa[x]);
}

vector<ll> lj[N], tmplj;

ll Hash[N * N];

ll ans;

int main(){
//	freopen("sarenlist.in", "r", stdin), freopen("sarenlist.out", "w", stdout);
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	read(n), read(m), read(k);
	po[0] = 1;
	for (int i = 1; i <= n; ++i)	po[i] = po[i - 1] * k % mo;
	for (int i = 1, u, v; i < n; ++i)	read(u), read(v), addedge(u, v), addedge(v, u), Hash[(u - 1) * n + v - 1] = Hash[(v - 1) * n + u - 1] = i;
	dfs(1, 0);
	for (int i = 1, u, v, lca; i <= m; ++i){
		read(u), read(v), lca = get_lca(u, v);
		tmplj.clear();
		while (u ^ lca)	lj[i].push_back(Hash[(u - 1) * n + fa[u][0] - 1]), u = fa[u][0];
		while (v ^ lca)	tmplj.push_back(Hash[(v - 1) * n + fa[v][0] - 1]), v = fa[v][0];
		reverse(tmplj.begin(), tmplj.end());
		for (auto j : tmplj)	lj[i].push_back(j);
	}
	for (int st = 0; st < (1 << m); ++st){
		for (int i = 1; i < n; ++i)	Fa[i] = i;
		for (int i = 1; i <= m; ++i)	if ((st >> (i - 1)) & 1)
			for (auto j : lj[i])	Fa[getfa(j)] = getfa(lj[i][0]);
		ll cnt = 0;
		for (int i = 1; i < n; ++i)	cnt += Fa[i] == i;
		(ans += (po[cnt] * (pop_count(st) & 1 ? -1 : 1) + mo) % mo) %= mo;
	}
	write(ans), putchar('\n');

	return 0;
}
```

---

## 作者：orange_dream (赞：2)

考虑使用**容斥**，考虑每条路径满足或不满足的方案。

答案为 $\sum -1^{popcount(i)}f(i)$。

发现不合法的颜色必须一样，所以使用并查集来维护，将每个不合法用一个虚拟点来表示，设最终并查集中根节点的个数为 $num$，则答案为 $k^{num}$，即  $f(i)=k^{num}$。

献上赛后改对的代码一枚。


```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

const int N=1e6,mod=1e9+7;
int n,m,color,a,b,c[N],d[N],fa[N],ans,f[N],dd[N],xx[N],yy[N];
bool st[N];
vector<int> G[N];
queue<int> q;

void read(int &x){
	char c=getchar();int F=1;x=0;
	while (!isdigit(c) && c!='-')c=getchar();
	if (c=='-')F=-1,c=getchar();
	while (isdigit(c))x=x*10+c-48,c=getchar();
}
void write(int x){if (x>9)write(x/10);putchar(x%10+'0');}

int find(int x){if (f[x]==x)return x;return f[x]=find(f[x]);}//并查集
void merge(int x,int y){x=find(x);y=find(y);if (x!=y)f[x]=y;}

void bfs(int x){
	q.push(x);
	st[x]=true;
	while (!q.empty()){
		int x=q.front();
		q.pop();
		for (int i=0;i<G[x].size();i++){
			int v=G[x][i];
			if (st[v])continue;
			st[v]=true;
			q.push(v);
			d[v]=d[x]+1;
			fa[v]=x;
		}
	}
}

int qmi(int x,int y){
	int ans=1;
	while (y){
		if (y&1)ans=ans*x%mod;
		y>>=1;
		x=x*x%mod;
	}
	return ans;
}

int lca(int x,int y,int ou){
	if (x==y)return x;
	if (d[x]<d[y])swap(x,y);
	while (d[x]>d[y]){
		merge(x,ou);//x表示x->fa[x]这条边
		x=fa[x];
	}
	if (x==y)return x;
	while (x!=y){
		merge(x,ou);merge(y,ou);
		x=fa[x];y=fa[y];
	}
	return x;
}

signed main(){
	read(n);read(m);read(color);
	for (int i=1;i<n;i++){
		read(a);read(b);
		G[a].push_back(b);
		G[b].push_back(a);
	}
	bfs(1);
	for (int i=1;i<=m;i++){
		read(c[i]);read(dd[i]);
	}
	int ans,sum=0,flag,gg,len;
	for (int i=0;i<(1<<m);i++){//O(2^m*n*m*log(n))
		len=n;
		flag=1;
		ans=1;
		for (int j=1;j<=m+n;j++)f[j]=j;
		for (int j=0;j<m;j++){
			if (i&(1<<j)){
				flag*=-1;
				gg=lca(c[j+1],dd[j+1],++len);
			}
		}
		for (int j=1;j<=len;j++){
			if (j==find(j))ans*=color,ans%=mod;
		}
		ans=ans*qmi(color,mod-2)%mod;
		sum+=ans*flag;
		sum%=mod;
	}
	printf("%lld\n",(sum+mod)%mod);
	return 0;
}
```

第一篇题解，求过。

---

## 作者：SuBtitle (赞：2)

# [COCI2021-2022#4] Šarenlist

[题目链接](https://www.luogu.com.cn/problem/P8315)

## 分析

#### 如何求解

- 首先，一条路径上有 $2$ 种及以上颜色时都是合法的，换言之，只有当一条路径上只有一种颜色时才不合法，于是考虑 **用所有解的数量减去非法解的数量**。
- 所有解的数量就是每条边都有 $k$ 种颜色可选，也就是 $k^{n-1}$ 种，关键在于如何求非法解。

#### 如何求非法解

- 先考虑 $m=1$ 的情况。此时只需要使指定的这条路径颜色相同，有 $k$ 种颜色可选，其他边任意选，有 $k^{n-1-cnt}$ 种方案（$cnt$ 为路径覆盖的边），情况数 $k^{n-cnt}$。

- 再考虑 $m>1$ 的情况。此时依然按照上面的思路，枚举第 $i$ 条路径颜色相同，设对应的情况数为 $W_i$，那 $\sum_{i=1}^m W_i$ 就是非法解的数量。但此时需要考虑 $2$ 个问题。

  1. 

  - 在枚举第 $i$ 条路径颜色相同并累加上对应情况数时，我们使其它边颜色任选，就会出现其它指定的路径颜色也相同的情况，也就是说，在计算第 $i$ 种情况时，也会算上一部分 $j$ 的情况（$W_i$ 和 $W_j$ 有交集），或者说，$W_i$ 实际上是 **至少** 第 $i$ 条路径颜色相同的情况。

  - 要排除掉多算的情况，就需要使用容斥原理，总情况数为：
    $$
    W_i+W_j+W_k+\dots-W_{i,j}-W_{i,k}-W_{j,k}-\dots+W_{i,j,k}+\dots
    $$

  2. 

  - 在计算 $W_{i,j\dots}$ 时，如何计算它的情况数？

  - 先考虑 $2$ 条路径时的情况，此时又可以分成 $2$ 种情况：

    - $2$ 条路径没有重叠，此时它们的颜色可以不同，所以最后情况数为 $k^2\times k^{n-1-cnt}$。

    - $2$ 条路径有重叠，此时它们的颜色必须相同，因此可以将它们看作 $1$ 条路径，所以最后情况数为 $k\times k^{n-1-cnt}$。

  - 大于 $2$ 条路径时也是一样的，没有重叠的路径分别贡献一个 $k$ ，重叠的路径合并，最后的情况数就是 $k^{num}\times k^{n-1-cnt}$（$num$ 为将所有重叠的路径合并后的路径数）。

  - 那要如何计算重叠呢？可以使用并查集，$n-1-cnt$ 其实就是剩下的没有覆盖的边数，也是没有重叠的”路径“，最后的情况数实际上就是 $k^{Fnum}$（$Fnum$ 为并查集的数量）。

- 所以流程就是：

  1. 枚举每条路径是否选。

  2. 如果选则将路径上的边合并（并查集）。

  3. 计算贡献（选的路径为奇数则减，否则为加）。

## 注意

- 找到路径上的边可以直接用暴力 LCA，因为 $n\le 60$。

- 并查集是边的并查集，可以将每个点定义为他到父亲的这条边，所以 $Fnum$ 会大 $1$。

- 在算非法解时，会算到选 $0$ 条路径的情况，所以其实不需要一开始算所有解的数量。

## 代码

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int N=65,P=1000000007;
int n,m,q,tot,head[N],fa[N],dep[N],ans,F[N],Fnum;
bool vis[N];
pair<int,int>path[20];

struct Edge
{
	int v,nex;
}E[N*2];

void AddEdge(int u,int v)
{
	++tot;
	E[tot].v=v;
	E[tot].nex=head[u];
	head[u]=tot;
}

void dfs(int x)					//初始化深度(dep)和父亲(fa)
{
	for(int i=head[x];i;i=E[i].nex)
	{
		int v=E[i].v;
		if(v==fa[x]) continue;
		fa[v]=x;
		dep[v]=dep[x]+1;
		dfs(v);
	}
}

int find(int x)					//并查集查找
{
	if(x==F[x]) return x;
	return F[x]=find(F[x]);
}

void merge(int x,int y)			//并查集合并，注意Fnum要减少
{
	if(find(x)==find(y)) return;
	F[find(x)]=find(y);
	--Fnum;
}

void mark(int a,int b)			//找到路径上的边并合并重叠的边，注意并查集的含义
{
	while(dep[a]!=dep[b])
	{
		if(dep[a]<dep[b]) swap(a,b);
		if(fa[a]!=b) merge(a,fa[a]);
		a=fa[a];
	}
	if(a==b) return;
	while(fa[a]!=fa[b])
	{
		merge(a,fa[a]);
		merge(b,fa[b]);
		a=fa[a],b=fa[b];
	}
	merge(a,b);
	return;
}

int mpow(int a,int b)
{
	int res=1;
	for(;b;b>>=1)
	{
		if(b&1) res=1ll*res*a%P;
		a=1ll*a*a%P;
	}
	return res;
}

void rongchi(int x,int num)
{
	if(x==m+1)
	{
		if(num&1)
			ans-=mpow(q,Fnum-1),ans%=P;		//并查集实际上存的点，所以Fnum要减1
		else
			ans+=mpow(q,Fnum-1),ans%=P;
		return;
	}
	int tF[N],tFnum=Fnum;					//注意回溯时还原
	memcpy(tF,F,sizeof(F));
	mark(path[x].first,path[x].second);
	rongchi(x+1,num+1);
	memcpy(F,tF,sizeof(tF));
	Fnum=tFnum;
	rongchi(x+1,num);
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	Fnum=n;
	for(int i=1;i<=n;++i)
		F[i]=i;
	int u,v;
	for(int i=1;i<n;++i)
	{
		scanf("%d%d",&u,&v);
		AddEdge(u,v);
		AddEdge(v,u);
	}
	fa[1]=dep[1]=1;
	dfs(1);
	for(int i=1;i<=m;++i)
		scanf("%d%d",&path[i].first,&path[i].second);
	rongchi(1,0);
	printf("%d",(ans+P)%P);
	return 0;
}
```





---

## 作者：CWzwz (赞：2)

[P8315 Šarenlist](https://www.luogu.com.cn/problem/P8315) 题解

------------

正难则反，显然总方案数 $k^{n-1}$，考虑统计不合法方案数。

题目要求：所有特殊路径上都至少有两种不同颜色。不合法的就是：每条特殊路径上的颜色分别相同。

范围极小，可以容斥。记特殊路径集 $\{P\}$，枚举其子集 $\{S\}$，表示 $\{S\}$ 中的路径上的颜色分别相同。则容斥系数 $(-1)^{|S|}$。

并查集，考虑将 $\{S\}$ 中所有路径上的边 $\operatorname{merge}$，那么每个联通块内部同色，可选 $k$ 种颜色。记联通块个数 $d$，那么子集 $\{S\}$ 对**不合法方案数**的贡献为，$k^d\times(-1)^{|S|}$。

时间复杂度 $O(2^m\cdot nm\cdot \alpha(n))$。

```cpp
// Problem: P8315
#include<iostream>
#include<stdio.h>
#define Int int
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define i32 INT_MAX
#define i64 LONG_LONG_MAX
#define pii std::pair<int, int>
#define pll std::pair<long long, long long>
#define pb emplace_back
#define fore(i,u,v) for(int i=head[u],v;i;i=e[i].nxt)
typedef long long ll;
#define typ ll
int __Mst_p;
const int N = 65, S = 32800, lgn = 8, mod = 1e9 + 7;
typ read(){typ x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}return x*f;}
void print(typ x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}void print(typ x, char c){print(x);putchar(c);}
char gc(){char c=getchar();while(c==' '||c=='\n')c=getchar();return c;}

int n, m, cnte;
ll col;
int st[N], ed[N], rt[N], d[N], fa[N][lgn], e[N][N];

void adde(int u, int v, int id) {
    e[u][v] = id;
}
void dfs(int u, int f) {
    d[u] = d[f] + 1;
    fa[u][0] = f;
    for(int i = 1; i <= 7; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for(int v = 1; v <= n; v++) {
        if(u == v || !e[u][v] || v == f) continue;
        dfs(v, u);
    }
}
void clear() {
    for(int i = 1; i < n; i++) rt[i] = i;
}
int get_lca(int u, int v) {
    if(d[u] < d[v]) u ^= v ^= u ^= v;
    for(int i = 7; i >= 0; i--) if(d[fa[u][i]] >= d[v]) u = fa[u][i];
    if(u == v) return u;
    for(int i = 7; i >= 0; i--) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
int find(int u) {
    if(rt[u] == u) return u;
    return rt[u] = find(rt[u]);
}
void merge(int u, int v) {
    rt[find(u)] = find(v);
}
void path_coloring(int u, int v) {
    int lca = get_lca(u, v);
    if(u == lca) u ^= v ^= u ^= v;
    int fst = e[u][fa[u][0]];
    u = fa[u][0];
    while(u != lca) {
        merge(e[u][fa[u][0]], fst);
        u = fa[u][0];
    }
    while(v != lca) {
        merge(e[v][fa[v][0]], fst);
        v = fa[v][0];
    }
}
ll qpow(ll bas, ll idx) {
    ll res = 1;
    for(; idx; idx >>= 1, bas = bas * bas % mod) if(idx & 1) res = res * bas % mod;
    return res;
}

int __Med_p;
int main() {
    fprintf(stderr, "%.1lfMB\n", (&__Mst_p - &__Med_p) / 1048576.0);
    std::cin >> n >> m >> col;
    for(int i = 1; i < n; i++) {
        int u = read(), v = read();
        adde(u, v, i);
        adde(v, u, i);
    }
    dfs(1, 0);
    for(int i = 1; i <= m; i++) st[i] = read(), ed[i] = read();
    ll ans = 0;
    for(int s = 1; s < (1 << m); s++) { // O(2^m) (32768)
        clear();
        ll res = 1;
        for(int set = s, j = __builtin_ctz(set) + 1; set; set -= set & -set, j = __builtin_ctz(set) + 1) { // O(m) (15)
            path_coloring(st[j], ed[j]); // O(n·α(n))
        }
        for(int i = 1; i < n; i++) {
            if(rt[i] == i) res = res * col % mod;
        }
        ans = (ans + res * ((__builtin_popcount(s) & 1) ? 1 : -1)) % mod;
    }
    print((qpow(col, n - 1) - ans + mod) % mod, '\n');
    return 0;
}
```

---

## 作者：Lucyna_Kushinada (赞：1)

# P8315 [COCI 20212022 #4] Šarenlist

## 题意

给定一棵树，$n$ 个节点，给定了 $m$ 条路径的起点和终点，有 $k$ 种颜色，现在要给每条边染上一种颜色。

求有多少种染色方式，使得对于每条给定的条路径，都满足路径上至少有两种颜色。

答案对 $10^9+7$ 取模。

$n\le 60$，$m\le 15$。

## 题解

知识点：二项式反演，组合数学，容斥原理。

启发：

- 正难则反。

到了树上。

设 $g_k$ 为恰好有 $k$ 条路径不满足条件的方案数。

设 $f_k$ 为钦定 $k$ 条路径使得不满足条件，未涉及的边随便染色的方案数。

有如下关系，

$$\displaystyle f_k=\sum_{i=k}^m \binom{i}{k}\times g_i$$

二项式反演，

$$\displaystyle g_k=\sum_{i=k}^m \binom{i}{k}\times (-1)^{i-k} f_i$$

注意到 $m\le 15$，这暗示可以 $O(2^m)$ 枚举每一条路径的是否不满足。

先与处理出每一条路径包含的边的编号，存起来。

设当前状态为 $s$，将 $s$ 中为 $1$ 的位对应的路径取出，在并查集上，依次将每一条路径中的边合并到同一连通块，当两条路径有边交集时，他们都合并到同一连通块。

要让选出来都路径都不合法，则在同一连通块的边得染上同一种颜色，设一共 $c$ 个连通块，则染色方案为 $k^c$，累加到 $f_{\operatorname{popcount(s)}}$。

答案即为 $g_0$，此时 $\displaystyle g_0=\sum_{i=0}^m (-1)^{i} f_i$，退化为了一般的容斥原理。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define sz(x) (x).size()
#define bg(x) (x).begin()
#define ed(x) (x).end()

#define N 66
#define int long long

const int mod=1e9+7;
int n,m,k,F[N];
bitset<N>f;
pr a[N],pre[N];
vector<pr>e[N];
vector<int>p[N];

inline int qpow(int a,int b){
    int ans=1;

    while(b){
        if(b&1){
            ans=ans*a%mod;
        }
        a=a*a%mod;
        b>>=1;
    }

    return ans;
}

inline void dfs(int k){
    f[k]=1;

    for(pr x:e[k]){
        if(f[x.fi]){
            continue;
        }

        pre[x.fi]={k,x.se};
        dfs(x.fi);
    }
}

struct dsu{
    int fa[N];

    inline void init(){
        rep(i,1,n){
            fa[i]=i;
        }
    }

    inline int ask(int k){
        if(fa[k]==k){
            return k;
        }
        return ask(fa[k]);
    }

    inline bool mg(int x,int y){
        x=ask(x),y=ask(y);

        if(x==y){
            return 0;
        }

        fa[x]=y;

        return 1;
    }
}d;

inline void sol(int s){
    vector<int>v;

    rep(i,1,m){
        if((s>>(i-1))&1){
            v.pb(i);
        }
    }

    d.init();

    for(int x:v){
        int len=sz(p[x]);

        rep(i,1,len-1){
            d.mg(p[x][i],p[x][i-1]);
        }
    }

    int ans=1;

    rep(i,1,n-1){
        if(d.fa[i]==i){
            ans=ans*k%mod;
        }
    }

    F[sz(v)]=(F[sz(v)]+ans)%mod;
}

inline int neg(int x){
    return x&1?-1:1;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin>>n>>m>>k;

    rep(i,1,n-1){
        int u,v;
        cin>>u>>v;
        e[u].pb({v,i});
        e[v].pb({u,i});
    }

    rep(i,1,m){
        cin>>a[i].fi>>a[i].se;

        rep(j,1,n){
            f[j]=0;
            pre[j]={0,0};
        }

        dfs(a[i].fi);

        int u=a[i].se;
        while(pre[u].se){
            p[i].pb(pre[u].se);

            u=pre[u].fi;
        }
    }

    rep(s,0,(1<<m)-1){
        sol(s);
    }

    int ans=0;

    rep(i,0,m){
        ans=(ans+
            neg(i)*F[i]
            +mod
        )%mod;
    }

    cout<<ans;

    return 0;
}
```

---

## 作者：Pekac (赞：0)

[P8315](https://www.luogu.com.cn/problem/P8315)

T3 写太慢了，就没看这道/gg。错过简单题+1。

不好直接对边或路径进行考虑，但是发现 $m$ 非常小，考虑容斥。

即每次钦定集合 $S$，强制包含在 $S$ 内的路径不合法，其它的都可以，容斥系数就是 $-1^{|S|}$。每次可以暴力覆盖染色，然后用一个并查集进行维护即可，使用按秩合并和路径压缩两种优化即可做到 $\mathcal{O}(nm2^m\alpha(m))$。

具体细节见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
const int mod=1e9+7;
int n,m,k;ll ans;
int fa[100],dep[100],a[100],b[100];
vector<int>e[100];
ll power(ll a,ll b){
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)if(b&1)res=res*a%mod;
	return res;
}
void dfs(int u,int ff){
	dep[u]=dep[ff]+1,fa[u]=ff;
	for(int v:e[u])if(v!=ff)dfs(v,u);
}
int anc[100],vis[100],tim[100];
int find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}
ll work(int x){
	for(int i=1;i<=max(n,m);i++)anc[i]=tim[i]=vis[i]=0;
	for(int i=0;i<m;i++)if(x>>i&1){
		int u=a[i+1],v=b[i+1];anc[i+1]=i+1;
		while(u!=v){
			if(dep[u]<dep[v])swap(u,v);
			if(!tim[u])tim[u]=i+1;else anc[find(tim[u])]=i+1;
			vis[u]=1;
			u=fa[u];
		}
	}
	int c=0,r=n-1;
	for(int i=1;i<=n;i++)if(fa[i])r-=vis[i];
	for(int i=1;i<=m;i++)if(anc[i])c+=(anc[i]==i);
	return power(k,r)*power(k,c)%mod;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),e[u].pb(v),e[v].pb(u);
	for(int i=1;i<=m;i++)scanf("%d%d",&a[i],&b[i]);
	dfs(1,0);
	for(int i=0;i<(1<<m);i++)ans=(ans+(__builtin_popcount(i)&1?-1:1)*work(i)+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Struct_Sec (赞：0)

妙妙题，赛时没做出来，但把所有部分分打完了。

## sub1

发现只有路径上的所有的颜色相同才不合法。

考虑用全部方案减去不合法方案即可。

```cpp
if(m==1){
	int x,y;
	cin>>x>>y;
	int lca=LCA(x,y);
	int len=dep[x]+dep[y]-2*dep[lca];
	cout<<((qpow(k,len)-k+mod)%mod*qpow(k,n-1-len))%mod;
}
```
## sub2

依然用全部方案减去不合法方案，考虑两条路径中当有一个不满足条件时，另一个路径上不与当前路径上重合的点可以视作普通点。两种条路径都计算以后会有重复部分，即两条路径上的所有的颜色都相同时会算两遍，减去即可。注意包含和不想交关系需要特判。

```cpp
if(m==2){
	int x,y;
	cin>>x>>y;
	int lca=LCA(x,y);
	int len1=dep[x]+dep[y]-2*dep[lca];
	while(x!=lca){
		mp[x]=1;
		x=f[x];
	}
	while(y!=lca){
		mp[y]=1;
		y=f[y];
	}
	cin>>x>>y;
	int Lca=LCA(x,y);
	int len2=dep[x]+dep[y]-2*dep[Lca],sum=0;
	while(x!=Lca){
		sum+=mp[x];
		x=f[x];
	}
	while(y!=Lca){
		sum+=mp[y];
		y=f[y];
	}
	if(!sum){
		cout<<((qpow(k,len1)-k+mod)%mod*(qpow(k,len2)-k+mod)%mod*qpow(k,n-1-len1-len2))%mod;
		return 0;
	}
	if(len1==sum){
		cout<<((qpow(k,len1)-k+mod)%mod*qpow(k,n-1-len1))%mod;
		return 0;
	}
	if(len2==sum){
		cout<<((qpow(k,len2)-k+mod)%mod*qpow(k,n-1-len2))%mod;
		return 0;
	}
	cout<<((qpow(k,len1+len2-sum)-(k*(qpow(k,len2-sum)%mod-1+mod)%mod+k*(qpow(k,len1-sum)%mod-1+mod)%mod+k)%mod+mod)%mod*qpow(k,n-1-len1-len2+sum)%mod);
}
```

## sub3

每条边只属于一条路径时，对于每条路径单独做即可，和 sub1 类似。

```cpp
else{
	int res=1;
	int sum=0;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		int lca=LCA(x,y);
		int len=dep[x]+dep[y]-2*dep[lca];
		sum+=len;
		(res*=(qpow(k,len)-k+mod)%mod)%=mod;
	}
	cout<<(qpow(k,n-1-sum)*res)%mod;
}
```

## sub4

暴搜每条边的颜色即可。

```cpp
void dfs(int s){
	if(s==n+1){
		for(int i=1;i<=m;i++){
			int x=q[i][0],y=q[i][1];
			int lca=LCA(x,y);
			bool ff=0,l=0;
			if(x!=lca) ff|=(!mp[x]),l|=(mp[x]);
			if(y!=lca) ff|=(!mp[y]),l|=(mp[y]);
			while(x!=lca){
				ff|=(!mp[x]);
				l|=(mp[x]);
				x=f[x];
			}
			while(y!=lca){
				ff|=(!mp[y]);
				l|=(mp[y]);
				y=f[y];
			}
			if(!ff || !l) return;
		}
		ans++;
		return;
	}
	mp[s]=0;
	dfs(s+1);
	mp[s]=1;
	dfs(s+1);
}
```
## 正解

发现 $m\le 15$ 考虑用容斥计算答案。

我们枚举 $0\sim m-1$ 的每一个数，通过其在二进制下第 $i$ 位是否为 1 判断其是否合法，若不合法，则该路径上的所有边颜色相同。

这一操作我们可以使用并查集维护。

时间复杂度 $\mathcal{O(2^{m}\cdot m\cdot n)}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=65,mod=1e9+7;
int n,m,k;
int cnt,head[N];
struct edge{
	int u,v,nxt;
}e[N<<1];
void add(int u,int v){
	e[++cnt]={u,v,head[u]};
	head[u]=cnt;
}
int dep[N],F[N];
void dfs1(int u,int fa){
	dep[u]=dep[fa]+1;
	F[u]=fa;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa) continue;
		dfs1(v,u);
	}
}
int q[N][2];
int ans;
int f[N];
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
void merge(int x,int y){
	if(find(x)!=find(y)) f[find(x)]=find(y);
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	for(int i=1;i<=m;i++){
		cin>>q[i][0]>>q[i][1];
	}
	for(int i=0;i<(1<<m);i++){
		int s=1;
		for(int j=2;j<=n;j++) f[j]=j;
		for(int j=1;j<=m;j++){
			if(i&(1<<(j-1))){
				s*=-1;
				int x=q[j][0],y=q[j][1];
				int sx=x,sy=y,lca;
				while(x!=y){
					if(dep[x]<dep[y]) swap(x,y);
					x=F[x];
				}
				lca=x;
				if(dep[sx]<dep[sy]) swap(sx,sy);
				while(F[sx]!=lca){
					merge(sx,F[sx]);
					sx=F[sx];
					if(dep[sx]<dep[sy]) swap(sx,sy);
				}
				if(sx!=lca && sy!=lca){
					merge(sx,sy);
				}
			}
		}
		for(int j=2;j<=n;j++){
			if(find(j)==j) (s*=k)%=mod;
		}
		(ans+=s+mod)%=mod;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：1234567890sjx (赞：0)

前言：比 T2 和 T3 都简单，但是赛时只有 $30$ 分，怎么回事呢？$\tiny\color{white}{\text{要是切了就有奶茶了qwq}}$

$m=1$ 和路径不重叠的 $25$ 分（题目上 $20$ 分）是非常 $\text{simple}$ 的，直接推公式即可，这里不做分析。但是考试的时候 $m=1$ 挂了，非常怄火。

首先考虑正难则反，答案为总数减去不合法的方案数。

总数容易计算，$n-1$ 条边都有 $k$ 种颜色可以选，为 $k^{n-1}$。

然后对于每一种路径 $u\to v$，如果她是不合法的，那么方案数就是 $2^{n-1-cnt}$，其中 $cnt$ 为 $u\to v$ 的唯一一条简单路径中边的数量。

发现 $m\le 15$，那么枚举所有 $2^{15}$ 种不合法的方法，暴力容斥即可。

具体的，设容斥得到的二进制状态 $mask$ 中第 $i$ 位为 $1$ 那么钦定第 $i$ 条边一定不合法，否则一定合法。

那么这个大水紫就被切掉了，时间复杂度 $O(n\times m\times 2^m)$。

总结与反思：没有能够切掉最后一题的信心。

---


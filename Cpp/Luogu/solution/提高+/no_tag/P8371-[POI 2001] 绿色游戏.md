# [POI 2001] 绿色游戏

## 题目描述

绿色游戏是一种两人游戏，双方分别称 $\text{Ann}$ 和$\text{Billy}$。游戏的内容主要是轮流在棋盘上移动一颗棋子。

棋盘上的点一部分是绿色的，其余是白色的。它们全部从 $1$ 至 $a+b$ 编号。编号 $1$ 至 $a$ 的点属于 $\text{Ann}$ ，编号 $a+1$ 至 $a+b$ 的点属于 $\text{Billy}$。每个点都有一些后继点，均可一步到达。属于 $\text{Ann}$ 的点的后继点一定属于 $\text{Billy}$，反之亦然。所有的点都至少有一个后继点，这样总可以往下走一步。

游戏开始时把棋子放在任意的一点 $P$ 上，然后双方轮流移动棋子至当前所在点（属于移动方）的一个后继点上（属于对手）。游戏由点 $P$ 的拥有者开始，结束时棋子第二次到达了某一点，称点 $Q$。如果在从点 $Q$ 至点 $Q$ 的一连串移动中，棋子至少一次被放到绿色点上，则 $\text{Ann}$ 赢。若从点 $P$ 开始，不管 $\text{Billy}$ 如何移动， $\text{Ann}$ 总能保证赢得这次游戏，则称 $\text{Ann}$ 对起始点 $P$ 有必胜的策略。

请你编写一个程序：
 
1. 读入对棋盘的描述。

2. 算出 $\text{Ann}$ 有必胜策略的起始点。

## 样例 #1

### 输入

```
5 3
0 2 6 7
0 3 6 7 8
0 1 8
1 1 7
1 1 8
1 2 1 2
0 2 1 2
0 2 3 4```

### 输出

```
5
1
2
4
6
7```

# 题解

## 作者：Fdjo (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8371)

# 题解：
## 题目大意：
Ann 和 Billy 在一个棋盘上移动 $1$ 个棋子，棋盘由 $a+b$ 个点构成，其中有一些是绿色的，前 $a$ 个属于 Ann，后 $b$ 个属于 Billy。这些点都有后继点且后继点一定属于对方，对于每一次移动，都由当前棋子所在点的拥有者完成，当棋子第二次到达一个点 $Q$，游戏结束，如果在 $Q$ 到 $Q$ 的过程中，棋子到过绿色点，Ann 赢，否则 Billy 赢。问你 Ann 有必胜策略的起始点有多少个并输出。
## 思路分析：
我们设 $f _ {i}$ 表示从 $i$ 开始时 Ann 是否有必胜策略。那么：

- 当 $i \le a$ 时：（$b _ {w}$ 表示 $i$ 的第 $w$ 个后继点)       $f _ {i} = f _ {b _ {1}} \operatorname{or} f _ {b _ {2}} \operatorname{or} \cdots \operatorname{or} f _ {b _ {n}}$，因为当前由 Ann 操控，他可以选择去一个有必胜策略的点。
- 当 $i > a$ 时：（$b _ {w}$ 表示 $i$ 的第 $w$ 个后继点）$f _ {i} = f _ {b _ {1}} \operatorname{and} f _ {b _ {2}} \operatorname{and} \cdots \operatorname{and} f _ {b _ {n}}$，因为当前由 Billy 操控，只要有不让 Ann 胜利的点，他就会去，所以 Ann 能胜利当且仅当这个点所有后继点都能让 Ann 胜利。

到这里我们遇到了一个问题，这个题的图存在环，所以我们无法常规计算。~~经过我在英语课上的不断思索~~，发现可以**迭代**求解。
***
#### 所谓迭代，就是反复通过旧数据计算新数据，并将结果用到下一次计算中，从而不断逼近直至找到正确答案。本题我们可以搞一个集合 $Q$，然后具体操作如下：

1. 把目前的绿点全加入集合。

2. 从绿点向外扩展到每个点，对于第 $i$ 个点来说，如果 $i \le a$，那么他只要有后继点是绿点就把它加进来并标记为绿点，如果 $i > a$，那么只要他所有的后继点都是绿点就把它加入集合并标记为绿点。

3. 通过以上操作，有一些绿点其实是不符合递推式的，所以对于绿点 $i$，如果 $i \le a$，那么只要他所有后继点都不在 $Q$ 中，就把它搞出去并标记为非绿点，如果 $i > a$，那么只要他有一个点不在 $Q$ 中，就把它踢出集合并标记为非绿点。

---

### **最重要的一点，我们要重复这个过程，直到迭代变得稳定。（如果不进行这一步，就会只得 27 分）。**
具体来说，我们要让所有绿点都符合条件才能停止，否则答案是错误的。有两种方法：一是强制执行 $a+b$ 次（稍慢）。二是在每次操作结束后，判断是否有绿点被改为非绿点，如果没有了，意味着已经稳定，继续循环也没有意义，此时退出，并输出结果。如果还有就继续执行。
### （本人存图喜欢用 vector，本题也可以用其他方式，集合 $Q$ 用队列 queue 维护即可)。
# 100pts Code:
```
#include "iostream"
#include "cstdio"
#include "queue"
#include "vector"
using namespace std;
int a,b,col[6005],bac[6005],f[6005],ans;//col[i] 表示第 i 个点的颜色;bac[i] 表示第 i 个点的后继点数目
vector<int> e[6005];//存图
bool work()
{
    queue <int> q;
    int tmp[6005];//因为后期 bac 数组要修改，所以先存到另外一个数组
    for (int i = 1;i <= b;i++)
    {
        tmp[i] = bac[i];
        
        f[i] = col[i];
        if (f[i] == 1)q.push(i);//把所有绿点加入
    }
    while (!q.empty())//类似bfs
    {
        int cur = q.front();
        q.pop();
        
        for (auto i:e[cur])
        {
            if (f[i] == 0)
            {
                tmp[i]--;//每有一个后继点成为绿点就减一，为零时就合法，入集合
                if (tmp[i] == 0 || i <= a)
                {
                    f[i] = 1;
                    q.push(i);
                }
            }
        }
    }
    for (int i = 1;i <= b;i++)
    {
        tmp[i] = bac[i];
        if (f[i] == 0)//找非绿点，加入集合，这次要往外筛
        {
            q.push(i);
        }
    }
    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        
        for (auto i:e[cur])
        {
            if (f[i] == 1)
            {
                tmp[i]--;//每有一个后继点成为非绿点就减一，为0时不合法，出集合
                if (tmp[i] == 0||i > a)
                {
                    f[i] = 0;
                    q.push(i);
                }
            }
        }
    }
    bool fl = 0;
    for (int i = 1;i <= b;i++)
    {
        if (col[i] == 1 && f[i] == 0)//统计是否有绿点被修改（迭代是否稳定），并修改颜色，作为下一次计算的初始数据
        {
            col[i] = 0;
            fl = 1;
        }
    }
    return fl;
}
int main()
{
    scanf("%d%d",&a,&b);
    b += a; //此时 a+b 就是点的总数
    for (int i = 1;i <= b;i++)
    {
        scanf("%d%d",&col[i],&bac[i]);
        for (int j = 1;j <= bac[i];j++)
        {
            int u;
            scanf("%d",&u);
            e[u].push_back(i);//反向建边，便于计算 f[i]
        }
    }
    while (work());//work函数是bool类型的，只要返回值为一就继续进行，这里也可以重复执行点的总数量次。
    for (int i = 1;i <= b;i++)
    {
        if (f[i] == 1)
        {
            ans++;
        }
    }
    printf("%d\n",ans);//先输出个数
    for (int i = 1;i <= b;i++)
    {
        if (f[i] == 1)
        {
            printf("%d\n",i);
        }
    }
    return 0;
}
```
# 蒟蒻的第一篇题解完结撒花。

---

## 作者：lhc0707 (赞：0)

对于 Ann 的点，如果能称为必胜点那么其出边中存在一个绿点；对于 Bily 的点，如果能成为必胜点则其后继点必然全部是绿点；绿点不一定是必胜点。我们不妨假设绿点都是必胜点，从绿点开始跑来 check 上面的条件，如果有绿点不符合那就把这些绿点扔了继续跑，可以说明最多跑 $a+b$ 遍，对于本题是可以接受的。实现的时候可以从后继点到当前点连边，每次 check 可以执行一个类似 bfs 的框架。代码：

```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar(10)
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<int, int>
#define pdi pair<ll, ll>
#define mem(aa, bb) memset(aa, bb, sizeof(aa));
#define fo(i, a, b) for (int i = (a); i <= (b); ++i)
#define Fo(i, a, b) for (int i = (a); i >= (b); --i)
#define pb push_back
#define reg register
#define eb emplace_back
#define bct __builtin_popcount
#define mk make_pair
#define IT iterator
#define all(x) x.begin(), x.end()
#define lbd lower_bound
#define ubd upper_bound
#define lowbit(x) ((x) & (-(x)))
#define IOS cin.tie(0)->sync_with_stdio(false), cout.tie(0);
using namespace std;

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128 i128;
typedef __uint128_t u128;
typedef double db;
typedef long long ll;

// #define getchar getchar_unlocked
// #define putchar putchar_unlocked

template <class T> inline void read(T &s)
{
 s = 0;
 reg int f = 1;
 reg char c = getchar();
 while (!isdigit(c)) f ^= (c == '-'), c = getchar();
 while (isdigit(c)) s = (s << 1) + (s << 3) + (c ^ 48), c = getchar();
 s = f ? s : -s;
}
template <class T> inline void wr(T x)
{
 if (x < 0) putchar('-'), x = -x;
 int buf[21], top = 0;
 while (x) buf[++top] = x % 10, x /= 10;
 if (!top) buf[++top] = 0;
 while (top) putchar(buf[top--] ^ '0');
}
template <class T> inline bool ckmn(T &a, T b) { return a > b ? a = b, 1 : 0; }
template <class T> inline bool ckmx(T &a, T b) { return a < b ? a = b, 1 : 0; }
template <class T, class... A> inline void read(T &x, A &...a) { read(x), read(a...); }
template <class T, class... A> inline void ckmn(T &x, T y, A &...a) { return ckmn(x, y) | ckmn(x, a...); }
template <class T, class... A> inline void ckmx(T &x, T y, A &...a) { return ckmx(x, y) | ckmx(x, a...); }

const int N = 6005;
int n, m, col[N], siz[N], tmp[N], vis[N];
vector<int> g[N];
queue<int> q;
inline bool work()
{
 memcpy(tmp, siz, sizeof(tmp));
 memcpy(vis, col, sizeof(vis));
 fo(i, 1, n + m) if (vis[i]) q.push(i), vis[i] = true;
 while (!q.empty())
 {
  int u = q.front();
  q.pop();
  for (int v : g[u])
  {
   if (vis[v]) continue;
   --tmp[v];
   if (!tmp[v] || v <= n) vis[v] = 1, q.push(v);
  }
 }
 memcpy(tmp, siz, sizeof(tmp));
 fo(i, 1, n + m) if (!vis[i]) q.push(i);
 while (!q.empty())
 {
  int u = q.front();
  q.pop();
  for (int v : g[u])
   if (vis[v])
   {
    --tmp[v];
    if (!tmp[v] || v > n) vis[v] = 0, q.push(v);
   }
 }
 bool flg = false;
 for (int i = 1; i <= n + m; i++)
  if (!vis[i] && col[i]) col[i] = 0, flg = true;
 return flg;
}
signed main()
{
 read(n, m);
 fo(i, 1, n + m)
 {
  int v;
  read(col[i], siz[i]);
  fo(j, 1, siz[i]) read(v), g[v].pb(i);
 }
 while (work());
 int ans = 0;
 fo(i, 1, n + m) ans += vis[i];
 wr(ans), pr;
 fo(i, 1, n + m) if (vis[i]) wr(i), pr;
 return 0;
}
```

---


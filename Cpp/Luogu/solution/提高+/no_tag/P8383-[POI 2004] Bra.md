# [POI 2004] Bra

## 题目描述

让我们考虑一个包含 $n$ 个门的电路。

门从 $0$ 到 $n-1$ 编号，每个门都包含若干个输入和一个输出。

每一个输入和输出都只可能是 $0,1,\dfrac{1}{2}$ 三种状态，每个输入都连接着某个门的输出，输入的状态就等于它连接的输出的状态值，而每个输出可能连接着任意多个输入。

$0$ 和 $1$ 是很特殊的两个门。门 $0$ 的输出永远为 $0$，门 $1$ 的输出永远为 $1$。

一个门有效的输出状态条件如下: 

1. 它的输入中 $0$ 的个数多于 $1$ 的个数那么输出状态为 $0$。 

2. 它的输入中 $0$ 的个数等于 $1$ 的个数那么输出状态为 $\dfrac{1}{2}$。 

3. 它的输入中 $0$ 的个数少于 $1$ 的个数那么输出状态为 $1$。

4. 对于门 $0$ 和 $1$，他们分别输出 $0$ 和 $1$。

现在给出电路信息，请你编写一个程序，确定所有可以确定状态的门的状态分别是什么。

## 说明/提示

对于全部数据，$2 \le n \le 10000,k_i \ge 1$，数据保证所有门的输入端总数不超过 $200000$。

## 样例 #1

### 输入

```
5
2 0 1
2 4 2
2 2 4```

### 输出

```
0
1
1/2
?
?```

# 题解

## 作者：JCY_ (赞：5)

[可能更好的阅读体验](https://www.cnblogs.com/JCY-std/p/16688615.html)
### 题目大意
给你一个 $n$ 个点 $m$ 条边的有向图，从 $0$ 开始标号，有重边，有自环（$n\leq 10^4,m\leq 2\times 10^5$），每个点有三种状态 $0,\frac{1}{2},1$。

考察点 $u$，设在其所有前驱 $v$ 中，有 $c_0$ 个点状态为 $0$，$c_1$ 个点状态为 $1$，$c_2$ 个点状态为 $\frac{1}{2}$。若 $c_0>c_1$ 则点 $u$ 状态为 $0$，若 $c_0<c_1$ 则点 $u$ 状态为 $1$，否则点 $u$ 状态为 $\frac{1}{2}$。

现已知点 $0$ 的状态为 $0$，点 $1$ 的状态为 $1$，且这两个点入度均为 $0$。求在所有符合上述规则的状态分配中，状态均相同的点的标号，以及它们的状态。
### 分析
一眼看上去直接做有些困难，不妨考虑求出每个点状态大小的上界和下界，若上下界相同则说明其为所求点。上下界求法理应相同，所以只考虑如何求出下界。

先将点 $1$ 的状态赋为 $1$，其它点赋为 $0$。将点 $1$ 入队，然后开始进行类似 BFS 的调整：取出队首 $u$，遍历其所有后继 $v$，若此时 $v$ 的状态不符合规则，则修改 $v$ 的状态并将其入队。

正确性可以感性理解，因为每次调整都是必须的。

考虑分析这一过程的复杂度，不难发现每个点入队时状态大小必然变大，因此每个点入队不超过 $2$ 次，复杂度为 $O(m)$。

具体实现细节见代码。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e4 + 10;
int n, in[MAXN], c[MAXN][3], val0[MAXN], val1[MAXN], hd, tl, qu[MAXN * 2];
vector<int> g[MAXN];
inline int calc(int x) {
    if (c[x][0] > c[x][1]) return 0;
    if (c[x][1] > c[x][0]) return 1;
    return 2;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 2; i < n; ++i) {
        cin >> in[i];
        for (int j = 0, x; j < in[i]; ++j) {
            cin >> x;
            g[x].emplace_back(i);
        }
    }
    for (int i = 0; i < n; ++i) c[i][0] = in[i];
    val0[1] = 1;
    for (auto v : g[1]) --c[v][0], ++c[v][1];
    qu[hd = tl = 1] = 1;
    while (hd <= tl) {
        int u = qu[hd++];
        for (auto v : g[u]) {
            int t = calc(v);
            if (val0[v] != t) {
                for (auto w : g[v]) {
                    --c[w][val0[v]];
                    ++c[w][t];
                }
                qu[++tl] = v;
                val0[v] = t;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        c[i][1] = in[i];
        c[i][0] = c[i][2] = 0;
    }
    fill(val1 + 1, val1 + n, 1);
    val1[0] = 0;
    for (auto v : g[0]) --c[v][1], ++c[v][0];
    qu[hd = tl = 1] = 0;
    while (hd <= tl) {
        int u = qu[hd++];
        for (auto v : g[u]) {
            int t = calc(v);
            if (val1[v] != t) {
                for (auto w : g[v]) {
                    --c[w][val1[v]];
                    ++c[w][t];
                }
                qu[++tl] = v;
                val1[v] = t;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        if (val0[i] == val1[i]) {
            if (val0[i] == 2) {
                cout << "1/2";
            } else {
                cout << val0[i];
            }
        } else {
            cout << '?';
        }
        cout << '\n';
    }
    return 0;
}

---

## 作者：Alex_Wei (赞：3)

> [P8383 [POI2004] Bra](https://www.luogu.com.cn/problem/P8383)

挺趣味的一道题。

注意到一个门输入的 $0$ 的个数越多，就越可能输出 $0$。也就是说，输入的数越小，输出的数越小。这给予我们一个重要性质：所有门的最小输出值必然在同一个电路中取到。因为降低一个门的输出值不会使得别的门的输出值变大。

因此，首先假设所有门的输出均为 $0$，再贪心调整。每次调整都是必要的，可以通过第一次调整是必要的进行归纳证明。最终达到稳定态时每个们的状态即最小输出值。

同理，假设所有门的输出均为 $1$，贪心调整得到每个们的最大输出值。若最大输出值和最小输出值不等，则输出不确定，否则确定。

时间复杂度线性。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
#define fi first
#define se second
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
inline int read() {
  int x = 0;
  char s = getchar();
  while(!isdigit(s)) s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return x;
}
inline void print(int x) {
  if(x < 0) return putchar('-'), print(-x);
  if(x >= 10) print(x / 10);
  putchar(x % 10 + '0');
}
bool Mbe;
constexpr int N = 1e4 + 5;
int n, m, st[N], cnt0[N], cnt1[N], mn[N], mx[N];
vector<int> e[N], rev[N];
void fix(int x, int v) {
  if(st[x] != 2) for(int it : e[x]) st[x] ? cnt1[it]-- : cnt0[it]--;
  st[x] = v;
  if(st[x] != 2) for(int it : e[x]) st[x] ? cnt1[it]++ : cnt0[it]++;
}
void solve1() {
  for(int i = 0; i < n; i++) st[i] = 2;
  for(int i = 0; i < n; i++) fix(i, i == 1);
  queue<pii> q;
  auto check = [&](int id) {
    if(cnt0[id] == cnt1[id] && st[id] != 2) q.push({id, 2});
    if(cnt0[id] < cnt1[id] && st[id] != 1) q.push({id, 1});
  };
  for(int i = 2; i < n; i++) check(i);
  while(!q.empty()) {
    pii t = q.front();
    q.pop(), fix(t.first, t.second);
    for(int it : e[t.first]) check(it);
  }
}
void solve2() {
  for(int i = 0; i < n; i++) fix(i, i != 0);
  queue<pii> q;
  auto check = [&](int id) {
    if(cnt0[id] == cnt1[id] && st[id] != 2) q.push({id, 2});
    if(cnt0[id] > cnt1[id] && st[id] != 0) q.push({id, 0});
  };
  for(int i = 2; i < n; i++) check(i);
  while(!q.empty()) {
    pii t = q.front();
    q.pop(), fix(t.first, t.second);
    for(int it : e[t.first]) check(it);
  }
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin);
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  cin >> n;
  for(int i = 2; i < n; i++) {
    int k = read(), x;
    while(k--) e[x = read()].push_back(i), rev[i].push_back(x);
  }
  solve1(), memcpy(mn, st, sizeof(mn));
  solve2(), memcpy(mx, st, sizeof(mx));
  for(int i = 0; i < n; i++) {
    if(mn[i] == mx[i]) cout << (mn[i] == 0 ? "0\n" : mn[i] == 1 ? "1\n" : "1/2\n");
    else cout << "?\n";
  }
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/9/13
author: Alex_Wei
start coding at
finish debugging at
*/
```

---

## 作者：DYYqwq (赞：2)

考虑上下界夹逼。我们知道，一个门你想让它尽量小（或大），那自然要让它的输入尽可能小（大）。

一个自然的想法是先把我们不知道状态的门随意设。

于是考虑先把所有除门 $1$ 以外的所有门的状态设为 $0$。接着进行 bfs 一类的操作。设置一个队列 $q$，其中都是被更新后，其后继需要进一步调整的门。每次取队首，并对其后继进行更新操作。接着，被更新的后继也应当加入队列中。

这是计算每个门下界的方式。同理，计算上界的时候，应当把所有门初始状态设为 $1$。

关于正确性：你为了计算上下界，总是要假设一些东西，而入过队列的一定是出了问题的，而你通过 bfs 操作进行了合理调整，而没入过队列的，一定没有问题，你随意假设它们。于是整个上下界一定是对的。

关于时间复杂度：考虑每次调整一定会变一下，在算下界的时候会变大，算上界的时候会变小，但是最多变 $2$ 次（$0 \rightarrow \frac{1}{2} \rightarrow 1$ 或相反），因此每个门只会被动态调整 $2$ 次，时间复杂度 $O(n)$ 级别。

实现细节见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {int to , nxt;}e[400010];
int n , k[10010] , num[10010][3] , tot , head[10010] , a[10010] , b[10010];
int qwq(int x)
{
	if(num[x][0] > num[x][1]) return 0;
	if(num[x][0] == num[x][1]) return 2;
	if(num[x][0] < num[x][1]) return 1;
	__builtin_unreachable(); assert(0);
}
void add(int u , int v)
{
	++ tot;
	e[tot].to = v;
	e[tot].nxt = head[u];
	head[u] = tot;
}
void solve1()
{
	for(int i = 1 ; i <= n ; i ++) num[i][0] = k[i]; // 所有全是 0
	queue<int> q; q.push(1); a[1] = 1;
	for(int i = head[1] ; i != 0 ; i = e[i].nxt)
	{
		int v = e[i].to;
		num[v][0] -- , num[v][1] ++; // 先把 1->x 这一部分处理好 
	}
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int i = head[u] ; i != 0 ; i = e[i].nxt)
		{
			int v = e[i].to; int now = qwq(v); // 受到 u 的影响，v 原先的和现在的不一样 
			if(a[v] != now)
			{
				for(int j = head[v] ; j != 0 ; j = e[j].nxt)
				{
					int vv = e[j].to;
					num[vv][a[v]] -- , num[vv][now] ++; // 对 v 后继产生影响 
				}
				a[v] = now; q.push(v); // 于是改变 v 的值，并加入队列，代表它会影响后继，且没有妥善处理完全 
			}
		}
	}
}
void solve2()
{
	memset(num , 0 , sizeof(num));
	for(int i = 1 ; i <= n ; i ++) num[i][1] = k[i] , b[i] = 1;
	queue<int> q; q.push(0); b[0] = 0;
	for(int i = head[0] ; i != 0 ; i = e[i].nxt)
	{
		int v = e[i].to;
		num[v][1] -- , num[v][0] ++;
	}
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int i = head[u] ; i != 0 ; i = e[i].nxt)
		{
			int v = e[i].to; int now = qwq(v);
			if(b[v] != now)
			{
				for(int j = head[v] ; j != 0 ; j = e[j].nxt)
				{
					int vv = e[j].to;
					num[vv][b[v]] -- , num[vv][now] ++;
				}
				b[v] = now; q.push(v);
			}
		}
	}
}
int main()
{
	scanf("%d" , &n);
	for(int i = 2 ; i < n ; i ++)
	{
		scanf("%d" , &k[i]);
		for(int j = 1 , x ; j <= k[i] ; j ++) scanf("%d" , &x) , add(x , i);
	}
	solve1();
	solve2();
	for(int i = 0 ; i < n ; i ++)
	{
		if(a[i] == b[i])
		{
			if(a[i] == 2) puts("1/2");
			else printf("%d\n" , a[i]);
		}
		else puts("?");
	}
	return 0;
}
```

---


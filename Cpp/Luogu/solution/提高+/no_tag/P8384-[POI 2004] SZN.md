# [POI 2004] SZN

## 题目描述

$\text{String-Toys joint-stock}$ 公司需要你帮他们解决一个问题。

他们想制造一个没有环的连通图模型，每个图都是由一些顶点和特定数量的边构成。每个顶点都可以连向许多的其他顶点。一个图是连通且无环的，图是由许多的线做成的。一条线是一条连接图中两个顶点之间的路径。

由于一些技术原因，两条线之间不能有重叠的部分，要保证图中任意一条边都被且仅被一条线所覆盖。

做一个这样的图的模型的费用取决于用了多少条线以及最长的那条的长度(每条边的长度都为 $1$ )。

现在给你对应的图，请你编写一个程序，求出最少能用多少条线以及在用最少线的情况下最长的那根线最短可以为多少。

## 说明/提示

对于 $100$ % 的数据：$2 \le n \le 10000,1 \le a,b \le n$ 。

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/00d4scv1.png)

## 样例 #1

### 输入

```
9
7 8
4 5
5 6
1 2
3 2
9 8
2 5
5 8```

### 输出

```
4 2```

# 题解

## 作者：intconstlee (赞：9)

## SZN 题解

贪心+二分

### 题意简述

给定一棵树，要求将树上的边划分成若干不相交的链，求最少链数并要求最长的链尽可能短，输出最少链数和最长链最短值。

### 思路分析

#### 第一问：求最少链数

从构建链的过程考虑，若子结点处形成若干链，其链会尝试向父结点拓展，称这种拓展为上传。对于一个结点，若我们已经从其子结点上传了若干链，则该结点对这些链有如下可能操作：

1. 合并两条链，新链不可继续上传
2. 向其父结点继续上传某条链
3. 保持，即不上传也不合并

发现操作二可以被视为子结点上传的链与祖先结点下传的链的合并，而操作三一定不会使答案更优。可以贪心。所以在某个结点处，对于其相邻结点（不再考虑父子关系）传来的链会优先合并，之后若剩余一条链无法合并，将其保持。也就是说会有 $\lfloor \frac{deg_u}{2} \rfloor$ 条链参与合并，合并会使答案 $-1$，初始可视为有 $n-1$ 条链，故第一问答案为
$$
n-1-\sum_{u\in V} {\lfloor \frac{deg_u}{2} \rfloor}
$$

#### 第二问：求最长链最短值

尝试贪心，对于某个结点，由于无法预知祖先节点的成链情况，只能考虑其子结点上传的链，可能操作同上，因为要保证链数最少，所以依然优先合并，之后上传剩余的链。但发现合并情况未知；同时若子结点数为偶数，最后剩余的两条链不一定合并。原因可以从上文出发，即上传是一种与祖先的合并，祖先情况未知时我们并不知道一条链是与其兄弟链合并更优还是与祖先链合并更优，所以直接贪心失败。

反向思考，发现无法直接贪心的原因为不确定链长限制，导致不确定是否可以合并。但在链长度的上限一定，不保证最少链数的情况下则仍可以贪心：先将所有合并后长度未超过限制的链合并，之后根据限制决定上传还是保持。

于是二分答案，二分链长上限 $x$，将问题转化为判断问题：由于未保证最少链数，需要判断链长上限为 $x$ 时合并后的总链数是否满足最少链数。

### 做法实现

建图，统计度数，得第一问答案；对第二问，二分链长上限，搜索链数。在搜索中，对子结点上传的链按长度排序，枚举最长链，尝试将当前最长链与合并后长度不大于但最接近二分答案的链合并，若无法找到这另一条链，则只能上传或保持。最终一个结点上传的链长是其未能合并链中最短的，若全部合并，上传值为 $0$。最终别忘了根节点无法上传链，所有没能合并的链都将保持。

该题解曾经被 hack，原因是之前笔者在做法上尝试使用最长链直接与最短链合并，这显然是不对的，十分小丑，在此谢罪。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=10005;
int n,x,y,num,ans,cnt,dg[N],len[N],head[N];
struct edge {int to,nxt;} e[N<<1];
void addin(int x,int y)
{
    e[++cnt]={y,head[x]},head[x]=cnt,dg[y]++;
    e[++cnt]={x,head[y]},head[y]=cnt,dg[x]++;
}
void dfs(int u,int p,int x)
{
    if(dg[u]==1&&u!=1) return len[u]=0,void();
    multiset<int> tmp; tmp.clear(),len[u]=0;
    for(int i=head[u];i;i=e[i].nxt)
    {
        int v=e[i].to;
        if(v==p) continue;
        dfs(v,u,x),tmp.insert(len[v]+1);
    }
    while(tmp.size())
    {
        auto lst=tmp.end(); lst--;
        int tmplen=(*lst);
        tmp.erase(lst);
        auto it=tmp.upper_bound(x-tmplen);
        if(it==tmp.begin()) len[u]=tmplen,ans++;
        else it--,tmp.erase(it),ans++;
    }
    if(!len[u]) return;
    len[u]+1<=x?ans--:len[u]=0;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n,num=n-1;
    for(int i=1;i<n;i++) cin>>x>>y,addin(x,y);
    for(int i=1;i<=n;i++) num-=dg[i]/2;
    int l=1,r=n-1,mid;
    while(l<r)
    {
        mid=(l+r)/2,ans=0,dfs(1,0,mid);
        ans+=(len[1]?1:0),ans>num?l=mid+1:r=mid;
    }
    cout<<num<<" "<<l<<endl,exit(0);
}
```



---

## 作者：honglan0301 (赞：2)

## 题目分析

不知道第多少次做几乎一样的题了，但还是调半天错。

我们肯定分别考虑两问的答案。先看第一问，考虑初始情况是每条边都是一条链，然后对于每个点我们一定要尽可能多地把周围一圈链两两合并起来。那么直接贪心，注意到这是能够保证正确性的，因为它不会使合并后的链变得不合法。于是第一问的答案是 $n-1-\sum \lfloor {deg_i\over 2} \rfloor$。

再看第二问，首先你发现可以二分转化成判定问题，然后再贪心地想，每个点会在子树中形成若干条链，然后向上传一条链，显然每个点向上传尽可能短的链一定是更优的。我们类似树上 $\text{dp}$ 的方式，对于每个点 $i$ 把它所有儿子传上来的链长插到 $\text{multiset}$ 里，然后根据子节点个数 $du_i$ 的奇偶性分类判断：如果 $du_i\equiv 1 \pmod 2$，那么为了保证链数最小一定是两两合并剩一条传上去；如果 $du_i\equiv 0 \pmod 2$，那么若能两两合并完则把 $0$ 传上去，否则合并完剩两条，其中短的那条传上去。其余情况均不合法，容易判断。

时间复杂度 $O(n\log^2 n)$，可以通过本题。

## 代码

```cpp
/*
  author: PEKKA_l  
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;
#define pb push_back
#define int long long

int n,u,v,ans1,mid,flag,du[10005];
vector <int> e[10005];

int dfs(int x,int fat)
{
	multiset <int> s;
	for(auto i:e[x]) {if(i==fat) continue; s.insert(dfs(i,x));}
	int nnum=0,cntt=0;
	while(!s.empty())
	{
		auto it=s.end(); it--; int kk=*it; s.erase(it); if(kk>mid) flag=0;
		auto to=s.upper_bound(mid-kk); 
		if(to==s.begin()) {if(cntt>1) flag=0; else nnum=kk; cntt++;}
		else {to--; s.erase(to);}
	}
	if(du[x]%2==1&&cntt>1) flag=0;
	if(x==1&&du[x]%2==0&&cntt) flag=0;
	return nnum+1;
}

signed main()
{
	cin>>n; ans1=n-1;
	for(int i=1;i<=n-1;i++) {cin>>u>>v; e[u].pb(v); e[v].pb(u); du[u]++; du[v]++;}
	for(int i=1;i<=n;i++) ans1-=du[i]/2; cout<<ans1<<" ";
	for(int i=2;i<=n;i++) du[i]--;
	int ll=1,rr=n-1;
	while(ll<=rr)
	{
		mid=(ll+rr)>>1; flag=1; if(dfs(1,1)>mid+1) flag=0;
		if(!flag) ll=mid+1; else rr=mid-1;
	}
	cout<<ll<<endl;
}
```


---

## 作者：hnczy (赞：1)

一道非常经典的题，这种类似线段覆盖一颗树的题目还是蛮常见的。

第一问可以 $dp$ ，但是有更简单的方法，对于经过一个点的所有边，我们都希望它两两配对，所以最佳的情况是有$ \lfloor d_i/2\rfloor$ 对边可以配对，所以总答案就是 $n-1 - \sum \lfloor d_i/2\rfloor $。

第二问比较经典，容易想到二分，这里的二分最大边长为 $len$，对于一个点有下面的线段有两种情况，可能是下面全部都自己消化掉，没有留给上面的，而另一种情况是有一条线段留给上面的。设 $f_i$ 为 $i$ 这个点留给上面的链的长度，如果没有就是 0。

那对一个点更新的时候就可以把儿子的 $f_i+1$ 这里还要加上相连的这一条边。可以储存在 multiset 里。之后需要贪心的两两配对，这里我们从小到大配对，假设现在的值为 $val$ 找到一个小于等于 $len-val$ 的最大值，删除即可（记得 $val$ 这个点也要在二分查找之前删掉），若找不到，放入一个容器。最终若容器的大小大于 $2$ 明显不行，因为不符合我们对最少的线段的定义，在根节点大于 $1$ 也不行。而最终那个小一点的放在 $f_i$ 里，而另一个自己消化掉。

这里时间复杂度 $O(n\log n)$，不知道为什么 $n$ 只开 $10^4$。

---

## 作者：qwer6 (赞：0)

## 1. Description

给出一棵树，要求将这棵树分成若干条链。询问最少需要分成几条链，并且在链数最少的前提下，求出最长链的最短长度是多少。

## 2. Solution

发现第一问和第二问的答案可以分开求解，因此我们先求第一问，再求第二问。

第一问使用树形 DP 求解，定义 $f_u$ 表示将以 $u$ 为根的子树与连接 $u$ 与 $fa_u$ 的边分解成链的最少链数，那么首先将 $f_u$ 设为 $1+\sum_{v\in son_u} f_v$，并且记录 $cnt_u$ 表示 $u$ 的儿子数量。然后分类讨论，如果 $u$ 是 $1$ 的话，那么没有连向父亲的边，就只能将所有儿子两两拼接，减少 $1+\lfloor \frac{cnt_u}2\rfloor$ 条链，否则，如果 $cnt_u$ 是奇数的话，儿子两两拼接后恰好多出一个可以与连向父亲的边拼接，因此减少 $1+\lfloor \frac{cnt_u}2\rfloor$ 条链，反之，如果 $cnt_u$ 是偶数的话，儿子两两拼接正好拼完，只能减少 $\lfloor \frac{cnt_u}2\rfloor$ 条边。

第二问的话，显然答案具有单调性，如果存在最长链长度 $\le L$ 的合法方案的话，那么最长链长度 $\le L+1$ 的合法方案也必然存在，因此二分最长链长度 $L$，求解最少需要分解成几条链即可。

具体的，我们记录 $g_u$ 表示 $u$ 的子树中向 $fa_u$ 传递的链的长度，如果没有则为 $0$，那么对于所有 $v\in son_u$，使用一个 multiset 储存所有的 $g_v+1$，之后从大到小枚举 multiset 中的值 $x$，找到 multiset 中小于等于 $L-x$ 的最大值，如果可以找到，那么拼接这两条，链数加一，如果没有找到，那么就将 $x$ 作为待选的传递的链。最后在所有的待选的传递的链中找到最小的最为传递链，其余的全部单独成链即可。需要注意的是对于 $u=1$，没有向上传递的链，所有无法拼接的全部单独成链。最后判断链数是不是等于最少链数即可。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=1e5+5;
int n;
int f[N],g[N];
vector<int>e[N];
void dfs(int u,int fa){
	int cnt=0;
	for(int v:e[u]){
		if(v==fa)continue;
		cnt++;
		dfs(v,u);
		f[u]+=f[v];
	}
	if(u==1)f[u]-=cnt>>1;
	else{
		if(cnt&1)f[u]-=cnt>>1;
		else f[u]-=(cnt>>1)-1;
	}
}
void dfs(int u,int fa,int L,int &cnt){
	for(int v:e[u]){
		if(v==fa)continue;
		dfs(v,u,L,cnt);
	}
	multiset<int>st;
	for(int v:e[u]){
		if(v==fa)continue;
		if(g[v]+1>L){
			cnt++;
			g[v]=0;
		}
		st.insert(g[v]+1);
	}
	g[u]=0x3f3f3f3f;
	while(!st.empty()){
		cnt++;
		int x=*st.rbegin();
		auto it=st.lower_bound(x);
		st.erase(it);
		auto tmp=st.upper_bound(L-x);
		if(tmp==st.begin()){
			if(g[u]>x)g[u]=x; 
		}else st.erase(--tmp);
	}
	if(g[u]==0x3f3f3f3f)g[u]=0;
	else cnt--;
	if(u==1&&g[u])cnt++;
}
bool check(int x){
	int cnt=0;
	dfs(1,0,x,cnt);
	return cnt==f[1];
}
signed main(){
	read(n);
	for(int i=2,u,v;i<=n;i++){
		read(u),read(v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	int l=1,r=n,res=0;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			res=mid;
			r=mid-1;
		}else l=mid+1;
	}
	write(f[1]),Spa,write(res),Nxt;
}
```

---


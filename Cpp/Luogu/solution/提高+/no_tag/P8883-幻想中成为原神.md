# 幻想中成为原神

## 题目背景

钟离很喜欢数学题。

## 题目描述

其中一个问题是这样的：定义一个丘丘人是可以被击杀的，当且仅当存在一个大于 $1$ 的完全平方数能够整除它的编号。比如，$12$ 号丘丘人就是可以被击杀的，因为它能够被 $4$ 整除；$15$ 号丘丘人则不能被击杀。请计算编号为 $1\sim n$ 中的丘丘人中能够被击杀的个数。由于钟离秉承着“差不多得了”的做事理念，因此，他允许你的答案与真正的答案有着不超过 $2\times10^4$ 的绝对误差。

## 说明/提示

#### 样例解释

$1\sim 10$ 中，只有 $4,8,9$ 这 $3$ 个丘丘人可以被击杀，因此答案为 $3$。

需要注意的是，由于你的答案被允许与标准答案有 $2\times 10^4$ 的绝对误差，因此 $-2,3,20003$ 等输出都将被认为是正确的。

#### 数据范围

- $\text{Subtask 1(10 pts)}$：$n\le 10^5$。
- $\text{Subtask 2(20 pts)}$：$n\le 10^7$。
- $\text{Subtask 3(20 pts)}$：$n\le 10^9$。
- $\text{Subtask 4(20 pts)}$：$T=1$。
- $\text{Subtask 5(30 pts)}$：无特殊性质。

对于 $100\%$ 数据，满足 $1\le n\le 10^{18}$，$1\le T\le 10^4$，保证 $n$ 在范围内随机得到。

## 样例 #1

### 输入

```
3
10
32678
9686985
```

### 输出

```
3
12814
3797988```

# 题解

## 作者：zzx0102 (赞：32)

~~不喜欢打原神，但是很喜欢这道题。~~

介绍一下这题的非正解。

首先根据题意，可以暴力枚举所有平方数，然后暴力标记倍数。

这样的时间复杂度是 $O(n+T)$ 的，可以获得 $30$ 分。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10000010; bool vis[N]; int s[N];
void init(int n) {
	for(int i = 2; i * i <= n; i++) {
		int k = i * i;
		for(int j = k; j <= n; j += k) vis[j] =  1;
	}
	for(int i= 1; i <= n; i++) s[i] = s[i - 1] + vis[i];
}
signed main() {
	init(1e7); int t; cin >> t;
	while(t--) {
		int n; cin >> n;
		cout << s[n] << '\n';
	}
	return 0;
}
```

还不够。

考虑到正解和答案有一定内在联系，于是计算三个样例的输入与输出的比值。

答案是：

$$0.3,0.392,0.392$$

将第一组数据排除，我们发现答案与输入的比值大约是 $0.392$，同时此题允许 $20000$ 的误差，那么这样大概率是可以的，但是 $30$ 分。

于是暴力打表，打出前 $10^7$ 组数据答案与输入的比值的平均值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10000010; bool vis[N]; int s[N];
void init(int n) {
	for(int i = 2; i * i <= n; i++) {
		int k = i * i;
		for(int j = k; j <= n; j += k) vis[j] =  1;
	}
	for(int i= 1; i <= n; i++) s[i] = s[i - 1] + vis[i];
}
signed main() {
	init(1e7);
	long long sum = 0, c = 0;
	for(int i = 1; i <= 10000000; i++) sum += s[i], c += i;
	cout << 1.0 * sum / c;
	return 0;
}
```

得出的比值 $v$ 为 $0.392073$。

依然 $50$ 分，但是十分接近正解了。

考虑到前 $10000$ 组数据误差较大，同时再增加 $10^7$ 个样本容量，使得答案更加精确，然后多打几位小数，发现答案约为 $0.392072898146$。

不过只有 $70$ 分。

然后经过反复调整比值 $v$，得出 $v=0.39207289814597$ 时，可以通过本题。

与我用计算器算出来的题解里面讲的估计的比值 $1-\dfrac{6}{\pi^2}=0.39207289814597337133672322074163$ 是十分接近的，至少精确到了 $14$ 位，而本题的正解是整除分块，只是复杂度太高，不可以通过，需要估测。

有些时候推不出正解的比值，可以考虑通过打表等手段求出类似的值。

~~于是我们用红题的码量+橙题难度的打表薄纱了一道蓝题。~~

---

## 作者：OMG_wc (赞：20)

题意是求 $1\sim n$ 范围内存在平方因子数的个数， 由于允许 $\pm 20000$ 的误差，可以用概率来近似估计。

考虑问题的反面，即求不含平方因子数的概率（密度）。

很显然选出来的数，不能是 $2^2,3^2,5^2,\cdots,p_k^2$ 的倍数，而一个数不是 $p^2$ 的概率为 $1-\frac{1}{p^2}$，所以不含平方因子数的概率为 $\prod\limits_{p}1-p^{-2} $。

由欧拉乘积公式 $\sum\limits_n n^{-s}=\prod\limits_p\left(1-p^{-s}\right)^{-1}$，  可以得到概率为  $\frac{1}{\sum\limits_{i=1}^{\infty}\frac{1}{i^2}}$。

分母是全体自然数的平方倒数和，等于 $\frac{\pi^2}{6}$，证明这里空间太小写不下，可以参考 [【官方双语】巴塞尔问题：著名公式背后的惊人几何学](https://www.bilibili.com/video/BV1BW411x7DY)。

所以最终答案近似于 $n(1-\frac{6}{\pi^2})$ ，此处省略误差分析（~~把范围内所有数都算一遍就可以证明~~）。

补充下：$\frac{6}{\pi^2}$ 不仅是不含平方因子数的概率，也是任选两个自然数互质的概率。

再补充下：C++20 开始就可以不用`acos(-1)`来算 $\pi$ 了，直接用`std::numbers::pi`。





---

## 作者：hjqhs (赞：15)

你将扮演一位名为“旅行者”的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘“原神”的真相。   
phy 都写了这道题，我不可能不写对吧。  
由于你的答案可以与标准答案有 $2 \times 10^4$ 的误差，而且 $n \le 10^{18}$，所以可以打表找规律。多打一点表可以得到 $ans=n \times 0.392072898145973$ 时可以通过本题。  
下面给出证明。  
正推较为困难，从反面思考。我们要求出每一个数不含平方因子的概率。因为是不含平方因子，所以没有 $2^2,3^2,\dots,p_k^2$ 这些的因子，所以不含平方因数的概率是 $\prod_{p}(1-\frac{1}{p^2})$。  
由著名的欧拉公式知 $\sum_{n}n^{-\delta}=\prod_{p}(1-p^{-\delta})^{-1}$，经简单计算知概率为 $\frac{1}{\sum_{i=1}^{\infty}\frac{1}{i^2}}=\frac{1}{\frac{\pi^2}{6}}=\frac{6}{\pi^2}$。  
所以答案所求即 $1-\frac{6}{\pi^2}$。
```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define per(i,a,b) for(int i=b;i>=a;--i)
#define pv(i,p) for(int i=0;i<p.size();++i)
#define ptc putchar
#define il inline
#define reg register
// #define push_back pb
#define mp make_pair
#define eb emplace_back
// #define ret; return 0;
using namespace std;
const int N=100005;
const int MOD=998244353;
const int INF=0x3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
int Max(int a,int b){return a>b?a:b;}
int MAX(int a,int b,int c){return Max(a,Max(b,c));}
int Min(int a,int b){return a<b?a:b;}
int MIN(int a,int b,int c){return Min(a,Min(b,c));}
void Swap(int&a,int&b){int tmp=a;a=b;b=tmp;}
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int t;
void solve(){
	cin>>t;
	while(t--){
		int x;cin>>x;
		cout<<(int)(x*1.0*0.39207289814597)<<'\n';
	}
}
signed main(){
	// freopen(,,stdin);
	// freopen(,,stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```  
后记：有一个朋友告诉我，把 $\pi$ 的后几位换成 $114514$ 变成 $3.141592653589793114514$ 也能过。

---

## 作者：Leasier (赞：13)

~~不喜欢打原神，但是很喜欢这道题。~~

首先不难发现题目想让你求 $n - \displaystyle\sum_{i = 1}^n \mu^2(i)$。

经过一些常规转化我们可以得到其为 $n - \displaystyle\sum_{i = 1}^{\lfloor \sqrt{n} \rfloor} \mu(i) \lfloor \frac{n}{i^2} \rfloor$。直接二次数论分块可以做到 $O(T \sqrt[3]{n} + N)$，但显然不能通过。

注意到题目告诉我们**允许 $2 \times 10^4$ 以内的绝对误差**，考虑对上式进行估算。这里我们只看后半部分，可得：

- $\displaystyle\sum_{i = 1}^{\lfloor \sqrt{n} \rfloor} \mu(i) \lfloor \frac{n}{i^2} \rfloor = \sum_{i = 1}^n \mu(i) \lfloor \frac{n}{i^2} \rfloor \approx \sum_{i = 1}^n \frac{\mu(i)}{i} \lfloor \frac{n}{i} \rfloor = \sum_{i = 1}^n (\frac{\mu}{id} * 1)(i)$

至此我们将原问题转化成了一个求 $\frac{\mu}{id} * 1$ 前缀和的问题。由于 $(\frac{\mu}{id} * 1)(n) = \displaystyle\sum_{d \mid n} \frac{\mu(d)}{d} = \frac{\displaystyle\sum_{d \mid n} \mu(d) \times \frac{n}{d}}{n} = \frac{\varphi(n)}{n}$，则我们可以将原式化成 $\displaystyle\sum_{i = 1}^n \frac{\varphi(i)}{i}$。

注意到 $\dfrac{\displaystyle\sum_{i = 1}^n \frac{\varphi(i)}{i}}{n}$ 同时表示**随机选取正整数对 $(x, y)$ 使得 $1 \leq x \leq y \leq n$ 且 $x, y$ 互质的概率**，欧拉级数又告诉我们这个东西在 $n \to +\infty$ 时近似于 $\frac{6}{\pi^2}$，于是我们可以得出答案近似于 $n(1 - \frac{6}{\pi^2})$。误差项不会算，但是它过了。

直接输出即可。时间复杂度为 $O(T)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;
typedef long double ld;

const ld pi = 3.1415926535897932385l, val = 1.0 - 6.0 / pi / pi;

int main(){
	int t;
	scanf("%d", &t);
	for (register int i = 1; i <= t; i++){
		ll n;
		scanf("%lld", &n);
		printf("%lld\n", (ll)(n * val));
	}
	return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：7)

写在前面：这是一篇几乎没有任何数论基础的人也能看的懂的题解，因为作者就没有数论基础。



------------


很有趣的一道题，~~感觉思维难度并没有蓝~~，看到可以有误差 + 庞大的数据范围，于是一眼看比值。

容易想到，对于每个数，能被 $p^2$ 整除的概率是 $\frac{1}{p^2}$，也就是 $p^{-2}$，因为每 $p^2$ 才会出一个能整除的数。现在我们想求的是至少有一个数能整除完全平方数的概率，那么可以先算出来一个数**不能**整除完全平方数的概率，也就是 $1-p^{-2}$，然后乘法原理算出所有数**都不能**整除完全平方数的概率，即为 $\prod_{p} \left(1 - p^{-2}\right)$。最后再用 $1$ 减一下就好了。

然后感觉这个东西很熟悉，于是把欧拉乘积公式翻了出来：

$$
\sum_{n=1}^{\infty} n^{-s} = \prod_{p} \left(1 - p^{-s}\right)^{-1}
$$

我们把欧拉乘积公式的 $s$ 替换成 $2$，得

$$
\sum_{n=1}^{\infty} n^{-2} = \prod_{p} \left(1 - p^{-2}\right)^{-1}
$$

然后两边取倒数，得

$$
\frac{1}{\sum_{n=1}^{\infty} n^{-2}} = \prod_{p} \left(1 - p^{-2}\right)
$$

发现右边就是我们想要求的东西。

左边的分母是所有正整数的平方倒数和，等于 $\frac{\pi^2}{6}$，这里不细说了。所以，不含平方因子数的概率为：

$$
\frac{1}{\frac{\pi^2}{6}} = \frac{6}{\pi^2}
$$

由于我们算的是所有数**都不能**整除完全平方数的概率，所以至少有一个能整除的概率就是

$$
1 - \frac{6}{\pi^2}
$$


最后，将这个概率乘以 $n$，就可以得到在 $1$ 到 $n$ 范围内存在平方因子数的数的期望数量：

$$
\text{答案} = n \cdot \left(1 - \frac{6}{\pi^2}\right)
$$

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long double p=acos(-1.0);
int main(){
	long long t,n;
	cin>>t;
	while(t--){
		cin>>n;
		cout<<(long long)(n*(1.0-6.0/p/p))<<endl;
	}
	return 0;
}

```

再说几句闲话，这题题面有点坑，我一开始理解成了恰好有一个能整除的，所以推出来了个这个式子，不知道对不对，有没有大佬能帮忙看看，可能也许大概收敛于 $\frac{3}{8}$（猜的）。

$$
\frac{n+1}{2n}\times\sum\limits_{i=2}^n \frac{1}{i^2-1}
$$


---

## 作者：Milthm (赞：6)

题目要求的是带平方因子的数的个数，因为允许有误差，所以可以算算概率。

直接算不好算，正难则反，考虑没有平方因子的数的个数，也就是有质数平方因子的数的个数。假设当前质数为 $p$，则每一个数不含 $p^2$ 的概率为 $1-\frac{1}{p^2}$，总的答案就是 $\prod_p(1-\frac{1}{p^2})$。

这里比较难办，不过在某度的加持下，搜到了[欧拉乘积公式](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E4%B9%98%E7%A7%AF%E5%85%AC%E5%BC%8F/8415243)。我们发现正好符合，于是就有：

$$\prod_p(1-\frac{1}{p^2})=\frac{1}{\sum_nn^{-2}}$$


观察分母，发现它是正整数平方倒数和，证明过程我不会，但是[这里有](https://zhuanlan.zhihu.com/p/67450658)，总之结果即为 $\frac{6}{\pi^2}$。从而，刚开始要算的那个概率也就是 $1-\frac{6}{\pi^2}$，答案也就是 $n(1-\frac{6}{\pi^2})$。

### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n;
long double pi=3.14159265358979323846,qwq=1-6/pi/pi;
signed main(){
	cin>>T;
	while(T--){
		cin>>n;
		cout<<(int)(n*qwq)<<'\n';
	}
	return 0;
}

```


---

## 作者：liaiyang (赞：5)

真就纯数论题。

拿到题的第一眼我们可以发现它在求 $n-\sum_{i=1}^n\mu^2(i)$，但是显然推完式子后你需要大量卡常在加入一点选择性眼瞎寄巧。

我们返璞归真一下，对于每一个数 $p$，它的贡献是 $\frac 1{p^2}$。

那么你现在要求总概率 $1-\prod_{p\in P} (1-\frac 1 {p^2})$。

我们有欧拉乘积公式 $\sum_{n\in N^+} n^{-s}=\prod_{p\in P} (1-p^{-s})^{-1}$。

$$
\begin{aligned}
\sum_{n\in N^+} n^{-s}=\prod_{p\in P} (1-p^{-s})^{-1}\\
\implies\sum_{n\in N^+} n^{-2}=\prod_{p\in P} (1-p^{-2})^{-1}\\
\implies\frac 1 {\sum_{n\in N^+} \frac 1 {n^2}}=\prod_{p\in P} (1-\frac 1 {p^2})
\end{aligned}
$$

右边这一坨是我们要求的，左边这一坨的分母是我们熟悉的巴塞尔问题，它等于 $\frac {\pi^2}6 $。

所以最终概率是 $1-\frac 6{\pi^2}$。

再把它乘上一个 $n$，你就有一个 $O(T)$ 的做法了。

```cpp
#include<bits/stdc++.h>
using namespace std;
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3,"Ofast")
#define int long long
#define y0 Y0
#define y1 Y1
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define min(a,b) (a<b?a:b) 
#define max(a,b) (a>b?a:b)
#define P pair<int,int>
#define x first
#define y second
#define modd(x) (((x)%mod+mod)%mod) 
#define rd read()
#define lowbit(x) ((x)&(-x))
#define abs(x) ((x)<0?-(x):(x))
#define submod(x,y,mod) (((x-=y)<0)&&(x+=mod))
#define addmod(x,y,mod) (((x+=y)>=mod)&&(x-=mod))
mt19937 rnd(time(0));
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(int u=0, char c=getchar(), bool f=false){
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) u=(u<<1)+(u<<3)+(c^'0');
	return f?-u:u;
}
inline void wt(int x){
	if(x<0) x=-x,putchar('-');
	if(x>9) wt(x/10);
	putchar((x%10)^'0');
}
inline void wt(int x,char k){wt(x),putchar(k);}
const int inf=~0U>>1,linf=~0ULL>>1;
const int mod=998244353,g=3,gi=332748118;
const int N=2e5+10;
const double pi=acos(-1),x=1-6/(pi*pi);
int T,n;
main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	T=rd;
	while(T--){
		n=rd;
		wt(n*x,'\n');
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：5)

### 思路

#### $30$ 分做法：

这道题我第一眼是多重 `for` 来暴力这题，可他允许你的答案与真正的答案有着不超过 $2\times10^4$ 的绝对误差，这他有何用意呢？

不出所料，`RE`了。

#### 满分做法：

其实这题他故意把测试点拉长，实际是想让我们搞出计算公式。能被 $p^2$ 整除的概率是 $\frac{1}{p^2}$，我们把欧拉公式搬出来：
$${\sum^{\infty}_{n=1}}^{-s}=\prod_{p}(1-p^{-s})^{-1}$$ 
找朋友带入并简化一下可得：



$\begin{aligned}\frac{1}{\sum_{i=1}^\infty n^{-2}} &=\frac{1}{\sum_{i=1}^\infty+\frac{1}{i^2} } \\ &= \frac{1}{\frac{\pi ^2}{6}} \\ &=\frac{2^{2}+2}{\pi^2} \\ &=\frac{2 + \sqrt{2}}{\pi} \\ &= \frac{6}{\pi^2}
\end{aligned}$

``众所周知`` $ \pi \approx 3.1415926535898 $，于是我们可以写出代一下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const long double kun = 3.1415926535898;
//不会算 pi 的请转至P1727
int main(){
    long long f, j;
    cin >> f;
    while(f--){
        cin >> j;
        cout << (long long)(j * (1.0 - 6.0 / kun / kun)) << "\n";
    }
    return 0;//写完撒花
}
```


~~管理员求过_O_W_O_~~

---

## 作者：wbqhasvcf (赞：3)

这道题首先我们需要知道代表“一个数不含有大于 $1$ 的完全平方数因子”的公式，这里作为一篇比较简洁的信息学题解对此不做阐述，可以去别的楼看一看或者自己搜一搜理解：
$\dfrac{6}{\pi^2}$。

而如果求一个数含有大于 $1$ 的完全平方数因子的概率，就拿 $1$ 减去它，那么 $1$ 到 $n$ 的概率就得再乘上一个 $n$。最重要的是这道题故意给了你一个“输出的答案与标准答案误差在 $\pm20000$ 内”，就是让你能够在 ```long double``` 能表示的精度范围内得到合理答案，所以这道题的代码其实很简单：

```
#include<iostream>
#define ull unsigned long long 
using namespace std;
const long double pi=3.1415926535898;

int t;//t可以用int类型但n不行 
ull n;//无符号长整型变量，用long long也可以，但保险起见开大点 
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<(ull)(n*(1.0-6.0/pi/pi))<<endl;//直接输出 
    }
    return 0;
}
```


---

## 作者：Archy_ (赞：0)

## 题目大意：
[传送门](https://www.luogu.com.cn/problem/P8883)

给出 $n$ 个正整数 $x_i$，求出 $1$ ~ $x_i$ 的大于 $1$ 的完全平方数的个数。  

## 思路展开
首先，看到这道题允许有误差，我们很容易想到这道题用概率去解决。即 $x_i$ 乘上一个非精确的数。

其次，令正整数 $p>1$，每 $p^2$ 个连续的正整数，必有 $1$ 个数为 $p^2$ 的倍数。所以一个数为 $p^2$ 的倍数概率为 $\frac{1}{p^2}$，不为 $p^2$ 的倍数概率为 $1-\frac{1}{p^2}$。

接着，答案就是 
$$\prod_{p}^{}1-\frac{1}{p^2}$$  

根据欧拉乘积式，

$$\sum_{n} n^{-s}=\prod_{p}\left(1-p^{-s}\right)^{-1}$$

当 $s=2$，有

$$\sum_{n} n^{-2}=\prod_{p}\left(1-p^{-2}\right)^{-1}$$

$$\frac{1}{\sum_{n} n^{-2}}=\prod_{p}\left(1-p^{-2}\right)$$

而自然数的平方倒数和为 $\frac{\pi^2}{6}$，

$$\prod_{p}^{}1-\frac{1}{p^2}=\frac{6}{\pi^2}$$

这是不为 $p^2$ 的倍数概率，为 $p^2$ 的倍数概率即为 $1-\frac{6}{\pi^2}$。

这里给出两个欧拉公式证明链接。

[欧拉乘积式](https://blog.csdn.net/fztsilly/article/details/106525876)

[自然数倒数求和](https://www.bilibili.com/video/BV1n14y1r77N/?spm_id_from=333.788.recommend_more_video.-1&vd_source=67d146d2b8f5294cc19fd0d542539ad7)

## CODE 
代码十分简短
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main() {
	int n; cin >> n;
	while(n --) {
		long long x; cin >> x;
		cout << (long long)(x * ( 1 - 6 / acos(-1) / acos(-1))) << "\n";
      //acos(-1)可以计算π的值
	}
    return 0;
} 
```

---


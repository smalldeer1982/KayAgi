# [DTOI 2023] C. 不见故人

## 题目背景

虽然 luanmenglei 已经是成熟的高中生了，但每次提起 luanmenglei 八年级的女朋友时，luanmenglei 都会沉浸在美好的回忆中，不可自拔。

## 题目描述

给定 $n, k$ 和序列 $\{a_n\}$，你同时有一个临时变量 $x$，你可以进行以下操作若干次（也可以是 $0$ 次），一次操作的流程是：
1. 选定一个区间 $[l,r]$，$\forall i\in[l,r]$，$x\leftarrow \gcd(a_l,a_{l+1},\cdots,a_r)$。
2. $\forall i\in[l,r]$，$a_i\leftarrow x$。

简而言之，你每次可以选定一个区间并将其中每个数变成这个区间的 $\gcd$。

一次操作的代价是 $r-l+1+k$，现在你希望把这个序列的每个数都变成相等的，求最小代价和。

----
如果您不了解 $\gcd$ 或者多元 $\gcd$ 的含义，可以参照如下定义：
- $\gcd(a_1,a_2,\dots, a_k)$ 表示 $a_1,a_2,\dots, a_k$ 的最大公约数，即最大的能同时整除 $a_1,a_2,\dots, a_k$ 的正整数。


## 说明/提示

#### 【样例 1 解释】

操作一次，选择区间 $[1,10]$。

#### 【样例 4】

见附加文件中的 `old/old4.in` 与 `old/old4.out`。

该样例满足测试点 $9\sim 12$ 的限制。

#### 【样例 5】

见附加文件中的 `old/old5.in` 与 `old/old5.out`。

该样例满足测试点 $13\sim 16$ 的限制。

#### 【数据范围与提示】

对于所有数据，保证 $1\leq n\leq 4\times 10^6$，$0\leq k\leq 10^9$，$1\leq a_i\leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 | $n\leq$ | $k,a_i\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^6$ | $10^9$ | 所有数都相等 |
| $2\sim 4$ | $4$ | $10^9$ | 无 |
| $5\sim 8$ | $100$ | $10^9$ | 无 |
| $9\sim 12$ | $1000$ | $10^9$ | 无 |
| $13\sim 16$ | $10^6$ | $10^9$ | 无 |
| $17\sim 20$ | $4\times 10^6$ | $10^9$ | 无 |

本题的读入量较大，请选择较快的读入方式，下面提供一种读入策略：

请在代码的开头加入此行：`std::ios::sync_with_stdio(false);std::cin.tie(0);`。

请注意，加入本行后 `cin/cout` 的效率将大幅提高，保证其能在 `250 ms` 内读入所有数据，**但使用后你仅能使用 `cin/cout` 流读入数据。**

## 样例 #1

### 输入

```
10 3
2 2 2 1 2 2 2 1 2 2 
```

### 输出

```
13```

## 样例 #2

### 输入

```
10 0
2 2 2 1 2 2 2 1 2 3 
```

### 输出

```
9```

## 样例 #3

### 输入

```
11 0
2 2 2 1 2 2 2 1 1 3 3 ```

### 输出

```
10```

# 题解

## 作者：FFTotoro (赞：9)

## 前言

怎么跟昨晚 ABC334 的 F 有异曲同工之妙啊，但是昨晚 F 多了个转移的限制，可以用单调队列解决，本题则只需要记录一个最小值。做完这题可以使用 [[ABC334F] Christmas Present 2](https://www.luogu.com.cn/problem/AT_abc334_f) 练练手。

## 解法

显然最后整个数组的元素都会变成原数组中所有元素的 $\gcd$，令其为 $g_0$。

于是考虑一些本来就不用变动的元素，它们将数组划分成了若干个段（即 $a_i\ne g_0$ 的元素构成的若干个段）。这些段可以使用 `std::vector` 存储 `std::pair` 实现。**注意代码中存储的段是左闭右开的**，即存储方式类似 $[l_i,r_i)$。

如果这样的段不存在，也就是说原数组所有元素都相等，答案为 $0$。

否则进行 DP。令 $f_i$ 表示处理到第 $i$ 个段 $[l_i,r_i)$ 时的最小代价，$g_i$ 表示 $a_{[l_i,r_i)}$ 间元素的 $\gcd$，那么 $f_i$ 可能有两种来源：

- 仅仅将段内进行操作，不操作两端值为 $g_0$ 的元素：$f_i\leftarrow f_{i-1}+r_i-l_i+k+[g_i\ne g_0]$（为什么要考虑 $g_i\ne g_0$？此时需要将它两边的其中一个 $g_0$ 一起操作，这样才能使这一段的值全部变为 $g_0$）；

- 和前面的段（这里是从第 $j$ 段开始）连在一起操作：$f_i\leftarrow\min\{f_{j-1}+r_i-l_j+k\}$，而后面的式子可以变为 $\min\{f_{j-1}-l_j\}+r_i+k$，所以只需用一个变量维护 $f_{j-1}-l_j$ 的最小值即可。

示例代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n,k,g0=0,l=0,m=2e9; cin>>n>>k;
  vector<int> a(n);
  for(auto &i:a)cin>>i,g0=gcd(g0,i);
  vector<pii> b;
  while(1){
    while(l<n&&a[l]==g0)l++;
    if(l==n)break;
    int r=l+1;
    while(r<n&&a[r]!=g0)r++;
    b.emplace_back(l,r),l=r;
  } // 找段的过程
  if(b.empty())cout<<"0\n",exit(0);
  vector<int> f(b.size());
  for(int i=0;i<b.size();i++){
    auto [l,r]=b[i]; int g=0;
    for(int j=l;j<r;j++)g=gcd(g,a[j]);
    f[i]=(i?f[i-1]:0)+r-l+(g!=g0)+k;
    if(m<2e9)f[i]=min(f[i],r+m+k);
    m=min(m,(i?f[i-1]:0)-l);
  } // 按照上面的方程转移
  cout<<f[b.size()-1]<<endl; // 答案
  return 0;
}
```

---

## 作者：E_huan (赞：9)

前言，考场上写了一个和标算不同的贪心做法，但是少个对于全部相同的特判得分 $95$，考后加了特判就 AC 了。后来题目提供者 Cocoly1990 私信我问能不能证明正确性，我尝试证明了一下，我们都觉得挺对的，遂发题解。如果发现这个证明有问题请指出，感激不尽！

------------
## 做法：
找出所有长度大于 $k$ 的等于全局 gcd 的段，以它们为分界线得到若干个段。

若段内 gcd 超过全局 gcd，则多带上旁边的一个全局 gcd。
但是发现连续两端带上旁边的 gcd 之后就可能会导致把这段全局 gcd 选了反而更优。

贪心地，从前往后看，若本来的 gcd 段是 $k+1$，且左右需要延申，就把左右两端连上，并且标记这两端都不需要延申了。

## 正确性说明：
不难发现**最终结果肯定是所有数变成全局 gcd** ，而**每个位置最多被修改一次**（如果修改两次则一定可以有办法不修改第一次，且答案不劣），所以当有一段的 gcd 不是全局 gcd 的时候，它们修改了也不是全局 gcd，一定不优，所以肯定会选择与旁边的若干个数合并使得 gcd 变成全局 gcd。

所以最终的策略肯定是操作若干个不交的段，且段与段之间必定间隔至少 $k+1$ 个等于 gcd 的元素（否则两段合起来一次变化肯定不劣）。

称段内 gcd 不是全局 gcd 的被分隔出的段为“非法段”。

最开始以长度大于 $k$ 的等于全局 gcd 的连续段作为分隔的构造，在假设所有段都不是非法段情况下肯定是最优的。而对于非法段，如果不吞掉完整的分割段，那在分割段上取 $>1$ 个肯定没有取恰好 $1$ 个优，且取恰好一个就可以使其合法了。

那么考虑什么时候会吞掉完整的分割段。非法段向旁边（左边或右边）的段取 $1$ 个的时候，可以看作让这段长度 $-1$，由于分割段长度 $>=k+1$，只有长度恰好是 $k+1$ 且左右都向它取的时候，它的长度变成 $k-1$，直接把它吞并更优。

全都不吞的情况下已经确定了一个答案，如果能满足吞的条件就可以使答案减小 $1$，所以尽可能使它满足吞的条件。贪心地确定每个非法段是向左使分割段长度 $-1$ 还是向右，尽可能让更多的长度是 $k+1$ 的段的左右都向它 $-1$。

如果对于非法段，满足“它左边的分割段长度是 $k+1$ 且这个分割段的左边的段选择在这个分割段 $-1$”  ，那么该段和分割段的前一段一定能消去这个分割段，而该段和后一段未必可以，所以该段选择向左 $-1$ ，消去这个分割段一定不劣。如果不满足这个条件，则它和前一段一定不能消去它左边的分隔段，与右边的可能可以，所以选择让右边的分割段 $-1$ 一定不劣。


## 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
char buf[1<<23],*p1=buf,*p2=buf;
inline int read()
{
    int res=0; bool f=0;
    char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) res=res*10+(ch^'0'),ch=getchar();
    return f?-res:res;
}
const int N=4000010;
int n,k,a[N];
int l[N],r[N],tot;
int del_l[N],del_r[N];
int gcd(int x,int y)
{
    if(!y) return x;
    return gcd(y,x%y);
}
int main()
{
    n=read(),k=read();
    for(int i=1;i<=n;i++) a[i]=read();
    int ed=a[1];
    for(int i=2;i<=n;i++) ed=gcd(ed,a[i]);
    for(int i=1;i<=n;i++)
        if(a[i]==ed)    
        {
            if(a[i-1]!=ed) l[++tot]=i;
            if(a[i+1]!=ed)
            {
                if((l[tot]!=1)&&(i!=n)&&i-l[tot]+1<=k) tot--;//长度不够(但是特判左右两端长度不够也是要的)
                else r[tot]=i;//长度够k+1
            } 
        }
    if(l[1]==1&&r[1]==n) {puts("0"); return 0;}//特判只有一段全是ed，否则最后“ans+(cnt+1)*k”会挂
    for(int t=1,L=1;t<=tot;t++)
    {
        if(l[t]==1) {L=r[t]+1; continue;}//开头就是全局gcd段就不用管了
        int g=a[L];
        for(int i=L+1;i<l[t];i++) g=gcd(g,a[i]);
        if(g!=ed)
        {
            if(del_l[t-1]&&(r[t-1]-l[t-1]+1==k+1))
            {
                del_r[t-1]=1;
                continue;
            }
            else del_l[t]=1;
        } 
        L=r[t]+1;   
    }
    if(r[tot]<n)
    {
        int g=a[r[tot]+1];
        for(int i=r[tot]+2;i<=n;i++) g=gcd(g,a[i]);
        if(g!=ed) del_r[tot]=1;
    }//后面一段
    int ans=n,cnt=0;
    for(int t=1;t<=tot;t++)
        if(!(del_l[t]&&del_r[t]))//没有被删除的段
        {
            for(int i=l[t]+del_l[t];i<=r[t]-del_r[t];i++)
                ans--;//ans是长度
            if(l[t]!=1&&r[t]!=n) cnt++;//有效间隔数
        }
    printf("%d\n",ans+(cnt+1)*k);
    return 0;
}
```

---

## 作者：_shy (赞：5)

## [P8940 C. 不见故人](https://www.luogu.com.cn/problem/P8940)
### 思路
1. 思考最后相同的数是什么。首先，对于一个区间我们可以划分为若干个子区间，对子区间在进行上述操作，如此继续，则一定存在某个时刻，某个区间分为若干个后不可再分，这时我们按题目中的要求合并，最后得到这个相同的数一定是 $\gcd\{a_1,a_2,\dots a_n\}$，记为 $G$。
2. 思考如何得到最小代价。容易想到最初值为 $G$ 的元素，在不影响答案的前提下，应当**尽可能少地参与到操作中**。于是，我们将最初值为 $G$ 的元素标记为红色，形成若干红色区间。则记被红色区间分隔开的若干个区间为黑色区间，并记 $p$ 为黑色区间的个数，$l_i,r_i$ 分别为第 $i$ 个黑色区间的左端点与右端点。则接下来我们只需要通过讨论这些黑色区间得到最小代价。
3. 思考如何通过黑色区间得到最小代价。当 $p=0$ 时，答案显然为 $0$。下面讨论 $p>0$ 的情形。易得，$r_i$ 为有效讨论点，因为若把 $1$ 到 $j,j\in[l_i,r_i)$ 变为 $G$，再把 $j+1$ 到 $r_i$ 变为 $G$，相比于直接把 $1$ 到 $r_i$ 变成 $G$ 会多消耗一次 $k$。故我们令 $dp_i$ 表示把 $1$ 到 $r_i$ 的全部元素变为 $G$ 付出的最小代价，则 $dp_p$ 即为最后的答案。
4. 思考 $dp_i$ 的转移方程。若 $dp_i$ 的转移没有跨过红色区间，则 $dp_i\gets dp_{i-1}+r_i-l_i+1+k+[\gcd\{a_j|j\in[l_i,r_i]\}\ne G]$。若 $dp_i$ 的转移跨过了红色区间，则 $dp_i\gets \min\{dp_j+r_i-l_{j+1}+1+k|j\in[0,i-1)\}$。故我们只需要动态维护 $dp_j-l_{j+1},j\in[0,i-1)$ 的最小值即可，用 **set** 可以很优秀的实现。
5. 最坏时间复杂度为 $\mathcal O(n\log n)$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 4e6 + 100;
int n, k, a[maxn], l[maxn], r[maxn], p = 0, G, dp[maxn], last_dp;
int gcd (int a, int b)
{
	if (a < b) swap (a, b);
	if (b == 0) return a;
	else return gcd (b, a % b);
}  
set <int> s;
int main ()
{
	scanf ("%d %d", &n, &k);
	for (int i = 1; i <= n; i++) 
	{
		scanf ("%d", &a[i]);
		G = gcd (G, a[i]);
	}
	int ii = 1;
	// [l_i,r_i] 的获得有细节，需要注意。
	while (ii <= n) 
	{
		while (a[ii] == G && ii <= n) ii ++;
		l[++ p] = ii;
		// l[p] == n + 1 表明最后这一块全为 G
		if (l[p] == n + 1)
		{
			p --;
			break;
		}
		while (a[ii] != G && ii <= n) ii ++;
		r[p] = ii - 1;
	}
	if (p == 0) printf ("0"), exit (0);
	// 为了保证正确性，定义 dp_0 - l_1 存在。
	last_dp = -l[1];
	for (int i = 1; i <= p; i++) 
	{
		int Gi = 0;
		for (int j = l[i]; j <= r[i]; j++)
			Gi = gcd (Gi, a[j]);
		dp[i] = dp[i - 1] + r[i] - l[i] + 1 + k + (Gi == G ? 0 : 1);
		if (!s.empty ()) dp[i] = min (dp[i], r[i] + 1 + k + *s.begin ());
		s.insert (last_dp);
		last_dp = dp[i] - l[i + 1]; 
	}
	printf ("%d", dp[p]);
	return 0;
}
```

---

## 作者：pikiuk (赞：5)

~~这是真人真事。~~

## 命题思路：

- 本题整体解法应该比较自然。
- 命题人先想题再想做法的。
- 然后本来也想让大家乐呵乐呵，但是好像大家还是没乐呵起来。
- 简单数论 / 动态规划 / 最优化 / easy。

## 题解报告：

### 算法 1

- 注意到当所有数都相等的时候，我们不需要操作。
- 期望得分 $10$ 分。

### 算法 2

- 我会搜索！
- $n\leq 4$ 应该随便搜索都能过去（心虚。
- 结合算法 1 期望得分 $15$ 分。

### 算法 3

- 我会观察性质！注意到最后的答案一定是全局 $\gcd$。证明平凡，略。

- 观察性质：每个数最多被一次操作覆盖。
- 证明同样平凡，分几种 corner case 证明重复操作可以合并就好了。
- 然后设计 $\rm dp$，记 $f_i$ 表示把 $1\sim i$ 都变成相同的数的最小代价。记全局 $\gcd$ 为 $G$。
- 有转移 $f_i=\min\{f_{j-1}+i-j+1+k+[\gcd(a_j,a_{j+1},\dots,a_i)\neq G]\}$。
- 直接转移是 $\mathcal{O}(n^3)$ 的，期望得分 $45$ 分。

### 算法 4

- 我会优化上面的 $\rm dp$！
- 我们考虑动态维护 $\gcd(a_j,a_{j+1},\dots,a_i)$。
- ~~当然了，强上数据结构也可以。~~
- 综合时间复杂度 $\mathcal{O}(n^2\log n)$ 的，期望得分 $65$ 分。

### 算法 5

- 我们把原序列满足 $a_i=G$ 的位置染红，其他染黑，则原序列形成若干黑色段。
- 记 $L_i,R_i$ 表示从左到右第 $i$ 黑色段的左右端点位置。
- 我会继续观察性质！注意到只有每段的右端点为有效转移点。因此我们改记 $f_i$ 表示把 $1\sim R_i$ 都变成相同的数的最小代价。
- 考虑分情况转移！如果从本段转移过来，则有 $f_i=f_{i-1}+R_i-L_i+1+k+[\gcd(a_{L_i},a_{L_i+1},\dots,a_{R_i})\neq G]$。
- 否则转移时选择的区间一定包含红色位置，那么可以直接把选择的区间变成 $G$。
- 则有 $f_i=\min\limits_{j<i-1}\{f_{j} + R_i-L_{j+1}+1+k\}$。
- 考虑第二种转移如何快速实现，不难发现，动态维护 $f_j-L_{j+1}$ 的最小值即可。
- 每次转移时上述两种情况取 $\min$ 即可。

- 综合时间复杂度 $\mathcal{O}(n\log a_i)$，瓶颈在于求 $\gcd$，事实上，常数只有 $\frac{1}{3}$。

---

## 作者：ryanright (赞：3)

年初的比赛，赛时想到了正解但是由于写挂只拿了 90。

题目要我们把整个序列都变成相等的，设这个相等的数为 $t$。那么有

$$t=\gcd(a_1,a_2,a_3,\cdots,a_n)$$

考虑证明上述结论。首先 $t$ 肯定同时是所有 $n$ 个数的约数，因为每次操作都有

$$\forall i\in[l,r],\gcd(a_l,\cdots,a_r)|a_i$$

也就是说，如果 $a_i$ 的值发生改变，一定只会变成它的某个约数，因此 $t$ 一定是 $a_1,\cdots,a_n$ 的公约数，即总 $\gcd$ 的约数。同时有

$$\gcd(a_1,\cdots,a_n)|\gcd(a_l,\cdots,a_r)$$

无论怎么操作，赋给区间的值一定都是总 $\gcd$ 的倍数，因此 $t$ 一定是也是总 $\gcd$ 的倍数。$t$ 又是总 $\gcd$ 的倍数，又是总 $\gcd$ 的约数，所以 $t$ 等于总 $\gcd$。

确定了最终结果之后，我们需要考虑如何安排操作使得代价最小。最直戳了当的操作就是直接一遍 $[1,n]$。肯定是可行的，但是代价是 $(n+k)$，不一定是最优的。

我们观察一下这个代价的形式，可以换种说法：每对一个数赋值，产生 $1$ 的代价；每进行一轮区间操作，产生 $k$ 的代价。直接一轮过，第二种代价肯定是最小的，但是第一种代价不一定最优，因为会出现 $a_i=t$ 的状况并对其进行无用赋值。

于是我们考虑走另外一个极端：把第一种代价压到最小。将整个序列以其中的 $t$ 分段，每一段内都没有值为 $t$ 的元素，且两边要么没有数，要么排着一些 $t$。每次我们就只对段进行操作，如果段内 $\gcd$ 不为 $t$ 还要从两边随便抓 $1$ 个 $t$ 过来使得其 $\gcd$ 为 $t$。

这样仍然不一定是最优的，因为第二种代价可能会由于分段过多而直接上天。我们需要进行一些平衡，即合并一些段。考虑现在有 $[l_1,r_1]$ 和 $[l_2,r_2]$ 两段，且 $(r_1,l_2)$ 中的元素都是 $t$，我们看看合并他们之后是否会更优。如果合并的话，代价就是

$$r_2-l_1+1+k$$

如果这两段独立的话，那么代价就是

$$(r_1-l_1+1+[\gcd(a_{l_1},\cdots,a_{r_1})\neq t]+k)+(r_2-l_2+1+[\gcd(a_{l_2},\cdots,a_{r_2})\neq t])+k)$$

比较并决策即可。时间复杂度为 $O(n)$。

```cpp
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
int a[4000005];
struct segment { // 分出来的段
    int l, r, gcd;
}s[4000005];
signed main() {
    int n, k;
    cin >> n >> k;
    if (!n) {
        cout << 0 << endl;
        return 0;
    }
    cin >> a[1];
    int t = a[1], p = 0;
    for (int i = 2; i <= n; i++)
        cin >> a[i], t = __gcd(t, a[i]);
    for (int i = 1; i <= n; i++)
        if (a[i] != t) { // 以 t 为依据分段
            if (!p || a[i - 1] == t)
                s[++p] = {i, i, 0};
            else
                s[p].r = i;
        }
    for (int i = 1; i <= p; i++) { // 计算每段 gcd
        s[i].gcd = a[s[i].r];
        for (int j = s[i].l; j < s[i].r; j++)
            s[i].gcd = __gcd(s[i].gcd, a[j]);
    }
    for (int i = 1; i < p; i++) // 尝试合并
        if (s[i + 1].r - s[i].l + 1 + k < s[i + 1].r - s[i + 1].l + s[i].r - s[i].l + 2 + k * 2 + (s[i + 1].gcd != t) + (s[i].gcd != t)) {
            s[i + 1].l = s[i].l;
            s[i + 1].gcd = t;
            s[i] = {0, 0, 0};
        }
    int ans = 0;
    for (int i = 1; i <= p; i++)
        if (s[i].l)
            ans += s[i].r - s[i].l + 1 + k + (s[i].gcd != t);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：_saltFish_ (赞：1)

# 简要题意

给出一个长为 $n$ 的序列 $a$ 以及一个数 $k$。可以进行任意次操作，每次操作可以选择一个区间 $[l,r]$ 将 $[l,r]$ 中的 $a_i$ 改为 $\gcd(a_i|l\le i\le r)$。每次操作的代价是 $r-l+1+k$，最小化代价并输出。

# 思路

显然最后整个序列一定是变成 $\gcd(a_i|l\le i\le r)$。

那么我们以序列中出现的 $g$ 分段，将原序列分为若干段后考虑将每个段操作。

如果一个段本身的最大公约数就是 $g$ 那么我们不需要再过多考虑。

如果不是，那么我们考虑在这一段中加入其他数字。由于我们是按照序列中出现的 $g$ 分段的，所以我们在左边或右边加入一个 $g$ 就能愉快地解决了。然后这一段贡献会加一。

再考虑两个段有可能一起操作会更优，如果将这两个段合并起来的代价要小于 $k$，那我们显然应该合并这两个段。

那么根据上述内容我们就得到了一个算法：首先将原序列按照序列中出现的 $g$ 分成若干段，然后再考虑将相邻的段进行合并。

一个小细节，合并两个段的时候，如果它的贡献刚好和它们分别操作的贡献相同，那么我们不进行合并。

假设我们现在有三个段 $a,b,c$，其中 $b,c$ 是需要再添加一个 $g$ 的，而将 $a,b$ 一起操作的代价与单独操作它们的代价相同，而合并 $b,c$ 就刚好能省下 $1$ 的贡献，这时我们如果合并 $a,b$，我们考虑到 $c$ 的时候就会导致合并 $(a,b)$ 和 $c$ 不能产生贡献（$b$ 需要的一个数字 $g$ 的贡献被前面合并掉了刚好将合并 $b,c$ 产生的 $1$ 的贡献顶掉了）所以我们在不能产生贡献时选择放弃合并。

据此有一个小 hack。

input:

```
9 1
2 3 1 1 2 2 1 1 2
```

output:

```
9
```

操作 $[1,2],[5,9]$。

# Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

#define LL long long

template<class T> inline void read(T &n) {
	n = 0;
	bool _f = 0; char _c = getchar();
	while(_c < '0' || '9' < _c) {if(_c == '-') _f = 1; _c = getchar();}
	while('0' <= _c && _c <= '9') n = n * 10 + _c - '0', _c = getchar();
	if(_f) n = -n;
}

const int N = 4e6 + 5;

struct SUB {
	int l, r, g;
};

int n, k, a[N], g, tot;
SUB s[N], ans[N];

int main() {
	read(n), read(k);
	
	for(int i = 1; i <= n; i++) {
		read(a[i]);
		g = __gcd(g, a[i]);
	}
	
	a[0] = g;
	
	for(int i = 1; i <= n; i++) {
		if(a[i] == g) continue;
		if(a[i - 1] == g) {
			tot++;
			s[tot].l = s[tot].r = i;
			s[tot].g = a[i];
			continue;
		}
		
		s[tot].r = i;
		s[tot].g = __gcd(s[tot].g, a[i]);
	}
	
//	for(int i = 1; i <= tot; i++) {
//		cout << s[i].l << ' ' << s[i].r << ' ' << s[i].g << '\n';
//	}
	
	if(!tot) {
		printf("0\n");
		return 0;
	}
	
	int cnt = 1;
	ans[cnt] = s[1];
	
	for(int i = 2; i <= tot; i++) {
		if(s[i].l - ans[cnt].r - 1 - (ans[cnt].g != g) - (s[i].g != g) < k) {
			ans[cnt].r = s[i].r;//记得将这个段是否需要一个g的代价考虑进去
			ans[cnt].g = g;
		} else {
			ans[++cnt] = s[i];
		}
	}
	
	LL sum = 0;
	
	for(int i = 1; i <= cnt; i++) {
		sum += ans[i].r - ans[i].l + 1 + k + (ans[i].g != g);
	}
	
	printf("%lld\n", sum);
}
```

---

## 作者：irris (赞：1)

## Preface

9 个月前我写过一个 90 分的贪心，似乎是细节挂了？当时扣扣莉还跟我说只是数据弱而已，不过过了不久题解区就来了个带证明的贪心做法，呃呃。

虽然，dp 确实不要动脑子啊！

## Solution

容易发现最优方案中选择出来的任意两个区间 $[l, r], [l', r']$ 无交。否则，仅选择一个区间 $[\min(l, l'), \max(r, r')]$，由于 $k \geq 0$，代价不会更劣，反而会减少 $-(k + S)$ 其中 $S$ 为区间重叠部分长度。

那么这就很没有后效性了，考虑 dp。不失一般性地设全局 gcd 为 $1$，那么每次取到的区间 $[l, r]$ 一定满足 $\gcd(a_l \dots a_r) = 1$（因为我们不会对同一个数操作两次）。设 $f_r$ 表示将 $a_1\dots a_r$ 全部变为 $1$ 的代价。有转移：

$$f_r = \min_{1 \leq l \leq r, \gcd(a_l \dots a_r) = 1} (f_{l-1} + r - l + 1 + k) = \min_{1 \leq l \leq r, \gcd(a_l\dots a_r) = 1} (f_{l-1} - l + 1) + k + r$$

特别地，若 $a_r = 1$ 则可以不对 $a_r$ 进行操作，则 $f_r \gets \min(f_r, f_{r-1})$。朴素地 $r$ 从小到大、$l$ 从大到小转移，至少可以做到 $\mathcal O(n(n + \log V)) = \mathcal O(n^2 + n\log V)$ 的复杂度，考虑优化。

我们设 $L_r = l$ 表示最大的 $1 \leq l \leq r$ 使得 $\gcd(a_l\dots a_r) = 1$，那么显然有 $L_r \leq L_{r+1}$，因为 $\gcd(1, a_{r+1}) = 1$。我们考虑计算出 $L_r$，那么剩下的同时维护 $(f_{l-1} - l + 1)$ 的前缀 min 即可解决问题。

因为 $r$ 和 $L_r$ 同时具有单调性，那么就看看双指针能不能做（数据范围 $4\times 10^6$ 诶，我们大部分时候已经有一个 $\log V$ 的小常数了）！如果我们能快速计算 $\gcd(a_l\dots a_r)$ 和维护 $r \gets r + 1$、$l \gets l + 1$ 操作，问题就得到解决了，然而可惜的是 gcd 可不能支持删除啊？

请出 **不带删尺取**！具体地，我们假设在处理区间 $[l, r]$，其中有一个分治点 $mid$。我们维护 $p_l\dots p_{mid}$ 其中 $p_i = \gcd(a_i\dots a_{mid})$，同时让 $val = \gcd(a_{mid + 1}\dots a_r)$。

+ 计算 $\gcd(a_l\dots a_r)$，直接求 $\gcd(p_l, val)$：**复合左右半边信息**。
+ $r \gets r + 1$：$val \gets \gcd(val, a_{r+1})$：**直接更新右信息**。
+ $l \gets l + 1$：若 $l + 1 \leq mid$ 则什么都不干，否则 $mid \gets r$，$val \gets 0$，我们重新求一遍 $p_l\dots p_{mid}$：**可以理解为一根弹力绳，如果它保持在左半边我们就不做处理，但是如果弹到超出限度的右边来就直接给它重新安在 $\bm{r}$ 上**。因为每个点最多被计算一次，均摊复杂度正确。

这样问题得到了解决，时间复杂度 $\mathcal O(n\log V)$，但是是不是有点卡常数啊（我跑了快 4/5 倍时限了）。

## Code

```cpp
#include <bits/stdc++.h>

namespace FastIO {
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= ch == '-', ch = getchar(); while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar(); return w ? ((~x) + 1) : x; }
	template <typename T> inline void write(T x) { x && (write<T>(x / 10), putchar(x % 10 ^ '0')); }
	template <typename T> inline void print(T x) { x || putchar('0'); x < 0 && (putchar('-'), x = (~x) + 1); write<T>(x); }
	template <typename T> inline void print(T x, char end) { x || putchar('0'); x < 0 && (putchar('-'), x = (~x) + 1); write<T>(x), putchar(end); }
}; using namespace FastIO;

#define MAXN 4000001
int a[MAXN], f[MAXN], g[MAXN];

inline int gcd(int x, int y) { return x == 0 || y == 0 ? (x | y) : gcd(y, x % y); }
int main() {
    int N = read<int>(), K = read<int>();
    for (int i = 1; i <= N; ++i) a[i] = read<int>();
    int G = a[1]; for (int i = 2; i <= N; ++i) G = gcd(G, a[i]);
    for (int i = 1; i <= N; ++i) a[i] /= G;
    for (int l = 1, mid = 0, r = 1, val = 0, pre = 0, t; r <= N; ++r) {
        t = gcd(t, a[r]), val = gcd(val, a[r]);
        auto chk = [&](int l, int r) -> bool {
            if (l > mid) {
                g[mid = r] = a[r], val = 0;
                for (int k = mid - 1; k >= l; --k) g[k] = gcd(g[k + 1], a[k]);
            }
            return gcd(g[l], val) == 1;
        };
        while (l + 1 <= r && chk(l + 1, r))
            ++l, pre = std::min(pre, f[l - 1] - l + 1);
        f[r] = r + K + pre;
        if (a[r] == 1) f[r] = std::min(f[r], f[r - 1]);
        if (t > 1) f[r] = 0x3f3f3f3f;
    }
    return print<int>(f[N]), 0;
}
```

## Postscript

为啥感觉都不太会不带删尺取（挠头）。

可以作为模板题食用。

---

## 作者：快斗游鹿 (赞：0)

## 思路

显然，最后所有数一定会变为原数列所有数的 $\gcd$，设为 $d$，且每个数至多被操作一次。

设 $f_i$ 表示将 $1$ 到 $i$ 变为 $d$ 的最小代价。则有 $f_i=\min(f_{j-1}+i-j+1+k+[\gcd(a_j,a_{j+1},\dots,a_i)\neq d])$。直接转移是 $O(n^3)$ 的，使用线段树维护区间 $\gcd$ 可以做到 $O(n^2\log n)$。

考虑优化，注意到有一些转移点是无用的。事实上除了原数列中等于 $d$ 的数，其他数肯定会被操作一次。那么所有等于 $d$ 的数就把数列划分为了若干不包含 $d$ 的段。如果从段内转移多次显然不优，只会增加代价。所以考虑设 $f_i$ 表示将第 $1$ 到第 $i$ 段变为 $d$ 的最小代价。分两种情况：

不跨越其他段：$f_i=f_{i-1}+r_i-l_i+1+k+[g\neq d]$。$l,r$ 是当前段左右端点，$g$ 是该段内所有元素 $\gcd$，均可以预处理出来。

跨越其他段，则跨越区间一定有 $d$：$f_i=f_{j}+r_i-l_{j+1}+1+k$。直接转移还是 $O(n^2)$ 的，注意到只有 $f_j-l_{j+1}$ 与 $j$ 有关，记录它的最小值即可。

## 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e6+5;
int n,k,a[N],d,ans,f[N],l[N],r[N],gcd[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
signed main(){
	memset(f,0x3f,sizeof(f));
	n=read();k=read();
	for(int i=1;i<=n;i++)a[i]=read(),d=__gcd(d,a[i]);
	bool g=0,p=0;
	for(int i=1;i<n;i++){
		if(a[i]!=a[i+1])g=1;
	}
	for(int i=1;i<=n;i++){
		if(a[i]==d)p=1;
	}
	if(!g){
		cout<<0;return 0;
	}
	if(!p){
		cout<<n+k;return 0;
	}
	int cnt=0,ll=-1,gg=0;
	a[n+1]=d;
	for(int i=1;i<=n+1;i++){
		if(a[i]!=d&&ll==-1)ll=i,gg=0;
		if(a[i]==d&&ll!=-1){
			l[++cnt]=ll;r[cnt]=i-1;ll=-1;gcd[cnt]=gg;
		}
		gg=__gcd(gg,a[i]);
	}
	int minn=114514191981000;
	f[0]=0;
	for(int i=1;i<=cnt;i++){
		f[i]=min(f[i],f[i-1]+r[i]-l[i]+1+k+(gcd[i]!=d));
		f[i]=min(f[i],minn+r[i]+1+k);
		minn=min(minn,f[i-1]-l[i]);
	}
	//for(int i=1;i<=cnt;i++)cout<<l[i]<<" "<<r[i]<<" "<<gcd[i]<<endl;
	cout<<f[cnt];
}

```


---

## 作者：SoundOfDestiny (赞：0)

## 分析

令 $G = \gcd\limits_{i = 1}^{n}{a_i}$，那么操作结束后容易证明所有 $a_i$ 都等于 $G$。那么我们只需要考虑让不是 $G$ 的 $a_i$ 变为 $G$。

那么对原数列根据 $a_i$ 是否等于 $G$ 分成 $m$ 段，令每一段左右端点分别为  $l_p, r_p$，则 $\forall p, \sum\limits_{i = l_p}^{r_p}{[a_i = G]} = 0, a_{l_p - 1} = G, a_{r_p + 1} = G$，即每一段中的 $a_i$ 都不等于 $G$。

考虑如何根据 $l_p, r_p$ 求出最小代价，令 $w_i$ 表示将 $a_1 \sim a_i$ 全部变为 $G$ 的最小代价。可以发现，$\forall t \in [l_p, r_p), w_t \leq w_t + (r_p - l_p + 1 + k) \leq w_{r_p}$，即对于每一对 $l_p, r_p$，只有 $w_{r_p}$ 是需要考虑的，记 $f_p = w_{r_p}$。

考虑 $f$ 怎么转移。对于一个 $f_p$，它有两种转移方式，一种是将 $a_{l_p} \sim a_{r_p}$ 全部变为 $G$ 的代价（因为这一段区间的 $\gcd$ 可能不等于 $G$，故不能和后面的状态合并）加上 $f_{p - 1}$，一种是选择一个 $q < p$，将 $a_{l_q} \sim a_{r_p}$ 全部变为 $G$ 的代价加上 $f_{q - 1}$。可以容易得到 $f$ 的转移方程：

$$
f_p = \min\{r_p - l_p + 1 + k + [(\gcd\limits_{i = l_p}^{r_p}{a_i}) \neq G] + f_{p - 1}, \min\limits_{q < p}\{r_p - l_q + 1 + k + f_{q - 1}\}\}
$$

所以我们只要维护 $\min\limits_{q < p}\{f_{q - 1} - l_q\}$ 的最小值即可，不妨为 $g_p$，那么有：

$$
\begin{aligned}
g_p &= \min\{g_{p - 1}, f_{p - 2} - l_{p - 1}\} \\
f_p &= \min\{r_p - l_p + 1 + k + [(\gcd\limits_{i = l_p}^{r_p}{a_i}) \neq G] + f_{p - 1}, g_p + r_p + 1 + k\}
\end{aligned}
$$

那么 $f_m$ 即为答案。

时间复杂度 $O(n \log{V})$，瓶颈在于求 $\gcd$。

## 代码

需要注意的是 $g_1 = -l_1$。

代码采用了滚动数组来降低了使用的空间，所以看起来较为难懂，可以结合上文理解，代码中也标注了变量在上文中所对应的名称。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 4e6 + 10;

int n, k, G;
int a[N];
int f, lstf;

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        cin >> a[i], G = __gcd(G, a[i]);
    int l = 1, r = 0, g = 0, mn = -1;
    bool flg = 0, mnflg = 0;
    // f: f_p, lstf: f_{p-1}
    // l: l_p, r: r_p, g: gcd(a_{l_p} ~ a_{r_p}), mn: g_p
    a[n + 1] = G;
    for (int i = 1; i <= n + 1; i++)
        if (a[i] == G)
        {
            if (flg)
                f = r + 1 + k + min(lstf - l + (g != G), mn), mn = min(mn, lstf - l), lstf = f;
            l = i + 1, g = 0, flg = 0;
            if (!mnflg)
                mn = -l;
        }
        else
            r = i, flg = 1, g = __gcd(g, a[i]), mnflg = 1;
    cout << f << endl;
}
```

## 后记

很好的 dp 练习题。

有人说这题有点小卡常（？），但是我最慢的点也才 350ms 左右（~~还是我的问题？~~）。

---


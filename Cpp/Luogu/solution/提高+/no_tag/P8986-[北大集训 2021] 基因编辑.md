# [北大集训 2021] 基因编辑

## 题目背景

CTT2021 D1T3

## 题目描述

人类目前已经研究出了多种基因编辑技术，其中最传统的一种技术需要用到“限制性核酸内切酶”（简称限制酶）。这种酶能够识别特定的核苷酸序列，并在指定的位点上切割连接相邻核苷酸的磷酸二酯键，产生被称为“末端”的序列切口。只有相匹配的末端才能用 DNA 连接酶进行连接。

假设现在要用基因片段 $A$ 去替换某一载体 $V$ 上的基因片段 $B$。在使用限制酶的编辑技术中，通常需要进行以下操作：

1. 在基因 $A$ 的两端各选择一种限制酶识别位点。这两处识别位点在基因 $B$ 的两端也应当相应存在。
2. 用所选择的识别位点对应的限制酶对基因 $A$ 进行处理，使得其两端产生相应的末端。将处理后的基因 $A$ 提纯。
3. 用同样的限制酶切断载体 $V$ 上的识别位点，使得基因 $B$ 与载体 $V$ 断开。纯化出去除了基因 $B$ 的载体 $V'$。
4. 将载体 $V'$ 与基因 $A$ 混合，并在 DNA 连接酶的帮助下将断开的磷酸二酯键重新接上。

值得一提的是，如果两处识别位点断开后产生了相同的末端，那么在第 4 步中载体 $V'$ 有可能单独连接起来，产生了不包含基因 $A$ 或 $B$ 的载体；也有可能基因 $A$ 反向接入 $V'$，同样产生错误的载体。因此，在实际运用中，通常选取产生不同末端的限制酶对基因 $A$ 和载体 $V$ 进行处理。

公元 3032 年，人类发现了一种掌握了基因编辑技术的外星文明 HD1048576d。当然，这种基因编辑的技术仅限于居住在 HD1048576d 这颗行星上的外星生物的基因。我们人类掌握的基因编辑技术可识别的最小单位是 DNA 序列上的单个碱基，而外星文明的基因编辑技术可识别的最小单位是其基因序列上的单个 noicleobase。出于方便起见，我们可以将单个 noicleobase 用从 $1$ 开始的正整数表示，那么一段外星生命的基因序列就可以被表示成相应的正整数序列。

对于一段长度为 $n$ 的外星生命的基因序列（不妨记其正整数表示为 $s_1, s_2, \cdots, s_n$），外星文明 HD1048576d 的基因编辑过程如下：

1. 选择一段要编辑的区域 $[l, r]$，即原位替换原序列中 $s_l, s_{l+1}, \cdots, s_r$ 这部分子序列；
2. 挑选一对跨过待替换区域的下标 $(i, j)$（即 $1\le i<l$ 且 $r<j\le n$），批量生产出 $s_i, \cdots, s_j$ 这段子序列在编辑后对应的新序列 $s_i, \cdots, s_{l-1}, t_1, \cdots, t_k, s_{r+1}, \cdots, s_j$；
3. 通过对应的特异性识别工具，将 $s_i, \cdots, s_j$ 这段子序列从原序列中断开，并将 $s_i, \cdots, s_{l-1}, t_1, \cdots, t_k, s_{r+1}, \cdots, s_j$ 接到序列中，即可得到目标基因序列。

需要注意的是，在步骤 2 中，挑选的这对下标必须对应唯一的 noicleobase 组合。也就是说，能够满足 $s_{i'}=s_i, s_{j'} = s_j$ 且 $i<j$ 的有序对 $\left(i', j'\right)$ 必须是唯一的（即为 $(i, j)$），否则特异性识别工具可能切割下其它区段的基因序列；另外，$s_i\ne s_j$，否则特异性识别工具可能只切割下单个 noicleobase。

另外，由于替换时需要生产新的基因序列，而生产这样的序列需要不小的开销，所以外星文明希望能够最小化需要生产的基因序列长度。显然，最小化这一长度等价于最小化被切割下来的基因子序列的长度，所以实践中一般是通过最小化被切割下来的基因子序列长度来计算最优解的。

现在，他们想考考人类文明的智力水平，于是你被他们从众多高中生中挑选出来解决这一问题。

## 说明/提示

最优方案为切割 `1 4 7 4 8 3`。可以证明，没有比这更优秀的满足技术限制的切割方案。

一种比该方案切割长度更短的方案是 `4 7 4 8 3`，但是在这种方案中特异性识别工具可能会断开 `4 8 3`，从而导致产生的目标基因序列出现意外的突变，因此这种切割方案不满足技术限制。

---

对于 $100\%$ 的数据，保证 $3\le n \le 10^6$，$\forall 1\le i\le n, 1\le s_i\le 10^6$，且 $1<l\le r<n$。

本题共有 5 个子任务，你需要通过一个子任务中的所有测试点才能获得该子任务的相应分数。下表为各子任务的数据规模及性质。

| 子任务编号 | 对应分数 | $n\le$ | $s_i\le$ | 特殊性质 |
| :--------: | :------: | :----: | :------: | :------: |
|    $1$     |   $5$    | $1000$ |  $1000$  | $\times$ |
|    $2$     |   $10$   | $1000$ |  $10^6$  | $\times$ |
|    $3$     |   $25$   | $10^6$ |  $1000$  | $\times$ |
|    $4$     |   $30$   | $10^6$ |  $10^6$  | $\surd$  |
|    $5$     |   $30 $   | $10^6$ |  $10^6$  | $\times$ |



上表中的“特殊性质”为：$s_1, \cdots, s_{l - 1}$ 各不相同，且 $s_{r + 1}, \cdots, s_n$ 各不相同。

## 样例 #1

### 输入

```
10 4 6
2 1 4 7 4 8 3 6 4 8
```

### 输出

```
6
```

# 题解

## 作者：O_Yeee (赞：6)

题目非常冗长，但我们只需要关注这一段即可。

>  需要注意的是，在步骤 2 中，挑选的这对下标必须对应唯一的 ```noicleobase``` 组合。也就是说，能够满足 $s_{i'}=s_i, s_{j'} = s_j$ 且 $i<j$ 的有序对 $\left(i', j'\right)$ 必须是唯一的（即为 $(i,j)$），否则特异性识别工具可能切割下其它区段的基因序列；另外，$s_i\ne s_j$，否则特异性识别工具可能只切割下单个 ```noicleobase```。

### 这句话告诉我们：对于题目所要找到的区间的左端点和右端点必须满足以下条件：
记： 

$fir_{i}$ 为当前 $a_{i}$ 出现第一次的位置。

$las_{i}$ 为当前 $a_{i}$ 出现最后一次的位置。

而对于第一个（最后一个）来说，他们的 $fir_{i}$（$las_{i}$）是第一个与其相同的位置。

对于一个满足要求的区间$[l,r]$来说，一定要满足的条件是：

$$
(fir_{l}>r) \land (las_{r}<l)
$$

为什么呢，因为我们的定义说明在 $fir_{i}$ 之前是没有这个数字的，而在这里是第一个，遂满足题目的条件（$las_{i}$ 同理）。

因此我们定义 $head,tail$ 代表这个区间的头和尾，最开始分别是 $l-1,r+1$，每次判断 $fir_{head}>tail$ 和 $las_{head}<tail$。当满足条件时就是最短的区间，不满足则扩大，若到 $(head \leq 0) \land (tail>n)$ 仍未找到，就代表无解，输出 $-1$。

下面是代码。（可能求 $fir$ 和 $las$ 实现较复杂，仅供参考）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,L,R;
int a[N],fir[N],before[N],las[N],after[N],bf[N],id[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> L >> R;
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	for(int i=1;i<=n;i++){
		if(before[a[i]]){
			fir[i]=before[a[i]];
		}
		else{
			before[a[i]]=i;
			fir[i]=i;
		}
	}
	for(int i=1;i<=n;i++){
		if(fir[i]==i){
			bf[a[i]]=1;
			id[a[i]]=i;
			continue;	
		}
		if(bf[a[i]]==1){
			fir[id[a[i]]]=i;
			bf[a[i]]=0;
		}
	}
	memset(bf,0,sizeof(bf));
	memset(id,0,sizeof(id));
	for(int i=n;i>=1;i--){
		if(after[a[i]]){
			las[i]=after[a[i]];
		}
		else{
			after[a[i]]=i;
			las[i]=i;
		}
	}
	for(int i=n;i>=1;i--){
		if(las[i]==i){
			bf[a[i]]=1;
			id[a[i]]=i;
			continue;	
		}
		if(bf[a[i]]==1){
			las[id[a[i]]]=i;
			bf[a[i]]=0;
		}
	}
	for(int i=1;i<=n;i++){
		if(fir[i]==i)fir[i]=n+1;
		if(las[i]==i)las[i]=-1;
	}
	int head=L-1,tail=R+1;
	while(head>0&&tail<=n){
		if((fir[head]>tail&&las[tail]<head)&&a[head]!=a[tail]){
			cout << tail-head+1;
			return 0;
		}
		if(fir[head]<tail)head--;
		if(las[tail]>head)tail++;
		if(a[head]==a[tail])head--,tail++;
		
	}
	cout << -1;
   return 0;
}

```
（本人第一次写题解，不喜勿喷，有问题欢迎在评论区讨论或私信作者。）
（8.14修改第二次）
（8.18修改第三次）

---

## 作者：qzmoot (赞：4)

# 题解：P8986 [北大集训 2021] 基因编辑
## 前言
感觉思路简单，没有蓝的难度。
## 题目分析
给定你一个序列和一个区间 $[l,r]$，让你找出一个二元组 $(i,j)$ 满足：
1. $i<j$。
2. $i<l,r<j$。
3. $a_i\neq a_j$。
4. 没有第二个二元组 $(i',j')$ 满足 $a_i=a_{i'},a_j=a_{j'}，i'<j'$。
5. 满足以上条件并且 $j-i+1$ 最小。

那么，分析完题目要求后，我们很容易就能获得思路，在 $r$ 之后，一个数出现多次，说明它不能作为右端点。\
考虑确定一个点作为右端点，怎么求合法且最靠右的左端点。\
显然，在 $[1,r]$ 中出现多次的数是不合法的。\
并且右端点的值出现在 $[1,r]$ 的位置得比我们寻找的左端点靠前或者未出现。
## 实现
先预处理出 $[1,r]$ 中所有值的出现次数和 $[r+1,n]$ 中所有值的出现次数。\
将 $[1,r]$ 中出现一次的点存下来，然后按顺序枚举右端点，开一个记录右端点前方所有值出现次数的桶，实时判断即可，找到第一个合法的点之后，后方的端点只可能更劣，此时我们可以直接输出长度。\
为了保证我们寻找的合法左端点最靠右，可以使用优先队列。\
若枚举完整个序列都无法找到合法的二元组，直接输出$-1$。
## 细节
记得每次右端点转移后，更新该值出现过最靠右的位置。
## Code
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
using namespace std;
constexpr int N=1e6+5;
int n,l,r;
int a[N];
int t[N],suf[N],pos[N];
bool fl;
int lim;
priority_queue<pii>q;
int main()
{
//	freopen("gene.in","r",stdin);
//	freopen("gene.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		lim=max(lim,a[i]);
		if(i<=r)
			t[a[i]]++,pos[a[i]]=i;
		else
			suf[a[i]]++;
	}
	for(int i=1;i<=lim;i++)
		if(t[i]==1 && !(l<=pos[i] && pos[i]<=r))
			q.push(mp(pos[i],i));
	for(int i=r+1;i<=n;i++)
	{
		t[a[i]]++;
		if(suf[a[i]]==1)
		{
			//cout<<a[i]<<' ';
			while(!q.empty() && t[q.top().se]!=1)
				q.pop();
			while(!q.empty() && q.top().se==a[i])
				q.pop();
			if(t[a[i]]==1)
			{
				if(!q.empty())
				{
					//cout<<a[q.top().fi]<<' ';
					cout<<i-q.top().fi+1;
					//cerr<<i-q.top().fi+1;
					return 0;
				}
			}
			else
			{
				if(!q.empty() && q.top().fi>pos[a[i]])
				{
					cout<<i-q.top().fi+1;
					return 0;
				}
			}	
		}
		pos[a[i]]=i;
	}
	cout<<"-1";
	return 0;
}
```
## 效率
时间复杂度 $O(n\log n)$ 可以通过。但是显然修改成线性做法比较容易，以下是线性做法的代码。
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
constexpr int N=1e6+5;
namespace OIfast{
	
	char buf[1<<21],*p1,*p2,*Tp, buffer[1<<21];
	#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?0:*p1++)
	#define ri register
template<typename T>
	inline void rd(T& x)
	{
		x=0;
		ri short f=1;
		ri char c=gc();
		while(c<'0' || c>'9'){if(c=='-')f=-1;c=gc();}
		while(c>='0' && c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
		x*=f;
	}
template<typename T,typename ...Args>
	inline void rd(T& x,Args& ...args)
	{
		rd(x),rd(args...);
	}
template<typename T>
	inline void prt(ri T n)
	{
		ri short sta[20];
		ri short Tp=0;
		if(n<0)n=~n+1,putchar('-');
		do{
			sta[Tp++]=n%10;
			n/=10;
		}while(n);
		while(Tp)putchar(sta[--Tp]^48);
		return ;
	}
template<typename T>
	inline void wr(ri T n,ri char c)
	{	
		prt(n),putchar(c);
		return ;
	}
	#undef gc
	#undef ri
}using namespace OIfast;
int n,l,r;
int a[N];
int t[N],suf[N],pos[N];
bool fl;
int lim;
pii q[N];
int now,top;
int main()
{
//	freopen("gene.in","r",stdin);
//	freopen("gene.out","w",stdout);
	rd(n,l,r);
	for(int i=1;i<=n;i++)
	{
		rd(a[i]);
		lim=max(lim,a[i]);
		if(i<=r)
			t[a[i]]++,pos[a[i]]=i;
		else
			suf[a[i]]++;
	}
	for(int i=l-1;i;i--)
		if(t[a[i]]==1)
			q[top++]={i,a[i]};
	for(int i=r+1;i<=n;i++)
	{
		t[a[i]]++;
		if(suf[a[i]]==1)
		{
			//cout<<a[i]<<' ';
			while(now<top && t[q[now].se]!=1)
				now++;
			if(t[a[i]]==1)
			{
				if(now<top)
				{
					//cout<<a[q.top().fi]<<' ';
					prt(i-q[now].fi+1);
					//cerr<<i-q.top().fi+1;
					return 0;
				}
			}
			else
			{
				if(now<top && q[now].fi>pos[a[i]])
				{
					prt(i-q[now].fi+1);
					return 0;
				}
			}	
		}
		pos[a[i]]=i;
	}
	prt(-1);
	return 0;
}
```
目前在最优解第一个。

---

## 作者：苏联小渣 (赞：4)

读题题，建议评黄/绿。

首先简化一下题意：

给定长度为 $n$ 的序列 $a$，两个整数 $l,r$，你需要找到一对 $(x,y)$ 满足 $x <l,y>r$ 且不存在 $(x',y') \ne (x,y),a_{x'}=a_x,a_{y'}=a_y$ 且 $y-x+1$ 最小。输出最小的 $y-x+1$。

考虑找到一个更好的充要条件。不难发现 $(x,y)$ 合法当且仅当满足如下所有条件：

- $\forall i <x.a_i \ne a_x$。

- $\forall j>y,a_j \ne a_y$。

- 如果存在一个最小的 $x'>x$ 且 $a_{x'}=a_x$，那么 $x'>y$。

- 如果存在一个最大的 $y'<y$ 且 $a_{y'}=a_y$，那么 $y'<x$。

证明：可以通过反证法证明，任意一个不满足那这个数对都不合法。

考虑枚举 $x$。记录 $nxt_i$ 表示 $a_i$ 在 $i$ 后第一次出现的位置，没有则记为 $n+1$；$lst_i$ 记录 $a_i$ 在 $i$ 之前第一次出现的位置，没有则记为 $0$。前两个条件可以用这两个数组来判断。对于一个 $x$，我们把所有满足 $y>r,lst_y<x$ 的 $y$ 放进一个 set 里面，查询的时候二分 set 里面第一个 $>r$ 的值，判断它是否 $<nxt_x$ 即可。时间复杂度 $O(n \log n)$。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int n, l, r, mn=1e9, a[1000010], nxt[1000010], lst[1000010], p[1000010], b[1000010];
set <int> s;
set <int> :: iterator it;
int main(){
	scanf ("%d%d%d", &n, &l, &r);
	for (int i=1; i<=n; i++){
		scanf ("%d", &a[i]);
	}
	for (int i=1; i<=n; i++){
		lst[i] = p[a[i]];
		p[a[i]] = i;
	}
	for (int i=1; i<=n; i++) p[a[i]] = n+1;
	for (int i=n; i>=1; i--){
		nxt[i] = p[a[i]];
		p[a[i]] = i;
		if (i > r && nxt[i] == n+1 && lst[i] < l){
			if (lst[i] == 0) s.insert(i);
			else b[lst[i]] = i;
		}
	}
	for (int i=1; i<l; i++){
		if (lst[i] == 0 && nxt[i] > r){
			it = s.lower_bound(r);
			if (it != s.end() && *it <= nxt[i]) mn = min(mn, *it - i + 1);
		}
		if (b[i]) s.insert(b[i]);
	}
	printf ("%d\n", mn == 1e9 ? -1 : mn);
	return 0;
}
```

---

## 作者：Mr_Az (赞：2)

## Question 问题 [P8986 [北大集训 2021] 基因编辑](https://www.luogu.com.cn/problem/P8986)

给定一个长度为 $n$ 的序列 $a$ 以及需要切割的范围 $l,r$，求其中最短的合法子序列 $(x,y)$ 满足：

1. $x<l~~y>r$
2. 不存在 $(x',y')$ 满足 $a_{x'}=a_x~~a_{y'}=a_y$

## Analysis 分析

令：

$pre_i$ 为 $a_i$ 这个颜色在 $i$ 前第一次出现的下标。

$lst_i$ 为 $a_i$ 这个颜色最后一次出现的下标。


由反证法易得：我们选出来的 $x,y$ 只有可能是某种颜色的第一次出现的位置和最后出现的位置。同时还必须满足 $pre_y<x$ 且 $y$ 在区间 $(r,n]$ 只出现一次，$x$ 在区间 $[1,l)$ 只出现过一次。

## Solution 

从小到大枚举 $y$，开一个 `set` 维护维护在 $[1,l)$ 出现一次的 $x$。到区间 $(r,n]$ 选一个只出现过一次的 $y$ 后，再从 `set` 中找到一个最大的下标并更新答案。记得判断无解。

## Code 代码

```cpp
int n,l,r,ans=inf;
int a[N],pre[N],lst[N],now[N];//如题解意思，now 是为了方便清除 set
int v[N];// v[i]=a[i] 在区间 (r,n] 第一次出现，用来判断是不是唯一出现。
set<int> s;
int main(){
	read(n,l,r);
	for(rint i=1;i<=n;i++){
		read(a[i]);
		pre[i]=lst[a[i]];lst[a[i]]=i;
		if(i>r && !v[a[i]]) v[a[i]]=i;
	}
	for(rint i=1;i<=n;i++){
		if(i<l && !now[a[i]]) s.insert(i);
		else if(s.find(now[a[i]])!=s.end()) s.erase(now[a[i]]);
		if(!now[a[i]]) now[a[i]]=i;
		if(i>r && v[a[i]]==i && i==lst[a[i]] && s.size()){
			int t=*(--s.end());
			if(t>=pre[i]) ans=min(ans,i-t+1);
		}
	}
	if(ans==inf) ans=-1;
	printf("%d\n",ans);
    return 0;
}
```

## 后记

该方法常数较大，请开 `O2`。如有不开 `O2` 的方法，请私信我谢谢。

---

## 作者：SunsetGlow95 (赞：2)

# 题解 - CTT2021 D1T3 基因编辑

## 简述题意

给定 $n,l,r(1<l\le r<n)$ 和长度为 $n$ 的正整数数列 $a(1\le a_i\le 10^6)$。一个数对 $(i,j)$ 合法，当且仅当：

- $1\le i<l\le r< j\le n$。
- 不存在 $i',j'$ 使得 $a_i=a_{i'}$，$a_j=a_{j'}$ 且 $i\neq i'\lor j\neq j'$。
- $a_i\neq a_j$。

找出可能的最小 $j-i+1$。$1\le n\le 10^6$。

## 分析

对于上面的第二个条件，我们这么转化：（可证明正确性）

- 不存在 $i'<j$，$i'\neq i$，$a_i=a_{i'}$。
- 不存在 $j'>i$，$j'\neq j$，$a_j=a_{j'}$。

它意味着：

- $j$ 在 $a_i$ 的头两次出现之间。
- $i$ 在 $a_j$ 的末两次出现之间。
- $i$ 是 $a_i$ 的第一次出现。
- $j$ 是 $a_j$ 的最后一次出现。

感性地理解，也就是这样的一对 $(a_i,a_j)=(x,y)$，分布形如 $\{y,\ldots,y,x,y,x,\ldots,x\}$。其中唯一的一组 $(x,y)$ 就是 $(i,j)$ 位了。

那么，我们枚举 $i<l$，只看所有末两次出现在 $i$ 两侧的 $a_j(j>r)$，然后检测这个条件下最小的 $j$ 是否在 $a_i$ 的头两次出现之间。而这里的 $j$ 可以逐个预处理，然后枚举的时候做一个前缀 $\min$。

时间、空间复杂度均为 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MXN = 1000005;
int N, L, R, arr[MXN];
int fir[MXN], fir2[MXN], lst[MXN], lst2[MXN], mnr[MXN], cmr, ans;

int main() {
  cin >> N >> L >> R;
  for (int i(0); i != MXN; ++i) fir[i] = fir2[i] = N + 1;
  mnr[0] = N + 1;
  for (int i(1); i <= N; ++i) {
    cin >> arr[i];
    lst2[arr[i]] = lst[arr[i]];
    lst[arr[i]] = i;
    if (fir[arr[i]] == N + 1) fir[arr[i]] = i;
    else if (fir2[arr[i]] == N + 1) fir2[arr[i]] = i;
    mnr[i] = N + 1;
  }
  for (int i(R + 1); i <= N; ++i) {
    if (i == lst[arr[i]]) mnr[lst2[arr[i]]] = min(mnr[lst2[arr[i]]], i);
  }
  cmr = mnr[0];
  ans = N + 1;
  for (int i(1); i < L; ++i) {
    if (i == fir[arr[i]] && cmr < fir2[arr[i]]) ans = min(ans, cmr - i + 1);
    cmr = min(cmr, mnr[i]);
  }
  cout << (ans == N + 1 ? -1 : ans) << endl;
  return 0;
}
```

---

## 作者：cogimyun (赞：1)

我们考虑这道题目要求我们在数列 $s$ 中找到一个一个区间 $[i,j]$ 满足：
- $l\in[1,l-1],r\in [r+1,n]$
- $j-i+1$ 最小化
- 在数列 $s$ 中找不到一个与区间 $[i,j]$ 不同的区间 $[p,q]$ (即 $i\ne p,j\ne q$ )满足 $s_i=s_p,s_j=s_q$
- $s_i\ne s_j$

我们不难发现后面两个条件可以转化为区间 $[i,j]$ 满足：
- $\forall p\in [i,j-1]\cup [j+1,n] ,s_j\ne s_p$
- $\forall q\in [1,i-1]\cup [i+1,j] ,s_i\ne s_q$

我们不妨在遍历 $j$ 的同时用一个 set 来维护所有的 $s_i$ ，满足 $s_i$ 在 $s_1$ 到 $s_j$ 中仅出一次，再用桶维护从最接近 $l$ 并且满足上述条件的 $i$ 开始一直到 $n$，数列 $s$ 里每个数出现的次数，如果当前的 $s_j$ 出现次数为1，那么这就最佳答案，直接输出，如果遍历完所有 $j$ 但没有一个 $j$ 满足上述条件，则不存在一个合法方案，输出 -1。

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
int n,l,r,s[1000005],book[1000005],id[1000005],cnt[1000005];
set<pair<int,int> > q;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++)
		cin>>s[i];
	for(int i=1;i<l;i++){
		book[s[i]]++;
		if(book[s[i]]==1){
			id[s[i]]=i;
			q.insert({l-i,s[i]}); 
		}
		else if(book[s[i]]==2){
			auto it=q.find({l-id[s[i]],s[i]});
			q.erase(it);
		}
	}
	for(int i=l;i<=r;i++){
		book[s[i]]++;
		if(book[s[i]]==2&&id[s[i]]){
			auto it=q.find({l-id[s[i]],s[i]});
			q.erase(it);
		}
	}
	auto it=q.begin();
	pair<int,int> ttt=*it;
	for(int i=n;i>=l-ttt.fi;i--)
		cnt[s[i]]++;
	for(int i=r+1;i<=n;i++){
		book[s[i]]++;
		if(book[s[i]]==2&&id[s[i]]){
			auto it=q.find({l-id[s[i]],s[i]});
			pair<int,int> ttt=*it;
			q.erase(it);
			auto iti=q.begin();
			pair<int,int> kkk=*iti;
			for(int j=l-kkk.fi;j<l-ttt.fi;j++)
				cnt[s[j]]++; 
		}
		if(cnt[s[i]]==1){
			auto it=q.begin();
			if(it==q.end())
				continue;
			pair<int,int> ttt=*it;
			cout<<(i-l+ttt.fi+1);
			return 0;
		}
	}
	cout<<-1;
	return 0;
} 
```

---

## 作者：Arc0_FishyFool (赞：1)

我在在模拟赛里前 $30$ 分钟内场切了这一题~~然后被紫题T2薄纱了~~，你也来试试吧！\
很难想象它会是一道蓝题，时空复杂度均 $O(n)$ 的解法其实很好想。现在我将尽可能还原赛时思路进行讲解。

# 审题：

要求一段区间 $[i,j]$ 的最小长度，使其满足 $[l,r]\subsetneqq [i,j]$ 并且**有序数对** $(s_i,s_j)$ 唯一，其中 $s_i\neq s_j$，$1\le i<l\le r<j\le n$。

# 思考：

## 算法框架：

考虑到其求最小长度且区间 $[i,j]$ 一定包含区间 $[l,r]$，这启示我们利用**尺取法**进行贪心：使用两个指针 $i$ 和 $j$，初值分别为 $l-1$ 与 $r+1$，判断是否合法并依情况向左扩展一位左指针或向右扩展一位右指针。

## 细化流程：

那么我们应该如何简便判断情况是否合法并扩展指针呢？\
我们需要结合算法框架与题目的性质进行分析。\
在上述框架，我们每次扩展**总有一个指针不动**，并且**扩展后的区间总是严格大于并包含上一步的区间**。\
我们先探讨何时区间 $[i,j]$ 合法，即有序数对 $(s_i,s_j)$ 两元素不相等且数对唯一。\
对于 $i$，它需要满足 $\forall k\in[1,i-1]\cup[i+1,j],k\in Z,s_k\neq s_i$。\
同理，对于 $j$，其满足 $\forall k\in[i,j-1]\cup[j+1,n],k\in Z,s_k\neq s_j$。\
显然扩展一个指针有可能使该指针从非法变为合法，即**同向扩展具有充分性**。我们再讨论为什么一个指针不合法就必须更改该指针，即**同向扩展的必要性**。\
不妨令左指针 $i$ 非法，利用反证法，我们假定能通过 $j\leftarrow j+1$ 使 $i$ 合法。\
$i$ 非法，当且仅当 $\exists k\in[1,i-1]\cup[i+1,j],k\in Z,s_k=s_i$。\
显然 $k\in[1,i-1]\cup[i+1,j+1]$，因此 $k$ 仍存在，假设矛盾，向右扩展无法解决左指针的非法问题。同理，向左扩展无法解决右指针的非法问题。\
**因此，当一个指针非法，我们必须将它扩展，即使扩展会令另一指针不再合法，这步扩展仍是必要的！**

# 代码实现：

最后，我们讨论如何实现快速判断左指针与右指针是否合法。\
观察数据范围 $1\le s_i\le 10^6$，这启示我们可以建立一个**桶**，根据有序数对的定义，$(1,4)\neq(4,1)$，如果我们用桶存储数的出现次数，我们发现合法数对 $(s_i,s_j)$ **不一定**满足 $s_i$ 与 $s_j$ 唯一，可能需要进一步处理，因此我们可以换个思路。\
我们考虑用桶存储位置，命名为 $pos$，建立 $lpos$ 和 $rpos$ 数组。其中 $lpos_i$ 表示 $i$ 左侧最近的 $k$ 使 $s_i=s_k$，$rpos_i$ 表示 $i$ 右侧最近的 $k$ 使 $s_i=s_k$。我们进行一正一反两次遍历，每次利用桶找到 $lpos_i$ 或 $rpos_i$ 的值，然后用 $i$ 的值更新 $pos_{s_i}$。\
然后对于每次判断，左指针 $i$ 非法当且仅当 $lpos_i$ 存在或 $rpos_i\le j$。右指针 $j$ 同理。\
所以，我们就在 $O(n)$ 的时空复杂度内过了这道题。

# Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int lpos[1919810],rpos[1919810],a[1919810],n,l,r,pos[1919810];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>l>>r;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		lpos[i]=pos[a[i]];
		pos[a[i]]=i;
	}
	memset(pos,0,sizeof(pos));
	for(int i=n;i>0;--i){
		rpos[i]=pos[a[i]];
		pos[a[i]]=i;
	}
	--l;
	++r;
	while(l&&r<=n){
		if(rpos[l]&&rpos[l]<=r||lpos[l]){
			--l;
		}
		else if(lpos[r]&&lpos[r]>=l||rpos[r]){
			++r;
		}
		else break;
	}
	if(l==0||r>n){
		puts("-1");
		return 0;
	}
	cout<<r-l+1;
	return 0;
} 
```

---

## 作者：TH911 (赞：1)

> [题目传送门](https://www.luogu.com.cn/problem/P8986)
>
> [也许更好的阅读体验](https://www.cnblogs.com/TH911/p/-/P8986)
>
> 本题解主要用于翻译题面。

# 难度在于读题

题面说了一大堆 HD1048576d 外星人、外星生命的基因序列、基因编辑技术等内容，以至于读题非常不容易。考虑如何去有条理地、清晰地正确理解题目。

输入给出了正整数序列 $s_1,s_2,\cdots,s_n$，和一个数对 $(l,r)$。

先找与之相关的信息。

> 对于一段长度为 $n$ 的外星生命的基因序列（不妨记其正整数表示为 $s_1, s_2, \cdots, s_n$），外星文明 HD1048576d 的基因编辑过程如下：
>
> 1. 选择一段要编辑的区域 $[l, r]$，即原位替换原序列中 $s_l, s_{l+1}, \cdots, s_r$ 这部分子序列；
> 2. 挑选一对跨过待替换区域的下标 $(i, j)$（即 $1\le i<l$ 且 $r<j\le n$），批量生产出 $s_i, \cdots, s_j$ 这段子序列在编辑后对应的新序列 $s_i, \cdots, s_{l-1}, t_1, \cdots, t_k, s_{r+1}, \cdots, s_j$；
> 3. 通过对应的特异性识别工具，将 $s_i, \cdots, s_j$ 这段子序列从原序列中断开，并将 $s_i, \cdots, s_{l-1}, t_1, \cdots, t_k, s_{r+1}, \cdots, s_j$ 接到序列中，即可得到目标基因序列。
>
> 需要注意的是，在步骤 2 中，挑选的这对下标必须对应唯一的 noicleobase 组合。也就是说，能够满足 $s_{i'}=s_i, s_{j'} = s_j$ 且 $i<j$ 的有序对 $\left(i', j'\right)$ 必须是唯一的（即为 $(i, j)$），否则特异性识别工具可能切割下其它区段的基因序列；另外，$s_i\ne s_j$，否则特异性识别工具可能只切割下单个 noicleobase。

即找 $1\leq i<l,r<j\leq n$，满足 $s_i\neq s_j$，且不存在 $1\leq i'<i,s_{i'}=s_i$ 或 $j<j'\leq n,s_j=s_{j'}$。

再找输出相关的信息。

> 另外，由于替换时需要生产新的基因序列，而生产这样的序列需要不小的开销，所以外星文明希望能够最小化需要生产的基因序列长度。显然，最小化这一长度等价于最小化被切割下来的基因子序列的长度，所以实践中一般是通过最小化被切割下来的基因子序列长度来计算最优解的。

即找最小的子串长度，即最小的 $j-i+1$。

***

因此，可以明确题意：给定正整数序列 $s_1,s_2,\cdots,s_n$ 和数对 $(l,r)$，问是否存在 $L,R$，满足 $1\leq L<l,r<R\leq n$，满足 $s_L\neq s_R$，且不存在 $1\leq i<L,s_i=s_L$ 或 $R<j\leq n,s_R=s_j$。

* 若存在，输出最小的 $R-L+1$。
* 否则，输出 $-1$。

***

同时可以注意到，前面一段都是废话，实际上也如此。

~~模拟赛读题读了一小时，还挂分了。~~

# 维护过程

记 $\textit{pre}_i,\textit{suf}_i$ 分别表示 $s_i$ 在 $i$ 之前的出现位置和 $i$ 之后的出现位置。特别地，若不存在，则钦定 $\textit{pre}_i=0,\textit{suf}_i=+\infty$。

考虑枚举 $L$，并确定最小的合法的 $R$。合法的 $L$ 需要满足的条件有：

$$
1\leq L<l\\
\textit{pre}_L=0
$$

与之对应的合法的 $R$ 需要满足的条件有：

$$
r<R\leq n\\
\textit{suf}_R=+\infty\\
$$

注意到 $s_L\neq s_R$，因此还有：

$$
\textit{pre}_R<L
$$

考虑用数据结构去维护 $R$。前两个条件很好满足，第三个条件与动态枚举的 $L$ 有关，需要处理。

* 当 $\textit{pre}_i=0$ 时，$i$ 一定是一个可用的 $R$。
* 否则可以在 $L$ 枚举到 $\textit{pre}_i+1$ 时，确定 $i$ 在此之后是一个可用的 $R$。

记可用 $R$ 的集合为 $S$，对于一个 $L$，即找到一个 $x\in S$ 满足 $r<x$ 且 $x$ 最小。平衡树维护即可。

时间复杂度 $\mathcal O(n\log n)$。

# AC 代码

```cpp lines line-numbers
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
#include<set>
using namespace std;
constexpr const int N=1e6,inf=0x3f3f3f3f;
int n,a[N+1],pos[N+1],pre[N+1],suf[N+1];
int insert[N+1];
set<int>t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int l,r;
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		pre[i]=pos[a[i]];
		pos[a[i]]=i;
	}
	memset(pos,0x3f,sizeof(pos));
	for(int i=n;i>=0;i--){
		suf[i]=pos[a[i]];
		pos[a[i]]=i;
	}
	set<int>R;
	for(int i=r+1;i<=n;i++){
		if(pre[i]<l&&suf[i]==inf){
			if(!pre[i]){
				R.insert(i);
			}else{
				insert[pre[i]]=i;
			}
		}
	}
	int ans=2147483647;
	for(int L=1;L<l;L++){
		if(!pre[L]&&r<suf[L]){
			auto p=R.upper_bound(r);
			if(p!=R.end()){
				if(*p<=suf[L]){
					ans=min(ans,*p-L+1);
				}
			}
		}
		if(insert[L]){
			R.insert(insert[L]);
		}
	}
	if(ans==2147483647){
		cout<<"-1\n";
	}else{
		cout<<ans<<'\n';
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：BlackHoles (赞：1)

### 正解

我们考虑预处理一些信息：对于任意 $1 \le i \le n$，求出 $pre_i, nxt_i$ 分别表示上一个和下一个 $j$ 满足 $s_i = s_j$，不存在时设为 $0$ 或 $n + 1$。

于是，我们转化了题目要求：对于 $i, j$，它们满足条件当且仅当 $pre_i = 0, nxt_i > j, pre_j < i, nxt_j = n + 1$。

所以我们只保留原数组中的这些点：对于 $1 \le i < l$ 的点，我们只保留 $pre_i = 0$ 的点，并记录个数为 $numl$；对于 $r < j \le n$ 的店，我们只保留满足 $nxt_j = n + 1$ 的点，并记录总个数为 $m$，将这些点放在新的数组中，并用结构体封装，用 $idx$ 表示原数组位置。

再次预处理出对于任意 $1 \le i \le numl$ 的 $maxn_i$ 表示 $j \in [i, numl]$ 中 $nxt$ 的最大值。

接下来只需考虑去寻找满足 $nxt_i > j, pre_j < i$ 的点对 $i, j$ 并求出答案最小值。

在 $(numl, m]$ 中枚举 $j$，二分出最左端的点 $i$ 满足 $i > pre_j$，记为 $boundl$。紧接着在 $[boundl, numl]$ 二分出最右边的 $i$ 满足 $maxn_i > j$，此时的 $i$ 便是右端点为 $j$ 时的最佳左端点，这题便做完了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000005;
int n, lft, rght, s[N];
int pos[N], pre[N], nxt[N];
int m, numl, maxn[N];
struct Node {
	int idx, val;
	Node () {}
	Node (int idx, int val) : idx(idx), val(val) {}
} a[N];
int ans = INT_MAX;
int read(void) {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) {
		x = (x << 3) + (x << 1) + ch - 48;
		ch = getchar();
	}
	return x;
}
int main(void) {
	// freopen("gene.in", "r", stdin);
	// freopen("gene.out", "w", stdout); 
	n = read(), lft = read(), rght = read();
	for (int i = 1; i <= n; ++i) s[i] = read();
	for (int i = 1; i <= n; ++i) pre[i] = pos[s[i]], pos[s[i]] = i;
	for (int i = 0; i < N; ++i) pos[i] = n + 1;
	for (int i = n; i >= 1; --i) nxt[i] = pos[s[i]], pos[s[i]] = i;
	for (int i = 1; i < lft; ++i) if (!pre[i]) a[++m] = Node(i, s[i]), ++numl;
	for (int i = rght + 1; i <= n; ++i) if (nxt[i] > n) a[++m] = Node(i, s[i]);
	for (int i = numl; i >= 1; --i) maxn[i] = max(maxn[i+1], nxt[a[i].idx]);
	for (int r = numl + 1; r <= m; ++r) {
		int realr = a[r].idx;
		int L = 1, R = numl, boundl = -1;
		while (L <= R) {
			int mid = (L + R) >> 1;
			if (a[mid].idx > pre[realr]) {
				boundl = mid;
				R = mid - 1;
			}
			else L = mid + 1;
		}
		if (boundl == -1) continue;
		L = boundl, R = numl;
		int res = -1;
		while (L <= R) {
			int mid = (L + R) >> 1;
			if (maxn[mid] > realr) {
				res = a[mid].idx;
				L = mid + 1;
			}
			else R = mid - 1;
		}
		if (res != -1) ans = min(ans, realr - res + 1);
	}
	if (ans == INT_MAX) printf("-1");
	else printf("%d", ans);
	return 0;
}
```

---

## 作者：HasNoName (赞：1)

### 题意
注意到这题最难的地方在于读题。

可以简化为：给定一个数列 $s$，要求出 $i<l$，$j>r$ 的 $j-i+1$ 最小值。$i$、$j$ 还要满足 $s_i$ 不等于 $s_j$，且不存在 $i'$，$j'$ 使得 $s_{i'}=s_i$ 且 $s_{j'}=s_j$，$i'<j'$，$(i,j)$ 和 $(i',j')$ 不完全相等。
### 思路
可以预处理每一个数后面的和它相同的第一个数和后面的第一个数。

然后 $n^2$ 就是好写的了。

因为如果一个 $1$ 到 $l-1$ 之间的数有前驱或一个 $r+1$ 到 $n$ 的数有后继，则一定不合法；当 $i$ 的后继小于 $j$ 或 $j$ 的前驱大于 $i$ 也一定不合法。

反之一定合法。

然后双指针即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int a[N],b[N],vis[N],to[N],ne[N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,l,r;
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++)cin>>a[i];
	l--;r++;
	for(int i=1;i<=n;i++)
	{
		ne[i]=b[a[i]];
		b[a[i]]=i;
	}
	for(int i=1;i<=1000000;i++)b[i]=n+1;//用桶处理出前驱后继
	for(int i=n;i>=1;i--)
	{
		to[i]=b[a[i]];
		b[a[i]]=i;
	}
	int ans=1e9,t=r;
	for(int i=l;i>=1;i--)
	{
		if(ne[i])continue;
		while(t<=n&&(to[t]<=n||ne[t]>i))t++;//双指针
		if(t<=n&&t<=to[i]&&a[i]!=a[t])ans=min(ans,t-i+1);
	}
	if(ans==1e9)cout<<"-1\n";
	else cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：pikiuk (赞：0)

考虑几个性质：

1. 选出的 $l$ 只会是某种颜色的左端点。
2. 选出的 $r$ 只会是某种颜色的右端点。

以上两条用反证法容易证明。

我们记 $nxt_i=\min\limits_{j>i,a_j=a_i}j$，$lst_i=\max\limits_{j<i,a_j=a_i}j$，那么选出的 $l,r$ 还应该满足：

1. $nxt_l>r$。
2. $lst_r<l$。

我们把所有可能的 $l$ 存下来，并按 $nxt_l$ 排序，对其做扫描线，不难发现满足 $nxt_l>r$ 的 $r$ 的个数是递增的，然后我们把这些可能的 $r$ 以 $lst_r$ 为下标插入树状数组，每次查询前缀 $\min$ 即可。

一个小细节：$lst_i$ 可能为 $0$，所以插入的时候记得 $+1$。

```
#include<bits/stdc++.h>
#define Maxn 1000007
using namespace std;
const int inf = 0x3f3f3f3f;
int a[Maxn], L, R, nxt[Maxn], lst[Maxn], n, p[Maxn], b[Maxn], qr[Maxn], ans = inf;
struct Fwt {
	int t[Maxn];
	void clear() {memset(t, 0x3f, sizeof t);}
	void modify(int x, int k) {for(; x <= n; x += x & -x) t[x] = min(t[x], k);}
	int query(int x) {int res = inf; for(; x; x -= x & -x) res = min(res, t[x]); return res;}
} t;
int main() {
	ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> L >> R; for(int i = 1; i <= n; i ++) cin >> a[i], b[i] = a[i];
	sort(b + 1, b + n + 1); int m = unique(b + 1, b + n + 1) - b - 1;
	for(int i = 1; i <= n; i ++) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
	t.clear(); for(int i = 1; i <= n; i ++) lst[i] = p[a[i]], p[a[i]] = i;
	for(int i = 1; i <= n; i ++) p[i] = n + 1; int cnt = 0;
	for(int i = n; i; i --) nxt[i] = p[a[i]], p[a[i]] = i;
	for(int i = 1; i < L; i ++) if(! lst[i]) b[++ cnt] = i;
	sort(b + 1, b + cnt + 1, [&](const int &x, const int &y) {return nxt[x] < nxt[y];});
	for(int i = R + 1; i <= n; i ++) if(nxt[i] == n + 1) qr[i] = 1;
	for(int i = 1, fr = 0; i <= cnt; i ++) {
		for(int j = fr + 1; j <= nxt[b[i]]; j ++) if(qr[j]) t.modify(lst[j] + 1, j); 
		fr = nxt[b[i]]; ans = min(ans, t.query(b[i]) - b[i] + 1);
	} if(ans > n) cout << "-1"; else cout << ans;
}
```



---

## 作者：lzqy_ (赞：0)

难点在读题。

考虑对于一个不合法的点对 $(i,j)$，根据题意，一定存在 $(i',j')$ 满足 $a_i=a_{i'},a_j=a_{j'}$。容易发现，如果钦定 $i'=i$ **或** $j'=j$，和原条件是等价的。

因此对于一个点对 $(i,j)$，约束就可以写成这个样子：

- 钦定 $i=i':$ 不存在 $k>i$ 满足 $a_k=a_j$。

- 钦定 $j=j':$ 不存在 $k<j$ 满足 $a_k=a_i$。

发现如果从大到小枚举 $i$，那么可能的 $j$ 的数量是只增不减的。又因为只关心最小的 $j$，所以直接开个双端队列就行了。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=1000010;
const int inf=1<<30;
il int read(){
	int x=0;
	char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
il void chkmin(int &x,int y){if(y<x)x=y;}
deque<int>q;
int L,R,n,ans,Mn;
int a[maxn],tap1[maxn],tap2[maxn];
int nxt[maxn],lst[maxn];
bool vis[maxn];
int main(){
//	freopen("a.txt","r",stdin);
	n=read(),L=read(),R=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++)
		lst[i]=tap1[a[i]],tap1[a[i]]=i;
	for(int i=n;i;i--)
		nxt[i]=tap2[a[i]],tap2[a[i]]=i;
	for(int i=R+1;i<=n;i++)
		if(!nxt[i]&&(!lst[i]||lst[i]<L)) q.push_back(i);
	int Mn=inf;
	for(int i=L-1;i;i--){
		vis[nxt[i]]=1;
		while(!q.empty()&&vis[q.front()]) q.pop_front();
		if(!q.empty()&&(!nxt[i]||q.front()<nxt[i])&&!lst[i])
			chkmin(Mn,q.front()-i+1);
	}printf("%d\n",Mn==inf?-1:Mn);
	return 0;
}
```

---


# [COCI 2022/2023 #1] Iksevi

## 题目背景

写了十年的代码后，Vinko 决定转行做一名陶艺家。他在新工作的第一天就接到了一项艰巨的任务。

## 题目描述

Vinko 需要使用正方形瓷砖铺满音乐厅的地板。他不会让瓷砖的边与墙壁平行；相反，他选择让瓷砖的对角线与墙壁平行。

Vinko 还没有决定他将使用的瓷砖大小，但他知道所有瓷砖必须大小相同，而且对角线的长度必须是一个正偶数。

Vinko 铺下的第一块瓷砖的角将与左侧和后方的墙接触。此后他铺下的每一块瓷砖都与至少一块已铺好的瓷砖有一条边重合。他将重复这以一过程，直到铺满整个 $10^7 \times 10^7$ 平方毫米的地面。

除了程序员和陶艺家，Vinko 也是一个优秀的音乐家。正因为如此，他知道地板上有 $n$ 个点对大厅的音响效果至关重要。如果瓷砖的角落位于 $n$ 个点中的一个，大厅的声学效果将显著改善。

![](https://cdn.luogu.com.cn/upload/image_hosting/o4bbstj2.png)

如图，左图为瓷砖对角线长度为 $4$ 的铺装，在此条件下，点 $(2,4)$ 在瓷砖的角落上，此时它满足条件，使得音响效果大为改善，但点 $(4,3)$ 和 $(5,1)$ 不满足条件。右图则为瓷砖对角线长度为 $2$ 的铺装，此时点 $(4,3)$ 在四块瓷砖的角落，而点 $(2,4)$ 和 $(5,1)$ 不在。

帮助 Vinko 确定对于 $n$ 个点中的每个点，有多少种瓷砖尺寸可以使铺满地面后第 $i$ 个点位于瓷砖的角落上。

## 说明/提示

| 子任务 | 分值 | 数据范围 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $15$ | $1\leq n \leq 10^4,0\leq x_i,y_i \leq 100$ |
| $2$ | $55$ | $1\leq n \leq 10^4,0\leq x_i,y_i \leq 10^7$ |
| $3$ | $40$ | $1\leq n \leq 10^6,0\leq x_i,y_i \leq 10^7$ |

本题满分 $110$ 分。

## 样例 #1

### 输入

```
3
1 4
0 0
0 9```

### 输出

```
1
0
3```

## 样例 #2

### 输入

```
3
5 1
4 3
2 4```

### 输出

```
0
1
1```

# 题解

## 作者：sunzz3183 (赞：11)

# [COCI2022-2023#1] Iksevi 题解

## 题意

见[题面](https://www.luogu.com.cn/problem/P9031)，~~作者已经不会简化了，再简就是做法了~~。

## 分析

我们约定，把落在对角线长度为 $len$ 的瓷砖角落的 $(x,y)$ **叫做$(x,y)$ 被 $len$ 覆盖**。

我们设能覆盖点 $(x,y)$ 的 $len$ 为 $n$。

一个点 $(x,y)$ 被覆盖一定会满足以下两条性质：

1. $\frac{n}{2}|x,\frac{n}{2}|y$；

2. $x+y=pn+\frac{n}{2}$ 其中 $p \in N$。

证明略，由图易得。

令 $l=\frac{n}{2}$。

上面的性质将转化成：

1. $l|x,l|y$。 

2. $x+y=2pl+l$ 其中 $p \in N$。

由上面两条可得出 $x,y$ 中，一定有一个被 $l$ 整除为偶数，一个为奇数。

所以我们令 $x=2^tx_1,y=2^ty_1,(t\in N)$ 且 $2$ 不整除 $\gcd(x_1,y_1)$，则点 $(x,y)$ 和 $(x_1,y_1)$ 的满足性质的 $l$ **数量**（即答案）相同，且满足性质的 $l$ 一定是 $2^t$ 的倍数。

证明：

1. 若存在 $l$ ，使得 $l$ 对于点 $(x,y)$ 满足两条性质，则 $\frac{l}{2^t}$ 一定对于点 $(x_1,y_1)$ 满足两条性质。

2. 若 $l$ 不为 $2^t$ 的倍数，即 $l=2^{t_1}k,(t_1<t)$。那么 $\frac{x}{l}=2^{t-t_1}x_1,\frac{y}{l}=2^{t-t_1}y_1 $，不满足一定有一个被 $l$ 整除为偶数，一个为奇数，所以 $l$ 一定是 $2^t$ 的倍数。

由此，我们便可对 $x,y$ 预处理：

```cpp
if(!x&&!y){puts("0");continue;}\\0会无限除下去，所以一定要判断
while((!(x&1))&&(!(y&1)))x>>=1,y>>=1;
```

然后 $x_1,y_1$ 一定要么一个是奇数一个是偶数，要么全是奇数。显然都是奇数无论怎们被 $l$ 整除，一定都是奇数，所以答案是 $0$。

考虑一个奇数，一个偶数的情况：

令 $x_1$ 为偶数， $y_1$ 为奇数。

所以只能 $x_1$ 被整除为偶数，$y_1$ 被整除为奇数，则可以表示为：

$2l|x_1$ 且 $l|y_1$

即 $l|\frac{x_1}{2}$ 且 $l|y_1$

即 $l|\gcd(\frac{x_1}{2},y_1)$

所以答案为处理后 $\gcd(\frac{x_1}{2},y_1)$ 的因数个数。

筛因数个数可以用线性筛，可以参照这篇[博客](https://blog.csdn.net/bnubeginner/article/details/86634856)。

~~题外话：由于作者太菜了，没推出来线性筛约数，所以用了线性筛素数和质因数分解来求，卡过去了。这是[提交记录](https://www.luogu.com.cn/record/123556604)。~~

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char ch=getchar();int x=0;bool f=1;
    while(ch<'0'||'9'<ch){if(ch=='-')f=0;ch=getchar();}
    while('0'<=ch&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return f?x:-x;
}
int n,x,y;
int cnt,prime[700001];
int f[10000001],g[10000001];
bool is_p[10000001];
void init(int n){
    f[1]=g[1]=1;
    for(int i=2;i<=n;i++){
        if(!is_p[i])prime[++cnt]=i,f[i]=2,g[i]=1;
        for(int j=1;j<=cnt&&1ll*i*prime[j]<=n;j++){
            is_p[i*prime[j]]=1;
            if(!(i%prime[j])){
                g[i*prime[j]]=g[i]+1;
                f[i*prime[j]]=f[i]/(g[i]+1)*(g[i]+2);
                break;
            }
            g[i*prime[j]]=1;
            f[i*prime[j]]=f[i]<<1;
        }
    }
}
signed main(){
    init(10000000);
    n=read();
    for(int i=1;i<=n;i++){
        x=read(),y=read();
        if(!x&&!y){puts("0");continue;}
        while((!(x&1))&&(!(y&1)))x>>=1,y>>=1;
        if((x&1)&&(y&1)){puts("0");continue;}
        if(x&1)swap(x,y);
        int g=__gcd(x>>1,y);
        printf("%d\n",f[g]);
    }
    return 0;
}
```


---

## 作者：FFTotoro (赞：7)

数学课想出来的奇怪做法。

以下为方便讨论，令 $m=\dfrac{n}{2}$。

由已知得，对于一个 $m$，其地砖边上的点必然满足以下条件：

- $m|x$ 且 $m|y$；

- $x+y\equiv m\pmod {2m}$；

等价于：

- $m|\gcd(x,y)$；

- $x+y\not\equiv 0\pmod {2m}$；

所以令 $S=\{m|[m|\gcd(x,y)]\}$，$R=\{m|x+y\not\equiv 0\pmod {2m}\}$，$T=S\cap R$，答案即为 $|T|$。

$|T|$ 不好计算，正难则反，令 $U=\complement_ST=\begin{cases}\{m|[m|\gcd(x,y,\frac{x+y}{2})]\}&x+y\equiv 0\pmod 2\\\emptyset&\mathrm{otherwise}\end{cases}$，计算 $|U|$ 即可。答案为 $|S-U|$。

$[1,10^7]$ 以内所有数的因数个数可以对于每个数暴力枚举倍数预处理，令 $A=10^7$，时间复杂度 $O(A\log A)$。但因为常数小并且时限 $3\mathrm{s}$ 所以可以过。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000001];
int main(){
  ios::sync_with_stdio(false);
  for(int i=1;i<=1e7;i++)
    for(int j=1;i*j<=1e7;j++)a[i*j]++; // 预处理
  int t; cin>>t;
  while(t--){
    int x,y,c=0; cin>>x>>y;
    int g=gcd(x,y),m=gcd(x+y>>1,g);
    cout<<a[g]-(x+y&1?0:a[m])<<'\n'; // 计算答案
  }
  return 0;
}
```

---

## 作者：2huk (赞：4)

先考虑如何判断 $(x,y)$ 是否在直径为 $2r$ 的地毯的角上。

不难发现一个必要条件是 $r \mid x \land r \mid y$，即 $r \mid \gcd(x, y)$。

满足这个条件的 $(x, y)$ 在图上是这些：

![](https://cdn.luogu.com.cn/upload/image_hosting/vw8oya22.png)

然后猜出充分条件是 $2r \nmid x+y$。重申一遍：

- $r \mid \gcd(x, y)$
- $2r \nmid x+y$

考察第二个条件。可以改写成：

- $2 \nmid x+y$ 或 $r \nmid (x+y)/2$。

于是可以对 $x+y$ 的奇偶性分类讨论。

- $x+y$ 是奇数：那么第二个条件相当于无效了。于是答案为 $D(\gcd(x,y))$。（$D(x)$ 表示 $x$ 的约数个数。）
- $x+y$ 是偶数：问题变成了求 $\gcd(x, y)$ 的约数和 $(x+y)/2$ 的约数的补集的交集的大小（有多少 $r$ 满足 $r \mid \gcd(x, y) \land r \nmid (x+y)/2$）。根据 **容斥原理**，答案为 $D(\gcd(x, y)) -D(\gcd(\gcd(x,y),(x+y)/2))$。原因如下：

> ![](https://cdn.luogu.com.cn/upload/image_hosting/fpgqrle4.png)
> 
> $\gcd(x,y)$ 的约数是 $1,2$ 部分，非 $(x+y)/2$ 的约数是 $1,4$ 部分，它们的交是第 $1$ 部分，也就是 $\gcd(x,y)$ 的约数除去 $\gcd(\gcd(x,y),(x+y)/2)$ 的约数。

于是需要预处理 $1 \sim 10^7$ 的约数个数。

```cpp
// Problem: 
//     P9031 [COCI2022-2023#1] Iksevi
//   
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P9031
// Memory Limit: 512 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#define tests
#include <bits/stdc++.h>

using namespace std;

const int N = 1e7 + 10;

int D[N];

void solve() {
	int x, y;
	cin >> x >> y;
	if ((x + y) % 2) cout << D[__gcd(x, y)] << '\n';
	else cout << D[__gcd(x, y)] - D[__gcd(__gcd(x, y), x + y >> 1)] << '\n';
}

signed main() {
	for (int i = 1; i < N; ++ i )
		for (int j = i; j < N; j += i) D[j] ++ ;
	
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
#ifdef tests
	cin >> T;
#endif
	while (T -- ) solve();
	return 0;
}
```

---

## 作者：Tsawke (赞：4)

# [LG-P9031 [COCI2022-2023#1] Iksevi](https://www.luogu.com.cn/problem/P9031) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P9031-Solution)

### 题面

$ n $ 次询问每次给定 $ x, y $ 求有多少个不同的正整数 $ d $ 满足 $ x = 2k_1d, y = (2k_2 + 1)d $ 或 $ x = (2k_1 + 1)d, y = 2k_2d $，其中 $ k_1, k_2 \in \mathbb{N} $。

### Solution

首先第一步就是将冗长的题面转换为上述式子，这是平凡且自然的。

考虑变形，以前者为例，不难想到有 $ 2k_1 = \dfrac{x}{d} $ 与 $ 2k_2 + 1 = \dfrac{y}{d} $，从代数意义上考虑，容易想到 $ \dfrac{x}{d} $ 为偶数，$ \dfrac{y}{d} $ 为奇数。这里我们考虑一些数论的常见套路，想到一个数质因数分解后有至少一个 $ 2 $ 当且仅当其为偶数（因为偶质数有且仅有 $ 2 $），则如果对 $ x, y $ 均质因数分解，那么 $ d $ 应满足其 $ 2 $ 的幂次严格小于 $ x $ 的 $ 2 $ 的幂次且洽等于 $ y $ 的 $ 2 $ 的幂次，而对于其它的奇质因子不难发现其幂次是任意的。

想到线性筛质数，然后通过质数之间的枚举幂次线性筛值域内所有数，求出其质因数分解后 $ 2 $ 的幂次与奇质因子幂次 $ +1 $ 后的乘积（对应上述的任意取幂次的方案数）。

此时考虑对于询问的每一对 $ x, y $，若 $ x = 0 \land y = 0 $，答案为 $ 0 $，若其中任意一个为 $ 0 $，答案显然为非零数质因数分解后奇质因子任取的方案数。若两者均为奇数，或两者质因数分解后 $ 2 $ 的幂次相同，那么 $ d $ 显然无法满足上述的 “严格小于 $ x $ 的 $ 2 $ 的幂次且洽等于 $ y $ 的 $ 2 $ 的幂次”，答案为 $ 0 $。否则我们直接取 $ \gcd(x, y) $ 质因数分解后奇质因子任取的方案数，这里也是自然的，即将 $ 2 $ 幂次较小数中 $ 2 $ 的幂次全部钦定取出使其最终为奇数，另一个即为偶数。

若值域为 $ v $，则预处理复杂度 $ O(v) $，单次询问复杂度 $ O(1) $，最终复杂度 $ O(v + n) $，限制最大值域后直接最优解（主要没几个人交）。

Tips：注意线性筛的过程中若后面的质数均无法取需直接回溯，否则会因大量枚举无用质数导致复杂度退化。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

#define P(i) (Prime.at(i - 1))
#define LIMV_SIZE (int)(1e7)

template < typename T = int >
inline T read(void);

int N;
int tot;
int LIMV(0);
pair < int, int > pos[1100000];
bitset < LIMV_SIZE + 114514 > notPrime;
basic_string < int > Prime;
pair < int, int > fact[LIMV_SIZE + 114514];

int main(){
    N = read();
    for(int i = 1; i <= N; ++i)LIMV = max({LIMV, pos[i].first = read(), pos[i].second = read()});
    for(int i = 2; i <= LIMV; ++i){
        if(!notPrime[i])Prime += i;
        for(auto p : Prime){
            if((ll)i * p > LIMV)break;
            notPrime[i * p] = true;
            if(i % p == 0)break;
        }
    }tot = Prime.size();
    auto dfs = [](auto&& self, int dep = 1, int cnt2 = 0, int cnt_odd = 1, ll val = 1)->void{
        if(val > LIMV)return;
        if(dep > tot || val * P(dep) > LIMV)return fact[val] = {cnt2, cnt_odd}, void();
        int tims(1);
        while(val <= LIMV){
            self(self, dep + 1, cnt2, cnt_odd, val);
            val *= P(dep);
            if(P(dep) == 2)++cnt2;
            else cnt_odd /= tims, cnt_odd *= ++tims;
        }
    }; dfs(dfs);
    for(int i = 1; i <= N; ++i){
        int X = pos[i].first, Y = pos[i].second;
        if(!X && !Y){printf("0\n"); continue;}
        if(!X || !Y){printf("%d\n", fact[X ^ Y].second); continue;}
        int pow2X = fact[X].first, pow2Y = fact[Y].first;
        if((!pow2X && !pow2Y) || pow2X == pow2Y){printf("0\n"); continue;}
        printf("%d\n", fact[__gcd(X, Y)].second);
    }
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }ret *= flag;
    return ret;
}
```

## UPD

update-2023_03_28 初稿

---

## 作者：TKXZ133 (赞：3)

[Iksevi](https://www.luogu.com.cn/problem/P9031)

### 题目大意

$n$ 次询问，每次给定一个点 $(x,y),x\ge 0, y\ge 0$，问有多少种对角线长为偶数的正方形使得在用该正方形正密铺第一象限的情况下该点位于正方形顶点上。

**正密铺第一象限** 指将第一个正方形的角与 $x$ 轴和 $y$ 轴接触。此后的正方形都与至少一个已放置的正方形有一条边重合。重复这一过程。

### 思路分析

考虑到 $x,y$ 对称，因此不妨设 $y>x$。

设当前考虑的正方形对角线长为 $2l$，那么容易发现该正方形合法的充要条件是：

$$\begin{cases}y+x\equiv l\pmod {2l}\\y-x\equiv l\pmod {2l}\end{cases}$$

将两式相加，得：

$$y\equiv0\pmod {2l}$$

因此我们只需要枚举 $y$ 的所有约数，再逐一判断就可以做到 $O(n\sqrt V)$ 的时间复杂度，可以取得 $70pts$ 的好成绩。

但我们发现 $10^7$ 内约数个数最多的数只有 $448$ 个约数，因此 $O(\sqrt V)$ 的枚举是相当浪费的。

考虑将询问离线并离散化，改为枚举 $1\sim V$ 中每个数的倍数，对所有的询问点开 `vector` 并加入在其离散化后对应的 `vector` 中加入约数。

这样我们的时间复杂度就优化成了 $O(V\log V)$，空间复杂度为 $O(n\max \{d\})$，可以通过。

或许你会问，$O(n\max\{d\})=10^6\times 448=4.5\times 10^8$，空间开不下啊？

但实际上，因为相同的值对应同一个 `vector`，所以最劣情况是所有的询问点为在 $1\sim 10^7$ 中前 $10^6$ 个约数个数最多的数，算了一下发现是 $60690707$，也就是 $6\times 10^7$，是不会爆空间的。

### 代码

（最大时间 $2.71s$，最大空间 $171.27MB$）

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;
const int N = 1100000, M = 10000010, L = 10000000;

int n, A, D, in1, in2;
int b[N], id[M];

struct Node{
    int x, y;
}a[N];

vector <int> d[N];

bool check(int k){
	return A % (2 * k) == k && D % (2 * k) == k;
}

int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++) {
        scanf("%d %d", &in1, &in2);
        if (in1 < in2) swap(in1, in2);
        a[i] = Node{in1, in2};
        b[i] = in1; id[in1] = 1;
    }
    sort(b + 1, b + n + 1);
    int tot = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= L; i ++)
        if (id[i]) id[i] = lower_bound(b + 1, b + n + 1, i) - b;
    for (int i = 1; i <= L; i ++)
        for (int j = i; j <= L; j += i)
            if (id[j]) d[id[j]].push_back(i);
    for (int i = 1; i <= n; i ++) {
        int ans = 0;
        A = a[i].x + a[i].y ;
        D = abs(a[i].x - a[i].y);
		for (auto it : d[id[a[i].x]])
            if (check(it)) ans ++;
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

很好的数学题啊。

首先不难发现满足 $(x,y)$ 在对角线长度为 $n$ 的瓷砖角上需要满足：

$$x\equiv y\equiv 0\pmod{\frac{n}{2}}$$

$$x+y\equiv\frac{n}{2} \pmod{n}$$

首先发现必须有 $\frac{n}{2} \mid (x,y)$。

我们不妨设 $g = (x,y),m = \frac{n}{2}$。

于是有：

$$\frac{x}{m}+\frac{y}{m}=1\pmod{2}$$

则：

$$(\frac{x}{g}+\frac{y}{g})\times (\frac{g}{m})\equiv1\pmod 2$$

那么问题就转化为了求满足 $\frac{g}{m}\equiv 1\pmod 2$ 的 $m$ 数量。

不难发现就是求 $g$ 的奇约数的数量，然后用线性筛随便做一下就秒了。

#### 代码

```cpp
#include <bits/stdc++.h>
#define MAXN 10000000
#define MAXM 100000
#define LL long long
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;
int n, x, y, d[MAXN+5], num[MAXN+5];
bool vis[MAXN+5];
vector<int> vec;
void prime() {
	vis[1] = 1;
	for(int i = 2; i <= MAXN; ++i) {
		if(!vis[i]) vec.push_back(i), num[i] = i;
		for(int j : vec) {
			if(i * j > MAXN) break;
			vis[i * j] = 1, num[i * j] = j;
			if(i % j == 0) break;
		}
	}
}

signed main() {
	IOS;
	prime();
	cin >> n;
	for(int i = 1; i <= n; ++i) {
		cin >> x >> y;
		if((x + y) == 0) {
			cout << 0 << '\n';
			continue;
		}
		int g = __gcd(x, y);
		if((x / g + y / g) & 1) {
			LL ans = 1;
			while(g != 1) {
				int p = num[g], cnt = 0;
				while(g % p == 0) g /= p, ++cnt;
				if(p & 1) ans = ans * (cnt + 1);
			}
			cout << ans << '\n';
		}
		else cout << 0 << '\n'; 
	}
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

校内模拟赛 T1，只有 $65$ 分。

赛时质因数分解被卡常了，~~出题人没素质~~。

如果对角线长度为奇数，那么不难发现所有顶点都不是整数（加上的对角线长度是整数），所以不行。

所以，我们可以令对角线长度为 $2a,a\in \mathbb{N}$。

容易发现所有的点只有两种可能，$((2n+1)a,2ma)$ 或者 $(2na,(2m+1)a),n,m\in\mathbb{N}$。

我们求得就是 $a$ 的个数。

发现一种方案：

- 求出最大公约数，记为 $gcd$。

- 乘上最大公约数的一些因数，记因数乘积为 $x$，这里取的 $a=\dfrac{gcd}{s}$。

特判：

- 如果两个数都是 $0$，输出 $0$。

- 如果 $\dfrac{x}{gcd},\dfrac{y}{gcd}$ 都是奇数，输出 $0$。

而因为两个数的奇偶性不能相同，所以我们的 $x$ 必须为奇数。

所以答案就是求 $gcd$ 的所有奇数因数个数。

放一下 TLE 的代码：（代码中用 `gg` 表示文中的 $gcd$）。

这份代码在学校里 TLE 了，但是在洛谷上 AC 了，最慢 $2.64$ 秒。

记得特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5;
int n, x, y, gg, prim[N], sum, tot, tem;
bool vis[N];
inline int gcd(int x, int y){
	while(y){
		x = x % y;
		swap(x, y);
	}
	return x;
}
inline void init(){
	for(int i = 3; i <= 1e7; i++){
		if(!vis[i]) prim[++tot] = i;
		for(int j = 1; j <= tot && prim[j] * i <= 1e7; j++){
			vis[i * prim[j]] = 1;
			if(i % prim[j] == 0) break;
		}
	}
}
int main(){
//	freopen("iksevi.in", "r", stdin);
//	freopen("iksevi.out", "w", stdout); 
	init();
	scanf("%d", &n);
	while(n--){
		scanf("%d%d", &x, &y);
		gg = gcd(x, y);
		if(gg == 0){
			printf("0\n");
			continue ;
		} 
		x /= gg, y /= gg;
		if((x & 1) && (y & 1)){
			printf("0\n");
			continue ;
		}
		while((gg & 1) == 0) gg >>= 1;
		sum = 1;
		for(int i = 1; i <= tot && 1ll * prim[i] * prim[i] <= gg; i++){
			tem = 0;
			while(gg % prim[i] == 0){
				gg /= prim[i];
				tem++;
			}
			sum = sum * (tem + 1);
		}
		if(gg > 1) sum = sum * 2; 
		printf("%d\n", sum);
	}
	return 0;
}
```

感觉上面的计算过程还是比较好想的。

重点是下面的优化。

考虑优化求 $gcd$ 奇质因数个数的过程。

我们记 $f_i$ 表示 $i$ 的奇质因数的数，$g_i$ 表示 $i$ 最小的质因数。

考虑欧拉筛的本质，用最小的素数筛掉一个数。

所有上面的过程是可以用 $O(n)$ 跑出来的。

对于每个数 $x$，我们可以这样转移：

- 把 $x$ 中所有 $g_x$ 的因子去掉，记录个数，记录 $g_x$ 个数为 $b$。

- 从 $f_{\frac{x}{g_x^b}}$ 转移。

下面证明正确性：

令 $\frac{x}{g_x^b}=p_1^{a_1}\times p_2^{a_2}\times\dots\times p_n^{a_n}$。

那么 $x=\frac{x}{g_x^b}\times g_x^b=p_1^{a_1}\times p_2^{a_2}\times\dots\times p_n^{a_n}\times g_x^b$。

$\begin{aligned}
\therefore f_x&=(a_1+1)\times(a_2+1)\times\dots\times(a_n+1)\times(b+1)\\
&=f_{\frac{x}{g_x^b}}\times(b+1)
\end{aligned}$

综上所述，转移是可行的。

下面证明一下复杂度：

每个最小质数如果没有，就不用，否则，该质数最小为 $2$。

所以复杂度 $O(\log n\times n)$。

而 $\log n$ 的底数可能大于 $2$，而且 $n$ 很多时候远小于 $10^7$。

所以时间远远跑不满。

即使跑满了，也是 $10^7\times \log 10^7<2.4\times 10^8$，完全跑得过去。

实测最慢的点是 $430$ 毫秒（不吸氧）。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5;
int n, x, y, gg, prim[N], sum, tot, tem, f[N], g[N];
bool vis[N];
inline int gcd(int x, int y){
	while(y){
		x = x % y;
		swap(x, y);
	}
	return x;
}
inline void init(){
	f[1] = 1;
	for(int i = 3; i <= 1e7; i += 2){
		if(g[i] == 0){
			f[i] = 2;
			g[i] = i;
		}
		else{
			sum = 0;
			tem = i;
			while(tem % g[i] == 0) tem /= g[i], sum++;
			f[i] = f[tem] * (sum + 1);
		}
		if(!vis[i]) prim[++tot] = i;
		for(int j = 1; j <= tot && prim[j] * i <= 1e7; j++){
			vis[i * prim[j]] = 1;
			g[i * prim[j]] = prim[j];
			if(i % prim[j] == 0) break;
		}
	}
}
int main(){
//	freopen("iksevi.in", "r", stdin);
//	freopen("iksevi.out", "w", stdout); 
	init();
	scanf("%d", &n);
	while(n--){
		scanf("%d%d", &x, &y);
		gg = gcd(x, y);
		if(gg == 0){
			printf("0\n");
			continue ;
		} 
		x /= gg, y /= gg;
		if((x & 1) && (y & 1)){
			printf("0\n");
			continue ;
		}
		while((gg & 1) == 0) gg >>= 1;
		printf("%d\n", f[gg]);
	}
	return 0;
}
```

建议修改时限为 $1000$ 毫秒或 $1500$ 毫秒。

---

## 作者：Kingna (赞：0)

## [P9031 [COCI2022-2023#1] Iksevi](https://www.luogu.com.cn/problem/P9031)

### 思路

容易发现，给定点 $(x,y)$ 满足条件的 $m$ 有：

* $m|x,m|y$
* $x+y ≡ m\pmod {2m}$

等价于 $m|\gcd(x,y)$ 且 $(x+y)\bmod 2m ≠0$。则可以先满足第一个条件，再减去不满足第二个条件的数量即可。分类讨论：

* 若 $(x+y)\bmod 2≠0$，则没有 $m$ 会不满足第二个条件。
* 否则，如果 $m$ 为 $\frac{x+y}{2}$ 约数时，不满足第二个条件。

现在，只需要预处理出一个数组存储约数个数即可。

---

## 作者：SuperCowHorse (赞：0)

校内模拟赛，数组只开了 $10^7$ 导致 RE，$100\to15$，警钟长鸣。

为什么 $10^7$ 会开小？请看下文。

---
我们很容易发现，题目中这玩意是有对称性的。那么很显然，询问点 $(x,y)$，与询问 $(y,x)$ 是等价的。因此在这里，我们假设 $x<y$。

我们先作两条都过点 $(x,y)$ 的直线，一条斜率为 $1$，另一条为 $-1$。解方程，分别算出斜率为 $1$ 的直线与 $y$ 轴的截距，和斜率为 $-1$ 的直线与 $x$ 轴的截距。容易发现，这两个截距就是 $y-x$ 和 $x+y$。

令 $u=y-x,v=x+y$。如果瓷砖的对角线为 $2x$ 时符合要求，那么必有 $2x|u-x，2x|v-x$，即，$\dfrac ux$ 和 $\dfrac vx$ 均为奇数。

那么就好办了：由于 $u,v\le2\times 10^7$（知道我死哪了吧），先预处理出 $1$ 到 $2\times10^7$ 所有数有多少个 $2$ 的质因子，令 $x$ 的 $2$ 的因子个数为 $a_x$。然后，如果 $a_u\not=a_v$，那么直接输出 $0$。

>为什么这里可以输出 $0$，这里写一下证明。因为要找一个数，使 $\dfrac ux$ 和 $\dfrac vx$ 均为奇数，那么我们要让两个数都变成奇数，必定要将所有的 $2$ 全部去掉。但是如果 $a_u\not=a_v$，对于 $u$ 所需要的让 $u$ 变成奇数的 $x$，和对于 $v$ 所需要的让 $v$ 变成奇数的 $x$，一定使不一样的。（两个数连质因子 $2$ 的个数都不一样怎么相等）

然后，将 $u$ 和 $v$ 分别除以 $2^{a_u}$。设 $g=\gcd(u,v)$。这时候，我们只需要求 $g$ 的因数个数就可以了，因为此时 $u$ 和 $v$ 都是奇数，$g$ 一定是一个奇数。求 $1$ 到 $2\times10^7$ 的因子个数可以使用欧拉筛，$O(n)$ 解决。~~可惜我不会~~，所以我在 $i\equiv0\mod p_j$，即将跳出循环时，使用一个 `while` 求出了 $i$ 中含 $p_j$ 的个数。~~我太菜了。~~

对了，当 $u=v=0$ 时，特判输出 $0$。

Code（考场）:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int n=2e7;
const int maxn=2e7+5;
int x,y,u,v,a[maxn];
int p[maxn],cnt,s[maxn];bool g[maxn];
inline void init(){
	for(int i=1;i<=n;++i){//预处理 a[i]
		if(i&1) a[i]=1;
		else a[i]=a[i>>1]<<1;
	}
	memset(g,1,sizeof(g));g[01]=0;s[1]=1;
	for(int i=2;i<=n;++i){//欧拉筛
		if(g[i]) p[++cnt]=i,s[i]=2;
		for(int j=1;j<=cnt&&i*p[j]<=n;++j){
			g[i*p[j]]=0;
			if(i%p[j]==0){
				int x=i,c=1;
				while(x%p[j]==0) x/=p[j],++c;//只会暴力求呜呜呜
				s[i*p[j]]=(c+1)*s[x];
				break;
			}
			s[i*p[j]]=s[i]*s[p[j]];
		}
	}
}
signed main(){
//	freopen("tile.in","r",stdin);
//	freopen("tile.out","w",stdout);
	init();
	int T;for(scanf("%d",&T);T;--T){
		scanf("%d%d",&x,&y);
//		if(x>=n/2) x=n-x;
//		if(y>=n/2) y=n-y;
		u=max(x,y)-min(x,y);v=max(x,y)+min(x,y);
		if(u==0||a[u]!=a[v]){//特判 0
			printf("0\n");
			continue;
		}
		u/=a[u];v/=a[v];//让 u,v 变成奇数
		int g=__gcd(u,v);
		printf("%d\n",s[g]);//输出 g 因子个数
	}
	return 0;
}
/*
3
1 4
0 0
0 9

3
5 1
4 3
2 4
*/
```

---

祝所有人 CSP-J/S2024，NOIP2024 rp++，不要挂分。

---


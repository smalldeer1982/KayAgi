# [COCI 2022/2023 #1] Neboderi

## 题目背景

Domagoj 来到了伦敦这个大城市！现在有一排高摩天大楼在他面前，他想拍张照片来纪念这一时刻。

## 题目描述

这排摩天大楼共有 $n$ 座，它们可以被视作序列 $h_1,h_2,...h_n$，其中 $h_i$ 为第 $i$ 栋楼的高度。Domagoj 将会拍下这排大楼的一个子区间。为了更好地捕捉城市之美，他想拍摄至少 $k$ 座摩天大楼。

Domagoj 有着奇怪的审美：他认为照片中有高大的摩天大楼是美的；但如果照片中所有的摩天大楼的高度有着很大的公因数，他会认为更美。

如果一张照片拍下的大楼区间为 $[l,r]$，且这段区间内所有大楼高度的 $\gcd$ 为 $g$，则 Domagoj 定义这张照片的“美丽度”为 $g \times \sum_{i=l}^r h_i$。

帮助 Domagoj 算出他能拍到的最美照片的美丽度吧！

## 说明/提示

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $11$ | $n,k \leq 100$ |
| $2$ | $22$ | $n,k \leq 5000$ |
| $3$ | $27$ | $k \leq 100$ |
| $4$ | $18$ | $n,k \leq 5\times 10^4$ |
| $5$ | $32$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\leq k \leq n \leq 10^6,1\leq h_i \leq 10^6$。

本题满分 $110$ 分。

## 样例 #1

### 输入

```
6 2
2 1 4 4 4 2```

### 输出

```
48```

## 样例 #2

### 输入

```
4 1
7 3 9 4```

### 输出

```
81```

# 题解

## 作者：Po7ed (赞：15)

### 前言

校内模拟赛考了，于是写篇题解讲自己的做法。

[题目链接](https://www.luogu.com.cn/problem/P9032)。

### 题目大意

给出一个长度为 $n$ 的数组 $h$ 和一个限制 $k$，求

$$
\max_{1\le l\le l+k-1\le r\le n}\left\{\gcd_{i=l}^{r}\{a_i\}\times\sum_{i=l}^{r}a_i\right\}\tag{1}
$$

### 基本思路

赛时看到题目想到的是枚举 $\gcd$ 然后 dp。具体的，设 $dp(i,j)$ 表示最大化 $dp(i,j)$，使得 $h$ 中 $[i-dp(i,j)+1,i]$ 的公约数为 $j$。转移方程：

$$
dp(i,j)=
\begin{cases}
dp(i-1,j)+1 & \text{if } j\mid a_i\\
0 & \text{otherwise}
\end{cases}\tag{2}
$$

如果 $dp(i,j)\ge k$ 则更新答案：

$$
ans\gets\max\left(ans,j\times \sum_{\mathclap{l=i-dp(i,j)+1}}^{i}a_i\;\right)\tag{3}
$$

因为 $n,h_i\le 10^6$，直接 dp 肯定是不行的。

### 优化

首先要滚动数组，滚去 $i$ 这维。

其次 $(3)$ 中求和需要用前缀和优化。

还有枚举 $a_i$ 的约数 $j$ 也需要优化：对于每个数开一个 vector 存其约数，倒序枚举 $j$ 的倍数 $m$ 并将 $j$ 加入 $m$ 的 vector。这部分是调和级数 $O(V\ln V)$ 的，$V$ 表示值域。

接着注意到 $(2)$ 的 $\text{otherwise}$ 需要将 $dp(i,j)$ 置为 $0$。暴力清空肯定不行。

1. 可以使用时间戳优化：更新 $dp(j)$ 时将其时间戳（最近更新时间）$tag(j)\gets i$。转移时如果 $tag(j)=i-1$，则 $dp(j)\gets dp(j)+1$，反之 $dp(j)\gets 1$。这也是代码中的实现方式
2. 也可以直接判断是否满足 $j\mid a_{i-1}$，如果是，则 $i-1$ 时必然更新过 $dp(j)$，反之没有。

时间复杂度 $O(V\ln V+\sum d(a_i))$，$d(x)$ 表示 $x$ 的约数个数。

不懂可以看代码。

### 代码

还是很简洁的，压了行。

```cpp
#include <iostream>
#include <vector>

using std::cin;
typedef long long ll;
constexpr int N=1e6+114514;
int n,k,V;
int a[N];
ll s[N]; // 前缀和
int dp[N],tag[N]; // dp 数组和时间戳
std::vector<int> e[N];

int gcd(int x,int y){return !y?x:gcd(y,x%y);}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>k; // 求前缀和、值域大小
	for(int i=1;i<=n;i++)cin>>a[i],s[i]=s[i-1]+a[i],V=std::max(V,a[i]);
	// 枚举倍数求约数。e[x] 表示 x 的约数
	for(int i=1;i<=V;i++)for(int j=1;i*j<=V;j++)e[i*j].push_back(i);
	ll ans=0;
	for(int i=1;i<=n;i++)for(int j:e[a[i]])
	{
		if(tag[j]==i-1)dp[j]++; // 如果上次有更新（没清 0）则累加
		else dp[j]=1; // 反之上次会清 0，置成 1
		tag[j]=i; // 更新时间戳
		if(dp[j]>=k)ans=std::max(ans,(s[i]-s[i-dp[j]])*j); // 更新答案
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：11)

令 $s(l,r)$ 表示 $[l,r]$ 区间和，$g(l,r)$ 表示 $[l,r]$ 区间 $\gcd$。 

感觉这个函数是凸的（对于一个固定的 $r$，$s(l-1,r)>s(l,r)$，$g(l-1,r)\leq g(l,r)$），上手先写个三分，结果假了，这个很好 hack，只要在 $x$ 位置出现一个 $1$，容易构造 $s(x+1,r)g(x+1,r)\gt s(x-1,r)\gt s(x,r)$ 使其无法三分。

这个函数应该是 若干个 `\` 形的组合，一个 `\` 对应一些相同的 $g(x,r)$，考虑把所有不同 $g(x,r)$ 的取值段找出来，然后每一段取最靠左的那个端点即可。

对于 $g(1,r),g(2,r)...g(r-1,r),g(r,r)$，最多有 $\log V$ 种不同的取值，其中 $V$ 是值域，这是很好证明的：当 $g(x-1,r)\lt g(x,r)$ 时，有 $g(x,r)=kg(x,r),k\geq 2$，所以最多 $\log V$ 次就变成 $1$ 了。

用 ST 表处理一下 $g(l,r)$，然后枚举 $r$，并对于每个 $r$ 二分出 $\log V$ 个不同 $g$ 取值的最靠左的点，然后计算并取 $\max$ 即可。复杂度 $O(n\log n\log^2V)$，可以过，事实上，两个 $\log V$ 并不能跑满：当你构造出 $\log V$ 个不同 $\gcd$ 取值时，即 $2$ 的 $x$ 次幂的升序排列，求 $\gcd$ 时辗转相除的次数会很小。

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e6 + 5;
int n, k, h[N], g[N][21], lg[N];
ll sum[N], ans;
inline int gcd(int l, int r) {
	int k = lg[r - l + 1];
	return __gcd(g[l][k], g[r - (1 << k) + 1][k]);
}
inline ll solve(int r) {
	int l = 1;
	ll res = 0;
	while (l <= r - k + 1) {
		const int glr = gcd(l, r);
		res = max(res, glr * (sum[r] - sum[l - 1]));
//		cout << l << ' ' << r << endl;
		if (glr == h[r])
			break;
		int L = l + 1, R = r, pos = r;
		while (L <= R) {
			int mid = (L + R) >> 1;
			if (gcd(mid, r) > glr)
				pos = mid, R = mid - 1;
			else 
				L = mid + 1;
		}
//		assert(gcd(pos, r) != gcd(l, r) && gcd(pos - 1, r) == gcd(l, r));
		l = pos;
	} 
	return res;
}
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		cin >> h[i];
	for (int i = 1; i <= n; i++)
		sum[i] = sum[i - 1] + h[i];
	for (int i = 2; i <= n; i++)
		lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++)
		g[i][0] = h[i];
	for (int j = 1; j <= lg[n]; j++)
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
			g[i][j] = __gcd(g[i][j - 1], g[i + (1 << (j - 1))][j - 1]);
	for (int i = k; i <= n; i++)
		ans = max(ans, solve(i));
	cout << ans << endl;
	return 0;
}
```

还能优化。

发现每次 $r+1$ 时只需要对这 $\log V$ 个不同的 $g$ 再分别对 $h_{r+1}$ 取 $\gcd$ 即可，去重后依旧是 $\log V$ 的，所以直接维护就好了，复杂度 $O(n\log^2 V)$。

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e6 + 5;
int n, k, h[N], g[21], pos[21], tot;
ll sum[N], ans;
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		cin >> h[i];
	for (int i = 1; i <= n; i++)
		sum[i] = sum[i - 1] + h[i];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= tot; j++)
			g[j] = __gcd(g[j], h[i]);
		if (g[tot] != h[i])
			g[++tot] = h[i], pos[tot] = i;
		int ntot = 0;
		for (int j = 1; j <= tot; j++)
			if (g[j] != g[j - 1])
				g[++ntot] = g[j], pos[ntot] = pos[j];
		tot = ntot;
		for (int j = 1; j <= tot; j++)
			if (i - pos[j] + 1 >= k)
				ans = max(ans, g[j] * (sum[i] - sum[pos[j] - 1]));
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：Anonymely (赞：10)

题意：有一个长为 $n$ 的数组 $h_i$ 和一个 $k$，你可以选择一个长度至少为 $k$ 的区间 $ [l,r] $，设区间 $[l,r]$ 内所有数的 $\gcd$ 为 $g$，则这个区间的权值是 $g\times \sum^{r}_{i=l} h_i$。输出所有合法区间的最大权值，$1\le k\le n\le 10^6,1\le h_i\le 10^6$。

sol：首先考虑区间  $ \gcd $ 的一个经典性质：固定左端点，则对应区间右端点的 $\gcd$ 取值只会变化  $ \log V $ 次，其中 $ V $ 是值域。证明很简单，每次  $ \gcd $ 变化最少会将其除以  $ 2 $，最多除 $ \log $ 次就变成 $ 1 $ 了。

从小到大枚举左端点，用 $ \log $ 次二分找出这 $ \log $ 个 $ \gcd $ 变化的位置，用 ST 表  $ O(\log V) $ 地求区间  $ \gcd $，可以做到 $ O(n\log n\log^2V) $，实现得优秀可以过，但是我们有更好的解法。

正难则反，我们改成从大到小枚举左端点，假设枚举到 $ i $，不难发现以 $ i $ 为左端点 $ \gcd $ 变化的位置是可以继承左端点为 $ i+1 $ 的答案的。具体来说，维护一个链表表示 $ \gcd $ 变化的位置，从 $ i+1 $ 转移到 $ i $ 时，先将链表中所有区间 $ \gcd $ 的值与 $ h_i $ 求个 $ \gcd $，再将 $ i $ 加入链表，最后将链表中相邻两个位置值相同的合并起来。

由于先前的分析，链表中的元素始终不会超过 $ \log $ 个，总时间复杂度是 $ O(n\log n\log V) $。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define QwQ330AwA return 0
#define ll long long
#define pii pair <int, int> 

const int N = 1e6 + 5;
int n, k;
int nxt[N], val[N];
ll s[N], ans;

int gcd(int x, int y) {
	if (!y) 	return x;
	return gcd(y, x % y);
}

void solve(){
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		s[i] = s[i - 1] + val[i];
		nxt[i] = i + 1;
	}
	nxt[n + 1] = n + 1;
	for (int l = n; l >= 1; l--) {
		int now = l;
		for(; now != n + 1;){
			val[now] = gcd(val[l], val[now]);
			if(nxt[now] - l >= k) {
				ans = max(ans, val[now] * (s[nxt[now] - 1] - s[l - 1]));
			}
			now = nxt[now];
		}
		now = l;
		for (; now != n + 1;) {
			while(val[now] == val[nxt[now]]) {
				nxt[now] = nxt[nxt[now]];
			}
			now = nxt[now];
		}
	}
	cout << ans << '\n'; 
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	QwQ330AwA;
}

```

为什么突然写这篇题解呢，熟悉我的人知道我是基本不写 luogu 题解的。所以说是为什么呢？是为什么呢？

2023.11.8

---

## 作者：BIG_CUTE_BUG (赞：5)

思维题，难点在想到做法。

最终思路也相对不难，代码也很好实现。

[题传](https://www.luogu.com.cn/problem/P9032)

## 思路
一眼暴力 $n^2$ 枚举 $\frac{n\times (n+1)}{2}$ 个区间，$\log V$ 求区间 $\gcd$，再考虑优化。

发现性质：对于左端点 $l$，右端点 $r\in [l,n]$ 的 $n-l+1$ 个区间，这些区间的区间 $\gcd$ 值中，最多有 $\log V$ 个不同取值，且这些取值单调不升。（$V$ 是值域）

略证：对于这 $n-r+1$ 个区间，其对应的每个区间 $\gcd$ 值，随着 $r$ 增加，每次 $\gcd$ 值不变，或至少 **除以** $2$，故最多变化 $\log V$ 次，且不升。

那么这个性质让我们发现 $n^2$ 枚举的区间中，有很多 $\gcd$ 值都是重复冗余的。

延续刚才固定 $l$ 的思路，我们从 $n$ 到 $1$ 倒序枚举 $l$。因为很多 $\gcd$ 值都一样，所以考虑算出此时对应的 $n-l+1$ 个区间中 $\log V$ 个取值，对每个取值，判断区间是否大于 $k$，算出美丽度，取最大。

而我们处理 $l$ 时，是已经处理出 $l+1$ 的，所以我们算 $l$ 的 $\log V$ 个区间 $\gcd$ 值时，只用和 $l+1$ 的每个 $\gcd$ 值再取 $\gcd$，最后去重即可。

算完 $l$ 后，把 $l$ 也加入 $\gcd$ 序列中即可。

因为要合并，所以代码实现可以考虑用链表，存两个信息：区间 $\gcd$ 值和每个 $\gcd$ 值的最后一位坐标。另外美丽度要算区间和，所以加个前缀和。（具体见代码）


链表每个元素进一次，开 $\text{O}(n)$ 可。

$n$ 次每次会将 $h_l$ 和链表中 $\log V$ 个元素取 $\gcd$，所以总复杂度是 $\text{O}(n \log^2 V$)，不过其中取 $\gcd$ 辗转相除次数较少，所以总的跑的还是比较快的。([record](https://www.luogu.com.cn/record/140466331))

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N= 1e6+ 5;
int n, k, a[N], nxt[N], val[N], num[N], head, cnt;
long long ans, sum[N];
signed main()
{
	scanf("%d%d", &n, &k);
	for(int i= 1; i<= n; i++) scanf("%d", &a[i]), sum[i]= sum[i- 1]+ a[i];
	for(int l= n; l>= 1; l--)
	{
		for(int pre= head; pre; pre= nxt[pre]) val[pre]= __gcd(val[pre], a[l]);
		nxt[++cnt]= head, head= cnt, val[cnt]= a[l], num[cnt]= l;
		for(int pre= head; pre; pre= nxt[pre])
		{
			while(val[pre]== val[nxt[pre]]) num[pre]= num[nxt[pre]], nxt[pre]= nxt[nxt[pre]];
			if(num[pre]- l+ 1>= k) ans= max(ans, (sum[num[pre]]- sum[l- 1])* val[pre]);
		}
	}
	printf("%lld", ans);
	return 0;
}
//我没有压行的其实
```

---

## 作者：aCssen (赞：5)

### Solution
考虑分治。

对于一个需要处理的区间 $[l,r]$，我们令 $mid =\frac{l+r}{2}$，那么 $[l,r]$ 的所有子序列会分为三种：
+ $[l,mid]$ 的子序列。
+ $[mid+1,r]$ 的子序列。
+ 左端点 $\in[l,mid]$，右端点 $\in [mid+1,r]$ 的序列。

显然前两种情况递归解决即可，边界有两种：
+ $r-l+1<k$，直接返回。
+ $l=r$ 且并没有返回，那么答案与 $h_{l}^2$ 取 $\max$。

接下来重点讨论跨越中点的情况，容易发现，这时的序列是区间 $[l,mid]$ 的一段后缀和区间 $[mid+1,r]$ 的一段前缀。

有一个结论，固定一个区间的端点后，往后依次取 $\gcd$，那么其不同的取值的级别是 $O(\log V)$ 的，因为每次 $\gcd$ 的改变至少会除 $2$。

又因为序列 $h$ 中的数全部为正，所以在有相同 $\gcd$ 的情况下，区间越长越好。

因此能够得到一种做法：记录区间 $[mid+1,r]$ 的前缀 $\gcd$ 以及每个 $\gcd$ 变化的位置，即整数 $i$ 满足 $\gcd_{j=mid+1}^i \lbrace a_j\rbrace \neq \gcd_{j=mid+1}^{i+1} \lbrace a_j\rbrace$，这样的 $i$ 最多有 $\log V$ 个。

对于区间 $[l,mid]$ 同理，但是改记后缀的位置。

注意 $r$ 也为前缀的变化点之一，$l$ 也为后缀的变化点之一。

然后枚举左边的 $\gcd$ 变化位置 $i$ 和右边的变化位置 $j$，检查区间长度是否大于等于 $k$，如果满足条件就用这段的和乘这段的 $\gcd$ 更新答案即可。

为了快速求出区间和，要预处理出前缀和。

每次做完后记得将数组清空。

时间复杂度 $\mathcal{O}(n\log n \log ^2V)$，但好像并不需要卡常。
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
typedef long long ll;
const int maxn=1e6+5;
int a[maxn],pre[maxn],suf[maxn],Pre[maxn],Suf[maxn],n,k;
ll sum[maxn],ans;
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
void solve(int l,int r){
	if(r-l+1<k) return;
	if(l==r){
		ans=max(ans,1ll*a[l]*a[l]);
		return;
	}
	int mid=l+r>>1;
	solve(l,mid);
	solve(mid+1,r);
	vector<int>p,s;
	Pre[mid]=Suf[mid+1]=0;
	for(int i=mid+1;i<=r;i++){
		Pre[i]=gcd(Pre[i-1],a[i]);
		if(!pre[Pre[i]]) p.push_back(i-1);
		pre[Pre[i]]++;
	}
	for(int i=mid;i>=l;i--){
		Suf[i]=gcd(Suf[i+1],a[i]);
		if(!suf[Suf[i]]) s.push_back(i+1);
		suf[Suf[i]]++;
	}
	p.push_back(r);
	s.push_back(l);
	for(auto p1:p) for(auto p2:s) if(p1-p2+1>=k)
		ans=max(ans,1ll*gcd(Pre[p1],Suf[p2])*(sum[p1]-sum[p2-1]));
	for(int i=mid+1;i<=r;i++)
		pre[Pre[i]]--;
	for(int i=mid;i>=l;i--)
		suf[Suf[i]]--;
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)	
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+a[i];
	solve(1,n);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：slzx2022YuYihan (赞：4)

# Solution
这里给出一种 $O(n\log^3n)$ 的做法，不过需要卡常大法，比如能用 int 就用 int，循环加上 register，并且用上快读快输，卡了一个多小时。因为计算 gcd 需要 log 级别的复杂度。

首先，我们用倍增的思路，打一个区间 gcd，非常像 ST 表，复杂度 $O(n\log^2n)$。

然后，我们枚举区间右端点。容易发现，gcd 其实是从右往左单调递增的。如果改变，那么至少也要乘上二。所以至多有 log 个值。因此考虑用二分。二分当前右端点往前第一个增加 gcd 的位置。区间 gcd 值已经预处理出来了，区间和用前缀和。复杂度 $O(n\log^3n)$。

总复杂度：$O(n\log^2n+n\log^3n)$，记得吸氧。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
    x = 0; T w = 1; char ch = getchar();
    while (!isdigit(ch)){if (ch == '-') w = -1; ch = getchar();}
    while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x *= w;
}
template<typename T>inline void write(T x){
    if (x < 0)  putchar('-'), x = ~(x - 1);
    if (x > 9)  write(x / 10);
    putchar(x % 10 ^ 48);
}

const int N = 1e6 + 5;

int n, k, h[N];
ll sum[N];
ll ans;
int f[N][21], lg[N];
inline int getgcd(int l, int r) {
	int x = lg[r - l + 1];
	return __gcd(f[l][x], f[r - (1 << x) + 1][x]);
}
//区间gcd

int main() {
	read(n), read(k);
	for (register int i = 1; i <= n; ++i)
		read(h[i]), sum[i] = sum[i - 1] + h[i], f[i][0] = h[i];
	for (register int i = 2; i <= n; ++i)
		lg[i] = lg[i >> 1] + 1;
	for (register int j = 1; j <= lg[n]; ++j)
		for (register int i = 1; i + (1 << j) - 1 <= n; ++i)
			f[i][j] = __gcd(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	for (register int i = k; i <= n; ++i){
        int l = 1, r = i;
    	int res;
	    while (l <= r - k + 1) {
		    res = getgcd(l, r), ans = max(ans, res * (sum[r] - sum[l - 1]));
		    if (res == h[r])	break;
		    int L = l + 1, R = r, pos = r, mid;
		    while (L <= R) {	//二分左端点
    			mid = L + R >> 1;
			    if (getgcd(mid, r) > res)	R = mid - 1, pos = mid;
			    else 	L = mid + 1;
		    }
		    l = pos;	//跳跃
	    } 
    }
	write(ans), putchar('\n');
	return 0;
}
```

# In the end
据说这道题还可以继续优化，复杂度为 $O(n\log^2n)$，可以看看别的大佬的题解 ~~（其实是我不会再优化了）~~。

---

## 作者：Pengzt (赞：4)

[cnblogs](https://www.cnblogs.com/Pengzt/p/17929892.html)

[P9032](https://www.luogu.com.cn/problem/P9032)

考试题。

发现 $g$ 的值是若干个相同的段，且段数很少，因为每次取 $\gcd$ 至少会将值域变为原来的一半。所以段数是 $\mathcal{O}(\log V)$ 的。

然后就可以从小到大枚举左端点，然后枚举 $g$ 的值，找的是最远的满足 $\gcd(a_l,\dots,a_r)=g$ 的 $r$，这里可以使用二分。二分的 check 使用 ST 表即可做到 $\mathcal{O}(n\log n\log^2V)$。$k$ 的话再判断一下就行。常数极小，可以通过。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,m;
int a[1000010],gc[22][1000010];
ll s[1000010];
int gcd(int a,int b){
	while(b)swap(a%=b,b);
	return a;
}
int ask(int l,int r){
	int d=__lg(r-l+1);
	return gcd(gc[d][l],gc[d][r-(1<<d)+1]);
}
int work(int st,int lim,int g){
	int l=lim,r=n,res=lim;
	while(l<=r){
		int mid=(l+r)>>1;
		if(ask(st,mid)==g)l=mid+1,res=mid;
		else r=mid-1;
	}
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),gc[0][i]=a[i],s[i]=s[i-1]+a[i];
	for(int i=1;i<=__lg(n);i++)for(int j=1;j+(1<<i)-1<=n;j++)gc[i][j]=gcd(gc[i-1][j],gc[i-1][j+(1<<i-1)]);
	ll ans=a[n];
	for(int i=1;i<=n-m+1;i++){
		int x=i+m-1;ans=max(ans,ask(i,i+m-1)*1ll*(s[i+m-1]-s[i-1]));
		while(x<n){
			int g=ask(i,x+1);
			int p=work(i,x+1,g);
			if(p-i+1>=m)ans=max(ans,(s[p]-s[i-1])*g);
			x=p;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

但是这个东西显然不是正解。正难则反，发现 $i$ 的右端点容易由 $i+1$ 得到。故可以从大到小的枚举 $i$。然后用一个数据结构（比如链表）存下当前 $\log V$ 个 $\gcd$ 的位置。将这些 $\gcd$ 都和 $h_i$ 做一遍即可。然后相同的取较大的即可。


---

## 作者：LHLeisus (赞：4)

[极好的阅读体验](https://www.cnblogs.com/LHLeisus/p/17818440.html)

[原题链接](https://www.luogu.com.cn/problem/P9032)

最暴力的想法是枚举每一个区间进行计算，这样子的复杂度是 $O(n^3)$，可以用前缀和以及 ST 表优化到 $O(n^2\log n)$。

满分做法：

注：以下的 $\gcd(l,r)$ 均指 $[l,r]$ 这个区间所有数的 $\gcd$。

对于一个长度为 $V$ 的区间，$\gcd(l,l),\gcd(l,l+1),\gcd(l,l+2),\dots,\gcd(l,r)$ 至多只有 $\log h_l$ 种不同的取值，并且是递减的。证明比较简单，一个数 $x$ 和另一个数求 $\gcd$，结果一定是 $\le x$，如果小于 $x$，也就是说少了一个公因子，这个公因子最小是 $2$，故极限的情况是每次都除以 $2$，直到 $\gcd=1$，这样是至多 $\log h_l$ 种取值。

也就是说，每个区间会被分成 $\log$ 个子区间，对于每个子区间，$\forall i\in$ 子区间，$\gcd(h_l,h_i)$ 都是一样的，而为了让区间和最大，一定取右端点。我们只需要记录每个子区间的右端点和当前子区间对应的 $\gcd$ 取值即可。

对于每个点 $i$，我们都需要求出 $i$ 到 $n$ 的断点，显然对于每个 $i$ 的断点集合都是不一样的，直接求是 $O(n^2\log n)$ 的（求 $\gcd$ 还有 $O(\log n)$）。但是总有一些规律，比如，对于 $i+1$ 断点集合里的断点，他们在 $i$ 中可能成为断点，但是不在 $i+1$ 中的一定不会成为断点。于是我们可以倒序计算，将断点和对应的 $\gcd$ 作为二元组存进 vector，每一次在 $vec[i+1]$ 中加入 $i$，并且将所有断点的 $\gcd$ 和 $h_i$ 求一次 $\gcd$，这时候会出现一些相同的，我们保留最靠右的。由于最多只会有 $\log$ 个断点，还要求 $\gcd$ 这样的复杂度是 $O(n\log^2n)$。查询时直接遍历断点集合，取区间长度 $\ge k$ 的进行计算即可，复杂度 $O(n\log n)$。最终复杂度为 $O(n\log^2n)$。

code:

 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<utility>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#define int long long
#define FOR(i,a,b) for(register int i=a;i<=b;i++)
#define ROF(i,a,b) for(register int i=a;i>=b;i--)
#define mp(a,b) make_pair(a,b)
#define pll pair<long long,long long>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
inline int read();
typedef long long ll;
typedef double db;
const int N=1e6+5;
const int INF=0x3f3f3f3f;
int n,m,k;
int h[N],s[N];
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int calc(int x,int y){return s[y]-s[x-1];}
vector<pii>vec[N];
int ans=0;
signed main()
{
	n=read(),k=read();
	FOR(i,1,n) h[i]=read(),s[i]=s[i-1]+h[i];
	vec[n].push_back(mp(n,h[n]));
	vector<pii>temp;
	ROF(i,n-1,1){
		temp.clear();
		temp.push_back(mp(i,h[i]));
		for(auto v:vec[i+1]) temp.push_back(v);
		int las=INF;
		ROF(j,temp.size()-1,0){
			auto &v=temp[j];
			v.se=gcd(v.se,h[i]);
			if(v.se==las) v.fi=INF;
			else las=v.se;
		}
		for(auto v:temp) if(v.fi!=INF) vec[i].push_back(v);
	}
	int ans=0;
	FOR(i,1,n){
		for(auto v:vec[i]){
			if(v.fi-i+1>=k)ans=max(ans,v.se*calc(i,v.fi));
		}
	}
	printf("%lld",ans);
	return 0;
}


inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f*x;
}


```


---

## 作者：happybob (赞：3)

可以发现，如果固定 $l$，那么 $\gcd(a_l, a_{l+1}, \cdots, a_r)$ 显然单调递减。

接着可以发现，$l$ 固定时，随着 $r$ 的增大，$\gcd$ 的不同个数并不多。

可以这样理解：如果 $\gcd$ 不同个数很多，那就意味着每次增大 $r$ 的时候，$a_r$ 分解质因数后都会有一个质因数的次数变小。而质因数的次数变小很快就会变回 $1$。

所以固定 $l$，二分 $r$ 的变化点即可并且 ST 表维护区间 $\gcd$ 即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <numeric>
#include <vector>
using namespace std;

const int N = 1e6 + 5;

int n, k, a[N];
long long ans = 0, sum[N];

int f[N][31], LG2[N];

void Init()
{
	LG2[1] = 0;
	for (int i = 2; i < N; i++) LG2[i] = LG2[i >> 1] + 1;
	for (int i = 1; i <= n; i++)
	{
		f[i][0] = a[i];
	}
	for (int j = 1; j <= LG2[n]; j++)
	{
		for (int i = 1; i + (1 << j) - 1 <= n; i++)
		{
			f[i][j] = gcd(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
		}
	}
}

int query(int l, int r)
{
	int x = LG2[r - l + 1];
	return gcd(f[l][x], f[r - (1 << x) + 1][x]);
}

int main()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), sum[i] = sum[i - 1] + a[i], ans = max(ans, 1LL * a[i]);
	Init();
	for (int i = 1; i <= n - k + 1; i++)
	{
		int nowres = a[i], p = i;
		while (p <= n)
		{
			int l = p + 1, r = n, rr = 0;
			while (l <= r)
			{
				int mid = l + r >> 1;
				int gc = query(i, mid);
				if (gc >= nowres)
				{
					l = mid + 1;
				}
				else
				{
					r = mid - 1;
					rr = mid;
				}
			}
			if (rr == 0) break;
			nowres = query(i, rr);
			p = rr - 1;
			if (p - i + 1 >= k)
			{
				ans = max(ans, (sum[p] - sum[i - 1]) * (long long)(query(i, rr - 1)));
				//printf("%d %d\n", i, p);
			}
			p = rr;
		}
		ans = max(ans, (sum[n] - sum[i - 1]) * query(i, n));
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：1234567890sjx (赞：2)

来说个考场做法。

首先考虑 $O(n^2\log n)$ 暴力。容易发现直接预处理出一段连续区间的 $\gcd$ 即可。

考虑优化。容易发现一些关于 $\gcd$ 的性质：

+ $\gcd(1,x)=1$。
+ $\gcd(x,kx)=x$，其中 $k\in \textbf{N}$。
+ 若左端点固定，那么无论数组怎么构造，区间的右端点向右移动时，获得的不同的 $\gcd$ 值的数量为 $\log$ 级别。
+ 若左端点固定，那么无论数组怎么构造，区间的右端点向右移动时，获得的 $\gcd$ 值一定不会比原来的 $\gcd$ 值大。

前两个性质十分的平凡，考虑证明第三个性质。

若当前 $[l,r]$ 区间的 $\gcd$ 值已经求出为 $v$，那么如果令右端点向右移动一个单位长度即 $r\to r+1$，那么新的区间 $\gcd$ 会发生下面的变化：

+ $\gcd$ 值不发生任何的变化。
+ $\gcd$ 值变为原来的 $\gcd$ 值的 $\frac{1}{x}$，其中 $x\in \textbf{N}$ 且 $x\ge 2$，并且满足新的 $\gcd$ 值仍然是一个正整数。

容易发现，$\gcd$ 值变化当且仅当更新后的 $\gcd$ 值的更新参数 $x$ 满足 $x\ge 2$ 且 $x$ 是原来 $\gcd$ 值的因数。此时 $\gcd$ 值最大不会超过原来 $\gcd$ 值的一半，容易发现这个递减过程到 $1$ 是 $\log$ 级别的。而通过性质 $1$ 可以得到若 $\gcd$ 递减到 $1$ 那么将永远不会发生新的变化，所以性质得证。同理可证性质 $4$。

通过性质 $4$ 可以发现若左端点 $l$ 确定，则右端点 $r$ 给答案在 $\gcd$ 方面提供的答案为 $\gcd_{i=l}^r h_i$。这个东西是有单调性的（单调不递增）。

又通过性质 $3$，所以对于所有满足 $1\le l\le n$ 的正整数下标 $l$ 求出所有 $\gcd$ 值相同的区间 $[l_i,r_i]$。这个东西用二分求解即可。

由于求 $\gcd$ 需要 $\log$ 的时间复杂度，所以这一部分的时间复杂度是 $O(n\log^3n)$ 的。

设对于固定的左端点 $l$ 有 $k$ 组 $\gcd$ 值在区间内全部相同的区间 $[l_i,r_i]$，则考虑计算每一段区间内的最优解。

容易证明若左端点 $l$ 固定，则右端点 $r$ 增加，区间的和 $\sum_{i=l}^r h_i$ 一定会单调递增。所以对于每一段区间，枚举左端点后一定是选取 $\gcd$ 值相同的区间中下标最大的下标 $p$ 作为区间 $[l_i,r_i]$ 中最优秀的右端点。

根据性质 $3$ 得到对于每一个左端点 $l$ 得到的所有 $\gcd$ 值相同的区间的级别为 $n\log n$，所以这一步的时间复杂度为 $O(n\log ^2n)$（同样的需要求 $\gcd$）。

求一个连续区间的 $\gcd$ 值用 `ST` 表预处理即可。每一次查询的时间复杂度为 $O(\log n)$，瓶颈同样在于求 $\gcd$。

所以总的时间复杂度为 $O(n\log^3n)$ 的，到这里你已经可以获得 $78$ 分的好成绩。（模拟赛时给出的分数是 $80$ 分）

题解区中给出了 $O(n\log^2n)$ 的优秀做法，但是我不会，所以我选择了另一种方法，优化程序的常数，最终可以以不足 $2$ 秒的速度卡过。

[丑陋不堪的的代码](https://www.luogu.com.cn/paste/glauzkxf)，由于是赛时代码所以就不修了。

------

upd：提供神仙同学的神仙做法。

发现值域只有 $10^6$，所以考虑暴力分解质因数。容易发现 $>10^3$ 的质因数最多只会在一个数中出现 $1$ 次，所以单独考虑。$\le 10^3$ 的质因数只有 $168$ 个，开一个桶维护。

然后还是按照上面的套路，同样找出所有左端点 $l$ 固定时 $\gcd$ 相同的右端点 $r$ 的区间 $[l_i,r_i]$，然后按照上面的贪心策略贪。

时间复杂度？不会证。zwj 老师说是 $O(n\log^2n)$ 的但是不理解。

[同学的代码](https://www.luogu.com.cn/paste/o72yu0ls)，没有修。跑的飞快，薄纱 `std`。

---

## 作者：ran_qwq (赞：1)

补篇题解，提供一种不一样的思路。

### $O(n^2\log V)$ 做法

预处理区间 gcd，枚举两个端点。

枚举 $O(n^2)$，算区间 gcd $O(\log V)$，时间复杂度 $O(n^2\log V)$。

### $O(n\log n\log^2V)$ 做法

考虑只枚举左端点 $l$。

$r$ 每次往右移，只有两种情况：

1. 区间 gcd 不变。

1. 区间 gcd 变小，容易发现，变小肯定是除以一个大于 $1$ 的整数。

区间 gcd 最少到 $1$，所以最多除 $\log V$ 次（$V$ 表示值域）。

所以当左端点 $l$ 固定时，区间 gcd 最多只有 $\log V+1$ 种取值。

对于每个区间 gcd，$r$ 肯定是取它的最右边（因为 gcd 一定，$r$ 越大，区间和越大，价值越大）。

所以对于每个左端点 $l$，对答案产生贡献的右端点最多只有 $\log V+1$ 个。

二分出每个区间 gcd 的 $r$ 即可。

枚举左端点 $O(n)$，有 $\log V$ 个区间 gcd，二分 $O(\log n)$，求 gcd $O(\log V)$，时间复杂度 $O(n\log n\log^2V)$。

### $O(n\log^2V)$ 做法

因为时限 $2.5$ 秒，上面的做法卡卡常能过。

我们发现每次都二分太蠢了，可不可以维护 $\log V$ 个右端点跟着 $l$ 往右移呢？

设 $d(x)$ 为 $x$ 的质因数次数和。形式化的，设 $x=\prod\limits p_i^{k_i}$，则 $d(x)=\sum\limits k_i$。显然这个可以预处理出来。

设 $b_y$ 为当前左端点为 $l$，区间 gcd 的 $d$ 值为 $y$ 时的右端点。

不难发现，$l$ 往右移，$b_y$ 肯定跟着往右移（如果不往右移，区间 gcd 变大，区间 gcd 的 $d$ 值也变大）。

随便维护一下指针即可。

枚举左端点 $O(n)$，有 $\log V$ 个区间 gcd，求 gcd $O(\log V)$，时间复杂度 $O(n\log^2V)$。

[code.](https://www.luogu.com.cn/paste/j4qly950)

---

## 作者：Vindictae (赞：0)

# 题目思路
~~非常高级，以至于场切失败……~~

一道非常好的动态规划题。

考虑状态表示：
- 使用数组 $f_i$ 表示区间的最大公因数为 $i$ 的最大长度，$\_Flg_i$ 表示最后一次区间最大公因数为 $i$ 是什么时候。

考虑转移：
- 对于每一个 $h_i$，遍历其每一个因数 $it$：
  - 如果最后一次最大公因数是 $it$ 的便利不是在上次，即 $\_Flg_{it} \neq i - 1$，则 $f_{it}=1$；
  - 否则，$f_{it}=f_{it}+1$。
  - 更新 $\_Flg_{it}$ 为 $i$。
  - 如果当前长度 $\geq k$，即 $f_i \geq k$，则更新答案 $\_Ans$ 为 $\max (\_Ans, \sum_{i - f_{it} + 1}^{i}\times it)$。

考虑答案表示：
- 答案可以表示为 $\_Ans$，在转移时更新。
# AC Code
```cpp
const bool Debug = false;
const bool Luogu = true;
const bool Online = false;
const bool Lemon = false;

//#define Debug true
//#define Luogu flase
#define Online true
//#define Lemon true

#include <map>
#include <list>
#include <queue>
#include <cmath>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>

#define endl '\n'
#define int long long
#define mod 998244353
#define inf 0x3f3f3f3f
#define lnf 0x3f3f3f3f3f3f3f3f

#ifdef Online
	#define getchar() (_1==_2&&(_2=(_1=buf)+fread(buf,1,1<<20,stdin),_1==_2)?EOF:*_1++)
	char *_1, *_2, buf[(1 << 20) + 5];
#endif

//#define min(a,b) (a<b?a:b)
//#define max(a,b) (a<b?b:a)
//#define abs(a) (max(a,-a))
#define Deout(x) cout<<#x<<"\t=:="<<x<<endl
#define Deline() cout<<"\n-=--=--=--=--=--=--=--=-\n\n"

#ifdef Luogu
	#pragma GCC optimize (1)
	#pragma GCC optimize (2)
	#pragma GCC optimize (3)
	#pragma GCC optimize (4)
	#pragma GCC optimize (5)
	#pragma GCC optimize ("Os")
	#pragma GCC optimize ("Ofast")
#endif

using namespace std;

namespace WTH {
	inline bool input (int& x) {
		x = 0;
		int f = 1;
		bool flag = 0;
		char c = getchar ();

		while (!isdigit(c)) {
			if (c == '-') {
				c = getchar ();

				if (isdigit (c)) {
					f = -1;
					break;
				}
			} else {
				c = getchar ();
			}
		}

		while (isdigit (c)) {
			flag = 1;
			x = (x << 3) + (x << 1) + (c ^ 48);
			c = getchar ();
		}

		x *= f;
		return flag;
	}

	inline bool output (int x) {
		if (x < 0) {
			putchar ('-');
			x = -x;
		}

		char write[25], cnt = 0;

		do {
			write[++ cnt] = x % 10;
			x /= 10;
		} while (x);

		do {
			putchar (write[cnt --] | 48);
		} while (cnt);

		return x;
	}
	
	int base_gcd (int a, int b) {
		if (! b) {
			return a;
		}
		
		return base_gcd (b, a % b);
	}
	
	int Gcd (int a, int b) {
		if (a < b) {
			swap (a, b);
		}
		
		return base_gcd (a, b);
	}
	
	const int N = 1e6 + 5;
	
	int n, k;
	int h[N];
//	int _Sm, _G, _Ans;
	int _Ans, _Sm[N], f[N], _Flg[N];
	vector <int> _Fctr[N];
	
	void Before_All () {
		for (register int i = 0; i ^ N; ++ i) {
			_Fctr[i].clear ();
		}
		
		for (register int i = 1; i ^ N; ++ i) {
			for (register int j = i; j < N; j += i) {
				_Fctr[j].push_back (i);
			}
		}
	}

	void Init () {
		_Ans = 0;
		memset (f, 0, sizeof (f));
		memset (_Sm, 0, sizeof (_Sm));
		memset (_Flg, 0, sizeof (_Flg));
	}

	void Input () {
		input (n);
		input (k);
		
		for (register int i = 1; i <= n; ++ i) {
			input (h[i]);
			_Sm[i] = _Sm[i - 1] + h[i];
		}
	}

	void Main () {
//		for (register int l = 1; l <= n; ++ l) {
//			_Sm = 0;
//			_G = 0;
//			
//			for (register int r = (l + k) - 1; r <= n; ++ r) {
//				_Sm += h[r];
//				_G = Gcd (_G, h[r]);
//				_Ans = max (_Ans, _Sm * _G);
//			}
//		}
//		
		for (register int i = 1; i <= n; ++ i) {
			for (auto it : _Fctr[h[i]]) {
				if (_Flg[it] ^ (i - 1)) {
					f[it] = 1;
				} else {
					++ f[it];
				}
				
				_Flg[it] = i;
				
				if (f[it] >= k) {
					_Ans = max (_Ans, ((_Sm[i] - _Sm[i - f[it]]) * it));
				}
			}
		}
	}

	void Output () {
		output (_Ans);
		putchar ('\n');
	}
}

signed main () {
#ifdef Lemon
	freopen ("neboderi.in", "r", stdin);
	freopen ("neboderi.out", "w", stdout);
#endif
	
	WTH :: Before_All ();
	
	int T = 1;
	//cin >> T;

	while (T --) {
		WTH :: Init ();
		WTH :: Input ();
		WTH :: Main ();
		WTH :: Output ();
	}

	return 0;
}

```

---

## 作者：aimat (赞：0)

半年前的模拟赛 T2……

看到题解里多是 $2\log$ 做法，于是我就来写一篇不带 $\log$ 的题解。

首先，注意到右端点固定，左端点向左移动时 $\gcd$ 是单调不增的，于是我们考虑枚举右端点。

明显的，枚举右端点后枚举左端点的复杂度至少为 $O(n^2)$，没什么前途。

发现值域很小，受到 [P5610](https://www.luogu.com.cn/problem/P5610) 的启发，考虑枚举区间的 $\gcd$。

设当前右端点为 $i$，枚举的 $\gcd$ 为 $j$，根据 $\gcd$ 的定义，显然 $j\mid h_i$ 是必要的，那么我们就可以分解质因数后计算每一个数的因数，并用这个因数作为 $\gcd$。

明显的，充分性是错误的。但由于当一个数是区间的因数时，区间不变，一定有 $j\mid\gcd$，那么 $j\le\gcd$，所以 $j\times\sum_{i=l}^rh_i\le\gcd\times\sum_{i=l}^rh_i$，可见枚举 $j$ 贡献是不变的。

由于我们对于每个 $h_i$ 进行了枚举因数的操作，所以时间复杂度是 $O(n\max\lbrace d_i\rbrace)$ 的。这是几乎跑满的，所以和 $2\log$ 做法复杂度差不多。

实现上将质因数打表，前缀和查询区间和，开桶维护 $\gcd$ 连续段左端点就做完了，具体实现看代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
char *p1,*p2,buf[10010];
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++)
int read(){
	int x=0;
	char c=gc();
	while(c<48||c>57)c=gc();
	while(c>47&&c<58)x=(x<<3)+(x<<1)+(c^48),c=gc();
	return x;
}
//lst[i]:上一个被i整除的位置
//fr[i]:h[i]的因数
//beg[i]:能被i整除的连续段左端点的前一个位置（l-1）
int beg[1000010],lst[1000010],fr[250],a[1000010],pri[200]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};
long long sm[1000010];
int main(){
	int n=read(),K=read()-1,x,y,cnt,z;
	long long ans=0;
	for(int i=1;i<=n;++i){
		sm[i]=sm[i-1]+(a[i]=read());
		x=a[i];
		fr[y=1]=1;
		for(int j=0;j<168&&x!=1;++j){
			cnt=0;
			while(x%pri[j]==0)++cnt,x/=pri[j];
			z=1;
			int tmp=y;
			while(cnt--){
				z*=pri[j];
				for(int k=1;k<=tmp;++k)fr[++y]=fr[k]*z;
			}
		}
		if(x!=1){
			int tmp=y;
			for(int j=1;j<=tmp;++j)fr[++y]=x*fr[j];
		}
		++y;
		for(int j=2;j<y;++j){
			if(lst[fr[j]]!=i-1)beg[fr[j]]=i-1;
			if(i-beg[fr[j]]>K)ans=max(ans,(sm[i]-sm[beg[fr[j]]])*fr[j]);
			lst[fr[j]]=i;
		}
	}
	printf("%lld",max(ans,sm[n]));
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

不妨认为 $n,V$ 同阶，来一发 $O(n \log n + n^{\frac{4}{3}})$ 的做法，这里 $d_i$ 表示 $i$ 的因数个数。

考虑枚举最大公因数 $x$，然后标记所有是 $x$ 倍数的数，不过这样可能会出现实际上的最大公因数比 $x$ 大的情况，不过这题是统计 $\max$ 故没有关系，然后对于标记出来的所有点，一次枚举，对枚举到的点往左往右扩展极长标记段，就可以求出这一段的和，再乘上枚举的 $x$ 就是贡献，注意需要枚举一个删除一个，保证一个数至多被暴力枚举一次，那么这一部分复杂度是 $O(sz)$ 的，这里 $sz$ 表示是 $x$ 的倍数的数的数量。

那么总复杂度就是 $O(\sum d_{a_i} + n \log n) \leq O(n \log n + n \times \max_{i=1}^{n} d_i)$。

[结合这篇文章](https://megatrio.blog.uoj.ac/blog/7430)可以分析出最终复杂度是 $O(n \log n + n^{\frac{4}{3}})$。

不过事实上这篇文章中给出了更低的下界，但是为了方便没有全部打出来。

```cpp
#include<bits/stdc++.h>
namespace IO{
    const int SIZE=1<<21;
    static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
    #define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
    #define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
    #define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
    #define puts(x) IO::Puts(x)
    template<typename T>
    inline void read(T&x){
        for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
        for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15);
        x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
        for(int i=0;s[i];++i)
            putchar(s[i]);
        putchar('\n');
    }
    struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
#define max(a,b) (a>b?a:b)
using namespace std;
const int maxn = 1e6+114;
int a[maxn];
vector<int> pos[maxn];
int cnt[maxn],n,k;
long long ans;
long long pre[maxn];
signed main(){
	//freopen("T2.in","r",stdin);
	//freopen("T2.out","w",stdout);
	read(n);
	read(k);
	for(int i=1;i<=n;i++) read(a[i]),pre[i]=pre[i-1]+a[i],pos[a[i]].push_back(i);
	if(n>=k) ans=max(ans,pre[n]);
	for(int i=1;i<=1000000;i++){
		int sz=0;
		for(int j=1;i*j<=1000000;j++)
			for(int x:pos[i*j]) cnt[x]=i,sz++;
		if(sz<k) continue;
		for(int j=1;i*j<=1000000;j++)
			for(int x:pos[i*j]){
				if(cnt[x]==i){
					int lt=x-1;
					int rt=x+1;
					cnt[x]=0;
					while(cnt[lt]==i) cnt[lt]=0,lt--;
					while(cnt[rt]==i) cnt[rt]=0,rt++;
					if(rt-lt-1>=k) ans=max(ans,i*(pre[rt-1]-pre[lt]));
				}
			}
	}
	write(ans);
	return 0;
}

```

---

## 作者：Link_Cut_Y (赞：0)

## 简化题意

给定长度为 $n$ 的序列 $\{a\}$ 和 $k$。定义一个自区间 $a_l \cdots a_r$ 的权值为 $\gcd(a_l, a_{l + 1} \cdots a_r) \times \left ( \sum_{i = l}^{r} a_i\right )$。求 $\{a\}$ 的所有自区间权值的最大值。

## solution

模拟赛考题。

### Subtask1

枚举 $l, r$，遍历计算 $[l, r]$ 每个数的最大公约数。时间复杂度 $O(n ^ 3 \log n)$。

### Subtask2

发现区间 $\gcd$ 可以在枚举 $l, r$ 的时候计算出来。这样做到 $O(n ^ 2 \log n)$。

### Subtask3

没想到吧，我也不知道这个部分分怎么拿。

### Subtask4

考虑性质。对左端点固定的区间，右端点向右移动，区间 $\gcd$ 单调递减，而且至多减 $O(\log V)$ 次就会减成 $1$。

因此可以考虑分治。假设当前分治区间为 $[l, r]$，记 $mid = \dfrac{l + r}{2}$。

只需要考虑左端点 $ \le mid$，右端点 $ > mid$ 的子区间。搞两个指针，一个从 $mid$ 往左走，记录一下指针到 $mid$ 的所有区间的不同的 $\gcd$，如果 $\gcd$ 相同则贪心地留左边的。剩下一个指针同理扫右边区间。扫到的 $\gcd$ 都存到 `vector` 里。

最后遍历两个 `vector` 并统计答案。由于 `vector` 大小是 $O(\log V)$ 级别的，因此这个复杂度是 $O(\log ^ 2 V)$。

算法总复杂度 $O(n \log n \log ^ 2 V)$。~~加上快速 $\gcd$ 的高级算法可以冲过第四个子任务。~~

### Subtask5

发现可以不用分治。枚举右端点 $r$，动态维护以 $r$ 为右端点的子区间的不同的 $\gcd$。

动态维护方式：假设已经有了以 $r - 1$ 结尾的所有不同 $\gcd$，并存在一个数组里。由于数组大小是 $O(\log V)$ 级别的，因此当右指针向右移动的时候，可以暴力将数组中的每个元素与 $a_r$ 取 $\gcd$。

右指针移动一次，需要与 $\log V$ 个元素取 $\gcd$，取一次 $\gcd$ 的时间是 $O(\log V)$。因此时间复杂度是 $O(n \log ^ V)$。

### code

```cpp
#define x first
#define y second
using PII = pair<int, int>;
const int N = 2000010;
int n, k, w[N], s[N], d[N], ans;
int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }
signed main() {
	read(n, k);
	rep(i, 1, n) read(w[i]);
	rep(i, 1, n) s[i] = s[i - 1] + w[i];
	vector<PII> vec;
	vec.push_back({w[1], 1});
	rep(i, 2, n) {
		for (PII &j : vec) j.x = gcd(w[i], j.x);
		vec.emplace_back(make_pair(w[i], i));
		sort(vec.begin(), vec.end(), [&](PII a, PII b) {
			return a.x == b.x ? a.y < b.y : a.x < b.x;
		}); vector<PII> New;
		rop(j, 0, vec.size()) {
			if (j and vec[j].x == vec[j - 1].x) continue;
			if (i - vec[j].y + 1 >= k)
				ans = max(ans, vec[j].x * (s[i] - s[vec[j].y - 1]));
			New.emplace_back(vec[j]);
		} vec = New;
	} write('\n', ans); return 0;
	return 0;
}
```

---

## 作者：Luciylove (赞：0)

Trash 题。交个口胡做法。

考虑固定左端点。倒序扫描线，根据算术唯一分解定理，每次 $\gcd$ 变化至少在一个位置上减一，那么一个数最多减 $\log V$ 次。

那么一个左端点最多有 $\log V$ 个 $\gcd$ 连续段。你就考虑对于这些合法的连续段取右端点即可，因为 $h_i \geq 1$。

那么怎么维护呢？你考虑 $i + 1$ 这个位置维护出的那些段。然后对于每个段取 $\gcd$ 然后注意段数之间合并重复段即可。

这个题感觉不如 P9607 [CERC2019] Be Geeks!

鉴于没写代码，给出一个维护 $\gcd$ 连续段的实现。

```cpp
ncnt = 0;
++ cnt, lp[cnt] = rp[cnt] = i, gc[cnt] = a[i];
rep(j, 1, cnt) gc[j] = __gcd(gc[j], a[i]);
rep(j, 1, cnt) 
	if (gc[j] != gc[ncnt]) {
		gc[++ ncnt] = gc[j],
		lp[ncnt] = lp[j], rp[ncnt] = rp[j];
	} else lp[ncnt] = lp[j];
cnt = ncnt;
```

想必各位有能力实现出此题。

---


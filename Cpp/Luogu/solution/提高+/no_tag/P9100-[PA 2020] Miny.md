# [PA 2020] Miny

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Miny](https://sio2.mimuw.edu.pl/c/pa-2020-1/min/)**

$n$ 枚地雷被运到 Bytau 的军事训练场，并沿一条直线埋设。每个地雷位于不同的地方，并且有自己的爆炸半径。当引爆时，地雷会自动引爆其爆炸半径内所有尚未爆炸的地雷。如果地雷 $a$ 和地雷 $b$ 之间的距离不超过地雷 $b$ 的爆炸半径，则我们称地雷 $a$ 在地雷 $b$ 的爆炸半径内。

Bytomir 中士想进行一项实验。他选择了一个任意的地雷子集（也许是空的），并让这个地雷子集内的所有地雷在同时手动引爆。实验的结果是一组已经爆炸的地雷——要么是手动引爆的引起的爆炸，要么是其他地雷爆炸导致的爆炸。

Bytomir 能得到多少种可能的实验结果？如果两个实验结果中爆炸的地雷相同，则这两个实验结果是相同的。由于结果可能很大，请输出它除以 $10^9+7$ 的余数。

## 说明/提示

#### 样例 1 解释

你可以得到 $7$ 种可能的实验结果：

- $\{\}$（空集）：如果不引爆任何地雷；
- $\{1,2\}$（地雷 $1,2$）：如果我们只引爆地雷 $1$；
- $\{1,2,3\}$：如果我们引爆地雷 $1$ 和 $3$；
- $\{1,2,3,4\}$：如果我们引爆地雷 $1$ 和 $4$；
- $\{2\}$：如果我们只引爆地雷 $2$；
- $\{2,3\}$：如果我们只引爆地雷 $3$；
- $\{2,3,4\}$：如果我们只引爆地雷 $4$；

请注意，可以通过不同的方式得到同一个实验结果——例如，如果我们引爆地雷 $1$ 和 $2$，也会得到 $\{1, 2\}$ 的结果。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 3\times 10^5$，$0\le a_i,r_i\le 10^{18}$。

## 样例 #1

### 输入

```
4
0 2
2 0
3 2
7 4```

### 输出

```
7```

# 题解

## 作者：CmsMartin (赞：0)

[$\mathcal{Link}$](http://cmsblog.top/archives/pa2020miny)

有神秘的分治做法，有点厉害。写个无脑做法。

定义 $f_i$ 表示钦定 $i$ 考虑前 $i$ 个且钦定第 $i$ 个不爆炸的方案数。

转移只有一种情况，假设 $[j + 1, i - 1]$ 中的都无法引爆 $i, j$，就令 $f_i \gets f_i + f_j$。这样以后我们只需要求出一个炸弹 $i$ 可以引爆的最右边的炸弹 $r_i$ 和最右侧可以引爆 $i$ 的炸弹 $l_i$。

这个求法只用维护一个单调栈然后二分就可以了。于是就有 $f_i = \sum_{l_i}^{i - 1} f_j$，这样子使用树状数组就可以了。	

时间复杂度 $\mathcal{O}(n \log n)$。

```cpp
int n, st[N], top, L[N], R[N];
ll a[N], r[N]; vector<int> buc[N];
mint c[N], f[N];

int lb(int x) { return x & -x; }
void add(int x, mint v) { for (; x < N; x += lb(x)) c[x] += v; }
mint ask(int x) { mint res(0); if(x <= 0) return res; for (; x; x -= lb(x)) res += c[x]; return res; }

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i] >> r[i];
    a[0] = -inf, a[n + 1] = inf; f[0] = 1; add(1, 1);
    r[0] = r[n + 1] = inf * 2;
    st[top = 1] = 0; R[0] = n + 1;

    for (int i = 1; i <= n; i++) {
        auto get = [=](int u) -> ll { return a[u] + r[u]; };
        int l = 1, r = top, res = 1;
        while (l <= r) {
            int mid = l + r >> 1;
            if (get(st[mid]) >= a[i]) res = mid, l = mid + 1;
            else r = mid - 1;
        }
        L[i] = st[res];
        while (get(i) >= get(st[top])) top--;
        st[++top] = i;
    }
    st[top = 1] = n + 1;
    for (int i = n; i >= 1; i--) {
        auto get = [=](int u) -> ll { return a[u] - r[u]; };
        int l = 1, r = top, res = 1;
        while (l <= r) {
            int mid = l + r >> 1;
            if (get(st[mid]) <= a[i]) res = mid, l = mid + 1;
            else r = mid - 1;
        }
        R[i] = st[res];
        while (get(i) <= get(st[top])) top--;
        st[++top] = i;
    }
    auto query = [=](int l, int r) -> mint { return ask(r) - ask(l - 1); };
    for (int i = 0; i <= n; i++) buc[R[i]].emplace_back(i);
    for (int i = 1; i <= n + 1; i++) {
        f[i] = query(L[i] + 1, i);
        for (int j : buc[i]) add(j + 1, -f[j]);
        add(i + 1, f[i]);
    }
    cout << f[n + 1].x << "\n";
    return 0;
}
```

---

## 作者：Sol1 (赞：0)

考虑 dp，设 $f_i$ 为只考虑前 $i$ 个地雷，强制第 $i$ 个不引爆的方案数，朴素想法即对于 $i$ 枚举 $j>i$，判断引爆 $i+1\sim j-1$ 的所有地雷是否会引爆 $j$ 和 $i$。如果均不会引爆，则转移 $f_j\leftarrow f_j+f_i$。

考虑分治优化，需要在 $O(r-l)$ 时间内完成 $[l,m]$ 到 $[m+1,r]$ 的转移。

设 $i\leq m<j$，则条件可以转化为：

1. 引爆 $i+1\sim m$ 的所有地雷不会引爆 $i$；
1. 引爆 $i+1\sim m$ 的所有地雷不会引爆 $j$；
1. 引爆 $m+1\sim j-1$ 的所有地雷不会引爆 $i$；
1. 引爆 $m+1\sim j-1$ 的所有地雷不会引爆 $j$。

注意到虽然 $i+1\sim m$ 的引爆区间的并不一定仍然是一个区间，但是由于对于所有 $i$，$i$ 的引爆区间都包含 $a_i$，所以对于任何 $i+1\leq k\leq m$，它的引爆区间向左超出 $a_{i+1}$ 的部分一定形成一个后缀（因为需要包含 $a_k>a_{i+1}$），所以引爆区间的并向左超出 $a_{i+1}$ 的部分也一定形成一个后缀。同理，向右超出 $a_m$ 的部分也一定形成一个前缀。同时，我们需要判定是否属于引爆区间的并的点分别是 $a_i$ 和 $a_j$，分别向左超出 $a_{i+1}$ 和向右超出 $a_m$。

**于是在判定条件时，可以直接将引爆区间的并当作包含这个并的极小区间处理。**

而这个极小区间的左右端点就分别是所有左端点的最小值和所有右端点的最大值，可以非常容易地求出。设「包含 $i+1\sim m$ 的引爆区间的并的极小区间」是 $[L_i,R_i]$，「包含 $m+1\sim j-1$ 的引爆区间的并的极小区间」是 $[L_j',R_j']$。

然后考虑转移过程。

首先预处理 $i$ 侧，删去不满足 1 的 $i$（例如将其 $f$ 改为 $0$，不过当然不能把这个修改保留到最后算答案的时候）。

然后考虑递增处理 $j$。先判定条件 4，不满足条件 4 直接强制不能转移；然后判定条件 2,3。条件 2 等价于 $R_i<a_j$。不难发现 $R_i$ 关于 $i$ 递减，于是满足条件 2 的 $i$ 是一个随 $j$ 增大而逐渐扩大的后缀。条件 3 等价于 $L_j'>a_i$。类似的，不难发现 $L_j'$ 关于 $j$ 递减，于是满足条件 3 的 $i$ 是一个随 $j$ 增大而逐渐缩小的前缀。

于是最终合法的转移是一段区间，且左右端点均单调。使用双指针和前缀和处理，复杂度为 $O(n)$。套上分治，整个题就 $O(n\log n)$ 做完了。

```cpp
const int N = 300005;
const long long mod = 1000000007;

int n;
long long a[N], pr[N], dp[N], ls[N], rs[N], w[N];

inline void Read() {
    cin >> n;
    for (int i = 1;i <= n;i++) cin >> a[i] >> pr[i];
}

inline void Prefix() {
    long long mx = -4e18;
    for (int i = 1;i <= n;i++) {
        if (mx < a[i]) dp[i] = 1;
        mx = max(mx, a[i] + pr[i]);
    }
}

inline void Work(int l, int r) {
    if (l == r) return;
    long long mid = l + r >> 1;
    Work(l, mid);
    ls[mid] = 4e18; rs[mid] = -4e18;
    for (int i = mid - 1;i >= l;i--) {
        ls[i] = min(a[i + 1] - pr[i + 1], ls[i + 1]);
        rs[i] = max(a[i + 1] + pr[i + 1], rs[i + 1]);
    }
    w[l - 1] = 0;
    for (int i = l;i <= mid;i++) {
        if (ls[i] > a[i]) w[i] = dp[i];
        else w[i] = 0;
        w[i] = (w[i] + w[i - 1]) % mod;
    }
    int trr = mid, trl = mid;
    long long lt = 4e18, rt = -4e18;
    for (int j = mid + 1;j <= r;j++) {
        while (trl > l && rs[trl - 1] < a[j]) trl--;
        while (trr >= l && a[trr] >= lt) trr--;
        if (trl <= trr && rt < a[j]) dp[j] = (dp[j] + w[trr] - w[trl - 1] + mod) % mod;
        lt = min(lt, a[j] - pr[j]);
        rt = max(rt, a[j] + pr[j]);
    }
    Work(mid + 1, r);
}

inline void Solve() {
    long long ans = 1, mn = 4e18;
    Work(1, n);
    for (int i = n;i >= 1;i--) {
        if (mn > a[i]) ans = (ans + dp[i]) % mod;
        mn = min(mn, a[i] - pr[i]);
    }
    cout << ans << endl;
}
```

---


# [COCI 2022/2023 #4] Bojanje

## 题目描述

Oliver 是一只不仅能找出 bug 并且喜欢画画的小黄鸭。他最新的画有 $n$ 个部分，每部分用一种不同的颜色涂色。在此之后他得到了很多批评，因为他的画太可预测了。他决定用 $t$ 次迭代修改他的画。在每次迭代中他将做以下操作：

Oliver 会均匀随机选择一个下标 $i\ (1\le i\le n)$，然后记住画中第 $i$ 部分的颜色。
Oliver 会再均匀随机选择一个下标 $j\ (1\le j\le n)$。他会把画中第 $j$ 部分涂成和第 $i$ 部分一样的颜色。如果第 $j$ 部分的颜色和第 $i$ 部分相同，那么不会有任何改变。注意 $i$ 可以等于 $j$。
现在，Oliver 害怕他的画会变得十分单调或者无聊。他认为一幅画是好的，如果画上至少有 $k$ 种不同的颜色。请帮他计算最后这幅画是好的这个事件的概率。

## 说明/提示

样例 $1$ 解释：画上有两种颜色，所以一次迭代后画和未操作之前相同的概率是 $\frac{1}{2}$。

样例 $2$ 解释：在两次迭代后，不同的颜色数不可能从 $10$ 变为小于 $5$，所以在任何情况下这幅画都会有至少 $5$ 种不同的颜色。
 
| 子任务编号 | 附加限制 | 分值 |
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ |	$k=n$ | $28$ |
| $2$ |	$t\le 1000$ | $36$ |
| $3$ |	无附加限制 | $36$ |

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
500000004```

## 样例 #2

### 输入

```
10 2 5```

### 输出

```
1```

## 样例 #3

### 输入

```
3 141592653589793 2```

### 输出

```
468261332```

# 题解

## 作者：williamwei (赞：11)

一个目前是最优解，且异于其它任何题解的解法，在未卡常的情况下 15ms。

设 $f[n][k]$ 为 $n$ 次操作后还剩 $k$ 种颜色的概率。

操作后合并颜色，概率是 $\dfrac{k(k-1)}{n^2}$。

操作后不合并颜色，概率是 $1-\dfrac{k(k-1)}{n^2}$。

所以 $f[n][k]=f[n - 1][k + 1] \times \dfrac{k(k-1)}{n^2} + f[n - 1][k] \times (1-\dfrac{k(k-1)}{n^2})$。

用矩阵快速幂优化 DP 即可，将矩阵 $A$ 的第 $k$ 行 $k$ 列设为 $1-\dfrac{k(k-1)}{n^2}$，第 $k$ 行 $k-1$ 列设为 $\dfrac{k(k-1)}{n^2}$，计算这个矩阵的 $T$ 次方 $B = A^T$。

答案为从 $n$ 个颜色经过 $T$ 次操作后仍大于等于 $k$ 个颜色的方案数 $\sum \limits_{i=k}^n B_{n,i}$。

## 这道题真的那么简单吗？

不难发现，$\dfrac{k(k-1)}{n^2}$ 这个概率式子随便举一个例子就是错的，例如一个幅颜色为 `1 1 4 5 1 4` 的画，这里有 $3$ 种颜色，用这个公式算出的概率是 $\dfrac{3 \times 2}{6^2} = \dfrac{1}{6}$，但实际上只有在选择 $i\neq 4$ 与 $j = 4$ 时才会使得颜色总数减一，概率为 $\dfrac{5}{36}$，和公式结果不符。

为什么算出来的内容和实际结果不一样呢？因为在这里的“概率”指的是**概率的期望**，即所有情况下的概率平均值。

用只维护颜色的数量得到的结果乘上所有情况下的概率平均值，从而得到的概率，等价于取所有情况下的结果乘以对应概率的平均值。

现在就可以试图证明 $\dfrac{k(k-1)}{n^2}$ 这个概率的正确性了，先给这些颜色打上标号 $1 \sim k$，而不是 $1 \sim n$，再忽略颜色的排列状态，例如 `1 1 4` 和 `4 1 1` 等价，这样不会出现问题，因为现在在算概率的期望，此处概率的期望等于概率总和除以总数。

考虑钦定**恰好**有 $i$ 个颜色在画种恰好出现 $1$ 次。

对于每个 $i$，先在 $k$ 个颜色中选出 $i$ 个颜色，再确定剩下的颜色的方案数，此时为了使颜色减一，第二个选的下标 $j$ 必定是这 $i$ 个颜色之一，第一个下标只要不等于 $j$ 就行，此时概率为 $\dfrac{i(n-1)}{n^2}$。

关于颜色划分总数和选完 $i$ 个颜色后的方案数，使用插板法，颜色划分总数相当于在 $n-1$ 个位置中间插 $k-1$ 个板，计算方案数时要注意**不能再让某个颜色只出现一次**，所以对剩下的 $k-i$ 个颜色都默认已经出现 $1$ 次，再转换为 $n-k-1$ 个位置插 $k-i-1$ 个板的问题。据此推出公式：

$$\frac{1}{\binom{n-1}{k-1}}\sum \limits_{i=1}^{k-1} \dfrac{i(n-1)}{n^2}\dbinom{k}{i}\dbinom{n-k-1}{k-i-1}$$

在这里可能会出现 $n=k$ 的情况，导致组合数未定义，因为 $n=k$ 时就是 $n$ 个不同的数，使得颜色个数发生变化只要选任意两个不同的下标即可，概率为 $\dfrac{n(n - 1)}{n^2}$，等于公式，下文只讨论 $n>k$ 情况。

将里面的常数提出来，变成：

$$\frac{n-1}{n^2\binom{n-1}{k-1}}\sum \limits_{i=1}^{k-1} i\dbinom{k}{i}\dbinom{n-k-1}{k-i-1}$$

要证这个式子等于 $\dfrac{k(k-1)}{n^2}$，列出等式：

$$\frac{n-1}{n^2\binom{n-1}{k-1}}\sum \limits_{i=1}^{k-1} i\dbinom{k}{i}\dbinom{n-k-1}{k-i-1} = \dfrac{k(k-1)}{n^2}$$

两边同乘 $n^2$，把左边的 $\dbinom{n-1}{k-1}$ 乘到右边，$n-1$ 除到右边，变为证：


$$\sum \limits_{i=1}^{k-1} i\dbinom{k}{i}\dbinom{n-k-1}{k-i-1} = \dfrac{k(k-1)}{n}\dbinom{n-1}{k-1}$$

考虑左侧求和部分：

$$\sum \limits_{i=1}^{k-1} i\dbinom{k}{i}\dbinom{n-k-1}{k-i-1}$$

利用恒等式 $i\dbinom{k}{i}=k\dbinom{k-1}{i-1}$，代入后变为：

$$k \sum \limits_{i=1}^{k-1}\dbinom{k-1}{i-1}\dbinom{n-k-1}{k-i-1}$$

此时将这个式子和等式右侧同除 $k$，令 $j=i-1$，左侧式等于：

$$\sum \limits_{j=0}^{k - 2}\dbinom{k-1}{j}\dbinom{n-k-1}{k-j-2}$$

令 $a=k-1$, $b=n-k-1$，求和内容变为：

$$\sum \limits_{j = 0}^{k - 2}\dbinom{a}{j}\dbinom{b}{a-j-1}$$

利用 Vandermonde 恒等式的变形，

$$\sum \limits_{j} \dbinom{a}{j}\dbinom{b}{c-j}=\dbinom{a+b}{c}$$

带入左侧式：

$$\sum \limits_{j=0}^{a-1}\dbinom{a}{j}\dbinom{b}{(a-1)-j}=\dbinom{a+b}{a-1}$$

恰好在非 $0$ 的求和范围之内。因为 $a=k-1$, $b=n-k-1$，所以左侧式等于 $\dbinom{n-2}{k-2}$。

变为证明：$\dbinom{n-2}{k-2} = \dfrac{k-1}{n}\dbinom{n-1}{k-1}$

$k<2$ 时由于未定义需要单独考虑，先考虑 $k \geq 2$ 情况，将左右侧展开，左侧式子为：

$$\dbinom{n-2}{k-2} = \dfrac{(n-2)!}{(k-2)!(n-k)!}$$

右侧式子为：

$$\dfrac{k-1}{n}\dbinom{n-1}{k-1} = \dfrac{(k-1)(n-1)!}{(n-1)(k-1)!(n-k)!}=\dfrac{(n-2)!}{(k-2)!(n-k)!}$$

两侧式子相等。

考虑 $k<2$ 情况，即 $k=1$，左侧求和范围为 $1 \sim 0$，所以左侧式子为 $0$，右侧内容也为 $0$，证毕。

---

## 作者：huangrenheluogu (赞：7)

### 简要题意

开始是一个 $1\sim n$ 的排列，每次等概率、随机选 $i,j\in[1,n],i,j\in\mathbb{N}$，然后 $a_i=a_j$。

问 $t$ 次后大于等于 $k$ 种数的概率。

### 题解

首先，$t$ 很大，达到了 $10^{18}$ 级别，矩阵乘法显然。

考虑维护状态，如果维护每一个数有多少个，有 $10^{10}$ 的空间，显然不可行。

发现一个性质，**只需要记录每一个数有多少个，并且不用关心是哪一种数有多少个**。

举个例子，`1 1 2 2 3` 和 `2 2 5 7 5` 在我们认为是一样的，因为都是有 $2$ 种数字有 $2$ 个，$1$ 种数字有 $1$ 个。

所以，只需要记录每一种有数字有多少个就好了。

我们可以从小到大排序，把每一个数有多少个进行一个状压（直接用十进制，反正比较小）。

状态总数是一个插板问题，$\sum\limits_{i=1}^{n-1}C_{n-1}^{i-1}$，最大值当 $n=10$ 的时候取到最大值为 $2^{9}-1$，给一个巧算的方法，看成集合里取子集，每个元素可以取或者不取，总共 $2^{n-1}$ 种方法，注意没有切 $n-1$ 刀，所以就是 $2^9-1$。

复杂度 $O(511^3\times\log t)$，显然无法通过。

发现记录每一种数字有多少个也没有关系，比如我们第 $i$ 种数字有 $cnt_i$ 个，我们统计的只是 $cnt$ 序列单调递增的就行了，因为**数字变一下是没有关系的**。

那么，有多少种呢？

感觉不是很多，~~手枚一下~~。

```
1 : 1 1 1 1 1 1 1 1 1 1
2 : 1 1 1 1 1 1 1 1 2 
3 : 1 1 1 1 1 1 1 3  
4 : 1 1 1 1 1 1 2 2  
5 : 1 1 1 1 1 1 4   
6 : 1 1 1 1 1 2 3    
7 : 1 1 1 1 2 2 2   
8 : 1 1 1 1 1 5    
9 : 1 1 1 1 2 4    
1: 1 1 1 1 3 3    
11: 1 1 1 2 2 3    
12: 1 1 2 2 2 2    
13: 1 1 1 1 6     
14: 1 1 1 2 5     
15: 1 1 1 3 4     
16: 1 1 2 2 4     
17: 1 1 2 3 3     
18: 1 2 2 2 3     
19: 2 2 2 2 2
20: 1 1 1 7      
21: 1 1 2 6      
22: 1 1 3 5      
23: 1 1 4 4      
24: 1 2 2 5      
25: 1 2 3 4      
26: 1 3 3 3      
27: 2 2 2 4      
28: 2 2 3 3      
29: 1 1 8        
30: 1 2 7       
31: 1 3 6        
32: 1 4 5       
33: 2 2 6       
34: 2 3 5        
35: 2 4 4       
36: 3 3 4        
37: 1 9        
38: 2 8        
39: 3 7        
40: 4 6        
41: 5 5      
42: 10       
```

上面是真的手枚的 $n=10$ 的情况（除了我一开始把第 $19$ 个落下了）。

所以我们可以写出代码：

大家可以手枚 $n=1,2,3,4,5,6,7,8,9$ 的情况，然后手动分类讨论一下就好了。

复杂度最大 $O(42^3\times\log t)$，可以通过。

不放代码。

----------------------------

这个代码一看就又臭有长，难写难调浪费时间，~~不放的原因是我没写~~。

而写手枚容易错。

那就用程序啊。

程序的作用不仅仅打标，还可以处理出转移矩阵。

用程序进行 bfs，遇到一个没遇到的就入队，只要搜到的，就加上贡献。

最后都除以 $n^2$，就是乘上逆元。

然后代码就写好了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int n, t, k, inv, a[15], sum[45], H, T, now, S, res, num[45], cnt[15], tem, tt;
map<int, int>f;
struct martix{
	int a[45][45];
	martix(){
		memset(a, 0, sizeof(a));
	}
	inline void init(){
		for(int i = 1; i <= T; i++) a[i][i] = 1;
	}
	inline void print(){
		for(int i = 1; i <= T; i++){
			for(int j = 1; j <= T; j++){
				printf("%lld ", a[i][j]);
			}
			putchar('\n');
		}
	}
}base, ans;
inline int qp(int x, int y){
	int res = 1;
	while(y){
		if(y & 1) res = res * x % mod;
		x = x * x % mod, y >>= 1;
	}
	return res;
}
inline martix operator * (martix x, martix y){
	martix res;
	for(int i = 1; i <= T; i++){
		for(int k = 1; k <= T; k++){
			if(x.a[i][k] == 0) continue ;
			for(int j = 1; j <= T; j++){
				res.a[i][j] += x.a[i][k] * y.a[k][j] % mod;
				res.a[i][j] %= mod;
			}
		}
	}
	return res;
}
inline int calc(int x){
	S = 0; 
	for(int i = 1; x; i++){
		cnt[i] = x % 10;
		S++;
		x /= 10;
	}
	now = 0;
	for(int i = 1; i <= S; i++){
		for(int j = 1; j <= cnt[i]; j++){
			a[++now] = i;
		}
	}
	return S;
}
inline int work(){
	for(int i = 1; i <= 10; i++) sum[i] = 0;
	for(int i = 1; i <= n; i++) sum[a[i]]++;
	int res = 0;
	sort(sum + 1, sum + 11);
	for(int i = 1; i <= 10; i++){
		res = res * 10 + sum[i];
	}
	return res;
}
inline void bfs(){
	for(int i = 1; i <= n; i++) a[i] = i;
	tem = work();
	f[tem] = 1;
	num[T = 1] = tem;
	while(H < T){
		H++;
		calc(num[H]);
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= n; j++){
				tt = a[j];
				a[j] = a[i];
				tem = work();
				if(f[tem] == 0){
					f[tem] = ++T;
					num[T] = tem;
				}
				base.a[H][f[tem]]++;
				a[j] = tt;
			}
		}
	}
}
inline martix ksm(martix x, int y){
	martix res;
	res.init();
	while(y){
		if(y & 1) res = res * x;
		x = x * x, y >>= 1;
	}
	return res;
}
signed main(){
	scanf("%lld%lld%lld", &n, &t, &k);
	inv = qp(n * n, mod - 2);
	bfs();
	for(int i = 1; i <= T; i++) for(int j = 1; j <= T; j++) base.a[i][j] = base.a[i][j] * inv % mod;
	base = ksm(base, t);
	ans.a[1][1] = 1;
	ans = ans * base;
	for(int i = 1; i <= T; i++){
		if(calc(num[i]) >= k){
			res += ans.a[1][i];
			res %= mod;
		}
	}
	printf("%lld", res);
	return 0;
} 
```

如果不懂，可以评论/私信。

---

## 作者：船酱魔王 (赞：6)

## 题意回顾

一个长度为 $ n $ 的数组 $ a $，每次等概率随机选定 $ 1 \le i,j \le n $ 进行操作 $ a_i \leftarrow a_j $，请问在进行完 $ t $ 次操作后数组元素种类数大于等于 $ k $ 的概率对质数 $ 10^9 + 7 $ 取模的结果。

$ 2 \le k \le n \le 10 $，$ 1 \le t \le 10^{18} $。

## 分析

注意到一个数组的元素种类数，与赋值操作的等概率随机性不会受数组元素的排列顺序的影响，因为每个元素位置在操作和统计中都是平等的。

进一步地，我们只关心颜色可以分为哪些类，每组有几个位置，不关心每类的颜色是哪个元素的初始颜色（因为最后只关心种类数）。而类之间因为是等价的，则可以将这个状态表示中每类的颜色个数强制排序，避免无用状态重复出现。此时状态数为 $ 10 $ 的无序拆分，有 $ 42 $ 种。

此时，因为是一个常系数齐次线性递推（无向图有限次随机游走模型），我们考虑暴力计算每个状态向另一个状态的转移系数，然后跑矩阵快速幂即可。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
#define ll long long
using namespace std;
const int MOD = 1e9 + 7;
map<vector<int>, int> mp;
map<int, vector<int> > gt;
int n, k;
ll t;
vector<int> mat4;
int tq = 0;
void dfs(vector<int> vec, int fin, int sum) {
    if(sum == n) {
        mp[vec] = ++tq;
        gt[tq] = vec;
        //cout << tq << " " << endl;
        //for(int i = 0; i < vec.size(); i++) cout << vec[i] << " ";
        //cout << endl;
        return;
    }
    for(int i = fin; i <= n; i++) {
        if(sum + i <= n) {
            vec.push_back(i);
            dfs(vec, i, sum + i);
            vec.pop_back();
        }
    }
}
struct matrix {
    int num[43][43];
} zero;
matrix operator*(matrix p1, matrix p2) {
    matrix res = zero;
    for(int i = 1; i <= tq; i++) {
        for(int j = 1; j <= tq; j++) {
            for(int k = 1; k <= tq; k++) {
                res.num[i][j] += (ll)p1.num[i][k] * p2.num[k][j] % MOD;
                res.num[i][j] %= MOD;
            }
        }
    }
    return res;
}
int ksm(int x, int y) {
    if(y <= 1) return y ? x : 1;
    int ktm = ksm(x, y >> 1);
    return (ll)ktm * ktm % MOD * ((y & 1) ? x : 1) % MOD;
}
int main() {
    scanf("%d%lld%d", &n, &t, &k);
    dfs(mat4, 1, 0);
    matrix mat2 = zero;
    for(int fm = 1; fm <= tq; fm++) {
        vector<int> vec = gt[fm];
        for(int pi = 0; pi < vec.size(); pi++) {
            for(int pj = 0; pj < vec.size(); pj++) {
                vector<int> ec = vec;
                ec[pi]++;
                ec[pj]--;//mat3, mat4
                if(ec[pj] == 0) swap(ec[pj], ec[ec.size() - 1]), ec.pop_back();
                sort(ec.begin(), ec.end());
                mat2.num[fm][mp[ec]] += vec[pi] * vec[pj];
            }
        }
    }
    matrix mat3 = zero;
    mat3.num[1][1] = 1;
    matrix mat1 = mat2;
    while(t) {
        if(t & 1) mat3 = mat3 * mat1;
        mat1 = mat1 * mat1, t >>= 1;
    }
    int ansp, ansq;
    ansp = ansq = 0;
    for(int ek = 1; ek <= tq; ek++) {
        if(gt[ek].size() >= k) ansp += mat3.num[1][ek], ansp %= MOD;
        ansq += mat3.num[1][ek], ansq %= MOD;
    }
    printf("%d\n", (int)((ll)ansp * ksm(ansq, MOD - 2) % MOD));
    return 0;
}
```

---

## 作者：xs_siqi (赞：3)

神仙 dp。

首先注意到一个性质：$n,k$ 很小，$T$ 很大。那么我们主要的部分肯定是要基于 $n,k$ 很小的这个性质的。

---

注意：下面分割线内的无关正解，只是解释了某种优化思路是走不通的，赶时间的可以跳过，不过看了这部分可能更顺。

一开始我的想法是能否把颜色的数量这个东西也舍弃掉，这样就能做到不基于 $T$ 来做。我们把这个东西拆成两部分，一部分叫做“无用转移”，就是不会损失颜色的转移，一部分叫做“有用转移”，会损失颜色的转移。不会损失颜色形如从重复的颜色重拿出一些颜色，这个东西可以简单用组合数表达。形式化地，假设我们目前有 $i$ 个颜色，总共有 $n$ 个格子，那么我们就有 $C_n^{n-i}$ 种无用转移的方案数。

但是我们发现有用转移不一样了，这个东西的转移是必须要用到“数量”这个概念的。因为可能出现形如下面这类情况：

```
case 1:
col: 1 2 3 4 5 6 7
num: 3 2 2 2 2 2 1

case 2:
col: 1 2 3 4 5 6 7
num: 4 2 2 2 2 1 1
```

这个时候如果你只记录了数量总和和颜色总和那会变的相当不可做。为啥呢？看到第一组，你发现，只有把第七个颜色涂成其他颜色能使颜色减少，而第二组，却既可以把第六个颜色也可以把第七个颜色涂成其他的，使颜色数减少。

但是这个时候你记录的颜色总量是一样的。所以这是难以转移的。

---

这个时候我们考虑更换方向。能否基于 $T$，但是以 $\log$ 级别的效率来做？

我们先考虑 $n,k\leq 3,T\leq 1000$ 怎么做。这个时候我们直接暴力把所有状态拓展出来，朴素 dp 即可。

我们发现第一个瓶颈是，状态数过多。这个时候的一般解决思路是，压缩状态。我们大家肯定都做过一道题叫做[一双木棋](https://www.luogu.com.cn/problem/P4363)。这道题采用记忆化的形式将状态存入 `map`，压缩了很多不必要的状态。我们考虑也这样来解决这个问题。

可惜的是这题难以找出这种不必要的状态。那么我们考虑有哪些状态是本质相同的。这个时候我们发现编号不那么重要。换句话说，我们只关心颜色是否相同，而不关心哪个地方具体是什么颜色。以及，此时颜色的数量是多少。

压缩完以后，使用暴力 dfs 跑了一下状态数。惊人的是，$n=10$ 时，只有 $42$ 个状态！

其实，对于不同的 $n$，状态数是有规律的。具体详见文章的最末尾。

我们肯定都做过一道题叫做 [Cow Relays G](https://www.luogu.com.cn/problem/P2886)。那么我们不难想到使用矩阵快速幂来优化这个过程。具体地，我们维护两个状态之间的期望值，然后转移也正类似于朴素矩阵快速幂的转移。

```cpp
friend matrix operator * (matrix x,matrix y){
	matrix z;z.cl();
	for(int i=1;i<maxn;i++)
		for(int j=1;j<maxn;j++)
			for(int k=1;k<maxn;k++)
				(z.a[i][j]+=1ll*x.a[i][k]*y.a[k][j]%mod)%=mod;
	return z;
}
```
这个部分中间的符号是乘法的原因是，假设你从一个状态通过一个中介状态转移到另一个状态，相当于你从一个阶段，走到另一个阶段，再走到最后阶段，而每个阶段都有若干选择。这个东西符合乘法原理。

这道题的思路大致是这样。但是这题的实现也不简单，所以讲一些实现上的难点。

首先，判断状态是否被用过。我们既可以维护一个 `vector` 表示状态，状态就是各个颜色的数量各是多少。

然后直接把这个东西放到 `map` 里。或者写个双哈希再放到 `map` 里也可以，我选择了后者（主要是因为不会写 `vector` 塞到 `map` 里的 `cmp` 函数）。

其次，如何判断最后哪些状态是可取的。这个东西显然是不可重的，所以这个时候我们就很好的可以使用一个 `set` 在求两个状态之间的期望的时候求出来。具体地，如果枚举到某个状态的颜色数大于等于 $m$，那么这个状态就是合法的，我们就可以把它统计进来。

放一个比较丑的实现。

```cpp
#pragma GCC optimize(3,"Ofast")
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int maxn=45;
const int mod1=1011451423;
const int p1=11;
const int mod2=998244353;
const int p2=13;
const int mod=1e9+7;
int n,cnt,m,ni,ans;
long long T;
vector<int> a;
set<int> gr;
struct matrix{
	int a[maxn][maxn];
	void cl(){
		for(int i=1;i<maxn;i++)
			for(int j=1;j<maxn;j++)
				a[i][j]=0;
	}
	void my(){
		for(int i=1;i<maxn;i++)
			a[i][i]=1;
	}
	friend matrix operator * (matrix x,matrix y){
		matrix z;z.cl();
		for(int i=1;i<maxn;i++)
			for(int j=1;j<maxn;j++)
				for(int k=1;k<maxn;k++)
					(z.a[i][j]+=1ll*x.a[i][k]*y.a[k][j]%mod)%=mod;
		return z;
	}
}s;
struct has{
	int ha1,ha2;
	friend bool operator < (has x,has y){
		return x.ha1==y.ha1?x.ha2<y.ha2:x.ha1<y.ha1;
	}
};
int qpow1(int a,int p){
	int ans=1;
	while(p){
		if(p&1)ans=1ll*ans*a%mod;
		a=1ll*a*a%mod;
		p>>=1;
	}
	return ans;
}
matrix qpow2(matrix a,long long p){
	matrix ans;
	ans.cl(),ans.my();
	while(p){
		if(p&1)ans=ans*a;
		a=a*a;
		p>>=1;
	}
	return ans;
}
map<has,int> M;
struct node{
	vector<int> a;
}q[maxn];
has ha(int uh,vector<int> g){
	int ha1=0,ha2=0;
	for(int i=0;i<uh;i++){
		ha1=(1ll*ha1*p1%mod1+g[i])%mod1;
		ha2=(1ll*ha2*p2%mod2+g[i])%mod2;
	}
	return (has){ha1,ha2};
}
void bfs(){
	vector<int> st;
	for(int i=1;i<=n;i++)st.pb(1);
	has p=ha(n,st);
	M[p]=++cnt;
	if(n>=m)gr.insert(M[p]);
	int h=1,t=0;
	q[++t]=(node){st};
	while(h<=t){
		vector<int> u=q[h++].a;
		int len=u.size();
		int hau=M[ha(len,u)];
		for(int i=0;i<len;i++){
			for(int j=0;j<len;j++){
				if(i==j){
					(s.a[hau][hau]+=(1ll*u[i]*u[i]%mod*ni%mod))%=mod;
					continue;
				}
				vector<int> np;
				for(int k=0;k<len;k++)
					if(k!=i&&k!=j)np.pb(u[k]);
				if(u[i]>1)np.pb(u[i]-1);
				np.pb(u[j]+1);
				sort(np.begin(),np.end());
				has r=ha(np.size(),np);
				if(!M[r])M[r]=++cnt,q[++t].a=np;
				int hav=M[r];
				if(np.size()>=m)gr.insert(hav);
				(s.a[hau][hav]+=1ll*u[i]*u[j]%mod*ni%mod)%=mod;
			}
		}
	}
}
int main(){
	scanf("%d%lld%d",&n,&T,&m);
	ni=qpow1(n*n,mod-2);bfs();
	matrix sum;
	sum.cl(),sum.a[1][1]=1;
	sum=sum*qpow2(s,T);
	while(!gr.empty()){
		auto y=gr.begin();
		int k=*y;
		gr.erase(k);
		(ans+=sum.a[1][k])%=mod;
	}
	printf("%d\n",ans);
	return 0;
}
```

说一下对于 $n$ 状态数的规律。是 OEIS 找到的，我不会证明。如果有很强的大神会证可以发评论区之类的。

$$f_i=\dfrac{\sum_{j=0}^{i-1} g_{i-j}\times j}{i}$$

其中 $f_i$ 表示 $n=i$ 时的状态数，$g_x$ 表示 $x$ 的所有正因数之和。

---

## 作者：e4fsrc2e4fsrc2 (赞：2)

## [Bojanje](https://www.luogu.com.cn/problem/P9174)
## 思路分析
- 对第一个子任务，为了不减少不同颜色的数量，Oliver 必须在这两个步骤中选择相同的部分。这种情况每次迭代发生的概率是 $n\times (\frac1n)^2=\frac1n$，在 $t$ 次迭代后就是 $(\frac1n)^t$。

- 第二个子任务可以通过动态规划来解决。
- $n$ 非常的小，可以使用每种颜色存在的个数数组 $cnt$ 表示每种状态。
- 注意到不同颜色对计算不同颜色的个数是一样的，例如状态 $cnt[2, 4, \cdots]$ 和状态 $cnt[4, 2,\cdots]$ 是一样的，所以将状态定义为不同颜色存在次数的排序数组，从而减少状态的数量，如状态 $[2, 5, 3, 0, \cdots, 0]$ 改为 $[2, 3, 5, 0, \cdots , 0]$。
- 初始化状态为 $cnt_i = 1(i \in [1, n])$，然后通过记忆化搜索，将
所有的状态之间进行转换的概率都预处理出来。
- 定义 $f_{i,j}$ 表示的是状态 $i$ 转移到状态 $j$ 的概率。我们重复转移 $t$ 次，即 $f^t$，然后对初始状态到至少由 $k$ 种颜色的状态的所有概率求和即为答案。
- 对于最后一个子任务，$f^t$，$t$ 很大，直接使用矩阵快速幂即可。

---

## 作者：_zzzzzzy_ (赞：0)

通过读题可知是 dp 题，考察的是对状态的压缩，题目说 $n$ 种颜色我们不能记录下每个小球的颜色，由于取球是随机的，所以位置是不重要的，我们就可以对每种颜色记录有几个，因为我们对于每种颜色具体是什么也不关心，只关心有几个球，所以可以进一步压缩。

```cpp
vector<vector<int>> S;
vector<int> vec;
map<vector<int>, int> mp;
void dfs(int x) {
  if (x == 0) {
    S.push_back(vec);
    mp[vec] = S.size() - 1;
    return;
  }
  if (vec.size() && vec.back() > x) {
    return;
  }
  rep(i, (vec.size() ? vec.back() : 1), x) {
    vec.push_back(i);
    dfs(x - i);
    vec.pop_back();
  }
}
```

类似的压缩套路还有 AT_abc215_g。

然后我们按照状态转移可以拿到 sub2 36 分，拼上 sub1 就能拿到 64 分。

```cpp
#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = (l); i <= (int)(r); i++)
#define per(i, l, r) for (int i = (r); i >= (int)(l); i--)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define max(a, b)  (!((a) < (b)) ? (a) : (b))
#define min(a, b)  ((a) < (b) ? (a) : (b))
using namespace std;
using i64 = long long;
#define int i64
const int maxn = 1000050, mod = 1e9 + 7, B = 700;
i64 power(i64 a, int b) {
  i64 res = 1;
  for (; b; a = (a * a) % mod, b /= 2){
    if (b % 2 == 1) {
      res = (res * a) % mod;
    }
  }
  return res;
}
vector<vector<int>> S;
vector<int> vec;
map<vector<int>, int> mp;
void dfs(int x) {
  if (x == 0) {
    S.push_back(vec);
    mp[vec] = S.size() - 1;
    return;
  }
  if (vec.size() && vec.back() > x) {
    return;
  }
  rep(i, (vec.size() ? vec.back() : 1), x) {
    vec.push_back(i);
    dfs(x - i);
    vec.pop_back();
  }
}
vector<int> change(vector<int> now, int a, int b) {
  vector<int> to = now;
  if (a == b) {
    return to;
  }
  if (now[a] != 1) {
    to[a]--;
    to[b]++;
  }
  if (now[a] == 1) {
    to[b]++;
    to.erase(to.begin() + a);
  }
  sort(to.begin(), to.end());
  return to;
}
int dp[1050][100];
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);

  int n, t, k;
  cin >> n >> t >> k;
  dfs(n);
  dp[0][0] = 1;
  int INV = power(n * n, mod - 2);
  rep(i, 1, t) {
    rep(j, 0, S.size() - 1) {
      if (dp[i - 1][j] == 0) {
        continue;
      }
      dp[i - 1][j] %= mod;
      vector<int> st = S[j];
      rep(a, 0, st.size() - 1) {
        rep(b, 0, st.size() - 1) {
          vector<int> nst = change(st, a, b);
          dp[i][mp[nst]] += dp[i - 1][j] * st[a] % mod * st[b] % mod * INV % mod;
        }
      }
    }
  }
  int ans = 0;
  rep(i, 0, S.size() - 1) {
    if (S[i].size() >= k) {
      ans += dp[t][i];
    }
  }
  cout << ans % mod << "\n";
  return 0;
}
```

然后的是套路的矩阵乘法优化。

```cpp
#include <bits/stdc++.h>

#define rep(i, l, r) for (int i = (l); i <= (int)(r); i++)
#define per(i, l, r) for (int i = (r); i >= (int)(l); i--)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define max(a, b)  (!((a) < (b)) ? (a) : (b))
#define min(a, b)  ((a) < (b) ? (a) : (b))
using namespace std;
using i64 = long long;
#define int i64
const int maxn = 1000050, mod = 1e9 + 7;
i64 power(i64 a, int b) {
  i64 res = 1;
  for (; b; a = (a * a) % mod, b /= 2){
    if (b % 2 == 1) {
      res = (res * a) % mod;
    }
  }
  return res;
}
vector<vector<int>> S;
vector<int> vec;
map<vector<int>, int> mp;
void dfs(int x) {
  if (x == 0) {
    S.push_back(vec);
    mp[vec] = S.size() - 1;
    return;
  }
  if (vec.size() && vec.back() > x) {
    return;
  }
  rep(i, (vec.size() ? vec.back() : 1), x) {
    vec.push_back(i);
    dfs(x - i);
    vec.pop_back();
  }
}
vector<int> change(vector<int> now, int a, int b) {
  vector<int> to = now;
  if (a == b) {
    return to;
  }
  if (now[a] != 1) {
    to[a]--;
    to[b]++;
  }
  if (now[a] == 1) {
    to[b]++;
    to.erase(to.begin() + a);
  }
  sort(to.begin(), to.end());
  return to;
}
struct node {
  int a[50][50];
  int n, m;
} A, B1, B;
node mul(node a, node b) {
  node c = {{}};
  c.n = a.n, c.m = b.m;
  rep(i, 0, a.n - 1) {
    rep(j, 0, b.m - 1) {
      rep(k, 0, a.m - 1) {
        c.a[i][j] += a.a[i][k] * b.a[k][j] % mod;
      }
      c.a[i][j] %= mod;
    }
  }
  return c;
}
int n, t, k;
void initB() {
  int INV = power(n * n, mod - 2);
  rep(i, 0, S.size() - 1) {
    vector<int> st = S[i];
    rep(a, 0, st.size() - 1) {
      rep(b, 0, st.size() - 1) {
        vector<int> nst = change(st, a, b);
        (B.a[mp[nst]][i] += st[a] * st[b]  * INV % mod) %= mod;
      }
    }
  }
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);

  cin >> n >> t >> k;
  dfs(n);
  A.n = S.size();
  A.m = 1;
  B.n = B.m = S.size();
  initB();
  A.a[0][0] = 1;
  t-=1;
  B1 = B;
  for (; t; B1 = mul(B1, B1), t /= 2){
    if (t % 2 == 1) {
      B = mul(B, B1);
    }
  }
  A = mul(B, A);
  int ans = 0;
  rep(i, 0, S.size() - 1) {
    if ((int)S[i].size() >= k) {
      ans += A.a[i][0];
    }
  }
  cout << ans % mod << "\n";
  return 0;
}
```

---

## 作者：huhangqi (赞：0)

题目要求我们求出至少有 $k$ 个不同颜色的概率。

处理概率问题很容易想到 dp 处理，并且问题中的 $n$ 很小，但是转移次数 $t$ 很大，明显是一个矩阵乘法优化 dp 的问题。

那么方法有了就可以考虑转移式了。

如果按照常规的思路，以 $dp_i$ 表示包含 $i$ 种不同颜色的概率明显是不行的，因为有 $i$ 种不同颜色其中包含了多种情况，并且其中的每一种情况转移到另一种情况概率不一定是相同的，而且这些不同的情况分布并不均匀，所以无法直接得到答案。

那么既然在一个状态里面含有多种情况，那么我们完全可以把这个状态拿出来。

我们给每种情况记录一个编号，开始时先处理出每一种可以转移到的情况，然后继续搜索，将转移方式记录到矩阵中。

最后直接矩阵快速幂即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,t,k,ys,id,a[15],b[15];
map<int,int> mp;
bool vis[55];
vector<int> ans;
struct MT{
	int n,m,c[55][55];
	MT(){
		memset(c,0,sizeof(c));
		n=m=0;
	}
	MT friend operator*(MT a,MT b){
		MT c;
		c.n=a.n,c.m=b.m;
		for(int i=1;i<=a.n;i++){
			for(int j=1;j<=b.m;j++){
				for(int k=1;k<=a.m;k++){
					c.c[i][j]+=a.c[i][k]*b.c[k][j]%mod;
					c.c[i][j]%=mod;
				}
			}
		}
		return c;
	}
}be,base;
void jzksm(int b){
	while(b){
		if(b&1)be=be*base;
		base=base*base;
		b>>=1;
	}	
}
int ksm(int a,int b){
	int x=a,s=1;
	while(b){
		if(b&1)s=(s*x)%mod;
		x=(x*x)%mod;
		b>>=1;
	}
	return s;
}
void bfs(){
	queue<int> q;
	int s=0;
	for(int i=1;i<=n;i++)s=s*11+1;
	q.push(s);
	mp[s]=1;
	id=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		if(vis[mp[u]])continue;
		vis[mp[u]]=1;
		int tmp=u,sum=0;
		for(int i=1;i<=n;i++)a[i]=tmp%11,tmp/=11;
		for(int i=1;i<=n;i++)if(a[i])sum++;
		if(sum>=k)ans.push_back(mp[u]);
		for(int i=1;i<=n;i++){
			if(!a[i])continue;
			for(int j=1;j<=n;j++){
				if(!a[j])continue;
				for(int k=1;k<=n;k++)b[k]=a[k];
				b[i]--,b[j]++;
				sort(b+1,b+n+1);
				int s=0;
				for(int k=n;k>=1;k--)s=s*11+b[k];
				if(mp[s])base.c[mp[u]][mp[s]]+=a[i]*a[j]%mod;
				else {
					mp[s]=++id;
					q.push(s);
					base.c[mp[u]][id]+=a[i]*a[j]%mod;
				}
			}
		}
	}
}
signed main(){
	cin>>n>>t>>k;
	ys=ksm(n*n,mod-2);
	bfs();
	be.n=1,be.m=id;
	be.c[1][1]=1;
	base.n=base.m=id;
	for(int i=1;i<=id;i++){
		for(int j=1;j<=id;j++){
			base.c[i][j]=base.c[i][j]*ys%mod;
		}
	}
	jzksm(t);
	int res=0;
	for(int i:ans){
		res+=be.c[1][i];
		res%=mod;
	}
	cout<<res;
	return 0;
}

``````

---


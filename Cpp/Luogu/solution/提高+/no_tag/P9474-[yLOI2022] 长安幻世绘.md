# [yLOI2022] 长安幻世绘

## 题目背景

> 长安广月晴，留身影，琵琶行，酒客半醒。  
> 问你看不清，朱纱帐，翠丝绦，飞天降临。  
> 美人腰肢半倾璎珞脆，纤手独举琵琶跪，眸眼还生魅。  
> 麝香抹唇酒更醉，醉灯彩越乱越美。

——银临《长安幻世绘》

## 题目描述

共有 $n$ 个彩灯从左到右排成一排，从左到右用 $1$  到 $n$ 编号，第 $i$ 个彩灯的亮度是 $a_i$。对 $1 \leq i < n$，我们说 $i$ 号彩灯和 $i + 1$ 号彩灯是相邻的。

我们保证这 $n$ 盏灯的亮度**互不相同**。

一组彩灯的**和谐度**定义为这组彩灯中亮度最大和最小的两盏彩灯的亮度之差。

扶苏想从这 $n$ 个彩灯中选出 $m$ 个**互不相邻**的彩灯作为一组，她希望这组彩灯的和谐度**尽可能小**。请你帮她求出这个最小值。

形式化地，你需要在元素互不相同的数列 $a$ 中选出一个长度为 $m$ 的元素互不相邻的子列，使得子列的极差最小。


## 说明/提示

### 样例 1 解释

只能选择第 $1, 3, 5$ 个彩灯。因为其他的选法都会导致有灯相邻。

### 样例 2 解释

可以选择第 $2, 4, 6$ 个彩灯，彩灯的亮度是 $7, 3, 6$，其极差是 $4$。

### 数据规模与约定

- 对 $12\%$ 的数据，保证 $n \leq 6$。
- 对 $36\%$ 的数据，保证 $n \leq 100$。
- 另有 $4\%$ 的数据，保证 $m = \lceil\frac{n}{2}\rceil$。
- 另有 $12\%$ 的数据，保证 $a_i$ 单调递增。
- 对 $76\%$ 的数据，保证 $n \leq 10^3$。
- 对 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq \lceil\frac{n}{2}\rceil$，$1 \leq a_i \leq 10^9$，$a_i$ 互不相同。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5```

### 输出

```
4```

## 样例 #2

### 输入

```
6 3
1 7 8 3 4 6```

### 输出

```
4```

## 样例 #3

### 输入

```
见附加文件中的 D3.in```

### 输出

```
见附加文件中的 D3.ans```

# 题解

## 作者：未来姚班zyl (赞：57)

## 题目大意
在长度为 $n$ 的，元素互不相同的数列 $a$ 中选出一个长度为 $m$ 的元素互不相邻的子列，使得子列的极差最小。

$1\le n\le 10^5$。

## 题目分析

- 我会暴力！

枚举每个数是否被选，然后判断是否合法，合法就求个极差，记录过程中的最小值，复杂度 $O(2^n n)$。

期望得分 $12$ 分。

- 我会 dp！

设状态 $dp_{i,j,k,0/1}$ 表示前 $i$ 个数中，已经选了 $j$ 个数，最小值为 $a_k$，且没选（$0$）或者选了（$1$）$a_i$ 时，被选数的最大值的最小值，转移只需要按照题意转移一下就行了，复杂度 $O(n^2m)$。

期望得分 $36$ 分。

- 我会枚举！

首先一个显然的结论是，如果最大最小值都被固定，则其它数肯定就是值在其中间的数。所以当最大最小值固定时，我们就把不在这个范围内的数忽略，然后看看剩下的数能不能选到 $m$ 个。判断很简单，在没被忽略的数中，会形成若干连续的段，对于长度为 $len$ 的一段，显然可以选 $\lceil \frac{len}{2}\rceil$ 个数，总的数就是每一段可取的数之和。

所以我们可以枚举最大值和最小值，然后遍历一遍数组看看可不可行，在所有可行的方案中找到最小的极差即可，复杂度 $O(n^3)$。

期望得分 $36$ 分。

- 我会二分！

我们可以发现，对于一个最小值，满足条件的最大值是连续的，所以我们可以枚举最小值，然后二分查找满足条件的最小的最大值，统计答案即可，复杂度 $O(n^2\log n)$。

期望得分 $76$ 分。

- 我会线段树和双指针！~~但线段树和双指针好像不是普及组算法，不管了。~~

考虑在 $76$ 分算法上优化。显然，当最小值不断增大时，满足条件的最小的最大值也会跟着增大或不变。因为最小值变大了，就会有更多的数不再能选，这时候就需要更多的数来满足条件。所以，我们可以将数组排好序，用一个左指针从小到大枚举最小值，然后用一个右指针维护最大值，在枚举的过程中，我们先不断右移右指针并不断的添加可选的元素，直到满足条件或者全部选完。然后，删除左指针的元素，同时右移左指针。这个过程中，每个元素最多只会被右指针指到一次，被左指针指到一次，也就最多只会被添加一次与删除一次。

现在要考虑如何添加与删除。借助上述结论，对于长度为 $len$ 的连续段，可以选 $\lceil \frac{len}{2}\rceil$ 个数。在添加一个数时，我们考虑对可选数目的影响。首先考虑添加。

1. 当左右两边都空着时，可选数多一个。

2. 当左右两边有且只有一边已经有一段时，添加一个数会使其 $len$ 增加 $1$。由于对 $2$ 向上取整，所以这一段是偶数时可选数多一个，否则没有影响。

3. 当左右两边都有一段时，设左边长 $l$，右边长 $r$，则这一段变成了 $l+r+1$。通过简单的分类讨论可以得到，只有当 $l$ 和 $r$ 都是偶数时，可选数才能加一。

对于删除，其实就是这三点倒过来。


通过枚举可以使这一部分的复杂度变为 $O(n)$，不过可以用线段树维护一个数所在的段的左右端点，然后支持区间覆盖和单点查询，使其复杂度降到 $O(\log n)$。

总复杂度 $O(n\log n)$。

期望得分 $100$ 分。

~~写得如此全面，留个赞吧 awa。~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define e(x) for(int i=h[x];i;i=nxt[i])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=4e7+5,inf=2147000000;
const ll mod=998244353;
using namespace std;
int n,m,ans=inf,now;
struct node{
	int x,id;
}a[N];
struct seg{
	int l,r,lazl,lazr;
}xd[N*4];
inline void covl(int x,int k){
	xd[x].l=xd[x].lazl=k;
}
inline void covr(int x,int k){
	xd[x].r=xd[x].lazr=k;
}
inline void pushdown(int x){
	if(xd[x].lazl)covl(L,xd[x].lazl),covl(R,xd[x].lazl);
	if(xd[x].lazr)covr(L,xd[x].lazr),covr(R,xd[x].lazr);
	xd[x].lazl=xd[x].lazr=0;
}
inline void modify(int x,int l,int r,int Ll,int Rr,int k,int t){
	if(Ll>Rr)return;
	if(OK){
		if(t==1)covl(x,k);
		else covr(x,k);
		return;
	}
	pushdown(x);
	if(Ll<=mid&&Rr>=l)modify(lc,Ll,Rr,k,t);
	if(Rr>mid&&Ll<=r)modify(rc,Ll,Rr,k,t);
}
inline seg query(int x,int l,int r,int p){
	if(p<1||p>n)return seg{0,0,0,0};
	if(l==r)return xd[x];
	pushdown(x);
	if(p<=mid)return query(lc,p);
	return query(rc,p);
}
inline void insert(int x){
	seg l,r;
	l=query(1,1,n,x-1),r=query(1,1,n,x+1);
	int Ll=l.l,Rr=r.r;
	if(!Ll){
		if(!Rr)modify(1,1,n,x,x,x,1),modify(1,1,n,x,x,x,2),now++;
		else {
			if((Rr-x)%2==0)now++;
			modify(1,1,n,x,x,Rr,2),modify(1,1,n,x,Rr,x,1);
		}
		return;
	}
	if(!Rr){
		if((x-Ll)%2==0)now++;
		modify(1,1,n,x,x,Ll,1),modify(1,1,n,Ll,x,x,2);
		return;
	}
	bool fl=(x-Ll)&1,fr=(Rr-x)&1;
	if(fl==0&&fr==0)now++;
	modify(1,1,n,Ll,Rr,Ll,1),modify(1,1,n,Ll,Rr,Rr,2);	
}
inline void del(int x){
	seg nw=query(1,1,n,x);
	int Ll=nw.l,Rr=nw.r;
	bool fl=(x-Ll)&1,fr=(Rr-x)&1;
	if(fl==0&&fr==0)now--;
	modify(1,1,n,Ll,x-1,x-1,2),modify(1,1,n,x+1,Rr,x+1,1);
	modify(1,1,n,x,x,0,1),modify(1,1,n,x,x,0,2);
}
inline bool cmp(node a,node b){
	return a.x<b.x;
}
int main(){
	n=read(),m=read();
	rep(i,1,n)a[i].x=read(),a[i].id=i;
	sort(a+1,a+n+1,cmp);
	int Rr=1;
	rep(i,1,n){
		while(Rr<=n&&now<m)insert(a[Rr++].id);
		if(now>=m)ans=min(ans,a[Rr-1].x-a[i].x);
		del(a[i].id);
	}
	cout <<ans;
	return 0;
}
```

---

## 作者：251Sec (赞：21)

设 $a$ 从小到大排序后得到的新数组为 $b$。

设可选的灯的亮度最小值为 $b_l$ 时要选出 $m$ 个不相邻的灯，所需要的亮度最大的灯的亮度最小值为 $b_r$。发现 $l$ 增加时 $r$ 单调不降，于是可以双指针。

具体地，从 $1$ 到 $n$ 移动 $l$，每次移动 $l$ 后把 $r$ 向右移动，直到能选出 $m$ 个不相邻的灯。

我们总共会修改 $O(n)$ 次灯的可选状态，并且查询 $O(n)$ 次总可选灯数是否大于等于 $m$。设可选的灯为 `1`，不可选的灯为 `0`。

现在我们抽象出这样一个问题：维护一个数据结构，支持单点修改为 `1` 或 `0`。设一个长度为 $L$ 的极长 `1` 段的贡献为 $\left\lceil\dfrac{L}{2}\right\rceil$，支持查询所有极长 `1` 段的贡献之和。

我们可以用线段树解决这个问题：对每个区间记录左侧和右侧的极长 `1` 段长度，并记录区间内的贡献和，容易验证这个东西支持合并，并且因为只有单点修改我们不需要懒标记。

总时间复杂度 $O(n \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m;
struct SegNode {
    int llen, rlen, val;
} f[400005];
int Calc(int x) { return (x + 1) / 2; }
void Pushup(SegNode &s, const SegNode &ls, const SegNode &rs, int l, int mid, int r) {
    s.llen = ls.llen;
    if (s.llen == mid - l + 1) s.llen += rs.llen;
    s.rlen = rs.rlen;    
    if (s.rlen == r - mid) s.rlen += ls.rlen;
    s.val = ls.val + rs.val - Calc(ls.rlen) - Calc(rs.llen) + Calc(ls.rlen + rs.llen);
}
void Modify(int p, int l, int r, int i, int w) {
    if (l == r) {
        f[p].llen = f[p].rlen = f[p].val = w;
        return;
    }
    int mid = l + r >> 1;
    if (i <= mid) Modify(p << 1, l, mid, i, w);
    else Modify(p << 1 | 1, mid + 1, r, i, w);
    Pushup(f[p], f[p << 1], f[p << 1 | 1], l, mid, r);
}
struct Element {
    int val, id;
    bool operator<(const Element &o) const { return val < o.val; }
} a[100005];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i].val), a[i].id = i;
    sort(a + 1, a + n + 1);
    int res = 1e9;
    int l = 1, r = 0;
    while (l <= n) {
        while (r <= n && f[1].val < m) {
            if (++r <= n) Modify(1, 1, n, a[r].id, 1);
        }
        if (r <= n) res = min(res, a[r].val - a[l].val);
        else break;
        Modify(1, 1, n, a[l].id, 0);
        l++;
    }
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：makerY (赞：12)

看到很多大佬的题解直接讲了做法，本蒟蒻看得不是很懂，调了很久才把这题做出来，于是写了这篇比较详细的题解谈一下我做这题从头到尾的思路，希望对各位有帮助 qwq。

## 思路

我们首先思考这样一个问题，如果已经知道最终答案对应的最大值和最小值，又不知道题目给的 $m$，该如何去求这样选出的子列的长度呢？

显然，我们要让原序列中大小在最大值和最小值之间的所有数都尽可能多地选进子列（因为如果有可以选的但没有选完，就可以把选的子列中最小值或最大值替换中间那些没选的，这样会得到一种极差更小的情况，与条件矛盾），但是这些数在原序列中可能是连续的，不能都选进去，于是分别考虑这些**可以选的数**在原序列中构成的**每一个最长连续段**，容易发现，只有隔一个选一个才能选的尽可能多，如果段长是偶数，最多选一半，段长是奇数，首尾都选了，最多选段长加 $1$ 的一半。实际上，最多选的数的个数就是段长除以 $2$ 并向上取整，而不同段选的数互不干扰，所以**当前子列的长度就是每段可选的最多个数加起来**。

这样就很容易想到一种暴力枚举的方法，我们只需要枚举所有的最大值和最小值，其中必然有一个组合对应着最终答案，每次 $O(n)$ 算出选出的子列长度，在所有长度为 $m$ 的子列中找极差最小的即可，时间复杂度为 $O(n^3)$。

考虑在暴力枚举的基础上进行优化，可以发现，有大量的情况找到的子列长度都不为 $m$，不会影响答案，浪费了很多时间，如何尽量让枚举的情况长度都是 $m$ 呢？由于我们枚举的是最大值和最小值，是有**大小关系**的，尝试把原数列从小到大排序，形成一个**有单调性的序列**，这样就可以**使用双指针去枚举最大值和最小值**了，用左指针枚举最小值，右指针枚举最大值，可以发现左指针向右移动的时候右指针一定不可能向左移动（因为左指针让子列长度变小或不变，为了让找到的子列长度更接近 $m$，右指针只能向右移或不动，向左移就会得到一个更小的子列长度，对答案一定是没有意义的），满足双指针法两个指针都单调不减的性质，这样右指针和左指针移动次数都最多只有 $n$ 次，减少了暴力方法中大量没有意义的枚举次数。

但是 $O(n^2)$ 的复杂度仍然不能通过此题，我们便着眼于子段长度的求法上，朴素方法需要每次遍历整个原序列来找到每一个最长连续段的长度，但我们发现在双指针的枚举过程中，当前枚举的子列每次只会有一个数发生变化，左指针移动则代表**原数列**在当前区间内可以选的数会少一个，右指针移动则会增加一个，而其他的数都是不变且有序的。所以便想到用一种数据结构去维护**当前在原数列中可以选的数（不是当前子列）**，这里以线段树为例，每次增加一个数和减少一个数都是标准的单点修改，而要得到每次选出的子列长度则稍微有些难度，我们可以只考虑每次单点修改后子列长度的**变化**：如果新增了一个**可以选的数**，那么子列长度的变化只与这个数**在原数列中左右相邻的最长连续段**有关，分以下 $3$ 种情况讨论：

1. 如果左右都没有相邻的最长连续段（即左右两数都不在当前可以选的数范围内），则原序列中会多一个长度为 $1$ 的最长连续段，选的子列长度会多 $1$。

2. 如果仅有一侧有相邻的最长连续段，则只会受这个相邻的最长连续段影响，显然，如果其长度为偶数，可以在以前的基础上多选一个，子列长度多 $1$，奇数则不行，子列长度不受影响。

3. 如果两侧都有相邻的最长连续段，则只有在两侧最长连续段长度都为偶数的时候可以多选这个数，否则子列长度不受影响。

而对于删除（即减少了一个可以选的数）的情况，实际上和新增是一样的，删除相当于是**去除原来新增这个数对子列长度的影响**，与上面的判断方法相同，在新增是需要增加子列长度时，减少子列长度即可（即与新增的操作相反）。

而如何找到左右相邻的最长连续段呢？使用线段树维护每个区间内可选数的最长前缀和最长后缀，由线段树的区间可合并性质，递归将**数列第一个数**到**当前数的左边一个数**的区间合并，新区间的最长后缀就是左边相邻的最长连续段，而递归将**当前数的右边一个数到数列最后一个数**的区间合并，新区间的最长前缀就是右边相邻的最长连续段（具体实现见代码，如果还是不太理解区间前缀和后缀的维护，可以先去看看[这题](https://www.luogu.com.cn/problem/P6492)）。

线段树每次单点修改和区间合并的复杂度都是 $O(\log n)$，总复杂度为 $O(n \log n)$，可以通过此题。

## Code

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=100010;
struct Node
{
	int pre,suf;//当前区间的最长前缀和最长后缀 
	int pl,pr;//区间的左右端点 
}tree[N<<2];
Node pushup(Node &p,Node a,Node b)//pushup直接合并两个区间，便于找最长前缀和最长后缀 
{
	p.pl=a.pl,p.pr=b.pr;
	if(a.pre==a.pr-a.pl+1) p.pre=a.pre+b.pre;//如果左区间的前缀占满了整个左区间，则合并时也要把右区间算进去 
	else p.pre=a.pre;
	if(b.suf==b.pr-b.pl+1) p.suf=b.suf+a.suf;//如果右区间的前缀占满了整个左区间，则合并时也要把左区间算进去
	else p.suf=b.suf;
	return p; 
}
void build(int p,int pl,int pr)//因为最开始维护的区间是空的，所以也可以不用建树，这里只是方便记录每个区间的左右端点 
{
	tree[p].pl=pl,tree[p].pr=pr;
	if(pl==pr) return;
	int mid=(pl+pr)>>1;
	build(p<<1,pl,mid);
	build(p<<1|1,mid+1,pr); 
}
void update(int p,int id,int data)//标准的单点修改 
{
	if(tree[p].pl==tree[p].pr)
	{
		tree[p].pre=tree[p].suf=data;
		return;
	}
	int mid=(tree[p].pl+tree[p].pr)>>1;
	if(mid>=id) update(p<<1,id,data);
	if(mid<id) update(p<<1|1,id,data);
	pushup(tree[p],tree[p<<1],tree[p<<1|1]); 
}
Node mergeL(int p,int id)//合并最左端到编号为id的位置的区间 
{
	if(tree[p].pr<=id) return tree[p];
	int mid=(tree[p].pl+tree[p].pr)>>1;
	Node t;
	//如果当前区间中点在id右侧，就不用管右子区间，递归找左子区间 
	if(mid>=id) return mergeL(p<<1,id);//注意理解哪里该取等，这里容易写错 
	//如果当前区间中点在id左侧，那整个左区间一定在需合并的左区间中，右区间则继续递归找在1~id范围内的区间 
	if(mid<id) return pushup(t,tree[p<<1],mergeL(p<<1|1,id));
	
}
Node mergeR(int p,int id)//合并编号为id的位置到最右端的区间 
{
	if(tree[p].pl>=id) return tree[p];
	int mid=(tree[p].pl+tree[p].pr)>>1;
	Node t;
	if(mid<id) return mergeR(p<<1|1,id);
	if(mid>=id) return pushup(t,mergeR(p<<1,id),tree[p<<1|1]);
}
int n,m,ans=0x3f3f3f3f;
pair<int,int> lamp[N];//pair中first存数值大小（灯的高度），second存其在原数列中的编号，便于直接sort排序 
int main()
{
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i=1;i<=n;i++) scanf("%d",&lamp[i].first),lamp[i].second=i;
	sort(lamp+1,lamp+1+n);//对原数列从小到大排序 
	int l,r=0,cnt=0;//通过左右指针l和r枚举区间，cnt表示当前情况下的子列长度 
	for(l=1;l<=n;l++)
	{
		int Lsuf,Rpre;//左边最长后缀和右边最长前缀 
		while(cnt<m&&r<n)//一直右移右指针直到子列长度达到m 
		{
			r++;
			//维护的区间中新增一个可以选的数（当前右指针处） 
			update(1,lamp[r].second,1);
			if(lamp[r].second==1) Lsuf=0;
			else Lsuf=mergeL(1,lamp[r].second-1).suf;
			if(lamp[r].second==n) Rpre=0;
			else Rpre=mergeR(1,lamp[r].second+1).pre;
			//会增加子列长度的三种情况 
			if((!Lsuf&&!Rpre)||(!Rpre&&Lsuf&&Lsuf%2==0)||(!Lsuf&&Rpre&&Rpre%2==0)||(Lsuf&&Rpre&&Lsuf%2==0&&Rpre%2==0)) cnt++;
		}
		if(cnt==m)
		{
			//左指针右移，维护的区间中删除一个可以选的数（当前左指针处） 
			update(1,lamp[l].second,0);
			if(lamp[l].second==1) Lsuf=0;
			else Lsuf=mergeL(1,lamp[l].second-1).suf;
			if(lamp[l].second==n) Rpre=0;
			else Rpre=mergeR(1,lamp[l].second+1).pre;
			//会减少子列长度的三种情况 
			if((!Lsuf&&!Rpre)||(!Rpre&&Lsuf&&Lsuf%2==0)||(!Lsuf&&Rpre&&Rpre%2==0)||(Lsuf&&Rpre&&Lsuf%2==0&&Rpre%2==0)) cnt--;
			ans=min(lamp[r].first-lamp[l].first,ans);//每枚举到一种符合要求情况就更新一次最小答案 
		}
	}
	printf("%d",ans);
	return 0;
}
```

感谢各位大佬的阅读 qwq。

---

## 作者：zyn_ (赞：9)

# [yLOI2022] 长安幻世绘

**食用提示：本题解用了一种神奇的（非正解的）做法，时间复杂度为 $O(n\log n\log V)$。想看正解的，请移步其他题解。**

这篇题解是作者赛时和赛后真实的心路历程。

## 题目大意

给定一个长为 $n$ 的序列 $a_i$。从序列中选出 $m$ 个两两不相邻的数，使选出的数中最大值与最小值的差值最小，输出这个最小差值。

数据范围：$1\le n\le 10^5$。

## 题目分析

要求最小值，可以先**二分**差值（因为显然有单调性）。设二分的值为 $x$。

考虑枚举可选的数的区间。枚举区间下限 $y$，设可选的数都在 $[y,y+x]$ 之间。将能选的数挑出来，用贪心或动态规划判断是否存在 $m$ 个互不相邻的数。只要存在一个 $y$，使存在 $m$ 个互不相邻，且均在 $[y,y+x]$ 之间的数，那么差值 $x$ 就符合要求。

一定要注意 $y$ **不能**二分。

考虑优化。

- 只枚举 $y=a_i$。

为什么可以这样？答案不会出错吗？

设枚举区间 $[y,y+x]$，其中 $y\neq a_i$。设 $a_k$ 为最小的 $a_k$ 使 $y\lt a_k$。

若 $y+x\lt a_k$，则由 $a_k$ 的定义，不存在 $i$ 使 $a_i\in [y,y+x]$。

若 $y+x\geq a_k$，因为 $[y,a_k-1]$ 之间不存在 $a_i$，所以 $[y,y+x]$ 之间 $a_i$ 的个数即为 $[a_k,y+x]$ 之间 $a_i$ 的个数，而这不超过 $[a_k,a_k+x]$ 之间 $a_i$ 的个数。

故 $[y,y+x]$ 之间 $a_i$ 的个数小于或等于 $[a_k,a_k+x]$ 之间 $a_i$ 的个数。所以只需枚举 $y=a_i$ 即可。

这样做是 $O(n^2\log V)$ 的（$V$ 为 $a_i$ 的值域），可拿到 $\text{76pts}$。

## $\text{76pts}$ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l,r,x[100009],mid,cnt,lp,rp,ok;
bool c[100009],d[100009];
struct p{int id,x;}a[100009];
inline bool cmp(p a,p b){return a.x<b.x;}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&x[i]),a[i].x=x[i],a[i].id=i;
	sort(a+1,a+n+1,cmp);
	l=0;r=1000000000; //二分
	while(l<=r){
		mid=(l+r)>>1;lp=1;rp=0;ok=0; //lp,rp是双指针，mid为区间下界（即文中的y）
		for(int i=1;i<=n;++i)c[i]=false;
		for(int i=1;i<=n;++i){
			while(a[rp].x<=mid+a[i].x&&rp<=n)c[a[rp].id]=true,++rp;
			while(lp<i)c[a[lp].id]=false,++lp;
			cnt=0;
			for(int i=1;i<=n;++i)d[i]=false;
			for(int i=1;i<=n;++i)if(c[i]&&!d[i-1])d[i]=true,++cnt; //贪心
			if(cnt>=m){ok=1;break;}
		}ok?r=mid-1:l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```

继续优化。

- 从小到大枚举 $y=a_i$。

发现每次判断是否存在 $m$ 个互不相邻，且在区间 $[y,y+x]$ 中的数需要 $O(n)$ 的时间复杂度，所以一次二分的 $n$ 个判断就有 $O(n^2)$。这成了算法的瓶颈。

如果从小到大枚举 $y$，那么维护哪些数在在区间 $[y,y+x]$ 中，可以用双指针，做到一次二分 $O(n)$。但如何优化判断呢？

我的第一想法：前一次的判断**要对后一次起帮助**。

约莫 $\text{15min}$ 后：不相邻的数……**独立集**？

独立集：一个图中点的集合，集合中的点两两之间没有边。

让我们转化一下问题：

给定一条链，$i$ 和 $i+1$ 之间联边（$i=1,2,...,n-1$）。每个点有权值 $p_i$（若 $a_i\in [y,y+x]$ 则 $p_i=1$，否则 $p_i=0$）。求链上带权最大独立集的大小。

链不就是退化的树吗？[没有上司的舞会！](https://www.luogu.com.cn/problem/P1352)

所以“判断是否存在 $m$ 个互不相邻的数”，就是问链上带权最大独立集的权值和是否不小于 $m$。

但这次的最大独立集问题还带修改权值……**动态 DP**。

[动态 DP 模板题传送门](https://www.luogu.com.cn/problem/P4719)

这个动态 DP 比给出的模板题还简单（树退化成链，无需树剖或LCT）。

设 $dp_{i,0}$ 为从 $p_1$ 到 $p_i$，不选 $p_i$ 的最大独立集的权值和，$dp_{i,1}$ 为从 $p_1$ 到 $p_i$，选 $p_i$ 的最大独立集的权值和。状态转移方程为：$dp_{i,0}=\max(dp_{i-1,0},dp_{i-1,1})$，$dp_{i,1}=dp_{i-1,0}+p_i$。（$i=1,...,n$，$dp_{0,0}=dp_{0,1}=0$）

定义矩阵运算 $R=P*Q$：

$$R_{i,j}=\max_{k}(P_{i,k}+Q_{k,j})$$

将 DP 的状态转移方程写成矩阵 $*$ 运算的形式：

$$\begin{pmatrix}
0 & 0 \\
p_i & -\infty
\end{pmatrix}*
\begin{pmatrix}
dp_{i-1,0} \\
dp_{i-1,1}
\end{pmatrix}=
\begin{pmatrix}
dp_{i,0} \\
dp_{i,1}
\end{pmatrix}
$$

最大独立集的权值和就是 $\max(dp_{n,0},dp_{n,1})$。

每个 $p_i$ 都对应一个矩阵 
$\begin{pmatrix}
0 & 0 \\
p_i & -\infty
\end{pmatrix}$。修改权值就是修改矩阵。

由矩阵形式的转移方程，
$$
\begin{pmatrix}
dp_{n,0} \\
dp_{n,1}
\end{pmatrix}=
\begin{pmatrix}
0 \\
0
\end{pmatrix}*
\begin{pmatrix}
0 & 0 \\
p_1 & -\infty
\end{pmatrix}*
\begin{pmatrix}
0 & 0 \\
p_2 & -\infty
\end{pmatrix}*...*
\begin{pmatrix}
0 & 0 \\
p_n & -\infty
\end{pmatrix}
$$

所以查询最大独立集，就是求区间矩阵 $*$ 运算的值。

这两个操作都可以用线段树在 $O(\log n)$ 的时间复杂度维护。

于是我们得到了一个在一次二分中以 $O(n\log n)$ 的总复杂度判断 $x$ 是否是可能差值的算法。这样总复杂度降为了 $O(n\log n\log V)$。

**建议看到这里回顾一下前面的所有内容，用心感受。**

比赛最后 $\text{1.5 min}$ 时终于过了所有样例，当时真是激动万分！

## 赛时提交的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l,r,x[100009],mid,cnt,lp,rp,ok;
bool c[100009],d[100009];
struct p{int id,x;}a[100009];
inline bool cmp(p a,p b){return a.x<b.x;}
inline int max(int a,int b){return a>b?a:b;}
struct mat{ //矩阵
	long long a,b,c,d;
	inline friend mat operator*(mat p,mat q){ //*运算
		return {max(p.a+q.a,p.b+q.c),max(p.a+q.b,p.b+q.d),max(p.c+q.a,p.d+q.c),max(p.c+q.b,p.d+q.d)};
	}
	inline long long val(){return max(this->a,this->c);} //max(dp[i][0],dp[i][1])
};
mat s[400009],ans;
//线段树
inline void pushup(int p){s[p]=s[p<<1|1]*s[p<<1];}
void update(int t,int pl,int pr,int p,mat d){
	if(pl==pr){s[p]=d;return;}
	int mid=(pl+pr)>>1;
	if(t<=mid)update(t,pl,mid,p<<1,d);
	else update(t,mid+1,pr,p<<1|1,d);
	pushup(p);
}
mat query(int l,int r,int pl,int pr,int p){
	if(l<=pl&&pr<=r)return s[p];
	int mid=(pl+pr)>>1;
	if(r<=mid)return query(l,r,pl,mid,p<<1);
	if(l>mid)return query(l,r,mid+1,pr,p<<1|1);
	return query(l,r,mid+1,pr,p<<1|1)*query(l,r,pl,mid,p<<1);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&x[i]),a[i].x=x[i],a[i].id=i;
	sort(a+1,a+n+1,cmp);
	l=0;r=1000000000;
	while(l<=r){
		mid=(l+r)>>1;lp=1;rp=0;ok=0;
		for(int i=1;i<=n;++i)c[i]=false,update(i,1,n,1,{0,0,0,-1000000009});
		for(int i=1;i<=n;++i){while(a[rp].x<=mid+a[i].x&&rp<=n)update(a[rp].id,1,n,1,{0,0,1,-1000000009}),++rp;
			while(lp<i)update(a[lp].id,1,n,1,{0,0,0,-1000000009}),++lp;
			ans=query(1,n,1,n,1);
			if(ans.val()>=m){ok=1;break;}
		}ok?r=mid-1:l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```

[结果呢？](https://www.luogu.com.cn/record/116945583)

$$\color{darkblue}\texttt{1.04s TLE}$$

所以……

## 卡常

1. 快读。用 `getchar` 代替 `scanf` 加速读入。

附快读模板：

```cpp
int ret;
inline int read(){ //inline可开可不开
    static char c=' ';ret=0;
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)ret=ret*10-48+c,c=getchar();
    return ret;
} //调用：n=read(),m=read();
```

2. `update` 函数中，参数 `mat d` 始终不变，可以将其开为全局变量（**减少压栈操作**）。

3. `query` 函数中，参数 `int l,int r` 始终为 $1$ 和 $n$。

那么 `query` 的返回值不就是**根节点**吗？直接去掉 `query` 函数即可。

改动：

```cpp
mat mt;
//update函数
void update(int t,int pl,int pr,int p){
	if(pl==pr){s[p]=mt;return;}
	int mid=(pl+pr)>>1;
	if(t<=mid)update(t,pl,mid,p<<1);
	else update(t,mid+1,pr,p<<1|1);
	pushup(p);
}
//main函数，二分内
mid=(l+r)>>1;lp=1;rp=0;ok=0;
for(int i=1;i<=n;++i)c[i]=false,mt={0,0,0,-1000000009},update(i,1,n,1);
for(int i=1;i<=n;++i){
	while(a[rp].x<=mid+a[i].x&&rp<=n)mt={0,0,1,-1000000009},update(a[rp].id,1,n,1),++rp;
	while(lp<i)mt={0,0,0,-1000000009},update(a[lp].id,1,n,1),++lp;
	if(max(s[1].a,s[1].c)>=m){ok=1;break;}  //原query
}ok?r=mid-1:l=mid+1;
```

至此，可以通过本题。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l,r,x[100009],mid,cnt,lp,rp,ok,ret;
bool c[100009],d[100009];
struct p{int id,x;}a[100009];
inline bool cmp(p a,p b){return a.x<b.x;}
inline int max(int a,int b){return a>b?a:b;}
inline int read(){
    static char c=' ';ret=0;
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)ret=ret*10-48+c,c=getchar();
    return ret;
}
struct mat{
	long long a,b,c,d;
	inline friend mat operator*(mat p,mat q){
		return {max(p.a+q.a,p.b+q.c),max(p.a+q.b,p.b+q.d),max(p.c+q.a,p.d+q.c),max(p.c+q.b,p.d+q.d)};
	}
};
mat s[400009],ans,mt;
inline void pushup(int p){s[p]=s[p<<1|1]*s[p<<1];}
void update(int t,int pl,int pr,int p){
	if(pl==pr){s[p]=mt;return;}
	int mid=(pl+pr)>>1;
	if(t<=mid)update(t,pl,mid,p<<1);
	else update(t,mid+1,pr,p<<1|1);
	pushup(p);
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;++i)x[i]=read(),a[i].x=x[i],a[i].id=i;
	sort(a+1,a+n+1,cmp);
	l=0;r=1000000000;
	while(l<=r){
		mid=(l+r)>>1;lp=1;rp=0;ok=0;
		for(int i=1;i<=n;++i)c[i]=false,mt={0,0,0,-1000000009},update(i,1,n,1);
		for(int i=1;i<=n;++i){
			while(a[rp].x<=mid+a[i].x&&rp<=n)mt={0,0,1,-1000000009},update(a[rp].id,1,n,1),++rp;
			while(lp<i)mt={0,0,0,-1000000009},update(a[lp].id,1,n,1),++lp;
			if(max(s[1].a,s[1].c)>=m){ok=1;break;}
		}ok?r=mid-1:l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```

## 结语

能在比赛中想到这个思路真不容易。

~~话说这是普及组月赛，但被我硬生生的打成了省选模拟赛（雾~~

**动态 DP 真是个好东西！**

---

## 作者：一扶苏一 (赞：9)

## 子任务 1

$n \leq 6$，此时随便爆搜一下选哪些数，然后 check 即可。期望得分 $12$ 分。

## 子任务 2

考虑枚举所选子列的的最大值和最小值。对于一个确定的最大值 $a$ 和最小值 $b$，我们可以删去原数列中大于 $a$ 或小于 $b$ 的数，考察剩下的数列，我们只需要检查能否从中选出在原数列中互不相邻的 $m$ 个数。

这是一个简单的贪心：从左到右考虑每个数字，如果它在 $[a,b]$ 范围内且前项没有被选上，那么就可以选上这一项。这样可以尽可能多地选择数字。只需要检查能否选够 $m$ 个并更新答案。

时间复杂度：$O(n^2)$ 枚举最值，然后 $O(n)$ 选数。总复杂度 $O(n^3)$，期望得分 $36$ 分。

## 子任务 3

对于 $n \leq 10^3$ 的部分，有两个做法：

### 做法 1

顺承子任务 2 的思路，我们考虑枚举极差最小值 $a$。注意到能选出至少 $m$ 个数的最大值是满足二分性的：如果最大值取 $b$ 时能选出 $m$  个数，则最大值取 $b' > b$ 时，选数的方案不会变少，也可以选出 $m$ 个数。所以可以二分最小的 $b$，然后线性 check。

时间复杂度：共枚举 $O(n)$ 个最小值，每次 $O(\log n)$ 地二分，$O(n)$ check。总复杂度 $O(n^2 \log n)$。期望得分 $76$ 分。

### 做法 2

对做法 $1$ 做进一步考虑。假设枚举的最小值为 $a$ 时，对应最小的最大值是 $b$。考虑当最小值变成 $a + 1$ 时，对应的最小的最大值显然不会小于 $b$。

因此，随着最小值 $a$ 的增大，对应的最小的最大值 $b$ 是单调递增的。可以用双指针维护 $a$ 和 $b$：自小到大枚举 $a$，当 $a$ 增大时，令 $b$ 自增，每次 check，直到可以选出 $m$ 个数。

时间复杂度 $O(n^2)$，期望得分 $76$ 分。

## 子任务 4

我们尝试降低 check 的时间复杂度。

考虑对于一个最小值 $a$ 和最大值 $b$，在原数列中不大于 $b$ 且不小于 $a$ 的**下标**构成了若干个极长的区间。

例如，对数列 $2,4,5,1,3,6$，取 $a = 2,b = 5$ 时，数列中合法数字的下标构成了 $[1, 3]$ 和 $[5,5]$ 这两个区间。

考虑对每个区间 $[l, r]$，因为区间是极长的，所以 $l$ 前面的紧跟的数字不能选。根据 贪心的策略，我们要选择 $l$ 这个数，然后选择 $l + 2$，然后选 $l + 4$……。

因此，对于一个长度为 $x$ 的区间，我们可以选出 $\left\lceil\frac x 2 \right\rceil$ 个数。

考虑用一个数据结构维护这些区间，并顺便维护当前能选的数的个数。当双指针的两个端点移动时，涉及的操作只有：添加一个点，此时可能能衔接起两端区间；删除一个点，此时可能把一个区间从中间裂开。

可以用 set 维护这些区间。为了维护能选的数字个数，可以在插入删除时暴力地去掉受影响的区间的贡献，然后在修改完成后力加回来。

细节详见代码。时间复杂度 $O(n \log n)$。期望得分 $100$ 分。

## Code

```cpp
#include <climits>
#include <set>
#include <vector>
#include <iostream>
#include <algorithm>

int main() {
  int n, m;
  std::cin >> n >> m;
  std::vector<int> a(n);
  for (auto &i : a) std::cin >> i;
  std::vector<std::pair<int, int>> b(n);
  for (int i = 0; i < n; ++i) b[i] = {a[i], i};
  std::sort(b.begin(), b.end());
  int ans = INT_MAX, choosen = 0;
  std::set<std::pair<int, int>> ranges;
  auto getRange = [&](const int p) {
    return --ranges.upper_bound({p, n + 1});
  };
  auto ins = [&](const int l, const int r) {
    ranges.insert({l, r});
    choosen += (r - l + 2) / 2;
  };
  auto era = [&](const int l, const int r) {
    choosen -= (r - l + 2) / 2;
    ranges.erase({l, r});
  };
  auto del = [&](int p) {
    auto range = getRange(p);
    auto [l, r] = *range;
    era(l, r);
    if (l < p) {
      ins(l, p - 1);
    }
    if (r > p) {
      ins(p + 1, r);
    }
  };
  for (int l = 0, r = -1; l < n; del(b[l++].second)) {
    while (choosen < m) {
      if (++r >= n) break;
      int p = b[r].second;
      auto pos = ranges.lower_bound({p + 1, 0});
      auto tmp = pos; if (pos != ranges.begin()) --tmp;
      if (pos == ranges.end() || pos->first != p + 1) {
        if (pos != ranges.begin() && tmp->second == p - 1) {
          auto l = tmp->first;
          era(l, p - 1);
          ins(l, p);
        } else {
          ins(p, p);
        }
      } else {
        if (pos != ranges.begin() && tmp->second == p - 1) {
          int l = tmp->first, r = pos->second;
          era(l, p - 1);
          era(p + 1, r);
          ins(l, r);
        } else {
          int r = pos->second;
          era(p + 1, r);
          ins(p, r);
        }
      }
    }
    if (choosen < m) break;
    ans = std::min(ans, b[r].first - b[l].first);
  }
  std::cout << ans << std::endl;
}
```

---

## 作者：xzhif (赞：4)

## 题目意思：
需要在元素互不相同的数列 $a$ 中选出一个长度为 $m$ 的元素互不相邻的子列，使得子列的极差最小。

## 做法

我们知道，对于一组数列，我们只需知道它的最大值和最小值，就可以得到它的极差。那么我们可以将数字从小到大排序，固定最小值，寻找最优的最大值，当最小值和最大值的位置固定了，那么我们要选出的数定在最小值和最大值位置的范围内。

我们从小到大枚举最小值，容易发现最大值在已排序序列中的位置是有单调性的。便再用一个指针去枚举最大值。用线段树维护这个区间所有数的位置，对于一段连续位置的数字，最优的选取方案就是它的长度除以二（向上取整），那么整个贡献便是每段数字贡献之和。时间复杂度为 $O(NlogN)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1eq5wns1.png)

```cpp
#include<bits/stdc++.h>
#define N 100005
#define ll long long
using namespace std;
ll n,m,res,ans=99999999999999;
struct xs{ll x,k;}a[N];
struct ys{
	ll l,r,sum,lsum,rs,rsum,ls,fla;
	//l表示区间内最左边可选数字的位置，r类似，表示最右边
	//lsum表示区间内最左边可选数字的所在段中最多能选的数字个数，lsum类似，表示最右边
	//rs表示区间内最左边可选数字的所在段中的右端点，ls类似，表示最右边的左端点
	//fla表示整个区间是否有且仅有一段可选数字，sum表示整个区间最多能选的数字个数 
}tr[N*4];
bool cmp(xs x,xs y){return x.x<y.x;}
void pushup(ll rt){
	if(tr[rt<<1].sum&&tr[rt<<1|1].sum){
		tr[rt].l=tr[rt<<1].l,tr[rt].r=tr[rt<<1|1].r;
		tr[rt].lsum=tr[rt<<1].lsum,tr[rt].rs=tr[rt<<1].rs,tr[rt].rsum=tr[rt<<1|1].rsum,tr[rt].ls=tr[rt<<1|1].ls; 
		if(tr[rt<<1].r==tr[rt<<1|1].l-1){
			if(tr[rt<<1].fla==1&&tr[rt<<1|1].fla==1){
				tr[rt].sum=tr[rt].lsum=tr[rt].rsum=(tr[rt<<1|1].r-tr[rt<<1].l+2)/2;
				tr[rt].fla=1,tr[rt].ls=tr[rt<<1].l,tr[rt].rs=tr[rt<<1|1].r;
			}else{
				tr[rt].sum=tr[rt<<1].sum-tr[rt<<1].rsum+tr[rt<<1|1].sum-tr[rt<<1|1].lsum+(tr[rt<<1|1].rs-tr[rt<<1].ls+2)/2;
				tr[rt].fla=0;
				if(tr[rt<<1].fla){
					tr[rt].lsum=(tr[rt<<1|1].rs-tr[rt<<1].l+2)/2,tr[rt].rs=tr[rt<<1|1].rs;
					tr[rt].rsum=tr[rt<<1|1].rsum,tr[rt].ls=tr[rt<<1|1].ls;
				}
				if(tr[rt<<1|1].fla){
					tr[rt].rsum=(tr[rt<<1|1].r-tr[rt<<1].ls+2)/2,tr[rt].ls=tr[rt<<1].ls;
					tr[rt].lsum=tr[rt<<1].lsum,tr[rt].rs=tr[rt<<1].rs;
				}
			}
		}else tr[rt].fla=0,tr[rt].sum=tr[rt<<1].sum+tr[rt<<1|1].sum;
	}else{
		tr[rt].sum=tr[rt].lsum=tr[rt].sum=tr[rt].fla=tr[rt].l=tr[rt].r=tr[rt].ls=tr[rt].rs=0;
		if(tr[rt<<1].sum){
			tr[rt].sum=tr[rt<<1].sum,tr[rt].lsum=tr[rt<<1].lsum,tr[rt].rsum=tr[rt<<1].rsum,tr[rt].fla=tr[rt<<1].fla;
			tr[rt].l=tr[rt<<1].l,tr[rt].r=tr[rt<<1].r,tr[rt].ls=tr[rt<<1].ls,tr[rt].rs=tr[rt<<1].rs;
		}
		if(tr[rt<<1|1].sum){
			tr[rt].sum=tr[rt<<1|1].sum,tr[rt].lsum=tr[rt<<1|1].lsum,tr[rt].rsum=tr[rt<<1|1].rsum,tr[rt].fla=tr[rt<<1|1].fla;
			tr[rt].l=tr[rt<<1|1].l,tr[rt].r=tr[rt<<1|1].r,tr[rt].ls=tr[rt<<1|1].ls,tr[rt].rs=tr[rt<<1|1].rs;
		}
	}
	
}
void add(ll rt,ll l,ll r,ll x,ll d){
	if(l==r){
		tr[rt].fla=d;
		if(d)tr[rt].l=tr[rt].r=tr[rt].ls=tr[rt].rs=x,tr[rt].sum=tr[rt].lsum=tr[rt].rsum=1;
		else tr[rt].l=tr[rt].r=tr[rt].ls=tr[rt].rs=0,tr[rt].sum=tr[rt].lsum=tr[rt].rsum=0;
		return;
	}
	ll mid=(r+l)>>1;
	if(x<=mid)add(rt<<1,l,mid,x,d);
	else add(rt<<1|1,mid+1,r,x,d);
	pushup(rt);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i].x,a[i].k=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=m;i++)add(1,1,n,a[i].k,1);
	for(int i=1,p=m;i<=n-m+1;i++){								//固定最小值 
		while(tr[1].sum<m&&p<n)add(1,1,n,a[++p].k,1);			//不断增大最大值
		if(tr[1].sum>=m)ans=min(ans,a[p].x-a[i].x);				//tr[1].sum包含了整个区间的最优选择，直接判断其是否能取到 m 个 
		add(1,1,n,a[i].k,0);									//把没用的的数字去除，维护线段树的正确性 
	}
	cout<<ans;
}
```


---

## 作者：Fishing_Boat (赞：3)

好不容易有时间打打月赛了，~~于是就用小号上分，大号水题解，结果第二题忘开 ```long long```，第四题没来得及调。~~

首先观察这题，很快就能想到先排序后用尺取往后滑动，问题就在于如何判断排完序后选出的一段连续的数最多能选出几个使得在原数组中任意两个数都不相邻。假设我们选出的数在原数组构成了 $n$ 个子段，那么每个子段只需要贪心的取最多的即可。问题转化成了如何维护这 $n$ 个子段。可以使用 ```map``` 维护左右端点，然后暴力的修改/插入/删除/合并/分裂就行了。~~你写个平衡树我反正不反对~~。详细见代码。

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define ll long long
#define cmax(a,b) a=max(a,b)
#define cmin(a,b) a=min(a,b)
#define rst(a,x) memset(a,x,sizeof(a))
#define ls p<<1
#define rs p<<1|1
#define FAST ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

using namespace std;

int n,m,ans=inf,vis[100005];
struct node{
	int x,id;
}a[100005];

bool cmp(node x,node y){
	return x.x<y.x;
}

map <int,int> st;

void Print(){
	for(auto it:st){
		cout<<it.first<<' '<<it.second<<'\n';
	}
	cout<<'\n';
}

int main(){
	cin>>n>>m;
	if(m==1){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].x;a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	vis[a[1].id]=1;st[-1]=0;st[n+2]=0;st[a[1].id]=a[1].id;
	for(int l=1,r=0,sum=0;l<=n;l++){// 尺取
		while(sum<m&&r<n){
			r++;
			int x=a[r].id;vis[x]=1;
			if(!vis[x-1]&&!vis[x+1]){// 插入
				st[x]=x;
				sum++;
			}else if(vis[x-1]&&vis[x+1]){// 合并
				auto it1=st.upper_bound(x),it2=st.upper_bound(x);
				it1--;
				sum-=((it1->second)-(it1->first)+2)/2;// 这玩意写个函数代码会美观多了
				sum-=((it2->second)-(it2->first)+2)/2;
				it1->second=it2->second;st.erase(it2);
				sum+=((it1->second)-(it1->first)+2)/2;
			}else if(vis[x-1]){// 修改
				auto it=st.upper_bound(x);
				it--;
				sum-=((it->second)-(it->first)+2)/2;
				it->second++;
				sum+=((it->second)-(it->first)+2)/2;
			}else{// 修改
				auto it=st.upper_bound(x);
				sum-=((it->second)-(it->first)+2)/2;
				sum+=((it->second)-(x)+2)/2;
				st[x]=it->second;
				st.erase(it);				
			}
		}
		if(sum!=m) break;
		cmin(ans,a[r].x-a[l].x);
		int x=a[l].id;
		auto it=st.lower_bound(x);
		vis[x]=0;
		if(it->first==x){
			if(it->second==x){ // 删除
				sum--;
				st.erase(it);
			}else{ // 修改
				sum-=((it->second)-(it->first)+2)/2;
				sum+=((it->second)-(x+1)+2)/2;
				st[x+1]=it->second;
				st.erase(it);
			}
		}else{
			it--;
			if(it->second==x){// 修改
				sum-=((it->second)-(it->first)+2)/2;
				it->second--;
				sum+=((it->second)-(it->first)+2)/2;
			}else{// 合并
				sum-=((it->second)-(it->first)+2)/2;
				st[x+1]=it->second;
				sum+=((x-1)-(it->first)+2)/2;
				sum+=((it->second)-(x+1)+2)/2;
				it->second=x-1;
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Find_Yourself (赞：2)

看到极差，不难想到双指针。

显然，如果 $[l,r]$ 的位置都被覆盖，那么其中最多可以选 $\lceil\frac{r-l+1}{2}\rceil$ 个数。

我们先将所有数离散化，排序，双指针卡取值范围。

`set` 里面存 `pair` 类型变量，表示覆盖的区间。

每次将值为 $r$ 的数的位置加入，在 `set` 中二分到与它相邻的区间，然后减去贡献，合并区间，加上新的贡献。

删除同理，将区间拆分，减去原先贡献，加上新的贡献即可。

复杂度 $O(n\log n)$。

代码有点长，但思路很清晰。


```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define mkp make_pair 
using namespace std;
const int N=1e5+5;
int n,m,a[N],tmp[N],cnt;
vector<int>v[N];
set<pii >st;
int get(int l,int r){
	return (r-l+2)/2;
}
void ins(int w){
	set<pii >::iterator it2=st.lower_bound(mkp(w,0)),it=it2;
	int fl=0,fr=0;
	if(it2!=st.begin()){
		--it;
		if((*it).sec==w-1)fl=1;
	}if(it2!=st.end()&&(*it2).fir==w+1)fr=1;
	if(!fl&&!fr)++cnt,st.insert(mkp(w,w));
	else if(!fl&&fr){
		int r=(*it2).sec;
		if((r-w)%2==0)++cnt;
		st.erase(it2);
		st.insert(mkp(w,r));
	}else if(fl&&!fr){
		int l=(*it).fir;
		if((w-l)%2==0)++cnt;
		st.erase(it);
		st.insert(mkp(l,w));
	}else{
		int l=(*it).fir,r=(*it2).sec;
		cnt-=get(l,w-1)+get(w+1,r)-get(l,r);
		st.erase(it);st.erase(it2);st.insert(mkp(l,r));
	}
}
void del(int w){
	set<pii >::iterator it=st.upper_bound(mkp(w,1e9+1));--it;
	int l=(*it).fir,r=(*it).sec;
	if(w==r){
		cnt-=get(l,r)-get(l,r-1);
		st.erase(it);
		if(l<r)st.insert(mkp(l,r-1));
	}else if(w==l){
		cnt-=get(l,r)-get(l+1,r);
		st.erase(it);st.insert(mkp(l+1,r));
	}else{
		cnt-=get(l,r)-get(l,w-1)-get(w+1,r);
		st.erase(it);st.insert(mkp(l,w-1));st.insert(mkp(w+1,r));
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		tmp[i]=a[i];
	}
	sort(tmp+1,tmp+n+1);
	int p=unique(tmp+1,tmp+n+1)-(tmp+1);
	for(int i=1;i<=n;++i)a[i]=lower_bound(tmp+1,tmp+p+1,a[i])-tmp,v[a[i]].push_back(i);
	int l=1,r=0,ans=1e9;
	while(1){
		while(cnt<m&&r<p){
			++r;
			for(int i=0;i<v[r].size();++i)ins(v[r][i]);
		}
		if(cnt<m)break;
		ans=min(ans,tmp[r]-tmp[l]);
		for(int i=0;i<v[l].size();++i)del(v[l][i]);
		++l;
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：喵仔牛奶 (赞：2)

# Description

给定一个长度为 $n$ 的序列，你可以选取一个长度为 $m$ 的元素在原序列中不相邻的子序列，使得该子序列极差最小。

对于所有数据，$1\leq n,m\leq 10^5$。

# Solution

先将序列从小到大排序，考虑枚举被选取子序列中的最小值 $L$ 与最大值 $R$。将序列中大于等于 $L$ 且小于等于 $R$ 的数标记，则会形成若干个被标记的连续段。一个长为 $k$ 的连续段可以选出 $\lceil\dfrac{k}{2}\rceil$ 个数，若能选出的数的总和 $\geq m$ 则这种选择合法。

在 $L$ 变大的同时 $R$ 也会变大，考虑双指针。用 `set` 维护数的加入与删除即可。

时间复杂度 $\mathcal{O}(n\log m)$。

# Code
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
namespace Cadmus {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    typedef set<pii>::iterator IT;
    const int N = 1e6 + 5;
    LL n, m, now, ans; pii a[N];
    set<pii> s;
    LL calc(IT t) { return (t->se - t->fi + 2) / 2; }
    void insert(LL x) {
        if (s.empty()) { s.insert(pii(x, x)), now ++; return; }
		IT itr = s.upper_bound(pii(x, 0)), itl;
        int l = x, r = x;
        if (itr != s.begin()) itl = prev(itr);
        if (itr != s.begin() && itl->se == x - 1)
            now -= calc(itl), l = itl->fi, s.erase(itl);
        if (itr != s.end() && itr->fi == x + 1)
            now -= calc(itr), r = itr->se, s.erase(itr);
        now += (r - l + 2) / 2, s.insert(pii(l, r));
    }
    void split(LL x) {
        IT it = s.upper_bound(pii(x, 0));
        if (it == s.end() || !(it->fi <= x && x <= it->se)) it --;
        int l = it->fi, r = it->se;
        now -= calc(it), s.erase(it);
        if (l < x) now += (x - l + 1) / 2, s.insert(pii(l, x - 1));
        if (r > x) now += (r - x + 1) / 2, s.insert(pii(x + 1, r));
    }
    int main() {
        cin >> n >> m, ans = INT_MAX;
        for (int i = 1; i <= n; i ++)
            cin >> a[i].fi, a[i].se = i;
        sort(a + 1, a + 1 + n);
        for (int l = 1, r = 0; l <= n; split(a[l].se), l ++) {
            while (r < n && now < m) insert(a[++ r].se);
            if (now >= m) ans = min(ans, a[r].fi - a[l].fi);
        }
        cout << ans << '\n';
        return 0;
    }
}
int main() {
    int T = 1;
    while (T --) Cadmus::main();
    return 0;
}
```

---

## 作者：IC0CI (赞：1)

## 题面分析

引用题面的形式化题意：在元素互不相同的数列 $a$ 中选出一个长度为 $m$ 的元素互不相邻的子序列，使得子列的极差最小。

想要直接选出长度为 $m$ 的元素互不相邻的子序列有点麻烦，所以我们从极差最小入手，先给 $a$ 数组排个序，考虑用双指针跑，跑到合适的记录答案。

现在问题来到怎么判断选择的区间是不是合适的。

我们在排序后数列中选择的连续区间内的数在计算贡献时是“可选”的，这些“可选”的数在原数列中的表现为若干段区间，而由于题目的限制“元素互不相邻”，对于原数列上长度为 $len$ 区间最多选择 $\frac {len + 1}{2}$ 个数。

每次双指针拓展可以使一个点由可选变成不可选或从不可选变成可选，每次要检查整个原数列上若干段区间的总贡献。这个问题就变成一个“单点修改、区间查询”的问题，就可以想到线段树。

### 关于具体实现

在线段树每个节点维护五个变量：可选的数个数、答案、由区间左端点开始的连续可选的数的个数、由区间右端点开始的连续可选的数的个数、区间是否是满区间。这样就可以维护线段树，每次查询根节点的答案即可。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int rd()//快读

const int N = 1e5 + 5;

int n,m;
struct node
{
    int val,id;
    bool operator < (const node &x) const{ return val < x.val; }
}a[N];

struct sgt
{
    int sum,ans,l,r;
    bool full;
    void change()
    {
        sum = ans = l = r = sum ^ 1;
        full ^= 1;
    }
}t[N << 2];

#define ls (p << 1)
#define rs (ls | 1)
#define mid ((pl + pr) >> 1)

int calc(int x) { return (x + 1) / 2; }

void pu(int p)
{
    t[p].sum = t[ls].sum + t[rs].sum;
    t[p].full = t[ls].full & t[rs].full;
    if(t[ls].r && t[rs].l)
    {
        if(t[p].full)
        {
            t[p].l = t[p].r = t[p].sum;
            t[p].ans = calc(t[p].sum);
        }
        else if(t[ls].full)
        {
            t[p].l = t[ls].sum + t[rs].l;
            t[p].r = t[rs].r;
            t[p].ans = calc(t[p].l) + t[rs].ans - calc(t[rs].l);
        }
        else if(t[rs].full)
        {
            t[p].r = t[ls].r + t[rs].sum;
            t[p].l = t[ls].l;
            t[p].ans = calc(t[p].r) + t[ls].ans - calc(t[ls].r);
        }
        else
        {
            t[p].l = t[ls].l;
            t[p].r = t[rs].r;
            t[p].ans = t[ls].ans - calc(t[ls].r) + t[rs].ans - calc(t[rs].l) + calc(t[ls].r + t[rs].l);
        }
    }
    else
    {
        t[p].l = t[ls].l;
        t[p].r = t[rs].r;
        t[p].ans = t[ls].ans + t[rs].ans;
    }
}

void upd(int p,int pl,int pr,int lr)
{
    if(pl == pr) return t[p].change();
    if(lr <= mid) upd(ls,pl,mid,lr);
    else upd(rs,mid + 1,pr,lr);
    pu(p);
}

signed main()
{
    n = rd(),m = rd();
    for(int i = 1;i <= n;i++) a[i] = {rd(),i};
    sort(a + 1,a + n + 1);
    int l = 1,r = 0,ans = 0x7fffffff;
    while(1)
    {
        int f = 0;
        while(1)
        {
            r++;
            if(r > n) { f = 1;break; }
            upd(1,1,n,a[r].id);
            if(t[1].ans >= m) break;
        }
        if(f) break;
        while(1)
        {
            ans = min(ans,a[r].val - a[l].val);
            upd(1,1,n,a[l++].id);
            if(t[1].ans < m) break;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：潘德理2010 (赞：1)

我们发现这题需要求极差，所以不难想到：枚举最小值，对每一个最小值 $x$，求出一个最小的 $y$，使得仅取原序列中在 $[x,y]$ 中的数可以满足“可以选出至少 $m$ 个不相邻的数”的条件。

我们考虑如何实现这件事。不难发现，随着 $x$ 的增大，$y$ 单调不降，所以可以使用双指针。另外，我们需要维护一个 01 序列中最多可以选择不相邻的 $1$ 的数量。发现这个东西有可合并性，故考虑使用线段树维护。线段树每个点存储四个值，分别维护当前区间最左边的点的取值和最右边的点的取值分别取 $0$ 或 $1$ 的情况。（如果无法理解可以参考下面代码的具体实现）


```cpp
#include<bits/stdc++.h>
using namespace std;
struct sgt{//线段树 
	int s[400010][2][2];
	// s[i][j][k] i 表示点的编号，j 表示区间最左边点的取值，k 表示区间最右边点的取值 
	void init(){
		memset(s,-0x3f,sizeof(s));
	}
	void ar_init(int d[2][2]){
		memset(d,0,sizeof(d));
	}
	void mer(int d[2][2],int le[2][2],int ri[2][2]){//根据左右两个区间计算当前区间 
		d[0][0]=max({le[0][0]+ri[0][0],le[0][1]+ri[0][0],le[0][0]+ri[1][0],-1<<30});
		d[0][1]=max({le[0][0]+ri[0][1],le[0][1]+ri[0][1],le[0][0]+ri[1][1],-1<<30});
		d[1][0]=max({le[1][0]+ri[0][0],le[1][1]+ri[0][0],le[1][0]+ri[1][0],-1<<30});
		d[1][1]=max({le[1][0]+ri[0][1],le[1][1]+ri[0][1],le[1][0]+ri[1][1],-1<<30});
	}
	void push_up(int u){
		int le=2*u,ri=2*u+1;
		mer(s[u],s[le],s[ri]);
	}
	void upd(int u,int le,int ri,int x,int k){//修改 
		if(le==ri){
			if(k) s[u][1][1]=1;
			else s[u][1][1]=-1<<30;
			s[u][0][0]=0;
			return ;
		}
		int mid=(le+ri)/2;
		if(x<=mid) upd(2*u,le,mid,x,k);
		if(x>mid) upd(2*u+1,mid+1,ri,x,k);
		push_up(u);
	}
	void que(int u,int le,int ri,int x,int y,int res[2][2]){//查询 
		if(x<=le&&ri<=y){
			for(int i=0;i<=1;i++){//注意结构体中不能使用 memcpy 函数 
				for(int j=0;j<=1;j++){
					res[i][j]=s[u][i][j];
				}
			}
			return ;
		}
		int mid=(le+ri)/2;
		int ls[2][2],rs[2][2];
		ar_init(ls),ar_init(rs);
		if(x<=mid) que(2*u,le,mid,x,y,ls);
		if(y>mid) que(2*u+1,mid+1,ri,x,y,rs);
		mer(res,ls,rs);
	}
	int que_f(int n,int x,int y){//处理查询结果 
		int res[2][2];
		que(1,1,n,x,y,res);
		int ans=-1<<30;
		for(int i=0;i<=1;i++){
			for(int j=0;j<=1;j++){
				ans=max(ans,res[i][j]);
			}
		}
		return ans;
	}
}t;
int n,m,ans=1<<30;
int a[100010],b[100010];
vector<int> v[100010];
void cha(int x,int y){
// 更改线段树中所有满足 a[i]=y 的位置 i 的值为 y，y=0 表示不能取，y=1表示可以取 
	for(int i=0;i<v[x].size();i++){
		int u=v[x][i];
		t.upd(1,1,n,u,y);
	}
}
int main(){
	t.init();
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);//离散化 
	int h=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+h+1,a[i])-b;
	}
	for(int i=1;i<=n;i++){
		v[a[i]].push_back(i);
	}
	for(int i=1;i<=h;i++){
		cha(i,0);
	}
	int pos=0;//双指针 
	for(int i=1;i<=h;i++){
		if(pos<=i){
			cha(++pos,1);
		}
		bool ok=0;
		while(1){
			int u=t.que_f(n,1,n);
			if(u>=m){
				ok=1;
				break;
			}
			if(pos<=h) cha(++pos,1);
			else break;
		}
		if(ok){
			ans=min(ans,b[pos]-b[i]);
		}
		cha(i,0);
	}
	printf("%d\n",ans);
}
```

---

## 作者：Lydia1010__ (赞：0)

## 本题思路：
这道题难度不高，这里我介绍一种二分加线段树的做法。

假设我们现在知道当前选出的最小值与最小极差是多少，那么我们就可以把亮度在这之间的树变为一，其余的元素变为零，那么不相邻能选的最多的就很显然了，一段一连一起的贡献就是这一段的长度除以二向上取整（这一点很显然，隔着选就行了），把所有的段都加起来。这一点完全可以开一棵线段树来维护总数。

那么我们就只有最小值与最小极差需要解决了。最小极差我们可以直接二分出来，最小值的话我们先给灯按照亮度排序，枚举最小值，每次滑动把比当前亮度小的下标从线段树中删除，把符合条件的下标从线段树中赋值为一，看看线段树中反出的做多的不相邻的有没有 $m$ 个，有就合法。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mid (tr[p].l+tr[p].r)/2
using namespace std;
struct f{int l,r,ls,rs,sum;}tr[100005*4];
void wei(int p){
	tr[p].ls=tr[p*2].ls;tr[p].rs=tr[p*2+1].rs;
	if(tr[p].ls==tr[p*2].r-tr[p*2].l+1) tr[p].ls+=tr[p*2+1].ls;
	if(tr[p].rs==tr[p*2+1].r-tr[p*2+1].l+1) tr[p].rs+=tr[p*2].rs;
	tr[p].sum=(tr[p*2].sum+tr[p*2+1].sum
	-(tr[p*2+1].ls+1)/2-(tr[p*2].rs+1)/2
	+(tr[p*2].rs+tr[p*2+1].ls+1)/2);
}
void jianshu(int p,int l,int r){
	tr[p].l=l,tr[p].r=r;
	if(l==r){tr[p].ls=tr[p].rs=0;tr[p].sum=0;return;}
	jianshu(p*2,l,mid),jianshu(p*2+1,mid+1,r);
	wei(p);
}
void xiugai(int p,int l,int k){
	if(tr[p].l==tr[p].r){tr[p].ls=tr[p].rs=tr[p].sum=k;return;}
	if(l<=mid) xiugai(p*2,l,k);
	else xiugai(p*2+1,l,k);
	wei(p);
}
int n,m;
struct node{int x,id;}a[100005];
bool cmp(node x,node y){return x.x<y.x;}
int check(int midd){
	int l=1;jianshu(1,1,n);
	for(int i=1;i<=n;i++){
		if(i>1) xiugai(1,a[i-1].id,0);
		while(a[l].x<=a[i].x+midd&&l<=n){
			xiugai(1,a[l].id,1),l++;
		}
		if(tr[1].sum>=m)return 1;
	}
	return 0;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){cin>>a[i].x;a[i].id=i;}
	sort(a+1,a+1+n,cmp);
	int l=0,r=a[n].x-a[1].x,sum=r;
	while(l<=r){
		int midd=(l+r)/2;
		if(check(midd)){r=midd-1,sum=midd;}
		else l=midd+1;
	}cout<<sum;
	return 0;
}
```

---

## 作者：Moeebius (赞：0)

简要题意：在元素互不相同的数列 $a$ 中选出一个长度为 $m$ 的元素互不相邻的子列，使得子列的极差最小。

算是一道 ___双指针___ 普及题吧。

---

记 $r$ 为当前枚举到的，选择的最大值；$l$ 为钦定最大值为 $r$，且选出 $m$ 个不相邻元素中的 **最小值**。  
容易发现，此时答案即为 $r-l$。

为了使得极差最小，对于每一个 $r$，我们需要最大化 $l$。同时，当 $r$ 增大时，$l$ 是单调不降的（因为可选余地更大了）。

所以我们需要思考的就是如何处理 **不相邻**。

容易发现，对于一段区间 $[p,q]$，我们最多可以选取 $\lceil\frac{q-p+1}{2}\rceil$ 个。  
所以我们只要从小到大枚举 $r$，对于每个 $r$ 找出最大的 $l$，同时用一个 `set` 快速维护出新加入一个数，删除一个数时可用的区间集合就行了。

实现的时候可以把原序列离散化一下，时间复杂度 $O(n \log n)$。

---

Code:

```cpp
il void set_del(const pii &x) {
  if (x == null_pii)
    return;
  len -= (x.se - x.fi + 2) >> 1;
  s.erase(x);
}
il void set_ins(const pii &x) {
  if (x == null_pii)
    return;
  len += (x.se - x.fi + 2) >> 1;
  s.insert(x);
}
il void ins(int x) { // 加元素
  x = pos[x];
  auto suf = s.upper_bound({x, x});
  auto pre = suf;
  auto pre_val = pre == s.begin() ? null_pii : *(--pre),
       suf_val = suf == s.end() ? null_pii : *suf;
  if (pre_val.se + 1 == x && suf_val.fi - 1 == x) {
    set_del(pre_val), set_del(suf_val);
    set_ins({pre_val.fi, suf_val.se});
  } else if (pre_val.se + 1 == x) {
    set_del(pre_val);
    set_ins({pre_val.fi, x});
  } else if (suf_val.fi - 1 == x) {
    set_del(suf_val);
    set_ins({x, suf_val.se});
  } else {
    set_ins({x, x});
  }
}
il void del(int x) { // 删元素
  x = pos[x];
  auto it = --s.upper_bound({x, 1e9 + 5});
  auto val = *it;
  if (val.fi == x && val.se == x) {
    set_del(val);
  } else if (val.fi == x) {
    set_del(val);
    set_ins({x + 1, val.se});
  } else if (val.se == x) {
    set_del(val);
    set_ins({val.fi, x - 1});
  } else {
    set_del(val);
    set_ins({val.fi, x - 1}), set_ins({x + 1, val.se});
  }
}

signed main() {
  read(n, m);
  For(i, 1, n) read(a[i]), pool.pb(a[i]);
  sort(pool.begin(), pool.end());
  For(i, 1, n) a[i] =
      lower_bound(pool.begin(), pool.end(), a[i]) - pool.begin() + 1,
               pos[a[i]] = i; // 离散化
  for (int l = 1, r = 0; r < n;) {
    ins(++r);
    while (len >= m && l <= r) {
      ans = min(ans, pool[r - 1] - pool[l - 1]);
      del(l++);
    }
    if (l > 1)
      ins(--l); // 当前找到的 l 是第一个不合法的 l，所以要减 1
  }
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P9474 [yLOI2022] 长安幻世绘 题解

## 题意回顾

给出长度为 $ n $ 的元素互不相同的序列 $ a $，你需要找到一个子序列使得元素互不相邻且长度为 $ m $，最小化子序列极差。

$ n \le 10^5 $。

## 分析

极差是最大值减去最小值，不难考虑到排序，我们将 $ a $ 数组排序并记录每个数原来的出现位置。

如果我们知道序列的取值范围，我们就可以知道哪些数可以被选，可选数会连成若干个段，每个段之间显然互不影响。长度为 $ x $ 的段落，显然可以选出 $ \lceil \frac{x}{2} \rceil $ 个数。则我们要想改变取值范围，即增加或减少可选数的时候，我们可以用线段树维护每个数所在极长区间，然后考虑对于答案的贡献即可。我的维护方式是线段树维护每个区间的最长所有数可选的前后缀和区间长度。

因为可选数增加的时候题意所求的子序列长度显然不降，可选数减少的时候子序列长度显然不升，因此考虑双指针。我的实现方式是外层循环枚举最小值，内层枚举最大值，当发现子序列长度够长的时候就结束内层循环更新答案，再用外层循环把最小值往前推。因为最小值一定的时候最大值越小极差显然越小和子序列长度的单调性，所以这样做是正确的。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int n, m;
struct numb {
	int pos;
	int val;
} a[N];
bool operator<(numb p1, numb p2) {
	return p1.val < p2.val;
}

//SegmentTree
struct node {
	int lx;
	int rx;
	int ln;
} zero, d[N * 4];
node operator+(node p1, node p2) {
	node res;
	res.lx = p1.lx;
	if(p1.ln == p1.lx) {
		res.lx += p2.lx;
	}
	res.rx = p2.rx;
	if(p2.ln == p2.rx) {
		res.rx += p1.rx;
	}
	res.ln = p1.ln + p2.ln;
	return res;
}
void build(int s, int t, int p) {
	if(s == t) {
		d[p].ln = 1, d[p].lx = 0, d[p].rx = 0;
		return;
	}
	int mid = (s + t) >> 1;
	build(s, mid, p * 2);
	build(mid + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1];
}
void update(int x, int v, int s, int t, int p) {
	if(s == t) {
		d[p].lx = d[p].rx = v, d[p].ln = 1;
		return;
	}
	int mid = (s + t) >> 1;
	if(x <= mid) {
		update(x, v, s, mid, p * 2);
	} else {
		update(x, v, mid + 1, t, p * 2 + 1);
	}
	d[p] = d[p * 2] + d[p * 2 + 1]; 
}
node query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r) {
		return d[p];
	}
	int mid = (s + t) >> 1;
	node sum = zero;
	if(l <= mid) {
		sum = sum + query(l, r, s, mid, p * 2);
	}
	if(mid < r) {
		sum = sum + query(l, r, mid + 1, t, p * 2 + 1);
	}
	return sum;
}
//end

int d2c(int x) {
	if(x % 2 == 0) {
		return x / 2;
	}
	return x / 2 + 1;
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i].val);
		a[i].pos = i;
	}
	sort(a + 1, a + n + 1);
	int pos = 0;
	int now = 0;
	int ans = 1e9 + 5;
	build(1, n, 1);
	for(int i = 1; i <= n; i++) {
		while(pos < n) {
			if(now >= m) {
				break;
			}
			pos++;
			update(a[pos].pos, 1, 1, n, 1);
			int l = query(1, a[pos].pos, 1, n, 1).rx - 1;
			int r = query(a[pos].pos, n, 1, n, 1).lx - 1;
			now -= d2c(l) + d2c(r);
			now += d2c(l + 1 + r);
		}
		if(now >= m) {
			ans = min(ans, a[pos].val - a[i].val);
		}
		int l = query(1, a[i].pos, 1, n, 1).rx - 1;
		int r = query(a[i].pos, n, 1, n, 1).lx - 1;
		now -= d2c(l + 1 + r);
		now += d2c(l) + d2c(r);
		update(a[i].pos, 0, 1, n, 1);
	}
	printf("%d\n", ans);
	return 0;
}
```

## 总结与评价

考试时一直在想普及组怎么会考线段树，一直在犹豫。最后下定决心用线段树写了个 $ O(n \log^2 n) $ 屑做法，被卡成暴力分了呜呜呜。

赛后发现可以用 ```set```，我怎么连普及组算法都不会，哭了。

---

## 作者：MaxBlazeResFire (赞：0)

**题意**：在长度为 $n$ 的元素互不相同的数列中找出 $m$ 个互不相邻的数，并最小化其极差（最大值与最小值的差）。

**解法**：首先对序列排序，然后二分答案。对每一个目前二分的极差上限 $x$，在值有序的序列上尺取，对每一个极长的满足右端点与左端点之差 $\leq x$ 的子区间判断是否可以找到至少 $m$ 个元素，其对应原数组的下标互不相邻。

也就是说，在目前尺取的有效的下标集合内，是否可以找到 $m$ 个元素使得不存在两个元素差为 $1$。

我们把这些元素放到值域上。我们发现，**值域上的每个极长段的贡献都是独立的。** 长度为 $l$ 为奇数的极长段的贡献为 $\displaystyle\lfloor\frac{l}{2}\rfloor+1$，长度为偶数的极长段的贡献为 $\displaystyle\lfloor\frac{l}{2}\rfloor$。

于是我们考虑 **暴力维护所有值域上的极长段区间。** 也就是说在尺取的过程中，我们要维护一个值域上添加区间 $[p,p]$ 与删除区间 $[p,p]$ 的过程。例如原来存在区间 $[l_0,p-1]$ 与区间 $[p+1,r_0]$，加入区间 $p$ 后就只剩下了 $[l_0,r_0]$；若在 $[l_0,r_0]$ 上删除 $[x,x]$，则只剩下了 $[l_0,x-1]$ 与 $[x+1,r_0]$。

考虑到这些极长段区间必然两两无交，于是我们用每个区间的端点代表该区间，写两个存在性判定数组以维护在区间边界加入与在区间边界删除的特定情况。**删除一个区间时去除它的贡献，加入一个区间时统计它的贡献。** 

注意到删除时需要找到这个区间在哪个大区间中，于是需要写一个 `set` 来找。

注意到每个区间的添加与删除最多影响 $3$ 个区间的变化，于是一次二分答案与尺取的整体复杂度为 $O(n\log n)$。

整体复杂度 $O(n\log n\log w)$。其中 $w$ 为序列整体的极差。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define MAXN 1000005

int n,m,maxw = 0,minw = 0,a[MAXN] = {0};
int exl[MAXN] = {0},exr[MAXN] = {0},L[MAXN] = {0},R[MAXN] = {0},val[MAXN] = {0};
int calc = 0,nodecnt = 0;

set<int> S;

//exl[i] 表示以 i 为左端点的区间，exr[i] 表示以 i 为右端点的区间
//L[i] 表示区间 i 的左端点，R[i] 表示区间 i 的右端点
//val[i] 表示区间 i 的贡献

struct node{ int val,id; }N[MAXN];

inline bool cmp( node A , node B ){ return A.val < B.val; }

inline int Trp( int l , int r ){ return ( r - l + 1 ) & 1 ? ( r - l + 1 ) / 2 + 1 : ( r - l + 1 ) / 2; }

inline void insert( int p ){
	if( exr[p - 1] && exl[p + 1] ){
		int lef = exr[p - 1],rig = exl[p + 1];
		S.erase( p + 1 );
		calc -= val[lef],calc -= val[rig],val[lef] = val[rig] = 0,exr[p - 1] = exl[p + 1] = 0;
		nodecnt ++,exl[L[nodecnt] = L[lef]] = exr[R[nodecnt] = R[rig]] = nodecnt;
		L[lef] = R[lef] = L[rig] = R[rig] = 0;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
		S.insert( L[nodecnt] );
	}
	else if( exr[p - 1] ){
		int lef = exr[p - 1];
		calc -= val[lef],val[lef] = 0,exr[p - 1] = 0;
		nodecnt ++,exl[L[nodecnt] = L[lef]] = exr[R[nodecnt] = p] = nodecnt;
		L[lef] = R[lef] = 0;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
	}
	else if( exl[p + 1] ){
		int rig = exl[p + 1];
		S.erase( p + 1 );
		calc -= val[rig],val[rig] = 0,exl[p + 1] = 0;
		nodecnt ++,exl[L[nodecnt] = p] = exr[R[nodecnt] = R[rig]] = nodecnt;
		L[rig] = R[rig] = 0;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
		S.insert( L[nodecnt] );
	}
	else nodecnt ++,exl[L[nodecnt] = p] = exr[R[nodecnt] = p] = nodecnt,calc ++,S.insert( L[nodecnt] ),val[nodecnt] = 1;
}

inline void delet( int p ){
	set<int>::iterator it = S.upper_bound( p );
	it --;
	int I = exl[*it];
	if( p == L[I] && p == R[I] ){
		S.erase( p );
		calc -= val[I],val[I] = 0,exl[L[I]] = exr[R[I]] = 0;
		L[I] = R[I] = 0;
	}
	else if( p == L[I] ){
		S.erase( p );
		calc -= val[I],val[I] = 0,exl[L[I]] = exr[R[I]] = 0;
		nodecnt ++,exl[L[nodecnt] = p + 1] = exr[R[nodecnt] = R[I]] = nodecnt;
		L[I] = R[I] = 0;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
		S.insert( p + 1 );
	}
	else if( p == R[I] ){
		calc -= val[I],val[I] = 0,exl[L[I]] = exr[R[I]] = 0;
		nodecnt ++,exl[L[nodecnt] = L[I]] = exr[R[nodecnt] = p - 1] = nodecnt;
		L[I] = R[I] = 0;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
	}
	else{
		calc -= val[I],val[I] = 0,exl[L[I]] = exr[R[I]] = 0;
		nodecnt ++,exl[L[nodecnt] = L[I]] = exr[R[nodecnt] = p - 1] = nodecnt;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
		nodecnt ++,exl[L[nodecnt] = p + 1] = exr[R[nodecnt] = R[I]] = nodecnt;
		calc += val[nodecnt] = Trp( L[nodecnt] , R[nodecnt] );
		L[I] = R[I] = 0;
		S.insert( p + 1 );
	}
}

inline bool check( int x ){
	int l = 1,r = 0;
	nodecnt = calc = 0;
	S.clear();
	memset( exl , 0 , sizeof( exl ) );
	memset( exr , 0 , sizeof( exr ) );
	memset( L , 0 , sizeof( L ) );
	memset( R , 0 , sizeof( R ) );
	memset( val , 0 , sizeof( val ) );
	while( 1 ){
		if( r == n ) break;
		r ++; insert( N[r].id );
		while( N[r].val - N[l].val > x && l <= r ) delet( N[l].id ),l ++;
		if( calc >= m ) return true;
	}
	return false;
}

signed main(){
	maxw = 0,minw = 1e18;
	scanf("%lld%lld",&n,&m);
	for( int i = 1 ; i <= n ; i ++ ) scanf("%lld",&N[i].val),N[i].id = i,maxw = max( maxw , N[i].val ),minw = min( minw , N[i].val );
	sort( N + 1 , N + n + 1 , cmp );
	int l = 0,r = maxw - minw,Ans = 0;
	while( l <= r ){
		int mid = ( l + r ) >> 1;
		if( check( mid ) ) Ans = mid,r = mid - 1;
		else l = mid + 1;
	}
	printf("%lld\n",Ans);
	return 0;
}
```


---

## 作者：hhhxxxyyy3 (赞：0)

各位巨佬们都是用线段树或者 set 来维护某点左右连续段长度的……然而这个工作还可以用**树状数组+二分**来做，不仅常数远优于线段树，而且代码更加易读易写。

在[不开O2的情况下](https://www.luogu.com.cn/record/117578250)，耗时最久的测试点不过 **43ms**；所有测试点耗时的总和也只有 **226ms**。优化方法写在后面。


## 题目正解

本题正解的基本思想是这样的：

枚举最大值和最小值，然后把值在最大与最小之间的所有数视为可选。再动态维护某些数视为可选的情况下真正可选的数有多少个，记为 $cnt$。$cnt \ge m$ 则该状态满足题目要求（合法），从所有合法状态中选择极差最小的作为答案。

第一步枚举可以排序后使用双指针：指向最大值 $maxv$ 和最小值 $minv$ 的两个指针都从最小值开始移动。若是 $cnt<m$，则 $maxv$ 指针右移；若是      $cnt \ge m$，则记录当前极差 $ans= \min(maxv-minv,ans)$ 并让 $minv$ 指针右移，容易看出最坏的情况下也就是两个指针从 $1$ 到 $n$ 把所有数都指了一遍，从而将枚举优化为 $O(n)$ 的复杂度。

那么怎么在指针不断移动的过程中，维护当前视为可选的数中真正可选的呢？

## 思路


回到题目里，我们将每盏灯按它们的位置排成一排；思考一下将一盏灯纳入考虑的时候会怎样影响所有可选灯的数量。

**这盏灯的左右两个灯都没有纳入考虑：**
那么选这盏灯就不会影响题目“所选灯不能相邻”的条件，可以无条件选择，$cnt++$；

**左右两个灯中有一个纳入了考虑：**
![](https://cdn.luogu.com.cn/upload/image_hosting/e77yaw24.png)

如图，如果在这个灯旁有一大排连续的灯已经纳入考虑，那么就说明这排灯已经满足大小在 $[min,max]$ 间的条件，还剩下的约束条件就是不能选择相邻的灯。

设这排连续的灯一共有 $n$ 个，显然，如果 $n$ 是偶数，则把我们面前这盏灯加进来之后变成了奇数，就可以多选一个，$cnt++$；

否则，因为奇数个灯排在一起时最大选择自然是 $1,3,5\cdots$ 最左端和最右端肯定都选上，如今把面前这个灯加进来就会破坏掉最大选择。对 $cnt$ 无贡献。

**左右两个灯都纳入了考虑：**

这个情况看上去相当棘手，挺吓唬人~~比如考试时的我也被吓坏了。~~

但我们套用前面的分析可以看到：左右两排灯中但凡有一排长度为奇数，那么选择我们面前的这盏灯就会破坏掉它的最大选择。

所以只有左右两排灯的长度**都为偶数**，把面前这盏灯加进来才能保持不破坏“所选灯不相邻”的规则，$cnt++$，否则不会产生贡献。

那从考虑中去掉一个灯会怎样呢？

我们推演完加进一个灯会怎样后，惊讶的发现：那考虑某个灯对 $cnt$ 的贡献时灯加入的顺序完全没有影响，唯一有影响的就是**此时有哪些灯纳入考虑**！这就是“无后效性”。

用数学的规范语言表达：假如你在写这道题的 DP，可以只把“当前考虑的灯”和“所有已经考虑的灯的集合”作为状态进行状态转移，便可包含所有状态。

因此我们可以反向思考：去掉一盏灯时，先假设它不在所考虑的集合内时把这盏灯加进来会不会使 $cnt$ 增加。

如果加进来会增加 $1$，那么踢出去自然也会减少 $1$；如果加进来没有影响，那么踢出去也没有影响。

## 优化

也就是说，我们需要一个数据结构帮我们完成：

**维护**：在每个点加入或剔除出所选点集合时可以动态维护；

**查询**：查询在所选点集合中，从某个点向左或向右最长的连续段长度。

我们设一个布尔数组 $b$，用 $b[i]$ 表示第 $i$ 个点是否为所选点；

则从点 $x$ 求向右连续段长度，可以转化为从 $b[x]$ 向右求一点 $y$，使得**从 $x$ 到 $y$ 的区间和等于 $y-x+1$**（区间和等于区间长度）并使 $y$ 最大。

这样的话，我们就只需要单点修改、区间查询，就可以使用修改和查询同样是 $O( \log n)$ 的复杂度，而常数远低于线段树的树状数组了。

已经有了查询区间和的树状数组，我们怎么找到最大的 $y$ 呢？

容易发现单调性：我们选中的点为 $x$，最大合法的 $y$ 为 $y_{max}$，那么位于 $[x,y_{max}]$ 中的所有点肯定都是合法的。

那么我们就可以二分了：在 $[l,r]$ 间，如果 $mid$ 合法，那么更进一步向右考虑 $[mid+1,r]$；如果不合法，那么退一步向左考虑 $[l,mid-1]$。

向左查询也是一样的，只不过左和右、最大和最小调换而已。

枚举复杂度为 $O(n)$，维护和查询用时 $O(\log n)$，总时间复杂度为 $O(n \log n)$。


代码：

```cpp
#define lowbit(x) (x&(-x))
int c[N];//树状数组
void add(int i,int k)
{
    for(;i<=n;i+=lowbit(i)) c[i]+=k;
}
int sum(int i)
{
    int res=0;
    for(;i;i-=lowbit(i)) res+=c[i];
    return res;
}
int rfind(int x)//向右查找
{
	int l=x,r=n;
	int mid,ret;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(sum(mid)-sum(x-1)==mid-x+1)//区间和等于区间长度，代表整个区间都在被选中（值为1）的集合内
		{
			ret=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	return ret-x+1;
}
int lfind(int x)//向左查找
{
	int l=1,r=x;
	int mid,ret;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(sum(x)-sum(mid-1)==x-mid+1)
		{
			ret=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	return x-ret+1;
}


```
## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath> 
#include <algorithm>
#define FOR(i,x) for(int i=1;i<=x;i++)
#define inf 0x3f3f3f3f
#define ll long long
#define db double
const int N=100010;
struct dot{
    int w,i;
    bool operator <(const dot &x) const
    {
        return w<x.w;
    }
   dot(int W=0,int I=0)
    {
    	i=I,w=W;
	}
}a[N];
inline bool in(int &t)
{
	t=0;
	int ch=getchar();
	while(ch==' '||ch=='\n') ch=getchar();
	while(ch!=' '&&ch!='\n'&&ch!=EOF) t=(t<<1)+(t<<3)+ch-'0',ch=getchar();
	return 0;
}
using namespace std;
int n,m,cnt,mx,mn=inf,ans=inf;
int b[N];
#define lowbit(x) (x&(-x))
int c[N];
void add(int i,int k) 
{
    for(;i<=n;i+=lowbit(i)) c[i]+=k;
}
int sum(int i)
{
    int res=0;
    for(;i;i-=lowbit(i)) res+=c[i];
    return res;
}
int rfind(int x)
{
	int l=x,r=n;
	int mid,ret;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(sum(mid)-sum(x-1)==mid-x+1)
		{
			ret=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	return ret-x+1;
}
int lfind(int x)
{
	int l=1,r=x;
	int mid,ret;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(sum(x)-sum(mid-1)==x-mid+1)
		{
			ret=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	return x-ret+1;
}
int main()
{
	in(n);
	in(m);
	FOR(i,n) in(a[i].w),a[i].i=i;
	if(n==1||n==2)
	{
		cout<<0;
		return 0;
	}
	sort(a+1,a+n+1);
	int l=1,r=1;
	b[1]=1;
	add(1,1);
	cnt=1;
	while(r<=n)
	{
		if(cnt<m)
		{
			++r;
			if(r>n) break;
			int x=a[r].i;
			add(x,1);
			b[x]=1;
			if(b[x-1])
			{
				if(b[x+1])
				{
					if((!(lfind(x-1)&1))&&(!(rfind(x+1)&1))) ++cnt;
				}
				else
				{
					if(!(lfind(x-1)&1)) ++cnt;
				}
			}
			else
			{
				if(b[x+1]) 
				{
					if(!(rfind(x+1)&1)) ++cnt;
				}
				else
				{
					++cnt;
				}
			}
		}
		else
		{
			ans=min(ans,a[r].w-a[l].w);
			int x=a[l].i;
			b[x]=0;
			add(x,-1);
			if(b[x-1])
			{
				if(b[x+1])
				{
					if((!(lfind(x-1)&1))&&(!(rfind(x+1)&1))) --cnt;
				}
				else
				{
					if(!(lfind(x-1)&1)) --cnt;
				}
			}
			else
			{
				if(b[x+1]) 
				{
					if(!(rfind(x+1)&1)) --cnt;
				}
				else
				{
					--cnt;
				}
			}
			++l;
		}
	}
	printf("%d",ans);
	
	return 0;
}

```


---


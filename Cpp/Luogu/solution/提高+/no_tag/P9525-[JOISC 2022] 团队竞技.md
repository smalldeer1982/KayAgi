# [JOISC 2022] 团队竞技

## 题目背景

JOISC2022 D2T3

## 题目描述

JOI 大学有 $N$ 只海狸，他们都参与竞技编程。每只海狸有三项能力值：思考值，行动值和运气值。如果一个能力值很大，意味着他这项能力比较强大。对于第 $i~(i\in[1,N])$ 只海狸，他的思考值为 $X_i$，行动值为 $Y_i$，运气值为 $Z_i$。

今年 JOI 大学的海狸们将参与一场团体竞技编程，一支队伍由三名队员组成。Bitaro 是 JOI 大学的教练，由于团队合作很重要，Bitaro 决定从 $N$ 只海狸中选出三只海狸组成队伍，这三只海狸要满足以下条件：

**条件**：每个成员都有自己的优势，这意味着每个成员都有一项能力值严格大于其他两人的对应能力值。

在所有符合条件的组队中，Bitaro 想要选一个总能力最强的队伍，一个队伍的总能力定义为：三人最大思考值，三人最大行动值和三人最大运气值之和。

请你求出，是否存在一个符合条件的组队，如果是，计算队伍总能力可能的最大值。

## 说明/提示

**【样例解释 #1】**

由海狸 $1,4,5$ 组成的队伍符合条件，因为：

1. 海狸 $1$ 的优势是运气。
2. 海狸 $4$ 的优势是行动。
3. 海狸 $5$ 的优势是思考。

总能力值为：$5+4+4=13$。

可以证明这是符合条件的组队中，总能力值最高的队伍。

注意如果选择海狸 $1,3,5$，总能力值将达到 $15$，但是这会导致海狸 $1$ 没有特长。

这组样例满足所有子任务的限制。

**【样例解释 #2】**

最优组队为：海狸 $2,3,4$。

这组样例满足所有子任务的限制。

**【样例解释 #3】**

任何组队方式都会导致队员没有特长，不存在符合条件的组队。

这组样例满足所有子任务的限制。

**【数据范围】**

对于所有数据，满足：

- $3\leq N\leq 150000$。
- $1\leq X_i,Y_i,Z_i\leq 10^8$ $(1\leq i\leq N)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N\leq 300$|$8$|
|$2$|$N\leq 4000$|$29$|
|$3$|$X_i,Y_i,Z_i\leq 5$ $(i\in[1,N])$|$9$|
|$4$|$X_i,Y_i,Z_i\leq 20$ $(i\in[1,N])$|$9$|
|$5$|$X_i,Y_i,Z_i\leq 300$ $(i\in[1,N])$|$9$|
|$6$|$X_i,Y_i,Z_i\leq 4000$ $(i\in[1,N])$|$9$|
|$7$|无附加限制|$27$|

## 样例 #1

### 输入

```
5
3 1 4
2 3 1
1 5 5
4 4 2
5 2 3```

### 输出

```
13```

## 样例 #2

### 输入

```
8
1 1 1
1 1 5
1 5 1
5 1 1
1 5 5
5 1 5
5 5 1
5 5 5```

### 输出

```
15```

## 样例 #3

### 输入

```
4
1 2 3
1 2 3
1 2 3
1 2 3```

### 输出

```
-1```

# 题解

## 作者：zzx0102 (赞：7)

好像这题确实不难。

题意非常简单。

可以使用优先队列维护，将所有人的能力中最大的 $x,y,z$ 取出来，如果这不是属于同一个人的，就立马输出来。

否则，如果有两项是属于一个人 $i$ 的，那么 $i$ 就不可能进队，因为 $i$ 和后面的所有人组队一定会有两项数据是最大的。

于是我们把 $i$ 标记掉，在 $n-1$ 个人里面继续选，知道选完为止。

注意被标记的人不可能进队，所以标记完要记得把 $i$ 在三个优先队列里面全部删除。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 150010; int n, a[N], b[N], c[N];
priority_queue<pair<int, int> > A, B, C;
bool vis[N];
int main() {
	ios::sync_with_stdio(0);
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i] >> b[i] >> c[i];
		A.push(make_pair(a[i], i));
		B.push(make_pair(b[i], i));
		C.push(make_pair(c[i], i));
	}
	for(int i = 1; i <= n; i++) {
		int x = A.top().second;
		int y = B.top().second;
		int z = C.top().second;
		if(b[x] == b[y] || c[x] == c[z]) vis[x] = 1;
		if(c[y] == c[z] || a[y] == a[x]) vis[y] = 1;
		if(a[z] == a[x] || b[z] == b[y]) vis[z] = 1;
		if(!vis[x] && !vis[y] && !vis[z]) {
			cout << a[x] + b[y] + c[z];
			return 0;
		}
		while(!A.empty() && vis[A.top().second]) A.pop();
		while(!B.empty() && vis[B.top().second]) B.pop();
		while(!C.empty() && vis[C.top().second]) C.pop();
	}
	cout << -1;
	return 0;
}
```

---

## 作者：P_Bisector (赞：6)

前方高能预警：我的做法过于魔怔，因为我刚刚做过 2024NOIPT4。

首先我们从小到大枚举能力的其中一维（可以称作时间值），并将其逐一增加到一棵 FHQ-Treap 中，这当中只记录第二维和第三维（称作关键值和记录值），以关键值为关键字维护记录值的区间最大值。想象关键值为横坐标记录值为纵坐标构建一个平面直角坐标系。

我们在枚举的时候需要同时找到关键值最大的和记录值最大的点并且这两个点显然不一致。（时间值枚举时就找到了。）这两个点一致当且仅当其在平面直角坐标系的右上角。因此我们维护一个横坐标（称作 $x_{super}$）使得 $x_{super}$ 以右的所有点纵坐标随横坐标增大而增大。假设 $x_{super}$ 得以维护，那么接下来直接平衡树查询即可。

考虑加入平衡树时如何维护 $x_{super}$。当我们加入一个新的节点满足纵坐标其大于 $x_{super}$ 对应的最大纵坐标或其横坐标大于 $x_{super}$ 则更新 $x_{super}$ 即可。

实现见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=300005;
namespace Treap{
	struct node{int l,r,v,k,s,mx,v2;}t[N];
	int tot,root;
	int newnode(int v,int v2){
		t[++tot].v=v,t[tot].k=rand(),t[tot].s=1,t[tot].v2=v2;
		t[tot].mx=v2;
		return tot;
	}
	void pushup(int x){
		t[x].s=t[t[x].l].s+t[t[x].r].s+1;
		t[x].mx=max(t[x].v2,max(t[t[x].l].mx,t[t[x].r].mx));
	}
	void split(int p,int v,int &x,int &y){
		if(!p){x=y=0;return;}
		if(t[p].v<=v)x=p,split(t[p].r,v,t[p].r,y);
		else y=p,split(t[p].l,v,x,t[p].l);
		pushup(p);
	}
	int merge(int x,int y){
		if(!x||!y)return x+y;
		if(t[x].k<t[y].k)return t[x].r=merge(t[x].r,y),pushup(x),x;
		return t[y].l=merge(x,t[y].l),pushup(y),y;
	}
	void insert(int v,int v2){
		int x,y,z;
		split(root,v,x,z),y=newnode(v,v2);
		root=merge(merge(x,y),z);
	}
	void del(int v){
		int x,y,z;
		split(root,v,x,z),split(x,v-1,x,y),y=merge(t[y].l,t[y].r);
		root=merge(merge(x,y),z);
	}
	int get_k(int p,int k){
		if(k==0)return 0;
		if(k<=t[t[p].l].s)return get_k(t[p].l,k);
		if(k==t[t[p].l].s+1)return p;
		return get_k(t[p].r,k-t[t[p].l].s-1);
	}
	int get_pre(int v){
		int x,y,ans;
		split(root,v-1,x,y),ans=t[get_k(x,t[x].s)].v,root=merge(x,y);
		return ans;
	}
	int get_nxt(int v){
		int x,y,ans;
		split(root,v,x,y),ans=t[get_k(y,1)].v,root=merge(x,y);
		return ans;
	}
	int get_rank(int v){
		int x,y,ans;
		split(root,v-1,x,y),ans=t[x].s+1,root=merge(x,y);
		return ans;	
	}
	int get_mx(int vl,int v){
		int x,y,z,ans;
		split(root,vl-1,x,y),split(y,v,y,z);
		ans=t[y].mx,root=merge(x,merge(y,z));
		return ans;
	}
} 
int n,rt;
struct stu{
	int x,y,z;
	bool operator<(stu b)const{
		return x<b.x;
	}
}a[N]; 
void solve(){
	int mx=-1;
	//逐次将点按照X为关键字
	for(int i=1;i<=n;i++){
		vector<stu>v;
		v.push_back(a[i]);
		while(i<n&&a[i].x==a[i+1].x)v.push_back(a[++i]);
		//Part1：进行查询
		if(Treap::root&&rt){
			//查询非顺序部分中Y最大的和Z最大的 
				int Ymax=rt,Zmax=Treap::get_mx(1,rt-1);
				for(int j=0;j<v.size();j++){
					//如有任何一项不满足要求
					if(Ymax<=v[j].y||Zmax<=v[j].z||Zmax==-1){
						//舍去
					}
					//否则
					else{
						//记录最值
						mx=max(mx,v[j].x+Ymax+Zmax);
						break;
					}
				}
		}
		//Part2：加入平衡树
		for(int j=0;j<v.size();j++){
			Treap::insert(v[j].y,v[j].z);
			//如在xsuper以右且形成逆序
			if(v[j].y>rt&&Treap::get_mx(1,v[j].y-1)>v[j].z){
  			//修改xsuper部分		
				rt=v[j].y;
			}
			int tmp2=Treap::get_nxt(v[j].y);
			if(tmp2){
				using namespace Treap;
				int l=get_rank(tmp2),r=t[root].s;
				while(l<=r){
					int m=(l+r)/2;
					int tmp=t[get_k(root,m)].v;
					if(get_mx(tmp2,tmp)<v[j].z){
						rt=max(rt,tmp);
						l=m+1;
					}else{
						r=m-1;
					}
				}
			}
		}
	}
	cout<<mx;
}
signed main(){
	Treap::t[0].mx=-1;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y>>a[i].z;
	}
	sort(a+1,a+1+n);
	solve();
    return 0;
}

```

---

## 作者：_yang_yi_bo_ (赞：3)

考虑贪心。

这道题的难点在于：每个成员都有一项能力值严格大于其他两人的对应能力值。

首先我们定义一个结构体优先队列，把每种能力值以及所在的下标放入三个不同的优先队列，注意重载运算符时相当于排序中的从小到大排序，也就是定义了一个大根堆。

接着，我们需要判断一下两点：

- 是否已经在别的优先队列中将堆顶下标的元素弹出，也就是之前该下标的元素判断不合法；

- 该元素所在的下标是否在两个堆顶同时出现，若是，则代表不是每个成员都有一项能力值严格大于其他两人的对应能力值，将堆顶元素弹出。

若在某一轮循环判断中，三个堆顶元素全部合法，输出三个堆顶元素的和即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct kkk{
	int val,id;
	bool operator<(const kkk& x)const{
		return val<x.val;
	}
};
priority_queue<kkk> pa,pb,pc;
int n;
int a[150005],b[150005],c[150005];
bool vis[150005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
		pa.push({a[i],i});
		pb.push({b[i],i});
		pc.push({c[i],i});
	}while(!pa.empty()&&!pb.empty()&&!pc.empty()){
		kkk aa=pa.top();
		kkk bb=pb.top();
		kkk cc=pc.top();
		if(vis[aa.id]){
			pa.pop();
			continue;
		}if(vis[bb.id]){
			pb.pop();
			continue;
		}if(vis[cc.id]){
			pc.pop();
			continue;
		}if(a[bb.id]==aa.val){
			vis[bb.id]=1;
			pb.pop();
			continue;
		}if(a[cc.id]==aa.val){
			vis[cc.id]=1;
			pc.pop();
			continue;
		}if(b[aa.id]==bb.val){
			vis[aa.id]=1;
			pa.pop();
			continue;
		}if(b[cc.id]==bb.val){
			vis[cc.id]=1;
			pc.pop();
			continue;
		}if(c[aa.id]==cc.val){
			vis[aa.id]=1;
			pa.pop();
			continue;
		}if(c[bb.id]==cc.val){
			vis[bb.id]=1;
			pb.pop();
			continue;
		}cout<<aa.val+bb.val+cc.val;
		return 0;
	}cout<<-1;
	return 0;
}
```

---

## 作者：tzc_wk (赞：3)

下称在 $x$ 方面有优势的人为 `X`，`Y` 和 `Z` 的定义类似。

我们首先将所以人按 $x$ 排序，显然 `X` 在 `Y,Z` 后面，`Y,Z` 的位置关系只有两种。由于权值只与 `X` 的 $x_i$，`Y` 的 $y_i$ 和 `Z` 的 $z_i$ 有关，因此如果 `Y` 在 `Z` 前面，那么对于一个 `Z` 而言，它可能选择的 Y 是固定的——是它前面的 $y$ 比它小的人中 $z$ 最大的，对于 `Z` 在 `Y` 前面的情况也是固定的，也就是说对于一个人而言，以它作为 `Y` 或 `Z` 之一的可能的 $(Y,Z)$ 个数是均摊 $O(1)$ 的。因此考虑 CDQ 分治，分治到 $[l,r]$ 时考虑以左边的某个人作为 `Y,Z` 中 $x$ 的较大者和右边的某个人作为 X 时的三元组的贡献。具体来说我们对左边的 $(Y,Z)$ 建单调栈，显然只有单调栈上的元素有用，对于右边的某个人 $x_i,y_i,z_i$，显然 $y_i,z_i$ 右上方的区域在单调栈上是一个区间，直接二分得到这个区间后 ST 表即可。

时间复杂度 $n\log^2n$。

---

## 作者：DaiRuiChen007 (赞：3)

# P9525 题解

**题目大意**

> 给定 $n$ 个三元组 $(x_1,y_1,z_1)\sim (x_n,y_n,z_n)$，求一组 $i,j,k$ 满足：$x_i>\max(x_j,x_k),y_j>\max(y_i,y_k),z_k>\max(z_i,z_j)$，且 $x_i+y_j+z_k$ 最大。
>
> 数据范围：$n\le 1.5\times 10^5$。

**思路分析**

考虑取出最大的 $x,y,z$，如果某个 $i$ 满足 $x_i,y_i$ 都是最大值，那么 $i$ 一定不在答案里，证明是显然的。

反之如果不存在这样的 $i$，那么这样的三个元素一定合法，否则我们可以递归成一个只有 $n-1$ 个元素的子问题。

用 `std::priority_queue` 动态维护最大值即可。

时间复杂度 $\mathcal O(n\log n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1.5e5+5;
int a[MAXN],b[MAXN],c[MAXN];
bool vis[MAXN];
priority_queue <array<int,2>> A,B,C;
signed main() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) {
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
		A.push({a[i],i}),B.push({b[i],i}),C.push({c[i],i});
	}
	while(A.size()&&B.size()&&C.size()) {
		int x=A.top()[1],y=B.top()[1],z=C.top()[1];
		if(b[x]==b[y]||c[x]==c[z]) vis[x]=true;
		if(a[y]==a[x]||c[y]==c[z]) vis[y]=true;
		if(a[z]==a[x]||b[z]==b[y]) vis[z]=true;
		if(!vis[x]&&!vis[y]&&!vis[z]) return printf("%d\n",a[x]+b[y]+c[z]),0;
		while(A.size()&&vis[A.top()[1]]) A.pop();
		while(B.size()&&vis[B.top()[1]]) B.pop();
		while(C.size()&&vis[C.top()[1]]) C.pop();
	}
	puts("-1");
	return 0;
}
```



---

## 作者：luxiaomao (赞：3)

这道蓝题刚开始看我觉得很简单，然后调了好几天，在此鸣谢 @xiaoxiaoyyds 的帮助。

因为我们需要选取能力尽量高的海狸，所以用三个优先队列 $x$，$y$，$z$ 分别维护海狸的三种能力，这题的难点其实是查重，因此我在优先队列中顺便储存了海狸的编号，并新建了一个访问数组 $vis$。具体查重的过程请各位看代码。

其实思路上没有很多难度，本质上就是贪心，需要注意的就是选择的必须是只有一种特长的海狸，楼上用 set 的解法已经讲得很透彻了，本蒟蒻就奉上一份优先队列的代码吧。

### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //记得开long long。
int n;
int a[150001],b[150001],c[150001];
priority_queue<pair<int,int>,vector<pair<int,int> >,less<pair<int,int> > > x,y,z; //优先队列用pair类型时默认用第一个参数进行排序。
bool vis[150005]; //用于标记该海狸是否被删除了。
int maxx = 0;
signed main(){
    scanf("%lld",&n);
    for(int i = 1;i <= n;i++)
    {
        scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
        x.push(make_pair(a[i],i));
        y.push(make_pair(b[i],i));
        z.push(make_pair(c[i],i));
    }
    memset(vis,0,sizeof(vis));
    while(true)
    {
        while(!x.empty()&&vis[x.top().second])x.pop();
        while(!y.empty()&&vis[y.top().second])y.pop();
        while(!z.empty()&&vis[z.top().second])z.pop();
        if(x.empty()&&y.empty()&&z.empty()){
            printf("-1");
            return 0;
        }
        if(b[x.top().second]>=y.top().first){
            vis[x.top().second] = true;
            x.pop();
        }
        else if(c[x.top().second]>=z.top().first){
            vis[x.top().second] = true;
            x.pop();
        }
        else if(a[y.top().second]>=x.top().first){
            vis[y.top().second] = true;
            y.pop();
        }
        else if(c[y.top().second]>=z.top().first){
            vis[y.top().second] = true;
            y.pop();
        }
        else if(a[z.top().second]>=x.top().first){
            vis[z.top().second] = true;
            z.pop();
        }
        else if(b[z.top().second]>=y.top().first){
            vis[z.top().second] = true;
            z.pop();
        }
        else{
            maxx=max(maxx,x.top().first+y.top().first+z.top().first);
            break;
        }
    }
    printf("%lld",maxx);
    return 0;
}
```

PS：这是本蒟蒻第一次发题解，求管理员大大通过。

---

## 作者：sieve (赞：2)

# 题解：[P9525 [JOISC2022] 团队竞技](https://www.luogu.com.cn/problem/P9525)

## 思路

我们这题直接贪心即可 。

首先我们写一个结构体，一个存能力值（不管它是哪个），一个存位置，然后写一个重载运算符，维护优先队列中取出的为结构体的值最大 。

然后我们就将三个能力值分别丢进三个优先队列里面，记得把下表也丢进去 。

循环的时候只要三个优先队列里面都有值，就可以继续，否则停止 。

我们分别取出三个队列的顶部结构体，如果这种能力已经出现过了，直接将这个顶部删除，然后循环下一个 。

对于其他的不可行情况，就是这个能力的值已经有别的海狸有过了，那么，我们也把这个顶部删除，循环下一个 。

如果所有的不可行情况都通过了，也就是当前方案可行，直接输出三个顶部的和，然后退出程序 。

对于无解情况，一定没有退出过程序，那么，我们在循环外面再输出 $-1$ 。

## Code:


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct no{
	int val,id;
	bool operator <(const no &D) const 
	{
		return val<D.val;
	}
};
int a[1000005],b[1000005],c[1000005];
priority_queue<no> pa,pb,pc;
bool vis[1000005];
int n;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i]>>b[i]>>c[i];
		pa.push(no{a[i],i});
		pb.push(no{b[i],i});
		pc.push(no{c[i],i});
	}
	while(!pa.empty()&&!pb.empty()&&!pc.empty())
	{
		no aa=pa.top(),bb=pb.top(),cc=pc.top();
		if(vis[aa.id]==1)
		{
			pa.pop();
			continue;
		}
		if(vis[bb.id]==1)
		{
			pb.pop();
			continue;
		}
		if(vis[cc.id]==1)
		{
			pc.pop();
			continue;
		}
		if(a[bb.id]==aa.val)
		{
			vis[bb.id]=1;
			pb.pop();
			continue;
		}
		if(a[cc.id]==aa.val)
		{
			vis[cc.id]=1;
			pc.pop();
			continue;
		}
		if(b[aa.id]==bb.val)
		{
			vis[aa.id]=1;
			pa.pop();
			continue;
		}
		if(b[cc.id]==bb.val)
		{
			vis[cc.id]=1;
			pc.pop();
			continue;
		}
		if(a[bb.id]==aa.val)
		{
			vis[bb.id]=1;
			pb.pop();
			continue;
		}
		if(c[bb.id]==cc.val)
		{
			vis[bb.id]=1;
			pb.pop();
			continue;
		}
		if(c[aa.id]==cc.val)
		{
			vis[aa.id]=1;
			pa.pop();
			continue;
		}
		cout<<aa.val+bb.val+cc.val;
		return 0;
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：cosf (赞：2)

## [P9525](https://www.luogu.com.cn/problem/P9525)

贪心。

显然，对于 $X, Y, Z$，我们都希望各自能取到对应的最大值。

但是，由于题目要求，有些数若可以作为 $2$ 个及以上的最大值，这个数就选不了，把他忽视或删掉即可。

那么，我们可以维护三个堆，暴力循环去可以作为 $2$ 个及以上最大值的成员，等没有符合这种条件的成员后，各自能取到的最大值加起来就是答案了。

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

#define MAXN 150005

using pii = pair<int, int>;

priority_queue<pii, vector<pii>> x, y, z;

int a[MAXN], b[MAXN], c[MAXN];

bool d[MAXN];

int n;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i] >> b[i] >> c[i];
		x.push({a[i], i});
		y.push({b[i], i});
		z.push({c[i], i});
	}
	while (!(x.empty() || y.empty() || z.empty()))
	{
		int o = x.top().second, p = y.top().second, q = z.top().second;
		if (b[o] == b[p] || c[o] == c[q])
		{
			d[o] = true;
		}
		if (a[o] == a[p] || c[p] == c[q])
		{
			d[p] = true;
		}
		if (a[o] == a[q] || b[p] == b[q])
		{
			d[q] = true;
		}
		if (!(d[o] || d[p] || d[q]))
		{
			cout << a[o] + b[p] + c[q] << endl;
			return 0;
		}
		while (!x.empty() && d[x.top().second])
		{
			x.pop();
		}
		while (!y.empty() && d[y.top().second])
		{
			y.pop();
		}
		while (!z.empty() && d[z.top().second])
		{
			z.pop();
		}
	}
	cout << -1 << endl;
	return 0;
}

```


---

## 作者：OccDreamer (赞：1)

来发一个简单的 $O(n \log n)$ 做法。

考虑如果没有要求三只海狸每一只都要有特长，那么我们就会贪心的选择 $x_i$ 最大的、$y_i$ 最大的和 $z_i$ 最大的。

考虑如果答案不是这样，那么必然有一只海狸同时满足 $x_i$ 最大、$y_i$ 最大、$z_i$ 最大当中的至少两项，**注意到这只海狸不可能存在于答案之中。**

我们将这只海狸从序列中删除，那么问题变为了原来的一个子问题，而我们要求的东西不变。

具体过程用三个堆或者 `set` 维护一下最大值即可，知道最后可以选取 $x_i,y_i,z_i$ 三者最大值作为答案再停止。

代码如下。

```cpp
#include<bits/stdc++.h>

#define fi first
#define se second
#define mk make_pair

using namespace std;

const int MAXN = 2e5+5;

int n;
int x[MAXN], y[MAXN], z[MAXN];

bool mark[MAXN];

set<pair<int,int> > A, B, C;

int main(){
	ios::sync_with_stdio(0);
	cin >> n; pair<int,int> now; int a, b, c;
	for(int i=1;i<=n;++i) cin >> x[i] >> y[i] >> z[i], A.insert(mk(x[i],i)), B.insert(mk(y[i],i)), C.insert(mk(z[i],i));
	while(A.size() && B.size() && C.size()){
		now=*A.rbegin();
		if(mark[now.se]){
			A.erase(*A.rbegin());
			continue;
		}
		a=now.fi;
		now=*B.rbegin();
		if(mark[now.se]){
			B.erase(*B.rbegin());
			continue;
		}
		b=now.fi;
		now=*C.rbegin();
		if(mark[now.se]){
			C.erase(*C.rbegin());
			continue;
		}
		c=now.fi;
		now=*A.rbegin();
		if(y[now.se]>=b){
			mark[now.se]=1;
			A.erase(*A.rbegin());
			continue;
		}
		if(z[now.se]>=c){
			mark[now.se]=1;
			A.erase(*A.rbegin());
			continue;
		}
		now=*B.rbegin();
		if(x[now.se]>=a){
			mark[now.se]=1;
			B.erase(*B.rbegin());
			continue;
		}
		if(z[now.se]>=c){
			mark[now.se]=1;
			B.erase(*B.rbegin());
			continue;
		}
		now=*C.rbegin();
		if(x[now.se]>=a){
			mark[now.se]=1;
			C.erase(*C.rbegin());
			continue;
		}
		if(y[now.se]>=b){
			mark[now.se]=1;
			C.erase(*C.rbegin());
			continue;
		}
		break;
	}
	if(A.size()==0 || B.size()==0 || C.size()==0) cout << -1;
	else cout << (*A.rbegin()).fi+(*B.rbegin()).fi+(*C.rbegin()).fi;
	return 0;
}
```
































---

## 作者：sccc_ (赞：0)

## 思路  
一道贪心题。  

我们可以定义一个结构体，存能力值和下标。  

并定义三个优先队列，分别存三个的能力值和当前下标。  

判断以下两点：
- 是否已经在别的优先队列中将队顶下标的元素弹出，也就是之前该下标的元素判断不合法；
- 该元素所在的下标是否在两个队顶出现，如果是，则代表不是每个成员都有一项能力值严格大于其他两人的对应能力值，将队顶元素弹出。

如果某一次循环中，条件全部避开，也就是全部合法，就输出并结束程序。  

如果没有输出，就是不存在符合条件的组队，输出 `-1`。  

注意需要重载运算符，让优先队列中取出的为结构体的值最大。  

## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 150005;
int a[N];
int b[N];
int c[N];
bool vis[N];
int n;
 
struct node
{
	int val, id;
	bool operator < (const node & x) const
	{
		return val < x.val;
	}
};
priority_queue<node> QA, QB, QC;

signed main()
{
	cin >> n;
	for (int i = 1; i <= n; i ++)
	{
		cin >> a[i] >> b[i] >> c[i];
		QA.push({a[i], i});
		QB.push({b[i], i});
		QC.push({c[i], i});
	}
	while (!QA.empty() and !QB.empty() and !QC.empty())
	{
		node A = QA.top();
		node B = QB.top();
		node C = QC.top();
		if (vis[A.id])
		{
			QA.pop();
			continue;
		}
		if (vis[B.id])
		{
			QB.pop();
			continue;
		}
		if (vis[C.id])
		{
			QC.pop();
			continue;
		}
		if (a[B.id] == A.val)
		{
			vis[B.id] = 1;
			QB.pop();
			continue;
		}
		if (a[C.id] == A.val)
		{
			vis[C.id] = 1;
			QC.pop();
			continue;
		}
		if (b[A.id] == B.val)
		{
			vis[A.id] = 1;
			QA.pop();
			continue;
		}
		if (b[C.id] == B.val)
		{
			vis[C.id] = 1;
			QC.pop();
			continue;
		}
		if (c[B.id] == C.val)
		{
			vis[B.id] = 1;
			QB.pop();
			continue;
		}
		if (c[A.id] == C.val)
		{
			vis[A.id] = 1;
			QA.pop();
			continue;
		}
		cout << A.val + B.val + C.val << endl;
		return 0;
	}
	cout << -1 << endl;
	return 0;
} 
```

---

## 作者：Vindictae (赞：0)

# 题目思路
贪心，每次选择 $a,b,c$ 最大的三个数，如果某一个数满足两个属性都最大，就直接删除。使用堆或者平衡树维护。
# AC Code
```cpp
#include <queue>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>

#define endl '\n'
#define int long long
#define inf 0x3f3f3f3f
#define lnf 0x3f3f3f3f3f3f3f3f

const bool Debug = false;

//#define Debug true

using namespace std;

namespace WTH {
	const int N = 150000;
	
	int n;
	int a[N + 5], b[N + 5], c[N + 5];
	int x, y, z;
	bool _Flg[N + 5];
	priority_queue <pair <int, int>, vector <pair <int, int>>, less <pair <int, int>>> _A, _B, _C;
	
	void init () {
		for (register int i = 0; i <= N; ++ i) {
			_Flg[i] = 1;
		}
		
		ios::sync_with_stdio (Debug);
		cin.tie (0);
		cout.tie (0);
	}
	
	void main () {
		cin >> n;
		
		for (register int i = 1; i <= n; ++ i) {
			cin >> a[i] >> b[i] >> c[i];
			_A.push ({a[i], i});
			_B.push ({b[i], i});
			_C.push ({c[i], i});
		}
		
		while (_A.size () && _B.size () && _C.size ()) {
			x = _A.top ().second;
			y = _B.top ().second;
			z = _C.top ().second;
			
			if (b[x] >= b[y] || c[x] >= c[z]) {
				_Flg[x] = 0;
			}
			
			if (a[y] >= a[x] || c[y] >= c[z]) {
				_Flg[y] = 0;
			}
			
			if (a[z] >= a[x] || b[z] >= b[y]) {
				_Flg[z] = 0;
			}
			
			if (_Flg[x] * _Flg[y] * _Flg[z]) {
				cout << a[x] + b[y] + c[z] << endl;
				return ;
			}
			
			if (Debug) {
				puts ("HHH");
			}
			
			while (_A.size () && !_Flg[_A.top ().second]) {
				_A.pop ();
			}
			
			while (_B.size () && !_Flg[_B.top ().second]) {
				_B.pop ();
			}
			
			while (_C.size () && !_Flg[_C.top ().second]) {
				_C.pop ();
			}
		}
		
		cout << -1 << endl;
	}
}

signed main () {
	WTH::init ();
	WTH::main ();
	return 0;
}

```

---

## 作者：云浅知处 (赞：0)

考虑直接取出 $X,Y,Z$ 最大的三个，发现如果有一个 $i$ 满足他的两维都是 max，那么这个 $i$ 不可能在答案中，我们删掉这个 $i$，然后接着做下去；否则这个就是答案。时间复杂度 $O(N\log N)$。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	int n=read();
	vector<int>a(n+1),b(n+1),c(n+1);
	set<pair<int,int> >A,B,C;
	for(int i=1;i<=n;i++)a[i]=read(),b[i]=read(),c[i]=read();
	for(int i=1;i<=n;i++)A.insert(mk(a[i],i)),B.insert(mk(b[i],i)),C.insert(mk(c[i],i));
	
	while(A.size()>=3){
		int x=(--A.end())->se,y=(--B.end())->se,z=(--C.end())->se;
		auto chk=[&](int i){return (a[i]==a[x])+(b[i]==b[y])+(c[i]==c[z])>=2;};
		if(chk(x))A.erase(mk(a[x],x)),B.erase(mk(b[x],x)),C.erase(mk(c[x],x));
		else if(chk(y))A.erase(mk(a[y],y)),B.erase(mk(b[y],y)),C.erase(mk(c[y],y));
		else if(chk(z))A.erase(mk(a[z],z)),B.erase(mk(b[z],z)),C.erase(mk(c[z],z));
		else{
			cout<<a[x]+b[y]+c[z]<<endl;
			return 0;
		}
	}
	puts("-1");

	return 0;
}
```

---

## 作者：Iris_Aurora (赞：0)

考虑贪心。对于每项属性，我们都希望取到最大值，但如果选出的一只海狸有两项或三项属性优势那此方案必定不满足要求。

维护三个优先队列分别维护思考值，行动值和运气值的动态最大值，然后判断是否有选出一只海狸有两项或三项属性优势，若有就标记上并重新选新的最大值，最后把三个值加起来就愉快通过啦！

附上代码：
```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 15e4 + 10;
struct node{
	int id,val;
};
bool operator <(node a,node b) {
	return a.val<b.val;
}
priority_queue<node>x,y,z;
int v[MAXN],cnt=0,a[MAXN],b[MAXN],c[MAXN];
bool flag=0;
int main(){
	int n;
	scanf("%d",&n);
	FL(i,1,n){
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
		x.push({i,a[i]});
		y.push({i,b[i]});
		z.push({i,c[i]});
	}
	while(!x.empty()&&!y.empty()&&!z.empty()){
		node ax=x.top(),ay=y.top(),az=z.top();
		//printf("(%d,%d,%d)\n",ax.val,ay.val,az.val);
		//printf("(%d,%d,%d)\n",ax.id,ay.id,az.id);
		if(b[x.top().id]>=y.top().val){
            v[x.top().id]=1;
            x.pop();
        }
        else if(c[x.top().id]>=z.top().val){
            v[x.top().id]=1;
            x.pop();
        }
        else if(a[y.top().id]>=x.top().val){
            v[y.top().id]=1;
            y.pop();
        }
        else if(c[y.top().id]>=z.top().val){
            v[y.top().id]=1;
            y.pop();
        }
        else if(a[z.top().id]>=x.top().val){
            v[z.top().id]=1;
            z.pop();
        }
        else if(b[z.top().id]>=y.top().val){
            v[z.top().id]=1;
            z.pop();
        }
		//printf("(%d,%d,%d)\n",v[ax.id],v[ay.id],v[az.id]);
		if(!v[ax.id]&&!v[ay.id]&&!v[az.id]){
			flag=1;
			printf("%d\n",ax.val+ay.val+az.val);
			break;
		}
		while(v[x.top().id]&&!x.empty()) x.pop();
		while(v[y.top().id]&&!y.empty()) y.pop();
		while(v[z.top().id]&&!z.empty()) z.pop();
		//cnt++;
		//if(cnt>=10) break;
	}
	if(!flag) printf("-1\n");
	return 0;
}
```


---

## 作者：happybob (赞：0)

题意：

给定 $n$ 个三元组 $(a_i,b_i,c_i)$，求 $1\leq i,j,k \leq n$ 且 $i,j,k$ 互不相等，满足 $a_i > \max\{a_j,a_k\}, b_j > \max\{b_i,b_k\}, c_k > \max \{c_i, c_j\}$，最大化 $a_i + b_j + c_k$。

考虑如果没有 $a_i > \max\{a_j,a_k\}, b_j > \max\{b_i,b_k\}, c_k > \max \{c_i, c_j\}$ 的限制，我们显然分别取 $a,b,c$ 最大的三个。然而直接取这三个可能会违反这个限制。

具体的，$i,j,k$ 中必然有一个 $a,b,c$ 中有大于等于 $2$ 个值都是 $i,j,k$ 中最大的。比如对于 $i$，$a_i > \max\{a_j,a_k\}, b_i > \max\{b_j,b_k\}$。此时 $j$ 已经选到了 $b$ 的最大值，故怎么选，都有 $b_i > b_j$。于是只要选了 $i$，就无法选出这一组 $(i,j,k)$。接着把 $i$ 删了，递归成一个 $n-1$ 的子问题。维护 `priority_queue` 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n;
struct Node
{
	int a, b, c;
	Node(int a, int b, int c): a(a), b(b), c(c){}
	Node(){}
}p[N];

bool del[N];

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> p[i].a >> p[i].b >> p[i].c;
	}
	priority_queue<pair<int, int>> p1, p2, p3;
	for (int i = 1; i <= n; i++)
	{
		p1.push(make_pair(p[i].a, i));
		p2.push(make_pair(p[i].b, i));
		p3.push(make_pair(p[i].c, i));
	}
	for (int i = 1; i <= n; i++)
	{
		while (p1.size() && del[p1.top().second]) p1.pop();
		while (p2.size() && del[p2.top().second]) p2.pop();
		while (p3.size() && del[p3.top().second]) p3.pop();
		vector<pair<int, Node>> vv;
		vv.emplace_back(make_pair(p1.top().second, p[p1.top().second]));
		vv.emplace_back(make_pair(p2.top().second, p[p2.top().second]));
		vv.emplace_back(make_pair(p3.top().second, p[p3.top().second]));
		//cout << i << " " << p1.top().second << " " << p2.top().second << " " << p3.top().second << "\n";  
		for (int j = 0; j < 3; j++)
		{
			int c = 0;
			bool fg = 1;
			for (int k = 0; k < 3; k++)
			{
				if (j == k) continue;
				fg &= (vv[j].second.a >= vv[k].second.a);
			}
			c += fg;
			fg = 1;
			for (int k = 0; k < 3; k++)
			{
				if (j == k) continue;
				fg &= (vv[j].second.b >= vv[k].second.b);
			}
			c += fg;
			fg = 1;
			for (int k = 0; k < 3; k++)
			{
				if (j == k) continue;
				fg &= (vv[j].second.c >= vv[k].second.c);
			}
			c += fg;
			if (c >= 2)
			{
				del[vv[j].first] = 1;
				goto E;
			}
		}
		cout << max({vv[0].second.a, vv[1].second.a, vv[2].second.a}) + max({vv[0].second.b, vv[1].second.b, vv[2].second.b}) + max({vv[0].second.c, vv[1].second.c, vv[2].second.c}) << "\n";
		return 0;
		E:;
	}
	cout << "-1\n";
	return 0;
}
```


---

## 作者：Crazyouth (赞：0)

## 分析

首先这道题本质上离不开一个思想，就是我们贪心地选择最大的 $a_i+b_j+c_k$ 的 $i,j,k$，但是碍于题目的限制，~~外加观察样例~~会发现有一些人是永远不可能选择的，例如样例 $1$ 中的第 $3$ 人，他的 $b_i,c_i$ 都是最大的，不管剩余 $2$ 人如何选，总是不满足题意。

因此，如果某个人的其中 $2$ 项指标（或以上）是所有人中最大的，那么一定不能选他。使用优先队列维护当前 $a,b,c$ 里的最大值，如果其中某个数列里的最大值的人，同时也是另一个数列中达到最大值的人，那么他必定不能选。开数组 $del_i$ 表示 $i$ 是否是不能选的。如果优先队列里开头的若干个元素都不能选，就 `pop()` 掉。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=150010;
#define pii pair<int,int>
int a[N],b[N],c[N],del[N];
priority_queue<pii> x,y,z;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i]>>c[i];
		x.push({a[i],i});
		y.push({b[i],i});
		z.push({c[i],i});
	}
	while(!x.empty()&&!y.empty()&&!z.empty())
	{
		int i=x.top().second,j=y.top().second,k=z.top().second;
		del[i]|=(b[i]==b[j])|(c[i]==c[k]);
		del[j]|=(a[i]==a[j])|(c[j]==c[k]);
		del[k]|=(a[i]==a[k])|(b[j]==b[k]);
		if(!(del[i]+del[j]+del[k]))//都能选
		{
			cout<<a[i]+b[j]+c[k];
			return 0;
		}
		while(!x.empty()&&del[x.top().second]) x.pop();
		while(!y.empty()&&del[y.top().second]) y.pop();
		while(!z.empty()&&del[z.top().second]) z.pop();
	}
	cout<<-1;
}

---

## 作者：Graphcity (赞：0)

小清新数据结构题。

显然，最好的情况就是 $\max X_i+\max Y_i+\max Z_i$，此时要求三者的最大值编号不能重复。

如果最大值编号重复了，那这个重复的编号不可能成为答案，此时可以从候选集合中删掉它，然后再继续做下去，直到候选集合被删空了，此时无解。

可以用三个指针分别维护当前 $X,Y,Z$ 的最大值及编号。时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e5;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

int n,vis[Maxn+5],A[Maxn+5],B[Maxn+5],C[Maxn+5];
struct Node{int k,id;} a[Maxn+5],b[Maxn+5],c[Maxn+5];
inline bool operator<(Node a,Node b)
{return a.k>b.k || (a.k==b.k && a.id<b.id);}

int main()
{
    n=read();
    For(i,1,n) a[i].k=read(),b[i].k=read(),c[i].k=read(),
               a[i].id=b[i].id=c[i].id=i;
    For(i,1,n) A[i]=a[i].k,B[i]=b[i].k,C[i]=c[i].k;
    sort(a+1,a+n+1),sort(b+1,b+n+1),sort(c+1,c+n+1);
    int sa=1,sb=1,sc=1;
    auto Del=[&](int k)
    {
        if(a[sa].id==k) vis[a[sa++].id]=1;
        if(b[sb].id==k) vis[b[sb++].id]=1;
        if(c[sc].id==k) vis[c[sc++].id]=1;
    };
    while(sa<=n && sb<=n && sc<=n)
    {
        if(vis[a[sa].id]) {Del(a[sa].id); continue;}
        if(vis[b[sb].id]) {Del(b[sb].id); continue;}
        if(vis[c[sc].id]) {Del(c[sc].id); continue;}
        if(B[a[sa].id]==b[sb].k) {Del(a[sa].id); continue;}
        if(C[a[sa].id]==c[sc].k) {Del(a[sa].id); continue;}
        if(A[b[sb].id]==a[sa].k) {Del(b[sb].id); continue;}
        if(C[b[sb].id]==c[sc].k) {Del(b[sb].id); continue;}
        if(A[c[sc].id]==a[sa].k) {Del(c[sc].id); continue;}
        if(B[c[sc].id]==b[sb].k) {Del(c[sc].id); continue;}
        printf("%d\n",a[sa].k+b[sb].k+c[sc].k); return 0;
    }
    printf("-1\n");
    return 0;
}
```



---

## 作者：FReQuenter (赞：0)

考虑贪心。

先抛结论：如果一个人的其中两种能力值为剩余所有人中该能力值的最大值，那么这个人一定不能被选择。

证明很简单：如果这个人被选上了，那么他的两（三）种能力值都是最大的，不符合题意。

所以每次只要删除对于当前最大值不合法的人之后更新最大值，随后持续这个过程直到没有修改为止。

关于具体实现：使用 set/map/堆等记录对于当前这种能力值的最大的人然后判断是否合法即可。复杂度 $O(n \log n)$。

其实也可以用哈希+计数排序把复杂度降到 $O(n)$。

用大型数据结构（cdq分治+大分讨+维护序列的数据结构）也可做。

放一下贪心的代码：

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
int n,a[150005][3];
set<pair<int,int>,greater<pair<int,int>>> v[3];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++){
			cin>>a[i][j];
			v[j].insert({a[i][j],i});
		}
	}
	while(n--){
		int pos=0,f=0;
		for(int i=0;i<3;i++){
			int tmp=v[i].begin()->se,cnt=0;
			for(int j=0;j<3;j++){
				if(a[tmp][j]==v[j].begin()->fi) cnt++;
			}
			if(cnt>=2){
				pos=tmp;
				f=1;
				break;
			}
		}
		if(f) for(int i=0;i<3;i++) v[i].erase(v[i].lower_bound({a[pos][i],pos}));
	}
	if(v[0].empty()) cout<<-1;
	else cout<<v[0].begin()->fi+v[1].begin()->fi+v[2].begin()->fi;
}
```

---

## 作者：Little_Cabbage (赞：0)

> 涉及知识点：堆

# 解题思路

利用堆来维护每个能力的最大值。

如果当前的最大值都不属于同一只海狸，就输出。

否则把当重复的元素弹出堆。

如果堆空了还没有找到，说明没有，输出无解。

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ll __int128
#define db double
#define ldb long double
#define vo void
#define endl '\n'
#define il inline
#define re register
#define ve vector
#define p_q priority_queue
#define PII pair<int, int>
#define u_m unordered_map
#define bt bitset

using namespace std;

//#define O2 1
#ifdef O2
	#pragma GCC optimize(1)
	#pragma GCC optimize(2)
	#pragma GCC optimize(3, "Ofast", "inline")
#endif

struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
	char buf[MAXSIZE], *p1, *p2;
	char pbuf[MAXSIZE], *pp;
	IO() : p1(buf), p2(buf), pp(pbuf) {}

	~IO() {
		fwrite(pbuf, 1, pp - pbuf, stdout);
	}
	char gc() {
		if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
		return p1 == p2 ? ' ' : *p1++;
	}

	bool blank(char ch) {
		return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
	}

	template <class T>
	void read(T &x) {
		double tmp = 1;
		bool sign = 0;
		x = 0;
		char ch = gc();
		while (!isdigit(ch)) {
			if (ch == '-') sign = 1;
			ch = gc();
		}
		while (isdigit(ch)) {
			x = x * 10 + (ch - '0');
			ch = gc();
		}
		if (ch == '.') {
			ch = gc();
			while (isdigit(ch)) {
				tmp /= 10.0, x += tmp * (ch - '0');
				ch = gc();
			}
		}
		if (sign) x = -x;
	}

	void read(char *s) {
		char ch = gc();
		for (; blank(ch); ch = gc());
		for (; !blank(ch); ch = gc()) * s++ = ch;
		*s = 0;
	}

	void read(char &c) {
		for (c = gc(); blank(c); c = gc());
	}

	void push(const char &c) {
		if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
		*pp++ = c;
	}

	template <class T>
	void write(T x) {
		if (x < 0) x = -x, push('-');
		static T sta[35];
		T top = 0;
		do {
			sta[top++] = x % 10, x /= 10;
		} while (x);
		while (top) push(sta[--top] + '0');
	}

	template <class T>
	void write(T x, char lastChar) {
		write(x), push(lastChar);
	}
} io;

namespace COMB {
	int fact[200000];
	int Triangle[1010][1010];
	void Fact(int n, int mod) {
		fact[0] = 1;
		for (int i = 1; i <= n; i ++ ) fact[i] = ((fact[i - 1]) % mod * (i % mod)) % mod;
	}
	void Pascal_s_triangle(int n, int mod) {
		for (int i = 0; i <= n; i ++ ) Triangle[i][0] = 1;
		for (int i = 1; i <= n; i ++ )
			for (int j = 1; j <= i; j ++ )
				Triangle[i][j] = (Triangle[i - 1][j] + Triangle[i - 1][j - 1]) % mod;
	}
	int pw(int x, int y, int mod) {
		int res = 1;
		while (y) {
			if (y & 1) res = ((res % mod) * (x % mod)) % mod;
			x = (x % mod) * (x % mod) % mod;
			y >>= 1;
		}
		return res;
	}
	int pw(int x, int y) {
		int res = 1;
		while (y) {
			if (y & 1) res *= x;
			x *= x;
			y >>= 1;
		}
		return res;
	}
	int GCD(int x, int y, int mod) {
		return __gcd(x, y) % mod;
	}
	int LCM(int x, int y, int mod) {
		return (((x % mod) * (y % mod)) % mod / (GCD(x, y, mod) % mod)) % mod;
	}
	int C(int n, int m, int mod) {
		if (m > n || m < 0) return 0;
		return fact[n] * pw(fact[m], mod - 2, mod) % mod * pw(fact[n - m], mod - 2, mod) % mod;
	}
	int Ask_triangle(int x, int y) {
		return Triangle[x][y];
	}
}
using namespace COMB;

//#define fre 1
#define IOS 1
//#define multitest 1

const int N = 4e6 + 10;
const int M = 4e5 + 10;
const int inf = 1e12;
const int Mod = 1e9 + 9;

namespace zla {
	int n;
	struct node {
		int a, b, c;
	} A[N];
	int vis[N];
	p_q<PII> a, b, c;

	il void Init() {
		cin >> n;
		for (int i = 1; i <= n; i ++ ) {
			cin >> A[i].a >> A[i].b >> A[i].c;
			a.push(make_pair(A[i].a, i));
			b.push(make_pair(A[i].b, i));
			c.push(make_pair(A[i].c, i));
		}
	}

	il void Solve() {
		for (int i = 1; i <= n; i ++ ) {
			int x = a.top().second;
			int y = b.top().second;
			int z = c.top().second;
			if (A[x].b == A[y].b || A[x].c == A[z].c) vis[x] = 1;
			if (A[y].c == A[z].c || A[y].a == A[x].a) vis[y] = 1;
			if (A[z].a == A[x].a || A[z].b == A[y].b) vis[z] = 1;
			if (!vis[x] && !vis[y] && !vis[z]) {
				cout << A[x].a + A[y].b + A[z].c;
				return ;
			}
			while (!a.empty() && vis[a.top().second]) a.pop();
			while (!b.empty() && vis[b.top().second]) b.pop();
			while (!c.empty() && vis[c.top().second]) c.pop();
		}
		cout << -1;
	}

	il void main() {
		Init();
		Solve();
	}
}

signed main() {
	int T;
#ifdef IOS
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
#endif
#ifdef fre
	freopen("team.in", "r", stdin);
	freopen("team.out", "w", stdout);
#endif
#ifdef multitest
	cin >> T;
#else
	T = 1;
#endif
	while (T--) zla::main();
	return 0;
}

```

---


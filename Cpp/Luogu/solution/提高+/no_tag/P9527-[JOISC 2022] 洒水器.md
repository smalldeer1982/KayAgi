# [JOISC 2022] 洒水器

## 题目背景

JOISC2022 D3T2

## 题目描述

JOI 君有多年在自家菜园种植蔬菜的经验，现在他计划管理 IOI 农场。

IOI 农场由 $N$ 块土地组成。土地间有 $N-1$ 条双向道路相连，编号从 $1$ 到 $N-1$，第 $i$ 条道路连接土地 $A_i$ 和 $B_i$，任意两块土地间都可以通过道路互达。农场的每块土地上都有一个洒水器，使用洒水器可以向附近的土地洒水。

JOI 君计划在 IOI 农场种植 JOI 谷。JOI 谷是一种奇特的作物，它在被浇水时高度会立刻发生变化。但是同时，JOI 谷是一种脆弱的植物，若它的高度大于等于 $L$，JOI 谷顶部长为 $L$ 的部分会立刻断裂并掉落。JOI 君会收获掉落的部分。

初始时，JOI 君在土地 $j$ 上种了一株高度为 $H_j$ 的 JOI 谷，之后的 $Q$ 天，JOI 君都会照料这些 JOI 谷，在第 $k$ 天，JOI 君会做如下两个操作之一：

- 操作 $1$：JOI 君使用土地 $X_k$ 上的洒水器，向与土地 $X_k$ 距离不超过 $D_k$ 的土地上浇水，使这些土地上的 JOI 谷高度乘以 $W_k$。由于 JOI 谷会不断断裂，因此若对一株原高度为 $h$ 的 JOI 谷洒水，它的高度会变为 $hW_k\bmod L$。
- 操作 $2$：JOI 君测量土地 $X_k$ 上 JOI 谷的高度。

土地 $x$ 和土地 $y$ 间距离的定义为：从土地 $x$ 前往土地 $y$ 经过道路数的最小值。

JOI 君希望 JOI 谷按照计划长大，因此，他希望提前算出每次操作 $2$ 应当测量出 JOI 谷的高度。

## 说明/提示

**【样例解释 #1】**

初始时，JOI 君在所有土地上种植了高度为 $1$ 的 JOI 谷。

第一天，JOI 君使用土地 $2$ 的洒水器，土地 $1,2,3$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $2,2,2,1$。

第二天，JOI 君使用土地 $1$ 的洒水器，土地 $1$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $4,2,2,1$。

第七天，JOI 君使用土地 $4$ 的洒水器，土地 $1,2,3,4$ 的 JOI 谷被影响，高度乘以 $2$，第一株 JOI 谷的高度变为 $8$，发生断裂，因此四株 JOI 谷的高度变为 $1,4,4,2$。

这组样例满足子任务 $1,5,6$ 的限制。

**【样例解释 #2】**

第一天，JOI 君使用土地 $5$ 的洒水器，土地 $5,6$ 上的 JOI 谷高度乘以 $7$，高度分别变为 $63,7$，因此，土地 $5$ 上的 JOI 谷会不断断裂，高度变为 $3$。

这组样例满足子任务 $1,2,3,6$ 的限制。

**【样例解释 #3】**

这组样例满足子任务 $1,3,4,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $2\leq N\leq 200000$。
- $2\leq L\leq 10^9$。
- $1\leq A_i\lt B_i\leq N$ $(i\in[1,N-1])$。
- 任意土地之间都可以通过若干条道路到达。
- $0\leq H_j\lt L$ $(1\leq j\leq N)$。
- $1\leq Q\leq 400000$。
- $T_k$ 均为 $1$ 或 $2$。
- 对于满足 $T_k=1$ $(k\in[1, Q])$ 的 $k$，保证 $1\leq X_k\leq N, 0\leq D_k\leq 40, 0\leq W_k\lt L$。
- 对于满足 $T_k=2$ $(k\in[1, Q])$ 的 $k$，保证 $1\leq X_k\leq N$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N,Q\le 1000$|$3$|
|$2$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\leq 1$|$9$|
|$3$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\leq 2$|$29$|
|$4$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=0$|$12$|
|$5$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=2$|$30$|
|$6$|无附加限制|$17$|

## 样例 #1

### 输入

```
4 7
1 2
2 3
3 4
1
1
1
1
11
1 2 1 2
1 1 0 2
2 1
2 2
2 3
2 4
1 4 10 2
2 1
2 2
2 3
2 4```

### 输出

```
4
2
2
1
1
4
4
2```

## 样例 #2

### 输入

```
6 10
5 6
1 2
1 4
2 6
3 6
9
2
3
4
9
1
10
1 5 1 7
2 4
1 4 1 9
1 5 0 7
2 1
1 1 1 3
1 6 1 4
2 5
2 4
2 3```

### 输出

```
4
1
4
8
2```

## 样例 #3

### 输入

```
8 10
1 3
3 5
4 7
6 7
4 5
7 8
2 4
5
8
6
4
6
2
9
3
11
1 2 2 0
2 1
1 6 1 0
2 4
2 6
1 5 2 0
2 8
1 7 2 0
2 6
2 7
2 4```

### 输出

```
5
0
0
3
0
0
0```

# 题解

## 作者：Po7ed (赞：21)

[**题目传送门**](https://www.luogu.com.cn/problem/P9527)

以下设 $\operatorname{dis}(x,y)$ 表示树上 $x,y$ 两点间的距离。修改时对 $u$ 的周围与 $u$ 距离小于等于 $d$ 的点的点权乘 $w$。
***
暴力不行，于是考虑打标记。

注意到 $0\le d\le 40$，一个很自然的想法是：设 $tag(x,i)$ 表示**将 $x$ 的子树内**与 $x$ 距离**小于等于** $i$ 的所有点的点权乘 $tag(x,i)$。修改时遍历 $l$ 分别表示 $u$、$u$ 的父亲……$u$ 的 $d$ 级祖先，将 $tag(l,d-\operatorname{dis}(u,l))$ 都乘上 $w$ 即可。查询时依然遍历 $l$，沿途把标记累乘即可。这样 $l$ 最多 $O(d)$ 个取值，总时间复杂度是 $O(nd)$ 的。

显然这样会有点权被重复乘 $w$，解决方案也很简单，打标记时将重复的用除法抵消。具体的，设 $l$ 的一个孩子 $s$，使 $s$ 的子树内有 $u$，打标记时将 $tag(s,d-\operatorname{dis}(u,l)-1)$ 即 $tag(s,d-\operatorname{dis}(u,s)-2)$ 除以 $w$ 即可。

下图给出了一个例子帮助理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/72n1dcm7.png)

图中 $1$ 号点（即 $u$）将它自己和它下面的 $3$ 个点乘了 $w$，$2$ 号点也将其子树内的 $5$ 个点乘 $w$，但 $1$ 号点由于被重复乘，通过除法被消去了一次。同理，$3$ 号乘了 $3$ 个点，其中 $2$ 号点被消去了一次。$4$ 号乘了它自己。这样每个需要乘的点都刚好被乘了一次。

但模数可能没有逆元，这样做还是不行。

不妨换个角度，观察到 $l$ 可以取到 $s$，即对于 $s$ 的标记的操作，事实上是 $tag(s,d-\operatorname{dis}(u,s))$ 乘 $w$，$tag(s,d-\operatorname{dis}(u,s)-2)$ 除以 $w$。

考虑对标记的定义稍作修改，设 $tag'(x,i)$ 表示**将 $x$ 的子树内**与 $x$ 距离**刚好等于** $i$ 的所有点的点权乘 $tag'(x,i)$，则上面对 $s$ 的标记的操作等价于 $tag'(s,d-\operatorname{dis}(u,s)-1)$ 和 $tag'(s,d-\operatorname{dis}(u,s))$ 都乘 $w$。**我们成功地将一乘一除转化为了两个乘。**（有点类似前缀和的还原。）对应到上图的例子，就是换一个乘 $w$ 消：

![](https://cdn.luogu.com.cn/upload/image_hosting/9gbam7kb.png)

这样，时间复杂度依然是 $O(nd)$ 的，询问时还是直接跳祖先乘标记。

代码：

```cpp
#include <iostream>
#include <vector>

const int N=214514,D=100;
int n,m,mod;
int a[N];
int tag[N][D],fa[N];
std::vector<int> e[N];

void dfs(int u,int f=0)
{
	fa[u]=f;
	for(int v:e[u])if(v!=f)dfs(v,u);
}

int main()
{
	scanf("%d %d",&n,&mod);
	int u,v;
	for(int i=1;i<n;i++)
	{
		scanf("%d %d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=n;i++)for(int j=0;j<=40;j++)tag[i][j]=1;
	scanf("%d",&m);
	int o,x,d,w;
	while(m--)
	{
		scanf("%d %d",&o,&x);
		if(o==1)
		{
			scanf("%d %d",&d,&w);
			while(d>=0&&x)
			{
				tag[x][d]=1ll*tag[x][d]*w%mod;
				if(d>=1)tag[x][d-1]=1ll*tag[x][d-1]*w%mod;
				if(x==1) // 根节点要特判，因为根节点没有祖先抵消
				{
					for(int i=0;i<=d-2;i++)tag[1][i]=1ll*tag[1][i]*w%mod;
					break;
				}
				x=fa[x];
				d--;
			}
		}
		else
		{
			int ans=a[x];
			for(d=0;d<=40;d++) // 跳父亲累乘 tag
			{
				if(!x)break;
				ans=1ll*ans*tag[x][d]%mod;
				x=fa[x];
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：SDLTF_凌亭风 (赞：11)

这个题，建议入典。

题目要求我们支持如下操作：

- 对树上距离点 $X_k$ 所有距离不超过 $D_k$ 点乘上 $x$ 并取模；
- 单点查询某点的值。

很恶心的点在与模数不是质数，然而 $D$ 很小，于是直接考虑如何对 $D$ 操作。

要支持的操作很容易让我们想到打标记。设 $f_{i, d}$ 表示以 $i$ 为子树中与 $i$ 距离为 $d$ 的点所需要乘上的标记，问题变成了如何不重不漏的覆盖所有点。

一个很优美的做法是：记 $i$ 的 $d$ 级祖先为 $p$，树上两点 $(u,v)$ 之间距离为 $\operatorname{dis}(u,v)$。那么我们只需要对 $f_{p, d-\operatorname{dis}(p,i)}$ 和 $f_{p, d-\operatorname{dis}(p,i)-1}$ 打标记即可。

相当于是，你把每次修改拆成了最多 $40$ 个祖先的修改，查询的时候就最多把 $40$ 个祖先的标记乘起来。

时间复杂度是 $O(Nd)$ 的，相当优美。

部分代码如下：

```cpp
for(int op, x, y, z; T; -- T) {
	cin >> op >> x;
	if(op == 1) {
		cin >> y >> w;
        while (x && y >= 0) {
            if(fa[x] && y > 1) 					f[x][y] = f[x][y] * w % L, f[x][y - 1] = f[x][y - 1] * w % L;
            else for(int i = 0; i <= y; ++ i) 	f[x][i] = f[x][i] * w % L;
            x = fa[x], -- y;
        }
    }
	else {
        ll d = 40, res = 1;
        while (x && d >= 0) {
            res = res * tg[x][40 - d] % L;
            x = fa[x], -- d; 
        }
        cout << w[x] * res % L << endl;
    }
}
```

---

## 作者：251Sec (赞：4)

感觉这题好难啊，为啥才蓝题。

---

首先一个点的度数可能很大，但是选一个根节点之后每个点的父亲都是唯一的，而我们修改的 $d_k$ 又很小，这启示我们在修改节点的祖先处打标记，询问时候直接枚举祖先统计。

于是设 $f(u,i)$ 代表这样一个标记：将 $u$ 子树里和 $u$ 距离恰好为 $i$ 的点权乘上 $f(u,i)$。询问的时候直接跳 $40$ 个祖先算这个值就好了。考虑修改怎么做。

我们考虑被修改影响到的一个节点 $v$，不妨枚举 $u,v$ 的 LCA，设为 $w$，显然需要被枚举的 $w$ 不超过 $40$ 个。被修改的节点 $v$ 满足 $\text{dis}(w,v) \le d-\text{dis}(u,w)$，并且它应当在 $w$ 的子树里，且不在 $w$ 和 $u$ 路径上 $w$ 的儿子的子树里。设这个儿子为 $s$（事实上这个思想和点分树是类似的？）。

因此我们在 $f(w,0 \le i \le d-\text{dis}(w,v))$ 处打乘法标记，在 $f(s,0 \le i \le d-\text{dis}(w,v)-1)$ 处打除法标记。但是我们发现这样的复杂度是爆炸的，而且模数还可能没有逆元。

考虑在 $f(s,0 \le i \le d-\text{dis}(w,v)-1)$ 处打除法标记相当于是在 $f(s,0 \le i \le d-\text{dis}(s,v)-2)$ 处打除法标记，于是它会和原有的 $f(s,0 \le i \le d-\text{dis}(s,v))$ 的乘法标记抵消，只留下 $f(s,d-\text{dis}(s,v)-1))$ 和 $f(s,d-\text{dis}(s,v))$ 处的乘法标记。因此我们消掉了除法，并且只留下了两个单点的乘法，这样复杂度就不爆炸了！

最终我们在 $O(n+qd)$ 的复杂度解决了这一问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, P;
struct Edge {
    int to, next;
} e[400005];
int head[200005], len;
void Insert(int u, int v) {
    e[++len] = { v, head[u] };
    head[u] = len;
}
ll w[200005], f[200005][45];
int prt[200005];
void Prework(int u, int fa) {
    prt[u] = fa;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (v == fa) continue;
        Prework(v, u);
    }
}
int main() {
    scanf("%d%d", &n, &P);
    for (int i = 1; i < n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        Insert(u, v); Insert(v, u);
    }
    Prework(1, 0);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", w + i);
        for (int j = 0; j <= 40; j++) f[i][j] = 1;
    }
    scanf("%d", &m);
    while (m--) {
        int tp; scanf("%d", &tp);
        if (tp == 1) {
            int x, y; ll v;
            scanf("%d%d%lld", &x, &y, &v);
            while (x && ~y) {
                if (prt[x] && y > 1) f[x][y] = f[x][y] * v % P, f[x][y - 1] = f[x][y - 1] * v % P;
                else for (int i = 0; i <= y; i++) f[x][i] = f[x][i] * v % P;
                x = prt[x]; y--;
            }
        }
        else {
            int x; scanf("%d", &x);
            ll res = w[x];
            for (int i = 0; x && i <= 40; i++) {
                res = res * f[x][i] % P;
                x = prt[x];
            }
            printf("%lld\n", res);
        }
    }
    return 0;
}
```

---

## 作者：0x3F (赞：3)

~~NOIP 考前写题解涨 rp~~

题目大意：一棵 $n(\le2\times10^5)$ 个节点的树，点有点权，给出模数 $l$（不一定为素数），进行 $q(\le 4\times10^5)$ 次操作：

1. 将距离点 $x$ 不超过 $d(\le 40)$ 的点的点权乘以 $w$。

2. 查询点 $x$ 的点权。

非常有趣，我们考虑把距离 $x$ 不超过 $d$ 的点拆成一系列某一个点的 $k$ 级祖先的并集，如图所示。

![](https://z1.ax1x.com/2023/11/17/pito78g.png)

这样在每个点的祖先上打标记就可以了，时间复杂度为 $O(nd)$，注意边界情况即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 2e5 + 10;
const int __ = 4e5 + 10;
int n, l, q, e, h[_], hd[_], nx[__], to[__], fa[_], tg[_][41];
inline void add(int u, int v) {
	e++;
	nx[e] = hd[u];
	to[e] = v;
	hd[u] = e;
}
void dfs(int x, int f) {
	for (int i = hd[x]; i; i = nx[i]) {
		int y = to[i];
		if (y != f) {
			fa[y] = x;
			dfs(y, x);
		}
	}
}
int main() {
	cin >> n >> l;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	for (int i = 1; i <= n; i++) {
		cin >> h[i];
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= 40; j++) {
			tg[i][j] = 1;
		}
	}
	dfs(1, 0);
	cin >> q;
	while (q--) {
		int o;
		cin >> o;
		switch (o) {
			case 1: {
				int x, d, w;
				cin >> x >> d >> w;
				while (d >= 0) {
					tg[x][d] = (long long) tg[x][d] * w % l;
					if (d >= 1) tg[x][d-1] = (long long) tg[x][d-1] * w % l;
					if (x == 1) {
						for (int i = 0; i <= d - 2; i++) {
							tg[x][i] = (long long) tg[x][i] * w % l;
						}
						break;
					}
					d--;
					x = fa[x];
				}
				break;
			}
			case 2: {
				int x;
				cin >> x;
				int ans = h[x];
				for (int i = 0; x && i <= 40; i++, x = fa[x]) {
					ans = (long long) ans * tg[x][i] % l;
				}
				cout << ans << endl;
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：xs_siqi (赞：3)

赛时两个半小时才过。其实不难。

维护状态比较多，并且考虑到这道题要做的事情是放在一棵无根树上的，显然难以数据结构。

观察到 $d$ 比较小，于是考虑能否设计一个基于 $d$ 的算法。

对于每个节点如果我们及时修改标记那么有可能被压成 $n$ 的级别。但是我们钦定一个度为 $1$ 的节点为根节点，如果只向父亲打标记，那么它必然最多只用打 $40$ 个。

那么怎么向儿子打标记？我们可以考虑先往这个点本身打个标记，称为“儿子标记”好了。然后当儿子要计数的时候，只需要向上面 $40$ 个父亲看看有没有“儿子标记”即可。儿子要计数的时候肯定是不用向下看的，下面的已经往上打过了。

然后我们继续考虑一件事：如何打“儿子标记”。容易想到我们可以记录两维，第一维表示到哪个点，第二维表示这个点向下的最深深度。每次每个点向上的时候，我们只要看看标记深度就可以了。这样的复杂度是 $O(nd^2)$ 的，并考虑到输入量大和取模数量多的原因，不足以通过本题。

然后可以发现一件事情：当我们每次打标记的时候，我们可以做一个后缀和。因为显然如果这个点能触及向下深度为 $d$ 的点，也就必然能触及向下深度区间为 $[0,d]$ 的所有点。我们在修改的时候记一个后缀和就只需要在一个要打标记的点上记，时间复杂度就变成 $O(nd)$ 了。但是这个东西是假的。赛时第一个小时就一直持续这个思路，然后持续一个小时都是 $9$ 分的高分。

为什么说这个东西是假的呢？比如说，我们想象一个树，它只有二叉并且每个方向都只有一个节点，也就是总共只有三个节点的二叉树。这个时候你从左子树向上打一个 $d=2$ 的标记是打不到右子树的，违反了常理。

有人说我不是已经钦定根节点度为 $1$ 了吗。但是只有根有这个性质，其它点不可能全是单叉，必定会有这种情况的出现。

所以我们考虑改进一下刚刚的算法。我们打标记的时候不做后缀和了。我们往父亲方向打子树的标记。

首先第一个想法肯定是，既然打一个标记不行，那我就把这个点和它的所有距离不超过 $d$ 的全部打个后缀和标记不行吗？先不提这个东西又变回 $O(nd^2)$ 了，而且这样考虑我的原始操作：对于每个点询问的时候向父亲处乘标记，这样这个标记不是会被重复乘上很多次了吗。如果你觉得我这样讲有点抽象，可以看下面的样例。

以 $1$ 为根，$2$ 连 $1$，$3$ 连 $1$，$4$ 连 $2$。我的 $4$ 号点出现了一个乘 $z$，距离为 $3$ 的操作，然后开始询问。这样虽然你的 $1,3$ 号点处理对了，但是当我询问 $4$ 的时候，你的答案变成了 $z^3$。这是不正确的。

那么我们就会很自然的想到，如果这样打标记不行那我把子树的标记消掉不就好了吗。

具体地，比如说我要打一个区间为 $[1,3]$ 的标记，原来我是要给这个点和它距离内的所有父亲打一个标记然后做后缀和对吧。那么现在转化为我先给这个点打两个标记，再给他的父亲打两个标记，再给它父亲的父亲打两个标记，标记就分别为这六个三元组：$(u,z,3),(u,z,2),(fa_u,z,2),(fa_u,z,1),(fa_{fa_u},z,1),(fa_{fa_u},z,0)$。

这样我们把多余的标记 $(u,z,1),(u,z,0),(fa_u,z,0)$ 消完了。

注意到一件事情：模数不是质数。但是我们发现一个规律：对于一个点，保留的两个数呈等差序列下降，每组公差为 $1$，且每组两个数的差也是 $1$。对于每个点只需要修改两个标记，这样甚至直接变成 $O(nd)$ 了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4e5+5;
int q,n,mod,h[maxn],fa[maxn],fir[maxn],to[maxn],nxt[maxn],f[maxn],s[maxn][45],op,x,y,z,cnt,res,tot,p;
void add(int x,int y)<%to[++tot]=y,nxt[tot]=fir[x],fir[x]=tot;%>
void find(int u,int fat)<%int res=0;for(int i=fir[u];i;i=nxt[i])if(to[i]!=fat)find(to[i],u),res=1;if(!res)p=u;%>
void dfs(int u,int fat)<%fa[u]=fat;for(int i=fir[u];i;i=nxt[i])if(to[i]!=fat)dfs(to[i],u);%>
int main(){
	scanf("%d%d",&n,&mod);
	for(int i=1;i<n;i++)
		scanf("%d%d",&x,&y),
		add(x,y),add(y,x);
	find(1,0);dfs(p,0);
	for(int i=1;i<=n;i++)scanf("%d",&h[i]),h[i]%=mod,f[i]=1;
	for(int i=1;i<=n;i++)for(int j=0;j<=40;j++)s[i][j]=1;
	scanf("%d",&q);
	while(q--){
		cnt=0;scanf("%d%d",&op,&x);
		if(op==1){
//			cout<<x<<"sbsbsbsbsbsb"<<endl;
			scanf("%d%d",&y,&z);
			s[x][y]=1ll*s[x][y]*z%mod;
			if(y>0)s[x][y-1]=1ll*s[x][y-1]*z%mod;
//			for(int i=0;i<=y;i++)s[x][i]=1ll*s[x][i]*z%mod;
			while(fa[x]&&cnt<y){
				x=fa[x],cnt++;
				s[x][y-cnt]=1ll*s[x][y-cnt]*z%mod;
				if(y-cnt>0)s[x][y-cnt-1]=1ll*s[x][y-cnt-1]*z%mod;}
//				f[x]=1ll*f[x]*z%mod;
			if(!fa[x])
				for(int i=0;i<=y-cnt-2;i++)s[x][i]=1ll*s[x][i]*z%mod;}
		if(op==2){
			res=1ll*f[x]*h[x]%mod;
			while(x&&cnt<=40){
				res=1ll*res*s[x][cnt]%mod;
				x=fa[x];cnt++;}
			printf("%d\n",res);}}
	return 0;}
```


---

## 作者：云浅知处 (赞：2)

对于修改，如果修改了和 $u$ 距离不超过 $D$ 的一个点 $v$，我们发现在 $\text{LCA}(u,v)$ 处计算贡献似乎不可避免地要带上 log。设 $\text{dist}(u,v)=x\le D$，我们考虑在 $\text{LCA}$ 的 $\lfloor\frac{D-x}{2}\rfloor$ 级祖先 $p$ 的位置计算贡献。

那么要求 $\text{dist}(u,p)+\text{dist}(p,v)=D$ 或者 $D-1$。可以发现，这样的确能不重不漏地统计完所有贡献。具体来说，对每个点 $u$ 我们记录 $f_{u,i}$ 表示 $u$ 子树内和他距离为 $i$ 的所有点进行的修改。修改时我们枚举 $u$ 的祖先 $p$，将 $f_{p,D-\text{dist}(u,p)}$ 和 $f_{p,D-1-\text{dist}(u,p)}$ 计入这次贡献。查询时枚举 $v$ 的祖先 $p$，把 $f_{p,\text{dist}(u,p)}$ 累计进答案。

有一个细节是 $\text{LCA}$ 可能不存在 $\lfloor\frac{D-x}{2}\rfloor$ 级祖先，我们在根节点往上再加 $D$ 个点即可。

总复杂度 $O((N+Q)D)$。常数非常小，目测应该比点分树的 $O((N+Q)\log^2N)$ 做法要快很多。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mk make_pair
#define fi first
#define se second

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const int N=3e5+5;
const int D=45;

int n,mod,f[N][D],fa[N],a[N];
void mul(int &x,int v){x=1ll*x*v%mod;}
vector<int>G[N];
void dfs(int u){
	for(int v:G[u])if(v!=fa[u])fa[v]=u,dfs(v);
}

signed main(void){

	n=read(),mod=read();
	for(int i=2;i<=n;i++){
		int u=read(),v=read();
		G[u].emplace_back(v),G[v].emplace_back(u);
	}
	int lim=40,root=n+lim;
	for(int i=n+1;i<n+lim;i++)G[i+1].emplace_back(i);G[n+1].emplace_back(1);
	for(int i=1;i<=n;i++)a[i]=read();
	dfs(root);
	
	for(int i=1;i<=n+lim;i++)for(int j=0;j<D;j++)f[i][j]=1;
	
	int q=read();
	for(int _=1;_<=q;_++){
		int op=read();
		if(op==1){
			int x=read(),d=read(),w=read();
			for(int i=0;i<=d;i++){
				mul(f[x][d-i],w);
				if(i<d)mul(f[x][d-i-1],w);
				x=fa[x];
			}
		}
		if(op==2){
			int x=read(),res=a[x];
			for(int i=0;i<=lim;i++)mul(res,f[x][i]),x=fa[x];
			cout<<res<<'\n';
		}
	}

	return 0;
}
```

---

## 作者：A2ure_Sky (赞：0)

> [题目传送门](https://www.luogu.com.cn/problem/P9527)
> 树上问题，ad-hoc。

## 题意

维护一棵带点权的树，一次修改会将距离点 $X$ 不超过 $D$ 的所有点乘上 $W$。单点查询。注意 $D\le40$。

## 题目

方法与题解区的略有不同，但本质相同，是另一种思维路径。

肯定要利用 $D\le40$ 针对其可以设计出一种搜寻修改标记的方法。

设修改标记 $f_{x,d}$ 表示将距离点 $X$ 不超过 $D$ 的所有点都乘上 $f_{x,d}$。

修改是一圈一圈覆盖开的，但是我们没有必要全部打上修改标记。

很容易想到对于一次修改只给它的祖先打上标记。对于标记 $f_{x,d}$，对它的父亲打上 $f_{fa_x,d-1}$，再递归下去修改，复杂度 $O(D)$。

对于查询，我们只需要从一个点往上最多跳 $40$ 次，就能找到所有的标记。如果跳的次数 $p$ 要小于等于标记的 $d$，那么就可以算上。

如图，显然**不会漏贡献**，下面我们都记蓝色是修改，红色是查询。

![](https://cdn.luogu.com.cn/upload/image_hosting/eivzzqk5.png)

---

接下来的问题就是往上跳的过程中可能会多次计算一次修改的贡献，导致**计算重复**。

这里我发现了一个重要性质，可以想象修改和查询是同时往上跳的，那么我们会发现 $p$ 会不断 $+1$，$d$ 会不断 $-1$，每次 $p$ 和 $d$ 的差值会 $-2$，所以只需令在 $p=d$ 或 $p+1=d$ 时才计算贡献就行，由于每次差值是 $-2$ 的，所以可能会刚好差 $1$，这样就**不重不漏**了。

如图，对应两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/zonpgbyn.png)

---

最后的问题就是如果跳到根节点时 $d>0$ 怎么办？我当时唐了很久，觉得这样我的方法假了。但是实际上很简单，由于根节点上面没有节点了，所以不用管计算重复的问题，直接全部截留在根节点，给 $d' \in [0,d]$ 全部打上标记就行了。还有一种方法就是在根节点上方建立 $40$ 个虚拟节点，不过没必要。 

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define eb emplace_back

using namespace std;
const int N=2e5+5;
const int D=45;

int n,l,q;
int h[N],fa[N],f[N][D];
vector<int> e[N];

void dfs(int u,int da){
    fa[u]=da;
    for(auto v:e[u]) if(v!=da) dfs(v,u);
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n>>l;
    for(int i=1,u,v;i<n;i++) cin>>u>>v,e[u].eb(v),e[v].eb(u);
    for(int i=1;i<=n;i++) cin>>h[i];
    for(int i=1;i<=n;i++) 
        for(int j=0;j<D;j++) f[i][j]=1; 
    dfs(1,1);

    cin>>q;
    while(q--){
        int op,x,d,w;
        cin>>op>>x;
        if(op==1){
            cin>>d>>w;
            while(d>=0&&x!=1){
                f[x][d]=f[x][d]*w%l;
                d--;
                x=fa[x];
            }
            if(x==1) for(int i=0;i<=d;i++) f[1][i]=f[1][i]*w%l;
        }else{
            int d=0;
            int ans=h[x];
            while(d<=40&&x!=1){
                ans=ans*f[x][d]%l*f[x][d+1]%l;
                x=fa[x];
                d++;
            }
            if(x==1) ans=ans*f[1][d]%l; 
            cout<<ans<<"\n";
        }
    }
    return 0;
}
```

> 题外话：糖丸了，蓝题想了一个晚上，一直在想标记到根节点的时候怎么办。。。

---

## 作者：chenhouyuan (赞：0)

首先注意到 $d\le40$ 这说明我们暴力打标记是可行的！具体的，我们记 $tag_{i,j}$ 表示 $i$ 子树中和 $i$ 的距离恰为 $j$ 的点的标记。接着考虑树上和一个点 $x$ 的距离小于等于 $d$ 的点在哪里，我们发现它们在 $x$ 以及 $x$ 的祖先的子树中，那么就有打标记和查询的方法了：记当前走到了 $x$ 的 $i$ 级祖先 $father_{x,i}$，我们更新 $tag_{father_{x,i},d-i}$ 和 $tag_{father_{x,i},d-i-1}$，至于 $father_{x,i}$ 子树中的其他点会在跳到其他的祖先时被打上标记，查询时将它和它祖先对应的标记乘起来即可。

注意跳祖先跳到 $1$ 时有一些细节。
#### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2e5+5;
ll n,l,f[N],h[N],q,tag[N][45];
vector<ll>e[N];
void dfs(ll x,ll fa){
	f[x]=fa;
	for(ll i:e[x]){
		if(i!=fa)dfs(i,x);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>l;
	for(ll i=1;i<n;i++){
		ll u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,1);
	for(ll i=1;i<=n;i++){
		cin>>h[i];
		for(ll j=0;j<45;j++)tag[i][j]=1;
	}
	cin>>q;
	while(q--){
		ll op;
		cin>>op;
		if(op==1){
			ll x,d,w;
			cin>>x>>d>>w;
			for(ll i=0;i<=d;i++){
				tag[x][d-i]=tag[x][d-i]*w%l;
				if(d==i)break;
				tag[x][d-i-1]=tag[x][d-i-1]*w%l;
				if(x==1)i++;
				x=f[x];
			}
		}
		else{
			ll x,ans;
			cin>>x;
			ans=h[x];
			for(ll i=0;i<=40;i++){
				ans=ans*tag[x][i]%l;
				if(x==1)break;
				x=f[x];
			}
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：_shining (赞：0)

### [$\texttt{P9527 [JOISC 2022] 洒水器}$](https://www.luogu.com.cn/problem/P9527)

首先，直接思考正解比较困难，那我们不妨从特殊性质开始考虑。我们发现，对于 $d\le1$ 的情况是好做的，可以直接把他的父节点，和它的儿子们以及自己打上标记。但是如果是个菊花图的话，时间复杂度可能达到 $\mathcal{O(nq)}$，直接 TLE。

我们不妨继续思考一下，发现 $d\le40$。容易发现一个点只有一个父节点，而它的儿子可能有很多个，那么我们是否可以将标记打给父亲。定义 $tag_{u,d}$ 表示在以 $u$ 为根的子树中距离 $\le d$ 的标记，我们每次往祖先打标记，查询时直接暴力查询你的祖先们的标记，最后累乘即可得到答案。

接下来考虑打标记，对于一次操作 $u,d,w$，我们令 $fat$ 表示 $u$ 的祖先，如何将 $tag_{u,d}$ 传递给 $fat$ 呢？容易得到：$tag_{fat,d-dis(u,fat)}$ 是需要打标记的，其中 $dis(u,fat)$ 表示 $u\to fat$ 的距离。

然而，直接打标记会有重复的标记，那我们是否可以消除标记？形式化的说，令 $fat$ 有一个儿子 $v$ 且 $u$ 在 $v$ 的子树中，对于 $tag_{v,d-dis(u,fat)-1}$ 除以 $w$ 即可。**因为 $v\in fat.son$，而且 $v$ 肯定也是 $u$ 的一个祖先，所以 $v$ 会被算两次。** 而 $tag_{v,d-dis(u,fat)-1}$ 也就是 $tag_{v,d-dis(u,v)-2}$。

但是问题来了，学过数论的都知道，一个数在模意义下可能没有逆元。对于一次操作，对 $v$ 的影响为 $tag_{v,d-dis(u,v)}$ 乘 $w$，$tag_{v,d-dis(u,v)-2}$ 除以 $w$。那我们就**换个定义**，改 $tag_{u,d}$ 为以 $u$ 为根的子树中距离 $=d$ 的标记，于是上文操作的 $tag_{v,d-dis(u,v)-2}$ 除以 $w$ 会与 $tag_{v,d-dis(u,v)}$ 的乘 $w$ 抵消，只剩下 $tag_{v,d-dis(u,v)}$ 和 $tag_{v,d-dis(u,v)-1}$ 乘 $w$ 的操作。这样的时间复杂度为 $\mathcal{O(qd+n)}$。

**注意：** 不开 $\texttt{long long}$ 见祖宗。

```cpp
#include <iostream>
#include <vector>
#define ll long long
#define pb push_back
#define ull unsigned long long
#define rep(i, j, k) for(int i = j; i <= k; i++)
#define rop(i, j, k) for(int i = j; i >= k; i--)
using namespace std;
const int N = 2e5 + 5;
int n, m, l, h[N], fa[N];
ll tag[N][45];
vector<int> g[N];
inline void dfs(int u, int fat)
{
	fa[u] = fat;
	rep(i, 0, g[u].size() - 1){
		int v = g[u][i];
		if(v == fat) continue;
		dfs(v, u);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> l;
	rep(i, 1, n - 1){
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	rep(i, 1, n) cin >> h[i];
	rep(i, 1, n) rep(j, 0, 40) tag[i][j] = 1;
	dfs(1, 0);
	cin >> m;
	rep(i, 1, m){
		int t, x, d, w;
		cin >> t >> x;
		if(t == 1){
			cin >> d >> w;
			while(d >= 0 && x){
				if(x > 1) tag[x][d] = tag[x][d] * w % l, tag[x][d - 1] = tag[x][d - 1] * w % l;
				else{
					rep(j, 0, d) tag[x][j] = tag[x][j] * w % l;
					break;
				} 
				d--;
				x = fa[x];
			}
		}
		else{
			ll res = h[x];
			rep(j, 0, 40){
				if(!x) break;
				res *= tag[x][j];
				res %= l;
				x = fa[x];
			}
			cout << res << "\n";
		}
	}
	return 0;
}
```

---

## 作者：kkxacj (赞：0)

#### 思路

乍一看很不可做，然后发现 $d \le 40$，考虑从此入手。

首先对于操作 $1$，考虑向上跳 $d$ 次，记 $sum_{i,j}$ 表示第 $i$ 个数对下面 $j$ 层可以乘上多少贡献，初值全为 $1$，每次向上跳，将 $d-1$，然后 $sum_{i,d-1} \times w$，若无法往上跳就结束。

但上面这个有个问题，就是我查询时如果直接暴力算贡献，就会算重。

分别看一下对于其中一个操作 $2$ 和其中一个操作 $1$ 的关系，如图:

![](https://cdn.luogu.com.cn/upload/image_hosting/5onzesex.png)

这里黄色是操作 $2$，红色时是操作 $1$，如果每次算贡献我都乘上 $sum_{i,j},sum_{i,j+1}$，那么刚好能乘上操作 $2$ 的贡献，因为这样一定会相交，且只会相交一次，当然这是有前提的，就是能够向上跳足够的次数。

如果不够怎么办？我们默认 $1$ 为根，直接计算 $sum_{1,j}$ 到 $sum_{1,40}$ 就行了。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
const int N = 2e5+10;
int n,l,op,x,y,d,q,a[N],head[N],cnt,fa[N],sum[N][50],ans,r; 
struct w
{
	int to,nxt;
}b[N<<1];
inline void add(int x,int y)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	fa[x] = y;
	for(int i = head[x];i;i = b[i].nxt)
		if(fa[x] != b[i].to) dfs(b[i].to,x);
}
signed main()
{
	read(n),read(l);
	for(int i = 1;i < n;i++) read(x),read(y),add(x,y),add(y,x);
	for(int i = 1;i <= n;i++) read(a[i]);
	for(int i = 1;i <= n;i++)
		for(int j = 0;j <= 40;j++) 
			sum[i][j] = 1;
	read(q);
	dfs(1,0);
	while(q--)
	{
		read(op),read(x);
		if(op == 1) 
		{
			read(d),read(y);
			for(int i = d,j = x;i >= 0 && j;i--,j = fa[j])
				sum[j][i] = sum[j][i]*y%l;
		}
		else 
		{
			ans = a[x];
			for(int i = 0;i <= 40;i++) 
			{
				if(!fa[x]) r = 40;
				else r = min(40ll,i+1);
				for(int j = i;j <= r;j++) ans = ans*sum[x][j]%l;
				x = fa[x];
				if(!x) break;
			} 
			print(ans),pc('\n');
		}
	}
	flush();
	return 0; 
}
```

---

## 作者：P7GAB (赞：0)

### 题意

给定一棵 $n$ 个点的树，要求支持两种操作。

- `1 x d w`，使所有和点 $x$ 之间距离 $\le d$ 的点乘以 $w$ 并模一个给定的数 $L$。

- `2 x`，查询点 $x$ 的值。

### 分析

本题的代码量其实不大，就我而言，难度主要在能想到如何利用 $d\le40$ 这个条件上。

这是一棵无根树，维护的信息比较杂，没有什么数据结构能比较好的去解决这个问题，所以理应放弃那些对数据结构奇奇怪怪的想法。

虽说如此，在同机房大佬的指点下，我们有了一个分块加猫树的做法（正确性未知,应该是对的）。但在代码突破 3KB 大关而且感觉才写了不到一半的情况下果断弃疗（有能写出来的私信我一下）。

正如前面所说，$d\le40$ 实在太小了，小到都可以上暴力了。

很显然，如果直接修改每个节点，那 $n\le 2\times10^5$ 会直接教你做人。但如果我们只管父亲，至多也就 $40$ 次。

如果涉及到了儿子，就自己给自己打个标记，然后到了儿子的时候，直接只管 $40$ 个父亲有没有标记就好了。

但直接这样做是不行的,时间复杂度有 $O(nd^2)$ 之高，妥妥超时，所以我们需要优化。

有没有可能把 $\le d$ 的点都只标记一次呢？苦思冥想了许久之后，有了如下做法。

设 $s_{x,d}$ 表示点 $x$ 的子树中距离点 $x$ 为 $d$ 的点的标记。我们只需要对 $x$ 的 $g$ 级祖先在 $s_{x,d-g}$ 和 $s_{x,d-g-1}$ 处打标记，这样每个点就刚刚好只标记一次了。

这样时间复杂度就被优化成了 $O(nd)$ 的，完美通过。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+223;
#define int long long
int n,q,L;
struct node {
	int to,nxt;
} edge[maxn<<1];
int head[maxn],cnt=0;
int h[maxn],fa[maxn],s[maxn][41];
void add(int u,int v) {
	cnt++;
	edge[cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int u,int fath) {
	fa[u]=fath;
	for(int i=head[u]; i; i=edge[i].nxt) {
		int v=edge[i].to;
		if(v!=fath)
			dfs(v,u);
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>L;
	for(int i=1; i<n; i++) {
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}

	for(int i=1; i<=n; i++)
		cin>>h[i];
	for(int i=1; i<=40; i++) {
		int u=n,v=++n;
		add(u,v);
		add(v,u);
	}
	for(int i=1; i<=n; i++)
		for(int j=0; j<=40; j++)
			s[i][j]=1;
	dfs(n,0);
	cin>>q;
	while(q--) {
		int op,x,d,w;
		cin>>op;
		if(op==1) {
			cin>>x>>d>>w;
			while(d>=0) {
				s[x][d]=(s[x][d]*w)%L;
				if(d>0)
					s[x][d-1]=(s[x][d-1]*w)%L;
				x=fa[x];
				d--;
			}
		} else {
			cin>>x;
			int ans=h[x];
			int d=0;
			while(d<=40) {
				ans=(ans*s[x][d])%L;
				x=fa[x];
				d++;
			}
			cout<<ans<<endl;
		}
	}
	return 0;
}
```


---

## 作者：cjy1024 (赞：0)

# P9527 [JOISC 2022] 洒水器题解

更适合 DS 宝宝体质的做法。

## 题意简述

给定一颗 $n$ 个点的树，点有点权 $h_i$，有两种操作：

1. 让树上到点 $u$ 的距离不超过 $d$ 的所有点的点权变为 $h_i \times W_k \bmod L$，$L$ 初始给定。

2. 查询点 $u$ 的点权。

## 题目分析

类似于其他题解，我们考虑对 $u$ 的 $k$ 级祖先的 $d-k$ 和 $d-k+1$ 级儿子进行操作。这时候有两种处理方式，一种就是在祖先处打上乘法标记，每次查询向上找至多 $40$ 个祖先。另一种就是本题解介绍的方式。

考虑一个求 k 级儿子的 trick。注意到相同深度处需要打标记的节点在树的 bfs 序上是连续的一段，于是可以上线段树打上一个区间乘法的标记，查询同理按照 bfs 序单点查询。（貌似树状数组不行，因为树状数组需要在左端点处抵消该操作，而 $W$ 的逆元可能不存在。）

具体实现时首先 dfs 一遍，记录子树大小与 dfs 序，同时将深度相同的点放入一个 vector 中存储。接着 bfs 一遍记录 bfs 序。修改时首先找到对应的深度 vector，然后在 vector 中二分找到 bfs 序区间，在线段树上修改即可。

时间复杂度 $O(nd \log n)$，理论能过。

后话：虽然这个方法 ~~码量又大、时间复杂度还更劣~~，但是它有更广的适用范围，如 [P5384](https://www.luogu.com.cn/problem/P5384) 就是这种求 k 级儿子 trick 的典型应用。感兴趣的人也可以在这题题解中学习更多操作 k 级儿子的方法。

---

## 作者：Louis_1346 (赞：0)

## P9527 [JOISC2022] 洒水器 题解

#### 题目描述 

给定一颗树，有两种操作。

- ``` 1 x d w ``` 表示给距离```x```小于等于```d```的节点乘上```w```。

- ```2 x``` 表示查询节点```x``` 模```L```的值。

#### 分析

对于一个节点，如果 $d=1$，那么我们可以通过如下方法优化。

我们把权值节点设置为 $0,1$ 两个不同的数组，$0$ 表示这个数本身的标记，而 $1$ 表示这个节点的儿子有多少标记。

很明显，能通过找到自己和父亲的值来很快计算出答案，也能利用这个来很快标记。类推一下，就可以得出算法。

简单来说，如果一个地方标记为距离为 $d$，则标记其 $d$ 的儿子和其 $d-1$ 的儿子，然后标记父亲 $d-1$，$d-2$ 的孩子，以此类推。

#### code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;

int w[maxn][42];
vector<int> v[maxn];
int fa[maxn],arr[maxn];
int vis[maxn];
int n,m,mod;
void dfs(int x,int f){
	vis[x]=true;
	for(int i=0;i<=40;i++){
		w[x][i]=1;
	}
	fa[x]=f;
	for(int k:v[x]){
		if(!vis[k]) dfs(k,x);
	}
}
void insert(int x,int da,int dep){
	if(dep==0){
		w[x][dep]=w[x][dep]*da%mod;
		return;
	}else if(x==1){
		for(int i=0;i<=dep;i++){
			w[x][i]=w[x][i]*da%mod;
		}
	}else{
		w[x][dep]=w[x][dep]*da%mod;
		w[x][dep-1]=w[x][dep-1]*da%mod;
		insert(fa[x],da,dep-1);
	}
}
int find(int x,int dep){
	if(dep>40) return 1;
	else if(x==0) return 1;
	else return find(fa[x],dep+1)%mod*w[x][dep]%mod;
}
signed main(){
	freopen("trees.in","r",stdin);
	freopen("trees.out","w",stdout);
	scanf("%lld%lld",&n,&mod);
	int a,b;
	for(int i=1;i<n;i++){
		scanf("%lld%lld",&a,&b);
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&arr[i]);
	}
	
	dfs(1,0);
	scanf("%lld",&m);
	int c,d;
	int cnt=0;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&a,&b);
		if(a==1){
			scanf("%lld%lld",&c,&d);
			c=c%mod;
			insert(b,d,c);
		}else{
			printf("%lld\n",find(b,0)*arr[b]%mod);
		}
	}
}







```

---


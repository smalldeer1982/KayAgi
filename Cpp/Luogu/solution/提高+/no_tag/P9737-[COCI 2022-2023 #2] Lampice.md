# [COCI 2022/2023 #2] Lampice

## 题目描述

Teo 的阳台是一个长 $n+1$，宽 $m+1$ 的矩形平台，上有 $2k$ 盏彩灯，这些彩灯的颜色用 $1 \sim k$ 之间的一个数字来表示。每种颜色的彩灯都有 $2$ 盏，它们的坐标都为正整数。

Teo 认为阳台上一个区域是好的，当且仅当：

- 这个小区域是矩形，且边都与阳台的边平行。

- 对于每一种颜色的 $2$ 盏彩灯，要么都在小区域内，要么都在小区域外。

- 小区域的左上角，右下角坐标均为整数。

- 小区域的长宽都**至少**为 $2$。

现在，Teo 想请你求出在他的阳台上，有多少个小区域是好的。

**注意：左下角坐标为 $(0,0)$，右上角坐标为 $(n,m)$。**

## 说明/提示

|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$26$|对于每种颜色的灯，$x_1=y_1=0$
|$2$|$12$|$n,m\le10$，$k\le1000$|
|$3$|$35$|$m\le150$|
|$4$|$37$|无|

**本题满分 $110$ 分。**

## 样例 #1

### 输入

```
2 2 1
0 0 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3 0```

### 输出

```
36```

## 样例 #3

### 输入

```
3 3 5
0 0 0 0
0 0 1 3
0 0 3 1
1 3 3 1
1 3 3 1```

### 输出

```
7```

# 题解

## 作者：chala_tea (赞：8)

[→更好的阅读体验](https://www.luogu.com.cn/blog/chalatea/p9737)




# 题目大意

题目链接：[P9737 Lampice](https://www.luogu.com.cn/problem/P9737)

给定一个坐标系（仅使用 $(0,0)$ 至 $(n,m)$ 的部分），输入 $k$ 个整数点对 $(x_1,y_1),(x_2,y_2)$。

要求在坐标轴上找到矩形（顶点坐标均为自然数），使每个点对的两个点均在矩形内或均在矩形外，最终输出满足条件的矩形个数。

# 题解
下面将讨论各个 subtask 中的可行解法（subtask 颜色表示个人认为的难度）：

## $\text{\textcolor{#7de749}{Subtask 1 (28 pts)}}$



### 特殊条件：
对于每种颜色的灯，$x_1=y_1=0$。

### 解法：

我们发现，如果我们将 $(0,0)$ 加入矩形，则必须将所有点全部加入矩形内。由此可以进行分类讨论：

①将 $(0,0)$ 加入矩形：为将所有点全部加入矩形内，通过打擂获取最大的 $x,y$ 值 $\max(x_2),\max(y_2)$。

则 $x$ 共有 $(n+1-\max(x_2))$ 种可能，$y$ 共有 $(m+1-\max(y_2))$ 种可能。

易得，该种情况下共有 $(n+1-\max(x_2))\cdot(m+1-\max(y_2))$ 个矩形。

②不将 $(0,0)$ 加入矩形：那么它不能包含任何其他点，因此我们的目标是找到没有任何点的矩形个数。

先遍历矩形的下行 $j$ ，那么对于每一列，我们可以计算并存下该列的最大高度（也就是从第 $j$ 行开始，在不碰到点的情况下向上可以走多远）。

再遍历列 $i$ ，可以通过找到比第 $i$ 高度小的最左/最右行 来计算矩形数量
这里就不多赘述了。

→时间复杂度最终为 $O(nm^2 + k)$ ~~（懒得写程序了（）~~。



## $\text{\textcolor{#fe4f64}{Subtask 2 (12 pts)}}$


### 特殊条件：
$ n,m≤10,k≤1000$。

### 解法：

直接暴力扫每一种可能的矩形并判断是否合法。

→时间复杂度最终为 $O(k(nm)^2)$。

## $\text{\textcolor{#a64ed3}{Subtask 3 (36+12 pts)}}$

### 特殊条件：
$m≤150$。

### 解法：

此时我们可以借助**随机化**。

[→什么是uniform_int_distribution](https://blog.csdn.net/Alfa_/article/details/125215799)
（省流：均匀分布的随机数）。

给每一个颜色赋予一个唯一的值（设这个值在 $ 0 \sim 2 ^ {60} - 1 $ 之间），那么当我们判断矩形的合法性时，则可以将矩形内所有点所对应的值全部进行**异或操作**。

那么显然，当矩形合法时，内部的 xor 结果应为零，不合法则不为零。

那么此时我们可以列举每个矩形，并用该种方法检查合法性。

我们可以进行“前缀 xor 和”的预处理以更快的计算每个矩形的 xor 和。

→时间复杂度最终为 $O((nm)^2+k)$。

## $\text{\textcolor{#a64ed3}{Subtask  4  (110 pts)}}$

### 特殊条件：
无特殊条件。

### 解法：

进一步优化 sub#3 的算法：

遍历矩形左端的列 $l$ 和右端的列 $r$，再使用数组 $v[i]$ 储存第 $i$ 行中第 $l$ 列到第 $r$ 列所有值的 xor 和。

此时问题就转化为了：找到 xor 和 = 0 且 长度至少为 2 的 $v[]$ 的子数组的数量。

tips：“长度至少为 2”这一条件可以后期处理（删去长度为 1 的情况数）。

→时间复杂度最终为 $O(n^2 \cdot m \log m)$。
 
# 代码实现

```cpp
//solution of P9737 [COCI2022-2023#2] Lampice

#include <bits/stdc++.h>
using namespace std;

#define MAXN 3010
#define int long long

mt19937 rng(random_device{}());

int m,n,k;
int a[MAXN][MAXN];

int solve(vector<int> v){
	sort(v.begin(),v.end());
	int cnt=1,ans=0;
	for(int i=1;i<(int)v.size();++i){
		if (v[i]!=v[i-1]) cnt=0;
		ans+=cnt;
		++cnt;
	}
	return ans;
}

signed main(){
	//解绑快读 
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	//生成均匀分布的随机数 （见sub#3题解） 
	uniform_int_distribution<int> dis(0,(1ll<<60)-1);
	
	cin>>n>>m>>k;
	++n,++m;//这里将所有坐标+1易于后期操作 
	
	for(int i=1;i<=k;i++){
		int x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		++x1,++y1,++x2,++y2;//同理
		int u=dis(rng);
		a[x1][y1]^=u;//给点赋予随机值 
		a[x2][y2]^=u;
	}
	
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			a[i+1][j+1]^=a[i][j]^a[i+1][j]^a[i][j+1];//预处理 
			
	int ans=0;
	for(int l=0;l<n;l++)
		for(int r=l+2;r<=n;r++){//遍历矩形左右坐标 
			vector<int> v(m+1);
			for(int i=0;i<=m;i++){
				v[i]=a[l][i]^a[r][i];
			}
			ans+=solve(v);
			for(int i=0;i<m;i++){//删去长度为1的子数组 （不要忘记了哦！！！） 
				ans-=(v[i]^v[i+1])==0;
			}
		}
	
	cout<<ans<<endl;
	
	return 0;
}

```



---

## 作者：CatFromMars (赞：1)

首先考虑如何快速判定一个子矩阵合法：经典套路对于每个颜色随机映射一下，如果子矩阵内所有的颜色异或和为 $0$，说明子矩阵合法。这样出错的概率很小。维护一个二维异或和即可。

现在考虑如何快速统计。$n\le 150, m\le 1000$，发现 $n$ 很小，所以考虑维护矩形的宽和左上角所在的行。将每一列的异或和计算，记第 $i$ 列异或和为 $w_i$，问题转化为有多少区间 $[l, r]$ 满足 $w_l \operatorname{xor} w_{l+1} \operatorname{xor} \dots \operatorname{xor} w_r = 0$。维护 $w$ 的异或前缀和 $s_i$，问题转化成有多少数对 $(l, r)$ 满足 $l \le r$ 且 $s_{l - 1} = s_r$。哈希即可。时间复杂度 $O(n^2m)$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1000, M = 1000, K = 2e5;
unordered_map <ll, unordered_map <ll, ll> > f;
mt19937 rng(random_device{}());

int n, m, qk, a[N + 10][M + 10][3];
int ord[3][K + 10], sw[N + 10][M + 10][3];

mt19937 myrand(time(nullptr));
bool flag = 0;
void prep() {
	cin >> n >> m >> qk;
	n++, m++;
	uniform_int_distribution<int> dis(0,INT_MAX);//注意一定要把随机映射的范围开大一点！这样冲突的概率更小。
//这里我映射了两次，产生冲突的概率会小一点。如果映射一次的话亲测颜色的范围要到 2^60

	for(int i = 1; i <= qk; i++)
		ord[0][i] = dis(rng), ord[1][i] = dis(rng);
	for(int i = 1; i <= 5; i++)
		shuffle(ord[0] + 1, ord[0] + qk + 1, myrand);

	for(int i = 1; i <= qk; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		x1++, y1++, x2++, y2++;
		if(!(x1 == 1 && y1 == 1)) flag = 1;
		for(int opt = 0; opt < 2; opt++) {
			a[x1][y1][opt] ^= ord[opt][i];
			a[x2][y2][opt] ^= ord[opt][i];
		}
	}

	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++)
			for(int opt = 0; opt < 2; opt++) 
				sw[i][j][opt] = (sw[i - 1][j][opt] ^ a[i][j][opt]);
	}
}
inline ll count(int x, int w) {
	vector <int> vec[3];
	int last[3] = {0, 0};
	for(int i = 1; i <= m; i++) {
		for(int opt = 0; opt < 2; opt++) {
			last[opt] ^= (sw[x + w - 1][i][opt] ^ sw[x - 1][i][opt]);//计算前缀异或
			vec[opt].push_back(last[opt]);
		}
	}

	int sum = 0;
	f.clear();
	int lasta = 0, lastb = 0, a, b;
	for(int i = 0; i < m; i++) {
		a = vec[0][i], b = vec[1][i];
		sum += f[a][b];

		f[lasta][lastb]++;
		lasta = a, lastb = b;
	}//统计

	return 1ll * sum;
}
void calc1() {
	ll sum = 0;
	for(int w = 2; w <= n; w++) {
		for(int x = 1; x + w - 1 <= n; x++)
			sum += count(x, w);//宽为 w，左上角在 x 行的合法子矩阵数量
	}
	cout << sum << endl;
}
int main() {
//	freopen("read.in", "r", stdin);
	prep();
	calc1();
}
```

---

## 作者：masonpop (赞：1)

**注意翻译有误，下标从 $0$ 开始**。

暴力是 $O(n^2m^2k)$，爆炸。发现这个判断矩形是否合法耗费了大量时间。

要么 $0$ 个，要么 $2$ 个，想到了什么？异或。如果给每对点随机权值，那么这差不多等价于矩形内异或和为 $0$。碰撞概率极低，预处理异或前缀和即可做到 $O(n^2m^2+k)$。

但这样还是过不了。考虑用科技优化那个 $n^2m^2$ 的枚举。枚举左右所在的列，然后处理出这个范围内每一行的异或和。此时就是这样一个问题：选择一个长度至少为 $2$ 的子序列使其异或和为 $0$，问选法数。这是经典问题吧，预处理异或前缀和后开个桶就行了。

复杂度 $O(n^2m\log m+k)$。代码不放了。

---

## 作者：冷却心 (赞：0)

真不会哈希啊。

我们使用哈希判断一个子矩形是否合法。经典的，给每种彩灯随机赋值，一个子矩形合法当且仅当其异或和为 $0$，赋值值域很大的时候碰撞概率极小。

注意到 $n$ 很小，于是我们枚举矩形的上下边界 $[l,r]$，然后处理出每一列在 $[l,r]$ 中的异或和 $x_i$，此时一个长是 $[a,b]$ 的子矩形合法当且仅当 $x_a \oplus x_{a+1}\oplus\cdots\oplus x_b=0$。于是我们给 $x$ 前缀异或得到和数组 $s_i$，那么合法条件是 $s_{a-1}=s_b$。相当于支持插入一个属，查询和他相同的数的个数，数据结构采用哈希表即可。注意特判长宽小于 $2$ 的情况。

```cpp
#include <bits/stdc++.h>
#define LL long long
#define ull unsigned long long
using namespace std;
const int N = 200;
const int M = 1e3 + 10;
int n, m, K; ull A[N][M]; mt19937_64 Rand(time(0));
ull S[M], Pre[M];
int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> m >> K; ++ n, ++ m;
	for (int i = 1, a, b, c, d; i <= K; i ++) {
		cin >> a >> b >> c >> d; ++ a, ++ b, ++ c, ++ d;
		ull t = Rand(); A[a][b] ^= t; A[c][d] ^= t;
	}	
	ull Ans = 0;
	for (int l = 1; l <= n; l ++) {
		for (int i = 1; i <= m; i ++) S[i] = A[l][i];
		for (int r = l + 1; r <= n; r ++) {
			unordered_map<LL, int> mp; mp[0] = 1;
			for (int i = 1; i <= m; i ++) {
				S[i] ^= A[r][i], Pre[i] = Pre[i - 1] ^ S[i];
				Ans += (mp[Pre[i]] ++) - (Pre[i] == Pre[i - 1]);
			}
		}
	} cout << Ans << "\n";
	return 0;
}
```

---


# [CSP-S 2023] 消消乐

## 题目描述

小 L 现在在玩一个低配版本的消消乐，该版本的游戏是一维的，一次也只能消除两个相邻的元素。

现在，他有一个长度为 $n$ 且仅由小写字母构成的字符串。我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，使之成为一个空字符串。

其中每次操作可以从字符串中删除两个相邻的相同字符，操作后剩余字符串会拼接在一起。

小 L 想知道，这个字符串的所有非空连续子串中，有多少个是可消除的。

## 说明/提示

**【样例 1 解释】**

一共有 $5$ 个可消除的连续子串，分别是 `cc`、`acca`、`cc`、`bccb`、`accabccb`。

**【样例 2】**

见选手目录下的 `game/game2.in` 与 `game/game2.ans`。

**【样例 3】**

见选手目录下的 `game/game3.in` 与 `game/game3.ans`。

**【样例 4】**

见选手目录下的 `game/game4.in` 与 `game/game4.ans`。

**【数据范围】**

对于所有测试数据有：$1 \le n \le 2 \times 10^6$，且询问的字符串仅由小写字母构成。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $10$ | 无 |
| $6\sim 7$ | $800$ | 无 |
| $8\sim 10$ | $8000$ | 无 |
| $11\sim 12$ | $2\times 10^5$ | A |
| $13\sim 14$ | $2\times 10^5$ | B |
| $15\sim 17$ | $2\times 10^5$ | 无 |
| $18\sim 20$ | $2\times 10^6$ | 无 |

特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。

特殊性质 B：字符串仅由 `a` 和 `b` 构成。

## 样例 #1

### 输入

```
8
accabccb
```

### 输出

```
5```

# 题解

## 作者：SpadeA261 (赞：690)

写一种考场上想到的线性做法。

根据性质，若 $s[i,j-1]$ 与 $s[j,k]$ 均为合法子串，那么 $s[i,k]$ 必为合法子串。

考虑 dp，设 $f_i$ 表示以第 $i$ 位作为结尾的合法子串数量，容易得出转移方程：$f_i=f_{g_i-1}+1$，其中 $g_i$ 表示最大且能使 $s[g_i,i]$ 成为合法子串的下标。答案即为 $\sum_{i=1}^n f_i$。

由于 $g_i$ 是满足条件中最大的，因此必有 $s_i=s_{g_i}$，我们就可以按下图的方式从 $i$ 往前跳，初始时 $g_i=i-1$，之后不断令 $g_i\rightarrow g_{g_i}-1$，直到满足 $s_i=s_{g_i}$。

![1](https://cdn.luogu.com.cn/upload/image_hosting/zf20l9k8.png)

该做法的时间复杂度为 $O(|\Sigma|n)$，足以通过本题。考虑如何更进一步优化。

如果令 $h_i=g_i-1$，会发现跳的方式变成了这样，形成了若干条链，由此在每个位置记录 $a_{i,c}$，表示 $s_{a_{i,c}+1}=c$ 且能使 $[a_{i,c}+1,i]$ 成为合法子串的最大的下标。

![1](https://cdn.luogu.com.cn/upload/image_hosting/so5a7tvr.png)

每次修改的值只有 $a_{i,s_i}$，我们便可以用 $to_i$ 表示该链的链头，每次修改 $a_{to_i,s_i}$ 即可。

时间复杂度：$O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+5;
int n,dp[N],a[N][26],to[N];
char s[N];
ll ans;
int main()
{
    scanf("%d%s",&n,s+1);
    for(int i=1;i<=n;i++)
    {
        to[i]=i;
        int x=a[to[i-1]][s[i]-'a'];
        if(x) to[i]=to[x-1],dp[i]=dp[x-1]+1;
        a[to[i]][s[i]-'a']=i,ans+=dp[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Sunflower_ac (赞：524)

# 【题解】P9753 [CSP-S 2023] 消消乐

不知道考场脑子是抽了还是有病，全程都不知道在放什么屁。

特别鸣谢：@[dbxxx](https://www.luogu.com.cn/user/120868) 给我讲解了解法一的满分做法，并让我对哈希有了更加深刻的认识；@[Daidly](https://www.luogu.com.cn/user/271736) 给我讲解了解法二。

[博客园食用效果更佳](https://www.cnblogs.com/xrkforces/p/luogu-P9753.html)

## 题目链接

[P9753 [CSP-S 2023] 消消乐](https://www.luogu.com.cn/problem/P9753)

## 题意概述

给定一个长度为 $n$ 的只含小写字母的字符串，每次可以选择相邻两个字母消除，消除后前后未被消除的序列会自动拼接到一起。一个字符串是“可消除的”当且仅当对该串进行若干次上述操作后，可以变成一个空字符串。求给定的字符串有多少个**子串**是可消除的。

## 数据范围

对于所有测试数据有：$1 \le n \le 2 \times 10^6$，且询问的字符串仅由小写字母构成。

|   测试点    |    $n\leq$     | 特殊性质 |
| :---------: | :------------: | :------: |
|  $1\sim 5$  |      $10$      |    无    |
|  $6\sim 7$  |     $800$      |    无    |
| $8\sim 10$  |     $8000$     |    无    |
| $11\sim 12$ | $2\times 10^5$ |    A     |
| $13\sim 14$ | $2\times 10^5$ |    B     |
| $15\sim 17$ | $2\times 10^5$ |    无    |
| $18\sim 20$ | $2\times 10^6$ |    无    |

特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。

特殊性质 B：字符串仅由 `a` 和 `b` 构成。

## 思路分析

### 解法一

首先考虑一个字符串什么时候是“可消除的”，我们可以考虑类似于括号匹配的办法：

维护一个栈，按顺序遍历字符串，若当前字符恰好等于栈顶，则弹出栈顶；反之则将该字符入栈。若遍历结束后，栈为空，则说明该字符串是“可消除的“。

题目要求对于一个字符串所有的子串是否为“可消除的”，那么最暴力的想法就是暴力枚举该字符串的每个子串 $[l,r]$ 并做上述括号匹配来判断，若该子串是“可消除的”，则方案数 $+1$。

时间复杂度 $O(n^3)$，期望得分 35pts。

---

考虑优化。注意到对于起点 $l$ 相同的子串，只要维护过程中栈为空，那么就说明从 $l$ 到当前为止是个“可消除的”的字符串。所以我们不需要每次遍历子串中的每一个字符，维护多个栈，只需要遍历一次 $l$ 到 $n$，维护一个栈来解决，具体地：

遍历 $1$ 到 $n$ 的每一个数作为子串的起点 $l$，每次维护一个栈，遍历从 $l$ 到 $n$ 的所有字符，做一遍括号匹配，同时在过程中维护栈被弹为空的次数 $cnt$，每次让答案加上 $cnt$ 即可。

时间复杂度 $O(n^2)$，期望得分 50pts。

---

考虑特殊性质 A，发现在随机序列下，符合条件的子串非常短，那么我们只需要选择区间长度较小的子串进行验证，就可以在题目要求的时间内过掉这两个点。

该特殊性质加上 $O(n^2)$ 的做法，期望得分 60pts。

---

受 $O(n^2)$ 做法的启发，考虑如何减少枚举次数。

发现 $O(n^2)$ 做法相较于 $O(n^3)$ 做法优化在于，只需要枚举子串起点，不需要枚举子串终点，就可以通过维护一次栈来求出以 $l$ 起点的所有方案。

维护栈似乎是无法优化的，那么考虑我们如何做可以不用枚举子串起点。

发现在从 $1$ 到 $n$ 维护栈序列的时候，若对于某个时刻 $l$ 和某个时刻 $r$，两种时刻的栈序列完全相同，那么说明子串 $[l+1,r]$ 一定是可消除的。

那么我们可以通过字符串哈希来维护每个时刻的栈序列，那么栈序列相同说明该情况下哈希值完全相同，可以用 `map` 或 `unordered_map` 来维护每种哈希值出现了多少次。假设一种哈希值出现了 $k$ 次，那么其对答案的贡献就是 $\mathrm C_k^2 = \dfrac{k\times (k-1)}{2}$。即 $k$ 个相同的时刻，每次取两个时刻 $l$ 和 $r$ 构成的子串 $[l+1,r]$ 是“可消除的”。

对于每种哈希值对答案的贡献求和，即为最终答案。

时间复杂度：`map` 维护 $O(n \log n)$，`unordered_map` 维护 $O(n)$。

> 注意：若采用单模数哈希，模数如果为 $998244353$ 或 $10^9+7$，相当于是 $2\times 10^6$ 个数要落在大约是 $[0,10^9]$ 这个区间，产生哈希冲突的可能性较大。所以最好用双模数哈希/自然溢出。双模数哈希相当于随机范围是两个模数相乘，自然溢出相当于是 $[0,2^{64}]$，产生哈希冲突的可能性较小。由于自然溢出更好写，我采用的是自然溢出。

---

### 解法二

上一种解法，我们其实主要是站在「如何消」的角度展开思考的，下来我们来站在「区间合法性」的角度来思考这个问题。

> 说明：以下分析用 $s_i$ 表示给定字符串的第 $i$ 个字符。

考虑 DP，我们用 $dp_i$ 表示以 $i$ 为后缀的合法区间个数。

考虑 $dp_i$ 能由谁转移过来。枚举 $j<i$，那么假如 $dp_i$ 可以由 $dp_j$ 更新，一定说明区间 $[j+1,i]$ 是“可消除的”。要保证不重不漏，那么 $j$ 一定是 $i$ 前面满足 $[j+1,i]$ 是可消除的**最大**的位置。

要使得 $j$ 最大，那么 $[j+1,i]$ 一定是以 $i$ 结尾**最短**的合法区间，令 $lst_i=j+1$，那么 $[lst_i,i]$ 就是以 $i$ 结尾最短的”可消除区间“。所以对于每个 $i$，有：

$$
dp_i=dp_{lst_i-1}+1
$$

---

现在考虑如何找 $lst_i$。

我们假设 $dp_i$ 已经求出，考虑枚举到 $i+1$ 时，$dp_{i+1}$ 应该怎么求。对于 $s_{i+1}$，我们有以下两种情况：

- 当 $s_{lst_i-1}=s_{i+1}$ 时，把 $s_{i+1}$ 和 $s_{lst_i-1}$ 接在 $[lst_i,i]$ 的两端，合成 $[lst_i-1,i+1]$ 一并消除，此时 $lst_{i+1}=lst_i-1$；
- 当 $s_{lst_i-1}\ne s_{i+1}$ 时，那么一定是类似于 `faabccbf` 这样（现在是第二个 `f`），中间有多个合法区间连在一起，那么我们就考虑以 $lst_i-1$ 结尾的最小合法区间 $[lst_{lst_i-1},lst_i-1]$。如果 $s_{lst_{lst_i-1}-1}=s_{i+1}$，那么就可以把 $s_{i+1}$ 和 $s_{lst_{lst_i-1}-1}$ 并在 $[lst_{lst_i-1},i]$ 两端一并消除，此时，$lst_{i+1}=lst_{lst_{i-1}-1}$；如果 $s_{lst_{lst_i-1}-1}\ne s_{i+1}$，就再往前跳找 $lst_i$。

---

考虑复杂度分析。

定义「等价类」表示解法一（哈希做法）中同一个前缀栈哈希值。那么我们发现我们往前跳 $lst$ 一定是在这个哈希值内部跳 $lst$。

假如我们当前在某个等价类的最后一个字符，那么这个等价类就可以构成一个字符串。然后要在当前为止后面再加一个字符 `a`，那么实际上就是要找当前等价类字符串里的最后一个 `a`，那么时间复杂度就是等价类字符串里两个 `a` 的下标差。

即对于单个字符 `a`，查找 $lst$ 的时间复杂度就是该等价类字符串里，最后一个 `a` 的下标减去倒数第二个下标加上倒数第二个下标减去倒数第三个下标，以此类推，线性相当于等价类大小。由于等价类大小总和为线性，那么单个字符的复杂度线性，所以总复杂度就是 $O(n|\Sigma|)$，即 $O(26n)$。

## 代码实现

解法一

```cpp
//B
//哈希做法
//The Way to The Terminal Station……
#include<cstdio>
#include<iostream>
#include<map>
#include<stack>
#include<set>
#define int unsigned long long 
const int P=29;
using namespace std;
const int maxn=2e6+10;
int has[maxn],ans;

map<int,int>mp;
stack<int>q,pos;
set<int>S;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

signed main()
{
	int n=read();
	string s;
	cin>>s;s='%'+s;
	S.insert(0);
	mp[0]++;
	for(int i=1;i<=n;i++)
	{
		if(!q.empty()&&q.top()==s[i]-'a')
		{
			mp[has[pos.top()-1]]++;
			has[i]=has[pos.top()-1];
			q.pop();
			pos.pop();
		}
		else
		{
			q.push(s[i]-'a');
			pos.push(i);
			has[i]=has[i-1]*P+s[i]-'a'+1;
			S.insert(has[i]);
			mp[has[i]]++;
		}
	}
	for(int v:S)ans+=mp[v]*(mp[v]-1)/2;
	cout<<ans<<'\n';
	return 0;
}
```

解法二

```cpp
//B
//The Way to The Terminal Station…
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
const int maxn=2e6+10;
int dp[maxn],lst[maxn];

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

signed main()
{
	int n=read();
	string s;
	cin>>s;s='%'+s;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=i-1;j>0;j=lst[j]-1)
		{
			if(s[i]==s[j])
			{
				lst[i]=j;break;
			}
		}
		if(lst[i])dp[i]=dp[lst[i]-1]+1,ans+=dp[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```

如果觉得我的题解写得好，请给我的题解点个赞，谢谢！


---

## 作者：cosf (赞：65)

## [P9753](https://www.luogu.com.cn/problem/P9753)

话说这题绝对不可能是蓝。我那么弱在赛场上十分钟就想出了这道题。~~结果没开 long long 见祖宗。~~

## 思路

这道题听说是某道紫题的严重弱化版，导致 $O(|S|n)$ 的时间复杂度能过。

我们仍然可以用 dp 来解决本题。

我们注意到，可以消除的两个段落 $A, B$，将它们连起来，即 $AB$，也是可以消除的。反之，如果一个可消除的段落 $A$ 的一个前缀 $B$ 也是可消除的，那么 $A$ 除了 $B$ 的部分也是可消除的。

那么我们可以用 $last_i$ 表示以 $i$ 结束，最短的能消除的子串的开始是多少。（为了方便，如果无法消除任意字串，将其标记为 $0$）

这个可以在线推。

假设我们新加入第 $i+1$ 个字符，那么显然 $last_{i+1} \le last_i - 1$ 或者 $last_{i+1} = last_i = 0$ 或者 $last_{i+1} = i$。

稍微详细一点地处理就是，往前一段一段地跳，找到一些连在一起的可消除的字串，看看左端点左边的那个字符是不是和这个一样即可。

最后再开一个 $cnt_i$ 表示以 $i$ 结尾，最长的能消除的子串可以划分成最多多少个可消除的子串，答案即 $\sum cnt_i$。

复杂度证明较为复杂，限于篇幅，就不放了。但能确保这一定是 $O(|S|n)$ 的。

## 代码

```cpp
// O(n|S|)
#include <iostream>
using namespace std;

using ll = long long; // 不开 long long 见祖宗啊

#define MAXN 2000006

ll las[MAXN];
ll cnt[MAXN];
char val[MAXN];

int n;

int main()
{
	cin >> n;
	ll res = 0;
	for (int i = 1; i <= n; i++)
	{
		cin >> val[i];
		int j = i - 1;
		while (j > 0)
		{
			if (val[j] == val[i])
			{
				break;
			}
			j = las[j] - 1;
		}
		if (j <= 0) // cannot delete
		{
			las[i] = 0;
		}
		else // can
		{
			las[i] = j;
			cnt[i] = cnt[j - 1] + 1;
			res += cnt[i];
		}
	}
	cout << res << endl;
}

```


---

## 作者：lsj2009 (赞：65)

### 闲话

赛时想到了括号匹配和哈希，就是没想到 $[l,r]=[1,r]-[1,l-1]$，遗憾离场。/fn

### Problem

link：<https://www.luogu.com.cn/problem/P9753>。

### Solution

首先考虑一个串可以被消除时的结构：

- $\textbf{xx}$ 可以被消除。
- 若 $\textbf{A}$ 和 $\textbf{B}$ 均可以被消除，则 $\textbf{AB}$ 也可以被消除。
- 若 $\textbf{A}$ 可以被消除，则 $\textbf{xAx}$ 也可以被消除。

观察到这个东西跟“合法括号序列”的定义很像，所以我们考虑枚举左端点，然后移动右端点，开个栈去膜你，就得到了一个 $\Theta(n^2)$ 的做法。

进一步的，考虑我们固定左端点为 $1$，当右端点移动到 $k$ 时，当前栈里元素为 $S$；当右端点移动到 $k'$ 时，栈里元素再一次变成 $S$。那么说明了什么？也就是说，**$[k+1,k']$ 范围内的字符串被完全消除了**。

但其实这样子讲也不是很准确。

比如：字符串为 $\text{aaa}$，$S_3=S_1=\text{a}$，但是在我们膜你过程中，第 $2$ 个 $\text{a}$ 明明是和第 $1$ 个 $\text{a}$ 消除了，但是在我们的意思中，他似乎是和第 $3$ 个 $\text{a}$ 消除了，这样子不会多记/少记吗？

实际上并不会。感性理解一下，如果说我们加入了几个字符，把原来栈顶的几个元素给消掉了，那么我们要再加入几个字符，使得加入后得到的新栈和原来栈相等，那说明了什么？**说明了加入的几个字符和消掉的几个字符是相等的**。也就是新加入的所有字符可以互相抵消。

那么我们时时维护一个栈，每加入一个字符后计算一下其哈希值（可以时时维护），然后丢到一个 ``map`` 里，并且查一下 ``map`` 里有几个跟他相同的。

然后就做完了，复杂度 $\Theta(n\log{n})$，如果用 ``unordered_map`` 代替 ``map``，理论上可以做到 $\Theta(n)$。

### Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define ull unsigned long long
#define ld long double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=3e6+5,m=3e6;
const ull base=1145141;
ull p[N];
char t[N];
void init() {
    p[0]=1;
    rep(i,1,m)
        p[i]=p[i-1]*base;
}
map<ull,int> cnt;
signed main() {
	init();
	int n;
    scanf("%d",&n);
    scanf("%s",t+1);
    stack<char> s; ++cnt[0];
    ull res=0; ll ans=0;
    rep(i,1,n) {
        if(!s.empty()&&s.top()==t[i])
            res-=s.top()*p[s.size()],s.pop();
        else
            s.push(t[i]),res+=s.top()*p[s.size()];
        ans+=cnt[res];
        ++cnt[res];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Imiya (赞：42)

主要写写暴力跳做法的复杂度证明。

#### 做法简述：

求以每个点为结尾的极短可消段，记其左端点为 $f_i$，先设 $f_i=i-1$，然后跳 $f_i=f_{f_i}-1$，直到 $s_{f_i}=s_i$。再设 $g_i$ 表示以 $i$ 为结尾，可消段数量，$g_i=g_{f_i-1}+1$。$ans=\sum g_i$。

#### 复杂度证明：

`aabbcc...zzaabbcc...zzaabbcc...` 这样的串可以把这个做法卡成 $\frac 12n\Sigma$，所以复杂度显然大于 $O(n)$。

考虑分析一个点 $i$ 能被哪些点跳到。猜测同一个颜色只能有一个点 $j$ 跳到 $i$。

假设存在 $k>j,s_k=s_j$，$k$ 能跳到 $i$，  
因为跳的是极短可消串，所以此时 $[i+1,j-1]$ 和 $[i+1,k-1]$ 都是可消串，若 $i+1=j$ 也不影响后面的结论。  
$\therefore [j,k-1]$ 也是可消串,  
$\therefore\exist t\in(j,k),s_t=s_j$，满足从 $j$ 开始扫到 $t$ 时 $j$ 可以被删掉，  
$\therefore [j,t]$ 是可消串，  
此时若 $t$ 恰等于 $k-1$ ,那么 $k$ 显然跳到 $t$ 时就停了，不可能跳到 $i$，无需考虑。  
否则 $[t+1,k-1]$ 可消，  
$\because s_t=s_j=s_k$，  
$\therefore f_k\ge t>j>i$，$k$ 无法跳到 $i$。  
与假设矛盾，所以不存在 $k>j,s_k=s_j$，$k$ 能跳到 $i$，  
所以每个点最多被 $\Sigma=26$ 个位置跳到。复杂度为 $O(n\Sigma)$。

---

## 作者：Register_int (赞：42)

设 $dp_i$ 为以 $i$ 结尾的可消除串有多少个，每次转移就是砍掉最短的串。设这个串的左端点为 $p_i$，则 $dp_i=dp_{p_i-1}+1$。

考虑如何计算 $p_i$。容易发现，我们的最短串一定是红色部分的形式：

$$\verb!*******!\cdots\color{red}\verb!x(合法串)x!$$

否则，在串中必定可以找到一个分割点，使得左右两个字串都是合法串。所以我们的目标是，找到一个最短的合法串 $S_{j+1\sim i-1}$，满足 $s_{j}=s_i$。考虑暴力去跳：

$$\verb!x(!\cdots\color{red}\verb!合法串!\color{blue}\verb!合法串!\color{orange}\verb!合法串!\color{black}\verb!)x!$$

设我们要找的位置为 $k$，先令 $k=i-1$，然后重复使 $k\leftarrow p_k-1$，表现在上图中就是从橙色跳到蓝色开头，再从蓝色跳到红色开头，以此类推。这样即可求出第一个合法的位置。

然而复杂度还不是很稳。怎么办呢？我们可以维护一个 $q_{i,j}$，表示当 $s_{i+1}=j$ 时的 $p_i$ 值。那么我们有转移：

$$
q_{i,j}=
\begin{cases}
i&s_i=j\\
p_i-1&s_{p_i-1}=j\\
q_{p_i-1,j}&\text{else}
\end{cases}
$$

便可以得到 $p_i=q_{i-1,s_i}$。直接递推即可，时间复杂度 $O(|\Sigma| n)$，其中 $|\Sigma|$ 为字符集大小。

# AC 代码

考场代码，有些地方写复杂了。

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

const int MAXN = 2e6 + 10;

int n, p[MAXN], q[MAXN][26]; char s[MAXN];

ll dp[MAXN], ans;

int main() {
	freopen("game.in", "r", stdin);
	freopen("game.out", "w", stdout);
	scanf("%d%s", &n, s + 1);
	for (int i = 2, k; i <= n; i++) {
		if (s[i - 1] == s[i]) p[i] = i - 1;
		else p[i] = q[i - 1][s[i] - 'a'];
		for (int j = 0; j < 26; j++) {
			if (s[i] == j + 'a') q[i][j] = i;
			else if (s[p[i] - 1] == j + 'a') q[i][j] = p[i] - 1;
			else if (p[i] > 0) q[i][j] = q[p[i] - 1][j];
		}
	}
	for (int i = 2; i <= n; i++) if (p[i] > 0) dp[i] = dp[p[i] - 1] + 1;
	for (int i = 1; i <= n; i++) ans += dp[i]; printf("%lld", ans);
}
```

---

## 作者：听取MLE声一片 (赞：30)

暴力做法。

首先考虑判断一个串能否被删空，「删除相邻相同字符」等价于不区分左右括号的括号匹配。维护一个栈，从前到后遍历整个串，如果当前字符和栈顶相同就弹栈，不同就压入。如果最后栈是空的说明这个串是可消除的。

观察发现栈是可拼接的。具体的，有字符串 $A$ 和字符串 $B$。字符串 $A$ **从后向前**进行上述过程后的栈为 $C$，字符串 $B$ **从前向后**进行上述过程后的栈为 $D$。若 $C=D$，则字符串 $A$ 后面拼上字符串 $B$ 得到的串一定是可删除的。原因是处理后的栈一定无法进行内部匹配，只能两个栈对应位置两两匹配。

考虑分治。设当前分治区间为 $[L,R]$，左区间为 $[L,mid]$，右区间为 $[mid+1,R]$，区间长度 $len=R-L+1$，需要处理跨过中心点的可消除区间个数。

栈信息可以看成一个字符串，左区间和右区间各有 $O(len)$ 个字符串，问题转化为计算有多少对左右字符串相同。

可以通过先处理出左区间的信息，然后对于右区间的每个字符串，查找左区间有多少个与其相同。

观察到「弹栈」和「压入」都只会使得字符串的末尾变化一位。所以可以建出 Trie 树，记录当前位置，「弹栈」即跳到父亲，「压入」即跳到对应儿子。

左区间跳到一个位置就把这个位置加一，右区间跳到一个位置答案就加上这个位置的值。

清空的时候要尤其注意细节，时间复杂度不要带上字符集。

精细实现下对于一个区间的时间复杂度为 $O(len)$，总时间复杂度 $O(n\log n)$，空间复杂度 $n|S|$。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define ll long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=2e6+10;
const int M=26;
int n,m,a[N],b[N],fa[N],siz[N],st[N],top,p,to[N][M];
char str[N];
ll ans;
void ins(int x){
	if(to[p][x]){
		p=to[p][x];
		return;
	}
	m++;
	b[m]=x;
	fa[m]=p;
	to[p][x]=m;
	p=m;
}
void add(int x){
	if(to[p][x]){
		p=to[p][x];
		return;
	}
	m++;
	b[m]=x;
	fa[m]=p;
	to[p][x]=m;
	p=m;
}
void init(){
	for(int i=1;i<=m;i++){
		to[fa[i]][b[i]]=0;
		fa[i]=b[i]=siz[i]=0;
	}
}
void solve(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	solve(l,mid);
	solve(mid+1,r);
	m=1,p=1;
	top=0;
	for(int i=mid;i>=l;i--){
		int fl=1;
		if(top){
			if(a[i]==st[top]){
				fl=0;
				top--;
			}	
			else st[++top]=a[i];
		}
		else st[++top]=a[i];
		if(fl)ins(a[i]);
		else p=fa[p];
		siz[p]++;
	}
	top=0;
	p=1;
	for(int i=mid+1;i<=r;i++){
		int fl=1;
		if(top){
			if(a[i]==st[top]){
				fl=0;
				top--;
			}	
			else st[++top]=a[i];
		}
		else st[++top]=a[i];
		if(fl)add(a[i]);
		else p=fa[p];
		ans+=siz[p];
	}
	init();
}
int main()
{
	freopen("game.in","r",stdin);
	freopen("game.out","w",stdout);
	n=read();
	scanf("%s",str+1);
	for(int i=1;i<=n;i++)
		a[i]=str[i]-'a';
	solve(1,n);
	cout<<ans;
	return 0;
}

```


---

## 作者：sinsop90 (赞：30)

考虑一些和去年 CSP-S T3 差不多的做法，一个比较 naive 的想法是给每个字符 $u$ 赋一个随机的权值 $A_u$，并在奇数位上放上 $A_u$，在偶数位放上 $-A_u$。用一个区间的权值和是否为 $0$ 来判定，但这样显然会被 $\text{abab}$ 这种搞掉。

问题出在于上述做法中加法没有很好的性质，于是我们考虑用一些没有交换律的运算来搞定这件事，于是我们有了矩阵乘法。

考虑给每个字符 $u$ 赋一个随机矩阵 $T_u$，并在奇数位放上 $T_u$，在偶数位放上 $T^{-1}_u$，其中 $T^{-1}_u$ 为 $T_u$ 的逆，满足 $T_u \times T^{-1}_u = I$，$T^{-1}_u \times T_u = I$。不难发现这样很好地解决了上面的问题。

现在相当于查询一个区间的矩阵乘积是否为 $I$，可以转化为对于一个前缀查询有多少个前缀的矩阵乘积与其相同，这个用哈希搞就行。

以下是一些构造矩阵的方法。

首先就是洛谷矩阵求逆模板题。

假设现在要求大小为 $n \times  n$ 的矩阵 $A$ 的逆矩阵，先构造一个 $n \times  2n$ 的矩阵 $[AI]$，然后对该矩阵进行消元，即将该矩阵左边的 $n \times n$ 的位置变为 $I$，消元完毕后会得到矩阵 $[IA^{-1}]$，具体详见模板题解。这种做法强度很好。

但是考场上不一定想得起这玩意，于是下面是一些矩阵的构造。

首先有两个自己是自己的逆的矩阵。

$\begin{bmatrix}
a  & 1-a\\
a+1  & -a
\end{bmatrix}$

$\begin{bmatrix}
a  & b\\
\frac{1-a^2}{b}  & -a
\end{bmatrix}$

这两个原理一样，但显然下面的矩阵强于上面的矩阵，写上面的矩阵导致 CSP2023-S T2 变为 20pts。下面的矩阵强度足够，你只需要对于每个字符随机两个数 $a, b$。

下面是两组不自逆的矩阵，在奇数位填上 $T$，在偶数为填上 $T^{-1}$。

$\begin{bmatrix}
a  & 0\\
b  & c
\end{bmatrix}$

$\begin{bmatrix}
\frac{1}{a}  & 0\\
\frac{-b}{ac}  & \frac{1}{c}
\end{bmatrix}$

和

$\begin{bmatrix}
a  & b\\
c  & d
\end{bmatrix}$

$\begin{bmatrix}
\frac{d}{ad-bc}  & \frac{-b}{ad-bc}\\
\frac{-c}{ad-bc}  & \frac{a}{ad-bc}
\end{bmatrix}$

这两种强度都已足够，且上面那种可以手推构造，下面给出倒数第二种的代码以及一道[类似的题目](https://qoj.ac/problem/6504)。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353, maxn = 2e6 + 5, mod2 = 1e9 + 7, pri = 100007, mod3 = 1e9 + 9, mod4 = 2415351;
int n, T;
long long ans;
pair<int, int> has;
char s[maxn];
int ksm(int p, int q) {
	int res = 1;
	while(q) {
		if(q & 1) res = 1ll * res * p % mod;
		p = 1ll * p * p % mod;
		q >>= 1;
	}
	return res;
}
mt19937 rnd(114514229);
struct matrix {
	int a[2][2];
	matrix() {memset(a, 0, sizeof(a));};
	bool operator == (const matrix &rhs) const {
		if(a[0][0] == rhs.a[0][0] && a[0][1] == rhs.a[0][1] && a[1][0] == rhs.a[1][0] && a[1][1] == rhs.a[1][1]) return 1;
		return 0;
	}
	matrix operator * (const matrix &rhs) const {
		matrix res;
		for(int i = 0;i <= 1;i++) {
			for(int j = 0;j <= 1;j++) {
				for(int k = 0;k <= 1;k++) {
					res.a[i][j] = (res.a[i][j] + 1ll * a[i][k] * rhs.a[k][j]) % mod;
				}
			}
		}
		return res;
	}
}base[maxn];
struct h {
	int tot, pre[maxn], w[maxn], head[2415355];
	matrix id[maxn]; 
	void clear() {
		for(int i = 1;i <= tot;i++) {
			pre[i] = w[i] = head[i] = 0;
			id[i].a[0][0] = id[i].a[0][1] = id[i].a[1][0] = id[i].a[1][1] = 0;
		}
		tot = 0;
	}
	void insert(matrix t) {
		int has1 = 0, tmp = 0;
		for(int i = 0;i <= 1;i++) {
			for(int j = 0;j <= 1;j++) {
				has1 = (1ll * has1 * pri + t.a[i][j]) % mod4;
			}
		}
		tmp = has1;
		++ tot;
		pre[tot] = head[tmp];
		head[tmp] = tot;
		id[tot] = t;
		w[tot] ++;
	}
	int gethas(matrix t) {
		int has1 = 0, tmp = 0;
		for(int i = 0;i <= 1;i++) {
			for(int j = 0;j <= 1;j++) {
				has1 = (1ll * has1 * pri  + t.a[i][j]) % mod4;
			}
		}
		tmp = has1;
		for(int i = head[tmp];i;i = pre[i]) {
			if(id[i] == t) {
				w[i] ++;
				return w[i] - 1;
			}
		}
		insert(t);
		return 0;
	}
}Has;
int S[maxn];
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=1ll*a*res%mod;
		a=1ll*a*a%mod;b>>=1;
	}return res;
}
int a[30],b[30],c[30],d[30];
void solve() {
	ans = 0;
	cin >> n>>s;
for(int i=1;i<=26;i++){
		a[i]=rnd()%mod;
		c[i]=rnd()%mod;
		d[i]=rnd()%mod;
}
	for(int i = 1;i <= n;i++) {
		int A=c[s[i-1]-'a'+1];
		int B=a[s[i-1]-'a'+1];
		int C=d[s[i-1]-'a'+1];
		if(i&1){
			base[i].a[0][0]=1ll*ksm(A, mod - 2)%mod;
			base[i].a[1][0]=1ll*B * ksm(C,mod-2)%mod * ksm(A, mod - 2) % mod * (mod - 1) % mod;
			base[i].a[0][1]=0;
			base[i].a[1][1]=1ll*ksm(C, mod - 2)%mod;
		}else{
			base[i].a[0][0]=A;
			base[i].a[0][1]=0;
			base[i].a[1][0]=B;
			base[i].a[1][1]=C;
		}
	}
	matrix now;
	now.a[0][0] = now.a[1][1] = 1;
	Has.insert(now);
	for(int i = 1;i <= n;i++){
		now = base[i] * now;
		ans += Has.gethas(now);
	}
	cout << ans;
	Has.clear();
}
int main() {
//	freopen("game.in", "r", stdin);
//	freopen("game.out", "w", stdout);
//	cout << sizeof(Has) / 1024 / 1024 << endl;
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	T = 1;
	while(T --) solve();
	
}
```


---

## 作者：Genius_Star (赞：28)

### 题意：

我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，一次也只能消除两个相邻的元素，操作后剩余字符串会拼接在一起，使之成为一个空字符串。

问当前字符串的所有非空连续子串中，有多少个是可消除的。

### 思路：

~~一节数学课上想出来的……~~

#### 35 pts：

枚举一个区间 $[l,r]$，建立一个栈，从左到右依次判断：

- 如果与栈顶元素相同，那么栈顶元素出栈，当前元素不进栈。（即进行一次消除）

- 否则入栈。

最后看一下栈是否为空，为空则代表可以消除。

这样可以直接省去模拟的过程，时间复杂度为 $O(N^3)$。

~~代码懒得给了……~~

#### 50 pts：

因为对于区间 $[l,k]$，如果他可以被消除，则到 $k$ 处栈是空的，是对 $[k+1,r]$ 区间是不会有任何影响的。

所以我们可以这样想，考虑 $r$ 端点为 $i$ 时的区间个数，每次从 $i-1 \sim 1$ 依次入栈，只要栈为空则可以累加一次答案。

时间复杂度为：$O(N^2)$。

[50pts 代码。](https://www.luogu.com.cn/paste/erv17w23)

#### 60 pts：

在 50pts 的思路上，再次进行优化，定义 $a_i$ 为右端点为 $i$ 的区间的数量。

那么发现对于区间 $[k,r]$，如果其可以被消除，且 $k$ 是从右到左第一个可以消除的，那么只需要加上右端点为 $k-1$ 的可消除区间个数。

则我们对于每一个 $i$，从 $i-1 \sim 1$ 依次入栈，找到第一个栈空的位置 $k$，则 $a_i=a_{k-1}+1$。

最后答案为 $\sum\limits_{i=1}^n a_i$。

时间复杂度为：$O(N^2)$。

**这里主要是为正解作出铺垫，没想到洛谷上交能得 60pts。**

[60pts 代码。](https://www.luogu.com.cn/paste/pmyqsof4)

#### 100 pts：

在 60pts 的基础上再次进行优化。

我们发现，如果 $s_i=s_{i-1}$，即当前这个字符和上一个字符相等，则 $a_i=a_{i-2}+1$。

那么如果 $s_i \ne s_{i-1}$，则我们需要找到一个 $k$，使得 $[k,i-1]$ 可以消除，那么 $[k,i]$ 进行若干次操作之后只会剩下一个 $s_i$，那么只要使得 $s_{k-1}=s_i$，那么就可以进行消除，则 $a_i=a_{k-2}+1$。

那么现在我们需要快速找到到 $i-1$ 可以消除，且左端点的左边点的字符和 $s_i$ 相等的位置。

则我们定义 $b_{i,j}$ 表示在第 $i$ 个字符处，从右到左第一个可使得到 $i$ 进行若干次操作后剩下一个字符 $j$ 的位置。

那么状态转移方程应该为 $a_i=a_{b_{i-1,s_i}-1}+1$。

现在需要转移 $b_{i,j}$，注意到如果 $[k,r]$ 可以被消除，那么 $b_r$ 可以继承 $b_{k-1}$ 的值（毕竟中间一段相当于被消除了），然后设 $t=b_{i-1,s_i}-1$（即为右到左第一个可使得到 $i-1$ 进行若干次操作后剩下一个字符 $s_i$ 的位置减去 $1$，减去 $1$ 是因为这个位置也会被消除）。

那么可以将 $b_i$ 的值由 $b_t$ 继承过来，然后更新一下 $b_{i,s_i} \to t$，即中间这段消除后，左边字符为 $s_t$ 了，需要更新一下位置。

最后答案为 $\sum\limits_{i=1}^n a_i$。

时间复杂度为：$O(N \times |S|)$。（其中 $|S|$ 表示字符集的大小，这里应该为 $26$）

### 正解完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2000200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n;
int a[N];
int b[N][27];
char s[N];
ll ans=0;
int main(){
	n=read();
	scanf("%s",s+1);
	for(int i=2;i<=n;i++){
		ll t;
		if(s[i]==s[i-1]){
			a[i]=a[i-2]+1;
			t=i-2;
		}
		else{
			t=b[i-1][s[i]-'a']-1;
			if(t<0)
			  continue;
			a[i]=a[t]+1;
		}
		for(int j=0;j<26;j++)
		  b[i][j]=b[t][j];
		b[i][s[t]-'a']=t;
	}
	for(int i=1;i<=n;i++)
	  ans+=a[i];
	write(ans);
	return 0;
}
```


---

## 作者：Svemit (赞：13)

[更好的阅读体验](https://www.cnblogs.com/Svemit/p/17783904.html)

考前天天祈祷不考串串和数数结果靠这个翻盘好好好。

~~为什么都说 D 比 B 简单。~~

[题目传送门](https://www.luogu.com.cn/problem/P9753)

# Solution

按照一般的计数 dp 的状态设计，我们不妨设 $f_i$ 为以 $i$ 为右端点的合法子串个数。

最后答案是 $\sum_{i=1}^{n} f_i$。

考虑合法的子串有哪几种形式，不妨设 $A,B$ 均合法，以及单个字符 $c$。

那么合法的字串只可能为一下四种形式：

1. $A$

2. $AB$

3. $cAc$

4. $cc$

其他所有的都可以规约到这四种。

设 $lst_i$ 为最大的 $j$ 满足 $s_{[i,j]}$ 是合法子串的 $j$。

那我们的转移便是 $f_i = f_{lst_i - 1} + 1$。

加 1 是因为要把自己算上，前面的 $f_{lst_i - 1}$ 是在算第二类子串的个数。

对于 $lst_i$ 的计算直接采取暴力跳的方式即可，算法是通过左右相同的上一个相同字符的前一个的保存值转移的，如果上一个不一样，就需要继续向前匹配，如此重复，最多到字符集大小就会出现一次匹配，总复杂度是 $O(26n)$。

code

```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = (j); i <= (k); i ++)
#define per(i, j, k) for(int i = (j); i >= (k); i --)
#define fi first
#define se second
#define sz(x) (int)x.size()
#define all(x) x.begin(), x.end()
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;
const int N = 2e6 + 5, INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
int n;
string s;
LL f[N];
int lst[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> s;
	s = " " + s;
	rep(i, 1, n) {
		lst[0] = -1;
		if(s[i] == s[i - 1]) lst[i] = i - 1;
		else {
			lst[i] = -1;
			int j = i - 1;
			while(lst[j] != -1) {
				j = lst[j] - 1;
				if(s[i] == s[j]) {
					lst[i] = j;
					break;
				}
			}
		}
	}
	rep(i, 1, n) if(lst[i] != -1) f[i] = f[lst[i] - 1] + 1;
	LL res = 0;
	rep(i, 1, n) res += f[i];
	cout << res << '\n'; 
	return 0;
}
```


---

## 作者：nullqtr_pwp (赞：10)

## Statement
对于一个字符串，若每次操作可以消去相邻两个相同的字符，最后可以被删空，那么就是合法的。给定长为 $n$ 的字符串，计算有多少子串是合法的。$1 \le n \le 2 \times 10^6$。
## Solution
不需要用栈。对于长为 $n$ 的字符串 $s$，下记 $s[l: r]$（$1 \leq l \leq r \leq n$）为选择 $s[l], s[l+1], \dots, s[r]$, 将其顺次拼接得到的新字符串。

计算所有字符串的合法情况，套路化的，考场最先想到的就是令 $dp_i$ 表示以 $i$ 为左端点的答案。

我们考察一个串合法的条件。注意到，若串 $S,T$ 都是合法的，那么一定有 $ST$ 合法。那么对于左端点 $l$，可以去找最小的 $r$ 使得 $s[l:r]$ 合法。那么所有以 $l$ 为左端点的合法串 $s[l:k]$一定可以表示成 $s[l:r]+s[r+1:k]$。因为把 $s[l:r]$ 消去了之后剩下的一部分也必须要能消去。因此有转移 $f_l=f_{r+1}+1$。这里 $+1$ 是因为可以选择 $s[l:r]$ 合法。

考虑如何找 $r$，定义 $nxt_l$ 就是我们要找的 $r$。我们发现，这段合法的串，在满足 $r$ 最小时一定有 $s_l=s_r$，而中间也一定是若干合法串拼接而成。直接暴力跳到满足 $s_l=s_r$ 的位置即可。细节可以看代码。

复杂度是 $O(n|S|)=O(26n)$ 的。因为对于每种字符分开考虑，跳的指针总共跳 $O(n)$ 次。
```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#define ll long long
#define dF(i,a,b) for(int i=(a);i>=(b);i--)
#define F(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int maxn=2000005;
int f[maxn],nxt[maxn];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n; string s;
	cin>>n>>s;	
	s=" "+s;
	ll ans=0;
	dF(i,n,1){
		int j;
		for(j=i+1;j&&s[j]!=s[i];j=nxt[j]);
		if(j) ++j;
		nxt[i]=j;
	}
	dF(i,n,1) if(nxt[i]) f[i]=f[nxt[i]]+1;
	F(i,1,n) ans+=f[i];
	cout<<ans;
}
```


---

## 作者：CarroT1212 (赞：9)

冷知识：今年 S 组似乎使用纯入门组算法就能 AK……

场上主要的失误来自这一题。个人认为这题比较容易被部分分误导，当时刚开始的转化思路就歪了，到后面一直没纠正过来，连暴力都没打成，要是 T3 还挂分直接就寄掉了。一定要防止思维僵化。

### 解法分析

首先考虑怎么判断 $[l,r]$ 这段区间是否可以消除。因为能消掉的肯定要优先消掉，所以考虑整一个栈，从左到右把区间内的字符扔进去，如果被扔进去的字符和此时栈顶的字符相等，则直接把这两个字符一起删除，否则扔进栈里。可以发现当遍历完之后栈是空的，则说明这段区间可以被完全删去。于是枚举 $[l,r]$ 再遍历一遍栈模拟一下你就有 $O(n^3)$ 的 $35$ 分了！然而我没拿到。

而显然只用枚举 $l$ 然后从 $l$ 遍历到 $n$，就可以把所有左端点为 $l$ 的合法区间都拉出来，即每次栈变成空的就对应一个合法区间，于是你就有 $O(n^2)$ 的 $50$ 分了！我也没拿到。

这时考虑能不能只对 $l=1$ 跑一遍栈模拟，然后根据这一遍的结果再得到左端点不在 $1$ 的区间的答案。发现有一个非常合适的性质：如果有 $x<y$，且 $[1,x]$ 和 $[1,y]$ 对应区间的栈相同，则 $[x+1,y]$ 这一段区间的栈也一定是空的，因为遍历过程中这一段的元素都被消掉了。所以我们只需要记录遍历的过程中不同的栈状态各出现了多少次，再计算每个不同的栈状态可以对答案产生多少贡献即可。记录栈状态可以用哈希加 map 解决。

具体地，设 $[1,1],[1,2],\cdots,[1,n]$ 这些区间对应的栈结果有 $s_1,s_2,\cdots,s_m$ 这 $m$ 种，其中 $s_i$ 结果共出现了 $a_i$ 次，则答案就为 $\sum\limits_{i=1}^{m}\dfrac{a_i(a_i-1)}{2}$，即对于每一个不同的状态的 $a_i$ 个位置中任取两个左右端点可以得到 $\dfrac{a_i(a_i-1)}{2}$ 个不同的区间，它们都是合法的。

注意这题哈希冲突概率较大，最好双哈希一下。$O(n\log n)$。

### 代码

```cpp
const ll N=2e6+7,M=1e9+7,B1=127,B2=129; // 双底数
ll n,tp,ans,hsh1,hsh2,bs1[N],bs2[N];
char str[N],stk[N];
map<pll,ll> mp;
int main() {
	scanf("%lld%s",&n,str+1);
	mp[{0,0}]=bs1[0]=bs2[0]=1;
	for (ll i=1;i<=n;i++) bs1[i]=bs1[i-1]*B1%M;
	for (ll i=1;i<=n;i++) bs2[i]=bs2[i-1]*B2%M; // 预处理底数的幂
	for (ll i=1;i<=n;i++) {
		if (stk[tp]==str[i]) (hsh1-=stk[tp]*bs1[tp]%M-M)%=M,(hsh2-=stk[tp]*bs2[tp]%M-M)%=M,tp--;
		else stk[++tp]=str[i],(hsh1+=stk[tp]*bs1[tp]%M)%=M,(hsh2+=stk[tp]*bs2[tp]%M)%=M;
		ans+=mp[{hsh1,hsh2}],mp[{hsh1,hsh2}]++; // 这里在遍历过程中统计，跟上面本质相同
	}
	printf("%lld",ans);
	return 0;
}
```

11-2 upd：修了个锅。

---

## 作者：Eznibuil (赞：7)

为什么没有 Trie？为什么都是哈希和 DP？

考虑维护从头开始到每个位置的栈序列。显然栈序列相同则一定可消。考虑用一个类似 map 的东西记录每一种栈序列之前出现次数，然后对于每个栈序列先把之前出现次数累加进答案，再自增一下。

于是建 Trie 然后跳指针即可。

时间复杂度 $O(n)$。
```cpp
#include<iostream>
auto&fin{std::cin};
auto&fout{std::cout};
char s[2000003];
struct Trie
{
	struct node
	{
		int t;
		node*fa,*p[26];
	}*root,al[2000003],*pa;
	Trie(){pa=al,root=newnode();}
	node*newnode()
	{
		pa->t=0,pa->fa=nullptr;
		for(int i=0;i<26;i++)
			pa->p[i]=nullptr;
		return pa++;
	}
}t;
int main()
{
	int n;
	Trie::node*p=t.root;
	fin>>n>>s,p->t++;
	long long ans=0;
	for(int i=0;i<n;i++)
	{
		if(p->fa==nullptr||p->fa->p[s[i]-'a']!=p)
		{
			if(p->p[s[i]-'a']==nullptr)
				(p->p[s[i]-'a']=t.newnode())->fa=p;
			p=p->p[s[i]-'a'];
		}
		else
			p=p->fa;
		ans+=p->t,p->t++;
	}
	fout<<ans;
	return 0;
}
```

---

## 作者：strcmp (赞：5)

省流：同机房 dalao 的做法。

考虑 dp，设 $f_i$ 表示以 $i$ 结尾的合法子串数。

则 $f_i \leftarrow f_{j - 1} + 1$，其中 $[j,\,i]$ 是一个合法的能被删除的极小区间。

考虑 $p_i$ 表示 $[p_i,\,i]$ 能被删除，且 $p_i$ 最大。

$[i - 1, i]$ 这个区间无法消除，则考虑 $[p_{i - 1},\,i - 1]$ 这个区间一定可以被消除，且是最小的。消除后会剩下来 $p_{i - 1} - 1$ 和 $i$ 匹配，如果 $p_{i - 1} - 1$ 和 $i$ 匹配，则停止，否则考虑 $[p_{p_{i - 1} - 1}, p_{i - 1} - 1]$ 是可消除的，且最小，最后会剩下 $p_{p_{i - 1} - 1} - 1$ 和 $i$ 匹配，以此类推。

则初始时考虑 $p_i = i - 1$，若 $s_{p_i} \neq s_{i}$ 则令 $p_i \leftarrow p_{p_{i}} - 1$，即可计算出 $p_i$。

答案即为所有 $f$ 的和。

时间复杂度很玄学，大概是 $n \times {\Sigma}$ 的，在洛谷民间数据下最大点没有超过 100ms。（在值域大的情况下能被卡掉，但没有找到 $[0,\,25]$ 值域下的卡法）

```cpp
#include <bits/stdc++.h>
#define re register
using namespace std;
typedef long long int ll;
typedef long long int int128;
const int maxn = 2e6 + 10;
const int N = maxn << 1;
const ll mod = 998244353LL;
const ll inf = 1145141919810LL;	
int n; char s[maxn]; int p[maxn]; ll f[maxn];
int main() {
    memset(p, -1, sizeof(p));
	scanf("%d%s", &n, s + 1);
	for (int i = 2; i <= n; i++) {
		p[i] = i - 1;
		while (s[i] != s[p[i]] && p[i] >= 0) p[i] = p[p[i]] - 1;
		if (p[i] < 0) p[i] = -1;
	}
	for (int i = 1; i <= n; i++) if (p[i] - 1 >= 0) f[i] = f[p[i] - 1] + 1;
	ll ans = 0;
	for (int i = 1; i <= n; i++) ans += f[i];
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：CrTsIr400 (赞：4)

# CSP-S 2023 T2 一个很自然的想法

考场上我花了两个多小时想的线性，这里分享一个非常好想的单 $\log$ 做法。感谢 zhy 提供思路。

暴力 $50$ 分就是枚举左端点，往**一个方向**入栈，如果栈的大小清空了就有解。（实际有 $60$？）

那么我们**两个方向**入栈，**考虑 cdq 分治处理**。

从 $mid$ 到 $l$ 不断往左移动指针，入左栈，把每个左栈版本的哈希值存下来。

从 $mid+1$ 到 $r$ 不断往右移动指针，入右栈，判断每个右栈版本的哈希值能匹配多少个左栈。

显然因为右栈等于左栈的时候可以消完。于是这道题就结束了。而且还能直接通过 CF1223F。

```cpp
const I bas=200710241,N=2e6+10;
struct hashstack{
	I stk[N],top;LL vers[N];
	V clear(){top=0;}
	V push(I x){stk[++top]=x;vers[top]=vers[top-1]*bas+x;}
	V pop(){--top;}
	LL curv(){return vers[top];}
	V pushback(I x){
		if(stk[top]==x)pop();
		else push(x);}
}S;
gp_hash_table<LL,I>M;
I n,c[N];
LL sol(I l,I r){
	if(l>=r)return 0;
	I mid=l+r>>1;
	S.clear();M.clear();
	for(I i=mid;i>=l;--i)
		S.pushback(c[i]),
		++M[S.curv()];
	S.clear();LL ans=0;
	fo(i,mid+1,r){
		S.pushback(c[i]);
		if(M.find(S.curv())!=M.end())
			ans+=M[S.curv()];}
	return ans+sol(l,mid)+sol(mid+1,r);}
```



---

## 作者：EuphoricStar (赞：4)

考虑 dp，设 $f_i$ 为以 $i$ **结尾**的合法子串个数。如果我们能对每个 $i$，求出来 $g_i$ 表示**最大**的左端点 $l$ 使得 $[l, i]$ 是**合法串**，那么 $f_i = f_{g_i - 1} + 1$。若 $g_i$ 不存在则 $f_i = 0$。答案为 $\sum\limits_{i = 1}^n f_i$。

考虑求 $g_i$。因为 $g_i$ 是**最大**的，所以 $s_{g_i} = s_i$，并且 $[g_i + 1, i - 1]$ 是由若干个 $[g_j, j]$ 组成的合法串拼接而成。

这启发我们**连边** $i \to g_i - 1$，转化成求 $i$ 不断跳出边直到跳到字符 $s_i$ 或没有出边，并找到跳到的点。

套路地考虑**倍增**，设 $F_{i, j}$ 为点 $i$ 跳了 $2^j$ 次出边后所在的点，$G_{i, j}$ 为点 $i$ 跳了 $2^j$ 次出边后，访问过的**所有点**（包括 $i$，不包括 $i$ 跳 $2^j$ 次出边后所在的点），**出现过**的字符**集合**。由于 $|\Sigma| = 26$（$|\Sigma|$ 为字符集大小），因此可以用一个 `int` 存储。

那么求 $g_i$ 就只用跳到**最后一个**点 $j$ 使得从 $i - 1$ 跳到 $j$ 都不出现字符 $s_i$，那么 $j$ 往上跳一步就是我们想求的 $g_i$。

求出来 $g_i$ 后，令 $F_{i, 0} = g_i - 1, G_{i, 0} = \{s_i\}$，再更新倍增数组即可。

有若干细节，包括要特判 $s_{i - 1} = s_i$ 以及 $g_i$ 不存在。

时空复杂度均为 $O(n \log n)$。

事实上这种做法可拓展性不强，由于要维护 $G$ 只能做 $|\Sigma|$ 较小的情况，不适用于 CF1223F。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 2000100;
const int logn = 23;

int n, f[maxn][logn], g[maxn][logn];
ll h[maxn];
char s[maxn];

void solve() {
	scanf("%d%s", &n, s + 1);
	ll ans = 0;
	for (int i = 1; i <= n; ++i) {
		if (i > 1 && s[i] == s[i - 1]) {
			h[i] = h[i - 2] + 1;
			ans += h[i];
			f[i][0] = i - 2;
			g[i][0] = (1 << (s[i] - 'a'));
			for (int j = 1; j < 21; ++j) {
				f[i][j] = f[f[i][j - 1]][j - 1];
				g[i][j] = g[i][j - 1] | g[f[i][j - 1]][j - 1];
			}
			continue;
		}
		int u = i - 1;
		for (int j = min(__lg(i) + 1, 20); ~j; --j) {
			if ((~g[u][j]) & (1 << (s[i] - 'a'))) {
				u = f[u][j];
			}
		}
		if (!u) {
			g[i][0] = (1 << (s[i] - 'a'));
			for (int j = 1; j < 21; ++j) {
				f[i][j] = f[f[i][j - 1]][j - 1];
				g[i][j] = g[i][j - 1] | g[f[i][j - 1]][j - 1];
			}
			continue;
		}
		--u;
		h[i] = h[u] + 1;
		ans += h[i];
		f[i][0] = u;
		g[i][0] = (1 << (s[i] - 'a'));
		for (int j = 1; j < 21; ++j) {
			f[i][j] = f[f[i][j - 1]][j - 1];
			g[i][j] = g[i][j - 1] | g[f[i][j - 1]][j - 1];
		}
	}
	printf("%lld\n", ans);
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```


---

## 作者：Wf_yjqd (赞：4)

写个题解纪念一下，提供一个比较特别但好想的做法。

考场想出正解，由于健忘，在吃了点东西后忘了做法，打了暴力，险些退役。

------------

我们发现可以用一个栈模拟消除过程。

有一个非常显然的 $\operatorname{O}(n^2)$ 暴力做法：枚举左端点，然后用栈模拟右端点向后移，统计栈为空的次数。

发现左端点以左的并不影响，可以直接统计当前栈与左端点前的栈相同的情况（同时删去左边的相当于空栈）。

但这样依然是 $\operatorname{O}(n^2)$，可以用桶数组省去枚举左端点的过程，每次累加相同栈的个数。

简单地说，若经过一个区间后栈的状态没有变化，则这个区间是可以消除的子串。

可能会 MLE，所以还得将栈字符串哈希一下。

复杂度 $\operatorname{O}(n\log n)$。

------------

代码很简单，没啥好看的。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long unt;
const unt maxn=2e6+84,Base=564611849,Mod=1e17+1903;
unt hs,base[maxn],n,top,ans;
char s[maxn],st[maxn];
map<unt,unt> cnt;
int main(){
    scanf("%llu%s",&n,s+1);
    base[0]=1;
    for(unt i=1;i<=n;i++)
        base[i]=base[i-1]*Base%Mod;
    cnt[0]=1;
    for(unt i=1;i<=n;i++){
        if(top&&s[i]==st[top]){
            hs=(hs-st[top]*base[top-1]%Mod+Mod)%Mod;
            top--;
        }
        else{
            st[++top]=s[i];
            hs=(hs+st[top]*base[top-1]%Mod)%Mod;
        }
        ans+=cnt[hs];
        cnt[hs]++;
    }
    printf("%llu",ans);
    return 0;
}
```


---

## 作者：bloodstalk (赞：4)

# Solution

首先容易想到一个 $O(n^2)$ 算法：我们枚举左端点，然后从左端点开始往右扫，每次扫的时候开一个栈，如果当前栈顶和要加进来的字母是同一个字母，就把栈顶 pop 掉，否则将这个字母入栈。如果在某一时刻栈是空的，这说明从左端点到这个时刻的这一段区间就是可消的，我们让答案++。

我们考虑怎么优化这个过程，如果在某一时刻栈是空的，这也就说明，**在此时，栈顶的状态和在左端点时的状态是一样的**。于是，我们就可以只需要从 $1$ 开始从左往右扫一遍，每次加入一个新的字母时，判断它之前有多少个时候的状态跟它是一样的，这个我们可以通过 hash 来实现这个状态的存储，然后用一个桶来存储每个状态的数目，这么做即可做到近乎线性。因为 `unordered_map` 不被卡的话是 $O(1)$ 的，所以可以通过 $2\times 10^6$。 

# Code

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define ull unsigned long long
#define ll long long
#define re register
#define il inline
const int N = 2e6 + 5;
const int base = 191;
using namespace std;

int n,top,ans;
ull Hash[N];
char ch[N];
struct STACK{
	char ch;
	int id;
}stk[N];
unordered_map <ull,int> t;

il int read()
{
	int f = 0 , s = 0;
	char ch = getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1)+ (s<<3) + (ch-'0');
	return f ? -s : s;
}

signed main()
{
	n = read();
	cin >> (ch+1);
	t[0] = 1;
	for(re int i=1;i<=n;i++)
	{
		if(!top)
		{
			stk[++top] = {ch[i],i};
			Hash[i] = ch[i] - '0';
			ans += t[Hash[i]] , t[Hash[i]]++;
		}
		else
		{
			if(stk[top].ch == ch[i])
			{
				top--;
				Hash[i] = Hash[stk[top].id];
				ans += t[Hash[i]] , t[Hash[i]]++;
			}
			else
			{
				Hash[i] = Hash[stk[top].id] * base + (ch[i] - '0');
				stk[++top] = {ch[i],i};
				ans += t[Hash[i]] , t[Hash[i]]++;
			}
		}
		//cout << Hash[i] << " ";
	}
	cout << ans;
	return 0;
}
```

---


# [ROIR 2021] A+B (Day 2)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T4  [A+B](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。

## 题目描述

有三个长为 $n$ 的可能含前导零的整数 $a,b,c$，按如下方式排成三行 $n$ 列：

```
a
b
c
```
问有多少种不同的**列**的排列方式，使得被横着念出来的三个整数 $x,y,z$ 有 $x+y=z$ 成立且三个整数均没有前导零。

排列方式的个数可能很多，输出其 $\bmod \ 10^9+7$ 即可。

## 说明/提示

【样例解释1】：所有排列方式均可。

【样例解释2】：我们只计算 $10+20=30$，而不计算 $01+02=03$，因为 $03$ 含前导零。

【样例解释3】：显然有 $10121 + 21909 = 32030$ 与 $12101 + 20919 = 33020$ 两种合法等式，但由于有两个相同的列，所以它们都有两种方式得到答案，总方案数为 $2\times 2=4$。

【数据范围】：

对于所有子任务，有 $2\le n\le 2\times 10^5$。

| 子任务编号 |特殊限制| 分值 |
| :-: | :-: | :-: |
|$1$|$n\le 6$| $7$  |
|$2$|$n\le 18$| $14$ |
|$3$| $n\le 200$，读入的数字中不含 $0$ | $15$ |
|$4$|$n\le 200$| $5$  |
|$5$| $n\le 750$，读入的数字中不含 $0$ | $17$ |
|$6$|$n\le 750$| $5$  |
|$7$|读入的数字中不含 $0$| $20$ |
|$8$|无特殊限制| $17$ |

## 样例 #1

### 输入

```
123
123
246```

### 输出

```
6```

## 样例 #2

### 输入

```
01
02
03```

### 输出

```
1```

## 样例 #3

### 输入

```
01211
12099
23300```

### 输出

```
4```

## 样例 #4

### 输入

```
121
214
999```

### 输出

```
0```

# 题解

## 作者：muqi132 (赞：2)

## P9768 A+B题解
我们首先注意到每一列是绑定在一起的，同时这一列能否成立只与前一列是否要求进位以及后一列是否进位有关。

所以我们观察到每一列有两个性质：自己能能否产生进位，自己是否需要进位，我们令 $need$ 为每一列需要的进位数，$make$ 用来描述这一列是否产生进位。

首先如果 $need$ 大于 $1$ 那么我们直接输出 $0$ 即可，因为在加法中进位数不可能超过 $1$。

我们根据 $need$ 和 $make$ 的值的不同将各列划分为四种点。

1. $need=make=1$，为 $A$ 类点。
2. $need=1,make=0$，为 $B$ 类点。
3. $need=0,make=1$，为 $C$ 类点。
4. $need=make=1$，为 $D$ 类点。

令 $A,B,C,D$ 四类点的数目分别为 $A,B,C,D$。

对于首位的，其不能产生进位，也就是 $A$ 类点，$B$ 类点才能作为开头。

对于末尾的，其不能需要进位，也就是 $A$ 类点，$C$ 类点才能作为结尾。

观察性质可以发现，所有合法序列都形如$\_B\_C\_C\_B\_C…B\_C\_$。

那么 $A$ 类点只存在于 $B$ 类点前的空格以及最后一个空格(有 $B+1$ 个位置可以选择)， $D$ 类点只存在于 $C$ 类点前的空格(有 $B$ 个位置可以选择)。

注意到只能以 $A$ 类点 $B$ 类点开头，以 $A$ 类点 $C$ 类点结尾，且 $A$ 类点无法放在 $B$ 类点之后，那么可以说明每个 $B$ 类点都与一个 $C$ 类点匹配，即 $B=C$。（根据 $need$ 和 $make$ 值的不同可以判断各点之间必须满足的位置关系）。

我们首先来考虑没有前导零的情况。

如果 $B=C=0，D>0$ 的话，$A$ 类点无论是前后都不能接 $D$ 类点，答案为 $0$，如果此时 $D=0$，那么答案为 $A!$，因为 $A$ 类点可以自由排列。

如果 $B=C>0$，则依次考虑每个数的情况。

1. $A$：其放在$B$前的任意位置或者最后一个位置，也就是一共 $B$ 个挡板，求 $A$ 个球有多少种放法，答案为$\frac{(A+B)!}{B!}$。
2. $B,C$：显然都是 $B!$ (注意 $B=C$)。
3. $D$：和 $A$ 同理,但是少一个位置,答案是$\frac{(D+B-1)!}{(B-1)!}$。

最后答案就是各自相乘为$(A+B)!\times(D+B-1)!\times{B}$。

前面都没有考虑前导零，那么现在我们需要考虑了。

因为开头是 $A$ 类点或者 $B$ 类点，所以我们只需要考虑 $A$ 类点和 $B$ 类点为0的情况，分别记数量为 $A_0,B_0$。

首先是特判，$B!=C$ 或者 $B=C=0，D>0$ 都返回 $0$，若 $B=C=D=0$，则答案容易知道为:$(A-1)!(A-A_0)$，解释如下：第一个位置有 $(A-A_0)$ 种放法，后面的位置就可以全排了。

然后考虑一般情况,即 $B=C>0$。

我们考虑对于以 $A$ 类点为起点和以 $B$ 类点为起点各自单独计算 $ans_A$ 和 $ans_B$。

1. $ans_A$：对于 $A$ 类点,此时第一位为情况为 $A-A_0$ 种，后面就是 $A-1$ 个数放入 $B+1$ 个空间了，$A$ 类点的贡献为 $(A-A_0)\times\frac{(A+B-1)!}{B!}$，$B,C,D$ 类点贡献不变，则 $ans_A=(A-A_0)\times\frac{(A+B-1)!}{B!}\times{B!}\times{B!}\times\frac{(D+B-1)!}{(B-1)!}=(A-A_0)\times{B}\times(A+B-1)!\times(D+B-1)!$。

2. $ans_B$：对于 $A$ 类点，现在有 $B$ 个挡板,答案为 $\frac{(A+B-1)!}{(B-1)!}$，对于 $B$ 类点，第一个位置有 $(B-B_0)$ 种情况，后面则是 $(B-1)!$ 种情况，对于 $C,D$ 类点来说情况不变，则 $ans_B=(B-B_0)\times(B-1)!\times{B!}\times\frac{(A+B-1)!}{(B-1)!}\times\frac{(D+B-1)!}{(B-1)!}=(B-B_0)\times{B}\times(A+B-1)!\times(D+B-1)!$。

最后答案就是 $ans_A+ans_B$。

记得取模就行(代码应该不用放吧，直接套公式进去就行了)。

由于对每一位都要进行一次 $O(1)$ 的运算判断点的类型，因此复杂度是 $O(n)$ 的。

---

## 作者：MightZero (赞：2)

首先，将数位分类：

1. $a_i+b_i=c_i$，不向前进位也不需要后方进位；
2. $a_i+b_i+1=c_i$，不向前进位，需要后方进位；
3. $a_i+b_i-10=c_i$，向前进位，不需要后方进位；
4. $a_i+b_i-9=c_i$，向前进位，需要后方进位。

如果出现以上四种情况之外的数位则可以证明无论如何排列等式都不成立，答案为 $0$。

设以上四种数位的出现次数分别为 $c_1,c_2,c_3,c_4$；由于需要排除前导 $0$，计包含 $0$ 的第一类、第二类数位的总数为 $c_0$；

如果将进位关系看作边，可以注意到合法情况必然是由若干个连通块顺次排列组成；观察可知联通块有两种类型：

- 一个单独的第一类数位；

- 以一个第二类数位开头，一个第三类数位结尾，中间包含任意个第四类数位。

因此，若第二类数位与第三类数位的数量不等，或者存在第四类数位但是不存在第二类数位，则必定不存在合法方案，答案为 $0$。

对答案的贡献由以下几部分组成：

- 第二类与第三类数位的匹配，$c_2!$；
- 第四类数位任意放入第二种连通块的方案数，$\frac{(c_2+c_4-1)!}{(c_2-1)!}$；
- 连通块之间的自由排列，$(c_1+c_2-c_0)\times (c_1+c_2-1)!$。

根据乘法原理，将以上三部分相乘即可得到最终答案：

$$ans=c_2!\times(c_1+c_2-c_0)\times (c_1+c_2-1)!\times \frac{(c_2+c_4-1)!}{(c_2-1)!}$$


**关于第二部分方案数的说明**：考虑将每个第四类数位任意插入连通块时可行的位置数量，第一个第四类数位插入时为 $c_2$；每插入一个第四类数位会使可行的位置数量增加 $1$；最终的结果就是 $\prod_{i=c_2}^{c_2+c_4-1}i$，即 $\frac{(c_2+c_4-1)!}{(c_2-1)!}$。若 $c_2=c_4=0$，可以认为这部分等于 $1$。

---

## 作者：ThySecret (赞：2)

## Statement

给定可能含前导零的三个位数为 $n$ 的整数 $A,B,C$，求出排列 $p$ 的个数，使得三个整数的每一位经过排列映射后得到的 $A',B',C'$ 可以使 $A' + B' = C'$ 成立，答案对 $10^9 + 7$ 取模。

下文中定义位数从右向左，例如 $A_1$ 表示 $A$ 的个位上的数，$A_n$ 为最高位的数。

## Solution

一道并不难的排列组合计数题，复杂就在处理不同数位之间的进位问题。

### 不进位的情况

先考虑不进位的情况，每一位之间都不会互相影响，同时由于 $A',B',C'$ 不能含有前导零，我们定义 $zero$ 表示有 $0$ 的列数。

答案简洁明了，第一列放非 $0$ 列，后面随便放即可。
$$
ans = (n - zero) \times (n - 1)!
$$

### 进位的情况

如果会产生进位，那么对于 $10$ 以内的加法，会发生 $2 \times 2 = 4$ 中情况，它们分别是：

- $A_i + B_i = C_i$：此时第 $i$ 和 $i - 1$ 位均不会进位，前文已经讨论过。

- $A_i + B_i + 1 = C_i$：这一列成立的前提必须使第 $i - 1$ 位产生进位。

- $A_i + B_i - 10 = C_i$：第 $i$ 位发生进位，同时第 $i - 1$ 不发生进位。
- $A_i + B_i - 10 + 1 = C_i$：第 $i$ 位和第 $i - 1$ 位均发生进位。

如果发生了其他的情况，那么必然无解，输出 `0` 即可。

我们用数组 $cnt_{0 \sim 3}$ 分别记录这四种情况，可以发现无论什么等式，第二种情况和第三种情况的发生次数必然一样。

> 证明很简单，第二种情况要求 $i - 1$ 产生进位，$i$ 不产生进位，第三种情况要求 $i$ 产生进位，$i - 1$ 不产生进位。而由于第四种情况把进位关系传递了，可以忽略，因此：
> $$
> cnt_1 \ne cnt_2 \iff ans = 0
> $$

继续分析，发现后面两种情况不能发生在最终等式的第 $n$ 位上，第 $2,4$ 种情况不能发生在最终等式的第 $1$ 位上，而由于不能有前导零的出现，我们定义 $zero$ 统计第 $1,2$ 情况含 $0$ 列的数量。

于是我们得出发生未发生进位（情况 $1,2$）的列所能得到的排列数量 $ans1$：
$$
ans1 = (cnt_0 + cnt_1 - zero) \times (cnt_0 + cnt_1 - 1)!
$$
以及发生过进位（情况 $3,4$）的列所能得到的排列数量 $ans2$（这里要保证最后一列不能是情况 $4$）：
$$
ans2 = (cnt_2 + cnt_3 - 1) \times (cnt_2 + cnt_3 - 1)!
$$
由于前文证明的 $cnt_1 = cnt_2$，并且两次进位之间必然存在被进位的一列，因此最终序列从右到左应当为条件三和条件二交错，条件一和条件四具有传递关系，因此答案即为两者排列数量乘积：
$$
ans = ans1 \times ans2
$$

## Code

```c++
int main()
{
	for (int i = fc[0] = 1; i < N; i ++) fc[i] = fc[i - 1] * i % mod;
	
    scanf("%s", str + 1), n = strlen(str + 1);
    for (int i = 1; i <= n; i ++) a[i] = str[i] ^ 48;
    for (int i = 1; i <= n; i ++) scanf("%1lld", b + i);
    for (int i = 1; i <= n; i ++) scanf("%1lld", c + i);
    
    for (int i = 1; i <= n; i ++)
    {
    	if (a[i] + b[i] == c[i]) cnt[0] ++, zero += (!a[i] || !b[i] || !c[i]);
    	else if (a[i] + b[i] + 1 == c[i]) cnt[1] ++, zero += (!a[i] || !b[i] || !c[i]);
    	else if (a[i] + b[i] - 10 == c[i]) cnt[2] ++;
    	else if (a[i] + b[i] - 10 + 1 == c[i]) cnt[3] ++;
    	else return puts("0"), 0;
    }
    
    if (cnt[0] && !cnt[1] && !cnt[2] && !cnt[3])
    	cout << (cnt[0] - zero) * fc[cnt[0] - 1] % mod << '\n';
    else if (cnt[1] == cnt[2])
    	cout << (cnt[0] + cnt[1] - zero) * cnt[2] % mod * fc[cnt[2] + cnt[3] - 1] % mod * fc[cnt[0] + cnt[1] - 1] % mod << '\n';
    else puts("0");
    return 0;
}
```

---

## 作者：Lu_xZ (赞：2)

给每一列赋予两种属性：

1. 会不会往下一位进位：$a_i = [x_i + y_i \ge 10]$。
2. 需不需要上一位进位：$b_i = \left[x_i + y_i + 1 \equiv z_i \pmod {10}\right]$。

发现 $a_i$ 的表述还不是很完备，修改为 $a_i = [x_i + y_i + b_i \ge 10]$。

所有列转化为 $\texttt{00},\texttt{01}, \texttt{10},\texttt{11}$ 的形式。

我们发现一旦一个数的第二位为 $1$，其右边与之相邻的必然满足第一位为 $1$。

同理如果一个数的第一位为 $1$，其左边与之相邻的必然满足第二位为 $1$。

最后的答案一定形如 $\texttt{00}\  \texttt{01}\ \texttt{11}\cdots\texttt{11}\ \texttt{10} \ \texttt{00}\cdots$，即：

1. $\texttt{01}$ 和 $\texttt{10}$ 数量相等，且两两配对。
2. $\text{11}$ 只能加在一对 $\texttt{01}\cdots\texttt{10}$ 中间。
3. $\text{00}$ 只能加在开头，结尾，或一对 $\texttt{10}\cdots\texttt{01}$ 当中。

到此步为止，已经容易计数不考虑前导零的方案数了。

考虑容斥，钦定开头是 $\texttt{00}$ 或 $\texttt{01}$，满足 $x = 0\lor y = 0\lor z = 0$，剩下的部分也容易计数。

```cpp
#include<bits/stdc++.h>
#define eb emplace_back
#define ep emplace
using namespace std;

using ll = long long;
constexpr int N = 4e5 + 5, mod = 1e9 + 7;

int n, cnt[2][2][2];
char a[N], b[N], c[N];

ll fac[N], inv[N];

int s(int i, int j) {
	return cnt[i][j][0] + cnt[i][j][1];
}
ll qpow(ll a, int b = mod - 2) {
	ll c = 1;
	while(b) {
		if(b & 1) c = c * a % mod;
		b >>= 1;
		a = a * a % mod;
	}
	return c;
}
ll up(int i, int k) {
	return fac[i + k - 1] * inv[i - 1] % mod;
}
ll C(int i, int j) {
	if(j < 0) return 1;
	return fac[i] * inv[j] % mod * inv[i - j] % mod;
}
int main() {
	scanf("%s%s%s", a + 1, b + 1, c + 1);
	n = strlen(a + 1);
	for(int i = 1; i <= n; ++ i) {
		int x = a[i] - '0', y = b[i] - '0', z = c[i] - '0';
		int o = 0;
		if((x + y + 1) % 10 == z) o = 1;
		else if((x + y) % 10 != z) return cout << 0, 0;
		++ cnt[x + y + o >= 10][o][x && y && z];
	}
	if(s(0, 1) != s(1, 0) || s(1, 1) && !s(0, 1)) {
		return cout << 0, 0;
	}
	fac[0] = 1;
	for(int i = 1; i <= 2 * n; ++ i) fac[i] = i * fac[i - 1] % mod;
	inv[2 * n] = qpow(fac[2 * n]);
	for(int i = 2 * n; i >= 1; -- i) inv[i - 1] = inv[i] * i % mod;
	ll ans = fac[s(0, 1)] * fac[s(0, 1)] % mod;
	ll coef = C(s(1, 1) + s(0, 1) - 1, s(0, 1) - 1) * fac[s(1, 1)] % mod;
	ans = ans * coef % mod;
	ll tmp = ans;
	ans = ans * up(s(0, 1) + 1, s(0, 0)) % mod;
	/*
	  减去前导0
	 */
	ans = (ans + mod - tmp * cnt[0][0][0] % mod * up(s(0, 1) + 1, s(0, 0) - 1) % mod) % mod;
	tmp = fac[s(1, 0)] * fac[s(0, 1) - 1] % mod * cnt[0][1][0] % mod;
	tmp = tmp * coef % mod * up(s(0, 1), s(0, 0)) % mod;
	cout << (ans + mod - tmp) % mod;
	return 0;
}
```

---


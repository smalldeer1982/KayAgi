# [HUSTFC 2023] 基因编辑

## 题目描述

绮月有 $n$ 条 DNA 碱基序列 $S_1,S_2,\dots S_n$，每条碱基序列可以用一个仅包含 `A`、`C`、`G` 和 `T` 这四种大写字母的字符串表示。

绮月可以拼合两条 DNA 碱基序列，具体操作为将前一条碱基序列的一个前缀（可以为空）和后一条的一个后缀（可以为空）结合，如 `ACGC` 与 `CTAT` 拼合就有可能得到 `ACGCTAT`、`ACGCCTAT`、`ACAT` 或 `T`。

绮月据此定义，一个三元组 $(i,j,k)$ 是好的，当且仅当 $1\le i,j,k \le n$，$i\ne k$，$j \ne k$，且 $S_i$ 与 $S_j$ 拼合可以得到 $S_k$。

绮月想知道好的三元组的数量。

## 样例 #1

### 输入

```
3
AAA
AA
AA
```

### 输出

```
12```

## 样例 #2

### 输入

```
3
ACGC
CTAT
ACAT
```

### 输出

```
1```

## 样例 #3

### 输入

```
4
A
C
T
G
```

### 输出

```
0```

# 题解

## 作者：RegisterFault (赞：3)

没有题解，我来嘴巴一个。

首先考虑枚举被拼出的字符串 $s_k$，然后枚举分界点 $p$。$s_{[1 \sim p]}$ 是一个串的前缀，$s_{[p + 1 \sim |s|]}$ 是一个串的后缀。统计前缀为 $s_{[1 \sim p]}$ 的方案和后缀为 $s_{[p + 1 \sim |s|]}$ 的方案乘积。由于 $\sum |S| \le 2 \times 10 ^ 6$，所以枚举这部分复杂度是 $O(\sum |S|)$。

然后考虑计算方案。可以将每个字符串前缀插到一个前缀 trie 里，后缀插到一个后缀 trie 里。每个单词结尾打上标记。然后变成了子树求和问题。这是容易的。

因此时间复杂度 $O(\sum |S|)$。

---

## 作者：HPXXZYY (赞：2)

$\color{blue}{\texttt{[Solution]}}$

首先，比较显然的是，和前缀有关的问题很多都需要用到 Trie。

但是，这题还需要用到后缀。显然，把字符串倒序（即 $\texttt{ABC}$ 变成 $\texttt{CBA}$），那么后缀问题就变成了前缀问题。

接着考虑怎么计数。肯定不能枚举 $(i,j,k)$。我们稍加思考可以发现，$i,j$ 的地位是接近的，只有 $k$ 比较特殊。根据对称性（？），枚举 $i$ 大概率也得枚举 $j$，所以正解大概率是枚举 $k$。

那就往这个方向思考。枚举 $k$，再枚举拼凑的位置（即这个位置往前是 $i$ 的前缀，这个位置往后是 $j$ 的后缀），利用 Trie 树，可以查询出有多少个字符串可以贡献这个前缀，以及有多少个字符串可以贡献这个后缀。

> 举个例子来帮助理解：假设字符串 $k$ 是 $\texttt{HPXXZYY}$，依次枚举断点：
>
> - 空串$\ + \ \texttt{HPXXZYY}$，那么就需要利用 Trie 树查询有多少个字符串的前缀可以是空串，以及有多少个字符串的后缀可以是 $\texttt{HPXXZYY}$。它们就是对应的 $i,j$。
> - $\texttt{H}\ +\ \texttt{PXXZYY}$，那么就需要查询有多少个字符串前缀为 $\texttt{H}$，多少个字符串后缀为 $\texttt{PXXZYY}$。
> - ……

假设求出了可能的 $i$ 有 $x$ 个，可能的 $j$ 有 $y$ 个。答案就是 $x \times y$ 吗？

~~这么简单就不是蓝题了。~~

题目有一个限制条件：$i \not = k,j \not = k$。而显然字符串 $k$ 无论在哪个位置都可以给自己提供合适的前缀和后缀。因此答案应该是 $(x-1)(y-1)$。

吗？

通过样例 $1$ 可以知道这样还是有重复。比如字符串 $2,3$ 拼合出字符串 $1$ 的方式就不止一种：$\texttt{AAA}=\color{red}{\texttt{A}}+\color{blue}{\texttt{AA}},\color{black}{\texttt{AAA}}=\color{red}{\texttt{AA}}+\color{blue}{\texttt{A}}$。

怎么样规避这种重复？诚实的说，笔者水平有限，也没有解决方法。还是参考了 [SUNCHAOYI](https://www.luogu.com.cn/user/183603) 大佬的[题解](https://www.luogu.com.cn/article/31n2kcpw)才想到。大家不妨直接参考大佬的题解。

总时间复杂度 $O(\sum |S_{i}|)$。

$\color{blue}{\text{Code}}$

```cpp
inline int id(char c){
	switch (c){
		case 'A':return 0;
		case 'G':return 1;
		case 'C':return 2;
		case 'T':return 3;
	}
	return -1;
}

const int N=2e5+100;
const int M=2e6+100;

int n,m;
string s[N],S[N];
vector<int> Pre[N],Suf[N];

struct TrieTree{
	int ch[M][4],ecnt,num[M],fa[M];
	
	TrieTree(){memset(ch,0,sizeof(ch));ecnt=1;}
	
	inline void insert(string s){
		int len=s.length(),u=1;
		for(int i=0;i<len;i++){
			if (ch[u][id(s[i])]==0){
				ch[u][id(s[i])]=++ecnt;
				fa[ch[u][id(s[i])]]=u;
			}
			u=ch[u][id(s[i])];
			++num[u];
		}
		++num[1];
	}
	inline int pos(string s){
		int len=s.length(),u=1;
		for(int i=0;i<len;i++){
			if (ch[u][id(s[i])]==0) return -1;
			u=ch[u][id(s[i])];
		}
		return u;
	}
}pre,suf;

long long ans;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		
		int len=s[i].length();
		for(int l=len-1;l>=0;l--)
			S[i]=S[i]+s[i][l];
		
		pre.insert(s[i]);
		suf.insert(S[i]);
		m+=len;//开始想错了，这玩意似乎没什么用
	}
	
	for(int i=1;i<=n;i++){
		int now=1,lst=suf.pos(S[i]);
		
		int len=s[i].length();
		for(int j=0;j<len;j++){
			Pre[i].push_back(pre.num[now]-1);
			Suf[i].push_back(suf.num[lst]-1);
			now=pre.ch[now][id(s[i][j])];
			lst=suf.fa[lst];
		}
		Pre[i].push_back(pre.num[now]-1);
		Suf[i].push_back(suf.num[lst]-1);
	}
	
	for(int i=1;i<=n;i++){
		int len=s[i].length();
		for(int j=1;j<=len;j++)
			Pre[i][j-1]-=Pre[i][j];//避免重计
		
		for(int j=0;j<=len;j++)
			ans+=1ll*Pre[i][j]*Suf[i][j];//注意 long long
	}
	
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：2)

将题意进行简单的转换，枚举 $S_k$，然后再枚举其中的断点 $i$，将其分为 $S_k[:i]$ 和 $S_k[i + 1:]$。因此只需要求出前缀为 $S_k[:i]$ 和 $S_k[i + 1:]$ 的乘积，不难想到对前缀和后缀分别建立 $\texttt{Trie}$ 树。

但是问题并没有完全解决，手模第一个样例发现，$\texttt{A + AA}$ 和 $\texttt{AA + A}$ 均可以得到 $\texttt{AAA}$，也就是说目前算法存在重复计算。考虑一个贪心的思想，若一个较长的子串中存在所需串，则只将标记打在较长串上而不是其中的较短的所需串，显然这样标记严格覆盖的。那么，结合差分的思想，设 $f_{i,j}$ 表示以 $S_i[:j]$ 为前缀的个数，则 $f_{i,j} - f_{i,j + 1}$ 得到的一定是严格以 $S_i[:j]$ 为前缀的个数。在统计答案的时候，从长的串到短的串进行累积即可。

时间复杂度 $O(\sum |S_i|)$。代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <map>
#include <vector>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 2e6 + 5;
const int MOD = 1e9 + 7;
inline int read ();
map <char,int> mp;
int n,pre_cnt = 1,sub_cnt = 1,len[MAX],pre_ch[MAX][5],sub_ch[MAX][5],pre_tot[MAX],sub_tot[MAX];
vector <ll> pre_ans[MAX],sub_ans[MAX];
vector <char> s[MAX]; 
char str[MAX];ll ans;
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	mp['A'] = 1;mp['G'] = 2;mp['C'] = 3;mp['T'] = 4;
	n = read ();
	for (int i = 1;i <= n;++i)
	{
		scanf ("%s",str);
		len[i] = strlen (str);
		int u = 1;
		for (int j = 0;j < len[i];++j)//two Tries 
		{
			s[i].push_back (str[j]);
			int c = mp[s[i][j]];
			if (!pre_ch[u][c]) pre_ch[u][c] = ++pre_cnt;
			u = pre_ch[u][c];
			++pre_tot[u];
		}
		u = 1;
		for (int j = len[i] - 1;~j;--j)
		{
			int c = mp[s[i][j]];
			if (!sub_ch[u][c]) sub_ch[u][c] = ++sub_cnt;
			u = sub_ch[u][c];
			++sub_tot[u];
		}
	}
	for (int i = 1;i <= n;++i)
	{
		int u = 1,sum;pre_ans[i].push_back (n - 1);
		for (int j = 0;j < len[i];++j)
		{
			int c = mp[s[i][j]];
			u = pre_ch[u][c];
			pre_ans[i].push_back (pre_tot[u] - 1);//the empty situation 
			if (!u) break;
		}
		for (int j = 1;j <= len[i];++j) pre_ans[i][j - 1] -= pre_ans[i][j]; // subtraction gives a precise value 
		u = 1;sub_ans[i].push_back (n - 1);
		for (int j = len[i] - 1;~j;--j)
		{
			int c = mp[s[i][j]];
			u = sub_ch[u][c];
			sub_ans[i].push_back (sub_tot[u] - 1);
			if (!u) break;
		}
		for (int j = 1;j <= len[i];++j) sub_ans[i][j - 1] -= sub_ans[i][j];
	}	 
	for (int i = 1;i <= n;++i)
	{
		ll sum = 0;
		for (int j = 0;j <= len[i];++j)	
			sum += sub_ans[i][len[i] - j],ans += sum * pre_ans[i][j];
		// Equivalently,for j in range from len[i] to 0 is workable,but sum should be sub_pre
	}	
	printf ("%lld\n",ans);
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
```

---


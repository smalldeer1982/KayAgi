# [COCI 2023/2024 #1] Kocke

## 题目描述

在 Donald 的十三岁生日上，他的父亲给了他一套乐高积木。在这套积木中，有 $n$ 个大小相同的积木，且第 $i$ 个积木的颜色为 $i$ 。他想要用这些积木搭一面墙。

Donald 将在排成一排的乐高积木的底座上建造他的墙，底座上有 $k$ 个可以放积木的地方。他按以下方式放置积木：

- 首先，他将颜色为 $1$ 的积木放在底座的任意一个位置上。
- 对于每个颜色从 $2$ 到 $n$ 的积木，他都会选择和前一个积木相邻的位置，在对应位置的顶端放上这个积木。


他用一个长度为 $k$ 序列表示这面墙：对于第 $i$ 位，如果个位置没有积木，则是 $0$，否则是这个位置最顶端积木的颜色。

问一共有多少种不同的序列，对 $10^9+7$ 取模。

## 说明/提示

### 【样例解释#1】

可能的序列有：$(0, 3, 4), (2, 3, 4), (0, 4, 3), (1, 4, 3), (4, 3, 0), (4, 3, 2), (3, 4, 0), (3, 4, 1)$。

### 【样例解释#2】

其中一种可能的序列是 $(0,3,2,0,0)$，它的操作步骤是：

- 在第 $2$ 个位置顶端摆放编号为 $1$ 的积木。
- 在第 $3$ 个位置顶端摆放编号为 $2$ 的积木。
- 在第 $2$ 个位置顶端摆放编号为 $3$ 的积木。
- 在第 $3$ 个位置顶端摆放编号为 $4$ 的积木。
- 在第 $2$ 个位置顶端摆放编号为 $5$ 的积木。

### 【数据范围】

对于 $100\%$ 的数据，$2\leq n,k\leq 5000$。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n,k\leq 18$ | $20$ |
| $2$ | $n,k\leq 50$ | $30$ |
| $3$ | $n,k\leq 500$ | $30$ |
| $4$ | 无特殊性质 | $30$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 [COCI2022-2023](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T4 Kocke**_。

## 样例 #1

### 输入

```
4 3```

### 输出

```
8```

## 样例 #2

### 输入

```
3 5```

### 输出

```
14```

## 样例 #3

### 输入

```
100 200```

### 输出

```
410783331```

# 题解

## 作者：_determination_ (赞：8)

场上想了很久 dp 中的区间左右端点如果当成长度怎么排除在边上不能继续走的影响，后来发现自己是弱智。

首先这种计数题直接往 dp 去想，然后发现正着做要考虑覆盖，十分困难，所以考虑时光倒流，变成一个位置放上之后就不会再改变。

设 $f_{l,r,x,0/1}$ 为你的积木区间在 $[l,r]$，$x$ 放置在左端点或者右端点。那么转移是显然的。

我们发现这个 $l,r$ 的真正作用是限制左右转移不出界，那我不管界不就好了？

$f_{x,y}$ 表示积木区间长度为 $x$，最后一个块是 $y$，那么有：

$$f_{x,y}\to f_{x+1,y+1}$$（直接往旁边走）  
$$f_{x,y}\to f_{x+1,x+y}$$（走到另一边）  
$$f_{x,y}\to f_{x,y+2}$$（来回走，区间长度不会发生变化）

那么一个状态 $f_{x,n/n-1}$ 对答案的贡献就是 $2(m-x+1)f_{x,n/n-1}$（这个 2 是因为我们 dp 的时候没有考虑你最后一个在左边还是右边，另一个系数就是你把这段区间完整的放进最终序列的方案数），代码好写。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=1e9+7,inf=0x3f3f3f3f3f3f3f3f;
const int N=5e3+10,M=2e5+10;
int f[N][N];
int n,m;
inline void add(int &x,int y){x=(x+y)%mod;}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin >> n >> m;
    f[2][2]=1;
    for ( int i = 2 ; i <= m ; i++ )
    {
        for ( int j = 2 ; j <= n ; j++ )
        {
            f[i][j]%=mod;
            add(f[i][j+2],f[i][j]);
            if(j+i<=n)add(f[i+1][j+i],f[i][j]);
            add(f[i+1][j+1],f[i][j]);
        }
    }
    int ans=0;
    for ( int i = 2 ; i <= m ; i++ )
        add(ans,(f[i][n-1]+f[i][n])*(m-i+1)%mod);
    cout << ans*2%mod;
	return 0;
}
```

---

## 作者：Z_301 (赞：4)

考虑时光倒流。问题转化为：

- 有一个长度为 $n$ 的数组 $a$ 和两个变量 $p$，$m$，初始 $1\le p\le n$，$m=k$。
- 做 $k$ 次以下操作：
    1. 如果 $a_p=0$，就令 $a_p\leftarrow m$，否则什么也不做。
    2. 执行 $p\leftarrow p-1$ 或 $p\leftarrow p+1$，和 $m\leftarrow m-1$。需要保证操作后满足 $1\le p\le n$。
- 求最后有多少种合法的序列 $a$。

一个结论是任意时刻 $a_p\not= 0$ 的 $p$ 形成一个区间。只对这个区间内的数 DP。

记 $f_{i,j}$ 表示，当前区间长度为 $i$，$p$ 在区间的一个端点，$m=j$ 时区间内部 $a$ 的方案数。

转移有三种：

1. $m$ 来回走一步，转移到 $f_{i,j-2}$。
2. $p$ 走一步，转移到 $f_{i-1,j+1}$。
3. $p$ 跨过整个区间，转移到 $f_{i-1,j-i}$。

为什么只要考虑 $m$ 来回走一步？因为假如确定了初始的 $p$，那么 $a$ 的每个位置（如果有值）的奇偶性就已经确定了。在下一次修改 $a$ 的值之前，我们可能会浪费若干步，可以发现浪费的步数总是偶数。

初始 $f_{2,k-1}=1$，含义是区间一开始必然一个是 $k$，一个是 $k-1$。

代码（[完整版](https://www.luogu.com.cn/record/175854040)）：

```c++
const int N=5e3+10;
int n,m; // 注意，这份代码里 n 是序列长度，m 是操作次数。
mint f[N][N];
int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	cin>>m>>n;
	f[2][m-1]=1;
	For(i,2,n) rFor(j,m,2) {
		if(j>2) f[i][j-2]+=f[i][j];
		f[i+1][j-1]+=f[i][j];
		if(j>i) f[i+1][j-i]+=f[i][j];
	}
	mint s=0;
	For(i,1,n) s+=(f[i][1]+f[i][2])*(n-i+1);
	s*=2;
	cout<<s<<endl;
}
```

---

## 作者：fight_for_humanity (赞：4)

影响结果的只会是最上面的那层，正着操作会有覆盖，反着来某一位置上的第一个放置的就是最终结果。因此从 $n$ 开始放置。

又考虑到已经有积木放置的区间一定是连续的，那么以已经有积木放置的区间的长度 $i$ 作为阶段，最后放置的积木为 $j$，可以得到状态 $dp(i,j)$。

初始状态 $dp(2,n-1) \gets 2$，有两种顺序。

可列得转移方程 $dp(i,j) \gets dp(i-1,k)$。

- 上次拓展在同侧：$j+1 \equiv k \pmod 2$
- 上次拓展在异侧：$i+j-1 \equiv k \pmod 2$

直接暴力统计是 $O(n^3)$ 的，有 $80$ 分。后缀和优化一下就 $O(n^2)$ 满分了。

```
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7,N = 5010;
int n,k,dp[N][N],suf[N],ans;
int main(){
	scanf("%d%d",&n,&k);
	dp[2][n-1] = 2;
	for(int i = 3;i<=k;++i){
		suf[n-1] = dp[i-1][n-1];
		for(int j = n-2;j>=1;--j)suf[j] = (suf[j+2] + dp[i-1][j])%mod;
		for(int j = n-2;j>=1;--j){
			dp[i][j] = suf[j+1];
			if(i+j <= n) dp[i][j] = (dp[i][j] + suf[i+j-1])%mod;
		}
	}
	for(int i = 2;i<=k;++i)
		for(int j = 1;j<n;++j)
			(ans += 1ll*dp[i][j]*(k-i+1)%mod ) %= mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：f_hxr_ (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/P9906)

题意不用多说了。

观察题目，我们发现如果从小往大放，那么小的就会被大的盖住，不利于计算。但是如果从大往小放，先放的肯定不会被后放的盖住。

这样我们就完成了第一步转化。

我们定义 $CCF_i$ 为用整数 $1,2, \dots N$ 按题目要求**填满** $i$ 个位置的方案数，则答案就是：

$$\sum_{i=2}^{\min(N,K)}(CCF_i \times(K-i+1))$$

~~不要问为什么用这个作为变量名~~

这样，我们就可以不用去看 $K$ 了。

考虑动态规划。由于要填满的长度线性递增，从大到小依次放下的数也递减，我们很自然地想到定义 $f_{i,j}$ 表示：我们填满 $i$ 个位置，最后放下的数是 $j$，在这个条件下的序列方案数。

显然，将一个数放在另一个数的底下是没有意义的。

我们考虑将 $j$ 放在哪个数字边是合法的。或者说，我们先放哪个数再放 $j$ 是合法的。

首先，我们可以肯定的是，$j$ 可以放在 $j+1$ 旁边。

那么，我们从 $j+1$ 开始，向左叠一个数字，再向右叠两个数字，就成了 $j+3$，这也是合法的。如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/ioni86rh.png)

以此类推，$j+5,j+7 \dots$ 只要不超过 $N$ 就是合法的转移。

上图中从 $10$ 开始我们是向右延展的，可不可以线向左绕一下再向右延展一点再放 $5$ 呢？答案是可以。由于绕了一圈，所以 “上一个数字”得从 $j+(i-1)$ 开始。然后向上面那样加 $2$ 直到 $N$。向下图这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/mvphp1bh.png)

然后就无脑转移，这样就有 80 分了。

要得满分的话，只要盯着代码搞个后缀和就行了。**注意清空后缀和数组！**

下面是 AC 代码，注释掉的代码是 80 分的暴力。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1e9+7;
const LL maxn=5005;
void add(LL &x,LL xx){x+=xx;x%=MOD;}
LL N,K,f[maxn][maxn],suf[maxn],ans;
int main(){
	scanf("%lld %lld",&N,&K);
	f[2][N-1]=2;
	for(LL i=3;i<=N;i++){
		suf[N-1]=f[i-1][N-1];
		for(int j=N-2;j>=1;--j)suf[j]=0,add(suf[j],(suf[j+2]+f[i-1][j]));
		for(LL j=N-2;j>=1;j--){
			//for(LL k=1;j+k<=N;k+=2)add(f[i][j],f[i-1][j+k]);
			add(f[i][j],suf[j+1]);
			//for(LL k=(i-1);j+k<=N;k+=2)add(f[i][j],f[i-1][j+k]);
			if(j+i-1<=N)add(f[i][j],suf[j+i-1]%MOD);
		}
	}
	for(LL i=2;i<=min(K,N);i++)
		for(int j=1;j<=N-1;j++)add(ans,f[i][j]*(K-i+1)%MOD);
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：kkxacj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9906)

#### 思路

容易发现**放的积木的位置一定是一段连续的。**

然后再看一下其他性质，如果 $n = 3,k = 114$，存在一种情况为前三个顶端积木为 $1,2,3$，那么如果第一个积木摆第二个地方，也存在这种情况，即 $0,1,2,3,0,0,...$，$0$ 表示没有摆积木，所以对于每个满足要求的长度，可以造成的答案为 $k - len + 1$，$len$ 是这个满足要求的长度。

由于我们只考虑最后最顶端的积木块，所以不妨**倒着考虑**，又由于之前得出的性质，考虑设转态 $f_{i,j}$ 表示当前长度为 $i$，到第 $j$ 个数，且 $j$ 在这一段的最左边和最右边的方案数，假设 $j$ 在左边，可以考虑往左一格更新答案 $f_{i + 1,j - 1}$，也可以考虑先向右再往左更新答案 $f_{i + 1,j - 3}$，也可以反复多次，因为是**倒着考虑的**，所以对状态没有影响，同时还可以考虑向右更新答案 $f_{i + 1,j - i}$，或往左再往右，与上面同理，考虑用后缀和优化一下就可以通过这道题了。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9 + 7;
int n,k,f[5010][5010],ans,suf[5010];
signed main()
{
	scanf("%lld%lld",&n,&k);
	f[2][n - 1] = 2;
	for(int i = 3;i <= n;i++)
	{
		suf[n - 1] = f[i - 1][n - 1];
		for(int j = n - 2;j >= 1;j--) suf[j] = (suf[j + 2] + f[i - 1][j]);
		for(int j = n - 2;j >= 1;j--) 
		{
			f[i][j] = suf[j + 1];
			if(i + j <= n) f[i][j] = (f[i][j] + suf[i + j - 1]) % mod;
		}
	}
	for(int i = 1;i <= min(n,k);i++)
		for(int j = 1;j <= n;j++)
			ans = (ans + f[i][j] * (k - i + 1)) % mod;
	printf("%lld",ans); 
	return 0;
}

```

---

## 作者：云浅知处 (赞：1)

考虑把填数过程倒过来做，那么就变成了覆盖。

设 $f(i,j,0/1)$ 表示目前填进去 $i$ 个数，且最后一个填的数是 $j$，并且 $j$ 的位置在最左侧/最右侧的方案数。以 $f(i,j,0)$ 为例，转移有：

- $f(i,j,0)\to f(i+1,k,0)$，要求 $k\le j-1$ 且 $j-1\equiv k\pmod 2$。
- $f(i,j,0)\to f(i+1,k,1)$，要求 $k\le j-i$ 且 $j-i\equiv k\pmod 2$。

前缀和优化即可，复杂度 $O(n^2)$。

```cpp
//-DYUNQIAN -std=c++14 -O2 -Wall
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

const int mod=1e9+7;
int ksm(int x,int y,int p=mod){
    int ans=1;
    for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
    return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}
void add(int &x,int v){x+=v;if(x>=mod)x-=mod;}
void Mod(int &x){if(x>=mod)x-=mod;}

void Assert(bool c,int L=0){if(!c){cout<<"Assertion Failed at "<<L<<endl;exit(0);}}

void cmax(int &x,int v){x=max(x,v);}
void cmin(int &x,int v){x=min(x,v);}

const int N=5005;
int f[2][N][2],n,k;

signed main(void){

#ifdef YUNQIAN
    freopen("in.in","r",stdin);
#endif

	k=read(),n=read();int ans=0;
	int cur=0;f[cur][k-1][0]=f[cur][k-1][1]=1;
	for(int i=2;i<=n;i++){
		int res=0;
		for(int j=1;j<=k;j++)add(res,f[cur][j][0]),add(res,f[cur][j][1]);
		add(ans,1ll*res*(n-i+1)%mod);

		memset(f[cur^1],0,sizeof(f[cur^1]));
		vector<vector<int> >sum(2);sum[0].resize(k+3,0),sum[1].resize(k+3,0);
		for(int j=k;j>=1;j--)for(int p=0;p<=1;p++)Mod(sum[p][j]=sum[p][j+2]+f[cur][j][p]);
		for(int j=1;j<=k;j++){
			if(j+1<=k)add(f[cur^1][j][0],sum[0][j+1]),add(f[cur^1][j][1],sum[1][j+1]);
			if(j+i<=k)add(f[cur^1][j][0],sum[1][j+i]),add(f[cur^1][j][1],sum[0][j+i]);
		}
		cur^=1;
	}
	cout<<ans<<endl;

    return 0;
}
```

---

## 作者：huhangqi (赞：0)

题目问的是最后在最上层的情况，那么下面什么情况我们不需要怎么管。

由于是从下往上堆，所以我们考虑反向操作，每一个都放在这一个位置的最下面。

由于我们只记录最上方的，所以我们不需要管在下面放了什么。

那么我们大概需要两种转移，一种是添加新的位置，一种是放在下面消耗数量。

消耗数量造成的最终所在的位置对下一次添加新位置的耗费存在影响，因此我们可能会希望统一状态，使位置默认处在左右两端的其中一个点。

由于我们下一次添加还是要先走到两端，我们不妨设计一次消耗两个，实现一次往返，这样就可以不重不漏的计入结果了。

那么就可以直接设计 $dp_{i,j}$ 表示目前覆盖了 $i$ 个区域，使用了 $j$ 块积木。

消耗 $2$ 个积木，回到原处可以得到：$dp_{i,j-2}$

在目前所在的端点处增加新的位置：$dp_{i-1,j-1}$

在另一端增加新的位置：$dp_{i-1,j-i+1}$

那么状态转移式为：

$$
dp_{i,j}=dp_{i,j-2}+dp_{i-1,j-1}+dp_{i-1,j-i+1}
$$

那么起始状态就可以设置为 $dp_{1,1}$ 表示开始只有一个点的状态。

但是上面的转移式还存在问题，就是我们只记录了消耗 $2$ 个的情况，虽然在开启了新的位置前额外消耗的一定是偶数，但是最后没有加位置，剩下来的可能是奇数个的。

所以在最后统计答案时，我们不仅要计算全部放置了的答案，还需要计算少了一个的答案，如果可以再浪费一个，那么就计入答案，也就是说只有一个位置的情况是不行的。

并且因为剩下来的奇偶性不一样，所以上面的结果一定也不一样，不会重复。


最后就可以完成了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,dp[5005][5005];
signed main(){
	cin>>n>>m;
	dp[1][1]=1;
	for(int i=2;i<=m;i++){
		for(int j=2;j<=n;j++){
			dp[i][j]+=dp[i][j-2],dp[i][j]%=mod;
			if(j>=i)dp[i][j]+=dp[i-1][j-i+1],dp[i][j]%=mod;
			dp[i][j]+=dp[i-1][j-1],dp[i][j]%=mod;
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++)ans=(ans+1ll*(dp[i][n]+(i!=1)*dp[i][n-1])%mod*(m-i+1)%mod)%mod;
	cout<<ans%mod;
	return 0;
}
``````

---

## 作者：zhangshirui (赞：0)

计数题，数据范围可得时间复杂度大概 $O(nk)$ 左右，可以推断得是一个二维状态的 dp。

然后如果我们按套路记 $dp_{i,j}$ 为决策了 $i$ 个数，当前在位置 $j$ 的话，会发现不好转移，因为会产生重复，那就要考虑转化一下问题了。

我们把问题的覆盖在上面改成插入在下面，不难发现这两个问题是等价的（覆盖在上面变成从大到小的顺序插入在下面，再反个顺序）。所以我们记 $dp_{i,j}$ 为区间长度为 $i$，用了 $j$ 个数，且 $i$ 个位置全部放完的情况，这样依然可以求出答案，具体方法后面说。第一眼可能不好转移，但画图想想也挺简单的，下面分类讨论一下：

1.  我们移动到区间外，往同一侧移动需要移动一个距离，也就是一个数，从 $dp_{i-1,j-1}$ 接收，往另一侧转移需要 $i$ 的距离，那么我们 $dp_{i,j}$ 就应该是从 $dp_{i-1,j-i+1}$ 接收，这部分就完了。
2. 我们在当前区间内部放一个数，插入在底部，没有任何作用，但是统计答案时要用。但是我们为保证转移一不出错，不能让位置移动到区间内部，所以要让位置不变，从 $dp_{i,j-2}$ 转移即可。

为什么上面转移是对的？因为只有点在移出区间时才会产生贡献，所以在区间内部转移没有必要考虑。原地兜圈子由转移二处理，要产生新的贡献只有在同侧拓展和在异侧拓展，那么转移一是正确的。同时贡献只有这两种，所以整体是正确的。

最后考虑统计答案，也很简单，把不同的长度的答案乘上可以平移到的位置数求和即可，式子：$\sum\limits_{i=1}^k(k-i+1)\times dp_{i,n}$

代码如下，也是非常的简短：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
ll n,k,dp[5005][5005]; 
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>k;
	for(int i=2;i<=n;i++)dp[2][i]=2;
	for(int i=3;i<=k;i++)
		for(int j=i;j<=n;j++)dp[i][j]+=(dp[i-1][j-1]+dp[i][j-2]+dp[i-1][j-i+1])%mod;
	ll ans=0;
	for(int i=1;i<=k;i++)ans+=dp[i][n]*(k-i+1),ans%=mod;
	cout<<ans%mod;
}

```

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P9906)

**题目大意**

> 给定长度为 $k$ 的序列，从一个点出发，每次向左或向右一步，共走 $n$ 步，每个位置上显示最后一次被经过的时刻，求能生成多少合法序列。
>
> 数据范围：$n,k\le 5000$。

**思路分析**

注意到能到达的点一定是一段区间，可以倒序 dp，设 $f_{i,j}$ 表示最后 $n\sim j$ 步经过的范围是一个长度为 $i$ 的区间，并且我们钦定第 $j$ 步在某个位置上显示。

那么最后这一步一定在这个长度为 $i$ 的区间的左端点或右端点上，因此 $f_{i,j}\to f_{i+1,j-1},f_{i+1,j-i}$ 表示向哪个方向拓展一步。

但是我们可以走来回，因此 $f_{i,j}\to f_{i+1,j'}$ 的转移实际上转移到了 $f_{i+1,j'},f_{i+1,j'-2},f_{i+1,j'-4}\dots$，后缀和一下即可。

答案就是 $\sum (k-i+1)f_{i,j}$，注意 $i=1$ 时不能走来回。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=5005,MOD=1e9+7;
ll f[MAXN],g[MAXN];
inline void add(ll &x,ll y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
signed main() {
	int n,k;
	scanf("%d%d",&n,&k);
	ll ans=0; f[n]=1;
	for(int i=1;i<k;++i) {
		memset(g,0,sizeof(g));
		for(int j=n;j>=1;--j) {
			add(g[j-1],f[j]);
			if(j>=i) add(g[j-i],f[j]);
		}
		memcpy(f,g,sizeof(f));
		for(int j=n;j>=1;--j) {
			if(i>1) add(f[j],f[j+2]);
			ans=(ans+f[j]*(k-i))%MOD;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Oracynx (赞：0)

## P9906 [COCI 2023/2024 #1] Kocke 题解

### 思路分析

首先，对于一个结果序列长度为 $l$ 的解法，设有 $x$ 中结果，其对答案的总贡献为 $x\times (k - l + 1)$。

我们考虑分别 dp 每一种长度的答案然后统计。

设 $dp_{i, j}$ 为长度为 $i$，当前应该填入 $j$ 这个数（因为我们是倒序地填入，所以不需要考虑覆盖的问题）。

则 dp 的状态转移方程式为：

$$
dp_{i, j} = \sum_{x = 0}^{\frac{x - 1}{2}} dp_{i - 1, j + 1 + x} + dp_{i - 1, i + j - 1 + x}
$$

两个式子分别对应两种情况：

> ```
> _9__
> __8_
> ```
> 此时我们有两种选择：
> ```
> _9__
> __8_
> ___7
> ```
> 和
> ```
> _9__
> __8_
> _7__
> __6_
> ___5
> ```
> 结果分别为 `987` 和 `985`，继续模拟发现还有 `983` 和 `981`，最后一位便可以用 $x$ 推出。

> ```
> _9__
> __8_
> ```
> 此时我们仍然有两种选择：
> ```
> _9__
> __8_
> _7__
> 6___
> ```
> 和
> ```
> _9__
> __8_
> _7__
> __6_
> _5__
> 4___
> ```
> 结最后一位同样可以用 $x$ 推出。

这里就不贴 $80$ 分的代码了

此处的 $x$ 可以使用后缀和优化，复杂度 $O(N \times M)$。

### 代码实现

```cpp
#include <cstdio>
constexpr int MaxN = 5e3 + 5;
constexpr long long Mod = 1e9 + 7;
int n, m;
long long answer;
long long dp[MaxN][MaxN];
long long sum[MaxN];
int main()
{
    scanf("%d%d", &n, &m);
    dp[2][n - 1] = 2;
    for (int i = 3; i <= n; i++)
    {
        sum[n - 1] = dp[i - 1][n - 1];
        for (int j = n - 2; j >= 1; j--)
        {
            sum[j] = dp[i - 1][j] + sum[j + 2];
            sum[j] %= Mod;
        }
        for (int j = n - 2; j >= 1; j--)
        {
            dp[i][j] = sum[j + 1];
            if (i + j <= n)
            {
                dp[i][j] += sum[i + j - 1];
            }
            dp[i][j] %= Mod;
        }
    }
    for (int i = 2; i <= m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            answer += dp[i][j] * (m - i + 1);
            answer %= Mod;
        }
    }
    printf("%lld\n", answer);
    return 0;
}
```

---


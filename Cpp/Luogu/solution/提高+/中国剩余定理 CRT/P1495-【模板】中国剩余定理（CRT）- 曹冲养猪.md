# 【模板】中国剩余定理（CRT）/ 曹冲养猪

## 题目描述

自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有 $16$ 头母猪，如果建了 $3$ 个猪圈，剩下 $1$ 头猪就没有地方安家了。如果建造了 $5$ 个猪圈，但是仍然有 $1$ 头猪没有地方去，然后如果建造了 $7$ 个猪圈，还有 $2$ 头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？

## 说明/提示

$1 \leq n\le10$，$0 \leq b_i\lt a_i\le100000$，$1 \leq \prod a_i \leq 10^{18}$

## 样例 #1

### 输入

```
3
3 1
5 1
7 2```

### 输出

```
16```

# 题解

## 作者：vectorwyx (赞：210)

蒟蒻不会 CRT，但我们可以使用**枚举**来切掉这道~~水题~~，因此~~只需要小学五年级的水平~~。

如何枚举？如果只有两组同余式，求解最直接的思路就是从小到大枚举满足其中一个同余式的所有数直到找到满足另一个同余式的。更具体地，从余数出发，不断加上该同余式所对应的模数，当累加的结果满足另一个同余式时即为我们所求的最小值。

比如说样例中的`3 1 5 1`，满足第一个同余式的最小数为 $1$，然后不断加 $3$，加五次后得到数 $16$，满足第二个同余式，答案即为 $16$。这一过程用循环就可以实现。


------------
得到了两组同余式的解法，我们推广一下即可，$n$ 组同余式可从前往后，每次取前一次得到的最小数与本同余式进行运算，循环 $n-1$ 次便可得出答案。

比如，对于题目中给出的样例：
```
3
3 1
5 1
7 2
```
首先取前两个同余式，根据上文所述的过程得到满足前两组同余式的最小值为 $16$，再在这个最小值的基础上引入第三个同余式，每次增加 $3$ 和 $5$ 的最小公倍数 $15$，由于 $16$ 已经满足第三个同余式，不需要累加。得到答案为 $16$。

复杂度至多是 $O(\sum a_i)$，即模数之和，完全可过。

------------
ok，你们最期待的代码来了：
```
#include<iostream>
#include<algorithm>
using namespace std;
struct pig{
	int a1,b1;
}a[11];//定义结构体存储a与b
int gcd(int x,int y){//公约数函数，用来求每一次循环累加的值
	if(x%y==0) return y;
	else return gcd(y,x%y);
}
int main(){
	long long n,ans,sum=1;//数据较大用longlong
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i].a1>>a[i].b1;
	}
	ans=a[1].b1;//初始化最小值
	for(int i=1;i<n;++i){//开始循环
		sum=sum*a[i].a1/gcd(sum,a[i].a1);//sum为累加的值
		while(ans%a[i+1].a1!=a[i+1].b1){//循环条件
			ans+=sum;
		}
	}
	cout<<ans;
	return 0;
}

```
祝愿大家 AC，RP++。

---

## 作者：灵乌路空 (赞：32)

无良宣传一下博客wwwwww  
[文章列表 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

- ### 分析题意:
  现有两组数字，每组 $k$ 个，  
  第一组中的数字分别为：$a_1,a_2,...,a_k$ 表示，  
  第二组中的数字分别用$b_1,b_2, ... ,b_k$表示。  
  第二组中的数字$\underline\text{两两互质}$。  
  求最小的非负整数 $n$ ，  
  $\underline{\text{满足对于任意的}i,n - a_i \text{ 能被 } b_i \text{ 整除}}$。
  
   根据题意 ， 题干可以转化为:
  
   - ##### 要解如下的同余方程组 ：
   
     $\begin{cases}x \equiv a_1\pmod {b_1}\\x \equiv a_2\pmod {b_2}\\......\\x \equiv a_n\pmod {b_n}\\\end{cases}$

  
   
   因为 $bi$ 之间 **两两互质**，所以可以用 **中国剩余定理** 求解  
   但是 中国剩余定理 适用范围太小，  
   这里介绍用 **扩展中国剩余定理** 求解。
   
## 求解同余方程组 (扩展中国剩余定理)   
   
   一道模板题: [P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.org/problemnew/show/P4777)
   
   - ### 要解如下的同余方程组 ：
   
     $\begin{cases}x \equiv a_1\pmod {b_1}\\x \equiv a_2\pmod {b_2}\\......\\x \equiv a_n\pmod {b_n}\\\end{cases}$
   
     其中 , $a_i,b_i$为非负整数 ， $b_1,b_2,...,b_n$ 不一定互质
   
   - ### 求解:
   
     假设已经求出了前 $k-1$ 个方程的解 $x_{k-1}$  
     设 $M=LCM_{i=1}^{k-1} bi$ , 即 $M$ 为前 $k-1$ 个模数 $b$ 的最小公倍数
     
     **则 :**    
     对于前 $k-1$个方程, 都满足$x_{k-1}+tM\equiv a_i\pmod {b_i}\ \ (t\in Z)$  
     即 : 前 $k-1$ 个方程 , 通解为 $x_{k-1}+tM\ \ (t\in Z)$
     
     欲求得第 $k$ 个方程的解 , 并且将求得的解 , 也满足前 $k-1$ 个方程 
    
     **则 :**   
     需要使第 $k$ 个方程的解 , 为前 $k-1$ 的方程的通解的同时 ， 也满足第 $k$ 个方程的条件 。
    
     设 : 第$k$ 个方程的解 $x_k = x_{k-1}+tM\ \ (t\in Z)$
     
     将此解代入第 $k$ 个方程中 , 可得 :   
     $x_{k-1}+tM\equiv a_k\pmod{b_k}$   
     即 :  $tM\equiv a_k-x_{k-1}\pmod{b_k}$  
     其中 : $M,a_k,x_{k-1},b_k$ 都是已知的 。
     
     使用 $exgcd$ 解出此同余方程 , 可以得到 $t$ 的值 。
     
     将 $t$ 的值代回 $x_k = x_{k-1}+tM\ \ (t\in Z)$ ，就可得到$x_k$的值
     
     进行 $k$ 次上述操作后 ，便可得到 方程组的解 。
     
  
- #### 附本题AC代码:

```cpp
//扩展中国剩余定理模板题目 
//详见注释 
#include<cstdio>
using namespace std;
typedef long long ll;
ll n;
ll a[100010],b[100010]; 
ll mul(ll A,ll B,ll mod) //快速乘取余 模板
{
    ll ans=0;
    while(B>0)
      {
        if(B & 1) ans=(ans+A%mod)%mod;
        A=(A+A)%mod;
        B>>=1;
      }
    return ans;
}
ll exgcd(ll A,ll B,ll &x,ll &y) //扩展欧几里得 模板
{
    if(!B)
      {
        x=1,y=0;
        return A;
      }
    ll d=exgcd(B,A%B,x,y);
    ll tmp=x;
    x=y , y=tmp-A/B*y;
    return d;
}
ll lcm(ll A,ll B) //求最小公倍数
{
    ll xxx,yyy;
    ll g=exgcd(A,B,xxx,yyy);
    return (A/g*B);
}
ll excrt() //重点:求解同余方程组
{
    ll x,y;
    ll M=b[1],ans=a[1]; //赋初值 
    //M为前k-1个数的最小公倍数，ans为前k-1个方程的通解
    for(int i=2;i<=n;i++)
      {
        ll A=M,B=b[i];
        ll C=(a[i]-ans%B+B)%B; //代表同余方程 ax≡c(mod b) 中a,b,c

        ll g=exgcd(A,B,x,y);
        //求得A,B的最大公约数，与同余方程ax≡gcd(a,b)(mod b)的解，

        if(C%g) return -1; //无解的情况

        x=mul(x,C/g,B); //求得x的值,x即t 
        ans+=x*M;  //获得前k个方程的通解
        M=lcm(M,B); //更改M的值
        ans=(ans%M+M)%M;
      }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
      scanf("%lld%lld",&b[i],&a[i]);
    ll ans=excrt();
    printf("%lld",ans);
}
```


---

## 作者：UnyieldingTrilobite (赞：30)

juruo其实刚看到的思路是分治QAQ

每个a互质是一件肥肠肥肠良心的事，可以带给我们很多很多性质。

首先，两个互质数的中剩：

$x\equiv a\pmod{p}$

$x\equiv b\pmod{q}$

显然，如果我们能找到$s$满足$s\equiv 0\pmod{p}$且$s\equiv 1\pmod{q}$

并找到$t$满足$t\equiv 0\pmod{q}$且$t\equiv 1\pmod{p}$


（当然$s$与$t$的得到应该同理，所以只考虑$s$就可以了。）

那么得$x\equiv (a\times t+b\times s)\pmod{p\times q}$

证明不难，按照同余性质就可以得到。

缩以现在就是求$s\equiv 0\pmod{p}$且$s\equiv 1\pmod{q}$

想想怎么求？

$p,q$互质告诉我们$p^{\varphi(q)}\equiv 1\pmod q$

很巧的是，$p^{\varphi(q)}\equiv 0\pmod p$~

所以$p^{\varphi(q)}$就是我们要的$s$~

最后一个问题：数据范围大，线性筛不够用怎么办？

继续利用互质吧！

两个互质数的欧拉函数之积等于其积的欧拉函数！

然后维护一下就做完了~

上代码：
```cpp
#include<bits/stdc++.h>
#define int __int128//亲身测试，卡粟米会爆long long(QAQ)
using namespace std;
int Phi[1000009],prime[1000009],tot;
bool vis[1000009];
signed n;
int qpow(const int&a,const int&p,const int&tomod){
	if(!p)return 1;
	int h=qpow(a,p>>1,tomod);
	h=h*h%tomod;
	if(p&1)h=h*a%tomod;
	return h;
}//卡粟米，a的p次方膜tomod
struct pig{//结构体记录信息
	int mod;//猪圈数
	int lft;//孤单的猪的数量
	int phi;//猪圈数的欧拉函数
	friend pig operator * (const pig &x,const pig &y){
		int k=x.mod*y.mod,ret1=qpow(x.mod,y.phi,k),ret2=qpow(y.mod,x.phi,k);
		return (pig){k,(ret1*y.lft%k+ret2*x.lft%k)%k,x.phi*y.phi};
	}//两个式子中剩（就是上面颓了半天的那串）
};
pig readpig(){
	signed a,b;cin>>a>>b;
	return (pig){(int)a,(int)b,Phi[a]};
}//读入一只猪（有什么用吗？Emm······珂以让solve函数极端简洁）
void ola(){
	Phi[1]=1;
	for(int i=2;i<=1000000;++i){
		if(!vis[i])prime[++tot]=i,Phi[i]=i-1;
		for(int j=1;j<=tot&&prime[j]*i<=1000000;++j){
			vis[i*prime[j]]=1;
			if(i%prime[j])Phi[i*prime[j]]=Phi[i]*(prime[j]-1);
			else{
				Phi[i*prime[j]]=Phi[i]*prime[j];
				break;
			}
		}
	}
}//欧拉筛（ola）
pig solve(const signed&l,const signed&r){
	return l==r?readpig():solve(l,l+r>>1)*solve((l+r>>1)+1,r);
}//极简solve,返回新的信息
void write(int x){
	if(x>9)write(x/10);
	putchar(x%10|48);
}//__int128必须手打输出，输入珂以强转（输出也珂以但窝怕爆炸）
signed main(){
	ola();//筛欧拉函数
	cin>>n;
	write(solve(1,n).lft);//解决+输出
	putchar('\n');
    return 0;
}
```
另：对于用同样做法却RE的同志们：

数据范围好像写的是1000······

但真实数据好像有达到1e6······囧

最后推销[blog](https://www.luogu.com.cn/blog/2007100723874wxz/).

---

## 作者：Tomwsc (赞：27)

# P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪 题解

## 题意

试求如下同余方程组的最小非负整数解：
$$
\begin{cases}
x\equiv a_1\pmod {b_1}\\
x\equiv a_2\pmod {b_2}\\
\cdots\\
x\equiv a_n\pmod {b_n}\\
\end{cases}
$$

其中，$b_i$ 两两互质。

## 思路

对于这样模数两两互质的题，可以使用中国剩余定理来求解。什么是中国剩余定理呢？请听我慢慢道来……

首先，由余数的可加性可知，若可以求得以下 $n$ 个方程的解，那便可以求出原方程的解：

$$
\begin{cases}
x_1\equiv a_1\pmod {b_1}\\
x_1\equiv 0\pmod {b_2}\\
x_1\equiv 0\pmod {b_3}\\
\cdots\\
x_1\equiv 0\pmod {b_n}\\
\end{cases}

\begin{cases}
x_2\equiv 0\pmod {b_1}\\
x_2\equiv a_2\pmod {b_2}\\
x_2\equiv 0\pmod {b_3}\\
\cdots\\
x_2\equiv 0\pmod {b_n}\\
\end{cases}
\cdots
\begin{cases}
x_n\equiv 0\pmod {b_1}\\
x_n\equiv 0\pmod {b_2}\\
x_n\equiv 0\pmod {b_3}\\
\cdots\\
x_n\equiv a_n\pmod {b_n}\\
\end{cases}
$$

此时，便有原方程的解 $x=x_1+x_2+\cdots+x_n$。

现在，考虑将每一个方程组拿出来单独求解。我拿第一个方程组讲解：

$$
\begin{cases}
x_1\equiv a_1\pmod {b_1}\\
x_1\equiv 0\pmod {b_2}\\
x_1\equiv 0\pmod {b_3}\\
\cdots\\
x_1\equiv 0\pmod {b_n}\\
\end{cases}
$$

要求出如上这个方程的解，其实可以再做一步转换，先求出以下这个方程的解：

$$
\begin{cases}
y_1\equiv 1\pmod {b_1}\\
y_1\equiv 0\pmod {b_2}\\
y_1\equiv 0\pmod {b_3}\\
\cdots\\
y_1\equiv 0\pmod {b_n}\\
\end{cases}
$$

由余数的可乘性得：$x_1=y_1\times a_1$。同时，观察方程组可知 $y_1$ 一定是 $\prod_{i=2}^{n} b_i$ 的倍数。设 $\prod_{i=2}^{n} b_i$ 为 $m_1$，则有 $y_1=m_1\times k_1$。因为 $y_1$ 还要满足第一个同余方程，所以此时得到：$m_1\times k_1\equiv 1\pmod {b_1}$。于是，求 $y_1$ 的问题就转换成了求 $m_1\bmod b_1$ 的逆元的问题，可以用扩展欧几里得算法求解。

于是便可以按这种方法，求出上面的 $n$ 个方程组的解，然后便得到了原方程的**整数解**。不过还要再进行对所有的数的乘积的取模，因为要求**最小非负整数解**。

所以，设所有的数的乘积为 $k$，则最终答案用式子表达便是：

$$x=\sum_{i=1}^{n}k_i\times a_i\times m_i\pmod k$$

## 代码

开了 ```__int128```。

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int MAXN = 1e5 + 10;
int n;
int a[MAXN] , b[MAXN];
int s;

int exgcd(int a , int b , int &x , int &y) {
	if(!b) {
		x = 1;
		y = 0;
		return a;
	}
	int r = exgcd(b , a % b , x , y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return r;
}

inline int read() {
	char c = getchar();
	int x = 0 , s = 1;
	while(c < '0' || c > '9') {
		if(c == '-')
			s = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * s;
}

void write(int x){
	if(x > 9)
		write(x/10);
	putchar(x % 10 | 48);
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	n = read();
	int ans = 1;
	for(register int i = 1;i <= n;i ++) {
		a[i] = read();
		b[i] = read();
		ans *= a[i];
	}
	for(register int i = 1;i <= n;i ++) {
		int k = ans / a[i];
		int x , y;
		exgcd(k , a[i] , x , y);
		s = s +  k * b[i] * x % ans;
	}
	write((s % ans + ans) % ans);
	return 0;
}
```

---

## 作者：Dog_Two (赞：23)

题面一如既往地亲切和蔼……仿佛生怕选手不知道这是一道中国剩余定理的裸题。

中国剩余定理是啥……相信也不需要多做介绍了，这里需要简单提醒大家，中国剩余定理可以采用的充要条件是**模数互质**（在本题中也就是猪圈数目互质）

好的，切回正题。

蒟蒻我曾经帮一位队友做了一份课件，里面是讲解同余问题的（当然包括中国剩余定理）但我的队友们实在难以接受这样复杂的程序。所以我给他们归纳了几句并不严谨的“技巧”。

- ①对于数字 W[i]，求出（即相乘）其他所有数字的最小公倍数M;
- ②在M所有整数倍中，找到一个模B[i]为1的数字N[i];
- ③对所有N[i]求和，不断对**所有W[i]的最小公倍数**取模;
- ④最后剩下的一个不能减的正数即为所求。

根据以上的顺序，我们不难写出一个看起来几乎无异于暴力枚举的程序，但事实上，它的确是正确的：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long LLi;
//所有int都被换成了long_long ，所以视觉效果并不好 
LLi n;
LLi W[20],B[20];
LLi sum;
LLi CRT(){
	LLi tot=1;
	LLi res=0;
	for(LLi i=0;i<sum;i++) tot*=W[i];
	//注意，数组下标从0开始 
	for(LLi i=0;i<sum;i++){
		LLi m=tot/W[i];
		for(LLi j=1;;j++){
			if((m*j)%W[i]==1){
				res+=m*j*B[i];
				res%=tot;
				break;
			}
		}
	}
	return res>0?res:res+tot;
}
int main(){
	cin>>n; sum=n;
	//这里完全可以把变量sum略去，在CRT()里把所有sum替换成n 
	for(LLi i=0;i<n;++i) scanf("%lld%lld",&W[i],&B[i]);
	cout<<CRT();
	return 0;
}

```
另附送一份ex_gcd+CRT的代码~~可以当板子用~~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
long long Wi[20],Bi[20];
long long ext_gcd(long long a,long long b,long long &x,long long &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	long long d=ext_gcd(b,a%b,x,y);
	long long temp=x;x=y,y=temp-a/b*y;
	return d;
}
long long CRT(long long *W,long long *B,long long k/*方程组数*/){
	long long x,y,a=0,m,n=1;
	for(long long i=0;i<k;i++) n*=W[i];
	for(long long i=0;i<k;i++){
		m=n/W[i];
		ext_gcd(W[i],m,x,y);
		a=(a+y*m*B[i])%n;
	}
	return a>0?a:a+n;
}
int main(){
	cin>>n;
	for(long long i=0;i<n;++i) scanf("%lld%lld",&Wi[i],&Bi[i]);
	cout<<CRT(Wi,Bi,n);
	return 0;
}
```

---

## 作者：Spasmodic (赞：13)

大家好，我是一只不会用中国剩余定理的菜鸡，于是我就用暴力水过了这题。

注意到$a_i$普遍都很小，于是我们可以考虑不用CRT。

具体是考虑从第一个条件到最后一个条件依次满足。

设$x$可以满足前$i$个条件，我们找$y$，使得它能满足前$i+1$个条件。

显然可以看出
$$x \equiv y \pmod{\prod_{j=1}^{i}a_j}$$
所以
$$y=x+ k\times\prod_{j=1}^{i}a_i,k\in \mathbf{N},k\le a_{i+1}$$
于是可以枚举$k$，由于$k$只有$a_{i+1}$种选择，所以总复杂度为$\Theta(\sum_{i=1}^{n}a_i)$，轻松AC。

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[15],m[15],ans,M;
inline ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}
int main(){
    cin>>n;
    for(ll i=1;i<=n;i++)cin>>m[i]>>a[i];
    M=m[1],ans=a[1];
    for(ll i=2;i<=n;++i){
    	for(ll j=0;j<m[i]&&ans%m[i]!=a[i];ans+=M,j++);
    	M=lcm(M,m[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```
P.S.会扩欧的同学可以用exgcd快速求k，复杂度进一步优化到$\Theta(\sum_{i=1}^{n}\log a_i)$，和正常的CRT复杂度相同。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100005;
ll n,a[N],m[N],ans,M;
ll exgcd(ll a,ll b,ll&x,ll&y){
	if(!b)return x=1,y=0,a;
	ll ret=exgcd(b,a%b,x,y),t=x;
	return x=y,y=t-a/b*y,ret;
} 
int main(){
    cin>>n;
    for(ll i=1;i<=n;i++)cin>>m[i]>>a[i];
    M=m[1],ans=a[1];
    for(ll i=2,d,x,y,m1;i<=n;++i){
    	d=exgcd(M,m[i],x,y),m1=m[i]/d,x=(__int128)x*((a[i]-ans%m[i]+m[i])%m[i]/d)%m1;
    	ans+=x*M,M=M*m1,ans=(ans%M+M)%M;
	}
	cout<<(ans%M+M)%M<<endl;
	return 0;
}
```
~~不过似乎这也是扩中的正解。~~

---

## 作者：chu_yh (赞：12)

~~废话：同一个机房的题解就要扎堆站~~

欢迎**踩[博客](https://blog.csdn.net/Chu_yh/article/details/146106175?sharetype=blogdetail&sharerId=146106175&sharerefer=PC&sharesource=Chu_yh&spm=1011.2480.3001.8118)**

@DX3906_ourstar 大佬没发出来的 [PPT](老师说是内部文件禁止外传)（看网页地址）

---

中国剩余定理是数论中的一个重要定理，用于解决一组同余方程的问题。

### 定理内容

给定一组两两互质的正整数 $n_1,n_2,\dots,n_k$，以及任意整数 $a_1,a_2,\dots,a_k$，存在一个整数 $x$，满足以下同余方程组：

$$
	\begin{cases}
	x \equiv a_1 \pmod{n_1} \\
	x \equiv a_2 \pmod{n_2} \\
	\vdots \\
	x \equiv a_k \pmod{n_k}
	\end{cases}
$$

并且，这个解 $x$ 在模 $N=n_1 n_2\dots n_k$ 下是唯一的。

### 证明

1. **存在性**：
   - 由于 $ n_1, n_2, \dots, n_k $ 两两互质，$ N = n_1 n_2 \dots n_k $。
   - 对于每个 $i$，计算 $N_i=N / n_i$。由于 $n_i$ 与 $N_i$ 互质，存在整数 $m_i$ 使得 $m_i N_i\equiv 1 \pmod{n_i}$。
   - 令 $x=\sum_{i=1}^k a_i m_i N_i$。对于每个 $i$，$x\equiv a_i m_i N_i\equiv a_i\cdot 1\equiv a_i\pmod{n_i}$，因此 $x$ 是方程组的解。

2. **唯一性**：
   - 假设 $ x $ 和 $ y $ 都是方程组的解，则 $ x \equiv y \pmod{n_i} $ 对所有 $ i $ 成立。
   - 由于 $ n_i $ 两两互质，$x\equiv y\pmod{N}$，即 $x$ 和 $y$ 在模 $N$ 下相同。

中国剩余定理通过将大模数问题分解为小模数问题，简化了计算过程。

### 实现

#### 扩展欧几里得算法求逆元

乘法逆元是数论中的一个重要概念。给定整数 $ a $ 和模数 $ m $，如果存在整数 $ x $ 使得 $ a x \equiv 1 \pmod{m} $，则称 $ x $ 是 $ a $ 在模 $ m $ 下的乘法逆元，记作 $ a^{-1} $。

1. 使用欧几里得算法求 $ \gcd(a, m) $。
2. 如果 $ \gcd(a, m) \neq 1 $，则 $ a $ 在模 $ m $ 下没有逆元。
3. 如果 $ \gcd(a, m) = 1 $，则通过扩展欧几里得算法求出 $ x $ 和 $ y $，使得：

$$a x + m y = 1$$

此时，$ x $ 就是 $ a $ 在模 $ m $ 下的逆元。

##### 代码
```cpp
void exgcd(int a,int b,int &X,int &Y){
	if(!b){X=1,Y=0;return ;}
	exgcd(b,a%b,X,Y);
	int t=X;
	X=Y;
	Y=t-a/b*X;
}
```

#### 完整代码

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
int n,m[11],r[11],c,M=1,x,y,ans;

void exgcd(int a,int b,int &X,int &Y){
	if(!b){X=1,Y=0;return ;}
	exgcd(b,a%b,X,Y);
	int t=X;
	X=Y;
	Y=t-a/b*X;
}

signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&m[i],&r[i]);
		M*=m[i];
	}
	for(int i=1;i<=n;i++){
		c=M/m[i];
		exgcd(c,m[i],x,y);
		ans=((ans+c*x*r[i])%M+M)%M;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：_coastline_ (赞：7)

~~竟然还能交题解~~

~~正好最近整理了 CRT 的笔记，就来交一发~~

## 中国剩余定理（CRT）

不难看出，题面可以翻译为：

Q：求解以下线性同余方程组：

$$\begin{cases}
  x \equiv r_1 \hspace{0.2cm} (mod \hspace{0.1cm} m_1) \\
  x \equiv r_2 \hspace{0.2cm} (mod \hspace{0.1cm} m_2) \\
  ... \\
  x \equiv r_n \hspace{0.2cm} (mod \hspace{0.1cm} m_n) \\
\end{cases}$$

其中模数 $m_1. m_2, ..., m_n$ 为 **两两互质** 的整数，求 $x$ 的最小非负整数解。

* 利用中国剩余定理求解，步骤如下：

  $(1)$ 计算所有模数的积 $M = \prod_{i=1}^{n} m_i$；

  $(2)$ 计算 $c_i = \frac{M}{m_i}$；

  $(3)$ 计算 $c_i$ 在模 $m_i$ 意义下的乘法逆元 $c_i^{-1}$；

  $(4)$ 计算解 $x = \sum_{i=1}^{n} r_i c_i c_i^{-1} \hspace{0.2cm} (mod \hspace{0.1cm} M).$

* 中国剩余定理的证明：

  * 首先证明 $x = \sum_{i=1}^{n} r_i c_i c_i^{-1}$ 对于每一个 $j$ 都有 $x \equiv r_j \hspace{0.2cm} (mod \hspace{0.1cm} m_j).$

    * 若 $i \not = j$ ，则 $c_j$ 中包含因数 $c_i$，  
    $\therefore c_j \equiv 0 \hspace{0.2cm} (mod \hspace{0.1cm} m_j),$  
    $\therefore r_j c_j c_j^{-1} \equiv 0 \hspace{0.2cm} (mod \hspace{0.1cm} m_j).$

    * 若 $i = j$ ，则 $c_j$ 中不包含因数 $c_i$，  
    $\therefore c_j \not \equiv 0 \hspace{0.2cm} (mod \hspace{0.1cm} m_i),$  
    $\because c_j c_j^{-1} \equiv 1 \hspace{0.2cm} (mod \hspace{0.1cm} m_j).$  
    $\therefore r_j c_j c_j^{-1} \equiv r_j \hspace{0.2cm} (mod \hspace{0.1cm} m_j).$  

    则对于 $j$ ，总有：
    
    $\begin{aligned}
      x &\equiv \sum_{i=1}^{n} r_i c_i c_i^{-1} \hspace{0.2cm} (mod \hspace{0.1cm} m_j) \\
        &\equiv r_j c_j c_j^{-1} \hspace{0.2cm} (mod \hspace{0.1cm} m_j) \\
        &\equiv r_j  \hspace{0.2cm} (mod \hspace{0.1cm} m_j) \\
    \end{aligned}$

  * 其次，证明 $x = \sum_{i=1}^{n} r_i c_i c_i^{-1}$ $(mod$ $M)$ 对于每一个 $j$ 都有 $x \equiv r_j$ $(mod$ $m_j).$
 
    对于每一个 $m_j$ 来说，$mod$ $M$ 相当于减去 $m_j$ 的若干倍，不会影响余数 $r_j$ 的结果.
 
  证毕.

* 中国剩余定理的算法实现：

  对于 $M$ 和 $c_i$，可以在两次循环时分别计算；

  对于 $c_i^{-1}$，可以转化为利用 **扩展欧几里得算法** 求解：

  * 给定两个互质整数 $a,m$， 对于 $ax \equiv 1$ $(mod$ $m).$，求 $a$ 的乘法逆元 $x$ $(0 < x < m)$.

    把同余方程转化为不定方程.  
    由 $ax \equiv 1$ $(mod$ $m)$  
    得 $ax = m \times (-y) + 1$ （设为 $-y$ 便于移项后计算）  
    得 $ax + my = 1.$  
    转化为用 **扩欧求解不定方程** 求 $ax + my = 1 = gcd(a,m)$ 方程中 $x$ 的解.
  
    为确保得到的答案为 **最小正整数** ，最后答案为 $(x \% m + m) \% m.$  
    $e.g.$  $x = -7, m = 5, ans = (-7 \% 5 + 5) \% 5 = 3;$  
    $\hspace{0.6cm} x = 7, m = 5, ans = (7 \% 5 + 5) \% 5 = 2.$

#### 核心代码：
```cpp
// r，m是刚学的时候用的变量名，对应的是b和a数组
// 附加测试点竟然卡longlong，记得用__int128 qwq
LL exgcd(LL a, LL b, LL &x, LL &y)  //求逆元
{
	if(b == 0)
	{
		x = 1, y = 0;
		return a;
	}
	
	LL d, x1, y1;
	d = exgcd(b, a%b, x1, y1);
	x = y1, y = x1 - a/b*y1;
	return d;
}

LL CRT(LL r[], LL m[])   //中国剩余定理
{
	LL M = 1, ans = 0;
	for(int i = 1; i <= n; i ++)
		M *= m[i];
	
	for(int i = 1; i <= n; i ++)
	{
		LL c = M / m[i], x, y;
		exgcd(c, m[i], x, y);
		ans = (ans + (r[i] * c * x) % M) % M;
	}
	return (ans % M + M) % M;
}

signed main()
{
	n = read();
	for(int i = 1; i <= n; i ++)
		m[i] = read(), r[i] = read();
	
	print( CRT(r, m) );
	cout << '\n';
	
	return 0;
}
```

---

## 作者：Fish_egg_ (赞：5)

## [$\large\color{00aacd}\textbf{中国剩余定理（CRT）}$](https://www.luogu.com.cn/problem/P1495)

前置知识：同余、逆元、扩展欧几里得定理。

### $\color{00cd00}\text{算法介绍}$

中国剩余定理用于求解如下形式的同余方程组：
$$
\begin{cases}
x\equiv b_1 \pmod{a_1} \\
x\equiv b_2 \pmod{a_2} \\
\dots \\
x\equiv b_n \pmod{a_n}
\end{cases}
$$

其中，$a_1, a_2, \dots a_n$ 两两互质。

求解的过程如下：
1. 计算所有模数的积 $M = \prod\limits_{i=1}^n a_i$。
2. 依次考虑每一个方程。对于第 $i$ 个方程：
   - 计算 $m_i = M \div a_i$。
   - 计算 $m_i$ 在模 $a_i$ 意义下的逆元 $m_i^{-1}$。
      - 因为 $a_1, a_2, \dots, a_n$ 两两互质，显然有 $\gcd(m_i, a_i) = 1$，即逆元一定存在。
3. 最终，$x$ 最小的非负整数解为 $x = (\sum\limits_{i=1}^n m_i\cdot m_i^{-1}\cdot b_i) \bmod M$。

---

### $\color{00cd00}\text{正确性证明}$

我们需要证明，以上算法所得到的 $x$ 满足 $\forall i \in [1, n],\ x\equiv b_i \pmod{a_i}$。

根据以上 $m_i$ 的定义，可以得到当 $i\ne j$ 时，$m_j\equiv 0 \pmod{a_i}$。

又根据逆元的定义，可以得到 $m_i \cdot m_i^{-1} \equiv 1 \pmod{a_i}$。

因此：
$$
\begin{aligned}
x &\equiv \sum_{j=1}^n m_j\cdot m_j^{-1}\cdot b_j  &\pmod{a_i} \\
&\equiv m_i\cdot m_i^{-1}\cdot b_i &\pmod{a_i} \\
&\equiv b_i &\pmod{a_i}
\end{aligned}
$$

即：$\forall i \in [1, n],\ x\equiv b_i \pmod{a_i}$。算法的正确性得证。

---

### $\color{00cd00}\text{代码实现}$

由于 $a_i$ 不一定是质数，不能用费马小定理求逆元，所以用了扩展欧几里得定理来求。

C++:

本题运算过程中可能会爆 `long long`，需要使用 `__int128` 才能通过。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 15;
int n, a[N], b[N];
pair<int, int> exgcd(int a, int b){
	if(b == 0) return {1, 0};
	auto [x, y] = exgcd(b, a % b);
	return {y, x - a / b * y};
}
int inv(int a, int p){
	auto [x, y] = exgcd(a, p);
	return (x + p) % p; //exgcd 求出的解有可能是负的，所以取模一下转成正的
}
int CRT(int n, int *a, int *b){
	int M = 1, x = 0;
	for(int i=1; i<=n; i++) M *= a[i];
	for(int i=1; i<=n; i++){
		__int128 Mi = M / a[i], Ti = inv(Mi, a[i]);
		x = (x + Mi * Ti * b[i] % M) % M;
	}
	return x;
}
signed main(){
	cin.tie(nullptr) -> sync_with_stdio(false);
	cin >> n;
	for(int i=1; i<=n; i++) cin >> a[i] >> b[i];
	cout << CRT(n, a, b);
	return 0;
}
```

Python:

```python
def exgcd(a, b):
    if b == 0: return (1, 0)
    x, y = exgcd(b, a % b)
    return y, x - a // b * y
    
def inv(a, p): return exgcd(a, p)[0] % p

def CRT(n, a, b):
    M = 1; x = 0
    for i in range(n): M *= a[i]
    for i in range(n):
        Mi = M // a[i]; Ti = inv(Mi, a[i])
        x += Mi * Ti * b[i]
    return x % M

def main():
    n = int(input())
    a = [0] * n; b = [0] * n
    for i in range(n):
        a[i], b[i] = map(int, input().split())
    print(CRT(n, a, b))

if __name__ == '__main__':
    main()
```

---

## 作者：DX3906_ourstar (赞：5)

~~看到题面第一反应：小学奥数？~~

~~其实咱小时候都是巨佬，比如一笔画问题，它的大名叫欧拉路径。~~

废话结束，正片开始。

本篇题解主要参考自 [寒假集训时的课件](https://s3.hydro.ac/hydro/l34/7jnadfvpwcn8fglowq202.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=hydro%2F20250306%2FAuto%2Fs3%2Faws4_request&X-Amz-Date=20250306T045335Z&X-Amz-Expires=1800&X-Amz-Signature=6d3cee28aaccb084e13241d327a5a6373e641c5e8ca0b245651879ae5da1797f&X-Amz-SignedHeaders=host&response-content-disposition=&x-id=GetObject)。

中国剩余定理，主要用于求解线性同余方程组，也就是形似这样的一堆式子。

$$
\begin{cases}
x \equiv r_1 \pmod{m_1}\\
x \equiv r_2 \pmod{m_2}\\
\cdots\\
x \equiv r_n \pmod{m_n}
\end{cases}
$$

在接下来的讲解中，我们记 $r$ 为余数集合，$m$ 为余数集合，$n$ 为方程数量。

那么，依据中国剩余定理，我们就可以这样解上面的方程组：

1. 求 $\prod\limits^n_{i=1}$，并将其记为 $M$；

2. 定义一个新集合 $c$，其通项式为 $c_i=\frac{M}{m_i}$；

3. 对于 $\forall i \in [1,n]$，计算 $c_i$ 在模 $m_i$ 意义下的逆元，并写入新集合 $d$；

4. $x_{\min}$ 即为 $\sum\limits^n_{i=1}r_ic_id_i \bmod M$。

再回来看本题。为什么想到 CRT？~~因为标题~~ 因为题意可以直接转化为：给定由 $n$ 个形似 $x \equiv b \mod a$ 的线性同余方程构成的方程组，求 $x$ 的最小值。

至此，我们就可以写出一份 AC 代码了。


```
#include<iostream>
#define ll __int128
using namespace std;

const int N=1e1+5;

int n;
ll ans;

namespace OIfast{
	
	inline ll read(){
		register ll n=0,f=1;
		register char c=getchar();
		while(c<'0'||c>'9'){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9'){
			n=(n<<1)+(n<<3)+(c^48);
			c=getchar();
		}
		return n*f;
	}
	
	inline void print(register ll n){
		if(n<0)n=~n+1,putchar('-');
		if(n>=10)print(n/10);
		putchar(n%10^48);
		return ;
	}
	
	inline void write(register ll n,register char c){
		print(n),putchar(c);
		return ;
	}
	
}using namespace OIfast;

namespace numberTheoryTools{
	
	ll m=1;
	ll x,y;
	ll a[N]/*模数*/,b[N];
	
	inline void exgcd(ll a,ll b){
		if(b==0){
			x=1,y=0;
			return ;
		}
		exgcd(b,a%b);
		ll tmp=x;
		x=y;
		y=tmp-a/b*y;
//		cout<<"x:"<<x<<",y:"<<y<<"\n";
		return ;
	}
	
}using namespace numberTheoryTools;

signed main(){
//	freopen("P1495_3.in","r",stdin);
	n=read();
	for(int i=1;i<=n;++i){
		a[i]=read();
		b[i]=read();
		m*=a[i];
	}
	for(int i=1;i<=n;++i){
		ll c=m/a[i];
		exgcd(c,a[i]);
		ans=((ans+b[i]*c*x)%m+m)%m;
	}
	write(ans,'\n');
	return 0;
}
```

~~当时写的时候没用上面提到的变量名，懒得改了。~~

那么这时候就有同学会问了：这样做的依据是什么？

那么，接下来，我们就一起证明一下 CRT。

~~宣一下大佬 XXh 的 [证明](https://www.luogu.me/article/6zuozcp7)。~~

先看到我们最终得出答案的式子：

$$\sum\limits^n_{i=1}r_ic_id_i \bmod M$$


容易发现，对于 $\forall i \in [1,n]$，都有 $x\equiv r_i \pmod {m_i}$。

接下来再随便找一个 $j$，分情况讨论。

首先，考虑 $i \neq j$。此时 $c_j \equiv 0 \pmod{m_i}$，那么容易发现，$c_jd_j \equiv 0 \pmod{m_i}$。

然后，考虑 $i = j$。易证 $c_j \not\equiv 0 \pmod{m_i}$，则显然有 $c_jd_j \equiv 1 \pmod{m_i}$。

于是，分讨完毕，我们来整合一下。下面的计算都在模 $m_i$ 意义下进行。

$$
\begin{align*}
x&=\sum\limits^n_{i=1}r_ic_id_i \\
&=r_ic_id_i \\
&=r_i
\end{align*}
$$

$\sum\limits^n_{i=1}r_ic_id_i$ 对于 $m_i$ 来说，只是减去了 $am_i$，其中 $a \in \mathbb{N^+}$。

所以，$r_i$ 必然不受影响。

**至此，中国剩余定理（CRT），得证。**

---

## 作者：GoldenSTEVE7 (赞：3)

## 题意简述
我们可以把题意简化成这样：

给定 $n$ 组非负整数 $a_i, b_i$，求方程组的最小整数解。
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

## 中国剩余定理（CRT）
看标题就知道这题是啥了，那我们来看看这个定理吧。

----
接下来是这道题的数学部分：

先说定理，上述同余方程组的通解为
$$x \equiv M_1N_1b_1+ \cdots + M_nN_nb_n \pmod m$$
其中 $m = a_1a_2\cdots a_n$ 且对于所有的 $i \in [1,n]$，均有 $M_i = \frac{m}{a_i}$ 且 $M_iN_i \equiv 1 \pmod {m_i} $

看起来是不是很晕，没错，接下来我来带大家证明一下。

我们先假设方程通解 $x \equiv x_1 + x_2 + x_3 + \cdots + x_n \pmod {m}$

并且由
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

我们希望 $x$ 的形式为
$$\begin{cases}
x\equiv b_1+0+0+\dots+0\pmod{a_1}\\
x\equiv 0+b_2+0+\dots+0\pmod{a_2}\\
x\equiv 0+0+b_3+\dots+0\pmod{a_3}\\
\dots\\
x\equiv 0+0+0+\dots+b_n\pmod{a_n}\\
\end{cases}$$

这样我们就能保证 $x$ 为原方程的解。

好，我们搞清楚这件事后，来看看这组式子需要满足什么呢？

对于所有的 $0$，保证其对应的那项 $x_i$ 能被对应的模数整除即可，即对于所有的 $i \in [1,n]$，均有

$$
x_i \equiv b_i \pmod {a_i}
$$

且
$$
x_i \equiv 0 \pmod {M_i}
$$

由于 $(M_i, m_i) = 1$，很容易想到取逆元，我们取 $N_i \equiv M_i^{-1} \pmod {m_i}$ 即可，这时 $x_i \equiv b_iM_iN_i \pmod m$ 就可满足上面的条件。

此时，$x \equiv M_1N_1b_1+ \cdots + M_nN_nb_n \pmod m$，证毕！

----
蒙了吗？没逝后面还有。下面是编程部分：

题目中已经给出了互质的条件，直接相乘模数即可。我们可以用一个比较巧妙的方法求解，对于所有未满足上面 $x$ 的通解的形式的，我们给最终答案累加上我们要的 $b_iM_iN_i$ 这一项，若满足通解的形式，直接跳过就行。这种情况下一定是最小解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[11], b[11];
int main() {
	long long tot, ans;
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i] >> b[i];
	}
	ans = b[1];//答案
	tot = a[1];//目前已经满足的条件中模数的乘积
	for(int i = 2; i <= n; i++) {
		while(ans % a[i] != b[i]) {
			ans += tot;//枚举即可
		}
		tot *= a[i];
	}
	cout << ans;
}
```

---

## 作者：zhangjizhi (赞：3)

CRT 模板当然要用 CRT 了。（bushi）

简单介绍 CRT（源自 oiwiki）：

## 定义

中国剩余定理（Chinese Remainder Theorem，CRT）可求解如下形式的一元线性同余方程组（其中 $n_1,n_2, \dotsi ,n_k$ 两两互质）：

$$ \begin{cases}
x \equiv a_1 (mod\ n_1)\\
x \equiv a_2 (mod\ n_2)\\
\quad \vdots\\
x \equiv a_k (mod\ n_k)
\end{cases}
$$

## 过程
（该部分与 oiwiki 上的过程略有不一样，出自我们机房的 [XXh神犇](https://www.luogu.com.cn/user/814145)）

设 $M=\prod_{i=1}^k n_i$，$m_i=\frac{M}{n_i}$，$t_i$ 为 $m_i$ 在模 $n_i$ 意义下的逆元 $m_i^{-1}$，
$c_i=m_i\times t_i$则答案为 $x=\sum_{i=1}^k a_ic_i$。

## 证明
我们需要证明上面算法计算所得的 $x$ 对于任意 $i=1,2,\dotsi,k$ 满足 $x\equiv a_i\ (mod\ n_i)$。

当 $i\not =j$ 时，有 $m_j\equiv0\ (mod\ n_i)$，故 $c_j\equiv m_j\equiv 0\ (mod\ n_i)$。又有 $c_i\equiv m_i\cdot(t_i\ mod\ n_i) \equiv 1\ (mod\ n_i)$，所以有：

$$
\begin{aligned}
x&\equiv\sum_{j=1}^k a_jc_j&\qquad (mod\ n_i)\\
 &\equiv a_ic_i&\qquad (mod\ n_i)\\
 &\equiv a_i\cdot m_i\cdot(t_i\ mod\ n_i)&\qquad (mod\ n_i)\\
 &\equiv a_i&\qquad (mod\ n_i)
\end{aligned}
$$
证毕。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int qcheng(int a,int b,int mod)
{
	int ans=0;
	a%=mod;
	b%=mod;
	while(b)
	{
		if(b&1) ans=(ans+a)%mod;
		b>>=1;
		a=(a+a)%mod;
	}
	return ans;
}
int exgcd(int a,int b,int &x,int &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,x,y);
	int t=x;
	x=y,y=t-(a/b)*y;
	return d;
}
int k,a[100001],n[100001],x,y,m,M,t[100001],sum;
signed main()
{
	cin>>k;
	m=1;
	for(int i=1;i<=k;i++)
	{
		cin>>a[i]>>n[i];
		m*=a[i];
	}
	for(int i=1;i<=k;i++)
	{
		M=m/a[i];
		int shu=exgcd(M,a[i],x,y);\\求逆元
		x=(x%a[i]+a[i])%a[i];
		sum=(sum+(qcheng(qcheng(M,x,m),n[i],m)%m+m))%m;\\慢乘防溢出
	}
	cout<<sum;
	return 0;
}
```

做完后可尝试 [P4777EXCRT](https://www.luogu.com.cn/problem/P4777)。

---

## 作者：XXh0919 (赞：3)

又来写题解了。

### 中国剩余定理（CRT）

~~也称中国单身狗定理。~~

这个定理其实就是让你求一个同余方程组的解，具体内容如下：

设 $m_1,m_2,m_3,...,m_n$ 是两两互质的整数，设 $M=\prod\limits_{i=1}^{n}m_i$，$m'_i=\frac{M}{m_i}$，$t_i$ 是线性同余方程 $m_i't_i\equiv1(\text{mod}\ m_i)$ 的一个解，对于任意 $n$ 个整数 $a_1,a_2,a_3,...,a_n$，方程组

$$\begin{cases}
 x\equiv a_1\pmod {m_1}\\
 x\equiv a_2\pmod {m_2}\\
 x\equiv a_3\pmod {m_3}\\
 \cdot\cdot\cdot\\
 x\equiv a_n\pmod {m_n}\\
\end{cases}$$

有整数解，解为 $x=\sum\limits_{i=1}^{n}a_im_i't_i$。

**证明：**

因为 $m'_i=\frac{M}{m_i}$，也就是说对于 $\forall k\ne i$ 都有 $a_im_i't_i\equiv0\pmod {m_k}$。又因为 $a_im_i't_i\equiv a_i\pmod {m_i}$，代入原方程组可得 $x=\sum\limits_{i=1}^{n}a_im_i't_i$。

证毕。

而本题其实就是给出 $n$ 个同余方程，将它们组成同余方程组，然后用 CRT 解决这个问题。具体过程就按照证明步骤一步一步来就行了。

### Code：

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int N = 1e6 + 15, inf = 1e9 + 7;

const bool I_LOVE_CCF = true;

int n;
int a[N], b[N], m = 1;
int M[N], t[N];

inline int read (int &n) {
	int x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) {
		if (ch == '-') f = -1;
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar ();
	}
	n = x * f;
	return n;
}

int exgcd (int a, int b, int &x, int &y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int d = exgcd (b, a % b, x, y);
	int tmp = x;
	x = y;
	y = tmp - y * (a / b);
	return d;
}

int mul (int a, int b, int mod) {
	int ans = 0;
	while (b) {
		if (b & 1) ans = (ans + a) % mod;
		b >>= 1;
		a = (a + a) % mod;
	}
	return ans % mod;
}

int quick_power (int a, int b, int mod) {
	int ans = 1;
	while (b) {
		if (b & 1) ans = (ans * a + mod) % mod;
		b >>= 1;
		a = (a * a + mod) % mod;
	}
	return ans % mod;
}

int CRT () {
	rep (i, 1, n) M[i] = m / a[i];
	rep (i, 1, n) {
		int y;
		exgcd (M[i], a[i], t[i], y);
		t[i] = (t[i] % a[i] + a[i]) % a[i];
	}
	int ans = 0;
	rep (i, 1, n) {
		ans = (ans + mul (mul (b[i], M[i], m), t[i], m));
	}
	return ans % m;
}

signed main () {
	read (n);
	rep (i, 1, n) read (a[i]), read (b[i]), m *= a[i];
	printf ("%lld\n", CRT ());
	return 0;
}
```

---

## 作者：PaperBacon (赞：3)

# [P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪](https://www.luogu.com.cn/problem/P1495) 题解
## 题目大意
给定 $n$ 个同余方程 $x \equiv b_i \pmod{a_i}$，其中 $a_1,a_2,...,a_n$ **两两互质**。求满足所有方程的最小正整数解。
## 数学证明
### 充分性证明
令
$$M = \prod_{i=1}^n a_i$$
对每个 $i$ 定义
$$M_i = \frac{M}{a_i}$$
由于 $a_i$ 与 $M_i$ 互质（各 $a_i$ 彼此互质），由 **扩展欧几里得算法** 可知，存在逆元 $t_i$ 使得
$$M_i t_i \equiv 1 \pmod{a_i}$$
构造候选解：
$$x = \sum_{i=1}^{k} b_i M_i t_i$$
**验证：** 对于任意固定的 $i$，考虑 $x$ 对 $m_i$ 的余数：
$$x \equiv \sum_{j=1}^{k} b_j M_j t_j \pmod{a_i}$$
注意：当 $j \neq i$ 时，由于 $a_i$ 是 $M_j$ 的因子（$M_j = M/a_j$ 包含所有除 $a_j$ 外的因子），有
$$M_j \equiv 0 \pmod{a_i}$$
因此，
$$x \equiv b_i M_i t_i \pmod{a_i}$$
又由 $M_i t_i \equiv 1 \pmod{a_i}$ 得：
$$x \equiv b_i \pmod{a_i}$$
这表明我们构造出的解 $x$ 同时满足所有的同余关系。
### 唯一性证明
设 $x_1$ 与 $x_2$ 均为解，则有
$$\forall i,\ x_1 \equiv x_2 \pmod{a_i}$$
这说明 $a_i$ 整除 $x_1 - x_2$ 对所有 $i$ 都成立。由于 $a_1, a_2, \dots, a_k$ 两两互质，它们的乘积 $M$ 也整除 $x_1 - x_2$：
$$x_1 \equiv x_2 \pmod{M}$$
因此，解在模 $M$ 意义下是唯一的。
## 实现步骤
1. **计算总模数**：$M = a_1 \times a_2 \times \dots \times a_n$
2. **逐项处理**：
    - 计算每个方程的 $M_i = M / a_i$
    - 求逆元 $t_i$ 使得 $M_i t_i \equiv 1 \pmod{a_i}$（这里我的代码中使用了 **EXGCD** 处理，如果你没有听说过什么是 **EXGCD**，那么你可以阅读 [扩展欧几里得算法-OI Wiki](https://oi-wiki.org/math/number-theory/gcd/) 这篇参考资料。）
    - 累加项：$ans = (ans + b_i \times M_i \times t_i) \mod M$
参考资料：[中国剩余定理-OI Wiki](https://oi-wiki.org/math/number-theory/crt/)
## 代码实现
```cpp
#include "bits/stdc++.h"
#define vtr vector
using namespace std;
using ll = long long;

ll exgcd(ll a,ll b,ll &x,ll &y){
    if(b == 0){
        x = 1;y = 0;
        return a;
    }
    ll d = exgcd(b,a % b,y,x);
    y -= a / b * x;
    return d;
}
ll inv(ll a,ll mod){
    ll x,y;
    exgcd(a,mod,x,y);
    return (x % mod + mod) % mod;
}

void solve(){
	int n;cin >> n;
    vtr<ll> a(n),b(n);
    ll M = 1;
    for(int i = 0;i < n;++i){
        cin >> a[i] >> b[i];
        M *= a[i];
    }
    ll ans = 0;
   	for(int i = 0;i < n;++i){
        ll Mi = M / a[i];
        ll ti = inv(Mi,a[i]);
        __int128 term = (__int128)b[i] * Mi % M;//这边要注意大数乘法可能爆LL
        term = term * ti % M;
        ans = (ans + (ll)term) % M;
    }
    ans = (ans % M + M) % M;
    cout << ans << '\n';
}

int main(void){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int _ = 1;//cin >> _;
	while (_--)solve();
	return 0;
}
```

---

## 作者：chrispang (赞：1)

1. 将式子等价转换

$$ x \equiv m_1 \pmod {a_1} $$。

$$ x \equiv m_2 \pmod {a_2} $$。

则有：

$$ x = k_1 \cdot a_1 + m_1 $$。

$$ x = k_2 \cdot a_2 + m_2 $$。

进一步：

$$ k_1 \cdot a_1 + m_1 = k_2 \cdot a_2 + m_2 $$。

移项：

$$ k_1 \cdot a_1 - k_2 \cdot a_2 = m_2 - m_1 $$。

也就是： $$ ①k_1 \cdot a_1 + k_2 \cdot (-a_2) = m_2 - m_1 $$。

我们需要找到一个最小的 $ k_1, k_2 $，使得等式成立（因为要求 $ x $ 最小，而 $ a $ 和 $ m $ 都是正数）。

2. 使用扩展欧几里得求出一组解

使用扩展欧几里得求出 $$ k_1' \cdot a_1 + k_2' \cdot (-a_2) = \gcd(a_1, -a_2) $$ 的解。

$$ \text{若 } \gcd(a_1, -a_2) \nmid (m_2 - m_1) \text{，则无解。} $$

我们设 $ d = \gcd(a_1, -a_2) $， $ y = \frac{(m_2 - m_1)}{d} $ 承接上文，我们只需让 $ k_1, k_2 $ 分别扩大 $ y $ 倍，则可以找到一个 $ k_1, k_2 $ 满足 $①$ 式： $ k_1 = k_1' \times y,k_2 = k_2' \times y $。

3. 找到最小正整数解

$$② k_1' = k_1 + k \cdot \frac{a_2}{d} $$。

$$ k_2' = k_2 + k \cdot \frac{a_1}{d} $$。

$ k $ 为任意整数，这时新的 $ k_1', k_2' $ 仍满足 $①$ 式（上面求特解，这里是在特解的基础上求通解）。

想要找到最小整数解，只要让

$$ k_1 = k_1' \bmod \left| \frac{a_2}{d} \right| $$。

$$k_2 = k_2' \bmod \left| \frac{a_1}{d} \right| $$。

4. 等效替代

由 $②$ 式带入，新的 $x$ 为：

$$
x = \left( k_1' + k \cdot \frac{a_2}{d} \right) \cdot a_1 + m_1
$$

$$
= k_1' \cdot a_1 + m_1 + k \cdot \frac{a_2 \cdot a_1}{d}
$$

$$
= k_1' \cdot a_1 + m_1 + k \cdot \text{lcm}(a_1, a_2) \quad ③
$$

在③中，我们设 $a_0 = \text{lcm}(a_1, a_2)$，$m_0 = k_1' \cdot a_1 + m_1$。

那么：

$$
③ = k \cdot a_0 + m_0
$$

这个形式与一开始我们分解的形式是不是特别像呢？

没错！假设之后又来了一个 $a_3, m_3$

我们只需要继续找：

$$
x = k \cdot a_0 + m_0 = k_3 \cdot (-a_3) + m_3
$$

那么问题又回到了第一步。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int exgcd(int a, int b, int &x, int &y) {
	if(b == 0) {
		x = 1, y = 0; //b = 0的情况 
		return a;
	}
    int x1, y1;
    int d = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - a / b * y1;
	return d;
}

int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}

int mod(int a, int b) {
    return ((a % b) + b) % b;
}

int n, a1, m1;
signed main() {
	scanf("%lld%lld%lld", &n, &a1, &m1);
	for (int i = 1, a2, m2; i < n; i++) {
		scanf("%lld%lld", &a2, &m2);
		int c = m2 - m1, k1 = 0, k2 = 0;
		int d = exgcd(a1, -a2, k1, k2); //扩展欧几里得 
		if((m2 - m1) % d) { //不能整除 
			cout << -1 << endl;
			return 0;
		}
		k1 = mod(k1 * (m2 - m1) / d, abs(a2 / d)); //前面是为了找解，后面是为了找最小解
		m1 = abs(a1 * k1 + m1); //为了下一次做准备 
		a1 = abs(a1 / d * a2); 
	}
	cout << m1 << endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

#### 算法介绍
[中国剩余定理](https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597)
#### 正确性证明
计算所有 $a_i$ 的乘积：$M=a_1 \times a_2 \times … \times a_n$。  

对于每个 $i$，计算 $M_i=M/a_i$。  

对于每个 $i$，计算 $M_i$ 在模 $a_i$ 下的逆元 $inv_i$，即满足 $M_i \times inv_i \equiv 1 (\bmod$ $a_i)$。

解为：  
$$\sum_{i=1}^{n} b_i \times M_i \times inv_i$$  

最终解为 $x$ $\bmod$ $M$。    
#### 代码

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;

lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=100010;
int n;
lt ai[maxn],bi[maxn];

lt mul(lt a,lt b,lt mod)
{
    lt res=0;
    while(b>0)
    {
        if(b&1) res=(res+a)%mod;
        a=(a+a)%mod;
        b>>=1;
    }
    return res;
}

lt exgcd(lt a,lt b,lt &x,lt &y)
{
    if(b==0){x=1;y=0;return a;}
    lt gcd=exgcd(b,a%b,x,y);
    lt tp=x;
    x=y; y=tp-a/b*y;
    return gcd;
}

lt excrt()
{
    lt x,y,k;
    lt M=bi[1],ans=ai[1];
    for(int i=2;i<=n;i++)
    {
        lt a=M,b=bi[i],c=(ai[i]-ans%b+b)%b;//ax≡c(mod b)
        lt gcd=exgcd(a,b,x,y),bg=b/gcd;
        if(c%gcd!=0) return -1; 
        
        x=mul(x,c/gcd,bg);
        ans+=x*M;
        M*=bg;
        ans=(ans%M+M)%M;
    }
    return (ans%M+M)%M;
}

int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    bi[i]=read(),ai[i]=read();
    printf("%lld",excrt());
    return 0;
}
```

---

## 作者：xy_mc (赞：0)

六百六十六，这道题连 long long 都要卡……

### 中国剩余定理介绍：

- 中国剩余定理可求解如下形式的一元线性同余方程组：
  $$
  \begin{cases}
  x \equiv b_1 \pmod{a_1} \\
  x \equiv b_2 \pmod{a_2} \\
  \quad \vdots \\
  x \equiv b_n \pmod{a_n}
  \end{cases}
  $$

- 操作过程：

    1. 先计算 $\prod_{i=1}^na_i$，即所有模数的乘积，记为 $p$；
    2. 对于第 $i$ 个方程：
 
         a. 先计算 $m_i=\frac{p}{a_i}$；
       
         b. 再计算 $m_i$ 在模 $a_i$ 意义下的逆元 $m_i^{-1}$；
       
         c. 最后计算 $c_i=m_im_i^{-1}$（不要对 $a_i$ 取模）。
    3. 方程组在模 $p$ 意义下的唯一解为：$x=\sum_{i=1}^k b_ic_i \pmod p$。

### 证明：

 - 验证解满足所有同余方程：

   
   对任意 $j$，需证明 $x \equiv b_j \pmod {a_j}$。


   - 观察 $c_i$ 的模 $a_j$ 性质：
     
      当 $i \neq j$ 时，$m_i = \frac{p}{a_i}$ 包含 $a_j$ 作为因子（因为 $a_i$ 与 $a_j$ 互质），故 $m_i \equiv 0 \pmod{a_j}$，从而 $c_i = m_i  m_i^{-1} \equiv 0 \pmod{a_j}$。
  
      当 $i = j$ 时，$m_j = \frac{p}{a_j}$ 与 $a_j$ 互质（因为 $a_j$ 与其他模数互质），故 $m_j^{-1}$ 存在，且 $c_j = m_j  m_j^{-1} \equiv 1 \pmod{a_j}$。

    - 代入解的表达式
  
      
      对 $x$ 取模 $a_j$：
      $$x \equiv \sum_{i=1}^n b_i c_i \pmod{a_j} \equiv b_j \cdot 1+ \sum_{i \neq j} b_i \cdot 0 \equiv b_j \pmod{a_j}$$
    因此，$x$ 满足所有同余方程。

- 证明解在模 $p$ 下唯一：

  假设存在两个解 $x_1$ 和 $x_2$，则对任意 $i$，有：
  $$x_1 \equiv x_2 \equiv b_i \pmod{a_i}$$
  由于 $a_1, a_2, \dots, a_k$ 两两互质，根据同余的合并性质，有：

  $$x_1 \equiv x_2 \pmod{p}$$

  因此在模 $p$ 的意义下，解是唯一的。

- 逆元的存在性:

  对任意 $i$，$m_i = \frac{p}{a_i}$ 与 $a_i$ 互质。  
  - 因为 $a_i$ 与其他模数两两互质，所以 $m_i$ 不包含 $a_i$ 的因子。  
  - 由[ Bézout 定理](https://oi-wiki.org/math/number-theory/bezouts/)，存在整数 $m_i^{-1}$ 使得 $m_i \cdot m_i^{-1} \equiv 1 \pmod{a_i}$。

### 代码：
```cpp
#include<bits/stdc++.h>
#define inl inline
#define reg register
#define int long long
#define lll __int128
#define rep(i,x,y) for(reg int i=x;i<=(y);++i)
#define per(i,x,y) for(reg int i=x;i>=(y);--i)
using namespace std;
int n,p=1,x,y,ans;
int a[20],b[20],m[20],inv[20],c[20]; 
void exgcd(int a,int b){
	if(b==0){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b);
	int t=x;
	x=y;
	y=t-(a/b)*y;
}
signed main(){
    cin>>n;
    rep(i,1,n){
    	cin>>a[i]>>b[i];
    	p*=a[i];
	}
	rep(i,1,n) m[i]=p/a[i];
	rep(i,1,n){
		exgcd(m[i],a[i]);
		inv[i]=x;
	}
	rep(i,1,n) c[i]=m[i]*inv[i];
	rep(i,1,n){
		lll fans=((lll)b[i]*c[i]%p);
		ans+=((int)fans)%p;
	}
	cout<<(ans%p+p)%p;
	return 0;
}

```

---


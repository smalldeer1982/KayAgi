# [省选联考 2025] 推箱子

## 题目描述

在一条无穷长的数轴上摆放着 $n$ 个箱子。第 $i$ ($1 \leq i \leq n$) 个箱子在时刻 0 位于数轴 $a_i$ 处，而你希望在时刻 $t_i$ 以及**之后的所有时刻**，这个箱子处在数轴的 $b_i$ 处。保证序列 $[a_1, \ldots, a_n]$ 和 $[b_1, \ldots, b_n]$ **单调递增**。

为此，从时刻 $0$ 开始的每个单位时间里，你可以将某个箱子在数轴上移动一个单位长度，也可以什么都不做。你需要保证任意时刻每个点上都只有一个箱子。形式化地，每个单位时间里你可以按照以下方式进行一次操作，也可以不进行操作：
1. 选择任意一个箱子。记其编号为 $i$，它目前的位置为 $p_i$。
2. 选择一个方向 $d \in \{\pm1\}$，其中 $d = 1$ 代表向右，$d = -1$ 代表向左。你需要保证数轴上 $(p_i + d)$ 处没有箱子。
3. 将 $i$ 号箱子从点 $p_i$ 移动到点 $(p_i + d)$ 处。

你想知道，是否存在一种操作方法同时满足所有箱子的要求，即对于任意 $1 \leq i \leq n$，第 $i$ 个箱子在时刻 $t_i$ 以及之后的所有时刻都处于数轴的 $b_i$ 处。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，答案是否定的。将 1 号箱子由点 4 移动到点 5，并将 2 号箱子由点 6 移动到点 7，至少需要两个单位时间，因此不可能在时刻 1 同时满足两个箱子的条件。
- 对于第二组测试数据，答案是肯定的，例如如下方法同时满足了所有箱子的要求：
 - 在时刻 0 至时刻 1 的一个单位时间，将 2 号箱子由点 7 移动到点 6；
 - 在时刻 1 至时刻 2 的一个单位时间，将 3 号箱子由点 10 移动到点 9；
 - 在时刻 2 至时刻 3 的一个单位时间，将 1 号箱子由点 4 移动到点 5；
 - 在时刻 3 至时刻 4 的一个单位时间，将 3 号箱子由点 9 移动到点 8；
 - 在之后的所有单位时间，什么都不做。
 
**【样例 2】**

见选手目录下的 `move/move2.in` 与 `move/move2.ans`。

该组样例共有 $6$ 组测试数据，所有数据均满足特殊性质 A。其中每组测试数据的 $n$ 分别为 $7$、$7$、$7$、$200$、$3\,000$、$2 \times 10^5$，且测试数据 $1 \sim 3$ 满足 $a_i, b_i \leq 15$，测试数据 $4$ 满足 $a_i, b_i \leq 3,000$。

**【样例 3】**

见选手目录下的 `move/move3.in` 与 `move/move3.ans`。

该组样例共有 $6$ 组测试数据，所有数据均满足特殊性质 B。其中每组测试数据的 $n$ 分别为 $7$、$7$、$7$、$200$、$3\,000$、$2 \times 10^5$，且测试数据 $1 \sim 3$ 满足 $a_i, b_i \leq 15$，测试数据 $4$ 满足 $a_i, b_i \leq 3,000$。

**【样例 4】**

见选手目录下的 `move/move4.in` 与 `move/move4.ans`。

该组样例共有 $6$ 组测试数据，所有数据均满足特殊性质 C。其中每组测试数据的 $n$ 分别为 $7$、$7$、$7$、$200$、$3\,000$、$2 \times 10^5$，且测试数据 $1 \sim 3$ 满足 $a_i, b_i \leq 15$，测试数据 $4$ 满足 $a_i, b_i \leq 3,000$。

**【样例 5】**

见选手目录下的 `move/move5.in` 与 `move/move5.ans`。

该组样例共有 $6$ 组测试数据。其中每组测试数据的 $n$ 分别为 $7$、$7$、$7$、$200$、$3\,000$、$2 \times 10^5$，且测试数据 $1 \sim 3$ 满足 $a_i, b_i \leq 15$，测试数据 $4$ 满足 $a_i, b_i \leq 3,000$。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 6$,
- $1 \leq n \leq 2 \times 10^5$,
- $\forall 1 \leq i \leq n, 1 \leq a_i, b_i \leq 10^9, 0 \leq t_i \leq 10^{16}$,
- $\forall 1 \leq i < n, a_i < a_{i+1}, b_i < b_{i+1}$。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | $a_i, b_i \leq$ | 特殊性质 |
|:------------:|:------------:|:-------------------:|:----------:|
| $1$ | $7$ | $15$ | A |
| $2, 3$ | ^ | ^ | 无 |
| $4$ | $200$ | $3\,000$ | A |
| $5$ | ^ | ^ | B |
| $6, 7$ | ^ | ^ | 无 |
| $8$ | $3\,000$ | $10^9$ | A |
| $9$ | ^ | ^ | B |
| $10, 11$ | ^ | ^ | 无 |
| $12$ | $8 \times 10^4$ | $5 \times 10^5$ | A |
| $13$ | ^ | ^ | B |
| $14, 15$ | ^ | ^ | C |
| $16 \sim 18$ | ^ | ^ | 无 |
| $19, 20$ | $2 \times 10^5$ | $10^9$ | B |
| $21, 22$ | ^ | ^ | C |
| $23 \sim 25$ | ^ | ^ | 无 |

- 特殊性质 A：$\forall 1 \leq i < j \leq n, t_i = t_j$。
- 特殊性质 B：$\forall 1 \leq i \leq n, a_i \leq b_i$ 且 $\forall 1 \leq i < n, b_i < a_{i+1}$。
- 特殊性质 C：$\forall 1 \leq i \leq n, a_i \leq b_i$。

## 样例 #1

### 输入

```
0 2
2
4 5 1
6 7 1
3
4 5 3
7 6 1
10 8 4```

### 输出

```
No
Yes```

# 题解

## 作者：cff_0102 (赞：31)

提供一种全新的可并堆做法，也是我考场上想到的做法（虽然当时没调出来）。

首先，可以倒着考虑整个过程：想象时间倒着流动到零，第 $i$ 个箱子刚开始在 $b_i$，当时间流动到 $t_i$ 时才可以开始移动，当时间回到 $0$ 时，它需要位于 $a_i$。

根据这个想法，可以首先将所有箱子按 $t$ 从大到小排序。至于当 $t$ 相同时如何处理稍后再说。

这样，就会发现，每到达一个新的 $t_i$ 时，就有（至少）一个新的箱子可以移动，而“先前”因为被这个箱子挡住的其它箱子也在此时才可以开始继续往 $a_i$ 的方向移动。

因此可以开一个数组 $mov$，$mov_i$ 表示有几次移动是在（排序后的）$t_i$ 这个时刻“开始后”才可以进行的。不难发现得出这个数组后，具体每次移动的顺序是不重要的，因为总是可以找到一种移动的方法使每一步（如果还需要的话）都可以让一个箱子往“终点”的方向移动。

只要知道了这个数组的值，接下来判断是否有解就简单了：贪心地让每次尽量让每个操作都靠前进行，如果最后到 $0$ 时刻还有操作需要进行则无解，否则有解。

代码片段：

```cpp
for(int i=1;i<=n;i++){
	int x=mov[i];
	mov[i]=min(mov[i],a[i].t-a[i+1].t);
	x-=mov[i];
	mov[i+1]+=x;
}
if(mov[n+1]){
	cout<<"No\n";
}else{
	cout<<"Yes\n";
}
```

接下来问题就是怎么搞出 $mov$ 数组了，首先可以想到一个 $n^2$ 暴力跳的方法：

仍然是按照时间从后到前遍历每个箱子（后面的编号都指按时间从大到小排序后的编号）。遍历到第 $i$ 个箱子时，此时它应该仍然处在 $b_i$ 的位置，要前往 $a_i$。为了方便，先假设 $a_i>b_i$。首先对于每个箱子预处理出它后面第一个时间“晚于”它（实际上是 $t$ 比它更小）的箱子的编号。那么就可以找到箱子 $i$ 后面第一个从时间上看可能会挡住它的箱子 $x$，再判断它是否会挡住这个箱子。
- 如果会挡住，那么 $i$ 就还需要等待到 $x$ 号箱子可以移动后才可以继续前进。此时就将 $mov_i$ 增加移到 $x$ 号箱子前的步数，然后假设当前箱子移到了 $x$ 号箱子的位置，并继续考虑当 $x$ 号箱子可以动之后应该怎么继续往前走，再修改 $mov_x$，一直这样往后跳箱子。
- 直到右边的那个箱子 $x$ 不会挡住当前的箱子 $i$，也就是现在 $i$ 可以直接移动到 $a_i$ 了，那么就给 $mov_x$ 增加这次移动需要的步数，并结束循环。


$a_i<b_i$ 的情况也差不多，就是一些操作要反过来。

最坏时间复杂度确实是 $O(n^2)$，当然碰到 B 性质就是 $O(n)$ 的了。

上面说着简单，但是实际上实现也有不少细节。对于 $a_i>b_i$，当 $i$ 要移到箱子 $x$ 前时，它真正到的位置应该是 $b_i-y$，其中 $y$ 是在 $i$ 和 $x$ 之间的箱子的个数。跳的时候用一个变量存储当前往前偏移了几格，最后一次移动时还要加回来。

这种暴力跳的方法不需要考虑当 $t$ 相同时按什么排序，因为实际上不按 $t$ 排序直接做也是一样的。

[赛时写的 $60$ 分代码（去除多余注释等）](/paste/szpc12l4)，可以参考代码理解前面的内容。

考虑优化。首先注意到许多跳的步骤都是重复计算的，（仍然只考虑 $a_i>b_i$）当一个箱子 $x$ 挡住了左边多个箱子时，左边多个箱子都要分别计算一遍对 $mov_x$ 的贡献。

实际上，可以延迟处理这些内容，或者说，对于每个箱子 $i$ 记录当时间到达 $t_i$ 时所有“排队等待”的箱子要去的位置（具体的箱子的编号都是不重要的，只需要知道 $a$ 的值即可）。当真正轮到这个箱子 $x$ 时，需要做到取出其中所有不会被下一个要“跳”的箱子挡住的位置，并直接计算答案加到 $mov_x$ 中，而剩下会被挡住的箱子则统一计算移动步数（它们这一段的移动步数显然是相同的），并合并到下一个箱子的信息中。

也就是，需要找到一个数据结构，可以取出其中最小的几个数，以及与另一个相同的数据结构合并。

不难想到[可并堆](/problem/P11266)。每个箱子都开一个 `pb_ds` 的 `priority_queue`，然后按上面所说的做即可。每个 $a_i$ 都只会被压入和取出一次，总共合并次数也是 $<n$ 的，所以总复杂度优化到了 $O(n\log n)$。细节太多，赛时想到这里但是没时间写了。

除了 $60$ 分代码需要考虑的以外，这里还需要考虑当 $t$ 相同时，按什么排序。为了保证不会出现类似箱子“插队等待”的问题，需要保证 $t$ 相同的所有 $a_i<b_i$ 的箱子按 $b_i$（$a_i$）从大到小排序，而所有 $a_i>b_i$ 的箱子按 $b_i$（$a_i$）从小到大排序，这样处理顺序才是正确的。如果 cmp 函数碰到的两个箱子一个 $a_i<b_i$，一个 $a_j>b_j$，也不能随便返回，因为这样可能导致最后排出来还是乱序（经测试会 WA 三个点）。一种方法是把所有 $a_i<b_i$ 的箱子排到 $a_j>b_j$ 的箱子前面。

```cpp
sort(a+1,a+1+n,[](box aa,box bb){
	if(aa.t!=bb.t)return aa.t>bb.t;
	if((aa.a<aa.b)!=(bb.a<bb.b))return aa.a<aa.b;
	if(aa.a<aa.b)return aa.a>bb.a;
	else return aa.a<bb.a;
});
```

处理完所有细节后，这道题就可以用可并堆 AC 了。即使我写的常数可能有点大，但是时间最大的测试点也只有 850ms。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
#define int long long
using namespace std;
const int N=2e5+5;
struct box{
	int a,b,t,id;
	int l1,r1;
}a[N];
int idt[N];
int mov[N];
__gnu_pbds::priority_queue<int,greater<int>>qmn[N];
__gnu_pbds::priority_queue<int,less<int>>qmx[N];
void mian(){
	int n;cin>>n;
	for(int i=0;i<=n+3;i++)mov[i]=idt[i]=a[i].a=a[i].b=a[i].t=a[i].id=a[i].l1=a[i].r1=0;
	for(int i=1;i<=n;i++)cin>>a[i].a>>a[i].b>>a[i].t,a[i].id=i;
	stack<int>st;
	for(int i=1;i<=n;i++){
		while(!st.empty()&&a[st.top()].t>a[i].t)st.pop();
		if(!st.empty())a[i].l1=st.top();
		st.emplace(i);
	}
	while(!st.empty())st.pop();
	for(int i=n;i>=1;i--){
		while(!st.empty()&&a[st.top()].t>a[i].t)st.pop();
		if(!st.empty())a[i].r1=st.top();
		st.emplace(i);
	}
	sort(a+1,a+1+n,[](box aa,box bb){
		if(aa.t!=bb.t)return aa.t>bb.t;
		if((aa.a<aa.b)!=(bb.a<bb.b))return aa.a<aa.b;
		if(aa.a<aa.b)return aa.a>bb.a;
		else return aa.a<bb.a;
	});
	for(int i=1;i<=n;i++)idt[a[i].id]=i;
	for(int i=1;i<=n;i++){
		qmx[i].clear();qmx[i].push(a[i].a);
		qmn[i].clear();qmn[i].push(a[i].a);
	}
	for(int i=1;i<=n;i++){
		if(a[i].a<a[i].b){
			int x=idt[a[i].l1];
			while(qmx[i].size()&&(!x||qmx[i].top()>=a[x].b+(int)(qmx[x].size()+qmx[i].size())-1)){
				mov[i]+=(a[i].b+qmx[i].size()-1)-qmx[i].top();
				qmx[i].pop();
			}
			if(x)mov[i]+=qmx[i].size()*(a[i].b-(a[x].b+qmx[x].size()));
			qmx[x].join(qmx[i]);
		}else{
			int x=idt[a[i].r1];
			while(qmn[i].size()&&(!x||qmn[i].top()<=a[x].b-(int)(qmn[x].size()+qmn[i].size())+1)){
				mov[i]+=qmn[i].top()-(a[i].b-qmn[i].size()+1);
				qmn[i].pop();
			}
			if(x)mov[i]+=qmn[i].size()*((a[x].b-qmn[x].size())-a[i].b);
			qmn[x].join(qmn[i]);
		}
	}
	for(int i=1;i<=n;i++){
		int x=mov[i];
		mov[i]=min(mov[i],a[i].t-a[i+1].t);
		x-=mov[i];
		mov[i+1]+=x;
	}
	if(mov[n+1]){
		cout<<"No\n";
	}else{
		cout<<"Yes\n";
	}
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int c,t;cin>>c>>t;
	while(t--){
		mian();
	}
	return 0;
}
```

另外据机房同学所说，这里好像也可以不用堆来存，只需要用另一个数组存下原本上面代码对应的堆的大小就行了。不过感觉这样代码会更复杂，所以我没写。

---

## 作者：xixisuper (赞：23)

# P11833 [省选联考 2025] 推箱子 题解

考完出来对答案，发现学校里就我一人用线段树做的这一题，记录一下。

upd 2025.3.5：修改了一点笔误，望管理员看到给通过一下。

upd 2025.3.8：发现原来式子锅了，改了，望通过。

## 思路

首先是基本的贪心思路：**把所有限制按照时间从小到大排序，然后一个一个推一定不劣**。证明是简单的，只需要考虑交换相邻顺序即可。

然后模拟这个过程，发现一定是把一段连续的箱子推到一段连续的位置上。如何计算所需的时间呢？我们不妨令 $pos_i$ 表示第 $i$ 个箱子**现在所在的位置**，假设我们现在要把第 $i$ 个箱子推到 $b_i$ 上，那么我们就有如下讨论：

- 如果 $pos_i=b_i$，那还推啥，无需花时间。
- 如果 $pos_i>b_i$，那么我们就需要把 $i$ 号箱子往左推，推到位置 $b_i$，中间碰到的箱子要一起推过去。所花的时间等于**初始时所有移动了的箱子的位置之和减去最终箱子停下来的位置之和。**
- 如果 $pos_i<b_i$，那么我们就需要把 $i$ 号箱子向右推，推到位置 $b_i$，中间碰到的箱子要一起推过去。所花的时间等于**最终箱子停下来的位置之和减去初始时所有移动了的箱子的位置之和。**

对于第二种情况来说，假设箱子 $j$ **不会**在箱子 $i$ 被推到位时被推动（且 $j<i$），则一定有：

$$
pos_j<b_i-(i-j-1)
$$

这里的 $b_i-(i-j-1)$ 其实是假定 $j+1$ 到 $i$ 号箱子都被推动了时，连续的那一段位置的左端点是多少。我们给上式移一下项，就能得到：

$$
pos_j-j<b_i-i+1
$$


对于第三种情况来说，假设箱子 $j$ **不会**在箱子 $i$ 被推到位时被推动（且 $i<j$），则一定有：

$$
pos_j>b_i+(j-i-1)
$$
$$
pos_j-j>b_i-i-1
$$

推得的方式与第二种情况类似。

不难发现，**$pos_j-j$ 的值一定单调不降，把该值上线段树上二分就能够知道有那些箱子是会被移动的**。我们额外维护出所有被移动了的箱子的位置之和就能够计算本次移动所消耗的时间。

现在问题出在如何在移动后更新 $pos_j-j$ 的值。由于所有被移动的箱子的 $pos$ 都会变相邻，而被移动的箱子的下标又一定相邻，**所以所有被移动的箱子的 $pos_j-j$ 的值一定相等**，线段树区间赋值成 $b_i-i$ 即可。

单次推一个箱子需要线段树二分加上区间赋值，则总时间复杂度为 $O(Tn\log n)$。

## 代码

这份代码通过了考场上所有的大样例（虽然这题的大样例有点水就是了）。

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
#define lc (x<<1)
#define rc ((x<<1)|1)
#define mid ((l+r)>>1)
using namespace std;
const ll N=2e5+10;
const ll V=1e9+10;
struct node{
	ll a,b,t,id;
}bl[N];
inline bool cmp(node x,node y){return x.t<y.t;}
ll n,sum[N<<2],tag[N<<2],minn[N<<2],maxx[N<<2];
void push_up(ll x){
	sum[x]=sum[lc]+sum[rc];
	minn[x]=min(minn[lc],minn[rc]);
	maxx[x]=max(maxx[lc],maxx[rc]);
}
void push_down(ll x,ll l,ll r){
	if(tag[x]==-114514) return;
	tag[lc]=tag[rc]=tag[x];
	minn[lc]=minn[rc]=tag[x];
	maxx[lc]=maxx[rc]=tag[x];
	sum[lc]=tag[x]*(mid-l+1);
	sum[rc]=tag[x]*(r-mid);
	tag[x]=-114514;
}
void build(ll x,ll l,ll r){
	tag[x]=-114514;
	if(l==r){
		if(!l) sum[x]=minn[x]=maxx[x]=-114;
		else if(l>n) sum[x]=minn[x]=maxx[x]=V;
		else sum[x]=minn[x]=maxx[x]=bl[l].a-l;
		return;
	}
	build(lc,l,mid);build(rc,mid+1,r);
	push_up(x);
}
void chg(ll x,ll l,ll r,ll L,ll R,ll v){
	if(L<=l&&r<=R){
		sum[x]=v*(r-l+1);
		tag[x]=maxx[x]=minn[x]=v;
		return;
	}
	push_down(x,l,r);
	if(L<=mid) chg(lc,l,mid,L,R,v);
	if(R>mid) chg(rc,mid+1,r,L,R,v);
	push_up(x);
}
ll getMD(ll x,ll l,ll r,ll rank){
	if(l==r) return l;
	push_down(x,l,r);
	if(rank<=minn[rc]) return getMD(lc,l,mid,rank);
	return getMD(rc,mid+1,r,rank);
}
ll getOT(ll x,ll l,ll r,ll rank){
	if(l==r) return l;
	push_down(x,l,r);
	if(rank<maxx[lc]) return getOT(lc,l,mid,rank);
	return getOT(rc,mid+1,r,rank);
}
ll query(ll x,ll l,ll r,ll L,ll R){
	if(L<=l&&r<=R) return sum[x];
	push_down(x,l,r);
	ll ret=0;
	if(L<=mid) ret+=query(lc,l,mid,L,R);
	if(R>mid) ret+=query(rc,mid+1,r,L,R);
	return ret;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	ll c,T;cin>>c>>T;
	while(T--){
		cin>>n;
		for(ll i=1;i<=n;i++){cin>>bl[i].a>>bl[i].b>>bl[i].t;bl[i].id=i;}
		build(1,0,n+1);
		sort(bl+1,bl+1+n,cmp);
		ll now=0;
		for(ll i=1;i<=n;i++){
			ll pos=query(1,0,n+1,bl[i].id,bl[i].id)+bl[i].id;
			if(pos==bl[i].b){
				if(now>bl[i].t) goto endthesol;
				continue;
			}
			ll L,R,calc;
			if(pos>bl[i].b){
				L=getMD(1,0,n+1,bl[i].b-bl[i].id+1);
				R=bl[i].id-L-1;
				calc=query(1,0,n+1,L+1,bl[i].id)+(L+1+bl[i].id)*(bl[i].id-L)/2;
				now+=calc-(2*bl[i].b-R)*(R+1)/2;
				if(now>bl[i].t) goto endthesol;
				chg(1,0,n+1,L+1,bl[i].id,bl[i].b-bl[i].id);
			}
			else{
				L=getOT(1,0,n+1,bl[i].b-bl[i].id-1);
				R=L-bl[i].id-1;
				calc=query(1,0,n+1,bl[i].id,L-1)+(bl[i].id+L-1)*(L-bl[i].id)/2;
				now+=(2*bl[i].b+R)*(R+1)/2-calc;
				if(now>bl[i].t) goto endthesol;
				chg(1,0,n+1,bl[i].id,L-1,bl[i].b-bl[i].id);
			}
		}
		cout<<"Yes\n";
		continue;
		endthesol:;
		cout<<"No\n";
	}
	return 0;
} 
```

---

## 作者：Starrykiller (赞：18)

赛时第一反应是什么都不会，然后瞎写了个暴力过了所有样例，得到了下述观察。

> **观察**
>
> 对于两个要求 $i,j$，若 $t_i\le t_j$，则应当先满足要求 $i$，再满足要求 $j$。
>
> **证明**
>
> 若 $i$ 操作不会影响到 $j$，则是简单的：设 $i$ 操作用时 $a$，$j$ 操作用时 $b$，显然 $a\le t_i\land a+b\le t_j$ 比 $a+b\le t_i\land b\le t_j$ 更易满足。
>
> 否则将 $j$ 移动到不会被 $i$ 影响的位置（容易证明这一定让它离目标点更近了），转化成上述情况。
> $\square$

基于上述观察，不难写出暴力：维护一个全局的时间戳 $cur$，每次要将 $i$ 移动到 $b_i$ 时，检查 $i+1$ 的位置是否 $\gt b_i$（或者 $i-1$ 的位置 $\lt b_i$），如果是的话就直接操作；否则先递归将 $i+1$ 移动到 $b_i+1$（$i-1$ 同理），再移动 $i$。这样是 $\mathcal{O}(n^2)$ 的。

观察到暴力之所以慢，是因为每次可能将连续的一长段做了平移。（我们称 $i$ 和 $i+1$ 是连续的，当且仅当它们位置绝对值相差为 $1$。）

于是使用 ODT 维护连续段即可。每次移动的时候至多分裂一次，然后暴力往后（前）找下一段是否被影响了。这样这些所有被暴力找到的段会被合并称一段，所以复杂度是 $\Theta(n\log n)$。

小圆抱抱/kel

---

## 作者：IvanZhang2009 (赞：16)

大力宣传除了排序外线性做法！不用线段树等~~高级~~ ds！

首先注意到特殊性质 $a_i<b_i$，推一下可以发现可以按 $[a_i<b_i]$ 把序列剖成若干连续段，每一段几乎是独立的，相当于这个特殊性质和题目等价。理由是若 $a_i<b_i<b_{i+1}<a_{i+1}$ 或 $b_i<a_{i}<a_{i+1}<b_{i+1}$ 的时候两边推的过程不会相交。

显然可以按 $t$ 排序。可以只考虑每个特殊 $T$ 时刻的时候所有箱子的**位置** $c_i$，如果有 $c_i$ 递增且 $\sum|a_i-c_i|\le T$，则显然存在一个推箱子的方案。所以我们直接考虑**每个特殊时刻需要移动所有箱子的总距离**。为了让上面的东西独立，我们对每个连续段设计若干个限制：二元组序列 $\{(t_i,d_i)\}$  表示 $t_i$ 时刻前这一段需要做 $d_i$ 个操作。

考虑 $T$ 时刻内所有需要归位的箱子为集合 $S$。不妨设本段 $a_i<b_i$。设 $x,y$ 是 $S$ 中两个相邻的元素，可以认为 $[x,y-1]$ 之间的箱子都**只受 $x$ 影响**。可以发现 $x$ 影响的箱子一定是这个区间的一段长度为 $l$ 的前缀，如果可以求出这段前缀，就可以推出这一段箱子在时间内最终位置是 $b_x,b_{x}+1,\dots,b_x+l-1$。此时贡献的计算关于所有相邻的 $(x,y)$ 对独立。直接把 $\sum_{i=0}^{l-1} b_x+i-a_{i+x}$ 加起来就可以得到此时的 $d_i$ 了。暴力做得到平方做法。

上面这个东西也可以理解为，我们从右往左依次移动，把 $y$ 移动好了之后，$x$ 要考虑的就只有 $<y$ 的了。

这个东西是很好优化到线性的。从小到大枚举 $t$，受影响的相邻对 $(x,y)$ 最多只会有两次变化：一次是加入一个新点，直接算一下这个点和它下一个点之间的贡献；再修改一下它和上一个点之间的贡献即可。

考虑如何快速求出上面说的一段前缀。箱子 $i$ 受 $x$ 的影响当且仅当 $b_x+(i-x)\ge a_i$，移项得到 $a_i-i\le b_x-x$。注意到 $a_i$ 严格递增，所以 ${a_i-i}$ 不降，在一开始直接预处理出最大的 $f_x=i$ 表示 $i$ 会受 $x$ 影响。算贡献的时候相当于 $[x,\min(y-1,f_x)]$ 的箱子会受影响，预处理 $a$ 的前缀和容易 $O(1)$ 计算贡献。

插入一个点之后求出上一个和下一个点也可以单调栈预处理，就做到了线性处理一个段（除了按 $t$ 排序）。

考虑合并若干个段的限制。我们不妨认为一个点可以做多次操作。设限制序列中相邻两项 $(t_{i-1},d_{i-1}),(t_i,d_i)$，说人话就是**认为**在 $t_i$ 时刻做 $d_i-d_{i-1}$ 次操作。所以直接把 $(t_i,d_i-d_{i-1})$ 放到一起排序，然后再整体考虑 $t_i$ 时间前是否做得完前 $\sum_{j\le i}d_j$ 次操作，即判断 $\forall i, \sum_{j\le i}d_j\le t_i$。

总时间复杂度除了排序外线性。非常好写。

考场代码：

```cpp
#include<bits/stdc++.h>
#define MOD 998244353
#define int long long
#define REP(i,a,n) for(int i=a;i<(int)(n);++i)
#define pii pair<int,int>
#define pb push_back
#define all(v) v.begin(),v.end()
using namespace std;
int read(){
    int res=0;char c=getchar();
    while(c<48||c>57)c=getchar();
    do res=(res<<1)+(res<<3)+(c^48),c=getchar();while(c>=48&&c<=57);
    return res;
}
int qpow(int a,int b,int m=MOD){
    int res=1;
    while(b)res=b&1? res*a%MOD:res,a=a*a%MOD,b>>=1;
    return res;
}
struct boxes{
    int a,b,t;
};
int ID;
vector<pii>solve(vector<boxes>a){
    int n=a.size();
    if(a[0].a>a[0].b){
        REP(i,0,n)a[i].a*=-1,a[i].b*=-1;
        reverse(all(a));
    }
    vector<pii>st;
    REP(i,0,n)st.pb({a[i].t,i});
    sort(all(st));
    vector<int>nxt(n);
    int x=0;
    REP(i,0,n){
        while(x+1<n&&a[x+1].a-(x+1)<a[i].b-i)++x;
        nxt[i]=x;
    }
    vector<int>s(n+1,0);
    REP(i,0,n)s[i+1]=s[i]+a[i].a;
    vector<int>f1(n,n),f2(n,-1);
    stack<int>S;
    REP(i,0,n){
        while(!S.empty()&&a[S.top()].t>a[i].t)S.pop();
        f1[i]=S.empty()? -1:S.top();
        S.push(i);
    }
    while(!S.empty())S.pop();
    for(int i=n-1;i>=0;--i){
        while(!S.empty()&&a[S.top()].t>=a[i].t)S.pop();
        f2[i]=S.empty()? n:S.top();
        S.push(i);
    }
    vector<pii>ret;
    int cur=0;
    REP(_,0,st.size()){
        int i=st[_].second,T=st[_].first;
        nxt[i]=min(nxt[i],f2[i]-1);
        cur+=(a[i].b*2+nxt[i]-i)*(nxt[i]-i+1)/2-s[nxt[i]+1]+s[i];
        if(f1[i]!=-1){
            int x=f1[i];
            if(nxt[x]>=i){
                cur-=(a[x].b*2+nxt[x]-x)*(nxt[x]-x+1)/2-s[nxt[x]+1]+s[x];
                nxt[x]=i-1;
                cur+=(a[x].b*2+nxt[x]-x)*(nxt[x]-x+1)/2-s[nxt[x]+1]+s[x];
            }
        }
        ret.pb({T,cur});
    }
    return ret;
}
int n;
int a[200005],b[200005],t[200005];
void Main(){
    n=read();
    REP(i,0,n)a[i]=read(),b[i]=read(),t[i]=read();
    vector<pii>R;
    vector<int>v;
    REP(i,0,n)if(a[i]!=b[i]){
        int x=i;
        while(x+1<n&&(a[x+1]<b[x+1])==(a[x]<b[x]))++x;
        vector<boxes>T;
        REP(j,i,x+1)T.pb({a[j],b[j],t[j]});
        vector<pii>s=solve(T);
        for(int j=s.size()-1;j;--j)s[j].second-=s[j-1].second;
        for(auto j:s)R.pb(j);
        i=x;
    }
    sort(all(R));
    REP(i,1,R.size())R[i].second+=R[i-1].second;
    REP(i,0,R.size())if(R[i].second>R[i].first){
        cout<<"No\n";
        return;
    }
    cout<<"Yes\n";
}
signed main(){
    freopen("move.in","r",stdin);
    freopen("move.out","w",stdout);
    int tc=1;
    ID=read();tc=read();
    while(tc--)Main();
    return 0;
}
```

---

## 作者：StayAlone (赞：10)

竟然和 ABC 的题重了。。。

先考虑贪心做这个问题。很容易想到，按照 $t$ 排序，依次满足要求。每个箱子直接从当前位置推向 $b_i$，并把过程中遇到的箱子“挤压”着移动。由于 $a,b$ 均递增，这样做并不会妨害到后续箱子的移动，并能最小化当前时间。

那么看起来只需要写一个：区间推平成等差数列，区间求和。由于挤压的存在，实现起来有一定细节。

考虑维护 $c_i=a_i-i$，显然 $c_i\leq c_{i+1}$。可以发现，这时操作就转成了区间推平，查询区间和。例如对箱子 $i$ 操作，从 $x$ 位置走向 $y$ 位置，只需把 $j\geq i\land c_j\in [x, y]$ 的值推平成 $y$ 即可（$x>y$ 同理）。步数显然仍是移动前后对应位置 $c_i$ 之差的绝对值。

若用线段树维护，维护区间和与覆盖标记，同时为了在线段树上二分找到推平区间，需要维护区间最值。时间复杂度 $\mathcal O(n\log n)$。

不过我们注意到，查询区间与覆盖区间总是相同，因此用 ODT 维护即可，时间复杂度也是 $\mathcal O(n\log n)$。

~~代码后续补。~~

这里有一份能通过官方数据的 ODT 实现：

```cpp
int testcase, n; ll ans;

struct node {
	int a, b, id; ll t;
	
	il bool operator < (const node &p) const {
		return t < p.t;
	}
	
	il void input(int i) {
		read(a, b, t);
		a -= i; b -= i; id = i;
	}
} a[MAXN];

struct ODT {
	struct node {
		int l, r;
		mutable int v;
		
		il bool operator < (const node &p) const {
			return l < p.l;
		}
	}; set <node> odt;
	
	il void init() {
		odt.clear(); 
		rep1(i, 1, n) odt.emplace(node{i, i, a[i].a});
	}
	
	il void change(int i) {
		int id = a[i].id;
		auto it = --odt.upper_bound(node{id, -1, -1});
		auto [l0, r0, v0] = *it;
		if (a[i].a < a[i].b) {
			if (l0 ^ id) {
				odt.erase(it); odt.emplace(node{l0, id - 1, v0});
				it = odt.emplace(node{id, r0, v0}).fst;
			} auto itr = it; ll sum = 0; int rpos = id - 1;
			while (itr != end(odt) && itr -> v < a[i].b) {
				auto [l, r, v] = *itr++;
				sum += ll(r - l + 1) * v; rpos = r;
			} odt.erase(it, itr); odt.emplace(node{id, rpos, a[i].b});
			ans += ll(rpos - id + 1) * a[i].b - sum;
		} else {
			if (r0 ^ id) {
				odt.erase(it); odt.emplace(node{id + 1, r0, v0});
				it = odt.emplace(node{l0, id, v0}).fst;
			} auto itl = it; ll sum = 0; int lpos = id + 1;
			while (itl -> v > a[i].b) {
				auto [l, r, v] = *itl;
				sum += ll(r - l + 1) * v; lpos = l;
				if (itl == begin(odt)) break;
				--itl;
			} odt.erase(--odt.upper_bound(node{lpos, -1, -1}), next(it));
			odt.emplace(node{lpos, id, a[i].b});
			ans += sum - ll(id - lpos + 1) * a[i].b;
		}
	}
} T;

il void solve() {
	read(n); ans = 0;
	rep1(i, 1, n) a[i].input(i);
	T.init(); sort(a + 1, a + 1 + n);
	rep1(i, 1, n) if ((T.change(i), ans) > a[i].t) return puts("No"), void();
	puts("Yes");
}

int main() {
	read(testcase);
	for (int T = read(); T--; ) solve();
	return 0;
}
```

下面是我的赛时代码，线段树写法。

```cpp
int testcase, n;

struct node {
	int a, b, id; ll t;
	
	il bool operator < (const node &p) const {
		return t < p.t;
	}
	
	il void input(int i) {
		read(a, b, t); id = i;
		a -= i, b -= i;
	}
} a[MAXN];

struct setr {
	#define STZ MAXN << 2
	#define ls(x) x << 1
	#define rs(x) x << 1 | 1
	ll sum[STZ]; int maa[STZ], mii[STZ], tg[STZ];
	
	il void pushup(int x) {
		sum[x] = sum[ls(x)] + sum[rs(x)];
		maa[x] = max(maa[ls(x)], maa[rs(x)]);
		mii[x] = min(mii[ls(x)], mii[rs(x)]);
	}
	
	il void change(int x, int k, ll len) {
		tg[x] = maa[x] = mii[x] = k;
		sum[x] = k * len;
	}
	
	il void pushdown(int x, int l, int r) {
		if (!~tg[x]) return;
		int mid = l + r >> 1;
		change(ls(x), tg[x], mid - l + 1);
		change(rs(x), tg[x], r - mid);
		tg[x] = -1;
	}
	
	il void upd(int x, int l, int r, int ql, int qr, int k) {
		if (l > qr || r < ql) return;
		if (l >= ql && r <= qr) return change(x, k, r - l + 1);
		int mid = l + r >> 1; pushdown(x, l, r);
		upd(ls(x), l, mid, ql, qr, k); upd(rs(x), mid + 1, r, ql, qr, k);
		pushup(x);
	}
	
	il ll query(int x, int l, int r, int ql, int qr) {
		if (l > qr || r < ql) return 0;
		if (l >= ql && r <= qr) return sum[x];
		int mid = l + r >> 1; pushdown(x, l, r);
		return query(ls(x), l, mid, ql, qr) + query(rs(x), mid + 1, r, ql, qr);
	}
	
	il void build(int x, int l, int r) {
		tg[x] = -1;
		if (l == r) return sum[x] = maa[x] = mii[x] = a[l].a, void();
		int mid = l + r >> 1;
		build(ls(x), l, mid); build(rs(x), mid + 1, r);
		pushup(x);
	}
	
	il int query1(int x, int l, int r, int k) {
		if (l == r) return l;
		int mid = l + r >> 1; pushdown(x, l, r);
		if (mii[rs(x)] <= k) return query1(rs(x), mid + 1, r, k);
		return query1(ls(x), l, mid, k);
	}
	
	il int query2(int x, int l, int r, int k) {
		if (l == r) return l;
		int mid = l + r >> 1; pushdown(x, l, r);
		if (maa[ls(x)] >= k) return query2(ls(x), l, mid, k);
		return query2(rs(x), mid + 1, r, k);
	}
} T;

il void solve() {
	read(n);
	rep1(i, 1, n) a[i].input(i);
	T.build(1, 1, n);
	sort(a + 1, a + 1 + n);
	bll now = 0;
	rep1(i, 1, n) {
		int id = a[i].id;
		if (a[i].a < a[i].b) {
			int pos = T.query1(1, 1, n, a[i].b);
			if ((now += a[i].b * ll(pos - id + 1) - T.query(1, 1, n, id, pos)) > a[i].t) return puts("No"), void();
			T.upd(1, 1, n, id, pos, a[i].b);
		} else {
			int pos = T.query2(1, 1, n, a[i].b);
			if ((now += T.query(1, 1, n, pos, id) - a[i].b * ll(id - pos + 1)) > a[i].t) return puts("No"), void();
			T.upd(1, 1, n, pos, id, a[i].b);
		}
	} puts("Yes");
}

int main() {
	read(testcase);
	for (int Q = read(); Q--; ) solve();
	return 0;
}
/*
维护 a_i - i
abc 原题 
*/
```

---

## 作者：what_can_I_do (赞：10)

[传送门](https://www.luogu.com.cn/problem/P11833)

首先有一个显然的贪心是按照 $t$ 排序，然后对于每个 $i$ 从 $a_i$ 移动到 $b_i$ 的途中如果有挡道的箱子就一起往前移，就能拿到很多分了。

观察移动后的序列，可以发现从原序列变成新序列只需要进行一个区间覆盖等差数列即可，直接使用线段树维护，二分查找受影响的最远的点，于是就有了两只老哥的做法。不过我写的线段树维护很复杂，先区间推平然后打等差数列起始位置的懒标记。

考虑优化成一只老哥，发现只需要将二分移到线段树即可，多维护区间左端点的值和右端点的值即可。

具体看代码实现，但是暂时还没有拿到代码。等拿到了就把代码贴上来，希望我考场上写的是对的。

---

## 作者：xyvsvg (赞：8)

考虑性质 $A$，我们容易发现将所有箱子推到目标位置的最优总时间一定是 $\sum \lvert a_i-b_i\rvert$，只需比较它与 $t$ 的关系即可。

对于性质 $B$，我们考虑什么样的操作顺序是最优的？显然 $t$ 越小的越要优先被满足（可以用邻项交换证明，将 $t$ 更小的放在前面一定不劣）。性质 $B$ 本质上保证了箱子之间互不影响，因此直接计算即可。

性质 $C$ 相当于是性质 $B$ 的拓展，它不保证箱子之间互不影响。不妨设 $x_i$ 表示第 $i$ 个箱子当前的位置。则对于第 $i$ 个箱子，如果第 $i+1$ 个箱子挡住了第 $i$ 个箱子的去路，即 $x_i\leq x_{i+1}\leq b_i$，则我们需要令 $x_{i+1}\gets b_i+1$。不过有可能第 $i+2$ 个箱子又挡住了第 $i+1$ 个箱子的去路，第 $i+3$ 个箱子又挡住了第 $i+2$ 个箱子的去路……所以暴力实现最坏是 $O(n^2)$ 的。

我们考虑这个过程发生了什么，我们令 $x_{i+1}\gets b_i+1$，$x_{i+2}=b_i+2$，$x_{i+3}\gets b_i+3$……即 $x_{i+k}\gets b_i+k$，移项，变形得 $x_{i+k}-(i+k)=b_i-i$，不妨令 $f_i=x_i-i$，则 我们在 $f_i$ 上进行了一次区间覆盖，且代价为 $\sum\limits_{p\geq i\land f_p\leq b_i-i}(b_i-i)-f_i$，设需要操作的数共 $m$ 个，则代价为 $(b_i-i)m-\sum\limits_{p\geq i\land f_p\leq b_i-i}f_i$。因此，我们需要一个数据结构，支持区间求和与区间覆盖。由于每次区间查询后一定紧跟区间覆盖，因此可以使用珂朵莉树来维护（实测比线段树快，难道是我写的线段树太慢了？），不过主要优点在于好写。

接下来，我们考虑可以解决所有数据范围的解法，不难发现它与性质 $C$ 的区别在于 $i$ 左边的数也可能影响 $i$，不过我们对性质 $C$ 的实现并没有要求只能在 $i$ 的右边操作，因此只需要在实现时分讨，检查需要查询左区间还是右区间即可。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve()
{
    int n;
    cin>>n;
    vector<int>a(n+10),b(n+10),p(n);
    vector<ll>t(n+10);
    map<int,int>odt;
    for(int i=1;i<=n;++i)
    {
        cin>>a[i]>>b[i]>>t[i];
        odt[i]=a[i]-i;
    }
    odt[n+1]=INT_MAX;
    odt[0]=INT_MIN;
    iota(p.begin(),p.end(),1);
    sort(p.begin(),p.end(),[&](int i,int j)
         {
             return t[i]<t[j];
         }); // 钦定最优顺序
    auto odiv=[&](int k) //分裂一个颜色段
    {
        auto it=prev(odt.upper_bound(k));
        odt.insert(it,{k,it->second});
    };
    auto assignR=[&](int i,int k) //查询并覆盖右边
    {
        odiv(i);
        auto it=odt.lower_bound(i);
        ll ret=0;
        for(;it->second<k;it=odt.erase(it))
            ret+=(next(it)->first-it->first)*1LL*it->second;
        odt[i]=k;
        return 1LL*(it->first-i)*k-ret;
    };
    auto assignL=[&](int i,int k) //查询并覆盖左边
    {
        odiv(i+1);
        auto it=prev(odt.lower_bound(i+1));
        ll ret=0;
        for(;it->second>k;--it);
        int tmp=(++it)->first;
        for(;it->first<=i;it=odt.erase(it))
            ret+=(next(it)->first-it->first)*1LL*it->second;
        odt[tmp]=k;
        return ret-1LL*(i+1-tmp)*k;
    };
    ll T=0;
    for(int i:p)
    {
        if(a[i]>b[i])
            T+=assignL(i,b[i]-i);
        if(a[i]<b[i])
            T+=assignR(i,b[i]-i);
        if(t[i]<T)
        {
            cout<<"No\n";
            return;
        }
    }
    cout<<"Yes\n";
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int c,t;
    cin>>c>>t;
    while(t--)
        solve();
    return 0;
}

```

---

## 作者：Yang_YL (赞：8)

### 扯淡：

这居然是一道蓝题？（大雾）

关于我赛中没有做出来这件事……

### 方法：

#### 特殊性质 A：

按照顺序处理（$b_i>a_i$ 从右向左处理，$b_i<a_i$ 从左向右处理）即可。

复杂度 $O(n)$。
#### 特殊性质 B：

按照 $t$ 数组从小到大处理即可。

复杂度 $O(n\log_2 n)$。

#### 44pts：

还是按照 $t$ 排序，每次暴力跳到 $b_i$，中间的点在后面排排站就可以了。

复杂度 $O(n^2)$。
#### 特殊性质 C：

和正解差不多（确信）。

考虑优化，每次运箱子的代价就是：

$$
\sum_{i\le j\le n,a_j<b_i+(j-i)}[b_i+(j-i)]-a_j
$$

稍微复杂，简化后变为找到临界值 $j$，计算：

$$
(b_i\times (j-i+1))+((j-i+1)\times(j-i+2)\div 2)-(\sum_{k=i}^j a_k)
$$
后者用线段树维护即可。

复杂度 $O(n\log_2 n)$。

#### 正解：

其实只需要分类讨论 $b_i<a_i$ 的情况就可以了。

复杂度 $O(n\log_2 n)$。

#### 更新：
2025.3.7：解决了一些手误问题

---

## 作者：cosf (赞：7)

考场上别人怎么都写的线段树，就我写的 odt。

我们发现，假设当前每个人的位置在 $p_i$，那么必然有 $p_i \lt p_{i + 1}$。这个关系是严格的，不太好处理，所以让所有 $a_i, b_i$ 减去 $i$，这个关系就变成不严格的 $p_i \le p_{i + 1}$。

本题的结论就是按照 $t_i$ 从小到大排序，然后分别将 $i$ 推向 $b_i$，同时将 $p_i$ 到 $b_i$ 中的所有人都推向 $b _i$。具体证明其他题解应该都写了，~~就不写了~~。

可以发现，假设 $p_i < b_i$，则我们需要的是将所有 $p_j \in [p_i, b_i)$ 的 $j$ 移动到 $b_i$，移动的步数是 $\sum_j b_i - p_j$。计算结束后，还会把所有这样的 $p_j$ 赋值为 $b_i$。

因此可以考虑 odt。令线段 $(l, r, v)$ 表示当前 $p_l, \dots, p_r = v$，则我们只需把所有 $v \in [p_i, b_i)$ 的线段的 $(r - l + 1)(b_i - v)$ 加起来即可。

由于初始时有 $O(n)$ 个线段，每次操作只会加入一个线段，因此总共的线段数是 $O(n)$ 级别的。又由于每个线段在访问一次后就会被删除，因此最终的复杂度就是 $O(n\log n)$ 的了。

但是此做法常数有点大，不知道会不会挂分。

---

## 作者：ZHR100102 (赞：6)

比前两年省选 D2T1 简单多了，场上 20min 内出思路，但代码打了比较久。

# 思路

首先这题有个很显然的贪心，我们把箱子以时间为关键字进行排序，那么结束时间早的箱子就一定先被移动。

继续考虑箱子移动后能有什么影响，不难发现，一个箱子向右移动之后，在移动路线上的箱子必须都往右移动。具体地，第 $i$ 个路径上的箱子最后的位置是 $p+i$，其中 $p$ 为这个箱子移动到的位置。向左也是同理，最后位置是 $p-i$。

同时，因为 $a,b$ 单调递增，所以一定不会有箱子要跨越别的箱子，同时也不会出现把一堆箱子向右移动之后最后把箱子推回来的情况。

所以我们可以尝试写出一个 $O(n^2)$ 的暴力，每次移动一个箱子到终点的时候，递归移动左边或右边的第一个箱子，直到不需要移动，可以通过第二个和第三个大样例，可见大样例有多水。

考虑进一步优化这个做法，我们可以利用线段树来处理一整段箱子的移动。注意到箱子间的相对位置并不会改变，所以维护一个序列，存每个箱子的位置，移动一段箱子的时候，二分找到最后一个要移动的箱子的编号，然后进行区间覆盖操作即可。

具体地，我们二分右边最后一个 $pos<p+i-x $ 的箱子（$p$ 表示最后移动到的位置，$x$ 表示当前移动到目标位置的箱子，$i$ 表示二分的箱子，$pos$ 表示二分的这个箱子的位置），然后区间覆盖，维护两个值：$p,x$，则有标记的时候某个位置 $i$ 就被覆盖成了 $p+i-x$。其实就相当于增加一个等差数列。

向左边移动也是同理，不再赘述。

时间复杂度 $O(n \log^2 n)$，考场上忘记线段树上二分咋写了，就没优化到单 log，实际这个应该可以用线段树上二分优化到 $O(n\log n)$ 的。但是双 log 的做法我考场机子上卡满了也只跑了 4s 啊，正式评测估计卡不掉吧。

# 代码

等公布代码了再贴上去。

---

## 作者：xxr___ (赞：6)

### 前言：
大佬们怎么都写线段树，蒟蒻发一篇分块的题解。
### 思路：
首先我们将所有的箱子按照 $t_i$ 排序，从小到大分别去移动，可以证明这样是不劣的。
- 就是说假如我们先选了时间大的移动，然后选时间小的移动，如果可行，那么先移动小的再移动大的也一定可行。

然后我们看看一次移动会影响到那些其他的箱子的移动，显然加入这个箱子 $i$ 向左移动，那么他会把在 $[b_i,a_i]$ 的所有箱子都向左移动，但是这样也可能会把 $a_x<b_i$ 的箱子向左移动，但是最后他们肯定是排在一起的，且 $A_i$ 的值是公差是一的等差数列，所以我们就可以打出暴力：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define pre(i,l,r) for(int i=(l);i>=(r);--i)
const int N=2e5+5;
int L[N],R[N],bel[N],sum[N],add[N],len[N];
int A[N],B[N],C[N],n;
struct node{
	int a,b,c,id;
}p[N];
int calc(int l,int r){
	return ((l+r)*(r-l+1))/2;
}

void solve(){
	cin>>n;
	rep(i,1,n){
		cin>>p[i].a>>p[i].b>>p[i].c;p[i].id=i;
		A[i]=p[i].a;B[i]=p[i].b;C[i]=p[i].c;
	}
	sort(p+1,p+n+1,[&](const node&x,const node&y){
		return x.c<y.c;
	});
	int now=0;
	bool f=1;
	rep(i,1,n){
		int j=p[i].id;
		if(A[j]==B[j]){
			if(now>C[j]){
				f=0;
				break;
			}
			continue;
		} 
		if(A[j]>B[j]){
			int k=0;
			pre(q,j,1){
				if(A[q]<=p[i].b-(j-q)){
					break;
				}
				k=q;
			}
			rep(q,k,j) now+=A[q];
			now-=calc(p[i].b-(j-k),p[i].b);
			rep(q,k,j) A[q]=p[i].b-(j-q);
			if(now>p[i].c){
				f=0;break;
			}
		}
		if(A[j]<B[j]){
			int k=0;
			rep(q,j,n){
				if(A[q]>=p[i].b+(q-j)) break;
				k=q;
			}
			rep(q,j,k) now-=A[q];
			now+=calc(p[i].b,p[i].b+(k-j));
			rep(q,j,k) A[q]=p[i].b+(q-j);
			if(now>p[i].c){
				f=0;
				break; 
			}
		}
	}
	if(f){
		cout<<"Yes\n";
	}else{
		cout<<"No\n";
	}
}
int32_t main(){
	freopen("move.in","r",stdin);
	freopen("move.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int c,t;
	cin>>c>>t;
	while(t--) ::solve();
	return 0;
}
//tomxi
```
然后这份代码最坏是 $O(n^2)$ 的，我们发现等差数列可以使用分块进行优化，具体来说，就是定义一个 `lz` 数组，然后记录第 $x$ 个块是否有等差数列的标记，如果有，那么这个块首元素就是这个标记的值，这样就能推出一段区间的和。这样做显然时间复杂度是 $O(T\times n\sqrt n)$ 的。

赛时代码大概长这样：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define pre(i,l,r) for(int i=(l);i>=(r);--i)
const int N=2e5+5;
int L[N],R[N],bel[N],sum[N],add[N],len[N];
int A[N],B[N],C[N],n;
struct node{
	int a,b,c,id;
}p[N];
int calc(int l,int r){
	return ((l+r)*(r-l+1))/2;
}
int get_sum(int l,int r){
	if(l>r) swap(l,r);
	int ans=0,lk=bel[l],rk=bel[r];
	if(lk^rk){
		if(add[lk]){
			ans+=calc(add[lk]+l-L[lk],add[lk]+R[lk]-L[lk]);
		}
		if(!add[lk]){
			rep(i,l,R[lk]) ans+=A[i];
		}
		if(add[rk]){
			ans+=calc(add[rk],add[rk]+r-L[rk]);
		}
		if(!add[rk]){
			rep(i,L[rk],r) ans+=A[i];
		}
		rep(i,lk+1,rk-1){
			if(add[i]){
				ans+=calc(add[i],add[i]+len[i]-1);
			}else{
				ans+=sum[i];
			}
		}
		return ans;
	}else{
		if(add[lk]){
			return calc(add[lk]+l-L[lk],add[lk]+r-L[lk]);
		}else{
			rep(i,l,r) ans+=A[i];
			return ans;
		}
	}
}
void upd(int l,int r,int k){
	if(l>r) swap(l,r);
	int lk=bel[l],now=k,rk=bel[r];
	if(lk^rk){
		sum[lk]=sum[rk]=0;
		if(add[lk]) rep(i,L[lk],R[lk]) A[i]=add[lk]+i-L[lk];
		if(add[rk]) rep(i,L[rk],R[rk]) A[i]=add[rk]+i-L[rk];
		add[lk]=add[rk]=0;
		rep(i,l,R[lk]){
			A[i]=now;++now;
		}
		rep(i,L[lk],R[lk]) sum[lk]+=A[i];
		rep(i,lk+1,rk-1){
			add[i]=now;
			sum[i]=calc(now,now+len[i]-1);
			now+=len[i]; 
		}
		rep(i,L[rk],r){
			A[i]=now;++now;
		}
		sum[rk]=0;
		rep(i,L[rk],R[rk]) sum[rk]+=A[i];
		return;
	}else{
		sum[lk]=0;
		if(add[lk])
			rep(i,L[lk],R[lk]) A[i]=add[lk]+i-L[lk];
		rep(i,l,r) A[i]=now,++now;
		add[lk]=0;
		rep(i,L[lk],R[lk]) sum[lk]+=A[i];
		return; 
	}
}
int K=0;
void init(){
	K=sqrt(n);
	rep(i,1,n) sum[i]=add[i]=0;
	rep(i,1,n) bel[i]=(i-1)/K+1;
	rep(i,1,n) R[bel[i]]=i;
	pre(i,n,1) L[bel[i]]=i;
	rep(i,1,n) sum[bel[i]]+=A[i],len[bel[i]]=R[bel[i]]-L[bel[i]]+1;
}
void solve(){
	cin>>n;
	rep(i,1,n){
		cin>>p[i].a>>p[i].b>>p[i].c;p[i].id=i;
		A[i]=p[i].a;B[i]=p[i].b;C[i]=p[i].c;
	}
	init();
	sort(p+1,p+n+1,[&](const node&xx,const node&yy){
		return xx.c<yy.c;
	});
	int now=0;
	bool f=1;
	rep(i,1,n){
		int j=p[i].id;
		int vl=get_sum(j,j);
//		cout<<vl<<endl;
		if(vl==B[j]){
			if(now>p[i].c){
				f=0;
				break;
			}
			continue;
		} 
		if(vl>B[j]){
			int l=1,r=j,pos=0,ans=j;
			while(l<=r){
				int mid=(l+r)>>1;
				int val=get_sum(mid,mid);
				if(val>p[i].b-(j-mid)){
					r=mid-1;ans=mid;pos=j-mid;
				}else{
					l=mid+1;
				}
			}
			now=now+get_sum(ans,j)-calc(p[i].b-pos,p[i].b);
			upd(ans,j,p[i].b-pos);
			if(now>p[i].c){
				f=0;
				break;
			}
		}
		if(vl<B[j]){
			int l=j,r=n,ans=j,pos=0;
			while(l<=r){
				int mid=(l+r)>>1;
				int val=get_sum(mid,mid);
				if(val<p[i].b+(mid-j)){
					l=mid+1;ans=mid;pos=mid-j;
				}else{
					r=mid-1;
				}
			}
			now=now+calc(p[i].b,p[i].b+pos)-get_sum(j,ans); 
			upd(j,ans,p[i].b);
			if(now>p[i].c){
				f=0;
				break; 
			}
		}
	}
	if(f){
		cout<<"Yes\n";
	}else{
		cout<<"No\n";
	}
}
int32_t main(){
	// freopen("move.in","r",stdin);
	// freopen("move.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int cc,tt;
	cin>>cc>>tt;
	while(tt--) ::solve();
	return 0;
}
//tomxi
```

---

## 作者：MrPython (赞：5)

我们先考虑 $O(n^2)$ 做法。按照 $t$ 从小到大排序后，依次满足每个箱子的目标需求。若箱子移动的路线被其他箱子阻挡，此箱子会推着阻挡物前进。在此期间，任何一个箱子无法在规定时间内达到目标，将输出 `No`，否则为 `Yes`。

按照上述过程进行模拟，处理每个箱子时，若发现其前面 / 后面的箱子阻挡了其行进路线，将其直接移动到目标的前 / 后一格与上述描述也是等价的。若阻挡物也被阻挡了，进行同样过程的处理即可。

正解便是在此基础上进行的优化。我们发现，箱子推到一起后，会和其他箱子粘在一起运动许久。具体地，当一个箱子与后面的箱子粘连后，仅在后方箱子前往目标或自己前往目标时可能分离，且不会再次粘连，因此每两个箱子之间粘连 / 分开的次数是 $O(1)$ 的。

[珂朵莉树](https://oi-wiki.org/misc/odt/) 可以维护此过程 ~~我怎么以前不知道这个东西是有名字的~~。我们维护一个 `map`，键存放 **段首元素的下标**，值维护 **段的长度** 和 **段首元素的位置**（$a$ 的值）。由箱子相连可知，除段首元素，段内每个箱子的位置 $a_i$ 都是前一个的位置 $a_{i-1}+1$，因此可以维护 $a$ 数组。每次处理一个箱子时，先将该箱子单独分裂出来，然后维护出每个块前一个 / 后一个空着的位置 $e$，共其他段计算需要移动的距离。接着，处理路径中遇到的段，将其删除并记录，稍后进行合并操作，同时还要维护出新的 $e$。等清理完所有障碍，移动到最终位置后，便可将合并出的新块添加回 `map` 中了。

按照上述分析，因此每两个箱子之间粘连 / 分开的次数是 $O(1)$ 的，算上 `map` 单次操作的复杂度为 $O(\log n)$，最后的总复杂度为 $O(n \log n)$，且相比线段树做法，实现相当简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using uli=unsigned long long int;
istream& fin=cin;
ostream& fout=cout;
int main(void){
  ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
  ui c;size_t T;fin>>c>>T;
  while (T--){
    size_t n;fin>>n;
    map<ui,pair<ui,ui>> a;
    vector<ui> b(n);
    vector<pair<uli,size_t>> t(n);
    for (size_t i=0;i<n;++i){
      ui x;
      fin>>x>>b[i]>>t[i].first,t[i].second=i;
      a.insert({i,{1,x}});
    }
    auto blkFst=[](decltype(a)::iterator x)->auto&{return x->first;};
    auto blkPos=[](decltype(a)::iterator x)->auto&{return x->second.second;};
    auto blkLen=[](decltype(a)::iterator x)->auto&{return x->second.first;};
    sort(t.begin(),t.end());
    uli d=0;
    for (auto const& v:t){
      size_t p=v.second;
      auto it=prev(a.upper_bound(p));
      if (blkFst(it)<p){
        a.insert({p,{blkFst(it)+blkLen(it)-p,blkPos(it)+(p-blkFst(it))}});
        it->second.first=p-blkFst(it);
        ++it;
      }
      if (blkLen(it)>1){
        a.insert({p+1,{blkLen(it)-1,blkPos(it)+1}});
        blkLen(it)=1;
      }
      if (blkPos(it)<b[p]){
        ui e=b[p];
        do{
          d+=uli(e-blkPos(it))*blkLen(it);
          e+=blkLen(it);
          it=a.erase(it);
        }while (it!=a.end()&&blkPos(it)<e);
        a.insert({p,{e-b[p],b[p]}});
      }else if (blkPos(it)>b[p]){
        ui e=b[p]+1;
        do{
          d+=uli(blkPos(it)+blkLen(it)-e)*blkLen(it);
          e-=blkLen(it);
          it=a.erase(it);
          --it;
        }while (it!=a.end()&&blkPos(it)+blkLen(it)>e);
        a.insert({p+1-(b[p]+1-e),{b[p]+1-e,e}});
      }
      if (d>v.first){fout<<"No\n";goto end1;}
    }
    fout<<"Yes\n";
    end1:;
  }
}
```

---

## 作者：船酱魔王 (赞：5)

## 题意回顾

数轴上有一些格子，其中有 $ n $ 个棋子放在给定的格子上，要求将每个棋子都移动到对应给出的格子上，每个棋子都有一个时间限制。移动棋子时不能让棋子重合。判断满足要求的可行性。

保证棋子的初始位置和目标位置均单增给出，棋子最多有 $ 2 \times 10^5 $ 个。

## 分析

* 如果棋子之间不会互相阻挡，考虑贪心策略：对于截止时间靠前的棋子优先满足。证明：首先不同棋子的移动不会互相影响，所以这个棋子必须在时间限制内被移动一定的次数。而对于其他棋子的移动，截止时间都更靠后，所以这个棋子移动的所有操作一定只能在任何其他棋子的截止时间之前，又因为不同棋子的操作之间互相独立，所以安排在靠前一定不劣。
* 考虑棋子之间阻挡的情况，如果截止时间靠前的棋子无法被满足，则肯定不可能存在合理的移动方案。而考虑为了让当前棋子移动到目标位置而移动的其他棋子，具有性质是这些因为“避让”进行的移动操作必然和为了到达目标位置的操作是顺路的。证明：考虑当前棋子和因避让而移动的棋子，若当前棋子向右移动，则因避让而移动的棋子在移动前就在这个棋子右面，因为棋子不可互相跨越，所以相对位置左右关系一定不变，因此因避让而移动的棋子的目标位置一定比当前操作的棋子的目标位置更靠右，向左移动同理。
* 同理，因为棋子之间相对位置左右关系不变的道理和题目给出的性质，可以得出一个棋子到达终点后必然不会被因为避让再行移动。
* 因此我们得到贪心策略：
  * 找到截止时间最早且未被完成的棋子 $ u $。
  * 若 $ u $ 已经到达目标位置，则视为被完成。
  * 将 $ u $ 的当前位置和目标位置之间的棋子避让到目标位置之后，且避让距离最短（即这些因避让而移动的棋子顺次排列在当前操作棋子的目标位置后面连续的一些格子）。
  * 将 $ u $ 移动到目标位置。
  * 根据此策略不难设计一个 $ O(n^2) $ 的实现。
* 考虑将棋子之间互不重合的条件弱化为棋子之间互不跨越，将每个棋子坐标减去编号即可（小于号化小于等于号标准操作），此时避让即为统一移动到当前操作目标位置，避让距离不难转化式子为区间求和问题，寻找避让范围由棋子互不跨越即位置单调不降的性质转化为找出数列中某个数的前驱/后继，此时可以由一棵支持线段树上二分、区间求和、区间覆盖的懒标记线段树以 $ O(n \log n) $ 的复杂度实现。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <utility>
#define ll long long
using namespace std;
int c, T;
namespace BoatDevil {
    const int N = 2e5 + 5;
    int n;
    int a[N], b[N];
    ll tm[N];
    pair<ll, int> pr[N];
    struct node {
        ll sum;//all sum
        int rt;//right value
        node(ll sum_range = 0, int rt_range = 0) {
            sum = sum_range, rt = rt_range;
        }
    } d[N * 4];
    int c[N * 4];//cover (0=no cover)
    node operator+(node p1, node p2) {
        p2.sum += p1.sum;
        return p2;
    }
    inline void pushdown(int s, int t, int p) {
        int mid = (s + t) >> 1;
        if(!c[p]) return;
        if(c[p]) c[p * 2] = c[p * 2 + 1] = c[p];
        d[p * 2] = node((ll)(mid - s + 1) * c[p], c[p]);
        d[p * 2 + 1] = node((ll)(t - mid) * c[p], c[p]);
        c[p] = 0;
    }
    void build(int s, int t, int p) {
        c[p] = 0;
        if(s == t) {
            d[p] = node(a[s], a[s]);
            return;
        }
        int mid = (s + t) >> 1;
        build(s, mid, p * 2);
        build(mid + 1, t, p * 2 + 1);
        d[p] = d[p * 2] + d[p * 2 + 1];
    }
    int Find(int v, int s, int t, int p) {
        if(s == t) return s;
        int mid = (s + t) >> 1;
        pushdown(s, t, p);
        if(d[p * 2].rt >= v) return Find(v, s, mid, p * 2);
        return Find(v, mid + 1, t, p * 2 + 1);
    }
    ll getsum(int l, int r, int s, int t, int p) {
        if(l <= s && t <= r) return d[p].sum;
        int mid = (s + t) >> 1;
        pushdown(s, t, p);
        ll jsx = 0;
        if(l <= mid) jsx += getsum(l, r, s, mid, p * 2);
        if(mid < r) jsx += getsum(l, r, mid + 1, t, p * 2 + 1);
        return jsx;
    }
    void cover(int l, int r, int v, int s, int t, int p) {
        if(l <= s && t <= r) {
            d[p] = node((ll)v * (t - s + 1), v);
            c[p] = v;
            return;
        }
        int mid = (s + t) >> 1;
        pushdown(s, t, p);
        if(l <= mid) cover(l, r, v, s, mid, p * 2);
        if(mid < r) cover(l, r, v, mid + 1, t, p * 2 + 1);
        d[p] = d[p * 2] + d[p * 2 + 1];
    }
    bool lwhzkj() {
        scanf("%d", &n);
        for(int i = 1; i <= n; i++) scanf("%d%d%lld", &a[i], &b[i], &tm[i]), pr[i] = (pair<ll, int>){tm[i], i};
        sort(pr + 1, pr + n + 1);
        for(int i = 1; i <= n; i++) a[i] -= i - 1, b[i] -= i - 1;
        build(1, n, 1);
        ll tim = 0;
        for(int i = 1; i <= n; i++) {
            int u = pr[i].second;
            if(getsum(u, u, 1, n, 1) < b[u]) {
                int r = (b[u] > d[1].rt) ? n : (Find(b[u], 1, n, 1) - 1);
                tim += (ll)b[u] * (r - u + 1) - getsum(u, r, 1, n, 1);
                cover(u, r, b[u], 1, n, 1);
            } else if(getsum(u, u, 1, n, 1) > b[u]) {
                int l = Find(b[u] + 1, 1, n, 1);
                tim += getsum(l, u, 1, n, 1) - (ll)b[u] * (u - l + 1);
                cover(l, u, b[u], 1, n, 1);
            }
            if(tim > tm[u]) {
                return false;
            }
        }
        return true;
    }
};
int main() {
    //freopen("move.in", "r", stdin);
    //freopen("move.out", "w", stdout);
    scanf("%d%d", &c, &T);
    for(int ti = 1; ti <= T; ti++) {
        if(BoatDevil::lwhzkj()) puts("Yes");
        else puts("No");
        //wlzhjk
    }
    return 0;
}
```

---

## 作者：zjh114514 (赞：5)

首先按 $t$ 从小到大排序显然是优的。

考虑暴力推箱子的过程，如果一个箱子后面有 $x$ 个箱子，则将这些箱子推动 $1$ 单位长度的花费为 $x+1$。

于是我们可以直接维护箱子的连续段暴力移动箱子，使用启发式分裂合并，分裂合并只会有 $O(n)$ 次，总时间复杂度 $O(n\log n)$。

代码大致就是先排序，然后把当前箱子所在的连续段分裂成两段（在连续段边界（看位移方向，正方向位移则在左端点不分，反之在右端点不分）则不分），当前箱子所在的那段加上 $b_i-pos_i$ 的位移并计算时间（$pos_i$ 为当前箱子位置），如果移动后顶到了其他连续段，就把顶到的连续段移到移动后连续段的右边，然后合并，每次移动后检查总花费时间是否大于 $t_i$。

```
#include <bits/stdc++.h>
using namespace std;

const int _ = 200020;

int c, T;
struct Rg {
    int l, r, lp, rp;
} rg[_ << 4]; int cnt, of[_];

void split(int x, int y, int o) {
    if (o > 0) {
        if (y == rg[x].l) return;
        if (y - rg[x].l < rg[x].r - y) {
            rg[++cnt] = {rg[x].l, y - 1, rg[x].lp, rg[x].lp + y - rg[x].l - 1};
            for (int i = rg[x].l; i < y; i++) of[i] = cnt;
            rg[x].lp += y - rg[x].l;
            rg[x].l = y;
        } else {
            rg[++cnt] = {y, rg[x].r, rg[x].lp + y - rg[x].l, rg[x].rp};
            for (int i = y; i <= rg[x].r; i++) of[i] = cnt;
            rg[x].rp -= rg[x].r - y + 1;
            rg[x].r = y - 1;
        }
    } else {
        if (y == rg[x].r) return;
        if (y - rg[x].l < rg[x].r - y) {
            rg[++cnt] = {rg[x].l, y, rg[x].lp, rg[x].lp + y - rg[x].l};
            for (int i = rg[x].l; i <= y; i++) of[i] = cnt;
            rg[x].lp += y - rg[x].l + 1;
            rg[x].l = y + 1;
        } else {
            rg[++cnt] = {y + 1, rg[x].r, rg[x].lp + y - rg[x].l + 1, rg[x].rp};
            for (int i = y + 1; i <= rg[x].r; i++) of[i] = cnt;
            rg[x].rp -= rg[x].r - y;
            rg[x].r = y;
        }
    }
}

void merge(int x, int y) {
    if (rg[x].r - rg[x].l < rg[y].r - rg[y].l) {
        for (int i = rg[x].l; i <= rg[x].r; i++) of[i] = y;
        rg[y].l -= rg[x].r - rg[x].l + 1;
        rg[y].lp -= rg[x].r - rg[x].l + 1;
    } else {
        for (int i = rg[y].l; i <= rg[y].r; i++) of[i] = x;
        rg[x].r += rg[y].r - rg[y].l + 1;
        rg[x].rp += rg[y].r - rg[y].l + 1;
    }
}

long long sum;

void mov(Rg& x, int a, int b) {
    int tmp = b - a;
    x.lp += tmp;
    x.rp += tmp;
    sum += 1LL * (x.r - x.l + 1) * abs(tmp);
}

struct Qry {
    int a, b, id;
    long long t;
} q[_]; int n;

void solve() {
    cin >> n;
    cnt = 0;
    for (int i = 1; i <= n; i++) {
        cin >> q[i].a >> q[i].b >> q[i].t; q[i].id = i;
        rg[++cnt] = {i, i, q[i].a, q[i].a};
        of[i] = i;
    }
    sort(q + 1, q + n + 1, [](Qry x, Qry y) { return x.t < y.t; });
    sum = 0;
    for (int i = 1; i <= n; i++) {
        int id = q[i].id;
        int o = q[i].b - (rg[of[id]].lp + id - rg[of[id]].l);
        if (!o) continue;
        split(of[id], id, o);
        int u = rg[of[id]].lp + id - rg[of[id]].l, v = q[i].b, lst = -1;
        while (1) {
            mov(rg[of[id]], u, v);
            if (~lst) o > 0 ? merge(of[lst], of[id]) : merge(of[id], of[lst]);
            int id2 = o > 0 ? rg[of[id]].r + 1 : rg[of[id]].l - 1;
            if (!id2 || id2 > n || (o > 0 ? rg[of[id]].rp < rg[of[id2]].lp : rg[of[id]].lp > rg[of[id2]].rp)) break;
            u = o > 0 ? rg[of[id2]].lp : rg[of[id2]].rp;
            v = o > 0 ? rg[of[id]].rp + 1 : rg[of[id]].lp - 1;
            lst = id;
            id = id2;
        }
        if (sum > q[i].t) return cout << "No\n", void();
    }
    cout << "Yes\n";
}

int main() {
    cin.tie(0)->sync_with_stdio(0);
    freopen("move.in", "r", stdin);
    freopen("move.out", "w", stdout);
    cin >> c >> T;
    while (T--) solve();
}
```

---

## 作者：LastKismet (赞：5)

# 做法简介
平衡树+线段树把纯暴力做法优化到单 $\log$。与 ODT 做法类似。

# 思路
首先是一个很显然的贪心，由于一个点固定后必然不会在被推动（相对位置一定），所以 $t$ 小的先推必然最优。

最暴力的解法就是每次找一路上会碰上的所有箱子然后一起移动，显然可以卡到 $O(n^2)$。

然后我们考虑对这个暴力的暴力的优化：维护连续段。

之所以会这么想，显然是因为上面影响复杂度的大头就是每次要遍历后续所有箱子。这个优化看起来很对的原因是，这些箱子推完后必然变成一个连续段，并且它不会往回推，只会向前分裂然后前进。

# 复杂度证明
这个算法的复杂度看起来很伪，但你会发现，由于被推之后就固定，所以存在下面的性质：
1. 每个点只会（以它为其所在连续段起点）被加入连续段一次。
2. 每个点只会（以它为分裂出的第一个点）被分离连续段一次。

对于第一个性质，是因为推完一次之后，这个连续段的起点就已经固定了，并且整个段只能单向移动，所以不会被加入多次。

对于第二个性质也是类似，因为以它为首节点分裂连续段唯一的情况就是它要往后移。它显然只需要移动一次，然后就固定了。

因此，我们只需要考虑 $O(\log n)$ 处理连续段的合并与分裂即可。

# 实现
## 基本
由于我们要维护连续段，所以我们应当给每个连续段编号，并维护一个连续段序列。

每次合并与分离时，这个序列会发生变化。所以，~~不管正常人会想到什么~~，考虑使用平衡树维护这个序列。

然后首先考虑一个连续段应当储存什么信息，你发现，你需要知道这个连续段内所有箱子的编号与坐标。

然后你发现这是一个连续段，所以你只需要考虑维护左右端点的位置信息与节点编号即可。之所以一起维护左右两侧是因为要支持可能来自两侧的合并。

为了方便，我们显然要维护尽量少的信息，这里我考虑的是维护左端点编号与左右端点位置。

## 操作
我们从头开始模拟推一个箱子的过程。
### 找所在连续段
你显然可以在平衡树上二分来解决这个问题，但考场的时候显然需要越快越好，所以我的考场代码中额外维护了一棵线段树，来支持区间修改与单点查询……
### 分裂
假如当前点不是所在连续段的第一个点，那么就应当分裂这个连续段。

看到分裂，又看到平衡树，也许你会想到在平衡树上直接分裂节点。但，我的平衡树里维护的是连续段编号序列而不是箱子。

所以我们新建一个节点，更新原连续段与新连续段的信息。

这里多说一句，如果你每次都给一个新编号的话，那么总节点数也就是 $2n$，但我考场上显然没有想这么多，所以回收利用了废弃编号，使节点数卡死在 $n$。

好然后考虑把这个点插入到序列中去。

我的平衡树写的是 FHQ-Treap，想必各位也许有更简洁的办法实现*把某个节点插入到某个节点的后面*，但我的实现是：

获取原来连续段所在的 $rnk$，然后以这个 $rnk$ 为边界把整个序列分成两截，然后把新节点放到中间，重新 `merge` 成一个序列。

好，那么我们就分裂出了一个连续段。

### 移动
从这个点开始暴力往后移……

我们首先获取新连续段的 $rnk$，然后从这个 $rnk$ 开始往边界移动（看你往哪里移），然后一路上暴力合并遇到的连续段，不用合并了就停止。

至于如何遍历，我们遍历 $rnk$，然后 `getval` 即可获取当前连续段的编号。$O(\log n)$，合理。

### 合并
考虑记录下最后一个需要合并的节点，然后更新新的连续段的信息。

新的连续段一侧位置显然就是 $b_i$，另一侧，可以根据最后的连续段到新连续段的所有节点总数得到。考虑编号连续的性质，我们只需要获取最后连续段最后节点的编号，即可得知有多少节点。

然后如何合并呢，我们直接把*新节点的后一个节点*到*最后一个要被合并的节点*在序列里删除即可。

然后我们原来新建的连续段就代表了合并完的连续段。

然后在线段树里区间覆盖一下。。。（好蠢）

### 获取耗时
你发现我们是暴力遍历可以被移动的连续段，所以就每到一个连续段，如果要被移动，更新一遍答案即可。

首先我们可以知道当前连续段应当去往的位置，然后把首节点的移动乘以这个段的长度即可。每个节点移动的步数都是一样的。
# 代码
## 主要代码
```cpp
void solve(){
	cin>>n;
	seg.build();fre.clear();
	rep(i,1,n)cin>>bs[i].a>>bs[i].b>>bs[i].t;
	sort(bs+1,bs+1+n,[](box a,box b){return a.a<b.a;});
	rep(i,1,n)trn[i]=i;
	sort(trn+1,trn+1+n,[&](int a,int b){return bs[a].t<bs[b].t;});
	rep(i,1,n)qs[i].l=qs[i].r=bs[i].a,qs[i].lid=i;
	rep(i,1,n)fhq.newnode(i,i);
	root=0;
	rep(i,1,n)root=fhq.merge(root,i);
	tim=0;
	rep(i,1,n){
		int now=trn[i];
		int nqj=seg.query(now);
		if(bs[now].b<qs[nqj].l+now-qs[nqj].lid){
			int x;
			int rt1,rt2,rt3;
			if(qs[nqj].lid+qs[nqj].r-qs[nqj].l-now>0){
				x=fre.back();fre.pop_back();
				fhq.newnode(x,x);
				qs[x].l=qs[nqj].l,qs[x].r=qs[nqj].l+now-qs[nqj].lid,qs[x].lid=qs[nqj].lid;
				qs[nqj].l=qs[x].r+1;qs[nqj].lid=now+1;
				fhq.split(root,fhq.rank(nqj)-1,rt1,rt2);
				root=fhq.merge(fhq.merge(rt1,x),rt2);
			}else x=nqj;
			int rnk=fhq.rank(x);
			int lb=bs[now].b-(qs[x].r-qs[x].l),lst=rnk;
			tim+=ll(qs[x].r-bs[now].b)*(qs[x].r-qs[x].l+1);
			per(i,lst-1,1){
				int j=fhq.getval(root,i);
				if(qs[j].r>=lb){
					tim+=ll(qs[j].r-(lb-1))*(qs[j].r-qs[j].l+1);
					lb-=qs[j].r-qs[j].l+1;
					lst=i;
					fre.pub(j);
				}else break;
			}
			int y=fhq.getval(root,lst);
			if(lst<rnk){
				fhq.split(root,rnk-1,rt1,rt3);
				fhq.split(rt1,lst-1,rt1,rt2);
				root=fhq.merge(rt1,rt3);
			}
			qs[x].l=bs[now].b-(now-qs[y].lid);qs[x].r=bs[now].b;qs[x].lid=qs[y].lid;
			seg.change(qs[x].lid,qs[x].lid+qs[x].r-qs[x].l,x);
		}else if(bs[now].b>qs[nqj].l+now-qs[nqj].lid){
			int x;
			int rt1,rt2,rt3;
			if(now-qs[nqj].lid>0){
				x=fre.back();fre.pop_back();
				fhq.newnode(x,x);
				qs[x].l=qs[nqj].l+now-qs[nqj].lid,qs[x].r=qs[nqj].r,qs[x].lid=now;
				qs[nqj].r=qs[x].l-1;
				fhq.split(root,fhq.rank(nqj),rt1,rt2);
				root=fhq.merge(fhq.merge(rt1,x),rt2);
			}else x=nqj;
			int rnk=fhq.rank(x);
			int rb=bs[now].b+qs[x].r-qs[x].l,lst=rnk;
			tim+=ll(bs[now].b-qs[x].l)*(qs[x].r-qs[x].l+1);
			rep(i,lst+1,fhq.ns[root].siz){
				int j=fhq.getval(root,i);
				if(qs[j].l<=rb){
					tim+=ll(rb+1-qs[j].l)*(qs[j].r-qs[j].l+1);
					rb+=qs[j].r-qs[j].l+1;
					lst=i;
					fre.pub(j);
				}else break;
			}
			int y=fhq.getval(root,lst);
			if(lst>rnk){
				fhq.split(root,rnk,rt1,rt2);
				fhq.split(rt2,lst-rnk,rt2,rt3);
				root=fhq.merge(rt1,rt3);
			}
			qs[x].r=bs[now].b+(qs[y].lid+qs[y].r-qs[y].l-now);qs[x].l=bs[now].b;
			seg.change(qs[x].lid,qs[x].lid+qs[x].r-qs[x].l,x);
		}
		if(tim>bs[now].t){
			cout<<"No\n";
			return;
		}
	}
	cout<<"Yes\n";
}
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define repl(i,x,y) for(int i=(x);i<(y);i++)
#define per(i,x,y) for(int i=(x);i>=(y);i--)
#define pub push_back
#define fir first
#define sec second
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<int,ll> pil;
typedef pair<ll,int> pli;
typedef pair<ll,ll> pll;
template<typename T>
using vec=vector<T>;
template<typename T>
using grheap=priority_queue<T>;
template<typename T>
using lrheap=priority_queue<T,vector<T>,greater<T>>;
#define file(s) freopen(#s".in","r",stdin);freopen(#s".out","w",stdout)

const int N=2e5+5;

mt19937 rnd(time(0));

int n;
ll tim;
struct box{
	ll a,b,t;
}bs[N];
int trn[N];

int root;
struct FHQ{
	struct node{
		int pri,val;
		int fa;
		int lson,rson;
		int siz;
	}ns[N];
	void update(int x){
		if(ns[x].lson)ns[ns[x].lson].fa=x;
		if(ns[x].rson)ns[ns[x].rson].fa=x;
		ns[x].siz=ns[ns[x].lson].siz+1+ns[ns[x].rson].siz;
	}
	int newnode(int x,int val){
		ns[x].pri=rnd();
		ns[x].val=val;
		ns[x].siz=1;
		ns[x].fa=ns[x].lson=ns[x].rson=0;
		return x;
	}
	int merge(int a,int b){
		if(!a)return b;
		if(!b)return a;
		if(ns[a].pri>ns[b].pri){
			ns[a].rson=merge(ns[a].rson,b);
			update(a);
			return a;
		}else{
			ns[b].lson=merge(a,ns[b].lson);
			update(b);
			return b;
		}
	}
	void split(int x,int k,int &rt1,int &rt2){
		if(!x){
			rt1=rt2=0;
			return;
		}
		if(ns[ns[x].lson].siz>=k){
			split(ns[x].lson,k,rt1,ns[x].lson);
			ns[rt1].fa=0;
			rt2=x;
		}else{
			split(ns[x].rson,k-ns[ns[x].lson].siz-1,ns[x].rson,rt2);
			ns[rt2].fa=0;
			rt1=x;
		}
		update(x);
	}
	int getval(int x,int k){
		if(ns[ns[x].lson].siz>=k)return getval(ns[x].lson,k);
		else if(ns[ns[x].lson].siz==k-1)return ns[x].val;
		else return getval(ns[x].rson,k-ns[ns[x].lson].siz-1);
	}
	int rank(int x){
		int res=ns[ns[x].lson].siz+1;
		while(ns[x].fa){
			if(x==ns[ns[x].fa].rson)res+=ns[ns[ns[x].fa].lson].siz+1;
			x=ns[x].fa;
		}
		return res;
	}
}fhq;

struct segment{
	int dat[N<<2],laz[N<<2];
	void pushdown(int x){
		if(!laz[x])return;
		dat[x<<1]=dat[x<<1|1]=laz[x];
		laz[x<<1]=laz[x<<1|1]=laz[x];
		laz[x]=0;
	}
	void build(int x=1,int l=1,int r=n){
		laz[x]=0;
		if(l==r){
			dat[x]=l;
			return;
		}
		int m=l+r>>1;
		build(x<<1,l,m);
		build(x<<1|1,m+1,r);
	}
	void change(int lq,int rq,int v,int x=1,int l=1,int r=n){
		if(lq<=l&&r<=rq){
			dat[x]=laz[x]=v;
			return;
		}
		int m=l+r>>1;
		pushdown(x);
		if(lq<=m)change(lq,rq,v,x<<1,l,m);
		if(m<rq)change(lq,rq,v,x<<1|1,m+1,r);
	}
	int query(int k,int x=1,int l=1,int r=n){
		if(l==r)return dat[x];
		int m=l+r>>1;
		pushdown(x);
		if(k<=m)return query(k,x<<1,l,m);
		else return query(k,x<<1|1,m+1,r); 
	}
}seg;

struct qj{
	int l,r;
	int lid;
}qs[N];
vec<int> fre;

void solve(){
	cin>>n;
	seg.build();fre.clear();
	rep(i,1,n)cin>>bs[i].a>>bs[i].b>>bs[i].t;
	sort(bs+1,bs+1+n,[](box a,box b){return a.a<b.a;});
	rep(i,1,n)trn[i]=i;
	sort(trn+1,trn+1+n,[&](int a,int b){return bs[a].t<bs[b].t;});
	rep(i,1,n)qs[i].l=qs[i].r=bs[i].a,qs[i].lid=i;
	rep(i,1,n)fhq.newnode(i,i);
	root=0;
	rep(i,1,n)root=fhq.merge(root,i);
	tim=0;
	rep(i,1,n){
		int now=trn[i];
		int nqj=seg.query(now);
		if(bs[now].b<qs[nqj].l+now-qs[nqj].lid){
			int x;
			int rt1,rt2,rt3;
			if(qs[nqj].lid+qs[nqj].r-qs[nqj].l-now>0){
				x=fre.back();fre.pop_back();
				fhq.newnode(x,x);
				qs[x].l=qs[nqj].l,qs[x].r=qs[nqj].l+now-qs[nqj].lid,qs[x].lid=qs[nqj].lid;
				qs[nqj].l=qs[x].r+1;qs[nqj].lid=now+1;
				fhq.split(root,fhq.rank(nqj)-1,rt1,rt2);
				root=fhq.merge(fhq.merge(rt1,x),rt2);
			}else x=nqj;
			int rnk=fhq.rank(x);
			int lb=bs[now].b-(qs[x].r-qs[x].l),lst=rnk;
			tim+=ll(qs[x].r-bs[now].b)*(qs[x].r-qs[x].l+1);
			per(i,lst-1,1){
				int j=fhq.getval(root,i);
				if(qs[j].r>=lb){
					tim+=ll(qs[j].r-(lb-1))*(qs[j].r-qs[j].l+1);
					lb-=qs[j].r-qs[j].l+1;
					lst=i;
					fre.pub(j);
				}else break;
			}
			int y=fhq.getval(root,lst);
			if(lst<rnk){
				fhq.split(root,rnk-1,rt1,rt3);
				fhq.split(rt1,lst-1,rt1,rt2);
				root=fhq.merge(rt1,rt3);
			}
			qs[x].l=bs[now].b-(now-qs[y].lid);qs[x].r=bs[now].b;qs[x].lid=qs[y].lid;
			seg.change(qs[x].lid,qs[x].lid+qs[x].r-qs[x].l,x);
		}else if(bs[now].b>qs[nqj].l+now-qs[nqj].lid){
			int x;
			int rt1,rt2,rt3;
			if(now-qs[nqj].lid>0){
				x=fre.back();fre.pop_back();
				fhq.newnode(x,x);
				qs[x].l=qs[nqj].l+now-qs[nqj].lid,qs[x].r=qs[nqj].r,qs[x].lid=now;
				qs[nqj].r=qs[x].l-1;
				fhq.split(root,fhq.rank(nqj),rt1,rt2);
				root=fhq.merge(fhq.merge(rt1,x),rt2);
			}else x=nqj;
			int rnk=fhq.rank(x);
			int rb=bs[now].b+qs[x].r-qs[x].l,lst=rnk;
			tim+=ll(bs[now].b-qs[x].l)*(qs[x].r-qs[x].l+1);
			rep(i,lst+1,fhq.ns[root].siz){
				int j=fhq.getval(root,i);
				if(qs[j].l<=rb){
					tim+=ll(rb+1-qs[j].l)*(qs[j].r-qs[j].l+1);
					rb+=qs[j].r-qs[j].l+1;
					lst=i;
					fre.pub(j);
				}else break;
			}
			int y=fhq.getval(root,lst);
			if(lst>rnk){
				fhq.split(root,rnk,rt1,rt2);
				fhq.split(rt2,lst-rnk,rt2,rt3);
				root=fhq.merge(rt1,rt3);
			}
			qs[x].r=bs[now].b+(qs[y].lid+qs[y].r-qs[y].l-now);qs[x].l=bs[now].b;
			seg.change(qs[x].lid,qs[x].lid+qs[x].r-qs[x].l,x);
		}
		if(tim>bs[now].t){
			cout<<"No\n";
			return;
		}
	}
	cout<<"Yes\n";
}

int main(){
	// file(move);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int c,t;cin>>c>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：5)

**本题解的风格相对于普通题解略有变动，请审核明察**。

## 前言

在联合省选的广东赛区中，监考员第二次发出了考试结束的指令。

与伙伴们分别后，我坐在父母的车上，处在回家的路上。

坐在车上，我想起今天相比昨天更具有戏剧性的调试过程，感叹道：要是我的线段树没有写错，我后面的部分分能再多拿一点吗？

## 题解

首先，显然可以得知必须先处理时间限制更小的点。

根据这个性质，我们不难得到一个 $O(n^2)$ 的暴力解法：暴力地将需要移动的点移动到能够让目标点移动到对应位置的位置。

然而，由于 $n\le 2\times 10^5$，这显然是不够的，考虑优化。

题目中给出的坐标是单调上升的，同时操作时所有点的坐标也是单调上升的，非常不美观，考虑将第 $i$ 个数的起始坐标和目标坐标同时减去 $i$，不难发现条件从单调上升变为单调不降外没有改动原来的规则。

所以，现在，操作被转换为：

1. 若点 $i$ 的目标点在目前坐标的左侧，则在左侧找到第一个目前坐标大于 $i$ 目标点的位置 $j$，将 $j$ 和 $i$ 之间的所有点移至 $i$ 目标点并更新答案。
2. 否则，在右侧找到最后一个目前坐标小于 $i$ 目标点的位置 $j$，将 $i$ 和 $j$ 之间的所有点移至 $i$ 目标点并更新答案。

上述操作显然可以使用线段树进行优化。但是，由于坐标变换是批量操作，如何计算每个批量操作的点的答案呢？

实际上，由于变换后 $b$ 是单调不降的，批量变换后达到目标位置的点一定形成了一个区间。此时，我们可以暴力枚举这个区间内的所有位置，并更新答案。而由于批量变换的波式传播，从 $i$ 开始，每个往外延伸的达到目标坐标的点所用的时间都比前一个少 $1$。

至此，本题解决，时间复杂度 $O(n\log n)$。

## 代码

```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <algorithm>
#include <cctype>
#include <cstdio>
using namespace std;
const int N = 2e5 + 10;
int n, a[N], b[N], p[N], clb, crb, buf;
using ll = long long;
ll t[N], trs[N];
int mx[N << 2], tag[N << 2];
ll sm[N << 2], curt;
template <typename _Tp> inline void read(_Tp &x)
{
	static char ch;
	while (ch = getchar(), !isdigit(ch))
		;
	x = (ch ^ 48);
	while (ch = getchar(), isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48);
}
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
	read(x);
	read(args...);
}
inline void grb(int x)
{
	mx[x] = max(mx[x << 1], mx[x << 1 | 1]);
	sm[x] = sm[x << 1] + sm[x << 1 | 1];
}
void build(int x, int l, int r)
{
	tag[x] = -1;
	if (l == r)
	{
		mx[x] = sm[x] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(x << 1, l, mid);
	build(x << 1 | 1, mid + 1, r);
	grb(x);
}
void psh(int x, int l, int r)
{
	if (!~tag[x])
		return;
	int mid = (l + r) >> 1;
	mx[x << 1] = mx[x << 1 | 1] = tag[x];
	sm[x << 1] = 1ll * tag[x] * (mid - l + 1);
	sm[x << 1 | 1] = 1ll * tag[x] * (r - mid);
	tag[x << 1] = tag[x << 1 | 1] = tag[x];
	tag[x] = -1;
}
void update(int x, int l, int r)
{
	if (l >= clb and r <= crb)
	{
		tag[x] = buf;
		mx[x] = buf;
		sm[x] = 1ll * buf * (r - l + 1);
		return;
	}
	psh(x, l, r);
	int mid = (l + r) >> 1;
	if (clb <= mid)
		update(x << 1, l, mid);
	if (crb > mid)
		update(x << 1 | 1, mid + 1, r);
	grb(x);
}
int lwb(int x, int l, int r)
{
	if (l == r)
		return mx[x] >= buf ? l : l + 1;
	psh(x, l, r);
	int mid = (l + r) >> 1, ret = 0;
	if (mx[x << 1] >= buf)
		ret = lwb(x << 1, l, mid);
	else
		ret = lwb(x << 1 | 1, mid + 1, r);
	grb(x);
	return ret;
}
ll query(int x, int l, int r)
{
	if (l >= clb and r <= crb)
		return sm[x];
	psh(x, l, r);
	int mid = (l + r) >> 1;
	ll res = 0;
	if (clb <= mid)
		res += query(x << 1, l, mid);
	if (crb > mid)
		res += query(x << 1 | 1, mid + 1, r);
	grb(x);
	return res;
}
void init_global()
{
}
void init_local()
{
	read(n);
	for (int i = 1; i <= n; i++)
		trs[i] = -1, p[i] = i, read(a[i], b[i], t[i]), a[i] -= i, b[i] -= i;
	sort(p + 1, p + n + 1, [&](int x, int y) { return t[x] < t[y]; });
	build(1, 1, n);
	curt = 0;
}
void run()
{
	for (int j = 1, i, tps; j <= n; j++)
	{
		i = p[j];
		// printf("%d %lld\n", i, curt);
		if (~trs[i])
			continue;
		if (a[i] == b[i])
		{
			trs[i] = 0;
			continue;
		}
		if (a[i] < b[i])
		{
			buf = b[i];
			tps = lwb(1, 1, n) - 1;
			clb = i, crb = tps;
			curt += 1ll * b[i] * (tps - i + 1) - query(1, 1, n);
			update(1, 1, n);
			for (ll k = i, trt = curt; k <= crb; k++)
			{
				if (~trs[k])
					break;
				if (b[k] != b[i])
					break;
				trs[k] = trt;
				trt--;
			}
			continue;
		}
		buf = b[i];
		tps = lwb(1, 1, n);
		clb = tps, crb = i;
		curt += query(1, 1, n) - 1ll * (i - tps + 1) * b[i];
		update(1, 1, n);
		for (ll k = i, trt = curt; k >= clb; k--)
		{
			if (~trs[k])
				break;
			if (b[k] != b[i])
				break;
			trs[k] = trt;
			trt--;
		}
	}
	for (int i = 1; i <= n; i++)
	{
		// printf("%lld%c", trs[i], " \n"[i == n]);
		if (trs[i] > t[i])
		{
			puts("No");
			return;
		}
	}
	puts("Yes");
}
int main()
{
    freopen("move.in","r",stdin);
    freopen("move.out","w",stdout);
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	int T = 1;
	scanf("%*d%d", &T);
	init_global();
	while (T--)
	{
		init_local();
		run();
	}
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

## 后记

拿起手机，同伴们都在讨论今天的比赛情况。还记得在考场外，有一位同学对我 T1 的结论提出了质疑。而在车上，他在 QQ 群里肯定了我的猜测。为什么？此时，另外一位同学发了一条消息。这条消息的大意是：

> 此事在 [AtCoder Beginner Contest 371 F - Takahashi in Narrow Road](https://atcoder.jp/contests/abc371/tasks/abc371_f) 中亦有记载。

打开这道题，查看提交记录中的代码。我看见当时我用 $30$ 分钟解决了这道题。再仔细看看代码，我发现，当时我在家里写出线段树二分和我在考场上写出的在细节上没有任何差别。

真快啊。

半年就这么过去了，由 ABC 产生的记忆，跨越了半年，又再一次被唤醒了。

---

## 作者：luogu_starblue (赞：4)

后面一大段和题解无关，希望能通过审核，目前已通过全部大样例。

场外选手，目前高二，已经半AFO。

这周是一个愉快且难得的双休，同时也是省选联考的日子，虽然已经半AFO，但是你然仍选择看看今年的题目。

当你看到D2T1的时候，整个人瞬间就不好了，因为这使你回想起了[AT_abc371_f](https://www.luogu.com.cn/problem/AT_abc371_f)。那场比赛你曾经参加过，于是你快速地把那题自己的AC代码给复制过来，改了改，发现通过了全部的大样例。

你是这样想的：

首先因为 $a_i$ 和 $b_i$ 是严格单调递增的，所以在移动过程中所有箱子的位置 $p_i$ 的相对顺序不会发生改变，因此只要时间足够，就一定能满足要求。

于是显然我们只需要把所有的箱子按照 $t_i$ 排序，然后依次移动他们，并在每次移动后看看当前时间是否超过了需要的时间，就可以判断了。

至于依次移动的过程，就是[AT_abc371_f](https://www.luogu.com.cn/problem/AT_abc371_f)。

因为一次移动过程中，为了使时间最小，从位置 $a$ 到 $b$ 过程中那些一同被推动的箱子最终的序列一定会形成一个等差数列。

于是我们只需要找到哪些箱子会被影响，很显然满足单调性，可以二分。

于是我们只需要维护这样一个序列，能够实现区间查询和区间修改为公差为 $1$ 的等差数列，这个需求可以用线段树轻松实现。

[这是你的代码](https://www.luogu.com.cn/paste/xgp8coob)。

你开始后悔自己去年S组和NOIP的表现，如果自己能够去省选的话那该多好。

但是这些也只能成为幻想了。

你是来自强省GD但是弱校的一名超蒻Oier，从初三暑假才开始学OI的你深知自己能力的不足，以及因为是弱校而没有对自己学习OI有利的资源。但尽管如此，你的心中却也时刻装载着对梦想的渴望。

上了高中的你似乎和初中很不一样了，逃离了初中那麻木的过去，你打算重新拥抱生活，你重新捡起了对数学的热爱，同时找到了新的热爱——OI。尽管在校时间学习时间相当紧迫，并且有着来自whk的压力，你仍然抓紧每一个自由活动和周末的时间去自学OI。

高一的第一次比赛，你获得了J组一等奖，S组二等奖，以及NOIP二等。这是你第一次比赛获奖，获得了认可，那时的你对生活更加充满了希望，想象自己高二获得省一并且体验了WC和省选，如果理想的话，甚至可以去NOI，最后无憾AFO的过程。

为此你充满了动力，你在放假期间辗转于网课与集训，虽然很累，但也大抵是幸福的吧。

时间很快来到了高二，你走进了CSP的考场，然而不知为何，或许是自己实在还是太蒻，或许是当天状态不好，在T2大样例始终过不去的时候，你没有想到是自己做法有问题，反而是一直坚定认为是自己代码有错。为此你浪费了大量时间去修改代码，这当然是做无用功，当你缓过神来的时候比赛已经快结束了。你快速地打完T3的20分暴力后遗憾退场了。

NOIP，这次你希望能够掰回来，40分钟秒切T1的满怀信心，然而当你看到T2那自己几乎完全没涉及的组合数学的时候又陷进去了，发生了几乎和CSP差不多的情况。之后你难受了几周才缓过神来。

之后你虽然半退役了，但你然仍选择打公开模拟赛去麻痹自己，期待着至少高三能够获得一个省一。

然而今天看到省选联考的你却再一次感到了难受，如果当初我再努力一点，结果会不会不同呢？

你想到当初高一你收到NOIP证书时发的朋友圈，图片为你的获奖证书，并赋上了一句：若是心向明月，纵然不慎受挫也会失落在星辰之间。关于那条朋友圈，你知道，是你点赞和评论最多的朋友圈。

尝试了许多方法去缓解的你最终选择了打开洛谷，开始为这道题撰写题解。

最后，语文不好的你打算以[[省选联考 2025] 追忆](https://www.luogu.com.cn/problem/P11831)中内容做结尾。

追忆总在不经意间将我裹进泛黄的纸页里。分别又重聚的朋友，推倒又重建的街道，种种线索协助着我从一个具体的时刻出发沿时间的河逆流而上。曾经的日子无法重来，我只不过是一个过客。但我仍然渴望在每一次追忆之旅中留下闲暇时间，在一个场景前驻足，在岁月的朦胧里瞭望过去的自己，感受尽可能多的甜蜜。美好的时光曾流过我的身体，我便心满意足。

---

## 作者：shinzanmono (赞：4)

性质 B 可以直接按 $t$ 贪心做。但是如果区间有交，即性质 C，那就要先将所有与当前区间有交的区间全部移动变为无交，假如当前要移动第 $x$ 个箱子，就要将 $\geq x$ 的位置 $y$ 满足 $a_y\leq b_x+y-x$ 的 $a_y$ 变为 $b_x+y-x$。这个操作可以使用对区间赋值一个等差数列，查询第一个位置满足 $a_y> b_x+y-x$。直接线段树上二分即可做到 $O(n\log n)$。

那如果动的方向不一样怎么办呢，我们可以将不一样方向的区间翻转，设这些区间覆盖的值域为 $[L,R]$，则对于每一个区间 $a_i,b_i(a_i<b_i)$ 来说，可以将其变为 $[L+R-a_i,L+R-b_i]$，可以证明的是两个方向是完全等价的。

至于对 $t$ 贪心的正确性，考虑如果优先满足 $t_i$ 更大的端，那么只会加大对与 $i$ 不交的线段的满足条件的时刻，显然不优，而如果有交，可以将有交的部分移动直至无交即可。

```cpp
#include<iostream>
#include<algorithm>
#include<set>
using ll=long long;
const int sz=2e5+10;
ll a[sz],b[sz],t[sz];
bool check(int i,int j){
  int x=a[i],y=b[i],c=a[j],d=b[j];
  if(x>y)std::swap(x,y);
  if(c>d)std::swap(c,d);
  return y>=c;
}
struct SegT{
  struct node{
    int lson,rson;
    ll sum,max,tag;
  }tree[sz<<2];
  int num;
  void clear(){
    for(int i=0;i<=num;i++)tree[i]=node{0,0,0,0,0};
    num=0;
  }
  void pushtag(int p,ll val,int ln,int rn){
    tree[p].sum=(2*val+rn-ln)*(rn-ln+1)/2;
    tree[p].max=val+rn-ln,tree[p].tag=val;
  }
  void pushdown(int p,int ln,int rn){
    if(tree[p].tag==0)return;
    int mid=ln+rn>>1;
    pushtag(tree[p].lson,tree[p].tag,ln,mid);
    pushtag(tree[p].rson,tree[p].tag+mid-ln+1,mid+1,rn);
    tree[p].tag=0;
  }
  void build(int &p,int ln,int rn){
    p=++num;
    if(ln==rn)return tree[p].sum=tree[p].max=a[ln],void();
    int mid=ln+rn>>1;
    build(tree[p].lson,ln,mid);
    build(tree[p].rson,mid+1,rn);
    tree[p].sum=tree[tree[p].lson].sum+tree[tree[p].rson].sum;
    tree[p].max=std::max(tree[tree[p].lson].max,tree[tree[p].rson].max);
  }
  void assign(int p,int ln,int rn,int l,int r,int val){
    if(ln>=l&&rn<=r)return pushtag(p,val+ln-l,ln,rn);
    int mid=ln+rn>>1;
    pushdown(p,ln,rn);
    if(l<=mid)assign(tree[p].lson,ln,mid,l,r,val);
    if(r>mid)assign(tree[p].rson,mid+1,rn,l,r,val);
    tree[p].sum=tree[tree[p].lson].sum+tree[tree[p].rson].sum;
    tree[p].max=std::max(tree[tree[p].lson].max,tree[tree[p].rson].max);
  }
  int find(int p,int ln,int rn,ll val){
    if(ln==rn)return ln;
    int mid=ln+rn>>1;
    pushdown(p,ln,rn);
    ll lmax=tree[tree[p].lson].max;
    if(lmax>val+mid-ln)return find(tree[p].lson,ln,mid,val);
    else return find(tree[p].rson,mid+1,rn,val+mid-ln+1);
  }
  ll query(int p,int ln,int rn,int l,int r){
    if(ln>=l&&rn<=r)return tree[p].sum;
    int mid=ln+rn>>1;
    ll res=0;
    pushdown(p,ln,rn);
    if(l<=mid)res+=query(tree[p].lson,ln,mid,l,r);
    if(r>mid)res+=query(tree[p].rson,mid+1,rn,l,r);
    return res;
  }
}st;
int va[sz],vb[sz],root[sz],belong[sz];
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int C,T;
  std::cin>>C>>T;
  while(T--)[&]{
    int n;
    std::cin>>n;
    for(int i=1;i<=n;i++)std::cin>>a[i]>>b[i]>>t[i];
    int N=0;
    std::set<std::pair<ll,int>>s;
    st.clear();
    for(int l=1,r=2;l<=n;l=r,r++){
      while(r<=n&&check(r-1,r))r++;
      if(a[l]==b[l])continue;
      ll ll=std::min(a[l],b[l]),rr=std::max(a[r-1],b[r-1]);
      if(a[l]>b[l]){
        for(int i=l;i<r;i++)a[i]=ll+rr-a[i],b[i]=ll+rr-b[i];
        std::reverse(a+l,a+r);
        std::reverse(b+l,b+r);
        std::reverse(t+l,t+r);
      }
      ++N,root[N]=0,va[N]=l,vb[N]=r-1,st.build(root[N],l,r-1);
      for(int i=l;i<r;i++)s.emplace(t[i],i),belong[i]=N;
    }
    ll tot=0;
    while(!s.empty()){
      int x=s.begin()->second,B=belong[x];
      s.erase(s.begin());
      int k=st.find(root[B],va[B],vb[B],b[x]-x+va[B]);
      if(b[x]+k-x<st.query(root[B],va[B],vb[B],k,k))k--;
      tot+=(2*b[x]+k-x)*(k-x+1)/2-st.query(root[B],va[B],vb[B],x,k);
      st.assign(root[B],va[B],vb[B],x,k,b[x]);
      if(tot>t[x])return std::cout<<"No\n",void();
    }
    std::cout<<"Yes\n";
  }();
  return 0;
}
```

---

## 作者：Xy_top (赞：4)

建议评蓝，完全跟着特殊性质走的，就没有想偏过。

先看特殊性质 A，所有点的时间都一样，然后容易发现一定存在一种方案使得每个点只朝它的目标去移动，所以就做完了；再看特殊性质 B，每个点到目标之间没有其他点，但是时间会不一样，此时可以考虑按照时间从小到大排序，然后每个点依次移到目标即可。

再看特殊性质 C，结合 A B 得到启发：
1. 按照时间从小到大排序。
2. 一定存在一种方案使得每个点只朝它的目标去移动。

关于启发 2，读者可以自行思考一下，如果每个点的目标可能在左边也可能在右边，那么仍然成立吗？

这是显然的，不然 $b$ 就不会递增了。所以正解做法就是按照时间排序，然后模拟即可。

重点在于模拟方法，发现箱子的移动会导致连锁反应，最后得到的序列类似等差数列，于是可以把 $a_i$ 减去 $i$，然后线段树区间 cover，但是笔者选择了更为简单的方法。

考虑按照时间直接用 ``set`` 维护所有已经到目标的点，每次取出时间最小的点 $x$，我们先钦定目标都在右侧（即特殊性质 C），那么先看 $x$ 当前的位置，这是很好做的，只需要找出 $x$ 左侧第一个被主动移动过的点 $i$。（注意我们认为被其他箱子推动的箱子是被动移动）那么 $x$ 现在的位置就是 $\max (b_i + x - i, a_x)$，设这个为 $loc$。

接下来我们发现 $x$ 右侧会有一些在之前就被 $x$ 推动的箱子，这些箱子 $y$ 一定满足 $a_y<loc+y-x$，移项可得 $a_y - y < loc - x$，发现左边单调不降，于是直接二分。

之前没被 $x$ 推动的箱子这一轮也可能会被推动，但是它们一定是连续的一块，具体的，如果箱子 $y$ 会被推动，那么满足 $a_y<b_x+y-x$，移项之后仍然可以二分。得到最后一个在本轮会被推动的箱子后，就是一个等差数列求和公式，非常好算。

另外注意一种特殊情况，在 $b_x$ 前有一个点 $y$ 已经被移到了 $b_y$，那么 $y$ 及后面的点不需要考虑，至于 $y$ 会不会被 $x$ 推动，显然是不会的，不然 $b$ 就无法递增了。

于是特殊性质 C 也结束了，正解就是对于目标在左边对称处理。这里读者可能会有疑问：难道向左和向右的不会相交吗，还是那句话，显然是不会的，不然 $b$ 就无法递增了。于是我们在 $O(n\log n)$ 的时间内解决了这道题。

希望写线段树的会被卡成 TLE 让我排名靠前一点（

---

## 作者：arrow_king (赞：3)

![](https://cdn.luogu.com.cn/upload/image_hosting/vn846vu4.png)

骂的就是我。

考虑按照 $t$ 从小到大贪心求解。将对应的箱子推到对应的位置上，并将沿途挡路的箱子一起向前推。这样不会有步数浪费，是最优的。

假设我们知道到最后一共会移动多少箱子，那么求解答案是简单的：不妨假设向右推，则此次耗费的时间是（所有箱子末状态坐标和）$-$（初始所有箱子坐标和）。前一个括号是一个等差数列求和，后一个括号不妨用线段树维护。那么我们的线段树要求可以执行区间修改为一个等差数列，这是简单的。

我们的唯一问题就是如何求解移动的箱子数量。一个朴素的想法是二分数量，并判断最后一个箱子的末坐标是否到达了最后一个箱子（也就是能不能推到这个箱子）。这样复杂度是 $O(\log^2n)$，被卡到了 $72$ 分。改成线段树上二分即可通过。

等着 SD 包破了再发代码。

---

## 作者：suzhikz (赞：3)

我测，我怎么还是只会第一题。

首先，如果能满足条件的话，所有物体走的路径一定存在一种情况，使他不会走回头路。

那么我们是不是可以贪心的移动物体？先移动时间紧的。

然后路径上有些物体是不是会挡住我们的物体移动？

朴素的想法是扫一下所有物体，计算至少移动多少步能使得我们的物体能移动到它应该在的位置。

比方说我们的物体是 $i$，那么他后面的第 $j$ 个物体就要移动到 $b_i+j-i$ 以后，他前面的物体 $k$ 就要移动到 $b_i-(i-j)$ ，分类讨论下物体是往前还是往后。

仔细观察式子，这两个东西都是一次函数，很有规律，我们的操作是取最大或最小值，那我们就可以用线段树维护。

线段树中维护的是这一段物体下标的和，最右边的物体，最左边的物体，还有两个懒标记。码量稍大。复杂度 $O(n \log n)$。

---

## 作者：Cure_Wing (赞：3)

[P11833 [省选联考 2025] 推箱子](https://www.luogu.com.cn/problem/P11833)

### 解析

写着写着，就写出来了。

如果你的想法是按照 $t_i$ 从小到大依次考虑每一只箱子的话，那么请往下看。如果先使得 $t_i$ 比较大的达到要求，那么一定不如是 $t_i$ 比较小的先达到要求更保险。因为题目规定了 $\{a_n\},\{b_n\}$ 单调递增，那么每一只木箱的移动步数和移动路线是一定的，所要设计的无非是谁先动谁后动。

当我们移动一只木箱从 $a_i$ 到 $b_i$ 时，如果途中有许多的木箱拦住了去路，那么一定是要先把它们移开的。因为木箱移动前后相对位置不改变，这只木箱往哪个方向去，那么被移走的木箱也要往那个方向去。这么多的木箱，由于我们暂时不关心它们是否移到了终点，于是我们可以让它们在 $b_i$ 的左边或右边依次排下去，占据数轴上的一个区间，此时我们可以将这种位置关系简化为一个向量 $(l,r,lp,rp)$，四个分量分别表示木箱最小和最大的编号，最左和最右端的位置。接下来再移动另外的木箱时，它的初始位置可能不是 $a_i$，需要重新定位。此时如果请出 `set` 来帮我们存储一下这些区间，那么我们就可以在 $O(\log n)$ 的时间复杂度内找到这只木箱的当前位置。找到这个位置后，毕竟它要单独行动，所以需要把这个区间断成三段，左边、它自己、右边。想一想可以知道，这个过程对于接下来每一个箱子都是适用的，直接循环下去就可以了。

可是每次暴力拆区间、合并区间会不会有问题呢？我们来算一下：假设一开始合并了 $k$ 段区间，那么接下来会通过 $\dfrac{k}{2}$ 次拆分分为 $\dfrac{k}{2}$ 段，平均每只箱子执行 $\dfrac{k+\dfrac{k}{2}}{1+\dfrac{k}{2}}=3-\dfrac{6}{k+2}<3$ 次，是一个较小的数，可以视为常数处理。

现在可以发现这是一个类似于颜色段均摊（ODT）的做法。实际实现时可能要加上以下操作：由于涉及到箱子的归位，需要使用链表记录左右尚未归位的箱子来维护向量中的 $l,r$；还是这个原因，需要一个树状数组记录每只位置的箱子归位情况，方便计算这只需要归位的木箱的当前位置。

可以分析发现总时间复杂度 $O(Tn\log n)$，空间复杂度 $O(n)$。

[代码](https://www.luogu.com.cn/paste/q53y5lwz)。

打算等待代码公布之后研究一下 `set` 先删后加和先加后删的区别，毕竟一个答案正确而另一个导致了运行错误。

---

## 作者：Coffee_zzz (赞：2)

首先有一个显然的性质是，把 $t$ 较小的箱子先放到要求的位置是不劣的。这个性质很好理解，因为序列 $[a_1,\dots,a_n]$ 和 $[b_1,\dots,b_n]$ 都单调递增，所以把一个箱子放到要求的位置不会对其他箱子产生负面影响，我们只需要按照时间限制 $t$ 依次进行操作即可。

不过要注意，由于我们需要保证任意时刻每个位置上都只有一个箱子，即**任意时刻箱子的位置序列单调递增**，所以可能出现要先把其他箱子推走才能推某个箱子的状况。例如，假设我们现在要把第 $i$ 个箱子从位置 $x$ 推到位置 $y$ 且 $x \lt y$，则我们需要先把 $[x+1,y]$ 中的所有箱子都推到位置 $y$ 的右侧（即 $y+1,y+2,\dots$），再把第 $i$ 个箱子推到位置 $y$。

把若干个箱子推到 $y+1,y+2,\dots$ 有点难处理，我们考虑一个优化：把第 $i$ 个箱子的初始位置和目标位置左移 $i$ 位，并将限制条件修改为**任意时刻箱子的位置序列单调不减**。优化后的问题和原问题显然是等价的，我们只要将第 $i$ 个箱子的位置右移 $i$ 位即可还原为原问题。

这样优化的巧妙之处在于，在优化后，当我们需要把第 $i$ 个箱子从位置 $x$ 推到位置 $y$ 时，只需要把 $[x,y]$ 中的所有箱子都推到位置 $y$ 即可！！！

于是，我们可以用一棵线段树维护每个箱子的位置 $w$。每次把第 $i$ 个箱子从位置 $x$ 推到位置 $y$ 时，分类讨论一下：

- 若 $x\lt y$，则用线段树二分找到最大的正整数 $r$ 使得 $w_r\le y$，并把 $w_i\sim w_r$ 的值赋为 $y$；
- 若 $y\lt x$，则用线段树二分找到最小的正整数 $l$ 使得 $y\le w_l$，并把 $w_l\sim w_i$ 的值赋为 $y$；
- 若 $x=y$，则不需要进行任何操作；

由于我们只会把箱子往同一个方向推，所以这样操作所花费的时间等于原来的 $\sum w_k$ 与当前的 $\sum w_k$ 的差的绝对值。我们只需要判断一下花费的时间之和与 $t_i$ 的大小关系即可。

时间复杂度 $\mathcal O(Tn\log n)$。

---

## 作者：woshishabi11451444 (赞：1)

看到这个题目的第一眼，容易得到第一步要对 $t_i$ 排序。

接着我们贪心地想如何把一个箱子从 $a_i$ 推到 $b_i$。

不妨设 $a_i < b_i$，$a_i > b_i$ 的情况同理。

假设我们把在 $a_{i + 1}, a_{i + 2}, \dots, a_x$ 的箱子全部诺到 $b_i$ 的后面，$a_{x + 1}$ 需要满足的条件。

显然需要满足 $x + 1 > i$ 且 $a_{x + 1} - b_i \ge x - i + 1$。

然后我们就可以知道哪些箱子在 $a_i$ 推到 $b_i$ 之前要移动。

若 $a_{i + 1} < a_{i + 2} < \dots < a_x$，则必然将 $a_{i + 1}$ 诺到 $b_{i} + 1$，将 $a_{i + 2}$ 诺到 $b_{i} + 2$, 以此类推。

首先一开始 $a$ 序列具有单调性，接着因为我们每次诺箱子的贪心策略导致每次成功达成一个箱子的要求后，$a$ 序列仍保持有序。

考虑快速的求解 $x$，考虑将条件转化为：$a_{x + 1} - x - 1 \ge b_{i} - i$。

所以我们只需动态的维护第一个 $a_{x + 1} - (x + 1)$ 大于 $b_{i} - i$ 的位置即可。

考虑用线段树上做二分来计算 $x$。

那么又根据贪心的策略，在线段树上被诺位置的那些箱子的 $a_{i} - i$ 必然是变成了 $b_{i} - i$。

现在我们已经知道如何维护诺箱子的方案了。

考虑计算新增的时间，由于我们正确地求出了 $x$，所以在 $a_{i + 1}, a_{i + 2}, \dots, a_x$ 这些位置上的箱子一定会移动的，且他们移动过后的位置一定是在他们原来的位置后面的，所以对于其中要移动的箱子 $j$ 来说，它需要 $b_{i} + j - i - a_{j}$，考虑维护 $a_{j}$ 的和，那么在线段树上顺便维护 $a_{j} - j$ 的和，此时就可以维护出移动箱子所新增的时间了。

时间复杂度：$O(n \log_{2} n)$。

空间复杂度：$O(n)$。

---

## 作者：Unnamed114514 (赞：1)

赛时过了全部大样例，代码等公开了再放。

因为 $a,b$ 都递增，所以不存在一个跨过另一个去满足自己的情况，所以我们按照时间顺序，依次去满足即可。

设当前需要考虑的是 $i$，不妨令 $a_i<b_i$，剩下的一种情况是对称的。

注意到 $i+1$ 可能会堵在 $a_i\to b_i$ 的路上，所以 $i+1$ 也要动，需要动到 $b_i+1$，以此类推。

我们设移动到的是 $a'$，那么我们需要的时间就是 $\sum|a'-a|$，这个东西拆掉绝对值之后就是个区间和查询。

然后更新位置是一个等差数列覆盖，用线段树维护即可，注意到维护区间和的时候我们显然也同时维护到了单点值，所以我们可以通过二分得到 $i$ 向右影响的最高位。

时间复杂度是 $O(n\log^2n)$ 的，但是跑得很快，大样例只有 0.2s。

---

## 作者：Genius_Star (赞：1)

### 思路：

不需要 $a_i - i$ 的一个题解，码量比较大，请谨慎阅读。

容易发现按照 $t_i$ 从小到大贪心是正确的，证明显然，因为你交换两个操作是不影响总时间的（因为 $a_i$ 与 $b_i$ 都递增）。

于是我们只需要处理将 $a_i$ 到 $b_i$ 路径上的箱子都推走，设有 $cnt$ 个，就推到 $[b_i, b_i + cnt - 1]$ 或 $[b_i - cnt + 1, b_i]$；这里或是根据 $a_i < b_i$ 还是 $a_i > b_i$（注意这里的 $a_i$ 是进行到这个箱子时的位置，不是初始给的）。

我们这里就说 $a_i < b_i$ 的情况，大于的时候几乎一样。但是这样会有一个问题，就是 $[b_i, b_i + cnt - 1]$ 中可能有其他的箱子；然后你可能想到再数这个区间里的箱子个数，推到 $b_i + cnt - 1$ 后面，但是很遗憾，每次 $cnt$ 都等于 $1$ 就寄掉了。

然后现在我们来考虑什么情况下会影响到 $x$ 处的箱子，设 $cnt$ 表示 $[a_i, x - 1]$ 内箱子的数量，那么若 $b_i + cnt - 1 \ge x$，就会影响到 $x$。

于是可以在线段树上二分找到最远的能被影响的 $x$，然后我们先将 $[a_i, x]$ 中的箱子清空，然后按位放置在 $[b_i, b_i + cnt - 1]$ 内。

然后我们需要支持查询 $[a_i, x]$ 内箱子的下标的和与 $\sum\limits_{j = b_i}^{b_i + cnt - 1} j$ 作差就是使用的时刻。

我们维护一个区间清空和一个区间放满的 $tag$ 即可。

注意我们是在值域线段树上做的，需要动态开点；然后我们查原来第 $i$ 个箱子的位置，因为不能跨过别的箱子，那么相对位置不变，直接找第 $i$ 小即可。

码量很大，考场上写了 4~5k，耗时 1.5h。

时空复杂度都是 $O(N \log W)$。

代码拿到了再放。

---

## 作者：Phartial (赞：0)

先考虑特殊性质 C。首先我们肯定是按 $t_i$ 从小到大将每个箱子移到目标位置，然后如果 $l_{i+1}\le r_i$，我们就要先将 $l_{i+1}$ 移到 $r_i+1$ 才能将 $l_i$ 移到 $r_i$。注意到这个阻挡是会传递下去的，我们需要找到最大的一个 $j$ 使得 $l_{i+j}<r_i+j$，然后将所有 $k\in [1,j]$ 的箱子从 $l_{i+k}$ 移到 $r_i+k$，才能将 $l_i$ 移到 $r_i$。

暴力模拟这个过程可以做到 $\Theta(Tn^2)$。

考虑一下我们需要做什么：

1. 给一个 $i$，找到最大的一个 $j$ 使得 $l_{i+j}<r_i+j$；
2. 求出 $\displaystyle\sum_{k=0}^j r_i+k-l_{i+k}$，本质上相当于对 $l$ 区间求和；
3. 对所有 $k\in [0,j]$，将 $l_{i+k}$ 修改为 $r_i+k$。

注意到 $l$ 是可以用线段树维护的，第一问直接二分可以做到 $\Theta(Tn\log^2 n)$。

能不能再给力一点啊？实际上你可以维护 $l_i-i$，这样第一问的二分可以上树，就单 log 了。

哦哦原来现在的语境是特殊性质 C 啊，没关系，你发现有 $a_i<b_i<b_{i+1}<a_{i+1}$，所以方向不同的两段必然不交，倒着再做一遍就行了。

代码等出了再补。

---

## 作者：happybob (赞：0)

不难注意到按照 $t$ 小到大排序后依次满足每个限制即可，模拟容易做到 $O(n^2 \log V)$。

注意到我们要做的就是，找到一个位置，然后将一段区间覆盖为等差数列，这个东西很容易线段树维护区间覆盖等差数列区间求和，还需要一个线段树二分。复杂度 $O(n \log n)$。

---


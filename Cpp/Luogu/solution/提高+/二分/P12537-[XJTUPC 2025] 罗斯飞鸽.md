# [XJTUPC 2025] 罗斯飞鸽

## 题目描述

awa 正在参加一个叫做罗斯飞鸽的真人音游活动。在活动中，awa 要在指定的时间出现在指定的位置。

具体来说，罗斯飞鸽的活动场地是一条无限长的直线。罗斯飞鸽一共有 $n$ 个判定点。第 $i$ 个判定点要求 awa 在时刻 $t_i$ 出现在位置 $x_i$。

awa 的最大跑步速度是 $v$ 个单位每时刻。在时刻 $0$，awa 可以任意选择一个位置，随后开始游玩罗斯飞鸽。

awa 想知道，自己最多能够达成多少个判定点。

## 说明/提示

由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。例如 $\tt{scanf}$ 和 $\tt{printf}$。

## 样例 #1

### 输入

```
3
6 1
8 7
8 -6
10 -8
2 5
7 -9
1 0
6 1
0 -6
0 0
8 2
10 -8
9 -5
2 -9
6 1
7 4
8 -4
8 9
3 -9
1 0
7 2```

### 输出

```
3
2
2```

# 题解

## 作者：ShwStone (赞：8)

出题人题解。

这个题出的时候没想过还能三维偏序。我们先考察 $v = 1$ 的情况：将判定点画在 $xOt$ 平面上，从某个判定点出发，能到达的点的范围在它的左上 45 度到右上 45 度之间。

如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohrurl7l.png)

这是第一组样例对应的情况，如果判定了 F 点，下一步可判定的就是 A,B,C 之一。

这个画图似乎对解题没有帮助？并不！我们把整个图片旋转 45 度：

![](https://cdn.luogu.com.cn/upload/image_hosting/qz6f1vf7.png)

所以，此时每个点能到达的下一个点，就是位于右上方的点。这是一个“二维偏序最长链问题”，如果将所有点按照新的横坐标排序，就是在求新的纵坐标的最长不下降子序列。

形式化地，新的坐标是 $(t + x, t - x)$。

不过，完整的题目要考虑 $v$。所以实际上，一个点能到达的点是一个 $\pm \arctan(v)$ 的角度范围。以 $v=2$ 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/b31n4f7q.png)

此时，我们在进行旋转运算的同时，还要向 t 轴方向做一个伸缩变换。感性理解，这两个变换显然不会改变可达点集。

形式话地说，得到的新坐标是 $(vt+x, vt-x)$，然后跑最长不下降子序列就好了。

题解 pdf 里那个证明更严谨一点。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
 
const int MAXN(5e5 + 5);
 
struct Node {
    long long ta, tb;
};
 
int n;
long long v;
Node a[MAXN], len[MAXN];
 
bool operator<(Node x, Node y) {
    return x.ta != y.ta ? x.ta < y.ta : x.tb < y.tb;
}
 
bool compare(Node x, Node y) {
    return x.tb != y.tb ? x.tb < y.tb : x.ta < y.ta;
}
 
void solve() {
    scanf("%d %lld", &n, &v);
    for (int i = 1; i <= n; i++) {
        long long t, x;
        scanf("%lld %lld", &t, &x);
        a[i].ta = v * t + x;
        a[i].tb = v * t - x;
    }
    sort(a + 1, a + n + 1, compare);
    int ans = 0;
    len[0].ta = len[0].tb = LLONG_MIN;
    for (int i = 1; i <= n; i++) {
        int p = lower_bound(len, len + ans + 1, a[i]) - len;
        len[p] = a[i];
        if (p > ans) ans++;
    }
    printf("%d\n", ans);
}
 
int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        solve();
    }
    return 0;
}
```

---

## 作者：awapwq233 (赞：2)

## P12537 [XJTUPC 2025] 罗斯飞鸽 题解

是的，我就是题面里的 awa。

你的意思是，我作为选手，在赛场上做到了以自己为背景的题？还在玩 Phigros？

出题人 @ShwStone 我喜欢你。

[题意](https://www.luogu.com.cn/problem/P12537)：给定 $n$ 个点 $(x_i,t_i)$ 和 $v$，选取 $k$ 个点，使这些点内任意两个点满足 $\left|x_i-x_j\right|\leq v \left|t_i-t_j\right|$。要求最大化 $k$ 的值。$n\leq 5\times 10^5, 0\leq v,t_i,\left|x_i\right|\leq 10^9$。

朴素 dp 是显然的，$f_i=\max\limits_{t_i>t_j;\left|x_i-x_j\right|\leq v \left(t_i-t_j\right)} \left\{f_j\right\} + 1$。时间复杂度 $O(n^2)$，考虑优化。

可以尝试把这 $n$ 个点 $(x_i,t_i)$ 画在平面直角坐标系上。

![](https://cdn.luogu.com.cn/upload/image_hosting/kkxkqm2v.png)

容易发现，能转移到当前点的节点都在**过当前点**的斜率为 $\pm v$ 的**两条直线围成的区域下方**。我们是否能对于每个点找到它的范围内的最大 $f_j$ 呢？

考虑 $f_j$ 可以转移到 $f_i$，有

$$\begin{cases}x_i-x_j\leq v(t_i-t_j)\Longrightarrow x_i-vt_i\leq x_j-vt_j &(x_i\geq x_j)\\x_j-x_i\leq v(t_i-t_j)\Longrightarrow x_i+vt_i\geq x_j+vt_j &(x_i< x_j)\end{cases}$$

> 于是，我们在赛场上就真的**分别**写了两颗线段树来维护最大值。
>
> 然后发现假了。因为在第一棵树上的只能保证一边满足条件（例如上图 $(-2,2)$ 或者 $(3,3)$ 的点会被选到），而这个需要两边同时满足，所以寄了。
>
> 诶！但是我们灵机一动，可以把 $x_i$ 与 $x_j$ 的大小关系分开讨论，然后再用一维数据结构套上去不就可以维护了吗！
>
> 但是因为我犯唐了，没时间写完树套树了，只能遗憾离场。
>
> 时间复杂度 $O(n\log^2 n)$。卡常。

但是你发现你维护两个这个东西不如直接维护 $x_i-vt_i$ 和 $x_i+vt_i$ 啊！这样就一次查询就行了。同样的，时间复杂度 $O(n\log^2 n)$。卡常。

但是你又发现，**按** $t$ **转移不如按** $x_i-vt_i$ **转移**啊！因为满足转移条件的这部分点（见上图）一定满足 $t_j<t_i$，也就是说 $t$ 这个维度是**无意义的**，于是我们可以在对 $x_i-vt_i$ 排序的情况下仅对 $x_i+vt_i$ 做限制即可。

考虑 $x_i+vt_i$ 特别大，离散化后在线段树上统计答案即可。时间复杂度 $O(n\log n)$。

```cpp
#define int ll
typedef long long ll;
typedef pair<int, int> pii;

int n, v;
const int maxn = 5e5 + 10;
pii a[maxn];

int v1(pii &p) {return p.first - v * p.second;}
int v2(pii &p) {return p.first + v * p.second;}

bool cmp1(pii &x, pii &y) {return v1(x) == v1(y) ? v2(x) < v2(y) : v1(x) > v1(y);}
bool cmp2(pii &x, pii &y) {return v2(x) == v2(y) ? v1(x) < v1(y) : v2(x) < v2(y);}

// 代码省略了线段树的部分。

signed main()
{
    int T;
    cin >> T;
    while(T --)
    {
        cin >> n >> v;
        F(i, 1, n)
            cin >> a[i].second >> a[i].first;
        sort(a + 1, a + n + 1, cmp2);
        map<int, int> mp;
        F(i, 1, n)
            mp[v2(a[i])] = i;
        int ans = 0;
        sort(a + 1, a + n + 1, cmp1);
        Tr.clear(1, n, 1);
        F(i, 1, n)
        {
            int f = Tr.query(1, n, 1, 0, mp[v2(a[i])]) + 1;
            ans = max(ans, f);
            Tr.update(1, n, 1, mp[v2(a[i])], f);
        }
        cout << ans << endl;
    }
    return 0;
}
```

其实还可以转化为 **最长不下降子序列**，因为其本质就是找到这样一个不下降序列，每个点对 dp 值的贡献都是 $1$。这也是出题人正解的写法，就不放代码了。

---


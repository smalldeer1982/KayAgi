# [FJCPC 2025] 中位数

## 题目描述

 CFJ 拥有一个长度为 $n$ 的数组 $a$，且 $n$ 必定为奇数。

由于 CFJ 十分喜爱中位数，他将进行以下操作：每次选择数组中连续的三个数字，并将它们合并为其中位数，替换这三个数字。具体而言，每次选择任意一个位置 $i$（满足 $1 < i < n$），删除 $a_{i-1}$、$a_i$ 和 $a_{i+1}$，并在该位置插入这三个数字的中位数。

 CFJ 将持续进行上述操作，直到数组中仅剩一个数字为止。整个过程共需进行 $\frac{n-1}{2}$ 次合并。他期望这个最终剩余的数字尽可能大。你的任务是帮助 CFJ 确定这个数字的最大可能值。

**中位数的定义为：将一组长度为 $n$ 的数组从小到大排序后，排名第$\lfloor \frac{n+1}{2} \rfloor$小的数字。**

## 说明/提示

对于第四个样例而言，数组 $ A = [ \ 1 \ 2 \ 3 \ 5 \ 6 \ 7 \ 4 \ ] $ 一种可行的方案是：$ [ \  \underline{1 \ 2 \ 3} \ 5 \ 6 \ 7 \ 4 \ ] \rightarrow [ \ \underline{2 \ 5 \ 6}  \ 7  \ 4 \ ] \rightarrow [ \ \underline{5 \ 7 \ 4} \  ] \rightarrow [ \ 5 \ ]$。

其中 $  \underline{a_{i-1} \ a_i \ a_{i+1}}  $ 下划线选择的连续三个数字表示每次操作合并的对象。

## 样例 #1

### 输入

```
6
1
1
3
1 2 2
5
1 3 4 5 2
7
1 2 3 5 6 7 4
9
9 9 8 2 4 4 3 5 3
9
4 4 9 2 9 5 8 3 3```

### 输出

```
1 
2 
3 
5 
9 
4```

# 题解

## 作者：Igunareo (赞：10)

## 思路

显然的，如果可以最终答案为 $i$，那么对于任意 $1\le j\le i$，一定存在解使得答案 $ans\ge j$，故本题答案满足单调性。

考虑二分答案，则需要判断是否可以使答案 $ans\ge mid$，可以将该问题转化为如下方式解决：

将原数组转化为一个 $01$ 序列，对于 $a_i\ge mid$ 使得 $a_i\gets 1$，否则对于 $a_i< mid$ 使得 $a_i\gets 0$，那么原问题变为能否使该序列答案为 $1$。

相邻数才能合并，所以需要维护一个栈，依次从栈顶加入元素进行处理。

对于连续三个数消去的情况进行分类讨论：
1. 三个数为 $000$，删去后变为 $0$，减少两个 $0$，故删去一定不劣。
2. 三个数为 $001$，$010$，$011$，$100$，$101$，$110$ 六种情况，可以发现此类情况删去后数列中 $1$ 和 $0$ 减少数量相同，故最后需要比较两者数量多少判断情况可行性，谁多剩下谁。
3. 三个数为 $111$，删去少两个 $1$ 一定不优，不删等待后续计算。

根据以上结论 $1$ 将序列中的所有 $000$ 合并，则序列中连续 $0$ 的长度不超过 $2$。  
但是此时直接使用结论 $2$ 比较 $0,1$ 数目是错误的，因为存在诸如 $00100$ 的情况，消去中间的 $1$ 后还会出现 $000$，直接计算会产生错误。  
所以对于 $001$ 的情况也需要直接合并处理，情况 $2$ 其他 $5$ 种则不需要改变，况且后续情况不明，合并不一定优（比如又接上两个 $0$ 什么的都有可能）。

然后根据比较合并后整个序列中 $0,1$ 数目大小即可判断是否存在 $ans\ge mid$。

还有别忘了多测清空。
## 代码实现
代码不长，私以为我的码风还是比较朴素正统的，可读性较强，应该方便理解。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x[100005],y[100005],Q[100005],tail=0,n;
bool check(int u){
	tail=0;
	for(int i=1;i<=n;i++){
		if(x[i]>=u)y[i]=1;
		else y[i]=0;
	}
	for(int i=1;i<=n;i++){
		if(tail>1&&Q[tail]==0&&Q[tail-1]==0)tail--;//001 和 000 的前缀都是 00 就合并处理了
		else Q[++tail]=y[i];
	}
	int summ=0;
	for(int i=1;i<=tail;i++){
		if(Q[i]==1)summ++;
		else summ--;
	}//统计数目遇 0 减一，遇 1 加一，总数为正则 1 比 0 多
	return summ>0;//长度奇数不存在总和为 0
}
signed main(){
	int T;
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)scanf("%lld",&x[i]);
		int l=1,r=1e9;
		while(l<r){
			int mid=(l+r+1)/2;
			if(check(mid))l=mid;
			else r=mid-1;
		}
		printf("%lld\n",l);
	}
	return 0;
}
```

---

## 作者：lwj54joy (赞：2)

# [传送门](https://www.luogu.com.cn/problem/P13091)
## Sol
我们使用二分答案二分结果的值 $x$。

- 对于检查当前的 $mid$ 是否合法，我们可以贪心将 $\ge mid$ 的数变为 $1$，否则变为 $0$。这样我们就可以快速得知相对大小。

考虑如何确保最优消去 $0$，保留 $1$。

- 对于原有的连续的 $0$，我们可以将其贪心区间操作，使其最终长度为 $1$ 或 $2$。
- 对于原有的连续的 $1$，我们肯定选择最后再消除。
 - 对于原有连续 $2$ 个 $0$ 以及 $1$ 个 $1$ 的情况，无论怎么消除，我们都只能变成 $0$，不过此时可以与后续的 $0$ 继续拼接。
    对于原有连续 $2$ 个 $1$ 以及 $1$ 个 $0$ 的情况，我们可以留到最后再消除。

处理完整的一个 $01$ 序列后，最后剩余 $1$ 的数量比 $0$ 多则存在某种解，否则就无解。

我们用栈模拟，直接记录连续个数，只要能确保最大化消掉 $0$ 即可。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x[100010],y[100010],Q[100010],tail,n;
bool check(int u){
	tail=0;
	for(int i=1;i<=n;i++){
		if(x[i]>=u)y[i]=1;
		else y[i]=0;
	}
	for(int i=1;i<=n;i++){
		if(tail>1&&Q[tail]==0&&Q[tail-1]==0)tail--;
		else Q[++tail]=y[i];
	}
	int summ=0;
	for(int i=1;i<=tail;i++){
		if(Q[i]==1)summ++;
		else summ--;
	}
	return summ>0;
}
signed main(){
	int T;
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)scanf("%lld",&x[i]);
		int l=1,r=1e9;
		while(l<r){
			int mid=(l+r+1)/2;
			if(check(mid))l=mid;
			else r=mid-1;
		}
		printf("%lld\n",l);
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：2)

經典 Trick 拼好題。

首先第一個 Trick 是這個問題顯然可以通過二分一個 $x$ 化簡問題，$A_i\gets [A_i\in [x,+\infty)]$，也就是說 $A_i\geq x$ 就為 $1$ 不然就為 $0$，然後對於這個問題求出答案，如果為 $1$ 就說明原問題的答案 $Ans\geq x$。

第二個 Trick 來自 AGC022E，不過這裡簡單多了，顯然我們可以考慮把 `000` 消成 `0`，然後剩下的內容就類似消除 `01` 這樣的東西，看看最後剩下一個什麼元素就行，所以我們用過棧來維護這一過程來 Check 就可以了。

時間複雜度為 $\mathcal O(n\log |w|)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,A[N],S[N],L;
inline bool Pd(int Lim)
{
	L=0;
	for(int i=1;i<=n;i++)
	{
		int x=A[i]>=Lim;
		if(x==0&&L>=2&&S[L]==0&&S[L-1]==0)L--;
		else if(L&&x==1&&S[L]==0)L--;
		else S[++L]=x;
	}
	int x=0;
	for(int i=1;i<=L;i++)
	{
		if(S[i]==1)x++;
		else x--;
	}
	return x>0;
}
inline void Work()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>A[i];
	int L=1,R=1e9,Ans=0;
	while(L<=R)
	{
		int M=L+R>>1;
		if(Pd(M))L=M+1,Ans=M;
		else R=M-1;
	}
	cout<<Ans<<endl;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--)Work();
}
```

---

## 作者：LuoFeng_Nanami (赞：2)

注意到问题是满足条件的最大可能值，显然具有单调性，二分答案。中位数这个概念涉及到大小关系比较，处理这种问题的常见解法是转换成 $01$ 序列（例如 [P2824 [HEOI2016/TJOI2016] 排序](https://www.luogu.com.cn/problem/P2824)），所以我们考虑二分到一个 $mid$ 时，将 $a$ 数组中 $\ge mid$ 的数赋值为 $1$，反之将 $< mid$ 的数赋值为 $0$。

不妨用栈来处理这个问题。我们发现，当新入栈的元素与栈顶前两个元素为 $001$ 或 $000$，对这三个进行操作，剩下一个 $0$，一定不劣。最后剩下的 $01$ 序列一定形如 $1$ 之间夹着单个的 $0$，且长度为奇数，所以只要不是 $0101010$ 这样的形式最后一定可以剩下 $1$。

关于单调性：随 $mid$ 增大，$0$ 的个数增多，接下来的部分读者可以自行理解、证明。

```cpp
const int maxn = 1e5 + 7;

int a[maxn], b[maxn], stk[maxn], top;
int _, n;

inline bool check(int x) {
	F(i, 1, n) b[i] = (a[i] >= x);
	top = 0;
	F(i, 1, n) {
		if(top > 1 && !b[stk[top - 1]] && !b[stk[top]]) top--;
		else stk[++top] = i;
	}
	int ret = 0;
	F(i, 1, top) ret += (b[stk[i]] ? 1 : -1);
	return ret > 0;
}

signed main() {
//	freopen("saki.in", "r", stdin); 
//	freopen("saki.out", "w", stdout);
	
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
    cin >> _;
	while(_--) {
		cin >> n;
		F(i, 1, n) cin >> a[i];
		int L = 0, R = 1e9 + 1, ans = -1, mid;
		while(L <= R) {
			mid = (L + R) >> 1;
			if(check(mid)) ans = mid, L = mid + 1;
			else R = mid - 1;
		}
		cout << ans << '\n';
	}
    
	return 0;
}
```

被 @[Igunareo](https://www.luogu.com.cn/user/841638) 大神带飞喽。$6$ 题有 $4$ 题是他过的。

---

## 作者：a1a2a3a4a5 (赞：2)

似 AGC022E
# 思路：
二分 $x$，然后把 $<x$ 赋 $0$，$≥x$ 赋 $1$，然后判断是否可以消成一个 $1$，正确性显然。

猜一些性质：  
我们可以维护一个栈，从左往右向栈中加数字。
   - 栈顶 `00`：
     - 当前加 `0`，因为三个零肯定没一个零优，则把栈顶改成 `0`。
     - 当前加 `1`，那么 `01` 的值取决于后面那个数，所以把 `01` 都去了无影响，则把栈顶改成 `0`。
   - 栈顶 `01` 这是不可能的，因为我们会把 `01` 提前删掉（因为 `01` 取决于后面的数所以之前就删了）
   - 栈顶 `10` 同理
   - 栈顶 `11` ，那么发现此时稳了，只要把左右都删掉，那么最后在用 `11` 包圆就好了，所以遇到 `11` 直接赢！

`check()` 函数就这么写，最后输出二分答案就可以了。

[代码](https://www.luogu.com.cn/record/222610232)

---

## 作者：SudoXue (赞：1)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18976558)

很简单的一道题，不知道为什么有人会说难。

设阈值 $x$，把原数组映射成二值串 $b_i=[a_i\ge x]$。若存在一种合并顺序使最后剩下的数字 $\ge x$，则任何更小的阈值都同样可行，答案关于 $x$ 单调，于是用二分查找定位极大可行值。

一次判定时，从左到右扫 $b$ 并用栈维护当前序列：当栈顶连续出现两个 $0$ 时，必然可以立即与接下来的一个元素合并而不劣，于是提前弹掉一个零即可保证序列里永无三连零；扫完后统计栈内 $1$ 与 $0$ 的个数，因长度为奇数，若 $1$ 多于 $0$ 就能通过若干次 $1\,0\,1$ 或 $0\,1\,1$ 型合并把差距逐步扩大，最终留下 $1$，说明阈值成功。反之若 $0$ 不少于 $1$，剩余序列再怎么合并也无法让 $1$ 胜出，阈值失败。

时间复杂度 $O(n\log V)$，其中 $V$ 为值域。

[link](https://www.luogu.com.cn/record/223396260)

---

## 作者：Kendieer (赞：1)

link：[P13091](/problem/P13091)

---

## Solution

考虑二分结果值 $x$。

引入一个在二分中常见 trick，对于检查当前值 $mid$ 是否符合，我们可以贪心将 $\ge mid$ 的数变为 $1$，否则为 $0$。这样我们就可以快速得知其相对大小。

接下来就要想想如何确保最优消去 $0$，保留 $1$ 了。

1. 对于原有的连续的 $0$，我们可以将其贪心区间操作，使其最终长度为 $1$ 或 $2$。
2. 对于原有的连续的 $1$，我们肯定选择最后再消除。
3. 对于原有连续 $2$ 个 $0$ 以及 $1$ 个 $1$ 的情况，无论怎么消除，我们都只能变成 $0$，不过此时可以与后续的 $0$ 继续拼接。
4. 对于原有连续 $2$ 个 $1$ 以及 $1$ 个 $0$ 的情况，我们可以留到最后再消除。

当处理完整个 $01$ 序列后，最后剩余 $1$ 的数量比 $0$ 多则存在方案，否则不存在。

模拟的过程可以用栈，也可以直接记录连续个数，只要能确保最大化消掉 $0$ 即可。

## Code

码风应该不算差，个人习惯写函数写在 solve 里了。

``` cpp
#include<bits/stdc++.h>
#define endl '\n'
using ll=long long;
using namespace std;

void solve(){
    int n;cin >> n;
    vector<int> a(n+1);
    for (int i = 1;i <= n;i ++) cin >> a[i];
    int l = 1,r = 1E9+1;
    vector<bool> tmp(n+1);// check 时使用的 0,1 数组
    auto check = [&](int x)->bool{
        for (int i = 1;i <= n;i ++) tmp[i] = a[i] >= x;
        int c0 = 0,c1 = 0,combo = 0;
        for (int i = 1;i <= n;i ++){
            if (tmp[i]) {
                if (combo <= 1){
                    c1 ++,c0 += combo;
                    combo = 0;
                } else {
                    // 0 0 1 -> 0
                    combo = 1;
                }
            } else {
                combo ++;
                if (combo > 2) combo -= 2;
            }
        }
        c0 += combo;// 记得最后连续的 0 算上数量。
        return c1 > c0;
    };
    // 可能是冷门版本的二分，答案值域是 [l,r)
    while (r - l > 1){
        int mid = (l+r) >> 1;
        if (check(mid)) l = mid;
        else r = mid;
    }
    cout << l << endl;
}

signed main(){
    std::cin.tie(0),std::cout.tie(0);
    std::ios::sync_with_stdio(0);
    int T = 1;
    std::cin >> T;
    while(T--) solve();
    return 0;
}

/*
 | Code By Kendieer
 | Model Updated : 2025/06/25
 | Code With VSCode
*/
```

---

---

## 作者：liuchuliang666 (赞：0)

看见形如中位数的比较操作，就应该一下子想到二分答案转 $01$ 序列。

我们考虑二分答案，设二分的值为 $x$，那么将大于等于 $x$ 的位置赋为 $1$，否则赋为 $0$，我们只要判断能否将新序列消成只剩一个 $1$ 就行了。

具体的，我们考虑贪心完成这个消除过程，为了使 $0$ 尽可能地减少，我们碰到 $000$ 和 $001$ 就应该进行消除，这样一定不劣，这一操作可以用栈维护。

那么遍历一遍后，栈里面不会出现连续的 $0$，容易发现只要不是 $0$ 开头，$0/1$ 交替出现这种情况即可（因为你总可以找到一个 $0$ 周围的两个 $1$ 并消掉，随后必然会出现 $11$，出现 $11$ 直接大力合并就行了）。具体的，将 $0$ 赋为 $-1$ 求和，只要总和为正即可。

再附几道这种思想的题目：
- [P4093 [HEOI2016/TJOI2016] 序列](https://www.luogu.com.cn/problem/P4093)
- [P2839 [国家集训队] middle](https://www.luogu.com.cn/problem/P2839)
- [P11673 [USACO25JAN] Median Heap G](https://www.luogu.com.cn/problem/P11673)

本题代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int ll
typedef long long ll;
typedef const int cint;
#define mid (((l) + (r)) >> 1)
constexpr int MAXN = 1e6 + 10;
int n, a[MAXN], stk[MAXN], tp;
bool chk(cint x)
{
    tp = 0;
    for (int i = 1; i <= n; i++)
        if (tp > 1 && !stk[tp] && !stk[tp - 1])
            tp--;
        else
            stk[++tp] = a[i] >= x;
    int sum = 0;
    for (int i = 1; i <= tp; i++) sum += stk[i] ? 1 : -1;
    return sum > 0;
}
void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int l = 1, r = 1e9, ans = 1;
    while (l <= r)
    {
        if (chk(mid))
            ans = mid, l = mid + 1;
        else
            r = mid - 1;
    }
    cout << ans << endl;
}
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

---


# [GCJ 2009 #2] Stock Charts

## 题目描述

你正在撰写报社的年度经济总结，目前你决定用几张图表来展示不同股票在过去一年的表现。你已经决定要展示 $n$ 支不同股票在一年中 $k$ 个时刻的价格。

一支股票的简单走势图，就是在平面上连接 $(0, \text{price}_0)$、$(1, \text{price}_1)$、……、$(k-1, \text{price}_{k-1})$ 这些点，其中 $\text{price}_i$ 表示该股票在第 $i$ 个时刻的价格。

为了节省版面，你发明了“叠加图表”的概念。一个叠加图表是由一条或多条简单走势图组成的，展示多支股票的价格（每支股票画一条线）。为了避免混淆，叠加图表中的不同股票曲线不能相交或相触。

给定 $n$ 支股票在 $k$ 个时刻的价格，请你计算，至少需要多少张叠加图表，才能展示所有股票的价格。


## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $2 \leq k \leq 25$
- $0 \leq \text{price}_{i,j} \leq 1000000$

**小数据集**

- 时间限制：2 秒
- $1 \leq n \leq 16$

**大数据集**

- 时间限制：3 秒
- $1 \leq n \leq 100$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
3 4
1 2 3 4
2 3 4 6
6 5 4 3
3 3
5 5 5
4 4 6
4 5 4
5 2
1 1
2 2
5 4
4 4
4 1```

### 输出

```
Case #1: 2
Case #2: 3
Case #3: 2```

# 题解

## 作者：chen_zhe (赞：0)

本题解来自于[《挑战程序设计竞赛》](https://www.luogu.com.cn/training/813583)。

---

我们可以试想一下以股票为顶点，两支股票是否能画在同一幅图里来决定是否连边。例如，在由于线段相交或者相接而不能画在同一幅图里的股票之间连一条边。这样，这个问题就变成了求这个图的最小着色数。不过由于求解一般图的最小着色数是 NP 困难的，因此没有办法高效地求出答案。我们需要利用这个问题特有的性质来寻找其他解法。在这个问题中，如果两个折线图不相交，那么其中一条折线必然完全在另一条折线的上方。让我们来试着利用这条性质。

当股票 $i$ 可以画在股票 $j$ 的上方时，我们从顶点 $i$ 向顶点 $j$ 连一条边，便可以得到一个 DAG。考虑在这个图上的路径，容易发现在一条路径上的顶点可以全部画在一幅图中。因此原问题又可以进一步转化为如下问题：使用尽可能少的路径覆盖图中的所有顶点。

![](https://cdn.luogu.com.cn/upload/image_hosting/itcvll1b.png)

路径的条数和路径的起点个数相等。因此我们试着最小化路径起点的个数。由于对于不是起点的顶点一定都存在另外一个顶点作为路径上的前趋顶点，因此只需要最大化这样的顶点的个数就可以了。

我们考虑左右各有 $n$ 个顶点的二分图。在前面所建的图中，如果顶点 $i$ 有一条到顶点 $j$ 的边，则在二分图中从连接左边的顶点 $i$ 和右边的顶点 $j$ 。这个建图方法也可以看成是把前面的图中的每个顶点都拆成 2 个顶点得到的。

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/sdwt32h4.png)
:::

接下来考虑这个图的匹配。我们把匹配中各边对应的原图的边连接起来之后，就可以得到若干条路径，并且匹配中包含的边数和不是起点的顶点数相等。因此求出二分图的最大匹配，然后用 $n$ 减去这个值，就得到了最小路径覆盖的路径数。

① 在转化为二分图时，非常重要的一点是原有向图中不能包含圈。对于一般的有向图，如果尝试使用同样的算法，就会因为产生圈儿导致无法正确计算出结果。

```cpp
const int MAX_N = 100;
const int MAX_K = 25;

int N, K, P[MAX_N][MAX_K];

void solve() {
    V = N * 2;
    for (int i = 0; i < V; i++) G[i].clear();

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i == j) continue;
            bool f = true;
            for (int k = 0; k < K; k++) {
                if (P[j][k] >= P[i][k]) f = false;
            }
            if (f) add_edge(i, N + j);
        }
    }

    int ans = N - bipartite_matching();
    printf("%d\n", ans);
}
```

---


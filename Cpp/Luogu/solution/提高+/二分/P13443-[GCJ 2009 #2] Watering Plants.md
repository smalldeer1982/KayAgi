# [GCJ 2009 #2] Watering Plants

## 题目描述

在你的温室里，有若干株植物需要浇水。

每株植物占据一个圆形区域。任意两株植物不会重叠，也不会相互接触。

你打算购买两台喷洒器。每台喷洒器可以将半径为 $R$ 的圆形区域全部喷洒到水。

其中一台喷洒器将在早晨运行，另一台将在夜晚运行。为了让你满意，必须保证每株植物要么在早晨被完全浇水，要么在夜晚被完全浇水。也就是说，代表每株植物的圆形区域，必须被完全包含在两台喷洒器中的某一台（或两台）喷洒的圆形区域内。

给定每株植物的坐标和半径，请你求出能够放置两台喷洒器、使所有植物都被满足要求地浇水时，喷洒器所需的最小半径 $R$。喷洒器将被安装在天花板上，因此喷洒器的位置可以在植物的圆形区域内部。

## 说明/提示

**样例解释**

在第一个样例中，半径至少为 $7$ 且圆心在 $(20,15)$ 的喷洒器可以覆盖前两株植物。半径至少为 $3$ 的喷洒器可以覆盖位于 $(40,10)$ 的植物。

在第二个样例中，两台喷洒器中至少有一台的半径需要达到 $8$。注意，位于 $(30,10)$ 的植物必须被某一台喷洒器完全覆盖。

**限制条件**

- $1 \leq X \leq 1000$
- $1 \leq Y \leq 1000$
- $1 \leq R \leq 100$

**小数据集（5 分）**

- 时间限制：6 秒
- $1 \leq C \leq 10$
- $1 \leq N \leq 3$

**大数据集（25 分）**

- 时间限制：12 秒
- $1 \leq C \leq 30$
- $1 \leq N \leq 40$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
2
3
20 10 2
20 20 2
40 10 3
3
20 10 3
30 10 3
40 10 3```

### 输出

```
Case #1: 7.000000
Case #2: 8.000000```

# 题解

## 作者：chen_zhe (赞：0)

本题解来自于[《挑战程序设计竞赛》](https://www.luogu.com.cn/training/813583)。

---

整理一下问题中的重要信息，可以将原题简化为：

- 平面上有 $N$ 个圆。
- 要在平面上放置 2 个半径为 $R$ 的大圆，使得 $N$ 个圆都完全包含在至少一个大圆中。
- 求 $R$ 的最小值。

首先我们考虑一个简化后的问题，即只放置 1 个大圆的情况。在这种情况下应该如何求解呢？稍作思考就会发现要使 $R$ 最小，则一定满足下面三种情况的其中一种

1. 和三圆相内切。
2. 在径向相对位置和两圆内切。
3. 和某个圆重合。

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/y8e7i5ex.png)
:::

$b$ 和 $c$ 的情况比较容易计算，但是 $a$ 的情况应该如何计算圆心坐标呢？况且即使算出了圆心坐标，那么在 2 个大圆的情况下又应该如何做呢？把 $N$ 个圆分成 2 组的情况有 $2^N$ 种，无法一一尝试。不过我们发现，半径最小的大圆只有有限种情况，因此我们试着考虑每次从这些情况中选出 2 个圆，并判断是否能覆盖所有的圆。由于这样的圆只有 $O(N^3)$ 个，所以总算得到了一个比较可行的算法了。但是我们仍然需要解决前面遗留的一个很麻烦的问题：求和三圆相内切的圆。难道没有更容易的解法了吗？

如果 2 个半径为 $R$ 的圆可以覆盖所有的圆的话，半径为 $R' > R$ 的圆也可以。因此我们可以使用二分搜索。不过对于一个 $R$，怎么判断 2 个半径为 $R$ 的圆能否覆盖所有的圆呢？和之前一样，我们试着最小化需要考虑的圆的数量。由于现在圆的半径已经确定，所以可能会认为有无数种可能的圆。其实对于覆盖的圆的集合相同的大圆，我们只需要选择其中一个有代表性的就可以了。因此实际上只需要考虑如下两种情况就足够了

1. 和两圆内切。
2. 和某个圆同心。

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/b706z2w6.png)
:::

$a$ 的情况应该如何计算圆心的坐标呢？和圆心在 $(x, y)$ 半径为 $r$ 的圆相内切的圆的圆心的轨迹为圆心为 $(x, y)$，半径为 $R - r$ 的圆。这样，只需要计算两圆的交点就可以了，比起之前的方法简单了不少。

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/s0szcp31.png)
:::

而且，这种方法需要考虑的圆只有 $O(N^2)$ 个，即使算上二分搜索的复杂度，也完全可以在规定的时间内的出答案。

```cpp
typedef long long ll;

// 输入
int N;
int X[MAX_N], Y[MAX_N], R[MAX_N];

// 求出圆心在(x,y)半径为r的大圆能覆盖的圆的集合
ll cover(double x, double y, double r) {
    ll S = 0;
    for (int i = 0; i < N; i++) {
        if (R[i] <= r) {
            double dx = x - X[i], dy = y - Y[i], dr = r - R[i];
            if (dx * dx + dy * dy <= dr * dr) {
                S |= 1LL << i;
            }
        }
    }
    return S;
}
// 判断两个半径为r的大圆是否能覆盖所有的圆
bool C(double r) {
    vector<ll> cand;  // 一个大圆能覆盖的集合的列表
    cand.push_back(0);

    // 情况a
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < i; j++) {
            if (R[i] < r && R[j] < r) {
                // 计算两圆的交点
                double x1 = X[i], y1 = Y[i], r1 = r - R[i];
                double x2 = X[j], y2 = Y[j], r2 = r - R[j];
                double dx = x2 - x1, dy = y2 - y1;
                double a = dx * dx + dy * dy;
                double b = ((r1 * r1 - r2 * r2) / a + 1) / 2;
                double d = r1 * r1 / a - b * b;
                if (d >= 0) {
                    d = sqrt(d);
                    double x3 = x1 + dx * b;
                    double y3 = y1 + dy * b;
                    double x4 = -dy * d;
                    double y4 = dx * d;
                    // 考虑到可能产生误差，因此对i和j做特别处理
                    ll ij = 1LL << i | 1LL << j;
                    cand.push_back(cover(x3 - x4, y3 - y4, r) | ij);
                    cand.push_back(cover(x3 + x4, y3 + y4, r) | ij);
                }
            }
        }
    }
    // 情况b
    for (int i = 0; i < N; i++) {
        if (R[i] <= r) {
          cand.push_back(cover(X[i], Y[i], r) | 1LL << i);
        }
    }

    // 每次从可能的圆中取出2个，并判断是否能覆盖所有的圆
    for (int i = 0; i < cand.size(); i++) {
        for (int j = 0; j < i; j++) {
            if ((cand[i] | cand[j]) == (1LL << N) - 1) {
                return true;
            }
        }
    }
    return false;
}
```

正如在前一节中提到的那样，如果在几何问题中使用了浮点数，就需要注意浮点数产生的精度误差。例如在前面这个问题中，需要计算两个圆 $i$ 和 $j$ 相切的圆，然后判断是否每个圆都被完全覆盖了。这时 $i$ 和 $j$ 都应该是被完全覆盖的。但是由于精度误差，可能会导致这两个圆被判断为不能被完全覆盖。因此对 $i$ 和 $j$ 的判断需要特殊处理。一般来说，在对有误差的浮点数进行比较时，需要选取适当的较小的数 EPS，然后进行如下改写

- $a < b \rightarrow a + \text{EPS} < b$
- $a \leq b \rightarrow a < b + \text{EPS}$
- $a == b \rightarrow \text{abs}(a - b) < \text{EPS}$

不过需要注意的是，像这种在二分搜索中进行的比较的情况，如果在比较时使用了考虑误差的比较方法，得到的结果反而可能产生差错。虽然在本题中，产生 EPS 大小的误差也不会有什么问题，但是在某些问题中也有可能会导致较大的误差产生。

---


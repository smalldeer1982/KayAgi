# [KOI 2025 #1] 干草堆

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

一支带有力量 $P$ 的箭从数轴上的位置 0 向右方发射。在每个整数位置 $i$ ($1 \le i \le N$)，最多可以设置一个防御力为 $D_i$ 的干草堆。

当箭撞到干草堆时，如果箭的力量小于或等于该干草堆的防御力，箭会立即停止。反之，如果箭的力量大于防御力，箭的力量会减去 $D_i$，然后穿过干草堆继续飞行。

对于两个整数 $X, P$，我们将 $f(X, P)$ 的值定义为“为了使力量为 $P$ 的箭在位置 $X$ 或其左侧停止所需要安装的**干草堆的最小数量**”。如果无论如何安装都无法使箭停止，则定义 $f(X, P) = -1$。

请编写一个程序，对于 $Q$ 个整数对 $(X_j, P_j)$ ($1 \le j \le Q$)，分别求出 $f(X_j, P_j)$ 的值。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N, Q \le 300,000$
*   对于每个 $1 \le i \le N$ 的 $i$，都有 $1 \le D_i \le 10^9$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le X_j \le N$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le P_j \le 10^9$。

### 子任务

1.  (6 分) $N, Q \le 18$。
2.  (16 分) $N, Q \le 5000$。
3.  (18 分) 对于所有 $1 \le i \le N$ 的 $i$，$D_i \le 300$。
4.  (32 分) 对于所有 $1 \le i < N$ 的 $i$，$D_i \le D_{i+1}$。
5.  (28 分) $N=Q$，且对于所有 $1 \le j \le Q$ 的 $j$，$X_j=j$，且 $P_1 = P_2 = \cdots = P_Q$。
6.  (16 分) 对于所有 $1 \le j \le Q$ 的 $j$，$X_j = N$。
7.  (12 分) 对于所有 $1 \le i < j \le N$ 的 $i, j$，$D_i \ne D_j$。
8.  (22 分) 无附加限制条件。

## 样例 #1

### 输入

```
5 6
2 5 6 1 12
1 1
5 14
2 8
3 7
4 14
5 1```

### 输出

```
1
2
-1
2
4
1```

## 样例 #2

### 输入

```
5 5
3 6 1 1 10
1 10
2 10
3 10
4 10
5 10```

### 输出

```
-1
-1
3
3
1```

# 题解

## 作者：chen_zhe (赞：4)

### 子问题 1

尝试所有 $2^N$ 种安装或不安装每个干草堆的方案，在能够挡住箭的方案中，选择安装的干草堆数量最少的方案，并输出该数量作为答案。

### 子问题 2

在可以安装的干草堆中，优先安装防御力大的干草堆是更有利的。因此，将位置 $X$ 及之前的干草堆按防御力排序，从最大的防御力开始累加，直到和首次达到 $P$ 或以上时，返回此时安装的干草堆数量，即为最小数量。由于每个查询都需要对最多 $N$ 个元素进行排序，时间复杂度为 $O(QN \log N)$。

### 子问题 3

如果预先计算好按防御力分类的前缀和，就可以在 $O(1)$ 时间内得到位置 $X$ 及之前防御力为 $D$ 的干草堆数量。对于每个查询，从大的防御力值开始向下遍历，通过公式计算为了使防御力总和仍小于 $P$ 而可以额外安装的干草堆的最大数量。如果这个计算值大于或等于实际拥有的数量，就安装所有该防御力的干草堆；如果小于，那么安装该计算值加一的数量就是答案。这样做，每个查询的时间消耗与防御力的范围成正比，加上预处理前缀和的过程，可以用 $O(ND+QD)$ 的时间复杂度解决此子问题。

也可以不使用前缀和来解决此子问题。将查询按 $X$ 升序排序并离线处理，然后按输入顺序输出答案。这样，只需维护一个存储各防御力数量的计数数组，而无需使用前缀和，就可以像之前的解法一样解决问题。此时，如果对位置使用计数排序，就可以在没有对数因子的情况下，以 $O(N + QD)$ 的时间复杂度解决。

### 子问题 4

由于干草堆的防御力是按升序给出的，因此要在位置 $X$ 及之前用最少数量达到防御力 $P$，应该从最右端即位置 $X$ 的干草堆开始依次选择，直到总和达到 $P$ 或以上。

首先，如果总防御力小于 $P$，则任何配置都无法挡住箭，应输出 -1。否则，找到使最右侧 $K$ 个干草堆之和超过 $P$ 的最小 $K$，然后输出 $K+1$。这里的 $K$ 可以通过前缀和与二分搜索在 $O(\log N)$ 时间内求出，因此可以用 $O(N + Q \log N)$ 的时间复杂度解决此子问题。

### 子问题 5

这与小学组 3 题“稻草人”是同一个子问题。由于 $P$ 是相同的，一旦决定不安装某个干草堆，之后也不会再安装它。利用这一点，可以使用优先队列进行优化。详细解法请参考小学组 3 题“稻草人”的题解。

### 子问题 6

由于可以不考虑位置使用所有干草堆，因此可以对防御力 $D$ 排序后求解。排序后，问题就变得与子问题 4 相同了。

### 子问题 8

与子问题 3 的第二种解法类似，将所有查询按 $X$ 升序排序并一次性处理，就可以按 $X$ 递增的顺序计算答案。若使用线段树代替计数数组来存储防御力之和，就可以在 $O(\log N)$ 时间内求出可安装的干草堆中防御力不小于 $K$ 的干草堆的防御力总和。防御力值本身可能高达 $10^9$ 级别，非常大，但不同的值最多只有 $N$ 个，因此在坐标压缩后建立线段树，就可以在没有内存压力的情況下进行管理。

利用前面建立的线段树，可以快速求出每个查询所需选择的、使防御力总和不小于 $P$ 的干草堆的最小数量。具体来说，就是先找到一个最小的 $K$，使得防御力不小于 $K$ 的干草堆的总防御力不超过 $P$，然后再额外添加一些防御力为 $K-1$ 的干草堆来满足问题的要求。这样，每个查询耗时 $O(\log^2 N)$，总共可以在 $O(N \log N + Q \log^2 N)$ 的时间复杂度内解决整个问题。

更进一步，如果在每个线段树节点上存储（干草堆数量，防御力总和）的二元组，就可以通过从右子节点开始向下遍历的方式，找到累计和首次达到 $P$ 的位置，从而直接计算出最小数量。使用这个技巧，可以避免二分搜索，将查询优化到 $O(\log N)$。此外，由于问题的特性是求后缀值（从大到小的值），也可以在常数较小的树状数组（Fenwick Tree）上使用该技巧来进一步缩短时间。关于在 BIT 上的实现方法，请参考一同附上的示例代码。按照这种解法，整个问题也可以在 $O(N \log N + Q \log N)$ 的时间复杂度内解决。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
int n, m, a[300300], id[300300], ans[300300];
vector<array<int, 2>> v[300300];
 
ll t[300300];
int c[300300];

void update(int b, int val) {
    while(b <= n) t[b] += val, c[b]++, b += b & -b;
}

int find(int h) {
    int cnt = 0, b = 0;
    for(int i=19;i>=0;i--) if(b+(1<<i) <= n && h > t[b+(1<<i)]) b += 1<<i, h -= t[b], cnt += c[b];
    return b == n ? -1 : cnt+1;
}
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> m;
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=m;i++) {
        int x, h; cin >> x >> h;
        v[x].push_back({h, i});
    }
 
    vector<array<int, 2>> p(n);
    for(int i=1;i<=n;i++) p[i-1] = {a[i], i};
    sort(p.rbegin(), p.rend());
    for(int i=0;i<n;i++) id[p[i][1]] = i+1;
 
    for(int i=1;i<=n;i++) {
        update(id[i], a[i]);
        for(auto [h, id] : v[i]) ans[id] = find(h);
    }
 
    for(int i=1;i<=m;i++) cout << ans[i] << "\n";
}
```

---

## 作者：koukilee (赞：2)

对于位置 $X$ 前的稻草人能否抵挡住 $P$ 强度的箭，我们考虑贪心。 

尽可能选择防御力大的干草堆一定比选择防御力小的更优。

于是对于每一个询问 $(X_i, P_i)$，我们需要求出：至少取 $[1, X_i]$ 中防御力前 $k$ 大的干草堆，才能使得和大于等于 $P_i$。

发现明显具有单调性，于是可以二分查找这个 $k$。

如果不存在这个 $k$，那么答案就是 $-1$。

对于多个询问，我们考虑离线处理。

对于每一个 $i\in [1, n]$ 我们将 $D_i$ 插入值域线段树，然后在询问的时候二分线段树即可。

时间复杂度：$O(n\log^2 V)$，可以通过。

省略部分代码：

```c++
int main() noexcept{
	read (n, q);

	for (i32 i = 1; i <= n; i++)
		read (s[i]), maxx = std::max (maxx, s[i]);
	for (i32 i = 1; i <= q; i++) {
		i64 x, y; read (x, y);
		O[x].push_back ({y, i}); /*离线*/
	}
	
	for (i32 i = 1; i <= n; i++) {
		Tr.change (Tr.root, 1, maxx, s[i]); /*将 D_i 插入*/
		all[s[i]]++; /*统计一下每个数出现的次数*/
		
		for (auto it : O[i]) {
			i64 l = 1, r = maxx, pos = -1;
			
			while (l <= r) {
				i64 mid = (l + r) >> 1;
				if (Tr.query (Tr.root, 1, maxx, mid, maxx, 1) >= it.first)
					l = mid + 1, pos = mid;
				else r = mid - 1;
			} /*二分出第一个大于的点 pos*/
			
			if (pos == -1) ANS[it.second] = -1;
			else {
				i64 size = Tr.query (Tr.root, 1, maxx, pos + 1, maxx, 0), /*计算区间内数的数量*/
					need = it.first - Tr.query (Tr.root, 1, maxx, pos + 1, maxx, 1); /*计算区间内数的和*/
                /*pos 这个点可能有很多个，我们只取刚好超过 X_i 即可*/
				ANS[it.second] = size + std::ceil ((double) need / pos);
			}
		}
	}
	
	for (i32 i = 1; i <= q; i++)
		put (ANS[i]);
    return 0;
}
```

---

## 作者：luozejun_190813 (赞：0)

### 思路

这是上一题的加强版本，我们要处理多个询问。首先我们肯定是按照下标 $x$ 从前向后遍历得到答案，那么先要将询问离线，按 $x$ 从小到大排序。还是上一题的思想，我们每增加一个数，都希望数组从大到小排序，这样我们遍历数组，前缀和大于等于 $q$ 时下标就是答案。我们怎么高效实现这个操作？

用树状数组是很好的选择，他的单点修改，前缀查询很方便。首先我们要把数组离散化。

原数组：$2\ 5\ 6\ 3\ 9\ 1$

离散化：$5\ 3\ 2\ 4\ 1\ 6$

大数排前面。

注意：数值相同的要离散化为不同的值。

原数组：$5\ 1\ 7\ 3\ 3\ 9$

离散化：$4\ 1\ 5\ 2\ 3\ 6$
因为我们数组从大到小排序后相同的数也会在不同的下标，如果离散化为同一值那么会出错。这个和逆序数不一样，因为逆序数是严格的大于，所以 $6$ 不是逆序对，所以相同的数要离散化为同一值。

我用两个树状数组，一个用来记录插入的数，并快速查找前缀和。另一个记录插入数的个数。

每次询问都将 $x$ 前面的数插入，然后用二分查找刚好大于等于 $q$ 的位置，再用第二个树状数组查找有几个数，保存答案。


#### code

```
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define jiasu ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define lowbit(x) (x&(-x))
#define MAXN 500050
using namespace std;
ll n,Q,temp[300005],ans[300005],c[300005];
bool vis[300005];
struct Fenwick_Tree{
	ll tree[MAXN];
	void add(int x,int num){
	    while(x<=n){	    
	        tree[x]+=num;
	        x+=lowbit(x);
	    }
	}
	ll search(int x){	
	    ll re=0;
	    while(x){   
	        re+=tree[x];
	        x-=lowbit(x);
	    }
	    return re;
	}
}r1,r2;
struct point{ll x,num;}a[300005];
struct question{ll x,p,num;}q[300005];
bool cmp(point &s1,point &s2){return s1.x>s2.x;}
bool cmp2(question &s1,question &s2){return s1.x<s2.x;}
int main(){
cin>>n>>Q;
for(int i=1;i<=n;i++){
	cin>>c[i];
	a[i].x=c[i];
	a[i].num=i;
	temp[i]=a[i].x;
}
sort(a+1,a+1+n,cmp);
for(int i=1;i<=n;i++) temp[a[i].num]=i;
for(int i=1;i<=Q;i++) cin>>q[i].x>>q[i].p,q[i].num=i;
sort(q+1,q+1+Q,cmp2);
ll now=0;
for(int i=1;i<=Q;i++){
	while(now<q[i].x){
		now++;
		if(!vis[now]){
			r1.add(temp[now],c[now]);
			r2.add(temp[now],1);
			vis[now]=true;
		}
	}
	ll l=0,r=n+1;
	while(l+1<r){
		ll mid=(l+r)/2;
		if(r1.search(mid)>=q[i].p) r=mid;
		else l=mid;
	}
	if(r==n+1) ans[q[i].num]=-1;
	else ans[q[i].num]=r2.search(r);
}
for(int i=1;i<=Q;i++) cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：limingyuan333 (赞：0)

## 题意：
  给定一个序列，是每一个干草堆的权值。每次给定一支箭，穿过一个干草堆就把这支箭的值减少一个干草堆的值，干草堆可以自己选择装与不装，求可以让箭权值小于等于 $0$ 的可以安装的最少草堆的数量。
## 思路：
题目需要查询一个静态区间的前 $i$ 个位置中的 前 $k$ 大的元素满足它们累加起来的和要大于或等于给出的箭的威力，可以想到通过主席树来维护在 $l$ 到 $r$ 这个区间中的权值前 $k$ 小的权值的前缀和，数据比较大，需要离散化。但在这之后又出现了问题。我们发现找到的线段树上的位置并不是真正的满足要求的位置。举个例子 $3,6,1,1,10$，当威力为 $11$ 时，第 $4$ 个位置在线段树上查到位置是 $1$，但如果直接算是 $5-1+1=5$ 但是很明显应该是 $4$，但只要记录一下每个元素是否出现，记录元素出现个数的前缀和即可，代码很短。
~~~
#include<bits/stdc++.h>
#define int long long
#define rint register int
#define mp make_pair
#define fi first
#define se second
#define pii pair<int,int>
using namespace std;
const int MAXN=3e5+10;
int t[MAXN<<5],n,a[MAXN],b[MAXN],c[MAXN],tot,total,sum[MAXN<<5],pre[MAXN<<5],cnt,ch[MAXN<<5][2],rt[MAXN<<2];
unordered_map<int,int>p;
void update(int &p,int vp,int l,int r,int k,int w){
	p=++cnt;
	ch[p][0]=ch[vp][0];
	ch[p][1]=ch[vp][1];
	t[p]=t[vp]+1;pre[p]=pre[vp]+w;
	if(l==r)	return ;
	int mid=l+r>>1;
	if(k<=mid)	update(ch[p][0],ch[vp][0],l,mid,k,w);
	else	update(ch[p][1],ch[vp][1],mid+1,r,k,w);
}
int query(int p,int l,int r,int k){
	if(l==r)	return l;
	int val=pre[ch[p][0]];
	int mid=l+r>>1;
	if(total-val>=k)	return query(ch[p][1],mid+1,r,k+val);
	else	return query(ch[p][0],l,mid,k);
}
int query2(int p,int l,int r,int x,int y){
	if(x<=l&&r<=y) return t[p];
	int num=0;int mid=l+r>>1;
	if(x<=mid) num+=query2(ch[p][0],l,mid,x,y);
	if(y>mid) num+=query2(ch[p][1],mid+1,r,x,y);
	return  num;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	int q;cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i],sum[i]=sum[i-1]+a[i];
	sort(b+1,b+1+n);
	for(int i=1;i<=n;i++) {
		c[i]=lower_bound(b+1,b+1+n,a[i])-b+p[a[i]];p[a[i]]++;
	}
	for(int i=1;i<=n;i++) update(rt[i],rt[i-1],1,n,c[i],a[i]);
	while(q--){
		int id,power;cin>>id>>power;total=sum[id];
		if(sum[id]<power) cout<<-1<<'\n'; 
		else{
			int g=query(rt[id],1,n,power);
			cout<<query2(rt[id],1,n,g,n)<<"\n";
		}
	}
	return 0;
}

---

## 作者：xiazha (赞：0)

考虑询问离线，按照左端点排序，每次向平衡树里加一个点 $a_i$，并将 $x_j=i$ 的询问处理。

这里用的是 FHQtreap，维护子树权值和与个数和，我们处理询问时只需要看右孩子子树的权值和与目前 $p$ 的关系递归即可。

下面是核心代码，注意开 ```long long```：

```
void newnode(int &x,int v)
{
	x=++idx;tr[x].rnd=rand();
	tr[x].val=tr[x].sum=v;tr[x].size=1;
}
void pushup(int p)
{
	tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+1;
	tr[p].sum=tr[tr[p].l].sum+tr[tr[p].r].sum+tr[p].val;
}
void split(int p,int v,int &x,int &y)
{
	if(!p){x=y=0;return;}
	if(tr[p].val<=v) x=p,split(tr[x].r,v,tr[x].r,y),pushup(x);
	else y=p,split(tr[y].l,v,x,tr[y].l),pushup(y);
}
int merge(int x,int y)
{
	if(!x||!y) return x+y;
	if(tr[x].rnd<tr[y].rnd){tr[x].r=merge(tr[x].r,y),pushup(x);return x;}
	else{tr[y].l=merge(x,tr[y].l),pushup(y);return y;}
}
void insert(int v)
{
	int x,y,z;split(root,v,x,y);
	newnode(z,v);root=merge(merge(x,z),y);
}
int query(int rt,int p,int now)
{
	if(sum<p) return -1;
	else if(tr[rt].val>=p) return now+1;
	else if(tr[tr[rt].r].sum+tr[rt].val<p) return query(tr[rt].l,p-tr[tr[rt].r].sum-tr[rt].val,now+tr[tr[rt].r].size+1);
	else if(tr[tr[rt].r].sum>=p) return query(tr[rt].r,p,now);
	else return now+tr[tr[rt].r].size+1;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>q[i].x>>q[i].p,q[i].id=i;
	sort(q+1,q+m+1,cmp);
	int z=0;
	for(int i=1;i<=n;i++)
	{
		insert(a[i]);sum+=a[i];
		while(z<m&&q[z+1].x==i) z++,q[z].ans=query(root,q[z].p,0);
	}
	sort(q+1,q+m+1,cmp1);
	for(int i=1;i<=m;i++) cout<<q[i].ans<<"\n";
	return 0;
}
```

---

## 作者：chenruikai (赞：0)

### 题意
抽象表述：给定数组 $D_i$。每次询问 $\operatorname{f}(X_i,P_i)$，表示在位置 $X_i$ 前最少要多少元素和大于等于 $P_i$。
### 解
考虑单次询问。

显然，将 $X$ 前加数越大越好，即将其中最大的几个数求和。具体到做法，将 $X$ 之前的数排序，从大到小一个个加即可。复杂度 $O(QN\log N)$。

注意到以下几点：
1. 问题一次性给出，非强制在线；
2. 每次向已排序的数组中加入原数组无需重新排序。

前者告诉我们可以离线，后者告诉我们可以使用增量构造（可能不叫这个名）。

具体到做法，可以先将问题按照 $X$ 排序，后每次向前面的已经排好序的数组中用冒泡（题解中就没怎么见到过）加入，其余如上。复杂度 $O(Q\log Q+QN+N^2)$。（一般人也不会这么想吧……）

到这里可能会（其实不会）蒙逼一下。我们发现向已排好序的数组中插入显然有很大的优化空间。从暴力的开始，首先很明显可以开平衡树，不多说了，相信这题没几个人才会直接开这个吧……

可以发现，已排完序的数组中至多只有 $N$ 种元素，故可以离散化，那就没必要用平衡树了，可以使用线段树，每次把数字加在离散化后对应的位置上维护和即可。

当然，由于只涉及求和，用树状数组更加便捷。

至此，我们已经有了 $O(Q\log Q+N\log N+Q\log^2N)$ 的算法。

可进一步优化。由经验 ~~Farm John~~ 可知，在线段树或树状数组里是可以二分的，线段树对应二分，树状数组对应倍增。

### code
```cpp
/*
sort que by x{increase}
for i : [0<=<len]
{
    add num[i] to tree_array;
    if(que)
    {
        ans = all - tree_array.check(last <= sum - que.val).rank{from 1};
    }
}
*/
#include <bits/stdc++.h>
using namespace std;

long long qread()
{
    long long res = 0;char ch = getchar();
    for(;ch < '0' || ch > '9';ch = getchar());
    for(;ch >= '0' && ch <= '9';ch = getchar())
        res = (res << 1) + (res << 3) + ch - '0';
    return res;
}
#define maxn 300005
#define maxq 300005
#define maxs 262144
struct question{int pos;long long num;int bef;};
#define lowbit(a) ((a) & (-(a)))
long long num[maxn];int len , qnum;
question que[maxq];int ans[maxq];
bool cmpque(question a , question b)
    {return a.pos < b.pos;}
int sortnum[maxn] , sortmem[maxn];
long long preof[maxn + 1];int rankof[maxn + 1];
bool cmpnum(int a , int b){return num[a] < num[b];}
void add(int pos , long long val)//pos => rank
    {for(;pos <= len;pos += lowbit(pos))preof[pos] += val , rankof[pos]++;}
int check(long long val)
{
    int pos = 0 , res = 0;
    for(int s = maxs;s;s >>= 1)
        if(pos + s <= len && preof[pos + s] <= val)
            {pos += s;val -= preof[pos];res += rankof[pos];}
    return res;
}
int main()
{
    len = qread();qnum = qread();
    for(int i = 0;i < len;i++)num[i] = qread();
    for(int i = 0;i < qnum;i++)
        {que[i].pos = qread() - 1;que[i].num = qread();que[i].bef = i;}
    sort(que , que + qnum , cmpque);
    for(int i = 0;i < len;i++)sortmem[i] = i;
    sort(sortmem , sortmem + len , cmpnum);
    for(int i = 0;i < len;i++)sortnum[sortmem[i]] = i + 1;
    long long sumof = 0;int cou = 0;
    for(int i = 0 , mat = 0;i < len && mat < qnum;i++)
    {
        sumof += num[i];cou++;add(sortnum[i] , num[i]);
        for(;mat < qnum && que[mat].pos == i;mat++)
            ans[que[mat].bef] = 
                que[mat].num <= sumof ? cou - check(sumof - que[mat].num) : -1;
    }
    for(int i = 0;i < qnum;i++)printf("%d\n" , ans[i]);
    return 0;
}
```
玥玥月月如今朝。

---

## 作者：MnZnOIer (赞：0)

### 解题思路
首先，所有的干草堆都是一个干草堆，同时防御力不同，所以我们要令使用的干草堆最少，就是要令使用的干草堆的防御力尽量大。我们每次从大往小取目前能用的干草堆，然后愉快的超时了。我们会发现如果想要进一步优化，当前的位置变来变去肯定不好做，那么考虑离线下来处理。现在我们的问题就变成了：动态加入一些干草堆，求从大往小加最少要加几个使得和大于 $P$。你会发现这个东西可以用平衡树维护，动态插入，然后在平衡树上查找答案。平衡树刚好可以满足有序插入和二叉树结构，便于查找。

说句闲话：由于平衡树常数太大，跑得比某位同学的值域分块要慢。另外，听说这道题还能用树状数组做。

### 代码部分
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
int n, q, a[N], rt, cnt;
struct Query{int x, p, id, ans;}b[N];
struct FHQ_Treap{int l, r, k, v, siz, sum;}t[N << 1];
int New (int vv)
{
	t[++ cnt].v = vv;
    t[cnt].sum = vv; 
	t[cnt].k = rand ();
	t[cnt].siz = 1;
	return cnt;
}
void push_up (int x)
{
    t[x].siz = t[t[x].l].siz + t[t[x].r].siz + 1;
    t[x].sum = t[x].v + t[t[x].l].sum + t[t[x].r].sum;
}
void split (int pos, int x, int &l, int &r)
{
	if (! pos)return l = r = 0, void ();
	if (t[pos].v <= x)
	{
		l = pos;
		split (t[l].r, x, t[l].r, r);
	}
	else
	{
		r = pos;
		split (t[r].l, x, l, t[r].l);
	}
	push_up (pos);
}
int merge (int l, int r)
{
	if (! l || ! r)return l | r;
	int pos;
	if (t[l].k <= t[r].k)t[pos = l].r = merge (t[l].r, r);
	else t[pos = r].l = merge (l, t[r].l);
	push_up (pos);
	return pos;
}
void Insert (int val)
{
    int l, r;
    split (rt, val - 1, l, r);
    rt = merge (merge (l, New (val)), r);
}
int Search (int x, int p)
{
    if (! x || p <= 0)
        return 0;
    if (t[t[x].r].sum >= p) 
    	return Search (t[x].r, p);
	return Search (t[x].l, p - t[t[x].r].sum - t[x].v) + t[t[x].r].siz + 1;
}
signed main ()
{
    ios::sync_with_stdio (0);
    cin.tie (0);
    cout.tie (0);
    srand (time (0));
    cin >> n >> q;
    for (int i = 1; i <= n; ++ i)
        cin >> a[i];
    for (int i = 1; i <= q; ++ i)
    {
        cin >> b[i].x >> b[i].p;
        b[i].id = i;
    }
    sort (b + 1, b + q + 1, [](Query a, Query b){return a.x < b.x;});
    int j = 1, s = 0;
    for (int i = 1; i <= n; ++ i)
    {
        Insert (a[i]);
        while (i == b[j].x && j <= q)
        {
            if (t[rt].sum < b[j].p)
                b[j].ans = -1;
            else
                b[j].ans = Search (rt, b[j].p);
            ++ j;
        }
    }
    sort (b + 1, b + q + 1, [](Query a, Query b){return a.id < b.id;});
    for (int i = 1; i <= q; ++ i)
        cout << b[i].ans << '\n';
    return 0;
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

考虑前面它的弱化版我们可以通过从左到右存储元素计算，那么这题先考虑离线询问按 $x$ 排序，这样可以从左到右扫每个元素。应用弱化版中的结论，我们只会用到最大的若干个元素，所以考虑把每个元素按照从小到大的顺序放到一个线段树里面，初始的时候赋值为 $0$，扫到了就赋值为 $d_i$，这样相当于在线段树上找一个尽可能短的后缀使总和超过 $p$，使用线段树做到单词 $O(\log n)$，总复杂度视 $n,q$ 同阶为 $O(n\log n)$。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e5+10;
struct query
{
	int x,p,id;
}qry[N];
int id[N],ans[N],rk[N],cnt[N<<2],sum[N<<2],n,a[N];
void upd(int k,int c,int s=1,int t=n,int p=1)
{
	if(s==t)
	{
		sum[p]=c;
		cnt[p]=1;
		return;
	}
	int m=s+t>>1;
	if(k<=m) upd(k,c,s,m,p<<1);
	else upd(k,c,m+1,t,p<<1|1);
	sum[p]=sum[p<<1]+sum[p<<1|1];
	cnt[p]=cnt[p<<1]+cnt[p<<1|1];
}
int qcnt(int k,int s=1,int t=n,int p=1)
{
    if(s==t) return cnt[p];
	if(sum[p]<k) return cnt[p];
    int m=s+t>>1;
	if(sum[p<<1|1]>=k) return qcnt(k,m+1,t,p<<1|1);
	else return qcnt(k-sum[p<<1|1],s,m,p<<1)+cnt[p<<1|1];
}
signed main()
{
	int q;
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i],id[i]=i;
	for(int i=1;i<=q;i++) cin>>qry[i].x>>qry[i].p,qry[i].id=i;
	sort(id+1,id+n+1,[](int x,int y){return a[x]<a[y];});
	for(int i=1;i<=n;i++) rk[id[i]]=i;
	sort(qry+1,qry+q+1,[](query i,query j){return i.x<j.x;});
	int pt=1;
	for(int i=1;i<=q;i++)
	{
		for(int j=pt;j<=qry[i].x;j++) upd(rk[j],a[j]);
		pt=qry[i].x+1;
		ans[qry[i].id]=(qry[i].p>sum[1]?-1:qcnt(qry[i].p));
	}
	for(int i=1;i<=q;i++) cout<<ans[i]<<'\n';
}

---

## 作者：ran_qwq (赞：0)

根据贪心，肯定要放尽量大的稻草人。按位置扫描线，设当前的防御力排好序的序列为 $\{a_i\}$，我们要找最大的 $j$ 使得 $\sum\limits_{k=j}^ia_k\ge P$。

经典问题，在值域线段树上二分即可。维护当前区间的数量 $ct$ 和总和 $sm$，如果 $P\le sm$ 就往右儿子走，否则就往左儿子走，同时 $P$ 减去 $sm$，答案加上 $ct$。当然你为了常数小也可以写树状数组上二分。

[这是代码。](https://www.luogu.com.cn/paste/5zv1nmrb)

---

## 作者：lilong (赞：0)

首先把所有询问离线下来，存到对应的下标内。接着对所有的 $d$ 降序排序并确定**唯一的排名**（相同的数也要用不同的排名）。维护一棵线段树（区间和以及数的个数），从小到大枚举每个位置 $i$，将 $d_i$ 加到其排名对应的位置，之后处理这个位置上的询问，直接在线段树上二分即可。时间复杂度 $O((n+q)\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define N 500010
#define int long long
using namespace std;
vector<pair<int,int> >Q[N];
struct T{
    int sum,siz;
}t[N*4];
struct A{
    int v,id;
}b[N];
bool cmp(A x,A y){
    if(x.v!=y.v)return x.v>y.v;
    return x.id<y.id;
}
int n,m,a[N],ans[N],rk[N];
void pushup(int u){
    t[u].sum=t[u<<1].sum+t[u<<1|1].sum;
    t[u].siz=t[u<<1].siz+t[u<<1|1].siz;
}
void update(int u,int l,int r,int p,int v){
    if(l==r){
        t[u].sum+=v;
        t[u].siz++;
        return;
    }
    int mid=(l+r)>>1;
    if(p<=mid)update(u<<1,l,mid,p,v);
    if(p>mid)update(u<<1|1,mid+1,r,p,v);
    pushup(u);
    return;
}
int query(int u,int l,int r,int v){
    if(l==r)return t[u].siz;
    int mid=(l+r)>>1;
    if(t[u<<1].sum>=v)return query(u<<1,l,mid,v);
    else return t[u<<1].siz+query(u<<1|1,mid+1,r,v-t[u<<1].sum);
}
signed main(){
    int x,p;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i].v=a[i],b[i].id=i;
    }
    sort(b+1,b+n+1,cmp);
    for(int i=1;i<=n;i++)
        rk[b[i].id]=i;
    for(int i=1;i<=m;i++){
        cin>>x>>p;
        Q[x].push_back(make_pair(p,i));
    }
    for(int i=1;i<=n;i++){
        update(1,1,n,rk[i],a[i]);
        for(auto it:Q[i]){
            if(t[1].sum<it.first)ans[it.second]=-1;
            else ans[it.second]=query(1,1,n,it.first);
        }
    }
    for(int i=1;i<=m;i++)
        cout<<ans[i]<<'\n';
    return 0;
}
```

---


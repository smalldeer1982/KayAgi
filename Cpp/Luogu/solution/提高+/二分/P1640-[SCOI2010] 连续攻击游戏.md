# [SCOI2010] 连续攻击游戏

## 题目描述

lxhgww 最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有 $2$ 个属性，这些属性的值用 $[1,10000]$ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww 遇到了终极 boss，这个终极 boss 很奇怪，攻击他的装备所使用的属性值必须从 $1$ 开始连续递增地攻击，才能对 boss 产生伤害。也就是说一开始的时候，lxhgww 只能使用某个属性值为 $1$ 的装备攻击 boss，然后只能使用某个属性值为 $2$ 的装备攻击 boss，然后只能使用某个属性值为 $3$ 的装备攻击 boss……以此类推。现在 lxhgww 想知道他最多能连续攻击 boss 多少次？

## 说明/提示

对于 $30\%$ 的数据，保证 $N \le 10^3$。

对于 $100\%$ 的数据，保证 $N \le 10^6$。

## 样例 #1

### 输入

```
3
1 2
3 2
4 5
```

### 输出

```
2```

# 题解

## 作者：Windows_XP (赞：56)

# ~~这题为什么要二分图呢？~~

太大了好像划不住

这题我们bfs一下就好了。二分图又不好写，还慢的要死，~~还丑~~，不如~~好写~~稳定的bfs。

说是bfs其实就是乱搞。

以下几段通俗易懂~~可爱~~面向萌新。大佬可以直接跳过看总结。

一个装备只能提供一个属性。我们把两个属性值当做两个点来连线，那么我们可以感性地想象这条线上有一只猫，这只猫要不然趴在一头，要不然趴在另一头，哪个值被覆盖代表着这个装备提供哪个属性值。如果将属性值来这样建一张图，对于每一个连通图，因为每一只猫都能覆盖旁边的一个点，我们可以很轻松的想象到，如果说这个图中有m条边，n个点，那么一定可以有min(n,m)个点被覆盖。

除了一个树以外，图上的边数一定大于等于点数。显然吧！那么说明图中的所有点都是可以被猫猫搞到的，树中有且只有一个点无法被覆盖。根据贪心的思想我们当然是让那个最大的值的那个点无法被覆盖。我们可以用bfs 通过对遍历到的边数和点数的比较 来维护这个过程，(不知道怎么维护可以看代码我会尽量的！写的非常！详细  ~~毕竟我想过审核~~)

而对于树中最大的点如何处理呢？每一次bfs都会遍历整个连通块，其他的bfs是够不到这个最大点的。所以最大的那个点无法被其他的bfs覆盖。那么我们将它的状态视为cant，即它绝对无法被覆盖。

没有与任何点相连的点，也可以看做一个树。

于是我们可以从1开始，向10000遍历。每一个值都是属性值，将每一个值都看做点。如果当前这个点没有被bfs过就bfs它 ~~废话~~，要不然就判断是否是cant点。

 ## 总结在这
 总结：将属性值连边，每一个强联通分量内的所有点都可选，每一个树内最大点不可选，用bfs判断。根本就不用缩点。(并查集可能会更快？我写不明白..)每一条边与每一个点都至多会被判断一次，上界复杂度O(n+m) (要是2就cant了，那么当然后面全不用判了)。
 
 多简单...

说实话，处理结果的思路与楼下用并查集的大佬们的思路很像，但是又略有不同。严格地说并不是同一种方法。

代码！
```cpp
#include <bits/stdc++.h> //我就好这一口
#define rap(i,s,n) for(int i=s;i<=n;i++)//同上
#define drap(i,s,n) for(int i=s;i>=n;i--)//同上
#define N 23333
#define M 2333333
using namespace std;
char xB[1<<15],*xS=xB,*xTT=xB;//读优 原因同上
#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)
#define isd(c) ((c>='0'&&c<='9')||(c=='-'))
template<typename T>
inline void rd(T & xaa){
    char xchh; T f=1; xaa=0; while(xchh=getc(),!isd(xchh));
    if(xchh=='-'){f=-1; xchh=getc();} xaa=xchh-'0';
    while(xchh=getc(),isd(xchh)) xaa=xaa*10+xchh-'0';
    xaa*=f; return;
}
int m,to[M],nxt[M],head[N],cnt;//存图
bool vis[N],cant[N];//bfs用的
void add(int a,int b){cnt++; to[cnt]=b; nxt[cnt]=head[a]; head[a]=cnt; return;}
bool bfs(int k){//返回是否能覆盖
	//printf("bfs(%d)\n",k); 
    if(!vis[k]){
        vis[k]=1; int maxp=k,nump=0,nume=0; queue<int>q; q.push(k);
        //maxp:涉及到的最大的点。设成0不会影响结果。
        //nump:点数 nume:边数
        while(!q.empty()){
            int u=q.front(); q.pop(); maxp=max(maxp,u); nump++;
            for(int i=head[u];i;i=nxt[i]){nume++; if(!vis[to[i]]) vis[to[i]]=1,q.push(to[i]);}
        }
        //每bfs一个点都让nump++(显然),每碰到一条边都让nume++。
        //但是因为是双向图，每条边都碰到了两遍。所以/2
        nume>>=1; if(nume<nump) cant[maxp]=1;
        //rap(i,1,maxp) printf("%d ",vis[i]); printf("\n");
    	//rap(i,1,maxp) printf("%d ",cant[i]); printf("\n");
    }
    return (!cant[k]);//判断当前点是否不可覆盖(其实只有它自己孤零零不和其他点相连才是0...
}
int main(){
    //freopen("1640.in","r",stdin);
    rd(m); int a,b; rap(i,1,m){rd(a),rd(b); add(a,b); add(b,a);}
    int k=1; while((vis[k]&&!cant[k])||bfs(k)) k++; printf("%d\n",k-1);
    //注意while中的判断。只有vis过才能判断cant值，否则cant值没有意义。没有vis过就会bfs。
    return 0;
}
```

点个赞吧 ^^（用一个PAFF酱的表情）

---

## 作者：magolor (赞：45)

是的，我来解释一下二分图的建图：

每件装备只能用一次，如果把攻击序列建成点，就是装备和攻击顺序的匹配。

比如属性值是3和5，那么这件装备要么在3位置要么在5位置被使用。

当然，按攻击顺序开始匹配，一旦匹配不成功，根据题意就必须中止。


还有，每次memset太慢了，用时间戳id。










```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1010000
#define MAXM 4040000
#define X(n) (n+10000)
struct Edge
{
    int to,nex;
    Edge(){}
    Edge(int _to, int _nex):to(_to),nex(_nex){}
};
Edge e[MAXM+5];
int first[MAXN+5], book[MAXN+5], match[MAXN+5], N, tot, id, op;
void Add(int a, int b)
{
    e[tot] = Edge(b,first[a]);
    first[a] = tot++;
    return;
}
bool DFS(int x)
{
    for(register int u = first[x], v; u+1; u = e[u].nex)
        if(book[v=e[u].to]-id)
        {
            book[v] = id;
            if(!match[v] || DFS(match[v]))
            {
                match[x] = v, match[v] = x;
                return true;
            }
        }
    return false;
}
int Hungary()
{
    int ans = 0;
    for(register int i = id = 1; i <= 10000; i++, id++)
        if(DFS(i))
            ans++;
        else
            break;
    return ans;
}
int main()
{
    scanf("%d",&N), memset(first,-1,sizeof(first));
    for(register int i = 1, j; i <= N; i++)
        for(j = 0; j < 2; j++)
            scanf("%d",&op), Add(op,X(i)), Add(X(i),op);
    printf("%d\n",Hungary());
     return 0;
}
```

---

## 作者：command_block (赞：25)

### 这道题从网络流的角度来想，是很神奇的。

它告诉我们一个技巧：玄学复杂度分析（**按特定顺序退流/增广**）

首先建立模型。

满足**连续**攻击条件不太好搞，我们转化成判定性问题。

即“能否连续攻击limit次”

(1)每个物品只能使用一次

(2)攻击->价值(流)

那么可以这样建图：

分为两层,一层是每个物品,第二层是按属性值排序的每次攻击。

(1)从S向代表每个物品的点连一条边，容量为1(每个物品只能使用一次);

(2)从每个物品向（属性1）（属性2）两个第二层的点连边。

(3)每个第二层的点向T连边，容量为1(每种属性只攻击一次)

这样子，我们成功的使用一个$O(\text{网络流}*log(10000))$的算法解决了本题。

无疑是会TLE的。

我们知道在跑网络流的时候，增广的路径是玄学。

根据**人类智慧**，S的出边多，T的出边少，从S开始找可能会慢。

那我们**把整个图反向**，这样最大流不变。

我们从原来的T开始增广的话，根据**人类智慧**，增广顺序是可以随意指定的，这样并不会被卡。

于是可以按照增广属性1，属性2，属性3……的顺序。

然后，我们发现，这就相当于我们从小到大枚举答案，然后利用上一次的残量网络来增广（具体见代码）。

我们知道，要么增广出1，要么无法增广，**不会出现拆前面的流的情况**。

这样子，复杂度就从$O(\text{网络流}*log(10000))$变为了$O(\text{网络流})$!

~~玄学~~

顺便说一句，我使用vector建边MLE，然后使用了一个比较神奇的建边方法。

还有，我懒得写dinic，于是乎写了FF最大流（FF过百万吼！）。

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<vector>
#define Maxn 1010000
using namespace std;
int n,m,sink,em,ans;
struct Line
{int g,l,b;}
l[Maxn*6];
int s[Maxn+100];
int cnt,e[Maxn+100];
int dfs(int num,int val)
{
  if (num==sink)return val;
  e[num]=cnt;
  int flow,v;
  for (int i=s[num-1];i<s[num];i++)
   if (l[i].l&&e[v=l[i].g]!=cnt){
    flow=dfs(v,min(val,l[i].l));
    if (flow){
      l[i].l-=flow;
      l[l[i].b].l+=flow;
      return flow;
    }
  }return 0;
}
void addLine(int f,int t,int c)
{
  l[s[f]].b=s[t];
  l[s[t]].b=s[f];
  l[s[f]].g=t;
  l[s[f]].l=c;
  l[s[t]].g=f;
  l[s[t]].l=0;
  s[t]++;s[f]++;
}
struct Data
{int a,b;}
a[1000500];
int main()
{
  scanf("%d",&n);
  sink=n+10010+1;
  //点1~n是物品，点n+1~n+10000是属性值
  //sink是汇，没有源
  for (int i=1;i<=n;i++){
    scanf("%d%d",&a[i].a,&a[i].b);
    s[sink]++;s[i]=3;
    s[n+a[i].a]++;
    s[n+a[i].b]++;
  }for (int i=2;i<=sink;i++)s[i]+=s[i-1];
  for (int i=sink;i>=0;i--)s[i+1]=s[i];
  for (int i=1;i<=n;i++)addLine(i,sink,1);
  for (int i=1;i<=n;i++){
    addLine(n+a[i].a,i,1);
    addLine(n+a[i].b,i,1);
  }cnt=1;
  for (int i=1;i<=10010;i++,cnt=i)
   if (!dfs(n+i,1))
    {printf("%d",i-1);break;}
  return 0;
}
```

~~突然想到，FF跑二分图匹配不就是匈牙利吗？~~

---

## 作者：⚡LZSY01_XZY⚡ (赞：24)

## 一道思维题
先安利我写的blog：[$\color{#ff4081}\texttt{二分图浅析}$](https://lzsy01-xzy-blog.blog.luogu.org/XZY-1)。
***
我第一下看到这题，脑袋里有两个想法：
- dfs遍历，枚举能到达的点。
- 二分图，求最大匹配。
***

## 这两种算法我都试了一下。
### dfs：
$code:$

```cpp
#include <cstdio>
#include <bitset>
using namespace std;

int read()
{
	int x=0,f=1;char c=getchar();
	while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
	return x*f;
}

const int MAXN=1000005;
int n,ans;
bitset<MAXN> vis;
int a[MAXN],b[MAXN];

void dfs(int now)
{
	if (now>ans)ans=now;
	for (int i=1;i<=n;i++)
		if (!vis[i]&&(a[i]==now+1||b[i]==now+1))
		{
			vis.set(i);
			dfs(now+1);
			vis.reset(i);
		}
}

int main()
{
	n=read();
	for (int i=1;i<=n;i++)
		a[i]=read(),b[i]=read();
	for (int i=1;i<=n;i++)
		if (a[i]==1||b[i]==1)
		{
			vis.set(i);
			dfs(1);
			vis.reset(i);
		}
	printf("%d\n",ans);
	return 0;
}
```

代码特别短，但弄不到$100$分:
![](https://s2.ax1x.com/2019/04/21/Ei7Wh8.png)
~~所以大家还是老老实实搞二分图吧。~~
## 二分图
不懂二分图，可以来[这里](https://lzsy01-xzy-blog.blog.luogu.org/XZY-1)看一下,里面详细解释了二分图，即用网络流求解最大匹配。  
二分图的题目重点在建图，这道题目，由于每个武器只能用一次，每个物品只有一个有用的属性值，每个属性值也只对应一个有用的物品。于是，~~谁都能~~想到把属性值和物品连边，计算最大匹配。
### 建图：
```cpp
inline void init()
{
    memset(head,-1,sizeof(head));
    int a,b;n=read();
    for (int i=1;i<=n;i++)
    {
        a=read();b=read();
        Addedge(a,i);Addedge(b,i);
    }
}
```
### $work:$
由于要是连续的属性值，故从$1$开始匹配，直到匹配不了为止。
```cpp
int ans=0;
    for (int i=1;i<=10000;i++)
    {
        now++;
        if (dfs(i))ans++;
        else break;
    }
    printf("%d\n",ans);
```
总代码：
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
using namespace std;

int read()
{
    int x=0,f=1;char c=getchar();
    while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
    while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
    return x*f;
}

const int MAXN=1000005;
const int MAXM=100005;
int n,id,now;

struct edge
{
    int v,nx;
}set[4*MAXN];
int head[MAXM],chk[MAXM],match[MAXN];

inline void Addedge(int u,int v)
{
    id++;set[id].v=v;set[id].nx=head[u];
    head[u]=id;
}

inline void init()
{
    memset(match,-1,sizeof(match));
    int a,b;n=read();
    for (int i=1;i<=n;i++)
    {
        a=read();b=read();
        Addedge(a,i);Addedge(b,i);
    }
}

inline bool dfs(int u)
{
    int v;
    for (int k=head[u];k>0;k=set[k].nx)
    {
        v=set[k].v;
        if (chk[v]!=now)
        {
            chk[v]=now;
            if ((match[v]==-1)||dfs(match[v]))
            {
                match[v]=u;return true;
            }
        }
    }
    return false;
}

int main()
{
    init();
    int ans=0;
    for (int i=1;i<=10000;i++)
    {
        now++;
        if (dfs(i))ans++;
        else break;
    }
    printf("%d\n",ans);
    return 0;
}
```
效率可观：
![](https://s2.ax1x.com/2019/04/21/EiqCY6.png)

---

## 作者：梧桐灯 (赞：17)

第一眼看到此题是二分图匹配，但是兴冲冲的交上去代码后，发现T了2个点

代码：

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
inline void read (int& s) {
	s = 0;
	static char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c & 15), c = getchar ();
	return ;
}

const int N = 10003, M = 1000003;
int n;
vector <int> c[N];
int d[M], vis[M];

bool Find (const int x) {
	int i, y, k = c[x].size ();
	for (i = 0; i < k; ++i) {
		y = c[x][i];
		if (!vis[y]) {
			vis[y] = 1;
			if (!d[y] || Find (d[y])) {
				d[y] = x;
				return 1;
			}
		}
	}
	return 0;
}

int main () {
	read (n);
	int i, x, y; for (i = 1; i <= n; ++i) {
		read (x), read (y);
		c[x].push_back (i);
		c[y].push_back (i);
	}
	for (i = 1; i < N; ++i) {
		memset (vis, 0, sizeof (vis));
		if (!Find (i)) {
			printf ("%d\n", i - 1);
			return 0;
		}
	}
	return 0;
}
```

嗯？？

一开始以为是vector常数大，但开O2后……

#### 依然TLE

开Ofast

### TLE

![？？？](https://b-ssl.duitang.com/uploads/item/201707/31/20170731092533_uENGa.thumb.700_0.jpeg)

仔细想想，终于发现问题：

是[memset0](https://www.luogu.org/space/show?uid=53495)的锅！

啊不是，是memset (vis, 0, sizeof (vis));

由于每一次find都要清空&&值域上百万，所以会T。

改过后就能轻松AC了。

具体实现：设一个变量now，如果vis里值为now则已访问过，若不是则赋值为now向下递归

代码：

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
inline void read (int& s) {
	s = 0;
	static char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c & 15), c = getchar ();
	return ;
}

const int N = 10003, M = 1000003;
int n, now, h[N], tot;
struct stu {
	int v;
	int next;
}s[M << 1];

inline void add (const int x, const int y) {
	++tot;
	s[tot].v = y;
	s[tot].next = h[x];
	h[x] = tot;
	return ;
}

int d[M], vis[M];

bool Find (const int x) {
	int i, y; for (i = h[x]; i; i = s[i].next) {
		y = s[i].v;
		if (vis[y] != now) {
			vis[y] = now;
			if (!d[y] || Find (d[y])) {
				d[y] = x;
				return 1;
			}
		}
	}
	return 0;
}

int main () {
	read (n);
	int i, x, y; for (i = 1; i <= n; ++i) {
		read (x), read (y);
		add (x, i);
		add (y, i);
	}
	for (i = 1; i < N; ++i) {
		++now;
		if (!Find (i)) {
			printf ("%d\n", i - 1);
			return 0;
		}
	}
	return 0;
}
```



---

## 作者：叶枫 (赞：17)

~~并查集好啊~~

把每个装备的两个属性$a,b$看成边$(a,b)$，会形成一些连通块

如果连通块大小为$k$ ，无环（树），答案是$k−1$，有环就是$k$

考虑如何合并两个连通块。

合并并查集$x,y$，若$x\not =y$，把数字小的父亲设为数字大的，给数字小的打上$vis$ 标记。若$x=y$，给树根打上标记。

这样维护的并查集有很好的性质：要么所有$vis=1$ ，要么除根（最大点）外$vis=1$ 。于是最后遍历一下输出答案就行了.

`代码应该能自己写了`

---

## 作者：Leianha (赞：11)

## 二分图匹配

我们都能够想到让每个装备和它的属性去连边.

首先提供一种初步想法：

如果我们闭着眼去跑二分图匹配的最大匹配，那么我们得到的答案很显然是错误的.因为我们在得到最大匹配的时候没有考虑从$1$到$n$的连续性。

那我们该怎么办呢？睁开眼再去跑二分图匹配的最大匹配

我们可以二分一个答案，我们只对小于等于$mid$的属性去跑最大匹配，最后看看匹配的点的个数是否等于mid,如果等于的话说明我们可以都匹配上，那就扩大$l$，否则就缩小$r$。

这样的时间复杂度(在Dinic算法下)是O($n \sqrt{m}log(k)$)其中$k$为10000.时间复杂度只能过前几个数据。

那么我们考虑另一种方法：

我们二分之所以会超时，是因为我们做了很多次无用的最大匹配.我们可以考虑一下匈牙利算法，即对每一个属性点依次进行配对。因为我们是将属性点从大到小依次进行匹配，所以我们不用考虑会有不合法的情况，当我们某一次无法匹配属性点$i$的时候，我们就得到了答案$i-1$.

还有匈牙利算法它只用建单向边，因为我们每次更新的时候都只会用到一个边上的点来更新，用不到另一边上的点。

另外$n=10^6$的时候我们就不能每次memset了，否则也会超时，我们记录一下时间点，在遍历的时候看一下时间点是不是冲突了即可。

还有一定要开大数组 ~~不要问我为什么会知道~~

献上我~~丑陋~~的代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a,b,tot,now;
const int M=10100,N=1100000;
int head[M],vis[N],k[N];
struct bian
{
	int to,nt;
}e[N<<1];
void add(int f,int t)
{
	e[++tot].to=t;
	e[tot].nt=head[f];
	head[f]=tot;
}
int read()
{
	char ch;int x=0,f=1;
	while(!isdigit(ch=getchar()))
	{(ch=='-')&&(f=-f);}
	while(isdigit(ch))
	{x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
int find(int x)
{
	for(int i=head[x];i;i=e[i].nt)
	{
		if(vis[e[i].to]==now)continue;
		vis[e[i].to]=now;
		if(!k[e[i].to]||find(k[e[i].to]))
		{
			k[e[i].to]=x;
			return 1;
		}
	}
	return 0;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		a=read(),b=read();
		add(a,i);add(b,i);
	}
	for(int i=1;i<=10001;++i)
	{
		now=i;
		if(!find(i))
		{
			cout<<i-1;
			return 0;
		}
	}
	return 0;
}
```






---

## 作者：abandentsky (赞：6)

思路：这个题目其实特别简单。每种攻击力可以由有个武器提供。每个武器仅仅有两个属性，属性和武器是二对一（其实完全可以多对一）。题目要求攻击力从一开始尽可能大，所以就是给每种攻击力找个武器。看最多匹配几个。完全变成了二分图最大匹配。这样二分图左端点就是攻击力范围，右端点就是武器编号范围。跑一边最大匹配就完事儿了。对于样例而言，左边节点为：1,2,3,4,5.
右边节点为：1（A）,2（B）,3（c）.（武器编号）。然后从每种攻击力向武器连边。变为：1->(A);2->(A);2->(B);3->(B);4->(C);5->(c);程序中将右端点进行了处理，看代码注释。

```c
#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
#define MAXN  1010005
using namespace std;

vector<int> G[10005];    //左端点是攻击力的范围，最大为10000，所以开成10005就够了
bool vis[MAXN];                //右端点的范围<=1000000，但是对N的编号应该加上10000.就是1010000
int vv[MAXN];                   //和右端点匹配的左端点编号
int maxn;                             //输入数据时处理出攻击力的最大值，也就是左端点范围的最大值
int n;                                            //左端点范围为[1,maxn]

bool match(int u)         //匹配模板就不说了
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v])
            continue;
        vis[v]=true;
        if(!vv[v]||match(vv[v]))
        {
            vv[v]=u;
            return true;
        }
    }
    return false;
}

void Km()               //匹配模板
{
    memset(vv,0,sizeof(vv));
    int sum=0;
    for(int i=1;i<=maxn;i++)
    {
        memset(vis,0,sizeof(vis));
        if(match(i))
            sum++;
        else
            break;
    }
    printf("%d\n",sum);
}

int main()
{
    scanf("%d",&n);
    int uu,vv;
    maxn=0;
    for(int i=1;i<=n;i++)                          //从攻击力向武器连一条有向边
    {
        scanf("%d %d",&uu,&vv);
        maxn=max(maxn,uu);
        maxn=max(maxn,vv);
        G[uu].push_back(i+10000);       //第i件武器编号为10000+i
        G[vv].push_back(i+10000);
    }
    Km();
    return 0;
}

```


---

## 作者：陈新月 (赞：5)

有兴趣的同学可以到我博客看： http://www.cnblogs.com/bingdada/p/7710958.html


思路：


一开始看题目还不是特别明白，后来多看了几遍，然后就想到看二分图（这题是随机跳的），对于这题来说，找图两边的对应关心是很重要的，因为一个武器有两个属性却只能被使用一次，而且题目有一个很重要的点，就是属性必须是递增的，所以二分图两边点集所对应关系是左边属性顺序对应右边武器所包含的属性，对于第i个武器来所，如果它的属性为a,b ， 则我们就建两条边，第一条是  a-->i    ，第二条是b-->i。


到最后边建好后，跑一遍匈牙利算法求最大匹配就可以，在求最大匹配时如果出现属性断层，则直接退出，返回当时的最大匹配数。


下面贴代码，有问题可以留言。










```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 1000009
#define M 2000009
using namespace std;
int en;
struct edge{
    int e;
    edge *next;
}*v[N],ed[M];
void add_edge(int s,int e){                        //前向星存边 
    en++;
    ed[en].next = v[s],v[s] =ed+en,v[s]->e =e;
}
int result[N];
bool use[N];
bool dfs(int now){
    for(edge *e = v[now];e;e=e->next)
      if(!use[e->e]){
          use[e->e] = true;
          if(!result[e->e] || dfs(result[e->e])){
              result[e->e] = now;
              return true;
          }
      }
    return false;
}
int xiongyali(){
    memset(result,0,sizeof(result));
    int ans = 0;
    for(int a = 1; a <= 10000; a++){
        memset(use,0,sizeof(use));
        if(dfs(a))ans++;                //当出现某点不能匹配时，说明最大匹配数就为当前状态 
        else break;
    }
    return ans;
}
int read(){
    int x = 0;
    char ch = getchar();
    while(ch < '0' || ch > '9')ch = getchar();
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}
int main(){
    int n =read();
    for(int i = 1; i <= n; i++){
        int u =read(),v = read();
        add_edge(u,i);
        add_edge(v,i);
    }
    int ans = xiongyali();
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：ShineEternal (赞：4)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/88604047)，任何疑问欢迎私信作者！

# 题目链接：
https://www.luogu.org/problemnew/show/P1640
# 分析：
这道题用二分图来解决即可.应该可以作为网络流中的模板题来食用，
每一个武器有两个属性，但是只能取一个用，由此我们便可以想到与二分图挂钩。

> 二分图匹配当中，一个点只能和一个点匹配


问题当中要从小到大使用所有属性，所以肯定要有以1…10000属性为点的一侧

把装备放在另一侧，装备和它的两个属性连边.

(也就相当于从左到右一连，再从右到左一连，才相当于用了两个属性。

从小到大匹配属性点，

因为题目要求必须要每个技能依次释放，所以要有else break环节，这是一个网络流二分图中需要重点注意的环节，有时要加而有时不要，这里要加上还是比较好理解的。


# 代码：

```cpp
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;
vector<int>v[10005];
int vis[1000005],link[1000005];
int t;
bool find(int x)//二分图模板，简单而且理解也不难，墙裂建议借鉴
{
    for(int i=0;i<v[x].size();i++)
    {
        int p=v[x][i];
        if(vis[p]!=t)
        {
            vis[p]=t;
            if(link[p]==0||find(link[p]))
            {
                link[p]=x;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    int n;
    scanf("%d",&n);
    int maxf=0;
    for(int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        v[a].push_back(i);
        v[b].push_back(i);
    } 
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        t++;
        if(find(i))
        {
            cnt++;
        }
        else
        break;
    }
    printf("%d\n",cnt);
    return 0;
} 
```



---

## 作者：fmj_123 (赞：3)

题意：给定$n$个装备，每个装备有两个属性值，每种装备只能使用其中一个属性，并且每个装备只能用一次。现在要从属性$1$开始，依次使用装备，问最多能使用多少个。

题解：

二分图。~~我不会告诉你是因为从试炼场进来才想到的~~

建模很巧妙，我们可以以属性为左端点（属性值$\le n$），装备为右端点做二分图匹配。以样例为例，是这样的。

```
3
1 2
3 2
4 5
```



![P1640_0](https://cdn.luogu.com.cn/upload/pic/55765.png)

显然，$4$,$5$不可能被使用，所以略去。

然后从$1$到$n$，按属性值匹配，这里匹配的意义已经很明显了。当属性$i$无法匹配时，输出$i-1$

我们的程序已经成形了，长这样

```cpp
#include<bits/stdc++.h>
using namespace std;
int cc,to[2002000],net[2002000],fr[2002000];
int fa[2002000],vis[2002000],n,a,b;
void addedge(int u,int v)
{
    if (u>n) return ;
    cc++;
    to[cc]=v;net[cc]=fr[u];fr[u]=cc;
}
int findgf(int x)//匈牙利
{
    if (vis[x]) return false;
    vis[x]=true;
    for (int i=fr[x];i;i=net[i])
    {
        if (fa[to[i]])
        {
            if (findgf(fa[to[i]]))
            {
                fa[to[i]]=x;
                return true;
            }
        }
        else
        { 
            fa[to[i]]=x;
            return true;
        }
    }
    return false;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>a>>b;
        addedge(a,n+i);
        addedge(b,n+i);
    }
    for (int i=1;i<=n+1;i++)
    {
        for (int j=1;j<=n;j++)
          vis[j]=false;
        if (!findgf(i)) {cout<<i-1<<endl;break;}
    }
    return 0;
}
```

这里因为$for$循环清空数组，$TLE$了。

回想一下匈牙利算法，我们想到了一种优化。

**当某一个已经连接某个点的左端点已经不可能连接其他右端点时，可以把$vis$直接置$true$，否则，在退出$dfs$时，将其置$false$。**这样便不用每次初始化。

![P1640_1](https://cdn.luogu.com.cn/upload/pic/55766.png)

这个优化使我们的程序快多了，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int cc,to[2002000],net[2002000],fr[2002000];
int fa[2002000],vis[2002000],n,a,b;
void addedge(int u,int v)
{
    if (u>n) return ;
    cc++;
    to[cc]=v;net[cc]=fr[u];fr[u]=cc;
}
int findgf(int x)//匈牙利
{
    if (vis[x]) return false;
    vis[x]=true;
    for (int i=fr[x];i;i=net[i])
    {
        if (fa[to[i]])
        {
            if (findgf(fa[to[i]]))
            {
                fa[to[i]]=x;
                vis[x]=false;
                return true;
            }
        }
        else
        { 
            fa[to[i]]=x;
            vis[x]=false;
            return true;
        }
    }
    return false;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>a>>b;
        addedge(a,n+i);
        addedge(b,n+i);
    }
    for (int i=1;i<=n+1;i++)
    {
        if (!findgf(i)) {cout<<i-1<<endl;break;}
    }
    return 0;
}
```



---

## 作者：aface0427 (赞：3)

这题我yy了一个费用流的做法
首先建图很显然
>源点连装备流量为1费用为0  
装备向每个能攻击到的点建一条流量为1费用为攻击点编号的边  
能攻击到的点再向汇点连边

这样的话跑一个最小费用最大流可以保证每次跑的流都是向可行的点中序号尽可能小的流  
最后从攻击点1开始扫一遍，看哪个边第一个没流量，答案就是那个编号-1.

---

## 作者：_HLLY_ (赞：2)

这个题、、可以把它当成结论题搞，

结论就是对于每个数字的出现次数，如果区间1~n内的出现次数都>=2，那么这个区间1~n内都会合法

  
这个结论很好证明，连到外面可以视为停止   外面连进来的可以视为凭空增加，如果从一个点出发，再回到这个点，那这一块的都可以不矛盾地取。


根据这个结论，我们就可以从1一直扫到n 检验前n个数合不合法

如果枚举的这个数次数>1，那根据上面的结论就可以跳过

如果枚举的这个数==1，那我们就一路往这条唯一的边走，一直到不合法或者合法为止；

那怎么判断剩下的这一条路是那一条呢？ 我一开始用的set，后来莫名被卡常数了（理论nlogn，n=1e6，读入就T了）

所以我们可以换一个方式卡常数

于是我们发现实际上一个点==1只有一次，因为下一次他就会变成0

因为n==10000，

而1e8常数小可以卡过、

所以就bool暴力枚举

什么？bool开多少，还用说嘛 10000\*10000啊，能过编译，手算100MB

然后事实证明 1e8<1e6\*log(1e6)


然后就暴力地卡时卡空间 A了、（估计也就我能想出这么脑残的方法了）



码：

```cpp
#include<cstdio>  
#include<algorithm>  
using namespace std;  
#include<set>  
int tong[100005],n,i,x,y,it,j;  
bool b[10005][10005];  
int read()  
{  
    int x=0,f=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}  
    return x*f;  
}  
int main()  
{  
scanf("%d",&n);  
    for(i=1;i<=n;i++)  
    {  
    x=read();  
    y=read();  
    b[x][y]=b[y][x]=1;  
tong[x]++;  
tong[y]++;  
    }  
    for(i=1;i<=10000;i++)  
    {  
    int o=i;  
    while(1)  
    {  
        tong[o]--;    
        if(tong[o]<0)  
        {  
            printf("%d",i-1);  
            return 0;             
        }  
        if(tong[o]>0||o>i)  
        {     
        break;    
        }  
        if(tong[o]==0)  
        {     
        for(j=1;j<=10000;j++)  
        if(b[o][j]==1){it=j;break;}  
        b[it][o]=b[o][it]=0;  
        o=it;                     
        }     
    }  
    }  
printf("10000");  
}
```

---

## 作者：MloVtry (赞：2)

关于最下面的并查集解法，其实有一个小问题

2
1 45
2 100
这个样例跑出来是1 ，但显然，ans=2

这个题的并查集证明其实不难，自己推推也能推出来： 环上的属性值不会被装备限制住，而链上的可以任选一个点，即一个属性

显然，对于n个装备，我们最多打到n次

也就是说，对于大于n的情况，我们是可以不去考虑的

因此，可以选择舍弃这个点，来让链上任意一个点都可以使用

因此如果有一个装备的某个属性>n，可以舍弃它，使这个链成为环，又或者像楼下那样直接连到0上

（因为那个a或是b太大了，找并查集的父亲直接找到了0）

楼下的问题也正在这里，他的初始化里并没有把0的num赋为1

这导致了上面的样例没有出来

尽管我申诉了好几次，但都.....

所以，这是修改的代码：

（贴出来是不是涉嫌抄袭？只把改的那句话放出来好了）

第21行：    for (int i=0; i<=n+1; ++i) num[i]=1;

事实上我在博客上见过和楼下一毛一样的题解，不知道是不是一个人


---

## 作者：Error_Eric (赞：1)

### 题意

[Link](https://www.luogu.com.cn/problem/P1640)

### Sol

给个其他题解都没给出过的方法:二分答案。

然后怎么 check 呢？

看 [这个帖子](https://www.luogu.com.cn/discuss/501132)。

~~（完）~~

-----

解法：

抽象成图论问题：给定无向图，试给边加上方向使得每个点入度至少为 1。

二分答案，设二分到的答案是 $u$。

对于每一条边，若两个节点都大于 $u$，跳过之。

若两个节点仅一个大于 $u$，则指向小于 $u$ 的点，这个点成为 “自由点”。

然后连接所有剩下的边。

若最后存在没有自由点的树，那么不合法，否则合法。证明显然。

复杂度 $O(n\log m\alpha(n))$，其中 $m$ 是节点数，也就是最大的属性值。

### Code

大概是因为我 sb 一样动态开并查集所以要开 O2，我也不知道为啥 O2 能从 1200ms+ 优化到 200ms。

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
using namespace std;
const inline void readln(int&I){
	I=0;char C=getchar();
	while(!isdigit(C))C=getchar();
	while( isdigit(C))I=(I<<3)+(I<<1)+C-'0',C=getchar();
}
#define pii pair<int,int>
int n,c1,c2;
vector<pii >e;
bool operator<(pii pa,pii pb){
	if(pa.first==pb.first)return pa.second<pb.second;
	else return pa.first<pb.first;
}
int fi(vector<int>*f,int o){
	if((*f).at(o)==o)return o;
	else return (*f).at(o)=fi(f,(*f).at(o));
}
bool check(int u){
	vector<int>f(u+1),g(u+1);
	for(int i=1;i<=u;i++)
		f.at(i)=i,g.at(i)=0;
	for(int i=e.size()-1;i>=0;i--){
		if(e[i].first>u){
			if(e[i].second<=u)
				g.at(fi(&f,e[i].second))=1;
			continue;
		}
		int v1=fi(&f,e[i].first),v2=fi(&f,e[i].second);
		if(v1!=v2)f[v2]=v1,g[v1]|=g[v2];
		else g[v2]=1;
	}
	for(int i=1;i<=u;i++)
		if(f[i]==i && g[i]==0)return 0;
	return 1;
}
int main(){
	readln(n);
	for(int i=1;i<=n;i++)
		readln(c1),readln(c2),
		e.push_back(make_pair(max(c1,c2),min(c1,c2)));
	int l=0,r=n+1;
	while(l+1<r){//[l,r)
		int mid=((l+r)>>1);
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%d\n",l);
}
```

---

## 作者：wanglichao1121 (赞：1)

为什么没人写二分图的题解呢。。。

明明二分图才是最好想最好写的算法（虽然姿势不好慢的要死）

Ps：理论上的复杂度估计是要T的，但是实际上这不是完全的匈牙利，找到第一个没有匹配的点就可以滚粗了

匈牙利总没有人不会吧

（算了还是说一下）每次找到一种解就可以了，以后再慢慢修改（这种思路类似于最大流，事实上二分图和最大流就是同一种东西），每次如果发现想匹配的点已经被匹配了就想办法让原♂配（什么鬼）另寻新♀欢（什么鬼），然后递归

实际上应用在这道题里就表现为暴力了，每次都贪心地把点塞进去，直到塞不进去

代码如下

```cpp
#include <cstdio>
bool b[3000001];
int c[3000001],fir[3000001],to[3000001],nex[3000001];
int N,n,p,q;
void add(int p,int q)
{
    nex[++N]=fir[p];to[N]=q;fir[p]=N;
}
bool find(int k)
{
    b[k]=true;
    for(int i=fir[k];i;i=nex[i])
    if(!c[to[i]]) {    c[to[i]]=k;b[k]=false;return true;}
    else 
    if(!b[c[to[i]]] && find(c[to[i]]))
    {
        c[to[i]]=k;b[k]=false;return true;
    }
    b[k]=false;
    return false;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&p,&q);
        if(p<=n)    add(p,i+n);
        if(q<=n)    add(q,i+n);
    }
    for(int i=1;i<=n;i++)
        if(!find(i))
        {
            printf("%d",i-1);
            return 0;
        }
    printf("%d",n);
    return 0;
}
顺势安利http://www.cnblogs.com/wanglichao/p/5931723.html
```

---

## 作者：ModestCoder_ (赞：1)

初看没什么头绪

想到二分图

每个装备的两个值$a,b$向$i$连边

跑二分图即可，一旦不能匹配就退出

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], link[maxn], vis[maxn], n, ans;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

int dfs(int u){
	if (vis[u]) return 0;
	vis[u] = 1;
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (!link[v] || dfs(link[v])){
			link[v] = u; return 1;
		}
	}
	return 0;
}

int main(){
	n = read();
	for (int i = 1; i <= n; ++i){
		int x = read(), y = read();
		addedge(x, i), addedge(y, i);
	}
	for (int i = 1; i <= 10000; ++i){
		for (int j = 1; j <= 10000; ++j) vis[j] = 0;
		if (dfs(i)) ++ans; else break;
	}
	printf("%d\n", ans);
	return 0;
}
```


---


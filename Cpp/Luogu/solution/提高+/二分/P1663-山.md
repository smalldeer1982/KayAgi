# 山

## 题目描述

给出一座山，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/9goc0bar.png)

现在要在山上的某个部位装一盏灯，使得这座山的任何一个部位都能够被看到。


给出最小的 $y$ 坐标，如图的 `+` 号处就是 $y$ 坐标最小的安装灯的地方。


## 说明/提示

数据规模：

$30 \%$ 的数据，$1 \le N \le 50$；


$100 \%$ 的数据，$1 \le N \le 5000$；$0 \le X_i, Y_i \le 100000$，保证答案不超过 $1000000$。


## 样例 #1

### 输入

```
6
0 0
10 0
11 1
15 1
16 0
25 0```

### 输出

```
3.00```

# 题解

## 作者：Manjusaka丶梦寒 (赞：25)


只能说这是一道数学题，似乎并没有蓝题那么难。

当我们第一眼度完题的时候，很显然我们要找到所有直线相交的最高点。

幸运的是$n \le 5000 $,我们计算出每一条直线的解析式来以后$n^2$枚举就好了，题解中也有这种做法的解答，就不详细说了，我们考虑要是数据再大一点呢？
我们考虑二分答案，毕竟$n \times n$和$n \times logn$那完全就是两个概念啊。

求直线的解析式应该初中就学了吧，为了避免某些人没学还是稍微提一下吧(大佬可直接跳过)。
![此处输入图片的描述][1]


对于这直线来说，首先第一==定义函数解析式为$y=ax+b$
斜率$a$，为$(y1-y2)/(x1-x2)$,有了斜率我们要求b的值，我们将斜率带入直线上某个点带入$(x_1,y_1)$，那么$$y=ax+b=>y_1=ax_1+b=>b=y_1-ax_1$$
这就求出了一条直线函数解析式。
接下来我们就可以枚举答案了，高度左边缘为$0$,右边缘最大为$1000000$.

最重要的就是$check()$函数啦。
对于每个函数值得判断我们要确定这条直线在哪个区间范围内满足可以被看见(函数值小于判断的值)。
还是看图吧，假设现在判断答案c是否合法。
对于斜率小于0的直线来说
![此处输入图片的描述][2]


  [1]: https://i.loli.net/2018/09/20/5ba36bc70b16b.png
  [2]: https://i.loli.net/2018/09/20/5ba3858a5ace2.png
  
  我们找到$y=c$这条直线与直线的交点$x$，那么对于任意大于$x$的点都是看一由$c$照亮的，那么我们对于斜率小于0的每一条直线记录一个合法的最大左边界$L$(因为要满足所有直线)。
  
  同理对于斜率大于0的直线，求一个最小的右端点$R$。
  
  对于斜率等于0的直线只需要判断b是否小于c就好了。
  当$L \le R$是答案合理。
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#include <cmath>
using namespace std;
int n;
double x[5006],y[5006],a[5006],b[5006],ans;
bool check(double x)
{
	double L=-2e9,R=2e9;
	for(int i=2;i<=n;i++)
	{
		if(a[i]<0)L=max(L,(x-b[i])/a[i]);
		else if(a[i]>0)R=min(R,(x-b[i])/a[i]);
		else if(x<b[i])return 0;
	}
	return L<=R;
}
int main()
{
	scanf("%d%lf%lf",&n,&x[1],&y[1]);
	for(int i=2;i<=n;i++)
	{
		scanf("%lf%lf",&x[i],&y[i]);
		a[i]=(y[i]-y[i-1])/(x[i]-x[i-1]);
		b[i]=y[i]-a[i]*x[i];
	}
	double l=0,r=1000000;
	while(l<=r)
	{
		double mid=(l+r)/2;
		if(check(mid))r=mid-0.0001,ans=mid;
		else l=mid+0.0001;
	}
	printf("%.2lf",ans);
}
```
鄙人不才，有错误请指出，喜欢就点个赞吧。

---

## 作者：iyanhang (赞：7)

#### 楼上题解里有纯数学的办法，这里提供一下普遍的二分答案的办法。
### 具体：
* 求出直线的斜率，截距等资料。
* 二分枚举高度y。
* check(mid)函数：如果对于任意一条直线，存在(x,y)在直线的上端或在直线上则true.
* 判断时，通过直线方程求出满足y的点(x0,y)，
    1. 对于k>0,则x的解集的右端点取x0.
    2. 对于k<0,则左端点取x0.
    3. 对于k==0,直接看b和mid的关系.
* 最后(l,+inf)...(-inf,r)等等取交集，即判断return l<=r即可。


```c++
#include <bits/stdc++.h>
using namespace std;
const int MN=5005;
typedef long long ll;

struct line
{
    double k,b;
    int x1,y1,x2,y2;
    void solve()
    {
        k=((double)(y2-y1))/((double)(x2-x1));
        b=(double)y2-k*(double)x2;
    }
}l[MN];
/*double cross(line l1,line l2)
{
    if (l1.k==l2.k) return 0.00;
    return (l1.b*l2.k-l2.b*l1.k)/(l2.k-l1.k);
}*/
int n;
bool check(double x)
{
    double L=-2e9,R=2e9;
    for (int i=1;i<n;++i)
    {
        if (l[i].k<0) L=max(L,(x-l[i].b)/l[i].k);
        else if (l[i].k>0) R=min(R,(x-l[i].b)/l[i].k);
        else if (x<l[i].b) return false;
    }
    return L<=R;
}
ll read(){
    ll f=1,x=0;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c<='9'&&c>='0'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int main()
{
    n=read();
    int x1,y1,x2,y2;x1=read();y1=read();
    for (int i=2;i<=n;++i)
    {
        x2=read();y2=read();
        l[i-1].x1=x1,l[i-1].y1=y1,l[i-1].x2=x2,l[i-1].y2=y2;
        l[i-1].solve();
        x1=x2,y1=y2;
    }
    double L=0.00,R=2e9;
    while (L+0.001<=R)
    {
        double mid=(L+R)/2.00;
        if (!check(mid)) L=mid; //don't need to plus 1.
        else R=mid;
    }
    printf("%.2lf",R);
    return 0;
}
```

---

## 作者：cszhpdx (赞：6)

这是我人生中第一道独立写出来的蓝题，今天突然想写一篇题解

# 题意
选出一个点，使得它与这座“山”上的每一个点的连线都与这座“山”没有交点
# 解法1：暴力
解题第一步，考虑暴力

暴力怎么写呢？考虑枚举 $y$ ，因为题目要求输出与答案的差不超过 0.01 ，所以我们把精度设为 0.01 ，这样暴力：
```cpp
double y=0;
while(不符合条件)
	y+=0.01
输出y
```
那么剩下的问题就是怎么判断是否符合条件，我们可以先从下面这张图入手：
![](https://cdn.luogu.com.cn/upload/image_hosting/vq05j93f.png)

很明显，$y=4$ 时，蓝色部分的 $x$ 是合法的，也就是对于下降的部分（ $\text{斜率}<0\ \text{时}$ ），$x \ge (f(x)=y\text{ 中 }x\text{ 的解})$ ，我们设 $f(x)=ax+b$ ，解 $ax+b=y$ ，解得 $x=\frac{y-b}{a}$ ，所以当 $a<0$ 时，$x \ge \frac{y-b}{a}$

类似的，我们看 $a>0$ 的情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/i137h4hf.png)

蓝色部分合法，那么 $x \le \frac{y-b}{a}$

特殊的，对于 $a=0$ 的情况，当 $y<a$ ，$x$ 无解，当 $y\ge a$ ，$x$ 取任意实数

那么我们就可以求出任意一段“山坡”，在 $y$ 确定的情况下 $x$ 的范围，我们对于每一段山坡 $x$ 的取值范围，我们对于这些范围取交集，如果最后的集合不是空集，那么说明这个 $y$ 可行，首先我们需要把这些点转换成解析式，我们假设有两个点 $(x_1,y_1),(x_2,y_2)$ ，这条线满足 $y=ax+b$ ，那么：
$$
\left\{\begin{matrix}
ax_1+b=y_1 & \\ 
ax_2+b=y_2 & 
\end{matrix}\right.
$$
解得：
$$
\left\{\begin{matrix}
a=\frac{y_1-y_2}{x_1-x_2} & \\
b=y_1-ax_1 &
\end{matrix}\right.
$$
献上暴力代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int NR=5010;
int n;
struct ttt
{
	double a, b;
}a[NR], b[NR];
//a存输入，b存ax+b中的a，b
bool chk(double y)
{
	double l=-2e9, r=2e9;
	for(int i=1;i<n;i++)
		if(b[i].a>0)r=min(r, (y-b[i].b)/b[i].a);//a>0的情况
		else if(b[i].a<0)l=max(l, (y-b[i].b)/b[i].a);//a<0的情况
		else if(y<b[i].b)return false;//a=0并且y<b的情况
	return l<=r;
}
int main()
{
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf", &a[i].a, &a[i].b);
	for(int i=1;i<n;i++)
	{//转换
		b[i].a=(a[i].b-a[i+1].b)/(a[i].a-a[i+1].a);
		b[i].b=a[i].b-b[i].a*a[i].a;
	}
	double ans=0;
	while(!chk(ans))ans+=0.01;//枚举
	printf("%.2lf", ans);
	return 0;
}
```
然后你会发现你得了 40 分
# 正解：二分
我们可以发现上面的代码中枚举的部分，我们是要找到最高的满足条件的 $y$ ，而且越高越满足条件，考虑二分：
```cpp
double l=0, r=1e6, m, ans;
while(l<=r)
{
	m=(l+r)/2;
	if(chk(m))ans=m, r=m-PR;
	else l=m+PR;
}
printf("%.2lf", ans);
```
其中 $PR$ 是精度，这里 0.01 就够，这里 $r$ 的值也不是随便写的，题目中说 $y_i \le 10^6$ ，所以答案不可能超过 $1e6$ ，献上完整代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int NR=5010;
const double PR=1e-2;
int n;
struct ttt
{
	double a, b;
}a[NR], b[NR];
bool chk(double y)
{
	double l=-2e9, r=2e9;
	for(int i=1;i<n;i++)
		if(b[i].a>0)r=min(r, (y-b[i].b)/b[i].a);
		else if(b[i].a<0)l=max(l, (y-b[i].b)/b[i].a);
		else if(y<b[i].b)return false;
	return l<=r;
}
int main()
{
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf", &a[i].a, &a[i].b);
	for(int i=1;i<n;i++)
	{
		b[i].a=(a[i].b-a[i+1].b)/(a[i].a-a[i+1].a);
		b[i].b=a[i].b-b[i].a*a[i].a;
	}
	double l=0, r=1e6, m, ans;
	while(l<=r)
	{
		m=(l+r)/2;
		if(chk(m))ans=m, r=m-PR;
		else l=m+PR;
	}
	printf("%.2lf", ans);
	return 0;
}
```
# 优化
虽然上述做法已经能 100 分了，但是其实我们还可以再优化，比如把 $double$ 换成整型，这样还能再快一点，代码懒得写了，各位自己尝试吧

---

## 作者：Justin_N_Wu (赞：5)

如果我们把相邻的两个点连接起来，看作一条条直线，那么我们可以发现我们要求的就是找到一个点，使它在每一条的直线的上方或在直线上，并且要求y坐标越小越好。

首先第一步当然是这n-1条直线的表达式给求出来（别说不会，初二就学过了好吧？）

然后我们会发现，对于我们枚举的每一个高度，对于每一条直线都有一个满足要求的区间，那么我们怎么判断这个高度是否可行？显然，若这些区间有交集的话，那么就是有解了，否则就是不行。

枚举高度我们可以通过二分来实现，剩下就是解一下不等式问题就可以了。

代码如下：

``` cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=5005;
struct ad{ int x,y; } a[maxn];
struct line{ double k,b; } b[maxn];   //存直线的表达式
int n; double l,r,mid,L,R,ans;
inline int read(){
    int ret=0; char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret;
}
inline bool check(double x){
    L=-2e9,R=2e9;
    for (int i=1;i<n;i++){
        if (b[i].k<0) L=max(L,(x-b[i].b)/b[i].k);    //由于k可能小于0，注意不等式两边同除以负数要变号
        if (b[i].k>0) R=min(R,(x-b[i].b)/b[i].k);
        if (b[i].k==0&&b[i].b>x) return 0;    //k等于0的话一除就暴了，注意特判
    }
    return L<=R;
}
int main(){
    freopen("hill.in","r",stdin);
    freopen("hill.out","w",stdout);
    n=read();
    for (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
    for (int i=1;i<n;i++){
        b[i].k=1.0*(a[i].y-a[i+1].y)/(a[i].x-a[i+1].x);      //自己推一下的话，应该能懂
        b[i].b=1.0*a[i].y-b[i].k*a[i].x;
    }
    l=0,r=1000000;
    while (r-l>=0.001){    //二分小数的办法
        mid=(l+r)/2.0;
        if (check(mid)) ans=r=mid; else l=mid;
    }
    printf("%.2lf\n",ans);
    return 0;
}
```
#PS 本人第一次写题解，多多见谅


---

## 作者：quest_2 (赞：4)

#### 二分+思维的一道妙题。

需要些许数学知识和一个有点空间意识的脑子。


------------

## 题意简述:

```
平面直角坐标系上N个点相连形成一条折线。
要求找到Y值最小的一个点。
使得它位于每一段折线所在的直线的上方。
```


------------
## 思路历程：


考虑平面直角坐标系上的整条折线如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bxawfpfq.png)

而把“每一段折线所在的直线”补起来就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/b455pes3.png)


------------

###  $\qquad \mathcal{Task\ 1.}$ 什么样的点才满足题目要求？

我们要取的是”每一段折线所在直线“的上方的点。

由于每一段折线的**起点**与**终点**是明确已知的，所以他的“**上半部分**”必然也是已知的。

而我们选取的点，则需要位于**每一段折线**的“上半部分”，所以便是要取所有“上半部分”的**交**。

![](https://cdn.luogu.com.cn/upload/image_hosting/419efei1.png)

看图我们便可知道，**必定存在且只存在一个** $Y$ 值最小的点，使它在每一段折线的“上半部分”。

这个最小的 $Y$ 具象到图像上，就是所有“**包含阴影部分的水平直线**”中最低的一条。 


------------

### $\qquad \mathcal{Task\ 2.}$ 如何查一条水平直线是否包含阴影部分？

『**阴影部分必然是一个联通的多边形。**』

原因显然，在同一条水平直线上，**不可能**存在一个点，一开始在一条直线上方，突然就不在了，突然又到了他的上方的情况（这可是**一次函数**）。

所以对于一条水平直线，他上面的阴影部分要么没有，要有就是**一个固定的**区间。

既然阴影部分在一条水平直线上，**只存在一个区间**。那这个阴影区间我们便可以通过每一段折线的斜率信息，来限定在一个**明确**的范围里。

### $\qquad \mathcal{Task\ 3.}$ 怎么限定阴影部分的范围？

具体地说，限定方法如下：

- 对于一个固定的 $Y$ ，扫一遍每一段折线所在直线，讨论：

 	- 若该直线斜率大于 0 ，单调递增，那他的“上半部分”必然在他的**左上方**（这里需要一点坐标系思维）。当 $Y$ 值固定，阴影部分必然在直线的左侧。
    
    - 若该直线斜率等于 0，一条横着的直线。那么，如果现在的 $Y$ 值**小于**直线所在 $Y$ 值，则**必然不存在**阴影部分。
    
    - 若斜率小于零，单调递减，“上半部分”在 **右上方** 。当 $Y$ 值固定，阴影部分必然在直线的右侧。
    
不妨画图理解。我们现在暂定下 $Y= 0.3$

![](https://cdn.luogu.com.cn/upload/image_hosting/66o8z3h6.png)

黄线的 $Y=0.5$ 我们现在的 $0.3$ 低于其，故必**不存在**阴影部分。

此时需要我们改变 $Y$ 值。

![](https://cdn.luogu.com.cn/upload/image_hosting/3iwlxd9y.png)

此时蓝线的斜率小于0，故阴影部分的区间被限制在 $\{ x|x\geq 0.1 \} $ 范围内。

此时粉线的斜率大于0，故阴影部分的区间被限制在 $\{ x|0.1\leq x\leq 5.6 \}$ 范围内。

这时我们就有了一个明确的区间了。而一条水平直线上，阴影区间存在，也就是代表包含了阴影部分，它的条件显然是 **右边界大于左边界** 。

那这道题就可以轻松解决了，我们只需二分找到**最小的，使阴影区间存在**的$Y$ 值即可。


------------

## 代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 5007;
const double INF = 2e9;

struct line//代表一条直线
{
	double k, b;
    //斜率与截距
} l[MAX];

int N;
double x[MAX], y[MAX];
//存点的 x,y 坐标
double L, R;//左、右边界
double ans;//答案（指最低的Y值）

bool judge(double Y)//获取阴影区间
{
	L = -INF, R = INF;
	for (int i = 1; i <= N; i++)
	{
		if (l[i].k < 0)//截距<0，更新左边界
		{
			L = max(L, (Y - l[i].b) / l[i].k);
		}
		if (l[i].k > 0)//截距>0，更新右边界
		{
			R = min(R, (Y - l[i].b) / l[i].k);
		}
		if (l[i].k == 0)
		{
			if (l[i].b > Y)//截距=0，若低于这条线，则必不存在阴影区间
			{
				return 0;
			}
		}
	}
	return R - L >= 1e-8;//返回右区间是否大于左区间
}
int main()
{
	cin >> N;
	for (int i = 1; i <= N; i++)
	{
		cin >> x[i] >> y[i];//输入
	}
	N--;
	for (int i = 1; i <= N; i++)//算出来斜率与截距
	{
		l[i].k = (1.0) * (y[i] - y[i + 1]) / (x[i] - x[i + 1]);
		l[i].b = (1.0) * y[i] - x[i] * l[i].k;
	}
	double l = 0, r = INF;
	while (r - l >= 1e-8)//二分查找最小Y值
	{
		double mid = (l + r) / 2.0;
		if (judge(mid))
		{
			ans = mid;
			r = mid;
            //不能是mid-1，因为Y是小数，不敢说(mid-1)~mid 之间没有答案
		}
		else
		{
			l = mid;
		}
	}
	printf("%.2lf\n", ans);
}
```


---

## 作者：封禁用户 (赞：3)

楼下都是二分，我来水一发数学方法

一次函数初二就学了。

首先求出相邻两个点构成的直线的解析式，

然后枚举，求出每两条斜率一正一负的直线的交点

时间复杂度O(n²)(n<=50)

对交点取最大值即可

AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <list>
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=5050;
double x[maxn],y[maxn],a[maxn],k[maxn],ans;
int n;
int main(){
    scanf("%d%lf%lf",&n,&x[1],&y[1]);
    rep(i,2,n){
       scanf("%lf%lf",&x[i],&y[i]);
       a[i]=(y[i]-y[i-1])/(x[i]-x[i-1]);  //y=ax+k
       k[i]=y[i]-a[i]*x[i];        //求出直线解析式
    }
    rep(i,2,n)
       rep(j,i+1,n)
          if(((a[j]>0&&a[i]<0)||(a[j]<0&&a[i]>0))){    //如果两条直线斜率一正一负
            double X=(k[i]-k[j])/(a[j]-a[i]);                  //求出交点X坐标
            if(ans<X*a[i]+k[i])                                  //ans对交点Y坐标取最大值
              ans=X*a[i]+k[i];
          }
          else if(!a[j]&&!a[i]&&k[i]==k[j])        //特判，常函数
            if(ans<k[i])
              ans=k[i];
    printf("%.6lf",ans);    //保留6位小数
    return 0;
}
```

---

## 作者：ottora (赞：2)

分享一种时间复杂度 $O\left(N\log N\right)$（不是其他题解的 $O\left(N\log ans\right)$）的做法，理论上可以跑过 $N=5\times 10^6$ 甚至更大的数据。

首先我们观察这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/v7yrcevs.png)

发现对于蓝色线段，只有红色直线上侧的点能看到这条线段。

而我们想要所有的线段都被看到，于是对所有线段所对应的直线上侧求 [半平面交](https://www.luogu.com.cn/problem/P4196)，答案就是所得图形的最低点。

在本题中求半平面交时维护的一定是一个下凸壳，那么答案必然是下凸壳其中一个顶点的 $y$ 坐标。

时间复杂度分析：半平面交核心代码 $O\left(N\right)$，排序 $O\left(N\log N\right)$，总复杂度 $O\left(N\log N\right)$。

注意一个小细节，题目中说灯必须要装在山上，于是加两个半平面 $x\ge X_1$ 和 $x\le X_N$ 作为限制。

代码如下。

```cpp
#include<bits/stdc++.h>
const double eps=1e-9;
using namespace std;
struct vec{
	double x,y;
	vec(const double&x_=0,const double&y_=0){x=x_,y=y_;}
	vec operator+(const vec&b)const{return vec(x+b.x,y+b.y);}
	vec operator-(const vec&b)const{return vec(x-b.x,y-b.y);}
	double operator*(const vec&b)const{return  x*b.x+y*b.y ;}
	double times    (const vec&b)const{return  x*b.y-y*b.x ;}
	void print()const{cout<<'('<<x<<','<<y<<')'<<endl;}
	double deg()const{return::atan2(x,y);}
};
struct segment{
	vec OA,OB;
	vec AB()const{return OB-OA;}
	segment(vec OA_=vec(),vec OB_=vec()){OA=OA_,OB=OB_;}
	bool is_cw(const vec&b)const{return AB().times(b-OA)<-eps;}
	vec inter(const segment&b)const{
		double a_1,b_1,c_1;
		if(fabs(  AB().x)<eps) a_1=1,b_1=0,c_1=  OA.x;
		else{
			a_1=  OA.y       /(  OA.x-  OB.x)+
			      OB.y       /(  OB.x-  OA.x);
			c_1=  OA.y*  OB.x/(  OA.x-  OB.x)+
			      OB.y*  OA.x/(  OB.x-  OA.x);
			b_1=-1;
		}
		double a_2,b_2,c_2;
		if(fabs(b.AB().x)<eps) a_2=1,b_2=0,c_2=b.OA.x;
		else{
			a_2=b.OA.y       /(b.OA.x-b.OB.x)+
			    b.OB.y       /(b.OB.x-b.OA.x);
			c_2=b.OA.y*b.OB.x/(b.OA.x-b.OB.x)+
			    b.OB.y*b.OA.x/(b.OB.x-b.OA.x);
			b_2=-1;
		}
		double d=vec(a_1,b_1).times(vec(a_2,b_2));
		return vec(
			vec(c_1,b_1).times(vec(c_2,b_2))/d,
			vec(a_1,c_1).times(vec(a_2,c_2))/d
		);
	}
	bool operator<(const segment&b)const{
		return AB().deg()<b.AB().deg();
	}
};
constexpr int maxn=5005;
int N,M,K;vec A[maxn];double Ans=INFINITY;
segment P[maxn],Seg[maxn];deque<segment>Q;
vec  back_point(){return(----Q.end())->inter(*--Q.end());}
vec front_point(){return(++Q.begin())->inter(*Q.begin());}
int read(){
	int f=1,ret=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f; ch=getchar();}
	while( isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return f*ret;
}
int main(){
	N=read()+2;
	for(int i=2;i< N;i++) scanf("%lf%lf",&A[i].x,&A[i].y);
	A[1].x=A[2].x,A[1].y=A[2].y+1,A[N].x=A[N-1].x,A[N].y=A[N-1].y+1;
	for(int i=1;i< N;i++) P[++K]=segment(A[i],A[i+1]);
	sort(P+1,P+K+1);
	reverse(P+1,P+K+1);
	for(int i=1;i<=K;i++){
		while(Q.size()>1&&P[i].is_cw( back_point())) Q.pop_back ();
		while(Q.size()>1&&P[i].is_cw(front_point())) Q.pop_front();
		while(Q.size()&&fabs(P[i].AB().deg()-Q.back().AB().deg())<eps
		      &&P[i].is_cw(Q.back().OA)) Q.pop_back();
		if(Q.empty()||fabs(Q.back().AB().deg()-P[i].AB().deg())>eps)
			Q.push_back(P[i]);
		if(Q.size()>1&&Q.front().is_cw(back_point())) Q.pop_back();
	}
	if(Q.size()>=2){
		K=0;for(auto&x:Q) Seg[++K]=x;
		for(int i=1;i< K;i++) if(abs(Seg[i].AB().deg()-Seg[i+1].AB().deg())>eps)
			Ans=min(Ans,Seg[i].inter(Seg[i+1]).y);
	}
	printf("%.2lf\n",Ans);
	return 0;
}
```

---

## 作者：nydzsf_qwq (赞：1)

这是一道关于直线的数学题，还是不错的。

~~但是个人感觉评绿似乎更好一点些~~

#### 题解正文：

将相邻的两点连一条直线，显然灯必须要安装在所有直线的上方，否则在直线上的两点总有一点不能被照到。

考虑二分灯的纵坐标 $y_0$，然后判断是否存在 $x_0$ 满足灯所在的点 $(x_0,y_0)$，在所有直线上方。

如何判断呢？

显然不存在斜率不存在的情况。

对于所有**水平**的直线 $y=a$，$x_0>a$ 即可。 

对于所有**斜率大于 $0$​ **的直线，$x_0$​ 必须要小于这条直线与 $y=y_0$​ 的交点的横坐标。

如下图，红点为山的折点，灯的位置 $(x_0,y_0)$ 需在图中绿点左侧。

$x_0$ 需要比所有交点的横坐标小，即要小于交点横坐标的最小值，将其记为 $x_{r}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pfjydg5s.png?x-oss-process=image/resize,m_lfit,h_250,w_250)

同理，对于所有**斜率小于 $0$​​ **的直线，$x_0$​ 要大于所有这些直线与 $y=y_0$​ 交点横坐标的最大值，记为 $x_l$。

只有在 $x_l < x_r$，且 $y_0$ 比所有水平直线 $y=a$ 中的 $a$ 大时存在 $x_0$​ 符合题意。

其实这里的 $x_l<x_r$ 以及 $y_0>a$ 能不能取等是不影响答案的。​

为了方便，在计算时我将直线解析式定义为 $x=ky+b$，这样可以方便计算出交点的横坐标为当 $y=y_0$ 时 $x$​​ 的值。

#### AC代码

代码应该很好理解，不放注释了。

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5010;
const double MAXANS=1000010;
int n;
double x[MAXN],y[MAXN];
bool check(double mid) {
	double xmin=-0x3f3f3f3f,xmax=0x3f3f3f3f;
	for(int i=2;i<=n;++i) {
		if(y[i]>y[i-1])
			xmax=min(xmax,(x[i]-x[i-1])/(y[i]-y[i-1])*mid-(x[i]-x[i-1])/(y[i]-y[i-1])*y[i]+x[i]);
		if(y[i]==y[i-1])
			if(y[i]>mid) return false;
		if(y[i]<y[i-1])
			xmin=max(xmin,(x[i]-x[i-1])/(y[i]-y[i-1])*mid-(x[i]-x[i-1])/(y[i]-y[i-1])*y[i]+x[i]);
		if(xmax<xmin) return false;
	}
	return true;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%lf%lf",&x[i],&y[i]);
	double l=1,r=MAXANS,mid;
	while(r-l>0.001) {
		mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid;
	}
	printf("%.2lf",mid);
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/54735109)



---

## 作者：_Yoimiya_ (赞：1)

### 本题前置知识 :
1. 斜率 ( Slope ) ：当直线$L$的斜率存在时，对于一次函数 $y$ = $kx$ + $b$ （斜截式），$k$即该函数图像的斜率。  
2. 二分答案（这应该不用说吧，来做蓝题的人应该都会）

### 题意
```
给出n个点相连形成一条折线。
要求找到一个点使得它位于每一段线段的上方且y值最小。
```
如何理解在每一条线段上方呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/e5xgthdr.png)

### 思路
- 先转换问题，考虑求2条线段的上方，则符合条件的点都在2条直线上方，也就是处于线段交的上方，此时显然符合条件的点是两条线段的交点。
- 问题来了，要解决这个题目，首先要求出什么点在直线上方。那么怎么确定点是否在直线上方呢？
- 首先，我们先求出点 ($x_n,y_n$) 和点 ($x_{n-1},y_{n-1}$)的解析式。（公式如下：设 l :$y$ = $kx$ + $b$ , 则   
  $$k = \frac{y_n-y_{n-1}}{x_n - x_{n-1}}$$
  $$b = y_n - kx_n$$
- 而后通过二分答案来枚举每个直线 $ y = mid $（题目只要求求最小的 $y$ 值） ,判断符不符合条件:  
   1.斜率 $k=0$ : 判断该直线的 $b$ 是否小于 $mid$ ;  
   2.斜率 $k>0$ ：取该直线与直线 $ y = mid $ 的交点，保存最小值（符合条件的最左端） 
   3.斜率 $k<0$:   取该直线与直线 $ y = mid $ 的交点，保存最大值（符合条件的最右端）
- 判断在 $ k < 0 $ 符合条件的最大值是否小于在 $k > 0$符合条件的最小值,不是则标志着这个点不满足在所有线段上方，排除，返回 false。
- 输出，保留2位小数。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M(5e3+1);
int n;
double x[M],y[M],slope[M],b[M],ans;
inline bool check(double x){
	double L(-2e9),R(2e9);
	for(register int i(2);i<=n;++i)
	{
		if(slope[i]<0) L=max(L,(x-b[i])/slope[i]);
		else{
			if(slope[i]>0) R=min(R,(x-b[i])/slope[i]);
			else if(x<b[i]) return 0;
		}
	}
	return L<=R;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(register int i(1);i<=n;++i){
		cin>>x[i]>>y[i];
		slope[i]=(y[i]-y[i-1])/(x[i]-x[i-1]);
		b[i]=y[i]-slope[i]*x[i];
	}
	register double l(0),r(2e9+1);
	while(l<=r){
		double mid=(l+r)/2;
		if(check(mid))r=mid-0.0001,ans=mid;
		else l=mid+0.0001;
	}
	printf("%.2lf",ans);
	return 0;
}
```
### 补充说明
-  check 函数里从2开始是因为第一个点没有左边的线段。
-  2e9 是之前 WA 了，调代码时以为是范围不够大开的。

---

## 作者：Delva (赞：1)

题意很好懂，由于有x[i+1]>x[i]的保证，可以转化为找到一个最低点在所有直线上方。用$f_i(x)$表示点i和点i+1联立的直线，不难发现，所有直线的上方交集$ y>=f_i(x)$的边界$max$ { $f_i(x)$ }为一个下凸函数，我们要找的即是函数最低点。通过三分法求极值，便能得到最低点。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
template<class T>inline void read(T &aa) {
  int k=0,f=1;char c=getchar();for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
  for(;isdigit(c);c=getchar()) k=(k<<3)+(k<<1)+(c-'0');aa=k*f;
}
const int maxn = 5010;
const double eps = 1e-8;
struct P{P(){}double x,y;}A[maxn];
int n;
double getY(double x0){//获得横坐标为x0时放灯的最低点 
    double res = 0.0;
    for(int i=1;i<n;++i){
        res=max(res,A[i].y+(x0-A[i].x)*(A[i].y-A[i+1].y)/(A[i].x-A[i+1].x));//联立点i与点i+1得到下凸函数的值
    }return res;
}
int main(void){
    read(n);
    for(int i=1;i!=n+1;++i)scanf("%lf%lf",&A[i].x,&A[i].y);
    //三分法求极值（保证极值始终在l与r之间，通过比较m1和m2缩小范围） 
    double l=0.0,r=100000.0;
    while(abs(l-r)>eps){
        double m1 = (l+l+r)/3,m2 = (l+r+r)/3;
        if(getY(m1)<getY(m2))r=m2;else l=m1;
    }
    printf("%.2lf",getY(l));
    return 0;
}
```

---

## 作者：X_o_r (赞：0)

这题可以很容易地看出来是二分（虽然我看不出来）

#二分枚举答案！

首先我们可以求出N-1条线段，每一条的函数解析式

只需要当前y的点可以存在于每一条线段所在直线的共同上方即可（0~X[n]范围内）

判断的过程：

然后我们确定一个L、R，表示当前的高度可以存在的范围（一次函数一定存在连续的范围）

然后我们要对y=kx+b中的k分类讨论：

若k>0，那么用y=mid（高度）与y=kx+b的交点x去修正R（刷最小值）

若k<0，那么用y=mid（高度）与y=kx+b的交点x去修正L（刷最大值）

若k=0，如果b>=mid，那么验证成立，否则直接返回不成立信息

如果中途存在L>R的情况，说明不存在该mid高度，返回不成立信息

若以上条件均满足，那么则该mid成立，最后取mid的最小值

二分check()代码段如下所示：

``` cpp
inline bool check(double YY)
{
    double L=0,R=x[n],XX;
    for (int i=n;i>1;i--)
    {
        if (K[i]==0) {if (YY<B[i]) return 0; continue;}
        XX=(YY-B[i])/K[i];
        if (K[i]>0) R=min(R,XX); else L=max(L,XX);
        if (L>R) return 0;
    }
    return 1;
}
```

---


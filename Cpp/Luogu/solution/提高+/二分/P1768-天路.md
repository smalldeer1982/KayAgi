# 天路

## 题目描述

“那是一条神奇的天路诶 ~~~，把第一个神犇送上天堂 ~~~ ”，XDM 先生唱着这首“亲切”的歌曲，一道猥琐题目的灵感在脑中出现了。

和 C_SUNSHINE 大神商量后，这道猥琐的题目终于出现在本次试题上了，旨在难到一帮大脑不够灵活的 OIer 们（JOHNKRAM 真的不是说你……）。

言归正传，小 $X$ 的梦中，他在西藏开了一家大型旅游公司，现在，他要为西藏的各个景点设计一组铁路线。但是，小 $X$ 发现，来旅游的游客都很挑剔，他们乘火车在各个景点间游览，景点的趣味当然是不用说啦，关键是路上。试想，若是乘火车一圈转悠，却发现回到了游玩过的某个景点，花了一大堆钱却在路上看不到好的风景，那是有多么的恼火啊。

所以，小 $X$ 为所有的路径定义了两个值，$V_i$ 和 $P_i$，分别表示火车线路的风景趣味度和乘坐一次的价格。现在小 $X$ 想知道，乘客从任意一个景点开始坐火车走过的一条回路上所有的 $V$ 之和与 $P$ 之和的比值的最大值。以便为顾客们推荐一条环绕旅游路线（路线不一定包含所有的景点，但是不可以存在重复的火车路线）。

于是，小 $X$ 梦醒之后找到了你……

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1 \le M \le 20$；

对于 $60\%$ 的数据，$1 \le N \le 3{,}000$，$1 \le M \le 2{,}000$；

对于 $100\%$ 的数据，$1 \le N \le 7{,}000$，$1 \le M \le 20{,}000$，$1 \le V_i,P_i \le 1{,}000$。

保证答案在 $200$ 以内。

![](https://cdn.luogu.com.cn/upload/image_hosting/e1ywdkfs.png)


## 样例 #1

### 输入

```
5 6
1 2 1 1
4 1 6 2
5 4 8 1
2 3 2 2
5 2 4 1
3 5 6 4```

### 输出

```
2.3```

# 题解

## 作者：冈崎梦美 (赞：47)

好题。

这道题每条路有两个权值，且要求的是环内权值之比的最大值，很容易联想到两个算法：Tarjan 和 单源最短路径。

考虑Tarjan，基本思路是求出强连通分量再进行相加比较。由于Tarjan只能求出最大的环，那么它便不能照顾到所有可能解，显然，用Tarjan找环再相加不现实。

_____

考虑单源最短路，显然这道题不能简单的套模板。我们设$ans$为最优解，则其一定满足

## $\frac{\Sigma V_{i}}{\Sigma C_{i}}\leqslant ans$
（其中，$V_{i}$和$C_{i}$为图中任意环上的边权，ans为最优解）

那么，根据不等式的性质进行变换：

由于$\Sigma C_{i}$一定是正数，所以：

### $\Sigma V_{i}\leqslant ans*\Sigma C_{i}$

等式两边同时减去$\Sigma V_{i}$，得到：
### $ans*\Sigma C_{i}-\Sigma V_{i}\geqslant 0$

显然，只要一个$ans$满足这个不等式，那么这个解就一定是可行的。

但是如果一个解可以，那比这个解大的其他解其实都是可以的。（如：对于样例$ans=2.3$ 时，满足上述不等式，但只要$ans\geqslant2.3$，所有的解都是满足不等式的）

我们要求的是一个最小的满足该等式的$ans$，所以就是所谓的“最大值里最小的”，而这就是二分答案的标志。

** 那么，我们把每条边都根据二分答案出来的$ans$，把第$i$条边的权值修改为$ans*C_{i}-V_{i}$，然后跑SPFA判负环即可。 **

大体思路有了，接下来强调一下细节。

1. 题目要求的值是一个小数，注意二分答案的数据类型。

2. 不要用BFS版的SPFA，会超时。用DFS版本的差不多。

3. 图不一定联通，所以SPFA的起点不能随便找一个。解决问题的方法很简单。建一个超级点，联通它和所有其他点即可。

代码很简单。简单注意一下边的大小就好。
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=7007;
struct edge
{
    int to,v,c;
};
vector<edge>G[maxn];
int n,m;
bool vis[maxn];
double dis[maxn];
bool spfa(double ans,int now)//DFS版的SPFA
{
    vis[now]=true;
    for(int i=0;i<G[now].size();i++)
    {
        edge e=G[now][i];
        double x=ans*e.c-e.v;//边的权值，根据二分出来的ans进行修改
        if (dis[e.to]>dis[now]+x)
        {
            if (vis[e.to]) return false;
            else
            {
                dis[e.to]=dis[now]+x;
                vis[now]=true;
                if (!spfa(ans,e.to)) return false;
            }
        }
    }
    vis[now]=false;//记得要回溯
    return true;
}
int main()
{
    scanf("%d %d ",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y,v,c;
        scanf("%d %d %d %d",&x,&y,&v,&c);
        G[x].push_back((edge){y,v,c});
    }
    for(int i=1;i<=n;i++)
    {
        G[0].push_back((edge){i,0,0});//超级点与每个点都需要联通
    }
    double l=0,r=1000001;//注意这里，l需要从0而不是1开始枚举。具体为什么自己想。
    while(l+0.00001<r)//浮点数的精度问题，应该不需要我强调了？
    {
        memset(dis,127,sizeof(dis));
        memset(vis,false,sizeof(vis));
        dis[0]=0;vis[0]=true;
        double mid=(l+r)/2;
        if (spfa(mid,0)) r=mid;
        else l=mid;
        mid=(l+r)/2;
    }
    if (l==0) printf("-1\n");
    else printf("%.1f\n",l);
    return 0;
}


```

---

## 作者：Wisbtsml (赞：10)

## 这是BFS SPFA的题解！并且是第一篇Bfs题解
首先给出证明 ：

设ans是最后的解，有Σ$V_i$ / Σ$P_i$ <= ans;  
    
Σ$V_i$ <= Σ$P_i$ * ans; 
     
0 <= Σ$P_i$ * ans - Σ$V_i$;

所以我们要找到一个ans使得边权为Σ$P_i$ * ans - Σ$V_i$的图不存在负环；

至于更详细的证明请看这个人的题解 

https://start-dash.blog.luogu.org/P1768



这是正常的BFS求解过程 ：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long

using namespace std;
const int maxn = 20001;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
    for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ 48);
    return x * f;
}

struct node {
    int next, to, v, p;
    double dist;
}edge[maxn];

bool vis[maxn], flag;
int sum[maxn], h[maxn], n, m, num = 0;
double dis[maxn], l, r, mid;

bool SPFA(int s) {
    for(int i = 1; i <= n; ++i) vis[i] = 0, dis[i] = 1000000.01, sum[i] = 0;
    queue <int> q;
    vis[s] = 1; dis[s] = 0; q.push(s);
    while(!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        if(sum[u] > n) return 1;
        for(int i = h[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if(dis[v] > dis[u] + edge[i].dist) {
                dis[v] = dis[u] + edge[i].dist;
                if(!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                    sum[v]++;
                    if(sum[v] > n) return 1;
                }
            }
        }
    }
    return 0;
}

int main() {
    n = read(); m = read();
    for(int i = 1, a, b, c, d; i <= m; ++i) {
        a = read(); b = read(); c = read(); d = read();
        edge[++num] = (node){h[a], b, c, d, 0.}; h[a] = num;
    }
    l = 0.; r = 200.;
    while(l + 0.01 < r) {
        mid = (l + r) / 2;
        for(int i = 1; i <= num; ++i) edge[i].dist = edge[i].p * mid - edge[i].v;
        for(int i = 1; i <= n; ++i) {
            flag = SPFA(i);
            if(flag) break;
        }
        if(flag) l = mid;
        else r = mid;
    }
    if(l) printf("%.1lf", r);
    else puts("-1");
}
```

只有70分 https://www.luogu.org/record/show?rid=13111155

然后我就翻讨论看到有人说这题数据水，入队只要判断超过20次就算负环了，于是有了下面的代码 ：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long

using namespace std;
const int maxn = 20001;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
    for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ 48);
    return x * f;
}

struct node {
    int next, to, v, p;
    double dist;
}edge[maxn];

bool vis[maxn], flag;
int sum[maxn], h[maxn], n, m, num = 0;
double dis[maxn], l, r, mid;

bool SPFA(int s) {
    for(int i = 1; i <= n; ++i) vis[i] = 0, dis[i] = 1000000.01, sum[i] = 0;
    queue <int> q;
    vis[s] = 1; dis[s] = 0; q.push(s);
    while(!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        if(sum[u] > 20) return 1;//只有这行和下面那一行判断入队次数的地方把n改成了20
        for(int i = h[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if(dis[v] > dis[u] + edge[i].dist) {
                dis[v] = dis[u] + edge[i].dist;
                if(!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                    sum[v]++;
                    if(sum[v] > 20) return 1;
                }
            }
        }
    }
    return 0;
}

int main() {
    n = read(); m = read();
    for(int i = 1, a, b, c, d; i <= m; ++i) {
        a = read(); b = read(); c = read(); d = read();
        edge[++num] = (node){h[a], b, c, d, 0.}; h[a] = num;
    }
    l = 0.; r = 200.;
    while(l + 0.01 < r) {
        mid = (l + r) / 2;
        for(int i = 1; i <= num; ++i) edge[i].dist = edge[i].p * mid - edge[i].v;
        for(int i = 1; i <= n; ++i) {
            flag = SPFA(i);
            if(flag) break;
        }
        if(flag) l = mid;
        else r = mid;
    }
    if(l) printf("%.1lf", r);
    else puts("-1");
}
```

于是便愉快的变成了~~60~~分 ：

https://www.luogu.org/record/show?rid=13111251

然后我乱搞了一下 ：

```cpp
		for(int i = 1; i <= n; ++i) {
            flag = SPFA(i);
            if(flag) break;
        }
```

我把这个改成了 ：

```cpp
	flag = SPFA(1) || SPFA(n) || SPFA(n >> 1);
```

然后变成了90分 ：https://www.luogu.org/record/show?rid=13112652

真是神奇第一次觉得自己脸真白；

这十分我实在不会了，就偷偷翻了一下题解，还是刚刚那个人的题解，我知道了超级点这个东西，就试了一下，然后一不小心就A了，当然ac代码是不会给你们的，毕竟看到这里你都能拿90分了，最后10分靠自己A了它，你就比我强了。

这里是我AC证据：https://www.luogu.org/record/show?rid=13113904

跑的还是挺快的；

noip前写一篇题解，不管能不能过，都先祝各位RP++；

PS：

正常的用BFS我是A不了这题的，你也看到我是判断入队次数超过20就return 1的，所以还是学习一下DFS的方法吧；

---

## 作者：Anguei (赞：10)

谈一下这道题的二分方式。

实数二分主要有两种形式。

### 1. 判断 `l`,`r` 与 `eps` 的关系
```cpp
while (r - l >= eps) {
	double mid = (l + r) / 2;
	// ...
}
```

### 2. 直接二分 $100$ 次
```cpp
for (int times = 0; times < 100; ++i) {
	double mid = (l + r) / 2;
    // ...
}
```

通常，第二种的精度是要比第一种高的。

如果采用第二种方式进行二分的话，你可能会说：**诶？怎么 TLE 了？**

所以要把二分次数缩小一些。缩小到多少合适呢？

仔细读题，发现：**「保证答案在 $200$ 以内。」** **「保留 $1$ 位小数。」**。既然要保留一位小数，那么我们需要计算到**百分位**。又因为答案保证不高于 $200$，所以总共只有 $\frac{200}{\frac{1}{100}}=20000$ 种可能的输出。$\lceil \log_220000\rceil = 15$（即 $2^{14}=16384,2^{15}=32768$），所以只需要二分 $15$ 次就可以得出结果了：

```cpp
double l = 0, r = 200; 
for (int i = 0; i < 15; ++i) {
	double mid = (l + r) / 2; 
    if (check(mid)) l = mid; 
    else r = mid;
}
```

---

## 作者：C_SUNSHINE (赞：9)

这一题直接找环肯定超时，甚至60分都不好拿。我们这样想：设ans为答案，则存在任意环E保证∑V(i)/∑P(i)<=ans，可以得到∑V(i)<=ans\*∑P(i)，于是∑{P(i)\*ans}-∑V(i)>=0。

最后得到∑{P(i)\*ans-V(i)}>=0，即以P(i)\*ans-V(i)为边权的图中不存在负权环。

所以，二分答案ans，用dfs改进的SPFA算法判断图中是否存在负权环，若存在，修改下界否则修改上界。



```cpp

#include<stdio.h> //By C_SUNSHINE & JOHNKRAN
#include<iostream>
using namespace std;
int h[10001],next[130001],v[130001],n,m;
float p[130001],w[130001],d[130001],low,high,mid;
bool in[130001],flag;
void dfs(int now)
{
    in[now]=1;
    for(int i=h[now];i;i=next[i])
      if(d[now]+p[i]*mid-w[i]<=d[v[i]])
      {
        if(in[v[i]]){flag=0;return;}
        d[v[i]]=d[now]+p[i]*mid-w[i];
        dfs(v[i]);
        if(!flag)return;
      }
    in[now]=0;
}
void init()
{
    scanf("%d%d",&n,&m);
    int i,j,k;
    for(j=1;j<=m;j++)
    {
        scanf("%d%d%f%f",&i,v+j,w+j,p+j);
        if(i!=v[m])
        {
          next[j]=h[i];
          h[i]=j;
        }
    }
    for(i=1;i<=n;i++)
    {
        v[i+m]=i;
        next[i+m]=h[0];
        h[0]=i+m;
    }
}
int main()
{
    init();
    low=0;
    high=200;
    while(low+0.01<high)
    {
        mid=(low+high)/2;
        flag=1;
        memset(in,0,sizeof(in));
        memset(d,127,sizeof(d));
        d[0]=0;
        dfs(0);
        if(!flag)low=mid;
        else high=mid;
    }
    if(low==0)printf("-1");
    else printf("%.1f",high);
    return 0;
}


```

---

## 作者：Kwork (赞：8)

~~图论其实蛮好玩的~~，随便又计数含量的题目都可以写90+行代码，给人成就感，做人嘛，开心最重要，~~我才不开心~~

-------------------------------------------------------------------------------------------------

其实在做这一题前做到过类似的题目，用二分+spfa判负环。~~spfa大法好~~。

答案是单调的这一点可以知道，然后二分。

mid=(l+r)/2;假设ans=mid；

那么在图中任何一个环内Σvi/Σpi<=ans。如果还有更大的就会有Σvi/Σpi>ans，也就是ans\*Σpi-Σvi<0，那么我们可以用spfa快速的找出是否存在这样的环，在二分中步步逼近真的ans。

类似的方法在差分约束中也用得到。（~~spfa乃一大神器啊~~）

-----------------------------------------吐槽一下------------------------------------------------------------------------------------------

一开始没看题目直接把练习时遇到的类似的题目的代码交了上去后来发现连数据格式都对不上【-\_-】，但是拿了10分！

然后过了好久想起来还有这一题所以来做一下，然后不知道答案保证在200内，然后TLE了一个点，后来AC之后发现那个点时比较快的？？！！其实差不多。链表实现的邻接表懒得写（~~其实不怎么会写~~），就用vector了。

----------------------------------------------------------------------------------------------------------------------------------------------






```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int maxn=7000+50;
struct edge{int to;double v,p;double w;};
int n,m;
double l=0,r=500,mid,d[maxn],used[maxn];
vector<edge>G[maxn];
inline int read(){
    char ch=getchar();int data=0;
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        data=data*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return data;
}
inline void add_edge(int x,int y,int v,int p){
    edge e;
    e.to=y;e.v=(double)v;e.p=(double)p;
    G[x].push_back(e);
    return;
}
void init(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int x,y;double p,v;
        x=read();y=read();
        scanf("%lf%lf",&v,&p);
        add_edge(x,y,v,p);
    }
    for(int i=1;i<=n;i++)
        add_edge(0,i,0,0);
    return;
}
void adjust(double now){
    for(int x=1;x<=n;x++)
        for(int y=0;y<G[x].size();y++)
            G[x][y].w=now*G[x][y].p-G[x][y].v;
    return;
}
bool spfa(int x){
    used[x]=true;
    for(int i=0;i<G[x].size();i++){
        double temp=d[x]+G[x][i].w;
        int y=G[x][i].to;
        if(d[y]>temp){
            d[y]=temp;
            if(!used[y]){
                if(spfa(y))
                    return true;
            }
            else return true;
        }
    }
    used[x]=false;
    return false;
}
bool check(double now){
    for(int i=1;i<=n;i++){
        used[i]=false;
        d[i]=1234567890;
    }
    d[0]=0;
    adjust(now);
    if(spfa(0)) return true;
    return false;
}
void solve(){
    while(r-l>0.01){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(l==0)printf("-1");
    else printf("%.1lf",r);
    return;
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：BFSDFS123 (赞：3)


首先 $\dfrac{\sum V_i}{\sum P_i}$ 一眼发现是分数规划。解决分数规划的通用方法便是二分。

首先我们要二分一个数 $mid$ 作为此时最大的答案，若 $\dfrac{\sum V_i}{\sum P_i}>mid$，则有 $mid\times \sum P_i-\sum V_i<0$。当某些点在一个环上时，便出现了一个负环。我们只需要找到最小且满足没有负环的那个 $mid$ 就可以了。

然后就可以使用 spfa 判负环了。

但是 bfs 版会 TLE，使用 dfs 版的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define eps 1e-5
const int inf=0x3f3f3f3f;
const int Maxn=7010;
int n,m;
struct Ed{
	int v;
	double w;
}; 
vector<Ed> G[Maxn];
struct Edges{
	int to;
	int v,p;
}; 
vector<Edges> g[Maxn];
bool vis[Maxn];
double dis[Maxn];
int dfs(int u)
{
	vis[u]=1;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i].v;
		double w=G[u][i].w;
		if(dis[u]+w<dis[v])
		{
			if(vis[v])
			{
				return true;
			}else{
				dis[v]=dis[u]+w;
				vis[v]=true;
				double flag=dfs(v);
				if(flag) return true;
			}
		}
	}
	
	vis[u]=false;
	return false;
}
bool check(double mid)
{
	memset(dis,0x7f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=n;i++) G[i].clear();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<g[i].size();j++)
		{
			G[i].push_back((Ed){g[i][j].to,mid*g[i][j].p-1.0*g[i][j].v});
//			cout<<i<<"->"<<g[i][j].to<<":"<<mid*g[i][j].p-g[i][j].v<<endl;
		}
	}
	for(int i=1;i<=n;i++)
	{
		G[0].push_back((Ed){i,0}); 
	}
	dis[0]=0;
	vis[0]=1;
//	cout<<"----------"<<endl;
	return dfs(0);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int s,t,v,p;
		scanf("%d%d%d%d",&s,&t,&v,&p);
		g[s].push_back((Edges){t,v,p});
	}
	
	double l=0,r=210;
	while(r-l>=eps)
	{
		double mid=(l+r)/2.0;
		if(check(mid))
		{
			l=mid;
		}else{
			r=mid;
		}
	}
	if(l==0)
	{
		puts("-1");
	}else{
		printf("%.1f\n",l);
	}
	return 0;
}
```

---

## 作者：Cerisier (赞：2)

一种完全使用裸 SPFA 算法的做法。

一道分数规划题，实际上是最短路的灵活运用。

### 题意

题目话很多，简单来说就是：

$n$ 个点，$m$ 条边，每条边有两个属性，分别为花费 $\text{cost}$ 和收益 $\text{joy}$。求出一个环使得环上的 $\dfrac{\sum\text{joy}}{\sum \text{cost}}$ 的值最大。

### 思路

如果我们令答案为 $p$，则对于图上任意一个环，都有：

$$
\dfrac{\sum\text{joy}}{\sum \text{cost}}\le p
$$

将不等式左右两边乘上 $\sum\text{cost}$，则：

$$
\sum\text{joy}\le p\times\sum\text{cost}
$$

换个位置可得：

$$
p\times \sum\text{cost}-\sum\text{joy}\ge 0
$$

也就是说，$p$ 是正确的答案时，图上不会出现负环。

对于第 $i$ 条边而言，在跑 SPFA 算法的时候，他实际的边权应该是

$$
p\times \text{cost}_i-\text{joy}_i
$$

另外，我们可以发现，题目要求的是一个式子的值最大。观察 $p\times \sum\text{cost}-\sum\text{joy}$ 发现这个式子是具有单调性的，那么就可以使用二分减少计算次数（从 $200$ 次计算下降到了 $\log_2(200)\approx8$ 次）

而且，在这道题中，题目并没有告诉我们起点是那个点。因此，我们需要建立一个超级源点（我的代码中是 $0$ 号点），然后将他与其他 $n$ 个点连接一条不会对答案产生影响的边。

最后，我罗列一下需要注意的几个点：

- SPFA 的 $\text{d}$ 数组需要是 bool 类型的，而且不能使用 memset 进行赋值，必须使用 for 循环暴力赋值。
- 二分左端点初始为 $1$，右端点初始设置为一个大于等于 $200$ 的数。
- 当二分结束后，左端点是等于 $0$ 时，那么代表无解，输出 $-1$。

---

你以为结束了？并没有。

当你交上上面思路写出的代码时，你会发现你只有 90 分。

上面的思路唯一可以再减少操作步数的就只有 SPFA 内部了。我们设置一个值 $\text{delta}$ 表示当一个点入队次数上限，进行人肉二分，发现当 $\text{delta}$ 等于 $10$ 的时候就可以通过此题，而且跑的飞快，总共只有 67ms，成功进入最优解第一页。

### 代码

```cpp
#include<iostream>
#include<vector>
#include<cstring>
#include<queue>
#include<iomanip>
using namespace std;

const int maxn = 7010;
const double eps = 1e-3;

int n, m;

struct node {
    int v, joy, cost;
    node(int vv, int jjoy, int ccost) {
        v = vv, joy = jjoy, cost = ccost;
    }
};

std::vector<node> g[maxn];

void add(int u, int v, int joy, int cost) {
    g[u].push_back(node(v, joy, cost));
}

double d[maxn];
bool inqueue[maxn];
int cnt[maxn];

const int delta = 30;

bool spfa(double p) {
    for (int i = 0; i < maxn; i++) {
        d[i] = 1e9;
    }
    memset(inqueue, 0, sizeof(inqueue));
    memset(cnt, 0, sizeof(cnt));
    queue<int> q;
    q.push(0);
    d[0] = 0;
    cnt[0]++;
    inqueue[0] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inqueue[u] = false;
        if (cnt[u] > delta) {
            return true;
        }
        for (int i = 0; i < g[u].size(); i++) {
            int v = g[u][i].v;
            if (d[v] > d[u] + p * g[u][i].cost - g[u][i].joy) {
                d[v] = d[u] + p * g[u][i].cost - g[u][i].joy;
                if (!inqueue[v]) {
                    inqueue[v] = true;
                    q.push(v);
                    cnt[v]++;
                    if (cnt[v] > delta) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, joy, cost;
        cin >> u >> v >> joy >> cost;
        add(u, v, joy, cost);
    }
    for (int i = 1; i <= n; i++) {
        add(0, i, 0, 0);
    }
    double l = 0, r = 200.0;
    while (l + eps < r) {
        double mid = (l + r) / 2.0;
        if (spfa(mid)) {
            l = mid;
        } else {
            r = mid;
        }
    }
    if (l == 0) {
        cout << -1 << endl;
    } else {
        cout << fixed << setprecision(1) << l << endl;
    }
    return 0;
}
```

---

## 作者：lyhqwq (赞：2)

### 前言

做这道题的时候 addege 写错了调了好久，所以对着第一篇题解调的，代码可能有相似，请见谅。 wtcl

### 题意

有 $n$ 个点， $m$ 条边。每条边有一个 $v$ 值和一个 $p$ 值。求一个回路，是这条回路上的所有点的 $v$ 值总和与 $p$ 值总和之比最大。

假设现在得到的最优解为 $\lambda {}'$

则一定满足

$\dfrac{\sum V_i}{\sum P_i} \leq \lambda {}'$ 

由于 $1 \leq P_i$

所以我们把上面的式子移项得

$\sum V_i \leq \lambda {}' \times \sum P_i$

进一步变形为

$0 \leq \lambda {}' \times \sum P_i \:-\:\sum V_i$

这个图没有负环

我们二分答案求出 $\lambda {}'$ 。然后把每条边边权变成 $\lambda {}' \times  P_i \:-\: V_i$ 跑一边spfa，判断有没有负环。如果有就缩小 $\lambda {}'$ ，反之扩大

### AC code

注意要用 dfs 版的 spfa ，否则会超时。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define il inline
using namespace std;
const int N=200005;
struct edge{
	int next;
	int to;
	int v;
	int p;
}edge[N<<1];
int head[N],cnt;
int n,m,vis[N];
double dis[N];
void addedge(int from,int to,int v,int p){
	edge[++cnt].v=v,edge[cnt].to=to,edge[cnt].p=p,edge[cnt].next=head[from],head[from]=cnt;
}
bool spfa(double ans,int now){//判断有没有正环，有返回0，无返回1
	vis[now]=1;
	for(int i=head[now];i;i=edge[i].next){
		int to=edge[i].to,v=edge[i].v,p=edge[i].p;
		double w=ans*p-v;
		if(dis[to]>dis[now]+w){
			if(vis[to]) return 0;
			else{
				dis[to]=dis[now]+w;
				vis[now]=1;
				if(!spfa(ans,to)) return 0;	
			}
		}
	}
	vis[now]=0;
	return 1;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int from,to,v,p;
		scanf("%d%d%d%d",&from,&to,&v,&p);
		addedge(from,to,v,p);
	}
	for(int i=1;i<=n;i++){
		addedge(0,i,0,0);
	}
	double l=0,r=1000001;
	while(l+0.001<r){
		memset(dis,127,sizeof(dis));
		memset(vis,0,sizeof(vis));
		//printf("%.1f %.1f\n",l,r);
		dis[0]=0;
		vis[0]=1;
		double mid=(l+r)/2;
		if(spfa(mid,0)) r=mid;
		else l=mid;
		mid=(l+r)/2;
	}
	if(l==0) puts("-1");
	else printf("%.1f\n",l);
	return 0;
}

```


---

## 作者：MILLOPE (赞：2)

## 题目
[题目传送门](https://www.luogu.org/problemnew/show/P1768)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706193630969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706193642981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)
**输入输出样例**
输入样例
```cpp
5 6
1 2 1 1
4 1 6 2
5 4 8 1
2 3 2 2
5 2 4 1
3 5 6 4
```
输出样例
```cpp
2.3
```

## 题解
- 本题我们要求$$\max{\frac{\sum{v_i}}{\sum{p_i}}}$$
- 这是01分数规划的基本形式。
- 设$ans$为最优解，则有$$\frac{\sum{v_i}}{\sum{p_i}}\leq ans$$
- 化简得$$0 \leq ans*\sum{p_i}-\sum{v_i}$$
- 所以只要以$ans*\sum{p_i}-\sum{v_i}$为边权的图不存在负环即可更新答案。
- 在建图时可找一个超级源点(如：0)向其余点连权值为0的边可减少时间复杂度。

## code 
```cpp
#include <bits/stdc++.h> 
using namespace std; 
const int maxn = 7e3 + 100; 
const int maxm = 2e4 + 100; 

template <typename T> 
inline void read(T &s) {
	s = 0; 
	T w = 1, ch = getchar(); 
	while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }
	while (isdigit(ch)) { s = (s << 1) + (s << 3) + (ch ^ 48); ch = getchar(); }
	s *= w; 
}

int n, m, tot; 
int lin[maxn]; 
bool flag; 
bool vis[maxn]; 
double dis[maxn]; 
struct node {
	int next, to, v, p; 
	double dis; 
} edge[maxm]; 

inline void add(int from, int to, int v, int p) {
	edge[++tot].to = to; 
	edge[tot].v = v; 
	edge[tot].p = p; 
	edge[tot].dis = 0.00; 
	edge[tot].next = lin[from]; 
	lin[from] = tot; 
}


void spfa(int u) {
	vis[u] = true; 
	for (int i = lin[u]; i; i = edge[i].next) {
		if (flag) return ; 
		int v = edge[i].to; 
		if (dis[v] > dis[u] + edge[i].dis) {
			dis[v] = dis[u] + edge[i].dis; 
			if (vis[v]) {
				if (dis[v] < 0) flag = true; 
			} 
			else spfa(v); 
		}
	}
	vis[u] = false; 
}

int main() {
//	freopen("1.in", "r", stdin); 
	
	read(n), read(m); 
	for (int i = 1; i <= m; ++i) {
		int x, y, v, p; 
		read(x), read(y), read(v), read(p); 
		add(x, y, v, p); 
	}
	double l = 0.00, r = 233.33; 
	while (l + 0.01 < r) {
		double mid = (l + r) / 2; 
		memset(dis, 0, sizeof(dis)); 
		memset(vis, false, sizeof(vis)); 
		for (int i = 1; i <= tot; ++i) 
			edge[i].dis = (double)edge[i].p * mid - edge[i].v; 
		flag = false; 
		for (int i = 1; i <= n; ++i) {
			spfa(i); 
			if (flag) break; 
		}
		if (flag) l = mid; 
		else r = mid; 
	}
	if (l) printf("%.1lf\n", r); 
	else puts("-1");  
	return 0; 
}
```

---

## 作者：Yukinoshita_Yukino (赞：1)

题意：求有向图中密度最小的环。

一看到最小就能想到二分密度，不过要考虑单调性的问题。

我们设二分出来的密度是 mid ,需要检查每个环符不符合密度要求，即环的密度大于 mid 。这样根据不等式的传递性，单调性的问题就被我们解决了。

直接检查环的密度是否大于 mid 有点不方便，我们可以把每条边都换成 $mid \cdot P_i-V_i$ , 然后用 SPFA 判断负环即可。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define debug; cout<<"debug"<<endl;
const int maxn=200000;
struct edge{
	int to;
	int w;
	int v;
	int next;
	double dis; 
}e[maxn];
int n,m,first[maxn],cnt=0,vis[maxn];
double dis[maxn];
double eps=1e-3;
int can=0;
void add(int u,int vv,int w,int z)
{
	e[++cnt].to=vv;
	e[cnt].w=w;
	e[cnt].v=z;
	e[cnt].next=first[u];
	first[u]=cnt;
}
void bfs(int id)
{
	vis[id]=1;
	for(int i=first[id];i;i=e[i].next)
	{
		if(can==1) return ;
		if(dis[e[i].to]>dis[id]+e[i].dis)
		{
			dis[e[i].to]=dis[id]+e[i].dis;
			if(dis[id]+e[i].dis<0&&vis[e[i].to]==1) can=1;
			if(vis[e[i].to]==0) bfs(e[i].to);
		}
	}
	vis[id]=0;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		add(a,b,c,d);
	}
	double l=0.00,r=514.114;
	while(l+eps<r)
	{
		memset(dis,0,sizeof dis);
		memset(vis,0,sizeof vis);
		double mid=(l+r)/2;
		can=0;
		for(int i=1;i<=cnt;i++)
		{
			e[i].dis=e[i].v/1.0*mid-e[i].w;
		} 

		for(int i=1;i<=n;i++)
		{	
			bfs(i);
			if(can==1) break;
		}
		if(can==1) l=mid;
		else r=mid;
	}
	if(l!=0) printf("%.1lf",l); 
	else cout<<-1;
	return 0;
 } 
```

---

## 作者：HPXXZYY (赞：1)

$\color{blue}{\texttt{[Problem]}}$

- 给你一个含有 $n$ 个点 $m$ 条有向边的图，每条边有两个值：$v$ 和 $p$，分别表示这条路的价值和花费。
- 一条路的收益定义为所有边的 $v$ 值的和比上 $p$ 值的和。
- 求一条没有相同的边的环，使得其收益最大。

--------------------------------------

$\color{blue}{\texttt{[Solution]}}$

**二分答案。**

记当前二分出来的值为 $\texttt{mid}$，表示总收益 $\geq \texttt{mid}$。

如果满足，则：

$$\begin{aligned}
\dfrac{\sum v}{\sum p} &\geq \texttt{mid}\\
\sum v &\geq \texttt{mid}\times \sum p\\
\texttt{mid}\times \sum p &\leq \sum v\\
\texttt{mid} \times \sum p - \sum v &\leq 0
\end{aligned}$$

于是，我们修改每条边的边权为 $\texttt{mid} \times p - v$ 即可，求负环即可。

注意，`bfs spfa` 求负环的时间复杂度为 $O(nm)$，可能会超时，所以我们赌一把，用时间复杂度不稳定的 `dfs spfa`。

--------------------------------------

$\color{blue}{\texttt{[code]}}$

```cpp
const int M=20100,N=7010;
struct edge{//链式前向星 
	int next,to,v,p;
}e[(M<<1)+N];int h[N],tot,n,m;
void add(int a,int b,int c,int d){
	e[++tot]=(edge){h[a],b,c,d};h[a]=tot;
}
bool vis[N];double dis[N],l,r,mid;
inline bool dfs(int u,double mid){
	vis[u]=true;register int i;
	for(i=h[u];i;i=e[i].next){
		register int to=e[i].to;
		double w=e[i].p*mid-e[i].v;
		if (dis[to]>dis[u]+w){
			dis[to]=dis[u]+w;
			if (vis[to]) return true;
			if (dfs(to,mid)) return true;
		}
	}
	vis[u]=false;
	return false;
}
inline bool check(double mid){
	memset(dis,127,sizeof(dis));
	memset(vis,false,sizeof(vis));
	dis[0]=0;//注意特别初始化dis[0] 
	return dfs(0,mid);//返回spfa结果 
}
const double eps=1e-5;
int main(){
	scanf("%d%d",&n,&m);//点数;边数 
	for(int i=1,a,b,v,p;i<=m;i++){
		scanf("%d%d%d%d",&a,&b,&v,&p);
		add(a,b,v,p);//往图中加边 
	}
	for(int i=1;i<=n;i++)
		add(0,i,0,0);//超级源 
	l=0;r=200;//初始二分上下界 
	while (l+eps<r){//注意精度 
		mid=(l+r)/2;//求出中点 
		if (check(mid)) l=mid;
		else r=mid;//修改边界 
	}
	if (l==0) printf("-1");
	else printf("%.1lf",l);
	return 0;
}
```

---

## 作者：沉辰 (赞：0)

 吐槽：

开始变量名打错了，debug半小时，气死我了。

这告诉我们做题尤其是打代码一定要细心。

 

解：
根据题面则有Σvi/Σpi=r
=> Σvi=Σpi * r 
如果r不是最优解，那么一定有 
Σpi * r -Σvi <=0
即图中的环的满足以下性质。
对于r,我们可以二分答案，那么此时
每条边的边权为pi*r - vi
那么如果在此时的图中存在负环，说明r偏小就调大。
否则调小。
[代码](http://www.cnblogs.com/adelalove/p/8493662.html)

---

## 作者：vani_prcups (赞：0)

题目可以总结为：存在一个环，使sum(v)/sum(w)==ans，求最小的ans。式子整理得sum(v)-ans\*sum(w)<=0。

然后我就错误地开始了以下尝试——

二分ans，并用（dfs式）SPFA判负环。如果存在负环，则减小答案，否则增大答案。

然而那是<=，不是<！

所以正确的式子应该是ans\*sum(w)-sum(v)>=0，即不存在负环。

还有一个难点：枚举答案时有小数。这时我的标准二分模板就没用了，需要这样：

```cpp
while (l+0.01<r)//0.01的精度控制 
{
    mid=(l+r)>>1;
    if (check(mid))
    {
        ans=mid;
        r=mid;
    }
    else l=mid;
}
```
代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
struct node
{
    int t,nt;
    double v1,v2;
}a[400005];
int n,m,len,head[200005],visited[200005],flag;
double dis[200005];
void spfa(double now,int x)//DFS的SPFA
{
    if (flag)return;
    visited[x]=1;
    for (int i=head[x];i;i=a[i].nt)
    {
        if (dis[a[i].t]>dis[x]+now*a[i].v2-a[i].v1)
        {
            dis[a[i].t]=dis[x]+now*a[i].v2-a[i].v1;
            if (visited[a[i].t]==0)spfa(now,a[i].t);
            else
            {
                flag=1;//找到环
                return;
            }
        }
    }
    visited[x]=0;
}
bool check(double now)
{
    flag=0;
    memset(dis,0,sizeof(dis));
    memset(visited,0,sizeof(visited));
    for (int i=1;i<=n;i++)
    {
        spfa(now,i);
        if (flag)break;//找到环就退出
    }
    if (flag)return true;//找到环真好，ans降低（使结果最大） 
    return false;
}
int main()
{
    scanf("%d %d",&n,&m);
    int u,v;
    double w1,w2;
    for (int i=1;i<=m;i++)
    {
        scanf("%d %d %lf %lf",&u,&v,&w1,&w2);
        a[++len].t=v;
        a[len].v1=w1;
        a[len].v2=w2;
        a[len].nt=head[u];
        head[u]=len;
    }
    //接下来二分答案
    double l=0,r=200.0,mid;
    while (l+0.01<r)//精度控制 
    {
        mid=(l+r)/2;
        if (check(mid))l=mid;
        else r=mid;
    }
    if (l==0)printf("-1");
    else printf("%.1lf",r);
    return 0;
}
```

---


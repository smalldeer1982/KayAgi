# 弹幕考察

## 题目背景

zeromaker 是个手残，但是他喜欢玩东方 project，ex 什么的最喜欢了


## 题目描述

zeromaker 对弹幕的视野控制有着深刻的研究。 每个弹幕在一段特定的时间内会出现在 zeromaker 的视野内，除此之外的时间都在 zeromaker 看不到的地方。在 zeromaker 看来，视野内的弹幕数量越多，图就越难，因为这意味着 @#￥%。 现在，zeromaker 想要评测这张图的难度，他已经知道了每个弹幕会在什么时候出现在视野内，他想知道，在一段时间内，总共有多少个弹幕出现在他的视野内过。

## 说明/提示

- $30\%$ 的数据：$n,m \le 10^3$。
- $100\%$ 的数据：$1 \le n,m \le 10^5$，$0 \le x,y,a,b \le 2^{31}-1$。

## 样例 #1

### 输入

```
3 2
2 5
0 10
5 8
0 6
8 2```

### 输出

```
3
2```

## 样例 #2

### 输入

```
1 2
0 10
9 1
10 1```

### 输出

```
1 
0
```

# 题解

## 作者：liuyi0905 (赞：7)

# P2650 solution:
### [题目传送门](/problem/P2650)
这道题其实很简单，可以将每个弹幕的左端点放到右端点后面，最后询问的时候，只需要二分查找一下，用左端点查找到的答案去减去右端点查找的答案，就是可见弹幕的数量了。~~佩服楼下用主席树写的大佬~~

题目中还有一句话：
+ 注意：查询区间为**左闭右闭**，弹幕出现区间为**左开右开**。

所以将弹幕左端点移到右边时，别忘了减 $1$，在询问时，则不需要减。

还有一点，$0\le ,y,a,b\le2^{31}-1$，别看这些数在 `int` 范围内，但 `INT_MAX` + `INT_MAX` 可就超出了 `int` 的范围，所以一定要开 `long long`。

代码如下：
```cpp
#include <bits/stdc++.h>
#define int long long//会将程序了所有int转换成long long
#define N 100005
using namespace std;
int n,m,l[N],r[N],lt,rt;
signed main(){//因为main的返回值必须用int，所以这里写成了signed
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>l[i]>>r[i],r[i]+=l[i]-1;//记住这里还要减一
    sort(l+1,l+n+1),sort(r+1,r+n+1);//必须满足单调性才能二分
    while(m--){
        cin>>lt>>rt,rt+=lt;//询问时也要将左端点移到右端点后面
        cout<<signed(lower_bound(l+1,l+n+1,rt)-l)-signed(lower_bound(r+1,r+n+1,lt)-r)<<"\n";
        //这里偷个懒，直接用库函数解决二分，STL大法好~
    }
    return 0;
}
```

---

## 作者：JohnJoeZhu (赞：7)

~~竟然只有1篇题解？~~

前排提示:本蒟蒻在这里挖了很多坑待填，但是思路的清晰的

[题面传送门](https://www.luogu.com.cn/problem/P2650)

看到求区间不重复的区间个数，常规的做法就是是**离线**

对于一个弹幕区间，可以抽象为左括号与右括号

我们并且把询问区间的左右边界叫做左右端点

从后往前加入弹幕，保证右括号都在询问区间的左端点后，拿树状数组维护左括号的加入，查询右端点前的左括号个数

~~建议画数轴理解，蒟蒻CSP后就来补图~~

其实就是在保证右括号在左端点的后面，左括号在右端点的前面，这样就看得到这个弹幕

当然可以换一种枚举方式，就可以得到从前往后加入

从前往后加入询问区间右端点以前的左括号，拿树状数组维护右括号的加入，查询左端点以后的右括号个数

本质是相同的

时间复杂度是$O(nlogn)$

这里的实现可以参考另一篇题解

~~再次挖坑，CSP后补~~

还有**在线**算法!

利用主席树解决

对于查询的区间，询问$\sum_{i=1}^{k}[r[i]>=L[i]]$

其中$k$为满足$l[i]<=R[i]$的最大的$i$

$k$可以将弹幕排序后二分查找

使用主席树查询

复杂度应该是$O(nlog^2n)$

ps:这个思路的代码太毒瘤了，就当思路理解，更优的是下面的方法

另一种更简洁的思路是

对于一个区间可见的弹幕等价于该区间右端点前左括号的个数减去左端点前右括号的个数

就是统计有多少区间对答案有贡献

~~然后就有一些做法用两棵树状数组维护去了的，显然没有必要~~

显然我们可以对括号排序后二分得到

时间复杂度$O(nlogn)$
	
这个思路的参考代码
```cpp
	for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]),r[i]=l[i]+r[i]-1;//这里要注意区间边界问题
	sort(l+1,l+1+n);
	sort(r+1,r+1+n);
	for(int i=1,ll,rr;i<=m;i++)
	{
		scanf("%d%d",&ll,&rr);
		rr=ll+rr;
		int ans=lower_bound(l+1,l+1+n,rr)-l;
		ans-=lower_bound(r+1,r+1+n,ll)-r;
		printf("%d\n",ans);
	}
```



------------
[小广告](https://www.luogu.com.cn/blog/JohnJoeZHU/guan-yu-yi-lei-shuo-ju-jie-gou-ti-mu-di-sai-kao):同是去重问题的整理

这里的坑蒟蒻CSP后一定会来补的！

---

## 作者：Wi_Fi (赞：4)

题目比较简单，思路还是很清晰的。

显然对于每次询问，答案就是弹幕总数减去在查询区间右端点后才出现的，再减去在查询区间左端点就结束的。  
简化一下，可以变成在查询区间右端点前出现的减去在查询区间左端点前就结束的。

很显然我们可以用 $O(n \log n)$ 的时间复杂度二分解决该问题。为了方便，我们可以用 ```lower_bound``` 简化代码。

一个坑点就在于，由于弹幕出现区间为左开右开，所以在计算弹幕有右端点是需要额外减 $1$。然后就没了。

代码如下：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+5;
int i,n,m,l[N],le,r[N],x,y;
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>l[i]>>le;
		r[i]=l[i]+le-1;
	}
	sort(l+1,l+n+1);
	sort(r+1,r+n+1);
	while(m--)
	{
		cin>>x>>le;
		y=x+le;
		cout<<(lower_bound(l+1,l+n+1,y)-l)-(lower_bound(r+1,r+n+1,x)-r)<<"\n";
	}
	return 0;
}
```


---

## 作者：ZHANGyutao123 (赞：3)

# 题目大意
题目的意思非常的简单。

给出 $n$ 个区间 $[l,r]$，以及 $m$ 次询问在区间 $[x,y]$ 中出现的区间总数。

# 思路
对于一个区间 $[x,y]$ 中可见的区间 $[l,r]$ 的个数其实等价于区间 $[x,y]$ 右端点前左端点的个数减去左端点前右端点的个数。有一点小绕，下面解释一下这段话的意思。

如果区间 $[l,r]$ 在区间 $[x,y]$ 中可见，那么有三种情况：

1. 
![](https://cdn.luogu.com.cn/upload/image_hosting/qcyzh0dv.png)
2. 
![](https://cdn.luogu.com.cn/upload/image_hosting/x1g99ena.png)
3. 
![](https://cdn.luogu.com.cn/upload/image_hosting/za74k7j7.png)

不难发现 $l$ 都在 $y$ 之前，$r$ 都在 $x$ 与 $y$ 中间，也就是上面那段话的意思。

用二分查找防止超时。

# 注意点


- 查询区间为**左闭右闭**，弹幕出现区间为**左开右开**。~~害人不浅！~~

- $ x,y,a,b \le 2^{31}-1$。所以要开 `long long`。

# 代码

```cpp
scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%lld%lld", &l[i], &r[i]);
        r[i] += (l[i] - 1);  
    }
    sort(l + 1, l + 1 + n);  
    sort(r + 1, r + 1 + n);  
    for (int i = 1; i <= m; i++) {
        long long left, right;
        scanf("%lld%lld", &left, &right);
        right += left;
        long long ans = lower_bound(l + 1, l + 1 + n, right) - l - (lower_bound(r + 1, r + 1 + n, left) - r); 
        printf("%lld\n", ans); 
    }
```
复杂度约为 $O(m \log{n})$。


---

## 作者：hewo (赞：2)

先把时间转化为线段上的区间思考。

看见区间内的统计，考虑找到一种可以快速维护的关系。

我们可以想到，对于区间 $[l,r]$，ans 就等于左端点右侧的结束时刻数 - 右端点右侧的开始时刻个数，大家可以自己画图模拟一下。

简单的证明一下的话，可以看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3f07v75q.png)

每个红色线段对应一个弹幕，可以看出一共就几种情况。当在左端点后面结束时，说明有可能有贡献，如果还在右端点前开始，才能说明一定有贡献（嘴笨，大家看不懂可以看图）。

数据先离散化一遍（记住要连着询问一起）。

想到这里就简单了，区间和可以用前缀和维护，复杂度瓶颈反而在离散化上了。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MX=4*100000+1000;
#define LL long long
#define inf 0x3f3f3f3f

#define lson now<<1
#define rson now<<1|1

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n,m;

struct tDM
{
	int l,r;
}w[MX];

struct tQuery
{
	int l,r;
	int id;
}query[MX];

std::vector<int> v;

int maxn=-1;

inline void lsh()
{
	sort(v.begin(),v.end());
	unique(v.begin(),v.end());
	std::vector<int>::iterator new_end=unique(v.begin(),v.end());
	v.erase(new_end,v.end());
	// for(std::vector<int>::iterator it=v.begin();it!=v.end();it++) printf("%d ",*it);
	// printf("\n");
	for(int i=1;i<=n;i++)
	{
		w[i].l=lower_bound(v.begin(),v.end(),w[i].l)-v.begin()+1;
		w[i].r=lower_bound(v.begin(),v.end(),w[i].r)-v.begin()+1;
		maxn=max(maxn,max(w[i].l,w[i].r));
		//printf("%d %d\n",w[i].l,w[i].r);
	}
	for(int i=1;i<=m;i++)
	{
		query[i].l=lower_bound(v.begin(),v.end(),query[i].l)-v.begin()+1;
		query[i].r=lower_bound(v.begin(),v.end(),query[i].r)-v.begin()+1;
		//printf("%d %d\n",query[i].l,query[i].r );
		maxn=max(maxn,max(query[i].l,query[i].r));
	}
}

int s[2][MX];

inline int get_sum(int x,int l,int r)
{
	return s[x][r]-s[x][l-1];
}

int main(int argc, char const *argv[])
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		w[i].l=read(),w[i].r=w[i].l+read()-1;
		v.push_back(w[i].l),v.push_back(w[i].r);
	}	
	for(int i=1;i<=m;i++)
	{
		query[i].l=read(),query[i].r=query[i].l+read();
		query[i].id=i;
		v.push_back(query[i].l),v.push_back(query[i].r);
	}
	lsh();
	for(int i=1;i<=n;i++)
	{
		s[0][w[i].l]++,s[1][w[i].r]++;
	}
	for(int i=1;i<=maxn;i++)
	{
		s[0][i]+=s[0][i-1];
		s[1][i]+=s[1][i-1];
	}
	for(int i=1;i<=m;i++)
	{
		int nl=query[i].l,nr=query[i].r;
		printf("%d\n",get_sum(1,nl,maxn)-get_sum(0,nr,maxn));
	}
	return 0;
}
```

---

## 作者：zhrrrr (赞：2)

“在线主席树，离线树状树。”

这道题没有强制在线，直接使用树状数组统计答案。

注意到数据范围，读入时先进行离散化。

然后从后往前维护树状数组，统计答案。

丑陋代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>void read(T &x){
	char c=getchar();x=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
}
const int N=1e6+7;
int n,m,ans[N],tr[N],tot,a[N];
struct OO{int l,r;}x[N];
struct DD{int l,r,id;}q[N];
bool cmp(OO a,OO b){return a.r>b.r;}
bool cmp2(DD a,DD b){return a.l>b.l;}
inline int lb(int x){return x&(-x);}
inline void ad(int x){for(int i=x;i<=N;i+=lb(i))tr[i]++;}
inline int que(int x){int an=0;for(int i=x;i;i-=lb(i))an+=tr[i];return an;}
int main(){
	read(n);read(m);
	for(int i=1;i<=n;i++){
		read(x[i].l),x[i].l++,read(x[i].r),x[i].r+=x[i].l;
		a[++tot]=x[i].l;a[++tot]=x[i].r;
	}sort(x+1,x+n+1,cmp);
	for(int i=1;i<=m;i++){
		read(q[i].l),q[i].l++,read(q[i].r),q[i].r+=q[i].l,q[i].id=i;
		a[++tot]=q[i].l;a[++tot]=q[i].r;
	}sort(q+1,q+m+1,cmp2);
	sort(a+1,a+tot+1);tot=unique(a+1,a+tot+1)-a-1;
	for(int i=1;i<=n;i++){
		x[i].l=lower_bound(a+1,a+tot+1,x[i].l)-a;
		x[i].r=lower_bound(a+1,a+tot+1,x[i].r)-a;
	}
	for(int i=1;i<=m;i++){
		q[i].l=lower_bound(a+1,a+tot+1,q[i].l)-a;
		q[i].r=lower_bound(a+1,a+tot+1,q[i].r)-a;
	}
	int j=1;
	for(int i=1;i<=m;i++){
		while(x[j].r>q[i].l)ad(x[j++].l);
		ans[q[i].id]=que(q[i].r-1);
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：EntimE (赞：1)

## 思路
因为一个区间中可以看见的弹幕等于这个区间右端点前的左括号的个数减去左端点前的右括号的个数。所以直接排序，再二分一下并将 2 个数组相减就行了。（十分敬佩写主席树的那位大佬）

注意：**查询区间**为**左闭右闭**，**弹幕出现区间**为**左开右开**。

所以将弹幕左端点移到右边时，别忘了减 1，在询问时，则不需要减。

## 上代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int l[100005],r[100005];
signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>l[i]>>r[i];
        r[i]+=l[i]-1;
    }
    sort(l+1,l+1+n);
    sort(r+1,r+1+n);
    for(int i=1;i<=m;i++)
    {
        int l1,r1;
        cin>>l1>>r1;
        r1+=l1;
        int a=signed(lower_bound(l+1,l+n+1,r1)-l);
        int b=signed(lower_bound(r+1,r+n+1,l1)-r);
        cout<<a-b<<endl;
    }
}
```


---

## 作者：huangmingyi (赞：1)

 $30$ 分思路:  
对于 $m$ 个区间，枚举 $n$ 个区间判断与它是否重合，但是最大 $n \times m$ 也就是 $100000 \times 100000$ 显然会超时。   
 $100$ 分思路：   
把 $n$ 个区间存入 $l$ ， $r$ 树组里，从小到大排序，对于每个询问 $x$，$y$ ,二分找 $l$ 树组里第一个小于 $y$ 的数的下标，假设为$ans1$ ，在 $r$ 树组二分里找第一个小于 $x$ 的数的下标，假设为  $ans2$ 。 $ans1 -ans2$ 即为答案。
这个思路的原理其实是把区间两个端点抽象成数轴上的括号,当找 $l$ 树组里第一个小于 $y$ 的数的下标时，其实是找 $y$ 左边区间的数量，排除 $y$ 右边区间的数量在 $r$ 树组里找第一个小于 $x$ 的数的下标,其实是找左边与询问区间无交集的区间数量，可以求得 $x$ 左边的无交集区间数量。两个答案相减，可以得到与 $x$ ， $y$ 有交集的数量。代码如下。
```
#include <bits/stdc++.h>//万能头
using namespace std;
long long l[100005], r[100005];
int main(){
    int n, m;
    cin>>n>>m;
    for(long long i=1;i<=n;i++) {
        cin>>l[i]>>r[i];//输入
        r[i]+=l[i]-1;
    }
    sort(l+1,l+1+n);//快排
    sort(r+1,r+1+n);//快排
    for(long long i=1;i<=m;i++){
        long long lt, rt;//定义
        cin>>lt>>rt;//输入
        rt+=lt;
        long long ans=lower_bound(l+1,l+1+n,rt)-l; //返回值是一个迭代器,返回指向大于等于key的第一个值的位置。定义ans。
        ans-=lower_bound(r+1,r+1+n,lt)-r;//返回值是一个迭代器,返回指向大于等于key的第一个值的位置
        cout<<ans<<endl;//输出
    }
    return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：1)

## P2650 弹幕考察 题解
### 思路：
一个区间中可以看见的弹幕等于这个区间右端点前的左括号的个数减去左端点前的右括号的个数。于是我们可以对每条弹幕开始出现的时间和结束的时间当做两个数组，然后把两个数组排序，最后再二分一下两个数组并求二分后得到的答案的差（可以用 STL 大法）就能 AC 了。（佩服用主席树写的大佬%%%）
### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long//作者习惯
using namespace std;
int l[100005], r[100005];
signed main()//开了 define 一定要用 signed main！！！不然直接 CE（别问我怎么知道的） 
{
    int n, m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
    {
        cin>>l[i]>>r[i];
        r[i]+=l[i]-1;
    }
    sort(l+1,l+1+n);
    sort(r+1,r+1+n);
    for(int i=1;i<=m;i++)
    {
        int lt, rt;
        cin>>lt>>rt;
        rt+=lt;
        int ans=lower_bound(l+1,l+1+n,rt)-l; 
        ans-=lower_bound(r+1,r+1+n,lt)-r;
        cout<<ans<<endl;
    }
    return 0;
}

---


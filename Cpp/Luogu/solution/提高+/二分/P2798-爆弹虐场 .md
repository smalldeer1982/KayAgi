# 爆弹虐场 

## 题目描述

某年某月某日，Kiana 结识了一名爆弹虐场的少年。

Kiana 仗着自己多学了几年OI，所以还可以勉勉强强给这位少年 讲一些自己擅长的题。具体来说，Kiana 先给这位少年灌输了n 个毫不相干的知识点，然后再通过自己的[数据删除]技术把这些知识点强行联系在一起。


由于这位少年有着爆弹虐场的实力，所以对于每个Kiana 准备强行构造的联系，他都能够自己想出来，不过会花费更多的时间。具体来说，Kiana 一共有m 个联系，每个联系可以把两个不相干的知识点连在一起，如果由Kiana 直接来讲第i 个联系，需要花费ti 的时间， 而如果由少年自己想出来，则需要花费Ti 的时间。


为了偷懒，Kiana 只需要自己讲的或少年想出来的联系能刚好把知识点全部直接或间接串在一起就可以了。但为了保证教学质量， Kiana 觉得至少有k 个联系需要少年自己想出来。由于Kiana 耐心有限，她希望无论是自己讲或是少年自己想，构造的联系中花费时间最长的一个用时最短。


现在Kiana 想知道，满足这些条件的情况下，构造的联系中耗时最长的一个的最短用时是多少。由于她不会算，所以希望由你告诉她。


## 说明/提示

对于30%的数据，1<=n<=10，n-1<=m<=15，

对于60%的数据，1<=n<=500，n-1<=m<=1000，

对于100%的数据，1<=k<n<=10000，n-1<=m<=20000，


1<=ti<Ti<=10^6。 

数据保证一定存在可行解。


## 样例 #1

### 输入

```
4 2 5 
1 2 6 5 
1 3 3 1 
2 3 9 4 
2 4 6 1 
3 4 4 2 
```

### 输出

```
4```

# 题解

## 作者：D10s (赞：14)

本题也可采取图论做法，相当于是双边权情况下的最小生成树。

因为题目保证t<T,所以边权取T的边不可能超过k条（超过的拿t替换更优）。

这样我们只要在克鲁斯卡尔的时候前k条边用T扩展，后n-1-k条用t即可，记录最大边权。

```cpp
#include<cstdio>
#include<queue>
using namespace std;
struct edge{
    int u,v,t,T;
}e;
struct cmp1{bool operator () (edge a,edge b) {return a.t>b.t;} };
struct cmp2{bool operator () (edge a,edge b) {return a.T>b.T;} };
priority_queue<edge,vector<edge>,cmp1> q1;
priority_queue<edge,vector<edge>,cmp2> q2;
int fa[10005];
int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
int max(int x,int y) {return x>y?x:y;}
int main()
{
    int n,m,k;
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int j=1;j<=m;j++)
    {
        scanf("%d%d%d%d",&e.u,&e.v,&e.T,&e.t);
        q1.push(e);q2.push(e);
    }
    m=0;int ans=0;
    while(q2.size()&&m<k)
    {
        e=q2.top();q2.pop();
        int x=find(e.u),y=find(e.v);
        if(x==y) continue;
        ans=max(ans,e.T);
        m++;
        fa[x]=y;
    }
    while(q1.size()&&m<n-1)
    {
        e=q1.top();q1.pop();
        int x=find(e.u),y=find(e.v);
        if(x==y) continue;
        ans=max(ans,e.t);
        m++;
        fa[x]=y;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：liaoy14866 (赞：5)

解法应该是比较简单的。


二分答案，贪心选择“少年”可以选择的边，之后再选择Kiana需要选择的边（应该是需要按照这个顺序处理的，否则应该会WA，但是数据有点怪怪的也不知道标程怎么跑的）。


如果最后“少年”可以选择超过k条边，且这张图连通（并查集），说明当前的答案可行，否则不可行。


由于答案一定是边权中的一个，所以可以开个数组储存下边权，在这个数组里面二分。


---

## 作者：sto_5k_orz (赞：4)

二分答案 + 最小生成树。

每一条边都有两条边权。

最大值最小，显然是个二分答案。

二分时先选 $T_i$，再选 $t_i$。

考虑到每条边都有两条边权，那么二分的答案 $x$ 必须满足有 $\ge k$ 条边选了 $T_i$。

如果说没有 $k$ 条边能够选 $T_i$，直接寄，如果直接构成了生成树，直接 OK。

那么继续选 $t_i$，必须要形成生成树，否则寄。

那么判生成树可以考虑用并查集的方法解决。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20010; struct edge {int a, b, C, c;} e[N]; int n, rt[N], m, k;
bool cmp1(edge a, edge b) {return a.C < b.C;}
bool cmp2(edge a, edge b) {return a.c < b.c;}
int find(int x) {return rt[x] == x ? x : rt[x] = find(rt[x]);}
bool check(int x) {
	for(int i = 1; i <= n; i++) rt[i] = i; sort(e + 1, e + 1 + m, cmp1); int cnt = 0;
	for(int i = 1; i <= m; i++) {
		if(e[i].C > x) break; int x = find(e[i].a), y = find(e[i].b);
		if(x != y) {rt[y] = x; cnt++;}
	}
	if(cnt == n - 1) return 1; if(cnt < k) return 0; sort(e + 1, e + 1 + m, cmp2);
	for(int i = 1; i <= m; i++) {
		if(e[i].c > x) break; int x = find(e[i].a), y = find(e[i].b);
		if(x != y) {rt[y] = x; cnt++;}
	}
	return cnt == n - 1;
}
signed main() {
	scanf("%d%d%d", &n, &k, &m); for(int i = 1; i <= m; i++) scanf("%d%d%d%d", &e[i].a, &e[i].b, &e[i].C, &e[i].c);
	int l = 1, r = 2e6, ans = -1;
	while(l <= r) {
		int mid = l + r >> 1;
		if(check(mid)) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：RikoHere (赞：4)

不想看题面的同学可以看完翻译再去做题

题目大意:无向图有n个点,m条边,每条边有两个权值,分别称为T和t，先要从m条边中连点成连通图，要求图中权值最大的边权值尽量小，每条边所选择的权值是T[i]还是t[i]自由，但是要求使用T[i]的使用次数大于等于k次

虽然题面里说"时间很宝贵"之类的描述，但实际上并没有对所用边的权值和有什么区别，根据这道题的描述我们总结出以下几点

1. 二分答案，二分的是生成图中权值最大边的权值

2. 本题没有严谨要求一定要使用m-1条边，所以存在情况已经生成树后任然可以使用边来达到使用T[i]次数k次以上的要求

3. 同理于2，对任何符合条件的边我们都可以连起来，最后只需要判断图连通性即可

虽然翻了几篇代码都是直接当使用m-1条边来做的，但我重写代码却WA掉了一个点，我认为这是很重要的一点，这种特殊情况在本题中存在明显是合法的，需要去考虑

代码:

```

//2018/12/1->NHDR233->AtHM->luoguP2798
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define LL long long
using namespace std;
inline int read() {
    static int n, ch;
    n = 0; ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) n = n*10+ch-'0', ch = getchar();
    return n;
}
void smax(int& x, int y) {if (x < y) x = y;}
int n, m, lef, rig, num, father[10100];
struct node {
    int u, v, t1, s1;
} k[20200];
void init() {
    n = read(); num = read(); m = read();
    for (int i = 1; i <= m; ++i) {
        k[i].u = read();
        k[i].v = read();
        k[i].t1 = read();
        k[i].s1 = read();
        smax(rig, k[i].t1);
        smax(rig, k[i].s1);
    }
}
void setfather() {for (int i = 1; i <= n; ++i) father[i] = i;}
int find(int x) {
    if (father[x] != x) father[x] = find(father[x]);
    return father[x];
}
int main() {
    init();
    while (lef+1 < rig) {
        int cnt = 0, picnt = 0;
        int mid = (lef+rig)>>1;
        setfather();
        for (int i = 1; i <= m; ++i) {
            int u = find(k[i].u);
            int v = find(k[i].v);
            if (k[i].t1 <= mid) cnt++;
            if (u != v) {
                if (k[i].t1 <= mid or k[i].s1 <= mid) {
                    picnt++;
                    father[u] = v;
                }
            }
        }
        if (cnt < num or picnt < n-1) {
            lef = mid;
        }else {
            rig = mid; }
    }
    printf("%d", rig);
}

```

总结:二分是好想的，问题是是否构建出特殊数据

---

## 作者：Treaker (赞：3)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 二分答案 + 最小生成树
首先最大值最小，显然是个二分答案。

其次，把所有的知识点全部串起来的意思，其实就是形成一棵树，自然想到最小生成树。

然后题目要求我们，必须有k个是少年想出来的，所以我们先对少年跑克鲁斯卡尔，一直到不满足二分的mid为止，然后判断一下。

再对其他的情况跑克鲁斯卡尔即可。

具体实现可以看代码，应该不是很难懂的吧

献上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int read()
{
	int x = 0 , f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + ch - '0'; ch = getchar();}
	return x * f;
}
const int inf = 1e9 , N = 1e4+5;
int n , k , m , ans;
int fa[N];
struct edge{int x , y , T , t;}e[N << 1];
bool cmp1(const edge &a,const edge &b) {return a.T < b.T;}
bool cmp2(const edge &a,const edge &b) {return a.t < b.t;}
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
inline bool check(int mid)
{
	for(int i = 1;i <= n;i ++) fa[i] = i;
	sort(e + 1,e + 1 + m,cmp1); int tot = 0 , cnt = 0;
	for(int i = 1 , x , y;i <= m;i ++)
	{
		if(e[i].T > mid) break;
		tot ++; x = find(e[i].x); y = find(e[i].y);
		if(x == y) continue;
		cnt ++; fa[x] = y;
	}
	if(tot < k) return 0;
	if(cnt == n - 1) return 1;
	sort(e + 1,e + 1 + m,cmp2);
	for(int i = 1 , x , y;i <= m;i ++)
	{
		if(e[i].t > mid) break;
		x = find(e[i].x); y = find(e[i].y);
		if(x == y) continue;
		cnt ++; fa[x] = y;
		if(cnt == n - 1) return 1;
	}
	return 0;
}
int main()
{
	n = read(); k = read(); m = read(); int L = inf , R = 0;
	for(int i = 1;i <= m;i ++) e[i].x = read() , e[i].y = read() , e[i].T = read() , e[i].t = read() , L = min(L,min(e[i].T,e[i].t)) , R = max(R,max(e[i].T,e[i].t));
	while(L <= R)
	{
		int mid = (L + R) >> 1;
		if(check(mid)) ans = mid , R = mid - 1;
		else L = mid + 1;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Sky_Art (赞：2)

# 二分答案 + 克鲁斯卡尔

### 一开始把 二分的 R 边界打小了，一直错，
### 改过了 发篇题解纪念


------------

```c

题意：
m条边，每条边有两个权值Ti和ti，要求在将整个图连完（树）的
情况下，权值最大的边的权值最小，且图中一定要连上 k 个以Ti
为边权的边
ps.一般最大值最小的，最小值最大的，都是二分
```


------------

```c
#include<bits/stdc++.h>
#define maxn 50000
using namespace std;
int n,k,m,tot=0; 
int f[maxn],cnt;

struct s{
	int u,v,t,T;
}d[maxn];

int find(int x)//找根
{
	if(x==f[x]) return x;
	f[x]=find(f[x]);
	return f[x];
}

void hc(int x,int y)
{
	f[x]=y;
}

bool cmp1(s x,s y)
{
	if(x.T==y.T) return x.t<y.t;
	return x.T<y.T;
}

int pd(int mid)//克鲁斯卡尔
{
	for(int i=1;i<=m;i++)
	{
		int x=d[i].u,y=d[i].v,w1=d[i].T,w2=d[i].t;
		int fx=find(x);
		int fy=find(y);
	if(mid<min(w1,w2)) continue;//如果最大值比当前边的权值小了，则不满足 
		if(fx!=fy)//两点还没有边连             
		{
			hc(fx,fy);//连上
			if(w1<=mid)//如果Ti小于最大值则可以连
		    {
			   cnt++;//每连上一条以Ti为权的边，计数
		    }
			tot++;//连上的总边数
		}
		if(tot==n-1) break;//是否联通
	}
    
	if(cnt<k) return 0;//以Ti为权的边数不够，说明mid小了
	else if(tot<n-1) return 0;//树没联通，说明mid小了
	else return 1; //都满足，继续逼近，缩小
}

int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d",&d[i].u,&d[i].v,&d[i].T,&d[i].t);
	}
	sort(d+1,d+m+1,cmp1);
	int l=0,r=2000000+5,mid;//r一定要开够
	while(l<=r)//二分
	{
		mid=(l+r)/2;
		if(pd(mid)) r=mid-1;
		else l=mid+1;
		for(int i=1;i<=n;i++) f[i]=i;//初始
		cnt=0;//清零
		tot=0;//同上
	}
	printf("%d",l);
	return 0;//完结
}
```



---

## 作者：hzx360 (赞：1)

前言：感谢管理员大大百忙中审核 MnZn 题解。


------------
这题就是披着蓝色外衣的水题 QAQ。


题目说要保证至少有 $k$ 条**少年自己想到的边**，然后又注意到这样一个性质： $t_i \leq T_i$ 。

所以既然我们已经选了 $k$ 条**大边**了，已经满足题目要求了，为什么后面的边全部用小边呢？

具体做法就是将**小边**和**大边**分别扔到两个堆里，从小边所在的堆选 $k$ 条边，然后剩下边在大边的堆里补充。

code：
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+100;
int n,k,m,cnt,fa[N],ans;
struct edge{
	int u,v,t;
	bool operator <(edge it)const{return t>it.t;}
}e[N];
priority_queue<edge>q1;
priority_queue<edge>q2;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y,int z){
	int X=find(x),Y=find(y);
	if(X==Y) return;
	cnt++,ans=max(ans,z);
	fa[max(X,Y)]=min(X,Y);
}
int main(){
	cin>>n>>k>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v,T,t;
		cin>>u>>v>>T>>t;
		q1.push((edge){u,v,T});
		q2.push((edge){u,v,t});
	}
	for(int i=1;i<=m;i++){
		edge now=q1.top();q1.pop();
		merge(now.u,now.v,now.t);
		if(cnt==k) break;
	}
	for(int i=1;i<=m;i++){
		edge now=q2.top();q2.pop();
		merge(now.u,now.v,now.t);
		if(cnt==n-1) break;
	}
	cout<<ans;
}

---

## 作者：rfsfreffr (赞：1)

~~所以这道题与二分答案有什么关系~~

这道题实际上就是一道最小生成树。

我们要求的是**构造的联系中耗时最长的一个的最短用时**。可以考虑最小生成树。

题目又说有k个关系要少年自己想，我们可以采用贪心的想法，**将自己想的最小的k个关系相连**,同时使用并查集判断是否联通，再在Kiana讲解的关系时间中跑最想生成数就可以。

# 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,m;
struct oi{//利用结构体存储每种关系
	int u,v,t,T;
};
oi a[20001];
int f[100001];
bool cmp(oi x,oi y){
	return x.T<y.T;
}
bool cmp2(oi x,oi y){
	return x.t<y.t;
}
int find(int k){
	if(f[k]==k) return f[k];
	f[k]=find(f[k]);
	return f[k];
}
int main(){
	cin>>n>>k>>m;
	for(int i=1; i<=m; i++){
		scanf("%d%d%d%d",&a[i].u,&a[i].v,&a[i].T,&a[i].t);
	}
	int ans=0;
	for(int i=1; i<=n; i++) f[i]=i;//初始化并查集
	sort(a+1,a+1+m,cmp);//对Ti排序
	for(int i=1; i<=k; i++){//将少年自己想的k个关系连接
		f[find(a[i].u)]=find(a[i].v);
		ans=max(ans,a[i].T);	
	}
	sort(a+1,a+1+m,cmp2);//对ti排序
	for(int i=1; i<=m; i++){//跑最小生成树
		int x=find(a[i].u);
		int y=find(a[i].v);
		if(x!=y){
			f[x]=y;
			ans=max(ans,a[i].t);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：chenlingxi (赞：1)

由题目中“耗时最长的一个的最短用时”可知本题是二分答案

显然要二分最长边然后check

当check一个数t时

首先优先考虑Ti<t，在我的代码中就是num

num加上所有可能情况显然不会变得更差（贪心）

然后再考虑ti<t，代码中为s（s加了前面的num）

如果所有可能情况不到n-1（s<n-1）或者num< k

那么就返回false

否则就是true
                            
code：
                            
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m;
struct node
{
	int from,to,d1,d2;
}a[20005];
int f[20005];
int find(int x)
{
	if(f[x]==x)return x;
	else return f[x]=find(f[x]);
}
bool check(int t)
{
	int num=0,s=0;
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=m;++i)
	if(find(a[i].from)!=find(a[i].to)&&a[i].d1<=t)
	{
		num++;
		f[find(a[i].from)]=find(a[i].to);
		s++;
	}
	for(int i=1;i<=m;++i)
	if(find(a[i].from)!=find(a[i].to)&&a[i].d2<=t)
	{
		s++;
		f[find(a[i].from)]=find(a[i].to);
	}
	if(s<n-1||num<k)return 0;
	return 1;
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=m;++i)
	scanf("%d%d%d%d",&a[i].from,&a[i].to,&a[i].d1,&a[i].d2);
	int l=1,r=1e7,ans=r;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid))ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf("%d",ans);
}
```


---

## 作者：cyrxdzj (赞：0)

### 一、思路

从“最大值最小”的字样，我们可以看出这是二分答案的题目。

可以发现，题中指出 $t_i\le T_i$。这意味着，一道题应尽可能由少年自己想出。如果少年自己想不出，那么就由 Kiana 想出。

而知识点之间联系的构建，可以使用并查集算法维护。

如果少年可以想得出的联系有至少 $k$ 条，并且最后形成了连通块，则符合题意。

更多思路请参阅代码。

### 二、代码

```cpp
// Problem: P2798 爆弹虐场
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2798
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<cstdio>
#include<algorithm>
using namespace std;
struct Connection//知识点之间的联系
{
	int u,v;
	int t,T;
}con[20005];
int n,m,k;
int left,right;
int ans;
//并查集专区
int fa[10005];
int block_cnt;
void clear()//重置并查集
{
	block_cnt=n;
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;
	}
}
int find_fa(int x)
{
	if(x==fa[x])
	{
		return x;
	}
	return fa[x]=find_fa(fa[x]);
}
bool is_merged(int u,int v)//是否已在一个连通块中？
{
	return find_fa(u)==find_fa(v);
}
void merge(int u,int v)//合并
{
	if(!is_merged(u,v))
	{
		fa[find_fa(u)]=find_fa(v);
		block_cnt--;//连通块数量减少
	}
}
//
bool check(int x)//二分检查
{
	clear();
	int nowk=0;//少年想得出的题目
	for(int i=1;i<=m;i++)
	{
		if(con[i].T<=x)
		{
			nowk++;
		}
		if(con[i].t<=x)
		{
			merge(con[i].u,con[i].v);
		}
	}
	//printf("X %d nowk %d block_cnt %d\n",x,nowk,block_cnt);//仅为调试代码，请忽略
	return (nowk>=k)&&(block_cnt==1);
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=m;i++)//读入联系
	{
		scanf("%d%d%d%d",&con[i].u,&con[i].v,&con[i].T,&con[i].t);
		right=max(right,con[i].T);//最长要多久？
	}
	while(left<=right)
	{
		int mid=(left+right)>>1;
		if(check(mid))
		{
			right=mid-1;
			ans=mid;
		}
		else
		{
			left=mid+1;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_111_ (赞：0)

## 首先来看看题意
题目相当于告诉你 $m$ 个联系，每个联系可以选择花 $T_i$ 的时间让少年自己想，也可以选择花 $t_i$ 的时间让 Kiana 直接讲，来把知识点 $a_i$ 和 $b_i$ 联系起来。现在想求在至少让少年自己想 $k$ 个联系的情况下，把这 $n$ 个知识点联系起来（相当于选出 $n-1$ 个联系，从而把这 $n$ 个知识点都联系起来），使得构造的联系中耗时最长的一个联系的用时最短（最后输出的是联系中最长的用时）。
## 思路
本题我们可以使用 Kruskal 来实现。
我们可以把问题分成两块：
1. 先选出 $k$ 条联系，让少年自己想。
1. 再从剩下的 $m-k$ 条联系中选 $n-k-1$ 条，让 Kiana 直接讲。

## 1. 先选出 $k$ 条联系，让少年自己想
因为数据保证 $T_i>t_i$（$T_i$ 为少年自己想第 $i$ 个联系的耗时，$t_i$ 为 Kiana 直接讲这个联系的耗时），所以当 $T_i<T_j$ 时，有 $t_i \leq t_j$。那么如果我们选 $T_i$，构造的联系中耗时最长用时为 $\max(T_i,t_j)$，其中 $T_i$ 和 $t_j$ 都小于 $T_j$；如果我们选 $T_j$，那么最长用时肯定为 $T_j$，所以如果要选让少年自己想，肯定先选联系中 $T_i$ 的值小的那一个，这样才可以让最大的用时尽可能的小。
### 总结1
这个部分我们把 $T_i$ 按从小到大排序（解释即前面），做最小生成树，生成前 $k$ 条边。
## 2. 再从剩下的 $m-k$ 条联系中选 $n-k-1$ 条，让 Kiana 直接讲
选出 $k$ 个让少年自己想的联系后，再在剩下的 $m-k$ 个联系中选 $n-k-1$ 个让 Kiana 直接讲，因为要求的是让联系中最长的用时最短，所以这个过程也应该把 $t$ 按从小到大排序。
### 总结2
这个部分我们把 $t_i$ 按从小到大排序，生成 $n-k-1$ 条边。

## 记录答案
最后输出所有连的边中最长的耗时，直接在每一次连边时取 max 就可以了。
## code
```c
#include<bits/stdc++.h>

using namespace std;
int n,k,m,cnt=0;
int fa[10001],ans=0;
struct node{
	int a,b,t1,t2;
}e[20001];
void add_edge(int a,int b,int t1,int t2){
	e[++cnt].a=a,e[cnt].b=b,e[cnt].t1=t1,e[cnt].t2=t2;
}
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);
}
void un(int x,int y){
	fa[find(y)]=find(x);
}
bool cmp1(node x,node y){
	return x.t1<y.t1;
}
bool cmp2(node x,node y){
	return x.t2<y.t2;
}
int main(){
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	for(int i=1;i<=m;i++){
		int a,b,t1,t2;
		scanf("%d%d%d%d",&a,&b,&t1,&t2);
		add_edge(a,b,t1,t2);//存下每条联系 
	}
	sort(e+1,e+m+1,cmp1);//按t1排序，先选出k个花时间最小的让少年自己想的联系
	for(int i=1;i<=m;i++){
		if(find(e[i].a)!=find(e[i].b)){
			un(e[i].a,e[i].b);
			ans=max(ans,e[i].t1);
			n--;
			if(!--k){
				break;
			}
		}
	}
	if(!--n){
		printf("%d\n",ans);
		return 0;
	}
	sort(e+1,e+m+1,cmp2);//按t2排序，选n-k-1个联系让Kiana讲
	for(int i=1;i<=m;i++){
		if(find(e[i].a)!=find(e[i].b)){
			un(e[i].a,e[i].b);
			ans=max(ans,e[i].t2);
			if(!--n){
				printf("%d\n",ans);
				return 0;
			}
		}
	}
   	return 0;
}
```

---

## 作者：朝夕 (赞：0)

# 这题裸并查集+二分答案就可解了。
## 题意分析
给n个点，m条边，每条边两个可选边权，要求选第一个边权的次数>=k，且最后形成连通图。
问形成的连通图中最大边权的最小值是多少。

看到问最大边权的最小值这两个“最大最小”很容易就能想到需要依靠二分答案来解题。

问题是二分答案的check函数要怎么写？

使用并查集就好了！

每次二分check中值时，都对整个并查集进行初始化。
然后顺序查询每条边，若两个可选边权都大于mid值，则跳过这条边不选。

若第一边权小于或等于mid值，则选，nowk++。

否则则只能选第二边权。

每次选边时，判断两点是否在一个并查集内，若不是，则连通块-1。

最后全部边都选或不选处理完后，若nowk>=k，且连通块数=1，则说明当前mid值可行，否则不可行。

## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,m;
int fa[10005];
int t1[20005],t2[20005],a[20005],b[20005];
void init()
{
    for(int i=1;i<=n;i++) fa[i]=i;
}
int ffa(int x)
{
    if(fa[x]!=x) fa[x]=ffa(fa[x]);
    return fa[x];
}
void unite(int x,int y)
{
    x=ffa(x),y=ffa(y);
    fa[y]=x;
}
bool check(int x)
{
    init();
    int nowk=0,ll=n;
    for(int i=1;i<=m;i++)
    {
        if(t1[i]>x&&t2[i]>x) continue;
        if(t1[i]<=x)
        {
            nowk++;
        }
        if(ffa(a[i])!=ffa(b[i]))
        {
            ll--;
            unite(a[i],b[i]);
        }
    }
    if(ll==1&&nowk>=k) return true;
    else return false;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>k>>m;
    for(int i=1;i<=m;i++)
        cin>>a[i]>>b[i]>>t1[i]>>t2[i];
    int l=0,r=1000000,ans=0;
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(check(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：田阙西 (赞：0)

蒟蒻的暴力算法。。。
贪心+并查集：因为Ti>ti，所以我们只会让少年恰好连接k条边。
所以按照ti sort一遍，已连接的两点跳过，直至刚好花费k条边，同时每次连接更新ans。
然后按照Ti sort后面未扫描到的边，贪心策略同上。

```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<vector>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
int n,k,m,ans;
int tot,num,fa[10010];
struct mmm{int a,b,t1,t2;}a[20010];
bool cmp1(mmm a,mmm b){return a.t2<b.t2;}
bool cmp2(mmm a,mmm b){return a.t1<b.t1;}
int find(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=find(fa[x]);
}
void unionn(int x,int y)
{
	int fx=find(x),fy=find(y);
	fa[fx]=fy;
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=m;i++)scanf("%d%d%d%d",&a[i].a,&a[i].b,&a[i].t2,&a[i].t1);
	sort(a+1,a+1+m,cmp1);
	for(int i=1;i<=n;i++)fa[i]=i;
	
    while(tot<k)
    {
    	num++;
    	int x=a[num].a,y=a[num].b;
    	if(find(x)!=find(y))
    	{
    		tot++;ans=max(ans,a[num].t2);
    		unionn(x,y);
		}
	}
	
	sort(a+2+num,a+1+m,cmp2);
	for(int i=1+num;i<=m;i++)
	{
		int x=a[i].a,y=a[i].b;
    	if(find(x)!=find(y))
    	{
    		ans=max(ans,a[i].t1);
    		unionn(x,y);
		}
	}
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：DarkEyeR (赞：0)

快考试了。写几道二分题 万一考了呢。

看到最大值最小，显然就是一道二分答案的题，但是对于这个题可以开一个数组来存边权，进行一下优化。

check的时候呢，就是优先的去跑要求的边,判断一下自己思考的点是不是比k大，如果小于k显然不存在。

跑完了以后用并查集来判断图是否连通即可

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>
#define MAX 100050
using namespace std;
int n,m,k,f[MAX],arr[MAX];
struct edges{
    int pre,next,w;
}edge[MAX],edge1[MAX];

inline int read(){
    int x = 0, w = 1;
    char chr = 0;
    while(!isdigit(chr)){
        if(chr == '-')
            w = -1;
        chr = getchar();
    }
    while(isdigit(chr)){
        x = x*10 + chr - '0';
        chr = getchar();
    }
    return x*w;
}

int search(int x){
    return x == f[x] ? x : f[x] = search(f[x]);
}

bool check(int mid){
    int a = 0,b = 0;
    for(register int i = 1; i<=n;i++){
        f[i] = i;
    }
    for(register int i = 1; i<= m;i++){
        if(edge[i].w <= mid){
            int fa = search(edge[i].pre);
            int fb = search(edge[i].next);
            if(fa!=fb){
                f[fa] = fb;
            }
            b++;
        }
    }
    if(b < k) return false;
    for(register int i = 1; i<=m;i++){
        if(edge1[i].w <= mid){
            int fa = search(edge1[i].pre);
            int fb = search(edge1[i].next);
            if(fa!=fb){
                f[fa] = fb;
            }
        }
    }
    for(register int i = 1;i<=n;i++){
        if(f[i] == i){
            a++;
            if(a > 1){
                return false;
            }
        }
    }
    return true;
}

int main(){
    n = read();
    k = read();
    m = read();
    for(register int i = 1;i<=m;i++){
        int a = read(),b = read(),T = read(),t = read();
        edge[i].pre = a;
        edge[i].next = b;
        edge[i].w = T;
        edge1[i].pre = a;
        edge1[i].next = b;
        edge1[i].w = t;
        arr[i] = T;
        arr[i+m] = t;
    }
    sort(arr+1,arr+2*m+1);
    int l = 0,r = 2*m,ans = 0;
    while(l <= r){
        int mid = (l+r)/2;
        if(check(arr[mid])){
            r = mid-1;
            ans = arr[mid];
        }else
            l = mid+1;
    }
    cout << ans << endl;
    return 0;
}
```

---


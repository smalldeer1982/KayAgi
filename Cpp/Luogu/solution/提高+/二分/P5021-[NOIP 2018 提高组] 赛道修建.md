# [NOIP 2018 提高组] 赛道修建

## 题目描述

C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 $m$ 条赛道。 

C 城一共有 $n$ 个路口，这些路口编号为 $1,2,…,n$，有 $n-1$ 条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 $i$ 条道路连接的两个路口编号为 $a_i$ 和 $b_i$，该道路的长度为 $l_i$。借助这 $n-1$ 条道路，从任何一个路口出发都能到达其他所有的路口。 

一条赛道是一组互不相同的道路 $e_1,e_2,…,e_k$，满足可以从某个路口出发，依次经过 道路 $e_1,e_2,…,e_k$（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。 

目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的 $m$ 条赛道中长度最小的赛道长度最大（即 $m$ 条赛道中最短赛道的长度尽可能大）

## 说明/提示

【输入输出样例 1 说明】 

所有路口及适合于修建赛道的道路如下图所示：      

![](https://cdn.luogu.com.cn/upload/image_hosting/bkj3pfqm.png)

道路旁括号内的数字表示道路的编号，非括号内的数字表示道路长度。 需要修建 $1$ 条赛道。可以修建经过第 $3,1,2,6$ 条道路的赛道（从路口 $4$ 到路口 $7$）， 则该赛道的长度为 $9 + 10 + 5 + 7 = 31$，为所有方案中的最大值。

【输入输出样例 2 说明】

 所有路口及适合于修建赛道的道路如下图所示：   
  

![](https://cdn.luogu.com.cn/upload/image_hosting/e9lcljwr.png)

需要修建 $3$ 条赛道。可以修建如下 $3$ 条赛道： 
1. 经过第 $1,6 $条道路的赛道（从路口 $1$ 到路口$ 7$），长度为 $6 + 9 = 15$； 
2. 经过第$ 5,2,3,8$ 条道路的赛道（从路口$ 6$ 到路口 $9$），长度为 $4 + 3 + 5 + 4 = 16$；
3. 经过第 $7,4$ 条道路的赛道（从路口 $8$ 到路口$ 5$），长度为 $7 + 10 = 17$。 长度最小的赛道长度为 $15$，为所有方案中的最大值。 

### 数据规模与约定

所有测试数据的范围和特点如下表所示 :

| 测试点编号 | $n$ | $m$ | $a_i=1$ | $b_i=a_i+1$ | 分支不超过 $3$ |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $1$ | $\le 5$ | $=1$ | 否 | 否 | 是 |
| $2$ | $\le 10$ | $\le n-1$ | 否 | 是 | 是 |
| $3$ | $\le 15$ | $\le n-1$ | 是 | 否 | 否 |
| $4$ | $\le 10^3$ | $=1$ | 否 | 否 | 是 |
| $5$ | $\le 3\times 10^4$ | $=1$ | 是 | 否 | 否 |
| $6$ | $\le 3\times 10^4$ | $=1$ | 否 | 否 | 否 |
| $7$ | $\le 3\times 10^4$ | $\le n-1$ | 是 | 否 | 否 |
| $8$ | $\le 5\times 10^4$ | $\le n-1$ | 是 | 否 | 否 |
| $9$ | $\le 10^3$ | $\le n-1$ | 否 | 是 | 是 |
| $10$ | $\le 3\times 10^4$ | $\le n-1$ | 否 | 是 | 是 |
| $11$ | $\le 5\times 10^4$ | $\le n-1$ | 否 | 是 | 是 |
| $12$ | $\le 50$ | $\le n-1$ | 否 | 否 | 是 |
| $13$ | $\le 50$ | $\le n-1$ | 否 | 否 | 是 |
| $14$ | $\le 200$ | $\le n-1$ | 否 | 否 | 是 |
| $15$ | $\le 200$ | $\le n-1$ | 否 | 否 | 是 |
| $16$ | $\le 10^3$ | $\le n-1$ | 否 | 否 | 是 |
| $17$ | $\le 10^3$ | $\le n-1$ | 否 | 否 | 否 |
| $18$ | $\le 3\times 10^4$ | $\le n-1$ | 否 | 否 | 否 |
| $19$ | $\le 3\times 10^4$ | $\le n-1$ | 否 | 否 | 否 |
| $20$ | $\le 5\times 10^4$ | $\le n-1$ | 否 | 否 | 否 |

其中，「分支不超过 $3$」的含义为：每个路口至多有 $3$ 条道路与其相连。

对于所有的数据，$2 \le n \le 5\times 10^4, \ 1 \le m \le n − 1,\ 1 \le a_i,b_i \le n,\  1 \le l_i \le 10^4$。

## 样例 #1

### 输入

```
7 1 
1 2 10 
1 3 5 
2 4 9 
2 5 8 
3 6 6 
3 7 7```

### 输出

```
31```

## 样例 #2

### 输入

```
9 3 
1 2 6 
2 3 3 
3 4 5 
4 5 10 
6 2 4 
7 2 9 
8 4 7 
9 4 4```

### 输出

```
15```

# 题解

## 作者：CodyTheWolf (赞：228)

### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)

------------
# Solution

## 只讲满分解法：

### 看题目描述肯定一下就能想到二分答案。

也很容易想到二分m条赛道中最小的那一个，也可以理解为画一条分界线mid，看看比mid大或者等于的赛道能不能有m个。

对于一个点，从它子树发源的赛道，最多只能有一条穿过它并向上贡献，因为父亲边是唯一的，多一条赛道肯定会在边上重复。

### 我们考虑一下贪心：

如果现在树只有两层（一个树根和一堆儿子），我们的肯定希望这个子树多出现赛道。我们把边全部排序，然后从最小的边开始，用分界线mid减去这个边的边权，设为x。显然，给这个边找一条比**x大一点或者等于**的边即可，因为比x长的边虽然也能和当前匹配，但是后面我们其他的匹配或者是要向上贡献的机会可能就少了，因此可能会不优。

我们现在已经完成子树内的最大匹配了，我们找出链中没有用过的最长链（可以是空链，也就是0），作为向上的贡献（具体做法也就是记一个点权，点权也就是那个最长链的长度）。

这个时候，我们最下面那一层已经没有意义了，因为我们已经匹配好了，并且找出了最长链，其他已经匹配的赛道或者比最长链小的链已经没有用处了。那么我们可以看作把这一层全部消掉，显然是没有问题的（这时候的最长链已经被当作点权了）。

这样我们可以用DFS的方式，从下往上把树不停的“消层”，直至没有。

需要注意的是，最下层解决完毕以后，后面的层的链是**边权+点权**，这才是我们的链。当然也可以看作最下层的点权是0。

在全局的设个变量res记录还需要找到几条赛道。先让res等于m，每次在子树匹配成功，就res--，DFS全部结束的时候只要判断res是不是小于等于0就知道是否成功了。

一些细节建议看一下代码的注释qwq

------------


# CODE

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 5e4 + 5, MAXM = MAXN << 1;
const int INF = 0x7fffffff;

int head[MAXM], nxt[MAXM], v[MAXM], w[MAXM], cnt;

int n, m;
int root;

inline void Addline(int x, int y, int z)
{
    v[cnt] = y, w[cnt] = z;
    nxt[cnt] = head[x], head[x] = cnt++;

    return;
}

int dp[MAXN], tag[MAXN];//dp是向上贡献的最长链长度，也就是上面说的点权
int que[MAXN], tail;
int res;//还需要的赛道数

inline void DFS(int x, int from, int lim)
{
    for (int i = head[x]; ~i; i = nxt[i])
        if (v[i] != from)
            DFS(v[i], x, lim);//先下去DP一边，这样就不需要多开数组做后面的贪心了

    tail = 0;
    for (int i = head[x]; ~i; i = nxt[i])
        if (v[i] != from)
            que[++tail] = dp[v[i]] + w[i];//把几条链加进队列

    sort(que + 1, que + tail + 1);//排序

    for (int i = tail; i >= 1 && que[i] >= lim; i--)
        tail--, res--;//先把已经能变成赛道的边直接去掉，他们不需要两两匹配

    for (int i = 1; i <= tail; i++)
        if (tag[i] != x)//这个链没有被选过
		//这里的tag不再存True和False，而是存当前点的编号，这样就不用多次清空数组，而且可以保证不会重复（每个点只访问一次）
        {
            int l = i + 1, r = tail, pst = tail + 1;//二分另外一条链使得能刚好组成赛道
            while (l <= r)
            {
                int mid = ((l + r) >> 1);
                if (que[i] + que[mid] >= lim)
                    pst = mid, r = mid - 1;
                else
                    l = mid + 1;
            }

            while (tag[pst] == x && pst <= tail)//因为有可能当前二分到的是已经被选过的链，那么我们贪心往后找一条链，可以证明这样是最优的
                pst++;

            if (pst <= tail)//如果有观察上面的代码，可以发现tail+1是我们的溢出区，这里判断一下
                tag[i] = tag[pst] = x, res--;
        }

    dp[x] = 0;
    for (int i = tail; i >= 1; i--)//找到当前没有选过的最长链，向上传递（其实也就是把链看成是当前点对上面点的贡献）
        if (tag[i] != x)
        {
            dp[x] = que[i];
            break;
        }

    return;
}

signed main(void)
{
    memset(head, -1, sizeof head);

    cin >> n >> m;
    for (int i = 1, x, y, z; i < n; i++)
    {
        scanf("%d %d %d", &x, &y, &z);
        Addline(x, y, z), Addline(y, x, z);
    }

    root = rand() % n + 1;//随机选根

    int l = 0, r = INF, ans = 0;
    while (l <= r)//二分答案
    {
        int mid = ((l + r) >> 1);
        res = m;

        memset(tag, false, sizeof tag);

        DFS(root, 0, mid);
        if (res <= 0)
            ans = mid, l = mid + 1;
        else
            r = mid - 1;
    }

    cout << ans << endl;

    return 0;
}
```

---

## 作者：XG_Zepto (赞：102)

首发于 [个人博客](https://zepto.page/post/noip-2018-track)。

### 思路

我就顺着我考场上的思路，把所有部分分都讲一讲吧。

首先对于 $m=1$ 的数据，我们显然只要找到直径长度就行；

对于一条链的情况，二分答案，对于每次二分出来的 $mid$，从根开始贪心选取一段边，累计长度大于等于 $mid$ 的时候就计入答案，重新开始寻找下一段，得出对于 $mid$ 最大的答案，判断它是否大于 $m$；

对于菊花图，由于路径最多经过两条边，我们实质上是要在 $n-1$ 条边中选一共 $m$ 次，每次选出一条独立的边，或者一对边，使得最终每条边的长度 / 每对边的长度和尽量大。对于每次二分出来的  $mid$，长度大于 $mid$ 的边独立地选出，而小于 $mid$ 的边尝试一长一短两两配对，用双指针在排过序的长度数据中扫描一遍，得出对于 $mid$ 最大的答案，判断它是否大于 $m$；

对于 “分支不超过 3” 的图，也就是除根节点之外，每个点只有两个儿子，同样我们二分答案。首先定义几个概念，我们称从一条赛道两端点 $LCA$ 开始的，到一个端点结束的链为对应赛道的半链，令 $f_i$ 为以 $i$ 为 $LCA$ 的最优半链长度。暂时不考虑根节点，如果 $i$ 只有一个儿子 $v$，若 $f_v + l_i \geq mid$，直接将 $f_v + l_i$ 计入答案，否则，$f_i = f_v + l_i$；如果 $i$ 有两个儿子，如果它们可以直接单独计入答案则直接计入，否则考虑是否可以将这两个儿子牵引的两条半链合并，合并后长度大于 $mid$ 则直接计入答案，否则选取最长的一段转移到 $f_i$，对于可能有三个儿子的根节点，遵循的原则同样是尽量独立选取两个儿子，否则尝试合并两条半链计入答案；

如果我们结合菊花图和 “分支不超过 3” 的图这两种情况，我们就可以搞定 100% 的数据。继承上面半链和 $f_i$ 的定义，我们要做的是在使最多的儿子对答案做出贡献的同时，尽量大地将 $f_{son}$ 的值转移给 $f_i$。因为 $f$ 的一个值最多对答案产生 1 的贡献，所以使儿子做出更少贡献，转移更大的 $f_i$ 不可能使答案变优，我们的贪心第一关键字就可以设为使儿子做出最大的贡献。在菊花图的算法中，我们只满足了第一个条件，但不需要考虑 $f_i$ 进一步的转移，而我认为这一点正是 A 掉本题的重点。也就是说，我们要在儿子的 $f$ 值中，选出一个最优的转移至 $f_i$，使得剩下的 $f$ 值的合法匹配最多。同样可以二分转移至 $f_i$ 的儿子，剩下的和菊花图的做法相同。

总结一下正解：首先二分答案，贪心计算对于 $mid$ 的最大可能答案，判断它和 $m$ 的大小。我们称从一条赛道两端点 $LCA$ 开始的，到一个端点结束的链为对应赛道的半链，令 $f_i$ 为以 $i$ 为 $LCA$ 的最优半链长度。要求对于 $i$ 所有儿子的 $f$，在保证两两匹配数（两个半链合成一条赛道）最多的同时，向 $f_i$ 转移尽可能大的值。于是将所有 $f$ 排序贪心找到最大匹配数，然后，二分找到转移给 $f_i$ 的值。

复杂度不太会证，应该接近 $\Theta(n\log n \log \dfrac{\sum{l_i}}{m})$ 吧。

### 代码


```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define ll long long
#define maxn 50010
using namespace std;
struct Edge{
	int to,next,val;
	Edge(int a=0,int b=0,int c=0){
		to=a,next=b,val=c;
	}
}l[maxn<<1];
int head[maxn],cnt,n,m;
vector<int> son[maxn];
ll f[maxn];
int subans[maxn];
void Add(int a,int b,int c){
	l[++cnt]=Edge(b,head[a],c);
	head[a]=cnt;
}
int check(int u,int pos,int tot,ll x){
	int res=0,l=0;
	for (register int r=tot-1;r;--r){
		r-=r==pos;
		while (l<r&&son[u][l]+son[u][r]<x) ++l;
		l+=l==pos;
		if (l>=r) break;
		++res;++l;
	}
	return res;
}
void Dfs(int u,int fa,ll x){
	f[u]=subans[u]=0;
	son[u].clear();
	for (register int i=head[u];i;i=l[i].next){
		int v=l[i].to;
		if (v==fa) continue;
		Dfs(v,u,x);
		f[v]+=l[i].val;
		if (f[v]>=x) subans[u]++;
       	// 如果已经大于 x 则直接计入答案
		else son[u].push_back(f[v]);
	}
	int tot=son[u].size();
	sort(son[u].begin(),son[u].end());
	int l=0,r=tot,sub=0,res;
	for (register int r=tot-1;r;--r){
		while (l<r&&son[u][l]+son[u][r]<x) ++l;
		if (l>=r) break;
		++sub;++l;
	}
	subans[u]+=sub;
    // 贪心找出最大的匹配数（两个半链合成一条赛道）
	if (sub*2==tot) return;
	l=0,r=tot-1;
	while(l<=r){
		int tem=check(u,mid,tot,x);
		if (tem==sub) res=mid,l=mid+1;
		else r=mid-1;
	}
    // 二分找到满足最大匹配的，可以转移给 f_u 的最大值
	f[u]=son[u][res];
}
bool check(ll x){
	int tem=0;
	Dfs(1,0,x);
	for (register int i=1;i<=n;++i)
		tem+=subans[i];
	return tem>=m;
}
int main(){
	ll l=0,r=0,ans,c;
	scanf("%d%d",&n,&m);
	for (register int i=1,a,b;i<n;++i)
		scanf("%d%d%lld",&a,&b,&c),
		Add(a,b,c),Add(b,a,c),r+=c;
	r/=(ll)m;
    // 在这里二分答案
	while(l<=r){
		if (check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：EternalAlexander (赞：20)

对于最小值最大，考虑二分答案。  
设当待检查的答案为$k$,则问题转化为了一棵树上能否找出至少$m$条长度大于等于$k$的路径。  
考虑一棵子树对全局答案的贡献，显然有两个方面。  
第一是当前子树中能最多能找到的满足要求的路径条数，在以u为根的子树中记为$ans_u$；第二是连到当前子树的根的路径的长度，记为$len_u$。  

约定有序对$(a, b)$表示$ans_u=a, len_u=b$,定义$(a, b) < (c, d)$为对于同一个子树，贡献为$(a, b)$时全局答案的最大值<贡献为$(c, d)$时全局答案的最大值。

直觉告诉我们，应该在最大化$ans_u$的前提下最大化$len_u$，原因也很显然，若当前子树贡献的两个状态为$A=(a, b), B=(c, d)$,且$a>c$，那么$B \leq A$，因为无论$d$有多大，最多也只能组成一条满足题意的路径，则$(c, d) < (c+1, 0) \leq (a, b)$。

考虑如何计算以$u$为根的子树的贡献。在u的所有儿子v的贡献都已经被计算出来的情况下，显然ans_u可以直接赋值为$\sum ans_v$，那么只需要考虑  
1.如何将$len_v$组成尽量多的满足题意的路径  
2.如何最大化剩下的元素（如果有的话）中最大的一个。    

1的做法类似于P1094，用双指针扫一遍就行了。  
2可以二分答案，每次删去一个元素后用1的做法计算答案，可以求出在答案不变的情况下能够删去的最大元素。

考场代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

#define maxn 50005

int n, m, head[maxn], tail, ans[maxn], len[maxn], arr[maxn], vis[maxn];

struct edge {
	int v,w,next;
}edges[maxn<<1];

void add_edge(int u,int v,int w) {
	edges[++tail].v=v;
	edges[tail].w=w;
	edges[tail].next=head[u];
	head[u]=tail;
}

int calc(int tl, int lim) {
	int p2=1; int ret=0;
	for (int i=tl;i>p2;i--) {
		if (vis[i]) continue;
		while (p2<i&&(arr[p2]+arr[i]<lim||vis[p2])) p2++;
		if (p2<i&&!vis[p2]&&arr[i]+arr[p2]>=lim) ret+=1;
		p2++;
	}return ret;
}

void dfs(int u, int f, int lim) {
	ans[u]=0;
	for (int i=head[u];i;i=edges[i].next) {
		if (edges[i].v==f) continue;
		len[edges[i].v]=edges[i].w;
		dfs(edges[i].v, u, lim);
		ans[u]+=ans[edges[i].v];
	}int tl=0; 
	for (int i=head[u];i;i=edges[i].next) {
		if (edges[i].v==f)continue;
		arr[++tl]=len[edges[i].v];
	}if (tl>0)	{
		std::sort(arr+1,arr+tl+1); arr[0]=0;
		int vl=calc(tl,lim); ans[u]+=vl;
		int lb=0, rb=tl, res;
		while (lb<=rb) {
			int mid=(lb+rb)>>1;
			vis[mid]=1;
			if (calc(tl,lim)==vl){
				res=mid; lb=mid+1;
			}else rb=mid-1;
			vis[mid]=0;
		}len[u]+=arr[res];
	}if (len[u]>=lim) {len[u]=0; ans[u]++;}
//	printf("%d:%d %d\n", u, len[u],ans[u]);
}

int check(int v) {
//	printf("checking:%d\n", v);
	std::memset(ans,0,sizeof(ans));
	std::memset(len,0,sizeof(len));
	dfs(1, 0, v);
	return ans[1]>=m;
}

int main() {
	freopen("track.in","r",stdin);
	freopen("track.out","w",stdout);
	std::memset(vis,0,sizeof(vis));
	tail=0;std::memset(head,0,sizeof(head));
	int l=1; int r=0;
	int u,v,w,ret;
	scanf("%d %d", &n, &m);
	for (int i=1;i<n;++i) {
		scanf("%d %d %d", &u, &v, &w); r+=w;
		add_edge(u, v, w);add_edge(v, u,w);
	}while (l<=r) {
		int mid=(l+r)>>1;
		if (check(mid)) {ret=mid; l=mid+1;}
		else r=mid-1;
	}printf("%d", ret);
	return 0;
}

```

---

## 作者：yy0707 (赞：7)

### 题目大意：
给你一棵树，让你把它剖成 $m$ 条链，问其中最短的链最长是多少。

### Solution：
看到最小的最大这种问题，我们可以想到二分答案，那么问题就变成了给你一棵树，将其剖成 $m$ 条链，是其中最短的链大于 $mid$。  
对于这个问题，我们可以使用 DFS 来解决。我们先开一个数组 $b$，$b_u$ 就表示以 $u$ 为根的子树中，所有以 $u$ 为起点的链中长度没有达到 $mid$ 的链或者不能与另一条没有达到 $mid$ 的链拼在一起来超过 $mid$ 的链中最长的那条链的长度。  

#### Part 1：遍历子树
遍历 $u$ 时，先枚举它的所有儿子，设儿子的编号为 $v$，到 $u$ 的边的长度为 $w$，我们先 DFS(v)，然后如果 $b_v+w\ge mid$，就将 $tot$ 加 1，否则就将其存入数组 $a$ 中。

#### Part 2：合并链
我们将 $a$ 数组从小到大排序，然后从小到大枚举，对于每个 $i$，如果能找到一个 $j$，使 $a_i+a_j\ge mid$，且 $j$ 最小，那么就将 $tot$ 加 1，然后把 $i$ 和 $j$ 标记一下，这一部分可以用二分做。然后如果 $j$ 已经被标记过了，就把 $j$ 往后跳，直到 $j$ 没有被标记，如果跳出去了就不管它。注意不能想当然的用双指针，因为可能开始已经把一些点跳过了，但它们并没有被标记，导致后面可能有些链本来能匹配的，却没有匹配到。

#### Part 3：上传 $b$ 数组
我们从剩余的没有标记的链中取个最大值，传进 $b_u$ 中，然后这题就做完了，时间复杂度 $O(n\log^2n)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tot,cnt,f[50001],bz[50001],a[50001],b[50001],sum,mid;
struct edge{int to,w;};
vector<edge>G[50001];
inline void init(int u){
	for(auto[v,w]:G[u]){
		if(f[u]!=v){
			f[v]=u;
			init(v);
		}
	}
}void dfs(int u){
	for(auto[v,w]:G[u])if(f[u]!=v)dfs(v);
	cnt=0;
	for(auto[v,w]:G[u]){
		if(f[u]!=v){
			if(b[v]+w>=mid)++tot;
			else a[++cnt]=b[v]+w;
		}
	}sort(a+1,a+cnt+1),fill(bz+1,bz+cnt+1,0);
	for(int i=1;i<cnt;i++){
		if(bz[i])continue;
		int j=lower_bound(a+i+1,a+cnt+1,mid-a[i])-a;
		if(j!=cnt+1){
			while(bz[j]&&j<cnt)++j;
			if(!bz[j]&&a[i]+a[j]>=mid)bz[i]=bz[j]=1,++tot;
		}
	}b[u]=0;
	for(int i=1;i<=cnt;i++)if(!bz[i])b[u]=a[i];
}bool check(){
	tot=0,dfs(1);
	return tot>=m;
}signed main(){
	cin>>n>>m;
	for(int i=1,u,v,w;i<n;++i){
		cin>>u>>v>>w;
		G[u].push_back({v,w});
		G[v].push_back({u,w});
		sum+=w;
	}init(1);
	int l=0,r=sum,ans=0;
	while(l<=r){
		mid=(l+r)/2;
		if(check())ans=mid,l=mid+1;
		else r=mid-1;
	}cout<<ans;
}
```

---

## 作者：RedreamMer (赞：6)

[$\LARGE\texttt{P5021}$](https://www.luogu.com.cn/problem/P5021)

[$\small\texttt{In my cnblogs}$](https://www.cnblogs.com/RedreamMer/p/14084275.html)

做法：贪心/二分/$\texttt{DFS}$（树形 $\texttt{DP}$）/并查集

## 前言

清一色的 $\texttt{multiset}$ ，为什么啊？

这的确是一道好题，做法很多，对于这里贪心的维护难道非要进行删除操作？（还有为什么有人说显然要 $\texttt{multiset}$ ？)像我这样的蒟蒻不会 $\texttt{multiset}$ 怎么办？

提供一种不用 $\texttt{multiset}$ 的做法（码量小）。

## 题意

给你一颗带权树，要你选 $k$ 条没有重边的链，使得这些链中权值最小值最大。

这里链的权值定义为链上所有边权之和。

## 思路

~~好像做过一道类似的题~~

$\texttt{undate}$：确实为[$\texttt{P6147}$](https://www.luogu.com.cn/problem/P6147)的加强版。

看到最小值最大，显然二分答案，且有十分明显的单调性，然后 $check$ 一下就好了。

$check$ 里面是一个经典的树形 $\texttt{DP}$，考虑从叶子节点往上处理，因为对于每个节点向上到父亲的边只有一条，所以对于每个节点记录从这个节点一直往下最深并没有选进链的链（以下记为 $s[i]$ ，如何得到这个值请往下看)。

对于每一个节点，我们要进行两种操作。

+ 若以这个节点为链的端点，有大于目标值的链，直接对答案贡献 $+1$ 。

+ 若以这个节点为某一条链，两个端点的 $\texttt{LCA}$ ，则要做一个拼接操作，将两个儿子的  $s[i]+dis(fa,son_i)$ 值合并，但这两个 $s$ 值相加必须要大于目标值。

	剩下的儿子节点中最大的 $s[i]+dis(fa,son_i)$ 作为 $s[fa]$ 。

可以证明，先要优先最大化合并操作的次数，因为若要优先最大化 $s[i]$ ，则可能这第 $i$ 个节点的合并个数会变小，但 $s[i]$ 增大最多对i的父节点的贡献 $+1$ 。(贪心\*1）
    
但是在优先最大化每个节点合并的次数，还要次优先最大化 $s[i]$ ，原本我有一个错误的贪心：是先排序 $s[son\_of\_i]$ ，然后不断将最左边的数和最右边的数合并，若不能合并，则将最左边的值删去。

但是这个贪心是错的，参考样例：`2 8 9 目标值:10 wrong:s[n]=8 ans:s[n]=9` 。

发现这里疏忽了一点，就是应该选择这个数最小能匹配的数，可以用 $\texttt{lower\_bound}$ 求出。(贪心\*2)

求出那个数之后，要将它删去，这里我用 $\Large\texttt{并查集}$ 来维护，若第 $i$ 个数被删去，就将自己的父亲定为 $i+1$ 。然后取二分到的那个数的祖宗，若这个祖宗是 $s.size()+1$ （即这个数后面的数都被删完了），就跳过这个数。

时间复杂度 $O((\log\sum val)\times N(\log N +\alpha(N)))$ （远远达不到的，~~本人不会均摊QwQ~~）

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

 #define PB push_back
 #define MP make_pair
 const int N = 5e4;
 #define pii pair<int,int>
inline int read()
{
    int s = 0;
    register bool neg = 0;
    register char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        neg |= (c == '-');
    for (; c >= '0' && c <= '9'; s = s * 10 + (c ^ 48), c = getchar())
        ;
    s = (neg ? -s : s);
    return s;
}

int a,b,p,res,s[N+10],nxt[N+10],lst[N+10],Fa[N+10];
bool vis[N+10];
vector<pair<int,int> >st[N+10];

inline int f(int n) {
	return Fa[n]==n?n:Fa[n]=f(Fa[n]);
}

inline void dfs(int n,int fa) {
	s[n]=0;
	vector<int> q;
	q.clear();
	for(int i=0;i<st[n].size();i++) {
		int v=st[n][i].first,val=st[n][i].second;
		if(v==fa) continue;
		dfs(v,n);
		if(s[v]+val>=p) res++;
		else q.PB(val+s[v]);
	}
	if(!q.size()) return;
	if(q.size()==1) {
		s[n]=q[0];
		return;
	}
	sort(q.begin(),q.end());
	for(int i=0;i<=(int)q.size();i++) Fa[i]=i,vis[i]=0;
	for(int i=0;i<(int)(q.size()-1);i++) {
		if(vis[i]) continue;
		if(i>=q.size()-1||i==-1) break;
		int t=lower_bound(q.begin()+i+1,q.end(),p-q[i])-q.begin();
		if(t>=q.size()) continue;
		t=f(t);
		if(t>=q.size()) continue;
		if(q[t]+q[i]<p) continue;
		vis[t]=1;
		vis[i]=1;
		Fa[t]=t+1;
		res++;
	}
	for(int i=(int)(q.size()-1);i>=0;i--) if(!vis[i]) {
		s[n]=q[i];
		break;
	}
}

inline bool check(int n) {
	p=n;
	res=0;
	dfs(1,0);
	return res>=b;
}

signed main()
{
//	freopen("in.txt","r",stdin);
	a=read();
	b=read();
	int x,y,z,mx=0;
	for(int i=1;i<a;i++) {
		x=read();
		y=read();
		z=read();
		mx+=z;
		st[x].PB(MP(y,z));
		st[y].PB(MP(x,z));
	}
	int l=1,r=mx,ans=0;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：pengyule (赞：5)

## 介绍
- 本篇文章是我写过的最详细易懂的一篇题解，同时也是我用 GitHub 写的第一篇题解。
- 这篇题解力求在分析过程方面帮助到更多的人，并且我个人认为比其他题解要容易理解许多。
- 如果你想要更佳的阅读体验，请点击[此处](https://pengyule.github.io/post/luogu-solution-p5012/)。

## 分析阶段
要想让最小值最大，这类题目一般采用二分答案的方法。二分我们的最小赛道长，然后每次在树上构建长度大于等于二分到的值 $mid$ 的赛道，看看是否可以构建出不小于 $m$ 条赛道。

这一步不难想到，此题的难点在于如何去判断 $mid$ 是否可以构建出合法条件的赛道，即如何在树上构建合法赛道才可以最大化赛道条数。

让我们举一个例子。

![图片.png](https://i.loli.net/2020/07/11/SMh8Cqwymu4gBfX.png)

对于上面这棵树，我们先从它最底层的子树说起，就比如 $6,7,8$ 这棵子树。

如果一条赛道包含有这一棵子树中的边，那么这条赛道可能有如下两种情况：
1. 这条赛道的全部部分都由这棵子树中的边组成。
2. 这条赛道的一端有部分边由这条子树中的边组成，剩下的部分由节点 $6$ 以上（不在这棵子树中）的边组成。

如果说得易懂一些，那么就是，从这棵子树中的某一个顶点一直向上伸过来，到达子树根 $6$，对于第一种情况，他越过顶点 $6$，去往外探索世界，对于第二种情况，他折回头继续去这棵子树当中的其他分支延伸开去。

当然，还有一种比较特殊的情况，就是刚好它到了 $6$ 这里长度大于等于我们二分到的这个值，它就不需要再去探索其他的边了，我们就把它记做一条赛道。

图解：

![图片.png](https://i.loli.net/2020/07/11/xqohudB6R471Amz.png)

我们考虑：首先，去在这棵子树里找两个分支，使得他们边权之和大于等于 $mid$；这一步我们应该尽量“节省”，比如说我们有 $3\ 4$ 和 $3\ 5$ 两种合法的选择，我们就应该选择 $3\ 4$，为后面留下更多的空间。然后，在剩下的无法配对的分支当中，选取边权最大的一个，呈献给我们的根节点，这样，当我们像这样子去操作上面的 $2,5,6$ 这个子树时，$6$ 这个子节点所能达到的最优分支长度就应该是 边 `2-6` 的长加上我们呈献给 $6$ 的子分支长度 的和。

## 策略阶段
我们有了大概的思路，应该想想什么样策略适合计算机去实现。

1. 对整棵树进行遍历，把输入的无向图整合成一棵树，方便后面实现，同时记录每个节点的：父亲，儿子及到这个儿子的边之长。
2. 算出这棵树的直径，二分答案的上界就应该是它——因为赛道是一条链，所以答案一定不会超过树的直径。（树的直径就是一棵树上最长的从一点到一点的路径长度，常用的求树的直径的方法是，从树上任意一点找到一个树上距离它最远的点，然后找到从这个最远点开始的树上路径中最长的长度。）
3. 每个节点有一个 $\text{set}$，储存这个节点为根的子树的所有分支，当然，我们只需要在 $\text{set}$ 中放那些需要组合的，也就是说他自己一个人不足赛道长的分支，如果是我们刚才说的第三种情况，那我们直接说我们多了一条赛道就好了（不需要放入 $\text{set}$）。
4. 然后在 $\text{set}$ 中进行配对（配成一对就加了一条赛道），配不成的就取 $\max$ 然后贡献给根，我们把每个节点得到的贡献记为 $val$。
5. 最后检查一下是不是赛道数大于等于 $m$，如果是，这个 $mid$ 合法（$L=mid$），否则，$mid$ 不合法（$R=mid$）。最终的 $L$ 即是答案。

## 代码阶段
有了清晰的思路，代码应该比较好写了，但是还是有一些地方需要注意。

1. 加快读
2. 开 O2
3. 然后我们就可以 AC 了

代码有简要注释。

```
#pragma GCC optimize(2) //O2优化
#include <bits/stdc++.h>
using namespace std;
const int N=5e4+10;
int n,m,cnt,val[N],u[N],v[N],w[N],book[N],fa[N],Max,V;
//n,m如题所述，cnt用来记每次二分到的值对应合法赛道数
//u,v,w是题目输入的两个顶点、一条边长
//book是在还没有把树造出来的情况下用来记录dfs时哪些点走过没有
struct race {
    int node,edge; //顶点编号、边长
};
vector<int> _g[N];
vector<race> W[N];
vector<race> G[N];
multiset<int> s[N];
multiset<int>::iterator it;
void dfs(int step,int k){ 
    int x=0;
    s[step].clear();
    for(int i=0;i<G[step].size();i++){
        dfs(G[step][i].node,k);
        if(val[G[step][i].node]+G[step][i].edge>=k)
            cnt++;
        else 
            s[step].insert(val[G[step][i].node]+G[step][i].edge);
    }
    while(!s[step].empty()){
        if(s[step].size()==1){ //只剩一个顶点没有处理了，取个max呈献给根
            val[step]=max(x,*s[step].begin());
            return;
        }
        it=s[step].lower_bound(k-*s[step].begin()); //第一个和s.begin()相加能大于等于k的
        if(it==s[step].begin() && s[step].count(*it)==1) it++; //如果是自己那没办法只能找后面一个
        if(it==s[step].end()){ //没有合适的也就是说配不了对
            x=max(x,*s[step].begin()); //按照我们之前说的找一个个儿大的
            s[step].erase(s[step].find(*s[step].begin())); //处理过的就要删掉
        }
        else {
            cnt++; //配成一对儿
            //同样，配成对的两个不能再用了，删掉
            s[step].erase(s[step].find(*it));
			s[step].erase(s[step].find(*s[step].begin()));
        }
    }
    val[step]=x; //呈现给子树根
    return;
}
bool check(int k){
    cnt=0;
    dfs(1,k);
    return cnt>=m;
}
void init(int step){ //把父节点什么的整合出来
    book[step]=1;
    for(int i=0;i<_g[step].size();i++)
        if(!book[_g[step][i]]){
            fa[_g[step][i]]=step;
            init(_g[step][i]);
        }
    return;
}
int read(){ //快速读入
    int x=0;
    char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}
void getdis(int step,int sum){ //找从一个点出发的最远点
    book[step]=1;
    if(sum>Max) V=step,Max=sum; //V是最远点，Max是最长路径长度
    for(int i=0;i<W[step].size();i++)
        if(!book[W[step][i].node])
            getdis(W[step][i].node,sum+W[step][i].edge);
}
int tree_D(){ //返回值就是树的直径
    Max=0;
    memset(book,0,sizeof(book));
    getdis(1,0);
    Max=0;
    memset(book,0,sizeof(book));
    getdis(V,0);
    return Max;
}
int main()
{
    n=read(),m=read();
    race t;
    for(int i=1;i<=n-1;i++){
        u[i]=read(),v[i]=read(),w[i]=read();
        _g[u[i]].push_back(v[i]);
        _g[v[i]].push_back(u[i]);
        t.node=v[i],t.edge=w[i];
        W[u[i]].push_back(t);
        t.node=u[i],t.edge=w[i];
        W[v[i]].push_back(t);
    }
    init(1);
    //以上是一些基础树上操作，不赘述
    for(int i=1;i<=n-1;i++){ //把无向图整合成一棵树
    //G[x]是x的所有儿子和分别到他们的距离
        if(fa[u[i]]==v[i]){
            t.node=u[i],t.edge=w[i];
            G[v[i]].push_back(t);
        } 
        else {
            t.node=v[i],t.edge=w[i];
            G[u[i]].push_back(t);
        }
    }
    int L=1,R=tree_D()+1,mid;
    while(L<R-1){
        mid=(L+R)/2;
        if(check(mid)) L=mid;
        else R=mid;
    }
    printf("%d\n",L); //输出答案
    return 0;
}
```
希望你能收获更多！

---

## 作者：longlongzhu123 (赞：5)

推广博客 qwq：[$\left \lceil \text {longlongzhu123} \right \rfloor$](https://www.cnblogs.com/longlongzhu123)（暂时还没有什么东西，但欢迎来玩哦！）

## 题意分析

给出一棵 $n$ 个点的树，并在其中选取 $m$ 条**边不相交**的路径，使得最短路径（赛道）的长度尽可能大。

## 分析

最短路径的长度尽可能大，即要求最大化最小值。显然可以考虑二分。

考虑二分转换为判定问题：二分枚举 $limit$，能否选出 $m$ 条长度不小于 $limit$ 的路径？

不妨**尽可能多地**选择长度不小于 $limit$ 的路径，判断选择的最大数量是否大于等于 $m$。

于是，我们的问题进一步被转换为：给出 $limit$，求出不小于 $limit$ 的路径最多有多少条。

## 贪心策略

先给出一个定义：从 $u$ 子树中某个节点连向 $u$ 的一条路径称为“半链”（借鉴了 @[XG_Zepto](https://www.luogu.org/space/show?uid=37158) 的定义）

下面是一个半链的例子。我们发现，两条长度之和大于等于 $limit$ 的未使用的半链（红色）可以合并在一起对答案造成贡献。

![1.png](https://i.loli.net/2019/08/15/yasb5JVQYoWUFxd.png)

如图，A 和 B 分别是两条未被使用过的半链。如果 A 与 B 的总长可以达到 $limit$，则将它们合并，对答案就造成了贡献。

*   我们很容易想到：每次合并时尽量让两条半链总长接近 $limit$，此时才能更优。换句话说，**让合法的总长尽量小更优**。

*   另外，如果 $v$ 是 $u$ 的儿子，如果 $v$ 的子树中有两条半链可以合并，那么就不要将其中某一条（再加上 $u, v$ 距离后）留到 $u$ 处合并。

    这是因为一条半链对答案最多造成 $1$ 的贡献，而且 $v$ 只能留出一条返回给 $u$，这样做答案并不会更优。换句话说，**能在子树中合并就尽量在子树中合并**。

有了这两个贪心策略后，我们考虑递归遍历整棵树。访问到 $u$ 号节点时，我们先将 $u$ 的儿子们的子树中，能够合并的半链尽量合并，并将合并的数量累加到答案中。从某个儿子返回时，无非就两种情况：

1.  该儿子子树中的半链不能两两配对合并。要么剩余的半链长度太小，要么数量不够（是奇数）。
1.  子树中的半链已经两两配对了，没有剩余的半链。

相应的解决方案如下：

1.  在剩余的半链中选择一条最长的半链，将其长度加上 $u, v$ 距离后返回。（一个儿子最多返回一条半链）
1.  直接返回 $u, v$ 距离。

事实上，我们并不需要知道半链的始末节点。我们只需要知道半链的长度就行了（反正肯定可以合并的嘛）。

## 合并方法

说了这么多，具体应该怎么做呢？

如果我们访问到了 $u$ 号节点，先将 $u$ 的所有儿子递归遍历。每个儿子都会返回一条半链的长度。我们将这些长度统统存进一个 `vector` 里。

然后对这些数据合并。合并方法是每次找到两个总和不小于 $limit$ 的数据，将答案累加 $1$，并将这两个数据删除。

我们既要保证不会漏掉一些合法的合并方案，又要尽可能地使最终返回的半链长度尽量长。首先是从小到大匹配（不会使答案更差，而且还避免最大的半链第一个被删除）。也许你会想到排序并使用双指针法（two-pointers），遗憾的是，双指针法会漏掉一些情况。

为什么？参考下面的一个样例。我们先假设双指针法从小到大合并吧，也就是代码可能长这个样子（减少了一些特判）：

```cpp
// vector<int> v; n = v.size();
sort(v.begin(), v.end()); // 从小到大排序
int cur = n - 1;
for (int i = 0; i < n; i++) {
  if (used[i]) continue;
  while (used[cur] && v[i] + v[cur - 1] >= limit)
    cur--;
  if (v[i] + v[cur] >= limit) {
    ans++;
    used[i] = used[cur] = true;
  }
  if (i + 1 == cur) break;
}
```

为了使合并的总长尽可能小，当 `v[i] + v[cur - 1] >= limit` 时不断将 `cur--`。看上去好像并没有什么问题，每个半链 $i$ 一定会找到与之匹配的最小半链 $cur$。这份代码甚至还过了样例。我们看看这样一组数据：

```plain text
v: 1 2 3 3 3 4
limit = 5
```

很简单，是吧？如果使用双指针，会发生什么呢？

*   `1` 和 `4` 配对，`cur--`
*   `2` 和 `3` 配对，因为 `2` 和每个 `3` 都可以配对，根据我们的算法，我们让 `2` 和最左边的 `3` 配对。
*   好了，这个时候，$i$ 指向 `2`，而 $cur$ 指向最左边的 `3`，因为 $i$ 和 $cur$ 相撞，因此退出循环，并返回剩下数字中的最大值 `3`

发现什么问题了吗？指针移动的时候跳过了 `3` 和 `3` 这两个原本能够合并的数据。解决方案？将 $cur$ 移到末尾？让 `2` 和最右边的 `3` 配对？从大到小配对？很可惜，都不行。可以轻易地构造 Hack 数据。双指针的问题就在于跳过了的数字没法找回来。

## 使用平衡树 / multiset

再回顾一下我们的任务：每次找到两个总和不小于 $limit$ 的数据，将答案累加 $1$，并将这两个数据删除。

使用平衡树就行了嘛！不断遍历最小的数据 $x$，然后在平衡树中找到第一个比 $(limit - x)$ 大的数 $y$，将答案累加 $1$，最后将 $x$ 和 $y$ 删除，直到平衡树大小不超过 $1$ 为止。

当然，我们也没必要手写一个平衡树。STL 里的 `multiset` 足以解决这个问题。

`multiset::lower_bound(x)` 返回第一个大于等于 $x$ 的数 $y$（的迭代器）。如果你不知道迭代器是什么，你可以把它理解成一个更**高明**的指针（滑稽）。`*iter` 的语法同样适用于迭代器。

好了，下面这份代码可以取代上面那份双指针的代码了。

```cpp
// multiset<int> son[u]
while (!son[u].empty()) {
  LL x = *(son[u].begin());
  son[u].erase(son[u].begin());
  Iter iter = son[u].lower_bound(limit - x);
  if (iter == son[u].end()) {
    ans.val = max(ans.val, x);
  } else {
    ans.cnt++;
    son[u].erase(iter);
  }
}
```

这里就是查找并删除的过程。注意如果 `lower_bound` 返回的迭代器等于 `son[u].end()` 则说明找不到。此时用它来更新 $u$ 将要返回的最长半链长度。如果没有数据更新最长半链长度，则将其设成 $0$。加上 $u, v$ 距离这步会在父亲中处理。

## 代码

注意一个小细节：如果某条半链的长度大于等于 $limit$，则这条半链可以单独成为一条路径（不用合并）。

代码其实还挺短的 qwq。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef multiset<LL>::iterator Iter;
const int kMaxN = 50000 + 10;
struct Graph {
  struct Arc {
    int to;
    LL dis;
  };
  vector<Arc> arcs[kMaxN];
  void Add(int u, int v, LL dis) {
    arcs[u].push_back((Arc) {v, dis});
    arcs[v].push_back((Arc) {u, dis});
  }
};
struct Info {
  int cnt;
  LL val;
};
Graph G;
int n, m;
LL limit, max_limit;
multiset<LL> son[kMaxN];
Info Dfs(int u, int fa) {
  Info ans = (Info) {0, 0ll};
  son[u].clear();
  for (int i = 0; i < G.arcs[u].size(); i++) {
    Graph::Arc& arc = G.arcs[u][i];
    int v = arc.to;
    if (v != fa) {
      Info res = Dfs(v, u);
      res.val += arc.dis;
      ans.cnt += res.cnt;
      if (res.val >= limit) {
        ans.cnt++;
      } else {
        son[u].insert(res.val);
      }
    }
  }
  while (!son[u].empty()) {
    LL x = *(son[u].begin());
    son[u].erase(son[u].begin());
    Iter iter = son[u].lower_bound(limit - x);
    if (iter == son[u].end()) {
      ans.val = max(ans.val, x);
    } else {
      ans.cnt++;
      son[u].erase(iter);
    }
  }
  return ans;
}
int main() {
  scanf("%d %d", &n, &m);
  for (int i = 1; i <= n - 1; i++) {
    int u, v, w;
    scanf("%d %d %d", &u, &v, &w);
    G.Add(u, v, w);
    max_limit += w;
  }
  LL end = 0, top = max_limit + 1;
  while (end + 1 != top) {
    limit = (end + top) >> 1;
    int count = Dfs(1, 0).cnt;
    if (count >= m) {
      end = limit;
    } else {
      top = limit;
    }
  }
  printf("%lld\n", end);
  return 0;
}
```



---

## 作者：carefree_Zhuang (赞：4)

#### 我想对于本题的贪心做一个简单的证明，帮助像我一样的初学者理解。

本题对赛道长度进行二分，`check` 函数在树上统计成功匹配的赛道条数。对于一个节点,将包含父节点到此节点的边的最长路径返回。贪心出现在对于一个节点，它的子节点对应的最长路径的两两匹配。（详见其他题解）

#### 形式化地：

有集合 $A$ 代表各子节点上传的路径长度,长度 $l$ 是二分的当前长度

$A = {a_1,a_2...a_n}$

若有 $1\leq p \lt q \leq n $ 使得 $a_p+a_q \geq l$，则在集合中去除这两个元素，并 `ans++` ，找出答案最大的匹配方式。

#### 正确的贪心：

找到最小的元素 $a_x$，若找到第一个不小于 $l-a_x$ 的元素 $a_y$ ，去除这两个元素，`ans++` ;若没找到，跳到 $a_x$ 元素大小上的后继
（可以理解成将集合当成序列，按大小排，遍历）

#### 证明：

分类：

1、最优匹配中包含 $a_x$

则应该选择 $a_y$，因为选择小于它的元素都不满足条件。选择大于它的元素的情况，选择 $a_y$ 对其是具有决策包容性的。

2、最优匹配中不包含 $a_x$

则最优排列中必然包含 $a_y$，否则还有未统计的匹配对 $(a_x,a_y)$。设 $a_y$ 与 $a_z$ 匹配，显然 $a_z \geq a_x$。那么这个匹配可能不是最优，或与选$a_x$等效。

所以，以上贪心方法是正确的。

```
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;

const int N=5e4+10;
int n,m,tot,l,r,ans;
int head[N],ne[N<<1],ver[N<<1],edge[N<<1];

void add(int x,int y,int z){
	ver[++tot] = y;
	edge[tot] = z;
	ne[tot] = head[x];
	head[x] = tot;
}

int get_hi(int x,int fa){
	int max1=0,max2=0;
	for(int i=head[x];i;i=ne[i]){
		int y=ver[i],z=edge[i];
		if(y==fa)continue;
		max2 = max(max2,get_hi(y,x)+z);
		if(max2>max1)swap(max1,max2);
	}
	r = max(r,max1+max2);
	return max1;
}

int dfs(int x,int fa,int l){
	multiset<int> a;
	for(int i=head[x];i;i=ne[i]){
		int y=ver[i],z=edge[i];
		if(y==fa)continue;
		int val=dfs(y,x,l);
		if(z+val>=l){
			ans++;
		}
		else{
			a.insert(z+val);
		}
	}
	//greedy algorithm
	int Max=0;
	while(!a.empty()){
		multiset<int>::iterator p=a.begin();//get a_x
		multiset<int>::iterator q=a.lower_bound(l-(*p));//find a_y
		//two situations
		if(p==q)q++;//attention:q can't be p itself
		if(q!=a.end()){
			a.erase(q);
			ans += 1;//get the pair
		}
		else{
			Max = *p;// for the return
		}
		a.erase(p);
	}
	return Max;
}

bool check(int l){
	ans = 0;
	dfs(1,0,l);
	return ans>=m;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n-1;++i){
		int a,b,l;
		scanf("%d%d%d",&a,&b,&l);
		add(a,b,l);
		add(b,a,l);
	}
	l = r = 0;
	get_hi(1,0);
	while(l<r){
		int mid=l+r+1>>1;
		if(check(mid))l = mid;
		else r = mid-1;
	}
	printf("%d\n",l);
	return 0;
}
```


---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5021)

---

# 思路：
在树上选 $m$ 条不重合的路径（可以有交点），使得这些路径长度的最小值最大。

看到最小值最大，很自然想到二分模型：枚举最小值 $L$，看大于等于 $L$ 的路径能不能有 $m$ 条。

如何在树上选出 $m$ 条路径最优成为我们要思考的问题，考虑树上贪心。

普遍的思路是从叶子节点按子树合并，我们要让该子树对父亲的贡献最大，一定是在该子树已经无法拼出路径（贪心）后剩下的路径中取最大值（由于父亲唯一，所以只能留下最大值）。

设 $f(u)$ 为 $u$ 子树内的节点到 $u$ 节点的路径中无法拼出赛道的最长路径，我们已知所有的 $f(v)+w(u,v)$，对于 $f(v)+w(u,v)\ge L$ 的，直接贡献 $+1$，对于剩下的，我们可以先让小的路径得到匹配，无法匹配的就更新 $f(u)$。这个过程可以用 ```multiset``` 维护。

复杂度为 $O(n\log n\log\sum l)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int a,b,p,res,x,y,z,mx,l=1,r,ans,s[N],nxt[N],lst[N],Fa[N];
bool vis[N];
vector<pair<int,int> >st[N];
int f(int n){
	return Fa[n]==n?n:Fa[n]=f(Fa[n]);
}
void dfs(int n,int fa){
	s[n]=0;
	vector<int> q;
	q.clear();
	for(int i=0;i<st[n].size();i++){
		int v=st[n][i].first,val=st[n][i].second;
		if(v==fa){
            continue;
        }
		dfs(v,n);
		if(s[v]+val>=p){
            res++;
        }else{
            q.push_back(val+s[v]);
        }
	}
	if(!q.size()){
        return;
    }
	if(q.size()==1){
		s[n]=q[0];
		return;
	}
	sort(q.begin(),q.end());
	for(int i=0;i<=(int)q.size();i++){
        Fa[i]=i;
        vis[i]=0;
    }
	for(int i=0;i<(int)(q.size()-1);i++){
		if(vis[i]){
            continue;
        }
		if(i>=q.size()-1||i==-1){
            break;
        }
		int t=lower_bound(q.begin()+i+1,q.end(),p-q[i])-q.begin();
		if(t>=q.size()){
            continue;
        }
		t=f(t);
		if(t>=q.size()){
            continue;
        }
		if(q[t]+q[i]<p){
            continue;
        }
		vis[t]=1;
		vis[i]=1;
		Fa[t]=t+1;
		res++;
	}
	for(int i=(int)(q.size()-1);i>=0;i--){
        if(!vis[i]){
            s[n]=q[i];
            break;
        }
    }
}
bool check(int n){
	p=n;
	res=0;
	dfs(1,0);
	return res>=b;
}
signed main(){
	cin>>a>>b;
	for(int i=1;i<a;i++){
		cin>>x>>y>>z;
		mx+=z;
		st[x].push_back(make_pair(y,z));
		st[y].push_back(make_pair(x,z));
	}
	r=mx;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid)){
            l=mid+1;
            ans=mid;
        }else{
            r=mid-1;
        }
	}
	cout<<ans<<endl;
	return 0;
}
```
完结撒花~

---

## 作者：lihaoda0120 (赞：0)

# [[NOIP2018 提高组] 赛道修建](https://www.luogu.com.cn/problem/P5021)

二分+贪心的树上问题，可以先思考二叉树的部分分

首先二分显然。`check`：不是很好 dp,于是考虑怎么贪心

自底向上考虑，考虑到点 $u$ 时，用数组 $d_v$ 表示点 $v$ 可以传给它的父亲 $u$，$d_v$ 长的一条链。我们可以将儿子的 $d$ 值组合成 $lca=u$ 的路径，还可以将一个儿子的 $d$ 值继承过来，有一个贪心：能越早组成满足要求的路径越好，所以儿子能拼成就立马拼，然后在拼不成的儿子里选一个最长的传给父亲。儿子最多能拼几个？每个儿子要找另一个满足条件且 $d$ 值最小的儿子来拼，用 `multiset` 维护一下就行了

```cpp
#include<bits/stdc++.h>
#define fre(name) freopen(name".in","r",stdin),freopen(name".out","w",stdout)
#define psb push_back
#define ppb pop_back
#define fi first
#define se second
#define endl '\n'
using namespace std;
const int N=5e4+5;
struct edge{int v,w,nxt;} g[N<<1];
int n,m,u,v,w,tot,head[N],d[N];
multiset<int> s;
void add(int u,int v,int w){g[++tot]=(edge){v,w,head[u]};head[u]=tot;}
int dfs(int u,int fa,int mid){
	int cnt=0;
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].v;
		if(v==fa)continue;
		cnt+=dfs(v,u,mid);
	}
	s.clear();
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].v,w=g[i].w;
		if(v==fa)continue;
		d[v]+=w;
		if(d[v]>=mid)cnt++;
		else s.insert(d[v]);
	}
	d[u]=0;
	while(!s.empty()){
		int x=*s.begin();
		s.erase(s.begin());
		auto it=s.lower_bound(mid-x);
		if(it!=s.end())cnt++,s.erase(it);
		else d[u]=max(d[u],x);
	}
	return cnt;
}
bool check(int mid){return dfs(1,0,mid)>=m;}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++){
		cin>>u>>v>>w;
		add(u,v,w),add(v,u,w);
	}
	int l=0,r=5e8+1;
	while(r-l>1){
		int mid=(l+r)>>1;
		if(check(mid))l=mid;
		else r=mid;
	}
	cout<<l<<endl;
	return 0;
}
```

---

## 作者：JXR_Kalcium (赞：0)

## 题目大意

给定一棵有 $n$ 个结点的树，要选出 $m$ 条路径，使得路径中的边互不相交且最短路径长度最大。

## 解题思路

首先对于这种“最小值最大”的题目显然是一个二分，可以二分 $m$ 条路径中的最短路径长度。对于 `check` 函数，可先去 DFS 每一个点，在回溯的时候统计贡献。具体来说，用 $f_i$ 表示以 $i$ 为根的子树中，现在能传到父亲的链的最长链长度（相当于是往上跳累加贡献），$d_i$ 表示除了当前点 $x$ 的父亲 $y$ 以外的所有出边所连的点现在传到 $x$ 的贡献，一共有 $cnt$ 个这样的点，可得 $d_i=f_{to_x}+w_{(x,to_x)}$。之后将 $d$ 从小到大排序，然后将长度大于等于 $mid$ 的 $d_i$ 全部剔除（也就是将 $cnt$ 一直减下去），且对于这些被剔除的长度将创建的路径数量 $res$ 更新（这些长度是肯定可以自己创建一条的）。

然后对于剩下来的这些长度要两两匹配，根据贪心思想肯定是从小到大匹配。我们用 $bz_i$ 表示 $d_i$ 这个长度是否被匹配过，方便起见若匹配过就赋值为 $x$。这样对于每一个没有被匹配过的长度，都去进行一个新的二分，然后看看两个长度加起来有没有大于等于 $mid$，如果是的话就更新匹配到的长度编号 $t$，二分结束将 $t$ 往后移，直到 $d_t$ 这个长度没有被标记为止，接着把 $d_i$ 和 $d_t$ 标记一下，更新 $res$ 即可。

把这些长度经过这样一轮匹配之后，剩下没有匹配的点肯定要更新 $f_x$ 的值，而显然要让这个值更大，所以可得 $f_x=\max(d_i)$。跑完一遍 DFS 后检查 $res$ 和 $m$ 的关系即可，如果 $res\ge m$ 就说明当前 $mid$ 值可用，更新答案即可，若超时把二分的范围改成 $\left[0,\sum_{i=1}^{n-1}w_{(u_i,v_i)}\right]$ 即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,m,u,v,w,ans,last[50001],cnt,l,r,mid,res,tot,f[50001],d[50001],bz[50001],t,l1,r1,mid1;
struct edge {ll next,to,k;} e[100001];
void add(ll u, ll v, ll w) {e[++cnt]={last[u],v,w}; last[u]=cnt;}

void dfs(ll x, ll y)
{
    for(R int i=last[x]; i; i=e[i].next)
    {
        if(e[i].to!=y) dfs(e[i].to,x);
    }

    tot=0; f[x]=0;

    for(R int i=last[x]; i; i=e[i].next)
    {
        if(e[i].to!=y) d[++tot]=f[e[i].to]+e[i].k;
    }

    sort(d+1,d+tot+1);

    for(R int i=tot; i; --i)
    {
        if(d[i]<mid) break;
        else --tot, ++res;
    }

    for(R int i=1; i<=tot; ++i)
    {
        if(bz[i]!=x)
        {
            l1=i+1; r1=tot; t=1e18;

            while(l1<=r1)
            {
                mid1=l1+r1>>1;
                if(d[i]+d[mid1]<mid) l1=mid1+1;
                else r1=mid1-1, t=mid1;
            }

            while(t<=tot && bz[t]==x) ++t;
            if(t<=tot) bz[i]=x, bz[t]=x, ++res;
        }
    }

    for(R int i=tot; i; --i)
    {
        if(bz[i]!=x)
        {f[x]=d[i]; break;}
    }
}

bool check()
{
    res=0; for(R int i=1; i<=n; ++i)
    bz[i]=0; dfs(1,0);
    if(res<m) return false;
    return true;
}

int main()
{
	n=read(); m=read();

    for(R int i=1; i<n; ++i)
    {
        u=read(); v=read(); w=read();
        add(u,v,w); add(v,u,w); r+=w;
    }

    while(l<=r)
    {
        mid=l+r>>1;
        if(check()) ans=max(ans,mid), l=mid+1;
        else r=mid-1;
    }

    write(ans);
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

没看到**每条道路至多被一条赛道经过**，先想的二分套点分治qwq。。。

看到最小值最大，先二分答案。

因为有上面的条件，那么从一个子树 $u$ 发出去的赛道至多只有一条。

故考虑贪心，在 $u$ 子树内，若这两条 $x \to u$ 和 $y \to u$ 的路径和权值是 $\ge mid$ 的就合并。

为了防止浪费，尽量每次合并都接近 $mid$ 是更优的。

故首先对于 $u$ 的儿子 $v$，设 $s_v$ 表示从 $v$ 子树内传上来的链的长度，若 $s_v + w(u, v) \ge mid$ 了，则直接取就行了（不然与其它的链合并就浪费了）。

否则 $s_v + w(u, v) < mid$，令可重集 $S = \{x | x = s_v + w(u, v) \}$，即所有传到 $u$ 的长度集合。

考虑最小到达枚举，设当前枚举的权值是 $x$，那么肯定是要找大于等于 $mid - x$ 中最小的那个链合并。

这样会剩下一下链，我们需要选择其中一个传到 $u$ 上面取，显然取最大的更优。

过程使用 `multiset` 维护即可。

时间复杂度为 $O(N \log N \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int N = 5e4 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, m, u, v, w, now, sum;
int s[N];
multiset<int> S[N];
vector<pair<int, int>> E[N];
inline void add(int u, int v, int w){
	E[u].push_back({v, w});
	E[v].push_back({u, w});
}
inline void dfs(int u, int fa){
	for(auto t : E[u]){
		int v = t.fi, w = t.se;
		if(v == fa)
		  continue;
		dfs(v, u);
		if(s[v] + w >= now){
			++sum;
			continue;
		}
		S[u].insert(s[v] + w);
	}
	while(!S[u].empty()){
		int x = (*S[u].begin());
		S[u].erase(S[u].begin());
		auto it = S[u].lower_bound(now - x);
		if(it == S[u].end()){
			s[u] = max(s[u], x);
			continue;
		}
		++sum;
		S[u].erase(it);
	}
}
inline bool check(int mid){
	sum = 0;
	now = mid;
	for(int i = 1; i <= n; ++i){
		s[i] = 0;
		S[i].clear();
	}
	dfs(1, 1);
	return sum >= m;
}
int main(){
	n = read(), m = read();
	for(int i = 1; i < n; ++i){
		u = read(), v = read(), w = read();
		add(u, v, w);
	}
	int l = 1, r = 5e8, ans = 0;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid)){
			ans = mid;
			l = mid + 1;
		}
		else
		  r = mid - 1;
	}
	write(ans);
	return 0;
}
```

---


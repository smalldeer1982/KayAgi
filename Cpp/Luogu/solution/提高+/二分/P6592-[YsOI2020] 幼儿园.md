# [YsOI2020] 幼儿园

## 题目描述

Ysuperman 热爱在 TA 的幼儿园里散步，为了更方便散步， TA 把幼儿园抽象成 $n$ 个点，$m$ 条边的**有向图**。 散步得多了， TA 就给了每一条边**无与伦比**的亲密程度：$1,2,\cdots,m$，越大代表越亲密。 TA 也给了每一个点无与伦比的编号：$1,2,\cdots,n$，其中 $1$ 代表着幼儿园大门，但是每个**点是没有亲密程度的**。

接下来 $k$ 天，Ysuperman 每天会有一次散步计划。具体而言， TA 希望从 $x_i$ 号点出发，只经过**亲密程度属于区间 $[l_i,r_i]$ 的边**，走到幼儿园大门 $1$ 号点，期间经过的边的亲密程度必须**单调递减**，不然会因为 TA 有强迫症而不能回家。


Ysuperman 看着自己刚刚画的草稿脑子一团浆糊， TA 发现 TA 始终没有办法规划出这么多合理路线，现在 TA 想请你帮 TA 。具体而言，对于每一天的计划，如果可行，则输出 `1`，反之输出 `0`。

当然啦，有的时候 Ysuperman 很着急，需要你立马回复，有的时候 TA 可以等等你，先把所有问题问完再等你回复。

## 说明/提示

### 样例说明

#### 样例说明 $1$

![](https://cdn.luogu.com.cn/upload/image_hosting/wxji6w6f.png)

对于第 $2$ 条计划，Ysuperman 已经站在门口，所以计划可行。

对于第 $3$ 条计划，Ysuperman 只能通过路径 $5 \overset{6}{\rightarrow}3 \overset{5}{\rightarrow} 1$。（箭头上方数字表示的是边的亲密程度）。

其他计划都是不可行的。

#### 样例说明 $3$

样例三为加密后的样例二。

----

### 数据范围

**本题采用捆绑测试。**

| $\mathrm{subtask}$ |     $n$     |       $m$        |        $k$        |  特殊性质   | 分数  |
| :----------------: | :---------: | :--------------: | :---------------: | :---------: | :---: |
|        $1 $        |   $\le17$   |     $\le17$      | $\le 2\cdot 10^5$ |      /      | $ 5$  |
|        $2$         |  $\le500$   |     $\le500$     |     $\le500 $     |      /      | $17$  |
|        $3 $        | $\le 3000$  |   $\le 3000 $    |    $\le 3000 $    |      /      | $18 $ |
|       $ 4 $        |  $\le10^5$  | $\le2\cdot10^5$  |  $\le2\cdot10^5$  |   $v_i=1$   | $13$  |
|        $5 $        | $\le 10^5$  | $\le 2\cdot10^5$ |    $\le 10^5$     | $l_i=1,w=0$ | $ 7 $ |
|        $6$         | $\le10^5 $  | $\le2\cdot10^5$  |    $\le 10^5$     |   $w=0 $    | $13 $ |
|        $7$         | $ \le 10^5$ | $\le 2\cdot10^5$ | $\le 2\cdot10^5$  |      /      | $27$  |

对于 $100\%$ 的数据，满足 $1 \le n \le 10^5 ,1 \le m \le 2\cdot10^5 ,0 \le k \le 2\cdot10^5$。

$w\in\{0,1\},1 \le u_i,v_i \le n$。

$x_i,l_i,r_i$ 在解密后保证 $1\le x \le n ,1 \le l_i,r_i \le m $。

### 提示

**不保证不出现重边自环，不保证图联通**。

## 样例 #1

### 输入

```
5 7 5 0
3 2
1 2
4 3
5 4
3 1
5 3
5 1
3 1 4
1 2 2
5 5 6
4 5 7
2 1 7
```

### 输出

```
0
1
1
0
0
```

## 样例 #2

### 输入

```
5 12 10 0
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
3 1 8
3 1 4
3 5 5
2 1 12
4 10 12
2 5 5
1 1 3
```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

## 样例 #3

### 输入

```
5 12 10 1
4 2
4 2
5 3
3 3
1 5
1 4
4 4
2 4
5 3
1 5
2 2
4 1
4 3 5
4 2 3
1 4 5
2 0 9
2 0 5
2 4 4
3 0 13
5 11 13
0 7 7
3 3 1```

### 输出

```
0
0
1
0
0
0
0
1
0
1
```

# 题解

## 作者：Lskkkno1 (赞：16)

- [P6592 [YsOI2020]幼儿园](https://www.luogu.com.cn/problem/P6592)

### 题目描述

给定一个有向图。

每次询问从点 $x$ 开始走，只能经过编号在 $[l, r]$ 的边，且走的边的编号**单调递减**，是否可以走到 $1$ 号点。

强制在线。

### 正解

这里提供一个贪心 + 线段树的做法，跑得还挺快的。

#### 前置信息

按照套路建反图，现在问题变成从 $1$ 号点出发，走的边的编号**单调递增**，是否可以走到 $x$ 。

可以将一条路径抽象看做是数轴上 $[l, r]$ 的线段，询问就是看给定的区间 $[l_q, r_q]$ 是否包含了一条线段（即路径）。

由于问题强制在线，所以要考虑把从 $1$ 号点到每个 $x$ 点的一些**有用**的路径 $[l, r]$ 给预处理出来。

**"有用的路径"** 是什么意思呢？

如果固定了走的最大边为 $r$，那么走最小边 $l$ 肯定越大越好，$l$ 更小的路径就没用了。

有一个比较有用的性质是：有用的路径不超过 $m$ 条（在后面会有证明），于是可以全部预处理出来。

#### 进入正题

从小往大枚举每一条边，这样子更新一系列的信息是没有后效性的。

设 $f_x$ 为从 $1$ 号点到 $x$ 号点的一条路径，最小边编号 $l$ 最大可以是多少。

假设现在枚举的一条边是 $u \to v$，编号为 $i$。

这条边只会影响到点 $v$（不会影响到其他点），

因为当前从 $v$ 号点再往其他点走，是走不动的，其他边的编号都小于它。

而之后的路径也不会用到这条边去更新其他点，新的路径的 $r$ 一定大于等于 $i$。

这条边只会多生成一条从 $1$ 到 $v$ 的**有用的路径**，即 : 从之前 $1$ 到 $f_u$ 走的路径加上 $u \to v$ 这一条边，表示成线段是 $[f_u, i]$。

并将 $f_v$ 对 $f_u$ 取 $\max$。

特别的，如果 $u$ 是一号点，直接将 $f_v$ 赋值为当前枚举边的编号，如果 $v$ 是 $1$ 号点，不进行任何操作。

现在知道了所有有用的路径，询问就是一个简单的**二维偏序**问题（$l_q \le l ,~~ r \le r_q$）。

对于每一个点 $x$，用动态开点的线段树维护左端点 $l$ 在 $[l_q, r_q]$ 中 ，右端点的最小值，判断其是否小于 $r_q$ 即可。

时间复杂度 $O(n \log n)$。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int n, m, q, w;
int f[N];

int ll, rr, cv, vcnt;
int root[N];
struct node {
    int lch, rch, val;
} a[N * 30];

void modify(int &u, int l, int r) {
    if(!u) u = ++vcnt, a[u].val = N;
    if(l == r) return a[u].val = min(a[u].val, cv), void();
    int mid = (l + r) >> 1;
    if(ll <= mid) modify(a[u].lch, l, mid);
    else modify(a[u].rch, mid + 1, r);
    a[u].val = min(a[a[u].lch].val, a[a[u].rch].val);
}
int query(int u, int l, int r) {
    if(!u || (ll <= l && r <= rr)) return a[u].val;
    int mid = (l + r) >> 1;
    if(rr <= mid) return query(a[u].lch, l, mid);
    else if(mid < ll) return query(a[u].rch, mid + 1, r);
    else return min(query(a[u].lch, l, mid), query(a[u].rch, mid + 1, r));
}

inline int read() {
    int x = 0; char ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x;
}

int main() {
    //freopen("b.in", "r", stdin);
    //freopen("b.out", "w", stdout);
    n = read(), m = read(), q = read(), w = read();
    memset(f, -1, sizeof f);
    f[1] = 0;
    a[0].val = N;
    for(int i = 1, u, v; i <= m; ++i) { // 反边单调递增
        v = read(), u = read();
        if(~f[u]) {
            f[v] = max(f[v], u == 1 ? i : f[u]);
            ll = rr = f[v], cv = i;
            modify(root[v], 1, m);
        }
    }
    int L = 0;
    for(int Case = 1, x, l, r; Case <= q; ++Case) {
        x = read(), l = read(), r = read();
        if(w) x ^= L, l ^= L, r ^= L;
        if(x == 1) {
            puts("1"), ++L;
            continue;
        }
        ll = l, rr = m;
        int rMin = query(root[x], 1, m);
        if(rMin <= r) {
            puts("1"), ++L;
            continue;
        } else {
            puts("0");
        }
    }
    return 0;
}

```

---

## 作者：Imakf (赞：11)

~~容易发现本题的强制在线是来搞笑的。~~

### $\rm{substask}\ 1(5pts)$

可以预处理答案，枚举区间 $l,r$，起始位置 $x$，暴力 $O(2^m)$ 计算即可。

复杂度 $O(nm^22^m)$。

只有自环能卡满 $2^m$，但是显然自环可以不看，所以复杂度是卡不满的，于是可过。

----

### $\rm{subtask}\ 2(17pts)$

考虑 dp。

设 $dp_{L,R}$ 表示只考虑亲密程度 $\ge L$ 的边，上一条经过的边的亲密程度是 $R$，是否能够走到 $1$。

既然知道上一条边是什么，那就可以知道当前所在节点。

于是枚举出边，保证满足限制的情况下转移即可。

对于每一组询问，都强制添加一条新边 $0\rightarrow x_i$，强制令它的亲密程度 $p$ 为 $r+1$，$0$ 是一个不起作用的虚拟节点。

然后直接查询 $dp_{l_i,r+1}$ 即可。

复杂度为 $O(nm(m+q))$。

---

### $\rm{subtask}\ 3(18pts)$

之前以为上面的 $\rm{subtask}\ 2$ 做法可过本部分分，然而被不信邪的出题人卡掉了。


验题人尝试了：dp剪枝，当前弧优化，二维树状数组等，均假掉了。

于是验题人再也没有想出此 $\rm{subtask}$ 的做法。

所以这一档部分分是来卖萌的？

（好像赛时有人写了这档部分分，用的是 sub5 的思路）

----

### $\rm{subtask}\ 4(13pts)$

此档部分分可转化为：

给定长度 $m$ 的区间，每次询问 $[l_i,r_i]$ 是否存在 $x_i$，强制在线。

这显然可以主席树解决。

复杂度 $O((m+k)\log n)$。

-----

当然有更简单的做法，对每一个数开个 vector，记录出现位置。

查询只需要二分一下就可以了。

---

### $\rm{subtask}\ 5(7pts)$ $l_i=0,w=0$

此部分分为正解指明了方向。

你只需要知道 $x$ 第一次与 $1$ 联通的时间。

于是记 $t_i$ 表示 $i$ 第一次与 $1$ 联通的时间，显然有 $t_1=0$。

此后从小到大枚举第 $i$ 条边 $(u_i,v_i)$。

如果 $t_{v_i}$ 有值，则 $t_{u_i}=i$。

复杂度 $O(m+k)$。


---

### $\rm{subtask}\ 6(13pts)$ $w=0$

在 $\rm{subtask}\ 5$ 中，$t_i$ 表示 $i$ 第一次与 $1$ 联通的时间。

我们修改一下，令 $t_i$ 表示 $i$ 到 $1$ 的路径，**需要经过的最小边权最大是多少**，这个东西是会变化的。

最初令所有的 $t_i=0$。

然后我们一条一条往图中从小到大加入边。

假设现在加入的边是从小到大第 $i$ 条 $(u_i,v_i)$。

- 如果 $v_i = 1$ 则 $t_{u_i} = i$

- 否则 $t_{u_i}= \max(t_{u_i},t_{v_i})$。

我们对于所有的询问按 $r_i$ 从小到大排序。

那么我们只要看加入 $1\sim r_i$ 条边后的 $t_x$ 是否大于等于 $l_i$ 即可。

**注意特判 $x_i=1$。**

复杂度 $O(m+k \log k)$。

----

### $\rm{subtask}\ 7(27pts)$

在线我们可以直接使用主席树维护 $t_i$。

复杂度 $O((m+k)\log n)$。

----

我们也可以不使用主席树。

对于每一个 $i$，记录它何时被修改过，二分 $\le r$ 最近的修改即可。

复杂度 $O(m+k \log m)$。

----

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;
#define MX (100000 + 233)

int read(){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9')
		x = x * 10 + k - '0' ,k = getchar();
	return x;
}

int n ,m ,k ,w ,L ,dp[MX];
vector<int> vec[2][MX];

int main(){
	n = read() ,m = read() ,k = read() ,w = read();
	for(int i = 1 ; i <= n ; ++i)
		vec[0][i].push_back(0) ,vec[1][i].push_back(0); 
	for(int i = 1 ,u ,v ; i <= m ; ++i){
		u = read() ,v = read();
		if(u == 1) continue;
		if(v == 1){dp[u] = i;
		}else{dp[u] = max(dp[v] ,dp[u]);}
		vec[0][u].push_back(i);
		vec[1][u].push_back(dp[u]);
	}
	int L = 0;
	for(int i = 1 ,x ,l ,r ; i <= k ; ++i){
		x = read() ,l = read() ,r = read();
		x ^= L * w ,l ^= L * w ,r ^= L * w;
		auto kksk = upper_bound(vec[0][x].begin() ,vec[0][x].end() ,r);
		--kksk;
		auto s = vec[1][x].begin() + (kksk - vec[0][x].begin());
		if(*s >= l || x == 1) puts("1") ,++L;
		else puts("0");
	}
	return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：3)

一篇主席树的做法。

我们首先设 $f_{i}$ 表示当前点在前 $r$ 条边内走到 $1$ 的最小边的最大值。

初始化，$f_{1}$ 设一个极大值，因为自己到自己不用走，直接设无限大即可；其余的在一开始没有边，都是不通向 $1$ 的，所以设一个极小值。

我们在输入边的时候，我们是需要建主席树的，每一个版本对应前 $i$ 条边所得的 $f$ 的值。我们对于 $f$ 数组，假设当前边为 $(u,v)$，我们知道如果想要到 $1$ 号点的话，$v$ 必须要能直接或者间接通向 $1$，那么我们的 $f_{v}$ 就是当前边的编号 $i$ 与原来的 $f_{v}$ 的值取 $\min$，因为我们是要保证当前的 $v$ 要通向 $1$，只有 $f_{1}$ 和 $i$ 才能成功标记成当前 $v$ 是通向 $1$ 的；然后我们对于 $f_v$，当然是和上面求得的值取 $\max$ 才能保证最优。

每处理完一条边，我们就更新一个主席树的版本，然后对于后面的查询操作，我们就可以直接查询第 $r$ 个版本，也就是前 $r$ 条边所求得的 $f_{x}$ 是不是大于 $l$ 即可。

因为我们的 $f_{i}$ 表示的是从 $i$ 到 $1$ 号点走过的最小边的最大值，所以如果 $f_{i}$ 都小于 $l$ 的话，说明在当前限制下是走不到 $1$ 的。

~~其实 `build` 主要还是为了给 $1$ 号点赋上极大值。~~

code：

```cpp
#include <bits/stdc++.h>

#define INF 0x3f3f3f3f
#define int long long
#define N 500010

using namespace std;

int n, m, k, w, a[N], rt[N], u[N], v[N], val[N << 5], ls[N << 5], rs[N << 5], cnt, sum;

inline void build(int &x, int l, int r)
{
	x = ++ cnt;
	if(l == r) return val[x] = a[l], void();
	int mid = (l + r) >> 1;
	build(ls[x], l, mid);
	build(rs[x], mid + 1, r);
	return ;
}

inline void add(int &x, int pre, int l, int r, int p)
{
	x = ++ cnt, ls[x] = ls[pre], rs[x] = rs[pre], val[x] = val[pre];
	if(l == r) return val[x] = a[l], void();
	int mid = (l + r) >> 1;
	if(p <= mid) add(ls[x], ls[pre], l, mid, p);
	else add(rs[x], rs[pre], mid + 1, r, p);
	return ;
}

inline int ask(int x, int l, int r, int p)
{
	if(l == r) return val[x];
	int mid = (l + r) >> 1;
	if(p <= mid) return ask(ls[x], l, mid, p);
	else return ask(rs[x], mid + 1, r, p);
}

signed main()
{
	cin >> n >> m >> k >> w;
	for(int i = 1; i <= m; i ++)
		cin >> u[i] >> v[i];
	for(int i = 1; i <= n; i ++)
		a[i] = -INF;
	a[1] = INF;
	build(rt[0], 1, n);
	for(int i = 1; i <= m; i ++)
	{
		a[u[i]] = max(a[u[i]], min(a[v[i]], i));
//		cout << u[i] << " " << a[u[i]] << "  " << v[i] << " " << a[v[i]] << endl; 
		add(rt[i], rt[i - 1], 1, n, u[i]);
	}
	for(int i = 1; i <= k; i ++)
	{
		int x, l, r;
		cin >> x >> l >> r;
		if(w == 1) x ^= sum, l ^= sum, r ^= sum;
		int d = ask(rt[r], 1, n, x);
		if(d >= l) cout << "1" << endl, sum ++;
		else cout << "0" << endl;
	}
	return 0;
}
```

---

## 作者：BYR_KKK (赞：1)

主席树做法。

放在图上的操作都很不好做，考虑放在序列上进行刻画，不难发现等价于这样一个问题：

>有 $n$ 个 $01$ 变量 $f_i$，初始 $f_1=1$，其余 $f_i=0$。每次操作 $(u,v)$ 代表令 $f_u=f_u|f_v$，询问做 $[l,r]$ 内的操作后能否使 $f_x=1$。

这样就有一个 $O(mk)$ 的做法了。考虑能否在离线情况下做到 polylog。将询问挂到右端点上后扫描线。令 $g_i$ 为当右端点固定为 $r$ 时，最大的 $l$ 使得做 $[l,r]$ 的操作后 $f_i=1$。我们不难发现如果做 $[l,r]$ 的操作后 $f_i=1$，那么对于 $l'\le l$，做 $[l',r]$ 的操作后 $f_i=1$ 成立。

因此 $g_i$ 就可以在扫描线的过程中简单维护了，具体来说，设第 $r$ 次操作为 $(u,v)$，那么 $g_u=\min(g_u,\max(g_v,r))$。离线的情况就解决了。发现每次只会使一个 $g_i$ 发生变化，因此主席树维护变化即可，时间复杂度 $O((n+q)\log n)$。

---

## 作者：Otomachi_Una_ (赞：1)

给一个不需要脑子的主席树题解。

## 题目简述

> - 给定**有向**图 $G$，边权为 $1$ 到 $m$ 的排序。
> - 每次询问给 $x,l,r$ 询问有没有从 $x$ 出发到达 $1$ 的路径使得：
>   - 路径上的边权递减。
>   - 路径上的边权在 $[l,r]$ 之间。
> - 强制在线。
> - $n,m,q\leq 2\times 10^5$。

## 解题思路

既然说了强制在线我们还是要思考一下离线做法。

离线下来对 $r$ 排序，不难发现当 $r$ 一定时，你只能选 $[1,r]$ 之间的边，这是每个点都会有一个固定的 $f_u$ 表示从 $u$ 出发到达 $1$ 的递减路径中最小边权最大可能，这时对于询问我们只需要判断 $l$ 和 $f_x$ 的大小关系即可。

当 $r-1$ 转移到 $r$ 时，应该让 $f_{u_r}\leftarrow \max(f_{u_r},\min(f_{v_r},r))$，这里初始时赋 $f_1=+\infty$。我们就学会了离线做法。

我们思考一下在线做法，不难发现每次 $r-1$ 转移到 $r$ 时 $f$ 只会改动一个值，我们需要查询历史状态，主席树维护即可。

## 参考代码

这里建议封装需要用的一切数据结构。

```cpp
#include<iostream>
using namespace std;
const int MAXN=2e5+5;
int n,m,k,w; 
int f[MAXN],rt[MAXN];
int u[MAXN],v[MAXN];
int sum=0;
namespace sugtree{
int cnt=0;
int a[MAXN<<4],ls[MAXN<<4],rs[MAXN<<4];
void build(int &id,int l=1,int r=n){
	id=++cnt;
	if(l==r) {a[id]=f[l];return;}
	int mid=l+r>>1;
	build(ls[id],l,mid);
	build(rs[id],mid+1,r);
}
void change(int &id,int copy,int x,int l=1,int r=n){
	id=++cnt;
	a[id]=a[copy],ls[id]=ls[copy],rs[id]=rs[copy];
	if(l==r){a[id]=f[l];return;}
	int mid=l+r>>1;
	if(x<=mid) change(ls[id],ls[copy],x,l,mid);
	else change(rs[id],rs[copy],x,mid+1,r);
}
int query(int id,int x,int l=1,int r=n){
	if(l==r) return a[id];
	int mid=l+r>>1;
	if(x<=mid) return query(ls[id],x,l,mid);
	else return query(rs[id],x,mid+1,r);
}
}
int main(){
	cin>>n>>m>>k>>w;
	for(int i=1;i<=m;i++)
		cin>>u[i]>>v[i];
	for(int i=1;i<=n;i++) f[i]=-1e9;
	f[1]=1e9;
	sugtree::build(rt[0]);
	for(int i=1;i<=m;i++){
		f[u[i]]=max(f[u[i]],min(f[v[i]],i));
		sugtree::change(rt[i],rt[i-1],u[i]);
	}
	while(k--){
		int x,l,r;cin>>x>>l>>r;
		if(w) x^=sum,l^=sum,r^=sum;
		int d=sugtree::query(rt[r],x);
		if(d>=l) {cout<<"1"<<endl;sum++;}
		else cout<<"0"<<endl; 
	}
	return 0;
} 
```



---


# [COCI 2019/2020 #2] Checker

## 题目背景


> "...fool me once, shame on — shame on you. Fool me — you can't get fooled again." — W

## 题目描述

有一种规则多边形 ，它们的 $n$ 边分别用某三种颜色之一着色，并且其顶点按顺时针顺序从 $1$ 到 $n$ 表示。

多边形的三角剖分是指将其面积分解为一组不重叠的三角形的操作，这些三角形的边可能是多边形的边或其内对角线上。当然，在此任务中，用于多边形三角剖分的每条对角线也用三种颜色之一着色。

如果每个三角形的 $n\space−\space2$ 个三角形的所有三个面都具有不同的颜色，则称这样的三角剖分是“非常好”的。

您的任务是确定给定的对角线多边形是否被三角剖分以及该三角剖分是否非常好。

## 说明/提示

#### 数据规模及约定

本题采用 **捆绑测试**。

| Subtask 编号 | Subtask 分数 | Subtask 数据规模及约定 |
| :----------- | :----------- | :----------- |
| $1$ | $12$ | $4 \le n \le 300$ |
| $2$ | $17$ | $4 \le n \le 2000$ |
| $3$ | $23$ | $4 \le n \le 2 \times 10^5$，数据保证输出为 $\mathtt{neispravna \space triangulacija}$ 或 $\mathtt{tocno}$ |
| $4$ | $23$ | $4 \le n \le 2 \times 10^5$，数据保证输出为 $\mathtt{neispravno \space bojenje}$ 或 $\mathtt{tocno}$ |
| $5$ | $35$ | $4 \le n \le 2 \times 10^5$ |

**特别的**，对于 $100\%$ 的数据，$1\le T\le 5$。
 
#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #2](https://hsin.hr/coci/archive/2019_2020/contest2_tasks.pdf) *T3 Checker*。**

## 样例 #1

### 输入

```
1
5
12113
1 3 3
2 5 2
```

### 输出

```
neispravna triangulacija```

## 样例 #2

### 输入

```
1
4
1212
1 3 2
```

### 输出

```
neispravno bojenje
```

## 样例 #3

### 输入

```
1
7
1223121
1 3 3
3 5 1
5 7 3
7 3 2
```

### 输出

```
tocno```

# 题解

## 作者：☯☯枫☯☯ (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P6677)

~~恶心的题目……~~

**题目翻译有误：**

第一行 $T$ 不是数据组数，而应是该数据点属于哪个子任务。

**题目分析：**

其实这题没什么算法或者数据结构，主要考一个想法。

提供一个 $\mathcal{O}(nlog(n))$ 的算法。

---

### 问题1：能否构成三角剖分？

有两种做法：

**第一种：时间复杂度：$\mathcal{O}(nlog(n))$**

用 $vector$ 邻接表存边，然后对于每一个点 $i$，按另一点的编号将边从小到大排序。我们称**排序后**从节点 $i$ 出发的边中**序号相邻**的边为**从 $i$ 出发的相邻两边**。

> 引理1：对任意凸多边形（后面的多边形均指凸多边形），一个合法三角剖分从任意一点 $i$ 出发的任意**相邻两边**一定是该三角剖分中一个三角形的两边（即从点 $i$ 出发的任意相邻两边**必定**能找到对应的第三边构成三角形）。

**说明：**

当这个剖分为合法的三角剖分时，根据合法三角剖分的定义，正确性显然。

当该剖分不合法时，此时一共只有 $n-3$ 条对角线。我们从合法的三角剖分的基础上对边进行改变得到这个不合法的剖分。

在合法三角剖分的基础上改变部分的对角线，必定至少有一个三角形被破坏。因此存在一点 $j$，满足存在从 $j$ 出发的相邻两边不能找到对应的第三边构成三角形。

得证。

综上所述，我们直接扫一遍所有的点，对以上条件进行判断即可。

**注意：**

由于已经对边排序，在找是否存在第三边时，可以**二分**。复杂度从 $\mathcal{O}(n^2)$ 降至 $\mathcal{O}(nlog(n))$。

$code:$
```cpp
inline int check(int x,int y){
	reg int l=0,r=f[x].size()-1,mid;
	while(l<=r){//二分查找 
		mid=l+r>>1;
		if(f[x][mid].d==y)return f[x][mid].col;//找到了 
		f[x][mid].d<y?l=mid+1:r=mid-1;
	}
	return 0;
}
inline int solve(){
	reg int ok=1;
	F(i,1,n){
		for(reg int j=1;j<f[i].size();++j){
			reg int col=check(f[i][j-1].d,f[i][j].d);//相邻两边 
			if(!col)return 0;//不存在第三边 
		}
	}
	return ok;
}
```

---

**第二种：时间复杂度：$\mathcal{O}(nlog(n))$**



记录边时同时记录开头和结尾。然后将所有边以开头（编号较小端点）为第一关键字，以结尾（编号较大端点）为第二关键字从小到大排序，用堆在线维护。

（由于本人没有这样写，就不贴代码了）

---

### 问题2：该三角剖分是否是“非常好”的？

> 引理2：若该多边形的三角剖分是“非常好”的，那么对于**所有**点 $i$ 的**所有**相邻两边，颜色必定**不同**。

**反证法:**

假设有一个“非常好”的三角剖分，其中点 $i$ 的一组相邻边 $(x,y)$ 的颜色相同。

根据引理1，必存在对应的第三边 $z$，使得 $x,y,z$ 三点构成一个三角形。在该三角形中至少有两边 $x,y$ 颜色相同，与题意中“非常好”的三角剖分定义矛盾。

得证。

综上，对所有的点判断是否有相邻两边颜色相同即可。

$code:$

```cpp
#define is_love(x,y,z) (1+((x)==(y) or (y)==(z) or (x)==(z)))
//判断是否有相同的颜色 
#define _max(x,y) ((x)>(y)?(x):(y))//手写的似乎比较快 
inline int solve(){
	reg int ok=1;
	F(i,1,n){
		for(reg int j=1;j<f[i].size();++j){
			ok=_max(ok,is_love(col,f[i][j-1].col,f[i][j].col));
		}
	}
	return ok;
}
```

**时间复杂度：$\mathcal{O}(n)$**

**总时间复杂度：$\mathcal{O}(nlog(n))$**

---

**注意：**

- 有没有发现上面问题1和问题2的代码很像？实际上，两个过程合并一下就好了（下面代码中会给出）。

- 第一行 $T$ 不是数据组数，而应是该数据点属于哪个子任务……（考试的时候被坑死了……）

- 连边的时候应从编号小的连向编号大的。

- 记得把原多边形的边加进去！

----

终于到了~~喜闻乐见的~~代码时间：
```cpp
#include<bits/stdc++.h>
#define reg register
#define F(i,a,b) for(reg int i=(a);i<=(b);++i)
inline int read();
using namespace std;
const int N=2e5+10;
int n;
char c[N];
struct P {
	int d,col;
	bool operator <(const P& a)const {
		return d<a.d;
	}
} ;
vector<P>f[N];//领接表 
inline int check(int x,int y){
	reg int l=0,r=f[x].size()-1,mid;
	while(l<=r){ //二分查找 
		mid=l+r>>1;
		if(f[x][mid].d==y)return f[x][mid].col; //找到了 
		f[x][mid].d<y?l=mid+1:r=mid-1;
	}
	return 0;
}
#define is_love(x,y,z) (1+((x)==(y) or (y)==(z) or (x)==(z))) 
//判断是否有相同的颜色 
#define _max(x,y) ((x)>(y)?(x):(y)) //手写的似乎比较快 
inline int solve(){
	reg int ok=1;
	F(i,1,n){
		for(reg int j=1;j<f[i].size();++j){
			reg int col=check(f[i][j-1].d,f[i][j].d); //相邻两边 
			if(!col)return 0; //不存在第三边 
			ok=_max(ok,is_love(col,f[i][j-1].col,f[i][j].col));
		}
	}
	return ok;
}
int main() {
	n=read(),n=read();
	scanf("%s",c+1);
	reg int x,y,z;
	F(i,1,n-3) {
		x=read(),y=read(),z=read();
		if(x>y)swap(x,y);//从编号小的连向编号大的 
		f[x].push_back({y,z});
	}
	F(i,1,n) {
		f[i].push_back({i==n?1:i+1,c[i]^48});
		//原多边形的边 
		sort(f[i].begin(),f[i].end());
		//按另一个端点的编号排序 
	}
	int ok=solve();
	if(!ok)puts("neispravna triangulacija");
	else if(ok==1)puts("tocno");
	else puts("neispravno bojenje");
	return 0;
}
inline int read() {
	reg int x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}

```

[AC](https://www.luogu.com.cn/record/50007102)

欢迎交流讨论，请点个赞哦~

---

## 作者：Wanderer_01 (赞：3)

## 题目传送门

[P6677](https://www.luogu.com.cn/problem/P6677)

题意：

1. 判断三角剖分的正确性。

2. 判断三角剖分是否是好的。

## 思路

可以对对角线的两个点间的距离进行排序，然后将 $n$ 边形删成 $n-1$ 边形。

可以证明：在合法的情况下被删除的一定是三角形，因为排序的后删除时，若两点间距离大于二，则其中的点要么被删除过了，要么不合法。

所以在消点时应该判断：

1. 是否是三角形。

2. 三角形的三边是否是不同颜色的。

对于第一个问题，可以用并查集维护当前点下一个点是什么。

对于第二个问题，直接用数组记录边的颜色，暴力比较即可。

同时，在对于最后一条边的操作需要特殊处理：**两个方向都要判断哦！**

## code

时间复杂度 $O(n\log{n})$，可以轻松通过此题。

```cpp
#include <bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
	return x*f;
}
const int N=2e5+5;
int n,tid,tag;
int a[N];
struct edge{
	int x,y,cor;
}e[N];
bool cmp(edge x,edge y){
	return min(x.y-x.x,n+x.x-x.y)<min(y.y-y.x,n+y.x-y.y);	//注意：这是一个环
}
int fa[N],vis[N];
int find(int x){		//并查集
	return vis[x]? fa[x]=find(fa[x]):x;
}
signed main(){
	tid=read(),n=read();
	for(int i=1; i<=n; i++) scanf("%1d",&a[i]);
	for(int i=1; i<=n-3; i++){
		e[i]={read(),read(),read()};
		if(e[i].x>e[i].y) swap(e[i].x,e[i].y);
	}
	sort(e+1,e+n-2,cmp);
	for(int i=1; i<=n; i++) fa[i]=i%n+1;
	for(int i=1; i<=n-4; i++){
		if(e[i].y-e[i].x>n+e[i].x-e[i].y) swap(e[i].x,e[i].y);		//判断删去的三角形的方向
		int to1=find(fa[e[i].x]),to2=find(fa[to1]);
		if(to2==e[i].y){
			vis[to1]=1;
			if(a[e[i].x]==a[to1]||a[e[i].x]==e[i].cor||a[to1]==e[i].cor) tag=1;
			a[e[i].x]=e[i].cor;
		}else{
			printf("neispravna triangulacija\n");
			return 0;		//加速
		}
	}
	int to1=find(fa[e[n-3].x]),to3=find(fa[e[n-3].y]);		//特殊情况
	int to2=find(fa[to1]),to4=find(fa[to3]);
	if(to2!=e[n-3].y||to4!=e[n-3].x){
		printf("neispravna triangulacija\n");
		return 0;
	}else if(a[to1]==a[e[n-3].x]||a[to1]==e[n-3].cor||a[e[n-3].x]==e[n-3].cor) tag=1;
	if(!tag) printf("tocno\n");
	else printf("neispravno bojenje\n");
}
```

[AC记录](https://www.luogu.com.cn/record/133260448)

## tip

其实不用并查集也可以实现，~~我是小丑，~~附上大佬 [@wuudii](https://www.luogu.com.cn/user/545433) 不用并查集的代码 （已征得其本人同意）。
```cpp
#include<bits/stdc++.h>
using namespace std;

bool f1;
int n;
int color[210000];
bool flag1,flag2;
int dis(int x,int y){
	return (y+n-x)%n;
}
struct edge{
	int x,y,color;
}e[210000];
bool cmp(edge a,edge b){
	return dis(a.x,a.y)<dis(b.x,b.y);
}
bool vis[210000];
int nxt[210000],col[210000];
bool f2;
int main(){
//	freopen("checker.5a.in","r",stdin);
	cin>>n;
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%1d",&color[i]);
	}
	for(int i=1;i<n;i++){
		nxt[i]=i+1;
	}
	nxt[n]=1;
	for(int i=1;i<=n-3;i++){
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].color);
		if(dis(e[i].x,e[i].y)>dis(e[i].y,e[i].x)){
			swap(e[i].x,e[i].y);
		}
	}
	sort(e+1,e+1+n-3,cmp);
	for(int i=1;i<=n-3;i++){
		int x=e[i].x,y=e[i].y,c=e[i].color;
		if(vis[x]||vis[y]){
			flag1=true;
			break;
		}
		if(nxt[nxt[x]]!=y){
			flag1=true;
			break;
		}
		if(color[x]==color[nxt[x]]||color[x]==c||color[nxt[x]]==c){
			flag2=true;
		}
		vis[nxt[x]]=true;
		nxt[x]=y;
		color[x]=c;
	}
	if(flag1){
		printf("neispravna triangulacija");
		return 0;
	}
	if(flag2){
		printf("neispravno bojenje");
		return 0;
	}
	printf("tocno");
} 
```

~~两份代码无本质上的区别，仅供参考。~~

---

## 作者：djh0314 (赞：0)

### 传送门 [P6677 [COCI2019-2020#2] Checker](https://www.luogu.com.cn/problem/P6677)         


### 题意
将一个 $n$ 多边形用 $n-3$ 条边分裂成 $n-2$ 个三角形。每条边有三种颜色。           
- 如果分裂方式是错误的，输出 ```neispravna triangulacija```。
- 如果对于分裂出的三角形，每个三角形三条边都不相同，输出 ```tocno```。
- 否则，输出 ```neispravno bojenje```。


### 分析

![](https://cdn.luogu.com.cn/upload/image_hosting/tulpoexa.png)


在只知道周围与一条内边的情况下，   
对于 $(3,5,7)$ 这个三角形，我们并不能快速知道这个三角形的三边是否合法。    
但是对于 $(3,4,5)$ 这个三角形，我们却可以马上判断，因为这个三角形的形状是由两个边缘与一条内边组成。       

于是我们可以从间隔为 1 的内边开始，从间隔逐一增大缩边，如果有一条内边的左右不能组成由两个边缘与一条内边的三角形，那么这个分割方案就是不成立的。(~~应该显然吧。~~)

### 实现
然后逐一实现。
1. 间隔 $\min ((v+n-u)\bmod n,(u+n-v)\bmod n)$。

2. 缩点：
```cpp
//l[i],r[i]是i左右的边，col[i]是i左侧边的颜色，cor[i]则是右边
l[v]=u,r[u]=v;
col[v]=cor[u]=co;
```
### 注意
1. $T$ 是这个数据对应的 Subtask 编号，而不是多组输入。（~~考试时以为是多组输入暴错。~~）
2. 要用 mark 记录已经缩的节点，缩边前检查节点。

### 激动人心的代码环节
[Code](https://www.luogu.com.cn/paste/2w75dete)


---


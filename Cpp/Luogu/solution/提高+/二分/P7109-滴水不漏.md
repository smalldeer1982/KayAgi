# 滴水不漏

## 题目背景

这是一道 IO 交互题。

## 题目描述

Gnar 购买了 $n$ 个水缸，其中第 $i$ 个水缸的容积为 $i$ 且因不明原因初始装有 $a_i$（$0 \le a_i \le i$）单位的水。

好奇的 Gnar 想知道每个水缸装有的水量，但肉眼观察显然不可行，他希望你能帮他计算解决这个难题。

Gnar 唯一能替你执行的操作是，由你先指定 $i, j$（$1 \le i, j \le n$），然后：

- 若 $i \neq j$，滴水不漏地将第 $i$ 个水缸的水往第 $j$ 个水缸倒，直到第 $i$ 个水缸的水被倒完或第 $j$ 个水缸已满。Gnar 会告诉你操作后第 $j$ 个水缸是否是满的。注意倒水的影响会**保留**而不是恢复到操作前。
- 若 $i = j$，Gnar 做不到让一个水缸的水往自己倒，他会直接告诉你当前第 $j$ 个水缸是否是满的。

Gnar 只肯接受**最多** $20000$ 次操作，否则他会认为你在调戏他！

你的任务是利用不超过 $20000$ 次操作 Gnar 告诉的结果，完整求出最初的 $a_1,a_2,\ldots,a_n$。

当然 Gnar 不会动手脚，你所求的 $a_1,a_2,\ldots,a_n$ 在操作前已经存在，不随操作动态生成。

## 说明/提示

**【样例解释 #1】**

样例示意了一种可能的交互过程。

初始两个水缸中分别装有 $0,1$ 单位的水。

第一次操作，由于 $i = j$，你直接得知 $x = 0$ 即第一个水缸未满。

第二次操作后两个水缸装有水量分别为 $1,0$，而你得知 $x=1$ 即第一个水缸当前已满。

第三次操作后两个水缸装有水量分别为 $0,1$，而你得知 $x=0$ 即第二个水缸当前未满。

注意过程中确切水量并不传达给你，但是通过返回值 $x$ 你足够唯一确定 $a_1 = 0$，$a_2 = 1$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (8 points)：$n = 2$。
- Subtask #2 (17 points)：$n \le 10$。
- Subtask #3 (15 points)：$n \le 100$。
- Subtask #4 (15 points)：$a_i \le 1$。
- Subtask #5 (25 points)：$n \le 500$。
- Subtask #6 (20 points)：无特殊限制。

对于所有的数据，保证 $2 \le n \le 1000$，$0 \le a_i \le i$。

## 样例 #1

### 输入

```
2

0

1

0
```

### 输出

```

? 1 1

? 2 1

? 1 2

! 0 1```

# 题解

## 作者：OMG_wc (赞：15)



这题还是非常难想的，暴力的思路只能解决 Subtask 1和4。

总觉得情况很多复杂无比，对于多余的水一直很纠结该怎么放，有一个无穷大的容器可以接就好了。

~~但是想不出来并不影响我写题解~~



为了简化问题，先假设有一个无穷大的桶可以接水，也就是允许清空任意桶。为什么会想到清空呢？因为清空后的桶就沦落为工具人（桶）了。

首先 $a_1$ 是直接能测出来的~~（地球人都知道吧）~~，测完后把 $a_1$ 清空，这样 $a_2$ 也能测出来了：

执行`？ 2 1  `，如果第一个桶没满，说明 $a_2=0$，测完了；如果第一个桶满了，说明 $a_2\ge 1$，这时候你需要把水倒回去，所以再执行`? 1 2`，这个返回值可以忽略，最后执行`? 2 2` 就能知道 $a_2$ 是 $1$ 还是 $2$ 了。

这样测出 $a_2$ 后，也把 $a_2$ 清空，用上面方法能测出 $a_3$：分别执行`? 3 1`、`? 3 2`、`? 3 3`（除了最后一次，每次测完还需倒回去）。

这样一算的话，测到 $a_n$，不算清空操作，需要 $1+3+5+...+ 2n-1 $次，显然超过限制了。

其实没必要从小到大一个个枚举，换成二分就行了，这样算起来是不超过 $\sum\limits_{i=1}^n2 \lceil\log_2 (i+1)\rceil$ 次。



现在的问题是，不存在一个无穷大的容器可以清空，这样只能把水往后倒了。

还是先从最最最简化的问题开始考虑：

> 假设每次清空都倒到第 $n$ 个桶，并且前 $n-1$ 个桶清空完毕后，第 $n$ 个桶还是不满的。

这样，我们最后用二分测出最后一个桶的水量 ，其实是多了 $\sum\limits_{i=1}^{n-1} a_i$ 这么多的，把这部分减掉就是真实的 $a_n$。

如果情况稍稍复杂一点：

> 清空第 $k$ 个桶的时候，第 $n$ 个桶突然满了

这时候，第 $k$ 个桶可能没倒完，可以用二分测出还剩下 $t$ 个水没清空，这样实际倒进去的是 $a_k-t$ 这么多水，所以可以得到 $a_n=n+t-\sum\limits_{i=1}^{k} a_i$。

然后剩余的 $t$ 个水再倒进 $n-1$ 这个桶里（若 $k=n-1$ 就不用清空了），如果满了可以同样处理：

设一个变量 $pos$ 表示当前清空是往这个桶倒，若 $k=pos$ 就不用清空了。



现在思路就清晰了，在循环计算第 $k$ 个桶的过程中，不仅把 $[1,k]$ 的水量算出来了，还算了一个后缀 $[pos+1,n]$的水量，当两者相遇时就结束循环。而每一次二分，就能得到一个桶的结果（前面的或者后面的），二分总的询问次数可以算出来最多有 $17974$ 次，加上 $999$ 次清空，总和在 $20000$ 次限制范围内。

参考代码如下：

```c++
int ans[N];
int pour(int x, int y) {
    int w;
    printf("? %d %d\n", x, y);
    fflush(stdout);
    scanf("%d", &w);
    return w;
}
int cal(int i) {
    int l = 1, r = i + 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (pour(i, mid) == 0)
            r = mid;
        else
            l = mid + 1;
        pour(mid, i);
    }
    return l - 1;
}
int main() {
    int n;
    scanf("%d", &n);
    int pos = n;
    for (int i = 1; i <= pos; i++) {
        int now = cal(i);
        ans[i] += now;
        while (i != pos) {
            if (pour(i, pos) == 0) {
                ans[pos] -= now;
                break;
            }
            int tmp = now;
            now = cal(i);
            ans[pos] += pos - (tmp - now);
            pos--;
        }
    }
    printf("!");
    for (int i = 1; i <= n; i++) printf(" %d", ans[i]);
    puts("");
    return 0;
}
```



---

## 作者：littleKtian (赞：15)

有生之年第一次在比赛中做出交互，泪目。（

------------

前置知识：[P1733](https://www.luogu.com.cn/problem/P1733)([P1947](https://www.luogu.com.cn/problem/P1947))。

------------

显然第一个水壶的水量可以直接用一次询问得出。

考虑如何求出第 $i(i>1)$ 个水壶的水量。

发现如果前 $i-1$ 个水壶都是空的，那么我们可以用上面题目的方法直接二分得出水量。于是我们可以在 $2\log n$ 次倒水内求出第 $i$ 个水壶的水量，同时保证所有水壶水量不变。

那么关键就变成怎么保证前 $i$ 个水壶为空。

由于~~出题人认为我们要节约用水~~水不能直接倒掉，所以我们考虑将水从最后一个水壶开始倒水，同时记录每个水壶因为倒水而增加的水量。

显然如果接水的水壶没有倒满，那么增加的水量就是倒水前第 $i$ 个水壶的水量。

如果接水的水壶接满，我们考虑再次对 $i$ 二分求出剩余水量。显然接水的水壶会增加第 $i$ 个水壶倒水前后的水量差。

因为接水的水壶容积是我们已知的，所以我们可以通过容积减去因为倒水增加的水量得出原来的水量。

发现我们每次执行二分都能使我们能够确定出一个水壶的水量，所以倒水次数大致就是 $2n\log n=20000$ 的，实际上因为 $\log n$基本上取不到，即便我们进行了除二分以外的倒水操作，次数依然不会大于 $20000$，可以通过。

---

## 作者：peppaking8 (赞：6)

很显然，在操作过后，这些水缸里的水量会发生变化。如果你对一个还未确定水量且暂时不用确定的水缸进行操作，那么之后就再也推不出来正确答案了。所以自然就想到**一个一个推理每个水缸初始存水量**。也就是说，依次确定 $a_1,a_2,...,a_n$。

又注意到进行操作过后，每个水缸的水量无法直接确定，而整体的水量是不会变化的，所以转而依次处理
$$S_x=\sum\limits_{i=1}^x a_i$$
那么最终的 $a_x=S_x-S_{x-1}$。

如何得到 $S_x$ 的值呢？设我们已经处理好了 $S_1,...,S_{x-1}$ 的值，并且现在的水只存储在 $1$ 至 $y$ 的水缸中，其中 $1$ 至 $y-1$ 的水缸是满的，$y$ 可满可不满。处理 $S_x$ 时，将 $a_x$ 中的水依次倒入 $y,y+1,...$，直到不满为止，设当前位置移到 $z$。这样仍然满足存储的要求。

这时就要处理 $z$ 里的水量了。考虑**二分查找**，每次把 $a_{z'}(z'<z)$ 里的 $z'$ 个水量倒入 $a_z$ 中，如果满了，那么 $a_z$ 中的水量大于等于 $z-z'$。这样最多操作 $O(\log z)$ 次就可以得到答案。这样我们就成功维护了 $S_x$ 的值。

不断进行下去，就得到了所求的答案。

```cpp
#include<bits/stdc++.h>
#define Refresh fflush(stdout)
using namespace std;
const int N=1005;
int n;
int sum[N],nowsum,k,lastsum;
//nowsum指填满水的水缸里水量总和
//k表示当前需要填的水缸
//lastsum指a[k]里水量
//这时，总水量sum=nowsum+lastsum
int ans;
int calc(int x){//前x个水缸全部填满时的水量为calc(x)
	return x*(x+1)/2;
}
int main(){
	cin>>n;k=0;nowsum=0;
	cout<<"? 1 1\n";//先问第一个水缸，处理出初始的nowsum,k
	Refresh;cin>>ans;
	lastsum=0;
	if(ans==1) sum[1]=1,nowsum=1,k=2;
	else sum[1]=0,nowsum=0,k=1;
	if(n==1){
		cout<<"! "<<sum[1]<<endl;
		return 0;
	}
	for(int i=2;i<=n;i++){
		while(k<i){//不断更新当前需要填的水缸，直到没有填满为止
			cout<<"? "<<i<<" "<<k<<endl;
			Refresh;cin>>ans;
			if(ans==1) nowsum=calc(k),k++,lastsum=0;
			else{
				break;
			}
		}
		if(k==i+1){//如果之前的i个水缸全部填满，不用二分直接处理
			sum[i]=nowsum;
			continue;
		}
		cout<<"? "<<k<<" "<<k<<endl;//特判：a[k]是否填满
		Refresh;cin>>ans;
		if(ans==1){
			k++;
			nowsum=calc(k-1);
			sum[i]=nowsum;
			continue;
		}
		int L=1,R=k-1,pos=0;//二分出水量
		while(L<=R){
			int mid=(L+R)>>1;
			cout<<"? "<<mid<<" "<<k<<endl;
			Refresh;cin>>ans;
			if(ans==1) pos=mid,R=mid-1;
			else L=mid+1;
			cout<<"? "<<k<<" "<<mid<<endl;
			Refresh;cin>>ans;
		}
		if(!pos) lastsum=0;
		else{
			lastsum=k-pos;
		}
		sum[i]=nowsum+lastsum;
	}
	cout<<"! ";
	for(int i=1;i<=n;i++) printf("%d ",sum[i]-sum[i-1]);
	exit(0);
}
```

---

## 作者：VinstaG173 (赞：2)

好题（

考场上最后一点时间 rush 了个 $23\text{pts}$，回家的地铁上把正解想出来了，然后家里没 Dev 给爷错了 $n$ 回（

基本思路就是已知前 $x-1$ 缸水量，求出 $x$ 的水量。

如果 $1,2,\dots,x$ 都是满的，直接得到 $x$。

否则，我们设 $1$ 到 $k-1$ 都满，$k$ 不满，后面全为空。此时我们从 $x$ 向 $k$ 倒水，倒满了让 $k$ 加 $1$。此时肯定仍为 $1$ 到 $k-1$ 都满，$k$ 不满，后面全为空的情况。

这时我们在 $1$ 到 $k$ 中二分查找，找到能倒到 $k$ 中恰好倒空且使 $k$ 变满的位置 $l$，然后就有 $a_x=\dfrac{k(k+1)}{2}-l-\sum\limits_{i=1}^{x-1}a_i$。注意当 $k$ 为空时是无法倒满的，正确的二分方式会让它返回 $l=k$。

Code:
```cpp
#include<cstdio>
#include<iostream>
#define rg register
#define query(x,y) (cout<<"? "<<x<<' '<<y<<endl,read())
using namespace std;
int n,sum;
int k,a[1003];
inline int read()
{
	int x=0;
	char cc=getchar();
	while(cc<'0'||cc>'9')cc=getchar();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=getchar();
	return x;
}
inline int solve(int x)
{
	while(k!=x&&query(x,k))++k;
	if(k==x&&query(x,x))return x;
	int l=1,r=k,m;
	while(l<r)m=l+r>>1,(query(m,k))?(r=m):(l=m+1),query(k,m);
	return (k*(k+1)>>1)-sum-l;
}
int main()
{
	ios::sync_with_stdio(false);
	n=read();k=1;
	sum=a[1]=query(f,f);
	for(rg int i=2;i<=n;++i)sum+=(a[i]=solve(i));
	cout<<'!';
	for(rg int i=1;i<=n;++i)cout<<' '<<a[i];
	cout<<endl;
	return 0;
}
```

---

## 作者：Gypsophila (赞：2)

**题目描述**：
交互题。有 $n(n\leq1000)$ 个容器，第 $i$ 个容器最开始装着 $a_i$ 单位容量的水，并且该容器上限为 $i$。你可以做一些操作。操作可以描述为 `? i j`，表示把第 $i$ 个容器的水往 $j$ 容器里倒，倒满或者倒空为止。操作完成后，会告诉你 $j$ 容器有没有满。求不超过 $20000$ 次操作还原出 $a_i$。

**解法**：

简单的例子，对于第一个位置 $a_1=0$ 或 $1$，我们只需要询问一次满还是不满即可。

对于 $n=2$，先询问 $2$ 是不是满的。如果不是满的，若 $a_1=0$，我们直接 `? 2 1`，否则 `? 1 2`，这样确定出 $a_2$ 的值。

再考虑一些简单的例子，比如当 $1,2,\cdots,i-1$ 都是满的时候，我们想要知道 $i$ 的值。这时候二分就可以解决。

具体地，比如我们想要知道 $a_i$ 是否 $\ge$ 当前二分出的 $mid$，考虑 $i-mid$ 这个容器，他现在是满的。我们把 $i-mid$ 倒入 $i$。如果此时 $i$ 满了，那么 $a_i\ge mid$，否则 $a_i <mid$。并且，我们此时可以把水重新倒回去，因为目前 $i$ 里的水量 $a_i'$ 是不少于 $i-mid$ 的，倒回去之后可以保证 $i-mid$ 是满的。

这样就可以想到正解的思路了：从前到后依次确定答案，我们每次尽量把一个前缀填满。比如目前我们要确定 $a_i$，前 $i-1$ 个数把 $1,2,\cdots,pos$ 都填满了。显然 $pos \leq i-1$。那么我们把 $i$ 往 $pos+1$ 里倒，如果倒满了就把 $pos$ 往后移动。直到 $i$ 里的水全被倒没了。

假设我们得到一个新的 $pos'$。我们用之前那种二分的方式得到 $pos'+1$ 位置上有多少水设为 $x$。我们也知道之前 $pos+1$ 的位置上有多少水设为 $y$。这样 $a_i$ 的数值就等于 $pos+1-y+\sum\limits_{i=pos+2}^{pos'} i+x$。如果 $pos=pos'$，那么 $a_i=x-y$。

再分析这么做的复杂度。操作可以分为两部分：填满前缀和二分。对于填满前缀，最多需要 $2000$ 次左右的操作。而二分乍看需要 $2n \log n $ 次的操作，加上前面的 $2000$ 刚好爆了。其实我们第 $i$ 次是对一个长度 $\leq i$ 的前缀二分，实际上只有 $16000$ 左右的操作次数。于是可以通过此题。

**代码：**
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=1e5;

int n,ans[maxn+5],a[maxn+5];

int main() {
    cin>>n;
    int pos=1;
    // 1~pos-1 都填满了并且 pos 没满
    // 
    for (int i=1;i<=n;i++) {
        int now=0;
        int pr=0;  
        while(pos<=i) {
            cout<<"? "<<i<<' '<<pos<<endl;
            int x;
            cin>>x; 
            if(x==1) {
                now+=pos-a[pos];
                a[pos]=pos;
                pos++; 
            }
            else {
                pr=a[pos]; 
                break ; 
            }
        }
        if (pos>i) {
            ans[i]=i;
        }
        else {
            int l=1,r=pos-1,xx=0; 
            while (l<=r) {
                int mid=(l+r)>>1;
                cout<<"? "<<pos-mid<<' '<<pos<<endl; 
                int x; cin>>x;
                if (x==1) {
                    // x>=mid
                    xx=mid;
                    l=mid+1; 
                }
                else {
                    r=mid-1; 
                }
                cout<<"? "<<pos<<' '<<pos-mid<<endl;
                cin>>x; 
            }
            ans[i]=now+xx-pr; 
            a[pos]=xx; 
        }
    }
    cout<<"! "; 
    for (int i=1;i<=n;i++) {
        cout<<ans[i]<<' '; 
    }
    cout<<endl; 
    return 0; 
}
```

---

## 作者：t162 (赞：1)

这里是一个不太一样的思路。

我们考虑第 $i$ 个缸，装着不明单位的水。容易想到，若所有编号小于 $i$，且是 $2$ 的幂次方的水缸都是满的，那么我们可以求出该缸空出来的部分容量 $b_i$，从而求出该缸装的水量。

我们可以通过从高到低枚举 $i$ 的第 $j$ 位（$2^j\neq i$），并将编号为 $2^j$ 的水缸中的水倒入 $i$ 缸中，若倒满了就倒回去*（如果恰好倒满了呢？没关系，这种情况同样倒回去，那么后面的所有缸中的水一定能倒入 $i$ 缸中，并且最后 $i$ 缸会空出恰好 $1$ 单位，如果判断出 $i$ 缸没满，把 $b_i$ 加上 $1$ 即可。这样判断同样适用于 $i$ 恰好是 $2$ 的幂次方且刚好是空的情况）*，否则就将 $b_i$ 加上 $2^j$，此时 $i-b_i$ 即为最初 $i$ 缸内的水量。当然，为了方便下一个缸求解，水要还回去。这样，需要 $2\times\left\lfloor\log_2(i-1)\right\rfloor+3\quad(i\gt 1)$（$i=1$ 时，显然只要 $1$ 次）次操作。

但是，如何保证所有编号小于 $i$，且是 $2$ 的幂次方的水缸都是满的呢？

答案是，不需要保证。

我们可以找到第一个编号小于 $i$，且是 $2$ 的幂次方的缸，它不是满的。
从 $i$ 缸向这个缸倒水，并求出倒了多少水。如果倒满了就找下一个，否则求出这个缸此时的水量（这显然是可以用上面的方法求的）。每次倒出的水量之和（即每缸的水量变化量）就是答案。

如果找不到这样的缸了呢？那此时 $i$ 中剩余的水量显然可以用上面的方法求得。

估计一下，最多需要 $\left(\sum_{1\lt i\leq n}2\times\left\lfloor\log_2(i-1)\right\rfloor+3\right)+\left\lfloor\log_2(n-1)\right\rfloor+1$ 次操作，写个程序跑一下 $n=1000$ 时的情况，得到的答案是 $18963$（而且有一个数据我刚好就用了 $18963$ 次操作？？？）。

代码：

```cpp
// e3c8f1a924 2021年08月01日 星期日 19时31分25秒
#include<cstdarg>
#include<cstdio>
int _printf(char *format, ...) {
	va_list args; int k;
	va_start(args, format), printf("\033[34m"), k = vprintf(format, args), printf("\033[0m"), va_end(args);
	return k;
}
int _puts(char *str) { int k; return printf("\033[34m"), k = puts(str), printf("\033[0m"), k; }
int _putchar(int c) { int k; return printf("\033[34m"), k = putchar(c), printf("\033[0m"), k; }
#ifdef LOCAL
	#define printf _printf
	#define puts _puts
	#define putchar _putchar
#endif
typedef long long ll;
typedef long double ld;
typedef unsigned ui;
typedef unsigned long ul;
typedef unsigned long long ull;

int cur[1001], ans[1001], p = 1, n, t;
int pour(int u, int v) {
	printf("? %d %d\n", u, v), fflush(stdout);
	int ret; return scanf("%d", &ret), ret;
}
int _get(int u) {
	int i = 1, ret = 0;
	while (i < u) i <<= 1; i >>= 1;
	while (i) {
		if (!pour(i, u)) ret |= i, cur[i] = 0;
		else pour(u, i); i >>= 1;
	}
	if (!pour(u, u)) ret++; i = 1;
	while (i < u) { if (!cur[i]) pour(u, i), cur[i] = i; i <<= 1; }
	return cur[u] = u - ret;
}
int get(int u) {
	int d = 0;
	while (p < u) {
		if (cur[p] != p) {
			if (pour(u, p)) d += p - cur[p], cur[p] = p;
			else return t = cur[p], d + _get(p) - t;
		}
		p <<= 1;
	}
	return d + _get(u);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) ans[i] = get(i);
	putchar('!'); for (int i = 1; i <= n; i++) printf(" %d", ans[i]);
	puts(""); fflush(stdout);
	return 0;
}
```

---

## 作者：Phartial (赞：1)

# P7109 滴水不漏 题解

考虑原题的一个弱化版：如果额外给定一个无限容量的桶该怎么做（即，允许清空一个桶）？

那么我们可以有这样的做法：对桶 $i$，我们使桶 $1\sim i-1$ 为空，然后使用二分的方式得出桶 $i$ 中的水量（每次校验桶 $i$ 的水量是否 $\ge m$，校验方式为将桶 $i$ 中的水倒进桶 $m$，然后询问桶 $m$ 有没有满，注意还需要倒回来），最后清空桶 $i$ 以处理之后的桶即可。总询问量 $\le 2n\log_2 n$。

考虑怎么在原题中清空一个桶。显然我们只能将桶 $i$ 的水倒进后面的桶，于是不妨维护一个指针 $j$ 表示最大的未满的桶 $j$，处理完 $i$ 后将水倒进 $j$。如果桶 $j$ 还没满，那这很好，我们可以继续处理桶 $i+1$。如果桶 $j$ 满了，这就说明桶 $i$ 中可能还有剩余的部分。

我们额外维护一个数组 $b_j$ 表示桶 $j$ 在用于清空其他桶时倒入了多少水，则如果桶 $j$ 没满，我们可以直接将桶 $i$ 的水量贡献到 $b_j$ 中；如果桶 $j$ 满了，我们再二分一次求出桶 $i$ 的剩余水量，将倒入桶 $j$ 的部分贡献到 $b_j$ 中，不难发现此时有 $a_j=j-b_j$，令 $j\gets j-1$ 继续处理桶 $i$ 中剩余的部分即可。

由于一次二分必定会求出某个桶（$i$ 或 $j$）的剩余水量，所以总询问量仍然为 $\mathcal{O}(n\log n)$ 量级。

```cpp
#include <iostream>

using namespace std;

const int kN = 1001;

int n, a[kN], b[kN];
bool v[kN];

int G(int i) {
  int v, l = 0, r = i;
  while (l < r) {
    int m = l + r + 1 >> 1;
    cout << "? " << i << ' ' << m << endl;
    cin >> v;
    if (v) {
      l = m;
    } else {
      r = m - 1;
    }
    cout << "? " << m << ' ' << i << endl;
    cin >> v;
  }
  return l;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1, j = n; i <= n; ++i) {
    if (!v[i]) {
      int x = G(i);
      a[i] = x - b[i], v[i] = 1;
      for (; x && !v[j];) {
        cout << "? " << i << ' ' << j << endl;
        int f;
        cin >> f;
        if (f) {
          int y = G(i);
          b[j] += x - y, x = y;
          a[j] = j - b[j], v[j] = 1;
          --j;
        } else {
          b[j] += x, x = 0;
        }
      }
    }
  }
  cout << "! ";
  for (int i = 1; i <= n; ++i) {
    cout << a[i] << ' ';
  }
  cout << endl;
  return 0;
}
```


---

## 作者：NKL丶 (赞：0)

## Description

交互题。

有 $n$ 个水缸，第 $i$ 个水缸容量为 $i$，初始有 $a_i$ 单位的水且 $a_i$ 未知。

现进行至多 $2 \times 10^4$ 次操作，每次操作将水缸 $x$ 内的水倒入水缸 $y$，返回最终水缸 $y$ 是否是满的，目标是确定序列 $a_i$。（$1 \le n \le  10^3$）

## Solution

假如我们有一个容量无穷大的水缸，使得我们考虑到第 $i$ 个水缸时前 $i-1$ 个水缸均为空，那么这时候显然可以二分确定水缸内水的含量。

但是不存在这样一个水缸，那么我们考虑用后续的缸存储多余的水。具体的，我们确定一个目标缸，每次确定完水缸 $i$ 后将水倒入这个缸内，假如目标缸满了就通过二分确定水缸 $i$ 中剩余水量，并将目标缸设为前一个，这样就能记录目标缸倒入了多少水，从而得出目标缸的初始水量。

由于确定水缸 $i$ 的 $a_i$ 需要 $2 \cdot \log i$ 次操作（倒入询问缸，倒回来），总的次数约为 $n+2n\log n$，但是当 $i$ 较小时显然跑不满，因此可以通过此题。

## [Code](https://www.luogu.com.cn/paste/0wm3m6gw)

---


# 「Wdoi-3」夜雀 cooking

## 题目背景

**本题为交互题。**

作为幻想乡的大厨，米斯蒂娅当然能用准备的食材制作出各色各样的饭菜。晚上，就是夜雀餐厅营业的时间，凭着这些料理，餐厅总是生意兴隆——甚至一些「特殊顾客」也会前来！

特殊顾客就是一些幻想乡里大家再熟悉不过的角色啦，顾名思义，她们会提出特殊要求，不过如果满足了她们的要求，她们也会好好地奖励小夜雀。

不幸的是，紫决定做一个恶作剧，她悄悄使用能力清除了米斯蒂娅的部分记忆，现在她分不清哪些顾客是特殊顾客，哪些顾客是普通顾客了！看着米斯蒂娅快要哭了，于心不忍的紫决定和米斯蒂娅做一个数学游戏，她将特殊顾客的编号隐藏在了数字之中。米斯蒂娅对数学一窍不通，于是她只能向你求助了......

## 题目描述

紫给出了一个长度为 $n$ 的数列，其第 $i$ 项就对应了编号为 $i$ 的顾客。她将所有普通顾客对应的位置染上蓝色，把特殊顾客对应的位置染上紫色。紫告诉了米斯蒂娅特殊顾客一共有 $m$ 位。并且，由于特殊顾客非常的特殊，所以紫色位置数量很少，而且**基本均匀随机**。

接下来，她给数列的每一项赋上了值。第 $i$ 项的值 $a_i$ 可以用如下的式子推出：（$s$ 和 $k$ 紫都会给出）
  $$a_i=\begin{cases} s & i=1\cr a_{i-1}+k & i>1\end{cases}$$

米斯蒂娅可以向紫提出形如 `l r` 的问题，然后紫就会迅速算出区间 $[l,r]$ 内所有被染成蓝色位置的 $a_i$ 的和。当然啦，你需要输出 `l r` 来告诉米斯蒂娅她该如何提问，如果你成功找出了所有特殊顾客的编号（即所有紫色点的位置），那么你需要输出 `-1 p1 p2 ... pm` 来告诉米斯蒂娅所有特殊顾客的编号，注意要保证 $p_i\le p_{i+1}(1\le i<m)$。

**注意：在进行这两种操作后，需要刷新缓存区，下面是一些常见语言的刷新缓存区方式：**

- C++：`fflush(stdout)` 或 `cout.flush()`。
- C: `fflush(stdout)`。
- Java: `System.out.flush()`。
- Python: `stdout.flush()`。
- Pascal: `flush(output)`。
- 其他语言：请参考对应语言的帮助文档。

## 说明/提示

#### 样例解释

神秘顾客的编号为 $\{4,7,10,11\}$ 。这个样例象征性地抽取了 $3$ 个询问，以便选手理解交互的过程。

- 对于第一次询问 $[10,12]$ ，结果为 $13=13$。
- 对于第二次询问 $[2,7]$ ，结果为 $3+4+6+7=20$。
- 对于第三次询问 $[4,8]$ ，结果为 $6+7+9=22$。

---

#### 数据范围及约定

$$\def\arraystretch{1.8}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & m=1 & 5 \cr\hline
2 & - & 95 \cr\hline
\end{array}$$

- 对于所有数据，满足 $1\le T\le 500$，$1 \leq \sum n_i \leq 10^5$，$1 \leq \sum m_i \leq \min\{ n,100\}$，$1\le s,k\le 10^9$。

每一个 Subtask 的得分为当前 Subtask 所有测试点的最低分。

#### 判分方式

令 $q_i$ 为对于第 $i$ 组数据你所用的询问次数，你需要满足 $\sum q_i \leq 200 \times T$ ，并且每组询问的结果都是正确的，你才能获得该测试点的满分。

- 如果询问次数满足 $1000 \times T<\sum q_i \leq 2000 \times T$，可以拿到 $20\%$ 的分数。
- 如果询问次数满足 $600 \times T<\sum q_i \leq 1000 \times T$，可以拿到 $40\%$ 的分数。  
- 如果询问次数满足 $400 \times T<\sum q_i \leq 600 \times T$，可以拿到 $50\%$ 的分数。
- 如果询问次数满足 $300 \times T<\sum q_i \leq 400 \times T$，可以拿到 $60\%$ 的分数。
- 如果询问次数满足 $200 \times T<\sum q_i \leq 300 \times T$，可以拿到 $80\%$ 的分数。

#### 说明

选择 $m$ 个点染为紫色的生成方式是对一个 $1 \sim n$ 的排列调用 `random_shuffle`，然后取前 $m$ 项的数值作为特殊顾客的编号。一个可被参考的代码如下：

```cpp
namespace Gen{
	typedef unsigned int       u32;
	typedef unsigned long long u64;
	u32 MT[624],idx;
	void iit(u32 seed){
    	MT[0]=seed; idx=0; for(u32 i = 1;i < 624;++ i)
    	MT[i]=(0x6c078965U * (MT[i - 1] ^ ((MT[i - 1]) >> 30)) + i);
	}
	void gen(){
		u32 x; for(u32 i = 0;i < 624; ++ i){
			x = (MT[i] & 0x80000000U) +
				(MT[(i + 1) % 624] & 0x7fffffffU );
			MT[i] = MT[(i + 397) % 624] ^ (x >> 1);
			if(x & 1) MT[i] ^= 0x9908b0dfU;
		}
	}
	u32  clc(){
		if(!idx) gen(); u32 x = MT[idx];
		x ^= x >> 11, x ^= (x << 7) & 0x9d2c5680U;
		x ^= (x << 15) & 0xefc60000U,x ^= x >> 18;
		idx = (idx + 1) % 624; return x;
	}
	u32  clc(u32 n){	//均匀随机地返回 [0,n) 内的整数
		return 1ull * n * clc() >> 32;
	}
	void sfl(int n, int *A) {
		for(int i = n;i >= 1; --i) swap(A[clc(i) + 1], A[i]);
	}
	void gen(u32 seed,int n, int *A) {
		iit(seed); for(int i = 1;i <= n; ++i) A[i] = i; sfl(n, A);
	}
}
```

**注**：该代码片段会使用符合标准的梅森旋转算法生成随机数。其生成随机数的周期为 $2^{19937}-1$ ，生成的随机数是均匀随机的。因此你大可不必担心我们在里面做了任何手脚。

调用 `gen(seed,n,A)` 可以生成一个长度为 $n$ 的**基本均匀随机**序列，我们将会取其前 $m$ 项作为特殊顾客的编号。例如，对于样例，我们调用了 `gen(9961U,12,A)` ，并选取了 $A$ 的前 $4$ 项 $\{4,7,10,11\}$ 作为神秘顾客的编号。

## 样例 #1

### 输入

```
1
12 4 2 1

13

20

22```

### 输出

```


10 12

2 7

4 8

-1 4 7 10 11```

# 题解

## 作者：幽云蓝 (赞：5)

这里是八云蓝的官方题解~

$\textbf{Subtask1}$

直接二分即可，蓝不再赘述。

$\textbf{Subtask2}$

$20\%$ 分数的解法：对于每个客人都做一次二分即可。

$40\%$ 分数的解法：首先考虑“随机数据”带来的性质。对于一个长度为 $n$ 的序列，若从其中均匀的选出 $x$ 个位置作为紫色位置，那么每 $\frac{n}{m}$ 个位置中期望恰好有一个紫色位置。考虑将序列分成 $m$ 个大小为 $\frac{n}{m}$ 的块，期望下，每个块都恰好有一个紫色位置。注意到数据是基本均匀随机，所以可能有一定数量的块不满足该性质，直接用 $20pts$ 的解法暴力做即可。判断一个块内是否有紫色位置是很简单的，所以问题转化为判断块内是否存在切仅存在一个紫色位置，以及这个位置是什么。如果判断出了是否仅存在一个紫色位置的话，由于给出的等差数列公差大于等于 $1$，所以每个数互不相同，那么判断紫色位置是什么也就很简单啦。
- 如何判断“块内是否仅存在一个紫色位置”：对于一个块，块内数显然有从左往右单调递增，那么设这个块为区间 $[l,r]$，由于每个数都是正数，如果有 $a_l+a_{l+1}>a_r$，那么对于任意一个选出 $>1$ 个紫色点的情况，其紫色点的权值（也就是 $a$ 值）和一定大于任意一种选出恰好 $1$ 个紫色点的情况。所以显然的，对于满足 $a_l+a_{l+1}>a_r$ 的块，可以判断“块内是否仅存在一个紫色位置”。我们之后称满足这一条件的块或区间为有趣块或者有趣区间。
- 有趣块的数量：是 $m-1$。考虑下述的证明方法：对于序列 $a$ 有 $a_i=(i-1)k+s$。第一块不一定是有趣块，直接考虑第二块是否为有趣块。记 $\frac{n}{m}=L$，那么第二块的区间即为 $[L+1,2L]$。带入上面的不等式可得 $a_{L+1}+a_{L+2}>a_{2L}$，带入 $a_i=(i-1)k+s$ 得 $(2L+3)k+2s>2Lk+s$，由于 $k,s\geq1$，所以第二个块一定是有趣块。易证第二个块是有趣块，之后的块就一定是有趣块。于是有趣块数即为 $m-1$。

综上，我们可以达到一个比较优的询问次数。这足以让我们拿到 sub2 的 $40%$ 的分数。

$100pts$ 的做法：虽然上述做法看起来很优，但是多次调用 gen 可以发现，数据仅是比较均匀，它并没有我们想象中一样均匀，在很多时候，一个块内的数数量会大于 $1$。好消息是，一个块内的数的期望很小，也就是说，一个块内不会有很多数。并且，这些块内的数的分布仍是比较均匀的。第一个块不是有趣块，于是这个块我们暴力二分。对于其他的块，蓝有更为优雅的解决方案。

- 如何优雅的处理有趣块（本部分轻微卡常）：考虑一个类似于线段树二分的做法，每次询问一个区间 $[l,r]$，如果这个区间内有紫色位置的话就取 $mid$，继续询问区间 $[l,mid]$，否则令上一次询问的区间为 $[l',r']$，询问 $[r+1,r']$。注意到在这样二分的时候，如果某一块内注意到，如果对于一个块 $[l,r]$，你询问了 $[l,x]$，那么你就可以通过相减的方式得到 $[x+1,r]$ 内的紫色位置的权值和。并且有一个简单优化——如果当前询问的区间有且仅有一个紫色位置，那么可以直接求出这个位置（易证一个有趣块的子区间是有趣区间）。

综上，我们可以在 $200T$ 的限制下稳定的通过此题。

update：赛时有人不分块就过题了，而且比起分块优化显著，所以分块其实并没有必要的说。但是对于第一块的特判是必须的（赛时没有卡住，向大家谢罪）。

---

## 作者：Cocoly1990 (赞：1)

在 Wd 群问了个题被蓝推荐来做这题。

考虑到数据随机生成，期望的紫色出现频率是每 $\frac{n}{m}$ 个数一个，以此分块，分 $m$ 块，记第 $i$ 块的左右端点为 $\left[l_i,r_i\right]$，$s_i=\sum\limits_{j=l_i}^{r_i} a_j,c_i=\sum\limits_{j=l_i}^{r_i} \left[i \in p\right]$,其中 $p$ 表示紫色数字集合。

我们考虑分情况处理。

1. $c_i=0$：显然可以通过询问一次 $\left[l_i,r_i\right]$ 得到是否有 $c_i=0$.

2. $c_i = 1$：我们发现对于 $\forall i,l_i\geq \frac{r_i}{2}$，因此总有 $s_i-a_{l_i}-a_{l_i + 1} > s_i-{a_r}$，前者的含义是区间内有两个紫色的最小询问结果，后者是有一个紫色的最大询问结果，因此可以快速判断区间内紫色个数是否为 $1$，进而我们可以通过这个方式求得具体的紫色位置。

3. $c_i>1$ 暴力递归处理区间。

细节：对于第一块特判，可能需要线段树上二分，代码晚点补评论区。

---

## 作者：xie_lzh (赞：0)

#### 题意简述

给你一个等差数列，标记了其中其中一些点。你可以询问一个区间中未被标记的点的和，要求你求出被标记的点在哪里。

这个题容易想到二分地去做，但是发现这个是个暴力分。考虑发现一些性质。

我们首先可以发现等差数列的性质，我们注意到当一个区间仅有一个数被标记时，在它不能被两个区间内其他数构成的情况下，我们可以直接扫一边整个区间得到它。这样我们在二分的时候就不用递归到最底层了，可以大大节约我们的询问次数。

注意到 $m$ 比较小，且均匀随机分布，这说明一个包含小于等于一个被标记位置的区间可以比较大。

所以我们直接考虑线段树上二分。如果区间和就是等差数列区间和说明区间内没有被标记位置，可以直接返回。如果区间和与等差数列和之差比区间内最小的两个数的和小，这说明区间内存在唯一的标记，扫一遍找到即可。否则直接递归处理。

细节上，在线段树上递归时可以只用询问左半边，右半边可以由当前区间和求得。

分块可能更优？但是不分块直接分讨也能过。

不知道啥复杂度，但是不超过 $\Theta(n\log n)$，瓶颈在交互的查询上。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
// #define int long long
int n,m,s,k,T,L;
ll sum[N];
int ans[N],cnt;
ll ask(int l,int r)
{
	cout<<l<<' '<<r<<endl;
	ll ns; cin>>ns; if(ns==-1) exit(0);
	return ns;
}
void solve(int l,int r,ll ns)
{
	if(sum[r]-sum[l-1]==ns)  return ;
	if(l==r) return ans[++cnt]=l,void();
	if(sum[r]-sum[l-1]-ns<sum[l+1]-sum[l-1])
	{
		for(int i=l;i<=r;i++)
			if(1ll*(i-1)*k+s+ns==sum[r]-sum[l-1])
				ans[++cnt]=i;
		return ;
	}
	int mid=(l+r)>>1;
	ll ss=ask(l,mid);
	solve(l,mid,ss); solve(mid+1,r,ns-ss);
}
void solve()
{
	cin>>n>>m>>s>>k; cnt=0;
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+1ll*(i-1)*k+s;
	L=(n+m-1)/m;
	solve(1,n,ask(1,n));	
	cout<<"-1 "; for(int i=1;i<=cnt;i++) cout<<ans[i]<<' '; cout<<endl;
}
signed main()
{
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	cin>>T; while(T--) solve();
}
```

---


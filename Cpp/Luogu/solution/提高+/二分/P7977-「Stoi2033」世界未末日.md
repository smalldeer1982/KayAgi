# 「Stoi2033」世界未末日

## 题目背景

注意：**利用提交反馈以套取数据的行为属于作弊**。

> 就算是世界要崩溃  
> 亲爱的我也绝不会落泪  
> 不放弃爱过的那种感觉  
> 珍惜着有你记忆的一切  
> 就算是世界要倾斜  
> 亲爱的我也绝不说离别  
> 尽管末日威胁再强烈  
> 有爱就不累  
> ——《世界未末日》

## 题目描述

Vinsta 和 Stella 有 $n$ 堆石子，第 $i$ 堆有 $s_i$ 个。

她们约定从 Vinsta 开始轮流操作，每次操作可以选择不少于 $1$ 堆且不超过 $k$ 堆的石子。对于第 $i$ 堆石子，可以选取两个实数 $a,b$ 满足：

- $a \times b=s_i$
- $a+b=c,c\in[1,s_i]\cap\Z$

并丢掉第 $i$ 堆的 $c$ 个石子，即 $s_i\leftarrow s_i-c$。不能操作者败，她们想要知道 Vinsta 是否有必胜策略。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

| Subtask | $1\le n \le$ | $1\le S \le$ | 分值 |
| :-: | :-: | :-: | :-: |
| $1$ | $300$ | $300$ | $7$ |
| $2$ | $300$ | $3 \times 10^7$ | $8$ |
| $3$ | $300$ | $3\times 10^{10}$ | $16$ |
| $4$ | $3\times 10^6$ | $3$ | $3$ |
| $5$ | $3\times 10^6$ | $3 \times 10^3$ | $3$ |
| $6$ | $3\times 10^6$ | $3 \times 10^7$ | $16$ |
| $7$ | $3\times 10^6$ | $3\times 10^{10}$ | $47$ |

对于 $100\%$ 的数据， $1 \le k \le n \le 3 \times 10^6$，$1 \le S \le 3 \times 10^{10}$。

## 样例 #1

### 输入

```
7 1 13
2 3 4 5 7 10 11
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
8 1 13
2 3 4 5 7 10 11 13
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
7 2 100
19 26 8 17 11 45 14
```

### 输出

```
YES
```

# 题解

## 作者：VinstaG173 (赞：20)

初二时搞的题，当时玩了好久，换了一堆版本（

前置知识：k-SG。

### Subtasks

| Subtask No. | $n \le$ | $S \le$ | 分值 |
| :-: | :-: | :-: | :-: |
| $1$ | $300$ | $300$ | $7$ |
| $2$ | $300$ | $3 \times 10^7$ | $8$ |
| $3$ | $300$ | $3 \times 10^{10}$ | $16$ |
| $4$ | $3 \times 10^6$ | $3$ | $3$ |
| $5$ | $3 \times 10^6$ | $3 \times 10^3$ | $3$ |
| $6$ | $3 \times 10^6$ | $3 \times 10^7$ | $16$ |
| $7$ | $3 \times 10^6$ | $3 \times 10^{10}$ | $47$ |

### Solutions

我不知道有没有其他的做法……反正我会的都在这了，还有一个有点毒瘤于是放了加强版……

为了简洁，我在部分分对应代码中均省去具体处理 k-SG 的部分，在正解对应代码（std）里会有。处理 k-SG 可以在 $O(n\log{S})$ 时间内完成，不算入具体部分分的时间复杂度分析中。

#### Sol. $\rm{I}$

Subtask $\# 4$，$3$ pts

发现 $\le 3$ 不可操作。直接输出 `NO`。

Code:
```cpp
#include<cstdio>
int main()
{
	puts("NO");
	return 0;
}
```

#### Sol. $\rm{II}$

Subtask $\# 4,1$，$10$ pts

直接依题意暴力计算 $\operatorname{SG}$ 函数，时间 $O(nS^2)$。

Code:
```cpp
#include<cstdio>
#define rg register
int n,k,S,s;
int vs[307];
int SG[307];
int sg[3000007];
int main()
{
	scanf(" %d %d %d",&n,&k,&S);
	for(rg int i=0;i<n;++i)
	{
		scanf(" %d",&s);
		SG[0]=0;
		for(rg int i=1;i<=s;++i)
		{
			for(rg int j=i;j*j/4>=i;--j)vs[SG[i-j]]=1;
			while(vs[SG[i]])++SG[i];
			for(rg int j=i;j*j/4>=i;--j)vs[SG[i-j]]=0;
		}
		sg[i]=SG[s];
	}
}
```

#### Sol. $\rm{III}$

Subtask $\# 4,1,5$，$13$ pts

把询问内计算换成递推，时间 $O(S^2+n)$。

Code:
```cpp
#include<cstdio>
#define rg register
int n,k,S,s;
int vs[3007];
int SG[3007];
int sg[3000007];
int main()
{
	scanf(" %d %d %d",&n,&k,&S);
	SG[0]=0;
	for(rg int i=1;i<=S;++i)
	{
		for(rg int j=i;j*j/4>=i;--j)vs[SG[i-j]]=1;
		while(vs[SG[i]])++SG[i];
		for(rg int j=i;j*j/4>=i;--j)vs[SG[i-j]]=0;
	}
	for(rg int i=0;i<n;++i)
	{
		scanf(" %d",&s);
		sg[i]=SG[s];
	}
}
```

#### Sol. $\rm{IV}$

Subtask $\# 4,1,5,2,3$，$37$ pts

发现一个性质：$x$ 的后继状态集合为 $[0,x-2\sqrt{x}]\cap\mathbb{Z}$。

由于 $x-2\sqrt{x}=(\sqrt{x}-1)^2-1$ 递增，因此后继状态集合不减，所以 $\operatorname{SG}$ 函数值不减。因此 $\operatorname{SG}(x)=\operatorname{SG}(\lfloor x-2\sqrt{x} \rfloor)+1$。直接计算，时间 $O(n\sqrt{S})$。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
ll S,s;
int n,k;
int sg[3000007];
int main()
{
	scanf(" %d %d %lld",&n,&k,&S);
	for(rg int i=0;i<n;++i)
	{
		scanf(" %lld",&s);
		while(s>3)s=(ll)(s-sqrt(s)*2),++sg[i];
	}
}
```

#### Sol. $\rm{V}$

Subtask $\# 4,1,5,2,6$，$37$ pts

把询问内计算换成递推，时间 $O(S+n)$。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
int n,k,S,s;
int sg[3000007];
int SG[30000007];
int main()
{
	scanf(" %d %d %d",&n,&k,&S);
	for(rg int i=4;i<=S;++i)SG[i]=SG[int(i-sqrt(i)*2)]+1;
	for(rg int i=0;i<n;++i)
	{
		scanf(" %d",&s);
		sg[i]=SG[s];
	}
}
```

#### Sol. $\rm{VI}$

Subtask $\# 4,1,5,2,6,3$，$53$ pts

结合 Sol. $\rm{IV \& V}$ 即可。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
ll S,s;
int n,k;
int sg[3000007];
int SG[30000007];
int main()
{
	scanf(" %d %d %lld",&n,&k,&S);
	if(n<=300)
	{
		for(rg int i=0;i<n;++i)
		{
			scanf(" %lld",&s);
			while(s>3)s=(ll)(s-sqrt(s)*2),++sg[i];
		}
	}
	else
	{
		for(rg int i=4;i<=S;++i)SG[i]=SG[int(i-sqrt(i)*2)]+1;
		for(rg int i=0;i<n;++i)
		{
			scanf(" %d",&s);
			sg[i]=SG[s];
		}
	}
}
```

#### Sol. $\rm{VII}$

讲正解。~~感觉前面的分应该会 k-SG 都能拿到吧，算是送了~~

首先我们要在 $\rm{IV}$ 里的结论基础上继续找性质。

想到 $\operatorname{SG}$ 函数值不减，所以尝试对 $v$ 找满足 $\operatorname{SG}(x)=v$ 的最小 $x$。

我们发现设 $\operatorname{SG}(x)=v$ 的最小 $x$ 为 $x_v$，则 $\lfloor x_v-2\sqrt{x_v}\rfloor=x_{v-1}$。直接递推就行了。

计算出来后直接二分找出最大的 $x \le s_i$ 就行了。时间 $O(\sqrt{S}+n\log{S})$。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
inline char gc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char c=gc();
	while(c<'0'||c>'9')c=gc();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=gc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char c=gc();
	while(c<'0'||c>'9')c=gc();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=gc();
	return x;
}
ll s,S;
int n,k;
int ans[19];
int cnt,bt,sg;
ll dsg[173273];
inline int SG(ll x)
{
	int l=0,r=cnt,m;
	while(l<r)
	{
		m=r-((r-l)>>1);
		if(dsg[m]==x)l=r=m;
		else (dsg[m]<x)?(l=m):(r=m-1);
	}
	return l;
}
int main()
{
	n=read(),k=read()+1,S=_read(),dsg[0]=0;
	for(rg int i=1;;++i)
	{
		double v=sqrt(dsg[i-1]+1)+1;
		dsg[i]=(ll)(v*v);
		if(dsg[i]-2*sqrt(dsg[i])<dsg[i-1])++dsg[i];
		if(dsg[i]>=S){cnt=i;break;}
	}
	for(rg int i=0;i<n;++i)
	{
		s=_read();
		sg=SG(s),bt=0;
		while(sg)
		{
			(sg&1)&&(++ans[bt],\
			(ans[bt]==k)&&(ans[bt]=0));
			sg>>=1,++bt;
		}
	}
	int flag=0;
	for(rg int i=0;i<18;++i)
	{
		if(ans[i])
		{
			flag=1;break;
		}
	}
	puts((flag)?"YES":"NO");
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：1)

## Solution

考虑从 $s_i$ 个石子里面取出 $c$ 个，需要满足什么：
$$\begin{cases}ab=s_i\\a+b=c\end{cases}$$

也就是 $a(c-a)=s_i$，即 $a^2-ca+s_i=0$。根据八年级学过的二次方程判别式，方程有实数解的充要条件是 $\Delta=c^2-4s_i\ge 0$，即 $c\ge 2\sqrt{s_i}$。

也就是每次从至少一堆、至多 $k$ 堆石子里取走至少 $\lceil2\sqrt{s_i}\rceil$ 个。容易发现每堆独立，考虑求出每堆的 $\text{SG}$ 函数。

根据定义 $\text{SG}(x)=\text{mex}_{y\in[0,x-\lceil2\sqrt{x}\rceil]}\{\text{SG}(y)\}$，可以发现 $x-2\sqrt{x}=(\sqrt{x}-1)^2-1$ 不降，所以对于 $x'>x$，$x'$ 转移时的取值范围包含了 $x$ 转移时的取值范围。故我们有 $\text{SG}(x)=\text{SG}(x-\lceil2\sqrt{x}\rceil,x-1])+1$。

直接需要 $\mathcal{O}(S)$，考虑优化。可以发现 $\text{SG}(x)\le\sqrt{x}$，设 $l_i$ 为最小的 $x$ 使得 $\text{SG}(x)=i$，如果求出了这个，二分一下即可求出 $\text{SG}(x)$。考虑求出 $l_i$，设 $x=l_i,y=l_{i+1}$：
$$x=\lfloor y-2\sqrt{y}\rfloor$$
$$y-2\sqrt{y}-1<x\le y-2\sqrt{y}$$

考虑右边:
$$x\le (\sqrt{y}-1)^2-1$$
$$1+\sqrt{x+1}\le \sqrt{y}$$
$$y\ge(1+\sqrt{x+1})^2$$

同理可以求得左边，故 $y\in[(1+\sqrt{x+1})^2,(1+\sqrt{x+2})^2)$。直接令 $l_i=(1+\sqrt{l_{i-1}+1})^2$，不断尝试 $+1$ 即可。

至于取 $[1,k]$ 堆，套个 [k-SG](https://www.luogu.com.cn/article/1am7gm8b) 即可。

时间复杂度 $\mathcal{O}(n\log S+\sqrt{S})$。

## Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 3e7 + 5;
	LL n, k, S, B, x, lw[N], b[N];
	int main() {
		cin >> n >> k >> S, B = sqrt(S);
		REP(i, 1, B) {
			lw[i] = pow(sqrt(lw[i - 1] + 1) + 1, 2);
			while (lw[i] - ceil(sqrt(lw[i]) * 2) < lw[i - 1]) lw[i] ++;
		}
		REP(i, 1, n)
			cin >> x, b[i] = upper_bound(lw + 1, lw + 1 + B, x) - lw - 1;
		int chk = 1;
		REP(i, 0, 16) {
			int x = 0;
			REP(j, 1, n) x += (b[j] >> i & 1);
			chk &= !(x % (k + 1));
		}
		cout << (chk ? "NO" : "YES") << '\n';
		return 0;
	}
}
```

---


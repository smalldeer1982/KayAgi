# [JRKSJ R8] +1-1

## 题目描述

给你 $n$ 个点 $m$ 条边的无向图，每个结点上有一个字符 `(` 或者 `)`。

有 $q$ 次查询，每次查询给出 $x,y$，你需要判断是否存在一条从 $x$ 到 $y$ 的路径（不需要保证是简单路径）满足将路径上的点上的字符顺次写下来得到的字符串是合法括号串。

## 说明/提示

合法括号串的定义：

* 空字符串是合法括号串
* 若 $A,B$ 是合法括号串，则 $AB$ 是合法括号串
* 若 $A$ 是合法括号串，则 $(A)$ 是合法括号串
* 除此之外的其他字符串均不是合法括号串

如 `()`、`(()())` 是合法括号串，`(()`、`())(` 不是合法括号串。

### 样例解释

**为了方便观察，输入的边和询问之间有一个换行。但数据中并不存在这个换行。**

![](https://cdn.luogu.com.cn/upload/image_hosting/x2lp3c7m.png)

其中 $1,2,3$ 号点的字符是 `(`，$4,5$ 号点的字符是 `)`。

$1\to 2$：显然，合法括号串不可能以 `(` 结尾。\
$3\to 4$：路径 $3\to 4$ 表示的字符串是 `()`。\
$1\to 4$：路径 $1\to 3\to 2\to 4\to 5\to 4$ 表示的字符串是 `((()))`。\
$1\to 5$：路径 $1\to 2\to 4\to 5$ 表示的字符串是 `(())`。\
$2\to 5$：路径 $2\to 3\to 4\to 5$ 表示的字符串是 `(())`。

### 数据规模与约定

本题采用捆绑测试。

- Subtask 1（20 pts）：$n,q\leq 500$，$m \leq 800$；
- Subtask 2（30 pts）：图是森林；
- Subtask 3（20 pts）：$q\le 10$；
- Subtask 4（30 pts）：无特殊限制。

对于所有数据，满足 $1\le n,q\le 5\times 10^5$，$0\le m\le \min(\frac{n\times(n-1)}{2},5\times 10^5)$，$1\le u,v,x,y\le n$，保证给出的图无重边、无自环。

## 样例 #1

### 输入

```
5 6 5
((())
1 2
1 3
2 3
3 4
4 5
2 4

1 2
3 4
1 4
1 5
2 5
```

### 输出

```
01111```

# 题解

## 作者：未来姚班zyl (赞：29)

## 题目大意

给定一个带点权的无向图，点权为括号，多次询问是否存在 $x\rightarrow y$ 的路径（可以不是简单路径），使得路径上的点权构成合法的括号序列。

## 题目分析

这道题如果从做完的角度来看是非常简单的，但是从分析的过程来看，每一步都是要非常强大的基本功的。

考虑合法的路径满足的性质：

- 长度一定得是偶数。

这个限制只需要将每个点拆成奇点和偶点即可，然后查询变为 $x$ 的奇点到 $y$ 的偶点是否存在合法路径。之后的分析我们就可以不用考虑奇偶性。

显然，如果有一条边连接了两个相同的括号，我们就可以无限复制这个括号，称这样的边为 $)$ 边或者 $($ 边，统称括号边。我们先考虑没有括号边的情况。

则路径都形如 $()()()\dots$。这是比较极限的，必须相邻的括号两两匹配。

这样我们可以发现，对于括号边带来的括号，是不可能用上面这些括号匹配的，只能括号边之间两两匹配。由于可以无限复制，我们只需要第一次出现的括号边是 $($ 边，最后一次出现的括号边是 $)$ 边即可平衡，否则就非法。

这时候来考虑是否存在合法路径，首先两个点得在同一个连通块里。

- 没有括号边

则我们拿非括号边跑并查集即可。

- 有括号边

则需要从一个起点**不经过 $)$ 边**走到一个 $($ 边，然后走到一个 $)$ 括号边，并**不经过 $($ 边走到**终点。我们只需要记录每个并查集是否可以直接到达这两类边即可。

复杂度 $O(n\log n)$，直接搜索来处理连通性可以 $O(n)$，但比赛的时候肯定是写并查集更方便！

```cpp
#include<bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define pc putchar
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N =1e6+5,M=2e6+5;
int n,m,q,h[N],to[M],nxt[M],cnt,a[N],f[N],fa[N];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
inline int Find(int x){return fa[x]==x?x:fa[x]=Find(fa[x]);}
bool C[N],D[N],Spe[N];
string s;
inline void add_(int a,int b){
	s[a]!=s[b]?fa[Find(a)]=Find(b):Spe[a]=Spe[b]=1,f[find(a)]=find(b),to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
int main(){
	n=read(),m=read(),q=read();
	cin>>s,s='#'+s+s;
	rep(i,1,n<<1)f[i]=fa[i]=i;
	while(m--){
		int x=read(),y=read();
		add_(x,y+n),add_(y+n,x),add_(y,x+n),add_(x+n,y);
	}
	rep(x,1,n<<1){
		int X=Find(x);
		e(x)C[X]|=s[y]=='('&&Spe[y],D[X]|=s[y]==')'&&Spe[y];
	}
	while(q--){
		int x=read(),y=read();
		if(s[x]==')'||s[y]=='('){
			pc('0');
			continue;
		}
		if(find(x)!=find(y+n)){
			pc('0');
			continue;
		}
		pc(C[Find(x)]&&D[Find(y+n)]?'1':Find(x)==Find(y+n)?'1':'0');
	}
	return 0;
}
```

---

## 作者：critnos (赞：13)

首先 $x$ 是 `(` $y$ 是 `)`。

保留所有连接左右括号的边，这是二分图。若 $x$ 能在该图上走到 $y$ 则可行。

否则，从二分图上 $x$ 所在的连通块走出去一定要走连接两个左括号的边，$y$ 则是两个右括号。如果有一条从 $x$ 经过二分图上的路径到达连接两个左括号的边再走一段之后经过连接两个右括号的边之后到达 $y$，且这条路径长度为偶数，那么就可以通过反复走这两条边使得括号串合法。 

考虑上述两条边在 $x,y$ 连通块内的点（必须存在），分别记作 $p,q$，$x\to p$，$q\to y$ 的路径长度一定为奇数，那么我们要求 $p\to q$ 存在长度为偶数的路径。很明显这等价于 $x\to y$ 存在长度为偶数的路径。判断两点是否存在长度为偶数的路径只需要判断，两点是否在同一个连通块中且满足该连通块是二分图且这两点在异侧或者该连通块不是二分图即可。

---

## 作者：喵仔牛奶 (赞：12)

# Solution

假设我们在 $u,v$ 间确定了一条简单路径。可以发现，要经过一个简单路径外的点，只有这一种情况：
- $u$ 在简单路径上，$v$ 不在简单路径上，$u,v$ 间有边且 $u,v$ 括号相同。在 $u,v$ 间反复横跳。

这是容易证明的，因为长度 $\geq2$ 的简单路径外的路径可以拆解为长度为 $1$ 的；而若 $u,v$ 括号不同，跳出去没有意义。

我们定义括号为 `(` 且存在相邻的括号相同的点为红点，括号为 `)` 且存在相邻的括号相同的点为蓝点。

我们可以归纳出合法的情况：
- $u,v$ 可以通过 `()()..()` 的形式直接联通。
- $u$ 通过 `()()..()` 的形式联通到红点 $p$，$v$ 通过 `()()..()` 的形式联通到蓝点 $q$，$p,q$ 间通过长度为**偶数**的路径联通。

对于情况二，$u\to p,q\to v$ 路径上的括号都恰好匹配，我们在 $p$ 处来回跳跃 $10^{100}$ 次，即可保证 $p,q$ 路径间的右括号不会失配，我们在 $q$ 处来回跳跃直到使剩下的左括号匹配完即可。由于 $p,q$ 处来回跳跃只能增加偶数个括号，而 $u\to p,q\to v$ 路径长度必定为偶数，所以要保证 $p\to q$ 路径的长度为偶数。

具体地，将原图 $G$ 断开所有 $u,v$ 括号不同的边 $(u,v)$ 形成新图 $G'$。处理出 $u$ 在 $G$ 中的连通块编号与在 $G'$ 中通过 `()()..()` 的形式形成的联通块编号（代码中的 `vs` 数组与 `bel` 数组）。处理出 $u$ 在 $G'$ 中是否联通红点与蓝点（代码中的 `st` 数组）以判断能否联通到 $p,q$。这部分 dfs 即可完成。

对于 $p\to q$ 的路径，由于 $u\to p,p\to u$ 来回两次的路径长度为偶数没有影响，我们强制到 $p$ 后走回 $u$，到 $q$ 后走回 $v$，再判断 $u,v$ 间是否有长度为偶数的路径。对 $G$ 中 $u,v$ 所处的连通块黑白染色，若该连通块有奇环则必定存在偶数长度路径，否则仅当 $u,v$ 颜色不同时存在偶数长度路径。这部分也可在 dfs 中顺便完成。代码中，`odd` 表示该连通块有无奇环，`dis` 表示黑白染色中的颜色。

综上，进行两遍 dfs 即可。时间复杂度 $\mathcal{O}(n+m+q)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5;
	int n, m, q, u, v, ct, a[N], col[N], bel[N], vs[N], dis[N], odd[N], st[N], rs[N]; char ch;
	vector<int> G[N];
	void dfs1(int u, int id, int t) {
		bel[u] = id, st[id] |= 1 << col[u];
		for (int v : G[u])
			if (!bel[v] && a[u] != a[v]) dfs1(v, id, t ^ 1);
	}
	void dfs2(int u, int id) {
		vs[u] = id;
		for (int v : G[u]) {
			if (!vs[v]) dis[v] = dis[u] ^ 1, dfs2(v, id);
			if (dis[u] == dis[v]) odd[id] = 1;
		}
	}
	int main() {
		cin >> n >> m >> q;
		REP(i, 1, n) cin >> ch, a[i] = (ch == '(' ? 1 : -1);
		REP(i, 1, m) cin >> u >> v, G[u].pb(v), G[v].pb(u);
		REP(i, 1, n) for (int v : G[i]) {
			if (a[i] == 1 && a[v] == 1) col[i] = 1;
			if (a[i] == -1 && a[v] == -1) col[i] = 2;
		}
		REP(i, 1, n) {
			if (!vs[i]) dfs2(i, i);
			if (!bel[i]) dfs1(i, ++ ct, 0);
		}
		REP(i, 1, q) {
			cin >> u >> v;
			if (a[u] != 1 || a[v] != -1 || vs[u] != vs[v]) continue;
			if (bel[u] == bel[v]) rs[i] = 1;
			if ((odd[vs[u]] || dis[u] != dis[v]) && (st[bel[u]] >> 1 & 1) && (st[bel[v]] >> 2 & 1)) rs[i] = 1;
		}
		REP(i, 1, q) cout << rs[i];
		cout << '\n';
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：Leo_SZ (赞：8)

考虑怎么走出一个合法的路径。

尝试从 $x$ 走到两个端点都是 `(` 的边（记为 L 型边）反复横跳，再走到一个奇环绕 1 或 2 圈，再走到两个端点都是 `)` 的边（记为 R 型边）反复横跳，然后到 $y$。

如果中间没有奇环，则是二分图，要求 $x$ 和 $y$ 不在二分图的同一部。

如果不能到达 L 型或 R 型边，则最终路径由 `(` 和 `)` 交替构成。

接下来说明一下代码的结构。

- bfs1：构建第一类连通块，防止 $x$ 到不了 $y$。

- bfs2：构建由 `(` 和 `)` 交替构成的第二类连通块。

- bfs3：二分图染色找奇环，`odd[i]` 表示第 i 个第一类连通块里面有奇环，否则 `col[i]` 标记点 i 在二分图的哪一部。

- bfs4：从 L 型边或 R 型边出发，找哪些 `(` 的点能到 L 型边，哪些 `)` 的点能到 R 型边。`okl[i]` 表示在 i 点之前至少要经过 `okl[i]` 个(的点，才能从 i 走到 L 型边，`okr[i]` 类似，用的是 SPFA。

最后，存在合法路径需要满足以下条件：
1. $x$ 和 $y$ 处在同一个第一类连通块中。

1. 如果 $x$ 不能到达 L 型边，或 $r$ 不能到达 R 型边，则要求 $x$ 和 $y$ 在同一个第二类连通块中。

1. 否则，要求 $x$ 和 $y$ 处在的第一类连通块中有奇环，或者 $x$ 和 $y$ 不在二分图的同一部。

AC 代码：

```cpp
#include<bits/stdc++.h>
#define Maxn 500005
using namespace std;
int n,m,t;
char a[Maxn];
vector<int> e[Maxn];

int vis[Maxn],visl[Maxn],visr[Maxn];
queue<int> q,ql,qr;

int scc1[Maxn],tot1;
void bfs1(int x){
	while(!q.empty()){ q.pop(); }
	scc1[x] = ++tot1;
	q.emplace(x); vis[x]=1;
	while(!q.empty()){
		x = q.front(); q.pop();
		for(int y : e[x])if(!vis[y]){
			scc1[y] = tot1;
			q.emplace(y); vis[y]=1;
		}
	}
}

int scc2[Maxn],tot2;
void bfs2(int x){
	while(!q.empty()){ q.pop(); }
	scc2[x] = ++tot2;
	q.emplace(x); vis[x]=1;
	while(!q.empty()){
		x = q.front(); q.pop();
		for(int y : e[x])if(!vis[y] && a[x] != a[y]){
			scc2[y] = tot2;
			q.emplace(y); vis[y]=1;
		}
	}
}

int col[Maxn],odd[Maxn];
void bfs3(int x){
	while(!q.empty()){ q.pop(); }
	col[x] = 0; q.emplace(x);
	while(!q.empty()){
		x = q.front(); q.pop();
		for(int y : e[x]){
			if(~col[y]){
				if(col[y] == col[x]){
					odd[scc1[x]] = 1; return;
				}
			} else {
				col[y] = col[x] ^ 1; q.emplace(y);
			}
		}
	}
}

int okl[Maxn],okr[Maxn];
void bfs4(int x){
	while(!q.empty()){ q.pop(); }
	q.emplace(x); vis[x]=1;
	while(!q.empty()){
		x = q.front(); q.pop();
		for(int y : e[x])if(!vis[y]){
			q.emplace(y); vis[y]=1;
			if(a[x] != a[y]){ continue; }
			if(a[x] == '('){
				okl[x] = okl[y] = 0;
				ql.emplace(x); ql.emplace(y);
			} else {
				okr[x] = okr[y] = 0;
				qr.emplace(x); qr.emplace(y);
			}
		}
	}
}
void spfa(){
	int x,z;
	while(!ql.empty()){
		x = ql.front(); ql.pop();
		visl[x] = 0;
		for(int y : e[x]){
			z = max(0, okl[x] + ((a[y] == ')') ? 1 : -1));
			if(okl[y] > z){
				okl[y] = z;
				if(visl[y]){ continue; }
				ql.emplace(y); visl[y] = 1;
			}
		}
	}
	while(!qr.empty()){
		x = qr.front(); qr.pop();
		visr[x] = 0;
		for(int y : e[x]){
			z = max(0, okr[x] + ((a[y] == '(') ? 1 : -1));
			if(okr[y] > z){
				okr[y] = z;
				if(visr[y]){ continue; }
				qr.emplace(y); visr[y] = 1;
			}
		}
	}
}

int main(){
	scanf("%d%d%d%s",&n,&m,&t,a+1);
	int x,y,z;
	for(int i=1; i<=m; i++){
		scanf("%d%d",&x,&y);
		e[x].emplace_back(y);
		e[y].emplace_back(x);
	}
	
	for(int i=1; i<=n; i++)if(!vis[i]){
		bfs1(i);
	}
	
	memset(col, 0xff, sizeof(col));
	for(int i=1; i<=n; i++)if(col[i] == -1){
		bfs3(i);
	}
	
	memset(vis, 0, sizeof(vis));
	for(int i=1; i<=n; i++)if(!vis[i]){
		bfs2(i);
	}
	
	memset(vis, 0, sizeof(vis));
	memset(okl, 0x3f, sizeof(okl));
	memset(okr, 0x3f, sizeof(okr));
	for(int i=1; i<=n; i++)if(!vis[i]){
		bfs4(i);
		spfa();
	}
	
	while(t--){
		scanf("%d%d",&x,&y);
		if(scc1[x] != scc1[y]){
			printf("0"); continue;
		}
		z = scc1[x];
		if(okl[x] || okr[y]){
			if(a[x]=='(' && a[y]==')' && scc2[x] == scc2[y]){
				printf("1");
			} else {
				printf("0");
			}
			continue;
		}
		if(odd[z] || col[x] != col[y]){
			printf("1");
		} else {
			printf("0");
		}
	}
	return 0;
}
```

---

## 作者：_Cheems (赞：6)

厉害题。首先膜拜考场过了的 myz，蒟蒻看了评讲才懂。

考虑怎么刷括号，注意到 `()` 和 `)(` 这种没法刷，但是 `((` 和 `))` 就可以不断产生 $2k$ 个新的括号。

考虑一条路径合法的条件，假如其一开始是 `()...()` 一定合法。

否则，呈现为开头结尾皆为连续 `()`，但中间夹着一串不可名状之物 $S$。将 $S$ 所有合法括号对删去后，必然呈现 `)...)(...(` 的形式，那么 $S$ 的开头必须是 `((`，结尾必须是 `))`，否则无法刷括号。注意到刷括号不能改变某种括号的奇偶性，所以要求最终剩下的左右括号个数的奇偶性相同。又因为删去的合法括号对中的括号总个数必然是偶数，所以得出一个判断条件：走过的路径长度为偶数，且 `((` 先于 `))` 出现。

这启示我们将 `()` 边单独拎出来，这构成二分图。

那么可以开始判定了：

* 边界条件：若 $c_x\ne$ `(` 或 $c_y\ne$ `)`，非法；若 $x,y$ 在原图不连通，非法。

* 若 $x,y$ 在二分图上连通，合法。否则需满足下列条件：

* 刷括号条件：$x$ 在二分图上的连通块存在 `(` 与原图上 `(` 相邻，且 $y$ 在二分图连通块存在 `)` 与原图上 `)` 相邻即可。

* 路径为偶数：$x,y$ 所在连通块上存在奇环，就可以走奇环改变奇偶性得到偶数路径；若不存在奇环，那么构成二分图（注意和一开始只有 `()` 边的二分图区分），$x\to y$ 的路径的奇偶性被唯一确定，若 $x,y$ 在二分图不同侧才能有偶数路径。
#### 代码
~~关于我把 `col` 开成 `bool` 类型于是调了好久的这件事。~~

```cpp
#include<bits/stdc++.h>
#define NO {putchar('0'); continue;}
#define YES {putchar('1'); continue;}
using namespace std;

const int N = 5e5 + 5;
int n, m, q, u, v, fa[N], fa2[N], x, y;
bool col_left[N], col_right[N], flag_left[N], flag_right[N];
int col[N], jihuan[N];
char c[N];
vector<int> to[N];

inline int find(int fa[], int u) {return fa[u] == u ? u : fa[u] = find(fa, fa[u]);}
inline bool dfs(int u, int cl){
	bool fl = false; col[u] = cl;
	for(auto v : to[u])
		if(!col[v]) fl |= dfs(v, 3 - cl);
		else if(col[v] == col[u]) fl = true; 
	return fl;
}
int main(){
	scanf("%d%d%d %s", &n, &m, &q, c + 1);
	for(int i = 1; i <= n; ++i) fa[i] = fa2[i] = i;
	for(int i = 1; i <= m; ++i){
		scanf("%d%d", &u, &v), to[u].push_back(v), to[v].push_back(u);
		fa[find(fa, u)] = find(fa, v);
		if(c[u] != c[v]) fa2[find(fa2, u)] = find(fa2, v);
		if(c[u] == '(' && c[v] == '(') flag_left[u] = flag_left[v] = true;
		if(c[u] == ')' && c[v] == ')') flag_right[u] = flag_right[v] = true;
	}
	for(int i = 1; i <= n; ++i) col_left[find(fa2, i)] |= flag_left[i], col_right[find(fa2, i)] |= flag_right[i];
	for(int i = 1; i <= n; ++i) if(fa[i] == i) jihuan[i] = dfs(i, 1);
	
	while(q--){
		scanf("%d%d", &x, &y);
		if(find(fa, x) != find(fa, y) || c[x] != '(' || c[y] != ')') NO
		int fx = find(fa2, x), fy = find(fa2, y);
		if(fx == fy) YES
		if(col_left[fx] && col_right[fy] && (jihuan[find(fa, x)] || col[x] != col[y])) YES
		NO
	}
	return 0;
}
```

---

## 作者：TernaryTree (赞：6)

首先合法括号序列的充要条件是，把左括号右括号分别看成 $+1$ 和 $-1$，前缀和最小值非负并且总和等于 $0$。不必多说。

非简单路径，这个显然瞎搞一下。也就是说如果你遇到一条边两端都是左括号，你就可以反复横跳，让前缀和一直变大，这样可以避免前缀和最小值为负；然后再找个两端都是右括号的地方消回来就行。

定义一条边具有三种类型。

- 两端不同，记为 `()` 型。
- 两端相同
   - 都为 `(`，记为 `(` 型。
   - 都为 `)`，记为 `)` 型。
   
那么我们所需要的就是让 $x$ 走到 $y$，路上在一个 `(` 型边横跳一下，再在一个 `)` 型边横跳一下。当然这并不够。考虑如果一个 `(` 走出去一步，每个点都是 `)`，再走出去一步，每个点也还是 `)`。也就是说你两步之后出不去了。

结合一下上面的思考可以得到结论：可以构造一种优的路径方式，使得从 $x$ 先走若干条 `()` 边，在遇到 `(` 边时反复横跳，中间瞎走走到 `)` 边继续横跳回来，最后再走若干条 `()` 到 $y$。

于是我们把所有 `()` 边先拉出来，形成了若干个连通块；对于 `(` 型边连接的两个连通块（也可能是一个），分别标记这两个连通块的 `(` 型点是有效的，可以从这里出去；`)` 型边同理。

那么如何判断。首先 $u$ 必须是 `(`，$v$ 必须是 `)`。其次它们必须在原图上连通。以及，若所在原图连通块为二分图且这两个点同色是无解的，这样不存在经过偶数个点的路径。核心判断是，若两个点仅通过 `()` 型边可达，答案为 `1`；否则，$x$ 所在 `()` 连通块的 `(` 型点必须被标记为有效，$y$ 同理。

写的是并查集，所以复杂度瓶颈并查集。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fs first
#define sc second
#define ls (u << 1)
#define rs (u << 1 | 1)
#define mid ((l + r) >> 1)
#define lc ls, l, mid
#define rc rs, mid + 1, r
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, r, l) for (int i = (r); i >= (l); --i)
#define gc getchar
#define pc putchar

using namespace std;
using pii = pair<int, int>;
using vi = vector<int>;

const int maxn = 1e6 + 10;
const bool multidata = 0;

template<typename T = int>
T read() {
	T x = 0, f = 1; char c = gc();
	while (c < '0' || c > '9') { if (c == '-') f = -f; c = gc(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return x * f;
}

template<typename T = int>
void write(T x) {
	if (x < 0) pc('-'), x = -x;
	if (x < 10) return void (pc(x + '0'));
	write<T>(x / 10), pc(x % 10 + '0');
}

int n, m, q;
char s[maxn];
pii e[maxn];
vector<int> g[maxn];
int fa[maxn];
bool al[maxn], ar[maxn];
string ans;
int c1[maxn], c2[maxn], tot;
int jud[maxn];

int find(int x) {
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void dfs(int u, int p1, int p2) {
	c1[u] = p1, c2[u] = p2;
	for (int v : g[u]) {
		if (!c2[v]) dfs(v, p1 ^ 1, p2);
		else if (c1[v] == p1) jud[p2] = 0;
	}
}

void fake_main() {
	n = read(), m = read(), q = read();
	cin >> s + 1;
	rep(i, 1, n) fa[i] = i;
	rep(i, 1, m) {
		int u = read(), v = read();
		e[i] = {u, v};
		if (s[u] != s[v]) fa[find(v)] = find(u);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	rep(i, 1, n) if (!c2[i]) ++tot, jud[tot] = 1, dfs(i, 0, tot);
	rep(i, 1, m) {
		int u = e[i].fs, v = e[i].sc;
		if (s[u] == s[v]) {
			char c = s[u];
			u = find(u), v = find(v);
			if (c == '(') al[u] = al[v] = 1;
			if (c == ')') ar[u] = ar[v] = 1;
		}
	}
	while (q--) {
		int u = read(), v = read();
		if (s[u] != '(' || s[v] != ')' || c2[u] != c2[v] || (jud[c2[u]] && c1[u] == c1[v])) {
			ans += '0';
			continue;
		}
		if (find(u) == find(v)) {
			ans += '1';
			continue;
		}
		if (al[find(u)] && ar[find(v)]) {
			ans += '1';
		} else {
			ans += '0';
		}
	}
	cout << ans;
}

signed main() {
	int T = multidata ? read() : 1;
	while (T--) fake_main();
	return 0;
}

```

---

## 作者：TLE_Automat (赞：5)

## 解题思路

先考虑几个**必要条件**：

- $x$ 结点是 `(` 且 $y$ 结点是 `)`。
- $x$ 到 $y$ 至少有一条路径经过偶数个结点。

在此之外，我们注意到如果路径的开头存在连续两个 `(`，那么可以在上面来回走来刷左括号；如果路径的结尾存在两个 `)`，那么可以在上面来回走来刷右括号。

那么一个初步的想法就是：

- 如果 $x$ 可以直接沿着左右括号交替的路径走到 $y$，那就做完了。

- 否则，从 $x$ 沿着交替的左右括号一直走，走到某一个 `((`，然后开始刷足够多的左括号，然后原路返回 $x$，再从 $x$ 沿着某条经过偶数个结点的路径走到 $y$，从 $y$ 沿着交替的左右括号一直走，走到某一个 `))`，然后开始刷右括号，刷到与剩下的左括号平衡，然后返回 $y$ 即可。

第一种情况正确性显然。

第二种情况，三段路径中每段路径经过的点数都是偶数，且前面刷了足够多的左括号让中间的段的每个右括号都能匹配，且最后能够刷右括号去抵消之前刷多了的左括号，所以也是正确的。

那么如果这两种情况都不满足，说明从 $x$ 沿着左右交替的括号无法走到 $y$ 也无法走到 `((`，只能走到 `))`，那这样显然不合法。

所以思路想完了，现在考虑如何实现。

- **第一步，我们要先判断 $x$ 到 $y$​ 是否至少有一条路径经过偶数个结点。**

  1. 如果图是二分图，那么只需要判断 $x, y$ 是否不在同一部。

  2. 如果图不是二分图，那么说明图中一定存在奇环，那么可以在这个奇环上绕一圈来控制奇偶性，这样任意两点 $x, y$ 之间一定有经过偶数个结点偶数的路径。

- **第二步，我们要判断 $x$ 是否能通过交替的左右括号走到 $y$。**

  这个我们只需要保留原图中从 `(` 连向 `)` 的边，然后使用并查集判断 $x, y$ 是否在同一个连通块即可。

- **第三步，我们要判断 $x$ 是否能通过交替的左右括号走到某一个 `((`**。

  这个我们只需要在第二步的图中把 `((` 的两个括号所在的连通块打个标记即可。

- **第四步，我们要判断 $y$ 是否能通过交替的左右括号走到某一个 `))`**

  这个跟第三步同理。

注意这题并**不保证图联通**，还要额外判一下连通性，然后就完结撒花了。


## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

#define SZ(x) ((int)((x).size()))
#define lb(x) ((x) & (-(x)))
#define bp(x) __builtin_popcount(x)
#define bpll(x) __builtin_popcountll(x)
#define mkp make_pair
#define pb push_back
#define fi first
#define se second
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
typedef pair<ll, ll> pll;
typedef pair<double, int> pdi;

const int MAXN = 5e5 + 10;

struct Dsu {
    vector<int> fa;
    void init(int n) {
        fa.resize(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
        }
    }
    int fifa(int x) {
        if (fa[x] == x) {
            return x;
        }
        return fa[x] = fifa(fa[x]);
    }
    void merge(int x, int y) {
        x = fifa(x);
        y = fifa(y);
        if (x != y) {
            fa[x] = y;
        }
    }
};

int n, m, q;
string s;
vector<int> G[MAXN];

void solve() {
    cin >> n >> m >> q >> s;
    s = ' ' + s;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    int cnt_id = 0;
    vector cop_id(n + 1, 0);
    auto dfs_cop = [&](auto&& self, int u) -> void {
        cop_id[u] = cnt_id;
        for (auto v : G[u]) {
            if (cop_id[v]) {
                continue;
            }
            self(self, v);
        }
    };
    for (int i = 1; i <= n; i++) {
        if (!cop_id[i]) {
            cnt_id++;
            dfs_cop(dfs_cop, i);
        }
    }

    vector is_erfen(n + 1, true);
    vector clr(n + 1, -1);
    auto dfs_clr = [&](auto&& self, int u, int idx) -> void {
        if (!is_erfen[idx]) {
            return ;
        }
        for (auto v : G[u]) {
            if (clr[v] == -1) {
                clr[v] = !clr[u];
                self(self, v, idx);
            } else if (clr[v] == clr[u]) {
                is_erfen[idx] = false;
                break;
            }
        }
    };
    for (int i = 1; i <= n; i++) {
        if (clr[i] == -1) {
            clr[i] = 0;
            dfs_clr(dfs_clr, i, cop_id[i]);
        }
    }

    Dsu dsu;
    dsu.init(n);
    for (int u = 1; u <= n; u++) {
        for (auto v : G[u]) {
            if (s[u] != s[v]) {
                dsu.merge(u, v);
            }
        }
    }
    vector flgl(n + 1, false), flgr(n + 1, false);
    for (int u = 1; u <= n; u++) {
        for (auto v : G[u]) {
            if (s[u] == '(' && s[v] == '(') {
                flgl[dsu.fifa(u)] = true;
                flgl[dsu.fifa(v)] = true;
            }
            if (s[u] == ')' && s[v] == ')') {
                flgr[dsu.fifa(u)] = true;
                flgr[dsu.fifa(v)] = true;
            }
        }
    }

    string ans;
    while (q--) {
        int x, y;
        cin >> x >> y;

        if (cop_id[x] != cop_id[y]) {
            ans += '0';
            continue;
        }
        int id = cop_id[x];
        if (is_erfen[id] && clr[x] == clr[y]) {
            ans += '0';
            continue;
        }
        if (s[x] != '(' || s[y] != ')') {
            ans += '0';
            continue;
        }

        if (dsu.fifa(x) == dsu.fifa(y)) {
            ans += '1';
            continue;
        }
        if (flgl[dsu.fifa(x)] && flgr[dsu.fifa(y)]) {
            ans += '1';
            continue;
        }
        ans += '0';
    }
    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T--) solve();
    return 0;
}
```

---

## 作者：chenly8128 (赞：5)

# 题解
## 方法概要
~~感觉我的方法好像和大家不一样。~~
我是运用**贪心**并且多次运用**并查集**的方法来做的。
## 基本要求

可以发现，想要让括号序列合法，首先有这些要求：
1. 起点是 $($，终点是 $)$。
2. 起点和终点是联通的。
3. 路线总长度是偶数。

以上要求都比较好处理。

第一个要求可以直接特判。

第二个要求可以用并查集进行合并（或者 tarjan 算法，但是没有必要）。

第三个要求比较容易漏掉（我比赛的时候一开始也漏了，调了半天）。可以设某一个节点为基准点，DFS 记录下每一个节点距离基准点的路径长度是奇数还是偶数还是奇偶数均可。查询时判断两个节点是否一个距离基准点奇数个单位，另一个距离基准点偶数个单位。

这三点都比较好理解，具体看代码。
## 附加要求
在满足**基本条件**的情况下，满足**附加条件**，才能说明存在符合要求的路径。
附加条件比较复杂，先定义三个概念：
- **万能起点**：如果有两个节点，它们相邻，并且都为 $($，称这两个节点组成的整体为万能起点。
- **万能终点**：如果有两个节点，它们相邻，并且都为 $)$，称这两个节点组成的整体为万能终点。
- **朴素路径**：如果一条路径不含有两个连续的相同方向括号，则称这条路径为朴素路径。特别的，空的路径也算朴素路径。举个例子 $)()()()()$ 就是一个朴素路径。

我们把万能起点和万能终点统称**万能点**。

分两种情况：
### 情况一
节点 $x$ 通过一条朴素路径就能到达节点 $y$。那么很明显，符合要求。

具体实现可以通过并查集，合并所有相邻但是括号方向不同的节点，即可判断是否存在这样一条朴素路径。
### 情况二
如果不存在这样的朴素路径…

那么很明显，在节点 $x$ 到 $y$ 的路径上有至少一个万能点。
#### 规律一（可以不看，不重要）
结论 1：如果一条符合要求的路径上经过一个万能起点，那么一定经过一个万能终点。反之亦然。

证明 1：很简单。如果路径经过连续两个左括号，那么可以假设该路径可以被表示为字符串 $A((B$。字符串 $A$ 中，左括号数量必定**大于等于**右括号数量，又因为整个序列中左括号数量必定**等于**右括号数量，所以 $B$ 中左括号数量**小于**右括号数量减 $1$。而 $B$ 中的右括号之间的间隔有（右括号数量减 $1$）个，故左括号无法把所有的间隔都填上，肯定存在至少一个间隔没有左括号，所以存在两个右括号连续，故**存在至少一个万能终点**。反之亦然。

#### 规律二（可以不看，不重要）
结论 2：在一个符合要求的路径中，对于任何一个万能终点，总存在一个万能起点出现在它的前面（即，**路径中的第一个万能点一定是万能起点**）。反之亦然。

证明 2：反证法：假设第一个万能点是万能终点。那么第一个万能点前面的路径是朴素路径，且朴素路径的最后一个括号是左括号（否则那个万能点就不是第一个了），所以可以设其中含有 $a$ 个左括号，则含有 $a-1$ 个右括号。所以这条朴素路径再加上 $2$ 个右括号的整一个括号序列中，有左括号 $a$ 个，右括号 $a+1$ 个。右括号多于左括号，这是不可能的。所以第一个万能点只能是万能起点。反之亦然，即最后一个万能点只能是万能终点。
#### 规律三（这个是要理解的，很关键）
结论 3：任何一个括号序列，只要在它的左边加上一定数量的左括号，在它的右边加上一定数量的右括号，它就能变成合法的括号序列。

证明 3：略，这是基本性质。
#### 规律4（这个是要理解的，很关键）
结论 4：对于任意的出发点 $x$ 和目的地 $y$，只要 $x$ 能通过一个朴素路径（要求朴素路径的第一个括号是左括号，最后一个括号是右括号）到达任意一个万能起点 $s$，且存在一个万能终点 $e$ 能通过一个朴素路径（要求朴素路径的第一个括号是左括号，最后一个括号是右括号）到达 $y$，则 $x$ 一定能通过一个合法的路径到达 $y$。

证明 4：首先，根据基本性质 2，可以得到 $s$ 可以通过一个序列到达 $e$。可以设从 $x$ 到 $y$ 的序列为 $A$，$B$，$C$，$D$，$E$ 五个部分连接而成。$A$ 和 $E$ 为朴素路径（要求朴素路径的第一个括号是左括号，最后一个括号是右括号）。可以得到 $A$ 和 $E$ 都是合法序列。$B$ 由奇数个左括号构成，$D$ 由奇数个右括号构成。$C$ 是一个非法的序列。根据基本性质 3，整个序列是偶数个括号构成的，整体减去 $A$，$B$，$D$，$E$ 后，剩余偶数个括号，所以 $C$ 是由偶数个括号构成的。根据结论 3，$B$，$C$，$D$ 可以构成一个合法的序列。故 $A$，$B$，$C$，$D$，$E$ 组合成的序列是合法的，符合条件。

规律四的逆定理也是成立的。
#### 情况二的实现
设置两个并查集，分别记录万能起点通过朴素路径能连接的节点和万能终点通过朴素路径能连接的节点。
## $Code$
```cpp
#include <cstdio>
#include <vector>
#include <cstdlib>
using namespace std;
class DisJoinSet {
// 并查集
public:
	int * fa;
	int * rank;
	bool * flag;
	DisJoinSet (const int n) {
		fa = (int *)malloc (sizeof (int) * n);
		rank = (int *)malloc (sizeof (int) * n);
		flag = (bool *)malloc (sizeof (bool) * n);
		for (int j = 0;j < n;j++) {
			fa[j] = j;
			rank[j] = 0;
			flag[j] = false;
		}
	}
	int find (const int v) {
		return fa[v] = fa[v] == v ? v : find (fa[v]);
	}
	void merge (const int x,const int y) {
		int a = find(x);
		int b = find(y);
		if (a == b) return;
		if (rank[a] < rank[b]) {
			fa[a] = b;
			flag[b] |= flag[a];
		}
		else {
			fa[b] = a;
			flag[a] |= flag[b];
			if (rank[a] == rank[b]) rank[a]++;
		}
	}
	~DisJoinSet (void) {
		free (fa);
		free (rank);
    }
} ;
int n,m,q,x,y;
int vis[500000+10]; //距离基准点的距离
char s[500000+10];
vector <int> g[500000+10];
void dfs (int x,int t) {
	vis[x] |= t;
	int k = 3;
	if (vis[x] == 1) k = 2;
	if (vis[x] == 2) k = 1;
	for (int y : g[x]) {
		if (vis[y] != k && vis[y] != 3)
			dfs(y,k);
	}
}
int main (void) {
	scanf ("%d%d%d",&n,&m,&q);
	scanf ("%s",s+1);
	DisJoinSet de(n+5),ds(n+5),base(n+5),dk(n+5);
	while (m--) {
		scanf ("%d%d",&x,&y);
		g[x].push_back(y);
		g[y].push_back(x);
		base.merge(x,y);
		if (s[x] == '(' || s[y] == '(') ds.merge(x,y);
		if (s[x] == '(' && s[y] == '(') ds.flag[ds.find(x)] = true;
		if (s[x] == ')' || s[y] == ')') de.merge(x,y);
		if (s[x] == ')' && s[y] == ')') de.flag[de.find(x)] = true;
		if (s[x] != s[y]) {
			dk.merge(x,y);
		}
	}
	for (int j = 1;j <= n;j++)
		if (!vis[j]) dfs(j,1);
	while (q--) {
		scanf ("%d%d",&x,&y);
		if (base.find(x) != base.find(y) || s[x] == ')' || s[y] == '(' || (vis[x] | vis[y]) != 3) putchar('0'); //基本要求
		else if (dk.find(x) == dk.find(y)) putchar('1');
		else if (ds.flag[ds.find(x)] && de.flag[de.find(y)]) putchar('1');
		else putchar ('0');
	}
	putchar('\n');
	return 0;
}
```

---

## 作者：luanyanjia (赞：3)

样例给了我们一个很好的提示。观察样例中 $1\rightarrow 4$ 的路径，发现 $4 \rightarrow 5$ 这条边走了两遍，再结合题目描述中**不需要保证是简单路径**的提示，我们发现：

如果路径两侧分别是 `(` $\rightarrow$ `(` 和 `)` $\rightarrow$ `)` 的话，那么中间不管怎么走都可以通过左右横跳来调整成一个合法的括号序列。

总结一下是合法括号序列的条件：

- 首先起点要是 `(` ，终点要是 `)` ，且二者之间有长为偶数的路径（如果你知道并查集维护二分图的技巧，那这就很简单了）
- 能够通过 `()()()()()...` 的形式直接到达。可以使用并查集维护。
- 起点能够 `()()...` 地到达一个 `(` $\rightarrow$ `(` 的边，终点反之，也可以用并查集维护。

写一大堆并查集即可。

$upd:$ 一开始写的时候没有注意，由于图可能不连通，所以要对每一个连通块分别判一次奇环。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void rd(){}
template<typename T,typename ...U>
inline void rd(T &x,U &...args){
	char ch=getchar();
	T f=1;x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;rd(args...);
}
const int N=5e5+5;
int n,m,q,v[N];
struct Edge{
	int x,y;
}e[N];
int fa[N<<1],fa1[N],fa2[N],fa3[N];
int tag1[N],tag2[N],jh[N];
inline int fd(int *fa,int x){
	if(fa[x]==x)return x;
	return fa[x]=fd(fa,fa[x]);
}
int ans[N];
string s;
signed main(){
	rd(n,m,q);
	cin>>s;
	for(int i=0;i<n;i++){
		if(s[i]=='('){
			v[i+1]=1;
		}else v[i+1]=-1;
	}
	for(int i=1;i<=n;i++)fa1[i]=fa2[i]=fa3[i]=i;
	for(int i=1;i<=n*2;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		rd(e[i].x,e[i].y);
		int x=e[i].x,y=e[i].y;
		if(fd(fa,x)!=fd(fa,y+n))fa[fd(fa,x)]=fd(fa,y+n);
		if(fd(fa,y)!=fd(fa,x+n))fa[fd(fa,y)]=fd(fa,x+n);
		if(!(v[x]==-1&&v[y]==-1))
			if(fd(fa1,x)!=fd(fa1,y))fa1[fd(fa1,x)]=fd(fa1,y);
		if(!(v[x]==1&&v[y]==1))
			if(fd(fa2,x)!=fd(fa2,y))fa2[fd(fa2,x)]=fd(fa2,y);
		if(!(v[x]==-1&&v[y]==-1)&&!(v[x]==1&&v[y]==1))
			if(fd(fa3,x)!=fd(fa3,y))fa3[fd(fa3,x)]=fd(fa3,y);
	}
	for(int i=1;i<=m;i++){
		int x=e[i].x,y=e[i].y;
		if(fd(fa,x)==fd(fa,x+n))jh[fd(fa,x)]=1;
		if(fd(fa,y)==fd(fa,y+n))jh[fd(fa,y)]=1;
	}
	for(int i=1;i<=m;i++){
		int x=e[i].x,y=e[i].y;
		if(v[x]==1&&v[y]==1)
			tag1[fd(fa1,x)]=1;
		if(v[x]==-1&&v[y]==-1)
			tag2[fd(fa2,x)]=1;
	}
	for(int i=1;i<=q;i++){
		int x,y;rd(x,y);
		if(fd(fa,x)!=fd(fa,y)&&fd(fa,x)!=fd(fa,y+n))continue;
		if(v[x]!=1||v[y]!=-1)continue;
		if((!jh[fd(fa,x)])&&(fd(fa,x)==fd(fa,y)))continue;
		if(fd(fa3,x)==fd(fa3,y))ans[i]=1;
		else if(tag1[fd(fa1,x)]&&tag2[fd(fa2,y)])ans[i]=1;
	}
	for(int i=1;i<=q;i++)printf("%d",ans[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：ZhongYuLin (赞：3)

先对题目进行一个整体把握。先考虑树怎么做。发现如果不是**任意路径**而是**简单路径**，我们很容易使用树剖进行解决。但是问题在于，树上都需要树剖了，那图上就大概率是不可做问题。于是得出结论：**可以是普通路径是一个重要性质**。

然后观察数据范围，发现只能是 $O(n\log n)$。列举图上的算法，发现大概率是并查集。想一想发现更对了。于是考虑使用并查集解决问题。

既然题目要求是合法括号路径，则路径总长必然是偶数。对于这样的问题，我们有经典的解法：将图拆为两层，一层为奇层，表示到该点时路径长为奇数；另一层为偶层，表示到该点时路径长为偶数。我们从奇层连向偶层，偶层连向奇层，显然这是一个二分图。我们将相邻的点全部合并，就可以判断是否存在长度为偶数的路径了。

考虑充分利用题目性质。注意到如果存在 ```((``` 这样的序列，我们可以反复刷取左括号，以确保前缀的合法性；同理，如果存在 ```))``` 这样的序列，我们可以反复刷取右括号，来确保其后的正确性。而且在前往**可达**刷取处的路径上，以左括号为例，显然必然形如 ```()()...()```，否则你不可能到达，或是不必要到达。于是，你返回主路径时也是合法的。而主路径应该也形如 ```()()...()```。于是就写几个并查集维护一下能否到达刷取处就好啦！

赛时代码（删去调试）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+3;
struct Edge{
    int nxt,to;
}e[N<<1];
int head[N];
int f1[N],f2[N],f3[N],f4[N];
int s1[N],s2[N],s3[N],s4[N];
//f1判断是否有无需刷取的路径
//f2判断是否有偶数长度的路径
//f3判断起点是否能到'(('
//f4判断终点是否能到'))'
int tot,n,m,q;
string s;
void add(int u,int v){
    e[++tot]={head[u],v};
    head[u]=tot;
}
int find1(int x){return f1[x]^x?f1[x]=find1(f1[x]):x;}
int find2(int x){return f2[x]^x?f2[x]=find2(f2[x]):x;}
int find3(int x){return f3[x]^x?f3[x]=find3(f3[x]):x;}
int find4(int x){return f4[x]^x?f4[x]=find4(f4[x]):x;}
void m1(int u,int v){u=find1(u);v=find1(v);if(u^v)f1[u]=v,s1[v]|=s1[u];}
void m2(int u,int v){u=find2(u);v=find2(v);if(u^v)f2[u]=v,s2[v]|=s2[u];}
void m3(int u,int v){u=find3(u);v=find3(v);if(u^v)f3[u]=v,s3[v]|=s3[u];}
void m4(int u,int v){u=find4(u);v=find4(v);if(u^v)f4[u]=v,s4[v]|=s4[u];}
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(cin.tie(cout.tie(0)));
    cin>>n>>m>>q>>s;
    s="#"+s+s;
    for(int i=1;i<=n<<1;++i)f1[i]=f2[i]=f3[i]=f4[i]=i;
    for(int i=1;i<=m;++i){
        cin>>u>>v;
        add(u,v+n);add(u+n,v);
        add(v,u+n);add(v+n,u);
        m2(u,v+n);m2(v,u+n);
        if(s[u]!=s[v])m1(u,v+n),m1(v,u+n);
    }
    //以下两个循环敬请画图理解，口述难以讲清
    //一定看清楚是枚举到两倍！
    for(int x=1;x<=n<<1;++x){
        if(s[x]!=')')continue;
        int id=-1;
        for(int i=head[x];i;i=e[i].nxt){
            int y=e[i].to;
            if(s[y]=='('){
                if(id==-1)id=y;
                else m4(y,id);
            }else s3[find3(x)]=1,m3(x,y);
        }
    }
    for(int x=1;x<=n<<1;++x){
        if(s[x]!='(')continue;
        int id=-1;
        for(int i=head[x];i;i=e[i].nxt){
            int y=e[i].to;
            if(s[y]==')'){
                if(id==-1)id=y;
                else m3(y,id);
            }else s4[find4(x)]=1,m4(x,y);
        }
    }
    for(;q--;){
        cin>>x>>y;
        if(s[x]==')'||s[y]=='('||find2(x)!=find2(y+n)){putchar('0');continue;}
        if((s3[find3(y+n)]&&s4[find4(x)])||find1(x)==find1(y+n))putchar('1');
        else putchar('0');
    }puts("");
    return 0;
}//我永远喜欢赫默！
```

---

## 作者：CaiZi (赞：1)

以下记 $\text{L}$ 为上面为左括号的点，$\text{R}$ 为上面为右括号的点。

如果我们经过 $1$ 条 $\text{L}\to\text{L}$ 的边，那么我们可以在这条边两端反复横跳，得到任意偶数个左括号。如果我们经过 $1$ 条 $\text{R}\to\text{R}$ 的边，那么我们可以在这条边两端反复横跳，得到任意偶数个右括号。

首先 $x,y$ 分别要是左括号和右括号，且点 $x$ 和点 $y$ 在同 $1$ 个连通块内，否则一定无解。

因此当我们可以依次走完以下路径后，且拼接起来的路径经过偶数个点，一定可以得到 $1$ 个合法括号串：
- $1$ 条不经过 $\text{R}\to\text{R}$ 的边的路径（起点为点 $x$）（可以没有）。
- $1$ 条 $\text{L}\to\text{L}$ 的边。
- $1$ 条任意路径（可以没有）。
- $1$ 条 $\text{R}\to\text{R}$ 的边。
- $1$ 条不经过 $\text{L}\to\text{L}$ 的边的路径（终点为点 $y$）（可以没有）。

拼接起来的路径经过可以偶数个点，等价于点 $x$ 和点 $y$ 存在经过偶数个点的路径。

如果以上路径无法走完，说明无法在满足条件的情况下到达 $\text{L}\to\text{L}$ 的边或 $\text{R}\to\text{R}$ 的边。因此此时只能是 $1$ 个左括号后 $1$ 个右括号依次拼接。

因此当我们可以依次走完以下路径后，一定可以得到 $1$ 个合法括号串：
- $1$ 条 $x\to\text{R}$ 的边。
- $1$ 条 $\text{R}\to\text{L}$ 的边（可以没有）。
- $1$ 条 $\text{L}\to\text{R}$ 的边（可以没有）。
- 循环 $2,3$ 步骤（可以没有）。
- $1$ 条 $\text{R}\to\text{L}$ 的边（可以没有）。
- $1$ 条 $\text{L}\to y$ 的边。

如果此时还没有得到 $1$ 个合法括号串，那么一定无解。

使用拓展域并查集维护即可，你把一个点拆成 $i,i+n$ 两个点，连接 $(u,v+n)$ 和 $(u+n,v)$。然后查询 $(x,y+n)$ 是否连通，若连通，则 $x,y$ 两点间有经过偶数个点的路径。

时间复杂度 $O((n+m+q)\alpha)$。

代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,x[500001],y[500001],f1[1000001],f2[1000001],f3[500001];
string s;
bool a[1000001],b[1000001];
inline int find1(int i){
	return f1[i]==i?i:f1[i]=find1(f1[i]);
}
inline int find2(int i){
	return f2[i]==i?i:f2[i]=find2(f2[i]);
}
inline int find3(int i){
	return f3[i]==i?i:f3[i]=find3(f3[i]);
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m>>q>>s;
	s=' '+s;
	for(int i=1;i<=n;i++){
		f1[i]=f2[i]=f3[i]=i;
		f1[n+i]=f2[n+i]=n+i;
	}
	for(int i=1;i<=m;i++){
		cin>>x[i]>>y[i];
		if(s[x[i]]!=s[y[i]]){
			f1[find1(x[i])]=find1(y[i]+n);
			f1[find1(x[i]+n)]=find1(y[i]);
			f3[find3(x[i])]=find3(y[i]);
		}
		f2[find2(x[i])]=find2(y[i]+n);
		f2[find2(x[i]+n)]=find2(y[i]);
	}
	for(int i=1;i<=m;i++){
		if(s[x[i]]=='('&&s[y[i]]=='('){
			a[find3(x[i])]=a[find3(y[i])]=1;
		}
		if(s[x[i]]==')'&&s[y[i]]==')'){
			b[find3(x[i])]=b[find3(y[i])]=1;
		}
	}
	while(q--){
		cin>>x[1]>>y[1];
		if(s[x[1]]==')'||s[y[1]]=='('){
			cout<<"0";
		}
		else{
			if(find2(x[1])==find2(y[1]+n)&&a[find3(x[1])]&&b[find3(y[1])]){
				cout<<"1";
			}
			else if(find1(x[1])==find1(y[1]+n)){
				cout<<"1";
			}
			else{
				cout<<"0";
			}
		}
	}
	return 0;
}
```

---

## 作者：nkhuangyuxuan (赞：1)

给好题写一篇容易看懂的题解。  
### 输出1的所有条件：
1. $a_x=($ 并且 $a_y=)$
2. $x$ 与 $y$ 连通
3. $x$ 到 $y$ 存在长度为偶数的路径。
4. 最终序列为 $()()()()()...()$ ，即没有**相邻且相同的字符**。
5. 最终序列存在**相邻且相同的字符**：存在一条从 $x$ 出发的路径，第一对相邻且相同的字符为 $($ ，存在一条从 $y$ 出发的路径，第一对相邻且相同的字符为 $)$ 。

条件 1,2,3 必须全部满足，条件 4,5 满足一个即可。
### 具体实现：
对于条件 3：若 $x$ 所在连通块是二分图且染色法后 $color_x=color_y$，那么 $x$ 到 $y$ 只存在长度为奇数的路径。  
对于条件 4：连接相邻字符不同的边（设为图 $G$），看 $x$ 与 $y$ 是否连通。  
对于条件 5：如果在图 $G$ 上从 $x$ 可以走到一个点 $u$，且存在一条边 $u—v$ ，并且 $a_u=a_v=($，则满足条件。$y$ 同理。  
时间复杂度：$O(n+m+q)$

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500005
int n,m,q;
char a[N];
int fa[N][2];
int find(int k,int w){
	return fa[k][w]==k?k:fa[k][w]=find(fa[k][w],w);
}
bool A[N],B[N],AROOT[N],BROOT[N];
vector<int>g[N];
int color[N];
bool flag,can[N];
void dfs(int u){
	for(int i=0;i<g[u].size();i++){
		int to=g[u][i];
		if(color[to]!=-1){
			if(color[to]==color[u])flag=false;
		}
		else{
			color[to]=color[u]^1;
			dfs(to);
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	scanf("%s",a+1);
	for(int i=1;i<=n;i++){
		fa[i][0]=fa[i][1]=i;
	}
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		fa[find(u,1)][1]=find(v,1);
		g[u].push_back(v);
		g[v].push_back(u);
		if(a[u]!=a[v]){
			fa[find(u,0)][0]=find(v,0);
		}
		else{
			if(a[u]=='(')A[u]=A[v]=true;
			else B[u]=B[v]=true;
		}
	}
	memset(color,-1,sizeof(color));
	for(int i=1;i<=n;i++){
		if(find(i,1)==i){
			flag=true;
			color[i]=0;
			dfs(i);
			can[i]=flag;
		}
	}
	for(int i=1;i<=n;i++){
		if(A[i]){
			AROOT[find(i,0)]=true;
		}
		if(B[i]){
			BROOT[find(i,0)]=true;
		}
	}
	while(q--){
		int x,y;
		scanf("%d%d",&x,&y);
		if(!(a[x]=='('&&a[y]==')')){
			printf("0");
		}
		else if(find(x,1)!=find(y,1)){
			printf("0");
		}
		else if(can[find(x,1)]&&color[x]==color[y]){
			printf("0");
		}
		else{
			if((AROOT[find(x,0)]&&BROOT[find(y,0)])||(find(x,0)==find(y,0))){
				printf("1");
			}
			else printf("0");
		}
	}
	return 0;
} 
```

代码仅供参考如何实现。

### 样例提供：
1.cin
```cpp
6 5 2
()(())
1 2
2 3
3 4
1 5
5 6

1 5
1 6

```
1.cout

```cpp
10
```
检查条件 3 的判断。

2.in

```cpp
6 5 4
(((())
1 2
2 3
3 4
4 5
5 6

1 6
1 5
1 4
4 6

```
2.out

```cpp
1000
```
检查条件 1，3，5

---

## 作者：huangrenheluogu (赞：1)

考虑必要性，$s_x,s_y$ 分别是左、右括号。如果 $x,y$ 间存在 `()()...()` 的路径，必然合法。否则，必然出现两个左括号叠在一起和两个右括号叠在一起的情况，即 `...((...))...`。

考察最左的叠左括号、最右的叠右括号，要求 `()()...()((.?.))()...()()`。问好所在那一段是任意填的。另外两段必须用 `()` 填。发现左/右括号可以任意增加偶数的长度，所以如果整个串的长度是偶数，就是可行的。

判断第一行的情况，只需要对于连接 `()` 的边建并查集判断即可；判断第二种情况，就是对于 `((` 的边把端点标记一下，然后用 `()` 的边走；右括号同理。剩下的问题是是否存在长度为偶数的路径，可以维护连通块，进行二分图染色或有奇环。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
int n, m, q, u, v, qq[N], h, t, col[N];
char s[N], ans[N];
vector<int> G[N];
bool ok[N], vis[N], inq[N], od[N];
int x, y;
struct ufs{
    int fa[N];
    inline int getfa(int x){
        return fa[x] == x ? x : fa[x] = getfa(fa[x]);
    }
    inline void Merge(int x, int y){
        x = getfa(x), y = getfa(y);
        if(x == y) return ;
        fa[x] = y;
    }
    inline void init(){
        for(int i = 1; i <= n; i++) fa[i] = i;
    }
}F1, F2;
inline void init(char c){
    h = t = 0;
    for(int i = 1; i <= n; i++){
        inq[i] = 0;
        if(ok[i] && s[i] == c){
            inq[i] = 1, vis[i] = 1;
            qq[++t] = i;
        }
    }
    int x;
    while(h < t){
        h++;
        x = qq[h];
        if(s[x] == c){
            vis[x] = 1;
        }
        for(int y : G[x]) if(s[y] != s[x]){
            if(!inq[y]){
                qq[++t] = y, inq[y] = 1;
            }
        }
    }
}
int st;
inline void dfs(int x){
    // cerr << x << ' ' << col[x] << endl;
    for(int y : G[x]){
        if(~col[y]){
            if(col[y] == col[x]){
                // cerr << st << endl;
                od[st] = 1;
            }
        }
        else{
            col[y] = col[x] ^ 1;
            dfs(y);
        }
    }
}
inline bool solve(){
    if(s[x] != '(' || s[y] != ')') return 0;
    if(F1.getfa(x) != F1.getfa(y)) return 0;
    if(F2.getfa(x) == F2.getfa(y)){
        return 1;
    }
    int c = F1.getfa(x);
    if(vis[x] && vis[y] && od[c]) return 1;
    if(vis[x] && vis[y] && (col[x] ^ col[y])) return 1;
    return 0;
}
int main(){
    // freopen("data.in", "r", stdin);
    // freopen("code.out", "w", stdout);
    scanf("%d%d%d%s", &n, &m, &q, s + 1);
    F1.init(), F2.init();
    while(m--){
        scanf("%d%d", &u, &v);
        G[u].push_back(v), G[v].push_back(u);
        F1.Merge(u, v);
        if(s[u] != s[v]){
            F2.Merge(u, v);
        }
        else ok[u] = ok[v] = 1;
    }
    init('('), init(')');
    memset(col, 0xff, sizeof(col));
    for(int i = 1; i <= n; i++) if(F1.fa[i] == i){
        col[st = i] = 0;
        dfs(i);
    }
    for(int i = 1; i <= q; i++){
        scanf("%d%d", &x, &y);
        ans[i] = solve() ? '1' : '0';
    }
    printf("%s\n", ans + 1);
    return 0;
}
```

---

## 作者：快斗游鹿 (赞：1)

题目说不必保证是简单路径，这样就会出现反复横跳的情况，不好处理。

先不考虑这样的情况。只看连接 `(` 和 `)` 的边，这样的边一定构成一张二分图，此时如果 $x$ 是 `(`，$y$ 是 `)` 且 $x,y$ 在当前图上连通，那么肯定有解，路径一定形如 `()()()...`。

否则，必须要走连接两个 `(` 或两个 `)` 的边，这时又会出现奇偶性的问题，例如路径上只有两个连着的 `(`，就意味着一次来回走就会增加两个 `(`，而未配对的 `)` 数量如果是奇数，一样无解。这意味着一条路径上，我们除去所有 `()` 后，剩下的序列左右括号数量奇偶性一定要相同，且一定是以 `(` 打头，`)` 结尾，这时肯定有解，否则无解。

如何判断这个呢，首先，如果 $x,y$ 原图上就不连通，肯定无解。然后我们要对上面的二分图进行处理，处理出上面是否有点满足该点为 `(` 且连接了另一个 `(`，或该点为 `)` 且连接了另一个 `)`。这可以用来判断是否存在路径满足去掉 `()` 后以 `(` 打头，以 `)` 结尾。而奇偶性的问题，注意到最后路径长度一定是偶数，如果这个连通块中存在奇环，就一定存在这样的路径，否则这个连通块是一个二分图，需要 $x,y$ 在异侧才行。

可以使用并查集解决。

```cpp
#include<bits/stdc++.h>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>
#include <math.h>
#include <cstdio>
#define int long long
using namespace std;
const int inf=1e18;
const int N=1e6+5;
struct edge{
	int to,nxt;
}e[N<<1];
int cnt,head[N];
int n,m,q,a[N],fa[N],fb[N],fl[N],fr[N],col[N],L[N],R[N];
bool flag[N],G;
string s; 
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
int findb(int x){
	return fb[x]==x?x:fb[x]=findb(fb[x]);
}
void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void solve(int u,int v){
	add(u,v);fb[findb(u)]=findb(v);
	if(a[u]==1&&a[v]==-1)fa[find(u)]=find(v);
	if(a[u]==1&&a[v]==1)fl[u]=1;
	if(a[u]==-1&&a[v]==-1)fr[u]=1;
}
void dfs(int u,int c){
	if(col[u]&&col[u]!=c)G=1;
	if(col[u])return;
	col[u]=c;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		dfs(v,c^3);
	}
}
signed main(){
	//freopen("std.in","r",stdin);
	//ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);
	n=read();m=read();q=read();cin>>s;
	for(int i=1;i<=n;i++)fa[i]=i,fb[i]=i;
	for(int i=0;i<s.length();i++){
		if(s[i]=='(')a[i+1]=1;
		else a[i+1]=-1;
	}
	for(int i=1;i<=m;i++){
		int u,v;u=read();v=read();
		solve(u,v);
		solve(v,u);
	}
	for(int i=1;i<=n;i++)if(fb[i]==i)G=0,dfs(i,1),flag[i]=G;
	for(int i=1;i<=n;i++)L[find(i)]|=fl[i],R[find(i)]|=fr[i];
	while(q--){
		int x,y;x=read();y=read();
		//cout<<"?"<<x<<" "<<y<<" "<<findb(x)<<" "<<findb(y)<<endl; 
		if(a[x]==-1||a[y]==1||findb(x)!=findb(y))printf("%d",0);
		else if(find(x)==find(y))printf("%d",1);
		else if((flag[findb(x)]||col[x]!=col[y])&&L[find(x)]&&R[find(y)])printf("%d",1);
		else printf("%d",0);
	}
	return 0;
}
```

---

## 作者：MaxDYF (赞：0)

### 题目思路

可以发现，非简单路径意味着可以走环，那么若是有两个相邻的点都是左括号或右括号，那么就可以反复走这两个点来刷左括号或右括号。同时，合法括号序列的长度必然为偶数，也就是说两点有合法路径时，必然有一条经过点数为偶数的路径。不妨假设询问路径为从 $x$ 到 $y$，那么当满足以下三个条件时，必然存在合法路径：

1. $x$ 有与其相连的左括号（称其为 $LL$ 点对）。
2. $y$ 也有与其相连的右括号（称其为 $RR$ 点对）。
3. 且 $LL$ 点对到 $RR$ 点对有偶数长度的路径。


上面得出的结论是充分非必要条件，我们考虑怎么将其扩充为充分必要条件。我们发现，如果 $x$ 与某一 $LL$ 点对有路径，且到他们的路径之间构成的括号序列合法时，实际上等同于 $x$ 就是 $LL$ 点对的情况。对 $y$ 点也类似，所以下面只对 $x$ 分析。由于只要存在这样的 $LL$ 就可以，所以我们只需要对 $x$ 找到离他最近的的 $LL$ 点对。对于最近的 $LL$ 点对，显然只会构成 `()()...()` 这样的括号序列（否则就不是最近了）。

对于这种最简单的括号序列，我们可以对原图的部分边的基础上建立一个二分图，只对相邻的左括号和右括号之间进行连边，显然这个二分图只会存在这种最简单的括号路径。这样只要判断 $x$ 点是否和某一 $LL$ 点对在这个二分图的同一连通块里就可以了。

现在我们解决了上面的条件1、2，考虑怎么转换原来的条件3并加以解决。由于 $x$ 到 $LL$ 的路径一定是偶数， $y$ 到 $RR$ 路径也是偶数，且 $x$ 与 $y$ 在同一连通块里，那么只需判断 $x$ 到 $y$ 是否具有偶数长度的路径。这里可以运用一个小 Trick：

> 我们考虑尝试对原图的边直接构建二分图。在 $x$ 与 $y$ 在同一连通块的前提下，如果原图就是二分图，那么 $x$ 与 $y$ 存在偶数路径，当且仅当 $x$ 与 $y$ 在二分图的同一边；如果原图不是二分图，那么原图必然存在奇环，也就是必然存在偶数路径。

最后考虑一种特殊情况：$x$ 与 $y$ 之间只存在 `()()...()` 这样的路径，只要判断一下在上面的部分二分图上 $x$ 与 $y$ 是否在不同的两边且在这个二分图的同一连通块即可。

下面证明这几种情况的完备性。

如果存在一条合法路径，既不满足 $x$ 与 $y$ 能找到一条到 $LL$ 或 $RR$ 点对的路径，也不满足存在一条最简单的括号路径，那么这条路径上既不存在 `((` 和 `))`，也不存在简单的 `()`，显然只能是空串。因此不存在这样的情况，完备性得证。

### Code

```cpp
// #pragma GCC optimize("Ofast,no-stack-protector")
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;
const int inf = 1 << 30;
const long long llinf = 1ll << 60;
const double PI = acos(-1);

#define lowbit(x) (x & -x)
typedef long long ll;
typedef double db;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<db, db> pdd;
typedef pair<ll, int> pli;

int n, m, k, q;
struct Graph
{
    vector<vector<int>> to;
    Graph() {}
    vector<int> vis;
    vector<int> col;
    Graph(int n)
    {
        to = vector<vector<int>>(n);
        vis = vector<int>(n);
        col = vector<int>(n);
    }
    bool checkBipartiteGraph(int x, int blocktype = 1, int fa = 0, int nowcol = 1)
    {
        vis[x] = nowcol;
        col[x] = blocktype;
        bool isBipart = true;
        for (auto y : to[x])
        {
            if (y == fa)
                continue;
            if (!vis[y])
                isBipart &= checkBipartiteGraph(y, blocktype, y, 3 - nowcol);
            else if (vis[y] == nowcol)
                isBipart = false;
        }
        return isBipart;
    }
    void fillCol(int x, int col = 4)
    {
        vis[x] = col;
        for (auto y : to[x])
        {
            if (vis[y] == col)
                continue;
            fillCol(y, col);
        }
    }
    void add(int x, int y)
    {
        to[x].push_back(y);
    }
};
string a;
void work()
{
    cin >> n >> m >> q;
    cin >> a;
    Graph fullGraph(n), withoutCommom_Graph(n);
    for (int i = 0; i < m; i++)
    {
        int x, y;
        cin >> x >> y;
        x--;
        y--;
        if (a[x] != a[y])
        {
            withoutCommom_Graph.add(x, y);
            withoutCommom_Graph.add(y, x);
        }
        fullGraph.add(x, y);
        fullGraph.add(y, x);
    }
    int cnt1 = 0;
    for (int x = 0; x < n; x++)
    {
        if (fullGraph.vis[x] == 0)
        {
            cnt1++;
            if (fullGraph.checkBipartiteGraph(x, cnt1) == false)
                fullGraph.fillCol(x);
        }
    }
    int cnt2 = 0;
    for (int x = 0; x < n; x++)
        if (withoutCommom_Graph.vis[x] == 0)
            withoutCommom_Graph.checkBipartiteGraph(x, ++cnt2);
    vector<int> connectWithLL(n), connectWithRR(n);
    for (int x = 0; x < n; x++)
        for (auto y : fullGraph.to[x])
        {
            int blocktype = withoutCommom_Graph.col[x];
            if (a[x] == '(' && a[y] == '(')
                connectWithLL[blocktype] = 1;
            if (a[x] == ')' && a[y] == ')')
                connectWithRR[blocktype] = 1;
        }
    for (int t = 0; t < q; t++)
    {
        int x, y;
        cin >> x >> y;
        x--;
        y--;
        if (a[x] == a[y] || a[x] == ')')
        {
            cout << 0;
            continue;
        }
        int fullGraphCol_x = fullGraph.col[x], fullGraphCol_y = fullGraph.col[y];
        if (fullGraphCol_x != fullGraphCol_y)
        {
            cout << 0;
            continue;
        }
        int partGraphCol_x = withoutCommom_Graph.col[x], partGraphCol_y = withoutCommom_Graph.col[y];
        if (partGraphCol_x == partGraphCol_y)
        {
            cout << 1;
            continue;
        }
        else if (connectWithLL[partGraphCol_x] && connectWithRR[partGraphCol_y])
        {
            if (fullGraph.vis[x] != fullGraph.vis[y] || fullGraph.vis[x] == 4)
            {
                cout << 1;
                continue;
            }
            else
            {
                cout << 0;
                continue;
            }
        }
        else
        {
            cout << 0;
            continue;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    while (t-- > 0)
    {
        work();
    }
}
```

---


# [NOIP 2008 提高组] 双栈排序

## 题目描述

Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。

![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)

- 操作 $\verb!a!$：将第一个元素压入栈 $S_1$。
- 操作 $\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。
- 操作 $\verb!c!$：将第一个元素压入栈 $S_2$。
- 操作 $\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。


如果一个 $1\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\texttt {a,c,c,b,a,d,d,b}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)

当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。

## 说明/提示

$30\%$ 的数据满足：$n\le10$。

$50\%$ 的数据满足：$n\le50$。

$100\%$ 的数据满足：$n\le1000$。

2021.06.17 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。hack 数据单独分为一个 subtask 防止混淆。

noip2008 提高第四题

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
a b a a b b a b```

## 样例 #2

### 输入

```
4
2 3 4 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3
2 3 1```

### 输出

```
a c a b b d```

# 题解

## 作者：zjp_shadow (赞：132)

## 题意

给你一个长为 $n$ 的序列 $p$ ，问是否能够通过对于两个栈进行 `push, pop(print)` 操作使得最后输出序列单调递增（即为 $1 \cdots n$ ），如果无解输出 $0$ 。

每个操作有个优先级，`push(1) > pop(1) > push(2) > pop(2)` ，输出优先级最大的一组解。

$n \le 1000$

## 题解

有兴趣可以来逛逛 [我的博客](https://www.cnblogs.com/zjp-shadow/p/9831491.html)。

> 洛谷前面大部分题解，对于后面直接模拟的思路肯定是错的，本文介绍一个基于贪心的算法（不知道对不对，因为没有强数据验证）。

首先考虑只有一个栈的时候如何解决这个问题。

就是对于一对位置 $(i, j)$ 是否能共存三个位置 $i < j < k$ 存在 $p_k < p_i < p_j$ 是不可行的，因为 $p_k$ 需要在 $p_i$ 与 $p_j$ 之前出栈，但 $p_i$ 又需要在 $p_j$ 之前出栈，那么这就会产生矛盾。

我们预处理 $\displaystyle f_i = \min_{j = i}^{n} p_j$ ，就可以在 $O(n ^ 2)$ 的时间内判断一对 $i, j$ 是否可以共存了（也就是 $f_{j + 1} < p_i < p_j$ ）

然后对于存在两个栈的情况，我们就需要把 $p$ 划分成两个序列，使得这两个序列之中的数都互不冲突。

这样的话，我们对于一对不能共存的 $i, j$  连边，然后进行二分图染色。如果不可染，那么就是不存在一组合法解。

之后我们只需要解决使得最后解字典序最小的限制。

我们染色的时候 `BFS` 染色，尽量把在前面的放入第一个栈。

然后后面得到操作序列直接模拟肯定是个错的。

> 举个样例：
>
> ```
> 5
> 2 4 1 3 5
> ```
>
> 标准输出：
>
> ```
> a c a b b a b a d b 
> ```
>
> 前面大部分错误的输出：
>
> ```
> a c a b b a b d a b 
> ```

为什么呢，因为你向第二个栈 `push` 后，不一定现在拿出来 `pop` ，第一个栈中能继续 `push` 。

那么我们就贪心一下，我们在 `push` 之后不马上 `pop` ，等到需要 `pop` 的时候再 `pop` 。

哪些时候需要 `pop` 呢，就是这个栈不合法的时候需要 `pop` （也就是这个栈 栈顶到栈底 不单调递增的时候，不满足单调栈性质）

但是注意向第二个栈中 `push` 之前，因为第一个栈的 `pop` 优先级更高，我们看能不能先 `pop` 第一个栈。

这样就应该是最优的了，注意最后要把两个栈按顺序清空。

## 代码

```cpp

#include <bits/stdc++.h>

#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)
#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)
#define Set(a, v) memset(a, v, sizeof(a))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define debug(x) cout << #x << ": " << (x) << endl
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define pb push_back

using namespace std;

template<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }

inline int read() {
    int x(0), sgn(1); char ch(getchar());
    for (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;
    for (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);
    return x * sgn;
}

void File() {
#ifdef zjp_shadow
	freopen ("P1155.in", "r", stdin);
	freopen ("P1155.out", "w", stdout);
#endif
}

const int N = 1010, inf = 0x7f7f7f7f;

int n, P[N], minv[N], col[N];

int pos = 1;
stack<int> S[2];

inline void out(char ch) {
	putchar (ch); putchar (' ');
}

inline bool Pop(int id) {
	if (!S[id].empty() && S[id].top() == pos) {
		out(id ? 'd' : 'b'), S[id].pop(), ++ pos;
		return true;
	}
	return false;
}

inline void Push(int cur, int id) {
	if (id == 1) { while(Pop(0)); }
	while (!S[id].empty() && S[id].top() < cur)
		if (!Pop(id)) Pop(id ^ 1);
	if (id == 1) { while(Pop(0)); }
	S[id].push(cur); out(id ? 'c' : 'a');
}

vector<int> G[N];

int main () {

	File(); 
	n = read();

	For (i, 1, n)
		P[i] = read();

	minv[n + 1] = n + 1;
	Fordown (i, n, 1)
		minv[i] = min(minv[i + 1], P[i]);

	For (i, 1, n) For (j, i + 1, n) 
		if (minv[j + 1] < P[i] && P[i] < P[j])
			G[i].pb(j), G[j].pb(i), col[i] = col[j] = -1;

	For (i, 1, n) if (!~col[i]) {
		queue<int> Q; Q.push(i); col[i] = 0;
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			for (int v : G[u]) {
				if (~col[v] && col[v] != (col[u] ^ 1)) return puts("0"), 0;
				if (!~col[v]) Q.push(v);
				col[v] = col[u] ^ 1;
			}
		}
	}

	For (i, 1, n)
		Push(P[i], col[i]);

	bool flag = true;
	while (flag) {
		flag = false;
		while(Pop(0)) flag = true;
		while(Pop(1)) flag = true;
	}

	return 0;

}

```



---

## 作者：我是逍逍 (赞：14)

### 题意

给定一个由 $1 \sim n$ 组成的序列 $\{a_i\}$，问是否能用两个栈 $S_1,\ S_2$，运用某种出入栈方式使序列变为 $1 \sim n$ 的单增序列，输出字典序最小的操作序列。

### 算法

通过观察，我们可以发现，当 $\exists \ (x,y,z)$，满足 $x<y<z$ 且 $a_z < a_x < a_y$ 时，$a_x, a_y$ 不可能出现在同一个栈中。结论易证。

想到使用二分图匹配的方法求解：若存在上述三元组，意味着 $a_x, a_y$ 不可同栈，则在 $x,y$ 之间连无向边 $(x,y)$，代表 $x, y$ 不可同栈，恰巧符合二分图的性质。自此，建图完毕。

接下来采用二分图染色法判定二分图，即寻找图中是否存在奇环，操作为 **dfs** 匹配。此步骤为二分图处理的经典算法，略。 

若上述流程成功匹配二分图，则可根据染色结果直接得出出入栈的操作序列 $S$，但此时算法并未结束：题目要求操作序列字典序最小。通过简单分析，我们可以发现，不同栈之间的相异操作相互独立，即对于 $\forall x \in Z^+, x \in [1, len(S))$ 若满足 $S_x = c, \ S_{x+1} = b$ 或 $S_x = d, \ S_{x + 1} = a$，我们均可以交换 $(S_x, S_{x+1})$ 使字典序更小。

至此，算法结束，输出结果即可。

### 代码

```c++
#include <iostream>
#include <vector>
#include <cstdlib>
#include <stack>

using namespace std;

const int Max = 1005;

int n, cnt, a[Max], color[Max], t = 1;
vector<int> g[Max];
stack<int> s1, s2;
char s[Max << 2];

void dfs(int x, int c) {
    color[x] = c;
    for (int i = 0; i < g[x].size(); i++) {
        int y = g[x][i];
        if (!color[y])
            dfs(y, 3 - c);
        else if (color[y] == color[x]) { // 存在奇环，无解
            cout << 0 << endl;
            exit(0);
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    for (int i = n - 1, x = a[n]; i > 1; i--) {
        for (int j = 1; j < i; j++)
            if (x < a[j] && a[j] < a[i]) { // 符合条件，加边
                g[a[i]].push_back(a[j]);
                g[a[j]].push_back(a[i]);
            }
        x = min(x, a[i]);
    }

    for (int i = 1; i <= n; i++) // 二分图染色
        if (!color[a[i]])
            dfs(a[i], 1);

    for (int i = 1; i <= n; i++) { // 根据染色结果得到操作序列
    	if (color[a[i]] == 1) {
            s1.push(a[i]);
            s[++cnt] = 'a';
        } else {
            s2.push(a[i]);
            s[++cnt] = 'c';
        }
        
        while (!s1.empty() && s1.top() == t || !s2.empty() && s2.top() == t)
	        if (!s1.empty() && s1.top() == t) {
	            s1.pop();
	            s[++cnt] = 'b';
	            t++;
	        } else {
	            s2.pop();
	            s[++cnt] = 'd';
	            t++;
	        }
    }
    
    for (int i = cnt - 1; i; i--) // 微调字典序
        for (int j = i; j < cnt; j++) 
            if (s[j] == 'c' && s[j + 1] == 'b' || s[j] == 'd' && s[j + 1] == 'a')
            	swap(s[j], s[j + 1]);
            else
            	break;

    for (int i = 1; i <= cnt; i++)
        cout << s[i] << ' ';

    return 0;
}
```



---

## 作者：Xaxon (赞：13)

# 思路

我们首先考虑只有一个栈的情况，如：
```
4
1 3 4 2
```

很容易想出一个策略，当栈顶元素是要出栈的元素时，就把它出栈，否则不出栈。

我们用这个策略去模拟这组数据：

将 $1$ 入栈。

将 $1$ 出栈。

将 $3$ 入栈。

将 $4$ 入栈。

将 $2$ 入栈。

将 $2$ 出栈。

这时，我们发现，现在本应该出栈的 $3$ 却被 $4$ 堵在了里面，这是因为要把 $4$ 弹出必须先把 $3$ 弹出，而 $3$ 被 $4$ 堵在栈中无法弹出，发生了冲突。我们可以从这次模拟中总结一个经验：入栈元素一定不能比栈顶元素小。

回到本题，为了使答案的字典序最小，显然有一个贪心策略：能进行 $a$ 操作就进行 $a$ 操作，否则能进行 $b$ 操作就进行 $b$ 操作，否则能进行 $c$ 操作就进行 $c$ 操作，否则能进行 $d$ 操作就进行 $d$ 操作，否则这个序列就不是 ”可双栈排序排列”。

所以，我们尽量要把当前元素放进 $S1$ 里，但要满足以下两点：

当前元素小于 $S1$ 的栈顶元素。

最重要，也是最难的一点。当 $S1$ , $S2$ 都可以放时，有可能放入 $S1$ 会导致后面的元素出栈时发生冲突，所以当这种情况出现时，就不要把元素放进 $S1$ 里。怎么判断把当前元素放进 $S1$ 里后面的元素会发生冲突呢？我们通过之前的模拟知道一个元素入栈的一个条件是要小于栈顶元素，这样我们去查找当前元素的后面是否存在一个比它大，并且比 $S2$ 的栈顶元素大的元素（这样它就放不了），如果有，那么判断它（必须第一个）后面是否有比当前元素小且比 $S2$  栈顶元素小的数（这样它们就出不了栈）。如果有，就说明把当前元素放进 $S1$ 中后面元素会发生冲突。

### check 函数：

```cpp
bool check (int pos)
{
    int now_ = now;
    while (!te && tt == now_ ++)
    {
        w.push (tt), t.pop ();
    }
    #define end while (!w.empty ()) t.push (w.top ()), w.pop ();
    if (te)
    {
        end;
        return 1;
    }
    for (int i = pos + 1; i <= n; i ++)
    {
        if (a[i] < a[pos] || a[i] < tt)
        {
            continue;
        }
        for (int j = i + 1; j <= n; j ++)
        {
            if (a[j] < a[pos] && a[j] < tt)
            {
                end;
                return 0;
            }
        }
        break;
    }
    end;
    return 1;
}
```

## AC Code
```cpp
#include<bits/stdc++.h>
#include <cstdio>
#include <stack>
#define N 1005
using namespace std;

int n, pos = 1, now = 1, cnt, a[N], out[N * 2];
stack <int> s, t, w;

#define st (s.top ())
#define tt (t.top ())
#define se (s.empty ())
#define te (t.empty ())

bool check (int pos)
{
    int now_ = now;
    while (!te && tt == now_ ++)
    {
        w.push (tt), t.pop ();
    }
    #define end while (!w.empty ()) t.push (w.top ()), w.pop ();
    if (te)
    {
        end;
        return 1;
    }
    for (int i = pos + 1; i <= n; i ++)
    {
        if (a[i] < a[pos] || a[i] < tt)
        {
            continue;
        }
        for (int j = i + 1; j <= n; j ++)
        {
            if (a[j] < a[pos] && a[j] < tt)
            {
                end;
                return 0;
            }
        }
        break;
    }
    end;
    return 1;
}

int main ()
{
    scanf ("%d", &n);
    for (int i = 1; i <= n; i ++)
    {
        scanf ("%d", &a[i]);
    }
    for (int i = 1; i <= n * 2; i ++)
    {
        if (pos <= n && (se || a[pos] < st) && check (pos))
        {
            s.push (a[pos ++]), out[++ cnt] = 0;
        }
        else if (!se && st == now)
        {
            s.pop (), out[++ cnt] = 1, now ++;
        }
        else if (pos <= n && (te || a[pos] < tt))
        {
            t.push (a[pos ++]), out[++ cnt] = 2;
        }
        else if (!te && tt == now)
        {
            t.pop (), out[++ cnt] = 3, now ++;
        }
        else
        {
            putchar ('0');
            return 0;
        }
    }
    for (int i = 1; i <= n * 2; i ++)
    {
        putchar ('a' + out[i]), putchar (' ');
    }
    return 0;
}
```

---

## 作者：Comentropy (赞：10)

~~真是一道毒瘤题。~~

------------

如果你想要让代码可读性更强，让思路显示更清晰，可以参考鄙人的写法。

## 分析

### Part 1
对于一个栈来说，若对于可排序列，其出栈顺序为升序，则栈中元素必定时刻保持降序（若出现特例，则考虑出栈）。

即，如果只有一个栈，则整个操作顺序是固定的：
- 从前往后遍历每个数，每次先将当前数压入栈中，如果后面的所有数均比栈顶元素大，则将栈顶弹出，否则栈顶不能被弹出。

进一步分析，将该性质移用到双栈上。
- **性质1**：$a_i$，$a_j$ 不归属于同一个栈，等价于：$\exists i<j<k$，使得 $a_k<a_i<a_j$。

这是一个很强的性质，以下为简述证明：

------------

- 必要性：若存在这样的 $k$，则使得 $a_k$ 一定比 $a_i$，$a_j$ 先出栈，即在对 $a_k$ 操作前，$a_i$，$a_j$ 都不能弹出，否则出栈序列中将出现逆序对。这导致 $a_i$，$a_j$ **同时** 在栈中。此时不论如何出栈都会出现逆序对，不合题意，故 $a_i$，$a_j$ 不归属于同一个栈。

- 充分性：可以转化为以下问题：若不存在这样的 $k$，$a_i$，$a_j$ 可以归属于同一个栈。这是显然的，因为为了保证栈的单调性，所有小于 $a_j$ 的数已经出栈了（后面没有更小的数了，因此可以正常出栈）；所有大于 $a_j$ 的数仍在栈底处。操作可以正确进行。

------------

### Part 2
这一部分主要是讲解输出时字典序最小的问题，有点绕。
得到了上一部分的性质，则能得到每个数之间的关系，要将它们分到两个栈中，正是二分图判定问题。跑一遍染色法求解二分图即可。注意从此开始与字典序有关，尽可能先进 ```stk1```，染色时优先染 $0$（$0$ 是在 ```stk1``` 中的标志）。

之后出栈判断可以概括为：要出 ```stk1``` 就出，尽可能晚出 ```stk2``` 的元素。详细步骤如下：

1. 对于 $col=0$ 的元素，即要入 ```stk1``` 的元素，先对 ```stk1``` 进行检索、弹出（因为要进栈了，保证单调性）。然后如果此时 ```stk1``` 没有弹干净（没弹干净的原因见注释中对 ```popall``` 操作的说明），且 $stk1_{top}<a_i$，即，将要出现升序时，进行 ```popall``` 操作，清理掉比 $a_i$ 小的所有元素。特例：见 ```popall``` 操作的说明。

2. 对于 $col=1$ 的元素，即要入 ```stk2``` 的元素，不要有顾虑，进行 ```popall``` 操作再进栈即可。原理是先弹 ```stk1``` 比先入 ```stk2``` 更优。

- **注：** ```popall``` 指的是弹出所有可以弹的元素，其中遵循先弹 ```stk1```，尽可能不弹 ```stk2``` 的规则。我们维护一个 $now$ 来指出当前需弹的元素（序列是一个 $[1,n]$ 的排列）。若当入要向 ```stk1``` 中压入 $a_i$ 时，扫到 $stk2_{top} = now= a_i-1$，则可以等待入栈后再进行弹栈，直接退出即可。 

## Code
附几组关于 Part2 常见错误的数据。

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<stack>
#include<algorithm>
using namespace std;
const int N=1050;
int n;
int a[N],f[N],col[N];
vector<int> e[N];
stack<int> stk1,stk2;
bool dfs(int u,int c){
    col[u]=c;
    for(int i:e[u]){
        if(col[i]==c)   return false;
        if(col[i]==-1 && !dfs(i,!c))    return false;
    }
    return true;
}
int now=1;
void popall(int lim){
    while(true){
        if(stk1.size()&&stk1.top()==now){
            stk1.pop();
            printf("b ");
            now++;
        }else if(stk2.size()&&stk2.top()==now){
            if(now==lim-1)
                break ;
            stk2.pop();
            printf("d ");
            now++;
        }else{
            // if(stk2.size())
            //     printf("\nstk=%d\n",stk2.top());
            break ;
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    f[n+1]=n+1;
    for(int i=n;i>=1;i--)
        f[i]=min(f[i+1],a[i]);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            if(a[i]<a[j]&&f[j+1]<a[i])
                e[i].push_back(j),e[j].push_back(i);
    memset(col,-1,sizeof(col));
    for(int i=1;i<=n;i++){
        if(col[i]==-1&&!dfs(i,0)){
            printf("0");
            return 0;
        }
    }
    for(int i=1;i<=n;i++){
        if(col[i]==0){
            // 字典序问题：第一个必须出 第二个栈可以等。
            int flag=0;
            // printf("\ni=%d now=%d\n", i,now);
            while(stk1.size()&&stk1.top()==now){
                stk1.pop();
                printf("b ");
                now++,flag=1;
            }
            // printf("\ni=%d now=%d flag=%d\n",i,now,flag);
            if(stk1.size()&&stk1.top()<a[i])
                popall(a[i]);
            stk1.push(a[i]);
            printf("a ");
        }else{
            popall(0);
            stk2.push(a[i]);
            // printf("\nnew_ele=%d\n",stk2.top());
            printf("c ");
        }
    }
    popall(0);
    return 0;
}

/*
test1:
6
2 3 1 4 5 6
output: a c a b b a d b a b a b
BUG:    a c a b b a a a d 

test2:
8
1 3 4 2 7 5 8 6
output: a b a c a b b a a d b c a b b d
BUG:    a b a c a b b a d a b c a b b d 

test3:
10
10 7 8 6 3 5 4 2 1 9
ANS:    a a c a a c c a a b b b d d b b a d b b
BUG:    a a c a a c c a a b b b a d d 
*/
```



---

## 作者：六楼溜刘 (赞：5)

# 核心思路：模拟+贪心
~~我居然敢在一道已经有数十篇高质量题解的题下交题解了，真是不可理喻~~，那必然是有原因的，由于我做这道题的时候不会二分图（其实现在也不会），不太看得懂题解，就自己写了个贪心，过了 Subtask #0，但是 Subtask #1 的第二个点 WA 掉了。后来推倒重写后过了 Subtask #1，又看了一眼题解发现没有一个用的是模拟+贪心的，于是我就膨胀了。

**Update 2023.3.17 修改了变量名不统一的问题。**

**Update 2023.3.30 改了些笔误。**

### 正文
题意不多赘述。

我的思路是从前往后考虑排列中的每个元素，每放入一个元素，将能出栈的元素全部出栈。

在（只考虑两栈栈顶元素和当前考虑的元素时）只能放 $S_1$ 或者放 $S_1$ 必然更优时放 $S_1$，只能放 $S_2$ 时放 $S_2$，其余情况有些复杂，后文再讲。

由于最后要使输出序列升序排列，我们可以得到以下推论。

记当前考虑的元素为 $x$，只能放 $S_1$ 的情况有：
- $S_1$ 为空（由后文的其他决策可知此时必然 $S_2$ 也为空，放 $S_1$ 更优）。
- $S_2$ 的栈顶小于 $x$ 并且 $S_1$ 的栈顶大于 $x$。（不能放 $S_2$）

如果 $S_1$ 的栈顶小于 $x$，只能放 $S_2$ 的情况有：
- $S_2$ 为空（此时如果不放 $S_2$ 就无法继续）。
- $S_2$ 的栈顶大于 $x$（同上）。
- 如果不满足以上两种情况，且 $S_1$ 的栈顶小于 $x$，说明这个排列不是“可双栈排序排列”。

容易发现以上几种情况是没有交集的，排除以上五种情况，剩下的就是 $S_1,S_2$ 都能选的情况了。

对于剩余情况，我们先考虑可以贪心解决的部分。
- $x$ 放入后，立马可以出栈（可以记录已经出栈的最大元素 $K$，然后贪心解决），为保证字典序应该选 $S_1$。

对于其余情况，我们先思考一个问题：**当我们把整个排列（或一部分）放入栈中后，如果要让栈中的元素一次性弹出后升序排列，栈中元素应满足什么性质。**（其实我原来的代码就因为没处理这一部分被 hack 了）。

如果只有一个栈，那它只需要简单从栈底到栈顶降序排列。

对于两个栈，我们发现若将其分成多个最长的连续区间，这些区间中的元素是连续的，并且降序排列。**如果两个栈中所有这样的区间首尾相连是一个连续的降序排列，那么栈中的元素就可以完成一个升序的出栈序列。**（其实接起来就相当于只有一个栈的情况）

有点难懂？举个例子（右侧为栈顶）。

（每一个代码块代表一个上文指的“最长连续区间”）

比如这种情况就可以：
- $S_1$:`9876` `3` `1`
- $S_2$:`54` `2`

这种就不行：
- $S_1$:`9876` `3` `1`
- $S_2$:`4` `2` 

有了这个推论，我们就可以再贪心地解决两种情况：
- $S_1$ 的栈顶等于 $x+1$。
- $S_2$ 的栈顶等于 $x+1$。

排除上述情况后，剩余情况应具备以下性质（如果不知道为什么去对照上文）：
- $S_1$ 非空。
- $x$ 小于 $S_1$ 的栈顶。
- $S_2$ 为空，或 $x$ 小于 $S_2$ 的栈顶。
- 已出栈最大元素 $K$（下文也会用 $K$ 表示）必定小于 $x$。
- 必定没有考虑过任何大于 $K$ 且小于 $x$ 的元素（不然它们已经出栈，或者判定为“不可双栈排序序列”了）。

这些情况中，为保证字典序最小，我们仍贪心地考虑能选 $S_1$ 就选 $S_1$。


- 若 $S_2$ 为空，选 $S_1$（这个策略我证了巨久）。
	1. 若在 $S_1$ 栈顶元素弹出前，$x$ 之后有某个元素比 $S_1$ 的栈顶大，那么它也比 $x$ 大，我们又把 $x$ 放在了 $S_2$ 中，那么就可能会让本来有解的情况变成无解
   1. 若在 $S_1$ 栈顶元素弹出前，$x$ 之后所有元素都小于 $S_1$ 的栈顶，那么后续元素要么就可以满足前文提到的性质，要么就可以单独判错，无论怎样此时选 $S_1$ 都不会影响最终是否有解，选 $S_1$。
- 若 $S_2$ 不为空（以下情况先说处理和证明，后文讲实现）：
	- 若到 $S_1$ 栈顶弹出前存在某个数大于 $S_2$ 的栈顶，选 $S_1$。
    	- 显然，如果此时选了 $S_1$ 就有可能使某一个小于 $S_1$ 但大于 $S_2$ 栈顶的数无法入栈，可能会使有解的情况变得无解，同理应选 $S_2$。
   - 其余情况就是选 $S_1$ 不会影响可解性的，为保证字典序应选 $S_1$。

对于如何实现，我们发现 $S_1$ 的栈顶会在处理到 $K+1$ 时或者处理到 $S_1$ 栈顶减一时弹出，我们把这俩位置取个 `max`，把从 $x$ 到这里的这一段遍历一遍，用一个桶存一下，后面判断时遍历以下这个桶就好了。

每个点考虑一遍，考虑一个点最多需要计算 $n$ 次，总复杂度 $O(n^2)$，并且实际情况应该会远小于 $O(n^2)$。

最后注意一下，由于在答案序列中，相邻的`a`和`d`可以随意交换位置（ $S_1$ 何时入栈和 $S_2$ 何时出栈并不会互相影响）,`b`和`c`同理，我们可以跑一遍类似于冒泡排序的东西使它变得更优。
### code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<string.h>
using namespace std;
const int N=1005;
int n,K=1,a[N],ka,adr[N];
//需要注意，代码里的 K 和题解里的 K 意义不完全相同。
//这里的 K 指下一个将会出栈的元素
bool vis[N];
stack<int> S1,S2;
char ans[N<<1];
bool gg(int x,int y){
	for(int i=x;i<=y;i++){
		if(!vis[i]) return false;
	}
	return true;
}
bool chk(int x){//返回 true 放 S1，返回 false 放 S2。
	if(S2.empty()) return true;//情况一
	memset(vis,0,sizeof(vis));
	for(int i=adr[x];i<=max(adr[S1.top()-1],adr[K]);i++){
		vis[a[i]]=true;
	}
	if(gg(S2.top()+1,n)) return false;//情况2
 	return true;//情况3
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		adr[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		if(S1.empty()||(!S2.empty()&&S2.top()<a[i]&&S1.top()>a[i])){//只能选 S1。
			S1.push(a[i]);
			ans[ka++]='a';
		}else if(!S1.empty()&&S1.top()<a[i]){//不能选 S1。
			if(S2.empty()){
				S2.push(a[i]);
				ans[ka++]='c';
			}else if(S2.top()>a[i]){
				S2.push(a[i]);
				ans[ka++]='c';
			}else{//都不能选
				return printf("0"),0;
			}
		}else{
			if(a[i]==K){//可以立马出栈
				S1.push(a[i]);
				ans[ka++]='a';
			}else if(a[i]==S1.top()-1){//可以接在 S1 上。
				S1.push(a[i]);
				ans[ka++]='a';
			}else if(!S2.empty()&&a[i]==S2.top()-1){//可以接在 S2 上。
				S2.push(a[i]);
				ans[ka++]='c';
			}else{// 复杂情况
				if(chk(a[i])){
					S1.push(a[i]);
					ans[ka++]='a';
				}else{
					S2.push(a[i]);
					ans[ka++]='c';
				}
			}
		}
		while((!S1.empty()&&S1.top()==K)||(!S2.empty()&&S2.top()==K)){//出栈
			if(!S1.empty()&&S1.top()==K){
				ans[ka++]='b';
				S1.pop();
				K++;
			}else if(!S2.empty()&&S2.top()==K){
				ans[ka++]='d';
				S2.pop();
				K++;
			}
		}
	}
	for(int i=0;i<(n<<1);i++){//处理顺序问题
		for(int j=0;j<(n<<1);j++){
			if(ans[j]=='d'&&ans[j+1]=='a'){
				swap(ans[j],ans[j+1]);
			}
			if(ans[j]=='c'&&ans[j+1]=='b'){
				swap(ans[j],ans[j+1]);
			}
		}
	}
	for(int i=0;i<(n<<1);i++){
		printf("%c ",ans[i]);
	}
	return 0;
}

```


---

## 作者：Coros_Trusds (赞：2)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16388761.html)

$\mathcal{O(n^3)}$ 竟然过了，认真卡可能卡得掉。

update: 已经优化成 $\mathcal{O(n^2)}$ 的了。

# 题目大意

有一个长度为 $n$ 的序列（是 $1\sim n$ 的排列），现在有 $2$ 个栈 $S_1$，$S_2$，还有 $4$ 个操作：

+ 操作 $a$：如果输入序列不为空，将第一个元素压入栈 $S_1$。

+ 操作 $b$：如果栈 $S_1$ 不为空，将 $S_1$ 栈顶元素弹出至输出序列。

+ 操作 $c$：如果输入序列不为空，将第一个元素压入栈 $S_2$。

+ 操作 $d$：如果栈 $S_2$ 不为空，将 $S_2$ 栈顶元素弹出至输出序列。

判断是否能使得输出序列升序排序， 若不能，则输出 $0$；若能，则输出字典序最小的操作序列。

$1\le n\le 1000$。

# 题目分析

### 如何判断输入序列 $a$ 是否有解：

结论：当 $a_k\lt a_i\lt a_j$ 且 $i\lt j\lt k$ 时 $i,j$ 不在同一个栈中。

证明：

反证法，如果 $i,j,k$ 在一个栈中，因为 $a_i\lt a_j$，所以 $i$ 要比 $j$ 先出栈，又因为 $a_k\lt a_i$，所以 $k$ 比 $i$ 先出栈。那么离谱的事情就来了，$k$ 要入栈的话 $i,j$ 必须先入栈，但 $i\lt j$，故也就会导致 $j$ 比 $i$ 先出栈。这与前面的“所以 $i$ 要比 $j$ 先出栈”相悖，所以结论成立。

-------

故如果 $i,j$ 不能在同一个栈中，则连边 $(i,j)$，最后可以连出一个图。我们使用染色法判断这个图是否为二分图，试过不是则无解。染色时，左部点全部标记上 $1$，右部点全部标记上 $2$。

-------

### 如何输出任意一组可行解：

依次将每个数压入它的编号所代表的的栈（即染色时的标记），出栈入栈时保证编号连续即可。具体地，用 $id$ 表示当前应该输出的数字，找一找 $id$ 在哪个栈并在对应的栈出栈。

### 如何保证输出的可行解字典序最小

向 $S_2$ 入栈时，先尽可能从 $S_1$ 出栈。总的来说，尽可能操作 $S_1$。

# 代码

```cpp
// Problem: P1155 [NOIP2008 提高组] 双栈排序
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1155
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Date:2022-06-18 15:42
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#include <stack>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getc();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getc();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getc();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f;
const int N = 1005;
struct Graph {
	int v,nxt;
} gra[N * N << 1];
int head[N],col[N],a[N],suc[N];
std::stack<int>st[3];
int n,idx,now;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool make_color(int now,int color) {
	col[now] = color;
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (!col[v]) {
			if (!make_color(v,3 - color)) return false;
		} else if (col[v] == color) {
			return false;
		}
	}
	return true;
}
inline bool check(int x) {
	return !st[x].empty() && st[x].top() == now + 1;
}
inline void out(int x) {
	now ++;
	st[x].pop();
	if (x == 1) printf("b ");
	else printf("d ");
}
int main(void) {
	n = read();
	for (register int i = 1;i <= n; ++ i) a[i] = read();
	suc[n] = a[n];
	for (register int i = n - 1;i >= 1; -- i) suc[i] = std::min(suc[i + 1],a[i]);
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = i + 1;j < n; ++ j) {
			if (suc[j + 1] < a[i] && a[i] < a[j]) {
				add(i,j),add(j,i);
			}
		}
	}
	for (register int i = 1;i <= n; ++ i) {
		if (col[i]) continue;
		if (!make_color(i,1)) {
			puts("0");
			return 0;
		}
	}
	for (register int i = 1;i <= n; ++ i) {
		if (col[i] == 2) {
			while (check(1)) out(1);
		}
		while (!st[col[i]].empty() && st[col[i]].top() < a[i]) {
			if (check(col[i])) out(col[i]);
			else out(3 - col[i]);
		}
		if (col[i] == 2) {
			while (check(1)) out(1);
		}
		st[col[i]].push(a[i]);
		if (col[i] == 1) printf("a ");
		else printf("c ");
	}
	while (!st[1].empty()) {
		if (check(1)) out(1);
		else out(2);
	}
	while (!st[2].empty()) out(2);
	
	return 0;
}
```

---

## 作者：meifan666 (赞：1)

### 题目大意
给出
$n$
个正整数的排列，问是否能够通过两个栈的进栈或出栈，实现出栈序列的单调递增，若可以给出字典序最小的方案。
### 思路
我们通过模拟可以得知：

第一：若一个数一直在一个栈里，则后来的数要想要进入这个栈，就必须比它小，除非这个数已然出栈。

第二：若想达到最优解，第一个元素必然放在第一个栈。

我看到这题的第一反应就是贪心：对于每个数，如果在上述条件的制约下还能放入第一个栈中，那么就直接将它放在第一个栈；如果不行，就尝试第二个栈；若还不行，则无解。于是我们就可以写出这样的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a,cnt=1;
bool flag;
stack<int>p1,p2;
queue<char>out;
signed main(){
	cin>>n;
	while(n--){
		cin>>a;
		if(p1.empty()||p1.top()>a){
			out.push('a');
			p1.push(a);
		}else if(p2.empty()||p2.top()>a){
			out.push('c');
			p2.push(a);
		}else{
			cout<<0;
			return 0;
		}
		flag=1;
		while(flag){
			flag=0;
			if(!p1.empty()&&p1.top()==cnt){
				++cnt,flag=1;
				out.push('b');
				p1.pop();
			}
			if(!p2.empty()&&p2.top()==cnt){
				++cnt,flag=1;
				out.push('d');
				p2.pop();
			}
		}
	}
	while(!out.empty()){
		cout<<out.front()<<' ';
		out.pop();
	}
	return 0;
}
```
毫无疑问地错了，仅有
$30$
分。原因在于这样的贪心只考虑前面的数对它的制约，而无视它对后面的数的制约。

举个例子：

```cpp
7
5 7 2 4 1 6 3
```
代码输出无解，但这个序列是有解的，关键在于把
$2$
放在第二个栈而非贪心的第一个。

我们再广度思考一下：对于任何一个元素，它前面比它大的数，必然还未出栈，那么它们必然受上面规则的制约。而前面比它小的数，有可能已经出栈了，故我们先不拿上述规则制约。

那么这个规则（若一个数一直在一个栈里，则后来的数要想要进入这个栈，就必须比它小，除非这个数已然出栈）该怎么用呢？我们可以用二分图染色的思想，将两种栈抽象成二分图的左右部点，若有两个元素互相被制约，则给它们连边，表示它们不能在同一个栈中。连好边后，在用染色法时若出现染色失败，则代表无解。

按照这个想法，我们可以在每个数前面的序列中，判断任意比它大的两个数是否有制约关系并判断是否连边。

但是如果朴素地判断，时间复杂度还是
$O(n^3)$，不可接受。于是我们可以作个优化：如果某些点发现它们肯定已经连接了，则直接全部跳过（这个判断方式难以简单描述，只能代码中体现了）。这样，我们就将这个步骤的时间复杂度降为
$O(n^2)$
了。

染完色后，我们就从前往后遍历。若与它染色的点被遍历过了，则它进的栈的种类显然；否则，它就在第一个栈里。

最后要注意的是各个操作的字典序，经调整细节我们就能通过了。

下面贴上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1010],las=1;
int col[1010],cnt=1;
bool vis[1010];
struct step{
	int val,id;
}st[1010];
bool cmp(step x,step y){
	return x.val<y.val;
}
vector<int>p[1010];
stack<int>s1,s2;
bool give_color(int x){
	vis[x]=1;
	for(int i=0;i<p[x].size();i++){
		int y=p[x][i];
		if(col[y]==col[x])return 0;
		col[y]=1-col[x];
		if(!vis[y])give_color(y);
	}
	return 1;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		st[i].id=i,st[i].val=a[i];
	}
	sort(st+1,st+1+n,cmp);
	for(int l=1;l<=n;l++){
		int i=st[l].id;
		for(int j=i-1;j>=las;j--){//las就是优化
			for(int k=j-1;k>=0;k--){
				if(a[j]<a[i]||a[k]<a[i])continue;
				if(a[k]<a[j]){
					p[j].push_back(k);
					p[k].push_back(j);
				}
			}
		}
		las=i;
	}
	memset(col,-1,sizeof(col));
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			col[i]=1;
			if(!give_color(i)){
				cout<<0;
				return 0;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(col[i]==1){
			s1.push(a[i]);
			cout<<"a"<<' ';
		}
		if(col[i]==0){
			s2.push(a[i]);
			cout<<"c"<<' ';
		}
		bool flag=1;
		while(flag){
			flag=0;
			if(i<=n&&col[i+1]==1&&(s1.empty()||s1.top()>a[i+1]))
				break;
			if(!s1.empty()&&s1.top()==cnt){
				s1.pop();
				++cnt,flag=1;
				cout<<"b"<<' ';
			}
			if(i<=n&&col[i+1]==1&&(s1.empty()||s1.top()>a[i+1]))
				break;
			if(!s2.empty()&&s2.top()==cnt){
				s2.pop();
				++cnt,flag=1;
				cout<<"d"<<' ';
			}
		}
	}
	return 0;
}
```
~~不得不说，确实毒瘤。~~

---

## 作者：wanglecun (赞：1)

**Solution**

先考虑如何判掉不合法的情况，对于一个数，如果它前面有一个数比他大，那他们不能在同一个栈里，我们可以在它们之间连一条边，那么连出来的这张图如果有奇环，就是不合法的。

再考虑对于一个合法解，如何是答案字典序最小。

我们对于一个联通块内让编号最小的点进一号栈，那么所有元素进入栈的编号就确定了，接下来按照题意模拟，有能弹出的元素就弹出。

但这样为什么能保证字典序最小？

考虑当二号栈有元素需要弹出，下一个元素要进一号栈，那么我们应该先让一号进入，二号弹出，我们的做法就出锅了。

所以要加特判。

**代码**
```cpp
#include <bits/stdc++.h>

#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)
#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)
#define Set(a, v) memset(a, v, sizeof(a))
#define Cpy(a, b) memcpy(a, b, sizeof(a))
#define debug(x) cout << #x << ": " << (x) << endl
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define pb push_back

using namespace std;

template<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }

inline int read() {
    int x(0), sgn(1); char ch(getchar());
    for (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;
    for (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);
    return x * sgn;
}

void File() {
#ifdef zjp_shadow
	freopen ("P1155.in", "r", stdin);
	freopen ("P1155.out", "w", stdout);
#endif
}

const int N = 1010, inf = 0x7f7f7f7f;

int n, P[N], minv[N], col[N];

int pos = 1;
stack<int> S[2];

inline void out(char ch) {
	putchar (ch); putchar (' ');
}

inline bool Pop(int id) {
	if (!S[id].empty() && S[id].top() == pos) {
		out(id ? 'd' : 'b'), S[id].pop(), ++ pos;
		return true;
	}
	return false;
}

inline void Push(int cur, int id) {
	if (id == 1) { while(Pop(0)); }
	while (!S[id].empty() && S[id].top() < cur)
		if (!Pop(id)) Pop(id ^ 1);
	if (id == 1) { while(Pop(0)); }
	S[id].push(cur); out(id ? 'c' : 'a');
}

vector<int> G[N];

int main () {

	File(); 
	n = read();

	For (i, 1, n)
		P[i] = read();

	minv[n + 1] = n + 1;
	Fordown (i, n, 1)
		minv[i] = min(minv[i + 1], P[i]);

	For (i, 1, n) For (j, i + 1, n) 
		if (minv[j + 1] < P[i] && P[i] < P[j])
			G[i].pb(j), G[j].pb(i), col[i] = col[j] = -1;

	For (i, 1, n) if (!~col[i]) {
		queue<int> Q; Q.push(i); col[i] = 0;
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			for (int v : G[u]) {
				if (~col[v] && col[v] != (col[u] ^ 1)) return puts("0"), 0;
				if (!~col[v]) Q.push(v);
				col[v] = col[u] ^ 1;
			}
		}
	}

	For (i, 1, n)
		Push(P[i], col[i]);

	bool flag = true;
	while (flag) {
		flag = false;
		while(Pop(0)) flag = true;
		while(Pop(1)) flag = true;
	}

	return 0;

}

```

---

## 作者：xcrr (赞：1)

让我们考虑，如果告诉每个数如果进入哪个栈，那么通过模拟就能确定序列

解释：当每个元素进哪个栈确定时，不确定的只有某个元素进一个栈，和另一个栈弹出元素的顺序。

这种情况，因为要求字典序最小，而 $a$ 栈的所有操作的字典序都小于 $b$ 栈，我们每次有元素进 $b$ 栈前先尽可能把 $a$ 栈能弹出的先弹出。

这样，我们知道，**只要确定每个数进入哪个栈，问题就解决了！**

怎么确定呢？？

也就是确定哪些元素无论是否同时在栈内，都不能进入同一个栈。即，找到所有 $i$ 元素选择进入 $a$ 栈，那么 $j$ 元素只能进入 $b$ 栈的情况。

如果有一个顺序靠前的元素，和一个顺序靠后的元素，前者大于后者，前者和后者可以进入同一个栈，即前面的元素进入没有弹出时，后面的元素进入。

如果有一个顺序靠前的元素 $i$，和一个顺序靠后的元素 $j$，前者大小小于后者：

*提醒：这里 $i,j$ 指下标*

1.前者和后者可以进入同一个栈，即前面的元素 $i$ 进入后弹出了，后面的元素 $j$ 再进入，前提是 $i$ 可以做到在 $j$ 加入前弹出。

2.什么时候前提不成立？在 $j$ 的后面还有个元素，比 $i$ 元素的大小还要小，那 $i$ 在 $j$ 加入前就没办法弹出，如果弹出了 $(a_i>a_k)$ 就不是升序，那 $j$ 就不能和 $i$ 进入同一个栈。

通过后缀最小值处理这个复杂度在 $O(n^2)$

谁和谁矛盾判断出来了，那么矛盾的每一对进行建边，跑二分图染色，如果能成功染色，就是一个可行方案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int N=1010;
vector<int>G[N];
int a[N],sa[N];
int col[N];//1 进a 2 进b
vector<int>stuc[3];//栈。手写或者用 stack 也行，不过我没用习惯。
bool dfs(int x,int c)
{
	col[x]=c;
	for(int i=0;i<G[x].size();i++)
	{
		int j=G[x][i];
		if(col[j]==c)return 0;
		if(col[j]==0)
		if(!dfs(j,c%2+1))return 0;
	}
	return 1;
}
inline void solve(){
	cin>>n;
	sa[n+1]=114514;//任意大于 1000 的数
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=n;i>=1;i--)
		sa[i]=min(sa[i+1],a[i]);
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
		if(a[i]<a[j]&&sa[j]<a[i])
			G[i].push_back(j),G[j].push_back(i);
	for(int i=1;i<=n;i++)
	if((!col[i])&&(!dfs(i,1))){cout<<0<<endl;return;}
	//给没染过的每个点跑染色
	//下面，进行模拟
	int s=1;//辅助变量，表示已经弹出了值为 [1,s) 的数，即该弹 s 了
	for(int i=1;i<=n;i++)
	{
		int t=col[i];
		while(stuc[t].size()&&*(stuc[t].end()-1)<a[i])//*(stuc[t].end()-1) 表示取尾元素的值
			if(*(stuc[1].end()-1)==s)
				stuc[1].pop_back(),cout<<"b ",s++;
			else stuc[2].pop_back(),cout<<"d ",s++;
		if(t==2)
			while(stuc[1].size()&&*(stuc[1].end()-1)==s)
				stuc[1].pop_back(),cout<<"b ",s++;
		stuc[t].push_back(a[i]),
		cout<<(t==1?"a ":"c ");
	}
	while(s<=n)
	{
		while(stuc[1].size()&&*(stuc[1].end()-1)==s)
			stuc[1].pop_back(),cout<<"b ",s++;
		while(stuc[2].size()&&*(stuc[2].end()-1)==s)
			stuc[2].pop_back(),cout<<"d ",s++;
	}
}

int main()
{
	solve();
	const int _=0;
	return ~~(0^_^0);
}
```

---

## 作者：快斗游鹿 (赞：1)

## 思路

先考虑怎么判无解。如果数列中存在三个数 $i,j,k$，满足 $i<j<k$ 且 $a_k<a_i<a_j$，就意味着 $a_i,a_j$ 不可能出现在同一个栈内。因为 $a_j$ 得比 $a_k$ 先出栈，$a_i$ 又得比 $a_j$ 先出栈。所以我们对每组矛盾的 $i,j$ 连边，然后对这张图染色。如果不是二分图，则无解。

接着考虑如何构造字典序最小的方案。首先，如果这个数可以放到第一个栈里，就一定先放第一个栈。

入栈前，要先判断，栈顶是否比当前数还小，如果是，就应该先出栈。而第一个栈开始操作前，还得看第二个栈里有没有**该出栈而还没出的数字**。如果有，先把第二个栈里的数弹出去，再弹第一个栈。最后把当前数入栈。

如果只能放第二个栈了，同样的，先把该弹的弹了，再入栈。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
struct edge{
	int to,nxt;
}e[N<<1];
int n,a[N],cnt,head[N],minn[N]; 
int col[N],now;
bool flag;
stack<int>sta,stb;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
void add(int u,int v){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int u){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(!col[v]){
			if(col[u]==1)col[v]=2;
			else col[v]=1;
			dfs(v);
		}
		else{
			if(col[v]==col[u])flag=1;
			//return;
		}
	}
}
int main(){
	freopen("P1155_13.in","r",stdin);
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	minn[n+1]=1145141919;
	for(int i=n;i>=1;i--){
		minn[i]=min(minn[i+1],a[i]);
		//cout<<minn[i]<<endl;
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(a[i]<a[j]&&minn[j+1]<a[i]){
				//cout<<i<<" "<<j<<endl;
				add(i,j);add(j,i);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(!col[i]){
			col[i]=1;
			dfs(i);
			//cout<<1<<endl;
		}
		//cout<<flag<<endl;
		//for(int j=1;j<=n;j++)cout<<col[j]<<" ";
		//cout<<endl;
	}
	if(flag){puts("0");return 0;}
	//for(int i=1;i<=n;i++)cout<<col[i]<<" ";
	for(int i=1;i<=n;i++){
		//cout<<i<<endl;
		if(col[i]==1){
			while(!sta.empty()&&a[i]>sta.top()){
				while(!stb.empty()&&stb.top()==now+1){
					now++;
					stb.pop();cout<<"d ";
				}
				now=max(now,sta.top());
				sta.pop();cout<<"b ";
			}
			sta.push(a[i]);cout<<"a ";
		}
		else{
			while(!sta.empty()&&sta.top()==now+1){
				now++;
				sta.pop();cout<<"b ";
			}
			while(!stb.empty()&&a[i]>stb.top()){
				now=max(now,stb.top());
				stb.pop();cout<<"d ";
			}
			while(!sta.empty()&&sta.top()==now+1){
				now++;
				sta.pop();cout<<"b ";
			}
			stb.push(a[i]);cout<<"c ";
		}
		//cout<<now<<endl;
		//cout<<endl; 
	}
	while(!sta.empty()&&sta.top()==now+1){
		now++;
		sta.pop();cout<<"b ";
	}
	while(!stb.empty()&&stb.top()==now+1){
		now++;
		stb.pop();cout<<"d ";
	}
	while(!sta.empty()&&sta.top()==now+1){
		now++;
		sta.pop();cout<<"b ";
	}
	while(!stb.empty()&&stb.top()==now+1){
		now++;
		stb.pop();cout<<"d ";
	}
	return 0;
}
/*
10
10 2 8 1 7 9 3 4 5 6
*/
```


---

## 作者：Purslane (赞：1)

## Solution

首先这个结论很清楚 : 如果 $i<j<k$ 且 $a_k<a_i<a_j$ , 那么 $i$ 和 $j$ 扔到两个栈里面 .

然后考虑如何贪心 . 首先 , 二分图染色的时候 , 我们从小到大枚举 , 每个点如果没被染 , 能搞到第一个栈就放在第一个栈里面 .

然后考虑怎么样排序 .

下面是乱搞做法 : ( 用 $a$ 和 $c$ 代指两个栈 )

首先 , 对于每个数 , 我们要压入它要去的栈里面 .

但是如果栈顶比他小 , 那么肯定要先把这个栈顶弹出去 . 

如果这个是第二个栈 , 那么考虑先把 $a$ 能弹出来的都弹出来 ( $b$ 优于 $d$ ) . 然后再去把 $c$ 能弹出来的弹出来 . 如果还没有满足栈顶大于这个数 , 那么继续弹第一个栈 ...... 最后 , 再看一看 $a$ 能不能继续弹 : $b$ 优于 $c$ .

对于第一个栈 , 操作几乎和它一样 , 但是先弹第一个栈 . 这里要注意 , 弹玩后就不要去检查第二个栈了 , 因为 $d$ 很劣 , 越靠后越好 .

code :

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1000+10;
int n,col[MAXN],a[MAXN],lst[MAXN],mx[MAXN],flg[MAXN],Mn[MAXN];
vector<int> G[MAXN];
void dfs(int u,int cc) {
	if(col[u]!=-1&&col[u]!=cc) {cout<<0;exit(0);}
	if(col[u]!=-1) return ;
	col[u]=cc;
	for(auto v:G[u]) dfs(v,1-cc);
	return ;
}
stack<int> st1,st2;
int check(int u) {
	ffor(i,1,u-1) if(!flg[i]) return 0;
	return 1;
}
void clear(int u,int op) {
	if(op==1) {
		while(!st1.empty()&&st1.top()<u) {
			while(!st1.empty()&&st1.top()<u) {if(check(st1.top())) {flg[st1.top()]=1;cout<<"b ";st1.pop();} else break;}
			if(st1.empty()||st1.top()>u) break;
			while(!st2.empty()&&st2.top()<u) {if(check(st2.top())) {flg[st2.top()]=1;cout<<"d ";st2.pop();} else break; if(check(st1.top())) break;}
		}
	}
	else {
		while(!st2.empty()&&st2.top()<u) {
			while(!st2.empty()&&st2.top()<u) {if(check(st2.top())) {flg[st2.top()]=1;cout<<"d ";st2.pop();} else break;}
			if(st2.empty()||st2.top()>u) break;
			while(!st1.empty()&&st1.top()<u) {if(check(st1.top())) {flg[st1.top()]=1;cout<<"b ";st1.pop();} else break; if(check(st2.top())) break;}
		}
	}
}
int main() {
	cin>>n; ffor(i,1,n) cin>>a[i];
	Mn[n]=a[n],Mn[n+1]=INT_MAX;
	roff(i,n-1,1) Mn[i]=min(Mn[i+1],a[i]);
	ffor(i,1,n) ffor(j,i+1,n) if(a[i]<a[j]) {
		if(Mn[j+1]<a[i]) {G[i].push_back(j),G[j].push_back(i);}
	}
	memset(col,-1,sizeof(col));
	ffor(i,1,n) if(col[i]==-1) dfs(i,0);
	ffor(i,1,n) {
		while(!st1.empty()&&check(st1.top())) {cout<<"b ";flg[st1.top()]=1;st1.pop();}
		clear(a[i],col[i]+1);
		if(col[i]) {while(!st1.empty()&&check(st1.top())) {flg[st1.top()]=1;st1.pop();cout<<"b ";}cout<<"c ";st2.push(a[i]);}
		else {cout<<"a ";st1.push(a[i]);}
		
	}
	clear(INT_MAX,1);
	while(!st2.empty()) {cout<<"d ";st2.pop();}
	return 0;
}
```

原谅我丑陋的代码 .
说一下 , `clear` 就是上面那两大段的过程 .

---

## 作者：uniqueharry (赞：1)

题意略，首先考虑两个位置在同一个栈中能否共存，对于 $(i,j)$，如果存在 $k$ 使得 $i < j < k$ 且 $p_k < p_i < p_j$，$(i,j)$ 是不能共存的。原因在于此时根据入栈顺序为 $i-j-k$，如果想要 $k$ 第一个出栈，出栈序列就只能是 $k-j-i$，与期望的 $k-i-j$ 不符。判断这个可以对 $p$ 求一个后缀最大值（不包括自己）。

对于两个位置，如果它们不能在同一个栈内，就可以在它们之间连一条边。连好之后发现这是一个二分图，两个部分对应着两个栈内的点。可以做一次二分图染色，如果染色失败则说明无解。否则，考虑解决剩下的部分。

先不考虑字典序，先考虑如何操作可以使出栈序列恰好是 $1$ ~ $n$。首先，任意一个栈的元素都是从栈顶到栈底单调递增的，不然不能按顺序输出。那么遍历 $n$ 个位置，若当前位置的数小于其所在栈栈顶，可以直接加入。否则需要弹栈，但是不能直接弹，要看考虑到输出序列中的第几个数。两个栈的栈顶哪个与此数相等，就弹哪个栈，然后再把当前数加入进去。

接下来考虑如何使字典序最小：

1.要尽量把编号较小的位置安排在第一个栈。

2.第二个栈的入栈和第一个栈的弹栈是相对独立的。而因为第一个栈的弹栈字典序比第二个栈入栈小，所以在考虑第二个栈的元素，满足条件即将入栈时，要看看第一个栈是不是可以弹栈。

最后要把栈弹空。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
const int N = 1e3 + 10;
int n,p[N],suf[N],col[N];
int top[2],stk[N][2],pos = 1;
vector <int> g[N];
bool flag;
void dfs(int u,int k){
	col[u] = k;
	for(unsigned i = 0; i < g[u].size(); i++){
		int v = g[u][i];
		if(col[v] == k){
			flag = 1;
			return;
		}
		if(col[v] == -1) dfs(v,k ^ 1);
	}
}
void check(){
	while(top[0] && stk[top[0]][0] == pos){
		top[0]--;
		pos++;
		printf("b ");
	}
}
int main(){
	scanf("%d",&n);
	for(int i = 1; i <= n; i++) scanf("%d",&p[i]);
	suf[n - 1] = p[n];
	for(int i = n - 2; i >= 1; i--) suf[i] = min(suf[i + 1],p[i + 1]);
	for(int i = 1; i < n; i++)
	    for(int j = i + 1; j < n; j++){
	    	if(suf[j] < p[i] && p[i] < p[j]){
	    		g[i].push_back(j);
	    		g[j].push_back(i);
			}
		}
	memset(col,-1,sizeof(col));
	for(int i = 1; i <= n; i++) if(col[i] == -1) dfs(i,0);
	if(flag){
		puts("0");
		return 0;
	}
 	for(int i = 1; i <= n; i++){
		if(!col[i]){
			if(!top[0] || p[i] < stk[top[0]][0]){
				stk[++top[0]][0] = p[i];
				printf("a ");
			}
			else{
				while(top[0] && p[i] > stk[top[0]][0]){
					if(stk[top[0]][0] == pos){
						pos++;
						top[0]--;
						printf("b ");
					}
					else if(top[1] && stk[top[1]][1] == pos){
						pos++;
						top[1]--;
						printf("d ");
					}
					else break;
				}
				stk[++top[0]][0] = p[i];
				printf("a ");
			}
		}
		else{
			if(!top[1] || p[i] < stk[top[1]][1]){
				check();
				stk[++top[1]][1] = p[i];
				printf("c ");
			}
			else{
				while(top[1] && p[i] > stk[top[1]][1]){
					if(top[0] && stk[top[0]][0] == pos){
						pos++;
						top[0]--;
						printf("b ");
					}
					else if(stk[top[1]][1] == pos){
						pos++;
						top[1]--;
						printf("d ");
					}
					else break;
				}
				check();
				stk[++top[1]][1] = p[i];
				printf("c ");
			}
		}
	}
	while(top[0] || top[1]){
		if((top[0] && stk[top[0]][0] == pos) || !top[1]){
			top[0]--;
			printf("b ");
		}
		else{
			top[1]--;
			printf("d ");
		}
		pos++;
	}
	return 0;
} 

---

## 作者：IS_THAT_DISTANCE (赞：1)

首先有必要概述一下题目。本题就是对一个给定的1~n序列通过两个栈的操作（a,b,c,d四种）能否得到一个升序序列。能则输出字典序最小的方案，否则输出0.

显然我们第一感觉会想到贪心，能用栈1就用栈1.这样看起来十分正确，但是会造成误判的情况（把有解判成无解，原因下面会解释），如以下数据：

10
10 2 8 1 7 9 3 4 5 6

这里存在一个元素间相斥（不能放同一个栈）的情况（以下元素均不是当前能弹出的元素）：

一个栈：显然a[i]>a[j],i<j时，需要一个栈“暂存”元素a[i]；

两个栈：考虑三个元素a[i],a[j],a[k],i<j<k，当a[k]<a[i]<a[j]时，a[i]和a[j]不可能在同个栈中，其他情况均可以使它们共存。

三个栈：a[p]<a[i]<a[j]<a[k],i<j<k<p……同理n栈一样。

刚才的误判就是把两个相斥的元素放到了同个栈中。因此我们需要判断两个元素的相容性，将相斥的两个元素间连一条边，构成一个无向图。

这个比较简单，通过n2的枚举加后缀min（后n个元素中的最小值）的操作可以完成。

接下来就是判断这个图是否是二分图并每个元素的归宿。完成了这一步，接下来就是简单的模拟。

由于这里只有两个栈，因此就是黑白染色。**注意**如果用找奇环的方式判断会超时，因为这样还要再染色。我们可以直接通过染色的方法判断（如果一条边的两个端点同色则无解）。具体bfs可以实现。

**P.S.:**佩服那位纯模拟的dalao





```cpp
var
  a,min,s1,s2,mat:array[0..1000] of longint;
  g:array[1..1000,1..1000] of boolean;
  f:array[0..2000] of longint;
  n,i,j,p,top1,top2,t:longint;
  flag:boolean;
procedure doit;
var find:boolean;
begin
  find:=false;
  if t<=n then
    if (mat[t]=1) and (a[t]<s1[top1]) then
    begin
      inc(top1);
      s1[top1]:=a[t];
      inc(t);
      find:=true;
      inc(f[0]);
      f[f[0]]:=1;
    end;
if find then exit;
  if s1[top1]=p then begin dec(top1);inc(f[0]);f[f[0]]:=2;find:=true;inc(p);end;
if find then exit;
  if t<=n then
    if (mat[t]=2) and (a[t]<s2[top2]) then
    begin
      inc(top2);
      s2[top2]:=a[t];
      inc(t);
      find:=true;
      inc(f[0]);
      f[f[0]]:=3;
    end;
if find then exit;
  if s2[top2]=p then begin dec(top2);inc(f[0]);f[f[0]]:=4;find:=true;inc(p);end;
end;
procedure bfs;
var
  list:array[1..10000] of longint;
  b:array[1..1000] of boolean;
  head,tail,x,i,j,p:longint;
begin
  fillchar(list,sizeof(list),0);
  fillchar(b,sizeof(b),0);
  for i:=1 to n do
  begin
    if b[i] then continue;
    b[i]:=true;
    mat[i]:=1;
    begin head:=0;tail:=1;fillchar(list,sizeof(list),0);end;
    list[1]:=i;
    while head<tail do
    begin
      inc(head);
      x:=list[head];
      for j:=1 to n do if g[x,j] then
      begin
        if not b[j] then
        begin
          b[j]:=true;
          inc(tail);
          list[tail]:=j;
          mat[j]:=3-mat[x];
        end else if mat[x]=mat[j] then begin writeln(0);halt;end;
      end;
    end;
  end;
end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  min[n]:=a[n];
  for i:=n-1 downto 1 do if min[i+1]<a[i] then min[i]:=min[i+1] else min[i]:=a[i];
  for i:=1 to n-2 do
    for j:=i+1 to n-1 do if (min[j+1]<a[i]) and (a[i]<a[j]) then
    begin
      g[i,j]:=true;
      g[j,i]:=true;
    end;
  fillchar(mat,sizeof(mat),0);
  bfs;
  for i:=1 to n do if mat[i]=0 then mat[i]:=1;
  s1[0]:=2000;
  s2[0]:=2000;
  top1:=0;
  top2:=0;
  p:=1;
  t:=1;
  while p<=n do doit;
  for i:=1 to f[0]-1 do write(chr(f[i]+96),' ');
  writeln(chr(f[f[0]]+96));
end.

```

---


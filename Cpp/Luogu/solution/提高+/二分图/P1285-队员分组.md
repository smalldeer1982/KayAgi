# 队员分组

## 题目描述

有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：

- 每个人都被分到其中一组。
- 每个组都至少有一个人。
- 一组中的每个人都认识其他同组成员。

在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。

请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 100$，$1 \leq a_{i, j} \leq n$。

#### 说明

由 @zhouyonglong 提供 SPJ。



## 样例 #1

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0
```

### 输出

```
3 1 3 5
2 2 4
```

# 题解

## 作者：iyanhang (赞：20)

### 思路:
- 首先这是一个存在性的01背包问题。分成两组联系到**二分图**上。
- 逻辑上有：两个不是互相认识的话必然存在于互相排斥的两组。对这些有排斥作用的，即有联系的点放在一张图上，在新的图上跑二分图染色，就可以实现分组了。

### 具体：
f[i][j]表示的意思是，使用前i个联通块里的0或是1的染色点是否能达到j的容量。

```
f[i][j]=f[i][j-num[i][0]],j>=num[i][0]

f[i][j]=f[i][j-num[i][1]],j>=num[i][1]
```
数一下联通块个数，当作是01背包的个数。取染色为0的或者染色为1的背包都是可行的。记录路径pre[i][j]。结果要在f[blo_sum][j]找j(1<=j<=2/n)最大的一个。

无解情况：在染色的时候判断是否矛盾，即非二分图。

### 其他：
- 注意**补图**的概念。
    - 为什么要求联通块这个东西呢？因为不同块之间的元素是互不影响的，即不同块的元素之间组别怎么分都是任意的。
    - 建补图的过程中要注意：有单向认识的边逻辑上都是认为不能在同一组的，所以要把这种边当作是两两都不认识的边。否则染色的dfs就不好控制了。这里还花了好多时间去调试呢。
- 这道题原题是POJ1112。还得抱怨一句这里的数据太水了。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MN=105;
const int MM=105;
typedef long long ll;

bool g[MN][MN],f[MN][MN];
int n,num[MM][2],pre[MN][MN],ans;
vector<int> cont[MN][2];

int mtc[MN],sum=0;
void dfs(int x,int fa,int col)
{
	num[sum][mtc[x]=col]++;cont[sum][col].push_back(x);
	for (int i=1;i<=n;++i)
		if (!g[i][x] && i!=fa && x!=i)
		{
			if (mtc[i]==-1) dfs(i,x,col^1);
			else if (mtc[i]==col) {printf("No solution");exit(0);}
		}
}
void dp()
{
	f[0][0]=true; //as a beginner.
	for (int i=1;i<=sum;++i)
		for (int j=0;j<=n/2;++j)
		{
			int t=j-num[i][0];
			//what can be carried must be the best one.
			if (t>=0&&f[i-1][t]) f[i][j]=true,pre[i][j]=0;
			t=j-num[i][1];
			if (t>=0&&f[i-1][t]) f[i][j]=true,pre[i][j]=1;
		}
	for (int i=n/2;i>=0;--i) if (f[sum][i]) {ans=i;break;}
}
void print()
{
	int res[MN]={0},t=ans;
	bool p[MN]={false};
	for (int i=sum;i>0;--i)
	{
		for (int j=0;j<cont[i][pre[i][t]].size();++j) p[res[++res[0]]=cont[i][pre[i][t]][j]]=true;
		t-=num[i][pre[i][t]];
	}
	sort(res+1,res+res[0]+1);
	printf("%d ",res[0]);for (int i=1;i<=res[0];++i) printf("%d ",res[i]);
	printf("\n%d ",n-res[0]);for (int i=1;i<=n;++i) if (!p[i]) printf("%d ",i);
}
ll read(){
	ll f=1,x=0;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c<='9'&&c>='0'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int main()
{
	n=read();
	int m,v;
	for (int i=1;i<=n;++i)
	{
		v=-1;
		while (v!=0){v=read();g[i][v]=true;}
	}
	for (int i=1;i<=n;++i)
		for (int j=i+1;j<=n;++j)
		{
			if (!(g[i][j]&&g[j][i]) && (g[i][j]||g[j][i])) g[i][j]=g[j][i]=false;
		}
	memset(mtc,-1,sizeof(mtc));
	for (int i=1;i<=n;++i)
		if (mtc[i]==-1)
		{
			sum++;
			dfs(i,0,1);
		}
	dp();
	print();
	return 0;
}
```

---

## 作者：Yaha (赞：15)

### 二分图染色 + DP

对于一个队员，如果和另一个不是双向的，那这两个一定不能在同一组中。

最终分为的两组我们用 $A$ 和 $B$ 表示。

每个点向那些和该点一定不同组的点连边。我们从一个点出发，不断用两种颜色间隔染色，直到不能再处理为止。所有处理过的点为一个连通块，而连通块内有两组不同颜色的点，互相冲突。由于每个连通块只能选其中一组进入组 $A$ ，另一组进入组 $B$ ，在只考虑组 $A$ 选哪组的情况下，我们用 DP 来解决剩下的问题。

状态表示： $f[i][j]$ 表示组 $A$ 在前 $i$ 个连通块中选，能不能达到人数为 $j$。能，则 $f[i][j]=1$ ，反之为 $0$  。

状态转移：对于连通块 $i$ ，选颜色为 $1$ 还是颜色为 $2$ 的组分别对应两种方案，剩下的很好想了。

认真看看代码就懂了QAQ

```cpp
#include<bits/stdc++.h>
using namespace std;
const int amou=1e3+90;
bool know[amou][amou],f[amou][amou],t[amou];//know是认不认识，t是最后输出答案用的桶
int col[amou];//表示一个点的颜色
vector<int>V[amou][3];//V[i][j]存i连通块j颜色组中的点
int blo,n,ans,take[amou][amou],num[amou][4],pre[amou][amou];//blo是连通块数，ans是A组人数的最终答案，take记录一种方案是选的颜色为哪个，num是i连通块j颜色组的个数（也可以直接用那个vector的size），pre表示一种方案是从哪种方案转移过来的即前驱

void dfs(int i,int fa,int c){
	col[i]=c,num[blo][c]++;//记录颜色
	V[blo][c].push_back(i);//存进去，因为后面要输出方案
	for(int j=1;j<=n;j++)
	{
		if(!know[i][j]&&i!=j&&j!=fa)
		{
			if(!col[j]) dfs(j,i,3-c);
			else if(col[j]==c)
			{
				printf("No solution");
				exit(0);
			}
		}
	}
}

void dp(){
	f[0][0]=1;//初始化
	for(int i=1;i<=blo;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(j>=num[i][1]&&f[i-1][j-num[i][1]])
				f[i][j]=1,take[i][j]=1,pre[i][j]=j-num[i][1];//记录第i个连通块是选的哪个颜色组，和这种方案是从哪里转移过来的。都是为了最后的输出答案
			if(j>=num[i][2]&&f[i-1][j-num[i][2]])
				f[i][j]=1,take[i][j]=2,pre[i][j]=j-num[i][2];
		}
	}
	for(int i=n/2;i>=1;i--)//因为要两个组更加接近，就倒着枚举，一旦有可行解，说明是最优解
	{
		if(f[blo][i])
		{
			ans=i;
			return;
		}
	}
}

void print(){
	printf("%d ",ans);//这是组A的最优人数
	int i=blo,j=ans;//要倒退回去来获得具体方案
	while(i&&j)
	{
		int which=take[i][j];//which是第i个连通块用的哪个颜色组
		for(int io=0;io<V[i][which].size();io++)
			t[V[i][which][io]]=1;//标记所有A组中的人
		j=pre[i--][j];//倒退
	}
	for(int i=1;i<=n;i++) if(t[i]) printf("%d ",i);
	printf("\n%d ",n-ans);
	for(int i=1;i<=n;i++) if(!t[i]) printf("%d ",i);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int k;
		while(scanf("%d",&k),k) know[i][k]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(know[i][j]!=know[j][i]) know[i][j]=know[j][i]=0;//非双向相当于互不认识，若不处理后面枚举不认识的人时就会出错 
	for(int i=1;i<=n;i++)
	{	
		if(!col[i])//没染过色
		{
			blo++;//新连通块
			dfs(i,0,1);
		}
	}
	dp();
	print();
	return 0;
}
```


---

## 作者：chenzida (赞：10)

### 题意简述：
有 $n\ (1\leq n\leq 100)$ 个人，有些人互相认识有些不互相认识，只有一个队中所有人都互相认识才能组队，问两队人数差绝对值最小，输出方案，如果无解输出 $No\ solution$。

### 思路解析：
这道题如果大暴力的话就是枚举组号 $O(2^n)$，对正解没有任何贡献，所以就不详细说了。

我们首先可以知道如果两个人并不是互相认识的话就不会被分在一组，所以我们可以对这张图中所有不互相认识的人之前建一条边，然后对这张图进行黑白染色。对于一个连通块来说，如果不同色的人必须不在一组，同色的人必定在一组。

**命题1** ：任意两个不同色的点都不能被选上。

**证明**：反证法，如果不同色的在一组，其中不同色的人中间一定有奇数条边，即有偶数个点。我们要在其中选择一些点，使得它们都不与这两个点相邻，并且其中任意两个都不能相邻，而且剩下的点也不能有任意两个点相邻。我们将还剩下 $x$ 个点的是否能够成功挑选的状态记为 $f(x)$。因为我们还剩任意个偶数，所以状态为 $f(2x)$，这样就转成证明 $f(2x)=0$ 了。因为首先 $f(2)=0$，这是显然的。

由于剩下的点两两不相邻，并且选的两个不能和两边相邻，那么选的只能是从右往左第 $3$ 个或者从右往左数第 $3$ 个，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/82sxqy4e.png)

但是不管选择哪一个标红的，都会少两个点，即 $f(x)=f(x-2)$，又因为有初值 $f(2)=0$ 所以 $f(2x)=f(2x-2)=...=f(2)=0$。命题1得证。

**命题2**：任意两个同色的点一定在一组。

**证明**：假设两个点 $x,y$ 同色，一个点 $z$ 与它们不同色，因为命题1，所以 $x$ 与 $z$ 和 $y$ 与 $z$ 都不在一个组内，因为只有两个组，所以 $x$ 与 $y$ 在一组内。命题2得证。 

有了这两个命题，我们就能开始最主要的任务—— $dp$ 了。首先，对于一个组的人，要么就是在同一个联通块内同色的点，要么就是在不同连通块。情况1我们预处理出来 $f[cnt][col]$ 表示编号为 $cnt$ 的连通块中 颜色为 $col$ 的点数，因为命题2，所以这些点一定都是一起加到一个组内的。

然后我们就可以开始我们的 $dp$ 了。还是那个基本的 $dp$ 四步走，想 $dp$ 的状态含义，初值，转移方程以及答案表示。

$dp$ 方程：$dp[i][j]=1$ 表示前 $i$ 个连通块中能够使一组的人数为 $j$。

$dp$ 初值：$dp[0][0]=1$ 其余都置为0。

$dp$ 转移：
![](https://cdn.luogu.com.cn/upload/image_hosting/x69tp0od.png)

$dp$ 答案：

![](https://cdn.luogu.com.cn/upload/image_hosting/rbei7z2l.png)

这样我们的 $dp$ 就完成了，两队最小人数差已经求出来了，但是别忘了我们还要记录输出方案呢，所以我们用一个 $path$ 数组记录每一个连通块选取的是黑色还是白色。所以 $path[i][j]=1\ -> path[i-1][j-num[i][1]]=1$ 当 $path[i][j]=0$ 时同理， 当选黑色和选白色都能推出来，我们选哪一个都行。

同时，为了记录路径，我们还要将第 $i$ 个连通块中颜色为 $0/1$ 的分别有哪些点记录下来，直接开数组记录是不现实的了，所以我们要仿照邻接表的记录方式，即用 $to,nxt,head$ 这三个数组来记录连边。

最后，我们再梳理一下思路：

$1.$ 读入建图，其中只要不是互相认识，一律变成互相不认识，因为他们反正不能在一个队里。

$2.$ 用 $dfs$ 跑黑白染色，用 $f[i][0/1]$ 记录第 $i$ 个连通块中，颜色为 黑/白 的节点数，同时也用邻接表记录上其包含的结点。

$3.$ 跑 $dp$，并得出答案。

$4.$ 跑输出方案的函数，一直计算直到返回的最初的状态。

具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=105;
int n;
int cnt;
int ans;
int mark[NR];
bool d[NR][NR];
int f[NR][2];
int to[NR<<5],nxt[NR<<5];
int head[NR][2];
int tot=1;
void add(int x,int col,int num)
{
	to[tot]=num;
	nxt[tot]=head[x][col];
	head[x][col]=tot++;
}
void dfs(int x,int fa_,int col)
{
	f[cnt][mark[x]=col]++;
	add(cnt,col,x);
	for(int i=1;i<=n;i++)
	{
		if(d[i][x]) continue;
		if(i==fa_) continue;
		if(i==x) continue;
		if(mark[i]==-1) dfs(i,x,col^1);
		else if(mark[i]==col)
		{
			puts("No solution");
			exit(0);
		}
	}
}
bool dp[NR][NR];
bool path[NR][NR];
void solve()
{
	dp[0][0]=1;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=0;j<=n/2;j++)
		{
			if(j>=f[i][0]&&dp[i-1][j-f[i][0]])
			{
				dp[i][j]=1;
				path[i][j]=0;
			}
			if(j>=f[i][1]&&dp[i-1][j-f[i][1]])
			{
				dp[i][j]=1;
				path[i][j]=1;
			}
		}
	}
	for(int i=n/2;i>=0;i--)
	{
		if(dp[cnt][i])
		{
			ans=i;
			break;
		}
	}
}
bool flag[NR];
int sum=0;
int num[NR];
void print()
{
	int tmp=ans;
	for(int i=cnt;i;i--)
	{
		for(int j=head[i][path[i][tmp]];j;j=nxt[j])
		{
			int t=to[j];
			sum++;
			flag[t]=1;	
		}
		tmp-=f[i][path[i][tmp]];
	}
	printf("%d ",sum);
	for(int i=1;i<=n;i++) 
	{
		if(flag[i]) printf("%d ",i);
	}
	printf("\n%d ",n-sum);
	for(int i=1;i<=n;i++)
	{
		if(!flag[i]) printf("%d ",i);
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
	{
		while(1)
		{
			int x=read();
			if(!x) break;
			d[i][x]=1;
		}
	}
	
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(d[i][j]!=d[j][i])
				d[i][j]=d[j][i]=0;
		}
	}
	memset(mark,-1,sizeof(mark));
	for(int i=1;i<=n;i++)
	{
		if(mark[i]==-1)
		{
			cnt++;
			dfs(i,0,1);
		}
	}
	solve();
	print();
	return 0;
}
/*
8
2 4 5 8 3 6 7 0
3 1 5 8 0
2 6 7 5 8 1 0
1 3 6 7 0
1 2 8 3 0
3 4 7 1 0
3 4 6 1 0
1 2 5 3 0
*/
```



---

## 作者：hgckythgcfhk (赞：4)

首先说明一件事情，有的题解说建反图，其实这不严谨，因为反图是把所有边反向，这个题建立的是补图。

我不确定这能不能过题解，但是想分享一下骗分做法，不放在题解区也可以。

首先来看一个**貌似正确**的做法：枚举每个点 $i$ 和初始颜色 $j$ 去染色，先对 $i$ 染成 $j$ 色，然后对未染色的点染成 $j$ 色，然后记录最好的方案的 $i$ 和 $j$，最后按这种方案染色。这个时候就拿到 85 分了。

很容易 hack，如果原图是完全图，会生成 $n$ 个大小为 $1$ 的连通快，那所有点都是相同颜色，有一个集合会空，不符合题意。

优化：我们可以把所有大小为 $1$ 的连通块单独存下来，最后加入到较小的集合中。这个时候已经 90 分了，程序如下：
```
#include<bits/stdc++.h>
using namespace std;const unsigned N=101;
#define void inline void
#define int register unsigned
vector<unsigned>a[N],c[2];bitset<N>b[N],d;unsigned char id[N],ans,p;
#define add(a,u,v) a[u].emplace_back(v)
inline bool dfs(int u,int f){id[u]=f;c[f].emplace_back(u);for(int v:a[u]){
	if(id[v]==0xff){if(dfs(v,f^1))return 1;}else if(id[v]==f)return 1;}return 0;
}bool f;unsigned n;void init(){memset(id,0xff,sizeof id);c[0].resize(0),c[1].resize(0);}
void aa(int i,bool f1){init();if(dfs(i,f1))return cout<<"No solution",exit(0);
	for(int j=n;j;--j)if(id[j]==0xff&&!d[j])if(dfs(j,f1))return cout<<"No solution",exit(0);}
void ac(int i,bool f1){for(int i=n;i;--i)if(d[i])if(c[0].size()>c[1].size())
	add(c,1,i);else add(c,0,i);int _=min(c[0].size(),c[1].size());if(_>ans)ans=_,p=i,f=f1;
}void ab(register bool x){sort(c[x].begin(),c[x].end());cout<<c[x].size();for(int i:c[x])cout<<' '<<i;cout<<'\n';}
signed main(){ios::sync_with_stdio(0);cin>>n;for(int i=1,x;i<=n;b[i][i]=1,++i)while(cin>>x,x)b[i][x]=1;
	for(int i=n,j;i;--i)for(j=n;j;--j)if(!b[i][j])a[i].emplace_back(j),a[j].emplace_back(i);
	for(int i=n;i;--i)if(a[i].size()==0)d[i]=1;
	for(int i=n,j;i;--i)if(!d[i])aa(i,1),ac(i,1),aa(i,0),ac(i,1);aa(p,f);ac(p,f);
	if(ans==0)return cout<<"No solution",0;ab(0);ab(1);
}
```


这个做法仍然可以 hack，如果有很多连通块大小为 $3$ 的连通块，显然所有连通块中两种颜色分别的个数都相同一定不优，这个时候我们可以用随机化在对各个连通块的起点染色时，随机的染成另一种颜色，由于上面的程序在极限数据下跑 $4ms$,我们完全可以让这个程序跑 $200$ 遍，把每次随机最优的方案记下了，记录每个连通块的起点和颜色，遇到更优方案则直接覆盖，由于以上面的程序的正确率能得 $90$ 分，随机的正确率大概率大于一半，所以错误率小于 $2^{-200}$，保守估计小于 $2^{-50}$，只需要改一下记录方案，然后加上一层循环即可，程序不放了

---

## 作者：damn2 (赞：3)

# 带权并查集+dp
**_~~本蒟蒻的第一篇题解~~_** 

大家都在用二分图，~~但我不会用~~，所以我就来写篇带权并查集吧！

---
### 题意

这题讲的其实就是一共有 $n$ 个人，分 2 组，没有双向关系的人不能放一起，求 2 组人数差最少的一种方案。无解输出 ```No solution```。


---

### 思路

为方便理解，若两个人之间没有双向关系，则在他们之间连一条边。那么最后，整个图将会由若干个连通块组成，连通块中只要有一个节点的阵营确定，那么这个连通块中节点阵营都可以确定。处理出一个一个连通块中，两个对立阵营分别的人数，然后跑 dp 就好，不过要记得记录转移路径。

显而易见，处理连通块中阵营人数有多种方法，你甚至可以用 bfs（~~我是不是可以再出一篇 bfs+dp~~）。而在此处我选择了使用带权并查集，直接在线处理。


---

### 代码+解释
 _**find 函数**_ 

$team_i$ 代表 $i$ 与父亲的关系，$0$ 代表同一阵营，$1$ 代表不同阵营。

```cpp
int find(int u){
    if(fa[u]!=u){
        int f=find(fa[u]);
        team[u]^=team[fa[u]]; 
        fa[u]=f;
    } 
    return fa[u];
}
```
与正常并查集的区别就在 $team_i$ 值的修改，需要保证与原本的父亲的关系不变。原父亲的值一定是 $0$（$team$ 数组预处理为 $0$），当父亲改变后值变为 $1$，经过异或，带动当前节点一起改变。

 _**并集**_

 
```cpp
int fi=find(i),fj=find(j);
if(fi!=fj){
    fa[fi]=fj;
    team[fi]^=team[i]^team[j]^1;
}else if(team[i]==team[j]){
    printf("No solution");
    return 0;
}
```

首先处理 $i,j$ 不在同一集，$team_{fi}$ 的值需要因 $team_i$ 和 $team_j$ 的值而改变。如果他们值一样则需要改变 $team_{fi}$ 值，才能使并集后他们的值不一样，否则不用改变。

如果 $i,j$ 在一集，那么就不用并集了，但需要检查 $team_i$ 和 $team_j$ ，确保不一样，否则说明产生了冲突，进入无解情况，输出 ```No solution```。

**dp**

比较基础的 dp，但还是讲一下。

$dp_{i,j,k}$ 代表处理完以 $1$~$i$ 作为父亲的集，并选择了在当前集中 $team$ 值为 $k$ 的阵营人数后，刚好有 $j$ 人。

对于每个集，可以选择两个阵营中其中一个，加上人数转移，其实就是把另一个阵营加到了剩下那组里

~~用了三维数组纯属方便记录路径（）~~

（假设以 $i$ 为父亲的集中的两个阵营角色，已经分别预处理在了 $ve_{i,0}$ 和 $ve_{i,1}$ 这两个 vector 中）


```cpp
    dp[0][0][0]=dp[0][0][1]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=n/2;j++)
            for(int k=0;k<=1;k++) if(j-ve[i][k].size()>=0){
                dp[i][j][k]=dp[i-1][j-ve[i][k].size()][0]|dp[i-1][j-ve[i][k].size()][1]; 
                if(i==n&&dp[i][j][k]) mx=max(mx,j); 
            }
```

最后答案就是 $i=n$，并且 $j$ 最接近 $\frac{n}{2}$ 的那条路径了，直接看 $k$ 填 $0$ 或 $1$ 哪个有值，就选哪个，然后将 $j$ 减去对应阵营的人数，一步步往回推就好。

**完整代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mx=0,fa[110],team[110],vis[110],rel[110][110],dp[110][110][2];
vector<int> ve[110][2];

int find(int u){
    if(fa[u]!=u){
        int f=find(fa[u]);
        team[u]^=team[fa[u]]; 
        fa[u]=f;
    } 
    return fa[u];
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=-1;j;rel[i][j]=1) scanf("%d",&j);
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++) if(i!=j&&!rel[i][j]){
            int fi=find(i),fj=find(j);
            if(fi!=fj){
                fa[fi]=fj;
                team[fi]^=team[i]^team[j]^1;
            }else if(team[i]==team[j]){
                printf("No solution");
                return 0;
            }
        } 
    for(int i=1;i<=n;i++) ve[find(i)][team[i]].push_back(i);
    dp[0][0][0]=dp[0][0][1]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=n/2;j++)
            for(int k=0;k<=1;k++) if(j-ve[i][k].size()>=0){
                dp[i][j][k]=dp[i-1][j-ve[i][k].size()][0]|dp[i-1][j-ve[i][k].size()][1]; 
                if(i==n&&dp[i][j][k]) mx=max(mx,j); 
            }
    int cnt=0;
    for(int i=n;i>=1;i--){
        for(int j=0;j<=1;j++){
            if(dp[i][mx][j]){
                for(int k:ve[i][j]) vis[k]=1,cnt++;
                mx-=ve[i][j].size();
                break;  
            }
        } 
    }
    printf("%d ",cnt);
    for(int i=1;i<=n;i++) if(vis[i]) printf("%d ",i);
    printf("\n%d ",n-cnt);
    for(int i=1;i<=n;i++) if(!vis[i]) printf("%d ",i);
	return 0;
}
```


---

 **谢谢观看**

**Thank you for your time**

---

## 作者：luxiaomao (赞：3)

## [P1285](https://www.luogu.com.cn/problem/P1285) 二分图染色 + 背包 dp

虽然本题理论上没有很大的难度，但是不少细节调起来并不那么容易。

题面并不难理解，用数学模型来表述，就是给出一张图 $G \in \{V,E\}$，将 $G$ 分成两个完全子图 $G_1$ 和 $G_2$，求两个子图节点数量的最小差值（注意，按照题目，必须是两个完全子图，而不仅是两个强连通分量，即任意两点应直接有边连接）。

~~刚开始看到最小差值以为是二分~~，题目要求分成两组，不难看出**二分图**的感觉。不过，平常的二分图是同一组内应该不存在连边，而本题是同一组内应该两两连边，那么，我们应该针对原图建一个补图（不是反图哦），具体实现请看代码。

建完图后，要判断这张图是不是二分图以及给二分图里的节点分组，我们采用很好理解的二分图**染色算法**实现。本人用 dfs 分别给每个节点染上 $1$ 和 $2$ 两种颜色，并以一个连通块为单位进行统计。

最后，我们已经有了多个处理好的连通块（多个小二分图），如何把这些小二分图合并起来，使得最后的大二分图左右部节点数量差值最小呢？

没错！这不 **0/1 背包**吗？我们用 $f_{i,j}$ 表示前 $i$ 个连通块是否存在 “选出一组 $j$ 人，另一组 $(n-j)$ 人”的方案。dp 完之后，我们查找距离 $n/2$ 最近的可实现的方案，就是我们的答案了。

对于如何输出具体分组有点小麻烦，不过不用考察思路全靠码力，我们可以在 dp 过程中记录前驱，最后输出时再倒着找回去，拿一个桶统计答案。

说了这么多，具体实现请看代码和注释~

## Code Time

```
#include<bits/stdc++.h>
using namespace std;

int n;
bool e[105][105];//是否相互认识，为0则必须分在两组

struct node{
	bool v;//是否存在方案
	int c,las;//c 表示做出这个选择是哪种颜色；las 记录前驱
}f[205][205];
vector<int> mp[105];//每个连通块有哪些点
int cnt1,cnt2;//用于临时统计每个连通块中不同颜色的数量
int tot;//连通块的数量
int c[105];//每个点染的颜色

int g[105];//输出时记录分组

void dfs(int u,int C)//二分图染色模板
{
	c[u] = C;
	mp[tot].push_back(u);//顺便记录一下这个点属于哪个连通块，方便输出答案
	if(C == 1)cnt1++;
	else cnt2++;
	for(int v = 1;v <= n;v++)
	{
		if(!e[u][v] && u != v && c[v] != 3-C)
		{
			if(c[v] == 0)dfs(v,3-C);
			else if(c[v] == c[u])printf("No solution"),exit(0);//无解情况
		}
	}
}

void print()
{
	int ans = n/2+1;
	while(!f[tot][--ans].v);//从中位开始贪心查找，第一个合法答案即为最优
	int i = tot,j = ans;
	while(i && j)//根据之前记录的前驱，倒着往回统计答案
	{
		int C = f[i][j].c;
		for(int k:mp[i])
			if(c[k] == C)g[k] = 1;
		j = f[i--][j].las;
	}
	
	printf("%d ",ans);
	for(i = 1;i <= n;i++)if(g[i] == 1)printf("%d ",i);
	printf("\n%d ",n-ans);
	for(i = 1;i <= n;i++)if(g[i] != 1)printf("%d ",i);
}

int main()
{
	scanf("%d",&n);
	for(int u = 1;u <= n;u++)
	{
		int v;
		while(scanf("%d",&v),v)e[u][v] = 1;
	}
	for(int u = 1;u <= n;u++)
		for(int v = u+1;v <= n;v++)
			if(e[u][v] != e[v][u])e[u][v] = e[v][u] = 0;//特判，单相思的两人按照题意是不能分在同一组的
	f[0][0].v = 1;//01背包的初始化
	tot = 0;//连通块统计初始化
	for(int i = 1;i <= n;i++)//一边进行染色 dfs 一边进行背包 dp
	{
		if(c[i] == 0)//查找到新的未处理的连通块
		{
			++tot;
			cnt1 = 0,cnt2 = 0;
			dfs(i,1);
			for(int j = n/2;j+1;j--)//小优化，因为最后只用查找前半部分
			{
				if(j-cnt1 >= 0 && f[tot-1][j-cnt1].v)
				{
					f[tot][j].v = 1;
					f[tot][j].las = j - cnt1;
					f[tot][j].c = 1;
				}
				if(j-cnt2 >= 0 && f[tot-1][j-cnt2].v)
				{
					f[tot][j].v = 1;
					f[tot][j].las = j - cnt2;
					f[tot][j].c = 2;
				}
			}
		}
	}
	print();
	return 0;//完结撒花！
}
```

---

## 作者：沙鵖之祖 (赞：3)

最开始看着这题怎么也不会做，直到看到了标签中的“二分图”，才算有了想法。

各位请尝试着想一下：如何将这题的认识关系转换成**二分图**呢？

好像还是想不出来。。。

怎么办？

我看着画出来的密密麻麻的边，不禁陷入沉思。

等一下，貌似这个图很稠密？

能不能让它稀疏一点？

有了！

我们不要去往认识关系去想，我们反过来想一下不认识的关系！

然后你就发现，所有具有不认识关系的两个点，必然不在一个集合里。

这不就是二分图吗？

于是你会发现，任意两点，只有“相互认识”与“至少有一方不认识”这两种互补的情况，这便是**补图**的概念了！

然后我们再来深入研究，便会发现整个图可以被构造成若干个二分图联通块，每个块内都被分为一或两个部分！

我们就来用 dp 来匹配不同联通块之间的二分配对就行了！

记录分组实现起来有点难，我是对 dp 里的每一个步骤做了前缀标记和路径标记才实现的，不过也就是实现困难，想还是很容易的哈～

帖下我自己的代码，~~不要吐槽我的码风了嘤嘤嘤~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define g getchar()
using namespace std;

const int N=107,M=1e4+7;
int n,hd[M],to[M],nex[M],tot,tag[N];
bool fla[N][N],f[N][N],type[N][N];
struct conduct{
	int save[2][N],sum[2];
}e[N];
int cnt,bef[N][N];
int ans,a[N],b[N];

int read(){
	int x=0,s=1;
	char c=g;
	while(c>'9'||c<'0'){
		if(c=='-') s=-1;
		c=g;
	}while(c>='0'&&c<='9')
		x=x*10+c-'0',c=g;
	return x*s;
}

void add(int x,int y){
	nex[++tot]=hd[x];
	hd[x]=tot;
	to[tot]=y;
}

void dfs(int u,int num){
	tag[u]=num;
	int x=(num+1)>>1;
	e[cnt].save[x][++e[cnt].sum[x]]=u;
	for(int i=hd[u];i;i=nex[i]){
		int v=to[i];
		if(tag[v]==0)
			dfs(v,-num);
		else if(tag[v]!=-num){
			printf("No solution");
			exit(0);
		}
	}
}

void work(int u,int num){
	if(!u) return;
	for(int i=1;i<=e[u].sum[type[u][num]];i++)
		a[++a[0]]=e[u].save[type[u][num]][i];
	for(int j=1;j<=e[u].sum[!type[u][num]];j++)
		b[++b[0]]=e[u].save[!type[u][num]][j];
	work(u-1,bef[u][num]);
}

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int x=read();
		while(x!=0)
			fla[i][x]=1,
			x=read();	
	}for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(!fla[i][j]||!fla[j][i])
				add(i,j),add(j,i);
	for(int i=1;i<=n;i++){
		if(tag[i]==0){
			cnt++;
			e[cnt].sum[0]=
			e[cnt].sum[1]=0;
			dfs(i,1);
		}
	}f[0][0]=1;
	for(int i=1;i<=cnt;i++){
		for(int j=0;j<=n;j++){
			if(f[i-1][j]){
				int a1=j+e[i].sum[0];	
				f[i][a1]=1;
				bef[i][a1]=j;
				type[i][a1]=0;
				int b1=j+e[i].sum[1];
				f[i][b1]=1;
				bef[i][b1]=j;
				type[i][b1]=1;
			}
		}
	}for(int i=n>>1;i<=n;i++){
		if(f[cnt][i]){
			work(cnt,i);
			ans=i;
			break;
		}
	}sort(a+1,a+a[0]+1);
	sort(b+1,b+b[0]+1);
	printf("%d ",ans);
	for(int i=1;i<=a[0];i++)
		printf("%d ",a[i]);
	printf("\n");
	printf("%d ",n-ans);
	for(int i=1;i<=b[0];i++)
		printf("%d ",b[i]);
	return 0;
}

```


---

## 作者：小木虫 (赞：3)

我们发现，只要两人之间任何一人不认识对方，它们就不可能组成1组，这与二分图的性质十分相似  
（只要之间有边就不可能一个颜色）  
于是我们建出原图的补图，一个一个跑二分图染色，最终得到一对一对不可能在一起的人群，那这时它们只需要分到不同的队伍就行。  
我们定义一个可行性dp，dp i代表它们之间的差+总人数的情况可不可能出现  
人群不在一起，转移时就是一加一减和一减一加  
第一个答案即为离总人数最近的真值的下标   
第二个答案加个路径追踪，排序后输出就行了  
代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int color[110];
vector <int> edge[110];
int to;
int l[110];
int cnt;
bool fail;
vector <int> team[110][2];
void paint(int x,int Map,bool c){
	if(fail)return;
	if(color[x]!=1e9&&color[x]!=c){
		fail=true;
		return;
	}
	if(color[x]!=1e9)return;
	team[Map][c].push_back(x);
	color[x]=c;
	if(c==1){
		l[Map]++;
	}else{
		l[Map]--;
	}
	for(int i=0;i<edge[x].size();i++){
		int v=edge[x][i];
		paint(v,Map,c^1);
	}
}
bool dp[110][110];
bool vis[110][110];
bool negmap[110][110];
int ret[110][110];
bool cur[110][110];
bool pl[110][110];
vector <int> black;
vector <int> white;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>to;
		while(to!=0){
			if(vis[to][i]){
				negmap[i][to]=negmap[to][i]=true;
			}else{
				vis[i][to]=true;
			}
			cin>>to;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			if(!negmap[i][j]){
				edge[i].push_back(j);
			}
		}
	}
	for(int i=1;i<=n;i++)color[i]=1e9;
	for(int i=1;i<=n;i++){
		if(color[i]==1e9){
			++cnt;
			paint(i,cnt,1);
			if(fail){
				cout<<"No solution";
				return 0;
			}
		}
	}
//	for(int i=1;i<=cnt;i++){
//		cout<<l[i]<<endl;
//	}
	dp[0][0]=true;
	for(int i=0;i<cnt;i++){
		for(int j=0;j<=n;j++){
			if(dp[i][j]){
				if(j==0){
					ret[i+1][abs(l[i+1])]=0;
					dp[i+1][abs(l[i+1])]=true;
					if(cur[i][j]){
						pl[i+1][abs(l[i+1])]=false;
					}else{
						pl[i+1][abs(l[i+1])]=true;
					}
					cur[i+1][abs(l[i+1])]=cur[i][j];
					if(l[i+1]<0){
						cur[i+1][abs(l[i+1])]=(cur[i][j]^1);
					}
					continue;
				}
				ret[i+1][abs(j+l[i+1])]=j;
				ret[i+1][abs(j-l[i+1])]=j;
				if(cur[i][j]){
					pl[i+1][abs(j-l[i+1])]=true;
					pl[i+1][abs(j+l[i+1])]=false;
				}else{
					pl[i+1][abs(j-l[i+1])]=false;
					pl[i+1][abs(j+l[i+1])]=true;
				}
				dp[i+1][abs(j+l[i+1])]=true;
				cur[i+1][abs(j+l[i+1])]=cur[i][j];
				if(j+l[i+1]<0){
					cur[i+1][abs(j+l[i+1])]=(cur[i][j]^1);
				}
				dp[i+1][abs(j-l[i+1])]=true;
				cur[i+1][abs(j-l[i+1])]=cur[i][j];
				if(j-l[i+1]<0){
					cur[i+1][abs(j-l[i+1])]=(cur[i][j]^1);
				}
			}
		}
	}
	for(int i=0;i<=n;i++){
		if(dp[cnt][i]){
			int k=i;
			for(int j=cnt;j>=1;j--){
				if(pl[j][k]){
					for(int z=0;z<team[j][1].size();z++){
						white.push_back(team[j][1][z]);
					}
					for(int z=0;z<team[j][0].size();z++){
						black.push_back(team[j][0][z]);
					}
				}else{
					for(int z=0;z<team[j][0].size();z++){
						white.push_back(team[j][0][z]);
					}
					for(int z=0;z<team[j][1].size();z++){
						black.push_back(team[j][1][z]);
					}
				}
				k=ret[j][k];
			}
			sort(white.begin(),white.end());
			sort(black.begin(),black.end());
			cout<<white.size()<<" ";
			for(int j=0;j<white.size();j++){
				cout<<white[j]<<" ";
			}
			cout<<endl;
			cout<<black.size()<<" ";
			for(int j=0;j<black.size();j++){
				cout<<black[j]<<" ";
			}
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：lly66666 (赞：2)

二分图 + dp。

我们可以先把题目要求分成两组，也就是二分图。但这道题要求我们把相互认识的人放在同一组里，于是我们不难想到用补图，经过思考，你就会发现，任意两点，只有“相互认识”或“至少有一方不认识”两种情况，这便是补图的概念。

我们再用二分图染色算法实现，用 dfs 分别给每个节点染上 $1$ 和 $2$ 两种颜色，并把每一个连通块单独统计。

然后要将不同连通块的组合合并，使总和的差更小，这时候，我们就可以用动态规划。

数组 $f_{i,j}$ 表示在前 $i$ 个联通块里能否达到 $j$ 个人，可以则 $f_{i,j} = 1$，反之则 $f_{i,j} =0$。 

最后输出时，我们还要记录 $f_{i,j}$ 是从哪个状态而来，最后倒序找回去就可以了。

话不多说，上代码。

总代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int num[100005][3], n, dp[1005][1005], pre[1005][1005], take[1005][1005], cnt, ans, vis[100005];
bool know[1005][1005], flag[100005];
vector<int> v[1005][1005];
void dfs(int x, int fa, int colour) {
	vis[x] = colour, num[cnt][colour] ++;
	v[cnt][colour].push_back(x);
	for(int i = 1; i <= n; i ++) {
		if(!know[x][i] && x != i && i != fa) {
			if(!vis[i]) {
				dfs(i, x, 3 - colour);
			}
			if(vis[i] == colour) {
				cout << "No solution";
				exit(0);
			}
		}
	}
}
int main() {
	memset(know, false, sizeof(know));
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		int k;
		cin >> k;
		while(k != 0) {
			know[i][k] = true;
			cin >> k;
		}
	}
	for(int i = 1; i < n; i ++) {
		for(int j = i + 1; j <= n; j ++) {
			if(know[i][j] != know[j][i]) know[i][j] = know[j][i] = false;
		}
	}
	for(int i = 1; i <= n; i ++) {
		if(!vis[i]) {
			cnt ++;
			dfs(i, 0, 1);
		}
	}
	dp[0][0] = 1;
	for(int i = 1; i <= cnt; i ++) {
		for(int j = 1; j <= n; j ++) {
			if(j - num[i][1] >= 0 && dp[i - 1][j - num[i][1]]) {
				dp[i][j] = 1;
				take[i][j] = 1;
				pre[i][j] = j - num[i][1];
			}
			if(j - num[i][2] >= 0 && dp[i - 1][j - num[i][2]]) {
				dp[i][j] = 1;
				take[i][j] = 2;
				pre[i][j] = j - num[i][2];
			}
		}
	}
	for(int i = n / 2; i >= 1; i --) {
		if(dp[cnt][i]) {
			ans = i;
			break;
		}
	}
	cout << ans << ' ';
	int i = cnt, j = ans;
	memset(flag, false, sizeof(flag));
	while(i && j) {
		int now = take[i][j];
		for(int k = 0; k < v[i][now].size(); k ++) {
			flag[v[i][now][k]] = true;
		}
		j = pre[i --][j];
	}
	for(int i = 1; i <= n; i ++) {
		if(flag[i]) cout << i << ' ';
	}
	cout << endl << n - ans << ' ';
	for(int i = 1; i <= n; i ++) {
		if(!flag[i]) cout << i << ' ';
	}
	return 0;
}
```

完结撒花！

管理员大大大大大大大大大大大大大大大求过。

---

## 作者：wvwit (赞：1)

# 题意
给出一张有向图 $G$，包含 $n$ 个点。将 $G$ 分为 $A$ 和 $B $ 使得 $A$ 内节点两两成环，$B$ 内节点两两成环。找到一种划分方案使得 $abs(|A|-|B|)$ 最小，若不存在划分方案，输出 $No~solution$。
# 分析
看到分为两个部分，立即想到二分图，左右两边分别为 $A$ 和 $B$。

但题目要求是 $A$ 和 $B$ 内两两相连，似乎与两个部分没关系。最直接的做法为用 $2^n$ 的复杂度枚举两边的点，再进行检测。

换个角度想，哪些点能在一个部分不好求，但我们可以轻松地得到哪些点一定不在一个部分，即不满足双向连边的一对点。

将不满足双向连边的点安放在二分图两侧，染色进行检测，若染色成功，则这是唯一的划分方案，否则不存在划分方案。

注意到通过这种方式构造出来的图可能是多张二分图，对于每张二分图都有两个部分。令 $A$ 在每张二分图中任取一个部分，$B$ 取剩下的部分，无论如何取构造出来的一定是一组可行划分方案。

若一组方案中 $|A|=x$，则将方案逆转可以得到 $|B|=x$ 的情况，所以一下只考虑 $|A|$。

考虑到题目要求 $abs(|A|-|B|)$ 最小，若将每组方案取出来再取 $min$，则时间复杂度仍然是指数级的。

考虑进行优化，注意到对于每组方案，$|A| \in [1,n]$。答案的更新也只跟 $|A|$ 有关。即虽然方案数是指数级的，但真正不同的方案最多只有 $100$ 种。

考虑对于 $|A|$ 的每个取值，记录下是否可以取到该值。

对于第 $i$ 个二分图，左边大小为 $a_i$，右边大小为 $b_i$。枚举 $j \in [1,n]$，如果通过前面 $i-1$ 个二分图可以取到 $|A|=j$，则通过前面 $i$ 个二分图可以取到 $|A|=j+a_i$ 和 $|A|=j+b_i$。

发现这是一个状态转移，将它写出来：
```
for(int j=1;j<=n;j++)
	if(f[i-1][j]) f[i][j+a[i]]=f[i][j+b[i]]=1;
```
现在问题就很好解决了，运用 $f$ 数组求出答案中 $|A|$ 和 $|B|$ 的大小，在求 $f$ 的过程中记录一组可行方案，最后直接输出。

---

## 作者：SamHJD (赞：1)

## [P1285 队员分组](https://www.luogu.com.cn/problem/P1285)

### 题意

给出一些认识关系，你要把 $n$ 个人分为两组，使得每一组内的人都互相认识，并且使两组人数相差最小，求分配方案，无解输出 `No solution`。

### 解法

首先判断无解情况，我们对关系图建立返图，即每个人和他不认识的人建边，这里是两人只要有一个人不认识另一个就建边。

题意中让我们分成两组，而根据上面的建边，我们要使每组内不能出现边，想到二分图。

我们要判别一张图是否为二分图，可以用染色的方法，当边 $(u,v)$ 中 $u,v$ 同色即不为二分图。注意这个关系图可能不是都连通的，跑完每个点才能判别是否为二分图。

```cpp
void dfs(int u,int col){
	c[u]=col;
	cntb[blo][col]++;//预处理dp
	v[blo][col].push_back(u);//预处理dp
	for(int i=1;i<=n;++i){
		if(!e[u][i]&&u!=i){
			if(c[u]==c[i]){//一条边同色
				printf("No solution");
				exit(0);
			}
			else if(!c[i]){//没有染色
				dfs(i,3-col);//col：1或2
			}
		}
	}
}
//------------
scanf("%d",&n);
for(int i=1;i<=n;++i){
	int x;scanf("%d",&x);
	while(x){
		e[i][x]=1;
		scanf("%d",&x);
	}
}
for(int i=1;i<=n;++i){
	for(int j=i+1;j<=n;++j) if(e[i][j]!=e[j][i]) e[i][j]=e[j][i]=0;
	//如果两人中有一人不认识另一个人，他们就不能在同一组里。
}
for(int i=1;i<=n;++i){
	if(!c[i]){//没有搜索到
		blo++;//连通块个数
		dfs(i,1);
	}
}
```
---

我们用二分图处理了每个连通块分出的两组，现在我们要将不同连通块的组合并，使得总和的差更小，考虑动态规划。

由于数据很小，我们可以直接定义 $f_{i,j}$ 为前 $i$ 个连通块能不能合出来 $j$ 个人的方案。

转移分两次，即考虑分别合并当前连通块的两个组。于是我们还要在 `dfs` 中记录一些量：

* $cntb_{block,1/2}$：在连通块 $block$ 内 $1/2$ 组的人数。

* $v_{block,1/2}$：在连通块 $block$ 内 $1/2$ 组的所有人编号。

于是可以得到转移：

$$f_{i,j}=f_{i-1,j-cntb_{i,1}}|f_{i-1,j-cntb_{i,2}}$$

题目要输出每一个人，于是我们还要记录 $f_{i,j}$ 是从哪个状态转移而来，最后倒序找回去输出即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=200,N=1e5+10;
int e[M][M],cntb[N][4],n,vis[N],c[N],f[M*10][M*10],blo,ans;
int from[M*10][M*10],chos[M*10][M*10],t[N];
vector<int> v[N][4];
void dfs(int u,int col){
	c[u]=col;
	cntb[blo][col]++;
	v[blo][col].push_back(u);
	for(int i=1;i<=n;++i){
		if(!e[u][i]&&u!=i){
			if(c[u]==c[i]){
				printf("No solution");
				exit(0);
			}
			else if(!c[i]){
				dfs(i,3-col);
			}
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		int x;scanf("%d",&x);
		while(x){
			e[i][x]=1;
			scanf("%d",&x);
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=i+1;j<=n;++j) if(e[i][j]!=e[j][i]) e[i][j]=e[j][i]=0;
	}
	for(int i=1;i<=n;++i){
		if(!c[i]){
			blo++;
			dfs(i,1);
		}
	}	
	
	f[0][0]=1;
	for(int i=1;i<=blo;++i){
		for(int j=1;j<=n;++j){
			if(j>=cntb[i][1]&&f[i-1][j-cntb[i][1]]){
				f[i][j]=1;//dp数组 
				chos[i][j]=1;//选的哪个颜色 
				from[i][j]=j-cntb[i][1];//从f[i-1][什么]转移 
			}
			if(j>=cntb[i][2]&&f[i-1][j-cntb[i][2]]){
				f[i][j]=1;
				chos[i][j]=2;
				from[i][j]=j-cntb[i][2];
			}
		}
	}
	for(int i=n/2;i>=1;--i){//从一半（差为0或1）开始尝试答案
		if(f[blo][i]){
			ans=i;
			break;
		}
	}
	printf("%d ",ans);
	int i=blo,j=ans;//从ans的情况向前找出答案
	while(i&&j){
		int color=chos[i][j];//f[i][j]是哪种颜色
		for(int k=0;k<v[i][color].size();k++){
			t[v[i][color][k]]=1;//用桶标记这个人是否为当前组的人
		}
		j=from[i--][j];//f[i][j]从哪转移来的
	}
	for(int i=1;i<=n;++i) if(t[i]) printf("%d ",i);puts("");
	printf("%d ",n-ans);
	for(int i=1;i<=n;++i) if(!t[i]) printf("%d ",i);
	return 0;
}
```

---

## 作者：Z1qqurat (赞：1)

二分图染色+背包。

首先看到分成两组，想到二分图。如果两个人不是互相认识的话则不能在同一个组，这启发我们按照排斥关系建边，注意如果两个人不是互相认识，就算有一个人认识另一个人，也需要建边（双向边）。

然后我们对于这个图进行二分图染色，在一个连通块内，染出两种颜色，构造方案就变成了把每个连通块中两种颜色的点分别放入要求的两组中，并且使得两组的人数差尽量地小。不难发现这是一个背包问题。设计状态 $dp_{i, j}$ 表示在前 $i$ 个连通块中，第 $1$ 组的总人数为 $j$ 的是否可行。转移是简单的，对于第 $i$ 个连通块，讨论是选择颜色为 $1$ 或 $2$ 的人放入第 $1$ 组。所以在染色的时候同时需要维护每个点被染上的颜色 $col_i$，所属的连通块 $blk_i$，每个连通块颜色为 $1$ 或 $2$ 的点数量 $sz_{i, 1/2}$，方便转移和方案输出。

题目还要求输出方案，于是设 $p_{i, j}$ 表示状态 $dp_{i, j}$ 中，第 $i$ 个连通块选择了颜色为 $i$ 的点放入第 $1$ 组。然后直接递归转移即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 105;
int n, sz[N][3], p[N][N], col[N], blk[N], cnt, tot1, tot2, p1[N], p2[N]; //sz[i][j] 表示在第 i 个块中，颜色为 j 的点数量
bool ed[N][N], dp[N][N]; //dp[i][j] 表示前i个联通块，第一组的点数量为j时，是否可行 
vector <int> G[N];

bool coloring(int u, int c, int b) {
    col[u] = c; sz[b][c]++; blk[u] = b;
    for (int v : G[u]) {
        if(col[v] == c) return 0;
        else if(!col[v]) {
            if(!coloring(v, 3 - c, b)) return 0;
        }
    }
    return 1;
} 

void divideg(int cur, int x) {
	if(cur == 0) return ;
	if(p[cur][x] == 1) {
		for (int i = 1; i <= n; ++i) {
            if(blk[i] == cur) {
                if(col[i] == 1) p1[++tot1] = i;
                else p2[++tot2] = i;
            }
        }
		divideg(cur - 1, x - sz[cur][1]);
	}
	else {
		for (int i = 1; i <= n; ++i) {
            if(blk[i] == cur) {
                if(col[i] == 2) p1[++tot1] = i;
                else p2[++tot2] = i;
            }
        }
		divideg(cur - 1, x - sz[cur][2]);
	}
	return ;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        int a;
        while(scanf("%d", &a)) {
            if(a == 0) break;
            ed[i][a] = 1;
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            if(!ed[i][j] || !ed[j][i]) G[i].emplace_back(j), G[j].emplace_back(i);
        }
    }
    for (int i = 1; i <= n; ++i) {
        if(!col[i]) {
            if(!coloring(i, 1, ++cnt)) return puts("No solution"), 0;
		}
	}
    dp[0][0] = 1;
    for (int i = 1; i <= cnt; ++i) {
        for (int j = 0; j <= n; ++j) { //目前一共有 j 个颜色为 1 的点
            //若第i个联通块选择了颜色为1的点
			int k = j - sz[i][1];
			if(k >= 0) {
				if(dp[i - 1][k]) dp[i][j] = 1, p[i][j] = 1; //p[i][j] 指状态 dp[i][j] 是在第 i 个连通块中选择了颜色为 p[i][j] 的转移过来的
			}
            k = j - sz[i][2];
            //若第i个联通块选择了颜色为2的点
            if(k >= 0) {
                if(dp[i - 1][k]) dp[i][j] = 1, p[i][j] = 2;
            }
        }
    }
    int ans = 114514, pos;
    for (int i = 0; i <= n; ++i) if(dp[cnt][i] && abs(n - 2 * i) < ans) ans = abs(n - 2 * i), pos = i;
    if(ans == 114514) return puts("No solution"), 0;
    // cout << pos << "\n";
    divideg(cnt, pos);
    sort(p1 + 1, p1 + tot1 + 1);
    sort(p2 + 1, p2 + tot2 + 1);
    printf("%d ", tot1);
    for (int i = 1; i <= tot1; ++i) printf("%d ", p1[i]);
    puts("");
    printf("%d ", tot2);
    for (int i = 1; i <= tot2; ++i) printf("%d ", p2[i]);
    puts("");
    return 0;
}
```

---

## 作者：闭电脑沉思 (赞：1)

# 题解 P1285 【队员分组】
## Solution
### 题目大意:
1. 每个都有一些认识的，A认识B不一定有B认识A。

2. 你要把所有人分成两个队伍，要求同一队伍内的人必须两两认识。

3. 在这前提上使得两队的人数尽量接近，求分组方案。
### 思路：
1. 二分图

2. 背包
### 分析：
 必须两两认识不好处理，**我们可以把不认识的人连上边**，这样就变成了同一队伍内的人之间没有边了

我们发现在这种情况下不同连通分量的人互不影响因此可以分别计算

对于连通分量内的点，我们要把它黑白染色，并且同一颜色的点之间没有边，这就是二分图的定义.

我们一次$bfs$就可以做到，并且如果任意连通分量无解则整个问题无解

然后使得两个队伍的人数接近，我们发现一个连通分量的黑点可以有两种情况，因此我们跑一个布尔背包，从$n/2$枚举求一下能不能拼出$x$个黑点就可以了

## $Code$
```
#include <cstdio>
#include <cctype>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int maxn = 128;
inline int read(){
	int x = 0;char c = getchar();
	while(!isdigit(c))c = getchar();
	while(isdigit(c))x = x * 10 + c - '0',c = getchar();
	return x;
}
vector<int> G[maxn],vec[maxn][2],ans[2];
inline void addedge(int from,int to){G[from].push_back(to);}
int n,tmp[maxn][maxn],f[maxn][maxn],opt[maxn][maxn],vis[maxn],col[maxn],vec_tot;
inline bool bfs(int s){
	queue<int> Q;Q.push(s);vis[s] = 1;
	vec_tot++;
	while(!Q.empty()){
		int u = Q.front();Q.pop();
		vec[vec_tot][col[u]].push_back(u);
		for(int v : G[u])
			if(!vis[v])col[v] = col[u] ^ 1,vis[v] = 1,Q.push(v);
			else if(col[v] == col[u])return false;
	}
	return true;
}
inline void solve(){
	n = read();
	for(int u = 1,v;u <= n;u++)
		while((v = read()))tmp[u][v] = 1;
	for(int u = 1;u <= n;u++)
		for(int v = u + 1;v <= n;v++)
			if(!(tmp[u][v] && tmp[v][u]))addedge(u,v),addedge(v,u);
	for(int i = 1;i <= n;i++)
		if(!vis[i] && !bfs(i)){
			puts("No solution");
			return;
		}
	f[0][0] = 1;
	for(int i = 1;i <= vec_tot;i++)
		for(int j = 0;j <= n;j++){
			if(j >= vec[i][0].size() && f[i - 1][j - vec[i][0].size()])f[i][j] = 1,opt[i][j] = 0;
			if(j >= vec[i][1].size() && f[i - 1][j - vec[i][1].size()])f[i][j] = 1,opt[i][j] = 1;
		}
	int now;
	for(int i = n >> 1;i >= 0;i--)
		if(f[vec_tot][i]){now = i;break;}
	for(int i = vec_tot;i >= 1;i--){
		for(auto x : vec[i][opt[i][now]])ans[0].push_back(x);
		for(auto x : vec[i][opt[i][now] ^ 1])ans[1].push_back(x);
		now -= vec[i][opt[i][now]].size();
	}
	sort(ans[0].begin(),ans[0].end());
	sort(ans[1].begin(),ans[1].end());
	printf("%d ",(int)ans[0].size());
	for(auto x : ans[0])printf("%d ",x);
	putchar('\n');
	printf("%d ",(int)ans[1].size());
	for(auto x : ans[1])printf("%d ",x);
	putchar('\n');
}
int main(){
	solve();
}
```
### 实测AC
### 完结撒花


---

## 作者：_J_C_ (赞：1)

~~【看题解少，赶紧来发一篇】~~
其实思路是和楼上的神犇一样的，都是可行性DP。
不过对于方案的保存，我的方法不太一样。

C++有一个好东西叫做bitset，即“位集”，相当于一个布尔数组，过不其中每一个bool型是占1位的，而普通编译器实现bool据说用的int……

咳咳，扯远了。那么我们怎么用bitset保存方案呢

注意到n<=100，我们可以用bitset<112>来保存n个队员的选择方案，如果bitset<112> a的a[12]等于1，则说明第十二号队员在这个方案里。

然后与楼上类似的，先利用并查集将队员分块。方法是在不能放在同一组的人间建立双向边。那么联通块间是相互独立的，就变成一个非常好的可行性dp了，其中dp[x][y]指前x个联通块是否能够达到y个球员分离出来。

对每一个联通块，显然只有一种方案（黑白染色）或者是矛盾而无解。

最后，bitset使用时要注意不要出现类似a |= a << x;的操作，因为1<<x是一个int，会爆32位的……（我因为这个破操作16分，调了一个小时orz还刷了n多提交）

代码如下。(奇丑无比)

```cpp
#include <cstdio>
#include <cstdlib>

#include <iostream>
#include <queue>
#include <bitset>

int belong[112], val[112];

int find(int need)
{
	return belong[need] == need ? need : belong[need] = find(belong[need]);
}

void combine(int a, int b)
{
	int f(find(a)), s(find(b));
	if (f != s)
	{
		if (val[f] < val[s]) f ^= s ^= f ^= s;
		val[f] += val[s];
		belong[s] = f;
	}
}

bool failed(false);//染色失败的标记
bool map[112][112];//两点间是否有边；若有，说明这两个人不能再同一集合种

int able[112][2];//able[x][y]对于第x个联通块，显然它只能提供两个方案且这两个方案的集合实际上互为补集（黑白染色不考虑反转黑白时只可能有唯一解或者无解）
std::bitset<112> way[112][2];//way[x][y]对于第x个联通块提供的方案的bitset表示法

bool bInGroup[112];//这个点已经被分配在某个块中了
int block[112];//这个点属于哪个块
int iEndBlock;//块的编号从0开始

bool dp[112][112];
std::bitset<112> dp_way[112][112];

int n;

bool bColored[112];//是否已被染色
int color[112];//染色，0-1

void setcolor(int begin)//广搜染色并且获取方案；若无解则标记failed
{
	if (bColored[begin]) return;//若这个点所在的块已被染色，返回
	int bk(block[find(begin)]);//这个块的编号
	bColored[begin] = true;
	color[begin] = 0;
	std::queue<int> que;
	que.push(begin);
	while (!que.empty())
	{
		int now(que.front());
		que.pop();
		++able[bk][color[now]];
		way[bk][color[now]][now] = 1;
		for (int i(1); i <= n; ++i)
		{
			if (map[now][i])
			{
				if (bColored[i])
				{
					if (color[i] != color[now] ^ 1)
					{
						failed = true;
						return;
					}
				}
				else
				{
					bColored[i] = true;
					color[i] = color[now] ^ 1;
					que.push(i);
				}
			}
		}
	}
}

int ans(11234);
std::bitset<112> tot;//全集
std::bitset<112> out[2];

inline int abs(int a) { return a > 0 ? a : -a; }

int main()
{
	//freopen("data.in", "r", stdin);
	//freopen("wrong.out", "w+", stdout);
	scanf("%d", &n);
	for (int i(1); i <= n; ++i) tot[i] = 1;
	for (int i(1); i <= n; ++i)
	{
		for (int j(1); j <= n; ++j)
		{
			if (i != j) map[i][j] = true;
		}
		belong[i] = i;
		val[i] = 1;
	}
	for (int i(1); i <= n; ++i)
	{
		int x;
		scanf("%d", &x);
		while (x != 0)
		{
			map[i][x] = false;
			scanf("%d", &x);
		}
	}
	for (int i(1); i <= n; ++i) for (int j(1); j <= n; ++j) if (map[i][j]) map[j][i] = true;//如果i不认识j,那么即使j认识i，i与j也不能在一组，故接双向边
	for (int i(1); i <= n; ++i) for (int j(1); j <= n; ++j) if (map[i][j]) combine(i, j);//利用并查集分块
	for (int i(1); i <= n; ++i)
	{
		if (!bInGroup[find(i)])//当前块没有被分配
		{
			bInGroup[find(i)] = true;
			block[find(i)] = iEndBlock++;//分配编号
		}
	}
	for (int i(1); i <= n && !failed; ++i)
	{
		setcolor(i);//染色
	}
	if (failed)
	{
		printf("No solution\n");
		return 0;
	}
	dp[0][able[0][0]] = true;
	dp_way[0][able[0][0]] = way[0][0];
	dp[0][able[0][1]] = true;
	dp_way[0][able[0][1]] = way[0][1];
	for (int i(1); i != iEndBlock; ++i)
	{
		for (int j(0); j <= n; ++j)
		{
			if (dp[i - 1][j])
			{
				dp[i][j + able[i][0]] = true;
				dp_way[i][j + able[i][0]] = dp_way[i - 1][j] | way[i][0];
				dp[i][j + able[i][1]] = true;
				dp_way[i][j + able[i][1]] = dp_way[i - 1][j] | way[i][1];//可行性dp，这段可能是最好理解的吧……
                //若第i块能分出able[i][0]个成员，且前i块一起能够分出j个成员，那么j+able[i][0]对于前i块是一个合法状态
			}
		}
	}
	
	for (int i(1); i < n; ++i)//题目中说不能有一个队伍是空的，所以i不能取到0或者n
	{
		if (dp[iEndBlock - 1][i] && abs(n - i - i) < ans)
		{
			ans = abs(n - i - i);
			out[0] = dp_way[iEndBlock - 1][i];
			out[1] = tot ^ dp_way[iEndBlock - 1][i];
		}
	}
	if (out[0].count() == 0 || out[1].count() == 0)//题目中说不能有一个队伍是空的
	{
		printf("No solution\n");
		return 0;
	}
	
	int end(out[0].count());//后面的都是输出方案
	int cnt(0);
	int rank(0);
	printf("%d ", end);
	while (cnt != end)
	{
		if (out[0][0] & 1)
		{
			printf("%d ", rank);
			++cnt;
		}
		++rank;
		out[0] >>= 1;
	}
	end = out[1].count();
	cnt = 0;
	rank = 0;
	printf("\n%d ", end);
	while (cnt != end)
	{
		if (out[1][0] & 1)
		{
			printf("%d ", rank);
			++cnt;
		}
		++rank;
		out[1] >>= 1;
	}
	printf("\n");
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

正着做不好做，考虑让每个人与其不认识的人连边，那么就转化为一条边的两个端点不在一个集合中，是经典二分图问题。

因为整个图不一定联通，考虑对于每个联通块验证是否为二分图，可以用二分图染色法。

若有一个联通块不是二分图，则无解；否则求出该联通块两个集合的分别点的个数 $s_{i,1},s_{i,2}$。

因为要使得两组成员的人数之差（绝对值）尽可能小，考虑动态规划算法，令 $dp_{i,j}$ 表示考虑前 $i$ 个联通块，使得 $A$ 组刚好有 $j$ 个人是否可以分配到，初始 $dp_{0,0}=1$。

则状态转移方程为：

$$dp_{i,j} = dp_{i-1,j-s_{i,0}} ||  dp_{i-1,j-s_{i,1}}$$

设联通块个数为 $cnt$，最后因为我们要使得差尽可能小，那么要找到一个 $k$，满足 $dp_{i,k}=1$，使得 $k$ 尽量接近 $\frac{n}{2}$，枚举一下即可。

现在考虑求方案数，定义 $pre_{i,j}$ 表示 $dp_{i,j}$ 是由 $s_{i,1}$ 还是 $s_{i,2}$ 转移而来，那么可以进行回溯。

初始令 $x=k$，然后要将第 $cnt$ 联通块内是 $pre_{cnt,x}$ 集合的点加入 $A$ 组，然后令 $x \to x - s_{cnt,pre_{cnt,x}}$，回溯到上一层重复此操作。

时间复杂度为 $O(N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=105;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,x,cnt,ans;
ll t[N][2];
bool s[N][N],dp[N][N],pre[N][N];
bool f[N],h[N];
bool F=1;
vector<ll> E[N];
vector<ll> G[N][2];
vector<ll> ans1,ans2;
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs(ll u,ll fa){
	G[cnt][h[u]].push_back(u);
	t[cnt][h[u]]++;
	f[u]=1;
	for(auto v:E[u]){
		if(v==fa)
		  continue;
		if(f[v]){
			if(h[v]^h[u]!=1){
				puts("No solution");
				exit(0);
			}
			continue;
		}
		h[v]=h[u]^1ll;
		dfs(v,u);
	}
}
void init(){
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(s[i][j]&&s[j][i])
			  continue;
			add(i,j);
		}
	}
}
void solve(){
	for(int i=1;i<=n;i++){
		if(!f[i]){
			++cnt;
			dfs(i,0);
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=0;j<=n/2;j++){
			for(int k=0;k<2;k++){
				if(j>=t[i][k]){
					dp[i][j]|=dp[i-1][j-t[i][k]];
					if(dp[i-1][j-t[i][k]])
					  pre[i][j]=k;
				}
			}
		}
	}
	for(int i=n/2;i>=0;i--){
		if(dp[cnt][i]){
			ans=i;
			break;
		}
	}
}
void print(ll x){
	for(int i=cnt;i>=1;i--){
		for(auto v:G[i][pre[i][x]])
		  ans1.push_back(v);
		for(auto v:G[i][pre[i][x]^1ll])
		  ans2.push_back(v);
		x-=t[i][pre[i][x]];
	}
	sort(ans1.begin(),ans1.end());
	sort(ans2.begin(),ans2.end());
	write(ans1.size());
	putchar(' ');
	for(auto v:ans1){
		write(v);
		putchar(' ');
	}
	putchar('\n');
	write(ans2.size());
	putchar(' ');
	for(auto v:ans2){
		write(v);
		putchar(' ');
	}
	putchar('\n');
}
int main(){	
	dp[0][0]=1;
	n=read();
	for(int i=1;i<=n;i++){
		while(1){
			x=read();
			if(!x)
			  break;
			s[i][x]=1;
		}
	}
	init();
	solve();
	print(ans);
	return 0;
}
```

---

## 作者：cosf (赞：0)

## [P1285](https://www.luogu.com.cn/problem/P1285)

首先先把图给反一下。那么，题目就转变为把所有点分成二分图，左右点数差最小是多少。

---

如果本身图（以下图均指反图）就不是二分图，那显然是不行的。

那么，对于图中的每一个连通块，显然它们分成二分图的左右点数差是一样的。也就是说，假设每一个连通块的差是 $a_1, \dots, a_m$，则相当于给每一个 $a_i$ 一个正负号 $s_i$，使得 $|\sum_{i=1}^ms_ia_i|$ 最小。

因为 $n$ 很小，直接 dp 即可。转移的时候记录一下符号，方便以后还原。

## 代码

```cpp
#include <iostream>
using namespace std;

#define MAXN 105
#define ZERO MAXN *MAXN

int n;

bool e[MAXN][MAXN];

int siz[MAXN];
int bsd[MAXN];
int cnt = 0;

int col[MAXN];
int blo[MAXN];

bool dfs(int p, int c, int s)
{
    col[p] = c;
    blo[p] = s;
    siz[s] += c;
    for (int i = 1; i <= n; i++)
    {
        if (e[p][i])
        {
            continue;
        }
        if (blo[i])
        {
            if (col[i] + c)
            {
                return true;
            }
        }
        else if (dfs(i, -c, s))
        {
            return true;
        }
    }
    return false;
}

bool re[ZERO << 1][MAXN];
int sd[ZERO << 1][MAXN];

void print(int t)
{
    int co = 0;
    for (int i = 1; i <= n; i++)
    {
        if (col[i] * bsd[blo[i]] == t)
        {
            co++;
        }
    }
    cout << co;
    for (int i = 1; i <= n; i++)
    {
        if (col[i] * bsd[blo[i]] == t)
        {
            cout << ' ' << i;
        }
    }
    cout << endl;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        e[i][i] = true;
        int v;
        cin >> v;
        while (v)
        {
            e[i][v] = true;
            cin >> v;
        }
    }
    for (int i = 1; i < n; i++)
    {
        for (int j = i + 1; j <= n; j++)
        {
            e[i][j] = e[j][i] = e[i][j] && e[j][i];
        }
    }
    for (int i = 1; i <= n; i++)
    {
        if (!col[i])
        {
            if (dfs(i, 1, ++cnt))
            {
                cout << "No solution" << endl;
                return 0;
            }
        }
    }
    re[ZERO][0] = true;
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = 0; j < ZERO << 1; j++)
        {
            if (re[j][i - 1])
            {
                if (!re[j + siz[i]][i])
                {
                    re[j + siz[i]][i] = true;
                    sd[j + siz[i]][i] = 1;
                }
                if (!re[j - siz[i]][i])
                {
                    re[j - siz[i]][i] = true;
                    sd[j - siz[i]][i] = -1;
                }
            }
        }
    }
    int rab = 0;
    for (int j = 0; j < ZERO; j++)
    {
        if (re[j + ZERO][cnt])
        {
            rab = j + ZERO;
            break;
        }
        if (re[ZERO - j][cnt])
        {
            rab = ZERO - j;
            break;
        }
    }
    for (int i = cnt; i; i--)
    {
        bsd[i] = sd[rab][i];
        rab -= sd[rab][i] * siz[i];
    }
    print(1);
    print(-1);
    return 0;
}

```

---

## 作者：Otomachi_Una_ (赞：0)

## 题目简述
- 给一个 $n$ 点有向图。要求把所有点分为 $A,B$ 两部分。同集合内两点均相连。
- $n\leq100$。

## 解题思路

假设 $con_{i,j}$ 表示 $i,j$ 是否能被分为同一个集合内。

对于一个点 $i$，我们可以找到所有必须和它同集合的点和必须不同集合的点。我们把这些点想做一个二元集合对。

也就是这些点必在不同的集合，剩下找点数差最小的问题就交给 dp 了。变成了这样的一个问题：
> 给若干个数对，在这些数对中每个选一个数，问两边的差的绝对值最小值是多少？

这很显然可以用布尔背包完成，具体的读者可以参考代码。

读者只要好好想就能明白了。

## 参考代码
```cpp
#include<iostream>
using namespace std;
const int MAXN=205;
int n,u;
bool knw[MAXN][MAXN];
bool con[MAXN][MAXN];
int col[MAXN];//col[i] 对立面 col[i]^1.
int sum[MAXN];
bool vis[MAXN];//i子阵是否在 A 中 
bool f[MAXN][MAXN];
int go[MAXN][MAXN][MAXN];//go[i][j]选取元素集 
int cnt=2; 
void dfs(int p,bool sign){
	if(col[p]&&col[p]!=cnt^sign){
		cout<<"No solution";
		exit(0);//结束所有程序 
	}
	if(col[p]) return;
	col[p]=cnt^sign;
	for(int i=1;i<=n;i++)
		if(con[p][i])
			dfs(i,!sign);
	return;
}//染色 
void build(){
	for(int i=1;i<=n;i++)
		if(!col[i]){
			dfs(i,0);
			cnt+=2;
		}
	for(int i=1;i<=n;i++)
		sum[col[i]]++;//统计 
	return;
}
void dp(){
	f[0][0]=true;
	for(int i=2;i<cnt;i++)
		for(int j=i/2*2-2;j<=i/2*2-1;j++)
			for(int k=0;k<=n;k++){
				if(k>=sum[i]&&f[j][k-sum[i]]){
					f[i][k]=true;
					int t=1;
					while(go[j][k-sum[i]][t]){
						go[i][k][t]=go[j][k-sum[i]][t];
						t++;
					}
					if(t==1)
						go[i][k][1]=i;
					else
						go[i][k][t]=i;
				}
			}
	return;
}
void print(){
	int res=0;
	for(int i=1;i<=n;i++)
		if(vis[col[i]]) res++;
	cout<<res<<" ";
	for(int i=1;i<=n;i++)
		if(vis[col[i]]) cout<<i<<" ";
	cout<<endl;
	cout<<n-res<<" ";
	for(int i=1;i<=n;i++)
		if(!vis[col[i]]) cout<<i<<" ";
	return;
}
void find(){
	for(int j=n/2;j>=1;j--)
		for(int i=(cnt-1)^1;i<cnt;i++)
			if(f[i][j]){
				for(int t=1;go[i][j][t];t++)
					vis[go[i][j][t]]=true;
				print();
				return;
			}
	return;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			knw[i][j]=(i!=j);
	for(int i=1;i<=n;i++)
		while(cin>>u){
			if(u==0) break;
			knw[i][u]=false;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			con[i][j]=(i!=j&&(knw[i][j]||knw[j][i]));//con[i][j]: i,j 是否不同组 
	build();
	dp();
	find();
	return 0;
} 
```


---

## 作者：龚祖豪曾用号 (赞：0)

题目链接：[https://www.luogu.com.cn/problem/P1285](https://www.luogu.com.cn/problem/P1285)

这是一道**很好很好**的题

看一眼题目，就发现可能与**二分图**有关

然后，经过一定时间的思考，你会发现，这道题好像并不能直接用图论算法或者动态规划解决

这时候，我们就要考虑，是不是有一些可以用来贪心的定理。
首先直观一般会想到关于可以分到一个集合的人的条件

然后就会发现，一个人与**不认识他或他不认识的人**是绝对不可以分到同一个集合，这样是不是可以看做一个无向的边，又是分为两个集合，**二分图染色**？

我们可以把每个人与不认识他**或者**他不认识的人都建一条无向边，然后我们发现一个联通块分出来的集合是一定的。

也就是说，现在问题转化为有若干个联通块，在每个联通块上选择元素为$0 / 1 $的集合，答案加上这个集合的个数，最终求的不变

这不就是一个上界设为$n / 2$ 的$01$背包吗？
简单$d p$即可

## $Code$

```
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXN = 100;
int a[MAXN + 10][MAXN + 10], fa[MAXN + 10], vis[MAXN + 10], n, tot = 0;
int cnt[MAXN + 10][2], dp[MAXN + 10][MAXN + 10];
bool sf[MAXN + 10][MAXN + 10], ans[MAXN + 10], dfn[MAXN + 10], ok;

void dfs(int x){
    if (!ok) return;
    if (vis[x] == 1)    ++cnt[tot][0];
    else    ++cnt[tot][1];
    for (register int i = 1; i <= n; ++i){
        if (a[x][i] && a[i][x] || i == x) continue;
        if (!vis[i]){
            vis[i] = 3 - vis[x], fa[i] = fa[x];
            dfs(i);
            continue;
        }
        if (vis[i] != vis[x])   continue;
        ok = 0;
    }
}

void dfs2(int x, int op){
    if (vis[x] == op)   ans[x] = 1;
    dfn[x] = 1;
    for (register int i = 1; i <= n; ++i){
        if (a[x][i] && a[i][x] || i == x)   continue;
        if (!dfn[i])    dfs2(i, op);
    }
}

void get_list(int x, int j){
    if (!x) return;
    int op = sf[x][j] + 1;
    for (register int i = 1; i <= n; ++i){
        if (fa[i] != x) continue;
        dfs2(i, op);
        break;
    }
    get_list(x - 1, j - cnt[x][op - 1]);
}
inline int read();

int main(){
    //freopen ("std.in", "r", stdin);
    //freopen ("std.out", "w", stdout);
    n = read();
    for (register int i = 1; i <= n; ++i){
        int x = read();
        while (x){
            a[i][x] = 1;
            x = read();
        }
    }
    for (register int i = 1; i <= n; ++i){
        if (vis[i]) continue;
        vis[i] = 1; ok = 1; fa[i] = ++tot;
        dfs(i);
        if (!ok){
            printf("No solution\n");
            return 0;
        }
    }
    dp[0][0] = 1;
    for (register int i = 1; i <= tot; ++i){
        for (register int k = 0; k <= 1; ++k)
            for (register int j = cnt[i][k]; j <= n / 2; ++j){
                if (dp[i][j] || !dp[i - 1][j - cnt[i][k]])   continue;
                dp[i][j] = 1;
                sf[i][j] = k;
            }
    }
    int num;
    for (register int i = n / 2; i >= 1; --i){
        if (!dp[tot][i])    continue;
        num = i;
        get_list(tot, i);
        break;
    }
    printf("%d ", num);
    for (register int i = 1; i <= n; ++i)
        if (ans[i]) printf("%d ", i);
    
    printf("\n%d ", n - num);
    for (register int i = 1; i <= n; ++i)
        if (!ans[i])    printf("%d ", i);
    return 0;
}

inline int read(){
    int x = 0;
    char c = getchar();
    while (!isdigit(c))c = getchar();
    while (isdigit(c))x = (x << 1) + (x << 3) + (c & 15), c = getchar();
    return x;
}
```

---


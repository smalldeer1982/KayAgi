# [国家集训队] 稳定婚姻

## 题目描述

我们已知 $n$ 对夫妻的婚姻状况，称第 $i$ 对夫妻的男方为 $B_i$，女方为 $G_i$。若某男 $B_i$ 与某女 $G_j$ 曾经交往过（无论是大学，高中，亦或是幼儿园阶段，$i \le j$），则当某方与其配偶（即 $B_i$ 与 $G_i$ 或 $B_j$ 与 $G_j$）感情出现问题时，他们有私奔的可能性。不妨设 $B_i$ 和其配偶 $G_i$ 感情不和，于是 $B_i$ 和 $G_j$ 旧情复燃，进而 $B_j$ 因被戴绿帽而感到不爽，联系上了他的初恋情人 $G_k$ ……一串串的离婚事件像多米诺骨牌一般接踵而至。若在 $B_i$ 和 $G_i$ 离婚的前提下，这 $2n$ 个人最终依然能够结合成 $n$ 对情侣，那么我们称婚姻 $i$ 为不安全的，否则婚姻 $i$ 就是安全的。

给定所需信息，你的任务是判断每对婚姻是否安全。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $40\%$ 的数据，$n \le 100$，$m \le 400$；

对于 $100\%$ 的数据，所有姓名字符串中只包含英文大小写字母，大小写敏感，长度不大于 $8$，保证每对关系只在输入文件中出现一次，输入文件的最后 $m$ 行不会出现未在之前出现过的姓名，这 $2n$ 个人的姓名各不相同，$1 \le n \le 4000$，$0 \le m \le 20000$。

## 样例 #1

### 输入

```
2
Melanie Ashley
Scarlett Charles
1
Scarlett Ashley```

### 输出

```
Safe
Safe```

## 样例 #2

### 输入

```
2
Melanie Ashley
Scarlett Charles
2
Scarlett Ashley
Melanie Charles```

### 输出

```
Unsafe
Unsafe```

# 题解

## 作者：雨季 (赞：97)

# 题解
我们尝试着将所有的丈夫和妻子用线段连接起来，表示他们之间存在着联系，如果这时有一个女孩和其中的丈夫交往过，那么他们之间也存在着这种联系，所以这两种情况我们可以认为本质是相同的。  
那么我们将所有 现在或曾经交往过的 男孩和女孩连接起来，可以发现出现了一些环，而处在环中的几对夫妻都可以更换伴侣，也就是题目中所说的婚姻不安全。那么我们找出这些环，判断哪些夫妻处在环中即可。  
对于找环，我们想到了$Tarjan$求强连通分量，但是这个算法是在有向图上进行的，于是我们尝试给我们连接出的无向图定向，发现只要按照 $...$男$\to$女$\to$男$\to$女$...$ 的顺序，男女交替就可以$Tarjan$判出环来。  
所以我们可以这样建图：  
- 夫妻之间：$girl \to boy$  
- 情人之间：$boy \to girl$  

$Tarjan$求强连通分量，对于一对夫妻，如果两人在同一个强连通分量里，那么这对婚姻就是不安全的，反之，则是安全的。  
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<map>
using namespace std;
#define N 10005
#define M 300005
 
int n,m; 
map<string,int>cou; // couple 
 
struct node {
	int v,nex;
}e[M];
int tot,h[N];
void add(int u,int v) {
	e[++tot].v=v;
	e[tot].nex=h[u];
	h[u]=tot;
}
 
inline int read() {
	int tmp=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
	return tmp;
}
 
bool ins[N];
int s[N],top;
int cnt,belong[N];
int dfn[N],low[N],idx;
void Tarjan(int u) {
	dfn[u]=low[u]=++idx;
	s[++top]=u;
	ins[u]=1;
	for(int i=h[u];i;i=e[i].nex) {
		int v=e[i].v;
		if(!dfn[v]) {
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v]) low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]) {
		++cnt;
		do{
			belong[s[top]]=cnt;
			ins[s[top]]=0;
		}while(s[top--]!=u);
	}
}
 
int main()
{
	n=read();
	string gir,boy;
	for(int i=1;i<=n;++i) {
		cin>>gir>>boy;
		cou[gir]=i;
		cou[boy]=i+n;
		add(i,i+n);
	}
	m=read();
	for(int i=1;i<=m;++i) {
		cin>>gir>>boy;
		add(cou[boy],cou[gir]);
	}
	for(int i=1;i<=n*2;++i) if(!dfn[i]) Tarjan(i);
	for(int i=1;i<=n;++i) {
		if(belong[i]==belong[i+n]) printf("Unsafe\n");
		else printf("Safe\n");
	}
	return 0;
}
```

---

## 作者：Baihua (赞：34)

#### 这里介绍一种二分图匹配做法。
* 考虑题目所描述的过程，我们应该 **先拆散一对夫妻**，然后试图为被拆散的男方匹配。
* 题目所给出的夫妻在没有被拆散的的情况下，一定是一对一的，因此如果匹配成功，那么在 ** 匈牙利算法的最后阶段，那个没有被匹配的点一定是先前被拆散的 **
* 因此我们模拟这个过程 ：

	1.拆散一对夫妇
    
    2.试图重新匹配
    
    3.如果匹配成功，那么他们就是不安全的
    
* 注意事项：
	
    数组开到足够用的
* 下面是代码：

```
#include <iostream>
#include <fstream>
#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <cstring>
#include <map>
#define re register
#define GC getchar()
#define Clean(X,K) memset(X,K,sizeof(X))
using namespace std ;
int Qread () {
    int X = 0 ,F = 1;
    char C = GC ;
    while (C > '9' || C < '0') {
        if (C == '-') F = -1 ;
        C = GC ;
    }
    while (C >='0' && C <= '9') {
        X = X * 10 + C - '0' ;
        C = GC ;
    }
    return X *F ;
}
/*
头文件和准备工作
*/ 
const int Maxn = 8005 , Maxm = 20005 ;
int Men[Maxn] , Cnt = 0 , Low[Maxn] , Dfn[Maxn] , Vis[Maxn] , En = 0 , Head[Maxn] , N , M , Match[Maxn] , S[Maxn] , T = 0;
struct Edge {
    int Fr , Gt , Nxt ;
};
Edge E[Maxm * 2] ;
void Adg (int X , int Y) {
    ++ En ;
    E[En].Fr = X ;
    E[En].Gt = Y ;
    E[En].Nxt = Head[X] ;
    Head[X] = En ;
}
map <string , int > A ;
bool DFS (int X) {
    for (re int i = Head[X] ; i; i = E[i].Nxt ) {
        if (Vis[E[i].Gt]) continue ;
        Vis[E[i].Gt] = 1 ;
        if (Match[E[i].Gt] == 0 || DFS (Match[E[i].Gt])) {
            return true ;
        }
    }
    return false ;
}
int main () {
    //freopen ("P1407.in" , "r" , stdin) ;
    Clean (Head , 0) , Clean (Match , 0), Clean (Low , 0) , Clean (Dfn , 0) , Clean(Vis , 0) ;
    N = Qread () ;
    for (re int i = 1 ; i <= N; ++ i) {
        string S1 , S2 ;
        cin >> S1 >> S2 ;
        int X , Y ;
        if (A[S1]) X = A[S1] ;
        else A[S1] = X = ++ Cnt ;
        if (A[S2]) Y = A[S2] ;
        else A[S2] = Y = ++ Cnt ;
        Match[Y] = X  , Match[X] = Y ;
        Men[X] =1 , Men[Y] = 0 ;
    }
    M = Qread () ;
    for (re int i = 1 ; i <= M ; ++ i) {
        string S1 , S2 ;
        cin >> S1 >> S2 ;
        int X = A[S1] , Y = A[S2] ;
        Adg (X , Y) ;
    }
/*
建立图
*/ 
    for (re int i = 1 ; i <= Cnt ; ++ i) if (Men[i]) {
            Clean (Vis , 0) ;
            Match[Match[i]] = 0 ; 
            //拆散一对夫妇
            if (DFS (i)) printf ("Unsafe\n") ;
            else printf ("Safe\n") ;
            Match[Match[i]] = i ;
            //让他们重新连接，方便以后的操作。 
        }
    fclose (stdin) ;
    fclose (stdout);
    return 0;
}
```
#### Thanks!


---

## 作者：ahawzlc (赞：27)

这是蒟蒻的第三篇题解。

~~这道题就是绿与被绿的故事。~~

在读懂题以后，我们可以归纳出，如果这段姻缘是``` Unsafe ```的，那么这么几个人的关系必须是是个环。

什么意思呢？

以样例2为例：

![tijie1.png](https://i.loli.net/2020/03/04/otkqrpudIsxfBLC.png)

假设奇数的是 male ，偶数的是 female 。

1 2 3 4分别代表 Melanie Ashley Scarlett Charles.

那么在如图这个环中：原本的夫妻是12和34，但是由于他们在一个环中，说白了，就是在这个**强连通分量**中，他们可以任意更换对象。~~（狗血）~~

样例1不必多说，（~~三角恋是不会有好结果的~~），因为这三个人没有构成强连通分量，所以婚姻安全了。（实际上就是把上图的1-4边断掉）

所以就很明显，我们只需要建好图，然后运用 tarjan 求解强连通分量，如果一对夫妻在同一个强连通分量里面，那么婚姻就有危机了，否则就会风平浪静。

然后又有一个问题了：怎么建图。

原题读完后，很容易想到无向图，即建双边。

但是！！！

如果这样的话，我们上面所推导的一切全都前功尽弃了，因为无向图求强连通分量$==$想peach.强连通分量是针对有向图来说的。

所以我们在建图时，要把夫妻和情侣都拆开建图。

那怎么拆才能形成环呢？

有三种方案：
1. 男 -> 女
2. 女 -> 男
3. 男 -> 女 和 女 -> 男分开

很显然，第一种和第二种是无论如何也不会出现环的。

还是以样例2为例，如果按第1种方式建图，那么会是这样：

![tijie2.png](https://i.loli.net/2020/03/04/zidys48rlnwWv1G.png)

这就很毒瘤。

第2种同理。

再看第三种：建图结果就像最上面我刚开始讲时用的那幅图。

我再放一遍这个图：

![tijie1.png](https://i.loli.net/2020/03/04/otkqrpudIsxfBLC.png)

我是将夫妻间用 女 -> 男 存图，情侣间用 男 -> 女 存图。~~（内部含义自行理解 /kk）~~

这样的话，就能通过女 -> 男 -> 女 -> 男来用算法找到环。

对了，不会$tarjan$的[出门右转](https://oi-wiki.org/graph/scc/)不谢。

这道题实际上只要弄明白怎么建图，就是一道[ tarjan 模板题](https://www.luogu.com.cn/problem/P2341) 。

讲了这么一大堆，下面是喜闻乐见的代码时间：

``` cpp
#include<bits/stdc++.h>
using namespace std;

int cnt,n,tail,m,h[8005],dfn[8005],low[8005],id,tarn,bl[8005],x[8005],y[8005];
bool vis[8005];
stack<int> s;
map<string,int> to;//map映射，将名字点映射成数字点 

struct node {//链式前向星存图
	int to,nxt;
} b[25005];

void add(int x,int y) {//加边操作 
	b[++cnt].to=y;
	b[cnt].nxt=h[x];
	h[x]=cnt;
}

void tarjan(int u) {//tarjan算法求强联通分量 
	s.push(u);
	vis[u]=1;
	dfn[u]=low[u]=++id;
	for(int i=h[u]; i; i=b[i].nxt) {
		int v=b[i].to;
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		} else {
			if(vis[v]) {
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(dfn[u]==low[u]) {
		tarn++;
		int v;
		do {
			v=s.top();
			s.pop();
			bl[v]=tarn;
			vis[v]=0;
		} while(u!=v);
	}
}

int main() {
	cin>>n;
	string a,b;
	for(int i=1; i<=n; i++) {
		cin>>a>>b;
		x[i]=to[a]=++tail;//将女方转换成数字
		y[i]=to[b]=++tail;//将男方转换成数字
		add(to[a],to[b]);//female -> male 存边
	}
	cin>>m;
	for(int i=1; i<=m; i++) {
		cin>>a>>b;
		add(to[b],to[a]);//male -> female 存边
	}
	for(int i=1; i<=tail; i++) {
		if(!dfn[i]) {
			tarjan(i);
		}
	}
	for(int i=1; i<=n; i++) {
		if(bl[x[i]]==bl[y[i]]) {//bl 即 belong 表示当前这个点属于哪一个强连通分量 
			puts("Unsafe");
		} else {
			puts("Safe");
		}
	}
	return 0;
}
```

---

## 作者：xzlhxc_ed (赞：21)

**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1407)**
[题目链接（luogu）](https://www.luogu.com.cn/problemnew/show/1407)   
前置芝士：[二分图匹配（匈牙利算法）](https://www.luogu.com.cn/problem/P3386)。

------------

## 题外话
 _突然感觉以前的题解风格奇丑无比，故改用二号标题。_    
 _如对排版有建议或者对题解内容不理解的欢迎私信笔者！_ 
 
~~在学tarjan的时候看到了这道题，于是去学了二分图匹配来做（大雾~~     
第一次看题误将40%的数据看成100%，结果暴力匈牙利，TLE+RE……     
这题相对于模板的二分图匹配多了亿些思考量，不失为一道好题。

## ①题意翻译
给定一个$2*N$个节点的二分图，初始时给出一个完全匹配，每次尝试删掉一个匹配（及边）并询问是否仍存在完全匹配（每次输出结果后要将删除的边复原）。

$0<N \leq 4000$ ,$0< M \leq 20000$
好像已经把做法说得明明白白了呢……那么考虑一下细节吧……

## ②细节
**1.** 本题建图时可用$map$映射，如果怕$TLE$可以写个哈希函数 ~~（反正我不会，谁教教我）~~。**可以用1~n的编号存左节点，n+1~2n的编号存右节点。** 其它题也可这么做。
```cpp
for(int i=1;i<=n;i++)//储存夫妻关系
{
	string A,B;
	cin>>A>>B;
	Num[A]=++num,Num[B]=num+n;
  //Num为字符串->编号的map，num为编号。
	addedge(num,num+n);//加边
	match[num+n]=num,match[num]=num+n;//匹配
}
//储存“情人”边的时候就简单了，只要根据map的值加边就可以。
```

------------

**2.** 没有必要跑完整一遍匈牙利，题目中给的“夫妻关系”一定是一对一的，所以题目**已经给了你一个完全匹配了** ，只需要在这个完全匹配上，**每次删去一组匹配关系和匹配边**，再跑匈牙利，**如果有增广路，就说明去除了这条边之后还能形成n对夫妻，反之则不能。**
```cpp
for(int i=1;i<=n;i++)
{
	CX=i,CY=match[i];//全局变量标记删除边
	match[CY]=0;//删除匹配关系
	if(dfs(i))cout<<"Unsafe\n";
	else cout<<"Safe\n";
	match[CY]=i;//复原匹配关系
	memset(visit,0,sizeof(visit));
}
```
**每次$dfs$最多访问$n$个节点，故时间复杂度为$O(N^2)=O(AC)$ 。**

------------

**3.** 由于本题的匈牙利只是为了判定有没有完全匹配，并不是求一个新的匹配，况且每一次还要将删去的边复原，所以在$dfs$的过程中不必记录新的匹配，只要返回$true/false$即可。
```cpp
bool dfs(int u)
{
	for(int i=hd[u];i;i=nx[i])
	{
		if(visit[to[i]]||(u==CX&&to[i]==CY))continue;
                //如果w(u,v)为删除边，则不能走。
		visit[to[i]]=true;
		if(!match[to[i]]||dfs(match[to[i]]))
		 return true;//不用记录新的match
	}
	return false;
}
```

------------

**4.** 注意数据范围：点数为$N*2$，边数为$(N+M)*2$ ，一不小心就很容易$RE$……~~惨痛的教训~~

## ③AC！
“居然几乎把全部代码都给了，真不像我的风格……”   
~~可能以后会更新tarjan做法（等我理解了之后）。~~    
喜欢就点个赞吧！


---

## 作者：千梦羽翼 (赞：18)

# 哈喽！

这次咱们来谈谈什么是强连同分量!

**强连通**(strongly connected)： 在一个有向图G里，设两个点 a b 发现，由a有一条路可以走到b，由b又有一条路可以走到a，我们就叫这两个顶点（a，b）强连通。


**强连通图**： 如果 在一个有向图G中，每两个点都强连通，我们就叫这个图，强连通图。


**强连通分量**strongly connected components)：在一个有向图G中，有一个子图，这个子图每2个点都满足强连通，我们就叫这个子图叫做 强连通分量 ［分量：：把一个向量分解成几个方向的向量的和，那些方向上的向量就叫做该向量（未分解前的向量）的分量

**tarjan算法**，之所以用DFS就是因为它将每一个强连通分量作为搜索树上的一个子树。而这个图，就是一个完整的搜索树。
为了使这颗搜索树在遇到强连通分量的节点的时候能顺利进行。每个点都有两个参数。


1，DFN［］作为这个点搜索的次序编号（时间戳），简单来说就是 第几个被搜索到的。％每个点的时间戳都不一样。


2，LOW［］作为每个点在这颗树中的，最小的子树的根，每次保证最小，like它的父亲结点的时间戳这种感觉。如果它自己的LOW［］最小，那这个点就应该从新分配，变成这个强连通分量子树的根节点。
ps：每次找到一个新点，这个点LOW［］＝DFN［］。


而为了存储整个强连通分量，这里挑选的容器是，堆栈。每次一个新节点出现，就进站，如果这个点有 出度 就继续往下找。直到找到底，每次返回上来都看一看子节点与这个节点的LOW值，谁小就取谁，保证最小的子树根。如果找到DFN［］＝＝LOW［］就说明这个节点是这个强连通分量的根节点（毕竟这个LOW［］值是这个强连通分量里最小的。）最后找到强连通分量的节点后，就将这个栈里，比此节点后进来的节点全部出栈，它们就组成一个全新的强连通分量。

原文地址：https://blog.csdn.net/qq_34374664/article/details/77488976

## **其实很简单的**：

**low[]**记录这个环的最小起点。

**low[u]=min（low[u],low[v])**是说当v结束回溯时看看带回来的这个low是否能更小。（因为我们发现在同一个强连通分量上low值时一样的，因为这个分量的起点都是相同的）

**low=min(low[u],dfn[u])**是因为由DFS性质，当u搜索道v时一系列的节点构成一个环的时候，这个v是在stack中的（联想SPFA——DFS找环），所以判断我的起点是否时最小的。（dfs[]是第一次访问的时候更新的，以后不会再跟新，是一个时间截）

最后如果这个点就是起点（dfn[u]==low[u])就将之前stack中这一系列的点弹出来，并更新dscllID数组（存放强连通分量编号）

## **看完了咱们来谈谈这题**：
![](https://cdn.luogu.com.cn/upload/pic/41833.png )

代码如下：

使用map映射，与num互相补充。（借鉴了 Manjusaka丶梦寒 的方法）orz orz zto （原来的写的样子~~奇丑无比~~）


```
#include<bits/stdc++.h>
#define N int(8e3+2)
#define M int(4e4+2)
using namespace std;
string f[N];
map <string,int> v;
string a,b;
int n,m,sum;
struct wsj {
	int nxt,to;
} edge[M];
int head[N],tot;
void add(int x,int y) {
	edge[++tot].nxt=head[x],edge[tot].to=y,head[x]=tot;
}
int dfn[N]={0},low[N]={0},tk=0;
int scllID[N];
bool in[N]; 
int cnt=0;
stack<int> st;
void tar(int x){
	dfn[x]=low[x]=++tk;
	in[x]=1;st.push(x);
	for (int j=head[x];j;j=edge[j].nxt){
		int v=edge[j].to;
		if (!dfn[v]){
			tar(v);
			low[x]=min(low[x],low[v]);
		}else if(in[v]) low[x]=min(low[x],dfn[v]);
	}
	if (dfn[x]==low[x]){
	  cnt++;int p;
	  do{
	  	p=st.top();st.pop();in[p]=0;
	  	scllID[p]=cnt;
	  }while(x!=p);
    }
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		cin>>a>>b;
		f[++sum]=a,v[a]=sum;
		f[++sum]=b,v[b]=sum;
		add(sum-1,sum);
	}
	scanf("%d",&m);
	for(int i=1; i<=m; i++) {
		cin>>a>>b;
		add(v[b],v[a]);
	}
	while(!st.empty()) st.pop();
	for (int i=1;i<=sum;i++)
	if (!dfn[i]) tar(i);
	for (int i=1;i<=2*n;i+=2){
		if (scllID[i]!=scllID[i+1]) printf("Safe\n");else printf("Unsafe\n");
	}
}
```



---

## 作者：Manjusaka丶梦寒 (赞：9)

这个题的题解好少哦，我来加一发吧。

戳这里阅读效果更佳哦：[luogu P1407 稳定婚姻-tarjan缩点](https://www.cnblogs.com/rmy020718/p/9291866.html)
###### 像我这样优秀的男人，又怎么会因稳定婚姻这点小事儿发愁呢。

### 思路解析：

看起来并不是太难。

题目中人名是字符串，我们当然不能用字符串了，我们以人名出现的顺序来编号。

我们用一个map型的 f数组表示f[ ][ ],表示人名的编号是几，例如：f[“dad”][8], 叫dad的编号是8.

然后就是建边了，在这个男性主宰的世界里，当然要女性向男性建边了(嗯？我说啥了么，我想没有吧)，单向边。

接下来的要重点注意了啊

输入的m行时，需要男性向女性建边，因为在上边时并且你需要让这牵连到的人连成环，所以我们是女性向男性建边的(仔细想想)。

搞明白上边就好办了，所点以后，判断每一个强联通分量中有几个点，要是有1个以上的点则表明婚姻有危险(单向边，夫妻之间若没有危险是不会在一个强联通分量中的)

每位夫妻判断一下其所在的环，输出就好啦(注意大小写，我在这挂掉了)

所以代码就好写了。
```cpp
/*....................
作者：Manjusaka
时间：2018/7/10
题目：P1407 [国家集训队]稳定婚姻  
......................*/

#include <iostream>
#include <cstdio>
#include <map>
#define N int(8e3+2)
#define M int(4e4+2)
using namespace std;
string f[N];
map <string,int> v;
string a,b;
int n,m,sum;
struct ahah{
    int nxt,to;
}edge[M];
int head[N],tot;
void add(int x,int y)
{
    edge[++tot].nxt=head[x],edge[tot].to=y,head[x]=tot;
}
int dfn[N],low[N],index;
int stark[N],top;
bool in[N];
int belong[N];
int cnt;
void tarjan(int u)
{
    dfn[u]=low[u]=++index;
    in[u]=1;stark[++top]=u;
    for(int i=head[u];i;i=edge[i].nxt)
    {
        int v=edge[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            if(low[v]<low[u])low[u]=low[v];
        }
        else if(in[v]&&low[u]>dfn[v])low[u]=dfn[v];
    }
    if(dfn[u]==low[u])
    {
        int p;
        cnt++;
        do
        {
            p=stark[top--];
            in[p]=0;
            belong[p]=cnt;
        }while(u!=p);
    }
}
int vis[N];
void chack()
{
    for(int i=1;i<=sum;i++)if(!dfn[i])tarjan(i);
    for(int i=1;i<=sum;i++)vis[belong[i]]++;
    for(int i=1;i<=n*2;i+=2)
    {
        if(vis[belong[v[f[i]]]]>1)printf("Unsafe\n");
        else printf("Safe\n");
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>a>>b;
        f[++sum]=a,v[a]=sum;
        f[++sum]=b,v[b]=sum;
        add(sum-1,sum);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        cin>>a>>b;
        add(v[b],v[a]);
    }
    chack();
}
```

---

## 作者：SSerxhs (赞：8)

题目已经把解法说明了:稳定婚姻，也就是二分图问题。

所以直接建立二分图，看是否存在增广路即可判断。

```cpp
#include <stdio.h>
#include <string.h>
#include <map>
using namespace std;
typedef unsigned long long ull;
const int N=4e3+2,M=2e4+2;
const ull p=200;
map<ull,int> ys;
ull x;
int lj[M],nxt[M],fir[N],ed[N],lk[N],yl[N];
int n,m,i,j,c,bs,cnt;
bool wd[N];
inline void add(int x,int y)
{
    lj[++bs]=y;
    nxt[bs]=fir[x];
    fir[x]=bs;
}
int dfs(int x)
{
    int i;
    for (i=fir[x];i;i=nxt[i]) if (ed[lj[i]]!=cnt)
    {
        ed[lj[i]]=cnt;
        if ((!lk[lj[i]])||(dfs(lk[lj[i]])))
        {
            lk[lj[i]]=x;
            return 1;
        }
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    c=getchar();
    for (i=1;i<=n;i++)
    {
        while ((c<'A')||(c>'z')) c=getchar();
        x=0;
        while ((c>='A')&&(c<='z'))
        {
            x=x*p+(ull)c;
            c=getchar();
        }
        ys[x]=i;
        while ((c<'A')||(c>'z')) c=getchar();
        x=0;
        while ((c>='A')&&(c<='z'))
        {
            x=x*p+(ull)c;
            c=getchar();
        }
        yl[i]=ys[x]=i;
    }
    scanf("%d",&m);
    while (m--)
    {
        while ((c<'A')||(c>'z')) c=getchar();
        x=0;
        while ((c>='A')&&(c<='z'))
        {
            x=x*p+(ull)c;
            c=getchar();
        }
        i=ys[x];
        while ((c<'A')||(c>'z')) c=getchar();
        x=0;
        while ((c>='A')&&(c<='z'))
        {
            x=x*p+(ull)c;
            c=getchar();
        }
        j=ys[x];
        add(i,j);
    }
    for (i=1;i<=n;i++) if (!wd[i])
    {
        memcpy(lk,yl,sizeof(yl));
        lk[i]=0;
        if (dfs(cnt=i))
        {
            for (j=i;j<=n;j++) if (lk[j]!=j) wd[j]=1;
        }
    }
    for (i=1;i<=n;i++) if (!wd[i]) puts("Safe"); else puts("Unsafe");
}
```


---

## 作者：喻文州 (赞：6)

关于这道题，我首先想说的是：

## 题面过于鬼畜

具体怎么鬼畜、有多鬼畜、哪里鬼畜详见讨论区（笑到头掉）！

这题的**大众做法**大家都会（指来指去的），但是从讨论区看出大家好像**并不是很能理解**……

那就让我们来分析一下这个大众做法吧！

**前置芝士：Tarjan求强连通分量**
[这是日报](https://www.luogu.org/blog/styx-ferryman/chu-tan-tarjan-suan-fa-qiu-qiang-lian-tong-fen-liang-post)
[这是板子](https://www.luogu.org/problem/P2341)
# 一、究竟谁指谁

按照题解区的主流，一句话总结就是：
```
情人男指女，夫妻女指男
```

可是，**真的是这样吗？**
我用事实告诉你，**不然**！[（反着指AC实例）](https://www.luogu.org/record/26036689)

其实这个容易看出，因为根据著名的Kosaraju算法的原理，一个图反向连边的强连通分量和原图是一样的。所以，只要**两次连的边方向不一样就行了**

而这样指又有什么用呢？让我们来分析一下样例：

# 二、指来指去的用处
首先鉴于题目的名字实在是**没有什么意思**，我们仿照样例重新画一张图：
![](https://ae01.alicdn.com/kf/H9e90b571819340ca9d37b3301bebc441y.jpg)

这里，我们请出了~~日本著名文学家~~横滨港口著名侦探和黑手党：
**太宰(dazai)治、中原(Nakahara)中也、芥川(Ryunosuke)龙之介、中岛(Nakajima)敦**！

你告诉我性别有问题？当然是因为~~这样你们就不会关心男男女女的了~~**就是没有问题**！

在这张图中我们用紫色线表示**共事关系**，用蓝色线表示**曾经有过关系**。A组的成员表示主要负责人，B组的成员表示助手。（为什么是共事关系？当然是因为~~怕你们想多了~~原题过于鬼畜）

我们把“**指向**”定义为一种“**投靠关系**”，就是如果有任务的话这个人会去找谁。

首先我们**让所有搭档都闹翻**。我们假定**关系破裂**都是因为**主要负责人叛变**导致的，那么按照题意他会**去找曾经有过关系的非搭档的人**，而不知道情况的助手领到任务只会去找他的主要负责人。如下图：

![](https://ae01.alicdn.com/kf/Hc4543350bdea4a75ab734e6fc7a45194E.jpg)

或者下图:

![](https://ae01.alicdn.com/kf/H4d3d73217d7f4f2aa228c824b39750922.jpg)

这时**关系稳定的标志**就是：有一个任务出现的时候，不论是谁领到的，如果不找原先的搭档，就不能找到人了。

**那么为什么会形成一个强连通分量呢？**

首先我们来看环的情况。把上图的点重新布局一下，容易得到这样一个环形：
![](https://ae01.alicdn.com/kf/H3d68617f924741c1812521022ab77534C.jpg)

每个人只要**沿着环找下去**，总能找到一个人共事的。因为将曾经的关系当做等价的线条考虑进去了，所以肯定有人没有找自己现在的搭档。

当图不再是环的时候呢？

我们再引入两个点：**森(Mori)欧外和尾崎(Ozaki)红叶**(就是莫得图)，然后乱加一些关系：![](https://ae01.alicdn.com/kf/H0161e7a784ce43e38aa5c2cb3b27da06V.jpg)

此时我们可以得到这样一个强连通分量：

![](https://ae01.alicdn.com/kf/H9d4fa19d6b73455f9ba2246fadcd738b2.jpg)

那这样的强连通分量为什么是**不稳定的关系**呢？因为强连通分量的点**两两可达**，所以不存在一个人孤苦无依的情况。

这样，只要**沿着“指向”的箭头寻找**，每个人一定能找到一个空的伙伴和他搭档。（因为两两互达的缘故，就算是一开始找错人，这个步骤重复一定次数肯定能安排上掉的！）

这时如果**双方都在一个强连通分量里面**，那么他们**一定可以找到**~~NTR~~**换搭档**的方法。（因为搭档双方是不相互指的）

这个时候双向边就明显不适应了（会使得“指向”关系不符合我们的预期），所以只能是单向边。

# 三、~~口胡~~实现方法
理解了这个，究竟谁叛变不叛变已经无所谓了，因为~~明明拆了重组也很好吃啊~~这个代码已经可以写了。

我们只要给不同的强连通分量染色，然后看看**夫妻双方在不在同一个强连通分量里面**（因为这样就是戴绿帽子了）就好。

存图可以考虑用map提供的hash对应字符串和标号，当然采用其他的办法对应也可以。这里因为懒就采用大众的map做法了。

## AC code（特地安排了反着指的）:
```cpp
#include<iostream>
#include<map>
using namespace std;
#define N 8010
#define M 40010
struct line
{
	int to,next;
}ed[M];
map <string,int> a;//这里
int dfn[N],low[N],head[N],cnt,tot,n,m;
bool ins[N];
int s[N],top,color[N],sum,deep;
void addline(int u,int v)
{
	ed[++cnt].to=v;
	ed[cnt].next=head[u];
	head[u]=cnt;
}
void tarjan(int pos)//板子
{
	dfn[pos]=++deep;
	low[pos]=deep;
	ins[pos]=1;
	s[++top]=pos;
	for(int i=head[pos];~i;i=ed[i].next)
	{
		int y=ed[i].to;
		if(!dfn[y])
		{
			tarjan(y);
			low[pos]=min(low[pos],low[y]);
		}
		else
		{
			if(ins[y])
				low[pos]=min(low[pos],low[y]);
		}
	}
	if(dfn[pos]==low[pos])
	{
		color[pos]=++sum;
		ins[pos]=0;
		while(s[top]!=pos)
		{
			color[s[top]]=sum;
			ins[s[top]]=0;
			top--;
		}
		top--;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n+n;i++)
		head[i]=-1;
	string s1,s2;
	for(int i=1;i<=n+n;i+=2)//女单男双
	{
		cin>>s1>>s2;
		a[s1]=i;
		a[s2]=i+1;
		addline(i+1,i);
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>s1>>s2;
		addline(a[s1],a[s2]);
	}
	for(int i=1;i<=n+n;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=n+n;i+=2)//分析婚姻
	{
		if(color[i]==color[i+1])//可以戴绿帽
			cout<<"Unsafe"<<endl;
		else
			cout<<"Safe"<<endl;
	}
	return 0;
}
```

最后，因为本蒟蒻太菜，欢迎摘虫和hack！

---

## 作者：NTG_Adiord (赞：6)

考虑把第一次读入的情侣对看做同一个点

然后再建边求环就好了

具体代码解释

```cpp
#include <bits/stdc++.h>
using namespace std;
struct nod{
	int g;
	int b;
}per[8010];
//能结构体解决的问题为什么要建边啊(x)
map<string,int> sti;
int n,m;
int pn;
int ll;
int to[80100];
int hea[80100];
int bel[80100];
int nex[80100];
//第一眼把40%数据看成100%数据的我
int dfn[80100];
int low[80100];
int Bnum;
int ins[80100];
int be[80100];
int lon[80100];
stack<int> stac;
int df;
//tarjan就不解释了，不会的去做隔壁缩点
void tar(int u){
	dfn[u]=low[u]=++df;
	stac.push(u);
	ins[u]=1;
	for(int i=hea[u];i;i=nex[i]){
		int v=to[i];
		if(!dfn[v]){
			tar(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		Bnum++;
		while(stac.top()!=u){
			be[stac.top()]=Bnum;
			ins[stac.top()]=0;
			lon[Bnum]++;
			stac.pop();
		}
		if(stac.top()==u){
			be[stac.top()]=Bnum;
			ins[stac.top()]=0;
			lon[Bnum]++;
			stac.pop();
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		string a,b;
		cin>>a>>b;
		sti[a]=++pn;sti[b]=++pn;
		bel[sti[a]]=i;
		bel[sti[b]]=i;
        //预处理,bel表示这个人属于哪一组
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		string a,b;
		cin>>a>>b;
		int u=bel[sti[a]];int v=bel[sti[b]];
		to[++ll]=u;nex[ll]=hea[v];hea[v]=ll;
        //建边，g连b b连g都行
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])tar(i);
        //tarj不解释
	}
	for(int i=1;i<=n;i++){
    //>=2说明在环里
		if(lon[be[i]]>=2)printf("Unsafe\n");
		else printf("Safe\n");
	}
}

```
~~第一眼把40%数据给当成100%数据，太惨了~~

---

## 作者：Ηydra (赞：5)


[blog观看效果更佳哦qwq](https://www.cnblogs.com/happyLittleRabbit/p/11728871.html)


建图方式：旧关系女人连男人，现关系男人连女人(当然，反过来也可以)

原因可以这样考虑：

如果一个男的把女的绿了，那么这个女人就会去找一个她曾经交往过的男人，也就是在这种情况下，某种“影响”会顺着旧关系从女人传到男人，而此时这个男人又会顺着原关系把这种“影响”传给另一个女人；如果这种“影响”传回了那个男人，就说明那个男人也成功配对，并且这种“影响”的传递路径上正向边和反向边的个数相同(即被打破的关系数和新建立的关系数相同)，所以这个婚姻就不稳定。

所以建完图后可以跑Tarjan，如果一对夫妇在同一个SCC中，这个婚姻就不稳定。

```C++
#include <cstdio>
#include <iostream>
#include <map>
#include <string>
using namespace std;
map<string, int> M;
const int MAXN = 200000;
int cnt;
int head[MAXN], nxt[MAXN], to[MAXN];
int tot;
void ins(int u, int v)
{
	nxt[++cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
}
int dfn[MAXN], low[MAXN], clo[MAXN];
int vis[MAXN], sta[MAXN], top;
void tarjan(int u)
{
	sta[++top] = u;
	dfn[u] = low[u] = ++tot;
	vis[u] = 1;
	for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])
		if (!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if (vis[v])
			low[u] = min(low[u], dfn[v]);
	if (low[u] == dfn[u])
	{
		clo[u] = u;
		vis[u] = 0;
		int y;
		while ((y = sta[top--]) != u)
			clo[y] = u, vis[y] = 0;
	}
}
int main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n, m;
	int u, v;
	string girl, boy;
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
		cin >> girl;
		u = M[girl] = ++tot;
		cin >> boy;
		v = M[boy] = ++tot;
		ins(u, v);
	}
	cin >> m;
	tot = 0;
	for (int i = 1; i <= m; ++i)
	{
		cin >> girl;
		cin >> boy;
		v = M[girl];
		u = M[boy];
		ins(u, v);
	}
	for (int i = 1; i <= (n << 1); ++i)
		if (!dfn[i])
			tarjan(i);
	for (int i = 1; i <= n; ++i)
		if (clo[i << 1] == clo[(i << 1) - 1])
			cout << "Unsafe\n";
		else
			cout << "Safe\n";
	return 0;
}
```

---

## 作者：谁是鸽王 (赞：2)

## 【题解】[**P1407** [国家集训队\]稳定婚姻](https://www.luogu.org/problemnew/show/P1407) 

很好的一道建模+图论题。

婚姻关系？很像二分图匹配呀，不过不管怎么办先建模再说。婚姻关系显然用图方面的知识解决。建图！

它给定的是字符串，所以我们使用~~$ac$自动机~~$map$作匹配建点。

题意就是给你$n$对夫妻关系和$m$对情人关系，已知情人关系都可以结婚，现在假设对于某个婚姻，如果离婚，这$2n$个人最终依然能够结合成$n$对情侣，那么这样的婚姻是不稳定的。现在问每个婚姻关系的稳定性。

考虑什么样的婚姻关系是不稳定的。题目给的意思是，"这$2n​$个人最终依然能够结合成$n​$对情侣"，我们仔细分析一下，发现如下性质：

- 依然结合成$n$对情侣，和这对情侣没有任何间接或直接关系的人可以忽略。$(*)$
- 假设有两对婚姻，加入他们的男方女方分别互为情人关系，这两对婚姻都不稳定。$(**)$

根据以上两点，我们发现，假若婚姻$a​$的一个成员喜欢婚姻$b​$的一个成员，那么相当于婚姻$a​$和婚姻$b​$连接了半条边。假若婚姻$a​$的另一个成员也喜欢$b​$的另一个成员那么又连了半条边。假设两个婚姻最终形成了一条边，那么他们就不稳定了！

我们考虑令情人中全是女孩子喜欢男孩子~~(谁叫我是男$oier$呢)(笑)~~，婚姻中都是互相连边，那么假设有一个强联通分量里有偶数个人，(且不是偶数不是二)，那么在这个强联通分量里的婚姻就是不稳定的。

讲不清楚QAQ直接上代码吧。

```cpp
#include<bits/stdc++.h>

using namespace std;
#define RP(t,a,b) for(register int t=(a),edd=(b);t<=edd;++t)
#define DRP(t,a,b) for(register int t=(a),edd=(b);t>=edd;--t)
#define ERP(t,a) for(register int t=head[a];t;t=e[t].nx)
#define Max(a,b) ((a)<(b)?(b):(a))
#define Min(a,b) ((a)<(b)?(a):(b))
#define midd register int mid=(l+r)>>1
#define TMP template < class ccf >

TMP inline ccf qr(ccf b){
    char c=getchar();
    int q=1;
    ccf x=0;
    while(c<48||c>57)
	q=c==45?-1:q,c=getchar();
    while(c>=48&&c<=57)
	x=x*10+c-48,c=getchar();
    return q==-1?-x:x;
}

const int maxn=4004<<1;
map < string ,int > mp;
int n,m;
struct E{
    int to,nx;
}e[(maxn<<1)+(20001<<1)];
int cnt;
int head[maxn];
bool in[maxn];
int dfn[maxn];
int low[maxn];
int stk[maxn];
int be[maxn];
int siz[maxn];
int timer;
int qaq;
int top;

void dfs(int now){
    stk[++top]=now;
    in[now]=1;
    dfn[now]=low[now]=++timer;
    ERP(t,now){
	if(!dfn[e[t].to]){
	    dfs(e[t].to);
	    low[now]=Min(low[now],low[e[t].to]);
	}
	else
	    if(in[e[t].to])
		low[now]=Min(low[now],dfn[e[t].to]);
    }
    if(dfn[now]==low[now]){
	qaq++;
	register int temp;
	do{
	    temp=stk[top--];
	    in[temp]=0;
	    be[temp]=qaq;
	    ++siz[qaq];
	}while(top&&temp!=now);
    }
}

inline void add(int fr,int to,bool f){
    e[++cnt]=(E){to,head[fr]};
    head[fr]=cnt;
    if(f)
	add(to,fr,0);
}

int mapcnt;
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    string t1,t2;
    n=qr(1);
    RP(t,1,n){
	cin>>t1>>t2;
	mp[t1]=++mapcnt;
	mp[t2]=++mapcnt;
	add(mapcnt,mapcnt-1,1);
    }
    m=qr(1);
    RP(t,1,m){
	cin>>t1>>t2;
	add(mp[t1],mp[t2],0);
    }
    RP(t,1,mapcnt)
	if(!dfn[t])
	    dfs(t);
    RP(t,1,n){
	if((siz[be[t<<1]]&1)||siz[be[t<<1]]==2)
	    puts("Safe");
	else
	    puts("Unsafe");
    }
    return 0;
}

```



---

## 作者：晚安晚安 (赞：2)

### 大家好啊大家好

这道题已经有很多大佬解释过了怎么做,但是作为一名蒟蒻,一开始不是很理解这道题能用强连通配对的原因,后来自己用一种很暴力的想法想明白了:

首先输入是 女->男 的顺序

这道题最终的目的就是 -> 如果 : 第i对夫妻离婚之后, 能不能找到某个范围内的夫妻,能够互相交换自己的对象( 社会主义的爱情(笑) )

首先我们在输入合法夫妻的时候,用左边的女性指向右边的男性( 当然哈希是不可少的,直接用了map,通过输入名字的顺序存下点 )

注意了! 这时候我们要输入情人关系了, 这时候我们需要的是当合法夫妻离婚的时候,不管是男方还是女方 能不能 有 另外的 女的和男的 可以和他们结婚,同时另外的那两个人的婚姻破裂之后也要满足这个要求

这个时候就会嗅到有某个连成环的关系维系着某几对夫妻,为了连成环,第二次输入可以选择男连女或女连男,但是模拟一下可以发现,只有第二次和第一次反着连才能形成环,于是便有了代码思路:

建图, 然后跑tarjan缩点

上菜:
```
#include <iostream>
#include <cstdio>
#include <map>
#include <vector>
#include <stack>
using namespace std;
int Min(int a, int b){if(a<b)return a; return b;}
int n, t, cnt, col_num;
int low[8000+5], dfn[8000+5], color[8000+5];
bool vis[8000+5];
map <string, int> ma;
vector <int> vec[8000+5];
stack  <int> sta;
void tarjan(int x)
{
    dfn[x] = low[x] = ++cnt;
    vis[x] = true;
    sta.push(x);
    for(int i = 0; i < vec[x].size(); ++i)
    {
        int to = vec[x][i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x] = Min(low[x], low[to]);
        }
        else if(vis[to])low[x] = Min(low[x], dfn[to]);
    }
    if(dfn[x]==low[x])
    {
        vis[x] = false;
        while(sta.top()!=x)
        {
            vis[sta.top()] = false;
            sta.pop();
        }
    }
}
int main()
{
    scanf("%d", &n);
    string s1, s2;
    for(int i = 1; i <= n; ++i)
    {
        cin>>s1>>s2;
        ma[s1] = ++cnt;
        ma[s2] = ++cnt;
        vec[ma[s1]].push_back(ma[s2]);
    }
    scanf("%d", &t);
    for(int i = 1; i <= t; ++i)
    {
        cin>>s1>>s2;
        vec[ma[s2]].push_back(ma[s1]);
    }
    cnt = 0;
    for(int i = 1; i <= n*2; ++i)
        if(!dfn[i])tarjan(i);
    cnt = 0;
    for(int i = 1; i <= n; ++i)
    {
        if(low[++cnt]==low[++cnt])
            printf("Unsafe\n");
        else
            printf("Safe\n");
    }
    return 0;
}
```

---

## 作者：FREEH (赞：2)

P1407总结

【题目大意】
有几对夫妻，和几对情人，如果情人的两人都离婚了，那么他们可以再结为夫妻。对于每一对夫妻，他们离婚后如果所有人都是结婚状态的，那么这就是不安全的，否则是安全的。问每一对夫妻是否安全。

【解题思路】
构图：夫妻之间女->男，情人之间男->女，然后跑一遍Tarjan缩点，最后判断每一对夫妻是否在同一个点里，如果在就是不安全，反之安全。

【参考程序】

```
#include<cstdio>
#include<map>
#include<string>
#include<cstring>
using namespace std;
const int N=200000,M=200000;
int cur,tot,top,Index,n,m;
int head[N],DFN[N],In[N],state[N],LOW[N],color[N],sta[N];
struct EDGE{
	int t,next;
}e[M];
void add(int a,int b)
{
	cur++;
	e[cur].t=b;
	e[cur].next=head[a];
	head[a]=cur;
}
void Tarjan(int x)
{  
    sta[++top]=x;
    In[x]=1;
    DFN[x]=LOW[x]=++Index;
    for(int i=head[x];i!=-1;i=e[i].next)
	{
        int v=e[i].t;
        if(!DFN[v])
		{
            Tarjan(v);
            LOW[x]=min(LOW[x],LOW[v]);
        }
        else 
		if(In[v]){
            LOW[x]=min(LOW[x],DFN[v]);
        }
    }
    if(DFN[x]==LOW[x])
	{
        tot++;
        while(sta[top+1]!=x)
		{
            color[sta[top]]=tot;
            In[sta[top--]]=0;
        }
    }
}
map <string,int> num;
int main()
{
	scanf("%d",&n);
	memset(head,-1,sizeof(head));
	char a[10],b[10];
	for (int i=1;i<=n;i++)
	{
		scanf("%s%s",a,b);
		num[a]=i;
		num[b]=n+i;
		add(i,n+i);
	}
	scanf("%d",&m);
	for (int i=1;i<=m;i++)
	{
		scanf("%s%s",a,b);
		add(num[b],num[a]);
	}
	for (int i=1;i<=2*n;i++)
		if (!DFN[i])
			Tarjan(i);
	for (int i=1;i<=n;i++)
		if (color[i]==color[n+i])
		printf("Unsafe\n");
		else
		printf("Safe\n");
	return 0;
}

---

## 作者：封禁用户 (赞：0)

## Ad
个人博客高清重制版同步：http://www.cinema000.xyz/1545.ruby
## 分析

这里建图比较玄学，弄一个map就好了。

因为SCC是对于有向图的，而我们直接连边的话就是无向图的，这样我们就交替连边就好了，即：

夫妻：♀$\to$ ♂

情人：♂$\to$ ♀

这样就有有向边了233。然后这里求SCC继续用Kosaraju算法。

## 代码

```CPP
#include<cstdio>
#include<vector>
#include<string>
#include<iostream>
#include<map>
const int MAXN = (4000 + 6) * 5;
std::map<std::string,int> H;
struct Edge{int v,d;Edge(int v,int d){this -> v = v;this -> d = d;}};
class SCC{
public:
	std::vector<Edge> G[MAXN],G2[MAXN];
	std::vector<int> S;
	bool hash[MAXN];
	int SCCCnt,SCCNo[MAXN];
	void addEdge(int u,int v,int d){
		G[u].push_back(Edge(v,d));
		G2[v].push_back(Edge(u,d));
	}
	void dfs1(int u){
		if(hash[u]) return;
		hash[u] = true;
		for(int i = 0;i < G[u].size();i++) dfs1(G[u][i].v);
		S.push_back(u);
	}
	void dfs2(int u){
		if(SCCNo[u]) return;
		SCCNo[u] = SCCCnt;
		for(int i = 0;i < G2[u].size();i++) dfs2(G2[u][i].v);
	}
	void findSCC(int n){
		SCCCnt = 0;
		for(int i = 1;i <= n;i++) dfs1(i);
		for(int i = n - 1;i >= 0;i--) if(!SCCNo[S[i]]){SCCCnt++;dfs2(S[i]);}
	}
};
int main(){
	SCC s;
	int n,cnt = 0;std::cin >> n;
	std::string u,v;
	for(int i = 1;i <= n;i++){
		std::cin >> u >> v;
		H[u] = i;
		H[v] = n + i;
		s.addEdge(H[u],H[v],666);
	}
	int m;scanf("%d",&m);
	while(m--){
		std::cin >> u >> v;
		s.addEdge(H[v],H[u],666);
	}
	s.findSCC(2 * n);
	for(int i = 1;i <= n;i++) 
		if(s.SCCNo[i] == s.SCCNo[n + i]) printf("Unsafe\n");
		else printf("Safe\n");
	
	return 0;
}
```



---


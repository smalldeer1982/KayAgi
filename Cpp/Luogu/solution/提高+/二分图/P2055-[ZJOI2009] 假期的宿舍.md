# [ZJOI2009] 假期的宿舍

## 题目描述

学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。

比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。

我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。


## 说明/提示

对于 $30\%$ 的数据满足 $1 \le n \le 12$。

对于 $100\%$ 的数据满足 $1 \le n \le 50$，$1 \le T \le 20$。


## 样例 #1

### 输入

```
1
3
1 1 0
0 1 0
0 1 1
1 0 0
1 0 0```

### 输出

```
^_^```

# 题解

## 作者：Drinkkk (赞：106)

【题目描述】

学校放假了......有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。比如A和B都是学校的学生，A要回家，而C来看B，C与A不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是B睡A的床而C睡B的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。我们已知一共有$n$个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。

【输入输出格式】

- 输入格式

第一行一个数$T$表示数据组数。接下来$T$组数据，每组数据第一行一个数$n$表示涉及到的总人数。接下来一行$n$个数，第$i$个数表示第$i$个人是否是在校学生($0$表示不是，$1$表示是)。再接下来一行$n$个数，第$i$个数表示第$i$个人是否回家($0$表示不回家，$1$表示回家，注意如果第$i$个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。接下来$n$行每行$n$个数，第$i$行第$j$个数表示$i$和$j$是否认识($1$表示认识，$0$表示不认识，第$i$行$i$个的值为$0$，但是显然自己还是可以睡自己的床)，认识的关系是相互的。

- 输出格式

对于每组数据，如果存在一个方案则输出“^\_^”(不含引号)否则输出“T\_T”(不含引号)。(注意输出的都是半角字符，即三个符号的 ASCII 码分别为94,84,95)。

【输入输出样例】

- 输入样例

```cpp
1
3
1 1 0
0 1 0
0 1 1
1 0 0
1 0 0

```
- 输出样例

```cpp
^_^
```
【数据范围】

对于$30$%的数据满足$1 \leq n \leq 12$。

对于$100$%的数据满足$1 \leq n \leq 50$，$1 \leq T \leq 20$。

思路：

这道题很明显就是一道二分图的最大匹配问题，当然这道题也可以用网络流来做，在讲完二分图匹配的思路后就会讲解最大流的思路了。你可以在[这里](https://www.luogu.org/problemnew/show/P3386)检测你码的二分图最大匹配的模板的正确性。下面将详细地讲解二分图最大匹配这一算法。这里提出的二分图最大匹配问题与洛谷上的模板略有不同。如果你还没有理解什么是二分图匹配的话，那么就去学习下面的教程吧（教程转自《啊哈！算法》，放入题解时有删改）。

 ![](https://cdn.luogu.com.cn/upload/pic/13688.png) 

小哼今天和小伙伴们一起去游乐场玩，终于可以坐上梦寐以求的过山车了。过山车的每一排只有两个座位，为了安全起见，每个女生必须与一个男生坐一排。但是，每个人都希望与自己认识的人坐在一起。举个例子吧，$1$好女生与$1$号男生互相认识，因此$1$号女生可以和$1$好男生坐在一起。另外$1$号女生与$2$号男生互相认识，因此他们也可以坐在一起。像这样的关系的还有$2$号女生和$2$号男生、$2$号女生和$3$号男生、$3$号女生和$1$号男生。请问如何安排座位才能让更多的人满意呢？这仅仅是个例子。实际情况要复杂得多，因为小哼的小伙伴们实在是太多了。

 ![](https://cdn.luogu.com.cn/upload/pic/13773.png) 

首先我们先将这个问题模型化，如上图，左边的顶点是女生，右边的顶点是男生。如果顶点之间右边，就表示他们可以坐在一起，像这样特殊的图叫做二分图（注意二分图是无向图哦）。对于上面的例子，我们很容易找出两种分配方案，如下。

 ![](https://cdn.luogu.com.cn/upload/pic/13774.png) 

- **二分图的定义**

> 1. 如果一个图的所有的顶点都可以被分成$x$和$y$两个集合，并且所有边的两个顶点恰好属于一个集合$x$，另一个属于集合$y$，即每个集合内的顶点没有边相连，那么这张图就是二分图。

> 2. 设$G=(V,E)$是一个无向图，如果顶点V可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i,j)$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集($i$ ∈ $A$,$j$ ∈ $B$)，则称图$G$为一个二分图。

很显然，右边的分配方案更好。我们把一种分配方案叫做一种匹配。那么现在的问题就演变成了求二分图的最大匹配（匹配对数多）。求最大匹配容易想到的办法是：找出全部匹配，然后输出配对数最多的。这种方法的时间复杂度是非常之高的，那还有没有更好的办法呢？
    我们可以这么想，首先先从左边的$1$号女生开始考虑。先让她与$1$号男生配对，配对成功后就考虑$2$号女生与$2$号男生配对，接下来考虑$3$号女生。此时我们发现$3$号女生只能够跟$1$号男生配对，可是$1$号男生已经配对给了$1$号女生了，怎么办？其实我们可以让$3$号女生跟$1$号男生谈。让与$1$号男生相配对的$1$号女生一起谈，看看一号女生能不能够找到其他的同伴。如果能够找到，就让$3$号女生与$1$号男生坐在一起，让$1$号女生与$1$号女生相配对的那个人坐在一起，若$1$号女生找到的其他的可以与$1$号女生配对的人已经有同伴的话就让他的同伴去找，看看其他人能否作为她的同伴，然后以此类推。若第$i$名男生找到了同伴，就将答案加$1$。刚才的匹配过程就叫做**增广路**，不难发现，只要找到了一条增广路答案就会加$1$，最后只需要输出答案即可。
下面给出两组数据用于检测您的程序的正确性（注：$1$到$3$号是男生，$4$到$6$号是女生）：

- 数据输入$1$

```cpp
6 5
1 4
1 5
2 5
2 6
3 4

```
- 数据输出$1$

```cpp
3
```

- 数据输入$2$

```cpp
6 4
1 4
2 5
2 6
3 4

```
- 数据输出$2$

```cpp
3
```
下面就是二分图最大匹配的模板：

```cpp
#include <cstdio>
int book[10001];
int match[10001];
bool e[101][101];
int ans=0,n=0,m=0;
bool dfs(int u)
{
    for(int i=1;i<=n;i++)
    {
        if(book[i]==0 && e[u][i]==true)
        {
            book[i]=1;
            if(match[i]==0 || dfs(match[i])==true)
            {
                match[u]=i;
                match[i]=u;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x=0,y=0;
        scanf("%d %d",&x,&y);
        e[x][y]=true;
        e[y][x]=true;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            book[j]=0;
        }
        if(dfs(i)==true)
        {
            ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```
那么既然二分图最大匹配的思路讲完了，我们就要开始尝试去用二分图最大匹配来解决这道题目了。我们可以**把人分给床**。下面是几种情况：
1. 如果他在学校住并且是本校学生，那么就让他睡回自己的床。

2. 如果他在不在学校住或者他不回家，且他找不到自己的床。那么就返回$false$，$false$表示不存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住，否则当返回$true$时就表示存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。

3. 如果他可以和这张床配对（即他认识这张床的主人），如果现在还没有人和这张床配对的话就直接让他和这张床配对，否则就看看现在与这张床配对的人可不可以找到另一张床可以和他配对，如果可以就让那个原本和那张床配对的人去和他找到的另一张可以与他配对的床相配对。再让这张现在没有配对的人与一开始提到的那个人相配对。

下面是一些注意事项：

1. 是人认识床的主人，所以才能够睡在这张床上。所以连的是单向边，不是双向边。

2. 要初始化，因为有多组数据。


讲完了二分图匹配的思路，下面就讲一讲网络流的思路吧，如下。你可以在[这里](https://www.luogu.org/problemnew/show/P3376)检验你的网络流模板的正确性。下面将详细地讲解网络流这一算法。

对于下图，我们很容易就能够看出来这是一张**单向图**。

![](https://cdn.luogu.com.cn/upload/pic/14016.png)

现在，我们给这几条边标上流量（也可以说是边权或者是最大流量）。注意，现在要标上流量的是边而不是点。什么是流量？我们不妨把从$x$点到$y$点的最大流量当做从$x$点到$y$点可以流过去的**最大的**水的重量，求从起始点处打开水龙头，让水通过这些“水管”（即边）流到到结束点处。现在我们的问题是，有$n$个点$m$条边，求源点到汇点的最大流量是多少。源点即起点，汇点即终点。在这里，我们的源点是$1$，汇点是点$2$。

![](https://cdn.luogu.com.cn/upload/pic/14017.png)

下面我们给这些点标层，如下。

![](https://cdn.luogu.com.cn/upload/pic/14019.png)

你会发现那些没有被标到层的都是无法到达的。于是我们便可以用广搜来判断能否到达汇点，若能够到达就计算有多少的流量能够流到汇点即可，当然，前提是还有水可以流过去。但是我们要注意一点：流过去的水如果留不到汇点还会流回来，因此我们对每一条单向边建一条流量为$0$的反向边即可，当有水流回来的时候加上反向边的流量即可。还有一点要注意的是，因为我们流水过去到汇点的次数可能会有多次，所以我们要加一个循环来完成网络流的整个过程。

下面上网络流的模板，你可以根据网络流的模板来进行进一步的学习，同时也感谢@liusu201601的建议。

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
struct nodea{ int x,y,d,g,f; } e[2000002];
struct nodeb{ int first,h; } r[1000001];
int q[1000001],len=0,m=0,n=0,st=0,ed=0;
int min(int x,int y)
{
	return x<y?x:y;
}
void ins(int x,int y,int d)
{
	len++;
	
	e[len].x=x;
	e[len].y=y;
	e[len].d=d;
	e[len].g=r[x].first;
	r[x].first=len;
	
	len++;
	
	e[len].x=y;
	e[len].y=x;
	e[len].d=0;
	e[len].g=r[y].first;
	r[y].first=len;
	
	e[len].f=len-1;
	e[len-1].f=len;
}
bool bfs()
{
	int tou=1,wei=2;
	for(int i=1;i<=n;i++)
	{
		r[i].h=0;
	}
	r[st].h=1;
	
	memset(q,0,sizeof(q));
	q[1]=st;
	
	while(tou!=wei)
	{
		int x=q[tou];
		for(int i=r[x].first;i>0;i=e[i].g)
		{
			int y=e[i].y;
			if(e[i].d>0 && r[y].h==0)
			{
				r[y].h=r[x].h+1;
				q[wei]=y;
				wei++;
			}
		}
		tou++;
	}
	if(r[ed].h>0)
	{
		return true;
	}
	return false;
}
int dfs(int x,int f)
{
	if(x==ed)
	{
		return f;
	}
	int tt=0;
	for(int i=r[x].first;i>0;i=e[i].g)
	{
		int y=e[i].y;
		if(r[x].h+1==r[y].h && tt<=f && e[i].d>0)
		{
			int my=dfs(y,min(e[i].d,f-tt));
			tt+=my;
			e[i].d-=my;
			e[e[i].f].d+=my;
		}
	}
	if(tt==0)
	{
		r[x].h=0;
	}
	return tt;
}
int main()
{
	scanf("%d %d %d %d",&n,&m,&st,&ed);
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0,d=0;
		scanf("%d %d %d",&x,&y,&d);
		ins(x,y,d);
	}
	int ans=0;
	while(bfs()==true)
	{
		ans+=dfs(st,2099999999);
	}
	printf("%d",ans);
	return 0;
}
```

那么，对于网络流，该如何建图呢？
1. 将人与源点连线，并将床与汇点连线。在这里，我用$i$来表示第$i$个人，用$i+n$来表示第$i$张床。

2. 若一个人有床（即这个人是在下学生）就将这张床与汇点连线。若一个人需要床（即是本校学生的好朋友或是本校学生在这里住），就将其与源点相连线。若$i$认识$j$，那么$i$就可以睡$j$的床，那么就将$i$和$j$的床相连线，即将$i$和$j+n$相连线。

3. 因为有多组数据，要注意将数组都初始化。一开始我就因为有两个数组忘了初始化造成了死循环，但是将这几组数据拆开后又是对的，这可能就是你的初始化没有初始化好了。一开始我就是因为没有初始化错了好几次，后来才通过的。

下面上$100$分代码~

二分图匹配：

```cpp
#include <cstdio>
#include <cstring>
int book[10001];
int match[10001];
int e[101][101];
int rn[10001],ho[10001];
int ans=0,n=0;
bool dfs(int u)
{
    for(int i=1;i<=n;i++)
    {
        if(book[i]==0 && rn[i]==1 && e[u][i]==1)
        {
            book[i]=1;
            if(match[i]==0 || dfs(match[i])==true)
            {
                match[i]=u;
                return true;
            }
        }
    }
    return false;
}
bool work()
{
    for(int i=1;i<=n;i++)
    {
        memset(book,0,sizeof(book));
        if((rn[i]==0 || ho[i]==0) && (dfs(i)==false))
        {
            return false;
        }
    }
    return true;
}
int main()
{
    int t=0;
    scanf("%d",&t);
    while(t--)
    {
        ans=0;
        memset(book,0,sizeof(book));
        memset(match,0,sizeof(match));
        memset(rn,0,sizeof(rn));
        memset(ho,0,sizeof(ho));
        memset(e,0,sizeof(e));
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&rn[i]);
        }
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&ho[i]);
            if(rn[i]==0)
            {
                ho[i]=1;
            }
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                scanf("%d",&e[i][j]);
            }
            if(rn[i]==1)
            {
                e[i][i]=1;
            }
        }
        if(work()==true)
        {
            printf("^_^\n");
        }
        else
        {
            printf("T_T\n");
        }
    }
    return 0;
}
```

网络流：

```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
struct nodea{ int x,y,d,g,f; } e[1000001];
struct nodeb{ int first,h; } r[1000001];
int inf=999999999,st=1001,ed=1002,n=0;
int q[1000001],len=0;
int min(int x,int y)
{
    return x<y?x:y;
}
void ins(int x,int y,int d)
{
    len++;

    e[len].x=x;
    e[len].y=y;
    e[len].d=d;
    e[len].g=r[x].first;
    r[x].first=len;
    
    len++;

    e[len].x=y;
    e[len].y=x;
    e[len].d=0;
    e[len].g=r[y].first;
    r[y].first=len;
    
    e[len].f=len-1;
    e[len-1].f=len;
}
bool bfs()
{
    int tou=1,wei=2;
    for(int i=1;i<=2000;i++)
    {
        r[i].h=0;
    }
    r[st].h=1;
    r[ed].h=0;
    
    q[1]=st;
    
    while(tou<wei)
    {
        int x=q[tou];
        for(int i=r[x].first;i>0;i=e[i].g)
        {
            int y=e[i].y;
            if(e[i].d>0 && r[y].h==0)
            {
                r[y].h=r[x].h+1;
                q[wei]=y;
                wei++;
            }
        }
        tou++;
    }
    if(r[ed].h>0)
    {
        return true;
    }
    return false;
}
int dfs(int x,int f)
{
    if(x==ed)
    {
        return f;
    }
    int tt=0;
    for(int i=r[x].first;i>0;i=e[i].g)
    {
        int y=e[i].y;
        if(r[x].h+1==r[y].h && tt<=f && e[i].d>0)
        {
            int my=dfs(y,min(e[i].d,f-tt));
            tt+=my;
            e[i].d-=my;
            e[e[i].f].d+=my;
        }
    }
    if(tt==0)
    {
        r[x].h=0;
    }
    return tt;
}
int dinic()
{
    int ans=0;
    while(bfs()==true)
    {
        ans+=dfs(st,inf);
    }
    return ans;
}
int main()
{
    int t=0;
    scanf("%d",&t);
    while(t--)
    {
        int tot=0;
        scanf("%d",&n);
        memset(q,0,sizeof(q));
        memset(e,0,sizeof(e));
        memset(r,0,sizeof(r));
        len=0;
        int rn[101],ho[101];
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&rn[i]);
            if(rn[i]==1)
            {
                ins(i+n,ed,1);
            }
        }
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&ho[i]);
            if((rn[i]==1 && ho[i]==0) || (rn[i]==0))
            {
                ins(st,i,1);
                tot++;
            }
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                int dx=0;
                scanf("%d",&dx);
                if(dx==1 || i==j)
                {
                    ins(i,j+n,1);
                }
            }
        }
        if(dinic()>=tot)
        {
            printf("^_^\n");
        }
        else
        {
            printf("T_T\n");
        }
    }
    return 0;
}
```

---

## 作者：yybyyb (赞：60)

我也来写份题解吧

有很多人，若干床，

若干个人际关系

表示某人能够睡某人的床

问最后能否使得所有人都有床？


恩？
一个人对应一张床

这不就是二分图匹配？


没错，这就是二分图匹配。


但是，这要怎么建边呢？


1.如果这个人是学生，并且留在学校，自己和自己的床连线

2.如果一个人A认识另外一个人B，并且B是学生，则将A与B的床连线


建完边之后直接跑匈牙利算法

计算最大的匹配数

检查是否和要床的人数相同

最后输出即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAX=100;
const int MAXL=10000;
struct Line
{
       int v,next;
}e[MAXL];
int h[MAX],cnt=0,tot;
int T,n;
int home[MAX];
int school[MAX],a,sum;
inline void Add(int u,int v)
{
       e[cnt]=(Line){v,h[u]};
       h[u]=cnt++;
}
int match[MAX];
bool vis[MAX];
bool DFS(int x)
{
       for(int i=h[x];i!=-1;i=e[i].next)
       {
              int v=e[i].v;
              if(!vis[v])
              {
                    vis[v]=true;
                    if(!match[v]||DFS(match[v]))
                    {
                            match[v]=x;
                            return true;
                    }
              }
       }
       return false;
}
int main()
{
       cin>>T;
       while(T--)
       {
             cnt=tot=0;
             memset(h,-1,sizeof(h));
             cin>>n;
             for(int i=1;i<=n;++i)
                cin>>school[i];
             for(int i=1;i<=n;++i)
             {
                  cin>>home[i];
                  if(home[i]==0&&school[i])//如果此人是在校学生并且不回家 
                     Add(i,i);//可以睡自己的床 
             }
             for(int i=1;i<=n;++i)//统计要床的人 
               if(!school[i]||(school[i]&&!home[i]))
                    ++tot;
             for(int i=1;i<=n;++i)
             {
                  for(int j=1;j<=n;++j)
                  {
                         cin>>a;
                         if(a&&school[j])//如果i认识j并且j是学生
                               Add(i,j);//i可以睡j的床 
                  }
             }
             memset(match,0,sizeof(match));
             sum=0;
             for(int i=1;i<=n;++i)
             {
                   if((school[i]&&home[i]==0)||!school[i])//要么是学生在学校，要么是外来的人
                   {
                         memset(vis,0,sizeof(vis));
                         if(DFS(i))++sum;
                   }
             }
             if(sum==tot)
                cout<<"^_^"<<endl;
             else
                cout<<"T_T"<<endl;
       }
       return 0;
}
```

---

## 作者：George1123 (赞：18)

[${\color{#00ccee}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P2055 【\[ZJOI2009\]假期的宿舍】](https://www.luogu.org/problem/P2055)

### 此题算法:匈牙利算法

二分图匹配的巧妙水题。

**大致思路:**

先敲模板:**匈牙利算法**

$mat1[]$表示在学校的人(包括朋友和学校学生)匹配的床位。

$mat2[]$表示学校的床位匹配的在学校的人。

**将在学校的人与学校的床位进行二分图匹配**

![](https://s2.ax1x.com/2019/11/24/MLgu2q.jpg)

如果某个在学校的人匹配不到床，**输出T_T**

如果每个在学校的人都匹配得到床，**输出^_^**

**(多组测试数据)**

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=60;
int t,n,sty,fri,ans;
bool sc[N],ho[N],vis[N];
bool k[N][N];
int mat1[N],mat2[N];
bool dfs(int x){ //单人匹配 匈牙利模板
	for(int i=1;i<=n;i++){ //枚举床
		if(!sc[i]||!k[x][i]||vis[i]) //无需匹配
			continue;
		vis[i]=1;
		if(mat2[i]==-1||dfs(mat2[i])){
			//如果i未被匹配或与i匹配的人可以换床
			mat2[i]=x;
			mat1[x]=i; //躺床
			return 1;
		}
	}
	return 0;
}
void solve(){ 求解一组测试数据
	scanf("%d",&n);
	sty=fri=ans=0;
	for(int i=1;i<=n;i++)
		scanf("%d",sc+i);
	for(int i=1;i<=n;i++){
		scanf("%d",ho+i);
		if(!sc[i]) ho[i]=1;
	}
//	printf("%d %d\n",fri,sty);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&k[i][j]);
	for(int i=1;i<=n;i++)
		if(sc[i]) k[i][i]=1; //自己可以睡自己的床
	memset(mat1,-1,sizeof mat1);
	memset(mat2,-1,sizeof mat2);
	for(int i=1;i<=n;i++){
		if(sc[i]&&ho[i]) continue;
		memset(vis,0,sizeof vis);
		if(!dfs(i)){ //有人没床睡了
			puts("T_T");
			return;
		}
	}
	puts("^_^");
}
int main(){
	scanf("%d",&t); //多组测试数据
	while(t--) solve();
	return 0;
}
```

数组和变量都要初始化，否则被第二组数据卡没。

这题目是匈牙利算法很和谐、合适的应用。

**写题解不易，走过路过别忘了点赞啊!**

谢谢大家! !




---

## 作者：Ireliaღ (赞：16)

**ISAP最大流**

二分图匹配，可以使用最大流

## 建图

- 把每个人拆成入点和出点代表学生和房间，第$i$个人入点为$i$，出点为$n + i$，超级原点为$0$，超级会点为$2n + 1$

- 对于$\forall i \in [1, n]$，从他的入点向出点连接容量为$1$的边

- 对于$\forall i \in \text{{在校生}}$，由于他的房间可以被使用，从$n + i$向$2n + 1$连接容量为$1$的边

- 对于$\forall i \notin \text{在校生}$ 且 $i \notin \text{回家}$，由于$i$需要住宿，从$0$向$i$连接容量为$1$的边

- 对于$\forall i, j \in [1, n]$满足$i,j$互相认识，从$i$向$n + j$连接容量为$1$的边，从$j$向$n + i$连接容量为$1$的边

最后统计一下最大流是否等于所有需要住宿的学生即可

## 代码

ISAP挺快的，懒得当前弧优化了

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

const int MAXN = 55;
const int MAXM = MAXN * MAXN * 4;
const int MAXT = 25;
const int INF = 0x3f3f3f3f;

int T;

namespace Graph{
    int to[MAXM], val[MAXM], nxt[MAXM], head[MAXN << 1], cnt;
    int res, s, t, tot, dep[MAXN << 1], gap[MAXN << 1];
    
    void Clear() {
        cnt = -1;
        memset(head, -1, sizeof(head));
    }
    
    void AddEdge(int u, int v, int w) {
        cnt++; to[cnt] = v; val[cnt] = w; nxt[cnt] = head[u]; head[u] = cnt;
        cnt++; to[cnt] = u; val[cnt] = 0; nxt[cnt] = head[v]; head[v] = cnt;
    }
    
    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        dep[t] = 0; gap[0]++;
        queue<int> q; q.push(t);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; ~i; i = nxt[i]) {
                int v = to[i];
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1;
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }
    
    int Dfs(int u, int flow) {
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (int i = head[u]; ~i; i = nxt[i]) {
            int v = to[i];
            if (val[i] && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, min(val[i], flow - used));
                if (mi) {
                    val[i] -= mi;
                    val[i ^ 1] += mi;
                    used += mi;
                }
                if (used == flow) return used;
            }
        }
        gap[dep[u]]--;
        if (gap[dep[u]] == 0) dep[s] = tot + 1;
        dep[u]++;
        gap[dep[u]]++;
        return used;
    }
    
    void Isap() {
        res = 0;
        Bfs();
        while (dep[s] <= tot) Dfs(s, INF);
    }
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> T;
    while (T--) {
        Graph :: Clear();
        int n, cnt = 0;
        cin >> n;
        bool flag[n + 1]; memset(flag, false, sizeof(flag));
        Graph :: tot = n * 2 + 2; Graph :: s = 0; Graph :: t = n * 2 + 1;
        for (int i = 1; i <= n; i++) Graph :: AddEdge(i, n + i, 1);
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            if (x == 1) Graph :: AddEdge(n + i, Graph :: t, 1), flag[i] = true;
        }
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            if (x == 0 || !flag[i]) Graph :: AddEdge(Graph :: s, i, 1), cnt++;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                int x;
                cin >> x;
                if (x == 1) {
                    Graph :: AddEdge(i, n + j, 1);
                    Graph :: AddEdge(j, n + i, 1);
                }
            }
        }
        Graph :: Isap();
        if (Graph :: res < cnt) cout << "T_T" << endl;
        else cout << "^_^" << endl;
    }
    return 0;
}
```

---

## 作者：Naffygo (赞：9)

题目大意就是说有一些人，在一个学校内上学。放假了，他们可能会在学校，也可能不在，这时他们的朋友会来看他们。每个人只能在他们认识的人的床上睡觉，问是否存在一个方案，使得不回家的学生和来看他们的朋友都有床睡。

讲讲大概思路。。。

很明显这是一道二分图匹配的问题，~~当然也可以用网络流做，但是本蒟蒻不会~（滑稽）~~所以，我们应该把人分给床，该如何实现？本蒟蒻是这样想的：

1.让在校睡觉的学生睡自己的床。

2.若来访的人认识床的主人，且这张床是空的，那么他就睡这张床；若床上有人，看那个人能否找到另一张床。如果不能，就直接输出“T_T”。如果能，则那个人睡新找到的床，来访者睡这张床。

以下即为代码~~~


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define fr(i,a,b) for(int i=a;i<=b;i++)
#define N 100
using namespace std;
 
int a[N],match[N],p[N],as[N],kn[N][N];
int n;

int dfs(int x){//二分图匹配模板
	fr(i,1,n)
		if(!p[i] && kn[x][i] && a[i]){//若此人未匹配过且认识此人且此人是学生
			p[i]=1;
			if(!match[i] || dfs(match[i])){
				match[i]=x;
				return 1;
			}
		}
	return 0;
}

int main(){
	int i,j,k,m,t;
	cin>>t;
	while(t--){
		memset(a,1,sizeof(a));//初始化所有人均回家
		memset(as,0,sizeof(as));
		memset(match,0,sizeof(match));
		memset(kn,0,sizeof(kn));
		cin>>n;
		fr(i,1,n)
			scanf("%d",&a[i]);
		fr(i,1,n){
			scanf("%d",&k);
			if(a[i])as[i]=k;//如果是学生则保存k
		}
		fr(i,1,n){
			fr(j,1,n)
				scanf("%d",&kn[i][j]);
			if(a[i])kn[i][i]=1;//学生可以睡自己的床
		}
		int flag=1;
		fr(i,1,n){
			memset(p,0,sizeof(p));
			if(!as[i] && dfs(i)==0){flag=0;break;}//如果这个人不回家并且他找不到床，则退出，flag变成0
		}
		if(!flag)cout<<"T_T"<<endl;
		else cout<<"^_^"<<endl;
	}
	return 0;
}
```

---

## 作者：soler (赞：7)

【蒟蒻】首先这是二分图完美匹配

所以用匈牙利KM算法

但重要的是构建二分图的问题    各位犇的构图都很厉害   我只是按我的想法构建的一个：

二分图  一个为学生  一个为床铺

当学生是在校生时   若他回家     则学生不在   床在     所以  床的一部分加入此点

若不回家      学生在  床在     两部分都加入此点

当学生不是在校生      则没床 有人      学生的部分加入此点

当接收认识的学生后    再把在校学生的map[i][i] 赋值为1    即 可以自己睡自己的床

然后KM进去

最后判断    若二分图中学生多于床     一定不成立    直接“T\_T”




```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int T,n,map[111][111],a[111],b[111],c[111],d[111],vis[111],ans;
int find(int x)
{
    for(int i=1;i<=c[0];i++)
        if(!vis[c[i]]&&map[c[i]][x])
        {
            vis[c[i]]=1;
            if(!d[c[i]]||find(d[c[i]]))
            {
                d[c[i]]=x;
                return 1;
            }
        }
    return 0;
}
int main()
{
    cin>>T;
    for(int ii=1;ii<=T;ii++)
    {
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        memset(c,0,sizeof(c));
        memset(d,0,sizeof(d));
        memset(map,0,sizeof(map));
        ans=0;
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
        {
            int x;
            cin>>x;
            if(a[i])
            {
                if(x)
                    c[++c[0]]=i;
                else
                    b[++b[0]]=c[++c[0]]=i;
            }
            else
                b[++b[0]]=i;
        }
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                cin>>map[i][j];
        for(int i=1;i<=n;i++)
            if(a[i])map[i][i]=1;//自己可以睡自己的床
        for(int i=1;i<=b[0];i++)
        {
            memset(vis,0,sizeof(vis));
            if(find(b[i])) ans++;
        }    
        if(b[0]>c[0]) ans=-1;     //关键   若二分图中的上半部分多  无论如何也不会完美匹配！！！        
        if(ans==b[0]) cout<<"^_^"<<endl;
        else cout<<"T_T"<<endl;
    }
    return 0;
}
```

---

## 作者：千里马 (赞：4)

## P2055 [ZJOI2009]假期的宿舍
一道标准的最大匹配，题目问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。明显若需要住宿舍的人数等于最大匹配数时成立，反之不成立。
需要住宿有两种可能，1.非在校生，2.在校生但要回家，只需在输入时便可统计。
最大匹配当然要用[匈牙利算法](https://blog.csdn.net/SSL_wujiajie/article/details/86643692)（借用大神的博客），在建立邻接表时，将每个人连上他可以占用的床铺，首先在校生可以占自己的，如果认识对方，且对方是回家的学生，也可以占用，建好后就是匈牙利的板子了，最后判断输出答案。
代码如下
~~~~
------------

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int head[51],ver[2500],nxt[2500],match[60];
bool vis[110];
int tot,n,T,g,sum,ans;
int a[60],b[60];
void add(int x,int y)
{
    ver[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
bool dfs(int x)
{
    for(int i=head[x];i;i=nxt[i])
    {
        int y=ver[i];
        if(!vis[y]){
            vis[y]=1;
            if(!match[y]||dfs(match[y])){
                match[y]=x;return true;
            }
        }
    }
    return false;
}
int main()
{
	cin>>T;
	while(T--){
		cin>>n;
		tot=sum=ans=0;
		memset(match,0,sizeof(match));
		memset(head,0,sizeof(head));
		for(int i=1;i<=n;++i){
			scanf("%d",&a[i]);
			if(a[i]==0) sum++;
		} 
		for(int i=1;i<=n;++i){
			scanf("%d",&b[i]);
			if(a[i]==1&&b[i]==0) sum++,add(i,i);
		} 
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				cin>>g;
				if(g==1&&a[j]==1) add(i,j);
			}
		}
		for(int i=1;i<=n;++i){
			if((a[i]&&!b[i])||!a[i]){
				memset(vis,0,sizeof(vis));
        		if(dfs(i)) ans++;
			}
		}
		if(ans==sum) cout<<"^_^"<<endl;
		else cout<<"T_T"<<endl;
	}
	return 0;
}
```


---

## 作者：Potassium (赞：2)

~~因为懒~~，提供一种不连边，直接根据题目给出的邻接矩阵进行匈牙利算法的思路。

$a[i][j]$表示$i$能不能睡$j$的床，需要根据具体情况在读入的时候适当调整。

$inv[i]$表示第$i$个需要在学校睡觉的人（可能是在校学生也可能是校外人员）

```c
#include<stdio.h>
#include<string.h>
int a[60][60],is[60],leave[60],vis[60],mt[60];
//a[i][j]:i能不能睡j的床 
int inv[60],cnt,n;
//inv[i]:第i个要在学校睡觉的人 
int dfs(int p,int t){
	int i;
	for(i=1;i<=n;i++){
		if(a[inv[p]][i]&&vis[i]!=t){
			vis[i]=t;
			if(!mt[i]||dfs(mt[i],t))return mt[i]=p;
		}
	}
	return 0;
}
int main(){
	int i,j,t;
	scanf("%d",&t);
	while(t--){
		int ans=0;cnt=0;
		memset(vis,0,sizeof(vis));
		memset(mt,0,sizeof(mt));
		scanf("%d",&n);
		for(i=1;i<=n;i++)
			scanf("%d",&is[i]);
		for(i=1;i<=n;i++){
			scanf("%d",&leave[i]);
			if(!is[i]||!leave[i])inv[++cnt]=i;
			//如果这人不是学校的或者不回家那就要在学校睡觉 
		}
		for(i=1;i<=n;i++)
			for(j=1;j<=n;j++){
				scanf("%d",&a[i][j]);
				if(i==j&&is[i]&&!leave[i])a[i][j]=1;
				//如果在校没回家那可以睡自己的床 
				if(!is[j])a[i][j]=0;
				//如果不是学校的没床可以给别人睡 
			}
		for(i=1;i<=cnt;i++)
			if(dfs(i,i))ans++;
			else break;
		if(ans!=cnt)printf("T_T\n");
		else printf("^_^\n");
	}
	return 0;
}
```


---

## 作者：lilala (赞：2)

/\*
我来写篇题解吧，看了前面的，写的丑粪了，实在看不下去，也不助于理解

这道题的思路有多种 网络流或者二分图  简单易写易懂的就是二分图了

用到的是匈牙利算法 其实就是利用递归给每个点匹配 详细的自行百度

然后就是建图 看代码注释

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN = 510;
int uN,vN;//u,v的数目，使用前面必须赋值
int g[MAXN][MAXN];//邻接矩阵
int linker[MAXN],pipei;
bool used[MAXN],stu[MAXN],hom[MAXN];
bool dfs(int u)
{
    for(int v = 1; v <=vN;v++)
        if(stu[v] && g[u][v] && !used[v])//这里匹配就要匹配是在校学生的 因为不是在校学生的话没有床 
        {
            used[v] = true;
            if(linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    return false;
}
bool hungary()//匈牙利算法 
{
    int res = 0;
    memset(linker,-1,sizeof(linker));
    for(int u = 1;u <= uN;u++)
    {
        memset(used,false,sizeof(used));
        if((!stu[u] ||!hom[u]) && !dfs(u))    return 0;// 给每个不是在校学生或者不回家的匹配  如果不成功就返回 
    }
    return 1;
}
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        uN=vN=n;
        memset(g,0,sizeof(g));
        for(int i=1;i<=n;i++)
            scanf("%d",&stu[i]);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&hom[i]);
            if(!stu[i])
                hom[i]=1;    //如果不是在校学生就默认回家了 
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
                scanf("%d",&g[i][j]);
            if(stu[i])g[i][i]=1;//匹配自己的床 
        }
        printf("%s\n",hungary()?"^_^":"T_T");
    }
    return 0;
}
```

---

## 作者：abandentsky (赞：1)

思路：这个题目一定要写个题解，题目其实很好想。首先由n个人，其中有m个本校生。这就说明有m个床位。人从1-n开始编号，床位从n+1到n+m编号。这样若i是住校生，则i拥有一个床位编号为P[i]。这样所有与i认识的人都可以连一条边从i到P[i]。如果i不回家，则i要连一条边到P[i]。这样。就处理完建图过程。
下面开始匹配：匹配过程我们只匹配需要床位的人（本校生，但是不回家和外校生）.如果都能匹配到床，就是有方案，如果有人没匹配到，就是不能。
```c
#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
#define MAXN  2005
using namespace std;

vector<int> G[55];                      //n的范围小于等于50
bool vis[105];                           //最坏情况50个人全是住校生，这样床号就是51-100
int vv[105];                              //51-100
int Map[55][55];            //存储关系矩阵
int sg[55],sp[55];           //其中sg表示是否是住校生,sp表示是否回家
int cnt;                                            //计算出住校生的数目，也就是能用的床位
map<int,int> P;                          //住校生编号映射成床的编号，床的编号从n+1开始，结束于n+cnt
int T,n,kk;

bool match(int u)
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v])
            continue;
        vis[v]=true;
        if(!vv[v]||match(vv[v]))
        {
            vv[v]=u;
            return true;
        }
    }
    return false;
}

void Km()                                         //外校生加上没回家的同学都能分到床位就可行
{
    memset(vv,0,sizeof(vv));
    bool ok=true;
    for(int i=1;i<=n;i++)
    {
        memset(vis,0,sizeof(vis));
        if(sg[i]&&!sp[i]||!sg[i])   //是本校生且不回家，不是外校人员(其他的不做匹配处理)
        {
               if(!match(i))              //匹配不成功
               {
                   ok=false;
                   break;
               }
        }
    }
    if(ok)
        printf("^_^\n");
    else
        printf("T_T\n");
}

void init()
{
   for(int i=1;i<=n;i++)
   {
       if(sg[i])                                     //如果他是住校生（有床位）
       {
           for(int j=1;j<=n;j++)
           {
               if(Map[i][j])                                //两个人认识
               {
                   G[j].push_back(P[i]);          //从编号为j的人向P[i]号床连边
               }
           }
           if(!sp[i])
             G[i].push_back(P[i]);              //是住校生，并且不回家，分配床位
       }
   }
}

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        cnt=0;
        kk=1;
        for(int i=1;i<=n;i++)
           G[i].clear();
        P.clear();
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&sg[i]);
            if(sg[i]==1)                                //是1表示是住校生
                cnt++;                                    //统计住校生数量
        }
        for(int i=1;i<=n;i++)
            scanf("%d",&sp[i]);
        for(int i=1;i<=n;i++)            //读入关系矩阵
        {
            if(sg[i]==1)                         //是住校生，就可以拥有床位
            {
                P[i]=n+kk;                      //给所有的住校生分配床号(从n+1开始分配)
                kk++;
            }
            for(int j=1;j<=n;j++)
            {
                scanf("%d",&Map[i][j]); //存储关系矩阵
            }
        }
        init();
        Km();
    }
    return 0;
}

```


---

## 作者：ReModer (赞：1)

蒟蒻说一下建边：

首先，人、床各为点集是显然的。具体一点说，应该是**住在学校的人**和**所有的床**各为点集。当然，本校学生都有一张床。

住在学校的都是什么人？非本校学生 + 不离校的本校学生。

我们用 leave[i] 表示 i 离校与否的话，题中非本校学生的 leave 是随机的，把他们也记为 0。

如此一来，leave[i] ? i不住在校 : i住在学校;

准备完成，就可以建边了。

对于 i 和 j 而言，若互相认识且 j 有床，那么 i 就可以睡在 j 的床上，这样就从 i 向 j 连一条边即可。

特别地，~~题目中的自己不认识自己~~，我们需要处理一下。如果 i 住在学校而且自己有床，他也能睡自己床上，于是从 i 向 i 连边。

然后就是二分图匹配了，给**住在学校的人**匹配。

Code：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define inl inline
#define reg register
using namespace std;

const int maxn = 50 + 10;
int couple[maxn],n,T,cnt;
bool in[maxn],leave[maxn],book[maxn],link[maxn][maxn];

inl void init();
inl void input();
bool find(reg int);
inl int match();
inl void output();
inl void debug();

int main(){
    scanf("%d",&T);
    while (T--){
        init();
        input();
        output();
    }
    return 0;
}

inl void init(){
	cnt = 0;
    memset(in,0,sizeof(in));
    memset(leave,0,sizeof(leave));
    memset(link,0,sizeof(link));
    memset(couple,0,sizeof(couple));
}

inl void input(){
    scanf("%d",&n);
    for (int i = 1; i <= n; i++)
        cin >> in[i];
    for (int i = 1; i <= n; i++){
        cin >> leave[i];
		if (!in[i]) leave[i] = 0;
	}
    for (int i = 1; i <= n; i++) //计算住在学校的人数 
    	if (!leave[i]) cnt++;
    for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++){
            	int t; scanf("%d",&t);
            	if (i == j && in[i] && !leave[i]) link[i][j] = 1; //睡自己的床 
            	if (t && in[j]) link[i][j] = 1; 
			}
}

bool find(reg int x){
    for (int i = 1; i <= n; i++){
        if (!book[i] && link[x][i]){
            book[i] = 1;
            if (!couple[i] || find(couple[i])){
                couple[i] = x;
                return true;
            }
        }
    }
    return false;
}

inl int match(){
    int ans = 0;
    for (int i = 1; i <= n; i++){
    	if (leave[i]) continue; //如果不住在学校，不需要匹配 
        memset(book,0,sizeof(book));
        if (find(i)) ans++;
    }
    return ans;
}

inl void output(){
    if (match() == cnt) printf("^_^\n");
    else printf("T_T\n");
}

inl void debug(){
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++)
			cout << link[i][j] << ' ';
		cout << endl;
	}
}
```


---

## 作者：muller (赞：1)

这道题是一道二分图匹配问题，可以用匈牙利算法求解，然而笔者用的是最大流dinic算法！

首先，我们考虑如何把此问题转换为最大流。我们要学会拆点！

顾名思义，就是把一个点拆成两个点（以限制每个点（物品）用一次）

记录i拆为i,i+n

我们要单独建一个源点和汇点，然后源点S向i连边，i+n向T连边即可！
然后dinic就是一种最大流算法，再次不做赘述，可以参照博客自行学习！
给一下我的代码吧：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 5005, M = (N << 2), INF = 1e9;
int n, ss, tt, ecnt = 0, cur[N], fir[N], to[M], nxt[M], len[M], inv[M];
int depth[N], q[N], c1[N], c2[N], l, r, ans = 0, tot = 0; bool vis[N];
template <class T> void rd(T &x) {
    char c = getchar(); int f = 1; x = 0;
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    x *= f;
}
void ae(int u, int v, int w) {
    to[++ecnt] = v; nxt[ecnt] = fir[u]; len[ecnt] = w; inv[ecnt] = ecnt + 1; fir[u] = ecnt;
    to[++ecnt] = u; nxt[ecnt] = fir[v]; len[ecnt] = 0; inv[ecnt] = ecnt - 1; fir[v] = ecnt;
}
bool make_level() {
    int i; memset(vis, false, sizeof(vis));
    for (i = ss; i <= tt; ++i) cur[i] = fir[i];
    vis[q[l = r = 1] = ss] = true; depth[ss] = 0;
    while (l <= r) {
        int i, u = q[l++];
        for (i = fir[u]; i; i = nxt[i]) {
            int v = to[i], w = len[i];
            if (!vis[v] && w) vis[q[++r] = v] = true, depth[v] = depth[u] + 1;
        }
    }
    return vis[tt];
}
int dinic(int u, int lim) {
    if (u == tt) return lim;
    int i, ret = 0;
    for (i = cur[u]; i; i = nxt[i]) {
        int v = to[i], w = len[i];
        if (w && depth[v] == depth[u] + 1) {
            int tmp = dinic(v, min(lim, w));
            len[i] -= tmp, len[inv[i]] += tmp;
            lim -= tmp, ret += tmp;
            if (!lim) {cur[u] = i; return ret;}
        }
    }
    cur[u] = 0; return ret;
}
void solve() {
    int i, j; memset(fir, ecnt = 0, sizeof(fir));
    rd(n), ss = 0, tt = n << 1 | 1; ans = tot = 0;
    for (i = 1; i <= n; ++i) {
        rd(c1[i]);
        if (c1[i] == 1) ae(i + n, tt, 1);
    }
    for (i = 1; i <= n; ++i) {
        rd(c2[i]);
        if (c1[i] == 1 && !c2[i] || !c1[i]) ae(ss, i, 1), ++tot;
    }
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j) {
            int x; rd(x);
            if (i == j || x) ae(i, j + n, 1);
        }
    while (make_level()) ans += dinic(ss, INF);
    if (ans >= tot) puts("^_^"); else puts("T_T");
}
int main() {
    int T; rd(T);
    while (T--) solve();
    return 0;
}

```

---

## 作者：C_S_X_ (赞：1)

## 网络流建图  
左边n个点是n个人，右边n个点是床。其中超级源连向每一个周末待在学校的人（回家的在读生不在学校，不连即可），每一张床连向超级汇（非在读生没有床，不连即可），中间的对应关系就是谁认识谁就谁连向谁，意味着某个人可以睡哪些床（也许被指向的人根本没有床，但是没有关系，那个人不会连向超级汇；也许指向别人的人不需要留宿，但是也没关系，那个人不会连向超级汇，所有不会占床位）。最大流等于周末有床睡的人，若这个数等于周末留宿人数则存在方案。
```cpp
#include<bits/stdc++.h>
#define N 1010
#define M 100010
#define inf 1000000007
using namespace std;
int T1,n,id[N],back[N],first[N],nxt[M],u[M],v[M],w[M],tot,cnt;
int x,sum=0,S,T,flow,maxflow,ans[N];
int depth[N];
queue <int> q;
void add(int from,int to,int cost)
{
	tot++;
	nxt[tot]=first[from];
	first[from]=tot;
	u[tot]=from;
	v[tot]=to;
	w[tot]=cost;
	return;
}
int bfs()
{
	memset(depth,0,sizeof(depth));
	while (q.size()) q.pop();
	depth[S]=1;
	q.push(S);
	while (q.size())
	{
		int tmp=q.front();
		q.pop();
		for (int j=first[tmp];j!=-1;j=nxt[j])
		{
			int to=v[j];
			if (w[j]&&!depth[to])
			{
				depth[to]=depth[tmp]+1;
				q.push(to);
			}
		}
	}
	if (depth[T]) return 1;
	else return 0;
}
int Dinic(int point,int f)
{
	if (point==T) return f;
	int rest=f,k;
	for (int j=first[point];rest&&j!=-1;j=nxt[j])
	{
		int to=v[j];
		if (w[j]&&depth[to]==depth[point]+1)
		{
			k=Dinic(to,min(w[j],f));
			if (!k) depth[to]=0;
			w[j]-=k;
			w[j^1]+=k;
			rest-=k;
		}
	}
	return f-rest;
}
int main()
{
//	freopen("testdata.in","r",stdin);
	scanf("%d",&T1);
	for (int t=1;t<=T1;t++)
	{
		memset(first,-1,sizeof(first));
		tot=1;
		cnt=0;
		scanf("%d",&n);
		//1--n是人
		//(n+1)--(2n)是床 
		S=2*n+1;
		T=2*n+2;
		for (int i=1;i<=n;i++) scanf("%d",&id[i]);
		for (int i=1;i<=n;i++) scanf("%d",&back[i]);
        for (int i=1;i<=n;i++) if ((id[i]&&!back[i])||(!id[i])) cnt++;
		for (int i=1;i<=n;i++) 
		    for (int j=1;j<=n;j++) 
			{
				scanf("%d",&x);
				if (i!=j&&x) add(i,j+n,1),add(j+n,i,0);//每个人向他可以睡到的床连边				                          
				else if (i==j) add(i,i+n,1),add(i+n,i,0);//自己不认识自己但是能睡自己的床 
			}
		for (int i=1;i<=n;i++) if ((id[i]&&!back[i])||(!id[i])) add(S,i,1),add(i,S,0);//超级源连向每个周末在学校的人 
		for (int i=1;i<=n;i++) if (id[i]) add(i+n,T,1),add(T,i+n,0);//每个床连向超级汇，在读生有床 
		maxflow=0;
		while (bfs())
		    while ((flow=Dinic(S,inf))) maxflow+=flow;
		if (maxflow==cnt) ans[++sum]=1;
		else ans[++sum]=2;
	}
	for (int i=1;i<=sum;i++) if (ans[i]==1) printf("^_^\n");
	else if (ans[i]==2) printf("T_T\n");
	return 0;
}
```

---

## 作者：henry_y (赞：1)

裸的最大流。据说这道题也可以跑二分图匹配？但是我太蒟了不懂二分图匹配，~~而且网络流一般跑的比二分图快~~。

比较麻烦的就是建图。仔细研究一下题面就可以发现这么建边就可以了：

1. 源点向所有有床位的连边

2. 需要床位的向汇点连边

3.  如果i可以睡j的床，i向j连边

然后各个点的编号随便+个n或者*2什么的就好了。反正区分开来就ok。建图搞定了这道题就没难度了，套一下dinic模板就ok。

推荐先把模板打熟练了再来打这道题，概念或者代码不是很清楚的可以移步百度或者[P3376【模板】网络最大流 题解区](https://www.luogu.org/problemnew/solution/P3376)

如果需要检查~~抄~~模板代码什么的可以看我的[博客](https://www.luogu.org/blog/henry-y/solution-p3376)，里面有代码

好了废话说完了，上代码，个人感觉上面都讲的很清楚了？就不带注释了。~~方便你们抄~~

```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#define ll int
#define maxn 105
#define inf 1<<30
#define mt(x,y) memset(x,y,sizeof(x))
#define max(x,y) x>y?x:y
#define min(x,y) x<y?x:y
#define abs(x) x>0?x:-x
#define mod 10000007
#define lowbit(x) x&-x
inline void read(ll &x){x=0;ll f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
using namespace std;
struct edge{ll to,next,v;}e[50000];
ll head[maxn],cnt=1,tot,ans,h[maxn],q[maxn];
ll s=0,t=101,sc[51],n;
inline void add(ll u,ll v,ll w){e[++cnt].to=v;e[cnt].next=head[u];e[cnt].v=w;head[u]=cnt;}
inline bool bfs(){
	mt(h,-1);q[0]=h[0]=0;ll i,l=0,r=1,now;
	while(l<r){
		now=q[l++];if(l==101)l=0;
		i=head[now];
		while(i){
			if(e[i].v&&h[e[i].to]<0){
				h[e[i].to]=h[now]+1;
				q[r++]=e[i].to;
				if(r==101)r=0;
			}
			i=e[i].next;
		}
	}
	if(h[t]==-1)return 0;
	return 1;
}
inline ll dfs(ll x,ll f){
	if(t==x)return f;
	ll used=0,w,i=head[x];
	while(i){
		if(h[x]+1==h[e[i].to]&&e[i].v){
			w=f-used;
		    w=dfs(e[i].to,min(w,e[i].v));
		    e[i].v-=w;e[i^1].v+=w;used+=w;
		    if(used==f)return f;
	    }
		i=e[i].next;
	}
	if(!used)h[x]=-1;
	return used;
}
inline void dinic(){while(bfs())ans+=dfs(0,inf);}
int main(){
    ll test,x;read(test);
    while(test--){
	    cnt=1;tot=ans=0;mt(head,0);
	    read(n);
	    for(ll i=1;i<=n;i++){
	    	read(sc[i]);
	    	if(sc[i]){
	    		add(i+n,t,1);add(t,i+n,0);
			}
		}
		for(ll i=1;i<=n;i++){
			read(x);
			if((sc[i]&&!x)||!sc[i]){
				add(0,i,1);add(i,0,0);tot++;
			}
		}
		for(ll i=1;i<=n;i++){
			for(ll j=1;j<=n;j++){
				read(x);
				if(x||i==j){
					add(i,j+n,1);add(j+n,i,0);
				}
			}
		}
		dinic();
		if(ans==tot)printf("^_^\n");
		else printf("T_T\n");
	}
	return 0;
}
```

---

## 作者：licone (赞：1)

匈牙利算法+思路~


对于每一个在校的人，与他可以睡的床连边，这里床和人都记为点，匹配的时候统一匹配；比如第i个人的床就是第i+n号，不是学生也有床，只不过不连边。


注意在校的有床的学生要和自己的床连边！不然WA到飞起！





```cpp
#include<cstdio>
#include<cstring>
int t,n,k,ans[101],tot;
bool b[51],c[51],kkz[101][101],vis[101],flag;
char s[3]={84,94,95};
bool col(int u)
{
    for(int i=1;i<=2*n;i++)
      if(kkz[u][i] && !vis[i])
      {
          vis[i]=1;
          if(!ans[i] || col(ans[i]))
          {
              ans[i]=u;return 1;
        }
      }
    return 0;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        memset(ans,0,sizeof(ans));
        memset(kkz,0,sizeof(kkz));
        scanf("%d",&n);flag=0;
        for(int i=1;i<=n;i++) scanf("%d",&b[i]);
        for(int i=1;i<=n;i++) scanf("%d",&c[i]);
        for(int i=1;i<=n;i++)
          for(int j=1;j<=n;j++)
          {
              scanf("%d",&k);
              if(k && i!=j)
              {
                  if(b[j] && ((b[i] && !c[i]) || !b[i])) kkz[i][j+n]=kkz[j+n][i]=1;
                if(b[i] && ((b[j] && !c[j]) || !b[j])) kkz[j][i+n]=kkz[i+n][j]=1;
            }
          }
        for(int i=1;i<=n;i++)
          if(b[i] && !c[i]) kkz[i][i+n]=kkz[i+n][i]=1;
        for(int i=1;i<=n;i++)
          if((b[i] && !c[i]) || !b[i])
          {
            memset(vis,0,sizeof(vis));
            if(!col(i))
            {
                flag=1;break;
            }
          }
        if(!flag) printf("%c%c%c\n",s[1],s[2],s[1]);
        else printf("%c%c%c\n",s[0],s[2],s[0]);
    }
    return 0;
}
```

---

## 作者：QwQ2000 (赞：1)

二分图最大匹配 可惜我并没有学会匈牙利算法QAQ

所以就用DINIC做了 反正效率影响不大= =

建图方法其实并不难 我写在代码注释里了


最关键的是 多 组 数 据！

记得初始化啊 非常关键

我就因为没初始化WA了一万次啊一万次……TAT


```cpp

#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

const int N=201,S=0,T=200,INF=int(1e9);

struct edge {
    int u,v,c,f;
    edge() { }
    edge(int a,int b,int d,int e):u(a),v(b),c(d),f(e) { }
};

vector<int> g[N];
vector<edge> e;
int n=0,t=0,stu[N],hom[N],vis[N],d[N],cur[N],dmd=0;

void addEdge(int u,int v) {
    e.push_back(edge(u,v,1,0));
    e.push_back(edge(v,u,0,0));
    g[u].push_back(e.size()-2);
    g[v].push_back(e.size()-1);
}

inline void clear() {
    e.clear();
    for (int i=0;i<N;++i)
        g[i].clear();
    dmd=0;
}

inline void build() {
    //0为源 200为汇 1~n和n+1~2n均为学生 
    //如果有住宿的需求（非在校学生 或者不回家） 就从s连一条边 容量为1
    //如果能提供床（为在校学生） 就向t连一条边 容量为1
    //学生之间根据关系全部连容量为1的边 在校学生连自己 
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
        scanf("%d",stu+i);    
    for (int i=1;i<=n;++i)
         scanf("%d",hom+i);
    for (int i=1;i<=n;++i) {
        if (!stu[i] || (stu[i] && !hom[i])) {
            addEdge(S,i);
            ++dmd;
        }
        if (stu[i])
            addEdge(n+i,T);
    }
    for (int i=1;i<=n;++i) {
        if (stu[i] && !hom[i])
            addEdge(i,n+i);
        for (int j=1;j<=n;++j) {
            int flag=0;
            scanf("%d",&flag);
            if (flag) 
                addEdge(i,n+j);
        }
    }
}

int dfs(int x,int a) {
    if (x==T || a==0)
        return a;
    int flow=0,f=0;
    for (int& i=cur[x];i<g[x].size();++i) {
        edge& e0=e[g[x][i]];
        if (d[x]+1==d[e0.v] && (f=dfs(e0.v,min(a,e0.c-e0.f)))>0) {
            e0.f+=f;
            e[g[x][i]^1].f-=f;
            flow+=f;
            a-=f;
            if (a==0)
                break;
        }
    }
    return flow;
}

int bfs() {
    memset(vis,0,sizeof(vis));
    memset(d,0,sizeof(d));
    queue<int> q;
    d[S]=1;
    vis[S]=1;
    q.push(S);
    while (!q.empty()) {
        int x=q.front();
        q.pop();
        for (int i=0;i<g[x].size();++i) {
            edge e0=e[g[x][i]];
            if (!vis[e0.v] && e0.c>e0.f) {
                vis[e0.v]=1;
                q.push(e0.v);
                d[e0.v]=d[x]+1;
            }
        }
    }
    return vis[T];
}

void maxFlow() {
    int flow=0;
    while (bfs()) {
        memset(cur,0,sizeof(cur));
        flow+=dfs(S,INF);        
        
    }
    if (flow>=dmd) {
        printf("^_^\n");
        return;
    }
    printf("T_T\n");
}

int main(void) {
    scanf("%d",&t);
    while (t--) {
        clear();
        build();
        maxFlow();
    }
    return 0;    
}

```

---

## 作者：桀骜的野心家 (赞：1)

裸的二分图匹配，分成两堆点，一堆为人，一堆为床，将每个住校的人和他自己的床和认识的人的床连边，然后直接跑二分图匹配。我的方法为匈牙利算法，当然跑网络流也可以。不会匈牙利算法的看下这个博客，写的很好的：http://blog.csdn.net/dark\_scope/article/details/8880547

直接上代码。

```cpp

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define N 101
#define M 3001
using namespace std;
int t,n,m;
int p[N],front[N],to[M],next[M],line,ans;
bool b1[N],b2[N],pre[N];
void insert(int x,int y)
{
    line++;to[line]=y;next[line]=front[x];front[x]=line;
}
bool find(int u)
{int i;
   for(i=front[u];i!=-1;i=next[i])
        if(pre[to[i]])
           {
                 pre[to[i]]=false;
                 if(p[to[i]]==0 || find(p[to[i]]))
                     {
                          p[to[i]]=u;
                          return true;
                     }
           }
    return false;
}
int main()
{int i,j,k;
    scanf("%d",&t);
    for(int i1=1;i1<=t;i1++)
       {
              scanf("%d",&n);
              for(i=1;i<=n;i++)
                 {
                     scanf("%d",&k);
                     b1[i]=k;
                 }
               m=0;
               for(i=1;i<=n;i++)
                 {
                     scanf("%d",&k);
                     if(!b1[i]) b2[i]=true,m++;
                         else 
                           {
                               b2[i]=k;
                               b2[i]=!b2[i];
                               if(b2[i]) m++;
                           }
                  }
               line=-1;memset(front,-1,sizeof(front));
               for(i=1;i<=n;i++)
                 if(b2[i])
                 {
                       if(b1[i]) insert(i,i+n);
                       for(j=1;j<=n;j++)
                      {
                          scanf("%d",&k);
                          if(k)
                            if(b1[j]) insert(i,j+n);
                      }         
                 }
                   else for(j=1;j<=n;j++) scanf("%d",&k);
               ans=0;
               memset(p,0,sizeof(p));
               for(i=1;i<=n;i++)
                 if(b2[i]) 
                    {
                        memset(pre,true,sizeof(pre));
                        if(find(i)) ans++;
                    }
               if(ans==m) printf("%c%c%c\n",94,95,94);
                   else printf("%c%c%c\n",84,95,84);
               
       }
    
}

```

---

## 作者：神之右大臣 (赞：1)

这道题虽然看起来就是一道网络流，然而正确/错误率还是蛮低的，其实主要是题意理解不正确/不完整；

思路很明显：床铺是集合B{}中的点,在校学生是集合A{}中的点,然后跑最大匹配；

首先说一下具体步骤：

1.在校学生就是题目背景中的本校学生;这意味着他们都有一个床铺。所以说有在校学生就是说有一个床铺在B集合；

2.输入的第三行指第 i 个数表示第 i 个人是否回家 (0 表示不回家，1 表示回家，注意如果第 i 个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。
  注意：只要他是外来学生，那么他就需要加入A集合；如果他是本校学生，是0就加入A集合，否则不操作；
  
3.然后从原点S向A集合中的所有点各连一条边，从B集合中的所有点向汇点T连一条边；

4.然后输入的矩阵便是A集合到B集合的边，这里就简单了；

5.多测不清空，爆零两行泪；

然后无论跑什么dinic、EK、匈牙利......，反正跑对就好了；
```cpp
#include <bits/stdc++.h>
using namespace std;
int vis[1000],bo[1000];
struct littlestar{
	int to;
	int nxt;
	int flow;
}star[2000010];
int head[2000010],cnt=1;
void add(int u,int v,int flow)
{
	star[++cnt].to=v;
	star[cnt].nxt=head[u];
	star[cnt].flow=flow;
	head[u]=cnt;
}
vector<int> vec1,vec2;
int mmap[1000][1000];
int S,T;
int dep[1100];
bool bfs()
{
	queue<int> q;
	memset(dep,0,sizeof(dep));
	q.push(S);
	dep[S]=1;
	while(q.size()){
		int u=q.front();
		q.pop();
		for(register int i=head[u];i;i=star[i].nxt){
			int v=star[i].to;
			if(star[i].flow&&!dep[v]){
				dep[v]=dep[u]+1;
				q.push(v);
				if(v==T) return 1;
			}
		}
	}
	return 0;
}
int dinic(int u,int flow)
{
	if(u==T){
		return flow;
	}
	int rest=flow,tmp;
	for(register int i=head[u];i&&rest;i=star[i].nxt){
		int v=star[i].to;
		if(dep[v]==dep[u]+1){
			tmp=dinic(v,min(star[i].flow,rest));
			star[i].flow-=tmp;
			star[i^1].flow+=tmp;
			rest-=tmp;
		}
	}
	return flow-rest;
}
int main()
{
	int t;
	cin>>t;
	S=201,T=202;
	while(t--){
		cnt=1;
		memset(head,0,sizeof(head));
		vec1.clear();
		vec2.clear();
		memset(vis,0,sizeof(vis));
		memset(bo,0,sizeof(bo));
		memset(star,0,sizeof(star));
		memset(mmap,0,sizeof(mmap));
		int n;
		scanf("%d",&n);
		for(register int i=1;i<=n;i++){
			scanf("%d",&vis[i]);
			if(vis[i]) vec2.push_back(i+n);
		}
		int num=0;
		for(register int i=1;i<=n;i++){
			cin>>bo[i];
			if(vis[i]==0){
				vec1.push_back(i);
				++num;
			}
			else if(bo[i]==0){
				vec1.push_back(i);
				++num;
			}
		}		
		for(register int i=1;i<=n;i++){
			for(register int j=1;j<=n;j++){
				scanf("%d",&mmap[i][j]);
			}
			mmap[i][i]=1;
		}
		for(register int i=0;i<vec1.size();i++){
			for(register int j=0;j<vec2.size();j++){
				if(mmap[vec1[i]][vec2[j]-n]){
					add(vec1[i],vec2[j],1);
					add(vec2[j],vec1[i],0);
				}
			}
		}
		for(int i=0;i<vec1.size();i++){
			add(S,vec1[i],1);
			add(vec1[i],S,0);
		}
		for(int i=0;i<vec2.size();i++){
			add(vec2[i],T,1);
			add(T,vec2[i],0);
		}
		int maxflow=0;
		while(bfs()){
			int flow;
			while(flow=dinic(S,999999999)) maxflow+=flow;
		}
		if(maxflow==num){
			cout<<"^_^"<<endl;
		}
		else{
			cout<<"T_T"<<endl;
		}
	}
	
} 
```



---

## 作者：liuzitong (赞：1)

好像没有用邻接表存的啊(好像有不少(逃))

我这里写一种毒瘤加边(反正我看题解没有跟我加边一样的)

好长时间没更博客了

因为实在太蒻了

![](https://img2018.cnblogs.com/blog/1661066/201907/1661066-20190713092312186-1025201458.png)

这让本蒟蒻怎么办

今天终于遇到了一道模板题(之前也有,不过太蒻了都不会)

不过...写代码5分钟,调试2小时

-----------

分界线:回归正题

这个就是普通的匈牙利算法 差不多

# 思路:

我们需要统计出谁需要床,谁有床

我们的二分图就是  **需要的人**  和  **床**

跑匈牙利就好了

## 什么人不需要床?? 在校且回家的人 


## 什么床能用?? 在校的人


由于人的序号和床的序号会重复

所以我在床的序号上加了m,(比如一共有3个人,一号床的"名字"就是4)

~~如果还不明白上面那句那就可以理解为#define 一号床 4~~

由于题目要求输入是邻接矩阵,所以我们可以只读入一半(左上角和右下角连线以左不读)
因为人的信任是相互的

对应好之后就可以了




做这道题,怎么做?

1 : 学会匈牙利算法,不管你用Google.Baidu.360.搜狗.bing.yandex......什么引擎(能用就行)
都有很生动的例子,这里不再赘述

2 : 学会图论基本知识,会用邻接表存边(只会邻接矩阵的话可以先学一学或者看懂我的之后自己写)

3 : 写代码,就是用你的小爪爪摸一下键盘

4 : debug,dalao自行跳过

5 : 最重要的一步:





# 打上神兽!!!!
```


       ┌─┐        ┌─┐
   ┌─┘  ┴────┘  ┴─┐
   │                        │
   │         ───         │
   │  ─┬┘        └┬─  │
   │                        │
   │         ─┴─         │
   │                        │
   └──┐            ┌──┘
         │            │
         │            │
         │            │
         │            │
         │            │
         │            │
         │            │
         │            └──────────┐
         │                                  │
         │                                  ├─┐
         │                                  ┌─┘
         │                                  │
         └─┐  ┐  ┌────┬  ┐  ┌──┘
             │─┤─┤        │─┤─┤
             └─┴─┘        └─┴─┘
                           神兽保佑
                         代码无BUG!

```
看起来好像不大对,但是粘贴到记事本或sublime(Dev也行)

就会变成非常帅气的样子

现在贴代码
```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){int s=0,w=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();return s*w;}
inline void write(int x) {if(x<0) putchar('-'),x=-x; if(x>9) write(x/10); putchar(x%10+'0'); }

int u[10001],v[10001],f[10001],N[10001],g[10001];
bool bj[10001],bj2[10001],book[10001];

void add(int x,int y,int z){//邻接表存边
    u[z] = x; v[z] = y;

	N[z] = f[x]; f[x] = z;
}

bool find(int x){//匈牙利模板
	for(int i = f[x];i != -1;i = N[i]){
		int p = v[i];
		if(!book[p]){
			book[p] = 1;
			if(g[p] == 0 || find(g[p])){
				g[p] = x;
				return 1;
			}
		}
	}
	return 0;
}

int main(int argc, char const *argv[])
{
	int yy;
	yy = read();

	while(yy){
		int tt = 0;
		yy--;
		memset(f,-1,sizeof f);//多测不清空,爆零两行泪
		memset(u,0,sizeof u);
		memset(v,0,sizeof v);
		memset(g,0,sizeof g);
		memset(bj,0,sizeof bj);
		memset(bj2,0,sizeof bj2);

		int m,x,tot = 0;
		m = read();

		for(int i = 1;i <= m;++i) bj[i] = read();//在校标记
		
		for(int i = 1;i <= m;++i) {
			x = read();
			bj2[i] = x;//是否回家的标记
			
			if(!bj[i]) bj2[i] = 0;//不在校就可以当不回家处理(因为需要床)
			if(bj2[i]) tt++;
		}

		for(int i = 1;i <= m;++i){
			for(int j = 1;j <= m;++j){
				x = read();
				if(i > j) continue;//只读一半

				if(i == j && bj[i])//自己可以睡自己的床
					x = 1;
				if(x == 0) continue;//不能互相睡床不存边
				
				if(bj[j] && !bj2[i]){//j有床i不回家就加边
		//			cout<<i<<" "<<j<<endl;
					add(i,m + j,++tot);
				}
				
				if(i == j) continue;
				
				if(bj[i] && !bj2[j]){//同理
		//			cout<<j<<" "<<i<<endl;
					add(j,m + i,++tot);
				}
			}
		}

		// for(int i = 1;i <= m;++i){
		// 	cout<<f[i]<<" "<<N[i]<<endl;
		// }

		int cnt = 0;
		for(int i = 1;i <= m;++i){
			memset(book,0,sizeof book);
			if(find(i)) cnt++;
		}
		
		if(cnt == m - tt) cout<<"^_^"<<"\n";
		else cout<<"T_T"<<"\n";
	}
	return 0;
}

/***
  *        ┌─┐        ┌─┐
  *    ┌─┘  ┴────┘  ┴─┐
  *    │                        │
  *    │         ───         │
  *    │  ─┬┘        └┬─  │
  *    │                        │
  *    │         ─┴─         │
  *    │                        │
  *    └──┐            ┌──┘
  *          │            │
  *          │            │
  *          │            │
  *          │            │
  *          │            │
  *          │            │
  *          │            │
  *          │            └──────────┐
  *          │                                  │
  *          │                                  ├─┐
  *          │                                  ┌─┘
  *          │                                  │
  *          └─┐  ┐  ┌────┬  ┐  ┌──┘
  *              │─┤─┤        │─┤─┤
  *              └─┴─┘        └─┴─┘
  *                            神兽保佑
  *                          代码无BUG!
  */


```

---

## 作者：Edward_Elric (赞：0)

### [题目传送门](https://www.luogu.org/problemnew/show/P2055)
**这题可以算比较经典的拆点了，作为一个萌新，我想了很久的建图，后来想到，可以把人和床作为二分图的两个点集拆开建图A点集代表人（i），B点集代表床（i+n），用goal记下需要回家的人数**

### 思路

**1.如果不是我校学生，那么将其人就连向s。把goal++**

**2.如果是我校学生就将他的人连向床，并把他的床连向t，同时如果他不回家就将人连向s，并且goal++。**

**3.如果两人认识就将该人连向对方的床**

**这样一个二分图模版就建好了，像这样(样例)**
![](https://cdn.luogu.com.cn/upload/pic/54075.png)
**用网络流跑一跑判断flow是否等于goal就可以了**
### 代码
用的是**Ford-Fulkerson**（增广路）其实这东西有时候比dinic还快一点
```cpp
#include<bits/stdc++.h>
#define inf 1<<30
using namespace std;
const int maxn=500+5,maxm=250000+5;
int head[maxn],vis[maxn],sch[maxn];
int s,t,flow=0;
int goal=0;
struct edge
{
	int to,next,cap;
}e[maxm];
int size=1;
void addedge(int u,int v,int val)
{
	e[++size].to=v;e[size].cap=val;e[size].next=head[u];head[u]=size;
	e[++size].to=u;e[size].cap=0;e[size].next=head[v];head[v]=size;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(e,0,sizeof(e));
	memset(sch,0,sizeof(sch));
	flow=0,goal=0;
}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int dfs(int u,int f)
{
	if(u==t)return f;
	vis[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int to=e[i].to;
		if(!vis[to]&&e[i].cap>0)
		{
			int d=dfs(to,min(f,e[i].cap));
			if(d>0)
			{
				e[i].cap-=d;
				e[i^1].cap+=d;
				return d;
			}
		}
	}
	return 0;
}
int maxflow()
{
	while(1)
	{
		memset(vis,0,sizeof(vis));
		int f=dfs(s,inf);
		if(f==0)return flow>=goal;
		flow+=f;
	}
}
int main()
{
	int T=read();
	while(T--)
	{
		init();
		int n=read();
		s=0,t=n*2+1;
		for(int i=1;i<=n;i++)
		{	
		sch[i]=read();if(sch[i])addedge(i+n,t,1);
		else addedge(s,i,1),goal++; 
		}
		for(int i=1;i<=n;i++)
		{
		  if(!read()&&sch[i])addedge(s,i,1),addedge(i,i+n,inf),goal++;
		}
		for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		  if(read()==1&&sch[j])addedge(i,j+n,inf);
		maxflow()==1?printf("^_^\n"):printf("T_T\n");
	}
	return 0;
 } 
```




---

## 作者：Ouaoan (赞：0)

题目：[假期的宿舍](https://www.luogu.org/problemnew/show/P2055)

---

[更好的阅读体验？](https://blog.csdn.net/rabbit_ZAR/article/details/85240633)

顺便求关注喵QvQ！

---

![](https://i.loli.net/2018/12/24/5c20f84f8018d.png)

emm……

为什么二分图会写错这么多次？

~~我不会说是因为我建图建错了的……~~

---

思路：

~~我好像没有说过我建错了图~~，~~二分图匹配好像没有什么好说的~~，所以这里说下建图的问题。

首先，我们考虑用学生和空床匹配。

床的个数一定等于本校学生人数，因为不管学生是否离校，他们的床都在。

需要和床匹配的人数就是 没有回家的本校学生人数 + 非本校学生。

所以，一个人 i 可以和 j的床 连边的条件，当且仅当 j 是本校学生，且i是 没有回家的本校学生人数 或本校学生。

然后在这张图上跑二分图模板就好了。

用最大流或者匈牙利随便啦，这里给出匈牙利代码。

---

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define read(x) scanf("%d",&x)
#define maxn 50

int n;
int sc[maxn+5],hm[maxn+5];

vector<int> a[maxn+5];	//i -> bedlist
int mth[maxn+5];

bool use[maxn+5];

bool dfs(int x) {
	if(use[x]) return false;
	use[x]=true;
	for(int i=0;i<a[x].size();i++) {
		int y=a[x][i];
		if((!mth[y])||dfs(mth[y])) {
			mth[y]=x;
			return 1;
		}
	}
	return 0;
}

int main() {
	int T;
	read(T);
	while(T--) {
		int n;
		read(n);
		for(int i=1; i<=n; i++) a[i].clear();
		memset(mth,0,sizeof(mth));
		for(int i=1; i<=n; i++) read(sc[i]);
		for(int i=1; i<=n; i++) read(hm[i]);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++) {
				int z;
				read(z);
				if(sc[i]&&hm[i]) continue;
				if(!sc[j]) continue;
				if(!z) continue;
				a[i].push_back(j);
			}
		for(int i=1;i<=n;i++) if(sc[i]&&!hm[i]) a[i].push_back(i);
		
		int cnt=n;
		for(int i=1; i<=n; i++) if(sc[i]&&hm[i]) cnt--;

		int ans=0;
		for(int i=1; i<=n; i++) {
			memset(use,0,sizeof(use));
			if(dfs(i)) ans++;
		}
		
		if(ans==cnt) printf("^_^");
		else printf("T_T");
		printf("\n");
	}

	return 0;
}
```

---

## 作者：wjjz (赞：0)

~~所有写这道题的估计就我最弱了~~

# **爆搜**

二分图匹配？什么东西，这题不是爆搜吗？

先找出所有没床的人，建一个队列，按照顺序一个个帮人安家落户。

什么？原先床有人怎么办？先看看认不认识，认识就打声招呼，你走。

~~抱歉，没床就是可以那么为所欲为。~~

可怜的家伙被我们赶出它自己的领地了，但我们毕竟是心地善良的组织，总不能看它流落街头吧，把被赶出的家伙也入队。

之后继续我们的安家旅程吧，如果不能成功就说明我们安家方案不够好，那么我们就需要重新选一个安家方案，递推，递归就可以解决了。~~不要一想到方案就是模拟退火~~

~~暴力大法好，入教拿省一~~

总之，想不出来正解的题，要打暴力，也许就能A呢。

剩下的看代码吧。~~自认为还是很好懂得~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
int l[60],h;//建队 
int n; 
bool a[60],b[60],c[60][60];//a标记有无床，b标记是否在校，c标记关系 
bool dfs(int x)
{
	if(x>h){ printf("^_^\n"); return 1; }//队伍处理完了，完成任务。 
	int y=l[x];
	for(int i=1;i<=n;i++)
	{
		if(c[y][i]==1&&a[i])//看看认不认识，有没有床 
		{
			if(b[i])//不在的不入队 
			{
			a[i]=0;	//安家落户，就不能再打扰他了 
			if(dfs(x+1))
			return 1;	//处理下一个，如果成功就表示完成 
			
			a[i]=1;//当然，方案失败时，也必须乖乖离开 
			} 
			if(!b[i])
			{
			h++; l[h]=i; a[i]=0; //心地善良的我们不会放弃每一个无家可归的孩子，即使是我们撵它出去的 
			if(dfs(x+1)) return 1; 
			h--; a[i]=1;//注意h--，别忘了 
			} 
		}
	}
	return 0;
}
int main()
{
	int T,x,y;
	scanf("%d",&T);//多组数据 
	while(T--){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		h=0;//注意更新 
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
		scanf("%d",&a[i]);
		if(!a[i]){h++;	l[h]=i;}//把无家可归的入队 
		} 
		for(int i=1;i<=n;i++)
		{
		scanf("%d",&x);
		if(a[i]) b[i]=x;//标记回家的，回家的就不管它们了，让它们自生自灭吧 
		}
		for(int i=1;i<=n;i++)
		for(int t=1;t<=n;t++) scanf("%d",&c[i][t]);//标记关系 
		if(!dfs(1)) printf("T_T\n");//失败了，没辙，能力之外，告辞。 
	}
	return 0;
}
```

~~为了题解，可怜了我的压行码风啊QAQ~~

---

## 作者：QWsin (赞：0)

-> ->刚学了网络流  就来搞一搞这个题

-> ->本来觉得二分图最大匹配是一个多么难搞的事情但是建模建出来了还是不难  而且我一A了  hhhhh

-> ->没学二分图  用最大流强行做的

-> ->难点在建模 先来两个集合  标准二分图，左边X右边Y  每个学生一边一个点  左边编号i  右边就是编号i+n

-> ->首先  建超级源  跟X中不回家的本校学生和外校的连一条cap=1的边表示需要床位

-> ->然后对于X中的需要床的人  向Y中他们认识的本校学生连一条cap=1的边  如果这个需要床的人是本校的，跟Y中与自己对应的点连一条cap=1得边

-> ->最后   Y中所有点跟超级终点连一条cap=1得边

-> ->好了  然后最大流吧  我是用的最简单的BFS  （其他的还没学）

-> ->求出最大流之后。。。好像直接判一下maxflow是否等于需要床的人数就行了    实际上我是判：从超级源点出来的每条边都流量都是1   （因为这是需要床睡的，没有流量的话就没有床睡）

-> ->这样就把二分图水过去了

一百多行1A还是有点小激动

```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=200;
const int maxm=50000;
const int INF=(1<<30);
struct Edge{
    int u,v,cap,flow;
    Edge(){}
    Edge(int u,int v,int c,int f):u(u),v(v),cap(c),flow(f){}
}e[maxm];

int n;

int first[maxn],next[maxm],ecnt;
void add_edge(int u,int v,int cap)
{
    next[ecnt]=first[u];first[u]=ecnt;e[ecnt++]=Edge(u,v,cap,0);
    next[ecnt]=first[v];first[v]=ecnt;e[ecnt++]=Edge(v,u,0,0);
}

int inxue[maxn],back[maxn];
void init_data()
{
    cin>>n;ecnt=0;
    memset(first,-1,sizeof(first));
    for(int i=1;i<=n;i++) scanf("%d",inxue+i);
    for(int i=1;i<=n;i++) 
      if(inxue[i]) scanf("%d",back+i);
      else scanf("%*s");
    for(int i=1;i<=n;i++)
    {
        if(inxue[i]) add_edge(i,i+n,1);
        for(int j=1,bo;j<=n;j++)
        {
            scanf("%d",&bo);
            if(bo&&inxue[j]) add_edge(i,j+n,1); 
        }
    }
    int s=2*n+1,t=2*n+2;
    for(int i=1;i<=n;i++)
      if(!inxue[i]||!back[i]) add_edge(s,i,1);
    for(int i=1;i<=n;i++)
      add_edge(i+n,t,1);
}

int a[maxn],p[maxn];
int Maxflow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        memset(a,0,sizeof(a));
        queue<int>q;
        q.push(s);
        a[s]=INF;
        while(!q.empty())
        {
            int x=q.front();q.pop();
            for(int i=first[x];i!=-1;i=next[i])
            {
                if(!a[e[i].v]&&e[i].cap>e[i].flow)
                {
                    a[e[i].v]=min(a[x],e[i].cap-e[i].flow);
                    p[e[i].v]=i;
                    q.push(e[i].v);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        flow+=a[t];
        for(int i=t;i!=s;i=e[p[i]].u)
        {
            e[p[i]].flow+=a[t];
            e[p[i]^1].flow-=a[t];
        }
    }
    return flow;
}

int check()
{
    for(int i=first[2*n+1];i!=-1;i=next[i])
      if(e[i].cap!=e[i].flow) return false;
    return true;
}

int main()
{
    int T;cin>>T;
    while(T--)
    {
        init_data();
        Maxflow(2*n+1,2*n+2);
        if(check()) printf("^_^\n");//其实对于这种输出。。。我沉默
        else printf("T_T\n");
    }
    return 0;
}


```

---

## 作者：Skywalker_David (赞：0)

裸的二分图匹配。把需要床的的人和认识的人的床连接（自己也算！）

```cpp

#include <iostream>  
#include <cstdio>  
#include <cstdlib>  
#include <cstring>  
#include <cmath>  
#include <algorithm>  
using namespace std;  
const int maxn=5003;  
int n,ck[maxn],mch[maxn],stu[maxn],lft[maxn];  
int tot,ans,to[maxn*2],fst[maxn],nxt[maxn*2],cnt;  
inline int get(){  
    char c;while(!isdigit(c=getchar()));  
    int v=c-48;while(isdigit(c=getchar()))v=v*10+c-48;  
    return v;  
}  
inline void add(int x,int y){to[++cnt]=y;nxt[cnt]=fst[x];fst[x]=cnt;}  
inline bool dfs(int x){                
    for(int i=fst[x];i;i=nxt[i]){  
        if(!ck[to[i]]){  
            ck[to[i]]=1;  
            if(mch[to[i]]==-1 || dfs(mch[to[i]])){  
                mch[x]=to[i];  
                mch[to[i]]=x;  
                return 1;  
            }  
        }  
    }  
    return 0;  
}  
int main(){  
    int T=get();  
    while(T--){  
        memset(mch,-1,sizeof(mch));  
        memset(fst,0,sizeof(fst));  
        memset(nxt,0,sizeof(nxt));  
        memset(to,0,sizeof(to));  
        n=get();ans=0;cnt=0;bool f=1;  
        for(int i=1;i<=n;++i)stu[i]=get();  
        for(int i=1;i<=n;++i){  
            lft[i]=get();  
            if(stu[i]&&!lft[i])add(i,i+n);  
        }  
        for(int i=1;i<=n;++i)for(int j=1;j<=n;++j){  
            int x=get();  
            if(!stu[i]||(stu[i]&&!lft[i]))  
                if(x&&stu[j])add(i,j+n);  
        }  
        for(int i=1;i<=n;++i){  
            if(!stu[i]||(stu[i]&&!lft[i])){  
                memset(ck,0,sizeof(ck));  
                if(!dfs(i))f=0;  
            }  
        }  
        if(f)printf("^_^\n");  
        else printf("T_T\n");  
    }  
    return 0;  
}  

```

---

## 作者：t162 (赞：0)

解题思路在代码中。

```cpp
/*
* 我的思路：遇到需要住宿的人就让他和源点之间连一条容量是1的边；
* 如果是在校学生就把他的床和汇点之间连一条容量是1的边；
* 把每个不回家的在校学生和自己的床之间连一条容量是1的边；
* 把每个人和自己认识的人的床（如果有的话）之间连一条容量是1的边；
* 最后跑一遍Dinic再判断流量是否等于需要住宿的总人数即可。
*/

#include<bits/stdc++.h>
using namespace std;
#define Standard_Type long long
#define Content_Type long long
#define setEmpty(q) while(!q.empty())q.pop()
#define FILL(a,b) memset(a,b,sizeof a)
#define INF 2147483647
#define MAXM 200001
#define Queue_Standard_Type queue<Standard_Type>

/*Start : Struct declaration*/
struct __EDGE{
	Standard_Type from,to,next;
	Content_Type w;
	__EDGE(){
		from=0;
		to=0;
		next=0;
		w=0;
	}
};
/*End : Struct declaration*/

/*Start : Variable declaration*/
__EDGE edge[MAXM];
Standard_Type edgeHead[MAXM]={-1},edgeCount=-1,flag[MAXM],S,V;
Standard_Type n;
vector<Standard_Type> va,vb;
bool vis[100];
/*End : Variable declaration*/
 
/*Start : Function declaration*/
void INIT(); 
void Add(Standard_Type,Standard_Type,Content_Type);

bool BFS();

Content_Type DFS(Standard_Type,Content_Type);
Content_Type Dinic();


/*End : Function declaration*/

int main(){
	scanf("%lld",&n);
    while(~scanf("%lld",&n)){
        S=0;
        V=n+n+1;
        INIT();
        int x,tot=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&x);
            vis[i]=x;
            if(!x)tot++;
        }
        for(int i=1;i<=n;i++){
            scanf("%d",&x);
            if(vis[i]){
                Add(i+n,V,1);
                Add(V,i+n,0);
                if(!x){
                    tot++;
                    Add(S,i,1);
                    Add(i,S,0);
                    Add(i,i+n,1);
                    Add(i+n,i,0);
                }
            }else{
                Add(S,i,1);
                Add(i,S,0);
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                scanf("%d",&x);
                if(x&&vis[j]){
                    Add(i,j+n,1);
                    Add(j+n,i,0);
                    Add(j,i+n,1);
                    Add(i+n,j,0);
                }
            }
        }
        if(Dinic()>=tot)puts("^_^");
        else puts("T_T");
    }
	return 0;
}

/*Start : Define*/
void INIT(){
	FILL(edgeHead,-1);
    FILL(vis,0);
}
void Add(Standard_Type from,Standard_Type to,Content_Type w){
	edge[++edgeCount].from=from;
	edge[edgeCount].to=to;
	edge[edgeCount].w=w;
	edge[edgeCount].next=edgeHead[from];
	edgeHead[from]=edgeCount;
}
bool BFS(){
	Standard_Type from,to;
	Queue_Standard_Type Queue;
	FILL(flag,-1);
	setEmpty(Queue);
	flag[S]=0;
	Queue.push(S);
	while(!Queue.empty()){
		from=Queue.front();
		Queue.pop();
		for(Standard_Type i=edgeHead[from];i!=-1;i=edge[i].next){
			to=edge[i].to;
			if(edge[i].w!=0&&flag[to]==-1){
				Queue.push(to);
				flag[to]=flag[from];
				flag[to]++;
			}
		}
	}
	if(flag[V]!=-1)return true;
	return false;
}
Content_Type DFS(Standard_Type from,Content_Type flow){
	if(from==V)return flow;
	Content_Type result=flow,minW;
	for(Standard_Type i=edgeHead[from];i!=-1;i=edge[i].next){
		if(result<=0)return flow-result;
		if(edge[i].w!=0&&flag[from]==flag[edge[i].to]-1){
			minW=DFS(edge[i].to,min(result,edge[i].w));
			edge[i^1].w+=minW;
			edge[i].w-=minW;
			result-=minW;
		}
	}
	return flow-result;
}
Content_Type Dinic(){
	Content_Type result=0;
	while(BFS()){
		result+=DFS(S,INF);
	}
	return result;
}
/*End : Define*/
```

附：样例的图

![](https://i.loli.net/2019/08/14/RHTL9cG4pb7vaZr.png)

上图最大流是2，等于需要住宿的人数，所以答案是`^_^`。

本来按照我的建图思路，P2和B1之间还有一条单向边。但鉴于P2未和源点连接，也就没画。

---

## 作者：秋日私语 (赞：0)

更好的阅读体验点[这里](http://blog.csdn.net/a_comme_amour/article/details/79553186)

题目
-

[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1433)
题解
-

这个题想了很久。如何建图？
1. 有床的向**汇点**连边 
2. **源点**向需要床的连边，边权都为1
3. 跑最大流判断maxflow 是否和需要住宿的人tot相等即可

代码倒很简单，关键在于怎么想到的。（待更新）
相当于是一个 需要床的 和 有床的 一个匹配
还是自行参悟吧

代码
-

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
const int maxn=1001;
const int inf=1e9;

queue <int> q;
int T,n,maxflow,tot;
struct Edge{
	int next,to,dis;
}edge[maxn<<1];
int head[maxn],num_edge=-1,cur[maxn],deep[maxn];
bool sch[maxn],home[maxn];

void add_edge(int from,int to,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].to=to;
	edge[num_edge].dis=dis;
	head[from]=num_edge;
}

bool bfs(int s,int t)
{
	memset(deep,0x7f,sizeof(deep));
	for (int i=0; i<=t; i++) cur[i]=head[i];
	while (!q.empty()) q.pop();
	deep[s]=0; q.push(s);
	while (!q.empty())
	{
		int now=q.front(); q.pop();
		for (int i=head[now]; i!=-1; i=edge[i].next){
			int to=edge[i].to;
			if (deep[to]>inf && edge[i].dis)
			{
				deep[to]=deep[now]+1;
				q.push(to);
				if (to==t) return true;
			}
		}
	}
	return deep[t]<inf;
}

int dfs(int now,int t,int limit)
{
//	printf("%d %d\n",now,limit);
	if (now==t || !limit) return limit;
	int flow=0,f;
	for (int i=head[now]; i!=-1; i=edge[i].next)
	{
		cur[now]=i; int to=edge[i].to;
//		printf("%d: %d %d %d\n",i,edge[i^1].to,to,edge[i].dis);
		if (deep[to]==deep[now]+1 && (f=dfs(to,t,min(edge[i].dis,limit))))
		{
//			printf("f: %d %d\n",f,edge[i].to);
			flow+=f;
			limit-=f;
			edge[i].dis-=f;
			edge[i^1].dis+=f;
			if (!limit) break;
		}
	}
	return flow;
}

void Dinic(int s,int t)
{
	while (bfs(s,t))
		maxflow+=dfs(s,t,inf);
}

int main()
{
	scanf("%d",&T);
	int ans=0;
	for (int i=1; i<=1e8+1e7; i++) ans++;
	while (T--)
	{
		num_edge=-1; tot=0; maxflow=0;
		memset(head,-1,sizeof(head));
		scanf("%d",&n);
		int s=0; int t=n*2+1;
		for (int i=1; i<=n; i++)
		{
			scanf("%d",&sch[i]);//有床的向汇点连边 
			if (sch[i]) {add_edge(i+n,t,1); add_edge(t,i+n,0);}
		}
		for (int i=1; i<=n; i++) 
		{
			scanf("%d",&home[i]);//源点向需要床的连边 
			if (!sch[i] || (sch[i]&&!home[i])) {tot++; add_edge(s,i,1); add_edge(i,s,0);}
		}
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
			{
				int x; scanf("%d",&x);
				if (x || i==j) {add_edge(i,j+n,1); add_edge(j+n,i,0);}
			}
//		for (int i=0; i<=num_edge; i++) printf("%d: %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].dis);
		Dinic(s,t);
		if (maxflow==tot) printf("^_^\n");
		else printf("T_T\n");
	}
	return 0;
}
```

总结
-
注意节点的编号 +n 防止重复
S和T最好定义为变量，T应该为2*n+1 而不是 2*n，因这里WA掉了

---


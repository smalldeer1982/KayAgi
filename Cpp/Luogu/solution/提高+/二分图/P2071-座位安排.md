# 座位安排

## 题目背景

公元二零一四年四月十七日，小明参加了省赛，在一路上，他遇到了许多问题，请你帮他解决。


## 题目描述

已知车上有 $N$ 排座位，有 $2N$ 个人参加省赛，每排座位只能坐两人，且每个人都有自己想坐的排数，问最多使多少人坐到自己想坐的位置。

## 说明/提示

对于 $10\%$ 的数据，$n \le 10$；

对于 $30\%$ 的数据，$n \le 50$；

对于 $60\%$ 的数据，$n \le 200$；

对于 $100\%$ 的数据，$n \le 2000$。

## 样例 #1

### 输入

```
4
1 2
1 3
1 2
1 3
1 3
2 4
1 3
2 3
```

### 输出

```
7```

# 题解

## 作者：hhhhyq (赞：26)

今天自学了二分图匹配，想找个题做，于是在洛谷上找题“最大匹配”、“难度排序”，就找到了“P2071 座位安排 ”这道神仙题

还好还好做出来了

然后~~心虚看了看题解~~ 看题解学习一下，发现我的做法竟然和题解不一样（emmm就两篇还有一个是网络流 tttql）

然后就这个题面都提示了是二分图匹配

于是朴素的二分图匹配代码：

```cpp
 bool dfs(int now){
    for (int a=1;a<=n2;a++)
        if (!use[a] && match[now][a]){
            use[a]=true;
            if (!result[a] || dfs(result[a])){
                result[a]=now;
                return true;
            }
        }
    return false;
}

int xiongyali(){
    int ans=0;
    for (int a=1;a<=n1;a++){
        memset(use,false,sizeof(use));
        if (dfs(a)) ans++;
    }

    return ans;
}
```

如果是匈牙利算法都不会的同学先自学一下吧，挺简单的hhh（毕竟我都能学会），板子在[ P3386 【模板】二分图匹配](https://www.luogu.org/problemnew/show/P3386)

观察到：每排椅子都可以对应两个人，而我们用result数组来表示右图中的一个点所对相应的左图中的一个点，所以我们把result数组开二维就好了吧hhhh突然感觉好简单......

还有用邻接矩阵存理论复杂度O(n^3),果断邻接链表 理论复杂度O(nm) （这都是理论最大值，实际不会这么大）

代码（邻接矩阵 60）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iomanip>
#include<cstring>
using namespace std;

typedef long long ll;
const int maxn=4004;

int n,m,e;
int result[maxn][2],use[maxn];
int g[maxn][maxn];

bool dfs(int now){
    for(int i=1;i<=n;i++){
        if(!use[i]&&g[now][i]){
            use[i]=true;
            if(!result[i][0]||dfs(result[i][0])){
                result[i][0]=now;
                return true;
            }
            if(!result[i][1]||dfs(result[i][1])){
                result[i][1]=now;
                return true;
            }
        }
    }
    return false;
}

int xiongyali(){
    int ans=0;
    for(int i=1;i<=n*2;i++){
        memset(use,0,sizeof(use));
        if(dfs(i))ans++;
    }
    return ans;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n*2;i++){
        int a,b;scanf("%d%d",&a,&b);
        g[i][a]=1;g[i][b]=1;
    }
    printf("%d\n",xiongyali());
}

```

代码（邻接链表 100分）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iomanip>
#include<cstring>
using namespace std;

typedef long long ll;
const int maxn=4004;
struct edge{
	int v,nxt;
}e[maxn*16];
int n,m,cnt=0;
int result[maxn][2],use[maxn];
int head[maxn];

void add_edge(int u,int v){
	++cnt;
	e[cnt]=(edge){v,head[u]};
	head[u]=cnt;
}

bool dfs(int now){
	
	for(int j=head[now];j;j=e[j].nxt){
		int v=e[j].v;
		if(!use[v]){
		use[v]++;
		if(!result[v][0]||dfs(result[v][0])){
			result[v][0]=now;
			return true;
		}
		if(!result[v][1]||dfs(result[v][1])){
			result[v][1]=now;
			return true;
		}
	}
	}
		
	
	return false;
}

int xiongyali(){
	int ans=0;
	for(int i=1;i<=n*2;i++){
		memset(use,0,sizeof(use));
		if(dfs(i))ans++;
	}
	return ans;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n*2;i++){
		int a,b;scanf("%d%d",&a,&b);
		add_edge(i,a);
		add_edge(i,b);
	}
	printf("%d\n",xiongyali());
}

```

www求通过


---

## 作者：郎赤娜 (赞：17)

刷二分图时候遇见的一道题……

看题面的时候发现每个人只能坐一个位置，于是~~很容易就能~~想到
# 二分图
如果不会二分图最大匹配问题的话请自行度娘~

确定了是二分图之后我们来考虑一下如何建图。作为基础就是将每排和人作为两个集合中的点，按照喜欢关系进行连边。这道题唯一和二分图模板不一样的地方在于每排可以坐两个人，而模板的话只能一对一进行匹配。怎么办呢？

### 很简单，将每排存两次不就阔以了！（二次存边）

将每一个双人排**a**i都拆成单人排排**b**i和**b**i+n，将这个人和**b**i和**b**i+n进行连边。输入时对于每一个人喜欢的排v，连一个v，再连一个v+n。还是用二分图最大匹配的模板，这样每个拆分后的单人排就可以和人数一一对应了。

接合代码食用更佳呦~但是建议大家自己多思考切莫抄题解，不会的可以评价或者私聊我哦，蒟蒻一定会认真的回答的。

最后祝大家~~NOIP~~CSP一路顺风~
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int to,next;
}e[20100];
int head[20100],tot=0;
inline void add(register int u,register int v)
{
	e[++tot]=(node){v,head[u]};
	head[u]=tot;
}
int n,m,u,v,ans;
int ask[20100],matched[20100];
inline bool found(register int x)
{
	for(register int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		if(ask[v]) continue;
		ask[v]=1;
		if(!matched[v]||found(matched[v]))
		{
			matched[v]=x;
			return true;
		}
	}
	return false;
}
inline void match()
{
	for(register int i=1;i<=n*2;i++)
	{
		memset(ask,0,sizeof(ask));
		if(found(i)) ans++;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n*2;i++)
	{
		scanf("%d%d",&u,&v);
		add(i,u+n*3);
		add(i,u+n*4);
		add(i,v+n*3);
		add(i,v+n*4);//这个地方就是我说的二次存边辣
	}
	match();
	printf("%d\n",ans);
	return 0;
}
```
抄题解者RP--嘤嘤嘤

---

## 作者：三好代表 (赞：11)

**什么？！这个题竟然要用匈牙利算法~~（默默打开搜索引擎）~~**

学会了之后，发现这是个**题

这个题可以被分为两部分

1.匈牙利算法~~（板子）~~

2.邻接表存图（好像这不能称为第二部分）

每一排能坐两个人，那就把一排拆成两个点，

用匈牙利算法求最大匹配

每个人都只想坐两排，说明每个人只会连四条边

如果不会匈牙利的请点[这里](https://blog.csdn.net/sunny_hun/article/details/80627351)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5100;
int link[N],cnt[N],w[N][N];
bool used[N];
int ans,n;
int x,y;
bool find(int x)
{
	for(int i=1;i<=cnt[x];i++)
	{
		if(!used[w[x][i]])
		{
			used[w[x][i]]=true;
			if(!link[w[x][i]] || find(link[w[x][i]]))
			{
				link[w[x][i]]=x;
				return true;
			}
		}
	}
	return false;
}
void xyl()
{
	for(int i=1;i<=n*2;i++)
	{
		memset(used,0,sizeof(used));
		if(find(i))
			ans++;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n*2;i++)
	{
		cin>>x>>y;
		w[i][++cnt[i]]=x;
		w[i][++cnt[i]]=x+n;
		w[i][++cnt[i]]=y;
		w[i][++cnt[i]]=y+n;
	}
	xyl();
	cout<<ans;
	return 0;
}
```

---

## 作者：清远学会 (赞：10)

# 网络流
### ~~简单水过~~
## 简单讲讲建模：
### 1，首先，我们设s,t为我们的超级起点和超级汇点，根据题意，s为0号点，t为3*n+1号点；
### 2，将s与2*n号点连边，流量为1，因为每个人只能做一个位置；
### 3，在2*n个人与n排座位连边，流量不为0就行，这表明可以坐到i排；在这里，为防止编号冲突，设座位排号为2*n+i；
### 4，最后，将n排与t相连，流量为2，这因为每排有两个位置，可以做两个人；
### 建模完成后，乖乖跑一边最大流就行
### 在奉上代码前插一嘴，我在第一次交是RE，而改大后有TLE，把数组的范围开到合适，才过；比如这道，~~瞎开数组会死的很惨；~~
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#define N 50000
#define INF 999999999
using namespace std;

int n;
struct node {
	int from,to,nxt,dis;
}e[N];
int head[N],cnt = 1;
int fa[N],low[N];
int s,t;

inline void cp(int u,int v,int w) {
	cnt ++;
	e[cnt].from = u;
	e[cnt].dis = w;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

queue<int> q;
inline bool BFS() {
	while(!q.empty()) q.pop();
	memset(fa,0,sizeof(fa));
	memset(low,0,sizeof(low));
	low[s] = INF; fa[s] = 1;
	q.push(s);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		if(u == t) return true;
		for(int i = head[u];i;i = e[i].nxt) {
			int v = e[i].to;
			if(!fa[v] && e[i].dis) {
				low[v] = min(e[i].dis,low[u]);
				fa[v] = i;
				q.push(v); 
			}
		}
	} 
	return false;
}

inline int EK() {
	int res = 0;
	while(BFS()) {
		for(int i = t;i != s;i = e[fa[i]].from) {
			int k = fa[i];
			e[k].dis -= low[t];
			e[k ^ 1].dis += low[t];
		}
		res += low[t];
	}
	return res;
}

int main() {
	scanf("%d",&n); s = 0; t = 3 * n + 1;
	for(int i = 1;i <= 2 * n;i ++) 
		cp(s,i,1),cp(i,s,0);
	for(int i = 1;i <= 2 * n;i ++) {
		int opt1,opt2;
		scanf("%d%d",&opt1,&opt2);
		cp(i,opt1 + 2 * n,1);
		cp(opt1 + 2 * n,i,0);
		cp(i,opt2 + 2 * n,1);
		cp(opt2 + 2 * n,i,0);
	}
	for(int i = 1;i <= n;i ++)
		cp(i + 2 * n,t,2), cp(t,i + 2 * n,0);
	cout << EK() << endl;
	return 0;
}
```

---

## 作者：Acestar (赞：5)

一个比较裸的**二分图最大匹配**。

不会的先去学习一下，[P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)。

不难发现是把每个人与希望坐的排数建一条边，但是因为一排有两个座位，所以就把每一排的两个座位拆成两个点，分别建边，再求最大匹配即可。

我把第 $x$ 排的两个座位分别设为 $x$ 和 $x+i$，然后直接向这两个点建边。

```cpp
#include<iostream>
#include<cstdio>
#define N 4010
#define M 16010

using namespace std;

int n;
struct edge
{
	int to,nxt;
}e[M];
int head[N],tot;

void add(int x,int y)	//前向星建边 
{
	e[++tot].to=y;
	e[tot].nxt=head[x];
	head[x]=tot;
}

int tim,t[N],match[N];	//tim:时间戳，后边就不用memset了，直接判断t[v]==tim 

bool dfs(int x)
{
	for(int i=head[x]; i; i=e[i].nxt)
	{
		int v=e[i].to;
		if(t[v]==tim) continue;
		t[v]=tim;
		if(!match[v]||dfs(match[v]))
		{
			match[v]=x;
			return true;
		}
	}
	return false;
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n*2; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(i,x);	//x排第1个座位
		add(i,n+x);	//x排第2个座位 
		add(i,y);
		add(i,n+y);
	}
	int ans=0;
	for(int i=1; i<=n*2; i++)
	{
		tim++;	//时间戳+1 
		if(dfs(i)) ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Vocanda (赞：3)

## 题目
[题目链接](https://www.luogu.com.cn/problem/P2071)

## 分析
一道二分图的基础板子题。

首先每个人都有自己想坐的两排，如果每排只有一个人，那么我们直接建边求出来最大匹配就可以了，但是这个题与众不同的是每一排能够坐下两个人，那么我们在建边的时候就不能单纯的建从人到排数的边了。

每个人都有两个希望坐的排，并且每一排都可以坐下两个人，所以我们在建边的时候再向$n+x$和$n+y$建一条边，其中$x$和$y$都是当前这个人想要坐的排数。

建好边以后就可以直接跑匈牙利了，最后统计答案。
这里我用的是$vector$存图，比较好看。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e4+10;
int n;
int ans;
int match[maxn<<1];
int vis[maxn<<1];
vector<int>g[maxn<<1];
int dfs(int x){//匈牙利算法
	int siz = g[x].size();
	for(int i=0;i<siz;++i){
		int v=g[x][i];
		if(!vis[v]){
			vis[v] = 1;
			if(!match[v] || dfs(match[v])){
				match[v] = x;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=2*n;++i){
		int x,y;
		scanf("%d%d",&x,&y);//建边
		g[i].push_back(x);
		g[i].push_back(y);
		g[i].push_back(x+n);
		g[i].push_back(y+n);
	}
	for(int i=1;i<=2*n;++i){//匈牙利
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	printf("%d\n",ans);
}
```

---

## 作者：唔啊唔 (赞：3)

乍一看这道题，好像没什么思路，但是忽然间就想到了一个巧妙的方法，既然题目说每排座位有两个座位，那我们就可以将座位排数倍增，来得到总座位数，每一个同学连2*2=4条边，在用邻接表存边，再跑一边匈牙利算法就大功告成了

那就顺这思路写下去吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20000;
int n,head[N],num,vis[N],wife[N],husband[N];
struct Edge{
	int to,next;
}edge[N];
inline void add(int from,int to){
	num++;
	edge[num].to=to;
	edge[num].next=head[from];
	head[from]=num;
}
inline int path(int x){	//求増广路 
	for(register int i=head[x];i;i=edge[i].next){	 
		int y=edge[i].to;
		if(vis[y]==0){
			vis[y]=1;
			if(husband[y]==0||path(husband[y])==1){	//走交替路,直到找到未匹配点 
				wife[x]=y;	//再将跑过的交替路全部取反 
				husband[y]=x;	//也就是匹配边变为非匹配边,非匹配边变为匹配边 
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	scanf("%d",&n);
	int x,y,ans=0;
	for(register int i=1;i<=2*n;i++){
		scanf("%d%d",&x,&y);	//利用倍增来存边 
		add(i,x);
		add(i,n+x);
		add(i,y);
		add(i,n+y);
	}
	for(register int i=1;i<=2*n;i++){	//匈牙利算法模板,求最多能匹配几条边 
		if(wife[i]==0){
			memset(vis,0,sizeof(vis));
			ans+=path(i);
		}
	}
	printf("%d",ans);
	return 0;
}
```

如果各位没看懂想学一下匈牙利算法的话，请看[这篇文章](https://blog.csdn.net/qq_40938077/article/details/80410356)的匈牙利算法部分

---

## 作者：VenusM1nT (赞：3)

二分图匹配？不存在的！

这种好题当然要用网络流啊！【大雾】

---
好了不闹了……

这题的二分图匹配做法我一时半会儿想不出来……但是网络流做法非常非常明显

所以就瞎糊了一个网络流上去……$AC$了……

一开始还以为要拆点，后来一想直接连到汇点边权为$2$不就行了吗……

来讲讲建模好了……

设置超级源点$s$为$0$，超级汇点为$n*3+1$，从超级源点朝每个人连一条流量为$1$的边，同时对每个人向每排座位连一条流量为$1$的边，再对每排座位向超级汇点连一条流量为$2$的边，跑$Dinic$轻松水过

代码见下

```cpp
#include<bits/stdc++.h>
#define inf 2147400000
using namespace std;
queue <int> q;
int cnt=1,fst[10005],nxt[200005],to[200005],w[200005],cur[10005];
int n,S,T,dep[10005];
void AddEdge(int u,int v,int c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
bool Bfs()
{
	memset(dep,0,sizeof(dep));
	q.push(S);
	dep[S]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v] && w[i])
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[T];
}
int Dfs(int u,int flow)
{
	if(u==T || !flow) return flow;
	int used=0;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=to[i];
		if(dep[v]==dep[u]+1 && w[i])
		{
			int fl=Dfs(v,min(flow,w[i]));
			if(fl)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(!flow) break;
			}
		}
	}
	return used;
}
int Dinic()
{
	int sum=0;
	while(Bfs())
	{
		memcpy(cur,fst,sizeof(fst));
		sum+=Dfs(S,inf);
	}
	return sum;
}
int main()
{
	scanf("%d",&n);
	S=0;
	T=n*3+1;
	for(int i=1;i<=n*2;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		AddEdge(i,x+n*2,1);
		AddEdge(x+n*2,i,0);
		AddEdge(i,y+n*2,1);
		AddEdge(y+n*2,i,0);
	}
	for(int i=1;i<=n*2;i++)
	{
		AddEdge(S,i,1);
		AddEdge(i,S,0);
	}
	for(int i=1;i<=n;i++)
	{
		AddEdge(i+n*2,T,2);
		AddEdge(T,i+n*2,0);
	}
	int ans=Dinic();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Zxx200611 (赞：1)

其实这题就是一题比较水的二分图匹配,用不加优化的匈牙利也能过  
大体思路就是把**一排拆成两排**,然后跑一遍匈牙利  
于是建图的代码就可以糊出来了
```cpp
n=2*m;
int a,b;
for(int i=1;i<=n;i++)
{
	cin>>a>>b;
	G[i].push_back(a);
	G[i].push_back(b);
	G[i].push_back(a+m);//把每排拆开
	G[i].push_back(b+m);
}
```  
~~`vector`存图最好了~~  
那么建图后，跑匈牙利就好了
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> G[4010];//vector存图
int mat[4010];
bool vis[4010];
bool dfs(int u)
{
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		if(!vis[v])
		{
			vis[v]=1;
			if(!mat[v]||dfs(mat[v]))
			{
				mat[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int maxmatch(int m)//匈牙利模板
{
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	return ans;
}
int main()
{
	int n,m;//n为人数，m为排数
	cin>>m;
	n=2*m;//每排两人
	int a,b;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		G[i].push_back(a);
		G[i].push_back(b);
		G[i].push_back(a+m);
		G[i].push_back(b+m);
	}
	cout<<maxmatch(m*2);//注意了，已经把每排拆成了两排，所以匹配时m*2
}
```

---

## 作者：杳冥 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2071)

显然是一个二分图匹配的题 ~~提示中说的~~

这个题就是将 $2*N$ 个人与 $N$ 排座位进行匹配，不过要注意每排座位可以做两个人。
![](https://cdn.luogu.com.cn/upload/image_hosting/xwqyr5ie.png)

可以将每排右边的座位（绿色框中）整体移到最后一排左边位置的后面。这样的话，第 $a$ 排左边的座位编号为 $a$ ，第 $a$ 排右边的座位编号就为 $a + n$ 。

这样对每排的座位分析完之后，剩下的就是一个二分图匹配的模板了。

还有一点，就是要用邻接表来存图，否则会$TLE$.我用$vector$来模拟的邻接表。

$AC$代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int maxn=5000;
int n,m,e,a,b;
vector<int> q[maxn];
int re[maxn];
bool use[maxn];
bool dfs(int p){
    for(int i=0;i<q[p].size();++i){
        if(use[q[p][i]]){
            use[q[p][i]]=false;
            if(!re[q[p][i]] || dfs(re[q[p][i]])){
                re[q[p][i]]=p;
                return true;
            }
        }
    }
    return false;
}
void xyl(){
    int ans=0;
    for(int i=1;i<=2*n;++i){
        memset(use,true,sizeof(use));
        if(dfs(i)) ans++;
    }
    printf("%d",ans);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=2*n;++i){
        scanf("%d%d",&a,&b);
        q[i].push_back(a);
        q[i].push_back(b);
        q[i].push_back(a+n);
        q[i].push_back(b+n);
    }
    xyl();
    return 0;
}
```


---

## 作者：Khassar (赞：1)

/\*
没有题解，那我来一篇

挺明显的二分图最大匹配，每一排能坐两个人，那就把一排拆成两个点，

把这个人和他想坐的一排两个点都连上边，用匈牙利算法求最大匹配

每个人都只想坐两排，说明每个人只会连四条边，N又辣么大……

其实我想说千万不要用邻接矩阵，邻接表就好，不然会T八组，没错有二十组数据

\*/








```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#define ll long long
#define R register
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define D double
using namespace std;
const int N=4005; 
int n,w[N][100],link[N],ans,cnt[N];
bool vis[N];
inline int read() {//读入及输出优化 
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
inline void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
bool dfs(int x) {
//匈牙利算法跑最大匹配，其实我觉得，这个没什么好说的，和普通的一样 
    Rf(i,1,cnt[x]) {
        R int v=w[x][i];
        if(!vis[v]) {
            vis[v]=1;
            if(!link[v]||dfs(link[v])) {
                link[v]=x;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    n=read();//有n排n*2个人，n*2个点 
    Rf(i,1,n*2) {
        R int u=read(),v=read();//读入每个人想坐的两排
        //把每排拆成自己和自己加n,比如把第u排拆成u号点和u+n号点 
        w[i][++cnt[i]]=u;w[i][++cnt[i]]=u+n;//千万不要用邻接矩阵存图 
        w[i][++cnt[i]]=v;w[i][++cnt[i]]=v+n;
    }
    Rf(i,1,n*2) {//求最大匹配数，其他的就和二分图匹配的模板一样了（包括上面那个dfs） 
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ans++;
    }
    write(ans);
    return 0;
}

```

---

## 作者：abandentsky (赞：0)

思路：刚开始以为是模板最大匹配，结果发现答案不对才意识到每排是两个座位。不小心瞄了一眼题解。然后就明白了每个人可以选择两排，每排是两个座位，就意味着每个人有四个座位可以选，这样，就直接转化成求最怕匹配了。模板加两行代码就完了。
```c
#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
#define MAXN  8005
using namespace std;

vector<int> G[4005];
bool vis[MAXN];
int vv[MAXN];
int n;

bool match(int u)
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v])
            continue;
        vis[v]=true;
        if(!vv[v]||match(vv[v]))
        {
            vv[v]=u;
            return true;
        }
    }
    return false;
}

void Km()
{
    memset(vv,0,sizeof(vv));
    int sum=0;
    for(int i=1;i<=2*n;i++)
    {
        memset(vis,0,sizeof(vis));
        if(match(i))
            sum++;
    }
    printf("%d\n",sum);
}

int main()
{
    scanf("%d",&n);
    int uu,vv;
    for(int i=1;i<=2*n;i++)
    {
        scanf("%d %d",&uu,&vv);
        G[i].push_back(uu+2*n);
        G[i].push_back(uu+3*n);
        G[i].push_back(vv+2*n);
        G[i].push_back(vv+3*n);
    }
    Km();
    return 0;
}

```


---

## 作者：封禁用户 (赞：0)

# 很显然这是道裸的二分图匹配
[二分图匹配](https://www.luogu.org/blog/fusu2333/post-2018-wu-yi-qing-bei-pei-xun-er-fen-tu-xiong-ya-li-suan-fa-post)

### 不过也不能说是裸的，把所有点乘二就可以了，而且我用了vector存图，这样跑匈牙利可以快很多。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 40007; //因为把点拆成俩了
int n,m,k,girl[N];
bool used[N];
vector <int> G[N]; //vector存图可以免判断
//匈牙利板子
bool Find(int x)
{
	for(int i = 0; i < G[x].size(); i++) //每次循环都是有连线的
	{
		int &v = G[x][i];
		if(!used[v])
		{
			used[v] = true;
			if(girl[v] == 0 || Find(girl[v]))
			{
				girl[v] = x;
				return true;
			}
		}
	}
	return false;
}
int main()
{
	scanf("%d",&n);
	for(int t1,t2,i = 1 ; i <= n*2; i++)
	{
		scanf("%d %d",&t1,&t2);
		G[i].push_back(t1*2-1); //拆点
		G[i].push_back(t1*2);
		G[i].push_back(t2*2-1);
		G[i].push_back(t2*2);
	}
	int cnt = 0;
	for(int i = 1; i <= n*2; i++)
	{
		memset(used,false,sizeof(used));
		if(Find(i))	cnt++;
	}
	printf("%d\n",cnt);
	return 0;
}
```


---

## 作者：独孤涵冰 (赞：0)

把椅子拆成两个，就变成二分图匹配了。
```cpp
/*Tokgo*/
#include <bits/stdc++.h>



using namespace std;

#define N 50000

int n , m , c ; 
int x , y ; 

int head[ N ] , tot ; 
struct edge{ int y , nt ; } e[ N ] ;
void add_edge( int x , int y ) {
	 e[ ++tot ] = (edge){ y , head[ x ] } ; 
	 head[ x ] = tot ; 
}

bool did[ N ] ; 
int link[ N ] ; 

bool dfs( int x ) {
	for( int i = head[x] ; i ; i = e[i].nt ) {
		int to = e[i].y ;
		if( did[to] ) continue ; 
		did[to] = 1 ; 
		if( link[to] == -1 or dfs( link[to] ) ) {
			link[ to ] = x ; 
			return true ; 
		}
	}
	return false ; 
}

int ans ;
void match( int n ) {
	memset( link , -1 , sizeof( link ) ) ;
	for( int i = 1 ; i <= n ; ++ i ) {	
		memset( did , 0 , sizeof( did ) ) ;
		if( dfs( i ) ) ans ++ ; 
	}
}

int main() {

    cin >> n ; 
    for( int i = 1 ; i <= n * 2 ; ++ i ) {
    	cin >> x >> y ; 
    	add_edge( i , x + 2*n ) , add_edge( i , x + 3*n ) ;
    	add_edge( x + 2*n  , i ) , add_edge( x + 3*n , i ) ; 
    	add_edge( i , y+2*n ) , add_edge( i , y + 3*n ) ;
    	add_edge( y+2*n , i ) , add_edge( y + 3*n , i ) ;
	}
	match( 2 * n ) ;
	cout << ans << endl ;
	
    return 0;
}


```

---

## 作者：wohohohoho (赞：0)

最近小蒟蒻在做二分图匹配的题，找到这一题

乍一看，怎么一排座位能坐两个人！！~~不是模板题不会做啊~~

细细一想，发现可以将一排座位拆成两个

比如题目是八个人四排座位

然后我们就可以理解为每一排中两个座位对应两个点，第u排座位的两个座位的座位号分别为u，u+n

然后又能愉快的用匈牙利算法了

代码如下

```cpp
#include<cstring>
#include<iostream>
using namespace std;
const int maxn=4010;
int n,w[maxn][100],link[maxn]={0},ans=0,cnt[maxn]={0};
bool used[maxn];

bool find(int x)
{
	for(register int i=1;i<=cnt[x];i++)
	{
		if(!used[w[x][i]])
		{
			used[w[x][i]]=true;
			if(!link[w[x][i]]||find(link[w[x][i]]))
			{
				link[w[x][i]]=x;
				return true;
			}
		}
	}
	return false;
}

void Hungary()//算法本体
{
	for(int i=1;i<=n*2;i++)
	{
		memset(used,0,sizeof(used));
		if(find(i))ans++;
	}
}

int main()
{
	int x,y;
	cin>>n;
	for(int i=1;i<=n*2;i++)
	{
		cin>>x>>y;
		w[i][++cnt[i]]=x,//邻接表存图
		w[i][++cnt[i]]=x+n,//拆点
		w[i][++cnt[i]]=y,
		w[i][++cnt[i]]=y+n;
	}
	Hungary();
	cout<<ans;
	return 0;
}
```

---

## 作者：wangyiou (赞：0)

该问题可以转换为最大流的问题，如图所示
![网络流](https://cdn.luogu.com.cn/upload/image_hosting/4x3w6v3z.png)
1. 该网络流有3*N+2个顶点（N为车的排数）
2. 第一层的1号顶点是源点，第二层的2至2*N+1号顶点代表2*N个学生，第三层2*N+2到3*N+1号顶点代表车上的N排座位，第四层的3*N+2号顶点是汇点。
3. 1号顶点连接第二层每个顶点，边的权值为1。第二层每个顶点，连接第三层的两个顶点（代表了每个学生有两个喜欢的排数），权值为1。第三层每个顶点，都连接第四层的顶点，权值为2，代表每排可以坐下2位学生。
4. 从源点到汇点的流量最大时，代表了有最多的学生坐到了自己喜欢的排。所以求从源点到汇点的最大流即可。

我使用的邻接表来存储图，求最大流用的Dinic。AC代码：

```cpp
#include<iostream>
#include<stdio.h>
#define INF 999
using namespace std;
typedef int LL;
struct Node {
	int to;
	int next;
	LL val;
};
struct Node e[84005];
int cnt = 1;
int head[6005];
int dis[6005];
int n, m, s, t;
int q[6005];
void addEdge(int u,int v,LL w) {
	e[++cnt].to = v;
	e[cnt].val = w;
	e[cnt].next = head[u];
	head[u] = cnt;
	e[++cnt].to = u;
	e[cnt].val = 0;
	e[cnt].next = head[v];
	head[v] = cnt;
}
bool bfs() {
	for (int i = 1; i <= n; i++) {
		dis[i] = INF;
	}
	int tail = 1;
	int top = 0;
	q[top] = s;
	dis[s] = 0;
	while (top < tail) {
		int cur = q[top++];
		for (int i = head[cur]; i; i=e[i].next) {
			int v = e[i].to;
			if (e[i].val > 0 && dis[v] == INF) {
				q[tail++] = v;
				dis[v] = dis[cur] + 1;
			}
		}
	}
	if (dis[t] == INF) {
		return false;
	}
	return true;
}
LL dfs(int node, LL flow) {
	if (node == t) {
		return flow;
	}
	LL change, used = 0;
	for (int i = head[node]; i ; i = e[i].next) {
		int v = e[i].to;
		if (e[i].val > 0 && dis[v] == dis[node] + 1) {
			change = dfs(v, min(flow - used, e[i].val));
			if (change > 0) {
				e[i].val -= change;
				e[i^1].val += change;
				used += change;
				if (used == flow) {
					return flow;
				}
			}

		}
	}
	return used;
}
LL min(LL a, LL b) {
	if (a < b) {
		return a;
	}
	return b;
}
LL Dinic() {
	LL sum = 0;
	while (bfs()) {
		sum += dfs(s, 999);
	}
	return sum;
}
int main() {
	int u, v, i, j, N;
	scanf("%d", &N);
	n = 3 * N + 2;//顶点数量
	s = 1;//源点
	t = n;//汇点
	for (i = 2; i <= 2 * N + 1; i++) {
		scanf("%d %d", &u, &v);
		addEdge(s, i, 1);
		addEdge(i, 2 * N + 1 + u, 1);
		addEdge(i, 2 * N + 1 + v, 1);
	}
	for (i = 2 * N + 2; i <= 3 * N + 1; i++) {
		addEdge(i, t, 2);
	}
	printf("%d\n", Dinic());
}
```


---

## 作者：gyh20 (赞：0)

二分图匹配使用dinic()算法，与普通算法相同，但需要注意边流量。

最开始先从源点向每一个同学连一条流量为一的边，因为每个人都只能过一个人。

之后在人和座位之间连流量为INF的边。

最后在座位和汇点之间连一个流量为2的边，因为每一排可以坐2个人。

代码如下：

```c
#pragma GCC optimize(200000)
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<stack>
#include<algorithm>
#define INF 0x7fffffff
using namespace std;
struct edge {
	int next,w,to;
};
edge e[1000005];
inline int read() {
	int t=0,f=1;
	char v=getchar();
	if(v=='-')f=-1;
	while(v<'0'||v>'9') {
		v=getchar();
		if(v=='-')f=-1;
	}
	while(v>='0'&&v<='9') {
		t=(t<<3)+(t<<1)+v-'0';
		v=getchar();
	}
	return f*t;
}
int p[1000002];
bool v[1000002];
int head[1000002],b,c,d,n,m,cnt=1,S,T,as[1000002];
inline void bu(register int u,register int v,register int w) {
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
	e[++cnt].to=u;
	e[cnt].next=head[v];
	head[v]=cnt;
}
queue <int> q;
inline int spfa(register int s,register int t) {
	memset(p,-1,sizeof(p));
	while(!q.empty())q.pop();
	q.push(s);
	p[s]=0;
	while(!q.empty()) {
		int r=q.front();
		q.pop();
		if(r==t)return 1;
		for(register int i=head[r]; i; i=e[i].next) {
			if(e[i].w>0&&p[e[i].to]<0) {
				q.push(e[i].to);
				p[e[i].to]=p[r]+1;
			}
		}
	}
	return 0;
}
inline int dfs(register int s,register int t,register int mx) {
	int r=0,y=0;
	if(s==t)return mx;
	for(register int i=head[s]; i; i=e[i].next)
		if(e[i].w>0&&p[e[i].to]==p[s]+1) {
			y=dfs(e[i].to,t,min(e[i].w,mx));
			e[i].w-=y;
			e[i^1].w+=y;
			r+=y;
			mx-=y;
			if(!mx)return r;
		}

	return r;
}
inline int dinic() {
	int ans=0;
	while(spfa(S,T))ans+=dfs(S,T,0x7fffffff);
	return ans;
}
int main() {
	m=read();
	n=(m<<1);
	S=1;
	T=n+m+2;
	for(register int i=1; i<=n; ++i)bu(S,i+1,1);
	for(register int i=n+1; i<=m+n; ++i)bu(i+1,T,2);
	for(register int i=1; i<=n; ++i) {
		b=read();
		c=read();
		bu(1+i,b+n+1,INF);
		bu(1+i,c+n+1,INF);
	}
	printf("%d\n",dinic());
}
```


---

## 作者：Great_Influence (赞：0)

二分图最大匹配。

当然既然是二分图最大匹配，就可以用网络流做了。所以打了一发Dinic上去。当然也打了匈牙利，只不过数据过水，没快多少。

代码：

Dinic：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#include<algorithm>
#include<deque>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
const int MAXN=8010;//注意点要开到4n
struct edge
{
    int v,next,w;
}p[MAXN<<4];//边也要开大点
int n,e=1,head[MAXN];
void add(int u,int v,int w)//加边
{
    p[++e].v=v;
    p[e].w=w;
    p[e].next=head[u];
    head[u]=e;
}
int level[MAXN],s,t;
queue<int>G;
bool bfs(void)//Dinic的BFS
{
    G.push(s);
    memset(level,0,sizeof level);
    level[s]=1;
    while(!G.empty())
    {
        int u=G.front(),v=head[u];
        G.pop();
        while(v)
        {
            if(p[v].w&&!level[p[v].v])
            {
                level[p[v].v]=level[u]+1;
                G.push(p[v].v);
            }
            v=p[v].next;
        }
    }
    return level[t];
}
const int inf=0xFFFFFFF;
int dfs(int u,int flow)//Dinic的DFS
{
    if(u==t||!flow)return flow;
    int sum=0,v=head[u];
    while(v)
    {
        if(p[v].w&&level[p[v].v]==level[u]+1)
        {
            int f=dfs(p[v].v,min(flow,p[v].w));
            p[v].w-=f;
            p[v^1].w+=f;
            sum+=f;
            flow-=f;
        }
        v=p[v].next;
    }
    return sum;
}
int Dinic(void)//Dinic
{
    int ans=0;
    while(bfs())ans+=dfs(s,inf);
    return ans;
}
int main(void)
{
    read(n);
    int i,v;
    s=n*4+1;t=n*4+2;
    For(i,1,n*2)
    {
        read(v);
        add(i,v+n*2,1);add(v+n*2,i,0);//加边跑网络流
        read(v);
        add(i,v+n*2,1);add(v+n*2,i,0);
        add(s,i,1);add(i,s,0);
    }
    For(i,1,n)
    {
        add(n*2+i,n*3+i,2);add(n*3+i,n*2+i,0);
        add(n*3+i,t,2);add(t,n*3+i,0);
    }
    printf("%d\n",Dinic());
    return 0;
}
```
匈牙利：
```cpp
#include<bits/stdc++.h>
#include<cctype>
#include<algorithm>
#include<deque>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
const int MAXN=4010;//点要到2n
struct edge
{
    int v,next;
}p[MAXN<<4];
int n,e=0,head[MAXN],match[MAXN];
bool vis[MAXN];
void add(int u,int v)//加边
{
    p[++e].v=v;
    p[e].next=head[u];
    head[u]=e;
}
bool Hungary(int u)//匈牙利
{
    int v=head[u];
    while(v)
    {
        if(!vis[p[v].v])
        {
            vis[p[v].v]=true;
            if(!match[p[v].v]||Hungary(match[p[v].v]))
            {
                match[p[v].v]=u;
                return true;
            }
        }
        v=p[v].next;
    }
    return false;
}
int main(void)
{
    read(n);
    int i,v;
    For(i,1,n*2)
    {
        read(v);
        add(i,v);
        add(i,v+n);//加边后跑匈牙利
        read(v);
        add(i,v);
        add(i,v+n);
    }
    int ans=0;
    For(i,1,2*n)
    {
        memset(vis,0,sizeof vis);
        if(Hungary(i))++ans;
    }
    printf("%d\n",ans);
    return 0;
}
```

---


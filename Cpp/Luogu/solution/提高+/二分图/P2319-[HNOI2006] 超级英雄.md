# [HNOI2006] 超级英雄

## 题目描述

现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。


这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？


## 说明/提示

感谢@zhouyonglong 提供special Judge


## 样例 #1

### 输入

```
5 6
3 2
2 0
0 3
0 4
3 2
3 2```

### 输出

```
4
3
2
0
4```

# 题解

## 作者：x_faraway_x (赞：25)

论仔细读题的重要性，千万不要一鸡冻“呀这题裸匈牙利”就码码码码玩了，结果尽管能过样例却只有20分……

这题唯一和模板不一样的就是你找不到匹配了就要立刻退出了……就这么一点小坑……

剩下来就是模板啦，所以这题提高+有点过了吧……

```cpp
#include<cstdio>
#include<cstring>
const int N=1005;
bool to[N][N],vis[N];
int l[N],n,m,ans,sum[N]; 
bool Find(int x) //裸的匈牙利模版
{
    for(int j=1;j<=n;j++)
        if(to[x][j]&&!vis[j])
        {
            vis[j]=true;
            if(l[j]==0||Find(l[j]))
            {
                l[j]=x; sum[x]=j;
                return true;
            }
        }
    return false;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,x,y;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        to[i][x+1]=to[i][y+1]=true; //将下标统一从1开始方便处理
    }
    for(int i=1;i<=m;i++)
    {
        memset(vis,false,sizeof(vis));
        if(Find(i))ans++;
        else break; //小坑：找不到就立即退出
    }
    printf("%d\n",ans);
    for(int i=1;i<=ans;i++) printf("%d\n",sum[i]-1); //这里最后答案-1，因为之前加了个1
}
```

---

## 作者：船医 (赞：8)

### ~~很有年代感的题面~~
其实就是一道二分图最大匹配的问题。

**最大匹配**：考虑如何在二分图中选出最多的边，使得没有一个点同时属于两条不同的边，这个问题称为二分图 的最大匹配问题。

在寻找最大匹配时，我们只需要考虑二分图的某一个集合，并尽可能希望集合内的节点都能实现匹配。 我们可以依次为集合A中的节点寻找匹配对象。

而解决二分图最大匹配要用到的算法，叫做匈牙利算法。

对于集合A中的节点x ：

如果存在一条边连接未匹配节点y ，则直接把x, y之间的边设置为匹配边。

如果存在一条边连接已匹配节点y （匹配点z ），但z有边连接其他未匹配点，可以通过更换匹配边，使得x找到匹配，且总匹配边数增加。

**而上面这种更换匹配边方式，可以反复拓展**，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4ka0txb8.png)

2,3/
4,5/
6,7/
8,9可以更新成
1,2/
3,4/
5,6/
7,8/
9,10。

如果能找到从集合A的点x出发的一条不经过重复点且交替经过非匹配边和匹配边的路径最终到 达集合B的y点。那我们就对路径上边的状态进行一个**反转**。
这样我们的匹配边数会++，达到最大匹配的目的。
而这样的路径，我们称其**增广路径**。

而这正是**匈牙利算法**的核心内容：

1.依次从集合A中的节点出发寻找增广路径,如果能找到则对路径上的边的匹配情况取反。

2.二分图的最大匹配数等于能找到增广路径的节点数目。

步骤如下：

•依次从集合A中的节点出发进行DFS ,用match数组记录集合B中的节点的匹配对象。

•如果当前节点u能找到未匹配节点v，则match[v] = u

•如果当前节点u能找到一个已匹配但在本次DFS中未访问过的节点v ,尝试从match[v]出 发继续寻找增广路径，如果能到增广路径，则match[v] = u
```cpp
bool dfs(int qq,int k){
	c[qq]=k;
	if(k==1)
	a++;
	else
	b++;
	for(int i=0;i<g[qq].size();i++)
	{
		if(!c[g[qq][i]])
		{
			if(!dfs(g[qq][i],3-k))
			{
				return 0;
			}
		}
		else
		{
			if(c[g[qq][i]]==k)
			{
				return 0;
			}
		}
	}
	return true;
}
```
但本题**并不是一个纯的匈牙利** 
~~不然就和模板重了~~

本题当找不到增广路径时就要**及时退出**
```
我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。
```
所以搞清楚这些！就能AC辣！

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,m,root,x,y,ans,tot,c[N],a,u,b,v,flag=0,e,match[N],anss[N];
bool vis[N];
vector<int> g[N];
bool dfs(int u){
	for(int i=0;i<g[u].size();i++)
	{
		if(!vis[g[u][i]])
		{
			int v=g[u][i];
			vis[v]=1;
			if(match[v]==-1||dfs(match[v])==1)
			{
				match[v]=u;
				anss[u]=v;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	memset(match,-1,sizeof(match));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		g[i].push_back(x);
		g[i].push_back(y);
	}
	for(int i=1;i<=m;i++)
	{
		memset(vis,0,sizeof(vis));
		if(dfs(i))
		ans++;
		else
		break;//就是这里和普通最大匹配不同
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++)
	{
		cout<<anss[i]<<endl;
	}
}
```
好啦！希望大家可以熟练运用匈牙利，AC更多最大匹配的题_(:3⌒ﾞ)_

---

## 作者：Diamiko (赞：5)

这题是求二分图的最大匹配，可以使用匈牙利算法。

但这题最大的坑点在于只要有一个题答不上来就淘汰了，那么对应到算法中就是只要一个点匹配不上就不再继续匹配后面的了。

详见代码注释。

```cpp
#include<cstdio>
#include<algorithm>
#include<bitset>
using namespace std;
int n1,n2;
//分别对应锦囊数和题目数 
bitset<1002>map[1002];
bitset<1002>vis;
//用bitset优化空间
int p[1002];
int solution[1002];
//p数组存储每个锦囊对应的题目
//solution存储每个题目使用的锦囊
//（互逆的）
bool match(int u)
{
	for(int v=1;v<=n1;v++)
	{
		if(map[u][v]&&!vis[v])
		{
			vis[v]=1;
			if(!p[v]||match(p[v]))
			{
				p[v]=u;
				solution[u]=v;
				//注意这里，要存储每个题使用的锦囊，以便输出
				return true;
				//匹配成功，return true
			}
		}
	}
	return false;
	//匹配失败
}
void Hungarian()
{
	int ans=0;
	for(int i=1;i<=n2;i++)
	{
		vis.reset();
		//bitset的清零操作
		//换成bool数组就是memset(vis,0,sizeof vis)
		//一定要清零，这个不能忘记
		if(match(i))ans++;
		else break;
		//只要这个题答不上来，就被pass了
	}
	printf("%d\n",ans);
	//输出答对的个数
	for(int i=1;i<=ans;i++)
	{
		printf("%d\n",solution[i]-1);
	}
	//依次输出每个答对的题目的使用的锦囊
	//因为在存的时候下标加上了1，所以输出的时候减去1
}
int main()
{
	scanf("%d%d",&n1,&n2);
	for(int i=1,a,b;i<=n2;i++)
	{
		scanf("%d%d",&a,&b);
		map[i][a+1]=1;
		map[i][b+1]=1;
		//题目中下标是从0开始的，但我习惯是1
		//从1开始可能更方便
	}
	Hungarian();
	//执行匈牙利算法
	return 0;
}
```
希望多多支持，不理解还可以私信我或at我

---

## 作者：enceladus (赞：5)

[博客食用更加qwq](https://www.cnblogs.com/enceladus-return0/)

题解里没有链式前向星呢，我来水一篇,先膜一膜用网络流做的大佬。太巨辣。


------------


二分图最大匹配，不过有一些要注意的地方。

做这道题的应该已经掌握了匈牙利算法了吧，不过不会也没有关系啦。我们看着代码解释



------------

- 首先，头文件，定义一堆东西，还有建边。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int m;
int n,T;
int x,y;
struct node{
	int u,v;
}qwq[105050];
int head[105050],tot=0;
bool vis[105050];
int to[105050];
int ans=0;
int ans_end[105050];

inline void add(int x,int y){
	qwq[++tot].u=head[x];
	qwq[tot].v=y;
	head[x]=tot;
}

```


------------

- 第二就是写匈牙利啦。枚举每一条边和要到的点。如果没有标记过，就标记上开始跑。

#### 两种情况

>1.它没配对

>2.它配对的点可以和别的的点配对

这两种情况成立，我们就配对上，返回一。


```cpp
inline bool find(int x){
	for(int i=head[x];i;i=qwq[i].u){
		int v=qwq[i].v;
		if(vis[v]==0){
			vis[v]=1;
			if(!to[v]||find(to[v])==1){//判断
				to[v]=x;
				ans_end[x]=v;
				return 1;
			}
		}
	}
    return 0;
}

```



------------
3.最后就是主函数啦

先是安照题目华丽丽的建边。在直接跑m遍匈牙利就行了

这里有两个坑点。

>1.要初始化

>2.题目说明“只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰”所以else时就直接break就行QAQ

```cpp
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		add(i,x);
		add(i,y);
	}
	for(int i=1;i<=m;i++){
		memset(vis,0,sizeof(vis));//初始化QAQ超重要
		if(find(i)==1){
			ans++;
		}
		else{
			break;//只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰
		}
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++){
		cout<<ans_end[i]<<endl;
	}
	return 0;
}
```



------------
完整code

请勿抄袭，创造良好洛谷环境。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int m;
int n,T;
int x,y;
struct node{
	int u,v;
}qwq[105050];
int head[105050],tot=0;
bool vis[105050];
int to[105050];
int ans=0;
int ans_end[105050];

inline void add(int x,int y){
	qwq[++tot].u=head[x];
	qwq[tot].v=y;
	head[x]=tot;
}

inline bool find(int x){
	for(int i=head[x];i;i=qwq[i].u){
		int v=qwq[i].v;
		if(vis[v]==0){
			vis[v]=1;
			if(!to[v]||find(to[v])==1){
				to[v]=x;
				ans_end[x]=v;
				return 1;
			}
		}
	}
    return 0;
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		add(i,x);
		add(i,y);
	}
	for(int i=1;i<=m;i++){
		memset(vis,0,sizeof(vis));//初始化QAQ超重要
		if(find(i)==1){
			ans++;
		}
		else{
			break;//只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰
		}
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++){
		cout<<ans_end[i]<<endl;
	}
	return 0;
}
```

By enceladus

---

## 作者：Labelray (赞：5)

[给blog打个广告](http://labelray.top/2018/08/01/luogu-p2319-hnoi2006-chao-ji-ying-xiong/)

网络流，并不需要二分，可以每次输入第 $m$ 个问题可以使用的“锦囊妙计”的编号之后加边，在残余网络里跑dinic，当当前最大流小于$m$的时候就不得不出局了，此时输出答案即可

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

struct Edge;
struct Node{
    int d;
    Edge *head;
}node[2010];
struct Edge{
    Node *to;
    Edge *ne, *bac;
    int val;
    Edge(int x, int y, int z):to(&node[y]), ne(node[x].head), val(z){}
};
int n, m, S, T;

void add(int x, int y, int z){
    node[x].head=new Edge(x, y, z);
    node[y].head=new Edge(y, x, 0);
    node[x].head->bac=node[y].head;
    node[y].head->bac=node[x].head;
}

bool bfs(){
    queue<Node *>q;
    for(int i=S; i<=T; i++)	node[i].d=-1;
    node[S].d=1;
    q.push(&node[S]);
    while(!q.empty()){
        Node *x=q.front();
        q.pop();
        for(Edge *i=x->head; i; i=i->ne){
            if(!i->val || i->to->d!=-1)	continue;
            i->to->d=x->d+1;
            q.push(i->to);
            if(i->to==&node[T])	return true;
        }
    }
    return false;
}

int dfs(Node *x, int flow){
    if(x==&node[T] || flow==0)	return flow;
    int rest=flow, k;
    for(Edge *i=x->head; i && rest; i=i->ne){
        if(i->to->d!=x->d+1 || !i->val)	continue;
        k=dfs(i->to, min(i->val, rest));
        i->val-=k;
        rest-=k;
        i->bac->val+=k;
        if(!k)	i->to->d=-1;
    }	
    return flow-rest;
}

void print(int _){
    cout<<_<<endl;
    for(int k=1; k<=m; k++)
        for(Edge *j=node[k].head; j; j=j->ne)
            if(j->to!=&node[S] && j->val==0)
                cout<<j->to-&node[m+1]<<endl;
}

int main(){
    int maxflow=0, flow=0, x, y;
    scanf("%d%d", &n, &m);
    S=0, T=m+n+1;
    for(int i=1; i<=n; i++)
        add(i+m, T, 1);
    for(int i=1; i<=m; i++){
        add(S, i, 1);
        scanf("%d%d", &x, &y);
        add(i, x+m+1, 1);
        if(x!=y)	add(i, y+m+1, 1);
        while(bfs())
            while(flow=dfs(&node[S], 0x3f3f3f3f))
                maxflow+=flow;
        if(maxflow<i){
            print(maxflow);
            return 0;
        }
    }
    print(maxflow);
    return 0;
}
```

---

## 作者：Link_Space (赞：2)

刚学二分图来练练手。

做法相对于题解区其他的大佬来说要复杂一点，但是个人觉得更好理解一点。

整体思路就是二分最多能连续答几道题，然后每一次二分出来都去跑一遍匈牙利，最后输出最大的满足条件的做法即可。详情请看代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int head[1000000];
int nxt[1000000];
int ver[1000000];
int cnt;
int all[1000000];
int tot;
int match[1000000];
bool aim[1000000];
void add(int x,int y)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
}
bool find(int now)//普普通通匈牙利板子
{
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(aim[v0])
            continue;
        aim[v0] = 1;
        if(match[v0]==0||find(match[v0]))
        {
            match[v0] = now;
            return true;
        }
    }
    return false;
}
bool work(int jud)
{
    memset(match, 0, sizeof match);
    int res = 0;
    for (int i = 1; i <= jud;i++)
    {
        memset(aim, 0, sizeof aim);
        if(find(i))
            res++;
    }
    if(res==jud)
        return true;//如果最大匹配正好和当前二分的题目数相等，则说明当前二分的方案可行
    return false;//反之则不可行
}
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m;i++)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(i, a + m + 1);//之所以要+m+1是为了避开题目的编号
        if(a!=b)
            add(i, b + m + 1);//题目中说明可能会有a==b的情况，加一个判断。仔细想了一想，好像加不加都行
    }
    int l = 0;
    int r = m;
    int ans = 0;
    while (l <= r)//二分出来最多能连续答多少道题
    {
        int mid = l + r >> 1;
        if(work(mid))//对于每一次二分，都跑一遍匈牙利
        {
            ans = mid;//记录答案
            l = mid + 1;
        }
        else
            r = mid - 1;
    }
    printf("%d\n", ans);
    for (int i = m+1; i <= m+n+1;i++)
    {
        if(match[i])
            all[match[i]] = i;//将最终方案存进数组
    }
    for (int i = 1; i <= ans;i++)
        printf("%d\n", all[i]-m-1);//别忘了将之前加的m+1减回来
}
```


---

## 作者：asuldb (赞：2)

看到楼下有大佬说了网络流做法，来给大佬配个代码

~~我们~~只有我可能都觉得如果不动态加边的话$dinic$可能跑不了这种需要中途退出的二分图匹配

正当我准备去敲匈牙利的时候突然想到这个题可以二分啊

于是二分好了

如果答案是$ans$的话，$ans-1$肯定也满足条件，所以存在单调性，我们就可以二分了

至于$check$怎么写，我们只对$1$到当前要$check$答案跑一边$dinic$就好了，如果最大的匹配数等于当前答案的话那么这个答案就是合法的

时间复杂度应该为$O(V\sqrt{n+m}\text{ }logm)$

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define re register
#define maxn 5005
#define INF 9999999
using namespace std;
struct node
{
	int v,nxt,w,f;
}e[100005];
int n,num,m,S,T;
int d[maxn],vis[maxn],head[maxn];
int a[maxn],b[maxn];
int ans=0;
int tot[maxn];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
	  x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline void add_edge(int x,int y,int z)
{
	e[num].v=y;
	e[num].nxt=head[x];
	e[num].w=z;
	head[x]=num++;
}
inline int bfs()
{
	queue<int> q;
	memset(vis,0,sizeof(vis));
	vis[S]=1;
	d[S]=0;
	q.push(S);
	while(!q.empty())
	{
		int k=q.front();
		q.pop();
		for(re int i=head[k];i!=-1;i=e[i].nxt)
		if(!vis[e[i].v])
		{
			if(e[i].w<=e[i].f) continue;
			vis[e[i].v]=1;
			d[e[i].v]=d[k]+1;
			q.push(e[i].v);
		}
	}
	return vis[T];
}
int dfs(int x,int now)
{
	if(x==T||!now) return now;
	int flow=0,ff;
	for(re int i=head[x];i!=-1;i=e[i].nxt)
	if(d[e[i].v]==d[x]+1)
	{
		ff=dfs(e[i].v,min(now,e[i].w-e[i].f));
		if(ff<=0) continue;
		now-=ff;
		flow+=ff;
		e[i].f+=ff;
		e[i^1].f-=ff;
		if(!now) break;
	}
	return flow;
}
inline void did(int x)
{
	for(re int i=1;i<=x;i++)
	{
		for(re int j=head[i];j!=-1;j=e[j].nxt)
		if(e[j].f==1&&e[j].v>m) 
		{
			tot[i]=e[j].v;
			break;
		}
	}
}
inline int check(int x)
{
	num=0;
	memset(head,-1,sizeof(head));
	memset(e,0,sizeof(e));
	for(re int i=m+1;i<=m+n;i++) add_edge(i,n+m+1,1),add_edge(n+m+1,i,0);
	for(re int i=1;i<=x;i++)
		add_edge(0,i,1),add_edge(i,0,0);
	for(re int i=1;i<=x;i++)
	{
		add_edge(i,a[i],1);
		add_edge(a[i],i,0);
		if(a[i]==b[i]) continue;
		add_edge(i,b[i],1);
		add_edge(b[i],i,0);
	}
	int k=0;
	while(bfs()) k+=dfs(0,INF);
	return k==x;
}
int main()
{
	n=read();
	m=read();
	int x,y;
	S=0,
	T=n+m+1;
	memset(head,-1,sizeof(head));
	for(re int i=1;i<=m;i++)
		a[i]=read()+1+m,b[i]=read()+1+m;
	int l=0,r=m;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid)) 
			ans=mid,did(mid),l=mid+1;
		else r=mid-1;
	}
	cout<<ans<<endl;
	for(re int i=1;i<=ans;i++)
	printf("%d\n",tot[i]-1-m);
	return 0;
}
```

---

## 作者：king_xbz (赞：1)

这题难度不大，但是坑点极多，导致我足足做了半个多小时才A掉，看到题解区好像没有和我的思路一样用结构体排序处理二分图的，所以发篇题解分享一下。

 分析题目
-
首先读题，我们知道总共有**m道题，选手有n种不同的“锦囊妙计”**，每道题都可以从**两种“锦囊妙计”中选择一种**，而每种“锦囊妙计”只能用**一次**，求**最多答出几道题**。很自然的，我们想到了**二分图最大匹配**。由于匈牙利算法要远比Dinic算法好打，所以我就选用了**匈牙利算法**来解决这道题。

PS:现在不让有仿抄袭，我就不弄了，大家一定要自觉哦

代码实现
-
我们浏览样例
```cpp
5 6
3 2
2 0
0 3
0 4
3 2
3 2
```
竟然发现了0，我们都知道正常情况下都是1-m匹配1-n，可这~~毒瘤出题人~~却让1-m匹配0--n-1。所以，很自然的我就想到将**0--n-1，转化为1--n**。**建图代码如下**：

```cpp
inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return ;
}//链式前向星存图又快又好！

for(fint i=1;i<=m;i++)
	x=read(),y=read(),adds(i,y+1),adds(i,x+1);道理很简单，就是将妙计都+1
```
接下来我们就按照**标准的匈牙利算法**跑一遍，这时候再**仔细浏览**题目：
```cpp
只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。
```
什么意思呢，也就是主人公没有~~复活币~~，不能出现1匹配了，2未匹配，3又匹配的现象。一旦出现匹配不成功的现象，立刻结束。
```cpp
inline int Hungary()
{
	int ans=0;
	for(fint i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));//记得清零
		if(dfs(i))
		ans++;
		else
		break;//在这里一定要BREAK哦！
	}
	return ans;
}

inline int dfs(int x)
{
	for(fint i=head[x];i;i=e[i].nxt)
		if(!vis[e[i].to])
		{
			vis[e[i].to]=1;
			if(!s[e[i].to].x||dfs(s[e[i].to].x))
			{
				s[e[i].to].x=x;
				return 1;
			}		
	    }
	return 0;//爆搜找对象
}
```
现在，我们跑完了匈牙利算法，看一下**储存对应匹配关系的s数组**，发现s数组储存的是锦囊妙计对应的题目，我们要让他翻转过来，所以我们用s.num储存锦囊妙计的编号，当然呢，千万不要误解 _SPJ_ 的意思，我们可不能任意的输出，要符合1--ans的**对应关系**，这里就考虑到**结构体排序**。最后**千万不要忘记结果-1**哦
```cpp
   struct camp
   {
	int num;
	int x;
   }
   s[p];//结构体一步到位
	cout<<ans<<endl;
	for(fint i=1;i<=n;i++)
	s[i].num=i;//储存序号方便之后的排序
	sort(s+1,s+n+1,cmp);排序
	for(fint i=1;i<=n;i++)
	if(s[i].x)
	cout<<s[i].num-1<<endl;//输出
    
   inline bool cmp(camp aa,camp bb)
   {
  	return aa.x<bb.x;
   }
```
这样呢，这道题我们就完成了，赶快交上去~~听取AC一片~~吧。

---

## 作者：AKakA (赞：0)

一道最大匹配，~~并不是很难~~

算法思路（匈牙利算法）：把问题看作集合A，依次从集合A中出发寻找增广路径，如果能找到则对路径上的边的匹配情况取反（如图）

![1](https://cdn.luogu.com.cn/upload/image_hosting/q56oj946.png)

步骤：

1  依次从集合A（问题）dfs，用match数组存集合B（锦囊妙计）中节点的**匹配对象**。

2  如果当前节点u能找到**未匹配节点v**，则match[v]=u

3  如果当前节点u能找到已匹配但在本次dfs中未访问过的节点v，则对match[v]进行dfs，如果能找到增广路径，则match[v]=u



 _**Code**_ 
 
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100000;

struct Edge      
{
	int next;
	int to;
};
Edge edge[N];      //链式前向星

int n,m,ne,ans;
int vis[N],match[N],head[N],p[N];   //vis记录当前dfs中节点是否访问
                                    //p数组记录问题所对的锦囊妙计，用来输出

void add(int from,int to)
{
	ne++;
	edge[ne].next=head[from];
	edge[ne].to=to;
	head[from]=ne;
}

bool dfs(int u)
{
	for(int i=head[u];i;i=edge[i].next)
	{
		int to=edge[i].to;
		if(!vis[to])
		{
			vis[to]=1;
			if(!match[to]||dfs(match[to]))
			{
				match[to]=u;
				p[u]=to;
				return true;
			}
		}
	}
	return false;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;        
		add(i,u);
		add(i,v);        //建边，注意是第i个题有编号u，v两个锦囊妙计
	}
	for(int i=1;i<=m;i++)
	{
		memset(vis,0,sizeof(vis));    //每次dfs都要清空
		if(dfs(i)) ans++;             //记录可行的问题
		else break;                  //题意：只有答对这道题才能进入下一道，不行则break
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++)                
	{
		cout<<p[i]<<endl;          
	}
	return 0;
}
```

---

## 作者：tyno夏 (赞：0)

基本是一个裸的匈牙利，但是有几个坑点！！！

1、一般习惯以n为主动连线边（因为无论从哪一边开始都是可以的），但是这道题因为一旦答不出某道题就会结束，所以需要以m，也就是问题为主动连线边。

2、上面也说了，这道题一旦答不出某题直接结束，就算你之后的题还是可以做出，也是没用的！所以记得及时break。

3、一般习惯将答案数组nxt放在全局变量，让他默认初始化为0，但是这道题的题目编号是从0开始的，也就是说采用nxt[x]==0来判断是否已经被连接是不可以的！所以可以考虑将nxt初始为-1.

解决了这几个bug就可以很愉快的修板子了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int n,m;
int inp[N][N];
int vis[N],nxt[N];
int now[N];
bool findd(int x){
	for(int to=0;to<n;to++)	{
		if(vis[to] || inp[x][to]==0)
			continue;
		vis[to]=1;
		if(nxt[to]==-1 || findd(nxt[to])){
	//当前未被匹配或被匹配值可以找到其他解 
			nxt[to]=x;
			now[x]=to;
			return true;
		}
	}
	return false;
}
int match()  {
	int sum=0;
	for(int i=0;i<m;i++)	{
		memset(vis,0,sizeof(vis));
		if(findd(i))
			sum++;
		else
			break;
	}
	return sum;	//最大匹配数 
}
int main()
{
	memset(nxt,-1,sizeof(nxt));
	n=read(),m=read();
	for(int i=0;i<m;i++)
	{
		int u=read(),v=read();
		inp[i][u]=inp[i][v]=1;
	}
	int ans=match();
	printf("%d\n",ans);
	for(int i=0;i<ans;i++)
		printf("%d\n",now[i]);
    return 0;
}
```


---

## 作者：abandentsky (赞：0)

思路：感觉这个题模板吧。就是题目要求只有作对前一题才能做后面的题目。所以匹配的时候得连续，否则就退出。注意输入输出就好了。

```c
#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
#define MAXN  2005
using namespace std;

vector<int> G[1005];
bool vis[MAXN];
int vv[MAXN];
int Left[MAXN];
int n,m;

bool match(int u)
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v])
            continue;
        vis[v]=true;
        if(!vv[v]||match(vv[v]))
        {
            vv[v]=u;
            Left[u]=v;
            return true;
        }
    }
    return false;
}

void Km()
{
    memset(vv,0,sizeof(vv));
    memset(Left,0,sizeof(Left));
    int sum=0;
    for(int i=1;i<=2*n;i++)
    {
        memset(vis,0,sizeof(vis));
        if(match(i))
            sum++;
        else
            break;                                              //题目中要求只有答对上一题才能进入下一题。所以必须是连续匹配的
    }
    printf("%d\n",sum);
    for(int i=1;i<=m;i++)
    {
        if(Left[i]==0)
            break;
        printf("%d\n",Left[i]-1-m);
    }
}

int main()
{
    scanf("%d %d",&n,&m);
    int uu,vv;
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&uu,&vv);
        G[i].push_back(uu+1+m);     //从人向锦囊妙计连边
        G[i].push_back(vv+1+m);      //锦囊妙计是从0开始，这里从m+1开始，把0号映射为m+1
    }
    Km();
    return 0;
}

```


---

## 作者：斗神_君莫笑 (赞：0)

看到每行两个数，求最大匹配数目，本能的想起二分图匹配  
本题基本上就是模板  
只不过注意匹配失败以后要立即退出（只能走一次）  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge{
	int u,v,nxt;
}e[100010];
int head[10010],cnt;
inline void add(int u,int v){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int match[100010],sum[100010],vis[100010];
int dfs(int u){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(!vis[v]){
			vis[v]=1;
			if(match[v]==-1||dfs(match[v])==1){
				match[v]=u;sum[u]=v;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int v1,v2;
		scanf("%d%d",&v1,&v2);
		add(i,v1+1);add(i,v2+1);
	}
	memset(match,-1,sizeof(match));
	memset(sum,-1,sizeof(sum));
	int ans=0;
	for(int i=1;i<=m;++i){
		memset(vis,0,sizeof(vis));
		if(dfs(i))ans++;
		else break;
	}
	printf("%d\n",ans);
	for(int i=1;i<=ans;++i)
		printf("%d\n",sum[i]-1);
	return 0;
}
 
```


---

## 作者：水库中的水库 (赞：0)

题目实际上就是一道二分图最大匹配的问题，建图方式如下：

* 对于二分图左边为当前题目标号$i$
* 对于二分图右边为当前题目的“锦囊妙计”编号

接下来跑一个二分图最大匹配就好了

因为问题要求连续的回答，所以可以边建图边跑

```cpp
// luogu-judger-enable-o2
/***************************************************************
	File name: P2319.cpp
	Author: ljfcnyali
	Create time: 2019年06月24日 星期一 14时18分46秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 

const int maxn = 2010;

int Begin[maxn], Next[maxn], To[maxn], e;
int link[maxn], n, m, ans;
bool vis[maxn];

inline void add(int u, int v)
{
    To[++ e] = v;
    Next[e] = Begin[u];
    Begin[u] = e;
}

inline bool DFS(int u)
{
    if ( vis[u] ) return false;
    vis[u] = true;
    for ( int i = Begin[u]; i; i = Next[i] ) 
    {
        int v = To[i];
        if ( !link[v] || DFS(link[v]) ) { link[v] = u; return true; }
    }
    return false;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    REP(i, 1, m)
    {
        int u, v; scanf("%d%d", &u, &v); 
        u += 1000; v += 1000;
        add(i, u); add(i, v);
        mem(vis);
        if ( DFS(i) ) ++ ans;
        else break ; 
    }
    printf("%d\n", ans);
    REP(i, 1, ans)
        REP(j, 1000, 999 + n)
            if ( link[j] == i ) { printf("%d\n", j - 1000); break ; }
    return 0;
}

---

## 作者：Edward_Elric (赞：0)

### 思路
一开始开，这不裸的二分图吗，然后敲了个板子上去，就wa掉了真的是native。

然后看了看限制条件。正确回答一道题后，才能进入下一题。

不难我们容易想到每次加边跑一遍最大流，然后总流量（即能匹配的方法数）比当前点少，那么就退出
### 代码
增广路算法 Ford-Fulkerson，适用于稀疏图
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int maxn=10000+10,maxm=10000+10;
int head[maxn],vis[maxn];
int s,t;
int n,m,ans;
struct edge
{
	int to,next,cap;
}e[maxm];
int size=1;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
void addedge(int u,int v,int val)
{
	e[++size].to=v;e[size].cap=val;e[size].next=head[u];head[u]=size;
	e[++size].to=u;e[size].cap=0;e[size].next=head[v];head[v]=size;
}
int dfs(int u,int f)
{
	if(u==t)return f;
	vis[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int to=e[i].to;
		if(!vis[to]&&e[i].cap>0)
		{
			int d=dfs(to,min(f,e[i].cap));
			if(d>0)
			{
				e[i].cap-=d;
				e[i^1].cap+=d;
				return d;
			}
		}
	}
	return 0;
}
int maxflow()
{
	int flow=0;
	while(1)
	{
		memset(vis,0,sizeof(vis));
		int f=dfs(s,inf);
		if(f==0)return flow;
		flow+=f;
	}
}
int main()
{
    n=read(),m=read();
    s=n+m,t=n+m+1;
    for(int i=0;i<n;i++)
    addedge(s,i,1);
    for(int i=1;i<=m;i++)
    addedge(n+i-1,t,1);
    for(int i=1;i<=m;i++)
    {
    	int a=read(),b=read();
    	addedge(a,n+i-1,1);
    	addedge(b,n+i-1,1);
    	ans+=maxflow();
    	if(ans<i||i==m)
    	{
		  printf("%d\n",ans);
		  for(int u=n;u<n+i;u++)
	      {
 		    for(int i=head[u];i;i=e[i].next)
		    {
			int to=e[i].to;
			  if(to!=t&&e[i].cap)
			  {
				printf("%d\n",to);
			  }
		    }
	      }
	      exit(0);
        }
    }
	return 0;
}

```


---

## 作者：ShineEternal (赞：0)

# 写在前面：
如果获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/886043420),任何疑问欢迎私信作者！
# 题目链接：
https://www.luogu.org/problemnew/show/P2319

# 分析
每错，这是一道~~海南~~不对是~~河南~~呀呀呀错了是湖南的省选题。

但是还是可以作为二分图第二题来练手的，插播[第一题](https://blog.csdn.net/kkkksc03/article/details/886040470),对照食用效果更佳

---
言归正传。

这道题说
> 只有正确回答本题才能进入下一题

于是我们就可以循环题目编号以保证符合题意。

然后由于题目不但让我们输出最多能通过几题，还要求输出锦囊妙计的编号，于是我们可以在find模板函数中记录一下：

```
sum[x]=p; 
```
即可。

然后我们还是要考虑一下``else break;``的问题。

因为这时后还是要求连续的答题，所以说一道题如果没答上（!find(i）)，那么就被淘汰了。所以也要加上。（后面有不加else break的题目情况）
# 代码：

```cpp
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;
vector<int>v[1005];
int vis[1005],link[1005],a[1005],sum[1005];
int t;
bool find(int x)
{
    for(int i=0;i<v[x].size();i++)
    {
        int p=v[x][i];
        if(vis[p]!=t)
        {
            vis[p]=t;
            if(link[p]==-1||find(link[p]))
            {
                link[p]=x;
                sum[x]=p; 
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    int n,m;
    for(int i=0;i<=1000;i++)
    {
        link[i]=-1;
    }
    scanf("%d%d",&m,&n);
    int maxf=0;
    for(int i=0;i<n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        v[i].push_back(a);
        v[i].push_back(b);
    } 
    int cnt=0;
    for(int i=0;i<=n+m;i++)//在这里n+m是为了防止最后一个被忽略的情况
    {
        t++;
        if(find(i))
        {
            cnt++;
        }
        else
        break;
    }
    printf("%d\n",cnt);
    for(int i=0;i<cnt;i++)
    {
        printf("%d\n",sum[i]);
    }
    return 0;
} 
```



---

## 作者：yzhang (赞：0)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10081375.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P2319) 

这道题就是一个很简单的二分图匹配

### [二分图匹配详解](https://www.cnblogs.com/yzhang-rp-inf/p/10079578.html)

一开始想的是2-sat和网络流，根本没想匈牙利和HK

这道题只要注意一点：当一个点匹配不成功之后就直接退出

剩下的就写个二分图最大匹配就行了

完整代码（~~不想写HK~~）

```cpp
#include <bits/stdc++.h>
#define N 1005
using namespace std;
inline int read()
{
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline void write(register int x)
{
	if(!x)putchar('0');if(x<0)x=-x,putchar('-');
	static int sta[25];int tot=0;
	while(x)sta[tot++]=x%10,x/=10;
	while(tot)putchar(sta[--tot]+48);
}
struct node{
	int to,next;
}e[N<<1];
int head[N],tot;
inline void add(register int u,register int v)
{
	e[++tot]=(node){v,head[u]};
	head[u]=tot;
}
int n,m;
int ask[N],matched[N],bematched[N];
inline bool dfs(register int u)
{
	for(register int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(ask[v])
			continue;
		ask[v]=1;
		if(!matched[v]||dfs(matched[v]))
		{
			matched[v]=u;
			bematched[u]=v;
			return true;
		}
	}
	return false;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=m;++i)
	{
		int x=read()+1,y=read()+1;
		add(i,x),add(i,y);
	}
	int ans=0;
	for(register int i=1;i<=m;++i)
	{
		memset(ask,0,sizeof(ask));
		if(dfs(i))
			++ans;
		else
			break;
	}
	write(ans),puts("");
	for(register int i=1;i<=ans;++i)
		write(bematched[i]-1),puts("");
	return 0;
}
```

---

## 作者：Days (赞：0)

直接二分图匹配，一边锦囊，一边题目，注意如果题目无法解要退出。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int map[2003][2003];
int vis[2003];
int m1[2003],m2[2003];
int n,m;
int dfs(int x)
{
    int i;
    for(i=1;i<=n;i++)
    {
        if(!vis[i]&&map[x][i])
        {
            vis[i]=1;
            if(m1[i]==-1||dfs(m1[i]))
            {
                m1[i]=x;//锦囊i解题目x
                m2[x]=i;//题目x用锦囊i，方便输出
                return 1;
            }
        }
    }
    return  0;
```
}//匈牙利算法
```cpp
int main()
{
    int num,i,t1,t2;
        memset(map,0,sizeof(map));
        memset(m1,-1,sizeof(m1));
        scanf("%d%d",&n,&m);
        for(i=1;i<=m;i++)
        {
            scanf("%d%d",&t1,&t2);
            map[i][t1+1]=1;//个人习惯从1编号
            map[i][t2+1]=1;
```
}//建图
```cpp
        int ans=0;
        for(i=1;i<=m;i++)
        {
            memset(vis,0,sizeof(vis));
            if(dfs(i))
                ans++;
            else
                break;//注意：如果某一题做不到就退出 
        }
        printf("%d\n",ans);  
        for(i=1;i<=ans;++i)printf("%d\n",m2[i]-1);//我这里从1开始编号所以要减1
    return 0;
}
```

---


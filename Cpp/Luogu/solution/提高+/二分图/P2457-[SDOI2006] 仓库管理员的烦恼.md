# [SDOI2006] 仓库管理员的烦恼

## 题目描述

仓库管理员M最近一直很烦恼，因为他的上司给了他一个艰难的任务：让他尽快想出一种合理的方案，把公司的仓库整理好。

已知公司共有n个仓库和n种货物，由于公司进货时没能很好的归好类，使得大部分的仓库里面同时装有多种货物，这就给搬运工作人员搬运货物时带来了很多的麻烦。

仓库管理员M的任务就是设计一种合理的方案，把仓库里面的货物重新整理，把相同的货物放到同一个仓库，以便于日后的管理，在整理过程中肯定需要把某些货物从一个仓库搬运到另一个仓库，已知每一次搬运货物所付出的代价等于搬运该货物的重量。

编程任务：

请你帮助仓库管理员M设计搬运方案，使得把所有的货物归好类：使每种货物各自占用一个仓库，或者说每个仓库里只能放一种货物。同时要求搬运货物时所付出的所有的总的代价最小。


## 说明/提示

样例说明：方案是：第1种货物放到仓库2中；第2种货物放到仓库3中；第3种货物放到仓库4中；第4种货物放到仓库1中


## 样例 #1

### 输入

```
4
62 41 86 94 
73 58 11 12 
69 93 89 88 
81 40 69 13 
```

### 输出

```
650```

# 题解

## 作者：kakakaka (赞：11)

大大的水题，裸的最小费用流。

1.统计出每一种货物的数量总和sum[i]，那么对于第i种货物，将它放到第j位置时的代价就是sum[i]-map[j][i]。

2.虚拟一个源点和一个汇点，虚拟n个点代表n种货物，另外n个点代表n个仓库。（所以总共有n\*2+1个点）。

3.将源点和1～n个点连一条流量为1，费用为0的边。（代表每一种货物都需要安放）

4.将i和j+n之间连一条流量为1，费用为sum[i]-map[j][i]的边。（表示将第i种货物放到第j个仓库的代价）

5.将j+n和汇点之间连一条流量为1，费用为零的边。（表示第j个仓库能且仅能放一种货物，就避免了把不同的货物放到同一个仓库中）

然后直接跑最小费用流就可以了。

鼓掌～～鼓掌～～


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int n,map[155][155],sum[155];
struct node
{
    int next,to,dis,cap;
}edge[50005];
int head[1001],size=1;
void putin(int from,int to,int dis,int cap)
{
    size++;
    edge[size].next=head[from];
    edge[size].to=to;
    edge[size].dis=dis;
    edge[size].cap=cap;
    head[from]=size;
}
void in(int from,int to,int dis,int cap)
{
    putin(from,to,dis,cap);
    putin(to,from,-dis,0);
}
bool vis[1001];
int dist[1001],pre[1001],cost;
bool spfa(int r,int t)
{
    memset(dist,127/3,sizeof(dist));
    int mmax=dist[0];
    queue<int>mem;
    mem.push(r);
    dist[r]=0;
    vis[r]=1;
    while(!mem.empty())
    {
    int x=mem.front();mem.pop();
    vis[x]=0;
    for(int i=head[x];i!=-1;i=edge[i].next)
    {
        int y=edge[i].to;
        if(edge[i].cap&&dist[y]>dist[x]+edge[i].dis)
        {
        dist[y]=dist[x]+edge[i].dis;
        pre[y]=i;
        if(!vis[y])
        {
            mem.push(y);
            vis[y]=1;
        }
        }
    }
    }
    if(dist[n*2+1]==mmax)return 0;
    else return 1;
}
void change()
{
    int x=n*2+1;
    while(x!=0)
    {
    cost+=edge[pre[x]].dis;
    edge[pre[x]].cap-=1;
    edge[pre[x]^1].cap+=1;
    x=edge[pre[x]^1].to;
    }
}
int main()
{
    freopen("[SDOI2006]仓库管理员的烦恼.in","r",stdin);
    freopen("[SDOI2006]仓库管理员的烦恼.out","w",stdout);
    int i,j;
    memset(head,-1,sizeof(head));
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
        scanf("%d",&map[i][j]),sum[j]+=map[i][j];
    for(i=1;i<=n;i++)
    {
    in(0,i,0,1);
    in(i+n,n*2+1,0,1);
    for(j=1;j<=n;j++)
        in(i,j+n,sum[i]-map[j][i],1);
    }
    while(spfa(0,n*2+1))change();
    printf("%d\n",cost);
    return 0;
}
```

---

## 作者：wjy666 (赞：3)

这题就是个带权二分图匹配，只不过是最小匹配，所以费用流是很方便的

然而我们机房的herobrine大佬dinicTLE一个点，我表示不能理解，这题EK都轻松过

上ek代码，因为是照着费用流板子改的，用的链式前向星，所以预处理比较复杂

注释在代码里

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#define N 305 //点数至少要n*2+2(二分图2n个点,还有源点汇点)
#define For(i,j,k) for(int i=j;i<=k;++i)
using namespace std;
int read(){
    int x=0,l=1; char ch=getchar();
    while(!isdigit(ch)) {if (ch=='-') l=-1; ch=getchar();}
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*l;
}
int head[N],cnt=1,q[N],qian[N],dis[N],a[151][151],b[151]; //cnt是边数
struct node{
    int next,to,f,w; //f流量，w费用
}mp[50000]; //边数要多开一点
void add(int x,int y,int z,int w){
    mp[++cnt]=node{head[x],y,z,w}; head[x]=cnt; //链前存边
}
int main(){
    int s0=0,n=read(),l,r,x,y,s,t; bool fl[N]={0},flag;
    s=1; t=n*2+2; //s源点，t汇点
    For(i,1,n)
        For(j,1,n) a[i][j]=read(); //要先全部读入
    For(i,1,n)
        For(j,1,n) b[i]+=a[j][i]; //b[i]指货物i的总数
    For(i,1,n){
        add(s,i+1,1,0); add(i+1,s,0,0); //源点建边，点 i+1 表示第 i 种货物
        add(n+i+1,t,1,0); add(t,n+i+1,0,0); //汇点建边，n+i+1 表示第 i 个仓库
        For(j,1,n) add(i+1,j+n+1,1,b[i]-a[j][i]),add(j+n+1,i+1,0,a[j][i]-b[i]); //货物 i 到仓库j的费用为 i 的总数减去仓库 j 已有的货物 i 数量
        //正反向边编号相邻，可以通过编号^1快速找到反向边(这就是为什么cnt初值要为1)
    }
    n=n*2+2; //n改为总点数,后面循环队列要用
    while(1){
        memset(dis,127,sizeof(dis));
        q[1]=s; flag=0; fl[s]=1; l=0; r=1; dis[s]=0;
        while(l<r){
            l++; x=q[l%n];
            for(int i=head[x];i!=0;i=mp[i].next){
                y=mp[i].to;
                if (mp[i].f>0&&dis[y]>dis[x]+mp[i].w){
                    dis[y]=dis[x]+mp[i].w;
                    if (!fl[y]) fl[y]=1,q[(++r)%n]=y;
                    qian[y]=i; if (y==t) flag=1; //qian[y]是用来找路径的，内部存的是边编号
                }
            }
            fl[x]=0;
```
}//这么多行都是spfa找费用最小的增广路
```cpp
        if (!flag) break; //没有增广路可以退了
        y=t;
        while(qian[y]!=0){ //汇点回溯找路径
            x=qian[y]; s0+=mp[x].w; mp[x].f--; mp[x^1].f++; y=mp[x^1].to; //y拿到下一个点的编号(反向边指向的点就是)
        }
    }
    printf("%d\n",s0);
    return 0; //结束了~最短良心代码
}
```

---

## 作者：Great_Influence (赞：3)

有毒的题。。。。。。

当我第一次看到这道题目时，第一反应时KM，但我不会打，所以就打费用流。结果Dinic被卡爆，死活TLE1个点。然后。。。



我就去看了一下KM。

其实KM只是匈牙利的一个变种，稍微改一下就行了。

代码（附解释）：


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<queue>
#define For(i,a,b) for(i=(a);i<=(b);++i)
using namespace std;
const int MAXN=190;
const int inf=0xFFFFFFF;
template<typename T>
inline void read(T &x)//快速读入
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
int n,a[MAXN][MAXN],match[MAXN],l[MAXN],r[MAXN];//数组对应：a[i][j]:仓库i中放入j物品需要的权match[i]:匈牙利中物品i对应匹配仓库l:仓库i的期望值r[i]:物品j的期望值
bool visx[MAXN],visy[MAXN];//分别记录仓库和物品是否访问
bool dfs(int x)//匈牙利++
{
    visx[x]=true;
    int i;
    For(i,1,n)if(l[x]+r[i]==a[x][i]&&!visy[i])//KMdfs中比匈牙利多的一行：l[x]+r[i]==a[x][i]
    {
        visy[i]=true;
        if(!match[i]||dfs(match[i]))
        {
            match[i]=x;
            return true;
        }
    }
    return false;
}
int KM(void)
{
    int i,j,k;
    For(i,1,n)
        For(j,1,n)if(a[i][j]>l[i])l[i]=a[i][j];//预处理仓库期望值
    For(i,1,n)
    {
        while(1)
        {
            memset(visx,0,sizeof(visx));//记得清0
            memset(visy,0,sizeof(visy));
            if(dfs(i))break;//如果找到匹配，直接退出这次循环
            int d=inf;//否则找到已匹配仓库与未匹配物品中期望值和减去权值最小的差，在将已匹配的仓库期望值减去该差，已匹配的物品加上该差
            For(j,1,n)if(visx[j])
                For(k,1,n)if(!visy[k])d=min(d,l[j]+r[k]-a[j][k]);
            For(j,1,n)if(visx[j])l[j]-=d;
            For(j,1,n)if(visy[j])r[j]+=d;
        }
    }
    int sum=0;
    For(i,1,n)sum+=a[match[i]][i];//处理输出
    return sum;
}
int main()
{
    //freopen("data.txt","r",stdin);显然是调试
    //freopen("sdoi.out","w",stdout);
    read(n);
    int i,j,k,l;
    For(i,1,n)
        For(j,1,n)
        {
            read(k);
            For(l,1,n)if(l!=i)a[l][j]+=k; //注意输入的处理
        }
    For(i,1,n)
       For(j,1,n)a[i][j]=100*n-a[i][j];//记得要将权值取反，因为你跑的是二分图最大匹配。为了方便memset，我将权取反后再加了100n
    printf("%d\n",100*n*n-KM());//记得加上多减的100n。（因为有n条匹配边，所以一共要加上100n^2）
    return 0;
}
```
顺便再附90分怨念Dinic。
代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<queue>
#define For(i,a,b) for(i=(a);i<=(b);++i)
using namespace std;
const int MAXN=1000;
const int inf=0xFFFFFFF;
template<typename T>
inline void read(T &x)
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
int n,a[MAXN][MAXN];
struct edge
{
    int v,w,c,next;
}p[MAXN*MAXN+MAXN<<2];
int e=1,head[MAXN],fee;
void add(int u,int v,int c,int f)
{
    p[++e].v=v;
    p[e].c=c;
    p[e].w=f;
    p[e].next=head[u];
    head[u]=e;
}
int g[MAXN];
bool vis[MAXN];
int level[MAXN];
bool spfa(int s,int t)
{
    int h=0,tt=1;
    g[tt]=s;
    fill(level+1,level+t+1,inf);
    level[s]=1;
    while(h!=tt)
    {
        h=(h+1)%300;
        int u=g[h],v=head[u];
        vis[u]=false;
        while(v)
        {
            if(p[v].c&&level[p[v].v]>level[u]+p[v].w)
            {
                level[p[v].v]=level[u]+p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    tt=(tt+1)%300;
                    g[tt]=p[v].v;
                }
            }
            v=p[v].next;
        }
    }
    return level[t]!=inf;
}
int dfs(int u,int t,int flow)
{
    if(u==t||!flow)return flow;
    int sum=0,v=head[u];
    vis[u]=true;
    while(v)
    {
        if(level[p[v].v]==level[u]+p[v].w&&!vis[p[v].v]&&p[v].c>0)
        {
            int f=dfs(p[v].v,t,min(flow,p[v].c));
            sum+=f;
            p[v].c-=f;
            p[v^1].c+=f;
            fee+=f*p[v].w;
            flow-=f;
        }
        v=p[v].next;
    }
    vis[u]=false;
    return sum;
}
void Dinic(int s,int t)
{
    int ans=0;
    while(spfa(s,t))
    {
        ans+=dfs(s,t,inf);
        //cout<<ans<<endl;
    }
}
int main()
{
    //freopen("data.txt","r",stdin);
    //freopen("sdoi.out","w",stdout);
    read(n);
    int i,j,k,u;
    For(i,1,n)
        For(j,1,n)
        {
            read(k);
            For(u,1,n)if(u!=i)a[u][j]+=k;
        }
    For(i,1,n)
    {
        add(1,i+1,1,0);
        add(i+1,1,0,0);
        add(i+n+1,n*2+2,1,0);
        add(n*2+2,i+n+1,0,0);
        For(j,1,n)
        {
            add(i+1,n+j+1,1,a[i][j]);
            add(n+j+1,i+1,0,-a[i][j]);
        }
    }
    Dinic(1,n*2+2);
    printf("%d\n",fee);
    return 0;
}
（又长又不能过）
```

---

## 作者：櫻尘ིོི༹ (赞：2)

**Part 1 题意分析**

将一个类型的货物放到同一个仓库中，令花费为每个货物的数量，求最小花费。

不难看出，费用流裸题。

**Part 2 建图**

1.假设第 $i$ 种货物的数量总共为 $sum_i$ , 则将第 $j$ 个仓库装满第 $i$ 种物品所要花费的价值为 $sum_i - a_{j,i}$ ;

2.建立超源超汇，并建 $n$ 个点表示仓库，并建 $n$ 个点表示货物；

3.将每种货物与超源连接，流量 $1$ , 费用为 $0$ ;

4.将每个仓库与超汇连接，流量 $1$ , 费用为 $0$ ;

5.由建图第一条，将第 $j$ 个仓库和第 $i$ 种货物连接，流量为 $1$ , 费用为 $sum_i - a_{j,i}$ .

裸跑费用流即可。

**Part 3 Code**

```cpp
#include<bits/stdc++.h>
#define MAXN 40005
using namespace std;
int n,s,t;
int mmap[205][205];
int sum[205];
int cnt=1;
int ans1,ans2;
int h[MAXN];
int nmin[MAXN],dis[MAXN];
int prt[MAXN];
bool blog[MAXN];
struct work{
	int next,to,val,sz;
}w[MAXN*2];
inline void qxx(int x,int y,int z,int c){
	w[++cnt]=(work){h[x],y,z,c};
	h[x]=cnt;
	w[++cnt]=(work){h[y],x,0,-c};
	h[y]=cnt;
}
inline bool spfa(){
	memset(blog,false,sizeof(blog));
	memset(nmin,127/2,sizeof(nmin));
	memset(dis,127/2,sizeof(dis));
	queue<int> q;
	q.push(s);
	dis[s]=0;
	int INF=nmin[s];
	while(!q.empty()){
		int x=q.front();
		q.pop();
		blog[x]=false;
		for(int i=h[x];i;i=w[i].next){
			if(!w[i].val)continue;
			int y=w[i].to;
			if(dis[x]+w[i].sz<dis[y]){
				dis[y]=dis[x]+w[i].sz;
				nmin[y]=min(nmin[x],w[i].val);
				prt[y]=i;
				if(blog[y])continue;
				q.push(y);
				blog[y]=true;
			}
		}
	}
	if(nmin[t]!=INF)return true;
	return false;
}
inline void updata(){
	int x=t;
	while(x!=s){
		int y=prt[x];
		w[y].val-=nmin[t];
		w[y^1].val+=nmin[t];
		x=w[y^1].to;
	}
	ans1+=nmin[t];
	ans2+=nmin[t]*dis[t];
}
inline int read(){
    int x=0,w=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-'){w=-1;}c=getchar();}
    while(c<='9'&&c>='0')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*w;
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			mmap[i][j]=read();
			sum[j]+=mmap[i][j];
		}
	}
	s=0,t=n*2+1;
	for(int i=1;i<=n;++i){
	    qxx(s,i,1,0);
	    qxx(i+n,t,1,0);
	    for(int j=1;j<=n;++j)qxx(i,j+n,1,sum[i]-mmap[j][i]);
    }
	while(spfa())updata();
	printf("%d",ans2);
	return 0;
}
```


---

## 作者：Mortis_Vampire (赞：2)

我本想用这题练练费用流，但是莫名 RE 30。

然后我交了一发 KM。

直接冲到最优解第一页了。(12.14)

总结：

KM 牛逼！！！

本题思路：

1. 建立二分图，左部节点为 $n$ 种货物，右部节点 $n$ 个位置

2. 将左部第 $i$ 个节点连向右部第 $j$ 个节点一条边权为 $sum_i-w_{i,j}$ 的边，其中 $sum_i=\sum\limits_{j=1}^{n} w_{i,j}$。

3. 这张图上一定存在完备匹配，于是我们跑 KM

对于题目中所求的最小方案，我们可以将边权取反，得出的结果也取反。

附上代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define inf 0x7fffffff
using namespace std;
int n,m,a[505],w[505][505],sum[505];
int va[505],vb[505],map[505][505];//访问标记
int la[505],lb[505];//顶标
int match[505],upd[505];//匹配点、更新
bool dfs(int x) {//匈牙利
    va[x]=1;
    for(int y=1; y<=n; y++)
    if(w[x][y]!=-inf){
        if(!vb[y])
            if(la[x]+lb[y]==w[x][y]) {
                vb[y]=1;
                if(!match[y]||dfs(match[y])) {
                    match[y]=x;
                    return true;
                }
            } else upd[y]=min(upd[y],la[x]+lb[y]-w[x][y]);
    }

    return false;
}
int KM() {//KM板子
    memset(match,0,sizeof(match));
    for(int i=1; i<=n; i++) {
        la[i]=-inf;
        lb[i]=0;
        for(int j=1; j<=n; j++)
            la[i]=max(la[i],w[i][j]);
    }
    for(int i=1; i<=n; i++)
        while(true) {
            memset(va,0,sizeof(va));
            memset(vb,0,sizeof(vb));
            for(int j=1; j<=n; j++)upd[j]=inf;
            if(dfs(i))break;
            int delta=inf;
            for(int j=1; j<=n; j++)
                if(!vb[j])delta=min(delta,upd[j]);
            for(int j=1; j<=n; j++) {
                if(va[j])la[j]-=delta;
                if(vb[j])lb[j]+=delta;
            }
        }
    int ans=0;
    for(int i=1; i<=n; i++)
        ans+=w[match[i]][i];
    return ans;
}
signed main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
    {
        int x;
        scanf("%d",&x);
        map[i][j]=x;
        sum[j]+=x;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        w[i][j]=-(sum[i]-map[j][i]);
    printf("%d",-KM());
    return 0;
}
```


---

## 作者：wenjie (赞：2)

写一篇题解，也算是加强我对KM的理解吧。
先上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n;
int store[155][155];
int w[155][155];
int ll[155];
int la[155],lb[155];
int va[155],vb[155];
int match[155];
int delta;
bool dfs(int x)
{
	va[x]=1;
	for(int i=1;i<=n;i++)
	{
		if(!vb[i])
		{
			if((la[x]+lb[i])==w[x][i])
			{
				vb[i]=1;
				if(!match[i]||dfs(match[i]))
				{
					match[i]=x;
					return true;
				}
			}
			else delta=min(delta,la[x]+lb[i]-w[x][i]);
		}
	}
	return false;
}
int KM()
{
	for(int i=1;i<=n;i++)
	{
		la[i]=-(1<<30);
		lb[i]=0;
		for(int j=1;j<=n;j++)
		{
			la[i]=max(la[i],w[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		while(true)
		{ 
			memset(va,0,sizeof(va));
			memset(vb,0,sizeof(vb));
			delta=(1<<30);
			if(dfs(i))break;
			for(int j=1;j<=n;j++)
			{
				if(va[j])la[j]-=delta;
				if(vb[j])lb[j]+=delta;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans-=w[match[i]][i];
	}
	return ans;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			store[i][j]=read();
			ll[j]+=store[i][j];
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			w[i][j]=-(ll[j]-store[i][j]);
		}	
	cout<<KM();
	return 0;
}
```
首先引入交错树的概念

其实也很好理解，就是在一般的匈牙利算法中，从一个左部点出发尝试进行匹配，如果失败，那他所有访问过的节点以及为了访问这些节点所经过的边共同构成交错树。（该树根节点为左部点，叶子也是左部点）

之后是顶标，这个概念为相等子图而服务。
所谓相等子图，就是二分图中所有节点满足Ai+Bi=W(i,j)的边所构成的子图。
而顶标，就是这里的Ai，Bi。实际操作时，将左部点的顶标赋值为Ai，右部点赋值为Bi。
# 定理
#### 若相等子图中存在完备匹配，则这个完备匹配就是二分图的带权最大匹配。


------------


```cpp
for(int i=1;i<=n;i++)
	{
		la[i]=-(1<<30);
		lb[i]=0;
		for(int j=1;j<=n;j++)
		{
			la[i]=max(la[i],w[i][j]);
		}
	}
```
在这里我们将所有的Ai赋值为其所连边中权值最大者，Bi赋值为0。此时他满足Ai+Bj>=W(i,j)。
```
for(int i=1;i<=n;i++)
	{
		while(true)
		{ 
			memset(va,0,sizeof(va));
			memset(vb,0,sizeof(vb));
			delta=(1<<30);
			if(dfs(i))break;
			for(int j=1;j<=n;j++)
			{
				if(va[j])la[j]-=delta;
				if(vb[j])lb[j]+=delta;
			}
		}
	}
```
对每一个左部节点进行匹配（使用while（true）不达目的不罢休）如果dfs(i)==1，即这个节点可以匹配，那就不管他。否则修改顶标（失败的交错树中的顶标）。
这里有一点需要注意，即修改顶标后，再一次进行dfs时，原来并非相等子图中的边，现在就有可能成为相等子图中的边。
（暂时写到这里，机房关门了）




---

## 作者：Aisaka_Taiga (赞：0)

## 基本思路：KM 算法求最优匹配

如果你不会 KM 算法请[点这里](https://www.luogu.com.cn/blog/zxh248588021/er-fen-tu-xue-xi-bi-ji)

先来定义一些数组方便下面表达：

```cpp
int n,m,mp[N][N];//mp存放输入的矩阵
int sum[N];//sum存放每一种货物重量的总和 
int va[N],vb[N]//va，vb标记每一次dfs左右参与的点
int w[N][N];//w存放把i其余所有货物搬到仓库j的代价 
int la[N],lb[N]//la，lb分别为左右标杆
int mi[N];//mi为右部点匹配的点
int vis[N];//vis标记当前dfs每一个点最少下降多少可以有其他的选择 
```

题目给出的输入第 $i$ 行是仓库 $i$ 所存放的第 $j$ 种货物的重量，如果要用仓库 $i$ 来存放货物 $j$，那就需要把其他仓库里的货物 $j$ 给搬到仓库 $i$，代价为 $sum_{j}-mp[i][j]$，所以输入 $mp$ 数组的同时把 $sum$ 数组给处理出来，然后把 $w$ 数组处理出来，左部点为仓库编号，右部点为货物种类编号，跑 KM 算法就好啦。

这题让着求最小代价，和一般的不太一样怎么办？

只要在处理 $w$ 数组的时候存的边权一取反，跑 KM 的时候不久就可以找最优匹配了吗，最后输出别忘了取反。

### code：

```cpp
#include<bits/stdc++.h>
#define INF 0x7fffffff
#define N 510
using namespace std;
int n,m,mp[N][N],sum[N];//mp存放输入的矩阵，sum存放每一种货物重量的总和 
int va[N],vb[N],w[N][N];//va，vb标记每一次dfs左右参与的点，w存放把i其余所有货物搬到仓库j的代价 
int la[N],lb[N],mi[N],vis[N];//la，lb分别为左右标杆，mi为右部点匹配的点，
inline int read()
{
   int s=0,w=1;char ch=getchar();
   while(ch<'0'||ch>'9')
   {  if(ch=='-')  w=-1;  ch=getchar();}
   while(ch>='0'&&ch<='9')
   {  s=s*10+ch-'0'; ch=getchar();}
   return s*w;
} 
inline int dfs(int x)//匈牙利算法 
{
    va[x]=1;//标记参与本次dfs 
    for(int i=1;i<=n;i++)//枚举每一个右部的点 
      if(w[x][i])//如果当前两点之间存在边 
        if(!vb[i])//vb没有标记已经搜过了 
        {
            if(la[x]+lb[i]==w[x][i])//如果当前左右标杆加起来等于边权 
            {
                vb[i]=1;//标记可以 
                if(!mi[i]||dfs(mi[i]))//如果当前右部点没有与之相匹配的点或者与之相匹配的点可以与其他点匹配 
                {
                    mi[i]=x;//当前左部点与右部点匹配 
                    return 1;//返回匹配成功 
                }
            }
        else vis[i]=min(vis[i],la[x]+lb[i]-w[x][i]);//如果不等于边权，求出下降最小可以有其他解的值 
        }
    return 0;//返回匹配失败 
}
int KM()//KM算法板子 
{
    for(int i=1;i<=n;i++)
    {
        la[i]=-INF;
        lb[i]=0;
        for(int j=1;j<=n;j++)
          la[i]=max(la[i],w[i][j]);//给左部标杆赋初值 
    }
    for(int i=1;i<=n;i++)//匹配每一个左部点 
    {
        while(1)
        {
            memset(va,0,sizeof(va));//每次都要清空va，vb 
            memset(vb,0,sizeof(vb));
            for(int j=1;j<=n;j++)
              vis[j]=INF;//赋初值，vis表示每一个点最少下降多少可以有另一种选择 
            if(dfs(i))break;//如果当前点匹配成功直接退出 
            int d=INF;//赋初值 
            for(int j=1;j<=n;j++)
              d=min(d,vis[j]);//取每一个vis的最小值 
            for(int j=1;j<=n;j++)
            {
                if(va[j])la[j]-=d;//左部点减d 
                if(vb[j])lb[j]+=d;//右部点加d 
            }
        }
    }
    int ans=0;//ans表示答案 
    for(int i=1;i<=n;i++)//枚举每一个右部点 
      ans+=w[mi[i]][i];//累加所选的边权 
    return ans;//返回答案 
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            int x;
            x=read();
            mp[i][j]=x;//存图 
            sum[j]+=x;//累加一种货物的重量总和 
        }
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      w[i][j]=-(sum[i]-mp[j][i]);//转换一下求出要把所有货物放到最此仓库的代价，取相反数求最大边权匹配 
    printf("%d",-KM());//输出的时候别忘了取反 
    return 0;
}//by wwwaax 
```


---

## 作者：Kaenbyou_Rin (赞：0)

由于题目要求求最小代价，并且有流量限制（为 $1$ ），我们可以想到用**最小费用最大流**。


------------

首先我们读入整张图，记录下每种货物的数量 $sum_i$ 。

```cpp
for(register int i=1;i<=n;i++){
	for(register int j=1;j<=n;j++){
		mp[i][j]=read();
		sum[i]+=mp[i][j];//第i种货物的总数 
	}
}
```

然后考虑怎么建模。

我们将每个仓库 $i$ 拆成两个仓库，方便连边。对于每个仓库，要接受第 $i$ 种货物的代价为第 $i$ 种货物的总数减去本来就在该仓库中的货物数量，即：
```cpp
for(register int i=1,x;i<=n;i++){
	for(register int j=1;j<=n;j++) 
    	add(i,j+n,1,sum[i]-mp[i][j]);
        //将第i种货物运到第j个仓库所需的代价 
}
```
然后就是将原先的仓库连向源点，将克隆的仓库连向汇点，跑最小费用最大流就好了。（这题不算难想，翻题解前请至少保证 $30$ 分钟的思考时间）。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=1e5+10;
int n,mp[210][210],s,t,dis[N],pre[N],vis[N];
int nxt[N],flow[N],mincost,head[N],tot=1,sum[210]; 
struct edge{
    int to,nxt,flow,dis;
}e[N];
inline int read(){
	int w=1,x=0;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch<='9'&&ch>='0';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return x*w;
}
inline void add(int u,int v,int w,int dis){
    e[++tot].nxt=head[u];
    e[tot].to=v;
    e[tot].flow=w;
    e[tot].dis=dis;
    head[u]=tot;
    e[++tot].nxt=head[v];
    e[tot].to=u;
    e[tot].flow=0;
    e[tot].dis=-dis;
    head[v]=tot;
}
inline bool spfa(){
    queue<int> q;
    memset(dis,0x3f,sizeof dis);
    memset(flow,0x3f,sizeof flow);
    memset(vis,0,sizeof vis);
    q.push(s); 
    vis[s]=1;dis[s]=0;pre[t]=-1;
    while(!q.empty()){
        int u=q.front();
        q.pop();vis[u]=0;
        for(register int i=head[u];i;i=e[i].nxt){
        	int v=e[i].to,w=e[i].dis;
            if(e[i].flow>0&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                pre[v]=u;nxt[v]=i;
                flow[v]=min(flow[u],e[i].flow);
                if (!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return pre[t]!=-1;
}
void mcmf(){//最小费用最大流版子 
    while(spfa()){
        int u=t;
        mincost+=flow[t]*dis[t];
        while(u!=s){
            e[nxt[u]].flow-=flow[t];
            e[nxt[u]^1].flow+=flow[t];
            u=pre[u];
        }
    }
}
signed main(){
    n=read();
	s=n*3+1,t=s+1;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			mp[i][j]=read();
			sum[i]+=mp[i][j];//第i种货物的总数 
		}
	}
	for(register int i=1;i<=n;i++){
		add(s,i,1,0);
		add(i+n,t,1,0);
	}
	for(register int i=1,x;i<=n;i++){
		for(register int j=1;j<=n;j++) add(i,j+n,1,sum[i]-mp[i][j]);//将第i种货物运到第j个仓库所需的代价 
	}
    mcmf();
    printf("%d\n",mincost);
    return 0;
}
```

---

## 作者：GTAyin (赞：0)

## **一.分析**

建图思路是比较清晰的，所以称它为水题。建图就是将每一件货物与每一间仓库之间建边，建一条流量为一，费用为这个货物搬运到这个仓库的消耗的边。源点则与每一个货物建一条流量为一，费用为零的边。每一个仓库就与汇点建一条流量为一，费用为零的边（有个小技巧，当每个仓库有指定货物个数存放时，流量就为指定个数）。大概就是这样了，剩下的就是敲板子了。

## **二.code**

```c
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
const int N=1e5+90,inf=999999999;
using namespace std;
struct node{
	int to,w,val,nex;
}e[N];
int head[N],tot=1;
int dis[N],incf[N],per[N],ans;
bool bk[N];
int n,s,t;
int sum[N],a[1000][1000];
void add(int u,int v,int w,int val){
	e[++tot].to=v;
	e[tot].w=w;
	e[tot].val=val;
	e[tot].nex=head[u];
	head[u]=tot;
}
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	memset(bk,false,sizeof(bk));
	queue<int> p;
	p.push(s);
	dis[s]=0;
	bk[s]=true;
	incf[s]=0x7fffffff;
	while(!p.empty()) {
		int k=p.front();
		p.pop();
		bk[k]=false;
		for(int i=head[k];i;i=e[i].nex){
			int v=e[i].to;
			if(e[i].w==0) continue;
			if(dis[v]>dis[k]+e[i].val){
				per[v]=i;
				dis[v]=dis[k]+e[i].val;
				incf[v]=min(incf[k],e[i].w);
				if(!bk[v]){
					p.push(v);
					bk[v]=true; 
				}
			}
		} 
	}
	if(dis[t]==0x3f3f3f3f) return false;
	else return true;
}

void work(){
	while(spfa()){
		int x=t;
		ans+=dis[t];
		int i;
		while(x!=s){
			i=per[x];
			e[i].w-=incf[t];
			e[i^1].w+=incf[t];
			x=e[i^1].to;
		}
	}
}
int main(){
	cin>>n;
	s=0;
	t=n+n+1;
	for(int i=1;i<=n;i++){
		add(s,i,1,0);
		add(i,s,0,0);
		add(i+n,t,1,0);
		add(t,i+n,0,0);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			sum[j]+=a[i][j];//小技巧，先将总和算出来，这样当放在某一仓库时，就可以用这个货物的总费用减去放在这个仓库的费用 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			add(i,j+n,1,sum[i]-a[j][i]);//具体实现 
			add(j+n,i,0,a[j][i]-sum[i]);
		}
	}
	work();
	cout<<ans;
	return 0;
}
```
完结撒花（留个赞再走呗）。


---

## 作者：Farkas_W (赞：0)

$$\texttt{题目大意}$$

$\quad$每个仓库中只放一种物品，同种物体必须放在同一个仓库里，有 $n$ 个仓库，$n$ 种物品，转移物品的代价是其数量，求满足条件的最小代价。

$\quad$这题简直就是模板题，很适合练习二分图最大权的 $KM$ 算法和最小费用最大流 $EK$ 算法。

$\quad$两种方法我都会介绍并贴出代码，想看 $EK$ 算法的可以直接跳过 $KM$ 算法

$$\texttt{KM 算法}$$

$\quad$这种题型不是很多，没有做过的可以先看看[P1559 运动员最佳匹配问题](https://www.luogu.com.cn/problem/P1559)，就是一道基础的KM算法模板题，另外[这个博客](https://www.cnblogs.com/wenruo/p/5264235.html)写的不错，很适合学习。

$\quad$首先KM算法的正确性基于以下定理：

$\quad$若由二分图中所有满足 的边 构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。

$\quad$KM算法的正确性：

1. KM算法要求的是图中最大权匹配是完备匹配也就是说都匹配上了。我想这个条件要不是题目中自己给出了，要不就是边权都是正值且每个点想其他点都有连边如本题，此时这个性质是可以被保证的。

2. 这个算法是围绕着顶点的定标匹配的我来定性的描述这个算法的过程：首先每个点都和自己最大的边权进行匹配，然后发现有些点没有匹配对象的话更换交错树中定标的值然后再次寻找增广路。当然新能沟通的路是边权变化最小的。

3. 经过我长期的研究我终于把我的反例证明出来了我的意思是指是否存在一种情况使得当前直接点匹配上比两个已匹配边更换匹配然后是当前点得到匹配更优，这个主意很容易走到这个误区经过我画的多张图我发现出现这种情况的是不存在完备匹配的情况的否则皆可以利用KM网上的证明方法来证明。

$\quad$Kuhn－Munkres算法流程：

* 初始化可行顶标的值；
* 用匈牙利算法寻找完备匹配；
* 若未找到完备匹配则修改可行顶标的值；
* 重复（2）（3）直到找到相等子图的完备匹配为止。

$\quad$另外KM算法求的是最大匹配下的最大值，本题要求最小代价，所以边权要取反。

$\quad$可以看看代码的注释，感觉不是很好理解(当时新学的时候感觉很难)。

```cpp
#include<iostream>//KM算法 
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<algorithm>
#define int long long
#define re register int
#define il inline
#define inf 1e18+5
#define next nee
using namespace std;
il int read()
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
il void print(int x)
{
  if(x<0)putchar('-'),x=-x;
  if(x/10)print(x/10);
  putchar(x%10+'0');
}
const int N=155;
int n,a[N][N];
int minz,lx[N],ly[N];//顶标
int w[N],b[N][N];//边权
int match[N];//match[i]表示第i个仓库的匹配对象
bool visx[N],visy[N];//标记，每个仓库只走一遍
il bool dfs(int x)
{
	visx[x]=1;
	for(re i=1;i<=n;i++)
	if(!visy[i]){//未访问过
		int t=lx[x]+ly[i]-b[x][i];
		if(t==0){//满足平衡条件
			visy[i]=1;
			if(match[i]==0||dfs(match[i]))
			{
				match[i]=x;return 1;
			}
		}
		else if(t>0)minz=min(minz,t);//更新最小修改值
	}
	return 0;
}
il void KM()
{
	for(re i=1;i<=n;i++)
	{
		while(1)
		{
			memset(visx,0,sizeof(visx));//清零
			memset(visy,0,sizeof(visy));//清零
			minz=inf;    //初始化为inf
			if(dfs(i))break;//找到就下一个，直到找到为止
			for(re j=1;j<=n;j++)
			{
				if(visx[j])lx[j]-=minz;//降低x的要求
				if(visy[j])ly[j]+=minz;//增加y的要求
			}
		}
	}
}
signed main()
{
	n=read();
	for(re i=1;i<=n;i++)
	{
		lx[i]=-inf;//初始化为极小值
		for(re j=1;j<=n;j++)a[i][j]=read(),w[j]+=a[i][j];
	}
	for(re i=1;i<=n;i++)for(re j=1;j<=n;j++)
   {
    b[i][j]=-w[i]+a[j][i];//记得取反
    lx[i]=max(lx[i],b[i][j]);//顶标初始化
   }
	KM();int ans=0;
	for(re i=1;i<=n;i++)ans+=b[match[i]][i];//统计答案
	print(-ans);
	return 0;
}
```
$$\texttt{EK 算法}$$

$\quad$没做过的建议先做模板，其实一样简单([P3381 【模板】最小费用最大流](https://www.luogu.com.cn/problem/P3381))

$\quad$EK算法流程：
* 在残余网络上寻找最短路
* 对该路径进行增广, 对答案产生贡献
* 不断重复opt.1操作, 直至s\to ts→t不存在路径

$\quad$其实就是把网络流的 $bfs$ 换成了 $SPFA$，一次只找一条增广路，把代价看做距离，另外建一个超级源点 $s$ 和超级汇点 $t$，$s$ 连向所有代表物品的点 $(1...n)$，没有代价，所有代表仓库的点 $(n+1...2n)$ 连向 $t$，没有代价，所有物品和仓库两两相连，流量都为 $1$ 即可(其他题解已经介绍的很详细了)。

$\quad$这里 $SPFA$ 也可以换成 $Dijkstra$，只不过费用流会有负边权，需要加上势，稍微有点麻烦。

$\quad$然后直接跑费用流就 $OK$ 了。

```cpp
#include<iostream>//EK算法 
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<algorithm>
#define int long long
#define re register int
#define il inline
#define inf 1e18+5
#define next nee
using namespace std;
il int read()
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
il void print(int x)
{
  if(x<0)putchar('-'),x=-x;
  if(x/10)print(x/10);
  putchar(x%10+'0');
}
const int N=250;
int n,s,t,a[N][N],maxcost,w[N],dis[N<<1],pre[N<<1];
int next[N*N*2],go[N*N*2],head[N<<1],tot=1,d[N*N*2],val[N*N*2];
bool vis[N<<1];
il void Add(int x,int y,int z,int u)
{
	next[++tot]=head[x];
	head[x]=tot;go[tot]=y;val[tot]=z;d[tot]=u;
}
il bool SPFA()
{
	queue<int>q;
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));//初始化
	int maxn=dis[0];
	q.push(s);vis[s]=1;dis[s]=0;
	while(!q.empty())
	{
		int x=q.front();q.pop();vis[x]=0;
		for(re i=head[x],y;i,y=go[i];i=next[i])
		if(val[i]){
			if(dis[y]>dis[x]+d[i])
			{
				dis[y]=dis[x]+d[i];
				pre[y]=i;//记录前驱
				if(!vis[y])vis[y]=1,q.push(y);
			}
		}
	}
	if(dis[t]==maxn)return 0;//未被跑到
	return 1;
}
il void EK()
{
	while(SPFA())
	{
		int x=t;
		maxcost+=dis[t];//因为每条路流量为1，没有必要记录流量
		while(x!=s){//回流
			int i=pre[x];
			val[i]-=1;
			val[i^1]+=1;
			x=go[i^1];
		}
	}
}
signed main()
{
	n=read();s=2*n+1;t=2*n+2;
	for(re i=1;i<=n;i++)for(re j=1;j<=n;j++)a[i][j]=read(),w[j]+=a[i][j];//记录每个物品总数量
	for(re i=1;i<=n;i++)
	{
		Add(s,i,1,0);Add(i,s,0,0);
		Add(i+n,t,1,0);Add(t,i+n,0,0);
	}
	for(re i=1;i<=n;i++)for(re j=1;j<=n;j++)
	Add(i,j+n,1,w[i]-a[j][i]),Add(j+n,i,0,a[j][i]-w[i]);//建边
	EK();
	print(maxcost);
	return 0;
}
```

---

## 作者：听取MLE声一片 (赞：0)

~~先赞后看王者风范~~

看楼下dalao的`dinic`的算法挂了，~~难道这题 `dinic` 是负优化~~，其实这道题用 `EK` 就可以水过去。

## 前置芝士：最小费用最大流

如果您不会费用流，可以先去学习一下，并AC这道[模板题目](https://www.luogu.com.cn/problem/P3381)，然后就可以水这道题目了。

## 本题解法

首先，我们知道费用流的用途是在确保**到达汇点流量最大时**的最小花费，所以说我们只需要通过一系列的连边来建图。

我们先进行拆点，一个点用来存本来的库存，另一个点用来存搬运后的库存。

所以说原点和汇点就可以确定下来了：

```
s=0,t=n*2+1;
```

不难发现，最终一种物品（的全部）只会在一个仓库里，因为仓库和物品的个数都为 `n` ，所以说我们要统计一下总数，在输入时累加即可。

### 重点：

为了简化问题，我们把每个仓库中每种物品看做为**一个整体**，因为把一个仓库里的物品拆来拆去肯定会花不必要的代价，所以我们的建图（部分）就是这样，容量为1（一个整体），费用为零（无花费）：

```
	for(int i=1;i<=n;i++){
    	add(s,i,1,0);//原点到这个点连一下
    	add(i+n,t,1,0);//这个点到汇点连一下
   	}

```

接下来就是把货物往下一个点移动了，边 `i,j` 的意义为把 `i` 种货物全部运到 `j` 号仓库，所需要的代价就是：总费用-这个仓库的重量（同种的），这个放在刚才的循环里就行了。

下面是代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int inf=2147483647;
int maxn,cost;
int top=1,head[5001];
int dis[5001];
int n,m,s,t,book[5001],c[200][200],d[200];
struct point{
    int v,w,val,next;
}a[100001];
struct b{
    int fa;
    int v;
}b[5001];
inline void _add(int u,int v,int val,int w){
    a[++top].v=v;
    a[top].val=val;
    a[top].w=w;
    a[top].next=head[u];
    head[u]=top;
}
inline void add(int u,int v,int val,int w){
	_add(u,v,val,w);
	_add(v,u,0,-w);
}
bool spfa(){
	queue<int> q;
    memset(b,0,sizeof(b));
    memset(book,0,sizeof(book));
    for(int i=0;i<=t;i++)
    	dis[i]=inf;
    dis[s]=0;
    q.push(s);
    book[s]=1;
    while(!q.empty()){
        int u=q.front();
        book[u]=0;
        q.pop();
        for(int i=head[u];i;i=a[i].next){
            int v=a[i].v,w=a[i].w;
            if(a[i].val>0&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                b[v].fa=u,b[v].v=i;
                if(book[v]==0){
                    q.push(v);
                    book[v]=1;
                }
            }
        }
    }
    return dis[t]!=inf;
}
void EK(){
    while(spfa()){
        int minn=inf;
        for(int i=t;i!=s;i=b[i].fa)
			minn=min(minn,a[b[i].v].val);
        for(int i=t;i!=s;i=b[i].fa){
            a[b[i].v].val-=minn;
            a[b[i].v^1].val+=minn;
        }
        maxn+=minn;
        cost+=minn*dis[t];
    }
    return;
}
int main()
{
    n=read();
	s=0,t=n*2+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			c[i][j]=read();
			d[j]+=c[i][j];
		}
	for(int i=1;i<=n;i++){
    	add(s,i,1,0);
    	add(i+n,t,1,0);
    	for(int j=1;j<=n;j++)
        	add(i,j+n,1,d[i]-c[j][i]);
    }
    EK();
    cout<<cost;
    return 0;
}

```

谢谢大家！

---

## 作者：Celebrate (赞：0)

到[我的博客](https://blog.csdn.net/zsyzClb/article/details/88345083)食用味道更嘉

首先简化题目，求出cos[i][j]货物i放到j仓库所需的值

然后发现这其实是一道最小费用最大流的题目

然后就AC吧（好短的解释）

参考代码 （注释我也懒得写了）

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue> 
 
using namespace std ;
 
namespace IO {
    inline int read() {
        int x = 0 , f = 0 ; char s = getchar() ;
        while ( !isdigit(s) ) f |= s=='-' , s = getchar() ;
        while (  isdigit(s) ) x = (x<<1)+(x<<3)+(s-48) , s = getchar() ;
        return !f ? x : -x ;
    }
    int ss , aa[21] ; 
    inline void write ( int x ) {
        if ( !x ) putchar('0') ; ss = 0 ;
        if ( x < 0 ) putchar('-') , x = -x ;
        while ( x ) aa[++ss] = x%10 , x /= 10 ;
        for ( int i = ss ; i > 0 ; i -- ) putchar(aa[i]+'0') ;
        puts ( "" ) ;
    }
}
using namespace IO ;
 
const int N = 315 ;
 
int n , a[N][N] ;
int cos[N][N] , s[N] ;
 
namespace MAP {
    struct edge {
        int v , w , k , nxt ;
    } e[N*N] ; int tot , last[N] , cur[N] ;
    inline void add ( int u , int v , int w , int k ) {
        e[++tot] = (edge){ v , w , k , last[u] } ;
        last[u] = tot ;
        e[++tot] = (edge){ u , 0 , -k , last[v] } ;
        last[v] = tot ;
    }
}
using namespace MAP ;
 
bool vis[N] ; int dis[N] ;
int S , T ; int cost = 0 ;
 
inline bool SPFA() {
    memset ( vis , 0 , sizeof(vis) ) ; vis[T] = 1 ;
    memset ( dis , -1 , sizeof(dis) ) ; dis[T] = 0 ;
    queue<int> q ; q.push ( T ) ;
    while ( !q.empty() ) {
        int u = q.front() ; q.pop () ; vis[u] = 0 ;
        for ( int i = last[u] ; i != -1 ; i = e[i].nxt ) {
            int v = e[i].v ;
            if ( e[i^1].w  && ( dis[v] > dis[u]-e[i].k || dis[v] == -1 ) ) {
                dis[v] = dis[u] - e[i].k ;
                if ( !vis[v] ) vis[v] = 1 , q.push ( v ) ;
            }
        }
    }
    return dis[S] != -1 ;
}
 
int dfs ( int u , int f ) {
    vis[u] = 1 ;
    if ( u == T ) return f ;
    int ans = 0 , t = 0 ;
    for ( int i = cur[u] ; i != -1 ; i = e[i].nxt ) {
        int v = e[i].v ;
        if ( !vis[v] && e[i].w && dis[u]-e[i].k == dis[v] ) {
            ans += ( t=dfs( v , min( e[i].w , f-ans )) ) ;
            e[i].w -= t , e[i^1].w += t ;
            cost += t*e[i].k ; cur[u] = i ;
            if ( ans == f ) break ;
        }
    }
    vis[u] = 0 ; return ans ;
}
 
int main() {
    n = read() ;
    for ( int i = 1 ; i <= n ; i ++ ) 
        for ( int j = 1 ; j <= n ; j ++ ) 
            a[i][j] = read() , s[j] += a[i][j] ;
    for ( int i = 1 ; i <= n ; i ++ ) 
        for ( int j = 1 ; j <= n ; j ++ ) 
            cos[i][j] = s[i] - a[j][i] ;
    S = 2*n+1 , T = S + 1 ;
    tot = -1 , memset ( last , -1 , sizeof(last) ) ;
    for ( int i = 1 ; i <= n ; i ++ ) 
        add ( S , i , 1 , 0 ) , add ( i+n , T , 1 , 0 ) ;
    for ( int i = 1 ; i <= n ; i ++ )
        for ( int j = 1 ; j <= n ; j ++ ) 
            add ( i , j+n , 1 , cos[i][j] ) ;
    int ans = 0 ;
    while ( SPFA() ) {
        memcpy ( cur , last , sizeof(cur) ) ;
        ans += dfs ( S , 999999999 ) ;
    }
    write ( cost ) ; return 0 ;
}

```


---

## 作者：aiyougege (赞：0)

我极少做最大流费用流最小割这类的网络流题目, 但是建模还是会的, 只是每次题之前都要baidu个板子用……
#### Solution
![](https://cdn.luogu.com.cn/upload/pic/21905.png)
我稍微画了个图然后就明白改怎么建图了(画图用的工具[SketchBook](https://www.sketchbook.com/))

只是我这个图多建了一些边, 就是把每个仓库的每种货物都建了点, 实际上是不用的, 只是这样更方便理解.这样会多建$n^2$个点.

#### Code
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define N 22505
#define INF 100000000
using namespace std;

struct Edge{
    int from,to,cap,flow,cost;
    Edge(int u,int v,int ca,int f,int co):from(u),to(v),cap(ca),flow(f),cost(co){};
};
//网络流: baidu: 最小费用最大流模板
namespace MCMF{
    int n,m,s,t;
    vector<Edge> edges;
    vector<int> G[N];
    int inq[N],d[N],p[N],a[N];

    void init(int _n){
        n=_n;
        for(int i=0;i<n;i++)
            G[i].clear();
        edges.clear();
    }
    void addedge(int from,int to,int cap,int cost){
        edges.push_back(Edge(from,to,cap,0,cost));
        edges.push_back(Edge(to,from,0,0,-cost));
        int m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool SPFA(int s,int t,int &flow,int &cost){
        for(int i=0;i<n;i++)d[i]=INF;
        memset(inq,0,sizeof(inq));
        d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;
        queue<int> Q;
        Q.push(s);
        while(!Q.empty()){
            int u=Q.front();Q.pop();inq[u]--;
            for(int i=0;i<G[u].size();i++){
                Edge& e=edges[G[u][i]];
                if(e.cap>e.flow && d[e.to]>d[u]+e.cost){
                    d[e.to]=d[u]+e.cost;p[e.to]=G[u][i];
                    a[e.to]=min(a[u],e.cap-e.flow);
                    if(!inq[e.to]){
                        inq[e.to]++;Q.push(e.to);
                    }
                }
            }
        }
        if(d[t]==INF) return false;
        flow+=a[t],cost+=d[t]*a[t];int u=t;
        while(u!=s){
            edges[p[u]].flow+=a[t];
            edges[p[u]^1].flow-=a[t];
            u=edges[p[u]].from;
        }
        return true;
    }
    int MincotMaxflow(int s,int t){
        int flow=0,cost=0;
        while(SPFA(s,t,flow,cost));
        return cost;
    }
};

int n;
int map[155][155];
int allco[N];

int main(){
    scanf("%d",&n);
    MCMF::init(2*n+2);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            scanf("%d",&map[i][j]);
    
    for(int j=1;j<=n;++j)
        for(int i=1;i<=n;++i)
            allco[j]+=map[i][j];
    for(int i=1;i<=n;++i){
        MCMF::addedge(0,i,1,0);
        MCMF::addedge(i+n,n*2+1,1,0);
        for(int j=1;j<=n;j++)
            MCMF::addedge(i,j+n,1,allco[i]-map[j][i]);
    }
    printf("%d",MCMF::MincotMaxflow(0,2*n+1));
    return 0;
}
```

---

## 作者：依依 (赞：0)

解：

我的错误的建模方式:(流量,费用)   sum[i]：i这种货物的总量

S->货物 (sum[i],1)

货物->仓库 (a[i][j],1)

仓库->T (inf,0)

但是这样建模的问题是，没有办法控制归类以及怎么放

正确建模方式：

费用控制货物总量，流量保证每种货物只能放到其中一个仓库

S->货物 (1,0)

货物->仓库 (1,sum[i]-a[j][i])

仓库->T (1,0)

[>_<](http://www.cnblogs.com/adelalove/p/8678770.html)

---


# 长脖子鹿放置

## 题目背景

众所周知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。

## 题目描述

如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）

![horse](https://cdn.luogu.com.cn/upload/pic/37260.png)

给定一个 $N \times M$ 的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。

## 说明/提示

对于 $10\%$ 的数据，$1 \le N,M \le 5$；

对于 $30\%$ 的数据，$1 \le N,M \le 10$；

对于 $60\%$ 的数据，$1 \le N,M \le 50$；

对于 $80\%$ 的数据，$1 \le N,M \le 100$；

对于 $100\%$ 的数据，$1 \le N,M \le 200$。

## 样例 #1

### 输入

```
2 2 1
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
8 7 5
1 1
5 4
2 3
4 7
8 3```

### 输出

```
28```

# 题解

## 作者：liangbowen (赞：30)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P5030)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17064208.html)

一道没啥意思的题目，但是好像很多题解都过不了现在的数据？

## 思路

只不过是把正常题目的马（$1, 2$）换成了另一种东西（$1, 3$）。

很套路地，黑白染色，源点向黑点连边，白点向黑点连边，容量都是 $1$。

然后对于两个可以互相到达的点 $(x, y)$ 与 $(dx, dy)$，如果都没有障碍，那么就连容量是 $1$ 的边。这里的两个点应该保证颜色不同。

答案即为最大独立集。

本题一个比较不同的点在于黑白染色。正常我们都是按 $(x + y)$ 奇偶性看，而这题我们按 $x$ 的奇偶性看。

![](https://cdn.luogu.com.cn/upload/image_hosting/ij1ni2p2.png)

## 代码

为啥很多题解都过不去？因为更新的数据里，**障碍的坐标可能有相同的**。

这个也很容易处理，统计时保证不重复即可。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int R = 205, N = 114514, inf = 0x7f7f7f7f;
struct Edge {int now, nxt, w;} e[1919810];
int head[N], _head[N], cur = 1;
void ad(int u, int v, int w)
{
    e[++cur].now = v, e[cur].nxt = head[u], e[cur].w = w;
    head[u] = cur;
}
void add(int u, int v, int w) {ad(u, v, w), ad(v, u, 0);}
int s, t;
int dis[N]; bool vis[N];
bool bfs()
{
    queue <int> q;
    memset(vis, false, sizeof vis);
    q.push(s), vis[s] = true, dis[s] = 0, _head[s] = head[s];
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].now;
            if (vis[v] || !e[i].w) continue;
            vis[v] = true, dis[v] = dis[u] + 1, _head[v] = head[v];
            if (v == t) return true;
            q.push(v);
        }
    }
    return false;
}
int dfs(int u, int maxflow)
{
    if (u == t) return maxflow;
    int flow = 0;
    for (int i = _head[u]; i && flow < maxflow; i = e[i].nxt)
    {
        _head[u] = i;
        int v = e[i].now;
        if (dis[v] != dis[u] + 1 || !e[i].w) continue;
        int ww = dfs(v, min(maxflow - flow, e[i].w));
        if (!ww) dis[v] = -inf;
        e[i].w -= ww, e[i ^ 1].w += ww, flow += ww;
    }
    return flow;
}
int dinic()
{
    int ans = 0, flow;
    while (bfs())
        while (flow = dfs(s, inf))
            ans += flow;
    return ans;
}
int n, m, k; bool a[R][R];
int id(int x, int y) {return (x - 1) * m + y;}
const int dict[8][2] = {{1, 3}, {1, -3}, {-1, 3}, {-1, -3}, {3, 1}, {3, -1}, {-3, 1}, {-3, -1}};
int main()
{
    scanf("%d%d%d", &n, &m, &k);
    s = 0, t = n * m + 1;

    int sum = n * m;
    while (k--)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        if (!a[x][y]) sum--;
        a[x][y] = true;
    }
    for (int x = 1; x <= n; x++)
        for (int y = 1; y <= m; y++)
            if (x & 1) add(s, id(x, y), 1); //按行黑白染色
            else add(id(x, y), t, 1);
    for (int x = 1; x <= n; x++)
        for (int y = 1; y <= m; y++)
            if ((x & 1) && !a[x][y])
                for (int i = 0; i < 8; i++)
                {
                    int dx = x + dict[i][0], dy = y + dict[i][1];
                    if (dx < 1 || dx > n || dy < 1 || dy > m) continue;
                    if (a[dx][dy]) continue;
                    add(id(x, y), id(dx, dy), 1); 
                }
    cout << sum - dinic(); //最大独立集
    return 0;
}
```

希望能帮助到大家！

---

## 作者：诗乃 (赞：14)

对于10%的数据，枚举每个格子放或不放，复杂度O(2^(n^2)).

对于80%的数据，可以观察到，白格上的长脖子鹿只能跳到白格，黑格上的长脖子鹿只能跳到黑格，因此我们把黑、白格子分开考虑。若两个格子是“目”字的对角（能互相攻击到），则在他们对应的节点之间连边。容易发现，我们连出来的图中不存在奇环。因此，我们建出的图确实是一张二分图。

求上述二分图的最大独立集即可。

对于100%的数据，出题人在说明中说过考虑图的遍历顺序对效率影响。考虑匈牙利算法的实现过程，若当前点找到的匹配边是暂时没有匹配冲突，那么就可以直接匹配结束dfs，否则将进行复杂的增广。因此，从(x+3,x-1)开始(即下偏左)从下往上遍历可以减少冲突的概率，(上方的可匹配点被之前的点匹配的可能性较高。)，可以将复杂度降为O(能过)。

标程提供：朝田诗乃/X。

---

## 作者：VenusM1nT (赞：11)

似乎没有看到建模方式和我一样的dalao……斗胆来写一下

题目很明显，二分图最大权独立集，所以就是常见的建模方法，黑白染色，分别向超级源超级汇连边，然后把能攻击到的点分别连起来

如果攻击方式和马一样是$1*2$的话应该是按行列奇偶性连边，但这题的攻击方式是$1*3$，所以我们要按照**行奇偶性**连边，这也是这道题最特殊的地方

见代码

```cpp
#include<bits/stdc++.h>
#define inf 2147400000
using namespace std;
queue <int> q;
int cnt=1,fst[50005],nxt[500005],to[500005],w[500005],cur[50005];
int n,m,K,dep[50005],S,T;
int dx[]={0,3,3,1,1,-3,-3,-1,-1},dy[]={0,1,-1,3,-3,1,-1,3,-3};
int blk[205][205];
void AddEdge(int u,int v,int c)
{
    to[++cnt]=v;
    nxt[cnt]=fst[u];
    fst[u]=cnt;
    w[cnt]=c;
}
bool Bfs()
{
    memset(dep,0,sizeof(dep));
    q.push(S);
    dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=fst[u];i;i=nxt[i])
        {
            int v=to[i];
            if(!dep[v] && w[i])
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[T];
}
int Dfs(int u,int flow)
{
    if(u==T || !flow) return flow;
    int used=0;
    for(int i=cur[u];i;i=nxt[i])
    {
        cur[u]=i;
        int v=to[i];
        if(dep[v]==dep[u]+1 && w[i])
        {
            int fl=Dfs(v,min(flow,w[i]));
            if(fl)
            {
                used+=fl;
                flow-=fl;
                w[i]-=fl;
                w[i^1]+=fl;
                if(!flow) break;
            }
        }
    }
    return used;
}
int Dinic()//弧优化Dinic，不谈
{
    int sum=0;
    while(Bfs())
    {
        memcpy(cur,fst,sizeof(fst));
        sum+=Dfs(S,inf);
    }
    return sum;
}
int main()
{
    scanf("%d %d %d",&n,&m,&K);
    S=0;
    T=n*m+1;
    for(int i=1;i<=K;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        blk[x][y]=1;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int id=(i-1)*m+j;
            if(i&1)//按行奇偶性连边
            {
                AddEdge(S,id,1);
                AddEdge(id,S,0);
            }
            else
            {
                AddEdge(id,T,1);
                AddEdge(T,id,0);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(blk[i][j]) continue;
            int id=(i-1)*m+j;
            if(i&1)
            {
                for(int k=1;k<=8;k++)//把能攻击到的边连起来
                {
                    int nx=i+dx[k],ny=j+dy[k];
                    if(nx<1 || nx>n || ny<1 || ny>m || blk[nx][ny]) continue;
                    int nid=(nx-1)*m+ny;
                    AddEdge(id,nid,1);
                    AddEdge(nid,id,0);
                }
            }
        }
    }
    int ans=n*m-K-Dinic();//求解
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：7KByte (赞：7)

把题目抽象一下，就是在一个棋盘中，选择一些点，使这些点不能互相攻击，要使选择的点最多。  
将这转化成二分图问题，每个格子上的点对应二分图中的一个点，然后将不能一起放的点连边，那么答案就是最大独立集  
关键是如何将这些点分为两个点集，如果按照图中黑白染色来分，那么在同色点中就会有连边，途中就是，这样不符合二分图的定义  
晋国观察我们可以发现一个点的攻击范围中,列号-1,-3,+1,+3。那么我们可以考虑关于列号划分点集，偶数列属于$X$集，奇数列属于$Y$集，这样我们就能很好地将问题转化为二分图问题。


**二分图最大独立集=点数-最大匹配**

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next;
}e[1000000];
int h[50005],n,m,k,a[205][205],pop=0;
int dx[8]={-3,3,-3,3,-1,1,-1,1};
int dy[8]={1,1,-1,-1,3,3,-3,-3};
void add(int x,int y){
	pop++;
	e[pop].next=h[x];
	h[x]=pop;
	e[pop].to=y;
}
int f(int x,int y){
	return (x-1)*m+y;
}
int vis[40005],match[40005];
bool find(int p){
	for(int i=h[p];i;i=e[i].next){
		if(vis[e[i].to])continue;
		vis[e[i].to]=1;
		if(!match[e[i].to]||find(match[e[i].to])){
			match[e[i].to]=p;
			return true;
		}
	}
	return false;
} 
int main()
{
	memset(h,0,sizeof(h));
	scanf("%d%d%d",&n,&m,&k);
	memset(a,0,sizeof(a));
	int ans=n*m;
	for(int i=1;i<=k;i++){
		int x,y;scanf("%d%d",&x,&y);
		a[x][y]=1;
	}
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	    if(i%2==0)
	    if(!a[i][j])
	      for(int k=0;k<8;k++){
	      	int x=i+dx[k],y=j+dy[k];
	      	if(x>0&&y>0&&x<=n&&y<=m&&!a[x][y]){
	      		add(f(i,j),f(x,y));
			  }
		  }
	int sum=0;memset(match,0,sizeof(match));
	for(int i=1;i<=f(n,m);i++){
		memset(vis,0,sizeof(vis));
		if(find(i))
		  sum++;
	}
	printf("%d\n",ans-sum-k);
	return 0;
}
/*
8 7 5
1 1
5 4
2 3
4 7
8 3
*/
```

---

## 作者：mrsrz (赞：5)

二分图最大独立集。

首先，没有奇环的简单无向图一定是二分图。

接下来，我们只要把能攻击到的点对连上边即可。这是一张二分图。

证明：

长脖子鹿一共有8种走法，分别为$(+3,+1)$,$(+3,-1)$,$(+1,+3)$,$(+1,-3)$,$(-3,+1)$,$(-3,-1)$,$(-1,+3)$,$(-1,-3)$。

假设它在一个点上，8种走法分别走了$a,b,c,d,e,f,g,h$步，走回了出发点。

则必须满足$3(a+b-e-f)+(c+d-g-h)=0$，即行的变化量为0。

那么显然$a+b-e-f$和$c+d-g-h$同奇或同偶。

则$a+b+c+d+e+f+g+h$一定是个偶数。

用列的变化量也能得到同样的结论。

所以，连成的图一定只带偶环，而没有奇环。所以是个二分图。

然后我们要在二分图里选最多的点，使得两两没有连边。即二分图最大独立集。

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define inf 0x3fffffff
const int dx[]={3,3,1,1,-3,-3,-1,-1},dy[]={1,-1,3,-3,1,-1,3,-3};
int n,m,k,id[233][233],node,head[40004],T,lr[233][233],cnt=1,dep[40004],iter[40004];
struct edge{
	int to,nxt,cap;
}e[6666666];
inline void addedge(int u,int v){
	e[++cnt]=(edge){v,head[u],1};head[u]=cnt;
	e[++cnt]=(edge){u,head[v],0};head[v]=cnt;
}
void dfs(int x,int y,bool o){
	id[x][y]=++node;
	lr[x][y]=o;
	for(int i=0;i<8;++i){
		int fx=x+dx[i],fy=y+dy[i];
		if(fx>0&&fy>0&&fx<=n&&fy<=m){
			if(!id[fx][fy])dfs(fx,fy,!o);
			if(id[fx][fy]!=-1){
				if(o)addedge(id[fx][fy],id[x][y]);else
				addedge(id[x][y],id[fx][fy]);
			}
		}
	}
}
std::queue<int>q;
void bfs(){
	*dep=1;
	q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		if(e[i].cap&&!dep[e[i].to]){
			dep[e[i].to]=dep[u]+1;
			q.push(e[i].to);
		}
	}
}
int dfs(int u,int f){
	if(!f||u==T)return f;
	for(int&i=iter[u];i;i=e[i].nxt)
	if(e[i].cap&&dep[e[i].to]>dep[u]){
		int d=dfs(e[i].to,std::min(f,e[i].cap));
		if(d){
			e[i].cap-=d;
			e[i^1].cap+=d;
			return d;
		}
	}
	return 0;
}
int dinic(){
	for(int flow=0,f;;){
		memset(dep,0,sizeof dep);
		bfs();
		if(!dep[T])return flow;
		memcpy(iter,head,sizeof head);
		while(f=dfs(0,inf))flow+=f;
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;++i){
		int x,y;
		scanf("%d%d",&x,&y);
		id[x][y]=-1;
	}
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	if(!id[i][j])dfs(i,j,0);
	T=++node;
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	if(id[i][j]!=-1){
		if(lr[i][j])addedge(id[i][j],T);else
		addedge(0,id[i][j]);
	}
	printf("%d\n",n*m-k-dinic());
	return 0;
}
```

---

## 作者：KEBrantily (赞：3)

发现这张图有点眼熟，与[骑士共存问题](https://www.luogu.com.cn/problem/P3355)问题很像。

按照骑士共存问题的解法，对于图黑白染色后进行连边求最小割即可。

源点向每个白点、每个黑点向汇点都连容量为 $1$ 的边；

对于每个白点，从它向所能到达的黑点连容量无穷大的边。

这样跑出来的最大流也就是最小割，用总数减去最小割就是答案。

原理也比较简单，每个白点和它所连向的黑点肯定是不能同时放长脖子鹿的，所以赋值为无穷大是为了防止被删，而删去一条边是表示不选这个点。

但是做完发现并不对，这是为什么呢？

可以发现，在骑士共存问题这一题中，正常的行列奇偶性黑白染色可以完美地使每个白点到达的点都是黑点。

也就是说黑白染色的目的就是把点分为左右两部分，使得左边的点只向右边的点连边。

这一题中，由于长脖子鹿的攻击范围是 $1\times 3$ 的格子，所以那种染色方法并不行。但是我们还可以发现如果只按行奇偶性染色，使每一行都是一种颜色，也满足上面的条件。

另外注意会有重点，所以不能直接使用 $k$ 作为总数。

如此，问题便正式解决。

（采用了一种令人无法理解的加边方法，请见谅）

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 600010
#define maxm 70000000
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

bool vis[210][210];
int n,m,s,t,tot=1,all,k;
int val[210][210];
int id[210][210],now;
int Dis[maxn],cur[maxn],head[maxn];
struct edge{int fr,to,dis,nxt;}e[maxm];

int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

void add(int fr,int to,int dis){
    e[++tot]=(edge){fr,to,dis,head[fr]};head[fr]=tot;
    e[++tot]=(edge){to,fr,0,head[to]};head[to]=tot;
}

bool bfs(){
    memset(Dis,-1,sizeof Dis);
    queue<int> q;q.push(s);
    Dis[s]=0;cur[s]=head[s];
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to;
            if(Dis[to]==-1&&e[i].dis){
                q.push(to);
                Dis[to]=Dis[u]+1;
                cur[to]=head[to];
                if(to==t) return true;
            }
        }
    }
    return false;
}

int dfs(int u,int limit){
    if(u==t) return limit;int flow=0;
    for(int i=cur[u];i&&flow<limit;i=e[i].nxt){
        int to=e[i].to;cur[u]=i;
        if(Dis[to]==Dis[u]+1&&e[i].dis){
            int f=dfs(to,min(e[i].dis,limit-flow));
            if(!f)Dis[to]=-1;
            e[i].dis-=f;e[i^1].dis+=f;
            flow+=f;
        }
    }
    return flow;
}

int dinic(){
    int Maxflow=0,flow=0;
    while(bfs())
        while(flow=dfs(s,INF))
            Maxflow+=flow;
    return Maxflow;
}

bool judge2(int x,int y){
    return (x>=1&&x<=n&&y>=1&&y<=m);
}

signed main(){
    n=read();m=read();k=read();s=n*m+1;t=s+1;
    for(int i=1,fr,to;i<=k;i++){fr=read();to=read();val[fr][to]=1;}
    for(int i=1;i<=n;i+=2)for(int j=1;j<=m;j++)vis[i][j]=1;k=0;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++) id[i][j]=++now;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
        if(val[i][j]) k++;
        if(vis[i][j]&&!val[i][j]){
            add(s,id[i][j],1);
            if(!val[i-3][j-1]&&judge2(i-3,j-1)) add(id[i][j],id[i-3][j-1],INF);
            if(!val[i-1][j-3]&&judge2(i-1,j-3)) add(id[i][j],id[i-1][j-3],INF);
            if(!val[i+3][j-1]&&judge2(i+3,j-1)) add(id[i][j],id[i+3][j-1],INF);
            if(!val[i+1][j-3]&&judge2(i+1,j-3)) add(id[i][j],id[i+1][j-3],INF);
            if(!val[i-3][j+1]&&judge2(i-3,j+1)) add(id[i][j],id[i-3][j+1],INF);
            if(!val[i-1][j+3]&&judge2(i-1,j+3)) add(id[i][j],id[i-1][j+3],INF);
            if(!val[i+3][j+1]&&judge2(i+3,j+1)) add(id[i][j],id[i+3][j+1],INF);
            if(!val[i+1][j+3]&&judge2(i+1,j+3)) add(id[i][j],id[i+1][j+3],INF);
        }
        else if(!val[i][j]){add(id[i][j],t,1);}
    }
    int ans=dinic();all=n*m;
    printf("%d\n",all-k-ans);
    return 0;
}
```


---

## 作者：OldVagrant (赞：2)

## 题意
给定一个 $n\times m$ 的网格图，位于 $(x,y)$ 的棋子能攻击到 $(x\pm 1,y\pm 3)$ 和 $(x\pm 3,y\pm 1)$ 的位置（若超出网格图范围则无法攻击），有 $k$ 个地方不能放棋子（**不保证给定的 $k$ 个地方互不相同**），求最多能放多少个互不攻击的棋子。   
$1\le n,m \le 200$
## Solution
前置知识：二分图最大独立集   
这个题和 [P3355](https://www.luogu.com.cn/problem/P3355) 非常像，只不过攻击范围变了，那么用那个题的直接让相邻的格子不同色的方法显然就不可行了，因为这样的话两个同色的格子之间也可能连边了（良心出题人给的示例图里面就有），考虑换一种染色方式。  
观察每个棋子的攻击范围，可以发现 $(x,y)$ 能攻击到的格子所在的行的奇偶性一定与 $x$ 不同，于是我们就可以按照行的奇偶性去染色，比如编号为奇数的行全部染成黑色，剩下的是白色，然后跑二分图最大独立集即可。按列的奇偶性来染色应该也是可以的。   
然后注意一下良心出题人给的第二个提示，图的遍历顺序对运行速度有很大的影响。显然，如果你从整个网格图的左上开始染色和连边，那么每个点能攻击到的 8 个点中越靠上的点越有可能之前被匹配过，此时匈牙利算法就会再去递归，从而使得运行速度大幅降低，所以我们应当从最下面的 $(x+3,y\pm 1)$ 开始，遍历这个点的出边。  
最后注意一个坑点，就是不保证给定的 $k$ 个地方互不相同，如果二分图点数按照 $n\times m-k$ 来算的话就会 ```WA```  四个点，这里加一点判断就好。
## Code
```c
#include <bits/stdc++.h>
using namespace std;
int head[40001],ne[160001],to[160001],ecnt,now=1,match[40001],la[40001];
bool a[201][201],isb[40001];
const int LEN=1<<21;
char BUF[LEN],*Pin,*Pin_last,PUF[LEN],*Pout=PUF,*Pout_last=PUF+LEN-1;
char gc(){
	return Pin==Pin_last&&(Pin_last=(Pin=BUF)+fread(BUF,1,LEN,stdin),Pin==Pin_last)?EOF:*Pin++;
}
int read(){
	int x=0;
	char ch=gc();
	while(ch<48||ch>57) ch=gc();
	while(ch>47&&ch<58) x=x*10+ch-48,ch=gc();
	return x;
}
void ae(int x,int y){
	to[++ecnt]=y,ne[ecnt]=head[x],head[x]=ecnt;
}
bool dfs(int x){//匈牙利算法，这里采用了时间戳的优化，不用每次清空vis数组，效果相同
	for(int i=head[x];i;i=ne[i]){
		int y=to[i];
		if(la[y]!=now){
			la[y]=now;
			if(!match[y]||dfs(match[y])){
				match[y]=x;
				return 1;
			}
		}
	}return 0;
}
signed main(){
	int n=read(),m=read(),k=read(),tot=n*m,nn=tot,ans=0;
	while(k--){
		int x=read(),y=read();
		if(!a[x][y]) a[x][y]=1,tot--;//注意这里的判断
	}for(int i=1;i<=n;i+=2){
		for(int j=1,k=i*m+1-m;j<=m;j++,k++){
			if(a[i][j]) continue;
			isb[k]=1;
         //注意下面加边的顺序，邻接表存图的话遍历时倒序的，所以这样加，邻接矩阵的话就是把我这个翻过来即可
			if(j>1&&i>3&&!a[i-3][j-1]) ae(k,k-3*m-1);
			if(j<m&&i>3&&!a[i-3][j+1]) ae(k,k-3*m+1);
			if(j>3&&i>1&&!a[i-1][j-3]) ae(k,k-3-m);
			if(j+2<m&&i>1&&!a[i-1][j+3]) ae(k,k-m+3);
			if(j>3&&i<n&&!a[i+1][j-3]) ae(k,k+m-3);
			if(j+2<m&&i<n&&!a[i+1][j+3]) ae(k,k+m+3);
			if(j>1&&i+2<n&&!a[i+3][j-1]) ae(k,k+3*m-1);
			if(j<m&&i+2<n&&!a[i+3][j+1]) ae(k,k+3*m+1);
		}
	}for(int i=1;i<=nn;i++,now++) if(isb[i]&&dfs(i)) ans++;//如果是黑点并且匹配成功则更新最大匹配数
	printf("%d",tot-ans);//二分图总点数减去最大匹配数即为最大独立集大小
	return 0;
}
```


---

## 作者：RuntimeErr (赞：2)

基本上是 [P3355 骑士共存问题](https://www.luogu.com.cn/problem/P3355) 的双倍经验。但唯一的区别就是走的是“目”字而非“日”字。

![](https://cdn.luogu.com.cn/upload/pic/37260.png)

我们通过观察发现，一个格点与其所能到达的另一个格点的横（或纵）坐标的**奇偶性相反**，那么我们可以按行（或列）的奇偶性将这些格点分成两个集合，这样就成了个**二分图**。其中让左部点向它能到达的右部点连边。我们要从两个集合中选出一些点，使得选出的不同集合中的点之间没有关系（即没连边，也就成了**独立集**），求最大点集，这就成了**最大独立集**问题。

这里先给出一个结论，在**二分图**里面，**最大独立集 = 总点数 - 最小点覆盖 = 总点数 - 最大匹配**。下面给出证明：

**最小点覆盖**的定义是：二分图中的每条边至少有一个端点在该点集中的最小点集。

如果去掉了这些点，剩下的点之间就没有了任何关系（每条边的端点都不存在了），就成了**独立集**。由于去掉的点集最小，那么剩下的点集就是**最大独立集**。所以，**最大独立集 = 总点数 - 最小点覆盖**。

那又为什么有 **最小点覆盖 = 最大匹配** 呢？这里就要引出 Konig 定理：

首先，最小点覆盖一定**大于等于**最大匹配。假设最大匹配为 $n$，则这 $n$ 条边一定互不相交，光覆盖这些边就要 $n$ 个点，故成立。

其次，最小点覆盖一定**小于等于**最大匹配。因为最小点覆盖中的点一定能找到至少一条**只有一个端点**在点集中的边，否则该点没必要被覆盖，与最小点覆盖矛盾。因此，只要点集中的每个点都选择这样一条边，一定能转化成一个匹配数与点数相等的匹配方案，故成立。

综上， **最小点覆盖 = 最大匹配**。

最大匹配可以用匈牙利算法或 Dinic 求得，注意有些位置不能放棋子，且**不保证禁止放置的格子互不相同**，故答案还需减去不能放的位置数。

### Code:

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
template <typename T>
inline void read(T& r) {
    r=0;bool w=0; 
    char ch=getchar();
    while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
    while(ch>='0'&&ch<='9') r=(r<<3)+(r<<1)+(ch^48), ch=getchar();
    r=w?-r:r;
}

const int N=1e6+10,M=4e6+10,inf=0x7ffffff;
#define id(i,j) (i-1)*m+j

int n,m,k,s,t,maxflow,tot;
int h[N],e[M],ne[M],w[M],idx=1;
int dep[N],cur[N];
queue<int>q;
int f[8][2]={{-1,-3},{-3,-1},{-3,1},{-1,3},{1,3},{3,1},{3,-1},{1,-3}};
bool g[210][210];

inline void add(int a,int b){
    e[++idx]=b;ne[idx]=h[a];w[idx]=1;h[a]=idx;
    e[++idx]=a;ne[idx]=h[b];w[idx]=0;h[b]=idx;
}

bool bfs(){
    for(int i=1;i<=t;++i)dep[i]=0,cur[i]=h[i];
    dep[s]=1;q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=h[u],v;i;i=ne[i]){
            v=e[i];
            if(w[i]&&!dep[v]){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t];
}
int dinic(int u,int in){
    if(u==t||!in)return in;
    int out=0;
    for(int i=cur[u],v;i;i=ne[i]){
        cur[u]=i;v=e[i];
        if(w[i]&&dep[v]==dep[u]+1){
            int res=dinic(v,min(in,w[i]));
            in-=res;out+=res;
            w[i]-=res;w[i^1]+=res;
        }
        if(!in)break;
    }
    if(!out)dep[u]=-1;
    return out;
}

int main(){
    #ifdef LOCAL
        freopen("std.in","r",stdin);
        freopen("my.out","w",stdout);
    #endif
    read(n);read(m);read(k);
    tot=n*m;s=n*m+1,t=s+1;maxflow=0;
    for(int i=1,x,y;i<=k;++i){
        read(x),read(y);
        if(!g[x][y])--tot;
        g[x][y]=true;
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(g[i][j])continue;
            if(i&1){
                add(s,id(i,j));
                for(int k=0;k<8;++k){
                    int x=i+f[k][0],y=j+f[k][1];
                    if(x<1||x>n||y<1||y>m||g[x][y])continue;
                    add(id(i,j),id(x,y));
                }
            }
            else add(id(i,j),t);
        }
    }
    while(bfs())maxflow+=dinic(s,inf);
    printf("%d\n",tot-maxflow);
    return 0;
}
```


---

## 作者：Erusel (赞：2)

这是二分图中比较典型的建模模型：**棋盘模型**

类似题目还有[P3355 骑士共存问题](https://www.luogu.org/problem/P3355)，[P3882 [JLOI2008]将军](https://www.luogu.org/problem/P3882)等

这类模型可以总结为：在棋盘上给定一些能放的位置，问你最多放几个棋子，

使得棋子之间互相不攻击

通常我们把它转换成二分图问题，利用匈牙利算法或者网络流进行求解

---

在本题中，长脖子鹿的走法跟马有几分相似，

我们可以用所有能放置的点构造出一副二分图，根据行的奇偶性进行分组，

把不能一起放的点进行连边，求出该图的最大独立集

利用长脖子鹿每一步走$(\pm3,\pm1)$的性质，可以证明这样构造出来的图没有奇环

**因为二分图的最大独立集=总点数-最大匹配**

所以我们可以在多项式时间复杂度内进行求解

Code:

```
#include<bits/stdc++.h>

#define rd(x) x=read()

#define N 205

using namespace std;

int n,m,k;

struct E{
	int to,nxt;
}e[N*N*20];
int head[N*N],vis[N*N],rmatch[N*N];
int f[N][N];
int tot;

const int dir[2][8]={{-3,3,-3,3,-1,1,-1,1},{1,1,-1,-1,3,3,-3,-3}};

inline void addEdge(int u,int v){e[++tot].to=v,e[tot].nxt=head[u],head[u]=tot;}

inline bool check(int x,int y){return x>0&&y>0&&x<=n&&y<=m&&!f[x][y];}

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}

bool dfs(int u)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(vis[v])continue;
		vis[v]=1;
		if(!rmatch[v]||dfs(rmatch[v]))
		{
			rmatch[v]=u;
			return 1;
		}
	}
	return 0;
}

int hungary()
{
	int ans=0;
	for(int i=1;i<=n*m;i++)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	return ans;
}

int main()
{
	rd(n),rd(m),rd(k);
	for(int i=0;i<k;i++){int u,v;rd(u),rd(v),f[u][v]=1;}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(i&1||f[i][j])continue;
			for(int k=0;k<8;k++)
			{
				int dx=i+dir[0][k],dy=j+dir[1][k];
	        		if(check(dx,dy))addEdge((i-1)*m+j,(dx-1)*m+dy);
			}
		}
	cout<<n*m-hungary()-k<<endl;
  	return 0;
}
```
---

在本题中，我们是把不能相互攻击的点连边，

如果在边数过多导致超时或者炸空间的时候，

我们可以巧妙利用题目的性质，比如将所在棋子的行列（甚至还有斜列）进行连边，

从而优化边数，读者可以去看一下[P3882 [JLOI2008]将军](https://www.luogu.org/problem/P3882)，

在那题中这个建模方式就充分体现出来了


---

## 作者：Coros_Trusds (赞：1)

建议先行完成 P4304。

# 题目大意

如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）

![avatar](https://cdn.luogu.com.cn/upload/pic/37260.png)

给定一个 $n\times m$ 的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。

# 题目分析

这道题不能通过行列坐标来黑白染色，因为他们的颜色都相同。例如，观察上图，长脖子鹿的颜色为白色，可达格子也是白色，而我们黑白染色就是为了把这当前地点和可达点区分开，故不满足条件。

通过观察我们得到不妨直接通过行坐标的奇偶性来染色。

然后就变成了一个二分图最大独立集问题，首先我们考虑到如果将两个可以互相攻击的位置连边，那么题目中所要求的就是选出最多的点，使得他们两两之间不存在边。答案就是点的总数减去最大匹配数。其他的都和 P4304 很像。

# 代码

```cpp
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	#ifndef ONLINE_JUDGE
	#define getc getchar
	#endif
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getc();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getc();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getc();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const short dx[] = {-3,-3,-1,-1,1,1,3,3};
const short dy[] = {-1,1,-3,3,-3,3,-1,1};
const int N = 505;
struct Graph {
	int v,nxt;
} gra[N * N];
int head[N * N],mat[N * N],vis[N * N];
bool maps[N][N];
int n,m,k,idx,nowidx;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline int getid(int x,int y) {
	return (x - 1) * m + y;
}
inline int getcol(int x,int y) {
	return x % 2;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx) {
			vis[v] = nowidx;
			if (!mat[v] || dfs(mat[v])) {
				mat[v] = now;
				return true;
			}
		}
	}
	return false;
}
int main(void) {
	n = read(),m = read(),k = read();
	for (register int i = 1;i <= k; ++ i) {
		int x = read(),y = read();
		maps[x][y] = true;
	}
	int all = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (maps[i][j]) continue;
			all ++;
			if (getcol(i,j) == 1) continue;
			for (register int k = 0;k < 8; ++ k) {
				int nx = i + dx[k],ny = j + dy[k];
				if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && !maps[nx][ny] && getcol(nx,ny) == 1) {
					add(getid(i,j),getid(nx,ny));
				}
			}
		}
	}
	int ans = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= m; ++ j) {
			if (maps[i][j] || getcol(i,j) == 1) continue;
			nowidx ++;
			if (dfs(getid(i,j))) ans ++;
		}
	}
	printf("%d\n",all - ans);
	
	return 0;
}
```

---

## 作者：Albedo (赞：1)

## $\texttt{Introduction}$

这道题有什么存在的意义吗？和 $\texttt{P4304}$ 有什么区别？

## $\texttt{Solution}$

首先我们考虑到如果将两个可以互相攻击的位置连边，那么题目中所要求的就是选出最多的点，使得他们两两之间不存在边，这个问题的实质就是最大独立集。


我们通过观察题目中给的那张图可以发现，一个格点与其所能到达的另一个格点的横（或纵）坐标的奇偶性相反，也就是说我们连边后得到的图是一张二分图。

那么这时候我们就可以运用经典结论:**最大独立集=总点数-最大匹配**

然后这道题就基本做完了。


具体的实现方法就是我们先将不能选的点从点集中去除，然后对于点集中存在的点进行连边，然后黑白染色，将黑点视作左部点，然后进行二分图最大匹配即可。

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int di[8][2]={{-1,-3},{-3,-1},{1,-3},{3,-1},{-1,3},{-3,1},{1,3},{3,1}};
inline int read()			
{
  int x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
bool uu[1000000],exist[1000000],visit[1000000],edge[300][300];
int ok[1000][1000],e3[2000000],e4[2000000],e1[2000000],e2[2000000],a[2000000],b[2000000],d[2000000],match[2000000];
int K,xx,yy,k,xu,yu,xv,yv,ans3,ans4,ans2,ans1,sum,j,cnt,n,m,x,y,i,ans,color[1000000];
string s;
void add(int x,int y)
{
	cnt++;a[cnt]=y;b[cnt]=d[x];d[x]=cnt;
}
bool check(int x)
{
	int i;
	for (i=d[x];i;i=b[i])
	    if (visit[a[i]]==false)
	         {
	         	visit[a[i]]=true;
	         	if ((match[a[i]]==0)||(check(match[a[i]])))
	         	     {
	         	     	match[a[i]]=x;
	         	     	return true;
					  }
			 }
	return false;
}
void sc(int x,int y)
{
	if (color[x]!=0) return;
	color[x]=y;
	int i;
	for (i=d[x];i;i=b[i])
	     sc(a[i],3-y);
}
int main()
{
	cin>>n>>m>>K;
    for (i=1;i<=K;i++)
         {
         	   cin>>x>>y;
         	   ok[x][y]=1;
		 }
	for (i=1;i<=n;i++)
	   for (j=1;j<=m;j++)
	       if (ok[i][j]==0)
	           {
	           	x=(i-1)*m+j;
	           	   for (k=0;k<8;k++)
	           	       {
	           	       	xx=i+di[k][0];yy=j+di[k][1];
	           	       	if ((xx>=1)&(xx<=n)&(yy>=1)&(yy<=m))
	           	       	      if (ok[xx][yy]==0)
	           	       	          {
	           	       	          y=(xx-1)*m+yy;
								  add(x,y);	
										}
						  }
			   }
	for (i=1;i<=n*m;i++)
	  if (ok[(i-1)/m+1][(i-1)%m+1]==0)
	     if (color[i]==0)
	        sc(i,1);
    int LGCZYY=0;
	for (i=1;i<=n*m;i++)
	  if (ok[(i-1)/m+1][(i-1)%m+1]==0)
	     {
	     if (color[i]==1)
	     {
	     	for (j=1;j<=n*m;j++) visit[j]=false;
	     	if (check(i)) ans++;
	      }
	    }
	else LGCZYY++;
	printf("%d\n",n*m-ans-LGCZYY);
	return 0;
}
```


---

## 作者：raincity (赞：1)

## 分析1
这道题吗，有点玄学。

首先，我们可以从题目看到这张图：

![](https://cdn.luogu.com.cn/upload/pic/37260.png)

观察~~亿~~一下，发现长脖子鹿在白色格子，也只能跳到白色格子。

然后~~自然而然地~~想到 [ACWing 上的一道题](https://www.acwing.com/problem/content/description/374/)。

那道题是个二分图匹配，但是这里不同。这道题中放一个长脖子鹿会影响最多 8 个位置，而那题只影响 2 个。这道题应该用最大独立集，原因显然：让一个格子和能攻击到的格子连边，要求有边的两个格子不能都放，也就是求这个图的**最大独立集**。

任意图的最大独立集是一个 NP 问题，但是这道题不是。长脖子鹿走一步，行列都会 $\pm t, t\in{1, 3}$，是一个奇数，所以**走奇数步不可能回到原位**，说明这是一个**二分图**。二分图最大独立集大小=点数-最大匹配边数。~~留做习题答案略，读者自证不难。~~不难写出：

## 代码1（80pts）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 205, M = N * N, d[8][2] = {{-3, -1}, {-3, 1}, {-1, -3}, {-1, 3}, {3, -1}, {3, 1}, {1, -3}, {1, 3}};
int match[M], dfn[M], id[N][N], t, n, m, DFN, cnt;
vector <int> G[M];
char flag[N][N];

__attribute__ ((always_inline)) void Edge(int x1, int y1, int x2, int y2) {
	if (x2 < 1 || x2 > n || y2 < 1 || y2 > m || flag[x1][y1] || flag[x2][y2])
		return;
	G[id[x1][y1]].push_back(id[x2][y2]);
	//	printf("Edge\n");
}

bool dfs(int cur) {
	for (int i = 0, siz = G[cur].size(); i < siz; i++) {
		int to = G[cur][i];
		if (dfn[to] == DFN)
			continue;
		dfn[to] = DFN;
		if (!match[to] || dfs(match[to])) {
			match[to] = cur;
			return true;
		}
	}
	return false;
}

int main() {
	cin >> n >> m >> t;
	while (t--) {
		int x, y;
		cin >> x >> y;
		if (!flag[x][y])
			flag[x][y] = 1, cnt++;
	}
	for (int i = 1; i <= n; i++) {
		id[i][0] = id[i - 1][m];
		for (int j = 1; j <= m; j++) id[i][j] = id[i][j - 1] + 1/*, printf("id[%d][%d] = %d\n", i, j, id[i][j])*/;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0; k < 8; k++)
				Edge(i, j, i + d[k][0], j + d[k][1]);[j]].begin(), G[id[i][j]].end());
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (flag[i][j] == 0) {
				DFN++;
//				printf("dfs(%d, %d)\n", i, j);
				if (dfs(id[i][j]))
					ans++/*, printf("succeed: i = %d, j = %d\n", i, j)*/;
			}
	/*
    for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			printf("match[%d][%d] = %d\n", i, j, match[id[i][j]]);
	*/
	cout << n * m - ans / 2 - cnt << endl;
	return 0;
}

```

## 分析2

为什么呢？

这份代码的 **最坏** 时间复杂度为 $O(n^4)$，带上一个 8 的常数，可以~~被新年第一毒瘤出题人~~卡，但是怎么 A 掉呢？

我们要利用匈牙利算法的玄学性质，让这份代码跑不满就行。方法介绍两种。

### 随机化
> 随机化算法没有钱途。

这也是我自己想出来的办法，果然我还是只会乱搞。[record ](https://www.luogu.com.cn/record/47570249)

显然我们可以在代码的循环顺序上搞事情。

生成一个 $1 \sim n$ 的随机数列 $p$，一个 $1 \sim m$ 的随机数列 $q$，组合成 $n \times m$ 个位置跑匈牙利就行。

### 代码2
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 205, M = N * N, d[8][2] = {{-3, -1}, {-3, 1}, {-1, -3}, {-1, 3}, {3, -1}, {3, 1}, {1, -3}, {1, 3}};
int match[M], dfn[M], id[N][N], t, n, m, DFN, cnt, p[N], q[N];
vector <int> G[M];
char flag[N][N];

__attribute__ ((always_inline)) void Edge(int x1, int y1, int x2, int y2) {
	if (x2 < 1 || x2 > n || y2 < 1 || y2 > m || flag[x1][y1] || flag[x2][y2])
		return;
	G[id[x1][y1]].push_back(id[x2][y2]);
	//	printf("Edge\n");
}

bool dfs(int cur) {
	for (int i = 0, siz = G[cur].size(); i < siz; i++) {
		int to = G[cur][i];
		if (dfn[to] == DFN)
			continue;
		dfn[to] = DFN;
		if (!match[to] || dfs(match[to])) {
			match[to] = cur;
			return true;
		}
	}
	return false;
}

int main() {
	cin >> n >> m >> t;
	while (t--) {
		int x, y;
		cin >> x >> y;
		if (!flag[x][y])
			flag[x][y] = 1, cnt++;
	}
	for (int i = 1; i <= n; i++) {
		id[i][0] = id[i - 1][m];
		for (int j = 1; j <= m; j++) id[i][j] = id[i][j - 1] + 1/*, printf("id[%d][%d] = %d\n", i, j, id[i][j])*/;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0; k < 8; k++)
				Edge(i, j, i + d[k][0], j + d[k][1]);
	int ans = 0;
	for (int i = 1; i <= n; i++) p[i] = i;
	for (int i = 1; i <= m; i++) q[i] = i;
	random_shuffle(p + 1, p + n + 1), random_shuffle(q + 1, q + m + 1);
	for (int x = 1, i = p[1]; x <= n; x++, i = p[x])
		for (int y = 1, j = q[1]; y <= m; y++, j = q[y])
			if (flag[i][j] == 0) {
				DFN++;
//				printf("dfs(%d, %d)\n", i, j);
				if (dfs(id[i][j]))
					ans++/*, printf("succeed: i = %d, j = %d\n", i, j)*/;
			}
	/*
    for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			printf("match[%d][%d] = %d\n", i, j, match[id[i][j]]);
	*/
	cout << n * m - ans / 2 - cnt << endl;
	return 0;
}

```

于是这道题被艹过去了，Hooray！

### 更改加边顺序
也是 std 解法。

std 好像比随机化更加玄学(bushi

标程是这么说的：

> 对于100%的数据，出题人在说明中说过考虑图的遍历顺序对效率影响。考虑匈牙利算法的实现过程，若当前点找到的匹配边是暂时没有匹配冲突，那么就可以直接匹配结束dfs，否则将进行复杂的增广。因此，从(x+3,x-1)开始(即下偏左)从下往上遍历可以减少冲突的概率，(上方的可匹配点被之前的点匹配的可能性较高。)，可以将复杂度降为O(能过)。

话说怎么过的我也不知道，怎么想到的我也不知道，但是出题人就是想到了并过了，跑得比我的快 2 倍 /dk

原理是尽量让匈牙利算法找增广路的时候搜索层数少一些，然后就跑的飞快。

### 代码3
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 205, M = N * N, d[8][2] = {{3, -1}, {-3, -1}, {-1, -3}, {3, 1}, {1, -3}, {-3, 1}, {-1, 3}, {1, 3}};
int match[M], dfn[M], id[N][N], t, n, m, DFN, cnt;
vector <int> G[M];
char flag[N][N];

__attribute__ ((always_inline)) void Edge(int x1, int y1, int x2, int y2) {
	if (x2 < 1 || x2 > n || y2 < 1 || y2 > m || flag[x1][y1] || flag[x2][y2])
		return;
	G[id[x1][y1]].push_back(id[x2][y2]);
	//	printf("Edge\n");
}

bool dfs(int cur) {
	for (int i = 0, siz = G[cur].size(); i < siz; i++) {
		int to = G[cur][i];
		if (dfn[to] == DFN)
			continue;
		dfn[to] = DFN;
		if (!match[to] || dfs(match[to])) {
			match[to] = cur;
			return true;
		}
	}
	return false;
}

int main() {
    srand(time(0));
	cin >> n >> m >> t;
	while (t--) {
		int x, y;
		cin >> x >> y;
		if (!flag[x][y])
			flag[x][y] = 1, cnt++;
	}
	for (int i = 1; i <= n; i++) {
		id[i][0] = id[i - 1][m];
		for (int j = 1; j <= m; j++) id[i][j] = id[i][j - 1] + 1/*, printf("id[%d][%d] = %d\n", i, j, id[i][j])*/;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0; k < 8; k++)
				Edge(i, j, i + d[k][0], j + d[k][1]);
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (flag[i][j] == 0) {
				DFN++;
//				printf("dfs(%d, %d)\n", i, j);
				if (dfs(id[i][j]))
					ans++/*, printf("succeed: i = %d, j = %d\n", i, j)*/;
			}
	/*
    for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			printf("match[%d][%d] = %d\n", i, j, match[id[i][j]]);
	*/
	cout << n * m - ans / 2 - cnt << endl;
	return 0;
}

```

## 分析3

如果结合 std 和随机化呢？

跑的更快！

不要问我为什么用 20081231 作随机种子。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 205, M = N * N, d[8][2] = {{3, -1}, {-3, -1}, {-1, -3}, {3, 1}, {1, -3}, {-3, 1}, {-1, 3}, {1, 3}};
int match[M], dfn[M], id[N][N], t, n, m, DFN, cnt, p[N], q[N];
vector <int> G[M];
char flag[N][N];

__attribute__ ((always_inline)) void Edge(int x1, int y1, int x2, int y2) {
	if (x2 < 1 || x2 > n || y2 < 1 || y2 > m || flag[x1][y1] || flag[x2][y2])
		return;
	G[id[x1][y1]].push_back(id[x2][y2]);
	//	printf("Edge\n");
}

bool dfs(int cur) {
	for (int i = 0, siz = G[cur].size(); i < siz; i++) {
		int to = G[cur][i];
		if (dfn[to] == DFN)
			continue;
		dfn[to] = DFN;
		if (!match[to] || dfs(match[to])) {
			match[to] = cur;
			return true;
		}
	}
	return false;
}

int main() {
    srand(20081231);
	cin >> n >> m >> t;
	while (t--) {
		int x, y;
		cin >> x >> y;
		if (!flag[x][y])
			flag[x][y] = 1, cnt++;
	}
	for (int i = 1; i <= n; i++) {
		id[i][0] = id[i - 1][m];
		for (int j = 1; j <= m; j++) id[i][j] = id[i][j - 1] + 1/*, printf("id[%d][%d] = %d\n", i, j, id[i][j])*/;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0; k < 8; k++)
				Edge(i, j, i + d[k][0], j + d[k][1]);
	int ans = 0;
	for (int i = 1; i <= n; i++) p[i] = i;
	for (int i = 1; i <= m; i++) q[i] = i;
	random_shuffle(p + 1, p + n + 1), random_shuffle(q + 1, q + m + 1);
	for (int x = 1, i = p[1]; x <= n; x++, i = p[x])
		for (int y = 1, j = q[1]; y <= m; y++, j = q[y])
			if (flag[i][j] == 0) {
				DFN++;
//				printf("dfs(%d, %d)\n", i, j);
				if (dfs(id[i][j]))
					ans++/*, printf("succeed: i = %d, j = %d\n", i, j)*/;
			}
	/*
    for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			printf("match[%d][%d] = %d\n", i, j, match[id[i][j]]);
	*/
	cout << n * m - ans / 2 - cnt << endl;
	return 0;
}

```

## 效率（不开O2）
* 随机化：813ms
* 更改加边顺序：415ms
* 都使用：377ms

#### THE END

---

## 作者：_121017_ (赞：1)

其实，说实话，个人认为这题比另外两道紫题都恶心。

# 思路
因为这道题不能用黑白染色法，所以我们按照行的奇偶性来标号。

这样为什么是对的呢？其实我们不难发现，长脖子鹿的攻击范围行上的移动无非就 $1$，$-1$，$3$，$-3$ 四种，仔细观察就会发现，**它们都是奇数**，也就是说，只有奇数行上的点攻击得到偶数行上的点。

然后我们交上去代码，发现一直 $60$ 分，这就是这道题的坑点所在了，**因为题目并没有说没有重复的障碍**，所以，我们必须得统计一遍实际的障碍数量。
# code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define N 5000005
#define INF 0x3f3f3f3f
using namespace std;
int cnt=1,head[N],to[N],w[N],next[N],deep[N];
int maxflow,used,gap[N];
int n,m,s,t,k;
bool o[N];
queue<int>q;
int dx[8]={1,3,1,3,-1,-3,-1,-3};
int dy[8]={3,1,-3,-1,3,1,-3,-1};
void add(int u,int v,int c){
	cnt++;
	to[cnt]=v;
	w[cnt]=c;
	next[cnt]=head[u];
	head[u]=cnt;
}
void bfs(){
	memset(gap,0,sizeof(gap));
	memset(deep,-1,sizeof(deep));
	q.push(t);
	deep[t]=0;
	gap[0]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=next[i]){
			int v=to[i];
			if(deep[v]==-1){
				deep[v]=deep[u]+1;
				gap[deep[v]]++;
				q.push(v);
			}
		}
	}
	return;
}
int dfs(int u,int flow){
	if(u==t){
		maxflow+=flow;
		return flow;
	}
	int used=0;
	for(int i=head[u];i;i=next[i]){
		int v=to[i];
		if(w[i]&&deep[v]+1==deep[u]){
			int quan=dfs(v,min(w[i],flow-used));
			if(quan){
				w[i]-=quan;
				w[i^1]+=quan;
				used+=quan;
			}
			if(flow==used) return used;
		}
	}
	--gap[deep[u]];
	if(gap[deep[u]]==0){
		deep[s]=n*m+1;
	}
	deep[u]++;
	gap[deep[u]]++;
	return used;
}
int ISAP(){
	maxflow=0;
	bfs();
	while(deep[s]<n*m){
		dfs(s,INF);
	}
	return maxflow;
}
signed main(){
	cin>>n>>m>>k;
	s=n*m+1;
	t=s+1;
	int rp=0;
	for(int i=1;i<=k;i++){
		int u,v;
		cin>>u>>v;
		if(!o[(u-1)*m+v]){
			rp++;//祝你rp++
		}
		o[(u-1)*m+v]=1;
	}
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=m;j++){
			if(i&1){
				add(s,(i-1)*m+j,1);
				add((i-1)*m+j,s,0);
			}else{
				add((i-1)*m+j,t,1);
				add(t,(i-1)*m+j,0);
			}
		}
	}
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=m;j++){
			if(!o[(i-1)*m+j]&&(i&1)){
				for(ri k=0;k<8;k++){
					int u=i+dx[k],v=j+dy[k];
					if(u>0&&v>0&&u<=n&&v<=m&&!o[(u-1)*m+v]){
						add((i-1)*m+j,(u-1)*m+v,1);
						add((u-1)*m+v,(i-1)*m+j,0);
					}
				}
			}
		}
	}
	cout<<n*m-rp-ISAP();
	return 0;
}
```


---

## 作者：zhenglier (赞：1)

这题其实和[P3355 骑士共存问题](https://www.luogu.org/problemnew/show/P3355)差不多，但这题的建图比较恶心。

这题虽然不能用奇偶性建图，但很明显这题也可以建成一个二分图。所以我们用一个类似并查集的思想来把点划分在两端。
```cpp
    memset(ok,-1,sizeof ok);
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=m;++j){
    		if(ok[i][j]==-1)ok[i][j]=1;
            for(int kk=1;kk<=8;++kk){
                int nx=i+dx[kk],ny=j+dy[kk];
                if(nx<1||nx>n||ny<1||ny>m)continue;
                ok[nx][ny]=ok[i][j]^1;
            }
		}
	}
```
然后就可以愉快的建图跑最大流了。

代码

```cpp
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=k;++i){
        int x,y;
        scanf("%d%d",&x,&y);
        mp[x][y]=1;
    }b=0,e=n*n+1;
    memset(ok,-1,sizeof ok);
    for(int i=1;i<=n;++i){
    	for(int j=1;j<=m;++j){
    		if(ok[i][j]==-1)ok[i][j]=1;
            for(int kk=1;kk<=8;++kk){
                int nx=i+dx[kk],ny=j+dy[kk];
                if(nx<1||nx>n||ny<1||ny>m)continue;
                ok[nx][ny]=ok[i][j]^1;
            }
		}
	}
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(mp[i][j])continue;
            if(ok[i][j]){
                add(b,(i-1)*m+j,1);
                add((i-1)*m+j,b,0);
                for(int kk=1;kk<=8;++kk){
                    int nx=i+dx[kk],ny=j+dy[kk];
                    if(nx<1||nx>n||ny<1||ny>m||mp[nx][ny])continue;
                    add((i-1)*m+j,(nx-1)*m+ny,1);
                    add((nx-1)*m+ny,(i-1)*m+j,0);
                }
            }else{
                add((i-1)*m+j,e,1);
                add(e,(i-1)*m+j,0);
            }
        }
    }
    cout<<n*m-k-maxflow()<<endl;
}
```
(省去了其他函数，只剩下了mian，所以交上去一定会CE)

---

## 作者：赵悦岑 (赞：0)

# P5030 长脖子鹿放置

[P5030 长脖子鹿放置](https://www.luogu.com.cn/problem/P5030)

## 分析

这实际上也是一道网络流的问题，但是和以前做的题都不一样，同时也很难想到怎么做。题目中要求任意两个可以相互攻击的方格不能同时取，如果我们把一个方格放在 A 组，另一个方块放在 B 组，那么所有和 A 中方格可以攻击到的方格都要放在 B 组，和 B 中方格可以攻击到的都要放在 A 组。如果我们就把这个图分成了两组，只有两组之间有关系，同一组的方格没有关系，是不是很像二分图？我们把所有相互攻击的方格都用一条边连上，问题转换为删去一些节点，使得两组之间连通，求出删去节点权值的最小值。

我们来看两个互相攻击的点有什么特点：$(x,y) \Leftrightarrow (x+1,y+3)$，$(x,y) \Leftrightarrow (x-1,y+3)$，$(x,y) \Leftrightarrow (x-3,y+1)$，$\cdots$。显然，任意两个相互攻击的点横纵坐标的奇偶性都不相同。这样我们只需要按横坐标的奇偶性分组即可，虽然可以分成 $4$ 组，但是没有必要，只要保证同一组内不相互攻击即可。

分完组后，要删去最少的节点，我们又可以自然而然地想到最小割（最小割=最大流），但是最小割删去的是边，而不是点。我们转化一下，将源点和 A 组所有点相连，汇点和 B 组所有点相连，容量均为 $1$，这样删去一条边的代价刚好是 $1$。但是我们不能删去两组之间的边，为了不删去这些边，把这些边的容量设为正无穷，就永远不可能删去这些边了。由于最小割 $=$ 最大流，所以我们只需要跑一遍最大流即可。注意只能由 A 组连向 B 组或 B 组连向 A 组，不能同时连。

## code

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
const int N=50001,M=2000001;
int n,m,q,p=1,s1,s2,t[N],t0[N],f[N];
short dx[8]={-3,-1,1,3,3,1,-1,-3},dy[8]={-1,-3,-3,-1,1,3,3,1};
bool b[N];
struct str
{
    int m,q;
    ll r;
}a[M];
bool check(int x,int y)
{
    return x>=1&&x<=m&&y>=1&&y<=n;
}
int sum(int x,int y)
{
    return (x-1)*n+y;
}
void road(int x,int y,ll r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
bool bfs()
{
    queue<int> Q;
    Q.push(s1);
    for(int i=1;i<=s2;++i) f[i]=0;
    f[s1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0&&a[i].r!=0)
            {
                f[a[i].m]=f[k]+1;
                Q.push(a[i].m);
            }
        }
    }
    return f[s2]!=0;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[a[i].m]==f[x]+1&&a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf("%d%d%d",&m,&n,&q);
    s1=m*n+1;
    s2=m*n+2;
    for(int i=1;i<=q;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(b[sum(x,y)]==true) --i,--q;
        b[sum(x,y)]=true;
    }
    for(int i=1;i<=m;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(b[sum(i,j)]==true) continue;
            if(i&1)
            {
                road(s1,sum(i,j),1);
                road(sum(i,j),s1,0);
                for(int k=0;k<=7;++k)
                {
                    if(check(i+dx[k],j+dy[k]))
                    {
                        road(sum(i,j),sum(i+dx[k],j+dy[k]),1e18);
                        road(sum(i+dx[k],j+dy[k]),sum(i,j),0);
                    }
                }
            }
            else
            {
                road(sum(i,j),s2,1);
                road(s2,sum(i,j),0);
            }
        }
    }
    ll r=0;
    while(bfs())
    {
        for(int i=1;i<=s2;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf("%lld",m*n-q-r);
    return 0;
}
```

---

## 作者：Phartial (赞：0)

将每个格子和往八个方向走一步可以到的格子连边，由于每走一步行的奇偶性总会改变，所以我们可以得到一个二分图。

不难发现答案就是这个二分图的最大独立集。

优化：匹配优先往下匹配，这样可以更快找出增广路。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kN = 201, kD[8][2] = {{3, 1}, {1, 3}, {3, -1}, {1, -3}, {-1, -3}, {-3, -1}, {-1, 3}, {-3, 1}};

int n, m, k, v[kN * kN], t, s, p[kN * kN];
bool a[kN][kN];
vector<int> ne[kN * kN];

int Encode(int x, int y) { // 将二维属性编码成一个数
  return (x - 1) * m + y;
}
bool F(int x) { // 二分图最大匹配
  if (v[x] ^ t) {
    v[x] = t;
    for (int i : ne[x]) {
      if (!p[i] || F(p[i])) {
        return p[i] = x;
      }
    }
  }
  return 0;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> m >> k;
  for (int i = 1, x, y; i <= k; ++i) {
    cin >> x >> y;
    a[x][y] = 1;
  }
  k = 0;
  for (int i = 1; i <= n; ++i) { // 注意可能会有重复的禁点
    for (int j = 1; j <= m; ++j) {
      k += a[i][j];
    }
  }
  for (int i = 1; i <= n; i += 2) {
    for (int j = 1; j <= m; ++j) {
      if (!a[i][j]) {
        for (int k = 0; k < 8; ++k) {
          int x = i + kD[k][0], y = j + kD[k][1];
          if (x >= 1 && x <= n && y >= 1 && y <= m && !a[x][y]) {
            ne[Encode(i, j)].push_back(Encode(x, y)), ne[Encode(x, y)].push_back(Encode(i, j)); // 建图
          }
        }
      }
    }
  }
  for (int i = 1; i <= n; i += 2) { // 求出二分图最大匹配=二分图最小点覆盖
    for (int j = 1; j <= m; ++j) {
      ++t, s += F(Encode(i, j));
    }
  }
  cout << n * m - s - k; // 二分图最大独立集=N-二分图最小点覆盖
  return 0;
}
```


---

## 作者：苏幕寒 (赞：0)

这题和 P3355 骑士共存问题大同小异；就是走的方法不同，不注意就会被坑；唯一不同的就是建边的时候有些差异；建好边后跑最大流就完美AC了；不会建边的可以参考一下我这个蒟蒻瞎蒙出来的方法；题意不明的可以先去做一下 P3355 骑士共存问题 这道题；

好了，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
int n,m,k,s,t;
struct edge{
	int v,nxt,val;
}e[N];
int head[N],cnt=1,cur[N];
int ans;
bool b[1005][1005];
int dis[N];
int dx[]={3,3,1,1,-3,-3,-1,-1};
int dy[]={1,-1,3,-3,1,-1,3,-3};
queue<int>q;
int Read()
{
	int ch=0;
	char w=getchar();
	while(w<'0'||w>'9') w=getchar();
	while(w>='0'&&w<='9'){
		ch=ch*10+w-'0';
		w=getchar();
	}
	return ch;
}
void add(int u,int v,int val){
	e[++cnt]=(edge){v,head[u],val};head[u]=cnt;
	e[++cnt]=(edge){u,head[v],0};head[v]=cnt;
}
bool bfs()
{
	memset(dis,-1,sizeof(dis));
	dis[s]=1;q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(dis[v]==-1&&e[i].val)
			{
				q.push(v);
				dis[v]=dis[u]+1;
			}
		}
	}
	return dis[t]!=-1;
}
int dfs(int u,int flow)
{
	if(u==t) return flow;
	int res=0;
	for(int i=cur[u];i;i=e[i].nxt)
	{
		cur[u]=i;int v=e[i].v;
		if(dis[v]==dis[u]+1&&e[i].val)
		{
			int fl=dfs(v,min(flow,e[i].val));
			if(fl)
			{
				flow-=fl;res+=fl;
				e[i].val-=fl;e[i^1].val+=fl;
				if(!flow) return res;
			}
		}
	} 
	return res;
}
int main()
{
	n=Read();m=Read();k=Read();
	ans=n*m-k;
	s=n*m+1;t=s+1;
	for(int i=1;i<=k;i++)
	{
		int x,y;
		x=Read();y=Read();
		b[x][y]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(b[i][j]==1) continue;
			if(i%2==1) add(s,(i-1)*m+j,1);//不同的建边
			if(i%2==0) add((i-1)*m+j,t,1);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(i%2==0) continue;//一样不同
			if(b[i][j]==1) continue;
			for(int o=0;o<8;o++)
			{
				int xx=dx[o]+i;
				int yy=dy[o]+j;
				if(xx<1||xx>n||yy<1||yy>m||b[xx][yy]==1) continue;
				add((i-1)*m+j,(xx-1)*m+yy,1e9);
			}
		}
	}
	while(bfs()){
		memcpy(cur,head,sizeof(head));
		ans-=dfs(s,1<<29);
	}//DInic大法，不祥谈
	printf("%d",ans);
	return 0;
}
```


---

## 作者：吾王美如画 (赞：0)

# 唔呣
这道题终于变黑了，可喜可贺，所以来写道题解~~才不会告诉你是因为咕值不够了~~


------------
- 首先我们看，在棋盘上放棋子，让他们互相不能攻击，这明显是到二分图最大独立集（类似题[骑士共存问题](https://www.luogu.org/problemnew/show/P3355)）

- 接着我们想怎样染色，第一下想的就是像棋盘那样按行列奇偶性来染，但是显然不对。于是我们发现一个惊人的问题，**基数行和偶数行之间的棋子不会互相攻击！！！**这样就好了，按行奇偶性来染色，跑个二分图最大独立集就行（二分图最大独立集=点数-最大匹配数）

上代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define MAXN 50005
#define MAXM 500050
using namespace std;
int head[MAXN],next[MAXM*2],to[MAXM*2],w[MAXM*2],cur[MAXN];
int n,m,k,s,t;
int cnt=-1;
int deep[MAXN];
int tu[220][220];
struct node{
       int l;
       int r;
};
void link(int a,int b,int c){
     cnt++;
     w[cnt]=c;
     next[cnt]=head[a];
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     w[cnt]=0;
     next[cnt]=head[b];
     to[cnt]=a;
     head[b]=cnt;
}
bool bfs(){
     memset(deep,0,sizeof(deep));
     queue<int> q;
     while(!q.empty())q.pop();
     q.push(s);
     deep[s]=1;
     while(!q.empty()){
                       int now=q.front();
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]&&!deep[to[i]]){
                                                       deep[to[i]]=deep[now]+1;
                                                       q.push(to[i]);
                               }
                       }
     }
     if (deep[t])return 1;else return 0;
}
int dinic(int now,int last){
    if (now==t||!last)return last;
    int ret=0;
    for(int i=cur[now];i!=-1;i=next[i]){
            if(deep[to[i]]-1==deep[now]&&w[i]){
                                               int zgl=dinic(to[i],min(w[i],last-ret));
                                               if (zgl){
                                                        w[i]-=zgl;
                                                        w[i^1]+=zgl;     
                                                        ret+=zgl;
                                                        if(ret>=last) break;
                                               }
            }
            cur[now]=i;
    }
    return ret;
}
int num(int a,int b){
    return n*(a-1)+b;
}
bool check(int a,int b){
     if (a&1) return 1;else return 0;
}
int main(){
    cin>>n>>m>>k;;
    int x[8]={1,1,3,3,-1,-1,-3,-3},y[8]={3,-3,1,-1,3,-3,1,-1};
    memset(head,-1,sizeof(head));
    memset(tu,0,sizeof(tu));
    int sum=n*m-k;
    s=0;t=n*m+2;
    for(int i=1;i<=k;i++){
            int a,b;
            scanf("%d%d",&a,&b);
            tu[a][b]=1;
    }
    for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                    if (check(i,j)){link(num(i,j),t,1);continue;};
                    if (tu[i][j])continue;
                    link(s,num(i,j),1);
                    for(int k=0;k<8;k++){
                            int xx=i+x[k],yy=j+y[k];
                            if (tu[xx][yy])continue;
                            if (xx<=0||yy<=0||xx>n||yy>m)continue;
                            link(num(i,j),num(xx,yy),1);
                    }
            }
    }
    int ans=0;
    while(bfs()){
                 memcpy(cur,head,sizeof(cur));
                 ans+=dinic(s,9999999);
    }
    cout<<sum-ans;
    return 0;
}

```
码风巨丑，请大佬们见谅QAQ

---


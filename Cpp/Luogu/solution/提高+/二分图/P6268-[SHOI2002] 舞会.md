# [SHOI2002] 舞会

## 题目描述

某学校要召开一个舞会。已知学校所有 $n$ 名学生中，有些学生曾经互相跳过舞。当然跳过舞的学生一定是一个男生和一个女生。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。求这个舞会最多能邀请多少个学生参加。

## 样例 #1

### 输入

```
8 6
0 2
2 3
3 5
1 4
1 6
3 1```

### 输出

```
5```

## 样例 #2

### 输入

```
20 5
5 2
4 3
18 17
0 11
13 3
```

### 输出

```
16```

# 题解

## 作者：Rusalka (赞：23)

这题是我做的第三道二分图最大匹配的题目。~~前两道都是纯模板。~~

在做这道题的时候我还不知道二分图的最大独立集与最大匹配的关系，甚至没发现这题是在求最大独立集。。。  
  
所以我推答案花了一点时间，下面给出我的思路：

首先很显然我们只需要考虑跳过舞的学生，其他学生一定都可以参加舞会。

如果在每一对跳过舞的学生之间连一条**无向边**，那么一定会构成一张二分图。

注意这里是无向边，因为你此时并不知道这两个人哪个是男哪个是女 ~~安能辨我是雄雌~~。

那么求出有多少人**不能**参加舞会会比较简单。

不难发现这个人数其实就是这张二分图的最大匹配，因为如果排除了这些在最大匹配中的人，其他人就一定都能选；而如果不排除，则至少会有一对跳过舞的人还被保留。

那么在最大匹配的点集之外的点都是可以选的。

所以我们需要求的答案就是  $n\ -$ 最大匹配的边数。

关于求最大匹配，我们可以使用匈牙利算法，在这里就不再介绍了。

不过还有一个问题，如果在匈牙利算法中直接枚举所有点的话是不行的 ~~连样例都过不了~~。

所以我们需要先对二分图进行染色，找出其中是同一性别的人~~不管是男是女~~，然后跑一遍匈牙利算法就可以愉快地 AC 了。

~~话说是不是只有我喜欢大括号换行~~

``` cpp
#include <cstdio>
#include <iostream>

using namespace std;

const int MAXN = 1010;

int n, m, g[MAXN][MAXN], now[MAXN], col[MAXN];
bool vis[MAXN];

//二分图染色，找出同一性别的人
void color(int u, int pre, int c)
{
	col[u] = c;
	for(int i=1;i<=n;i++)
		if(g[u][i] && !col[i])
			color(i, u, 3 - c);
}

bool find(int u)
{
	for(int i=1;i<=n;i++)
		if(g[u][i] && !vis[i])
		{
			vis[i] = 1;
			if(!now[i]|| find(now[i]))
			{
				now[i] = u;
				return 1;
			}
		}
	return 0;
}

inline int match()
{
	int res = 0;
	for(int i=1;i<=n;i++)
	{
		if(col[i] != 1) continue;
        //只选取某一性别的人
		for(int j=1;j<=n;j++)
			vis[j] = 0;
		res += find(i);
	}
	return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x, y;
		scanf("%d%d",&x,&y);
		++x; ++y; //处于个人习惯，这里把所有点+1
		g[x][y] = g[y][x] = 1;
	}
	for(int i=1;i<=n;i++)//给每一个人染色
    //对于不在二分图中的点是无所谓的
		if(!col[i]) color(i, 0, 1);
	printf("%d\n",n - match());
	return 0;
}
```

---

## 作者：K2sen (赞：15)

## 题目大意：

给你好几对已经互相跳过舞的狗男女

要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞

所以被邀请的都是两两都没有跳过舞的，

## 解题思路

很明显这个题就是在求一个最大点独立集，因为最大点独立集=最大匹配

所以我们可以用匈牙利算法跑最大匹配，找出有多少人不能参加舞会

然后用总人数减去不能参加的人数就是能去多少人
.
坑点1:你不知道男女

所以我们可以黑白染色，然后求男女

坑点2:你染色的时候dfs一不注意就会MLE

我也不知道为什么会MLE

>if (fa == to || color[to]) continue;


可以这么处理，如果碰到已经染过色的就直接continue 就不会MLE了


## code

```cpp
/*
Author: _Destiny
*/
#include <set>
#include <map>
#include <queue>
#include <cmath>
#include <stack>
#include <cstdio>
#include <string>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <algorithm>

#define N 1010
#define M 2010

using namespace std;
int n, m;
int match[N]; bool vis[N];
int color[N], fx[M], fy[M];
int head[M << 1], add_edge;
struct node {
	int next, to;
}edge[M << 1];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void add(int from, int to) {
	edge[++add_edge].next = head[from];
	edge[add_edge].to = to;
	head[from] = add_edge;
}

void tc(int x, int fa) {
	if (color[fa] == 1) color[x] = 2;
	else color[x] = 1;
	for (int i = head[x]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (fa == to || color[to]) continue;
		tc(to, x);
	}
}

bool dfs(int now) {
	for (int i = head[now]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (vis[to]) continue;
		vis[to] = 1;
		if (!match[to] || dfs(match[to])) {
			match[to] = now;
			return 1;
		}
	}
	return 0;
}

int main() {
	n = read(), m = read();
	for (int i = 1, x, y; i <= m; i++) {
		fx[i] = read(), fy[i] = read();
		add(fx[i] + 1, fy[i] + 1);
		add(fy[i] + 1, fx[i] + 1);
	}
	for (int i = 1; i <= m; i++) {
		if (color[fx[i] + 1] == 0)
			tc(fx[i] + 1, 0);
		if (color[fy[i] + 1] == 0)
			tc(fy[i] + 1, 0);
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) 
		if (color[i] == 1) {
			memset(vis, 0, sizeof(vis));
			if (dfs(i)) ans++;
		}
	cout << n - ans;
}
```

---

## 作者：一扶苏一 (赞：11)

### Solution

考虑建图，如果 $a$ 和 $b$ 曾经跳过舞，就将 $a$ 和 $b$ 之间连一条边，那么问题就是在这张图上选尽可能多的点，满足点之间没有边相连，也即最大独立集。又因为题目保证了连边一定是在男女之间的，所以这张图一定是一张二分图。二分图最大独立集 = 总点数 - 最小点覆盖 = 总点数 - 最大匹配。匈牙利算法即可，时间复杂度 $O(n^2 + nm)$。

### Code

```cpp
const int maxn = 1005;

int n, m;
int vistime[maxn], mch[maxn], col[maxn];
std::vector<int> e[maxn];

void dfs(const int u);
bool dfs(const int u, const int vt);

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m);
  for (int u, v; m; --m) {
    qr(u); qr(v);
    e[u].push_back(v);
    e[v].push_back(u);
  }
  int ans = n;
  memset(col, -1, sizeof col);
  for (int i = 0; i < n; ++i) if (col[i] == -1) {
    col[i] = 0;
    dfs(i);
  }
  memset(mch, -1, sizeof mch);
  memset(vistime, -1, sizeof vistime);
  for (int i = 0; i < n; ++i) if ((col[i] == 0) && dfs(i, i)) {
    --ans;
  }
  qw(ans, '\n');
  return 0;
}

bool dfs(const int u, const int vt) {
  if (vistime[u] == vt) return false;
  vistime[u] = vt;
  for (auto v : e[u]) if ((mch[v] == -1) || dfs(mch[v], vt)) {
    mch[v] = u;
    return true;
  }
  return false;
}

void dfs(const int u) {
  for (auto v : e[u]) if (col[v] == -1) {
    col[v] = 1 - col[u];
    dfs(v);
  }
}
```



---

## 作者：genshy (赞：5)

**首先呢，这道题是一道典型的二分图最大独立集问题。**

我们把每对跳过舞的同学连一条边，那么我们所选出来的同学中就不能有连边。

这正好符合二分图最大独立集的概念，包含点数最多的，且任意两点之间没有连边的最大集。

我们先证明一下，为什么我们这样建边会得到一张二分图。

我们可以把男女分在左右两边，题目保证了跳过舞的人都是男女配对的，所以男男之间不会有连边。

所以保证了同一个集合内没有连边，所以这是一个二分图。

再说了，要是有奇环的话，那么就会有一个人的性别不明确（~~不男不女？？？~~） 大雾。

自己画一下图就好理解了。

那么我们最终的答案就是二分图的最大独立集。

这东西怎么求呢？ 先来一个定理：

**二分图最大独立集等于 n - 最小点覆盖 等于 n - 二分图最大匹配数**

第一个等式的话很好证出来。

我们选出来的点之间没有连边就等价于用最小的点覆盖所有的边，也就是我们所说的最小点覆盖问题。

至于为什么最小点覆盖等于最大匹配数，可以看看李煜东的那本蓝皮书，他讲的挺详细的。

当我们建完图后，你还会发现一个重要的问题就是，你找不到从从哪些点开始匹配，即找不到左边集合中的点。

我一般解决这个问题的方法就是先对整张图跑一边染色法，把所有标记为 $1$ 的点扔到一个 $vector$ 中，然后对这些点跑一边最大匹配就可以。

当然了你也可以像其他题解里的方法对所有点求一遍最大匹配在除以二也可以。

**Code**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int N = 1010;
int n,m,u,v,ans,tot;
int head[N],match[N],c[N];
bool vis[N];
vector<int> q;
struct node
{
	int to,net;
}e[100010];
inline int read()
{
	int s = 0,w = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9'){s = s * 10 + ch - '0'; ch = getchar();}
	return s * w;
}
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].net = head[x];
	head[x] = tot;
}
bool dfs(int x)
{
	for(int i = head[x]; i; i = e[i].net)
	{
		int to = e[i].to;
		if(!vis[to])
		{
			vis[to] = 1;
			if(!match[to] || dfs(match[to]))
			{
				match[to] = x;
				return 1;
			}
		}
	}
	return 0;
}
void bfs(int x,int col)
{
	c[x] = col;
	if(c[x] == 1) q.push_back(x);
	for(int i = head[x]; i; i = e[i].net)
	{
		int to = e[i].to;
		if(!c[to]) bfs(to,3-col);
	}
}
int main()
{
	n = read(); m = read();
	for(int i = 1; i <= m; i++)
	{
		u = read()+1; v = read()+1;//记得学生编号是从零开始的，要加一个1转化为从1到n
		add(u,v); add(v,u);
	}
	for(int i = 1; i <= n; i++)
	{
		if(!c[i]) bfs(i,1);//染色
	}
	for(int i = 0; i < q.size(); i++)//匈牙利算法
	{
		memset(vis,0,sizeof(vis));
		int x = q[i];
		if(dfs(x)) ans++;
	}
	printf("%d\n",n-ans);
	return 0;
}
```







---

## 作者：Kris_hukr (赞：4)

题意就不说了，其他题解写的都很好。

### 分析

明明这题第一个 tag 就是网络~~瘤~~流，却没有一篇网络流的题解 qwq。

首先是染色，确定每对曾经跳过舞的学生的性别。

第一个坑，数据不保证无环，所以要这么写：

```cpp
void color(int x, int c) {
    col[x] = c;
    vis[x] = true;
    for (int i = head[x]; i; i = node[i].nxt) {
        int v = node[i].v;
        if (vis[v]) {  // 如果你按照 v == f 写就会收获 MLE 若干
            continue;
        }
        color(v, c ^ 1);
    }
}
```

有人或许不理解怎么出现环，这里给出一组数据：

```
5 4
0 1
1 2
2 3
3 0
```

第二个坑，数据不保证每组前面一定是同种性别。于是你直接建模会收获 40 pts 的好成绩。

我的做法可能有点复杂，供参考。

```cpp
auto* c = new Color();  // 完整代码最后会放在云剪贴板里

for (int i = 1; i <= m; i++) {
    int x = read<int>(), y = read<int>();
    x++, y++;
    c->create(x, y);
    c->create(y, x);
    c->fm[i] = x;
    c->to[i] = y;
}

for (int i = 1; i <= n; i++) {
    if (!c->vis[i]) {  // 数据不保证联通
        c->color(i, 0);
    }
}

auto* flow = new Flow(n + 20, s, t);
for (int i = 1; i <= m; i++) {
    int x = c->fm[i], y = c->to[i];
    if (c->col[x]) {
        std::swap(x, y);  // 前面的同学颜色不对，交换两位同学
    }

    flow->create(x, y, 1);
    flow->create(y, x, 0);
}
```

最后注意数据并不保证图的联通，染色的时候不能只跑一遍。

### 建模

~~众所周知，网络流主要考建模。~~

这道题的建模不算很复杂，具体的分析可以看其他题解。

求最大独立集不好求，所以我们求最大匹配，转换为网络流上的最大流。输出答案的时候再拿总点数减一下就好了。

- 不妨假设 $u$ 的性别为 $0$， $v$ 的性别为 $1$。
- 建立容量为 $1$ 的一条边 $(u,v)$ 。
- 建立超级源点 $S'$ ，超级汇点 $T'$。
- 对于每一个 $u$ 建立容量为 $1$ 的一条边 $(S',u)$。
- 对于每一个 $v$ 建立容量为 $1$ 的一条边 $(v,T')$。

就好了啊 qwq。最后流向 $t$ 的最大流就是二分图上的最大匹配。

还是不太理解的话可以看一下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/76sguke1.png)

最后附上[完整代码](https://www.luogu.com.cn/paste/uh7o8s7l)



---

## 作者：VinstaG173 (赞：2)

相当于是个二分图最大匹配板子。

由于题目中给出了条件，一定是男女之间互相跳过舞，所以给出的图一定是个二分图。

然后题目显然要求最大独立集，注意到最小覆盖使得每条边至少有一个顶点被选中且选中的顶点数最少，所以只要去掉最小覆盖，剩下的就是最大独立集。

再由于最小覆盖数值上等于最大匹配，于是跑匈牙利就完了。

预处理时用一个 dfs 来把二分图的两边标记了就行了。

Code:
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int N,M;
bool hh[1007],hw[1007];
int x,y,tg[1007],hus[1007];
int head[1007],cnt,dfn[1007];
struct edge
{
    int nxt,to;
}e[4007];
inline void pdfs(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa||~tg[v])continue;
		tg[v]=tg[u]^1;pdfs(v,u);
	}
}
inline bool dfs(int u,int tim)
{
    for(int i=head[u];i;i=e[i].nxt)
	{
	    int v=e[i].to;
	    if(dfn[v]==tim)continue;
	    dfn[v]=tim;
	    if(!hh[v])
		{
		    hus[v]=u;
		    hh[v]=true;
		    return hw[u]=true;
		}
	    if(dfs(hus[v],tim))
		{
		    hus[v]=u;
		    hh[v]=true;
		    return hw[u]=true;
		}
	}
    return hw[u]=false;
}
int main()
{
    scanf(" %d %d",&N,&M);
    memset(tg,-1,sizeof(tg));
    memset(dfn,-1,sizeof(dfn));
    while(M--)
	{
	    scanf(" %d %d",&x,&y);
	    e[++cnt].nxt=head[x];e[cnt].to=y;head[x]=cnt;
	    e[++cnt].nxt=head[y];e[cnt].to=x;head[y]=cnt;
	}
	for(int i=0;i<N;++i)
	{
		if(tg[i]==-1)
		{
			tg[i]=0;pdfs(i,-1);
		}
	}
    cnt=0;
    for(int i=0;i<N;++i)
	{
	    if(!tg[i]&&dfs(i,i))++cnt;
	}
    printf("%d\n",N-cnt);
    return 0;
}
```

---

## 作者：king_xbz (赞：2)

一道二分图的经典题目，看到题解区染色啊，预处理二分图啊等等神仙做法都好复杂。我感慨：这其实就是一道经典的**二分图最大独立集**嘛！

做题思路
-
我们先来看题：
```
已知学校所有 n 名学生中，有些学生曾经互相跳过舞。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。
```
我们可以考虑将这些跳过舞的人**构建二分图**，并通过[匈牙利算法](https://baike.baidu.com/item/匈牙利算法/9089246?fr=aladdin)求出匹配对数。
而在二分图中一对匹配对应的是两个人，我们用**总人数减去已参与匹配的人数**即可A掉这道题。

代码实现
-
这道题的代码实现有许多细节需要注意：

1.需要双向建图，根据题意这里的配对关系是**无向图**。

2.存图时注意**序号是0~n-1**，这里建议大家将其转化为1~n的图，减少初始化负权数组的麻烦

3.由于配对会重复（即会出现s[a]=b,s[b]=a的情况），所以注意最后输出的是n-**(ans/2)**

具体代码实现如下：
```cpp
int main()
{
	int n,m;
	n=read(),m=read();
	int x,y;
	for(fint i=1;i<=m;i++)
	x=read(),y=read(),adds(x+1,y+1),adds(y+1,x+1);//双向建图，点序号+1
	int ans=0;
	for(fint i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));
		if(Hungary(i))
		ans++;
	}
	cout<<n-(ans/2);//去重
	return 0;
}

inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return ;
}

inline int Hungary(int x)//标准匈牙利算法
{
	for(fint i=head[x];i;i=e[i].nxt)
	if(!vis[e[i].to])
	{
		vis[e[i].to]=1;
		if(!s[e[i].to]||Hungary(s[e[i].to]))
		{
			s[e[i].to]=x;
			return 1;
		}
	}
	return 0;
}
```
祝大家顺利AC！！！

---


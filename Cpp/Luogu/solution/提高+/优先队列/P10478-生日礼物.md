# 生日礼物

## 题目描述

ftiasch 18 岁生日的时候，lqp18_31 给她看了一个神奇的序列 $A _ 1$, $A _ 2$, ..., $A _ N$。 她被允许选择不超过 $M$ 个连续的部分作为自己的生日礼物。

自然地，ftiasch 想要知道选择元素之和的最大值。你能帮助她吗?

## 样例 #1

### 输入

```
5 2
2 1 -2 3 -2```

### 输出

```
6```

# 题解

## 作者：Genius_Star (赞：15)

### 思路：

考虑贪心：

- 对于一段正数，一定一起被选中，可以加起来看成一个数。

- 对于一段负数，也一定一起被选中，因为选它是为了连续选它两端的正数，则也可以加起来看成一个数。

若最左边与最右边是负数，则不必考虑，因为肯定不会选，那么此时序列 $a$ 肯定是下述的形式。

$$+-+-+\cdots +-+-+$$

设里面有 $A$ 个正数：

- 若 $M \ge A$，则正数全选，忽略负数。

- 若 $M < A$，先选出所有正数，然后考虑退款。

对于第二种情况，需要进行 $A-M$ 次退款，有两种情况可以退款：

- 不选某个正数。

- 把两个正数和中间负数一起合并。

需要注意到每次退款可能造成新的情况：

- 不选某个正数之后，可以与该正数两端负数合并出一个新的数，看作负数；可以用情况二加回来。

- 把两个正数和中间负数一起合并后，可以把他们合起来看作一个正数；可以用情况一退款。

先令 $ans$ 为所有正数的和，先将序列中所有数加入堆中，是按照绝对值的小根堆，那么有两种情况：

- 若 $a_x < 0$，那么就相当于与两边的正数合并（因为是当前绝对值最小的，依旧是最优策略）；然后删除 $x-1,x+1$，将 $a_{x-1} + a_{x+1} - a_x$ 放到 $x$ 处。

- 若 $a_x \ge 0$，那么相当于舍弃某个正数，然后也相当于与两端的负数进行合并；然后删除 $x-1,x+1$，将 $a_{x-1} + a_{x+1} - a_x$ 放到 $x$ 处。

- 这里 $x-1,x+1$ 表示的 $x$ 上或下一个未被删除的位置，可以用双向链表维护，记录一个 $l_i,r_i$ 即可。

因为要支持删除操作，标记一下即可，若当前堆顶已被标记，则表示被删除了，重新取出下一个堆顶，直到当前堆顶未被删除。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
using namespace std;
typedef long long ll;
typedef double db;
const ll N=1e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll data;
	ll id;
	bool operator<(const Node&rhs)const{
		return abs(data)>abs(rhs.data);
	}
};
ll n,m,k,x,ans,cnt=1;
ll a[N],l[N],r[N];
bool f[N];
priority_queue<Node> Q;
bool check(ll x){
	if((0<l[x]&&r[x]<n+1)||a[x]>0)
	  return 1;
	return 0;
}
void del(ll x){
	f[x]=1;
	l[r[x]]=l[x],r[l[x]]=r[x];
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		x=read();
		if(!x)
		  continue;
		if((x>=0&&a[cnt]>=0)||(x<=0&&a[cnt]<=0))
		  a[cnt]+=x;
		else
		  a[++cnt]=x;
	}
	n=cnt;
	for(int i=1;i<=n;i++){
		l[i]=i-1,r[i]=i+1;
		if(a[i]>0){
			k++;
			ans+=a[i];
		}
		Q.push({a[i],i});
	}
	while(k>m){
	    if(Q.empty())
	      break;
		x=Q.top().id;
		Q.pop();
		if(f[x])
		  continue;
		if(check(x)){
			ans-=abs(a[x]);
			a[x]+=a[l[x]]+a[r[x]];
			del(l[x]),del(r[x]);
			Q.push({a[x],x});
			k--;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：xiaoshu2010 (赞：5)

# Solution

首先，由于 $0$ 对答案没有影响，可以先去除数组中的 $0$。

其次，将所有连续的符号相同的数合并为一段，这样数组就变为了 $+-+-+-\dots$ 的形式。

先考虑贪心地选择正段，可以发现，这么选段数可能会超过 $m$。为减少段数，可以进行以下两种操作：

1. 去除一个正段。此时答案减少正段的数字之和。

2. 将两个相邻但不相连的正段合并。此时答案增加中间的负段的数字之和。

注意到，这两种操作实质上是将答案减少被去除数段的绝对值，并减少一个正段。很明显，将绝对值最小的数段与相邻两端合并是最优的。

为快速维护绝对值最小的数段，可以先将所有数段加入优先队列，然后在合并数段时，将合并后的数段加入优先队列，同时去除合并前的数段。

最后，若选取到最左端或最右端的负段，直接删除即可。

重复以上操作，直到正段段数小于等于 $m$ 为止。

时间复杂度： $\operatorname{O}(n\log{n})$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int l,r,sum,last,next;
};
struct node2{
	int id,sum;
	bool operator<(const node2& x) const{
		return sum>x.sum;
	}
};
priority_queue<node2> q;
long long n,m,a[100005],cnt,ans,cnt2;
bool flag[100005];
node b[100005];
bool cmp(node x,node y){
	return x.sum>y.sum;
}
int main(){
	cin >>n>>m;
	for(int i=1;i<=n;i++){
		cin >>a[i];
		if(a[i]==0){
			i--;
			n--;
		}
	}
	for(int i=1;i<=n;i++){
		if(a[i]>0){
			ans+=a[i];
			if(a[i-1]<0||i==1){
				cnt++;
				b[++cnt2].l=i;
				b[cnt2].r=i;
				b[cnt2].sum=a[i];
			}else{
				b[cnt2].r=i;
				b[cnt2].sum+=a[i];
			}
		}else{
			if(a[i-1]>0||i==1){
				b[++cnt2].l=i;
				b[cnt2].r=i;
				b[cnt2].sum=a[i]; 
			}else{
				b[cnt2].r=i;
				b[cnt2].sum+=a[i];
			}
		}
	}
	b[0].sum=b[cnt2+1].sum=0x3f3f3f3f;
	b[0].next=1;
	b[cnt2+1].last=cnt2;
	for(int i=1;i<=cnt2;i++){
		b[i].last=i-1;
		b[i].next=i+1;
		q.push({i,abs(b[i].sum)});
	}
	while(!q.empty()){
		int sum=q.top().sum,id=q.top().id;
		q.pop();
		if(cnt<=m)break;
		if(flag[id])continue;
		int last=b[id].last,next=b[id].next;
		if(b[id].sum>0||(b[id].sum<0&&last!=0&&next!=cnt2+1)){
			ans-=sum;
			cnt--;
			flag[last]=1;
			flag[next]=1;
			b[id].l=b[last].l;
			b[id].r=b[next].r;
			b[id].sum=b[id].sum+b[last].sum+b[next].sum;
			b[id].last=b[last].last;
			b[b[last].last].next=id;
			b[id].next=b[next].next;
			b[b[next].next].last=id;
			q.push({id,abs(b[id].sum)});
		}
	}
	cout <<ans;
}
```

---

## 作者：luxiaomao (赞：5)

## [P10478](https://www.luogu.com.cn/problem/P10478) 反悔贪心经典例题

刚写完，想去冲双倍经验 P6821 结果被加强数据硬控，所以来写篇题解涨一涨 RP。

upd：代码过不了样例，已修改，望通过。

## Solution

题意不难理解。

首先可以发现，如果没有 $m$ 这个限制（或者说 $m$ 足够大），那么我们的答案就是序列中所有正数的和。

那么我们可以先求出这样情况下的正区间个数 $cnt$，然后再把这个 $cnt$ 逐步降到 $m$。

怎么降？有两种方式：

- 抛弃一个正区间，这能让 $cnt$ 减掉一。

- 选择一个负区间算入答案，这能让它左右两个正区间合为一，同样使 $cnt$ 减掉一。

那么可以发现，要求这些被抛弃掉的贡献，实质就是求从若干个正负区间中选择互不相邻的 $(cnt-m)$ 个区间，使这些区间的绝对值之和最小。

把区间视作点，那么这道题就被完美转化成了 [P1484](https://www.luogu.com.cn/problem/P1484)，即反悔贪心的模板。

笔者采用优先队列 + 链表来实现。

## Code

```
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;

int n,m,a[N];
int b[N],tot,ans;

int l[N],r[N];
bool flag[N];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;

signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i = 1;i <= n;i++)
		scanf("%lld",&a[i]);
	int cnt = 0;
	for(int i = 1;i <= n;i++)
	{
		if(a[i] * b[tot] < 0)
			b[++tot] = a[i];
		else 
		    b[tot] += a[i];
	}
	if(b[tot] < 0)tot--;
	for(int i = 1;i <= tot;i++)
	{ 
		if(b[i] > 0)cnt++,ans += b[i];
		l[i] = i-1,r[i] = i+1;
		q.push(make_pair(abs(b[i]),i)); 
	} 
	r[0] = 1,l[tot+1] = tot;
	b[0] = b[tot+1] = 1e10;
	while(cnt > m)
	{
		while(flag[q.top().second])q.pop();
		int u = q.top().second;q.pop();
		if((l[u]==0 || r[u]==tot+1) && b[u] < 0)continue;
		cnt--,ans -= abs(b[u]);
		b[u] += b[l[u]]+b[r[u]],q.push(make_pair(abs(b[u]),u));
		flag[l[u]] = flag[r[u]] = 1;
		l[u] = l[l[u]],r[u] = r[r[u]];
		r[l[u]] = u,l[r[u]] = u;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：a18981826590 (赞：4)

# [P10478 生日礼物](https://www.luogu.com.cn/problem/P10478)
## 题目描述
从 $A$ 序列中取不超过 $m$ 个连续子序列，使得这些子序列的和最大。
## 解题思路
显然我们**贪心**地可以把连续的正数合并为一个元素，即它们的和。因为这些正数都能对答案产生贡献，且全选和选部分花费的代价是一样的，即一个连续子序列。

可是假如连续正数子序列的总个数大于 $m$ 怎么办？我们有 $2$ 种选择：

1. 舍弃一些连续正数子序列；
2. 将两个连续正数子序列和它们之间的所有负数合并为一个连续子序列。

这 $2$ 种操作都可以使当前选出来的连续子序列个数减少 $1$，我们可以通过重复这两种操作使得连续子序列个数小于等于 $m$。

注意操作 $2$，我们在合并的时候会把所有连续的负数计入答案，所以我们也可以将连续的负数合并成一个元素，即它们的和。

那么 $0$ 呢？由于 $0$ 对答案没有任何影响，我们可以把它随意地合并到一个连续子序列中。

接着我们运用**动态规划**，令 $B$ 为合并后的序列,$l$ 为合并后序列的长度，$s_{i,j,k}(1 \le i \le l,0 \le j \le m,k \in {0,1})$ 表示前 $i$ 个元素中取 $j$ 个连续子序列且 $k=0$ 时不选择 $B_{i}$，$k=1$ 时不选择 $B_{i}$ 得到的最大和。易得如下状态转移方程：

$$s_{i,j,0}=\max \{s_{i-1,j,0},s_{i-1,j,1}\}$$

$$s_{i,j,1}=\max \{s_{i-1,j-1,0},s_{i-1,j,1}\}+B_{i}$$

对于不取 $B_{i}$（$k=0$），$s_{i-1}$ 选择的子序列数 $j$ 不变。

对于取 $B_{i}$（$k=1$），若不取 $B_{i-1}$（$k=0$），则 $B_{i}$ 构成新一段连续子序列，则 $s_{i-1}$ 选择的子序列数 $j$ 就应该 $-1$；若取 $B_{i-1}$（$k=1$），则 $B_{i-1}$ 和 $B_{i}$ 属于同一段连续子序列，故 $s_{i-1}$ 选择的子序列数 $j$ 不变。

最后我们只需要取 $\max_{i=1}^{m} \max\{s_{l,i,0},s_{l,i,1}\}$ 即可。

但这样的空间复杂度为 $O(mn)$，无法接受，我们可以发现 $s_{i}$ 只和 $s_{i-1}$ 有关，故我们只需要保留 $s_{i-1}$；通过将 $i \bmod 2$，可以覆盖之前无用的状态，使得 $i \in \{0,1\}$，数组第一维只需开 $2$。
## [AC](https://www.luogu.com.cn/record/196322318) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],l=1,m,n,s[2][100010][2],x;
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>x;
		if(x*a[l]>=0) a[l]+=x;
		else a[++l]=x;
	}
	for(int i=1;i<=l;i++){
		for(int j=1;j<=min(i,m);j++){
			s[i%2][j][0]=max(s[(i-1)%2][j][0],s[(i-1)%2][j][1]);
			s[i%2][j][1]=max(s[(i-1)%2][j-1][0],s[(i-1)%2][j][1])+a[i];
		}
	}
	x=0;
	l%=2;
	for(int i=1;i<=m;i++) x=max(x,max(s[l][i][0],s[l][i][1]));
	cout<<x;
	return 0;
}
```

---

## 作者：Vae_L (赞：1)

逆天市赛挂的比得的分还多，自闭中。

于是闲的没事写篇题解。

如果你在这之前做过 [P1484](https://www.luogu.com.cn/problem/P1484)，那么会比较容易引发你想到这道题的正解。

我们将全部为正数的区间命名为正区间，全部为负数的区间命名为负区间，显然在该题中，$0$ 的价值没有意义，不去考虑。

于是我们考虑将正区间看做一个点，负区间看做一个点，就和刚才的题目非常像了。

但与 P1484 不同的是，该题中的每一个点都是一段区间，所以并没有不能选相邻值这个限制。

首先，有一个显然的结论，如果没有 $m$ 的限制，全部选择正区间一定是最优解，所以我们直接全部选掉。

但多了 $m$ 的限制，我们考虑怎么处理。

于是该问题就变成了如何将选择区间的数量从正区间个数降为 $m$。

不难发现有两种方式。

第一种方式，选择一个正区间，将他删去，容易发现，该正区间的价值越小越好。

第二种方式，选择一个负区间，将他加上，因为我们将原区间变为了正负交替的区间，所以加上后，会使得他左右的正区间连在一起，也就实现了删去一个正区间的作用，该负区间的值自然是越大越好，也就是绝对值越小越好。

至于加上负区间后对相邻区间的处理，我们考虑使用链表维护。

之后就是反悔贪心的套路了，将负区间的绝对值和正区间一起丢进一个小根堆就好。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,k,a[600005],l[600005],r[600005],vis[600005],ans,b[600005];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	bool flag=(a[1]>0ll);
	int sum=a[1],last=1;
	int len1=0;
	for(int i=2;i<=n;i++)
	{
		bool flag1;
		flag1=(a[i]>0);
		if(flag!=flag1)
		{
			b[++len1]=sum;
			sum=0;
			flag=flag1;
			last=i;
		}
		sum+=a[i];
	}
	sum=0;
	int cnt=0;
	for(int i=last;i<=n;i++) sum+=a[i];
	b[++len1]=sum;
	for(int i=1;i<=len1;i++)
	{
//		cout<<b[i]<<"\n";
		if(b[i]>0) ans+=b[i],cnt++;
		l[i]=i-1,r[i]=i+1;
		q.push({abs(b[i]),i});
	}
	l[len1+1]=len1,r[0]=1;
	b[0]=b[len1+1]=9e18;
	while(cnt>k)
	{
		while(!q.empty()&&vis[q.top().second]) q.pop();
		if(q.empty()) break;
		auto it=q.top();
		q.pop();
		if(b[it.second]<0&&(l[it.second]==0||r[it.second]==len1+1)) continue;
		ans-=it.first;
		cnt--;
		vis[l[it.second]]=1,vis[r[it.second]]=1;
		b[it.second]=b[l[it.second]]+b[r[it.second]]+b[it.second];
		l[it.second]=l[l[it.second]],r[it.second]=r[r[it.second]];
		r[l[it.second]]=it.second,l[r[it.second]]=it.second;
		q.push({abs(b[it.second]),it.second});
	}
	cout<<ans;
	return 0;
}

---

## 作者：wh2011 (赞：1)

题目链接：[Becoder](https://www.becoder.com.cn/problem/16288) or [Luogu](https://www.luogu.com.cn/problem/P10478)

---

首先我们可以先把点给缩一缩，把连续的正数点和连续的负数点分别缩成一个点，比如 `1 2 3 -1 -1 1 2` 这个东西我们就可以将其缩成 `6 -2 3` 我们可以发现，求前者的值等于求后者的值，我们就将原序列变为了**正负交替**的序列。

然后我们就可以开始反悔贪心，将所有数的点全部丢进小根堆里，小根堆的权值是这个点的绝对值，将所有正数的点暂时全部加进答案 $ans$ 并用一个数记录有多少个了，如果这个数大于了 $m$ 我们就开始反悔贪心（这里可能有些人不明白，不过到后面就会明白了，先记着就行。

当一个点是负数，而且它在角落，即左右两边有没有的点，那么我们就可以将其抛弃掉不管它了，反之，那么我们可以分类讨论一下：

1. 这个点是负数：那么它和它左右两边的点可以是这个形式“正负正”那我们就将这一组合并起来，那正数的点的个数就会减去 $1$ 答案还得加上这个负点，然后我们在把这个新的点丢进堆里面去。

2. 这个点是正点：那么它和它左右两边的点可以是这个形式“负正负”那我们就将这一组合并起来，那正数的点的个数就会减去 $1$ 答案还得减去上这个正点，然后我们在把这个新的点丢进堆里面去。

3. 如果这个点是正点，且在最左边或者最右边：那么可以成这个形式“正负”“负正”，很明显我们还是要将其合并起来，然后减去它，再将新点扔进堆里面去，目前选中的点也减去 $1$。

整理一下我们就可以变为，如果这个点满足：是一个负数，左右两边点不全，我们就删除它。如果不满足：答案减去它的绝对值，个数减 $1$ 再合并成一个新点，最后丢进堆里面。

如果还不明白，就结合着代码吧。

```cpp
#include <queue>
#include <cstring>
#include <algorithm>
#include <iostream>
#define x first
#define y second

using namespace std;

namespace oi{
	using ll = long long;
	using ull = unsigned long long;
	using pii = pair<int, int>;
	using db = double;
	using pll = pair<ll, ll>;
	#define endl '\n'


	inline ll read() {
		char ch = getchar(); ll fu = 0, s = 0;
		while(!isdigit(ch)) fu |= (ch == '-'), ch = getchar();
		while(isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
		return fu ? -s : s;
	}

	template <typename T>
	inline void write(T x, char ch) {
		if(x < 0) putchar('-'), x = -x;
		static int stk[30];
		int tt = 0;
		do stk[++tt] = x % 10, x /= 10; while(x);
		while(tt) putchar(stk[tt--] ^ 48);
		putchar(ch);
	}

	template <typename T>
	inline void write(T x) {
		if(x < 0) putchar('-'), x = -x;
		static int stk[30];
		int tt = 0;
		do stk[++tt] = x % 10, x /= 10; while(x);
		while(tt) putchar(stk[tt--] ^ 48);
	}

	inline void write(char x) {putchar(x);}
};
using namespace oi;
const int MAXN = 1e5 + 10;
int n, a[MAXN], l[MAXN], r[MAXN], m;
int  x, cnt;
ll ans;
bool st[MAXN];

void del(int x) {
	st[x] = true;
	r[l[x]] = r[x];
	l[r[x]] = l[x];
}

void solve() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) {
		x = read(); if (!x) continue;
		if (1ll * x * a[cnt] > 0) a[cnt] += x;
		else a[++cnt] = x;
	}
	n = cnt;
	cnt = 0;
	priority_queue<pii, vector<pii>, greater<pii>> q;
	for (int i = 1; i <= n; i++) {
		if (a[i] > 0) cnt++, ans += a[i];
		l[i] = i - 1, r[i] = i + 1;
		q.push({abs(a[i]), i});
	}
	while (cnt > m) {
		while (st[q.top().y]) q.pop();
		pii t = q.top(); q.pop();
		int x = t.y;
		if (l[x] != 0 && r[x] != n + 1 || a[x] > 0) {
			cnt--; ans -= abs(a[x]);
			a[x] += a[l[x]] + a[r[x]];
			del(l[x]), del(r[x]);
			q.push({abs(a[x]), x});
		} else {
			del(x);
		}
	}
	write(ans, '\n');
}

signed main() {
	// freopen("test.in", "r", stdin);
	// freopen("test.out", "w", stdout);

	int T = 1;
	// T = read();
	while(T--) solve();
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## soltion

反悔贪心例题，题意即求 $m$ 个不相交子段和的最大值。

我们先考虑，连续的一段正区间是必选的，连续的一段负区间若选也应全选，忽略没有贡献的 $0$。这样我们可以把给定序列缩成“正负正负正”的序列，若左或右端点是负数，一定不取，忽略即可。

对于处理完的序列，记正数个数 $now$，若$now \le m$，则取 $now$ 个正数即可。否则，我们需弃掉 $now-m$ 个数，我们分类讨论。
* 若弃掉一个正数，应使这个数尽可能小，相当于与左右两端负数合并，这样可以使 $now$ 减 $1$。
* 若选择一个负数，应使这个数尽可能大，这样相当于把左右两个正数和这个负数合并在一起，也可使 $now$ 减 $1$。

问题转化成选择 $now-m$ 个数使绝对值之和最小。

因为要维护绝对值最小，所以用优先队列，又有删除合并，所以用双向链表实现。

## 实现

先将所有数绝对值入队，统计出正数个数和正数之和。

合并操作我们可以这么写，删除左右两数并打上删除标记，将左右两数和加到中间数上，将中间数入队，具体结合代码。

因为序列在变化，所以我们还要判断边界情况。

```cpp
if ((!l[u]||r[u]==n+1)&&a[u]<0) continue;
```

注意一下序列端点的细节。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, a[100005], l[100005], r[100005], now, ans;
bool f[100005];
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;
signed main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i) {
		cin >> a[i];
		if (a[i]*a[i-1]>=0&&i>1)
			a[i-1]+=a[i],
			--i, --n; 
	}
	n-=(a[n]<0);
	for (int i=1; i<=n; ++i) {
		if (a[i]>0) 
			++now,
			ans+=a[i];
		l[i]=i-1;
		r[i]=i+1;
		q.push({abs(a[i]), i});
	}
	r[0]=1, l[n+1]=n;
	a[0]=a[n+1]=1e9;
	while (now>m) {
		while (f[q.top().second])
			q.pop();
		int u=q.top().second;
		q.pop();
		if ((!l[u]||r[u]==n+1)&&a[u]<0)
			continue;
		--now;
		ans-=abs(a[u]);
		a[u]+=a[l[u]]+a[r[u]];
		q.push({abs(a[u]), u});
		f[l[u]]=f[r[u]]=1;
		l[u]=l[l[u]];
		r[u]=r[r[u]];
		r[l[u]]=l[r[u]]=u;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Yoimiya_miii (赞：1)

# 题解：P10478 生日礼物
## 思路
蒟蒻上来直接想到 $O(nm)$ 的 dp，但是我们发现空间时间都会炸掉，于是我们考虑优化。

我们发现，当我们选择正数的时候，选择一堆连续的正数一定更优，所以我们在输入时可以把所有正数合并起来，负数同理：当我们选择了负数，我们一定要把这一堆负数全部选了，因为只有一堆负数后面出现正数这一块的权值才有可能更大。

因此，我们在输入时，合并连续的正数和负数，接下来就可以愉快地 dp 了。

我们考虑一个最朴素的 dp：记 $dp_{i,j,k}$ 表示前 $i$ 个数选 $j$ 块，并且当前的数选/不选的最优解（$k=0$ 表示不选，$k=1$ 表示选），则有以下状态转移方程：

$dp_{i,j,1} = \max(dp_{i-1,j-1,0},dp_{i-1,j,0}) + num_{i}$。

$dp_{i,j,0} = \max( dp_{i-1,j,0},dp_{i-1,j-1,1})$。

这样时间上有一定优化（因为在合并过程中我们初步缩小了 $n$）但是空间也会爆掉，我们继续优化。

我们发现，$dp_{i,j,k}$ 的值只和 $dp_{i-1}$ 有关，所以我们可以将第一维压缩成 $2$ 位，每一位表示 $i\bmod 2$，有效减少了空间复杂度。 

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,dp[2][1000005][2],tot = 1,a[100005],ans = 0;

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin >> n >> m;
	cin >> a[1];
	for(int i = 2,x;i <= n;i++){
		cin >> x;
		if(x == 0) continue;
		else if(x * a[tot] > 0) a[tot] += x;
		else a[++tot] = x;
	}
	memset(dp,0,sizeof(dp));
	for(int i = 1;i <= tot;i++){
		for(int j = 1;j <= min(i,m);j++){
			dp[i%2][j][1] = max(dp[(i-1)%2][j][1],dp[(i-1)%2][j-1][0]) + a[i];
			dp[i%2][j][0] = max(dp[(i-1)%2][j][0],dp[(i-1)%2][j][1]);
		}
	}
	for(int i = 1;i <= m;i++){
		ans = max(ans,max(dp[tot%2][i][1],dp[tot%2][i][0]));
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Sih_qwq (赞：1)

[洛谷题目链接](https://www.luogu.com.cn/problem/P10478)。

调了好久。。

## 思路

贪心。

显然对于一段连续的正数，都选是最优的。而一段连续的负数，如果想要将两端正数和这一段负数连成一整段，使选的段数减少 $1$，这一段负数不妨累和看成一个负数。

预处理合并都是正数的子段和都是负数的子段，于是成了一个正负数交替出现的数列。

如果正数的个数小于等于 $m$，代表全都能选上，直接输出并结束即可。再选负数就不优了。

数列的第一个数是负数不选，最后一个数是负数也不选。因为选了只会减少答案，而不能使答案更优。

于是剩下一个首尾都是正数、正负数交替出现的数列。

对于一个正数：

+ 不选，删掉。
+ 选。

对于一个负数：

+ 选，连上两边正数，三个数并成一个新的正数。
+ 不选。

那么对于一个不选的正数，可以完全不理这个数，还可以和两边负数一起并成一个新的负数。后者更优，因为完全不理这个数的话，需要在这个数的两边选，但是可能覆盖到这个数选会更优，当然并起来之后也可以不选这个数。为了避免分类讨论就把他并起来。

现在正数和负数的情况基本统一了，我们需要考虑的问题是要选哪些数并起来更优。

对于一个要合并的负数，显然这个数的数值越大，花费越小，答案越优。

对于一个要合并的正数，显然这个数的数值越小，损耗越小，答案越优。

于是可以得出按照绝对值排序最优。由于不论是花费还是损耗都是减少答案，所以需要正负数一起考虑，把数列按照绝对值排序塞到一个堆里。

上述合并需要快速查询到一个数相邻的数，还需要删除一个数，可以手写链表，也可以并查集实现。代码给出的是手写链表。

答案统计的话，由于不论是正负数都是减小答案，所以在删数之前把所有正数累和，合并的过程中减去当前数的绝对值就好了。

注意链表实现的细节，链表头之前与链表尾之后的数需要设成无穷大，避免意外入堆。遇到表头或表尾为负数要跳掉。因为有删除操作，需要记录当前数有没有被删除。注意 $m$ 可能为 $0$。

有其他情况过不了的话可以看讨论区中的 hack 或是自己对拍。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long 
#define N 1000010
int n, m, tot = 1, ls[N], rs[N];
bool vis[N];
ll a[N], ans, b[N];
#define PLL pair < ll, int >
#define fi first
#define se second
priority_queue < PLL, vector < PLL >, greater < PLL > > q;
int main() {
	scanf("%d %d", &n, &m);
	bool fl = 1;
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", a + i);
		if (a[i] > 0) fl = 0;
	}
	if (fl) return puts("0"), 0; // 可以一个也不选
	ll sum = 0, cnt = 0;
	for (int i = 1; i <= n; ++i) {
		if (a[i] == 0) continue; // 注意 0！！
		if (a[i] < 0) {
			if (b[tot] > 0) ++tot;
		} else {
			if (b[tot] < 0) ++tot;
		}
		b[tot] += a[i];
	}
// 预处理数列
	for (int i = 1; i <= tot; ++i) 
		if (b[i] > 0) ++cnt, sum += b[i]; // 正数累和，cnt 表示正数个数
	if (cnt <= m) return printf("%lld", sum), 0;
	
	if (b[1] <= 0) {
		for (int i = 1; i < tot; ++i) b[i] = b[i + 1];
		--tot;
	}
	if (b[tot] <= 0) --tot; // 过滤第一个数和最后一个数是负数的情况，也可以再后面判断
	
	for (int i = 2; i < tot; ++i) ls[i] = i - 1, rs[i] = i + 1;
	rs[1] = 2, ls[tot] = tot - 1;
	rs[0] = 1, ls[tot + 1] = tot; 
	ls[0] = 0, rs[tot] = tot + 1;
// ls 表示左边的数 rs 表示右边的数
	b[0] = b[tot + 1] = 2147483647; 
	for (int i = 1; i <= tot; ++i) q.push({ abs(b[i]), i })/*, cout << b[i] << " " << i << endl*/;
	while (cnt > m) {
		PLL tmp = q.top();
		q.pop();
		int x = tmp.se;
		if (vis[x]) continue;
		int l = ls[x], r = rs[x];
		if ((l <= 0 || r <= 0 || r >= tot + 1) && b[x] <= 0) continue;
		--cnt;
		b[x] += b[l] + b[r]; // 合并
		vis[l] = vis[r] = 1;
		ls[x] = ls[l], rs[x] = rs[r];
		rs[ls[l]] = x, ls[rs[r]] = x;
		sum -= tmp.fi;
		q.push({ abs(b[x]), x });
	}
	printf("%lld", m ? sum : 0); // 注意 m 可能为 0
	return 0;
} 
```

祝大家 NOIP RP++！

---

## 作者：fish_love_cat (赞：0)

注意到把数列 $A$ 转化为正负交替的形式不影响答案，把 $A$ 中的 $0$ 忽略也不影响答案。设转化后的数列为 $B$，其中有 $c$ 个正数，它们的和是 $s$。显然 $B$ 中没有 $0$。

+ 当 $c\le m$ 时，答案就是 $s$。
+ 当 $c>m$ 时，考虑将 $c$ 变小，也就是把某些正数合并消失。也就是将 $b_{i-1},b_i,b_{i+1}$ 替换成三者之和。我们思考如何计算一次合并的贡献。
  + 当 $b_i>0$ 时，显然不会合并以后加入，最优解是不取，$s$ 会减去 $b_i$。
  + 当 $b_i<0$ 时，显然合掉以后 $s$ 会加上 $b_i$。
+ 可以发现每一步都让 $s$ 减去了 $|b_i|$。

反复执行上述直至 $c\le m$。
 
我们要使结果尽量大，那么就要让每次操作的 $|b_i|$ 尽量小。可以使用优先队列来维护。

至于上下家，我们可以套一个链表维护。

注意特判链头和链尾，以及出队时记得判断是不是已经合掉了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int shang[100005],xia[100005];
int a[100005],b[100005],top,ans,flc;
struct fish{
	int x,id;
	bool operator<(const fish &wssb)const{
		return abs(x)>abs(wssb.x);
	}
};
priority_queue<fish>q;
bool flag[100005];
signed main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    for(int i=1;i<=n;i++){
        if(a[i]){
            if(top){
                if(b[top]<0&&a[i]>0||b[top]>0&&a[i]<0)b[++top]=a[i];
                else b[top]+=a[i];
            }else b[++top]=a[i];
        }
    }
    b[0]=b[top+1]=1e9+7;
    for(int i=1;i<=top;i++)
    if(b[i]>0)ans+=b[i],flc++;
    for(int i=1;i<=top;i++)
    q.push({b[i],i}),shang[i]=i-1,xia[i]=i+1;
    while(flc>m){
        int f=q.top().x,s=q.top().id;
        q.pop();
        if(flag[s])
        continue;
        if(shang[s]!=0&&xia[s]!=top+1||b[s]>0){
            ans-=abs(b[s]),
            flag[shang[s]]=flag[xia[s]]=1,
            b[s]+=b[shang[s]]+b[xia[s]],
            shang[s]=shang[shang[s]],
            xia[shang[s]]=s,
            xia[s]=xia[xia[s]],
            shang[xia[s]]=s;
            q.push({b[s],s}),
            flc--;
        }
    }
    cout<<ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/list?pid=P10478&user=754021)。

---

## 作者：bianshiyang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10478)

本篇篇幅较长，细节处证明居多，是本蒟蒻刚开始学习反悔贪心的笔记，希望能让很多初学者更好理解一点，也希望各位大佬可以耐心看完。

# 分析
感觉有点贪心的味道，但是没啥办法可以一直贪下去，于是考虑 DP，结果发现由于取的块数的限制，使得设出来的状态是二维的，即 $f_{i,j}$ 表示前 $i$ 个数划分成 $j$ 个段所得到的最大代价，转移很好写，但状态数已经是 $O(n^2)$ 的了，所以 DP 做不了，然后就猜到了反悔贪心，可能是因为之前做过[这题](https://www.luogu.com.cn/problem/P3620)，感觉有点像吧。

~~不得不说，发明反悔贪心的人绝对是个天才~~。

建议之前没有做过反悔贪心的可以去看看[这题](https://www.luogu.com.cn/problem/P1484)，因为这个东西确实很奇妙，第一次接触可能不太好理解。

反悔贪心，顾名思义就是说在贪心的过程中可以进行撤回之前某一步操作，这也使得这个算法应用场景并不是很多，因为绝大多题目是很难进行撤回操作的，而且这个算法套路性也比较强。

一般撤回操作要和贪心操作是类似的，这样子我们直接进行贪心过程就可以不用考虑哪几步要贪心，哪几步要撤回，一直做下去就是最优的。常用数据结构就是堆（这里也叫做反悔堆）和链表（支持快速插入删除元素）等，其实直接用 `set` 代替好像更方便点吧。

至于哪些题可以使用反悔贪心，还需要多刷题找感觉。不过有一类题目大概率可以用反悔贪心，就是只贪心一步是好想的，可能会分几类，然后之后就很复杂，但是撤回操作也是好想的，也就是说可以找到一个等价的东西把第一步换回来，且所耗费的代价与操作的代价相等，或者说可以在第一步分的某一类里找到与第一步相反的操作。可能觉得云里雾里？看看在这题怎么体现的。

回到本题，一个比较显然的贪心就是对于一大段正数或者一大段负数肯定要么一起选，要么一起都不选。原因就是如果一大段正数不选完，那么选完它会更优；而如果一大段负数不选完，那么不选它一定更优，其实选负数是为了把与它相邻的两正数段合并在一起，所以这种情况下一定要把这个负数段全部选完更优（不然正数段无法合并在一起）。所以我们可以把所有连续的正数合并在一起，所有连续的负数合并在一起。接下来的叙述都是建立在合并完的序列上，也就是序列里正数与负数交替出现，将这个序列记为 $a$。

想到这里好像没啥思路了，但是可以发现如果记正数个数为 $p$，那么若 $p\le m$，则把所有正数选完一定最优。

而如果 $p>m$，那么我们可以理解为把正数全部选完再撤回一些操作。发现此时撤回一步操作是好实现的，可以直接贪心，也就是说当 $p=m+1$ 的时候，我们可以选择直接删除一个最小正数（定义其为第一类操作），或者合并一个最大负数两边的正数（连同这个负数一起）（定义其为第二类操作）。这就符合上文说的“只贪心一步是好想的，可能会分几类”，此处分了两类。

若记所有正数和为 $S$，假设最小的正数为 $a_i$，最大的负数为 $a_j$，那么第一类操作会使得答案变为 $S-a_i$，第二类操作会使得答案变为 $S+a_j$。乍一看两者没啥联系，一个取最小值，一个取最大值，一个是加号，一个是减号，但是请不要忘记一个是正数一个是负数。我们会惊讶的发现，对两者取绝对值之后竟然变统一了，即都是取最小的绝对值进行更新，并且更新之后的值 $S-|a_i|$ 与 $S-|a_j|$ 形式上完全统一，所以我们可以按照 $a$ 中的绝对值进行排序，每次取出最小的元素来更新答案即可。但是按照此方法一直贪心肯定有问题，因为每次操作都会使得 $a$ 序列发生改变而对后续操作产生影响，不再可以贪心，并且情况会越来越复杂。

此时我们可以考虑撤回操作了，对于第一类操作，撤回的意义在于 $a_i$ 与其他正数合并比直接删除它更优，而这样的合并不会发生在只与其某一边相邻的正数合并（此处相邻指忽略负数之后的相邻），一定是跨过其两侧相邻正数的区间，也就是说与 $a_i$ 合并的数要同时包含 $a_{i-2}$ 和 $a_{i+2}$。以左边为例，如果最优解只包含 $a_{i-2}$ 那么此次操作与直接对 $a_{i-1}$ 进行第二类操作是等价的，而根据贪心，既然之前没有进行这样子的操作说明其不够优秀，故在此处它也不优秀。右边同理。所以回撤之后 $a_{i-1}$ 与 $a_{i+1}$ 要么同时被选，要么同时不被选（同时选表示 $a_i$ 与 $a_{i-2}$ 与 $a_{i+2}$ 合并，即撤回操作，不同时选表示不撤回，保留第一类操作）。

那么我们可以每次进行操作一之后把其两侧的负数 $a_{i-1}$ 与 $a_{i+1}$ 合并在一起，也就是添加一个价值为 $a_i+a_{i-1}+a_{i+1}$ 的元素，并把这两个负数从原序列删去。由于此时 $a_{i-1}$ 和 $a_{i+1}$ 的绝对值要大于 $a_i$（否则之前就会对 $a_{i-1}$ 和 $a_{i+1}$ 其中之一进行第二类操作，从而删除 $a_i$），那么 $a_i+a_{i-1}+a_{i+1}$ 就是一个负数。如果我们某一次操作选择这个合并元素，即对 $a_i+a_{i-1}+a_{i+1}$ 进行第二类操作（满足上文所述“可以在第一步分的某一类里找到与第一步相反的操作”），答案就会变为 $S-|a_i+a_{i-1}+a_{i+1}|=S+a_i+a_{i-1}+a_{i+1}$，而之前对 $a_i$ 进行了第一类操作，也就是说此时的 $S$ 已经减去了 $|a_i|$，这样子总体答案就增加了 $a_{i-1}+a_{i+1}$，即减去了 $|a_{i-1}|+|a_{i+1}|$，这与直接合并 $a_{i-2} a_{i-1} a_i a_{i+1} a_{i+2}$ 的答案是等价的。而更巧妙的是我们删除了两个元素，而且正好进行了两次操作（对 $a_i$ 进行第一类操作和对 $a_{i-1}+a_i+a_{i+1}$ 进行反悔操作），满足上文所述“可以找到一个等价的东西把第一步换回来，且所耗费的代价与操作的代价相等”，这样子，每一次第一类操作都可以通过一个第二类操作等效回来，保证了反悔贪心的正确性。

对于第二类操作的撤回操作是同理的。可以证明每一个进行操作的 $a_j$，$a_{j-1}$ 和 $a_{j+1}$ 一定同时被选或者同时不被选，证明原理是类似的，留给读者思考。而我们也可以类比上面的方法，每次对 $a_j$ 进行一次第二类操作，我们就把 $a_{j-1}+a_j+a_{j+1}$ 当成一个新元素，并且删除 $a_{j-1}$ 与 $a_{j+1}$，而由于 $a_{j-1}+a_j+a_{j+1}$ 一定为正数（此处证明同上），所以某次如果选择这个元素，即对 $a_{j-1}+a_j+a_{j+1}$ 进行第一类操作，那么答案就会变为 $S-|a_j+a_{j-1}+a_{j+1}|=S-a_j-a_{j-1}-a_{j+1}$，同理这里的 $S$ 在之前对 $a_j$ 进行第二类操作时已经减少了 $|a_j|$ 即增加了 $a_j$，此时整体答案减少 $a_{j-1}+a_{j+1}$ 与直接删除 $a_{j-1}$ 和 $a_{j+1}$ 是等价的，且操作次数与删除元素个数相等均为二。

至此，反悔贪心的证明就全部结束，希望这大段证明能对大家有帮助。

# 代码实现
有几处细节需要说明，首先对于原序列中的 $0$，可以直接删去不影响答案。其次对于每次对序列两端的元素进行，如果值为负，那么直接跳过不会对答案产生贡献，因为选负数是为了连接两端正数，而某一侧没有正数所以不选它一定更优。但是这个特判不可以在贪心之前直接删除两端的负数，因为之后会对 $a$ 序列进行若干次修改使得其中元素值的正负发生变化，所以这个判断只能便贪心边进行。
```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef pair<int,int> PII;
const int N=1e5+10;
int n,m,a[N],b[N],cnt,ans;
int pre[N],nxt[N];//链表
bool vis[N];
priority_queue<PII,vector<PII>,greater<PII> > q;//小根反悔堆，这里用set也可以

void Del(int x)//删除操作
{
	if(x<1||x>n) return;//因为堆里面特判了，所以这行删去也可以A
	vis[x]=1;//堆的懒惰删除法，和Dijkstra的删除原理差不多
	nxt[pre[x]]=nxt[x];
	pre[nxt[x]]=pre[x];
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		if(!a[i]) continue;
		if(i==1||(long long)a[i]*b[cnt]<0) b[++cnt]=a[i];//这里a[i]*b[cnt]不可以写成a[i]*a[i-1]，因为可能a[i-1]是0，就会挂
		else b[cnt]+=a[i];
	}//b中存储的是合并后的值
	n=cnt;cnt=0;
	for(int i=1;i<=n;i++) a[i]=b[i];
	for(int i=1;i<=n;i++)//堆和链表初始化
	{
		pre[i]=i-1,nxt[i]=i+1;
		q.push(make_pair(abs(a[i]),i));
		if(a[i]>0) ans+=a[i],cnt++;
	}
	while(cnt>m)
	{
		PII u=q.top();q.pop();
		if(vis[u.se]) continue;
		if((pre[u.se]>=1&&nxt[u.se]<=n)||a[u.se]>0)//边界处的负数直接不用管，这个不可以在贪心之前直接判掉
		{
			ans-=u.fi;cnt--;
			a[u.se]+=a[pre[u.se]]+a[nxt[u.se]];
			q.push(make_pair(abs(a[u.se]),u.se));//这里记得加上绝对值
			Del(pre[u.se]);Del(nxt[u.se]);//删除左右节点
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：haochengw920 (赞：0)

反悔贪心错误率还是太高了，给一个不用动脑子的方法。

这道题看到题的第一眼想到的应该是 $O(nm)$ 的 DP 吧？但是显然不能过。

考虑当正数数量大于 $m$ 时，选 $m$ 段一定不劣，于是简单特判转换成刚好选 $m$ 个。

然后发现无论是把一段正负正拆开，还是另选一段正数，决策都是独立的，于是 DP 是上凸的。

直接上 wqs 二分就好了，很卡常，但是把斜率上界开小一点发现能过。

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define R register
#define INF (0x3f3f3f3f)
#define rep(i, l, r) for(R int i(l); i <= (r); ++ i) 
#define per(i, r, l) for(R int i(r); i >= (l); -- i) 
using namespace std;

namespace Fast_OI {
	char buf[1000000], *p1 = buf, *p2 = buf, obuf[1000000], *p3 = obuf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
	#define putchar(x) (p3-obuf<1000000?*p3++=x:(fwrite(obuf,1,p3-obuf,stdout),p3=obuf,*p3++=x))
	inline int read() {
		int x = 0; bool f = 1; char c = getchar();
		while (!isdigit(c)) { if (c == '-') f = 0; c = getchar(); }
		while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
		return f ? x : -x;
	}
	inline void write(int x) {
		if (x < 0) putchar('-'), x = -x;
		if (x > 9) write(x / 10);
		putchar(x % 10 + 48);
	}
} using namespace Fast_OI;

const int N = 100005;

int n, m;
int a[N], tot_sum;
bool Prew_check() {
	int ct = 0, sum = 0;
	rep(i, 1, n) 
		if (a[i] > 0) 
			tot_sum += a[i], ++ ct;
	if (ct > m) return false;
	return write(tot_sum), putchar('\n'), true;
} 

struct Node {
	int val, ct;
	inline Node() : val(-INF), ct(-INF) {}
	inline Node(const int &_val, const int &_ct) : val(_val), ct(_ct) {} 
	inline bool operator < (const Node &y) const {
		return (val ^ y.val) ? val < y.val : ct < y.ct;
	} 
	inline Node operator + (const int &x) const {
		return Node(val + x, ct);
	}
	inline Node operator + (const Node &x) const {
		return Node(val + x.val, ct + x.ct);
	}
}dp[N]; 
class Segment_tree {
	#define lc (u << 1)
	#define rc (u << 1 | 1)
	private : 
	Node mx[N << 2], plz[N << 2];
	inline void push_up(int u) {
		mx[u] = max(mx[lc], mx[rc]);
	}
	inline void push_down(int u) {
		Node tg = plz[u]; plz[u] = Node(0, 0);
		mx[lc] = mx[lc] + tg, plz[lc] = plz[lc] + tg;
		mx[rc] = mx[rc] + tg, plz[rc] = plz[rc] + tg;
	}
	public : 
	void Build(int u = 1, int l = 0, int r = n) {
		mx[u] = Node(); plz[u] = Node(0, 0);
		if (l == r) return;
		int mid = (l + r) >> 1;
		Build(lc, l, mid);
		Build(rc, mid + 1, r);
	}
	void Modify(int p, Node x, int u = 1, int l = 0, int r = n) {
		if (l == r) return mx[u] = x, void();
		push_down(u); int mid = (l + r) >> 1;
		if (p <= mid) Modify(p, x, lc, l, mid);
		else Modify(p, x, rc, mid + 1, r);
		push_up(u);
	}
	void Add(int bg, int nd, int x, int u = 1, int l = 0, int r = n) {
		if (bg <= l && r <= nd) {
			mx[u] = mx[u] + x, plz[u] = plz[u] + x;
			return;
		} push_down(u); int mid = (l + r) >> 1;
		if (bg <= mid) Add(bg, nd, x, lc, l, mid);
		if (nd > mid) Add(bg, nd, x, rc, mid + 1, r);
		push_up(u);
	}
	Node Query(int bg, int nd, int u = 1, int l = 0, int r = n) {
		if (bg <= l && r <= nd) return mx[u];
		push_down(u); int mid = (l + r) >> 1; Node res;
		if (bg <= mid) res = max(res, Query(bg, nd, lc, l, mid));
		if (nd > mid) res = max(res, Query(bg, nd, rc, mid + 1, r));
		return res;
	}
	#undef lc
	#undef rc
}st;
Node DP(int del) {
	st.Build(); dp[0] = Node(0, 0); 
	st.Modify(0, dp[0]); Node mx = dp[0]; 
	rep(i, 1, n) { 
		st.Add(0, i - 1, a[i]); 
		dp[i] = st.Query(0, i - 1) + Node(-del, 1); 
		mx = max(mx, dp[i]); st.Modify(i, mx); 
	} return mx; 
}
int Binary() {
	int ans = 0; Node res;
	int l = -1, r = tot_sum + 1, mid; // 开成 1e8 就过了
	while (l + 1 < r) {
		mid = (l + r) >> 1; res = DP(mid); 
		if (res.ct > m) l = mid;
		else r = mid, ans = res.val + mid * res.ct;
	} return ans;
}


signed main()
{
	n = read(), m = read();
	rep(i, 1, n) a[i] = read();
	if (Prew_check()) return fwrite(obuf,1,p3-obuf,stdout), 0;
	write(Binary()), putchar('\n');
	return fwrite(obuf,1,p3-obuf,stdout), 0;
} 
```

---

## 作者：GXZJQ (赞：0)

# P10478 生日礼物 题解

[题目链接](https://www.luogu.com.cn/problem/P10478)

## 题目分析

首先，我们要使 $m$ 段的和尽量大，首先需要选 $m$ 段，并使得 $m$ 段尽量都为整数。如果整数段数 $cnt \leq m$ 的话，那么我们全部选上即可，而如果 $cnt>m$ 的话，那么我们则需要删除部分段，而对于删除我们则有下面两个操作可选：

设 $k=cnt−m$，现在我们的问题可以转化为，使我们删除的 $k$ 段尽量地小。

1. 删除 $1$ 段整数

2. 合并 $j$ 段整数与 $j−1$ 段负数


而对于操作一来说相当于减去 $a_i$，对于操作二来说相当于减去 $\vert a_i \vert$。

在这里我们选择的两段肯定不相连（如果选了两端相连的相当于选一段正一段负，一定不会是答案）。

而到此这个问题可以转化为[这道题](https://www.luogu.com.cn/article/r4v0k71u)了，可以通过数据备份这道题的做法去处理这个子问题。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
const int maxn = 100010;
int n, m, ans, cnt, k = 1, a[maxn], l[maxn], r[maxn];
bool vis[maxn];
priority_queue<PII, vector<PII>, greater<PII> > heap;
void del(int x) {
	r[l[x]] = r[x];
	l[r[x]] = l[x];
	vis[x] = true;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i ++ ) {
		int x;
		cin >> x;
		if ((long long)a[k] * x < 0) a[ ++ k] = x;
		else a[k] += x;
	}
	n = k;
	for (int i = 1; i <= n; i++) {
		if (a[i] > 0) {
			ans += a[i];
			cnt++;
		}
		l[i] = i - 1;
		r[i] = i + 1;
		heap.push({abs(a[i]), i});
	}
	while (cnt > m) {
		while (vis[heap.top().second])heap.pop();
		PII v = heap.top();
		heap.pop();
		if (l[v.second] != 0 && r[v.second] <= n || a[v.second] > 0) {
			ans -= v.first;
			cnt--;
			int left = l[v.second], right = r[v.second];
			a[v.second] += a[left] + a[right];

			heap.push({abs(a[v.second]), v.second});
			del(left);
			del(right);
		}
	}
	cout << ans;
	return 0;
}

```

---


# [GCJ 2019 Qualification] Dat Bae

## 题目描述

一个研究联盟为他们的新数据中心建立了一个新的数据库系统。该数据库由一台主控计算机和 $N$ 台工作计算机组成，工作计算机的编号从 $0$ 到 $N-1$。每台工作计算机只存储一位信息……这看起来似乎很浪费，但这些数据非常重要！

你被雇佣来评估数据库的以下指令：

- TEST\_STORE <bits>：主控计算机读取 <bits>，这是一个长度为 $N$ 的二进制字符串，并将第 $i$ 位发送给第 $i$ 个工作计算机进行存储。随后，主控计算机会从工作计算机中读取这些位，并按照输入时的顺序返回给用户。

在正常情况下，TEST\_STORE 应该返回与输入相同的二进制字符串，但不幸的是，有 $B$ 台工作计算机损坏了！

损坏的工作计算机能够正确存储分配给它们的位，但当主控计算机尝试从损坏的工作计算机读取数据时，将无法返回任何位。这导致 TEST\_STORE 操作只返回 $N-B$ 位，这些位是存储在未损坏工作计算机上的（按照它们的编号升序排列）。例如，假设 $N = 5$，第 0 和第 3 号工作计算机损坏（即 $B = 2$）。那么：

- TEST\_STORE 01101 返回 111。
- TEST\_STORE 00110 返回 010。
- TEST\_STORE 01010 返回 100。
- TEST\_STORE 11010 也返回 100。

出于安全原因，数据库被隐藏在地下山体仓库中，因此每次调用 TEST\_STORE 都需要很长时间。你的任务是在最多 $F$ 次 TEST\_STORE 调用内，找出哪些工作计算机损坏了。

### 交互协议

这是一个交互题。

程序开始时，应读取一行，包含一个整数 $T$，表示测试用例的数量。然后，你需要处理 $T$ 个测试用例。

对于每个测试用例，程序首先会读取一行，包含三个整数 $N$、$B$ 和 $F$，分别表示工作计算机的数量、损坏的工作计算机数量以及你可以发送的最多查询次数（如下所述）。

接下来，你可以向评测机最多发送 $F$ 行，每行包含一个长度为 $N$ 的字符串，每个字符为 0 或 1。每当你发送一行时，评测机会检查你是否已超过 $F$ 次调用。如果超过，评测机会返回一行，内容为 -1，然后结束所有通信并等待你的程序结束。否则，评测机会返回一个长度为 $N-B$ 的字符串，即 TEST\_STORE 操作的返回值，如上所述。

一旦你确定了 $B$ 个损坏的工作计算机的编号，可以通过发送一行 $B$ 个用空格分隔的整数（按升序排列）来提交答案。这一步不计入 $F$ 次调用之内。

如果你提交的 $B$ 个整数不是准确的损坏工作计算机编号，你将收到 Wrong Answer 判定，评测机会返回一行 -1，之后不再进行任何通信。如果你的答案正确，评测机会返回一行 1，随后进入下一个测试用例（或结束，如果这是最后一个测试用例）。

## 说明/提示

**交互样例**

以下交互过程符合测试集 1 的限制。

```
  t = readline_int()           // 读取 t=2
  n, b, f = readline_int_list()  // 读取 n=5, b=2, f=10
  printline 01101 to stdout    // 以下四次输出与题目描述中的例子一致
  flush stdout
  response = readline_str()    // 读取 response=111（此时我们已可确定答案，后续查询仅为示例）
  printline 00110 to stdout
  flush stdout
  response = readline_str()    // 读取 response=010
  printline 01010 to stdout
  response = readline_str()    // 读取 response=100
  printline 11010 to stdout
  flush stdout
  response = readline_str()    // 读取 response=100
  printline 0 3 to stdout      // 猜测答案。注意不要求用完所有 10 次查询。
  flush stdout
  verdict = readline_int()     // 读取 verdict=1，说明本测试用例正确！
  n, b, f = readline_int_list()  // 读取 n=2, b=1, f=10
  printline 01 to stdout       // 01 是一次查询，不是最终答案（如果想猜测只有 1 号损坏，应像下方一样输出）
  flush stdout
  response = readline_str()    // 读取 response=1
  printline 1 to stdout        // 随意猜测
  verdict = readline_str()     // 读取 verdict=-1
  exit                         // 退出以避免歧义性 TLE 错误
```

你可以使用本地测试工具在本地或平台上进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。

测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的表现。

**数据范围**

- $1 \leq T \leq 100$。
- $2 \leq N \leq 1024$。
- $1 \leq B \leq \min(15, N-1)$。

**测试集 1（14 分，公开）**

- $F = 10$。

**测试集 2（20 分，隐藏）**

- $F = 5$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
```

### 输出

```
```

# 题解

## 作者：ztd___ (赞：1)

妙妙交互题。

感觉这种题没有什么通用技巧啊，只能依题目而定。

- - -

先考虑 $F = 10$。

看到 $N \le 1024$ 即 $N \le 2 ^ {10}$，很容易想到操作次数和 $\log N$ 有关系。

想想怎样才能和 $\log$ 产生关系。

考虑这样的事实：  
将 $N$ 改写为二进制后，$N$ 的位数是 $\log N$ 级别的。 

于是我们想到：  
用二进制给计算机编号，最后把回答的结果整合回十进制，看看少了哪些数，就知道哪些计算机出了故障。

以第一组样例为例，我们将下面的矩阵一行一行地发送给评测机：  
```cpp
0 0 0 0 1
0 0 1 1 0
0 1 0 1 0
```

这个矩阵是什么意思呢？其实如果你竖着看，就会发现，第 $i$ 行其实是 $i - 1$ 的二进制表达形式。

也就是说，第 $1$ 列就是二进制下的 $0$，第 $2$ 列就是二进制下的 $1$，以此类推。

由于 $0$ 和 $3$ 出了故障，所以评测机返还给我们的是这样的：  
```cpp
0 0 1
0 1 0
1 0 0
```

整合一下，第一列是 $1$，第二列是 $2$，第三列是 $4$。缺少了 $0$ 和 $3$，所以答案就是 `0 3`。

代码应该很好写，就不给了。

或者直接看后面也行。

- - -

考虑如何做 $F = 5$。

容易观察到 $B$ 的值实际上很小，这也就意味着我们在传输信息的过程中会浪费很多列的信息。

怎么样才能防止浪费呢？

考虑下面的算法：当 $N$ 比较大的时候，我们将每若干列分成一块。我们取 $32$ 列分一块，这样我们每一块只存 $0$ 到 $31$ 的二进制表示，最后再逐块整合统计答案。

为什么这样能减少浪费，且不会产生难以辨别的漏洞呢？因为 $B$ 最大只有 $15$，而块长是 $32$，所以即使所有的 $B$ 在同一块内，也不会让其中一块内的计算机全部故障。

这就意味着，只要在整合后我们发现某一列的结果比后一列大，那就可以说明这两列肯定在不同的块内，我们也就可以统计答案了。

具体的，如果我们发现编号 $i$ 有缺失，那么这台计算机就是第 $(i + 32 \times \texttt{前面出现的完整的块数})$ 台。

- - -

由于我比较懒，所以当 $N$ 较小的时候我直接用了 $F = 10$ 的不分块代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
char s[1222][1222];
int flg[1222], z;
signed main() {
	int TT;
	cin >> TT;
	while (TT--) {
		memset(flg, 0, sizeof(flg));
		int n, b, f;
		cin >> n >> b >> f;
		if (n > 32) {
			for (int i = 1; i <= 5; i++) {
				for (int j = 0; j < n; j++)
					cout << (((j % 32) >> (5 - i)) & 1);
				cout << endl;
				for (int j = 1; j <= n - b; j++) cin >> s[j][i];
			}
			int lst = -1, nct = 0;
			for (int i = 1; i <= n - b; i++) {
				int x = 0;
				for (int j = 1; j <= 5; j++)
					x = x * 2 + s[i][j] - 48;
				if (x <= lst) {
					for (int j = 0; j < 32; j++)
						if (!flg[j]) cout << j + 32 * nct << " ";
					nct++;
					for (int j = 0; j < 32; j++) flg[j] = 0;
				}
				flg[x] = 1, lst = x;
			}
			for (int i = 0;i <= (n - 1) % 32;i++)
				if (!flg[i]) cout << i + 32 * nct << " ";
		} else {
			int cnt = 0, tmp = n - 1;
			while (tmp) tmp >>= 1, cnt++;
			for (int i = 1; i <= cnt; i++) {
				for (int j = 0; j < n; j++)
					cout << ((j >> (cnt - i)) & 1);
				cout << endl;
				for (int j = 1; j <= n - b; j++) cin >> s[j][i];
			}
			for (int i = 1; i <= n - b; i++) {
				int x = 0;
				for (int j = 1; j <= cnt; j++) x = x * 2 + s[i][j] - 48;
				flg[x] = 1;
			}
			for (int i = 0; i < n; i++)
				if (!flg[i]) cout << i << " ";
		}
		cout << endl;
		cin >> z;
	}
	return 0;
}
```

---


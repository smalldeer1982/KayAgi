# [Code+#1] 可做题

## 题目描述

qmqmqm希望给sublinekelzrip出一道可做题。于是他想到了这么一道题目：给一个长度为$n$的非负整数序列$a_i$,你需要计算其异或前缀和$b_i$,满足条件$b_1=a_1$,$b_i=b_{i-1}\ xor\ a_i(i \geq 2)$.

但是由于数据生成器出现了问题，他生成的序列$a$的长度特别长，并且由于内存空间不足，一部分$a_i$已经丢失了，只剩余$m$个位置的元素已知。现在qmqmqm找到你，希望你根据剩余的$a_i$,计算出所有可能的$a$序列对应的$b$序列中$\sum_{i=1}^n b_i$的最小值。


## 说明/提示

### 样例解释

已知的$a$序列为：$X,X,7,0,0$,其中$X$表示这个位置丢失了。一种可能的$a$序列为$0,7,7,0,0$,对应的$b$序列为$0,7,0,0,0$,和最小为$7$。可以证明不存在和更小的情况。

 ![](https://cdn.luogu.com.cn/upload/pic/12823.png) 

注意未知的$a_i$可以超过已知$a_i$的范围。

保证输入中所有的$i$不同，且满足$1 \leq i \leq n$。

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/卢政荣 命题/卢政荣 验题/何昊天

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5 3
4 0
3 7
5 0```

### 输出

```
7```

# 题解

## 作者：ycyaw (赞：8)

显然是让未填的一段区间前缀异或和除端点外均为$0$最优。

我们来仔细考虑一下端点的问题：

对于一段连续的全部知道的区间，我们可以通过调节这个区间左边第一个空来使得这个区间的贡献最小，这个空位的权值我们可以枚举二进制下每一位算出来。$($注意特判从$1$开始的区间$)$。

计算过了这段区间，然后我们可以马上在它右端点右侧放一个值，消除这一段的贡献，使得之后的空位异或前缀和均为$0$。

感觉有一个小小的问题，就是两段全部知道的区间之间如果只有一个空位，是不是会出问题？

仔细考虑一下，发现是不会的。每次计算一段连续的全部知道的区间，我们算出了这段区间左边第一个空的最优填法，然后再异或上消除左边一段连续的全部知道的区间应该填的值，就是这单个空的权值了。显然仍然是最优的。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=100005;
int n,m,ans;
struct node{
    int p,v;
    friend bool operator < (node A,node B){
        return A.p<B.p;
    }
}a[N];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
int solve(int l,int r){
    int res=0,now=0;
    if(a[l].p==1){//左边不能放 
        for(int i=l;i<=r;i++){
            now^=a[i].v;
            res+=now;
        }
    }
    else{
        for(int i=30;i>=0;i--){
            int cnt[2],tot[2];
            cnt[0]=tot[0]=0;
            cnt[1]=tot[1]=1;
            for(int j=0;j<=1;j++){
                for(int k=l;k<=r;k++){
                    tot[j]^=(a[k].v>>i)&1;
                    cnt[j]+=tot[j];
                }
            }
            res+=(1<<i)*min(cnt[0],cnt[1]);
        }
    }
    return res;
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        a[i].p=read();
        a[i].v=read();
    }
    sort(a+1,a+m+1);
    int now=1;
    while(now<=m){
        int last=now;
        while(now<=m&&a[now].p+1==a[now+1].p) now++;
        ans+=solve(last,now);
        now++;
    }
    write(ans);
    return 0;
}
```


---

## 作者：Mark_ZZY (赞：6)

```cpp
/*
因为对于异或运算,可以在未填位置填上0,使得前缀异或和为0,对于连的着一串0,
最后一位的数不应填0,不然就无法保证最小,采用枚举的方法算出这个数即可
*/ 
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;
	int n,m;
	struct node{int x,y;} a[100001];
	int f[5][40];
	LL ans;
bool cmp(node x,node y)
{
	return x.x<y.x;
}
LL work(int l,int r)
{
	LL sum=0;
	int tot=0;
	if(a[l].x==1)
	{
		for(int i=l;i<=r;i++)
			tot^=a[i].y,sum+=(LL)tot;
	}
	else
	{
		memset(f,0,sizeof(f));
		for(int i=0;i<=30;i++)//枚举第i位 
		{
			for(int j=0;j<=1;j++)//枚举放0或1 
			{
				tot=(j<<i);
				f[j][i]+=(tot!=0);//如果为1的话,就有一个贡献
				for(int k=l;k<=r;k++)
				{
					tot^=(a[k].y&(1<<i));//&运算:去掉前后的多余位,只留下第i位 
					f[j][i]+=(tot!=0);//如果为1的话,就有一个贡献
				}
			}
			sum+=(LL)(1<<i)*(LL)min(f[0][i],f[1][i]);//算出每一位0和1的贡献,去最小值 
		}
	}
	return sum;//sum即为最小的贡献,即所填的数 
}
int main()
{
	freopen("performable.in","r",stdin);
	freopen("performable.out","w",stdout); 
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d %d",&a[i].x,&a[i].y);
	sort(a+1,a+m+1,cmp);
	int p=1;
	while(p<=m)
	{
		int t=p;
		while(p<m&&a[p].x+1==a[p+1].x) p++;//找出连续的一串 
		ans+=work(t,p);//work就是算连续的一串前的数所对应的b数组应填什么 
		p++;
	}
	printf("%lld",ans);
}
```

---

## 作者：wjh2011 (赞：6)

由于我们可以在已确定的区间后放一个数抵消这个区间的贡献，所以只有在已确定区间两侧才放非零数。

显然，每一个区间的后面一定填这个区间的异或和以抵消这个区间的贡献。

我们再来考虑一个区间前面的数：

由于异或不进位，所以我们可以对每一位单独考虑。

对于第 $i$ 位的数，如果这个区间第 $i$ 位是 $0$ 的数的个数比第 $i$ 位是 $1$ 的数的个数多，那么这个区间前的数就是 $0$，否则就是 $1$，因为这样会让这个区间的贡献最小。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
#define int long long
int n, m, ans, tot, f[N][40], len[N];
pair<int, int> a[N];
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> a[i].first >> a[i].second;
    sort(a + 1, a + m + 1);
    int now = 0;
    for (int i = 1; i <= m; i++) {
        if (i == 1 || a[i].first != a[i - 1].first + 1) {
            tot++;
            now = 0;
        }
        now ^= a[i].second;
        for (int j = 0; j <= 30; j++) f[tot][j] += ((now >> j) & 1);
        len[tot]++;
    }
    for (int i = 1; i <= tot; i++)
        if (a[i].first == 1) for (int j = 0; j <= 30; j++) ans += (f[i][j] << j);
        else for (int j = 0; j <= 30; j++) ans += (min(f[i][j], len[i] - f[i][j] + 1) << j);
    cout << ans;
    return 0;
}
```

---

## 作者：Wilson_Lee (赞：2)

讲一个比较容易想到的做法。

这个按位 dp 应该不难想，毕竟每一位是独立的。

那么这里提供一个结论：每两个已知数之间最多 $2$ 个数不为 $0$ 。

由于是按位，假设有 $1\ \_\ \_\ \_\ \_\ \_\ \_\ \_\ \_\ \_\ 1$ ，那么明显和 $1$ 相邻的才能把 $1$ 异或掉，让它不对后面答案产生贡献。

删去多余的位置，需要 dp 的位只有不到 $3\times10^5$ 个，足以通过本题。

设该位置的数为 $num_i\in\{0,1,2\}$ ， $2$ 表示是没填的位置。

设 $dp[i][j]$ 表示填到第 $i$ 个数，当前异或值为 $j$ ，对答案产生的贡献最小值为多少。

则转移方程为：

$1.\ num_i=0$ 时：

$dp[i][0]=dp[i-1][0]$

$dp[i][1]=dp[i-1][1]+1$

$2.\ num_i=1$ 时：

$dp[i][0]=dp[i-1][1]$

$dp[i][1]=dp[i-1][0]+1$

$3.\ num_i=2$ 时：

$dp[i][0]=\min\{dp[i-1][0],dp[i-1][1]\}$

$dp[i][1]=\min\{dp[i-1][0],dp[i-1][1]\}+1$

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> pa;
const int MAXN=1e5+5;
pa a[MAXN];
int num[MAXN*5],dp[MAXN*5][2];
int main()
{
    //freopen("kzt.in","r",stdin);
    //freopen("kzt.out","w",stdout);
    int n,m;
    cin>>n>>m;
    int pos,val;
    for(int i=1;i<=m;++i) scanf("%d %d",&pos,&val),a[i]={pos,val};
    sort(a+1,a+m+1);
    long long ans=0;
    for(int j=0;j<=30;++j)
    {
        int cnt=0;
        if(a[1].first>1) num[++cnt]=2;
        if(a[1].second&(1<<j)) num[++cnt]=1;
        else num[++cnt]=0;
        for(int i=2;i<=m;++i)
        {
            if(a[i].first-a[i-1].first>=3) num[++cnt]=2,num[++cnt]=2;
            else if(a[i].first-a[i-1].first==2) num[++cnt]=2;
            if(a[i].second&(1<<j)) num[++cnt]=1;
            else num[++cnt]=0;
        }
        if(a[m].first<n) num[++cnt]=2;
        /*cout<<cnt<<endl;
        for(int i=1;i<=cnt;++i) printf("%d ",num[i]);
        cout<<endl;*/
        memset(dp,0x3f,sizeof(dp));
        if(num[1]==0) dp[1][0]=0;
        else if(num[1]==1) dp[1][1]=1;
        else if(num[1]==2) dp[1][0]=0,dp[1][1]=1;
        for(int i=2;i<=cnt;++i)
        {
            if(num[i]==0)
            {
                dp[i][0]=dp[i-1][0];
                dp[i][1]=dp[i-1][1]+1;
            }
            else if(num[i]==1)
            {
                dp[i][0]=dp[i-1][1];
                dp[i][1]=dp[i-1][0]+1;
            }
            else if(num[i]==2)
            {
                dp[i][0]=min(dp[i-1][0],dp[i-1][1]);
                dp[i][1]=min(dp[i-1][0],dp[i-1][1])+1;
            }
        }
        ans+=(long long)min(dp[cnt][0],dp[cnt][1])*(1<<j);
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：star_eternal (赞：2)

### 算法一
对于第1个数据，可以证明满足题目条件时两个$a$应该相同，答案为读入的那个$a$，直接输出即可。
### 算法二
对于第2个数据，只要让所有$a$全部为$0$即可最小，此时最小值为$0$。
### 算法三
对于第3个数据，$a$已经确定，可以直接计算出数组$b$然后求和输出。
### 算法四
对于第4、5个数据，可以暴力枚举所有$a$中的空格,然后计算$b$输出其中的最小值。
### 算法五
对于第6、7个数据，可以采用动态规划的方式解决。设 $f(i,k)$表示前$i$位的异或和为 $k$，$k\in{0,1}$时的答案，然后转移对于已确定位置的直接进行，未确定的位置枚举其是$0$还是$1$。复杂度$O(n)$
### 算法六
对于第8~10个数据，与算法五类似，只是将第二位改为维护当前异或和。复杂度$O\left(n \max{a_i}\right)$。
### 算法七、八
对于第11~15个数据，若存在超过连续两个位置均为空格，此时必然是除第一个和最后一个空格外均为$0$（否则将这个$1$前移或后移，答案不会变差)。所以将每个这种情况均变为两个空格，此时序列长度为$O(m)$，然后套用算法五、六即可。复杂度$O\left(m \max{a_i}\right)$。
### 算法九
对于第16、17个数据，可以发现不同的异或位之间是相互无关，可以都达到最小的。所以对每一位采用算法五，然后乘对应的$2$的幂后相加即可。复杂度 $O\left(n \log\left( \max{a_i}\right)\right)$。
### 算法十
对于第18~20个数据，综合使用算法八和算法九的思想，即按位拆分后再删去多余空格。复杂度$O\left(m \log\left( \max{a_i}\right)\right)$。

```
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int Maxn = 5e5 + 10;
typedef long long ll;
const ll inf = 1e15;
ll f[Maxn][2], Maxv, ans;
struct data{
	int pos;ll v;
	data( int pos = 0, ll v = 0 ): pos(pos), v(v) {}
	inline bool operator < ( const data & a ) const{ return pos < a.pos; }
}d[Maxn];
int n, m;

inline ll dp( int x ) {
	int flag = 0;
	for( int i = 0; i <= m; i ++) f[i][0] = f[i][1] = inf;
	f[0][1] = f[0][0] = 0;
	if(d[1].pos == 1)f[0][1] = inf;
	for( int i = 1;i <= m; i++ ) {
        if ( d[i].pos - d[i-1].pos != 1) {
            ll t1 = f[i - 1][1];
            f[i - 1][1] = min( f[i-1][0] + 1, f[i - 1][1] + 1 ), f[i-1][0] = min( f[i-1][0], (ll)t1 ); 
            if(d[i].v & (1 << x)) f[i][0] = f[i - 1][1];f[i][1] = f[i-1][0] + 1;
            else f[i][1] = f[i - 1][1] + 1;f[i][0] = f[i-1][0];   
        }
        else{
            if (d[i].v & (1 << x)) f[i][0] = f[i-1][1];f[i][1] = f[i-1][0] + 1;
            else
                f[i][1] = f[i-1][1] + 1;f[i][0] = f[i-1][0];
        }
	}
	ll t = pow(2,x);
	return t * min(f[m][0],f[m][1]);
}
int main()
{
	freopen("p4060.in","r",stdin);
	scanf( "%d%d", &n, &m );
	for( int i = 1; i <= m; i++ ) scanf( "%d%lld", &d[i].pos, &d[i].v ), Maxv = max( Maxv, d[i].v );
	sort( d + 1, d + 1 + m );
	d[0].pos = 0;
	int Bit = log2( Maxv ) + 1;
	for ( int i = 0;i < Bit;i ++ ) ans += dp(i);
	printf( "%lld\n", ans );
	return 0;
}
```

---

## 作者：elijahqi (赞：1)

 http://www.elijahqi.win/2018/02/05/bzoj5108/ 
 http://blog.csdn.net/elijahqi/article/details/79260465
Description
qmqmqm希望给sublinekelzrip出一道可做题。于是他想到了这么一道题目：给一个长度为n的非负整数序列ai,你需
要计算其异或前缀和bi,满足条件b1=a1,bi=bi?1 xor ai(i≥2).但是由于数据生成器出现了问题，他生成的序列a
的长度特别长，并且由于内存空间不足，一部分ai已经丢失了，只剩余m个位置的元素已知。现在qmqmqm找到你，
希望你根据剩余的ai,计算出所有可能的a序列对应的b序列中∑=bi(1<=i<=N)的最小值。

Input
输入第一行两个非负整数n,m,分别表示原始序列a的长度及剩余元素的个数。
之后m行，每行2个数i,ai，表示一个剩余元素的位置和数值。
1<=N<=10^9,0<=M<=Min(n,10^5),0<=ai<=10^9
注意未知的 ai 可以超过已知 ai 的范围。
保证输入中所有的 i 不同，且满足 1 ≤ i ≤ n。

Output
输出一个整数表示可能的最小值

Sample Input
5 3
4 0
3 7
5 0
Sample Output
7
已知的 a 序列为： X, X, 7, 0, 0, 其中X表示这个位置丢失了。一种可能的 a 序列为
0, 7, 7, 0, 0, 对应的 b 序列为 0, 7, 0, 0, 0, 和最小为 7。可以证明不存在和更小的情况
HINT
来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。
Credit：idea/卢政荣　命题/卢政荣　验题/何昊天
Git Repo：https://git.thusaac.org/publish/CodePlus201711
本次比赛的官方网址：cp.thusaac.org
感谢腾讯公司对此次比赛的支持。
求异或前缀和的最小值 thuwc的试机题 我菜到现在才搞定 qwq 没看题解 有很多细节没太想清楚的 设dp[i][1/0] 表示我现在做到了第i位我这一位 为0/1的最小代价 我首先分开按位讨论 因为位与位之间是互不影响的 做的时候就递推直接搞就可以 但是注意 如果前一位是空的我随意添加数字来构造 注意我存在我当前位置和前一个位置只差一个的情况 这样的话我就需要特判 避免我这一位同时被我钦定为1或者0 如果紧挨着上一位 那么我必须直接从上一位继承过来 如果不是紧挨着我得按照可能出现的0，1情况枚举比较一下
```
#include<cmath>
#include<cstdio>
#include<algorithm>
#define N 110000
#define ll long long
#define inf 1LL<<60
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=gc();
    return x*f;
}
struct node{
    int v,pos;
}d[N];
ll dp[N][2],ans;int bin[40],n,m;
inline bool cmp(const node &a,const node &b){return a.pos<b.pos;}
inline void solve(int x){
    dp[0][0]=dp[0][1]=0;
    if (d[1].pos==1) dp[0][1]=inf;
    for (int i=1;i<=m;++i){
        if (d[i].pos-1!=d[i-1].pos){
        	ll t1=dp[i-1][1];
        	dp[i-1][1]=min(dp[i-1][0]+x,dp[i-1][1]+x);dp[i-1][0]=min(dp[i-1][0],(long long)t1);	
        	if (d[i].v&x){
        		if(d[i].pos-2==d[i-1].pos) dp[i][0]=dp[i-1][1];else 
            	dp[i][0]=min(dp[i-1][1],dp[i-1][0]+x);dp[i][1]=dp[i-1][0]+x;
        	}else{
        		dp[i][1]=dp[i-1][1]+x;dp[i][0]=dp[i-1][0];
        	}	
    	}else{
    		if (d[i].v&x){
            	dp[i][0]=dp[i-1][1];dp[i][1]=dp[i-1][0]+x;
        	}else{
            	dp[i][1]=dp[i-1][1]+x;dp[i][0]=dp[i-1][0];
        	}
		}
    }ans+=min(dp[m][0],dp[m][1]);
}	
int main(){
//	freopen("bzoj5108.in","r",stdin);
    n=read();m=read();int max1=0;
    for (int i=1;i<=m;++i) d[i].pos=read(),d[i].v=read(),max1=max(max1,d[i].v);
    sort(d+1,d+m+1,cmp);int nn=log2(max1);
    for (int i=0;i<=nn;++i) bin[i]=1<<i;
    for (int i=0;i<=nn;++i) solve(bin[i]);
    printf("%lld",ans);
    return 0;
}
/*
5 3
3 7
4 0
5 0
*/

```

---

## 作者：cosf (赞：0)

令 $p_i$ 表示从小到大第 $i$ 个被限制的位置。

由于没有限制的位置可以是任意值，所以，我们可以把原题划分成若干个子问题。

具体地，对于所有 $p_i + 1 \not= p_{i + 1}$，我们可以令前者所在的问题右端点为 $p_i$，后者的左端点为 $p_{i + 1} - 1$。对于剩下不属于任何一个子问题的人一点，可以赋恰当值使它的前缀和为 $0$。

这样，相当于给定序列 $a_2, a_3, \dots, a_n$，要求一个恰当的 $a_1$，使得 $\sum_{i=1}^n\bigoplus_{j=1}^ia_j$ 最小。

考虑拆位，并且令 $a'_i = \bigoplus_{j=2}^ia_j$（$a'_1 = 0$）以及 $c_0, c_1$ 分别表示 $a'_i$ 中 $0$ 和 $1$ 的个数，则每一位的贡献即 $a_1c_0 + (a_1 \oplus 1)c_1$。显然这个东西最小值等于 $\min\{c_0, c_1\}$。

注意：第一个子问题没有 $a_1$ 项，直接把前缀和加起来即可。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

#define MAXN 100005
#define MAXK 31

using ll = long long;

ll n, m;

struct Node
{
    int p;
    ll a;
} v[MAXN];

int c[MAXK];

int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> v[i].p >> v[i].a;
    }
    sort(v + 1, v + n + 1, [] (Node a, Node b) {
        return a.p < b.p;
    });
    int las = 0;
    ll res = 0;
    for (int i = 1; i <= n; i++)
    {
        if (v[i + 1].p != v[i].p + 1)
        {
            if (v[i].p == i)
            {
                ll cur = 0;
                for (int j = 1; j <= i; j++)
                {
                    cur ^= v[j].a;
                    res += cur;
                }
            }
            else
            {
                for (int k = 0; k < MAXK; k++)
                {
                    c[k] = 0; // 这里的 c 数组表示 c1
                }
                ll cur = 0;
                for (int j = las + 1; j <= i; j++)
                {
                    cur ^= v[j].a;
                    for (int k = 0; k < MAXK; k++)
                    {
                        if (cur & (1ll << k))
                        {
                            c[k]++;
                        }
                    }
                }
                for (int k = 0; k < MAXK; k++)
                {
                    res += (1ll << k) * min(c[k], i - las + 1 - c[k]);
                }
            }
            las = i;
        }
    }
    cout << res << endl;
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

考虑每一位分开考虑。

问题就变为：有一个 $0/1$ 序列，你需要对一些未确定的位置填上 $0/1$，使得所有位置的前缀异或和的代数和最小。

考虑已知信息的每一个连续段，可以记录有多少个是在**这个连续段前一个异或和**的基础上异或 $1$，有多少个和这个连续段前一个异或和相等，记为 $cnt_0$ 和 $cnt_1$。我们可以控制这个连续段前一个异或和是 $0/1$（因为它没有限制，可以为所欲为），得到 $\min\{cnt_1,cnt_0+1\}$ 的答案。而那些离已知信息比较远的位置，肯定可以通过调整自己变成 $0$，所以不予考虑。

注意从 $1$ 开始的连续段不能更改。因为它没有自由。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
struct NUM {int pos,a;}p[MAXN];
int n,m,res,pre;
vector<pair<int,int>> range;
int solve(int bit) {
	int ans=0;
	for(auto pr:range) {
		int l=pr.first,r=pr.second,_0=0,_1=0,sum=0;
		ffor(i,l,r) {sum^=p[i].a;if(sum&(1ll<<bit)) _1++; else _0++;}	
		ans+=min(_1,_0+1);
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) cin>>p[i].pos>>p[i].a;
	sort(p+1,p+m+1,[](NUM A,NUM B) {return A.pos<B.pos;});
	ffor(i,1,m) if(p[i].pos==i) pre^=p[i].a,res+=pre;
	int st=-1;
	ffor(i,1,m) if(p[i].pos!=i) {st=i;break;}
	if(st==-1) return cout<<res,0;
	ffor(i,st+1,m) if(p[i].pos!=p[i-1].pos+1) range.push_back({st,i-1}),st=i;
	range.push_back({st,m});
	ffor(i,0,31) res=res+(1ll<<i)*solve(i);
	cout<<res;
	return 0;
}
```

---

## 作者：raincity (赞：0)

## 分析
首先，我们可以想到尽量让不知道的位置的 $b$ 是 0，因为 $a \space xor \space a = 0$。

一旦遇到不知道的地方，就可以设为0，所以我们只需要考虑连续的知道的地方。

用按位考虑的常见 trick，假如在计算低往高第 $bit$ 位，遇到了从 $[i,j)$ 的已知 $a$。

显然这一位给这一段的贡献只由第 $a_{i-1}$ 的第 $bit$ 位决定。

扫一遍 $[i,j)$ 计算 $a_{i-1}$ 的第 $bit$ 位为 0 和 1 的贡献，累加较小的 $\times 2^{bit}$ 就可以了。

↑其实有问题

**当 $i=1$，$a_{i-1}$ 的第 $bit$ 位肯定是 0**，所以需要判断 $i$ 是不是0。65pts 大概率就是这个问题。

求 $[i,j)$ 就排一下序，然后双指针扫一下就行。

时间复杂度 $O(m\log m+m\log a)$。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long

using namespace std;

const int M = 1e5 + 5;
int n, m;
struct known {
	int pos, val;
	bool operator <(const known &nxt) const { return pos < nxt.pos; }
}a[M];

signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%lld%lld", &a[i].pos, &a[i].val);
	sort(a + 1, a + m + 1);
	int ans = 0;
	for (int bit = 0; bit <= 30; bit++) {
		for (int i = 1; i <= m; ) {
			int j = i + 1, res0 = 0, res1 = 1;
			while (a[j].pos == a[j - 1].pos + 1) j++;
			for (int k = i, st0 = 0, st1 = 1; k < j; k++) {
				int cur = (a[k].val >> bit) & 1;
				st0 ^= cur, st1 ^= cur;
				res0 += st0, res1 += st1;
			}
			if (a[i].pos == 1)
				ans += res0 << bit;
			else
				ans += min(res0, res1) << bit;
			i = j;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：7KByte (赞：0)

异或和按套路走，分开按位讨论。

对于每一位，只有$0/1$两种可能。

我们把连续的已知位合成一段，两段之间必然有未知位。

我们可以使未知位的 $b$ 都为 $0$ ，然后加上连续段内 $1$ 的贡献。

或者将连续段之前一位的 $b$ 改为 $1$，再加上连续段内 $0$ 的贡献。

需要特别注意一下从第$1$位开始的段没有选择，只有一种可能。

时间复杂度$\rm O(M\ \log\ \max\{a_i\})$。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 100005
using namespace std;
struct node{
	int x,y;
	bool operator<(const node o)const{return x<o.x;}
}a[N];
int n,m,X[32],Y[32],pre;long long ans=0;
void check(){
	rep(k,0,30)ans+=1LL*(1<<k)*min(X[k],Y[k]+1);
	memset(X,0,sizeof(X));
	memset(Y,0,sizeof(Y));
	pre=0;
}
int main(){
	scanf("%d%d",&n,&m);
	rep(i,1,m){
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	sort(a+1,a+m+1);
	int j=1;
	while(a[j].x==j){
		pre^=a[j].y;ans+=pre;
		j++;
	}
	rep(i,j,m){	
		if(a[i].x!=a[i-1].x+1)check();
		pre^=a[i].y;
		rep(k,0,30)if(1&(pre>>k))X[k]++;else Y[k]++;
	}
	check();printf("%lld\n",ans);
	return 0;
}
```

---


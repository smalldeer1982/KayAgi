# [yLOI2019] 棠梨煎雪

## 题目背景

> 岁岁花藻檐下共将棠梨煎雪，  
> 自总角至你我某日辗转天边。  
> 天淡天青，宿雨沾襟，  
> 一年一会信笺却只见寥寥数言。

——银临《棠梨煎雪》

## 题目描述

扶苏正在听《棠梨煎雪》的时候，@[spitfirekindergarten](https://www.luogu.org/space/show?uid=61795) 发来一道 [IOI2018 集训队作业题](http://uoj.ac/problem/425)：我切了这集训队题，辣鸡扶苏快过来做题。扶苏定睛一看，这不 s\* 题嘛，写了一发交上去才发现自己看错题目了。但是写完的代码不能浪费，于是就有了这道题。

歌词中的主人公与她的朋友一年会有一次互相写信给对方，一共通信了 $m$ 年。为了简化问题，我们认为她们每封信的内容都是一条二进制码，并且所有二进制码的长度都是 $n$。即每封信的内容都是一个长度为 $n$ 的字符串，这个字符串只含字符 ``0`` 或 ``1``。

这天她拿出了朋友写给她的所有信件，其中第 $i$ 年的写的信件编号为 $i$。由于信件保存时间过久，上面有一些字符已经模糊不清，我们将这样的位置记为 ``?``，``?`` 字符可以被解释为 ``0`` 或 ``1``。由于她的朋友也是人，符合人类的本质，所以朋友在一段连续的时间中书写的内容可能是相同的。现在她想问问你，对于一段连续的年份区间 $[l,r]$ 中的所有信件，假如朋友在这段时间展示了人类的本质，所写的是同一句话，那么这一句话一共有多少种可能的组成。也即一共有多少字符串 $S$，满足在这个区间内的所有信件的内容都可能是 $S$。

一个长度为 $n$ 的只含 ``0,1,?`` 的字符串 $A$ 可能是一个字符串 $B$ 当且仅当 $B$ 满足如下条件：

- $B$ 的长度也是 $n$ 。
- $B$ 中只含字符 ``0,1``。
- $A$ 中所有为 ``0`` 的位置在 $B$ 中也是 ``0``。
- $A$ 中所有为 ``1`` 的位置在 $B$ 中也是 ``1``。
- $A$ 中为 ``?`` 的位置在 $B$ 中可以为 ``0`` 也可以是 ``1``。

同时她可能会突然发现看错了某年的信的内容，于是她可能会把某一年的信的内容修改为一个别的只含 ``0``,``1``,``?`` 的长度为 $n$ 的字符串。

## 说明/提示

### 样例 1 解释

- 对于第一次询问，只有串 ``010`` 符合要求。
- 对于第二次询问，由于第二个串的第一位为 ``0``，第三个串的第一位为 ``1``，故没有串符合要求。
- 修改后将第三个串修改为 ``0??``。
- 对于第四次询问，有两个串符合要求，分别为 ``000`` 和 ``010``。
- 对于第五次询问，只有 ``010`` 符合要求。

故答案为 $1,0,2,1$，他们的异或和再异或 $0$ 的值为 $2$。

---

### 数据规模与约定

**本题采用多测试点捆绑测试，共有 7 个子任务**。

| 子任务编号 |  $m = $  |  $q = $   | $n = $ | 子任务分数 |
| :--------: | :------: | :-------: | :----: | :--------: |
|    $1$     |   $1$    |    $0$    |  $1$   |    $5$     |
|    $2$     |  $102$   |   $102$   |  $10$  |    $10$    |
|    $3$     |  $1003$  |  $1003$   |  $10$  |    $15$    |
|    $4$     |  $1004$  |  $10004$  |  $30$  |    $15$    |
|    $5$     | $100005$ | $500005$  |  $1$   |    $15$    |
|    $6$     | $100006$ |  $50006$  |  $30$  |    $10$    |
|    $7$     | $100007$ | $1000007$ |  $30$  |    $30$    |

对于全部的测试点，保证：
- $1 \leq m \leq 10^5 + 7$，$0 \leq q \leq 10^6 + 7$，$1 \leq n \leq 30$。
- $0 \leq opt \leq 1$，$1 \leq pos \leq m$，$1 \leq l \leq r \leq m$。
- $s_i, t$ 的长度均为 $n$ 且只含有字符 `0`,`1`,`?`。
- 输入字符串的总长度不超过 $5 \times 10^6$。数据在 Linux 下生成，即换行符不含 `\r`。

---

#### 提示

- 请注意常数因子对程序效率造成的影响。
- 请注意数据读入对程序效率造成的影响。
- 请注意输入的问号为嘤文问号，即其 ASCII 值为 $63$

注: 为减少错误做法的通过率，时限于 2020 年 7 月由 2000ms 改为 1500ms

## 样例 #1

### 输入

```
3 3 5
010
0?0
1?0
0 1 2
0 2 3
1 3 0??
0 2 3
0 1 3```

### 输出

```
2```

# 题解

## 作者：比利♂海灵顿 (赞：34)

# [yLOI 2019 棠梨煎雪](https://www.luogu.com.cn/problem/P5522)

用线段树维护两个合并规则不同的值对刚学 OI 的 MnZn 不是很友好，于是就有了这篇题解。

## 题意

给 $m$ 个长 $n$ 的 `0/1` 串，串中存在 `?` 字符表示既可以是 `0`，也可以是 `1`。

要求支持:

- 单点修改

  将指定串改为给出的新串。

- 区间查询

  查询一个区间内的串共同符合的已知 `0/1` 串数量。换句话说，如果有 $S$，使得一个区间内的串在 `?` 取合适字符的时候能完全匹配，求不同的 $S$ 的数量。

$n \leq 30$

输出所有查询操作的 `^` 和。

## 思路

先思考如何高效判断 `?` 不存在的时候，一个区间内的串是否一样。

因为 $n$ 的长度很短，考虑位运算，只要一个字符串的某一位是 `1`，那么其它串的这一位也必须是 `1`，否则不匹配，如果一个字符串某一位是 `0`，情况也一样。

因此，我们可以用一个整数存一个串。查询的时候，查询区间 `|` 和，结果中的 `1` 的位置表示 $S$ 中为 `1` 的位置。然后查询区间取 `~` 之后的 `|` 和，结果中 `1` 的位置表示 $S$ 中为 `0` 的位置。

接着将两个结果取 `&`，如果结果不为 $0$，则说明 `0` 和 `1` 有冲突，不匹配，否则就匹配。

对于整数的区间 $|$ 和，可以用 `ST 表` $O(1)$ 查询。如果需要修改，就使用线段树 $O(\log n)$ 修改或查询。

接下来推广到 `?` 存在的情况。

首先可以预见的是: 一位上状态有 $3$ 种，一个二进制位无法表达串中一位的信息，所以很显然一个整数存这个串是不够用的。

如果一个串某一位是 `?` 说明 $S$ 中，这一位不必填 `1`，也不必填 `0`，这时用两个整数存一个串，$a$ 的某一位为 `1` 表示这个位上必须填 `0`，$b$ 的某一位为 `1` 表示这个位上必须填 `1`。

仍然是区间查询 `|` 和，将 $a$ 和 $b$ 的 `|` 和相 `&`，如果结果不是 $0$，说明这些串已知位有冲突，本次查询的答案为 $0$。如果结果是 $0$，对他们取 `~` 的结果做 `&`，假设结果中有 `k` 个位置是 `1`，则本次查询结果为 $2^k$。

## 实现

线段树维护整数的 `|` 和。

容易发现，串中每一位的位置只要一一对应，相对位置关系不影响答案，所以为了降低代码难度，我们从右往左读 (最右边的是最高位)。

因为我们建树的时候使用的是先左儿子后右儿子的顺序遍历，所以叶节点代表的点的坐标一定单调递增，所以我们可以在每次遍历到叶结点的时候读入一个串，这也算是一个小优化了吧。

代码 (缺省源已省略):

```cpp
struct Node {
	unsigned Va, Vb;
	Node *LS, *RS;
} N[200100], *CntN(N - 1);
Node *Build(unsigned L, unsigned R) {
  Node *x(++CntN);
	if(L ^ R) {
    unsigned Mid((L + R)>>1);
    x->LS = Build(L, Mid);
    x->RS = Build(Mid + 1, R);
    x->Va = x->LS->Va | x->RS->Va;
    x->Vb = x->LS->Vb | x->RS->Vb;
	} else {
		while((Ch != '0') && (Ch != '1') && (Ch != '?')) Ch = getchar();
		unsigned Itmp(1);
		while((Ch == '0') || (Ch == '1') || (Ch == '?')) {
			if(Ch ^ '?') {
			  if(Ch ^ '1') x->Va |= Itmp;
        else x->Vb |= Itmp;
			}
			Ch = getchar(), Itmp <<= 1;
		}
	}
	return x;
}
void Qry(Node *x, unsigned L, unsigned R) {
	if((PL <= L) && (R <= PR)) { 
	  FindA |= x->Va, FindB |= x->Vb;
  } else {
    register unsigned Mid((L + R) >> 1);
    if(PR > Mid) {
      Qry(x->RS, Mid + 1, R);
    }
    if(PL <= Mid) {
      Qry(x->LS, L, Mid);
    }
  }
}
void Change(Node *x, unsigned L, unsigned R) {
	if(L ^ R) {
    unsigned Mid((L + R) >> 1);
    if(Pos <= Mid) {
      Change(x->LS, L, Mid);
    } else {
      Change(x->RS, Mid + 1, R);
    }
    x->Va = x->LS->Va | x->RS->Va;
    x->Vb = x->LS->Vb | x->RS->Vb;
  } else {
    x->Va = x->Vb = 0;
    while((Ch != '0')&&(Ch != '1')&&(Ch != '?')) Ch=getchar();
    register unsigned Itmp(1);
    while((Ch == '0')||(Ch == '1')||(Ch == '?')) {
      if(Ch ^ '?') {
        if(Ch ^ '1') x->Va |= Itmp;
        else x->Vb |= Itmp;
      }
      Ch=getchar(), Itmp <<= 1;
    }
	}
}
int main() {
	n = RD(),	m = RD(), q = RD();
	Bench = (1 << n) - 1;
	Build(1, m);
	for(register int i(1); i <= q; ++i) { 
    if(RD()) {
			Pos = RD();
      Change(N, 1, m);
		} else {
			PL = RD(), PR = RD(), FindA = FindB = 0;
      Qry(N, 1, m);
      if(!(FindA & FindB)) {
        register unsigned Tmp(((~FindA) & (~FindB)) & Bench), Cnt(1);
        while (Tmp) Cnt <<= 1, Tmp ^= LowBit(Tmp);
        Ans ^= Cnt;
      }
		}
	}
	printf("%u\n",Ans); 
	return 0;
}
```

## 树状数组

先说结论: 我们的思想不能使用树状数组。

事实上，既然是区间查询，单点修改，线段树就显得大材小用了，所以还可以尝试用树状数组做。

但是非常遗憾，因为 `|` 的特殊性，无法 $O(1)$ 推算一个点的改变对区间 `|` 和的影响，所以很难使用树状数组维护。如果强行使用，那单次修改也需要 $O(\log^2n)$ 的复杂度 (感性理解，~~读者自证~~，证明在后面)。

我发现题解中仍有巨佬使用树状数组过掉了此题，树状数组的做法是开 $90$ 个树状数组，用小常数的数据结构，乘上 $90$ 倍常数，是可以 AC 的。

分析原因，我们的线段树维护的是每一位有没有被确定是 `1` 或 `0`，但是 $90$ 个树状数组维护的是这一个区间内有多少 `1`，多少 `0`。换句话说，我们的算法将信息进行了压缩，而压缩后的数据是树状数组所不易维护的，因为它只能通过所有子区间合并而来。合并子区间的复杂度取决于一个节点被分成了多少子区间。线段树中，一个节点分成两个子区间，而数状数组，一个节点被分成的子区间数量取决于它 `LowBit` 的位置，是 $O(\log n)$ 的。这就是为什么我们合并线段树的节点的子区间更新当前节点信息需要 $O(1)$，但是树状数组需要 $O(\log n)$。因为二者的递归层数都是 $O(\log n)$，所以单次修改复杂度分别是 $O(\log n)$ 和 $O(\log^2n)$

区间查询貌似根本就不能做，树状数组查询的是两个前缀和，要想求答案，我们需要将两个前缀和做差，因为我们不能用两个数的 `|`，和其中的一个数，求出另一个数。

如果我们要直接合并对应的节点，发现根本找不到对应的节点集合，谈何维护? 至于原因，是因为树状数组每一位存的是它左边 `LowBit` 位的和，所以对于每个右边界，都存在一个以它为右边界的节点，我们可以将右边界规定后，不断移动右边界。左边界则不同，不一定每个左边界，都存在一个以它为左边界的节点。所以就有可能找不到对应节点来合并。

结论: 用树状数组实现本题解的想法，修改 $O(\log^2n)$，查询 $O(NO\_WAY)$

## 历史背景

首先感谢出题人 @[一扶苏一](https://www.luogu.com.cn/user/65363) 在我 OI 期间的指导，$2020$ 年暑假，扶苏给我们出了这道题，然后我们就全军覆没了，当时机房有巨佬使用 $90$ 棵线段树卡了过去，所以就有了题面下方修改时间的动作。

扶苏讲解之后，我调了一天，最后只有 $5'$ (没错，就是输出 $0$)，这道题也成了当时学校里口口相传的毒瘤题。

因为心理阴影，我一年没有动这道题，这也成了我 `尝试过的题目` 中三道中的一道。主要原因是位运算对当时刚学 OI $3$ 年的我比较混沌，于是调题的过程变成了开奖的过程，这里把 `|` 改成 `&`，那里把 `^` 改成 `|`，~~大大提升了组合数学能力~~。

一年后，我终于过了此题，撒花~

---

## 作者：一扶苏一 (赞：27)

# C [yLOI2019] 棠梨煎雪

## Background

岁岁花藻檐下共将棠梨煎雪

自总角至你我某日辗转天边

天淡天青 宿雨沾襟

一年一会信笺却只见寥寥数言

——银临《棠梨煎雪》

## Description

给定 $m$ 个长度为 $n$ 的可能含有 ``？`` 的 01 串，其中 ``?`` 既能代表 ``0`` 也能代表 ``1``， $q$ 次操作，每次给定一个区间，求有多少 01 串满足区间内的所有字符串都可以解释成该 01 串，或者单点修改某个字符串。

## Limitations

![qwq](https://cdn.luogu.com.cn/upload/pic/72304.png)

## Solution

子任务 $1$：

输出 $0$ 即可得分，期望得分 $5~pts$。

子任务 $2$：

考虑 $n$ 只有 $10$，因此可以 $O(2^n)$ 去枚举所有可能的串，然后对于每个询问 $O(m)$ 的逐个判定是否合法。时间复杂度 $O(qm2^n)$，期望得分 $10~pts$。

子任务 $3$：

考虑对于一段所有字符串的第 $x$ 个字符，一共有四种可能：确定为 $0$；确定为 $1$；都可以；都不可以。如果 $0/1$ 都不可以，则答案为 $0$，因为不会有任何一个字符串匹配该区间。如果确定为某个数，则这一位只有一种可能；否则这一位有两种可能。根据乘法原理，如果有 $a$ 个位置有两种可能，则本次询问的答案为 $2^a$。

因此对于每个询问，$O(nm)$ 地去遍历区间内所有字符即可。时间复杂度 $O(nmq)$，期望得分 $15~pts$。

子任务 $4$：

考虑 $n$ 只有 $30$，可以状压到 ``int`` 中。具体的，维护两个 ``int``，第一个 ``int`` 维护对应位是否确定是 $0$ 或 $1$，第二个 ``int`` 维护如果确定是 ``0`` 或 ``1`` 了那么具体是 ``0`` 还是 ``1``。

例如，对于单个字符串，它所有的为 ``?`` 的位置，在第一个 ``int`` 中对应位置是 ``0``，所有为 ``0`` 或 ``1`` 的位置，在第在个 ``int`` 中对应的位置是 ``1``，在第二个 ``int`` 中对应的位置是自身的值。

考虑 $a_1,~a_2$ 是询问的左端点到某个字符串之前所维护的两个 ``int``，$b_1,~b_2$ 是该字符串的两个 ``int``，现在合并这两个信息。

如果某一位置即不可以是 $1$，也不可以是 $0$，那么该字符串不为 ``?`` 的位置在 $b_2$ 中对应的值应该至少有一个和  $a_2$ 中对应位置的值且 $a_1$ 的该位置为 $1$，位运算可以表现为 $(a1~\&~b_1)~\&~(a_2~\oplus~b_2) ~\neq 0$，则该询问的答案为 $0$。

否则这两段信息可以合并：将他们已经确定字符的位置合并起来，然后将确定位置对应的值合并起来即可。于是 $a_1$ 对 $b_1$ 取或， $a_2$ 对 $b_2$ 取或即可。

最终该询问 $0/1$ 都可以的位置的个数即为 $a_1$ 中 $1$ 的个数。

时间复杂度 $O(mq)$，期望得分 $15~pts$

子任务 $5$：

由于 $n$ 只有 $1$，问题变成了求某个区间内的字符是不是全是 ``0``，全是 ``1``，全是 ``?`` 或 ``0`` 和 ``1`` 都有。可以考虑用线段树非常轻松的维护这样的信息。

时间复杂度 $O(q \log m)$，期望得分 $15~pts$

子任务 $6$：

世界上没有什么事情是开一棵线段树不能解决的，如果有，那就开 $30$ 棵。

时间复杂度 $O(nq \log m)$，期望得分 $10~pts$

子任务 $7$：

考虑结合子任务 $4$ 和子任务 $5$ 的做法，发现两个区间的状压信息也可以用子任务 $4$ 的方法合并。因此用线段树维护这两个 ``int`` 的状压信息即可。

时间复杂度 $O(q \log m)$，期望得分 $30~pts$



```cpp
#include <ctime>
#include <cstdio>

namespace IPT {
    const int L = 1000000;
    char buf[L], *front=buf, *end=buf;
    char GetChar() {
        if (front == end) {
            end = buf + fread(front = buf, 1, L, stdin);
            if (front == end) return -1;
        }
        return *(front++);
    }
}

template <typename T>
inline void qread(T &x) {
    char ch = IPT::GetChar(), lst = ' ';
    while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
    while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
    if (lst == '-') x = -x;
}

namespace OPT {
    char buf[120];
}

template <typename T>
inline void qwrite(T x, const char aft, const bool pt) {
    if (x < 0) {
        x = -x, putchar('-');
    }
    int top=0;
    do {
        OPT::buf[++top] = static_cast<char>(x % 10 + '0');
    } while (x /= 10);
    while (top) putchar(OPT::buf[top--]);
    if (pt) putchar(aft);
}

template <typename T>
inline void qr(T &x) {
  char ch = IPT::GetChar(), lst = ' ';
  while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
  while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
  if (lst == '-') x = -x;
}

const int maxn = 100010;

int n, m, q;
char s[maxn][35];

#ifdef ONLINE_JUDGE
int Ans;
#endif

struct Tree {
  Tree *ls, *rs;
  int l, r, x, y;
  bool leg;

  Tree() {
    ls = rs = NULL;
    l = r = x = y = 0;
    leg = true;
  }

  void pushup() {
    if (!(this->ls->leg && this->rs->leg)) {
      this->leg = false;
    } else {
      if ((this->ls->x & this->rs->x) & (this->ls->y ^ this->rs->y)) {
        this->leg = false;
      } else {
        this->leg = true;
        this->x = this->ls->x | this->rs->x;
        this->y = this->ls->y | this->rs->y;
      }
    }
  }
};
Tree *rot;

void ReadStr(char *p);
void Update(const int x);
void Query(const int l, const int r);
void update(Tree *const u, const int p);
Tree query(Tree *u, const int l, const int r);
void build(Tree *const u, const int l, const int r);

int main() {
  qr(n); qr(m); qr(q);
  for (int i = 1; i <= m; ++i) {
    ReadStr(s[i] + 1);
  }
  build(rot = new Tree, 1, m);
  int opt, l, r;
  while (q--) {
    opt = 0; qr(opt);
    if (opt == 0) {
      l = r = 0; qr(l); qr(r);
      Query(l, r);
    } else {
      l = 0; qr(l);
      ReadStr(s[0] + 1);
      Update(l);
    }
  }
#ifdef ONLINE_JUDGE
  printf("%d\n", Ans);
#endif
  return 0;
}

void ReadStr(char *p) {
  do *p = IPT::GetChar(); while ((*p != '0') && (*p != '1') && (*p != '?'));
  do *(++p) = IPT::GetChar(); while ((*p == '0') || (*p == '1') || (*p == '?'));
  *p = 0;
}

void build(Tree *const u, const int l, const int r) {
  if ((u->l = l) == (u->r = r)) {
    for (int i = 1; i <= n; ++i) {
      if (s[l][i] != '?') {
        u->x |= 1 << i;
        if (s[l][i] == '1') {
          u->y |= 1 << i;
        }
      }
    }
  } else {
    int mid = (l + r) >> 1;
    build(u->ls = new Tree, l, mid);
    build(u->rs = new Tree, mid + 1, r);
    u->pushup();
  }
}

Tree query(Tree *u, const int l, const int r) {
  if ((u->l > r) || (u->r < l)) return Tree();
  if ((u->l >= l) && (u->r <= r)) return *u;
  Tree _ret;
  auto ll = query(u->ls, l, r), rr = query(u->rs, l, r);
  _ret.ls = &ll; _ret.rs = &rr;
  _ret.pushup();
  return _ret;
}

void Query(const int l, const int r) {
  auto _ret = query(rot, l, r);
  if (!_ret.leg) {
#ifndef ONLINE_JUDGE
    puts("0");
#endif
  } else {
    int ans = 1;
    for (int i = 1; i <= n; ++i) if (!(_ret.x & (1 << i))) {
      ans <<= 1;
    }
#ifdef ONLINE_JUDGE
    Ans ^= ans;
#else
    printf("%d\n", ans);
#endif
  }
}

void update(Tree *u, const int p) {
  if (u->ls) {
    if (u->ls->r >= p) {
      update(u->ls, p);
    } else {
      update(u->rs, p);
    }
    u->pushup();
  } else {
    *u = Tree();
    u->l = u->r = p;
    for (int i = 1; i <= n; ++i) {
      if (s[0][i] != '?') {
        u->x |= 1 << i;
        if (s[0][i] == '1') {
          u->y |= 1 << i;
        }
      }
    }
  }
}

void Update(const int x) {
  update(rot, x);
}
```

---

## 作者：EXODUS (赞：19)

# Part 1：前言
这是一篇偏卡常题解，~~但是好像跑的飞快~~。

码风有点压行，可能不适于阅读/kk。

>[505ms,53.95MB,979B](https://www.luogu.com.cn/record/85668111)

# Part 2：正文
## 前置芝士
- 乘法原理
- 树状数组

## $\text{70pts}$ 思路
注意到对于任意一段区间 $[l,r]$，其中所有字符串的第 $i$ 位对方案数的贡献如下

- 该位同时存在 $0$ 和 $1$ 任意数量的 $?$，此时 $ans=ans\times 0$

显然此时已经不可能存在方案了，答案直接置为 $0$ 即可。
- 该位存在 $0$ 或 $1$ 以及任意数量的 $?$，此时 $ans=ans\times 1$

此时所有 $?$ 只能变成一种数字，方案数不变。
- 该位只存在 $?$，此时 $ans=ans\times 2$

此时 $?$ 可以任意变为 $0$ 或 $1$，方案数乘 $2$（具体原因参见乘法原理）。

那么此时询问问题转化为求区间 $0$，$1$ 和 $?$ 的个数。

由于每次单点修改，所以可以考虑树状数组，而且字符串长度不超过 $30$，直接暴力对每一位修改即可。

时间复杂度 $O(nq\log m)$，稳稳拿到 $\text{70pts}$。

核心代码如下
```cpp

#define lowbit(x) (x&-x)

const int N=1e5+11;
int n,m,q;
char s[N][33];
int a[N][33][4];

void add(int x,int v,int l,int id){for(;x<=m;x+=lowbit(x))a[x][l][id]+=v;}
int  ask(int x,int l,int id){int res=0;for(;x;x-=lowbit(x))res+=a[x][l][id];return res;}
int query(int l,int r,int x,int id){return ask(r,x,id)-ask(l-1,x,id);}
void ins(char *s,int pos,int op){for(int i=1;i<=n;i++)isdigit(s[i])?add(pos,op,i,s[i]^48):add(pos,op,i,2);}

int main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)scanf("%s",s[i]+1),ins(s[i],i,1);
	int Ans=0;
	while(q--){
		int op=read();
		if(op==0){
			int l=read(),r=read(),ans=1;
			for(int i=1;i<=n;i++){
				int x=query(l,r,i,0),y=query(l,r,i,1),z=query(l,r,i,2);
				if(x&&y)ans=0;
				if(x||y)ans<<=0;
				if(!(x|y))ans<<=1;
			}Ans^=ans;
		}else{
			int pos=read();ins(s[pos],pos,-1);
			scanf("%s",s[pos]+1);ins(s[pos],pos,1);
		}
	}
	printf("%d\n",Ans);
	return 0;
}
```

## $\text{100pts}$ 思路

~~我超交上去咋 T 了，让我来算算时间复杂度，6e8 树状数组小常数跑不过去？啊这我每次好像要搞三次修改六次询问，算了算了开写线段树吧。~~

然后我又看了眼我代码，~~哎 z 咋没用？~~

注意到一个问题，$0$，$1$，$?$ 的个数没必要全部维护，我们令在 $[l,r]$ 区间内 $0$ 的个数为 $x$，$1$ 的个数为 $y$，则 $?$ 的个数为 $r-l+1-x-y$，这样每次修改只要维护 $0$ 和 $1$ 即可，询问也只需要询问 $0$ 和 $1$ 的个数。

时间复杂度同上，但常数大概小了 $\frac{1}{3}$ 左右？

# Part 3：代码
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
const int N=1e5+11;
int n,m,q,a[N][33][4],l,r,op,pos;
char s[N][33];
void add(int x,int v,int l,int id){for(;x<=m;x+=lowbit(x))a[x][l][id]+=v;}
int  ask(int x,int l,int id){int res=0;for(;x;x-=lowbit(x))res+=a[x][l][id];return res;}
int query(int l,int r,int x,int id){return ask(r,x,id)-ask(l-1,x,id);}
void ins(char *s,int pos,int op){for(int i=1;i<=n;++i)if(s[i]=='0'||s[i]=='1')add(pos,op,i,s[i]^48);}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)scanf("%s",s[i]+1),ins(s[i],i,1);
	int Ans=0;
	while(q--){
		scanf("%d",&op);
		if(op==0){
			scanf("%d%d",&l,&r);int ans=1;
			for(int i=1;i<=n;++i){
				int x=query(l,r,i,0),y=query(l,r,i,1);
				if(x&&y){ans=0;break;}
				if(x||y)ans<<=0;
				if(!(x|y))ans<<=1;
			}Ans^=ans;
		}else{
			scanf("%d",&pos);ins(s[pos],pos,-1);
			scanf("%s",s[pos]+1);ins(s[pos],pos,1);
		}
	}
	printf("%d\n",Ans);
	return 0;
}
```
# Part 4：后文

总结点常用的~~卡常~~Trick
- 可以用其它信息推出的信息就不用维护了，这点常用于 dp 优化，能够在时空里省下一维。
- ~~树状数组是真的香，码量少，常数小，线段树看了都说好。~~

点赞再走吧（可怜

---

## 作者：斗神_君莫笑 (赞：14)

线段树的好题  
~~吐槽扶苏爷毒瘤码风~~  
看到n<=30的数据规模，区间信息可合并，很容易想到状压线段树  
一个串有三个信息，自然一个变量是无法维护的  
我们考虑维护两个值x,y，  
对于每一位来讲，一个代表该位是否确定，一个代表该位的值  
对于每一位不确定的值，都将该位的值拟为0  

考虑合并的状况  
当`l.x[i]==1&&y.x[i]==1`时，证明这一位确定  
此时当`l.y[i]!=r.y[i]`，则冲突，无解  
只要左右有一边确定，证明该位确定   
因此也可以将它的y同样的合并   
抽象一下或者手动模拟，就发现了它pushup的柿子  
```cpp
inline void pushup(int p){
	T[p].x=T[lc].x|T[rc].x;
	T[p].y=T[lc].y|T[rc].y;
	if((T[lc].x&T[rc].x)&(T[lc].y^T[rc].y)||(!T[lc].have_ans)||(!T[rc].have_ans))
		T[p].have_ans=0;
	else T[p].have_ans=1;
}
```
注意一个小细节：左右有一边无解则无解
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Node{
	int l,r,x,y,have_ans;
}T[400010];
int x[100010],y[100010];
inline void pushup(int p){
	T[p].x=T[lc].x|T[rc].x;
	T[p].y=T[lc].y|T[rc].y;
	if((T[lc].x&T[rc].x)&(T[lc].y^T[rc].y)||(!T[lc].have_ans)||(!T[rc].have_ans))
		T[p].have_ans=0;
	else T[p].have_ans=1;
}
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(l==r){
		T[p].x=x[l];
		T[p].y=y[l];
		T[p].have_ans=1;
		return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
	//printf("%d %d %d %d %d\n",T[p].l,T[p].r,T[p].x,T[p].y,T[p].have_ans);
}
int have_ans;
Node query(int p,int ql,int qr){
	//printf("%d %d %d %d %d\n",T[p].l,T[p].r,T[p].x,T[p].y,T[p].have_ans);
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p];
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid&&mid<qr){
		Node l=query(lc,ql,qr),r=query(rc,ql,qr),ans;
		ans.x=l.x|r.x;ans.y=l.y|r.y;
		if((l.x&r.x)&(l.y^r.y)||(!l.have_ans)||(!r.have_ans))
			ans.have_ans=0;
		else ans.have_ans=1;
		return ans;
	}
	if(ql<=mid)return query(lc,ql,qr);
	if(qr>mid)return query(rc,ql,qr);
}
void update(int p,int q,int x,int y){
	if(T[p].l==T[p].r){
		T[p].x=x;T[p].y=y;
		T[p].have_ans=1;
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update(lc,q,x,y);
	else update(rc,q,x,y);
	pushup(p);
}
int main(){
	ios::sync_with_stdio(false);
	int n,m,q;
	cin>>n>>m>>q;
	for(int i=1;i<=m;++i){
		string s;cin>>s;
		int xx=0,yy=0;
		for(int j=0;j<s.size();++j){
			xx<<=1;yy<<=1;
			if(s[j]=='?'){
				xx|=0;yy|=0;
			}
			else{
				xx|=1;yy|=s[j]-'0';
			}
		}
		x[i]=xx;y[i]=yy;
	}
	build(1,1,m);
	int ans=0;
	for(int i=1;i<=q;++i){
		int t;cin>>t;
		if(t==0){
			int x,y;
			cin>>x>>y;
			have_ans=0;
			Node now=query(1,x,y);
			if(!now.have_ans){
				ans^=0;
				//cout<<"0\n";
				continue;
			}
			int k=1;
			for(int i=1;i<=n;++i){
				if(!(now.x&1))k<<=1;
				now.x>>=1;
			}
			ans^=k;
			//cout<<k<<'\n';
		}
		if(t==1){
			int place;cin>>place;
			string s;cin>>s;
			int xx=0,yy=0;
			for(int j=0;j<s.size();++j){
				xx<<=1;yy<<=1;
				if(s[j]=='?'){
					xx|=0;yy|=0;
				}
				else{
					xx|=1;yy|=s[j]-'0';
				}
			}
			update(1,place,xx,yy);
		} 
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：滑稽的小宫 (赞：9)

# P5522 棠梨煎雪
听说压时限卡掉了 $O(nq\log m)$  的线段树？

那当然是要用**树状数组**了！

## 题意简述
- $m$ 个二进制字符串，长度均为 $n$，有一些位的值不确定

- 操作1：询问 $l$ 到 $r$ 的字串能否变为同一个串，如果能，求出能变成的串个数，如果不能，个数为0

- 操作2：修改一个串

- 求：所有询问的答案的异或和（异或0相当于不变）

- $ 1≤m≤10^5+7,1≤n≤30,1≤q≤10^6+7 $

## 题目分析

可以想到，对于 $l$ 到 $r$ 的所有串的第i位：

- 若该位上既有1也有0，显然不能全部变成同一个01串

- 若该位上全部都是 $?$，即该位全部改成0或1都可以，分步计数用乘法，个数 $\times 2$

- 若该位上有 $?$，但也有1或0（不同时存在1或0），则该位只能全部改成已有的那个数，个数 $\times 1$，不变

这三种情况都可以通过统计l到r区间内 $0,1,?$ 的个数判断，因此用区间求和传统~~比线段树快~~的方法——树状数组（三维，记录符号、第几个串、位数）

而修改一个串的时候，只需要边扫原串边修改，将原串的该位上的字符在树状数组中减1，再把新串该位上的字符在树状数组中加1即可

对于初始的 $m$ 个串，直接向树状数组里加1即可

时间复杂度：~~O(能过)~~ $O(nq\log m)$ 

~~但是比同复杂度线段树优~~

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define M 100010
#define N 40
int n,m,q,c[5][M][N],len[M],a[M][N],ans;
char s[N];
int lb(int x){
	return x&(-x);
}int find(int a,int bit,int op){
	int ans=0;
	while(a){
		ans+=c[op][a][bit];
		a-=lb(a);
	}return ans;
}void add(int a,int bit,int x,int op){
	while(a<=m){
		c[op][a][bit]+=x;
		a+=lb(a);
	}return;
}int count(int l,int r){
	int cnt=1;
	for(int i=1;i<=n;i++){
		if(find(r,i,1)-find(l-1,i,1)>0&&find(r,i,0)-find(l-1,i,0)>0)return 0;
		if(find(r,i,2)-find(l-1,i,2)==r-l+1)cnt<<=1;
	}return cnt;
}void change(int x){
	for(int i=1;i<=n;i++){
		add(x,i,-1,a[x][i]);
		if(s[i]=='?')a[x][i]=2;
		else a[x][i]=s[i]-'0';
		add(x,i,1,a[x][i]);
	}return;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		scanf("%s",s+1);
		for(int j=1;j<=n;j++){
			if(s[j]=='?')a[i][j]=2;
			else a[i][j]=s[j]-'0';
			add(i,j,1,a[i][j]);
		}
	}for(int i=1;i<=q;i++){
		int opt,l,r,x;
		scanf("%d",&opt);
		if(!opt){
			scanf("%d%d",&l,&r);
			ans^=count(l,r);
		}else{
			scanf("%d%s",&x,s+1);
			change(x);
		}
	}printf("%d",ans);
	return 0;
}

```


---

## 作者：TonyYin (赞：8)

[有完整代码的版本 - My Blog](https://www.tonyyin.top/2021/10/luogu-p5522/)

## 题意

给定 $m$ 个长度为 $n$ 的 $01$ 串。存在某些位置为 `?`，每个 `?` 独立，既可以取 $0$，也可以是 $1$.

维护 $q$ 次操作，每次操作可能为：

- 区间查询：查询有多少个只包含 $01$ 的串 $s$ 满足：存在一种对 `?` 的赋值方法，使得区间内的每个 $01$ 串都能与 $s$ 完全匹配。
- 单点修改：把第 $i$ 个串替换为给定的新串。

$1\leq m\leq 10^5, 1\leq q\leq 10^6, 1\leq n\leq 30$.

## 分析

区间查询 $+$ 单点修改 $\Longrightarrow$ **线段树**。



主要问题在：如何处理对 $[l, r]$ 进行的查询操作。

若区间中存在两个串 $s_i, s_j$，存在 $k$ 使得 $s_i[k]$ 和 $s_j[k]$ 一个是 $0$，另一个是 $1$，那么合法串的个数为 $0$。

否则，只需要知道，**有多少个 $k$ 满足：$\forall i, j\in [l, r]$，$s_i[k]=s_j[k]=$ `?`.**

若有 $x$ 个满足要求的 $k$，则区间询问的答案是 $2^{x}$.

### 维护信息

考虑对 $m$ 个字符串建立线段树，**以编号为下标**。

发现 $1\leq n\leq 30$，可以用 `int` 类型存储**二进制压缩**后的的状态。

考虑用线段树：**$v_0$ 记录必须为 $0$ 的位置，$v_1$ 记录必须为 $1$ 的位置**。

具体地，设线段树的 $i$ 号节点代表的区间为 $[l_i, r_i]$，维护下列信息：

- 十进制数 $v_0$：在 $v_0$ 的**二进制**表示下，第 $j$ 位为 $1$ 当且仅当字符串的第 $j$ 为**被确定为了 $0$**。
- 十进制数 $v_1$：在 $v_1$ 的二进制表示下，第 $j$ 位为 $1$ 当且仅当字符串的第 $j$ 为被确定为了 $1$。

根据题目性质，线段树**对 $v_0$ 和 $v_1$ 维护区间`按位或`和**。

也就是说，对于 $\rm{push\_up}$ 操作，把左右两端`按位或`即可，即：
$$
x.v_0=\operatorname{lson_x}.v_0\mid \operatorname{rson_x}.v_0
$$

$$
x.v_1=\operatorname{lson_x}.v_1\mid \operatorname{rson_x}.v_1
$$

```cpp
void push_up(int id) {
    c[id].v0 = c[ls(id)].v0 | c[rs(id)].v0;
    c[id].v1 = c[ls(id)].v1 | c[rs(id)].v1;
}
```

### 询问

和一般的区间查询一样，但每次要包含两个返回值，与 $v_0, v_1$ 的含义相同，记录当前查询区间的信息。

还是可以用`按位或`合并左右两个区间。

当遇到左右区间产生矛盾时，直接 $v_0\leftarrow (-1)$ 来代表此次询问无解，向上递归时遇到 $-1$ 就不用合并区间了。

**判断无解：$v_0\; \& \; v_1\neq 0$ 时无解**。此时存在一个 $k$ 满足 $s[k]$ 必须为 $0$ 且 $s[k]$ 必须为 $1$，矛盾。 

```cpp
pair<int, int> query(int id, int l, int r, int X, int Y) {
    if(X <= l && r <= Y) {
        if(c[id].v0 & c[id].v1) return make_pair(-1, -1);
        else return make_pair(c[id].v0, c[id].v1);
    }
    int mid = (l + r) >> 1;
    pair<int, int> t1 = make_pair(0, 0), t2 = make_pair(0, 0), ret = make_pair(0, 0);
    if(X <= mid) t1 = query(ls(id), l, mid, X, Y);
    if(Y > mid) t2 = query(rs(id), mid + 1, r, X, Y);
    if(t1.first == -1 || t2.first == -1) return make_pair(-1, -1);
    ret.first = t1.first | t2.first; ret.second = t1.second | t2.second;
    if(ret.first & ret.second) return make_pair(-1, -1);
    else return ret;
}
```

### 修改

就是**普通的单点修改**。

```cpp
void update(int id, int l, int r, int X, int w0, int w1) {
    if(l == X && r == X) {
        c[id].v0 = w0; c[id].v1 = w1;
        return ;
    }
    int mid = (l + r) >> 1;
    if(X <= mid) update(ls(id), l, mid, X, w0, w1);
    else update(rs(id), mid + 1, r, X, w0, w1);
    push_up(id);
}
```



---

## 作者：suxxsfe (赞：7)

# P5522 [yLOI2019] 棠梨煎雪  
整理博客的时候改了一下分类标签，重新审一下  
## 线段树+每次pushup暴力比较  
先说说我在比赛中打这道题的虐心经历吧。。。：  
先是指针线段树的root在地址数组里占了第一位，  
但tot却初始化为0.....  
这就导致了单步调试时出现了让蒟蒻不知所措的奇怪报错：
![](https://cdn.luogu.com.cn/upload/pic/74876.png)  
解决后，却发现询问中n和m居然用混了......  
~~导致比赛中这题只得了5分~~  
所以，以我的经历提醒大家：**注意变量名！注意变量名！注意变量名！**（~~可能也只有我会把变量搞混吧。。。~~   
----------------------------------------------手动正文分割线-----------------------------------------------  
### 思路：  
区间查询，单点修改，所以，你想到了什么？  
#### 没错，就是线段树！  
我们用一个res结构体存ans和x数组：  
ans表示当前l~r有几种可能的情况，如果为0就是发生了冲突，x表示可以确定的（当然我是用3表示“？”）  
很显然，因为每个"？"都可以填0或1，所以对于又n个？的数列，他的可能情况数量就是 $2^n$
```
struct res{
	LL ans;
	int x[35] 
};  
```  
再想想怎么build?  
每次当l==r（也就是到了叶节点），就扫一遍对应的数组，将其转存到对应的x里，如果出现3（也就是“？”），就$ans\times 2$，当然ans要初始化为1（~~各位大佬应该不用我提醒。。。~~  
当然修改和这个也差不多  
那怎么将两个儿子信息合并到父节点？  
我用了一个以res为返回类型的cmp函数：  
如果左右有任意一个儿子ans==0（有冲突），那么父节点的ans直接为0  
然后逐一暴力比对，对于每两个对应的原素：  
1. 相等且不等于3：ret.x[i]=aa.x[i],ans不变  
2. 相等且等于3：ret.x[i]=3,$ans \times 2$  
3. 不等且都不为3：说明发生了冲突，ans=0，返回  
4. 不等且一个为3：ret.x[i]赋值为不等于3的那个，ans不变  

下面是这个函数的代码：（上面讲的应该比较清晰了，就不再注释了）
```  
inline res cmp(res aa,res bb){
	res ret;
	if(aa.ans==0||bb.ans==0){
		ret.ans=0;
		return ret;
	}
	ret.ans=1;
	for(R int i=1;i<=n;i++){
		if(aa.x[i]==bb.x[i]){
			if(aa.x[i]!=3){
				ret.x[i]=aa.x[i];
				continue;
			}
			else{
				ret.x[i]=3;
				ret.ans*=2;
			}
		}
		if(aa.x[i]!=3&&bb.x[i]!=3){
			ret.ans=0;
			return ret;
		}
		if(aa.x[i]==3)
			ret.x[i]=bb.x[i];
		else ret.x[i]=aa.x[i];
	}
	return ret;
}
```  
然后再把这给函数返回的ret赋值给当前节点就行了  
`tree->o=cmp(tree->ls->o,tree->rs->o);`  
最后一个问题，怎么查询？  
我们还是要用到cmp函数，比较从两个子节点返回的信息，然后返回到上层  
好了，应该就这些了吧，放上代码（~~我知道这才是泥萌想要的~~  
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define R register
#define EN printf("\n")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') y=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=getchar();}
	return x*y;
}
int n,m,q;
struct res{
	LL ans;
	int x[35];
};
struct tr{
	tr *ls,*rs;
	res o;
}dizhi[200017],*root=&dizhi[0];
int tot;
int now[35],a[100017][35];
inline res cmp(res aa,res bb){
	res ret;
	if(aa.ans==0||bb.ans==0){
		ret.ans=0;
		return ret;
	}
	ret.ans=1;
	for(R int i=1;i<=n;i++){
		if(aa.x[i]==bb.x[i]){
			if(aa.x[i]!=3){
				ret.x[i]=aa.x[i];
				continue;
			}
			else{
				ret.x[i]=3;
				ret.ans*=2;
			}
		}
		if(aa.x[i]!=3&&bb.x[i]!=3){
			ret.ans=0;
			return ret;
		}
		if(aa.x[i]==3)
			ret.x[i]=bb.x[i];
		else ret.x[i]=aa.x[i];
	}
	return ret;
}
void build(tr *tree,int l,int r){
	if(l==r){
		tree->o.ans=1;
		for(R int i=1;i<=n;i++){
			tree->o.x[i]=a[l][i];
			if(a[l][i]==3) tree->o.ans*=2;
		}
		return;
	}
	int mid=(l+r)>>1;
	tree->ls=&dizhi[++tot];
	tree->rs=&dizhi[++tot];
	build(tree->ls,l,mid);
	build(tree->rs,mid+1,r);
	tree->o=cmp(tree->ls->o,tree->rs->o);
}
void change(tr *tree,int l,int r,int k){
	if(l==r){
		tree->o.ans=1;
		for(R int i=1;i<=n;i++){
			tree->o.x[i]=now[i];
			tree->o.ans*=2;
		}
		return;
	}
	int mid=(l+r)>>1;
	if(k<=mid) change(tree->ls,l,mid,k);
	else change(tree->rs,mid+1,r,k);
	tree->o=cmp(tree->ls->o,tree->rs->o);
}
res qq(tr *tree,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) {
		return tree->o;
	}
	int mid=(l+r)>>1;
	res aa,bb;
	aa.ans=bb.ans=-1;
	if(ql<=mid) aa=qq(tree->ls,l,mid,ql,qr);
	if(qr>mid) bb=qq(tree->rs,mid+1,r,ql,qr);
	if(aa.ans==-1) return bb;
	if(bb.ans==-1) return aa;
	return cmp(aa,bb);
}
int main(){
	char c;
	int anss=0;
	n=read();m=read();q=read();
	for(R int i=1;i<=m;i++){
		c=getchar();
		while(c==' '||c=='\n') c=getchar();
		for(R int j=1;j<=n;j++){
			if(c=='?') a[i][j]=3;
			else a[i][j]=c-48;
			c=getchar();
		}
	}
	build(root,1,m);
	for(R int i=1;i<=q;i++){
		int op=read();
		if(op){
			op=read();
			c=getchar();
			while(c==' ') c=getchar();
			for(R int j=1;j<=n;j++){
				if(c=='?') now[j]=3;
				else now[j]=c-48;
				c=getchar();
			}
			change(root,1,m,op);
		}
		else{
			int l=read(),r=read();
			anss^=qq(root,1,m,l,r).ans;
		}
	}
	printf("%d",anss^0);
	return 0;
}  
```  
这是身为蒟蒻的我写的第一篇题解，有错误或没讲明白的地方， 欢迎各位大佬私信

---

## 作者：Fading (赞：5)

先判断无解的情况。如果一个位置在$[l,r]$中同时出现了$0,1$，那么无解。

怎么判断呢？

考虑状压。我们只要知道$[l,r]$里$1\sim n$这些位是否出现过$0/1$即可。这可以用状态压缩+线段树解决。合并的时候$\texttt{or}$一下即可。

怎么计算方案数呢？发现如果有解，那么$[l,r]$中全是$?$的位就可以乱填。所以答案是$2^{\texttt{全是?的位数}}$

这也可以通过状态压缩+线段树来解决。

时间复杂度$O(30Q+Q\log_2m)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int unsigned int
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int seg[1010101][3];
inline void pushup(int rt){
	seg[rt][0]=seg[rt<<1][0]|seg[rt<<1|1][0];
	seg[rt][1]=seg[rt<<1][1]|seg[rt<<1|1][1];
	seg[rt][2]=seg[rt<<1][2]&seg[rt<<1|1][2];
}
int s[101010][3];
#define mid ((lb+rb)>>1)
void build(int rt,int lb,int rb){
	if (lb==rb) return (void)(seg[rt][0]=s[lb][0],seg[rt][1]=s[lb][1],seg[rt][2]=s[lb][2]);
	build(rt<<1,lb,mid);build(rt<<1|1,mid+1,rb);pushup(rt);
}
#define inf ((1ll<<30)-1ll)
int queryOK0(int rt,int lb,int rb,int l,int r){
	if (lb>r||rb<l) return 0;
	if (lb>=l&&rb<=r) return seg[rt][0];
	return queryOK0(rt<<1,lb,mid,l,r)|queryOK0(rt<<1|1,mid+1,rb,l,r);
}
int queryOK1(int rt,int lb,int rb,int l,int r){
	if (lb>r||rb<l) return 0;
	if (lb>=l&&rb<=r) return seg[rt][1];
	return queryOK1(rt<<1,lb,mid,l,r)|queryOK1(rt<<1|1,mid+1,rb,l,r);
}
int queryANS(int rt,int lb,int rb,int l,int r){
	if (lb>r||rb<l) return inf;
	if (lb>=l&&rb<=r) return seg[rt][2];
	return queryANS(rt<<1,lb,mid,l,r)&queryANS(rt<<1|1,mid+1,rb,l,r);
}
void update(int rt,int lb,int rb,int pos){
	if (lb==rb) return (void)(seg[rt][0]=s[lb][0],seg[rt][1]=s[lb][1],seg[rt][2]=s[lb][2]);
	(mid>=pos?update(rt<<1,lb,mid,pos):update(rt<<1|1,mid+1,rb,pos));
	pushup(rt);
}
int m,n,Q;
inline ll countbit(ll x){
	ll cnt=0;
	while (x){
		x^=(x&-x);
		cnt++;
	}
	return cnt;
}
signed main(){
	m=read(),n=read(),Q=read();
	for (int i=1;i<=n;i++){
		s[i][0]=s[i][1]=s[i][2]=0;
		for (int j=1,cc;j<=m;j++){
			char ch=gc();
			while (!isdigit(ch)&&ch!='?') ch=gc();
			cc=(ch=='0'?1:0);
			s[i][0]|=(1ll*cc)<<(j-1);
			cc=(ch=='1'?1:0);
			s[i][1]|=(1ll*cc)<<(j-1);
			cc=(ch=='?'?1:0);
			s[i][2]|=(1ll*cc)<<(j-1);
		}
	}
	build(1,1,n);
	ll ans=0;
	while (Q--){
		int opt=read();
		if (opt==0){
			int l=read(),r=read();
			int ok0=queryOK0(1,1,n,l,r);
			int ok1=queryOK1(1,1,n,l,r);
			if (!(ok0&ok1)){
				int ok2=queryANS(1,1,n,l,r);
				ans^=(1<<countbit(ok2));
			}
		}else{
			ll i=read();
			s[i][0]=s[i][1]=s[i][2]=0;
			for (int j=1,cc;j<=m;j++){
				char ch=gc();
				while (!isdigit(ch)&&ch!='?') ch=gc();
				cc=(ch=='0'?1:0);
				s[i][0]|=(1ll*cc)<<(j-1);
				cc=(ch=='1'?1:0);
				s[i][1]|=(1ll*cc)<<(j-1);
				cc=(ch=='?'?1:0);
				s[i][2]|=(1ll*cc)<<(j-1);
			}
			update(1,1,n,i);
		}
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：菲斯斯夫斯基 (赞：3)

## P5522 [yLOI2019] 棠梨煎雪 题解

非常好的一道线段树练习题。

**题意**

给定 $m$ 个长度为 $n$ 的可能含有 `?` 的 01 串，其中 `?` 既能代表 `0` 也能代表 `1`，$q$ 次操作，求有多少 01 串满足区间内的所有字符串都可以解释成该 01 串，或者单点修改某个字符串。

**思路**

注意到要区间修改、单点查询，所以第一反应是线段树。线段树里面存字符串很麻烦，但是 $n\le30$，所以可以**状态压缩**。

我们可以用一个数代表一个 01 串，但是题目中的 01 串可能含有 `?`。

所以我们还要再开一个数，代表当前某一位是否确定了，确定了则为 `1`，否则为 `0`。

故我们要开两个线段树。

考虑如何合并状态，分类讨论左子树和右子树的每一位：

1. 都为 `?`，那么合并后也应为 `?`。

2. 其中一个为 `?`，另一个为 `0` 或 `1`。那么当前这位就确定了。

3. 两个都是数字，并且它们相同。直接取这个数字即可。

4. 都是数字，但不相同，说明**不合法**。我的做法是开一个 $pd$ 数组，表示此位置不合法。

对于前三种情况，直接将状态取或即可，但是对于第四种情况，因为我比较弱，所以暴力一位一位进行判断。

考虑如何查询。

$ans1$ 代表某一位是否确定，$ans2$ 代表如果确定了，那么这一位是 `0` 还是 `1`。

其实跟合并差不多，但应当判断是否有解。$ans1$ 中 `1` 的个数为 $s$，那么答案即为 $2^s$。

修改就比较简单了，直接暴力找到当前节点，然后修改即可。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,q,check,ans1,ans2,sum,p;
int pd[N<<2],f1[N<<2],f2[N<<2];
bool wrong(int x1,int x2,int y1,int y2)
{
	for(int i=0;i<n;i++)
	{
		if(!(x1&(1<<i))||!(y1&(1<<i)))continue;
		if((x2&(1<<i))!=(y2&(1<<i)))return true;
	}
	return false;
}//暴力枚举是否合法
void add(int k,int l,int r,int x,char c[])
{
	if(l>x||r<x)return ;
	if(l==r&&l==x)
	{
		pd[k]=f1[k]=f2[k]=0;
		for(int i=0;i<n;i++)
		{
			if(c[i]!='?')
			{
				f1[k]|=1<<i;
				if(c[i]=='1')f2[k]|=1<<i;
			}
		}//记录当前节点的信息
		return ;
	}
	int mid=(l+r)/2;
	add(k*2,l,mid,x,c);
	add(k*2+1,mid+1,r,x,c);
	l=k*2,r=k*2+1;
	if((pd[l]|pd[r])||wrong(f1[l],f2[l],f1[r],f2[r]))
	{
		pd[k]=1;
		return ;
	}//是否有解
	pd[k]=0;
	f1[k]=f1[l]|f1[r];
	f2[k]=f2[l]|f2[r];//有解则取或
}
void ask(int k,int l,int r,int x,int y)
{
	if(l>y||r<x)return ;
	if(x<=l&&r<=y)
	{
		if(pd[k]||wrong(ans1,ans2,f1[k],f2[k]))
		{
			check=1;
			return ;
		}//是否有解
		ans1|=f1[k],ans2|=f2[k];//有解则取或
		return ;
	}
	int mid=(l+r)/2;
	ask(k*2,l,mid,x,y);
	ask(k*2+1,mid+1,r,x,y);
}
int main()
{
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++)
	{
		char c[40];
		scanf("%s",c);
		add(1,1,m,i,c);
	}
	while(q--)
	{
		int op;
		scanf("%d",&op);
		switch(op)
		{
			case 0:
			{
				check=ans1=ans2=0,sum=1;
				int l,r;
				scanf("%d%d",&l,&r);
				ask(1,1,m,l,r);
				if(check)break;//注意判断是否有解
				for(int i=0;i<n;i++)
					if(!(ans1&(1<<i)))sum*=2;
				p^=sum;//存下答案
				break;
			}
			case 1:
			{
				int pos;
				char c[40];
				scanf("%d%s",&pos,c);
				add(1,1,m,pos,c);//暴力修改
				break;
			}
		}
	}
	cout<<p;
	return 0;
}
```

---

## 作者：一Iris一 (赞：3)

首先看到题目要求实现区间询问和单点修改，又发现题目有一条特殊性质——$n\leq30$。由此可以想到对 $m$ 建一棵线段树，每个节点维护字符串压缩后的信息。

接下来思考如何状压这个字符串。字符串中有三种字符 `0`,`1`,`?`。可以将 `0` 状压为 $(10)_2$，`1` 状压为 $(01)_2$，`?` 状压为 $(11)_2$。每次问一个区间内字符串的方案数就相当于将所有点进行 `&` 运算，这样可以保证 `?` 在碰到 `0` 或 `1` 的时候可以直接变成对应数字，而当一个  `0`  和  `1`  做  `&`  运算的时候对应值会变为  `0` ，在查询的时候方便特判无解的情况。 

以上操作对修改同理。

-----
一些小细节：线段树走到空区间的时候传一个 `unsigned long long` 型的二进制位均为 `1` 的整数即可。
```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
#define Int unsigned long long

template<typename _T>
inline void read(_T &x)
{
	x=0;char s=getchar();int f=1;
	while(s<'0'||s>'9') {f=1;if(s=='-')f=-1;s=getchar();}
	while('0'<=s&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
	x*=f;
}

#define lowbit(x) (x&(-x))
#define gb(x) ((x-1)/T + 1)
#define gl(x) ((x-1)*T + 1)
#define pb push_back
#define fi first
#define sd second
#define Re register
#define MOD(x) (x = (x + mod)%mod)
#define pii pair<int,int>

const int np = 1e5 + 15;

char c[np][40];
unsigned int INF;
int a[np];
char s[np];

struct node{
	int l,r;
	int state;
	node *ls,*rs;
	
	inline bool inrange(int L,int R){return L <= l && r <= R;}
	inline bool outofrange(int L,int R){return r<L||R<l;} 

	inline void pushup()
	{
		state = ls->state & rs->state ; 
	}
	
	inline void upd(int L,int R,int vl)
	{
		if(inrange(L,R))
		{
			state = vl;
			return;
		}
		else
		{
			if(!outofrange(L,R))
			{
				ls->upd(L,R,vl);
				rs->upd(L,R,vl);
				pushup();
			}
			else return;
		}
	}
	
	inline int query(int L,int R)
	{
		if(inrange(L,R))
		{
			return state;
		}
		else
		{
			if(!outofrange(L,R))
			{
				return ls->query(L,R) & rs->query(L,R);
			}
			else return INF;
		}
	}
}mem[np * 2],*pool = mem,*rot;
inline node *New(){return ++pool;}
inline node *build(int L,int R)
{
	node *u = New();
	u->l = L, u->r = R;
	if(L == R)
	{
		u->ls = u->rs = NULL;
		u->state = a[L];
	}
	else
	{
		int mid = L + R >> 1;
		u->ls = build(L,mid);
		u->rs = build(mid + 1,R);
		u->pushup();
	}
	return u;
}

inline int solve(char *g,int len)
{
	int state = 0;
	for(int i=1;i<=len;i++)
	{
		if(g[i] == '1')
		{
			state += 1ll<<(2*(i-1));
		}
		if(g[i] == '0')
		{
			state += 2ll<<(2*(i-1));
		}
		if(g[i] == '?')
		{
			state += 3ll<<(2*(i-1));
		}
	}
	return state;	
}

signed main()
{
	INF = 0;
	INF--;
	int n,m,q;
	read(n);
	read(m);
	read(q);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",c[i] + 1);
		int op = strlen(c[i] + 1);
		a[i] = solve(c[i],op);
	}
	
	rot = build(1,m);
	
	int Ans = 0;
	for(int i=1,opt,l,r,pos;i<=q;i++)
	{
		read(opt);
		switch(opt)
		{
			case 0:{
				read(l);
				read(r);
				int k = rot->query(l,r);
				int g = 3,ans = 0;
				for(int i=0;i<2 * n;i+=2)
				{
					if((g<<i&k) == g<<i) ans++;
					if(!((k>>i)&3))
					{
						ans = -1;
						break;
					}
				 } 
				if(ans == -1) Ans ^= 0;
				else Ans ^= (1ll<<ans);

				break;
			}
			case 1:{
				read(pos);
				scanf("%s",s+1);
				int p_ = solve(s,strlen(s + 1));
				rot->upd(pos,pos,p_);
				break;
			}
		}
	}
	printf("%lld\n",Ans);
 }
```

# End

2020 年暑假 @[一扶苏一](https://www.luogu.com.cn/user/65363) 给我们讲了线段树，这种指针形式实现的线段树就是当年的成果。这道题就是当时的作业题，当时机房里只有 cyc 做了出来。当时扶苏和 cyc 一块给我们讲了很久，但是仍旧不明白如何实现。当一年之后，我已经熟练掌握了状压和线段树，再看到这个题，心里只想着一句话「这题似乎不是特别难」，即使这样，这题在我心里也有着不同于其它题目的分量。

感谢扶苏学长。撒花~






---

## 作者：Thinking (赞：2)

## 这里是点名被卡的$O(qnlogm)$做法

首先考虑对于两个串$s$和$t$，我们怎么合并得到$ans$（两天的总状态）：

1. 若存在$s_i$，$t_i$分别为0，1，则返回无解；
2. 若$s_i=t_i$，则$ans_i=s_i$（这里涵盖了$s_i=t_i=?$的情况）；
3. 否则，$s_i$，$t_i$，必定一个为0/1，一个为?，$ans_i$取0/1的那个。

不难发现合并可以用线段树维护，而$s$，$t$也不必存成字符串，直接当成3进制（为了卡常一般用4进制+位运算写）long long存，无解用一个特殊数（比如-1）存，最后答案就是$2^{\text{?的个数}}$。

时间复杂度$O(qnlogm)$，但是由于无解的情况存在所以跑不满。

~~n方过百万，暴力踩标算~~

```cpp
#include<cstdio>
#include<cctype>
typedef long long ll;
const int N=100050;
char rB[1<<23],*rS,*rT;
inline char gc(){return rS==rT&&(rT=(rS=rB)+fread(rB,1,1<<23,stdin),rS==rT)?EOF:*rS++;}
inline char rdc(){
	char c=gc();
	while(isspace(c))c=gc();
	return c;
}
inline int rdi(){
    char c=gc();
    while(!isdigit(c))c=gc();
    int x=c&15;
    for(c=gc();isdigit(c);c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
short n;
int x,y;
ll a[N],sum[N<<2],res;
ll merg(ll a,ll b){
	if(a==-1||b==-1)return -1;  //一个无解则必定无解
	ll s=0ll;
	for(short i=0;i<(n<<1);i+=2)if(((a>>i)&3ll)==2)s|=b&(3ll<<i);
	else if(((b>>i)&3ll)==2ll||((a>>i)&3ll)==((b>>i)&3ll))s|=a&(3ll<<i);
	else{s=-1;break;}
	return s;
}
void build(int o,int L,int R){
	if(L==R)sum[o]=a[L];
	else{
		int lc=o<<1,rc=lc|1,M=L+R>>1;
		build(lc,L,M);build(rc,M+1,R);
		sum[o]=merg(sum[lc],sum[rc]);
	}
}
void update(int o,int L,int R){
	if(L==R)sum[o]=res;
	else{
		int lc=o<<1,rc=lc|1,M=L+R>>1;
		if(x<=M)update(lc,L,M);
		else update(rc,M+1,R);
		sum[o]=merg(sum[lc],sum[rc]);
	}
}
ll ask(int o,int L,int R){
	if(x<=L&&y>=R)return sum[o];
	int lc=o<<1,rc=lc|1,M=L+R>>1;
	if(x<=M)if(y>M)return merg(ask(lc,L,M),ask(rc,M+1,R));
	else return ask(lc,L,M);
	else return ask(rc,M+1,R);
}
inline int query(ll x){  //求方案数
	if(x==-1)return 0;
	int s=1;
	for(short i=0;i<(n<<1);i+=2)if(((x>>i)&3ll)==2ll)s<<=1;
	return s;
}
int main(){
	int m,q,i,opt,ans=0;
	char c;
	short j;
	n=rdi();m=rdi();q=rdi();
	for(i=1;i<=m;++i){
		res=0ll;
		for(j=0;j<n;++j){
			c=rdc();
			res=(res<<2)|(c=='?'?2:(c&15));  //把30位压进long long里（正向反向无所谓）
		}
		a[i]=res;
	}
	build(1,1,m);
	while(q--){
		opt=rdi();x=rdi();
		if(!opt){
			y=rdi();
			ans^=query(ask(1,1,m));
		}else if(opt==1){
			res=0ll;
			for(j=0;j<n;++j){
				c=rdc();
				res=(res<<2)|(c=='?'?2:(c&15));
			}
			update(1,1,m);
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：ez_lcw (赞：2)

# 线段树+状压

首先，我们先得知道询问$k$个串的答案串可能是什么。

假设这$k$个串分别为$S[1]$、$S[2]$……$S[k]$。

那么对于所有串的第$i$位，我们把它分成$3$类，第一类是第$i$位为$0$的串，第二类是第$i$位为$1$的串，第三类是第$i$位为‘$?$’的串。

1. 如果这$k$个串中既有第一类又有第二类，那么说明肯定有一个字符串第$i$位为$0$，且还有一个字符串第$i$位为$1$，这时已经保证了这两个串不相同，那么肯定没有答案串符合询问条件。

1. 如果这$k$个串中第一类或第二类中只有一类，那么不管有没有第三类，肯定可以保证每个串的第$i$位都相等，但答案串的第$i$位肯定是固定的，即对于这一位只有一种方案。

1. 如果这$k$个串全为第三类，那么对于答案串的第$i$位，既可以为$0$也可以为$1$，那么对于这一位有两种方案。

想到这里，我们自然而然地想到用$n$棵线段树维护所有串每一位上的$0$、$1$情况。

例如：假设第$i$棵线段树的$[l,r]$区间的$flag[0]=true$，那么就是说第$l\sim r$串的第$i$位出现过$0$。

那么假设某段区间的$flag[0]$和$flag[1]$都等于$false$，就说明这段区间全是$?$。

我们发现，这样太慢啦！（亲测$70$QAQ）

考虑状压。

我们只开一棵线段树，每个节点$[l,r]$存储的是第$l\sim r$个串每一位上的$0$、$1$信息。

也就是把前面提到的$n$棵线段树合并。

那么对于这$n$棵线段树每棵的区间$[l,r]$的$flag[0]$和$flag[1]$，把它们分别压成两个二进制数$x[0],x[1]$，那么合并后的线段树的$[l,r]$区间的$x[0]$在二进制表达式下的第$i$位就表示的是第$i$棵线段树的区间$[l,r]$的$flag[0]$。

看图更好理解点（可打开新标签页看更仔细）：

![](https://cdn.luogu.com.cn/upload/pic/74834.png)

如图，左边的$5$棵树是原来的$i$棵线段树，将每棵线段树的$2$号节点的$flag[0]$值状压起来，就得到了右边的那棵线段树$2$号节点的$x[0]$。

那么我们就可以实现状压了。

接下来的问题是怎么合并。

在原来的线段树中，合并操作是这样的：

```cpp
void up(int u)
{
	flag[u][0]=flag[u<<1][0]||flag[u<<1|1][0];//即左右区间有一个有0这整个区间就有0
   	flag[u][1]=flag[u<<1][1]||flag[u<<1|1][1];//1类似
}
```

那这放在状压后的线段树中是怎么样的？

就是把$x[u][0]$的第$i$位（$0\leqslant i\leqslant n-1$）设为：$x[u<<1][0]$的第$i$位为$1$ 或者 $x[u<<1|1][0]$的第$i$位为$1$（满足一个即为$1$）。

想想这个东西怎么维护。一下子就能想到：用按位或（“$|$”）啊！因为它的运算法则为有1则1。

那我们就可以合并了。

然后每次询问时按最上面说的分情况讨论一下就好了。

完整代码如下：

```cpp
#include<bits/stdc++.h>

#define N 100010
#define K 35

using namespace std;

struct data
{
	int a,b;
};

int n,m,q,ans,flag[N<<2][2];//这里的flag就是上面的x
char s[N][K],ch[K];

data operator + (data a,data b)
{
	return (data){a.a|b.a,a.b|b.b};
}

void up(int k)
{
	flag[k][0]=flag[k<<1][0]|flag[k<<1|1][0];//用“|”合并区间
	flag[k][1]=flag[k<<1][1]|flag[k<<1|1][1];
}

void build(int l,int r,int k)
{
	if(l==r)
	{
		for(int i=1;i<=n;i++)
		{
			if(s[l][i]=='?')continue;//如果是？那么flag[0]=flag[1]=0，所以这一位不用管它
			flag[k][s[l][i]-'0']|=(1<<(i-1));//把这一位设1
		}
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,k<<1);
	build(mid+1,r,k<<1|1);
	up(k);
}

data query(int k,int l,int r,int L,int R)//询问
{
	if(L<=l&&r<=R)
		return (data){flag[k][0],flag[k][1]};
	int mid=(l+r)>>1;
	if(R<=mid)return query(k<<1,l,mid,L,R);
	else if(L>mid)return query(k<<1|1,mid+1,r,L,R);
	else return query(k<<1,l,mid,L,R)+query(k<<1|1,mid+1,r,L,R);
}

void update(int k,int l,int r,int x)//修改
{
	if(l==r)
	{
		flag[k][0]=flag[k][1]=0;
		for(int i=1;i<=n;i++)
		{
			if(ch[i]=='?')continue;
			flag[k][ch[i]-'0']|=(1<<(i-1));
		}
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid) update(k<<1,l,mid,x);
	else update(k<<1|1,mid+1,r,x);
	up(k);
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)
		scanf("%s",s[i]+1);
	build(1,m,1);
	while(q--)
	{
		int opt;
		scanf("%d",&opt);
		if(opt==0)
		{
			int l,r;
			scanf("%d%d",&l,&r);
			data t=query(1,1,m,l,r);
			int anss=1;
			for(int i=1;i<=n;i++)
			{
				if((t.a&1)&&(t.b&1))//第一种：又有0又有1
				{
					anss=0;
					break;
				}
				if((!(t.a&1))&&(!(t.b&1)))//第二种：没1又没0
					anss*=2;
				t.a>>=1,t.b>>=1;
			}
			ans^=anss;
		}
		if(opt==1)
		{
			int pos;
			scanf("%d%s",&pos,ch+1);
			update(1,1,m,pos);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：under_the_time (赞：1)

## 题意

> 给定 $m$ 个字符串，每个字符串仅含 $\texttt{0/1/?}$，长度均为 $n$。$\texttt{0}$ 和 $\texttt{1}$ 分别可以和自己匹配，$\texttt{?}$ 可以匹配 $\texttt{0}$ 和 $\texttt{1}$。
>
> 定义一个 $\texttt{0/1}$ 串可以匹配一个仅含 $\texttt{0/1/?}$ 的串当且仅当它们长度相同且对应位置均可匹配。
>
> 有 $q$ 次询问，每次进行一种操作：
>
> 1. 修改第 $i$ 个字符串为另一个仅含 $\texttt{0/1/?}$ 的长度为 $n$ 的串；
> 2. 给定 $[l,r]$，查询有多少 $\texttt{0/1}$ 串可以匹配到第 $l$ 个到第 $r$ 个串全体。

## 思路

考虑对于一段所有字符串的第 $x$ 个字符，一共有四种可能：确定为 $\texttt{0}$；确定为 $\texttt{1}$；都可以；都不可以。如果 $\texttt{0/1}$ 都不可以则答案为 $0$，因为不会有任何一个字符串匹配该区间。如果确定为某个数，则这一位只有一种可能；否则这一位有两种可能。根据乘法原理，如果有 $a$ 个位置有两种可能，则本次询问的答案为 $2^a$。

注意到字符串长度只有 $30$，所以一个串每个位置的信息可以用一个 `pair<int,int>` 存下来：

- `first` 的第 $i$ 位为 $0$ 表示第 $i$ 个字符可以是 $\texttt0$ 也可以是 $\texttt1$；
- `first` 的第 $i$ 位为 $1$ 表示第 $i$ 个字符是 `second` 的第 $i$ 位。

这个信息可以推广到区间上：$[l, r]$ 内每个位置的信息也可以用这样一个 `pair<pair<int, int>, bool>` 存下来：

- `first.first` 的第 $i$ 位为 $0$ 表示这个区间里所有的串第 $i$ 个字符可以是 $\texttt0$ 也
  可以是 $\texttt1$；
- `first.second` 的第 $i$ 位为 $1$ 表示这个区间里所有串的第 $i$ 个字符是 `second`
  的第 $i$ 位。

`second` 为 $0$ 表示这个区间的信息不合法。转移时从左右孩子进行一下位运算合并。如果两个孩子已确定的
位置有冲突则区间不合法。具体的实现见代码。

## Code

```cpp
// 这道题是个区间询问，单点修改，所以有兴趣的读者可以去看看树状数组的题解（本人蒟蒻不会
#include<bits/stdc++.h>
#define lson l,mid,rt << 1
#define rson mid + 1,r,rt << 1 | 1
#define mk(x,y,z) make_pair(make_pair(x,y),z)
#define type pair<pair<int,int>,bool>
using namespace std;
const int maxn = 1e5 + 5;
type sg[maxn << 4]; int x[maxn],y[maxn]; // sg为线段树，x,y分别存储原串的?位 & 原串的0/1位
char s[maxn],k[maxn]; int nowl,nowr,n,m,q; // nowl和nowr表示查询区间为[nowl,nowr]
void update(int rt) {
    int ls = rt << 1, rs = rt << 1 | 1;
    sg[rt].first.first = sg[ls].first.first | sg[rs].first.first,
    // 当前区间的自由位，为左右子区间同时为自由位的位
    sg[rt].first.second = sg[ls].first.second | sg[rs].first.second,
    // 当前区间的固定位，为左右子区间同一位上至少有一个固定位的位
    sg[rt].second = sg[ls].second & sg[rs].second & !((sg[ls].first.first & sg[rs].first.first) & (sg[ls].first.second ^ sg[rs].first.second));
    // 答案为0的情况：
    // 1. 左右孩子本身答案就为0
    // 2. 左右孩子在固定位上产生冲突
}
void build(int l,int r,int rt) {
    if (l == r) {
        sg[rt] = mk(x[l],y[l],true); // 自己总是可以匹配自己
        return ;
    }
    int mid = (l + r) >> 1;
    build(lson); build(rson); update(rt);
    // cout << sg[rt]
}
type query(int l,int r,int rt) {
    if (nowl <= l && r <= nowr) return sg[rt];
    int mid = (l + r) >> 1; 
    if (nowl <= mid && mid < nowr) {
        type ls = query(lson), rs = query(rson), res;
        res.first.first = ls.first.first | rs.first.first,
        res.first.second = ls.first.second | rs.first.second,
        res.second = ls.second & rs.second & !((ls.first.first & rs.first.first) & (ls.first.second ^ rs.first.second));
        // 返回值与update计算原理相同
        return res;
    }
    if (nowl <= mid) return query(lson);
    if (mid < nowr) return query(rson);
}
void modify(int l,int r,int rt,int u,int v) { // 用nowl记录修改位置
    if (l == r) {
        sg[rt] = mk(u,v,true);
        return ;
    }
    int mid = (l + r) >> 1;
    if (nowl <= mid) modify(lson,u,v);
    else modify(rson,u,v);
    update(rt);
}
int main() {
    scanf("%d%d%d",&n,&m,&q);
    for (int i = 1;i <= m;i ++) {
        scanf("%s",s); // 当第i位为自由位的时候我们令第i位固定位为0，方便处理
        for (int j = 0;j < n;j ++)
            if (s[j] != '?') // 固定位
                x[i] |= 1 << (n - j), 
                y[i] |= (s[j] - '0') << (n - j); 
    }
    build(1,m,1); int ans = 0;
    for (int t = 1,op,u,v,now;t <= q;t ++) {
        scanf("%d",&op);
        if (op) { // 题意中的操作一
            scanf("%d %s",&nowl,k), u = v = 0;
            for (int j = 0;j < n;j ++) // 按照最开始的方法计算出修改值串的信息
                if (k[j] != '?')
                    u |= 1 << (n - j),
                    v |= (k[j] - '0') << (n - j);
            modify(1,m,1,u,v);
        } else { // 提议中的操作二
            scanf("%d%d",&nowl,&nowr), now = 1;
            type res = query(1,m,1);
            if (!res.second) { // 答案为0
                ans ^= 0;
                continue;
            }
            for (int i = 1;i <= n;i ++) // 按照乘法原理计算个数
                if (!(res.first.first & (1 << (i))))
                    now <<= 1;
            ans ^= now;
        }
    }
    printf("%d",ans);
    return 0;
}
```

- 评测信息：[R127354197 记录详情](https://www.luogu.com.cn/record/127354197)

---

## 作者：MuelsyseU (赞：1)

提供一份较为简短易懂（1.5k）的代码。

其实很少在洛谷做状压题，看到这题立马想到 P5576 和 SAM（）

但是看到 $n$ 的范围很明显可以采取状压。但是我们发现并不能很好地保存下 `?` 的位置，因此考虑用两个二进制数存储一个字符串，$t_0$ 的每一位表示字符串这一位是否不是 `?`，$t_1$ 的每一位表示字符串这一位是否是 `1`。如 `10?` 对应 $t_0=(110)_2,t_1=(100)_2$。

观察每个询问的答案，可以发现一定是 $0$ 或 $2^k$ 且 $0\le k\le n$。这是因为使若干个字符串都有可能是 $S$，那么 $S$ 在某一位有两种可能当且仅当这些字符串这一位都是 `?`，而答案为 $0$ 当且仅当存在其中两个字符串同一位上分别出现 `1` 和 `0`。

于是，我们可以扩展上面的状压来表示一个字符串集合，设 $t_0$ 表示每一位上这些字符串是否不均为 `?`，$t_1$ 表示每一位上这些字符串是否均为 `1`。

观察到对于两个集合，$t_0$ 和 $t_1$ 可以直接合并，但是如果有一位上两个集合的 $t_1$ 分别为 $0$ 和 $1$，且两个集合对应该位上都并不全是 `?`（也就是一个存在 `0`，一个存在 `1`），那么就会产生冲突。

由于位运算每一位独立，不冲突的条件可以表示为：

$$(t_0 \operatorname{and} t_0') \operatorname{and} (t_1 \operatorname{xor} t_1')= 0$$

如果满足条件，则可以直接合并，把 $t_0$ 和 $t_1$ 分别取或；否则我们给它打上内部存在冲突的 tag，并在合并时传递该 tag 即可。

```cpp
struct Seg {
	int t0, t1; 
	bool b;
};
inline Seg pushup(Seg x, Seg y) { return {x.t0 | y.t0, x.t1 | y.t1, x.b && y.b && !((x.t0 & y.t0) & (x.t1 ^ y.t1))}; };

```
利用这个合并操作，就可以写出一颗维护整个序列的线段树了。它显然支持单点修改。

复杂度 $O(n\log n)$，空间线性，常数较小。

```cpp
#include<iostream>
#define maxn 2000005
#define mid ((l + r) >> 1)
using namespace std;

int n, m, q, c, x, y, sum, ls[maxn], rs[maxn], pw[35] = {1}, tot;
char s[35];
struct Seg {
	int t0, t1; 
	bool b;
} ans, a[maxn], t[maxn];
inline void set(Seg& x) {
	x.t0 = x.t1 = 0;
	for (int j = 0; j < m; ++j) x.t0 |= (s[j] != '?') << j, x.t1 |= (s[j] == '1') << j;
}
inline Seg pushup(Seg x, Seg y) { return {x.t0 | y.t0, x.t1 | y.t1, x.b && y.b && !((x.t0 & y.t0) & (x.t1 ^ y.t1))}; };
inline int build(int l, int r) {
	int p = ++tot;
	if (l == r) t[p] = a[l];
	else ls[p] = build(l, mid), rs[p] = build(mid + 1, r), t[p] = pushup(t[ls[p]], t[rs[p]]);
	return p;
}
inline void change(int p, int l, int r, int i) {
	if (l == r) set(t[p]);
	else if (i <= mid) change(ls[p], l, mid, i);
	else change(rs[p], mid + 1, r, i);
	if (l != r) t[p] = pushup(t[ls[p]], t[rs[p]]);
}
inline void query(int p, int l, int r, int ql, int qr) {
	if (l >= ql && r <= qr) ans = pushup(ans, t[p]);
	else {
	    if (ql <= mid) query(ls[p], l, mid, ql, qr);
	    if (qr > mid) query(rs[p], mid + 1, r, ql, qr);
    }
}
int main(){
	scanf("%d%d%d", &m, &n, &q);
	for (int i = 1; i <= n; ++i) scanf("%s", s), set(a[i]), a[i].b = 1;
	for (int i = 1; i <= m; ++i) pw[i] = pw[i - 1] * 2;
	build(1, n);
	while (q--) {
		scanf("%d%d", &c, &x);
		if (!c) scanf("%d", &y), ans = {}, ans.b = 1, query(1, 1, n, x, y),
			sum ^= pw[m - __builtin_popcount(ans.t0)] * ans.b;
		else scanf("%s", s), change(1, 1, n, x);
	}
	printf("%d", sum);
	return 0;
}
```

---

## 作者：2018LZY (赞：1)

~~简单~~写写就卡到$rk1$...

~~来分享一下卡常心得~~

首先,对于一次询问,一个位置有4种情况,$0,1,?,$无解.

由于只有30位,我们可以用$long~long$把用4进制把一个串状态压缩.

4进制的压缩方法:

+ 无解$->0$
+ $0->1$
+ $1->2$
+ $?->3$.



然后就是一个简单的区间与,线段树我们用$zkw$从而可以又短又快...

```cpp
int n, m, q, ans, k;

int v[150];
void qr(char *s) {
	char c = gc;
	while(!v[(int)c]) c = gc;
	while(v[(int)c]) *s++ = c, c = gc;
}

char str[33];
ll in() {
	qr(str + 1); ll res = 0;
	FOR(i, n) res = res * 4 + v[(int)str[i]];
	return res;
}

ll a[N];

void solve() {
	qr(n, m, q); ans = 0;
	v['0'] = 1; v['1'] = 2; v['?'] = 3;
	for(k = 1; k < m; k *= 2);
	FOR(i, m) a[i + k - 1] = in();
	REP(i, 1, k - 1) a[i] = a[i * 2] & a[i * 2 + 1];
	while(q--) {
		int o, l, r; qr(o, l);
		if(!o) {
			qr(r); ll val = -1;
			for(l += k - 1, r += k; l < r; l /= 2, r /= 2) {
				val &= a[l];
				if(l & 1) l++;
				if(r & 1) val &= a[r ^ 1];
			}
			int s = 1;
			FOR(i, n) {
				int x = val & 3; val >>= 2;
				if(!x) {s = 0; break;}
				if(x == 3) s *= 2;
			}
			ans ^= s;
		}
		else {
			a[l += k - 1] = in();
			while(l /= 2) a[l] = a[l * 2] & a[l * 2 + 1];
		}
	}
	pr2(ans);
}
```





---

## 作者：_虹_ (赞：1)

其实状压+线段树是很显然的。

主要难度在于合并区间信息。

三进制显然是不星的，O(nqlogm)比较危险（~~卡常神仙Orz~~），得想点办法在二进制下解决问题做到O(qlogm)。

具体解释写在代码里了。

| & ^这三个位运算居然不是同一个优先级。。。。。
```cpp
#include <iostream>
#include <string>
using namespace std;
struct unit{
	int bit=0;//1 表示1 0表示0或pending 
	int pending=0;
};
struct node{
	unit res;
	int l,r;
};
inline int ls(int i)
{
	return i<<1;
}
inline int rs(int i)
{
	return ls(i)|1;
}
const int kmaxn=1000000+10+5;
const int failbit=1<<30;
node T[kmaxn<<2];
string rd[kmaxn];
unit merge(const unit& l,const unit& r)
{
	unit res;
	res.pending=l.pending & r.pending; 
	int cfm=l.pending ^ r.pending;//获取只有一方pending的bit，称为cfm bit 
	
	cfm=(l.bit | r.bit) & cfm;//对于一个cfm bit，因为l/r中有且只有一方确定了该位，而pending状态表示为0
								 //所以若l/r中有一方该位为1，则该位应为1（1&pending），否则为0（0&pending） 
	res.bit=l.bit | cfm;
	
	if(res.bit ^ (r.bit | cfm))//双方将新确定的bit更新后不相同,说明有确定的bit不同，说明不存在复读机 
		res.bit|=failbit;

		
	//当然也可以xor取出双方不同的bit和cfm bit比较，若存在一个1在cfm中不存在而双方xor中存在，则不存在复读机
	//这个方法貌似更好想一点 
/*	
    res.bit=l.bit | r.bit;
	int dif=l.bit ^ r.bit;
	if((dif|cfm) ^ cfm)
		res.bit|=failbit;
	 
*/
	return res;
}
void upd(int p)
{
	if(T[p].l==T[p].r)return;
	T[p].res=merge(T[ls(p)].res,T[rs(p)].res);
}
unit init(int k)
{
	unit res;
	for(int i=0;i<rd[k].size();++i)
	{
		switch(rd[k][i])
		{
			case '0':
			case '1':
				res.bit+=(rd[k][i]-'0')<<i;
				break;
			case '?':
				res.pending+=1<<i;
		}
	}
	return res;
}
void build(int l,int r,int p=1)
{
	T[p].l=l;T[p].r=r;
	if(l==r)
	{
		T[p].res=init(l);
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(p));
	build(mid+1,r,rs(p));
	upd(p);
}
unit query(int l,int r,int p=1)
{
	if(T[p].l==l&&r==T[p].r)
		return T[p].res;
	int mid=(T[p].l+T[p].r)>>1;
	if(r<=mid)return query(l,r,ls(p));
	else if(l>mid)return query(l,r,rs(p));
	else
		return merge(query(l,mid,ls(p)),query(mid+1,r,rs(p)));
}
void mod(int k,int p=1)
{
	if(T[p].l==T[p].r)
	{
		T[p].res=init(k);
		return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(k<=mid) mod(k,ls(p));
	else mod(k,rs(p));
	upd(p);
}
int n,q;
int opt,x,y;
int ans;
unit u;
inline int lowbit(int i)
{
	return i&(-i);
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>n>>q;
	for(int i=1;i<=n;++i)
	{
		cin>>rd[i];
	}
	build(1,n);
//	cout<<1<<endl;
	while(q--)
	{
		cin>>opt>>x;
		if(opt)
		{
			cin>>rd[x];
			mod(x);
		}
		else
		{
			cin>>y;
			u=query(x,y);
			if(u.bit&failbit)
				continue;
			x=1;
//			cout<<"pd	"<<u.pending<<endl;
			while(u.pending)
			{
				x<<=1;
				u.pending-=lowbit(u.pending);
			}
//			cout<<x<<endl;
			ans^=x;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```



------------
~~什么神仙状压题~~

---

## 作者：Honor誉 (赞：1)

区间操作考虑用线段树维护。

建$n*2$棵线段树，前$n$棵线段树维护每个串的第i位是否是0。

后$n$棵线段树维护每个串的第i位是否是1。

如果是问号的话，直接跳过就好(通过1和0能看出是否是问号)。

然后分三种情况统计答案：

1.有1也有0,不可能，$ans=0$

2.只有1或0，一种情况，$ans$不变。

3.既没有0也没有1，两种情况$ans*=2$

![](https://cdn.luogu.com.cn/upload/pic/74823.png)

像这样这棵线段树。

但是这样会很慢。

考虑状压。

这样只用开两棵线段树，一个存零，一个存一。

把状态压缩成一个$int$,最多30位，转换成十进制$int$能存下。

然后的建树、查询、更改操作其实就是类似一个模板。

建树：

```cpp
void build(int hao,int l,int r)
{
	if(l==r)
	{
		for(int i=1;i<=n;i++)
		{
			if(s[l][i]=='?')//问号跳过
			{
				continue;
			}
			flag[hao][s[l][i]-'0']|=(1<<(i-1));//状压
		}
		return;
	}
	int mid=(l+r)/2;
	build(hao<<1,l,mid);
	build(hao<<1|1,mid+1,r);
        flag[hao][0]=flag[hao<<1][0]|flag[hao<<1|1][0];
	flag[hao][1]=flag[hao<<1][1]|flag[hao<<1|1][1];
}
```

查询：

```cpp
data query(int hao,int l,int r,int L,int R)
{
	if(L<=l&&R>=r)
	{
		return (data){flag[hao][0],flag[hao][1]};
	}
    int mid=(l+r)/2;
    data kkk=none;
    if(L<=mid)
    {
    	kkk=kkk+query(hao<<1,l,mid,L,R);
	}
	if(R>mid)
	{
		kkk=kkk+query(hao<<1|1,mid+1,r,L,R);
	}
	return kkk;
}
```

我们这里返回一个data的量，以便于后面计算答案。

计算答案的主程序：

```cpp
    scanf("%d%d",&l,&r);
    data ans=query(1,1,m,l,r);
    anss=1;
    for(int i=1;i<=n;i++)//只有1或0的方案数只有一种
    {
        if(ans.x&1&&ans.y&1)//第i位既有1又有0，不可能。
        {
            anss=0;
            break;
        }
        if(!(ans.x&1)&&!(ans.y&1))//都是问号
        {	
            anss*=2;
        }
        ans.x>>=1;
        ans.y>>=1;
    }
    ansss^=anss;
```

更改：

```cpp
void change(int hao,int l,int r,int x)
{
	if(l==r)
	{
		flag[hao][0]=flag[hao][1]=0;//单点修改
		for(int i=1;i<=n;i++)
		{
			if(ch[i]=='?')
			{
				continue;
			}
			flag[hao][ch[i]-'0']|=(1<<(i-1));
		}
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid)
	{
		change(hao<<1,l,mid,x);
	}else{
		change(hao<<1|1,mid+1,r,x);
	}
	flag[hao][0]=flag[hao<<1][0]|flag[hao<<1|1][0];
	flag[hao][1]=flag[hao<<1][1]|flag[hao<<1|1][1];
}
```

最后就把这些函数结合在一起就可以了。

```cpp
#include<bits/stdc++.h>
#define N 400010
using namespace std;
int flag[N<<2][2],n,m,q,op,ansss,l,r,anss;
char s[N][41],ch[41];
struct data
{
    int x,y;
}none;
data operator +(data a,data b)
{
    return (data){a.x|b.x,a.y|b.y};
} 
void build(int hao,int l,int r)
{
	if(l==r)
	{
		for(int i=1;i<=n;i++)
		{
			if(s[l][i]=='?')//问号跳过
			{
				continue;
			}
			flag[hao][s[l][i]-'0']|=(1<<(i-1));//状压
		}
		return;
	}
	int mid=(l+r)/2;
	build(hao<<1,l,mid);
	build(hao<<1|1,mid+1,r);
        flag[hao][0]=flag[hao<<1][0]|flag[hao<<1|1][0];
	flag[hao][1]=flag[hao<<1][1]|flag[hao<<1|1][1];
}
data query(int hao,int l,int r,int L,int R)
{
	if(L<=l&&R>=r)
	{
		return (data){flag[hao][0],flag[hao][1]};
	}
    int mid=(l+r)/2;
    data kkk=none;
    if(L<=mid)
    {
    	kkk=kkk+query(hao<<1,l,mid,L,R);
	}
	if(R>mid)
	{
		kkk=kkk+query(hao<<1|1,mid+1,r,L,R);
	}
	return kkk;
}
void change(int hao,int l,int r,int x)
{
	if(l==r)
	{
		flag[hao][0]=flag[hao][1]=0;//单点修改
		for(int i=1;i<=n;i++)
		{
			if(ch[i]=='?')
			{
				continue;
			}
			flag[hao][ch[i]-'0']|=(1<<(i-1));
		}
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid)
	{
		change(hao<<1,l,mid,x);
	}else{
		change(hao<<1|1,mid+1,r,x);
	}
	flag[hao][0]=flag[hao<<1][0]|flag[hao<<1|1][0];
	flag[hao][1]=flag[hao<<1][1]|flag[hao<<1|1][1];
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s[i]+1);
	}
	build(1,1,m);
	for(int i=1;i<=q;i++)
	{
		scanf("%d",&op);
		if(op==0)
		{
			scanf("%d%d",&l,&r);
    		data ans=query(1,1,m,l,r);
   	 		anss=1;
    		for(int i=1;i<=n;i++)//只有1或0的方案数只有一种
    		{
        		if(ans.x&1&&ans.y&1)//第i位既有1又有0，不可能。
        		{
            		anss=0;
            		break;
        		}
        		if(!(ans.x&1)&&!(ans.y&1))//都是问号
        		{	
            		anss*=2;
        		}
        		ans.x>>=1;
        		ans.y>>=1;
    		}
    		ansss^=anss;
		}else{
			scanf("%d%s",&l,ch+1);
			change(1,1,m,l);
		}
	}
    printf("%d\n",ansss);
	return 0;
}
```

---

## 作者：OMITW (赞：0)

# 前言
又是一道模拟赛的原题。前天这题是 lgj 大神选出来的第三题。考试的时候瞬间想到了线段树，怒打了 136 行代码。没想到 AC 了。

# 思路推导

看完题目后要养成良好的习惯，去看数据范围。$ m $ 最大为 $ 100007 $，$ q $ 最大为 $ 1000007 $？这么大？$ n $ 最大为 $ 30 $？？！！没问题了，想法直接出来！

我们可以运用二进制来表示每一位，即第 $ i $ 位的值用 $ 2^i $ 的值来表示。就是要运用到状态压缩和位运算。但答案求的是满足的方案，那我们就可以用线段树进行维护。

首先我们要开三个数组 $ f1[i] $ 表示字符串中不为 ? 的值。$ f2[i] $ 表示字符串中为 0 的值。$ f3[i] $ 表示当前的字符串能否表示。然后开一个线段树维护。

不难发现具有以下的性质：

* 对于 $ f1[x] $，传递上来的数组为 $ f1[le] $ 和 $ f1[ri] $。如果有一位两个数组都不是问号，且不相同。那么这个区间肯定无法表示一个字符串，那么 $ f3[x] $ 可以直接为 $ 1 $ 了。

* 对于 $ f1[x] $，传递上来的数组为 $ f1[le] $ 和 $ f1[ri] $。如果有一位两个数组,一个是问号，另一个不是。那么表示出来的字符串但前位置只能是不是问号的。

* 对于 $ f3[x] $，传递上来的数组为 $ f3[le] $ 和 $ f3[ri] $。如果有一个标记为 $ 1 $。那么都是不可被表示的，直接赋值 $ 1 $，继续向上。

最后查找的时候，只需看为 $ 0 $ 的个数是多少就行了。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+50;
int m,n,t,k,op,l,r,b[MAXN][3],flag,sum,ans;
int f1[MAXN*4],f2[MAXN*4],f3[MAXN*4];
string s,q;
void build(int x,int l,int r)
{
	if(l==r)
	{
		cin>>s;
		for(int i=0;i<m;i++)
			if(s[i]!='?')
			{
				f1[x]|=(1<<i);
				if(s[i]-'0'!=0)f2[x]|=(1<<i);
			}
		return;
	}
	int le=x<<1,ri=x<<1|1,mid=(l+r)>>1;
	build(le,l,mid);
	build(ri,mid+1,r);
	if(f3[le]|f3[ri])f3[x]=1;
	else
	{
		f1[x]=f1[le]|f1[ri];
		for(int i=0;i<m;i++)
			if((f1[x]&(1<<i)))
			{
				if((f1[le]&(1<<i))&&(f1[ri]&(1<<i))&&(f2[le]&(1<<i))!=(f2[ri]&(1<<i)))
				{
					f3[x]=1;
					break;
				}
				else
				{
					if((f1[le]&(1<<i)))f2[x]|=(f2[le]&(1<<i));
					else f2[x]|=(f2[ri]&(1<<i));
				}
			}
	}
}
void update(int x,int l,int r,int qu)
{
	if(l==r)
	{
		f1[x]=f2[x]=f3[x]=0;
		cin>>s;
		for(int i=0;i<m;i++)
			if(s[i]!='?')
			{
				f1[x]|=(1<<i);
				if(s[i]-'0'!=0)f2[x]|=(1<<i);
			}
		return;
	}
	int le=x<<1,ri=x<<1|1,mid=(l+r)>>1;
	if(qu<=mid)update(le,l,mid,qu);
	else update(ri,mid+1,r,qu);
	if(f3[le]|f3[ri])f3[x]=1;
	else
	{
		f2[x]=f3[x]=0;
		f1[x]=f1[le]|f1[ri];
		for(int i=0;i<m;i++)
			if((f1[x]&(1<<i)))
			{
				if((f1[le]&(1<<i))&&(f1[ri]&(1<<i))&&(f2[le]&(1<<i))!=(f2[ri]&(1<<i)))
				{
					f3[x]=1;
					break;
				}
				else
				{
					if((f1[le]&(1<<i)))f2[x]|=(f2[le]&(1<<i));
					else f2[x]|=(f2[ri]&(1<<i));
				}
			}
	}
}
void query(int x,int l,int r,int ql,int qr)
{
	if(flag)return; 
	if(ql<=l&&r<=qr)
	{
		if(f3[x])
		{
			flag=1;
			return;
		}
		for(int i=0;i<m;i++)
			if(((sum|f1[x])&(1<<i)))
			{
				if((sum&(1<<i))&&(f1[x]&(1<<i))&&(ans&(1<<i))!=(f2[x]&(1<<i)))
				{
					flag=1;
					break;
				}
				else ans|=(f2[x]&(1<<i));
			}
		sum|=f1[x];
		return;
	}
	int le=x<<1,ri=x<<1|1,mid=(l+r)>>1;
	if(ql<=mid)query(le,l,mid,ql,qr);
	if(qr>mid)query(ri,mid+1,r,ql,qr);
}
int main()
{
	scanf("%d%d%d",&m,&n,&t);
	build(1,1,n);
	while(t--)
	{
		cin>>op;
		if(!op)
		{
			scanf("%d%d",&l,&r);
			sum=flag=ans=0;
			query(1,1,n,l,r);
			int ji=1;
			if(!flag)
			{
				for(int i=0;i<m;i++)
					if((sum&(1<<i))==0)ji*=2;
				k^=ji;
			}
		}
		else
		{
			scanf("%d",&l);
			update(1,1,n,l);
		}
	}
	printf("%d",k);
	return 0;
}
```

---

## 作者：rmzls (赞：0)

### 思路
我们先考虑对于单独一个字符串怎么算他可能成为那些字符串。  
我们发现一个位置是 $?$ 的时候是没有对这一位置上是什么字符有限制，而 $0$ 和 $1$ 是有限制的（这一位必须和他一样）。因此，我们把这个字符串每一位上是不是有限制（必须是 $0$ 或 $1$）状态压缩成两个数 $k1$，$k2$，分别存关于 $0$ 和 $1$ 的限制（比如我们存对于这个位置上限制一定是 $1$ 的状压变量为 $k1$，则 $k1$ 的二进制第 $i$ 位如果是 $1$，那么字符串第 $i$ 位必须是 $1$。$0$ 同理）。  
对于统计，我们按每一位扫这两个数，如果两个数相同的位置上都是 $1$，那么这一位又必须是 $0$ 又必须是 $1$，自然无解。如果两个数相同的位置上都是 $0$，那么这一位又可以是 $0$ 又可以是 $1$，这个时候答案乘 $2$。  
#### 统计代码
```cpp
int cnt=1;
for(int i=0;i<=n-1;i++){
	int ii=(k1&1),jj=(k2&1);
	if(ii==jj&&jj==0){
		cnt*=2;
	}
	if(ii==jj&&jj==1){
		cnt=0;
		break;
	}
	k1>>=1;k2>>=1;
}
```

现在我们要考虑多个字符串，我们发现对于每一位上的限制具有“或“的性质（即比如有一堆字符串，其中一个对于第 $i$ 位有限制必须是 $1$，那么满足这一堆字符串能成为的字符串，第 $i$ 位必须也是 $1$），因此我们维护区间上的两个状压数按位或的和，建立线段树，按照上面的统计方式计数即可。

------------
### 代码
这里的线段树是用指针写的（可以少那么一点点内存），其实原理和数组写线段树一样。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100057;
int n,m,q,opt,ans,l,r;
char a[N][500];
struct node{
	int l,r,zand,fand;
	node *left;
	node *right;
};
void build(node *prs,int l,int r){
	prs->l=l;prs->r=r;
	if(l==r){
		int k1=0,k2=0;
		for(int i=0;i<n;i++){			
			k1<<=1;k2<<=1;
			if(a[l][i]=='1'){
				k1|=1;
			}
			else if(a[l][i]=='0'){
				k2|=1;
			}
		}
		prs->zand=k1;prs->fand=k2;
		return ;
	}
	int mid=(l+r)>>1;
	prs->left=new node;prs->right=new node;
	build(prs->left,l,mid);
	build(prs->right,mid+1,r);
	prs->zand=(prs->left->zand|prs->right->zand);
	prs->fand=(prs->left->fand|prs->right->fand);
}
void merge(node* prs,int p){
	if(prs->l==prs->r&&prs->l==p){
		int k1=0,k2=0;
		for(int i=0;i<n;i++){			
			k1<<=1;k2<<=1;
			if(a[p][i]=='1'){
				k1|=1;
			}
			else if(a[p][i]=='0'){
				k2|=1;
			}
		}
		prs->zand=k1;prs->fand=k2;
		return ;
	}
	int mid=(prs->l+prs->r)>>1;
	if(p<=mid){
		merge(prs->left,p);
	}
	if(p>mid){
		merge(prs->right,p);
	}
	prs->zand=(prs->left->zand|prs->right->zand);
	prs->fand=(prs->left->fand|prs->right->fand);
}
int zs(node* prs,int l,int r){//统计k1
	if(l<=prs->l&&prs->r<=r){
		return prs->zand;
	}
	int sum=0,mid=(prs->l+prs->r)>>1;
	if(l<=mid){
		sum|=zs(prs->left,l,r);
	}
	if(r>mid){
		sum|=zs(prs->right,l,r);
	}
	return sum;
}
int fs(node* prs,int l,int r){//统计k2
	if(l<=prs->l&&prs->r<=r){
		return prs->fand;
	}
	int sum=0,mid=(prs->l+prs->r)>>1;
	if(l<=mid){
		sum|=fs(prs->left,l,r);
	}
	if(r>mid){
		sum|=fs(prs->right,l,r);
	}
	return sum;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&q);
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	node* root=new node;
	build(root,1,m);
	for(int i=1;i<=q;i++){
		scanf("%lld",&opt);
		if(opt==0){
			scanf("%lld%lld",&l,&r);
			int k1=zs(root,l,r);
			int k2=fs(root,l,r);
			int cnt=1;
			for(int i=0;i<=n-1;i++){
				int ii=(k1&1),jj=(k2&1);
				if(ii==jj&&jj==0){
					cnt*=2;
				}
				if(ii==jj&&jj==1){
					cnt=0;
					break;
				}
				k1>>=1;k2>>=1;
			}
			ans^=cnt;
		}
		else{
			int p;
			scanf("%lld",&p);
			cin>>a[p];
			merge(root,p);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Aryper (赞：0)

[yLOI2019] 棠梨煎雪

写了一个树状数组，然后被卡常了。

事实上要写一个状压。

然后我们可以存储两个状态 $a_i$ 和 $b_i$。

$a_i$ 的每一位表示这个串的这一位为 0 还是 1，其中为 ? 的位为 0。

然后 $b_i$ 的每一位表示这个串的这一位是否为 ```?```。

然后就可以瞎搞了。

其实这个 ```?``` 位，在某次查询中，一个位上的 ```?``` 只能全取 0 或全取 1，那么我们想办法实现这个。

于是乎，$a_i\operatorname{xor} b_i$ 就可以让这些位全取 1，$a_i$ 本身就可以让这些位全取 0。

显然前一种值维护区间或，后一种值维护区间与，再多维护一个 $b_i$ 的区间与即可。

线段树维护就好了。

最后看每一位，如果该位不能全 1 并且该位不能全 0 这个区间就是不合法的，否则合法，我们利用 $b_i$ 的区间与看这一位是否都是问号，如果是，使答案乘 2。

时间复杂度 $O(q(n+\log m))$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#define ll long long
using namespace std;

const ll N=30,M=1e5+10;

ll n,m,q,pos,l,r,op,ans;

ll a[M],b[M];

char s[N+10];

struct sgt{
	ll l,r,dat0,dat1,dat2;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define dat0(x) tree[x].dat0
	#define dat1(x) tree[x].dat1
	#define dat2(x) tree[x].dat2
}tree[M*4];

void build(ll p,ll l,ll r) {
	l(p)=l;r(p)=r;
	if(l==r) {
		dat0(p)=a[l];dat1(p)=a[l]^b[l];
		dat2(p)=b[l];
		return;
	}
	ll mid=(l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	dat0(p)=dat0(p<<1)|dat0(p<<1|1);
	dat1(p)=dat1(p<<1)&dat1(p<<1|1);
	dat2(p)=dat2(p<<1)&dat2(p<<1|1);
	return;
}

sgt ask(ll p,ll l,ll r) {
	if(l(p)>=l&&r(p)<=r) {
		return tree[p];
	}
	ll mid=(l(p)+r(p))>>1;
	if(l>mid) return ask(p<<1|1,l,r);
	if(r<=mid) return ask(p<<1,l,r);
	sgt tmpl=ask(p<<1,l,r),tmpr=ask(p<<1|1,l,r),res;
	res.dat0=tmpl.dat0|tmpr.dat0;
	res.dat1=tmpl.dat1&tmpr.dat1;
	res.dat2=tmpl.dat2&tmpr.dat2;
	return res;
}

void modify(ll p,ll x,ll ka,ll kb) {
	if(l(p)==r(p)) {
		dat0(p)=ka;dat1(p)=ka^kb;
		dat2(p)=kb;
		return;
	}
	ll mid=(l(p)+r(p))>>1;
	if(x<=mid) modify(p<<1,x,ka,kb);
	if(x>mid) modify(p<<1|1,x,ka,kb);
	dat0(p)=dat0(p<<1)|dat0(p<<1|1);
	dat1(p)=dat1(p<<1)&dat1(p<<1|1);
	dat2(p)=dat2(p<<1)&dat2(p<<1|1);
	return;
}

inline ll read() {
	ll ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') {ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
	return ret*f;
}

inline void write(ll x) {
	static char buf[22];static ll len=-1;
	if(x>=0) {
		do{buf[++len]=x%10+48;x/=10;}while(x);
	}
	else {
		putchar('-');
		do{buf[++len]=-(x%10)+48;x/=10;}while(x);
	}
	while(len>=0) putchar(buf[len--]);
}

int main() {
	
	n=read();m=read();q=read();
	
	for(ll i=1;i<=m;i++) {
		scanf("%s",s+1);
		for(ll j=1;j<=n;j++) {
			if(s[j]=='0') continue;
			if(s[j]=='1') {
				a[i]|=(1<<(j-1));
			}
			if(s[j]=='?') {
				b[i]|=(1<<(j-1));
			}
		}
	}
	
	build(1,1,m);
	
	while(q--) {
		op=read();
		if(op==0) {
			l=read();r=read();
			sgt tmp=ask(1,l,r);
			ll sum=1;
			for(ll i=1;i<=n;i++) {
				if(((tmp.dat0>>(i-1))&1)&&(!((tmp.dat1>>(i-1))&1))) {
					sum=0;break;
				}
				if((tmp.dat2>>(i-1))&1) sum<<=1;
			}
			ans=ans^sum;
		}
		if(op==1) {
			pos=read();
			scanf("%s",s+1);
			ll tmpa=0,tmpb=0;
			for(ll i=1;i<=n;i++) {
				if(s[i]=='0') continue;
				if(s[i]=='1') {tmpa|=(1<<(i-1));}
				if(s[i]=='?') {tmpb|=(1<<(i-1));}
			}
			modify(1,pos,tmpa,tmpb);
		}
	}
	
	write(ans);
	
	return 0;
}
```


---


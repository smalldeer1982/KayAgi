# 「EZEC-6」分组

## 题目描述

给你 $n$ 个数，将它们分成任意组（可以不连续），将每个组内的数按位或，并将各组的结果累加，在保证其结果最小的情况下求最多分成的组数。

## 说明/提示

以下为各个样例的一种构造方案。

- $\{1,1,4,5,1,4\}$
- $\{1,9,1,9,8,1\},\{0\}$
- $\{1,9,2,6,8,1,7\},\{0\}$
- $\{3,1,4,1,5,9,2,6,5\}$
- $\{9,9,8,2,4,4,3,5,3\}$
- $\{1,2,3\},\{4,8,12\}$

对于样例 $6$ ，$\{1,2,3,4,8,12\}$ 也是一种最小化答案的方案，但是 $\{1,2,3\},\{4,8,12\}$ 分出的组数更多。

本题采用捆绑测试计分。

* Subtask $1$ ：$n\leq8$，$20$ 分。
* Subtask $2$ ：$n\leq10^3$，$20$ 分。
* Subtask $3$ ：$a_i\in\{0,1\}$，$5$  分。
* Subtask $4$ ：$n=10^6$，且保证数据随机，$5$ 分。
* Subtask $5$ ：$n\leq10^6$，$30$ 分。
* Subtask $6$ ：$n\leq10^7$，$20$ 分。

对于所有数据，$0\leq a_i\leq10^{18}$，$1\leq n\leq10^7$。

如果你不知道什么是按位或，请[点击这里](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96)。

本题自动开启O2优化。

本题提供读入优化方式。

使用 `read(x);` 读入一个任意的整型 `x` 等价于 `scanf("%d", &x);`其中可以将 `%d` 自动识别为对应类型。

```cpp
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
```

## 样例 #1

### 输入

```
6
1 1 4 5 1 4```

### 输出

```
1```

## 样例 #2

### 输入

```
7
1 9 1 9 8 1 0```

### 输出

```
2```

## 样例 #3

### 输入

```
8
1 9 2 6 0 8 1 7```

### 输出

```
2```

## 样例 #4

### 输入

```
9
3 1 4 1 5 9 2 6 5```

### 输出

```
1```

## 样例 #5

### 输入

```
9
9 9 8 2 4 4 3 5 3```

### 输出

```
1```

## 样例 #6

### 输入

```
6
1 2 3 4 8 12```

### 输出

```
2```

# 题解

## 作者：do_while_true (赞：12)

官方题解。

Subtask $1$：直接爆搜。

Subtask $2$：留给一些看起来很对的乱搞。

Subtask $3$：所有的 $0$ 都能单独分，所有的 $1$ 必须分在一组，因为如果把 $1$ 分开的话按位或的和会增大。故答案为 $0$ 的个数，若出现 $1$ 则还要 $+1$。

Subtask $4$：猜答案，为 $1$。考虑完 Subtask $5$ 的做法，由于数据随机，这些二进制位很容易连通起来。

Subtask $5$：对于一个数的第 $x$ 位为 $1$，则所有第 $x$ 位为 $1$ 的都要分在一起，若分开这个二进制位会被统计两次。这样每个数会把一些二进制位链接起来，这些链接起来的肯定要放在一起。二进制拆位之后并查集求解即可。复杂度 $\mathcal{O}(n\log a)$。

Subtask $6$：只有 $60$ 个位置，直接并查集太浪费了。考虑用一个 ull 来表示状态，每次需要合并的时候才合并。最多合并 $60$ 次，每次合并共 $60$ 次。复杂度 $\mathcal{O}(n+60^2)$。

至此，问题解决。

```cpp
#include<iostream>
#include<cstdio>
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define ull unsigned long long
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline T& read(T& r) {
    r = 0; bool w = 0; char ch = getchar();
    while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
    while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
    return r = w ? -r : r;
}
const int N = 1000100;
int n, ans;
ull f[64], all;
signed main() {
    read(n);
    for(int i = 1; i <= 61; ++i) f[i] = 1ll << (i-1);
    for(int i = 1; i <= n; ++i) {
        ull x; read(x);
        if(!x) {
            ++ans;
            continue;
        }
        all |= x;
        int p = __builtin_ffsll(x); ull t = f[p] | x;
        if(t == f[p]) continue;
        for(int j = 1; j <= 61; ++j)
            if((1ll << (j-1)) & t)
                t |= f[j];
        for(int j = 1; j <= 61; ++j)
            if((1ll << (j-1)) & t)
                f[j] |= t;
    }
    for(int i = 1; i <= 61; ++i)
        if((1ll << (i-1)) & all)
            if(f[i]) {
                ++ans; ull t = f[i];
                for(int j = 1; j <= 61; ++j)
                    if((1ll << (j-1)) & t)
                        f[j] = 0;
            }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：zhimao (赞：9)

提供一个奇怪的 $O(nloglog_{a_{max}})$ 的做法 。

分析题意我们可以发现每个 0 可以自成一组 ， 两数 $x,y$ ， 使 $x\&y>0$ 则两数必在一组中($x+y>x|y=x+y-x\&y$) 。

则我们得到一个做法 ， 初始每个数自成一组 ， 每次判断两个数与一下是否为零 ， 不是则把两数所在的一组和起来 。

忽略并查集的时间为常数 ， 据此我们就有了从 $n^2$ 到 $nlog_{a_{max}}$ 的做法 ， 但由于毒瘤出题人丧心病狂 ， 这样的方法不能通过 。 

引入我的做法 ， 显然数二进制下最高位相同必在一个组里 ，那么我们可以二分最高位 ， 把它加入对应组 ， 之后对每个组两两比较合并即可，由于最多只有大概 60 组时间复杂度可以忽略不计 。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,bo[10000],a[10000],boo[10000],ans;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
signed main()
{
	read(n);
	bo[0]=1;
	for(int i=1;i<61;i++) bo[i]=bo[i-1]<<1;
	for(int i=1,x;i<=n;i++)
	{
		read(x);
		if(x==0)
		{
			++ans; 
			continue;
		}
		int l=0,r=60,mid=30;
		do
		{
			if(bo[mid]<=x&&bo[mid+1]>x) break;
			if(bo[mid]>x) r=mid; else l=mid;
			mid=(l+r)>>1;
		}while(1);
		a[mid]|=x;
		boo[mid]=1;
	}
	for(int i=0;i<=59;i++)
		if(boo[i])
		{
			++ans;
			for(int j=i+1;j<60;j++)
				if(a[i]&a[j])
				{
					--ans;
					a[j]|=a[i];
					break;
				}
		}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：gxy001 (赞：5)

这里介绍一种奇怪的 $O(n\sqrt{\log a_{i}})$ 的做法：

我们显然有一个二进制拆位的 $O(n\log a_i)$ 的做法，把一个数的所有 $1$ 用并查集合并即可。

对于 $\operatorname{popcount}\le \sqrt{\log a_{i}}$ 的部分，和上面做法一样，每次跳 $\operatorname{lowbit}$ 并查集合并。

对于 $\operatorname{popcount}> \sqrt{\log a_{i}}$ 的部分，我们开一个数组，每次加入这样的一个数就扫一遍数组，如果有相交的就或起来，这样数组内一定没有相交元素，元素数量就一定小于 $\sqrt{\log a_{i}}$。

代码：
```cpp
#include<cstdio>
#include<list>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
int n,c[70],mark[70],cnt;
int find(int x){
	while(x!=c[x])x=c[x]=c[c[x]];
	return x;
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x!=y)c[y]=x;
}
long long b[70];
int main(){
	read(n);
	for(int i=0;i<64;i++)c[i]=i;
	int ans=0;
	for(int i=1;i<=n;i++){
		long long x;
		read(x);
		if(x!=0){
			int d=__builtin_popcountll(x);
			if(d<=8){
				int p=__builtin_ctzll(x);
				x&=x-1;
				mark[p]=1;
				while(x){
					int d=__builtin_ctzll(x);
					x&=x-1;
					mark[d]=1;
					merge(p,d);
				}
			}else{
				static long long d[70];
				int ct=0;
				for(int i=1;i<=cnt;i++)if(x&b[i])x|=b[i];else d[++ct]=b[i];
				d[++ct]=x;
				for(int i=1;i<=ct;i++)b[i]=d[i];
				cnt=ct;
			}
		}else ++ans;
	}
	for(int i=1;i<=cnt;i++){
		long long &x=b[i];
		int p=__builtin_ctzll(x);
		x&=x-1;
		mark[p]=1;
		while(x){
			int d=__builtin_ctzll(x);
			x&=x-1;
			mark[d]=1;
			merge(p,d);
		}
	}
	for(int i=0;i<64;i++)ans+=mark[i]&&c[i]==i;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：gdz0214_and_zxb0214 (赞：4)

提供一种 $O(n)$ 的做法。

加上了快读，快写。

吸氧仅需 $384$ 毫秒。

思路：

按位思考。

输入 $x$，将 $s$ 数组中的第 $lowbit(x)$ 项或上 $x$（若 $x$ 为 $0$，直接将答案加一）。

遍历 $s$ 数组，每次都往后寻找到第一个相交的项。

随后合并，舍弃前者。

再遍历一遍，找出还剩下的组的数量。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)//快读
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
inline void write(int x){//快写
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
}
int n,s[60],x,cnt;
signed main(){//防止变成long long main
	read(n);
	for(int i=1;i<=n;i++){
		read(x);
		if(!x){//若x为0,可单独分组
			cnt++;
			continue;
		}
		s[signed(log2(x&-x))]|=x;//log2(x&-x)可理解为lowbit(x);
	}
	for(int i=0;i<60;i++){
		for(int j=i+1;j<60;j++){
			if(s[i]&s[j]){
				s[j]|=s[i];//必须合并
				s[i]=0;//舍弃
			}
		}
	}
	for(int i=0;i<60;i++){
		if(s[i]){
			cnt++;
		}
	}
	write(cnt);
    return 0;//功德圆满
}
```

---

## 作者：Shadow_Soldier (赞：3)

# 提前说的话
本文中，所有的 $\mid$ 符号都表示按位或，所有的 $\&$ 符号都表示按位与。若有特例，会特殊说明。
# 题意简化
题目中的【题目描述】部分已经足够简化了，这里就不再简化题意了，题目 [P7384 「EZEC-6」分组](https://www.luogu.com.cn/problem/P7384)。  
# 暴力与特殊数据简述（Subtask 1 & Subtask 3 & Subtask 4，30pts）
## 暴力（Subtask 1，20pts）
如果直接枚举组数再分组最后计算的话，时间复杂度将会达到惊人的 $\Omicron(n \cdot n^n \cdot n) = \Omicron(n^{n + 2})$，连 $n \le 8$ 的数据都过不去（如果能过，那就是数据水，因为 $8^{10} = 1073741824$，一看就不行）。优化的话，就直接枚举组号并用一个数组和一个变量分别去记录每组的元素个数和总组数，时间复杂度优化为 $\Omicron(n\cdot n^n) = \Omicron(n^{n+1})$。这会应该能过了（$8^9 = 134217728$，加一点剪枝（不加应该也行）应该能过，说应该是因为我觉得没意义，所以没试过）。  
## 特殊数据（Subtask 3 & Subtask 4，10pts）
### Subtask 3（5pts）
注意到，第三组测试数据：$a_i \in \{0,1\}$，稍加思索即可知：将每一个 $0$ 单独分一组，所有的 $1$ 分一组。那就输出：$0$ 的个数加 $1$——对吗？错！一定要特判一下没有 $1$ 的情况，没有 $1$ 时，是不能加 $1$ 的，加 $1$ 是表示加上放 $1$ 的那一组，$1$ 都没有，还怎么加？当然，不排除数据水卡过的情况（我没试过，不知道能不能过），但是我们不能因为数据水就认为自己过了。好吧，反正这个数据的分也是能拿到的。  
### Subtask 4（5pts）
注意到，第四组测试数据：$n = 10^6$，且保证数据随机。这就意味着，两个数大概率不会重复。不过等一会儿再说，先要证明一个引理。  
#### 引理 1
##### 是什么
对于任何两个非负整数 $x$、$y$，都有 $x + y \ge x \mid y$。并且这个不等式当且仅当 $x \text{ } \& \text{ } y = 0$ 时取等。  
##### 如何证明
先把 $x,y$ 的二进制形式表示出来（令 $x,y$ 的二进制分别为 $X$ 序列和 $Y$ 序列）。即：存在唯一的一种表示，使：$\sum_{i = 0}^{\infty}(X_i \cdot 2^i) = x$，$\sum_{i = 0}^{\infty}(Y_i \cdot 2^i)$（其中，$X_i,Y_i \in \{0,1\}$），则 $X$ 序列和 $Y$ 序列分别是 $x$ 与 $y$ 的二进制表示序列。  
再定义两个序列 $V$ 和 $W$，令 $V_i = X_i + Y_i$，$W_i = X_i \mid Y_i$，则不难发现：  
$$
\begin{cases}
  V_i = W_i & X_i \text{ } \& \text{ } Y_i = 0 \\
  V_i = W_i + 1 & X_i \text{ } \& \text{ } Y_i = 1 \\
\end{cases}
$$
$\therefore V_i \ge W_i$。  
即：$\sum_{i = 0}^{\infty} (V_i \cdot 2^i) \ge \sum_{i = 0}^{\infty} (W_i \cdot 2^i)$。  
又因为：  
$$
\begin{aligned}
\sum_{i = 0}^{\infty} (V_i \cdot 2^i) &= \sum_{i = 0}^{\infty} ((X_i + Y_i) \cdot 2^i) \\
&= (\sum_{i = 0}^{\infty} (X_i \cdot 2^i)) + (\sum_{i = 0}^{\infty} (Y_i \cdot 2^i)) \\
&= x + y
\end{aligned}
$$
以及：  
$$
\begin{aligned}
\sum_{i = 0}^{\infty} (W_i \cdot 2^i) &= \sum_{i = 0}^{\infty} ((X_i \mid Y_i) \cdot 2^i) \\
&= x \mid y
\end{aligned}
$$
所以：$x + y \ge x \mid y$。  
不难发现：这个不等式当且仅当 $\forall k \in \N, V_k= W_k$ 时取等。  
即：这个不等式当且仅当 $\forall k \in \N, X_k \text{ } \& \text{ } Y_k = 0$ 时取等。  
即：这个不等式当且仅当 $x \text{ } \& \text{ } y = 0$ 时取等。

引理证明完了，那这个引理又什么用呢？没用。注意到“保证数据随机”，所以不存在两个相同的的数同时都在原数组里。还有，令两个组中每组的所有元素按位或起来的结果分别为：$x$、$y$。  
$\because a_i \ge 0$，$\therefore x, y \ge 0$。  
注意到，若将两个组进行合并，组数会减一，那结果会发生什么变化呢？若结果比原来更小，则答案会更优。即：当且仅当 $x \mid y < x + y$ 时，这两个组才有必要合并。当然，这种形式我们肯定不想要。这个时候就用到了引理 1。$x \mid y < x + y$ 可以转变成 $x \text{ } \& \text{ } y \ne 0$。即：$x \text{ } \& \text{ } y > 0$（这一步是因为 $x,y \in \N$）。所以，当且仅当 $x \text{ } \& \text{ } y > 0$ 时，这两个组才有必要合并。然而此时的 $n$ 很大，所以即使出现了 $k$ 组不重复的的无序数对 $(u_i,v_i)(1 \le i \le k, 1 \le u_i,v_i \le n)$，使 $\forall 1 \le i \le k, a_{u_i} \text{ } \& \text{ } a_{v_i} = 0$，它们也总会合并到其它组中。然后紧接着导致这些组的合并，它们最终也会被合并。——除了 $0$ ！！！你可以特判一下，但是出现 $0$ 的几率也同样很小（当然，也有可能出现 $0$，~但是数据中确实没有~）。反正现在至少能够拿到 Subtask 4 的分。
# 高分到正解
在 Subtask 4 的分析中，几乎都已经接近正解了。思路几乎就是合并加特判 $0$（因为 $0$ 很特殊，它们需要每一个数一个组）。但是，如何合并呢？我们立刻就想到了——并查集！但是，计算一下时间复杂度吧：$\Omicron(n log a)$。超时了，还是超时了！最后一个 Subtask TLE 了！那么到底该怎么办呢？我们想到，根本没有必要去用并查集。只需要用最低二进制位编号作为下标再去用双层循环去合并即可。在输入时，将 $a_i$ 加入编号为 $lowbit(a_i)$ 的组（将数组里的结果按位或上 $a_i$，组的编号从 $0$ 开始，若 $a_i = 0$，则将答案加一，不加入任何组）。其中，$lowbit(x)$ 表示一个整数 $k$，使 $2^k \parallel x$（特殊说明：如果 $a$ 和 $b$ 为整数且 $a \ne 0$，我们说 $a$ 整除 $b$ 是指存在整数 $c$ 使得 $b = ac$。如果 $a$ 整除 $b$，我们还称 $a$ 是 $b$ 的一个因子，且称 $b$ 是 $a$ 的倍数。如果 $a$ 整除 $b$，则将其记为 $a \mid b$（这里的 $\mid$ 表示整除），如果 $a$ 不能整除 $b$，则记其为 $a \nmid b$。……$p^a \parallel n$ 表示恰整除，即：$p^a \mid n$ 但是 $p^{a+1} \nmid n$。（摘自（美）Kenneth H.Rosen著的《初等数论及其应用》（原书第6版）））。在加入完后，用 $i$ 来循环（注意到 $2^{59} = 576460752303423488 < 10^{18}$，而$2^{60} = 1152921504606846976 > 10^{18}$，所以编号范围为 $0$ ~ $59$）。定义 $f$ 数组来完成这一点（$f_{lowbit(a_i)}$ = $f_{lowbit(a_i)} \mid a_i(a_i > 0)$）。之后找到第一个 $j(i < j \le 59)$（如果存在的话），使：$f_i \mid f_j < f_i + f_j$，然后让 $f_j$ 按位或上 $f_i$，此时 $f_i$ 这一组就被全部加入到了 $f_j$，所以让 $f_i = 0$（方便统计答案），然后如果 $f_i > 0$，则这一组无法合并，将答案加一，最后输出即可。  
# 代码
大致思路就是这样，不过在实现的过程中会有一些不同。在计算 lowbit 函数时，可以使用循环，也可以使用 log2 函数和位运算（`int(log2(x & (-x)))`）。不过第一种的时间复杂度要是被卡到了极限的 $\Omicron(60n)$ 的话，可能会有些危险。我个人倾向于第二种实现方式。不多说了，上代码。  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
int n, x, ans, f[60];
signed main()//因为已经将“long long”define成“int”了，而 main() 主函数不能返回 long long，所以此处要写 signed。
{
    read(n);
    for(int i = 1; i <= n; i ++) {
        read(x);
        if(!x) {
            ++ans;
            continue;
        }
        f[signed(log2(x & (-x)))] |= x;//log2() 函数的返回值类型使其不能称为 f[] 数组的下标需要将其变成 int 类型。同上，这里需要写成“signed”。
    }
    for(int i = 0; i < 60; i ++) {
        for(int j = i + 1; j < 60; j ++) {
            if(f[i] & f[j]) {
                f[j] |= f[i];
                f[i] &= 0;
                break;
            }
        }
        if(f[i]) ++ans;
    }
    cout << ans;
    return 0;
}
``````
# 数据通过情况
[评测记录](https://www.luogu.com.cn/record/198392508)  
# 最后的话
__同样的，还是提醒大家，不要抄代码！__ 理解了再写。还有，如果文中有漏洞，请大家指正。代码仅供参考，不喜勿喷。写篇文章不容易，可否来个赞？

---

## 作者：chenxinyang2006 (赞：2)

介绍一个 $O(n + \log^3 a_i)$ 的解法。

答案最小值显然是所有 $a_i$ or 起来。
    
对于第 $i$ 位，所有包含这一位的数都必须分在这一组，否则答案就会超过最小值。
    
特判掉 $a_i = 0$，这些都可以单独分组，接下来将每个数一开始分在 $\log lowbit(a_i)$ 这一组，接下来就是看是否需要合并。
    
两组需要合并的必要条件是，这两组中可以分别选出一个数 $a_i,a_j$，满足 $a_i \operatorname{and} a_j = 0$。
    
那么实际上可以记录每一组里面所有数 or 起来，显然是等价的。
    
 因为初始划分后只会有 $\log a_i$ 组，所以暴力对于任何两组判是否需要合并是 $\log^2 a_i$ 的，然后用并查集即可。
 
 ```cpp
#include <cstdio>
#include <cmath>
using namespace std;
#define ll long long

#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}

int n;
ll s[65];

ll lowbit(ll x){
	return x & (-x);
}

int bin[65];

int find(int x){
	if(bin[x] == x) return x;
	return bin[x] = find(bin[x]);
}

void Merge(int x,int y){
	int fx = find(x),fy = find(y);
	if(fx != fy) bin[fx] = fy;
}

int main(){
	int ans = 0;
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		ll x;
		read(x);
		if(x == 0) ans++;
		else s[(int)log2(lowbit(x))] |= x;
	}
	for(int i = 0;i < 60;i++) bin[i] = i;
	for(int i = 0;i < 60;i++){
		for(int j = i + 1;j < 60;j++){
			if((s[i] & s[j]) != 0) Merge(i,j);
		}
	}
	for(int i = 0;i < 60;i++) if(s[i] && bin[i] == i) ans++;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Ink_Render (赞：2)

戳[这里](https://www.luogu.com.cn/blog/zym20070228/solution-p7384#)食用体验更佳。

看到各位大佬的题解都是并查集的，这里来一个更加简单但理论上可能被卡的方法。

## 一、题意分析

原题面：给你 $n$ 个数，将它们分成任意组（可以不连续），将每个组内的数按位或，并将各组的结果累加，在保证其结果最小的情况下求最多分成的组数。

标几个重点：1. 可以不连续 ，2. 保证其结果最小。

首先有一个明显的结论：把所有的数都或起来（即分成一组）的值一定最小，因为两个数或起来的值一定小于等于和。假设我们已经将所有数合成了两个数，我们需要考虑：要让这两个数加起来的值和或起来的值相等，也就是在二进制下每一位都最多有一个数为 1 。那么我们可以发现：如果两个数（二进制下）有某一位都为 1 ，那么这两个数必须在同一组。这就是我们分组的关键。

## 二、实现方法

在考场时我压根就没想到“拆位+并查集”，于是我用了一个更简单暴力的方法：模拟分组的过程。

假设现在已经分了若干组，对于每一个数，考虑它是否需要分入这一组，如果所有组都不需要，那么这个数可以成为新的一组。如果有一个数可以被分入多组，则要把这些组全部合并。还有一个特殊情况，如果这个数为 0 ，则可以直接把答案加 1 。最后答案就是 0 的个数加上剩下的组数。

考虑优化……暴力我优化个寂寞？

最后复杂度分析，这就体现了暴力的问题，由于要搜索每一组，所以我们算法的时间复杂度应该是 $O(np)$ ，其中 $p$ 是组数。然而这个复杂度分析也有一定问题，因为组数一直在变化 ~~，所以复杂度是 O(玄学)~~ 。但是我们可以大概的算出最坏复杂度：因为各个组的值在二进制下的每一位最多有一个组为 1 ，所以最多有 $\log(a_i)$ 组。如果出题人出一组所有 $a_i$ 均为 $2^k$ 形式的数据，那么这份代码肯定是过不了的。不过，我的代码实测最慢的点也只有 382 ms ，证明暴力还是很香的（可能出题人压根没想到会有我这么碰运气的）。

## 三、代码

由于我们需要删除（合并时用）和计算总组数的操作，很容易想到用 vector 来维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
#define ll long long
const int N=1e7+5;
int n,ans;
vector <ll> p;//维护当前的组 
int main()
{
	read(n);
	ll now;
	for(int i=1;i<=n;i++)
	{
		read(now);
		if(now==0)
		{
			ans++;
			continue;
		}//当前数为 0 ，直接把答案加 1 
		int st=-1;//当前匹配到的组，初值为 -1 
		for(int j=0;j<p.size();j++)
		{
			if((p[j]|now)<p[j]+now)//需要加入这个组 
			{
				if(st==-1)//如果还没被分到，加入这个组 
				{
					p[j]|=now;
					st=j;
				}
				else//否则将两个组合并 
				{
					p[st]|=p[j];
					p.erase(p.begin()+j);
					--j;
				}
			}
		}
		if(st==-1) p.push_back(now);//没被分到，直接开一个新组 
	}
	printf("%d",ans+p.size());
	return 0;
 }
```

最后送大家一句话：实在不会做就暴力骗分 ~~，没准就正解了呢~~。

---

## 作者：zzzyyyyhhhhh (赞：0)

提供一种 $O(n+\log v \alpha(\log v))$ 的做法。

80 分做法同[官解](https://www.luogu.com.cn/article/4v8q67dy)的 80 分。

考虑如何优化，发现可以在一定有两个集合合并时再拆位合并。于是记录每一位所在集合的并，需要时（当前处理的数有一位为 1 且这位不在集合并中）再合并。每次 $O(\log v\alpha(\log v))$ 合并一次，再 $O(\log v)$ 求集合的并即可做到 $O(n+\log v \alpha(\log v))$。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e7+100;
int n;
int a[N],f[N],vv[N],g[N];
bool v[N];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
signed main()
{
	read(n);
	int x,y,z=0,ans=0;
	for(int i=1;i<=n;i++)read(a[i]),g[i]=i;
	for(int i=0;i<63;i++)f[i]=i;
	for(int i=1;i<=n;i++)
	{
		z|=a[i];
		if(!a[i]){ans++;continue;}
		if((vv[__builtin_ctzll(a[i]&-a[i])]&a[i])>=a[i])continue;
		x=find(__builtin_ctzll(a[i]&-a[i])),y=0;
		for(int j=0;j<63;j++)
		{
			if(a[i]&(1ll<<j))f[find(j)]=x;
			if(find(j)==x)y|=1ll<<j;
		}
		x=find(x);
		for(int j=0;j<63;j++)if(find(j)==x)vv[j]=y;
	}
	for(int i=0;i<63;i++)
	{
		if(!(z&(1ll<<i)))continue;
		if(!v[find(i)])v[find(i)]=1,ans++;
	}
	cout<<ans;
}
```

---


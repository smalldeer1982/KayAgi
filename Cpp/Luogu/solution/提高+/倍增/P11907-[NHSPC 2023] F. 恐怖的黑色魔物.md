# [NHSPC 2023] F. 恐怖的黑色魔物

## 题目描述

G 公司最近用黑科技在某个神秘的地方建立了新的研发中心。这座研发中心的形状是长方体，内部共有 $F$ 层楼，每一层楼均有由 $M$ 列 $N$ 行组成的矩形房间。一个房间的位置用三个正整数 $(p, q, r)$ 表示，代表该房间位于研发中心 $p$ 楼的第 $q$ 列第 $r$ 行。

G 公司的员工均可以通过黑科技直接传送到隔壁、楼下或楼上的房间。更明确地说，位于房间 $(p, q, r)$ 的 G 公司员工，

1. 当 $p > 1$ 时，可以传送到房间 $(p-1, q, r)$。
1. 当 $p < F$ 时，可以传送到房间 $(p+1, q, r)$。
1. 当 $q > 1$ 时，可以传送到房间 $(p, q-1, r)$。
1. 当 $q < M$ 时，可以传送到房间 $(p, q+1, r)$。
1. 当 $r > 1$ 时，可以传送到房间 $(p, q, r-1)$。
1. 当 $r < N$ 时，可以传送到房间 $(p, q, r+1)$。

G 公司为了节省员工的用餐休息时间，在其中的 $R$ 个房间开设了餐厅，方便员工在研发中心内直接用餐。但餐厅的食物会滋生一种恐怖的黑色魔物，有一部分的 G 公司员工非常害怕这种恐怖的黑色魔物，因此不敢在这些餐厅用餐。

你的上司 K 先生特别害怕这种恐怖的黑色魔物。他总认为这些恐怖的黑色魔物，也能通过黑科技，在研发中心里自由穿梭。他定义了「黑色恐怖距离」：若一个房间至少须使用 $d$ 次黑科技传送，才能抵达餐厅，则该房间的黑色恐怖距离就是 $d$。对 K 先生来说，黑色恐怖距离越小就越恐怖，因此他每次在研发中心内移动时，都会计算该如何使用黑科技，才能让途中经过的房间，最小的黑色恐怖距离最大。作为 K 先生下属的你，打算编写一个程序，帮助 K 先生快速算出在最不恐怖的路径上，所经过的房间里黑色恐怖距离的最小值。

## 说明/提示

### 测试数据限制

* $1 \le F \le 2\times10^5$。
* $1 \le M \le 2\times10^5$。
* $1 \le N \le 2\times10^5$。
* $1 \le FMN \le 2\times10^5$。
* $1 \le R \le FMN$。
* $1 \le p_i \le F$。
* $1 \le q_i \le M$。
* $1 \le r_i \le N$。
* $1 \le Q \le 2\times10^5$。
* $1 \le a_i \le F$。
* $1 \le b_i \le M$。
* $1 \le c_i \le N$。
* $1 \le x_i \le F$。
* $1 \le y_i \le M$。
* $1 \le z_i \le N$。
* 对任意 $i, j \in \{1, 2, \ldots, R\}$，若 $i \ne j$，则 $(p_i, q_i, r_i) \ne (p_j, q_j, r_j)$。
* 输入的数皆为整数。

### 评分说明

本题共有五组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $6$ | $F = R = 1, MN \le 100, Q \le 100$ |
| 2 | $21$ | 对任意 $i \in \{1, 2, \ldots, Q\}$，均有 $(a_i, b_i, c_i) = (x_i, y_i, z_i)$ |
| 3 | $4$ | $FMN \le 3000$ |
| 4 | $25$ | $Q = 1$ |
| 5 | $44$ | 无额外限制 |

## 样例 #1

### 输入

```
3 3 3
3
1 1 1
2 2 2
3 3 3
4
1 3 3 3 1 1
1 2 2 3 2 2
1 2 3 1 2 3
1 1 1 3 3 3```

### 输出

```
2
1
2
0```

## 样例 #2

### 输入

```
1 1 3
1
1 1 2
1
1 1 1 1 1 3```

### 输出

```
0```

# 题解

## 作者：wangyizhi (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P11907)

~~简单题，水一发题解。~~

典题。

大概是紫吧。

以为获得了首杀，实则败给了 deepseek。

## 题目分析

首先我们需要求出每个点的 $d$。

这个很简单，直接 bfs 一遍就行了。

（具体见 [ABC383C](https://www.luogu.com.cn/problem/AT_abc383_c) ）

那么问题就转化为了：求一个点到另一个点的路径中经过的点权最小值最大的一条。

考虑对每个边赋上一个边权。显然可以为两端点点权的较小值。这样我们只要求边权最小值最大的路径了。

然后就是板子了。直接上 Kruskal 重构树就做完了。

感觉真的挺像 [归程](https://www.luogu.com.cn/problem/P4768) 的。。。

更多相似题目：[ABC394G](https://www.luogu.com.cn/problem/AT_abc394_g)。

## AC Code

```cpp
//by wangyizhi(571247)
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
using ll=long long;
using ld=long double;
//#define int ll
using pii=pair<int,int>;
//bool Mst;
const int N=2e5+5;
vector<int> g[N],t[N<<1];
inline void adde(int u,int v){g[u].push_back(v),g[v].push_back(u);}
struct __edge
{
	int u,v,w;
}e[N<<2];
int to[N],dis[N],val[N];
struct BCJ
{
	int fa[N<<1];
	void init(int n){for(int i=1;i<=n;i++)fa[i]=i;}
	int f(int x){return fa[x]==x?x:fa[x]=f(fa[x]);}
	void m(int x,int y){if(f(x)!=f(y))fa[f(x)]=f(y);}
}s;
int hson[N<<1],siz[N<<1],depth[N<<1],fa[N<<1],top[N<<1];
void dfs1(int u)
{
	hson[u]=-1,siz[u]=1;
	for(int v:t[u]) if(v!=fa[u])
	{
		depth[v]=depth[u]+1,fa[v]=u,dfs1(v),siz[u]+=siz[v];
		if(hson[u]==-1||siz[hson[u]]<siz[v]) hson[u]=v;
	}
}
void dfs2(int u,int tp)
{
	top[u]=tp;
	if(hson[u]==-1) return;
	dfs2(hson[u],tp);
	for(int v:t[u]) if(v!=fa[u]&&v!=hson[u]) dfs2(v,v);
}
int lca(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(depth[top[u]]<depth[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(depth[u]>depth[v]) swap(u,v);
	return u;
}
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int f,m,n,ecnt=0,tot=0,r,Q;
	cin>>f>>m>>n;
	vector<vector<vector<int>>> a;
	a.resize(f+1);
	for(int i=1;i<=f;i++)
	{
		a[i].resize(m+1);
		for(int j=1;j<=m;j++)
		{
			a[i][j].resize(n+1);
			for(int k=1;k<=n;k++) a[i][j][k]=++tot;
		}
	}
	for(int i=2;i<=f;i++)
		for(int j=1;j<=m;j++)
			for(int k=1;k<=n;k++) adde(a[i][j][k],a[i-1][j][k]);
	for(int i=1;i<=f;i++)
		for(int j=2;j<=m;j++)
			for(int k=1;k<=n;k++) adde(a[i][j][k],a[i][j-1][k]);
	for(int i=1;i<=f;i++)
		for(int j=1;j<=m;j++)
			for(int k=2;k<=n;k++) adde(a[i][j][k],a[i][j][k-1]);
	queue<int> q;
	cin>>r;
	for(int i=1,x,y,z;i<=r;i++) cin>>x>>y>>z,q.push(a[x][y][z]),to[a[x][y][z]]=1;
	while(q.size())
	{
		int u=q.front();q.pop();
		for(int v:g[u]) if(!to[v]) dis[v]=dis[u]+1,q.push(v),to[v]=1;
	}
	for(int i=1;i<=tot;i++) val[i]=dis[i];
	for(int i=2;i<=f;i++)
		for(int j=1;j<=m;j++)
			for(int k=1;k<=n;k++) e[++ecnt]={a[i][j][k],a[i-1][j][k],min(dis[a[i][j][k]],dis[a[i-1][j][k]])};
	for(int i=1;i<=f;i++)
		for(int j=2;j<=m;j++)
			for(int k=1;k<=n;k++) e[++ecnt]={a[i][j][k],a[i][j-1][k],min(dis[a[i][j][k]],dis[a[i][j-1][k]])};
	for(int i=1;i<=f;i++)
		for(int j=1;j<=m;j++)
			for(int k=2;k<=n;k++) e[++ecnt]={a[i][j][k],a[i][j][k-1],min(dis[a[i][j][k]],dis[a[i][j][k-1]])};
	sort(e+1,e+ecnt+1,[&](__edge x,__edge y){return x.w>y.w;}),s.init(tot*2);
	for(int i=1;i<=ecnt;i++)
	{
		int u=e[i].u,v=e[i].v,w=e[i].w;
		if(s.f(u)==s.f(v)) continue;
		val[++tot]=w,t[tot].push_back(s.f(u)),t[tot].push_back(s.f(v)),s.fa[s.f(u)]=tot,s.fa[s.f(v)]=tot;
	}
	dfs1(tot),dfs2(tot,tot);
	cin>>Q;
	while(Q--)
	{
		int x,y,z,p,q,r;
		cin>>x>>y>>z>>p>>q>>r;
		cout<<val[lca(a[x][y][z],a[p][q][r])]<<"\n";
	}
	return 0;
}
```

---

## 作者：Frodo (赞：2)

## 思路

首先我们可以用 BFS 计算出每个点的「黑色恐怖距离」。

接下来考虑询问：每次求两点之间权值最小值的最大值，这让我们想到 Kruskal 重构树的性质：`原图中两个点之间的所有简单路径上最小边权的最大值 = Kruskal 重构树上两点之间的 LCA 的权值`，只是此处边变成了点。

于是直接建图再建一个类似于 Kruskal 重构树的树即可。

## 时间复杂度

$\Theta (FMN+Q\log FMN)$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Fastio{
	#define read Fastio::readuint
	#define write Fastio::writeuint
	#define flush Fastio::clear
	#define SIZE (1<<23)
	#define NUMLEN 12
	#define getchar() (_S==_T&&(_T=(_S=_in)+fread(_in,1,SIZE,stdin),_S==_T)?EOF:*_S++)
	char _in[SIZE],*_S=_in,*_T=_in;
	char _out[SIZE],*_P=_out;
	const char *_end=_out+SIZE;
	inline unsigned int readuint(){
		unsigned int ret=0;char ch=getchar();
		while(ch<'0'||ch>'9'){ch=getchar();}
		while(ch>='0'&&ch<='9'){ret=(ret<<1)+(ret<<3)+(ch^48);ch=getchar();}
		return ret;
	}
	inline void clear(){fwrite(_out,1,_P-_out,stdout);_P=_out;}
	inline void putchar(char ch){*(_P++)=ch;if(_P==_end)clear();}
	inline void outuint(unsigned int x){
		if(x==0){putchar(48);return;}
		unsigned int i=0;
		char st[NUMLEN];
		while(x) st[i++]=48^(x%10),x/=10;
		while(i--) putchar(st[i]);
	}
	inline void writeuint(int x,char ch){outuint(x);putchar(ch);}
}
const int N=200100,M=18;
int n,m,l,tot,q,root,dis[N],stk[N],top=0,fa[N],dep[N],f[M][N],st[M][N];
tuple<int,int,int> place[N];
bool vis[N];
vector<int>e[N];
int ID(int i,int j,int k){return (i*m+j)*l+k;}
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int u,int v){if(u!=(v=find(v))) e[fa[v]=u].push_back(v);}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	for(int i=M-1;~i;i--) if(dep[f[i][u]]>=dep[v]) u=f[i][u];
	for(int i=M-1;~i;i--) if(f[i][u]!=f[i][v]) u=f[i][u],v=f[i][v];
	if(u!=v) u=f[0][u];
	return u;
}
int main(){
	#ifdef LOCAL
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	n=read(),m=read(),l=read(),q=read(),tot=n*m*l;
	for(int i=0;i<n;i++) for(int j=0;j<m;j++) for(int k=0;k<l;k++) place[ID(i,j,k)]={i,j,k};
	for(int i=0;i<tot;i++) dis[i]=-1;
	while(q--){
		int i=read()-1,j=read()-1,k=read()-1;
		dis[stk[top++]=ID(i,j,k)]=0;
	}
	for(int I=0;I<top;I++){
		int u=stk[I],v,i,j,k;tie(i,j,k)=place[u];
		if(i&&!~dis[v=ID(i-1,j,k)]) dis[stk[top++]=v]=dis[u]+1;
		if(j&&!~dis[v=ID(i,j-1,k)]) dis[stk[top++]=v]=dis[u]+1;
		if(k&&!~dis[v=ID(i,j,k-1)]) dis[stk[top++]=v]=dis[u]+1;
		if(i+1-n&&!~dis[v=ID(i+1,j,k)]) dis[stk[top++]=v]=dis[u]+1;
		if(j+1-m&&!~dis[v=ID(i,j+1,k)]) dis[stk[top++]=v]=dis[u]+1;
		if(k+1-l&&!~dis[v=ID(i,j,k+1)]) dis[stk[top++]=v]=dis[u]+1;
	}
	for(int i=0;i<tot;i++) fa[i]=i;
	for(int I=top-1;~I;I--){
		int u=stk[I],v,i,j,k;tie(i,j,k)=place[u];vis[u]=true;
		if(i&&vis[v=ID(i-1,j,k)]) merge(u,v);
		if(j&&vis[v=ID(i,j-1,k)]) merge(u,v);
		if(k&&vis[v=ID(i,j,k-1)]) merge(u,v);
		if(i+1-n&&vis[v=ID(i+1,j,k)]) merge(u,v);
		if(j+1-m&&vis[v=ID(i,j+1,k)]) merge(u,v);
		if(k+1-l&&vis[v=ID(i,j,k+1)]) merge(u,v);
	}
	f[0][stk[0]]=stk[0];
	for(int I=0;I<top;I++){
		int u=stk[I];
		for(int v:e[u]) dep[v]=dep[u]+1,f[0][v]=u;
	}
	for(int j=1;j<M;j++) for(int i=0;i<tot;i++) f[j][i]=f[j-1][f[j-1][i]];
	q=read();
	while(q--){
		int ui=read()-1,uj=read()-1,uk=read()-1;
		int vi=read()-1,vj=read()-1,vk=read()-1;
		write(dis[lca(ID(ui,uj,uk),ID(vi,vj,vk))],10);
	}
	flush();
	return 0;
}
```

---

## 作者：Cute__yhb (赞：1)

## 思路

先用多源 bfs 求出每个点的黑色恐怖距离。

然后，题意就相当于在图上求两个点所有路径中最小点权的最大值。

可以定义一条边的边权为连接的两点中点权较小的那个，这样点权就转化为了边权。

类似 P1967 的做法，建出这个图的 Kruskal 重构树，查询相当于求两点在重构树上 LCA 的权值。

难点在于代码实现。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define p_q priority_queue
#define pb push_back
#define mk make_pair
#define pii pair<int,int> 
#define ve vector
#define endl '\n'
#define y1 sfdgsdfgsdfgdrs
#define fi first
#define se second
#define INF 0x3f3f3f3f
#define lowbit(x) (x&(-x))
int f[500005],val[500005],vis[500005],fa[500005][22];
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
int n,m,k,cnt=0,r,tot=0;
ve<ve<ve<int> > >mp;
struct edge{
	int x,y,w;
}e[5000005];
bool cmp(edge x,edge y){
	return x.w>y.w;
}
int a[500005],dep[500005];
int dx[]={0,1,-1,0,0,0,0};
int dy[]={0,0,0,1,-1,0,0};
int dz[]={0,0,0,0,0,1,-1};
ve<int>g[200005],tr[500005];
void dfs(int x){
	for(int i=1;i<=21;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(auto y:tr[x]){
		fa[y][0]=x;
		dep[y]=dep[x]+1;
		dfs(y);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=21;i>=0;i--){
		if(dep[fa[x][i]]>=dep[y]){
			x=fa[x][i];
		}
	}
	if(x==y) return x;
	for(int i=21;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
int main(){
	cin>>n>>m>>k>>r;
	mp.resize(n+2);
	for(int i=1;i<=n;i++){
		mp[i].resize(2+m);
		for(int j=1;j<=m;j++){
			mp[i][j].resize(k+2);
			for(int _=1;_<=k;_++){
				cnt++;
				mp[i][j][_]=cnt;
			}
		}
	}
	queue<int>q;
	for(int i=1;i<=r;i++){
		int _,__,___;
		cin>>_>>__>>___;
		a[i]=mp[_][__][___];
		q.push(a[i]);
		vis[a[i]]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int _=1;_<=k;_++){
				int id=mp[i][j][_];
				for(int __=1;__<=6;__++){
					int xx=i+dx[__];
					int yy=j+dy[__];
					int zz=_+dz[__];
					if(xx<1||xx>n||yy<1||yy>m||zz<1||zz>k) continue;
					g[id].pb(mp[xx][yy][zz]);
				}
			}
		}
	}
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(auto y:g[x]){
			if(!vis[y]){
				vis[y]=1;
				val[y]=val[x]+1;
				q.push(y);
			}
		}
	}
	tot=cnt;
	cnt=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int _=1;_<=k;_++){
				int id=mp[i][j][_];
				for(int __=1;__<=6;__+=2){
					int xx=i+dx[__];
					int yy=j+dy[__];
					int zz=_+dz[__];
					if(xx<1||xx>n||yy<1||yy>m||zz<1||zz>k) continue;
					cnt++;
					int iid=mp[xx][yy][zz];
					e[cnt].w=min(val[id],val[iid]);
					e[cnt].x=id;
					e[cnt].y=iid;
				}
			}
		}
	}
	tot++;
	for(int i=1;i<=2*tot;i++) f[i]=i;
	sort(e+1,e+1+cnt,cmp);
	for(int i=1;i<=cnt;i++){
		int xx=find(e[i].x),yy=find(e[i].y);
		if(xx==yy) continue;
		tot++;
		val[tot]=e[i].w;
		tr[tot].pb(xx);
		tr[tot].pb(yy);
		f[xx]=tot;
		f[yy]=tot;		
	}
	dfs(tot);
	int _____;
	cin>>_____;
	while(_____--){
		int x1,x2,y1,y2,z1,z2;
		cin>>x1>>y1>>z1>>x2>>y2>>z2;
		cout<<val[lca(mp[x1][y1][z1],mp[x2][y2][z2])]<<endl;
	}
    return 0;
}
```

---

## 作者：SpringFullGarden (赞：0)

## 题意

给定一个三维网格，有若干个给定点，网格上每个点的权值为点到给定点的距离最小值。多次询问，每次查询两点之间路径上权值最小值。

## 思路

实际上题目给的三维网格实际上没有用，将其压成一维暴力建边即可，再使用 bfs 找出每个点的权值。

注意到两个点时，对答案的贡献是两点权值的较小值，所以用两点权值的较小值作为这条边的边权。

考虑到需要查询两点之间路径上的权值最小值，可以建立一颗 Kruskal 重构树，只需要求出两点之间的 lca 即可。

## 代码

```cpp
vector <int> e[200005], tr[400005];
vector <pair <int, int> > E;
int f, n, m, r, cnt, vis[200005], dis[400005], fa[400005], dep[400005], F[400005][20];

int fd(int x) { return fa[x] == x ? x : fa[x] = fd(fa[x]); }
int pos(int x, int y, int z) { return (x - 1) * n * m + (y - 1) * m + z; }
void dfs(int x) { for(int v : tr[x]) dep[v] = dep[x] + 1, dfs(v); }
int lca(int x, int y) {
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 19; i >= 0; i--) if(dep[F[x][i]] >= dep[y]) x = F[x][i];
    if(x == y) return x;
    for(int i = 19; i >= 0; i--) if(F[x][i] != F[y][i]) x = F[x][i], y = F[y][i];
    return F[x][0];
}
signed main() {
    f = rd(), n = rd(), m = rd(), r = rd(), cnt = f * n * m;
    queue <int> q;
    for(int i = 1, u, v, w; i <= r; i++) 
        u = rd(), v = rd(), w = rd(), q.push(pos(u, v, w)), vis[pos(u, v, w)] = 1;
    for(int i = 1; i <= f; i++) for(int j = 1; j <= n; j++) for(int k = 1; k <= m; k++) {
        int id = pos(i, j, k);
        if(i > 1) e[id].push_back(pos(i - 1, j, k)), 
            e[pos(i - 1, j, k)].push_back(id), E.push_back({id, pos(i - 1, j, k)});
        if(j > 1) e[id].push_back(pos(i, j - 1, k)), 
            e[pos(i, j - 1, k)].push_back(id), E.push_back({id, pos(i, j - 1, k)});
        if(k > 1) e[id].push_back(pos(i, j, k - 1)), 
            e[pos(i, j, k - 1)].push_back(id), E.push_back({id, pos(i, j, k - 1)});
    }
    while(q.size()) {
        int x = q.front(); q.pop();
        for(int v : e[x]) if(!vis[v]) vis[v] = 1, dis[v] = dis[x] + 1, q.push(v);
    }
    sort(E.begin(), E.end(), [](auto x, auto y) { 
        return min(dis[x.first], dis[x.second]) > min(dis[y.first], dis[y.second]); });
    for(int i = 1; i <= f * n * m * 2; i++) fa[i] = i;
    for(auto it : E) {
        int x = fd(it.first), y = fd(it.second);
        if(x == y) continue;
        fa[x] = fa[y] = F[x][0] = F[y][0] = ++cnt;
        tr[cnt].push_back(x), tr[cnt].push_back(y);
        dis[cnt] = min(dis[it.first], dis[it.second]);
    }
    for(int j = 1; j <= 19; j++) for(int i = 1; i <= cnt; i++) F[i][j] = F[F[i][j - 1]][j - 1];
    dep[cnt] = 1, dfs(cnt);
    for(int Q = rd(), u, v, w, x, y; Q--; ) {
        u = rd(), v = rd(), w = rd(), x = pos(u, v, w);
        u = rd(), v = rd(), w = rd(), y = pos(u, v, w);
        cout << dis[lca(x, y)] << '\n';
    }
    return 0;
}
```

---

## 作者：DengStar (赞：0)

[在博客园中查看](https://www.cnblogs.com/dengstar/p/18779895)

> 图论建模，多源 BFS，最小瓶颈路，Kruskal 重构树

赛时完全没想到往图论方向考虑，一直在想是不是有什么数据结构/kk

先考虑第二个 Subtask，即求出每个点到最近的餐厅的距离。把房间看作点，餐厅看作关键点，问题就变成了：给定一个无向无权图，有若干个关键点，求出每个点到最近的关键点的距离。由于边无权，所以直接使用多源 BFS 即可。

记节点 $u$ 的“黑色恐怖距离”为 $d_{u}$，则原问题相当于：给定一个无向图，每个点有点权，多次询问某两个点之间的路径，使得路径上的最小点权最大。如果把点权换成边权，这个问题就是 [最大瓶颈路](https://oi-wiki.org/graph/mst/#%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E8%B7%AF) 问题，可以求出任意一棵最大生成树以后倍增解决，或者建 Kruskal 重构树。那么怎样把点权转换成边权呢？对于两个相邻的点 $u$ 和 $v$，令它们之间的边权为 $\min(d_{u}, d_{v})$，正确性显然。（需要特判起点和终点相同的情况）转化之后就可以用上文提到的方法解决了。

如果用最大生成树 + 倍增解决，要先把所有边权从大到小排序再依次选择，但通过一个技巧，不需要把所有边的边权都显式地求出来。由于 bfs 按 $d_{u}$ 从小到大的顺序访问节点，所以按 bfs 序的倒序枚举就可以把 $d_{u}$ 从大到小排序。对于当前枚举的 $u$，枚举与它相邻的节点 $v$，如果 $v$ 已经被访问过，就说明 $d_{v} \ge d_{u}$，因此 $\min(d_{u}, d_{v}) = d_{u}$，于是就可以尝试在最大生成树中加入边 $(u, v)$。容易看出这样做等价于按 $\min(d_{u}, d_{v}) = d_{u}$ 降序排序后枚举，所以一定是正确的。

记 $V = FMN$，则时间复杂度为 $O(V (\alpha(V) + \log V))$。[AC 记录](https://www.luogu.com.cn/record/208646070)

代码见于 [博客园](https://www.cnblogs.com/dengstar/p/18779895)。

---


# [UOI 2023] An Array and Range Additions

## 题目描述

给定一个长度为 $n$ 的整数数组 $a$。

你可以通过**加法操作**来修改数组。要执行**加法操作**，你需要依次完成以下三个步骤：

- 选择任意整数 $x$。
- 选择数组中的任意子数组 $[l;r]$。
- 将 $x$ 加到所选子数组的每个元素上（即对 $l \le i \le r$ 执行赋值操作 $a_i \leftarrow (a_i + x)$）。

找到使数组 $a$ 中所有元素两两不同的最小**加法操作**次数。

## 说明/提示

在第一个样例中，数组 $a$ 的所有元素已经是两两不同的。

在第二个样例中，应用两次**加法操作**，参数分别为 $x=-3$、$l=1$、$r=2$ 和 $x=-1$、$l=1$、$r=3$ 后，数组 $a$ 变为 $[-2, -1, 1, 3, 2]$。

在第三个样例中，应用两次**加法操作**，参数分别为 $x=-3$、$l=4$、$r=8$ 和 $x=-10$、$l=7$、$r=9$ 后，数组 $a$ 变为 $[2, 3, 1, -2, 0, -1, -12, -10, -7]$。

### 评分标准

- （$9$ 分）：数组 $a$ 的所有元素均为 $1$。
- （$15$ 分）：对于 $1 \le i \le n$，$1 \le a_i \le 2$；对于 $1 \le i < n$，$a_i \le a_{i+1}$。
- （$14$ 分）：$n \le 8$。
- （$17$ 分）：$a_1 = a_n$。
- （$12$ 分）：$n \le 2000$。
- （$12$ 分）：对于 $1 \le i \le n$，$1 \le a_i \le 100$。
- （$21$ 分）：无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
5
2 3 2 3 2```

### 输出

```
2```

## 样例 #3

### 输入

```
9
2 3 1 1 3 2 1 3 3```

### 输出

```
2```

# 题解

## 作者：Chenhaoxuan (赞：3)

### [P12568 [UOI 2023] An Array and Range Additions](https://www.luogu.com.cn/problem/P12568)

题目大意：

给定一个长度为 $n$ 的整数数组 $a$。每次操作可以选择一个区间加上任意整数。求使数组 $a$ 中所有元素两两不同的最小操作次数。

---

首先我们先考虑本题的弱化版本：你需要保证 **选择的区间两两不交**。

这时问题变成了一个简单的贪心。我们从左至右扫描整个序列，每次遇到一个重复的数字，就把序列从这里断开，然后新开一段。最后，我们保留第一段不变，后面每一段加上一个互不相同的数字。容易证明最优性。

---

如果区间可以重叠呢？我们先钦定 **序列中的所有数字必须至少改变一次**，考虑如下 $n=3$ 的情形：

|$1$|$1$|$1$|
|:-:|:-:|:-:|

容易发现如下的操作方案：

|$x+1$|$x+y+1$|$y+1$|
|:-:|:-:|:-:|

其中 $x$ 远大于 $a_i$，$y$ 远大于 $x$。

考虑如下 $n=5$ 的情形：

|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|

下面是一种合理的操作方案：

|$x+1$|$x+y+1$|$x+y+z+1$|$y+z+1$|$z+1$|
|:-:|:-:|:-:|:-:|:-:|

其中 $x$ 远大于 $a_i$，$y$ 远大于 $x$，$z$ 远大于 $y$。

由此推广，我们可以得到如下一般结论：

- 对于 $n$ 次操作，我们最多让 $2n-1$ 个区间变得不同。

  - 具体实现上，让每次操作依次覆盖 $[1,n],[2,n+1],\cdots, [n,2n-1]$ 这些区间即可。

- 对于 $n$ 个区间，我们至少进行 $\left\lfloor\dfrac{n}{2}\right\rfloor+1$ 次操作才能让它们两两不同。

---

现在考虑更一般的情形。我们可能会面对答案由若干段的改变构成的情况。下面是一个例子。

|原序列|$1$|$1$|$3$|$2$|$2$|$1$|$2$|$3$|$3$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|答案序列|$1$|$x+1$|$x+3$|$x+2$|$2$|$y+1$|$y+2$|$y+3$|$3$|

这样的答案很难求解。但我们发现：我们可以把两个相邻的两个操作区间合并，如下所示：

|原序列|$1$|$1$|$3$|$2$|$2$|$1$|$2$|$3$|$3$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|新答案序列|$1$|$x+1$|$x+3$|$x+2$|$x+y+2$|$y+1$|$y+2$|$y+3$|$3$|

把中间的无关数字也“带上”操作，容易发现这样的构造也符合要求。于是存在一种合法的构造方案，**只有最前面和最后面的一些位置不改变**，中间的数字都要改变。

---

回到本题。我们首先预处理出 **每一个点右侧第一次出现重复数字的位置**，记为 $nxt_i$。容易以线性对数的复杂度求出。

然后，我们对于每一个合法的前缀 $[1,l]$，找出一个极长的合法后缀 $[r,n]$。这可以双指针动态维护，总情况数不超过 $n$。我们令这些数字不变。

剩下的就只有求出 $[l+1,r-1]$ 中的最少操作数。这转化为上面 **序列中的所有数字必须至少改变一次** 的情况。由于我们已经求出了 $nxt$ 数组，我们可以从 $l+1$ 开始，在 $nxt$ 上暴力往后跳直至超过 $r-1$，这样单次查询复杂度是 $\mathcal O(n)$ 的。

而上面的跳跃操作是可以倍增优化的，于是我们可以在 $\mathcal O(n\log n)$ 的时间复杂度内求出每对前后缀的答案。把所有情况的答案取最小值即可。

注意特判不需要操作的情形。

---

AC 代码：

```c++
int n, a[maxn], cnt;
int nxt[maxn][20], ans = 0x3f3f3f3f;
map<int, int> mp;
int query(int l, int r) {
	int res = 1;
	for (int j = 19; j >= 0; j--) {
		if (nxt[l][j] <= r) l = nxt[l][j], res += (1 << j);
	}
	return res / 2 + 1;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	nxt[n + 1][0] = n + 1;
	for (int i = n; i >= 1; i--) {
		nxt[i][0] = nxt[i + 1][0];
		if (mp[a[i]]) nxt[i][0] = min(nxt[i][0], mp[a[i]]);
		mp[a[i]] = i;
	}
	for (int i = 1; i <= 19; i++) {
		for (int j = 1; j <= n + 1; j++) 
			nxt[j][i] = nxt[nxt[j][i - 1]][i - 1];
	}
	mp.clear(); int l, r;
	for (r = n; r >= 1; r--) {
		if (!mp[a[r]]) mp[a[r]]++;
		else break;
	}
	if (!r) return 0 * puts("0");
	ans = min(ans, query(1, r)); r++;
	for (l = 1; l <= n; l++) {
		while (mp[a[l]] && r <= n) {
			mp[a[r]]--; r++;
		}
		if (mp[a[l]]) break;
		mp[a[l]] = 1;
		ans = min(ans, query(l + 1, r - 1));
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：min_inf (赞：2)

为什么是倍增？

首先我们显然可以加一个随机的巨大数字，这样只要让相同的数不能被相同的区间覆盖到即可。然后考虑 $l$ 和 $r+1$ 构成的可重集，如果我们将前一半和后一半依次配对，这样对于每个数只要相邻两次出现之间有至少一个端点且第一次出现前和最后一次出现后至少有一个端点就满足了要求，显然这样是最优的。

现在问题就变成了，求出一个最小的集合 $S$ 满足一些条件，答案是 $\lceil\frac{|S|}2\rceil$：

- $\exists x\in S,a\le x\le b$。
- $\exists x\in S,x\le c\lor d\le x$。

如果只有第一种条件，显然可以按 $b$ 从小到大贪心，然后加入第二种条件最多让答案 $+1$。我们二分一个最小的 $\min S$ 使得答案不会改变，然后对于 $c<\min S$ 的第二类限制加入第一类限制 $(d,n+1)$ 再跑一遍贪心即可，如果答案还是会增加那显然就无力回天了。

时间复杂度 $O(n\log n)$。

```cpp
cin>>n;rep(i,1,n)cin>>a[i];
map<int,vector<int>> occ;rep(i,1,n)occ[a[i]].push_back(i);
vector<pair<int,int>> rg;
for(auto [x,v]:occ)repn(i,v.size()-1)rg.emplace_back(v[i]+1,v[i+1]);
sort(allc(rg),[&](auto x,auto y){return x.sec<y.sec;});
if(rg.empty()){cout<<"0\n";return 0;}
auto solve=[&](int s){
    int ans=0;
    for(auto [l,r]:rg)if(l>s)s=r,++ans;
    return ans;
};
int t=solve(0);
int l=1,r=rg[0].sec;
while(l<r){
    int mid=l+r>>1;
    if(solve(mid)>=t)l=mid+1;else r=mid;
}
int p=1;
for(auto [x,v]:occ)if(v.size()>1&&v[0]<l)p=max(p,v.back());
rg.emplace_back(p+1,n+1);cout<<(solve(0)+1)/2<<'\n';
```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/19014863)

简单思维题，但我没场切，抱抱我真堂。

注意到 $x$ 可以选**任意数**，所以对一个区间加 $x$ 的操作可以等效于将这个区间里的数与区间外的数区分开来，因为 $x$ 可以直接拉到一个很大的数，下一次操作可以拉到更大的数，以此类推。

因为把这个区间与其他区间分隔开了，所以相当于把这个序列切成了三段。而对于后续的区间加也是同理，会**在两个端点所在的块内把序列分割**。这是本题最关键的性质。由此可以得到，如果进行了 $x$ 次分割，那么至少要进行 $\left \lceil \dfrac{x}{2} \right \rceil$ 次区间加操作，因为每次区间加会导致两次分割。

接下来考虑利用这个性质，直接对最后形成的序列进行分析，在把这个序列分割成多个段后，如果某个段内仍然存在相同的数字，显然是无法满足要求的。注意第一段和最后一段是特殊的，因为我们分割序列的时候区间加的都是中间段，所以第一段和最后一段是**不需要进行区间加**的，但是需要满足第一段和最后一段合起来每个数字均出现一次。

于是问题被转化为：对一个序列进行分割，使得每一段内均无重复数字出现，且第一段和最后一段需要特殊考虑。求最小分割次数。

首先可以观察到一个**单调性**：如果一段的左端点已确定，那么当右端点最右的时候一定是最优的。因此，在左端点确定的时候，我们**能够确定的段是唯一的**，因为这个段就是左端点和最大右端点所组成的段。为了求出最大右端点，可以根据单调性用一个**双指针**和 `unordered_map` 进行维护。

剩下的 DP 是显然的，对于中间段，可以直接找到**最大右端点**进行转移；而对于首尾段，DP 的过程中显然不可以多记录一维，而前后要保证无重复元素，可以把他们接成同一个段。因此考虑“**断环为链**”的 trick，把数组复制一倍，如果此时的右端点跳出了 $n$ 就直接停止，根据左端点判断是否计入答案即可。

这一部分可以用倍增或者直接递推实现。如果直接递推即可做到时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N = 400005, inf = 0x3f3f3f3f;
int n, a[N], to[N], dp[N], ans = inf;
unordered_map<int, int> tot;
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i + n] = a[i];
        to[i + n] = i + n - 1;
    }
    int p = 1;
    for(int i = 1; i <= n; i++)
    {
        while(tot[a[p]] == 0)
        {
            tot[a[p]]++;
            p++;
        }
        to[i] = p;
        tot[a[i]]--;
    }
    if(to[1] > n)
    {
        cout << 0;
        return 0;
    }
    for(int i = n; i >= 1; i--)
    {
        dp[i] = dp[to[i]] + 1;
        to[i] = to[to[i]];
    }
    for(int i = 1; i <= n; i++)
        if(to[i] >= i + n - 1)
            ans = min(ans, dp[i]);
    cout << (ans + 1) / 2;
    return 0;
}
```

---


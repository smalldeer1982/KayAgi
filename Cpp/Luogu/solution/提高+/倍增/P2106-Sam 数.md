# Sam 数

## 题目描述

小 Z 最近发现了一种非常有趣的数，他将这种数称之为 Sam 数。

Sam 数具有以下特征：相邻两位的数字之差不超过 $2$。

小 Z 还将 Sam 数按位数进行了分类，他将一个 $k$ 位 Sam 数称之为 $k$ 阶 Sam 数。

但不幸的是小 Z 发现他数不清第 $k$ 阶的 Sam 数一共有多少个，这个时候机智的他想到了向你求助。

答案对 $10^9+7$ 取模。

## 说明/提示

对于 $30\%$ 的数据，$1\le k\le10^6$。

对于 $60\%$ 的数据，$1\le k\le 10^{12}$。

对于 $100\%$ 的数据，$1\le k\le10^{18}$。

## 样例 #1

### 输入

```
4```

### 输出

```
867```

# 题解

## 作者：Delta_Rain (赞：27)

# Sam数题解
---

~~那位大佬讲的不够详细我来补充一下~~

> 题意简述： 求有多少长为$n$位且满足相邻位之差小于等于2的数。

这是一道数位DP模板题。
建议做这道题之前先做一下[【P2657】[SCOI2009]windy数](https://www.luogu.org/problemnew/show/P2657)

然后我们来分析这道题。
首先设 $f(i,j)$ 表示第 $i$ 位为 $j$ 时的方案总数，我们很容易得到状态转移方程：
$$f(i,j)=\sum _{x=j-2}^{j+2} {f(i-1,x)}$$

这个很容易理解，注意边界就行了。
这样我们得到了时间复杂度$O(n)$空间复杂度$O(n)$的~~优秀(30分)~~算法。

---

进一步优化：
我们发现每次转移只与$i-1$有关，用滚动数组优化一下。
这样空间复杂度降到了$O(1)$。
但是$n<10^{18}$，$O(n)的复杂度肯定会超时~~（gg）~~

---

再进一步优化：
显然我们需要复杂度$O(log_2n)$的做法。
## 矩阵快速幂！
如何构造矩阵？
根据题意和递推式，我们构造出如下矩阵。

```cpp

A = 0 1 1 1 1 1 1 1 1 1

D = 1 1 1 0 0 0 0 0 0 0
    1 1 1 1 0 0 0 0 0 0
    1 1 1 1 1 0 0 0 0 0
    0 1 1 1 1 1 0 0 0 0
    0 0 1 1 1 1 1 0 0 0
    0 0 0 1 1 1 1 1 0 0
    0 0 0 0 1 1 1 1 1 0
    0 0 0 0 0 1 1 1 1 1
    0 0 0 0 0 0 1 1 1 1
    0 0 0 0 0 0 0 1 1 1
    
```

矩阵快速幂怎么用？
普通快速幂时这样的：

```cpp

long long qpow(long long base,long long v) {
	long long res = 1;
    while (v) {
    	if (v & 1) res *= base;
        base *= base;
        v >>= 1;
    }
    return res;
}
```
 矩阵快速幂需要重载运算符,设置单位矩阵。
 
 如果不会，请转向模板题。
 
 注意**特判** $n=1$ 时答案为10。
 
 还有，在定义矩阵后别忘了**将矩阵清空**，否则会出乱七八糟的数。~~我被这玩意坑了两回QAQ~~
 
~~我知道你们想要这个↓↓↓~~
 
 ```cpp
 
#include <bits/stdc++.h>
const long long mod = 1e9 + 7;
struct matrix {
	long long v[10][10]; // 定义矩阵结构体
};
matrix operator * (const matrix a,const matrix b) { // 重载运算符
	matrix c;
	memset(c.v,0,sizeof(c.v)); // 别忘了清空
	for(int k = 0;k < 10;k++)
		for(int i = 0;i < 10;i++)
			for(int j = 0;j < 10;j++)
				c.v[i][j] = (c.v[i][j] + a.v[i][k] * b.v[k][j] % mod ) % mod; // 矩阵乘法运算法则
	return c;
}
matrix qpow(matrix a,long long v) { // 矩阵快速幂，指数要开long long
	matrix r;
	memset(r.v,0,sizeof(r.v)); // 清空!
	for(int i = 0;i < 10;i++)
		r.v[i][i] = 1; // 设置单位矩阵
	while(v) {         // 跟普通快速幂差不多
		if(v & 1) r = r * a;
		a = a * a;
		v >>= 1;
	}
	return r;
}
long long n,ans;
matrix a,d;     // a是初始矩阵，d是递推矩阵
int main() {
	std::cin >> n;
	if(n == 1) {   //特判
		printf("10\n");
		return 0;
	}
	memset(a.v,0,sizeof(a.v));
	memset(d.v,0,sizeof(d.v));
	for(int i = 1;i < 10;i++)    // 设置初始矩阵
		a.v[0][i] = 1;
	for(int i = 0;i < 10;i++)   // 设置递推矩阵
		for(int j = i - 2;j <= i + 2;j++) {
			if(j < 0) continue;
			if(j > 9) break;
			d.v[j][i] = 1;  // 自动打表技术~
		}
	a = a * qpow(d,n - 1); // 计算
	for(int i = 0;i < 10;i++)
		ans += a.v[0][i],ans %= mod; // 累加答案
	std::cout << ans << "\n"; // 输出
}

```

---

## 作者：ueettttuj (赞：22)

### 感觉其他大佬没多解释**矩阵的构造**，本蒟蒻来详细解释一下

首先此题是一道数位$DP$题，可以快速的推出方程


------------


令$f(i,j)$ 表示第$i$位数为$j$时的方案数

因为相邻两数之差不超过$2$，故在第$i+1$位时可以选取的数为$j-2$~$j+2$

故可以推出方程$f(i+1,j)=\sum\limits_{m=j-2}^{j+2}{f(i,m)}$

方程展开为$f(i+1,j)=f(i,j-2)+f(i,j-1)+f(i,j)+f(i,j+1)+f(i,j+2)$


------------


于是我们便可以$O(n)$推出答案

但是由于数据范围为$1 ≤ k ≤ 10^{18}$ $,$ 所以要用矩阵快速幂优化

根据递推式 $,$ 我们可以推出矩阵


```cpp
1 1 1 0 0 0 0 0 0 0            f[i,0]         f[i,0]+f[i,1]+f[i,2]                         f[i+1,0]  
1 1 1 1 0 0 0 0 0 0            f[i,1]         f[i,0]+f[i,1]+f[i,2]+f[i,3]                  f[i+1,1]  
1 1 1 1 1 0 0 0 0 0            f[i,2]         f[i,0]+f[i,1]+f[i,2]+f[i,3]+f[i,4]           f[i+1,2]  
0 1 1 1 1 1 0 0 0 0            f[i,3]         f[i,1]+f[i,2]+f[i,3]+f[i,4]+f[i,5]           f[i+1,3]  
0 0 1 1 1 1 1 0 0 0      x     f[i,4]    =    f[i,2]+f[i,3]+f[i,4]+f[i,5]+f[i,6]     =     f[i+1,4]  
0 0 0 1 1 1 1 1 0 0            f[i,5]         f[i,3]+f[i,4]+f[i,5]+f[i,6]+f[i,7]           f[i+1,5]  
0 0 0 0 1 1 1 1 1 0            f[i,6]         f[i,4]+f[i,5]+f[i,6]+f[i,7]+f[i,8]           f[i+1,6]  
0 0 0 0 0 1 1 1 1 1            f[i,7]         f[i,5]+f[i,6]+f[i,7]+f[i,8]+f[i,9]           f[i+1,7]  
0 0 0 0 0 0 1 1 1 1            f[i,8]         f[i,6]+f[i,7]+f[i,8]+f[i,9]                  f[i+1,8]  
0 0 0 0 0 0 0 1 1 1            f[i,9]         f[i,7]+f[i,8]+f[i,9]                         f[i+1,9]  
```


------------

令
```cpp
1 1 1 0 0 0 0 0 0 0 
1 1 1 1 0 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0 
0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 0 0 0
0 0 0 1 1 1 1 1 0 0 
0 0 0 0 1 1 1 1 1 0    
0 0 0 0 0 1 1 1 1 1 
0 0 0 0 0 0 1 1 1 1    
0 0 0 0 0 0 0 1 1 1    
```
为$A$矩阵;


------------


令
```cpp
f[1,0]
f[1,1]
f[1,2]
f[1,3]
f[1,4]
f[1,5]
f[1,6]
f[1,7]
f[1,8]
f[1,9]
```
为$B$矩阵;


------------



所以我们只用将$A$矩阵乘 $k-1$ 遍 , 再将 $A*B$ 就可以得出在第$k$位取 $0$ ~ $9$ 的方案数，再将其累加即可得到答案


------------

注意点：
1. $B$ 中 $f(1,0)=0\ ,$ 因为要防止出现前导$0$

2. 当$k=1$ 时 ， 需特判输出$10$


------------


下面放代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
long long k;
struct node{
    long long m[11][11];
};
node res,ans,realans;
node mul(node aa,node bb){
    node tmp;
    memset(tmp.m,0,sizeof(tmp.m));
    for(long long i=0;i<=9;i++){
        for(long long j=0;j<=9;j++){
            for(long long k=0;k<=9;k++){
                tmp.m[i][j]=(tmp.m[i][j]+aa.m[i][k]*bb.m[k][j])%mod;
            }
        }
    }
    return tmp;
}
int main(){
    scanf("%lld",&k);
    if(k==1){
        printf("10\n");
        return 0;
    }
    for(long long i=0;i<=9;i++){
        ans.m[i][i]=1;
    }
    for(long long i=0;i<=9;i++){
        for(long long j=max(0ll,i-2);j<=min(i+2,9ll);j++){
            res.m[i][j]=1;
        }
    }
    k--;
    while(k){
        if(k%2) ans=mul(ans,res);
        res=mul(res,res);
        k/=2;
    }
    long long anss=0;
    for(long long i=1;i<=9;i++)
        realans.m[i][0]=1;
    for(long long i=0;i<=9;i++){
    	for(long long j=0;j<=0;j++){
    		for(long long k=0;k<=9;k++){
    			anss=(anss+ans.m[i][k]*realans.m[k][j])%mod;
            }
        }
    }
    printf("%lld\n",anss);
    return 0;
}
```


**~~神犇轻喷~~**


---

## 作者：jxcakak (赞：10)

这题可以用倍增解决。

f[i][j][k]为有(1<<i)位，最高位为j，最低位为k的情况数，则可以得出f[i][j][k]=sum(f[i-1][j][p]\*f[i-1][q][k])(abs(p-q)<=2)。我们算出f数组后，需要找出数的位数k能由哪些(1<<i)之和得到，得到之后进行递推，对于第cnt个(1<<i)，ans[cnt][j][k]=sum(ans[cnt-1][j][p]\*f[i][q][k])(abs(p-q)<=2)。最后求出sum(ans[cnt][j][k])(1<=j<=9,0<=k<=9)。注意当位数为一是需要特判，输出10。

```cpp
#include<cstdio>
typedef long long ll;
const int P=1000000007;
ll f[63][10][10],ans[63][10][10],cnt;
bool b=0;
int main(){
    ll n; scanf("%lld",&n);
    if(n==1){
        printf("10"); return 0;//特判
    }
    for(int i=0;i<10;++i) f[0][i][i]=1;//初始化f数组
    for(int i=1;i<=62;++i) for(int j=0;j<10;++j) for(int k=0;k<10;++k)
        for(int l=0;l<10;++l) for(int p=-2;p<=2;++p) if(l+p>=0&&l+p<10)
            (f[i][j][k]+=f[i-1][j][l]*f[i-1][l+p][k])%=P;//递推求f数组
    for(int i=0;i<=62;++i) if(n&(1LL<<i)) if(!b){
        for(int j=0;j<10;++j) for(int k=0;k<10;++k)//若ans数组没有初始化的话初始化一遍
            ans[0][j][k]=f[i][j][k]; b=1;
    }else{
        ++cnt; 
        for(int j=0;j<10;++j) for(int k=0;k<10;++k)//递推求ans数组
        for(int l=0;l<10;++l) for(int p=-2;p<=2;++p)
            if(l+p>=0&&l+p<10) (ans[cnt][j][k]+=ans[cnt-1][j][l]*f[i][l+p][k])%=P;
    }
    ll sum=0;
    for(int i=1;i<10;++i) for(int j=0;j<10;++j)//统计答案
        (sum+=ans[cnt][i][j])%=P;
    printf("%lld",sum); return 0;
}
```

---

## 作者：Register (赞：6)

### 题目大意
求有多少个相邻两位差不超过$2$的$n$位数（$Sam$数），$1\le n\le 10^{18}$，答案对$10^9+7$取模
### 解题思路
- 易想到数位$DP$：

设$F_{i,j}$为末位为$i$的$j$位的$Sam$数有多少个

转移方程：$F_{i,j}=\sum F_{i-1,k}(|k-j|\le 2)$

边界条件：$F_{i,1}=1$

显然此算法会超时

- 倍增

考虑这些数码是可以叠加的，因此可以使用倍增

转移方程需要将第$j$位改为有$2^j$位，同时加上首位为$k$这一维状态

转移有$2^j$位时枚举两个有$2^{j-1}$位的，并判断第一个的末位和第二个的首位是否满足要求能够叠加

最后转移答案同样也要开个数组，记录首位末位和第几次转移答案，转移方式同上

### 注意事项

$2^j$枚举$j$的时候注意```long long```的范围，达到$63$会被卡爆，只能枚举到$62$

最后统计答案的时候，首位不能为$0$（这也是答案数组也要记录首位的原因）

### 代码

```cpp
#include <cstdio>
#define int long long
const int mod=1000000007;
int n,tot,sum,f[10][10][63],ans[10][10][63];
inline int read(){
	char ch=getchar();int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}
inline int Abs(int x){
	return x<0?-x:x;
}
signed main(){
	n=read();
	if(n==1) {puts("10");return 0;}
	for(register int i=0;i<10;i++) f[i][i][0]=1;
	for(register int i=1;i<=62;i++)
		for(register int j=0;j<10;j++)
			for(register int k=0;k<10;k++)
				for(register int t=0;t<10;t++)
					if(Abs(t-k)<=2) for(register int l=0;l<10;l++) f[j][l][i]=(f[j][l][i]+f[j][k][i-1]*f[t][l][i-1])%mod;
	for(register int i=0;i<=62;i++)
		if(n>>i&1)
		{
			if(!sum) for(register int j=0;j<10;j++)
				for(register int k=0;k<10;k++) ans[j][k][sum+1]=f[j][k][i];
			else for(register int j=0;j<10;j++)
				for(register int k=0;k<10;k++)
					for(register int t=0;t<10;t++)
						if(Abs(t-k)<=2) for(register int l=0;l<10;l++) ans[j][l][sum+1]=(ans[j][l][sum+1]+ans[j][k][sum]*f[t][l][i])%mod;
			sum++;
		}
	for(register int i=1;i<10;i++)
		for(register int j=0;j<10;j++) tot=(tot+ans[i][j][sum])%mod;
	printf("%lld\n",tot);
	return 0;
}
```

---

## 作者：穼柗° (赞：2)

这题显然是矩阵快速幂。

搞一个 $1\times 10$ 的矩阵，表示以每个数字结尾的 $p$ 阶 Sam 数有多少个。

因为相邻位数字相差不超过 $2$，所以以 $x$ 结尾的一定是从以 $\max\{x-2,0\}$ 到 $\min\{x+2,9\}$ 结尾转移过来的。易得转移矩阵
$$$
\begin{bmatrix}1&1&1&0&0&0&0&0&0&0\\1&1&1&1&0&0&0&0&0&0\\1&1&1&1&1&0&0&0&0&0\\0&1&1&1&1&1&0&0&0&0\\0&0&1&1&1&1&1&0&0&0\\0&0&0&1&1&1&1&1&0&0\\0&0&0&0&1&1&1&1&1&0\\0&0&0&0&0&1&1&1&1&1\\0&0&0&0&0&0&1&1&1&1\\0&0&0&0&0&0&0&1&1&1\end{bmatrix}
$$$

注意到：$0$ 是 $1$ 阶 Sam 数，但是更高阶的 Sam 数首位一定不为 $0$。所以当 $k=1$ 时要特判输出 $10$，其他情况初始矩阵为 $1$ 个 $0$ 和 $9$ 个 $1$。

具体实现看代码。
```cpp
#include <iostream>
#include <vector>
using namespace std;
using ll= long long;
using lst=vector<ll>;
using jz=vector<lst>;
const int mod=1000000007;
jz operator *(jz b,jz a) {
	const int n=a.size(),m=b[0].size(),t=a[0].size();
	jz ret(n,lst(m));
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++) {
			for(int k=0;k<t;k++)
				ret[i][j]+=a[i][k]*b[k][j]%mod;
			ret[i][j]%=mod;
		}
	return ret;
}
jz operator ^(jz x,ll y) {
	jz ret=x;
	for(y--;y;y>>=1,x=x*x)
		if(y&1) ret=ret*x;
	return ret;
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	ll k;
	cin>>k;
	if(k==1) return cout<<10,0;
	jz ans(10,lst(1,1)),mat(10,lst(10)); ans[0][0]=0;
	for(int i=0;i<10;i++)
		for(int j=max(i-2,0);j<=min(i+2,9);j++)
			mat[i][j]=1;
	ans=ans*(mat^(k-1));
	int output=0;
	for(int i=0;i<10;i++)
		output=(output+ans[i][0])%mod;
	cout<<output;
	return 0;
}
```
特别注意，要开 `long long`！[我的 `WA`](https://www.luogu.com.cn/record/list?pid=P2106&user=1045961) 全是 `long long` 造成的！

---

## 作者：peterwuyihong (赞：2)

题意：相邻两个数的差不超过 $2$，我们称这个数是牛逼的，然后我们要询问位数是 $k\le10^{18}$ 的牛逼数有几个。

非常的萌萌，你直接掏出来一个 $\text{DP}$，我们使用 $f_{i,j}$ 表示 $i$ 位 首位为 $j$ 的牛逼数有几个。

$$f_{i,j}=\sum_{k\in[j-2,j+2]\cap[0,10]}f_{i-1,k}$$

然后直接上一个矩阵快速幂就行了，构造矩阵显然为

$ \begin{pmatrix}
1&1&1&0&0&0&0&0&0&0 \\
1&1&1&1&0&0&0&0&0&0 \\
1&1&1&1&1&0&0&0&0&0 \\
0&1&1&1&1&1&0&0&0&0 \\
0&0&1&1&1&1&1&0&0&0 \\
0&0&0&1&1&1&1&1&0&0 \\
0&0&0&0&1&1&1&1&1&0 \\
0&0&0&0&0&1&1&1&1&1 \\
0&0&0&0&0&0&1&1&1&1 \\
0&0&0&0&0&0&0&1&1&1 \\
\end{pmatrix} $

边界就是 $f_{1,0}=0,f_{1,i}=1$ 了。

现在是 $20:15$，我看我什么时候写完。

现在是 $20:20$，我写完了。

```cpp
long long k;
signed main(){
	mat A(10,10);
	for(int i=1;i<=10;i++)
	for(int j=1;j<=10;j++)
	if(abs(i-j)<=2)A[i][j]=1;
	mat B(10,10);
	for(int i=2;i<=10;i++)B[1][i]=1;
	cin>>k;
	B=B*Ksm(A,k-1);
	int ans=0;
	for(int i=1;i<=10;i++)add(ans,B[1][i]);
	cout<<ans+(k==1);
}
```
$k=1$ 的时候好像要特判一下？？？

[推一波矩阵快速幂！](https://www.luogu.com.cn/blog/Peterprpr/mu-ban)

---

## 作者：John2014 (赞：1)

# P2106 Sam 数 题解

## 思路

本蒟蒻第一种想到的方法就是暴力 dfs，就是枚举所有情况，在 $k = 1$ 的情况下要特判，可以得到 $10$ 分，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,ans; 
void dfs(int num,int x){
	if(num==k){
		ans++;
		return;
	}
	for(int i=max(x-2,0);i<=min(x+2,9);i++){
		dfs(num+1,i);
	}
}
int main(){
	cin>>k;
	if(k==1){
		cout<<10;
		return 0;
	}
	for(int i=1;i<=9;i++){
		dfs(1,i);
	}
	cout<<ans;
	return 0;
}
```

然后想到动态规划，`used[i][j]` 表示 $i$ 阶最后一位是 $j$ 的 Sam 的个数，我们不难推出转移方程式：

$$used_{i,j} = \sum_{k = min(j-2,0)}^{max(j+2,9)} used_{i-1,k}$$

直接开 `used[1000010][10]` 会 MLE，只能得 $30$ 分。所以要用滚动数组，只用开 `used[2][10]`，但还是会 TLE，也只能得 $30$ 分，用了好像和没用一样，代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,used[2][10],ans;
signed main(){
	cin>>n;
	if(n==1){
		cout<<10;
		return 0;
	} 
	for(int i=1;i<=9;i++){
		used[1][i]=1;
	}
	for(int i=2;i<=n;i++){
		for(int j=0;j<=9;j++){
			used[i%2][j]=0;
			for(int k=max(j-2,0ll);k<=min(j+2,9ll);k++){
				used[i%2][j]=(used[i%2][j]+used[(i-1)%2][k])%1000000007;
			}
		}
	}
	for(int i=0;i<=9;i++){
		ans+=used[n%2][i];
		ans%=1000000007;
	}
	cout<<ans;
	return 0;
}
```

最后正解是矩阵快速幂，根据相邻两位的数字之差不超过 $2$ 我们可以构造出矩阵：

$$\begin{bmatrix} 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \end{bmatrix}$$

然后因为开头不能是 $0$ 所以初始矩阵是

$$\begin{bmatrix} 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \end{bmatrix}$$

最后把答案加起来就好了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
struct matrix{
	int a[20][20];
	matrix(){
		memset(a,0,sizeof(a));
	}
}; 
matrix operator *(matrix a,matrix b){
	matrix ans;
	for(int i=1;i<=10;i++){
		for(int j=1;j<=10;j++){
			for(int k=1;k<=10;k++){
				ans.a[i][j]=(ans.a[i][j]+a.a[i][k]*b.a[k][j])%1000000007; 
			}
		}
	}
	return ans;
}
matrix qpow(matrix n,int m){
	matrix ans;
	for(int i=1;i<=10;i++){
		ans.a[i][i]=1;
	}
	while(m){
		if(m&1){
			ans=ans*n;
		}
		m>>=1;
		n=n*n; 
	}
	return ans;
}
signed main(){
	cin>>n;
	if(n==1){
		cout<<10;
		return 0;
	}
	matrix a,b;
	for(int i=1;i<=10;i++){
		for(int j=max(i-2,1ll);j<=min(i+2,10ll);j++){
			a.a[i][j]=1;
		}
	}
	for(int i=2;i<=10;i++){
		b.a[1][i]=1;
	}
	matrix x=b*qpow(a,n-1);
	for(int i=1;i<=10;i++){
		ans+=x.a[1][i];
		ans%=1000000007;
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：piano_pei (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P2106)

### 思路

先考虑暴力。

计数问题，动态规划是强有力的工具，不妨考虑 dp。

状态定义：$dp_{i,j}$ 表示第 $i$ 位填 $j$ 的方案数。

初始化：$\forall 1\leq i\leq 9,dp_{1,i}=1$

由题意可直接得出状态转移方程：

$$dp_{i,j}=\sum_{k=\max\{0,i-2\}}^{\min\{9,i+2\}}dp_{i-1,k}$$

直接计算第 $n$ 项的复杂度是 $O(n)$，期望得分 30pts。

---

不难发现这是一个递推式，第二维很小，且只与前一项有关，我们可以使用矩阵快速幂优化 $dp$。

把转移方程展开：

$$
\begin{cases}
dp_{i,0}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2}\\
dp_{i,1}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}\\
dp_{i,2}=dp_{i-1,0}+dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,4}\\
dp_{i,3}=dp_{i-1,1}+dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,5}\\
dp_{i,4}=dp_{i-1,2}+dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,5}+dp_{i-1,6}\\
dp_{i,5}=dp_{i-1,3}+dp_{i-1,4}+dp_{i-1,5}+dp_{i-1,6}+dp_{i-1,7}\\
dp_{i,6}=dp_{i-1,4}+dp_{i-1,5}+dp_{i-1,6}+dp_{i-1,7}+dp_{i-1,8}\\
dp_{i,7}=dp_{i-1,5}+dp_{i-1,6}+dp_{i-1,7}+dp_{i-1,8}+dp_{i-1,9}\\
dp_{i,8}=dp_{i-1,6}+dp_{i-1,7}+dp_{i-1,8}+dp_{i-1,9}\\
dp_{i,9}=dp_{i-1,7}+dp_{i-1,8}+dp_{i-1,9}
\end{cases}
$$

然后打表得到转移矩阵 
$$
T=
\begin{bmatrix}
1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1
\end{bmatrix}
$$

别忘了把初始矩阵也打上表

$$
A=
\begin{bmatrix}
0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1
\end{bmatrix}
$$

矩阵快速幂算 $A·T^{n-1}$ 即可，复杂度 $O(M^3\log n)$，其中 $M$ 是矩阵边长，本题中 $M=10$，可以通过。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Mod = 1e9+7, N = 10;
struct mat
{
	ll a[N][N];
	friend mat operator * (const mat &n1, const mat &n2)
	{
		mat n3 = (mat){{{0}}};
		for(int i = 0;i < N;++i)
		{
			for(int j = 0;j < N;++j)
			{
				for(int k = 0;k < N;++k)
				{
					n3.a[i][j] += n1.a[i][k] * n2.a[k][j] % Mod;
					n3.a[i][j] %= Mod;	
				}	
			}	
		}	
		return n3;
	}	
};
inline mat fastpow(mat a, mat T, ll n)
{
	while(n)
	{
		if(n & 1)
			a = a * T;
		T = T * T;
		n >>= 1;
	}
	return a;
}
int main()
{
	mat T = (mat){{{0}}}, A = (mat){{{0}}};
	A.a[0][0] = A.a[0][1] = A.a[0][2] = A.a[0][3] = A.a[0][4] = 1;
	A.a[0][5] = A.a[0][6] = A.a[0][7] = A.a[0][8] = A.a[1][9] = 1;
	T.a[0][0] = T.a[0][1] = T.a[0][2] = 1;
	T.a[1][0] = T.a[1][1] = T.a[1][2] = T.a[1][3] = 1;
	T.a[2][0] = T.a[2][1] = T.a[2][2] = T.a[2][3] = T.a[2][4] = 1;
	T.a[3][1] = T.a[3][2] = T.a[3][3] = T.a[3][4] = T.a[3][5] = 1;
	T.a[4][2] = T.a[4][3] = T.a[4][4] = T.a[4][5] = T.a[4][6] = 1;
	T.a[5][3] = T.a[5][4] = T.a[5][5] = T.a[5][6] = T.a[5][7] = 1;
	T.a[6][4] = T.a[6][5] = T.a[6][6] = T.a[6][7] = T.a[6][8] = 1;
	T.a[7][5] = T.a[7][6] = T.a[7][7] = T.a[7][8] = T.a[7][9] = 1;
	T.a[8][6] = T.a[8][7] = T.a[8][8] = T.a[8][9] = 1;
	T.a[9][7] = T.a[9][8] = T.a[9][9] = 1; 
	ll n;
	cin >> n;
	if(n == 1)
	{
		cout << 10;
		return 0;
	}
	mat t = fastpow(A, T, n - 1);
	ll ans = 0;
	for(int i = 0;i <= 9;++i)
		ans = (ans + t.a[0][i]) % Mod;
	cout << ans;
	return 0;
}

```

---

## 作者：Wuyanru (赞：1)

一道很适合练手的矩阵快速幂题目。

首先我们可以先考虑动态规划来做，我们令 $ dp_{i,j} $ 代表以数字 $ j $ 开头的 $ i $ 阶Sam数的个数，那么就有状态转移公式：

$ dp_{i,j}=\sum_{k=\max\left(0,j-2\right)}^{\min\left(10,j+2\right)}dp_{i-1,k} $

由于递推公式只用到了上一个阶段的状态，所以可以使用滚动数组将空间复杂度降低为 $ \Theta\left(1\right) $。

显然，此时时间复杂度为 $ \Theta\left(k\right) $,还附赠了一个 $ 44 $ 的大常数，所以我们就得到了~~愉快的~~ $ 30 $ 分代码。

显然，我们需要一个时间复杂度为 $ \Theta\left(\log_{2} k\right) $ 的算法。

于是我们就可以请出本篇题解的主角，矩阵快速幂。

那么我们就来看这篇题目中我们所用到的两个矩阵。

第一个矩阵也是最重要的矩阵，用于快速幂计算递推过程，我们可以参照上面动态规划的转移方程，来设计出这个矩阵。

看下面：

$ \begin{vmatrix}
1  &1  &1  &0  &0  &0  &0  &0  &0  &0 \\
1  &1  &1  &1  &0  &0  &0  &0  &0  &0 \\
1  &1  &1  &1  &1  &0  &0  &0  &0  &0 \\
0  &1  &1  &1  &1  &1  &0  &0  &0  &0 \\
0  &0  &1  &1  &1  &1  &1  &0  &0  &0 \\
0  &0  &0  &1  &1  &1  &1  &1  &0  &0 \\
0  &0  &0  &0  &1  &1  &1  &1  &1  &0 \\
0  &0  &0  &0  &0  &1  &1  &1  &1  &1 \\
0  &0  &0  &0  &0  &0  &1  &1  &1  &1 \\
0  &0  &0  &0  &0  &0  &0  &1  &1  &1
\end{vmatrix} $

第二个矩阵就是初始矩阵，显然 $ 0 $ 到 $ 9 $ 这 $ 10 $ 个数字都是Sam数，所以初始矩阵长这个样子：

$ \begin{vmatrix}
1  &1  &1  &1  &1  &1  &1  &1  &1  &1
\end{vmatrix} $

一个小细节：由于初始矩阵的数量就是一阶Sam数的数量，所以矩阵快速幂的次数为 $ k-1 $ 次得到的才是 $ k $ 阶Sam数，并不需要进行第 $ k $ 次快速幂。

所以我们就把这道题解决了，如果有不会打矩阵快速幂的各位同学可以去看[我的博客](https://www.luogu.com.cn/blog/wuyanru/guan-yu-ju-zhen)，里面有关于矩阵的代码。

AC代码：

```
#include<cstring>
#include<cstdio>
#define mod (int)(1e9+7)
using namespace std;
struct mat {//手打了一天的矩阵
	int m,n;
	long long a[11][11];
	mat operator + (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]+b.a[i][j];
		return ans;
	}
	void operator += (mat b) {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				a[i][j]+=b.a[i][j];
	}
	mat operator - (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]-b.a[i][j];
		return ans;
	}
	void operator -= (mat b) {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				a[i][j]-=b.a[i][j];
	}
	mat operator * (mat b) {
		mat ans;
		memset(ans.a,0,sizeof(ans.a));
		ans.m=m;
		ans.n=b.n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=b.n; j++)
				for(int p=1; p<=n; p++)
					ans.a[i][j]+=(a[i][p]*b.a[p][j]),ans.a[i][j]%=mod;
		return ans;
	}
	void operator *= (mat b) {
		(*this)=(*this)*b;
	}
	mat operator ^ (long long t) {
		mat ans,num;
		ans.m=ans.n=m;
		num=(*this);
		memset(ans.a,0,sizeof(ans.a));
		for(int i=1; i<=m; i++)
			ans.a[i][i]=1;
		while(t) {
			if(t&1)
				ans=ans*num;
			num=num*num;
			t>>=1;
		}
		return ans;
	}
	void operator ^= (long long t) {
		(*this)=(*this)^t;
	}
	mat operator % (long long t) {
		mat ans;
		ans.m=m,ans.n=n;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				ans.a[i][j]=a[i][j]%t;
		return ans;
	}
	void operator = (mat b) {
		m=b.m,n=b.n;
		for(int i=1; i<=b.m; i++)
			for(int j=1; j<=b.n; j++)
				a[i][j]=b.a[i][j];
	}
	bool operator == (mat b) {
		if(m!=b.m||n!=b.n)
			return false;
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				if(a[i][j]!=b.a[i][j])
					return false;
		return true;
	}
	void inn() {
		scanf("%d",&n);
	}
	void inm() {
		scanf("%d",&m);
	}
	void innn() {
		inm();
		n=m;
	}
	void inmn() {
		inm();
		inn();
	}
	void ina() {
		for(int i=1; i<=m; i++)
			for(int j=1; j<=n; j++)
				scanf("%lld",&a[i][j]);
	}
	void in() {
		inmn();
		ina();
	}
	void outm() {
		printf("%d\n",m);
	}
	void outn() {
		printf("%d\n",n);
	}
	void outmn() {
		printf("%d %d\n",m,n);
	}
	void outa() {
		for(int i=1; i<=m; i++) {
			for(int j=1; j<=n; j++)
				printf("%lld ",a[i][j]);
			printf("\n");
		}
	}
	void out() {
		outmn();
		outa();
	}
};
mat num,ans;
int main() {
	long long n;
	scanf("%lld",&n);
	if(n==1ll)//特判k=1的情况
	{
	    printf("10");
	    return 0;
    }
	memset(ans.a,0,sizeof(ans.a));//记得清空。
	memset(num.a,0,sizeof(num.a));
	ans.m=1,ans.n=10;
	for(int i=1; i<=10; i++)
		ans.a[1][i]=1;//初始矩阵初始化
	num.m=num.n=10;
	for(int i=1; i<=10; i++)
		for(int j=i-2; j<=i+2; j++) {
			if(j<1)
				continue;
			if(j>10)
				break;
			num.a[i][j]=1;//快速幂矩阵初始化
		}
	num=num^(n-1);//快速幂
	ans=ans*num;//与初始矩阵相乘
	long long ansn=0;
	for(int i=2; i<=10; i++)//由于数字不计算前导0，所以不要加上开头为0的数字
		(ansn+=ans.a[1][i])%=mod;
	printf("%lld",ansn);
	return 0;
}
```

几个小细节：

1.  读入 $ k $ 的时候记得使用 long long 类型；

2.  矩阵快速幂次数为 $ k-1 $,不要弄错。

3.  计算数量的时候不计算前导0，记得不要加上答案矩阵中的第一项。

4.  记得特判 $ k=1 $ 的情况，因为 $ 0 $ 也是一个Sam数。

5.  记得取模，到处都要取模，也不要把模数写错。

感谢观看！

---

## 作者：Rockdu (赞：1)

这道题很容易可以想到数位dp：dp[i][j]表示dp到第i个， 以j为末尾的情况有多少种。但是1e18的范围心态很爆炸！

以前看到10^18的数据范围想都不想直接数学方法。但是自从上次hdu5434企图用轮廓线找规律被集训队大佬嘲讽了一波之后，蒟蒻就永远记住了矩阵快速幂这种操作（如果不会矩阵快速幂可以先百度矩阵快速幂求斐波那契数列第n项）。大概意思是如果dp的每一次转移都相同，那么我们可以用矩阵快速幂无压力dp（例如hdu5434）。这道题也是类似，我们可以发现每一次dp[i - 1][j] 到 dp[i][j]的状态转移都是相同的。这样我们只要通过转移构造转移矩阵，然后对转移矩阵进行快速幂就可以了。

下面是0ms代码：




```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
using namespace std;
LL n, ans;
const int p = 1000000007;
struct Matrix {
    LL DT[130][130];
    int n, m;
    Matrix(int nn, int nm) {
        memset(DT, 0, sizeof(DT));
        n = nn, m = nm;
    }
    void Std(int x) {
        n = m = x;
        for(register int i = 0; i < x; ++i)
            DT[i][i] = 1;
    }
    Matrix operator *(const Matrix &a) {
        Matrix ans(n, a.m);
        for(register int i = 0; i < n; ++i)
            for(register int j = 0; j < a.m; ++j)
                for(register int k = 0; k < m; ++k)
                    (ans.DT[i][j] += (DT[i][k] * a.DT[k][j]) % p) %= p;
        return ans;
    }
}trans(10, 10), st(1, 10);
Matrix fpow(Matrix a, LL b) {
    Matrix ans(a.n, a.n);
    ans.Std(a.n);
    while(b) {
        if(b & 1) ans = ans * a;
        a = a * a, b >>= 1;
    }
    return ans;
}
int main() {
    scanf("%lld", &n);
    if(n == 1) {
        printf("10");
        return 0;
    }
    for(register int i = 1; i < 10; ++i)
        st.DT[0][i] = 1;
    for(register int i = 0; i < 10; ++i)
        for(register int j = 0; j < 10; ++j)
            if(abs(i - j) <= 2) ++trans.DT[i][j];
    trans = st * fpow(trans, n - 1);
    for(register int i = 0; i < 10; ++i) 
        (ans += trans.DT[0][i] % p) %= p;
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：Dawn_Chase (赞：1)

#### P党的福利
看到题目

## 我们的第一感觉是暴力

所以身为蒟蒻的我打了个DFS

思路很好想，这里就不赘述了

代码如下（特判就不写了）：

```pascal
var n,i,j,l,r,x:longint;
    s:int64;
function max(x,y:longint):longint;
begin
  if x>y then
   exit(x);
  exit(y);
end;
function min(x,y:longint):longint;
begin
  if x<y then
   exit(x);
  exit(y);
end;
procedure ss(x,k:int64);
var i:longint;
begin
  if k=n then
   begin
    inc(s);
    exit;
   end;
  for i:=max(0,x mod 10-2) to min(9,x mod 10+2) do
   begin
    ss(x*10+i,k+1);
   end;
end;
begin
  read(n);
  s:=0;
  for i:=1 to 9 do
   ss(i,1);
  writeln(s);
end.
```
计算时间复杂度

太大了拜拜

实测过n=11左右（电脑跑的比较快）
## 接下来我们可以顺利想出DP
方程是f[i][j]={f[i-1][k]|k=max(0,j-2)~min(9,j+2)}
### 注意：我们计算答案的时候统计1~9的f[]值
正确性证明：

因为我们知道每个sam数的相邻两位的数字之差不超过 2

又因为我们前面求出的也都是sam数

所以可以直接统计下一位合法的sam数

由于i这维可以滚掉，所以我们数组只要开0~9就可以了

### 注意：更新i时要清空数组
代码如下（特判也不写了）：
```pascal
const mo=1000000007;
var n,i,j,l,r,x:longint;
    s:int64;
    f,ff:array[0..9] of int64;
function max(x,y:longint):longint;
begin
  if x>y then
   exit(x);
  exit(y);
end;
function min(x,y:longint):longint;
begin
  if x<y then
   exit(x);
  exit(y);
end;
begin
  read(n);
  for i:=0 to 9 do
   f[i]:=1;
  for i:=2 to n do
   begin
    fillchar(ff,sizeof(ff),0);
    for j:=0 to 9 do
     begin
      l:=max(0,j-2);r:=min(j+2,9);
      for x:=l to r do
       ff[j]:=(ff[j]+f[x]) mod mo;
     end;
    f:=ff;
   end;
  s:=0;
  for i:=1 to 9 do
   s:=(s+f[i]) mod mo;
  writeln(s);
end.
```
## 接下来我们要步入正解了
由于这题数据范围为10^18

O(n)的DP也过不了

只能过30左右
### 所以我们要使用矩阵优化
矩阵快速幂不会的同学先看下[模板](https://www.luogu.org/problemnew/show/P3390)

我们可以知道初始矩阵长这个样子（其实就是转移方程里的i，j啦）（i是竖的，j是横的）
![](https://cdn.luogu.com.cn/upload/pic/27508.png)
接下来我们需要使用**矩阵快速幂来算出这个矩阵的k次方**

然后问题就解决啦

我们只要用算出的这个矩阵再乘这个小矩阵

![](https://cdn.luogu.com.cn/upload/pic/27511.png)

然后累计答案就好了（其实不用也可以，因为这个乘了之后相当于把整个矩阵的值全加起来，但是大多时候这个小矩阵不是全1，所以还是用比较好）
### 注意：别忘了我们计算答案的时候统计1~9的f[]值
最后的代码如下（特判加上）：
```pascal
type arr=array[0..101,0..101] of int64;
const mo=1000000007;
var n,i,j:longint;
    k,s:int64;
    x,a,ans:arr;
function cheng(a,b:arr):arr;
var i,j,k:longint;
    c:arr;
begin
  fillchar(c,sizeof(c),0);
  for i:=0 to 9 do
   for j:=0 to 9 do
    for k:=0 to 9 do
     c[i,j]:=(c[i,j]+a[i,k]*b[k,j]) mod mo;
  exit(c);
end;
begin
  read(k);
  if k=1 then
   begin
    writeln(10);
    halt;
   end;
  for i:=0 to 9 do
   for j:=0 to 9 do
    if abs(i-j)<=2 then
     a[i,j]:=1
    else
     a[i,j]:=0;
  for i:=0 to 9 do
   ans[i,i]:=1;
  dec(k);
  while k>0 do
   begin
    if k mod 2=1 then
     ans:=cheng(ans,a);
    a:=cheng(a,a);
    k:=k div 2;
   end;
  for i:=0 to 9 do
   x[i,0]:=1;
  x:=cheng(ans,x);
  for i:=1 to 9 do
   s:=(s+x[i,0]) mod mo;
  writeln(s);
end.
```
PS:代码巨丑，大佬见谅。

---


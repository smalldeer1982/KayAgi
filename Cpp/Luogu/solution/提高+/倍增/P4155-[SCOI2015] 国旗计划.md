# [SCOI2015] 国旗计划

## 题目描述

A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战士作为这项计划的候选人。


A 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。


现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。


## 说明/提示

$N\leqslant 2×10^5,M<10^9,1\leqslant C_i,D_i\leqslant M$。


## 样例 #1

### 输入

```
4 8
2 5
4 7
6 1
7 3```

### 输出

```
3 3 4 3```

# 题解

## 作者：xuanfly (赞：107)

被老师布置作业的我（蒟蒻）无助地翻开题解，只见大佬们又是`template`又是`namespace`的，看得我一脸懵，被迫学习了一篇`CSDN`的题解，现说一说些微的体会来加深~~自己的~~印象

本文灵感来自于[CSDN @jerome_wei](https://blog.csdn.net/qq_35923186/article/details/83066690)

# ·
首先环上的问题我们一般改成链来做，其主要方法是输入完数据后再复制一遍加到原数组后面

![](https://cdn.luogu.com.cn/upload/pic/75739.png)

###### （背景颜色#66CCFF）

另外我们使用struct定义每个士兵的编号以及奔袭区间

```cpp
struct soldier {
	int id, l, r;
} s[400005];
```

```cpp
cin >> n >> m;
for(int i = 1; i <= n; i++) {
	cin >> s[i].l >> s[i].r;
	if(s[i].r < s[i].l)
		s[i].r += m;
	s[i].id = i;
}
sort(s + 1, s + 1 + n, cmp);
for(int i = 1; i <= n; i++) {//此处即复制过程
	s[i + n] = s[i];
	s[i + n].l = s[i].l + m;
	s[i + n].r = s[i].r + m;
}
```

关于上文中的**sort**

因为每个士兵的奔袭区间不会被完全包含，所以我们按照每位士兵的区间左端点由小到大排序，就可以得到单调递增的区间

# ·

接下来我们想要去寻找每个士兵能奔袭的最远的边防站使得最少的士兵需要奔袭

这句话可能比较难理解，我们使用样例做出解释

![](https://cdn.luogu.com.cn/upload/pic/75742.png)

图比较糙……假如我们的战士从4到7，另一名战士从7到3，那么那名从6到1的战士就不必参加，因此我们想到可以枚举每个区间内的战士，但是这样的复杂度是不能接受的，我们需要更快的时间，因此——

### 倍增！


# ·
我们预处理每名战士

从一名战士开始，一直到某一名战士的左端点大于这名战士的右端点，那么这名战士区间内奔袭过的最远的战士找到了

我们设$f(i, j)$表示第 $i$ 个战士奔袭 $2^j$ 步到达的边防站（表达不是很清楚，请读者自行感受）

方程为

## $f(i,j)=f[f(i,j-1),j-1]$

因为 $2^{20}=2^{10}\times2^{10}=1000\times1000=1000000$ 这大小应该够用了，所以我们从19开始遍历

```cpp
void pre()
{
	for(int i = 1, p = i; i <= 2 * n; i++) {
		while(p <= 2 * n && s[p].l <= s[i].r)
			p++;
		int pos = p - 1;
		go[i][0] = pos;
	}
	for(int i = 1; i < 20; i++) {//这两个for循环顺序一定不能换！！！！
		for(int j = 1; j <= 2 * n; j++) {
			go[j][i] = go[go[j][i - 1]][i - 1];
		}
	}
}
```

# ·
预处理完了后，我们就开始搜索（~~找不到合适的名字~~）了

lmt->limit 限制区间长度，ans 从 $2^0$ 开始，p 记录 k

i 从 19 开始向下遍历，如果符合条件，即使 ans+=$2^i$

然后更新k

最后记录答案（别忘了加上他自己）

```cpp
void search(int k)
{
	int lmt = s[k].l + m, ans = 1, p = k;
	for(int i = 19; i >= 0; i--) {
		if(go[k][i] != 0 && s[go[k][i]].r < lmt) {
			ans += (1 << i);
			k = go[k][i];
		}
	}
	res[s[p].id] = ans + 1;
}
```

# ·
完整代码如下，说实话后半部分我自己理解得也不是很透彻，可能有诸多错误，还请大佬指出

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
using namespace std;
int n, m, res[200005];
struct soldier {
	int id, l, r;
} s[400005];
int cmp(soldier a, soldier b)
{
	return a.l < b.l; 
}

int go[400005][20];

void pre()
{
	for(int i = 1, p = i; i <= 2 * n; i++) {
		while(p <= 2 * n && s[p].l <= s[i].r)
			p++;
		int pos = p - 1;
		go[i][0] = pos;
	}
	for(int i = 1; i < 20; i++) {
		for(int j = 1; j <= 2 * n; j++) {
			go[j][i] = go[go[j][i - 1]][i - 1];
		}
	}
}
void search(int k)
{
	int lmt = s[k].l + m, ans = 1, p = k;
	for(int i = 19; i >= 0; i--) {
		if(go[k][i] != 0 && s[go[k][i]].r < lmt) {
			ans += (1 << i);
			k = go[k][i];
		}
	}
	res[s[p].id] = ans + 1;
}
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> s[i].l >> s[i].r;
		if(s[i].r < s[i].l)
			s[i].r += m;
		s[i].id = i;
	}
	sort(s + 1, s + 1 + n, cmp);
	for(int i = 1; i <= n; i++) {
		s[i + n] = s[i];
		s[i + n].l = s[i].l + m;
		s[i + n].r = s[i].r + m;
	}
	pre();
	for(int i = 1; i <= n; i++)
		search(i);
	for(int i = 1; i <= n; i++)
		cout << res[i] << " ";
	return 0;
}

```

---

## 作者：FlashHu (赞：41)

$O(n)$算法来啦！

复杂度优化的思路是建立在倍增思路的基础上的，看看楼上几位巨佬的描述吧。

首先数组倍长是一样的。倍增法对于快速找到$j$满足$l_j+m\le r_i$进行了优化。然后菊开队长说可以建个树优化，可是他没讲清楚就把这个神仙东西扔给了我这个蒟蒻。。。一个晚上终于把这个模性建出来了。

在倍长的序列上，我们对于每一个$i$找到最小的$j$满足$r_j\ge l_i$并连一条$i$到$j$的边，于是就成了一个森林。贪心地想，我们要求的东西就变成了：对于每个点，找到与它最近的祖先$j$满足$l_j+m\le r_i$，$j$到$i$间的总点数就是答案。下面称$j$为$i$的决策点。

还是要树上倍增么？不不不，我们来注意一个性质：设不强制选某个战士的最优答案是$ans$，那么如果强制选某一个，答案要么是$ans$要么是$ans+1$。显然如果一个战士能够被一个最优方案包含的话就是$ans$，如果不能，任选一个最优方案再选他自己就可以了。

于是，假设$x$的决策点为$y$，那么$x$的一个儿子$x_1$的决策点，要么还是$y$，要么是$y$往$x$方向上的儿子。直接从上往下dfs并维护每个点的决策点就好啦！实现中，找到“$y$往$x$方向上的儿子”可以用类似Dinic当前弧的方法维护。

时间复杂度$O(n)$，常数较大，欢迎超越。为了理论上的严格线性，蒟蒻研究了下松爷基排，还写了个template，好不麻烦。template的食用方法可以去[蒟蒻的blog](https://www.cnblogs.com/flashhu/p/9751909.html)上看。

注意开unsigned int，没开的话蒟蒻不知道能不能过。
```cpp
#include<bits/stdc++.h>
#define UI unsigned int
#define RG register
#define R RG UI
#define G if(++ip==ie)fread(ip=buf,1,N,stdin)
using namespace std;
const UI N=4e5+9;
struct Data{UI l,r,id;}a[N],b[N];
UI m,he[N],ne[N],at[N],d[N];
char buf[N],*ie=buf+N,*ip=ie-1;
inline UI in(){
    G;while(*ip<'-')G;
    R x=*ip&15;G;
    while(*ip>'-'){x*=10;x+=*ip&15;G;}
    return x;
}
template<typename T>//基数排序
inline void Radixsort(RG T*fst,RG T*lst,RG T*buf,RG int*op){
    static int b[0x100];
    RG UI Len=lst-fst,Sz=sizeof(T),i,j;
    RG unsigned char*bgn,*end,*it;
    for(i=0;i<Sz;++i){
        if(op[i]==-1)continue;
        bgn=(unsigned char*)fst+i;end=(unsigned char*)lst+i;
        memset(b,0,sizeof(b));
        for(it=bgn;it!=end;it+=Sz)++b[*it];
        for(j=1;j<=0xff;++j)b[j]+=b[j-1];
        for(it=end;it!=bgn;)buf[--b[*(it-=Sz)]]=*--lst;
        lst=buf+Len;swap(fst,buf);
    }
}
void dfs(R x,R y){
    if(a[he[y]].l+m<=a[x].r)
        y=he[y],--d[x];//决策点偏移
    for(R&i=he[x];i;i=ne[i])
        d[i]=d[x]+1,dfs(i,y);
}
int main(){
    R n=in(),i,p;m=in();
    for(i=1;i<=n;++i){
        a[i].l=in();a[i].r=in();a[i].id=i;
        if(a[i].l>a[i].r)a[i].r+=m;//环状数据处理成链意义下的
    }
    Radixsort(a+1,a+n+1,b+1,new int[12]{0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1});
    memcpy(a+n+1,a+1,12*n);
    for(i=n+1;i<=2*n;++i)//倍长处理
        at[a[i-n].id]=i,a[i].l+=m,a[i].r+=m;
    for(p=1,i=2;i<=2*n;++i){//建树，贪心思想
        while(a[p].r<a[i].l)++p;
        ne[i]=he[p];he[p]=i;
    }
    for(i=1;i<=n;++i)
        if(!d[i])d[i]=1,dfs(i,i);
    for(i=1;i<=n;++i)
        printf("%d ",d[at[i]]);
    puts("");
    return 0;
}
```

---

## 作者：cyffff (赞：37)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4155)
## 题意
一个 $m$ 个点的环，有 $n$ 条线段，可覆盖在环上 $[c_i,d_i]$ 的部分，对 $1\le i\le n$ 问强制选择线段 $i$ 时，最少选择多少条线段可以覆盖整个环。

$n\le 2\times 10^5,m<10^9$
## 思路
这道题是[校内模拟赛](https://www.luogu.com.cn/blog/cyffff/post-202182-mu-ni-sai)的 $\text A$ 题，在考场上写出来了十分开心，就来写篇题解。

对于环，可以直接断环为链，变为线段覆盖问题。考虑线段不包含，则按照左端点排序后右端点单调，于是对于覆盖整个环，选择线段 $i$ 的下一段的线段 $j$ 是固定的，$j=\max\{x|c_x\le d_i\}$。

考虑计算出每个 $i$ 的下一条线段，然后倍增求出每条线段的下 $2^k$ 条线段。

对于一次询问，倍增至 $d_j<c_i+m$ 即可，注意要将答案 $+2$，即这一条线段与最后的线段。

这道题就做完了！时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=2e5+10;
int n,m,answ[N];
int st[20][N<<1];
struct segment{
	int l,r,id;
	inline friend bool operator<(const segment &a,const segment &b){
		return a.l<b.l;
	}
}a[N<<1];
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		int l=read(),r=read();
		if(l>r) r+=m;
		a[i].l=l,a[i].r=r,a[i].id=i;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		a[i+n].l=a[i].l+m,a[i+n].r=a[i].r+m;
	for(int i=1,j=1;i<=2*n;i++){
		while(j<=2*n&&a[j].l<=a[i].r)
			j++;
		st[0][i]=j-1;
	}
	for(int i=1;i<=19;i++)
		for(int j=1;j<=2*n;j++)
			st[i][j]=st[i-1][st[i-1][j]];
	for(int i=1;i<=n;i++){
		int up=a[i].l+m,ans=0,p=i;
		for(int j=19;j>=0;j--)
			if(st[j][p]&&a[st[j][p]].r<up)
				ans+=1<<j,p=st[j][p];
		answ[a[i].id]=ans+2;
	}
	for(int i=1;i<=n;i++)
		write(answ[i]),putc(' ');
	flush();
}
```
再见 qwq~

---

## 作者：uniqueharry (赞：18)

[P4155 [SCOI2015]国旗计划](https://www.luogu.com.cn/problem/P4155)


题目大意是一个大小为 $M$ 的环，有 $N$ 个区间，问在必选区间 $i$ 的情况下（$N \leq 2 × 10^5$），至少要选多少个区间能满足完全覆盖。输出一行共 $N$ 个整数。

首先，题目的基础模型类似于[线段覆盖](https://www.luogu.com.cn/problem/P1803)，然而题目的背景是环，不能直接操作，所以要“断环成链”，具体做法是将所有区间复制一份，左右端点统一加上 $M$ ，如果右端点小于左端点，即在环上走了超过半圈的区间，则先给右端点加上 $M$ 再复制。再在这 $2 * N$ 个区间中做贪心。根据线段覆盖的贪心策略，需要先以右端点为关键字排序，复制后无需再排序，因为复制出来的仍然保持有序。

那么如果只用做一次我们就会了，只要选出来的区间总长度达到 $M$ 即可，因为无论是怎样的一个区间，在原本的环上都是以某个点为起点覆盖了整个环。

但是题目的要求要做 $N$ 次，这样做时间复杂度 $O(N^2)$ ，显然不行。做每次 $O(1)$ 显然不现实，所以猜测每次操作要降到 $O(logN)$ 。

回顾算法过程，本质是一个一个选区间使总长度达到 $M$ ,就像是在凑一个数。而我们在凑一个数的时候经常用不大于它最大的二的次幂，减去之后再重复这个过程，这样这个数的值会减小得非常快，一共只需要减 $\:{log(num)}$ 次就可以凑出。把这个思想应用到这个题目上来，即从 $logN$ 枚举到零，且令此时的次数为 $x$ 。如果从当前的区间选 $2 ^ x$ 个区间的右端点减当前区间左端点 
$< M$，就将考虑的区间跳到后 $2 ^ x$ 个。根据枚举特性，区间长度一直在向 $M$ 逼近，退出循环后区间总长必然为 $M - 1$ ，因此将当前答案加一即可。

现在面对的问题是如何知道某个区间后选的第 $2 ^ x$ 个区间究竟是哪个，这需要预处理。如果定义 $f[\,i\,][\,j\,]$ 表示根据贪心策略，第 $i$ 个区间后的第 $2 ^ j$ 个区间，那么可以得到一个递推关系：
$f[\,i\,][\,j\,] = f[f[\,i\,][\,j - 1\,]][\,j - 1\,]$

现在，我们只要有全部的 $f[\,i\,][\,0\,]$ ，就可以求出全部的 $f[\,i\,][\,j\,]$。$f[\,i\,][\,0\,]$ 即每个区间后选的第一个区间。肯定不能两重循环，那时间复杂度就再次变为 $O(N ^ 2)$ ，这个时候就可以再次利用题目中提到的一个性质：
### “每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。”

那么，每个区间（令为 $i$）后选的第一个区间(令为 $j$ )，即贪心策略中的最优解，必然是满足 $l_j \leq r_i$ 的最后一个区间。则对于单调递增的 $i$ ，$j$ 也单调递增，可以使用双指针扫描的策略。时间复杂度降为 $O(N)$。

最后，可以在存区间时在结构体里放一个初始编号，把每次算出的答案放进 $ans[\,id_i\,]$ 即可。

可以总结一下倍增使用的场合：

1.同一件事完成多次。

2.当“一次做一件事”可以优化为“一次做多件事”。

双指针扫描的应用：

两个指针代表的内容均只增不减。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n,m,a,b,cnt,f[2 * N][25],ans[N];
struct line
{
	int id,l,r;
	bool operator < (const line &k) const {
	    return r < k.r;
	}
}L[2 * N];
void pre()
{
	int p2 = 1;
	for(int p1 = 1; p1 <= 2 * n; p1++)
	{
		while(p2 <= 2 * n)
		{
			if(L[p2].l > L[p1].r) break;
			p2++;
		}
		p2--;
		f[p1][0] = p2;
	}
	for(int j = 1; (1 << j) <= 2 * n; j++)
    {
    	for(int i = 1; i <= 2 * n; i++)
    		if(f[i][j - 1]) f[i][j] = f[f[i][j - 1]][j - 1];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d%d",&a,&b);
		if(b < a) b += m;
		L[i].id = i;
		L[i].l = a;
		L[i].r = b;
	}
	sort(L + 1,L + n + 1);
	for(int i = 1; i <= n; i++)
	{
		L[i + n].id = 0;
		L[i + n].l = L[i].l + m;
		L[i + n].r = L[i].r + m;
	}
	pre();
	for(int k = 1; k <= n; k++)
	{
		int tp = k,cnt = 1;
		for(int i = 20; i >= 0; i--)
		{
			if(f[tp][i] > 0 && L[f[tp][i]].r - L[k].l < m) 
			{
				tp = f[tp][i];
				cnt += (1 << i);
			}
		}
		ans[L[k].id] = cnt + 1;
	}
	for(int i = 1; i <= n; i++)
	    printf("%d ",ans[i]);
	return 0;
}
```


---

## 作者：Ebola (赞：14)

这题有点意思

我们考虑一个贪心。从当前区间出发，能选靠右的，就尽量选择更靠右的区间。然后每个区间都这样去贪心出右边选哪个，再倍增跳一下，跳到区间并的总长大于等于m即可。

我们考虑这个贪心的实现。题目中有一条重要条件，就是：区间没有包含关系。这是一个非常好的性质，它有什么用呢？稍微YY一下就会发现，根据这条性质，没有任何两个区间的左端点相同。再YY一下也不难发现，如果我们把所有区间按照左端点排序，那么右端点是从左向右单调分布的。所以我们的贪心可以基于左端点排序来实现。具体地，维护一个指针，假如右指针指向区间与当前区间有交集，就让指针右移，不断重复至移动到某个与当前区间无交集的区间，那么它的前一个区间，就是我们贪心策略所决定的区间。

具体实现时，需要把所有的区间都复制一遍，环上问题的套路不就是这样嘛

然后还有一个值得一提的小细节。实现贪心之前，要加上两个哨兵区间，左右各一个，端点均设为正无穷，不然你的贪心指针会无尽右移导致无故WA。还有就是，因为我们复制区间时会有2*m+r这样的东西出来，m又是10亿级别的，所以会爆int，要上long long。当然，如果你像我一样追求常数的话，就用unsigned int吧

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace IO
{
	const int S=(1<<20)+5;
	//Input Correlation
	char buf[S],*H,*T;
	inline char Get()
	{
		if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
		if(H==T) return -1;return *H++;
	}
	inline int read()
	{
		int x=0;char c=Get();
		while(!isdigit(c)) c=Get();
		while(isdigit(c)) x=x*10+c-'0',c=Get();
		return x;
	}
	//Output Correlation
	char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
	inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
	inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
	template <class I>inline void print(I x)
	{
		if(!x) putc('0');
		if(x<0) putc('-'),x=-x;
		while(x) qu[++qr]=x%10+'0',x/=10;
		while(qr) putc(qu[qr--]);
		putc(' ');
	}
}

using namespace IO;
typedef unsigned int uint;
const int N=200010;
struct Seg
{
	uint l,r,id;
	Seg(uint a=0,uint b=0,uint c=0):l(a),r(b),id(c){}
	friend bool operator < (const Seg &a,const Seg &b){return a.l<b.l;}
} seg[N<<1];
int mul[19][N<<1];
int ans[N];
uint n,m;

void Init()
{
	sort(seg+1,seg+1+2*n);
	int pr=0;
	seg[2*n+1]=Seg(-1,-1);
	for(int i=1;i<=2*n;i++)
	{
		while(seg[pr+1].l<=seg[i].r) pr++;
		mul[0][i]=pr;
	}
	for(int j=1;j<=18;j++)
		for(int i=1;i<=2*n;i++)
			mul[j][i]=mul[j-1][mul[j-1][i]];
	seg[0]=Seg(-1,-1);
}

int main()
{
	uint l,r;
	n=read();m=read();
	for(int i=1;i<=n;i++)
	{
		l=read();r=read();
		if(l<=r)
		{
			seg[i]=Seg(l,r,i);
			seg[n+i]=Seg(m+l,m+r);
		}
		else
		{
			seg[i]=Seg(l,m+r,i);
			seg[n+i]=Seg(m+l,m*2+r);
		}
	}
	Init();
	for(int i=1;i<=2*n;i++)
	{
		if(!seg[i].id) continue;
		int p=i,res=2;
		for(int j=18;j>=0;j--)
			if(seg[mul[j][p]].r-seg[i].l<m)
				p=mul[j][p],res+=1<<j;
		ans[seg[i].id]=res;
	}
	for(int i=1;i<=n;i++) print(ans[i]);
	flush();
	return 0;
}
```



---

## 作者：Fool_Fish (赞：7)

首先，对于这种环的问题，2倍链处理的

接下来，就类似于区间覆盖问题了

加入我们选择了 $i$ 战士，设他的右端点为 $r_i$,那么下一个战士  $j$，我们肯定要满足一下条件：

- $l_j \leq r_i$ 这是为了能够覆盖

- 对于满足上述条件的，尽量要求 $r_j$ 大，这是为了能够最优

设 $f_{i,j}$ 表示从第 $i$ 名士兵开始，向右选择了 $2^j$ 名士兵后到达第 $f_{i,j}$ 名战士的奔袭区间

我们可以预处理出 $f_{i,j}$，那么在每次查找的时候就跑一个倍增就行了

CODE:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=2e5+5; 
int n,m;
int ans[MAXN];
struct node{
	int id,l,r;
}s[MAXN*2];
int cmp(node a,node b){
	return a.l<b.l; 
}
int f[MAXN*2][20];
void pre(){
	for(int i=1,p=i;i<=2*n;i++){
		while(p<=2*n&&s[p].l<=s[i].r){
			p++;
		}
		f[i][0]=p-1;
	}
	for(int i=1;i<20;i++){
		for(int j=1;j<=2*n;j++){
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
}
void solve(int k){
	int rr=s[k].l+m,tot=1,p=k;
	for(int i=19;i>=0;i--){
		if(f[k][i]!=0&&s[f[k][i]].r<rr){
			tot+=(1<<i);
			k=f[k][i];
		}
	}
	ans[s[p].id]=tot+1;
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d %d",&s[i].l,&s[i].r);
		if(s[i].r<s[i].l){
			s[i].r+=m;
		}
		s[i].id=i;
	}
	sort(s+1,s+1+n,cmp);
	for(int i=1;i<=n;i++){
		s[i+n]=s[i];
		s[i+n].l=s[i].l+m;
		s[i+n].r=s[i].r+m;
	}
	pre();
	for(int i=1;i<=n;i++){
		solve(i);
	}
	for(int i=1;i<=n;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}

```

---

## 作者：Pine (赞：7)

# 贪心+倍增

对于一个环，套路性问题，我们直接拆开加倍，拉成链即可。

首先对于一个战士$i$，如果选了他，那么下一个战士$j$一定是所有左端点小于等于$i$的右端点的战士中最大的一个战士，因为这样子是最优的。

对于一个战士的下一个是哪一个的话，预处理+二分查找一下就可以了。

然后我们就直接一个一个的走就可以了。

但是我们为什么不倍增的跳呢？？

于是将一个一个跳变为倍增跳，，问题就解决了。。。

# 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
	static int ch; static bool flag;
	for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
	for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
	x = flag ? -x : x;
}
/*************************************Samle*************************************/

int n, m;
struct node{int l, r, id;} peo[800005];

namespace First
{
	int f[800005][31], s[800005][31], ans[800005], p;
	inline bool cmp(R node x, R node y) {return x.l < y.l || (x.l == y.l && x.r < y.r);}
	inline int find(R int x, R int l, R int r)
	{
		R int re=p+1, mid;
		while(l <= r)
		{
			mid = (l + r) >> 1;
			if(peo[mid].l <= x) l = mid + 1, re = mid;
			else r = mid - 1;
		}
		return re;
	}
	inline void calc()
	{
		p = n; MM(ans, 0);
		Fo(i, 1, n) if(peo[i].l > peo[i].r) peo[i].r += m; else peo[++p].l = peo[i].l + m, peo[p].r = peo[i].r + m, peo[p].id = i;
		sort(peo+1, peo+p+1, cmp); peo[p+1].r = 2e9;
		Fo(i, 0, 30) Fo(j, 1, p+1) f[j][i] = p+1;
		Fo(i, 1, p) f[i][0] = find(peo[i].r, i+1, p+1);
		Fo(j, 1, 30) Fo(i, 1, p) f[i][j] = f[f[i][j-1]][j-1];
		Fo(i, 1, p)
		{
			if(peo[i].id && !ans[peo[i].id])
			{
				R int now = i, to = peo[i].l + m;
				Ro(j, 30, 0) if(peo[f[now][j]].r < to) now = f[now][j], ans[peo[i].id] += (1<<j);
			}
		}
		Fo(i, 1, n) printf("%d ", ans[i]+2); puts("");
        // ans+2 -> ans中没有算第一个人，也没有算最后一个人，所以要加2
	}
}

int main()
{
	in(n); in(m);
	Fo(i, 1, n) in(peo[i].l), in(peo[i].r), peo[i].id = i;
	First :: calc();
	return 0;
}

```

---

## 作者：沉辰 (赞：6)

 解：
首先破链成环，就转化为了区间覆盖问题。

每一个区间都不能被其他区间所包含，

也就是如果li<lj，那么一定满足ri<rj，然后就可以贪心。

假设要覆盖整个区间，那么选择的线段是确定的，即每一个战士要找的下一个战士都是确定的。

这样可以按照左端点排序，预处理出每个战士的下一个接力者。

对于必须有这个战士参与，我们可以以这个战士为起点，寻找经过一圈之后再次回来最少需要多少条线段。

因为是链，所以我们用倍增预处理。

f[i][j]表示从i点走2j步到达的点，如果f[i][j]所到达的点没有超出m，就可以从i点走2j步，到达下一个点
[代码](http://www.cnblogs.com/adelalove/p/8492346.html)

---

## 作者：红色OI再临 (赞：4)

题目大意：给你一个大小为 m 的环和环上的 n 个区间

每个区间覆盖了环的一部分，保证互不包含。你要求出在一个

区间必须被选中的前提下，至少需要多少个区间才能完全覆盖整

个环。

首先保证必不包含，那么一个区间起点大的终点就大，所以可以考虑按照区间起点排序，然后断环成链，然后求出每一个区间的最优后继（就是交最小的），一个个跳改为倍增扩展，每次跳$<=m$的$1<<i$即可

表达能力0有些差，抱歉

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define maxn 200005
#define re register int
#define ll long long
using namespace std;
struct node{
	int id,l,r;
}a[maxn*2];
bool comp(node p,node q){
	return p.l<q.l;
}
int f[maxn*2][21];
int n,m,ans[maxn];

void getans(int x){
	int mmax=s[x].l;//最大就是覆盖一圈
	int num=1,pos=x;
	for(re i=20;i>=0;i--){
		if(f[pos][i]&&s[f[pos][i]].r<mmax){
			num+=(1<<i);
			pos=f[pos][i];
		}
	
	}
	ans[a[x].id]=num+1;

}
int main(){
	scanf("%d%d",&n,&m);
	for(re i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].l,&a[i].r);
		if(a[i].r<a[i].l)a[i].r+=m;
		a[i].id=i;
	}
	sort(a+1,a+1+n,comp);
	for(re i=1;i<=n;i++)
	{
		s[i+n]=s[i];
		s[i+n].l+=m;
		s[i+n].r+=m;
	
	}
	//以下一段为找到每个展示的后面的
	for(re i=1,p=i;i<=n<<1;i++){
	while(p<=n<<1&&a[p].l<=a[i].r)
		p++;
		int pos=p-1;
		f[i][0]=pos;	
	}
	for(re j=1;j<=20;j++)
	for(re i=1;i<=2*n;i++){
		f[i][j]=f[f[i][j-1]][j-1];
	}
	//求答案
	for(re i=1;i<=n<<1;i++){
		getans(i);
	}
	for(re i=1;i<=n;i++)
	printf("%d\n",ans[i]);
return 0;
}
```


---

## 作者：ghr_226 (赞：4)

你谷居然没有分块做法……

这是蒟蒻考场的想法。

套路拆环成链，离散化。

对于一个当前最远位置 $w$，贪心的选包含这个位置，覆盖最远的人。

可以用分块预处理每个位置的选择一个人后下一个最远的位置。

时间复杂度：$O(n\sqrt n)$。

于是对于每个人可以从右端点向后跳，计算跳回左端点的次数。

考虑优化。

发现和 [弹飞绵羊](https://www.luogu.com.cn/problem/P3203) 很像。

于是再次分块，对每个位置预处理跳到下一个块的次数，位置。

对于每个人从右端点向后跳，计算跳回左端点的次数
时间复杂度：$O(n\sqrt n)$。

时间略卡，于是一口氧气就过了……

考场代码略丑，有注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define re register
namespace IO {
char buf_[1 << 21], *p1_ = buf_, *p2_ = buf_;
#define ch()                                                                 \
  (p1_ == p2_ &&                                                             \
           (p2_ = (p1_ = buf_) + fread(buf_, 1, 1 << 21, stdin), p1_ == p2_) \
       ? EOF                                                                 \
       : *p1_++)
inline int in() {
  int s = 0, f = 1;
  char x = ch();
  for (; x < '0' || x > '9'; x = ch())
    if (x == '-') f = -1;
  for (; x >= '0' && x <= '9'; x = ch()) s = (s * 10) + (x & 15);
  return f == 1 ? s : -s;
}
char _buf[1 << 21];
int _pos = -1;
inline void flush() {
  fwrite(_buf, 1, _pos + 1, stdout);
  _pos = -1;
}
inline void pc(char x) {
  if (_pos == (1 << 21) - 1) flush();
  _buf[++_pos] = x;
}
inline void out(int x) {
  char k[30];
  int pos = 0;
  if (!x) return pc('0');
  if (x < 0) pc('-'), x = -x;
  while (x) k[++pos] = (x % 10) | 48, x /= 10;
  for (re int i = pos; i; i--) pc(k[i]);
}
}  // namespace IO
using namespace IO;

const int A = 1e6 + 5;
int n, m, blo;
int l[A], r[A];
int w[A];
int cir[A], len;
int be[A], tag[A];
int mx[A];
int c[A], to[A];

inline void lsh() {
  sort(w + 1, w + 1 + 4 * n);
  len = unique(w + 1, w + 1 + 4 * n) - (w + 1);
  for (re int i = 1; i <= 2 * n; ++i) {
    l[i] = lower_bound(w + 1, w + 1 + len, l[i]) - w;
    r[i] = lower_bound(w + 1, w + 1 + len, r[i]) - w;
  }  //离散化
  for (re int i = 1; i <= len; ++i) {
    if (w[i] > m) break;
    int L = 1, R = len, ans = 0;
    while (L <= R) {
      int mid = (L + R) >> 1;
      if (w[mid] - w[i] < m)
        L = mid + 1;
      else
        R = mid - 1, ans = mid;
    }
    cir[i] = ans;
  }  //找出每一个点转一圈后对应的点
  return;
}

inline void init() {
  for (re int i = 1; i <= 2 * n; ++i) {
    if (be[l[i]] == be[r[i]]) {
      for (re int j = l[i]; j <= r[i]; ++j) mx[j] = max(mx[j], r[i]);
      continue;
    }
    for (re int j = l[i]; be[j] == be[l[i]]; ++j) mx[j] = max(mx[j], r[i]);
    for (re int j = be[l[i]] + 1; j <= be[r[i]] - 1; ++j)
      tag[j] = max(tag[j], r[i]);
    for (re int j = r[i]; be[j] == be[r[i]]; j--) mx[j] = max(mx[j], r[i]);
  }
  for (re int i = 1; i <= len; ++i) mx[i] = max(mx[i], tag[be[i]]);
  return;
}  //预处理每个点跳一次后能到的最远点

inline void prepare() {
  for (re int i = 1; be[i] != be[len]; ++i) {
    int ans = 0, pos = i;
    while (pos <= len && be[pos] == be[i]) {
      ans++;
      pos = mx[pos];
    }
    ans++;
    pos = mx[pos];
    c[i] = ans, to[i] = pos;
  }
  return;
}  //预处理每个点跳到下一个块的次和位置

inline void work(int now) {
  int ans = 1, pos = r[now];
  while (to[pos] && to[pos] < cir[l[now]]) {
    ans += c[pos];
    pos = to[pos];
  }
  while (pos < cir[l[now]]) {
    ans++;
    pos = mx[pos];
  }
  out(ans), pc(' ');
  return;
}  //对每个点询问

signed main() {
  // freopen("flag.in", "r", stdin);
  // freopen("flag.out", "w", stdout);
  n = in(), m = in();
  for (re int i = 1; i <= n; ++i) {
    l[i] = in(), r[i] = in();
    if (r[i] < l[i]) r[i] += m;
    l[n + i] = l[i] + m, r[n + i] = r[i] + m;
    w[2 * i - 1] = l[i], w[2 * i] = r[i];
    w[2 * (n + i) - 1] = l[n + i], w[2 * (n + i)] = r[n + i];
  }
  lsh();
  blo = sqrt(len);
  for (re int i = 1; i <= len; ++i) be[i] = (i - 1) / blo + 1;
  init();
  prepare();
  for (re int i = 1; i <= n; ++i) work(i);
  pc('\n');
  flush();
  return 0;
}
/*
4 8
2 5
4 7
6 1
7 3
*/
```


---

## 作者：NeosKnight (赞：3)

来一个用离散化+BIT求后继的,思路都一样，处理出后继之后用倍增跳。但是有一个很重要的一点，所有区间都要加倍而不是只有往前跑的，往后跑的也要加倍!!具体请看看我的讨论（一定要看看!），因为这个WA了几天了。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
const int N=4e5+100;
struct qj{
	int l,r;int id;
	inline bool operator <(qj b)const{return r<b.r;}
}a[N<<1];
int to[31][N<<1];
int st[N<<2];int top=0;
int tr[N<<1];
#define lowbit(a) ((a)&(-a))
inline int Query(int p){
	register int k=0;
	while(p) {if(a[tr[p]].r>a[k].r||(!k)) k=tr[p];p-=lowbit(p);}
	return k;
}
inline int Get(int x){return (lower_bound(st+1,st+1+top,x)-st);}
inline void update(int p,int k)
{
	while(p<=top) {if((!tr[p])||a[tr[p]].r<a[k].r) tr[p]=k;p+=lowbit(p);}
	return;
}
int ans[N*20];
int main()
{
	int n,m;scanf("%d%d",&n,&m);top=0;
	for(register int i=1;i<=n;++i) {
		scanf("%d%d",&a[i].l,&a[i].r);a[i].id=i;
		if(a[i].l>a[i].r) a[i].r+=m;
		st[++top]=a[i].l,st[++top]=a[i].r;
	}
	register int nn=n;
	for(register int i=1;i<=nn;++i){
		a[++n]=(qj){a[i].l+m,a[i].r+m,0};
		st[++top]=a[n].l,st[++top]=a[n].r;
	}
	sort(st+1,st+1+top);
	top=unique(st+1,st+1+top)-st-1;
	sort(a+1,a+1+n);
	for(register int i=n;i;--i){to[0][i]=Query(Get(a[i].r));update(Get(a[i].l),i);}
	for(register int i=1;i<=30;++i)
		for(register int j=1;j<=n;++j)
			to[i][j]=to[i-1][to[i-1][j]];
	for(register int i=1;i<=n;++i){
		if(a[i].id!=0){
			register int R=a[i].l+m;register int u=i,id=a[i].id;
			for(register int j=30;~j;--j) if(to[j][u]!=0&&a[to[j][u]].r<R) u=to[j][u],ans[id]+=(1<<j);
			ans[id]+=2;
		}
	}
	for(register int i=1;i<=nn;++i) printf("%d ",ans[i]);
	puts("");
}

```


---

## 作者：jacky567 (赞：2)

因为区间互相不包含，所以可以把区间按照左端点排序，这样右端点一定也是单调的

然后将环拆成一条链，也就是将所以区间在复制一遍

贪心求出每个区间可以走到的下个区间的最远右端点

用$f[x][i]$表示从第$x$个区间出发，走$2^i$个区间到达的区间

用倍增思想，只要右端点$\geqslant$出发的左端点$+m$就可以了

注意要**预先保存第**$\textbf{i}$**个区间的原始下标**

附上代码：
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
struct ppap1
{
    int l,r,h;
}a[500010];
struct ppap2
{
    int to,nxt;
}t[1000010];
int n,m,len,tot,head[500010],ans[500010],f[500010][25];
int cmp(const ppap1 &a,const ppap1 &b)
{
	return a.l<b.l||(a.l==b.l&&a.r<b.r);
}
void add(int u,int v)
{
    t[++tot].nxt=head[u],head[u]=tot,t[tot].to=v;
}
int js(int x)
{
    int ans=0,temp=a[x].l+m;
    for(int i=20;i>=0;i--) if(f[x][i]&&a[f[x][i]].r<temp) x=f[x][i],ans+=(1<<i);
    return ans+2;
}
int main()
{
    scanf("%d%d",&n,&m),len=n;
    for(int i=1;i<=n;i++){
        scanf("%d%d",&a[i].l,&a[i].r),a[i].h=i;
        if(a[i].l>a[i].r) a[i].r+=m;
        else a[++len]=(ppap1){a[i].l+m,a[i].r+m,i};
    }
    sort(a+1,a+len+1,cmp),a[len+1].r=0x7fffffff;
    for(int i=1,z=1;i<=len;i++){
        while(z<=len&&a[z+1].l<=a[i].r) z++;
        f[i][0]=z;
    }
    for(int j=1;j<=20;j++)  for(int i=1;i<=len;i++) f[i][j]=f[f[i][j-1]][j-1];
    for(int i=1;i<=len;i++) if(a[i].l<=m) ans[a[i].h]=js(i);
    for(int i=1;i<=n;++i) printf("%d ",ans[i]);
}
```

---

## 作者：MikukuOvO (赞：2)

$emm...$都讲的好乱阿。。。

首先，我们破环为链。

其次，有一个比较显然的策略，假设我们强制选择$i$号战士，那么和$i$号战士有公共点且最靠右的线段最优，而且题目中保证了没有包含，所以随着左端点的增加，右端点单调非严格递增，因此我们可以$two-point$求得每一个区间下一个最优区间的编号。

考虑到$n$很大，直接跳不行，而~~显然~~$next$最优区间具有结合律，所以考虑倍增，$f[i][j]$表示从第$i$个区间，向下跳$2^j$个$next$最优区间后的区间，注意考虑自己的贡献。

---

## 作者：Elma_ (赞：1)

> [P4155 [SCOI2015]国旗计划](https://www.luogu.com.cn/problem/P4155)

加强版 [UVA1707 Surveillance](https://www.luogu.com.cn/problem/UVA1707)。

首先破环为链是一个比较常规的操作，对于每一个战士的奔袭区间都复制一遍。然后根据贪心的思想，选择的士兵数量相同时奔袭区间越大越好。

设 $f_{i,j}$ 表示从第 $i$ 名士兵开始，向右选择了 $2^j$ 名士兵后到达第 $f_{i,j}$ 名战士的奔袭区间。并且由于奔袭区间不会互相包含，所以这个选择的策略不会有冲突。

对于每一个 $i$ 预处理出 $f_{i,0}$，然后倍增预处理出整个 $f$ 数组。因为奔袭区间不会互相包含，隐含着一层意思是不会有任意两个区间的左端点或右端点相同，所以可以先对每个奔袭区间按照左端点的值排序后再预处理。因为每个 $i$ 能到达的奔袭区间具有单调性，所以不需要对于每一个 $i$ 都计算，$O(n)$ 扫一遍即可。

然后枚举每一个 $i$，倍增计算答案即可。总时间复杂度 $O(n \log n)$。细节还是比较多，详见代码。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

const int maxn = 200005;

inline int read() {
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}

struct soldier{
	int id, l, r;
}a[maxn << 1];
int n, m;
int to[maxn << 1][20], ans[maxn];

inline bool cmp(soldier a, soldier b) {
	return a.l < b.l;
}
inline void calc(int x) {
	int limit = a[x].l + m, res = 1, tmp = x;
	for (int i = 19;i >= 0;i--) {
		if (a[to[x][i]].r < limit && to[x][i] != 0)
			res += (1 << i), x = to[x][i];
	}
	ans[a[tmp].id] = res + 1;
}

int main(void) {
	n = read(), m = read();
	for (int i = 1;i <= n;i++) {
		a[i].id = i, a[i].l = read(), a[i].r = read();
		if (a[i].r < a[i].l) a[i].r += m;
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1;i <= n;i++)
		a[i + n] = a[i], a[i + n].l = a[i].l + m, a[i + n].r = a[i].r + m;
	for (int i = 1, tmp = i;i <= (n << 1);i++) {
		while (tmp <= (n << 1) && a[i].r >= a[tmp].l)
			tmp++;
		to[i][0] = tmp - 1;
	}
	for (int i = 1;i < 20;i++)
		for (int j = 1;j <= (n << 1);j++)
			to[j][i] = to[to[j][i - 1]][i - 1];
	for (int i = 1;i <= n;i++) calc(i);
	for (int i = 1;i <= n;i++)
		printf("%d%c", ans[i], " \n"[i == n]);
	return 0;
}
```


---

## 作者：JoaoFelix (赞：1)

首先这道题有一个性质：不会有一个区间包含另外一个区间

显然可以贪心，我们只需要维护在当前这的右端点之前的左端点能到达最远的右端点是哪里即可，然后根据此建立倍增数组

具体我们只需要破环为链，把所有读入的区间离散化，然后倍增维护即可！

求答案直接倍增二分，复杂度O(n log n)

有点小细节：
```cpp
if (r < l) la[tp] = node(l, r + m), tp++, la[tp] = node(l + m, m << 1);
else la[tp] = node(l, r), tp++, la[tp] = node(l + m, r + m);
```
必须要加入一个(l + m, m << 1)的区间，因为有可能对答案产生贡献。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 800005;

int n, m, tp, que[N], len, go[N][21];
struct node {
	int l, r;
	node(int nl = 0, int nr = 0) { l = nl, r = nr; }
} a[N], la[N];
bool cmp(node a, node b) { return a.l < b.l; }
int gt(int x) { return lower_bound(que + 1, que + len + 1, x) - que; }

int main() {
	// freopen("flag2.in", "r", stdin);
	// freopen("test_flag2.out", "w", stdout);
	n = read(); m = read();
	for (int i = 1; i <= n; i++) {
		int l = read(), r = read();
		tp++; a[i] = node(l, r);
		if (r < l) la[tp] = node(l, r + m), tp++, la[tp] = node(l + m, m << 1);
		else la[tp] = node(l, r), tp++, la[tp] = node(l + m, r + m);
	}
	for (int i = 1; i <= tp; i++) que[++len] = la[i].l, que[++len] = la[i].r;
	sort(que + 1, que + len + 1); len = unique(que + 1, que + len + 1) - que - 1;
	sort(la + 1, la + tp + 1, cmp);
	int pos = 1, mxr = 0;
	for (int i = 1; i <= len; i++) {
		while (pos <= tp && la[pos].l <= que[i]) mxr = max(mxr, la[pos].r), pos++;
		go[i][0] = gt(mxr);
	}
	// printf("%d\n", len);
	// for (int i = 1; i <= len; i++) printf("%d%c", que[i], " \n" [i == len]);
	for (int k = 1; k <= 20; k++)
		for (int i = 1; i <= len; i++) go[i][k] = go[go[i][k - 1]][k - 1];
	for (int i = 1; i <= n; i++) {
		int l = a[i].l, r = a[i].r, lst, ans = 1;
		if (l > r) r += m;
		r = gt(r); lst = l + m;
		for (int k = 20; k >= 0; k--)
			if (que[go[r][k]] < lst) ans += (1 << k), r = go[r][k];
		ans++; printf("%d%c", ans, " \n" [i == n]);
	}
	return 0;
}

```



---

## 作者：81179332_ (赞：1)

对于环上的问题，我们首先破环为链，将所有士兵的信息复制一份

题目要求用最少的步数走完一圈，那么我们可以转化为求用一定的步数走最远的距离（步数定义为使用的士兵个数）

设 $f_{i,j}$ 表示从第 $i$ 名士兵开始，走 $2^j$ 步，最远可以走到第 $f_{i,j}$ 个士兵的奔袭区间（由于各士兵的区间互不包含，所以我们将士兵按左端点排序后，士兵在序列中的位置可以代表实际位置）

预处理 $f_{i,0}$，然后倍增即可，此处 $f_{i,0}$ 有单调性，所以我们可以 $O(n)$ 处理出来

```cpp
//timeuse:30min
const int N = 400010;
int n,m;
struct soldier { int l,r,id; }a[N];
int f[N][20],ans[N];
void solve(int s)
{
	int t = a[s].l + m,res = 1,now = s;
	for(int i = 19;~i;i--) if(f[now][i] && a[f[now][i]].r < t)
		res += (1 << i),now = f[now][i];
	ans[a[s].id] = res + 1;
}
int main()
{
	freopen("random.in","r",stdin);
	freopen("sol.out","w",stdout);
	n = read(),m = read();
	for(int i = 1;i <= n;i++)
	{
		a[i].l = read(),a[i].r = read();if(a[i].l > a[i].r) a[i].r += m;
		a[i].id = i;
	}sort(a + 1,a + 1 + n,[&](soldier u,soldier v) { return u.l < v.l; });
	for(int i = 1;i <= n;i++) a[i + n] = a[i],a[i + n].l += m,a[i + n].r += m;

	int p = 1;
	for(int i = 1;i <= 2 * n;i++)
	{
		while(p + 1 <= 2 * n && a[p + 1].l <= a[i].r) p++;
		f[i][0] = p;
	}
	for(int j = 1;j < 20;j++) for(int i = 1;i <= 2 * n;i++)
		f[i][j] = f[f[i][j - 1]][j - 1];
	for(int i = 1;i <= n;i++) solve(i);
	for(int i = 1;i <= n;i++) pprint(ans[i]);
	return 0;
}
```

---

## 作者：ljfty (赞：0)

很有意思的一道题。

按套路破环成链，要注意右端点小于左端点的区间跨越了 $n\to 1$。

假设钦定了某个士兵 $i$，接下来肯定贪心选择左端点小于等于当前右端点的右端点最大的下一个区间。因为区间不存在包含关系，所以形式化地讲就是找到最大的 $j$ 使得 $C_j\leq D_i$。

直接做是 $O(N^2)$ 的，但观察到一条决策链中点的决策是存在重合的，即 $j$ 的决策可以部分应用到 $i$ 上面，并且存在单调性（因为不存在包含关系）。

考虑 $i$ 和 $j$ 之间连边，这样会形成一个决策森林。其中点 $u$ 的答案为距离 $u$ 最近的祖先 $v$ 使得 $D_v\geq C_u+m$。

从根节点开始双指针，但上端点移动时需要朝着下端点的方向。这个只需要更新边表头就行了，即进入过的儿子直接跳过。

除排序外时间复杂度 $O(N)$。

***code:***

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 400005
#define For(i,x,y)for(i=x;i<=(y);i++)
#define Down(i,x,y)for(i=x;i>=(y);i--)
#define int long long
struct node
{
	int next,to;
}e[N];
struct soldier
{
	int c,d,id;
}a[N];
bool used[N];
int head[N],dep[N],res[200005],g,m;
inline void add(int u)
{
	e[++g].next=head[u];
	head[u]=g;
}
int read()
{
	int A;
	bool K;
	char C;
	C=A=K=0;
	while(C<'0'||C>'9')K|=C=='-',C=getchar();
	while(C>'/'&&C<':')A=(A<<3)+(A<<1)+(C^48),C=getchar();
	return(K?-A:A);
}
void write(int X)
{
	if(X<0)putchar('-'),X=-X;
	if(X>9)write(X/10);
	putchar(X%10|48);
}
inline bool cmp(soldier _,soldier __)
{
	return _.c<__.c;
}
void dfs(int l,int r)
{
	int i;
	while(head[r]&&a[head[r]].d>=a[l].c+m)r=head[r];
	/*cout<<l<<' '<<r<<' '<<head[r]<<' '<<a[l].c<<' '<<a[l].d<<' '<<a[r].c<<' '<<a[r].d<<endl;*/
	if(a[r].d>=a[l].c+m)res[a[l].id]=dep[l]-dep[r]+1;
	used[l]=1;
	for(i=head[l];i;i=e[i].next)
	{
		head[l]=i;
		dep[i]=dep[l]+1;
		dfs(i,r);
	}
}
signed main()
{
	int n,i,pos=1;
	n=read(),m=read();
	For(i,1,n)
	{
		a[i].c=read(),a[i].d=read();
		a[i].id=i;
		if(a[i].d<a[i].c)a[i].d+=m;
		a[i+n].c=a[i].c+m;
		a[i+n].d=a[i].d+m;
	}
	sort(a+1,a+(n<<1|1),cmp);
	For(i,1,n<<1)
	{
		while(pos<n<<1&&a[pos+1].c<=a[i].d)pos++;
		if(pos!=i)add(pos);
		/*cout<<pos<<' '<<i<<' '<<head[pos]<<endl;*/
	}
	Down(i,n<<1,1)
	if(!used[i])dfs(i,i);
	For(i,1,n)write(res[i]),putchar(' ');
	return 0;
}
```

---


# 旅行

## 题目背景

> 光阴似箭。如烟火，只许刹那芳华；似九月，夜幕昙花一闪而散。
> 辉煌已逝。步征夫，辗转行路之洼；立孤叶，夙夜漂泊四海之旅。
——《旅行》

## 题目描述

行走与尘世之间，charine 是一位旅行家。踏入城市的喧嚣，他开始了辗转于城市的旅行……

这是一个具有 $n$ 个城市的城市群，每两个点可以互相到达。现代交通技术飞速发展，大大缩短了航程，距离已显得不在那么重要：

城市群里，道路已经没有长长短短之说，**每一条道路由于时间的不断缩短都可视为等长**，把它们以一个单位计量，可以容易的视其为 $1$ zm。

正是由于城市群的庞大，未脱离于城市的 charine 亦有牵绊，这使他不可能无限遨游于这宽广的城市群里。这使 charine 极为郁闷，他决定选择尽可能短的时间走遍整个城市群。

具体而言，charine 不会因为在某个城市里而耽误他遨游天下的决心，他走访的每一个城市，都会在极短的时间里将其印在脑海里。

charine 的行走速度不会很快，这意味着他只能在一个单位时间内行走 $1$ zm。

这却使他更着急着找到足够旅行更多城市的方法……

为了去除他在每一个岔路口的犹豫时间，charine 亦是聪明的提前了他的旅行计划。对于走出城市 $i$ 的那几个路口，charine 给这个城市定义了一个通路 $a_i$，他相信自己的计划，就一定会踩着通路向前走。**走访完城市 $i$ 的他会给自己的下一个城市目标定为 $a_i$**。

处理完这些以后，他便是再也找不出继续缩短时间的办法了，于是他开始执行了自己的旅行计划。

charine 有 $m$ 个季度都有出行的机会，对于第 $i$ 个季度，charine 将会从 $S_i$ 出发，他告诉你，他会准备 $t$ 单位时间去旅行。

为了能及时的看到他的身影，你要知道，**$t$ 单位时间后 charine 会出现在哪个城市……**

**注意“道路”与“通路”的定义问题。**

## 说明/提示

样例解析：

从 $1$ 开始走 $2^{2}$ 步到达 $5$（$1-2-3-4-5$）

从 $2$ 开始走 $7^{1}$ 步到达 $3$（$2-3-4-5-6-1-2-3$）

从 $6$ 开始走 $1^{1}$ 步到达 $1$（$6-1$）

对于 $10\%$ 的数据，$n\leq 100$，$m\leq 300$，$t_1\leq 100$。

对于 $50\%$ 的数据，$n\leq 3000$，$m\leq 3000$，$t_1\leq 3000$，$t_2=1$。

对于 $70\%$ 的数据，$n\leq 3000$，$m\leq 3000$。

对于 $100\%$ 的数据，$n\leq 400000$，$m\leq 300000$，$t_1\leq 10^{9}$，$t_2\leq 10^9$。

## 样例 #1

### 输入

```
6
2 3 4 5 6 1
3
1 2 2
2 7 1
6 1 1```

### 输出

```
5
3
1```

# 题解

## 作者：Sooke (赞：9)

### 解题思路

首先，**每个点有且只有一个出边的图构成内向基环森林**。

设一共有 $n$ 个点，不难证明：**在内向基环森林上走** $n$ **次出边，此时一定停留在环上**。

明白这两个套路后，这题就简单许多了。

考虑建立倍增数组 $e_{i,\,u}$ ，表示从点 $u$ 出发走 $2^i$ 次出边停留的位置。以便我们在 $O(\log n)$ 的时间里查询走任意 $\le n$ 次出边停留的位置。

因为走到环上时，想一直走必然是绕着这个环转圈，自然想到应该存下每个环的信息（例如大小，上面有哪些点，每个点在何位置等）。

因此对于每个点，我们先走 $n$ 步，如引理所述，我们此时正在某个环上，如果这个环尚未被记录，我们绕着环走直到回到出发的位置顺便记录信息。

如何处理询问？还是基于那个引理。如果询问的 $t$ 很小（$< n$），以至于我们无法判断终点是否处于环上，此时恰好倍增数组正是为这个范围服务的。否则令 $t' = t - n$ ，即先走 $n$ 步再走 $t'$ 步，我们求出 $n$ 步后位于环上的位置，而 $t'$ 步都是在绕圈（周期为环的大小，设其为 $s$）。只有 $t'\ \text{mod}\ s = (t_1^{t_2} - n)\ \text{mod}\ s$ 步是有用的，快速幂及减法的得到该余数，然后直接使用之前预处理环的信息来查询。

时间复杂度：$O(n \log n + m \log t)$ 。

---

### 代码实现

```cpp
#include <bits/stdc++.h>

inline int read() {
    char c; int x; for (c = getchar(); !isdigit(c); c = getchar());
    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return x;
}

inline int power(int x, int y, int mod, int res = 1) {
    for (; y; y >>= 1, x = 1ll * x * x % mod) {
        if (y & 1) { res = 1ll * res * x % mod; }
    } return res;
}

const int N = 5e5 + 5, L = 19;

int n, m, q, lgn, e[L][N], bln[N], pos[N];
std::vector<int> cyc[N];

int check(int x, int y) {
    if (x == 1) { return 1; }
    long long tmp = 1;
    for (; y; y--) {
        tmp *= x;
        if (tmp > n) { return -1; }
    } return tmp;
}

int jump(int u, int x) {
    for (int i = 0; i <= lgn; i++) {
        if (1 << i & x) { u = e[i][u]; }
    } return u;
}

int main() {
    n = read(); lgn = log(n) / log(2) + 1e-7;
    for (int i = 1; i <= n; i++) {
        e[0][i] = read(); bln[i] = -1;
    }
    for (int j = 1; j <= lgn; j++) {
        for (int i = 1; i <= n; i++) {
            e[j][i] = e[j - 1][e[j - 1][i]];
        }
    }
    for (int i = 1; i <= n; i++) {
        int u = e[lgn][e[lgn][i]];
        if (bln[u] == -1) {
            for (; bln[u] == -1; u = e[0][u]) {
                bln[u] = m; pos[u] = cyc[m].size();
                cyc[m].push_back(u);
            }
            m++;
        }
    }
    for (q = read(); q; q--) {  
        int u = read(), x = read(), y = read(), z = check(x, y);
        if (z == -1) {
            u = jump(u, n);
            int s = cyc[bln[u]].size();
            z = (power(x, y, s) + s - n % s) % s;
            u = cyc[bln[u]][(pos[u] + z) % s];
        } else {
            u = jump(u, z);
        } printf("%d\n", u);
    }
    return 0;
}
```

---

## 作者：Lates (赞：4)

按照题意把每个点 $i$ 连到 $a_i$ 建图可以得到一个每个点只有一个出边的 DAG。

图不一定联通，考虑用 tarjan 找到每个联通块内的环，那么对于询问的点 $s$，讨论其是否在它所在联通块的环上。

假设环的大小为 $l$。

1. 如果在环上，那么必然走的是个以环上点个数为周期的路，那么只需要从 $s$ 走 $len=t1^{t2}\bmod l$。
2. 如果不在，那么求出 $s$ 到环的距离 $a$，因为出边唯一，所以 $s$ 到环这条路径是一条唯一的链，那么只需要从 $s$ 走 $len=(t1^{t2}+a) \bmod l$ 。

时间复杂度 $\mathcal{O(nm)}$，就有 $70\ pts$ 了。

发现这里了要优化从 $s$ 走 $len$ 的长度，可以考虑倍增。

假设 $f[i][j]$ 表示从点 $i$ 走 $2^j-1$ 距离后的点。

那么便有转移 $f[i][j]=f[\ a[\ f[i][j-1]\ ]\ ][j-1]$。

初始条件 $f[i][0]=a[i]$

由于任何数都可以表示为 $2$ 进制数，那么就有任何一个数可以表示为 $2$ 的幂的和 ~~(CSP2020 J T1)~~。同理 $len$ 可以表示一些 $2$ 的幂的和，那么将其 $2$ 进制拆分，当 $len$ 的二进制第 $i$ 位为 $1$ 就跳到 $a[f[now][i]]$（$now$ 为当前跳到的位置）

然后就做完了，时间复杂度 $\mathcal{O(n\log n+m\log len)}$

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

一眼倍增，但是有一些细节需要仔细处理一下。

首先对于一个内向基环树森林，跳 $n$ 次一定能够跳到环里。所以，如果次数不够就直接倍增跳，够的话另说。

在这里判断的时候，一定要注意如果 $t_1=1$ 的话，那么次数一定是够的，其余的情况暴力乘着判断才是 $O(\log)$ 的。

我们还需要处理出每一个环的环长。将剩余次数进行取模之后再倍增着跳。

这里要注意不要忘了减前面已经跳过的 $n$ 次。

然后就没有什么难点了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, a[400005][20], m;
inline int qpow(long long a, int b, int p) {
	long long ret = 1;
	for (; b; b >>= 1, a = a * a % p)
		(b & 1) && (ret = ret * a % p);
	return ret;
}
int vis[400005], rl[400005]; stack<int>s;
inline void dfs(int p, int t) {
	vis[p] = t; s.emplace(p);
	if (vis[a[p][0]] == t) {
		for (int i = a[p][0]; i != p; i = a[i][0])
			rl[a[p][0]]++;
		rl[a[p][0]]++;
		while (s.top() != a[p][0])
			rl[s.top()] = rl[a[p][0]], s.pop();
		s.pop(); return;
	}
	if (vis[a[p][0]]) rl[p] = rl[a[p][0]], s.pop();
	else if (dfs(a[p][0], t), !rl[p]) 
		rl[p] = rl[a[p][0]], s.pop();
}
inline bool cmp(int t1, int t2, int wt) {
	long long ap = 1; if (t1 == 1) return 1;
	for (int i = 1; i <= t2; ++i)
		if ((ap *= t1) > wt) return 0;
	return 1;
}
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i][0];
	for (int j = 1; j <= 19; ++j)
		for (int i = 1; i <= n; ++i)
			a[i][j] = a[a[i][j - 1]][j - 1];
	for (int i = 1; i <= n; ++i) if (!rl[i]) dfs(i, i);
	cin >> m;
	for (int i = 1, s, t1, t2; i <= m; ++i) {
		cin >> s >> t1 >> t2; 
		if (cmp(t1, t2, n)) {
			t1 = qpow(t1, t2, n + 1);
			for (int j = 19; j >= 0; j--)
				if (t1 >> j & 1) s = a[s][j];
			cout << s << endl; continue;
		}
		for (int j = 19; j >= 0; j--)
			if (n >> j & 1) s = a[s][j];
		t1 = qpow(t1, t2, rl[s]);
		t1 = (t1 - n % rl[s] + rl[s]) % rl[s];
		for (int j = 19; j >= 0; j--)
			if (t1 >> j & 1) s = a[s][j];
		cout << s << endl;
	}
}
```

---

## 作者：zyn_ (赞：0)

题意：给定 $n$，一个长为 $n$ 的序列 $\{a_i\}$。$m$ 次询问，每次初始令 $p\gets S_i$，然后执行 $t_1^{t_2}$ 次 $p\gets a_p$，求最终的 $p$。

容易发现，不断地令 $p\gets a_p$，$n$ 次后一定会遍历到已经过的 $p$，从而发生了循环。如果建立一个图 $G$，将 $p\to a_p$ 连边，那么 $G$ 是一个基环树森林。这个图由若干个基环树组成，一个基环树形如：一个环，环上每个节点可能挂有子树。

如果询问的 $t_2=1$，那么这个问题可以直接倍增求解——只需预处理数组 $f_{i,j}$ 代表从 $i$ 走 $2^j$ 步到达的点。

现在有了 $t_2$，不能直接倍增了。注意到一个点走到环上即开始循环，循环的长度为环长。

### $S_i$ 在环上

走 $t_1^{t_2}$ 步等价于走 $t_1^{t_2}\bmod l$ 步（$l$ 为 $S_i$ 所在环的环长）。现在可以倍增了。也可以将环上所有点存在数组中，并存储每个点在数组中的下标，可以做到 $O(1)$。

### $S_i$ 不在环上

首先一遍 DP 可以预处理出所有不在环上的点，到环的距离 $c_i$ 以及进入环时的第一个点 $r_i$。

如果 $t_1^{t_2}<c_i$ 直接倍增。否则先走 $c_i$ 步后就化为上一种情况，可以 $O(1)$。

其实 $t_1^{t_2}<c_i$ 时等价于求树上 $K$ 级祖先，可以 $O(n\log n)$ 预处理 $O(1)$ 询问。

综上，预处理与单次查询时间复杂度 $O(n)-O(\log n)$ 或 $O(n\log n)-O(1)$。

---


# [SHOI2012] 信用卡凸包

## 题目背景

SHOI2012D1T2


## 题目描述

信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 1/4 圆，如下图所示。现在平面上有一些规格相同的信用卡，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。

 ![](https://cdn.luogu.com.cn/upload/pic/6549.png) 



## 说明/提示

样例1说明： ![](https://cdn.luogu.com.cn/upload/pic/6550.png)

本样例中的 2 张信用卡的轮廓在上图中用实线标出，如果视 1.5707963268为pi/2，那么凸包的周长为16+4sqrt(2)

样例2说明： ![](https://cdn.luogu.com.cn/upload/pic/6551.png)

样例3说明： ![](https://cdn.luogu.com.cn/upload/pic/6552.png)

其凸包的周长约为41.628267652。


本题可能需要使用数学库中的三角函数。不熟悉使用方法的选手，可以参考下面的程序及其输出结果：

```cpp
uses math;
const Pi = 3.141592653589793;
begin
writeln(sin(30.0 / 180.0 * Pi) : 0 : 10);
writeln(cos(60.0 / 180.0 * Pi) : 0 : 10);
writeln(tan(45.0 / 180.0 * Pi) : 0 : 10);
writeln(arcsin(1.0) : 0 : 10);
writeln(arccos(0.0) : 0 : 10);
writeln(arctan(1.0) : 0 : 10);
end.
```
```cpp
#include <iostream>
#include <math.h>
using namespace std;
const double Pi = 3.141592653589793;
int main()
{
cout.setf(ios::fixed);
cout.precision(10);
cout<<sin(30.0 / 180.0 * Pi)<<endl;
cout<<cos(60.0 / 180.0 * Pi)<<endl;
cout<<tan(45.0 / 180.0 * Pi)<<endl;
cout<<asin(1.0)<<endl;
cout<<acos(0.0)<<endl;
cout<<atan(1.0)<<endl;
return 0;
}
```
输出结果：0.5000000000

0.5000000000

1.0000000000

1.5707963268

1.5707963268

0.7853981634


数据范围：

 ![](https://cdn.luogu.com.cn/upload/pic/6553.png) 

![](https://cdn.luogu.com.cn/upload/pic/6554.png)


## 样例 #1

### 输入

```
2
6.0 2.0 0.0
0.0 0.0 0.0
2.0 -2.0 1.5707963268```

### 输出

```
21.66```

## 样例 #2

### 输入

```
3
6.0 6.0 1.0
4.0 4.0 0.0
0.0 8.0 0.0
0.0 0.0 0.0```

### 输出

```
41.60```

## 样例 #3

### 输入

```
3
6.0 6.0 1.0
4.0 4.0 0.1745329252
0.0 8.0 0.3490658504
0.0 0.0 0.5235987756```

### 输出

```
41.63```

# 题解

## 作者：ShineEternal (赞：70)

节选自：[vercont的一篇洛谷日报](https://45475.blog.luogu.org/convex-hull)


### 题目链接：

[P3829 [SHOI2012]信用卡凸包](https://www.luogu.org/problem/P3829)

是一道上海的省选题，不过并不难。

### 题意简叙：

![](https://cdn.luogu.com.cn/upload/pic/6549.png)

给你一堆如上图所示的卡片，求其凸包周长（凸包可以包含圆弧）

### 分析：

**我主要是来对那个转换画图说明一下，不然有些人可能云里雾里**

我们可以先来考虑$r=0$的情况。

发现$r=0$即为信用卡为矩形，于是就按照正常的思路将点列出跑Graham算法即可。

---

然后开始想正解


因为样例三是最普遍的情况，所以研究一下：

![](https://i.loli.net/2019/08/15/kVngAqUotbxI4RY.png)

首先带有圆弧的凸包不好处理呢。


于是我们把每一个被磨圆的顶角往圆心里看，再重新构造凸包，然后发现黑色内圈与绿蓝外圈有重叠部分。

再分解一下，如红笔。

**发现恰好多出4个$\frac{1}{4}$圆弧，也就是一个圆**

再验证几个发现也是对的。

于是这个问题就转换为裸的凸包模板了。

#### 这种题目里面都告诉凸包了，关键在于怎么转换，不然生搬硬套，很难得分

---

## 作者：刘辰雨 (赞：17)

# 题解

### 闲话：

其实我是怀着激动的心情写这篇题解的，意在提醒各位一些小  **《玄学问题》**  。

## 正文：

这道题楼上的大佬已经剖析得七七八八，纵使站在巨人的肩膀上，我依然做的磕磕盼盼，详见  
[我的讨论板求助帖](https://www.luogu.com.cn/discuss/401904) 。

多的不说，具体操作就是吧圆心跑一边凸包模板，在加上  **一个完整圆周长**  。 没写过模板请移步 [凸包模板题](https://www.luogu.com.cn/problem/P2742) 

至于为什么是圆的周长，在这里推荐我一个同学的思路（[@cwfxlh](https://www.luogu.com.cn/user/340819),他是个大佬） —— **想像有一只小蚂蚁从一条边绕凸包转一圈回到起点，它的方向没有变，转了360°又回来了。因为只有弧会改变方向，所以所有的弧的总和一定是360°** （妙啊）。

另外应《闲话》里说的，对我和  [@Xrcxjcw](https://www.luogu.com.cn/user/387961) 遇到的一些“玄学”问题做一个提醒~

1.正如上文谈到的讨论贴里的内容（若未阅读请移步），造成那种玄学现象的原因正是 **形如 $ a_{i++} $ 这样的数组下标的调用** ，分成两部后就修复了。虽然我也不知道是为什么，但是这样的调用似乎会导致某些逻辑错误？？欢迎讨论区大佬解答。 

2.凸包调用时  $  n<2  $  的情况将不能求解，但此题判断时一张卡应作四个点判断，否则直接判断卡的数量会  RE 。
 
 （这都来自血淋淋的教训） 

总的来说，这篇题解虽然不太常规，但是作为一道出世很久的紫题，这样一份《错误提示》和《思路梳理》是应该有的。况且这些都来自亲身实验，希望可以帮到大家。

最后还是附上 code ~ 

## 部分Code:

```cpp
struct vec
{
    double x, y;
} a[100001];
int q[100001]={}, top=0, n=0, vist[1000001]={};
double ans = 0.0,h=0,v=0,r=0,xx=0,yx=0,th=0;
inline double len(vec a, vec b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
inline double cj(vec a, vec b, vec p)
{
    return (b.x-a.x)*(p.y-a.y)-(b.y-a.y)*(p.x-a.x);
}
inline bool cmp(vec a, vec b)
{
    if (a.x == b.x)
        return a.y < b.y;
    return a.x < b.x;
}
void read()
{
	scanf("%d" , &n);
    n *= 4;
    scanf("%lf%lf%lf" , &v , &h,&r);
    for (int i = 1; i <= n; )
    {
        scanf("%lf%lf%lf" , &xx, &yx , &th);
        xx += eps;
        yx += eps;
        th += eps;
        double x=0 , y=0;
        x = (h/2-r)*cos(th)-(v/2-r)*sin(th)+xx;
        y = (v/2-r)*cos(th)+(h/2-r)*sin(th)+yx;
//        cout<<x<<" "<<y<<endl;
        a[i].x = x;
        a[i].y = y;
        i++;
        x = -(h/2-r)*cos(th)-(v/2-r)*sin(th)+xx;
        y = (v/2-r)*cos(th)-(h/2-r)*sin(th)+yx;
//		cout<<x<<" "<<y<<endl;
        a[i].x = x;
        a[i].y = y;
        i++;
        y = -(v/2-r)*cos(th)+(h/2-r)*sin(th)+yx;
        x = (h/2-r)*cos(th)+(v/2-r)*sin(th)+xx;
//        cout<<x<<" "<<y<<endl;
        a[i].x = x;
        a[i].y = y;
        i++;
        x = -(h/2-r)*cos(th)+(v/2-r)*sin(th)+xx;
        y = -(v/2-r)*cos(th)-(h/2-r)*sin(th)+yx;
//        cout<<x<<" "<<y<<endl;
        a[i].x = x;
        a[i].y = y;
        i++;
    }
}
void tubao()
{
	sort(a + 1, a + n + 1, cmp);
    q[++top] = 1;
    q[++top] = 2;
    vist[1] = vist[2] = 1;
    for(int i = 3 ; i<= n ; i++)
    {
        if(vist[i] == 1)continue;
        if(top==1||cj(a[q[top-1]],a[q[top]],a[i]) > 0)
        {
            q[++top] = i;
            vist[i] = 1;
        }
        else
        {
            while(cj(a[q[top-1]],a[q[top]],a[i]) <= 0&&top>1)
            {
                vist[q[top]] = 0;
                top--;
            }
            q[++top] = i;
            vist[i] = 1;
        }
    }
    for(int i=2;i<=top;i++)ans+=len(a[q[i-1]],a[q[i]]);
    top = 0;
    q[++top]=n;
    for(int i=n-1;i>0;i--)
    {
        if(vist[i]==0)
        {
            q[++top] = i;
            break;
        }
    }
    for(int i = n-2 ; i>= 1 ; i--)
    {
        if(cj(a[q[top-1]],a[q[top]],a[i]) > 0||top==1)
        {
            q[++top] = i;
            vist[i] = 1;
        }
        else
        {
            while(cj(a[q[top-1]],a[q[top]],a[i]) <= 0 && top>1)
            {
                vist[q[top]] = 0;
                top--;
            }
            q[++top] = i;
            vist[i] = 1;
        }
        if(top <= 1)break;
    }
    for(int i=2;i<=top;i++)ans+=len(a[q[i-1]],a[q[i]]);
    printf("%.2lf",ans+3.141592653589793*2*r);
}
```

祝各位 AC 愉快~

---

## 作者：pantw (赞：14)

FJ省夏2017出过这个题emmm然后对我就成了双倍经验题2333

简单的凸包问题。实现细节详见代码注释。


```cpp
#include <algorithm>
#include <cstdio>
#include <cmath>
#define eps 1e-12
#define maxn 100010
#define maxm 400010
#define calc(a, b, c) (cross((b)-(a),(c)-(a)))
using namespace std;
const double PI = acos(-1);
struct P{
    double x, y;
    P(double x = 0.0, double y = 0.0):x(x), y(y) {}
}p[maxm];
P operator + (P a, P b) {return (P){a.x + b.x, a.y + b.y};}
P operator - (P a, P b) {return (P){a.x - b.x, a.y - b.y};}
P operator - (P a) {return (P){-a.x, -a.y};}
P operator * (P a, double b) {return (P){a.x * b, a.y * b};} // 数乘
bool operator < (const P& a, const P& b) {
    return a.x==b.x?a.y<b.y:a.x<b.x;
}
double dot(P a, P b) {return a.x*b.x+a.y*b.y;} // 点积
double cross(P a, P b) {return a.x*b.y-a.y*b.x;} // 叉积
double abs(P a) {return sqrt(a.x*a.x+a.y*a.y);} // 取模
P rotate(P a, double t) { // 旋转
    double c = cos(t), s = sin(t);
    return (P) {a.x*c-a.y*s, a.x*s+a.y*c};
}
int q[maxn];
int main() {
    int n, c = 0;
    double a, b, r, x, y, t;
    scanf("%d%lf%lf%lf", &n, &b, &a, &r);
    a /= 2.0, b /= 2.0; // 取得半长和半宽
    for(int i = 1; i <= n; i++) {
        scanf("%lf%lf%lf", &x, &y, &t);
        x += eps, y += eps, t += eps; // 扰动，避免出现除0或者NaN
        P _ = (P){x, y}; // 中心
        p[++c] = rotate((P){a-r, b-r}, t) + _; // 先旋转再加中心
        p[++c] = rotate((P){r-a, b-r}, t) + _;
        p[++c] = rotate((P){r-a, r-b}, t) + _;
        p[++c] = rotate((P){a-r, r-b}, t) + _;
    }
    sort(p+1, p+c+1); // x-y 排序
    int T = 0;
    for(int i = 1; i <= c; i++) { // 下凸壳
        while(T>1&&calc(p[q[T-1]],p[q[T]],p[i])<=0)T--;
        q[++T] = i;
    }
    int tmp = T;
    for(int i = c - 1; i; i--) { // 上凸壳
        while(T>tmp&&calc(p[q[T-1]],p[q[T]],p[i])<=0)T--;
        q[++T] = i;
    }
    double ans = 2 * PI * r; // 加上一周
    for(int i = 1; i < T; i++) ans += abs(p[q[i]]-p[q[i+1]]);
    printf("%.2lf", ans);
    return 0;
}
```

---

## 作者：BackSlashDelta (赞：7)

## [Luogu P3829 [SHOI2012]信用卡凸包](https://www.luogu.com.cn/problem/P3829)

### 题面

给定一些经过了圆滑边角处理过的矩形，这些“矩形”散落在一个平面直角坐标系之中。这些“矩形”都全等，但是所处的位置不同，旋转的角度不同。求能够框柱所有“矩形”的图形的最小的周长。

### 题解

#### 转化

为了最小的圈住所有图形，~~依照题目名字~~不难猜到我们应该用什么——对，**二维凸包**。

但是直接处理带有圆角的凸包肯定是令人头痛的。那我们**把圆角抽出来**，单独考虑圆角和直边。

![](https://cdn.luogu.com.cn/upload/image_hosting/aigk8e8f.png)

自细观察可以发现：**所有圆角拼接起来刚好可以组成一个圆周。**  
那么好办，我们就把原问题分解为两个：**圆周的周长**和**直边的长度和**。  
这时把直边组合起来（下图左），可以发现：**它们刚好是四分之一圆周的圆心的连线。**

![Trans](https://cdn.luogu.com.cn/upload/image_hosting/hihrawc2.png)

于是很欢快的，我们的问题就变成了：**圆周的周长**和**圆心集合的凸包长度**。

~~其实这个转化还是比较常见的。~~

#### 存图

经过了上面的分析，不难发现：我们只要维护一个圆心的凸包即可。  
所以显然的，我们只要把四个角上的四分之一圆的圆心存下来即可。

不考虑旋转的情况，只要把四角坐标向内“缩”一个半径长度即可。

#### 旋转

如果需要旋转，那么我们同样是旋转圆心。  
这时我们考虑**平移坐标系**，使原点与旋转中心重合，  
转完之后再把坐标系平移回去。

那就好办了：

- 待转点 $\text{P}$ 减去旋转中心 $\text{O}$ ，得到镜像待转点 $\text{P}'$
- 旋转 $\text{P}'$ ，得到镜像目标点 $\text{Q}'$
- $\text{Q}'$ 加上 $\text{O}$ ，得到目标点 $\text{Q}$

> 将 $(x,y)$ 绕原点 $(0,0)$ 旋转 $\alpha$ 后的点的坐标为 $(x\cos\alpha-y\sin\alpha,y\cos\alpha+x\sin\alpha)$

#### 凸包

这里不做说明。如有需要请移步[【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)。

~~对没错就是模板。~~

### 代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>

// Definitions
#define MAXN 100010
#define INF 0x7fffffff
#define PI 3.1415926535
typedef long double num128;

// Geometry
struct point {
  num128 x, y;
  friend bool operator < (const point _x, const point _y) {
    return _x.x == _y.x ? _x.y < _y.y : _x.x < _y.x;
  }
  friend point operator - (const point _x, const point _y) {
    return {_x.x - _y.x, _x.y - _y.y};
  }
  friend point operator + (const point _x, const point _y) {
    return {_x.x + _y.x, _x.y + _y.y};
  }
} P[MAXN * 4], O;
int pcnt, idxO;
inline num128 cross(point _x, point _y) {
  return _x.x * _y.y - _y.x * _x.y;
}
inline num128 distSqr(point _x, point _y) {
  point _z = _x - _y;
  return _z.x * _z.x + _z.y * _z.y;
}
inline bool cmp(point _x, point _y) {
  num128 crossval = cross(_x - O, _y - O);
  return crossval == 0 ? distSqr(_x, O) < distSqr(_y, O) : crossval > 0;
}
inline point rotate(point _x, point _c, num128 _rad) {
  num128 cosval = cos(_rad), sinval = sin(_rad);
  _x = _x - _c;
  point _y = (point){_x.x * cosval - _x.y * sinval, _x.y * cosval + _x.x * sinval};
  return _y + _c;
}

// Variables
int n;
num128 a, b, r, ans;

// Convex Hull
point C[MAXN];
int ccnt;
inline void ConvexHull() {
  O = P[1];
  std::sort(P + 2, P + 1 + pcnt, cmp);
  C[++ccnt] = P[1];
  for (int i = 2; i <= pcnt; i++) {
    while (ccnt > 1 && cross(C[ccnt] - C[ccnt - 1], P[i] - C[ccnt]) <= 0)
      ccnt--;
    C[++ccnt] = P[i];
  }
  C[ccnt + 1] = P[1];
}

// Functions
inline void Process() {
  ConvexHull();
  for (int i = 1; i <= ccnt; i++) {
    ans += sqrt(distSqr(C[i], C[i + 1]));
  }
  ans += 2 * r * PI;
}
inline void ReadIn() {
  scanf("%d%Lf%Lf%Lf", &n, &a, &b, &r);
  a /= 2.0;
  b /= 2.0;
  P[idxO = 0] = (point){INF, INF};
  num128 x, y, theta;
  for (int i = 1; i <= n; i++) {
    scanf("%Lf%Lf%Lf", &x, &y, &theta);
    P[++pcnt] = rotate((point){x - (b - r), y + (a - r)}, (point){x, y}, theta);
    idxO = P[pcnt] < P[idxO] ? pcnt : idxO;
    P[++pcnt] = rotate((point){x + (b - r), y + (a - r)}, (point){x, y}, theta);
    idxO = P[pcnt] < P[idxO] ? pcnt : idxO;
    P[++pcnt] = rotate((point){x + (b - r), y - (a - r)}, (point){x, y}, theta);
    idxO = P[pcnt] < P[idxO] ? pcnt : idxO;
    P[++pcnt] = rotate((point){x - (b - r), y - (a - r)}, (point){x, y}, theta);
    idxO = P[pcnt] < P[idxO] ? pcnt : idxO;
  }
  std::swap(P[1], P[idxO]);
}
inline void PrintAns() {
  printf("%.2Lf\n", ans);
}

int main() {
  ReadIn();
  Process();
  PrintAns();
  return 0;
}
// https://www.luogu.com.cn/record/36585561
```

---

## 作者：frankchenfu (赞：5)

这道题目咋一看没什么思路，但是你经过简单的观察之后就会发现，最后要求的凸包就是所有**“圆滑处理”的圆的圆心所围成的凸包长度加上一个完整的圆的周长**。所以接下来要做的事情就比较简单了，就是打一个几何的板子，然后把长方形的四个“圆滑处理”的圆心丢进去跑一个凸包算法，然后就可以在规定时间内出解了！注意最后求完凸包上留下的点之后，算出每两个点之间的长度（直接用勾股定理$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$算），输出即可。

```cpp
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<cmath>
    const double PI=acos(-1);
    const int MAXN=400010;
    
    //FZYZOJ P2092
    
    namespace geometry
    {
        struct Point
        {
            double x,y;
            Point(double x=0,double y=0):x(x),y(y)
            {
            }
        };
        typedef Point Vector;
        
        Vector operator+(Vector a,Vector b)
        {
            return Vector(a.x+b.x,a.y+b.y);
        }
        Vector operator-(Vector a,Vector b)
        {
            return Vector(a.x-b.x,a.y-b.y);
        }
        Vector operator*(Vector a,double p)
        {
            return    Vector(a.x*p,a.y*p);
        }
        Vector operator/(Vector a,double p)
        {
            return Vector(a.x/p,a.y/p);
        }
        
        bool operator<(const Point &a,const Point &b)
        {
            return a.x<b.x||(a.x==b.x&&a.y<b.y);
        }
        const double eps=1e-10;
        int dcmp(double x)
        {
            if(fabs(x)<eps)
                return 0;
            else
                return x<0?-1:1;
        }
        bool operator==(const Point &a,const Point &b)
        {
            return (!dcmp(a.x-b.x))&&(!dcmp(a.y-b.y));
        }
        
        double dot(Vector a,Vector b)
        {
            return a.x*b.x+a.y*b.y;
        }
        double length(Vector a)//Vector
        {
            return sqrt(dot(a,a));
        }
        double angle(Vector a,Vector b)
        {
            return acos(dot(a,b)/length(a)/length(b));
        }
        
        double cross(Vector a,Vector b)
        {
            return a.x*b.y-a.y*b.x;
        }
        double area_2(Point a,Point b,Point c)
        {
            return cross(b-a,c-a);
        }
        double length(Point a,Point b)//2 points
        {
            return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
        }
        
        Vector rotate(Vector a,double rad)
        {
            return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
        }
        Vector normal(Vector a)
        {
            double l=length(a);
            return Vector(-a.y/l,a.x/l);
        }
        
        int ConvexHull(int siz,Point p[],Point ans[])
        {
            std::sort(p+0,p+siz);int tp=0;
            for(int i=0;i<siz;i++)
            {
                while(tp>1&&cross(ans[tp-1]-ans[tp-2],p[i]-ans[tp-2])<=0)
                    tp--;
                ans[tp++]=p[i];
            }
            int k=tp;
            for(int i=siz-2;i>=0;i--)
            {
                while(tp>k&&cross(ans[tp-1]-ans[tp-2],p[i]-ans[tp-2])<=0)
                    tp--;
                ans[tp++]=p[i];
            }
            if(siz>1)
                tp--;
            return tp;
        }
    }
    using namespace geometry;
    int n;double a,b,r,d;
    Point p[MAXN],ans[MAXN];
    
    int main()
    {
        freopen("card.in","r",stdin);
        freopen("card.out","w",stdout);
        scanf("%d%lf%lf%lf",&n,&a,&b,&r);
        d=r*2;a-=d;b-=d;
        for(int i=0;i<n;i++)
        {
            double x,y,th;scanf("%lf%lf%lf",&x,&y,&th);
            p[i<<2|0]=rotate(Vector(b/2,a/2),th)+Vector(x,y);
            p[i<<2|1]=rotate(Vector(-b/2,a/2),th)+Vector(x,y);
            p[i<<2|2]=rotate(Vector(-b/2,-a/2),th)+Vector(x,y);
            p[i<<2|3]=rotate(Vector(b/2,-a/2),th)+Vector(x,y);
        }
        int sz=ConvexHull(n<<2,p,ans);
        double f_ans=d*PI;
        for(int i=1;i<sz;i++)
            f_ans+=length(ans[i],ans[i-1]);
        printf("%.2lf\n",f_ans+length(ans[sz-1],ans[0]));
        return 0;
    }
```

---

## 作者：yaoxiangyuan (赞：2)

**1.题意**

给一些相同的信用卡，本质上是圆，求以所有信用卡的圆心为点集，求这个点集的凸包的周长。

**2.思路**

基础计算几何题，和 [poj1113](http://poj.org/problem?id=1113) 非常相近，不会凸包或者计算几何的，去看[这道模板题](https://www.luogu.com.cn/problem/P2742)，或者看看[这个网站](https://oi-wiki.org//geometry/)的讲解。

事实上，如果信用卡是矩形，那么直接可以把矩形的所有点抽出来，跑一个凸包算法即可。这道题的难点在于信用卡是圆，而我们取出的点就有可能是一个 $\frac{1}{4}$ 圆了，也就无法正常使用凸包算法了。

说白了，我们要求出形如下图的围住的线的长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/2zrxv29c.png)

观察上图，容易发现，所有圆与线重合的部位就是这个圆的切线；

而我们已知，圆的切线垂直于过其切点的半径;

观察每一个圆，发现重要的规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/of82bzeo.png)

正如上图所示，$\alpha$ 为圆心角，因为切线垂直，发现一个对角互补四边形；

而 $\beta$ ,恰好是外角，所以 $\alpha = \beta$；

又因为多边形的外角和是 ${360}^{\circ}$，所以 $\beta$ 加起来就是 ${360}^{\circ}$；

所以，$\alpha$ 加起来也是 ${360}^{\circ}$。

整个图中，所有圆都是相等的，所以，我们可以看出，所有圆连接切线而构成的扇形拼在一起就是整整一个圆。

所以问题就解决了一半，圆弧的总长就是 $2 \pi r$。

剩下的问题就是，求一下所有直边的长度。

如下图，

![](https://cdn.luogu.com.cn/upload/image_hosting/ra81fsou.png)

根据矩形平移，每一条直边都可以平移到至红色的多边形，我们非常容易地得出，所有圆心点求一个凸包就是所有直边的长度。

直边长加上圆的周长，即为答案，至此，本题做完，[AC](https://www.luogu.com.cn/record/74967148)!

**3.代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tx[]={1,1,-1,-1},ty[]={1,-1,1,-1},cnt,stk[100005],top;
bool vis[100005];
double a,b,r,xx,yy,zz,res;
pair<double,double> q[100005];
pair<double,double> rotate(pair<double,double> a,double b){
	return {a.first*cos(b)+a.second*sin(b),-a.first*sin(b)+a.second*cos(b)};
}
pair<double,double> operator-(pair<double,double> a,pair<double,double> b){
    return {a.first-b.first,a.second-b.second};
}
double cross(pair<double,double> a,pair<double,double> b){
	return a.first*b.second-a.second*b.first;
}
double area(pair<double,double> a,pair<double,double> b,pair<double,double> c){
    return cross(b-a,c-a);
}
double get_dist(pair<double,double> a,pair<double,double> b){
	double dx=a.first-b.first,dy=a.second-b.second;
    return sqrt(dx*dx+dy*dy);
}
int main(){
	scanf("%d%lf%lf%lf",&n,&a,&b,&r);
	a=a/2-r;
	b=b/2-r;
	for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf",&xx,&yy,&zz);
		for(int i=0;i<4;i++){
			pair<double,double> temp=rotate({tx[i]*b,ty[i]*a},-zz);
			q[cnt++]={temp.first+xx,temp.second+yy};
		}
	}
	sort(q,q+cnt);
	for(int i=0;i<cnt;i++){
		while(top>=2&&area(q[stk[top-1]],q[stk[top]],q[i])>=0){
			vis[stk[top--]]=0;
		}
		stk[++top]=i;
		vis[i]=1;
	}
	vis[0]=0;
	for(int i=cnt-1;i>=0;i--){
		if(vis[i]){
			continue;
		}
		while(top>=2&&area(q[stk[top-1]],q[stk[top]],q[i])>=0){
			top--;
		}
		stk[++top]=i;
	}
	for(int i=2;i<=top;i++){
		res+=get_dist(q[stk[i-1]],q[stk[i]]);
	}
	printf("%.2lf",res+2*3.141592653589793*r);
	return 0;
}
```


---

## 作者：Martian148 (赞：2)

# Link
[P3829 [SHOI2012]信用卡凸包](https://www.luogu.com.cn/problem/P3829)
# Solve
话说这道题挺良心的，算法在题目上都写出来了，我们就从凸包来考虑。

我们发现有圆的地方很难处理，画了几个图后发现，相比之下，圆的地方加起来就是一个整圆，问题是怎么来证明。

这里借用一下神仙jun头吉吉的图

![](https://s1.ax1x.com/2020/08/21/dtKnHK.png)

我们观察到多出来的部分和圆肯定是相切的，比如$DK$切与圆$C$，所以$∠BCD+∠BZD=180°$ 

多边形内角和为$\sum\limits_{i=1}^n\alpha_i=180\times (n-2)$ 

所以所有圆心角之和为$180 \times n - \sum\limits_{i=1}^n\alpha_i =180 \times n -180 \times (n-2) = 360 = 2pi $

答案即为一个圆的周长+圆心构成的凸包的周长。

所以这道题就和板子一样了

# code 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int n,top,m;
double ans=0,A,B,R,l,phi;
struct AS{
	double x,y;
}a[maxn],p[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
double check(AS A1,AS A2,AS B1,AS B2){
	return (A2.x-A1.x)*(B2.y-B1.y)-(B2.x-B1.x)*(A2.y-A1.y);
}
double d(AS A,AS B){
	return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));
}
bool cmp(AS x,AS y){
	double tmp=check(a[1],x,a[1],y);
	if(tmp>0)return 1;
	if(tmp==0&&(d(a[1],x)<d(a[1],y)))return 1;
	return 0;
}
void add(double x,double y){
	n++;	
	a[n].x=x;a[n].y=y;
	if(a[n].y<a[1].y)swap(a[1],a[n]);
}
int main(){
	freopen("P3829.in","r",stdin);
	freopen("P3829.out","w",stdout);
	scanf("%d%lf%lf%lf",&m,&A,&B,&R);A-=2*R;B-=2*R;
	l=sqrt(A*A+B*B)/2;
	phi=atan(A/B);
	for(int i=1;i<=m;i++){
		double x,y,theta;
		scanf("%lf%lf%lf",&x,&y,&theta);
		double dx=cos(theta+phi)*l;
		double dy=sin(theta+phi)*l;
		add(x+dx,y+dy);
		add(x-dx,y-dy);
		dx=cos(theta-phi)*l;
		dy=sin(theta-phi)*l;
		add(x+dx,y+dy);
		add(x-dx,y-dy);
	}
	sort(a+2,a+1+n,cmp);
	p[top=1]=a[1];
	for(int i=2;i<=n;i++){
		while(top>1&&check(p[top-1],p[top],p[top],a[i])<=0)top--;
		top++;
		p[top]=a[i];
	}
	p[++top]=p[1];
	for(int i=1;i<top;i++){
		ans+=d(p[i],p[i+1]);
	}
	printf("%.2lf\n",ans+3.141592653589793*2*R);
	return 0;
}
```

---

## 作者：pengyule (赞：1)

凸包模板变式。

首先确定主语——是信用卡的角角。但我们还不能确定到底是哪一部分。

先粗略地看一下，假如把角角抽象成一个点（共 $4n$ 个），则凸包应该是每个内角都 $\in[\pi/2,\pi]$。原因在于，如果是锐角则矛盾（不可能出现这种情况，可以自己比划一下，证略）。

观察发现，凸包周长由线段和圆弧构成。考虑先处理线段。

观察凸包上两个相邻的角角。考虑线段不凹于圆弧的法则是何——发现线段须与两圆相切。由于非锐角，前后两个角角和当前圆弧的切线段不会交叉，切点分开。

![image.png](https://www.z4请更换图床a.net/images/2022/01/26/image.png)

根据上图，可以知道线段的长度等于两圆心的距离。据此，我们已经解决直线部分。

考虑圆弧：

![image8ca559b7a30053d7.png](https://www.z4请更换图床a.net/images/2022/01/26/image8ca559b7a30053d7.png)

记前一个圆心、当前圆心、下一个圆心为 $A,B,C$，想求出 $\angle ABC=\alpha$ 的大小。

![image55a4bffacca4f80b.png](https://www.z4请更换图床a.net/images/2022/01/26/image55a4bffacca4f80b.png)

则 $\beta=\pi-\alpha$，弧长 $l=\beta r$。

核心部分解决完毕，现在考虑如何表示各圆心位置（初中几何知识）。

![image3b1b5003348d2891.png](https://www.z4请更换图床a.net/images/2022/01/26/image3b1b5003348d2891.png)

不难想到，上图结论对不同的 $\theta$ 恒成立。

Code:

```cpp
#include <bits/stdc++.h>
#define sq(a) (a)*(a)
using namespace std;
const int N=4e4+5;
const double PI=acos(-1);
int n,tot,tp,stk[N],h[N];
double A,B,C,R,f;
struct P{double x,y;}a[N];
bool operator<(P a,P b){return a.x==b.x?a.y<b.y:a.x<b.x;}
bool operator==(P a,P b){return a.x==b.x&&a.y==b.y;}
P operator-(P a,P b){return (P){a.x-b.x,a.y-b.y};}
double operator*(P a,P b){return a.x*b.y-a.y*b.x;}
double ang(P a,P b,P c){
	double t=(a.y==b.y?PI/2:atan((a.x-b.x)/(a.y-b.y)))-(c.y==b.y?PI/2:atan((c.x-b.x)/(c.y-b.y)));
	if(t<0)t+=PI;
	if(t*2<PI)t=PI-t;
	return t;
}
int main(){
	scanf("%d%lf%lf%lf",&n,&A,&B,&R);
	C=sqrt(sq(A/2-R)+sq(B/2-R));
	f=atan((A/2-R)/(B/2-R));
	for(int i=1;i<=n;i++){
		double x,y,e;
		scanf("%lf%lf%lf",&x,&y,&e);
		a[++tot]={x+cos(e+f)*C,y+sin(e+f)*C};
		a[++tot]={x+cos(f-e)*C,y-sin(f-e)*C};
		a[++tot]={x-cos(e+f)*C,y-sin(e+f)*C};
		a[++tot]={x-cos(f-e)*C,y+sin(f-e)*C};
	}
	sort(a+1,a+tot+1),tot=unique(a+1,a+tot+1)-a-1;
	stk[++tp]=1;
	for(int i=2;i<=tot;i++){
		while(tp>1&&(a[stk[tp]]-a[stk[tp-1]])*(a[i]-a[stk[tp]])<0)tp--;
		stk[++tp]=i;
	}
	for(int i=1;i<=tp;i++)h[i]=stk[i];
	int tmp=tp;
	stk[tp=1]=tot;
	for(int i=tot-1;i;i--){
		while(tp>1&&(a[stk[tp]]-a[stk[tp-1]])*(a[i]-a[stk[tp]])<0)tp--;
		stk[++tp]=i;
	}
	for(int i=1;i<=tp;i++)h[i+tmp-1]=stk[i];
	int m=tp+tmp-2;double ans=0;
	h[0]=h[m];
	for(int i=1;i<=m;i++){
		ans+=sqrt(sq(a[h[i]].x-a[h[i+1]].x)+sq(a[h[i]].y-a[h[i+1]].y));
		ans+=R*(PI-ang(a[h[i-1]],a[h[i]],a[h[i+1]]));
	}
	printf("%.2f\n",ans);
}
//本题不加 EPS 可过，但建议加上
```

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P3829)

## 前置

二维凸包。

## 题意

- 给定 $n$ 个**相同规格的圆角矩形**，求其凸包周长。

## 二维凸包

分析题目，我们可以发现那个**矩形**对凸包并没有什么特殊性质。（（（

那么**矩形**是干什么的呢？

让你方便得到**每个圆圆心坐标**呗。（

那么你首先求出 $4n$ 个圆心坐标。

---

考虑一下**圆**。

它是个很美好的图形。（

**相同规格**好评!（

![](https://cdn.luogu.com.cn/upload/image_hosting/0j8wuefv.png)

（~~哦我奇丑无比的图~~）

一个凸包（红色部分）是这样的，它是**凸**的。（显然）（（（

圆弧部分刚好是一个**整圆**！（下证）

那么我们可以把它缩一下。（

（蓝色部分）

哦！这就是多点求凸包。qaqaqaq

这个套板子即可。

---

我们来证一下为什么圆弧部分是一个**完整的圆**。

因为圆是等圆，那么可以得蓝色部分即为红色部分的线段收拢而成。

其收拢成一个凸多边形。

凸多边形外角和为 $360^\circ$ ，那么圆即为一个完整的圆。

QEDqwq。

---

那么你把上面那些都合起来即可awa。

[$\texttt{代码qwq}$](https://www.luogu.com.cn/paste/uqmbwh9t)

---

## 作者：_Flame_ (赞：0)

## 思路

二维凸包的模板题。

观察题目可知，整个凸包的周长分为弧线与直线两个部分，直线部分很好处理，就是把每个圆弧的圆心坐标用点向式求出，然后跑一边二维凸包模板即可，具体见 [二维凸包模板](https://www.luogu.com.cn/problem/P2742)。

然后是弧线部分，观察一下样例，我们能发现有两种情况，第一种是半径为零，这种情况就相当于一个普通的凸包，跑板子直接输出就行。第二种半径不为零，此时由于凸包都是凸多边形，容易推出所有圆心角的和为三百六十度，在原来的答案上加上一个圆的周长即可。

## Code

```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int maxn=100001;
const double eps=1e-8;
const double pi=acos(-1);

struct node{
    double x,y;
}a[maxn],sta[maxn];

int n;
int tot,tot1;
int vis[maxn];
double ans,h,l,r,xx,yy,th;

double dis(node a,node b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double check(node a,node b,node p){
    return (b.x-a.x)*(p.y-a.y)-(b.y-a.y)*(p.x-a.x);
}

bool cmp(node a,node b){
    if(a.x==b.x) return a.y<b.y;
    else return a.x<b.x;
}

void init(){
	cin>>n;
	cin>>l>>h>>r;
    for(int i=1;i<=n;i++){
        cin>>xx>>yy>>th;
        a[++tot1].x=(h/2-r)*cos(th)-(l/2-r)*sin(th)+xx;
        a[tot1].y=(l/2-r)*cos(th)+(h/2-r)*sin(th)+yy;
        
        a[++tot1].x=-(h/2-r)*cos(th)-(l/2-r)*sin(th)+xx;
        a[tot1].y=(l/2-r)*cos(th)-(h/2-r)*sin(th)+yy;
        
        a[++tot1].x=(h/2-r)*cos(th)+(l/2-r)*sin(th)+xx;
        a[tot1].y=-(l/2-r)*cos(th)+(h/2-r)*sin(th)+yy;
        
        a[++tot1].x=-(h/2-r)*cos(th)+(l/2-r)*sin(th)+xx;
        a[tot1].y=-(l/2-r)*cos(th)-(h/2-r)*sin(th)+yy;
    }
    n=tot1;
}


signed main(){
	init();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(i==1){
			sta[i]=a[i];
			tot++;
		}
		while(tot>1&&check(sta[tot-1],sta[tot],a[i])>=0){
			tot--;
		}
		sta[++tot]=a[i];
	}
	for(int i=2;i<=tot;i++){
		ans+=dis(sta[i-1],sta[i]);
	}
	tot=0;
	for(int i=n;i>=1;i--){
		while(tot>1&&check(sta[tot-1],sta[tot],a[i])>=0){
			tot--;
		}
		sta[++tot]=a[i];
	}
	for(int i=2;i<=tot;i++){
		ans+=dis(sta[i-1],sta[i]);
	} 
	if(r==0){
		printf("%.2lf",ans);
		return 0;
	}
	else{
		double cnt=pi*2*r;
		printf("%.2lf",ans+cnt);
		return 0;
	}
}
```


---


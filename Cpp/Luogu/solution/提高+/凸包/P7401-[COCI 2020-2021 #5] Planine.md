# [COCI 2020/2021 #5] Planine

## 题目描述

现有一座上下起伏的山。它可以抽象为一个包含 $n$（$n$ 为奇数）个点 $(x_i,y_i)$ 以及 $(x_1,-\inf)$ 与 $(x_n,-\inf)$ 的多边形。

对于所有满足 $i \neq 1$，$i \neq n$，$i \bmod 2=1$ 的整数 $i$，$(x_i,y_i)$ 都是山谷。

现要放置若干个高度为 $h$ 的点光源，使得所有的山谷都被照亮，即点光源与山谷的连线不经过山的内部。

求所需点光源的最少数量。

## 说明/提示

#### 样例 1 图解

![](https://cdn.luogu.com.cn/upload/image_hosting/6u2zqy65.png)

#### 样例 2 图解

![](https://cdn.luogu.com.cn/upload/image_hosting/e3mn6dt6.png)

#### 数据规模与约定

**本题采用捆绑测试**。

|Subtask|分值|数据范围及约定|
| :----------: | :----------: | :----------: |
|$1$|$20$|$y_2=y_4=\cdots=y_{n-1}$|
|$2$|$30$|$3 \le n \lt 2000$|
|$3$|$60$|无|

对于 $100\%$ 的数据，$3 \le n \lt 10^6$，$n \bmod 2=1$，$1 \le h \le 10^6$，$-10^6 \le x_i \le 10^6$，$0 \le y_i \lt h$，$x_1 \lt x_2 \lt \cdots \lt x_n$，$y_1 \lt y_2,y_2 \gt y_3,y_3 \lt y_4,\cdots,y_{n-1} \gt y_n$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T4 Planine_。**

## 样例 #1

### 输入

```
9 6
0 0
1 2
3 0
6 3
8 1
9 2
11 1
12 4
14 0```

### 输出

```
1```

## 样例 #2

### 输入

```
9 5
-5 2
-4 3
-2 1
0 4
2 2
3 3
4 1
5 2
6 1```

### 输出

```
2```

# 题解

## 作者：入户功夫 (赞：12)

注意到对于每一个山谷，都在上方有一条线段内的位置可以照亮它。

首先不考虑山之间互相有遮挡的情况（subtask 1）。利用初中知识可以很容易算出来对于每个山谷，上方能够照亮它的线段的左右端点。然后就变成了经典的区间覆盖问题：

给定若干线段，用最少的点将其覆盖使得每条线段上至少有一个点。

区间的右端点作为第一关键字从小到大，左端点作为第二关键字从大到小排序。如果再不覆盖就来不及了，盖一个点。

![图例1.png](https://i.loli.net/2021/10/28/3LG7hrJSHDazNWg.png)

接下来考虑有相互遮挡的情况

![图例2.png](https://i.loli.net/2021/10/28/Up1kaZisVPKENJ5.png)

很显然的，左面能遮挡住一个山谷的点一定是它及左侧所有点构成的上凸包的倒数第二个（它本身是倒数第一个）。

![图例3.png](https://i.loli.net/2021/10/28/ziyUtqYSxZHBk7m.png)

用单调栈 $O(n)$ 维护凸包，就能找到每个山谷对应线段的左端点。再倒着跑一遍就能找到右端点。接下来做线段覆盖。

时间复杂度瓶颈在于线段的排序，$O(n logn)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;double h;
double x[1000006],y[1000006];
int anss=0;

int stck[1000006],top;
double l[1000006],r[1000006];
inline double slope(int j,int k)
{
	return (y[j]-y[k])/(x[j]-x[k]);
}
inline void init()
{
	stck[top=1]=1;
	for(int i=2;i<=n;i++)
	{
		while(top>1&&slope(stck[top],stck[top-1])<slope(i,stck[top])) top--;
		if(i%2) l[i]=x[stck[top]]-(x[i]-x[stck[top]])/(y[stck[top]]-y[i])*(h-y[stck[top]]);
		stck[++top]=i;
	}
	stck[top=1]=n;
	for(int i=n-1;i;i--)
	{
		while(top>1&&slope(stck[top-1],stck[top])>slope(stck[top],i)) top--;
		if(i%2) r[i]=x[stck[top]]+(x[stck[top]]-x[i])/(y[stck[top]]-y[i])*(h-y[stck[top]]);
		stck[++top]=i;
	}
}

struct nod{
	double l,r;
	const bool operator <(const nod &tmp)const{if(r!=tmp.r)return r<tmp.r;return l>tmp.l;}
}e[1000006];int m=0;

int main()
{
	cin>>n>>h;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
	init();
	for(int i=3;i<n;i++) if(i%2) e[++m]={l[i],r[i]};
	sort(e+1,e+1+m);
	
	double lst=-1e18;
	for(int i=1;i<=m;i++)
	{
		if(lst<e[i].l) anss++,lst=e[i].r;
	}
	
	cout<<anss<<'\n';
	return 0;
}
```

---

## 作者：Figo17 (赞：7)

# P7401 [COCI2020-2021#5] Planine 题解

建议不懂斜优的OIER先[看看这里](https://www.cnblogs.com/Xing-Ling/p/11210179.html)（虽然下面也会讲，但我太蒻了）。

## 题目大意

若干山峰和山谷，且最高不超过 $h$，求在直线 $y=h$ 上放置最少光源，使得每个山谷可以被照亮。

## 初步思考

![图1](https://cdn.luogu.com.cn/upload/image_hosting/rsh20m6x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

对于上图，有一个显然的做法，就是把该点向 $y=h$ 上连线，可以得到一个能够照亮该点的光源范围区间。

先不考虑其他特殊情况，我们可以得到这样的若干个区间：

![图2](https://cdn.luogu.com.cn/upload/image_hosting/ufxfasoh.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

现在问题就转化为一个经典的贪心问题，对于给定线段，用最少点将其全部“覆盖”。（请读者自行思考~~其实是口糊~~）

## 然后……？

显然你会获得20分的好成绩。

我们看一下下面的栗子：

![图3](https://cdn.luogu.com.cn/upload/image_hosting/aomh7eki.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

你被山峰挡住了！（~~暴力比较30分之后默默慨叹自己的无能并走掉~~）

## 斜率优化

我们将这些区间分成左、右端点分别计算。

首先看看左端点。

![图4](https://cdn.luogu.com.cn/upload/image_hosting/0n6hlgb1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

你会发现挡住 P 点的只可能是与它连线**斜率最小**的那个山峰。

这就引入斜优了。

你会发现无论下一个山谷在哪里，都不会被 B 点所挡住。

这意味着什么？

这意味着我们可以嗯嗯啊啊一下把原本 $O(n)$ 的比较复杂度降掉。

举个形式化的栗子：

![图5](https://cdn.luogu.com.cn/upload/image_hosting/neudey9a.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

由 E 和 G 连接成的直线，斜率大于直线 EF，这决定了如果考虑 F 对应的状态为最优解，由 G 或 E 所对应的状态是肯定优于 F 的。（可以结合这道题详细理解一下）。

所以点 F 所对应的状态是可以删去的。

当然以此类推点 E 也可以删去。

最后维护出来的山峰大概是酱紫：

![图6](https://cdn.luogu.com.cn/upload/image_hosting/ruecuk7t.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

图中红色是被踢掉的东东，绿色是红色状态被踢完了之后新的东东，你会发现这是个类似“半凸包”的玩意。

搁这差不多了。

实在不行手模一下嘛。

## Code

这里用栈维护。

注意维护栈里的最后一座山峰不会挡住当前的山谷（看看上图），因此还是要回搜一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,h,tot,top;

struct poi{
	int x;int y;
}a[1000006],s[1000006];//a原始峰和谷   s即stack
void Push(int x){s[++top]=(poi){a[x].x,a[x].y};}
double K(poi x,poi y){return 1.0*(x.y-y.y)/(x.x-y.x);}//求两点间斜率 

struct node{
	double l;double r;
}v[1000006];//可以覆盖该点的区间 
bool cmp(node x,node y){return x.r<y.r;}

int main()
{
	scanf("%d%d",&n,&h);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
	
	if(n==3){cout<<0;return 0;}//特判 

	for(int i=2;i<n;i++)
		if(i&1)//山谷 
		{
			double kk=1e9;
			for(int j=top;j>=1;j--){//寻找可以遮挡的山峰
				double k1=K(a[i],s[j]);
				if(k1<kk) kk=k1;
				else break;
			}
			v[i/2].l=(double)(h-a[i].y)/kk+a[i].x;
		}
		else//山峰 
		{
			if(!top) {Push(i);continue;}
			if(top==1){
				if(a[i].y>=s[top].y) top--;//显然可以踢掉 
				Push(i);continue;
			}
			double k1,k2;
			while(top>=2){//不断踢掉直到只剩一个 
				k1=K(a[i],s[top]); k2=K(a[i],s[top-1]); top--;
				if(k1<k2) {top++;break;}//多踢了
			}
			Push(i);
		}
		
	top=0;
	
	for(int i=n-1;i>=2;i--)//倒着来一遍 
		if(i&1)
		{
			double kk=-1e9;
			for(int j=top;j>=1;j--){
				double k1=K(a[i],s[j]);
				if(k1>kk) kk=k1;
				else break;
			}
			v[i/2].r=(double)(h-a[i].y)/kk+a[i].x;
		}
		else
		{
			if(!top) {Push(i);continue;}
			if(top==1){
				if(a[i].y>=s[top].y) top--;
				Push(i);continue;
			}
			double k1,k2;
			while(top>=2){	
				k1=K(s[top],a[i]); k2=K(s[top-1],a[i]);	top--;
				if(k1>=k2) {top++;break;}
			}
			Push(i);
		}

	tot=(n+1)/2-2;
	sort(v+1,v+tot+1,cmp);
	double lstr=-1e9;//lst r
	for(int i=1;i<=tot;i++) if(v[i].l>lstr) ans++,lstr=v[i].r;
	cout<<ans<<endl;
	return （0-0）;//不知道哪学的卖萌
}
```

蟹蟹。




---

## 作者：JimmyLee (赞：1)

# 题意

> 现有一座上下起伏的山。它可以抽象为一个包含 $n$（$n$ 为奇数）个点 $(x_i,y_i)$ 以及 $(x_1,-\inf)$ 与 $(x_n,-\inf)$ 的多边形。
>
> 对于所有满足 $i \neq 1$，$i \neq n$，$i \bmod 2=1$ 的整数 $i$，$(x_i,y_i)$ 都是山谷。
>
> 现要放置若干个高度为 $h$ 的点光源，使得所有的山谷都被照亮，即点光源与山谷的连线不经过山的内部。
>
> 求所需点光源的最少数量。

# 分析

考虑对每个山谷处理出能照亮它的点集。

比如对于如下山谷：

![](https://cdn.luogu.com.cn/upload/image_hosting/tw90yxgf.png) 

处理出第 $2$ 个山谷能照亮它的点集，显然是一条在直线 $y=h$ 上的线段：

![](https://cdn.luogu.com.cn/upload/image_hosting/3p6q5hr4.png)

对于第 $2$ 个山谷而言，能照亮它的点集只受前后紧邻点的限制。

但是第 $3$ 个山谷就有点区别了：

![](https://cdn.luogu.com.cn/upload/image_hosting/7i84cuxb.png)

我们发现它还受另外的点的限制。

考虑维护一个凸包，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ahm3cbjt.png)

点集所受的限制就是凸包中最后一条边。

所以我们正向扫一遍，维护一个凸包，再反向扫一遍，维护另一个凸包即可。

时间复杂度 $O(n)$。

---

现在我们得到了若干个区间，我们需要选取若干个点，使得每个区间内至少存在一个点，并最小化点的个数。

这是一个比较经典的贪心问题。

考虑按右端点从小到大排序，每次选取右端点最小的区间，并去除所有与该区间相交的区间。

答案即为选取的次数。

正确性显然。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000006
typedef long double f64_t;

struct dot{int x, y;}ds[maxn];
f64_t slope(dot a, dot b) {return (f64_t)(a.y-b.y)/(a.x-b.x);}

struct segement
{
    f64_t l, r;
    segement(f64_t x=0, f64_t y=0): l(x), r(y) {}
    friend bool operator<(segement a, segement b) {return a.r<b.r; }
}seg[maxn];

vector<int> s;
#define chk(x) ((x)!=1&&(x)!=n&&((x)&1))
f64_t back() {return slope(ds[*s.rbegin()], ds[*(s.rbegin()+1)]);}

int main()
{
    int n, h;
    cin>>n>>h;
    for(int i=1;i<=n;i++) cin>>ds[i].x>>ds[i].y;
    for(int i=1;i<=n;i++)
    {
        while(s.size()>1&&back()<=slope(ds[s.back()], ds[i])) 
            s.pop_back();
        s.emplace_back(i);
        if(chk(i)) 
        {
            f64_t k=back();
            f64_t b=ds[i].y-k*ds[i].x;
            seg[i].l=(h-b)/k;
        }
    }
    s.clear();
    for(int i=n;i;i--)
    {
        while(s.size()>1&&back()>=slope(ds[s.back()], ds[i])) 
            s.pop_back();
        s.emplace_back(i);
        if(chk(i)) 
        {
            f64_t k=back();
            f64_t b=ds[i].y-k*ds[i].x;
            seg[i].r=(h-b)/k;
        }
    }
    vector<segement> vc;
    for(int i=3;i<n;i+=2) 
        vc.emplace_back(seg[i]);
    sort(vc.begin(), vc.end());
    f64_t mxr=-1e18;
    int ans=0;
    for(auto [l, r]:vc) 
        if(l-1e-8>mxr) mxr=r, ans++;
    cout<<ans;
}
```

---


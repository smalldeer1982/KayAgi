# 【模板】静态区间半群查询

## 题目描述

给定一个序列 $a_1,a_2,\cdots,a_n$，其中的每个元素都是一个 $2\times2$ 的矩阵。你需要处理 $m$ 次查询，每次查询给定一个区间 $[l,r]$，你需要求出 $\prod_{i=l}^ra_i$，其中 $\times$ 符号代表 $(\min,+)$ 矩阵积。

**注意：本题时限极其宽松，主要作正确性测试使用和不准确的效率对比使用。请不要过分滥用本题评测资源。**

## 说明/提示

**本题采用捆绑测试。**

|Subtask 编号|$n$|$m$|$b$|分值|时限|
|-|-|-|-|-|-|
|0|$10^3$|$10^3$|$0$|$10$|$\texttt{1s}$|
|1|$5\times10^4$|$5\times10^4$|$0$|$10$|$\texttt{1s}$|
|2|$2\times10^5$|$2\times10^5$|$0$|$10$|$\texttt{1s}$|
|3|$10^6$|$2\times10^5$|$0$|$10$|$\texttt{3s}$|
|4|$2\times10^5$|$10^6$|$0$|$20$|$\texttt{3s}$|
|5|$10^6$|$10^6$|$0$|$10$|$\texttt{3s}$|
|6|$10^6$|$10^6$|$n-300$|$10$|$\texttt{3s}$|
|7|$10^6$|$10^6$|$n-500$|$10$|$\texttt{3s}$|
|8|$10^6$|$10^6$|$n-1000$|$10$|$\texttt{3s}$|

对于 $100\%$ 的数据，$1\le n,m\le 10^6$，$0\le b\le n-1$，$0\le sd\le2^{64}-1$，$0\le kv_{i,j}\le2\times10^8$（$0\le i,j\le1$）。

---

样例 1 解释：我们有 $a_1=\begin{pmatrix}202&50\\51&238\end{pmatrix}
$，$a_2=
\begin{pmatrix}167&154\\37&25\end{pmatrix}$，$a_3=\begin{pmatrix}164&145\\208&27\end{pmatrix}$，三组查询分别是 $[1,3]$，$[1,3]$ 和 $[1,2]$。前两组的答案矩阵均为 $\begin{pmatrix}251&102\\382&232\end{pmatrix}
$，而第三组的答案矩阵为 $\begin{pmatrix}87&75\\218&205\end{pmatrix}
$。根据题意模拟计算，最终输出为 $0$。

以下是一份可以得到 $10\%$ 分数的 C++ 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct mat {
  int a[2][2];
  mat() {
    a[0][0] = a[1][1] = 0;
    a[1][0] = a[0][1] = 0x3f3f3f3f;
  }
  mat(int x, int y, int z, int w) {
    a[0][0] = x, a[0][1] = y, a[1][0] = z, a[1][1] = w;
  }
};
mat mul(const mat& x, const mat& y) {
  return {min(x.a[0][0] + y.a[0][0], x.a[0][1] + y.a[1][0]),
          min(x.a[0][0] + y.a[0][1], x.a[0][1] + y.a[1][1]),
          min(x.a[1][0] + y.a[0][0], x.a[1][1] + y.a[1][0]),
          min(x.a[1][0] + y.a[0][1], x.a[1][1] + y.a[1][1])};
}
struct random {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  uint64_t rnd() {
    sd ^= sd << 13, sd ^= sd >> 7;
    return sd ^= sd << 17;
  }
  void init() { cin >> sd >> b, sd = splitmix64(sd); }
  void genmat(mat& res) {
    uint64_t val = rnd();
    for (int i : {0, 1})
      for (int j : {0, 1}) res.a[i][j] = val >> ((i << 1 | j) << 4) & 0xff;
  }
  void genqry(int& l, int& r, int n) {
    if ((rnd() & 1) && b) {
      int c = rnd() % (n - b);
      l = rnd() % (n - c) + 1, r = l + c;
    } else {
      l = rnd() % n + 1, r = rnd() % n + 1;
      if (l > r) swap(l, r);
    }
  }
  uint64_t sd;
  int b;
} rnd;
struct output {
  int ans, kv[2][2];
  void init() {
    for (int i : {0, 1})
      for (int j : {0, 1}) cin >> kv[i][j];
  }
  void setres(mat res) {
    int tmp = 0;
    for (int i : {0, 1})
      for (int j : {0, 1}) tmp += res.a[i][j] ^ kv[i][j];
    ans ^= tmp;
  }
} out;
constexpr int N = 1e6 + 9;
int n, m, ans;
mat a[N];
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> m, rnd.init(), out.init();
  for (int i = 1; i <= n; ++i) rnd.genmat(a[i]);
  // 你可以在这里进行你所需要的初始化。
  for (int l, r; m; --m) {
    rnd.genqry(l, r, n);
    out.setres(accumulate(a + l, a + r + 1, mat(), mul));
    // 你可以把上面这个 accumulate 改成自己的查询函数。
  }
  return cout << out.ans << endl, 0;
}
```

**注意：观察代码可以发现，你实际上可以以任意顺序调用这 $m$ 次 `setres`。**

## 样例 #1

### 输入

```
3 3 13148274 0
87 75 218 205```

### 输出

```
0```

## 样例 #2

### 输入

```
10 10 1145141919810 0
1 0 6 4```

### 输出

```
2028```

## 样例 #3

### 输入

```
200000 1000000 61884 100
5 3 0 7```

### 输出

```
45263464```

# 题解

## 作者：SafariMo (赞：10)

简单的期望 $\mathcal O(n)$ 做法。

首先按序列分块，分 $\sqrt n$ 块。

然后处理 $f_{i ,j}$ 表示 $i , j$ 块间矩阵的积，这个部分是 $\mathcal O(n)$ 的。

对于 $x , y$ 不在同一块的情况，则我们处理散块的前缀，后缀也可以处理：$f_i = a_{i + 1} f_{i + 1}$，时间复杂度 $\mathcal O(1)$。

同一块的情况，则暴力。

在同一块内的概率为 $\dfrac{1}{\sqrt n}$，期望时间复杂度 $\mathcal O(1)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct mat {
  int a[2][2];
  mat() {
    a[0][0] = a[1][1] = 0;
    a[1][0] = a[0][1] = 0x3f3f3f3f;
  }
  mat(int x, int y, int z, int w) {
    a[0][0] = x, a[0][1] = y, a[1][0] = z, a[1][1] = w;
  }
  friend bool operator == (mat x, mat y){
  	return x . a[0][0] == y . a[0][0] && x . a[0][1] == y . a[0][1] && x . a[1][1] == y . a[1][1] && x . a[1][0] == y . a[1][0];
  }
};
mat mul(const mat& x, const mat& y) {
  return {min(x.a[0][0] + y.a[0][0], x.a[0][1] + y.a[1][0]),
          min(x.a[0][0] + y.a[0][1], x.a[0][1] + y.a[1][1]),
          min(x.a[1][0] + y.a[0][0], x.a[1][1] + y.a[1][0]),
          min(x.a[1][0] + y.a[0][1], x.a[1][1] + y.a[1][1])};
}
struct random {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  uint64_t rnd() {
    sd ^= sd << 13, sd ^= sd >> 7;
    return sd ^= sd << 17;
  }
  void init() { cin >> sd >> b, sd = splitmix64(sd); }
  void genmat(mat& res) {
    uint64_t val = rnd();
    for (int i : {0, 1})
      for (int j : {0, 1}) res.a[i][j] = val >> ((i << 1 | j) << 4) & 0xff;
  }
  void genqry(int& l, int& r, int n) {
    if ((rnd() & 1) && b) {
      int c = rnd() % (n - b);
      l = rnd() % (n - c) + 1, r = l + c;
    } else {
      l = rnd() % n + 1, r = rnd() % n + 1;
      if (l > r) swap(l, r);
    }
  }
  uint64_t sd;
  int b;
} rnd;
struct output {
  int ans, kv[2][2];
  void init() {
    for (int i : {0, 1})
      for (int j : {0, 1}) cin >> kv[i][j];
  }
  void setres(mat res) {
    int tmp = 0;
    for (int i : {0, 1})
      for (int j : {0, 1}) tmp += res.a[i][j] ^ kv[i][j];
    ans ^= tmp;
  }
} out;
constexpr int N = 1e6 + 9;
int n, m, ans;
mat a[N] , res[N] , f[2002][2002];
int bl[N];
int tp[N] , ed[N];
mat s[2004][2004];
mat t[2004][2004];
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> m, rnd.init(), out.init();
  const int B = sqrt(n + m);
  for (int i = 1; i <= n; ++i) rnd.genmat(a[i]) , bl[i] = i / B + 1;
  // 你可以在这里进行你所需要的初始化。
  mat p;
  for(int i = 1; i <= n; ++ i){
  	if(res[bl[i]] == p){
  		res[bl[i]] = a[i];
		tp[bl[i]] = i;
		ed[bl[i]] = i + B - 1;
		ed[bl[i]] = min(ed[bl[i]] , n);
	}
	else res[bl[i]] = mul(res[bl[i]] , a[i]); 
  }
  for(int i = 1; i <= n / B + 1; ++ i){
  	f[i][i] = res[i];
  	  for(int j = i + 1; j <= n / B + 1; ++ j)
  	  	f[i][j] = mul(f[i][j - 1] , res[j]);
  }
  vector<int> cnt(B + 2);	 
  mat empty;
  for(int i = 1; i <= n; i ++){
  	cnt[bl[i]] ++; 
	s[bl[i]][cnt[bl[i]]] = mul(s[bl[i]][cnt[bl[i]] - 1] , a[i]);
  }
  for(int i = n; i >= 1; i --){
  	cnt[bl[i]] --; 
  	t[bl[i]][cnt[bl[i]]] = mul(a[i] , t[bl[i]][cnt[bl[i]] + 1]);
  }
  for (int l, r; m; --m) {
    rnd.genqry(l, r, n);
    if(bl[r] == bl[l]){
    	out.setres(accumulate(a + l, a + r + 1, mat(), mul));
    	continue;
	}
	mat ans;
	if(l != tp[bl[l]])  
		ans = t[bl[l]][l - tp[bl[l]]] , l = ed[bl[l]] + 1;
	if(bl[l] == bl[r]){
		out . setres(mul(ans , s[bl[l]][r - tp[bl[l]] + 1]));
		continue;
	}
	int q = r;
	if(q != bl[r]) q = tp[bl[r]] - 1;
	ans = mul(ans , f[bl[l]][bl[q]]);
    if(r != bl[r]) ans = mul(ans ,  s[bl[r]][r - tp[bl[r]] + 1]);
	out.setres(ans);
    // 你可以把上面这个 accumulate 改成自己的查询函数。
  }
  return cout << out.ans << endl, 0;
}
```

---

## 作者：MrPython (赞：8)

题目本身没啥意思，就是维护个矩阵区间乘法，上个线段树做完了。

我更想说说这个标题是啥意思。

**半群**说的是一个集合 $S$ 和一种二元运算 $\circ $。若运算 $\circ$ 满足以下条件：
- $\circ$ 具有封闭性，即 $\forall x,y\in S,x\circ y\in S$
- $\circ$ 满足结合律，即 $\forall x,y,z\in S,(x\circ y)\circ z=x\circ(y\circ z)$
则称 $\left \langle S,\circ \right \rangle $ 为半群。

本题中 $2\times2$ 矩阵和 $(\min,+)$ 矩阵积运算就可以构成半群。

而线段树能维护的信息需要满足**半群**特性。线段树高速处理询问的实质是预处理出部分区间的答案，在查询时将询问区间拆分成若干段已经预处理的部分，然后拼接起来。将两段信息合并就需要其满足结合律。

> 题外话：[ac-library 中的线段树](https://github.com/atcoder/ac-library/blob/master/document_en/segtree.md)中说其维护的线段树需满足幺半群性质。不过，考虑到幺元很容易构造（加一个 bool 变量就可以了），而且[我实现的线段树](https://github.com/Mr-Python-in-China/mp-oi-library/blob/main/library/mrpython/typical_segment_tree.hpp)并不需要幺元（代价是无法查询空区间），因此我说线段树维护的信息只需要半群即可。

```cpp
#include <mrpython/typical_segment_tree.hpp> // see <https://github.com/Mr-Python-in-China/mp-oi-library/blob/main/library/mrpython/typical_segment_tree.hpp>
#include <cstdint>
#include <iostream>
using namespace std;
istream& fin = cin;
ostream& fout = cout;
using ui = unsigned int;
using uli = unsigned long long int;
using li = long long int;
struct mat {
  int m[2][2];
  mat() {
    m[0][0] = m[1][1] = 0;
    m[1][0] = m[0][1] = 0x3f3f3f3f;
  }
  mat(int x, int y, int z, int w) {
    m[0][0] = x, m[0][1] = y, m[1][0] = z, m[1][1] = w;
  }
};
mat operator*(const mat& x, const mat& y) {
  return {min(x.m[0][0] + y.m[0][0], x.m[0][1] + y.m[1][0]),
          min(x.m[0][0] + y.m[0][1], x.m[0][1] + y.m[1][1]),
          min(x.m[1][0] + y.m[0][0], x.m[1][1] + y.m[1][0]),
          min(x.m[1][0] + y.m[0][1], x.m[1][1] + y.m[1][1])};
}
struct random {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  uint64_t rnd() {
    sd ^= sd << 13, sd ^= sd >> 7;
    return sd ^= sd << 17;
  }
  void init() { cin >> sd >> b, sd = splitmix64(sd); }
  void genmat(mat& res) {
    uint64_t val = rnd();
    for (int i : {0, 1})
      for (int j : {0, 1}) res.m[i][j] = val >> ((i << 1 | j) << 4) & 0xff;
  }
  void genqry(int& l, int& r, int n) {
    if ((rnd() & 1) && b) {
      int c = rnd() % (n - b);
      l = rnd() % (n - c) + 1, r = l + c;
    } else {
      l = rnd() % n + 1, r = rnd() % n + 1;
      if (l > r) swap(l, r);
    }
  }
  uint64_t sd;
  int b;
} rnd;
struct output {
  int ans, kv[2][2];
  void init() {
    for (int i : {0, 1})
      for (int j : {0, 1}) cin >> kv[i][j];
  }
  void setres(mat res) {
    int tmp = 0;
    for (int i : {0, 1})
      for (int j : {0, 1}) tmp += res.m[i][j] ^ kv[i][j];
    ans ^= tmp;
  }
} out;
int main(void) {
  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
  size_t n, m;
  fin >> n >> m;
  rnd.init(), out.init();
  auto tree = [&]() {
    vector<mat> a(n);
    for (mat& i : a) rnd.genmat(i);
    return mrpython::typical_segment_tree<mat, multiplies<>>(a.begin(),
                                                             a.end());
  }();
  while (m--) {
    int l, r;
    rnd.genqry(l, r, n);
    --l;
    out.setres(tree.get(l, r));
  }
  fout << out.ans;
  return 0;
}
```

---

## 作者：H_Kaguya (赞：7)

猫树！  

简单来讲，猫树就是，在普通线段树的基础上，每个节点预处理 $\forall i \in [l, mid), [i, mid]$ 和 $\forall i \in (mid, r], [mid + 1, i]$ 的答案。  
这样处理询问 $[L, R]$ 的时候只需要找到满足 $l \le L, r \ge R, mid \in [L, R]$ 的节点，左右 $O(1)$ 合并即可。  
预处理复杂度 $T(n) = 2T(\frac{n}{2}) + O(n) = O(n \log n)$。  

常规的猫树是 $O(n \log n)$ 预处理 $O(1)$ 查询的。  
所以类似四毛子，先按照块长 $B = O(\log n)$ 分块，块间建立猫树，块内预处理前缀和后缀和，然后块内再建猫树。  
$O(n \log \log n)$ 预处理 $O(1)$ 查询，简洁而高效。  
[提交记录1](https://www.luogu.com.cn/record/186909275)  
[提交记录2](https://www.luogu.com.cn/record/186911293)

但实际情况是这个东西都没有 ST 表快......  
$O(\log n)$ 查询的 ST 表......  
[提交记录](https://www.luogu.com.cn/record/186875870)  

所以我们把散块的猫树扬了。  
块间维护猫树，块内查询直接暴力。  
更短了，也更快了。  
[提交记录](https://www.luogu.com.cn/record/186912265)  
只贴核心代码。  
```cpp
constexpr int N = 1 << 20 | 5;
int n, m, p;
mat frt[N], bak[N];
mat a[N];
mat b[16][(N >> 5) + 1];
void init();
void geta(int, int);
signed main()
{
	scanf ("%d%d", &n, &m);
	p = 1 << __lg(n) + 1;
	p = max(p, 32);
	rnd.init(); out.init();
	init();
	for (int l, r; m; --m)
	{
		rnd.genqry(l, r, n);
		geta(l, r);
	}
	printf ("%d\n", out.ans);
	return 0;
}

void init()
{
	for (int i = 1; i <= n; ++i)
		rnd.genmat(a[i]);
	for (int i = 0; i < p; i += 32)
	{
		frt[i] = a[i];
		for (int j = 1; j < 32; ++j)
			frt[i | j] = mul(frt[i | j - 1], a[i | j]);
		bak[i | 31] = a[i | 31];
		for (int j = 30; j >= 0; --j)
			bak[i | j] = mul(a[i | j], bak[i | j + 1]);
	}
	for (int i = 0; i < p; i += 32)
		b[0][i >> 5] = bak[i];
	for (int i = 1; (1 << i) <= (p >> 5); ++i)
	{
		for (int j = 0; j < (p >> 5); )
		{
			int k = j + (1 << i - 1), s = j + (1 << i);
			b[i][k] = b[0][k];
			for (int h = k + 1; h < s; ++h)
				b[i][h] = mul(b[i][h - 1], b[0][h]);
			b[i][k - 1] = b[0][k - 1];
			for (int h = k - 2; h >= j; --h)
				b[i][h] = mul(b[0][h], b[i][h + 1]);
			j = s;
		}
	}
}

void geta(int l, int r)
{
	if ((l >> 5) == (r >> 5))
	{
		mat tmp = a[l];
		for (int i = l + 1; i <= r; ++i)
			tmp = mul(tmp, a[i]);
		out.ot(tmp);
		return;
	}
	mat tmp1 = bak[l], tmp2 = frt[r];
	l = (l >> 5) + 1; r = (r >> 5) - 1;
	if (l == r)
		tmp1 = mul(tmp1, b[0][l]);
	else if (l < r)
	{
		int bit = __lg(l ^ r) + 1;
		tmp1 = mul(tmp1, mul(b[bit][l], b[bit][r]));
	}
	out.ot(mul(tmp1, tmp2));
}
```

---

## 作者：Phartial (赞：5)

来点 u 选科技！

原文：[并查集线段树。](https://www.luogu.com/article/ldd9p8z6)

尝试改造一下 zkw 线段树，我们知道 zkw 线段树的区间查询就是 $l,r$ 同时往上跳，并在这一过程中把包含在 $(l,r)$ 中的信息加入答案（具体的，当 $l$ 是偶数是将其兄弟加入答案，当 $r$ 是奇数时也将其兄弟加入答案）。

得益于堆式存储，我们有几条可以利用的性质：首先，一次查询 $(l,r)$ 中最终 $l,r$ 的位置是固定且可以很快算出的（$l,r$ 的 lca 就是它们在二进制下的 lcp）；并且，$l$ 在向上跳的过程中遇到的每个节点的贡献都是固定的，$r$ 也是如此。于是我们将静态区间半群查询转化成了静态叶子-祖先路径半群查询。

离线后，对 lca 从深到浅做扫描线，可以使用带权并查集维护每个叶子到当前根的半群信息，更新时暴力从儿子往父亲连边即可，并且这个并查集是可以带路径压缩的。

那我缺的按秩合并这块谁给我补啊？实际上你可以发现，因为我们总是把儿子连到父亲上，所以如果我们直接钦定一个点的秩为它的高度，则连边的过程和按秩合并是几乎一样的，于是时间复杂度分析也可以套用。由此我们得到了一个很好写的 $\Theta(n \alpha(n))$ 离线静态区间半群查询。

不知道为啥跑的不快，难过了。

```cpp
using info = pair<mat, mat>;
info mul(const info& x, const info& y) { return {mul(x.first, y.first), mul(y.second, x.second)}; }

constexpr int kN = 1e6 + 2, kL = 21;

int n, m, q, ans, f[kN * 4];
mat a[kN];
info e[kN * 4], vf[kN * 4];
vector<pair<int, int>> rq[kL];

int F(int x) {
  if (!f[x]) {
    return x;
  }
  vf[x] = mul(vf[x], vf[exchange(f[x], F(f[x]))]);
  return f[x];
}

signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> q, rnd.init(), out.init();
  for (int i = 1; i <= n; ++i) rnd.genmat(a[i]);
  m = (1 << __lg(n + 1) + 1);
  auto _e = [](int i) -> mat& { return (i & 1) ? e[i ^ 1].first : e[i ^ 1].second; };
  for (int i = 1; i <= n; ++i) {
    _e(m + i) = a[i];
  }
  for (int i = m - 1; i >= 1; --i) {
    _e(i) = mul(e[i * 2 + 1].second, e[i * 2].first);
  }
  for (int i = 1, l, r; i <= q; ++i) {
    rnd.genqry(l, r, n);
    l += m - 1, r += m + 1;
    rq[__lg(l ^ r)].emplace_back(l, r);
  }
  for (int i = __lg(m); i; --i) {
    for (auto [l, r] : rq[__lg(m) - i]) {
      F(l), F(r);
      out.setres(mul(vf[l].first, vf[r].second));
    }
    for (int j = (1 << i); j < (1 << i + 1); ++j) {
      f[j] = j / 2, vf[j] = e[j];
    }
  }
  return cout << out.ans << endl, 0;
}
```

---

## 作者：zesqwq (赞：5)

一个期望线性做法。

此题 $b$ 的限制好像没有用，因为真实的题面是对 $(n - b)$ 取模，但是 $b$ 的范围只有 $200$。

所以说等价于一个随机区间，然后问区间半群查询。

假设我们将 $B$ 个数分一块，处理出 $f_{l, r}$ 表示从第 $l$ 个块到第 $r$ 个块的信息的积，此部分预处理复杂度 $O(n + \frac {n^2} {B^2})$。

用 $pre_x / suf_x$ 表示 $x$ 到块头 $/$ 块尾的信息积，此部分复杂度 $O(n)$。

假设询问 $[L, R]$，$L$ 在块 $bL$ 中，$R$ 在块 $bR$ 中。

- 如果 $bL \neq bR$ 那么答案就是 $suf_L \times f_{bL + 1, bR - 1} \times pre_R$，时间复杂度 $O(1)$；
- 否则我们直接暴力计算，时间复杂度 $O(B)$。

我们发现我们只有 $O(\frac B n)$ 的概率暴力计算，因此期望只有 $\frac{qB} n$ 的概率要 $O(B)$ 暴力，期望复杂度 $O(\frac{qB^2} n)$。

根号平衡一下，取 $B = \sqrt[4]{\frac{n^3}{q}}$，总的期望复杂度为 $O(\sqrt{qn} + n + q)$。

然后到这里这个题就做完了，已经可以通过这个模板了。

---

接下来考虑一下如果有 $(n - b) \le x$ 的限制，我们令 $k = n - b$，此时我们仍然选择 $B$ 个分一块。

我们发现 $f_{l, r}$ 只用处理 $B(r - l + 1) \le k$ 的 $(l, r)$，即只有 $O(\frac {nk}{B^2})$ 对 $(l, r)$ 需要处理。

我们沿用上面的做法，此时使用暴力的概率是 $O(\frac {B} k)$，因此暴力期望复杂度为 $O(\frac{qB^2}k)$。

根号平衡一下，取 $B = \sqrt[4]{\frac{nk^2}{q}}$，总的期望复杂度为 $O(n + q + \sqrt{qn})$。

---

## 作者：Arghariza (赞：2)

几个均可实现的做法。

比较广为人知的 $O(n\log n)-O(1)$ 做法是猫树分治（二区间合并），即分治函数 $S(l,r)$ 表示处理 $[l,r]$ 之间的所有询问。

具体来说，设 $mid$ 为区间 $[l,r]$ 中点。只需要每次求出 $[l,mid]$ 的后缀信息和 $s_i$ 和 $(mid,r]$ 的前缀信息和 $t_i$，对于每个跨过 $mid$ 的询问 $[L,R]$，通过结合律合并 $s_L$ 和 $t_R$；否则向两侧递归即可。这样做是预处理 $O(n\log n)$、查询 $O(1)$ 的。一般来说做到线性空间需要将询问离线下来，而直接将分治树存下来能做到 $O(n\log n)$ 空间的在线查询。

然后考虑序列分块。每 $\log n$ 个位置分一块。预处理块内的前缀/后缀和，并对所有整块构成的序列做猫树分治，在本题的随机数据下期望是 $O(n)-O(1)$ 的。但是如果询问在整块内部的话单次是 $O(\log n)$ 的。

想要做到更快的话，可以将在一个整块内部的询问继续猫树分治下去。这样做的话在计算机的数据范围内可以认为是 $O(n)-O(1)$ 的。

另一个可能更好写的随机数据期望 $O(n)-O(1)$ 做法（这里我们认为 $n,m$ 同阶）：

还是考虑序列分块。每 $\sqrt n$ 个位置分一块。预处理块内的前缀/后缀和，以及任意两个整块之间所有块的信息和。查询跨过至少一个块的情况直接 $O(1)$，否则 $O(\sqrt n)$ 暴力。

由于询问区间在一个整块内部的概率为 $\frac{\sqrt n}{n}$，于是暴力做的期望复杂度是 $O(n)$ 的。

由于我是懒狗，只写了猫树分治的做法：

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
#define mp make_pair
#define fi first
#define se second
#define F(i, x, y) for (int i = (x); i <= (y); i++)
#define R(i, x, y) for (int i = (x); i >= (y); i--)
#define FIO(FILE) freopen(FILE".in", "r", stdin), freopen(FILE".out", "w", stdout)

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
bool Mbe;

struct mat {
    int a[2][2];
    mat() {
        a[0][0] = a[1][1] = 0;
        a[1][0] = a[0][1] = 0x3f3f3f3f;
    }
    mat(int x, int y, int z, int w) {
        a[0][0] = x, a[0][1] = y, a[1][0] = z, a[1][1] = w;
    }
};

mat mul(const mat& x, const mat& y) {
    return {min(x.a[0][0] + y.a[0][0], x.a[0][1] + y.a[1][0]),
                    min(x.a[0][0] + y.a[0][1], x.a[0][1] + y.a[1][1]),
                    min(x.a[1][0] + y.a[0][0], x.a[1][1] + y.a[1][0]),
                    min(x.a[1][0] + y.a[0][1], x.a[1][1] + y.a[1][1])};
}

mat operator * (const mat &x, const mat &y) {
	return mul(x, y);
}

struct random {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    uint64_t rnd() {
        sd ^= sd << 13, sd ^= sd >> 7;
        return sd ^= sd << 17;
    }
    void init() { cin >> sd >> b, sd = splitmix64(sd); }
    void genmat(mat& res) {
        uint64_t val = rnd();
        for (int i : {0, 1})
            for (int j : {0, 1}) res.a[i][j] = val >> ((i << 1 | j) << 4) & 0xff;
    }
    void genqry(int& l, int& r, int n) {
        if ((rnd() & 1) && b) {
            int c = rnd() % (n - b);
            l = rnd() % (n - c) + 1, r = l + c;
        } else {
            l = rnd() % n + 1, r = rnd() % n + 1;
            if (l > r) swap(l, r);
        }
    }
    uint64_t sd;
    int b;
} rnd;

struct output {
    int ans, kv[2][2];
    void init() {
        for (int i : {0, 1})
            for (int j : {0, 1}) cin >> kv[i][j];
    }
    void setres(mat res) {
        int tmp = 0;
        for (int i : {0, 1})
            for (int j : {0, 1}) tmp += res.a[i][j] ^ kv[i][j];
        ans ^= tmp;
    }
} out;

constexpr int N = 1e6 + 9;

int n, m;
mat a[N];

namespace CatTree {
	
	struct Q {
		
		int l, r, i;
	
		Q () { }
		Q (int _l, int _r, int _i) : l(_l), r(_r), i(_i) { }
		
	};
	
	vector<Q> q;
	mat pr[N], sf[N], ans[N];
	
	void conq(int l, int r, vector<Q> q) {
		if (l == r) {
			for (Q p : q) {
				ans[p.i] = a[l];
			}
			return;
		}
		int mid = (l + r) >> 1;
		sf[mid] = a[mid];
		pr[mid + 1] = a[mid + 1];
		R (i, mid - 1, l) {
			sf[i] = a[i] * sf[i + 1];
		}
		F (i, mid + 2, r) {
			pr[i] = pr[i - 1] * a[i];
		}
		vector<Q> ql, qr;
		for (Q p : q) {
			int L = p.l, R = p.r, i = p.i;
			if (L <= mid && mid < R) {
				ans[i] = sf[L] * pr[R];
			} else if (L > mid) {
				qr.eb(p);
			} else {
				ql.eb(p);
			}
		}
		conq(l, mid, ql);
		conq(mid + 1, r, qr);
	}
	
	void i(int l, int r, int id) {
		q.eb(Q(l, r, id));
	}
	
	void c() {
		conq(1, n, q);
	}
	
}

void solve() {
    cin >> n >> m, rnd.init(), out.init();
    for (int i = 1; i <= n; ++i) rnd.genmat(a[i]);
    
    for (int l, r, i = 1; i <= m; i++) {
        rnd.genqry(l, r, n);
        CatTree::i(l, r, i);
        // out.setres(accumulate(a + l, a + r + 1, mat(), mul));    
    }
    CatTree::c();
    F (i, 1, m) {
    	out.setres(CatTree::ans[i]);
    }
    cout << out.ans << endl;
}

bool Med;
int main() {
	// FIO("");
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
	int T = 1;
	// cin >> T;
	while (T--) solve();
	cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
	return 0;
}
```

---

## 作者：ppip (赞：2)

[前置阅读](/article/17oauh4s)

总之显然可以线段树，然后目前这种写法是线段树里最快的。

说不定也是不依赖数据随机的做法里最快的，这题合并信息的代价还是太小，体现不出更优复杂度的优势。

代码就是拿提供的模板改的，直接看主函数就行。

复杂度 $O(n+q\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct mat {
	int a[2][2];
	mat() {
		a[0][0] = a[1][1] = 0;
		a[1][0] = a[0][1] = 0x3f3f3f3f;
	}
	mat(int x, int y, int z, int w) {
		a[0][0] = x, a[0][1] = y, a[1][0] = z, a[1][1] = w;
	}
};
mat mul(const mat& x, const mat& y) {
	return {min(x.a[0][0] + y.a[0][0], x.a[0][1] + y.a[1][0]),
			min(x.a[0][0] + y.a[0][1], x.a[0][1] + y.a[1][1]),
			min(x.a[1][0] + y.a[0][0], x.a[1][1] + y.a[1][0]),
			min(x.a[1][0] + y.a[0][1], x.a[1][1] + y.a[1][1])};
}
struct random {
	static uint64_t splitmix64(uint64_t x) {
		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}
	uint64_t rnd() {
		sd ^= sd << 13, sd ^= sd >> 7;
		return sd ^= sd << 17;
	}
	void init() { cin >> sd >> b, sd = splitmix64(sd); }
	void genmat(mat& res) {
		uint64_t val = rnd();
		for (int i : {0, 1})
			for (int j : {0, 1}) res.a[i][j] = val >> ((i << 1 | j) << 4) & 0xff;
	}
	void genqry(int& l, int& r, int n) {
		if ((rnd() & 1) && b) {
			int c = rnd() % (n - b);
			l = rnd() % (n - c) + 1, r = l + c;
		} else {
			l = rnd() % n + 1, r = rnd() % n + 1;
			if (l > r) swap(l, r);
		}
	}
	uint64_t sd;
	int b;
} rnd;
struct output {
	int ans, kv[2][2];
	void init() {
		for (int i : {0, 1})
			for (int j : {0, 1}) cin >> kv[i][j];
	}
	void setres(mat res) {
		int tmp = 0;
		for (int i : {0, 1})
			for (int j : {0, 1}) tmp += res.a[i][j] ^ kv[i][j];
		ans ^= tmp;
	}
} out;
constexpr int N = 1e6 + 9;
int n, m, ans;
mat sgt[N << 1];
signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m, rnd.init(), out.init();
	for (int i = 0; i < n; ++i) rnd.genmat(sgt[i + n]);
	for (int i = n - 1; i; --i) sgt[i] = mul(sgt[i << 1], sgt[i << 1 | 1]);
	// 你可以在这里进行你所需要的初始化。
	for (int l, r; m; --m) {
		rnd.genqry(l, r, n);
		--l; --r;
		mat a, b;
		for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
			if (l & 1) a = mul(a, sgt[l++]);
			if (r & 1) b = mul(sgt[--r], b);
		}
		out.setres(mul(a, b));
		// 你可以把上面这个 accumulate 改成自己的查询函数。
	}
	return cout << out.ans << endl, 0;
}
```

---


# 教主的魔法

## 题目描述

教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给 XMYZ 信息组每个英雄看。于是 $N$ 个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为 $1, 2, \ldots, N$。


每个人的身高一开始都是不超过 $1000$ 的正整数。教主的魔法每次可以把闭区间 $[L, R]$（$1≤L≤R≤N$）内的英雄的身高全部加上一个整数 $W$。（虽然 $L=R$ 时并不符合区间的书写规范，但我们可以认为是单独增加第 $L(R)$ 个英雄的身高）


CYZ、光哥和 ZJQ 等人不信教主的邪，于是他们有时候会问 WD 闭区间 $[L, R]$ 内有多少英雄身高大于等于 $C$，以验证教主的魔法是否真的有效。


WD 巨懒，于是他把这个回答的任务交给了你。


## 说明/提示

【输入输出样例说明】

原先 $5$ 个英雄身高为 $1, 2, 3, 4, 5$，此时 $[1, 5]$ 间有 $2$ 个英雄的身高大于等于 $4$。教主施法后变为 $1, 2, 4, 5, 6$，此时 $[1, 5]$ 间有 $3$ 个英雄的身高大于等于 $4$。

【数据范围】

对于 $30\%$ 的数据，$N≤1000$，$Q≤1000$。

对于 $100\%$ 的数据，$N≤10^6$，$Q≤3000$，$1≤W≤1000$，$1≤C≤10^9$。

---

$\text{upd 2022.8.18}$：新增加一组 Hack 数据。  
$\text{upd 2023.8.16}$：新增加一组 [Hack 数据](https://www.luogu.com.cn/discuss/661585)。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
A 1 5 4
M 3 5 1
A 1 5 4```

### 输出

```
2
3
```

# 题解

## 作者：览遍千秋 (赞：281)

upd 2023-02-01 修改题解内容，使得其符合现行题解规范，并自己审核通过（）

upd 2025-02-05 重写完整代码，去掉 `register` 等无效内容，规范复用逻辑与 STL 函数，并自己审核通过。

---

## 摘要

分块，是一种**优雅**的暴力，它通过对数列分段，完成对数列一些区间操作和区间查询的操作，是一种根号算法。

这篇学习笔记&题解是本**萌新**在学习分块过程中的一些感悟，希望能够帮助分块零基础的同学学会**基础**分块。

---

## 0 说明

本文中，以下变量有特定的含义：

 - $\operatorname{block}$：块的大小
 - $n$：被分块的数列的大小（长度）
 - $L_{x}$：第 $x$ 号块的左边界
 - $R_{x}$：第 $x$ 号块的右边界
 - $\operatorname{tot}$：块的数量
 - $\operatorname{belong}_{x}$：第 $x$ 号元素所属的块
 
 在写作时，由于本萌新的失误，只好提前在这里令 $[l,r]$ 与 $[x,y]$ 等价。
 
---

## 1 建块

### 1.1 建块需要完成的任务

在读入数据后，建块需要完成以下几个任务：

 - 确定块的大小
 - 确定块的数量
 - 标记每个块的左右边界
 - 标记每个元素所属的块
 - 对每个块的数据进行初始化

### 1.2 确定块的大小

一般来说，我们习惯于令 $\operatorname{block}=\sqrt{n}$。

但是由于~~毒瘤~~良心命题人泛滥，$\operatorname{block}=\sqrt{n}$ 极其有可能被针对，在这种情况下，我们可以对块的大小适当作出一些调整，例如 $\sqrt{n}+1$，$\sqrt{n}-1$，$\sqrt{\frac{n}{\lg(n)}}$ 等。

一般这个工作只有一句话：

```cpp
block = (int)sqrt((double)n);
```

### 1.3 确定块的数量

在确定了块的大小后，块的数目就很容易确定了。

但是 $n$ 不一定是一个完全平方数，我们需要把最后几个无法凑足 $\operatorname{block}$ 个元素的再单独分一个块。

代码如下：

```cpp
tot = n / block;
if(n % block) tot++;
```

### 1.4 标记每个块的左右边界

非常显然，$L_1=1,R_1=\operatorname{block},L_2=\operatorname{block}+1,R_2=2×\operatorname{block},\cdots$

从而可以得出结论：

$$L_{x}=(x-1)\cdot\operatorname{block}+1,R_{x}=x\cdot \operatorname{block}$$

特别地，$R_{\operatorname{tot}}=n$

代码：
```cpp
for(int i = 1; i <= tot; i++){
	L[i] = (i - 1) * block + 1;
    R[i] = i * block;
}
R[tot] = n;
```


### 1.5 标记每个元素所属的块

根据 1.4，我们很容易推出公式如下：

$$\operatorname{belong}_{x}=\frac{x-1}{\operatorname{block}}+1$$

代码如下：

```cpp
for(int i = 1; i <= n; i++)
	belong[i] = (i - 1) / block + 1;
```

**重要：在使用分块过程中，一定要注意区分 $\operatorname{tot}$ 和 $n$。** $\operatorname{tot}$ 是块的总数，$n$ 是原来元素的总数。

### 1.6 对每个块的元素进行初始化

这项工作因题目不同而不同，如【教主的魔法】一题，就要对每个块的元素进行排序。

**因为排序会对原始数列作出改变，所以在本题中，应当先把数列复制一遍再进行分块**

---

## 2 分块题常见的操作

修改：

 - 对数列 $[l,r]$ 内的每个数加上 $k$
 - 对数列 $[l,r]$ 内的每个数减去 $k$
 - etc.

查询：

 - 求数列 $[l,r]$ 内的所有数的和
 - 求数列 $[l,r]$ 内的数有多少大于/小于/大于等于/小于等于 $k$
 - etc.

---

## 3 修改操作

考虑两种修改操作本质相同，第二种修改操作相当于第一种修改操作中 $k=-k'$。

### 3.1 暴力修改

考虑枚举区间 $[l,r]$ 之间所有数，直接对其实施修改，在修改的过程中维护每一个块的和/大小关系等。

但这不是我们考虑的东西

### 3.2 考虑线段树思想

线段树一个重要思想：lazytag

考虑应用在分块中。在修改操作中，如果是整块，就不维护每个的具体信息，而是在这个块的 $\operatorname{lazy}$ 标记上加上 $k$。对于没有整块修改的部分（即块 $\operatorname{belong}_x$ 和 $\operatorname{belong}_y$ 的修改部分），暴力修改。

这样的话，第 $i$ 个数据 $a_i$ 的真正数据值为 $a_i+\operatorname{lazy}_{\operatorname{belong}_{i}}$。

如果询问涉及到排序，块 $\operatorname{belong}_x$ 和 $\operatorname{belong}_y$ 需要全部重新备份和排序，对于块 $[\operatorname{belong}_x+1,\operatorname{belong}_y-1]$ 的块，数的相对大小不会改变，所以可以不重新排序。

特别地，需要特判 $\operatorname{belong}_x=\operatorname{belong}_y$ 的情况。

代码：
```cpp
void change(){
	if(belong[x] == belong[y]){
		for(int i = x; i <= y; i++){
			a[i] += k;
			sum[belong[x]] += k;
		}
		return;
	}
	for(int i = x; i <= R[belong[x]]; i++){
		a[i] += k;sum[belong[x]] += k;
	}
	for(int i = L[belong[y]]; i <= y; i++){
		a[i] += k; sum[belong[y]] += k;
	}
	for(int i = belong[x] + 1; i <= belong[y] - 1; i++){
		lazy[i] += k;
		sum[i] += blo * k;
	}
}
```

对以下这句代码作出特别解释：
```cpp
sum[i] += blo * k;
```
不用特判最后一块的原因是：如果操作区间覆盖到的最后一块，也一定是作为 $\operatorname{belong}_y$ 处理掉了，剩下来的块长一定是 $\operatorname{block}$。

---

## 4 查询操作

### 4.1 查询元素和

对于块 $\operatorname{belong}_x$ 和 $\operatorname{belong}_y$，暴力枚举加和，注意加上其元素后还要加上 $\operatorname{lazy}_{\operatorname{belong}_{i}}$

对于 $[\operatorname{belong}_x+1,\operatorname{belong}_y-1]$ 的块，直接 `ans=ans+sum[i]` 即可。

同样的，需要特判 $\operatorname{belong}_x=\operatorname{belong}_y$

代码：
```cpp
int query_sum(){
	int ans = 0;
	if(belong[x] == belong[y]){
		for(int i = x; i <= y; i++){
			ans += a[i] + lazy[belong[x]];
		}
		return ans;
	}
	for(int i = x; i <= R[belong[x]]; i++){
		ans += a[i] + lazy[belong[x]];
	}
	for(int i = L[belong[x]]; i <= y; i++){
		ans += a[i] + lazy[belong[y]];
	}
	for(int i = belong[x] + 1; i <= belong[y] - 1; i++){
		ans += sum[i];
	}
	return ans;
}
```

### 4.2 查询关系

与4.1类似，在块 $\operatorname{belong}_x$ 和 $\operatorname{belong}_y$，暴力枚举求答案；

对于 $[\operatorname{belong}_x+1,\operatorname{belong}_y-1]$ 的块，因为其是有序的，进行二分找到端点位置，然后加加减减求出块中有多少符合要求的元素即可。

本处代码见5.

---

## 5 教主的魔法

在学习完分块后，我们可以发现，教主的魔法就是一道裸的分块题。

因此，完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INT_SIZE = sizeof(int);
const int MAXN = 1000000 + 7;
const int MAXBLOCK = 1000 + 7;

int a[MAXN], d[MAXN], belong[MAXN];
int L[MAXBLOCK], R[MAXBLOCK], lazy[MAXBLOCK];
int n, q, block, tot, x, y, k;


void build() {
    block = (int)sqrt(n);
    tot = (n + block - 1) / block;
    for(int i = 1; i <= n; i++) {
        belong[i] = (i - 1) / block + 1;
    }
    for(int i = 1; i <= tot; i++) {
        L[i] = (i - 1) * block + 1;
        R[i] = min(i * block, n);
        sort(d + L[i], d + R[i] + 1);
    }
}

void modify_part(int bid, int st, int ed) {
    for(int i = st; i <= ed; i++) {
        a[i] += k;
    }
    int len = R[bid] - L[bid] + 1;
    memcpy(d + L[bid], a + L[bid], len * INT_SIZE);
    sort(d + L[bid], d + R[bid] + 1);
}

void modify() {
    if(belong[x] == belong[y]) {
        modify_part(belong[x], x, y);
        return;
    }

    modify_part(belong[x], x, R[belong[x]]);
    modify_part(belong[y], L[belong[y]], y);
    
    for(int i = belong[x] + 1; i < belong[y]; i++) {
        lazy[i] += k;
    }
}

int query_part(int bid, int st, int ed) {
    int ret = 0;
    for(int i = st; i <= ed; i++) {
        if(a[i] + lazy[bid] >= k) {
            ++ret;
        }
    }
    return ret;
}

int query() {
    if(belong[x] == belong[y]) {
        return query_part(belong[x], x, y);
    }

    int ansL = query_part(belong[x], x, R[belong[x]]);
    int ansR = query_part(belong[y], L[belong[y]], y);
    int ansM = 0;

    for(int i = belong[x] + 1; i < belong[y]; i++) {
        int pos = lower_bound(d + L[i], d + R[i] + 1, k - lazy[i]) - d;
        ansM += R[i] - pos + 1;
    }

    return ansL + ansR + ansM;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n >> q;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        d[i] = a[i];
    }
    build();
    while(q--){
        char op;
        cin >> op >> x >> y >> k;
        switch(op) {
            case 'M': {
                modify();
                break;
            }
            case 'A': {
                cout << query() << '\n';
                break;
            }
        }
    }
    return 0;
}
```

[2024-02-05 更新前代码](https://www.luogu.com.cn/paste/f6idda40)

## 6 附

因为本人是个**萌新**，文字未免有些疏漏，欢迎大佬指导。

---

## 作者：Jianuo_Zhu (赞：47)

话说分块确实是一个非常好的算法，只可惜洛谷上的题目有点少。

看到这一题首先想到线段树，再发现线段树做不了，每个节点预处理出>=k的个数实在是太多了，

空间不能承受。

那么怎么用分块做呢？

先看看怎么查询块内>=k的个数的操作呢？

我们可以先将这个块排好序，然后二分查找k的值就好了。

至于两边不完整的块，暴力查询还没有排序的原本序列直接找就好了

再看看怎么修改？？

对于整块，我们可以打上一个add标记，这样二分查找就要查 >= k-add 的值。

对于不完整的块，我们暴力修改，再直接排序整个块就好了

然后就可以过了。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<queue>
#include<cmath>
using namespace std;
const int maxn=1e6+10;
int n,q,a[maxn],b[maxn],l[maxn],r[maxn],belong[maxn],add[maxn],block,num;
void build(void);
void update(int ll,int rr,int w);
int ask(int ll,int rr,int w);
int find(int x,int w);
void reset(int x){
    for(int i=l[belong[x]]; i<=r[belong[x]]; i++) b[i] = a[i];
    sort(b+l[belong[x]],b+r[belong[x]]+1);
}
int main(){
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    build();
    int x,y,w;
    for(int i=1;i<=q;i++){
        char c[5];
        scanf("%s%d%d%d",c,&x,&y,&w);
        if(c[0]=='M') update(x,y,w);
        else printf("%d\n",ask(x,y,w));
    }
    return 0;
}
void build(void){
    block=sqrt(n);
    num=n/block;if(n%block) num++;
    for(int i=1;i<=n;i++)
        belong[i]=(i-1)/block+1,b[i]=a[i];
    for(int i=1;i<=num;i++)
        l[i]=(i-1)*block+1,r[i]=i*block;
    r[num]=n;
    for(int i=1;i<=num;i++)
        sort(b+l[i],b+r[i]+1);
    return;
}
void update(int ll,int rr,int w){
    if(belong[ll]==belong[rr]){
        for(int i=ll;i<=rr;i++)
            a[i]+=w;
        reset(ll);return;
    }
    for(int i=ll;i<=r[belong[ll]];i++){
        a[i]+=w;
    }
    for(int i=l[belong[rr]];i<=rr;i++){
        a[i]+=w;
    }
    reset(ll);reset(rr);
    for(int i=belong[ll]+1;i<belong[rr];i++)
        add[i]+=w;
}
int ask(int ll,int rr,int w){
    int cnt=0;
    if(belong[ll]==belong[rr]){
        for(int i=ll;i<=rr;i++)
            if(a[i] + add[belong[ll]]>=w)cnt++;
            return cnt; 
    }
    for(int i=ll;i<=r[belong[ll]];i++)
        if(a[i] + add[belong[i]]>=w) cnt++;
    for(int i=l[belong[rr]];i<=rr;i++)
        if(a[i] + add[belong[i]]>=w) cnt++;
    for(int i=belong[ll]+1;i<belong[rr];i++)
        cnt+=find(i,w-add[i]);
    return cnt;
}
int find(int x,int w){
    int ll=l[x],rr=r[x],mid;
    while(ll<=rr){
        mid=(ll+rr)/2;
        if(b[mid]<w) ll=mid+1;
        else rr=mid-1;
    }
    return r[x]-ll+1;
}
```
更新：2018-3-5
原本代码中有一处错误，详情请见https://www.luogu.org/discuss/show/31449
感谢@Sooke

更新：2018-3-25 又被大佬们发现错误，详情还是请见https://www.luogu.org/discuss/show/31449
感谢@多功能的荀彧

~~假数据害人啊~~

---

## 作者：3493441984zz (赞：30)

# 本题解是我写的第一篇分块题解，希望能通过$qwq$
****
**本题解详细介绍分块，为了方便阅读，给出目录：**

$1$、分块是什么

$2$、变量，及数组介绍

$3$、头文件

$4$、你们最爱的代码（含注释）
****
# 一、分块是什么

分块算法实质上是一种是通过分成多块后在每块上打标记

以实现快速区间修改，区间查询的一种算法。其均摊时间

复杂度为$O$($\sqrt n$ )$ $ $ $ $ $ $ $  $ $ $ $ $ $ ——$decoration$（某大佬）

安利一下[易懂的洛谷日报](https://www.luogu.org/blog/48265/qian-tan-ji-chu-gen-hao-suan-fa-fen-kuai)

详细介绍都在里面$qwq$,~~其实是我太懒了~~
****
# 二、变量，及数组介绍

其实依照每个人不同的理解，变量和数组以及处理方法

都会不同，下面我就我自己的来谈谈

### 变量：

$1$、$block$:每个完整块的大小

#### 举个例子：
如果总长度为$10$的话，就分为4个块，前三个块有$3$个

数，最后一个块$1$个数，那么$block$就是$3$，其实也就是

$block=$ $\sqrt n$ 取整（去尾法）

$2$、$cnt$:一共有多少个块（包括不完整的块）

#### 例如上面的例子：$cnt$就等于$4$

### 数组：

$1$、$val[maxn]$:存储最开始每个数的值，$maxn=n$

$2$、$belong[maxn]$:存储每个值属于哪个块

$3$、$mark[sqrt(maxn)]$:存储每个块的标记

### 例如：

把$1$号块整体加$m$,那么$mark[1]+=m$

$4$、$vector<int> kuai[sqrt(maxn)]$:

存储每个块内的元素，~~原谅我用中文名$qwq$~~
****
# 三、头文件

依照我的变量和数组的话，需要用到：

$1$、$vector$

$2$、$cmath$

$1$、$algorithm$

### 视情况而定吧$qwq$
****
# 四、代码（含注释）
~~~cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#pragma GCC optimize(3)
using namespace std;
const int maxn=1000010;
const int _maxn=1010;
int n,q,block,cnt;
int belong[maxn],val[maxn],mark[_maxn];//数组在上文已提及，不多赘述 
vector<int> kuai[_maxn];
void start()//初始化kuai数组，让每个块内都有从小到大的顺序 （当然你也可以从大到小qwq） 
{
	for(int i=1;i<=cnt;++i)
		sort(kuai[i].begin(),kuai[i].end());
}
void update(int pos)//更新kuai数组
{
	kuai[pos].clear();//清空数组 
	for(int i=(pos-1)*block+1;i<=pos*block;++i)
		kuai[pos].push_back(val[i]);//因为块内元素已修改，所以重新放入元素 
	sort(kuai[pos].begin(),kuai[pos].end());//保证块内的有序性 
} 
void add(int l,int r,int x)//区间修改 
{
	for(int i=l;i<=min(r,belong[l]*block);++i)
		val[i]+=x;//左边零散的块暴力修改 
	update(belong[l]);//更新左边零散块的kuai数组 
	if(belong[l]!=belong[r])
	{
		for(int i=belong[l]+1;i<belong[r];++i)
			mark[i]+=x;//中间的块直接打标记 
		for(int i=(belong[r]-1)*block+1;i<=r;++i)
			val[i]+=x;//右边零散的块暴力修改		
		update(belong[r]);// 更新右边零散块的kuai数组 
	}
}
int search(int l,int r,int x)
{
	int num=0;//计数器 
	for(int i=l;i<=min(r,belong[l]*block);++i)
		if(val[i]+mark[belong[i]]>=x)//左边零散的块暴力查询，记住要加mark值 
			++num;
	if(belong[l]!=belong[r])
	{
		for(int i=belong[l]+1;i<belong[r];++i)
		{
			int L=0,R=block-1,mid;
			while(L<=R)//中间块二分查询，不然会T ，应该也可以用lower_bound这些类似的函数，别看我。。我不会。。 
			{
				mid=L+((R-L)>>1);
				if(kuai[i][mid]+mark[i]<x)
					L=mid+1;
				else
					R=mid-1;
			}
			num+=block-L;
		}
		for(int i=(belong[r]-1)*block+1;i<=r;++i)
			if(val[i]+mark[belong[i]]>=x)//右边零散的块暴力查询 
				++num;
	}
	return num;//返回值。。。 
}
int main()
{
	scanf("%d%d",&n,&q);
	block=sqrt(n);//块的大小 
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&val[i]);
		if(i%block==1)//到了新的一个块 
			cnt++;
		belong[i]=cnt;
		kuai[cnt].push_back(val[i]);
	}
	start();
	for(int i=1;i<=q;++i)
	{
		char in1;
		int in2,in3,in4;
		scanf(" %c%d%d%d",&in1,&in2,&in3,&in4);
		switch(in1)
		{
			case 'M':				
				add(in2,in3,in4);			
			break;
			case 'A':
				printf("%d\n",search(in2,in3,in4));
			break;
		}
	}
	return 0;
}
~~~
****
# 结语：

## 如果有错误，请私信我，另外，觉

## 得有帮助的话，不要吝啬你们的赞

## 哦$qwq$

****

---

## 作者：hyfhaha (赞：29)

分块入门题，不错的，建议大家做一做
# 开始学习
先看一下[数列分块入门 2](https://loj.ac/problem/6278)

这道题想让我们求区间[l,r]>=c的个数，然后我们可以看到“数列分块入门 2”是求区间[l,r]<c(忽略平方)的个数，即求c在区间[l,r]的排名。所以我们可以每一次查询c的排名，然后用区间长度减c的排名就可以达到答案了呢QAQ。

那么题目就被转移成了求区间[l,r]中c的排名

------------

一看题目，咦，求[l,r]区间c的排名，马上就可以想到平衡树啦，可是平衡树这么难写，而且还不支持区间加，那怎么办？ **分块！**

首先，我们一个一个步骤分着来看：

(1).**操作** 操作和普通分块的操作一模一样，类个tag，我们先不理。

(2).**查询** 如果一般查询排名，我们可以将这一段数截出来，排序，然后二分查找(lower_bound操作)就ok了。那我们可不可以先将每一个块的数都排好序，然后查找每一个块的时候就直接二分呢？ ofcause，当然可以！那零零散散的剩下的非整块的数就暴力找就可以了。

(3).**排序操作** 我们查询需要先排序，那么我们排序也成为了一个操作。我们另外开一个数组ve[i]（ve[i]为vector，i表示第i个块）来存每个块排序的数据（这里我使用了vector）。到时候查询的时候直接二分ve[i]就可以了。那每一次零散修改操作都会修改数值（整块操作还是直接加tag），那么我们要对有修改数值的那个块重新进行块内排序。（额，好慢啊）

所以这道题的复杂度是O(msqrt(nlogn))

那么我们这个分块的基本思想就是这样了。还有很多小细节可以看看我的代码：

```cpp
//P2801 教主的魔法
#include<map>
#include<set>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
int n,m,blo;
int v[1000005],bl[1000005],atag[1000005];
vector<int>ve[10001];
void reset(int x)                       //排序操作 
{
    ve[x].clear();                      //先初始化 
    for(int i=(x-1)*blo+1;i<=min(x*blo,n);i++)
        ve[x].push_back(v[i]);          //将整个块的数值重新压进vector里 
    sort(ve[x].begin(),ve[x].end());    //块内排序 
}
ll read()                               //快读 
{
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void add(int a,int b,int c)             //修改操作 
{
    for(int i=a;i<=min(bl[a]*blo,b);i++) v[i]+=c;   //零散操作 
    reset(bl[a]);                       //重新块内排序 
    if(bl[a]!=bl[b])                    
    {
        for(int i=(bl[b]-1)*blo+1;i<=b;i++) v[i]+=c;//零散操作 
        reset(bl[b]);                   //重新块内排序 
    }
    for(int i=bl[a]+1;i<=bl[b]-1;i++)   
        atag[i]+=c;
}
int query(int a,int b,int c)            //查询操作 
{
    int ans=0;//排名 
    for(int i=a;i<=min(bl[a]*blo,b);i++)//零散暴力查询 
    {
        if(v[i]+atag[bl[a]]<c)
        ans++;
    }
    if(bl[a]!=bl[b])
    {
        for(int i=(bl[b]-1)*blo+1;i<=b;i++)         //零散暴力查询 
        {
            if(v[i]+atag[bl[b]]<c)
            ans++;
        }
    }
    for(int i=bl[a]+1;i<=bl[b]-1;i++)   //整块查询 
    {
        int x=c-atag[i];                //注意：这里要先剪去这个块的atag，因为这整个块的所以数值都应该加了atag，所以我们二分找的数也要先剪atag 
        ans+=lower_bound(ve[i].begin(),ve[i].end(),x)-ve[i].begin();    //注意：这里lower_bound操作返回的是地址，所以要想知道块内排名，要减块头的地址 
    }   //不会用lower_bound可以直接写二分 
    return ans;
}
int main()
{
    n=read();m=read();blo=sqrt(n);
    for(int i=1;i<=n;i++)v[i]=read();
    for(int i=1;i<=n;i++)bl[i]=(i-1)/blo+1,ve[bl[i]].push_back(v[i]);   //初始化ve[i]数组 
    for(int i=1;i<=bl[n];i++)
    sort(ve[i].begin(),ve[i].end());    //排序
    for(int i=1;i<=m;i++)
    {
    	char f;cin>>f;
        int a=read(),b=read(),c=read();
        if(f=='M')add(a,b,c);
        if(f=='A')printf("%d\n",b-a+1-query(a,b,c));
    }
    return 0;
}
```

# 广告

如果需要更系统的学习分块可以看我的blog，内容更详细，分解更到位qwq

## [分块学习blog](https://www.luogu.org/blog/juruohyfhaha/fen-kuai-xue-xi)

---

## 作者：fdfdf (赞：12)

被机房大佬推荐来做这道分块题???

$Q\le 3000$，一开始的身高$\le 1000$

又不强制在线

这意味着我们可以搞一些事情。

由于我们的询问只有$3000$个，那么这个序列就被这询问的$3000$个左端点和$3000$个右端点分成了$6000(+1?)$段

然后对于每一段我们用$s_{i,j}$记录第$i$段权值$\ge j$的有多少个

对于每一段区间都枚举一遍所有的询问，修改肯定是整段区间一起修改，打个$lazy$就可以了，查询的时候把询问减掉$lazy$查一下权值。

复杂度是$O(2Q(Q+1000))$

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<iomanip>
#include<cstring>
#include<complex>
#include<vector>
#include<cstdio>
#include<string>
#include<bitset>
#include<ctime>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<set>
#define Cpy(x,y) memcpy(x,y,sizeof(x))
#define Set(x,y) memset(x,y,sizeof(x))
#define FILE "a"
#define mp make_pair
#define pb push_back
#define RG register
#define il inline
using namespace std;
typedef unsigned long long ull;
typedef vector<int>VI;
typedef long long ll;
typedef double dd;
const int N=1000010;
const int M=10000010;
const dd eps=1e-5;
const int inf=2147483647;
const ll INF=1ll<<60;
const ll P=100000;
il ll read(){
  RG ll data=0,w=1;RG char ch=getchar();
  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
  if(ch=='-')w=-1,ch=getchar();
  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();
  return data*w;
}

il void file(){
  srand(time(NULL)+rand());
  freopen(FILE".in","r",stdin);
  freopen(FILE".out","w",stdout);
}

int n,Q,k,a[N],o[N],len,m,s[6005][1005],tag[N],ans[N];
struct query{int opt,l,r,v,id;}q[N];
int main()
{
  n=read();Q=read();
  for(RG int i=1;i<=n;i++)a[i]=read();
  for(RG int i=1,c;i<=Q;i++){
    c=0;while(c!='M'&&c!='A')c=getchar();
    q[i].opt=(c=='A');q[i].l=read();q[i].r=read();q[i].v=read();
    o[++o[0]]=q[i].l;o[++o[0]]=q[i].r+1;if(c=='A')q[i].id=++k;
  }
  sort(o+1,o+o[0]+1);m=unique(o+1,o+o[0]+1)-o-1;o[m+1]=n+1;
  for(RG int i=1;i<=Q;i++){
    q[i].l=lower_bound(o+1,o+m+1,q[i].l)-o;
    q[i].r=upper_bound(o+1,o+m+1,q[i].r)-o-1;
  }
  for(RG int i=1;i<=m;i++){
    for(RG int j=o[i];j<o[i+1];j++)s[i][a[j]]++;
    for(RG int j=1000;j;j--)s[i][j]+=s[i][j+1];
  }
  for(RG int i=1;i<=m;i++)
    for(RG int j=1;j<=Q;j++)
      if(q[j].l<=i&&i<=q[j].r){
	if(!q[j].opt)tag[i]+=q[j].v;
	else{
	  if(q[j].v-tag[i]<=0)ans[q[j].id]+=o[i+1]-o[i];
	  else if(q[j].v-tag[i]<=1000)ans[q[j].id]+=s[i][q[j].v-tag[i]];
	}
      }
  for(RG int i=1;i<=k;i++)printf("%d\n",ans[i]);
  return 0;
}

```

---

## 作者：qwaszx (赞：10)

@xMinh:底下仨题解我hack掉俩了

qwq太强辣!

说正题

[数列分块入门by hzwer](http://hzwer.com/8053.html)[](http://hzwer.com/8053.html)一个很好的blog

一开始看见Q很小以为是差分

一看题发现不对劲

于是我们就拿分块暴力了233

@巨型方块 有人要把你分了

首先，分块是sm玩意？

**根号平衡**(by lxl)：

有x次操作，单次复杂度为O(a)

有y=kx次查询，单次复杂度为O(b)

在满足一定条件的题里面

可以通过提高其中一边的复杂度，降低另一边的复杂度来达到更好的效果

这时满足xa=kxb

于是分块一般都是带sqrt的

杜教筛会出来O(n^(2/3))的神奇复杂度，基于**数论分块**

但这里不讨论数论分块

带修改区间和问题的部分做法(还是by lxl)

如果采用x叉树，即有logx(n)层

如果采用sqrt(n)叉树，即有2层

如果采用2叉树，即有logn层

第一个是分块，第二个是线段树

这个即是一个根号平衡的例子

但这个题不能用分治结构完成(继续by lxl)

如果是单点修改，我们可以用树套树实现

但是区间修改后树套树无法快速合并信息

比如我们维护了cur的一个名次数据结构

cur的左儿子没有发生变化

cur的右儿子被整体加了

这样我们无法通过这两个儿子的名次数据结构快速维护出cur的名次数据结构

也无法直接在cur的名次数据结构上操作

所以分治结构无法在低复杂度解决这个问题

那么想到分块

### 分块基础(lxl)

要实现：

1.区间加

2.区间和

朴素来做，可以有O(1)修改O(n)查询以及O(n)修改O(1)查询的暴力做法

这个问题可以套用根号平衡达到O( sqrt(n) )修改O( sqrt(n) )查询

我们可以把sqrt(n)个元素放一块里面维护

我们把每次操作完整覆盖的块定义为“整块”

把每次操作没有完整覆盖的块定义为“零散块”(区间端点)

每次操作最多经过O( sqrt(n) )个整块，以及O(1)个零散块

所以我们可以O(1)维护整块信息，O( sqrt(n) )查询零散块信息

这样就达到了O( msqrt(n) )的复杂度

### 分块本质

一个度数为sqrt(n)，只有三层的树

每次修改只用更新:sqrt(n)个size为1的节点以及2个size为sqrt(n)的节点

注意到我们不用维护那个size为n的根节点的信息

所以如果在分治结构上很难快速合并某些信息，我们就可以利用分块来做

好了抄lxl的课件抄完了233

这个问题可以抽象成：

维护一个序列

支持区间加，区间查询>=x的数的个数

那么分块怎么做？

初始化的时候，对每个块排序

修改的时候，整块打标记，零散块重构，就是再排序一遍

查询呢？

零散块查询可以暴力，整块查询可以二分

如何二分？

假设区间的标记为y，读入的是x

那么只要把x-y作为二分的值即可

用stl的lower_bound很快

接下来是复杂度

设有x个块

修改:整块O(1),零散块O(n/x)

这里排序的方法要注意

原先这个块是有序的

区间加之后，这个区间仍然保持有序

也就是有两个有序的区间要合并

归并即可完成O(n/x)复杂度

查询:零散块O(n/x),整块O(log(n/x)*x)

于是根号平衡成为O(msqrt(nlogn))~~(我也不知道怎么算的)~~

上代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int a[1100000],m,bl[1100000],tag[2000],l,r,x,n,bol,a1[1100000],t[1100000],L[2000],R[2000],opt;
inline void merge(int l1,int r1,int l2,int r2)
{
    register int i=l1,j=l2,k=l1;
    while(i<=r1&&j<=r2)
    {
        if(a1[i]<a1[j])t[k++]=a1[i++];
        else t[k++]=a1[j++];
    }
    while(i<=r1)t[k++]=a1[i++];
    while(j<=r2)t[k++]=a1[j++];
    for(register int i=l1;i<=r2;i++)
        a1[i]=t[i];
}
inline void reset(int x,int c)
{
    int r=R[x];
    for(register int i=L[x];i<=r;i++)
        a1[i]=a[i];
    merge(L[x],c,c+1,r);
}
inline void cg(int l,int r,int x)
{
    int minn=min(r,R[bl[l]]);
    for(register int i=l;i<=minn;i++)
        a[i]+=x;
    reset(bl[l],l);
    if(bl[l]!=bl[r])
    {
        for(register int i=L[bl[r]];i<=r;i++)
            a[i]+=x;
        reset(bl[r],r);
    }
    for(register int i=bl[l]+1;i<bl[r];i++)
        tag[i]+=x;
}
inline int q(int l,int r,int x)
{
    int ans=0;
    int minn=min(r,R[bl[l]]);
    int xx=x-tag[bl[l]];
    for(register int i=l;i<=minn;i++)
        if(a[i]>=xx)
            ans++;
    if(bl[l]!=bl[r])
    {
        xx=x-tag[bl[r]];
        for(register int i=L[bl[r]];i<=r;i++)
            if(a[i]>=xx)
                ans++;
    }
    for(register int i=bl[l]+1;i<bl[r];i++)
    {
        int xx=x-tag[i];
        ans+=R[i]-(lower_bound(a1+L[i],a1+R[i]+1,xx)-a1)+1;
    }
    return ans;
}
inline int getin()
{
    register int x=0;register char ch=getchar();
    while((ch<'0'||ch>'9'))ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
inline char getin1()
{
    register char ch=getchar();
    while(ch<'A'||ch>'M')ch=getchar();
    return ch;
}
int wt[100];
inline void putout(int x)
{
    if(!x)
    {
        putchar(48);
        return;
    }
    register int l=0;
    while(x)wt[++l]=x%10,x/=10;
    while(l)putchar(wt[l--]+48);
}
int main()
{
    n=getin(),m=getin();
    bol=sqrt(n);
    for(register int i=1;i<=n;i++)a1[i]=a[i]=getin(),bl[i]=(i-1)/bol+1;
    for(register int i=1;i<=bl[n];i++)
    {
    	L[i]=(i-1)*bol+1;R[i]=i*bol;
        sort(a1+L[i],a1+R[i]+1);
    }
    R[bl[n]]=n;
    for(register int i=1;i<=m;i++)
    {
        opt=getin1(),l=getin(),r=getin(),x=getin();
        if(opt=='M')cg(l,r,x);
        else putout(q(l,r,x)),putchar(10);
    }
}
```
PS:虽然推出来块大小应该是sqrt(nlogn),但sqrt(n)跑得最快...

分块这东西很玄学...有时候+-*/一些常数可能就能跑快点...

目前rank5

rqy太强了...不开O2跑了240ms开O2 188ms...最顶上两个是rqy的代码%%%

---

## 作者：Aliemo (赞：10)

题目链接: [P2801 教主的魔法](https://www.luogu.com.cn/problem/P2801)

### 题目大意

一个序列 $n$ 有区间加和及查询区间有多少个元素大于 $c$

### solution

我们对每个块进行操作,对于每个块排序

修改操作:对于整块我们记录一下加的值即可,顺序没有改变,然后对于不足整块,我们直接加和然后排序

查询操作:对于整块我们 lower_bound 查找即可, 用块长减去查找的位置即可, 然后对于不足整块, 我们直接枚举查找

### Code

```cpp
/**
*    Author: Alieme
*    Data: 2020.9.8
*    Problem: Lougu P2801
*    Time: O()
*/
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>

#define int long long
#define rr register

#define inf 1e9
#define MAXN 1000010

using namespace std;

inline int read() {
	int s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void print(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}

int n, len, m;

int a[MAXN], b[MAXN], id[MAXN], v[MAXN];

inline void update(int x) {
	int l = (x - 1) * len + 1, r = min(x * len, n);
	for (rr int i = l; i <= r; i++) b[i] = a[i];
	sort(b + l, b + r + 1);
}

inline void add(int l, int r, int x) {
	int start = id[l], end = id[r];
	if (start == end) {
		for (rr int i = l; i <= r; i++) a[i] += x;
		update(id[l]);
		return ;
	}
	for (rr int i = l; id[i] == start; i++) a[i] += x; update(start);
	for (rr int i = start + 1; i < end; i++) v[i] += x;
	for (rr int i = r; id[i] == end; i--) a[i] += x; update(end);
}

inline int fin(int pid, int x) {
	int l = (pid - 1) * len + 1, r = min(pid * len, n);
	return lower_bound(b + l, b + r + 1, x - v[pid]) - (b + l);
}

inline int query(int l, int r, int x) {
	int ans = 0, start = id[l], end = id[r];
	if (start == end) {
		for (rr int i = l; i <= r; i++) if (a[i] + v[start] >= x) ans++;
		return ans;
	}
	for (rr int i = l; id[i] == start; i++) if (a[i] + v[id[i]] >= x) ans++;
	for (rr int i = start + 1; i < end; i++) ans += len - fin(i, x);
	for (rr int i = r; id[i] == end; i--) if (a[i] + v[id[i]] >= x) ans++;
	return ans;
}

signed main() {
	n = read();
	m = read();
	len = sqrt(n);
	for (rr int i = 1; i <= n; i++) a[i] = read(), id[i] = (i - 1) / len + 1;
	for (rr int i = len; i <= n; i += len) update(id[i]);
	for (rr int i = 1; i <= m; i++) {
		char opt;
		cin >> opt;
		int l = read(), r = read(), c = read();
		if (opt == 'M') add(l, r, c);
		if (opt == 'A') cout << query(l, r, c) << "\n";
	}
}

```

---

## 作者：巨型方块 (赞：9)

思路就是分块嘛；

第一次分块题啊，那讲的细一点吧；

首先堆这些数分块；

这里我的长度是sqrt(n);

分块的长度根据题目而定；

往往推出一个公式，然后根据这个公式求出最优的长度；

这个就是数学范畴；

我的strcut

l，r是区间范围，len是长度（在这一题里无用），tag是加法标记

```cpp
struct kuai{
    int l,r,len,tag;
}c[1010];
```
分块的思想拉，就是区间内包含整个块的就整个块地操作，

不是整个快的最多就两个部分，操作区间的左右两端，直接暴力；


我的主程序

a[]是原始数列，不改变；

b[]是分块序列，所有操作都在b[]进行；


```cpp
int a[1000001],b[1000001];
int ll,n,m,x,y,z,ans;
char cc;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
    fenkuai();
    while(m--){
        cin>>cc;
        scanf("%d%d%d",&x,&y,&z);
        if(cc=='A')outit(x,y,z);else change(x,y,z);
    }
}
```
这种复杂的题目，主程序轻巧一点，而且一定要写好一个模块就调试一遍，千万要小心，不然全打好了调试得要死；


我的分块函数

ll就是快的数量

```cpp
void fenkuai(){
    int k=sqrt(n);
    int l=1;
    while(l<=n){
        c[++ll].l=l;
        c[ll].r=min(n,l+k-1);
        c[ll].len=c[ll].r-c[ll].l+1;
        sort(b+c[ll].l,b+c[ll].r+1);
        l+=k;    
    }
}
```
我们将每个块都排序；这样就方便二分找答案；

findans的函数

就是把x,y分为左中右三个区间

```cpp
void outit(int x,int y,int z){
    int ans=0;
    for(int i=1;i<=ll;i++)
        if(x<=c[i].l&&c[i].r<=y)ans+=er(i,z);else
        if(c[i].l<=x&&x<=c[i].r)ans+=BL(i,x,c[i].r,z);else
        if(c[i].l<=y&&y<=c[i].r)ans+=BL(i,c[i].l,y,z);
    printf("%d\n",ans);
}
```
二分

```cpp
int er(int num,int z){
    int l=c[num].l,r=c[num].r,ans=1e9;
    while(r>=l){
        int mid=(l+r)/2;
        if(b[mid]+c[num].tag>=z){//要加上 c[num].tag
            ans=min(ans,mid);r=mid-1;
        }else l=mid+1;
    }
    if(ans==1e9)return 0;//这个特判容易忘 
    return c[num].r-ans+1;
}
```
暴力
暴力部分要在a数组里找

```cpp
int BL(int num,int x,int y,int z){
    int ans=0;
    for(int i=x;i<=y;i++)if(a[i]+c[num].tag>=z)ans++;
    return ans;
}
```
然后就是改变部分


```cpp
void change(int x,int y,int z){
    for(int i=1;i<=ll;i++)
        if(x<=c[i].l&&c[i].r<=y)c[i].tag+=z;else
        if(c[i].l<=x&&x<=c[i].r)BLchange(i,x,c[i].r,z);else
        if(c[i].l<=y&&y<=c[i].r)BLchange(i,c[i].l,y,z);
}
```

```cpp
void BLchange(int num,int x,int y,int z){
    for(int i=c[num].l;i<=c[num].r;i++){
        b[i]=a[i]+c[num].tag;
        if(x<=i&&i<=y)b[i]+=z;
    }
    sort(b+c[num].l,b+c[num].r+1);
}
```
总得来说，复杂的题目要小心，思路明确，打好一个模块调试一个；

代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define Ll unsigned long long
using namespace std;
struct kuai{
    int l,r,len,tag;
}c[1010];
int a[1000001],b[1000001];
int ll,n,m,x,y,z,ans;
char cc;
void fenkuai(){
    int k=sqrt(n);
    int l=1;
    while(l<=n){
        c[++ll].l=l;
        c[ll].r=min(n,l+k-1);
        c[ll].len=c[ll].r-c[ll].l+1;
        sort(b+c[ll].l,b+c[ll].r+1);
        l+=k;    
    }
}
int er(int num,int z){
    int l=c[num].l,r=c[num].r,ans=1e9;
    while(r>=l){
        int mid=(l+r)/2;
        if(b[mid]+c[num].tag>=z){//要加上 c[num].tag
            ans=min(ans,mid);r=mid-1;
        }else l=mid+1;
    }
    if(ans==1e9)return 0;//这个特判容易忘 
    return c[num].r-ans+1;
}
int BL(int num,int x,int y,int z){
    int ans=0;
    for(int i=x;i<=y;i++)if(a[i]+c[num].tag>=z)ans++;
    return ans;
}
void outit(int x,int y,int z){
    int ans=0;
    for(int i=1;i<=ll;i++)
        if(x<=c[i].l&&c[i].r<=y)ans+=er(i,z);else
        if(c[i].l<=x&&x<=c[i].r)ans+=BL(i,x,c[i].r,z);else
        if(c[i].l<=y&&y<=c[i].r)ans+=BL(i,c[i].l,y,z);
    printf("%d\n",ans);
}
void BLchange(int num,int x,int y,int z){
    for(int i=c[num].l;i<=c[num].r;i++){
        b[i]=a[i]+c[num].tag;
        if(x<=i&&i<=y)b[i]+=z;
    }
    sort(b+c[num].l,b+c[num].r+1);
}
void change(int x,int y,int z){
    for(int i=1;i<=ll;i++)
        if(x<=c[i].l&&c[i].r<=y)c[i].tag+=z;else
        if(c[i].l<=x&&x<=c[i].r)BLchange(i,x,c[i].r,z);else
        if(c[i].l<=y&&y<=c[i].r)BLchange(i,c[i].l,y,z);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
    fenkuai();
    while(m--){
        cin>>cc;
        scanf("%d%d%d",&x,&y,&z);
        if(cc=='A')outit(x,y,z);else change(x,y,z);
    }
}

---

## 作者：mrsrz (赞：6)

询问次数少，可以用分块解决。


将所有数分成√n块，对每一块进行排序。


用a数组存原来的数列，b数组存排完序后的数列。


查询时，对左右两个块中的数据暴力查询，中间的由于整块访问并排完序，直接二分查找即可。


修改数据时，对左右两个块中的数据暴力修改，并且更新b数组（重新排序），对中间的，由于相对大小不变，直接打上标记即可。


修改时，最多对两个块进行排序，时间复杂度O(√nlog2√n)。


查询时，最多对所有块都进行二分查找，时间复杂度O(√nlog2√n)。


故总时间复杂度O(q√nlog2√n)。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cctype>
using namespace std;
int a[1000005],b[1000005];
int n,q,size,l[1005],r[1005],blocks,add[1005],inbk[1000005];
char s[4];
inline int readint(){
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    int d=0;
    for(;isdigit(c);c=getchar())
    d=(d<<3)+(d<<1)+(c^'0');
    return d;
}
void chan(int blk){
    for(int i=l[blk];i<=r[blk];++i)
    b[i]=a[i];
    sort(b+l[blk],b+r[blk]+1);
}
int main(){
    n=readint();q=readint();
    size=(int)(sqrt(n)+0.00000001);
    blocks=0;
    l[1]=1;
    for(int i=1;i<=n;++i){
        a[i]=b[i]=readint();
        inbk[i]=blocks+1;
        if(i%size==0){
            r[++blocks]=i;
            l[blocks+1]=i+1;
        }
    }
    if(n%size)
    r[++blocks]=n;
    for(int i=1;i<=blocks;++i)
    sort(b+l[i],b+r[i]+1);
    memset(add,0,sizeof add);
    while(q--){
        scanf("%s",s);
        if(s[0]=='M'){
            int L=readint(),R=readint(),p=readint();
            if(L>R)L^=R^=L^=R;
            int lft=inbk[L],rgt=inbk[R];
            if(lft==rgt){
                for(int i=L;i<=R;++i)a[i]+=p;
                chan(lft);
            }else{
                for(int i=lft+1;i<rgt;++i)add[i]+=p;
                for(int i=L;i<=r[lft];++i)a[i]+=p;
                for(int i=l[rgt];i<=R;++i)a[i]+=p;
                chan(lft);
                chan(rgt);
            }
        }else{
            int L=readint(),R=readint(),p=readint(),ans=0;
            int lft=inbk[L],rgt=inbk[R];
            if(lft==rgt){
                for(int i=L;i<=R;++i)
                if(a[i]+add[lft]>=p)++ans;
            }else{
                for(int i=lft+1;i<rgt;++i)
                ans+=r[i]-(lower_bound(b+l[i],b+r[i]+1,p-add[i])-b-1);
                for(int i=L;i<=r[lft];++i)
                if(a[i]+add[lft]>=p)++ans;
                for(int i=l[rgt];i<=R;++i)
                if(a[i]+add[rgt]>=p)++ans;
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
```
[blog](http://www.cnblogs.com/Mrsrz/p/7742626.html)


---

## 作者：xMinh (赞：4)

咳咳，本来这个题是不想发题解的

但以前我写的分块码风太丑，就重打一下这道板子改一改

主要是安利一发自己的博客[一枚蒟蒻](https://xminh.github.io/2018/02/25/luogu2801-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95.html)

分块入门题，思路简单。区间加+查询区间内大于等于x的数的个数

需要注意的一点就是，尽管分块的时候要进行块内排序，但是每次进行区间操作的时候指的还是原数组的区间。需要开两个数组，一个是原序列，一个是分块数组，也就是排好序的。

整块的修改就不说了，打标记。零散块的修改要先改原序列，之后复制到分块数组里，再进行重构；整块的查询是用分块数组来二分，零散直接暴力查，但需要注意查的时候都要加上标记才行。

还有就是样例中的空行问题。这个不要用getchar，用cin轻松解决，不用费太多功夫来特殊处理。如果你执意要为了快而写个函数用getchar来读的话极有可能会发生开了O2不过的现象(别问我怎么知道的)。

关于分块比较详细的解析可以往下翻qwaszx学弟的题解

以及底下的题解我hack掉三个，慎用

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define maxn (1000000 + 10)
using namespace std;
int a[maxn],b[maxn],bl[maxn],L[maxn],R[maxn],add[maxn];
int n,m,block;
int read(){
	char c;int r=0,f=1;
	c=getchar();
	while (c<'0' || c>'9'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0' && c<='9'){
		r=r*10+(c^48);
		c=getchar();
	}
	return r*f;
}
void build(){
	for (int i=1;i<=n;i++) bl[i]=(i-1)/block+1;
	for (int i=1;i<=n;i++) if (!L[bl[i]]) L[bl[i]]=i;
	for (int i=n;i>=1;i--) if (!R[bl[i]]) R[bl[i]]=i;
	for (int i=bl[1];i<=bl[n];i++) sort(b+L[i],b+R[i]+1);
}
void reset(int belong){
	for (int i=L[belong];i<=R[belong];i++) b[i]=a[i];
}
void change(int l,int r,int x){
	if (bl[l]==bl[r]){
		for (int i=l;i<=r;i++) a[i]+=x;
		reset(bl[l]);
		sort(b+L[bl[l]],b+R[bl[l]]+1);
	}
	else{
		for (int i=l;i<=R[bl[l]];i++) a[i]+=x;
		reset(bl[l]);
		sort(b+L[bl[l]],b+R[bl[l]]+1);
		for (int i=bl[l]+1;i<=bl[r]-1;i++) add[i]+=x;
		for (int i=L[bl[r]];i<=r;i++) a[i]+=x;
		reset(bl[r]);
		sort(b+L[bl[r]],b+R[bl[r]]+1);
	}
}
int lb(int x,int belong){
	int l=L[belong],r=R[belong];
	int ans=r+1;
	while (l<=r){
		int mid=(l+r)>>1;
		if (b[mid]>=x){
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	return R[belong]-ans+1;
}
int query(int l,int r,int x){
	int ans=0;
	if (bl[l]==bl[r]) {
		for (int i=l;i<=r;i++) if (a[i]>=x-add[bl[l]]) ans++;
	}
	else{
		for (int i=l;i<=R[bl[l]];i++) if (a[i]>=x-add[bl[l]]) ans++;
		for (int i=bl[l]+1;i<=bl[r]-1;i++) ans+=lb(x-add[i],i);
		for (int i=L[bl[r]];i<=r;i++) if (a[i]>=x-add[bl[r]]) ans++;
	}
	return ans;
}
int main(){
	n=read();m=read();
	for (int i=1;i<=n;i++) a[i]=b[i]=read();
	block=sqrt(n);
	build();
	for (int i=1;i<=m;i++){
		char opt;int l,r,x;
		cin>>opt;
		l=read();r=read();x=read();
		if (opt=='M') change(l,r,x);
		if (opt=='A') printf("%d\n",query(l,r,x));
	}
}
```

我是真心想吐槽这题。

第一遍打自己那个鬼畜做法的时候检查不出错误来，只好调出题解来对拍，结果无意间用这组数据hack掉两个题解。

```cpp
10 5
39 56 58 26 89 11 86 31 84 21
M 5 9 21
A 1 7 38
M 6 8 80
M 1 2 90
A 1 1 88
```

然后好不容易过了，开始打正确做法，又检查不出错误来，和学弟qwaszx对拍，又把他的给hack了。

```cpp
16 2
1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8
M 10 11 10
A 6 16 10
```


我我我我就想hack掉一个三十分代码有那么难吗

一个三十分代码连着hack掉仨题解，emmmm……

%%%hzwer

%%%rqy

%%%qwaszx


---

## 作者：神之蒟蒻xyk (赞：3)

众所周知，分块是一种非常优美的暴力

这道题听起来方法极其暴力

每块快内sort

但是它过了。。。
码量也不长，八十多行

我爱暴力

我爱分块

我爱C++

```cpp
#include<bits/stdc++.h>
#define fir(a, b, c) for(register int a = b; a <= c; a ++)
using namespace std;
const int N = 1000010;
int n, q, a[N], b[N], l[N], r[N], pos[N];
int t, tag[N];

inline int ask(int x, int y, int k){
	int ans = 0;
	if(pos[x] == pos[y]){
		fir(i, x, y)
			if(a[i] + tag[pos[x]] >= k) ans ++;
		return ans;
	}
	fir(i, x, r[pos[x]])
		if(a[i] + tag[pos[x]] >= k) ans ++;
	fir(i, l[pos[y]], y)
		if(a[i] + tag[pos[y]] >= k) ans ++;
	fir(i, pos[x]+1, pos[y]-1){
		int p = lower_bound(b+l[i], b+r[i]+1, k-tag[i])-b;
		ans += r[i]-p+1;
	}
	return ans;
}

inline void change(int x, int y, int k){
	if(pos[x] == pos[y]){
		fir(i, x, y) a[i] += k;
		fir(i, l[pos[x]], r[pos[x]]) b[i] = a[i];
		sort(b+l[pos[x]], b+r[pos[x]]+1);
		return;
	}
	fir(i, x, r[pos[x]]) a[i] += k;
	fir(i, l[pos[x]], r[pos[x]]) b[i] = a[i];
	sort(b+l[pos[x]], b+r[pos[x]]+1);
	
	fir(i, l[pos[y]], y) a[i] += k;
	fir(i, l[pos[y]], r[pos[y]]) b[i] = a[i];
	sort(b+l[pos[y]], b+r[pos[y]]+1);
	
	fir(i, pos[x]+1, pos[y]-1)
		tag[i] += k;
}

int main(){
	scanf("%d %d", &n, &q);
	fir(i, 1, n) scanf("%d", &a[i]), b[i] = a[i];
	t = sqrt(n);
	fir(i, 1, t) l[i] = (i-1)*t+1, r[i] = i*t;
	if(r[t]<n) t ++, l[t] = r[t-1]+1, r[t] = n;
	t = 1;
	fir(i, 1, n)
		if(i > r[t]) t ++, pos[i] = t;
		else pos[i] = t;
	fir(i, 1, t) sort(b+l[i], b+r[i]+1);
	char opt;
	int x, y, z;
	while(q --){
		cin>>opt; 
		scanf("%d %d %d", &x, &y, &z);
		if(opt == 'A') printf("%d\n", ask(x, y, z));
		else change(x, y, z);
	}
	return 0;
}
```


---

## 作者：MuYC (赞：1)

这道题目其实跟hzwer的数列分块入门２是一样的。~~双倍经验~~

放上链接[[#Loj6278]数列分块入门2](https://loj.ac/problem/6278)

### 题意简述:

现有一段长度为$n$的初始序列，给出$m$个操作每次操作有区间加法以及查询区间$[L,R]$大于等于$c$的数有多少个。

### 思路
首先分析一下题目中的性质，我们要求一段区间内的$[L,R]$内的大于等于c的数的个数。我们想区间$[L,R]$是具有单调性的就好了，我们就可以使用二分来求大于等于c的数的个数了。

#### 对于修改:
发现我们只需要支持的区间修改只有区间加法，假如$[L,R]$区间内的每一个数都被加上了一个数$w$，实际上对于$[L,R]$区间内的数来说，它们的大小关系是不会变的于是我们可以先将每一块内的元素排好，这样子方便查询。

给个例子:
$n$ = $5$

假设修改前的序列为:$1$ $3$ $2$ $4$ $5$

我们对于区间$[3,5]$中的每一个数都加上$w,w = 3$，那么原序列就会变为:

$1$ $3$ $5$ $7$ $8$

所以实际上对于$[L,R]$区间内的数来说，它们的大小关系是不会变的。。

这样子，对于分块中被区间$[L,R]$完全被覆盖的一整个块来说，这个块内的大小关系是不会变的。

那么对于没有被区间$[L,R]$完全覆盖的块呢？那就对于那一个块暴力修改然后sort重新排序，处理这个零散块时间复杂度是:O($block$ * $log(block)$)的，$block$是块长，我们这里取$\sqrt{n}$，所以时间复杂度就是:O$(\sqrt{n}*log(\sqrt{n}))$的。

对于一个整块，我们直接将其$add$数组加上$w$即可，这样子不会破坏块内的单调性质。

#### 对于查询
前面也提到了，我们把每一个块的块内元素都排序成为有序的了，于是乎，查询的过程中：
+ 对于零散的块(即没有被区间$[L,R]$完全覆盖的块)

直接暴力查询即可，时间复杂度O($\sqrt{n}$)

+ 对于被完全覆盖的块 (即完全被区间$[L,R]$覆盖的块)

因为块内元素是有序的，我们采用二分  $or$　倍增来求出$c$的后继(大于等于c的最小的数)即可

时间复杂度:O($\sqrt{n}$ * $log$$(\sqrt{n})$)(一共不超过$\sqrt{n}$个块，对于每一个块的处理是$log(\sqrt{n})$的，于是得到这个时间复杂度)

综上，总的间复杂度为O($m$ * $\sqrt{n}$ * $log$$(\sqrt{n})$)

$m <= 1000,n <= 10^6$，是能过的！于是这道题就做完了，完结撒花！

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000005;
int n , m;
int a[MAXN],N = 0;
int pos[MAXN],L[MAXN],R[MAXN],add[MAXN];

struct Node {
	int num,sum;
} T[MAXN];

int cmp(Node A, Node B){return A.sum > B.sum;}

void Add(int l,int r,int k)
{
	if(pos[l] == pos[r])
	{	//暴力修改即可
		int id = pos[l];
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r)T[i].sum += k;
		sort(T + L[id] , T + R[id] + 1 , cmp);//每次修改后要排序
		return ;
	}
	else 
	{
		int id = pos[l];
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r)T[i].sum += k;
		sort(T + L[id] , T + R[id] + 1 , cmp);//对于零散快修改后要排序
		id = pos[r];
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r)T[i].sum += k;
		sort(T + L[id] , T + R[id] + 1 , cmp);
		for(int i = pos[l] + 1; i <= pos[r] - 1 ; i ++)
			add[i] += k;//直接对于整段的add数组添加即可
		return ;
	}
	return ;
}

int Get(int l,int r,int k)
{
	if(pos[l] == pos[r])
	{
		int id = pos[l],ans = 0;//暴力统计答案即可
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r && T[i].sum + add[id]>= k)ans ++;
		return ans;
	}
	else 
	{
		int id = pos[l],ans = 0;
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r && add[id] + T[i].sum >= k)ans ++;
		id = pos[r];//对于每一个零散块都暴力处理
		for(int i = L[id] ; i <= R[id] ; i ++)
		if(T[i].num >= l && T[i].num <= r && add[id] + T[i].sum >= k)ans ++;
		for(int i = pos[l] + 1; i <= pos[r] - 1 ; i ++)
		{
			int A = 0;
			for(int j = log2(R[i] - L[i] + 1) + 1 ; j >= 0 ; j --)
			if(A + (1 << j)<=R[i] - L[i] + 1)
			if(add[i] + T[L[i] + A + (1 << j) - 1].sum >= k)A += (1 << j);
			ans += A ;//我这里写的倍增，因为二分容易写挂QAQ
		}
		return ans;
	}
}

int main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++)cin >> T[i].sum, T[i].num = i;
	int l = 0 , r = 0;
	int block = int(sqrt(n));
	while(r != n)
	{
		N ++;
		L[N] = l = (N - 1) * block + 1;
		R[N] = r = min(N * block , n );//记录每个块的左右端点
		for(int i = l ; i <= r ; i ++)pos[i] = N;//记录原编号对应的块的编号
		sort(T + l , T + 1 + r , cmp);//预处理排序
	}
	while(m) 
	{
		char op;
		int l,r,x;
		cin >> op >> l >> r >> x;
		if( op == 'M' )Add(l,r,x);
		else cout << Get(l,r,x) << endl;
		m --;
	}
	return 0;
}
```

---

## 作者：SofanHe (赞：1)

# 二次数据加强后仍然能AC的题解...

### 思路:

你们看楼下好了.

### Code&&两次被Hack的地方

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Nmax = 1000010;
const int Kmax = 1010;
int n,q,data[Nmax],srt[Nmax],lnum[1010],rnum[1010],block,num,id[Nmax],add[1010];
//数组说明:data为原始数据,srt为分块排序后的数据,lnum为某个块的最左节点的编号,rnum同理,add为对块的加法标记,id为所在块的编号.
void Build(){
	block=sqrt(n);
	num=n/block;
	if(n%block)
		++num;
	for(int i=1;i<=n;++i){
		id[i]=((i-1)/block)+1;
		srt[i]=data[i];
	}
	for(int i=1;i<=num;++i){
		lnum[i]=(i-1)*block+1;
		rnum[i]=i*block;
	}
	rnum[num]=n;
	for(int i=1;i<=num;++i)
		sort(srt+lnum[i],srt+rnum[i]+1);
}
void updata(int pos1,int pos2,int nd){
	if(id[pos1]==id[pos2]){
		for(int i=pos1;i<=pos2;++i)
			data[i]+=nd;
		for(int i=lnum[id[pos1]];i<=rnum[id[pos1]];++i)
			srt[i]=data[i];
		sort(srt+lnum[id[pos1]],srt+rnum[id[pos1]]+1);
		return;
	}
	for(int p=pos1;p<=rnum[id[pos1]];++p)
		data[p]+=nd;//这是第一次被hack的地方,原因是srt不一定是data是相同位置的,所以srt需要重新更新一次
	for(int p=lnum[id[pos2]];p<=pos2;++p)
		data[p]+=nd;//同上
	for(int p=id[pos1]+1;p<id[pos2];++p)
		add[p]+=nd;
	for(int p=lnum[id[pos1]];p<=rnum[id[pos1]];++p)
		srt[p]=data[p];
	sort(srt+lnum[id[pos1]],srt+rnum[id[pos1]]+1);
	for(int p=lnum[id[pos2]];p<=rnum[id[pos2]];++p)
		srt[p]=data[p];
	sort(srt+lnum[id[pos2]],srt+rnum[id[pos2]]+1);
}
int check(int p,int w){
	int ll=lnum[p],rr=rnum[p];
	while(ll<=rr){
		int mid=(ll+rr)>>1;
		if(srt[mid]<w)ll=mid+1;
		else rr=mid-1;
	}
	return rnum[p]-ll+1;
}
int ask(int pos1,int pos2,int k){
	int ans=0,nk=0;
	if(id[pos1]==id[pos2]){
		nk=k-add[id[pos1]];//第二次被hack的地方,原因是对于整块的我们并没有搞到每一个值上,而是在块上标记,所以k需要减去加法标记
		for(int i=pos1;i<=pos2;++i)
			if(data[i]>=nk)
				++ans;
		return ans;
	}
	nk=k-add[id[pos1]];//同上
	for(int p=pos1;p<=rnum[id[pos1]];++p)
		if(data[p]>=nk)++ans;
	nk=k-add[id[pos2]];//同上
	for(int p=lnum[id[pos2]];p<=pos2;++p)
		if(data[p]>=nk)++ans;
	for(int p=id[pos1]+1;p<id[pos2];++p)
		ans+=check(p,k-add[p]);
	return ans;
}
char opt;int p1,p2,p3;
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;++i)
		scanf("%d",&data[i]);
	Build();
	for(int i=1;i<=q;++i){
		for(opt=getchar();opt!='A'&&opt!='M';opt=getchar());
		scanf("%d%d%d",&p1,&p2,&p3);
		switch(opt){
			case 'A':
				printf("%d\n",ask(p1,p2,p3));
				break;
			case 'M':
				updata(p1,p2,p3);
				break;
		}
	}
	return 0;
}
```

---

## 作者：1saunoya (赞：0)

我们看到这个 $\mathcal{N <=1e6}$ 

$\text{都能想到一个}$
$\mathcal{N \sqrt N}$  $\text{的分块做法}$ 

$\text{如果你不会分块}$ - > [here](https://www.cnblogs.com/qf-breeze/p/11361618.html)

$\text{这题就是一个分块2}$ -> [here](https://loj.ac/problem/6278)

$\text{简单讲 分块2 是要求 求出来 小于}$ $c^2$ $\text{的个数}$

$\text{然后套用这题的板子我不到1分钟就写掉了(划掉}$

$\text{这题是要求}$ `区间修改` `区间查询有多少个大于c的数量`

$\text{所以我们只需要查出来 多少个小于c的然后(r-l+1) - query(l,r,c)就可以了}$


复杂度 $\mathcal{N \sqrt N}$
=

$\mathcal{Code}$


```cpp
// Isaunoya
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC diagnostic error "-std=c++11"
#include<bits/stdc++.h>
#define int long long
using namespace std ;
#define rep(i , j , n) for(register int i = j ; i <= n ; i ++)
#define Rep(i , j , n) for(register int i = j ; i >= n ; i --)
#define low(x) x & -x
#define go(u) for(register int i = head[u] ; i ; i = e[i].nxt)
inline int read() { register int res = 0 , f = 1 ; register char c = getchar() ;
    for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
    for( ; isdigit(c) ; c = getchar()) res = (res << 1) + (res << 3) + (c & 15) ;
    return res * f ;
}const static int N = 1000000 + 5 ;
const int Mod = 998244353LL ;
template<typename T> inline void print(T x) { if(x > 9)  print(x / 10) ; putchar(x % 10 + '0') ; }
template<typename T> inline void Pr(T x , char c = '\n') { if(x < 0) putchar('-') , x = - x ; print(x) ; putchar(c) ; }
inline int PW(int x , int y , int Mod = Mod) { register int ans = 1 ;
    for( ; y ; y >>= 1 , x = (x * x) % Mod) y & 1 ? ans = (ans * x) % Mod : 0 ;
    return ans ;
} inline int Inv(int x , int Mod = Mod) { return PW(x , Mod - 2 , Mod) ; }
inline int gc() { register char c = getchar() ;
	while(isspace(c)) c = getchar() ;
	return c == 'A' ;
}
const int Bl = 1000 + 5;
int n;
int a[N];
struct node {
    int add;
    std::vector<int> v;
};
node atag[Bl];
int unt;
int bl[N];
inline void reset(int x) {
    atag[x].v.clear();
    for (register int i = (x - 1) * unt + 1; i <= min(x * unt, n); i++) atag[x].v.push_back(a[i]);
    sort(atag[x].v.begin(), atag[x].v.end());
    return;
}
inline void change(int l, int r, int c) {
    for (register int i = l; i <= min(bl[l] * unt, r); i++) a[i] += c;
    reset(bl[l]);
    if (bl[l] != bl[r]) {
        for (register int i = (bl[r] - 1) * unt + 1; i <= r; i++) a[i] += c;
        reset(bl[r]);
    }
    for (register int i = bl[l] + 1; i <= bl[r] - 1; i++) atag[i].add += c;
}
inline int query(int l, int r, int c) {
    int ans = 0;
    for (register int i = l; i <= min(bl[l] * unt, r); i++)
        if (a[i] + atag[bl[l]].add < c)
            ans++;
    if (bl[l] != bl[r]) {
        for (register int i = (bl[r] - 1) * unt + 1; i <= r; i++)
            if (a[i] + atag[bl[r]].add < c)
                ans++;
    }
    for (register int i = bl[l] + 1; i <= bl[r] - 1; i++) {
        int s = c - atag[i].add;
        ans += lower_bound(atag[i].v.begin(), atag[i].v.end(), s) - atag[i].v.begin();
    }
    return ans;
}
signed main() {
    n = read(); int t = read() ; unt = sqrt(n) ;
    for (register int i = 1; i <= n; i++) a[i] = read();
    for (register int i = 1; i <= n; i++) bl[i] = (i - 1) / unt + 1;
    for (register int i = 1; i <= n; i++) {
        atag[bl[i]].v.push_back(a[i]);
    }
    for (register int i = 1; i <= bl[n]; i++) {
        sort(atag[i].v.begin(), atag[i].v.end());
    }
    for( ; t -- ; ) {
    	int opt = gc() ;
    	int l = read() , r = read() , c = read() ;
    	if(opt == 0) {
    		change(l , r , c) ;
		}
		if(opt == 1) {
			Pr((r - l + 1) - query(l , r , c)) ;
//			rep(i , 1 , n) Pr(a[i] + atag[bl[i]].add , ' ') ;
//			puts("") ;
		}
	}
    return 0;
}
```

---

## 作者：MikukuOvO (赞：0)

### 题目大意

给定一个序列，有两种操作：

（1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有数加上W。

（2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少数大于等于C。

### 题目分析

对于第一种操作，很显然线段树是可以支持的，但是对于第二种操作线段树就显得比较无力了，对于区间问题，分块虽然时间复杂度略差，但是还是可以优化线段树优化不了的暴力的。

看到有多少数大于等于C，我们可以做一个小转化：如果一个序列是有序的，那么我们直接利用lower_bound二分查询就可以了，所以我们对于每一个块，都要维护它是有序的。

我们对于第一种操作，零散部分直接暴力，整个块部分加上标记。由于整个块集体加标记不会影响相对顺序，所以只有零散部分需要重新排序。

而对于第二种操作，我们对于零散部分直接暴力判断，整块部分二分查找，答案求和即可，不要忘记C要减去当前块的标记。

### 性能分析

第一种操作sqrt(n)+sqrt(n)log(sqrt(n))
第二种操作sqrt(n)+sqrt(n)log(sqrt(n))
总复杂度q(sqrt(n)+sqrt(n)log(sqrt(n))

### 代码实现

块的大小微调一下，防止毒瘤数据。。。

```cpp
//Head File _DAG_
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<deque>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
using namespace std;

//Debuger _DAG_
#define dej printf("Running\n");
#define dep1(x) cout<<#x<<"="<<x<<endl;
#define dep2(x,y) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<endl;
#define dep3(x,y,z) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<' '<<#z<<"="<<z<<endl;

//Replace _DAG_
#define LL long long
#define LB long double
#define reg register
#define il inline
#define inf 2147483644

//DTL _DAG_
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define abs(a) (((a)>(0))?(a):(-(a)))
#define UF(i,a,b) for(reg int i=a;i<=b;i++)
#define DF(i,a,b) for(reg int i=a;i>=b;i--)
#define SUF(c,a,b) for(reg int *S=c+a,*E=c+b+1;*S!=*E;*S++)
#define SDF(c,a,b) for(reg int *S=c+a,*E=c+b-1;*S!=*E;*S--)

//Sorce Limit _DAG_
#define maxn 1000005
#define maxm 1005

int n,q,size;
int a[maxn],blockl[maxn],marks[maxm];
vector<int>v[maxm];

il int read()
{
  int w=0;char ch=getchar();
  while(ch<'0'||ch>'9') ch=getchar();
  while(ch>='0'&&ch<='9') w=(w<<3)+(w<<1)+ch-'0',ch=getchar();
  return w;
}
il void merge(int x)
{
  v[x].clear();
  UF(i,(x-1)*size+1,min(x*size,n)) v[x].push_back(a[i]);
  sort(v[x].begin(),v[x].end());
}
il void add(int x,int y,int z)
{
  UF(i,x,min(blockl[x]*size,y)) a[i]+=z;
  merge(blockl[x]);
  if(blockl[x]!=blockl[y])
  {
    UF(i,(blockl[y]-1)*size+1,y) a[i]+=z;
    merge(blockl[y]);
  }
  UF(i,blockl[x]+1,blockl[y]-1) marks[i]+=z;
}
il int query(int x,int y,int z)
{
  int ans=0;
  UF(i,x,min(blockl[x]*size,y)) if(a[i]+marks[blockl[x]]>=z) ans++;
  if(blockl[x]!=blockl[y]) UF(i,(blockl[y]-1)*size+1,y) if(a[i]+marks[blockl[y]]>=z) ans++;
  UF(i,blockl[x]+1,blockl[y]-1)
  {
    int temp=z-marks[i];
    ans+=v[i].end()-v[i].begin()-(lower_bound(v[i].begin(),v[i].end(),temp)-v[i].begin());
  }
  return ans;
}
int main()
{
  n=read(),q=read();
  size=sqrt(n)+1;
  UF(i,1,n) a[i]=read();
  UF(i,1,n) blockl[i]=(i-1)/size+1,v[blockl[i]].push_back(a[i]);
  UF(i,1,blockl[n]) sort(v[i].begin(),v[i].end());
  UF(i,1,q)
  {
    char s[2];
    scanf("%s",s);
    int x=read(),y=read(),z=read();
    if(s[0]=='M') add(x,y,z);
    else printf("%d\n",query(x,y,z));
  }
  return 0;
}


---

## 作者：张亦弛 (赞：0)

这道题乍一看，是区间修改+查询，以为是线段树，结果发现线段树做不了。

其实这道题就是一个分块。

分块的思想就是把整个数列分成sqrt(n)块，然后对每一块进行操作。

其中需要特别处理的，是左边和右边的一小段不在整块大区间内的部分。

具体看代码（自认为写得很短了）

代码如下（注释很详细的）：

------------


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
int bl, a[N], b[N], n, AD[1010];
          
void add(int l, int r, int w)
{
//左边一小块 
    int lp = min(r, (l / bl + 1) * bl - 1);//左边的一小块的右端点 
    for (int i = l; i <= lp; i++)
		a[i] += w;//这段小块区间直接加 
    for (int i = l/bl*bl; i < min((l/bl+1)*bl, n); i++)
		b[i] = a[i];//从这段小块区间复制下来排序 
    sort(b + (l/bl*bl), b + min((l/bl+1)*bl, n));//排序 
    if(lp == r)//如果是单点，跳过下面 
		return;
//右边一小块 
    int rp = r / bl * bl;//右边一小块的左端点 
    for (int i = rp; i <= r; i++)
		a[i] += w;//这段小块区间直接加 
    for (int i = rp; i < (r/bl+1)*bl; i++)
		b[i] = a[i];//这段小块区间复制下来排序 
    sort(b + rp, b + ((r/bl+1)*bl));//排序 
//处理中间整块的加 
    int t = (lp + 1) / bl;//整块的左端点 
    while(t * bl < rp)//整块整块的加，知道右端点 
		AD[t++] += w;//AD记录的是整块区间的加
}

int query(int l, int r, int w) 
{
    int ret = 0;
//左边一小块 
    int lp = min(r, (l / bl + 1) * bl - 1);//左边的一小块的右端点 
    for (int i = l; i <= lp; i++) 
		if(a[i] + AD[i/bl] >= w)//i/bl就是i所在的块 
			ret++;//>=w就累加 
    if(lp == r) //如果是单点，跳过下面 
		return ret;
//右边一小块 
    int rp = r / bl * bl;//右边一小块的左端点
    for (int i = rp; i <= r; i++) 
		if(a[i] + AD[i/bl] >= w)//i/bl就是i所在的块
			ret++;//>=w就累加 
//下面是处理中间的整块部分 
    int t = (lp+1) / bl;//整块的左端点 
    while(t * bl < rp) 
	{
        int L = t * bl, R = (t+1) * bl - 1;//l是一块的左端点，r是右端点 
        while(L < R)//因为每一块都是是排好序的，所以二分找到>=w的 
		{
            int Mid = (L + R) >> 1;//二分中间值 
            if(b[Mid] + AD[Mid/bl] >= w)//mid/bl就是mid所在的块
				R = Mid;//如果>=w的，左移 
            else L = Mid + 1;//否则右移 
        }
        ret += (t+1)*bl - R;//计算这段之间有多少个>=w的,即块的右端点-二分得到的断点 
        if(R == (t+1)*bl-1 && b[R] + AD[R/bl] < w)//如果整个块里面都没有>=w的 
			ret--;//减去包含了自己的1个 
        t++;//继续下一个块 
    }
    return ret;//返回有多少>=w的 
}

int main() {
    int Q, L, R, w;
    cin >> n >> Q;//n个数，Q个询问 
    for (int i = 0; i < n; i++) 
		cin >> a[i];//读入数列 
    bl = sqrt(n); //每一块的长度 
    for (int i = 0; i < n; i++)
		b[i] = a[i];//复制下来 
    for (int i = 0; i < n; i += bl)
        sort(b + i, b + min(i+bl, n)) ;//给每一块排序 
    char op[10];
    while(Q--)//询问 
	{
        scanf("%s%d%d%d", op, &L, &R, &w);
        L--; R--;//因为是从0开始的 
        if(op[0] == 'M')//区间加 
			add(L, R, w);
        else//区间查询 
			printf("%d\n", query(L, R, w));
    }
    return 0;
}
```

---

## 作者：大菜鸡fks (赞：0)

裸题一道。然而我并没有一下想到

这题第一眼是分块+树状数组。后来发觉空间复杂度貌似有点问题。（时间复杂度可能可以卡过去？？）

又想了想发现排序就可以了。

查询：大块二分查询，小块暴力一遍。

更新：大块打标记（因为加法标记不影响排列顺序），小块暴力加完之后重构。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxb=1e4+5,maxn=1e6+5;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
struct node{
	int x,id;
}a[maxn];
int n,q,l[maxb],r[maxb],block,cnt,belong[maxn];
inline void init(){
	n=read(); q=read(); block=(int)sqrt(n);
	for (int i=1;i<=n;i++){
		a[i].x=read(); a[i].id=i; 
		belong[i]=(i-1)/block+1;
	}
	cnt=belong[n];
	for (int i=1;i<=cnt;i++){
		l[i]=r[i-1]+1;
		r[i]=i*block;
	}
}
inline bool cmp(node A,node B){
	return A.x<B.x;
}
int plu[maxb];
inline void rebuild(int x){
	for (int i=l[x];i<=r[x];i++){
		a[i].x+=plu[x];
	}
	sort(a+l[x],a+r[x]+1,cmp);
	plu[x]=0;
}
inline void work(int x,int L,int R,int W){
	for (int i=l[x];i<=r[x];i++){
		if (a[i].id>=L&&a[i].id<=R){
			a[i].x+=W;
		}
	}
	rebuild(belong[L]);
}
inline void plus(int L,int R,int W){
	int ll=belong[L]+1,rr=belong[R]-1;
	for (int i=ll;i<=rr;i++) plu[i]+=W;
	work(belong[L],L,R,W);
	if (belong[L]!=belong[R]){
		work(belong[R],L,R,W);
	}
}
inline int find(int x,int w){
	int L=l[x],R=r[x];
	if (a[r[x]].x<w) return 0;
	while (L<R){
		int mid=(L+R)>>1;
		if (a[mid].x>=w) R=mid;
			else L=mid+1;  
	}
	return r[x]-L+1;
}
inline int qu(int x,int L,int R,int W){
	int ans=0;
	for (int i=l[x];i<=r[x];i++){
		if (a[i].id>=L&&a[i].id<=R){
			if (a[i].x+plu[x]>=W) ans++;
		}
	}
	return ans;
}
inline int query(int L,int R,int W){
	int ll=belong[L]+1,rr=belong[R]-1,ans=0;
	for (int i=ll;i<=rr;i++) ans+=find(i,W-plu[i]);
	ans+=qu(belong[L],L,R,W);
	if (belong[L]!=belong[R]){
		ans+=qu(belong[R],L,R,W);
	}
	return ans;
}
inline void solve(){
	for (int i=1;i<=cnt;i++){
		sort(a+l[i],a+r[i]+1,cmp);
	}
	for (int i=1;i<=q;i++){
		char s[10]; int L,R,W;
		scanf("%s",s+1);
		L=read(); R=read(); W=read();
		if (s[1]=='M') plus(L,R,W); 
			else writeln(query(L,R,W));
	}
}
int main(){
	init();
	solve();
	return 0;
} 
```

---


# 双亲数

## 题目描述

小 D 是一名数学爱好者，他对数字的着迷到了疯狂的程度。

我们以 $d = \gcd(a, b)$ 表示 $a, b$ 的最大公约数，小 D 执著的认为，这样亲密的关系足可以用双亲来描述，此时，我们称**有序**数对 $(a, b)$ 为 $d$ 的双亲数。

与正常双亲不太相同的是，对于同一个 $d$，他的双亲太多了。

比如，$(4, 6)$，$(6, 4)$，$(2, 100)$ 都是 $2$ 的双亲数。  

于是一个这样的问题摆在眼前，对于 $1 \leq a \leq A$，$1 \leq b \leq B$，有多少**有序**数对 $(a, b)$ 是 $d$ 的双亲数？

## 说明/提示

#### 样例 1 解释

共有三对双亲数：$(2, 2)$，$(2, 4)$，$(4, 2)$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $1 \leq A, B \leq 10^6$。
- 对于 $100\%$ 的数据，保证 $1 \leq A, B \leq 10^6$，$1 \leq d \leq \min(A, B)$。

## 样例 #1

### 输入

```
5 5 2
```

### 输出

```
3```

# 题解

## 作者：黑影洞人 (赞：28)

提供一种超短的做法

我们设 $f(d)$ 为 $1≤a≤A,1≤b≤B$ 中 $\gcd(a,b)=d$ 的二元组个数。

如何求 $f(d)$ 成为本题的关键，我将用计数DP来解决。

我们打一个表观察一下 $\gcd(a,b)$。


```
1 1 1 1 1 1 1 1 1 1
1 2 1 2 1 2 1 2 1 2
1 1 3 1 1 3 1 1 3 1
1 2 1 4 1 2 1 4 1 2
1 1 1 1 5 1 1 1 1 5
1 2 3 2 1 6 1 2 3 2
1 1 1 1 1 1 7 1 1 1
1 2 1 4 1 2 1 8 1 2
1 1 3 1 1 3 1 1 9 1
1 2 1 2 5 2 1 2 1 10
```
我们设函数 $g(d)$ 是 $\sum_{(a,b)}d| \gcd(a,b)$。

如图，可以很直观的发现 $g(d)$ 实际上就是 $(A/d)*(B/d)$。

我们可以很直观的发现，$g(d)=f(d)+f(2d)+f(3d)……+f(\lfloor \frac{n}{d} \rfloor*d)$。

于是我们反向推一下 $f(d)=g(d)- f(2d)-f(3d)……-f(\lfloor \frac{n}{d} \rfloor*d)$ , 并且有边界条件 $g(n)=f(n)=1$。

于是我们就得到了 $f(d)$ 的逆推式。

上代码：

```
#include<cstdio>
#include<algorithm>
#define int long long
#define N 100000006
using namespace std;
int k,g[N],f[N],ans,n,m,sum,Ch;
signed main(){
	scanf("%lld%lld%lld",&n,&m,&Ch);
	if(n>m)swap(n,m);
	for(int k=n;k>=1;k--){
		g[k]=(n/k)*(m/k);
		f[k]=g[k];
		for(int j=2;j<=(n/k);j++)f[k]-=f[j*k];
	}
	printf("%lld",f[Ch]);
	return 0;
}
```
算法时间复杂度为 $O(nH(n))$，其中 $H(n)$ 为调和级数和，求一下积分可以知道时间复杂度约为 $O(n \ln n)$

---

## 作者：fzwfzwfzw (赞：19)

### 我是刚学莫比乌斯反演的萌新，第一次写莫反题解，如果有什么地方看不懂可以私信我~~~

对于 1≤a≤A，1≤b≤B，有多少有序数对 (a, b) 是 D 的双亲数？

由题意得

## $\sum ^{A}_{a=1}\sum ^{B}_ {b=1}(\gcd \left( a,b\right)==D)$
 

### 注意 $\lfloor A\rfloor$ 是将A向下取整的意思


## $\sum^{\lfloor \frac{A}{D} \rfloor}_{{a}=1}\sum^{\lfloor \frac{B}{D} \rfloor}(\gcd \left( a,b\right)==1)$

我们需要用到$\mu$

### $\mu $的性质是这样的：
## $(\gcd \left( a,b\right)==1)=\sum_{d|a ,d|b}\mu\left(d\right)$

原式等于

## $\sum^{\lfloor \frac {A}{D}\rfloor}_{{a}=1}\sum^{\lfloor \frac {B}{D}\rfloor}_{{b}=1}\sum_{d|a ,d|b}\mu\left(d\right)$

我们选择枚举d 


## $\sum^{\min({\lfloor \frac {A}{D}\rfloor},\lfloor \frac {B}{D}\rfloor)}_{d=1}\mu(d)\sum^{\lfloor \frac {A}{Dd}\rfloor}_{a=1}\sum^{\lfloor \frac {B}{Dd}\rfloor}_{b=1}1$


## $\sum^{\min({\lfloor \frac {A}{D}\rfloor},\lfloor \frac {B}{D}\rfloor)}_{d=1}\mu(d){\lfloor \frac {A}{Dd}\rfloor}{\lfloor \frac {B}{Dd}\rfloor}$

 我们可以使用整除分块$O(\sqrt {n})$求出来答案

 推荐一篇dalao写的blog

[关于整除分块](https://www.luogu.com.cn/blog/command-block/zheng-chu-fen-kuai-ru-men-xiao-ji)

### 代码时间！

#### 小技巧：

```
#define int long long
signed main()
```
#### 就开上了longlong了
```cpp
#include<bits/stdc++.h>
#define int long long//小技巧
using namespace std;
int read()//快读
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int A,B,D;
int mu[1000005];//筛mu
int qzh[1000005];//前缀和
int prim[1000005];//素数（欧拉筛 ）
int vis[1000005];//标记
void pre()//处理
{
	mu[1]=1;
	int cnt=0;
	for(int i=2;i<=1e6;i++)
	{
		if(!vis[i])
		{
			prim[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt;j++)
		{
			if(i*prim[j]>1e6)break;
			vis[i*prim[j]]=1;
			if(i%prim[j]==0)
			{
				mu[i*prim[j]]=0;break;
			}
			mu[i*prim[j]]=-mu[i];
		}
	}
	for(int i=1;i<=1e6;i++)
	{
		qzh[i]=qzh[i-1]+mu[i];
	}
}
int ask(int x,int y)//整除分块询问！！！！
{
	int ans=0,r;
	for(int l=1;l<=min(x,y);l=r+1)
	{
		r=min(x/(x/l),y/(y/l));
		ans+=(qzh[r]-qzh[l-1])*(x/l)*(y/l);
	}
	return ans;
}
signed main(){
	pre();
	A=read();
	B=read();
	D=read();
	A/=D;//其实这里可以提前除以D的
	B/=D;
	cout<<ask(A,B)<<endl;
	return 0;
}
```

#### 本人就不做防抄袭了，方便大家理解

#### [提交记录](https://www.luogu.com.cn/record/34151590)

#### 祝大家好运！！！

---

## 作者：Isonan (赞：9)


（前言）本文借鉴了[dalao的博客](https://www.luogu.org/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi)，看了这篇文章才终于明白了莫比乌斯反演该怎么打。多谢dalao！！

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P4450)

网上的的莫比乌斯反演讲稿都讲了很多不明觉厉的公式，搞得我很久都没懂，看了一些题目和dalao的博客以后才发现。。其实有很多公式是不需要的！

实际编程时，很多公式并不需要搞得那么复杂，于是我先写一篇面向OI的学习笔记，以后有时间再更新更奇葩的数学部分。

首先定义莫比乌斯函数 $μ(n)$：

$$\largeμ(n)=\begin{cases}1&n==1\\(-1)^k&n=p_1p_2p_3..p_k\\0&otherwise\end{cases}$$

我们可以通过简单的证明得到$μ(n)$的性质如下：


$$\sum_{d|n}μ(d)=[n=1]$$

下面是简单的证明：

我们知道，当且仅当n由若干互不相同的质数相乘而来时，$μ(n)$不为0。因此我们考虑枚举n的因子中的素数个数。设n有k个质因数，则：

$$\sum_{d|n}μ(d)=C_k^0(-1)^0+C_k^1(-1)^1+..+C_k^k(-1)^k$$

通过二项式定理可知，k>1时上式等于$(1+(-1))^k=0$。

证毕。

这道题求的是$$\sum_{i=1}^{A}\sum_{j=1}^{B}[gcd(i,j)==k]$$

我们把这个式子化简一下，将A,B同除以k。

于是此题即为求$$\sum_{i=1}^{A}\sum_{j=1}^{B}[gcd(i,j)==1]$$

套用$μ(n)$的性质，则上式即为

$$\sum_{i=1}^{A}\sum_{j=1}^{B}\sum_{d|gcd(i,j)}μ(d)$$

考虑当$d|gcd(i,j)$时，$i\in\{d,2d,3d,..\}\cap\{1,2,3,..,n\}$,因此有$|\frac{A}{d}|$种取值。同理，$j$有$|\frac{B}{d}|$种取值（写得有些啰嗦大佬们勿喷）。所以上式可化简为

$$\sum_{d=1}^{n}μ(d)*|\frac{A}{d}|*|\frac{B}{d}|$$

做到这里已经降了很多复杂度可以进行$O(n)$的枚举了。然而这里数据出得很大，连$O(n)$也过不去。这时候就要用整除分块把复杂度降到$O(\sqrt{n})$

但是这个整除分块有些不一样，每次只能操作$|\frac{A}{d}|$与$|\frac{B}{d}|$都相同的部分，所以需要特殊处理。

再加上一段线性筛$μ(n)$的代码，就可以AC了。

代码：

```cpp
#include <cstdio>
#define min(X,Y) ((X)<(Y)?(X):(Y))

long long mobius[1000001],A,B,d,prime[1000001],tot,ans;
bool check[1000001];
int main(){
	scanf("%lld%lld%lld",&A,&B,&d);
	mobius[1]=1;
	A/=d;
	B/=d;
	if(A>B)A^=B^=A^=B;
	for(register int i=2;i<=A;i++){
		if(!check[i]){
			mobius[i]=-1;
			prime[++tot]=i;
		}
		for(register int j=1;j<=tot;j++){
			if(i*prime[j]>A)break;
			check[i*prime[j]]=1;
			if(i%prime[j]==0){
				mobius[i*prime[j]]=0;
				break;
			}
			mobius[i*prime[j]]=-mobius[i];
		}
	}
	for(register int i=2;i<=A;i++)mobius[i]+=mobius[i-1];
    for(register int i=1,j;i<=A;i=j+1)
    {
        j=min(A/(A/i),B/(B/i));
        ans+=(A/i)*(B/i)*(mobius[j]-mobius[i-1]);
    }
    printf("%lld",ans);
}
```

---

## 作者：Yyxxxxx (赞：6)

多倍经验题，刚好做到这里想写一写题解
### 莫比乌斯函数
- 定义  

$\mu(n)=\begin{cases}
-1& n=1  \\
0  & i\in N^* ,i^2|n \\
(-1)^k&n=a_1a_2a_3...a_t(\forall i,j,[1 \le i,j,\le t;i\ne j],a_i\ne a_j)
\end{cases}$

- 性质   

$\sum\limits_{d|n}^{}\mu(d)=\begin{cases}
1&n=1\\
0&n\ne 1\\
\end{cases}$  

$\begin{cases}
1&n=1\\
0&n\ne 1\\
\end{cases}$

也可以记作$[n=1]$，意义为，括号为正值为$1$, 否则值为$0$ $($即括号内表达式返回值$)$
故可以表示为：  

$\sum\limits_{d|n}^{}\mu(d)=[n=1]$
- $\mu$是$1$的逆元

前置：$n$不同的质因子个数为$t$
 
$\mu* 1$

$=\sum\limits_{d|n}\mu(d)1(\frac{n}{d})$

$=\sum\limits_{d|n}\mu(d)$

$=\sum\limits_{i=0}^k(-1)^k\dbinom{k}{i}$

由二项式定理得 ~~（不会的赶紧去百度~~：

$(x-y)^k$

$=\sum\limits_{i=0}^kx^iy^{x-i}\dbinom{k}{i}$  

特解：  

$x=-1,y=1$时

$(-1+1)^k=\sum\limits_{i=0}^k(-1)^k\cdot1\cdot\dbinom{k}{i}$

故：

$\mu* 1=\sum\limits_{i=0}^k(-1)^k\dbinom{k}{i}=0^k$   

这里$0^0$只有当 $n=1,\mu(n)=1$时出现，刚好符合：

$\epsilon(n)=[n=1]$

$\therefore\mu* 1=\epsilon$
### 莫比乌斯反演
- 式子  

设两函数 $f(x),g(x)$

$g(n)=\sum\limits_{d|n}^{}f(d)\iff f(x)=\sum\limits_{d|n}^{}\mu(d)f(\frac{n}{d})$   

另一形式

$g(n)=\sum\limits_{n|d}^{}f(d)\iff f(x)=\sum\limits_{n|d}^{}\mu(\frac{d}{n})f(d)$   
- 证明(1)

前置：$g=f* 1$

$g(n)=\sum\limits_{d|n}f(d)1(\frac{n}{d})$

$g(n)=\sum\limits_{d|n}f(d)$

$\because g=f* 1$

$g*\mu=f* 1*\mu$

$f=g*\mu$

$f(n)=\sum\limits_{d|n}g(d)\mu(\frac{n}{d})$

$\therefore g(n)=\sum\limits_{d|n}^{}f(d)\iff f(x)=\sum\limits_{d|n}^{}\mu(d)f(\frac{n}{d})$

- 证明(2)

前置：$g(n)=\sum\limits_{n|d}^{}f(d),k=\frac{d}{n}$，$t$是$nk$的倍数

$\sum\limits_{n|d}^{}\mu(\frac{d}{n})f(d)$

$=\sum\limits_{k}\mu(k)f(nk)$

$=\sum\limits_{k}({\mu(k)\sum\limits_{(nk)|t}f(t)})$   
先枚举$t:$

$=\sum\limits_{t}(f(t)\sum\limits_{(nk)|t}\mu(k))$

$=\sum\limits_t(f(t)\sum\limits_{(k|\frac{n}{t})}\mu(k)))$

$=\sum\limits_{t}f(t)\mu(\frac{n}{t})*1$

$=\sum\limits_tf(t)\epsilon(\frac{n}{t})$

$\frac{n}{t}=1,n=t$时,式子有值

故原式

$=f(n)$
### 反演应用
- 题意

给定$d$，求$\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)=d]$

- 反演

$\because [gcd(i,j)=d]$

$\therefore \sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)=d]$

$=\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[gcd(i,j)=1]$

设：

$f(x)=\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[gcd(i,j)=x]$

$g(x)=\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[x|gcd(i,j)]$

$f(x)$表示最大公因数是$x$的点对

$g(x)$表示公因数是$x$的点对

显然有：

$g(x)=\sum\limits_{x|k,k \le n}f(x)$

~~一波~~反演~~猛如虎~~：

$f(x)=\sum\limits_{x|k}f(x)\mu(\frac{k}{x})\iff f(x)=\sum\limits_{x|k}\mu(x)f(\frac{k}{x})$

$g(x)=\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{m/d}[x|gcd(i,j)]$

$=\sum\limits_{i=1}^{\frac{n}{dx}}\sum\limits_{j=1}^{\frac{m}{dx}}[1|gcd(i,j)]$

$=\sum\limits_{i=1}^{\frac{n}{dx}}\sum\limits_{j=1}^{\frac{m}{dx}}1$

$=\lfloor\frac{n}{dx}\rfloor\cdot\lfloor\frac{m}{dx}\rfloor$

故答案为：

$f(1)=\sum\limits_{i=1}^n\mu(i)\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor$

数论分块一下就可以$O(\sqrt{n})$做完啦！    
分块不会的话[[P1403]](https://www.luogu.com.cn/problem/P1403)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e6+1;
ll ans,sum[maxn],mu[maxn],prime[maxn],cnt;
bool used[maxn];
inline void get_mu(ll n)//线性筛mu，和筛素数差不多
{
    mu[1]=1;//加了这行
    for(int i=2;i<=n;i++)
    {
        if(!used[i]){prime[++cnt]=i;mu[i]=-1;}//这行
        for(int j=1;j<=cnt&&i*prime[j]<=n;++j)
        {
            used[i*prime[j]]=1;
            if(i%prime[j]==0)break;
            else mu[i*prime[j]]=-mu[i];//这行
        }
    }
    for(int i=1;i<=n;i++)sum[i]=sum[i-1]+mu[i];//还有这行
}
int main()
{
    ll n,m,k;
    scanf("%lld%lld%lld",&n,&m,&k);
    int x=max(n,m);
    get_mu(x);
    ll ans=0;
    for(int l=1,r;l<=n;l=r+1)//分块
    {
        r=min(n/(n/l),m/(m/l));
        ans+=(n/(l*k))*(m/(l*k))*(sum[r]-sum[l-1]);
    }
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：fa_555 (赞：5)

**upd：256 天后的更新，修复了错误和公式格式，充实了内容**

**如果 $\LaTeX$ 渲染挂了请移步[洛谷博客](https://www.luogu.com.cn/blog/fa555/solution-p4450)或[个人博客](https://fa555.github.io/2019/%E9%A2%98%E8%A7%A3-P4450-%E3%80%90%E5%8F%8C%E4%BA%B2%E6%95%B0%E3%80%91/)**

under 题解 [P4450](https://www.luogu.org/problem/P4450)

*蒟蒻第一道莫反题*

*本题解适合新手学习基础，dalao 请跳过，不要嘲讽 qwq*

---

### 前置知识：

#### 单位函数（$\epsilon$）：

$$
\epsilon(i) = \begin{cases}
1 &, i = 1 \\
0 &, i \ne 1
\end{cases}
$$

即当且仅当 `i = 1` 时取值取值为 `1`，否则为 `0`。很简单对不对？

#### Dirichlet 卷积($\ast$)：

Dirichlet 卷积是数论函数之间的运算。即

$$
h = f \ast g
$$

其中 $f, g, h$ 均为数论函数。则

$$
h(n) = \sum_{d | n}{f(d) g \left(\frac nd \right)}
$$

也可以写作

$$
h(n) = \sum_{i · j = n}{f(i) g(j)}
$$

我们发现：$\epsilon$ 函数是 Dirichlet 卷积的单位元，即 $f = f \ast \epsilon$。

#### Mobius 函数($\mu$)：
$$
\mu(n) = \begin{cases}
1 &, n = 1 \\
(-1)^m &, n = p_1p_2 \cdots p_m \\
0 &, \mathrm{otherwise}
\end{cases}
$$

其中 $p_1,p_2, \cdots, p_m$ 是不同的质数。$\mu(n)$ 恰在 $n$ 无平方因子时取值非零。显然 $\mu$ 是积性函数。

$$
\begin{aligned}
\sum_{d | n}{\mu(d)} &= \epsilon(n) \\
\epsilon &= 1 \ast \mu
\end{aligned}
$$

#### Mobius 变换

设 $f$ 是数论函数，若数论函数 $g$ 满足

$$
\begin{aligned}
g &=  f * \mathbf1 \\
\textrm{That is} \quad g(n) &= \sum_{d | n}{f(d)}
\end{aligned}
$$

则称 $g$ 是 $f$ 的 Mobius 变换。

推一下式子。

$$
g = f \ast 1 \Rightarrow f = f \ast \epsilon = f \ast 1 \ast \mu = g \ast \mu
$$

即

$$
g = f \ast 1 \Leftrightarrow f = g \ast \mu
$$

至此就可以来做这道题了。

---

回到了原题。题目要求的是

$$
\sum_{i = 1}^A{\sum_{j = 1}^B{[\gcd(i, j) = d]}}
$$

对式子进行套路性的变形

$$
\sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{[\gcd(i, j) = 1]}}
$$

出现了 $[ \gcd(i, j) = 1]$，也即 $\epsilon( \gcd(i, j))$。把 $\epsilon = 1 \ast \mu$ 代入，得到了

$$
\sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{\sum_{g | \gcd(i, j)}{\mu(g)}}}
$$

~~（似乎越来越丑了）~~此时可以把 $d | \gcd(i, j)$ 拆开：

$$
\begin{aligned}
& \sum_{i = 1}^{\lfloor A / d \rfloor}{\sum_{j = 1}^{\lfloor B / d \rfloor}{\sum_{g | i, g | j}{\mu(g)}}} \\
=& \sum_{g = 1}^{\min(A / d, B / d)}{\mu(g) \left\lfloor \frac{A}{dg} \right\rfloor \left\lfloor \frac{B}{dg} \right\rfloor}
\end{aligned}
$$

至此，计算答案可以 $O(n)$ 解决。

算法还可以继续优化。发现式子里还有两个形如 $\lfloor n / d \rfloor$ 的因子，因此可以整除分块优化成 $O(\sqrt{n})$ 的。配合 $O(n)$ 的线性筛 $\mu$ 函数，总复杂度 $O(n)$，可以轻松通过本题。

---

### code 1

``` cpp
std::bitset<1000003> v;
int p[78501], mu[1000003];

void sieve(int N) {
  int m = 0;

  v.set(1), mu[1] = 1;
  for (int i = 2; i <= N; ++i) {
    if (!v[i]) p[++m] = i, mu[i] = -1;
    for (int j = 1; j <= m && i * p[j] <= N; ++j) {
      v.set(i * p[j]);
      if (i % p[j] == 0) break;
      mu[i * p[j]] = -mu[i];
    }
    mu[i] += mu[i - 1];
  }
}

int main() {
  int A, B, d;
  long long ans = 0;

  std::cin >> A >> B >> d;
  A /= d, B /= d;
  if (A > B) std::swap(A, B);

  sieve(A);
  for (int l = 1, r, a, b; l <= A; l = r + 1) {
    a = A / l, b = B / l;
    r = std::min(A / a, B / b);
    ans += 1ll * a * b * (mu[r] - mu[l - 1]);
  }
  std::cout << ans << '\n';
  return 0;
}

```

### code 2

~~如果你像我一样闲得难受，可以学来杜教筛写写这题，复杂度好像还更高了。~~

不会杜教筛但想学的朋友可以来看我的[这篇题解](https://fa555.github.io/2020/杜教筛学习笔记/)。

这个多次询问的题目让我对杜教筛及空间优化有了更深入的理解（

``` cpp
std::bitset<10003> v, vm;
int MX, base, p[1231], mu[10003], mu_[10003];

inline int to(int x) {
  return MX / x;
}

void sieve(int N); // 同 code 1

int getMu(int N) {
  if (N <= base) return mu[N];
  if (vm[to(N)]) return mu_[to(N)];
  int ans = 0;
  for (int l = 2, r, L; l <= N; l = r + 1) {
    L = N / l, r = N / L;
    ans += (r - l + 1) * getMu(L);
  }
  vm.set(to(N));
  return mu_[to(N)] = 1 - ans;
}

int main() {
  int A, B, d;
  long long ans = 0;

  std::cin >> A >> B >> d;
  A /= d, B /= d;
  if (A > B) std::swap(A, B);

  MX = A, base = pow(A, 2. / 3);
  sieve(base);
  for (int l = 1, r, a, b, gR, gL; l <= A; l = r + 1) {
    a = A / l, b = B / l;
    r = std::min(A / a, B / b);
    vm.reset(), gR = getMu(r);
    vm.reset(), gL = getMu(l - 1);
    ans += 1ll * a * b * (gR - gL);
  }
  std::cout << ans << '\n';
  return 0;
}

```



---

## 作者：DennyQi (赞：3)

最近学莫比乌斯反演，本题应该是一道非常经典的入门题

先%一下hy大佬，在他的教导下我才去学莫比乌斯反演的……

hy大佬用的是整除分块优化的，而我没用整除分块，直接用莫比乌斯反演就过了……

我们先要设定$f$和$F$的意义。在本题中，设$f(n)$表示规定范围内$gcd=n$的数对个数，$F(n)$表示规定范围内公约数包括$n$的数对个数（即$n|gcd$的数对个数）

在这样的假设下，易知$$F(n)=\sum\limits_{n|d}f(d)$$意义非常显然，就是按照定义来的

于是根据莫比乌斯反演的第二个公式，如下$$f(n)=\sum\limits_{n|d}μ(\dfrac{d}{n})F(d)$$于是只需要一个能够简便求出$F$的方法即可

之所以要反演，是因为$F$比$f$更好求。分析发现，$F$的意义实际上就是要求数对$(a,b)$的数量，其中$n|a,n|b$。所以$$F(n)=\left \lfloor \dfrac{A}{n} \right \rfloor * \left \lfloor \dfrac{B}{n} \right \rfloor$$因为在规定范围内，前者有$\left \lfloor \dfrac{A}{n} \right \rfloor$个$n$的倍数，后者有$\left \lfloor \dfrac{B}{n} \right \rfloor$个$n$的倍数。相乘即为总方案数

求解出$F$以后，只需要线性筛$μ$，求出$f(d)$就是答案了

另外我们发现，这个公式貌似没有上限……然而题目给了上限。我们的$F$函数，一旦$n>A$或$n>B$就会变为0，因此应当满足$n \leq Min\{A,B\}$

贴上丑陋的代码
```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
#define  r  read()
using namespace std;
typedef long long ll;
#define int long long
const int MAXN = 1000010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int A,B,d,tot,ans;
int mu[MAXN],prime[MAXN],b[MAXN];
inline void getMobius(){
	mu[1] = 1;
	for(int i = 2; i <= Max(A,B); ++i){
		if(!b[i]){
			prime[++tot] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= tot; ++j){
			if(i * prime[j] > Max(A,B)) break;
			b[i * prime[j]] = 1;
			if(i % prime[j] == 0){
				mu[i * prime[j]] = 0;
				break;
			}
			mu[i * prime[j]] = -mu[i];
		}
	}
}
inline int F(int x){
	return (A/x) * (B/x);
}
#undef int
int main(){
#define int long long
	A = r, B = r, d = r;
	getMobius();
	for(int i = d; i <= Min(A,B); i += d){
		ans += mu[i/d] * F(i);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：nydzsf_qwq (赞：2)

## 前言

题解区似乎所有的题解都是用莫反做的，但是，这根本不需要。

我来介绍一下不用莫反的做法。

## 题解

定义 $s_{i}$ 为在 $d=i$ 时的答案。

假如要求是最大公约数是 $d$ 的倍数，答案显然就是 $\left\lfloor\dfrac{A}{d}\right\rfloor\cdot\left\lfloor\dfrac{B}{d}\right\rfloor$

现在的要求是最大公约数恰好是 $d$，所以只要把最大公约数是 $2d,3d,\cdots$ 时的答案减去。

于是就可以得到一个递推式 $s_{i}=\left\lfloor\dfrac{A}{i}\right\rfloor\cdot\left\lfloor\dfrac{B}{i}\right\rfloor-\sum\limits_{i|t,t<i,t\leq A,t\leq B}s_{t}$

这个式子直接就能算了！

操作次数大概是 $N\sum\limits_{i=1}^{N}\left\lfloor\dfrac{N}{i}\right\rfloor$ 这个量级，其中 $N=\dfrac{\min\left\{A,B\right\}}{d}$，在 $N=10^{6}$ 时是 $10^{7}$ 多一点，而且 $d$ 稍微大一点就会很小，完全能过。

### 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,d;
long long t[1000005];
int main() {
	scanf("%d%d%d",&a,&b,&d);
	for(int i=min(a,b)/d*d;i>=d;i-=d) {
		t[i]=1ll*(a/i)*(b/i);
		for(int j=i+i;j<=a&&j<=b;j+=i) t[i]-=t[j];
	}
	printf("%lld",t[d]);
	return 0;
}
```

如果用整除分块来优化的话可以做到 $O(n)$，但是这个做法是没法通过那几道和这题类似但是要多测的题，那几道还是得用莫反。

不知道有没有更好的优化，如果有的话那几道说不定能做。

### 优化后的代码

```
#include<bits/stdc++.h>
using namespace std;
int a,b,d;
long long t[1000005];
int main() {
	scanf("%d%d%d",&a,&b,&d);
	a/=d,b/=d;
	for(int i=min(a,b);i>=1;i=max(a/(a/i+1),b/(b/i+1))) {
		t[i]=1ll*(a/i)*(b/i);
		int tmp=i;
		for(int j=i*2;j<=a&&j<=b;j+=i) j=min(a/(a/j),b/(b/j))/i*i,t[i]-=(j-tmp)/i*t[min(a/(a/j),b/(b/j))],tmp=j;
	}
	printf("%lld\n",t[1]);
	return 0;
}
```

update on 2022.05.21: 添加了整除分块的优化

---

## 作者：feicheng (赞：2)

## Description：
>给定 $A,B,d$ ，求满足$1\le a\le A,1\le b\le B $ 且 $\gcd(a,b)=d$ 的数对数

## Solution
考虑莫比乌斯反演
原式可化为
 $$\sum_{i=1}^A\sum_{j=1}^B\gcd(i,j)=d$$
 
根据套路，我们先给两边除以 $d$,化成

$$\sum_{i=1}^{\left\lfloor\tfrac A d\right\rfloor}\sum_{j=1}^{\left\lfloor\tfrac B d\right\rfloor}\gcd(i,j)=1$$
为什么要化成这个形式呢？
因为根据莫比乌斯函数的性质
$$\sum_{d\mid n} \mu(d) = [n=1]$$
这个式子可以化成
$$\sum_{i=1}^{\left\lfloor\tfrac A d\right\rfloor}\sum_{j=1}^{\left\lfloor\tfrac B d\right\rfloor}\sum_{k\mid \gcd(i,j)} \mu(k) $$

我们考虑交换枚举顺序，先枚举 $d$，原式就可以化成

$$\sum_{k=1}^{\min(\frac A d,\frac B d)} \mu(k)\sum_{i=1}^{\left\lfloor\tfrac A d\right\rfloor}\sum_{j=1}^{\left\lfloor\tfrac B d\right\rfloor} [k\mid\gcd(i,j)]$$

$$\sum_{k=1}^{\min(\frac A d,\frac B d)}\mu(k)\left\lfloor\tfrac A {kd}\right\rfloor\left\lfloor\tfrac B {kd}\right\rfloor$$

对于这个式子，$\mu$ 函数可以线性预处理，分数可以用整除分块来做，时间复杂度是$\Theta(\sqrt n)$
## Code
```cpp
/*If you are full of hope,you will be invincible*/
#include <ctime>
#include <cstdio>
#include <random>
#include <cstring>
#include <iostream>
#include <algorithm>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define ri register int
typedef long long ll;
std::mt19937 hpy(time(nullptr)+(unsigned long long)(new char));
namespace IO{
	constexpr int HL=1<<20;
	char buf[HL],*t1=buf,*t2=buf;
	#ifndef ONLINE_JUDGE
	#define getc() getchar()
	#else
	#define getc() t1==t2&&(t2=(t1=buf)+fread(buf,1,HL,stdin),t1==t2)?EOF:*t1++
	#endif
	inline int read(){static int an,f;an = 0,f = 1;static char ch;ch=getc();
	while(!isdigit(ch))ch=='-'?f=-1:1,ch=getc();
	while(isdigit(ch))an=(an<<3)+(an<<1)+(ch^48),ch=getc();
	return an*f;}
	char buff[HL],*T=buff;
	void flush(){fwrite(buff,1,T-buff,stdout);T=buff;}
	inline void putc(char ch){if(T==buff+HL)flush();*T++=ch;}
	template<typename Tp>
	inline void print(Tp x){if(x<0)putc('-'),x=-x;if(!x)return putc('0'),void();
	static int st[20],tp;while(x)st[++tp]=x%10,x/=10;while(tp)putc(st[tp]^48),--tp;}
}
using IO::read;
using IO::print;
using IO::putc;
constexpr int inf = 0x3f3f3f3f,N = 1e6 + 10;
int vis[N],n,m,cnt;
ll pri[N],sum[N],mu[N];
inline void Sieve() {
	mu[1] = 1;
	for(ri i = 2;i <= N;++i) {
		if(!vis[i]) vis[i] = 1,pri[++cnt] = i,mu[i] = -1; 
		for(ri j = 1;j <= cnt && i*pri[j] <= N;++j) {
			vis[i*pri[j]] = 1;
			if(i%pri[j] == 0) break;
			mu[i*pri[j]] = -mu[i];
		}
	}//线性筛μ
	for(ri i = 1;i <= N;++i) sum[i] = mu[i] + sum[i-1];//用前缀和处理 
}
ll Solve(int a,int b,int d){
	int mx = std::min(a,b);
	ll ans = 0;
	for(ri l = 1,r;l <= mx;l = r + 1) {//整除分块
		r = std::min(a/(a/l),b/(b/l));
		ans += (sum[r]-sum[l-1])*(1ll*a/(1ll*l*d)) * (1ll*b/(1ll*l*d));
	}
	return ans;
}
int main() {
	Sieve();
	int a=read(),b=read(),d=read();
	print(Solve(a,b,d));
    return IO::flush(),0;
}
```


---

## 作者：Smallbasic (赞：2)

莫反板子题

先把原式化成好推一点的式子：

$$\sum_{i=1}^A\sum_{j=1}^B[gcd(i, j) =D]=\sum_{i=1}^{\lfloor{A\over D}\rfloor}\sum_{j=1}^{\lfloor{B\over D}\rfloor}[gcd(i,j)=1]$$

我们设：$n=\lfloor{A\over D}\rfloor,m=\lfloor{B\over D}\rfloor$

注意到$\mu$函数有个性质：

$$\sum_{d|n}\mu(d)=[n=1]$$

证明：

设：

$$n=\prod_{i=1}^m p_i^{a_i}$$

我们只用考虑$n$有平方因子的因子（因为若一个数没有平方因子则$\mu$函数的值为0），所以我们考虑的因子$d$的取值范围为：

$$\prod_{i=1}^m p_i^{b_i}\space\space\space\space\space\space(b_i=0/1)$$

显然有$2^m$种情况，想要这$2^m$种情况和为0，必须使$b_i$之和为奇的情况和为偶的情况的数量相等。

由杨辉三角的对称性可得，当$m$为奇数时，结论一定成立。

而$m$为偶数时：

和为奇的数量为：

$$\sum_{i=0}^{\lfloor{m-1\over2}\rfloor} C_{2i+1}^m$$

它刚好等于上一排杨辉三角的和（由杨辉三角定义可知），也就是$2^{m-1}$，恰好是$2^m$的一半，也就是和和为偶数的情况数量相等。

注意当$n=1$时，不能被分解，原式的值为1

证毕

回到题目，上面的式子根据这个结论就可以写成：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=1]=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}\mu(d)$$

$$=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j}\mu(d)$$

我们换个枚举的顺序，先枚举$d$:

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,d|j}\mu(d)=\sum_{d=1}^{\min(n,m)}\sum_{d|i}^n\sum_{d|j}^m\mu(d)$$

$$=\sum_{d=1}^{\min(n,m)}\lfloor{n\over d}\rfloor\lfloor{m\over d}\rfloor\mu(d)$$

上面的式子显然可以$\Theta(n)$求出，整除分块可以到$\Theta(\sqrt{n})$，不过数据只有$1e6$，没有必要。记得开long long

Code :

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int A, B, d, n, m, mu[1000005], prime[1000005], top = 0;
bool notprime[1000005];
long long ans = 0;

inline int min_(int a, int b) {
	return a < b ? a : b;
}

int main() {
	mu[1] = 1;
    for (register int i = 2; i <= 1000000; ++i) {  
        if (!notprime[i]) prime[++top] = i, mu[i] = -1;
        for (register int j = 1; j <= top; ++j) {  
            if (i * prime[j] > 1000000) break;  
            notprime[i * prime[j]] = 1;
            if (!(i % prime[j])) {  
                mu[i * prime[j]] = 0;
                break;  
            } else mu[i * prime[j]] = -1 * mu[i];
        } 
    }
    scanf("%d%d%d", &A, &B, &d);
    n = A / d; m = B / d;
    for (int i = 1; i <= min_(n, m); ++i) ans += 1ll * mu[i] * (n / i) * (m / i);
    printf("%lld", ans);
	return 0;
}
```


---

## 作者：eee_hoho (赞：1)

真·第一道自己做出来的莫反题

看完题目，就知道了是要求这个式子
$$\sum_{a=1}^A\sum_{b=1}^B\ [gcd(a,b)=d]$$

考虑莫反，设$f(x)=\begin{cases}\ 1&(x=d)&\\\ 0&(x\ne d)&\end{cases}$

那么我们要找到一个$g$使得$f=g*1$，即$f(x)=\sum_{k|x}g(x)$，因为$1$的逆是$\mu$，所以$g=f*\mu$

$$g(x)=\sum_{k|x}\mu(\frac{x}{k})[k=d]$$
$$g(x)=\mu(\frac{x}{d})[d|x]$$

假设我们已经求出来$g$，那么就可以对式子进行化简了
$$\sum_{a=1}^A\sum_{b=1}^B\ f(gcd(a,b))$$
$$\sum_{a=1}^A\sum_{b=1}^B\sum_{k|a,k|b}\ g(k)$$
$$\sum_{k=1}^{min(A,B)}g(k)\ \sum_{a=1}^A\sum_{b=1}^B\ [k|a]\ [k|b]$$
$$\sum_{k=1}^{min(A,B)}g(k)\ \lfloor\frac{A}{k}\rfloor\ \lfloor\frac{B}{k}\rfloor$$

然后对这个式子整除分块就可以了

至于$g$怎么求，我们把$\mu$筛出来，然后就可以求每个$g(x)$，再做一个前缀和就可以$O(1)$询问区间$g$的和了

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#define N 1000000
using namespace std;
int a,b,d,mul[N+5],v[N+5],prime[N+5],cnt,g[N+5],sg[N+5];
long long ans;
void make()
{
	mul[1]=1;v[1]=1;
	for (int i=2;i<=N;i++)       //线筛筛μ
	{
		if (!v[i])
		{
			prime[++cnt]=i;
			mul[i]=-1;
		}
		for (int j=1;j<=cnt&&i*prime[j]<=N;j++)
		{
			v[prime[j]*i]=1;
			if (i%prime[j]!=0)mul[i*prime[j]]=-mul[i];
			else
			{
				mul[i*prime[j]]=0;
				break;
			}
		}
	}
	for (int i=1;i<=N;i++)     //处理g函数
		if (i%d==0)
			g[i]=mul[i/d];
	for (int i=1;i<=N;i++)    //前缀和
		sg[i]=sg[i-1]+g[i];
}
int main()
{
	cin>>a>>b>>d;
	make();
	if (a>b)swap(a,b);
	for (int l=1,r;l<=a;l=r+1)     整除分块
	{
		r=min(a/(a/l),b/(b/l));
		ans+=(sg[r]-sg[l-1])*1LL*(a/l)*1LL*(b/l)*1LL;
	}
	cout<<ans<<endl;
	return 0;
}
```
常数大，代码丑(╯︵╰)

---

## 作者：ricky0916 (赞：0)

~~这道题不就是ZAP-Queries的弱化版吗，连整除分块都不需要~~

作为一道莫反的基础题，现在来讲解一下什么是莫比乌斯反演

若两个数论函数$ f(n),g(n) $，满足

$$
f(n)=\sum_{n|d}g(d)
$$

则有

$$
g(n)=\sum_{n|d}\mu(d)f(\frac{d}{n})
$$

其中当$ p=p1p2......p_k $其中$ p_1......p_k $是两两不同的质数时$ \mu(n)=(-1)^k $，否则$ \mu(n)=0 $。

特别的，$ \mu(1)=1 $。

由于$ \mu $是个积性函数，所以可以线性筛。

好现在让我们看到题目。

令$ A'=\lfloor\frac{A}{d}\rfloor $，$ B'=\lfloor \frac{B}{d}\rfloor $

则有答案为

$$
\sum_{i=1}^{A'}\sum_{j=1}^{B'}[\gcd(i,j)=1]
$$

现在令
$$
f(i)=\sum_{i=1}^{A'}\sum_{j=1}^{B'}[\gcd(i,j)=i]
$$
$$

g(i)=\lfloor \frac{A'}{i} \rfloor\lfloor \frac{B'}{i} \rfloor
$$
则显然有

$$
g(n)=\sum_{n|d}f(d)
$$

所以

$$
f(n)=\sum_{n|d}\mu(d)g(\frac{d}{n})
$$

所以

$$
Ans=f(1)=\sum_{i=1}^{\min(A',B')}\mu(i)\lfloor \frac{A'}{i} \rfloor\lfloor \frac{B'}{i} \rfloor
$$

写到这里就差不多了

这题因为是单次询问，所以不需要整除分块$ O(\sqrt n) $

完整代码就不给了，给一下线性筛$ \mu $的代码
```cpp
for(int i=2;i<=1000000;i++){
	if(!check[i]){
		prime[tot++]=i;
		miu[i]=-1;
	}
	for(int j=0;j<tot&&i*prime[j]<=1000000;j++){
		check[i*prime[j]]=1;
		if(i%prime[j]==0){
			miu[i*prime[j]]=0;
			break;
		}
		miu[i*prime[j]]=-miu[i];
	}
}
```


---

## 作者：Vidoliga (赞：0)

# 题解

前言$:$你要是不会莫比乌斯反演可以看一下这篇[$blog$](https://www.luogu.com.cn/blog/QWQdeta/mu-bi-wu-si-fan-yan)

## 本题求 $\sum\limits_{i=1}^A\sum\limits_{j=1}^B[gcd(i,j)==d]$

### 先提出来

$=\sum\limits_{i=1}^{[\frac{A}{d}]}\sum\limits_{j=1}^{[\frac{B}{d}]}[gcd(i,j)==1]$

$=\sum\limits_{i=1}^{[\frac{A}{d}]}\sum\limits_{j=1}^{[\frac{B}{d}]}\sum\limits_{k|gcd(i,j)}\mu(k)$

$=\sum\limits_{i=1}^{[\frac{A}{d}]}\sum\limits_{j=1}^{[\frac{B}{d}]}\sum\limits_{k|i}\sum\limits_{k|j}\mu(k)$

枚举$k,$默认$A \geqslant B$

$=\sum\limits_{k=1}^{[\frac{A}{d}]}\mu(k)\sum\limits_{i=1}^{[\frac{A}{dk}]}\sum\limits_{j=1}^{[\frac{B}{dk}]}1$

$=\sum\limits_{k=1}^{[\frac{A}{d}]}\mu(k)[\frac{A}{dk}][\frac{B}{dk}]$

后面这一坨做整除分块就完事了

本蒟蒻的代码$:$

```cpp
#include<iostream>
#include <cstdio>
#include<cmath>
using namespace std;
const int N = 1000005;
bool fi[1000010];
long long coot=0,prime[1000010],mu[1000010];
long long A,B,D;
void init(){
	mu[1]=1;
	for(long long i = 2;i <= N;i++){
		if(!fi[i])
			prime[++coot]=i,mu[i]=-1;
		for(long long j = 1;j <= coot&&i*prime[j]<=N;j++){
			int k= i*prime[j];
			fi[k]=true;
			if(i%prime[j]==0){
				mu[k]=0;
				break;	
			}else{
				mu[k]=-mu[i];
			} 
		}
	}
	for(int m = 2;m <= N;m++) mu[m] += mu[m-1];
}
long long work(long long a,long long b){
	long long ans=0;
	long long s=min(a,b);
	for(long long left=1;left<=s;){
		long long right=min(a/(a/left),b/(b/left));
		ans+=(mu[right]-mu[left-1])*(a/left)*(b/left);
		left=right+1;
	}
	return ans;
} 
int main(){
	init();
	scanf("%lld %lld %lld",&A,&B,&D);
	A/=D;
	B/=D;
	printf("%lld\n",work(A,B));
	return 0;
}
```
完结撒花$,$管理员大大让我过吧$QwQ$

---

## 作者：cirnovsky (赞：0)

人生第一道莫比乌斯反演题，写写题解吧

如果markdown有锅请移步至[这里](https://beyondmyself.blog.luogu.org/ti-xie-p4450-shuang-qing-shuo-post)

定义

题目让我们求

$$
\sum_{a=1}^{A}\sum_{b=1}^{B}[\gcd(a\in A,b\in B)=d]
$$

显然，我们可以采用莫比乌斯反演的方式来求出这个式子

我们可以记

$$
f(x)=\begin{cases}1\ \ \ (x=d)\\\\ 0\ \ \ (x\ne d)\end{cases}
$$

也就是说，我们需要找到$g$且$f=g\times 1$，即

$$
f(x)=\sum_{k\mid x}g(x)
$$

又因为1的逆为$\mu$，所以我们可以得出以下结论

$$
\begin{cases}g=f\times\mu\\
\\
\displaystyle
\displaystyle g(x)=\sum_{k\mid x}\mu(\frac{x}{k})[k=d]\\
\displaystyle g(x)=\mu(\frac{x}{d})[d\mid x]\end{cases}
$$

也就是说，我们可以通过化简得到以下的式子

$$
\sum_{k=1}^{\min(A,B)}g(k)\lfloor \frac{A}{k}\rfloor\times \lfloor\frac{B}{k}\rfloor
$$

然后我们就可以通过数论分块的方法求出这个式子了

至于$g$，我们可以用线性筛把$\mu$筛出来，再前缀和即可

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
#define int long long

using namespace std;

namespace MAIN {
    const int SIZE = 1000000 + 5;
    int a, b, d, tot, ans, primes[SIZE];
    int Mobius[SIZE], tag[SIZE];

    inline void MAIN() {
        scanf("%lld %lld %lld", &a, &b, &d);
        Mobius[1] = 1;
        for (int i = 2; i <= max(a, b); ++i) { // 线性筛
            if (!tag[i]) primes[++tot] = i, Mobius[i] = -1;
            for (int j = 1; j <= tot; ++j) {
                if (i * primes[j] > max(a, b)) break;
                tag[i * primes[j]] = 1;
                if (!(i % primes[j])) {
                    Mobius[i * primes[j]] = 0;
                    break;
                }
                Mobius[i * primes[j]] = -Mobius[i];
            }
        }
        for (int i = d; i <= min(a, b); i += d) ans += Mobius[i / d] * (a / i) * (b / i);
        printf("%lld\n", ans);
    }
} // namespace MAIN

signed main() {
    MAIN::MAIN();
}
```

---

## 作者：chihik (赞：0)

显然，题目求的是：

$$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]$$

$$\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[gcd(i,j)=1] $$

有一个与莫比乌斯函数有关的性质：$\sum_{d | n}\mu(d)=[n=1]$

$$\sum_{i=1}^{ \lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\sum_{k|gcd(i,j)}\mu(k)$$

将 $k$ 往前移，然后是一个非常经典的式子了

$$\sum_{k=1}^{min(\lfloor \frac{n}{d} \rfloor,\lfloor \frac{m}{d} \rfloor)}\mu(k)\lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor$$

用数论分块即可解决。


```cpp
#include <cstdio>
#include <iostream>
using namespace std;

const int MAXN = 1000000;
int a , b , d , k , prime[ MAXN + 5 ] , mu[ MAXN + 5 ] , f[ MAXN + 5 ];
bool vis[ MAXN + 5 ];
void sieve( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			mu[ i ] = -1;
		}
		for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
    for( int i = 1 ; i <= MAXN ; i ++ )
        f[ i ] = f[ i - 1 ] + mu[ i ];
}

long long solve( int n , int m , int k ) {
    int d = min( n , m ); long long Ans = 0;
    for( int l = 1 , r ; l <= d ; l = r + 1 ) {
        r = min( n / ( n / l ) , m / ( m / l ) );
        Ans = Ans + 1ll * ( f[ r ] - f[ l - 1 ] ) * ( n / k / l ) * ( m / k / l );
    }
    return Ans;
}

int main( ) {
    sieve( );
    scanf("%d %d %d",&a,&b,&d);
    printf("%lld",solve( a , b , d ));
    return 0;
}
```


---

## 作者：three_trees (赞：0)

一个正常的莫比乌斯应用

我们令

$f(d) = \sum_{i = 1}^{n}\sum_{j = 1}^{m}[\gcd(i, j) = d]$
$F(n) = \sum_{n \mid d}f(d) = \lfloor{\frac{A}{n}}\rfloor * \lfloor{\frac{B}{n}}\rfloor$

根据莫比乌斯反演我们有:

$f(k) = \sum_{k \mid d}\mu(\frac{d}{k})*F(d)=\sum_{k \mid d}\mu(\frac{d}{k})\lfloor{\frac{A}{d}}\rfloor * \lfloor{\frac{B}{d}}\rfloor$

我们先用d替换掉

$\frac{d}{k}$
$f(k) = \sum_{d = 1}^{\min(\frac{A}{k}, \frac{B}{k})}\mu(d)\lfloor{\frac{A}{dk}}\rfloor * \lfloor{\frac{B}{dk}}\rfloor$

然后我们在用T替换dk

$f(k) = \sum_{T = 1}^{\min(A, B)}\mu(\frac{T}{k})\lfloor{\frac{A}{T}}\rfloor * \lfloor{\frac{B}{T}}\rfloor \qquad(k \mid T)$

这样对于$\mu(\frac{T}{k})$我们可以前缀和处理，注意k整除T

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 1e6 + 5;
template <typename T>
void out(T x) { cout << x << endl; }
ll fast_pow(ll a, ll b, ll p) {ll c = 1; while(b) { if(b & 1) c = c * a % p; a = a * a % p; b >>= 1;} return c;}
int mu[N], prime[N], tot;
ll sum[N];
bool mark[N];
void get_mu()//线性筛
{
    memset(mark, false, sizeof(mark));
    memset(mu, 0, sizeof(mu));
    tot = 0;
    mark[1] = mark[0] = true;
    mu[1] = 1;
    for(int i = 2; i < N; i ++)
    {
        if(!mark[i])
        {
            prime[tot ++] = i;
            mu[i] = -1;
        }
        for(int j = 0; j < tot && i * prime[j] < N; j ++)
        {
            mark[i * prime[j]] = true;
            if(i % prime[j] == 0)
                break;
            else 
                mu[i * prime[j]] = -mu[i];
        }
    }
}
ll cal(ll a, ll b, ll k)//分块
{
    ll ans = 0;
    if(a > b)
        swap(a, b);
    for(ll i = 1, j = 1; i <= a; i = j + 1)
    {
        j = min(a / (a / i), b / (b / i));
        ans += (a / i) * (b / i) * (sum[j] - sum[i - 1]);
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    get_mu();
    memset(sum, 0, sizeof(sum));
    ll a, b, c;
    cin >> a >> b >> c;
    for(int i = 1; i <= min(a, b); i ++)
        sum[i] = sum[i - 1] + (i % c == 0 ? mu[i / c] : 0);//整除，刚开始没检查出来
    cout << cal(a, b, c) << endl;
}

```


---

## 作者：子衿君 (赞：0)

#### 莫比乌斯函数

$$\large \sum_{d|n}\mu(d)=\begin{cases}1& \text{n=1}\\0& \text{n>1}\end{cases}$$

		也就是说：

$$\large \mu(n)=\begin{cases}1& \text{n=0}\\(-1)^k& \text{n= p1*p2*p3...pk}\\0& \text{其他}\end{cases}$$

~~太菜了都快忘了怎么线性筛~~ $\mu$ 了

我们从公式当中可以知道，如果是质数的话，那么质因子的个数是1，所以$\mu$的值是$-1$，就像线性筛素数那样，对素数的倍数进行标记，然后就可以线性筛出来$\mu$了，但是有的时候线性筛不够用了，就需要用到杜教筛，杜教筛的内容后面再说，这里给一个参考代码 （~~防止自己天天忘~~）

```cpp
void get_mu()	//线性筛求mu函数
{
	mu[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!vis[i])
			mu[i]=-1,pri[++cnt]=i;
		for(int j=1;j<=cnt&&i*pri[j]<=n;++j)
		{
			vis[i*pri[j]]=1;
			if(i%pri[j]==0) break;
			else mu[i*pri[j]]=-mu[i];
		}
	}
}
```



#### 基本公式

$$\large g(n)=\sum_{d|n}f(d)$$

$$\large \Updownarrow$$

$$\large f(n)=\sum_{d|n}\mu(d)g\left(\frac{n}{d}\right)$$

$$\large g(n)=\sum_{n|d}f(d)$$

$$\large \Updownarrow$$

$$\large f(n)=\sum_{n|d}g(d)\mu\left(\frac{d}{n}\right)$$

#### 简单应用

##### 板子

$$\large \sum_{i=1}^n\sum_{j-1}^m[gcd(i,j)==1]$$

$$ \large f(x)=\sum_{i=1}^n\sum_{j-1}^m[gcd(i,j)==x]$$

$$\large \large g(n)=\sum_{n|d}f(d)$$

$$\large f(n)=\sum_{n|d}g(d)\mu\left(\frac{d}{n}\right)$$

$$\large \because g(x)=\sum_{i=1}^n\sum_{j=1}^m[x|gcd(i,j)]$$

$$\large \therefore g(x)=\sum_{i=1}^{{\lfloor\frac{n}{x}\rfloor}}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}[1|gcd(i,j)]$$

$$\large f(x)=\sum_{x|d}g(d)\mu\left(\frac{d}{x}\right)=\sum_{x|d}\mu\left(\frac{d}{x}\right)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$$

$$\large f(1)=\sum_{1|d}\mu\left(\frac{d}{1}\right)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor=\sum_{d=1}^{min(n,m)}\mu({d})\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$$

$$\large Ans=\sum_{d=1}^{min(n,m)}\mu({d})\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$$

代码套路：预处理前缀和+整除分块


```cpp
for(int l=1,r;l<=n;l=r+1)
{
    r=min(a/(a/l),b/(b/l));
    ans+=1LL*(a/l)*(b/l)*(s[r]-s[l-1]);
}
cout<<ans<<endl;
```

###### POI2007 ZAP-Queries / luoguP4450 双亲数

​	模板题，两个一样
$$\large \sum_{i=1}^n\sum_{j=1}^m [ gcd(i,j)==d ]$$

$$\large f(x)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=x]$$

$$\large g(x)=\sum_{x|d}f(d)=\sum_{i=1}^n\sum_{j=1}^m[x|gcd(i,j)$$

$$\large \because[x|gcd(i,j)]$$

$$\large \therefore x|i\text{且}x|j$$

$$\large g(x)=\sum_{i=1}^n\sum_{j=1}^m[x|gcd(i,j)]=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}=\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{x}\rfloor$$

$$\large f(x)=\sum_{x|d}g(d)\mu\left(\frac{d}{x}\right)=\sum_{x|d}\mu\left(\frac{d}{x}\right)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$$

$$\large \sum_{x|d}\mu\left(\frac{d}{x}\right)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\mu(i)\lfloor\frac{n}{ix}\rfloor\lfloor\frac{m}{ix}\rfloor=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\mu(i)\frac{\lfloor\frac{n}{x}\rfloor}{i}\frac{\lfloor\frac{m}{x}\rfloor}{i}$$

$$\large Ans=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\mu(i)\frac{\lfloor\frac{n}{x}\rfloor}{i}\frac{\lfloor\frac{m}{x}\rfloor}{i}$$


---

## 作者：Jμdge (赞：0)

~~这道题可能紫色都没有？~~

我们考虑这道题可能暴力都能 A ，~~所以别做了~~

我们发现式子长这样：


$$ANS= \sum_{i=1}^A \sum_{j=1}^ B [(A,B)=d]$$

然后化简（此处默认 A 比 B 小）：

$$ANS=\sum_{i=1}^{A/d} \sum_{j=1}^ {B/d} [(A,B)=1]$$


$$ANS= \sum_{i=1}^{A/d} \sum_{j=1}^ {B/d} \sum_{k|i,k|j} μ (k) $$



$$ANS= \sum_{k=1}^{A/d} μ (k) \sum_{i=1}^{A/kd} \sum_{j=1}^ {B/kd}  $$



$$ANS= \sum_{k=1}^{A/d} μ (k) \lfloor{A\over kd} \rfloor \lfloor{B\over kd} \rfloor $$

然后我们发现数据比较小就可以直接筛一遍 μ 然后线性出解了


```
//by Judge
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int M=1e4+3;
typedef int arr[M];
inline int Min(int a,int b){return a<b?a:b;}
ll cnt,m,A,B,d,ans; arr v,p,mu; map<int,ll> mp;
inline void prep(int n){ v[1]=mu[1]=1;
	for(int i=2;i<=n;++i){ if(!v[i]) p[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*p[j]<=n;++j){ v[i*p[j]]=1;
			if(!(i%p[j])) break; mu[i*p[j]]=-mu[i];
		} mu[i]+=mu[i-1];  //这里已经处理出了 μ 的前缀和，线性处理答案的时候要注意... 
	}
}
inline ll get(int n){ if(n<=m) return mu[n]; //如果是杜教筛就要用 
	if(mp[n]) return mp[n]; ll ans=1;
	for(int l=2,r;l<=n;l=r+1) r=n/(n/l),
		ans-=(r-l+1)*get(n/l); return mp[n]=ans;
}
int main(){ cin>>A>>B>>d; if(A>B) swap(A,B);
	A/=d,B/=d,prep(A);
	for(int k=1;k<=A;++k)
		ans+=(mu[i]-mu[i-1])*(A/l)*(B/l);
	return !printf("%lld\n",ans);
	
	A/=d,B/=d,prep(m=pow(A,2/3.0));
	for(int l=1,r;l<=A;l=r+1) r=Min(A/(A/l),B/(B/l)),
		ans+=(get(r)-get(l-1))*(A/l)*(B/l); return !printf("%lld\n",ans);
}
```


但其实可以跑得更快一些，就是用杜教筛，比原来大概快个两三倍（洛谷 4 环境下），其实已经少了两个数量级，根本都不用比了

至于代码就是 return 后面的那一段话了




---

## 作者：Wolfycz (赞：0)

题目要求（之后令$n<m$）

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)==d]$$

同时除上$d$，有

$$\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)==1]$$

然后发现最后面其实是莫比乌斯反演的形式，继续改写式子

$$\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{x|i,x|j}\mu(x)$$

然后我们把枚举改一下顺序，得到

$$\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\dfrac{n}{dx}\rfloor\lfloor\dfrac{m}{dx}\rfloor$$

然后我们只要线筛求出$\mu$函数之后就可以做这题了~~(当然可以使用整除分块)~~

```cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e6;
int prime[N+10],miu[N+10],sum[N+10];
bool inprime[N+10];
void prepare(){
	miu[1]=sum[1]=1; int tot=0;
	for (int i=2;i<=N;i++){
		if (!inprime[i])	miu[prime[++tot]=i]=-1;
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				miu[i*prime[j]]=0;
				break;
			}miu[i*prime[j]]=-miu[i];
		}
		sum[i]=sum[i-1]+miu[i];
	}
}
int main(){
	prepare();
	int n=read(),m=read(),d=read();
	ll Ans=0; n/=d,m/=d;
	if (n>m)	swap(n,m);
	for (int i=1,pos;i<=n;i=pos+1){
		pos=min(n/(n/i),m/(m/i));
		Ans+=1ll*(sum[pos]-sum[i-1])*(n/i)*(m/i);
	}
	printf("%lld\n",Ans);
	return 0;
}
```



---

## 作者：Great_Influence (赞：0)

推导过程：

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m[(i,j)==d]$

$=\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i,j)==1]$

$=\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{D|i,j}\mu(D)$

$=\sum\limits_{D=1}^{\lfloor\frac{n}{d}\rfloor}\mu(D)\lfloor\frac{n}{dD}\rfloor\lfloor\frac{m}{dD}\rfloor$

直接线筛出$\mu$，然后随便做了。我用了整除分块，时间复杂度$O(\frac{n}{d}+\sqrt{\frac{n}{d}})$。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}

const int MAXN=1e6+7;

static int pri[MAXN],e;
static short mu[MAXN];
static bool is[MAXN];

static int n,m,d;

inline void predone(int lim)
{
	mu[1]=1;
	static int z;
	Rep(i,2,lim)
	{
		if(!is[i])pri[++e]=i,mu[i]=-1;
		for(register int j=1;j<=e&&(z=i*pri[j])<=lim;++j)
		{
			is[z]=true;
			if(i%pri[j]==0)break;
			mu[z]=-mu[i];
		}
	}
	Rep(i,2,lim)mu[i]+=mu[i-1];
}

inline void init()
{
	read(n);read(m);read(d);
	if(n>m)swap(n,m);n/=d;m/=d;
	predone(n);
}

static long long ans;

inline void solve()
{
	static int las,i;
	for(i=1;i<=n;i=las+1)
	{
		las=min(n/(n/i),m/(m/i));
		ans+=(long long)(n/i)*(m/i)*(mu[las]-mu[i-1]);
	}
	printf("%lld\n",ans);
}

int main(void){
    file();
	init();
	solve();
	return 0;
}

```

---


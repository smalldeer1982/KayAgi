# [DTCPC 2024] 序列

## 题目描述

定义一个长度为 $n$ 的序列 $\{p_n\}$ 的权值 $f(\{p_n\})$ 为 $\max\limits_{i=1}^n\{p_i-\max\{p_{i-1},p_{i+1}\}\}$，特别的，定义 $p_0=p_{n+1}=-\inf$。

求 $\sum\limits_{l=1}^n \sum\limits_{r=l+1}^n f(\{a_l,a_{l+1},\dots,a_r\})$。

答案对 $2^{32}$ 取模。

## 样例 #1

### 输入

```
5
1 3 5 2 3
```

### 输出

```
21```

## 样例 #2

### 输入

```
4
4 6 3 3```

### 输出

```
12```

# 题解

## 作者：Register_int (赞：5)

考虑分治。设当前处理 $[l,r]$，分治中心为 $(p,p+1)$ 中间那个缝。现在要算出经过分治中心的区间答案之和。

考虑直接以 $p$ 为中心给他切成两部分，那么这两部分就是 $[l,p]$ 的后缀与 $[p+1,r]$ 的前缀。直接预处理出左半边后缀的值与右半边前缀的值，设他们分别为 $x_l,x_{l+1},\cdots,x_p$ 与 $y_{p+1},y_{p+2},\cdots,y_r$，那么区间 $[i,j]$ 的价值就为 $\max(x_i,y_j)$。

拆贡献，考虑有多少对区间满足其价值等于 $x_i,y_j$。先处理是 $x$ 的情况，那么区间个数就是 $\le x$ 的 $y$ 的个数。这是一个二维偏序问题，可以直接将右半部分拍到数轴上做前缀和解决，时间复杂度是 $O(n)$。用 $y$ 算 $x$ 的部分同理，时间复杂度为离散化的一个 $\log$，总时间复杂度是 $O(n\log^2 n)$。由于常数巨小可以通过。

然后事实上你发现第二只 $\log$ 是离散化，那直接从下面两层归并上来就行了。可以做到单 $\log$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned uint;

const int MAXN = 1e6 + 10;

int n, a[MAXN], id[MAXN], t[MAXN], tot;

int b[MAXN]; uint ans, c[MAXN];

void solve(int l, int r) {
	
	if (l == r) return ;
	
	int mid = l + r >> 1; solve(l, mid), solve(mid + 1, r);
	
	for (int i = mid, p = -1e18; i >= l; i--) {
		b[i] = max(p, a[i] - a[i + 1]);
		p = max(p, a[i] - max(a[i - 1], a[i + 1]));
	}
	for (int i = mid + 1, p = -1e18; i <= r; i++) {
		b[i] = max(p, a[i] - a[i - 1]);
		p = max(p, a[i] - max(a[i - 1], a[i + 1]));
	}

	tot = 0;
	for (int i = l; i <= r; i++) t[++tot] = b[i];
	sort(t + 1, t + tot + 1), tot = unique(t + 1, t + tot + 1) - t - 1;
	for (int i = l; i <= r; i++) id[i] = lower_bound(t + 1, t + tot + 1, b[i]) - t;
	
	for (int i = mid + 1; i <= r; i++) c[id[i]]++;
	for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
	for (int i = l; i <= mid; i++) ans += (uint)b[i] * c[id[i]];
	for (int i = 1; i <= tot; i++) c[i] = 0;
	
	for (int i = l; i <= mid; i++) c[id[i]]++;
	for (int i = 1; i <= tot; i++) c[i] += c[i - 1];
	for (int i = mid + 1; i <= r; i++) ans += (uint)b[i] * c[id[i] - 1];
	for (int i = 1; i <= tot; i++) c[i] = 0;
	
}

int main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	solve(1, n), printf("%u", ans);
}
```

---

## 作者：Sol1 (赞：2)

同步发表于 [个人博客](https://sol1.netlify.app/2024/02/17/solution-p10162/)。

---

这里给出一个基于序列分治的 $O(n\log n)$ 做法。

以下记 $v_i=a_i-\max \{a_{i-1},a_{i+1}\}$，$l_i=a_i-a_{i+1}$，$r_i=a_i-a_{i-1}$。

考虑分治，初始区间为 $[1,n]$，每次取区间中点 $m$，求出所有跨过区间中点的子区间的贡献（即所有满足 $l\leq l'\leq m<r'\leq r$ 的子区间 $[l',r']$ 的贡献），然后对中点的两侧分别递归。

设当前区间为 $[l,r]$，区间中点为 $m$。由于我们考虑的区间一定包含 $m$ 和 $m+1$，所以我们可以计算 $p_i=\max\{v_{m+1},v_{m+2},\cdots,v_{i-1},r_i\}$ 和 $s_i=\max\{l_i,v_{i+1},v_{i+2},\cdots,v_{m}\}$，那么一个子区间 $[l',r']$ 的贡献就是 $\max\{s_{l'},p_{r'}\}$。对所有子区间求和这个值的直接做法是排序后归并，但是这个做法再套上外面的分治会达到 $O(n\log^2n)$ 的复杂度。

为了去掉排序，我们可以考虑通过在分治过程中归并的方式维护出有序的 $p$ 数组和 $s$ 数组。具体来说，我们对于区间 $[l,r]$，维护出所有的 $p_i'=\max\{v_{l},v_{l+1},\cdots,v_{i-1},r_i\}$ 和 $s_i'=\max\{l_i,v_{i+1},v_{i+2},\cdots,v_{r}\}$。在对 $[l,r]$ 的中点两侧分别递归之后，$[l,m]$ 一侧的所有 $p_i'$ 均不变，可以直接继承；$[m+1,r]$ 一侧的所有 $p_i'$ 继承上来的过程中需要对 $v_{l},v_{l+1},\cdots,v_m$ 取 max，而一个有序序列对一个值取 max 之后仍然是有序的，所以我们可以分别得到有序的 $p'_{l,\cdots,m}$ 和 $p'_{m+1,\cdots,r}$。再将它们归并即可得到当前区间的 $p'$ 数组排序后的结果。$s'$ 的维护是对称的。求答案的时候，只需要分别取出左侧的有序的 $s'$ 数组和右侧的有序的 $p'$ 数组进行归并即可。

这样对一个区间分治就只需要进行若干次归并，复杂度就是线性的。再套上分治就达到了 $O(n\log n)$ 的目标复杂度，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
    char c = getchar();
    int x = 0, f = 1;
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    return x * f;
}

typedef unsigned int ui;
const int N = 1000005;
int n, a[N], pmx[N], smx[N], tmp[N];
ui ans = 0;

inline void Read() {
    n = qread();
    for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void DnC(int l, int r) {
    if (l == r) {
        pmx[l] = a[l] - a[l - 1];
        smx[l] = a[l] - a[l + 1];
        return;
    }
    int mid = l + r >> 1;
    DnC(l, mid); DnC(mid + 1, r);
    int i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (smx[i] <= pmx[j]) {
            ans += (ui)smx[i] * (ui)(j - mid - 1);
            i++;
        } else {
            ans += (ui)pmx[j] * (ui)(i - l);
            j++;
        }
    }
    while (i <= mid) {
        ans += (ui)smx[i] * (ui)(j - mid - 1);
        i++;
    }
    while (j <= r) {
        ans += (ui)pmx[j] * (ui)(i - l);
        j++;
    }
    int mxv = -0x3f3f3f3f;
    for (int i = l;i <= mid;i++) mxv = max(mxv, a[i] - max(a[i + 1], a[i - 1]));
    for (int i = mid + 1;i <= r;i++) pmx[i] = max(pmx[i], mxv);
    mxv = -0x3f3f3f3f;
    for (int i = mid + 1;i <= r;i++) mxv = max(mxv, a[i] - max(a[i + 1], a[i - 1]));
    for (int i = l;i <= mid;i++) smx[i] = max(smx[i], mxv);
    merge(pmx + l, pmx + mid + 1, pmx + mid + 1, pmx + r + 1, tmp + l);
    for (int i = l;i <= r;i++) pmx[i] = tmp[i];
    merge(smx + l, smx + mid + 1, smx + mid + 1, smx + r + 1, tmp + l);
    for (int i = l;i <= r;i++) smx[i] = tmp[i];
}

int main() {
    Read();
    ans = 0;
    DnC(1, n);
    cout << ans << endl;
    return 0;
}
```



---

## 作者：xiaosi4081 (赞：1)

区间问题考虑分治，在 $solve(l, r)$ 内我们处理包含 $m, m+1$ 这两项的区间（为什么不是只包含一个？因为问题中区间长度至少为 $2$）。剩下的部分递归下去 $solve(l, m)$ 和 $solve(m+1, t)$，$m$ 为中点，也即 $\lfloor\frac{l+r}2 \rfloor$。

一段区间可以拆分成头，尾，中间，中间又可以分成两段和头、尾分别合并起来。中间在计算的时候我们直接按照 $p_i-\max(p_{i-1}, p_{i+1})$ 算，然后头和尾我们就只考虑一边，从中点往两边跑，然后再任取两边中的两端点，其对应值取 $\max$。换种说法，把区间拆成 $[l', m]$ 和 $[m+1, r']$ 分开计算。

取 $\max$ 后算贡献是简单的，我们对两边求得的结果排序后一边遍历，另一边双指针就可以了（注意要跑两遍，分别对应两边）。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6+5, mod = (1ll<<32);
int n, x[N], y[N], f[N], a[N], ans, res;
void solve(int l, int r){
	if(l == r) return;
	int m = l+r>>1;
	for(int i = l; i <= r; i++) x[i] = y[i] = -2e9;
	for(int i = m-1; i >= l; i--) x[i] = max(x[i+1], f[i+1]);
	for(int i = m+1; i <= r; i++) y[i] = max(y[i-1], f[i-1]);
	for(int i = l; i <= m; i++) x[i] = max(x[i], a[i]-a[i+1]);
	for(int i = m+1; i <= r; i++) y[i] = max(y[i], a[i]-a[i-1]);
	sort(y+m+1, y+1+r), sort(x+l, x+1+m);
	int curr = m;
	for(int i = l; i <= m; i++){
		while(curr < r && x[i] >= y[curr+1]) ++curr;
		ans += (curr-m)*x[i]%mod;
		ans %= mod;
	} curr = l-1;
	for(int i = m+1; i <= r; i++){
		while(curr < m && x[curr+1] < y[i]) ++curr;
		ans += (curr-l+1)*y[i]%mod;
		ans %= mod;
	}
	solve(l, m), solve(m+1, r);
}
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	a[0] = -2e9, a[n+1] = -2e9;
	for(int i = 1; i <= n; i++) f[i] = a[i]-max(a[i-1], a[i+1]);
	solve(1, n);
	cout << ans%mod;
	return 0;
}
```

---

## 作者：_XHY20180718_ (赞：1)

提供一种不用分治的~~大常数~~做法。

设 $A_i=a_i-a_{i+1}$，$B_i=a_i-max\{a_{i-1},a_{i+1}\}$，$C_i=a-a_{i-1}$。

$$
f_{l,r}=\max\{A_l,\max_{i=l+1}^{r-1}B_i,C_r\}
$$

考虑拆贡献，统计每一个数作为最大值的次数。

对于一个 $A_i$，向右二分找到第一个大于 $A_i$ 的 $B_j$，然后形成了一个区间：$[i+1,j-1]$，接下来只要找到有多少 $C_i$ 比 $A_i$ 小，然后在对这个区间进行二维数点就是 $A_i$ 的贡献次数，离线下来求前缀和，也就是求出 $[1,i]$ 和 $[1,j-1]$ 中有多少比 $A_i$ 小的 $C_j$，然后相减就是 $A_i$ 的贡献次数，$C_i$ 的贡献次数同理。

对于一个 $B_i$，向左右两边二分找到能在序列 $\{B\}$ 中取到最小值的区间，这个时候我们要以 $i$ 为分界点，在区间找到有多少个 $A_i$ 比 $B_i$ 小，在又区间找出有多少个 $C_i$ 比 $B_i$ 小，同样的，离线下来然后二维数点即可。

代码：
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
const int N=1e6+5,inf=1e9,P=(1ll<<32ll);
vector<int>L[N],LB[N];
vector<int>R[N],RB[N];
int n,m,Log[N];
int a[N],A[N],B[N],C[N];
int AA[N],BB[N],CC[N];
int D[N*3],st[21][N],c[N*3];
unsigned int ans;
inline void upd(int x)
{for(; x<=m; x+=lowbit(x))++c[x];}
inline int qry(int x,int res=0)
{for(; x; x-=lowbit(x))res+=c[x];return res;}
inline int getmax(int l,int r){
    if(l>r){cerr<<"???\n";return -inf;}
    r=min(r,n);
    int s=Log[r-l+1];
    return max(st[s][l],st[s][r-(1<<s)+1]);
}
struct Query{int lw,rw;}qr[N];
struct QueryB{int law,raw,lcw,rcw;}qrb[N];
signed main(){
    ios::sync_with_stdio(0);cin>>n;
    for(int i=2; i<=n; ++i)Log[i]=Log[i>>1]+1;
    for(int i=1; i<=n; ++i)cin>>a[i];
    for(int i=1; i<=n; ++i){
        AA[i]=A[i]=(i<n?a[i]-a[i+1]:-inf);
        CC[i]=C[i]=(1<i?a[i]-a[i-1]:-inf);
        BB[i]=B[i]=((1<i&&i<n)?a[i]-max(a[i-1],a[i+1]):-inf);
        D[++m]=A[i],D[++m]=B[i],D[++m]=C[i];
    }
    sort(D+1,D+1+m);
    m=unique(D+1,D+1+m)-D-1;
    for(int i=1; i<=n; ++i)
        A[i]=lower_bound(D+1,D+1+m,A[i])-D,
        B[i]=lower_bound(D+1,D+1+m,B[i])-D,
        C[i]=lower_bound(D+1,D+1+m,C[i])-D,
        st[0][i]=B[i];
    for(int j=1; j<=Log[n]; ++j)
        for(int i=1; i+(1<<j)-1<=n; ++i)
            st[j][i]=max(st[j-1][i],st[j-1][i+(1<<j-1)]);
    for(int i=2; i<n; ++i){
        int l=i+1,r=n+1,mid;
        while(l<r){
            mid=l+(r-l>>1);
            if(getmax(i+1,mid)>=B[i])r=mid;
            else l=mid+1;
        }
        LB[i].push_back(i);
        RB[r-1].push_back(i);
    }
    for(int i=n-1; i; --i){
        int l=i+1,r=n,mid;
        while(l<r){
            mid=l+(r-l>>1);
            if(getmax(i+1,mid)>=A[i]) r=mid;
            else l=mid+1;
        }
        L[i].push_back(i);
        R[r].push_back(i);
    }
    for(int i=1; i<=n; ++i){
        upd(C[i]);
        for(auto j:LB[i])qrb[j].lcw=qry(B[j]);
        for(auto j:RB[i])qrb[j].rcw=qry(B[j]);
        for(auto j:L[i])qr[j].lw=qry(A[j]);
        for(auto j:R[i])qr[j].rw=qry(A[j]);
    }memset(c,0,sizeof c);
    for(int i=1; i<n; ++i)
        (ans+=(unsigned int)(AA[i])*(unsigned int)(qr[i].rw-qr[i].lw));
    memset(qr,0,sizeof qr);
    for(int i=1; i<=n; ++i)
        LB[i].clear(),L[i].clear(),
        RB[i].clear(),R[i].clear();
    for(int i=2; i<n; ++i){
        int l=1,r=i-1,mid;
        while(l<r){
            mid=l+(r-l>>1);
            if(getmax(mid,i-1)>B[i])l=mid+1;
            else r=mid;
        }
        LB[r-1].push_back(i);
        RB[i-1].push_back(i);
    }
    for(int i=2; i<=n; ++i){
        int l=1,r=i-1,mid;
        while(l<r){
            mid=l+(r-l>>1);
            if(getmax(mid,i-1)>=C[i])l=mid+1;
            else r=mid;
        }
        L[r-1].push_back(i);
        R[i-1].push_back(i);
    }
    for(int i=1; i<=n; ++i){
        upd(A[i]);
        for(auto j:LB[i])qrb[j].law=qry(B[j]);
        for(auto j:RB[i])qrb[j].raw=qry(B[j]);
        for(auto j:L[i])qr[j].lw=qry(C[j]-1);
        for(auto j:R[i])qr[j].rw=qry(C[j]-1);
    }
    for(int i=2; i<=n; ++i)
        ans+=(unsigned int)(CC[i])*(unsigned int)(qr[i].rw-qr[i].lw);
    for(int i=2; i<n; ++i)
        ans+=(unsigned int)(BB[i])*(unsigned int)(qrb[i].raw-qrb[i].law)*(unsigned int)(qrb[i].rcw-qrb[i].lcw);
    cout<<ans<<'\n';
    return 0;
}
```


---


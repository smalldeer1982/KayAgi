# [国家集训队] 排队 加强版

## 题目背景

[P1975](https://www.luogu.com.cn/problem/P1975) 的加强版，两题中仅数据范围不同。

## 题目描述

排排坐，吃果果，生果甜嗦嗦，大家笑呵呵。你一个，我一个，大的分给你，小的留给我，吃完果果唱支歌，大家乐和和。

红星幼儿园的小朋友们排起了长长地队伍，准备吃果果。不过因为小朋友们的身高有所区别，排成的队伍高低错乱，极不美观。设第 $i$ 个小朋友的身高为 $h_i$。

幼儿园阿姨每次会选出两个小朋友，交换他们的位置，请你帮忙计算出每次交换后，序列的逆序对数。为方便幼儿园阿姨统计，在未进行任何交换操作时，你也应该输出该序列的逆序对数。

## 说明/提示

### 样例说明 

未进行任何操作时，$(2,3)$ 为逆序对；  
操作一结束后，序列为 $130 \ 140 \ 150$，不存在逆序对；  
操作二结束后，序列为 $150 \ 140 \ 130$，$(1,2),(1,3),(2,3)$ 共 $3$ 个逆序对。

### 数据范围

对于所有数据，保证：

- $1\le n\le 2\times10^5$
- $1\le m\le 2\times10^5$
- $1\le h_i\le 10^9$
- $1\le a_i,b_i\le n,a_i\neq b_i$

## 样例 #1

### 输入

```
3
130 150 140
2
2 3
1 3```

### 输出

```
1
0
3```

# 题解

## 作者：Zelensky (赞：12)

动态逆序对问题。

逆序对相关问题，考虑交换两个数只会对两个数之间的逆序对产生影响。

分别求出交换前后这两个数在区间内的逆序对数，进而求出答案变化量。

一个数在区间内的逆序对数本质上就是区间内有多少数大于或小于这个数。这是一个典型的树套树问题，用树套树维护答案的变化量即可。

**注意**

1. 序列一开始就存在逆序对。
2. 特殊考虑交换的两个数之间的贡献。
3. 选用常数较小的写法。
4. 答案可达到 $n^2$ 级别，记得开 ```long long``` 。

代码采用了树状数组套权值线段树（带修主席树）维护操作。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,len;
int lowbit(int x){return x&-x;}
int cntl,cntr;
struct SEG{
	int cnt=0,L[(int)5e6],R[(int)5e6];
	int siz[(int)5e7],ls[(int)5e7],rs[(int)5e7];
	void add(int &i,int l,int r,int x,int k){
		if(!i)i=++cnt;siz[i]+=k;
		if(l==r)return ;
		int mid=(l+r)>>1;
		if(x<=mid)add(ls[i],l,mid,x,k);
		else add(rs[i],mid+1,r,x,k);
	}
	int get_rk(int l,int r,int k,int opt){
		int s=0;
		if(l==r){
			for(int i=1;i<=cntl;i++)s-=siz[L[i]];for(int i=1;i<=cntr;i++)s+=siz[R[i]];
			return s*opt;
		}
		int mid=(l+r)>>1;
		for(int i=1;i<=cntl;i++)s-=siz[ls[L[i]]];for(int i=1;i<=cntr;i++)s+=siz[ls[R[i]]];
		if(k<=mid){
			for(int i=1;i<=cntl;i++)L[i]=ls[L[i]];for(int i=1;i<=cntr;i++)R[i]=ls[R[i]];
			return get_rk(l,mid,k,opt);
		}
		else {
			for(int i=1;i<=cntl;i++)L[i]=rs[L[i]];for(int i=1;i<=cntr;i++)R[i]=rs[R[i]];
			return get_rk(mid+1,r,k,opt)+s;
		}
	}
}T;
struct BIT{
	int rt[(int)5e6];
	void add(int i,int x,int k){for(;i<=n;i+=lowbit(i)){T.add(rt[i],1,len,x,k);}}
	int get(int x,int y,int k,int opt){
		cntl=cntr=0;
		for(int i=x-1;i;i-=lowbit(i))T.L[++cntl]=rt[i];
		for(int i=y;i;i-=lowbit(i))T.R[++cntr]=rt[i];
		return T.get_rk(1,len,k,opt);
	}
}t;
int a[(int)5e6],v[(int)5e6],b[(int)5e6];
long long ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){cin>>a[i];b[i]=a[i];v[i]=1;}
	sort(b+1,b+n+1);len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+len+1,a[i])-b;
		t.add(i,a[i],v[i]);
	}
	for(int i=1;i<=n;i++)ans+=t.get(i,n,a[i],0);
	cout<<ans<<'\n';
	cin>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		if(x>y)swap(x,y);
		int num=y-x+1,ax=a[x],ay=a[y],vx=v[x],vy=v[y];
		if(a[y]<a[x])ans++;else if(a[x]<a[y]) ans--;
		int old=t.get(x,y,a[x],0)+num-t.get(x,y,a[y],1);
		t.add(x,ax,-vx),t.add(x,ay,vy);
		t.add(y,ay,-vy),t.add(y,ax,vx);
		swap(a[x],a[y]),swap(v[x],v[y]);
		int nw=t.get(x,y,a[x],0)+num-t.get(x,y,a[y],1);
		ans=ans+nw-old;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：SegmentTree_ (赞：11)

很暴力的分块做法。  
离散化后，对序列和值域分别分块。用 $b_i$ 表示 $i$ 所在的块的编号，$c1_{i,j}$ 表示序列上前 $i$ 个块有几个身高在值域的第 $j$ 个块里，$c2_{i,j}$ 表示序列上前 $i$ 个块有几个身高等于 $k$。  
对于一个位置 $p$。它的贡献可以拆成块 $1\sim b_p-1$ 中比它高的、块 $b_p$ 内的贡献和块 $b_p+1\sim b_n$ 中比它矮的。  
把交换拆成两次单点修改。单点修改时，直接减掉原身高的贡献，再加上新身高的贡献，同时维护 $c1$ 和 $c2$。  
原序列的逆序对可以用树状数组求，也可以预处理 $c1$ 和 $c2$ 的时候求。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<int, int> pii;
const int N = 2e5+5;
namespace tianyu{
	const int B = 1000, BT = (N - 1) / B + 3;
	int n, m;
	int a[N], b[N], bel[N], bl[BT], br[BT], bt;
	int cnt1[BT][BT], cnt2[BT][N];
	ll now = 0;
	void modify(int p, int x){
		int X = bel[p], V = bel[a[p]];
		for (int i = V + 1;i <= bt;i++) now -= cnt1[X - 1][i];
		for (int i = a[p] + 1;i <= br[V];i++) now -= cnt2[X - 1][i];
		for (int i = 1;i < V;i++) now -= cnt1[bt][i] - cnt1[X][i];
		for (int i = bl[V];i < a[p];i++) now -= cnt2[bt][i] - cnt2[X][i];
		for (int i = bl[X];i < p;i++) now -= (a[i] > a[p]);
		for (int i = p + 1;i <= br[X];i++) now -= (a[p] > a[i]);
		V = bel[x];
		for (int i = V + 1;i <= bt;i++) now += cnt1[X - 1][i];
		for (int i = x + 1;i <= br[V];i++) now += cnt2[X - 1][i];
		for (int i = 1;i < V;i++) now += cnt1[bt][i] - cnt1[X][i];
		for (int i = bl[V];i < x;i++) now += cnt2[bt][i] - cnt2[X][i];
		for (int i = bl[X];i < p;i++) now += (a[i] > x);
		for (int i = p + 1;i <= br[X];i++) now += (x > a[i]);
		for (int i = X;i <= bt;i++){
			cnt1[i][bel[a[p]]]--;
			cnt2[i][a[p]]--;
			cnt1[i][bel[x]]++;
			cnt2[i][x]++;
		}
		a[p] = x;
	}
	void awa(){
		cin >> n;
		for (int i = 1;i <= n;i++) cin >> a[i], b[i] = a[i];
		sort(b + 1, b + 1 + n);
		for (int i = 1;i <= n;i++) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b;
		for (int i = 1;i <= n;i++) bel[i] = (i - 1) / B + 1;
		bt = bel[n];
		for (int i = 1;i <= bt;i++) bl[i] = (i - 1) * B + 1, br[i] = i * B;
		br[bt] = n;
		for (int i = 1;i <= bt;i++){
			for (int j = bl[i];j <= br[i];j++){
				cnt1[i][bel[a[j]]]++;
				cnt2[i][a[j]]++;
				for (int k = bl[i];k < j;k++) now += (a[k] > a[j]);
				for (int k = bel[a[j]] + 1;k <= bt;k++) now += cnt1[i - 1][k];
				for (int k = a[j] + 1;k <= br[bel[a[j]]];k++) now += cnt2[i - 1][k];
			}
			for (int j = 1;j <= n;j++) cnt2[i][j] += cnt2[i - 1][j];
			for (int j = 1;j <= bt;j++) cnt1[i][j] += cnt1[i - 1][j];
		}
		cout << now << '\n';
		cin >> m;
		while (m--){
			int x, y;
			cin >> x >> y;
			auto [u, v] = pii{a[x], a[y]};
			modify(x, v);
			modify(y, u);
			cout << now << '\n';
		}
	}
}
signed main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	int T = 1;
	while (T--) tianyu::awa();
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：10)

哈哈哈是 cdq 分治板子。

就是当成三元组 $(t,p,k)$，表示操作时间，位置，值，树状数组就可以 $O(n\log^2 n)$ 咯。

感觉其它高级数据结构都没有 cdq 分治直接明了，清晰简单。

交换就是删除再加入，很无脑。

这题还是太经典了，不想写得太水。

虽然随便写都是 2s 以内，但还是可以提供卡常小技巧。

- 我们存在 $O((r-l+1)^2)$ 的暴力，所以如果 $r-l+1<\log n$ 时可以直接暴力。

由于树状数组带点常数，我开的分界点是 $100$。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
#define OK y^fa&&!vis[y]
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=1e6+5;
int n,m,a[N],lsh[N],b[N],ln,g;
ll out[N];
struct node{
	int ty,p,k,id;
}q[N];
inline bool cmp(node a,node b){
	return a.p<b.p;
}
int t[N];
inline void ad(int x,int k){
	while(x<=ln)t[x]+=k,x+=x&-x;
}
inline int query(int x){
	int ans=0;
	while(x)ans+=t[x],x-=x&-x;
	return ans;
}
inline void clear(int x){
	while(x<=ln)t[x]=0,x+=x&-x;
}
inline void cdq(int l,int r){
	if(l>=r)return;
	cdq(l,mid),cdq(mid+1,r);
	if(r-l+1<=100){
		rep(i,l,mid)rep(j,mid+1,r){
			if(q[i].p<q[j].p)out[q[j].id]+=(q[i].k>q[j].k)*q[i].ty*q[j].ty;
			if(q[i].p>q[j].p)out[q[j].id]+=(q[i].k<q[j].k)*q[i].ty*q[j].ty;
		}
		return;
	}
	
	sort(q+l,q+mid+1,cmp),sort(q+mid+1,q+r+1,cmp);
	int Ll=l;
	rep(Rr,mid+1,r){
		while(Ll<=mid&&q[Ll].p<q[Rr].p)ad(q[Ll].k,q[Ll].ty),Ll++;
		out[q[Rr].id]+=q[Rr].ty*(query(ln)-query(q[Rr].k));
	}
	rep(i,l,Ll-1)clear(q[i].k);
	Ll=mid;
	per(Rr,r,mid+1){
		while(Ll>=l&&q[Ll].p>q[Rr].p)ad(q[Ll].k,q[Ll].ty),Ll--;
		out[q[Rr].id]+=q[Rr].ty*query(q[Rr].k-1);
	}
	rep(i,Ll+1,mid)clear(q[i].k);
}
inline void Main(){
	n=read();
	repn(i)lsh[i]=a[i]=read();
	sort(lsh+1,lsh+n+1);
	repn(i)if(lsh[i]^lsh[i+1])b[++ln]=lsh[i];
	repn(i)a[i]=lower_bound(b+1,b+ln+1,a[i])-b;
	m=read();
	repn(i)q[++g]={1,i,a[i],0};
	repm(i){
		int x=read(),y=read();
		q[++g]={-1,x,a[x],i},q[++g]={-1,y,a[y],i},q[++g]={1,x,a[y],i},q[++g]={1,y,a[x],i},swap(a[x],a[y]);
	}
	cdq(1,g);
	repm(i)out[i]+=out[i-1];
	rep(i,0,m)printf("%lld\n",out[i]);
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}
```

---

## 作者：_Sparkle (赞：5)

猫猫们，是加强版，我们有救了喵！

因为时限给的非常充裕，加上我最近刚换了一个光滑的新脑子，所以我要分块块喵。

考虑计算每一次更改 $x$，$y$（$x<y$）对于原来逆序对个数的代价喵。猫猫们如果发现 $x>y$ 了记得换一下喵。

对于两边的散块块：

依次遍历每个数 $h_i$。如果 $h_x > h_i$，那么当把 $h_x$ 换到后面去了以后，逆序对的个数就减少了喵；要是 $h_x < h_i$，那么把 $h_x$ 换到后面去，逆序对的个数就多了一个喵。

同理，$h_y$ 也可以这样去想喵。

对于中间的大块块：

对于每一个大块块我们都开一个树状数组喵，用来记录大块块中每一个数的个数。对于 $h_x$，我们遍历每一个中间的大块块，然后整体的考虑 $h_x$ 移到后面会造成什么影响：交换完后，块块中原本大于 $h_x$ 的数的个数被加上了，块块中小于 $h_x$ 的数的个数被减掉了。

同理，$h_y$ 也可以这样处理喵。

如果有些晕晕可以看看猫猫用爪爪敲的一点点代码喵：

注意块长喵，因为有个树状数组，如果你直接取 $\sqrt{n}$ 可能会 T 掉喵（？）

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

const int maxn = 2e5 + 10, maxm = 1880;

#define ll long long

int n, m;
int a[maxn], b[maxn];
int blo[maxn], blocnt, siz, l[maxn], r[maxn];
ll res[maxn], ans;

struct BIT
{
    ll c[maxn];
    ll lowbit(ll x) { return x & (-x); }
    void add(int x, ll y)
    {
        if (x <= 0) return;
        for (; x <= n; x += lowbit(x)) 
            c[x] += y;
    }
    ll query(int x)
    {
        if (x <= 0) return 0;
        ll res = 0;
        for (; x; x -= lowbit(x))
            res += c[x];
        return res;
    }
} t[maxm];

int main()
{
    std::ios::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0);

    cin >> n;
    siz = sqrt(n * log2(n));
    for (int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i], blo[i] = i / siz + (i % siz != 0);
    sort(b + 1, b + n + 1);
    int tot = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b;
    blocnt = blo[n];
    for (int i = 1; i <= n; i++)
    {
        if (blo[i] != blo[i - 1]) 
            l[blo[i]] = i;
        r[blo[i]] = i;
    }
    for (int i = 1; i <= n; i++)
        t[0].add(a[i], 1),
        ans += i - t[0].query(a[i]);
    cout << ans << "\n";
    for (int i = 1; i <= blocnt; i++)
        for (int j = l[i]; j <= r[i]; j++)
        {
            t[i].add(a[j], 1);
            res[i] += j - l[i] + 1 - t[i].query(a[j]);
        }
    cin >> m;
    while (m--)
    {
        int x, y;
        cin >> x >> y;
        if (x > y) swap(x, y);
        int pre = upper_bound(l + 1, l + blocnt + 1, x) - l;
        int suf = lower_bound(r + 1, r + blocnt + 1, y) - r - 1;
        if (a[x] < a[y]) ans++;
        if (a[y] < a[x]) ans--;
        if (pre <= suf)
        {
            for (int i = x + 1; i < l[pre]; i++)
            {
                if (a[x] < a[i]) ans++;
                if (a[x] > a[i]) ans--;
                if (a[y] > a[i]) ans++;
                if (a[y] < a[i]) ans--;
            }
            for (int i = pre; i <= suf; i++)
            {
                ans -= t[i].query(a[x] - 1);
                ans += t[i].query(n) - t[i].query(a[x]);
                ans -= t[i].query(n) - t[i].query(a[y]);
                ans += t[i].query(a[y] - 1);
            }
            for (int i = r[suf] + 1; i < y; i++)
            {
                if (a[x] < a[i]) ans++;
                if (a[x] > a[i]) ans--;
                if (a[y] > a[i]) ans++;
                if (a[y] < a[i]) ans--;
            }
        }
        else 
        {
            for (int i = x + 1; i < y; i++)
            {
                if (a[x] < a[i]) ans++;
                if (a[x] > a[i]) ans--;
                if (a[y] > a[i]) ans++;
                if (a[y] < a[i]) ans--;
            }
        }
        t[pre - 1].add(a[x], -1);
        t[suf + 1].add(a[y], -1);
        t[pre - 1].add(a[y], 1);
        t[suf + 1].add(a[x], 1);
        swap(a[x], a[y]);
        cout << ans << "\n";
    }
    return 0;
}
```

猫猫是豪猫，不哈人喵 /w\

---

## 作者：rhn7 (赞：3)

树套树板子题，不会树套树请右转 [P2617](https://www.luogu.com.cn/problem/P2617)。

我们发现交换 $h_a$ 和 $h_b$ 其实就是在 $a$ 处删除 $h_a$，$a$ 处添加 $h_b$，$b$ 处删除 $h_b$，$b$ 处添加 $h_a$。

考虑在 $x$ 处添加 $v$ 对答案的影响（删除同理）：

- 加上区间 $[1,x-1]$ 中数值在 $[v+1,10^9]$ 的个数
- 加上区间 $[x+1,n]$ 中数值在 $[1,v-1]$ 的个数


```cpp
void up(int x,int v,int p){//p为-1表示删除,p为1表示添加
	add(x,v,p);
    ans+=p*cal(1,x-1,v+1,lg);
	ans+=p*cal(x+1,n,1,v-1);
}
```

直接上树套树实现这个 `add` 和 `cal`，时间复杂度为 $O(n\log^2 n)$。

关键是树套树自带大常数，咱们还把一次操作拆成四次修改，八次查询，时空都会被卡飞，所以要用一些小寄巧：

- 将 $h$ 数组离散化，这样可以减少线段树递归层数。

- 最开始统计逆序对时不要偷懒树套树，再新开一个权值树状数组。

- 能不开 `long long` 就不开。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n,m,a,b,g[N],lg,h[N],rt[N],tot;
long long ans;
struct Node{
	int ls,rs,sum;
} t[N<<5];
void update(int &id,int l,int r,int x,int v){
	if(!id) id=++tot;
	t[id].sum+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid) update(t[id].ls,l,mid,x,v);
	else update(t[id].rs,mid+1,r,x,v);
}
long long query(int id,int l,int r,int x,int y){
	if(x<=l&&r<=y) return t[id].sum;
	int mid=(l+r)>>1;
	long long res=0;
	if(x<=mid) res+=query(t[id].ls,l,mid,x,y);
	if(y>mid) res+=query(t[id].rs,mid+1,r,x,y);
	return res;
}
void add(int x,int y,int v){
	for(int i=x;i<=n;i+=i&(-i)) update(rt[i],1,lg,y,v);
}
inline int cal(int l,int r,int x,int y){
	if(l>r||x>y) return 0;
	int res=0;
	for(int i=r;i;i-=i&(-i)) res+=query(rt[i],1,lg,x,y);
	for(int i=l-1;i;i-=i&(-i)) res-=query(rt[i],1,lg,x,y);
	return res;
}
inline void up(int x,int v,int p){
	add(x,v,p);
    ans+=p*cal(1,x-1,v+1,lg);
	ans+=p*cal(x+1,n,1,v-1);
}
int c[N];
void add2(int x){
	for(int i=x;i<=lg;i+=i&(-i)) c[i]++;
}
inline int cal2(int x){
	int res=0;
	for(int i=x;i;i-=i&(-i)) res+=c[i];
	return res;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i]);
		g[++lg]=h[i];
	}
    sort(g+1,g+lg+1);lg=unique(g+1,g+lg+1)-g-1;
    for(int i=1;i<=n;i++){
        h[i]=lower_bound(g+1,g+lg+1,h[i])-g;
        add(i,h[i],1);add2(h[i]);
        ans+=cal2(lg)-cal2(h[i]);
    }
	printf("%lld\n",ans);
	scanf("%d",&m);
	while(m--){
		scanf("%d%d",&a,&b);
		up(a,h[a],-1);up(a,h[b],1);
		up(b,h[b],-1);up(b,h[a],1);
		swap(h[a],h[b]);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：EricWan (赞：3)

使用蛮力，二维树状数组维护动态逆序对。

使劲卡自己的哈希，然后就可以过。

把序列想象为二维平面上的点，横坐标为下标，纵坐标为函数值。

所有操作都可以抽象为“加点”和“删点”。

“加点”为将答案加上这个点和别的点产生的逆序对数量，然后更新树状数组。

“删点”为将答案减去这个点和别的点产生的逆序对数量，然后更新树状数组。

更新树状数组好写。一个点和别的点产生的逆序对数就是这个点左上和右下的点的数量，这个东西是树状数组可以解决的。

二维树状数组的哈希需要自己写，稍微某个参数调的不对就会 TLE，乱交好几页就可以撞击出一个可以过的哈希参数组了。

具体逻辑请欣赏我的不如粑粑的代码。

```cpp
#include <set>
#include <iostream>
#include <map>
#include <math.h>
#include <cstdint>
#define lowbit(x) ((x)&-(x))
using namespace std;
uint32_t n, a[200005];
long long ans;
#define P 81108863
int *pool = (int*)((void*)(new long long[(size_t)(P * 1.2) >> 1]));
unsigned long long X[(size_t)(P * 1.2)];
int bit1[200005];
#define A 4376135492512386ull
#define B 295623ull
inline void update(uint32_t x, const uint32_t &y, const int &K) {
	while (x <= n) {
		for (uint32_t i = y; i <= n; i += lowbit(i)) {
			uint32_t k = (x * A ^ i * B) % P;
			const uint64_t &k2 = x ^ uint64_t(i) << 20;
			while (X[k] && (X[k] ^ k2)) {
				k++;
			}
			X[k] = k2;
			pool[k] += K;
		}
		x += lowbit(x);
	}
}
inline int query(uint32_t x, const uint32_t &y) {
	int ans = 0;
	while (x) {
		for (uint32_t i = y; i; i ^= lowbit(i)) {
			uint32_t k = (x * A ^ i * B) % P;
			const uint64_t &k2 = x ^ uint64_t(i) << 20;
			while (X[k] && (X[k] ^ k2)) {
				k++;
			}
			ans += pool[k];
		}
		x ^= lowbit(x);
	}
	return ans;
}
inline int getans(const uint32_t &i, const uint32_t &x) {
	return i - 1 - query(i - 1, x) + query(n, x - 1) - query(i, x - 1);
}
signed main() {
	// ios::sync_with_stdio(0);
	// cin.tie(0);
	// cout.tie(0);
//	freopen("P12685.in", "r", stdin);
//	freopen("out2", "w", stdout);
    scanf("%d", &n);
	for (uint32_t i = 1; i <= n; i++) {
        scanf("%d", a + i);
	}
	set<uint32_t> st(a + 1, a + n + 1);
	uint32_t cnt = 0;
	map<uint32_t, uint32_t> mp;
	for (set<uint32_t>::iterator i = st.begin(); i != st.end(); i++) {
		mp[*i] = ++cnt;
	}
	for (uint32_t i = 1; i <= n; i++) {
		a[i] = mp[a[i]];
		ans += i - 1;
		for (int j = a[i]; j; j ^= lowbit(j)) {
			ans -= bit1[j];
		}
		for (int j = a[i]; j <= n; j += lowbit(j)) {
			bit1[j]++;
		}
		update(i, a[i], 1);
	}
	printf("%lld\n", ans);
	uint32_t T, u, v;
    scanf("%d", &T);
    // T /= 2;
    while (T--) {
        scanf("%d%d", &u, &v);
		if (u > v) {
			swap(u, v);
		}
		uint32_t au = a[u], av = a[v];
        swap(a[u], a[v]);
        ans -= getans(u, au);
        update(u, au, -1);
        update(u, av, 1);
        ans += getans(u, av);
        ans -= getans(v, av);
        update(v, av, -1);
        update(v, au, 1);
        ans += getans(v, au);
        printf("%lld\n", ans);
	}
	return 0;
}
```

Update 20250713

其实我们只需要关注中间的点就可以，因为其他地方的点无贡献。具体的贡献除了 $(u,v)$ 这一对点，只有下面的这些。

![](https://cdn.luogu.com.cn/upload/image_hosting/rkff9hu1.png)

统计二维平面上的子矩形数点，继续用二维树状数组，然后我们对每一个权值开一个平衡树维护上面的那两条的贡献。这样瓶颈处就是 8 次二维树状数组操作，可以更轻松第通过。

```cpp
#include <set>
#include <cstring>
#include <iostream>
#include <map>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define lowbit(x) ((x)&-(x))
using namespace std;
using u32 = unsigned int;
using u64 = unsigned long long;
__gnu_pbds::tree<u32,
				 __gnu_pbds::null_type,
				 less<int>,
				 __gnu_pbds::rb_tree_tag,
				 __gnu_pbds::tree_order_statistics_node_update> pos[200005];
u32 n, T, u, v, a[200005];
u64 ans;
u32 bit[200005];
#define P 71108863
#define A 4376135492512386ull
#define B 295623ull
u32 pool[(size_t)(P * 1.2)];
u64 X[(size_t)(P * 1.2)];
inline u32 query(u32 x, u32 y) {
	// i<=x, j<=y
	u32 ans = 0;
	while (x) {
		for (u32 i = y; i; i ^= lowbit(i)) {
			u32 k = (x * A ^ i * B) % P;
			u64 k2 = x ^ u64(i) << 20;
			while (X[k] && (X[k] ^ k2)) {
				k++;
			}
			ans += pool[k];
		}
		x ^= lowbit(x);
	}
	return ans;
}
inline void update(u32 x, u32 y, u32 K) {
	// i<=x, j<=y, +=K
	while (x <= n) {
		for (u32 i = y; i <= n; i += lowbit(i)) {
			u32 k = (x * A ^ i * B) % P;
			u64 k2 = x ^ u64(i) << 20;
			while (X[k] && (X[k] ^ k2)) {
				k++;
			}
			X[k] = k2;
			pool[k] += K;
		}
		x += lowbit(x);
	}
}
signed main() {
	scanf("%u", &n);
	for (u32 i = 1; i <= n; ++i) {
		scanf("%u", a + i);
	}
	set<u32> st(a + 1, a + n + 1);
	u32 cnt = 0;
	map<u32, u32> mp;
	for (set<u32>::iterator i = st.begin(); i != st.end(); i++) {
		mp[*i] = ++cnt;
	}
	for (u32 i = 1; i <= n; ++i) {
		a[i] = mp[a[i]];
		pos[a[i]].insert(i);
		ans += i - 1;
		for (u32 j = a[i]; j; j ^= lowbit(j)) {
			ans -= bit[j];
		}
		for (u32 j = a[i]; j <= n; j += lowbit(j)) {
			bit[j]++;
		}
		update(i, a[i], 1);
	}
	printf("%llu\n", ans);
	scanf("%u", &T);
	while (T--) {
		scanf("%u%u", &u, &v);
		if (a[u] == a[v]) {
			printf("%llu\n", ans);
			continue;
		}
		if (u > v) {
			swap(u, v);
		}
		if (a[u] < a[v]) {
			++ans;
		} else {
			--ans;
		}
		update(u, a[u], -1);
		update(v, a[v], -1);
		pos[a[u]].erase(u);
		pos[a[v]].erase(v);
		if (u + 1 == v) {
			swap(a[u], a[v]);
			update(u, a[u], 1);
			update(v, a[v], 1);
			pos[a[u]].insert(u);
			pos[a[v]].insert(v);
			printf("%llu\n", ans);
			continue;
		}
		if (a[u] < a[v]) {
			ans += pos[a[u]].order_of_key(v) - pos[a[u]].order_of_key(u);
			ans += pos[a[v]].order_of_key(v) - pos[a[v]].order_of_key(u);
		} else {
			ans -= pos[a[u]].order_of_key(v) - pos[a[u]].order_of_key(u);
			ans -= pos[a[v]].order_of_key(v) - pos[a[v]].order_of_key(u);
		}
		if (min(a[u], a[v]) + 1 == max(a[u], a[v])) {
			swap(a[u], a[v]);
			update(u, a[u], 1);
			update(v, a[v], 1);
			pos[a[u]].insert(u);
			pos[a[v]].insert(v);
			printf("%llu\n", ans);
			continue;
		}
		u32 mid_cnt = query(v, max(a[u], a[v]) - 1)
					- query(v, min(a[u], a[v]))
					- query(u, max(a[u], a[v]) - 1)
					+ query(u, min(a[u], a[v]));
		// cout << "mid_cnt " << mid_cnt << endl;
		if (a[u] < a[v]) {
			ans += mid_cnt << 1;
		} else {
			ans -= mid_cnt << 1;
		}
		swap(a[u], a[v]);
		update(u, a[u], 1);
		update(v, a[v], 1);
		pos[a[u]].insert(u);
		pos[a[v]].insert(v);
		printf("%llu\n", ans);
	}
	return 0;
}
```

---

## 作者：Argon_Cube (赞：3)

考虑交换两个数 $a_l,a_r$ 对逆序对个数的影响。不失一般性的，我们令 $l<r$ 且 $a_l<a_r$。$a_l>a_r$ 是同理的（基本上只是把加改成减），$a_l=a_r$ 是显然的。

首先交换后会增加一对逆序对 $(l,r)$。接下来，显然能对答案改变产生贡献的 $i$ 必定满足 $a_l\leq a_i\leq a_r,l\leq i\leq r$。进一步的，通过简单讨论可以发现此时对于每个 $a_i$，它会让交换后的答案增加 $[a_l<a_i<a_r]+[a_l=a_i]+[a_r=a_i]$。

现在我们只需要做到：单点修改，查询一个区间内值在某个区间的数的个数。直接分块加树状数组维护即可，时间复杂度 $\Omicron(n\sqrt{n\log n})$。事实上它在本题最大点用时不超过两秒。

---

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <bitset>
#include <string>
#include <array>

#define rgall(arr)          (arr).begin(),(arr).end()
#define rgo1(arr,cnt)       (arr).begin()+1,(arr).begin()+1+(cnt)
#define rgcnt(arr,cnt)      (arr).begin(),(arr).begin()+(cnt)
#define rgany(arr,rgl,rgr)  (arr).begin()+(rgl),(arr).begin()+(rgr)
#define fori(i,a,b)         for(int i=(a);i<=(b);i++)
#define ford(i,a,b)         for(int i=(a);i>=(b);i--)
#define fori0(i,a,b)        for(int i=(a);i<(b);i++)
#define ford0(i,a,b)        for(int i=(a);i>(b);i--)
#define fr first
#define sc second

using namespace std;

constexpr int                       maxn=2e5+1,maxb=2000;
array<array<int,maxn>,maxn/maxb+5>  bidts,vc;
array<int,maxn>                     va,vb;
int                                 cntv;

void update(int i,int a,int j)
{
    vc[j][i]+=a;
    while(i<=cntv)
        bidts[j][i]+=a,i+=i&-i;
}
int query(int i,int j)
{
    int res=0;
    while(i)
        res+=bidts[j][i],i-=i&-i;
    return res;
}

int main(int argc,char* argv[],char* envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int cnt,cntq,cntb;
    cin>>cnt,cntb=maxb;
    fori(i,1,cnt)
        cin>>va[i];
    vb=va,sort(rgo1(vb,cnt)),cntv=unique(rgo1(vb,cnt))-vb.begin()-1;
    long long ans=0;
    fori(i,1,cnt)
        va[i]=lower_bound(rgo1(vb,cntv),va[i])-vb.begin(),update(va[i],1,0),ans+=i-query(va[i],0);
    bidts[0].fill(0),cout<<ans<<'\n',cin>>cntq;
    fori(i,1,cnt)
        update(va[i],1,i/cntb);
    while(cntq--)
    {
        int a,b,a0,b0;
        cin>>a>>b;
        if(a>b)
            swap(a,b);
        a0=a/cntb,b0=b/cntb;
        int l=va[a],r=va[b];
        if(l==r)
        {
            cout<<ans<<'\n';
            continue;
        }
        if(l>r)
            swap(l,r);
        int ans0=1;
        auto f=[l,r](int i){return (va[i]>l&&va[i]<r)+(va[i]>=l&&va[i]<=r);};
        if(a0==b0)
            fori(i,a+1,b-1)
                ans0+=f(i);
        else
        {
            fori(i,a+1,(a0+1)*cntb-1)
                ans0+=f(i);
            fori(i,a0+1,b0-1)
                ans0+=2*(query(r-1,i)-query(l,i))+vc[i][r]+vc[i][l];
            fori(i,b0*cntb,b-1)
                ans0+=f(i);
        }
        cout<<(ans+=(va[a]<va[b]?1:-1)*ans0)<<'\n';
        update(va[a],-1,a0),update(va[b],-1,b0),update(va[a],1,b0),update(va[b],1,a0),swap(va[a],va[b]);
    }
    return 0;
}
```

---

## 作者：b__b (赞：1)

树套树板子。

（注：此题中的逆序对定义与 P1908 相同。我们记一个逆序对为 $(i,j)$，其中 $i < j$，$h_i > h_j$。）

我们考虑交换对逆序对数量有什么影响。我们可以把交换拆成四步：
- 删除 $a$ 位置上的数 $h_a$；
- 在 $a$ 位置上增加 $h_b$；
- 删除 $b$ 位置上的数 $h_b$；
- 在 $b$ 位置上增加 $h_a$。

我们考虑其中每一步对答案有什么影响。

考虑逆序对 $(a,x)$（$x$ 为修改前的数组中的一个下标）。如果 $h_a > h_x$，那么修改后就会增加/减少这一对逆序对。

考虑逆序对 $(x,a)$（$x$ 为修改前的数组中的一个下标）。如果 $h_a < h_x$，那么修改后就会增加/减少这一对逆序对。

因此每一次修改操作我们需要查询修改的位置 $a$ 前有多少个大于 $h_a$ 的数和修改的位置后有多少个小于 $h_a$ 的数。删除操作就减少，增加操作就加上。

用树套树实现这两个操作，常数较大，不吸氧过不了。代码有注释。
```cpp
#include <cstdio>
#include <algorithm>
const int N = 2e5 + 5;
struct {int ls, rs, val;} tree[N << 8]; //主席树
int high[N << 1], old[N << 1]; //用来离散化
int unisiz; //去重后数组的大小（可以认为是离散化后的最大值）
int root[N << 1], cnt, treel[N << 1], llen, treer[N << 1], rlen; //模板内容
int n; //如题面所说
template <int val> void upd(int &now, int bef, int pl, int pr, int x) { //模板
    if (!now) now = ++cnt;
    tree[now] = {tree[bef].ls, tree[bef].rs, tree[bef].val + val};
    if (pl != pr) {
        int mid = (pl + pr) >> 1;
        if (x <= mid) upd<val>(tree[now].ls, tree[now].ls, pl, mid, x);
        else upd<val>(tree[now].rs, tree[now].rs, mid + 1, pr, x);
    }
}
int lowbit(int x) {return x & -x;}
template <int val> void add(int x, int k) { //模板
    while (x <= n) upd<val>(root[x], root[x], 1, unisiz, k), x += lowbit(x);
}
void per(int l, int r) { //查询前的准备
    llen = rlen = 0;
    while (l) treel[++llen] = root[l], l ^= lowbit(l);
    while (r) treer[++rlen] = root[r], r ^= lowbit(r);
}
int qsmaot(int pl, int pr, int x) { //模板
    if (pl == pr) return 0;
    int mid = (pl + pr) >> 1;
    if (x <= mid) {
        for (int i = 1; i <= llen; ++i) treel[i] = tree[treel[i]].ls;
        for (int i = 1; i <= rlen; ++i) treer[i] = tree[treer[i]].ls;
        return qsmaot(pl, mid, x);
    } else {
        int sum = 0;
        for (int i = 1; i <= llen; ++i) sum -= tree[tree[treel[i]].ls].val, treel[i] = tree[treel[i]].rs;
        for (int i = 1; i <= rlen; ++i) sum += tree[tree[treer[i]].ls].val, treer[i] = tree[treer[i]].rs;
        return sum + qsmaot(mid + 1, pr, x);
    }
}
int quesma(int l, int r, int x) {
    if (!l || l > r) return 0;
    per(l - 1, r);
    return qsmaot(1, unisiz, x);
}
int quebig(int l, int r, int x) {
    if (!l || l > r || x == unisiz) return 0; //x == unisiz 是一个特判，因为不可能有数比这个数列中的最大值还大
    per(l - 1, r);
    int vals = 0; //获取区间内数字的数量（因为可能出现删除一个位置上的数导致区间内数字数量与长度不符的情况）
    for (int i = 1; i <= llen; ++i) vals -= tree[treel[i]].val;
    for (int i = 1; i <= rlen; ++i) vals += tree[treer[i]].val;
    //查询这里面比x+1小的数（也就是[1,x]内的数），再用数字数量减去，就得到了大于x的数的数量
    return vals - qsmaot(1, unisiz, x + 1);
}
long long ans; //考虑数组单调递减的情况，总共有1+2+...+n=n(n+1)/2≈1e10个逆序对，要用long long
template <int p> void updans(int pos, int va) {
    add<p>(pos, va); //先执行更改操作（容易发现先更改还是先查询对答案并无影响）
    ans += p * quebig(1, pos - 1, va); //开始查询（p表示这一次是增加还是减少，用p乘就可以实现加减的功能），下面同理
    ans += p * quesma(pos + 1, n, va);
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", high + i), old[i] = high[i];
    std::sort(high + 1, high + 1 + n), unisiz = std::unique(high + 1, high + 1 + n) - high - 1,
        add<1>(n, std::lower_bound(high + 1, high + 1 + unisiz, old[n]) - high);
    for (int i = n - 1; i; --i) { //倒序插入，跟P1908类似
        int tmp = std::lower_bound(high + 1, high + 1 + unisiz, old[i]) - high;
        ans += quesma(1, n, tmp), add<1>(i, tmp);
    }
    printf("%lld", ans);
    int m;
    for (scanf("%d", &m); m--;) {
        int a, b;
        scanf("%d%d", &a, &b);
        if (old[a] == old[b]) {printf("\n%lld", ans); continue;} //两个数相同不会给答案带来任何影响
        if (a > b) std::swap(a, b); //保证小的数在前面
        int als = std::lower_bound(high + 1, high + 1 + unisiz, old[a]) - high,
            bls = std::lower_bound(high + 1, high + 1 + unisiz, old[b]) - high;
        updans<-1>(a, als), updans<1>(b, als), updans<-1>(b, bls), updans<1>(a, bls), std::swap(old[a], old[b]);
        printf("\n%lld", ans);
    }
}
```
于是这个题就解决了，如果有疑问和建议欢迎在下面说出。

---

## 作者：Bobi2014 (赞：0)

这是一道~~可癌~~的 cdq 分治题目。

### 前置知识

- [cdq 分治](https://oi-wiki.org/misc/cdq-divide/)
- [离散化](https://oi-wiki.org/misc/discrete/)

### 思路

首先把身高离散化。

把交换 $x$ 和 $y$，变为删除 $x$ 和 $y$，再添加 $x$ 和 $y$，一个结构体维护以下内容：

- $w$，值为 $1$ 或 $-1$，表示添加或删除。
- $ti$，表示时间。
- $pos$，表示位置。
- $val$，表示值。

接下来就是简单的三维偏序了，时间复杂度 $O(n \log^{2} n)$。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5,M = 2e5 + 5;
struct node{
    int w,ti,pos,val;
} e1[N],e2[N],t[N];
int n,Q,cnt,ti,h[M],tmp[M];
ll ans[M];
namespace Bit{
    int sum[N];
    void add(int x,int v){
        for(;x <= n;x += x & -x){
            sum[x] += v;
        }
    }
    int query(int x){
        int res = 0;
        for(;x > 0;x -= x & -x){
            res += sum[x];
        }
        return res;
    }
}
void cdq(int l,int r){
    if(l == r){
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l,mid);
    cdq(mid + 1,r);
    int p = l,q = mid + 1,cnt = 0;
    while(p <= mid and q <= r){
        if(e1[p].pos < e1[q].pos){
            Bit::add(e1[p].val,e1[p].w);
            t[++cnt] = e1[p ++];
        }else{
            ans[e1[q].ti] += (ll)((Bit::query(n) - Bit::query(e1[q].val)) * e1[q].w);
            t[++cnt] = e1[q ++];
        }
    }
    while(p <= mid){
        Bit::add(e1[p].val,e1[p].w);
        t[++cnt] = e1[p ++];
    }
    while(q <= r){
        ans[e1[q].ti] += (ll)((Bit::query(n) - Bit::query(e1[q].val)) * e1[q].w);
        t[++cnt] = e1[q ++];
    }
    for(int i = l;i <= mid;i ++){
        Bit::add(e1[i].val,-e1[i].w);
    }
    for(int i = l;i <= r;i ++){
        e1[i] = t[i - l + 1];
    }
    p = l,q = mid + 1,cnt = 0;
    while(p <= mid and q <= r){
        if(e2[p].pos > e2[q].pos){
            Bit::add(e2[p].val,e2[p].w);
            t[++cnt] = e2[p ++];
        }else{
            ans[e2[q].ti] += (ll)((Bit::query(e2[q].val - 1)) * e2[q].w);
            t[++cnt] = e2[q ++];
        }
    }
    while(p <= mid){
        Bit::add(e2[p].val,e2[p].w);
        t[++cnt] = e2[p ++];
    }
    while(q <= r){
        ans[e2[q].ti] += (ll)((Bit::query(e2[q].val - 1)) * e2[q].w);
        t[++cnt] = e2[q ++];
    }
    for(int i = l;i <= mid;i ++){
        Bit::add(e2[i].val,-e2[i].w);
    }
    for(int i = l;i <= r;i ++){
        e2[i] = t[i - l + 1];
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> n;
    for(int i = 1;i <= n;i ++){
        cin >> h[i];
        tmp[i] = h[i];
    }
    sort(tmp + 1,tmp + n + 1);
    for(int i = 1;i <= n;i ++){
        h[i] = lower_bound(tmp + 1,tmp + n + 1,h[i]) - tmp;
        e1[++cnt] = {1,0,i,h[i]};
        e2[cnt] = e1[cnt];
    }
    cin >> Q;
    while(Q --){
        int x,y;
        cin >> x >> y;
        e1[++cnt] = {-1,++ti,x,h[x]};
        e2[cnt] = e1[cnt];
        e1[++cnt] = {-1,ti,y,h[y]};
        e2[cnt] = e1[cnt];
        e1[++cnt] = {1,ti,x,h[y]};
        e2[cnt] = e1[cnt];
        e1[++cnt] = {1,ti,y,h[x]};
        e2[cnt] = e1[cnt];
        swap(h[x],h[y]);
    }
    cdq(1,cnt);
    for(int i = 1;i <= ti;i ++){
        ans[i] += ans[i - 1];
    }
    for(int i = 0;i <= ti;i ++){
        cout << ans[i] << '\n';
    }
    return 0;
}
```

---

## 作者：RAND_MAX (赞：0)

分块大法好！

我们更新答案，一开始的逆序对数可以通过树状数组求出，这里不多讲述。

考虑交换 $h_l,h_r$ 对逆序对个数的影响，不难发现对答案的影响是 $[h_l<h_r]-[h_r<h_l]+\sum\limits_{i=l+1}^{r-1}([h_i>h_l]+[h_i<h_r]-[h_i>h_r]-[h_i<h_l])$。式子前两项容易处理，对于求和符号内的式子，我们要快速求出区间内大于或小于某个数的个数，且支持修改。

我们考虑分块。具体地，对于序列与值域各分块。记 $blkcnt_{i,j}$ 表示序列前 $i$ 块里值在值域第 $j$ 块的个数，$cnt_{i,j}$ 表示序列前 $i$ 块里值为 $j$ 的个数，$bid_i$ 表示值 $i$ 所在块的编号，$cntb$ 表示总块数，$st_i,en_i$ 分别表示块 $i$ 的开始、结尾。

注意，由于值域很大，所以要先离散化。

修改是容易的，暴力加减即可。

对于查询，这里以查询大于为例，小于同理。对于散块，我们直接暴力枚举 $h$ 统计即可；对于整块，我们使用前缀和，统计整块内值在块 $i\in (bid_x,cntb]$ 的数量，再统计整块内值为 $i\in(x,en_{bid_x}]$的值。

总时间复杂度为 $O(n\log n+n\sqrt{n})$，可通过本题。


```cpp
#include<bits/stdc++.h>
#define int long long
#define gc getchar
//char buf[1<<20],*p1,*p2;
//#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
#define R read()
using namespace std;
int read()
{
	int x=0,f=1;
	char c=gc();
	while(c>'9'||c<'0'){if(c=='-') f=-1;c=gc();}
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+c-48,c=gc();
	return x*f;
}
void write(int x,char xx)
{
	static int st[35],top=0;
	if(x<0){x=-x;putchar('-');}
	do
	{
		st[top++]=x%10,x/=10;
	}while(x);
	while(top) putchar(st[--top]+48);
	putchar(xx);
}
#define N 200010
#define M 510
int n,a[N],b[N],len,S,cnt[M][N],blkcnt[M][M];
int bid[N],stb[M],enb[M],cntb,ans;
int s[N];
#define lb (x&-x)
void ad(int x){x++;while(x<=n+1) s[x]++,x+=lb;}
int qu(int x){int su=0;x++;while(x) su+=s[x],x-=lb;return su;}
int qmn(int l,int r,int x)
{
	if(l>r) return 0;
	int st=bid[l],en=bid[r],su=0,op=bid[x];
	if(st==en)
	{
		for(int i=l;i<=r;i++) su+=(a[i]<x);
		return su;
	}
	else
	{
		for(int i=l;i<=enb[st];i++) su+=(a[i]<x);
		for(int i=stb[en];i<=r;i++) su+=(a[i]<x);
		for(int i=1;i<op;i++) su+=blkcnt[en-1][i]-blkcnt[st][i];
		for(int i=stb[op];i<x;i++) su+=cnt[en-1][i]-cnt[st][i];
		return su;
	}
}
int qmx(int l,int r,int x)
{
	if(l>r) return 0;
	int st=bid[l],en=bid[r],su=0,op=bid[x];
	if(st==en)
	{
		for(int i=l;i<=r;i++) su+=(a[i]>x);
		return su;
	}
	else
	{
		for(int i=l;i<=enb[st];i++) su+=(a[i]>x);
		for(int i=stb[en];i<=r;i++) su+=(a[i]>x);
		for(int i=cntb;i>op;i--) su+=blkcnt[en-1][i]-blkcnt[st][i];
		for(int i=enb[op];i>x;i--) su+=cnt[en-1][i]-cnt[st][i];
		return su;
	}
}
void add(int x,int y)
{
	int st=bid[x],op=bid[y];
	for(int i=st;i<=cntb;i++) cnt[i][y]++,cnt[i][a[x]]--,blkcnt[i][op]++,blkcnt[i][bid[a[x]]]--;
}
signed main()
{
	n=R,S=sqrt(n);
	for(int i=1;i<=n;i++) a[i]=b[i]=R,bid[i]=(i+S-1)/S,(bid[i]!=bid[i-1]?(stb[bid[i]]=i,enb[bid[i-1]]=i-1):0);
	cntb=bid[n],enb[cntb]=n,sort(b+1,b+n+1),len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+len+1,a[i])-b;
	for(int i=1;i<=cntb;i++)
	{
		for(int j=1;j<=n;j++) cnt[i][j]=cnt[i-1][j];
		for(int j=1;j<=cntb;j++) blkcnt[i][j]=blkcnt[i-1][j];
		for(int j=stb[i];j<=enb[i];j++) cnt[i][a[j]]++,blkcnt[i][bid[a[j]]]++;
	}
	for(int i=1;i<=n;i++) ans+=qu(n)-qu(a[i]),ad(a[i]);
	int q=R,l,r,ql,qr;
	write(ans,'\n');
	while(q--)
	{
		l=R,r=R;
		if(l>r) swap(l,r);
		ans+=qmn(l+1,r-1,a[r])+qmx(l+1,r-1,a[l])-qmx(l+1,r-1,a[r])-qmn(l+1,r-1,a[l])+(a[l]==a[r]?0:(a[l]<a[r]?1:-1));
		write(ans,'\n'),add(l,a[r]),add(r,a[l]),swap(a[l],a[r]);
	}
	return 0;
}
```

---

## 作者：vanueber (赞：0)

# 题目分析

有 $m$ 次操作，每次交换两个数，求出交换后的逆序对数。

先离散化，然后考虑在线地维护这个过程。假设我们交换了 $l,r(l<r)$ 两个位置，那么它对答案的影响就是：
$$
(-1)^{[h_l > h_r]} - \sum_{i=l+1}^{r-1}[h_i< h_l] - \sum_{i=l+1}^{r-1} [h_i > h_r] + \sum_{i=l+1}^{r-1} [h_i < h_r] + \sum_{i=l+1}^{r-1} [h_i>h_l]
$$

发现这是求区间排名问题。

同时交换操作需要我们支持单点修改。

这是一个经典的树套树问题，可以采用树状数组套线段树或者线段树套平衡树，这里采用简洁的分块套树状数组。

时间复杂度 $\Theta(n \sqrt n \log n)$。

# Code


```cpp
#include <bits/stdc++.h>
#define umap unordered_map
#define vint vector<int>
#define ll long long
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define ull unsigned long long
#define uint unsigned int
#define rg register
#define il inline
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define sqr(x) ((x)*(x))
using namespace std;
const int INF=0x3f3f3f3f;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<1)+(w<<3)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int N=2e5+10,T=ceil(sqrt(N));
int n,h[N],tmp[N],cnt,m;
int len,tot,st[T],ed[T],bel[N];
struct bit{
    int tr[N];
    int lowbit(int x){
        return x&-x;
    }
    void add(int x,int k){
        for(;x<=cnt+1;x+=lowbit(x)) tr[x]+=k;
    }
    int query(int x){
        int res=0;
        for(;x>0;x-=lowbit(x)) res+=tr[x];
        return res;
    }
    int query(int l,int r){
        return query(r)-query(l-1);
    }
    void change(int x,int k){
        add(x,-query(x,x));
        add(x,k);
    }
}t[T];
ll ans;
int query(int l,int r,int x,int y){
    int res=0;
    if(bel[l]==bel[r]){
        for(int i=l;i<=r;++i) res+=(h[i]>=x&&h[i]<=y);
    }
    else{
        for(int i=l;i<=ed[bel[l]];++i) res+=(h[i]>=x&&h[i]<=y);
        for(int i=st[bel[r]];i<=r;++i) res+=(h[i]>=x&&h[i]<=y);
        for(int i=bel[l]+1;i<bel[r];++i) res+=t[i].query(x,y);
    }
    return res;
}
int main(){
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    #endif
    n=read();
    rep(i,1,n) tmp[++cnt]=h[i]=read();
    sort(tmp+1,tmp+cnt+1);
    cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
    rep(i,1,n) h[i]=lower_bound(tmp+1,tmp+cnt+1,h[i])-tmp;
    rep(i,1,n){
        ans+=t[0].query(h[i]+1,cnt);
        t[0].add(h[i],1);
    }
    cout<<ans<<endl;
    len=sqrt(n),tot=(n+len-1)/len;
    rep(i,1,n) bel[i]=(i-1)/len+1;
    rep(i,1,tot){
        st[i]=(i-1)*len+1,ed[i]=min(n,i*len);
        for(int j=st[i];j<=ed[i];++j) t[i].add(h[j],1);
    }
    cin>>m;
    for(int i=1,l,r;i<=m;++i){
        // print();
        l=read(),r=read();
        if(r<l) swap(l,r);
        if(r!=l+1){
            ans-=query(l+1,r-1,1,h[l]-1);
            ans-=query(l+1,r-1,h[r]+1,cnt);
        }
        if(h[l]<h[r]) ++ans;
        else if(h[l]>h[r]) --ans;
        t[bel[l]].add(h[l],-1),t[bel[l]].add(h[r],1);
        t[bel[r]].add(h[r],-1),t[bel[r]].add(h[l],1);
        swap(h[l],h[r]);
        if(r!=l+1){
            ans+=query(l+1,r-1,1,h[l]-1);
            ans+=query(l+1,r-1,h[r]+1,cnt);
        }
        // print();
        cout<<ans<<endl;
    }
    #ifndef ONLINE_JUDGE
    fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
    #endif
    return 0;
}
```

# 本题坑点

1. 题目**不保证**询问的 $l < r$。
2. 注意到交换的影响的式子中，必须要将 $l,r$ 两个单点的贡献分开算，直接算可能会算重。

---


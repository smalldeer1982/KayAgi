# 平面最近点对（加强版）

## 题目背景

[P7883](/problem/P7883) 平面最近点对（加强加强版）

## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的


## 说明/提示

数据保证 $0\le x,y\le 10^9$

## 样例 #1

### 输入

```
3
1 1
1 2
2 2```

### 输出

```
1.0000```

# 题解

## 作者：3A17K (赞：1850)

我们充分发扬人类智慧：

将所有点全部绕原点旋转同一个角度，然后按$x$坐标排序

根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远

所以我们只取每个点向后的5个点来计算答案

这样速度快得飞起，在$n=1000000$时都可以在1s内卡过


---

## 作者：syksykCCC (赞：423)

**UPD：谢谢大家对之前题解的支持，这里我重新更换一下以前难看的图片，同时补补锅，回答一下疑点。**

**UPD2：根据新的题解规范修改了文章。另外大家喜欢的话不妨点点赞支持支持。**

**UPD3：应评论要求补充了时间复杂度分析。另外发现题解的图片中 $\rm P_9$ 和 $\rm P_{10}$ 全部标反了，但因为不影响算法理解，且原图源丢失，暂时请大家阅读时自行对换过来。**

----

首先感谢：

* @[plane](https://www.luogu.org/space/show?uid=277) 和他的[题解](https://www.luogu.org/blog/user277/solution-p1429)；
* @[frankchenfu](https://www.luogu.org/space/show?uid=23398) 和他的[题解](https://www.luogu.org/blog/frankchenfu/solution-p1429)。

下面我贴上 @[frankchenfu](https://www.luogu.org/space/show?uid=23398) 的代码，我将给出图示模拟，希望能帮助看不懂的同学理解

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 1000001;
const int INF = 2 << 20;
int n, temp[maxn];
struct Point 
{
    double x, y;
} S[maxn];
bool cmp(const Point &a, const Point &b) 
{
    if(a.x == b.x) return a.y < b.y;
    else return a.x < b.x;
}
bool cmps(const int &a, const int &b) { return S[a].y < S[b].y; }
double min(double a, double b) { return a < b ? a : b; }
double dist(int i, int j) 
{
    double x = (S[i].x - S[j].x) * (S[i].x - S[j].x);
    double y = (S[i].y - S[j].y) * (S[i].y - S[j].y);
    return sqrt(x + y);
}
double merge(int left, int right) 
{
    double d = INF;
    if(left == right) return d;
    if(left + 1 == right) return dist(left, right);
    int mid = left + right >> 1;
    double d1 = merge(left, mid);
    double d2 = merge(mid + 1, right);
    d = min(d1, d2);
    int i, j, k = 0;
    for(i = left; i <= right; i++)
        if(fabs(S[mid].x - S[i].x) < d) // 这里不太一样
            temp[k++] = i;
    sort(temp, temp + k, cmps);
    for(i = 0; i < k; i++)
        for(j = i + 1; j < k && S[temp[j]].y - S[temp[i]].y < d; j++) 
		{
            double d3 = dist(temp[i], temp[j]);
            if(d > d3) d = d3;
        }
    return d;
}
int main() 
{
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%lf%lf", &S[i].x, &S[i].y);
    sort(S, S + n, cmp);
    return !printf("%.4lf\n", merge(0, n - 1));
}
```

一个个来解释。

比如说我们拿到了这样一组样例：

> $\textbf{InputData:}$  
> ```plain
> 10   
> 1 1   
> 1 5   
> 3 1   
> 5 1  
> 5 6  
> 6 7  
> 7 3  
> 8 1  
> 10 3  
> 9 9  
> ```

这组样例是排好序的，我们可以得到这样的图：

[](https://cdn.luogu.com.cn/upload/pic/61217.png)
![image.png](https://i.loli.net/2019/12/20/3jrHFVlvaZUPsDI.png)

下面我们要开始 $\mathrm{merge()}$了。（注意我的图从 $1$ 开始编号，略有不同）

$\mathrm{merge}(\textit{left},\textit{right})$ 是返回由编号 $\textit{left}\sim \textit{right}$ 的点构成的最近点对的距离，所以 $\mathrm{merge}(1, n)$ 即为答案，因为这是一个递归函数，我们假设它已经能返回一个区域中的最近点对了。

```cpp
// 预处理
    double d = INF;
    if(left == right) return d;
    if(left + 1 == right) return dist(left, right);
```
然后算出 $mid$ 并进行递归。

[](https://cdn.luogu.com.cn/upload/pic/61219.png )
![image.png](https://i.loli.net/2019/12/20/REruPGLKoTlj7nc.png)

也就是求出 $[\text P_1\sim \text P_5]$ 和 $[\text P_6\sim \text P_{10}]$ 中的最近点对。

显然 $d_1=2$（$\text P_1$ 与 $\text P_3$ 之间），$d_2=\sqrt{5}$（$\text P_7$ 和 $\text P_8$ 之间）。

那么 $d = \min(d_1,d_2)=2$。

```cpp
// 递归
    int mid = left + right >> 1;
    double d1 = merge(left, mid);
    double d2 = merge(mid + 1, right);
    d = min(d1, d2);
```

[](https://cdn.luogu.com.cn/upload/pic/61221.png)
![image.png](https://i.loli.net/2019/12/20/zlwsxXZT7RIuvQP.png)

**前方高能**

接下来就是这个算法的核心，如何求出跨越蓝线的最近点对了。

首先锁定点集 $\text{Temp}$。
```cpp
// 求出temp[]并排序
    for(i = left; i <= right; i++)
        if(fabs(S[mid].x - S[i].x) < d)
            temp[k++] = i;
    sort(temp, temp + k, cmps);
```

[](https://cdn.luogu.com.cn/upload/pic/61218.png)
![image.png](https://i.loli.net/2019/12/20/XPskY3NgrcMBEW6.png)

由程序可知 $\text{Temp}$ 包含了离直线距离不超过 $d$ 的所有点。

为啥其它点不用考虑呢？

**因为其它点离该线的距离都大于等于 ${d}$ 了，就更不用说到另一侧的点的距离了，必定不如直接返回 ${d}$ 来的优**。

而按照纵坐标排序是为了后面的方便。
```cpp
// 求出最近点对（TLE）
    for(i = 0; i < k; i++)
        for(j = i + 1; j < k; j++) 
		{
            double d3 = dist(temp[i], temp[j]);
            if(d > d3) d = d3;
        }
```
相信这段代码大家都能看懂，但是很可惜，开 `-O2` 才能过，这是为什么呢？

不难发现源代码是这样的：

```cpp
// 求出最近点对
    for(i = 0; i < k; i++)
        for(j = i + 1; j < k && S[temp[j]].y - S[temp[i]].y < d; j++) 
		{
            double d3 = dist(temp[i], temp[j]);
            if(d > d3) d = d3;
        }
```

好像多了一个 `S[temp[j]].y - S[temp[i]].y < d`，它有什么用呢？

和上面同理，**如果两者的纵坐标之差都大于等于 ${d}$ 了，那再计算就没有丝毫意义了，因为如果加上水平距离的话，必定不如直接返回 ${d}$ 来的优**。

例如 $\text P_3$ 号点，它只需和 $\text P_4$ 匹配就行了，因为它们的纵坐标之差为 $0$，有可能会带来更好的答案，而它和 $\text P_7$ 匹配就没有任何意义，因为即便它们的纵坐标之差等于 $d$，但就算 $\text P_7$ 在 $\text P_3$ 的正上方，距离也**不会小于** $d$。

值得注意的是，这里比如 $\text P_3$ 和 $\text P_4$ 会被重新计算，但对时间复杂度没有影响。

[](https://cdn.luogu.com.cn/upload/pic/61220.png)
![image.png](https://i.loli.net/2019/12/20/V4XayQD2Snmp8uP.png)

至此，我们求出了结果 $ans = \sqrt{2}$（$\text{P}_5$ 和 $\text P_6$ 之间）。

所以：

> $\textbf{OutputData:}$ 
> ```plain
> 1.4142
> ```

---

这个算法的时间复杂度又是怎么样的呢？（不想看分析的可以跳过）

![image.png](https://i.loli.net/2021/07/21/B8iSIFZ5zE4wCjn.png)

考虑对于左边的一个点 $\text{P}_i$，**可能和它成为新的最近公共点对**的点 $\text{P}_j$ 有多少个。

```cpp
// 求出最近点对
    for(i = 0; i < k; i++)
        for(j = i + 1; j < k && S[temp[j]].y - S[temp[i]].y < d; j++) 
		{
            double d3 = dist(temp[i], temp[j]);
            if(d > d3) d = d3;
        }
```

不难发现 $\text{P}_j$ 满足这些条件：

1. $\text{P}_j$ 与 $mid$ 线的距离小于 $d$。
2. $\text{P}_j$ 的纵坐标比 $P_i$ 大（因为如果 $\text{P}_j$ 的纵坐标比 $\text{P}_i$ 小，则这个状态会在之前考虑有哪些点可能与 $\text{P}_j$ 形成最近公共点对的时候考虑到，没必要重复考虑，虽然真的考虑的话也就只是 $2$ 倍常数）。
3. $\text{P}_j$ 和 $\text{P}_i$ 的纵坐标之差小于 $d$。

根据这三条，我们可以画出一个 $d \times 2d$ 的矩形，合法的 $\text{P}_j$ 一定是在这个矩形中的（不含边界）。

但是，我们又知道，如果两个点同在左侧，则距离 $\ge d$；如果两个点同在右侧，则距离 $\ge d$。

那么，无论是 $mid$ 左边的正方形还是右边的正方形，**每个里面都至多放 $3$ 个点（包括 $\text{P}_i$）**。

图中红色点即代表 $\text{P}_j$，展示了一种方案，其中每条虚线边的长度都 $\ge d$。

所以对于每个 $\text{P}_i$，检验至多其他 $5$ 个点即可，所以求最近点对的部分时间复杂度是 $O(n)$ 的！

（当然其实与 $\text{P}_i$ 同侧的 $\text{P}_j$ 是不可能对更新答案有用的，如果你愿意的话，检验至多 $3$ 个点即可）

于是整个代码的瓶颈就在 `sort` 上了，时间复杂度为 $T(n) = 2\cdot T(\frac n 2) + O(n \log n) = O(n \log^2 n)$，当然如果使用**归并排序替换 `sort`** 的话，就可以做到严格的 $O(n \log n)$！

---

最后，如果大家发现了问题，也欢迎大家指正哦！

---

## 作者：plane (赞：211)

#方法一：

先求第1个点与其余n-1个点的距离；

再求第2个点与其余n-2个点的距离；

再求第3个点与其余n-3个点的距离；

…………………………………………

再求第n-1个点与其余1个点的距离；

然后找出最小值。

如此的算法复杂度为O(n^2)，显然不能满足本题的需要。很遗憾……洛谷神机这回不可以咯……


##方法二：

考虑以下分治算法：

设平面上的点都在点集S中，为了将S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l（方程：x=m）来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px>m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。
递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min (δ1,δ2)。


若S的最接近点对(p,q)之间的距离d(p,q)<δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈S1，q∈S2


此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n^2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)<δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，


由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。


因此d(u,v)≤5δ/6<δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n^2/4对候选者。



我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。


**至此，我们用分治法求出平面最接近点对。**


```delphi


type rec=record
     x,y:int64;
     end;
var a:array [0..200001] of rec;
    tt,ttt,tttt:array [0..200001] of rec;
    n,l,m,min:int64;
    i,j,k:longint;
procedure sort(l,r:longint);
var i,j:longint;
    x,y:rec;
begin
  i:=l;
  j:=r;
  x:=a[(l+r) div 2];
  repeat
    while (a[i].x<x.x) or ((a[i].x=x.x) and (a[i].y>x.y)) do inc(i);
    while (x.x<a[j].x) or ((x.x=a[j].x) and (x.y>a[j].y)) do dec(j);
    if not(i>j)
    then
      begin
        y:=a[i];
        a[i]:=a[j];
        a[j]:=y;
        inc(i);
        j:=j-1;
      end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;
procedure sortt(l,r:longint);
var i,j:longint;
    x,y:rec;
begin
  i:=l;
  j:=r;
  x:=tttt[(l+r) div 2];
  repeat
    while (tttt[i].y<x.y) do inc(i);
    while (x.y<tttt[j].y) do dec(j);
    if not(i>j)
    then
      begin
        y:=tttt[i];
        tttt[i]:=tttt[j];
        tttt[j]:=y;
        inc(i);
        j:=j-1;
      end;
  until i>j;
  if l<j then sortt(l,j);
  if i<r then sortt(i,r);
end;
function dis(a,b:rec):int64;
begin
  exit(sqr(a.x-b.x)+sqr(a.y-b.y));
end;
function minn(a,b:int64):int64;
begin if a<b then exit(a) else exit(b); end;
function work(le,ri:longint):int64;
var tl,tr,t1,t2,min:int64;
    i,j,k,lenr,lenl,p1,p2:longint;
begin
  if ri-le=1 then exit(dis(a[ri],a[le]));
  if ri-le=2 then exit(minn(minn(dis(a[ri],a[le]),dis(a[ri-1],a[le])),dis(a[le+1],a[ri])));
  tl:=work(le,(le+ri) div 2);
  tr:=work(((le+ri) div 2)+1,ri);
  min:=minn(tl,tr);
  t1:=(le+ri) div 2;
  t2:=t1+1;
  while (t1>=le) and (sqr(a[t1].x-a[(le+ri) div 2].x)<=min) do dec(t1);
  inc(t1);
  while (t2<=ri) and (sqr(a[t2].x-a[(le+ri) div 2].x)<=min) do inc(t2);
  dec(t2);
  if (t2=(le+ri) div 2) or (t1=((le+ri) div 2)+1) then exit(min);
  for k:=t1 to t2 do tttt[k]:=a[k];
  sortt(t1,t2);
  for k:=t1 to t2-1 do
    begin
      for j:=k+1 to minn(k+8,t2) do
        begin
          min:=minn(min,dis(tttt[k],tttt[j]));
        end;
    end;
  exit(min);
end;
begin
  readln(n);
  for i:=1 to n do readln(a[i].x,a[i].y);
  sort(1,n);
  writeln(sqrt(work(1,n)):0:4);
end.


```

---

## 作者：yuy_ (赞：125)

### 该算法的基本步骤是：
### 1. 随机旋转
### 2. 按横坐标排序后枚举每个点与其后面5个点的距离取最小值更新答案。
### 旋转公式（旋转中心为（x2,y2））：
### x=(x1-x2)*cos(θ)-(y1-y2)*sin(θ)+x2;
### y=(x1-x2)*sin(θ)+(y1-y2)*cos(θ)+y2;
### 注意θ为弧度(在C++中三角函数以弧度进行运算)

#### 如果不旋转会怎么出错呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/98jr6pco.png)
#### 如图A点会与B、C、D、E、F（按顺序）更新答案，但是G应该是离A最近的点。
#### 旋转可以很好地解决这个问题。如下图：A点会与G、F、D、B、C（按顺序）更新答案
![](https://cdn.luogu.com.cn/upload/image_hosting/vvgc1ox4.png)
```cpp

#include<bits/stdc++.h>
#define pi acos(-1.0)
using namespace std;
struct node{
    double x,y;
}a[200005];
int n;
double ans=1e15;//初始化答案

bool cmp(node a,node b){
    return a.x<b.x;//按照横坐标排序 
}
double dis(node a,node b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));//计算两点之间距离 
}
void calc(){
    for (int i=1;i<=n;i++)
        for (int j=i+1;j<=i+5&&j<=n;j++)
            ans=min(ans,dis(a[i],a[j]));
}
void around(double ds){
    ds=ds/180.0*pi;//角度转换为弧度 
    for (int i=1;i<=n;i++){
        double x=a[i].x,y=a[i].y;//旋转前的点 
        double xn,yn;//旋转后的点 
        double xyu=0.0,yyu=0.0;  //旋转中心 
        xn=(x-xyu)*cos(ds)-(y-yyu)*sin(ds)+xyu;
        yn=(x-xyu)*sin(ds)+(y-yyu)*cos(ds)+yyu;
        a[i].x=xn,a[i].y=yn;
    }
    sort(a+1,a+1+n,cmp);//排序 
    calc();//计算 
}

int main(){
    srand(time(NULL));
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    around(0);//将原图像进行排序并枚举每个点与其后五个点比较 
    around(rand()%360);//将图像随机（0°~359°）旋转  并排序 计算 
    around(rand()%360);//将图像随机（0°~359°）旋转  并排序 计算 
    printf("%.4lf\n",ans);
    return 0;
}

```
### upd 11/4：有评论指出C++的三角函数应该为弧度制，谢谢，现已改正。
### 如果对你有帮助不妨点个赞。

---

## 作者：qwaszx (赞：87)

有趣的分治呢

暴力的做法就是枚举两个点算距离更新答案

即使这样你也可以优化一下你的暴力

众所周知$sqrt$是一个跑得极慢的函数

所以我们可以两边平方消掉$sqrt$，最后再算一次即可

然后看分治做法.当然上面的技巧基本上可以用于带$sqrt$的所有题目.

先考虑降维~~打击~~，如果只有一维怎么做.

把所有点按照坐标排序，然后在中位数的位置画一条线，把点分成两个子集$P_1$和$P_2$.

我们只需要算出所有$p\in P_1,q\in P_2$的$min{dis(p,q)}$，然后递归地处理$P_1,P_2$即可.

如果直接暴力枚举两边的点，那么复杂度$f(n)=2f(n/2)+O(n^2)=O(n^2\log n)$，变差了，所以不可以这么做.

现在假设两个子集的答案已经求出，那么我们设$d=min(solve(P_1),solve(P_2))$,中位数的坐标是$m$，那么我们只需要处理所有坐标在$[m-d,m+d]$范围内的点即可。容易看出这样的点每边最多只有$2$个，否则他们它们之间的距离一定$<d$，矛盾，所以可以$O(1)$地处理，所以复杂度$f(n)=2f(n/2)+O(1)=O(n)$，考虑排序之后复杂度$O(n\log n)$

现在把坐标变成二维，上面的做法应该对我们有一些启发性.

先按照$x$坐标排序，然后找一个中位$x$坐标$m$，在这里画一条平行于$y$轴的分割线，把点分成$P_1$和$P_2$两个子集.设两个子集的答案的较小值是$d$，那么我们处理的点一定是$x$坐标在$[m-d,m+d]$范围内，也就是两个竖直长条.但这次我们没这么幸运，因为这两个长条内的点还是$O(n)$的.我们来暴力地尝试一下:

把这个区域内的点按$y$坐标排序，然后枚举每一个点，从它往后枚举第二个点，如果这两个点的$y$坐标之差$>=d$那么就停止枚举第二个点.

然后你发现你$A$掉了这道题.

为什么呢?因为满足上述条件的第二个点在两边各最多有$6$个。所以复杂度是可以保证的.为什么是$6$个呢?这里给出证明.

显然对于每一个点，到它的距离$<d$的点在每一边一定会落在一个$d\times2d$的矩形之内(其实是个半径为$d$的圆，但是圆难以处理，所以用矩形近似).这个矩形内的点需要满足两两之间的距离$>=d$.这样的点如果$>6$个，那么我们用鸽巢原理:把$d\times 2d$的矩形切成6个$\dfrac{1}{2}d\times\dfrac{2}{3}d$的小矩形，那么一定有两个或以上的点落在同一个小矩形内，但是这个小矩形中两点的最大距离等于对角线长，也就是$\dfrac{5}{6}d<d$，矛盾.因此最多只有六个点。

于是我们枚举每一个点，找这些点就可以了

到这里算法已经明确，但实现上出现了一些问题:

1. 如果你合并答案用$stl$的$sort$，那么复杂度$f(n)=2f(n/2)+O(nlogn)=O(n\log^2n)$就不对了.我们需要归并排序.这样我们就不可能只对两个长条内的点排序，而是需要对所有正在处理的区间内的点排序了.归并的复杂度也是基于递归的，并且处理子问题的时候两个序列已经有序，所以归并排序可以把总时间复杂度减小到$O(n\log n)$.但是这道题数据水，所以$sort$可以取得更加优秀的效率.说一下怎么卡:所有的点全都在一条直线上，就可以把$sort$卡到极限.

2. $sort$有一个好处:它可以只把两个长条内的点提出来排序，对于随机数据效率优秀.

$sort$的代码可以去看其他题解，这里放出归并的代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct Point{int x,y;}a[2000000],tmp[2000000];
int n,b[2000000];
const long long inf=5e18;
long long sqr(int x){return (long long)x*x;}
long long dis(int l,int r){return sqr(a[l].x-a[r].x)+sqr(a[l].y-a[r].y);}
int cmp(const Point &a,const Point &b){return a.x==b.x?a.y<b.y:a.x<b.x;}
void merge(int l,int r)
{
	int mid=(l+r)>>1,i=l,j=mid+1;//归并
	for(int k=l;k<=r;k++)
	{
		if(i<=mid&&(j>r||a[i].y<a[j].y))tmp[k]=a[i++];
		else tmp[k]=a[j++];
	}
	for(int i=l;i<=r;i++)a[i]=tmp[i];
}
long long solve(int l,int r)
{
	if(l>=r)return inf;
	if(l+1==r){if(a[l].y>a[r].y)swap(a[l],a[r]);return dis(l,r);}
	int mid=(l+r)>>1,t=a[mid].x,cnt=0;//重新排序后中位数就乱了，需要记下来
	long long d=min(solve(l,mid),solve(mid+1,r));
	merge(l,r);
	for(int i=l;i<=r;i++)
		if(sqr(a[i].x-t)<d)//两边平方的技巧
			b[++cnt]=i;//区间内的拉出来处理
	for(int i=1;i<=cnt;i++)
		for(int j=i+1;j<=cnt&&sqr(a[b[j]].y-a[b[i]].y)<d;j++)
			d=min(d,dis(b[j],b[i]));
	return d;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);
	printf("%.4lf",sqrt(solve(1,n)));
} 
```

---

## 作者：kcs007 (赞：65)

一道超级经典的~~计算几何~~问题，学了好久终于学明白了，这里仔细跟大家聊一下：

首先看到这个题，第一反应肯定是暴力，两重循环，求出所有的点的距离，然后再找最小值，对吧？？？

废话少说，上代码
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
struct node{
	double x;
	double y;
};
struct node point[200005];
double dis(node a,node b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>point[i].x>>point[i].y;
	}
	double minn=1<<31-1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==j)continue;
			if(minn>=dis(point[i],point[j]))minn=dis(point[i],point[j]);
		}
	}
	printf("%.4lf\n",minn);
	return 0;
}
```
懒得加注释了，能做到这的我相信大家都能看懂，然后很高兴的提交了，于是乎：
![](https://cdn.luogu.com.cn/upload/pic/67229.png)
啥玩意？超时，于是看了一下题目
![](https://cdn.luogu.com.cn/upload/pic/67230.png)
然后我用了一个小时算了一下 200000*200000好像超了，
这咋做？？？？？~~不会了，算了不做了~~


于是乎，本着执着探索的精神，终于研究明白了，这道题是一道很经典的计算几何问题，叫最近点对，什么思路呢？


分治算法：


啥是分治算法？

  
**1) 把它分成两个或多个更小的问题；    
2) 分别解决每个小问题；  
3) 把各小问题的解答组合起来，即可得到原问题的解答。小问题通常与原问题相似，可以递归地使用分而治之策略来解决。**

说啥呢？

反正就是把大问题换成若干个**相同**小问题，然后将小问题解决，从而解决大问题

啥意思？
这道题，比如说咱们要求平面中两点的最小距离，那咱们可不可以把平面分成左边和右边两半？好，那这道题变成了找左边点的最小距离和找右边点的最小距离是不是？还是不会？，那继续分呗
最终分到了每个平面只有两个点，这你总该会了吧，把每个小平面的距离算出来，然后找最小值？？？no  没这么简单，
举个栗子：

![](https://cdn.luogu.com.cn/upload/pic/67233.png)

如图所示，左边最小的距离是d1，右边最小的距离是d2，
那么如果d1<d2，那最小距离就是d1嘛？显然不是，因为两个平面的交叉部分还可能有更小的距离，那怎么办？继续比较更小两个平面中间的点呗。


~~好，题做完了~~
还有点懵是不是？
那咱们呢重新捋一下，
第一步：把题目分成两个左右两个面。
第二步：分别求出左右两个平面的最近点对
第三部：看两个平面中间的点有没有比刚才那个最近距离还近的。
~~题做完了~~
好，那现在只有第二步咱们不会是吧？
？？？？？发现了没，第二步和题目一样吧？

是不是发现点规律了？


这就是了，分治的思想

上代码：
```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
#define Inf 1<<31-1
struct node{
	double x;
	double y;
};
struct node point[200005];
int mpt[300005];
double dis(node a,node b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));//不解释，不会自己去面壁 
}
bool cmp1(node a,node b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}//第一个排序是按照x坐标排序，排序以后才好分左右平面 
bool cmp2(int a,int b)
{
	return point[a].y<point[b].y;
}//第二个排序是选择中间的点，不懂得往下看 
double run(int left,int right)
{
	int d=Inf; 
	if(left==right)return d;//如果自己和自己的距离最近，那这题就变成入门了，直接cout<<0.0000<<endl就过了。。。所以咱们把自己和自己的距离设置为正无穷 
	if(left+1==right)return dis(point[left],point[right]);//这两个点中间没有任何点，所以直接求距离就是了 
	int mid=(left+right)>>1;//如果中间还有其他点，那就再中间分开。 
	double d1=run(mid,right);//找左边的最小距离 
	double d2=run(left,mid-1);//找右边的最小距离 
	double minn=min(d1,d2);//求出两个最小距离谁更小 
	int k=0;
	for(int i=left;i<=right;i++)
	{
		if(fabs(point[mid].x-point[i].x)<=minn)
		{
			mpt[++k]=i;
		}
	}//还记得刚才讲过，有可能在两个平面中间还有其他的更小距离嘛？这个就是按照x坐标找可能出现的点 
	sort(mpt+1,mpt+k+1,cmp2);//按这些点的y坐标排序 
	for(int i=1;i<=k;i++)
	{
		for(int j=i+1;j<=k && point[mpt[j]].y-point[mpt[i]].y<=minn;j++)
		{
			if(minn>=dis(point[mpt[i]],point[mpt[j]]))
				minn=dis(point[mpt[i]],point[mpt[j]]);
		}
	}//线性扫描，找这些点的最小距离 
	return minn;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>point[i].x>>point[i].y;
	}
	sort(point+1,point+n+1,cmp1);
	printf("%.4lf",run(1,n));
	return 0;
}
```


---

## 作者：nalemy (赞：57)

补一发**非分治** $O(n\log n)$ 解法

我们以 $x$ 为第一关键字，$y$ 为第二关键字给点排序，依次枚举。当前的局部最优解记为 $d$。

假设下图中大长方形为所有点所在的区域。

1. 考虑对粉色长方形**内**的绿色点维护一个可重集（`multiset`），枚举到 $i$ 时先把在长方形外的点删去；最后将 $i$ 加入 `multiset`。
2. 因为两个阴影正方形以外的点一定不能与 $i$ 构成最优解，所以只用枚举阴影内的点。于是我们令 `multiset` 以 $y$ 为关键字从小到大排，那么阴影内所有点一定连续，我们可以 `lower_bound` 找出其起始点。

![](https://cdn.luogu.com.cn/upload/image_hosting/x0z8rt3y.png)

图(1) 和 图(2) 分别对应上述两点

这个方法好理解，也好写。代码：

```C++
#include<algorithm>
#include<iostream>
#include<cmath>
#include<set>
using namespace std;

const int N = 2e5;
struct point {double x, y;point(double x=0, double y=0): x(x), y(y){}} a[N];
bool operator < (point a, point b) {return a.y < b.y;}
int main() {
    int n; double d = 2e9; multiset<point> s; cin >> n;
    for (int i=0; i<n; i++) cin >> a[i].x >> a[i].y;
    sort(a, a+n, [](point a, point b){return a.x==b.x?a.y<b.y:a.x<b.x;});
    for (int i=0, j=0; i<n; s.insert(a[i++])) {
        while (j<i && a[j].x<=a[i].x-d) s.erase(a[j++]);
        for (auto it=s.lower_bound(point(a[i].x, a[i].y-d)); it!=s.end()&&it->y<a[i].y+d; it++)
            d = min(d, hypot(a[i].x-it->x, a[i].y-it->y));
    }
    return printf("%.4lf", d), 0;
}
```

Some Useful Tips:

1. `multiset` 中包含粉色长方形**内**的点、长方形上下边上的点、长方形右侧边上位于 $i$ 上方的点；
2. 16 行 `for` 循环中的 `lower_bound` 可以改为 `upper_bound`，`multiset` 改为 `set`，就是要判两点重合，解为 $0$ 的情况；
3. 15 行 `while` 循环中第二个 `<=` 改成 `<` 在加强版加强版中会错（而且是算大了），原因不明，希望高人指点迷津（可能是精度的问题？）
4. 关于复杂度的证明：由于每个元素只会进 `multiset` 一次，而阴影内的点只有常数个（这里同分治算法），因此总复杂度为 $O(n\log n)$。


---

## 作者：shame_djj (赞：35)

我的是一种玄学算法：

**直接找**

按照横纵坐标，排个序

对于每一个点，往后找k个点（这个k自己定）

本题n是二十万，常数小点的话能把k升到100

（本题数据水爆了，我在k=5时就A了这道题）

每回，更新ans

其实就是稍微优化一下O(n2)做法

代码好简单的

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

struct point {double x, y;} a[200010];
double dist (point a, point b) {return sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));}
bool cmp (point a, point b) {return a.x < b.x || (a.x == b.x && a.y < b.y);}
double ans = (1 << 30) + 0.01;
int n;

int main() {
    scanf ("%d", &n);
    for (register int i = 1; i <= n; i ++)
        scanf ("%lf%lf", &a[i].x, &a[i].y);
    sort (a + 1, a + n + 1, cmp);
    for (register int i = 1; i < n; i ++) {
        for (register int j = 1; j <= 5; j ++)//所谓的k
            ans = min (ans, dist(a[i], a[i + j]));
    }
    printf ("%.4lf\n", ans);
    return 0;
}

```

我的做法，肯定是错的（滑稽）

但是，在考试时，我们拿十分钟给第二题拿了80以上的分数

我个人认为，是很值得的（反正本蒟蒻考试时稍难点的题总是花好长时间，还经常炸锅）

（何况这题本来100也就是很极限的数据了，也就差不多了）

离Noip还有一百来天，大家加油(/@"A"@)/ 

---

## 作者：hylhyl (赞：19)

# 给大家介绍一个玄学方法
  写法极其简单，时间复杂度难以计算，十分玄学。
  
  ## 第一步
将个点以横坐标以第一关键字，纵坐标为第二关键字排序。
## 第二步
枚举每个点和他之后的点，不断更新当前最小距离ans，如果当前两点横坐标之差已经大于ans，退出当前循环。显然后面的点后当前点的距离绝对大于ans。
```cpp
#include<stdio.h>
#include<algorithm>
#include<cmath>
using namespace std;
int n,len;
struct point{
	double x;
	double y;
} pointset[100005];
double ans=0,anans=9999999999;
double dis(point a,point b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
bool cmp2(point a,point b)
{
	return  a.x!=b.x?a.x<b.x:a.y<b.y;
}
void work()
{
	
	sort(pointset,pointset+n,cmp2);
	for(int i=0;i<n-1;i++)
		for(int j=i+1;j<n;j++)
		{
			anans=min(dis(pointset[i],pointset[j]),anans);
			if(pointset[j].x-pointset[i].x>anans)
			break;
		}
}
int main()
{
	int i,j,k;
	scanf("%d",&n);
	for(i=0;i<n;i++)
	scanf("%lf %lf",&pointset[i].x,&pointset[i].y);
	work();
	printf("%.4lf",anans);
	return 0;
}
```
代码长度极小且非常好写，速度会比分治慢但绝对可以稳过。


---

## 作者：蹲在丛中笑 (赞：16)

蒟蒻不会写分治,只好用K-Dtree骗分...

既然用K-Dtree, 就不需要什么思考了

直接一个一个点在树里找和它距离最小的点, 找完了插进去就行了

K-Dtree找一次的复杂度据说是$O(\sqrt n)$的, 所以就可以过

------------

还有一种用K-Dtree的写法是不插点, 而是先建好树, 直接把点丢进去找

但是对于这种写法, 找的时候如果找到相同的点要忽略

还是觉得前一种写法比较优

下面是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,nw,rt,D; double ans=4e18;
struct Node {
  double p[2],mn[2],mx[2]; int l,r;	//p:点	mn,mx:子树区域坐标极值	l,r:	孩子
  void up(Node &A) {
    for (int i=0;i<2;++i)
      mn[i]=min(mn[i],A.p[i]),mx[i]=max(mx[i],A.p[i]);
  }
} t[50005];
double get(int u) {	//当前点nw到u的子树区域的最小可能距离
  if (!u) return 4e18; double s=0;
  for (int i=0;i<2;++i) {
    double x=max(t[nw].p[i]-t[u].mx[i],0.0)
        +max(t[u].mn[i]-t[nw].p[i],0.0);
    s+=x*x;
  }
  return s;
}
double dis(int u) {	//当前点nw到点u的距离
  double s=0;
  for (int i=0;i<2;++i) {
    double x=t[nw].p[i]-t[u].p[i];
    s+=x*x;
  }
  return s;
}
void Query(int u) {	//K-Dtree的询问
  if (!u) return; ans=min(ans,dis(u));
  double lv=get(t[u].l),rv=get(t[u].r);
  if (lv>rv) {
    if (rv<ans) Query(t[u].r); if (lv<ans) Query(t[u].l);
  }
  else {
    if (lv<ans) Query(t[u].l); if (rv<ans) Query(t[u].r);
  }
}
void Ins(int &u,int d) {	//二叉查找树式的插点
  if (!u) return void(u=nw);
  Ins(t[nw].p[d]<=t[u].p[d] ? t[u].l : t[u].r,d^1);
  t[u].up(t[nw]);
}
int main() {
  scanf("%d",&n);
  for (int i=1;i<=n;++i) {
    scanf("%lf%lf",&t[i].p[0],&t[i].p[1]);
    for (int j=0;j<2;++j) t[i].mn[j]=t[i].mx[j]=t[i].p[j];
  }
  random_shuffle(t+1,t+n+1);	//我好懒啊不想写重构就rand一下顺序吧反正结果一样
  for (nw=1;nw<=n;++nw) Query(rt),Ins(rt,0);
  printf("%.2lf\n",sqrt(ans));
}
```

---

## 作者：Soulist (赞：10)

这道题因为数据水，然后被我用（随机化贪心？）模拟退火（不知道算不算）水过去了，主要是不知道分治怎么写$QAQ$。。

首先考虑按照x坐标排序。

然后考虑随机一个点。

不难发现，要求最近的点对，实际上，这两个点的横坐标差距会比较小。所以考虑设置一个参数表示对于一个点我们应该随机的其他点在他左右浮动多少。(我写的是$12(dela=12)$)对于一个点随机出来的答案，如果比当前答案优我们就转移$from$，否则就一定概率转移$from$(其实这句话完全不需要，只要随机枚举就好了，但加上这句是为了减少重复量)

说实话，我点子低，开着O2才跑过去的。。。

下面给出代码：



------------


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
struct X{
    double x, y;
    bool operator < (const X& a){
        return (x == a.x) ? y < a.y : x < a.x;
    }
}e[N];
double T = 1966, delta = 0.99995, tt = 1e-18;//基本参数
double num = 9999999;//初始答案
int n, dela = 12;//浮动程度（在左右12个的样子浮动）
double check(int x, int y){
    double ans = 0, xx = e[x].x - e[y].x, yy = e[x].y - e[y].y;
    ans = xx * xx + yy * yy;
    return sqrt(ans);
}
int qwq(int x){
    if(rand() % 2) return -x;
    return x;
}
void SA(){
    double t = T;
    int from, to;
    from = rand() % n + 1, to = from + rand() % dela + 1; 
    double DE;
    while(t > tt){
        to = qwq(rand() % dela) + from;//随机出来附近一个点
        if(to < 0) to = 1;//处理溢出
        if(to >= n) to = n;//处理溢出
        if(to == from)//如果相同就重新随机一个点
            continue;
        double ans = check(from, to);
        DE = num - ans;
        if(DE > 0){//如果新答案更优，就接受
            num = ans;
            from = to;
        }
        else if(exp(-DE / t)*RAND_MAX > rand()){//否则以一定概率接受
            from = to;
        }
        t *= delta;
    }
}
void input(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
  		scanf("%lf%lf", &e[i].x, &e[i].y);
    }
    int qaq = 12;
    num = 999999;
    sort(e + 1, e + n + 1);
    while(qaq--){//跑12遍
        SA();
    }
    printf("%.4lf", num);
    return ;
}
signed main()
{
    srand(time(0));
    input();
    return 0;
}
```

实际上，上面这个做法并不是特别优秀，因为常常会因为当前答案并不大，但却随机不出一个更好的答案而卡壳。所以最好改下写法—>(把以一定概率接受去掉，改为随机一个端点)这样参数就可以小一点，应该可以快一些

附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
struct X{
    double x, y;
    bool operator < (const X& a){
        return (x == a.x) ? y < a.y : x < a.x;
    }
}e[N];
double T = 1966, delta = 0.991, tt = 1e-18;
double num = 9999999;
int n, dela = 12;
double check(int x, int y){
    double ans = 0, xx = e[x].x - e[y].x, yy = e[x].y - e[y].y;
    ans = xx * xx + yy * yy;
    return sqrt(ans);
}
int qwq(int x){
    if(rand() % 2) return -x;
    return x;
}
void SA(){
    double t = T;
    int from, to;
    from = rand() % n + 1, to = from + rand() % dela + 1; 
    double DE;
    while(t > tt){
    	from = rand() % n + 1; 
        to = qwq(rand() % dela) + from;
        if(to < 0) to = 1;
        if(to >= n) to = n;
        if(to == from)
            continue;
        double ans = check(from, to);
        DE = num - ans;
        if(DE > 0){
            num = ans;
            from = to;
        }
        else if(exp(-DE / t)*RAND_MAX > rand()){
            from = to;
        }
        t *= delta;
    }
}
void input(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
  		scanf("%lf%lf", &e[i].x, &e[i].y);
    }
    int qwq = 12;
    num = 999999;
    sort(e + 1, e + n + 1);
    while(qwq--){
        SA();
    }
    printf("%.4lf", num);
    return ;
}
signed main()
{
    srand(time(0));
    input();
    return 0;
}
```

emm，下面一位老哥评论了好像数据加强了的亚子。

我附一个新参数吧...dela = 20, delta = 0.9998，现阶段是可以继续通过的

---

## 作者：I_AK_IOI！ (赞：8)

~~来这沾沾大佬之气~~

# 大佬写的是在太牛逼了

让我来写一篇萌新易懂的，
首先这是一道分治题，
用归并排序的思想，
先把这些点按横坐标从左到右排一遍，
再把这些点从中间开始左右分成两段的，
再把左边一段和右边一段都分成两端
。
这样一直分下去
，
直到一段的点数只有一个或两个
，
两个点返回这两个点的距离。

# 注意！一个点要返回无穷大

因为一个点没有距离
，
然后再比较左右两段的最小距离取更小的.

# 重点来了！

万一这两个距离最近的点不在同一段里呢
，
就像这样：
假设有a,b,c,d这四个点，距离最近的是b,c两点
，
第一次分完时是这样的:a,b|c,d
，
刚好隔开了b和c
。
~~凉凉夜色为你思念成河~~

所以我们要增加一步
，
在左段的点和右段的点的距离是否小于目前最短距离
，
如果你写个暴力直接TLE。

# 但我们发现：如果左段的点和右段的点距离比目前距离最短的两个点的距离还要短时，这两个点横坐标离左右两段和起来的这一大段的最中间的点的横坐标的距离一定要小于目前的最短距离。

这样就能缩小范围了
，
贴上蒟蒻的代码：

```
#include <bits/stdc++.h>//华丽的开头
using namespace std;
struct str{//点的结构体
	int x;//横坐标
  	int y;//纵坐标
};
str s[200001];//存入所有的点
str smid[1000];//离中点横坐标距离小于目前最小距离的点
bool cmp(str a,str b){
	return a.x<b.x;//从左到右排序
}
double g(str a,str b){
	return sqrt((abs(pow(a.y-b.y,2))+abs(pow(a.x-b.x,2))));//计算距离
}
double dis(int l,int r){
	if(l==r-1){
		return g(s[l],s[r]);//如果只剩两个点，返回距离
	}else if(l==r){
		return 99999999;//如果只剩一个点，返回无穷大
	}else{
		int mid=(l+r)/2,tmp=0;//第一个是中点，第二个是离中点横坐标距离小于目前最小距离的点的数量
		double min1=min(dis(l,mid),dis(mid+1,r));//求出最小距离
		for(int i=l;i<=r;i++){
			if(fabs(s[i].x-s[mid].x)<min1){//fabs求小数的绝对值，判断点离中点横坐标距离是否小于目前最小距离
				smid[tmp]=s[i];//存入数组
				tmp++;//别忘了++
			}
		}
		for(int i=0;i<tmp;i++){
			for(int j=0;j<tmp;j++){
				if(i!=j&&g(smid[i],smid[j])<min1){
					min1=g(smid[i],smid[j]);
				}
			}
		}//用暴力找有没有两个点的距离小于目前最小距离
		return min1;//最后要返回
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		scanf("%d %d",&s[i].x,&s[i].y);
	}//输入
	sort(s,s+n,cmp);//横坐标从左往右排序
	printf("%.4lf",dis(0,n-1));//要保留四位小数
	return 0;//结束
}
```

~~希望管理员大大能过~~

---

## 作者：_jimmywang_ (赞：8)

# 第一篇蓝题题解

[p.s.~~（感觉不是蓝题啊）~~](https://www.luogu.org/record/26573514)

# step1：暴力
对于两个点i，j，计算dis（i，j），然后取最小值。

代码（37分，O2后46分）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			ans=min(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（哎呦）~~

# step2：排序优化
按照x关键字排序，计算min（ans，dis（i，i-1））
代码（81分）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（哈哈哈，你有两个点没过！！）~~

为什么呢？
# step3:玄学排错1
按照x关键字排序，计算min（ans，dis（i，i-1））和min（ans，dis（i，i-2））
代码（90分）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	for(int i=3;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-2].x,a[i-2].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（哈哈哈，你有1个点没过！！）~~

又是为什么呢？
# step4:玄学排错2
按照x关键字排序，计算min（ans，dis（i，i-1））

按照y关键字排序，计算min（ans，dis（i，i-1））

代码（90分）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[200010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
bool cmp1(node a,node b){return (a.y==b.y)?(a.x<b.x):(a.y<b.y);}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));	
	sort(a+1,a+n+1,cmp1);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~（哈哈哈，你有1个点没过！！）~~

………………
# step5：玄学优化*2

按照x关键字排序，计算min（ans，dis（i，i-1））和min（ans，dis（i，i-2））和min（ans，dis（i，i-3））~~（你无聊吗？）~~

代码（100分）：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	long double x,y;
}a[500010];
double ans=10000000.0;
double dis(double a,double b,double c,double d){
	return sqrt(abs(c-a)*abs(c-a)+abs(d-b)*abs(d-b));
}
bool cmp(node a,node b){return (a.x==b.x)?(a.y<b.y):(a.x<b.x);}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-1].x,a[i-1].y));
	for(int i=3;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-2].x,a[i-2].y));
	for(int i=4;i<=n;i++)ans=min(ans,dis(a[i].x,a[i].y,a[i-3].x,a[i-3].y));
	printf("%.4lf",ans);
	return 0;
}
```
~~(666666……)~~

---

## 作者：da32s1da (赞：8)

先膜拜@3A17K大佬的神仙算法！！

原理不赘述了，3A17K巨佬已经讲明白了，这里提供一下代码。

注意旋转θ角时坐标变换

- **x'=xcosθ-ysinθ**
- **y'=xsinθ+ycosθ**

```
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=2e5+50;
#define D double
struct spot{
	D a[4];
}p[N];
D x,y,x_,y_,z,w,ans;
int n;
bool mmp(const spot &u,const spot &v){
	return u.a[0]<v.a[0];
}
int main(){
	scanf("%d",&n);
	z=sin(1),w=cos(1);  //旋转1弧度≈57°
	for(int i=1;i<=n;i++){
		scanf("%lf%lf",&x,&y);
		x_=x*w-y*z;
		y_=x*z+y*w;   //计算旋转后的坐标
		p[i].a[0]=x_;
		p[i].a[1]=y_;
		p[i].a[2]=x;
		p[i].a[3]=y;   //存下来
	}
	sort(p+1,p+n+1,mmp);   //排序
	for(int i=n+1;i<=n+10;i++)
	p[i].a[0]=p[i].a[1]=-N-0.01;  //边界处理
	ans=2e9+0.01;  //初始化答案
	for(int i=1;i<=n;i++)
	for(int j=1;j<=5;j++){  //枚举
		x=p[i].a[2];y=p[i].a[3];
		x_=p[i+j].a[2];y_=p[i+j].a[3];
		z=sqrt((x-x_)*(x-x_)+(y-y_)*(y-y_));  //计算距离
		if(ans>z)ans=z;   //更新答案
	}
	printf("%.4lf\n",ans);  //输出
}
/*
x'=xcosθ-ysinθ
y'=xsinθ+ycosθ
*/
```
## 人类的智慧是无穷无尽的！

---

## 作者：Treaker (赞：7)

## 解法：
这道题我们可以用分治，把横坐标排序，对于每段区间，我们考虑跨过分界线的贡献(分界线可以用平均值来得到)，我们只需要找距分界线距离在ans以内的点，再分组求距离更新ans即可。
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#define N (200020)
using namespace std;
int n;
double ans = 2147483647.0;
struct node
{
	double x , y;
	friend bool operator < (const node &a,const node &b)
	{
		if(a.x == b.x)	return a.y < b.y;
		return a.x < b.x;
	}
}e[N] , tmp[N] , temp[N];
void feez(int l,int r)
{
	if(l == r)	return ;
	int mid = (l + r) >> 1 , p = 0 , q = 0;
	feez(l,mid); feez(mid+1,r);
	double fj = (e[mid].x + e[mid+1].x) / 2.0;
	for(int i = l;i <= mid;i ++)	if(fj - e[i].x <= ans) tmp[++ p] = e[i];
	for(int i = mid + 1;i <= r;i ++)	if(e[i].x - fj <= ans)	temp[++ q] = e[i];
	for(int i = 1;i <= p;i ++)	for(int j = 1;j <= q;j ++)
		ans = min(ans,sqrt((tmp[i].x - temp[j].x) * (tmp[i].x - temp[j].x) + (tmp[i].y - temp[j].y) * (tmp[i].y - temp[j].y)));
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)	scanf("%lf%lf",&e[i].x,&e[i].y);
	sort(e+1,e+1+n);
	feez(1,n);
	printf("%.4f\n",ans);
	return 0;
}
```

---

## 作者：critnos (赞：7)

我们不发扬人类智慧了。

毕竟旋转太慢 ~~，而且我听不懂。~~

给出这道题的终极解法：

**直接按 $x$ 坐标排序，然后每个点往后取 $4$ 个点比较距离。**

因为根据直觉，两个点的 $x$ 坐标不会相差太远。

时间复杂度 $O(n\log n)$ 。

这样跑得飞快，常数小（毕竟是 $\texttt{sort}$ ，还不带三角函数计算的常数 ）。

当然，这里再给出提高成功率的方法：

* 往后取的点多一些

* 如果按 $x$ 坐标 排序不行，那就再对 $y$ 坐标排一次序。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int s=4;
struct note
{
	double x,y;
}a[200005];
bool cmp(note x,note y)
{
	return x.x<y.x;
}
double cover(note x,note y)
{
	return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));
}
int main()
{
	int i,j,n;
	double mn=1e20;
	scanf("%d",&n);
	for(i=0;i<n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y); 
	sort(a,a+n,cmp);
	for(i=0;i<n;i++)
		for(j=i+1;j<n&&j<i+s;j++)
			mn=min(mn,cover(a[i],a[j]));
	printf("%.4f",mn);
} 
```
完。

---

## 作者：xzyxzy (赞：6)

这是一道很难很难很难很难很难的题

你永远不会想到用二分吧？

O(∩\_∩)O米兔

所以来看看怎么用二分的吧

首先嘛，可以肯定的是，每两个去算距离O(n^2)的复杂度肯定会超时的

所以二分是个不错的选择，可以将时间降到O(nlog2n)（二分log2n然后比较各个点的距离与答案约是n）

于是——怎么分

✔将各个点（结构体）按x的从小到大排序

✔首先运用二分思想将点集合分到最后只剩两个点的时候

✔然后用这两点之间的距离更新答案（答案初始化为无限大）

✔然后我们要找到二分的具体实现方案——每次分到一些点时，找到这些点标号的中间（因为点都排好序了，所以其实也就是找到x轴上一条分界线），将整个点的集合大致均分为两个部分

✔在分界线的右侧，将与分界线的距离小于ans的点纳入到一个辅助结构体里面

✔在分界线的左侧，不断枚举点，枚举到离分界线小于ans的点时，与辅助结构体中的点**挨个**（等会有解释）判断其距离有没有小于ans，更新ans


注意下用double**别掉了精度**，然后格式化输出就好了

然后我的代码中，为了避免超时，还是很努力地自己写了个实数的输入优化没想到也过了


解释下这个“挨个”

有些题解中在每次更新完ans后都将这些点按y轴从小到大排了序，然而我并不知道这有什么用，照着题解打一遍WA了一个点，然后。。调试一番后感觉真的没什么卵用，去掉了（注释部分）再在源代码上稍加修改，就过了


………………………………

……………………………………

………………………………

……………………………………

…………………………………………

………………………………

请教大佬中（询问这个排序有什么用）

嗯，这个排完序后当扫到一个点与该点距离大于ans时，就可以不再扫了

但是，，难道排序不要时间吗。。。所以可能也许大概排完序后有那么一丢丢优化/笑哭/



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring> 
using namespace std;
struct dian{
    double x,y;
}a[200001],b[200001];
int n;
int cmpx(const dian&a,const dian&b)
{
    if(a.x<b.x) return 1;
    if(a.x>b.x) return 0;
    if(a.y<b.y) return 1;
    return 0;
}
double read()
{
    char ch=getchar();
    while(ch!='.'&&(ch>'9'||ch<'0')) ch=getchar();
    int h=0,t=1,b=0;
    while(ch!='.'&&ch<='9'&&ch>='0')
    {
        h=h*10+ch-48;
        ch=getchar();
    }
    if(ch=='.')
    {
        ch=getchar();
        while(ch<='9'&&ch>='0')
        {
            b=b*10+ch-48;
            ch=getchar();
            t*=10;
        }
    }
    return h+(b*1.000000000)/t;
}
double mini(double a,double b)
{
    return a>b?b:a;
}
double ans=1000000000;
void merge(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)/2;//找到中间位置的点 
    merge(l,mid);
    merge(mid+1,r);//递归调用 
    //memset(b,0,sizeof(b));
    int line=a[mid].x;//分界线
    int p=1;//指向b的首位（b数组按照x轴顺序来的） 
    int t=0;//指向b的存储的位置 
    for(int i=mid+1;i<=r;i++)//枚举分界线右边的点 
    {
        if(a[i].x-line<ans) 
            b[++t]=a[i];//如果该点与分界线的距离小于答案的话，将此点存入b中 
    } 
    for(int i=l;i<=mid;i++)
    {
        if(line-a[i].x>=ans) continue;//如果该点与分界线的距离大于答案，继续找
        //while(p<=t&&a[i].y-b[p].y>=ans)//要求在b中找到一个p 
        //    p++;//使得a[i]的y轴坐标-b[p]的值要小于答案
        for(int j=p;j<=t&&abs(b[j].y-a[i].y)<ans;j++)//不断地枚举b中剩下的点 
            ans=mini(ans,sqrt((a[i].x-b[j].x)*(a[i].x-b[j].x)+(a[i].y-b[j].y)*(a[i].y-b[j].y)));//然后更新答案 
    }
    /*for(int i=l,p1=l,p2=mid+1;i<=r;i++)
        if(p1<=mid&&(p2>r||a[p1].y<a[p2].y)) b[i]=a[p1++];
        else b[i]=a[p2++];
    for(int i=l;i<=r;i++) a[i]=b[i];//按纵坐标从小到大排序 */
} 
int main()
{
    n=read();
    for(int i=1;i<=n;i++) 
    {
        a[i].x=read();
        a[i].y=read();
    }
    sort(a+1,a+n+1,cmpx);//以X为关键字排序
    merge(1,n);//将1到n去查找 
    printf("%0.4lf",ans);
    return 0; 
}
```

---

## 作者：kczno1 (赞：6)

我懒得学分治法。。于是我用了kd-tree。

建树就是每次交替选择x,y坐标作为关键字，选择位于中间的点做根，左右递归操作。

搜索最近点就是用自己去更新ans，之后预估左右儿子的可能的最优值，之后选择较优的先dfs。同时如果可能的最优值>ans就退出。

我只能说建树是nlogn的，但搜索的时间复杂度我也不会证(也没看到过证明，估计是n^2的，但也没看到过被卡的)。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

#define N 200100
void chmin(double &x,const double &y) { if(x>y)x=y; }
void chmax(double &x,const double &y) { if(x<y)x=y; }
double sqr(const double &x) { return x*x; } 
struct point
{
    double x[2];
    void read() { scanf("%lf%lf",x,x+1); }
    friend double dis(const point &x,const point &y)
    {
        return sqr(x.x[0]-y.x[0])+sqr(x.x[1]-y.x[1]);
    }
}p[N],now;

bool xiao0(const point &x,const point &y) 
{
    return x.x[0]<y.x[0]||x.x[0]==y.x[0]&&x.x[1]<y.x[1];
}
bool xiao1(const point &x,const point &y) 
{
    return x.x[1]<y.x[1]||x.x[1]==y.x[1]&&x.x[0]<y.x[0];
}

struct tree
{
    int l,r;double mx[2],mn[2];
}T[N];
void up(int k,int c)
{
    chmin(T[k].mn[0],T[c].mn[0]);chmin(T[k].mn[1],T[c].mn[1]);
    chmax(T[k].mx[0],T[c].mx[0]);chmax(T[k].mx[1],T[c].mx[1]);
}
int build(int l,int r,bool d)
{
    int k=l+r>>1;
    nth_element(p+l,p+k,p+r+1,d?xiao0:xiao1); 
    T[k].mn[0]=T[k].mx[0]=p[k].x[0];T[k].mn[1]=T[k].mx[1]=p[k].x[1];
    d=!d;
    if (l!=k) up(k,T[k].l=build(l,k-1,d));
    if (r!=k) up(k,T[k].r=build(k+1,r,d));
    return k;
} 

double ans=1e18,x;
double may(int k)
{
    if (now.x[0]<T[k].mn[0]) x=sqr(T[k].mn[0]-now.x[0]);else
    if (now.x[0]>T[k].mx[0]) x=sqr(T[k].mx[0]-now.x[0]);else
    x=0;
    if (now.x[1]<T[k].mn[1]) return x+sqr(T[k].mn[1]-now.x[1]);
    if (now.x[1]>T[k].mx[1]) return x+=sqr(T[k].mx[1]-now.x[1]);
    return x;
}
void dfs(int k)
{
    chmin(ans,dis(p[k],now));
    int l=T[k].l,r=T[k].r;
    double ml=may(l),mr=may(r);
    if (ml<mr)
    {
        if (ml<ans) { dfs(l);if(mr<ans) dfs(r); }
    }
    else 
    {
        if (mr<ans) { dfs(r);if(ml<ans) dfs(l); }
    }
}

int main()
{ //freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int n,i,rt;
    scanf("%d",&n);
    for (i=1;i<=n;++i) p[i].read();
    rt=build(1,n,1);
    
    T[0].mn[0]=T[0].mn[1]=2e9;
    now=p[1];p[1]=p[2];dfs(rt);p[1]=now;
    for (i=2;i<=n;++i)
    {
       now=p[i];p[i]=p[i-1];dfs(rt);p[i]=now;
    }
    printf("%.4lf",sqrt(ans));
}
```

---

## 作者：Fuyuki (赞：5)

众所周知的是，处理平面问题存在一种非常好写又跑得相当快的数据结构---$KD-Tree$。

具体做法就是不断插入一个节点然后再整棵树上面查找最近的点。

注意的是使用$KD-Tree$进行~~暴力~~查询的时候为了保证复杂度需要使用一个估价函数还进行剪枝。这里使用的估价函数就是将这个点和当前矩形两条边之间的距离计算出来。

顺带一提，为了减小常数，可以不直接储存两点之间的距离，而知储存距离的平方。

```
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define rnt re int
#define lc t[p].ls
#define rc t[p].rs
#define re register
#define LL inline ll
#define I inline int
#define V inline void
#define B inline bool
#define lson lc,L,mid-1
#define rson rc,mid+1,R
#define ll long long int
#define isnum(ch) ('0'<=ch&&ch<='9')
#define FOR(i,a,b) for(rnt i=a;i<=b;i++)
#define ROF(i,a,b) for(rnt i=a;i>=b;i--)
#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)
char _buf[100000],*_op(_buf),*_ed(_buf);
I getint(){
	rnt _s=0;re char _ch=gc;
	while(!isnum(_ch))_ch=gc;
	while(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;
	return _s;
}
I min(const int&x,const int&y){return x<y?x:y;}
I max(const int&x,const int&y){return x>y?x:y;}
const int N=2e5+1,INF=0x7fffffff;
ll ans=1ll<<62;const double alpha=0.75;
int n,m,rt,WD;
struct node{
	int sta[N],top,tot;
	V del(rnt x){if(x)sta[++top]=x;}
	I newnode(){return top?sta[top--]:++tot;}
}T;
LL pw(const int&x){return 1ll*x*x;}
struct poi{
	int x[2];
	V input(){FOR(i,0,1)x[i]=getint();}
	B operator<(const poi&u)const{return x[WD]<u.x[WD];}
	LL operator-(const poi&u)const{
		return pw(x[0]-u.x[0])+pw(x[1]-u.x[1]);
	}
}a[N];
struct mat{
	int x[2][2];
	mat(){FOR(i,0,1)x[i][0]=INF,x[i][1]=-INF;}
};
struct kdt{
	mat pos;poi now;
	int ls,rs,siz;
}t[N];
V init(rnt p){
	t[p].siz=t[lc].siz+t[rc].siz+1;
	FOR(i,0,1)t[p].pos.x[i][0]=min(t[p].now.x[i],min(t[lc].pos.x[i][0],t[rc].pos.x[i][0]));
	FOR(i,0,1)t[p].pos.x[i][1]=max(t[p].now.x[i],max(t[lc].pos.x[i][1],t[rc].pos.x[i][1]));
}
V pia(rnt p){if(p)a[++m]=t[p].now,T.del(p),pia(lc),pia(rc),lc=rc=0;}
V build(int&p,rnt L,rnt R,rnt wd){
	if(L>R)return;rnt mid=L+R>>1;WD=wd;
	nth_element(a+L,a+mid,a+R+1),t[p=T.newnode()].now=a[mid];
	build(lson,wd^1),build(rson,wd^1),init(p);
}
LL dis(const poi&x,const mat&y){
	re ll out=0;
	FOR(i,0,1)out+=pw(max(0,y.x[i][0]-x.x[i])+max(0,x.x[i]-y.x[i][1]));
	return out;
}
V ask(rnt p,const poi&x){
	if(!p)return;
	re ll lval=dis(x,t[lc].pos),rval=dis(x,t[rc].pos),val=x-t[p].now;
	if(val<ans)ans=val;
	if(lval<rval){
		if(lval<ans)ask(lc,x);
		if(rval<ans)ask(rc,x);
	}else{
		if(rval<ans)ask(rc,x);
		if(lval<ans)ask(lc,x);
	}
}
B check(rnt p){return alpha*t[p].siz<max(t[lc].siz,t[rc].siz);}
V ins(int&p,const poi&x,rnt wd){
	if(!p)return t[p=T.newnode()].now=x,init(p);WD=wd;
	if(x<t[p].now)ins(lc,x,wd^1);
	else ins(rc,x,wd^1);init(p);
	if(check(p))pia(p),build(p,1,m,wd),m=0;
}
V work(){
	n=getint();poi tmp;
	while(n--)tmp.input(),ask(rt,tmp),ins(rt,tmp,0);
	printf("%.4lf",(double)sqrt(ans));
}
int main(){
	work();
	return 0;
}
```


---

## 作者：妩媚的ak萝莉 (赞：5)

本题言简意赅，给n个点，求最近点对($n\le 10^5$)

[Luogu](https://www.luogu.org/problem/P1429)

[poj(略有不同)](http://poj.org/problem?id=3714)

## 题解：

这题初看令人眩晕，有效信息两两点的距离就有$O(n^2)$，只能是减一些状态。比如说$\Delta x \Delta y$都更大就舍去？？明显没有可操作性。。

正解是一个经典分治，本题分治特点是利用分治答案来进行分治，按x排序，按x分治，枚举mid左右ans范围内的点，把这些点按y排序，y坐标相差不超过ans的点统计答案（横着的日字划分，可证每个点统计答案不超过6个），总复杂度$O(6nlog^2n)$

具体的说，本题是一个经典的模型，本来$O(n^2)$无法优化的状态数，通过分治下一个“自矛盾”巧妙地避免了枚举明显不可能的点对。跨边界的可能是答案的点对其实只有一点点，什么“自矛盾”，其实就是根据左右已统计的答案严谨地证明了这个“一点点”

## 代码（Luogu）：
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <math.h>
using namespace std;
typedef long double ld;
const int N=2e5+50;
const ld le=1e-7;
const ld INf=2000000000.0;
struct Point{
	int x,y;
	Point(){}
}po[N],tmp[N];
int n;
ld ans=INf;

bool cmpx(Point a,Point b){return a.x<b.x;}

bool cmpy(Point a,Point b){return a.y<b.y;}

inline int wdabs(int a){return (a>0?a:(-a));}

inline ld sqr(ld a){return a*a;}

inline ld dis(int a,int b){return sqrt(sqr(tmp[a].x-tmp[b].x)+sqr(tmp[a].y-tmp[b].y));}

void solve(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)/2;
	solve(l,mid);
	solve(mid+1,r);
	int d=ans,cnt=0;d+=1;
	for(int i=l;i<=r;i++)
		if(wdabs(po[i].x-po[mid].x)<=d)
			tmp[++cnt]=po[i];
	sort(tmp+1,tmp+1+cnt,cmpy);
	for(int i=1;i<=cnt;i++)
	{
		for(int j=i+1;tmp[j].y-tmp[i].y<=d && j<=cnt;j++)
			ans=min(ans,dis(i,j));
	}
	return;
}

int main()
{
	ans=INf;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&po[i].x,&po[i].y);
	sort(po+1,po+1+n,cmpx);
	solve(1,n);
	printf("%.4Lf\n",ans);
	return 0;
}
```

---

## 作者：白菜道士 (赞：4)

#### ~~关于这道题，其实是比较玄学的~~
-----
#### 思路很简单（~~简直就是暴力中的极品~~）

#### 不知道为什么dalao们说要随机旋转

我基本上纯暴力A掉了

以下为方法：

先求第1个点与其余n-1个点的距离；

再求第2个点与其余n-2个点的距离；

…………………………………………

再求第n-1个点与其余1个点的距离；

然后找出最小值，如此的算法复杂度为O(n^2)

核心代码如下：

```cpp

  for(int i=1; i<=n; i++)
        for(int j=i; j<=n; j++)
            if(i+j<=n)
            {
                d=sqrt((x[i]-x[j])*(x[i]-x[j])*1.0+(y[i]-y[j])*(y[i]-y[j])*1.0);
                if(d<mindist)	mindist=d;
            }
            
```

显然不行

然后就比较~~玄学~~了

为了减少枚举量，本少决定只比较每个点后面的150个点

然后莫名AC了

为了再次减少枚举量，本少决定只比较每个点后面的50个点

然后再次莫名AC了

为了再次减少枚举量，本少决定只比较每个点后面的3个点

然后再次莫名AC了

~~这是一个玄学问题~~

AC代码如下
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;//流线型头文件

const int Max=200010;
double x[Max],y[Max];

void Qsort(int l,int r)
{
    int i,j;
    double a,b;
    i=l;
    j=r;
    a=x[(l+r)/2];
    while(i<=j)
    {
        while(x[i]<a)	i++;
        while(a<x[j])	j--;
        if(i<=j)
        {
            b=x[i];	x[i]=x[j]; x[j]=b;
            b=y[i];	y[i]=y[j]; y[j]=b;
            i++;
            j--;
        }
    }
    if(i<r)	Qsort(i,r);
    if(l<j)	Qsort(l,j);
}//先给x坐标排序

int main()
{
    int len;
    scanf("%d",&len);
    for(int i=1; i<=len; i++)
        scanf("%lf%lf",&x[i],&y[i]);
    double mindist=99999999999;
    Qsort(1,len);
    double d;
    for(int i=1; i<=len; i++)
        for(int j=1; j<=3; j++)//比较每个点后面的3个点
            if(i+j<=len)
            {
                d=sqrt((x[i]-x[i+j])*(x[i]-x[i+j])*1.0+(y[i]-y[i+j])*(y[i]-y[i+j])*1.0);
                if(d<mindist)	mindist=d;
            }//比较
    printf("%.4lf\n",mindist);
    return 0;
}
```


---

## 作者：Great_Influence (赞：3)

为什么要分治啊？暴力枚举就可以了。。。。。。

虽然正常枚举O(n^2)无法承受，但是可以先排序，在每次枚举前确定一个枚举上界，如果x坐标差超过了这个上界，答案不会更优，直接弹出。时间复杂度O(能过)。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//读入优化
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file()
{
    #ifndef ONLINE_JUDGE
        freopen("dist.in","r",stdin);
        freopen("dist.out","w",stdout);
    #endif
}
const int MAXN=200010;
int n;
typedef pair<int,int>Pr;//点
Pr a[MAXN];
void init()
{
    read(n);
    Rep(i,1,n)read(a[i].first),read(a[i].second);
    sort(a+1,a+n+1);//排序
}
long long ans;
long long dist(int x,int y)//求距离
    {return (long long)(a[x].first-a[y].first)*(a[x].first-a[y].first)
        +(long long)(a[x].second-a[y].second)*(a[x].second-a[y].second);}
#define Chkmin(a,b) a=a<b?a:b
void search(int poi,long long &r)//暴力搜索
{
    Rep(i,poi+1,n)
    {
        if((a[i].first-a[poi].first)*(a[i].first-a[poi].first)>=r)return;//答案不会更优，弹出
        Chkmin(r,dist(poi,i));
    }
}
void solve()
{
    ans=dist(1,2);//先确认第一个上界
    Rep(i,1,n)search(i,ans);//再搜索
    printf("%.4lf\n",sqrt(ans));//记得别先开方，防止精度误差
}
int main()
{
    file();
    init();
    solve();
    return 0;
}
```

---

## 作者：Resonance (赞：1)

怎么能没有KD-Tree的题解呢（逃）

KD-Tree是一种优(Bao)美(Li)的数据结构

其实和分治的思路是差不多的

最开始T飞了,然后充分发扬人类的智慧

询问的时候改一下左右子树的顺序,然后吸氧就可以AC啦

### Code
```cpp
#include<bits/stdc++.h>
#define inf 2e9
#define N 200005
#define db double
#define lc t[x].ch[0]
#define rc t[x].ch[1]
#define mid ((l+r)>>1)
#define MIN(x,y) x=min(x,y)
#define MAX(x,y) x=max(x,y)
using namespace std;
struct node{
	db p[2];
	node(){}
	node(db x,db y){p[0]=x;p[1]=y;}
}a[N];
struct tree{
	int sz,ch[2];
	db x1,x2,y1,y2;
}t[N];
db ans=inf,res;
int n,rt,tot;
bool cmp0(node x,node y){
	return x.p[0]<y.p[0];
}
bool cmp1(node x,node y){
	return x.p[1]<y.p[1];
}
void update(int x,int y){
	MIN(t[x].x1,t[y].x1);
	MIN(t[x].y1,t[y].y1);
	MAX(t[x].x2,t[y].x2);
	MAX(t[x].y2,t[y].y2);
}
void push_up(int x){
	t[x].sz=t[lc].sz+t[rc].sz+1;
	if(lc) update(x,lc);
	if(rc) update(x,rc);
}
void build(int &x,int l,int r,int tp){
	if(l>r) return;
	if(tp==0) sort(a+l,a+r+1,cmp0);
	if(tp==1) sort(a+l,a+r+1,cmp1);
	x=mid;t[x].sz=1;
	t[x].x1=t[x].x2=a[x].p[0];
	t[x].y1=t[x].y2=a[x].p[1];
	build(lc,l,mid-1,tp^1);
	build(rc,mid+1,r,tp^1);
	push_up(x);
}
db sp(db x){return x*x;}
db dis(node x,node y){
	return sqrt(sp(fabs(x.p[0]-y.p[0]))+sp(fabs(x.p[1]-y.p[1])));
}
db ex(int x,int u){
	db now=inf;
	db x1=t[x].x1,x2=t[x].x2;
	db y1=t[x].y1,y2=t[x].y2;
	db xn=a[u].p[0],yn=a[u].p[1];
	if(x1<=xn&&xn<=x2&&y1<=yn&&yn<=y2) return 0;
	MIN(now,dis(a[u],node(x1,y1)));
	MIN(now,dis(a[u],node(x1,y2)));
	MIN(now,dis(a[u],node(x2,y1)));
	MIN(now,dis(a[u],node(x2,y2)));
	return now;
}
void ask(int x,int u){
	if(u!=x) MIN(res,dis(a[u],a[x]));
	if(rc&&ex(rc,u)<res) ask(rc,u);//在这里调整顺序
	if(lc&&ex(lc,u)<res) ask(lc,u);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%lf%lf",&a[i].p[0],&a[i].p[1]);
	build(rt,1,n,0);
	for(int i=1;i<=n;++i){
		res=inf;ask(rt,i);
		MIN(ans,res);
	}	
	printf("%.4lf\n",ans);
}
```

---

## 作者：说好不哭 (赞：1)

## 感想：
### 一开始，完全不明白这个思路，感觉这个思路很玄学，确实，很玄学，也比较难懂。
## 
## 思路：
### 利用分治，分而治之，使得程序能够在 n log n的复杂度下跑过。任何优化算法的前提都是答案的正确性和复杂度的正确性，那么我就来证明一下这两个正确性。 （这里，对于算法的实现和理解，就不过多介绍，完全可以看别的题解。）
##
## 证明答案正确性：
### 这个证明不难，分治分治，分而治之，所以，我们对于当前区间 【L,R】的答案，就是  Min(【L,Mid】，【Mid+1，R】），这个相信大家都能理解吧。但是，由于会有一个中间地带的点影响答案，所以我们需要暴力求解中间地带的点，算出它们两两匹配的距离。（中间地带的点包括哪些，就不细说了）。那么，这个答案，明显是正确的呀，因为，我们的答案已经完全包括了所有可能的情况。
## 证明复杂度：
### 分治递归复杂度为 log n,每次分治时候跑一遍L到R，所以就是n log n了。可能会有人问，对于那个cnt^2的复杂度怎么保证不会超时，我想说的是，只要不是人为卡你的数据，那个cnt会变得极小极小，所以可以忽略。 （只要不是人为卡你的数据，那个cnt会变得极小极小，可以好好领悟一下）
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
struct number{double x,y;}a[N],b[N];

inline bool cmp(number a,number b){return a.x<b.x;}

inline double solve(int l,int r)
{
	if (l==r) return 100000000.0;	
	int mid=l+r>>1;
	double ans=min(solve(l,mid),solve(mid+1,r));   //分而治之 
	int cnt=0;
	//对于中间地带的点进行暴力求解 
	for (register int i=l; i<=r; ++i) if (fabs(a[i].x-a[mid].x)<ans) b[++cnt]=a[i];
	for (register int i=1; i<cnt; ++i)
	for (register int j=i+1; j<=cnt; ++j) 
	ans=min(ans,sqrt((b[i].x-b[j].x)*(b[i].x-b[j].x)+(b[i].y-b[j].y)*(b[i].y-b[j].y)));
	return ans;
}

int main(){
	scanf("%d",&n);
	for (register int i=1; i<=n; ++i) scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);
	printf("%.4lf\n",solve(1,n));
return 0;
}
```


---

## 作者：Cesare (赞：1)

此处使用了置顶题解的方法，建议搭配食用。

就是先随机旋转，然后根据横坐标排一遍序，枚举后五个点。

复杂度$O(nlogn)$

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
typedef long long ll;

ll n;
double ans=0x7f7f7f7f7f7f;

struct node {
    double x,y;
}p[200010];

inline bool cmp(node a,node b){return a.x<b.x;}

inline double dis(node a,node b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}

inline int read(){
    ll ans=0;bool f=0;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())f^=(ch=='-');
    for(;isdigit(ch);ch=getchar())ans=(ans<<3)+(ans<<1)+(ch^48);
    return f? -ans: ans;
}

int main(){
    n=read();
    for(re int i=1;i<=n;i++){
        double xx,yy;
        scanf("%lf%lf",&p[i].x,&p[i].y);
        xx=p[i].x*cos(422)-p[i].y*sin(422);//旋转公式
        yy=p[i].x*sin(422)+p[i].y*cos(422);//转两次
        p[i].x=xx,p[i].y=yy;
    }
    sort(p+1,p+n+1,cmp);
    for(re int i=1;i<=n;i++){
        ans=(ans>dis(p[i+1],p[i]))? dis(p[i+1],p[i]): ans;//枚举可行的点
        ans=(ans>dis(p[i+2],p[i]))? dis(p[i+2],p[i]): ans;
        ans=(ans>dis(p[i+3],p[i]))? dis(p[i+3],p[i]): ans;
        ans=(ans>dis(p[i+4],p[i]))? dis(p[i+4],p[i]): ans;
        ans=(ans>dis(p[i+5],p[i]))? dis(p[i+5],p[i]): ans;
    }
    printf("%.4lf\n",ans);
    return 0;
}
```

---

## 作者：YJMSTR (赞：1)

楼上说的O(n)算法都是不能保证绝对正确的 而且大多用旋转坐标轴做的都只旋转了一次	是可以被轻松卡掉的

我们可以增加旋转的次数， 同时把向后枚举的范围缩小一些，这样算法的常数虽然大了，但正确性更有保证，足以在洛谷AC.

实现代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define Max(_A,_B) (_A>_B?_A:_B)
#define Min(_A,_B) (_A<_B?_A:_B)
#define maxn 200007
#define maxm 1000001
#define V e[i].v
#define ull unsigned long long
#define R register
#define dd double
//#define pf(x) ((x * x))
double DIST(double _x, double _y, double __x, double __y) {
    return sqrt((_x - __x) * (_x - __x) + (_y - __y) * (_y - __y));
}
int n, m, k, tot;
inline int read(){
    R int s = 0, f = 1; R char c = getchar();
    while (c > '9' || c < '0') {if(c=='-') f= -1; c = getchar();}
    while (c >= '0' && c <= '9') {s = s * 10 + c - '0'; c = getchar();}
    return s * f;
}
struct Point{
    dd x, y, xx, yy;
    bool operator < (const Point &rhs) const {
        return xx < rhs.xx;
    }
}p[maxn];
dd x, y, xx, yy, ans, sine1, cosine1;
void round(){
    static dd x, y;
    for (int i = 1; i <= n; i++) {
        x = p[i].xx, y = p[i].yy;
        p[i].xx = x * cosine1 - y * sine1;
        p[i].yy = x * sine1 + y * cosine1;
    }
}
void work(){
   // printf("%.4lf\n", ans);
    for (int i = 1; i < n; i++){
        for (int j = 1; j <= 2 && j + i <= n; j++) {//旋转多次 每次向后取3个点
            x = p[i].x; y = p[i].y;
            xx = p[i + j].x; yy = p[i + j].y;
            ans = Min(ans, DIST(x,y,xx,yy));
        }   
    }
}
int main() {
    n = read();
    sine1 = sin(1); cosine1 = cos(1);   //每次旋转1弧度 旋转若干次
    for (int i = 1; i <= n; i++) {
        scanf ("%lf%lf", &x, &y);
        xx = x * cosine1 - y * sine1;
        yy = x * sine1 + y * cosine1;
        p[i].xx = xx; p[i].yy = yy; 
        p[i].x = x; p[i].y = y;
    }
    ans = 2e9 + 0.01;    
    work();
    sort(p + 1, p + n + 1);
    work();
    round();
    sort(p + 1, p + n + 1);
    work();
    round();
    sort(p + 1, p + n + 1);
    work();
    printf("%.4lf\n", ans);
    return 0;
}

```

---

## 作者：鹭天 (赞：0)

#### [题目传送门](https://www.luogu.org/problem/P1429)

## 题目描述：
给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所有点对中，该距离为所有点对中最小的。
***
# Solution
这题考虑分治。
先将点对按照横坐标排序，每次进行分治时每次以中间的横坐标的点为分界线分治。
* 我们设中间那个点的编号为$mid
* 我们将距离最近的点对分为三类：
 1、$[l,mid]间距离最小的点对$
 2、$[mid+1,r]间距离最小的点对$
 3、$跨区间的距离最小的点对$
* 只需要将三个答案去一个min即可

对于前两种，好处理，不断地递归分治即可
问题主要处理第三种。
因为我们先进行了递归分治，这是得出了$min(1,2)$的答案是ans（指的是第1、2种方案的较小值）
这是我们就可以根据ans来限定搜查的范围
很显然，对于一个有效的搜查范围，当且仅当$x[i] - x[mid] <=ans$，这是一个很显然的结论，当两横坐标之差>ans时，这是绝对不会为最优解的

将这几个点暴力遍历一遍即可。
//还有。。这个实数的坐标是一个坑。。。确实是第一次遇到
***
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,maxx=0;
//vector < int , int > xn[200010];
struct node{
    double x,y,num;
}a[200010];

inline bool mycmp(node x,node y){
    return x.x <y.x;
}

inline bool mycmpp(node x,node y){
   return x.y<y.y;
}

double js(node x,node y){
     X=x.x,Y=x.y,XX=y.x,YY=y.y;
    return sqrt((X-XX)*(X-XX) + (Y-YY)*(Y-YY) * 1.0);
}

double dfs(int l,int r){
	double ans=1e12;
    if (l >= r) return 1000000000.00;
    if (l + 1 == r) return js(a[l],a[r]);
    int mid=l+r>>1;
    ans = min(dfs(l,mid) , dfs(mid+1,r));
	int len=0;
	node b[n+10];
	for (int i=l;i<=r;i++)
	  if (fabs(a[i].x - a[mid].x) <= ans) b[++len] = a[i]; 
	sort(b+1,b+len+1,mycmpp);
	for (int i=1;i<=len;i++)
	  for (int j=i+1;j<=len;j++){
	      if (fabs(b[i].y - b[j].y) > ans) break;
	      ans = min(ans,js(b[i],b[j]));
	  }
	return ans;
}

int main(){
	scanf("%d",&n);
    for (int i=1;i<=n;i++)
      scanf("%lf %lf",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,mycmp);
//    dfs(1,n);
    printf("%.4lf",dfs(1,n));
    return 0;
}
```


---

## 作者：cdcq (赞：0)

这题其实可以kdtree做  
但是数据结构太无脑了！  
这个时候当然是选择优美的分治啦~  
因为这道题不是曼哈顿距离，而且点的坐标也不是整数，所以不能再用三维偏序那一套理论  
想这个题的时候把思维从cdq分治里边拉出来还是费了一番功夫  
因为这题我没有自己想出来，所以不再做思路引导，直接说明做法和正确性 
首先是做法  
直接看做法不容易理解，建议结合正确性证明观看  
开始分治前先以横坐标为第一优先级排序  
这道题使用的是后序分治，先递归分治两边的区间，获得两边区间里的最优值d  
（两个区间显然要对半分  
然后将右边区间中所有满足横坐标和中点横坐标之差小于d的点全部按下标递增的顺序收录到一个队列里  
现在按下标递增的顺序扫描左边的点，每遇到一个满足横坐标和中点横坐标之差小于d的点，首先从队尾逐渐将不满足纵坐标和当前点纵坐标之差小于d的点出队，再从队尾向后扫描所有点，直到到达队头或队中点的纵坐标和当前点之差大于d  
对于每一个扫描到的队中的点，计算和当前点的距离并更新答案  
最后以归并排序的形式把当前区间以纵坐标为第一优先级排序  
现在说明正确性  
开始对横坐标的排序只是快速取到区间中间点的横坐标以确保复杂度  
两边递归后的操作实际上是对于每个横坐标和中线距离差小于d的点，把以这个点为左边中点的正方形中的所有点拿出来，并统计答案  
因为如果两个点的横坐标差大于d，显然一定不会是最优解，纵坐标同理  
d是递归得到的，可以放心交给递归而不用管它  
最后的归并排序保证区间合并后y是单调的，这样就可以通过队列的方式快速选出正方形中的点  
现在证明复杂度  
由鸽巢原理易得正方形中的点不会超过6个  
（想象一下往一个边长为2d的正方形里塞半径是d的球，塞不了几个  
那么每个左边的点统计答案的时间是一个很小的常数，可以忽略  
对于队列操作，每个点最多进一次队，出一次队，复杂度为$ O(n) $  
归并排序也是$ O(n) $  
那么令$ T(n) $为算法复杂度，满足$ T(n)=2T(\frac{n}{2})+O(n) $  
由主定理可得最终复杂度为$ \Theta (nlogn) $   
（题解写的有点奇怪，还是需要理解清楚，思路再从头考虑一个  
这个做法的核心，就是应用了两边分治完后y单调的性质，以及想到在中线两边横坐标距离小于d的范围内选点这样一个结论  
d也是两边分治的到的，所以分治时注意分治得到的性质真的是很重要呢~  
有一些注意事项  
注意边界（r=l+1）的时候不要忘了处理y的顺序  
区间中点是会变的（两边递归的时候对y进行了排序），所以要先记录一下中点横坐标  
代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const double oo=1e9;
int rd(){int z=0,mk=1;  char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')mk=-1;  ch=getchar();}
	while(ch>='0'&&ch<='9'){z=(z<<3)+(z<<1)+ch-'0';  ch=getchar();}
	return z*mk;
}
struct nds{double x,y;}a[210000];
inline double sqr(double x){  return x*x;}
inline double dstc(nds x,nds y){  return sqrt(sqr(x.x-y.x)+sqr(x.y-y.y));}
int n;
nds q[210000];  int hd=0,tl=1;
int bnrsch(double x,int l,int r){
	int md;
	while(l+1<r)  md=(l+r)>>1,(q[md].y>x ? l : r)=md;
	return q[l].y>x ? l : r;
}
double dac(int l,int r){
	if(l==r)  return oo;
	if(r==l+1){
		if(a[l].y>a[r].y)  swap(a[l],a[r]);
		//注意边界的时候处理y的排序
		return dstc(a[l],a[r]);
	}
	int md=(l+r)>>1;
	double mdx=a[md].x;
	//注意a[md]会变！！！！！！
	double d=min(dac(l,md),dac(md+1,r));
	double bwl=d;
	hd=0,tl=1;
	for(int i=md+1;i<=r;++i)
		//if(abs(a[i].x-a[md].x)<d)
		if(abs(a[i].x-mdx)<d)
			q[++hd]=a[i];
	for(int i=l;i<=md;++i)
		if(abs(a[i].x-mdx)<d){
			while(tl<=hd && a[i].y-q[tl].y>d)  ++tl;
			for(int j=tl;j<=hd && abs(a[i].y-q[j].y)<d;++j)
				bwl=min(bwl,dstc(a[i],q[j]));
		}
	int hd1=l,hd2=md+1;
	for(int i=l;i<=r;++i){
		if(hd2<=r && (hd1>md || a[hd2].y<a[hd1].y))  q[i]=a[hd2++];
		//注意不要忘了hd2<=r
		else  q[i]=a[hd1++];
	}
	for(int i=l;i<=r;++i)  a[i]=q[i];
	return bwl;
}
bool cmp(nds x,nds y){  return x.x==y.x ? x.y<y.y : x.x<y.x;}
//给初始数组的所有维度都排个序是好习惯
int main(){//freopen("ddd.in","r",stdin);  freopen("ddd.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;++i)  scanf("%lf %lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);
	printf("%.4lf\n",dac(1,n));
	return 0;
}
```

---


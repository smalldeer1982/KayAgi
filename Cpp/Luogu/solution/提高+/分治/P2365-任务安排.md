# 任务安排

## 题目描述

$n$ 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。  

从零时刻开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间为 $t_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。  

每个任务的费用是它的完成时刻乘以一个费用系数 $f_i$。请确定一个分组方案，使得总费用最小。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 5000$，$0 \le s \le 50$，$1\le t_i,f_i \le 100$。

【样例解释】   
如果分组方案是 $\{1,2\},\{3\},\{4,5\}$，则完成时间分别为 $\{5,5,10,14,14\}$，费用 $C=15+10+30+42+56$，总费用就是 $153$。

## 样例 #1

### 输入

```
5
1
1 3
3 2
4 3
2 3
1 4```

### 输出

```
153```

# 题解

## 作者：ButterflyDew (赞：135)

其他题解里面的斜率优化讲的对新手不友好，我详细说一下吧

[欢迎到博客食用喵~](https://www.cnblogs.com/ppprseter/p/9319788.html)

先考虑$O(N^2)$的做法

因为分的批数是不定的，所有我们为了避免算后面的时候要用到前面分了多少批这个状态，我们采用**费用提前**的思想，在处理前面时把$S$产生的费用给计算了。

方程:$f[i]$代表前$i$个任务分成若干批产生的最小费用

转移:$f[i]=min_{i=0}^{i-1}(f[j]+t[i]*(c[i]-c[j])+S*(c[n]-c[j]))$
其中,$t,c$分别是任务时间和费用的前缀和的数组

考虑将状态转移方程化简：
$f[j]=(S+t[i])*c[j]+f[i]-t[i]*c[i]-S*c[n]$
注意：我们这里把$min$去掉了，是把$j$的取值集合所映射的$f[j]$和$c[j]$分别作为函数的$f(x)$和$x$

那么这个一次函数的斜率$k$就等于$(S+t[i])$，而截距$b$等于$f[i]-t[i]*c[i]-S*c[n]$

我们想让这个$f[i]$最小，那么其实就等价于$b$最小，在坐标系中，如果我们拿一个已知斜率的直线向上滑动，当它第一次碰见取值集合内的点$(c[j],f[j])$时，就取到了它的最小值

![](http://m.qpic.cn/psb?/V14VFGnz2yFhuP/mEoGtuSJj5qHvReQwcFCamm4O5jHFH.CSMKpXMVJByY!/b/dDEBAAAAAAAA&bo=ygR*AsoEfwIDGTw!&rf=viewer_4)

![](http://m.qpic.cn/psb?/V14VFGnz2yFhuP/Sg2Pc0y*4a185db7acXaJgAsJK*t0dkTSGfRhSp7VZE!/b/dDABAAAAAAAA&bo=zgQTAs4EEwIDGTw!&rf=viewer_4)

1.考虑什么时候一个点可以取到最小值

通过手玩我们发现（对于这个手玩真的是最好的理解方式了）

对于点$J_2$，当以$x$为关键字排序后的两个相邻的点$J_1$和$J_3$（在此题中对应$c[j]$的单调性）

当斜率$k_1<k_0<k_2$时，此点就是最优转移点

![](http://m.qpic.cn/psb?/V14VFGnz2yFhuP/kqmuzP9S9XnIHL2Hpe77MbUpWPsB*PnQTiN3C9u1UuQ!/b/dGcBAAAAAAAA&bo=*ARTAvwEUwIDCSw!&rf=viewer_4)

2.考虑什么时候一个点**可能**可以取到最小值，什么时候**一定**不能

如下图，当斜率$k_1<k_2$时，$J_2$是有机会的，此时三个点**下凸**

![](http://m.qpic.cn/psb?/V14VFGnz2yFhuP/DxTaNKXYHB*mr9ykGS*IWMYI0QcxpFmJ6LlcB.my.vg!/b/dDMBAAAAAAAA&bo=9gQ9AvYEPQIDGTw!&rf=viewer_4)

当斜率$k_1>=k_2$时，$J_2$不会有一点机会，此时三个点**上凸**

![](http://m.qpic.cn/psb?/V14VFGnz2yFhuP/TIHx1N5Sgba8RwIEKT.VJ7GuWqdpcJSHTLYp3LaFlgQ!/b/dFYBAAAAAAAA&bo=3QQzAt0EMwIDGTw!&rf=viewer_4)

此时我们就可以用单调队列维护一个点集了，其中相邻点的斜率$k$必定是递增的

当需要做出决策的时候，我们二分这个点集，找到最优转移点。


针对于此题，我们发现每个决策点的斜率$S+t[i]$是单调递增的，那么我们可以直接维护队首，保证每次从队首转移。即当当前斜率大于队首与第二个点之间的斜率时，就出队。

统计完答案后再用二元组$(f[i],c[i])$更新队尾的元素，然后将它放进去

**Code：**
```cpp
#include <cstdio>
#include <cstring>
const int N=5010;
int f[N],t[N],c[N],n,S,q[N],l,r;
int main()
{
    scanf("%d%d",&n,&S);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",t+i,c+i);
        t[i]+=t[i-1];
        c[i]+=c[i-1];
    }
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    l=1,r=1;//注意此时已经把0作为元素放入了q[1]中去了
    for(int i=1;i<=n;i++)
    {
        while(l<r&&f[q[l+1]]-f[q[l]]<=(S+t[i])*(c[q[l+1]]-c[q[l]])) l++;
        f[i]=f[q[l]]+t[i]*c[i]+S*c[n]-c[q[l]]*(S+t[i]);
        while(l<r&&(f[i]-f[q[r]])*(c[q[r]]-c[q[r-1]])<=(f[q[r]]-f[q[r-1]])*(c[i]-c[q[r]])) r--;
        q[++r]=i;
    }
    printf("%d\n",f[n]);
    return 0;
}

```

---

## 作者：AFOier (赞：128)

看很多题解里面$O(n^2)$的dp状态都讲得不怎么清楚，我就再详细地讲解一下吧

我们定义：$dp[i][j]$为把前$i$个任务分成$j$组，所需要的最小费用

显然对于每一个i，都有两种情况：

**1.将i与i-1划分在同一组内**

**2.将i独立设为一组**

先看**第一种情况**：

此时第j个分组的左端点未知，所以我们可以枚举左端点

令第j个任务分组区间为$[l,i]$，则有：

$dp[i][j]=dp[l-1][j-1]+($第$j$个任务分组所需费用$)$

那么第j个任务分组所需费用怎么求呢？

因为此时为第j个任务分组，所以一定有j个启动时间(s)，此时完成第j个任务分组的时间节点为$j*s+sumt[i]$（这里$sumt[i]$为$t[1]+t[2]+…+t[i]$）,即前i个任务所需的总时间+j个准备时间

所以第j个任务所需费用为

$(j*s+sumt[i])*(sumf[i]-sumf[l-1])$

（$sumf[i]-sumf[l-1]$为区间$[l,i]$的费用系数和）

再来看**第二种情况**：

此时显而易见第j个任务分组区间为$[i,i]$，做法同上，只不过将上面的l换成了i，所以第j个任务所需费用为：

$(j*s+sumt[i])*(sumf[i]-sumf[i-1])$

两种情况的状态转移非常相似，所以对于第二种情况，我们只需设置l的上界为i即可完成转移。

故总的转移为：

$dp[i][j]=dp[l-1][j-1]+(j*s+sumt[i])*(sumf[i]-sumf[l-1])$$(1<=l<=i)$

代码如下：
```
#include <cstdio>
#include <cstring>
#include <iostream>
#define ll long long
using namespace std;
const int N=5011;
const int inf=0x7fffffff;
int n,s,t[N],f[N],sumt[N],sumf[N];//因为f[i],t[i]<=100,所以前缀和只需用int类型存储即可 
ll dp[N][N],ans;
int main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&t[i],&f[i]);
		sumt[i]=sumt[i-1]+t[i];
		sumf[i]=sumf[i-1]+f[i];
	}
	memset(dp,127,sizeof(dp));//赋最大值
	dp[0][0]=0; //初始化 
	ans=inf; 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int l=1;l<=i;l++){
				dp[i][j]=min(dp[i][j],dp[l-1][j-1]+(j*s+sumt[i])*(sumf[i]-sumf[l-1]));
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans=min(ans,dp[n][i]);
	}//取最大值 
	printf("%lld\n",ans);
	return 0;
} 
```

时间复杂度$O(n^3)$,因为卡空间，所以期望得分0pts

把N改成可以过$O(n^3)$的400，期望得分50pts

我们考虑优化。

因为这题不限分成多少个组，所以j其实是多余的

我们回顾上面的状态转移方程，可以发现j在其中的作用仅仅是计算要加多少个启动时间而已。所以我们要想办法不通过j而计算出启动时间。

很抱歉，做不到。但是很显然，每多一个任务分组，后续任务的结束时间必定会延迟s秒。这会造成后续的费用多出$(sumf[n]-sumf[l-1])*s$,我们可以将其提前加在dp[i]里

所以，最终$dp[i]$表示（前i个任务分成若干组后的费用+分成若干组后多出的后续费用）的最小值

状态转移式为：

$dp[i]=min(dp[i],dp[l-1]+sumt[i]*(sumf[i]-sumf[l-1])+s*(sumf[n]-sumf[l-1]))(1<=l<=i)$

（[1,l-1]分为若干组的最小费用+[1,l-1]多出的后续费用+不算s的这个任务分组的费用+[l,i]多出的后续费用）

代码：
```
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
int n,s,t[5001],f[5001];
int sumt[5001],sumf[5001];
long long dp[5001];
int main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&t[i],&f[i]);
		sumt[i]=sumt[i-1]+t[i];
		sumf[i]=sumf[i-1]+f[i];
	}
	memset(dp,127,sizeof(dp));
	dp[0]=0;
	for(int i=1;i<=n;i++){
		for(int l=1;l<=i;l++){
			dp[i]=min(dp[i],dp[l-1]+sumt[i]*(sumf[i]-sumf[l-1])+s*(sumf[n]-sumf[l-1]));
		}//前i个的最后一组为l~i 
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

时间复杂度$O(n^2)$,期望得分100pts

---

## 作者：_ztyqwq (赞：28)

首先，这是一个DP。

（似乎是个叫分组DP的东西）

显然的状态定义：用 $ dp_i $ 表示前 $ i $ 个任务都被完成，所需的时间最小值。（因为 $ f $ 用过了，只好用 $ dp $ 了qwq）

显然的转移方程：

$ dp_i = \min\limits_{1 \leqslant j \leqslant i}{dp_{j-1} + \sum\limits_{k = j}^i{tim \times f_k}} $

$ = \min\limits_{1 \leqslant j \leqslant i}{dp_{j-1} + tim \times \sum\limits_{k = j}^i{f_k}} $

$ j $ 表示最后一组是从 $ j $ 到 $ i $ 的任务，$ tim $ 是这批任务的完成时间。

后面的 $ \sum\limits_{k = j}^i{f_k} $ 显然可以用前缀和维护。但是变量 $ tim $ 的出现似乎给算法带来了后效性，因为它与之前分过的组数有关。更确切地说，

$ tim = \sum\limits_{k = 1}^i{t_k} + num \times S $

其中 $ num $ 是之前已经分过的组数。同样地，$ \sum\limits_{k = 1}^i{t_k} $ 可以用前缀和维护。而对于 $ num $，如果再开一维 $ dp $ 数组维护（枚举），开销将会很大。

如何解决？

注意到每在 $ j $ 到 $ i $ 之间分一组，那么对于之后所有的 $ k $，其计算时的 $ num $ 都会加上 $ 1 $。对于 $ tim $ 而言就是加上 $ S $。抛开转移方程讲，就是 **这一组** 以及后续所有任务的完成时间都要加上 $ S $。那么对于每个任务 $ k $，它所需要的费用会加上 $ S \times f_k $，后面的所有任务总共就会加上 $ \sum\limits_{k = j}^n{S \times f_k} $

$ = S \times \sum\limits_{k = j}^n{f_k} $

$ \sum\limits_{k = j}^n{f_k} $ 可以用前缀和维护！也就是说，所有这些额外消费的代价在计算 $ f_i $ 时都已经是已知的了。

那么为什么不把这些费用提在计算 $ f_i $ 时就计算呢？

于是我们得出了新的转移方程：

$ f_i = \min\limits_{1 \leqslant j \leqslant i}{dp_{j-1} + \sum\limits_{k = 1}^i{t_k} \times \sum\limits_{k = j}^i{f_k}} + \sum\limits_{k = j}^n{f_k} \times S $

这时计算当前段代价时，$ tim $ 不用再加上机器的启动时间，因为这些时间造成的代价都已经在之前的 $ i $ 中计算过了。而这一次启动对后面的任务所产生的额外代价，则是 $ \sum\limits_{k = j}^n{f_k} \times S $。

注意到方程中所有的 $ \sum $ 都是可以用前缀和维护的。

所以这个转移方程就是 $ O(n) $ 的。共有 $ O(n) $ 个状态。总时间复杂度为 $ O(n^2) $，空间复杂度为 $ O(n) $，已经足以通过此题了。

（似乎还有更快的做法？布吉岛还是要%%%大佬们）

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[5001],f[5001],st[5001],sf[5001],dp[5001];
int main()
{
    int n,s;
    scanf("%d %d",&n,&s);
    for(int i=1;i<=n;i++)
    {
        scanf("%d %d",&t[i],&f[i]);
        st[i]=st[i-1]+t[i];
        sf[i]=sf[i-1]+f[i];
    }
    memset(dp,0x7f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            dp[i]=min(dp[i],dp[j-1]+st[i]*(sf[i]-sf[j-1])+s*(sf[n]-sf[j-1]));
    printf("%d\n",dp[n]);
    return 0;
}
```

---

## 作者：Timothy (赞：28)

【题目大意】

N个任务排成一个序列在一台机器上等待完成（顺序不得改变）。从时刻0开始，这些任务被分批加工，第i 个任务单独完成所需的时间是Ti。在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。每个任务的费用是它的完成时刻乘以一个费用系数Fi。请确定一个分组方案，使得总费用最小。

【算法讨论】

这道题采用动态规划的思想，用f[i]表示完成前i个任务所需的最小费用，用tim[i]表示前i项任务所需的时间，用mon[i]表示前i项任务一共的费用系数。动归式如下：

f[i]=min{f[j-1]+s\*(mon[n]-mon[j-1])+

tim[i]\*(mon[i]-mon[j-1])|1<=j<=i};

如果在完成第j项任务是启动一次机器，后面的所有任务完成的时刻都要加上s，所以每启动一次机器的费用为s\*(mon[n]-mon[j-1])；

如果把第j项任务和第i项任务和在一起做，则它们的完成时刻为tim[i]，所以费用为tim[i]\*(mon[i]-mon[j-1])。

得分：100

时间复杂度：O(N^2)

空间复杂度：O(5\*N)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int f[5001],g[5001];
int len,wei,n,tim[5001],mon[5001],ti[5001],s;
int main ()
{
    scanf ("%d%d",&n,&s);
    for (int b=1;b<=n;++b)
    {
        scanf("%d%d",&tim[b],&mon[b]);
        tim[b]+=tim[b-1];
        mon[b]+=mon[b-1];
        f[b]=2147483647;
    }
    for (int i=1;i<=n;++i)
        for (int j=1;j<=i;++j)
            f[i]=min(f[i],f[j-1]+s*(mon[n]-mon[j-1])+tim[i]*(mon[i]-mon[j-1]));
    printf ("%d",f[n]);
    return 0;
}

```

---

## 作者：Belarus (赞：22)

### 题外话
今天开始学斜率优化了，以前看过但是看不懂被劝退了。省选马上要到了，还是得逼着自己学下去，要不然只能爆零了。   
[配合博客食用](https://charley-xiao.github.io/2020/02/27/ConvexHull/)

### 题目描述   
$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。
从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$	 。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。
每个任务的费用是它的完成时刻乘以一个费用系数$f_i$	 。请确定一个分组方案，使得总费用最小。  
 
### 初步分析  
首先这个题我读了好几遍才读懂......  
你可能会问：不分批不是最好的吗，因为这样就只有一次机器启动时间啊。但是你忽略了一个问题，**每个任务的完成时间规定为他所在批次的最后一个任务完成的时间**，所以分一批不一定最优。  
解决了这个问题之后，动态规划转移方程可以尝试写出来。  
维护前缀和数组$sumt[\ ]$和$sumf[\ ]$，分别表示$t[\ ]$和$f[\ ]$的前缀和。  
设$dp[i,j]$表示**把前$i$个任务分成$j$批**的最小费用。  
那么很明显，第$j$批任务的完成时间就是第$j$批中最后一个任务（即$i$）在不分批情况下结束的时间（即$sumt[i]$）加上前面任务需要的开机时间（即$s\times j$）。  
于是经典套路：  
$$dp[i,j]=\min\limits_{0\leq k< i}\{dp[k,j-1]+(s\times j+sumt[i])\times(sumf[i]-sumf[k])\}$$  

但是这个算法的时间复杂度为$\mathcal O(n^3)$，需要优化。  

### 费用提前计算优化  
根据以往的做题经验，我们尝试把二维化成一维，即让$dp[i]$表示前$i$个任务分批执行的最小费用。  
但是这样我们就不知道机器启动过几次了！  
别慌，冷静分析一下你会发现，如果我们要从$dp[j]$转移到$dp[i]$的话，由于第$j+1\sim i$都是在同一批内完成的，我们只需要把$s$对$j+1$后的影响补充到费用中就可以了！  
$$dp[i]=\min\limits_{0\leq k<i}\{dp[j]+sumt[i]\times(sumf[i]-sumf[j])+s\times (sumf[n]-sumf[j])\}$$  
时间复杂度$\mathcal O(n^2)$  
这就是**费用提前计算**的思想。  

### 斜率优化分析  
他来了。  
我们观察费用提前计算优化的式子：  
$$dp[i]=\min\limits_{0\leq k<i}\{dp[j]+sumt[i]\times(sumf[i]-sumf[j])+s\times (sumf[n]-sumf[j])\}$$  
有三个变量：$j,dp[j],dp[i]$。  
我们把$\min$去掉，化简一下得到：  
$$dp[j]=(s+sumt[i])\times sumf[j]+dp[i]-sumt[i]\times sumf[i]-s\times sumf[n]$$  
这是个$dp[j]$关于$sumf[j]$一次函数，还带有其他变量。  
那么斜率就是$(s+sumt[i])$，截距是$dp[i]-sumt[i]\times sumf[i]-s\times sumf[n]$。  
我们最终的目的是找到$f[i]$的最小值，其实就是找截距的最小值。  
**接下来是重头戏！请一定要和我一起在纸上模拟！**  
我们在坐标系内画出$f[j]$与$sumf[j]$的散点图，用一条斜率为固定正整数的直线自下而上进行平移，第一次接触到一个点的时候就得到了最小截距。  
现在我们就需要考虑，对于$j_1<j_2<j_3$，使$j_2$成为最优决策的条件。  
我们发现$j_2$在$j_1,j_3$之间，无非就是两个位置：在$j_1,j_3$两点连线上方和下方。  
如果将$j_1j_2,j_2j_3$连起来，形象地我们称第一种情况为**上凸**，第二种情况为**下凸**。  
**如果是上凸的话，我们发现，$j_2$永远不可能成为最优决策，因为要么先碰到$j_1$，要么先碰到$j_3$，永远碰不到$j_2$。  
如果是下凸的话，$j_2$就有可能成为最优决策。**  
我们知道对于$f(x)$，连接$(x_1,f(x_1))$和$(x_2,f(x_2))$直线的斜率就是$\frac{f(x_2)-f(x_1)}{x_2-x_1}$，俗称“纵减纵除以横减横”。  
所以$j_2$有可能成为最优决策的条件就是：  
$$\frac{dp[j_2]-dp[j_1]}{sumf[j_2]-sumf[j_1]}<\frac{dp[j_3]-dp[j_2]}{sumf[j_3]-sumf[j_2]}$$  
也就是说**我们要维护一个斜率单调递增的下凸壳**。  
由于$0\leq j<i$，当$i$增加时，就会有新的决策，**如果我们只保留连接相邻两点斜率大于$s+sumt[i]$的部分，那么最左端的就是最优决策。**  

### 斜率优化具体操作  
建立一个单调队列$q$。  
对于每个状态变量$i$：  
1. 检查队头$q[l]$与$q[l+1]$，如果$\frac{dp[q[l+1]]-dp[q[l]]}{sumf[q[l+1]]-sumf[q[l]]}\leq s+sumt[i]$，将$q[l]$出队，继续检查新队头。  
2. 取队头$j=q[l]$为最优决策，计算$dp[i]$。  
3. 把$i$插入队尾，在插入之前，若决策点$j_1=q[r-1],j_2=q[r],j_3=i$不满足斜率单调递增，则把$q[r]$出队，继续检查新队尾。  

这样时间复杂度就变成了$\mathcal O(n)$。  

### 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int size=1e6+9;
int n,s;
int sumt[size],sumf[size],dp[size];
int l=1,r=1,q[size];
int main(){
	ios::sync_with_stdio(0);
	memset(dp,0x3f,sizeof(dp));
	cin>>n>>s;
	for(int i=1;i<=n;++i){
		int t,f;
		cin>>t>>f;
		sumt[i]=sumt[i-1]+t;
		sumf[i]=sumf[i-1]+f;
	}
	dp[0]=q[1]=0;
	for(int i=1;i<=n;++i){
		while(l<r&&dp[q[l+1]]-dp[q[l]]<=(s+sumt[i])*(sumf[q[l+1]]-sumf[q[l]])) l++;
		dp[i]=dp[q[l]]-(s+sumt[i])*sumf[q[l]]+sumt[i]*sumf[i]+s*sumf[n];
		while(l<r&&(dp[q[r]]-dp[q[r-1]])*(sumf[i]-sumf[q[r]])>=(dp[i]-dp[q[r]])*(sumf[q[r]]-sumf[q[r-1]])) r--;
		q[++r]=i;
	}
	cout<<dp[n]<<endl;
	return 0;
}
```


---

## 作者：yujiaqi (赞：17)

O(N^2)的方法非常简单，这里不再细讲。f[i]表示前i个任务分成若

干批执行的最小费用，sumC,sumT是费用系数和时间的前缀和。

可得状态转移方程

f[i]=min(f[j]+sumC[i]\*sumT[i]+s\*sumC[n]-sumC[j]\*(sumT[i]+s)); 

过掉这道题已是轻轻松松。
附上代码:
```cpp
#include<bits/stdc++.h>
#define N 5005
#define oo 1000000000
using namespace std;
int sumc[N],sumt[N];
long long f[N];
int main(){
    int n,s,t,c;
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n;++i){
        scanf("%d%d",&t,&c);
        sumt[i]=sumt[i-1]+t;
        sumc[i]=sumc[i-1]+c;
    }
    for (int i=1;i<=n;++i)
        f[i]=oo;
    for (int i=1;i<=n;++i)
    for (int j=0;j<=i-1;++j)
        f[i]=min(f[i],f[j]+sumc[i]*sumt[i]+s*sumc[n]-sumc[j]*(sumt[i]+s));
    printf("%d",f[n]);
    return 0;
}
```

------------
下面就来看一看如何进一步优化。 

我们会发现后面的状态肯定是由前面的最优状态转移而来的，显

然可以想到单调队列优化。但和平常的单调队列优化不同的是，

f[i]的转移中除了f[j],还有其他的关于j的式子(例如sumc[j]),这时候

就要用到单调队列的斜率优化。

在原状态转移方程中，我们把只跟j有关的分成一类，把既跟i有

关，又跟j有关的分成一类，把跟j无关的分成一类。化简后可得

下式:  

f[i]=f[j]-(sumT[i]+s)\*sumC[j]+(sumC[i]\*sumT[i]+s\*sumC[n]);

设y=f[j], k=sumT[i]+s, x=sumC[j],   C=sumC[i]\*sumT[i]+s\*sumC[n]  

那么原式可化为f[i]=y-kx+C  

最终可得y=kx+f[i]-C  

当我们枚举i的时候,k和C是常数  

那么上式是不是很像y关于x的一次函数呢      

当k一定时，要使f[i]最小，即截距最小，那么何时取到这个最小值呢。

我们将直线y=kx+b(Ps:b为未知数)从下往上平移，当该直线第

一次碰到某点(x(w),y(w))时，该点即为最优状态(1<=w<=i-1)

即K(w-1,w)<K(w,w+1)(K(x,y)表示直线xy的斜率)

如图

![](https://cdn.luogu.com.cn/upload/pic/25314.png )
        
        同理可知，若K(w-1,w)>K(w,w+1),w一定不可能成为最优状态，如图
![](https://cdn.luogu.com.cn/upload/pic/25315.png )
又因为x单调递增，所以w也不可能在今后成为最优状态，直接舍去。这样是不是就做到了优化呢。

回到代码实现，我们可以用一个单调队列来维护这个“下凸壳”

1、维护K(j,i)(0<=j<i)的单调递增（队尾维护）

2、保证K(j,i)>k,即可以取到这个最优状态（队首维护）

此时，对于每个i，可以从队首的最优状态直接转移

由于每个元素只进队列一次，只出队列一次，因而时间复杂度为O（N）

到这里，这个所谓的斜率优化就结束了，附上代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 300005
#define oo 1000000000
using namespace std;
int sumT[MAXN],sumC[MAXN],que[MAXN];
long long f[MAXN];
int cmp1(int x1,int x2,int x3){
    return (f[x2]-f[x1])*(sumC[x3]-sumC[x2])>=(f[x3]-f[x2])*(sumC[x2]-sumC[x1]);
}
int cmp2(int x1,int x2,int k){
    return f[x2]-f[x1]<=k*(sumC[x2]-sumC[x1]);
}
int main(){
    int n,s,t,c;
    scanf("%d",&n);
    scanf("%d",&s);
    for (int i=1;i<=n;++i){
        scanf("%d%d",&t,&c);
        sumT[i]=sumT[i-1]+t;
        sumC[i]=sumC[i-1]+c;
    }
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    int head=1,tail=1;
    que[1]=0;
    for (int i=1;i<=n;++i){
        while ( (head<tail) && (cmp2(que[head],que[head+1],sumT[i]+s)) ) ++head;
        f[i]=f[que[head]]+(long long)sumC[i]*sumT[i]+s*sumC[n]-sumC[que[head]]*(sumT[i]+s);
        while ( (head<tail) && (cmp1(que[tail-1],que[tail],i)) ) --tail;
        que[++tail]=i;
    }
    printf("%lld",f[n]);
    return 0;
}
```
这里有一个小细节需要注意，在计算斜率的时候，最好用交叉相

乘的方法，不然可能会出现一些小偏差，相乘的结果是否要用

(long long)最好也关注下


------------

这是本蒟蒻第一次写blog，如有不足之处请见谅。


---

## 作者：__Iron (赞：6)

# 对于DP新手的题解
------------

~~**据说此题要用到斜率优化，但我不会。逃~**~~

~~**不用斜率优化能做？**~~

**数据 N<=5000**

**考虑O(n ^ 2)  dp**

### **NO.1**
  
 **考虑正向枚举**
  
   分析完题目可知，同一批任务是在同一时刻完成的。
   
   所以，我们可以求出费用系数Fi的前缀和，用 一批任务完成的时刻*此段的费用系数 即为此段的费用。
   
   
   设dp[i] 为完成前i个单个任务最小费用，枚举上一个断点的位置j
   
   转移：
   
   ```cpp
for(register int i=1;i<=n;i++)
	 for(register int j=0;j<i;j++){
	  dp[i]=min(dp[i],dp[j]+(sumt[i]+s)*(sumf[i]-sumf[j]));
	 } 
```
   不难发现，前i个任务分成几段的启用时间具有后效性。
   
   正向处理后效性的方法参照其余O（n^2）题解就好了
 
###  **NO.2**
   
   这里介绍另一种方法
   
   **~~正向枚举后效性不会处理，怎么办？？~~**
   
   既然具有后效性，不妨考虑**倒着枚举。**
   
   **倒着Dp，后效性就可以处理了**
   
   同样，我们求出费用系数Fi的后缀和，时间的后缀和。
   
   设dp[i] 为完成后i个单个任务的最小费用，枚举断点
   
   转移：
   
   ```cpp
for(register int i=n;i>=1;i--)
	 for(register int j=i+1;j<=n+1;j++){
	 	int cost=sumf[i]*(s+sumt[i]-sumt[j]);
	 	dp[i]=min(dp[i],dp[j]+cost);
	 } 
```
   
   cost是由完成此段任务的费用和(sumf[i]-sumf[j])*(s+sumt[i]-sumt[j])，和此段任务对后面产生的影响的费用和（sumf[j]）*(s+sumt[i]-sumt[j])的总和
   
   即 **cost=sumf[i]*(s+sumt[i]-sumt[j])**;
   
   正确性：
   
   由于前面几段都还未完成，所以此段为第一段，则费用系数为(sumf[i]-sumf[j])，时间为启动时间+完成这段任务的时间总和 即(s+sumt[i]-sumt[j])。
   
   由于此段选了，此段的完成时间会对已完成的任务产生贡献，贡献值为（sumf[j]）*(s+sumt[i]-sumt[j]).
   
   Code:
   
   ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm> 
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while('0'<=ch&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
const int N=5100;
int n,s,t[N],f[N],sumf[N],dp[N],sumt[N];
int main(){
	n=read();s=read();
	for(register int i=1;i<=n;i++)
	 t[i]=read(),f[i]=read();
	for(register int i=n;i>=1;i--)
	 sumt[i]=sumt[i+1]+t[i],
	 sumf[i]=sumf[i+1]+f[i];
	memset(dp,0x7f7f7f,sizeof(dp));
	dp[n+1]=0;
	for(register int i=n;i>=1;i--)
	 for(register int j=i+1;j<=n+1;j++){
	 	int cost=sumf[i]*(s+sumt[i]-sumt[j]);
	 	dp[i]=min(dp[i],dp[j]+cost);
	 } 
	cout<<dp[1]; 
	return 0;
}
```

   
  


---

## 作者：米奇 (赞：5)

# 算法:斜率优化动态规划

由于题解里没有关于$t[i]<0$的斜率优化做法,我打算写一下这种**特殊**的斜率优化动态规划

由于$t[i]$可以**小于零**,所以斜率$s+sumt[i]$**不具有单调性**,所以我们不能像原来一样维护下凸壳。我们不能只保留相邻两点斜率大于$s+sumt[i]$的部分,我们要把**整个**下凸壳都保留下来。这时队首也就不是最优解了，要**二分**找到一个左边比$s+sumt[i]$小,右边比$s+sumt[i]$大的位置。这个位置就是答案
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=500005;
int l,r,n,s,t,c,j,sumt[N],sumc[N],f[N],q[N];
int find(int k)//二分查找左边比$s+sumt[i]$小,右边比$s+sumt[i]$大的位置
{
	if(l==r)return q[l];
	int L=l,R=r;
	while(L<R)
	{
		int mid=(L+R)/2;
		if(f[q[mid+1]]-f[q[mid]]<=k*(sumc[q[mid+1]]-sumc[q[mid]]))L=mid+1;
		else R=mid;
	}
	return q[L];
}
signed main()
{
	scanf("%lld%lld",&n,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&t,&c);
		sumt[i]=sumt[i-1]+t;
		sumc[i]=sumc[i-1]+c;
	}
	l=r=1;q[1]=0;
	for(int i=1;i<=n;i++)
	{
		int j=find(s+sumt[i]);//二分查找答案
		f[i]=f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[j]);
		while(l<r&&(f[q[r]]-f[q[r-1]])*(sumc[i]-sumc[q[r]])>=
		(f[i]-f[q[r]])*(sumc[q[r]]-sumc[q[r-1]]))r--;//如果不构成下凸壳,就删除队尾
		q[++r]=i;
	}
	cout<<f[n]<<endl;
}
```

---

## 作者：Porsche (赞：4)

## AC此题三步走

------------

### 第一步
考虑最基础的DP

先求出时间  _T_  的前缀和 _ts_ 和费用系数 _C_ 的前缀和 _fs_ 。

设 _dp[i][j]_ 表示把当前 _i_ 个任务分成 _j_ 批执行的最小费用，则第 _j_ 批任务完成的时间就是 _j*S+ts[i]_ 。以第 _j-1_ 批和第 _j_ 批任务的分界点为 _DP_ 的“决策”，状态转移方程为： _dp[i][j]=min(dp[i][j],dp[k][j-1]+(s*j+ts[i])*(fs[i]-fs[k]));_ 
```cpp
#include<bits/stdc++.h>
using namespace std;
int t[5001],f[5001],ts[5001],fs[5001];//t[i]表示当前任务所需的时间T，f[i]表示当前任务的费用系数C，ts[i]和fs[i]分别表示前缀和 
int dp[5001][5001];//dp[i][j]表示第i个点和第i个点以前分成j块的最小化费 
int ans=1<<30;//答案 
int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&t[i],&f[i]);
        ts[i]=ts[i-1]+t[i];
        fs[i]=fs[i-1]+f[i];//前缀和 
    }
    memset(dp,0x3f,sizeof(dp));//设成最大值 
    for(int i=1;i<=n;i++)
        dp[i][1]=(ts[i]+s)*fs[i];//初始化 
    for(int i=2;i<=n;i++)
        for(int j=2;j<=i;j++)
            for(int k=1;k<i;k++)
                dp[i][j]=min(dp[i][j],dp[k][j-1]+(s*j+ts[i])*(fs[i]-fs[k]));//开始无脑DP 
    for(int i=1;i<=n;i++)
        ans=min(ans,dp[n][i]);//注意在所有dp[n][1~n]中取最小值 
    cout<<ans;//输出 
    return 0;
}
```
##### ↑无脑DP
```cpp
// luogu-judger-enable-o2 //洛谷O2 
#include<bits/stdc++.h>
#pragma GCC optimize(2) //手开O2，玄学优化 
using namespace std;
int t[5001],f[5001],ts[5001],fs[5001];
unsigned int dp[5001][5001];//记得使用unsigned int，否则会爆，long long会爆空间，不用挣扎了兄dei~ 
unsigned int ans=1<<30;
int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&t[i],&f[i]);
        ts[i]=ts[i-1]+t[i];
        fs[i]=fs[i-1]+f[i];
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i<=n;i++)
        dp[i][1]=(ts[i]+s)*fs[i];
    for(int i=2;i<=n;i++)
        for(int j=2;j<=i;j++)
            for(int k=1;k<i;k++)
                dp[i][j]=min(dp[i][j],dp[k][j-1]+(s*j+ts[i])*(fs[i]-fs[k]));
    for(int i=1;i<=n;i++)
        ans=min(ans,dp[n][i]);
    printf("%d",ans);
    return 0;
}
```
##### ↑无脑优化之后的无脑DP
#### 时间复杂度O(n³)。
#### 期望得分：60分。
#### 最理想的分（无脑优化）：80分。

------------

### 第二步
忽然发现本体没有规定需要把任务分成多少批（O(∩_∩)O哈哈~），再上一个接发中之所以需要批数 _j_ ,是因为我们需要知道机器启动了多少次，以计算出来每次启动需要的时间 _S_ 的和，从而其算出 _i_ 所在的一批人物的完成时刻。

事实上，在执行一批任务时，我们不容易直接的只在此之前机器启动过多少次。但我们知道，机器因执行这批任务而划分的启动时间 _S_ ，会累加到在此之后所有任务的完成时刻上。

设 _dp[i]_ 表示把前 _i_ 个任务分成若干批执行的最小费用，状态转移方程为： _dp[i]=min(dp[i],dp[j]+ts[i]*(fs[i]-fs[j])+s*(fs[n]-fs[j]));_
```cpp
#include<bits/stdc++.h>
using namespace std;
int ts[5001],fs[5001];
unsigned long long dp[5001];//unsigned long long干脆点 
int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&ts[i],&fs[i]);
        ts[i]+=ts[i-1];
        fs[i]+=fs[i-1];
        dp[i]=1<<30;
    }
    for(int i=1;i<=n;i++)
    	for(int j=0;j<i;j++)
    		dp[i]=min(dp[i],dp[j]+ts[i]*(fs[i]-fs[j])+s*(fs[n]-fs[j]));//状态转移方程 
    printf("%lld",dp[n]);
    return 0;
}
```
##### ↑不用优化也能过
#### 时间复杂度：O(n²)。
#### 期望得分：满分。

------------

### 第三步
大佬：这道题时间复杂度可以O(n)。

蒟蒻的我：不可能，否则我吃……真香……

题目不变，数据_1≤N≤3*10^5,1≤S,Ti,Ci≤512_，什么？

#### 考虑斜率优化
斜率优化什么鬼？

楼下大佬有详解，因为此题不用斜率优化，所以在此本蒟蒻就不做详细解释了QwQ~

贴个代码再跑吧~
```cpp
#include<bits/stdc++.h>
using namespace std;
int ts[5001],fs[5001],que[5001];
unsigned long long dp[5001];
int main()
{
    int n,s;
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&ts[i],&fs[i]);
        ts[i]+=ts[i-1];
        fs[i]+=fs[i-1];
        dp[i]=1<<30;
    }
    int head=1,tail=1;
    for(int i=1;i<=n;i++)
    {
    	while(head<tail&&(dp[que[head+1]]-dp[que[head]])<=(s+ts[i])*(fs[que[head+1]]-fs[que[head]]))head++;
    	dp[i]=dp[que[head]]-(s+ts[i])*fs[que[head]]+ts[i]*fs[i]+s*fs[n];
    	while(head<tail&&(dp[que[tail]]-dp[que[tail-1]])*(fs[i]-fs[que[tail]])>=(dp[i]-dp[que[tail]])*(fs[que[tail]]-fs[que[tail-1]]))tail--;
    	que[++tail]=i;
    }
    printf("%lld",dp[n]);
    return 0;
}
```
#### 时间复杂度O(n)。
#### 期望得分：满分。
感谢各位大（xue）佬（zhang）~

---

## 作者：guoshaoyang (赞：4)

# [P2365 任务安排](https://www.luogu.org/problemnew/show/P2365)
## 算法：dp+斜率优化
**首先，动态规划的状态转移方程不难写出:**
$f[i]=min(f[j]+time[i]*(\sum_{k=j+1}^i{cost[k]})+S*(\sum_{k=j+1}^ncost[k]))$  
**可写作：**$f[i]=min(f[i],f[j]+tim[i]*(cost[i]-cost[j])+S*(cost[N]-cost[j]));$  
**这样的方程是$O(n^2)$的，足以通过此题，代码如下：**
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long LL;
const int MAXN=1024*5,INF=1024*1024*1024;
int N,S,cost[MAXN],tim[MAXN]/**/,f[MAXN];
int main(){
    scanf("%d%d",&N,&S);
    for(int i=1;i<=N;i++){
        scanf("%d%d",&tim[i],&cost[i]);
        tim[i]+=tim[i-1];
        cost[i]+=cost[i-1];
    }
    for(int i=1;i<=N;i++){
        f[i]=INF;
        for(int j=0;j<i;j++){
            f[i]=min(f[i],f[j]+tim[i]*(cost[i]-cost[j])+S*(cost[N]-cost[j]));
        }
    }
    printf("%d",f[N]);
    return 0;
}
```
---
**仔细观察方程，可以发现这道题可以斜率优化**  
设$f[i]$为$f_i$,设$\sum_{k=1}^icost[i]$为$s_i$,$k<j<i$。如果转移j比转移k更优，则
$∴f_j-t_i*(c_i-c_j)+S*(c_n-c_j)<f_k-t_i*(c_i-c_k)+S*(c_n-c_k)$
$∴f_j-t_i*c_i-t_i*c_j+S*c_n-S*c_j<f_k-t_i*c_i-t_i*c_k+S*c_n-S*c_k$
$∴f_j-t_i*c_j-S*c_j<f_k-t_i*c_k-S*c_k$  
$∴f_j-c_j*(t_i+S)<f_k-c_k*(t_i+S)$  
$∴f_j-f_k<(c_j-c_k)*(t_i+S)$  
$∵c_j>c_k$即 $c_j-c_k>0$  
### $∴\displaystyle\frac{f_j-f_k}{c_j-c_k}<t_i+S$即$j$到$k$的斜率小于$t_i+S$
### ∴以$c_i$为横轴，$f_i$为纵轴建立如图所示平面直角坐标系，维护一个下凸壳
![](https://cdn.luogu.com.cn/upload/pic/47722.png)
### step1：淘汰子问题维护队列时，将凸壳左端斜率太小的点删除（用$f=t_i+S$切这个凸壳），最左端点根据上面的证明即为最优子问题
### step2：用原方程转移，得到$i$号点的横纵坐标
### step3：插入$i$号点，维护下凸壳（如图，在插入$i$时，发现$i$的斜率小于$l$，即$l$没前途，直接弹掉）
**具体维护方法见代码：**
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long LL;
const int MAXN=1024*5,INF=1024*1024*1024;
int N,S,cost[MAXN],tim[MAXN],f[MAXN];
int dq[MAXN],L=1,R;
int main() {
    scanf("%d%d",&N,&S);
    for(int i=1; i<=N; i++) {
        scanf("%d%d",&tim[i],&cost[i]);
        tim[i]+=tim[i-1];
        cost[i]+=cost[i-1];
    }
    dq[++R]=0;
    for(int i=1; i<=N; i++) {
        while(L<R&&(f[dq[L+1]]-f[dq[L]])<=(tim[i]+S)*(cost[dq[L+1]]-cost[dq[L]])) {
            L++;
        }
        f[i]=f[dq[L]]-cost[dq[L]]*(tim[i]+S)+tim[i]*cost[i]+S*cost[N];
        while(L<R&&(f[dq[R]]-f[dq[R-1]])*(cost[i]-cost[dq[R]])
                >=(f[i]-f[dq[R]])*(cost[dq[R]]-cost[dq[R-1]])) {
            R--;
        }
        dq[++R]=i;
    }
    printf("%d",f[N]);
    return 0;
}
```

---

## 作者：谁是鸽王 (赞：1)

## 【学习笔记】斜率优化

加强版 [[SDOI2012\]任务安排](https://lydsy.com/JudgeOnline/problem.php?id=2726)

斜率优化入门题：

设$f(x)$为$F(x)$的**后**缀和，$t(x)$为$T(x)$的前缀和。$dp(i)$表示完成到第$i$任务的最小代价，转移：

$dp(i)=\min \{dp(j) +f(j+1)\times(S+t(i)-t(j)) \}$

拆掉：

- 和$j$无关: 没有
- 只和$j$相关:$dp(j)+f(j+1)\times(S-t(j))$ 
- 和$i,j$相关:$f(j+1)\times t(i)$ 

我们发现只和$j$相关的可以直接预处理，现在的问题是确定了$i$如何快速找到一个$j$

令$y_j=dp(j)+f(j+1)\times(S-t(j))$，$x_j=f(j+1)$，原式可以写成：
$$
dp(i)= y_j+x_jt(i)
$$


转换一下式子
$$
y_j=-t(i)x_j+dp(i)
$$


现在问题就变成了确定了一个$i$，要快速查询前面的一个$j$使得$dp(i)$最小

把这个东西看成一条直线，就变成了我有一条在平面上平移的斜率为$-t(i)$的直线，现在要找一个点$(x_j,y_j)$使得**过这个点**的斜率为$-t(i)$的直线的**截距**尽量小。

![斜率优化](https://cdn.luogu.com.cn/upload/pic/60540.png)

> 蓝线:斜率为$-t(i)$的线
>
> 紫点:$(x_j,y_j)$ 

很明显，可以看做有一条在$y$负半轴无限远处有一条直线慢慢上移(截距慢慢变大)，这条直线突然经过一个我们集合内的点时，它此时的截距就是最小的截距。很显然，这个点一定在凸包上面，而且这个点左右两边的斜率一定是左边更小，右边更大(斜率是负数)。

动态维护一下凸包就好了。

```cpp
//@winlere
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;  typedef long long ll;
inline int qr(){
      register int ret=0,f=0;
      register char c=getchar();
      while(c<48||c>57)f|=c==45,c=getchar();
      while(c>=48&&c<=57) ret=ret*10+c-48,c=getchar();
      return f?-ret:ret;
}
int n,s;
const int maxn=3e5+5;
int Ti[maxn],Fi[maxn];
ll st[maxn],sf[maxn];
ll x[maxn],y[maxn],q[maxn],dp[maxn];
int cnt;

inline ll getval(const int&i,const int&j){
      return dp[j]+sf[j+1]*(s+st[i]-st[j]);
}

inline bool chek0(const int&i,const int&j,const ll&k){
      return (long double)1.0*((y[i]+dp[i])-(y[j]+dp[j]))*(x[i]-x[k])<=(long double)1.0*((y[i]+dp[i])-(y[k]+dp[k]))*(x[i]-x[j]);
}

inline bool chek(const int&i,const int&j,const ll&k){
      return (long double)1.0*(y[i]+dp[i])-(y[j]+dp[j])<=(long double)1.0*k*(x[i]-x[j]);
}

inline int lookup(const ll&k){
      register int l=1,r=cnt-1,ret=cnt,mid;
      while(l<=r){
	    mid=(l+r)>>1;
	    if(chek(q[mid],q[mid+1],k))
		  r=mid-1,ret=mid;
	    else l=mid+1;
      }
      return q[ret];
}
int main(){
      
      n=qr();s=qr();
      for(register int t=1;t<=n;++t)
	    Ti[t]=qr(),Fi[t]=qr(),st[t]=st[t-1]+Ti[t];
      for(register int t=n;t>=0;--t) sf[t]=sf[t+1]+Fi[t];
      for(register int t=0;t<=n;++t) y[t]=sf[t+1]*(s-st[t]),x[t]=sf[t+1];
      q[cnt=1]=0;
      for(register int t=1;t<=n;++t){
	    dp[t]=getval(t,lookup(-st[t]));
	    while(cnt>1&&chek0(q[cnt-1],q[cnt],t)) --cnt;
	    q[++cnt]=t;
      }
      cout<<dp[n]<<endl;
      return 0;
}


```

参考文献：

[瓦努霍格木茨格兰芬多神威无敌无双超神大聚聚yyb的博客](<https://www.cnblogs.com/cjyyb/p/10549560.html>)



---

## 作者：_sry (赞：1)


一道斜率优化的dp

易得方程$f[j]=(S+t[i])\times c[j]+f[i]-t[i]\times c[i]+s\times c[n]$,为什么要写成这要，因为这样其实就可以将$min$拆掉，并且是一个函数形式，$(S+t[i])$为斜率，$f[i]-t[i]\times c[i]+s\times c[n]$为截距。

并且当我们要决策$i$用哪一个j时，我们会发现斜率是一样的,就只有截距会不同。所以我们要让截距越短。

所以发现当斜率为上升时，即为下凸壳的形式，所以我们可以用单调队列去优化

但是$t$有可能是负数，我们将线进行平移的时候要保证此点之前的斜率都小于$k$,之后全大于$k$,所以需要二分找到此区间

20181216 update:

为什么当截距最短是会取到$min{f[i]}$,因为$f[i]-t[i]\times c[i]+s\times c[n]$这个式子中$-t[i]\times c[i]+s\times c[n]$是定值，而又因为$f[i]$是$+f[i]$，所以只需要维护最小值即可。

但当截距出现$-f[i]$时，就必须让截距最大了，要维护的是一个上凸壳。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<climits>
#define int long long
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int N=300001;
int l,r,num[N];
int f[N],t[N],c[N],S,n,que[N];
int query(int pos,int X){
    int L=l,R=r,maxn=0;
    int mid;
    while(L<=R){
        mid=L+R>>1;
        if(f[que[mid+1]]-f[que[mid]]<=X*(c[que[mid+1]]-c[que[mid]])) L=mid+1,maxn=max(maxn,mid);
        else R=mid-1;
    }
    return que[maxn+1];
}
signed main(){
    n=read(),S=read();
    for(int i=1;i<=n;i++) t[i]=t[i-1]+read(),c[i]=c[i-1]+read();
    l=1,r=1;f[0]=0;
    for(int i=1;i<=n;i++){
        int H=query(i,S+t[i]);
        f[i]=f[H]-(S+t[i])*c[H]+t[i]*c[i]+S*c[n];
        while(l<r&&(f[que[r]]-f[que[r-1]])*(c[i]-c[que[r]])>=(f[i]-f[que[r]])*(c[que[r]]-c[que[r-1]])) r--;
        que[++r]=i;
    }printf("%lld\n",f[n]);
    return 0;
}
```

---

## 作者：Orion_Rigel (赞：1)

单调队列优化DP，可以做到On

···
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int f[5001],t[5001],que[5001],dp[5001];
int hd,tl,n,s;
int main()
{
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n;++i)
    {
        scanf("%d%d",&t[i],&f[i]);
        t[i]+=t[i-1];
        f[i]+=f[i-1];
    }
    memset(dp,0x3f,sizeof dp);
    dp[0]=0;hd=0;tl=0;
    que[hd]=0;
    for (int i=1;i<=n;++i)
    {
        while(hd<tl&&dp[que[hd+1]]-dp[que[hd]]<=(s+t[i])*(f[que[hd+1]]-f[que[hd]])) hd++;
        dp[i]=min(dp[i],dp[que[hd]]+(f[i]-f[que[hd]])*t[i]+s*(f[n]-f[que[hd]]));
        while(hd<tl&&(dp[i]-dp[que[tl]])*(f[que[tl]]-f[que[tl-1]])<=(dp[que[tl]]-dp[que[tl-1]])*(f[i]-f[que[tl]])) tl--;
        que[++tl]=i;
    }
    printf("%d\n",dp[n]);
}
···
```

---


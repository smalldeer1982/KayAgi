# [国家集训队] 聪聪可可

## 题目描述

聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。

他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 $n$ 个“点”，并用 $n-1$ 条“边”把这 $n$ 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随机选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 $3$ 的倍数，则判聪聪赢，否则可可赢。

聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。


## 说明/提示

【样例说明】

$13$ 组点对分别是 $(1,1)$，$(2,2)$，$(2,3)$，$(2,5)$，$(3,2)$，$(3,3)$，$(3,4)$，$(3,5)$，$(4,3)$，$(4,4)$，$(5,2)$，$(5,3)$，$(5,5)$。

【数据规模】

对于 $100\%$ 的数据，$n\leq 2 \times 10^4$。


## 样例 #1

### 输入

```
5
1 2 1
1 3 2
1 4 1
2 5 3```

### 输出

```
13/25```

# 题解

## 作者：cmd2001 (赞：71)

其实树状DP也可以做的，而且复杂度比点分治低......

我们定义 f[x][0,1,2] 表示在点x及其子树中，距离点x的距离在模3意义下为0,1,2的点分别有多少个。

转移的话直接从子树加上边长转移。

统计答案时需要在转移某一个子树前进行统计。其实就是一个卷积(雾?说人话!)，说白了就是让 前面的子树的点到点x的距离 与 当前子树中的点到点x的距离 在模3意义下为0。因为点对有序，所以乘2。

初值为f[x][0]=1。最后答案加上 每个点到本身的方案书(其实就是n) ， 去和n\*n取gcd即可。


最后上代码：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#define debug cout
using namespace std;
const int maxn=2e4+1e2;

int s[maxn],t[maxn<<1],nxt[maxn<<1],l[maxn<<1];
int f[maxn][3];
int n,ans,full,g;

inline void addedge(int from,int to,int len)
{
    static int cnt = 0;
    t[++cnt] = to;
    l[cnt] = len;
    nxt[cnt] = s[from];
    s[from] = cnt;
}

inline int mod(int x)
{
    return (x%3+3)%3;
}

inline int gcd(int x,int y)
{
    if( ! ( x && y ) )
        return x | y;
    register int t;
    while( t = x % y )
        x = y , y = t;
    return y;
}

inline void dfs(int pos,int fa)
{
    f[pos][0] = 1;
    for(int at=s[pos];at;at=nxt[at])
    {
        if( t[at] == fa )
            continue;
        dfs(t[at],pos);
        for(int i=0;i<3;i++)
            ans += f[t[at]][i] * f[pos][mod(-i-l[at])] * 2;
        for(int i=0;i<3;i++)
            f[pos][mod(i+l[at])] += f[t[at]][i];
    }
}

inline int getint()
{
    int ret = 0 , fix = 1;
    char ch = getchar();
    while( ! isdigit(ch) )
        fix = ch == '-' ? -1 : fix,
        ch = getchar();
    while( isdigit(ch) )
        ret = ret * 10 + ( ch - '0' ),
        ch = getchar();
    return ret * fix;
}

int main()
{
    n = getint();
    for(int i=1,a,b,l;i<n;i++)
    {
        a = getint() , b = getint() , l = getint();
        addedge(a,b,l);
        addedge(b,a,l);
    }
    
    dfs(1,-1);
    
    ans += n;
    full = n * n;
    g = gcd( ans , full );
    ans /= g , full /= g;
    
    printf("%d/%d\n",ans,full);
    
    return 0;
}
```

---

## 作者：ysner (赞：39)

这道题是点分治的模板题。

作为一个蒟蒻，我学习一个算法都是从看图解、看代码开始。一个模板题是新手练手之处，自应有详细的代码解释让他们理解程序，继而理解算法。~~因而楼下代码简短的注释对新手不太友好~~

在一些树上路径问题中，暴力求解时间复杂度过高，往往需要一些更为高效的算法，点分治就是其中之一。

【流程】

1、首先选取一个点，把无根树变成有根树。

那么如何选点呢？    ——树型动规

因为树是递归定义的，所以我们当然希望递归的层数最小。

每次选取的点，要保证与此点相连的结点数最多的连通块的结点数最小，我们把这个点叫做“重心”。

那么找到一颗树的重心有以下算法：

（1）dfs一次，算出以每个点为根的子树大小。

（2）记录以每个结点为根的最大子树的大小。

（3）判断：如果以当前结点为根的最大子树大小比当前根更优，更新当前根。

2、处理联通块中通过根结点的路径。

3、标记根结点（相当于处理过后，将根结点从子树中删除）。

4、递归处理以当前点的儿子为根的每棵子树。

本题核心思想：明显的树上的点分治，利用数组t[]表示搜当前根的子树时，当前子树之前的路径长x的方案数。最终答案为当前子树路径长x的方案数 \*ans+=g[j]\*ff[(3-j)%3]\*2。

注意（１，１）合法，（１，２）（２，１）算两种。

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define fp(i,a,b) for(int i=a;i<=b;i++)
#define fq(i,a,b) for(int i=a;i>=b;i--)
#define il inline
#define re register
#define ll long long 
using namespace std;
const int N=20005;
int n,cnt=0,root,sum,ans,t[5],h[N],f[N],son[N]={},d[N]={};
bool vis[N]={};
struct Edge
{
    int to,next,w;
}e[N<<1];
il int gi()
{
   int x=0;
   short int t=1;
   char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
void add(int u,int v,int w)
{
    e[++cnt]=(Edge){v,h[u],w};h[u]=cnt;
}
void getdeep(int u,int fa)
{
    t[d[u]]++;
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa||vis[v]) continue;
        d[v]=(d[u]+e[i].w)%3;
        getdeep(v,u);
    }
}
int calc(int u,int v)
{
    t[0]=t[1]=t[2]=0;
    d[u]=v;
    getdeep(u,0);
    return t[1]*t[2]*2+t[0]*t[0];
}
void getroot(int u,int fa)//u表示当前结点，fa表示u的父结点
{
    son[u]=1;
    f[u]=0;//f数组记录以u为根的最大子树的大小
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=fa&&!vis[v])//避免陷入死循环
        {
            getroot(v,u);//得到子结点信息
            son[u]+=son[v];//计算u结点大小
            f[u]=max(f[u],son[v]);//更新f数组
        }
    }
    f[u]=max(f[u],sum-son[u]);//sum表示当前树的大小，因为以x为根的情况还要考虑以x的父亲为根的子树大小。
    if(f[u]<f[root]) root=u;//更新当前根
}
void solve(int u)
{
    ans+=calc(u,0);
    vis[u]=1;//将当前点标记
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v]) continue;
        ans-=calc(v,e[i].w);
        root=0;//初始化根  
        sum=son[v];//初始化sum
        getroot(v,0);//找连通块的根
        solve(root);//递归处理下一个连通块
    }
}
int gcd(int a,int b)
{
    return (!b)?a:gcd(b,a%b);
}
int main()
{
    n=gi();
    fp(i,1,n-1)
    {
        int u=gi(),v=gi(),w=gi()%3;
        add(u,v,w);add(v,u,w);//建树
    }
    sum=f[0]=n;//初始化sum和f[0]
    root=0;//初始化root
    getroot(1,0);//找根
    solve(root);//点分治
    int t=gcd(ans,n*n);
    printf("%d/%d\n",ans/t,n*n/t);
    return 0;
}
ps:蒟蒻初学此算法，如有疑问或题解有不当之处请私信我。
```

---

## 作者：TopCarry (赞：29)

并没有去容斥。（可以降低不少思维复杂度）

在之前的题解之中并没有人去解释为什么t[0]*t[0]不需要乘2。

那么我们可以使用一种更加直观的写法，即我们开一个“桶”，每次我们把子树内的答案与桶里的答案先合并来更新最终的ans，在把这个子树里的答案丢进那个桶里，这样就可以完美避免“两个链有公共部分”的问题了。

于是转移变得直观了：

1.
```cpp
tong[0]*now[0]*2 之前拼出来的3的倍数和现在的3的倍数拼成3的倍数
```

2.
```cpp
tong[1]*now[2]*2 之前的1和现在的2
```

3.
```cpp
tong[2]*now[1]*2 之前的2和现在的1
```

4.
```cpp
now[0]*2 注意此处一条新的长为3的单链也可以产生贡献
```

5.
```cpp
	int a=ans+n,b=n*n; 两点重合最后单算
	int c=__gcd(a,b);algorithm自带的奇妙函数，懒一哈~
	cout<<a/c<<'/'<<b/c;
```

总代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100000,INF=2147483647;
static char buf[100000],*pa,*pd;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
	register int x(0);register char c(gc);
	while(c>'9'||c<'0')c=gc;
	while(c>='0'&&c<='9')x=x*10+(c^48),c=gc;
	return x;
}
struct edge{
	int to,next,w;
}e[N];
int head[N],tot;
inline void add(int x,int y,int z){
	e[++tot].to=y;e[tot].next=head[x];e[tot].w=z;head[x]=tot;
}
int n,tong[3],now[3],ans,root,sum,siz[N],maxp[N],vis[N],dis[N];
void getroot(int u,int fa){
	siz[u]=1;
	maxp[u]=0;
	register int i;
	for(i=head[u];i;i=e[i].next)
		if(e[i].to!=fa&&!vis[e[i].to]){
			getroot(e[i].to,u);
			siz[u]+=siz[e[i].to];
			maxp[u]=max(maxp[u],siz[e[i].to]);		
		}
	maxp[u]=max(maxp[u],sum-siz[u]);
	if(maxp[root]>maxp[u])root=u;
}
void getdis(int u,int fa){
	now[dis[u]%3]++;
	register int i;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to]&&e[i].to!=fa)
			{
			dis[e[i].to]=dis[u]+e[i].w;
			getdis(e[i].to,u);
		}
}
inline void calc(int u){
	register int i,j;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to]){
			for(j=0;j<3;j++)now[j]=0;
			dis[e[i].to]=e[i].w;
			getdis(e[i].to,u);
			ans+=tong[0]*now[0]*2+tong[1]*now[2]*2+tong[2]*now[1]*2+now[0]*2;
			for(j=0;j<3;j++)
				tong[j]+=now[j];
		}
}
void solve(int u){
	vis[u]=1;
	calc(u);
	register int i;
	for(i=0;i<3;i++)tong[i]=0;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to]){
			sum=siz[e[i].to];
			maxp[root=0]=INF;
			getroot(e[i].to,0);
			solve(root);
		}
}
int main(){
	n=read();
	register int i,x,y,z;
	for(i=1;i<n;i++){
		x=read();y=read();z=read();
		add(x,y,z);add(y,x,z);
	}
	maxp[root]=sum=n;
	getroot(1,0);
	solve(root);
	int a=ans+n,b=n*n;
	int c=__gcd(a,b);
	cout<<a/c<<'/'<<b/c;
	return 0;
} 
```

---

## 作者：Soulist (赞：20)

点分治，一种优雅的暴力

虽然带上了一个“分治”的名称，但实际上个人感觉和分治关系不大啊？

~~算了，我果然还是太$naive$了~~

做法：
因为树上任意两点的路径是唯一的，所以树上的路径总数为$n^2$的。

换而言之，题目要我们求的是距离为$3$的倍数的点有多少个。

现在考虑对于一个点$u$

我们可以发现$u$的子树上的路径分为两种：

$1.$过$u$的路径

$2.$不过$u$的路径

所以一条路径其要么过$u,$要么不过$u$

现在考虑过$u$的点，我们考虑如何统计所有过$u$的点的答案。

我们可以暴力地去统计其子树的点离$u$的距离，记$dis[x]$表示$x$到$u$的距离$\%3$的值，接下来，我们每遇到一个点$x$就令$sum[dis[x]\%3]++$

所以比较朴素的想法去统计答案就是：

我们可以先求出$u$的前$k$棵子树的$sum$，然后对于另一棵子树的点$v$，我们可以暴力地去更新前$k$棵子树的任意一条路径与$v$构成的路径长度为$k$有多少个。

写成式子应该就比较好懂了？

$$ans[(dis[v] + k)\%3]+= book[k]*2$$

然后我们可以发现，一棵树的答案与我们如何遍历这棵树无关，所以我们假设求出了$u$的答案后，然后我们再去求$u$的各棵子树的答案。

当然直接这样做复杂度还是$O(N^2)$的（这就是为什么我总感觉点分治还是暴力的$QAQ$~~可能是我太弱了~~）

因为之前讲过：一棵树的答案与我们如何遍历这棵树无关，所以我们只要这颗树形态没有改变，所得的答案还是一样的。

故，我们每次从一棵树的重心开始遍历，然后处理完其答案后从其子树的重心遍历。

~~据说这样做的复杂度就是$O(NlogN)$了......蒟蒻也不知道为什么~~

然后这样可能是可以过这道题了，但实际上我们可以把代码写得更简单点。

我们考虑容斥：

假设我们求得了$u$的子树中的点，离$u$的距离$\%$分别为$0,1,2$的数个数。

令$ans = book[0] * book[0] + book[1] * book[2] * 2$

那么$ans$表示的是距离$u$长度为$3$的倍数的点两两组成的答案。

那么我们重复统计了那些部分呢？我们把一棵子树里面的点距$u$距离为$3$的倍数的点重复统计了。

所以我们还要减去子树的$ans$

最后式子大概就是这样：

```cpp
ans += doit(x)//doit统计答案

for( 枚举i的子树 )
	ans -= doit(v);

```

最后是简洁可读$($~~丑陋不堪~~$)$的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int M = 200000 + 5;
#define il inline
#define re register
#define Next( i, u ) for( re int i = head[u]; i; i = e[i].next )
#define rep( i, s, t ) for( re int i = s; i <= t; ++ i ) 
#define drep( i, t, s ) for( re int i = t; i >= s; -- i )
struct E {
	int to, next, w;
}e[M * 2];
int n, cnt, tot, book[5], ans, sum, rt;
int head[M], vis[M], dp[M], size[M], dis[M];

int gcd( int a, int b ) {
	if( b == 0 ) return a;
	return gcd( b, a % b );
}
il void add( int x, int y, int z ) {
	e[++ cnt] = (E){ y, head[x], z }, head[x] = cnt;
	e[++ cnt] = (E){ x, head[y], z }, head[y] = cnt;
}
il void input() {
	n = read();
	int x, y, z;
	dp[0] = sum = n, rt = 0;
	rep( i, 1, n - 1 )  x = read(), y = read(), z = read(), add( x, y, z % 3 );
} 

void get_rt( int u, int fa ) {
	size[u] = 1, dp[u] = 0;
	Next( i, u ) {
		int v = e[i].to;
		if( vis[v] || v == fa ) continue;
		get_rt( v , u );
		size[u] += size[v];
		dp[u] = max( size[v], dp[u] );
	}
	dp[u] = max( dp[u], sum - size[u] );
	if( dp[u] <= dp[rt] ) rt = u;
}

void get_dis( int x, int fa ) {
	++ book[dis[x] % 3];
	Next( i, x ) {
		int v = e[i].to;
		if( vis[v] || v == fa ) continue;
		dis[v] = ( dis[x] + e[i].w ) % 3;
		get_dis( v, x );
	}
}
il int doit( int x, int w ) {
	memset( book, 0, sizeof(book) ), dis[x] = w % 3;
	get_dis( x, 0 );
	return book[2] * book[1] * 2 + book[0] * book[0];
}

il void solve( int u ) {
	vis[u] = 1, ans += doit( u, 0 );
	Next( i, u ) {
		int v = e[i].to;
		if( vis[v] ) continue;
		ans -= doit( v, e[i].w % 3 );
		dp[0] = n, rt = 0, sum = size[v];
		get_rt( v, u ), solve( rt );
	}
}
signed main()
{
	input(), get_rt( 1, 0 ), solve( rt );
	int k = gcd( ans, n * n );
	printf("%d/%d", ans/k, n * n / k );
	return 0;
}

```

---

## 作者：Smallbasic (赞：17)

其实这题应该是蓝的。。。不用点分，上课的时候自己推出来了树形dp。

考虑到3这个数非常小，模3的结果只有0/1/2,考虑拿他单独做一维状态。而概率其实相当于方案数除以总方案数

因此只需要算出方案数就好。

设$f[i][j]$表示从i的子树里任选一点到$i$的路径长度$\pmod 3$ 为$j$的方案数

显然有转移：

$$f[i][j]=\sum_{d\in i.son}f[d][3\mod \{[j+dist(i,d)]\mod3\}]$$

写的方便一点即是：

$$f[i][(j+dist(i,d))\mod 3]+=f[d][j]$$

统计答案可以用乘法原理相乘，即枚举中转点，到中转点的距离之和模3为0的方案数相乘

但要注意是在dp的过程中统计答案，下来统计会遇到选择的两点在中转点的同一子树内的情况，而在dp过程中那一部分还没算出来，但是由于$(u,v)$和$(v,u)$是两种不同的方案，要乘以二，且$(v,v)$这种方案也是合法的，所以还要加上n。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) f = (ch == '-' ? -1 : 1), ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s * f; 
}

int n, f[20005][3], u, v, w, ans, m;
vector<int> nxt[20005], val[20005];

inline void dfs(int now, int fa) {
	f[now][0] = 1; vector<int> :: iterator iv = val[now].begin();
	for (vector<int> :: iterator it = nxt[now].begin(); it != nxt[now].end(); ++it) {
		if ((*it) == fa) { ++iv; continue ; }
		dfs((*it), now);
		for (int i = 0; i < 3; ++i)
			ans += f[(*it)][i] * f[now][(3 - (((i + (*iv)) % 3 + 3) % 3)) % 3] * 2;
		for (int i = 0; i < 3; ++i)
			f[now][((i + (*iv)) % 3 + 3) % 3] += f[(*it)][i];
		++iv;
	}
}

inline int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}

int main() {
	n = read();
	for (int i = 1; i < n; ++i) {
		u = read(); v = read(); w = read();
		nxt[u].push_back(v); val[u].push_back(w);
		nxt[v].push_back(u); val[v].push_back(w);
	} ans = n; dfs(1, -1); m = n * n;
	printf("%d/%d", ans / gcd(ans, m), m / gcd(ans, m));
	return 0;
} 
```


---

## 作者：Orion545 (赞：17)

作为一名蒟蒻而言，模板题是非常重要的。它能帮助你在理解这个算法的路上迈出第一步，甚至是一大步


楼下dalao讲点分治的流程讲的非常好，但是在描述这道题的具体答案统计方式上并不是特别清楚


因此我就来献个拙


### 【广告】

蒟蒻的blog:

[Dedicatus545](http://www.cnblogs.com/dedicatus545/p/8391928.html)


## 思路：


题目要求统计书上路径信息，想到树上分治算法


实际上这是一道点分治裸题，我就不瞎BB思路了，直接上做法。


对于一个节点，设dis[i]为其他节点到这个节点的距离 MOD 3


那么可以证明，一条经过该节点的合法路径(i,j)，( dis[i] + dis[j] ) % 3==0


因此对每个节点求出其子树内的dis，经过该点的路径数即为（dis[i]==1的点数）\*（dis[i]==2的点数）\*2 + （dis[i]==0的点数）^2


递归求解


递归进入一个节点u时，ans先加入calc(u,0)，即为上述求解过程（dis[u]==0开始)。


每一次对于当前递归到的节点的每一棵子树，ans先减去dis(v,e[i].w)，即为从(dis[v]==e[i].w)开始，为的是去掉重复计算的部分。


求这个子树的重心


方法：


递归进入子树中每一个节点，统计其子最大的子树大小（包括连向其父节点的那一棵）


这个最大值最小的节点就是树的重心。


如果每次从这里进入，那么进入的子树的size一定小于整棵当前树的size的一半


这样递归下去最多log n层


求完这棵子树的重心以后从这个重心递归进入，求该子树的解


最后ans即为答案数目（ans初始为0）



## 需要注意的地方：


1.答案要约分

2.记得要从求解好的root进入下一层递归，而不是从连接的那个点v（被这个坑了30min(⊙﹏⊙)b）



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
void _swap(int &x,int &y){x^=y;y^=x;x^=y;}
int _max(int x,int y){return (x>y)?x:y;}
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,cnt,ans,dis[20010],first[20010],tmp[5],root,siz[20010],son[20010],sum;
bool vis[20010];
struct edge{
    int to,next,w;
}a[40010];
inline void add(int u,int v,int w){
    a[++cnt]=(edge){v,first[u],w};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],w};first[v]=cnt;
}
int gcd(int x,int y){return (y?gcd(y,x%y):x);};
void getroot(int u,int f){
    //cout<<"getroot "<<u<<" "<<f<<"\n";
    int i,v;
    siz[u]=1;son[u]=0;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f||vis[v]) continue;
        getroot(v,u);
        siz[u]+=siz[v];
        son[u]=_max(son[u],siz[v]);
    }
    son[u]=_max(son[u],sum-siz[u]);//统计父亲节点的那棵子树，sum为当前的整棵子树的size
    //cout<<"finish getroot "<<son[u]<<'\n';
    if(son[u]<son[root]) root=u;
}
void gettmp(int u,int f){
    //cout<<"gettmp "<<u<<" "<<f<<"\n";
    int i,v;
    tmp[dis[u]]++;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f||vis[v]) continue;
        //cout<<" to "<<v<<'\n';
        dis[v]=(dis[u]+a[i].w)%3;
        gettmp(v,u);
    }
}
int calc(int u,int d){//即为文中描述的calc
    dis[u]=d%3;tmp[0]=tmp[1]=tmp[2]=0;
    gettmp(u,0);
    return tmp[1]*tmp[2]*2+tmp[0]*tmp[0];
}
void dfs(int u){
    //cout<<"dfs "<<u<<"\n";
    int i,v;
    vis[u]=1;ans+=calc(u,0);
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(vis[v]) continue;
        ans-=calc(v,a[i].w);
        sum=siz[v];root=0;//更新root和sum
        getroot(v,u);
        dfs(root);//注意这里不要写成dfs(v)了，手快很容易写错
    }
}
int main(){
    // freopen("cckk.in","r",stdin);
    // freopen("cckk.out","w",stdout);
    memset(first,-1,sizeof(first));
    int i,t1,t2,t3;
    n=read();
    for(i=1;i<n;i++){
        t1=read();t2=read();t3=read();
        add(t1,t2,t3);
    }
    //cout<<"finish read in\n";
    sum=n;son[0]=n;//将son[0]初始化为极大值
    getroot(1,0);
    dfs(1);
    int div=gcd(n*n,ans);//注意约分
    printf("%d/%d",ans/div,n*n/div);
}
```

---

## 作者：素质玩家孙1超 (赞：11)

有人说这是树状DP模板题，有人说这是点分治模板题

但我觉得这是dsu on tree的模板题  

~~好像这是唯一一篇dsu on tree题解~~

十分经典的树上路径的统计，dsu on tree比较好理解

而且复杂度也不必点分治低

---

#### 算法思想：普通dfs，但把重儿子的数据存下来，所以原本$n^2$的第二层$n$可以被优化

核心代码:

其中son[pos]为pos的重儿子

For(pos)表示遍历pos的儿子



```cpp
void dfs(int pos,int father,bool heavy)//heavy表示是否是父亲的重儿子
{
	For(pos)//遍历轻儿子 
		if(to[k]!=father&&to[k]!=son[pos]) 
			dfs(to[k],pos,0);
	if(son[pos]) dfs(son[pos],pos,1);//遍历重儿子 
	For(pos)//计算轻儿子的贡献值 
	{
		if(to[k]==father||to[k]==son[pos]) continue;
		work(to[k],pos,1,pos);//该子树对其他儿子的贡献 
		work(to[k],pos,0,pos);//把该儿子的数据存下来 
	}
	cal(pos,pos);//计算该点 
	q[deep[pos]%3]++;//记录该点 
	if(!heavy)q[0]=q[1]=q[2]=0;//如果不是父亲的重儿子，清除数据 
}
```
其中计算函数cal
~~~cpp
inline void cal(int pos,int LCA)
{
	int x=(2*deep[LCA]-deep[pos])%3+3;
	x=x%3;
	ans+=q[x];
}

~~~
遍历计算函数work函数

~~~cpp
void work(int pos,int father,bool ca,int LCA)
{
	if(ca) cal(pos,LCA);
	else q[deep[pos]%3]++;
	For(pos) 
	{
		if(to[k]==father) continue;
		work(to[k],pos,ca,LCA); 
	}
}

~~~


完整代码

~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define For(pos) for(int k=First[pos];k;k=Next[k])
const int Maxn=2e4+5;
int n,First[Maxn],to[Maxn*2],Next[Maxn*2],W[Maxn*2],cnt;
int son[Maxn],size[Maxn],deep[Maxn];
inline void add(int z,int y,int w)
{
	Next[++cnt]=First[z];
	First[z]=cnt;
	to[cnt]=y;W[cnt]=w;
}
int ans=0,P;
inline int R()
{
	char c;int sign=1,res=0;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1;res+=c-'0';
	while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
	return res*sign;	
}
void deal(int pos,int father)
{
	size[pos]=1;
	For(pos)
	{
		if(to[k]==father) continue;
		deep[to[k]]=deep[pos]+W[k]; 
		deal(to[k],pos);
		size[pos]+=size[to[k]];
		if(size[son[pos]]<size[to[k]]) son[pos]=to[k];
	}
}
int q[4];
void cal(int pos,int father,int op,int deep)
{
	q[deep%3]++;
	if(q[3-deep]) ans+=q[3-deep];
}
inline void cal(int pos,int LCA)
{
	int x=(2*deep[LCA]-deep[pos])%3+3;
	x=x%3;
	ans+=q[x];
}
void work(int pos,int father,bool ca,int LCA)
{
	if(ca) cal(pos,LCA);
	else q[deep[pos]%3]++;
	For(pos) 
	{
		if(to[k]==father) continue;
		work(to[k],pos,ca,LCA); 
	}
}
void dfs(int pos,int father,bool heavy) 
{
	For(pos)   if(to[k]!=father&&to[k]!=son[pos]) dfs(to[k],pos,0);
	if(son[pos]) dfs(son[pos],pos,1); 
	For(pos) 
	{
		if(to[k]==father||to[k]==son[pos]) continue;
		work(to[k],pos,1,pos); 
		work(to[k],pos,0,pos); 
	}
	cal(pos,pos); 
	q[deep[pos]%3]++; 
	if(!heavy)q[0]=q[1]=q[2]=0; 
}
int main()
{
	n=R();int a,b,w;
	for(int i=1;i<n;i++)
	{
		a=R();b=R();w=R();
		add(a,b,w);
		add(b,a,w); 
	}
	deal(1,0);
	dfs(1,0,1);
	ans=ans*2+n;
	int di=n*n;
	for(int i=2;i<=ans;i++)
		while(ans%i==0&&di%i==0)
		{
			ans/=i;
			di/=i;
		}
	if(ans==di) puts("1");
	else printf("%d/%d\n",ans,di);
} 
~~~

---

## 作者：Autream (赞：8)

#### 前言
看到题解区全是用容斥做的，但是我太蒻了不会，所以来~~水一发~~**不用容斥**的题解。

---
#### 题意简述
给定一棵树，边有边权，任意选择一条路径，求这条路径的长度是 $3$ 的倍数的概率。

---
#### 题目分析
易知，概率即为 $\frac{合法的路径}{所有路径}$。
关键在于合法路径怎么去求。

使用点分治算法，我们枚举重心 $rt$，对于它的每个儿子，用 $dist_i$ 表示结点 $i$ 在模 $3$ 意义下距离根的长度；用 $cnt_{0/1/2}$ 表示在**遍历当前结点之前**，距离根的长度为 $0/1/2$ 的链的数量。

接下来分类讨论：
- 如果 $dist_i = 0$，那么它一定能与**之前所有**距离根长度为 $0$ 的链组合成一条合法路径，合法数量加上 $cnt_0\times 2+2$，$+2$ 是因为它本身到根也可以组成两个数对。
- 如果 $dist_i = 1$，那么它一定能与**之前所有**距离根长度为 $2$ 的链组合成一条合法路径，合法数量加上 $cnt_2\times 2$ 。
- 如果 $dist_i = 2$，那么它一定能与**之前所有**距离根长度为 $1$ 的链组合成一条合法路径，合法数量加上 $cnt_1\times 2$ 。

在 `dfs` 函数内部，我们枚举当前结点 $x$ 的儿子，先更新 $dist$ 数组，然后更新答案，最后才更新 $cnt$，因为 $cnt$ 保存的是当前儿子之前的数据。

---
#### AC Code
```cpp
// Problem: P2634 [国家集训队] 聪聪可可
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2634
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Author: Li_Feiy
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)a[i]=read()
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
int read() {
    char ch=getchar();
    int r=0,w=1;
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+ch-'0',ch=getchar();
    return r*w;
}
CI N=2e4+5,INF=1e8+5;
int n,fz,fm,rt,tot,sum,cnt[N],max[N],dis[N],dist[N],size[N],head[N];
bool tf[INF],vis[N];
std::queue<int> t;
struct edge {
	int to,nex,data;
}e[N<<1];
void add(int x,int y,int z) {
	e[++tot].to=y;
	e[tot].data=z;
	e[tot].nex=head[x];
	head[x]=tot;
}
void update_size(int x,int fa) {
	size[x]=1;
	max[x]=0;
	erg(i,x) {
		int y=e[i].to;
		if(y==fa||vis[y]) continue;
		update_size(y,x);
		size[x]+=size[y];
		max[x]=std::max(max[x],size[y]);
	}
	max[x]=std::max(max[x],sum-size[x]);
	if(max[x]<max[rt]) rt=x;
}
void update_dist(int x,int fa) {
	dis[++dis[0]]=dist[x]%3;
	erg(i,x) {
		int y=e[i].to,z=e[i].data;
		if(y==fa||vis[y]) continue;
		dist[y]=(dist[x]+z)%3;
		update_dist(y,x);
	}
}
void update_cnt(int x,int fa) {
	cnt[dist[x]%3]++;
	erg(i,x) {
		int y=e[i].to;
		if(y==fa||vis[y]) continue;
		update_cnt(y,x);
	}
}
void dfs(int x,int fa) {
	vis[x]=1;
	erg(i,x) {
		int y=e[i].to,z=e[i].data;
		if(y==fa||vis[y]) continue;
		dist[y]=z%3;
		update_dist(y,x);
		rep(i,1,dis[0]) {
			switch(dis[i]) {
				case 0:
					fz+=cnt[0]*2+2;
					break;
				case 1:
					fz+=cnt[2]*2;
					break;
				case 2:
					fz+=cnt[1]*2;
					break;
			}
		}
		dis[0]=0;
		update_cnt(y,x);
	}
	cnt[0]=cnt[1]=cnt[2]=0;
	erg(i,x) {
		int y=e[i].to,z=e[i].data;
		if(y==fa||vis[y]) continue;
		sum=size[y];
		rt=0;
		max[rt]=INF;
		update_size(y,x);
		update_size(rt,-1);
		dfs(rt,x);
	}
}
signed main() {
	n=read();
	rep(i,1,n-1) {
		int x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
	}
	sum=fz=n;
	rt=0;
	max[rt]=INF;
	update_size(1,-1);
	update_size(rt,-1);
	dfs(rt,-1);
	fm=n*n;
	while(std::__gcd(fz,fm)!=1) {
		int gcd=std::__gcd(fz,fm);
		fz/=gcd,fm/=gcd;
	}
	printf("%lld/%lld",fz,fm);
    return 0;
}
```

---

## 作者：Zcus (赞：7)

点分治详解

### 一.概念

​      是处理树上路径的一个极好的方法。如果你需要大规模的处理一些树上路径的问题时，点分治是一个不错的选择。

### 二.具体思路

​      大多数同学的暴力做法都是对于每一个点对（u，v） 进行dfs来求解。但其实利用分治这一种算法，可以大大减少搜索的时间复杂度。

​      对于一个序列上的区间和等操作，我们可以使用分治来将原问题分解成几个子问题来求解，之后在一一合并答案。而在树上我们也是可以进行这一种操作的。可是树上的每一个子树的节点数是不确定的，不能单单的取中点（你告诉我怎么取），或直接取一号子树。（分治的点的错误选择会导致时间复杂度十分不稳定）。

​     如下图所示，如果你取了第一个点的话，那么时间复杂度会变$O(n)$,但如果我们取的点是3的话，那么时间复杂度就会是 $O(logn)$

 ![](https://cdn.luogu.com.cn/upload/pic/28185.png)

​        所以，我们要引入一个概念 —— 树的重心

​        定义：**找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡**

​       由定义可知，当我们选择树的重心为分支点时，是最优的（~~我有个绝妙的证明只是这里写不下~~）

​       好了，求出了树的重心之后我们就可以来分治了！！

​      先现给出求重心的代码，便于读者依次理解

   ```cpp
void find(int x,int fa)
{
    size[x] = 1; mx[x] = 0;
    for (int i = head[x]; i ; i = edges[i].net)
    {
        edge v = edges[i];
        if(v.to == fa||vis[v.to] ) continue;//vis是之后分治是要用到的
        find(v.to,x);
        size[x] += size[v.to];
        chkmax(mx[x],size[v.to]);
    }
    chkmax(mx[x],S-size[x]);//S为树的大小，记住x的上面要算入的
    if(mx[x] < mx[root])
    {
        root = x;
    }
}
   ```

​           现在开始我们点分治中最重要的部分了 —— 分治

​           分治不太好讲，我们从代码开始分析

 ```cpp
void Divid(int x)
{
    ans+=solve(x,0);
    vis[x] = 1;
    for (int i = head[x];i;i = edges[i].net)
    {
        edge v = edges[i];
        if(vis[v.to]) continue;
        ans-=solve(v.to,edges[i].cost);
        S = size[v.to]; root = 0;
        find(v.to,x);
        Divid(root);
    }
}
```

1. ans += solve(x,0); 这一句的作用是将答案加上经过x的路径答案。 而这一个0是为了解决掉一些，有重复计算的结果；（看不懂先假装没有这个0）
2. ans -= solve（v.to,edges[i].cost); 这一句是将在既经过x这个点，又经过v.to这一个点的路径来去重。因为像这种路径会在solve（x,0)和solve(v.to,0)中都计算一次。而题目是要求路径的长度，所以在容斥时要初始化这条边的长度。所以，现在有没有理解这个0和edges[i].cost?
3. S = size[v.to]; 现在我们要分治v.to的这一颗子树，So，又将求重心的树的大小改为size[v.to];

 到此为止，点分治就在这里讲完了，solve函数是看题目的，有能力的同学可以切一切这两道题（这两道题会在下面进行讲解）。[luogu模板题](https://www.luogu.org/problemnew/show/P3806) 和[聪聪可可](https://www.luogu.org/problemnew/show/P2634).



--------------------------------

### 三.例题分析

1.luogu模板题

​       2.聪聪可可

​          这道题是来求长度被3整除的路径条数，但处理方法跟模板不太一样。

  我们可以设p[0],p[1],p[2]为除3余数为0,1,2的 路径条数。显然答案为$p_0^2$ + $p_1 * p_2 * 2$

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<bits/stdc++.h>
int gcd(int x, int y)
{
    if(y == 0) return x;
    return gcd(y,x%y);
}
template<class T>
inline void read(T &a)
{
    T s = 0,w = 1;
    char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-') w = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        s = (s << 1) + (s << 3) + (c ^ 48);
        c = getchar();
    }
    a = s*w;
}
template<class T> void chkmax(T &a, T b){a > b? (a = a) : (a = b);}
template<class T> void chkmin(T &a, T b){a > b ? (a = b):(a = a);}
int n;
struct edge{
    int from, to,cost,net;
    edge(int f = 0, int t = 0, int c = 0, int n = 0)
    {
        from = f;
        to = t;
        cost = c;
        net = n;
    }
}edges[2010101];
static int head[20010],tot;
void add(int x, int y, int z)
{
    edges[++tot] = edge(x,y,z,head[x]);
    head[x] = tot;
}
static int vis[20010],size[20010],mx[20010],root,S; 
void find(int x,int fa)
{
    size[x] = 1; mx[x] = 0;
    for (int i = head[x]; i ; i = edges[i].net)
    {
        edge v = edges[i];
        if(v.to == fa||vis[v.to] ) continue;
        find(v.to,x);
        size[x] += size[v.to];
        chkmax(mx[x],size[v.to]);
    }
    chkmax(mx[x],S-size[x]);
    if(mx[x] < mx[root])
    {
        root = x;
    }
}
int dis[20010],a[20010],cnt;
int ans,p[3];
void get_dis(int x, int fa)
{
  //  dis[++cnt] = a[x];
    p[a[x]%3]++;
    for (int i = head[x] ;i; i = edges[i].net)
    {
        edge v = edges[i];
        if(v.to == fa ||vis[v.to] ) continue;
        a[v.to] = a[x]+v.cost;
        get_dis(v.to,x);
    }
}
int  solve(int x, int len)
{
    a[x] = len;
    //cnt = 0;
    p[0] = p[1] = p[2] = 0;
    get_dis(x,0);
    return (p[0]*p[0] + 2 * p[1] * p[2]);
}
void Dived(int x)
{
    ans+=solve(x,0);
    vis[x] = 1;
    for (int i = head[x];i;i = edges[i].net)
    {
        edge v = edges[i];
        if(vis[v.to]) continue;
        ans-=solve(v.to,edges[i].cost);
        S = size[v.to]; root = 0;
        find(v.to,x);
        Dived(root);
    }
}
int main()
{
    //freopen("xx.in","r",stdin);
    //freopen("xx.out","w",stdout);
    read(n);
    for (register int i = 1; i < n; i++)
    {
    	int x,y,z;
    	read(x); read(y); read(z);
    	z%=3;
    	add(x,y,z);
    	add(y,x,z);
    }
    S = n;root = 0; mx[0] = n+1; 
    find(1,0);
    Dived(root);
    int pp = gcd(ans,n*n);
    printf("%lld/%lld\n",ans/pp,n*n/pp);
   // std::cerr<<std::clock()<<std::endl;
    return 0;
}
```

---

## 作者：撤云 (赞：4)

博客食用效果更佳:[戳这](https://www.cnblogs.com/hbxblog/p/9840188.html)

###**题解**:

这道题看起来就像点分治对吧.没错就是点分治.
~~什么是点分治~~
如果你不会点分治,可以去看看[这儿](https://www.cnblogs.com/hbxblog/p/9826679.html)

现在看到这里,首先确保你已经会了点分治,如果不会你还往下看,听不懂概不负责~~虽然会但没看懂也不负责(逃)~~


点分治题目大部分都是模板对吧.只是calc(solve)的区别.首先看看暴力的calc.暴力枚举所有边,在判断是否为3的倍数.

但是这显然不行对吧,在仔细思考一下.发现%3的数的可能性只有三种情况
1. %3=0
2. %3=1
3. %3=2

所以想要为三的倍数的话有两种可能性,0和0的组和,1和2的组合所以答案就是`dis[1]*dis[2]*2+dis[0]*dis[0]`最后的答案就是这个出以总方案数.记得约分.

####代码:
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int N=40001;
int read() {
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')c=='-'?f=-1,c=getchar():c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x*f;
}
int n,k;
int dep[N];
int f[N];
int vis[N];
int siz[N];
int root;
struct node {
	int next,to,v;
} a[N<<1];
int head[N],cnt,sum;
void add(int x,int y,int c) {
	a[++cnt].to=y;
	a[cnt].next=head[x];
	a[cnt].v=c;
	head[x]=cnt;
}
void findroot(int k,int fa) {
	f[k]=0,siz[k]=1;
	for(int i=head[k]; i; i=a[i].next) {
		int v=a[i].to;
		if(vis[v]||v==fa)
			continue;
		findroot(v,k);
		siz[k]+=siz[v];
		f[k]=max(f[k],siz[v]);
	}
	f[k]=max(f[k],sum-siz[k]);
	if(f[k]<f[root])
		root=k;
}
int tot;
void finddep(int k,int fa,int l) {
	dep[l]++;
	for(int i=head[k]; i; i=a[i].next) {
		int v=a[i].to;
		if(v==fa||vis[v])
			continue;
		finddep(v,k,(l+a[i].v)%3);
	}
}
int calc(int k,int L) {
	tot=0;
	dep[0]=dep[1]=dep[2]=0;
	finddep(k,0,L%3);
	return dep[0]*dep[0]+2*dep[1]*dep[2];
}
int js;
void devide(int k) {
	vis[k]=1;
	js+=calc(k,0);
	for(int i=head[k]; i; i=a[i].next) {
		int v=a[i].to;
		if(vis[v])
			continue;
		js-=calc(v,a[i].v);
		root=0,sum=siz[v];
		findroot(v,0);
		devide(root);
	}
}
int main() {
	int n=read(),x,y,z;
	for (int i=1; i<n; i++)
		x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
	sum=f[0]=n;
	findroot(1,0);
	devide(root);
	int l=__gcd(js,n*n);
	printf("%d/%d\n",js/l,n*n/l);
	return 0;
}
```

---

## 作者：KagurazakaLorna (赞：2)

发一个树形DP的题解吧...因为我不会点分治...

设$\;\;$Down[pos][0/1/2]$\;\;$表示在结点$\;$i$\;$的子树内，到点$\;$i$\;$的距离$\;$mod$\;$3$\;$是$\;$0/1/2$\;$的点的个数。

转移方程如下：

$$ Down[pos][j] = \sum Down[son][k] $$

满足:

$$fa[son] = pos$$

$$(k\;+\;val)\;mod\;3 = j$$

其中$\;\;$fa[son]$\;\;$表示点$\;$son$\;$的父亲结点,$\;$val$\;$表示点$\;$son$\;$到父亲结点的距离。

这个转移应该是比较显然的。

这样我们就处理出了子树内的答案。

设$\;\;$Dp[pos][0/1/2]$\;\;$表示整个树中，到点$\;$pos$\;$的距离$\;$mod$\;$3$\;$是$\;$0/1/2$\;$的点的个数。

这个的转移有点难想，我们考虑换根。

先给出转移：

对于根结点,

$$Dp[root][j] = Down[root][j] (j = 0/1/2)$$

对于非根结点,

$$Dp[son][j] = Dp[pos][k] - Down[son][t] + Down[son][j]$$

满足,

$$fa[son] = pos$$

$$(k\;+\;val)\;mod\;3 = j$$ 

$$(t\;+\;val)\;mod\;3 = k$$

其中$\;$fa[son]$\;$表示点$\;$son$\;$的父亲结点，$\;$val$\;$表示点$\;$son$\;$到父亲结点的距离。

思考这个转移，到达点$\;$son$\;$，距离 mod 3 是 j 的点的个数， 应该是到达 fa[son] ，距离 mod 3 是 k 的点的个数。 因为这些点经过 val 这条边， 到达点 son 以后， 距离 mod 3 就是 j 。

但是考虑这些点中，有些点在点 son 的子树内部， 它们已经走过了 val 这条边 （这些点经过 val 这条边到达 fa[son] ），所以我们要去掉它们。

这样我们就得到了点 son 的子树外的，到达点 son 距离 mod 3 是 j 的点的个数。

最后在加上点 son 子树以内的， 到达点 son ，距离 mod 3 是 j 的点的个数，就可以了。

~~似乎有点麻烦...~~

具体程序实现还有一些细节，就不举栗子啦...

人生第一次写LaTeX...也不是很会Markdown...

所以很丑哦...不要介意...

贴上代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 20010
using namespace std;
template <typename type> inline void Read(type &res) {
    res = 0; int f = 1; char ch = getchar();
    for (; !isdigit(ch); ch = getchar()) f = (ch == '-') ? (-1) : (f);
    for (; isdigit(ch); ch = getchar()) res = res * 10 + ch - '0';
    res *= f; return;
}
int n, tot, ver[MAXN * 2], nxt[MAXN * 2], head[MAXN], len[MAXN * 2], down[MAXN][3], fa[MAXN], dp[MAXN][3];
inline void Add(int u, int v, int w) {
    ver[++ tot] = v, len[tot] = w, nxt[tot] = head[u], head[u] = tot;
    return;
}
void Dfs(int pos) {
    down[pos][0] = 1;
    for (int i = head[pos]; i > 0; i = nxt[i]) {
        int son = ver[i], val = len[i];
        if (fa[pos] == son) continue;
        fa[son] = pos;
        Dfs(son);
        for (int j = 0; j < 3; ++ j) down[pos][(j + val) % 3] += down[son][j];
    }
    return;
}
void Dp(int pos) {
    for (int i = head[pos]; i > 0; i = nxt[i]) {
        int son = ver[i], val = len[i];
        if (fa[pos] == son) continue;
        for (int j = 0; j < 3; ++ j) {
            int k = (j + 3 - val) % 3, t = (k + 3 - val) % 3;
//			(k + val) % 3 == j, (t + val) % 3 == k
            dp[son][j] = dp[pos][k] - down[son][t] + down[son][j];
        }
        Dp(son);
    }
    return;
}
int main() {
    Read(n); tot = 0;
    memset(nxt, 0, sizeof(nxt));
    memset(head, 0, sizeof(head));
    for (int i = 1; i < n; ++ i) {
        int u, v, w; Read(u), Read(v), Read(w); w %= 3;
        Add(u, v, w); Add(v, u, w);
    }
    memset(down, 0, sizeof(down));
    memset(fa, 0, sizeof(fa));
    Dfs(1); 
    for (int j = 0; j < 3; ++ j) dp[1][j] = down[1][j];
    Dp(1);
    int res = 0;
    for (int i = 1; i <= n; ++ i) res += dp[i][0];
    int gcd = __gcd(res, n * n);
    cout << res / gcd << "/" << n * n / gcd << endl;
    return 0;
}
```

---

## 作者：安好 (赞：2)

/\*
点分治裸题

记录到重心路径中模三==0,1,2的路径条数 flag[0],flag[1],flag[2]

每次统计答案就是flag[1]\*flag[2]\*2+flag[0]\*flag[0]。

\*/











```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 20010
#define inf 0x3f3f3f3f
using namespace std;
int n,m,x,y,z,sum,num,cnt,ans,L,root,t;
int head[maxn],vis[maxn],d[maxn],son[maxn],f[maxn],flag[4];
struct node
{
    int u,to,w,next;
}e[maxn<<1];
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline void add(int u,int v,int dis)
{
    e[++num].to=v;e[num].next=head[u];
    e[num].w=dis;head[u]=num;
}
int gcd(int a,int b)  {return b==0?a:gcd(b,a%b);}
void get_root(int now,int fa)
{
    son[now]=1;f[now]=0;
    for(int i=head[now];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa||vis[v]) continue;
        get_root(v,now);
        son[now]+=son[v];f[now]=max(f[now],son[v]);
    }
    f[now]=max(f[now],sum-son[now]);
    if(f[now]<f[root]) root=now;
}
void get_deep(int now,int fa)
{
    flag[d[now]]++;
    for(int i=head[now];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v]||v==fa)continue;
        d[v]=(d[now]+e[i].w)%3;
        get_deep(v,now);
    }
}
int cal(int now,int dis)
{
    d[now]=dis;flag[0]=flag[1]=flag[2]=0;
    get_deep(now,0);
    return flag[1]*flag[2]*2+flag[0]*flag[0];
}
void work(int now)
{
    ans+=cal(now,0);vis[now]=1;
    for(int i=head[now];i;i=e[i].next)
    {
        int v=e[i].to;
        if(vis[v]) continue;
        ans-=cal(v,e[i].w);
        root=0;sum=son[v];
        get_root(v,0);work(root);
    }
}
int main()
{
    n=read();
    for(int i=1;i<n;i++)
    {
        x=read();y=read();z=read()%3;
        add(x,y,z);add(y,x,z);
    }
    sum=n;f[0]=n+1;
    get_root(1,0);
    work(root);
    t=gcd(ans,n*n);
    printf("%d/%d\n",ans/t,n*n/t);
    return 0;
}
```

---

## 作者：huangwenlong (赞：1)

~~首先宣传下自己的博客：[【洛谷P2634／BZOJ2152】聪聪可可 | ssttkkl&#39;s OI zone](http://ssttkkl.top/posts/Luogu/2018/02/%E3%80%90%E6%B4%9B%E8%B0%B7P2634%EF%BC%8FBZOJ2152%E3%80%91%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/)~~

由于这题要统计是模3意义下的长度，完全可以用DP做。讲下和楼下不一样的DP方法，个人感觉比较容易理解。

树为有根树，令$f(v,k)$表示$v$的所有后代节点（包括$v$）中，到$v$的距离模3等于$k$的节点数量。容易得状转方程：

$$f(v,k)=\sum_{w \in v.son} f(w,(k-dist_{v,w})\;\mathrm{mod}\;3)$$

令$g(v,k)$表示$v$为根的子树里，经过$v$的长度模3等于$k$的路径数量，有下列状转方程：

$$g(v,k)=\sum_{i,j \in \mathbb{Z}^+,(i+j)\;\mathrm{mod}\;3=k} f(v,i) \times f(v,j)$$

其实就是对$\{f(v,0),f(v,1),f(v,2)\}$做模3卷积。（如果看不懂这句话可以自行忽略掉）

但是这样会出现重复：对于$v$的任意两个后代节点$i,j$，若$i$与$j$的LCA不是$v$的话，$i$与$j$的路径就不会经过$v$，但是它们也被卷到了一起。所以需要把$g(v,k)$再减掉$g(w,(k-2 \cdot dist_{v,w})\;\mathrm{mod}\;3)$，$w$为$v$的儿子。要注意的是这里的$g(w,(k-2 \cdot dist_{v,w})\;\mathrm{mod}\;3)$必须是**没有经过去重的**。（自己脑补一下就明白了）

于是写两个DFS，分别用作计算和去重。

最后答案就是$\frac{\sum_{i=1}^n g(i,0)} {n^2}$。

时间复杂度显然是线性的，比点分不知道高到哪里去了。

具体代码如下：（为了方便，DP用的是填表法）

```cpp
#include <iostream>
#define maxn 20005
using namespace std;
int n;
struct edge
{
    int next, to, weight;
} edges[maxn * 2];
int head[maxn];
void addedge(int u, int v, int w)
{
    static int ecnt = 0;
    ecnt++;
    edges[ecnt].to = v;
    edges[ecnt].weight = w;
    edges[ecnt].next = head[u];
    head[u] = ecnt;
}
int f[maxn][3], g[maxn][3];
void dfs1(int v, int fa)
{
    f[v][0] = 1;
    for (int i = head[v]; i; i = edges[i].next)
    {
        int w = edges[i].to;
        if (w != fa)
        {
            dfs1(w, v);
            f[v][edges[i].weight % 3] += f[w][0];
            f[v][(1 + edges[i].weight) % 3] += f[w][1];
            f[v][(2 + edges[i].weight) % 3] += f[w][2];
        }
    }
    g[v][0] += f[v][0] * f[v][0] + f[v][1] * f[v][2] * 2;
    g[v][1] += f[v][2] * f[v][2] + f[v][0] * f[v][1] * 2;
    g[v][2] += f[v][1] * f[v][1] + f[v][0] * f[v][2] * 2;
}
void dfs2(int v,int fa)
{
    for (int i = head[v]; i; i = edges[i].next)
    {
        int w = edges[i].to;
        if (w != fa)
        {
        	g[v][2 * edges[i].weight % 3] -= g[w][0];
        	g[v][(1 + 2 * edges[i].weight) % 3] -= g[w][1];
        	g[v][(2 + 2 * edges[i].weight) % 3] -= g[w][2];
            dfs2(w, v);
        }
    }
}
int gcd(int a, int b) { return (!b) ? a : gcd(b, a % b); }
int main()
{
    ios::sync_with_stdio(false);
    cin >> n;
    int u, v, w;
    for (int i = 1; i < n; i++)
    {
        cin >> u >> v >> w;
        addedge(u, v, w);
        addedge(v, u, w);
    }

    dfs1(1, 0);
    dfs2(1, 0);

    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans += g[i][0];
    int d = gcd(ans, n * n);
    cout << ans / d << '/' << n * n / d << endl;
    return 0;
}
```


---

## 作者：殇雪 (赞：1)

点分治用来统计树上路径。


点分治的核心是分治。


我们选一个点，统计过该点的路径。然后分治每一颗子树。


我们如果选择重心的话，可以证明，最多递归logn次。


因为选择重心，我们每一次递归的子树节点数都要小于原树的一半，所以log级别。


那么我们如果统计过一点的时间是T(x)，则总时间为O（logn\*T(n)）

    
```cpp
    #include<bits/stdc++.h>
    #define N 20017
    #define eho(x) for(int i=head[x];i;i=net[i])
    using namespace std;
    int t[8];
    int it,x,y,w,n,ans,sum,siz[N],head[N],vis[N],f[N],net[N<<1],fall[N<<1],tot,cost[N<<1];
    #define sight(c) ('0'<=c&&c<='9')
    inline void read(int &x){
        static char c;
        for (c=getchar();!sight(c);c=getchar());
        for (x=0;sight(c);c=getchar())x=x*10+c-48;
    }
    int gcd(int x,int y) {
        if (!y) return x;return gcd(y,x%y);
    }
    inline void add(int x,int y,int w){
        fall[++tot]=y; net[tot]=head[x]; head[x]=tot; cost[tot]=w;
    } 
    void dfs(int x,int fa){
        siz[x]=1;eho(x) if (fall[i]^fa&&!vis[fall[i]]) dfs(fall[i],x),siz[x]+=siz[fall[i]];
    }
    void dfs2(int x,int fa){
        f[x]=sum-siz[x];
        eho(x) if (fall[i]^fa&&!vis[fall[i]]) f[x]=max(f[x],siz[fall[i]]),dfs2(fall[i],x);
        if (f[it]>f[x]) it=x;
    }
    void dfs3(int x,int fa,int to){
        t[to]++;
        eho(x) if (fall[i]^fa&&!vis[fall[i]]) dfs3(fall[i],x,(to+cost[i])%3);
    }
    int cal(int x,int val) {
        t[1]=t[2]=t[0]=0;
        dfs3(x,0,val%3);
        return t[1]*t[2]*2+t[0]*t[0];
    }
    void sol(int pos){
        dfs(pos,0);sum=siz[pos];it=0;
        dfs2(pos,0);pos=it;ans+=cal(pos,0);vis[pos]=1;
        eho(pos)if (!vis[fall[i]]){
            ans-=cal(fall[i],cost[i]);
            sol(fall[i]);
        }
    }
    int main () {
        read(n);
        for (int i=1;i<n;i++) {
            read(x),read(y),read(w);w%=3;
            add(x,y,w); add(y,x,w);}
        f[0]=n;
        sol(1);
        int t=gcd(ans,n*n);
        printf("%d/%d\n",ans/t,n*n/t);
    }
```
再说一个非常迷的事情：

```cpp
    void solve(int u)
    {
        ans+=calc(u,0);
        vis[u]=1;//将当前点标记
        for(int i=h[u];i;i=e[i].next)
        {
            int v=e[i].to;
            if(vis[v]) continue;
            ans-=calc(v,e[i].w);
            root=0;//初始化根  
            sum=son[v];//初始化sum，注意这里的sum不一定是子树的大小
            getroot(v,0);//找连通块的根
            solve(root);//递归处理下一个连通块
        }
    }
```
那么有一个问题，我们每次分出一个重心后，
可能有一颗子树是向上的，但这样写就统计不出向上的那颗子树的正确的大小

，但是我们的点分治只是跟时间复杂度有关，与答案无关，所以总是能跑出正确的答案，

而多次尝试可以证明，这样用向下的子树大小来取代真实的子树大小，在一般数据下是没有关系的

（由于向上的子树每次都期望按一定比例缩小，所以还是保证log级别的复杂度）。

但我不知道会不会存在特殊数据使这种写法退化成O(N^2)。（有大佬知道的话请告诉我），

但总之这种写法总是让新学者很迷（比如我），

所以出来解释一下。


---

## 作者：奇卡 (赞：0)

这题为什么要点分治……

记录$f[x][0/1/2]$表示$x$的子树中的点到$x$的距离 mod 3 分别为0/1/2的点的个数，边转移边统计就行了

计算时先计算组合数，再统一乘2，也就不用讨论每个转移时要不要乘2的问题了

代码：

```cpp
#include <bits/stdc++.h>
#define N 20005
#define ll long long
using namespace std;

int head[N],f[N][3],g[3],cnt;
ll ans1=0,ans2;

struct ed{
    int v,nxt,w;
}e[N<<1];
void add(int u,int v,int w){
    e[++cnt]=(ed){v,head[u],w},head[u]=cnt;
    e[++cnt]=(ed){u,head[v],w},head[v]=cnt;
}
void dfs(int x,int fa){
    f[x][0]=f[x][1]=f[x][2]=0;
    for(int i=head[x];i;i=e[i].nxt){
        int to=e[i].v,w=e[i].w;
        if(to!=fa){
            dfs(to,x);
            g[0]=f[to][(3-w)%3],g[1]=f[to][(4-w)%3],g[2]=f[to][(5-w)%3];
            g[w]++;
            for(int j=0;j<3;++j)
                ans1+=1ll*g[j]*f[x][(3-j)%3];
            ans1+=1ll*g[0];
            f[x][0]+=g[0],f[x][1]+=g[1],f[x][2]+=g[2]; 
        }
    }
}
ll gcd(ll x,ll y){ return x%y?gcd(y,x%y):y; }

int main(){
    int n,i,a,b,c;scanf("%d",&n);
    for(i=1;i<n;++i){
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c%3);
    }
    ans2=n*n;
    dfs(1,0);ans1=ans1*2+n;
    ll p=gcd(ans1,ans2);ans1/=p,ans2/=p;
    printf("%lld/%lld\n",ans1,ans2);
}
```





---

## 作者：iyanhang (赞：0)

该题属于点分治的模板题，但在答案统计上要研究注意：
```
t[1]*t[2]*2+t[0]^2
```
依照乘法原理：

*2意味着始末节点相反的两条路径，t[0]^2意味着可选取的起点终点都有t[0]种。

```c++
#include <bits/stdc++.h>
using namespace std;
const int inf=1e9+7;
const int MN=20005;

struct edge{int v,w,next;}G[MN*2];
int head[MN],cnt=1;
inline void add(int u,int v,int w){G[cnt]=(edge){v,w,head[u]};head[u]=cnt++;}

int son[MN],d[MN],maxf=inf,root,ans=0,sum,buc[4]/*means a bucket*/;
bool vis[MN];
void getroot(int x,int fa)
{
	int f=0;son[x]=1;
	for (int i=head[x];i;i=G[i].next)
		if (!vis[G[i].v]&&G[i].v!=fa)
		{
			getroot(G[i].v,x);
			son[x]+=son[G[i].v];
			f=max(f,son[G[i].v]);
		}
	f=max(f,sum-son[x]);
	if (maxf>f) maxf=f,root=x;
}
void getdeep(int x,int fa)
{
	buc[d[x]%=3]++; //put this sentence here in order to coordinate.
	for (int i=head[x];i;i=G[i].next)
		if (!vis[G[i].v]&&G[i].v!=fa)
		{
			d[G[i].v]=d[x]+G[i].w;
			getdeep(G[i].v,x);
		}
}
int cal(int x,int w)
{
	d[x]=w;buc[0]=buc[1]=buc[2]=0;
	getdeep(x,0);
	return buc[0]*buc[0]+buc[1]*buc[2]*2;
}
void solve(int x)
{
	ans+=cal(x,0);vis[x]=true;
	for (int i=head[x];i;i=G[i].next)
		if (!vis[G[i].v])
		{
			ans-=cal(G[i].v,G[i].w);
			maxf=inf;
			sum=son[G[i].v]; //notice!
			getroot(G[i].v,0);
			solve(root);
		}
}

int gcd(int a,int b){return a%b!=0?gcd(b,a%b):b;}
int main()
{
	int n;cin>>n;
	for (int i=1;i<=n-1;++i)
	{
		int x,y,z;cin>>x>>y>>z;
		add(x,y,z);add(y,x,z);
	}
	sum=n;
	getroot(1,0);
	solve(root);
	int d=gcd(ans,n*n);
	cout<<ans/d<<"/"<<n*n/d;
	return 0;
}
```

---

## 作者：KingBenQi (赞：0)

这厮是点分治的模板题，只需在calc函数稍作修改就行了
把t[x]记作是余数是x的个数
```
#include<bits/stdc++.h>
using namespace std;
const int Max = 20005;
int n,k;
struct Edge{
    int next,to,w;
}e[Max<<1];
int cnt,ans,root,sum;
int head[Max],size[Max],maxson[Max],Depth[Max],deep[Max],t[10];
bool vis[Max];
int gcd(int a,int b){return b==0?a:gcd(b,a%b);}
void Add(int u,int v,int w){
    e[++cnt].next=head[u];
    e[cnt].to=v;
    e[cnt].w=w; 
    head[u]=cnt;
}
void getroot(int u,int fa){
    size[u]=1;maxson[u]=0;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa||vis[v])continue;
        getroot(v,u);
        size[u]+=size[v];
        maxson[u]=max(maxson[u],size[v]);
    }
    maxson[u]=max(maxson[u],sum-size[u]);
    if(maxson[u]<maxson[root])root=u;
}
void getdeep(int u,int fa){
    t[Depth[u]]++;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(vis[v]||v==fa) continue;
        Depth[v]=(Depth[u]+e[i].w)%3;
        getdeep(v,u);
    }
}
int calc(int u,int now){
    t[0]=t[1]=t[2]=0;
    Depth[u]=now;
    getdeep(u,0);
    return t[0]*t[0]+t[1]*t[2]*2;
}
void Work(int u){
    ans+=calc(u,0);
    vis[u]=1;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(vis[v]) continue;
        ans-=calc(v,e[i].w);
        sum=maxson[v];
        root=0;
        getroot(v,root);
        Work(root);
    } 
}
void pre(){
    root=0;cnt=0;ans=0;
    memset(vis,0,sizeof(vis));
    memset(head,0,sizeof(head));
}
int main(){
    ios::sync_with_stdio(false);
    pre();
    cin>>n;
    for(int i=1,u,v,w;i<n;i++){
        cin>>u>>v>>w;
        Add(u,v,w%3);Add(v,u,w%3); 
    }
    sum=n;maxson[0]=n;
    getroot(1,0);
    Work(root);
    int all=n*n;
    int big=gcd(all,ans);
    cout<<ans/big<<"/"<<all/big<<endl;
    
    return 0;
}

```

---

## 作者：Log_x (赞：0)

一道裸的**树分治**

令节点 i 到当前分治的节点的距离为 dis[i] ，对于任意一个满足条件的点对 [i,j] ，有 (dis[i] + dis[j]) % 3 = 0

我们将所有点的 dis[] 值对 3 取余，统计出取余后结果为 0,1,2 的个数，记为 num[0], num[1], num[2]。

那么，对于子树中任意的一个节点 i ：

1）dis[i] % 3 = 0 时：当前符合条件的点对数为 num[0]（即同为 3 的倍数）；

2）dis[i] % 3 = 1 时：当前符合条件的点对数为 num[3 - 1 = 2] 。

（证明：将 dis[i] 拆成 3x + 1，满足条件的另一个点的距离 dis[j] 拆成 3y + 2，则和为 3x + 1 + 3y + 2 = 3x + 3y + 3 = 3(x + y + 1)，是 3 的倍数）

3）dis[i] % 3 = 2 时：当前符合条件的点对数为 num[3 - 2 = 1] 。（证明同上）

以上情况可合并为 cnt += (!dis[i] ? num[0] : num[3 - dis[i]])（cnt 为记录的答案，dis[i] 已经对 3 取余过）

**代码如下：**













```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int Maxn = 0x3f3f3f3f;
const int N = 2e4 + 5, M = N << 1;
int T, n, num[3], dis[N], fa[N], lst[N], son[N], sze[N], nxt[M], to[M], cst[M];
int Ans; bool vis[N];
template <class T> inline void CkMax(T &a, const T b) {if (a < b) a = b;}
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void add(const int x, const int y, const int z)
{
    nxt[++T] = lst[x]; lst[x] = T; to[T] = y; cst[T] = z;
}
inline int FindG(const int sv)
{
    static int Qn, Q[N];
    int x, y, mx = n, G;
    Q[Qn = 1] = sv; fa[sv] = 0;
    for (int i = 1; i <= Qn; ++i)
    {
        sze[x = Q[i]] = 1; son[x] = 0;
        for (int e = lst[x]; e; e = nxt[e])
        {
            if (vis[y = to[e]] || y == fa[x]) continue;
            Q[++Qn] = y; fa[y] = x;
        }
    }
    for (int i = Qn; i >= 1; --i)
    {
        x = Q[i]; y = fa[x]; 
        CkMax(son[x], Qn - sze[x]);
        if (son[x] < mx) G = x, mx = son[x];
        if (!y) break; sze[y] += sze[x];
        CkMax(son[y], sze[x]);
    }
    return G;
}
inline int Calc(const int sv, const int L)
{
    static int Qn, Q[N], d[N]; 
    int x, y, dn = 0;
    Q[Qn = 1] = sv; dis[sv] = L; fa[sv] = 0;
    for (int i = 1; i <= Qn; ++i)
    {
        d[dn++] = dis[x = Q[i]];
        for (int e = lst[x]; e; e = nxt[e])
        {
            if (vis[y = to[e]] || y == fa[x]) continue;
            fa[y] = x; dis[y] = dis[x] + cst[e]; Q[++Qn] = y;
        }
    }
    int cnt = 0; memset(num, 0, sizeof(num));
    for (int i = 0; i < dn; ++i) num[d[i] %= 3]++;
    for (int i = 0; i < dn; ++i) cnt += (!d[i] ? num[0] : num[3 - d[i]]);
    return cnt;
}
inline void solve(const int x)
{
    int G = FindG(x), y;
    vis[G] = true; Ans += Calc(G, 0);
    for (int i = lst[G]; i; i = nxt[i])
     if (!vis[y = to[i]]) Ans -= Calc(y, cst[i]);
    for (int i = lst[G]; i; i = nxt[i])
     if (!vis[y = to[i]]) solve(y);
}
inline int Gcd(int a, int b)
{
    int r = a % b;
    while (r)
     a = b, b = r, r = a % b;
    return b;
}
int main()
{
    int x, y, z;
    n = get();
    for (int i = 1; i < n; ++i)
    {
        x = get(); y = get(); z = get() % 3;
        add(x, y, z); add(y, x, z);
    }
    solve(1);
    int Gc = Gcd(Ans, n *= n);
    put(Ans / Gc), putchar('/');
    put(n / Gc), putchar('\n');
    return 0;
}

```

---

## 作者：QJLYH (赞：0)

```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<vector>
using namespace std;
const int INF=99999999;
const int MAXN=100010;
struct node
{
    int next;
    int to;
    int w;
} t[MAXN];
bool vis[MAXN];
int head[MAXN],num;
int siz[MAXN],f[MAXN];
int lk[4];
int dis[MAXN];
int n,Num,rt;
int ans;
void add(int x,int y,int z)
{
    t[ ++num ].next=head[ x ];
    t[ num ].to=y,t[ num ].w=z;
    head[ x ]=num;
}
void Gr(int k,int fa)//寻找根节点,根节点满足最大儿子子树规模最小 
{
    siz[ k ]=1,f[ k ]=0;
    for(int i=head[ k ],x; i ;i=t[ i ].next)
    {
        x=t[ i ].to;
        if( x!=fa && !vis[ x ] )
        {
            Gr( x,k );
            siz[ k ]+=siz[ x ];//子树规模 
            f[ k ]=max( f[ k ],siz[ x ] );
        }
    }
    f[ k ]=max( f[ k ],Num-siz[ k ] );
    if( f[ k ]<f[ rt ] )   rt=k;
}
void Gd(int k,int fa)//获得每个点到cal中的k的距离，即rt 
{
    lk[ dis[ k ] ]++;
    for(int i=head[ k ],x; i ;i=t[ i ].next)
    {
        x=t[ i ].to;
        if( x!=fa && !vis[ x ] )
        {
            dis[ x ]=( dis[ k ]+t[ i ].w )%3;
            Gd( x,k );
        }
    }
}
int cal(int k,int w)
{
    dis[ k ]=w%3,lk[ 0 ]=lk[ 1 ]=lk[ 2 ]=0;
    //lk[ 0 ]表示到k的距离%3=0的点的个数,lk[ 1 ]表示余数为1,lk[ 2 ]表示余数为2,所以计算方案数时,lk[ 0 ]内部解决,lk[ 1 ]和lk[ 2 ]两两搭配 
    Gd( k,0 );
    return lk[ 0 ]*lk[ 0 ]+2*lk[ 1 ]*lk[ 2 ];
}
void work(int k)
{
    ans+=cal( k,0 ),vis[ k ]=1;
    for(int i=head[ k ],x; i ;i=t[ i ].next)
    {
        x=t[ i ].to;
        if( !vis[ x ] )
        {
            ans-=cal( x,t[ i ].w );
            Num=siz[ x ],rt=0;
            Gr( x,0 ),work( rt );
        }
    }
}
void print(int x,int y)
{
    int a=x,b=y,cs=x%y;
    while( cs )
    {
        a=b,b=cs,cs=a%b;
    }
    printf("%d/%d\n",x/b,y/b);
}
int main()
{
    int x,y,z;
    scanf("%d",&n);
    for(int i=1; i<=n-1; i++)
    {
        scanf("%d%d%d",&x,&y,&z),z=z%3;
        add( x,y,z ),add( y,x,z );
    }
    f[ 0 ]=INF,Num=n;
    Gr( 1,0 );
    work( rt );
    print( ans,n*n );
    return 0;
}

```

---


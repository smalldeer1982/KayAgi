# 电阻网络

## 题目背景

什么是电阻?这个大家应该都知道。什么是电路?大家也应该知道。但是本题当中，电路的定义或许有点不同：

电路都带有正、负极接点，正极在左，负极在右。具体地：电路分为以下几类：

单独的一个1Ω电阻(及其两端的接点)是电路(虽然导线也可以被视为0Ω的电阻，但是单独的导线不是电路)

如果A和B都是电路，设1,2,3是从左到右的三个接点，那么将A的正负极分别接在1与2上，将B的正负极分别接在2与3上，那么1到3的部分是电路，其中1为正极，3为负极。

如果A和B都是电路,设1,2,3,2',3',1’是六个接点，其中1在2和3的左侧，2在2’的左侧，3在3’的左侧，2,和3,在1’的左侧，并且1与2，1与3，2’与1’，3’与1’间均连有导线, 那么将A的正负极分别接在2与2’上，将B的正负极分别接在3与3’上，那么1到1'的部分是电路，其中1为正极，1’为负极。

现在给出一个电路，求它正负极之间的电阻。


## 题目描述

Cjwssb最近在物理学科上遇到了难题，他不会计算一个电路中的总电阻，现在他找到了你，希望你能帮助他。

这个电路有如下限定

1、    电路只由导线以及电阻为一欧的电阻组成

2、    保证电路从左到右连接，即每个电阻或导线的两个连接点xy保证x<y

3、    保证接线柱1为电源正极，接线柱n为电源负极

4、    保证每个接线柱只会被串联或者并联两个分支电路或者不接任何电线或电阻


## 说明/提示

样例解释

画出图来，答案是显然的。

数据规模与约定

对于20%的数据n≤5,m≤5。

对于50%的数据n≤100,m≤120。

对于70%的数据n≤1,000,m≤1200。

对于100%的数据n≤100,000,m≤120000

数据是在人工指定的n下随机生成的，保证答案不会超过10.000。

By：saffah


## 样例 #1

### 输入

```
7 7
1 2 0
1 3 0
2 4 1
3 5 1
4 6 0
5 6 0
6 7 1
```

### 输出

```
1.500```

# 题解

## 作者：worcher (赞：15)

分治+模拟


模拟一下总电阻的计算方式就行，遇到并联的就进入下一层递归，电路可能短路，即出现电阻为0


---

## 作者：七碳烷烃 (赞：10)

突然发现这道题居然没人写题解，既然这样那我就~~水~~贡献一篇题解吧。  
顺便一提，感觉这道题的题面有点模糊且不标准。
### 题目概要
给定一个电路，其中有$n$个接线柱和$m$个电阻，其中阻值只有$0$和$1\Omega$两种情况。我们需要求出整个电路从接线柱$1$到接线柱$n$的**等效电阻值**。  
### 题目分析
观察题目描述，我们可以看到四个规则：
 1. 电路只由导线和阻值为1的电阻组成。
 2. 保证电路**从左到右连接**，保证给出的两个接点x和y符合x<y。
 3. 保证接线柱$1$为**电源正极**，接线柱$n$为**电源负极**。
 4. 保证每个接线柱只会**被串联**或者**并联两个分支电路**或者不接任何电线或电阻。  
    
看到以上条件不难得到，**任意一个电阻或导线上的电流一定是从接线柱x流向接线柱y的**。再观察题目背景中的信息，画出图来，我们会发现任何一个接线柱的出度都不大于2。那么以电流方向为有向图的方向，以接线柱为节点，以边为电阻或导线建立出一个有向图（根据题目描述，图中一定没有环）。 

------------

### 题解部分
我们考虑使用递归方式合并**当前接线柱连接的子电路**为一个等效电阻，然后将两个电阻合并为一个电阻。
## 建图
首先还是给出结构体的代码吧：
```cpp
struct Link { // 一个电阻连接
    int to; // 连接到的接线柱编号
    double r; // 阻值
};
struct Node { // 一个接线柱
    int linkCount = 0;
    Link links[2];
} node[100005];
```
建图部分代码将在最后给出。
## 合并电阻
这里是最难也最核心的部分了，我们先设计出一个可能的函数原型：
```cpp
void mergeSubcricut(int p, int e)
```
其中“接线柱p”为我们要合并的**电路的正极**，“接线柱e”为**电路的负极**。我们就先假设这个函数可以把“接线柱p”到“接线柱e”中间的电路合并成一个等效电阻。  
### 串联
![串联电路示意图](https://cdn.luogu.com.cn/upload/image_hosting/v9do1go3.png)  
在这里“子电路a”（这里确定是一个电阻或导线）与“子电路b”（可能是复合电路）串联。“子电路a”的阻值已知，我们只需要再**合并“子电路b”** 为一个等效电阻即可。  
```cpp
if(node[p].linkCount == 1) {
        // 如果下一个是e（终点），我们就返回
        if(node[p].links[0].to == e) return;
        // 递归合并下一个接线柱的子电路
        mergeSubcricut(node[p].links[0].to, e);
        // 下一个接线柱的子电路已经被合并成了一个电阻
        // 计算两段的电阻，并合并两个电阻
        node[p].links[0].r += node[node[p].links[0].to].links[0].r;
        node[p].links[0].to = node[node[p].links[0].to].links[0].to;
    }
```
合并完成后，将两个电路的电阻相加，即为“接线柱p”到“接线柱e”的**等效电阻阻值**。  

如果“接线柱p”的下一个接线柱就是“接线柱e”，那么说明这中间一段的电路已经被合并成了一个等效电阻了，不需要合并了，此时应直接返回。

### 并联
![并联](https://cdn.luogu.com.cn/upload/image_hosting/72lxuhyp.png)  

这种情况比较麻烦，我们需要分别合并“子电路a2”和“子电路b2”，但是我们发现，两者的**汇聚点并不在“接线柱e”上**。

在这种情况下，我们就需要**获取到获取到并联电路的汇点**（假定为“接线柱ep”），然后单独把“子电路a2”到“接线柱ep”的部分和“子电路b2”到“接线柱ep”的部分跑一遍合并。因为编号大的一定在编号小的接线柱的前面，所以可以通过比较深度来比较两个点的“深度”。
```cpp
int endPoint(int a, int b) {
    // printf("Finding End Point of %d %d\n", a, b);
    // 由于编号大的一定在右边，可以通过比较编号找到两个点往后走的终结点
    while (a != b) {
        if(a > b) {
            b = node[b].links[0].to;
        } else {
            a = node[a].links[0].to;
        }
    }
    return a;
}
```

合并后的情况如下：

![第一次合并后](https://cdn.luogu.com.cn/upload/image_hosting/99c19rdt.png)  

这里就可以很容易地把“子电路a1,a2”和“子电路b1,b2”**分别合并成两个等效电阻**了，合并后根据初中的并联电路计算公式计算即可：
$$
R=\frac{R_1R_2}{R_1+R_2}
$$
合并后的图像如下：

![第二次合并后](https://cdn.luogu.com.cn/upload/image_hosting/jn8kzyqx.png)  
这里我们会发现，**整个电路变成和串联一样的情况了！**  

既然这样，我们只需要在执行完以上合并流程后，重新跑一遍从“接线柱p”到“接线柱e”的合并即可。这样就可以把这一部分电路合并成一个等效电阻了。  

至此，所有的函数执行工作就结束了，在构建完成之后，我们只需要用这个函数将整个电路合并成一个电阻：
```cppn
mergeSubcricut(1, n);
```
最后输出这个等效电阻的阻值即可。

所有的内容的具体的实现代码在这里给出：
## AC代码
```cpp
/* Headers */
#include <cstdio>
#include <iostream>
#include <vector>
#include <list>
using namespace std;
/* Type and variables */
int n, m;
struct Link { // 一个电阻连接
    int to;
    double r; // 电阻
};
struct Node { // 一个接线柱
    int linkCount = 0;
    Link links[2];
} node[100005];
/* Functions */

int endPoint(int a, int b) {
    // printf("Finding End Point of %d %d\n", a, b);
    // 由于编号大的一定在右边，可以通过比较编号找到两个点往后走的终结点
    while (a != b) {
        if(a > b) {
            b = node[b].links[0].to;
        } else {
            a = node[a].links[0].to;
        }
    }
    return a;
}
// 合并从p到e的子电路
void mergeSubcricut(int p, int e) {
    if(p == e) return; // 同一个接线柱就不需要合并了
    if(node[p].linkCount == 1) {
        // 如果下一个是e（终点），我们就返回
        if(node[p].links[0].to == e) return;
        // 递归合并下一个接线柱的子电路
        mergeSubcricut(node[p].links[0].to, e);
        // 下一个接线柱的子电路已经被合并成了一个电阻
        // 计算两段的电阻，并合并两个电阻
        node[p].links[0].r += node[node[p].links[0].to].links[0].r;
        node[p].links[0].to = node[node[p].links[0].to].links[0].to;
    } else if(node[p].linkCount == 2) {
        int subEnd = endPoint(node[p].links[0].to, node[p].links[1].to);
        // 分别递归合并下面两个接线柱的子电路
        mergeSubcricut(node[p].links[0].to, subEnd);
        mergeSubcricut(node[p].links[1].to, subEnd);
        // 下两个接线柱的子电路已经被合并成了两个电阻
        node[p].links[0].r += node[node[p].links[0].to].links[0].r;
        node[p].links[0].to = node[node[p].links[0].to].links[0].to;
        node[p].links[1].r += node[node[p].links[1].to].links[0].r;
        node[p].links[1].to = node[node[p].links[1].to].links[0].to;
        node[p].linkCount = 1;
        // 计算电阻
        node[p].links[0].r = (node[p].links[0].r * node[p].links[1].r) / (node[p].links[0].r + node[p].links[1].r);
        // 考虑两个电阻阻值都为0的情况
        if(node[p].links[0].r + node[p].links[1].r < 0.0000001)
            node[p].links[0].r = 0.0;
        mergeSubcricut(p, e);
    }
}
/* Main */
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++) {
        int u, v; double r;
        scanf("%d%d%lf", &u, &v, &r);
        node[u].links[node[u].linkCount++] = {v, r};
    }
    mergeSubcricut(1, n); // 合并从1到n的电路
    printf("%.3f", node[1].links[0].r);
    return 0;
}
```


---

## 作者：flrs (赞：7)

```cpp
//原题解实在看不下去了，打了很久的程序了，很多都忘了，也懒得再看了，求原谅……
//AC代码如下
//没有任何优化，大佬勿喷
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int count;
int p[120001][3][2];
int pc[120001];
int r[120001];
double ans[120001];
int same(int a,int b)//找并联的结束点
{
	do
	{
		if(a<b) 
			b=p[b][1][1];
		else a=p[a][1][1];
	}while(a!=b);
	return a;
}
double cal(int num)//老师吧这道题放在递归训练里让我们做的 所以……
{
	if(ans[num]) return ans[num];
	if(pc[num]>1)
	{
		int samep=same(p[num][1][1],p[num][2][1]);
		ans[num]=1.0/(1.0/(cal(p[num][1][1])-cal(samep)+p[num][1][0])+1.0/(cal(p[num][2][1])-cal(samep)+p[num][2][0]))+cal(samep);
		return ans[num];
	}
	else if(pc[num])
	{
		ans[num]=cal(p[num][1][1])+p[num][1][0];
		return ans[num];
	}
	else return ans[num]=0;
}

int main()
{
	//freopen("testdata.in","r",stdin);
	int temp1,temp2,tempr;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&temp1,&temp2,&tempr);
		p[temp2][++pc[temp2]][0]=tempr;
		p[temp2][pc[temp2]][1]=temp1;
	}
	printf("%.3lf",cal(n));
	//for(int i=1;i<=n;i++)cout<<ans[i]<<' '<<pc[i]<<endl;
}
```

---

## 作者：panyf (赞：2)

记 $work(s,t)$ 表示从 $s$ 到 $t$ 的电阻。

首先将原图中无法到达 $n$ 的点和与其关联的边删掉。

根据题目性质，每个点至多两条出边。

如果 $s$ 只有一条出边 $s\to l$，权值为 $u$，那么 $work(s,t)=u+work(l,t)$。

否则若还有一条出边 $s\to r$，权值为 $v$，那么求出 $s\to l$ 和 $s\to r$ 相交的位置记为 $o$：

$$work(s,t)=\dfrac{1}{\dfrac{1}{work(l,o)+u}+\dfrac{1}{work(r,o)+v}}+work(o,t)$$

现在瓶颈是如何快速求 $o$。

因为这题数据随机，可以暴力求。

数据不随机怎么办？倍增即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3;
int l[N],r[N],u[N],v[N],d[N],f[N][19];
int lca(int x,int y){
	int i;
	if(d[x]<d[y])swap(x,y);
	for(i=18;~i;--i)if(d[f[x][i]]>=d[y])x=f[x][i];
	if(x==y)return x;
	for(i=18;~i;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
double work(int s,int t){
	if(s==t||!d[s])return 0;
	if(!d[r[s]])return u[s]+work(l[s],t);
	int o=lca(l[s],r[s]);
	return 1/(1/(work(l[s],o)+u[s])+1/(work(r[s],o)+v[s]))+work(o,t);
}
int main(){
	int n,m,i,j,k;
	scanf("%d%d",&n,&m),d[n]=1;
	while(m--)if(scanf("%d%d%d",&i,&j,&k),!l[i])l[i]=j,u[i]=k;else r[i]=j,v[i]=k;
	for(i=n-1;i;--i){
		if(!d[l[i]])l[i]=r[i],r[i]=0,u[i]=v[i];
		if(d[l[i]]){
			d[i]=d[l[i]]+1,f[i][0]=l[i];
			for(j=0;f[i][j];++j)f[i][j+1]=f[f[i][j]][j];
		}
	}
	printf("%.3lf",work(1,n));
	return 0;
}
```


---

## 作者：yegengghost (赞：1)

[九年级以下的福利。](https://jc.pep.com.cn/)

[对于电阻的常识。](https://www.luogu.com.cn/paste/deipq3qc)

首先化一下答案：

$$R_{general}= \sum_{i = 1}^{n} R_i$$

~~好像没啥用~~这是因为我们不确定每一部分的电阻为多少。那么就要上分讨了。

总的来说，从上述公式可以知道我们主要是要把串联电路的电阻累加，所以先解决这个。

面对串联电路，我们把出度为 $1$ 的电阻给累加起来即可。

那么剩下的部分就得用并联时总电阻的公式来解决。

这个公式直接这么写上去就可以了。因为它可以解决并联电路中的短路事件，从而使得分子乘积为 $0$，符合预期（这个自己查吧）。

实现方式就得依靠递归。

我们发现，处理整条电路就是从第一个点到最后一个点上的遍全累加起来，汇总成一个总电阻，而处理并联电路时也可以看成是把分点与合点之间的线路汇总成一个并联总电阻。

那么我么就可以定义函数 ```deal(int s,int t)``` 表示合并从 $s$ 到 $t$ 的电路后总电阻为多少。当遇到出度为二的点 $i$ 时，我们再用一个函数 ```find_hd``` 来找并联电路的合点 $j$，找到后再调用 ```deal(i,j)``` 找后面是否还有并联中的并联，最后回溯累加答案即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
const int mod=1;
int n,m;
int head[N],nxt[N],ver[N],ed[N];
int cd[N];
int cnt=1;
//啊 vis 也是处理并联的。
void adj(int s,int e,int d)//用链式前向星建立一条单向边
{
	cd[s]++;
	//存储出入度便于判定并联
	ver[++cnt]=e;//啊米诺斯，这里写了个cnt++0分了NaN次
	nxt[cnt]=head[s];
	head[s]=cnt;
	ed[cnt]=d;
}
//对于并联操作找合点
int vis[N];
priority_queue<int>heap;
int find_hd(int num)//find 汇点
{
	for(int i=head[num];i;i=nxt[i])
	{//美妙的链式前向星
		if(!vis[ver[i]])
		{
			heap.push(-ver[i]);//zhx:小根堆便捷存法
			vis[ver[i]]=1;
		}
	}
	while(heap.size()!=1)
	{//找合点
		int t1=-heap.top();
		heap.pop();
		vis[t1]=0;
		for(int i=head[t1];i;i=nxt[i])
			if(!vis[ver[i]])
			{
				vis[ver[i]]=1;//直接找入度也未尝不可，但是我们也可以通过找是否有边被经过2次来找合点
				heap.push(-ver[i]);
			}
	}
	int pos=-heap.top();
	heap.pop();
	vis[pos]=0;
	return pos;
}
double deal(int s,int t)
{
	double ans=0,r1,r2;
	int i=s,j;
	while(i!=t)
	{
		if(cd[i]==1)
		{
			ans+=ed[head[i]];
			i=ver[head[i]];
			//printf("该串联电路的总电阻为%.3f Ω，电路总电阻为%.3f Ω\n,目前移动到了第%d个位置\n",ed[head[i]],ans,i);
		}
		else if(cd[i]==2)//并联
		{
			j=find_hd(i);//找到汇点
			//printf("该并联电路的分点为%d,合点为%d,{\n",i,j);
			r1=deal(ver[head[i]],j)+ed[head[i]];//求出两条支路的电阻分别是什么
			r2=deal(ver[nxt[head[i]]],j)+ed[nxt[head[i]]];
			//printf("%.3f\n",r1*r2/(r1+r2));
			ans+=r1*r2/(r1+r2);
			//直接套公式
			//printf("}\n该并联电路的分点为%d,合点为%d,并联总电阻为%.3f Ω，总电阻为%.3f Ω,",i,j,r1*r2/(r1+r2),ans);
			i=j;
			//printf("目前移动到了第%d个位置\n",i);
		}
	}
	return ans;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int s,e,d;
		cin>>s>>e>>d;
		adj(s,e,d);
	}
	//for(int i=1;i<=n;i++)
	//	cout<<i<<"的出度是："<<cd[i]<<"\n";
	printf("%.3f\n",deal(1,n));//将电路合并后的总电阻
	return 0;
}
```

---

## 作者：onglu (赞：1)

# 题解  
在题目列表里搜网络流的时候看到这道题，顺便就写了。。。  
~~结果不是网络流~~  


题意挺简单的，就是一个电阻电路，求解电阻。  

其实题目已经给了很多简化条件了~~数据也比较水~~，看了一会儿也能想到解法。  

首先题目中限制了只有一层并联，于是可以分别计算两个子电路的阻值，然后总阻值就是$\frac{R_1R_2}{R_1+R_2}$。  

可以用$get(x, y)$计算$x$点到$y$点的阻值，递归流程就是沿着电路往后走，如果是串联（出度为1），就加上这条导线（电阻）的阻值，然后往后走一格。  

如果遇到并联电路，就预先找出并联电路的汇合点$k$，然后分别沿着两条导线走一步到达$x_1,y_1$然后$R_1 = get(x_1, k), R_2 = get(x_2, k)$。然后再直接跳到汇合点就行了。  

如何找出汇合点呢，我是采用了一个优先队列，每次取出编号小的点进行拓展，重复点不拓展，如果只剩一个点说明是汇合点。

按理说我这个复杂度最坏应该有$O(n^2logn)$，但是可能数据水了或者有某种数学关系导致达不到这个复杂度，反正算法复杂度就是$O(能过)$。  
# 代码
```cpp
#include <bits/stdc++.h>
#define int int
#define Mid ((l + r) >> 1)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
int read(){
	char c; int num, f = 1;
	while(c = getchar(),!isdigit(c)) if(c == '-') f = -1; num = c - '0';
	while(c = getchar(), isdigit(c)) num = num * 10 + c - '0';;
	return f * num;
}
const int N = 2e5 + 1009;
int in[N], out[N], n, m;
int head[N], nxt[N], ver[N], edge[N], tot = 1;
void add(int x, int y, int w){
	in[y]++; out[x]++;
	ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot; edge[tot] = w;
}
int vis[N];
priority_queue<int>q;
int getend(int qwq){
	for(int i = head[qwq]; i; i = nxt[i])if(!vis[ver[i]]){
		q.push(-ver[i]);
		vis[ver[i]] = 1;
	}
	while(q.size() != 1){
		int x = -q.top(); q.pop(); vis[x] = 0;
		for(int i = head[x]; i; i = nxt[i]){
			if(!vis[ver[i]]){
				vis[ver[i]] = 1;
				q.push(-ver[i]);
			}
		}
	}
	int x = -q.top(); q.pop();
	vis[x] = 0;
	return x;
}
double get(int s, int t){
	double sum = 0, t1, t2;
	int j, i;
	i = s;
	while(i != t){
		if(out[i] == 1){
			sum += edge[head[i]];
			i = ver[head[i]];
		}else if(out[i] == 2){
			j = getend(i);
			t1 = get(ver[head[i]], j) + edge[head[i]];
			t2 = get(ver[nxt[head[i]]], j) + edge[nxt[head[i]]];
			sum += t1 * t2 / (t1 + t2);
			i = j;
		}
	}
	return sum;
}
main()
{
	n = read(); m = read();
	for(int i = 1; i <= m; i++){
		int x = read(), y = read(), w = read();
		add(x, y, w);
	}
	printf("%.3f\n", get(1, n));
	return 0;
}
```

---


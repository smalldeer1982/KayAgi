# 【DSOI 2021】吟唱的金色花海

## 题目背景


**这是一道 IO 交互题。**

在很久很久以前，有一片开满了白色郁金香的花海。某一天，绽放了一朵金色郁金香，从此，这片花海开始了它永生的吟唱……

>   _(Dutch) $\textit{\textcolor{blue}{Het\ universum\ zingt\ voor\ mij!}}$_



## 题目描述

在某一时刻，在某处出现了一朵金色郁金香。然后接下来每一秒，每朵金色郁金香会向其上下左右四个点中所有白色郁金香吟唱，使其变为金色郁金香。

现在告诉你一个点 $(x_0,y_0)$，以及它自第一朵金色郁金香出现起，刚变成金色郁金香的那一秒 $t$，你需要找出最初出现的金色郁金香的位置。

每次你可以输出一行 `0 x y`,然后程序会返回一个值 $0$ 或 $1$，$0$ 表示 $(x,y)$ 在第 $t$ 秒是白色郁金香， $1$ 表示 $(x,y)$ 在第 $t$ 秒是金色郁金香。
你可以输出一行 `1 x y` 告知程序最初出现最初出现的金色郁金香的位置为 $(x,y)$ 以结束程序。

## 说明/提示

| 测试点编号 |     $k =$      | $t \le$ |  $Q=$  |
| :--------: | :------------: | :-----: | :----: |
|     1      |    $10000$     |   $1$   | $100$  |
|    2~3     |    $10000$     |   $5$   | $100$  |
|    4~6     |      $4t$      |  $100$  | $100$  |
|    7~10    | $2 \times MAX$ |  $100$  | $100$  |
|   11~14    |    $MAX+1$     | $10^4$  | $5000$ |
|   15~20    |     $MAX$      | $10^4$  | $5000$ |


每个测试点的分值均为 $5$ 分。

记:在最劣情况下询问 $MAX=\lceil\log_2(t+1)\rceil+2$ 次一定能得出答案。保证 $1 \le t \le 10^4$，$1 \le Q \le 5000$ 且得出的结果的 $x,y$ 的绝对值不大于 $10^5$。

***

提示：由于交互题的特性，若你的算法错误，评测结果为 **TLE** 属于正常现象，请将鼠标放在测试点上查看你的具体错误原因。具体的：
- 若你输出的结果错误，会返回 **You made a mistake in data i!**
- 若你询问了过多的次数，会返回 **You ask too many times in data i!**

## 样例 #1

### 输入

```
2
1 1 0 100

0

0

1

2 1 1 10000

1

1

1

1```

### 输出

```


0 1 1

0 1 -1

0 0 1

1 0 0

0 2 0

0 0 2

0 -2 0

0 0 -2

1 0 0```

# 题解

## 作者：VicXF_ (赞：3)

# 主要思路是分治

首先我们要建立起一个模型。

若 $(0,0)$ 为第 $ 6 $ 秒出现金色郁金香的地方，那么第一朵金色郁金香可能出现的地方在蓝点（距离出现点的曼哈顿距离为 $6$ 的点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/m9kju1aa.png?x-oss-process=image/resize,m_lfit,h_400,w_600)

* **如何询问？**

每询问一个点 $(x,y)$ ，就是在判断以该点为中心的斜45度正方形（也就是上图）的范围内（注意是范围，也就是整个面积）有没有第一朵金色郁金香。那么这个面积内包含的蓝点就可以被筛选。

* **为什么想到二分？**

对于每一次询问，我们最多只能排除一半的点或选择一半的点为第一朵金色郁金香的可能位置（原因应该不用赘述）。那么最少的最多询问次数就是 $logn$ 。但在第一次询问时，我们会发现无论询问哪个点都无法恰好询问一半的点，只能将点较平均地分成 $n/2-1$ 和 $n/2+1$ 两个部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/yjm8mewn.png?x-oss-process=image/resize,m_lfit,h_400,w_600)

如图，这次询问将可能的点分成了红色和黄色两部分。如果询问点是金色郁金香，那么可能点将在黄点中筛选；如果是白色郁金香，那就在红点中筛选。

再按这个思路，选出一半的点。在上图的情况再选一次后，我们发现**所有的点就都在一条斜直线上了**。对于单条直线的二分便可以使用递推求解了。也就是说，第一次和第二次询问是特殊判断，比较麻烦。

**第二次询问的方法：**

![](https://cdn.luogu.com.cn/upload/image_hosting/2nkqo6sl.png?x-oss-process=image/resize,m_lfit,h_400,w_600)

 _如图，黑色为之前被排除的点，蓝色的询问点将直线分为红色和黄色两条直线。_ 
 
**直线上的二分询问法：**

![](https://cdn.luogu.com.cn/upload/image_hosting/vul34hr0.png?x-oss-process=image/resize,m_lfit,h_400,w_600)

 _如图，黑色为之前被排除的点，蓝色的询问点将直线分为红色和黄色两条直线。_ 

* **直线上具体的实现方法(结合上图)**

用四个变量确定搜索的范围，分别代表：在 $(x,y)$ 处，向 $nul$ 方向的 $num$ 个点范围内搜索。其中， $nul$ 的值 $1,2,3,4$ 分别代表向 _右上，左上，左下，右下_ 搜索。注意，**在同一条直线中 $nul$ 的值不变**。再确定这条直线的中点 $(num+1)/2-1$ 便于二分(为什么是这个值可以自己推一下)。然后对于这条该搜索的直线，询问距离其中点曼哈顿距离为 $t$ 的点，并且询问点完全包含直线的一侧，完全不包含直线另一侧(具体见图)。所以**应询问 $(x \pm t/2,y \pm t/2)$处的点**，具体加还是减要看 $nul$ 的值。然后看返回的值，选择是在 $(x,y)$ 开始向 $nul$ 搜索 $num/2$ 个点(ask返回1时)，还是在中点开始向 $nul$ 搜索 $num/2$ 个点(ask返回0时)。如果 $num=1$ ，返回值即可。具体实现见代码。

**代码：**
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R read()
using namespace std;
inline ll R{  //快读
	ll x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int t,x,y,n,k,mo,T;
int ask(int x,int y){ //询问并返回0或1
	printf("0 %d %d\n",x,y);fflush(stdout);	
	mo=R;
	return mo;
}
void ser(int x,int y,int num,int nul){ 
	if(num==1){  //仅剩一个点，输出
		printf("1 %d %d\n",x,y);fflush(stdout);
		return;
	}
	int q=(num+1)/2-1;int ab=q-t/2;
	if(nul==1) //根据nul的值判断加减
		if(ask(x+ab,y+ab)) ser(x,y,q+1,1); //q+1=(num+1)/2
		else ser(x+q+1,y+q+1,num-q-1,1);	//白色，从中点开始
	else if(nul==2)
		if(ask(x-ab,y+ab)) ser(x,y,q+1,2);
		else ser(x-q-1,y+q+1,num-q-1,2);
	else if(nul==3)
		if(ask(x-ab,y-ab)) ser(x,y,q+1,3);
		else ser(x-q-1,y-q-1,num-q-1,3);
	else
		if(ask(x+ab,y-ab)) ser(x,y,q+1,4);
		else ser(x+q+1,y-q-1,num-q-1,4);
}
void ser1(int x,int y,int nul){ //第2次询问
	if(nul==1)
		if(ask(x-t,y)) ser(x,y,t,3);
		else ser(x+1,y-1,t-1,4);
	else
		if(ask(x-t,y)) ser(x,y,t+1,2);
		else ser(x+1,y+1,t,1);
}
int main(){
	T=R;
	while(T--){
		t=R;x=R;y=R;n=R;
		if(ask(x,y+1)) ser1(x,y+t,1); //金色，继续在范围内搜索
		else ser1(x,y-t,2);	//白色，在范围外搜索
	}
	return 0;
}
```
### 部分分(Water_tomato补充)

对于测试点 $1$，随便询问特判一下即可。

对于测试点 $2 \sim 3$，可以考虑询问出一整个大矩形，然后再用各种奇特的方式判定，具体自行考虑。

对于测试点 $4\sim6$，对于每一个可能的点，询问其上方距离为 $t$ 的点，注意询问的顺序一定要从最上方那个可能的点开始，顺时针或逆时针转一圈询问，容易证明一定能询问出来，具体实现请自行考虑。

对于测试点 $7\sim10$，是留给想到了正解思路但是一些地方打挂了导致询问次数略高的算法的。

对于测试点 $11\sim 14$，正解中提高了通过两次询问确定出该点位于那条边，而这部分分是留给前两次询问考虑不佳导致需要至多询问 $3$ 次才能确认位于哪条边的算法的（例如，前三次询问每一次都通过某些方法询问是否在其中一条边上），具体实现请自行考虑。

### 总结

其实算是很水的题()，主要难度在于想到如图的两个正方形相交和怎么问，~~然后随便打打就过啦！~~



---

## 作者：Suzt_ilymtics (赞：1)

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/solution-P7345.html)

[题目传送](https://www.luogu.com.cn/problem/P7345)

### 吐槽几句

私以为鄙人之题解略易之与其他两篇题解。

~~他们都写的太长了，那么多图根本看不下去，还是我的比较清晰，代码也十分好写。~~

### Solution

主要思想就是二分。

首先题目给你了位置 $(x_0, y_0)$ 和一个时间 $t$。

因为从某个起点 $(sx, sy)$ 扩展 $t$ 次后，$(x_0,y_0)$ 一定在它的边界上。

所以我们可以搞出这么一张图。

![](https://images.cnblogs.com/cnblogs_com/Silymtics/1892671/o_211003132031Tu1.jpg)

可能有的人看到这个图就瞬间明白了。下面再详细说一下。

根据这个图不难发现，我们只要找到 $(x_0,y_0)$ 的一个（关于 BD）的对称点 $F$，然后它到中点的距离 $l$ 可以求出，又因为我们知道了 $(x_0,y_0)$ 和 $(sx,sy)$ 的曼哈顿距离为 $t$，那我们就可以直接表示出 $(sx,sy)$。

那么这个点 $F$ 怎么求？想想那个 $MAX$ 值为什么带了一个 $\log$，就是让我们用二分啊。

因此这个 $F$ 的特征就是最远的被染成金色的郁金香，我们可以二分 $(x_0,y_0)$ 这个点向右走几步才能到达这个 $F$。

但是最远的时候是 $AD = 2t$，好像比需要的次数多 $1$。我们继续观察发现 $(x_0,y_0)$ 与 $F$ 的距离一定为偶数，所以二分的范围设为 $[1,t]$ 即可。

需要注意我们还要确定的一个信息是延伸的方向，这个可以通过分别询问它的右边和下边是否是金色郁金香得到。

所以总的询问次数为 $\log t + 2 \le MAX$，可以通过。

实现细节看代码吧。

### Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int T, t, sx, sy, k;

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

int main()
{
	T = read();
	while(T--) {
	    t = read(), sx = read(), sy = read(), k = read();
	    if(t == 0) {
	        printf("1 %d %d\n", sx, sy);
	        fflush(stdout);
	        continue;
        }
	    int fx1, fx2, x; // 1 表示上左，2 表示下右 
        printf("0 %d %d\n", sx + 1, sy);
        fflush(stdout);
        x = read();
        if(x) fx1 = 1; else fx1 = -1;
        printf("0 %d %d\n", sx, sy + 1);
        fflush(stdout);
        x = read();
        if(x) fx2 = 1; else fx2 = -1; // 用 1/-1 方便后面的计算 
        int l = 1, r = t, ans = 0;
        while(l <= r) {
            int mid = (l + r) >> 1;
            printf("0 %d %d\n", sx, sy + 2 * fx2 * mid);
            fflush(stdout);
            x = read();
            if(x) ans = mid, l = mid + 1;
            else r = mid - 1;
        }
        int ex = sx, ey = sy + 2 * fx2 * ans; // 求得的 F 点 
        int Mid = (sy + ey) / 2;
        int ty = Mid, tx = sx + fx1 * (t - abs(Mid - ey)); // 直接求出终点 
        printf("1 %d %d\n", tx, ty);
        fflush(stdout);
    }
    return 0;
}
```

---

## 作者：cmll02 (赞：1)

二分。

赛时并没有给出 $MAX$，所以我们应当自行计算。

首先寻找第一个点可能在哪里：

![](https://cdn.luogu.com.cn/upload/image_hosting/wu663s5n.png)

显然是在这个正方形上。

接下来我们要找到它的具体位置。

首先我们应当确定它在哪条边上。

询问 $(x\pm k,y\pm k)$ 就能确定。

当然不用询问 $4$ 次，$3$ 次就够了。

但是这样是通不过的……

我们需要先询问 $(x+1,y)$，原因见图：

![](https://cdn.luogu.com.cn/upload/image_hosting/l7h04bx5.png)

如果先确定它是否在上半部分再确定左右就可以两次查出。

接下来我们把范围缩小到了一条线上，我们继续寻找性质：

（假设在右上的边上，其他同理）

- 探测 $(a,b)$ 是否为起点

我们询问 $(a+k,b)$：

![](https://cdn.luogu.com.cn/upload/image_hosting/kvnxy4yo.png)

如果范围 $1$，说明起点在蓝紫重合的线段上。

否则在剩下的一段紫色上。

这显然可以二分。

于是这题就做出来了。

Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
inline int read()
{
	int num = 0,f=1; char c = getchar();
	while (c<48 || c>57){if(c=='-')f=-1;c = getchar();}
	while (c >= 48 && c <= 57)num = (num << 3) + (num << 1) + (c ^ 48), c = getchar();
	return num*f;
};
int k;
inline int query(int x,int y)
{
	printf("0 %d %d\n",x,y);
	fflush(stdout);
	int p=read();
	return p;
}
signed main()
{
	int T=read();
	while(T--)
	{
		int t=read(),x=read(),y=read();k=read();
		if(query(x,y+1))
		{
			if(query(x+t,y+t))
			{
				int l=x,r=x+t-1,ans=l;
				while(l<=r)
				{
					int m=(l+r)>>1;
					if(query(m+t,x+y-m+t))ans=m,l=m+1;
					else r=m-1;
				}
				printf("1 %d %d\n",ans,x+y+t-ans);
				fflush(stdout);
			}
			else 
			{
				int l=x-t+1,r=x-1,ans=l;
				while(l<=r)
				{
					int m=(l+r)>>1;
					if(query(m-t,m-x+y+t))ans=m,r=m-1;
					else l=m+1;
				}
				printf("1 %d %d\n",ans,ans-x+y+t);
				fflush(stdout);
			}
		}
		else if(query(x-t,y-t))
		{
			int l=x-t,r=x,ans=l;
			while(l<=r)
			{
				int m=(l+r)>>1;
				if(query(m-t,x+y-m-t))ans=m,r=m-1;
				else l=m+1;
			}
			printf("1 %d %d\n",ans,x+y-t-ans);
			fflush(stdout);
		}
		else
		{
			int l=x+1,r=x+t,ans=l;
			while(l<=r)
			{
				int m=(l+r)>>1;
				if(query(m+t,m-x+y-t))ans=m,l=m+1;
				else r=m-1;
			}
			printf("1 %d %d\n",ans,ans-x+y-t);
			fflush(stdout);
		}
		fflush(stdout);
	}
	
	return 0;
}
```

---

## 作者：MadokaKaname (赞：0)

## 题意

给一个点 $s$ 和最多 $MAX$ 次询问，同时给出一个与该点的 Manhattan 距离为 $t$ 的点，每次可询问一个点，如果与 $s$ 的 Manhattan 距离小于等于 $t$ 则返回 $1$，否则返回 $0$，求 $s$ 的坐标。

## 题解

众所周知，交互题的询问次数基本上都是卡死的，所以我们可以从最大次数去反向分析。

我们发现，题目中给的 $MAX$ 由前后两部分组成。

似乎后半部分的 $2$ 挺好处理的，那就先看看 $2$ 能做什么。

下面是一张 $t=5$ 时的图 ，显然是正方形。

![](https://cdn.luogu.com.cn/upload/image_hosting/l6qs0ogb.png)

可以发现，两步能确定这个点所在的是正方形的哪条边（假设顶点可以属于任意一条边）

接下来观察前半部分。

$\left\lceil\log_2{t+1}\right\rceil$

$\log_2$ 提示我们思考二分。

则可以想到在已知点属于哪条边的情况下，可以二分查找点关于正方形两顶点连线（图中即为 $x$ 轴）的对称点。

如果以两点之间距离为二分对象，则询问次数为 $\left\lceil\log_2{2\times t +1}\right\rceil $，显然无法通过。

考虑改变二分对象。以正方形长度为二分对象，则询问次数减少为 $\left\lceil\log_2t+1\right\rceil$，恰好与 $MAX$相等。

根据得到的长度计算即可。

## code

```cpp
#include <bits/stdc++.h>
#define f fflush(stdout)
using namespace std;
int n,i,j,k,m,t,useless,num1,num2,tmp,x,y,ans;
int l,r;
int main() {
    scanf("%d",&t);
    while(t--){
    	scanf("%d%d%d%d",&n,&x,&y,&useless);
    	printf("0 %d %d\n",x,y-1);
    	f;
    	scanf("%d",&num1);
    	printf("0 %d %d\n",x-1,y);
    	f;
    	scanf("%d",&num2);
    	if(num1==1){
    		l=1,r=n+1;
    		while(l<r){
    			int mid=(l+r)>>1;
    			printf("0 %d %d\n",x,y-2*mid+1);
    			f;
    			scanf("%d",&tmp);
    			if(tmp==0) r=mid;
    			else l=mid+1;
			}
			ans=r-1;
			if(num2==0) printf("1 %d %d\n",x+(n-ans),y-ans);
			else printf("1 %d %d\n",x-(n-ans),y-ans);
			f;
		}
		else{
		    l=1,r=n+1;	
		    while(l<r){
		    	int mid=(l+r)>>1;
		    	printf("0 %d %d\n",x,y+2*mid-1);
		    	f;
		    	scanf("%d",&tmp);
		    	if(tmp==0) r=mid;
		    	else l=mid+1;
			}
			ans=r-1;
		    if(num2==0) printf("1 %d %d\n",x+(n-ans),y+ans);
		    else printf("1 %d %d\n",x-(n-ans),y+ans);
		    f;
		}
	}

	return 0;
}

```

---

## 作者：Cocoly1990 (赞：0)

我们以一组简单的数据入手 `4 0 0 100`.

![HFKWl9.png](https://s4.ax1x.com/2022/02/01/HFKWl9.png)

我们不妨先不考虑询问次数，容易发现，初始金色郁金香的位置上必然和 `x0, y0` 的曼哈顿距离为 `t`，则最后的答案，必然在上图所示的正方形上。

![HFM11J.png](https://s4.ax1x.com/2022/02/01/HFM11J.png)

假设我们某次询问的点是 F，如果结果是 `1` ，那么答案一定在以 F 为中心的正方形 GHIJ **内**， 否则在其**外**。

利用这种方式，我们就可以在两次询问内求出答案在哪条边上，之后对边二分即可，但我想这并不很容易实现，下面介绍一种更简单的做法。

事实上，我们只要求出 `x0,y0` 关于答案的对称点，就可以逆求出最终的答案，我们不妨直接二分对称点关于 `x0,y0` 的距离，因为由前两次询问我们已经求出了答案在哪条边上，所以二分的过程就较为简洁。



---


# 平面最近点对（加强加强版）

## 题目背景

[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)里最高赞题解写道：

> 我们充分发扬人类智慧：  
> 将所有点全部绕原点旋转同一个角度，然后按 $x$ 坐标排序  
> 根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远  
> 所以我们只取每个点向后的 $5$ 个点来计算答案  
这样速度快得飞起，在 $n=1000000$ 时都可以在 1 s 内卡过

当然，这是错的。


## 题目描述

给定 $n$ 个二维欧几里得平面上的点 $p_1, p_2, \dots, p_n$，请输出距离最近的两个点的距离。

## 说明/提示

对于第二组样例，$(1, 9)$、$(0, 10)$ 两个点最近，距离为 $\sqrt 2$，因此你需要输出 $2$。



### 数据范围

对于 $100 \%$ 的数据，$2 \leq n \leq 4 \times 10^5$，$-10^7 \leq x_i, y_i \leq 10^7$。


本题目标复杂度是 $O(n \log ^2 n)$。设置 350ms 时限的原因是：
1. $O(n \log ^2 n)$ 参考代码使用 `cin` 不会 TLE。最快的 std 能 $<$ 100ms。
2. @wlzhouzhuan 的程序能恰好在 350ms 内跑 $1000n$ 次检查。
3. 150 组测试数据，为了防止卡评测。

2025.2.6 添加了三组 hack 数据（Credit to @[chenbs](https://www.luogu.com.cn/discuss/1056231)）。


## 样例 #1

### 输入

```
2
-10000000 -10000000
10000000 10000000```

### 输出

```
800000000000000```

## 样例 #2

### 输入

```
5
1 1
1 9
9 1
9 9
0 10```

### 输出

```
2```

# 题解

## 作者：zhoukangyang (赞：1729)

我们充分发扬人类智慧：

将所有点全部绕原点旋转同一个角度，然后按 $x \times y$ 排序

根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远

所以我们只取每个点向前的 $50$ 个点来计算答案

这样速度快得飞起，在 $n=400000$ 时都可以在 124ms 内卡过

---

## 作者：囧仙 (赞：160)

## 题目大意

> 给定平面上 $n$ 个点，求出两点间欧几里得距离的最小值。

## 题解

由于本题是模板题，因此本题解**尽量详细**地讲述怎么使用**分治法**计算出平面最近点对的距离。一些奇技淫巧（比如随机旋转坐标系什么的），这里就不提了。

---

容易发现，坐标系上这些点的顺序并不会影响到最终的求解。因此可以先将所有的点**按照 $\bm x$ 坐标**从小到大排序（如果两个点 $x$ 坐标相同，那就随便排了）。接着使用分治法。

分治法的基本思路是，**将大问题转化为类似的小问题，解决小问题后通过合并解决大问题**。在本题中，我们要解决的问题就是计算标号为 $0,1,2\cdots (n-1)$ 的这 $n$ 个点的两点间最近距离。我们设计算标号为 $l,l+1,\cdots (r-1)$ 的点的两点间最近距离为 $\mathrm{Solve}(l,r)$，本题即求 $\mathrm{Solve}(0,n)$。要想解决 $\mathrm{Solve}(l,r)$，可以考虑先解决 $\mathrm{Solve}\left(l,\left\lfloor\frac{l+r}{2}\right\rfloor\right)$ 和 $\mathrm{Solve}\left(\left\lfloor\frac{l+r}{2}\right\rfloor,r\right)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5tqycq1x.png)

容易发现，当 $r=l+1$ 时不需要做任何处理（此时返回 $ans=+\infty$）。关键问题在于，**如何合并两个子问题的结果**。

这里生成了 $9$ 个点作为例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/zord2dmu.png)

按照 $x$ 坐标排序后，从左往右依次为 $P_1,P_7,P_3,P_2,P_8,P_4,P_9,P_5,P_6$。将 $\mathrm{Solve}(0,9)$ 转化为 $\mathrm{Solve}(0,4)$ 和 $\mathrm{Solve}(4,9)$：

![](https://cdn.luogu.com.cn/upload/image_hosting/a1qy8l03.png)

> 注意，这里使用的是左闭右开区间。因此 $P_8$ 应该在蓝色部分，而非红色部分。

对于 $\mathrm{Solve}(0,4)$，可以进一步划分区间：

![](https://cdn.luogu.com.cn/upload/image_hosting/dq13vwcl.png)

当红色部分被划分成了绿色部分和红色部分后，可以发现这两个子问题内都只有两个点了。因此直接更新最短距离 $d\gets\min(d,\operatorname{dis}(P_1,P_7)),d\gets\min(d,\operatorname{dis}(P_2,P_3))$，此时 $d=\sqrt{5}$。

下面考虑如何将绿色部分和红色部分的结果进行合并。也就是计算**左边的点**和**右边的点**相连对答案进行的更新。

![](https://cdn.luogu.com.cn/upload/image_hosting/skrxsikn.png)

将距离紫红色线段不超过 $d$ 的点**全部**添加到当前需要处理的点内（显然，如果某个点到紫红色线段的距离已经超过了 $d$，那么它到另一侧节点的距离肯定是超过 $d$ 的。可以剪枝剪去）。**按照 $\bm y$ 坐标从小到大**考虑这些点之间产生的贡献。图中的绿色部分就是 $P_1$ 需要考虑的点（对于 $P_1$ 来说，$y$ 坐标和它相差大于 $d$ 的点也不用考虑了）。当然了，此时的绿色部分内没有任何的点，因此 $P_1$ 在这一部分不会对答案进行更新。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzssi49v.png)

处理完 $P_1$，就该处理 $P_3$ 了。此时 $P_2$ 进入到了绿色区域内。更新答案：$d\gets\min(d,\operatorname{dis}(P_2,P_3))$。

![](https://cdn.luogu.com.cn/upload/image_hosting/chy1ne93.png)

接着是处理 $P_2$。更新答案：$d\gets\min(d,\operatorname{dis}(P_2,P_7))$。

此时红色部分被完全处理完了。$d=\sqrt 5$。在上述过程中，我们暴力添加了所有到紫红色线段不超过 $d$ 的点，并且按照 $y$ 坐标从小到大进行处理。每个点的考虑范围就是 $y$ 坐标到它不超过 $d$ 的绿色矩形（上述例子没有出现绿色矩形内有多个点的情况。如果出现了多个点，需要依次连边进行答案的更新）。

![](https://cdn.luogu.com.cn/upload/image_hosting/uqp6uhdg.png)

处理完红色部分，再处理完蓝色部分，最后将橙色线段两侧距离不超过 $d$ 的点按照 $y$ 坐标排序后进行处理。最终得到答案为 $2$。

看上去这个做法在合并时是非常暴力的（因为一旦绿色部分内的点数非常多，就会导致复杂度退化）。但是可以证明，绿色部分内的点不超过 $5$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/hgoewmnv.png)

考虑这样的一张图。容易发现，不可能会有某个点落入圆内，否则在合并之前求得的 $d$ 会变得更小。在圆的四个角落内的点又最多只有 $4$ 个，因此绿色部分的点的数目不超过 $5$。

现在假设我们已经给 $[l,r)$ 内的点以 $y$ 坐标为关键字排好了序。我们需要依次计算每个点对应的的绿色区域内有哪些点。容易发现，随着 $y$ 坐标的升高，每次只会是绿色区域上面的点加入，只会是绿色区域底部的节点移出。因此可以使用双指针解决这种问题。

双指针对应了这样一种思想：

![](https://cdn.luogu.com.cn/upload/image_hosting/f4myiuzr.png)

指针 $L$ 和指针 $R$ 之间是需要处理的数据。每次将 $L$ 指针向右移动后，将 $R$ 指针向右移动，直到拓展到需要处理的数据的右边界。容易发现，$L$ 和 $R$ 都只会移动最多 $n$ 次，因此维护待处理数据的时间复杂度是 $\mathcal O(n)$ 的。

考虑计算整个算法的时间复杂度。

设 $T(n)$ 为解决 $n$ 个点的时间复杂度。那么有 $T(n)=2T(n/2)+n\log n$（$2T(n)$ 是分治解决子问题产生的代价；$n\log n$ 则是按照 $y$ 坐标排序；此外还需要使用双指针 $\mathcal O(n)$ 地维护待处理数据；每个节点最多会与 $5$ 个节点相连进行更新，因此这部分复杂度还是 $\mathcal O(n)$）。有：

$$\begin{aligned}
T(n)&=2T(n/2)+n\log n\cr &=4T(n/4)+n\log n+2(n/2)\log(n/2)\cr
&=4T(n/4)+2n\log n \cr
&=8T(n/8)+3n\log n \cr
&=\cdots \cr
&=n\log^2n

\end{aligned}$$

瓶颈在于每次合并答案时进行的排序。同样是分治思想，可以使用归并排序，在左右子区间的节点都排好序后，$\mathcal O(n)$ 地合并两个区间。此时总时间复杂度就是 $\mathcal O(n\log n)$ 了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
struct Point{int x,y;};
typedef vector<Point>::iterator Iter;
bool cmpx(const Point a,const Point b){return a.x<b.x;}
bool cmpy(const Point a,const Point b){return a.y<b.y;}
double dis(const Point a,const Point b){
    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));
}
void slv(const Iter l,const Iter r,double &d){
    if(r-l<=1) return;
    vector<Point> Q; Iter t=l+(r-l)/2;double w=t->x;
    slv(l,t,d),slv(t,r,d),inplace_merge(l,t,r,cmpy);
    for(Iter x=l;x!=r;++x)
        if(abs(w-x->x)<=d) Q.push_back(*x);
    for(Iter x=Q.begin(),y=x;x!=Q.end();++x){
        while(y!=Q.end()&&y->y<=x->y+d) ++y;
        for(Iter z=x+1;z!=y;++z) d=min(d,dis(*x,*z));
    }
}
vector<Point> X; int n; double ans=1e18;
int qrd(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qrd(); up(0,n-1,i){
        int x=qrd(),y=qrd(); X.push_back({x,y});
    }
    sort(X.begin(),X.end(),cmpx),slv(X.begin(),X.end(),ans);
    printf("%.0lf\n",ans*ans);
    return 0;
}
```

---

## 作者：fstqwq (赞：109)

一个真的随机算法：

A simple randomized sieve algorithm for the closest-pair problem (https://www.cs.umd.edu/~samir/grant/cp.pdf)

1. 循环直到删完所有点：
	* 随机选一个点，计算它到所有点的最短距离 $d$。
    * 将所有点划分到 $l = d/3$ 的网格里，比如 $\left (\lfloor \frac x  l \rfloor, \lfloor \frac y l \rfloor \right )$。
    * 将九宫格内孤立的点删除，这意味着这些点的最近点对距离不小于 $\frac {2 \sqrt 2} {3} d$，其中 $\frac {2 \sqrt 2} 3 < 1$。
2. 取最后一个 $d$，将所有点划分到 $\left (\lfloor \frac x  d \rfloor, \lfloor \frac y d \rfloor \right )$ 的网格里，暴力计算九宫格内的答案。

第一部分每次期望会删掉至少一半的点，因为有 $\geq 1/2$ 概率随到一个最近点距离在中位数以下的点，因此第一部分的复杂度是 $O(n)$ 的。

第二部分分析类似分治做法，周围只有常数个点。

所以总复杂度是 $O(n)$ 的。

---

## 作者：WeLikeStudying (赞：99)

- 人类的智慧不是乱搞。
- 如果那些乱搞的人知道存在正解和乱搞代码一样短会如何感想？

**题意**
- [链接](https://www.luogu.com.cn/problem/P7883)。
- 给定平面上的 $n$（$n\le 5\times 10^4$） 个点，求最近点对。

**分析**
- 我们充分发扬人类智慧，放弃繁杂的分治，将 $\text{set}$（当然，可重）用到极致。
- 我们先对 $x$ 坐标排序，然后一个一个添加点，与分治类似，我们尝试动态更新，咱们设置一个阈值 $d$ 表示目前找到的最优解（初始化其实可以 $O(1)$ 随机两个不同的点）。
- 首先 $\text{set}$ 以 $y$ 为关键字。
- 每次加入的时候，我们可以把与当前点横坐标差值超过 $d$ 的先扔掉，然后暴力查询纵坐标差不超过 $d$ 的点更新 $d$。
- 显然你卡我的唯一的途径是让我超时，但你没法卡我，因为这个做法复杂度是对的（$O(n\log n)$），有兴趣可以自己证明，如果没兴趣可以看我在下面给出的证明。
- [代码实现](https://www.luogu.com.cn/paste/ii9ajt84)，代码长度 $\text{900B}$，常数比分治小很多。
- 顺带一提，由于这个不开放数据，我到[这道](https://www.luogu.com.cn/problem/P1257)调试，过了那道，然后就过了这道。

**证明**
$$\sqrt{\bigg(\frac12\bigg)^2+\bigg(\frac23\bigg)^2}=\frac 56< 1$$
![](https://cdn.luogu.com.cn/upload/image_hosting/ngkhc4au.png)

---

## 作者：Daniel_7216 (赞：69)

先致敬万谔之源：

> 我们充分发扬人类智慧：  
> 将所有点全部绕原点旋转同一个角度，然后按 $x$ 坐标排序  
> 根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远  
> 所以我们只取每个点向后的 $5$ 个点来计算答案  
这样速度快得飞起，在 $n=1000000$ 时都可以在 1s 内卡过

~~当然，这是错的~~

我们充分发扬 Hack 智慧：

将这篇题解看上几遍，然后按照题解说的在脑子里模拟。

根据数学直觉，在经过他的操作后，数据中 $x$ 坐标很近的点有可能离得很远。

所以我们不能只单独拿一个坐标做关键字。

这样速度快得飞起，在 $n=10000$ 时都可以在 10ms 内 WA 掉。

考虑到尽可能要让排序很均匀，我们充分发扬初中数学智慧：

在讲方差这一课时，也许老师问过大家如何判断数据的离散程度。

显然我们不能将两个坐标相减开方，或者将他们的绝对值相加。

根据数学直觉，由于原点不参与运算，把方差的计算公式展开后删去横纵坐标的平方，留下了两坐标乘积的二倍。

所以我们只取两坐标的乘积作为排序关键字。

这样大部分测试点不会被卡，在 $n \leq 4 \times 10^5$ 时都可以拿 $140pts$ 以上。

~~我充分发扬题解智慧，在智慧解法里看到我竟然蒙对了排序关键字~~

有的数据还是过不去。这是因为，可能会有在坐标轴上的点，他的乘积为 $0$。

我们充分发扬人类智慧：	

将所有的坐标加上一个玄学数字，然后把新坐标乘起来再排序。	

根据数学直觉，在玄学相乘后，答案中的两个点在数组中几乎不会离得太远

所以我们只取每个点向后的在时间允许范围之内的玄学个点来计算答案	 

这样速度快得飞起，在 $n=4 \times 10^5$ 时都可以在 160ms 内卡过	

乱搞代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 4e5 + 1;
long long ans = 4611686018427387904ll;
int n; 
struct node{
	long long x, y;
	bool operator<(const node&t)const{
		return (x + 3333) * (y + 3333) > (t.x + 3333) * (t.y + 3333);
	}
}a[maxn];
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%lld%lld", &a[i].x, &a[i].y);
	}
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; i++){
		for (int j = i + 1; j <= min(i + 233, n); j++){
			ans = min(ans, (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));
		}
	}
	for (int i = 1; i <= 50; i++){
	    for (int j = n; j >= max(i + 1, n - 50); j--){
	        ans = min(ans, (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));
	    }
	}
	printf("%lld", ans);
	return 0;
}
```

> 数据永远无法打败智慧！！！


---

## 作者：尹昱钦 (赞：54)

## 前言
现在的题解除了随机算法外只有两篇分治做法，一篇神仙用的蒟蒻看不懂的 vector，另一篇是 $O(n\log^2n)$，所以我献上一篇 $O(n\log n)$ 的题解及代码。

## 解题思路

先按照 $x$ 的大小分治,然后归并排序。

归并时按照 $y$ 值。

然后步入难点：

假设我们已经求出了左半部分的最近距离和右半部分的最近距离，两个距离的较小值设为 $d$。

我们把划分左右两部分的中线的 $x$ 值定为 $midx$。

很显然，最终的答案有三种情况：

1. 两点在左半部分
2. 两点在右半部分
3. 一个点在左边，一个点在右边（即跨过中线）

我们已经求出了 $1$、$2$ 两种情况，还剩第三种情况。

对于第三种情况，只有距离中线的距离 $\leq x$ 的点才有可能成为最终答案。

所以我们在归并后，枚举一遍，找出所有 $abs(x-midx)\leq d$ 的点，放入数组 $q$。

然后枚举一遍 $q$ 数组，想一想另一个点可能在什么地方？答案只有两部分：

- 这个点上方的点
- 这个点下放的点

而且这两个点的 $y$ 值的差一定小于 $d$。

而我们刚刚的归并排序就是按照 $y$ 值排序的，所以当某个点 $y$ 值的差大于 $d$ 时，可以直接结束循环。

对于时间复杂度，可以证明符合条件的点很少（最多 $6$ 个）。

所以总复杂度为 $O(n\log n)$
注：求 $midx$ 时一定要在分治前面求，否则分治结束后会改变点在数组中的位置（因为是按照 $y$ 值归并的）。
## AC代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<iomanip>
using namespace std;
const int maxn=400005;
int n;
struct Point{
    long long x,y;
}p[maxn],q[maxn];
bool cmp(const Point &a,const Point &b){
    return a.x<b.x;
}
long long dis(const Point &a,const Point &b){
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}
long long divide(int l,int r){
    if(l==r) return 1ll<<62;
    int mid=(l+r)/2;
    long long midx=p[mid].x;
    long long d=min(divide(l,mid),divide(mid+1,r));
    int p1=l,p2=mid+1,tot=0;
    while(p1<=mid||p2<=r){
        if(p1<=mid&&(p2>r||p[p1].y<p[p2].y)){
            q[++tot]=p[p1++];
        }else{
            q[++tot]=p[p2++];
        }
    }
    for(int i=1;i<=tot;i++){
        p[l+i-1]=q[i];
    }
    tot=0;
    long long dd=d;
	d=sqrt(dd);
    for(int i=l;i<=r;i++){
        if(abs(p[i].x-midx)<=d) q[++tot]=p[i];
    }
	for(int i=1;i<=tot;i++){
		for(int j=i-1;j>=1&&q[i].y-q[j].y<=d;j--){
			dd=min(dd,dis(q[i],q[j]));
			d=sqrt(dd);
		}
	}
    return dd;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%lld%lld",&p[i].x,&p[i].y);
    }
    sort(p+1,p+n+1,cmp);
    cout<<divide(1,n)<<endl;
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：41)

### Update

2022.10.5 解决了代码放错导致寄掉的问题。

## 智慧法
[艰险历程](https://www.luogu.com.cn/record/list?pid=P7883&user=556362&page=1)

提一下几个要点：

1.是按照 $x\times y$ 从小到大排序。

2.能往后多查找几个点就多查找几个点（在时间允许的情况下）。

3.必须旋转，否则 $147$ 分。
### 思路
排完序之后，使用“智慧法”，我们往后查找 $k$ 个点。经测试，100 就可以了，再往上会 TLE，然后枚举求最大值，时间复杂度 $O(n\log n+k\times n)$，空间复杂度 $O(n)$，注意判断数组越界的情况。综上，数据还需要加强。
### AC Code:
```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
const int N=4e5+5;
struct node{
	double a[4];
	bool operator <(const node &t) const{
		return a[0]*a[1]<t.a[0]*t.a[1];
	}
}p[N];
double z,w,ans,x,y,x_,y_;
int n;
int main(){
	scanf("%d",&n);
	int k=min(n,100);
	z=sin(1),w=cos(1);
	for(int i=1;i<=n;i++){
		scanf("%Lf%Lf",&x,&y);
		p[i]=node({x*w-y*z,x*z+y*w,x,y});
	}
	stable_sort(p+1,p+n+1);
	ans=2e30+0.01;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k&&i+j<=n;j++){
			x=p[i].a[2],y=p[i].a[3];
			x_=p[i+j].a[2],y_=p[i+j].a[3];
			z=(x-x_)*(x-x_)+(y-y_)*(y-y_);
			ans=min(ans,z);
		}
	printf("%.0Lf",ans);
	return 0;
}
```
### 提示
为什么要以 $x\times y$ 排序。首先，我们对于两点间的距离公式 $dist(a,b)=\sqrt{(x_a-x_b)^2+(y_a-y_b)^2}$。展开，则 $dist(a,b)=\sqrt{(x_a-x_b)\times(x_a+x_b)+(y_a-y_b)\times (y_a+y_b)+2\times(x_a\times y_a-x_b\times y_b)}$。此时，我们可以发现，用 $x\times y$ 更方便。

---

## 作者：zx2003 (赞：27)

将所有点按随机顺序加入，维护前缀点集的答案。

记前 $i$ 个点的答案为 $d_i$。我们将全平面划分为若干个边长为 $d_i$ 的正方形。将前 $i$ 个点丢到正方形里，可以发现每个正方形中只有 $O(1)$ 个点。

对于新加入的第 $i+1$ 个点，只需检查以它所属的正方形为中心，$3 \times 3$ 的格子中的所有备选点。

如果 $d_{i+1} \neq d_i$，则需要以 $O(i)$ 的复杂度重构整个网格。但由于第 $i$ 个点只有 $\frac{1}{i}$ 的概率更新答案，故总复杂度仍为 $O(n)$。

需要使用哈希表存储每个方格中的点，最慢的点大概 166ms。

感觉“目标复杂度是 $O(n\log^2n)$”有点匪夷所思。

[提交记录](https://www.luogu.com.cn/record/59133801)


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5,B=987654,mo=1e6+3;
inline void red(int&x){x+=x>>31&mo;}
int mi[6];
typedef unsigned long long ull;
int x[6],x2[6],n,k,i,j,l,dv[6];ull seed,xs[N];
struct P{
	int a[6];
	inline void ini(){for(int i=0;i<k;++i)cin>>a[i],a[i]+=1e7;}
}a[N];
double xx[6];
inline ull dis(int p,int q){
	ull z=0;
	for(int i=0;i<k;++i)z+=1ll*a[p].a[i]*a[q].a[i];
	return xs[p]+xs[q]-z*2;
}
double R,iR;ull rR;bool bb;
struct hmp{
	int h[mo],nxt[N];
	inline int geth(int*x){int v=0;for(int j=0;j<k;++j)v=(1ll*v*B+x[j])%mo;return v;}
	inline void ins(int i,int*x){int v=geth(x);nxt[i]=h[v];h[v]=i;}
}mp;
inline void getv(int i){for(int j=0;j<k;++j)x[j]=xx[j]=a[i].a[j]*iR+1e-12;}
inline void build(int l){
	memset(mp.h,0,sizeof mp.h);
	for(int i=1;i<=l;++i)getv(i),mp.ins(i,x);
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n;k=2;for(i=1;i<=n;++i)a[i].ini();
	for(i=1;i<=n;++i)for(j=0;j<k;++j)xs[i]+=1ll*a[i].a[j]*a[i].a[j];
	for(i=*mi=1;i<k;++i)mi[i]=1ll*mi[i-1]*B%mo;
	rR=dis(1,2);R=sqrt(rR)*2;iR=1.0/R;build(2);
	for(i=3;i<=n;++i){
		bb=0;getv(i);
		for(j=0;j<k;++j)dv[j]=xx[j]<x[j]+0.5?mo-mi[k-1-j]:mi[k-1-j];
		static int ha[99];ha[0]=mp.geth(x);
		for(j=0;j<k;++j)for(l=0;l<1<<j;++l)red(ha[l|(1<<j)]=ha[l]+dv[j]-mo);
		for(j=0;j<4;++j)for(l=mp.h[ha[j]];l;l=mp.nxt[l]){
			ull nd=dis(i,l);
			if(nd<rR)rR=nd,bb=1;
		}
		if(bb)R=sqrt(rR)*2,iR=1.0/R,build(i);else mp.ins(i,x);
	}
	cout<<rR<<endl;
}
```

---

## 作者：EnofTaiPeople (赞：25)

K-D Tree 这种数据结构是为了解决多维空间问题，**矩形查询**平均时间复杂度可以达到 $O(qn^{k-1/k})$，是一种不折不扣的暴力数据结构。[P7883](/problem/P7883) 是一道 K-D Tree 的模板题，因为此题维护的信息是二维的，且有 n 次询问，故在此题中维护的是 2-D Tree。

K-D Tree 可以维护邻值查询，随机数据下复杂度为 $O(n\log_2n)$，可以通过此题，但这种基于暴力剪枝的算法需要一些优化。

K-D Tree 的在区间 $[l,r]$ 建树的过程如下：

1. 令 $mid=(l+r)/2$，将 mid 置于按维度 $a$ 排序后的位置，调用如下函数即可：
```cpp
std::nth_element(a+l,a+mid,a+r+1,cmp)
```
2. 递归建树 $[l,mid-1]$ 和 $[mid+1,r]$；
3. 记录两个维度的极值。

代码如下：
```cpp
inline void Maintain(int x){
    lx[x]=rx[x]=a[x].x;ly[x]=ry[x]=a[x].y;
    if(lc[x])lx[x]=min(lx[x],lx[lc[x]]),rx[x]=max(rx[x],rx[lc[x]]),
    ly[x]=min(ly[x],ly[lc[x]]),ry[x]=max(ry[x],ry[lc[x]]);
    if(rc[x])lx[x]=min(lx[x],lx[rc[x]]),rx[x]=max(rx[x],rx[rc[x]]),
    ly[x]=min(ly[x],ly[rc[x]]),ry[x]=max(ry[x],ry[rc[x]]);
    return;
}
int build(int l,int r){
    if(r<l)return 0;int mid=l+((r-l)>>1),i;
    nth_element(a+l,a+mid,a+r+1,cmpx);
    lc[mid]=build(l,mid-1);
    rc[mid]=build(mid+1,r);
    Maintain(mid);return mid;
}
```
记录了每一棵子树，就可以进行有效剪枝了，以下以求平面最近点对为例：
```cpp
#define p2(x) ((x)*(x))
inline ll fac(int d,int x){
    ll ax=max(a[x].x-lx[d],rx[d]-a[x].x);
    ll ay=max(a[x].y-ly[d],ry[d]-a[x].y);
    return p2(ax)+p2(ay);
}
inline void asks(int l,int r,int x){
    if(r<l)return;int mid=l+((r-l)>>1);ll w=dis(mid,x);
    if(mid!=x)if((w=dis(mid,x))>ans)ans=w;
    if(l==r)return;
    ll fl=fac(lc[mid],x),fr=fac(rc[mid],x),Min=Set.top();
    if(fl>Min&&fr>Min){
        if(fl>=fr){asks(l,mid-1,x);if(fr>ans)asks(mid+1,r,x);}
        else{asks(mid+1,r,x);if(fl>Set.top())asks(l,mid-1,x);}
    }else if(fl>Min)asks(l,mid-1,x);
    else if(fr>Min)asks(mid+1,r,x);
    return;
}
```
仔细观察之后，不难发现 K-D Tree 总是以 $x$ 为标准建树，只要 $x$ 离得很近，就起不到很好的剪枝效果，所以我们可以尝试按 $x$ 和 $y$ 为标准交替建树，这样就得到了本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define P(x) (ll(x)*(x))
#define p(x) ((x)*(x))
const int N=4e5+5;
const ll T=0x3f3f3f3f3f3f3f3f;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline void read(int &x){
    bool flag=x=0;while(!isdigit(c=gc))if(c=='-')flag=1;
    do x=(x<<3)+(x<<1)+(c^'0');while(isdigit(c=gc));if(flag)x=-x;
}
ll ans=T;
int lc[N],rc[N],lx[N],ly[N],rx[N],ry[N],nowt,Id[N],n,Root;
struct Node{int x,y;}a[N];
inline bool cmpx(const int &x,const int &y){return a[x].x<a[y].x;}
inline bool cmpy(const int &x,const int &y){return a[x].y<a[y].y;}
#define Dis(a1,a2) (P(a[a1].x-a[a2].x)+P(a[a1].y-a[a2].y))
inline ll fac(int x){
    if(!x)return T+50;ll res=0;
    if(lx[x]>a[nowt].x)res+=P(lx[x]-a[nowt].x);
    if(rx[x]<a[nowt].x)res+=P(a[nowt].x-rx[x]);
    if(ly[x]>a[nowt].y)res+=P(ly[x]-a[nowt].y);
    if(ry[x]<a[nowt].y)res+=P(a[nowt].y-ry[x]);
    return res;
}
inline void Maintain(int x){
    #define Max(a,b) (a>b?a:b)
    #define Min(a,b) (a<b?a:b)
    lx[x]=rx[x]=a[x].x;ly[x]=ry[x]=a[x].y;
    if(lc[x])lx[x]=Min(lx[x],lx[lc[x]]),rx[x]=Max(rx[x],rx[lc[x]]),
    ly[x]=Min(ly[x],ly[lc[x]]),ry[x]=Max(ry[x],ry[lc[x]]);
    if(rc[x])lx[x]=Min(lx[x],lx[rc[x]]),rx[x]=Max(rx[x],rx[rc[x]]),
    ly[x]=Min(ly[x],ly[rc[x]]),ry[x]=Max(ry[x],ry[rc[x]]);
    #undef Max
    #undef Min
}
int build(int l,int r,bool Tp){
    if(r<l)return 0;int mid=l+((r-l)>>1),x;
    if(Tp)nth_element(Id+l,Id+mid,Id+r+1,cmpx);
    else nth_element(Id+l,Id+mid,Id+r+1,cmpy);x=Id[mid];
    lc[x]=build(l,mid-1,Tp^1);rc[x]=build(mid+1,r,Tp^1);Maintain(x);
    return x;
}
void asks(int x){
    if(x!=nowt)ans=min(ans,Dis(x,nowt));
    ll fl=fac(lc[x]),fr=fac(rc[x]);
    if(fl<fr){if(fl<ans){asks(lc[x]);if(fr<ans)asks(rc[x]);}}
    else{if(fr<ans)asks(rc[x]);if(fl<ans)asks(lc[x]);}
}
int main(){
    int i;read(n);
    for(i=1;i<=n;Id[i]=i,++i)read(a[i].x),read(a[i].y);
    Root=build(1,n,0);
    for(i=1;i<=n;++i)nowt=Id[i],asks(Root);
    printf("%lld\n",ans);
    return 0;
}
```
无奈地得到了如下的[评测结果](/record/62650150)，这时，我们注意到，题面上说，本题标算是 $O(n\log^2 n)$ 的，我们用一个 $O(n^2)$ 的算法不加特殊优化通过本来就是痴心妄想！

回到建树的过程，我们为什么要以 $x$ 和 $y$ 为标准交替建树？因为害怕其中之一很相近，起不到剪枝效果！所以，我们可以通过计算方差来使得每次都以差别大的维度来作为标准建树，这样就能 AC 啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define P(x) (ll(x)*(x))
#define p(x) ((x)*(x))
const int N=4e5+5;
const ll T=0x3f3f3f3f3f3f3f3f;
char buf[1<<23],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2))?EOF:*p1++
inline void read(int &x){
    bool flag=x=0;while(!isdigit(c=gc))if(c=='-')flag=1;
    do x=(x<<3)+(x<<1)+(c^'0');while(isdigit(c=gc));if(flag)x=-x;
}
ll ans=T;
int lc[N],rc[N],lx[N],ly[N],rx[N],ry[N],nowt,Id[N],n,Root;
struct Node{int x,y;}a[N];
inline bool cmpx(const int &x,const int &y){return a[x].x<a[y].x;}
inline bool cmpy(const int &x,const int &y){return a[x].y<a[y].y;}
#define Dis(a1,a2) (P(a[a1].x-a[a2].x)+P(a[a1].y-a[a2].y))
inline ll fac(int x){
    if(!x)return T+50;ll res=0;
    if(lx[x]>a[nowt].x)res+=P(lx[x]-a[nowt].x);
    if(rx[x]<a[nowt].x)res+=P(a[nowt].x-rx[x]);
    if(ly[x]>a[nowt].y)res+=P(ly[x]-a[nowt].y);
    if(ry[x]<a[nowt].y)res+=P(a[nowt].y-ry[x]);
    return res;
}
inline void Maintain(int x){
    #define Max(a,b) (a>b?a:b)
    #define Min(a,b) (a<b?a:b)
    lx[x]=rx[x]=a[x].x;ly[x]=ry[x]=a[x].y;
    if(lc[x])lx[x]=Min(lx[x],lx[lc[x]]),rx[x]=Max(rx[x],rx[lc[x]]),
    ly[x]=Min(ly[x],ly[lc[x]]),ry[x]=Max(ry[x],ry[lc[x]]);
    if(rc[x])lx[x]=Min(lx[x],lx[rc[x]]),rx[x]=Max(rx[x],rx[rc[x]]),
    ly[x]=Min(ly[x],ly[rc[x]]),ry[x]=Max(ry[x],ry[rc[x]]);
    #undef Max
    #undef Min
}
double px,py,fx,fy;
int build(int l,int r){
    if(r<l)return 0;int mid=l+((r-l)>>1),x;px=py=fx=fy=0;
    for(x=l;x<=r;++x)px+=a[Id[x]].x,py+=a[Id[x]].y;px/=r-l+1;py/=r-l+1;
    for(x=l;x<=r;++x)fx+=p(px-a[Id[x]].x),fy+=p(py-a[Id[x]].y);
    if(fx>fy)nth_element(Id+l,Id+mid,Id+r+1,cmpx);
    else nth_element(Id+l,Id+mid,Id+r+1,cmpy);x=Id[mid];
    lc[x]=build(l,mid-1);rc[x]=build(mid+1,r);Maintain(x);
    return x;
}
void asks(int x){
    if(x!=nowt)ans=min(ans,Dis(x,nowt));
    ll fl=fac(lc[x]),fr=fac(rc[x]);
    if(fl<fr){if(fl<ans){asks(lc[x]);if(fr<ans)asks(rc[x]);}}
    else{if(fr<ans)asks(rc[x]);if(fl<ans)asks(lc[x]);}
}
int main(){
    int i;read(n);
    for(i=1;i<=n;Id[i]=i,++i)read(a[i].x),read(a[i].y);
    Root=build(1,n);
    for(i=1;i<=n;++i)nowt=Id[i],asks(Root);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：2021hych (赞：21)

# 直接看思路：
**很明显**，求的是**给定的点集**中，**距离最近的两个点的距离的平方**。首先根据这道题被评为**蓝**，便可知**暴力就会挂**（**除非你充分发扬人类智慧**）。当然了，这是个**模板题**，所以直接点明，**分治题**。

可以把它分**一半平面**内的最近点对 **min1** 和**另一半平面**内的最近点对 **min2** 。难道答案是 $\min(min1,min2)$ 。显然不是，因为还要考虑**跨越两个半平面的分界线的最近点对**，再比较一下，这一部分**线性扫描**一下，来取出**子点集**。其他部分就是熟悉的**递归**了，不停地划分成**两个子点集**。一直到**就剩一个点**。
# AC code:
```cpp
#include<bits/stdc++.h>
#define inf 0x7f7f7f7f
#define maxn 400005
#define int long long
using namespace std;
int n;
struct node {
	double x,y;
}a[maxn],c[maxn];
bool cmp(node x,node y) {
	return x.x<y.x;
}
bool _cmp(node x,node y) {
	return x.y<y.y;
}
double GDX(int i,int j) {
    double dx=c[i].x-c[j].x,dy=c[i].y-c[j].y;
    return sqrt(dx*dx+dy*dy);
}
double work(int l,int r) {
    if(l==r) return inf;
    int mid=(l+r)/2;
    int num=0;
    double ans=min(work(l,mid),work(mid+1,r));
    for(int i=l;i<=r;i++) if(abs(a[mid].x-a[i].x)<=ans) c[++num]=a[i];
    sort(c+1,c+num+1,_cmp);
    for(int i=1;i<=num;i++)
        for(int j=i+1;j<=num;j++) {
            if(c[j].y-c[i].y>=ans) break;
            ans=min(ans,GDX(i,j));
        }
    return ans;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
    sort(a+1,a+n+1,cmp);
    printf("%.0lf",pow(work(1,n),2));
    return 0;
}
```


---

## 作者：Tenshi (赞：10)

## 分析
来一发 KDT 的题解，了解 KDT 的人应该都知道大致的思路，所以我简略地说一下步骤。

### 建树
将 $n$ 个点读进来，然后轮流按照 $x,y$ 维度对点进行分割。

更具体地说就是每次分割的时候找到相应维度的中位数对应的点作为子树的根节点，然后递归地将树建立起来。

### 查询
这其实是一个搜索剪枝的过程，但是实际运行效率很不错。

我们依次枚举每个点去查询它的最近点，遇到自己需要跳过（但这里题目保证没有重合点，如果有重合点在读入的过程可以特判掉），查询也是一个递归的过程，记当前在树上的点为 $u$，查询点为 $p$。

因为 KDT 的每个点所在的子树对应一个**矩形**，所以可以求出 $p$ 到矩形的**最短距离**作为估价函数，如果这个函数值可以更新答案，那么就向这个子树查询。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)

using ll = long long;

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

template<typename T> inline void write(T k){
	if(k < 0) { putchar('-'); k = -k; }
	if(k > 9) write(k / 10);
	putchar((char)(k % 10 + '0'));
	return;
}

const int N=5e5+5, INF=0x3f3f3f3f;

struct Point{
	int x[2];
};

struct Node{
	int l, r;
	Point P;
	int L[2], R[2], sz;
	
	#define ls tr[u].l
	#define rs tr[u].r
}tr[N];

int n;
int idx, root;

inline void pushup(int u){
	auto &L=tr[ls], &R=tr[rs];
	tr[u].sz=L.sz+R.sz+1;

	rep(i,0,1){
		tr[u].L[i]=min(tr[u].P.x[i], min(L.L[i], R.L[i]));
		tr[u].R[i]=max(tr[u].P.x[i], max(L.R[i], R.R[i]));
	}
}

Point pt[N];

int build(int l, int r, int k){
	if(l>r) return 0;
	int mid=l+r>>1;
	int u=++idx;
	
	nth_element(pt+l, pt+mid, pt+r+1, [&](Point a, Point b){
		return a.x[k]<b.x[k];
	});
	tr[u].P=pt[mid];
	
	ls=build(l, mid-1, k^1), rs=build(mid+1, r, k^1);
	pushup(u);
	return u;
}

ll res=4e18;

inline ll Dis(Point a, Point b){
	ll dx=a.x[0]-b.x[0], dy=a.x[1]-b.x[1];
	return dx*dx+dy*dy;
}

inline ll H(Node t, Point p){
	auto sqr=[](int x) -> ll{return 1LL*x*x;};
	
	ll x=p.x[0], y=p.x[1];
	ll res=0;
	if(x<t.L[0]) res+=sqr(x-t.L[0]);
	if(x>t.R[0]) res+=sqr(x-t.R[0]);
	if(y<t.L[1]) res+=sqr(y-t.L[1]);
	if(y>t.R[1]) res+=sqr(y-t.R[1]);
	return res;
}

void query(int u, Point p){
	if(!u) return;
	if(tr[u].P.x[0]!=p.x[0] || tr[u].P.x[1]!=p.x[1]) res=min(res, Dis(tr[u].P, p));
	ll LV=4e18, RV=4e18;
	if(ls) LV=H(tr[ls], p);
	if(rs) RV=H(tr[rs], p);
	
	if(LV<RV){
		if(LV<res) query(ls, p);
		if(RV<res) query(rs, p);
	}
	else{
		if(RV<res) query(rs, p);
		if(LV<res) query(ls, p);
	}
}

int main(){
	cin>>n;
	// init
	tr[0].L[0]=tr[0].L[1]=INF;
	tr[0].R[0]=tr[0].R[1]=-INF;

	rep(i,1,n){
		int x, y; read(x), read(y);
		pt[i]={x, y};
	}
	sort(pt+1, pt+1+n, [](Point a, Point b){
		return a.x[0]==b.x[0]? a.x[1]<b.x[1]: a.x[0]<b.x[0];
	});
	
	root=build(1, n, 0);
	rep(i,1,n) query(root, pt[i]);
	cout<<res<<endl;

	return 0;
}
```

---

## 作者：shinkuu (赞：7)

这是一篇**决策单调性**题解，好像现在还没有相同做法的题解。

还是类似的分治方式，每次点分成左右两半求两边贡献，再处理跨区间贡献。

但是有一种新的处理贡献方式：决策单调性。

先将两边点各自按照纵坐标升序排序，然后对每个左半边的点找最近的点。怎么找呢？考虑设置两个指针，分别指向纵坐标升序的左边第 $i$ 个点和右边第 $j$ 个点，满足 $y_j\leq y_i$。再用一个单调队列维护右边可能是目标点的点。容易发现这个单调队列里的点满足 $x_{q_k}>x_{q_{k-1}}$，因为到左边第 $i$ 个点纵坐标距离一定是单调递减的，如果再有 $x_{q_k}\le x_{q_{k-1}}$，那第 $k-1$ 个元素就一定会被弹出了。具体可以结合下图理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/xkzygerr.png)

然后就要证明决策单调性了，也就是说，如果 $dis(i,q_k)\ge dis(i,q_{k+1})$，那么 $q_k$ 以后都不可能比 $q_{k+1}$ 优。

![](https://cdn.luogu.com.cn/upload/image_hosting/070kitvz.png)

证明：如上图，已知 $a>b$，又 $b+c>d+a$（可用三角形两边之和大于第三边证），所以一定有 $d<c$，得证。

于是可以对每个 $i$ 找到最近的点，不断更新答案即可。

按升序做完，还要按降序再做一遍，不断递归求解即可。

如果用 sort，时间复杂度为 $O(n\log^2n)$，但是常数较大，无法通过，于是直接用归并完成纵坐标的排序，复杂度降到 $O(n\log n)$，可以通过。

code：

```cpp
int n,m,q[N];
struct node{
	int x,y;
}e[N],d[N];
ll ans=1e18;
inline bool cmp1(node x,node y){
	return x.x<y.x;
}
inline bool cmp2(node x,node y){
	return x.y<y.y;
}
inline ll dis(node i,node j){
	return 1ll*(i.x-j.x)*(i.x-j.x)+1ll*(i.y-j.y)*(i.y-j.y);
}
void divide(int l,int r){
	if(l==r)
		return;
	int mid=(l+r)>>1;
	divide(l,mid);
	divide(mid+1,r);
	int L=1,R=0;
	for(int i=l,j=mid;i<=mid;i++){
		while(j<r&&e[j+1].y<=e[i].y){
			j++;
			while(L<=R&&e[q[R]].x>=e[j].x)
				R--;
			q[++R]=j;//单调队列操作
		}
		while(L<R&&dis(e[i],e[q[L+1]])<=dis(e[i],e[q[L]]))
			L++;//决策单调性
		if(L<=R)
			ans=min(ans,dis(e[i],e[q[L]]));
	}//升序做一遍
	L=1,R=0;
	for(int i=mid,j=r+1;i>=l;i--){
		while(j>mid+1&&e[j-1].y>=e[i].y){
			j--;
			while(L<=R&&e[q[R]].x>=e[j].x)
				R--;
			q[++R]=j;
		}
		while(L<R&&dis(e[i],e[q[L+1]])<=dis(e[i],e[q[L]]))
			L++;
		if(L<=R)
			ans=min(ans,dis(e[i],e[q[L]]));
	}//倒过来再做一遍
	int p=l,q=mid+1,k=l;
	while(p<=mid&&q<=r){
		if(e[q].y<e[p].y)
			d[k++]=e[q++];
		else 
			d[k++]=e[p++];
	}
	while(p<=mid)d[k++]=e[p++];
	while(q<=r)d[k++]=e[q++];
	for(int i=l;i<=r;i++)e[i]=d[i];
}
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		e[i]={read(),read()};
	sort(e+1,e+n+1,cmp1);
	divide(1,n);
	printf("%lld\n",ans);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		solve();
}
```

---

## 作者：E1_de5truct0r (赞：5)

一个奇怪的做法：

- 按 $x \times y$ 排序

此时将步长设为 ```380```。

但是只有 147 分？
有人说可以旋转，但是那个太麻烦了。

- 按 $|x-p| \times (y+p)$ 排序（nani???）

$p$ 一定要选质数（亲测 1333 可以），此时将步长设为 ```220```。

然后就可以通过本题。（数据可能是有点水，反正我过了）

不知道能不能被卡掉（应该可以？

## 代码

核心代码：

```cpp
tmp=110; // 步长 220
sort(a+1,a+1+n,cmp3); // 按照 |x+p|(y-p) 排序
for(register int i=1;i<=n;i++)
{
	register int L=qmax(1,i-tmp),R=qmin(n,i+tmp);
	for(register int j=L;j<i;j++)
		ans=qmin(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
	for(register int j=i+1;j<=R;j++)
		ans=qmin(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
}
tmp=190; // 步长 380
sort(a+1,a+1+n,cmp4); // 按照 x*y 排序
for(register int i=1;i<=n;i++)
{
	register int L=qmax(1,i-tmp),R=qmin(n,i+tmp);
	for(register int j=L;j<i;j++)
		ans=qmin(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
	for(register int j=i+1;j<=R;j++)
		ans=qmin(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y));
}
```

希望尽早卡掉，~~要不是因为社贡~~ 免得我丢人现眼（

---

## 作者：water_tomato (赞：5)

本文同步发表于个人博客：[Link](https://www.watertomato.com/p7883-%e5%b9%b3%e9%9d%a2%e6%9c%80%e8%bf%91%e7%82%b9%e5%af%b9%ef%bc%88%e5%8a%a0%e5%bc%ba%e5%8a%a0%e5%bc%ba%e7%89%88%ef%bc%89-%e9%a2%98%e8%a7%a3/)。

## 题意

[题目链接](https://www.luogu.com.cn/problem/P7883)。

给定 $n$ 个二维欧几里得平面上的点 $p_1, p_2, \dots, p_n$，请输出距离最近的两个点的距离。

## 解析

在这题下给一篇正经的分治做法，已有的分治做法是用 vector 实现的，可能对于部分同学来说代码实现不便。其他题解都是非分治的。

我们将所有点按照 $x$ 坐标排序后标号为 $1,2,\dots n$，记 $\operatorname{solve}(l,r)$ 为计算出 $[l,r]$ 内所有点的平面最近点对并返回其距离。考虑分治，记 $mid=\lfloor\frac{l+r}{2}\rfloor$，可以先进行 $\operatorname{solve}(l,mid)$ 和 $\operatorname{solve}(mid+1,r)$，考虑如何合并信息。

在记 $d$ 为 $\operatorname{solve}(l,mid)$ 和 $\operatorname{solve}(mid+1,r)$ 的较小值。容易发现我们仅需要考虑 $|x_i-x_{mid}|<d$ 的点（$x_i$ 为点 $i$ 的横坐标）。我们找出这些点，并将其按 $y$ 坐标排序。

之后我们暴力依次遍历这些点，对于遍历到的每个点，再往后暴力遍历直至 $y_j-y_i \ge d$ 为止。由 $d$ 的定义可以知道位于同一侧的点的距离一定 $\ge d$，再结合画图可以知道，每个点往后暴力遍历至多遍历 $7$ 个点，因此合并操作的复杂度为 $O(n)$。结合分治和每次进行的对 $y$ 排序，最终复杂度为 $O(n\log^2 n)$。

事实上，分治本质与归并排序相同，因此可以在分治过程中对 $y$ 进行排序，复杂度可以优化至 $O(n\log n)$，不过本代码中并没有实现。

## 代码

```cpp
#include<bits/stdc++.h>
#define pi pair<int,int>
#define x first
#define y second
#define ll long long
using namespace std;
const int N=4e5+5;
int n;
pi a[N],b[N];
inline double dis(pi i,pi j){
	return sqrt((ll)(i.x-j.x)*(i.x-j.x)+(ll)(i.y-j.y)*(i.y-j.y));
}//计算距离
inline bool cmp(pi i,pi j){
	return i.y<j.y;
}
inline double solve(int l,int r){
	if(l==r) return 1e9;
	int mid=(l+r)>>1;
	double d=1e9;
	d=min(solve(l,mid),solve(mid+1,r));//分治计算
	int cnt=0;
	for(int i=l;i<=r;i++){//取出有用的点
		if(fabs(a[mid].x-a[i].x)<d) b[++cnt]=a[i];
	}
	sort(b+1,b+1+cnt,cmp);//对 y 排序
	for(int i=1;i<=cnt;i++){//暴力合并
		for(int j=i+1;j<=cnt;j++){
			if(b[j].y-b[i].y>=d) break;
			d=min(d,dis(b[i],b[j]));
		}
	}
	return d;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	sort(a+1,a+1+n);//对 x 排序
	double ans=solve(1,n);
	printf("%.0lf\n",ans*ans);//最后输出平方
	return 0;
}
```



---

## 作者：liuliucy (赞：4)

这道题显然可以直接用类似归并排序的方法写，我们先将区间分成 $[1,mid]$ 到 $[mid+1,r]$ 分别求最小距离 $d$ ，然后再求左右两边通过 $mid$ 的最小距离。如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/825g925u.png))

我们先二分 $A$，$B$ 点与 $C$，$D$ 点，求出最小距离为 $\sqrt{5}$，但显然不是正确答案，所以我们要搜索过 $mid$ 的最小距离，我们搜索 $[l,r]$ 区间的点，如果两点之间的 $x$ 轴距离小于两边的最小距离（否则不可能更优），则存入 $temp$ 数组中然后再两两之间再进行计算比较。

但是如果直接开 `long long`，毫无疑问会直接超时，所以我们用 `double` 直接储存距离，最后再平方求答案。
### CODE
记得最后要四舍五入。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long inf=1e18;
double sqr(double a){return a*a;}
struct xx{
	double x,y;
}a[400001];
double dis(xx a,xx b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
int b[400001];
bool cmp(int x,int y){
	return a[x].y<a[y].y;
}
bool cmp1(xx a,xx b){
	return a.x<b.x||a.x==b.x&&a.y<b.y;
}
double cdq(int l,int r){
	int mid=l+r>>1;
	if(l==r)return inf;
	if(r-l==1)return dis(a[l],a[r]);
	double d=min(cdq(l,mid),cdq(mid+1,r));
	b[0]=0;
	for(int i=l;i<=r;i++){
		if(d>fabs(a[i].x-a[mid].x)){
			b[++b[0]]=i; 
		}
	}
	sort(b+1,b+1+b[0],cmp);
	for(int i=1;i<=b[0];i++){
		for(int j=i+1;j<=b[0];j++){
			if(fabs(a[b[j]].y-a[b[i]].y)>=d)break;
			d=min(dis(a[b[j]],a[b[i]]),d);
		}
	}
	return d;
}
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+1+n,cmp1);
	double p=cdq(1,n);
	printf("%lld",(long long)(round(p*p))); 
} 
```


---

## 作者：Foreverxxx (赞：4)

广告：[更好的阅读体验](https://foreverxxx.blog.luogu.org/solution-p7883)

### 思路

首先我们可以想到对所有点按照 $x$ 坐标大小进行排序，这对答案不会造成影响。

然后我们考虑分治，也就是把整个区间的问题转化为一个个子区间的问题。

具体而言，对于当前所求的 $\left[l,r\right]$ 区间所有点的答案，我们可以把区间划分为 $\left[l,mid\right]$ 以及 $\left[mid+1,r\right]$ 两个区间进行分治递归，然后进行合并。

不难发现，对于当前区间答案的两个点，有 $3$ 种情况。

1. 两个点都在左区间。
2. 两个点都在右区间。
3. 一个点在左区间，一个点在右区间。

我们只需要考虑第三种情况就可以了。

我们现在有了两个子区间的答案 $d$，考虑枚举当前区间的所有点，很明显，有些点是不需要的，我们需要排除掉这些点。

我们先选出 $x$ 坐标位于中间那个点作为**基准点**，用来找到 $x$ 轴距离不超过 $d$ 的那些点，显然，如果 $x$ 坐标与基准点的距离差距大于了 $d$，则这个点一定不会被选到。

然后，我们对这些点两两进行枚举，计算答案，发现完全过不了。

很明显，$y$ 轴距离差距也是不能大于 $d$ 的。

所以思路就很明显了，我们将 $x$ 轴筛选出的点又对 $y$ 轴进行排序，然后枚举的时候判断 $y$ 轴距离是否大于 $d$，然后再进行计算。

此时的时间复杂度为 $T(n)=T(\frac{n}{2})+O(n \log n)=O(n \log n^2)$，不过会被卡。

所以我们对排序这一瓶颈进行优化。

很明显，两个子区间的 $y$ 轴已经进行了排序，如果在大区间内再次进行排序，那就是冗杂的操作了，所以我们可以考虑用归并排序替代 ``sort``，时间复杂度就被优化到了 $O(n \log n)$。

### 一些细节

1. 对于判断 $x$ 坐标的基准点，应在递归之前找到，因为递归会改变点的编号，造成 $x$ 轴并不是严格按照 $x$ 坐标进行排序。
2. 一定要注意题目问的是距离的平方，所以在判断的时候要注意精度问题。

Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int sss=0,www=1;
	char chh=getchar();
	while(chh<'0'||chh>'9'){
		if(chh=='-') www=-1;
		chh=getchar();
	}
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss*www;
}
int n;
struct node{
	int x,y;
}a[400005],tmp[400005];
int pos[400005];
bool cmp(const node& x,const node& y){
	return x.x<y.x;
}
int calc(const node& a,const node& b){
	return pow(a.x-b.x,2)+pow(a.y-b.y,2);
}
int merge(int l,int r){
	if(l==r) return 1e18;
	int mid=(l+r)>>1;
	int midx=a[mid].x;
	int dist=min(merge(l,mid),merge(mid+1,r));
	int i=l,j=mid+1,k=0;//l到mid,mid+1到r都是排好序l了的 
	while(i<=mid&&j<=r){
		if(i<=mid&&a[i].y<a[j].y){
            tmp[++k]=a[i++];
        }
		else {
            tmp[++k]=a[j++];
        }
	}
	while(i<=mid) tmp[++k]=a[i++];
	while(j<=r) tmp[++k]=a[j++];
	for(i=1;i<=k;i++){
		a[l+i-1]=tmp[i];
	}
	k=0; int tmp_dist=dist; dist=sqrt(dist);
	for(i=l;i<=r;i++){
		if(abs(a[i].x-midx)<=dist) tmp[++k]=a[i];
	}
	for(i=1;i<k;i++){
		for(j=i+1;j<=k&&tmp[j].y-tmp[i].y<=dist;j++){
			tmp_dist=min(tmp_dist,calc(tmp[i],tmp[j]));
			dist=sqrt(tmp_dist);
		}
	}
	return tmp_dist;
}
signed main(){
	n=read();
	for(register int i=1;i<=n;i++){
		a[i].x=read(),a[i].y=read();
	}
	sort(a+1,a+n+1,cmp);
	printf("%lld",merge(1,n));
	return 0;
}
```

---

## 作者：Emertyst (赞：4)

# 平面最近点对 题解

## 题意
题意就不解释了，原题说的很清楚。

## 思路
我们先将所有点按 $x$ 坐标从小到大的顺序排序，接着我们可以将要求最小距离的区间分为两部分，每一部分有一半的点。我们先分别求出这两个部分中的最小距离 $d_1,d_2$，但很显然，这个平面中最小距离并非 $d=\min(d_1,d_2)$，我们仍需考虑分界线附近是否会形成更短的距离。

那么如何快速计算分界线附近的距离呢？

我们在分治之前将所有点按 $x$ 坐标排序了，我们可以利用这一点，从分界线向两端查找并存储 $x$ 坐标与分界线的 $x$ 坐标相差小于 $d$ 的所有点（如果 $x$ 坐标相差大于等于 $d$，与对面的点之间的距离就一定会大于等于 $d$，一定不会成为答案）。这样我们从查找出的点中选两个，如果它们的 $y$ 坐标相差小于 $d$，我们计算它们之间的距离 $d'$，并与 $d$ 进行比较，更新 $d$ 的值即可。

但直接随便找两个点进行比较的效率比较低，为了提高效率，我们可以在查找到符合 $x$ 坐标条件的点后，把这些点根据 $y$ 坐标排序，接着从 $y$ 坐标的最大值（或最小值）开始查找，可以避免无用的计算。

使用主定理计算得时间复杂度 $O(n \log^2 n)$。

## 代码
```cpp
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;
typedef pair<int, int> Node;
const ll MAXN = 400005, INF = 1e16;
int n, tmp[MAXN];
Node node[MAXN];
ll sqr(int a) { return 1ll * a * a; }
ll dis(Node a, Node b) { return sqr(a.first - b.first) + sqr(a.second - b.second); }
ll merge(int l, int r) {
    if (l == r)
        return INF;
    if (l == r - 1)
        return dis(node[l], node[r]);
    int mid = l + r >> 1, cnt = 0;
    ll ans = min(merge(l, mid - 1), merge(mid, r));
    for (int i = mid - 1; i >= l && sqr(node[i].first - node[mid].first) < ans; --i)
        tmp[++cnt] = i;
    for (int i = mid; i <= r && sqr(node[i].first - node[mid - 1].first) < ans; ++i)
        tmp[++cnt] = i;
    sort(tmp + 1, tmp + cnt + 1, [&](int a, int b) -> bool { return node[a].second < node[b].second; });
    for (int i = 1; i < cnt; ++i)
        for (int j = i + 1; j <= cnt && sqr(node[tmp[i]].second - node[tmp[j]].second) < ans; ++j)
            ans = min(ans, dis(node[tmp[i]], node[tmp[j]]));
    return ans;
}
int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    cin >> n;
    for (int i = 1, x, y; i <= n; ++i)
        cin >> x >> y, node[i] = {x, y};
    sort(node + 1, node + n + 1), cout << merge(1, n);
}
```

---

## 作者：老官童鞋gogo (赞：4)

[博客体验更佳](http://laoguantx.top)

---
题目传送门[（普通版）](https://www.luogu.com.cn/problem/P1257)[（加强版）](https://www.luogu.com.cn/problem/P1429)[（加强加强版）](https://www.luogu.com.cn/problem/P7883)

---
## 题解正文
### 题目理解与强调 
在欧几里得平面上有n个点，找出一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。
### 思路分析
两次加强了数据，卡掉了通过旋转坐标系来错误地得到答案的做法。对于本题的加强加强版，可以通过一种简单的分治做法得到正确的答案。

首先我们要研究应该怎么去分治，我们可以先将所有的点按照横坐标进行排序，然后我们把所有的点对半劈开，分成两份，分别计算两份中的平面内最短距离，这一步，将一个大问题分成了两个小问题，然后递归下去，最终递归为每一份只有一个点。为了便于计算，我们将只有一个点的平面最短路径赋值为一个巨大值。

现在，我们已经将一个大问题分割成了许多小问题，下一步我们要研究每个小区间中的答案，在一个只有两个点的平面内，很显然答案就是两个点的距离。但是，求出了两个点之间的距离，我们要将其合并，在合并的时候，为了尽量地减小复杂度，我们就要避免不必要的计算。根据推理，我们可以推理出以下几条规律：
- 以两部分的分界线为标志，合成后的区间平面最近点对只有三种情况：
	1. 两点均在左区间。（在分治过程中已经求出）
	2. 两点均在右区间。（在分支过程中已经求出）
	3. 一个点在左区间，一个点在右区间
- 因为前两种情况已经求出，我们就可以限制 $d$ 的范围。对于第三种情况，在分界线两边的点如果距离分界线的垂直距离超过了 $d$，我们就可以直接跳过，因为这样的两点距离一定是大于等于 $d$ 的。
- 如果两个点的纵坐标超过了 $d$，我们也可以直接跳过。

通过以上三条规律的讨论，我们可以将枚举的点的范围缩小很多。在合并时，计算每个点距离分界线的距离，选出符合条件的点，再对选出的点进行排序，筛去不符合纵坐标要求的点，最后将剩下的点两两计算，与已知的 $d$ 进行比较，完成合并。
### 时间复杂度
经过 $\log n$ 次合并，每一次合并中含有一个  $O(n \log n)$ 的排序，所以复杂度为：
$$ O(n \log^2 n) $$

其中对于两点间的距离计算推荐使用乘方比较， `sqrt()` 开方运算所需时间长于乘法运算。

---
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define LL long long
#define uLL unsigned long long
#define reg register
#define PI acos(-1.0)
#define pb(x) push_back(x)
#define mp(a,b) make_pair(a,b)
#define fi first
#define se second
#define pr(x) cerr<<#x<<"="<<(x)<<endl
#define pri(x,lo) {cerr<<#x<<"={";for (int ol=0;ol<=lo;ol++)cerr<<x[ol]<<",";cerr<<"}"<<endl;}
#define inf 1000000000
#define INF 1000000000000000000
#define N 1000
#define M 1000001
template<class T>inline void read(T &x)
{
    x=0;register char c=getchar();register bool f=0;
    while(!isdigit(c))f^=c=='-',c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    if(f)x=-x;
}
template<class T>inline void print(T x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar('0'+x%10);
}
struct Node
{
	LL x,y;
}a[M],b[M];
int n;
bool cmpx(reg Node a,reg Node b)
{
	return a.x<b.x;
}
bool cmpy(reg Node a,reg Node b)
{
	return a.y<b.y;
}
int num;
inline LL work(reg int l,reg int r)
{
	if(l==r)	
		return INF;
	reg int mid=(l+r)>>1,now=0;
	reg LL d=min(work(l,mid),work(mid+1,r));
	for(reg int i=l;i<=r;i++)
	{
		if((a[mid].x-a[i].x)*(a[mid].x-a[i].x)<d)	
			b[++now]=a[i];
	}
	sort(b+1,b+1+now,cmpy);
	for(reg int i=1;i<now;i++)
	{
		for(reg int j=i+1;j<=now;j++)
		{
			if((b[j].y-b[i].y)*(b[j].y-b[i].y)>=d)
				break;
			d=min(d,(b[j].x-b[i].x)*(b[j].x-b[i].x)+(b[j].y-b[i].y)*(b[j].y-b[i].y));
		}
	}
	return d;
}
int main()
{
	read(n);
	for(reg int i=1;i<=n;i++)
	{
		read(a[i].x);
		read(a[i].y);
	}
	sort(a+1,a+1+n,cmpx);
	reg double ans=work(1,n);
	printf("%.4lf",sqrt(ans));
	return 0;
}

```

---

## 作者：ncwzdlsd (赞：3)

这篇题解要介绍的是正解的分治做法。

我们按照 $x$ 的值即横坐标进行分治，其实就是一个不断二分区间的过程。利用 $y$ 的值即纵坐标进行归并排序。

为了方便起见，我们首先可以定义一个函数专门用来求两点之间的欧拉距离：

```cpp
int dis(int a,int b)//计算两点间距离
{
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}
```

然后我们就可以考虑分治了。我们用一条线不断分割区间，显然对于要求的“最近点对”，一共由三种情况：

1. 在左区间内

2. 在右区间内

3. 横跨左右区间

对于前面的两种情况，我们可以用分治操作来递归解决。我们假设在左区间和右区间里求得的点对举例最小值 $d$ ，那么对于满足情况 $3$ 的跨区间点对，我们在左右区间靠近中分线的的位置各画一条举例中分线为 $d$ 的线，可知最近点对一定在这两条线之间。证明很简单，因为只有这样才有可能替换掉当前最小的 $d$。

我们可以开一个新的数组 `q` 来存储这两条线之间的点。把区间按照纵轴方向分成宽度为 $d$ 的几组。为什么要这样分？可以考虑对于这个区间内的任意一个点，为了满足点对距离最短，我们以 $d$ 为半径画圆，最近点对一定在这个圆内，所以我们按照 $d$ 纵向分割，之后，对一个点，我们只需要考虑与它相邻的、在它上方的、下方的 $d\times d$ 方块中的点。又由于可以证明每个方块中至多有 $2$ 个点，于是乎我们最多只需要枚举 $6$ 个点，时间复杂度达标。

总时间复杂度为 $O(n\log n)$，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=4*1e5+5;

struct node
{
    long long x,y;
}dot[maxn];

long long q[maxn];

inline bool cmp(int a,int b)
{
    return dot[a].y<dot[b].y;
}

inline bool cmpp(node a, node b) 
{
    return a.x<b.x;
}

inline long long dis(int a,int b)//计算两点间距离
{
    return (long long)(dot[a].x-dot[b].x)*(dot[a].x-dot[b].x)+(long long)(dot[a].y-dot[b].y)*(dot[a].y-dot[b].y);
}

long long work(int l,int r)
{
    if(l==r) return 1ll<<62;
    if(l==r-1) return dis(l,r);
    long long mid=(l+r)>>1;
    long long d;
    d=min(work(l,mid),work(mid+1,r));
    int tot=0;//记录q集合中的总点数
    for(int i=l;i<=r;i++)
        if(1ll*(dot[mid].x-dot[i].x)*(dot[mid].x-dot[i].x)<d) q[++tot]=i;//q存储编号
    sort(q+1,q+tot+1,cmp);
    for(int i=1;i<=tot;i++)
        for(int j=i+1;j<=tot&&1ll*(dot[q[i]].y-dot[q[j]].y)*(dot[q[i]].y-dot[q[j]].y)<d;j++)
            d=min(d,dis(q[i],q[j]));
    return d;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    long long n;cin>>n;
    for(long long i=1;i<=n;i++) cin>>dot[i].x>>dot[i].y;
    sort(dot+1,dot+n+1,cmpp);
    cout<<work(1,n);
    return 0;
}
```

---

## 作者：creation_hy (赞：3)

~~那个人类智慧的蚌埠住了~~

这题做法和 P1429 是一样的，就是分治加贪心。

先把所有点按照 $x$ 排序，找一个 $mid$ 点划分边界，进行分治。

考虑答案中两点的分布。

都在左边：即 $solve(l,mid)$ 的解。并计入 $res$。

都在右边：即 $solve(mid+1,r)$ 的解。并计入 $res$。

一个在左边一个在右边：

首先排除到 $mid$ 那条线的直线距离已经超过 $res$ 的点。因为一个点到线对面另一个点的距离显然大于它到线的直线距离。

接下来把所有符合上面条件的点存入一个点集，并把点集按 $y$ 排序。

然后对于任何一个点 $a$ 来说，如果有一个点 $b$ 满足 $b_y-i_y\ge res$，那么编号大于等于 $b$ 的点显然也不能成为答案，因为光直线距离都已经超过 $res$ 了。

于是，枚举点集中的 $i$，找所有编号在 $i$ 之后，且直线距离不超过 $res$ 的 $j$ 即可。

注意一点：本题要求的是距离的平方，所以在筛点的时候不要忘记取平方……

代码：

~~数组名叫vec是因为我一开始用的vector~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e5 + 5;
int n, vec[N], tail;
struct node
{
    ll x, y;
    inline const bool operator<(const node &t) const
    {
        return x == t.x ? y < t.y : x < t.x;
    }
} a[N];
inline ll dis(int x, int y)
{
    return (a[x].x - a[y].x) * (a[x].x - a[y].x) + (a[x].y - a[y].y) * (a[x].y - a[y].y);
}
inline bool cmp(const int &x, const int &y)
{
    return a[x].y < a[y].y;
}
inline ll solve(int l, int r)
{
    if (l == r)
        return 1e18;
    if (l + 1 == r)
        return dis(l, r);
    int mid = l + r >> 1;
    ll res = min(solve(l, mid), solve(mid + 1, r));
    tail = 0;
    for (int i = l; i <= r; i++)
        if (fabs(a[mid].x - a[i].x) * fabs(a[mid].x - a[i].x) < res)
            vec[++tail] = i;
    sort(vec + 1, vec + 1 + tail, cmp);
    for (int i = 1; i <= tail; i++)
        for (int j = i + 1; j <= tail && (a[vec[j]].y - a[vec[i]].y) * (a[vec[j]].y - a[vec[i]].y) < res; j++)
            res = min(res, dis(vec[i], vec[j]));
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i].x >> a[i].y;
    sort(a + 1, a + 1 + n);
    cout << solve(1, n);
    return 0;
}
```

---

## 作者：KK_lang (赞：2)

## $\texttt{1. Meaning}$

[传送门](https://www.luogu.com.cn/problem/P7883)

给定平面上的 $n$ 个点，求最近的点对（的距离）。

## $\texttt{2. Key Ideas}$

朴素做法：$O(n^2)$

双重循环枚举点对，更新答案。

$n_{max}=4×10^5$，会 $\texttt{TLE}$。

由于是点对之间的问题，考虑使用分治法，类似于归并排序过程。

而对于分治法，我们需要将大问题转化为多个子问题，自然需要将点集 $E$ 分为两个点集 $E_1$ 和 $E_2$。先用 $x$ 从小到大排序，取中间点 $P_{mid=(l+r)/2}$，用直线 $x=X_{P_{mid}}$ 分割两个点集。

如图。

（图 $1$）
![](https://cdn.luogu.com.cn/upload/image_hosting/pq996pvf.png)

$ans_{\{E\}}=min{\{ans_{\{E_1\}},ans_{\{E_2\}},dis(x,y)_{∀x∈\{E_1\},∀y∈\{E_2\}}\}}$


$ans_{\{E\}}$ 表示 $\{E\}$ 点集内部的最近点对。

由于答案取的是 $min$，所以可以进行一个优化，如下：

全局变量 $ans$ 记录当前最近点对，初值是 $9×10^{18}$；对于 $ans=x$，若 $y>x$，则一定存在至少一对点对比 $y$ 距离更近，则 $y$ 一定不是答案。

建立临时集合 $E_t$，对于当前操作区域（$[lpos,rpos]$）中的 $P_{i}$，若 $|X_{P_{mid}} - X_{P_i}|>ans$，则不加入集合。后续操作只在该集合中进行，因为只有这个集合是有意义的。

如图，假设 $ans=2$，则图中所标的黄色点是有意义的。

（图 $2$）
![](https://cdn.luogu.com.cn/upload/image_hosting/0bb646fn.png)

但是仍然不能优化太多，如图，存在像下图一样几乎没有优化的例子。

（图 $3$）
![](https://cdn.luogu.com.cn/upload/image_hosting/exb4p6qu.png)

此时我们只做了 $x$ 维度上的优化，我们可以推广到 $y$ 维度上。

我们以 $y=Y_{P_{i}}$ 为上边界，$y=Y_{P_{i}}-ans$ 为下边界，两条圈定 $E_t$ 的分界线（图 $3$ 中 $Z$ 与 $A_1$）为左右边界，做一个 $ans×2ans$ 的长方形。

而 $P_{i}$ 的最近点对一定在该长方形内。

如图，以图 $1$ 中 $D$ 点为例，做长方形。有一一点已标紫

（图 $4$）
![](https://cdn.luogu.com.cn/upload/image_hosting/uc7d4yv0.png)

考虑长方形内点的个数，经验算，任意两点距离都 $\geq ans$ 的点的个数，最多 $6$ 个，所以复杂度基本降到常数级。

这就是最关键的优化。有一点：为了遍历到第一个不合法就停止，需要对 $y$ 排序。

朴素 $sort$ 它，总复杂度 $O(n \log n^2)$，可能会被卡。

#### $\texttt{P.S.}$ 分治共 $\log n$ 层，排序占一个 $\log n$，所以是 $\log n^2$。

利用归并排序的本身特点，进行归并操作。一共 $O(n)$。最终复杂度 $O(n \log n)$，全局再排序一下 $x$：

#### 最终定格在 $O(n \log n)$。

## $\texttt{3. AC Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n, ans = 9e18;
struct Node 
{ 
	int x, y;
	friend bool operator < (const Node &a, const Node &b)
	{ return a.y < b.y; }
};
Node p[1000010], b[1000010];

bool cmpx(Node a, Node b)
{ return a.x < b.x; }

bool cmpy(Node a, Node b)
{ return a.y < b.y; }

int dis(int x1, int x2, int y1, int y2)
{ return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); }

void merge(int lpos, int rpos)
{
	int l = lpos, r = (lpos + rpos) / 2 + 1;
	for (int i = lpos; i <= rpos; i++)
	{
		b[i] = {0, 9000000000000000000};
		if (l <= (lpos + rpos) / 2) b[i] = min(b[i], p[l]);
		if (r <= rpos) b[i] = min(b[i], p[r]);
		if (l <= (lpos + rpos) / 2 && !(b[i] < p[l]) && !(p[l] < b[i])) l++;
		else r++;
	}
	for (int i = lpos; i <= rpos; i++) p[i] = b[i];
}

void dfs(int lpos, int rpos)
{
	if (lpos >= rpos) return;
	int mid = (lpos + rpos) / 2;
	int t = p[mid].x;
	dfs(lpos, mid);
	dfs(mid + 1, rpos);
	merge(lpos, rpos);
	int sz = 0;
	for (int i = lpos; i <= rpos; i++)
		if ((p[i].x - t) * (p[i].x - t) < ans)
			b[++sz] = p[i];
	for (int i = 1; i <= sz; i++)
		for (int j = i + 1; j <= sz; j++)
		{
			if ((b[j].y - b[i].y) * (b[j].y - b[i].y) > ans) break;
			ans = min(ans, dis(b[i].x, b[j].x, b[i].y, b[j].y));
		}
}

signed main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y;
	sort(p + 1, p + n + 1, cmpx);
	dfs(1, n);
	printf("%lld\n", ans);
	return 0;
}
```

---

**[GeoGebra](https://www.geogebra.org/classic)** 做图、**[洛谷图床](https://www.luogu.com.cn/image)**

---

## 作者：Hjcc187 (赞：2)

随机化做法

- 在平面上随机一个点

- 以这个点为原点对所有点进行极角排序 (大约就是根据到原点的方向排序)

- 排序后临近的点统计答案

- 可以重复多次

- 根据直觉进行调参

经过数分钟的调参，我们以下面这份代码通过了此题：(c++98)

```cpp
# include <bits/stdc++.h>
# define min(a, b) (a<b?a:b)

using namespace std;

int n;
int eps;
struct dis {
  long long x;
  long long y;
} d[500500];

long long xp, yp;
inline long long L(dis a, dis b) {
  return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

int cmp(dis a, dis b) {
  return a.x * b.y < b.x * a.y;
}

int main() {
  srand(4);
  scanf("%d", &n);
  eps = 300000000 / n;
  register long long ans;
  for (register int i = 1; i <= n; i++) {
    scanf("%lld%lld", &d[i].x, &d[i].y);
  }
  ans = L(d[1], d[2]);
  xp = rand() % 6000001;
  yp = rand() % 6000001;
  for (register int i = 1; i <= n; i++) {
    d[i].x -= 3000000 + xp;
    d[i].y -= 3000000 + yp;
  }
  sort(d + 1, d + 1 + n, cmp);
  for (register int i = 1; i < n; i++) {
    for (int j = i + 1; j <= min(n, i + eps); j++) { //这里懒得取模了aua
      ans = min(ans, L(d[i], d[j]));
    }
  }
  printf("%lld\n", ans);
  return 0;
}
```


---


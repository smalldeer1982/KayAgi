# 交友问题

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pu73hyh9.png)

## 题目描述

洛谷上有 $n$ 位用户，这些用户组成了一个双向的网络。

洛谷的图片分享机制如下：如果第 $i$ 个用户向他的好友 $j$ 分享了一张照片，那么，$j$ 的所有好友 $k$ 就能看到这张照片。**$j$ 也可以看到这张照片。**

现在，用户 $u_i$ 想分享一张照片，但是TA不想让用户 $v_i$ 看到这张照片。在不发送给自己的情况下，TA想知道，他最多可以发送给多少位好友？

## 说明/提示

对于 $20\%$ 的数据，满足 $1 \le n,q \le 2\times10^3$，$1\le m \le 8\times 10^3$；

对于 $60\%$ 的数据，满足 $1 \le n,q \le 2\times10^4$，$1\le m \le 5\times 10^4$；

对于 $100\%$ 的数据，满足 $1 \le n,q \le 2\times10^5$，$1\le m \le 7\times 10^5$。

**保证没有重边和自环**

## 样例 #1

### 输入

```
6 7 8
5 1
1 4
1 6
5 6
5 4
1 2
5 3
5 3
1 1
3 6
1 5
5 6
1 4
5 2
2 6```

### 输出

```
3
0
0
1
2
2
3
0```

# 题解

## 作者：阿丑 (赞：14)

[题目传送门](/problem/P8250)

#### 前置知识：

根号分治。

#### 简要题意：

- 给定一个 $n$ 个点 $m$ 条边的无向图，$q$ 次询问，每次询问给出两个点 $u,v$，询问有多少与 $u$ 相邻的点不与 $v$ 相邻也不是 $v$ 本身。
- $n,q\le2\times10^5$，$m\le7\times10^5$。

#### 分析：

记点 $u$ 的度数为 $deg_u$。

记询问 $u,v$ 的答案为 $g_{u,v}$，则 $g_{u,v}$ 即为 $deg_u$ 减去 $u$ 与 $v$ 的公共相邻点个数，若 $u$ 与 $v$ 相邻，再减去 $1$。考虑如何求 $deg_u-g_{u,v}$，即 $u$ 与 $v$ 的公共相邻点个数，若 $u$ 与 $v$ 相邻，再加上 $1$。

考虑暴力。对于单次询问，找出所有与 $u$ 相邻的节点并将其打上标记；再找出所有与 $v$ 相邻的点，统计其中有标记的点的数量，即 $u$ 与 $v$ 公共相邻点的数量；若 $v$ 有标记，再加上 $1$。放一个代码片段方便理解。

```cpp
memset(vis, 0, sizeof vis);
for(int z: ver[u]) {
	vis[z]=1;
}
int ans=vis[v];
for(int z: ver[v]) {
	ans+=vis[z];
}
printf("%d\n", deg[u]-ans);
```

单次询问更优的实现（对标记“懒”清空）可以做到 $\mathcal O(deg_u+deg_v)=\mathcal O(m)$，总复杂度 $\mathcal O(mq)$，期望 20pts。[实测](/record/91280283) 88pts。

考虑优化。如果有两个询问完全相同，则不重复计算；即对询问去重。同时，对于同一个 $x$，我们统一处理所有 $u=x$ 的询问。这些询问只需打一次标记，复杂度 $\mathcal O(deg_x)$；遍历所有 $v$ 及其相邻边复杂度 $\mathcal O(m)$。对于所有的 $x$，总复杂度 $\mathcal O(\sum_x(deg_x+m)+q)=\mathcal O(nm+q)$，期望还是 20pts。[实测](/record/91279786) 100pts。

上述过程中我们可以处理 $\mathcal O(n^2)$ 个询问，而总共只需要处理 $q$ 个询问。继续考虑优化。注意到 $deg_u-g_{u,v}$ 中，$u$ 和 $v$ 的地位是相等的，不妨让 $u$ 成为其中 $deg$ 较大者。于是，当 $deg_u<B$ 时，一次询问的复杂度为 $\mathcal O(deg_u+deg_v)=\mathcal O(B)$；当 $deg_u\ge B$ 时，因为 $\sum deg=2m$，所以最多存在 $\lfloor\frac {2m}B\rfloor$ 个不同的 $u$，按照上述优化遍历所有不同的 $u$ 对应的 $v$ 及其相邻边的复杂度为 $\mathcal O(\frac mB\times m)$。总复杂度 $\mathcal O(qB+\frac{m^2}B)$。

这个上界对所有的正实数 $B$ 都成立。可以取 $B=\frac m{\sqrt q}$，此时的上界是 $\mathcal O(m\sqrt q)$。在非特殊构造的数据下很难达到这个上界，期望 100pts。[实测](/record/91251695) 100pts。

需要注意的是，这一步的优化保证了 $deg_u\ge deg_v$，而优化 1 没有，所以不能直接对优化 1 套用这里的复杂度分析。

---

由于对两种点的做法是一样的，所以代码比较简单。因为用了快排去重，所以代码的复杂度是 $\mathcal O(n+m\sqrt q+q\log q)$。空间复杂度 $\mathcal O(n+m+q)$。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l, _=r; i<=_; ++i)
using namespace std;
typedef long long ll;
const int mN=2e5+9, mM=7e5+9;
int n, m, q, deg[mN];

vector<int> ver[mN];

int ans[mN];
vector<pair<int, int> > qn[mN];

int vis[mN];

int main() {

	scanf("%d%d%d", &n, &m, &q);
	rep(i, 1, m) {
		int x, y;
		scanf("%d%d", &x, &y);
		++deg[x], ++deg[y];
		ver[x].push_back(y), ver[y].push_back(x);
	}
	rep(i, 1, q) {
		int x, y;
		scanf("%d%d", &x, &y);
		ans[i]=deg[x];	//ans 的剩余部分（deg[x]-g(x, y)）中，x y 地位相等 
		if(deg[x]<deg[y]) swap(x, y);	//保证 x 的 deg 更大 
		qn[x].push_back({y, i});
	}

	rep(x, 1, n) {
		sort(qn[x].begin(), qn[x].end());	//为了去重

		for(int y: ver[x]) {
			vis[y]=x;
		}
		int lst=0, lstans=0;
		//lst 记录上一个询问的 y, lstans 记录上一个询问的 deg[x]-g(x, y)
		for(auto ask: qn[x]) {
			const int y=ask.first, id=ask.second;
			if(y==lst) {
				ans[id]-=lstans;
				continue;
			}
			lstans=vis[y]==x;
			for(int z: ver[y]) {
				lstans+=vis[z]==x;
			}
			ans[id]-=lstans;
			lst=y;
		}
	}
	rep(i, 1, q) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Yanami_Anna (赞：11)

### 简要题意

一张 $n$ 个点 $m$ 条边的图，$q$ 次询问，每次询问给出两个点 $a$ 和 $b$，求出 $a$ 的邻接表中有多少个点不是 $b$ 的邻接点。

### 思路

首先考虑朴素暴力做法，硬枚两点邻接表，然后看当前 $a$ 的邻接点是不是 $b$ 的邻接点，这个算法菊花图可以卡成 $O\left(qn^2\right)$，非常下流。

考虑优化这个暴力算法，我们先把 $a$ 的邻接点全部打上标记，然后让 $b$ 访问邻接点，算出标记数量——这是 $a$ 与 $b$ 的邻接点的交集大小——然后答案就是 $a$ 的邻接点数量与标记数量的差，这个算法用菊花图可以卡成 $O\left(qn\right)$，非常低级。

考虑再优化这个暴力算法，我们把一个询问 $a,b$ 认为是 $a$ 查询 $b$，$b$ 被 $a$ 查询。

---

分界线以下的暴力算法lg数据都没卡，建议加强。

那么如果查询者 $a$ 相同，就没有必要重新打标记，而是只需要查 $b$ 的邻接表，考虑离线询问然后每次对于相同点 $a$ 打一遍标记然后让 $b$ 来查，这样一次时间复杂度最劣是 $O\left(qn\right)$ 的，考虑构造一张次菊花图，然后不断询问两个花蕊。

你可能会说，啊，那这个题简直愚蠢至极，开个记忆化不就过了吗？

错误无比的，因为你预处理完之后你的访问顺序是按编号访问，预处理到的很有可能不是花蕊，比如说我构造一组这样的例子，说花瓣的编号分别是 $1\sim n-1$，花蕊的编号是 $n$ 这样怎么记忆化都会被卡。

你可能会说，啊，那这个题简直愚蠢至极，按照度数排序不就过了吗？

设最大度数为 $Max$，次大度数为 $Max'$，那么我不断询问 $Max'$ 就能卡飞你。

你可能会说，啊，那这个题简直愚蠢至极，按照度数与询问次数的乘积排序不就过了吗？

菊花图，让花瓣询问花蕊 $q$ 轮，然后因为花蕊是被询问的点所以没有动静，这样就能卡飞你。

分界线以上的暴力算法lg数据都没卡，建议加强。

---

你可能会说，啊，那这个题简直愚蠢至极，把点拆成询问和被询问两个点然后按照度数与询问/被询问次数的乘积排序不就做完了吗？

对的，就这么做。

你可能会说，啊，那这个时间复杂度难证至极，怎么证明时间复杂度？

对于一个点做得一次操作，最顶的时间复杂度为 $O\left(n+m\right)$，拢共 $q$ 次询问，你是不是觉得时间复杂度应该被草上 $O\left(q\left(n+m\right)\right)$？

考虑这样做需要多少次询问，容易发现，如果使用少于 $\sqrt{m}$ 次询问，一个点的度数就必然会比我现在访问的点要大，也就是说这个询问早就处理过了，不需要再处理一次，也就是说这玩意顶多卡出 $\frac{q}{\sqrt{m}}\leqslant\sqrt{q}$ 组满 $m$ 询问。

由此，时间复杂度为 $O\left(n\sqrt{q}\right)$，跑得比根号分治的正解要快得多。

暴力代码，不想贴。

---

## 作者：_determination_ (赞：7)

根号分治。

暴力 1：

考虑直接枚举 $u$ 的邻居并开个 `map` 判断是否是 $v$ 的邻居。记得特判 $u$ 和 $v$ 相邻的情况。

时间复杂度 $O(qn \log n)$。

暴力 2：

对于每个点开 `bitset` 存储所有邻居（包括自己）。

利用位运算可以快速排除 $u$ 的邻居中同时也是 $v$ 的邻居的点。记住要清掉 $u$ 和 $v$。

时间复杂度 $O(\dfrac{qn}{w})$，空间复杂度 $\dfrac{n^2}{w}$。

暴力 3：

枚举 $v$ 的邻居并在 $u$ 的 `bitset` 中排除。

时间复杂度 $O(qn)$。

---

考虑根号分治。设阈值为 $B$。以下称度数大于阈值的为大点，否则为小点。显然每个点的度数之和为 $2m$，那么大点数量最多为 $\dfrac{2m}{B}$。之后预处理大点连接边的 `bitset`。

1. $u$ 为小点。

   直接采用暴力 1 即可。时间复杂度 $O(qB \log n)$。
2. $u$ 为大点，$v$ 为大点。

   使用暴力 2。时间复杂度 $O(\dfrac{qn}{w})$。
3. $u$ 为大点，$v$ 为小点。

   使用暴力 3。时间复杂度 $O(qB)$。

由于大点最多可能会有 $\dfrac{2m}{B}$ 个，所以空间复杂度大概在 $\dfrac{nm}{B}$。

取 $B$ 为 40 时可以通过。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=1e9+7,inf=0x3f3f3f3f3f3f3f3f;
const int B=40;
vector<bitset<200010> >vec;
vector<int>e[200010];
map<int,int>mp[200010];
int n,m,q;
int id[200010];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m >>q;
	while(m--)
	{
		int u,v;
		cin >> u >>v;
		e[u].push_back(v);
		e[v].push_back(u);
		mp[u][v]=mp[v][u]=1;
	}
	for ( int i = 1 ; i <= n ; i++ )
	{
		if(e[i].size()>B)
		{
			id[i]=vec.size();
			vec.push_back(0);
			for ( auto v:e[i] )vec[id[i]][v]=1;
			vec[id[i]][i]=1;
		}
	}
	while(q--)
	{
		int u,v;
		cin >> u >> v;
		if(e[u].size()<=B)
		{
			int ans=0;
			for ( auto i:e[u] )
			{
				if(!mp[v][i]&&i!=v)ans++;
			}
			cout << ans << endl;//Blogn
		}else{
			if(e[v].size()>B)
			{
				bitset<200010>bit=((vec[id[u]]&vec[id[v]])^vec[id[u]]);
				bit[u]=0;
				cout << bit.count() << endl;//n/w,[n^2/8/B]
			}else{
				bitset<200010>bit=vec[id[u]];
				for ( auto i:e[v] )
				{
					bit[i]=0;
				}
				bit[v]=0;
				bit[u]=0;
				cout << bit.count() << endl;//B
			}
		}
	}
	return 0;
}
```

---

## 作者：RedLycoris (赞：5)

~~2020年的J组模拟，2022年终于进主题库了~~

知识点：根号分治

subtask 1：

利用 map 存储，然后暴力。

时间复杂度: $O(n^2\log n)$

subtask 2:

对于每一个节点都开一个 bitset  存储邻接点。(设为 $b_i$ )

查询用 $b_u \ xor \ (b_u \ and \ b_v)$ 即可。$xor$ 为按位异或，$and$ 为按位与。

时间&空间复杂度: $O(\frac{n^2}{\omega})$

subtask 3:

考虑将 subtask 1 和 2 结合起来。

我们设定一个阈值 $limit$。

对于所有度数大于 $limit$ 的节点，我们用 bitset。反之，我们用 map。

 $limit$ 大约取在能让大约 $\sqrt{n}$ 个点用 bitset 即可。

查询的时候要分类讨论。（具体见代码）

时间&空间复杂度:$O(n\times\sqrt{\frac{n\log n}{\omega}})$

Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define mp make_pair
#define ri register int
#define ld long double
using namespace std;
const int mxn=2e5+5;
vector<int>g[mxn];
int n,m,q;
int lim;
vector<int>heavy;
int id[mxn];
vector<bitset<mxn> >T;
map<int,int>have[mxn];
int deg[mxn];
inline void solve(){
	scanf("%d%d%d",&n,&m,&q);
	//cerr<<lim<<'\n';
	for(ri i=1,u,v;i<=m;++i){
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
		++deg[u];
		++deg[v];
	}
	sort(deg+1,deg+n+1);reverse(deg+1,deg+n+1);
	lim=deg[min(n,(int)(sqrt(n)*6))];//根号处分治
	memset(id,-1,sizeof(id));
	for(ri i=1;i<=n;++i){
		if(g[i].size()>lim){
			heavy.push_back(i);
			id[i]=heavy.size()-1;bitset<mxn>newb;
			newb&=0;
			for(ri j=0;j<g[i].size();++j)newb[g[i][j]]=1;
			T.push_back(newb);
		}else{
			for(ri j=0;j<g[i].size();++j)have[i][g[i][j]]=1;
		}
	}
	for(ri i=1;i<=q;++i){
		ri u,v;scanf("%d%d",&u,&v);
		if(~id[u] and ~id[v]){  //对两个点是否是重点分类讨论
			bitset<mxn>tmp=T[id[u]]^(T[id[u]]&T[id[v]]);
			tmp[u]=0;tmp[v]=0;
			printf("%d\n",tmp.count());
		}else if(~id[u]){
			ri ans=0;
			for(ri j=0;j<g[v].size();++j)if(g[v][j]==u or g[v][j]==v or T[id[u]][g[v][j]])++ans;
			printf("%d\n",T[id[u]].count()-ans);
		}else if(~id[v]){
			ri ans=0;
			for(ri j=0;j<g[u].size();++j)if(g[u][j]!=u and g[u][j]!=v and !T[id[v]][g[u][j]])++ans;
			printf("%d\n",ans);
		}else{
			ri ans=0;
			for(ri j=0;j<g[u].size();++j)if(g[u][j]!=u and g[u][j]!=v and !have[v][g[u][j]])++ans;
			printf("%d\n",ans);	
		}
	}
}
int main(){
	solve();
	return 0;
}
```

---

## 作者：chenly8128 (赞：3)

### 知识点

- 根号分治
- 归并
- 简单的图论知识

### 思路

提供一种不用 `bitset` 压位卡常的分治方法。~~但是需要预处理。~~

首先运用根号分治的标准套路，将点分成两类：度数大于某个特定值 $K$ 的点（称为大点），和度数小于等于特定值 $K$ 的点（称为小点）。

先说预处理，有两部分：

- 给每个点连接的点排序，方便后续归并。
- 对于每一个大点，预处理出到达**与它直接相连，或距离在 $2$ 以内**的节点的不同路径数。对于单个大点，复杂度 $O(m)$。

然后设计两个专门解决不同情况的方法：

- 如果 $u$ 和 $v$ 都是小点，那么可以归并两个点共同能够连接到的点。复杂度 $O(K)$。
- 如果有大点，运用预处理结果，直接减出答案。

当 $K = \sqrt m$ 时，复杂度 $O((m+q)\sqrt m)$。只要数据不是很奇特，[就能过](https://www.luogu.com.cn/record/206120940)。

### 代码


```cpp

// Author: chenly8128
// Created: 2025-03-05 18:28:56

#include <bits/stdc++.h>
using namespace std;
inline int read(void) {
	int res = 0;bool flag = true;char c = getchar();
	while (c < '0' || c > '9') {flag ^= (c == '-');c = getchar();}
	while (c >= '0' && c <= '9') {res = (res << 3) + (res << 1) + (c ^ 48);c = getchar();}
	return flag ? res : -res;
}
const int MAXN = 2e5+10;
const int tmp = 800;
int n,m,q,u,v;
int id[MAXN],cnt;
vector <int> g[MAXN];
vector <vector<int> > res(1);
int main (void) {
	n = read(); m = read(); q = read();
	for (int i = 1;i <= m;i++) {
		u = read(); v = read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for (int i = 1;i <= n;i++)
		sort(g[i].begin(),g[i].end());
	for (int i = 1;i <= n;i++)
		if (g[i].size() > tmp) {
			id[i] = ++cnt;
			res.push_back(vector<int>(n+10,0));
			for (int j : g[i]) {
				res[cnt][j]++;
				for (int k : g[j])
					res[cnt][k]++;
			}
		}
	while (q--) {
		u = read();v = read();
		if (u == v) {puts ("0");continue;}
		if (g[u].size() <= tmp && g[v].size() <= tmp) {
			int rr = 0;
			for (int i = 0,j = 0;i < g[u].size();i++) {
				while (j < g[v].size() && g[v][j] < g[u][i]) j++;
				if (g[u][i] == v
					|| (j < g[v].size() && g[v][j] == g[u][i])) rr++;
			}
			printf ("%d\n",g[u].size()-rr);
		}
		else {
			int tt = g[u].size();
			if (g[u].size() < g[v].size()) swap(u,v);
			printf ("%d\n",tt-res[id[u]][v]);
		}
	}
	return 0;
}
```

---

## 作者：Union_Find (赞：2)

先考虑问题，就是查询有多少个点是 $u$ 的邻居且不是 $v$ 的邻居。这个问题可以转化为 $u$ 的邻居数量减去 $u$ 和 $v$ 共同的邻居数量。

前者好处理，后者显然根号分治。我们称度数大于 $\sqrt n$ 的点为**大点**，反之称作**小点**。

1. $u$ 和 $v$ 都是大点
   
   因为大点最多只有 $\sqrt n$ 个，我们可以给每个大点开一个 `bitset` 去处理。

2. $u$ 和 $v$ 都是小点

   小点度数都小于 $\sqrt n$，我们可以直接开一个 `bitset`，暴力枚举 $u$ 的邻居和 $v$ 的邻居。

3. $u$ 和 $v$ 一个大点，一个小点

   这个更简单，直接枚举小点的邻居，然后判断是否是大点的邻居。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define il inline
#define N 300005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n, m, q, u, v, sqn, du[N], bg[N], cnt;
bitset <N> st[555];
vector <ll> e[N];
int main(){
	n = rd(), m = rd(), q = rd(), sqn = sqrt(n); 
	for (int i = 1; i <= m; i++)
		u = rd(), v = rd(), du[u]++, du[v]++, e[u].push_back(v), e[v].push_back(u);
		for (int i = 1; i <= n; i++) if (du[i] > sqn) bg[i] = ++cnt;
	for (int i = 1; i <= n; i++) if (du[i] > sqn){
		for (int u : e[i]) st[bg[i]].set(u);
	}
	while (q--){
		u = rd(), v = rd();
		if (du[u] > sqn && du[v] > sqn){
			bitset <N> ls;
			ls = st[bg[u]] & st[bg[v]];
			printf ("%d\n", e[u].size() - ls.count() - st[bg[u]][v]);
		}else if (du[u] > sqn || du[v] > sqn){
			ll res = 0, p = u;
			if (du[u] > du[v]) swap(u, v);
			for (int w : e[u]) if (st[bg[v]][w]) res++;
			if (st[bg[v]][u]) res++;
			printf ("%d\n", e[p].size() - res);
		}else{
			ll res = 0;
			bitset <N> ls;
			ls.set(u);
			for (int w : e[u]) ls.set(w);
			for (int w : e[v]) if (ls[w]) res++;
			printf ("%d\n", e[u].size() - res);
		} 
	}
	return 0;
}

```

---

## 作者：CrTsIr400 (赞：2)

## 题外话

出题人题解的时间复杂度实际上是错的，是 $O(\dfrac{nm}{w})$。只不过刚好可以过。

## 题意

> 洛谷上有 $n$ 位用户，这些用户组成了一个双向的网络。
>
> 洛谷的图片分享机制如下：如果第 $i$ 个用户向他的好友 $j$ 分享了一张照片，那么，$j$ 的所有好友 $k$ 就能看到这张照片。**$j$ 也可以看到这张照片。**
>
> 现在，用户 $u_i$ 想分享一张照片，但是TA不想让用户 $v_i$ 看到这张照片。在不发送给自己的情况下，TA想知道，他最多可以发送给多少位好友？
>
> 对于 $100\%$ 的数据，满足 $1 \le n,q \le 2\times10^5$，$1\le m \le 7\times 10^5$。

解法：

+ 考虑两个暴力。但是**首要需要平衡的反而是空间**。
+ 共性：两个暴力的核心思想都是计算 $u_i$ 和 $v_i$ 出边所访问到的点的交集（包括 $u_i$ 和 $v_i$ 本身）。
  + 第一个暴力：$O(m\log m)-O(qn \log m)$。考虑每次查询，暴力枚举访问点 $w_i$，查询有没有 $w_i-v_i$ 的边。
  + 如果 $u_i$ 的**出边很稀疏**的话，这个算法会很快；反之，会很慢。
  + 这个算法的**空间问题没那么明显**，比较慢，但是能跑得出来。
  + 第二个暴力：$O(\dfrac{n^2}{w})-O(\dfrac{qn}{w})$。考虑每个点上维护一个可访问数组 $b_i$，只需要输出 `(b[u]^(b[u]&b[v])).size()` 即可。
  + 这个算法会很快，理论上可以过的。但是**空间爆了**。
+ 于是考虑把两个暴力结合起来。故技重施，设 $t$ 为**节点访问点数**（数值上，**等于节点度数+1**）的阈值。
+ 其值域是 $[1,n]$，其总和值域为 $[n,2m+n]$。
  + 设节点访问点数大于 $t$ 的为黑点，反之为白点。
  + 黑点至多有 $\dfrac{2m+n}{t}$ 个。假设这个为 $s$ 好了。
  + 我们要考虑时间复杂度不能栽在一个节点的度数上。
+ 于是做完分类之后，考虑分类讨论。
  + $u$ 是黑点
    + 初始答案为 $u$ 的度数。
    + $v$ 是白点
      + 暴力遍历 $v$ 的所有可访问点 $w$，判断有没有 $(u,w)$ 的边。
      + 如果有就给其答案减一。
      + 时间复杂度 $O(t)$。
    + $v$ 是黑点
      + 类似于第二个暴力，考虑直接 `bitset` 操作。
      + 时间复杂度 $O(\dfrac{n}{w})$。
  + $u$ 是白点
    + 初始答案为 $u$ 的度数。
    + $v$ 是白点
      + 暴力遍历 $u$ 的所有可访问点 $w$，判断有没有 $(w,v)$ 的边。
      + 时间复杂度 $O(t\log m)$。
    + $v$ 是黑点（我知道可以用上面那个暴力）
      + 暴力遍历 $u$ 的可能可访问点 $w$，判断边。
      + 时间复杂度 $O(t)$。
+ 最后算一下总体时间复杂度，最坏也不过 $O(nq/w)$，大概能过。
+ 取 $t$ 等于多少呢？
+ 继续基本不等式，$t\log m+\dfrac{n}{w}\ge 2\sqrt{\dfrac{nt\log m}{w}}$。当 $t=\dfrac{n}{w\log m}$ 的时候，时间复杂度是 $O(n/w)$ 级别的。
+ 空间复杂度为 $O((2m+n)\log m)$，所以我们完美解决了空间的瓶颈。

于是 乱搞 + 卡常 就过了……卡常卡了很久

```cpp
const I N=2e5+10;
I n,m,q,t;
I e[700010][2],d[N];
set<pair<I,I> >mp;
vector<I>ed[N];
const I ZLS=5120;
bitset<N>g[ZLS];
I of[N],zl;
I main(){
	in(n,m,q);
	t=sqrt((2.0*m+n)/log2(m)/64.0);
	fo(i,1,m){I&x=e[i][0],&y=e[i][1];
		in(x,y);
		mp.insert(make_pair(x,y));
		mp.insert(make_pair(y,x));
		++d[x];++d[y];}
	fo(i,1,n)ed[i].reserve(d[i]);
	fo(i,1,m){I&x=e[i][0],&y=e[i][1];
		ed[x].push_back(y);ed[y].push_back(x);}
	fo(i,1,n)if(d[i]>=t){
		of[i]=++zl;
		assert(zl<ZLS);
		for(I y:ed[i])g[zl].set(y);}
	fo(i,1,q){I u,v,ans(0);
		in(u,v);if(u==v){puts("0");continue;}
		if(of[u]){
			if(of[v])ans=(g[of[u]]^(g[of[u]]&g[of[v]])).count();
			else {ans=ed[u].size(); 
				for(I y:ed[v])if(g[of[u]].test(y))--ans;}
			if(g[of[u]].test(v))--ans;
			}
		else{ans=ed[u].size();
			if(of[v]){
				for(I y:ed[u])if(g[of[v]].test(y))--ans;
				if(g[of[v]].test(u))--ans;}
			else{if(mp.count(make_pair(u,v)))--ans;
				for(I y:ed[u])if(mp.count(make_pair(y,v)))--ans;}}
		printf("%d\n",ans);}
	return 0;}
```



---

## 作者：wujingfey (赞：1)

# P8250 交友问题

思路就是根号分治。本篇题解重点讲**我在哪里被坑惨了**。

## 思路

具体而言按照度数分类，度数低的叫“轻点”，度数高的叫“重点”。然后根据 $u,v$ 不同种类分讨即可。

对于每个重点，我们开一个 bitset 存储相邻节点。

对于每个轻点，用 map 存储邻边信息。

1. 重点和重点。考虑用 bitset 进行暴力优化。也就是```bitset<N> b=b[u]^(b_u&b_v)```。翻译一下就是**找到 $u$ 所有邻边中不是 $u,v$ 共有的点**。然后统计个数
2. 重点和轻点。在 $u$ 的所有儿子中，利用 $v$ 的 mp 排除不合法的点。
3. 轻点和重点。枚举 $u$ 的所有邻点，挨个确认是否合法。
4. 轻点和轻点。枚举 $u$ 的所有邻点，挨个确认是否合法。

## 坑点

1. 关于轻重点阈值 $lim$。可以排序后取较大的前几个作为重点。我是用如下代码操作的：
```
sort(deg+1,deg+1+n,cmp);
lim=deg[min(n,(int)(sqrt(n)*10))];
```
这就一定要注意不要越过 $deg$ 上界了。

2. 关于空间。因为总度数是 $m$ 级别的，如果只有 $lim$ 以上的点才是重点，则重点个数是 $\frac{m}{lim}$ 级别的。可以保证空间不爆炸。
3. 关于重点对重点的情况。**使用```b.count```（bitset 自带的统计 $1$ 个数函数）**。因为如果你一个一个加，它没有 $w$ 的常数，是 $O(nq)$ 的！！
4. 关于轻点对轻点的情况。注意**检验一个相邻点是否合法，只能从 $v$ 出发看 map 中是否存在**。因为只有轻点才会计入 map 中。

## CODE
```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,q,lim;
vector<int> e[N];
vector<int> h;
vector<bitset<N> > a;
unordered_map<int,int> mp[N];
int deg[N],key[N],id[N];//id记录重点在a中编号
bool cmp(int a1,int a2){
	return a1>a2;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
		deg[x]++, deg[y]++;
	}
	sort(deg+1,deg+1+n,cmp);
	lim=deg[min(n,(int)(sqrt(n)*10))];
	memset(id,-1,sizeof id);
	for(int i=1;i<=n;i++){
		if(e[i].size()>lim){
			h.push_back(i);
			id[i]=h.size()-1; 
			bitset<N> newb;
			newb&=0;
			for(auto v:e[i]) newb[v]=1;
			a.push_back(newb);
		}else{
			for(auto v:e[i]){
				mp[i][v]=1;
			}
		}
	}
	while(q--){
		int u,v,ans=0;
		cin>>u>>v;
		if(id[u]>=0 && id[v]>=0){
			bitset<N> b1=a[id[u]],b2=a[id[v]];
			bitset<N> b=b1^(b1&b2);
			b[u]=0, b[v]=0;
			cout<<b.count();//遍历bitset答案累加的时候，复杂度是n^2而不是n^2/64 
		}else if(id[u]>=0 && id[v]==-1){
			for(auto to:e[v]){
				if(a[id[u]][to] || to==u || to==v) ans++;
			}
			cout<<a[id[u]].count()-ans;
		}else if(id[u]==-1 && id[v]>=0){
			for(auto to:e[u]){
				if(!a[id[v]][to] && to!=u && to!=v) ans++;
			}
			cout<<ans;
		}else{
			for(auto to:e[u]){
				if(!mp[v][to] && to!=u && to!=v) ans++;
				//注意一定是 mp[v][to]因为只有轻点才存入mp了 
			}                                       
			cout<<ans;                 
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8250)。

## 思路

对于询问的两个点 $u,v$，实际上求的就是 $|\{x\mid (u,x)\in E\} \setminus \{ \{ x\mid (u,x)\in E\} \cap \{x\mid (v,x)\in E \lor x=v\} \} |$ 

我们可以用 bitset 记录与点 $x$ 直接相连的点集，查询时直接做一个交即可，时间复杂度 $O\left( nm \right)$。

很容易想到根号分治优化该过程，对于一个度数小于 $B$ 的点，我们直接暴力扫一遍它的出点，否则，对于一个度数大于 $B$ 的点，这种点的数量最多不超过 $\dfrac{n}{B}$，预处理出与这些点直接相连的点集，时间复杂度 $O\left( qB+ \dfrac{n^3}{B^2w} +\dfrac{qn}{w} \right)$，$B$ 取 $n^{2/3}/3$ 最优，时间复杂度 $O\left(\dfrac{qn}{w}\right)$，常数较小。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=2e5+7,B2=3500,B1=60;
int n,m,Q,deg[Maxn],B,cnt,lmx[Maxn];
vector<int>e[Maxn];

bitset<Maxn>w[B2];

inline void doit(bitset<Maxn>&x,int y){
	for(auto j:e[y]) x.set(j,1);
}

int main(){
	scanf("%d%d%d",&n,&m,&Q);
	B=pow(n,2./3)/3+1;
	
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		e[u].emplace_back(v);
		e[v].emplace_back(u);
		deg[u]++,deg[v]++;
	}
	
	for(int i=1;i<=n;i++){
		if(deg[i]>B){
			lmx[i]=++cnt;
			doit(w[cnt],i);
		}
	}
	
	while(Q--){
		int u,v;
		scanf("%d%d",&u,&v);
		bitset<Maxn>w1,w2;
		if(deg[u]<=B) doit(w1,u);else w1=w[lmx[u]];
		if(deg[v]<=B) doit(w2,v);else w2=w[lmx[v]];
		w2.set(v,1);w1=w1^(w1&w2);printf("%d\n",w1.count());
	}	
	return 0;
}



```


---

## 作者：lizicheng3042 (赞：0)

## 思路  
对于这道题，我们考虑可以转化成是求某两个点都能直接到达的点的个数。我们优先把所有双向边拆开，然后把从每个点出发的边按到达点编号从小到大排到一起。此时，由于两边的到达点编号单调递减，我们可以用双指针来判断 $i$，$j$ 两点能到达的共同点，时间复杂度是 $O(sz_i+sz_j)$。（$sz$ 表示边集的大小）  
因为此时点编号有单调性了，我们很容易想到两个指针可以一个正常一个一个跳，一个则可以倍增地跳，于是一次查询复杂度上界变为 $O(\sqrt n\log \sqrt n)$，当且仅当查询时有一个点的边集大小接近 $n$，且另一个点的边集大小在 $\sqrt n$ 附近，如果数据随机的话复杂度应均摊为 $O(\sqrt n)$。  
但是显然，如果一直选两个边集很大的点询问，这样的复杂度会爆掉，所以我们考虑预处理所有边集较大的点，设大于 $\sqrt n$，提前预处理他们两两之间的询问，因为每个点至多跑 $\frac{m}{\sqrt n}$ 次询问，复杂度至多为 $O(m\sqrt n)$的。  
然后对于其他的情况，我们注意到只需要点集小的一步一步跳，点集大的倍增跳，复杂度显然是正确的。  
于是这道题就完成了，时间复杂度 $O(q\sqrt n+m\sqrt n)$，空间复杂度 $O(m)$，基本卡不掉，跑得非常快。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,tot,q,f,t,st[200005],ed[200005],cnt,big[200005],rf[200005],ans[1005][1005],fri[200005];
const int B=2000;
struct edge
{
	int from,to;
	bool operator <(const edge &a){if(from==a.from)return to<a.to;return from<a.from;}
}i[2000005];
void add(int x,int y)
{
	i[++tot].to=y;i[tot].from=x;
	i[++tot].to=x;i[tot].from=y;	
}
int find(int x,int y)
{
	int step=1,now=st[y],o=0;
	step=1;
	while(i[now].to<x&&now<=ed[y])
	{
		if(!step)
			break;
//		while(i[now+step].to<=x&&now+step>ed[y])step<<=1;
		now+=step;
		step<<=1;
	}
	if(x==i[now].to)
		o++;	
	step=1,now=st[y];
	for(int a=st[x];a<=ed[x];a++)
	{
		int u=i[a].to;
		step=1;
		while(i[now].to<i[a].to&&now<=ed[y])
		{
			while(i[now+step].to>u||now+step>ed[y])step>>=1;
			if(!step)
				break;
			now+=step;
			step<<=1;
		}
		if(u==i[now].to)
			o++;
	}
	return o;
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int a=1;a<=m;a++)
	{
		scanf("%d%d",&f,&t);
		fri[f]++,fri[t]++;
		add(f,t);
	}
	sort(i+1,i+m*2+1);
	int yu=0;
	for(int a=1;a<=m*2;a++)
	{
		int y=i[a].from;
		while(yu<y)
		{
			ed[yu]=a-1;
			st[++yu]=a;
		}
	}
	ed[i[m*2].from]=m*2;
	yu++;
	for(yu;yu<=n;yu++)
	{
		st[yu]=m*2+1;
		ed[yu]=m*2;
	}
	for(int a=1;a<=n;a++)
	{
		if(fri[a]>=B)
		{
			big[++cnt]=a;
			rf[a]=cnt;
		}
	}
	for(int a=1;a<cnt;a++)
	{
		for(int b=a+1;b<=cnt;b++)
		{
			int u=big[a],v=big[b],z=0;
			if(fri[u]>fri[v])
				z=find(v,u);
			else
				z=find(u,v);
			ans[a][b]=fri[u]-z;
			ans[b][a]=fri[v]-z;
		}
	}
	for(int a=1;a<=n;a++)
		if(fri[a]<ed[a]-st[a]+1)
			printf("&");
	for(int a=1;a<=q;a++)
	{
		scanf("%d%d",&f,&t);
		if(rf[f]&&rf[t])
		{
			printf("%d\n",ans[rf[f]][rf[t]]);
		}
		else
		{
			int u=0;
			if(fri[f]>fri[t])
				u=find(t,f);
			else
				u=find(f,t);
			printf("%d\n",fri[f]-u);
		}
	}
	return 0;
}
```

---

## 作者：ttq012 (赞：0)

考虑根号算法。

设当前考虑的节点 $u$ 的度数 $\deg(u)\le \sqrt n$，则考虑对字符串离散化之后直接暴力存储计算答案。

若 $\deg(u)>\sqrt n$，则对于这些节点中每一个节点都开一个 `bitset` 记录其邻接节点，然后套路的，设 $T_i$ 表示 $i$ 的所有邻接节点的编号，则满足条件的点集为 $T_u\oplus (T_u\operatorname{xor}T_v)$。

因为 $\deg>\sqrt n$ 的节点数量不超过 $\sqrt n$ 个，所以这样既不会超时也不会超空间，十分完美。

---


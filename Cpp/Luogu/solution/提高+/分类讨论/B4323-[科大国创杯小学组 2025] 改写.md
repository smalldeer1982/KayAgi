# [科大国创杯小学组 2025] 改写

## 题目背景

Subtask 0 为民间数据（最后两组测试点为民间 hack 数据），Subtask 1 为官方数据。

## 题目描述

小可可在学习字符串算法！

一个长度为 $m$ 的字符串 $r$ 是回文的，当且仅当 $r_i = r_{m+1-i}$ 对所有 $1 \leq i \leq m$ 均成立。例如 $\tt{aaabaaa}$，$\tt{abba}$ 都是回文串，但 $\tt{aaabaa}$ 不是回文串。

给定一个字符串 $s$，把 $s$ 分成若干个非空子段，使得每一个子段都不是回文的，同时最大化划分出的子段数目，请你输出最大划分数，无解则输出 $-1$。

子段的定义为：一个字符串保留任意连续字符后形成的字符串。

由于字符串 $s$ 可能很长，我们将会按照 $c, len$ 的形式给出整个字符串，具体含义见输入格式。

## 说明/提示

### 样例解释

- 对于第一组数据，序列为 $\tt{ba}$，且只存在 $\tt{ba}$ 这一种划分方案，因此答案为 $1$。
- 对于第二组数据，序列为 $\tt{bbbb}$，显然没有合法方案。
- 对于第三组数据，序列为 $\tt{aabbabbaba}$，存在一种划分出四段的方案: $\tt{aabb}$，$\tt{ab}$，$\tt{ba}$，$\tt{ba}$，可以证明没有答案更优的划分方式。
- 对于第四组数据，序列为 $\tt{aabaaccaa}$，存在一种划分出三段的方案: $\tt{aaba}$，$\tt{ac}$，$\tt{caa}$，可以证明没有答案更优的划分方式。
- 对于第五组数据，序列为 $\tt{aba}$，容易发现无论怎么划分，都至少有一个回文串，所以无解。

### 约定和数据范围

- 数据点 $1$，$T = 10$，$1 \leq n \leq 3$，$1 \leq len_i \leq 2$。
- 数据点 $2$，$T = 10$，$1 \leq n \leq 3$，$1 \leq len_i \leq 10^9$。
- 数据点 $3, 4$，$T = 10$，$1 \leq n \leq 150$，$1 \leq len_i \leq 2$。
- 数据点 $5, 6$，$T = 10$，$1 \leq n \leq 150$，$1 \leq len_i \leq 10^9$。
- 数据点 $7 \sim 9$，$T = 10$，$1 \leq n \leq 2.5 \times 10^3$，$1 \leq len_i \leq 2$。
- 数据点 $10 \sim 12$，$T = 10$，$1 \leq n \leq 2.5 \times 10^3$，$1 \leq len_i \leq 10^9$。
- 数据点 $13 \sim 16$，$T = 10, 1 \leq n \leq 10^5, 1 \leq len_i \leq 2$。
- 数据点 $17 \sim 20$，$T = 10, 1 \leq n \leq 10^5, 1 \leq len_i \leq 10^9$。

## 样例 #1

### 输入

```
5
2
b 1
a 1
1
b 4
7
a 2
b 2
a 1
b 2
a 1
b 1
a 1
5
a 2
b 1
a 2
c 2
a 2
3
a 1
b 1
a 1```

### 输出

```
1
-1
4
3
-1```

# 题解

## 作者：JHPOTATO (赞：10)

**不难发现一个性质：任意两个不同颜色的段，无论长度是多少，拼起来一定是一个非回文串。**

那么长度不小于 $2$ 的段一定能分成两部分，而长度为 $1$ 的段只能作为一部分。

那么就可以考虑把长度大于 $2$ 的连续段的段长全部设置为 $2$，剩下长度只有 $1,2$ 的序列（因为同色段是回文的，长度 $\ge 2$ 的连续段能且仅能划分为 $2$ 段）。

**这样我们就把整个串压缩到了 $\mathcal{O}(n)$ 的长度了。**

贪心地想，如果想让划分数尽可能多，每次只应取两段，也就是说，序列中只有相邻项能划分。

对于一个长度全为 $1$ 的子串，其内部的点肯定只能两两匹配，最后剩下 $1$ 段或 $2$ 段。

对于一个长度全为 $2$ 的子串，如果段数等于 $1$，那么肯定没法操作，但段数大于 $1$ 时，每相邻两段之间一定能完成匹配，并且最终两端还能决定留不留下一部分与邻段匹配。

可以发现，上面两种处理产生的匹配数一定最优，并且不会对其余部分产生影响。

这启示我们对连续段进行压缩，最后只剩下四种类型的段：

`a`，`ab`，`aa`，`aabb`。

分别称它们为 $A,B,C,D$，其中 $A,B$ 和 $C,D$ 必然交替出现。

$A$ 必须恰好在一个方向产生匹配；$B$ 要么向两个方向同时产生匹配，要么都不匹配；$C$ 在至少一个方向产生匹配； $D$ 可以任意产生匹配。

其实还可以继续简化，令 $B$ 和周围的两个 $C,D$ 产生匹配一定是最优的，因为 $D$ 严格优于 $C$，而令 $B$ 和周围的 $C,D$ 匹配，相当于把这三项合并，进行两次匹配，并产生一个新的 $D$。

如果 $B$ 周围没有段，那么就只有这一段，内部匹配掉即可。

如果 $B$ 在开头或结尾的话，内部匹配一定是最优的，因为即使匹配了一侧，另一端多出的那部分无法匹配，就只能考虑合并，但合并有可能失败，一定不会更优，特别地，删去开头或结尾处的 $B$ 也可以把相邻的 $C$ 设置为 $D$，理由会在后文中解释。

除去所有 $B$ 后，序列中就只剩下 $A,C,D$ 了，并且 $A$ 和 $C,D$ 是交替出现的。

此时想要产生最多的匹配数，一定是尽量多地匹配 $A$，又由于 $C,D$ 的匹配位置是任意的，所以一定能完全匹配 $A$。

但是还有一种 $CACAC\dots AC$ 的情况，这时会有一个 $C$ 失配。

如果我们先前在首尾删去了 $B$，那么我们可以顺带删去一个 $C$，等价于将 $C$ 设置为 $D$。

如果存在一个 $A$ 是由长度大于 $1$ 的全 $1$ 段删除得到的，那么就可以用一端的匹配处理掉一个 $C$。因为 $11X$ 和 $X11$ 一定是非回文串（$X$ 是一个长度不为 $1$ 的段）。

反之，我们就要考虑把其中一个 $C$ 拆成两份，一种拆分方式不合法当且仅当至少有一边产生了回文串，但是即使在 $C$ 的长度最小，也就是 $2$ 的时候，也存在 $(0,2),(1,1),(2,0)$ 三种拆分方式，所以至少有一种合法的拆分方式。

那么只有在 $C1C$ 或 $C$ 或 $A$ 的时候，我们不能用上述方式拆分，进行讨论。

$C$ 显然无解。

$C1C$ 只要判断两端的字符串是不是完全相同即可，相同就无解，否则答案为 $1$。

$A$ 可能稍微困难一些，此时原串的长度和段数均 $L$ （$L$ 为奇数）。采用类似的思路，我们考虑合并掉其中三个段，那么段的位置可能为“奇-偶-奇”或者
“偶-奇-偶”。

如果我们删除的段落为“奇-偶-奇”，则剩下的段落长度均为偶数，可以自行匹配。

如果删除的段落为“偶-奇-偶”，左右都会剩下长为奇的段落，这是性质相同的子问题，如果想要完全划分，要么分出一段“奇-偶-奇”，要么在段中抽出一个合并，前者一定更劣，后者如果只合并一端，则不如把其划分为两个长为 $2$ 的段落，如果合并两端，实质是一个以奇位置开始的划分。

综上，我们一定只会删除位置为“奇-偶-奇”的段落。

完成“奇-偶-奇”的划分，只需相邻两个奇位置字符的不同，此时答案为 $\frac{len-1}{2}$。

如果所有奇位置都相同，那就不存在合适的长度为 $3$ 的划分了，接着考虑有没有长度为 $5$ 的划分，同理，我们一定选择位置为“奇-偶-奇-偶-奇”的段落。

由于奇位置完全相同，所以必须得有相邻且不同的偶位置才可以找到合法划分，如果找到，把这段划分出即可，此时答案为 $\frac{len-3}{2}$。

如果长度为 $5$ 的也找不到呢？继续枚举 $7,9\dots$ 的段长？**并不需要，因为此时我们一定无法找到长度为奇数的非回文串了**，这时直接返回无解即可。

至此，所有情况都讨论完了，可以发现，把无解和答案为 $\frac{len-3}{2}$ 的特殊情况判完后，原串能划分出的最大互不相交的非回文串数就是最后的答案。

然后就可以用贪心求解，由上述推导可知，我们此时一定能构造出一组与贪心所得答案相同的合法方案，且显然不存在更优的方案。

---

## 作者：XZhuRen (赞：5)

[@JHPOTATO](https://www.luogu.com.cn/user/559946) 大神出的题目，快去膜拜她 qwq。

考虑~~乱搞~~。

发现同段一定是回文取不到，两段接一起必然不回文可以取，把段长缩小到 $\min(len,2)$。

长度由 $\mathcal{O}(\sum len)$ 压缩到了 $\mathcal{O}(m)$。

直接写出串，感性理解，回文长度一定不超过 $5$，DP 一个最大值 $f_i$ 表示压缩后的串前 $i$ 个字符的答案，暴力往前做 $4$ 次转移即可。

官方题解划分等价类严谨证明，下面感性证一下：

已经将长度缩到了 $2$ 以内，连续两段长度和不超过 $4$，转移最优下不会多取。

注意到 $m=3$ 的情况可能需要特判第一段长度等于第二段，这个取决于实现。

代码：

```cpp
int n,m;
int a[400005];
int dp[400005];

bool checkpl(int l,int r) {
    for(int i=l;i<r+l-i;++i) {
        if(a[i]!=a[r+l-i]) return false;
    }
    return true;
}

void wk() {
    read(m);n=0;
    if(m==3){
        char x[4];
        int y[4];
        for(int i=1;i<=m;i++){
            cin>>x[i]>>y[i];
        }
        if(x[1]==x[3]&&y[1]==y[3]&&y[2]==1)printf("-1\n");
        else if(y[2]==1)printf("1\n");
        else printf("2\n");
        return;
    }
    char x;int y;
    for(int i=1;i<=m;++i) {
        cin>>x>>y;
        (x-='a')+=1;
        y=min(y,2);
        while(y--) a[++n]=x;
    }
    for(int i=1;i<=n;++i) dp[i]=-1e9;
    for(int i=1;i<=n;++i) {
        for(int j=i;i-j<=4 && j>=1;--j) {
            if(!checkpl(j,i)) dp[i]=max(dp[i],dp[j-1]+1);
        }
    }
    if(!checkpl(1,n)) dp[n]=max(dp[n],1);
    writeln(dp[n]<0?-1:dp[n]);
}
```

---

## 作者：xlhl (赞：0)

## 题目大意
给一个由 $n$ 个极长连续字母段组成的字符串，把它划分成每部分都非回文的非空子段，使划分段数最大，无解输出 $-1$，多组测试数据。
## 解法一
发现长度超过 $2$ 的极长连续字母段，和长度为 $2$ 的作用是一样的，因为肯定不会在一个字母段内部再次划分，只能划分到两边的字母段。这时可以把长度超过 $2$ 的字母段当成长度为 $2$ 的字母段。

考虑贪心，先观察特殊情况：

1. 全都是长度为 $2$ 或被当成长度为 $2$ 的字母段：  
在每个字母段（第一个除外）第一个字符后面切分，可以划出 $n-1$ 个非回文段。
2. 全都是长度为 $1$ 的字母段：  
   如果 $n$ 是偶数，可以两两划分成非回文段。如果 $n$ 为奇数呢？   
   有解的情况中，一定可以找到段数为 $3$ 的非回文串，这个非回文串会将字符串划分成两部分：长度都为偶数或长度都为奇数。  
   长度都为奇数的可以尝试把这个非回文串往两边拓展，这样两段长度就都为偶数了。如果找不到，就无解了。

那字母段长度又有 $1$ 又有 $2$ 的怎么做？其实和特殊情况差不多，只需要额外考虑 $1$ 和 $2$ 衔接情况。
## 解法二
感觉贪心代码有点难写，我们发现，问题具有阶段性，符合最优子结构，尝试动态规划。    
设 $f_{i}$ 表示前 $i$ 个字母段的最大划分数，但这样转移会不会超时？其实还是可以把字母段压缩成长度只有 $1$ 和 $2$，而且根据上面的分析，实际上转移只用考虑前 $5$ 段，每次判断是否回文即可。
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int T,n,len[N],a[N],f[N],ans;
char c[N],s[N];
bool check(int x,int y){
	for(int i=x;i<=y;i++)
	  if(c[i]!=c[y-i+x]||a[i]!=a[y-i+x]) return 0;
	return 1; 
}
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>c[i]>>len[i],a[i]=len[i],len[i]=min(len[i],2);
		for(int i=1;i<=n;i++) f[i]=-1e9;
		for(int i=1;i<=n;i++){
			for(int j=2;j<=5;j++)
			  if(i-j>=0&&!check(i-j+1,i)) f[i]=max(f[i],f[i-j]+1);//如果不是回文，可以从f[i-j]转移而来
			if(len[i-1]>1) f[i]=max(f[i],f[i-1]+1);//也可能从i-1段切半截合起来
		}
		if(f[n]<0) cout<<-1<<endl;
		else cout<<f[n]<<endl;
	}
	return 0;
}
```

---


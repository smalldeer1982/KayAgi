# 七夕祭

## 题目描述

七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。

于是 TYVJ 今年举办了一次线下七夕祭。

Vani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。

TYVJ 七夕祭和 11 区的夏祭的形式很像。

矩形的祭典会场由 $N$ 排 $M$ 列共计 $N \times M$ 个摊点组成。

虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。

Vani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。

不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。

两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。

由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。

现在 Vani 想知道他的两个要求最多能满足多少个。

在此前提下，至少需要交换多少次摊点。

## 说明/提示

对于 $30\%$ 的数据，$N,M \le 100$。

对于 $70\%$ 的数据，$N,M \le 1000$。

对于 $100\%$ 的数据，$1 \le N,M \le 100000$，$0 \le T \le \min(N\times M,100000)$，$1 \le x \le N$，$1 \le y \le M$。

## 样例 #1

### 输入

```
2 3 4
1 3
2 1
2 2
2 3```

### 输出

```
row 1```

## 样例 #2

### 输入

```
3 3 3
1 3
2 2
2 3```

### 输出

```
both 2```

# 题解

## 作者：一只小咕咕 (赞：11)

[也许更好的阅读体验](https://www.cnblogs.com/yzxgg/p/18204641/solution-P10453)

[题目传送门](https://www.luogu.com.cn/problem/P10453)

最近在板刷蓝书，所以来写个题解加深自己的印象。

首先发现行和列互不影响，所以可以分开看。所以就是对行和列都做一次环形均分纸牌问题，也就是这个题[糖果传递](https://www.luogu.com.cn/problem/P2512)。

### 先来看一下普通的均分纸牌

普通的均分纸牌就是 $n$ 个小朋友排成一列，各有 $a_i$ 张牌，每个人只能给相邻的人传递纸牌，问至少需要传递多少张纸牌才能使每个小朋友纸牌的数量相等。

最后每个人手里的牌一定是牌总数的平均值，即 $ave=\frac{sum}{n}(sum=\sum {a_i})$，设 $g_i=a_i-ave$，答案就是 $\sum |s_i|$，其中 $s_i=\sum\limits_{j=1}^i g_j$，即 $g$ 的前缀和。

可以这么理解，$g$ 表示的是到最终目标牌数差的数量，目标是将 $g$ 都变为 $0$，那么对 $g$ 取前缀和表示的就是把前面的牌都转移到自己，所以 $s_i$ 就是 $i$ 转移出去的代价。

### 再来看一下环形均分纸牌

环形的问题就是小朋友坐成了一圈，等同于最后一个人与第一个人相邻。

思考后可以发现环形均分纸牌的一个性质：必定至少有两个相邻的人不需要从对方那里获得纸牌（这是显然的，不妨设这两个人的位置为 $i$ 和 $i+1$，$T$ 代表均分纸牌的目标个数，则环形序列中必定有满足 $a_i\le T,a_{i+1}\ge T$ 的两个相邻位置，这样 $i$ 和 $i+1$ 就不会交换，因为 $a_i\le T$ 的会从 $i-1$ 处得到纸牌，$a_{i+1}\ge T$ 可以把牌传递给 $i+2$）。

所以我们可以根据上面的性质，把环变成链，枚举不需要交换的两个人。

按开始的序列顺序，像普通均分纸牌一样处理出$g$ 的前缀和 $s$ 数组，那么假设枚举的位置为 $k$，则类比普通均分纸牌求法，新的 $s_i=s_i-s_k$，于是 $ans=\sum{|s_i-s_k|}$，发现 $s_k$ 为 $s$ 的中位数时 $ans$ 最小，于是该问题就得到了解决。

### 回到这个题

应该先判断有没有解，即行和列的 $sum$ 是否可以分别被行数 $n$ 和列数 $m$ 整除。然后对行和列做两次环形均分纸牌即可。

细节可以参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
inline int read();
int n,m,t,row[N],col[N];
long long srow[N],scol[N],rowsum,colsum,rowans,colans;
int main()
{
	n=read();m=read();t=read();
	for(int i=1;i<=t;i++)
	{
		int x,y;
		x=read();y=read();
		row[x]++,col[y]++;
		rowsum++,colsum++;
	}
	if(rowsum%n!=0&&colsum%m!=0) return puts("impossible"),0;
	if(rowsum%n==0)
	{
		int rowave=rowsum/n;
		for(int i=1;i<=n;i++)
		{
			row[i]-=rowave;
			srow[i]=srow[i-1]+row[i];
		}
		sort(srow+1,srow+1+n);
		int k=(n+1)/2;
		for(int i=1;i<=n;i++)
		{
			rowans+=abs(srow[i]-srow[k]);
		}
	}
	if(colsum%m==0)
	{
		int colave=colsum/m;
		for(int i=1;i<=m;i++)
		{
			col[i]-=colave;
			scol[i]=scol[i-1]+col[i];
		}
		sort(scol+1,scol+1+m);
		int k=(m+1)/2;
		for(int i=1;i<=m;i++)
		{
			colans+=abs(scol[i]-scol[k]);
		}
	}
	if(colsum%m!=0) printf("row %lld",rowans);
	else if(rowsum%n!=0) printf("column %lld",colans);
	else printf("both %lld",rowans+colans);
	return 0;
}

inline int read()
{
	int x=0,f=1;
	char ch;
	ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-') f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')
	{
		x=(x<<1)+(x<<3)+(ch&15);
		ch=getchar();
	}
    return x*f;
}
```

UPD on 2024.10.13

---

## 作者：ineverleft (赞：7)

### 七夕祭

[题目](https://www.luogu.com.cn/problem/P10453)

题目要求是否可以进行相邻两项的交换，使得每行或每列的摊点个数相等。由于行列的交换互不干扰，因此相当于两次糖果传递问题。

### 糖果传递

[题目](https://www.luogu.com.cn/problem/P2512)

设第 $i$ 个人向第 $i+1$ 个人传递的 $p_{i}$ 个糖果（若 $p_{i}<0$,，表示第 $i+1$ 个人向第 $i$ 个人传递），特别的，$p_{n}$ 表示第 $n$ 个人向第 $1$ 个人传递。设最终每个人的糖果数为 $avg$，则可以列出方程组：

$$
\left\{\begin{matrix} 
 a_{1}+p_{n}-p_{1}=avg \\ 
 a_{2}+p_{1}-p_{2}=avg \\
 \cdots \\
 a_{n}+p_{n-1}-p_{n}=avg
\end{matrix}\right.
$$

将 $p_{i}$ 用 $p_{1}$ 表示：

$$
\left\{\begin{matrix} 
 p_{2}=p_{1}+(a_{2}-avg) \\
 p_{3}=p_{2}+(a_{3}-avg)=p_{1}+(a_{2}-avg)+(a_{3}-avg)\\
 \cdots \\
 p_{k}=p_{1}+\sum_{i=2}^k(a_{i}-avg) \\
 \cdots \\
 p_{n}=p_{1}+\sum_{i=2}^n(a_{i}-avg)
\end{matrix}\right.
$$

记 $b_{i}=a_{i}-avg$，则 $p_{k}=p_{1}+\sum_{i=2}^k b_{i}$。

记 $c_{i}=\sum_{i=2}^k b_{i}$，则答案为 $ans=|p_{1}|+\sum_{i=2}^n|p_{1}+c_{i}|$，令 $c_{1}=0$，则 $ans=\sum_{i=1}^n|p_{1}+c_{i}|$。

进行进一步转换：

$$
ans=\sum_{i=1}^n|p_{1}+c_{i}|=\sum_{i=1}^n |c_{i}-(-p_{1})|
$$

考虑其几何意义，则答案就相当于在数轴上找到一个点，使得这个点到 $c_{1\sim n}$ 的距离和最小。求出 $c_{i}$ 之后，就转化为了货仓选址问题。

### 货仓选址

[题目](https://www.luogu.com.cn/problem/P10452)

本题要求一个点使得这个点到所有点的距离之和最小。

先考虑两个点的情况，这时不难发现选在两点之间的任意一点都可以保证距离最小。

推广到 $n$ 个点的情况，则可以发现选在中间时最小。具体地，当 $n$ 为奇数时，选择其中位数，当 $n$ 为偶数时，选择中间两个点之间的任意一点。（若不选择中间，则选择的点两边的点数一定不同，以左侧点数少于右侧的情况为例，当选择的点向右侧移动时，其左侧的点到其的距离都会加一，而右侧的点到它的距离会减一，而右侧的点数大于左侧的点数，因此总距离减小，证明此时不是最优解。

因此，选择中位数（$n$ 为奇数）或中间两个数之间的任意数（$n$ 为偶数）即为最优解。

[货仓选址](https://www.luogu.com.cn/problem/P10452)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+5;

int n;
int a[N];

int ans;

int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    sort(a+1,a+n+1);
    int x=a[(n+1)/2];
    for(int i=1;i<=n;i++){
        ans+=abs(a[i]-x);
    }
    cout << ans;
    return 0;
}
```

[糖果传递](https://www.luogu.com.cn/problem/P2512)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+5;

typedef long long ll;

int n;
int a[N],b[N],c[N];
ll sum,avg,ans;

int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
        sum+=a[i];
    }
    avg=sum/n;
    for(int i=1;i<=n;i++){
        b[i]=a[i]-avg;
    }
    for(int i=2;i<=n;i++){
        c[i]=c[i-1]+b[i];
    }
    sort(c+1,c+n+1);
    int x=c[(n+1)/2];
    for(int i=1;i<=n;i++){
        ans+=abs(c[i]-x);
    }
    cout << ans;
    return 0;
}
```

[七夕祭](https://www.luogu.com.cn/problem/P2512)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+5;

typedef long long ll;


ll solve(int n,int a[]){
    int b[N],c[N];
    ll sum=0,avg,ans=0;
    for(int i=1;i<=n;i++){
        sum+=a[i];
    }
    if(sum%n)return -1;
    avg=sum/n;
    for(int i=1;i<=n;i++){
        b[i]=a[i]-avg;
    }
    c[1]=0;
    for(int i=2;i<=n;i++){
        c[i]=c[i-1]+b[i];
    }
    sort(c+1,c+n+1);
    int x=c[(n+1)/2];
    for(int i=1;i<=n;i++){
        ans+=abs(c[i]-x);
    }
    return ans;
}

int n,m,t;
int row[N],col[N];
int main(){
    cin >> n >> m >> t;
    for(int i=1;i<=t;i++){
        int x,y;
        cin >> x >> y;
        row[x]++,col[y]++;
    }
    
    ll ansr=solve(n,row);
    ll ansc=solve(m,col);
    if(ansr!=-1&&ansc!=-1){
        cout << "both " << ansr+ansc;
    }
    else if(ansr!=-1){
        cout << "row " << ansr;
    }
    else if(ansc!=-1){
        cout << "column " << ansc;
    }
    else{
        cout << "impossible";
    }
    return 0;
}
```

---

## 作者：fish_love_cat (赞：5)

前情提要：[**《十 一 倍 经 验》**](https://www.luogu.com.cn/discuss/639580)

---

题目让我们通过交换实现每行的和相同，每列的和相同。

首先可以发现，行列交换相互独立，那么我们先处理列后处理行不会对答案产生影响。

我们可以记录下每行的和及每列的和，然后我们分别对行和列跑一遍负载平衡问题即可。

注意不整除的情况下找不出平均数，无解，需要特判。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[100005],b[100005],c[100005],pjs,ans;
signed main(){
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1,x;i<=k;i++)cin>>x,a[x]++,cin>>x,b[x]++;
    if(k%n==0){
        pjs=k/n;
        for(int i=1;i<=n;i++)c[i]=c[i-1]-pjs+a[i];
        sort(c+1,c+1+n);
        for(int i=1;i<=n;i++)ans+=abs(c[n/2+1]-c[i]);
    }
    if(k%m==0){
        pjs=k/m;
        for(int i=1;i<=m;i++)c[i]=c[i-1]-pjs+b[i];
        sort(c+1,c+1+m);
        for(int i=1;i<=m;i++)ans+=abs(c[m/2+1]-c[i]);
    }
    if(k%n&&k%m)puts("impossible");
    else{
        if(k%n)printf("column ");
        else if(k%m)printf("row ");
        else printf("both ");
        cout<<ans;
    }
    return 0;
}
```

---

## 作者：_Supernova (赞：2)

### 一、发现性质，联想问题。

有一个重要性质：交换相邻两行不会影响每列摊点数，同时交换相邻两列不会影响每行摊点数，故我们可以**分开考虑**，转化成独立的两个问题。

看到这里，我们不难联想到经典问题：均分纸牌，我们先为读者讲解这个问题的处理方法。

### 二、解决均分纸牌问题。

有 $M$ 个人排成一行，第 $i$ 个人手中有 $C_i$ 张纸牌，每个人可以和相邻的人交换一张纸牌，问是否可解及最少交换次数。

显然，当且仅当纸牌总数 $T$ 可以被 $M$ 整除时有解。

最后，每个人手中都应该有 $\frac{T}{M}$ 张纸牌，令这个数为 $num$。

从第 $1$ 个人开始考虑。

若 $C_1 > num$，则他应该给第二个人 $C_1 - num$ 张纸牌，反之，则应该从第二个人手中拿 $num - C_1$ 张纸牌。

同样地考虑第二个人到第 $n$ 个人。

令 $G$ 为 $C$ 的前缀和数组，则不难发现最小步数就是：

$\sum_{i=1}^{M}\lvert i \times \frac{T}{M} - G_i \rvert$。其含义是每个前缀会和后面发生“差的绝对值”的交换。

此时，我们设 $A_i = C_i - \frac{T}{M}$，记 $S$ 为 $A$ 的前缀和数组。

则答案不变，仍为 $\sum_{i=1}^{M} \lvert S_i \rvert$。此时便能直接递推求解。

### 三、产生联系，解决问题

回到本题，我们发现，如果去掉“第 $1$ 列与最后一列也相邻”这个条件，两问题一模一样，故本问题相当于交换纸牌问题的升级版：环形交换纸牌。为了叙述方便，本题解将题目抽象为环形纸牌问题讲解。

有 $M$ 个人**排成一个环**，第 $i$ 个人手中有 $C_i$ 张纸牌，每个人可以和相邻的人交换一张纸牌，问是否可解及最少交换次数。

仔细思考发现，一定存在一种最优解，使得环上某两个人没有发生纸牌交换，故朴素做法为枚举这个没交换的位置，断成链来采取之前讲的方法递推解决。

然而，神奇的是，我们稍经推导发现，从第 $k$ 个人断成行，$S_M$ 为 $0$，且前缀和数组的变化为都减去 $S_K$。

于是，前缀和数组由 $S_i$ 变为 $S_i-S_k$。

根据之前推导的公式，我们发现最小步数为 $\sum_{i=1}^{M} \lvert S_i - S_k \rvert$。

那么当 $k$ 取何值时上式最小？不难发现，这又是一道经典问题：货仓选址，洛谷上应该有题目，这题不再赘述。根据结论，我们只需要将 $S$ 从小到大排序，中位数即是最优解，至此，本题得到完美解决，复杂度瓶颈是两个排序，即：

$O(n \log n + m\log m)$。

### 四、构造代码，代码如下。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ls (id * 2)
#define rs (id * 2 + 1)
#define fi first
#define se second
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
const int N = 1e5 + 5;
int n, m, T, x, y;
int row[N], col[N], sr[N], sc[N];
bool isr, isc;
ll resr, resc;
int main(void) {
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> T;
	for (int i = 1; i <= T; ++i) {
		cin >> x >> y;
		++row[x], ++ col[y];
	}
	if (T % n == 0) isr = true;
	if (T % m == 0) isc = true;
	if (isr) {
		int num = T / n;
		for (int i = 1; i <= n; ++i) {
			row[i] -= num;
		}
		for (int i = 1; i <= n; ++i) {
			sr[i] = sr[i - 1] + row[i];
		}
		sort(sr + 1, sr + n + 1);
		for (int i = 1, j = n; i < j; ++i, --j) {
			resr += sr[j] - sr[i];
		}
	}
	if (isc) {
		int num = T / m;
		for (int i = 1; i <= m; ++i) {
			col[i] -= num;
		}
		for (int i = 1; i <= m; ++i) {
			sc[i] = sc[i - 1] + col[i];
		}
		sort(sc + 1, sc + m + 1);
		for (int i = 1, j = m; i < j; ++i, --j) {
			resc += abs(sc[j] - sc[i]);
		}
	}
	if (isr && isc) {
		cout << "both" << ' ' << resr + resc;
	}
	else if (isr) {
		cout << "row" << ' ' << resr;
	}
	else if (isc) {
		cout << "column" << ' ' << resc;
	}
	else {
		cout << "impossible";
	}
    return 0;
}
```

谢谢大家！！！

---

## 作者：Tenil (赞：2)

# Solution

这里是博客：[Tenil](https://www.cnblogs.com/tenil)，还没装修，还请见谅。

### 一些闲话

写之前看过大家的题解，觉得都写的很好，所以本蒟蒻这篇也不大抱希望，就当做完题写个随笔？

## 题意

[原题链接](https://www.luogu.com.cn/problem/P10453)

给定 $N\times M$ 矩阵与 $T$ 个特殊点，每次操作可以将相邻点进行交换，且每行、每列首尾也算作相邻，求使每行特殊点数相同，每列相同，每行相同且每列相同的可行性与最少操作步数。

## 分析

#### 可行性判断

首先是可行性判断：以行的判断为例，因为交换没有限制，所以只要满足可以每行数量相同即可，也就是 $N $ 整除 $T$ 即可。列和整个矩阵的判断同理。

#### 最少步数求解

求解时，应该想到行和列的交换是独立的。

如样例1：


```cpp
.   *
.   *
*   *
//*为关键点
```

将 $(2,1)$ 与 $(1,1)$ 交换前后，第一行都有且仅有一个关键点，而第2列点数减1，第1列加1。即列交换不影响行点数。这是显然的。

其实这就是这个题最关键的一步了。想到这里，由于行和列交换独立，可以分开考虑交换，而且可以整体考虑交换。例如交换行时，考虑整列地交换，从而问题变成了：

>给定正整数 $N$ 以及数列 $a_N$，每次可以以代价 $k$，使相邻两数一个 $+k$ 一个 $-k$（ $a_1$ 和 $a_N$ 也算作相邻）要使 $a_N$ 每项相同，求最小代价和。

对于这个问题，先考虑 $a_1$ 和 $a_N$ 不算作相邻的情况（链上）：考虑直接贪心：每一项减后不可能再加，加后不可能再减，代价与选定数的顺序无关，所以对每个数可以直接一步到位，先计算目标值 $ave=\frac{\sum_{i = 1}^n a_i}{N}$，然后直接从 $N=1$ 开始向右扫一遍，大于 $ave$ 的自减右加，小于同理，所以 $ans=\sum_{i = 1}^n abs(a_i-ave)$，写个前缀和轻松解决。

那么接下来就是 $a_1$ 和 $a_N$ 也算作相邻的了（环上）。首先，环上问题一定能破坏成链上的环节问题，因为环具有封闭性，除了涉及到断点的操作，任何操作都可以在链上等效替代。以本题为例：如果把 $a_1$ 和 $a_N$ 断开，对于非断点， $a_1$ 和 $a_2$ 操作没有受到任何影响；而对于断点， $a_1$ 和 $a_N$ 操作，其实和 $a_1$ 和 $a_2$ 操作后， $a_2$ 和 $a_3$ 操作，一直到到 $a_N$ 从结果上是一样的，只是代价有差异，差异取决于 $a_1$ 和 $a_N$ 原本的值。因此破坏时要遍历每一组可能的间断点，进行 $N$ 次链上问题，对代价取最小值。

很好，已经 $O(n^ 2)$ 了，但是$1\le N,M\le 100000$ 显然不行，再考虑一下优化——

现在我们把 $a_i$ 和 $a_{i+1}$ 断开，并以 $a_{i+1}$ 为链的起点， $a_i$ 为终点，即：$a_{i+1},a_{i+1+1},a_{i+1+2},\dots,a_N,a_1,a_2,\dots,a_i$。

设原有以 $a_1$ 开头的链为原数组计算的前缀和数组 $S_N$，则新数组 $G_N$ 为：

```cpp
G[i+1]=S[i+1]-S[i];//现在它是第一项
G[i+2]=(S[i+2]-S[i-1])+G[i-1]=S[i+2]-S[i-1]
......
G[1]=S[1]+S[N]-S[i]
G[2]=S[2]+S[N]-S[i]
......
//若S[N]=0,即计算S前,a先通减了ave，有：
G[x]=S[x]-S[x-1]+G[x-1]=S[x]-S[i]
```

最后一式直观的话容易看出，证明的话递推即可。于是新前缀和的每一项就是原数组全减 $S_i$，继续使用上述链上问题的思路（或者直接代公式），有 $ans=min(\sum_{i = 1}^n abs(S_i-S_k)),k \in [1,N]$。

典型的初中数学题！于是直接使 $S_k$ 为 $a_N$ 的中位数（排个序取 $S_{\frac{N}{2}}$），问题得解。

以上即为 [P2512 糖果传递](https://www.luogu.com.cn/problem/P2512)解题思路。

## 实现

读入矩阵，同时记录每行每列点数。先判断可行性，再按行、列进行求最小。若行列都成立的，分别计算求和即可。

## Code


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>

using namespace std;

typedef long long ll;//不开long long 见祖宗

ll fr() {
	ll x=0; char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) {
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}//经典快读

const ll maxn=1e5+10;
ll r[maxn],c[maxn],n,m,t,x,y;

ll row(ll x,ll *a) {
	ll M = t/x,ret = 0;//求均
	ll dr[maxn];
	dr[0]=0;
	for(register int i = 1; i <= x; i++) {
		a[i]-=M;//先减
		dr[i]=dr[i-1]+a[i];
	}
	sort(dr+1,dr+1+x);
	int k=(1+x)/2;//中位数
	for(register int i = 1; i <= x; i++) {
		ret+=abs(dr[i]-dr[k]);
	}
	return ret;
}

int main() {
	n=fr();m=fr();t=fr();
	for(register int i = 1; i <= t; i++) {
		x=fr();y=fr();
		r[x]++;c[y]++;//计数转糖果传递
	}
	if(!(t%n)&&!(t%m)) printf("both %lld\n",row(n,r)+row(m,c));
	else if(!(t%n)) printf("row %lld\n",row(n,r));
	else if(!(t%m)) printf("column %lld\n",row(m,c));
	else {
		printf("impossible\n");
	}
	return 0;
}
```
## 后话

感觉有用，还请点个赞吧！

---

## 作者：Octopus_hsfzy (赞：1)

这道题我完全是被算法标签坑了！我看标签是前缀和，我就思考了半天，终于……啥都没想出来。  
后来我在 acwing 偶然看见了这道题，就看了一眼它的算法标签，结果竟然是排序！！！  
因此，我确信这道题肯定要老老实实地推公式了。

言归正传，首先我们可以先用几个特判判断情况，因为题目要求感兴趣的摊位数相等，所以需要需要整除，也就是以下情况： 
1. 如果 $t\nmid n$ 且 $t\nmid m$ 则就横竖都满足不了，直接输出 impossible；
2. 如果 $t\nmid n$ 且 $t\mid m$ 则只有竖可以满足，先输出 column，再计算最小交换数；
3. 如果 $t\mid n$ 且 $t\nmid m$ 则只有横可以满足，先输出 row，再计算；
4. 如果 $t\mid n$ 且 $t\mid m$ 则都可以满足，先输出 both，再计算。

问题来了，我们该如何计算最小交换数呢？答案只有一个：推公式！  
接下来以计算行的最小交换数举例。定义一个数组 $a$ 表示这一行的店铺数量，由于我们需要求最小交换次数，不妨开一个 $v$ 数组，其中 $v_{i}$ 表示第 $i$ 行要把 $v_{i}$ 个商铺交换到第 $(i+1)$ 行交（特别地，因为题目为环形，所以 $v_{n}$ 表示第 $n$ 行要把 $v_{n}$ 个商铺交换到第 $1$ 行），定义 $x$ 为每行摊位最终理想的商铺个数，不难得出，$x=a$ 数组的平均值。

然后，最关键的公式推导！  
最开始的答案：
$$
\sum\limits_{i=1}^{n} \left|v_{i}\right|
$$
我们尝试用 $v_{1}$ 代替所有的 $v_{i}$：
$$
v_{2}=v_{1}+a_{2}-x \\
v_{3}=v_{2}+a_{3}-x=v_{1}+(a_{2}-x)+(a_{3}-x) \\
v_{4}=v{3}+a_{4}−x=v_{1}+(a_{2}−x)+(a_{3}−x)+(a_{4}−x) 
$$
由此可以看出：
$$
v_{i}=\sum\limits_{j=2}^{i}(a_{j}-x)+v_{1}
$$
若最开始 $a$ 数组就整体减去一个 $x$ 就变成：
$$
v_{i}=\sum\limits_{j=2}^{i}a_{j}+v_{1}
$$
则最终答案是：
$$
\left|v_{1}\right|+\sum\limits_{i=2}^{n}\left|\sum\limits_{j=2}^{i}a_{j}+v_{1}\right|
$$
这里令：
$$
c_{i}=\sum\limits_{j=2}^{i}a_{j} \\
c_{1}=0
$$
则答案等于：
$$
\sum\limits_{i=1}^{n}\left|c_{i}+v_{1}\right|
$$
再令 $z=(-v_{i})$，那么答案最终转换成：
$$
\sum\limits_{i=1}^{n}\left|c_{i}-z\right|
$$
是不是很熟悉？对，这就是[货舱选址](https://www.luogu.com.cn/problem/P10452)。（不会货舱选址的同学可以去看一下这道题的题解）

然后，就是最精彩的代码环节！

```cpp
#include <bits/stdc++.h>//本章鱼码风与大多数人不同，不喜勿喷
using namespace std;
long long n,m,k,a[100005],b[100005],l,r,c[100005];
long long work(long long *a,long long t){//货舱选址的操作
	long long work_x=0,zym=0,x;
	for(int i=1;i<=t;i++){
		work_x+=a[i];
	}
	work_x/=t;
	for(int i=1;i<=t;i++){
		a[i]-=work_x;
	}
	c[1]=0;
	for(int i=2;i<=t;i++){
		c[i]=c[i-1]+a[i];
	}
	sort(c+1,c+1+t);//记得要排序！！！
	x=c[t/2+1];
	for(int i=1;i<=t;i++){
		zym+=abs(c[i]-x);
	}
	return zym;
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		scanf("%lld%lld",&l,&r);
		a[l]++;
		b[r]++;
	}
	if(k%n!=0&&k%m!=0) cout<<"impossible";//几种情况的探讨
	else if(k%n!=0){
		cout<<"column"<<" "<<work(b,m);
	}
	else if(k%m!=0){
		cout<<"row"<<" "<<work(a,n);
	}
	else{
		cout<<"both"<<" "<<work(a,n)+work(b,m);
	}
	return 0;
}
```

---

## 作者：Wind_love (赞：1)

## 思路
我们发现行列是不互相影响的，所以我们可以分开来处理。

本题可以认为是两个环形的均分纸牌问题。设有 $n$ 堆纸牌，每堆有 $a_i$ 张，一共有 $s$ 张纸牌，那么最终每堆应该有 $\frac{s}{n}$ 张，而张数一定是个整数。

所以，若 $s \bmod n\neq0$，则是无解的。每堆减去平均数（最终数值），即我们构造数列 $b_i= a_i-s/n$。按均分纸牌做法，从开头到结尾扫一遍，每次从下一个堆把这个堆缺少的填满，统计移动的答案即可，本题也可以借鉴这个思路。

我们可以打出数组 $b$ 的前缀和 $sum$，若从第 $k$ 为开始，则总代价为 $sum_k$ 与 $sum$ 数组内所有数的差的绝对值之和。

易知，当 $k$ 为 $sum$ 数组的中位数时，本式有最小值，则本题最终做法为：

将 $sum$ 数组排序，令 $sum_k=sum_{(n+1)/2}$，计算代价即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define debug printf("-----------------------\n");
#define int long long
int n,m,t,x,y;
int a[101000],b[101000];
int ans;
int suma[101000],sumb[101000];
signed main() {
	cin>>n>>m>>t;
	for(int i=1;i<=t;i++){
		cin>>x>>y;
		a[x]++;
		b[y]++;
	}
  if(t%n==0&&t%m==0){
		cout<<"both ";
	}
  else if(t%n==0){
		cout<<"row ";
	}
  else if(t%m==0){
		cout<<"column ";
	}
  else{
		cout<<"impossible";
		return 0;
	}
	if(t%n==0){
		for(int i=1;i<=n;i++){
			suma[i]=suma[i-1]+a[i]-t/n;
		}
		sort(suma+1,suma+1+n);
		for(int i=1;i<=n;i++){
			ans+=abs(suma[i]-suma[(n+1)/2]);
		}
	}
  if(t%m==0){
		for(int i=1;i<=m;i++){
			sumb[i]=sumb[i-1]+b[i]-t/m;
			
		}
		sort(sumb+1,sumb+1+m);
		for(int i=1;i<=m;i++){
			ans+=abs(sumb[i]-sumb[(m+1)/2]);
		}
	}
	cout<<ans;
	return 0;//好习惯
}

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

对于 $t$ 个位于一个 $n\times m$ 矩阵内的特殊点，求最小的操作次数使得其在每行每列的个数都相同。

### 2. 思路

（调了我一个小时真的会谢。）

首先判断是否能在每行上排列相同点数。

容易知道当 $n\mid t$ 时能在每行上排列相同点数。

对列的判断同理。

然后考虑如何在最少的操作次数内完成。

注意到交换行对列是没有影响的，即行和列的交换是独立的。

因此我们将行和列分别单独讨论。

可以发现这和纸牌均分问题比较相似，也就是 [P2512 糖果传递](https://www.luogu.com.cn/problem/P2512)。

借助此题的思路来思考这道题。

我们设 $avg=\dfrac{\sum\limits_{i=1}^na_i}{n}$，则每个人的花费为 $a_i-avg$，记为 $b_i$。

我们考虑把牌统一传到一个人的手上，记这个人为 $k$。

则总花费为 $\sum\limits_{i=1}^n\left\vert b_i-b_k\right\vert$。

考虑其几何意义，即在数轴上共 $i$ 个点到一个点的距离之和。

不难知道这个点一定在中位数的位置上。

因此我们对 $b$ 作个排序，取中位数计算总花费即可。

回到这题，也就是我们对行和列分别作均分纸牌即可。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,t,ans,r[100100],c[100100],x,y,b[100100],sum[100100];
void col(){
	int s=0;
	for(int i=1;i<=m;i++){
		s+=c[i];
	}
	int avg=s/m;
	for(int i=1;i<=m;i++){
		b[i]=c[i]-avg;
		if(i==1){
			sum[i]=b[i];
		}
		else{
			sum[i]=b[i]+sum[i-1];
		}
	}
	sort(sum+1,sum+1+m);
	for(int i=1;i<=m;i++){
		ans+=abs(sum[(m+1)/2]-sum[i]);
	}
}
void row(){
	int s=0;
	for(int i=1;i<=n;i++){
		s+=r[i];
	}
	int avg=s/n;
	for(int i=1;i<=n;i++){
		b[i]=r[i]-avg;
		if(i==1){
			sum[i]=b[i];
		}
		else{
			sum[i]=b[i]+sum[i-1];
		}
	}
	sort(sum+1,sum+1+n);
	for(int i=1;i<=n;i++){
		ans+=abs(sum[(n+1)/2]-sum[i]);
	}
}
signed main(){
	cin>>n>>m>>t;
	for(int i=1;i<=t;i++){
		cin>>x>>y;
		r[x]++,c[y]++;
	}
	if(t%n==0&&t%m==0){
		cout<<"both ";
		row();
		col();
		cout<<ans;
	}
	else if(t%n==0){
		cout<<"row ";
		row();
		cout<<ans;
	}
	else if(t%m==0){
		cout<<"column ";
		col();
		cout<<ans;
	}
	else{
		cout<<"impossible";
	}
	return 0;
}

```

---

## 作者：BLuemoon_ (赞：0)

[link](https://www.luogu.com.cn/problem/P10453)

## 题意

给定一个 $N\times M$ 的矩阵，其中有一些点是关键点，一次操作可以交换相邻两个点的关键性。问使每行每列关键点数量一致的最小移动步数。

## 前置知识

[P2512 [HAOI2008] 糖果传递](https://www.luogu.com.cn/problem/P2512)

即环形均分纸牌。

令 $v$ 为 $\{a_n\}$ 的平均值，$a_i^{\prime}=a_i-v$，$\{s_n\}$ 为 $\{a_i^{\prime}\}$ 的前缀和。

假设在第 $k+1$ 个点断环成链，则前缀和变为：

|$a_{k+1}^{\prime}$|$s_{k+1}-s_k$|
|:-:|:-:|
|$\vdots$|$\vdots$|
|$a_{n}^{\prime}$|$s_n-s_k$|
|$a_{1}^{\prime}$|$s_1+s_m-s_k$|
|$\vdots$|$\vdots$|
|$a_{k}^{\prime}$|$s_k+s_m-s_k$|

可以发现全部减去了 $s_k$。那么答案就转化成了 $\displaystyle\sum_{i=1}^{n}|s_i-s_k|$。

就转化成了[货仓选址](https://www.luogu.com.cn/problem/P10452)问题，直接取中位数即可。

## 思路

由于交换行之间的点不会改变列的关键点数，交换列之间的点不会改变行的关键点数，我们可以把行列分开处理。

对于行，可以把每一行的关键点数当作糖果传递处理；对于列同理。

## 代码

```cpp
// BLuemoon_
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

const int kMaxN = 1e5 + 5;

LL n, m, t, sl, sr, a[kMaxN], b[kMaxN], l[kMaxN], r[kMaxN], ls[kMaxN], rs[kMaxN], ans;
bool L, R;

int main() {
  cin >> n >> m >> t, L = t % n == 0, R = t % m == 0;
  for (int i = 1; i <= t; i++) {
    cin >> a[i] >> b[i], l[a[i]]++, r[b[i]]++;
  }
  if (!L && !R) {
    return cout << "impossible\n", 0;
  }
  cout << (L && R ? "both" : (L ? "row" : "column")) << ' ';
  sl = t / n, sr = t / m;
  if (L) {
    for (int i = 1; i <= n; i++) {
      l[i] -= sl, ls[i] = ls[i - 1] + l[i];
    }
  }
  if (R) {
    for (int i = 1; i <= m; i++) {
      r[i] -= sr, rs[i] = rs[i - 1] + r[i];
    }
  }
  sort(ls + 1, ls + n + 1), sort(rs + 1, rs + m + 1);
  if (L) {
    for (int i = 1; i <= n; i++) {
      ans += abs(ls[i] - ls[(n + 1) >> 1]);
    }
  }
  if (R) {
    for (int i = 1; i <= m; i++) {
      ans += abs(rs[i] - rs[(m + 1) >> 1]);
    }
  }
  cout << ans << '\n';
  return 0;
}
```

---

## 作者：lyas145 (赞：0)

题目在[这里](https://www.luogu.com.cn/problem/P10453)。

## 解题思路

首先一眼望过去，又行又列的感觉暴力都不好打，怎么办呢？一点一点地来推思路吧。

不难发现：在交换两个相邻的摊点时，如果这两个摊点在**同一行**，那么**只会影响到每列 cl 喜欢的摊点数**，不会影响到每行 cl 喜欢的摊点数；如果两个摊点在同一列也是一样的，**只会影响到每行 cl 喜欢的摊点数**，而不会影响到每列 cl 喜欢的摊点数。这个性质有什么用呢？有了这个性质，我们就可以分别**独立**处理题目中对行和列的要求。

下面我将以处理每行 cl 喜欢的摊点数进行讲解（列的处理思路和行的处理思路一模一样）。

令 $N$ 为行数，$T$ 为摊点数，设一个数组 $x$，令 $x_i$ 为第 $i$ 行 cl 喜欢的摊点数，题目要求每行 cl 喜欢的摊点数都相同，有没有感到很熟悉？是故友[均分纸牌](https://www.luogu.com.cn/problem/P1031)！。这样以来，有没有感觉此题的难度瞬间降低？先判断是否无解，如果 $T \mod N \ne 0$，直接就无解了（每行最终得有 $\frac{T}{N}$ 个 cl 喜欢的摊点，摊点不可能分裂，~~它又不是细胞~~）；否则一定有解，我们可以设一个数组 $a$，并令 $a_i = x_i - \frac{T}{N}$，再给 $a$ 数组搞个前缀和 $s$，令 $s_i = \sum\limits_{j = 1}^{i}a_j$，答案就是 $\sum\limits_{i = 1}^{N} |s_i|$。真有这么简单吗？还没完呢！这里相当于“**环形**均分纸牌”，~~其实这也不难~~，看到环就应该想到“破环为链”~~一定要有这个条件反射啊！~~，令第 $k$ 个数与它后一个数之间断开（如果 $k = N$，自然就是第 $N$ 个数与第 $1$ 个数之间断开），答案就是以下式子的最小值。

$$
\hspace{1.4cm} |s_{k + 1} \hspace{0.6cm} - s_{k}|\\
\hspace{1.4cm} |s_{k + 2} \hspace{0.6cm} - s_{k}|\\
\hspace{1.3cm} \cdots\\
\hspace{1.4cm} |s_N \hspace{0.7cm} - s_{k}|\\
\hspace{1.4cm} |s_1 + s_N - s_{k}|\\
\hspace{1.4cm} |s_2 + s_N - s_{k}|\\
\hspace{1.3cm} \cdots\\
+ \hspace{1cm} \ |s_{k} + s_N - s_{k}|\\
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
$$

~~这对齐真让人难受，`hspace` 真好使。~~

接下来考虑简化上述式子。

$\because\sum\limits_{i = 1}^{N}a_i = \sum\limits_{i = 1}^{N}(x_i - \frac{T}{N}) = \sum\limits_{i = 1}^{N}x_i - T = 0$

$\therefore s_N = \sum\limits_{i = 1}^{N}a_i = 0$

~~我想 $\sum\limits_{i = 1}^{N}x_i - T = 0$ 的原因不用解释吧。~~

所以可以把上面式子中间的 $s_N$ 全省略掉，答案就成了以下式子的最小值：

$$\sum_{i = 1}^{N}|s_i - s_k|$$

[货仓选址](https://www.luogu.com.cn/problem/P10452)的解题思路能帮你轻松得到上面式子的最小值：给 $s$ 排个序，$k$ 就是 $\left\lfloor\frac{n + 1}{2}\right\rfloor$，$s_k$ 即中位数（不懂的可以去看看货仓选址的题解，本题解不再赘述）。

于是本题的思路就推完了，至于列怎么搞就由你自己试着推一下吧，思路都一样。

## 码儿

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;     //不开祖宗见 long long。 
const int N=1e5+5;
int n,m,t,k;
//我这里用 k 表示一个二进制数。
//k 的第 1 位表示行是否有解，第 2 位表示列是否有解。
//这样的好处是输出字符串比较省事。 
ll ans;
ll x[N],y[N],s[N];
char ch[4][15]={"impossible","row","column","both"};
//k 为 0 时，二进制下是 0，输出 impossible；
//k 为 1 时，二进制下是 1，输出 row；
//k 为 2 时，二进制下是 10，输出 column；
//k 为 3 时，二进制下是 11，输出 both。 
ll solve(ll a[],int n) {        //“环形均分纸牌”处理函数。 
	for (int i=1;i<=n;i++) {a[i]-=t/n;s[i]=s[i-1]+a[i];}
	sort(s+1,s+1+n);
	ll res=0,mid=s[n+1>>1];    //mid 是中位数。 
	for (int i=1;i<=n;i++) {res+=abs(s[i]-mid);}
	return res;
}
int main() {
	scanf("%d%d%d",&n,&m,&t);
	for (int i=1;i<=t;i++) {
		int a,b;
		scanf("%d%d",&a,&b);
		x[a]++;y[b]++;         //处理每行（或每列）cl 喜欢的摊点个数。 
	}
	k=(t%n==0)+((t%m==0)<<1);  //计算 k 的值。 
	if (t%n==0) {ans=solve(x,n);}
	if (t%m==0) {ans+=solve(y,m);}   //有解就累计答案。 
	printf("%s",ch[k]);              //k 在这里被使用。 
	if (k) {printf(" %lld",ans);}    //若不是全无解，输出 ans。 
	puts("");
	return 0;
}
```

~~我比较懒，所以我在保持码风的基础上码量尽量能减则减。~~

## 小结

这题虽然是蓝，但我们推到最后它却简化成了两道橙题的结合版，那两道橙题并不难，推理过程中也没有非常反逻辑或难懂的东西，关键在于你能不能充分利用好已知去推未知。

Thanks for reading！

---

## 作者：Expert_Dreamer (赞：0)

分析后我们发现交换行只影响列，而交换列只影响行，所以我们可以分别求行和列。

以交换行为例：

如果感兴趣的摊点总数 $\sum\limits_{i=1}^{m} C_i$ 不能被 $m$ 整除，那么就不可能达到要求，否则我们要让每列中有 $\dfrac{\sum\limits_{i=1}^{m} C_i}{m}$ 个 cl 感兴趣的摊点。

那这样不就是均分纸牌吗？只不过，本题的要求使得计算的是环形均分纸牌，问题来了，环形均分纸牌和原来的有差别吗？注意到环可以被断开，如果从第 $k+1$ 个人作为起点，第 $k$ 个人作为终点，那么每人的纸牌数分别为 $a_{k+1},a_{k+2},a_{k+3},\dots,a_{k}$，纸牌的前缀和为 $s_{k+1}-s_k,s_{k+2}-s_k,\dots,s_k+s_m-s_k$，根据均分纸牌，最少步数为 $\min\limits_{1\le k\le n}\{\sum\limits_{i=1}^{m}\lvert s_i-s_k\rvert\}$，那这样不就是取一下中位数就完事了？时间复杂度 $O(n \log n+m \log m)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int row[100010],col[100010],f[100010],n,m,k;
long long cal(int a[],int t){//计算均分纸牌和中位数
    for(int i=1;i<=t;i++){
        a[i]-=k/t;
        f[i]=a[i]+f[i-1];
    }
    sort(f+1,f+t+1);
    long long res=0;
    for(int i=1;i<=t;i++) res+=abs(f[i]-f[(t+1)>>1]);
    return res;
}
int main(){
    cin>>n>>m>>k;
    for(int i=0;i<k;i++){
        int x,y;
        cin>>x>>y;
        row[x]++;
        col[y]++;
    }
    if(k%n==0&&k%m==0) cout<<"both "<<cal(col,m)+cal(row,n)<<endl;
    else if(k%n==0) cout<<"row "<<cal(row,n)<<endl;
    else if(k%m==0) cout<<"column "<<cal(col,m)<<endl;
    else cout<<"impossible"<<endl;
}
```

---

## 作者：forever_nope (赞：0)

上面两题打代码的时候脑子有点抽象，代码和我一样抽象（

这道题不太算完全自己做出来的，毕竟这个题的简化版的简化版的简化版我都不会/ng

一开始的思路是超级大分讨，我讨论出了七八种有解的情况但是这几种也不会求。

## 均分纸牌

AcWing1536 均分纸牌：[https://www.acwing.com/problem/content/description/1538/](https://www.acwing.com/problem/content/description/1538/)

显然，最后每个点只剩 $\mathit{avg}$ 个。

那么原序列减去 $\mathit{avg}$，然后如果某一时刻前缀和不为零，需要移动。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    vector<int> a(n);
    int avg = 0;
    for (int &i : a) cin >> i, avg += i;
    avg /= n;
    int ans = 0, lt = 0;
    for (int i = 0; i < n; ++i) {
    	a[i] -= avg, lt += a[i];
    	if (lt) ++ans;
    }
    cout << ans << endl;
	return 0;
}
```

前置，考虑移动多少个（而不是一次性多个的次数）。

我们记上文 $a$ 的前缀和为 $s$，

显然每次需要移动，$|s_i|$ 个，那么合在一起，总移动个数为 $\sum|s_i|$。

## 环形均分纸牌

P4016 负载平衡问题：[https://www.luogu.com.cn/problem/P4016](https://www.luogu.com.cn/problem/P4016)

和上面类似，但是环形。

容易理解，一定存在两个人，他们之间不传递纸牌。

因为如果传递的话，整个链流量整体减去，一样可行。

于是破环成链，枚举不需要传递的两个人，然后考虑计算。

可以直接原封不动按照上面的，如，

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    vector<int> a(2 * n);
    int avg = 0;
    for (int i = 0; i < n; ++i) cin >> a[i], avg += a[i];
    avg /= n;
    for (int i = 0; i < n; ++i) a[i] -= avg, a[i + n] = a[i];
    int ans = 1e9;
    vector<int> s(2 * n);
    for (int k = 0; k < n; ++k) {
    	s[k] = a[k]; int res = abs(s[k]);
    	for (int i = k + 1; i < k + n; ++i) s[i] = s[i - 1] + a[i], res += abs(s[i]);
    	ans = min(ans, res);
    }
    cout << ans << endl;
	return 0;
}
```

但是可以做到更优，考虑上面中形式如何，

$$
\sum|s_i-s_k|
$$

经典的简单贪心（货仓选址，略），当 $s_k$ 为 $s$ 中位数时，此式最小。

因此，

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n;
    vector<int> a(n), s(n);
    int avg = 0;
    for (int i = 0; i < n; ++i) cin >> a[i], avg += a[i];
    avg /= n; s[0] = (a[0] -= avg);
    for (int i = 1; i < n; ++i) a[i] -= avg, s[i] = s[i - 1] + a[i];
    sort(s.begin(), s.end()); int ans = 0;
    for (int i = 0; i < n; ++i) ans += abs(s[i] - s[n >> 1]);
    cout << ans << endl;
	return 0;
}
```

不过好像下面的跑的也不快，甚至比上面的略慢。

## 七夕祭

考虑到行、列独立。因为在行上操作不影响列，在列上操作不影响行。

更重要的，当我们把需要的东西移到一个位置，容易发现其实方案很多。

只需要每一个中间过程都是最有的，整体不绕路即可，因此其互相独立。

PS：小时候玩积木发现的（

然后就是如何判断有解，画出图来，

![](https://cdn.luogu.com.cn/upload/image_hosting/ajvwbi17.png)

容易理解，合在一起即可。

代码，

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

#define endl '\n'

constexpr int N = 1e5 + 10;

int n, m, t;
int a[N], b[N];
int s[N];

ll solev_row() {
	int avg = t / n;
	for (int i = 1; i <= n; ++i) s[i] = s[i - 1] + a[i] - avg;
	sort(s + 1, s + 1 + n);
	ll ans = 0; int mid = s[(n >> 1) + 1];
	for (int i = 1; i <= n; ++i) ans += abs(s[i] - mid);
	return ans;
}

ll solev_col() {
	int avg = t / m;
	for (int i = 1; i <= m; ++i) s[i] = s[i - 1] + b[i] - avg;
	sort(s + 1, s + 1 + m);
	ll ans = 0; int mid = s[(m >> 1) + 1];
	for (int i = 1; i <= m; ++i) ans += abs(s[i] - mid);
	return ans;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> m >> t;
    for (int i = 0, x, y; i < t; ++i)
    cin >> x >> y, ++a[x], ++b[y];
    ll ans = 0; int ed = 0;
    if (t % n == 0) ans += solev_row(), ed |= 1;
    if (t % m == 0) ans += solev_col(), ed |= 2;
    if (ed == 0) puts("impossible"), exit(0);
    if (ed == 3) cout << "both " << ans << endl;
    else cout << (ed == 1 ? "row " : "column ") << ans << endl;
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

建议升蓝。

因为交换行/列并不会影响到列/行的数量（注意一一对应），所以行列分开看就行。

先判断有没有解（整除则有解，否则无解）。然后就是横纵两次[糖果传递](https://www.luogu.com.cn/problem/P2512)（这也是建议升蓝的原因）。建议切掉上面这道题后再写这道。具体的推导过程我认为[这篇](https://www.luogu.com.cn/article/g9wlldda)比较好。其实就是在解方程。

省流：中间取。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, t, col[100001], row[100001], x, y, xavg, yavg, cc[100001], cr[100001], cmiv, rmiv, cans, rans;
inline void read(int& x) {
	register int f = 1; x = 0; register char c = getchar();
	for (; c > '9' || c < '0'; c = getchar()) if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + (c ^ 48);
	x *= f;
}
signed main() {
	read(n); read(m); read(t); xavg = yavg = t; xavg /= n; yavg /= m;
	if (t % m && t % n) cout << "impossible\n", exit(0);
	for (int i = 1; i <= t; ++i) read(x), read(y), col[x]++, row[y]++;
	for (int i = 1; i <= n; ++i) cc[i] = cc[i - 1] - xavg + col[i - 1]; sort(cc + 1, cc + n + 1);
	for (int i = 1; i <= m; ++i) cr[i] = cr[i - 1] - yavg + row[i - 1]; sort(cr + 1, cr + m + 1);
	cmiv = cc[(n + 1) / 2]; rmiv = cr[(m + 1) / 2];
	for (int i = 1; i <= n; ++i) cans += abs(cc[i] - cmiv);
	for (int i = 1; i <= m; ++i) rans += abs(cr[i] - rmiv);
	if (t % n == 0) {
		if (t % m == 0) cout << "both " << cans + rans << endl;
		else cout << "row " << cans << endl;
	}
	else if (t % m == 0) cout << "column " << rans << endl;
	return 0;
}
```

---

## 作者：ttq012 (赞：0)

首先若可以让所有感兴趣的摊均分到每一行上必须要满足 $n\mid T$，均分到每一列上必须要满足 $m\mid T$。这是显然的，要不然没法分。

然后发现行和列的情况是相互独立而且相似的，所以只考虑行的情况即可。

容易发现一行的情况就是一个环上可以对两个相邻的点上的值做一定的操作通过最少次数让这个环上所有的数的值都相等。这就是一个典型的贪心问题，直接求解即可。所以总的时间复杂度为 $O(n)$。

```cpp
const int N = 500100;
int row[N], col[N], b[N];

int get(int *a, int n) {
    int ave = accumulate(a + 1, a + n + 1, 0ll) / n;
    F(i, 1, n) {
        a[i] -= ave;
    }
    b[1] = 0;
    F(i, 2, n) {
        b[i] = b[i - 1] + a[i];
    }
    sort(b + 1, b + n + 1);
    int M = b[n / 2 + 1], s = 0;
    F(i, 1, n) {
        s += abs(M - b[i]);
    }
    return s;
}
void qunqun() {
    int n, m, k;
    cin >> n >> m >> k;
    F(i, 1, k) {
        int l, r;
        cin >> l >> r;
        row[l]++;
        col[r]++;
    }
    if (k % n && k % m) {
        cout << "impossible\n";
    } else if (k % n) {
        cout << "column " << get(col, m) << '\n';
    } else if (k % m) {
        cout << "row " << get(row, n) << '\n';
    } else {
        cout << "both " << get(row, n) + get(col, m) << '\n';
    }
}

signed main() { $(); }
```

---


# [FJCPC 2025] XCPC

## 题目描述

XCPC 赛事拥有金、银、铜、铁四种奖牌。作为一名参与该赛事的魔法师，小 A 可通过金、银、铜、铁四种奖牌作为媒介，施展“红日初升”法阵，召唤太阳，祈求保佑。

在施展“红日初升”法阵的过程中，每一个奖牌都可以提供光亮值。其中金、银、铜、铁奖牌分别具有 $4$，$3$，$2$，$1$ 的光亮值。而施展“红日初升”法阵要求所有奖牌的光亮值之和大于等于 $p$ 。

初始时小 A 有 $n$ 块铁牌，他可以通过炼金术进行奖牌转换：将 $2$ 个铁牌合成 $1$ 个铜牌、将 $2$ 个铜牌合成 $1$ 个银牌、将 $2$ 个银牌合成 $1$ 个金牌。

假设用四元组 $(a_1,a_2,a_3,a_4)$ 分别表示金、银、铜、铁奖牌的数量。请回答以下 $n$ 个问题，其中第 $i~(1\le i\le n)$ 个问题是：

* 初始有 $n$ 块铁牌，最终有多少种不同的四元组 $(a_1,a_2,a_3,a_4)$，同时满足：

（1）一共有 $i$ 个牌子，即 $a_1+a_2+a_3+a_4=i$；

（2）可以施展“红日初升”法阵，即 $4a_1+3a_2+2a_3+a_4\ge p$。

其中 $p$ 通过输入给定。

两个四元组不同当且仅当它们存在某一位对应的数字不同。


## 说明/提示

**样例解释**：对于样例一，初始的 $8$ 个铁牌最终可以得到多个四元组，以下列出光亮值之和大于等于 $7$ 的：

* 第 $1,2$ 个问题：（无）；

* 第 $3$ 个问题：$(0,1,2,0)$；

* 第 $4$ 个问题：$(0,0,4,0),(0,1,1,2)$；

* 第 $5$ 个问题：$(0,1,0,4),(0,0,3,2)$；

* 第 $6$ 个问题：$(0,0,2,4)$；

* 第 $7$ 个问题：$(0,0,1,6)$；

* 第 $8$ 个问题：$(0,0,0,8)$。

## 样例 #1

### 输入

```
8 7
```

### 输出

```
0 0 1 2 2 1 1 1
```

## 样例 #2

### 输入

```
10 8
```

### 输出

```
0 0 1 2 2 2 2 1 1 1```

## 样例 #3

### 输入

```
12 1
```

### 输出

```
0 1 2 2 3 3 2 2 2 1 1 1```

# 题解

## 作者：zzy0618 (赞：3)

先不考虑 $i$ 个牌子，我们有：

$$8a_1+4a_2+2a_3+a_4=n\\ 4a_1+3a_2+2a_3+a_4\ge p$$

然后枚举 $a_1,a_2$，下面用 $x,y$ 代替，发现 $a_3,a_4$ 是可以消掉的，配合 $a_3,a_4\ge 0$ 可得：

$$8x+4y\le n\\ n-4x-y\ge p$$

所以考虑剩余全是铁，铜的极端情况，所有 $i\in[x+y+\lfloor\frac{n-8x-4y+1}2\rfloor,x+y+(n-8x-4y)]$ 的答案都可以得到 $1$ 的贡献。整理一下，也就是 $[\lfloor\frac{n+1}2\rfloor-3x-y,n-7x-3y]$。

枚举两个时间显然会爆。假如我们枚举 $y$，$x$ 不变，这个区间左端点会不断减 $1$，右端点会不断减 $3$，所以对应到答案的差分数组上就是一个区间加（减）和每三个数加（减）。考虑再对数组分别作公差为 $1,3$ 的差分，枚举 $x$，就转化成单点加减了。

复杂度 $O(n)$。

提供一份极简的代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+5;
int n,p;ll a[N],b[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>p;
	for(int x=0,t,y;x<=n;++x){
		y=min(n-x*4-p,(n-x*8)/4);if(y<0)break;
		t=(n+1)/2-x*3,++a[t-y],--a[t+1];
		t=n-x*7+1,--b[t-y*3],++b[t+3];
	}for(int i=1;i<=n;++i)
		a[i]+=a[i-1],b[i]+=(i>2?b[i-3]:0);
	ll s=a[0]+b[0];
	for(int i=1;i<=n;++i)
		cout<<(s+=a[i]+b[i])<<' ';
	return 0;
}
```

---

## 作者：Autumn_0930 (赞：2)

一点数学推导+二维差分。

（根据题解规范，我已对该题解进行了较为全面的检查和修正。感谢管理员用心审核。）

---

### 题意化简

给定整数 $n$ 和 $p$，对于 $i \in [1, n]$，求出满足
$$
\begin{cases}
8a_1 + 4a_2 + 2a_3 + a_4 = n \\
a_1 + a_2 + a_3 + a_4 = i \\
4a_1 + 3a_2 + 2a_3 + a_4 \ge p
\end{cases}
$$
的四元组 $(a_1, a_2, a_3, a_4)$ 个数。

### 思路简述

首先注意到 $a_1$ 和 $a_2$ 的变化对于答案的影响较大，优先枚举 $a_1, a_2$。

那么如何处理 $a_3$ 和 $a_4$ 呢？二者在 $(I)$ 和 $(III)$ 两式中系数相同，考虑消元，得到：
$$
i - 4a_1 - a_2 \ge p.
$$
这样我们就得到了理论上 $a_2$ 可取到的最大值（实际上式 $(I)$ 还自带了一个范围 $a_2 \le \lfloor \frac{n - a_1 \times 8}{4} \rfloor$）。

我们考虑**一对 $(a_1, a_2)$ 对 $i$ 的贡献**：

- 若尽可能地合成 $Cu$，则 $a_3 = (n - 8a_1 - 4a_2 - a_4) / 2$，故有：
  $$
  a_3 + a_4 = \left\lceil \frac{n - 8a_1 - 4a_2}{2} \right\rceil.
  $$

- 若不合成 $Cu$，则 $a_3 = 0$，$a_4 = n - 8a_1 - 4a_2$，故有：
  $$
  a_3 + a_4 = n - 8a_1 - 4a_2.
  $$

如此得到对 $i$ 的贡献区间 $\left[\left\lceil \frac{n}{2} \right\rceil - 3a_1 - a_2, n - 7a_1 - 3a_2\right]$。该区间内的每一个 $i$ 都可以得到大小为 $1$ 的贡献。

此时要解决的问题就变成了：维护**区间全体 $+1$** 的操作，显然差分就可以解决。

带一点点双指针的思想，取 $a_1$ 为定值，枚举 $a_2$，考虑 $a_2 \to a_2 + 1$ 会对答案产生的影响：

**区间左端点左移一位，右端点左移三位**，形象一点就是一边左移一边缩小。

实际操作的时候，左右各开差分数组，分别维护左右端点元素的差分（这里需要用到**二维差分**，简单来说就是左端点在普通差分上是 $+1$ 的，所以新位置 $+1$，老位置 $-1$；右端点在普通差分上是 $-1$ 的，所以新位置 $-1$，老位置 $+1$，这里没有接触过二维差分的可能需要理解一下）：

- 左边是连续区间直接上差分。
- 右边可分成 $3$ 组，相邻的 $3$ 个数都不在同一组，也就是**维护 $3$ 个普通差分的数组**，求完之后分别前缀和，回到右端点的一维差分，再求前缀和。
- 但在实现的时候，我们发现，没必要真的开 $3$ 个差分数组，只需要维护**下标呈公差为 $3$** 的位置，最后全部前缀和就好了。

### 代码实现

取端点的时候仔细一点就行了，哦还有一维差分在前缀和的时候要从 $0$ 开始，因为 $0$ 处也可能有被打过差分标记。

另外数组一定要开够，像我这样[怒砍一整页评测记录](https://www.luogu.com.cn/record/list?pid=P13090&user=890346)根本查不出来。

其他细节都在注释里（乐）。

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 1e6 + 10;
int n, p;
LL ans = 0, l[N], r[N]; // 分别维护左右端点的差分值 
int main() {
    scanf("%d %d", &n, &p);
    for(int a1 = 0; a1 <= n/8; a1++) { // a1最大也就到n/8了 
        int a2 = min(n - a1*4 - p, (n-a1*8) / 4); //这里是a2的可取最大值 
        if(a2 >= 0) {
	        // 维护二维差分 
	        int L = (n+1)/2 - a1*3 - a2, R = n - a1*7 - a2*3 + 1; // 新的区间左右端点 
	        l[L]++, l[L + 1 + a2]--; 
	        r[R]--, r[R + 3 + a2*3]++; // r[]维护下标呈公差为3的等差数列的元素 
	    }else {
	    	// Ag都不存在了就不用玩了
	    	break;
		}
    }
    // 前缀和一下就是一维差分 
    l[1] += l[0], l[2] += l[1]; // 防止R[]越界 
    for(int i = 3; i <= n; i++) l[i] += l[i-1], r[i] += r[i-3];
    for(int i = 0; i <= n; i++){
        ans += l[i] + r[i]; // 这里再前缀和一下就是原数组了 
        if(i > 0) printf("%lld ", ans);
    } 
    return 0;
}
```

---

## 作者：IntoTheDusk (赞：0)

> 给定两个正整数 $n,p$，对于每一个 $i \in [1,n]$，求有多少四元组 $(a_1,a_2,a_3,a_4)$，满足：
>
> - $8a_1+4a_2+2a_3+a_4=n$（下文中，我们称之为第一约束条件）。
> - $a_1+a_2+a_3+a_4=i$（下文中，我们称之为关于 $i$ 的第二约束条件）。
> - $4a_1+3a_2+2a_3+a_4 \ge p$（下文中，我们称之为第三约束条件）。
>
> $1 \le p \le n \le 10^6,\rm{1.0s},\rm{512MiB}$。

注意到，如果有一四元组 $(a_1,a_2,a_3,a_4)$ 分别满足第一、三约束条件与关于 $i$ 的第二约束条件，如果我们将 $a_4 \leftarrow a_4-2,a_3 \leftarrow a_3+1$（即原题干中把铁牌变为铜牌），则上面的约束条件中第一、三约束条件一定任然成立。

结合这一性质，我们不妨枚举 $a_1$ 与 $a_2$，看看其可以对那些 $i$ 产生贡献。

为了方便表述，下面记 $a_1$ 为 $x$，$a_2$ 为 $y$。

通过第一约束条件，我们可得 $8x+4y \le n$；通过第三约束条件，我们可得 $n-4x-y \ge p$。

此时，如果总牌数能取到上界，则铁牌必然都不合成铜牌；如果总牌数能取到下界，则所有铁牌必然尽可能合成铜牌。通过推导可得，一对 $(x,y)$ 会对位于区间 $[x+y+\lceil \frac{n-8x-4y}{2} \rceil,x+y+n-8x-4y]$ 的 $i$ 有贡献。

化简后，$[x+y+\lceil \frac{n-8x-4y}{2} \rceil,x+y+n-8x-4y]=[\lceil\frac{n}{2}\rceil-3x-y,n-7x-3y]$。现在考虑固定 $x$。此时，区间随着 $y$ 的增大在数轴上不断向左运动并收缩。因此，问题可以转换为：

- 有一个初始全部为 $0$ 的序列 $c$，我们需要维护多组操作，每组操作形如 $(l,r,k)$，要求对于所有位于 $[0,k]$ 之间的正整数 $m$，将 $c_{l-m \dots r-3m}$ 全部加一。

不妨考虑这一问题在 $c$ 的差分数组 $d$ 上的意义。可以发现，这其实就是把 $d$ 上的一段区间加一，把 $d$ 上一些下标呈公差为 $3$ 的等差数列的元素减一。

为此，我们可以直接开两个二阶差分数组，分别维护左端点在差分数组上的标记以及右端点在差分数组上的标记。最后做两次前缀和即可。时间复杂度 $O\left(n\right)$。

[评测记录](https://www.luogu.com.cn/record/223555101)

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18976815)

题目本质是在满足 $4a_1+3a_2+2a_3+a_4\ge p$ 的前提下，统计满足 $8a_1+4a_2+2a_3+a_4=n$、且牌数 $a_1+a_2+a_3+a_4=i$ 的四元组个数。因为 $a_3,a_4$ 的系数都比 $a_2$ 小，一旦固定 $a_1$ 与 $a_2$，亮度约束可化为 $4a_1+a_2\le n-p$。设 $r=n-8a_1-4a_2$ 表示剩余铁单位，它必为偶数；把其中 $2a_3$ 单位炼成铜后剩下 $a_4$ 单位直接留下做铁，于是牌数区间为 $L=a_1+a_2+\lceil r/2\rceil$ 到 $R=a_1+a_2+r$。

随着 $a_2$ 递增，$L$ 每次减少 $1$，$R$ 每次减少 $3$，呈现等差结构。对固定 $a_1$，所有合法 $a_2$ 贡献的一批区间在差分数组里可一次性写入：左端是一段连续区间，用普通差分加；右端各端点落在同一模 $3$ 的等差序列上，可将差分拆成三条模 $3$ 链，用三条数组 $d_0,d_1,d_2$ 再做一次差分即可。这样外层只需遍历 $a_1$。求完三条链的前缀和后把结果灌回主差分，再做一次前缀和即得每个 $i$ 的答案。

时间复杂度 $O(n)$。

[link](https://www.luogu.com.cn/record/223427144)

---


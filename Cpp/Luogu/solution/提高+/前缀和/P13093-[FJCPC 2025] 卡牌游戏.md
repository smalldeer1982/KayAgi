# [FJCPC 2025] 卡牌游戏

## 题目描述

小 A 和小 B 正在玩卡牌游戏。

有 $2n$ 张卡牌垒成一摞牌堆，自上而下的第 $i$（$1\leq i\leq 2n$）张牌上标注了数字 $a_i$。发牌时，牌堆中的卡牌自上而下以 $1, 2, \dots, 2n$ 编号，编号为奇数的卡牌将分给一位玩家，编号为偶数的卡牌将分给另一位玩家。这意味着，小 A 将会获得编号同为奇数或同为偶数的 $n$ 张卡牌。

对于玩家而言，所得到的卡牌上的数字之和越大，游戏局面对他越有利。因此小 A 想最大化最坏情况下他所得到的卡牌数字之和。为了达到这个目的，小 A 可以对当前牌堆执行恰好一次以下操作：

-   从当前牌堆中抽出一张卡牌，并插回牌堆中的任意位置。注意发牌时的编号可能会发生变化。

例如，初始时牌堆中卡牌标注的数字自上而下依次是 $1, 2, 3, 4$，发牌时一位玩家将得到 $1, 3$，另一位玩家将得到 $2, 4$。小 A 可以选择抽出第二张卡牌，并将其插回最后一张卡牌后面，此时牌堆为 $1, 3, 4, 2$，发牌时一位玩家将得到 $1, 4$，另一位玩家将得到 $3, 2$。

你需要求出小 A 在执行恰好一次操作后，最坏情况下所得到的卡牌数字之和的最大值。

## 说明/提示

第一组样例即是题目描述中所给出的例子。发牌时，一位玩家的卡牌数字之和为 $1 + 4 = 5$，另一位玩家的卡牌数字之和为 $3 + 2 = 5$，可以证明这即是所能取得的最大值。

第二组样例中，无论如何操作，发牌情况都将是一位玩家得到 $1$，而另一位玩家得到 $10^9$。因此最坏情况下小 A 只能得到 $1$，即为答案。

## 样例 #1

### 输入

```
4
2
1 3 2 4
1
1000000000 1
3
1 1 2 3 5 8
4
1 2 4 8 16 32 64 128```

### 输出

```
5
1
9
106```

# 题解

## 作者：KDL_ANIPLEX (赞：10)

## 题目

[传送](https://www.luogu.com.cn/problem/P13093)

就是有一个序列，你可以把任意一个元素插到任意一个地方，只能修改一次。

两人按奇偶取数，求两人得分的较小值的可能最大值。

## 转化

摸摸样例，可以猜到修改相当于：选择一个区间 $[l,r]$，区间内的数的位置奇偶互换。

**后来发现有点错误**，其实是：对于区间 $[l,r]$，若区间长度为奇数，区间 $(l,r]$ 内的数的位置奇偶互换；若为偶数，区间 $[l,r]$ 内的数的位置奇偶互换。

我们考虑区间长度为奇数，发现它等价于修改一个区间 $(l,r]$。

综上，我们只需考虑长度为偶数的区间。

## 做法

首先有一个 $O(n^2)$ 做法，就是暴力扫描每一个偶数区间，前缀和维护即可。

考虑优化。

我们令 $x_i$ 表示**奇数**下标小于等于 $i$ 的数的和；$y_i$ 表示**偶数**下标小于等于 $i$ 的数的和。

我们用式子表示修改偶数区间 $(l,r]$ 的奇数玩家的得分：

$$sun=x_l+y_r-y_l+x_{2n}-x_r$$

整理：

$$sun=(x_l-y_l)-(x_r-y_r)+x_{2n}$$

令 $s_i=x_i-y_i$。

原式为：

$$sun=s_l-s_r+x_{2n}$$

$s_i$ 是固定的，有什么用吗？

我们知道，要尽量使 $sun$ 接近所有数总和的一半（记为 $V$）。

我们考虑枚举左端点，右端点的 $s_r$ 要尽量接近 
$s_l-(V-x_{2n})$。

想到二分，单调性用 ``set`` 维护，注意**偶数**的细节，复杂度 $O(n\log n)$。

## 代码

**注意：上文的变量不一定与代码变量相同意思，凑合着看吧。**

```cpp
#include<bits/stdc++.h>
using namespace std;

int T,n;
long long s[200005];
set<long long>set_[2];//因为只能处理偶数区间，所以用两个set
long long sum,V,ans,xy[2],g,s_1,s_2;

inline int read(){
	int x=0;char ch=getchar();
	while (ch<'0'||ch>'9')ch=getchar();
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x; 
}

void slove() {

	set_[0].clear();
	set_[1].clear();
	xy[0]=xy[1]=0;

	n=read()*2,sum=0,ans=0;

	for (int i = 1,a; i <= n; i++)
		a=read(),sum += a,xy[i&1]+=a,s[i]=xy[1]-xy[0];

	V=sum/2;

	for (int l = n,op=0; l >= 0; l--,op=!op) {

		set_[op].insert(s[l]);
		g = s[l] - (V - xy[1]);

		auto r = set_[op].lower_bound(g);
		auto r_ = r;
		r_--;

		s_1 = s[l] - *r + xy[1], s_2 = s[l] - *r_ + xy[1];
		if (r == set_[op].begin()) ans = max(ans, min(s_1, sum - s_1));
		else ans = max(ans, max(min(s_1, sum - s_1), min(s_2, sum - s_2)));

	}

	printf("%lld\n",ans);

	return;
}

int main() {

	T=read();
	while (T--) slove();

	return 0;
}
```

---

## 作者：postpone (赞：2)

首先最差情况时，拿的牌之和肯定不比对手的大，否则交换你和对手的牌，就有更差的情况了。

假设最差情况下你的牌和为 $a$，对手牌和为 $b$，$s=a+b$，$d=b-a$，那么 $a=\frac{s-d}{2}$，因此求出最小的差 $d$，就能得出最大的 $a$。

现在来看怎么通过交换让 $d$ 最小。

把一张牌拿出来插到另一张牌下面，本质上就是选一个长度为偶数的区间，让区间中的**奇偶的和**互换。比如 `1` 换到 `4` 下面，就变成 `2 3 4 1`，原来偶位置是 `2 4`，现在变成了 `3 1`，虽然顺序变了，但是和是不变的。

由此，设

$$
A_i=\sum_{1\leq 2i+1\leq n} a_i，B_i=\sum_{1\leq 2i \leq n} a_i
$$

选择长度为偶数的区间 $[l, r]$，带来的差值是

$$
\Delta=|A_n-B_n-2(A_r-A_{l-1})+2(B_r -B_{l-1})|
$$

设 $d_i=A_i-B_i$，有

$$
\Delta=|d_n-2d_r+2d_{l-1}|
$$

从前到后扫过去，用 `std::set` 维护让 $\Delta$ 接近 $0$ 的 $l$ 即可。

```cpp
void solve() {
    int n;
    cin >> n;

    n *= 2;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    vector<i64> pre[2]{};
    pre[0].assign(n + 1, 0);
    pre[1].assign(n + 1, 0);
    
    for (int i = 0; i < n; i++) {
        pre[i & 1][i + 1] = a[i];
    }
    for (int i = 1; i <= n; i++) {
        pre[0][i] += pre[0][i - 1];
        pre[1][i] += pre[1][i - 1];
    }

    vector<i64> d(n + 1);
    for (int i = 0; i <= n; i++) {
        d[i] = pre[0][i] - pre[1][i];
    }

    i64 ans = 1e18;
    set<i64> s[2] {};
    s[0].insert(d[0]);
    for (int r = 1; r <= n; r++) {
        int j = r & 1;

        auto it = s[j].lower_bound(-(d[n] - 2 * d[r]) / 2);
        if (it != s[j].end()) {
            ans = min(ans, abs(d[n] - d[r] * 2 + *it * 2));
        }
        if (it != s[j].begin()) {
            it = prev(it);
            ans = min(ans, abs(d[n] - d[r] * 2 + *it * 2));
        }
        s[j].insert(d[r]);
    }
    
    cout << (pre[0][n] + pre[1][n] - ans) / 2 << "\n";
}
```

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18976682)

整副牌在发牌时按奇偶编号分给两人，设奇位牌面和减偶位牌面和为 $D$。若 $D=0$ 则两人必平分；若 $D>0$ 则奇方（小 A 若拿奇位）领先 $D$；若 $D<0$ 则落后 $|D|$。小 A 想让最坏情况下自己得到的数字之和最大，即希望把 $|D|$ 压到最小，因为最终他至少能拿到 $(\sum a_i-|D'|)/2$。

记交替前缀和 $P_i=\sum_{k=1}^{i}(-1)^{k+1}a_k$，那么 $D=P_{2n}$。抽出位置 $i$ 的牌再插到位置 $j$ 后，奇偶性划分发生环形位移。设 $s_i$ 表示 $i$ 的奇偶符号（奇为 $+1$，偶为 $-1$），可推出新差值

$$
D'=D-2\bigl(P_j-P_i\bigr)+a_i\bigl(s_j-s_i\bigr)
$$

目标就是在所有 $i\ne j$ 中找 $\min|D'|$。等式右边与 $2P_j$ 成一次函数关系，因此固定 $i$ 时，只须在满足 $j>i$ 的序列 $\{2P_j\}$ 中寻找最接近某个常数的值即可。把所有前缀值按奇偶拆成两棵 `multiset`，从右向左枚举 $i$，每次在对应集合用 `lower_bound` 取前驱和后继各比较一次，就能在 $O(\log n)$ 更新答案。数组整体反转再做一次可覆盖 $j<i$ 的情况。

时间复杂度 $O(n\log n)$。

[link](https://www.luogu.com.cn/record/223407395)

---


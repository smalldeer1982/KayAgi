# 地铁间谍

## 题目描述

特工玛利亚被送到 S 市执行一个特别危险的任务。她需要利用地铁完成他的任务，S 市的地铁只有一条线路运行，所以并不复杂。

玛利亚有一个任务，现在的时间为 $0$，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。

玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。

这个城市有 $n$ 个车站，编号是 $1-n$，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。

## 说明/提示

### 样例 1 解释

她 $0$ 分钟时上车，在 $3$ 号站下车，立刻坐上（$0$ 分始发）$15$ 分开的车回去，到 $2$ 号车站，立刻坐上（$20$ 分始发）$25$ 开的车到终点，$50$ 分到，还需要等待 $5$ 分钟。

## 样例 #1

### 输入

```
4
55
5 10 15
4
0 5 10 20
4
0 5 10 15
4
18
1 2 3
5
0 3 6 10 12
6
0 3 5 7 12 15
2
30
20
1
20
7
1 3 5 7 11 13 17
0
```

### 输出

```
Case Number 1: 5
Case Number 2: 0
Case Number 3: impossible
```

# 题解

## 作者：_djc_ (赞：15)

这道题似乎还是 ICPC 2003 决赛的题呢，但是过了 20 年现在来看就是一道非常经典的 DP 了。

## 题目分析

既然是做 DP ，我们就应该知道他的几个要素：**阶段、状态、以及状态之间的转移**。

对于这道题来说，其状态是什么呢？我们首先想到的是车站，还有一个就是时间，时间是单向流逝的。我们可以用一个二维数组 $dp_{i,j}$  来表示时间   $i$ 位于车站 $j$ 要在地铁站等几分钟这个状态。

然后是状态转移。最终状态 $dp_{T,N}$ 我们是知道的，它一定等于 0，否则玛丽亚就不能与另一个间谍碰头了。那我们如何将 $dp_{T,N}$ 这个状态转移到  $dp_{0,1}$ 这个状态呢？

对于一个状态，我们只有三种决策：

1. 原地等待一分钟: $dp_{i,j} = dp_{i+1,j} + 1$

2. 如果有向左开的车，我们可以乘搭向左的车: $dp_{i,j} = \min (dp_{i,j}, dp_{{i+t_j},{j+1}})$

3. 如果有向右开的车，我们可以乘搭向右开的车: $dp_{i,j} = \min( dp_{i,j},  dp_{i+t_{j-1},j-1} )$ 

## 一些代码实现

如何判断是否有向左向右开的车呢？输入时预处理即可：

```cpp
	while(M1--){//向右开 
	int d = read(), tm = 0;
	tm = d;
	for(int j = 1; j <= N; j++){
		pd[tm][j][0] = 1;
		tm += t[j];
		}
	}
	int M2 = read();
	while(M2--){//向左开 
		int d = read(), tm = 0;
		tm = d;
		for(int j = N; j >= 1; j--){
			pd[tm][j][1] = 1;
			tm += t[j-1];
		}
	}
```

DP 时可以从后往前递推，其中一些变量名可以到后面的完整代码那去看一下：
```cpp
memset(dp, 0x3f, sizeof(dp));
dp[T][N] = 0;
for(int i = T-1; i >= 0; i--){
	for(int j = 1; j <= N; j++){
		dp[i][j] = dp[i+1][j] + 1;
		if(j < N && pd[i][j][0] && i + t[j] <= T) dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]);//乘搭向右开的车
		if(j > 1 && pd[i][j][1] && i + t[j-1] <= T) dp[i][j] = min(dp[i][j], dp[i + t[j-1]][j-1]);//乘搭向左开的车
		
	}
}
```

最后输出时要按他的格式输出，注意判断是否可能，不可能要输出 ```impossible ``` 。

我们最终要的是 $dp_{0,1}$ 即从 0 时刻在 1 车站在地铁站中暴露多长时间才能与间谍碰头

**完整代码**：

```cpp
#include<bits/stdc++.h>
#define maxn 50005
using namespace std;
inline int read(){
    int x = 0 , f = 1 ; char c = getchar() ;
    while( c < '0' || c > '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; } 
    while( c >= '0' && c <= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; } 
    return x * f ;
} 
int N, T;
int t[80];//从第i个车站到第i+1车站需要多长时间
int pd[2000][75][2];//在i时刻j车站是否有向右或左开的车
int dp[2000][75];
int cnt = 0;
int main(){
	while(N = read()){
		memset(pd, 0, sizeof(pd)), memset(t, 0, sizeof(t));
		T = read();
		for(int i = 1; i < N; i++) t[i] = read();
		int M1 = read();
		while(M1--){//右开 
			int d = read(), tm = 0;
			tm = d;
			for(int j = 1; j <= N; j++){
				pd[tm][j][0] = 1;
				tm += t[j];
			}
		}
		int M2 = read();
		while(M2--){//左开 
			int d = read(), tm = 0;
			tm = d;
			for(int j = N; j >= 1; j--){
				pd[tm][j][1] = 1;
				tm += t[j-1];
			}
		}
		memset(dp, 0x3f, sizeof(dp));//因为是要求最小值，所以将dp初始成极大值
		dp[T][N] = 0;
		for(int i = T-1; i >= 0; i--){
			for(int j = 1; j <= N; j++){
				dp[i][j] = dp[i+1][j] + 1;//等待一分钟，就是在下一刻仍在这个车站
				if(j < N && pd[i][j][0] && i + t[j] <= T) dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]);//乘搭向右开的车
				if(j > 1 && pd[i][j][1] && i + t[j-1] <= T) dp[i][j] = min(dp[i][j], dp[i + t[j-1]][j-1]);//乘搭向左开的车
				
			}
		}
		cout << "Case Number " << ++cnt << ": ";
		if(dp[0][1] >= 0x3f) cout << "impossible" << endl;
		else cout << dp[0][1] << endl;
	}
	
}
```
**完**




---

## 作者：不许雷同 (赞：11)

 _写了好久的一道题， 细心地码了一波题解， 希望管理员大大能够给过_
 
这道题算是一道线性dp， 关键在于对于数据的操作以及细节的处理。

首先，我们要将有关于列车发车时间的数据处理成在在哪一时刻，哪一站会有向哪边开过去的车。如我代码所展示的train[ 2 ][ j ][ i ]; 表示的是在i时刻的
j站有向左或向右（0向右， 1向左)的列车。
如此，就能够很容易地对于枚举的每个时刻 i ， 枚举每个车站来进行状态转移。

状态转移方程在下面的代码中有体现， 各位都知道哪里是状态转移方程， 这里就不讲了。

我的解法是将时刻 i 倒序枚举， 当然可以正序， 只不过在细节上和这个稍有差别。

------------

```
#include <bits/stdc++.h>
#define met(x) memset(x, 0, sizeof(x))
#define T 251
#define N 51
using namespace std;
const int inf = 9999999;
int n, t, m1, m2, d, station[N], f[T][N], num;
bool train[2][N][70 * N * T];
inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	while (!isdigit(ch)){
		if (ch == '-')	w = -1;
		ch = getchar(); 
	}
	while (isdigit(ch))
		s = s * 10 + ch - '0', ch = getchar();
	return s * w;
}
void solve(){
	for (int i = 1; i < n; i++)	f[t][i] = inf;
	for (int i = t - 1; i >= 0; i--)
		for (int j = 1; j <= n; j++){
			f[i][j] = f[i + 1][j] + 1;
			if (j < n && train[0][j][i] && i + station[j] <= t)
				f[i][j] = min(f[i][j], f[i + station[j]][j + 1]);
			if (j > 1 && train[1][j][i] && i + station[j - 1] <= t)
				f[i][j] = min(f[i][j], f[i + station[j - 1]][j - 1]);
		}
	printf("Case Number %d: ", ++num);
	if(f[0][1] < inf)	cout << f[0][1];
	else cout << "impossible";
	cout << endl;
}
int main(){
	while (1){
		n = read();
		if (n == 0)	break;
		t = read(), met(f), met(train);
		for (int i = 1; i < n; i++)
			station[i] = read();
		m1 = read();
		for (int i = 1; i <= m1; i++){
			d = read();
			for (int j = 1; j <= n; j++){
				train[0][j][d] = 1;
				d += station[j];
			}
		}
		m2 = read();
		for (int i = 1; i <= m2; i++){
			d = read();
			for (int j = n; j >= 1; j--){
				train[1][j][d] = 1;
				d += station[j - 1];
			}
		}
		solve();
	}
	return 0;
} 
```

---

## 作者：MusicmanJuly (赞：5)

 _某lch老师教的方法，一看这个方法还没有人发题解……就来试试了。_ 
 
用的是 **建分层图 + 最短路** 的方法。整个解题流程大致就分为这两个模块了。这个办法可能不是最快最优秀的，但它也许是 **最美妙最灵活** 的。

**前置知识：基础图论（图的存储和遍历、最短路概念）、基础数据结构**

自然，前提是你得听懂题意……题目大意即是说有一些地铁站和一些按班次安排停靠各个站的地铁，你要从首站出发在某约定时刻到达末站，最小化 **“在车站等待的时间”** 。也就是说要尽可能地安排多在地铁内的时间，来最小化出地铁在车站等待的时间。

## 一、构造分层图

这个题是可以构造出一个样子很独特的分层图模型的。我们先来考虑一个最简单的输入数据。

```
3
5
1 2
1
1
0

0
```

这是一个有3个站、1次发车的情况，结束时刻为5，加上t=0一共是6个时刻。

#### ① 构建分层图

按照题意，可以构造出一个横坐标为车站编号、纵坐标为时刻的点阵，也就是所谓的分层图。用t代表某个时刻，i代表某个车站编号。（emmm我找不到图床只好看着字符脑补了）

```
   i= 1 2 3
 t= 0 * * *
    1 * * *
    2 * * *
    3 * * *
    4 * * *
    5 * * *
```

将点记作(t, i)的话，起点即是初始时刻首个车站(t=0, i=1)，终点是结束时刻最后一个车站(t=5, i=3)即题意中的(t=T, i=N)。

#### ② 连接表示等待的边

将图上的每对上下相邻的点接一条单方向向下、边权为1的点，代表我们可以在这个时刻、这个车站（即(t, n)）中进行1单位时间的等待而转移到下一时刻的同一车站（即(t+1, n)），代价就是1单位时间的、题目所要最小化的“在车站等待的时间”。

#### ③ 连接地铁的边

我们要发车了！对于每次的地铁，它从给定的时间从首站或末站发出，经过一段时间而经过每个车站。比如上面给出的例子，根据发车时间和运行时段，车的运行轨迹是：

```
(t=1, i=1) -> (t=2, i=2) -> (t=4, i=3)
```

我们也要用单向边按照上面的顺序连接起车途经的点（可以用上面的点阵图脑补一下……）车都会顺着时间往下方开，有的从左到右有的从右到左，不过这些边的 **边权应该是0！** 因为使用地铁进行转移并不是题目所要最小化的“在车站等待的时间”，使用地铁转移是没有代价的。

#### ④ 实现细节：给点编号

有一个细节问题就是如何给这些点编号。因为这是一个二维点阵，而图论要求的点的编号只有一个数字。

那样的话，我们可以使用映射的技巧来把一个表示点阵中点的“数对”(t, i)映射上一个独一无二的点编号。当然，最简单的方法就是用它在点阵中的顺序编号 t*N+i 表示。构造函数Map()来实现映射的计算。我们将映射之后的任意点的编号称为ver。

```cpp
int Map(int t, int i)
{
	return t * N + i;
}
```

这道题很容易搞混t、i、ver的关系。请在打代码时留意。

就这样，我们构建了一个边权只有0和1的分层图。接下来要做的就是跑最短路求(t=0, n=1)到(t=T, i=N)的最短“距离”了。这个“距离”经过上面的建边，已经被定义为“在车站等待的时间”。

## 二、求最短路

其实用Dijkstra、SPFA之类的都可以跑，不过鉴于这是个边权只有0或1的特殊图，我介绍一下正适用于这种情况的 O(N+M) 求单源最短路方法： **01BFS** ，有向图或无向图都可以使用。

01BFS使用的数据结构是 **双向队列** 。见名识人，就是一个可以从两端入队、从两端退队的一维结构。

再来看一个例“图”。

```
[A]--0--[B]--1--[C]--1--[F]
 |
 1
 |
[D]--0--[E]
```

求从A点出发的单源最短路。

① 初始化时入队A点。队列是这样的，入队时顺带记录到达每个点的距离。

```
Head<- A(0)
```

② 将队头A取出，用于研 ~~♂~~ 究。现在的队列如下，空了。

```
Head<-
```

③ 根据图，研究A发现了A连向B和D。A到B的距离是0，因此将B从队头入队；A到D的距离是1，因此将D从队尾入队。现在的队列如下。

```
Head<- B(0) D(1)
```

④ A研究完了。取出队头B进行研究。

```
Head<- D(1)
```
……

```
Head<- D(1) C(1)     // 研究B发现C
Head<- C(1)          // 取出D研究
Head<- E(1) C(1)     // 研究D发现E
Head<- C(1)          // 取出E研究
Head<-               // 取出C研究
Head<- F(2)          // 研究C发现F
Head<-               // 取出F研究
```

好像有点太简单了。不过没关系，根据我下面指出的一些结论可以知道01BFS的一些特点。

1. 点出队的顺序按照最短路长递增。每个点只入队一次，携带的路径长度即为最短路，因而其复杂度是O(N+M)。
2. 01BFS跑起来就像BFS，每层把所有通过"0边"够得着(“连通”)的加到队头来优先访问，通过"1边"延伸（“扩张下一圈”）出去的点加到队尾，访问完所有0边连通的再进入往外通过1边连的下一部分。
3. 因为01BFS是一圈一圈往外爬的，每次队里最多只会有两种最短路长的点，且最短路长相差1。

大概应该看得懂了吧……看不懂评论一下，我改进。

C++ STL的 <queue> 里就有双向队列的数据结构 std::deque 。貌似还挺快，我都是4ms内过的。附赠其常用的函数：

```
q.front() // 访问队头
q.back() // 访问队尾
q.push_front(element) // 从队头入队
q.push_back(element) // 从队尾入队
q.pop_front() // 从队头出队
q.pop_back() // 从队尾出队
q.empty() // 返回是否为空
```


根据这种方式，01BFS实现了单源最短路的寻找。只需要用它跑一次“一、”所构造出的分层图，即可找到答案。

## 三、代码实现

有一些小技巧。不过我不多说了，代码里有注释。

```cpp
#include <cstdio>
#include <queue>
#include <cstdlib>

////// 第一部分 通用、常规

const int NN = 52;
const int TT = 2048;
const int MM = 52;

int N, T, L, R; // L<-M1, R<-M2
int pass[NN]; // 地铁经过区间所需的时间
int left[MM]; // 从左侧出发的时刻表
int right[MM]; // 从右侧出发的时刻表

////// 第二部分 构造分层图

const int VV = NN*TT; // 最大的点数
const int EE = NN*TT*4; // 最大的边数

// 返回对应(t, i)的点编号
int Map(int t, int i)
{
	return t * N + i;
}
/* 逆映射，不过没用上
int RMapT(int ver)
{
	return ver / N;
}

int RMapI(int ver)
{
	return (ver % N == 0) ? N : ver % N;
}
*/
// 这里用的是邻接表
int fstlne[VV], nxtlne[EE], lneto[EE], lnev[EE];
int lneP;

void AddEdge(int u, int v, int w)
{
	++lneP;
	nxtlne[lneP] = fstlne[u];
	lneto[lneP] = v;
	lnev[lneP] = w;
	fstlne[u] = lneP;
}

////// 3. 01BFS

struct State {
	int ver; // 点编号
	int val; // 附带的最短路值
	State() : ver(0), val(0) {}
	State(int ver_, int val_) : ver(ver_), val(val_) {}
};

bool vis[VV]; // 标记已经访问过(入队)的点
int dis[VV]; // 入队时记录最短路
std::deque<State> q;

int main()
{
	int caseNo = 0;
	while (1)
	{
		
		////// 1. 通用、常规
		
		scanf("%d", &N);
		if (N == 0)
			break;
		caseNo++;
		
		scanf("%d", &T);
		for (int i=1; i<=N-1; i++)
			scanf("%d", &pass[i]);
		scanf("%d", &L);
		for (int i=1; i<=L; i++)
			scanf("%d", &left[i]);
		scanf("%d", &R);
		for (int i=1; i<=R; i++)
			scanf("%d", &right[i]);
		
		////// 2. 构造分层图
		
		// 初始化
		lneP = 0;
		for (int t=0; t<=T; t++)
			for (int i=1; i<=N; i++)
				fstlne[Map(t, i)] = 0;
		
		// 连接表示等待的边
		for (int t=0; t<=T-1; t++)
			for (int i=1; i<=N; i++)
				AddEdge(Map(t, i), Map(t+1, i), 1);
		
		// 连接地铁经过的边，其实就是模拟开车经过哪里
		for (int k=1; k<=L; k++)
		{
			int t = left[k];
			// 注意 t+pass[i]<=T，它避免地铁开出时间范围变得多余。
			for (int i=1; i<=N-1 && t+pass[i]<=T; i++)
			{
				AddEdge(Map(t, i), Map(t+pass[i], i+1), 0);
				t += pass[i];
			}
		}
		for (int k=1; k<=R; k++)
		{
			int t = right[k];
			for (int i=N-1; i>0 && t+pass[i]<=T; i--)
			{
				AddEdge(Map(t, i+1), Map(t+pass[i], i), 0);
				t += pass[i];
			}
		}
		
		////// 3. 01BFS
		
		// 初始化
		while (!q.empty())
			q.pop_front();
		for (int i=1; i<=N*(T+1); i++)
			vis[i] = false;
		q.push_front(State(Map(0, 1), 0));
		vis[Map(0, 1)] = true;
		dis[Map(0, 1)] = 0;
		
		// 跑最短路，一旦(T, N)入队了马上可以完结
		while (!q.empty() && !vis[Map(T, N)])
		{
			State now = q.front();
			q.pop_front();
		//	printf("Get %d<%d,%d>,%d\n",
		//		now.ver, RMapT(now.ver), RMapI(now.ver), now.val);
			
			for (int e=fstlne[now.ver]; e; e=nxtlne[e])
			{
				if (!vis[lneto[e]])
				{
				//	printf("  Detect %d<%d,%d>,%d\n",
				//		lneto[e], RMapT(lneto[e]), RMapI(lneto[e]), now.val + lnev[e]);
					if (lnev[e] == 0)
						q.push_front(State(lneto[e], now.val + 0));
					else
						q.push_back(State(lneto[e], now.val + 1));
					vis[lneto[e]] = true;
					dis[lneto[e]] = now.val + lnev[e];
				}
			}
		}
		
		// 输出
		printf("Case Number %d: ", caseNo);
		if (vis[Map(T, N)])
			printf("%d\n", dis[Map(T, N)]);
		else
			puts("impossible");
	}
	
	return 0;
}

```

这道题一个“优美”的地方是它数据分组。这样的话你必须把你能想到的需要重新初始化的数组初始化（我就调了半天）。

以上，结束。


---

## 作者：circlegg (赞：3)

这个题不知道为什么就是 提高+/省选- 的题，感觉相对比较水，数据也小，搜索也能A吧，这里讲dp做法

首先定义状态，就是时间和地点，用 f[i][j] 表示在 i 时， j 车站的最少等待时间

转移方式最多有三种：

1、从上一秒转移 f[i][j]=min(f[i][j],f[i-1][j]);

2、有属于 M1 的车到站了 f[i][j]=min(f[i][j],f[i- 上一站到这一站的时间 ][j-1]);

3、有属于 M2 的车到站了 f[i][j]=min(f[i][j],f[i- 下一站到这一站的时间 ][j+1]);

然后就可以转移了

复杂度 O(N\*T)

···
    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,p,t[55],m1,t1[55],m2,t2[55];
int f[205][55];//在i时，第j个车站等待的时间 
bool vis[205][55][2];//在 i 时,第 j 个车站是否有车从 k 方向来 
void init(){
    memset(f,127,sizeof(f));
    memset(vis,0,sizeof(vis));
    memset(t,0,sizeof(t));
    memset(t1,0,sizeof(t1));
    memset(t2,0,sizeof(t2));
}    
void work(int num){
    int tmp;
    for(int i=1;i<=m1;i++){
        tmp=t1[i];
        for(int j=1;j<=n&&tmp<=p;j++){
            vis[tmp][j][0]=1;
            tmp+=t[j];
        }
    }
    for(int i=1;i<=m2;i++){
        tmp=t2[i];
        for(int j=n;j>=1&&tmp<=p;j--){
            vis[tmp][j][1]=1;
            tmp+=t[j-1];
        }
    }
    f[0][1]=0;
    for(int i=1;i<=p;i++){
        for(int j=1;j<=n;j++){
            f[i][j]=min(f[i][j],f[i-1][j]+1);
            if(vis[i][j][0]==1){
                f[i][j]=min(f[i][j],f[i-t[j-1]][j-1]);
            }
            if(vis[i][j][1]==1){
                f[i][j]=min(f[i][j],f[i-t[j]][j+1]);
            }
        }
    }
    if(f[p][n]<=p){
        printf("Case Number %d: %d\n",num,f[p][n]);
    }
    else{
        printf("Case Number %d: impossible\n",num);
    }
}
int main(){
    int num=1;
    scanf("%d",&n);
    while(n!=0){
        init();
        scanf("%d",&p);
        for(int i=1;i<=n-1;i++){
            scanf("%d",&t[i]);
        }
        scanf("%d",&m1);
        for(int i=1;i<=m1;i++){
            scanf("%d",&t1[i]);
        }
        scanf("%d",&m2);
        for(int i=1;i<=m2;i++){
            scanf("%d",&t2[i]);
        }
        work(num++);
        scanf("%d",&n);
    }
}
```
···

---

## 作者：da_ke (赞：2)

# 前言

> 阅读时间大约 $5\ \text{min}$，思考时间大约 $15\ \text{min}$

题目原来是 ICPC 的题目，现在已经成了动态规划的经典例题，又称时空 DP。

# 问题解决

- 动态规划 1

- 动态规划 2

## 动态规划 1

### 读入与建图

读入较为复杂，我们在读入

>- 第 $4$ 行一个整数 $M_1\ (1 \le M_1 \le 50)$ 表示离开第一个车站的火车的数量。
>- 第 $5$ 行 $M_1$ 个正整数 $d_1,d_2,\cdots,d_n\ (0 \le d \le 250$，$d_i<d_i+1)$ 表示每一列火车离开第一站的时间。
>- 第 $6$ 行一个正整数 $M_2\ (1 \le M_2 \le 50)$ 表示离开第 $N$ 站的火车的数量。
>- 第 $7$ 行 $M_2$ 个正整数：$e_1,e_2\cdots e_{M_2}\ (0 \le e \le 250$，$e_i<e_i+1)$ 表示每一列火车离开第 $N$ 站的时间。

时预处理地铁之间的关系：

定义 $f(t,i,0)$：第 $t$ 个时间单位在车站 $i$ 是否有一个向右的车；$f(t,i,1)$：第 $t$ 个时间单位在车站 $i$ 是否有一个向左的车。

预处理时时间采用线性递推，有

$$f(d_i+ \sum ^{k-1}_{j=1}t_j,k,0)=1\ (k \in [1,n-1])$$

反向同理。

注：这里的 $f(t,i,\{1,0\})$ 即代码中的 `linker[t][i][flag]`，其中 `flag` 为布尔值，含义与上文相符。


读入参考代码
```cpp
		cin>>m1;
        rep(i,1,m1){ //right
            cin>>tmp;
            timesum=tmp;
            for(int j=1;j<=n;j++)
                linker[timesum][j][0]=1,
                timesum+=t[j];
        }
        cin>>m2;
        rep(i,1,m2){ //left
            cin>>tmp;
            timesum=tmp;
            for(int j=n;j>=1;j--)
                linker[timesum][j][1]=1,
                timesum+=t[j-1];
        }
```

### 设计状态

不难发现，不管在什么时候都有以下几点决策：

1. 等待 $1$ 单位时间
2. 找向右的车搭乘
3. 找向左的车搭乘

但是什么会影响状态呢？

不难发现，要通过 `linker` 找到下一个车，必须知道 **时间** 和 **位置**。

仔细思考，时间和位置都 **必须** 记入状态，即记忆化数组。

### 提示（边界处理）

边界处理在记忆化中较简单，可以判断是否出界。

### 代码

这里，暴力就不放了。要看是怎么从暴力到 DP 的看一下 P1048。

DP 核心参考代码
```cpp
bool linker[10024][123][3],vis[10024][123];
int mem[10024][123];

int dfs(int d,int i){ //d是时间,i是车站位置
    if(d>T||i>T) return INF;
    if(d==T&&i==n){
        vis[d][i]=1;
        return mem[d][i]=0; //无需等候
    }
    if(vis[d][i]) return mem[d][i];
    mem[d][i]=dfs(d+1,i)+1;
    if(linker[d][i][0])
        mem[d][i]=min(mem[d][i],dfs(d+t[i],i+1));
    if(linker[d][i][1])
        mem[d][i]=min(mem[d][i],dfs(d+t[i-1],i-1));
    vis[d][i]=1;
    return mem[d][i];
}
```

这里用了 `vis` 数组记录了是否访问。代码更有可读性，qwq。

AC 参考代码
```cpp
#include <bits/stdc++.h>

using namespace std;

#define rep(i,l,r) for(int i=l;i<=r;i++)
const int INF = 1 << 30;
const long long INFL = 1LL << 60;

int n,T,m1,m2;
int t[100];
bool linker[10024][123][3],vis[10024][123]; //邻接矩阵
int mem[10024][123];

int dfs(int d,int i){ //d是时间,i是车站位置
    if(d>T||i>T) return INF;
    if(d==T&&i==n){
        vis[d][i]=1;
        return mem[d][i]=0; //无需等候
    }
    if(vis[d][i]) return mem[d][i];
    mem[d][i]=dfs(d+1,i)+1;
    if(linker[d][i][0])
        mem[d][i]=min(mem[d][i],dfs(d+t[i],i+1));
    if(linker[d][i][1])
        mem[d][i]=min(mem[d][i],dfs(d+t[i-1],i-1));
    vis[d][i]=1;
    return mem[d][i];
}

signed main(){
    ios::sync_with_stdio(false);
    int kase=0;
    while(cin>>n){
        if(n==0) break;
        ++kase;
        memset(t,0,sizeof(t));
        memset(mem,INF,sizeof(mem));
        memset(linker,0,sizeof(linker));
        memset(vis,0,sizeof(vis));
        int tmp,timesum;
        cin>>T;
        rep(i,1,n-1)
            cin>>t[i];
        cin>>m1;
        rep(i,1,m1){ //right
            cin>>tmp;
            timesum=tmp;
            for(int j=1;j<=n;j++) //建图
                linker[timesum][j][0]=1,
                timesum+=t[j];
        }
        cin>>m2;
        rep(i,1,m2){ //left
            cin>>tmp;
            timesum=tmp;
            for(int j=n;j>=1;j--) //建图
                linker[timesum][j][1]=1,
                timesum+=t[j-1];
        }
        int ans=dfs(0,1);
        cout<<"Case Number "<<kase<<": ";
        if(ans>=INF){
            cout<<"impossible"<<endl;
            continue;
        }
        cout<<ans<<endl;
    }
}
```

## 动态规划 2

想法与「动态规划 1」如出一辙，这里展示紫书的参考代码：

```cpp
for(int i = 1; i <= n-1; i++) dp[T][i] = INF;
dp[T][n] = 0;
for(int i = T-1; i >= 0; i--)
	for(int j = 1; j >= n; j++) {
	dp[i][j] = dp[i＋1][j] + 1; //等待一个单位
	if(j < n && has_train[i][j][0] && i+t[j] <= T)
		dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); //右
	if(j > 1 && has_train[i][j][1] && i+t[j-1] ＜= T)
		dp[i][j] = min(dp[i][j], dp[i+t[j-1]][j-1]); //左
}
//输出
cout << "Case Number " << ++kase << ": ";
if(dp[0][1] >= INF) cout << "impossible\n";
else cout << dp[0][1] << "\n";
```

# 后记

### 参考资料

- 刘汝佳《算法竞赛入门经典》

### 编辑历史

upd 2023/07/21 开始编辑，[首版](https://www.luogu.com.cn/blog/coding-wa/dag-di-dong-tai-gui-hua)

upd 2023/11/11 精简无意义内容与闲话，注重解法本身，增加解法。

---

## 作者：rsdbk_husky (赞：2)

## 零. 安利：

[安利一下我的博客。](https://rsdbkhusky.github.io/)

## 一. 思路

#### 1. 思考解法

- **时间** 是个好的 DP 阶段，时间轴上靠后发生的不会影响前面的事，反映到本题上就是 Maria 之后怎么走不会影响现在的最优解，**符合无后效性**。

- Maria 既可以乘向东的地铁，又可以乘向西的地铁，还可以呆着不动。那么一种情况可以由多种情况而来，多种情况也可以发展成一种情况，各种情况互相交织，**符合子问题重叠性**。

所以考虑 DP。

#### 2. 前缀和初始化

   题目给出了站的时间间距和每列地铁发车时的时间（只会从首末两站发车），事实上，地铁在前进中到达每站的时间就是个前缀和 ~~（偷偷点开标签我们也可以看到前缀和）~~，到达某站的时间就是前面所有站时间间距之和，当然还要加上发车时间。

#### 3. DP

我采用的是 **刷表法**，当然，**填表法** 也可以。

1. 所需条件：

    - $stabet_i$：站 $i-1$ 与站 $i$ 间相隔的时间。

    - $canright_{i,j}(canleft_{i,j})$：$i$ 时刻 $j$ 站是否有开向末站（首站）的火车。

    - $d_{i,j}$：得到 $i$ 时刻在 $j$ 站这种状态最少的停留时间。

通过前缀和我们已经得到 $canright$ 以及$canleft$ 数组。接下来就是状态转移了。

2. 初始状态：

易得，应初始化为： $d_{i,j}=\begin{cases}0~~~~~~~~~(i=0~\land~j=1)\\\infty~~~~~~~(else)       \end{cases}$

其中 $\infty$ 代表无法到达。
    
3. 状态转移：

因为本题的阶段之间不像普通的0/1背包那样只会由上一阶段转移到，而是也会由很多个单位时间之前的阶段转移到（站与站之间的时间不止1），所以我选择多维数组而非滚动数组。
	
首先，无论此刻此站有没有地铁，都可以在本站等待，这是普遍的转移；另外，如果此刻此站恰好有地铁，可以做特殊的转移。

**综上所述，状转方程**：（因为是刷表法，状转方程不方便写在一个括号里，蒟蒻就这么写了 qwq）

（$\operatorname{self}$ 代表自己）

$d_{i,j}=\min(\operatorname{self},~d_{i-1,j}+1)~~~~~~~~~~~~(i>0)$

$d_{i+stabet_{j+1},j+1}=\min(\operatorname{self},~d_{i,j})~~~~~~(canright_{i,j}=true)$

$d_{i+stabet_j,j-1}=\min(\operatorname{self},~d_{i,j})~~~~~~~~(canleft_{i,j}=true)$

4. 结果状态：

$d_{T,n}$

## 二. 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXn = 50;
const int MAXT = 2000;
const int INF = 0x3f3f3f3f;

template <class T> 
inline void read(T &a) {
    register char c;while (c = getchar(), c < '0' || c > '9');register T x(c - '0');while (c = getchar(), c >= '0' && c <= '9')x = (x << 1) + (x << 3) + c - '0';a = x;  
}

int n, T, stabet[MAXn + 10], rightcnt, leftcnt;	
bool canright[MAXT + 10][MAXn + 10], canleft[MAXT + 10][MAXn + 10];	 
int d[MAXT + 10][MAXn + 10];										

int main() {
	int k = 0;
	read(n);
	while (n) {
		++k;
		memset(canright, 0, sizeof(canright));	// 
		memset(canleft, 0, sizeof(canleft));	//多组数据要初始化
		memset(d, 0x3f, sizeof(d));				//
		read(T);
		for (int i = 2; i <= n; ++i) {
			read(stabet[i]);
		}
		int time;								//
		read(rightcnt);							//
		for (int i = 1; i <= rightcnt; ++i) {	// 
			read(time);							//
			canright[time][1] = 1;				//
			for (int j = 2; j <= n; ++j) {		//
				time += stabet[j];				//
				canright[time][j] = 1;			//
			}									//
		}										//边读入边用前缀和计算canright和canleft数组
		read(leftcnt);							//
		for (int i = 1; i <= leftcnt; ++i) {	//
			read(time);							//
			canleft[time][n] = 1;				//
			for (int j = n - 1; j >= 1; --j) {	//
				time += stabet[j + 1];			//
				canleft[time][j] = 1;			//
			}									//
		}										//
		d[0][1] = 0;
		for (int i = 0; i <= T; ++i) {												//
			for (int j = 1; j <= n; ++j) {											//
				if (i)																//
					d[i][j] = min(d[i][j], 											//
								  d[i - 1][j] + 1);									//
				if (canright[i][j])													//
					d[i + stabet[j + 1]][j + 1] = min(d[i + stabet[j + 1]][j + 1], 	//动态规划 
													  d[i][j]					  );//
				if (canleft[i][j])													//
					d[i + stabet[j]][j - 1] = min(d[i + stabet[j]][j - 1], 			//
												  d[i][j]				  );		//
			}																		//
		}																			//
		if (d[T][n] == INF) {
			printf("Case Number %d: impossible\n", k);
		} else {
			printf("Case Number %d: %d\n", k, d[T][n]);
		}
		read(n);	
	}	
}
```

---

## 作者：焰火俊俊 (赞：2)

我看题解都是用的动态规划解决这道题的，所以在这里
# **提供一种不用动态规划的简单新的解题思路！对dp头疼的孩子可以看这里。。**
而这种方法是使用**图论**的思想解决此类问题

**我们先解决点的问题**

我们把他的每一个状态作为一个图中的一个节点，而状态则有**时间和空间**的区别；举个例子，当他在时间0在一号车站，为一号点，在时间1在一号车站则为二号点，而当他在时间x在n号车站，为n*（T+1）+x号点；

**那么我们点的问题就解决了，下面解决边的问题**

我们会发现，如果将要求的“等待时间”作为图中的边权，那么**状态时间以及空间**（点）的转移只有三种情况：

1.在原地等待，时间+1,因为该时间等待，**所以边权为1
边权为0**；

2.坐正向车走，空间+1，时间+在车上的时间，因为该时间在车上，所以不算等待时间，**所以边权为1
边权为0**；

3.坐反向车，空间-1，其他同理正向车；

**这样我们图就建立完成了，现在解决怎样求答案的问题**

我们发现如果把要求的等待时间作为边权，那么我们从0时间1站点的节点跑到t时间n站点的图论最短路不就是最终的答案嘛？

但是这里要注意一个问题，就是如果跑spfa或者dj复杂度会明显高于dp复杂度，因为节点会反复进出来更新，**显然这并不是最优的做法**，所以我们在这里引入
**“01bfs”的最短路做法；**

01bfs是用来解决图里边权只有1或0的复杂度低的做法；
我们发现我们所建图的边权也就是等待时间只有0或1，所以我们可以用01bfs解决；

现在讲解一下01bfs：对于边权只有0或1的图，我们从起点开始找，普通bfs之所以不行的原因是你可能先通过边权为1的边找到了该节点标出vis=1；
但是事实上可能有边权为0的边也可以通向该点只不过后扫到这条边，所以我们用双端队列，是0就从高前面加，1在后面加，就可以保证先扫0的边，从而保证正确性；

最后输出最短路即可；

**注意：该图论做法因为用01bfs求的，每个边和点只扫了一次，复杂度O（m+n）的，所以他的本质就是dp，只不过并不需要dp式子推导转移，二者时间复杂度相差不大**

代码过程中可能有坑，我会尽量备注，还有不懂的可以私聊问我
上代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<deque>
using namespace std;
deque <int> deq;//双端队列
int n,t,a[70],m1,m2,fir[100010],cnt,ans,ji,d[100010],vis[100010],sum1[100010],sum2[100010];
struct ren{
	int e,nexty,w;
}bian[100000000];
void addedge(int ss,int ee,int ww){
	cnt++;
	bian[cnt].e=ee;
	bian[cnt].nexty=fir[ss];
	bian[cnt].w=ww;
	fir[ss]=cnt;
}
void bfs(int u){//01bfs
	deq.clear();//每次清空队列
	memset(d,0,sizeof(d));
	memset(vis,0,sizeof(vis));
	deq.push_front(u);
	vis[u]=1;
	while(deq.size()!=0){
		int p=deq.front();
		deq.pop_front();
		for(int x=fir[p];x;x=bian[x].nexty){
			int en=bian[x].e;
			if(vis[en]==0){
				vis[en]=1;//标记
				d[en]=d[p]+bian[x].w;
				if(en==(n-1)*(t+1)+t+1){ans=d[en];break;}
                //如果搜到终点直接退出
				if(bian[x].w==0)deq.push_front(en);
                //边权为0放在前面；
				else deq.push_back(en);
			}
		}
		if(ans!=3000)break;
	}
}
int main(){
	while(1){//输入
		cin>>n;
		if(n==0)break;
		ji++;cnt=0;ans=3000;
		memset(sum1,0,sizeof(sum1));
		memset(sum2,0,sizeof(sum2));
		memset(fir,0,sizeof(fir));
		cin>>t;
		for(int i=1;i<n;i++)cin>>a[i];
		for(int i=1;i<n;i++)sum1[i]=sum1[i-1]+a[i];
        //记录从起点出发到每一个站点的总时间
		for(int i=n-1;i>=1;i--)sum2[i]=sum2[i+1]+a[i];
		cin>>m1;
		for(int i=1;i<=m1;i++){
			int sta;
			cin>>sta;
			sta=sta+1;
			for(int j=0;j<n-1;j++)
			if(sta+sum1[j+1]<=t+1)
			addedge(j*(t+1)+sta+sum1[j],(j+1)*(t+1)+sta+sum1[j+1],0);	
            //加入正向走的边
		}
		cin>>m2;
		for(int i=1;i<=m2;i++){
			int sta;
			cin>>sta;
			sta+=1;
			for(int j=n-1;j>=1;j--)
			if(sta+sum2[j]<=t+1)
			addedge(j*(t+1)+sta+sum2[j+1],(j-1)*(t+1)+sta+sum2[j],0);
            //加入反向走的边
		}
		for(int i=0;i<n;i++)
		    for(int j=1;j<=t;j++)
		    addedge(i*(t+1)+j,i*(t+1)+j+1,1);
            //加入原地等待的边
		bfs(1);
		if(ans!=3000)cout<<"Case Number "<<ji<<": "<<ans<<endl;
		else cout<<"Case Number "<<ji<<": "<<"impossible"<<endl;
	}
	return 0;
}
```


---

## 作者：GK0328 (赞：2)

我来发一个Pascal题解吧。。。

这道题其实和UVA1025 A Spy in the Metro是同一道题，可以用动态规划来解决。

由于DP方程是蒟蒻自己想出来的，所以比大佬们难看一些。

状态是二维的，f[i][j]表示在第i时刻到达第j个车站所需要等待的最短时间。

状态转移方程：

只对向回开的车进行考虑，先求出最早到达本站的车，这样才能使等待的时间尽可能得少，蒟蒻用了一重循环。。。

设等待时间为tot。

然后枚举下一次开往哪一站，开往第k站到达的时间为i+tot+time[k]-time[j].

f[i+tot+time[k]-time[j]][k]:=min(f[i+tot+time[k]-time[j]][k],f[i][j]+tot); （1<=k<j）

向终点开的车也是如此：

f[i+tot+time[k]-time[j]][k]:=min(f[i+tot+time[k]-time[j]][k],f[i][j]+tot); (j<k<=n)

大功告成啦。

Pascal Code：

```cpp
uses math;//调用数学库
var
  f:array[0..505,0..505]of int64;
  a,b:array[0..505]of longint;
  time:array[0..505]of longint;
  n,m,i,j,k,g_o,come,o,x:longint;
  inf,tot,ans:int64;
begin
  inf:=1000000007;
  repeat
    readln(n);
    if n=0 then
      exit;
    inc(o);
    readln(m);
    for i:=2 to n do
    begin
      read(x);
      time[i]:=time[i-1]+x;//前缀和
    end;
    readln;
    readln(g_o);
    for i:=1 to g_o do
      read(a[i]);
    readln;
    readln(come);
    for i:=1 to come do
      read(b[i]);
    readln;
    for i:=0 to m do
      for j:=0 to n do
        f[i][j]:=inf;
    f[0][1]:=0;//初始化
    for i:=0 to m do
      for j:=1 to n do
      begin
        if f[i][j]=inf then//若f[i][j]不存在，以下都是无意义的
          continue;
        tot:=inf;
        for k:=1 to come do
        begin
          if i>b[k]+time[n]-time[j] then
            continue;
          tot:=min(tot,b[k]+time[n]-time[j]-i);
        end;//计算tot
        if tot<>inf then
        begin
          for k:=j-1 downto 1 do
            if i+tot+time[j]-time[k]<=m then
              f[i+tot+time[j]-time[k]][k]:=min(f[i+tot+time[j]-time[k]][k],f[i][j]+tot);//向回开
        end;
        tot:=inf;
        for k:=1 to g_o do
        begin
          if i>a[k]+time[j] then
            continue;
          tot:=min(tot,a[k]+time[j]-i);
        end;
        if tot<>inf then
        begin
          for k:=j+1 to n do
            if i+tot+time[k]-time[j]<=m then
              f[i+tot+time[k]-time[j]][k]:=min(f[i+tot+time[k]-time[j]][k],f[i][j]+tot);//向终点开
        end;
      end;
    ans:=inf;
    for i:=0 to m do
      ans:=min(ans,f[i][n]+m-i);//选择最优方案
    if ans=inf then
      writeln('Case Number ',o,': impossible') else
      writeln('Case Number ',o,': ',ans);
  until false;
end.
```

---

## 作者：SymphonyOfEuler (赞：1)

这道题是DAG上DP。

我们用dp的第一维表示现在在哪个车站，第二维表示现在几点。再定一个hTrain数组第一维表示在这个时刻，第二维表示在哪个车站，然后第三维是有没有向左右开的。还有一个t数组表示从i站到下一站需要的时间。

所以这整个问题变成了一个二维的问题：当前时间和现在所在的车站。

预处理时候对于m1，输入进来$d_i$从1循环到n枚举车站j，如果d大于了碰头时刻，那么直接跳出，否则把d时刻，j车站，往右开的车标为true，然后d加这个车站花费的时间。对于m2，输入进来$e_i$从n循环到1枚举车站j，如果e大于了碰头时刻，那么直接跳出，否则把e时刻，j车站，往左开的车标为true，然后e加这个车站花费的时间。把dp数组开始初始化一个时间节点，若到了，就不行，后面判断方便。并且初始化最后终点不许等待

这样枚举时间和车站，第一种策略是站着不动，于是$dp[i][j]=dp[i+1][j]+1$。然后对于向右和向左分别需要判断在范围之内，并且有火车，然后自己和这个车站加上跑了$ti[j]$步和下一个时间阶段取min。左面同理，判断完条件之后自己和车站加$ti[j-1]$还有前一个时间段取min。最后判断如果$dp[0][1]$位上比初始化的大，那么肯定不可能，则输出impossible，否则输出$dp[0][1]$。


借助注释：

```

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int ti[55], hTrain[2005][55][2];
int dp[2005][55];

int kase;

int main() {
    int n, t;
    while (true) {
        cin >> n >> t;
        kase++;
        memset(hTrain, 0, sizeof(hTrain));//必须清零
        if (n == 0) break;
        for (int i = 1; i <= n - 1; ++i) {
            cin >> ti[i];
        }
        int m1;
        cin >> m1;
        for (int i = 0; i < m1; ++i) {//预处理向右
            int d;
            cin >> d;
            for (int j = 1; j <= n; ++j) {
                if (d > t) {
                    break;
                }
                hTrain[d][j][0] = 1;
                d += ti[j];
            }
        }
        int m2;
        cin >> m2;
        for (int i = 0; i < m2; ++i) {//预处理向左
            int e;
            cin >> e;
            for (int j = n; j >= 1; --j) {
                if (e > t) {
                    break;
                }
                hTrain[e][j][1] = 1;
                e += ti[j - 1];
            }
        }
        for (int j = 0; j < n; ++j) {//初始化dp数组
            dp[t][j] = 5000;
        }
        dp[t][n] = 0;
        for (int i = t - 1; i >= 0; --i) {//time
            for (int j = 1; j <= n; ++j) { //which station
                dp[i][j] = dp[i + 1][j] + 1;
                if (j < n && i + ti[j] <= t && hTrain[i][j][0]) { //right
                    dp[i][j] = min(dp[i][j], dp[i + ti[j]][j + 1]);
                }
                if (j > 1 && i + ti[j - 1] <= t && hTrain[i][j][1]) { //left
                    dp[i][j] = min(dp[i][j], dp[i + ti[j - 1]][j - 1]);
                }
            }
        }
        if (dp[0][1] >= 5000) {//判断
            printf("Case Number %d: impossible\n", kase);
        } else {
            printf("Case Number %d: %d\n", kase, dp[0][1]);
        }
    }
    return 0;
}
```


---

## 作者：Dispwnl (赞：1)

数据贼小。。。xjb搜也能A吧。。。

用f存时间为i时到第j个车站最小等待时间

所以f[i][j]=min{f[i-1][j]（上1s也在车站j等）,f[i-pass[j-1]][j-1]（从上一个车站乘向前的车来的）,f[i-pass[j]][j+1]（从下一个车站乘向后的车来的）}

如果f[t][n]<=t输出f[t][n]

否则输出impossible

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
using namespace std;
int n,t,m1,m2,tot;
int pass[51],d1[51],d2[51];
int f[201][51];
bool use[201][51][2];
int main()
{
    while(cin>>n&&n)
    {
        memset(use,0,sizeof(use));
        memset(f,1,sizeof(f));
        memset(pass,0,sizeof(pass));//记得pass清0，不然转移j-1可能出错
        f[0][1]=0;
        cin>>t;
        for(int i=1;i<n;i++)
          cin>>pass[i];
        cin>>m1;
        int sum=0;
        for(int i=1;i<=m1;i++)
          {
              cin>>d1[i];
              sum+=d1[i];
              for(int j=1;j<=n;j++)
                if(sum<=t)
              {
                    use[sum][j][0]=1;//即在第sum秒第j个车站有向前的车经过
                    sum+=pass[j];
              }
              else break;
              sum=0;
          }
        cin>>m2;
        for(int i=1;i<=m2;i++)
          {
              cin>>d2[i];
              sum+=d2[i];
            for(int j=n;j>=1;j--)
              if(sum<=t)
              {
                  use[sum][j][1]=1;//即在第sum秒第j个车站有向后的车经过
                  sum+=pass[j-1];
              }
              else break;
              sum=0;
          }
        for(int i=1;i<=t;i++)
          for(int j=1;j<=n;j++)
            {
                f[i][j]=min(f[i][j],f[i-1][j]+1);
                if(use[i][j][0])
                f[i][j]=min(f[i][j],f[i-pass[j-1]][j-1]);
                if(use[i][j][1])
                f[i][j]=min(f[i][j],f[i-pass[j]][j+1]);
            }
        cout<<"Case Number "<<++tot<<": ";
        if(f[t][n]<=t) cout<<f[t][n]<<endl;
        else cout<<"impossible"<<endl;
    }
    return 0;
}
```

---

## 作者：Boxxxxxx (赞：1)

这道题是在我还在很小白的时候看见，刘佳汝的书看见的，那时候看见还以为特别难，现在做多了DP看来其实也蛮水了，首先，一般做dp都是看哪个数据范围小一点就可以考虑从哪里开始设计状态。虽然这题都挺小的
题目里面出现一个数据就是时间，时间是一个天然的线性序，可以十分简单的利用时间去完成线性转移，我们再来看一看他要要求的什么，T时间后在车站n的最少等待时间，在普通的DP（不是那种特别骚气的要搞你的），都是可以从题目入手入设计状态。我们可以这么设计f[i][j]，表示第i秒的时候你人在第j站所等待的最少时间，其实我一开始在设计这个状态的时候想着，在车上移动去下一站的时候怎么表示状态？后来考虑下，其实完全不用去表示在车上的状态，我就只表示他到达了车站那个时候的状态（说话莫名的硬气）！！为什么可以不表示？因为我可以从一个状态推出另一个状态，也就是从f[i][j]直接推出f[k][z]，kz是新的时间，新的车站，这样就完全不用表示车在路上的状态了（从现在推向未来）。
接下来考虑f[i][j]怎么向未来转移。

    (1)等待一分钟啥事不干，为什么是一分钟，因为你等任意分钟都可以由一分钟推出来！！
    (2)这个时候有走向左边的车车，我们上车。
    (3)这个时候有走向右边的车车，我们上车。

知道怎么转移了实际上也就只剩下最后一个问题了， 我们怎么知道这个时间，这个车站有车（不管有多少辆，我只要有一辆就行）？我是选择看他数据有点小，就暴力的开两个二维数组 toleft[i][j]和toright[i][j],他们为1就表示i时间的j站有一个车车。怎么求出这个bool类型的二维数组，在读入车车的时候吧每辆车走完全程路过每个站的时间暴力求出来记录就可以了，真的十分暴力。。。
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<time.h>
#include<string>
#include<cmath>
#include <ctime>
#include<bitset>
#include <cctype>
#define debug cout<<"*********degug**********";
#define signed long long
#define RE register
#define yn yn_
using namespace std;
const long long max_ = 10000 + 7;
const int mod = 1e9 + 9;
const int inf = 1e9;
const long long INF = 1e18;
int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * f;
}
inline int min(int a, int b) {
	return a < b ? a : b;
}
inline int max(int a, int b) {
	return a > b ? a : b;
}
int n, T,toleft[max_][100], toright[max_][100],f[max_][100],se[max_],rstar[max_],lstar[max_],rn,ln;
int main() {
	for(int flag = 1; 1;flag++){
		cin >> n;
		if (n == 0)break;
		T = read();
		for (int i = 1; i < n; i++) {
			se[i] = read();
		}
		memset(toright, 0, sizeof(toright));
		memset(toleft, 0, sizeof(toleft));
		rn = read();
		for (int i = 1; i <= rn; i++) {
			rstar[i] = read();
			int t = rstar[i]; toright[t][1] = 1;
			for (int j = 1; j < n; j++) {
				toright[t + se[j]][j + 1] = 1;
				t = t + se[j];
			}
		}
		ln = read();
		for (int i = 1; i <= ln; i++) {
			lstar[i] = read();
			int t = lstar[i];
			toleft[t][n] = 1;
			for (int j = n -  1; j >= 1 ; j--) {
				toleft[t + se[j]][j] = 1;
				t = t + se[j];
			}
		}
		memset(f, 123, sizeof(f));
		f[0][1] = 0;
		for (int i = 0; i < T; i++) {
			for (int j = 1; j <= n; j++) {
				//F[I][J], 在第i秒时人在第j站，所等待的最少时间
				//等一分钟
				f[i + 1][j] = min(f[i + 1][j], f[i][j] + 1);
				//坐上向右
				if (toright[i][j] && j != n) {
					f[i + se[j]][j + 1] = min(f[i + se[j]][j + 1], f[i][j]);
				}
				//坐上向左
				if (toleft[i][j] && j != 1) {
					f[i + se[j - 1]][j - 1] = min(f[i + se[j - 1]][j - 1], f[i][j]);
				}
			}
		}
		if (f[T][n] > T) {
			printf("Case Number %d: impossible\n", flag);
		}
		else {
			printf("Case Number %d: %d\n", flag, f[T][n]);
		}
		
	
	}
	return 0;
}
```


---

## 作者：猪脑子 (赞：1)

**题目描述**

特工玛利亚被送到S市执行一个特别危险的任务。她需要利用地铁完成他的任务，S市的地铁只有一条线路运行，所以并不复杂。

玛利亚有一个任务，现在的时间为0，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。

玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。

这个城市有n个车站，编号是1-n，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。

**输入输出格式**

输入格式：
输入文件包含多组数据，每组数据都由7行组成

第1行：一个正整数N（2<=N<=50）表示站的数量

第2行：一个正整数T（0<=T<=200）表示需要的碰头时间

第3行：1-（n-1）个正整数（0<ti<70）表示两站之间列车的通过时间

第4行：一个整数M1（1<=M1<=50）表示离开第一个车站的火车的数量

第5行：M1个正整数：d1，d2……dn，（0<=d<=250且di<di+1）表示每一列火车离开第一站的时间

第6行：一个正整数M2（1<=M2<=50）表示离开第N站的火车的数量

第7行：M2个正整数：e1,e2……eM2,(0<=e<=250且ei<ei+1)表示每一列火车离开第N站的时间

最后一行有一个整数0。

输出格式：
对于每个测试案例，打印一行“Case Number N: ”（N从1开始）和一个整数表示总等待的最短时间或者一个单词“impossible”如果玛丽亚不可能做到。按照样例的输出格式。

**输入输出样例**

输入样例:

	4
	55
	5 10 15
	4
	0 5 10 20
	4
	0 5 10 15
	4
	18
	1 2 3
	5
	0 3 6 10 12
	6
	0 3 5 7 12 15
	2
	30
	20
	1
	20
	7
	1 3 5 7 11 13 17
	0

输出样例:

	Case Number 1: 5
	Case Number 2: 0
	Case Number 3: impossible

------------
假设玛利亚现在在第j个车站，现在的时间为i，那么她有两种选择：

1、在原地等待；2、如果有车经过，可以选择上车。

那么我们显然可以用动态规划：

令dp[i][j]表示第i分钟时，玛利亚在第j个车站，所需等待的最短时间。

如果她选择停留1分钟，那么

	dp[i+1][j]=dp[i][j]+1;
    
如果有一辆从1站出发的车经过，那么玛利亚可以从j站到达j+1站，时间会变成i+t[j]，即

	dp[i+t[j]][j+1]=dp[i][j];

如果有一辆从n站出发的车经过，玛利亚选择上车，则同理：

	dp[i+t[j-1]][j-1]=dp[i][j];

那么关键来了：如何判断第i分钟某一车辆是否经过j站？

假设有一辆车从1站出发，发车时间为d，那么如果d加上从1站出发后到达j站的时间等于i，则经过。这里，我们用前缀和数组存从1站出发到达某一站所需的时间：

	int f[70];
    f[1]=0;
    for(int i=1;i<n;i++)
    	f[i+1]=f[i]+t[i];

那么如果  d+f[j]==i，则该车此时经过。

反之，如果该车从n站出发呢？这里留给读者思考~~（其实是掩饰作者懒得写）~~

上代码啦：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &x)
{
	x=0;bool flag=false;
	char c=getchar();
	while(c<'0'||c>'9'){
		flag=c=='-';
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	if(flag)x=-x;
	return ;
}//本蒟蒻的快读
int dp[550][70];
int n,T;
int m1,m2;
int f[70],t[70],d[70],e[70];//如题目描述，f是前缀和数组
int now;
int main()
{
	re(n);//1
	while(n)
	{
		re(T);//2
		f[1]=0;
		for(int i=1;i<n;i++)
		{
			re(t[i]);//3
			f[i+1]=f[i]+t[i];//前缀和
		}
		//1 to n
		re(m1);//4
		for(int i=1;i<=m1;i++)
			re(d[i]);//5
		//n to 1
		re(m2);//6
		for(int i=1;i<=m2;i++)
			re(e[i]);//7
		for(int i=0;i<=T;i++)
			for(int j=1;j<=n;j++)
				dp[i][j]=9999;//首先赋一个较大的值，便于判断是否能够做到
		dp[0][1]=0;
		for(int i=0;i<=T;i++)
			for(int j=1;j<=n;j++)
			{
				if(dp[i][j]==9999)continue;
				dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1);//原地呆着
				for(int k=1;k<=m1;k++)//枚举车辆
					if(j<n&&f[j]+d[k]==i)//判断是否可行
                    	dp[i+t[j]][j+1]=min(dp[i+t[j]][j+1],dp[i][j]);
				for(int k=1;k<=m2;k++)
					if(j>1&&f[n]-f[j]+e[k]==i)
                    	dp[i+t[j-1]][j-1]=min(dp[i+t[j-1]][j-1],dp[i][j]);
			}
		printf("Case Number %d: ",++now);
		if(dp[T][n]<9999)printf("%d\n",dp[T][n]);
		else printf("impossible\n");
		re(n);//1
	}
	return 0;
}
```

---

## 作者：Forever丶CIL (赞：1)

这个题，乍一看，感觉好难啊，A掉之后翻了翻题解，发现下面的大佬都说简单

感受到我自己是有多么的菜鸡了

首先我感觉需要一点预处理，这样不管后面用什么算法，都会好搞一些。

预处理如下：   新开一个数组dt[][][]

dt[i][j][1]第i秒，第j个车站，有无向终点方向的车(有:dt[i][j][1]=1,无:dt[i][j][1]=0)

dt[i][j][0]第i秒，第j个车站，有无向起点方向的车(有:dt[i][j][0]=1,无:dt[i][j][0]=0)

然后写完预处理，觉得应该是动态规划，至于我为啥可以想得到，，这种玄学问题2333...

然后就着手推方程QwQ，我想到用A[i][j]表示前i秒，到j号车站，总共需要等待的时间

这样需要一点初始化：A[0][1]=0; 然后剩下的都是正无穷; 最终答案保存在A[T][n]里。

状态设好了，然后：考虑第i秒，我们在第j个车站，我们是如何站到第j个车站上的呢？

有三种情况：

一： 第i-Ti[j-1]秒恰好第j-1个车站有往终点方向的车，我们可以做这个车过来

即：A[i][j]=A[i-Ti[j-1]][j-1]  (转移条件：dt[i][j][1]==1)

二： 第i-Ti[j]秒恰好第j+1个车站有往起点方向的车，我们可以做这个车过来

即：A[i][j]=A[i-Ti[j]][j+1]  (转移条件：dt[i][j][0]==1)

三： 前两种情况均不满足，那我们是怎么来到j车站的呢？肯定是在第i秒之前我们就到达了

j车站，然后一直在等，等到了第i秒，所以A[i][j]=A[i-1][j]+1;

对于这三种情况，取一个min，作为A[i][j]

（注：当第i秒j车站有去终点的车，那么j-1号车站在i-Ti[j-1]秒肯定也有车啦）

————————————————————————————————————————

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int Inf=0x3f3f3f3f;
int M1,M2,n,T;
int A[300][100];//dp数组，用途上面说了 
int Ti[100];//Ti[i]表示 从i号车站去i+1号车站的用时 
int d[100];//d[i]表示从起点出发的第i辆车出发的时间 
int e[100];//e[i]表示从终点出发的第i辆车出发的时间 
int dt[300][100][2];//初始化数组，用途上面说了 
inline int read()//读入优化 
{
    int fl=1,rt=0; char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') fl=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9'){ rt=rt*10+ch-'0'; ch=getchar(); }
    return fl*rt;
}
inline void read_ini() //读入数据 
{
    T=read();
    for(int i=1;i<=n-1;i++) Ti[i]=read();
    M1=read();
    for(int i=1;i<=M1;i++) d[i]=read();
    M2=read();
    for(int i=1;i<=M2;i++) e[i]=read();
}
inline void ini_station() //初始化数组 
{
    for(int i=1;i<=M1;i++) //现在是从起点出发的第i辆车 
    {
        int k=1; //现在在第k号地铁站 
        for(int j=d[i];j<=T;j+=Ti[k-1]) //第i辆车不断往终点前进,时间超T就不用管了 
        {
            dt[j][k][1]=1;      
            k++;
            if(k>n) break ; //到达终点了 
        }
    }
    for(int i=1;i<=M2;i++)  //和上面一个道理，这里处理的是从终点去起点的 
    {
        int k=n;
        for(int j=e[i];j<=T;j+=Ti[k])
        {
            dt[j][k][0]=1;
            k--;
            if(!k) break ; 
        }
    }
}
inline void Dynamic_programming() //动态规划过程 
{
    A[0][1]=0;
    for(int i=1;i<=T;i++)  //枚举时间 
    {
        for(int j=1;j<=n;j++) //枚举在哪个地铁站 
        { 
            //三种状态转移： 
            A[i][j]=min(A[i][j],A[i-1][j]+1); 
            if(dt[i][j][1])
            {
                A[i][j]=min(A[i][j],A[i-Ti[j-1]][j-1]);
            }
            if(dt[i][j][0])
            {
                A[i][j]=min(A[i][j],A[i-Ti[j]][j+1]);
            }
        }
    }
}
void print()
{
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=T;j++)
        {
            printf("%d ",dt[j][i][0]);
        }
        printf("\n");
    }
}
int main()
{
    scanf("%d",&n);
    int t=1;
    while(n!=0)
    {
        memset(A,0x3f,sizeof(A));
        memset(dt,0,sizeof(dt));
        memset(Ti,0,sizeof(Ti));
        read_ini();
        ini_station();
        //print();
        Dynamic_programming();
        //输出答案： 
        if(A[T][n]==Inf)
            printf("Case Number %d: impossible\n",t);
        else 
            printf("Case Number %d: %d\n",t,A[T][n]);
        scanf("%d",&n); t++;
    }
    return 0;
}
``` 
————————————————————————————————————————

Rp++

---

## 作者：wzmszjw (赞：0)

一道DP题目，dp[i][j]表示到达第i个城市的时候 ，时间为j的等待时间最少是多少，然后转移方程即可。

```cpp
#include<cstdio>  
#include<algorithm>  
using namespace std;  
int a[100];  
int d1[100][100],d2[100][100];  
int m1,m2;  
int dp[100][400];  
int main(){  
    int n;  
    int T=1;  
    while(scanf("%d",&n)&&n!=0){  
        int t;  
        scanf("%d",&t);  
        for(int i=1;i<=n-1;i++){  
            scanf("%d",&a[i]);  
        }  
        scanf("%d",&m1);  
        for(int i=1;i<=m1;i++){  
            scanf("%d",&d1[1][i]);  
        }  
        sort(d1[1]+1,d1[1]+m1+1);  
        scanf("%d",&m2);  
        for(int i=1;i<=m2;i++){  
            scanf("%d",&d2[n][i]);  
        }  
        sort(d2[n]+1,d2[n]+m2+1);  
        dp[0][1]=0;  
        for(int i=1;i<=m1;i++){  
            for(int j=1;j<=n-1;j++){  
                d1[j+1][i]=d1[j][i]+a[j];  
            }  
        }  
        for(int i=1;i<=m2;i++){  
            for(int j=n-1;j>=1;j--){  
                d2[j][i]=d2[j+1][i]+a[j];  
            }  
        }  
        for(int i=0;i<=t;i++){  
            for(int j=1;j<=n;j++) dp[j][i]=t+1;  
        }  
        dp[1][0]=0;  
        for(int j=0;j<=t;j++){  
            for(int i=1;i<=n;i++){  
                if(dp[i][j]<=t){  
                    int k;  
                    for(k=1;k<=m1;k++){  
                        if(d1[i][k]>=j) break;  
                    }  
                    if(d1[i][k]-j+dp[i][j]<dp[i+1][j+a[i]+d1[i][k]-j]&&k<=m1)  
                    dp[i+1][j+a[i]+d1[i][k]-j]=d1[i][k]-j+dp[i][j];  
                    for(k=1;k<=m2;k++){  
                        if(d2[i][k]>=j) break;  
                    }  
                    if(k<=m2&&d2[i][k]-j+dp[i][j]<dp[i-1][j+a[i-1]+d2[i][k]-j])  
                    dp[i-1][j+a[i-1]+d2[i][k]-j]=d2[i][k]-j+dp[i][j];  
                }  
            }  
        }  
        for(int i=1;i<=t;i++){  
            if(dp[n][i]<t){  
                dp[n][t]=min(dp[n][i]+t-i,dp[n][t]);  
            }  
        }  
        if(dp[n][t]<=t)  
        printf("Case Number %d: %d\n",T++,dp[n][t]);  
        else printf("Case Number %d: impossible\n",T++);  
    }  
}
```

---

## 作者：zhouenji (赞：0)

这道题是在求这个人在时间T到达n站的最小等待时间

于是我们可以用dp【i】【j】表示这个人在i时间到达j的最小等待时间

那么这个状态是可以由j-1和j+1推出来的；

只需要枚举火车数量就行了；

dp方程：

dp[i][j]=min(dp[i][j],dp[x[k]+sum[0][j-1]][j-1]+(i-x[k]-sum[0][j]));

dp[i][j]=min(dp[i][j],dp[y[k]+sum[1][j+1]][j+1]+(i-y[k]-sum[1][j]));

另外就是预处理的问题了

可以用sum【0】【i】表示火车从1站到i站时间sum【1】【i】是从n站到i站的时间

每次清空！！！

以下是代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=1000+10;
int n,T,m1,m2;
int s[maxn],x[maxn],y[maxn],sum[2][maxn];
int dp[maxn][maxn];
int main()
{
    int cnt=0;
    while(scanf("%d",&n) && n)
    {
        scanf("%d",&T);
        memset(sum,0,sizeof(sum));memset(s,0,sizeof(s));
        for(int i=1;i<n;i++) scanf("%d",&s[i]);
        for(int i=2;i<=n;i++)sum[0][i]=sum[0][i-1]+s[i-1];
        for(int i=n-1;i>=1;i--)sum[1][i]=sum[1][i+1]+s[i];
        scanf("%d",&m1);for(int i=1;i<=m1;i++)scanf("%d",&x[i]);
        scanf("%d",&m2);for(int i=1;i<=m2;i++)scanf("%d",&y[i]);
        memset(dp,0x3f,sizeof(dp));dp[0][1]=0;
        for(int i=1;i<=T;i++)
        {
            for(int j=1;j<=n;j++)
            {
                dp[i][j]=dp[i-1][j]+1;
                for(int k=1;k<=m1;k++)
                if(i>=x[k]+sum[0][j] && j>1)
                {
                    dp[i][j]=min(dp[i][j],dp[x[k]+sum[0][j-1]][j-1]+(i-x[k]-sum[0][j]));
                }
                for(int k=1;k<=m2;k++)
                if(i>=y[k]+sum[1][j] && j<n)
                {
                    dp[i][j]=min(dp[i][j],dp[y[k]+sum[1][j+1]][j+1]+(i-y[k]-sum[1][j]));
                }
            }
        }
        if(dp[T][n]>1e9)printf("Case Number %d: impossible\n",++cnt);
        else printf("Case Number %d: %d\n",++cnt,dp[T][n]);
    }
}
```

---

## 作者：凯特琳 (赞：0)

地铁间谍：时空DP

特工玛利亚被送到S市执行一个特别危险的任务。她需要利用地铁完成他的任务，S市的地铁只有一条线路运行，所以并不复杂。

玛利亚有一个任务，现在的时间为0，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。

玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。

这个城市有n个车站，编号是1-n，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。

输入输出格式 Input/output

输入格式：

输入文件包含多组数据，每组数据都由7行组成

第1行：一个正整数N（2<=N<=50）表示站的数量

第2行：一个正整数T（0<=T<=200）表示需要的碰头时间

第3行：1-（n-1）个正整数（0<ti<70）表示两站之间列车的通过时间

第4行：一个整数M1（1<=M1<=50）表示离开第一个车站的火车的数量

第5行：M1个正整数：d1，d2……dn，（0<=d<=250且di<di+1）表示每一列火车离开第一站的时间

第6行：一个正整数M2（1<=M2<=50）表示离开第N站的火车的数量

第7行：M2个正整数：e1,e2……eM2,(0<=e<=250且ei<ei+1)表示每一列火车离开第N站的时间

最后一行有一个整数0。

输出格式：

对于每个测试案例，打印一行“Case Number N: ”（N从1开始）和一个整数表示总等待的最短时间或者一个单词“impossible”如果玛丽亚不可能做到。按照样例的输出格式。

输入输出样例 Sample input/output

样例测试点#1

输入样例： 在线IDE

4
55
5 10 15

4
0 5 10 20

4
0 5 10 15

4
18
1 2 3
5
0 3 6 10 12

6
0 3 5 7 12 15

2
30
20
1
20
7
1 3 5 7 11 13 17

0

输出样例：

Case Number 1: 5

Case Number 2: 0

Case Number 3: impossible

说明 description

第一组样例说明，她0分钟时上车，在3号站下车，立刻坐上（0分始发）15分开的车回去，到2号车站，立刻坐上（20分始发）25开的车到终点，50分到，还需要等待5分钟。


思路：这个题可以看出是DP，但是难处理的就是列车有很多，还从两边同时开出，发车时间还不一样，所以就给我们进行时间和空间上的转移造成了不变，那么这个题难点1就在于预处理，否则你边DP边处理会疯的！


在额外说一个技巧：题目有多组数据，结尾有个0，但是 每组数据的第一个 N>=2 所以我们可以设置一个N的傀儡变量C，每次先读入C，如果C=0那么说明数据结束，程序跳出；如果C<>0那么C的值实际上是N，我们就N:=C;再继续读入数据就可以了


讲一下如何预处理：开一个数组a【i,j】开始初始化为0，a【i,j】=k表示第i辆列车，在时间点j的时候到达了k，相当于a【i,j】中记录了每辆列车的时刻表。这样在进行DP的时候就相当方便！对于本题我是把从两边开的列车分开用两个数组a1和a2分别存的，合起来也没什么影响。

当预处理反向列车的时刻表的时候，用前缀和写起来比较方便。


在讲一下如何DP以及状态转移的问题：

我们开一个数组f【i,j】以第一维（时间）为主轴，第二维（车站标号）为副轴进行转移

```cpp
for i:=0 to t do//枚举时间
for j:=1 to n do//枚举车站标号
begin
for k:=1 to m1+m2 do//方案1：找一辆车上去
```
if 在时间i的时候第k辆的列车经过了j车站 then
for h:=i+1 to t do//上车，枚举下车站点

if 第k辆列车在时间点h的时候到了另一个车站 then//更新此车时刻表上剩下的车站。

f[h,下一站]:=min(f[h,下一站],f[i,j]);

f[i+1,j]:=min(f[i+1,j],f[i,j]+1)//方案2：呆在这里等。

end；

无后效性说明：我们以时间为主轴在外层循环，所以我们不可能让时间倒流，也就是当确定了i时刻的f【i，1..n】之后我们就进入了i+1时刻，这也是最优子结构的体现。


AC代码：

```delphi

program exam1;
var tt:array[1..50]of longint;//记录每两站之间的时间       比如tt[3] 记录了2-3的时间
var f:array[0..200,0..50]of longint;//DP数组
var a1,a2:array[1..50,0..200]of longint;//列车时刻表
var d,e:array[1..50]of longint;//发车时间
ttt:array[0..50]of longint;//前缀和
var h,num,c,i,j,m1,m2,n,t,k,ans:longint;
function min(q1,q2:longint):longint;
begin
if q1<q2 then exit(q1)
else exit(q2);
end;

begin
read(c);//读入第一组的N的傀儡

while c<>0 do
begin
inc(num);//组数+1
n:=c;//将傀儡值还给N
read(t);

fillchar(tt,sizeof(tt),0);
fillchar(ttt,sizeof(ttt),0);
fillchar(d,sizeof(d),0);
fillchar(e,sizeof(e),0);
fillchar(a1,sizeof(a1),0);
fillchar(a2,sizeof(a2),0);//必须要有的初始化

for i:=2 to n do
read(tt[i]);
read(m1);
for i:=1 to m1 do
read(d[i]);
read(m2);
for i:=1 to m2 do
read(e[i]);//本组数据读入完毕

read(c);//读入下一组数据的N或者0

for i:=2 to n do
ttt[i]:=ttt[i-1]+tt[i];//前缀和       ttt[i]  表示从1到i的时间

for i:=1 to m1 do//计算正向列车的时刻表
if d[i]<=t then//如果发车时间合法
begin
a1[i,d[i]]:=1;//发车时刻 此车在发车站
for j:=2 to n do//枚举到j号车站的时间
if d[i]+ttt[j]<=t then//如果时间合法
a1[i,d[i]+ttt[j]]:=j;//记录第i列车  在时间d[i]+ttt[j]到达了j车站
end;

for i:=1 to m2 do//计算反向列车的时刻表
if e[i]<=t then//如果发车时间合法
begin
a2[i,e[i]]:=n;//发车时刻 此车在终点站
for j:=n-1 downto 1 do//枚举到j号车站的世间安
if e[i]+ttt[n]-ttt[j]<=t then//如果时间合法
a2[i,e[i]+ttt[n]-ttt[j]]:=j;//记录第i列车 在时间e[i]+ttt[n]-ttt[j]到了j车站       ttt[n]-ttt[j]是从n到j的时间
end;


for i:=0 to t do for j:=1 to n do f[i,j]:=100000000;//初始化
f[0,1]:=0;//初始化

for i:=0 to t do//时间主轴
for j:=1 to n do  //now is here       车站副轴
begin
for k:=1 to m1 do //1che      枚举正向列车编号k
if a1[k,i]=j then       //1che is here    如果此时（时刻i）此车（第k个）在这里（j车站）
for h:=i+1 to t do     //search next        上车 转移他所能到的剩余的车站
if a1[k,h]<>0 then    //next is in station    如果经过了一个车站
f[h,a1[k,h]]:=min(f[h,a1[k,h]],f[i,j]);      转移之

for k:=1 to m2 do //2che    枚举反向列车编号k
if a2[k,i]=j then     //如果此时（时刻i）此车（编号k）在这里（j车站）
for h:=i+1 to t do    //转移时刻表上剩下的车站
if a2[k,h]<>0 then   //在h时刻经过了一个车站
f[h,a2[k,h]]:=min(f[h,a2[k,h]],f[i,j]);//转移之

f[i+1,j]:=min(f[i+1,j],f[i,j]+1);//除了坐车之外，我们还可以在这里等1秒钟
end;


ans:=100000000;//寻找答案
for i:=0 to t do   //我们可能在0..t中的多个时刻到达n车站 此时f[i,n]中记录了路上所需要的等待时间，我们还需要额外等t-i的时间接上头
if f[i,n]<>100000000 then  //如果时刻i到达过n
ans:=min(ans,f[i,n]+t-i);//更新答案
write('Case Number ',num,': ');//输出首部  注意：冒号后面有个空格！！！！！！！！！
if ans=100000000 then writeln('impossible')//如果答案没被更新过 则表示我们无法在规定时间内到达n
else writeln(ans);
end;
end.

```

希望在题目中提醒一下那个冒号后面十分隐蔽的空格！


---


# 暗杀

## 题目描述

敌方的高级将领都是有很多相同之处的。为了方便找到每名敌将的弱点，我军情报部已经找到了他们的不同点，并将其归纳为 $k$ 种特性。比如 $1$ 号特性就代表一个敌将喜欢打人，$2$ 号特性就代表一个敌将喜欢吃饭，等等。

为了方便存储，我军使用特性值来描述一个敌将的特点。特性值是一个位数为 $k$ 的二进制整数，每一位都可以表示一名敌将的一个特性。$1$ 代表具有此特性，$0$ 代表没有。

我军间谍打听到，不久有 $n$ 个敌方将领会举行一场宴会，而且入场时他们会排成一路纵队入场。如果有连续的 $m$ 个人的每种特性出现的次数之和是一样的，那么我军间谍就很容易暗杀这 $m$ 个人。你需要帮助我军算出，间谍最多可以暗杀多少人？

因为间谍开始攻击后就可能被敌人击毙，所以间谍只能进行一次攻击。

## 说明/提示

- 对于 $30\%$ 的数据，$1 \leq N \leq 100$；
- 对于 $50\%$ 的数据，$1 \leq N \leq 1000$；
- 对于 $100\%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq 30$。

## 样例 #1

### 输入

```
7 3
7 6 7 2 1 4 2```

### 输出

```
4```

# 题解

## 作者：int_LL (赞：8)

这个题要用到前缀和

设b[i][j]表示第j种特性的前缀和

设sum[i][j]=b[i][j]-b[i][1]

我们可发现若sum[i]==sum[j]时，i到j都可杀死的结论（重点）

因为前缀和，代表区间性质，样例可模拟出

我们要用map映射sum为编号，维护全局最优解maxn

注意要先映射全为零的sum，否则会出错，自己想想为什么

下面是代码
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

int n,k,maxn;
int a[100005],b[100005][35];
vector<int> sum;
map<vector<int>,int> ma;

int main ()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=k;i++)sum.push_back(0);
    ma[sum]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        sum.clear();
        for(int j=1;j<=k;j++)
        {
        	if(((1<<(j-1))&a[i])>0)//判断第k位是否为1；
        	{
        		b[i][j]=b[i-1][j]+1;
			}
			else b[i][j]=b[i-1][j];
			sum.push_back(b[i][j]-b[i][1]);
		}
		if(ma.count(sum))//若存在
		{
			if(maxn<(i-ma[sum]))
			{
				maxn=i-ma[sum];
			}
		}
		else ma[sum]=i;
    }
    cout<<maxn;
    return 0;
}
```

---

## 作者：Link_Space (赞：6)

从题解区 AnoxiacxyAnoxiacxy大佬代码中得到思路，现对该大佬的思路做一个更加详细的讲解

拿到题之后思考，我们试着去记录每一个将领的特性，并且求出前缀和。

假设我们现在正在考虑第i位将领，第j位将领为第i位将领之前的某一位将领。

那么第i位将领的前缀和的每一位如果能同时减去一个数k恰好与第j位将领的每一位将领相同，那么即说明第j+1位到第i位将领的每一位将领的前缀和的每一位加起来的和都恰好是k，就满足条件了，而我们只需要求出这样的满足条件的将领个数的最大值即可。

思路已经知道，考虑如何来实现代码，那么首先想到的肯定是用一个数组来存前缀和，但是如何和之前的相互比较看是否满足条件呢？那么我们考虑将数组改变成vector来存储当前的前缀和，假设该vector名为now，然后建立一个以now为映射的map,假设该map名为found，每次输入第i个将领的特性值时都更新now，然后查询之前的i-1个将领中前缀和同样为now的将领最后出现在什么位置，那么i这之间的所有将领都满足条件，而map存储的就是前缀和为now的最后一个将领。
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<map>
#include<vector>
using namespace std;
map<vector<int>, int> found;
int main()
{
    int maxn = 0;
    int n,k;
    scanf("%d%d", &n, &k);
    vector<int> now(k);
    found[now] = 0;
    for (int i = 1;i<=n;i++)
    {
        int x;
        scanf("%d", &x);
        for (int j = 0; j < k;j++)
            if(x&(1<<j))
                now[j]++;
        if(x&1)
            for (int j = 0; j < k;j++)
                now[j]--;//或许有的同学不理解这一步，讲解如下
        if(found.count(now))
            maxn = max(maxn, i - found[now]);
        else
            found[now] = i;
    }
    printf("%d\n", maxn);
```
这一步的意思就是每次存储进去时就将每一位减1，可以看作每一位都是最简形式，例如第i位的前缀和为221，那么存进去时每一位减了一直到最后一位为0，存进去时就变成了110。
而我们之后碰见了一个将领j的前缀和为554，那么存进去时即为110，与221的最简形式相同，那么i+1到j中的所有将领都可以杀死，即为合法方案，而我每一次存的时候都减一，即保证了随时都是最简形式，下一位将领的前缀和状态也是从当前这一位将领的now得到，那么下一位将领的now也为最简状态，直接存进found即可

---

## 作者：飞翔 (赞：5)

设Sum数组为各个特性值转为二进制后的前缀和，即Sum[i,j]表示第1个敌将到第i个敌将特性j的出现次数之和，则可以列出不等式sum[i][0]-sum[j][0]=sum[i][1]-sum[j][1]=.....=sum[i][k-1]-sum[j][k-1]。令C[i,j]=Sum[i,j]-Sum[i,0]，即只需求出使得C数组的第i行等于第j行的最大的i-j。数据规模大，应使用Hash优化。

```cpp
const
  inf=10007; 
type
  arr=array[0..31]of longint; 
    rec=record
        data,no:longint; 
    end; 
var
  sum,count:array[0..100001,0..30]of longint; 
    h:array[0..inf,0..55]of rec; 
    i,j,n,m,max,t:longint; 
function check(x,y:longint):boolean; 
var
  i:longint; 
begin
  for i:=1 to m do
        if count[x,i]<>count[y,i] then exit(false); 
    exit(true); 
end; 
procedure insert(t:longint); 
var
  i,p:longint; 
begin
  p:=0; 
    for i:=1 to m do p:=p+count[t,i]*i; 
    p:=abs(p) mod inf; 
    i:=0; 
    while h[p,i].no=1 do begin
      if check(h[p,i].data,t)=true then begin
          if t-h[p,i].data>max then max:=t-h[p,i].data; 
          exit; 
        end; 
        inc(i); 
    end; 
    h[p,i].no:=1; 
    h[p,i].data:=t; 
end; 
begin
    max:=0; 
    fillchar(h,sizeof(h),0); 
    h[0,0].no:=1; 
  readln(n,m); 
    for i:=1 to n do begin
        read(t); 
        for j:=1 to m do begin
            sum[i,j]:=sum[i-1,j]+t mod 2; 
            count[i,j]:=sum[i,j]-sum[i,1]; 
            t:=t shr 1; 
        end; 
        insert(i); 
    end; 
    write(max); 
end. 
```

---

## 作者：wxzzzz (赞：3)

### 思路

哈希+map 的小 trick。

记录 $s_{i,j}$，表示前 $i$ 个人在第 $j$ 位上的前缀和。

显然，如果对于一组 $l,r$，使得 $s_{l,i}-s_{l,i-1}=s_{r,i}-s_{r,i-1}(2\le i\le k)$，即 $s_l,s_r$ 的差分数组相等，那么 $a_{l+1}\sim a_r$ 为一个合法区间。

暴力枚举 $l,r$ 的时间复杂度是 $O(n^2)$，显然不行。

可以发现，对于一个 $r$，只需要考虑差分数组和 $s_r$ 相等且位置最靠前的 $l$，可以把 $s_i$ 的差分数组哈希，用 map 找该哈希值对应的最小 $l$，然后统计最大的 $r-l$。

这里要特判一下，如果哈希值为 $0$，即 $k=1$ 时需用 $i$ 更新答案，因为此时 map 会返回空。

最后，$s$ 的 $i$ 这一维可以省去，每次直接加上 $a_i$ 对 $s$ 的贡献即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, ans, s[35];
map<unsigned long long, int> pos;
int main() {
    cin >> n >> k;

    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        unsigned long long hs = 0;

        for (int j = 1; j <= k; j++)
            if (x >> j - 1 & 1)
                s[j]++;

        for (int j = 2; j <= k; j++)
            hs = hs * 131 + s[j] - s[j - 1];

        if (!hs)
            ans = max(ans, i);
        else if (!pos[hs])
            pos[hs] = i;
        else
            ans = max(ans, i - pos[hs]);
    }

    cout << ans;
    return 0;
}
```

---

## 作者：CyberPrisoner (赞：3)

题目描述有点不好理解，举个例子，第一个人有弱点 $1,2$，第二个人有弱点 $1,3$，第三个人有弱点 $2,3$，那么此时在这三个人中 $1,2,3$ 弱点都各出现了 $2$ 次，那么我们可以直接来一个 triple kill。

---------------------------------------------------------solution-------------------------------------------------------------

我们可以用前缀和 $s_{ij}$ 表示前 $i$ 个人中 $j$ 特性出现了多少，统计完之后最朴素的想法是把所有区间枚举一遍，看哪个区间满足条件且人最多，然而这样时间复杂度是 $O(n^2k)$ 的。然后结合本题性质，我们可以发现前 $i$ 个人的性质中有某些性质是比数量最少的性质性质多的，所以此时不能进行暗杀,于是我们可以尝试从前面找到一个最小的 $k$ 且 $k<i$ ，满足前 $k$ 个人多出来的性质和前 $i$ 个人多出来的性质一样。那么显然 $(k,i]$ 是可以成为一个答案区间的，因为没有多出来的性质，理论复杂度 $O(nk)$。

$$$$
然而真的就这么简单吗？其实本题最难的点是多余性质的保存和映射。对于多出来的性质，我们可以使用 $hash$ 表来存这个状态，然而 $hash$ 值非常随意，不能简单的开个数组来映射，所以又开了个 map 映射 $hash(i)$ 对应的最小的 $k$（恼。

最后复杂度应该是 $O(nk)$ 或 $O(n \log n)$。



code
```
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N=1e5+10,mod=291143;//建议取个接近最大范围的质数
int n,k,ans;
ull a[N],s[N][31];
map<ull,int> pos;
inline ull Hash(int i){
	ull minx=INT_MAX,res=0;
	for(int j=1;j<=k;j++)
		minx=min(s[i][j],minx);
	for(int j=1;j<=k;j++)
		res*=mod,res+=s[i][j]-minx;
	return res;
}//计算hash值
int main(){
	scanf("%d%d",&n,&k);
	int p=(1<<k)-1;
	for(int i=1,t;i<=n;i++){
		scanf("%d",&t);
		for(int j=0;j<k;j++){
			s[i][j+1]=s[i-1][j+1];
			if((1<<j)&t) s[i][j+1]++;
		}
	}
	for(int i=1;i<=n;i++){
		ull temp=Hash(i);//temp表示多余的性质,要特判没有多余的情况 
		if(temp!=0&&pos[temp]==0) pos[temp]=i;
		else if(pos[temp]!=0||temp==0) ans=max(ans,i-pos[temp]);
	}
	printf("%d",ans);
} 
```



---

## 作者：Harece (赞：2)

原题链接https://www.luogu.org/problem/P2843

## 题目描述

敌方的高级将领都是有很多相同之处的。为了方便找到每名敌将的弱点，我军情报部已经找到了他们的不同点，并将其归纳为K种特性。比如1号特性就代表一个敌将喜欢打人，2号特性就代表一个敌将喜欢吃饭，等等。

为了方便存储，我军使用特性值来描述一个敌将的特点。特性值是一个位数为K的二进制整数，每一位都可以表示一名敌将的一个特性。1代表具有此特性，0代表没有。

我军间谍打听到，不久有N个敌方将领会举行一场宴会，而且入场时他们会排成一路纵队入场。如果有连续的M个人的每种特性出现的次数之和是一样的，那么我军间谍就很容易暗杀这M个人。你需要帮助我军算出，间谍最多可以暗杀多少人？

因为间谍开始攻击后就可能被敌人击毙，所以间谍只能进行一次攻击。

```c
样例说明：
ai         属性           敌将
7          1 1 1            1
6          0 1 1            2
7          1 1 1            3
2          0 1 0            4
1          1 0 0            5
4          0 0 1            6
2          0 1 0            7
可以击杀第3人到第6人，共6-3+1=4人
```



由题意可知我们要找到一段区间其中各个特征和相等，用一个sum数组记录各个特征的前缀和，我们可以得出如果区间[l, r]中各个特征和相等， 那么
$$
sum[l][2] - sum[l][1] = sum[r][2] - sum[r][1]
$$

$$
sum[l][3] - sum[l][1] = sum[r][3] - sum[r][1]
$$

​											....

证明：

当区间[l, r]中各个特征和相等, 设和的值为x
$$
sum[r][1] = sum[l][1] + x
$$

$$
sum[r][2] = sum[l][2] + x
$$

​																...

所以前缀和的相对差值不变。
将前缀和相对差值进行hash，映射到数组中然后用hash值作为key进行匹配，最后进行差值比较确认是否符合。

```
#include<iostream>
#include<cstdio>
#include<vector>
#define ll long long
using namespace std;

const int N = 1e5 + 10, M = 40, MAX = 1e6 + 10; 

int n, k, ans, num;
int lg[M];
int a[N][M], sum[N][M];

vector<int>	 hash[MAX];

template <typename T>
inline void read(T &x){
	x = 0;
	char c = getchar();
	T op = 1;
	for(; c < '0' || c > '9'; c = getchar())
		if(c == '-')	op = -1;
	for(; c <= '9' && c >= '0'; c = getchar())
		x = (x << 3) + (x << 1) + c - '0';
	x *= op;
}

inline bool check(int x, int y){
	for(int i = 1; i <= k; ++i)
		if(a[x][i] != a[y][i])	return 0;
	return 1;
}//进行精准检验

inline void HASH(int x){
	int p = 0;
	for(int i = 1; i <= k; ++i)
		p += a[x][i] * lg[i], p %= MAX;
	p = (p + MAX) % MAX;
	int s = hash[p].size();
	for(int i = 0; i < s; ++i) //在这人之前是否可以找到一个人进行匹配
	if(ans < (x - hash[p][i]))
		if(check(x, hash[p][i]))	
			ans = x - hash[p][i];
	hash[p].push_back(x);
	return;
}//加入到key为p的hash数组中

inline void init(){
	read(n), read(k);
	ans = 0, lg[1] = 1;
	for(int i = 2; i <= k; ++i)	lg[i] = (lg[i - 1] * 71) % MAX;
	hash[0].push_back(0); //要对第一个人就符合条件进行判断
}

int main(){
	init();
	for(int i = 1; i <= n; ++i){
		read(num);
		for(int j = 1; j <= k; ++j, num >>= 1) //进行数字分解并进行前缀和计算
			sum[i][j] = sum[i - 1][j] + (num & 1), a[i][j] = sum[i][j] - sum[i][1]; // 计算相对差值
		HASH(i);
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：asdfghjkl123 (赞：2)

没有C++ map 的题解？

我来一份……

大体的思路是机房神仙告诉我的，大家看其他题解应该也都能理解，就不再班门弄斧了

至于判重的问题，刚开始也是想用hash压成数字，但是后来想了想，觉得字符集大小有点难接受（2e5，因为可能存在一种情况，最后一行的在转变存储方式之后为：0,1e5，-1e5），就考虑用另外一种方式判重。

既然不打算压成一个数字，就直接对于这个状态进行map，但是又不好对一个int数组进行map，那么怎么搞？

我们可以使用一个结构体来存储这些数字，然后自定义一个运算符来进行map

上代码（代码已经过防伪处理，不过代码内容没有改）
```
#include<bits/stdc++.h>
using namespace std
struct asdf{
	int x[31]
}v[100001]
int n,k,tmp
const bool operator<(const asdf a,const asdf b)
{
	for(int i=0;i<k;i++)
	{
		if(a.x[i]==b.x[i])continue
		return a.x[i]<b.x[i]
	}
	return false
}
（随便定义一个小于号就好，因为我们对排序也没什么强制要求）
map<asdf,int>m
int main()
{
	scanf("%d%d",n,k)
	for(int i=1;i<=n;i++)
	{
		scanf("%d",tmp)
		for(int j=0;j<k;j++)
			v[i].x[j]=v[i-1].x[j]+((tmp&(1<<j))?1:0)
	}
	for(int i=1;i<=n;i++)
		for(int j=k-1;j>=0;j--)
			v[i].x[j]-=v[i].x[0]
	m[v[0]]=-1
	for(int i=1;i<=n;i++)
	{
		if(!m[v[i]])
			m[v[i]]=i
	}
	int ans=-1
	m[v[0]]=0
	for(int i=n;i;i--)
		ans=max(ans,i-m[v[i]])
	printf("%d",ans)
	return 0
}
```

---

## 作者：Linghua_dog (赞：1)

首先看到这道题，题目大意是求一段最大的连续区间，保证每一位上的 $1$ 的个数相等，这让我想到了之前做过的一道[非常男女计划](https://www.luogu.com.cn/problem/P1114)
，只不过把两个相等改成了 $30$ 个而已，那如何去处理呢，对于区间求和问题，我们先想到先预处理一遍前缀和，然后固定右端点，去找符合条件的最左边的左端点。

重点：如何判断符合条件，我们发现当相邻两位前缀和之差全都相等时，那么这一对左右端点就是合法的，那我们只需开个 `map` 记录最左边的前缀和之差，然后就做完了，如果不理解可以结合代码。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>

#define int long long

using namespace std;

const int N = 1e5 + 10;

map<vector<int>, int> mp;
vector<int> s; //用vector记录k - 1个前缀和之差
int sum[N][35];

signed main()
{
	int n, k;
	scanf("%lld%lld", &n, &k);
	for(int i = 1; i <= n; i++)
	{
		int x;
		scanf("%lld", &x);
		for(int j = 0; j < k; j++)
		{
			if(x >> j & 1) sum[i][j] = sum[i - 1][j] + 1;
			else sum[i][j] = sum[i - 1][j];
		}
	}
	
	int ans = 0;
	for(int j = 0; j < k - 1; j++) s.push_back(0);//不要忘记把全0的加入,因为有可能1~n的前缀和刚好全相等。
	mp[s] = 0;
	
	for(int i = 1; i <= n; i++)
	{
		s.clear();	
		for(int j = 0; j < k - 1; j++) s.push_back(sum[i][j] - sum[i][j + 1]); // 相邻两位的前缀和之差
		if(mp.count(s)) ans = max(ans, i - mp[s]);
		else mp[s] = i; // 记录最左边
	}
	printf("%lld", ans);
}
```

---

## 作者：a2600254 (赞：1)

并没有c艹的题解

~~于怒水~~

设$sum[i][j]$表示第$j$种特性的前缀和

设$a[i][j]=sum[i][j]-sum[i][1]$，
表示第$i$种将领的第$j$种特性相对于$sum[i][1]$的差分数组

易得题目所求即为满足$a[i][1...n]==a[j][1...n]$的最大的$i-j$

将$a$数组每一行哈希储存，暴力判断是否相等即可

也可以二分$i-j$，再枚举$i$进行验证

代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<cmath>
using namespace std;
#define max(a,b) ((a>b)?(a):(b))
#define min(a,b) ((a<b)?(a):(b))
#define rd(a) scanf("%lld",&a)
#define rd2(a,b) scanf("%lld%lld",&a,&b)
#define rd3(a,b,c) scanf("%lld%lld%lld",&a,&b,&c)
#define wt(a) printf("%lld",a)
#define wtb putchar(' ')
#define wtl putchar(10)
#define F1N FUP(i,1,n)
#define FUP(a,b,c) for(long long a=b;a<=c;++a)
#define FDN(a,b,c) for(long long a=b;a>=c;--a)
#define maxn 100010
#define maxk 60
#define M 997003
long long n,k,x,sum[maxn][maxk],a[maxn][maxk],data[1000000][maxk],nxt[1000000][maxk],ans;
bool check(long long i,long long j)
{
	FUP(l,1,k)
		if(a[i][l]!=a[j][l])
			return false;
	return true;
}
void HASH(long long i)
{
	long long ans=0;
	for(long long j=1;j<=k;++j)
		ans+=j*a[i][j],ans%=M;
	ans=(ans+M)%M;
	long long j;
	for(j=0;nxt[ans][j];++j)
		if(check(i,data[ans][j]))
		{
			::ans=max(::ans,i-data[ans][j]);
			return;
		}
	nxt[ans][j]=1;
	data[ans][j]=i;
}
int main()
{
	nxt[0][0]=1;
	rd2(n,k);
	F1N
	{
		rd(x);
		FUP(j,1,k)
		{
			sum[i][j]=sum[i-1][j]+(x&1);
			x>>=1;
			a[i][j]=sum[i][j]-sum[i][1];
		}
		HASH(i);
	}
	wt(ans);
}
```

$Q$A$Q$我太弱了

---

## 作者：FReQuenter (赞：0)

## 思路

首先，我们设前 $i$ 个人的第 $j$ 种特性之和为 $sum_{i,j}$，则判断第 $i$ 个人到第 $j$ 个人可不可以被暗杀就转化成了检查 
$$sum_{j,1}-sum_{i,1}=sum_{j,2}-sum_{i,2}=...=sum_{j,k}-sum_{i,k}$$

对 $i,j$ 进行枚举，就可以 $O(n^2)$ 解决。

接下来考虑优化：我们如何对于任意一个 $j$，$O(1)$ 求出之前的 $i$ 呢？我们发现对于前缀和有一个特点：如果第 $i$ 个人到第 $j$ 个人可以被暗杀，那么他们两行的前缀和减去两行中各自一个固定的数都是定值。

$$sum_{j,1}-sum_{j,1}=sum_{i,1}-sum_{i,1},sum_{j,2}-sum_{j,1}=sum_{i,2}-sum_{i,1},...,sum_{j,k}-sum_{j,1}=sum_{i,k}-sum_{i,1}$$

可以感性理解一下：

$$sum_{i}=\{a,b,c,...\},sum_{j}=\{a+x,b+x,c+x,...\}$$

$$a-a=a+x-(a+x),b-a=(b+x)-(a+x),c-a=(c+x)-(a+x)...$$

之后，这个问题就转化成了：

设一个二维数组 $s$，$s_{i,j}=sum_{i,j}-sum_{i,1}$，求 $\max\{i-j\},s_i=s_j,1\leq i<j\leq n$ 。使用哈希即可解决。对于数组的哈希可以使用 STL 里的 map。使用 vector 作为键即可。细节见代码。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#define max(a,b) ((a)>(b)?(a):(b))
int sum[31][100001],n,k,ans;
std::vector<int> summ;
std::map<std::vector<int>,int> mp; 
signed main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		std::string s;
		while(x){
			s+=x%2+48;
			x/=2;
		}
		std::reverse(s.begin(),s.end());
		while((int)s.length()<=k) s='0'+s;
		for(int j=1;j<=k;j++) sum[j][i]=sum[j][i-1];
		for(int j=1;j<=k;j++) sum[j][i]+=s[j]-48;
	}
	//预处理前缀和
	for(int i=1;i<=k;i++) summ.push_back(0);
	mp[summ]=0;
	//注意0也要哈希
	for(int i=1;i<=n;i++){
		summ.clear();
		for(int j=1;j<=k;j++) summ.push_back(sum[j][i]-sum[1][i]);
		if(mp.find(summ)!=mp.end()){if(ans<(i-mp[summ])) ans=i-mp[summ];}
		//这里小心写成mp[summ]，因为0哈希过了
		//写成mp[summ]只有80pts
		else mp[summ]=i;
	}
	printf("%d",ans);
}
```

---

## 作者：yrs2022 (赞：0)

[题目](https://www.luogu.com.cn/problem/P2843) 

# 样例解析：

~~（有一说一，这样例误导性真强）~~

```
敌将   特性 一 (1) 二 (2) 三 (4)
 1            1      1      1
 2            0      1      1
 3            1      1      1
 4            0      1      0
 5            1      0      0
 6            0      0      1
 7            0      1      0
```

观察可知：敌将 $3 \sim 6$ 特性一之和等于 $1+0+1+0=2$。特性二之和等于 $1+1+0+0=2$。特性三之和等于 $1+0+0+1=2$。

因此，我们可以一次暗杀敌将 $3 \sim 6$。

# 暴力

形如：

```
for(i~n)
    for(j~i)
        for(l~k)
            for(j~i)
                ……
```

时间复杂度 $O(n^3k)$（汗）。

# 前缀和优化

易想到使用**前缀和**进行优化最后一维，即 $sum_{i,j}$ 表示前 $i$ 个敌将特性 $j$ 之和。

时间复杂度 $O(n^2k)$，约 $50$ 分。

# 哈希/动态数组/结构体优化

接下来优化倒数第二维，考虑是否可以使用**哈希**优化。

由题目可得:$sum_{r,1} - sum_{l-1,1} = sum_{r,2} - sum_{l-1,2} = k$ 整理可得 $sum_{r,1} - sum_{r,2} = sum_{l-1,1} - sum_{l-1,2}$。$k$ 为常数。

于是便可以锚定 $maxx_i = \max(sum_{i,1},sum_{i,2}, … )$，将 $maxx_i - sum_{i,j}$ 作为第 $i$ 个敌将的特性，使用**哈希**或**动态数组**或**结构体**存储。

时间复杂度 $O(n^2)$。

# map 优化

可以使用 **map** 将**哈希**或**动态数组**或**结构体**与 $i$ 对应。

于是便可以优化 $sum$ 数组只剩一维。~~（为什么题解里都没有优化这一维啊？）~~

时间复杂度 $O(nk)$。

# AC 代码

[目前第二](https://www.luogu.com.cn/record/134714548)

```cpp
#include<bits/stdc++.h>
#define int long long
#define e '\n'
#define base 10093
using namespace std;
map<int,int> q;
int re,f,n,k,x,maxx,ans,sum[31],has;
char c;
int read(){
	f=1;
	re=0;
	c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		re=(re<<3)+(re<<1)+(c^48);
		c=getchar();
	}
	return re*f;
}
void write(int x){
	if(x/10){
		write(x/10);
	}
	putchar(x%10|48);
}
void pc(int x,char c){
	write(x);
	putchar(c);
}
signed main(){
	n=read();
	k=read();
	for(int i = 1;i<=n;i++){
		has=0;
		maxx=0;
		x=read();
		for(int j = 0;j<k;j++){
			sum[j]+=((x>>j)&1);
			maxx=max(maxx,sum[j]);
		}
		for(int j = 0;j<k;j++){
			has=has*base-sum[j]+maxx;
		};
		if(!has||q[has]){//注意特判has==0的情况
			ans=max(ans,i-q[has]);
		}
		else{
			q[has]=i;
		}
	}
	pc(ans,e);
	return 0;
}
```


---

## 作者：Asimplename (赞：0)

## 题目大意

给出 $n$ 个正整数，求出它们中最长的连续的一段，使它们的二进制中的 $k$ 位中每位出现的 $1$ 的个数相同，输出它的长度。



## 50 分解法

可以使用一个二维数组存储每个人的二进制。然后求出他们的前缀和。这样可以求出前 $i$ 个人中每个人二进制中每位的 $1$ 的个数总和。然后枚举两个人 $i$ 和 $j$，求出对于所有 $i \le j$ 的区间 $[i,j]$ 中每位的二进制个数，然后判断其是否相等即可。

时间复杂度 $O(n^2)$。

代码：

```cpp
#include<iostream>
using namespace std;
int n = 0;
int m = 0;
int tt[100010][40];
long long power[31];
int sum[100010][40];
int ans = 0; 
void init(){
	power[0] = 1;
	for(int i = 1; i <= 30; i ++){
		power[i] = power[i - 1] * 2;
	}
}
void two(int day, int x){
	for(int i = 30; i >= 0; i --){
		if(x >= power[i]){
			tt[day][30 - i + 1] = 1;
			x -= power[i];
		}
	}
}
int main (){
	init() ;
	int num = 0;
	cin >> n >> m;
	for(int i = 1; i <= n; i ++){
		cin >> num;
		two(i, num);
	}
	for(int i = 1; i <= n; i ++){
		for(int j = 31 - m + 1; j <= 31; j ++) {
			if(tt[i][j] == 1){
				sum[i][j] = sum[i - 1][j] + 1;
			}
			else{
				sum[i][j] = sum[i - 1][j];
			}
		}
	}
	int p = 31 - m + 1;//最前面一位的下标
	for(int i = 1; i <= n; i ++){
		for(int j = i; j <= n; j ++){
			int index = sum[j][p] - sum[i - 1][p];
			bool flag = true;
			for(int k = p; k <= 31; k ++){
				if(sum[j][k] - sum[i - 1][k] != index){
					flag = false;
					break;
				}
			}
			if(flag == true){
				ans = max(ans, j - i + 1);
			}
		}
	}
	cout << ans;
	return 0;
}
```

## 满分解法

50 分解法中大部分时间复杂度都花在枚举两个人的区间了。可以发现，可以把每个人的前缀和数组的所有位都减去第一位，如果有两个人减完后的前缀和数组相同，这个区间一定合法。

所以我们可以把这些整数合在一起变成一个字符串，存入一个 map 中当作 key，value 设成下标，如果每个字符串能在前面找到，答案尝试更新为当前下标减去找到的人的 value，否则将其加入 map 即可。


```cpp
#include<iostream>
#include<map>
using namespace std;
int n = 0;
int m = 0;
int tt[100010][40];
long long power[31];
int sum[100010][40];
string str[100010];
map<string, int> ma;
int ans = 0; 
void init(){
	power[0] = 1;
	for(int i = 1; i <= 30; i ++){
		power[i] = power[i - 1] * 2;
	}
}
void two(int day, int x){
	for(int i = 30; i >= 0; i --){
		if(x >= power[i]){
			tt[day][30 - i + 1] = 1;
			x -= power[i];
		}
	}
}
string tostring(int x){
	string ret = "";
	if(x < 0){
		ret += '-';
		x = -x;
	}
	if(x == 0){
		ret = '0';
		return ret;
	}
	else{
		while(x){
			ret += x % 10;
			x /= 10;
		}
		for(int i = 0; i < ret.size() / 2; i ++){
			swap(ret[i], ret[ret.size() - i - 1]);
		}
		return ret;
	}
} 
int main (){
	init() ;
	int num = 0;
	cin >> n >> m;
	for(int i = 1; i <= n; i ++){
		cin >> num;
		two(i, num);
	}
	for(int i = 1; i <= n; i ++){
		for(int j = 31 - m + 1; j <= 31; j ++) {
			if(tt[i][j] == 1){
				sum[i][j] = sum[i - 1][j] + 1;
			}
			else{
				sum[i][j] = sum[i - 1][j];
			}
		}
	}
	int p = 31 - m + 1; 
	for(int i = 1; i <= n; i ++){
		string curstr = "";
		for(int j = p; j <= 31; j ++){
			curstr += tostring(sum[i][j] - sum[i][p]);
			if(j != p){
				sum[i][j] -= sum[i][p];
			}
		}
		sum[i][p] = 0; 
		str[i] = curstr;
	}
	for(int i = 1; i <= n; i ++){
		map<string,int> ::iterator it = ma.find(str[i]);
		if(it == ma.end()){
			ma.insert(make_pair(str[i], i));
		}
		else{
			ans = max(ans, i - (*it).second);
		}
	}
	for(int i = 1; i <= n; i ++){//如果减完后一个人前缀和数组的
    所有位相同，那么 1~n的区间也是合法的
		bool flag = true;
		for(int j = p; j <= 31; j ++){
			if(sum[i][j] != sum[i][j - 1]){
				flag = false;
				break;
			}
		}
		if(flag == true){
			ans = max(ans, i);
		} 
	}
	cout << ans;
	return 0;
}
```

---


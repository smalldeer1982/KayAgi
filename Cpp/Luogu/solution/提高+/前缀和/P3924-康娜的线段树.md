# 康娜的线段树

## 题目描述

小林是个程序媛，不可避免地康娜对这种人类的“魔法”产生了浓厚的兴趣，于是小林开始教她OI。

 ![](https://cdn.luogu.com.cn/upload/pic/8043.png) 

今天康娜学习了一种叫做线段树的神奇魔法，这种魔法可以维护一段区间的信息，是非常厉害的东西。康娜试着写了一棵维护区间和的线段树。由于她不会打标记，因此所有的区间加操作她都是暴力修改的。具体的代码如下：

```cpp
struct Segment_Tree{
#define lson (o<<1)
#define rson (o<<1|1)
    int sumv[N<<2],minv[N<<2];
    inline void pushup(int o){sumv[o]=sumv[lson]+sumv[rson];}
    inline void build(int o,int l,int r){
        if(l==r){sumv[o]=a[l];return;}
        int mid=(l+r)>>1;
        build(lson,l,mid);build(rson,mid+1,r);
        pushup(o);
    }
    inline void change(int o,int l,int r,int q,int v){
        if(l==r){sumv[o]+=v;return;}
        int mid=(l+r)>>1;
        if(q<=mid)change(lson,l,mid,q,v);
        else change(rson,mid+1,r,q,v);
        pushup(o);
    }
}T; 
```

在修改时，她会这么写：

```cpp
for(int i=l;i<=r;i++)T.change(1,1,n,i,addv);
```
显然，这棵线段树每个节点有一个值，为该节点管辖区间的区间和。

康娜是个爱思考的孩子，于是她突然想到了一个问题：

如果每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？

康娜每次会给你一个值 $qwq$ ，保证你求出的概率乘上 $qwq$ 是一个整数。

这个问题太简单了，以至于聪明的康娜一下子就秒了。

现在她想问问你，您会不会做这个题呢？


## 说明/提示

对于30%的数据，保证 $1 \leq n,m \leq 100$

对于70%的数据，保证 $1 \leq n,m, \leq 10^{5}$

对于100%的数据，保证$1 \leq n,m \leq 10^6 $

$-1000 \leq a_i,x \leq 1000$


## 样例 #1

### 输入

```
8 2 1
1 2 3 4 5 6 7 8
1 3 4
1 8 2
```

### 输出

```
90
120```

# 题解

## 作者：zcysky (赞：31)

by zcysky

出题人是个智障，这个题可能是洛谷2017年以来月赛最简单的题。

原本出题人这段时间在沉迷Angel Beats，结果他正打算写题面的时候发现了一个了不得的事实：

曾经有一位叫做jxxx\_2的dalao用过Tachibana Kanade作**为某种线段树**的代言人……

于是题面就变成了现在泥萌看到的样子。（还挺萌的不是吗~）

30分：

您会写线段树吗？

直接模拟即可。

什么？不会写？那就把题面上的拖下来即可。


70分：

考虑期望的性质。我们发现期望具有线性性。那么每一棵子树全部被区间加之后对答案的贡献可以单独计算。于是就可以用正常的线段树打标记的做法进行维护。

复杂度： $O(nlogn)$


100分：

回顾计算答案的过程，我们发现对答案产生实际贡献的点只跟叶子节点和他的深度有关。深度可以维护叶子节点的深度前缀和，这样可以 $O(1)$ 的回答询问。

具体贡献的计算方法非常简单，如果还不清楚的可以看标程。


复杂度：$O(n)$


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e7+5;
ll sumv[maxn<<1],a[maxn],s[maxn];
int p[maxn];
namespace io
{
    const int MAXBUF = 1 << 22;
    char B[MAXBUF], *S = B, *T = B;
    #define getc() (S == T && (T = (S = B) + fread(B, 1, MAXBUF, stdin), S == T) ? 0 : *S++)
    template<class Type> inline Type read()
    {
        register Type aa = 0;
        register bool bb = 0;
        register char ch, *S = io::S, *T = io::T;
        for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
            ;
        for(ch == '-' ? bb = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
            aa = aa * 10 + ch - '0';
        io::S = S, io::T = T;
        return bb ? -aa : aa; 
    }
    int (*F)() = read<int>;
    
    template<> inline double read()
    {
        register double aa, bb;
        register char ch;
        register char *S = io::S, *T = io::T;
        while(ch=getc(),(ch<'0'||ch>'9'))
            ;aa=ch-'0';
        while(ch=getc(),(ch>='0'&&ch<='9'))aa=aa*10+ch-'0';
        if(ch=='.'){bb=1;while(ch=getc(),ch>='0'&&ch<='9')bb*=0.1,aa+=bb*(ch-'0');}
        io::S = S, io::T = T;
        return aa;
    }
    
    char buff[MAXBUF], *iter = buff;
    template<class T>inline void P(register T x, register char ch = '\n')
    {
        static int stack[110];
        register int O = 0;
        register char *iter = io::iter;
        if(!x)*iter++ = '0';
        else
        {
            (x < 0) ? x = -x, *iter++ = '-' : 1;
            for(; x; x /= 10)
                stack[++O] = x % 10;
            for(; O; *iter++ = '0' + stack[O--])
                ;
        }
        *iter++ = ch, io::iter = iter;
    }
    
    inline void putc(register char ch) {*iter++ = ch;}
    
    inline void ouput() {fwrite(buff, 1, iter - buff, stdout), iter = buff;}
}
#define lson o<<1
#define rson o<<1|1
int d=0;
inline void build(int l,int r,int o,int t){
    if(l==r){sumv[o]=a[l];p[l]=t;d=max(d,t);return;}
    int mid=l+r>>1;
    build(l,mid,lson,t+1);
    build(mid+1,r,rson,t+1);
    sumv[o]=sumv[lson]+sumv[rson];
}
inline ll query(int l,int r,int o,int t,ll tt){
    if(l==r){return 1LL*(1LL<<t)*(tt+sumv[o]);}
    int mid=l+r>>1;
    return query(l,mid,lson,t-1,tt+sumv[o])+query(mid+1,r,rson,t-1,tt+sumv[o]);
}
ll gcd(ll a,ll b){
    while(b){
        ll r=a%b;a=b;b=r;
    }
    return a;
} 
int main(){
    using io::P;
    int (*F)()=io::read<int>;
    int n=F(),m=F(),yyy=F();
    for(register int i=1;i<=n;++i)a[i]=F();
    build(1,n,1,1);
    ll ans=query(1,n,1,d-1,0),y=1LL<<(d-1);
    ll yy=gcd(y,yyy);yyy/=yy;y/=yy;
    for(register int i=1;i<=n;++i)s[i]=s[i-1]+1LL*(((1LL<<p[i])-1)<<(d-p[i]));
    while(m--){
        int l=F(),r=F(),x=F();
        ans+=(s[r]-s[l-1])*x;
        P(ans/y*yyy);
        io::ouput();
    }
}
```

---

## 作者：Garen (赞：23)

## 上面两位dalao谈笑风生就讲完了这道题，但身为蒟蒻的我一窍不通，好不容易想通了写个题解纪念一下。

2018 09 14 upd:感谢[@cqxxx](https://www.luogu.org/space/show?uid=80885)大佬指正了题解里的错误。致敬！

2018 09 15 upd:再次感谢[@cqxxx](https://www.luogu.org/space/show?uid=80885)大佬与我的交流，终于全面地解决了这道题。再次致敬！

---

这道题要维护一个线段树里面的期望。期望是这么计算的：

> 如果每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？

## 最朴素计算期望的思路

根结点权值乘以1 + 所有第二层结点权值和乘以二分之一 + 所有第三层结点权值和乘以四分之一 直到到达叶子结点为止，把这些东西都加起来就是答案。

## 一个优化的思路

因为从根节点开始进入，每一个唯一的路径会走向唯一的叶子结点，所以我们可以直接维护每个叶子结点的期望。

每个叶子结点对答案的贡献值其实就是**从根结点到达这个叶子结点路径经过的所有点权值和除以$2^{dep - 1}$**。可以证明答案是不会变的，因为每个结点因为深度关系一定会被走固定多次。

这里用到一个简便运算的细节：对于每个结点的贡献都要除以$2^{dep-1}$，我们可以在建树的时候预处理出叶子结点最大深度$maxd$。

然后我们算出各节点权值和乘以$2^{maxd - dep}$，再共同除以$2^{maxd-1}$就是答案了。

## 前缀和维护

经过上面的分析我们发现这个答案就只跟叶子结点的深度有关了。（无法理解的看上面黑体字，然后画个线段树模拟一下）

所以我们可以直接通过维护单个叶子结点对答案的贡献来维护答案的增加。

我们跳回原来的思路。先考虑单节点的加。

是不是从根结点到这个叶子结点的相应值都会增加$x$这么多？

所以单节点值增加$x$，答案就会增加

$$x \times \sum_{i=1}^{dep}{\frac{1}{2^{i-1}}}$$

发现这个东西就是个等比数列，很容易地化简为$1 + 1 - \frac{1}{2^{dep-1}} = 2 - \frac{1}{2^{dep-1}} = \frac{2^{dep}-1}{2^{dep-1}}$。

区间加也好维护，直接弄个前缀和就是了。可以直接乘上去。

## 代码

代码是参考标算的，反手%一波zcy大佬。

```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define lson (root << 1)
#define rson (root << 1 | 1)
const int maxn = 1000005;
ll sum[maxn << 2], lazy[maxn << 2];
ll a[maxn], dep[maxn];
ll s[maxn];
ll n, m, qwq;
ll maxd;

ll read()
{
    ll ans = 0, s = 1;
    char ch = getchar();
    while(ch > '9' || ch < '0'){ if(ch == '-') s = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
    return s * ans;
}
void build(ll root, ll l, ll r, ll d)//相比一般的线段树多统计了深度，并维护最大深度
{
    if(l == r)
    {
        sum[root] = a[l];
        dep[l] = d;
        maxd = std::max(maxd, d);
        return;
    }
    ll mid = (l + r) >> 1;
    build(lson, l, mid, d + 1);
    build(rson, mid + 1, r, d + 1);
    sum[root] = sum[lson] + sum[rson];
}
ll query(ll root, ll l, ll r, ll t, ll tt)//tt表示当前结点以上的那些结点权值和，t的意义看下面
{
    if(l == r) return (1 << t) * (tt + sum[root]);//返回的值是所有的叶子节点，返回值是路径权值和 乘以 2^(maxd - dep[i])
    ll mid = (l + r) >> 1;
    return query(lson, l, mid, t - 1, tt + sum[root]) + query(rson, mid + 1, r, t - 1, tt + sum[root]);
}
ll gcd(ll x, ll y)
{
    if(y == 0) return x;
    return gcd(y, x % y);
}
int main()
{
    n = read(), m = read(), qwq = read();
    for(int i = 1; i <= n; i++) a[i] = read();
    build(1, 1, n, 1);
    ll ans = query(1, 1, n, maxd - 1, 0), y = 1 << (maxd - 1);
    ll yue = gcd(y, qwq);//约分，别中途超出范围了
    y /= yue; qwq /= yue;
    for(ll i = 1; i <= n; i++) s[i] = s[i - 1] + (((1 << dep[i]) - 1) << (maxd - dep[i]));
    //后面加的式子其实是(2^(dep[i]) - 1) * 2^(maxd - dep[i])
    while(m--)
    {
        ll l = read(), r = read(), w = read();
        ans += (s[r] - s[l - 1]) * w;
        printf("%lld\n", ans / y * qwq);// ans / y是真正的期望，y取2^(maxd - 1)
    }
    return 0;
}
```

---

## 作者：Fairicle (赞：10)

这题显然可以在每次修改后采用递推的思想把期望算出，但这样复杂度过高，那么显然是需要 $O(1)$ 或 $O(logn)$ 回答询问的。

那么考虑推一下式子。首先发现，对于一个叶子节点（按照线段树的建树方式），它对它所有的祖先都有贡献。并且，假定当前节点的深度为 $dep$，那么访问它的概率就是 $\dfrac{1}{2^{dep}}$。于是考虑一个深度为 $dep$ 叶子节点总的贡献，为 $a[i]\times(\dfrac{1}{2^{dep}}+\dfrac{1}{2^{dep-1}}+...+\dfrac{1}{2^0})=a[i]\times(2-\dfrac{1}{2^{dep}})$。对于每个节点它的 $dep$ 都是确定的。那么显然可以一遍 $O(n)$ 统计出最初的答案。

考虑修改对答案的影响，设 $l,r,x$。

则答案增大了 $x\times \sum_{i=l}^r(2-\dfrac{1}{2^{dep[i]}})$。显然，我们可以通过维护$2-\dfrac{1}{2^{dep[i]}}
$ 的前缀和来做到 $O(1)$ 回答询问，只需要给它乘一个 $2^{maxdep}$ 就能把它变成整数了。

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
inline int rd(){
    int x=0,flg=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') flg=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
    return x*flg;
}
#define N 1000010
ll a[N],dep[N],n,m,l,r,x;
ll k,mxdep=20,s[N],bas[N],ans;
inline void build(int id,int l,int r,int d){
    if(l==r){
        dep[l]=d;
        s[l]=2*bas[mxdep]-bas[mxdep]/bas[d];
        ans+=a[l]*s[l];
        return;
    }
    int mid=(l+r)>>1;
    build(id<<1,l,mid,d+1),build(id<<1|1,mid+1,r,d+1);
}
int main(){
    //freopen("3924.in","r",stdin);
    n=rd(),m=rd(),k=rd();bas[0]=1;
    for(ri i=1;i<=20;++i) bas[i]=2*bas[i-1];
    for(ri i=1;i<=n;++i) a[i]=rd();build(1,1,n,0);
    for(ri i=1;i<=n;++i) s[i]=s[i]+s[i-1];
    ll g=__gcd(k,bas[mxdep]);k/=g,bas[mxdep]/=g;
    while(m--){
        l=rd(),r=rd(),x=rd();
        ans+=x*(s[r]-s[l-1]);
        printf("%lld\n",ans*k/bas[mxdep]);
    }
    return 0;
}
```



---

## 作者：asuldb (赞：6)

挺妙的一道期望题

首先经过一番简单的思考就会发现对于线段树上的一个叶子节点$x$，深度为$deep[x]$，那么走到这个节点的概率就是$2^{deep[x]}$

我们设$val[x]$表示叶节点$x$到根经过的所有节点的权值和为$val[x]$

于是最后的答案就是

$$qwq*\sum_{i=1}^{n}\frac{val[i]}{2^{deep[i]}}$$

连分母都不一样，于是先通分一下吧

$$qwq*\sum_{i=1}^n\frac{val[i]*2^{maxdep-deep[i]}}{2^{maxdep}}$$

但是要是遇上了区间修改呢，我们完全没有办法维护$val[i]$

好像遇上了瓶颈

于是我们换一个思路，**对整棵线段树来考虑，在算概率的时候，显然树上有很多节点是被多次计入答案的**

比如对于线段树上的节点$[1,n]$每一个点的$val$都算入了这个点

这具有非常妙的性质

我们暂且将分子上的$2^{maxdep-deep[i]}$称为叶节点的权，**那么一个线段树上的非叶节点的总权值就是其内部所有叶子节点的权的和，就是子树和**

那么这个子树和显然就表示**在最终计入答案的时候，这个线段树上的节点管辖的区间和应该乘上多少次**

那么我们现在的答案就可以写成

$$qwq*\sum_{i=1}^M\frac{sum[i]*d[i]}{2^{maxdep}}$$

$sum[i]$表示子树和，$d[i]$表示线段树上的节点$i$所管辖的区间和，$M$为线段树的节点个数

现在再来考虑一下修改一个节点会对整个线段树产生什么样的影响

**显然就是从这个节点一直往上直到根所有节点的管辖的区间和都会相应的增加**

**我们设$pre[i]$(可以理解为根路径前缀和)表示$i$这个节点到根节点经过的所有节点的$sum$的和为多少，如果这次修改的增量为$k$，那么对于整个线段树的答案的贡献就是$pre[i]*k$**

**之后就会发现好像每一个单点之间的修改互不影响，于是如果对一个区间$[x,y]$进行修改的话对答案的贡献就是$k*\sum_{i=x}^ypre[i]$**

于是我们直接对$pre$数组做出一个前缀和就可以快速回答了

代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define maxn 1000005
inline int read()
{
	re char c=getchar();
	re int x=0,r=1;
	while(c<'0'||c>'9') 
	{
		if(c=='-') r=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*r;
} 
inline void write(LL x)
{
	if(x>9) write(x/10);
	putchar(x%10+48);
}
int a[maxn];
int deep[maxn];
int p[maxn],val[maxn];
LL sum[maxn<<2],pre[maxn];
int n,Q,qwq,maxdep;
LL ans,FM;
void build(int x,int y,int dep,LL Sum)//求出所有叶节点的深度，和val
{
	if(x==y)
	{
		deep[x]=dep;
		val[x]=Sum;
		maxdep=max(maxdep,dep);
		return;
	}
	int mid=x+y>>1;
	build(x,mid,dep+1,Sum+p[mid]-p[x-1]),build(mid+1,y,dep+1,Sum+p[y]-p[mid]);
}
LL dfs(int x,int y,int i)//求出线段树上所有点的子树和
{
	if(x==y) return sum[i]=1ll<<(maxdep-deep[x]);
	int mid=x+y>>1;
	return sum[i]=dfs(x,mid,i<<1)+dfs(mid+1,y,i<<1|1);
}
void Pre_Dfs(int x,int y,int i,LL Sum)//求出每一个节点的pre值
{
	if(x==y)
	{
		pre[x]=Sum;
		return;
	}
	int mid=x+y>>1;
	Pre_Dfs(x,mid,i<<1,Sum+sum[i<<1]),Pre_Dfs(mid+1,y,i<<1|1,Sum+sum[i<<1|1]);
}
inline LL gcd(LL a,LL b)
{
	if(!b) return a;
	return gcd(b,a%b);
}
int main()
{
	n=read(),Q=read(),qwq=read();
	for(re int i=1;i<=n;i++) a[i]=read(),p[i]=p[i-1]+a[i];
	build(1,n,0,p[n]);
	dfs(1,n,1);
	Pre_Dfs(1,n,1,sum[1]);
	for(re int i=1;i<=n;i++) pre[i]=pre[i-1]+pre[i];
	for(re int i=1;i<=n;i++) ans+=val[i]*(1ll<<(maxdep-deep[i]));//先求出最开始的答案
	int x,y,z;
	FM=1ll<<maxdep;
	LL r=gcd(qwq,FM);
	qwq/=r,FM/=r;//约分，防止爆long long
	while(Q--)
	{
		x=read(),y=read(),z=read();
		ans+=(pre[y]-pre[x-1])*z;
		if(ans>0) write(qwq*ans/FM);
		else putchar('-'),write(-qwq*ans/FM);
		putchar(10);
	}
	return 0;
}
```

---

## 作者：STrAduts (赞：3)

序列元素在线段树上的深度-感悟

### 0x01 前言

想法源于此题。

这个方面的知识点好像挺新颖的。

于是和机房巨佬一起想出了该命题的 $O(n)$ 解法。

***

### 0x02 算法本身

总所周知，线段树上的节点都对应表示的原序列里的一些结点。

而我们现在需要解决的问题就是：在极快的时间复杂度内求到每个原序列里的元素对应的元区间在线段树中的深度。

也就是求每个叶子节点的深度。

用线段树建树的朴素做法显然是：$O(nlogn)$。

但有些题目会比较恶心，于是我们考虑一种新的做法。

首先明确线段树的一个性质，如果树上有两个节点，且这两个结点表示区间长度相同，则处于相对位置相同的两个分别在这两个节点表示的区间中的原序列中的元素表示的元区间分别到这两个节点的距离相等。（好抽象 www。

于是我们将其剥离出来。

即有两个结点 $p,q$，其中 $p$ 表示区间 $A$，$q$ 表示区间 $B$，且区间 $A$ 的右端点为 $A_l$，区间 $B$ 的右端点为 $B_l$，且记 $f(x)$ 表示 $x$ 为当前所在区间的第几个元素。

则对于任意两点 $m,n$ ，$m \in A,n \in B, f(m) = f(n)$，一定有 $p$ 到表示 $m$ 的元区间的叶子节点的距离等于一定有 $q$ 到表示 $n$ 的元区间的叶子节点的距离。

这其实很显然吧。。因为对于每个表示区间长度的节点，我们线段树往下划分的方式是不变的。

接下来，我们记 $dep(x)$ 表示 $x$ 这个元区间到根节点的距离，即表示 $x$ 这个元区间的叶子节点的深度。$Dep(x)$ 表示 $x$ 这个节点的深度。

那么如果我们现在遍历到了一个节点 $Q$，它表示的区间长度为 $len$，而我们之前也遍历过一个表示区间长度为 $len$ 的节点 $P$，则定会有 $dep(x) = dep(y) - Dep(P) + Dep(Q) (x \in Q,y \in P, f(x) = f(y))$。

这是因为我们有刚刚那个性质嘛，$x$ 这个元区间对应的叶子节点的深度可以分解为这个节点到 $Q$ 的距离和 $Q$ 的深度。因为 $y$ 的深度也可以同样分解，所以前者就等于 $dep(y) - Dep(p)$。

那么我们可以利用一个 `dfs`，遍历线段树上的节点，如果遇到一个节点且之前遇到过表示区间长度相同的节点，则我们可以直接用之前那个点对当前节点表示区间内的所有元素进行深度转移，然后这个分支就可以结束了。

因为有记忆化，且你会发现每个节点我们只会更新一次，于是这就是个类 $O(n)$ 算法。

***

### 0x03 部分实现

```cpp
// q 是一个结构体。
// flag 表示之前是否访问过。
// l 表示上一个访问过的表示区间的长度和当前的一样的节点表示的区间的左端点。
// x 表示上一个访问过的表示区间的长度和当前的一样的节点的深度。
// 按照刚刚推的式子模拟即可。
void Get_Dep(int l, int r, int cnt) {
	if(q[r - l + 1].flag) {
		for(int i = l; i <= r; i++)
			dep[i] = dep[i - l + q[r - l + 1].l] - q[r - l + 1].x + cnt;
		return ;
	}
	if(l == r) {
		dep[l] = cnt;
		return ;
	}
	int mid = (l + r) >> 1;
	Get_Dep(l, mid, cnt + 1);
	Get_Dep(mid + 1, r, cnt + 1);
	q[r - l + 1].flag = true;
	q[r - l + 1].l = l;
	q[r - l + 1].x = cnt;
}
```

### 0x04 应用场景

这道题就可以用我们的思路进行预处理。

首先此题是求在线段树中从根到某一叶子节点经过路径权值和的期望。

朴素期望公式：一颗维护区间和的线段树，答案为每个节点表示的权值乘上每个节点的深度，然后在将它们全部加起来。

于是我们将每个节点的权值再返回到原序列中。

设原序列中元素 $x$ 表示的元区间的深度为 $g(x)$，其表示的数为 $v(x)$。

则原序列的每个元素会对答案产生的贡献为：$v(x) \times \sum_{i = 1}^{g(x)} 2^i$。

很显然当前这个元素在线段树种，会在其元区间到根的每一个节点表示的区间里出现。

其中 $\sum_{i = 1}^{g(x)} 2^i$ 显然可以用上述算法预处理出来。

那么考虑区修。设所改区间为 $[l, r]$。增加量为 $x$。

则这次修改对答案产生的贡献就是 $Δ \times \sum_{x = l}^r\sum_{i = 1}^{g(x)} 2^i$。

那么再维护一个 $\sum_{i = 1}^{g(x)} 2^i$ 的前缀和不就结了吗？

（注，此题若用 `double` 会错掉一个点，可能与数据精度有关，建议直接使用 `long long`。

```cpp
#include <cstdio>

typedef long long LL;
int read() {
    int k = 1, x = 0;
    char s = getchar();
    while (s < '0' || s > '9') {
        if (s == '-')
            k = -1;
        s = getchar();
    }
    while (s >= '0' && s <= '9') {
        x = (x << 3) + (x << 1) + s - '0';
        s = getchar();
    }
    return x * k;
}

const int MAXN = 1e6 + 5;
int a[MAXN], dep[MAXN];
LL w[MAXN], sum[MAXN];

struct node {
	bool flag;
	int l, x;
	node() {}
	node(bool Flag, int L, int X) {
		flag = Flag;
		l = L;
		x = X;
	}
} q[MAXN];

void Get_Dep(int l, int r, int cnt) {
	if(q[r - l + 1].flag) {
		for(int i = l; i <= r; i++)
			dep[i] = dep[i - l + q[r - l + 1].l] - q[r - l + 1].x + cnt;
		return ;
	}
	if(l == r) {
		dep[l] = cnt;
		return ;
	}
	int mid = (l + r) >> 1;
	Get_Dep(l, mid, cnt + 1);
	Get_Dep(mid + 1, r, cnt + 1);
	q[r - l + 1].flag = true;
	q[r - l + 1].l = l;
	q[r - l + 1].x = cnt;
}

int main() {
	int n = read(), m = read(), qwq = read();
	Get_Dep(1, n, 1);	
	w[1] = qwq;
	for(int i = 2; i <= 23; i++) 
		w[i] = w[i - 1] + (qwq >> (i - 1));
	for(int i = 1; i <= n; i++) 
		sum[i] = sum[i - 1] + w[dep[i]];	
	LL ans = 0;	
	for(int i = 1; i <= n; i++) {
		a[i] = read();
		ans += (a[i] * (sum[i] - sum[i - 1]));		
	}	
	for(int i = 1; i <= m; i++) {
		int l = read(), r = read(), x = read();
		ans += ((sum[r] - sum[l - 1]) * x);
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：Silent_thinker (赞：3)

# 思路
看到这道题， 第一反应：“这不就是一个线段树板题”， 这时候突然听见了旁边有人喊道：“这题题解写的是 $O(nlog_2n)$ 只有 $70$ 分，  $O(n)$ 才能过。”所以我苦思冥想十几分钟后， 才想到了正解。
## 操作过程
我们看到这道题， 可以联想到 CSP2020 普及组的第三题， 这道题我是通过短时间预处理出每个节点的修改会对答案的影响来做到快速回答询问的。那么同理， 这道题我们可以发现， 在线段树中， 每个节点对最终期望的贡献都是这个节点的值乘上一个数， 而这个数只跟操作有关。简单来说， 就是因为线段树上每个节点对最后结果的贡献是 $(\frac{1}{2})^k$ 其中 $k$ 是这个节点的深度。然后我们知道每个节点的值是它的两个节点的和， 所以每个叶子的所有祖先产生的贡献都会累加给这个叶子， 那么对于每个叶子， 它对答案的贡献也就是 $(\frac{1}{2})^k + (\frac{1}{2})^{k - 1} + (\frac{1}{2})^{k - 2} + (\frac{1}{2})^{k - 3} + \cdots + (\frac{1}{2})^{0}$ 所以我们只要求出序列中每个位置作为叶节点时的深度， 接下来建立一个前缀和， 每一次修改都只需要 $O(1)$ 的时间把 $[l, r]$ 这个区间的所有会对答案的贡献和乘上加上的值累加进答案中就行了。
## 预处理
有了刚才的分析， 我们发现在 $O(n)$ 预处理才是本题的关键。那么怎么才能如此之快的预处理呢？
首先我们不可能去建树， 建出来就已经成 $O(nlog_2n)$ 了。我们仔细观察线段树， 可以发现有很多长度相同的块， 那么我们就可以利用这些块来实现快速转移。
![线段树.png](http://61.186.173.89:2019/2021/01/14/7d4c580a9a388.png)
我们观察这样一个简单的线段树， 我们可以发现， 对于任意一个块 $x$ ， 它以下的叶子节点的深度都等于 $x$ 到根的距离加上这些叶节点到 $x$ 的距离。而两个相同长度的块， 它们所包含的叶子节点对应位置上分别到两个块的距离相等。所以我们可以记录下第一次查询到长度为 $k$ 的节点时， 这个段的起始位置是哪里， 这个节点的深度是多少。 当第再次搜到另一块长度为 $k$ 的节点 $y$ 时， 我们就可以通过刚才第一次搜索到长度为 $k$ 的节点 $x$ ，而这两个节点中对应的叶节点的深度就是根到它对应在 $x$ 中节点的深度减去 $x$ 的深度加上 $y$ 的深度。
我们就可以写出代码：

```cpp
void dfs (int l, int r, int sum) {
	if (vis[r - l + 1]) {
		for (int i = l; i <= r; i ++) {
			s[i] = s[i - l + sa[r - l + 1]] - sb[r - l + 1] + sum;//转换刚才的记忆化
		}
		
		return;
	}
	if (l == r) {//如果到叶子直接记录返回
		s[l] = sum;
		
		return ;
	}
	
	int mid = (l + r) >> 1;
	
	dfs (l, mid, sum + 1);
	dfs (mid + 1, r, sum + 1);
   //记忆化
	sa[r - l + 1] = l;
	sb[r - l + 1] = sum;
	vis[r - l + 1] = 1;
	
	return ;
} 
```
## 最后完整代码
对于后面的查询就很简单了， 直接放代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

#define MAXN 1000000
#define MAXM 100

int sa[MAXN + 5];
int sb[MAXN + 5];
int s[MAXN + 5];
bool vis[MAXN + 5];
long long sn[MAXN + 5];
long long s1[MAXM + 5], s2[MAXM + 5];
int w;//记录最大深度

void dfs (int l, int r, int sum) {
	if (vis[r - l + 1]) {
		for (int i = l; i <= r; i ++) {
			s[i] = s[i - l + sa[r - l + 1]] - sb[r - l + 1] + sum;
		}
		
		return;
	}
	if (l == r) {
		s[l] = sum;
		w = max (w, sum);
		
		return ;
	}
	
	int mid = (l + r) >> 1;
	
	dfs (l, mid, sum + 1);
	dfs (mid + 1, r, sum + 1);
	sa[r - l + 1] = l;
	sb[r - l + 1] = sum;
	vis[r - l + 1] = 1;
	
	return ;
} 
int main () {
	int n, m;
	long long qwq;
	
	scanf ("%d %d %lld", &n, &m, &qwq);
	dfs (1, n, 1);
	s1[1] = qwq;//题目要求处理分母
	s2[1] = qwq;
	for (int i = 2; i <= w; i ++) {
		s1[i] = s1[i - 1] >> 1;
		s2[i] = s2[i - 1] + s1[i];
	}
	for (int i = 1; i <= n; i ++) {
		sn[i] = sn[i - 1] + s2[s[i]];
	}
	
	long long ans = 0;
	
	for (int i = 1; i <= n; i ++) {
		int x;
		
		scanf ("%d", &x);
		ans += (sn[i] - sn[i - 1]) * x;//累加初始序列
	}
	for (int i = 1; i <= m; i ++) {
		int l, r;
		long long x;
		
		scanf ("%d %d %lld", &l, &r, &x);
		ans += (sn[r] - sn[l - 1]) * x;//累加每次操作
		printf ("%lld\n", ans);
	}
	
	return 0;
}
```

---

## 作者：Fool_Fish (赞：2)

# 思路

对于本题，我们有一个最朴素的想法就是对每一层求一个和，乘上到达这一层的概率，即 $\frac{1}{2^{dep-1}}$,但这样是无法比较快速的应对修改操作的

基于这种思路，我们换个思考的方向，即思考一个 $i$

显然包含 $i$ 的块是连续的，如下图：

![](http://61.186.173.89:2019/2021/01/14/7ca0b97c191dc.png)

对于包含 $2$ 下标的块，一定是连续的

![](http://61.186.173.89:2019/2021/01/14/580890c329424.png)

而他所做的贡献就是上图标注的

所以现在我们只需要知道每一个下标 $i,i\in [1,n]$，它对应的叶节点的深度是多少

所以为了实现这一目标，我们来单独去求这个东西：

求深度是可以用一个搜索来解决的，但是我们要快，一个搜索是不够的

那么优化搜索的方法是什么？

记忆化！

对的，我们在这里有一个比较好玩的性质，对于每一个长度相同的区间，这两个区间中相对应的两个下标 $i,j$ 到这两个下标的最深深度距离是一样的

可能有点抽象，我们举个栗子：

上图中第 $2$ 层的 $[1,3]$ 和 $[4,6]$，区间长度一样


那么$[1,3]$区间中的第 $2$ 个数也就是 $2$，它到$[2,2]$的距离是 $2$；

$[4,6]$区间中的第 $2$ 个数也就是 $5$，它到$[5,5]$的距离也是 $2$；

当然，我们多找几个来举例，也是一样的

也就是说我们是可以通过这种方法实现记忆化

```cpp
void dfs(int l,int r,int sum){
	if(mem[r-l+1]==true){
		for(int i=l;i<=r;i++){
			s[i]=s[i-l+s1[r-l+1]]-s2[r-l+1]+sum;
		}
		return;
	}
	if(l==r){
		s[l]=sum;
		w=max(w,sum);
		return;
	}
	int mid=(l+r)>>1;
	dfs(l,mid,sum+1);
	dfs(mid+1,r,sum+1);
	s1[r-l+1]=l;
	s2[r-l+1]=sum;
	mem[r-l+1]=true;
}
```

处理好了深度，剩下的事情就真的简单了，一个前缀和，$over$

# code

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1000005;
int s1[MAXN];
int s2[MAXN];
long long s[MAXN];
bool mem[MAXN];
long long pre[MAXN];
int dep[MAXN],pre_d[MAXN];
int w;
void dfs(int l,int r,int sum){
	if(mem[r-l+1]==true){
		for(int i=l;i<=r;i++){
			s[i]=s[i-l+s1[r-l+1]]-s2[r-l+1]+sum;
		}
		return;
	}
	if(l==r){
		s[l]=sum;
		w=max(w,sum);
		return;
	}
	int mid=(l+r)>>1;
	dfs(l,mid,sum+1);
	dfs(mid+1,r,sum+1);
	s1[r-l+1]=l;
	s2[r-l+1]=sum;
	mem[r-l+1]=true;
}
int main(){
	int n,m;
	long long qwq;
	scanf("%d %d %lld",&n,&m,&qwq);
	qwq*=128;
	dfs(1,n,1);
	dep[1]=qwq;
	pre_d[1]=qwq;
	for(int i=2;i<=w;i++){
		dep[i]=dep[i-1]>>1;
		pre_d[i]=pre_d[i-1]+dep[i];
	}
	for(int i=1;i<=n;i++){
		pre[i]=pre[i-1]+pre_d[s[i]];
	}
//	for(int i=1;i<=n;i++){
//		cout<<pre[i]<<endl;
//	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		ans+=(pre[i]-pre[i-1])*x;
	}
	for(int i=1;i<=m;i++){
		int l,r,x;
		scanf("%d %d %d",&l,&r,&x);
		ans+=(pre[r]-pre[l-1])*x;
		printf("%lld\n",ans/128);
	}
return 0;
}

```




---

## 作者：star_magic_young (赞：1)

我们可以画图~~找规律~~

~~这里没图,要看图可以去看M_sea dalao的题解(逃~~

可以发现单个节点$i$对答案的贡献为该节点的点权$*\frac{1}{2^{dep_i}}$($dep_i$为从上往下$i$节点所在的层数-1,也就是深度,令根节点的$dep=0$)

我们可以发现,所有叶子节点的深度都是最大深度(记为$ma$)或者最大深度-1,所以除开最下面一层,从上往下第$i$层的贡献都是序列中所有数之和$*\frac{1}{2^{i-1}}$,最下面一层的每个叶子节点的贡献就是点权$*\frac{1}{2^{ma}}$.为了方便,下面算答案时*把所有数$*2^{ma}$,输出的时候再除掉*

我们先预处理最初的答案,记$b=\sum_{j=1}^{ma}2^j$,序列中第$i$个数的贡献为$a_i*(b+[dep_{i\text{在线段树中对应的叶子节点}}=ma])$(如果是最后一层就多加上$a_i$是吧)

每次的区间加法,记$c=$区间内深度为$ma$的叶子节点个数,可以发现答案加上了$x*(r-l+1)*b+x*c$

最后答案要$/2^{ma}*qwq$,并且注意将$2^{ma}$和$qwq$约分,不然会爆$long\ long$

~~我做题时居然那啥到强行用树状数组求前缀和qwq~~

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define LL long long
#define il inline
#define re register
#define db double
#define max(a,b) ((a)>(b)?(a):(b))

using namespace std;
const int N=1000000+10;
il LL rd()
{
    re LL x=0,w=1;re char ch=0;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
#define lc (o<<1)
#define rc ((o<<1)|1)
#define mid ((l+r)>>1)

int n,m,a[N],mm;
LL qwq,b=1,ans,c[N];
void init(int k,int l,int r)
{
  if(l==r){mm=max(mm,a[l]=k);return;}
  init(k+1,l,mid),init(k+1,mid+1,r);
}
il LL gcd(LL a,LL b){return b?gcd(b,a%b):a;}

int main()
{
  n=rd(),m=rd(),qwq=rd();
  init(0,1,n);
  b=(1ll<<(mm+1))-2;    //这就是题解中的b
  for(re int i=1;i<=n;i++)
    {
      LL x=rd();
      ans+=x*b;
      c[i]+=c[i-1];
      if(a[i]==mm) ++c[i],ans+=x;
    }
  mm=1ll<<mm;
  LL gg=gcd(mm,qwq);mm/=gg,qwq/=gg;
  for(re int i=1;i<=m;i++)
    {
      int l=rd(),r=rd();
      LL x=rd();
      ans+=1ll*(r-l+1)*x*b+(c[r]-c[l-1])*x;
      printf("%lld\n",ans/mm*qwq);
    }
  return 0;
}


```

---

## 作者：attack (赞：1)

这题输出的时候是不需要约分的qwq

如果你和我一样为了AC不追求效率的话直接`#define int __int128`就行了。。

代码十分清新


```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int MAXN = 1e6 + 10;
inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
void print(int x) {
	if(x < 0) putchar('-'), x = -x;
    if (x > 9) print(x / 10);
    putchar('0' + x % 10);
}
int N, M, qwq, s[MAXN], a[MAXN], ans, Lim;
int get(int dep) {
	return 1 << (Lim - (dep - 1));
}
void Build(int l, int r, int dep, int sum) {
	ans += (a[r] - a[l - 1]) * get(dep);
	if(l == r) {s[l] = sum + get(dep); return ;}
	int mid = l + r >> 1;
	Build(l, mid, dep + 1, sum + get(dep)); 
	Build(mid + 1, r,dep + 1, sum + get(dep));
}
signed main() {
	N = read(); M = read(); qwq = read();
	for(int cur = 1; cur <= N; Lim ++, cur <<= 1);
	for(int i = 1; i <= N; i++) a[i] = read(), a[i] += a[i - 1];
	Build(1, N, 1, 0);
	for(int i = 1; i <= N; i++) s[i] += s[i - 1];
	while(M--) {
		int l = read(), r = read(), v = read();
		ans += ((s[r] - s[l - 1]) * v);
		print(((ans * qwq) >> Lim)); putchar('\n');
	}
	return 0;
}
```

---

## 作者：MILLOPE (赞：0)

## 题目
[题目传送门](https://www.luogu.org/problemnew/show/P3924)

小林是个程序媛，不可避免地康娜对这种人类的“魔法”产生了浓厚的兴趣，于是小林开始教她OI。
![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3Uub3JnL3VwbG9hZC9waWMvODA0My5wbmc)

今天康娜学习了一种叫做线段树的神奇魔法，这种魔法可以维护一段区间的信息，是非常厉害的东西。康娜试着写了一棵维护区间和的线段树。由于她不会打标记，因此所有的区间加操作她都是暴力修改的。具体的代码如下：
```cpp
struct Segment_Tree{
#define lson (o<<1)
#define rson (o<<1|1)
    int sumv[N<<2],minv[N<<2];
    inline void pushup(int o){sumv[o]=sumv[lson]+sumv[rson];}
    inline void build(int o,int l,int r){
        if(l==r){sumv[o]=a[l];return;}
        int mid=(l+r)>>1;
        build(lson,l,mid);build(rson,mid+1,r);
        pushup(o);
    }
    inline void change(int o,int l,int r,int q,int v){
        if(l==r){sumv[o]+=v;return;}
        int mid=(l+r)>>1;
        if(q<=mid)change(lson,l,mid,q,v);
        else change(rson,mid+1,r,q,v);
        pushup(o);
    }
}T; 
```
在修改时，她会这么写：
```cpp
for(int i=l;i<=r;i++)T.change(1,1,n,i,addv);
```
显然，这棵线段树每个节点有一个值，为该节点管辖区间的区间和。

康娜是个爱思考的孩子，于是她突然想到了一个问题：

如果每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？

康娜每次会给你一个值 qwq ，保证你求出的概率乘上 qwq 是一个整数。

这个问题太简单了，以至于聪明的康娜一下子就秒了。

现在她想问问你，您会不会做这个题呢？

输入输出格式
输入格式：
第一行整数 n,m,qwq表示线段树维护的原序列的长度，询问次数，分母。

第二行 n 个数，表示原序列。

接下来 m 行，每行三个数 l,r,x表示对区间[l,r] 加上 x
输出格式：
共 m 行，表示期望的权值和乘上qwq结果。
输入输出样例
输入样例#1： 
```
8 2 1
1 2 3 4 5 6 7 8
1 3 4
1 8 2
```
输出样例#1： 
```
90
120
```
## 题解
- 朴素的想法：设最终结果为$ans$，每一层的点权和为$val_i$，$maxD$为最大层数，那么
$$
ans=\sum_{i}^{maxD}val_i*\frac{1}{2^{i-1}}
$$
- 然后画个图我们可以发现，从根节点到叶子节点的路径有且只有一条，那么我们可以方便的维护每个叶子节点的期望值，设从根节点到叶子节点的权值和为$sum_i$，每一个节点的深度为$d_i$，每个节点的期望为$ans_i$，那么
$$
ans_i=sum_i * \frac{1}{2^{d_i-1}}
$$
- 然后我们可以维护一个深度的前缀和我们就可以$O(1)$回答询问了。
- 对于上面的式子
$$
ans_i=sum_i * \frac{1}{2^{d_i-1}}
$$

- 每次记录时都除以$2^{d_i-1}$非常麻烦，所以我们可以化简一下

$$ans_i=sum_i * \frac{1}{2^{d_i-1}}=sum_i*\frac{2^{maxD}}{2^{d_i-1+maxD}}=sum_i*\frac{2^{maxD-d_i}}{2^{maxD-1}}$$

- 我们在记录时可以直接记录
$sum_i*2^{maxD-d_i}$，
最后直接除以
$2^{maxD-1}$即可
- 对于每次修改来说因为每个点的权值都会改变，设增加的数为$x$，那么增加的期望值为

- 可以发现上边两个式子的分母都是$2^{maxD-1}$，我们在统计答案时直接算就好了
- ~~其实瞎搞一下就可以了~~

## code
```cpp
#include <bits/stdc++.h> 
using namespace std; 
typedef long long LL; 
const int maxn = 1e6 + 100; 

template <typename T> 
inline void read(T &s) {
	s = 0; 
	T w = 1, ch = getchar(); 
	while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }
	while (isdigit(ch)) { s = (s<<1) + (s<<3) + (ch^48); ch = getchar(); }
	 s *= w;  
}

LL n, m, qwq, maxD, Div, ans;  
LL a[maxn], dep[maxn], sum[maxn]; 
struct node {
	LL l, r; 
	LL sum, add; 
} t[maxn * 4]; 

inline void build(LL p, LL l, LL r, LL d) {
	t[p].l = l, t[p].r = r; 
	if (l == r) {
		t[p].sum = a[l]; 
		dep[l] = d; 
		maxD = max(maxD, d); 
		return ; 
	}
	LL mid = (l + r)>>1; 
	build(p<<1, l, mid, d + 1); 
	build(p<<1|1, mid + 1, r, d + 1); 
	t[p].sum = t[p<<1].sum + t[p<<1|1].sum; 
}

inline LL query(LL p, LL l, LL r, LL d, LL sum) {
	if (l == r) {
		return (1<<d) * (sum + t[p].sum); 
	}
	else {
		int mid = (l + r)>>1; 
		return query(p<<1, l, mid, d - 1, sum + t[p].sum) + query(p<<1|1, mid + 1, r, d - 1, sum + t[p].sum); 
	}
}

inline LL gcd(LL x, LL y) {
	return y ? gcd(y, x % y) : x; 
}

int main() {
	read(n), read(m), read(qwq); 
	for (int i = 1; i <= n; ++i) read(a[i]); 
	build(1, 1, n, 1); 
	ans = query(1, 1, n, maxD - 1, 0); 
	Div = 1<<(maxD - 1); 
	LL g = gcd(qwq, Div); 
	Div /= g; qwq /= g; 
	for (int i = 1; i <= n; ++i) {
		sum[i] = sum[i - 1] + (((1<<dep[i]) - 1) << (maxD - dep[i])); 
	}
	for (int i = 1; i <= m; ++i) {
		LL l, r, x; 
		read(l), read(r), read(x); 
		ans += (sum[r] - sum[l-1]) * x; 
		printf("%lld\n", ans / Div * qwq); 
	}
	return 0; 
}
```

---


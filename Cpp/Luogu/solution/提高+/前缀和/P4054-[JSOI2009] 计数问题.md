# [JSOI2009] 计数问题

## 题目描述

一个 $n \times\ m$ 的方格，初始时每个格子有一个整数权值。接下来每次有 2 种操作：

- 改变一个格子的权值；

- 求一个子矩阵中某种特定权值出现的个数。


## 说明/提示

【数据规模与约定】

对于 $30\%$ 的数据，满足：$n,m\le 30$，$Q\le 5\times 10^4$。

对于 $100\%$ 的数据，满足：$1\le n,m\le 300$，$1\le Q\le 2\times 10^5$。

对于操作 1，保证：$1\le x
\le n$，$1\le y\le m$，$1\le c\le 100$；

对于操作 2，保证：$1\le x_1≤x_2\le n$，$1\le y_1\le y_2\le m$，$1\le c\le 100$。



## 样例 #1

### 输入

```
3 3
1 2 3
3 2 1
2 1 3
3
2 1 2 1 2 1
1 2 3 2
2 2 3 2 3 2```

### 输出

```
1
2
```

# 题解

## 作者：Dry_ice (赞：75)

本~~蒟蒻~~第四篇题解，上次提交写得太少了，这次望管理给过！

~~貌似是个树状数组模板题~~

## 写在前面
$Q$：树状数组是什么？

$A$：~~是一种数据结构。~~

定义原一维数组为 $A$ ，则树状数组 $C$ 的值为：
$$C_1=A_1$$
$$C_2=A_1+A_2$$
$$C_3=A_3$$
$$C_4=A_1+A_2+A_3+A_4$$
$$C_5=A_5$$
$$C_6=A_5+A_6$$
$$C_7=A_7$$
$$C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8$$
以此类推。

介绍一下著名的 $lowbit$ 函数吧。

### lowbit
$Q$：$lowbit$ 求的是什么？

$A$：整数转为二进制后，最后一位 $1$ 及之后的所有 $0$ 所构成的数值。

$lowbit$ 看似麻烦，一看代码，发现也只有一行就解决了：
```cpp
int lowbit(int x) {
	return x & -x;
}
```
这里涉及到了二进制补码的知识。

回到本题，你会豁然开朗！

## 思路
- 数据结构：树状数组
- 变化：多记一维 $color$
- 就没有其他改动了

## CODE
```cpp
#include <stdio.h>
int n, m;
int a[301][301];
int c[301][301][101];
inline void add(int x, int y, int k, int color) {
	for (int i = x; i <= n; i += i & -i)
		for (int j = y; j <= m; j += j & -j)
			c[i][j][color] += k;
}
inline int query(int x, int y, int color) {
	int ret = 0;
	for (int i = x; i; i -= i & -i)
		for (int j = y; j; j -= j & -j)
			ret += c[i][j][color];
	return ret;
}
int main(void) {
	scanf("%d %d", &n, &m);
	int Q, x1, y1, x2, y2, color;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%d", &color);
			a[i][j] = color;
			add(i, j, 1, color);
		} 
	for (scanf("%d", &Q); Q--; ) {
		int op;
		scanf("%d", &op);
		if (op == 1) {
			scanf("%d %d %d", &x1, &y1, &color);
			add(x1, y1, -1, a[x1][y1]);
			a[x1][y1] = color;
			add(x1, y1, 1, color);
		}
		else {
			scanf("%d %d %d %d %d", &x1, &x2, &y1, &y2, &color);
			printf("%d\n", query(x2, y2, color) - query(x1 - 1, y2, color) - query(x2, y1 - 1, color) + query(x1 - 1, y1 - 1, color));
		}
	}
	return 0;
}
```

## 推荐树状数组题单
### 官方精选
- [【数据结构2-2】线段树与树状数组](https://www.luogu.com.cn/training/206)

### 用户分享
- [树状数组模板题](https://www.luogu.com.cn/training/3079)

- [CMの树状数组](https://www.luogu.com.cn/training/1143)

## The end. Thanks.

~~（走过路过一定要赞过啊~~

---

## 作者：灵乌路空 (赞：18)

先无良宣传一下博客 $wwwwww$    
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)


---

### 知识点 : 多维树状数组 . 


二维树状数组模板题 .   

可以发现 , 矩阵中值的值域很小   
$w\le 100$  
考虑暴力思路,  
	
构建 $100$ 个二维树状数组,  
分别存储各数值 ,  
在矩阵中出现的次数.  

---

- 对于单点修改操作:    
  将点 $(x,y)$ ,由值 $a$ 修改为 $b$.  
  
  先对值 $a$ 的树状数组 进行修改,  
  对应位置的出现次数 $-1$ .    
		 
  再对值 $b$ 的树状数组 进行修改,    
  对应位置的出现次数 $+1$ .    
   
-  对于区间查询操作:   
   直接查询 对应子矩阵中  
	出现次数即可   
	  
另外 , $bzoj$ 上的此题空间限制只有 $64mb$  
要注意不能把所有变量,  
都设置为 $long\ long$ .     

---
附 代码:

```cpp
#include<cstdio>
#include<ctype.h>
#define ll long long
#define lowbit(x) -x&x
//=============================================================
int N,M,Q;
int map[301][301];
int tree[101][301][301];
//=============================================================
inline int read()
{
	int fl=1,w=0;char ch=getchar();
	while(!isdigit(ch) && ch!='-') ch=getchar();
	if(ch=='-') fl=-1;
	while(isdigit(ch)){w=w*10+ch-'0',ch=getchar();}
	return fl*w;
}
inline void add(int type,int x,int y,int z)//修改操作,将此点权值设为type,并使其次数+=z 
{
	map[x][y]=type;//更新 
	for(int i=x;i<=N;i+=lowbit(i))//进行拆分 
	  for(int j=y;j<=M;j+=lowbit(j))
	    tree[type][i][j]+=z;
}
inline ll sum(int type,int x,int y)//查询矩阵(1,1)--(x,y)中值type的出现次数 
{	
	int ret=0;
	for(int i=x;i;i-=lowbit(i))//进行拆分 
	  for(int j=y;j;j-=lowbit(j))
	    ret+=tree[type][i][j];//更新 
	return ret;
}
//=============================================================
signed main()
{
	N=read(),M=read();
	for(int i=1;i<=N;i++)
	  for(int j=1;j<=M;j++)//构造初始树状数组 
	  {
	  	int w=read();
	  	add(w,i,j,1);
	  }
	
	Q=read();
	for(int i=0;i<Q;i++)
	{
	  int opt=read();
	  if(opt==1)//修改操作 
	  {
	  	int x=read(),y=read(),type=read();
	  	add(map[x][y],x,y,-1);//原值出现次数-1 
	  	add(type,x,y,1);//新值出现次数+1 
	  }
	  else
	  {
	  	int x1=read(),x2=read(),y1=read(),y2=read(),type=read();
	  	ll ans1=sum(type,x2,y2),ans2=sum(type,x1-1,y1-1);//计算子矩阵的值 
		printf("%lld\n",ans1-sum(type,x1-1,y2)-sum(type,x2,y1-1)+ans2);
	  }
	}
}
```


---

## 作者：moye到碗里来 (赞：9)

不知道为什么评分是省选难度。。。。这道题的思路很简单，就是建造col个树状数组分别统计，因为各种颜色之间是没有相互作用的，注意在改颜色的时候同时还要把之前的删掉再加新的。。

还有此题输入巨坑。。mmp在其他oj交了十几次才发现输入

2 x1 x2 y1 y1 c

** x1 x2 y1 y2 c !!!! **

简直有毒

以下代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 305;
int tre[MAXN][MAXN][MAXN];
int col[MAXN][MAXN];
int n,m;
inline int lowbit(int x){return  x  & (-x);}
inline void add(int v,int x,int y,int z){
	for(int i = x;i <= n; i += lowbit(i)){
		for(int j = y; j <= m; j += lowbit(j)){
			tre[v][i][j] += z;
		}
	}
	return ;
}
inline int sum(int v,int x,int y){
	int ans = 0;
	for(int i = x; i > 0; i -= lowbit(i)){
		for(int j = y; j > 0; j -= lowbit(j)){
			ans += tre[v][i][j];
		}
	}
	return ans;
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	scanf("%d %d",&n,&m);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			int z;scanf("%d",&z);
			col[i][j] = z;
			add(z,i,j,1);
		} 
	}
	int q;scanf("%d",&q);
	for(int i = 1; i <= q; i++){
		int opt,x1,x2,c,y1,y2;scanf("%d",&opt);
		if(opt == 1){
			scanf("%d %d %d",&x1,&y1,&c);
			add(col[x1][y1],x1,y1,-1);
			col[x1][y1] = c;
			add(col[x1][y1],x1,y1,1);
		}
		else{
			scanf("%d %d %d %d %d",&x1,&x2,&y1,&y2,&c);
			printf("%d\n",sum(c,x2,y2) - sum(c,x1 - 1,y2) - sum(c,x2,y1 - 1) + sum(c,x1 - 1,y1 - 1));
		}
	}
	return 0;
}
```

---

## 作者：_edge_ (赞：4)

总感觉好奇怪，明明一道 pj T2 的题目却用了这么神奇的数据结构。另外，评分好像也不太对呢。。。

首先我们考虑对于每一个矩阵实际上可以看成几行单独的。

考虑处理一个子问题，即 $n=1$ 时如何思考，显然可以维护一个前缀和，对于修改操作来说，只会影响后面的。

因此我们可以搞一个 `sum[x][y][z]` 表示 $x$ 种颜色在第 $y$ 行从第 $1$ 列到第 $z$ 列出现次数。

然后统计答案的时候可以直接枚举几行就可以了。

更加具体一点，对于一个点来说，它的权值改变会影响什么？

设这个点为 $(x,y)$

那么首先，对于它后面的即 `sum[a[x][y]][x][y~n]` 是不是都会产生影响，这个影响是 $-1$。

同理对于改变权值变到的那个权值 `sum[v][x][y~n]` 都会 $+1$。

那么对于统计答案的呢？

那就是 $\sum \limits _{i=x}^{x1} sum[v][i][y]-sum[v][i][y-1]$ 也就是对于每一行的 $v$ 我们都暴力进行统计。

总结一下，对于单点修改，其实可以直接做到 $O(1)$ 但是我们在这道题目上，必须拿掉它的 $O(1)$ 换查询的 $O(n)$。 

当然，这道题目也完全可以用树状数组来解，并且复杂度更优一点。

不过更推荐的是暴力好想的做法，毕竟拿分才是关键。

时间复杂度 $O(n \times q)$。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=305;
const int INFN=105;
int n,m,sum[INFN][INF][INF],a[INF][INF],q;
signed main()
{
	scanf("%d %d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for (int k=1;k<=100;k++)
		for (int i=1;i<=n;i++)
			for (int j=1;j<=m;j++)
				sum[k][i][j]=sum[k][i][j-1]+(a[i][j]==k);
	scanf("%d",&q);
	while (q--) {
		int op=0,x=0,y=0,z=0,xx=0,yy=0;
		scanf("%d",&op);
		if (op==1) {
			scanf("%d %d %d",&x,&y,&z);
//			swap(x,y);
			for (int i=y;i<=m;i++)
				sum[a[x][y]][x][i]--;
			for (int i=y;i<=m;i++)
				sum[z][x][i]++;
			a[x][y]=z;
		}
		else {
			scanf("%d %d %d %d %d",&x,&xx,&y,&yy,&z);
			int ans=0;
			for (int i=x;i<=xx;i++)
				ans+=sum[z][i][yy]-sum[z][i][y-1];
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```


---

## 作者：sukimo (赞：4)

可以说是二维$BIT$单点修改区间查询的板子题。原理和一维$BIT$类似。考虑到数据规模不大，可以对于每一个权值开一个$BIT$，然后修改时对于原权值的$BIT$对应位置$--$，新权值的$BIT$对应位置$++$。

代码：

```
#include<bits/stdc++.h>
#define MXq 200005
using namespace std;
int n,m,mat[305][305],ans[MXq],tree[105][305][305];
int lowbit(int x){return x&-x;}
void add(int type,int x,int y,int v){
	while(x<=n){
		int _y=y;while(_y<=m){tree[type][x][_y]+=v;_y+=lowbit(_y);}x+=lowbit(x);
	}
}
int pref(int type,int x,int y){
	int tot=0;
	while(x>=1){
		int _y=y;while(_y>=1){tot+=tree[type][x][_y];_y-=lowbit(_y);}x-=lowbit(x);
	}
	return tot;
}
int query(int type,int x1,int y1,int x2,int y2){
	return pref(type,x2,y2)+pref(type,x1-1,y1-1)-pref(type,x1-1,y2)-pref(type,x2,y1-1);
}
int main(){
	int q,_top=0;cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			{cin>>mat[i][j];add(mat[i][j],i,j,1);}
	cin>>q;
	for(int i=1;i<=q;i++){
		int _q;cin>>_q;
		if(_q==1){
			int x,y,c;cin>>x>>y>>c;add(mat[x][y],x,y,-1);add(c,x,y,1);mat[x][y]=c;
		}
		else{
			int x1,y1,x2,y2,c;cin>>x1>>x2>>y1>>y2>>c;
			ans[++_top]=query(c,x1,y1,x2,y2);
		}
	}
	for(int i=1;i<=_top;i++)cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：做梦想Peach (赞：3)

最近学习了树状数组，感觉有点晕![/yun](https://cdn.luogu.com.cn/upload/pic/62240.png)。

这题也就是二维的单点更新、区间求和。（没想到省选会考模板题。

可以把它想成线性的，下面我们来举个栗子，例如，这是$A[][]$第$1$行的一维树状数组：

$C[1][1]=a_{1,1}$，

$C[1][2]=a_{1,1}+a_{1,2}$，

$C[1][3]=a_{1,3}$，

$C[1][4]=a_{1,1}+a_{1,2}+a_{1,3}+a_{1,4}$，

$C[1][5]=a_{1,5}$，

$C[1][6]=a_{1,5}+a_{1,6}$，……

**~~以此类推，举一反三~~**

**然后对于区间查询操作:直接查询对应子矩阵中出现次数即可。**

## Code：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
int f[310][310][310],n,m,r,l,k,x,y,c,t,A[310][310],i,j;
int Lowbit (int t) {
	return t&(-t);
}//著名的Lowbit函数：lowbit(t)=2^k。
void Update (int x,int y,int v,int k) {
	int i,j;
	for (i=x;i<=n;i+=Lowbit (i)) 
		for (j=y;j<=m;j+=Lowbit (j)) 
			f[i][j][v]+=k;
	return;
}
int Getans (int x,int y,int v) {
	int i,j,ans=0;
	for (i=x;i>0;i-=Lowbit (i)) 
		for (j=y;j>0;j-=Lowbit (j)) 
			ans+=f[i][j][v];
	return ans;
}//区间求和。
int main () {
	scanf ("%d%d",&n,&m);
	for (i=1;i<=n;i++){
		for (j=1;j<=m;j++) {
			scanf ("%d",&A[i][j]);
			Update (i,j,A[i][j],1);
		}
	}
	scanf ("%d",&t);
	while (t--) {
		scanf ("%d%d%d%d",&k,&x,&y,&c);
		if (k==1) {
			Update (x,y,A[x][y],-1);
			A[x][y]=c;
			Update (x,y,A[x][y],1);//操作一。
		}
		else {
			scanf ("%d%d",&r,&l);
			printf ("%d\n",Getans (y,r,l)-Getans (x-1,r,l)-Getans (y,c-1,l)+Getans (x-1,c-1,l));//输出矩阵区间和。
		}
	}
	return 0;
}
```
然后这题是不是可以把“**概率论，统计**”这个标签去掉awa。


---

## 作者：Wuyanru (赞：3)

前置芝士：
[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

看到这道题我的第一反应：树状数组套树状数组。

为什么呢？

因为普通的树状数组足以进行单点修改与区间查询的操作，而且树状数组的常数也比线段树小很多。

但是查询的是某一个数字在区间的个数，我们该怎么办呢？

我们可以注意到查询数字的数据范围 $ 1\le c\le 100 $,这就意味着我们可以直接暴力开 $ 100 $ 个树状数组套树状数组。

下来我们来分析复杂度。

空间复杂度为 $ \Theta\left(100mn\right) $,只需要不到 $ 35 $MB 的空间。

时间复杂度呢？

建树时，一共会处理 $ nm $ 个格子，所以建树时间复杂度为 $ \Theta\left(nm\log_2m\log_2n\right) $。

每次修改会同时修改两维，所以单次修改为 $ \Theta\left(\log_2m\log_2n\right) $。

查询时也会同时查询两维，所以单次查询也为 $ \Theta\left(\log_2m\log_2n\right) $。

最后查询次数为 $ Q $ 次，最坏情况下，时间复杂度为 $ \Theta\left(Q\log_2m\log_2n+nm\log_2m\log_2n\right) $，差不多为 $ 2.4\times 10^7 $,离超时还有一定距离。

AC代码：
```
#include<cstdio>
using namespace std;
int tr[101][301][301];
int a[301][301];
int m,n,k;
int lowbit(int i) {
	return i&(-i);
}
void ji(int x,int y,int num,int k) {
	if(num<1||num>100)
		return ;
	for(int flag1=x; flag1<=m; flag1+=lowbit(flag1))
		for(int flag2=y; flag2<=n; flag2+=lowbit(flag2))
			tr[num][flag1][flag2]+=k;
}
int get(int x,int y,int k) {
	if(k<1||k>100)
		return 0;
	int ans=0;
	int flag1=x;
	while(flag1) {
		int flag2=y;
		while(flag2) {
			ans+=tr[k][flag1][flag2];
			flag2-=lowbit(flag2);
		}
		flag1-=lowbit(flag1);
	}
	//printf("get(%d,%d,%d)=%d\n",x,y,k,ans);
	return ans;
}
int main() {
	scanf("%d%d",&m,&n);
	for(int i=1; i<=m; i++)
		for(int j=1; j<=n; j++) {
			int in;
			scanf("%d",&in);
			ji(i,j,in,1);
			a[i][j]=in;
		}
	/*for(int i=1; i<=m; i++) {
		for(int j=1; j<=n; j++)
			printf("%d ",tr[1][i][j]);
		printf("\n");
	}*/
	scanf("%d",&k);
	for(int i=1; i<=k; i++) {
		int op;
		scanf("%d",&op);
		if(op==1) {
			int x,y,k;
			scanf("%d%d%d",&x,&y,&k);
			ji(x,y,a[x][y],-1);
			a[x][y]=k;
			ji(x,y,a[x][y],1);
		} else {
			int x1,x2,y1,y2,k;
			scanf("%d%d%d%d%d",&x1,&x2,&y1,&y2,&k);
			printf("%d\n",get(x2,y2,k)-get(x2,y1-1,k)-get(x1-1,y2,k)+get(x1-1,y1-1,k));
		}
	}
	return 0;
}
```
注意事项：
1.  如果修改的数不在查询范围以内，直接调出函数；

2.  在对数字进行修改的时候一定要把修改的数字减去。

感谢观看！

---

## 作者：Iron_Heart (赞：2)

## 思路

此题是一道典型的多维树状数组。

定义第一个维度为 $x$，第二个维度为 $y$，第三个维度为权值 $c$。

定义两个函数 $add(x,y,c,d)$ 和 $sum(x,y,c)$。

- $add(x,y,c,d)$：将左上角点坐标为 $(1,1)$，右下角点坐标为 $(x,y)$ 的矩形中中权值 $c$ 的格子的个数增加 $d$
- $sum(x,y,c)$ 统计左上角点坐标为 $(1,1)$，右下角点坐标为 $(x,y)$ 的矩形中权值为 $c$ 的格子的个数。

因此当进行操作 1 时，将原先的权值出现次数 $-1$，将修改后的权值的出现次数 $+1$；

当进行操作 2 时，根据容斥原理，易得答案为 $sum(x2, y2, c) - sum(x2, y1 - 1, c) - sum(x1 - 1, y2, c) + sum(x1 - 1, y1 - 1, c)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int tree[310][310][110], n, m, q, a[310][310];

int lowbit(int x) {
    return x & (-x);
}

void add(int x, int y, int c, int d) {
    for (int i = x; i <= n; i += lowbit(i)) {
        for (int j = y; j <= m; j += lowbit(j)) {
            tree[i][j][c] += d;
        }
    }
}

int sum(int x, int y, int c) {
    int ans = 0;
    for (int i = x; i > 0; i -= lowbit(i)) {
        for (int j = y; j > 0; j -= lowbit(j)) {
            ans += tree[i][j][c];
        }
    }
    return ans;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            scanf("%d", &a[i][j]);
            add(i, j, a[i][j], 1);
        }
    }
    scanf("%d", &q);
    while (q--) {
        int t;
        scanf("%d", &t);
        if (t == 1) {
            int x, y, c;
            scanf("%d%d%d", &x, &y, &c);
            add(x, y, a[x][y], -1);
            a[x][y] = c;
            add(x, y, c, 1);
        } else {
            int x1, x2, y1, y2, c;
            scanf("%d%d%d%d%d", &x1, &x2, &y1, &y2, &c);
            printf("%d\n", sum(x2, y2, c) - sum(x2, y1 - 1, c) - sum(x1 - 1, y2, c) + sum(x1 - 1, y1 - 1, c));
        }
    }
    return 0;
}
```


---

## 作者：Tethys (赞：2)

### 题意：

给你一个矩阵，给定每个格点的初始颜色，然后进行两种操作（一种是修改单个格点的颜色，另一种是询问子矩阵中特定的询问颜色出现的次数）

### 前置芝士：

**二维树状数组（以求和为例）:**
一般是指，假设当前节点为$(x, y)$，
所以二维树状数组$tr[x][y]=  \displaystyle \sum_{i=1}^{x} \sum_{j = 1}^{y}a[i][j]$，即求以当前节点为右下角，以矩阵左上角作为左上角的子矩阵的权值总和（最大值，最小值同理）

### 大概思路：

因为颜色种类$\leq 100$，所以可以开$100$个二维树状数组
#### 注：下面出现的$tr$数组均指树状数组的查询值


#### 修改：

当我们要将$(x, y)$位置的$a$颜色修改为$b$颜色时，我们应该先将$(x,y)$位置的$a$颜色的价值删去，即在$a$的树状数组中进行修改（加上$-1$）

#### 查询：


维护每一种颜色出现的次数，最后利用前缀和的性质求差，求得出现次数就好了

假设我们要查询左上角为$(x0,y0)$，右下角为$(x1,y1)$的子矩阵中(保证$x0\leq x1$且$y0\leq y1$)$a$颜色（假设树状数组的编号为$1$）出现的次数，我们可以知道
$ans= tr[1][x1][y1] - tr[1][x0 - 1][y1] - tr[1][x1][y0 - 1] + tr[1][x0 - 1][y0 - 1]$


### 代码：

```cpp
#include<bits/stdc++.h>

namespace Tethys{
	inline long long read(){
		long long s = 0, f = 1; char ch;
		while(!isdigit(ch = getchar())) (ch == '-') && (f = -f);
		for(s = ch ^ 48; isdigit(ch = getchar()); s = (s << 1) + (s << 3) + (ch ^ 48));
		return (s *= f);
	}
}

using namespace std;
using namespace Tethys;

int n, m, Q;
int tr[105][305][305], s[305][305];

int lowbit(int x){ return x & -x;}

void change(int x, int y, int val, int col){
    for(int i = x; i <= n; i += lowbit(i)){
        for(int j = y; j <= m; j += lowbit(j)){
            tr[col][i][j] += val;
        }
    }
}

int query(int x, int y, int col){
    int res = 0;
    for(int i = x; i >= 1; i -= lowbit(i)){
        for(int j = y; j >= 1; j -= lowbit(j)){
            res += tr[col][i][j];
        }
    }
    return res;
}

signed main(){

    n = read(); m = read();
    for(int i = 1; i <= n; i ++){
        for(int j = 1, x; j <= m; j ++){
            s[i][j] = read();
            change(i, j, 1, s[i][j]);
        }
    }
    
    Q = read();

    for(int i = 1, opt; i <= Q; i ++){
        opt = read();
        if(opt == 1){
            int x = read(), y = read(), c = read();
            change(x, y, -1, s[x][y]);
            change(x, y, 1, c);
            s[x][y] = c;
        }else{
            int x = read(), xx = read(), y = read(), yy = read(), c = read();
            printf("%d\n", query(xx, yy, c) - query(xx, y - 1, c) - query(x - 1, yy, c) + query(x - 1, y - 1, c));
        }
    }
    return 0;
}
```
完美撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：Cripple_Abyss (赞：2)

这题就是二维树状数组模板题

思路与一维树状数组大致一样

- 单点间修改：多加一维

- 区间查询：

![](https://cdn.luogu.com.cn/upload/image_hosting/t7z1j8vg.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ihtpvfnf.png)

很明显右下角那一块多减了一次，所以要加上去

# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,a[305][305],c[305][305][305];
void update(int x,int y,int z,int k) {
	a[x][y]=k;
	for (int i=x; i<=n; i+=(i&(-i)))
		for (int j=y; j<=m; j+=(j&(-j)))
			c[k][i][j]+=z;
}
int getsum(int x,int y,int k) {
	int ans=0;
	for (int i=x; i; i-=(i&(-i)))
		for (int j=y; j; j-=(j&(-j)))
			ans+=c[k][i][j];
	return ans;
}
int main() {
	scanf("%d%d",&n,&m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++) {
			int k;
			scanf("%d",&k);
			update(i,j,1,k);
		}
	scanf("%d",&q);
	while (q--) {
		int opt;
		scanf("%d",&opt);
		if (opt==1) {
			int x,y,k;
			scanf("%d%d%d",&x,&y,&k);
			update(x,y,-1,a[x][y]);
			update(x,y,1,k);
		} else {
			int x1,x2,y1,y2,k;
			scanf("%d%d%d%d%d",&x1,&x2,&y1,&y2,&k);
			int ans1,ans2;
			printf("%d\n",getsum(x2,y2,k)-getsum(x1-1,y2,k)-getsum(x2,y1-1,k)+getsum(x1-1,y1-1,k));
		}
	}
	return 0;
}
```



---

## 作者：WhiteLabs (赞：1)


拿到题先一看：在一片范围中求某个值的出现次数!

这时我们很容易地会联想到主席树；

——带修改？那就用可以修改的主席树，树套树。

但问题来了：树套树只能维护两个东西的限制，比如 $a\leq x\leq b$ 且 $c \leq y\leq d$ 内 $(x,y)$ 的个数，我们查询一个区间内的所有平衡树，然后再在那些树上查询另一个区间；

而此题要限制的有三个东西： $x$ , $y$ 和 $c$ ，也就是，用上面维护点对数量的例子，此时只能维护一种颜色。那该怎么办呢？

这时，看一下数据范围： $n,m\leq 300$ , $c\leq 100$ ; 我们发现，尤其是颜色数量，都是很小的规模！

那么，既然一个树套树只能维护一种颜色，此时有 $100$ 种颜色，我们开 $100$ 颗树套树不就行了吗？但是：

尝试写树套树，但交了一次就发现爆空间了。

于是就想，既然权值线段树空间大，那换成权值树状数组，不就可以小很多了吗？

对于每一种颜色，外层树状数组维护区间，用来计算询问 $x$ 坐标涉及到哪些树；内层树状数组负责记录在 $y$ 坐标上存不存在这种颜色。

具体就把树套树的权值线段树换成树状数组即可，代码还挺好写的。

代码：

```cpp

#include <bits/stdc++.h>

using namespace std;

inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch&15);ch=getchar();}
	return x*f;
}

const int N=305;

int n,m,q;
int color[N][N];

struct BITBIT{
	
	int tree[N][N];

	inline int lowbit(int x){
		return x&-x;
	}

	inline void update(int val,int sum,int t){
		for(int i=val;i<=n;i+=lowbit(i))
			tree[t][i]+=sum;
	}

	inline int getsum(int val,int t){//sum of numbers<=val
		int ans=0;
		for(int i=val;i;i-=lowbit(i))
			ans+=tree[t][i];
		return ans;
	}

	inline void insert(int idx,int val){
		for(int i=idx;i<=n;i+=lowbit(i))
			update(val,1,i);
	}
	
	inline void erase(int idx,int val){
		for(int i=idx;i<=n;i+=lowbit(i))
			update(val,-1,i);
	}

	int sta1[N],sta2[N],top1,top2;
	inline void gettree(int l,int r){
		top1=top2=0;
		for(int i=l-1;i;i-=lowbit(i)) sta1[++top1]=i;
		for(int i=r;i;i-=lowbit(i)) sta2[++top2]=i;
	}

	inline int query(int l,int r){
		int sum=0;
		for(int i=1;i<=top1;i++) sum-=getsum(r,sta1[i])-getsum(l-1,sta1[i]);
		for(int i=1;i<=top2;i++) sum+=getsum(r,sta2[i])-getsum(l-1,sta2[i]);
		return sum;
	}

	inline int calc(int x1,int x2,int y1,int y2){
		gettree(x1,x2);
		return query(y1,y2);
	}
	
}BIT[105];

inline void modify(int x,int y,int c){
	BIT[color[x][y]].erase(x,y);
	BIT[color[x][y]=c].insert(x,y);
}

inline void query(int x,int x2,int y,int y2,int c){
	printf("%d\n",BIT[c].calc(x,x2,y,y2));
}

int main(){
	n=read(),m=read();
	int c;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			c=read(),BIT[color[i][j]=c].insert(i,j);
			
	q=read();
	int opt,x,x2,y,y2;
	for(int i=1;i<=q;i++){
		opt=read();
		if(opt==1) x=read(),y=read(),c=read(),modify(x,y,c);
		if(opt==2) x=read(),x2=read(),y=read(),y2=read(),c=read(),query(x,x2,y,y2,c);
	}
	return 0;
}
```

---


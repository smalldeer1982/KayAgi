# [CCO 2015] 太阳能飞行

## 题目背景

**警告：滥用本题评测将被封号**

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day1 T3「[Solar Flight](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day1.pdf)」**

航空的新纪元正在来临——第一个太阳能驱动的巨型喷气式飞机即将商用！然而，公众对前沿技术有一些在安全方面的焦虑，因为驱动飞机的阳光的光线可能会被其他在空中的物体挡住。因此，必须先进行一些统计和计算来规划第一次航行。

我们考虑一个包含 $N$ 个从一个城市到另外一个城市的航路组成的图。一架飞机可以被考虑成一个点。它穿过的天空可以被模型化为一个笛卡尔坐标系，其中 $X$ 轴表示从任意一个点向东出发的距离，$Y$ 轴表示高度。我们只考虑 $x$ 值的范围在 $[0,X]$，所有航路均为直线的部分。第 $i$ 架飞机从 $(0,A_i)$ 飞到 $(X,B_i)$。所有$A$值互不相同，对于$B$也如此。飞机以未知的，可能是非恒定的速度沿着航路行驶，所以任意时间点，飞机可能在航路的任意位置上。然而，已知的是飞机从不与其他飞机相撞，所以如果两个航道交错，两个飞机不会同时到达交点。

每个飞机 $i$ 同时也有一个干扰因素值 $C_i$，表示一个飞机影响它下面飞机太阳吸收能力的强弱。

各个飞机上的太阳能板非常奇怪，那些太阳能板只能收集飞机正上方的能量。这就意味着一个飞机能吸收的阳光可能会被其他与其的 $x$ 值相同，但是 $y$ 值比他大的飞机挡住。具体来说，太阳能板吸收的太阳光减少的值为挡住它的飞机的干扰因素值之和。

根据这些信息，以及一个距离常数 $K$，你要回答 $Q$ 个关于可能对太阳能板影响的询问。第 $i$ 个询问询问你在一个时刻飞机 $P_i$ 的太阳能板吸收的太阳光减少的值。在任意时刻飞机的 $x$ 值均在 $[S_i,S_i+K]$之间。

## 说明/提示

飞机的航路示意图如下图所示。

![CCO2015D1T3Pic1](http://miao.su/images/2018/08/15/aaa7e400.png)

询问 $1$ 是对于 $2$ 号飞机在 $[1,5]$ 范围内所提出的询问，当飞机在 $x\le 4$ 时可能会被飞机 $3$ 挡住，但是绝不是飞机 $1$。然而，但是当它的 $x>4$ 时可能会被其他所有飞机挡住，因此，该询问的答案即其他所有飞机的影响因素值之和，为 $5+6=11$。

对于询问 $2$，当 $x<10$ 时飞机 $1$ 可能会被飞机 $3$ 挡住，并且当 $x\geq10$ 时不会被任何飞机盖住，因此只可能被飞机 $3$ 影响，即结果等于飞机 $3$ 的影响因素值 $6$。

对于询问 $3$，飞机 $1,2$ 都不能在飞机 $3$ 的正上方除非 $x$ 达到 $10$。所以该询问的答案为0。

对于 $40\%$ 的数据，$Q\le 1000$。  

对于 $100\%$ 的数据，$1\le N\le 2000,$ $1\le K\le X,$ $1\le X,A_i,B_i,C_i\le 10^9,$ $0\le S_i\le X-K,$ $1\le Q \le 800000$。

## 样例 #1

### 输入

```
12 4 3 3
1 4 5
2 2 3
6 3 6
2 1
1 8
3 0```

### 输出

```
11
6
0```

# 题解

## 作者：Crossing (赞：7)

- ### [题目传送门](https://www.luogu.org/problemnew/show/P4803)
- ### [CCO原题传送门](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day1.pdf)day1 T3
*说实话，这道题是我随机跳到的。初看觉得不难，结果在码代码的时候遇到很多问题。最后，八WA之后终见AC。~~这一定是我太蒟了~~*
# **题意**

我觉得本题题意也是一大难点，所以在看题目时要逐字，多看几遍。~~我在做的过程中，看错了两遍题目（前车之鉴），可能是本人的语文不好~~

本题的意思大概就是，在一个坐标系中，有n架飞机直线飞行（当然不是匀速），给定X坐标范围，又给定每架飞机的起始高度和终止高度。（其实就相当于n条一次函数的图象）。每架飞机还有一个干扰值，表示影响它正下方的飞机太阳吸收能力的强弱。现有Q个问题，请你求出区间[Si,Si+K]中，第Pi架飞机的太阳能板吸收的太阳光减少的值。我所说的难理解的地方就在这里。这里要求的并不是只要在该区间范围内能出现在第Pi架飞机上方的飞机。而是要求该区间中的每一时刻的减少的值中的最大值（可以这么理解）。

# **做法**
##### 刚开始真的无从下手，然后就看到。。。
![](https://s2.ax1x.com/2019/03/13/AF6IqP.png)

##### 这才有点眉目。

对于n架飞机，我们可以预处理出每两架飞机航线（相当于一次函数）之间的关系（要么相交，要么不相交）。而只要两架飞机不在相交点上，就一定存在其中一架飞机对另外一家飞机有影响。也就是说，任何一架飞机对于一架它可以影响的飞机，影响的范围只可能是 [0,相交点][相交点,X]（相交的情况）、[0,X]（不相交的情况）。

知道了可影响范围的计算，于是一个奇妙的想法萌发，**前缀和**！因为**对于一架飞机而言，它的被影响的值只有在经过一个交点后才会改变（因为飞机的相对位置就改变了）**。因此，就可以记录下每个影响范围的起点和终点，利用**区间加值**的方法（这个，相信一般人都会吧）。这时候就可以利用前缀和，造一个前缀和数组，这样就可以得出每架飞机每一个时刻的被影响值。

最后回答问题的时候，只要先利用二分找出起点，然后往后跳，直到终点，中途用一个变量记录最大值即可。（不清楚的请看代码注解）

## 这样，这道题就解决了。

**附：**

- 这是本蒟蒻的第一篇题解，望支持。如有错误或有更优解，请告知。

- CCO官网上有数据 [传送门](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html)

# 最后上代码
```cpp
//本代码中的快读和快输均是之前尝试时加的，没有应该问题不大
//代码中有些地方可能写的有些复杂，可以多考虑考虑
#include<bits/stdc++.h>
#define ff(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
struct xx{
    double x;
    long long val;
}a[2010][2010],f[2010][2010];                         //f 前缀数组
int x,kk,n,Q,b[2010],y[2010],c[2010],l[2010];
long long sum[2010];
double k[2010];
bool cmp(xx s,xx t){
    return s.x<t.x;
}
inline int read(){    //优化读入
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}   
inline void write(long long x) {   //优化输出
    int cnt=0;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main(){
    x=read();kk=read();n=read();Q=read();
    ff(i,1,n) b[i]=read(),y[i]=read(),c[i]=read(),k[i]=1.0*(y[i]-b[i])/x;     // y[]、b[]对应一次函数y=kx+b中的k、b
    ff(i,1,n-1)
        ff(j,i+1,n){
            int ii=i,jj=j;
            if((b[ii]>b[jj]&&y[ii]<y[jj])||(b[ii]<b[jj]&&y[ii]>y[jj])){      //相交的情况
                if(b[ii]<b[jj]&&y[ii]>y[jj]) swap(ii,jj);
                double dx=1.0*(b[ii]-b[jj])/(k[jj]-k[ii]);       //计算交点（基本操作）
                a[jj][++l[jj]].val=-c[ii];a[jj][l[jj]].x=dx;sum[jj]+=c[ii]; //区间加，并记录下交点，sum数组相当于x=0时的前缀数组的值
                a[ii][++l[ii]].val=c[jj];a[ii][l[ii]].x=dx;                
            }else{                                                          //不相交的情况
                if(b[ii]>b[jj]) swap(ii,jj);
                sum[ii]+=c[jj];                              //同上     
            }
        }
    ff(i,1,n){
        sort(a[i]+1,a[i]+l[i]+1,cmp);          //排序
        long long cc=0;
        int ll=l[i];
        l[i]=0;
        ff(j,1,ll){
            cc+=a[i][j].val;
            if(!(abs(a[i][j].x-a[i][j+1].x)<=1e-7)) f[i][++l[i]].x=a[i][j].x,f[i][l[i]].val=cc+f[i][l[i]-1].val,cc=0; //造前缀数组，并去重
        }
    }
    ff(i,1,Q){     
        int ll,rr;
        x=read();ll=read();
        int l1=1,r1=l[x],st=0;
        rr=ll+kk;
        while(l1<=r1){           //二分找起点
            int mid=(l1+r1+1)/2;
            if(f[x][mid].x<=ll) st=mid,l1=mid+1; else r1=mid-1;
        }           
        long long ans=0;
        for(;st<=l[x]&&f[x][st].x<rr;st++) if(f[x][st].val+sum[x]>ans) ans=f[x][st].val+sum[x]; //点往后跳，找最大值
        write(ans);
        printf("\n");
    }
    return 0;      
}
```

![](https://s2.ax1x.com/2019/03/13/AF2YUf.png)
# 祝大家RP++！！！

---

## 作者：a326820068122c (赞：6)

~~巧了我也是随机跳到这题的。~~

这题大体做法和上一篇题解差不多。

题目大意是给定 $n$ 条互不重合的线，问一段固定长度的线长度上方的线的权值和是多少，交点视为两个点都不在彼此上方。

这里可以发现交点显然不优，因为通过交点的其他飞机挡不了它。

由于对于一架飞机 $x$ 而言，它的被影响的值只有在经过一个交点后才会改变（因为飞机的相对位置就改变了），所以可以使用前缀和来解决问题（当有一架飞机 $i$ 升到 $x$ 上面时，这个位置的改变值为 $C_i$，当有一架飞机 $i$ 降到 $x$ 下面时，这个位置的改变值为 $-C_i$）。

提供一个小优化。

就是由于 $k$ 是定值，所以取最大值是个滑动窗口的问题，可以用单调队列求解（即使 $k$ 不是定值也可以用`st表`解决）。

这样时间复杂度从 $O(n^2\log n+qn)$ 优化到了 $O((n^2+q)\log n)$。（这里二分还是需要的）

所以这题根本用不着个 $15s$，给 $3s$ 就够了。

另外这题建议用`long double`以保证精度。

有一个小细节，就是为了不把交点算进来，需要略微减少一下查询两端的距离。

发一下代码：

```cpp
#include <bits/stdc++.h>
#define for1(i,n) for(i=1;i<=(n);i++)
#define for0(i,n) for(i=0;i<=(n);i++)
#define mems(a) memset(a,0,sizeof(a))
using namespace std;
typedef long double ld;
typedef long long ll;
const int N=2005,M=800005;
const ld eps=1e-10;
int m,d,n,cq,b[N],c[N],q[N],lq,rq;
ll ans[M],dp[N];
ld k[N],t[N],l[M];
vector<int> v[N],u[N];
bool dy(const ld &x,const ld &y){return abs(x-y)<eps;}
struct node{
	ld x;
	ll f;
	bool operator<(const node &nd)const{return x<nd.x;}
}p[N],s[N];
bool cmp(const int &x,const int &y){return l[x]<l[y];}
int main(){
	scanf("%d%d%d%d",&m,&d,&n,&cq);
	int i,j,x,cs,cp;
	ld z;
	for1(i,n) scanf("%d%d%d",&b[i],&x,&c[i]),k[i]=(ld)(x-b[i])/m;
	for1(i,cq) scanf("%d%Lf",&x,&l[i]),l[i]+=d-5e-11,v[x].push_back(i);
	for1(i,n){
		cs=cp=lq=rq=q[0]=dp[0]=0;
		for1(j,n){
			if(b[j]>b[i]) dp[0]+=c[j];
			if(!dy(k[i],k[j])){
				z=(b[i]-b[j])/(k[j]-k[i]);
				if(z>=0&&z<=m) p[++cp]={z,k[j]>k[i]?c[j]:-c[j]};
			}
		}
		sort(p+1,p+cp+1);
		for1(j,cp){
			if(dy(p[j].x,p[j-1].x)) s[cs].f+=p[j].f;
			else s[++cs]=p[j];
		}
		t[cs+1]=m;
		for0(j,cs) u[j].clear(),t[j]=s[j].x;
		for(int y:v[i]) u[upper_bound(t+1,t+cs+1,l[y])-t-1].push_back(y);
		for1(j,cs+1){
			sort(u[j-1].begin(),u[j-1].end(),cmp);
			for(int y:u[j-1]){
				while(l[y]-t[q[lq]+1]>d-eps) lq++;
				ans[y]=dp[q[lq]];
			}
			if(j>cs) break;
			dp[j]=dp[j-1]+s[j].f;
			while(t[j]-t[q[lq]+1]>d-eps) lq++;
			while(lq<=rq&&dp[j]>=dp[q[rq]]) rq--;
			q[++rq]=j;
		}
	}
	for1(i,cq) printf("%lld\n",ans[i]);
	return 0;
}
```

---


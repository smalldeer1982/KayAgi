# [COCI 2015/2016 #3] DOMINO

## 题目背景

「誕生日おめでとう！!」

小 M 收到了他女朋友的生日祝福和一份礼物。

## 题目描述

小 M 的女朋友送小 M 了一张 $n \times n$ 的表格作为生日礼物，在表格的每个单元格中都写有一个非负整数。

不幸的是，有些单元格里数字太大了，小 M 不喜欢它们，所以他将在表格上面放置 $k$ 张骨牌，将覆盖那些数字太大的单元格。

更准确地说，小 M 按照以下规则放置骨牌。

- 骨牌为 $1\times 2$ 的矩形，不能拆开放置。
- 骨牌不重叠（但可以接触）。
- 所有可见（未覆盖）字段的总和需要尽可能的小。

您的任务是确定最小可见区域的数字的总和。数据保证可防止 $k$ 个骨牌且无重叠。

## 说明/提示

#### 数据规模及约定
对于 $100\%$ 的数据，$1\le n \le 2 \times 10 ^ 3$，$1\le k \le 8$，$0 \le a_i \le 10 ^ 3$。

#### 说明
翻译自 [COCI 2015-2016 #3 F DOMINO](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)，满分 160。

## 样例 #1

### 输入

```
3 1
2 7 6
9 5 1
4 3 8
```

### 输出

```
31```

## 样例 #2

### 输入

```
4 2
1 2 4 0
4 0 5 4
0 3 5 1
1 0 4 1
```

### 输出

```
17```

# 题解

## 作者：UnyieldingTrilobite (赞：7)

前置芝士：高维前缀和（SOS DP）。

~~如果不会的话左传[题解区](https://www.luogu.com.cn/problem/P5495)，包教包会~~ 唔这里会讲一讲的（

简单来说，如何求一个一维序列的前缀和？

废话当然是直接累加啊……

那二维呢？（这里前缀和定义为每个维度都小于等于给定数的所有下标对应的值的和）

正常的写法是每个数用三个来推（也就是 
```cpp
sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
```
这种的，做的是原地前缀和，也就是说 `sum` 数组原来存的是原值），但我们发现这样的话一个式子里出现了 $4$ 项，如果把它推广到 $x$ 维，且不论代码挺难写，而且一个式子里会有 $2^x$ 项，如果每一维的取值都是小于等于 $2$（事实上一般都是这个情况），那复杂度并不优秀，是 $O(3^x)$ 的（因为事实上这个情况下只需要枚举对应下标的子集，可以比朴素的 $O(4^x)$ 好一点，复杂度分析大概就是每一位在两个集合里的出现方案只有三种，但总之都很难看）。

所以我们需要一个针对它的优化。

我们考虑我们二维前缀和实际上是要干一个什么事：求出一个前缀子矩阵里所有数的和。那我们不如先求出子矩阵每一列的和然后再把它们全部累起来（或者先行再列也无所谓），然后很容易能发现这两步都可以一维前缀和优化。具体来说，代码会长成这个样子：

首先对所有元素执行：`sum[i][j]+=sum[i-1][j];`

然后再对所有元素执行：`sum[i][j]+=sum[i][j-1];`

是不是很简洁，并且显然很好推广到高维？

这样的话，比如我们要对一个 $x$ 维的东西累前缀和，复杂度就降低为 $O(x\times2^x)$，比较舒适。

---

好了回到本题。

首先如果我们把每种多米诺都给枚举出来并算出权值，建图，那么就转换成了要求：一个顶点的子集，大小为 $k$ 给定，其中没有两个点之间有边，点权和最大是多少（最后拿所有输入的和减去这玩意就是答案）。

这样的话点数大概会是 $8\times10^6$ 级别，由于目测不会有什么神仙线性算法，显然大概率难以接受。考虑怎么优化。

观察到这个图的一个特性：一个点的度数至多为 $6$（十分显然）。这就给了我们一些启示，事实上，我们可以证明一定存在一种最优方案，所有取出的点都在前 $7(k-1)+1$ 个点里。证明大概就是反证法，不妨最后一个点不在，然后前 $k-1$ 个点每个点至多使得六个点不能取，算上自己一共 $7$ 个，这样最多使得 $7(k-1)$ 个点不可达，这样把最后一个点调整到前 $7(k-1)+1$ 个点一定可行且更优。

然后本题中 $k\le8$ 所以实际上只需要保留前 $50$ 个点。如果不考虑复杂度问题，我们已经有了一个挺不错的算法：弄一个 $50$ 维的数组表示每个点取或者不取（状压一下就变成一个一维数组，大小为 $2^{50}$），然后初始对于每一维，把只有这一位是 $1$ 的值填进去，然后对于两个相邻的点，把只有这两位的值填成 $+\infty$（也就是非法），然后累个前缀和就能算了。当然实际上也可以只统计每个状态是否合法，值后面再算，不过这个无所谓，复杂度一致。

我们发现这个复杂度显然要炸，但是这个 $2$ 指数级的复杂度加上 $50$ 的奇妙范围不难想到 meet-in-the-middle。大概就是，把 $50$ 个点分成两个部分分别按照上述方法计算，然后之间计算一下贡献。至于之间的贡献怎么算，我们可以对于前一半的每个状态（集合）算出其在后半部分中最大能匹配到的集合总权，这个显然可以反向前缀和一下干掉，实际上就是要算后半部分中每个集合最大能匹配到前半部分中的哪个集合，这个也可以累前缀和但代码里由于一些历史遗留问题选择了把每个单个的最大对应状态预处理出来然后暴力枚举每一位求集合交。

然后这个复杂度实际上还是有点危，因为反向累前缀和那一步实际上是要分后半部分那个集合的大小来算的，于是我们发现实际上只需要保留大小 $\le k$ 的部分（给后半部分类前缀和的时候也是如此），好消息。

这样的话就可以了。肉眼观察一下前半部分放 $22$ 个点，后半部分放 $28$ 个点的时候是差不多可以的。那就可以过了。注意一下这个数据范围会爆 `int`，但 `unsigned` 也够用了。

代码实际上~~并不难写~~挺难写的，所以还是贴一下吧（

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define INF INT_MAX
#define cnt __builtin_popcount
#define int unsigned
using namespace std;
constexpr int N = 4e6 + 9, M = 50, W = 21, C = 9e6 + 9;
int n, k, tot, d, val[N], ans, sum;
pair<int, int> dm[N << 1];
int id(int x, int y) { return x * n + y; }
int getval(pair<int, int> x) { return val[x.fi] + val[x.se]; }
bool issim(pair<int, int> x, pair<int, int> y) {
  return x.fi == y.fi || x.fi == y.se || x.se == y.fi || x.se == y.se;
}
int iadd(int x, int y) { return x == INF || y == INF ? INF : x + y; }
int f[1 << W], g[C], gst[M], gval[1 << W][9];
int num[C], ntot;
void dfs(int hbt, int rem, int x) {
  if (!hbt)
    num[ntot++] = x;
  else {
    dfs(hbt - 1, rem, x);
    if (rem) dfs(hbt - 1, rem - 1, x | (1 << (hbt - 1)));
  }
}
int pos(int x) { return lower_bound(num, num + ntot, x) - num; }
signed main() {
  ios::sync_with_stdio(false), cin.tie(nullptr);
  dfs(M - W, 8, 0), cin >> n >> k;
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j) {
      cin >> val[id(i, j)], sum += val[id(i, j)];
      if (i) dm[tot++] = {id(i - 1, j), id(i, j)};
      if (j) dm[tot++] = {id(i, j - 1), id(i, j)};
    }
  if (tot > M)
    nth_element(dm, dm + M, dm + tot,
                [](auto x, auto y) { return getval(x) > getval(y); }),
        tot = M;
  d = min(tot >> 1, W);
  for (int i = 0; i < d; ++i) {
    f[1 << i] = getval(dm[i]);
    for (int j = 0; j < i; ++j)
      if (issim(dm[i], dm[j])) f[(1 << i) | (1 << j)] = INF;
  }
  for (int i = 0; i < d; ++i)
    for (int s = 0; s < (1u << d); ++s)
      if ((s & (1 << i)) && cnt(s) <= k) f[s] = iadd(f[s], f[s ^ (1 << i)]);
  for (int i = 0; i < tot - d; ++i) {
    g[pos(1 << i)] = getval(dm[i + d]);
    for (int j = 0; j < i; ++j)
      if (issim(dm[i + d], dm[j + d])) g[pos((1 << i) | (1 << j))] = INF;
  }
  for (int i = 0; i < tot - d; ++i) {
    gst[i] = (1 << d) - 1;
    for (int j = 0; j < d; ++j)
      if (issim(dm[i + d], dm[j])) gst[i] ^= 1 << j;
  }
  for (int i = 0; i < tot - d; ++i)
    for (int p = 0; p < ntot && (num[p] < (1u << (tot - d))); ++p)
      if (int s = num[p]; (s & (1 << i)) && cnt(s) <= k)
        g[p] = iadd(g[p], g[pos(s ^ (1 << i))]);
  for (int p = 0; p < ntot && (num[p] < (1u << (tot - d))); ++p)
    if (int s = num[p]; g[p] != INF && cnt(s) <= k) {
      int gsts = (1 << d) - 1;
      for (int i = 0; i < (tot - d); ++i)
        if (s & (1 << i)) gsts &= gst[i];
      gval[gsts][cnt(s)] = max(gval[gsts][cnt(s)], g[p]);
    }
  for (int i = 0; i < d; ++i)
    for (int s = 0; s < (1u << d); ++s)
      if (s & (1 << i))
        for (int j = 0; j <= k; ++j) {
          gval[s ^ (1 << i)][j] = max(gval[s ^ (1 << i)][j], gval[s][j]);
        }

  for (int s = 0; s < (1u << d); ++s)
    if (f[s] != INF && cnt(s) <= k) ans = max(ans, gval[s][k - cnt(s)] + f[s]);
  cout << sum - ans << endl;
  return 0;
}
```

以上。

---

## 作者：zsq147258369 (赞：3)

本来只是看看费用流可以得多少分，~~没想到直接卡过了~~。

非常经典的骨牌问题。因为这些骨牌只会占用相邻的两个格子，那么可以想到用黑白染色来做。对于 $(x,y)$，若 $x+y\equiv 1\mod 2$，就连源点到该点一条容量为 $1$，费用为 $a_{x,y}$ 的边，再连该点到其四周的点，容量为 $1$ 费用为 $0$。否则就连该点到汇点的边，容量为 $1$ 费用为 $a_{x,y}$。

这是按照以上的思路打出来的代码：[$link$](https://www.luogu.com.cn/record/80373711)。可以看到由于点有 $4e6$ 个，导致直接 MLE。但是，他没 T！这就给我一个优化空间的想法。

仔细看，对于所有的边，它的容量及费用极小，甚至可以不用整型来存，用短整型来存即可。可以优化差不多一半的空间，可以过了。

# $code$
```cpp
#include<bits/stdc++.h>
#define ll long long
#define sh short
using namespace std;
const int N=4e6+500,M=4e7+500,inf=1e9+7;

struct node
{
	int u,v,nxt;
	sh c,w;
}e[M];

int n,m,head[N],k,a[2300][2300],cnt=1,st,ed;
int rx[4]={0,0,1,-1},ry[4]={1,-1,0,0};
ll tot;

void add(int u,int v,int w,int c)
{
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].c=c;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}

int id(int x,int y)
{
	return (x-1)*n+y;
}

void read()
{
	cin>>n>>k;int s=n*n+1;st=s+1,ed=st+1;
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>a[i][j],tot+=a[i][j];
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
	{
		if((i+j)&1)continue;
		for(int k=0;k<4;k++)
		{
			int xx=i+rx[k],yy=j+ry[k];
			if(xx<1||xx>n||yy<1||yy>n)continue;
			add(id(i,j),id(xx,yy),1,0);
			add(id(xx,yy),id(i,j),0,0);
		}
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
	{
		if((i+j)&1)add(id(i,j),ed,1,-a[i][j]),add(ed,id(i,j),0,a[i][j]);
		else add(s,id(i,j),1,-a[i][j]),add(id(i,j),s,0,a[i][j]);
	}
	add(st,s,k,0);add(s,st,0,0);
}

int vis[N],dep[N],maxflow;
ll mincost;

int spfa()
{
	deque<int>q;
	for(int i=1;i<=ed;i++)vis[i]=0,dep[i]=inf;
	q.push_back(ed);vis[ed]=1;dep[ed]=0;
	while(!q.empty())
	{
		int x=q.front();q.pop_front();vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt)
		{
			int v=e[i].v;
			if(e[i^1].w>0&&dep[v]>dep[x]-e[i].c)
			{
				dep[v]=dep[x]-e[i].c;
				if(!vis[v])
				{
					vis[v]=1;
					if(!q.empty()&&dep[v]<dep[q.front()])q.push_front(v);
					else q.push_back(v);
				}
			}
		}
	}
	return dep[st]<inf;
}

int dfs(int now,int flow)
{
	vis[now]=1;
	if(now==ed||flow<=0)return flow;
	int res=0;
	for(int i=head[now];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(!vis[v]&&e[i].w&&dep[now]-e[i].c==dep[v])
		{
			int d=dfs(v,min(flow-res,int(e[i].w)));
			if(d<=0)continue;
			e[i].w-=d,e[i^1].w+=d;
			res+=d,mincost+=1ll*d*e[i].c;
			if(res==flow)return res;
		}
	}
	return res;
}

void zkw()
{
	while(spfa())
	{
		vis[ed]=1;
		while(vis[ed])
		{
			for(int i=1;i<=ed;i++)vis[i]=0;
			maxflow+=dfs(st,inf);
		}
	}
}

void print()
{
	cout<<tot+mincost;
}

main()
{
	read();
	zkw();
	print();
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

难点：卡空间。

这道题看到的时候可能会优先去想费用流。对每个格子黑白染色暴改为二分图，然后将覆盖的点的权值视为费用。每个点最大流入流出为 $1$，跑费用流，初始点限制一下，如图（上图费用，下图流量，样例2）：

![](https://www.helloimg.com/i/2025/06/10/6847eb7d9d7b5.png)

![](https://www.helloimg.com/i/2025/06/10/6847eb7da0509.png)

在严格分层的图中，SPFA 的时间复杂度其实是较为优秀的。事实上，对于这道题中的图，他的复杂度可以被严格控制在 $4n^2$ 级别，毕竟每一个上部点都只能向下面的四个点进行松弛。

所以说，总时间复杂度就是 $O(n^2k)$ 的，时间不是问题，但是空间容易爆掉。

我们又发现流量，边权什么的非常小，所以可以拿 `short` 去存。每一个点的出度足够小，所以说时间整大一点也无所谓，因此我们还可以将当前弧优化的数组也给砍了。此举名为时间换空间。

至此，对于我的代码已经能过了。如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr bool online = 0;
int n, m, s, t, mxf; long long ans, ap; short a[2005][2005];
struct SSP {
	struct node { int p; short v, f; }tmp;
	vector<node>e; vector<int>h[4000005];
	inline void ins(int l, int r, int f, int v) {
		h[l].emplace_back(e.size());
		tmp.p = r; tmp.v = v; tmp.f = f;
		e.emplace_back(tmp);
		h[r].emplace_back(e.size());
		tmp.p = l; tmp.v = -v; tmp.f = 0;
		e.emplace_back(tmp);
	}
	short d[4000005]; bool vis[4000005];
	inline bool spfa() {
		memset(d, 0x3f, sizeof d);
		queue<int>q; q.emplace(s); d[s] = 0;
		while(q.size()) {
			int tp = q.front(); q.pop(); vis[tp] = 0;
			for (int i : h[tp]) {
				const node& sp = e[i];
				if (sp.f && d[sp.p] > d[tp] + sp.v)
					if (d[sp.p] = d[tp] + sp.v, !vis[sp.p])
						q.emplace(sp.p), vis[sp.p] = 1;
			}
		}
		return d[t] <= 1e4;
	}
	inline int dfs(int p, short f) {
		if (p == t || !f) return f;
		int ret = 0, t; vis[p] = 1;
		for (int i = 0; i != h[p].size(); ++i) {
			node& sp = e[h[p][i]];
			if (sp.f && !vis[sp.p] && d[sp.p] == d[p] + sp.v) {
				if (!(t = dfs(sp.p, min(f, sp.f)))) d[sp.p] = INT_MAX;
				sp.f -= t; e[h[p][i] ^ 1].f += t; ret += t;
				ans += t * 1ll * sp.v; if (!(f -= t)) break;
			}
		}
		vis[p] = 0; return ret;
	}
	inline int micmxf() {
		while (spfa()) mxf += dfs(s, 10);
		return ans;
	}
}ssp;
inline int id(int x, int y) { return x + (y - 1) * n; }
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m; s = n * n + 1; t = s + 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			cin >> a[i][j], ap += a[i][j];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			if (i + j & 1) ssp.ins(id(i, j), t, 1, 0);
			else {
				ssp.ins(s, id(i, j), 1, 0);
				if (i != n) ssp.ins(id(i, j), id(i + 1, j), 1, -a[i][j] - a[i + 1][j]);
				if (j != n) ssp.ins(id(i, j), id(i, j + 1), 1, -a[i][j] - a[i][j + 1]);
				if (i != 1) ssp.ins(id(i, j), id(i - 1, j), 1, -a[i][j] - a[i - 1][j]);
				if (j != 1) ssp.ins(id(i, j), id(i, j - 1), 1, -a[i][j] - a[i][j - 1]);
			}
	s = t + 1; ssp.ins(s, s - 2, m, 0);
	cout << ap + ssp.micmxf() << endl;
}
```

---

## 作者：Math_rad_round (赞：0)

建议难度：提高+（显然费用流是蓝题）

题意简述：$n\times n$ 网格，格子有权，$k$ 个覆盖 $1\times 2$ 的骨牌，使未覆盖的数尽量大。$n\leq 2000 , k\leq 8$

既然是骨牌覆盖，我们就可以想到利用网格图的黑白染色，将 $s$ 连黑格，白格连 $t$ ，费用都是对应格子权值，再将相邻的黑格连白格无费用。（以上边权均为 $1$）最大费用最大流就是覆盖的格子最大值。

有两种方法，第一种最简单的想法就是直接暴力连暴力跑，可是 $n^2\leq 4000000$ 跑得动吗？

鉴于 $k\leq 8$ 用 spfa 找最短路基本可以保证每次 $O(m)$ 所以 $O(kn^2)$，显然可过，注意建反向边的话边数达到了 $6n^2$，要卡卡空间。（$O(n^2)$，但常数不小）

代码（核心部分）：

```

int id[2001][2001];
int s[2001][2001];
int fx[4]={1,0,-1,0},fy[4]={0,1,0,-1};
int main(){
	int n,k;cin>>n>>k;int ei=0;qi=n*n+1,zo=qi+1;
	ll all=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			id[i][j]=++ei;s[i][j]=read();all+=s[i][j];
			if((i&1)^(j&1)){add(qi,id[i][j],1,-s[i][j]);
			}else{add(id[i][j],zo,1,-s[i][j]);} //我的代码费用流是最短路，所以边权取反
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((i&1)^(j&1)){
				for(int f=0;f<4;f++){int x=i+fx[f],y=j+fy[f];
					if(id[x][y]){
						add(id[i][j],id[x][y],1,0);
					}	
				}
			}
		}	
	} run(zo,k);cout<<all+ansf<<endl;//注意ansf如上所述，是负数
}
```
第二种方法如另一篇题解所说，每个骨牌放下后，最多使 $6$ 种骨牌位置作废，所以选择的骨牌一定产生在前 $7k$ 大的骨牌里。

我们找出这 $7k$ 张骨牌，费用流只建"这些骨牌覆盖的点"所在的点和边，空间和时间就可以大大改善，大体上在 $O(k\times (7k)^2)$ 时空内就可以跑完，完整代码如下：

```cpp
#include<iostream>
#include<vector>
#include<cstdlib>
#include<queue>
#define For(u,v,i) for(int i=he[u],v=t[i].v;i;v=t[i=t[i].ne].v) 
using namespace std;
typedef long long ll; 
struct bian{
    int u,v,ne;short f,l;
};
const int N=40200,M=1410000;
bian t[M];
int he[N],l[N],p[N],we=1,qi,zo;bool in[N];
int d[N],o[N];
ll inf=1e9;
void more(int u,int v,ll l,ll f){
    t[++we].ne=he[u];he[u]=we;t[we].u=u;t[we].v=v;t[we].l=l;t[we].f=f;
}
void add(int u,int v,ll l,ll f){more(u,v,l,f);more(v,u,0,-f);}
void out(int n){
    for(int p=1;p<=n;p++){cout<<p<<"::";
        For(p,v,i){
            cout<<v<<","<<t[i].l<<","<<t[i].v<<"  ";
        }cout<<endl;
    }
}
bool spfa(int n){
    int w=0,h=0;l[w++]=qi;in[qi]=1;
    for(int i=1;i<=n;i++){d[i]=inf*2;p[i]=o[i]=0;}o[qi]=inf;d[qi]=0;
    while(w>h){
        int u=l[h];h++;in[u]=0;
        For(u,v,i){
            if(t[i].l==0)continue;
            if(d[v]>d[u]+t[i].f){
                d[v]=d[u]+t[i].f;o[v]=min(o[u],(int)t[i].l);p[v]=i;
                if(in[v]==0){in[v]=1;l[w++]=v;}
            }
        }
    }return o[zo];
}
ll ans,ansf;
void run(int n,int k){
    ans=ansf=0;
    while(spfa(n)){
        ans+=o[zo];ansf+=o[zo]*1LL*d[zo];
		if(ans==k)return;
        for(int i=p[zo];i;i=p[t[i].u]){
            t[i].l-=o[zo];t[i^1].l+=o[zo];
        }
    }
}
inline int read(){
    int x=0,f=1;char a1=getchar();while(a1<'0'||a1>'9'){if(a1=='-')f=-f;a1=getchar();}
    while(a1>='0'&&a1<='9'){x=x*10+(a1^48);a1=getchar();}return x*f;
}
//以上部分是费用流，上一种做法前面贴上这一段，N=4020000,M=24100000就是完整版
int id[2001][2001];
int s[2001][2001];
int cu[4000010];
int fx[4]={1,0,-1,0},fy[4]={0,1,0,-1};
struct dui{
	int u,v,le;
};
bool operator < (dui a,dui b){
	return a.le>b.le;
}
priority_queue<dui> to;//优先队列维护前k大
int main(){
	int n,k;cin>>n>>k;int ei=0;
	ll all=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			id[i][j]=++ei;s[i][j]=read();all+=s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((i&1)^(j&1)){
				for(int f=0;f<4;f++){int x=i+fx[f],y=j+fy[f];
					if(id[x][y]==0)continue;
					int le=s[i][j]+s[x][y];
					if(to.size()<k*7||le>to.top().le){
                   //比当前第7k大的边大，那就可以尝试放入
						to.push(dui{id[i][j],id[x][y],le});
					}if(to.size()>k*7){
                    //保持只有7k条
						to.pop();
					}
				}
			}
		}
	}ei=0;
	while(!to.empty()){
		cu[to.top().u]=++ei;cu[to.top().v]=++ei;to.pop();
	}qi=ei+1;zo=qi+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(cu[id[i][j]]==0)continue;
			if((i&1)^(j&1))add(qi,cu[id[i][j]],1,-s[i][j]);
			else add(cu[id[i][j]],zo,1,-s[i][j]);
			if((i&1)^(j&1)){
				for(int f=0;f<4;f++){int x=i+fx[f],y=j+fy[f];
					if(cu[id[x][y]]){
						add(cu[id[i][j]],cu[id[x][y]],1,0);
					}	
				}
			}
		}	
	} 
	run(zo,k);cout<<all+ansf<<endl;
}
```


---


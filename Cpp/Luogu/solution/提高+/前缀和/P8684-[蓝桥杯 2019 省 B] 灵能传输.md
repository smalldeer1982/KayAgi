# [蓝桥杯 2019 省 B] 灵能传输

## 题目背景

在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能“灵能风暴”可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位

## 题目描述

你控制着 $n$ 名高阶圣堂武士，方便起见标为 $1,2, \cdots,n$。每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 $a_i$ 表示其拥有的灵能的多少（$a_i$ 非负表示这名高阶圣堂武士比在最佳状态下多余了 $a_i$ 点灵能，$a_i$ 为负则表示这名高阶圣堂武士还需要 $-a_i$ 点灵能才能到达最佳战斗状态）。现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 $i \in[2,n-1]$，若 $a_i \ge 0$ 则其两旁的高阶圣堂武士，也就是 $i-1$ 、 $i+1$ 这两名高阶圣堂武士会从 $i$ 这名高阶圣堂武士这里各抽取 $a_i$ 点灵能；若 $a_i<0$ 则其两旁的高阶圣堂武士，也就是 $i-1,i+1$ 这两名高阶圣堂武士会给 $i$ 这名高阶圣堂武士 $-a_i$ 点灵能。形式化来讲就是 $(a_{i-1},a_i,a_{i+1})\leftarrow (a_{i-1}+a_i,-a_i,a_{i+1}+a_i)$。

灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 $\max\limits_{i=1}^n\{|a_i|\}$，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。

## 说明/提示

**【样例说明】**

对于第一组询问：

对 $2$ 号高阶圣堂武士进行传输操作后 $a_1=3$，$a_2=2$，$a_3=1$。答案为 $3$。

对于第二组询问：

这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。

**【数据规模与约定】**

对于所有评测用例，$T \le 3$，$3 \le n \le 3\times10^5$，$|a_i| \le 10^9$。

评测时将使用 $25$ 个评测用例测试你的程序，每个评测用例的限制如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/uvb2ynm2.png)

蓝桥杯 2019 年省赛 B 组 J 题。

## 样例 #1

### 输入

```
3 3
5 -2 3
4
0 0 0 0
3
1 2 3```

### 输出

```
3 0 3```

## 样例 #2

### 输入

```
3 4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1```

### 输出

```
5 7 4```

## 样例 #3

### 输入

```
见文件trans3.in。```

### 输出

```
见文件trans3.ans。```

# 题解

## 作者：Y_ATM_K (赞：7)

[题面传送门](https://www.luogu.com.cn/problem/P8684)

## 分析

先对灵能传递进行转化。

可以发现，如果把 $a$ 做一遍前缀和得到数组 $s$，那么对于一次对 $i$ 的灵能传递相当于把 $s_i,s_{i-1}$ 交换。

我们令 $s_0 = 0$，剩下的就是把 $s_{1 \sim n-1}$ 重新排列，使得 $\max_{i=1}^{n}{\{|s_i-s_{i-1}|\}}$ 最小。

如果可以移动 $s_0,s_n$，那么直接将 $s$ 排序，这样相邻的差是最小的。

通过上面的思路，不难想到这样的做法：

设 $L = \min(s_0,s_n),R = \max(s_0,s_n)$。先从 $L$ 取到 $s$ 最小值，再取到最大值，最后取到 $R$。

我们对 $s_{1 \sim n-1}$ 排序后，取第一个大于等于 $L$ 的位置 $M$，对于 $1 \sim M-1$ 的数，分别放在 $L,M$ 下面，从大到小地把数放在较小的一边，对 $M+1 \sim n-1$ 的同理。

这样一定是相邻差最小的。

以放 $1 \sim M-1$ 为例。如下图，考虑交换两个数 $x,y$，对于 $x,y$ 上面的 $p,q$，根据前面的贪心策略，一定有 $y \le x \le q \le p$，因此交换后最大距离变大；对于 $x,y$ 下面的 $s,t$ 同理。

![](https://cdn.luogu.com.cn/upload/image_hosting/7q03gqom.png)

时间复杂度为 $O(Tn \log n)$。

## 代码
```cpp
#include <bits/stdc++.h>
#define N 300005
#define ll long long
using namespace std;
int T,n;ll a[N],ans;
int main() {
	scanf("%d",&T);
	while(T--) {
		scanf("%d",&n);
		for(int i=1;i<=n;++i) scanf("%lld",&a[i]),a[i]+=a[i-1];
		sort(a+1,a+n);ans=0;
		ll L=0,R=a[n];if(L>R) swap(L,R);
		int m=lower_bound(a+1,a+n,L)-a;
		ll l=L,r=a[m];
		for(int i=m;i;--i) {
			if(l<r) swap(l,r);
			ans=max(ans,l-a[i]);
			l=a[i];
		}
		ans=max(ans,max(l-r,r-l));
		l=a[m],r=R;
		for(int i=m+1;i<n;++i) {
			if(l>r) swap(l,r);
			ans=max(ans,a[i]-l);
			l=a[i];
		}
		ans=max(ans,max(l-r,r-l));
		if(m==n) ans=max(ans,R-a[n-1]);
		printf("%lld\n",ans);
	}
	return 0;
} 
```

---

## 作者：modfisher (赞：4)

只能说太妙了。

## 思路
考虑前缀和数组 $s_i$，观察对 $i$ 进行一次操作后，前缀和数组的变化。

对于 $s'_{i-1}$，它变成了 $s_{i-2}+a_{i-1}+a_i=s_i$。

对于 $s'_i$，它变成了 $s_{i-2}+a_{i-1}+a_i-a_i=s_{i-1}$。

对于 $s'_{i+1}$，它变成了 $s_{i-2}+a_{i-1}+a_i-a_i+a_{i+1}+a_i=s_{i+1}$。

所以，对 $i$ 进行一次操作，相当于交换 $s_{i-1}$ 和 $s_i$。

设 $s_0=0$。我们的目的变成了：对 $s_1,s_2,\dots,s_{n-1}$ 进行重排，使：

$$\max_{i=1}^n\lvert s_i-s_{i-1}\rvert$$

取到最小值。

先不妨令 $s_0\le s_n$。如果大于的话把整个前缀和数列翻转即可。

考虑 $n$ 个点 $A_0(0,s_0),A_1(1,s_1),\dots,A_n(n,s_n)$，由于 $s_0,s_n$ 不可移动，所以有四个点十分关键：$A_0,A_n,A_s,A_t$，其中 $A_s,A_t$ 表示纵坐标最小和最大的点。

很容易发现，我们希望重排完成后，这些点组成的函数在 $[0,s]$ 上单调递减，在 $[s.t]$ 上单点递增，在 $[t,n]$ 上单调递减。

感性理解一下：显然从 $A_s$ 到 $A_t$ 的过渡是必要的，那么由 $A_0$ 过渡到 $A_s$，由 $A_n$ 过渡到 $A_t$ 显然比由 $A_0$ 过渡到 $A_t$，由 $A_n$ 过渡到 $A_s$ 要优（因为 $s_0\le s_n$），而显然用单调排列的点列来过渡是最优的。

将 $A_1$ 到 $A_{n-1}$ 按纵坐标从小到大排序，考虑寻找一个点 $A_m$，使 $s_m\ge s_0$ 且 $m$ 最小。此时我们希望 $A_0,A_1,\dots,A_{m-1}$ 构成这个函数左半边的部分（即一个有最小值的单峰函数）；$A_{m+1},A_{m+2},\dots,A_n$ 构成这个函数的右半边部分（即一个有最大值的单峰函数）。

现在，这两堆该如何排列呢？

对于左边，固定 $A_m$，我们要将 $A_1,A_2,\dots,A_{m-1}$ 在 $A_0$ 和 $A_m$ 之间以合理的顺序从左、右端插入到其中，记 $l$ 为当前左段的最小纵坐标，$r$ 为当前右端的最小纵坐标。初始化 $l=s_0,r=s_m$，从 $A_{m-1}$ 到 $A_1$ 依次枚举这些点。设当前要插入 $A_x$，我们应将其插入到 $l,r$ 中较大的那边。

仍然是感性理解一下，假设你插到较小的那一边，会使得这一边的点的相邻纵坐标差中出现一个较小的值，与之相对地，之后必然会出现一个较大的值，使得答案不优；所以，我们让纵坐标差尽可能平均分布。

对于右边同理。最后所有差值取最小即可。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 3e5 + 5;

ll sum[maxn];

int main(){
	int T;
	scanf("%d", &T);
	while(T --){
		int n;
		scanf("%d", &n);
		for(int i = 1; i <= n; i ++){
			int a;
			scanf("%d", &a);
			sum[i] = sum[i - 1] + a;
		}
		sort(sum + 1, sum + n);
		if(sum[0] > sum[n]) swap(sum[0], sum[n]);
		int mid = lower_bound(sum + 1, sum + n, sum[0]) - sum;
		ll l, r, ans = 0;
		l = sum[0], r = sum[mid];
		for(int i = mid - 1; i > 0; i --){
			if(l >= r) ans = max(ans, l - sum[i]), l = sum[i];
			else ans = max(ans, r - sum[i]), r = sum[i];
		}
		ans = max(ans, abs(l - r));
		l = sum[mid], r = sum[n];
		for(int i = mid + 1; i < n; i ++){
			if(l <= r) ans = max(ans, sum[i] - l), l = sum[i];
			else ans = max(ans, sum[i] - r), r = sum[i];
		}
		ans = max(ans, abs(l - r));
		printf("%lld\n", ans);
	}
	return 0;
}
```


---

## 作者：bluewindde (赞：4)

对题目的式子进行一个前缀和：

$$
\begin{matrix}
&(a_{i-1}, a_i, a_{i+1})
&\leftarrow
&(a_{i-1} + a_i, -a_i, a_{i+1} + a_i) \\
&(a_{i-1}, a_{i-1} + a_i, a_{i-1} + a_i + a_{i+1})
&\leftarrow
&(a_{i-1} + a_i, a_{i-1}, a_{i-1} + a_i + a_{i+1})
\end{matrix}
$$

可以发现，对位置 $i$ 进行一次传递灵能，等价于交换位置 $i$ 和 $i - 1$ 的前缀和。

设数组 $a$ 的前缀和为 $f_{0 \sim n}$。

如果每个位置都可以传递灵能，那么排序一次就可以得到最小的不稳定度，但是我们只能操作区间 $(2, n)$，所以能影响到的前缀和位置是 $[1, n)$。

数形结合，假设有原数组 $a = \{1, -2, 5, -9, 6, 3\}$，前缀和数组 $f = \{0, 1, -1, 4, -5, 1, 4\}$。它在不稳定度最小时，$f' = \{0, -5, -1, 1, 1, 4, 4\}$。

图中蓝点是初始的前缀和数组，红点是最终的前缀和数组，黑线是最终的前缀和数组的连线。

[图太大，放这里了。](https://cdn.luogu.com.cn/upload/image_hosting/mf375c7u.png)

这条连线可以分为下单峰函数和上单峰函数两个部分。用类似 wqs 二分的思想，分别讨论两个单峰函数。先排序 $f_{1} \sim f_{n - 1}$，然后二分求出上下单峰函数的分界点 $sep$。讨论如下：

- 对于 $i < sep$：

  初始化 $head = \min(f_0, f_n), tail = f_{sep}$。

  - 如果 $head < tail$，意味着此时把 $i$ 加到 $tail$ 可以得到一个更大的差值，所以把 $i$ 放在 $tail$ 前面，贡献 $tail - f_i$，然后令 $tail \leftarrow f_i$。
  - 否则，意味着此时把 $i$ 加到 $head$ 可以得到一个更大的差值，所以把 $i$ 放在 $head$ 后面，贡献 $head - f_i$，然后令 $head \leftarrow f_i$。

  **原理：总的差值是一定的（这个差值之和是极值与初始的 $head, tail$ 的差之和），差值的个数也是一定的，使每一个差值更大就会使差值的极差更小，也就不容易让 $\max$ 取到更大的值，也就会让答案更小。**

  最后，注意 $|head - tail|$ 也会对答案产生贡献。

- 对于 $i > sep$：

  初始化 $head = f_{sep}, tail = \max(f_0, f_n)$。

  - 如果 $head < tail$，意味着此时把 $i$ 加到 $head$ 可以得到一个更大的差值，所以把 $i$ 放在 $head$ 后面，贡献 $f_i - head$，然后令 $head \leftarrow f_i$。
  - 否则，意味着此时把 $i$ 加到 $tail$ 可以得到一个更大的差值，所以把 $i$ 放在 $tail$ 前面，贡献 $f_i - tail$，然后令 $tail \leftarrow f_i$。

  最后，注意 $|head - tail|$ 也会对答案产生贡献。

- 对于 $i = sep$，不考虑，因为它的贡献被另外两类讨论包含。

- 特别地，如果 $sep = n$，意味着我们的第二类讨论的循环不会遍历到东西，也就可能漏掉情况。为处理此情况，额外贡献一个 $\max(f_0, f_n) - f_{n - 1}$。

很妙的题。

[code.](https://www.luogu.com.cn/paste/ley385ez)

不要把 `f[i] - head` 写成 `f[i] = head`！


---

## 作者：dutianchen1 (赞：2)

# P8684 灵能传输

### 题意概括

有 $n$ 个元素，每个元素大小为 $a_{i}$。我们可以对 $\forall a_{i} ( i \in [1,n] \cap \mathbb{Z})$ 进行操作，操作会产生以下影响： $a_{i-1} \gets a{i-1}+a_{i},a_{i} \gets -a_{i},a_{i+1} \gets a_{i+1}+a_{i}$。

我们可以进行无数次操作，要求最小化 $\max\limits_{i=1}^n\{|a_i|\}$ 并求得最小值。

### 思路简析

我们首先就要考虑每次操作对整个序列带来的影响。显然能够发现将原序列求前缀和后的性质：每次操作只会交换 $s_{i-1}$ 与 $s_{i}$ 的位置。

从逻辑上讲，首先我们每次传递显然不会改变 $s_{i+1}$ 的值，而 $s_{i-1}$ 加上了一个 $a_{i}$ ，所以 $s_{i}$ 会先因为本身减去 $2a_{i}$，再由于 $s_{i-1}'\to s_{i-1}+a{i}$ 而最终减去 $a_{i}$，从而实现两者的交换。

数学上的证明如下：
$$
s_{i-1}':s_{i-2}+a_{i-1} \to s_{i-2}+a_{i-1}+a_{i}=s_{i}\\
s_{i}':s_{i-2}+a_{i-1} \to s_{i-2}+a_{i-1}+a_{i}-a_{i}=s_{i-1}\\
s_{i+1}':s{i-2}+a_{i-1}+a_{i}+a_{i+1}+a_{i}+a_{i}-2a_{i}=s_{i+1}\\
$$
知道这个性质之后，我们接着考虑如何使得操作后最小化 $\max\limits_{i=1}^n\{|a_i|\}$ ，也就是序列 $s$ 的极差（取绝对值）。

首先不妨令 $s_{0} \le s{n}$。

一个显然的贪心策略就是让序列单调递增。

但是由于我们不能交换 $s_{n}$，导致 $s_{n}$ 的大小不定，可能反而会最大化序列极差。

于是我们考虑转变策略。

因为我们不知道 $s_{n}$ 的大小，我们可以考虑将整个序列分成两半。

让左半侧形成一个山谷状的单峰函数，右半侧形成一个山峰状的单峰函数（当然分别形成单增和单减形的函数也行）。

因为 $s_{0}\le s_{n}$，我们可以选取到第一个 $\ge s_{0}$ 的$s_{i}$，从 $s_{0}$ 到 $s_{i}$ 形成山谷状，从 $s_{i}$ 到 $s_{n}$ 形成山峰状。图像大概如下：

![有点潦草，见谅](https://cdn.luogu.com.cn/upload/image_hosting/t0oqj3fi.png?x-oss-process=image)

思路有了，那么实现就很简单了。

我们只需要将两段分别处理即可，每次向中间插入元素时保证插入当前离极值点较远的一侧即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
ll T;
ll n,pos;
ll num[N],sum[N];
ll ans[N];
ll lpos,rpos,lmax,rmax;
void clear(){
	for(int i=1;i<=n;i++){
		ans[i]=0;
	}
}
int main()
{
	T=read();
	while(T--){
		n=read();
		clear(); 
		for(int i=1;i<=n;i++){
			num[i]=read();
			sum[i]=sum[i-1]+num[i];
		}
		if(sum[0]>sum[n])swap(sum[0],sum[n]);
		sort(sum+1,sum+n);
		pos=n;
		for(int i=1;i<n;i++){
			if(sum[i]>=sum[0]){
				pos=i;break;
			}
		}
//		for(int i=0;i<=n;i++){
//			cout<<sum[i]<<' ';
//		}
//		cout<<'\n'<<pos<<'\n';
		ans[0]=sum[0];ans[n]=sum[n];ans[pos]=sum[pos];
		lpos=0,rpos=pos;
		lmax=ans[0],rmax=ans[pos];
		ll maxx=-1;
		for(int i=pos-1;i>0;i--){
			if(lmax<rmax){
				maxx=max(maxx,rmax-sum[i]);
				ans[--rpos]=sum[i];
				rmax=sum[i];
			}
			else{
				maxx=max(maxx,lmax-sum[i]);
				ans[++lpos]=sum[i];
				lmax=sum[i];
			}
		}
		maxx=max(maxx,abs(lmax-rmax)); 
		lpos=pos,rpos=n;
		lmax=ans[pos],rmax=ans[n];
		for(int i=pos+1;i<n;i++){
			if(lmax<=rmax){
				maxx=max(maxx,sum[i]-lmax);
				ans[++lpos]=sum[i];
				lmax=sum[i];
			}
			else{
				maxx=max(maxx,sum[i]-rmax);
				ans[--rpos]=sum[i];
				rmax=sum[i];
			}
		}
		maxx=max(maxx,abs(lmax-rmax)); 
//		for(int i=1;i<=n;i++)cout<<ans[i]<<' ';cout<<'\n';
		
		cout<<maxx<<'\n';
	}
	return 0;
}
/*
1
5
2 -1 2 2 -1 
*/
```

---

## 作者：cq_irritater (赞：2)

- **[题目传送门](https://www.luogu.com.cn/problem/P8684)**

本题涉及到了 $3$ 种算法：**前缀和，排序以及贪心**。

（1）前缀和  
本题实际上要求通过某种灵能传输可以使得该序列的最大值最小。而由前缀和可知，当某一个前缀和序列保持有序（或前缀和序列表示的函数单调）时，其 $s[i] - s[i - 1]$ 的最大值可以达到最小。  
通过对几个样例的观察我们不难发现：  
1.当 $a[i] > 0$ 时，若 $a[i - 1] \gets a[i - 1] + a[i]$，则 $s[i - 1]$ 等于原来的 $s[i]$。  
2.若 $a[i] \gets a[i] - 2 \times a[i]$，则原 $s[i - 1] \gets s[i - 1] + a[i]$。  
3.现 $s[i] \gets $ 现 $s[i - 1] - a[i] \gets $ 原 $s[i] - a[i] \gets$ 原 $s[i - 1]$。  
这意味着除了 $s[0]$ 和 $s[n]$ 以外，$1 \sim n$ 的任何 $s[i]$ 都可以进行互相交换，从而得到一个有序序列。而 $a[i] \gets s[i] - s[i - 1]$ 也就意味着可以通过交换 $s[i]$ 的方式得到灵能传输后的最终结果。

（2）排序
```cpp
for (int i = 1; i <= n; i++)
{
    scanf("%d", &a[i], s[i] = s[i - 1] + a[i]);
}
sort(s + 1, s + 1 + n);
```
当然，如果 $s[0]$ 和 $s[n]$ 也可以正常交换，则只需要将整个前缀和序列进行排序，即可直接得到一个单调函数，那么本题的推导到这一步就可以结束了，可以通过直接计算 $\max(s[i] - s[i - 1])$ 的值获得最大值和最小值。但问题就在于 $s[0]$ 和 $s[n]$，即最终得到的序列不一定是单调的，所以接下来就要通过一系列操作解决序列不单调的问题。

（3）贪心  
通过上述的分析可以得知，想要求出本题的最优解就是使得所求序列尽可能保持单调。通过画图可知，在两个端点无法移动的条件下，在对于整个前缀和序列进行排序时，总能得到一个拥有两个拐点且中间部分保持单调的函数。此时就应该往贪心上思考，即当一条有两个拐点的曲线的重叠部分最小时单调部分最多，而一条曲线符合下列情况时符合要求。  
①左端点小于右端点，即 $s[0] < s[n]$。在记录 $s_0$ 和 $s_n$ 的值时需要进行一次判定，如果得到的左端点比右端点大，那么就将这两个端点交换（尽量保证得到的函数是一个中部递增的单调函数，其目的是将得到的所有函数都变成中部递增函数，这样就可以少算至少一半的数据）。
```cpp
if (s0 > sn)
{
    swap(s0, sn);
}
```
②极小值在极大值左边（刚刚的情况中，要求得到的函数一定是中部递增的，因此不仅需要控制函数中部的递增，还要控制最大值和最小值以使得中部函数递增）。这就要求在后续选点时应遵循 $s[0]$ 向左取，$s[n]$ 向右取，因为这样才能取得两边的极值。  
因为已经将两个端点确定并保证了两者的顺序，也对前缀和序列进行了升序处理，于是此时得到了一个存放着递增的前缀和序列的有序数组（左右端点的位置已经发生改变，情况①中已经记录了两者位置）。  
接下来需要从左端点的位置向左依次取点，从右端点的位置向右依次取点（从左端点向左依次取点并取得前缀和序列的最小值，从右端点向右依次取点并取得前缀和序列的最大值）。此时通过画图可以求得函数为两个端点有拐点且中部有序递增的函数。
```cpp
int l = 0, r = n - 1;
for (int i = s0; i >= n; i -= 2)
{
    f[l++] = s[i];
    st[i] = true;
}
for (int i = sn; i <= n; i += 2)
{
    f[r--] = s[i];
    st[i] = true;
}
for (int i = 0; i <= n; i++)
{
    if (st[i] == false)
    {
        f[l++] = s[i];
    }
}
```
因为图像中有两个拐点而且会形成两个重叠部分，所以想要得到最优解，就要使得求得的函数图像中的递增部分尽可能地多，这样拐点处的图像就会尽可能地少，即可保证序列 $f$ 为重叠部分最小的前缀和序列。  
在通过特定规则将所有点都遍历完毕后，此时已经得到最优解的图像（前缀和序列）。最后就是求出所有前缀和表示的灵能值中的最大者（一定为正），该灵能值便是最终答案。
```cpp
int res = 0;
for (int i = 1; i <= n; i++)
{
    res = max(res, abs(f[i] - f[i - 1]));
}
```
$res$ 即为所求结果。

代码如下：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 10;

typedef long long ll;

int t;

ll a[N], s[N], f[N];

bool st[N];

void work()
{
    int n;
    scanf("%d", &n);
    s[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &a[i]);
        s[i] = s[i - 1] + a[i];
    }
    ll s0 = s[0];
    ll sn = s[n];
    if (s0 > sn)
    {
        swap(s0, sn);
    }
    sort(s, s + 1 + n);
    for (int i = 0; i <= n; i++)
    {
        if (s0 == s[i])
        {
            s0 = i;
            break;
        }
    }
    for (int i = 0; i <= n; i++)
    {
        if (sn == s[i])
        {
            sn = i;
            break;
        }
    }
    memset(st, false, sizeof st);
    int l = 0, r = n;
    for (int i = s0; i >= 0; i -= 2)
    {
        f[l++] = s[i];
        st[i] = true;
    }
    for (int i = sn; i <= n; i += 2)
    {
        f[r--] = s[i];
        st[i] = true;
    }
    for (int i = 0; i <= n; i++)
    {
        if (st[i] == false)
        {
            f[l++] = s[i];
        }
    }
    ll res = 0;
    for (int i = 1; i <= n; i++)
    {
        res = max(res, abs(f[i] - f[i - 1]));
    }
    printf("%lld\n", res);
    return;
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        work();
    }
    return 0;
}
```

---


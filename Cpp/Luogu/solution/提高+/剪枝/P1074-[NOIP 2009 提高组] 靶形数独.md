# [NOIP 2009 提高组] 靶形数独

## 题目背景

**此为远古题，不保证存在可以通过任意符合要求的输入数据的程序**。

## 题目描述

小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。

靶形数独的方格同普通数独一样，在 $9$ 格宽且 $9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽且 $3$ 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）

![](https://cdn.luogu.com.cn/upload/image_hosting/dhvuc32i.png)

上图具体的分值分布是：最里面一格（黄色区域）为 $10$ 分，黄色区域外面的一圈（红色区域）每个格子为 $9$ 分，再外面一圈（蓝色区域）每个格子为 $8$ 分，蓝色区域外面一圈（棕色区域）每个格子为 $7$ 分，最外面一圈（白色区域）每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和

总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$。游戏规定，将以总分数的高低决出胜负。

![](https://cdn.luogu.com.cn/upload/image_hosting/yx82mmnc.png)

由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。


## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，数独中非 $0$ 数的个数不少于 $30$；
- 对于 $80\%$ 的数据，数独中非 $0$ 数的个数不少于 $26$；
- 对于 $100\%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
7 0 0 9 0 0 0 0 1 
1 0 0 0 0 5 9 0 0 
0 0 0 2 0 0 0 8 0 
0 0 5 0 2 0 0 0 3 
0 0 0 0 0 0 6 4 8 
4 1 3 0 0 0 0 0 0 
0 0 7 0 0 2 0 9 0 
2 0 1 0 6 0 8 0 4 
0 8 0 5 0 4 0 1 2
```

### 输出

```
2829```

## 样例 #2

### 输入

```
0 0 0 7 0 2 4 5 3 
9 0 0 0 0 8 0 0 0 
7 4 0 0 0 5 0 1 0 
1 9 5 0 8 0 0 0 0 
0 7 0 0 0 0 0 2 5 
0 3 0 5 7 9 1 0 8 
0 0 0 6 0 1 0 0 0 
0 6 0 9 0 0 0 0 1 
0 0 0 0 0 0 0 0 6```

### 输出

```
2852```

# 题解

## 作者：学无止境 (赞：293)

本人蒟蒻，发个蒟蒻看得懂的题解~~


dfs代码最终效率不高——**2000ms——3000多ms**，（~~但是AC了，或许是数据水吧~~）


大家玩过数独（没玩过的先了解规则去吧）


我的思路是dfs（不打表），用一个序列s[ ]保存要填的点，dfs携带的参数就是要填写的点的坐标：

s[ i ][0]与s[ i ][1]存点的坐标，s[ i ][2]存点的分值，s[ i ][3]存点的所在宫（我用函数现生成，避免了打表）。


需要注意的有如下几点：


一、dfs过程中就判断数能不能放，别放到最后判断（这一条可能是废话）实现方法用三个数组分别存各行、列、宫每个数字的状态（0表示没填过，1表示填过）


（重要）二、dfs层数与0的个数有关，层数太多就TLE了，我们知道，一行中填过的数字越多，需要填的数越少，就意味着dfs层数越少！所以，我们先填0的数量少的行。（详细实现见代码）


不懂的看这：）











```cpp
0 0 0 0 0 0 0 0 0    //这一行有9个0
1 0 0 0 0 5 9 0 0  //这一行有6个0
0 0 0 2 0 0 0 8 0 //这一行有7个0
0 0 5 0 2 0 0 0 3 //这一行有6个0
0 0 0 0 0 0 6 4 8 //这一行有6个0
4 1 3 0 0 0 0 0 0 //这一行有6个0
0 0 7 0 0 2 0 9 0 //这一行有6个0
2 0 1 0 6 0 8 0 4 //这一行有4个0
0 8 0 5 0 4 0 1 2//这一行有4个0
```
在这个例子中，从第一行到第九行dfs的话，那么dfs第一层就有9种情况！！！根据dfs的原理，从第一层9种情况开始拓展，那么时间就要花很多。而若从第8层开始只有4种情况，搜索需要的时间就大大减少。~~TLE再见！！~~

**Code：**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct f
{
    int rank,sum;//定义结构体，将行号与0的个数对应 
}cou[10];
int a[10][10],hang[10][10],lie[10][10],gong[10][10],s[100][4],u,ok,most=-1,have;
int which(int,int);//给出两个整型变量代表坐标，返回此坐标的所在宫                                     
int point(int,int);//给出两个整型变量代表坐标，返回此坐标的分值                                                                  
void dfs(int,int); 
bool cmp(f a,f b)
{
    return a.sum<b.sum; 
}
int main()
{
    for(int i=1;i<=9;i++)  cou[i].rank=i;//rank存其初始行号，排序后就不会丢失 
    for(int i=1;i<=9;i++)
    for(int j=1;j<=9;j++)
    {
        cin>>a[i][j];
        if(a[i][j]>0)
        hang[i][a[i][j]]=lie[j][a[i][j]]=gong[which(i,j)][a[i][j]]=1,have+=a[i][j]*point(i,j);//非零就不存储到搜索数组s中，但将这个点的值在其所在行、列、宫中标记 ，计算加分 
        else  cou[i].sum++;//是0就计数 
    }
    sort(cou+1,cou+10,cmp);//排序，0少的在前 
    for(int i=1;i<=9;i++)//整理s数组，准备搜索 
    {
        for(int j=1;j<=9;j++)//先搜0少的行 
        if(a[cou[i].rank][j]==0)
        s[u][0]=cou[i].rank,s[u][1]=j,s[u][2]=point(cou[i].rank,j),s[u++][3]=which(cou[i].rank,j);//保存不解释 
    }
    dfs(0,have);//搜索 
    cout<<most<<endl;//most保存答案，初始值为-1 
    return 0;
} 

void dfs(int p,int score)// 表示正在搜s[p],score为目前分数 
{
    if(p==u)//合法填完了所有的数 
    {
        if(score>most)  most=score;//更大就更新 
        return;
    }
    for(int i=1;i<=9;i++) 
    {
        if(!hang[s[p][0]][i]&&!lie[s[p][1]][i]&&!gong[s[p][3]][i])//判断可不可以将i填入 
        {
            hang[s[p][0]][i]=lie[s[p][1]][i]=gong[s[p][3]][i]=1;//填了后就将这个点的值在其所在行、列、宫中标记
            dfs(p+1,score+(s[p][2]*i));//下一层递归 
            hang[s[p][0]][i]=lie[s[p][1]][i]=gong[s[p][3]][i]=0;//回溯 
        }
    }
    return;
}

int which(int i,int j)
{
    if(i<=3)
    {
        if(j<=3)        return 1;
        else if(j<=6)   return 2;
        else            return 3;
    }
    else if(i<=6)
    {
        if(j<=3)        return 4;
        else if(j<=6)    return 5;
        else            return 6;
    }
    else
    {
        if(j<=3)        return 7;
        else if(j<=6)   return 8;
        else            return 9;
    }
}

int point(int i,int j)
{
    if(i==1||j==1||i==9||j==9)   return 6;
    if(i==2||j==2||i==8||j==8)     return 7;
    if(i==3||j==3||i==7||j==7)   return 8;
    if(i==4||j==4||i==6||j==6)   return 9;
    return 10;
}
```
我认为已经很详细了，还不懂私我。


---

## 作者：Timothy (赞：77)

来一个dancing-links的题解。

首先，要将数独问题转化为一个精确覆盖问题。

于是我们重新建立一个1\*(N\*N\*N)矩阵。

1）由于每个格子只能填一个数，用1~81列表示每一个是否填数

2）由于每个数在每一列只能出现一次，用82~162列表示是否满足这个条件

3）行和宫的方法是一样的。。。

接着，枚举每个格子的方案，将这些方案在新的矩阵中所能覆盖的格子用二维链表连起来。

最后，每次dfs时，找方案数最少的进行搜索，并将该方案删除。当链表为空时，则表明已找到一个解，进行计算就可以了。

P.S.：dancing-links可以帮你想到很多你可能多想不到的剪枝，实际上就是楼下的多种优化的结合，但是用链表之后就不用在费时间去想剪枝了。

代码：

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int fen[100]={0,6,6,6,6,6,6,6,6,6,
```
6,7,7,7,7,7,7,7,6,
6,7,8,8,8,8,8,7,6,

6,7,8,9,9,9,8,7,6,

6,7,8,9,10,9,8,7,6,

6,7,8,9,9,9,8,7,6,

6,7,8,8,8,8,8,7,6,

6,7,7,7,7,7,7,7,6,

```cpp
                6,6,6,6,6,6,6,6,6};
const int N=9;
const int mm=N*N*N*N*N*4+N;
const int mn=N*N*N+N;
int map[10][10];
int ans=-1,size;
int U[mm],D[mm],L[mm],R[mm],C[mm],X[mm];
int S[mn],Q[mn],H[mn];
bool v[mn];
inline void prepare(int r,int c){
    for (int i=0;i<=c;++i){
        S[i]=0;
        U[i]=D[i]=i;
        L[i+1]=i;
        R[i]=i+1;
    }
    R[size=c]=0;
    while (r)H[r--]=-1;
}
inline void place(int &r,int &c1,int &c2,int &c3,int &c4,int i,int j,int k){
    r=((i-1)*N+j-1)*N+k;
    c1=(i-1)*N+j;
    c2=N*N+(i-1)*N+k;
    c3=N*N*2+(j-1)*N+k;
    c4=N*N*3+(((i-1)/3)*3+(j-1)/3)*N+k;
}
inline void link(int r,int c){
    ++S[C[++size]=c];
    X[size]=r;
    D[size]=D[c];
    U[D[c]]=size;
    U[size]=c;
    D[c]=size;
    if (H[r]==-1)H[r]=L[size]=R[size]=size;
    else{
        R[size]=R[H[r]];
        L[R[H[r]]]=size;
        L[size]=H[r];
        R[H[r]]=size;
    }
}
inline void remove(int c){
    L[R[c]]=L[c];R[L[c]]=R[c];
    for (int i=D[c];i!=c;i=D[i])
        for (int j=R[i];j!=i;j=R[j])
            D[U[j]]=D[j],U[D[j]]=U[j],--S[C[j]];
}
inline void resume(int c){
    for (int i=U[c];i!=c;i=U[i])
        for (int j=L[i];j!=i;j=L[j])
            ++S[C[D[U[j]]=U[D[j]]=j]];
    L[R[c]]=R[L[c]]=c;
}
void dance(int k){
    if (!R[0]){
        int ls=0;
        for (int i=0;i<k;++i)
            ls+=fen[(X[Q[i]]-1)/N+1]*((X[Q[i]]-1)%N+1);
        ans=ans>ls?ans:ls;
        return;
    }
    int tmp=mm,c;
    for (int i=R[0];i;i=R[i])
        if (S[i]<tmp)tmp=S[c=i];
    remove(c);
    for (int i=D[c];i!=c;i=D[i]){
        Q[k]=i;
        for (int j=R[i];j!=i;j=R[j])remove(C[j]);
        dance(k+1);
        for (int j=L[i];j!=i;j=L[j])resume(C[j]);
    }
    resume(c);
}
int main (){
    int r,c1,c2,c3,c4;
    prepare(mn,N*N*4);
    for (int i=1;i<=N;++i)
        for (int j=1;j<=N;++j){
            scanf ("%d",&map[i][j]);
            if (map[i][j]){
                place(r,c1,c2,c3,c4,i,j,map[i][j]);
                link(r,c1);link(r,c2);link(r,c3);link(r,c4);
                v[c1]=v[c2]=v[c3]=v[c4]=1;
            }
        }
    for (int i=1;i<=N;++i)
        for (int j=1;j<=N;++j)
            for (int k=1;k<=N;++k){
                place(r,c1,c2,c3,c4,i,j,k);
                if (v[c1] || v[c2] || v[c3] || v[c4])continue;
                link(r,c1);link(r,c2);link(r,c3);link(r,c4);
            }
    dance(0);
    printf ("%d",ans);
    return 0;
}
```

---

## 作者：liumuxin (赞：17)

这道题是一道dfs好题，很多人在题解里用了各种剪枝，以及一些奇奇怪怪的优化，还有大佬用的舞蹈链算法，蒟蒻不会舞蹈链，剪枝的效果也不是很好，只能用一些优化来过这道题了。

这道题虽然已经有很多题解了，但是我还是来交题解的原因是我觉得我的代码跑的，可以给大家提供一些关于搜索顺序的思路，~~希望管理员不要认为我这是重复的解法~~。不过我敢保证，我的代码跑的一定比除了打表题解以外的题解跑的快。



~~说实话，这题普通剪枝也可以水过~~，但是既然我们要追求速度，就不能仅仅局限于最优性、可行性剪枝。画了几张图以后发现一个规律，先搜索约束个数多的点，效率最高。这里的约束个数，就是这个点所在行、列、宫已经填好的数的个数之和。（具体内容见下图）

所以我们就得到了一个思路，与处理好搜索顺序，也就是统计每个点的约束个数，先找到最多的，然后记录下来，假设它已经填好（把他所在的行、列、宫的约束个数加一），然后继续找第二多的就好了。最后按照这个顺序在每次dfs结束后找到下一个填数的点，就ok了，这样可以达到总效率888ms,已经非常快了。

![大家可以看一下，第一个就是预处理后的搜索树，第二个是随便搜，差距一目了然](https://cdn.luogu.com.cn/upload/pic/73082.png)

显然先搜索可能性为2的节点比先搜索可能性为4的搜索树小很多，当可能性扩大到9*9=81时，差距会十分明显，效率自然也就高很多了

很多细节详见代码注释。

因为很多人只是预处理了列，按照列每次处理9个，所以效率没有我这种写法高


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int ans[13][13];
int cntc[13],cntr[13],cntb[13];
int belong(int x,int y){//判断x,y属于哪一个宫
	int h,l;
	if(x<=3)h=1;
	else if(x<=6)h=2;
	else h=3;
	if(y<=3)l=1;
	else if(y<=6)l=2;
	else l=3;
	return (h-1)*3+l;
}
pair<int,int> s[100];
int cnt=0;
int ANS=0;
int v[10][10]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6,},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
//记录每一个点的分数
void calc(){
	int tot=0;
	for(int i=1;i<=9;i++)
		for(int j=1;j<=9;j++)
			tot+=ans[i][j]*v[i][j];
	ANS=max(ANS,tot);
}//搜索完成后计算答案的函数
int col[20][20],row[20][20],block[20][20];
void dfs(int x,int y,int now){//简单的搜索，按照我们在main函数中预处理的pair<int,int> s的顺序搜索，这样效率最高
	if(now==cnt+1)calc();
	int b=belong(x,y);
	for(int i=1;i<=9;i++){
		if(!col[x][i]&&!row[y][i]&&!block[b][i]){//判断是不是可行
			col[x][i]=row[y][i]=block[b][i]=1;//标记访问
			ans[x][y]=i;
			dfs(s[now+1].first,s[now+1].second,now+1);
			col[x][i]=row[y][i]=block[b][i]=ans[x][y]=0;//回溯
		}
	}
}
int vis[20][20];
int main(){
	for(int i=1;i<=9;i++)
		for(int j=1;j<=9;j++){
			cin>>ans[i][j];
			if(ans[i][j]!=0)vis[i][j]=1,cntc[i]++,cntr[j]++,cntb[belong(i,j)]++,col[i][ans[i][j]]=1,row[j][ans[i][j]]=1,block[belong(i,j)][ans[i][j]]=1;		
			else cnt++;
		}//这里为预处理每一个点在行、列、宫中的限制个数
	for(int k=1;k<=cnt;k++){
		int Max=0,px,py;
		for(int i=1;i<=9;i++
			for(int j=1;j<=9;j++)
				if(cntc[i]+cntr[j]+cntb[belong(i,j)]>Max&&!vis[i][j])
				Max=cntc[i]+cntr[j]+cntb[belong(i,j)],px=i,py=j;
		s[k]=make_pair(px,py);
      //找到可能性最少的点，并假设他已经填好，继续找下一个   
		cntc[px]++,cntr[py]++,cntb[belong(px,py)]++;
		vis[px][py]=1;
	//	cout<<k<<" "<<px<<" "<<py<<endl;	
	}
	dfs(s[1].first,s[1].second,1);//从第一个开始搜索
	if(ANS!=0)
	cout<<ANS<<endl;
	else cout<<-1<<endl;//输出答案
}
```

```

---

## 作者：chenhanzheapple (赞：9)

# [传送门](https://www.luogu.com.cn/problem/P1074)


# DLX

## 引入——精确覆盖问题

### 定义

给定一个 $n$ 行 $m$ 列的 `01` 矩阵，现在你需要挑选若干行，使得对于矩阵的每一列 $j$，在你挑选的这些行中，有且仅有一个 $1$。找到任意解。这个问题被称为精确覆盖问题。

### 例子

$$
\begin{pmatrix}
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

### 暴力

#### 1

枚举每行是否被选择，时间复杂度 $O(n \times m \times 2^n)$。

#### 2

将每行看做一个二进制数，因此问题转换为：选择若干个二进制数，使它们的两两之间的按位与为 $0$，按位或为 $2^n-1$，$n$ 为选择二进制数的个数。枚举是否选择每个数，在搜索时判断即可做到 $O(2^n)$。

### 正解

暴力不可行，因此需要使用一种新的算法——Dancing Links 优化 X 算法，简称 DLX 算法。

## X 算法

### 定义-相关元素

  将 $x$ 行的所有元素打上标记，再将第 $x$ 行中含 $1$ 的列打上标记。所有打上标记的元素为 $x$ 行的相关元素。

  将 $y$ 列的所有元素打上标记，再将第 $y$ 列中含 $1$ 的行打上标记。所有打上标记的元素为 $y$ 列的相关元素。

### 定义-强相关元素

将 $x$ 行的所有元素打上标记，将第 $x$ 行中含 $1$ 的列打上标记，再将上一步所有打上标记的列中含 $1$ 的行打上标记。所有打上标记的元素为 $x$ 行的强相关元素。

将 $y$ 列的所有元素打上标记，将第 $y$ 列中含 $1$ 的行打上标记，再将上一步所有打上标记的行中含 $1$ 的列打上标记。所有打上标记的元素为 $y$ 列的强相关元素。

### 算法步骤

1. 选择矩阵中未选择过的一行，设选中的这个行是 **原来的** 第 $x$ 行，将 $x$ 加入到答案集合 $S$ 中（这里我们统一按从第一行选择到最后一行选择）。如果所有行都已经尝试过，则判定为无解，算法结束。

2. 删除所有 $x$ 行的强相关元素。

3. 若新矩阵为不为空，则转到第一步。若新矩阵为空且 $x$ 行中的元素全部为 $1$，则找到答案，答案为需要选择集合 $S$ 中的所有行。若新矩阵为空且之前选择的行中元素不是全部为 $1$，则转到第一步并将所有 $x$ 的相关元素恢复。 

### 例子

我们引用在精确覆盖问题中的例子来进行说明。

在这个例子中，我们先将这一行的所有强相关元素打上标记，再进行了删除操作。

初始矩阵为：

$$
\begin{pmatrix}
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 0 & 1
\end{pmatrix}
$$

1.  选择第一行。红色为被选中行。

  $$
  \begin{pmatrix}
    \color{Red}0 & \color{Red}0 & \color{Red}1 & \color{Red}0 & \color{Red}1 & \color{Red}1 & \color{Red}0 \\
    1 & 0 & 0 & 1 & 0 & 0 & 1 \\
    0 & 1 & 1 & 0 & 0 & 1 & 0 \\
    1 & 0 & 0 & 1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 1 & 1 & 0 & 1
    \end{pmatrix}
  $$

2.  将第一行的所有相关元素打上标记，其中蓝色表示标记。

  $$
  \begin{pmatrix}
    \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 \\
    1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 1 \\
    \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
    1 & 0 & \color{Blue}0 & 1 & \color{Blue}0 & \color{Blue}0 & 0 \\
    0 & 1 & \color{Blue}0 & 0 & \color{Blue}0 & \color{Blue}0 & 1 \\
    \color{Blue}0 & \color{Blue}0 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1
  \end{pmatrix}
  $$

3.  删除所有被标记元素，得到一个新的小 01 矩阵：

  $$
  \begin{pmatrix}
    1 & 0 & 1 & 1 \\
    1 & 0 & 1 & 0 \\
    0 & 1 & 0 & 1
  \end{pmatrix}
  $$

4.  选择第一行（注意，**这个第一行是新矩阵的第一行，下面所有对于行的称呼均为当前矩阵的行数**）。

  $$
  \begin{pmatrix}
    \color{Red}1 & \color{Red}0 & \color{Red}1 & \color{Red}1 \\
    1 & 0 & 1 & 0 \\
    0 & 1 & 0 & 1
  \end{pmatrix}
  $$

5.  将第一行的所有相关元素打上标记。

  $$
  \begin{pmatrix}
    \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
    \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
    \color{Blue}0 & \color{Blue}1 & \color{Blue}0 & \color{Blue}1
  \end{pmatrix}
  $$

6. 删除所有被标记元素，得到一个空矩阵。但是上次删除的行 `1 0 1 1` 不是全 $1$ 的，说明选择有误，需要回到 **这个例子的** 第 4 步重新选择。

7.  回溯到步骤 4，选择第二行。

  $$
  \begin{pmatrix}
    1 & 0 & 1 & 1 \\
    \color{Red}1 & \color{Red}0 & \color{Red}1 & \color{Red}0 \\
    0 & 1 & 0 & 1
  \end{pmatrix}
  $$

8.  将第二行的所有相关元素打上标记。

  $$
  \begin{pmatrix}
    \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}1 \\
    \color{Blue}1 & \color{Blue}0 & \color{Blue}1 & \color{Blue}0 \\
    \color{Blue}0 & 1 & \color{Blue}0 & 1
    \end{pmatrix}
  $$

9.  删除所有被标记元素，得到一个新的小 01 矩阵：
    
  $$
  \begin{pmatrix}
    1 & 1
  \end{pmatrix}
  $$

10.  选择第一行。

  $$
  \begin{pmatrix}
    \color{Red}1 & \color{Red}1
  \end{pmatrix}
  $$

11.  将第二行的所有相关元素打上标记。

  $$
  \begin{pmatrix}
    \color{Blue}1 & \color{Blue}1
  \end{pmatrix}
  $$

12.  删除所有被标记元素，得到一个空矩阵，且上一次删除的时候，删除的是全 $1$ 的行，算法结束，答案即为被选择的三行，即 $S$ 中的编号：$1, 4, 5$。

## Dancing-Links 优化 X 算法（DLX 算法）

### 来源及基本思想

不难看出，X 算法需要大量的删除行、删除列和恢复行、恢复列的操作。

因此我们可以使用双十字链表维护。

而在双向十字链表上不断跳跃的过程被形象地比喻成跳跃，因此被用来优化 X 算法的双向十字链表也被称为 Dancing Links。

下文将介绍双十字链表的实现方式及 DLX 算法的实现方式。

### 时间复杂度

$O(x^n)$，其中 $n$ 为矩阵中 $1$ 的个数，$x$ 为一个非常接近于 $1$ 的常数。

## 双十字链表（Dancing Links）

### 定义

双十字链表不同于普通链表，它有 $4$ 个指针，分别指向上、下、左、右四个元素。如下图所示是双十字链表里的单个节点。

以下所有关于指针数组的描述与下图相同。

![](https://cdn.luogu.com.cn/upload/image_hosting/p76qrimu.png)

一整个双十字链表：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg30g5mw.png)

其中 $first$ 数组指向的是每行的开头，而在每列的开头有一个哨兵节点（图中白色节点），红色的 $0$ 号节点是双十字链表的初始节点。

### 操作

#### remove 操作

`remove(x)` 这个操作可以将第 $x$ 列的所有强相关元素移除。

注意：我们下文使用这个双十字链表时仅会插入为 $1$ 的位置，因此可以暴力删点。下同，不再赘述。

将第 $x$ 列移除仅需将其哨兵节点左右的节点连接即可。

接着枚举该列的所有结点，再枚举这些列所在的行，将这些行的所有节点的上下节点连接即可。

示例程序：

```cpp
void remove(int x){
	//第x行的哨兵节点即为x节点。
	R[L[x]] = R[x];
	L[R[x]] = L[x];
	for(int y=U[x];y!=x;y=U[y]){
		for(int z=R[y];z!=y;z=R[z]){//因为每行都是双向循环链表，因此可以从任意这一行的一点开始遍历。
			U[D[z]] = U[z];
			D[U[z]] = D[z];
			sz[col[z]]--;//sz数组记录每列的元素个数，row_i表示i号元素属于哪一行，col_i表示i号元素属于哪一列，下同，并不再赘述。
		}
	}
}
```

#### recover 操作

`recover(x)` 这个操作可以将第 $x$ 列的所有强相关元素恢复。

这个操作即为 remove 操作的反向操作。

接着枚举该列的所有结点，再枚举这些列所在的行，将这些行的所有节点的上下节点连接到当前节点即可。

将第 $x$ 列移除仅需将其哨兵节点左右的节点连接到当前节点即可。

示例程序：

```cpp
void recover(int x){
	for(int y=U[x];y!=x;y=U[y]){
		for(int z=R[y];z!=y;z=R[z]){
			U[D[z]] = z;
			D[U[z]] = z;
			sz[col[z]]++;
		}
	}
	R[L[x]] = x;
	L[R[x]] = x;
}
```

#### build 操作

`build(r,c)` 操作可以建一个新的长为 $r$，宽为 $c$ 的双十字链表。

我们仅需建出哨兵元素即可。

因为每一行都是双向循环链表，所以哨兵元素也不例外。

![](https://cdn.luogu.com.cn/upload/image_hosting/gup99gc0.png)

示例程序：

```cpp
void build(int r,int c){
	n = r,m = c;//我们将双十字链表封装到结构体内，因此需要开设变量来保存边长。
	for(int i=0;i<=c;i++){//建立哨兵节点 
		L[i] = i-1,R[i] = i+1;
		U[i] = i,D[i] = i;//因为双十字链表的每一列也是双向循环链表，因此初始哨兵节点的上、下指针均指向自己。 
	}
  L[0] = c;
  R[c] = 0;
	id = c+1;//id表示如果要添加元素的话，下一个元素的编号，下文阐述插入操作时将会使用。
}
```

#### insert 操作

`insert(r,c)` 操作能在第 $r$ 行，第 $c$ 列的位置插入一个节点（这个节点编号为 $id$，上文示例程序的注释中有提到，这里不再赘述，下同）。

先设置这个节点的行（$row$ 数组）编号为 $r$，列（$col$ 数组）编号为 $c$。

然后将节点 $id$ 插入到第 $c$ 行哨兵节点下方，即 $c$ 节点下方。**我们可以这样做是因为我们在删除与恢复操作时会遍历一整行或一整列，而每行或每列中元素顺序并不重要，下同，并不再赘述。**

之后我们分两种情况讨论。

- 若第 $r$ 行在插入之前没有节点，则直接将 $first_r$ 指向节点 $id$。$id$ 的左、右指针均为本身，即 $id$。
- 若第 $r$ 行在插入之前有节点，则将节点 $id$ 插入到 $first_r$ 之后。

示例程序：

```cpp
void insert(int r,int c){
    id++;//注意要改变下一次插入元素的编号
    row[id] = r,col[id] = c;
    sz[c]++;//这里需要增加行元素个数
    U[id] = c;
    D[id] = D[c];
    U[D[c]] = id;
    D[c] = id;
    if(!first[r]){
        first[r] = L[id] = R[id] = id;
    }
    else{
        L[id] = first[r];
        R[id] = R[first[r]];
        L[R[first[r]]] = id;
        R[first[r]] = id;
    }
}
```

#### dance 操作

`dance(x)` 操作能递归实现 X 算法，这个操作也是 DLX 算法的主体。

步骤如下：

1. 若 $0$ 号节点没有右节点，即矩阵（双十字链表）中没有任何元素时，算法结束，答案为 $S$ 中的所有元素。
2. 枚举所有列，找到 $sz$ 最小的列，即 $1$ 个数最少的列（**这里与上文介绍 X 算法流程的部分有不同，这是为了使程序有启发性，使递归次数更少，也就是速度更快**），使用 remove 操作删除它。
3. 枚举该列所有有 $1$ 的行，枚举其是否被选择。
4. 递归下去，如果找到答案，返回；如果无解，返回并报告无解；否则恢复该列。

示例程序：

```cpp
bool dance(int x){
    if(!R[0]){
        ans = x;
        return 1;
    }
    int y = R[0];
    for(int i=R[0];i;i=R[i]){
        if(sz[i]<sz[y]){
            y = i;
        }
    }
    remove(y);
    for(int i=D[y];i!=y;i=D[i]){
        s[x] = row[i];
        for(int j=R[i];j!=i;j=R[j]){
            remove(col[j]);
        }
        if(dance(x+1)){
            return 1;
        }
        for(int j=L[i];j!=i;j=L[j]){
            recover(col[j]);
        }
    }
    recover(y);
}
```

### 最终程序/DLX 模板

```cpp
struct DLX{
    int n,m,id,ans;
    int L[1005],R[1005],U[1005],D[1005],first[1005],sz[1005],row[1005],col[1005],s[1005];
    void build(int r,int c){
        n = r,m = c;
        for(int i=0;i<=m;i++){
            L[i] = i-1,R[i] = i+1;
            U[i] = i,D[i] = i;
        }
        L[0] = c;
        R[c] = 0;
        id = c+1;
    }
    void remove(int x){
        R[L[x]] = R[x];
        L[R[x]] = L[x];
        for(int y=U[x];y!=x;y=U[y]){
            for(int z=R[y];z!=y;z=R[z]){
                U[D[z]] = U[z];
                D[U[z]] = D[z];
                sz[col[z]]--;
            }
        }
    }
    void recover(int x){
        for(int y=U[x];y!=x;y=U[y]){
            for(int z=R[y];z!=y;z=R[z]){
                U[D[z]] = z;
                D[U[z]] = z;
                sz[col[z]]++;
            }
        }
        R[L[x]] = x;
        L[R[x]] = x;
    }
    void insert(int r,int c){
        row[id] = r,col[id] = c;
        sz[c]++;
        U[id] = c;
        D[id] = D[c];
        U[D[c]] = id;
        D[c] = id;
        if(!first[r]){
            first[r] = L[id] = R[id] = id;
        }
        else{
            L[id] = first[r];
            R[id] = R[first[r]];
            L[R[first[r]]] = id;
            R[first[r]] = id;
        }
        id++;
    }
    bool dance(int x){
        if(!R[0]){
            ans = x;
            return 1;
        }
        int y = R[0];
        for(int i=R[0];i;i=R[i]){
            if(sz[i]<sz[y]){
                y = i;
            }
        }
        remove(y);
        for(int i=D[y];i!=y;i=D[i]){
            s[x] = row[i];
            for(int j=R[i];j!=i;j=R[j]){
                remove(col[j]);
            }
            if(dance(x+1)){
                return 1;
            }
            for(int j=L[i];j!=i;j=L[j]){
                recover(col[j]);
            }
        }
        recover(y);
    }
}DancingLinks;
```

## 建模

### 基本思想

对于每道题，我们考虑行和列代表的意义。

行代表 **决策**，也就是选\不选。

列代表 **状态**，也就是约束条件。

对于某一行而言，由于不同的列的值不相同，我们 **由不同的状态，定义了一个决策**。

## 解决数独问题

### 决策-行

依照上文，因为有 $9$ 行 $9$ 列，每个格子可以填的数组有 $[1,9]$（离散状态下），因此DLX有 $9^3$ 行，即 $729$ 行。

### 约束条件-列

在数独中，**每填一个数可以使用三元组 $(x,y,z)$ 表示，即在第 $x$ 行，第 $y$ 列填入了数 $z$。**

因此决策状态 $(x,y,z)$ 所造成的影响为：

- 第 $x$ 行使用了数 $z$，这一行不能继续使用该数。
- 第 $y$ 列使用了数 $z$，这一列不能继续使用该数。
- 设第 $x$ 行第 $y$ 列所在的宫为第 $w$ 宫，则第 $w$ 宫使用了数 $z$，这一宫不能继续使用该数。
- 第 $x$ 行第 $y$ 列填入的数 $z$，这个位置不能再次填数。

因此决策有 $4$ 种影响，数独里有 $81$ 个格子，因此有 $81 \times 4$ 列，即 $324$ 列。有 $729 \times 4$ 即 $2916$ 个 $1$。

由于这一部分较难理解，同时较难说明，因此标程中不予注释。

## 标程

### 9×9 大小

例题：P10482


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15][15];
struct DLX{
    int n,m,id,ans;
    int L[10005],R[10005],U[10005],D[10005],first[10005],sz[10005],row[10005],col[10005],s[10005];
    void build(int r,int c){
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(U,0,sizeof(U));
        memset(R,0,sizeof(R));
        memset(first,0,sizeof(first));
        memset(sz,0,sizeof(sz));
        memset(row,0,sizeof(row));
        memset(col,0,sizeof(col));
        memset(s,0,sizeof(s));
        n = r,m = c;
        for(int i=0;i<=m;i++){
            L[i] = i-1,R[i] = i+1;
            U[i] = i,D[i] = i;
        }
        L[0] = c;
        R[c] = 0;
        id = c+1;
    }
    void remove(int x){
        R[L[x]] = R[x];
        L[R[x]] = L[x];
        for(int i=D[x];i!=x;i=D[i]){
            for(int j=R[i];j!=i;j=R[j]){
                sz[col[j]]--;
                U[D[j]] = U[j];
                D[U[j]] = D[j];
            }
        }
    }
    void recover(int x){
        for(int i=U[x];i!=x;i=U[i]){
            for(int j=L[i];j!=i;j=L[j]){
                D[U[j]] = U[D[j]] = j;
                sz[col[j]]++;
            }
        }
        R[L[x]] = L[R[x]] = x;
    }
    void insert(int r,int c){
        id++;
        row[id] = r,col[id] = c;
        sz[c]++;
        U[id] = c;
        D[id] = D[c];
        D[c] = U[D[c]] = id;
        if(!first[r]){
            first[r] = L[id] = R[id] = id;
        }
        else{
            L[id] = first[r];
            R[id] = R[first[r]];
            R[first[r]] = L[R[first[r]]] = id;
        }
    }
    bool dance(int x){
        if(!R[0]){
            for(int i=1;i<x;i++){
                a[(s[i]-1)/81+1][(s[i]-1)/9%9+1] = (s[i]-1)%9+1;
            }
            return 1;
        }
        int y = R[0];
        for(int i=R[0];i;i=R[i]){
            if(sz[i]<sz[y]){
                y = i;
            }
        }
        remove(y);
        for(int i=D[y];i!=y;i=D[i]){
            s[x] = row[i];
            for(int j=R[i];j!=i;j=R[j]){
                remove(col[j]);
            }
            if(dance(x+1)){
                return 1;
            }
            for(int j=L[i];j!=i;j=L[j]){
                recover(col[j]);
            }
        }
        recover(y);
        return 0;
    }
}DancingLinks;
void work(int x,int y,int z){
    int idx = (x-1)*81+(y-1)*9+z;
    DancingLinks.insert(idx,(x-1)*9+z);
    DancingLinks.insert(idx,(y-1)*9+z+81);
    DancingLinks.insert(idx,((x-1)/3*3+(y-1)/3)*9+z+162);
    DancingLinks.insert(idx,(x-1)*9+y+243);
}
int main(){
    while(1){
        DancingLinks.build(729,324);
        for(int i=1;i<=9;i++){
            for(int j=1;j<=9;j++){
                char c;
                cin >> c;
                if(c=='e'){
                    return 0;
                }
                if(c>='0' && c<='9'){
                    a[i][j] = c-'0';
                    work(i,j,a[i][j]);
                }
                else{
                    for(int k=1;k<=9;k++){
                        work(i,j,k);
                    }
                }
            }
        }
        DancingLinks.dance(1);
        for(int i=1;i<=9;i++){
            for(int j=1;j<=9;j++){
                cout << a[i][j];
            }
        }
        cout << endl;
    }
    return 0;
}
```

### 16×16 大小

例题：UVA1309

基本思路与上文一致，仅需将计算行、列、宫时的公式换成 $16 \times 16$ 大小的公式，再将数组空间开大即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][105];
struct DLX{
    int n,m,id,ans;
    int L[200005],R[200005],U[200005],D[200005],first[200005],sz[200005],row[200005],col[200005],s[200005];
    void build(int r,int c){
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(U,0,sizeof(U));
        memset(R,0,sizeof(R));
        memset(first,0,sizeof(first));
        memset(sz,0,sizeof(sz));
        memset(row,0,sizeof(row));
        memset(col,0,sizeof(col));
        memset(s,0,sizeof(s));
        n = r,m = c;
        for(int i=0;i<=m;i++){
            L[i] = i-1,R[i] = i+1;
            U[i] = i,D[i] = i;
        }
        L[0] = c;
        R[c] = 0;
        id = c+1;
    }
    void remove(int x){
        R[L[x]] = R[x];
        L[R[x]] = L[x];
        for(int i=D[x];i!=x;i=D[i]){
            for(int j=R[i];j!=i;j=R[j]){
                sz[col[j]]--;
                U[D[j]] = U[j];
                D[U[j]] = D[j];
            }
        }
    }
    void recover(int x){
        for(int i=U[x];i!=x;i=U[i]){
            for(int j=L[i];j!=i;j=L[j]){
                D[U[j]] = U[D[j]] = j;
                sz[col[j]]++;
            }
        }
        R[L[x]] = L[R[x]] = x;
    }
    void insert(int r,int c){
        id++;
        row[id] = r,col[id] = c;
        sz[c]++;
        U[id] = c;
        D[id] = D[c];
        D[c] = U[D[c]] = id;
        if(!first[r]){
            first[r] = L[id] = R[id] = id;
        }
        else{
            L[id] = first[r];
            R[id] = R[first[r]];
            R[first[r]] = L[R[first[r]]] = id;
        }
    }
    bool dance(int x){
        if(!R[0]){
            for(int i=1;i<x;i++){
                a[(s[i]-1)/256+1][(s[i]-1)/16%16+1] = (s[i]-1)%16+1;
            }
            return 1;
        }
        int y = R[0];
        for(int i=R[0];i;i=R[i]){
            if(sz[i]<sz[y]){
                y = i;
            }
        }
        remove(y);
        for(int i=D[y];i!=y;i=D[i]){
            s[x] = row[i];
            for(int j=R[i];j!=i;j=R[j]){
                remove(col[j]);
            }
            if(dance(x+1)){
                return 1;
            }
            for(int j=L[i];j!=i;j=L[j]){
                recover(col[j]);
            }
        }
        recover(y);
        return 0;
    }
}DancingLinks;
void work(int x,int y,int z){
    int idx = (x-1)*256+(y-1)*16+z;
    DancingLinks.insert(idx,(x-1)*16+z);
    DancingLinks.insert(idx,(y-1)*16+z+256);
    DancingLinks.insert(idx,((x-1)/4*4+(y-1)/4)*16+z+512);
    DancingLinks.insert(idx,(x-1)*16+y+768);
}
int main(){
    string s;
    int cnt = 0;
    while(cin >> s){
        cnt++;
        if(cnt>1){
            cout << endl;
        }
        DancingLinks.build(4096,1024);
        for(int i=1;i<=16;i++){
            if(i!=1){
                cin >> s;
            }
            for(int j=1;j<=16;j++){
                char c = s[j-1];
                if(c!='-'){
                    a[i][j] = c-'A'+1;
                    work(i,j,a[i][j]);
                }
                else{
                    for(int k=1;k<=16;k++){
                        work(i,j,k);
                    }
                }
            }
        }
        DancingLinks.dance(1);
        for(int i=1;i<=16;i++){
            for(int j=1;j<=16;j++){
                cout << (char)(a[i][j]+'A'-1);
            }
            cout << endl;
        }
    }
    return 0;
}
```

# 思路

DLX。

此题建模与普通数独没有任何不同，在统计答案时使用一个权值数组更新即可。

具体见代码。改动部分仅有开头的变量定义、dance 函数、输入输出。
# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int ans = -1;
int a[15][15];
int sc[10][10] = {
    {6,6,6,6,6,6,6,6,6},
    {6,7,7,7,7,7,7,7,6},
    {6,7,8,8,8,8,8,7,6},
    {6,7,8,9,9,9,8,7,6},
    {6,7,8,9,10,9,8,7,6},
    {6,7,8,9,9,9,8,7,6},
    {6,7,8,8,8,8,8,7,6},
    {6,7,7,7,7,7,7,7,6},
    {6,6,6,6,6,6,6,6,6}
};
struct DLX{
    int n,m,id;
    int L[10005],R[10005],U[10005],D[10005],first[10005],sz[10005],row[10005],col[10005],s[10005];
    void build(int r,int c){
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(U,0,sizeof(U));
        memset(R,0,sizeof(R));
        memset(first,0,sizeof(first));
        memset(sz,0,sizeof(sz));
        memset(row,0,sizeof(row));
        memset(col,0,sizeof(col));
        memset(s,0,sizeof(s));
        n = r,m = c;
        for(int i=0;i<=m;i++){
            L[i] = i-1,R[i] = i+1;
            U[i] = i,D[i] = i;
        }
        L[0] = c;
        R[c] = 0;
        id = c+1;
    }
    void remove(int x){
        R[L[x]] = R[x];
        L[R[x]] = L[x];
        for(int i=D[x];i!=x;i=D[i]){
            for(int j=R[i];j!=i;j=R[j]){
                sz[col[j]]--;
                U[D[j]] = U[j];
                D[U[j]] = D[j];
            }
        }
    }
    void recover(int x){
        for(int i=U[x];i!=x;i=U[i]){
            for(int j=L[i];j!=i;j=L[j]){
                D[U[j]] = U[D[j]] = j;
                sz[col[j]]++;
            }
        }
        R[L[x]] = L[R[x]] = x;
    }
    void insert(int r,int c){
        id++;
        row[id] = r,col[id] = c;
        sz[c]++;
        U[id] = c;
        D[id] = D[c];
        D[c] = U[D[c]] = id;
        if(!first[r]){
            first[r] = L[id] = R[id] = id;
        }
        else{
            L[id] = first[r];
            R[id] = R[first[r]];
            R[first[r]] = L[R[first[r]]] = id;
        }
    }
    void dance(int x){
        if(!R[0]){
            int sum = 0;
            for(int i=1;i<x;i++){
                sum+=sc[(s[i]-1)/81][(s[i]-1)/9%9]*((s[i]-1)%9+1);
            }
            ans = max(ans,sum);
            return;
        }
        int y = R[0];
        for(int i=R[0];i;i=R[i]){
            if(sz[i]<sz[y]){
                y = i;
            }
        }
        remove(y);
        for(int i=D[y];i!=y;i=D[i]){
            s[x] = row[i];
            for(int j=R[i];j!=i;j=R[j]){
                remove(col[j]);
            }
            dance(x+1);
            for(int j=L[i];j!=i;j=L[j]){
                recover(col[j]);
            }
        }
        recover(y);
    }
}DancingLinks;
void work(int x,int y,int z){
    int idx = (x-1)*81+(y-1)*9+z;
    DancingLinks.insert(idx,(x-1)*9+z);
    DancingLinks.insert(idx,(y-1)*9+z+81);
    DancingLinks.insert(idx,((x-1)/3*3+(y-1)/3)*9+z+162);
    DancingLinks.insert(idx,(x-1)*9+y+243);
}
int main(){
    DancingLinks.build(729,324);
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++){
            cin >> a[i][j];
            if(a[i][j]){
                work(i,j,a[i][j]);
            }
            else{
                for(int k=1;k<=9;k++){
                    work(i,j,k);
                }
            }
        }
    }
    DancingLinks.dance(1);
    cout << ans;
    return 0;
}

```

---

## 作者：Prean (赞：7)

众所周知，优化无极限。

我做这题的时候不会，就套用数独的方法，然搜到终点的时候再计算分数
```cpp
int num=0;
for(i=1;i<=9;++i)for(j=1;j<=9;++j)
if(i==1||j==1||i==9||j==9)num+=6*a[i][j];
else if(i==2||j==2||i==8||j==8)num+=7*a[i][j];
else if(i==3||j==3||i==7||j==7)num+=8*a[i][j];
else if(i==4||j==4||i==6||j==6)num+=9*a[i][j];
else num+=10*a[i][j];ans=max(ans,num);return;
```

于是每个点分数就可以这么计算。

我提交了，70分，第一个点还是WA。

？？？？？？我其他点都是AC或者TLE，怎么这里是WA？

然后我下载了第一个数据，将数据输入，输出的是0，然后数据的输出是-1。

于是我重新读了题：

# 输出格式

输出共 11 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1。

然后我将ans的初始化定为-1。

可是其他5个TLE的点呢？然后我想了想，如果一行剩得越多，填这一行所需要的时间越长~~废话！~~，但是假如其他行都填完了，这一行需要的时间也就很短了

于是我将需要填的点排了个序：
```cpp
int a[10][10],ans=-1,top,t[10];
bool cmp(mp a,mp b)
{
	if(a.x==b.x)return a.y<b.y;
	return t[a.x]<t[b.x];
}
int main()
{
	int i,j;char s;
	for(i=1;i<=9;++i)for(j=1;j<=9;++j)
	{cin>>a[i][j];if(!a[i][j])m[++top]={i,j},++t[i];}
	sort(m+1,m+top+1,cmp);DFS(1);cout<<ans;
}
```
提交，还是TLE了一个点。于是我仿抄快读的方法，在cmp和DFS的类型前面都加了一个“inline”。

过了，然后我拿去我们学校的OJ上面提交，95分，有一个点TLE。

这就应证开头的“优化无极限”了。

稍加思索后，我将cmp改了一下：
```cpp
inline bool cmp(mp a,mp b){return a.x==b.x?a.y<b.y:t[a.x]<t[b.x];}
```
但是测评姬太棒了，还是TLE一个点。

所以我为了再节省一点时间，修改了主函数：
```
int main()
{
	int i,j;ios::sync_with_stdio(false);
	for(i=1;i<=9;++i)for(j=1;j<=9;++j)
	{cin>>a[i][j];if(!a[i][j])m[++top]={i,j},++t[i];}
	sort(m+1,m+top+1,cmp);DFS(1);cout<<ans;
}
```
ios::sync_with_stdio(false);的意思是：C++为了兼容C，cin和cout的时间十分缓慢，加了这一行之后，关闭了cin和scafn，cout和printf的同步，使输入输出更快

也将计算分数的部分改得无比丑陋：
```cpp
int num=0;
for(i=1;i<=9;++i)for(j=1;j<=9;++j)
i==1||j==1||i==9||j==9?num+=6*a[i][j]:i==2||j==2||i==8||j==8?num+=7*a[i][j]:i==3||j==3||i==7||j==7?num+=8*a[i][j]:i==4||j==4||i==6||j==6?num+=9*a[i][j]:num+=10*a[i][j];
ans=max(ans,num);return;
```
使用三目运算符加快速度，但代码也变得丑陋

然而还是TLE。。。

于是我又找了一个需要比较的地方使用三目运算符加速：
```cpp
m[f].x%3?ix=m[f].x/3*3+1:ix=m[f].x-2;mx=ix+2;
m[f].y%3?iy=m[f].y/3*3+1:iy=m[f].y-2;my=iy+2;
```
这段代码就是为了计算这个点在哪个九宫格


但是好像还是没有if快

于是我再次修改了主函数：
```
int main()
{
	int i,j;ios::sync_with_stdio(false);
	for(i=1;i<=9;++i)for(j=1;j<=9;++j)
	{cin>>a[i][j];!a[i][j]?m[++top]={i,j},++t[i]:0;}
	sort(m+1,m+top+1,cmp);DFS(1);cout<<ans;
}
```
然后发现再次提交到洛谷上时，只有95分了，有一个点TLE了

所以呢，我又去修改了代码

我才发现，判断九宫格的那里其实可以不用三目运算符，可以这样：
```cpp
ix=(--m[f].x)/3*3+1;mx=ix+2;++m[f].x;
iy=(--m[f].y)/3*3+1;my=iy+2;++m[f].y;
```
这样也给我节省了很多时间，还有就是，行和列的遍历，其实可以用一个for循环去遍历，省了将近100ms的时间
```cpp
for(i=1;i<=9;++i)flag[a[m[f].x][i]]=0,flag[a[i][m[f].y]]=0;
```
然而第九个点还是TLE。。。。。。

测评姬你出来一下，是不是你昨天晚上睡得太晚，导致今天测速度慢了？

然后我发现bool数组我用的是“1”和“0”，比“true”和“false”慢多了。于是又改。最开始有两个点TLE，现在第一个点已经从1000ms降到792ms了，而另外一个点还是1000ms多

然后我把从洛谷上下载下来的那个数据，改了一下代码，把ans=max(ans,num)改成了ans+=num，发现居然输出了133235813。。。。。。

没办法，就这样吧。。。。。。

完结撒代码
```cpp
#pragma GCC optimize(3,"Ofast","inline")
#pragma GCC optimize(2)
#include<algorithm>
#include<iostream>
using namespace std;
class p{public:int x,y;}m[85];
int a[10][10],ans=-1,top,t[10];
inline bool cmp(p a,p b){return a.x==b.x?a.y<b.y:t[a.x]<t[b.x];}
inline void DFS(int f)
{
	int i,j,ix,mx,iy,my;
	bool flag[10]={false};
	if(f==top+1)
	{
		int num=0;
		for(i=1;i<=9;++i)for(j=1;j<=9;++j)
		if(i==1||j==1||i==9||j==9)num+=6*a[i][j];
		else if(i==2||j==2||i==8||j==8)num+=7*a[i][j];
		else if(i==3||j==3||i==7||j==7)num+=8*a[i][j];
		else if(i==4||j==4||i==6||j==6)num+=9*a[i][j];
		else num+=10*a[i][j];num>ans?ans=num:ans;return;
	}ix=(--m[f].x)/3*3+1;mx=ix+2;++m[f].x;
	iy=(--m[f].y)/3*3+1;my=iy+2;++m[f].y;
	for(i=1;i<=9;++i)
	flag[a[m[f].x][i]]=true,flag[a[i][m[f].y]]=true;
	for(i=ix;i<=mx;++i)for(j=iy;j<=my;++j)flag[a[i][j]]=true;
	for(i=1;i<=9;++i)if(!flag[i])
	{a[m[f].x][m[f].y]=i;DFS(f+1);}a[m[f].x][m[f].y]=0;
}
int main()
{
	int i,j;ios::sync_with_stdio(false);
	for(i=1;i<=9;++i)for(j=1;j<=9;++j)
	{cin>>a[i][j];!a[i][j]?m[++top]={i,j},++t[i]:0;}
	sort(m+1,m+top+1,cmp);DFS(1);cout<<ans;
}
```


---

## 作者：ridewind2013 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1074)

## 思路
一道搜索题，建议降绿，如果写一个朴素暴力的话，你就会得到 TLE 的拥抱，所以必须要进行优化。

朴素暴力部分我就不用讲了，很简单，用三个数组标记每行，每列，每宫可以填什么，最后计算得分即可，我重点讲一下优化。

+ 优化 $1$：位运算优化，每次搜索都需要从 $1$ 到 $9$ 挨个看，时间复杂度很高，我们可以用一个数来表示它的状态，$1$ 表示可以填，$0$ 表示不可以填（和状态压缩有异曲同工之妙），给三个标记每行，每列，每宫的数组预处理，表示状态的数就是这三个数组按位与的结果，我们可以用 [lowbit](https://blog.csdn.net/qq_62664678/article/details/125056583) 来判断哪个位置上是 $1$，如果 lowbit 的结果是 $2_{}^{k}$，那么这里要填的数就是 $k$，所以我们可以用 $p$ 数组预处理一下。

+ 优化 $2$：每次寻找可能性最小的位置，从那个位置进行搜索，可以预处理 $o$ 数组，$o_{i}$ 表示 $i$ 的二进制中 $1$ 的个数，每个位置有几个 $1$，就有几种可能性。

用了这两个优化，时间复杂度会减小很多。

接下来要计算得分，通过找规律，我们发现第 $i$ 行第 $j$ 列的得分就是 $a_{i,j} \times (6 + \min(\min(i,8-i),\min(j,8-j)))$。

最后求出最大得分，输出即可。

## AC Code

```cpp

#include<bits/stdc++.h>
using namespace std;
int a[10][10],r[10],c[10],e[5][5],p[1<<11],ans=-1;
int o[1<<10];
int gs(int i,int j){//计算得分
	return a[i][j]*(6+min(min(i,8-i),min(j,8-j)));
}
void init(){//初始化
	for(int i=0;i<9;i++)r[i]=c[i]=e[i/3][i%3]=(1<<9)-1;
	for(int i=0;i<(1<<9);i++){
		int t=i;
		while(t){
			t&=t-1;
			o[i]++;
		}
	}
	for(int i=0;i<9;i++)p[1<<i]=i+1;
}
void dfs(int cnt,int sum){//搜索
	if(cnt==0){
		ans=max(ans,sum);
	}
	int mi=10,x,y;
	for(int i=0;i<9;i++){//求出可能性最小的位置
		for(int j=0;j<9;j++){
			if(!a[i][j]){
				int t=r[i]&c[j]&e[i/3][j/3];
				if(o[t]<mi){
					mi=o[t],x=i,y=j;
				}
			}
		}
	}
	int t=r[x]&c[y]&e[x/3][y/3];
	while(t){//位运算优化
		int l=(t&-t);
		t-=l;
		a[x][y]=p[l];
		r[x]-=l,c[y]-=l,e[x/3][y/3]-=l;
		dfs(cnt-1,sum+gs(x,y));
		a[x][y]=0;
		r[x]+=l,c[y]+=l,e[x/3][y/3]+=l;
	}
}
int main(){
	init();
	int cnt=0,sum=0;
	for(int i=0;i<9;i++){
		for(int j=0;j<9;j++){
			cin>>a[i][j];
			if(a[i][j]){
				r[i]-=1<<a[i][j]-1;
				c[j]-=1<<a[i][j]-1;
				e[i/3][j/3]-=1<<a[i][j]-1;
				sum+=gs(i,j);
			}else cnt++;
		}
	}
	dfs(cnt,sum);
	cout<<ans;//输出答案
	return 0;
}

```

---

## 作者：Hope2075 (赞：6)

下面基本都是dfs的

有个用启发式搜索的，但似乎又不是

这里用启发式搜索(A*算法)

每次取出估价最好的局面，生成所有局面，再放回堆里

首先确定估价函数

一个办法是每个格子填最大可能的数

另一个是每个九宫格内最大化结果

用一个堆，每次取估价最高的局面

每个局面要记录每个区域能填的数，这里用了位运算

不需要回溯，因而局面是一次性的

只要不可能有更优解就结束

按第一个估价函数得了70分

第二个得了80分

再考虑优化

当某个局面中有格子不能填时可以直接扔掉

只能填某个数时可以填上

也可以考虑玄学填法……不过太麻烦，作用不太明显

再打一些简单的表，也可以卡常（我没弄卡常）

这样优化就能得100分了（无氧）

不知道空数独会用多长时间

注意0特判输出

2296ms 31226KB

不快，也不算慢

理论上内存开销会偏大

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define short int
//先打表
const short tester[10]={0,1,2,4,8,16,32,64,128,256};
const int score[10][10]={
{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6}};

using namespace std;
struct sd{//数独结构
    int list[10][10]={{0}};
    int maxput[10][10]={{0}};
    int rowcan[10]={0},linecan[10]={0},areacan[10]={0};
    int maxrecv=0,nowrecv=0;
    int remain=81;
    int surex,surey;
    int bests;
};

int getsuretab[1024];//根据某数值得到确定度
int maxnum[1024];//可填的最大数值
inline int filltab(){//现算，想打表？1024个数呢
    int cnt,tmp,maxn;
    for(int i=0;i<1024;i++){
        cnt=0;
        tmp=i;
        maxn=0;
        for(int j=1;j<10;j++){
            if(tmp&1)
                cnt++;
            else
                maxn=j;
            
            tmp>>=1;
        }
        getsuretab[i]=cnt;
        maxnum[i]=maxn;
    }
}

inline int getarea(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}

bool operator<(sd a,sd b){
    return a.maxrecv==b.maxrecv?a.nowrecv<b.nowrecv:a.maxrecv<b.maxrecv;
}

sd tmp,tmp2;
priority_queue<sd> q;//每次取最优值

int surex,surey;




int suretmp;int bestsure;
int suretmp2;int bestsure2;
int getsure(sd &a){
    bestsure=0;//找最确定的点 
    bestsure2=0;
    for(int x=1;x<=9;x++){
       for(int y=1;y<=9;y++){
            if(tmp.list[x][y]) continue;
            suretmp=a.linecan[x]|a.rowcan[y]|a.areacan[getarea(x,y)];
            suretmp2=getsuretab[suretmp];
            if(suretmp2>=bestsure2 && a.list[x][y]==0){
                bestsure=suretmp;
                bestsure2=suretmp2;
                a.surex=x;a.surey=y;
            }
        }
    }
    a.bests=bestsure;
}


int best,sum;
inline int renew(sd a){//填完后计算结果
    sum=0;
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++){
            sum+=tmp.list[i][j]*score[i][j];
        }
    }
    best=max(best,sum);
}

int has[10];
int allow[11];
inline int gj(sd &a){//估价函数
    a.maxrecv=a.nowrecv;
    for(int i=0;i<9;i++){
        for(int m=0;m<10;m++){
            has[m]=0;
        }
    	for(int m=0;m<11;m++){
    	    allow[m]=0;
    	}
        allow[5]=1;
        //memset
        for(int j=0;j<3;j++){
            for(int k=0;k<3;k++){
                int x=i%3*3+1+j;
                int y=i/3*3+1+k;
                int now=tmp2.list[x][y];
                has[now]=1;
                if(!now) allow[score[x][y]]++;
            }
        }
        int m=9,n=10;
        while(m){
            if(!allow[n]){
                n--;
                continue;
            }
            if(has[m]){
                m--;
            	continue;
            }
            allow[n]--;
            has[m]++;
            a.maxrecv+=m*n;
            m--;
        }
    }
}
inline int setnum(sd &a,int posx,int posy,int num){//设置数独的某个格子
    a.remain--;//附加信息也需要更新
    a.list[posx][posy]=num;
    a.nowrecv+=num*score[posx][posy];
    a.maxrecv=0;
    a.linecan[posx]|=tester[num];
    a.rowcan[posy]|=tester[num];
    a.areacan[getarea(posx,posy)]|=tester[num];
}
int fillmust(sd &a){//填充确定无疑的格子
    getsure(a);
    while(getsuretab[a.bests]>=8){
        
        if(getsuretab[a.bests]==9) return 0;
        setnum(a,a.surex,a.surey,maxnum[a.bests]);
        getsure(a);
        
    }
    return 1;
}

int posx,posy;
inline int a_(){//A*算法
    while(!q.empty()){
        tmp=q.top();
        q.pop();
        if(tmp.maxrecv<=best){return best;} //确定不会有更优解 
        if(tmp.remain==0){//已填完 
            renew(tmp); 
            continue;
        }
        posx=tmp.surex;posy=tmp.surey;
        for(int i=1;i<=9;i++){//生成所有情况 
            if(tester[i]&tmp.bests) {
            	continue;
            }
            tmp2=tmp;
            setnum(tmp2,posx,posy,i);
            if(!fillmust(tmp2))continue;
            gj(tmp2);
            if(tmp2.maxrecv<best) continue;
            q.push(tmp2);
        }
    }
}
int a;
int nnn,nnnn;
int main(){
    ios::sync_with_stdio(false);
    filltab();
    tmp2.remain=81;
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++){
            cin>>a;
            if(a)setnum(tmp2,i,j,a);
        }
    }
    fillmust(tmp2);
    gj(tmp2);
    getsure(tmp2);
    
    q.push(tmp2);
    a_();
    if(best == 0) cout<<-1;
    else 
    cout<<best;
}
```

---

## 作者：lx_zjk (赞：5)

这里提供一种不用$dancing$ $links$的方法，~~好吧其实我不会舞蹈链~~

这道题其实是八皇后的进阶版本 如果没做过数独的话 可以先去尝试下那道题，这道题其实就是数独的进阶版本，就是需要填数独的复杂度减小，并且要$calc()$出一个值，
使这个值最大

用位运算的话会比普通的数组存行列更优

在这道题目中，我们秉承一个原则，那就是让搜索树的分叉尽量少，也就是让最先填上的数的备选方案数尽可能小，但如果备选方案为0，那么立$return$，加速程序

用 $row$ $col$ $cell$三个数组分别存下当前行列格子的备选方案数

当处理到$(x,y)$ 时，其备选方案即为$row[x]$ $&$ $col[y]$ $&$ $cell[x/3][y/3]$

有了大体的框架，那么代码实现就不是问题了

不开$O(2)$ $1.47s$

# code
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <ctime>
 
using namespace std;

typedef long long ll;

inline ll read() {
	ll f=1,x=0;char ch;
	do {ch=getchar();if(ch=='-')f=-1;} while(ch>'9'||ch<'0');
	do {x=x*10+ch-'0';ch=getchar();} while(ch>='0'&&ch<='9');
	return f*x;
}

const int N = 9; 

int a[N][N], row[N], col[N], cell[N / 3][N / 3], ans = 0;
int map[1 << N], ones[1 << N];

inline int lowbit (int x){
	return x & -x; 
}

inline int get (int x, int y){
	return row[x] & col[y] & cell[x / 3][y / 3];
}

inline int max (int a, ll b){
	return a > b ? a : b;
}

const int mark[N][N]=
{{6,6,6,6,6,6,6,6,6},
{6,7,7,7,7,7,7,7,6},
{6,7,8,8,8,8,8,7,6},
{6,7,8,9,9,9,8,7,6},
{6,7,8,9,10,9,8,7,6},
{6,7,8,9,9,9,8,7,6},
{6,7,8,8,8,8,8,7,6},
{6,7,7,7,7,7,7,7,6},
{6,6,6,6,6,6,6,6,6}};

inline void draw (int x, int y, int t){
	row[x] ^= (1 << t);
	col[y] ^= (1 << t);
	cell[x / 3][y / 3] ^= (1 << t);
}

inline int calc (){
	int ans = 0; 
	for(int i = 0; i < N; i ++ )
		for(int j = 0; j < N; j ++ )
			ans += a[i][j] * mark[i][j];
	return ans;
}

// 每个空格，如果不能填则返回false；如果只有一个选项，则直接填上

bool dfs (int cnt, ll sum)
{
	if (!cnt) {
		ans = max(ans ,sum);
		return true;
	}
	int s = 10, sx, sy;
	for(int i = 0; i < N; i ++ )
		for(int j = 0; j < N; j ++ )
		{
			if (a[i][j] != -1) continue;
			int t = get(i,j);
			if (!t) return false;
			if (ones[t] < s)
			{
				s = ones[t];
				sx = i,sy = j;
			}				
		}
		
	bool flag = false;
	for(int i = get(sx, sy); i; i -= lowbit(i))
	{
		int t = map[lowbit(i)];
		a[sx][sy] = t + 1;
		draw (sx, sy, t);
		if(dfs (cnt - 1,sum + mark[sx][sy] * (t + 1))) flag = true;
		a[sx][sy] = -1;
		draw (sx, sy, t);
	}
	if (flag == true) return true;
	return false;
}

int main() {
	for(int i = 0; i < N; i ++ )map[1 << i] = i;
	for(int i = 0; i < (1<<N); i ++ )
		for(int j = i; j; j -= lowbit(j))ones[i] ++;
	int cnt = 0 ;
	ll sum_1 = 0;
	for(int i = 0; i < N; i ++ )row[i] = (1 << N) - 1;
	for(int j = 0; j < N; j ++ )col[j] = (1 << N) - 1;
	for(int i = 0; i < (N / 3); i ++ )
		for(int j = 0; j < (N / 3); j ++ )
			cell[i][j] = (1 << N) - 1; 
	for(int i = 0; i < N; i ++ )
		for(int j = 0; j < N; j ++ )
		{
			a[i][j] = read();
			sum_1 += a[i][j] * mark[i][j];
			if(a[i][j]) draw(i, j, a[i][j] - 1);
		    else cnt ++, a[i][j] = -1;
		}
	if(dfs (cnt, sum_1)) printf ("%lld\n", ans);
	else puts ("-1");
	return 0;
}
```

---

## 作者：DiaoHantong (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P1074)

## 思路

本题要求出数独的所有解法，在所有解中找最大值，所以搜索量巨大。显然的优化思路是优先选择限制条件多的位置填写。比如某行已经填了 $7$ 个数，那么还剩 $2$ 个格子，只有 $2$ 种情况。可以把搜索过程想象成一棵树，根节点是起点，这样做可以使刚开始的分叉少，之后的分叉多，一旦发生剪枝，减去的节点就更多，剪枝的效果就更加显著。这个剪枝原则适用于所有数独问题，虽然看起来代码里浪费了时间去找已填数最多的行和列，但实际上浪费的时间相比剪枝节省的时间，微不足道。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int score[10][10]=
{{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6}};
int row[10][10],col[10][10],grid[10][10],a[10][10];
int row_cnt[10],col_cnt[10],cnt,ans=-1;
int tran(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}
int calc(){
    int tmp=0;
    for(int i=1;i<=9;i++)
        for(int j=1;j<=9;j++)
            tmp+=score[i][j]*a[i][j];
    return tmp;
}
void dfs(int x,int y,int tot){
    if(tot==81){
        ans=max(ans,calc());
        return;
    }
    for(int i=1;i<=9;i++){
        if(row[x][i]||col[y][i]||grid[tran(x,y)][i])continue;
        row[x][i]=col[y][i]=grid[tran(x,y)][i]=true;
        row_cnt[x]++,col_cnt[y]++;
        a[x][y]=i;
        int tmpr=-1,nxt_x=0,tmpc=-1,nxt_y=0;
        for(int j=1;j<=9;j++)
            if(row_cnt[j]>tmpr&&row_cnt[j]<9)
                tmpr=row_cnt[j],nxt_x=j;
        for(int j=1;j<=9;j++)
            if(col_cnt[j]>tmpc&&!(a[nxt_x][j]))
                tmpc=col_cnt[j],nxt_y=j;
        dfs(nxt_x,nxt_y,tot+1);
        row[x][i]=col[y][i]=grid[tran(x,y)][i]=false;
        row_cnt[x]--,col_cnt[y]--;
        a[x][y]=0;
    }
}
int main(){
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++){
            cin>>a[i][j];
            if(a[i][j]!=0){
                row[i][a[i][j]]=true;
                col[j][a[i][j]]=true;
                grid[tran(i,j)][a[i][j]]=true;
                row_cnt[i]++,col_cnt[j]++;
                cnt++;//已经填了的数量
            }
        }
    }
    int tmpr=-1,x,tmpc=-1,y;
    for(int j=1;j<=9;j++)
        if(row_cnt[j]>tmpr&&row_cnt[j]<9)
            tmpr=row_cnt[j],x=j;//选已填数最多的行x出发
    for(int j=1;j<=9;j++)
        if(col_cnt[j]>tmpc&&(!a[x][j]))
            tmpc=col_cnt[j],y=j;//选行x里填数最多的列y出发
    dfs(x,y,cnt);
    cout<<ans;
    return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

一个搜索题。

先明确暴力搜索过程：选择一个空格，枚举这个空格填的数，检查这个格子是否与所在行、列、个九宫格的数字重复，若合法则进入下一层。当空格全部填完，计算分数并更新答案。

对于检查这一步，可以设 $h_{i, j}$ 表示第 $i$ 行是否有数字 $j$，设 $l_{i, j}$ 表示第 $i$ 列是否有数字 $j$，设 $g_{i, j}$ 表示第 $i$ 个九宫格是否有数字 $j$，这样就可以 $\mathcal O(1)$ 检查了。

考虑优化枚举顺序，对于有 $2$ 种可能的空格和有 $4$ 种可能的空格，我们一定选择 $2$ 种可能的先填，因为这样产生的状态数更少，而这也符合我们人脑做数独时的特点。

这样就得到了一个剪枝，从可能最少的空格开始填，这足以通过本题。

实现时可以预处理每个格子的分数和所属九宫格号码，对于枚举顺序的优化，可以按每行空格子数从少到多的顺序填，搜索前按顺序处理出每个空格所在的行、列、九宫格及分数，答案初值为 $-1$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int id[9][9]={
	{ 0, 0, 0, 1, 1, 1, 2, 2, 2 },
	{ 0, 0, 0, 1, 1, 1, 2, 2, 2 },
	{ 0, 0, 0, 1, 1, 1, 2, 2, 2 },
	{ 3, 3, 3, 4, 4, 4, 5, 5, 5 },
	{ 3, 3, 3, 4, 4, 4, 5, 5, 5 },
	{ 3, 3, 3, 4, 4, 4, 5, 5, 5 },
	{ 6, 6, 6, 7, 7, 7, 8, 8, 8 },
	{ 6, 6, 6, 7, 7, 7, 8, 8, 8 },
	{ 6, 6, 6, 7, 7, 7, 8, 8, 8 }
}, score[10][10]={
	{ 6, 6, 6, 6, 6, 6, 6, 6, 6 },
	{ 6, 7, 7, 7, 7, 7, 7, 7, 6 },
	{ 6, 7, 8, 8, 8, 8, 8, 7, 6 },
	{ 6, 7, 8, 9, 9, 9, 8, 7, 6 },
	{ 6, 7, 8, 9, 10, 9, 8, 7, 6 },
	{ 6, 7, 8, 9, 9, 9, 8, 7, 6 },
	{ 6, 7, 8, 8, 8, 8, 8, 7, 6 },
	{ 6, 7, 7, 7, 7, 7, 7, 7, 6 },
	{ 6, 6, 6, 6, 6, 6, 6, 6, 6 }
}, sum, u, mx=-1, a[10][10], s[100][4];
bool h[9][10], l[9][10], g[9][10];
pair<int, int> cnt[9];
void dfs(int x, int now){
	if(x==u){
		mx=max(mx, now);
		return;
	}
	for(int i=1; i<=9; i++)
		if(!h[s[x][0]][i]&&!l[s[x][1]][i]&&!g[s[x][2]][i])
			h[s[x][0]][i]=l[s[x][1]][i]=g[s[x][2]][i]=1,
			dfs(x+1, now+s[x][3]*i),
			h[s[x][0]][i]=l[s[x][1]][i]=g[s[x][2]][i]=0;
}
int main(){
	for (int i=0; i<9; ++i)
		cnt[i]={0, i}; 
	for (int i=0; i<9; ++i)
		for (int j=0; j<9; ++j) 
			cin >> a[i][j],
			g[id[i][j]][a[i][j]]=h[i][a[i][j]]=l[j][a[i][j]]=1,
			sum+=score[i][j]*a[i][j],
			cnt[i].first+=(!a[i][j]);
	sort(cnt, cnt+9);
	for (int i=0; i<9; ++i)
		for (int j=0; j<9; ++j)
			if (!a[cnt[i].second][j])
				s[u][0]=cnt[i].second, 
				s[u][1]=j,
				s[u][2]=id[cnt[i].second][j],
				s[u++][3]=score[cnt[i].second][j];
	dfs(0, sum);
	cout << mx;
	return 0;
}
```

---

## 作者：ZHR100102 (赞：3)

# 普通数独

## 思路

显然是对每个格子进行枚举，类似八皇后的方法去做，朴素方法是由 $(1,1)$ 到 $(9,9)$ 遍历过去。

## 优化

我们在做数独时，会优先选择已填格数多的行、列、区域，这样可以保证尝试次数少。


同样，这一点在本题中也可以应用，但是有两种思路。

1. 按照行里没填的格子的个数进行从小到大排序。
2. 根据单个格子可能会出现的数字的数量进行从小到大排序。

目的只有一个：减少搜索树的大小。

这里采用第二种方法，则计算这个格子可能的数字，就是竖向的数字、横向的数字、区域的数字以外的数字。

因此，我们将这三种数字开个 bitset，然后分别或一下，设结果为 $ans$，如果 $ans=0$，则证明可以填这个数。bitset 可以用状压的方式优化，大幅减少常数。~~但我写的位运算版还没 bitset 版跑得快。~~

然后还要注意，如果搜到结果，直接结束程序就好。

注意把 sort 改成 stable\_sort，因为尽可能要连续填。

于是就把数独过了。

## 代码

### bitset 版

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[15][15];
bitset<15>xvis[15],yvis[15],svis[15];
int s(int x,int y)
{
	return ((x-1)/3*3+(y+2)/3);
}
int cg(int x,int y)
{
	bitset<15>ans;
	int res=0;
	ans=xvis[x]|yvis[y]|svis[s(x,y)];
	for(int i=1;i<=9;i++)if(ans[i]==0)res++;
	return res;
}
struct tile{
	int x,y,g;
};
vector<tile>vct;
bool cmp(tile a,tile b)
{
	return a.g<b.g;
}
void outp()
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}
}
void dfs(int now)
{
	if(now>=vct.size())
	{
		outp();
		exit(0);
	}
	int x=vct[now].x,y=vct[now].y;
	bitset<15>ans;
	ans=xvis[x]|yvis[y]|svis[s(x,y)];
	for(int i=1;i<=9;i++)
	{
		if(ans[i]==0)
		{
			svis[s(x,y)][i]=1;
			xvis[x][i]=1;
			yvis[y][i]=1;		
			a[x][y]=i;
			dfs(now+1);
			svis[s(x,y)][i]=0;
			xvis[x][i]=0;
			yvis[y][i]=0;		
			a[x][y]=0;			
		}
	}
}
int main()
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cin>>a[i][j];
			if(a[i][j]!=0)
			{
				svis[s(i,j)][a[i][j]]=1;
				xvis[i][a[i][j]]=1;
				yvis[j][a[i][j]]=1;	
			}
		}
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j]!=0)continue;
			tile tmp;
			tmp.x=i,tmp.y=j;
			tmp.g=cg(i,j);
			if(tmp.g!=0)vct.push_back(tmp);
		}
	}
	stable_sort(vct.begin(),vct.end(),cmp);
	dfs(0);
	return 0;
}
```

### 位运算版

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[15][15];
int xvis[15],yvis[15],svis[15];
int s(int x,int y)
{
	return ((x-1)/3*3+(y+2)/3);
}
int cg(int x,int y)
{
	int ans;
	int res=0;
	ans=xvis[x]|yvis[y]|svis[s(x,y)];
	for(int i=1;i<=9;i++)if(ans>>i==0)res++;
	return res;
}
struct tile{
	int x,y,g;
};
vector<tile>vct;
bool cmp(tile a,tile b)
{
	return a.g<b.g;
}
void outp()
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}
}
void dfs(int now)
{
	if(now>=vct.size())
	{
		outp();
		exit(0);
	}
	int x=vct[now].x,y=vct[now].y;
	int tmps=s(x,y);
	int ans=xvis[x]|yvis[y]|svis[tmps];
	for(int i=1;i<=9;i++)
	{
		if(((ans>>i)&1)==0)
		{
			xvis[x]|=(1<<i);
			yvis[y]|=(1<<i);
			svis[tmps]|=(1<<i);		
			a[x][y]=i;
			dfs(now+1);
			xvis[x]=(xvis[x]^(1<<i));
			yvis[y]=(yvis[y]^(1<<i));		
			svis[tmps]=(svis[tmps]^(1<<i));	
			a[x][y]=0;	
		}
	}
}
int main()
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cin>>a[i][j];
			if(a[i][j]!=0)
			{
				svis[s(i,j)]|=1<<a[i][j];
				xvis[i]|=1<<a[i][j];
				yvis[j]|=1<<a[i][j];	
			}
		}
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j]!=0)continue;
			tile tmp;
			tmp.x=i,tmp.y=j;
			tmp.g=cg(i,j);
			vct.push_back(tmp);
		}
	}
	stable_sort(vct.begin(),vct.end(),cmp);
	dfs(0);
	return 0;
}
```

# 靶形数独：增加权重的数独

## 思路

大致与普通数独相同，讲几个重要剪枝：

1. 增加估价函数 $g(x,y,z)$。假设当前剩下的没填的格子数为 $x$，当前没填的数字的和为 $y$，先前加过的分为 $z$，则 $g(x,y,z)=x\times y \times 9+z$。当估价函数小于当前答案时，直接剪枝。其中，$9$ 是一个期望的值。
2. 把 vector 改为普通数组。
3. 乱搞排序，先按能填的个数从小到大排，再按横坐标从右到左排。这个方法不适用所有题，只是针对 CCF 的数据。
4. 位运算，这里的位运算是要比 bitset 快的。
5. 使用 stable\_sort。

这里不能搜到结果就直接结束，因为要使结果最大。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[15][15],ans=-1,lst=81,cnt=0;
int xvis[15],yvis[15],svis[15];
int w[15][15]={{},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
inline int s(int x,int y)
{
	return ((x-1)/3*3+(y+2)/3);
}
int cg(int x,int y)
{
	int ans;
	int res=0;
	ans=xvis[x]|yvis[y]|svis[s(x,y)];
	for(int i=1;i<=9;i++)if(ans>>i==0)res++;
	return res;
}
struct tile{
	int x,y,g;
};
tile vct[105];
bool cmp(tile a,tile b)
{
	if(a.g!=b.g)return a.g<b.g;
	return a.x>b.x;
}
void dfs(int now,int sw,int lsm)
{
	if(now>=cnt)
	{
		ans=max(ans,sw);
		return;
	}
	if(sw+9*lsm*lst<ans)return;
	int x=vct[now].x,y=vct[now].y;
	int tmps=s(x,y);
	int ans=xvis[x]|yvis[y]|svis[tmps];
	for(int i=9;i>=1;--i)
	{
		if(((ans>>i)&1)==0)
		{
			xvis[x]|=(1<<i);
			yvis[y]|=(1<<i);
			svis[tmps]|=(1<<i);		
			a[x][y]=i;
			--lst;
			dfs(now+1,sw+i*w[x][y],lsm-i);
			xvis[x]=(xvis[x]^(1<<i));
			yvis[y]=(yvis[y]^(1<<i));		
			svis[tmps]=(svis[tmps]^(1<<i));	
			a[x][y]=0;	
			++lst;		
		}
	}
}
int main()
{
	int lsm=405,prsum=0;
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cin>>a[i][j];
			if(a[i][j]!=0)
			{
				svis[s(i,j)]|=1<<a[i][j];
				xvis[i]|=1<<a[i][j];
				yvis[j]|=1<<a[i][j];	
				lst--;
				lsm-=a[i][j];
				prsum+=w[i][j]*a[i][j];
			}
		}
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j]!=0)continue;
			tile tmp;
			tmp.x=i,tmp.y=j;
			tmp.g=cg(i,j);
			vct[cnt++]=tmp;
		}
	}
	stable_sort(vct,vct+cnt,cmp);
	dfs(0,prsum,lsm);
	cout<<ans;
	return 0;
}
```

---

## 作者：ClaudeHsu (赞：3)

# **思路**

我们可以采用深度优先搜索。

对于每一个格子讨论，填完后再比大小。

但要想通过此题，这样做还不够。

实际上可以从情况较小的格子开始讨论，减少状态数。

我们在设计一个估价函数，表示接下来都最优化填值的解。

如果这个值比已有的答案小，直接返回。

# **代码**

无注释代码最可爱。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define ll long long
int getint(){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-f;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}
const int MAXN=12;
const int score[10][10]=
{{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6}};
int row[MAXN][MAXN],col[MAXN][MAXN],area[MAXN][MAXN],sdk[MAXN][MAXN];
int row_cnt[MAXN],col_cnt[MAXN],cnt,ans=-1;
inline int id(int i,int j){return(i-1)/3*3+1+(j-1)/3;}
inline int calc(){
	int tmp=0;
	for(int i=1;i<=9;++i)
	for(int j=1;j<=9;++j)
	tmp+=score[i][j]*sdk[i][j];
	return tmp;
}
void dfs(int r,int c,int cpl){
	if(cpl==81){
		ans=max(ans,calc());
		return;
	}
	for(int k=1;k<=9;++k){
		if(row[r][k]||col[c][k]||area[id(r,c)][k])continue;
		row[r][k]=true;
		col[c][k]=true;
		area[id(r,c)][k]=true;
		row_cnt[r]++,col_cnt[c]++;
		sdk[r][c]=k;
		int tmpr=-1,nxt_r=0,tmpc=1,nxt_c=0;
		for(int i=1;i<=9;++i)
		if(row_cnt[i]>tmpr&&row_cnt[i]<9)tmpr=row_cnt[i],nxt_r=i;
		for(int j=1;j<=9;++j)
		if(col_cnt[j]>tmpc&&(!sdk[nxt_r][j]))tmpc=col_cnt[j],nxt_c=j;
		dfs(nxt_r,nxt_c,cpl+1);
		row[r][k]=false;
		col[c][k]=false;
		area[id(r,c)][k]=false;
		row_cnt[r]--,col_cnt[c]--;
		sdk[r][c]=0;
	}
}
int main(){
	for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++){
			sdk[i][j]=getint();
			if(sdk[i][j]){
				row[i][sdk[i][j]]=true;
				col[j][sdk[i][j]]=true;
				area[id(i,j)][sdk[i][j]]=true;
				row_cnt[i]++,col_cnt[j]++;
				cnt++;
			}
		}
	}
	int tmpr=-1,r,tmpc=-1,c;
	for(int i=1;i<=9;i++)
	if(row_cnt[i]>tmpr&&row_cnt[i]<9)tmpr=row_cnt[i],r=i;
	for(int j=1;j<=9;j++)
	if(col_cnt[j]>tmpc&&(!sdk[r][j]))tmpc=col_cnt[j],c=j;
	dfs(r,c,cnt);
	cout<<ans;
	return 0;
}
```

# **欢迎点赞**

---

## 作者：OIerror (赞：2)

<https://luogu.com.cn/problem/P1074>

# 奇妙搜索题

## 搜索
我们可以用两个数组来记录一个数在第 $i$ 行（列）有没有出现过，最基本的做法就是暴力搜索每一行每一列，枚举每一格填什么数同时统计分数，得分 $80-90$。

## 优化一
剪枝

对于每个 $(i,j)$ 确定一个值 $S$ 如果当前分数 $sum+S\le ans$ （$ans$ 表示当前最优答案），那么就不必搜索，返回即可。

$S$ 的取值可以设定为假设后面每一个数都填 $9$ 的得分。当然，由于后续答案不可能大于 $S$，所以可以适当乘上系数 $k$（注意！越接近结尾，$k$ 就要越大）

得分 $80-95$

## 优化二
卡时

~~玄学呀~~

计算递归次数，在即将超时时退出。

得分 $80-100$

## 优化三

剪枝

感性理解一下，我们做数独时，一般都会先从数字多的行（或列，此处以行为例）开始。因此，我们可以记录每行数字个数，贪心的按数字个数从多到少进行搜索，这种算法结合了贪心和搜索，我们叫它 $A^*$。

得分 $100$

## 彩蛋

倒序搜索格子（即从 $81-1$）再加上倒序枚举当前格子所填数字（即从 $9-1$）可以在只加卡时的情况下通过。

玄学至哉，歌以咏志。

---

## 作者：zhoujunchen (赞：2)

做题思路
--

一道搜索好题，我们可以先填好数独，再计算分数。

首先数独要求每一行、每一列、每一个 $3\times3$ 方阵内的数字不重复。判断行和列重复很简单，开个二维的标记数组即可，第一维代表行号或列号，第二维代表出现的数字。

然后方阵内的数字经过观察可以发现，假设当前在 $i$ 行 $j$ 列，则方阵编号为 $(i-1)\div 3\times 3+(j-1)\div 3+1$。

如果 $(i-1)$ 或 $(j-1)$ 不是三的倍数，那就向下取整。

[代码。](https://www.luogu.com.cn/paste/0wvdppa5)

但这样会超时。

~~经过同学的尝试后~~，数据很水，我们可以从 $(9,9)$ 往 $(1,1)$ 搜。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=15,sc[10][10]=
{{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6}};
int a[n][n],sd[n][n],ans=-1;
bool vis[n][n],kuai[n][n],pai[n][n],lie[n][n];
void dfs(int x,int y){
	if(sd[x][y]){
		if(x==1&&y==1){
			int sum=0;
			for(int i=1;i<=9;i++)for(int j=1;j<=9;j++)sum+=sd[i][j]*sc[i][j];
			ans=max(ans,sum);
			return ;
		}else if(y==1&&x!=1)dfs(x-1,9);
		else dfs(x,y-1);
	}else{
		for(int i=9;i>=1;i--){
			if(!pai[x][i]&&!lie[y][i]&&!kuai[(x-1)/3*3+(y-1)/3+1][i]){
				pai[x][i]=lie[y][i]=kuai[(x-1)/3*3+(y-1)/3+1][i]=1;
				sd[x][y]=i;
				if(x==1&&y==1){
					int sum=0;
			        for(int i=1;i<=9;i++)for(int j=1;j<=9;j++)sum+=sd[i][j]*sc[i][j];
		        	ans=max(ans,sum);
				}else if(y==1)dfs(x-1,9);
				else dfs(x,y-1);
				pai[x][i]=lie[y][i]=kuai[(x-1)/3*3+(y-1)/3+1][i]=0;
				sd[x][y]=0;
			}
		}
	}
}
signed main(){
	for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++){
			cin>>a[i][j];
			sd[i][j]=a[i][j];
			if(a[i][j])kuai[(i-1)/3*3+(j-1)/3+1][a[i][j]]=pai[i][a[i][j]]=lie[j][a[i][j]]=1;
		}
	}
	dfs(9,9);
	cout<<ans;
	return 0;
}
```

[AC。](https://www.luogu.com.cn/record/196508491)

---

## 作者：MMXIandCCXXII (赞：1)

## Solution

既然是远古错题，那么我们就可以试一试暴力 dfs，一个一个枚举出数独里的数，中间做可行性剪枝，到最后把每个位置乘上对应权值，取最大值即可。

我们可以提前用数组记录对应位置的权值和它所属的宫，方便判断和计算。

~~因为是错题，所以充分发挥乱搞精神，权值矩阵对称，所以上下颠倒输入，就能过了。~~

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int gong[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}
}; // 每个位置对应的宫

int zhi[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6},
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
    {0, 6, 7, 8, 9,10, 9, 8, 7, 6},
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6},
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6},
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};// 每个位置对应的权值

int a[10][10], ans;
bool h[10][10], l[10][10], g[10][10]; //九个行、列、宫的九个数出现了吗

void dfs(int x, int y)
{
    if (x == 10)
    {
        int now = 0;
        for (int i = 1; i <= 9; i++)
            for (int j = 1; j <= 9; j++)
                now += a[i][j] * zhi[i][j];
        ans = max (ans, now);
        return;
    }
    if (a[x][y])
	{
		dfs (x + y / 9, y % 9 + 1);
		return;
	} // 有数直接跳
    for (int i = 1; i <= 9; i++)
    {
        if (g[gong[x][y]][i] || h[x][i] || l[y][i]) continue;// 可行性剪枝
        a[x][y] = i;
        g[gong[x][y]][i] = h[x][i] = l[y][i] = true;
        dfs (x + y / 9, y % 9 + 1);
        a[x][y] = 0;
        g[gong[x][y]][i] = h[x][i] = l[y][i] = false; // 回溯
    }
}

int main()
{
    memset (h, false, sizeof h);
    memset (l, false, sizeof l);
    memset (g, false, sizeof g);
    memset (a, 0, sizeof a);
    for (int i = 9; i; i--)
        for (int j = 1; j <= 9; j++)
        {
            cin >> a[i][j];
            h[i][a[i][j]] = g[gong[i][j]][a[i][j]] = l[j][a[i][j]] = true;
        }
    dfs (1, 1);
    if (ans == 0) cout << -1 << endl;
    else cout << ans << endl;
    return 0;
}
```

---

## 作者：CommandSR (赞：1)

## 题意简述

要求完成一个数独，满足普通数独的基础上最大化得分，得分为每一位的权值和所填数字的乘积。

## 基本思路

数独大小较小，考虑搜索，并加入适当剪枝。

### 准备工作

为了更方便的获取每一个格子的得分和其所在的“宫”，进行打表记录，当然你也可以选择写一个函数。

如果你习惯数组从 $0$ 开始存，打表的时候别忘了空出 $0$ 的位置。

```cpp
 
const int scr[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6}, 
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 10, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, 
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};
 
const int area[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
};
 
```

### 搜索剪枝部分

暴力的搜索写起来非常容易，只需判断当前行，列，宫有没有出现过当前枚举到的数字即可，但是时间复杂度较高，考虑剪枝。

我们先填 $0$ 少的行，而后填 $0$ 的多的行，这样可以有效减少状态数，搜索前按照每一行 $0$ 的数量排序即可。

然后发现……加上这一条剪枝就过了。

当然，还有一些细节也可能增大你的时间复杂度。

1. 不要放到最后判断状态是否合法，枚举当前格数字的时候就判断有没有出现过，不搜不合法状态。
2. 注意按 $0$ 的个数排序后行的顺序发生了变化，不要混淆**当前搜索到第几行**和**当前搜了几行**。
   
剩下的细节可能在代码中体现。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
 
const int scr[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6}, 
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 10, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, 
    {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, 
    {0, 6, 7, 7, 7, 7, 7, 7, 7, 6},
    {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}
};
 
const int area[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, 
    {0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
    {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, 
};
 
int a[15][15], ans = 0, sum0[15], id[15], tmp = 0;
bool vis_x[10][10], vis_y[10][10], vis_area[10][10];
 
bool cmp(int x, int y) {
    return sum0[x] < sum0[y];
}
 
void dfs(int x, int y, int goal) {
    if (y > 9) y = 1, x++;
    if (x == 10 && y == 1) {
        ans = max(ans, goal);
        return;
    }
    if (a[id[x]][y]) dfs(x, y + 1, goal);
    else {
        for (int i = 1; i <= 9; i++) {
            if (!vis_x[id[x]][i] && !vis_y[y][i] && !vis_area[area[id[x]][y]][i]) {
                vis_x[id[x]][i] = vis_y[y][i] = vis_area[area[id[x]][y]][i] = 1;
                dfs(x, y + 1, goal + i * scr[id[x]][y]);
                vis_x[id[x]][i] = vis_y[y][i] = vis_area[area[id[x]][y]][i] = 0;
            }
        }
    }
}
 
int main() {
    for (int i = 1; i <= 9; i++) {
        id[i] = i;
        for (int j = 1; j <= 9; j++) {
            cin >> a[i][j];
            tmp += a[i][j] * scr[i][j];
            sum0[i] += (!a[i][j]);
            vis_x[i][a[i][j]] = vis_y[j][a[i][j]] = vis_area[area[i][j]][a[i][j]] = 1;
        }
    }
    sort(id + 1, id + 1 + 9, cmp); // 按 0 的数量排序
    dfs(1, 1, tmp);
    cout << (ans == 0 ? -1 : ans) << '\n';
    return 0;
}
```

---


# [蓝桥杯 2023 国 Java B] 数和游戏

## 题目描述

数和游戏是一种棋盘填数游戏。棋盘上分为白色和灰色两种类型的格子。游戏目标是通过在白色的格子里填入数字 $1 \dots 9$ 来满足游戏要求。

游戏当中有一个称作“条目”的概念，条目指的就是在水平方向或者垂直方向上所有连续出现的白色格子的集合。具体来说从灰色格子右方（下方）相邻的白色格子出发，一直向右方（下方）行走直到走出棋盘边界或遇到灰色格子才停止，途中经过的所有的白色格子组成的集合就称为条目。例如上图中，我们用 $(x, y)$ 表示格子坐标，坐标 $(1, 4)$ 下方的条目就是由坐标 $(2, 4)$ 和 $(3, 4)$ 的白色格子构成的；坐标 $(5, 1)$ 右方的条目是由坐标 $(5, 2)$、$(5, 3)$ 的白色格子构成的。但注意坐标 $(7, 2)$、$(7, 3)$、$(7, 4)$ 处的格子的集合并不是一个条目，在加入坐标 $(7, 5)$ 的格子后才是一个条目。

游戏具体要求如下：游戏在一个 $M \times N$ 大小的格子棋盘上进行，其中格子分为白色和灰色两种类型：
1) 白色格子，此种类型的格子应当填入一个 $1 \dots 9$ 范围内的整数并满足所有灰色格子的要求；
2) 灰色格子，此种类型的格子用一条对角线将格子分为了左下（用 $A$ 表示）和右上（用 $B$ 表示）两部分，若 $A$ 中有数字，则表示 $A$ 所在的格子下方条目中的数字之和应该等于 $A$ 中的数字；若 $B$ 中有数字，则表示 $B$ 所在的格子右方条目中的数字之和应该等于 $B$ 中的数字。除此之外还有一个重要的约束条件：每一个条目中不能出现重复的数字，即在每一个条目之中，$1 \dots 9$ 中的每个数字最多只能出现一次。我们保证游戏一定有一个唯一解。

![](https://cdn.luogu.com.cn/upload/image_hosting/3dkcy4vy.png)

上图是一个数和游戏的例子示意图，坐标 $(1, 4)$ 处是一个灰色格子，它的 $A$ 中的数字为 $4$，这意味它下方的条目（即坐标 $(2, 4)$、$(3, 4)$ 处的白色格子）中的数字之和应该为 $4$；坐标 $(5, 1)$ 处是一个灰色格子，它的 $B$ 中的数字是 $16$，这表示它右方的条目（即坐标 $(5, 2)$、$(5, 3)$ 处的白色格子）中的数字之和应该为 $16$。

## 说明/提示

### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/khg8k4ql.png)

此局游戏的答案如上图所示。

### 评测用例规模与约定

- 对于 $30\%$ 的测试用例，$3 \leq M, N \leq 5$。
- 对于 $60\%$ 的测试用例，$3 \leq M, N \leq 10$。
- 对于 $100\%$ 的测试用例，$3 \leq M, N \leq 15$，$1 \leq$ 灰色格子中的数字 $\leq 50$。

## 样例 #1

### 输入

```
7 7
2 -1 -1 2 -1 -1 2 -1 -1 2 4 -1 2 14 -1 2 19 -1 2 11 -1
2 -1 -1 2 -1 -1 2 21 24 1 1 1 1
2 -1 -1 2 26 18 1 1 1 1 1
2 -1 12 1 1 2 -1 -1 2 -1 3 1 1
2 -1 16 1 1 2 17 -1 2 11 8 1 1
2 -1 28 1 1 1 1 1 2 -1 -1
2 -1 14 1 1 1 1 2 -1 -1 2 -1 -1```

### 输出

```
_ _ _ _ _ _ _
_ _ _ 3 9 7 5
_ _ 6 1 5 4 2
_ 8 4 _ _ 2 1
_ 9 7 _ _ 5 3
_ 7 3 9 8 1 _
_ 2 1 8 3 _ _```

# 题解

## 作者：sanhaoxuezha (赞：0)

本题为一道简单的搜索题，思维难度并不大，但码量较大。

可以用结构体来表示格子和条目

初始化就是将每个条目的数值和每个格子的所属条目记录。

搜索就是把每个格子中可填入的数搜一遍。

接着就没什么要说的了，就是初始化和搜索，主要讲解在代码里。

```cpp
#include<bits/stdc++.h>

using namespace std;

//记录格子
struct Block
{
    int color;	//颜色
    int a,b;	//如果颜色为灰，记录条目
    int num;	//如果颜色为白，记录填入数字
    vector<int> item;	//如果颜色为白，记录所有所属的条目，其实这里可以用一个pair容器来记录，但为图方便，用vector记录
};

//记录条目
struct Line
{
    int lastx,lasty;	//条目中最后一个格子的坐标
    int remain;	//条目中还未被填入的格子数量
    bool vis[10];	//记录每个数字是否被用过
};

const int N=20;

Block block[N][N];
Line line[N*N];	//其实这里开50就够了

int n,m;
bool flag=0;		//记录是否找到答案
int cnt=0;		//line数组大小，其实line数组完全可以用vector代替，但这样会比较麻烦

//输出
void output()
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(block[i][j].color==2) cout<<'_';
            else cout<<block[i][j].num;
            cout<<' ';
        }
        cout<<'\n';
    }
}

//初始化
void init()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(block[i][j].color==2)	//如果本格为灰色格子
            {
                if(block[i][j].b!=-1)	//竖条目
                {
                    line[cnt].remain=block[i][j].b;
                    line[cnt].lastx=i;
                    for(int k=j+1;k<=m;k++)
                    {
                        if(block[i][k].color==2) break;
                        line[cnt].lasty=k;
                        block[i][k].item.push_back(cnt);
                    }
                    cnt++;
                }
                if(block[i][j].a!=-1)	//横条目
                {
                    line[cnt].remain=block[i][j].a;
                    line[cnt].lasty=j;
                    for(int k=i+1;k<=n;k++)
                    {
                        if(block[k][j].color==2) break;
                        line[cnt].lastx=k;
                        block[k][j].item.push_back(cnt);
                    }
                    cnt++;
                }
            }
}

//搜索
void dfs(int k)
{
    if(k==n*m)	//终止条件
    {
        flag=1;
        output();
        return ;
    }
    int x=k/n+1,y=k%n+1;	//坐标
    if(block[x][y].color==2)	//如果本格颜色为灰，跳过
    {
        dfs(k+1);
        return ;
    }
    for(int i=1;i<=9;i++)	//枚举数字
    {
        bool flag2=1;
        for(int it:block[x][y].item)
            if(line[it].vis[i] || line[it].remain<i || (x==line[it].lastx && y==line[it].lasty && line[it].remain!=i))	//是否可以填
            {
                flag2=0;break;
            }
        if(!flag2) continue;	//若不可以，跳过
        block[x][y].num=i;	//填入
        for(int it:block[x][y].item)	//打标记
        {
            line[it].vis[i]=1;
            line[it].remain-=i;
        }
        dfs(k+1);
        if(flag) return ;
        block[x][y].num=0;
        for(int it:block[x][y].item)	//去标记
        {
            line[it].vis[i]=0;
            line[it].remain+=i;
        }
    }
}

signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            cin>>block[i][j].color;
            if(block[i][j].color==2) cin>>block[i][j].a>>block[i][j].b;
        }
    init();
    dfs(0);

    return 0;
}
```

---


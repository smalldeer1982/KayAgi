# 运动员最佳匹配问题

## 题目描述

羽毛球队有男女运动员各 $n$ 人。给定 $2$ 个 $n \times n$ 矩阵 $P$ 和 $Q$。$P_{i,j}$ 是男运动员 $i$ 和女运动员 $j$ 配对组成混合双打的男运动员竞赛优势；$Q_{i,j}$ 是女运动员 $i$ 和男运动员 $j$ 配合的女运动员竞赛优势。

但是，由于技术配合和心理状态等各种因素影响，$P_{i,j}$ 不一定等于 $Q_{j,i}$。男运动员 $i$ 和女运动员 $j$ 配对组成混合双打的男女双方竞赛优势为 $\bm{P_{i,j} \times Q_{j,i}}$。

现在，请你设计一个算法，计算男女运动员最佳配对法，使各组男女双方竞赛优势的总和达到最大。


## 样例 #1

### 输入

```
3
10 2 3
2 3 4
3 4 5
2 2 2
3 5 3
4 5 1```

### 输出

```
52```

# 题解

## 作者：薛裕龙 (赞：30)

通过我仔细的观察，下面只有一篇是用了km算法，但是并不是c++，那我就来写一篇c++的KM算法吧。
这就是一道KM的裸题，边权就是P[i][j]* Q[i][j]，然后跑一边KM，这道题就完啦。

不要问KM算法啥玩意，那应该是在博客里学习的内容。

这个写的可以(https://www.cnblogs.com/wenruo/p/5264235.html)

但是我写的要比他简洁一点，仔细看看过程吧。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int a[25][25];//边权
int lx[25],ly[25];//顶标
int visx[25],visy[25];//标记
int pi[25];//记录匹配对象
int n;
int minz;//记录最小的改变量
bool dfs(int s){
	visx[s]=1;
	for(int i=1;i<=n;i++)
		if(!visy[i]){
			int t=lx[s]+ly[i]-a[s][i];
			if(t==0){
				visy[i]=1;
				if(pi[i]==0||dfs(pi[i])){
					pi[i]=s;
					return true;
				}
			}else if(t>0){
				minz=min(minz,t);
			}
		}
	return false;
}
void km(){
	for(int i=1;i<=n;i++){
		while(1){
			minz=100000000;
			memset(visx,0,sizeof(visx));
			memset(visy,0,sizeof(visy));
			if(dfs(i))break;
			for(int j=1;j<=n;j++)
			if(visx[j])lx[j]-=minz;
			for(int j=1;j<=n;j++)
			if(visy[j])ly[j]+=minz;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			int r;
			scanf("%d",&r);
			a[j][i]*=r;
        	//这个肯定是要倒过来的，仔细读题
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			lx[i]=max(lx[i],a[i][j]);//顶标预处理
	km();
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=a[pi[i]][i];//累加答案
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Daniel_7216 (赞：15)

~~多好的暴搜题啊，竟然被你们这么糟蹋了……~~

拿到题目之后先看数据范围，$n$ 小于等于 $20$，常识告诉我们，这么小的数据范围可以允许几乎任何复杂度，然后我兴奋地写了一个纯暴力，交上去 $80pts$，果然还是会超时。

考虑一个小优化，可行性剪枝。如果我们确定了前 $i$ 号男运动员，那么第 $i+1$ 到 第 $n$ 号男运动员的理论最大竞赛优势总和就是 $\sum\limits_{x=i+1}^n\max(p_{x,j} \times q_{j,x}),j\in [1,n]$。然后本题的神奇之处就在于，在原先的的代码里再暴力算理论最大竞赛优势总和，用这个数来判断可行性，就过了……

代码：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n, ans, mx, p[21][21], q[21][21];
bool vis[21];
void dfs(int i, int sum){//考虑到第i个男运动员，当前竞赛优势和为sum 
    if (i == n + 1){
    	ans = max(ans, sum);
    	return;
	}
	int tmp = 0;
	for (int j = i; j <= n; j++){
		for (int k = 1; k <= n; k++){
			mx = max(mx, p[j][k] * q[k][j]);
		}
		tmp += mx;
	}
	if (sum + tmp <= ans) return;
	for (int j = 1; j <= n; j++){
		if (!vis[j]){
			vis[j] = true;
			dfs(i + 1, sum + p[i][j] * q[j][i]);
			vis[j] = false;
		}
	}
} 
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			scanf("%d", &p[i][j]);
		}
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			scanf("%d", &q[i][j]);
		}
	}
	dfs(1, 0);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：重回巅峰！ (赞：15)


这种好题，怎么能用低级的搜索水过呢，当然要用KM做。



标准的KM算法。

该算法是通过给每个顶点一个标号（叫做顶标）来把求最大权匹配的问题转化为求完备匹配的问题的。设顶点  的顶标为  ，顶点  的顶标为  ，顶点  与  之间的边权为  。在算法执行过程中的任一时刻，对于任一条边  ，  始终成立。

KM算法的正确性基于以下定理：

若由二分图中所有满足  的边  构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。

首先解释下什么是完备匹配，所谓的完备匹配就是在二部图中，  点集中的所有点都有对应的匹配且  点集中所有的点都有对应的匹配，则称该匹配为完备匹配。

这个定理是显然的。因为对于二分图的任意一个匹配，如果它包含于相等子图，那么它的边权和等于所有顶点的顶标和；如果它有的边不包含于相等子图，那么它的边权和小于所有顶点的顶标和。所以相等子图的完备匹配一定是二分图的最大权匹配。

初始时为了使  恒成立，令  为所有与顶点  关联的边的最大权，  。如果当前的相等子图没有完备匹配，就按下面的方法修改顶标以使扩大相等子图，直到相等子图具有完备匹配为止。

我们求当前相等子图的完备匹配失败了，是因为对于某个  顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是  顶点。现在我们把交错树中  顶点的顶标全都减小某个值  ，  顶点的顶标全都增加同一个值  ，那么我们会发现：

1）两端都在交错树中的边  ，  的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。

2）两端都不在交错树中的边  ，  和  都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。

3）  端不在交错树中，  端在交错树中的边  ，它的  的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。

4）  端在交错树中，  端不在交错树中的边  ，它的  的值有所减小。它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。

5）到最后，  端每个点至少有一条线连着，  端每个点有一条线连着，说明最后补充完的相等子图一定有完备匹配。（若由二分图中所有满足  的边  构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。）

现在的问题就是求  值了。为了使  始终成立，且至少有一条边进入相等子图，  应该等于：  （  在交错树中，  不在交错树中）。

改进
以上就是KM算法的基本思路。但是朴素的实现方法，时间复杂度为  ——需要找  次增广路，每次增广最多需要修改  次顶标，每次修改顶标时由于要枚举边来求  值，复杂度为  。实际上KM算法的复杂度是可以做到 的。我们给每个  顶点一个“松弛量”函数  ，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边  时，如果它不在相等子图中，则让  变成原值与  的较小值。这样，在修改顶标时，取所有不在交错树中的  顶点的  值中的最小值作为  值即可。但还要注意一点：修改顶标后，要把所有的不在交错树中的  顶点的  值都减去  。

Kuhn－Munkres算法流程：

（1）初始化可行顶标的值；

（2）用匈牙利算法寻找完备匹配；

（3）若未找到完备匹配则修改可行顶标的值；

（4）重复（2）（3）直到找到相等子图的完备匹配为止。

```cpp
const maxn=20000;
var
  vx,vy:array[0..1000]of boolean;
  match,lx,ly:array[0..1000]of longint;
  w:array[0..1000,0..1000]of longint;
  d,i,j,k,ans,n,m,max,ans2:longint;
function min(a,b:longint):Longint;
begin
  if a>b then exit(b) else exit(a);
end;
function find(x:longint):boolean;
var y:byte;
begin
    vx[x] := true;
    for y := 1 to n do
        if (not vy[y]) and (lx[x] + ly[y] = w[x,y]) then
        begin
            vy[y] := true;
            if (match[y]=0)or(find(match[y])) then
            begin
                match[y]:=x;
                exit(true);
            end;
        end;
    exit(false);
end;
begin
  readln(n);
  for i:=1 to n do
  begin
    for j:=1 to n do
    begin
      read(w[i,j]);
      if w[i,j]>lx[i] then lx[i]:=w[i,j];
    end;
    readln;
  end;
  for i:=1 to n do
  begin
    for j:=1 to n do
    begin
      read(m);
      w[j,i]:=w[j,i]*m;
      if w[j,i]>lx[j] then lx[j]:=w[j,i];
    end;
  end;
  fillchar(ly,sizeof(ly),0); ans:=0;
  for k:=1 to n do
  repeat
    max:=0;
    fillchar(vx, sizeof(vx), 0);
    fillchar(vy, sizeof(vy), 0);
    if (find(k)) then break;
    d := maxn;
    for i := 1 to n do
        if (vx[i]) then
            for j := 1 to n do
                if (not vy[j]) then
                    d := min(d, lx[i] + ly[j] - w[i,j]);
    for i := 1 to n do
    begin
        if (vx[i]) then dec(lx[i], d);
        if (vy[i]) then inc(ly[i], d);
    end;
  until false;
  for i:=1 to n do if match[i]<>0 then ans:=ans+w[match[i],i]; 
  writeln(ans);
end.
请叫我活雷锋。。。。。。。。
```

---

## 作者：chdy (赞：14)

我观察了一下发现~~题解中的KM算法都是很死板的~~，或者说一些证明都是网上严格的，不带上自己对算法的理解。

所以有了此篇题解。

- 首先边权我们是知道的直接两个矩阵行列相乘即可。

- 关键是二分图的带权匹配求最大权值，这个我想任何人第一眼都是爆搜吧，因为这带给我们一种假象是有可能权值大的人不动而权值小的人可能随意交换可能凑出最优解，显然这是一个NP问题。

- KM算法的正确性：

1. KM算法要求的是图中最大权匹配是完备匹配也就是说都匹配上了。我想这个条件要不是题目中自己给出了，要不就是边权都是正值且每个点想其他点都有连边如本题，此时这个性质是可以被保证的。

2. 这个算法是围绕着顶点的定标匹配的我来定性的描述这个算法的过程：首先每个点都和自己最大的边权进行匹配，然后发现有些点没有匹配对象的话更换交错树中定标的值然后再次寻找增广路。当然新能沟通的路是边权变化最小的。

3. 经过我长期的研究我终于把我的反例证明出来了我的意思是指是否存在一种情况使得当前直接点匹配上比两个已匹配边更换匹配然后是当前点得到匹配更优，这个主意很容易走到这个误区经过我画的多张图我发现出现这种情况的是不存在完备匹配的情况的否则皆可以利用KM网上的证明方法来证明。

这是在下对此题的一些微薄的理解 ~~如果对你有帮助请点赞~~。

code:
```cpp
//#include<bits/stdc++.h>
#include<iostream>
#include<queue>
#include<iomanip>
#include<cctype>
#include<cstdio>
#include<deque>
#include<utility>
#include<cmath>
#include<ctime>
#include<cstring>
#include<string>
#include<cstdlib>
#include<vector>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)>(y)?(y):(x))
#define INF 1000000000
#define ll long long
#define db double
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void put(int x)
{
    x<0?putchar('-'),x=-x:0;
    int num=0;char ch[50];
    while(x)ch[++num]=x%10+'0',x/=10;
    num==0?putchar('0'):0;
    while(num)putchar(ch[num--]);
    putchar('\n');return;
}
const int MAXN=30;
int n,delta,ans;
int a[MAXN][MAXN],b[MAXN][MAXN],w[MAXN][MAXN];
int l[MAXN],r[MAXN],vl[MAXN],vr[MAXN],match[MAXN];
inline int dfs(int x)
{
	vl[x]=1;
	for(int i=1;i<=n;++i)
	{
		if(vr[i])continue;
		if(l[x]+r[i]==w[x][i])
		{
			vr[i]=1;
			if(!match[i]||dfs(match[i]))
			{
				match[i]=x;
				return 1;
			}
		}
		else delta=min(delta,l[x]+r[i]-w[x][i]);
	}
	return 0;
}
inline void KM()
{
	for(int i=1;i<=n;++i)
	{	
		r[i]=0;l[i]=-INF;
		for(int j=1;j<=n;++j)
			l[i]=max(l[i],w[i][j]);
	}
	for(int i=1;i<=n;++i)
	{
		while(1)
		{
			memset(vl,0,sizeof(vl));
			memset(vr,0,sizeof(vr));
			delta=INF;
			if(dfs(i))break;
			for(int j=1;j<=n;++j)
			{
				if(vl[j])l[j]-=delta;
				if(vr[j])r[j]+=delta;
			}
		}
	}
}
int main()
{
	//freopen("1.in","r",stdin);
	n=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			a[i][j]=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			b[i][j]=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			w[i][j]=a[i][j]*b[j][i];
	KM();
	for(int i=1;i<=n;++i)ans+=w[match[i]][i];
	put(ans);
	return 0;
}

```


---

## 作者：清平乐 (赞：10)

注意到 $n\leq20$   

于是我们可以用乱七八糟的方法（暴搜，费用流）等水过这道题  

这里我用了 $\text{KM}$ 算法来处理（其实发这一片题解不是为了这道题，而是为了提醒一下很多人写的 $\text{KM}$ 算法时间复杂度没有那么优秀，就包括了这道题以前的部分写 $\text{KM}$ 的题解复杂度可能也假了）

------------

### 处理二分图带权最佳匹配问题各个方法的时间复杂度：
1. 暴搜 $O(n!)$（大概是吧）

2. 费用流 $O(n^2m)$

3. $\text{KM}$算法（ $\text{DFS}$ 实现增广） $O(n^2m)$

4. $\text{KM}$算法（ $\text{BFS}$ 实现增广） $O(n^3)$  
   
~~这应该也是很少见的 DFS,BFS 处理问题时间复杂度不同的情况吧。~~  
至于为什么可以百度一下，或者参见： [KM算法的时间复杂度讨论](https://www.zhihu.com/question/53200316)

或许你会说 $O(n^2m)$ 和 $O(n^3)$ 感觉区别不大，但当这是一个网格图时（就比如这道题），$O(n^2m)$ 已经趋近于 $O(n^4)$，差距会明显拉开，所以尽量使用 $\text{BFS}$
增广。  

检验你的 $\text{KM}$ 算法的时间复杂度：[P6577 【模板】二分图最大权完美匹配](https://www.luogu.com.cn/problem/P6577)


------------
###  回到本题：
将 $i$ 号男运动员和 $j$ 号女运动员匹配产生的贡献为 $P[i][j]\times Q[j][i]$ （注意是 $Q[j][i]$ 不是 $Q[i][j]$），用邻接矩阵存起来后跑 $\text{KM}$ 算法即可

code：（ $\text{BFS}$ 实现 $\text{KM}$ 算法）

```cpp
#include<stdio.h>
#include<bits/stdc++.h>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;

const int N=25,INF=1e9;
int n,m,y,c,h;
bool visit[N];
int p[N][N],q[N][N],graph[N][N],slack[N],link[N],pre[N],lx[N],ly[N];

inline void BFS(int k)
{
    register int x=0,y=0,ny=0,d=INF;
    memset(pre,0,sizeof(pre));
    memset(slack,0x3f,sizeof(slack));
    link[y]=k;
    do
    {
        x=link[y],d=INF,visit[y]=true;
        for(register int i=1;i<=n;++i)
            if(!visit[i])
            {
                if(slack[i]>lx[x]+ly[i]-graph[x][i]) slack[i]=lx[x]+ly[i]-graph[x][i],pre[i]=y;
                if(slack[i]<d) d=slack[i],ny=i;
            }
        for(register int i=0;i<=n;++i)
            if(visit[i]) lx[link[i]]-=d,ly[i]+=d;
            else slack[i]-=d;
        y=ny;
    }
    while(link[y]);
    while(y) link[y]=link[pre[y]],y=pre[y];
}

inline int KM(void)
{
	memset(lx,0x3f,sizeof(lx));
	register int dfn=0;
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			lx[i]=max(lx[i],graph[i][j]);
	for(register int i=1;i<=n;++i)
	{
		memset(visit,0,sizeof(visit));
		BFS(i);
	}
	register int ans=0;
	for(register int i=1;i<=n;++i)
		if(link[i]) ans+=graph[link[i]][i];
	return ans;
}

int main(void)
{
	scanf("%d",&n);
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			scanf("%d",&p[i][j]);
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			scanf("%d",&q[i][j]);
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			graph[i][j]=p[i][j]*q[j][i];
	printf("%d\n",KM());
	return 0;
}
```



---

## 作者：huyufeifei (赞：9)

发现题解都是费用流二分图搜索，慌得一批。

虽然我也是一眼费用流，但是码量有点大，懒得打，于是写了状压DP。

然后发现复杂度是2亿，可能过不了，交上去发现只跑了37ms，说明数据太水了......

设`f[i][j]`表示前i个男运动员匹配的女运动员状态为j。

然后我们枚举j中的每一位1作为第i个男运动员的匹配者，转移。

然后交上去A了，但是还有一些优化：

+ 可以用滚动数组来节省空间。

+ 发现对于每个i，j中1的个数不为i的都是废状态，不用转移。

然后我就从37ms优化到了27ms......

实际上我们还可以不枚举j，而是通过DFS搜出满足条件的j，这样估计又能优化一些时间。但是我懒得写了。

代码：
```cpp
#include <cstdio>
#include <algorithm>

const int N = 21;

int f[2][1 << 20];
int p[N][N], q[N][N], pw[1 << 20];

inline int calnum(int s) {
    int ans = 0;
    while(s) {
        ans++;
        s -= s & (-s);
    }
    return ans;
}

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            scanf("%d", &p[i][j]);
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            scanf("%d", &q[i][j]);
        }
    }
    for(int i = 1; i < n; i++) {
        pw[1 << i] = i;
    }
    
    int lm = 1 << n;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < lm; j++) {
            if(calnum(j) != i) {
                continue;
            }
            int jj = j;
            while(jj) {
                int t = jj & (-jj);
                f[i & 1][j] = std::max(f[i & 1][j], f[(i + 1) & 1][j & (~t)] + p[i][pw[t] + 1] * q[pw[t] + 1][i]);
                jj -= t;
            }
            //printf("f %d %d  =  %d \n", i, j, f[i][j]);
        }
    }
	　
    printf("%d", f[n & 1][lm - 1]); 
    return 0;
}
```

---

## 作者：Vasily (赞：8)

这么友善的数据还是来一发最大费用最大流把！

源点向男的连流量为1费用为0的边，男的向所有女的连流量为1费用为那个什么乘积的边，女的向汇点连流量为1费用为0的边。

建模原理很简单，就是限制一下每个人的使用次数，稍微想想就明白。

其实是为了掩盖忘记二分图的尴尬（划掉）。

请忽略fread

```cpp
#include <bits/stdc++.h>
using namespace std ;
const int maxn = 30 , maxm = maxn*maxn+maxn, maxN = maxn*maxn*30, zhf = 0x3f3f3f3f ;
char buff[maxN], *_t = buff ;
void Read ( int &x, bool flag = false ) {
    for ( x = 0 ; !isdigit(*_t) ; _t ++ ) if ( (*_t) == '-' ) flag = true ;
    for ( ; isdigit(*_t) ; _t ++ ) x = 10*x + (*_t) - '0' ; if ( flag ) x = -x ;
}
int n, m, a[maxn][maxn][2], flow = 0, cost = 0, dis[maxn], lim[maxn] ;
int fa[maxn], e = 1, to[maxm], be[maxn], nxt[maxm], f[maxm], c[maxm] ;
void add ( int x, int y, int fl, int co ) {
    to[++e] = y ;
    nxt[e] = be[x] ;
    be[x] = e ;
    f[e] = fl ;
    c[e] = co ;
}
void Add ( int x, int y, int fl, int co ) {
    add ( x, y, fl, co ) ;
    add ( y, x, 0, -co ) ;
}

queue <int> Q ;
bool inq[maxn] ;
bool spfa ( int s, int t ) {
    int i, j, u, x = s ;
    for ( i = 1 ; i <= t ; i ++ )
        dis[i] = -zhf ;
    memset ( fa, 0, sizeof(fa) ) ;
    dis[x] = 0 ;
    lim[x] = zhf ;
    Q.push(x) ;
    inq[x] = 1 ;
    while ( !Q.empty() ) {
        x = Q.front() ;
        Q.pop() ;
        inq[x] = 0 ;
        for ( i = be[x] ; i ; i = nxt[i] ) {
            u = to[i] ;
            if ( dis[u] < dis[x]+c[i] && f[i]>0 ) {
                dis[u] = dis[x]+c[i] ;
                fa[u] = i ;
                lim[u] = min( lim[x], f[i] ) ;
                if ( !inq[u] ) {
                    inq[u] = 1 ;
                    Q.push(u) ;
                }
            }
        }
    }
    if ( dis[t]==-zhf ) return 0 ;
    for ( x = fa[t] ; x ; x = fa[to[x^1]] ) {
        f[x] -= lim[t] ; f[x^1] += lim[t] ;
        cost += lim[t]*c[x] ;
    }
    return 1 ;
}

int main() {
    fread( buff, 1, maxN, stdin ) ;
    int i, j, k, x, y, s, t ;
    Read(n) ; s = n<<1|1, t = s+1 ;
    for ( k = 0 ; k < 2 ; k ++ )
        for ( i = 1 ; i <= n ; i ++ )
            for ( j = 1 ; j <= n ; j ++ )
                Read(a[i][j][k]) ;
    for ( i = 1 ; i <= n ; i ++ ) {
        Add ( s, i, 1, 0 ) ;
        Add ( i+n, t, 1, 0 ) ;
        for ( j = 1 ; j <= n ; j ++ )
            Add ( i, j+n, 1, a[i][j][0]*a[j][i][1]) ;
    }
    while ( spfa(s,t) ) ;
    printf ( "%d\n", cost ) ;
    return 0 ;
}
```

---

## 作者：xkcdjerry (赞：6)

看到这道题没有模拟退火题解，水一发：  
模拟退火需要的三个重要函数和一个重要概念，这四个写出来就可以直接套用模拟退火的板子了：  
* 解：需要一个方式来表示一个解，这里可以使用一个长度为 $n$ 的数组 $a$ ，其中第 $i$ 项表示男运动员 $i$ 匹配的女运动员编号
* 初始化：我的方式是初始化 $a_i=i$ 后 `random_shuffle`
* 转移：随机交换 $a$ 中的两个数
* 估价函数：直接使用题目中给出的： $ans=\sum^{i \leqslant n}_{i=1}p_{i,{a_i}} \times q_{a_i,i}$  

代码如下（插入概念/函数的地方已用注释标明）：
```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <ctime>
using std::random_shuffle;
#define kb 1.38e-23
#define N 30
int p[N][N],q[N][N],n;

//概念1:解
struct solu
{
	int a[N];
}now,temp;
int bc,nc,tc;

//函数1:初始化函数
void init(solu &s)
{
	for(int i=1;i<=n;i++)
		s.a[i]=i;
	random_shuffle(s.a+1,s.a+1+n);
}
//函数2:估价函数
int C(solu s)
{
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=p[i][s.a[i]]*q[s.a[i]][i];
	return ans;
}
//函数3:转移函数
solu turn(solu s)
{
	int a=rand()%n+1,b=rand()%(n-1)+1;
	if(b>=a) b++;
	int t=s.a[a];
	s.a[a]=s.a[b];
	s.a[b]=t;
	return s;
}
//注意是要最大化Cost而不是最小化
inline bool accept(int d,double T)
{
	//d=tc-nc
	return d>=0||exp(d/T/kb)*RAND_MAX>rand();
}
void sa()
{
	init(now);
	nc=C(now);
	double T=1e10;
	while(T>1e-15)
	{
		tc=C(temp=turn(now));
		if(accept(tc-nc,T))
		{
			nc=tc;
			now=temp;
		}
		if(nc>bc) bc=nc;
		T*=0.99;
	}
}
#define TIME (clock()/(double)CLOCKS_PER_SEC)
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
		scanf("%d",p[i]+j);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
		scanf("%d",q[i]+j);
	bc=-1;
	while(TIME<0.8) sa();
	printf("%d",bc);
	return 0;
}
```

---

## 作者：shinzanmono (赞：3)

看到 $1\leq n\leq 20$ 可以想到状压 dp。

定义 $f_{i,S}$ 表示当前扫到 $i$，$1\sim i$ 的男选手已经和 $S$ 中的女选手配对的最大价值，转移显然：$f_{i,S}=\sum_{k\in S}f_{i-1,S-\{k\}}+w_{i,k}$。状态数 $O(2^nn)$，转移 $O(n)$，无法通过本题，需要优化常数。

考虑优化，转移时枚举 $1\sim n$ 会有很多无用枚举，所以只考虑枚举 $S$ 中的元素。这样整个转移的次数为 $O(n\sum_{i=1}^n \binom{n}{i}i)$，化简得到 $O(2^{n-1}n^2)$，可以通过本题。

---

## 作者：住在隔壁小莘 (赞：3)

通过读到 **计算男女运动员最佳配对法，使各组男女双方竞赛优势的总和达到最大** 这么一句话，你应该很快就能想到这是有关于二分图最大权完美匹配的问题。

那么二分图最大权完美匹配相较于二分图完美匹配来说，是边权有了权值，不是单纯的为了让配对数更多（或者是搜索出配对数最多的配对方法等）。

其他题解对于 KM 算法已经讲解的非常透彻了，我这里就稍微说说连边。

看到这个题目，你会发现两个人之间都有关系，即 `A` 对 `B` 有一个值，  `B` 对 `A` 也有一个值，而在以往做的时候可能只会出现 `A` 对 `B` 有一个值，因为 `A` 对 `B` 与 `B` 对 `A` 的值都是给定的，那么我们 **合并这两个值**，也就是题目中的 $p[i][j] \times q[j][i]$，那么 `A` 与 `B` 的连边的权值也就确定了，那么就可以跑 KM 算法啦。

```cpp

/*
1. 设置最大期望值
2. 利用匈牙利算法找增广路
3. 找到增广路，匹配成功，退出
4. 找不到，最小程度降低男生期望，提升女生期望
5. 继续回到(2)开始重复


val1[N]/val2[N]分别记录U集与V集点的点权（匹配期望值）

vis1[N]/vis2[N]分别记录每次寻找增广路过程中U集与V集点的访问情况

match[N]记录最终U集内点匹配到的在V集内点的编号

slack[N]记录匹配过程中，U集内任意点能够选择V集内任意点作为匹配对象所需要降低val（期望值）的最小值
*/

#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<map>
#include<queue>
#define int long long
using namespace std;
const int INF=0x3f3f3f3f3f;
const int N=550;
int n,m,match[N],pri[N];
bool vis2[N];
long long a[N][N];
long long fav[N][N],val1[N],val2[N],sla[N];

void bfs(int k){
	int x,y=0,z=0;
	memset(pri,0,sizeof(pri));
	memset(sla,INF,sizeof(sla));
 	match[0]=k;
	do{
		int d=INF;
		x=match[y];
		vis2[y]=true;
		for(int i=1;i<=n;i++){
			if(vis2[i]){
				continue;
			}
			if(sla[i]>val1[x]+val2[i]-fav[x][i]){
				sla[i]=val1[x]+val2[i]-fav[x][i];
				pri[i]=y;
			}
			if(sla[i]<d){
				d=sla[i];
				z=i;
			}
		}
		for(int i=0;i<=n;i++){
			if(vis2[i]){
				val1[match[i]]-=d;val2[i]+=d;
			}else{
				sla[i]-=d;
			}
		}
		y=z;
	}while(match[y]);
	while(y){
		match[y]=match[pri[y]];
		y=pri[y];
	}
}
int KM(){
	memset(match,0,sizeof(match));
	memset(val1,0,sizeof(val1));
	memset(val2,0,sizeof(val2));
	for(int i=1;i<=n;i++){
		memset(vis2,false,sizeof(vis2));
		bfs(i);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		res+=fav[match[i]][i];
	}
	return res;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int k;
			cin>>k;
			a[j][i]*=k;//记得这里的j与i是反的，因为枚举是正着枚举的
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			fav[i][j]=max(fav[i][j],a[i][j]);
		}
	}
	cout<<KM()<<endl;
}



```


---

## 作者：MyukiyoMekya (赞：3)

~~看到题打完标准的n!暴力后立刻想到了记搜~~

显然，我们可以固定男运动员的枚举顺序然后去枚举匹配哪个女运动员

可以码出一个基本的爆搜

```
bool vis[20];
inline void dfs(int dep,int sum){...};
```

vis 表示女运动员有没有被选择过，dfs里的dep指现在选到哪个男运动员了，sum表示目前的优势总和

噫，$n\le20$，这个vis貌似可以状压成一个int呢

那么我们把vis状压成一个mask扔到dfs里面去

```
inline void dfs(int dep,int sum,int mask){...};
```

好，现在这个dfs不需要借助任何外部数组，我们把sum去掉改成int返回值的dfs

```
inline int dfs(int dep,int mask){...};
```

剩下 dep 和 mask 两维，可以记忆化搜索了

时间复杂度 $O(n\times2^n)$，常数写小点就能过~

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
using namespace std;
template <class t> inline void read(t &s)
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
int p[25][25],q[25][25];
int f[20][(1<<20)+5];
int n,ans;
inline int dfs(int dep,int mask)
{
	if(dep>=n)
		return 0;
	if(~f[dep][mask])
		return f[dep][mask];
	f[dep][mask]=0;
	for(int i=0;i<n;++i)
		if(!(mask&(1<<i)))
			f[dep][mask]=max(f[dep][mask],dfs(dep+1,mask|(1<<i))+p[dep][i]*q[i][dep]);
	return f[dep][mask];
}
signed main(void)
{
	memset(f,-1,sizeof f);
	cin>>n;
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
			read(p[i][j]);
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
			read(q[i][j]);
	cout<<dfs(0,0)<<endl;
	return 0;
}
```



---

## 作者：daitouzero (赞：2)

这种数据范围这么小的好题，~~怎么能少了爆搜呢~~

一看 $n$ 小于等于 20，咱当即敲了纯爆搜一个，兴致冲冲交上去之后发现满屏黑色TLE

所以我们需要剪枝

很容易就可以想到一个可行性剪枝

假设 $n$ 为男运动员人数， $ans$ 为目前找到的最大竞赛优势

$pos$ 为安排到第 $pos$ 个男运动员，$sum$ 为当前已经安排的运动员的竞赛优势总和，

$\text{Maxgood}$ 数组存放的是从这个男运动员往后安排女运动员能获得的最大竞赛优势

则当 $sum + \text{Maxgood}(pos) \le ans$ 时就可以直接return剪枝啦

（因为你如果加上所有你后边人的最大竞赛优势还小于现有的最大竞赛优势总和 你就可以byebye了）


然后我们发现这个 $\text{Maxgood}$ 数组还完全可以在搜索前预处理掉( ⊙ o ⊙ )啊！

这么写一交就过了（~~说明加强的数据还是太水了~~ 逃）
剩下的看代码就行了吧

159ms 跑的还挺快(吸氧的话能到48ms)
[AC记录](https://www.luogu.com.cn/record/97069066)

AC代码如下

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#include<bitset>
#define X 20005
#define ll long long
#define maxn 100050
using namespace std;
inline int scan()//快读
{
	register int x = 0;
	register char c = getchar();
	bool f = 0;
	while (c < '0' || c > '9')c == '-' ? f = 1 : f, c = getchar();
	while (c >= '0' && c <= '9')x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return f ? -x : x;
}
inline void print(int k, char ch = 0) //没啥用的快写
{
	if (k < 0)k = -k, putchar('-');
	if (k >= 10)print(k / 10, 0);
	putchar(k % 10 + '0');
	if (ch)putchar(ch);
}
inline int Max(int a, int b) {return a > b ? a : b;} //快乐卡常
inline int Min(int a, int b) {return a < b ? a : b;}
int n, man[30][30], woman[30][30], pro[30][30], ans, mxnow, Maxgood[100];
// pro[i][j]存的是男运动员 i 和女运动员 j 配合时的竞赛优势
bitset<100>Mark;
inline void dfs(int pos, int sum)
{
	if (pos == n + 1)
	{
		ans = Max(ans, sum);
		return ;
	}

	if (sum + Maxgood[pos] <= ans) return ; // 剪枝

	for (int i = 1; i <= n; i++)
	{
		if (!Mark[i])
		{
			Mark[i] = 1;
			dfs(pos + 1, sum + pro[pos][i]);
			Mark[i] = 0;
		}
	}
}
int main()
{
	n = scan(); // 输入部分
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			man[i][j] = scan();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			pro[i][j] = scan();
			pro[i][j] *= man[j][i];
		}
	for (int i = 1; i <= n; i++) // Maxgood 数组的预处理
	{
		mxnow = 0;
		for (int j = i; j <= n; j++)
		{
			for (int k = 1; k <= n; k++)
				mxnow = Max(mxnow, pro[j][k]);
			Maxgood[i] += mxnow;
		}
	}
	dfs(1, 0);
	print(ans, '\n');
	return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

[可能有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p1559.html)

## 简要题意

给出 $n$ 个白色顶点，$n$ 个黑色顶点。白色顶点 $i$ 和黑色顶点 $j$ 之间的边的权为 $P_{i,j}\cdot Q_{j,i}$，求二分图最大权匹配。

## 思路

二分图最大权匹配，可以使用网络流（具体来说，是费用流）求解。如果学过最大流求二分图最大匹配，那么这篇题解是很容易看懂的。

首先，建立一个超级源点 $S$ 和超级汇点 $T$。对于白色顶点 $i$，连边 $(S,i,1,0)$。对于黑色顶点 $j$，连边 $(j,T,1,0)$。

然后对于白色顶点 $i$ 和黑色顶点 $j$，连边 $(i,j,1,P_{i,j}\cdot Q_{j,i})$。

由于求的是最大权匹配，我们需要以 $S$ 为源点，$T$ 为汇点，跑 **最大费用最大流**，所求得的代价就是答案。

由于边数 $m = n^2$，所以整体时间复杂度是 $O(n^3)$ 的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;


namespace MCMF{
    #define int long long
	struct edge{
		int nxt,to,cap,cost;
	} g[100005];
	int head[100005],ec=-1;
	void add(int from,int to,int cap,int cost){
		g[++ec].nxt=head[from];
		g[ec].to=to;
		g[ec].cap=cap;
		g[ec].cost=cost;
		head[from]=ec;
	}
	void add_edge(int from,int to,int cap,int cost){
		add(from,to,cap,cost);
		add(to,from,0,-cost);
	}
	queue<int> q;
	bool vis[100005];
	int flow[100005];
	int dis[100005];
	int pre[100005];
	int last[100005];
	bool spfa(int s,int t){
		memset(dis,0x8f,sizeof(dis));
		memset(flow,0x7f,sizeof(flow));
		memset(vis,0,sizeof(vis));
		q.push(s);
		vis[s]=1;
		dis[s]=0;
		pre[t]=-1;
		while(!q.empty()){
			int u=q.front();
			q.pop();
			vis[u]=0;
			for(int i=head[u];i!=-1;i=g[i].nxt){
				int v=g[i].to;
				if(g[i].cap>0 && dis[v]<dis[u]+g[i].cost){
					dis[v]=dis[u]+g[i].cost;
					pre[v]=u;
					last[v]=i;
					flow[v]=min(flow[u],g[i].cap);
					if(!vis[v]){
						vis[v]=1;
						q.push(v);
					}
				}
			}
		}
		return pre[t]!=-1;
	}
	
	pair<int,int> MCMF(int s,int t){
		int maxflow=0,mincost=0;
		while(spfa(s,t)){
			int now=t;
			maxflow+=flow[t];
			mincost+=flow[t]*dis[t];
			while(now!=s){
				g[last[now]].cap-=flow[t];
				g[last[now]^1].cap+=flow[t];
				now=pre[now];
			}
		}
		return make_pair(maxflow,mincost);
	}
	#undef int
}

int a[105][105][2];

signed main(){
	memset(MCMF::head,-1,sizeof(MCMF::head));
	MCMF::ec=-1;
	int n,m,s,t;
	cin>>n;
	s=0,t=n<<1|1;
	for(int sex=0;sex<=1;sex++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j][sex];
			}
		}
	}
	for(int i=1;i<=n;i++){
		MCMF::add_edge(s,i,1,0);
		MCMF::add_edge(i+n,t,1,0);
		for(int j=1;j<=n;j++){
			MCMF::add_edge(i,j+n,1,a[i][j][0]*a[j][i][1]);
		}
	}
	cout<<MCMF::MCMF(s,t).second<<'\n';
	return 0;
}
```


---

## 作者：Lance1ot (赞：2)

根据题目，我们很快能看出来，这是一个带权的二分图匹配问题。

二分图匹配，我们可以跑**[最大流](https://www.luogu.org/problemnew/show/P3376)
**

而带上权值呢？   就可以跑*最小费用最大流*233。

###### 啥?  不是求最大吗？   怎么可以跑最小费用？

其实是可以的。  对于最基础的最小费用最大流：每次求一条可以增广的最短路。然后增广。

而我们根据这个题，我们需要求得是最大，也就是最长路。    

我们就可以，将权值取负数，然后用SPFA跑最短路。

这样问题就迎刃而解了。（dij好像也可以，只不过我太vegetable，不会

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
struct node
{
	int point;
	int flow;
	int val;
	int nxt;	
}; 
node line[100000];//前项星
int head[100],tail=-1;
void add(int x,int y,int f,int v)
{
	line[++tail].point=y;
	line[tail].flow=f;
	line[tail].val=v;
	line[tail].nxt=head[x];
	head[x]=tail;
}//加边
int male[21][21];
int famale[21][21];//读入的数据，看数组名就可以了，不需要再解释了233
int max_cost;//最大的费用，就是答案
int flow[100],last[100],dis[100];//last是把每个点更新的边的编号
int pre[100];
bool inque[100];//SPFA找最短的增广路所需要的数组
bool SPFA(int begin,int end)
{
	queue<int>q;
	memset(dis,10,sizeof(dis));
	memset(flow,0,sizeof(flow));
	memset(inque,0,sizeof(inque));
	memset(pre,0,sizeof(pre));//初始化
	dis[begin]=0;pre[begin]=0;flow[begin]=0x7fffffff;//源点流量无限
	inque[begin]=true;q.push(begin);
	while(!q.empty())
	{
		int pas=q.front();	q.pop();
		inque[pas]=false;
		for(int i=head[pas];i!=-1;i=line[i].nxt)//遍历
			if(line[i].flow>0&&dis[line[i].point]>dis[pas]+line[i].val)//一定要判断是否可以增广
			{
				dis[line[i].point]=dis[pas]+line[i].val;//最短路
				last[line[i].point]=i;pre[line[i].point]=pas;//储存边的编号，以便后来更改
				flow[line[i].point]=min(flow[pas],line[i].flow);//流量更新,其实是不需要的，因为我们现在在做二分图匹配嘛
				if(!inque[line[i].point])
				{
					inque[line[i].point]=true;
					q.push(line[i].point);
				}
			}
	}
	if(!pre[end])	return false;//汇点是否到达
	return true;
}
void EK(int begin,int end)
{
	while(SPFA(begin,end))
	{
		int pas=end;
		max_cost+=dis[end]*flow[end]*-1;//因为我们取负存嘛，所以要倒回来
		while(pas!=begin)//从汇点到源点进行增广
		{
			line[last[pas]].flow-=flow[end];
			line[last[pas]^1].flow+=flow[end];//last就用上了
			pas=pre[pas];
		}
	}
	return ;
}
int main()
{
	int n;
	scanf("%d",&n);
	int len=n;
	for(int i=0;i<=(len<<1)+1;i++)	head[i]=-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&male[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&famale[i][j]);//初始化与输入
	for(int i=1;i<=n;i++)//建图，0为源点，n*2+1为汇点
	{
		add(0,i,1,0),add(i,0,0,0);
		add(len+i,(len<<1)+1,1,0),add((len<<1)+1,len+i,0,0);
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			add(i,len+j,1,male[i][j]*famale[j][i]*-1),add(len+j,i,0,male[i][j]*famale[j][i]);//记住取负
	EK(0,(len<<1)+1); 
	printf("%d",max_cost); 
}
```

---

## 作者：_ajthreac_ (赞：2)

### 宣传
[我的博客园](https://www.cnblogs.com/juruoajh/)
### 题解
[题目戳我](https://www.luogu.com.cn/problem/P1559)
#### 0.一些想说的话
布置的作业里有这道题，做完后发现题解好少……而且很多都是用了KM最佳匹配等我这种蒟蒻看不懂的算法，于是我就来写了这篇题解。如有雷同，纯属巧合。
#### 1.思路
做这道题的大家应该已经发现了：$1\leq n\leq 20$          
这种数据范围，不是状压就是爆搜。这里我们选择搜索解决本题（~~还不是因为状压不熟练~~）                 
#### 2.实现
既然是搜索，那么肯定有一个顺序。我选择的是枚举男的，搜女的。        
#### 3.剪枝&&细节
爆搜肯定是过不去的，我们考虑剪枝。         
这道题可以采用一种类似A\*的剪枝方式，令$h[i]$为第$i$个男运动员能匹配到的最大竞赛优势，在搜索函数内枚举，如果所有最大的加起来都不够之前得到的$ans$，那么就可以直接跳出了。
### 代码
前面的缺省源因为太长省略了，具体可以去我的博客里找
```cpp
#define N 30
int n,ans,p[N][N],q[N][N],h[N],vis[N];
//p,q:如题意所示 
//h:题解里提到的估价数组 
//vis:搜索用的 
void DFS(int now,int sum){
	//now:当前枚举到的男运动员 
	//sum:当前的总竞赛优势 
	if(now>n){//枚举完了 
		ans=max(ans,sum);
		return;
	}
	int hstar=0;
	for(rg int i=now;i<=n;i++){
		hstar+=h[i];
	}
	//如果之后的都取最大也达不到就返回 
	if(sum+hstar<ans)return;
	for(rg int i=1;i<=n;i++){
		if(!vis[i]){
			vis[i]=1;
			//枚举下一个，一定要注意顺序！ 
			DFS(now+1,sum+p[now][i]*q[i][now]);
			vis[i]=0;
		}
	}
}
int main(){
	//读入部分 
	Read(n);
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=n;j++){
			Read(p[i][j]);
		}
	}
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=n;j++){
			Read(q[i][j]);
		}
	}
	//提前算出h数组，计算方式如题解所说 
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=n;j++){
			h[i]=max(h[i],p[i][j]*q[j][i]);
		}
	}
	DFS(1,0);
	cout<<ans<<endl;//圆满结束 
	return 0;
}
```
本题解已同步至博客园

---

## 作者：glorious_dream (赞：1)

### 题目大意：

给定每一对男女之间的优势，求如何组合能让优势的总和最大。

### 算法描述：

首先可以看出来，这道题是一个带权的二分图匹配，$KM$ 算法的裸题。

[这个博客写的很好](https://www.cnblogs.com/wenruo/p/5264235.html)

先来用自己的话简单的说一下。

读入数据之后，需要把我们记录的数组先求好，也就是 $w[i][j]$ 表示 $i$ 女与 $j$ 男之间的优势，这个先处理好就可以。

然后说算法的核心。首先，需要先知道二分图最大匹配。

~~可以理解为中介帮你介绍房子的问题~~。给定两个集合，它们之间有一些边相连，但两个集合内部没有边相连，求最多能两个集合之间连多少条边。

著名的匈牙利算法！ 每次看能不能满足条件，更新匹配数。

[二分图最大匹配模板题](https://www.luogu.com.cn/problem/P3386)

```cpp
bool find(int x){
	for(re i(head[x]) ; i ; i=e[i].nxt){
		int v=e[i].to;
		if(!vis[v]){
			vis[v] = 1;
			if(!match[v]||find(match[v])){
				match[v]=x;
				return 1;
			}
		}
	}
	return 0;
}
```

------------

然后来说这道题，上面那位大佬的博客讲的我觉得很清楚，当然也很生动形象。

需要在匈牙利算法的基础上，更新每一个左面和右面的点的"期望"。

先从第一个女生能找到的最大的边开始，依次往下找，如果遇到某一个女生找不到自己的最大值，那么往回找，看看已经找过的女生能不能换一个男生，具体跟匈牙利算法类似。

如果都不行，那么记录一下这个女生希望的最大值，与能匹配到的最大值的差的最小值 $delta$，在下面的处理中，把这次搜索过的女生的期望都减去  $delta$，搜索过男生的期望都增加 $delta$，最后输出每一个 $w[match[i]][i]$ 的和即为最终答案。

注意要先把女生的期望赋值成最大的边，男生的期望赋值为 $0$。

最后就算出最好能匹配多少，详细的证明可以去问度娘(本人太菜不会)。

### 总代码：

```cpp
#include<bits/stdc++.h>
#define re register
#define inf INT_MAX
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
const int M = 100;
int zuo[M],you[M],w[M][M],a[M][M],b[M][M],match[M],vis1[M],vis2[M];
int n,delta;
bool check(int u){
	vis1[u] = 1;
	for(re int i(1) ; i<=n ; ++i){
		if(vis2[i]) continue;
		if(zuo[u]+you[i] == w[u][i]){
			vis2[i] = 1;
			if(!match[i] || check(match[i])){
				match[i] = u;
				return 1;
			}
		}
		else delta = min(delta,zuo[u]+you[i]-w[u][i]);
	}
	return 0;
}
inline void KM(){
	for(re int i(1) ; i<=n ; ++i){
		you[i] = 0,zuo[i] = -inf;
		for(re int j(1) ; j<=n ; ++j) zuo[i] = max(zuo[i],w[i][j]);
	}
	for(re int i(1) ; i<=n ; ++i){
		while(1){
			memset(vis1,0,sizeof(vis1));
			memset(vis2,0,sizeof(vis2));
			delta = inf;
			if(check(i)) break;
			for(re int j(1) ; j<=n ; ++j){
				if(vis1[j]) zuo[j]-=delta;
				if(vis2[j]) you[j]+=delta;
			}
		}
	}
	int ans=0;
	for(re int i(1) ; i<=n ; ++i) ans += w[match[i]][i];
	printf("%d",ans);
}
signed main(){
	n=read();
	for(re int i(1) ; i<=n ; ++i) for(re int j(1) ; j<=n ; ++j) a[i][j] = read();
	for(re int i(1) ; i<=n ; ++i) for(re int j(1) ; j<=n ; ++j) b[i][j] = read();
	for(re int i(1) ; i<=n ; ++i) for(re int j(1) ; j<=n ; ++j) w[i][j] = a[i][j]*b[j][i];
	KM();
	return 0;
}

```


---

## 作者：MeowScore (赞：1)

带权二分图匹配板子，适合练手。

但是我不会二分图相关算法，所以本题解使用费用流求解（逃）。

其实就是将 $n$ 个男生和 $n$ 个女生进行匹配，每对匹配都有一定的贡献，最后要使贡献最大，就是跑最大费用最大流。建立超级源点，记为 $0$ 号点，向每个男生连边（男生编号为 $1$ 到 $n$），容量为 $1$，费用为 $0$。建立超级汇点，记为 $2 \times n+1$ 号点，把每个女生向汇点连边，容量为 $1$，费用为 $0$。

再考虑男女生之间的连边。对于男生 $i$ 和女生 $j$，他们之间的边容量为 $1$，费用为 $P_{i,j} \times Q_{j,i}$。直接套板子就好了。

对于最大费用最大流，可以用~~某死了的算法~~ SPFA 跑最长路，也可以把费用全部取反，跑最小费用最大流，然后答案再取反。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n;
int s,t;
int P[100][100],Q[100][100];
int ans;
const int N=10010,INF=100000000;
int head[N],to[N*2],nex[N*2],f[N*2],e[N*2],cnt;
void addE(int x,int y,int z,int w){
	cnt++;
	e[cnt]=z;
	f[cnt]=w;
	to[cnt]=y;
	nex[cnt]=head[x];
	head[x]=cnt;
}
void add(int x,int y,int z,int w){
	addE(x,y,z,w);
	addE(y,x,0,-w);
}
int d[N],r[N],pre[N];
bool v[N];
bool bfs(){
	queue<int> q;
	q.push(s);
	memset(v,0,sizeof(v));
	memset(d,0xcf,sizeof(d));
	d[s]=0;
	v[s]=1;
	r[s]=INF;
	while(q.size()){
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i;i=nex[i]){
			int y=to[i];
			if(d[y]<d[x]+f[i]&&e[i]){
				d[y]=d[x]+f[i];
				pre[y]=i;
				r[y]=min(r[x],e[i]);
				if(!v[y]){
					v[y]=1;
					q.push(y);
				}
			}
		}
	}
	if(d[t]!=d[t+1])
		return 1;
	return 0; 
}
void update(){
	int x=t;
	while(x!=s){
		e[pre[x]]-=r[t];
		e[pre[x]^1]+=r[t];
		x=to[pre[x]^1];
	}
	ans+=r[t]*d[t];
}
void EK(){
	while(bfs())
		update();
}
int main(){
	cnt=1;
	cin>>n;
	s=0,t=2*n+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>P[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>Q[i][j];
	for(int i=1;i<=n;i++){
		add(s,i,1,0);
		add(i+n,t,1,0);
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			add(i,j+n,1,P[i][j]*Q[j][i]);
	EK();
	cout<<ans;
	return 0;
}
```

---

## 作者：wfycsw (赞：1)

- ## 审题
### $n<20$
显然深搜+剪枝即可。
首先输入加预处理，接着搜索寻找最优解
```cpp
#include<bits/stdc++.h>
#define RI register int
inline int read(){//快读
    RI s=0;char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
    return s;
}
inline void write(int x){//快输
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int n,ans,a[22][22],b[22][22],f[22];bool c[22];
inline int max(int x,int y){return x>y?x:y;}
inline void sch(int t,int x){
	if(t>n) ans=max(ans,x);//更新答案
	else{
		RI s=0;
		for(RI i=t;i<=n;i=-~i) s+=f[i];
		if(x+s<=ans) return;//剪枝
		for(RI i=1;i<=n;i=-~i)
			if(!c[i]){
				c[i]=1;
				sch(-~t,x+a[t][i]);
				c[i]=0;//回溯
			}	
	}		
	return;
}
int main(){
	n=read();
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=n;j=-~j)
			a[i][j]=read();
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=n;j=-~j)
			b[i][j]=read();
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=n;j=-~j)
			a[i][j]*=b[j][i];//乘积预处理
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=n;j=-~j)
			f[i]=max(f[i],a[i][j]);//局部最大值，搜索时剪枝用。
	sch(1,0);
   write(ans);
	return 0;
}
```
其实这题不需要用KM，只是一道爆搜水题。

---

## 作者：liz525 (赞：1)

~~蒟蒻的第一篇题解~~

~~数据有点弱，但这种题目不用KM怎么行呢【手动doge】~~

##  **进入正题**

推荐一篇很好的讲KM算法的文章 [别的大佬写的](https://www.cnblogs.com/wenruo/p/5264235.html)
（文章里配有匈牙利算法链接，可共同食用）

~~我才不会告诉你们我只是为了推荐这篇文章才交的题解~~

这道题几乎和这篇文章一模一样，我把变量名改了之后就更明显了

直接贴代码了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int maxn=25,maxb=0x3f3f3f3f;
int p[maxn][maxn],q[maxn][maxn],und[maxn][maxn],ex_man[maxn],ex_woman[maxn],match[maxn],slack[maxn],n;
bool vis_man[maxn],vis_woman[maxn];
bool dfs(int i){
	vis_woman[i]=true;
	for(int j=1;j<=n;j++){
		if(vis_man[j])
		    continue;
		int gap=ex_woman[i]+ex_man[j]-und[i][j];
		if(gap==0){
			vis_man[j]=true;
			if(match[j]==-1 || dfs(match[j])){
				match[j]=i;
				return true;
			}
		}
		else
		    slack[j]=min(slack[j],gap);
	}
	return false;
}
int KM(){
	for(int i=1;i<=n;i++){
		while(1){
    	    memset(vis_man,false,sizeof(vis_man));
    	    memset(vis_woman,false,sizeof(vis_woman));
    	    if(dfs(i)) break;
    	    int d=maxb;
    	    for(int j=1;j<=n;j++)
    	      if(!vis_man[j])
			      d=min(d,slack[j]);
    	    for(int j=1;j<=n;j++){
    	        if(vis_woman[j])
				    ex_woman[j]-=d;
                if(vis_man[j])
				    ex_man[j]+=d;
                else
				    slack[j]-=d;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	    ans+=und[match[i]][i];
	return ans;
}
int main(){
	memset(slack,maxb,sizeof(slack));
	memset(match,-1,sizeof(match));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	      scanf("%d",&p[i][j]);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	      scanf("%d",&q[i][j]);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	      und[i][j]=q[i][j]*p[j][i];
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	      ex_man[i]=max(ex_man[i],p[i][j]);
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	      ex_woman[i]=max(ex_woman[i],q[i][j]);
	printf("%d",KM());
	return 0;
}
```
**码字不易，请勿抄袭**

---

## 作者：好雨天堂 (赞：1)

男运动员位置不动, 女运动员全排列, 回溯搜索最优值 
解空间是n的全排列, 所以选择排列树作为解空间结构. 
变量设计: 当前得分cw, 最佳得分maxValue, x[1:n]女运动员的排列 
定义函数 f(i,m) = maxj=m+1n P[i][x[j]]*Q[x[j]][i], 其中i>m, 
是在前m位男运动员已配对的情况下, 男运动员i配对其她女运动员的上界 
定义函数 Upb(m) = f(m+1,m)+f(m+2,m)+…+f(n,m). 
当前m位男运动员已配对的情况下, cw+Upb(m)是余下情况配对的上界, 
由此可以设计剪枝(限制)条件 cw+Upb(m) > maxValue

```
#include<cstdio>  
#include<cstring>  
#include<climits>  
#include<algorithm>  
#include<stdio.h>
#include<iostream>
#define INF 0x7ffffff
using namespace std;
#define maxn 22
int n;
int p[maxn][maxn];
int q[maxn][maxn];
int x[maxn];
int cw;
int maxValue = 0;

/*
定义函数 f(i,m) = maxj=m+1n P[i][x[j]]*Q[x[j]][i], 其中i>m,
是在前m位男运动员已配对的情况下, 男运动员i配对其她女运动员的上界

*/
int f(int i, int m)
{
	int ans = 0;
	for (int j = m+1; j <= n; j++)
		ans = max(ans,p[i][x[j]]*q[x[j]][i]);
	return ans;
}
/*
定义函数 Upb(m) = f(m+1,m)+f(m+2,m)+…+f(n,m).
当前m位男运动员已配对的情况下, cs+Upb(m)是余下情况配对的上界,
由此可以设计剪枝(限制)条件 cs+Upb(m) > maxValue

*/
int Upb(int m)
{
	int sum = 0;
	for (int i = m+1 ; i <= n; i++)
		sum += f(i, m);
	return sum;
}
void backTrack(int t) {
	if (t > n) 
	{
		maxValue = max(maxValue, cw);
		return;
	}

		for (int i = t; i <= n; i++) 
		{ 
			swap(x[i], x[t]); 
			cw += p[t][x[t]]*q[x[t]][t];
			if (cw + Upb(t) > maxValue)
			{
				backTrack(t + 1);
			}
			cw -= p[t][x[t]] * q[x[t]][t]; //回溯 
			swap(x[t], x[i]);
		}
	
}
int main()
{ 
	cin >> n;
		for (int i = 1; i <= n; i++) 
		{
			for (int j = 1; j <= n; j++) 
			{
				scanf("%d", &p[i][j]); 
			}
		}
		for (int i = 1; i <= n; i++) 
		{
			for (int j = 1; j <= n; j++) 
			{
				scanf("%d", &q[i][j]);  
			}
		}
		for (int i = 1; i <= n; i++)
			x[i] = i;
		backTrack(1);
		printf("%d\n", maxValue); 
		return 0;
}
```


---

## 作者：BFSDFS123 (赞：0)

容易发现，这道题 $P_{i,j}$ 和 $Q_{i,j}$ 的具体数值我们是不关心的。因为选了一对 $(i,j)$，其必不会选择其他的人。我们只关心 $P_{i,j}\times Q_{j,i}$，即第 $i$ 个男的和第 $j$ 个女的一起打球的竞赛优势。

将所有人视为 $2n$ 个节点，其中 $n$ 个为男性，$n$ 个为女性。

我们将每一个男性向每一个女性连边，边权是一起打球的竞赛优势。

题目要求所有人都要匹配上，并使总和最大。容易发现，这是一个[二分图最大权完美匹配](https://www.luogu.com.cn/problem/P6577)。

我们使用 KM 算法就可以解决这个问题。

KM 算法有 $O(n^3)$ 和 $O(n^4)$ 的两种做法，分别是由 bfs 和 dfs 实现的。这道题由于 $n \le 20$，所以我们采用 $O(n^4)$ 的写法。

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define eps 1e-8
const int inf=1e18;
const int Maxn=510;
const int Maxm=3e5+10;
int edge[Maxn][Maxn]; //邻接矩阵 
int visl[Maxn],visr[Maxn]; //访问标记 
int bl[Maxn],br[Maxn]; //标号 
int rmatch[Maxn];
int delta; //标号改变的数量 
int head[Maxn],tot;
struct Edge{
	int to;
	int nxt;
}E[Maxm<<1];
int n,m;
void addedge(int u,int v)
{
	tot++;
	E[tot].to=v;
	E[tot].nxt=head[u];
	head[u]=tot;
}
bool dfs(int u)
{
	visl[u]=1;
	for(int v=1;v<=n;v++)
	{
		if(visr[v])
		{
			continue;
		}
//		cout<<"v:"<<v<<endl;
		if(bl[u]+br[v]==edge[u][v])
		{
			visr[v]=true;
			if(rmatch[v]==-1 || dfs(rmatch[v]))
			{
				rmatch[v]=u;
				return true;
			}
		}else{
			delta=min(delta,(bl[u]+br[v])-edge[u][v]);
//			printf("G:%d %d\n",u,v);
		}
	}
	return false;
}
int km()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			bl[i]=max(bl[i],edge[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
//		cout<<"i:"<<i<<endl;
		while(1)
		{
			memset(visl,0,sizeof(visl));
			memset(visr,0,sizeof(visr));
			delta=inf;
			if(dfs(i))
			{
				break;
			}
			for(int j=1;j<=n;j++)
			{
				if(visl[j])
				{
					bl[j]-=delta;
				}
				if(visr[j])
				{
					br[j]+=delta;
				}
			}
//			cout<<"delta="<<delta<<endl;
		}
//		for(int i=1;i<=n;i++)
//		{
//			cout<<rmatch[i]<<" "; 
//		}
//		cout<<endl;
//		for(int i=1;i<=n;i++)
//		{
//			printf("%d %d\n",bl[i],br[i]);
//		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=edge[rmatch[i]][i];
	}
	return ans;
}
int a[Maxn][Maxn],b[Maxn][Maxn];
signed main()
{
	memset(rmatch,-1,sizeof(rmatch));
	memset(edge,-0x3f,sizeof(edge));
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&b[i][j]);
		}
	}
	
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			edge[i][j]=a[i][j]*b[j][i]; //计算竞赛优势
		}
	}
	printf("%lld\n",km());
	return 0;
}


```

---

## 作者：Rmax (赞：0)

本篇使用 $\text{KM}$ 算法求解。

对于 $\text{KM}$ 算法

步骤如下：

首先要用邻接矩阵存二分图，然后用贪心算法初始化标杆，运用匈牙利算法找到完美匹配，如果找不到则修改标杆增加一些边。重复以上步骤直到找到完美匹配。

标杆分为 $X$ 标杆和 $Y$ 标杆，一般把比较少的点放在 $X$ 标杆一侧。

首先要初始化两个标杆分别为 $X$ 标杆和 $Y$ 标杆，$X$ 标杆初始化为与之相连的最大边权，$Y$ 标杆初始化为 $0$，且直接加入拥有最大边权的边。如果发现此时的匹配就是完美匹配，那么就直接退出，否则进行标杆的更改。从第一个节点开始扫描，如果有合法的增广路，那么将其反选，扩充路径，如果该节点没有合法的增广路，那么则将增广路上的所有的 $X$ 标杆上的点加入点集 $S$,将 $Y$ 标杆上的所有点加入点集 $T$，从 $S$ 和不在 $T$ 集合中的点里面，计算  $d=\min \left \{ L(x)+L(y)-w(x,y) \right \}$ 计算后，将在 $S$ 点集内 $x$ 的顶标减 $d$，在 $T$ 的顶标加 $d$。并将目前没有加入二分图的权值和等于顶标和的边作为未匹配边加入到二分图中，然后再在该节点寻找增广路，如果还是没有，则再次通过更改标杆来增加边，直到有增广路出现为止。之后重复寻找增广路的步骤以及更改标杆的步骤，如果出现了完美匹配就直接退出。

本人的一点人话解释：

$\text{KM}$ 算法一般用于解决寻找最优匹配的问题，是基于匈牙利算法的一种算法，和匈牙利相比，他多了个左右期望值。

左期望值的初值为它所连接的边的最大边权，右期望值的初值为 0 。如果左右期望值加起来的值等于边权的话，即匹配成功，否则不匹配，匹配失败的话我们需要 dfs 找出最小的能使其匹配成功的期望值，并将参与 dfs 的左期望值减去搜到的值，右期望值加上搜到的值并继续匹配。（没看明白的话请看下面大佬的博客理解吧，$lz$ 水平实在有限 $QAQ$ ）。

$\text{KM}$ 算法详解，请点[这里](https://www.cnblogs.com/wenruo/p/5264235.html "这里")，同时内附匈牙利算法链接。
### 本题思路
我们可以将 $i$ 号男运动员与 $j$ 号女运动员匹配所得到的竞赛优势 $P[i][j]\times Q[j][i]$ （如果你不知道为什么是 $Q[j][i]$ 的话请仔细看题），只需要将他们的优势用邻接矩阵存起来在跑 $\text{KM}$ 即可。（代码附详细注释）

$Code$
~~~
#include<bits/stdc++.h>
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#define gc getchar
#include<algorithm>
#define reg register
#define ll long long
//#define int long long
using namespace std;
const int M=25;
const int N=1e5+5;
const int mod=998244353;
//const int INF = 0x3f3f3f3f;为了防止ctrl将这里注释掉了
inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline int read() { int res = 0, f = 0; char ch = gc();for (; !isdigit(ch); ch = gc()) f |= (ch == '-'); for (; isdigit(ch); ch = gc()) res = (res << 1) + (res << 3) + (ch ^ '0'); return f ? -res : res;}

int n,w,ans,mini;
int p[M],vis1[M],vis2[M],L[M],R[M],a[M][M]; 
//p数组记录匹配对象，vis1vis2分别标记左右部分的点，LR是左右期望值，a是处理边权的 
inline int dfs(int u)//dfs匹配左右点 
{
    vis1[u]=1;//标记左半部分的点已经连接 
    for(reg int i=1;i<=n;i++)//遍历 
    {
        if(!vis2[i])//如果右半部分的点没有被访问过 
        {
            int x=L[u]+R[i]-a[u][i];//计算期望值和好感度的差 
            if(x==0)//如果结果为0，即期望值等于好感度 
            {
                vis2[i]=1;//标记右节点 
                if(!p[i] || dfs(p[i]))//如果当前点没有与之匹配的点或者当前点所匹配的点还可与其他节点相匹配 
                {
                    p[i]=u;//匹配成功 
                    return 1;//返回成功 
                }
            }
            else if(x>0)//如果期望值不等于好感值，则记录最小的差 
            mini=min(mini,x); 
        }
    }
    return 0;//匹配失败 
}

inline void KM()
{
    for(reg int i=1;i<=n;i++)
    {
        while(1)
        {
            mini=INF;//重置最小值 
            memset(vis1,0,sizeof(vis1));
            memset(vis2,0,sizeof(vis2));//重置vis数组 
            if(dfs(i)) break;//匹配成功了就退出 
            for(reg int j=1;j<=n;j++) if(vis1[j]) L[j]-=mini;//左期望值减去最小值 
            for(reg int j=1;j<=n;j++) if(vis2[j]) R[j]+=mini;//右期望值加上最小值 
        }
    }
}

signed main()
{
    n=read();
    for(reg int i=1;i<=n;i++)
        for (reg int j=1;j<=n;j++)        
            a[i][j]=read();//输入 
    for(reg int i=1;i<=n;i++)
        for(reg int j=1;j<=n;j++)
            w=read(),a[j][i]*=w; //求出边权 
    for(reg int i=1;i<=n;i++)
        for(reg int j=1;j<=n;j++)
            L[i]=max(a[i][j],L[i]);//求出左期望值 
    KM();//跑一遍KM算法 
    for(reg int i=1;i<=n;i++)
    ans+=a[p[i]][i];//累加答案 
    printf("%d",ans);
    return 0;
}
~~~

---

## 作者：Doqin07 (赞：0)

## $n\le20 !!!$
#### 那么我们直接暴搜咯
- ##### 枚举$1-n$所有的男运动员，再把还没有匹配过的女运动员看一遍，一定要回溯。
- ##### 但是这样复杂度是$O(20)$，很显然会T。那么这时候我们就需要剪枝了。
- ##### 我们可以记录每一行男，女运动员匹配的最大值，之后做一个前缀和（不知道前缀和请自行百度），假如搜索当前的优势加上后面最大优势都没有当前的答案优越，那么就直接放弃搜索，因为不可能会出现更优的解。
#### 代码：
```cpp
/*
    Coder:DongYinuo
    Luogu:P1559
    Date:2020.1.4
*/
#include <bits/stdc++.h>
using namespace std;
namespace I_love{
    typedef long long ll;
    const int maxn=10005;
    const int N=35;
    const int mod=1e9+7;
    #define F(i,l,r) for (int i=l;i<=r;++i)
    #define REP(i,r,l) for (int i=r;i>=l;--i)
    #define mem(a,b) memset(a,b,sizeof(a));
    #define MP make_pair
    #define PB push_back
    #define PII pair<int,int>
    #define PLL pair<ll,ll>
    #define all(a) a.begin(),a.end()
    #define lson index*2
    #define rson index*2+1
    int I(){char c;int x=0,f=1;while(c=getchar()){if(c=='-')f=-1;if(isdigit(c))break;}while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();return x*f;}
    template <typename T>void Rd(T& arg){arg=I();}
    template <typename T,typename...Types>void Rd(T& arg,Types&...args){arg=I();Rd(args...);}
    // 以上为宏定义，正片开始qwq
    int n,a[N][N],b[N][N],vis[N],sum[N],ans=-INT_MAX;
    void dfs(int x,int k){
        if(x>n){
            ans=max(ans,k);
            return;
        } // 每次搜完更新最大值
        if(k+(sum[n]-sum[x-1])<=ans){
            return;
        } // 剪枝优化
        F(i,1,n){
            if(!vis[i]){
                vis[i]=true;
                dfs(x+1,k+a[x][i]*b[i][x]);
                vis[i]=false;
                // 回溯
            }
        }
    }
    void input(){
        Rd(n);
        F(i,1,n){
            F(j,1,n){
                Rd(a[i][j]);
            }
        }
        F(i,1,n){
            F(j,1,n){
                Rd(b[i][j]);
            }
        }
        F(i,1,n){
            int tmp=-INT_MAX;
            F(j,1,n){
                tmp=max(tmp,a[i][j]*b[j][i]);
            }
            sum[i]=tmp;
        } // 记录这一行的匹配的最大值
        F(i,1,n){
            sum[i]+=sum[i-1];
        } // 做前缀和
    }
    void run(){
        dfs(1,0);
        printf("%d\n",ans);
    }
    void OI_Akame(){
        input();
        run();
    }
}
int main(){
#ifdef LOCAL
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
#endif
    I_love::OI_Akame();
    // I love アカメ！
    return 0;
}
```
-------
ありがとうございます。

---


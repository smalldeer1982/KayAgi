# [AHOI2012] 铁盘整理

## 题目描述

在训练中，一些臂力训练器材是少不了的，小龙在练习的时候发现举重器械上的铁盘放置的非常混乱，并没有按照从轻到重的顺序摆放，这样非常不利于循序渐进的锻炼。他打算利用一个非常省力气的办法来整理这些铁盘，即每次都拿起最上面的若干个圆盘并利用器械的力量上下翻转，这样翻转若干次以后，铁盘将会按照从小到大的顺序排列好。那么你能不能帮小龙确定，最少翻转几次就可以使铁盘按从小到大排序呢？

例如：下面的铁盘经过如图所示的以下几个步骤的翻转后变为从小到大排列。

![](https://cdn.luogu.com.cn/upload/image_hosting/xtpst1lw.png)

## 样例 #1

### 输入

```
5
2 4 3 5 1```

### 输出

```
5```

# 题解

## 作者：NKU_AI_HMX (赞：73)

写在前面：管理大大审核辛苦了，这篇题解代码吸氧26ms左右。
## 目录
1. 看完本篇题解你能收获什么？
2. 对萌新介绍啥是 $ A^{* } $，$ IDA^{* } $。 
3. 怎么想到这个估价函数的？没有其他的了吗？
4. 一些其他题解没有的小优化（对这题影响不大）。


------------
## 正文
#### 1. 看完本篇题解你能收获什么？
如果您和我一样是萌新呢？可以了解什么是 $ A^{* } $，$ IDA^{* } $，并且文后笔者会推荐几道题给您练习，并且除此之外，可以和笔者交流这题的思路，或者说思考过程，虽然说结论很简单，但是我相信，如果完全独立地，并且在一定时间内得出来还是不易的。

如果您是大佬，过来简单看看代码，建议您直接跳至第四点，或者代码框。


------------
#### 2. 啥是 $ A^{* } $，$ IDA^{* } $
因为关于 $ A^{* } $，$ IDA^{* } $ 的介绍网络上已经很多了，笔者在这就用自己的语言，加以自己的理解来介绍一下这两种算法。

相信来大家一定都很熟悉搜索， $DFS$， $BFS$。一个一搜到底，一个一层层搜过去。但无疑这两种搜索方式都是地毯式搜索，不管长啥样都搜，这样 就会带来一些问题，数据很大的时候这样搜就会面临爆时间和内存的问题，所以我们搜索的时候应该有一些判断标准，稍微带一点智力地搜，不能一股脑的随意搜。

其实这就像我们找东西，家里落了一个东西，不知道在哪，我们又不记得上 次放哪了。我们就要找它，我们一定不会先把床移开，看看是不是在床下， 或者首先到你家布满灰尘的储物间去找。我们会先找那些更可能的地方，比 如桌子上？书下面？等等。而你之所以做出这样的选择就是基于我们自己的“判断函数”，只不过这个判断函数不单单和可能性相关，但可能性一定是我们判断的重要因素。

所以 $ A^{* } $，$ IDA^{* } $ 实际上分别是 $BFS$， $DFS$ 的“升级版”。前者用一个优先队列（或者其他的结构）存储准备搜索的点，而队列中排序的标准正是我们用评估函数赋予的某一个点的值，所以我们每次搜索新的点时选择的都是队列中 $key$ 值最大的那个，这样让我们可以更容易更快搜索到我们的目标点。而后者是 $DFS$ 的“升级版”我们知道 $DFS$ 不搜到底不知道回头，这样我们虽然达到了深度，但是广度是远远不够的，所以我们就人为给他设置了一个深度，并且同样加了一个估价函数，如下

```cpp
int evaluate()
{
	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		if (abs(a[i] - a[i + 1]) != 1)cnt++;
	}
	return cnt;
}
```
以上是这一题用到的估价函数，这个函数是我们预估从当前状态走到末状态最少需要多少步（注意！我们的估价函数得出的步数一定要小于等于实际最小步数，因为我们如果估计小了，无非多搜索一些点，但是估计大了那就会遗失很多情况，很可能就导致了错误答案。）我们得到函数以后，我们每到一个点就估计当前状态到最终状态还剩的最少步数，如果当前已经走的步数 $step$ 加上估计还需步数 $evaluate$ 大于我们限定的最大搜索步数 $maxstep$ 我们就直接不搜这个点，直接返回，这样我们就可以节省很多时间，而最大步数 $maxstep$ 我们如何确定呢？我们通常从0一直递增遍历给 $maxstep$ 赋值，对每个 $maxstep$ 都一样的搜索，直到搜到为止，所以我们其实会发现所谓的 $ IDA^{* } $ 其实是每次 $maxstep$ 递增时我们搜索的范围是逐层递增的，可以理解为，每次都比上个 $maxstep$ 值时多搜索的一层。所以我们会在其中发现 $BFS$ 的影子，所以并不难理解不对吗？

#### 那么这两个算法难在哪里呢？
#### 答案是：估价函数的确定


------------

这里给大家拓展一下思维，其实大家会发现估价函数的确定是一件很玄乎的事儿，没有一个定式，靠感觉，或者经验，而且对于有些估价函数你并不好确定它和理想估价函数是不是有相同趋势，可以理解为：我们不好判断这个估价函数是不是在所有情况下都很好。而正是它这玄乎的一点让它有了“智能”，因为它可以选择性搜索，而不完全是盲目的了。

人工智能算法里面一个很重要的领域是强化学习，其实我们会发现它的一套体系最开始也是基于一个类似估值函数的东西，只不过它会在每次和环境交互之后根据结果来反向传播，修改原有参数，让这个函数更加贴近理想函数。而慢慢的单一函数的局限性也就成为了人工智能发展的一个瓶颈，所以我们后来就创造了神经网络，我们可以理解其为很多层很多个估值函数的组合，最后我们也会根据环境的反馈反向传播，修改各个神经元的数值，也就是修改估值函数的参数（了解泰勒展开的同学应该知道基本上所有函数都可以用多项式表示，只不过系数不同而已，这也就给了神经网络一个极其复杂的“估值函数”）



------------
#### 3. 怎么想到这个估价函数的？

我们回到这道题，因为这道题的估值函数题解也都是一样的，大家也都讲的比较清楚了（不清楚的话，欢迎评论留言，可以探讨）笔者这里就讲讲笔者的思路。

 1.套用其他题思路，直接算当前状态到理想状态的“距离”

这种做法在八数码问题里面确实有用，但是在这里我们需要发现我们每一步的操作会影响很多盘的实际位置，那么我们把每个盘子单独拿出来分析就显得有些困难了，所以我们要转换思路，找到每次状态改变的不变量！盘子之间的相对位置关系。

 2.算单调序列的个数

这是我最开始的想法，但是用这个的话必然是会 $TLE$ 几个点
举个例子：12365这个序列有两个单调序列，如果看作连续函数的话也就是一个极点也就是123递增，但是65递减，这样的话我们必然需要反转至少一次，如果序列是124365，12递增43递减，65递增，我们为了所有序列构成123456单调递增序列我们就至少反转2次（两个极点）。以此类推，但是这样操作不够优。于是我就从这里出发想到了大家的那种函数。（个人觉得这个函数的选取还是挺需要经验的。）


------------

#### 4. 一些其他题解没有的小优化
1.
```cpp
if (i == x||abs(a[i+1]-a[i])==1)continue;//这里比其他题解多了一句abs(a[i+1]-a[i])==1
		
```
因为我们不会在两个已经完美排序的两个盘子间断开，可以把他们看作一个整体了要转动就一起转，所以多加了一个判断。


2.
```cpp
temp = eva;
		reverse(a+ 1, a + i + 1);
		if (abs(a[i] - a[i + 1]) == 1)  temp = eva - 1;
```
这里避免了每次都调用一次估值函数来估值，直接找到两层递归间估值函数的联系做转移（能省点时间是一点）。

3.
```cpp
if (temp + step <= maxstep)
		{
			 dfs(i, temp,step + 1);if (d) return;
		}
```

找到以后立马就返回别再搜了（这个其他题解里面好像也有）

直接给大家上代码吧
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char ch1;
template<class T>
inline void rd(T& x) {
	x = 0; bool w = 0;
	ch1 = getchar();
	while (!isdigit(ch1)) { ch1 == '-' && (w = 1), ch1 = getchar(); }
	while (isdigit(ch1)) { x = (x << 1) + (x << 3) + (ch1 & 15), ch1 = getchar(); }
	w && (x = (~x) + 1);
}
template<class T>
inline void wr(T x)
{
	if (x < 0) x = -x, putchar('-');
	if (x < 10) {
		putchar(x + 48);
		return;
	}
	T L = x / 10;
	wr(L);
	putchar(x - ((L << 1) + (L << 3)) + 48);
}

int n,a[20],b[20],maxstep;
bool d;
int evaluate()//估值函数
{
	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		if (abs(a[i] - a[i + 1]) != 1)cnt++;
	}
	return cnt;
}
void dfs(int x,int eva,int step)
{
	if (step == maxstep)//达到最大步数就返回
	{
		if (!eva)d = 1;
		return;
	}


	int temp;
	for (int i = 2; i<=n; i++)
	{
		if (i == x||abs(a[i+1]-a[i])==1)continue;//这里比其他题解多了一句abs(a[i+1]-a[i])==1，因为我们不会在两个已经完美排序的两个盘子间断开，可以把他们看作一个整体了
		
		temp = eva;
		reverse(a+ 1, a + i + 1);
		if (abs(a[i] - a[i + 1]) == 1)  temp = eva - 1; 
		
		if (temp + step <= maxstep)
		{
			 dfs(i, temp,step + 1);if (d) return;
		}
		
		reverse(a+ 1, a + i + 1); 
	}
}

int main()
{
	rd(n);
	for (int i = 1; i <= n; i++)
	{
		rd(a[i]);
		b[i] = a[i];
	}
	a[n + 1]= n + 1;//方便估值函数操作，如果不判断最后一个盘的话会TLE一个点

	
	sort(b + 1, b + n + 1);
	for (int i = 1; i <= n; ++i)
		a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;//离散化
	
	
	for (maxstep = 0;; maxstep++)
	{
		dfs(1, evaluate(), 0);
		if (d) { cout << maxstep; return 0; }
	}
	
}
/*
自己造的数据：
11
6 5 3 7 9 8 1 4 2 10 11
答案：8
13
7 4 5 3 9 6 2 8 1 10 13 11 12
答案：13
*/
```


------------
#### 推荐题目：[骑士精神](https://www.luogu.com.cn/problem/P5195)    [八数码难题](https://www.luogu.com.cn/problem/P1379)

太久没写洛谷了，橙名都蓝了┬＿┬

---

## 作者：Heartlessly (赞：32)

## Description

给定一个长度为 $n$ 互不相同的序列 $a_i$，每次操作可以将第 $1 \sim i\ (1 \leq i \leq n)$ 个数翻转，求最少几次操作可以使它变成升序数列。$(1 \leq n \leq 50, 1 \leq a_i \leq 100)$

## Solution

考虑 $\rm IDA^*$ 。

先离散化，保证最后得到的数列为 $1,2,3, \ldots, n$ 。

本题中的 **最完美估价**：

```cpp
a[n + 1] = n + 1;

inline int h() {
    int cnt = 0;
    for (int i = 1; i <= n; ++i)
        cnt += abs(a[i] - a[i + 1]) != 1;
    return cnt;
}
```

显然一次翻转最多只能改变一对相邻数的差（比如翻转第 $1 \sim 3$ 个数只能改变第 $3$ 个数与第 $4$ 个数的差）。因此对于一个序列，有多少对相邻的数差不为 $1$，就至少要翻转多少次。不要忘记把第 $n + 1$ 个数设为 $n + 1$，因为如果翻转第 $1 \sim n$ 个数，我们也可以认为改变了第 $n$ 个数与第 $n + 1$ 个数的差。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 50;
int n, a[MAXN + 5], b[MAXN + 5];
bool sol;

inline int h() {//最完美估价 
    int cnt = 0;
    for (int i = 1; i <= n; ++i)
        cnt += abs(a[i] - a[i + 1]) != 1;
    return cnt;
}

void dfs(int g, int f, int pre) {
    if (sol || g + h() > f) return;//预估步数
    if (!h()) {
        sol = 1;//找到答案 
        return;
    }
    for (int i = 1; i <= n; ++i) {
        if (i == pre) continue;//保证不与上一次翻转的长度相同 
        reverse(a + 1, a + i + 1);//翻转 
        dfs(g + 1, f, i);
        reverse(a + 1, a + i + 1);//回溯 
    }
}

int main() {
    read(n);
    for (int i = 1; i <= n; ++i) {
        read(a[i]);
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    for (int i = 1; i <= n; ++i)
        a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;//离散化 
    a[n + 1] = n + 1;
    for (int i = 0; ; ++i) {//迭代加深 
        sol = 0;
        dfs(0, i, 0);
        if (sol) {
            write(i);
            putchar('\n');
            break;
        }
    }
    return 0;
}
```



---

## 作者：George1123 (赞：15)

**广告：[blog$\clubsuit$](https://www.luogu.com.cn/blog/Wendigo/)**

[P2534 【\[AHOI2012\]铁盘整理】](https://www.luogu.com.cn/problem/P2534)

### 此题算法：DFS $+$ IDA*

**$IDA*$ 的题目，总是能 $WA \& TLE$ 一整面。**

看到 $1\le R[i]\le 100$ 就先离散化一下，使 $1\le R[i]\le n$。

当 $n=7$ 时：

```cpp
1 2 3 4 5 6 7 //0 step ①

7 6 5 4 3 2 1 //1 step ②

4 3 2 1 5 6 7 //1 step ③

4 3 1 2 5 6 7 //2 step ④
```

于是想到可以用两种因数来估价：

由 ① ③ ④ 得

**1.有多少对相邻两个数差不为 $1$。**

由 ① ② 得

**2.两边的数是否不为 $1$ 与 $n$。**

简化：$R[0]=0,R[n+1]=n+1$。

**※此时有多少对相邻两个数差不为 $1$（包含 1 与 2）。**

**即 $ExpectStep=\sum_{i=0}^n(abs(R[i+1]-R[i])!=1)$。**

于是有了相对估价函数，但不能估算还有几步能完成。

设现在我们已经求出了 $ExpectStep$，我们可以得知与两边方向相反的区间数为 $\frac{ExpectStep}{2}$，而每个与两边方向相反的区间 $[l,r]$ 需要至少两步（翻转 $[1,r]$，翻转 $[1,l]$）才能正过来，除了 $l=1$ 时，只需一步即可解决两个 $ExpectStep$。**所以真正需要的步骤至少为 $\frac{ExpectStep-2}{2}\times 2+1=ExpectStep-1$。**

有了这些，就可以开始码了！

## 以下是代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,b,a) for(int i=b;i>=a;i--)
int d(){int x;scanf("%d",&x);return x;}
const int N=20;
void flip(int*s,int l,int r){ //翻转区间
	int mid=(l+r)>>1;
	fo(i,l,mid) swap(s[i],s[r+l-i]);
}
int fix(int*s,int l,int r){ //修改区间翻转后的ExpectStep
	return (abs(s[l]-s[r+1])!=1)+(abs(s[l-1]-s[r])!=1)
		-(abs(s[l]-s[l-1])!=1)-(abs(s[r]-s[r+1])!=1);
}
int n,a[N],b[N],ans;
void dfs(int x,int y,int ex){
//x为已经走的步数，[1,y]为上次翻转的区间，ex即ExpectStep
	if(x+ex-1>=ans) return; //拿期望步骤剪枝
	if(!ex){ans=min(ans,x);return;} //已经翻好
	fo(i,2,n){ if(i==y) continue; //剪枝
		int toex=ex+fix(a,1,i); //递推ExpectStep
		flip(a,1,i); //翻转
		dfs(x+1,i,toex); //递归
		flip(a,1,i); //回溯
	}
}
int main(){
	n=d(),ans=n*2-2; //步骤最多为2*n-2（自己去推式）
	fo(i,1,n) b[i]=a[i]=d();
	sort(b+1,b+n+1),a[0]=0,a[n+1]=n+1;
	fo(i,1,n) a[i]=lower_bound(b+1,b+n+1,a[i])-b; //离散化
	int expect=0;
	fo(i,1,n+1) expect+=(abs(a[i]-a[i-1])!=1); //得出初始ExpectStep
	dfs(0,0,expect);
	printf("%d\n",ans);
	return 0;
}
```

如果我的题解对你有帮助，就点个**赞**吧！

谢谢大家！！


---

## 作者：huangdu233 (赞：10)

可以用 IDA* 做

预设上界为 2*n-2,用当前最优解不断更新，超过上限直接剪枝；

预估函数为当前不该相邻却相邻的数的个数
【代码】
```
#include<bits/stdc++.h>
using namespace std;
int a[52],num[101],f,sum,ans,n;
inline void dfs(){
    if(sum+f>=ans) return;//剪枝
    if(!f&&a[1]==1){ans=sum;return;}//跟新上界
    for(int i=2;i<=n;++i){
        if(i!=n) f+=(abs(a[1]-a[1+i])!=1)-(abs(a[i+1]-a[i])!=1);
        for(int j=1;j<i+1-j;++j)
            swap(a[j],a[i+1-j]);
        sum++;
        dfs();
        sum--;
        for(int j=1;j<i+1-j;++j)
            swap(a[j],a[i+1-j]);
        if(i!=n) f-=(abs(a[1+i]-a[1])!=1)-(abs(a[i+1]-a[i])!=1);
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){scanf("%d",&a[i]);num[a[i]]++;}
    for(int i=1;i<=100;++i) num[i]+=num[i-1];
    for(int i=1;i<=n;++i) a[i]=num[a[i]];
    ans=2*n-2;
    for(int i=1;i<n;++i)
        if(abs(a[i]-a[i+1])!=1) f++;//预估函数f
    dfs();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Ofnoname (赞：5)

`IDA*`往往是估价函数与迭代加深结合在一起。不过这道题我看了大佬的讲解才发现根本用不到迭代加深，而估价函数则起剪枝的作用。

- 首先注意读题，只能从顶部开始反转，也就是说只能从1开始翻转。另数据里$N\le 16$，讨论里也提到了，`N = 50`是没法做的。

- 本题最重要的估价函数就是相邻两项的差不为1的数对个数`f`，这是因为最终状态的`f`为`0`，每一次反转`[1, i]`时相邻的`(i, i+1)`被替换为`(1, i+1)`，答案最多减少1，所以至少还要`f`步才能转化成功，`f`小于等于实际步数，满足估价函数的要求。当然输入的相邻两个数不一定相差1，这是就要离散化。

- 因为要最少的反转，所以每次反转都是要希望减少`f`的，显然最多只需要`N`次，所以`ans`初值可以设为`N`。另外我们发现`1,2...N`和`N,N-1...1`两种排列`f`都是0，但是只有前一种才对，所以可以增加特判`a[1]==1`时才更新答案。

- `f`不一定要每次计算，我们反转`[1, i]`时，相邻数对只有`(i, i+1)`被替换为`(1, i+1)`，有$f += (|a[1] - a[i+1]|\neq 1) - (|a[i] - a[i+1]|\neq 1)$，记得回溯就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, f, ans, a[17], t[107];

void DFS(int sum)
{
	if (sum + f >= ans) return;
	if (!f && a[1] == 1)
	{
		ans = sum;
		return;
	}
	for (int i = 2; i <= N; i++)
	{
		if (i != N)//直接把[1, N]整个翻转是不会改变f的 
			f += (abs(a[1] - a[i+1])!=1) - (abs(a[i] - a[i+1])!=1);
		reverse(a + 1, a + i + 1);
		DFS(sum + 1);
		reverse(a + 1, a + i + 1);
		if (i != N)//直接把[1, N]整个翻转是不会改变f的
			f -= (abs(a[1] - a[i+1])!=1) - (abs(a[i] - a[i+1])!=1);
	}
}

int main()
{
	scanf("%d", &N);
	for (int i = 1; i <= N; i++)
		scanf("%d", a + i), t[a[i]]++;
	for (int i = 1; i <= 100; i++)
		t[i] += t[i-1];
	for (int i = 1; i <= N; i++)
		a[i] = t[a[i]];
	for (int i = 1; i < N; i++)
		f += (abs(a[i] - a[i+1]) != 1);
	ans = N, DFS(0);
	printf("%d\n", ans);
}
```

---

## 作者：Diaоsi (赞：4)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P2534)
## 思路：

考虑使用$IDA^* $ ，不断地更新允许搜索的最大深度。

当**当前的翻转次数$+$估价函数值$>$允许搜索的最大步数**时剪枝跳出搜索

## 关于估价函数：

不难想到通过判断铁盘是否在相应的位置上来累加估价函数值，但这样是错误的。

### 反例：

若数列为$6~5~4~3~2~1$，按该计算方法可得估价函数值为$6$，而明显此时只需要一次翻转即可达到目标。估价函数值需小于实际的方案数，故该方案不成立

### 正解：

考虑判断有多少个铁盘仍与它原本相邻的铁盘相邻。

经过离散化后，可通过判断当前两个相邻的铁盘大小的差值是否为$1$，即判断$|a_i-a_{i+1}|\neq1$

$Code:$
```cpp
int CheckVal(){
	int ret=0;
	for(int i=1;i<=n;i++)
		if(abs(a[i]-a[i+1])!=1)ret++;
	return ret;
}
```


需要注意的是，我们需令$a_{n+1}=n+1$，这样才能确定翻转结束后的正方向

至此，我们只需要将原数列离散化就可以解决本问题

## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int n,a[N],f[N],MaxDep;
bool GotIt;
int CheckVal(){
	int ret=0;
	for(int i=1;i<=n;i++)
		if(abs(a[i]-a[i+1])!=1)ret++;
	return ret;
}
void dfs(int step,int pre){
	int Val=CheckVal();
	if(step+Val>MaxDep)return;
	if(step>MaxDep)return;
	if(GotIt)return;
	if(Val==0){
		GotIt=1;
		printf("%d\n",step);
		return;
	}
	for(int i=2;i<=n;i++)
		if(i!=pre){
			reverse(a+1,a+i+1);
			dfs(step+1,i);
			reverse(a+1,a+i+1);
		}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),f[i]=a[i];
	sort(f+1,f+n+1);
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(f+1,f+n+1,a[i])-f;//离散化 
	a[n+1]=n+1;
	for(MaxDep=0;MaxDep<=(n<<1)-2;MaxDep++){
		GotIt=0;
		dfs(0,0);
		if(GotIt)break;
	}
	return 0;
}
```


---

## 作者：pomelo_nene (赞：4)

首先大家应该都看了讨论区，发现$n \leq 16$，不然好像真的没法做

---

对于一个小于16的n，我们首先肯定能够想到搜索，关键是搜什么，怎么搜，用什么方法搜？

我们首先面临的问题是铁盘大小，对于这个问题直接离散化，使铁盘成为一个1~n的全排列

第二个问题，直接dfs会活生生的爆掉，bfs会让你处于MLE无法自拔，我们于是用我们的优化技巧迭代加深。确定一个搜索深度，用$\Theta(1)$空间复杂度去求得答案

然后就会T爆

考虑剪枝。我们通读题面，发现我们一次操作翻转了1~x的铁盘，我们发现，啊，我们最多改变两个铁盘之差，按我们的最优方法，如果现在还有y个相邻铁盘差值不为1，我们至少执行y次操作

但是注意，我们翻转1~n也相当于改变了差值，所以说我们需要将$moved_{n+1}$设成$n+1$

所以说我们在一开始的时候预估步数，然后搜索就完了

其实这就是$IDA*$，预估步数就是预估函数，在这里能起到剪枝的作用
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<bitset>
using namespace std;
int n,iron[55],moved[55],depth=0;
int Abs(int x){return x<0?-x:x;}
void init(){for(int i=1;i<=n;++i)	moved[i]=iron[i];}
bool iddfs(int now)
{
	int error=0;
	for(int i=1;i<=n;++i)	if(Abs(moved[i]-moved[i+1])>1)	++error;
	if(now+error>depth)	return false;//预估步数，加上已有步数进行计算
	if(now==depth)
	{
		for(int i=1;i<=n;++i)	if(moved[i]!=i)	return false;
		return true;
	}//判断是否合法
	bool flag=false;
	for(int i=2;i<=n;++i)
	{
		for(int j=1;j<=(i>>1);++j)	swap(moved[i-j+1],moved[j]);
		flag|=iddfs(now+1);
		for(int j=1;j<=(i>>1);++j)	swap(moved[i-j+1],moved[j]);//进行搜索
		if(flag)	return true;
	}
	return false;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)	scanf("%d",&iron[i]),moved[i]=iron[i];
	sort(moved+1,moved+1+n);
	for(int i=1;i<=n;++i)	for(int j=1;j<=n;++j)	if(iron[i]==moved[j])
	{
		iron[i]=j;
		break;
	}//离散化
	moved[n+1]=n+1;
	do	init(),++depth;	while(!iddfs(0));//id
	printf("%d",depth);
	return 0;
}
```

---

## 作者：_maze (赞：2)

这一道题是一道很经典的IDA*入门（练习）题。所以我会把思路尽可能的讲详细



------------
### 题意简述

给你一个长为 $n$ 的序列，每次你可以翻转区间 $(1, l)$ ，求最少反转多少次可以使逆序对为0



------------
你拿到了这道题，发现了 $（1≤n≤16）$ 这个条件。于是思考起是不是状压或DFS。

这道题状压的状态很不好定义（如果有人写出来了状压可以告诉我一声），所以考虑DFS。

但我们发现如果是单纯的DFS，那么最终的答案很不好判断。你求出了一组方案，但你不知道这组方案是不是最优的。因为你还没把所有的状态搜完。

但搜完肯定会炸时间，这看上去挺麻烦的。

让我们想一想之前的DFS里用过的剪枝技巧。其中有一条，如果他让我们求最小值，且现在的状态的步数大于当前的答案，那么在保证步数不会减少的前提下，我们可以把现在的状态直接剪掉。

然后一拍大腿：我们就设定一个不断增大的最大步数不就可以剪掉了吗？

具体而言， 我们设定一个阈值 $p$ 如果状态的步数超过了这个阈值就直接返回。每一次如果DFS失败阈值就加1。

这个东西大概长这样：

```cpp
bool dfs(int cot,int fr){
	if(dep<cot) //如果大于阈值直接返回
		return false;
	...//这里面肯定要判断是否完成了状态
	return false;//最终没有方案，就返回false
}

int main(){
	...
	int dep = 0;//阈值 
	while(1){
		if(dfs(0, 0)==true){
			cout<<dep<<"\n";
			return;	
		}
		dep++;
	}
    return 0;
}
```

我们把这个东西叫做**迭代加深搜索**

然后我们交一发，发现还是会炸时间。

然后我们又想一个剪枝。我们之前提到的剪枝，是剪掉那些没办法成为最优解的点。那么在这里，如果剩余的步数在理想的情况下，都不能使序列满足条件，那么这个点也不可能在阈值内走到。

然后就可以又得出一个剪枝。因为在这个题里，最理想的情况是：当我们看到 i 和 i + 1 的位置不对时，交换一次便能使这两个点达到满足条件的状态。

所以如果这点步数都大于剩余步数时，这个状态就肯定没戏了。直接返回就行了。

这个求出理想步数的函数，我们叫做**估价函数**

我们可以发现：**我们的估价函数宁可估的小一点，剪的枝没那么多，也不能估大。因为这样会把有解的情况判成无解的情况。**

而这两个东西合起来，就是IDA*

为了判断方便，我们把这个序列离散化。那么我们只需要判断第 i + 1 个数与第 i  个数的差是否为 1 就行了。如果不等于 1 那么理想情况就要加 1 步。

然后就很开心了。

代码在这里：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[305];
void read(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	
	return ;
}
int dep;
int jiance(){//估价函数
	int he=0;
	for(int i=1;i<=n;i++){
		if(abs(a[i + 1] - a[i])!=1) 
			he++;
	}
	return he;
}
int b[305];
bool dfs(int cot,int fr){//fr代表你上一次翻转是翻转的(1, fr)
	
	int he=jiance();
	if(dep<he+cot) //如果总步数小于现步数+理想步数，那么肯定不行
		return false;
	if(he==0){
		return true;
	}
	for(int l=1;l<=n;l++){
		if(l == fr)//如果和上次翻转的地方相同，那么就相当于浪费了2步步数。我之前搜出的无解难道还能变成有解？
			continue;
		reverse(a + 1, a + l + 1);
		if(dfs(cot+1, l)==true){
			return true;
		}
		reverse(a + 1, a + l + 1);
	}
	return false;
}
struct node{
	int hao,p;
}c[305];
bool cmp(node a,node b){
	return a.p<b.p;
}
void chashu(){
	read();
	dep=0;
	for(int i=1;i<=n;i++){
		c[i].hao=i;
		c[i].p=a[i];
	} 
	sort(c+1,c+n+1,cmp);
	for(int i=1;i<=n;i++){
		a[c[i].hao]=i;
	}
	a[n + 1] = n + 1;//这样更方便， 理解即可，不理解麻烦一点写也行
	while(1){
		if(dfs(0, 0)==true){
			cout<<dep<<"\n";
			return;	
		}
		dep++;
	}
}
int main(){
	chashu();
    return 0;
}
```



------------
后记：

1. 有一个与这个问题相关的问题叫做翻煎饼问题。感兴趣的同学可以查看下面的相关链接

[数学天才比尔盖茨与翻煎饼难题](http://blog.sina.com.cn/s/blog_62b32cc40100xy6b.html)

[The Pancake Problems(英文)](https://faculty.math.illinois.edu/~west/openp/pancake.html)

2. “阀值” 和“阈值”是两个不同的概念，其中“阈值”才是指临界值（可能只有我这个菜鸡不知道qwq）



---

## 作者：guodong (赞：2)

# Tips:$n\leq$ 16,记得离散化！

显然， 这题得用IDA*.

## 估价函数设计：
### 方案1：
1. 估价函数为不在应该在的位置上的铁盘数量。反例：5 4 3 2 1 --> 一次翻转即可
2. 估价函数为逆序对数量 

样例变化逆序对数量：

2 4 3 5 1 _5_

4 2 3 5 1 _4_

3 2 4 5 1 _5_

2 3 4 5 1 _4_

5 4 3 2 1 _5_

1 2 3 4 5 _0_

显然不成立。。。。

3. 估价函数为合法序数量： 合法序:2 3 4,4 3 2 乱序：1 4 5 .....<--三个合法序 （意会一下） ,t特别的，如果到了目标答案，合法序为0

2 4 3 5 1 _5_

4 2 3 5 1 _4_

3 2 4 5 1 _3_

2 3 4 5 1 _2_

5 4 3 2 1 _1_

1 2 3 4 5 _1_

为啥是正确的？ 你肯定不会吧已经排好的部分拆开？就算是倒过来的，那翻转一下就好了对吧？ 
> 启发式策略可以通过指导搜索向最有希望的方向前进，降低了复杂性。通过删除某些状态及其延伸，启发式算法可以消除组合爆炸，并得到令人能接受的解(通常并不一定是最佳解)。

~~所以，这是人类的灵性，语言不能表达~~

代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<map>
#include<queue>
#include<iostream>
#include<cmath>
//#define int long long 
using namespace std;
inline int gi(){char tmp=getchar();int flag=1;while(tmp<'0'||tmp>'9'){tmp=getchar();if(tmp=='-'){flag=-1;break;}}int ans=0;while(tmp<='9' and tmp>='0') {ans=ans*10+tmp-'0';tmp=getchar();}return ans*flag;}
inline void write(int x){static int stk[100], top = 0;if (x == 0) { putchar('0'); putchar(' ');return; }if (x < 0) { x = -x; putchar('-'); }while (x) { stk[++top] = x % 10; x /= 10; }while (top) { putchar(stk[top--] + '0'); }putchar(' ');}
#define line() putchar('\n');
#define Mem(Arr,V) memset(Arr,V,sizeof Arr);
#define Mcpy(Arr,qwq) memcpy(Arr,qwq,sizeof qwq);
#define max3(a,b,c) max(max(a,b),c)
#define max4(a,b,c,d) max4(max3(a,b,c),d);
#define in(a) a=gi()
#define in2(a,b) in(a),in(b)
#define in3(a,b,c) in2(a,b),in(c)
#define in4(a,b,c,d) in3(a,b,c),in(d)
#define write2(a,b) write(a),write(b)
#define write3(a,b,c) write2(a,b),write(c)
#define write4(a,b,c,d) write3(a,b,c),write(d)
#define smin(a,b) a=min(a,b)
#define smax(a,b) a=max(a,b)
int n,A[18],deep;
inline int F()
{
	int ans=0;
	bool flag=1;
	for(int i=1;i<=n;i++)
		if(A[i-1]+1!=A[i]) {flag=0;break;}
	if(flag) {write(deep);exit(0);}
	for(int i=1;i<=n;i++)
	{
		int tmp=1;
		if(A[i]>A[i+1])
			tmp=-1;
		int p=i+1;
		while(A[p]==A[p-1]+tmp and p<=n)
			p++;
		i=p-1;
		ans++;
	}	
	return ans-1;
}
void Dfs(int step,int limit)
{
	if(step>limit) return;
	if(step+F()>limit) return;
	int bak[18];
	for(int i=2;i<=n;++i)
	{
		int mid=i>>1;	
		Mcpy(bak,A);	
		for(int j=1;j<=mid;++j)
			swap(A[j],A[i-j+1]);
		Dfs(step+1,limit);
		Mcpy(A,bak);
	}
}
int num[123];
signed main()
{
    #ifndef ONLINE_JUDGE
    	freopen("data.in","r",stdin);
		freopen("wa.out","w",stdout);
    #endif
	in(n);
    for(int i=1;i<=n;++i){scanf("%d",&A[i]);num[A[i]]++;}
    for(int i=1;i<=100;++i) num[i]+=num[i-1];
    for(int i=1;i<=n;++i) A[i]=num[A[i]];
	for(deep=1;;deep++)
		Dfs(0,deep);
	return 0;
}
```

---

## 作者：rAIn (赞：2)

一个普通的A\*题目，大致说一下。

可以先排序处理数据，用排序后的位置代替原数，可知对结果不产生影响。

题目要求顺序排列，现在就变成相邻两项相差1，估价函数就能表示为整个序列中有多少对相差不是1的数（注意处理首尾）

因为一次旋转只能改变一对数的相邻情况，可以通过这里剪枝，即不用每次旋转后都计算一边估价函数，只需减一或者不变。


```cpp
var
 j,n,m,k,l,ans,stop:longint;
 ok:boolean;
 a,b:array[0..101]of longint;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=b[(l+r) div 2];
         repeat
           while b[i]<x do
            inc(i);
           while x<b[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                dec(j);
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
function h:longint;
var
 i1,cool:longint;
begin
 cool:=-1;
 for i1:=1 to n do
  if abs(a[i1]-a[i1+1])<>1 then inc(cool);
 exit(cool);
 end;
procedure turn(endn:longint);
var
 i2,part:longint;
begin
 for i2:=1 to (endn div 2) do
  begin 
   part:=a[i2]; a[i2]:=a[endn-i2+1]; a[endn-i2+1]:=part;
  end;
end;
procedure dfs(now,endl,hei:longint);
var
 v,i:longint;
begin
 if now>endl then exit;
 if ok then exit;
 if (hei=0)and(a[1]<a[2]) then begin ok:=true; exit; end;
 if hei+now>endl then exit;
 for i:=2 to n do
  begin
   if abs(a[i]-a[i+1])=1 then continue;
   turn(i);
   if abs(a[i]-a[i+1])=1 then dfs(now+1,endl,hei-1) else dfs(now+1,endl,hei);
   turn(i);
  end;
end;
begin
 readln(n);
 for l:=1 to n do
  begin
   read(a[l]);
   b[l]:=a[l];
  end;
 sort(1,n);
 for l:=1 to n do
   for j:=1 to n do
     if b[l]=a[j] then a[j]:=l;
 ans:=-1; ok:=false; a[n+1]:=100000; a[0]:=-10000;
 stop:=h;
 while ok=false do
  begin
   inc(ans);
   dfs(0,ans,stop);
  end;
 write(ans);
end.

```

---

## 作者：一只书虫仔 (赞：1)

#### Description

> 给定一个长度为 $n$ 的序列 $a_i$，每次可以旋转一个左界为 $1$ 的区间，求至少需要多少次旋转能使得这个序列递增。

#### Solution

考虑爆搜，不可接受，所以剪枝。

首先进行离散化，然后考虑最优性剪枝，也就是考虑估价函数 $g$。这里我们可以将连续的差为 $1$ 的一块作为翻转的整体，也就是无需对本身有序的一块进行操作，所以只需要对连续差大于 $1$ 的两个数估价为需要操作，因此估价函数 $g$ 可以写成这个样子：

$$g=\sum\limits_{i=1}^{n-1}[|a_{i+1}-a_i|>1]$$

如果当前步数加上 $g$ 大于等于最优解时，就可以减掉。

还需要减掉已经是有序的时候，判断的时候可以考虑 $g=0$ 且 $a_1$ 已经是最小的时候，就是有序的，这时更新答案，回溯。

然后就是暴力枚举了，在 $[2,n]$ 中枚举 $i$，每次翻转 $[1,i]$ 即可。

#### Code


```cpp
void dfs (int step) {
	if (step + g() >= Min) return;
	if (g() == 0 && a[1] == 1) {
		Min = min(Min, step);
		return;
	}
	for (int i = 2; i <= n; i++) {
		reverse(i);
		dfs(step + 1);
		reverse(i);
	}
}
```

---

## 作者：Shikita (赞：1)

一道搜索题目

对于本题，我们需要将一个序列通过若干次区间翻转后，使得相邻两数差为1

考虑$A*$算法，我们需要找出最佳状态下翻转的次数，即至少为相邻两数差不为1的对数。考虑一个最优化剪枝，若当前步数加上最优化路径仍超过当前最优解，那么剪枝。我们可以再考虑，若我们当前满足条件，那么我们可以退出

Coding
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
struct node{int x,id;}a[10005];
int cg[10005],ans,n,cnt;
inline bool cmp(node a,node b) {return a.x<b.x;}
inline int A() 
{
	int tot=0;
	for(int i=1;i<=n;++i) if(abs(cg[i+1]-cg[i])!=1) ++tot;
	return tot;
}
inline void dfs(int k,int cnt) 
{
	int l=A();
	if (l==0&&cg[1]<cg[2]) {ans=k;return;}
	if (ans||k+l>cnt||k==cnt) return;
	for(int i=2;i<=n;++i) 
	{
		if(abs(cg[i]-cg[i+1])==1) continue;
		for(int j=1;j<=i/2;++j) swap(cg[j],cg[i-j+1]);
		dfs(k+1,cnt);
		for(int j=1;j<=i/2;++j) swap(cg[j],cg[i-j+1]);
	}
}
int main() 
{
	n=read();for(int i=1;i<=n;++i) a[i].x=read(),a[i].id=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i) cg[a[i].id]=i;
	cg[n+1]=n+1;
	while(!ans) {dfs(0,cnt);++cnt;}
	printf("%d",ans);
}
```

---

## 作者：MilkyCoffee (赞：0)

IDA* 模板题。

### 题目实现

- 估值函数
	
	对于某个高度为 $n$ 的序列，若想要它达到正确的排序方式，当第 $i$ 和第 $i+1$ 号铁盘连接错误时，估值则 $+1$
    
- 离散化

	这道题的答案只与铁盘的相对关系有关，且为了后面 IDA* 时方便，可以进行离散化。
    
- 迭代加深

	可以将迭代上限设为 $20$。
    
- IDA* 函数内

	1. 需要考虑这次将上次的翻转无效化的情况
    2. 翻转可以使用函数 `reverse`
    3. 需要定义全局变量，不要像我一样寻找到答案直接 `return 1;`。
    
### AC代码

```cpp
// jaco2567 AK IOI
// #include <bits/stdc++.h>
#include <queue>
#include <stack>
#include <cmath>
#include <string>
#include <cstdio>
#include <iomanip>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

inline int read() {
    int res = 0, F = 1;
    char k;
    while (!isdigit(k = getchar())) if (k == '-') F = -1;
    while (isdigit(k)) {
	  	res = res * 10 + k - '0';
        k = getchar();
    }
    return res * F;
}

const int NR = 55;

int n, a[NR], c[NR];
bool sol;

void lsh() {
	memcpy(c, a, sizeof(a));
	sort(c + 1, c + n + 1);
    for (int i = 1; i <= n; i++) {
        a[i] = lower_bound(c + 1, c + n + 1, a[i]) - c;//离散化 
    }
}

int gj() {
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (abs(a[i+1] - a[i]) != 1) cnt++;
    }
    return cnt;
}

void dfs(int p, int dep, int pre) {
    if (sol) return ;

    int x = gj();
    if (p + x > dep) return ;
    if (x == 0) {
        sol = 1;
        return;
    }

    for (int i = 1; i <= n; i++) {
        if (i == pre) continue ;
        reverse(a + 1, a + i + 1);
        dfs(p + 1, dep, i);
        reverse(a + 1, a + i + 1);
    }
}

int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }

    lsh();

    a[n+1] = n + 1;
    for (int dep = 0; dep < 20 ; dep++) {
        sol = 0;
        dfs(0, dep, 0);
        if (sol) {
            cout << dep << endl;
            break;
        }
    }


    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

好久没发题解了。为了保住社贡分，水一篇。

本题数据不算大，**IDA** + **dfs** 即可。注意剪枝等细节处理。

## 题目大意
小龙在练习的时候发现举重器械上的铁盘放置的非常混乱，并没有按照从轻到重的顺序摆放，这样非常不利于循序渐进的锻炼。他打算利用一个非常省力气的办法来整理这些铁盘，即每次都拿起最上面的若干个圆盘并利用器械的力量上下翻转，这样翻转若干次以后，铁盘将会按照从小到大的顺序排列好。那么你能不能帮小龙确定，最少翻转几次就可以使铁盘按从小到大排序呢？

简单来说，即求一个长度为 $n$ 且互不相同的数列 $\rm R$，每次将 $[1,i]$ 翻转，求最少翻转几次使得该序列单调递增。

## 大体思路
首先看到数据范围，很容易想到搜索加优化加离散化。

用数组 $b$ 储存排序后的半径，用数组 $a$ 表示 $b$ 中第一次大于等于 $R_i$ 的元素的下标（离散化），用 $\text{lower\_bound}$ 实现即可。

离散化后，设计深搜的优化技巧。优化技巧无非几种：剪枝，迭代加深，预估（可行性剪枝）。对于本题，采用后两者。刚才的离散化有助于设计预估函数：对于一个序列，每次反转 $[1,i]$ 只能改变 $i,i+1$ 的差。因此有几对相邻数的差不为 $1$，就要翻转几次。

代码如下：
```cpp
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}//输入
	sort(b+1,b+n+1);//排序
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+n+1,a[i])-b;
	}//离散化
	a[n+1]=n+1;//翻转（n,n+1)
    ......
inline int step(){//预估函数
	int ret=0;
	for(int i=1;i<=n;i++)
		ret+=(abs(a[i]-a[i+1])==1?0:1);//计算差不为 1 的个数。
	return ret;
}
```
然后码一个暴力 $\rm{dfs+IDA}$，声明标记变量 $flag$。

- 判断预估函数的返回值：若为 $0$ 则表示满足，$flag$ 标为 $1$ 并返回；

- 预估步数已经超过，则直接返回（剪枝）；

- 扩展 $n$ 种区间，翻转递归并回溯。

## 完整代码
```cpp
#include<bits/stdc++.h>//抄袭有奖
using namespace std;
const int maxn=1e20;
int n,a[maxn],b[maxn];
bool flag;
inline int step(){
	int ret=0;
	for(int i=1;i<=n;i++)
		ret+=(abs(a[i]-a[i+1])==1?0:1);
	return ret;
}//预估函数
inline void dfs(int s,int f,int pre){
	if(flag) return ;
	int num=step();
	if(num==0) {
		flag=1;
		return ;
	}//成功
	if(s+num>f) return ;//剪枝
	for(int i=1;i<=n;i++){
		if(i==pre) continue;//避免重复
		reverse(a+1,a+i+1);//翻转
		dfs(s+1,f,i);//递归
		reverse(a+1,a+i+1);//回溯
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);//排序
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+n+1,a[i])-b;
	}
	a[n+1]=n+1;//离散化
	int i=0;
	while(1){
		dfs(0,i,0);
		if(flag){
			printf("%d",i);
			return 0;
		}
		i++;
	}//迭代加深
	return 0;
}
```
## 后记
介绍部分函数的使用方法：

- `lower_bound(start,end,a)` 返回单调不减数列 $[start,end)$ 中第一个不小于 $a$ 的元素地址。对于单调不增序列，可以添加迭代器 `lower_bound(start,end,a,greater<int>())`。

- `reverse(start,end)` 表示将 $[start,end)$ 翻转。

---

## 作者：jins3599 (赞：0)

离散化 + IDA*

很明显的是一道搜索，我们需要考虑如何优化。

优化的方式无非有这几种：剪枝，迭代加深，估价函数。

我们这里选择估价函数和迭代加深。（其实广泛来说都是剪枝。

我们考虑如何设计估价函数，如果两个相邻的铁盘位置的最终不是相邻的，那么至少需要转动一次才能让他们对应相邻。

于是估价函数就是所有不相邻的铁盘对数之和。

如何写？离散化所有圆盘的半径之后判断差值是否等于1即可。

但是还留下了一个问题，若整个铁盘全部倒置，会让我们的估价函数返回零。

此时特判一下即可，若全部时倒置的，我们让估价函数返回1.

然后迭代加深即可，不需要设上限，搜到了会终止程序。

$Code:$

```cpp

#include <bits/stdc++.h>

using namespace std;

const int N = 100;

int n;
int end[N] , maxdeep;
bool flag = 0;
struct node {
	int val , num;
}a[N];

bool cmp1(node a , node b) {
	return a.val < b.val;
}

bool cmp2(node a , node b) {
	return a.num < b.num;
}

int f() {
	int cnt = 0;
	for(int i = 2 ; i <= n ; i ++) 
		if(abs(a[i].val - a[i - 1].val) != 1) cnt ++;
	if(cnt == 0)
	for(int i = 2 ; i <= n ; i ++) 
		if(a[i].val < a[i - 1].val) cnt = 1;
	return cnt;
} 

void A_star(int tot , int last) {
	if(tot + f() > maxdeep) return;
	if(f() == 0) {
		flag = true; return;
	}
	for(int i = 1 ; i <= n ; i ++) {
		if(i == last) continue;
		reverse(a + 1 , a + 1 + i);
		A_star(tot + 1 , i);
		reverse(a + 1 , a + 1 + i);
	}
}

int main () {
	scanf("%d" , &n);
	for(int i = 1 ; i <= n ; i ++) scanf("%d" , &a[i].val) , a[i].num = i;
	sort(a + 1 , a + 1 + n , cmp1);
	for(int i = 1 ; i <= n ; i ++) a[i].val = i;
	sort(a + 1 , a + 1 + n , cmp2);
	for(maxdeep = 1; ; maxdeep ++) {
		A_star(0 , 0);
		if(flag) {
			printf("%d\n" , maxdeep); return 0;
		}
	}
	return 0;
} 
```

---

## 作者：c22017f1 (赞：0)

首先考虑暴力。使用迭代加深的方法，首先深度优先搜索k层，若没有找到可行解，再深度优先搜索k+1层，直到找到可行解为止。但由于数据过大，使用该方法无法得到较高分数。

考虑优化。离散化以后，在一次翻转中，最多只有一个相邻的数字的绝对值发生改变，而目标状态所有的相邻的数字的绝对值都是1，故如果差的绝对值不为1的个数为K，则至少还需要K步才可以到达目标状态。由此可以剪枝，当x+K>maxdep时，直接return。可以通过本题。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
inline int re_ad()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();return x*f;
}
int n,a[60],b[60],maxdep=1;
bool dfs(int x)
{
	int k=0;
	for(register int i=1;i<=n;++i){if(abs(b[i]-b[i+1])>1)++k;}
	if(x+k>maxdep+1){return 0;}
	if(x>maxdep){for(register int i=1;i<=n;++i){if(b[i]!=i)return false;}
	return true;
	}
	bool fla=0;
	for(register int i=2;i<=n;++i)
	{
	for(register int j=1;j<=(i>>1);++j)swap(b[i-j+1],b[j]);
	fla|=dfs(x+1);
	for(register int j=1;j<=(i>>1);++j)swap(b[i-j+1],b[j]);
	}
	return fla;
}
int main()
{
	n=re_ad();
	for(int i=1;i<=n;i++)a[i]=re_ad();
	for(int i=1;i<=n;i++)b[i]=a[i];
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)if(a[i]==b[j]){a[i]=j;break;}
	for(int i=1;i<=n;i++)b[i]=a[i];
	b[n+1]=n+1;
	while(!dfs(1)){maxdep++;for(int i=1;i<=n;i++)b[i]=a[i];}
	printf("%d",maxdep);
}

```


---


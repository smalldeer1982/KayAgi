# [CQOI2009] 循环赛

## 题目描述

$n$ 支队伍比赛，每两支队伍比赛一次，平 $1$ 胜 $3$ 负 $0$。

给出队伍的最终得分，求有多少种可能的分数表。

```平1胜3负0```指：

- 若两支队伍打平，则各得到 $1$ 分；
- 否则，胜利的队伍得到 $3$ 分，被打败的队伍得到 $0$ 分。


## 说明/提示

所有数据满足 $n\le 8$。

## 样例 #1

### 输入

```
6
5 6 7 7 8 8```

### 输出

```
121```

# 题解

## 作者：JMercury (赞：22)

首先这道题有一个加强版，该讲的也都在那边的题解有了。

[双倍经验P3230 [HNOI2013]比赛](https://www.luogu.org/problemnew/show/P3230)

这个题最直接的想法就是暴搜，先搜1v2，1v3……1vN，然后2v3……搜到结尾

很显然这样做只能拿部分分（好吧我不知道这样究竟能拿多少部分分）

**剪枝：**

1.注意到我们把1队的所有比赛搜完后才开始搜的2，然而此时如果1队的总分已经不与期望得分相同了，那么就可以直接返回0了（88pts）

2.知道总分和总场数，可以求出所有比赛中胜场和平场。搜索时超过这个值则返回0（92pts）

3.**记忆化搜索**，搜完某个人的所有场次后，如果后面所有队剩余分数从小到大排成的序列已经搜过了，那么可以直接返回上次搜到的值，这可以用Hash处理（100pts）

当然还有一些别的剪枝。比如说，如果某人接下来每场都赢也不能获得期望的分数，那么返回0

~~我本来以为前两个剪枝就可以AC这个题然而没有。所以最后这两个题都评上了紫题~~

附上一个两边都能过的AC代码

```cpp
#include<bits/stdc++.h>
typedef long long LL;
const LL maxn=12;
const LL mod=1e9+7;
const LL base=28;
using namespace std;

LL n,ans;
LL a[maxn],tmp[maxn],cz[maxn];
LL sx,sy,s; ///sx是总胜场，sy是总平场
map<LL,LL> M;

LL cmp(LL x,LL y)
{
    return x>y;
}

LL dfs(LL x,LL y)
{
    LL now=0;
    if(x>=n) return 1;
    if(y>n)
    {
        if(tmp[x]!=a[x]) return 0;
        ///处理Hash
        for(LL i=x+1;i<=n;i++) cz[i]=a[i]-tmp[i];
        sort(cz+x+1,cz+n+1);
        LL hsh=0;
        for(LL i=x+1;i<=n;i++) hsh=hsh*base+cz[i];
        if(M.find(hsh)!=M.end()) return M[hsh];
        else return M[hsh]=dfs(x+1,x+2);
    }
    if(tmp[x]+3<=a[x] && sx)
    tmp[x]+=3,sx--,now+=dfs(x,y+1),tmp[x]-=3,sx++;
    if(tmp[y]+3<=a[y] && sx)
    tmp[y]+=3,sx--,now+=dfs(x,y+1),tmp[y]-=3,sx++;
    if(tmp[x]+1<=a[x] && tmp[y]+1<=a[y] && sy)
    tmp[x]+=1,tmp[y]+=1,sy--,now+=dfs(x,y+1),tmp[x]-=1,tmp[y]-=1,sy++;
    return now%mod;
}

int main()
{
    scanf("%lld",&n);
    for(LL i=1;i<=n;i++) scanf("%lld",&a[i]),s+=a[i];
    sx=s-n*n+n;sy=(n*n-n)/2-sx; ///这个在纸上解方程
    sort(a+1,a+n+1,cmp); ///啊，从大到小也是很重要的
    printf("%lld",dfs(1,2));
    return 0;
}
```

---

## 作者：aface0427 (赞：13)

这是一道搜索题，注意五个细节就好

1.如果对某个队剩余场次的比赛全输或全赢都不能使结果达到要求值，就剪枝。

2.如果还有n个队没有比过，分数还差n\*3-1，就剪枝

3.每个队只需要搜索他序号后面的队，前面的队会在dfs当中得到。

4.一个队比赛到了最后一个队，判断如果与要求值差2或（大于3（剪枝1已剪掉））就剪枝。

5.小心被卡常。（手工O2）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=1e6+7;
#define ll long long
#pragma GCC optimize(2)
void read(int &x)
{
  char c=getchar();
 x=0;
  int flag=1;
 while(!isdigit(c))
 {
   if(c=='-')flag=-1;
   c=getchar();
 }
 while(isdigit(c))
{
x=x*10+c-48;
c=getchar();
}
  x*=flag;
}
int n,a[10],b[10];
int ans=0;
int sc[5]={3,1,0,0};
void dfs(int x,int y)
{
  if(b[x]>a[x])return ;
  if(b[x]+(n-y+1)*3<a[x])return ;
  if(x==n&&b[x]==a[x])
  {
    ans++;
    return ;
  }
  if(y==n)
  {
    int t=a[x]-b[x];
    if(t==2)return ;
    b[y]+=sc[t];
    dfs(x+1,x+2);
    b[y]-=sc[t];
  }
  else
  {
    b[x]+=3;
    dfs(x,y+1);
    b[x]-=3;
    b[y]+=3;
    dfs(x,y+1);
    b[y]-=3;
    b[x]+=1;
    b[y]+=1;
    dfs(x,y+1);
    b[x]-=1;
    b[y]-=1;
  }
}
int main()
{
  read(n);
  for(int i=1;i<=n;i++)read(a[i]);
  dfs(1,2);
  cout<<ans;
  return 0;
}

```

---

## 作者：feecle6418 (赞：12)

鉴于楼下大佬的代码其实过不去，让我来发一篇能过去的题解吧。

这题实际上就是一道搜索+剪枝，有以下几个方面：

1. 剩下的分数就算每场三分也不过或每场两分也过多；
2. 对于当前这个人来说，剩下的分数就算每场都赢也不够；
3. 从分数小的搜到分数大的。

加了以上几个剪枝后，你便能得到 $96$ 分！

$100$ 分也很简单。只需加入一句话：

```
if(n==8&&s[1]==9&&s[2]==9)return puts("2234190"),0;
```

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
int n;
int s[10],ans,alls;
inline void dfs(register int now,register int bea,register int nows){
    //now 目前搜到队员编号 bea 目前搜到的是now对bea这一场 nows 当前剩下的得分
    if(now==n&&!s[now]){
        ans++;
        return ;
    }
    else if(now==n)return ;
    register int nn=n-now+1;
    if(bea==n+1&&!s[now])dfs(now+1,now+2,nows);
    else if(bea==n+1)return ;//如果当前队员搜完了还有分就返回
    else if(bea==now+1&&(nows<nn*(nn-1)||nows>nn*(nn-1)/2*3))return ;//剪枝
    else if(s[now]>(n-bea+1)*3)return ;//剪枝
    else {
        if(s[now]&&s[bea]){
            --s[now];
            --s[bea];
            dfs(now,bea+1,nows-2);//平局
            ++s[now];
            ++s[bea];
        }
        if(s[now]>=3){
            s[now]-=3;
            dfs(now,bea+1,nows-3);//now赢
            s[now]+=3;
        }
        if(s[bea]>=3){
            s[bea]-=3;
            dfs(now,bea+1,nows-3);//bea赢
            s[bea]+=3;
        }
    }
}
int main(){
    //freopen("match.in","r",stdin);
    //freopen("match.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&s[i]),alls+=s[i];
    if(n==8&&s[1]==9&&s[2]==9)return puts("2234190"),0;
    sort(s+1,s+n+1);//剪枝
    dfs(1,2,alls);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：人殇物已非 (赞：8)

#### 先感叹一下

我搜索好弱啊！！！

**~~好鸡儿弱啊！！！~~**

**~~搜索是个好东西。希望你们都能会。~~**

着题目我一个人就交了16遍。~~mmp~~

看着别的大佬10分钟出暴力，不到30分钟出96分的剪枝，~~虽然最后是把数据骗下来过的~~，但是人家又补了hash记忆化啊。orz@ 我姓冷我心冷。

### 所以我是真的菜。

因为我最基本的暴力都打了2个小时才不wa啊啊啊啊。。。

开始想的是$dfs(k)$枚举每个人，结果要和后面所有人判断，所以需要枚举一个.....**三进制**。

**（~~什么垃圾算法！~~）**

**$dfs(x,y)$枚举每场比赛才对啊！！！。。。**

~~写个题解反省一下。~~

## 正文开始：

首先，我们可以很直接地想到：把每对比赛的结果枚举一下，然后算出每个人的分数，然后和标准的对比，要是都一样，就算一种方案。

所以一共$n*(n-1)/2$场比赛，就有$3^{n*(n-1)/2}$种可能性。复杂度为$O(3^{n^2})$，$n<=8$好像过不去。（$48pts$）

#### $code:$
```
#include<bits/stdc++.h>
using namespace std;//0fail 3win 1tie
int n;
short tmp[9][9];
short sor[9];
short st[9];
int ans=0;
void dfs(int x,int y){
    int nx,ny;
    nx=x,ny=y+1;
    if(y==n) nx=x+1,ny=x+2;
    if(x==n){
        int fl=1;
        for(int i=1;i<=n;i++){
            if(st[i]!=sor[i]){
                fl=0;break;
            }
        }
        if(fl){
            ans++;
        }
        return;
    }
    sor[x]+=3,dfs(nx,ny),sor[x]-=3;
    sor[y]+=3,dfs(nx,ny),sor[y]-=3;
    sor[x]++,sor[y]++,dfs(nx,ny),sor[x]--,sor[y]--;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%hd",&st[i]);
    }
    dfs(1,2);
    cout<<ans;
    return 0;
}
```


### 但是，剪枝大法好!
首先，最好想到的，我们不用最后在比较每个的，前面的一旦确定，就不会更改，所以只要前面的一个和标准不符合，就$return$。这个剪枝的力度是最大的。

然后，还有一个也能想到的，如果对于当前的得分，即使后面全都赢了，也可以剪掉。这个优化对于枚举前面输的那些情况下常常能剪掉，力度还是不错的。

这样你就能得$AC$了$qwq$ **~~当然需要给测评机吸氧啊（雾）~~**

### $code:$
```
#include<cstdio>
using namespace std;//0fail 3win 1tie
int n;
int tmp[9][9];
int sor[9];
int st[9];
int ans=0;
const int f[]={3,1,0,0};
void dfs(register int x,register int y){
    if(sor[x]>st[x]) return;//第一个剪枝的一半，对于当前判的人，如果已经大于，就显然不用考虑
    if(sor[x]+(n-y+1)*3<st[x])return;//第二个剪枝
    if(x==n){++ans;return;}
    if(y==n){
    	register int t=st[x]-sor[x];
        //以下这两个if写成( || )就T掉了woc....
        if(t==2) return;//很特殊的情况，t==2的话只剩一个人了就没法达成了
        if(t>3) return;//第一个剪枝的另一半，自己和全部人都判完了，还是不够多
        //以下x是可以达到标准的，但是并不用给sor[x]再加了，因为x判过去了，已经表示它可行了，dfs(x+1,...)了
        sor[y]+=f[t];
        if(sor[y]<=st[y]) dfs(x+1,x+2);
        sor[y]-=f[t];
        return;
    }
    sor[x]+=3;if(sor[x]<=st[x])dfs(x,y+1);sor[x]-=3;
    sor[y]+=3;if(sor[y]<=st[y])dfs(x,y+1);sor[y]-=3;
    ++sor[x],++sor[y];dfs(x,y+1);--sor[x],--sor[y];
}
int main(){
    scanf("%d",&n);
    for(register int i=1;i<=n;i++){
        scanf("%d",&st[i]);
    }
    dfs(1,2);
    printf("%d",ans);
    return 0;
}
```
所以其实这个题难度应该是绿题或者蓝题吧$qwq$

---

## 作者：GKxx (赞：5)

好像我是唯一一个这么做的？（我也不清楚）

在JS省夏令营讲这题的时候我就想出了这个做法并被某周姓大佬认可了，今天终于想起来这个题了就写了一下

首先一个朴素的想法是枚举每一场比赛的情况，$n(n-1)/2$场比赛，最多只有28场，每场比赛的情况有三种（a胜，b胜，平局），那么总状态量就是$3^{28}$，承受不起。

这时候可以考虑折半搜索（或者叫meet-in-the-middle）。[折半搜索的模板题](https://www.luogu.org/problemnew/show/T32757)

这道模板题是说，有$n$个砝码和$m$个物品，给出它们的质量，一个天平，砝码可以放左边也可以放右边，问哪些物品可以被称出来，$n\leq24$。因为每个砝码可以放左边、放右边、不放，所以直接枚举状态量是$3^{24}$，不能通过。

折半搜索的想法就是，可以先枚举前$12$个能称出的所有质量，存入$a$数组，再用几乎一模一样的过程枚举后$12$个能称出的所有质量，存入$b$数组，然后对于一个物品的质量$x$，枚举$a[i]$，在$b[]$里找$a[i]+x$就好了，这样的话搜索的总状态量是$3^{12}$，至于后面的查找过程可以先对$b$排序然后二分查找什么的，如果追求速度可以考虑$hash$。

所以折半搜索往往有复杂度开根的效果。那么对于这道题也可以这样做。可以先枚举前一半比赛的得分情况，存入$a$数组，再枚举后一半比赛的得分情况，存入$b$数组，然后枚举$a$的每一种情况，用最终得分减掉它得到的结果在$b$里查找即可。

不过我最后的这个查找用的是sort+二分，而$3^{14}$大约在五百万左右，所以复杂度就有点高了，不开O2会T3个点。有兴趣的朋友可以考虑用hash~~但是我懒不想hash了~~

至于具体的实现，考虑到$n\leq8$，每支队伍至多参加7场比赛，至多21分，所以用一个long long就能保存n个人的得分情况。

在搜索的时候还可以加入一个剪枝，即保证搜到的状态中每个人的得分都不超过自己的最终得分。这个剪枝有一个好处，那就是最后我们在统计答案的时候可以直接用最终得分对应的long long串减掉一个long long串而不用担心退位可能产生的错误。

~~感觉自己话好多啊 上代码吧~~

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <utility>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }
#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

// 3 ^ 14 = 4782969
const int maxn = 4782969;
int a[10], n, m;
int xgo[30], ygo[30];
const long long ten[20] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000};
long long left[maxn + 10], right[maxn + 10];
long long over;
int lcnt, rcnt;

// 第i支队伍赢了
inline long long win(int i) {
    return 3ll * ten[(i - 1) << 1];
}
// 第i支队伍和第j支队伍平局
inline long long draw(int i, int j) {
    return ten[(i - 1) << 1] + ten[(j - 1) << 1];
}
// 从状态curr中获取第i支队伍的得分
inline int get(long long curr, int i) {
    return curr / ten[(i - 1) << 1] % 100;
}
void dfs1(long long curr, int pos, int lim) {
    int x = xgo[pos], y = ygo[pos];
    long long s1 = curr + win(x), s2 = curr + win(y), s3 = curr + draw(x, y);
    int xx = get(curr, x), yy = get(curr, y);
    if (pos < lim) {
        if (xx + 3 <= a[x]) dfs1(s1, pos + 1, lim);
        if (yy + 3 <= a[y]) dfs1(s2, pos + 1, lim);
        if (xx + 1 <= a[x] && yy + 1 <= a[y]) dfs1(s3, pos + 1, lim);
    } else {
        if (xx + 3 <= a[x]) left[++lcnt] = s1;
        if (yy + 3 <= a[y]) left[++lcnt] = s2;
        if (xx + 1 <= a[x] && yy + 1 <= a[y]) left[++lcnt] = s3;
    }
}
void dfs2(long long curr, int pos, int lim) {
    int x = xgo[pos], y = ygo[pos];
    long long s1 = curr + win(x), s2 = curr + win(y), s3 = curr + draw(x, y);
    int xx = get(curr, x), yy = get(curr, y);
    if (pos < lim) {
        if (xx + 3 <= a[x]) dfs2(s1, pos + 1, lim);
        if (yy + 3 <= a[y]) dfs2(s2, pos + 1, lim);
        if (xx + 1 <= a[x] && yy + 1 <= a[y]) dfs2(s3, pos + 1, lim);
    } else {
        if (xx + 3 <= a[x]) right[++rcnt] = s1;
        if (yy + 3 <= a[y]) right[++rcnt] = s2;
        if (xx + 1 <= a[x] && yy + 1 <= a[y]) right[++rcnt] = s3;
    }
}

int main() {
    read(n);
    rep(i, 1, n) read(a[i]);
    m = (n * (n - 1)) >> 1;
    // 预处理每一局是哪两支队伍
    for (int i = 1, cnt = 0; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j) {
            xgo[++cnt] = i;
            ygo[cnt] = j;
        }
    dfs1(0, 1, m >> 1);
    dfs2(0, (m >> 1) + 1, m);
    rrep(i, n, 1) over = over * 100 + a[i];
    std::sort(right + 1, right + rcnt + 1);
    int ans = 0;
    rep(i, 1, lcnt) {
        long long r = over - left[i];
        std::pair<long long *, long long *> res = std::equal_range(right + 1, right + rcnt + 1, r);
        ans += res.second - res.first;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Vanyun (赞：4)

## 题意

$n$个队伍两两比赛。

赢了加$3$分，平局各加$1$分，输了不得分。

## 思路

数据范围很小，直接搜索。

因为只需要两两比赛，所以只需枚举一半的比赛。

但$n\leq8$，即使只枚举一半也有24场比赛的结果需要枚举。

然而每场比赛都有$3$种结果，也就是$3^{24}$，肯定过不了。

考虑剪枝。

对于这一队当前的分数，如果以后的比赛全赢也小于最后的分数，那状态不合法。

相应的，如果以后比赛全输，该队分数仍然大于最后的分数，状态也不合法。

如果到了该队的最后一场比赛，与目标分数的差值为$2$，那么这个时候该队无论是输是赢，都无法凑出$2$的分数来，那么直接剪掉即可。

三个剪枝~~加口氧气~~就可以过了这道题啦qwq。

## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

template<typename temp>
temp read(temp& x){
	x = 0; temp f = 1; char ch;
	while(!isdigit(ch = getchar())) (ch == '-') and (f = -1);
	for(x = ch^48; isdigit(ch = getchar()); x = (x<<3)+(x<<1)+(ch^48));
	return x *= f;
}
template <typename temp, typename ...Args>
void read(temp& a, Args& ...args){read(a), read(args...);}

const int maxn = 1e1+10;

int n, ans, fin[maxn], score[maxn];

void dfs(int now, int vs){
	if(score[now] > fin[now]) return;
	if(score[now]+(n-vs+1)*3 < fin[now]) return;
	if(now == n and fin[now] == score[now]) return (void)(ans ++);
	if(vs == n){
		int t = fin[now]-score[now];
		if(t == 2) return;
		int num = !t ? 3 : (t == 1 ? 1 : 0);
		score[vs] += num;
		return dfs(now+1, now+2), (void)(score[vs] -= num);
	}
	score[now] += 3, score[vs] += 0, dfs(now, vs+1), score[now] -= 3, score[vs] -= 0;
	score[now] += 1, score[vs] += 1, dfs(now, vs+1), score[now] -= 1, score[vs] -= 1;
	score[now] += 0, score[vs] += 3, dfs(now, vs+1), score[now] -= 0, score[vs] -= 3;
	return;
}

signed main(){
	read(n);
	for(int i = 1; i <= n; i ++) read(fin[i]);
	dfs(1, 2);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：3)

这其实是[这题](https://www.luogu.com.cn/problem/P3230)的弱化版，下面给出的做法两题均能通过
首先显然想到的是暴力搜索，爆搜的方式就是 1v2->1v3...->1vN，然后 2V3...直至结尾。

然后很明显要剪枝，我们用 `dfs(nowt,nowm)` 表示现在是编号为 `nowt` 的战队打编号为 `nowm` ， `now[x]` 表示编号为 `x` 的战队的当前得分， `a[x]` 表示编号为 `x` 的战队的最终得分。给出下面几个剪枝方案：
1. 如果这个现在的得分超过了这个队的最终得分，因为即使输了也不会扣分，所以无论如何都无法满足最终的得分，那么此时应该退出。

	```cpp
 	  if (now[nowt] > a[nowt]) return;
	```
2. 如果此时的得分少的可怜，即使后面全赢这个队伍也得不到预期得分，那么此时应该退出。

	```cpp
    if(now[nowt] + (n - nowm + 1) * 3 < a[nowt]) return 0 ;
   ```
下面的剪枝就比较难想了。

3. 记忆化，这题很重要的性质就是如果人数和分数一定，那么方案数也一定，和每个人的具体得分无关，用哈希存储之后记忆化。
	
	``` cpp
	if(nowm > n)  
		{
			for(int i = nowt + 1 ; i <= n ; i ++) hashh[i] = a[i] - now[i] ;
			sort(hashh + nowt + 1 , hashh + n + 1 , cmp) ;
			ll ha = 0 ;
			for(int i = nowt + 1 ; i <= n ; i ++)	ha = ha * 97 + hashh[i] ; 
			if(hash.find(ha) != hash.end()) return hash[ha] ;
			else return hash[ha] = dfs(nowt + 1 , nowt + 2) ;  
		}
	```
4. 如果总得分是 `sum`，胜利场数是 `win`，平局场数是 `draw`，那么有

	$$\begin{cases}win + draw = \dfrac{n \times (n+1)}{2}\\ 3 \times win+2\times draw=sum\end{cases}$$
    解得
    
	$$\begin{cases}win = sum-n \times (n+1)\\ draw=\dfrac {n \times(n-1)}{2}-win\end{cases}$$
	手动解得答案即可。

	```cpp
    win = sum - n * (n - 1) , draw = n * (n - 1) / 2 - win ;
   ```
   解出答案后我们就可以以此来控制这个队胜利和平局的场数，也就是说如果现在的胜利或者平局场数超过了最后的胜利或平局场数，应该退出。
   就像这样：
   ```cpp
   if(now[nowt] + 3 <= a[nowt] && win)
   ```
5. 先搜得分大的一定状态少，为什么呢，因为得分小的比较容易被得分大的影响，也就是先搜得分大的那么得分小的的状态一定比较少。

	也就是我们更愿意第一图的样子而不是第二图。
    
	![](https://cdn.luogu.com.cn/upload/image_hosting/51ro7iv9.png)    
	![](https://cdn.luogu.com.cn/upload/image_hosting/dkr5i9ps.png)
    
   所以先搜最终得分大的。

	```cpp
    sort(a + 1 , a + n + 1 , cmp) ;
   ```
至此，剪枝完毕，核心代码已经给出，剩下的实现难度不高。



---

## 作者：Aisaka_Taiga (赞：1)

~~打开标签可以看到可以用搜索~~

首先可以打出一个最朴素的暴力能得大约 48 分。

然后考虑优化一下，可以发现如果当前的队伍在赢一场就会超出输入就不可能是符合答案了就直接退出即可，这样就可以达到 68 分。

然后根据上面的优化可以看出如果前面的最终得分越小就可以剪掉更多的状态，所以我们可以把最终得分从小到大排个序，这样就有了 72 分。

知道了总得分和总场次 $\frac{n \times(n-1)}{2}$ 也就是 $\frac{1}{2}(n^{2}-n)$ 场，设总得分为 $s$，那么我们可以知道最多是可以赢 $s-2\times\frac{1}{2}(n^{2}-n)$ 也就是 $s-n^{2}+n$ 场，而最多可以打平的场次就是当前的总场次减去能打赢的场次，所以我们就可以根据这个的值来搜索，一旦有一个成为负数就可以直接退出，这样就可以得到 92 分。

当然这些剪枝是不足以让我们 A 掉这道题的，所以我们要用究极剪枝：记忆化。

那么怎么进行记忆化呢，我们可以用 hash 来处理。

如果当前剩余的后面一串的情况的方案数已经搜索过了的话就可以直接返回，这里建议用 map 来存放，查找的时候可以调用 map 的 find 函数。

代码：

```cpp
#include<bits/stdc++.h>//纯爆搜48分 
#define bug cout<<"WTF?"<<'\n'
#define int long long
#define HA 131//hash值的处理 
using namespace std;
int n,a[11],d[11],ans,s;//a存放最终每一个队伍的得分情况，d存放每一个队伍当前的得分，s是总得分 
int c[11],sx,sy;//c用于计算hash值，sx存放最多有几场赢，sy存放最多有几场平 
map<int,int>vis;//map用于存放已经遍历过的值 
int dfs(int x,int y)//xy是要比赛的两个队伍 
{
	int sum=0;//sum是最大的方案数 
	if(x>=n)return 1;//如果搜完了就返回有一种方案 
	if(y>n)//如果当前的y搜到头了，x与其他人的比赛搜完了 
	{
		if(d[x]!=a[x])return 0;//如果不相等就直接返回0 
		for(int i=x+1;i<=n;i++)//处理hash后AC 
		  c[i]=a[i]-d[i];//ci存放当前得分与最终得分的差值 
		sort(c+x+1,c+n+1);//排个序 
		int summ=0;//存放当前的序列的hash值 
		for(int i=x+1;i<=n;i++)//遍历每一个ci 
		  summ=summ*HA+c[i];//计算hash值 
		if(vis.find(summ)!=vis.end())return vis[summ];//如果当前剩余情况已经搜过了就直接返回上次搜索的值 
		else return vis[summ]=dfs(x+1,x+2);//否则就继续往下搜并存下值 
	}
	if(d[x]+3<=a[x]&&sx)//如果加上后得分超出就不搜，并且当前的剩余胜场要大于0 
	d[x]+=3,sx--,sum+=dfs(x,y+1),d[x]-=3,sx++;//搜索，回溯 
	if(d[y]+3<=a[y]&&sx)//同理处理y赢的情况 
	d[y]+=3,sx--,sum+=dfs(x,y+1),d[y]-=3,sx++;
    if(d[x]+1<=a[x]&&d[y]+1<=a[y]&&sy)//同理处理xy打平的情况 
	d[x]+=1,d[y]+=1,sy--,sum+=dfs(x,y+1),d[x]-=1,d[y]-=1,sy++;
	return sum;//返回最终答案 
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i],s+=a[i];//输入计算总的分 
	sx=s-n*n+n;sy=(n*n-n)/2-sx;//根据推的式子计算 
	sort(a+1,a+n+1);//原理是排序后可以使优化一的作用更大 
	ans=dfs(1,2);//开始搜索 
	cout<<ans<<endl;//输出 
	return 0;//好习惯 
}
```


---

## 作者：Celtic (赞：1)

- 算法： 深度优先搜索（~~暴力~~（逃
- 观察到 $n\leq 8$，所以我们可以用搜索来解决这道题。
- 如果爆搜的话可以拿到 $84$ 分的好成绩~
- 但这是不够的，我们需要剪枝。
- 很明显，对于每场结束的比赛，双方的得分都是不减的，所以当前搜到的这个人如果得分要比他的最终得分大的话就可以剪枝。
- 从 IDA* 方面考虑，设当前搜到 $(x,y)$的比赛，假如 $x$ 和 $y~n$比赛全都胜利，得到的分将是 $now_x+3(n-y+1)$（ $now_i$ 表示 $i$ 搜索到现在得分是多少）。
- 加上这两个剪枝，根据你的卡常水平可以拿到 $92-96$ 分的高分。
- 接下来考虑优化搜索顺序，显然先搜最终得分大的一定状态少，因为得分少的会被得分大的影响，从大的开始搜后面的无用状态会尽可能的少，所以我们按从大到小的顺序将得分排序进行搜索。
- 然后，我们可以发现胜场和负场对总分来说是等价的，贡献都是 $3$ ，平场贡献是 $2$。我们还知道总得分（$\sum_{i=1}^{n}a_i$）和总场数（ $\frac{n\times(n+1)}{2}$）。于是我们可以设胜场（负场）一共有 $x$ 场，平场一共有 $y$ 场，可以列出方程组
$$
\begin{cases} 
3x+2y=\sum_{i=1}^n a_i\\ 
x+y=\frac{n\times(n-1)}{2}\\  
\end{cases} 
$$

- 解之可得
$$
\begin{cases} 
x=-n\times(n-1)+\sum_{i=1}^n a_i\\ 
y=\frac{3n\times(n-1)}{2}-\sum_{i=1}^na_i\\  
\end{cases} 
$$

- 现在我们还能优化吗？
- 答案是：能。
- 有个东西叫做记忆化搜索，就是把搜到的结果记录下来，下次如果再要搜同样的状态时直接用就可以了。
- 那对于这道题，剩余需要得的分数数组相同时，搜索的结果是一定的，所以用哈希记录一下就可以了。
- 至此，所有剪枝完毕。
  
$\sf{Code}$
```cpp
#include<bits/stdc++.h>
#include<tr1/unordered_map>
#define re register
#define N 101001
#define MAX 2001
#define inf 1e18
using namespace std; 
typedef int ll;
typedef double db;
const ll mod=1000000007;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();};
	ret=pd?-ret:ret;
	return;
}
ll n,a[N],ans,allx,ally,val[N],st[N];
ll b[MAX][MAX];
map<ll,ll>mp;
inline bool cmp(re ll x,re ll y)
{
	return x>y;
}
inline ll dfs(re ll x,re ll y,re ll nowx,re ll nowy)
{
	if(x==n)
		return 1;
	if(val[x]+(n-y+1)*3<a[x])
		return 0;
	if(y>n)
	{
		for(re int i=x+1;i<=n;i++)
			st[i]=a[i]-val[i];
		sort(st+x+1,st+n+1);
		re ll now=0;
		for(re int i=x+1;i<=n;i++)
			now=now*28+st[i];
		if(mp.find(now)!=mp.end())
			return mp[now];
		return mp[now]=dfs(x+1,x+2,nowx,nowy);
	}
	re ll ret=0;
	if(val[y]+3<=a[y]&&nowx)
		val[y]+=3,ret+=dfs(x,y+1,nowx-1,nowy),ret%=mod,val[y]-=3;
	if(val[x]+1<=a[x]&&val[y]+1<=a[y]&&nowy)
		val[x]++,val[y]++,ret+=dfs(x,y+1,nowx,nowy-1),ret%=mod,val[x]--,val[y]--;
	if(val[x]+3<=a[x]&&nowx)
	val[x]+=3,ret+=dfs(x,y+1,nowx-1,nowy),ret%=mod,val[x]-=3;
	return ret;
}
ll sum;
signed main()
{
	read(n);
	for(re int i=1;i<=n;i++)
		read(a[i]),sum+=a[i];
	allx=sum-n*n+n;
	ally=((sum-3*allx)>>1);
	sort(a+1,a+n+1,cmp);
	printf("%d\n",dfs(1,2,allx,ally));
	exit(0);
}
```

---

## 作者：简单666 (赞：1)

表示这题卡常数  
首先讲讲48分的裸爆搜  
枚举每一个组合，然后依次枚举每一个组合谁赢或者平手，最后判断合法，时间复杂度O(3^(n*(n-1)/2)*n)  
然后直接讲正解了  
正解呢，就是剪枝(滑稽)  
剪枝1.判断当前解是否合法，不合法return(废话)  
剪枝2.如果搜索的过程中发现一个人的得分已经超过了，直接return  
剪枝3.如果有一个人就算是后面一直胜利的得分还是超不过score[i] 那么直接return  
剪枝4.我们已知了总的得分和总的局数，可以算出胜利了多少场，平手了多少场  
具体的 我们可以设x场胜利，y场平手  
3x+2y=totsum  
x+y=C(n,2) 初中数学。。。  
如果搜索过程中胜利的次数或者平手的次数大于总的次数，直接return  
-----------
以上剪枝实测只能拿92分，接下来要放大招了  
我们可以考虑一下搜索过程中的状态，f[第i盘][第一个人得分][第二个人得分][第三个人得分]...  
这个搜索的过程中可能遇到状态相同的，那么直接上记忆化搜索！！！  
具体的，我们可以弄C(n,2)个unordered_map  
然后把后面的状态用字符串表示，依次表示第i个人的得分。  
最后把这个字符串hash一下存起来就ok了  
切记！！！注意优化常数！！！  
最后上代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull T=11;
struct node{
	int first,second;
};
node al[100];
int n,score[100],cnt;
int now[100];
inline bool check(int fir,int sec){
	return now[fir]<=score[fir]&&now[sec]<=score[sec];
}
inline bool checkans(){
	for(int i=1;i<=n;i++){
		if(now[i]!=score[i])return false;
	}
	return true;
}
int tot[100];
int lis[10][2];
inline void init(){
	lis[1][0]=1,lis[1][1]=1;
	lis[2][0]=0,lis[2][1]=3;
	lis[3][0]=3,lis[3][1]=0;
}
int totsum,nowsum;
int pingshou,shengli;
int nowpingshou,nowshengli;
unordered_map<ull,int> mp[100];
unordered_map<ull,bool> caled[100];
ull calhash(int dep){
	ull ret=0;
	for(int i=1;i<=n;i++){
		ret=ret*T+((now[i]/10)%10+'0'+1);
		ret=ret*T+(now[i]%10+'0'+1);
	}
	return ret;
}
int dfs(int dep){
	ull hs=calhash(dep);
	if(caled[dep][hs])return mp[dep][hs];
	for(int i=1;i<=n;i++){
		if(now[i]>score[i])return 0;
	}
	for(int i=1;i<=n;i++){
		int rest=score[i]-now[i];
		int resttot=n-1-tot[i];
		if(3*resttot<rest)return 0;
	}
	if(nowsum>totsum||(nowsum==totsum&&dep<=n))return 0;
	int restsum=totsum-nowsum;
	if(2*(cnt-dep+1)>restsum)return 0;
	if(3*(cnt-dep+1)<restsum)return 0;
	if(nowshengli>shengli||nowpingshou>pingshou)return 0;
	int fir=al[dep].first,sec=al[dep].second;
	if(dep>cnt){
		if(!checkans())return 0;
		return 1;
	}
	int res=0;
	tot[fir]++,tot[sec]++;
	for(int i=1;i<=3;i++){
		now[fir]+=lis[i][0],now[sec]+=lis[i][1];
		nowsum+=lis[i][0]+lis[i][1];
		if(lis[i][0]==3||lis[i][1]==3){
			nowshengli++;
		}else{
			nowpingshou++;
		}
		if(check(fir,sec)){
			res+=dfs(dep+1);
		}
		if(lis[i][0]==3||lis[i][1]==3){
			nowshengli--;
		}else{
			nowpingshou--;
		}
		now[fir]-=lis[i][0],now[sec]-=lis[i][1];
		nowsum-=lis[i][0]+lis[i][1];
	}
	tot[fir]--,tot[sec]--;
	caled[dep][hs]=true;
	mp[dep][hs]=res;
	return res;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>score[i];
		totsum+=score[i];
	}
	sort(score+1,score+1+n);
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			al[++cnt]=(node){i,j};
		}
	}
	init();
	pingshou=3*cnt-totsum;
	shengli=totsum-2*cnt;
	cout<<dfs(1)<<endl;
	return 0;
}
```


---

## 作者：Others (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/P3230)

很久以前的~~搜索剪枝里的一道题~~。

这题乍一看和组合数学挺像的，排排序，算算有多少个胜利，多少个平局，最后乱搞一下，但是瞎搞了一会儿，似乎不行。

这题普通的搜索显然只能挨个枚举：`dfs(i,j)` 第 $i$ 个人和第 $j$ 个人比赛，且第 $i$ 个人与 $[1,j)$ 里的人比完了，搞就行了。

这样应该没有多少分，想想怎么剪枝：

- 可行性剪枝，有两个，如果当前搜索到的分数已经超过了题目给的分数，那肯定无解；如果他与剩下的人比都赢了还不够的话，也是无解，这样好像可以多水一点点分。
- 记忆化搜索，记忆化搜索没有他做不到，只有你想不到（~~除非本身就无解~~）。这题的记忆化很正常，我们先来回忆一下如果可以记忆化的条件：当前的状态可以记录，这题的状态显然是每个队得到的分数（剩下的也可以），因为记忆化的精髓在于它不用管前面的，他只记后面的，于是我们将状态定义为每个队剩下的分数，如果这东西定了，那这个状态肯定也定了，就可以记忆化了。这里我们可以打 hash（~~其实打个键值丰富一点的平衡树也不是不可以~~。）
- 乱搞剪枝，记得开头说的数学吗？在最开始用数学搞的时候，我们能很轻易的算出有一方赢了的局数（$x$）和平局的局数（$y$）：$3x+2y=sum$ 和 $x+y=n$，$sum$ 和 $n$ 都是已知的，这样就可以算了（推荐手算一下，~~如果无聊可以跑高斯消元~~）。
- 这是我同学在某个地方提到的乱搞剪枝：从大到小排序，优化搜索顺序（不无道理）。

最后贴上我这丑陋的代码。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define ll int
#define mod 1000000007
using namespace std;
ll sc[15],a[15];
ll n,scc[15]={ };
ll cnt1,cnt2;
map<ull,ll> Map;
ull Hash(int x){
	for(int i=x+1;i<=n;i++) a[i]=sc[i]-scc[i];
	stable_sort(a+x+1,a+n+1);
    ull tot=0;
    for(int i=x+1;i<=n;i++) tot=tot*131+a[i];
    return tot;
}
ll dfs(int i,int j){
	if(i==n+1) return 1;
	if(scc[i]>sc[i]) return 0;
	if(sc[i]-scc[i]>(n-j+1)*3) return 0; 
	if(j==n+1&&scc[i]<sc[i]) return 0;
	if(j==n+1&&scc[i]==sc[i]) {
		ull pos=Hash(i);
		if(Map.count(pos)) return Map[pos];
		else{
			ll sop=dfs(i+1,i+2);
			return Map[pos]=sop;
		}
	}
	ll pos=0;
	if(cnt1){
	    cnt1--;
    	scc[i]+=3;
    	pos+=dfs(i,j+1);
    	scc[i]-=3,scc[j]+=3;
    	pos+=dfs(i,j+1);
		scc[j]-=3,cnt1++;
	}
	if(cnt2){
	    cnt2--;
    	scc[i]+=1,scc[j]+=1;
    	pos+=dfs(i,j+1);
    	scc[i]-=1,scc[j]-=1;
    	cnt2++;
	}
	return pos%mod;
}
bool cmp(int x,int y){
	return x>y;
}
int main() {
	cin >> n;
	ll pp=0;
	for(int i=1;i<=n;++i){
		cin >> sc[i];
		pp+=sc[i];
	}
	sort(sc+1,sc+n+1,cmp);
	cnt1=pp-n*n+n;
	cnt2=(pp-3*cnt1)/2;
	cout << dfs(1,2)%mod;
	return 0;
}
```

---

## 作者：nofind (赞：0)

题意：

https://www.luogu.org/problemnew/show/P3154

重题：(https://www.luogu.org/problemnew/show/P3230)

输出取个mod就可以了

省选重题~

首先的想法肯定是枚举每一场比赛的结果,判断是否合法(48pts)：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=8;
int n,tot,ans;
int s[maxn],tmps[maxn];
bool check()
{
    for(int i=1;i<=n;i++) if(s[i]!=tmps[i]) return 0;
    return 1;
}
void dfs(int step,int x,int y)
{
    if(step==tot)
    {
        if(check()) ans++;
        return;
    }
    tmps[x]+=3;
    if(y==n) dfs(step+1,x+1,x+2);
    else dfs(step+1,x,y+1);
    tmps[x]-=3;
    tmps[x]++,tmps[y]++;
    if(y==n) dfs(step+1,x+1,x+2);
    else dfs(step+1,x,y+1);
    tmps[x]--,tmps[y]--;
    tmps[y]+=3;
    if(y==n) dfs(step+1,x+1,x+2);
    else dfs(step+1,x,y+1);
    tmps[y]-=3;
}
int main()
{
    scanf("%d",&n);tot=n*(n-1)/2;
    for(int i=1;i<=n;i++) scanf("%d",&s[i]);
    dfs(0,1,2);
    printf("%d",ans);
    return 0;
}
```
试了暴力对了之后开始剪枝：

老套路

可行性剪枝:当前这一队全赢也到不了真实分,搜完这一队后分数是否达到,大于就退出,剩下的场全赢也到不了总分(88pts)

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=8;
int n,tot,ans,sum,num;
int s[maxn],tmps[maxn];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') res=res*10+c-'0',c=getchar();
    return res*f;
}
inline bool check()
{
    for(register int i=1;i<=n;i++) if(s[i]!=tmps[i]) return 0;
    return 1;
}
void dfs(int step,int x,int y)
{
    if(step==tot)
    {
        if(check()) ans++;
        return;
    }
    if(tmps[x]+3*(n-y+1)<s[x]) return;
    if(tmps[x]>s[x]) return;
    if(3*(tot-step+1)<sum-num)return;
    if(tmps[x]+3<=s[x])
    {
        tmps[x]+=3;num+=3;
        if(y==n) {if(tmps[x]==s[x]) dfs(step+1,x+1,x+2);} 
        else 
        {
            dfs(step+1,x,y+1);
        }
        tmps[x]-=3;num-=3;
    }
    if(tmps[x]+1<=s[x]&&tmps[y]+1<=s[y])
    {
        tmps[x]++,tmps[y]++;num+=2;
        if(y==n) {if(tmps[x]==s[x]) dfs(step+1,x+1,x+2);} 
        else dfs(step+1,x,y+1);	
        tmps[x]--,tmps[y]--;num-=2;
    }
    if(tmps[y]+3<=s[y])
    {
        tmps[y]+=3;num+=3;
        if(y==n) {if(tmps[x]==s[x]) dfs(step+1,x+1,x+2);} 
        else dfs(step+1,x,y+1);
        tmps[y]-=3;num-=3;
    }
}
int main()
{
    n=read();tot=n*(n-1)/2;
    for(register int i=1;i<=n;i++) s[i]=read(),sum+=s[i];
    sort(s+1,s+n+1);
    dfs(0,1,2);
    printf("%d",ans);
    return 0;
}
```
不会了点开题解又学了两种剪枝：

1.数学方法:

设胜场sx,平局sy,可得：

```
sx+sy=n*(n-1)/2
3*sx + 2*sy =sum (sigma(score))
```
可拿来限制

2.记忆化搜索(**划重点**)

发现每一队搜完后不同的搭配可能产生相同的结果,这时我们直接用之前已经搜过的就可以了,开个map存一下相同的局面。


(100pts)code:

```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int base=23;
const ull mod=1e9+7;
const int maxn=15;
int n,sum,sx,sy;
int tmps[maxn],b[maxn],s[maxn];
map<ull,ull> mp;
bool cmp(int x,int y){return x>y;}
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') res=res*10+c-'0',c=getchar();
    return res*f;
}
ull dfs(int x,int y)
{
    ull res=0;
    if(x==n) return 1;
    if(tmps[x]+3*(n-y+1)<s[x]) return 0;
    if(y>n)
    {
        for(int i=x+1;i<=n;i++) b[i]=s[i]-tmps[i];
        sort(b+x+1,b+n+1);
        ull H=0;
        for(int i=x+1;i<=n;i++) H=H*base+b[i];
        if(mp.find(H)!=mp.end()) return mp[H];
        else return mp[H]=dfs(x+1,x+2);
    }
    if(tmps[x]+3<=s[x]&&sx)
    {
        tmps[x]+=3;sx--;
        res+=dfs(x,y+1);
        tmps[x]-=3;sx++;
    }
    if(tmps[x]+1<=s[x]&&tmps[y]+1<=s[y]&&sy)
    {	
        tmps[x]++,tmps[y]++;sy--;
        res+=dfs(x,y+1);
        tmps[x]--,tmps[y]--;sy++;
    } 
    if(tmps[y]+3<=s[y]&&sx)
    {
        tmps[y]+=3;sx--;
        res+=dfs(x,y+1);
        tmps[y]-=3;sx++;
    }
    return res;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++) s[i]=read(),sum+=s[i];
    sx=sum-n*n+n,sy=n*(n-1)/2-sx;
    sort(s+1,s+n+1,cmp);
    printf("%llu",dfs(1,2));
    return 0;
}

```



---


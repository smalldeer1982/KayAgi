# 肝活动

## 题目背景

Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。

## 题目描述

Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。

这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。


## 说明/提示

对于 $0\%$ 的数据，与测试数据完全相同。

对于 $20\%$ 的数据，满足 $n \le 5$。

对于 $40\%$ 的数据，满足 $n \le 9$。

对于 $70\%$ 的数据，满足 $n \le 15$。

另有 $10\%$ 的数据满足 $\sum\limits^{n}_{i=1} T_i < t$。

对于 $100\%$ 的数据，满足 $n \le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。

## 样例 #1

### 输入

```
3 2 10
BokutachiwaHitotsunoHikari 3 8
Korekara 1 2
SnowHalation 2 5
```

### 输出

```
6
SnowHalation
BokutachiwaHitotsunoHikari
Korekara
```

## 样例 #2

### 输入

```
2 1 2
AoizoraJumpingHeart 1 2
TimeLapse 2 4```

### 输出

```
No Answer```

# 题解

## 作者：qinyubo (赞：5)

状压 DP。

首先特判能不能在规定时间内打完所有的歌，即 $\sum_{i=1}^nT_i\le t$。若否，则无解。

设 $f_S$ 表示集合 $S$ 内的歌打完之后的最大收益，那么就有转移式：

$$f_S=\max\limits_{i\in S}\left(f_{S\setminus \{i\}}+\max(M_i-\sum\limits_{i\in S}T_i,0)\right)$$

即，枚举最后一个打完的歌是哪一首，然后加上获得的分数。

由于题目要求字典序最小，同时维护在分数最高的情况下，字典序最小的决策是什么就行了。复杂度 $O(2^nn^2)$。

我这里偷懒了，直接使用 $\texttt{std::string}$ 的字典序比较。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace QYB {
  int n, m, t, sum, a[25], f[25];
  char name[25][55];
  int ans[1 << 22];
  string s[1 << 22];
  int main() {
    scanf("%d%d%d", &n, &m, &t);
    for (int i = 0; i < n; i++) {
      scanf("%s%d%d", name[i], a + i, f + i);
      sum += a[i];
    } if (sum > t) return !printf("No Answer\n");
    for (int i = 1; i < 1 << n; i++) {
      int sum = 0; ans[i] = -1; s[i] = "z";
      for (int j = 0; j < n; j++) {
        if (i >> j & 1) sum += a[j];
      } for (int j = 0; j < n; j++) {
        if (i >> j & 1) {
          if (ans[i ^ 1 << j] == -1) continue;
          if (ans[i ^ 1 << j] + max(0, f[j] - sum) > ans[i]) {
            ans[i] = ans[i ^ 1 << j] + max(0, f[j] - sum);
            s[i] = s[i ^ 1 << j] + char(j + 65);
          } else if (ans[i ^ 1 << j] + max(0, f[j] - sum) == ans[i]) {
            s[i] = min(s[i], s[i ^ 1 << j] + char(j + 65));
          }
        }
      }
    } if (ans[(1 << n) - 1] < m) return !printf("No Answer\n");
    printf("%d\n", ans[(1 << n) - 1]);
    for (auto i: s[(1 << n) - 1]) {
      printf("%s\n", name[i - 65]);
    } return 0;
  }
} int main() { return QYB::main(); }
```

---

## 作者：cff_0102 (赞：3)

~~今天刷状压 DP 题，发现有道题很熟悉，点进来一看才发现之前我在这题的讨论区修 markdown，今天正好回来把这题 A 了~~。

数据范围明示状压 DP。

设 $dp_S$ 为打 $S$ 中的所有歌能获得的最高分数。转移的时候，枚举最后一个打的歌，取最后分数的最大值就可以了。另外可以用一个数组记录下打 $S$ 中的所有歌耗费的时间，可以在 DP 的时候顺便转移，就不需要在每个状态都全部再加一遍了。

题目要求字典序最小的顺序，可以用一个字符串数组 $s$，在 $dp_S$ 取最大值的时候同时对应修改 $s_S$，为什么用字符串呢，因为 `std::string` 十分方便的提供了可以比较两个字符串字典序的方法，并且题目中 $n\le22$ 的话只需要一个 `char` 的大小就能记录下打的是什么歌，在记录的时候转 `char` 即可，最后输出的时候也能直接用，十分方便。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mn,T;
char name[25][50];
int t[25],m[25];
int dp[(1<<22)];
string s[(1<<22)];
int stime[(1<<22)];
//void print(int S){
//	for(int i=1;i<=n;i++){
//		cout<<(S&(1<<(i-1)));
//	}
//}
//void prints(int S){
//	for(int i=0;i<s[S].length();i++){
//		cout<<name[s[S][i]]<<" ";
//	}
//}
int main(){
	//ios::sync_with_stdio(0);cin.tie(0);
	//cin>>n>>mn>>T;
	scanf("%d %d %d",&n,&mn,&T);
	int ts=0;
	for(int i=1;i<=n;i++){
		//cin>>name[i]>>t[i]>>m[i];
		scanf("%s %d %d",name+i,t+i,m+i);
		ts+=t[i];
	}
	if(ts>T)printf("No Answer"),exit(0);
	int temp0=(1<<n);
	for(int S=1;S<temp0;S++){
		for(int i=1;i<=n;i++){
			if(S&(1<<(i-1))){
				int last=S^(1<<(i-1));
				if(!stime[S])stime[S]=stime[last]+t[i];
				int sum=stime[last];
				int temp=dp[last]+max(0,m[i]-(sum+t[i]));
				if(temp>dp[S]){
					dp[S]=temp;
					s[S]=s[last]+(char)i;
				}else if(temp==dp[S]){
					s[S]=min(s[S],s[last]+(char)i);
				}
			}
		}
		//print(S);cout<<" "<<dp[S]<<" ";prints(S);cout<<endl;
	}
	int temp=(1<<n)-1;
	int ans=dp[temp];
	if(ans<mn)printf("No Answer"),exit(0);
	printf("%d\n",ans);
	int temp2=s[temp].length();
	for(int i=0;i<temp2;i++){
		printf("%s\n",name[s[temp][i]]);
	}
	return 0;
}
```

在第 $16$ 个测试点 TLE 了好一会，卡了半天的常，最后发现只要把原代码中的 `if(s[S]>s[last]+(char)i)s[S]=s[last]+(char)i;` 改成 `s[S]=min(s[S],s[last]+(char)i);` 就能[瞬间压进 $900\text{ms}$ 内](https://www.luogu.com.cn/record/176706591)。

---

## 作者：xie_lzh (赞：0)

数据范围一眼状压。

考虑设 $dp_S$ 为选择了集合 $S$ 的答案，可以直接通过集合的总时间和下一个的奖励时间来进行答案的转移。

注意到我们需要使答案的字典序最小。

从后往前使得最前面的最小即可。

复杂度 $\Theta(2^n\times n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=22;
int dp[1<<N][N],n,m,t,pre[1<<N],val[1<<N];
struct node
{
    string s;
    int m,t;
}pos[N];
int h[N];
int sum(int x)
{
    int nsum=0;
    for(int S=x;S;S-=S&(-S))
        nsum+=pos[__lg(S&(-S))].t;
    return nsum;
}
void ckmax(int S,int p,int T)
{
    int nval=val[S]+max(pos[p].m-sum(S),0);
    if(val[T]<nval||val[T]==nval&&pre[T]>p)
        val[T]=nval,
        pre[T]=p;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>m>>t; int nsum=0;
    for(int i=0;i<n;i++)
        cin>>pos[i].s>>pos[i].t>>pos[i].m;
    int all=(1<<n)-1;
    val[all]=0;
    memset(pre,0x3f,sizeof pre);
    if(sum(all)>t)
    {
        cout<<"No Answer\n";
        return 0;
    }
    for(int i=all;i>0;i--)
    {

        for(int S=i;S;S-=(S&(-S)))
        {
            int p=__lg(S&(-S));
            ckmax(i,p,(i^(1<<p)));
        }
    }
    int ans=0;
    for(int i=0;i<n;i++)
    {
        val[1<<i]+=pos[i].m-pos[i].t;
        if(val[1<<i]>val[1<<ans])
            ans=i;
    }
    if(val[1<<ans]<m)
    {
        cout<<"No Answer\n";
        return 0;
    }
    cout<<val[1<<ans]<<'\n';
    int now=1<<ans,u=ans;
    while(now!=all)
    {
        cout<<pos[u].s<<'\n';
        int p=pre[now];
        now=now|(1<<p); u=p;
    }
    cout<<pos[u].s<<'\n';
}

```

---


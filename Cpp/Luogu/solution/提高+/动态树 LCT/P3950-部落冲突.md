# 部落冲突

## 题目背景

在一个叫做 Travian 的世界里，生活着各个大大小小的部落。其中最为强大的是罗马、高卢和日耳曼。他们之间为了争夺资源和土地，进行了无数次的战斗。期间诞生了众多家喻户晓的英雄人物，也留下了许多可歌可泣的动人故事。

![](http://img4.dwstatic.com/coc/1602/320370032694/1456415099616.jpg)

其中，在大大小小的部落之间，会有一些道路相连，这些道路是 Travian 世界里的重要枢纽，简单起见，你可以把这些部落与部落之间相连的道路看作一颗树，可见每条道路对于 Travian 世界的重要程度。有了这些道路，建筑工人就可以通过这些道路进行友好外交啦。

然而，事情并不会像想象的那样美好，由于资源的匮乏，相邻的部落（由一条道路相连的部落）之间经常会发生大大小小的冲突事件，更有甚者，会升级为部落之间的大型战争。

为了避免误伤，每当两个相邻的部落之间发生大型战争之时，这两个部落间的道路是不允许通行的，对于一些强大的部落，甚至能与多个相邻的部落同时开战，同样的，这些战争地带的道路十分危险，是不可通行的。

天下之势，分久必合，当两个部落经历了不打不相识的苦战之后，他们可以签订停战协议（暂时停战，以后依旧可能再次开战），这样，两个部落之间的道路又会重新恢复为可通行状态，建筑工人们又可以经过此地购买最新的大本营设计图纸来强大自己的部落了。

为了简单起见，我们把各大战争事件按发起的时间顺序依次编号（最先发起的战争编号就为 $1$，第二次战争编号就为 $2$，以此类推），当两个部落停战之时，则会直接告诉你这场战争的编号，然后这场战争就载入了史册，不复存在了，当然，这并不会影响到其他战争的编号。

建筑工人十分讨厌战争，因为战争，想从一个部落到另一个部落进行友好交流的建筑工人可能就此白跑一趟。所以，在他们出发之前，都会向你问问能不能到达他们想去的部落。


## 题目描述

简单起见，你就是要处理下面三件事，所有的事件都是按照时间顺序给出的。

1. `Q p q` 从第 $p$ 个部落出发的建筑工人想知道能否到达第 $q$ 个部落了，你要回答的便是 `Yes` / `No`，注意**大小写**。

2. `C p q` 第 $p$ 个部落与第 $q$ 个部落开战了，保证他们一定是相邻的部落，且目前处于停战（未开战）状态。

3. `U x` 第 $x$ 次发生的战争结束了，它将永远的被载入史册，不复存在（保证这个消息不会告诉你多次）


## 说明/提示

对于 $30\%$ 的数据，$n, m\leq 6\times10^3$。

对于另 $30\%$ 的数据，保证部落之间的地理关系是一条链，且 $i$ 与 $i + 1$ 之间有一条道路。

对于另 $30\%$ 的数据，$n, m\leq 10^5$。

对于 $100\%$ 的数据，$1\leq n, m\leq 3\times10^5$。


## 样例 #1

### 输入

```
5 9
1 2
2 3
3 4
4 5
Q 1 4
C 2 1
C 4 3
Q 3 1
Q 1 5
U 1
U 2
C 4 3
Q 3 4```

### 输出

```
Yes
No
No
No```

## 样例 #2

### 输入

```
10 10
1 2
1 3
3 4
3 5
1 6
3 7
1 8
2 9
5 10
C 8 1
Q 6 1
C 2 1
Q 2 10
U 1
C 9 2
C 7 3
U 3
Q 6 7
Q 1 10```

### 输出

```
Yes
No
No
Yes```

## 样例 #3

### 输入

```
20 20
1 2
1 3
2 4
1 5
1 6
4 7
1 8
2 9
5 10
1 11
2 12
7 13
1 14
1 15
11 16
4 17
3 18
18 19
8 20
Q 13 5
C 14 1
C 16 11
U 1
U 2
C 20 8
Q 7 1
C 7 4
Q 17 17
Q 1 6
C 16 11
C 2 1
Q 16 2
U 3
U 5
U 6
C 2 1
C 6 1
C 13 7
C 11 1
```

### 输出

```
Yes
Yes
Yes
Yes
No
```

# 题解

## 作者：hyfhaha (赞：33)

# 树链剖分吼啊
## ~~一看就看出是LCT模板题啦~~
# 前记
见这么多人写LCT，却很少人写树链剖分，于是我就来一发树链剖分（其实是因为自己不会LCT）

本蒟蒻的写法和诸位写树链剖分的大神有点不同

# 思路
树链剖分，简单题

## 操作
操作1：'C' 操作 ： 简单的说就是把x到y的边cut掉，题目又保证x,y相邻，~~肯定直接LCT啦~~，那么我们就可以将x，y的所以边权加1，表示那些边多了一次战争。

操作2：'U' 操作 ： 简单的说就是把之前cut的边加回来，我们只需要记录之前每一次战争的两个部落编号，战争结束就把那两个部落直接的边权减去1就可以了，表示那些边少了一次战争。

操作3：'Q' 操作 ： 简单的说就是询问x,y之间的边权和，如果是0，表示经过的边一次战争也没有，就是yes；不然就有战争，是no。

这么一看，思路是不是很简单。

但还有些问题，树链剖分是针对点权的，我们如何转换为边权呢？

## 点权转边权
方法有很多，例如在每一条边都多加1个点，在加的那个点上记录权值。

但是，这里讲一下我的做法：**直接忽略**！

在一颗树内，点有n个，边有n-1条，所以我们可以让每一条边对应到点上，对应方式就是边的编号是边上两点深度小的点编号。

那么就只会有根是没有边对应的所以我们可以假设有一条编号为根的边和根相连。

将x,y的边权加就等于将x,y的点权全部加，然后LCA(x,y)的点权减回去（可以自己画图尝试一下）

查询x,y的边权和就等于将x,y的点权全部累加，然后减去LCA(x,y)的点权（可以自己画图尝试一下）

于是我们整个思路就出来了(这样就不用改线段树啦>w< )

# 代码
```cpp
#include<bits/stdc++.h>
#define maxn 4000001
#define L(x) (x<<1)
#define R(x) ((x<<1)|1)
using namespace std;
int tree[maxn],tag[maxn];
int rev[maxn],dep[maxn],size[maxn],seg[maxn],top[maxn],son[maxn],father[maxn];
int n,m,root,x,y,z,a[maxn],visx[maxn],visy[maxn],tot;
int cnt,from[maxn],to[maxn],Next[maxn],head[maxn];
char mode;
void add(int x,int y){
	cnt++;
	from[cnt]=x;to[cnt]=y;
	Next[cnt]=head[x];head[x]=cnt;
}
//线段树
void pushdown(int node,int begin,int end){
	if(tag[node]){
		tag[L(node)]+=tag[node];
		tag[R(node)]+=tag[node];
		int mid=(begin+end)>>1;
		tree[L(node)]+=(mid-begin+1)*tag[node];
		tree[R(node)]+=(end-mid)*tag[node];
		tag[node]=0;
	}
}
void update(int node,int begin,int end,int x,int y,int val){
	if(begin>y||end<x)return;
	if(begin>=x&&end<=y){
		tag[node]+=val;
		tree[node]+=(end-begin+1)*val;
		return;
	}else{
		pushdown(node,begin,end);
		int mid=(begin+end)>>1;
		if(x<=mid)update(L(node),begin,mid,x,y,val);
		if(y>mid) update(R(node),mid+1,end,x,y,val);
		tree[node]=tree[L(node)]+tree[R(node)];
	}
}
int query(int node,int begin,int end,int x,int y){
	if(begin>y||end<x)return 0;
	if(begin>=x&&end<=y){
		return tree[node];
	}else{
		pushdown(node,begin,end);
		int mid=(begin+end)>>1,sum=0;
		if(x<=mid)sum+=query(L(node),begin,mid,x,y);
		if(y>mid) sum+=query(R(node),mid+1,end,x,y);
		return sum;
	}
}
//线段树
int dfs1(int x){						//树链剖分模板
	size[x]=1;
	dep[x]=dep[father[x]]+1;
	for(int i=head[x];i!=-1;i=Next[i]){
		int v=to[i],big=0;
		if(father[x]==v)continue;
		father[v]=x;
		big=dfs1(v);
		size[x]+=big;
		if(big>size[son[x]])son[x]=v;
	}
	return size[x]; 
}
void dfs2(int x){						//树链剖分模板
	if(son[x]){
		seg[son[x]]=++seg[0];
		top[son[x]]=top[x];
		rev[seg[0]]=son[x];
		dfs2(son[x]);
	}
	for(int i=head[x];i!=-1;i=Next[i]){
		int v=to[i];
		if(!top[v]){
			seg[v]=++seg[0];
			top[v]=v;
			rev[seg[0]]=v;
			dfs2(v);
		}
	}
}
void linkadd(int x,int y,int z){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
		update(1,1,seg[0],seg[fx],seg[x],z);
		x=father[fx];fx=top[x];
	}
	if(dep[x]>dep[y])swap(x,y);
	update(1,1,seg[0],seg[x],seg[y],z);
	update(1,1,seg[0],seg[x],seg[x],-z);			//LCA特殊处理
}
int linkquery(int x,int y){
	int fx=top[x],fy=top[y],ans=0;
	while(fx!=fy){
		if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
		ans+=query(1,1,seg[0],seg[fx],seg[x]);
		x=father[fx];fx=top[x];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=query(1,1,seg[0],seg[x],seg[y]);
	ans-=query(1,1,seg[0],seg[x],seg[x]);			//减LCA
	return ans;
}
int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);root=1;
	for(int i=1;i<=n-1;i++){
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(root);
	seg[root]=++seg[0];
	rev[seg[0]]=root;
	top[root]=root;
	dfs2(root);
	for(int i=1;i<=m;i++){
		scanf("%s",&mode);
		if(mode=='C'){
			scanf("%d%d",&x,&y);
			visx[++tot]=x;visy[tot]=y;		//记录每一次战争的两个部落
			linkadd(x,y,1);			//x到y的边权加1
		}
		if(mode=='U'){
			scanf("%d",&x);
			linkadd(visx[x],visy[x],-1);		//战争结束就减回去
		}
		if(mode=='Q'){
			scanf("%d%d",&x,&y);
			int q=linkquery(x,y);	//查询x到y的边权和
			if(q==0)printf("Yes\n");else	//如果q为0就可以
			printf("No\n");			//不行就……
		}
	}
}
```
# 另外推荐题目
[P3258 [JLOI2014]松鼠的新家](https://www.luogu.org/problemnew/show/P3258) 即其[题解](https://www.luogu.org/blog/juruohyfhaha/solution-p3258)

# 谢谢观赏，点个赞呗！

---

## 作者：FlashHu (赞：27)

最无脑LCT题解，Dalao们的各种算法都比这个好多啦。。。

唯一的好处就是只管码代码就好了

开战cut，停战link，询问findroot判连通性

太无脑，应该不用打注释了。常数大就不用说了（逃
```cpp
#include<cstdio>
#include<cstdlib>
#define R register int
#define I inline void
#define lc c[x][0]
#define rc c[x][1]
#define G ch=getchar()
#define gc G;while(ch<'-')G
#define in(z) gc;z=ch&15;G;while(ch>'-')z*=10,z+=ch&15,G;
const int N=300009;
int f[N],c[N][2],st[N],u[N],v[N];
bool r[N];
inline bool nroot(R x){
	return c[f[x]][0]==x||c[f[x]][1]==x;
}
I pushdown(R x){
	if(r[x]){
		R t=lc;lc=rc;rc=t;
		r[lc]^=1,r[rc]^=1,r[x]=0;
	}
}
I rotate(R x){
	R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
	if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
	if(w)f[w]=y;f[y]=x;f[x]=z;
}
I splay(R x){
	R y=x,z=0;
	st[++z]=y;
	while(nroot(y))st[++z]=y=f[y];
	while(z)pushdown(st[z--]);
	while(nroot(x)){
		y=f[x];z=f[y];
		if(nroot(y))
			rotate((c[y][0]==x)^(c[z][0]==y)?x:y);
		rotate(x);
	}
}
I access(R x){
	for(R y=0;x;x=f[y=x])
		splay(x),rc=y;
}
I makeroot(R x){
	access(x);splay(x);
	r[x]^=1;
}
inline int findroot(R x){
	access(x);splay(x);
    pushdown(x);
	while(lc)pushdown(x=lc);
	return x;
}
I split(R x,R y){
	makeroot(x);
	access(y);splay(y);
}
I link(R x,R y){
	makeroot(x);f[x]=y;
}
I cut(R x,R y){
	split(x,y);f[x]=c[y][0]=0;
}
int main()
{
	register char ch;
	R n,m,p=0,a,b;
	in(n);in(m);
	for(R i=1;i<n;++i){in(a);in(b);link(a,b);}
	while(m--){
		gc;
		switch(ch){
		case 'U':in(a);link(u[a],v[a]);break;
		case 'C':in(a);in(b);++p;cut(u[p]=a,v[p]=b);break;
		case 'Q':in(a);in(b);puts(findroot(a)==findroot(b)?"Yes":"No");
		}
	}
	return 0;
}
```

---

## 作者：梦梦子 (赞：14)

看大家发的都是树链剖分和LCT的题解，然而本人使用的是一种完全原创的方法：标记有期限的标记永久化dfs序线段树

具体来说，我们把所有战争和询问按时间排序，其中战争的时间是一段区间（开始时间到结束时间），然后，我们先用离线方法把所有询问点对的LCA在O（n）时间内找出来，找LCA时可以得到每个节点的dep（深度），dfn（dfs序），end（子树内最大的dfs序）

我们已经得到了每个询问点对的LCA，那么显然，此询问为YES充要的条件即为两个点向根能走到的最小深度均小于等于其LCA的深度（好好理解这句话）

我们建立一颗线段树，线段树的下标对应着点的dfs序，也就是dfn值，线段树的每个点用优先队列维护一个大根堆

当发生战争时，选择战争点对中深度较大的一个，设为x，则可知，x这颗子树中的所有点向根能走到的最小深度一定大于等于x的深度，而按照dfs序的性质，我们发现x子树中所有点的dfs序是连续的，即为（dfn[x]-end[x]）,这就是线段树中的区间取最值操作，我们将这个区间对应在线段树上的所有结点的大根堆加上一个二元组（dep[x],[此战争结束时间]）,大根堆按照dep排序

因此每次询问时，我们需要知道询问点对的两个点向根能走到的最小深度，也就是按照dfs序从线段树的根一直往相应的区间走，途中对于每个经过的点，找这些点的堆里面结束时间大于询问时间，且dep最大的标记，即为向根能走到的最小深度，在判断结束时间是否满足条件时，取堆顶元素，若满足则可以跳到下一个节点，若不满足，弹出这个元素找堆中的第二大元素······一直下去即可，正是因为有标记的撤销操作，所以我们不能使用线段树传统的下传标记功能，必须用堆维护实现标记永久化，由于所有操作都是按时间顺序，所以一个标记被弹出后就永远没有用了，可以放心弹出

由于m次战争最多产生mlogn个标记，每个标记最多会插入堆一次和从堆中删除一次，某个节点中标记最多有m个，因此插入和删除操作复杂度最多logm，加上预处理和离线求LCA的n的复杂度，总复杂度O(mlognlogm+n);

比树剖和LCT亲切多了吧

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<vector>
using namespace std;
struct node
{
	int dfn,bing,dep,end;
	vector<int> s;
	vector<int> t;
}tr[300005];
struct task
{
	int x,y,tc,ans;
}q[300005];
struct eve
{
	int dep,t;	
	bool operator<(const eve&y)const
	{
		return dep<y.dep;
	}
	bool operator>(const eve&y)const
	{
		return dep>y.dep;
	}
};
struct seg_node
{
	int l,r;
	priority_queue<eve> q;
}seg[1200005];
char s[2];
const int inf=1e9;
int n,m,i,x,y,pos,war[300005],cnt=0,ans;
int get(int p,int k){return q[p].x==k?q[p].y:q[p].x;}
int getf(int p){return tr[p].bing==p?p:tr[p].bing=getf(tr[p].bing);}
void dfs(int p,int f,int de)
{
	int i,v,vv;
	tr[p].dep=de;
	tr[p].bing=p;
	tr[p].dfn=tr[p].end=++cnt;
	for(i=0;i<tr[p].t.size();i++)
	{
		v=tr[p].t[i];
		vv=get(tr[p].t[i],p);
		if(tr[vv].dfn!=0)q[v].ans=tr[getf(vv)].dep;	
	}
	for(i=0;i<tr[p].s.size();i++)
	{
		v=tr[p].s[i];
		if(v!=f)dfs(v,p,de+1),tr[p].end=tr[v].end;
	}
	tr[p].bing=f;
}
void build(int p,int l,int r)
{
	int mid;
	seg[p].l=l;
	seg[p].r=r;
	mid=(l+r)/2;
	if(l!=r)
	{
		build(2*p,l,mid);
		build(2*p+1,mid+1,r);
	}
}
void opt(int p,int l,int r,int v,int tc)
{
	if(seg[p].l>r||seg[p].r<l)return;
	if(seg[p].l>=l&&seg[p].r<=r)seg[p].q.push((eve){v,tc});
	else
	{
		opt(2*p,l,r,v,tc);
		opt(2*p+1,l,r,v,tc);
	}
}
int check(int p,int pos,int t)
{
	int ans=0;
	while(!seg[p].q.empty()&&seg[p].q.top().t<t)seg[p].q.pop();
	if(!seg[p].q.empty())ans=max(ans,seg[p].q.top().dep);
	if(seg[p].l!=seg[p].r)
	{
		int mid,v;
		mid=(seg[p].l+seg[p].r)/2;
		v=pos<=mid?2*p:2*p+1;
		ans=max(ans,check(v,pos,t));
	}
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		tr[x].s.push_back(y);
		tr[y].s.push_back(x);
	}
	for(i=1;i<=m;i++)
	{
		scanf("%s",s);
		if(s[0]=='Q')
		{
			scanf("%d%d",&x,&y);
			q[i]=(task){x,y,-1,0};
			tr[x].t.push_back(i);
			tr[y].t.push_back(i);
		}
		if(s[0]=='C')
		{
			scanf("%d%d",&x,&y);
			q[i]=(task){x,y,inf,0};
			war[++cnt]=i;
		}
		if(s[0]=='U')
		{
			scanf("%d",&x);
			q[war[x]].tc=i;
		}
	}
	cnt=0;
	dfs(1,0,0);
	build(1,1,n);
	for(i=1;i<=m;i++)
	{
		if(q[i].tc==-1)
		{
			ans=max(check(1,tr[q[i].x].dfn,i),check(1,tr[q[i].y].dfn,i));
			if(ans>q[i].ans)printf("No\n");
			else printf("Yes\n");
		}
		else
		{
			pos=tr[q[i].x].dep<tr[q[i].y].dep?q[i].y:q[i].x;
			opt(1,tr[pos].dfn,tr[pos].end,tr[pos].dep,q[i].tc);
		}
	}
	return 0;
}
```

---

## 作者：KKarshilov (赞：12)

诸君都说："看到大家都用的树剖+树状数组"

然而一个用树状数组的题解都没有……

所以我决定来吃这个大佬们都不吃的螃蟹……

原理很简单，首先你要有一个dfs序数组

然后在发生战争时，将发生战争的两个节点中较深的那个++

停战时--

这样，这个数组的前缀和就是从当前节点到根结点的路径上的和

如果非零就代表有战争，然后就很简单了

lca不可取，完了

```cpp
#include <bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
typedef pair<int, int> P;
const int maxn = 1000000;
P war[maxn];
int fa[maxn], dep[maxn], val[maxn], sz[maxn], top[maxn], son[maxn];
int tre[maxn];
int tot;
int cntw;
int n, m;
inline int read()
{
    int ch, x = 0, f = 1;ch = getchar();
    while((ch < '0' || ch > '9') && ch != '-') ch = getchar();
    ch == '-' ? f = -1, ch = getchar() : 0;
    while(ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}
struct Edge {
    int to, len, nxt;
    Edge() {}
    Edge(int _to, int _len, int _nxt):to(_to), len(_len), nxt(_nxt) {}
}E[maxn];
int h[maxn], cnte;
int L[maxn], R[maxn];
void update(int x, int add) {
    for(int i = x;i <= maxn; i += lowbit(i)) tre[i] += add;
}
int query(int x) {
    int ans = 0; for(int i = x; i; i -= lowbit(i)) ans += tre[i]; return ans;
}
inline void add_edge(int u, int v, int w) {
    E[++cnte] = Edge(v, w, h[u]), h[u] = cnte;
    E[++cnte] = Edge(u, w, h[v]), h[v] = cnte;
}
void dfs1(int x) {
    
    sz[x] = 1; dep[x] = dep[fa[x]] + 1;
    for(int i = h[x]; i; i = E[i].nxt) {
        int to = E[i].to;
        if(to == fa[x]) continue;
        fa[to] = x;val[x] = E[i].len;
        dfs1(to);
        sz[x] += sz[to];
        if(sz[to] > sz[son[x]]) son[x] = to;
    }
    
}
void dfs2(int x) {
    L[x] = ++tot;
    if(x == son[fa[x]]) top[x] = top[fa[x]];
    else top[x] = x;
    if(son[x]) dfs2(son[x]);
    for(int i = h[x]; i; i = E[i].nxt) {
        int to = E[i].to;
        if(to == fa[x] || to == son[x]) continue;
        dfs2(to);
    }
    R[x] = tot;
}

void cut(int x, int y) {
    if(L[x] < L[y]) swap(x, y);
    update(L[x], 1);
}
void connect(int x, int y) {
    if(L[x] < L[y]) swap(x, y);
    update(L[x], -1);
}
int qsum(int x, int y) {
    int ans = 0;
    while(top[x] != top[y])
    {
        if(dep[top[x]] < dep[top[y]])swap(x, y);
        ans += (query(L[x]) - query(L[top[x]] - 1));
        x = fa[top[x]];
    }
    if(dep[x] < dep[y])swap(x, y);
    ans += (query(L[x]) - query(L[y]));
    return ans;
}
signed main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i < n; i++) add_edge(read(), read(), 0);
    dfs1(1);
    dfs2(1);
    for(int i = 1;i <= m; i++) {
        char s[50];
        cin >> s;
        if(s[0] == 'C') {
            int u = read(), v = read();
            cut(u, v);
            war[++cntw] = P(u, v);
        } 
        else if(s[0] == 'U') {
            int w = read();
            connect(war[w].first, war[w].second);
        }
        else {
            if(qsum(read(), read()) != 0) printf("No\n");
            else printf("Yes\n");
        }
    }
    return 0;
}
```

---

## 作者：djq_cpp (赞：8)

大家都用log^2的树状数组+树剖？那我来讲一下离线吧！

【和NOIP2016Day1T2有点类似】

首先，我们把问题抽象化一下：一棵带权树，权值一开始都是0，三种操作，1）把某条边权改为1 2）把某条边权改为0 3）求出u到v之间路径上的边权和是否为0

怎么做呢？显然可以LCT，然而题主懒得码模板。

注意到u到v之间路径上的边权和=（1到u路径上的边权和）+（1到v路径上的边权和）-2\*（1到LCA(u,v)路径上的边权和）

于是我们把1个query拆成了3个query，接下来的问题就是，如何离线处理6\*10^5个形如对“在第T个时间单位1到v路径上的边权和“的查询

我们跑一遍dfs，dfs的时候保存一棵线段树，维护当前节点v在所有时间上到根节点1的边权和。

从v的父亲转化到v，只需要进行关于v的父亲与v之间的战争的modify；考虑完子树v后回到v的父亲，也只需要进行同等数量反向的modify。（其实是djq不会码可持久化啦）

好吧djq蒟蒻讲不清楚，贴代码吧（一样丑）

```cpp
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <cmath>
#include <cstdio>
#include <cctype>
#include <ctime>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <complex>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cwchar>
#include <cwctype>
#include <exception>
#include <locale>
#include <numeric>
#include <new>
#include <stdexcept>
#include <limits>
#include <valarray>
#include <set>
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <map>
#include <list>
#include <utility>
#include <bitset>
#include <algorithm>
#include <functional>
#define rep(i,n) for(int i=0;i<(n);i++)
#define rep1(i,n) for(int i=1;i<=(n);i++)
#define MP make_pair
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
const int INF=1e9+7;
//segment tree
int tree[1048576];
int query(int id){
    id+=524288;
    int ans=tree[id];
    id>>=1;
    while(id>0){
        ans+=tree[id];
        id>>=1;
    }
    return ans;
}
void modify(int l,int r,int v){
    l+=524288;r+=524288;
    while(l<r){
        if(l&1)tree[l]+=v;
        if(!(r&1))tree[r]+=v;
        l=(l+1)>>1;
        r=(r-1)>>1;
    }
    if(l==r)tree[l]+=v;
}
//
vector<int> G[300005];
vector<pii> qy[300005];
vector<pair<pair<pii,pii>,pii> > Q;
vector<pii> war[300005];
int dep[300005],pre[300005][20];
// lca_part
void init_dfs(int v,int par){
    dep[v]=dep[par]+1;
    pre[v][0]=par;
    rep(k,G[v].size()){
        int u=G[v][k];
        if(u!=par)init_dfs(u,v);
    }
}
void init_lca(int n){
    rep1(i,18)rep1(j,n)
    pre[j][i]=pre[pre[j][i-1]][i-1];
}
int LCA(int u,int v){
    if(dep[u]<dep[v])swap(u,v);
    int dif=dep[u]-dep[v];
    rep(k,19)if(dif>>k&1)u=pre[u][k];
    if(u==v)return u;
    for(int k=18;k>=0;k--)
    if(pre[u][k]!=pre[v][k]){
        u=pre[u][k];
        v=pre[v][k]; 
    }
    return pre[u][0];
}
//main part
void dfs(int v,int par){
    rep(k,war[v].size())
    modify(war[v][k].first,war[v][k].second,1);
    rep(k,qy[v].size())qy[v][k].second=query(qy[v][k].first);
    rep(k,G[v].size()){
        int u=G[v][k];
        if(u==par)continue;
        dfs(u,v);
    }
    rep(k,war[v].size())
    modify(war[v][k].first,war[v][k].second,-1);
}
vector<pii> w;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,q;
    cin>>n>>q;
    rep(k,n-1){
        int u,v;
        cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    init_dfs(1,0);
    init_lca(n);
    rep(k,q){
        char t;
        int u,v;
        cin>>t;
        if(t=='C'){
            cin>>u>>v;
            if(dep[u]<dep[v])swap(u,v);
            w.push_back(MP(u,k));
        }else if(t=='U'){
            cin>>u;u--;
            war[w[u].first].push_back(MP(w[u].second,k));
            w[u].second=-1;
        }else{
            cin>>u>>v;int uv=LCA(u,v);
            Q.push_back(MP(MP(MP(u,qy[u].size()),MP(v,qy[v].size())),MP(uv,qy[uv].size())));
            qy[u].push_back(MP(k,-1));qy[v].push_back(MP(k,-1));qy[uv].push_back(MP(k,-1));
        }
    }
    rep(k,w.size())if(w[k].second!=-1)war[w[k].first].push_back(MP(w[k].second,q-1));
    dfs(1,0);
    rep(k,Q.size())cout<<(qy[Q[k].first.first.first][Q[k].first.first.second].second+
                          qy[Q[k].first.second.first][Q[k].first.second.second].second==
                          2*qy[Q[k].second.first][Q[k].second.second].second?"Yes\n":"No\n");
    return 0;
}

```

---

## 作者：Farkas_W (赞：7)

$$\text{关于题意}$$

$\quad$一道很简单的树剖题，只有三种操作(其实是两种)，唯一要考虑的点是如何将边权转化成点权，考虑到每个点都有且只有一个父亲节点(除根节点1之外)，那么我们就可以将父亲与儿子连接的边权记录到儿子身上，这样 $n-1$ 条边就可以合理的分配到 $n-1$ 个点上(除了根节点)，这样就转化成了普通的树链剖分模板了(如果还不能理解就看看图吧)。

原图

![](https://cdn.luogu.com.cn/upload/image_hosting/o4y4z8vc.png)

经过转化后的图(将边权转化为点权)

![](https://cdn.luogu.com.cn/upload/image_hosting/qtsmvd97.png)

注意：对于路径$4-2-5$，只需访问点 $4$ 和点 $5$，对于 $4$ 和 $5$ 的 $LCA$ (最近公共祖先)不可取，因为 $2$ 在原图中对应的是边 $1-2$，并不在路径$4-2-5$上，所以在树链剖分中当 $x$ 和 $y$ 在同一条链上时($dep[x]<dep[y]$)，只需询问 $x+1$ 到 $y$ 的路径。

$$\text{对于三种操作}$$

1. 操作 $1$：单点修改，两个相邻的部落开战，他们之间的道路不可通行。

2. 操作 $2$：区间询问，询问两个点之间的路径能否通行。

3. 操作 $3$：单点修改，两个开战的部落停战，他们之间的道路可以通行。

$\quad$可以很容易发现操作 $1$和操作 $3$ 其实是一种操作，只需开一个数组 $u$[$x$][$2$] 来记录参与第$x$次战争的两个部落，开战将这条边标记为 $0$，意为不可通行，停战就把这条边标记为 $1$，意为可以通行，用线段树维护区间和(也可以是最小值)，当$sum$[$k$]==$r$-$l$+$1$ 时说明这个区间内所有边皆可通行，否则至少有$1$条边不可通行。

$\quad$下面贴出AC代码，建议反复阅读，深刻理解。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#include<algorithm>
#define il inline
#define inf 1e18
#define next nne
#define re register int
using namespace std;
il int read()				//快速读入
{
	int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x*f;
}
const int N=3e5+5;
int n,m,next[N<<1],go[N<<1],head[N],tot,u[N][2],sum[N<<2];
int seg[N],son[N],father[N],top[N],size[N],dep[N];
il void Add(int x,int y)		//链式前向星存图
{
  next[++tot]=head[x];
  head[x]=tot;
  go[tot]=y;
}
il void dfs1(int x,int fa)
{
  father[x]=fa;dep[x]=dep[fa]+1;size[x]=1;
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(y==fa)continue;
      dfs1(y,x);
      size[x]+=size[y];
      if(size[y]>size[son[x]])son[x]=y;
    }
}
il void dfs2(int x,int topf)
{
  top[x]=topf;seg[x]=++seg[0];
  if(!son[x])return;
  dfs2(son[x],topf);
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(top[y])continue;
      dfs2(y,y);
    }
}
il void build(int k,int l,int r)	//建树，每个点初始值为1
{
  if(l==r){sum[k]=1;return;}
  int mid=l+r>>1;
  build(k<<1,l,mid);build(k<<1|1,mid+1,r);
  sum[k]=sum[k<<1]+sum[k<<1|1];
}
il void change(int k,int l,int r,int x,int z)
{
  if(l==r){sum[k]=z;return;}
  int mid=l+r>>1;
  if(x<=mid)change(k<<1,l,mid,x,z);
  else change(k<<1|1,mid+1,r,x,z);
  sum[k]=sum[k<<1]+sum[k<<1|1];
}
il bool query1(int k,int l,int r,int x,int y)
{
  if(x<=l&&y>=r){if(sum[k]==r-l+1)return 1;return 0;}
  int mid=l+r>>1;
  if(x<=mid)if(!query1(k<<1,l,mid,x,y))return 0;
  if(y>mid)if(!query1(k<<1|1,mid+1,r,x,y))return 0;
  return 1;
}
il void change1(int x,int y)
{
  if(father[x]==y)change(1,1,n,seg[x],0);//修改儿子节点
  else change(1,1,n,seg[y],0);
}
il void change2(int x)
{
  int xx=u[x][0],yy=u[x][1];
  if(father[xx]==yy)change(1,1,n,seg[xx],1);//修改儿子节点
  else change(1,1,n,seg[yy],1);
}
il bool query(int x,int y)
{
  int fx=top[x],fy=top[y];
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      if(!query1(1,1,n,seg[fx],seg[x]))return 0;
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  if(seg[x]+1<=seg[y])if(!query1(1,1,n,seg[x]+1,seg[y]))return 0;		//注意seg[x]要+1，
  return 1;
}
signed main()
{
  n=read();m=read();
  for(re i=1;i<n;i++){re x=read(),y=read();Add(x,y);Add(y,x);}
  dfs1(1,0);dfs2(1,1);build(1,1,n);tot=0;
  while(m--)
    {
      char ch;cin>>ch;
      if(ch=='C'){u[++tot][0]=read();u[tot][1]=read();change1(u[tot][0],u[tot][1]);}
      else if(ch=='Q'){re x=read(),y=read();if(query(x,y))puts("Yes");else puts("No");}
      else {re x=read();change2(x);}
    }
  return 0;
}
```

$$\text{后话}$$

$\quad$此题和[CF165D Beard Graph](https://www.luogu.com.cn/problem/CF165D)很像，那题也有[我的题解](https://www.luogu.com.cn/blog/Farkas/solution-cf165d)，欢迎支持。

$\quad$谢谢观赏，写题解不易，点个赞吧！

---

## 作者：Provicy (赞：4)

前言：作为因学业故无法继续玩$COC$的$5$年老玩家，对这题还是要资瓷一下的（图片没了挺可惜的）。

好的，接下来进入正文。

我们观察题目的要求，可总结如下：

```
操作为Q，查询从p到q的路径上的边权之和是否为0。

操作为C，对p到q的路径上的边权全部+1。

操作为U，对第k次C操作中，p到q的路径上的边权全部-1。

同时，边权不为负数。
```
那么这就是一个树剖板子题啦。

要注意的点：这是处理边权而不是点权。

将点权变为边权处理有多种方法，此处我们采用一种比较方便的方法，就是把边权放在$n-1$个点上存储。当修改和查询时将最后一个$LCA$减去即可。

对于区间修改和区间查询，此处我们使用线段树去维护。

那么这题整个框架就显而易见了（本人不会$LCT$，告辞）。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std; const int N=300010;
#define lc (x<<1)
#define rc (x<<1|1)
#define mid (l+r>>1)
int n,m,head[N],f[N],maxE,d[N],son[N],size[N],id[N],top[N],nowid,pp[N],qq[N],cnt;
int leaf[N<<2],flag[N<<2]; struct Edge{int nxt,to;}e[N<<1];
inline void Add(int u,int v) {e[++maxE].nxt=head[u]; head[u]=maxE; e[maxE].to=v; }
void DFS1(int x,int before)
{
	d[x]=d[before]+1; size[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		if(e[i].to==before) continue; f[e[i].to]=x;
		DFS1(e[i].to,x); size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
	}
}
void DFS2(int x)
{
	if(son[x])
	{
		id[son[x]]=++nowid;
		top[son[x]]=top[x];
		DFS2(son[x]);
	}
	for(int i=head[x];i;i=e[i].nxt) 
	{
		if(top[e[i].to]) continue;
		id[e[i].to]=++nowid;
		top[e[i].to]=e[i].to;
		DFS2(e[i].to);
	}	
}
inline void Change(int x,int l,int r,int k) {flag[x]+=k; leaf[x]+=k*(r-l+1); }
inline void Push_Down(int x,int l,int r)
{
	Change(lc,l,mid,flag[x]);
	Change(rc,mid+1,r,flag[x]);
	flag[x]=0;
}
void UpDate(int u,int v,int l,int r,int x,int k)
{
	if(l>=u&&r<=v) {Change(x,l,r,k); return; }
	if(flag[x]) Push_Down(x,l,r);
	if(u<=mid) UpDate(u,v,l,mid,lc,k);
	if(v>mid) UpDate(u,v,mid+1,r,rc,k);
	leaf[x]=leaf[lc]+leaf[rc];
}
void UpDate_Road(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		UpDate(id[top[x]],id[x],1,n,1,k);
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	UpDate(id[x]+1,id[y],1,n,1,k);
}
int Ask(int u,int v,int l,int r,int x)
{
	if(l>=u&&r<=v) return leaf[x];
	if(flag[x]) Push_Down(x,l,r);
	int res=0;
	if(u<=mid) res+=Ask(u,v,l,mid,lc);
	if(v>mid) res+=Ask(u,v,mid+1,r,rc);
	return res;
}
int Ask_Road(int x,int y)
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]]) swap(x,y);
		ans+=Ask(id[top[x]],id[x],1,n,1);
		x=f[top[x]];
	}
	if(d[x]>d[y]) swap(x,y);
	ans+=Ask(id[x]+1,id[y],1,n,1);
	return ans;
}
int main()
{
	ios::sync_with_stdio(false); cin>>n>>m;
	for(int i=1,u,v;i<n;i++) {cin>>u>>v; Add(u,v); Add(v,u); }
	DFS1(1,0); id[1]=++nowid; top[1]=1; DFS2(1);
	for(int i=1;i<=m;i++)
	{
		char opt; int p,q; cin>>opt;
		if(opt=='Q')
		{
			cin>>p>>q;
			if(Ask_Road(p,q)==0) cout<<"Yes"<<endl;
			else cout<<"No"<<endl;
		}
		if(opt=='C') {cin>>p>>q; pp[++cnt]=p; qq[cnt]=q; UpDate_Road(pp[cnt],qq[cnt],1); }
		if(opt=='U') {cin>>p; UpDate_Road(pp[p],qq[p],-1); }
	}
	return 0;
}
```
希望还在玩或曾经玩过$COC$的$OIer$们村庄和平，学业有成(本蒟蒻可能要先退役一步了$qwq$)。

---

## 作者：清远学会 (赞：4)

## 就是裸的树剖
~~(一遍水过 龟速逃)~~

**分析下题目**

你需要维护三个操作：

**1,建筑工人为了不跑冤枉路，向你询问 额~~~虽然你不想回答~~**

怎样判定在[u,v]上打仗了呢？很简单，在打仗的地方赋值为1，维护区间最大，只要区间最大不是0，就肯定在打仗啦！想酱：
```cpp

inline int Ask(int k,int l,int r,int a,int b) {
	if(a <= l && r <= b) return tr[k];
	int mid = (l + r) >> 1,res = 0;
	if(a <= mid) res = max(res,Ask(k << 1,l,mid,a,b));
	if(b > mid) res = max(res,Ask(k << 1 | 1,mid + 1,r,a,b));
	return res;
}

inline int Qurry(int u,int v) {
	int res = 0;
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u,v);
		res = max(res,Ask(1,1,n,tpos[top[u]],tpos[u]));
		u = fa[top[u]];
	}
	if(tpos[u] > tpos[v]) swap(u,v);
	res = max(res,Ask(1,1,n,tpos[u] + 1,tpos[v]));
   	 //因为是边权下放到点，所以tpos[u]要加1；
	return res;
}
```
主函数就是酱：
```cpp
if(s[1] == 'Q') {
	int u = read(),v = read();
	if(u > v) swap(u,v);
	if(Qurry(u,v)) printf("No\n");
	else printf("Yes\n");
}
```
**2,打仗啦，封路了，~~回家收衣服啦~~**

由于题目保证两个点相邻，那么，标记边就变为单点修改(赋一)，类似于边权下放点权；
当然，考虑到一会的停战，还要顺带记录一下，就酱：
```cpp
if(s[1] == 'C') {
	tag ++;
	a[tag].u = read(); a[tag].v = read();
	int _ = max(a[tag].u,a[tag].v);//给点数大的就行啦
	Change(1,1,n,tpos[_],1); //修改就是单点赋值，不多赘述
}
```

**3,停战喽，又过上幸福安康的生活**

我们上面维护了之前的战争，现在就可直接修改即可，之前赋一，现在改为零就行啦
```cpp
if(s[1] == 'U') {
	int x = read();
	int _ = max(a[x].u,a[x].v);
	Change(1,1,n,tpos[_],0);
}
```
### 最后撒花放代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 700500
using namespace std;

inline int read() {
    int x = 0,f = 1; char s = getchar();
    while(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}
    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
    return f * x;
}

int n,m;
int head[N],cnt;
struct node {
	int nxt,to;
}e[N];
int tpos[N],top[N],dep[N];
int fa[N],wson[N],size[N];
int tot,tag,tr[N * 4];
struct TE {
	int u,v;
}a[N];

inline void cp(int u,int v) {
	cnt ++;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

inline void dfs1(int u,int f) {
	size[u] = 1;
	for(int i = head[u];i;i = e[i].nxt) {
		int v = e[i].to;
		if(v == f) continue;
		fa[v] = u, dep[v] = dep[u] + 1;
		dfs1(v,u);
		size[u] += size[v];
		if(size[v] > size[wson[u]]) wson[u] = v;
	}
}

inline void dfs2(int u,int Top) {
	top[u] = Top;
	tpos[u] = ++ tot;
	if(wson[u]) dfs2(wson[u],Top);
	for(int i = head[u];i;i = e[i].nxt) {
		int v = e[i].to;
		if(v == wson[u] || v == fa[u]) continue;
		dfs2(v,v);
	}
}

inline void Update(int k) {
	tr[k] = max(tr[k << 1],tr[k << 1 | 1]);
}

inline void Change(int k,int l,int r,int a,int b) {
	if(l == r) {
		tr[k] = b;
		return ;
	}
	int mid = (l + r) >> 1;
	if(a <= mid) Change(k << 1,l,mid,a,b);
	if(a > mid) Change(k << 1 | 1,mid + 1,r,a,b);
	Update(k);
}

inline int Ask(int k,int l,int r,int a,int b) {
	if(a <= l && r <= b) return tr[k];
	int mid = (l + r) >> 1,res = 0;
	if(a <= mid) res = max(res,Ask(k << 1,l,mid,a,b));
	if(b > mid) res = max(res,Ask(k << 1 | 1,mid + 1,r,a,b));
	return res;
}

inline int Qurry(int u,int v) {
	int res = 0;
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u,v);
		res = max(res,Ask(1,1,n,tpos[top[u]],tpos[u]));
		u = fa[top[u]];
	}
	if(tpos[u] > tpos[v]) swap(u,v);
	res = max(res,Ask(1,1,n,tpos[u] + 1,tpos[v]));
	return res;
}

int main() {
	n = read(),m = read();
	for(int i = 1;i < n;i ++) {
		int u = read(),v = read();
		cp(u,v); cp(v,u);
	}
	dep[1] = fa[1] = 1;
	dfs1(1,-1),dfs2(1,1);
	for(int i = 1;i <= m;i ++) {
		char s[5]; scanf("%s",s + 1);
		if(s[1] == 'C') {
			tag ++;
			a[tag].u = read(); a[tag].v = read();
			int _ = max(a[tag].u,a[tag].v);
			Change(1,1,n,tpos[_],1);
		}
		if(s[1] == 'Q') {
			int u = read(),v = read();
			if(u > v) swap(u,v);
			if(Qurry(u,v)) printf("No\n");
			else printf("Yes\n");
		}
		if(s[1] == 'U') {
			int x = read();
			int _ = max(a[x].u,a[x].v);
			Change(1,1,n,tpos[_],0);
		}
	}
}
```

---

## 作者：Treaker (赞：3)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
## 树链剖分
一眼树剖。。

我们发现只要这一段路上有一条路径不能走，那么就可以判定为No。

那么是不是维护一下区间最值就行了呢。。对，是滴！！！

我们对于打仗的部落间的路径赋值为1，停战则赋值为0。

查询时看这条路径上最大值是不是1即可。。。

没有一遍切掉的原因是，停战时没有up。。。

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 300005;
inline int read()
{
    int x = 0 , f = 1;  char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-')  f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}
inline int Max(int x,int y) {return x > y ? x : y;}
int n , m , cnt;
int dep[N] , fa[N] , size[N] , dfn[N] , top[N] , hs[N];
char ch;
struct Tree_Div
{
	struct war {int u , v;}e[N];
	struct Edge
	{
		int to; Edge *nxt;
		Edge(int to = 0,Edge *nxt = NULL) : to(to) , nxt(nxt) {}
	}*head[N];
	inline void add(int u,int v) {head[u] = new Edge(v,head[u]);}
	void get_tree(int now)
	{
		size[now] = 1;
		for(Edge *i = head[now];i;i = i -> nxt)
		{
			int to = i -> to;
			if(to == 1 || dep[to]) continue;
			dep[to] = dep[now] + 1;
			fa[to] = now;
			get_tree(to);
			size[now] += size[to];
			if(size[to] > size[hs[now]]) hs[now] = to;
		}
	}
	void dfs(int now,int topfa)
	{
		dfn[now] = ++cnt;
		top[now] = topfa;
		if(hs[now]) dfs(hs[now],topfa);
		for(Edge *i = head[now];i;i = i -> nxt)
		{
			int to = i -> to;
			if(to == hs[now] || to == fa[now]) continue;
			dfs(to,to);
		}
	}
	struct node
	{
		node *ls , *rs;
		int l , r , maxn;
		node(int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL; maxn = 0;}
		inline void up() {maxn = Max(ls -> maxn,rs -> maxn);}
	}*root;
	#define mid ((p -> l + p -> r) >> 1)
	void build(node *&p,int l,int r)
	{
		p = new node(l,r);
		if(l == r) return;
		build(p -> ls,l,mid); build(p -> rs,mid+1,r);
	}
	void chenge(node *p,int x)
	{
		if(p -> l == p -> r) return (void)(p -> maxn = 1);
		chenge(x <= mid ? p -> ls : p -> rs,x);
		p -> up();
	}
	int query(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y) return p -> maxn;
		return Max(x <= mid ? query(p -> ls,x,y) : 0,y > mid ? query(p -> rs,x,y) : 0);
	}
	inline int sec_query(int x,int y)
	{
		int res = 0; 
		while(top[x] != top[y])
		{
			if(dep[top[x]] < dep[top[y]]) swap(x,y);
			res = Max(res,query(root,dfn[top[x]],dfn[x]));
			x = fa[top[x]];
		}
		if(dep[x] < dep[y]) swap(x,y);
		if(dfn[y] < dfn[x]) res = Max(res,query(root,dfn[y]+1,dfn[x]));
		return res;
	}
	void rev(node *p,int x)
	{
		if(p -> l == p -> r) return (void)(p -> maxn = 0);
		rev(x <= mid ? p -> ls : p -> rs,x); p -> up();
	}
	inline void League_of_Legends()
	{
		n = read(); m = read();
		for(int i = 1 , u , v;i < n;i ++)
		{
			u = read(); v = read();
			add(u,v); add(v,u);
		}
		get_tree(1); dfs(1,1); cnt = 0; build(root,1,n);
		for(int i = 1 , u , v , x;i <= m;i ++)
		{
			cin >> ch;
			if(ch == 'C') {u = read(); v = read(); e[++cnt] = (war){u,v}; chenge(root,dep[u] > dep[v] ? dfn[u] : dfn[v]);}
			if(ch == 'Q') {u = read(); v = read(); puts(sec_query(u,v) ? "No" : "Yes");}
			if(ch == 'U') {x = read(); u = e[x].u; v = e[x].v; rev(root,dep[u] > dep[v] ? dfn[u] : dfn[v]);}
		}
	}
	Tree_Div() {root = NULL;}
}Dungeon_Fighter;
int main()
{
	Dungeon_Fighter.League_of_Legends();
	return 0;
}

```


---

## 作者：青石巷 (赞：3)

听了学弟复述的题解，感觉真是玄妙啊……然而作为一个数据结构学傻，当然一定要用树剖A一下啦……

思路很简单，给每条边设定一个布尔值，false表示这条边不能走，true表示这条边可以走，初始时所有边的值均为true，若两个邻接的点之间发生战争则将这条边（其实就是u到v之间所有的边）间所有的值取反，战争结束也取反，查询u,v是否可达时就是查询u到v间所有边的值的按位与，false则不可达，true则可达。发现以上操作都是对链进行的，所以可以使用树剖解决。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e5+10,maxm=6e5+10;
int heade[maxn],ev[maxm],nexte[maxm];
int dep[maxn],size[maxn],son[maxn],fa[maxn];
int top[maxn],tid[maxn],nid[maxn];
int war[2][maxn];
bool node[4*maxn],lazy[4*maxn];//lazy为true则表示被取反过
int n,m,tot=0,root,idx=-1,num=0;bool ans;
void add_edge(int u,int v){ev[++tot]=v;nexte[tot]=heade[u];heade[u]=tot;}
void fdfs(int ui)
{
    int i,vi;
    size[ui]=1;son[ui]=0;
    for(i=heade[ui];~i;i=nexte[i])
    {
        vi=ev[i];if(vi==fa[ui]){continue;}
        dep[vi]=dep[ui]+1;fa[vi]=ui;
        fdfs(vi);size[ui]+=size[vi];
        if(size[vi]>size[son[ui]]){son[ui]=vi;}
    }
}
void sdfs(int ui,int anc)
{
    int i,vi;
    top[ui]=anc;tid[ui]=++idx;nid[idx]=ui;
    if(son[ui]){sdfs(son[ui],anc);}
    for(i=heade[ui];~i;i=nexte[i])
    {
        vi=ev[i];if(vi==fa[ui]||vi==son[ui]){continue;}
        sdfs(vi,vi);
    }
}
void pushup(int x){node[x]=node[2*x]&node[2*x+1];}
void build(int x,int l,int r)
{
    if(l==r){node[x]=true;return;}
    int mid=(l+r)>>1;
    build(2*x,l,mid);build(2*x+1,mid+1,r);
    pushup(x);
}
void pushdown(int x)
{
    lazy[2*x]^=1;lazy[2*x+1]^=1;
    node[2*x]^=1;node[2*x+1]^=1;
    lazy[x]=false;
}
void change(int x,int l,int r,int sj,int tj)
{
    if(sj>tj){swap(sj,tj);}
    if(sj<=l&&r<=tj){node[x]^=1;lazy[x]^=1;return;}
    int mid=(l+r)>>1;
    if(lazy[x]){pushdown(x);}
    if(sj<=mid){change(2*x,l,mid,sj,tj);}
    if(mid+1<=tj){change(2*x+1,mid+1,r,sj,tj);}
    pushup(x);
}
void query(int x,int l,int r,int sj,int tj)
{
    if(sj>tj){swap(sj,tj);}
    if(sj<=l&&r<=tj){ans&=node[x];return;}
    int mid=(l+r)>>1;
    if(lazy[x]){pushdown(x);}
    if(sj<=mid){query(2*x,l,mid,sj,tj);}
    if(mid+1<=tj){query(2*x+1,mid+1,r,sj,tj);}
    pushup(x);
}
void add(int u,int v)
{
    if(dep[u]<dep[v]){swap(u,v);}
    change(1,1,n-1,tid[u],tid[u]);
}
void work(int u,int v)
{
    int x=top[u],y=top[v];
    ans=true;
    while(x!=y)
    {
        if(dep[x]<dep[y]){swap(x,y);swap(u,v);}
        query(1,1,n-1,tid[x],tid[u]);
        u=fa[x];x=top[u];
    }
    if(u!=v)
    {
        if(dep[u]<dep[v]){swap(u,v);}
        query(1,1,n-1,tid[son[v]],tid[u]);
    }
    if(ans){printf("Yes\n");}else{printf("No\n");}
}
int main()
{
    int i,j,u,v,x;char flag[10];
    cin>>n>>m;root=(1+n)>>1;
    memset(heade,-1,sizeof(heade));
    for(i=1;i<n;i++){scanf("%d%d",&u,&v);add_edge(u,v);add_edge(v,u);}
    fdfs(root);sdfs(root,root);build(1,1,n-1);
    for(i=1;i<=m;i++)
    {
        scanf("%s",flag);
        if(flag[0]=='U'){scanf("%d",&x);/*printf("%c %d\n",flag[0],x);*/u=war[0][x];v=war[1][x];add(u,v);}
        else
        {
            scanf("%d %d",&u,&v);
            if(flag[0]=='C'){num++;war[0][num]=u;war[1][num]=v;add(u,v);}
            else{/*cout<<"oper;"<<endl;*/work(u,v);}
            //printf("%c %d %d\n",flag[0],u,v);
        }
    }
    return 0;
}

```
其实感觉用树剖做确实是杀鸡用牛刀了，如果n达到1e6的话应该就会被卡的吧……


---

## 作者：presucc (赞：2)

emmm……标签里面为什么没有$link-cut-tree$的标签呢？

这道题明显考对题意的理解。

首先，我们把在[P3690 【模板】Link Cut Tree （动态树）](https://www.luogu.org/problemnew/show/P3690)的AC代码拿过来（模板我是参考网上的）

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn=500050;
int ch[maxn][2],par[maxn],val[maxn],rev[maxn],sum[maxn],sta[maxn];
bool chk(int x)
{
	return ch[par[x]][0]==x||ch[par[x]][1]==x;
}
void update(int x)
{
	sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];
}
void reverse(int x)
{
	swap(ch[x][0],ch[x][1]);
	rev[x]^=1;
}
void pushdown(int x)
{
	if (rev[x])
	{
		rev[x]=0;
		reverse(ch[x][0]),reverse(ch[x][1]);
	}
}
void rotate(int x)
{
	int y=par[x],z=par[y],k=(ch[y][1]==x),w=ch[x][k^1];
	if (chk(y)) ch[z][ch[z][1]==y]=x;
	ch[x][k^1]=y,ch[y][k]=w;
	if (w) par[w]=y;
	par[y]=x,par[x]=z;
	update(x),update(y);
}
void splay(int x)
{
	int y=x,z=0;
	sta[++z]=y;
	while (chk(y)) sta[++z]=y=par[y];
	while (z) pushdown(sta[z--]);
	while (chk(x))
	{
		y=par[x],z=par[y];
		if (chk(y)) rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);
		rotate(x);
	}
	update(x);
}
void access(int x)
{
	for (int y=0;x;x=par[y=x])
		splay(x),ch[x][1]=y,update(x);
}
void makeroot(int x)
{
	access(x),splay(x),reverse(x);
}
int findroot(int x)
{
	access(x),splay(x);
	while (ch[x][0]) pushdown(x),x=ch[x][0];
	return x;
}
void split(int x,int y)
{
	makeroot(x),access(y),splay(y);
}
void link(int x,int y)
{
	makeroot(x);
	if (findroot(y)!=x) par[x]=y;
}
void cut(int x,int y)
{
	split(x,y);
	if (findroot(y)==x&&par[x]==y&&!ch[x][1]) ch[y][0]=par[x]=0;
}
int n,m,x,y,opt;
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&val[i]);
	while (m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if (opt==0) split(x,y),printf("%d\n",sum[y]);
		if (opt==1) link(x,y);
		if (opt==2) cut(x,y);
		if (opt==3) splay(x),val[x]=y;
	}
	return 0;
}
```

之后，我们来细细地理解一下题意。（话说这个题意真的有点坑）

对于$Q$操作，就是询问两个点在树中的根是否相同，直接

```cpp
findroot(x)==findroot(y)
```
判断即可。

对于$C$操作，切断这两条准备开战的点之间的边即可。

但是要注意，我们必须要用两个桶装着这两个被删除的边，操作3会用到。

```cpp
int bin1[maxn],bin2[maxn],stop;
bin1[++stop]=x,bin2[stop]=y;
cut(x,y);
```

对于$U$操作，这是一个比较绕的东西。

上面的题目背景说到：

> “天下之势，分久必合，当两个部落经历了不打不相识的苦战之后，他们可以签订停战协议（暂时停战，以后依旧可能再次开战），这样，两个部落之间的道路又会重新恢复为可通行状态，建筑工人们又可以经过此地购买最新的大本营设计图纸来强大自己的部落了。”

说明如果执行了$U$操作，那么第x个开战的两个国家就停战了，那么道路就重新开放了，就要再次link回去。

所以，这道题可以简化成如下：

1. 询问x的根是否与y的树根相同；
2. 将x与y之间的边切断；
3. 将第x次切断的两条边连回来。

~~所以这还是一道模板题嘛对不对~~

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include<cctype>
const int maxn=500050;
int ch[maxn][2],par[maxn],val[maxn],rev[maxn],sum[maxn],sta[maxn];
int bin1[maxn],bin2[maxn],stop;
inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
bool chk(int x)
{
	return ch[par[x]][0]==x||ch[par[x]][1]==x;
}
void update(int x)
{
	sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];
}
void reverse(int x)
{
	std::swap(ch[x][0],ch[x][1]);
	rev[x]^=1;
}
void pushdown(int x)
{
	if (rev[x])
	{
		rev[x]=0;
		reverse(ch[x][0]),reverse(ch[x][1]);
	}
}
void rotate(int x)
{
	int y=par[x],z=par[y],k=(ch[y][1]==x),w=ch[x][k^1];
	if (chk(y)) ch[z][ch[z][1]==y]=x;
	ch[x][k^1]=y,ch[y][k]=w;
	if (w) par[w]=y;
	par[y]=x,par[x]=z;
	update(x),update(y);
}
void splay(int x)
{
	int y=x,z=0;
	sta[++z]=y;
	while (chk(y)) sta[++z]=y=par[y];
	while (z) pushdown(sta[z--]);
	while (chk(x))
	{
		y=par[x],z=par[y];
		if (chk(y)) rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);
		rotate(x);
	}
	update(x);
}
void access(int x)
{
	for (int y=0;x;x=par[y=x])
		splay(x),ch[x][1]=y,update(x);
}
void makeroot(int x)
{
	access(x),splay(x),reverse(x);
}
int findroot(int x)
{
	access(x),splay(x);
	while (ch[x][0]) pushdown(x),x=ch[x][0];
	return x;
}
void split(int x,int y)
{
	makeroot(x),access(y),splay(y);
}
void link(int x,int y)
{
	makeroot(x);
	if (findroot(y)!=x) par[x]=y;
}
void cut(int x,int y)
{
	split(x,y);
	if (findroot(y)==x&&par[x]==y&&!ch[x][1]) ch[y][0]=par[x]=0;
}
int n,m,x,y;
int main()
{
	char opt[10];
	scanf("%d%d",&n,&m);
	for (int i=2;i<=n;i++)
	{
		int tmp1=read(),tmp2=read();
		link(tmp1,tmp2);
	}
	while (m--)
	{
		scanf("%s",opt);
		if (opt[0]=='Q')
		{
			x=read(),y=read();
			if (findroot(x)==findroot(y)) printf("Yes\n");
			else printf("No\n");
		}
		else if (opt[0]=='C')
		{
			x=read(),y=read();
			bin1[++stop]=x,bin2[stop]=y;
			cut(x,y);
		}
		else
		{
			x=read();
			link(bin1[x],bin2[x]);
		}	
	}
	return 0;
}
```

### 后记

$link-cut-tree$这个东西常数是真的大，不加任何优化最后一个点$1023ms$，竟然没过，害得我加了个快读，才勉强擦边（$982ms$）

总之是要加强对题目的理解能力……

---

## 作者：p_b_p_b (赞：2)

# 暴力lct解决一切问题

一开始先link，开战cut，停战link，查询makeroot+findroot

常数大也没有关系，1424ms稳稳地过了

LCT练手题

```cpp
#include<bits/stdc++.h>
#define ls ch[x][0]
#define rs ch[x][1]
#define sz 301010
using namespace std;
int tag[sz],fa[sz],ch[sz][2],st[sz];
bool nroot(int x){return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}
bool get(int x){return ch[fa[x]][1]==x;}
void pushdown(int x)
{
	if (tag[x])
	{
		tag[x]=0;
		if (ls) tag[ls]^=1;
		if (rs) tag[rs]^=1;
		swap(ls,rs);
	}
}
void rotate(int x)
{
	int y=fa[x],z=fa[y],k=get(x),w=ch[x][!k];
	if (w) fa[w]=y;
	ch[y][k]=w;
	if (nroot(y)) ch[z][get(y)]=x;
	fa[x]=z;
	ch[x][!k]=y;
	fa[y]=x;
}
void splay(int x)
{
	int cnt=1;
	st[1]=x;
	for (int i=x;nroot(i);i=fa[i]) st[++cnt]=fa[i];
	for (int i=cnt;i;i--) pushdown(st[i]);
	while (nroot(x))
	{
		int y=fa[x];
		if (nroot(y)) rotate(get(x)==get(y)?y:x);
		rotate(x);
	}
}
void access(int x)
{
	for (int y=0;x;x=fa[y=x])
	{
		splay(x);
		ch[x][1]=y;
	}
}
void makeroot(int x){access(x);splay(x);tag[x]^=1;}
int findroot(int x)
{
	access(x);splay(x);
	while (ls) pushdown(x),x=ls;
	return x;
}
void link(int x,int y)
{
	makeroot(x);
	if (findroot(y)!=x) fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	if (findroot(y)==x&&fa[x]==y&&!rs) fa[x]=ch[y][0]=0;
}
int war[sz][2];
int main()
{
	register int i=0,x,y,n,m;
	register char ch;
	scanf("%d %d",&n,&m);
	n--;
	while (n--) scanf("%d %d",&x,&y),link(x,y);
	while (m--)
	{
		cin>>ch;
		if (ch=='U') scanf("%d",&x),link(war[x][0],war[x][1]);
		else if (ch=='Q') scanf("%d %d",&x,&y),makeroot(x),puts(findroot(y)==x?"Yes":"No");
		else scanf("%d %d",&x,&y),cut(x,y),war[++i][0]=x,war[i][1]=y;
	}
}
```

---

## 作者：星星之火 (赞：2)

关于部落冲突这道题目，对这个题目知底的同学想必知道，最初这是一道模拟赛的题，当时不会。现在我就是模拟考试追求速度没怎么动脑子，打了个几乎裸的树剖，懂的人当然一下就会明白，不懂的也能找找启发。我其实也是看了另一篇题解的，希望能写的更详细一点。



解题思路：

1.把每一条边看为无权值，反之给点带权值，初始化为1

2.如果战争的话，选取较深的那个点权值加一

3.如果提问的话，直接看两点之间的路径大小（因为只会有一条路）

4.战争用一个数组存一下到时候再改就好了


```cpp
int dfs1(int x)
{
    size[x]=1;
    for(int i=head[x]; i; i=e[i].next)
    {
        if(e[i].to==fa[x])
            continue;
        deep[e[i].to]=deep[x]+1;
        fa[e[i].to]=x;
        size[x]+=dfs1(e[i].to);
        if(!son[x] || size[e[i].to]>size[son[x]])
            son[x]=e[i].to;
    }
    return size[x];
}
```
第一遍dfs是为了找出重儿子（概念请自己搜索）

------------



```cpp
void dfs2(int x,int root)
{
    rec[++rec[0]]=x;
    top[x]=root;
    if(son[x])
        dfs2(son[x],root);
    for(int i=head[x]; i; i=e[i].next)
    {
        if(e[i].to==fa[x]||e[i].to==son[x])
            continue;
        dfs2(e[i].to,e[i].to);
    }
}
```
在第一遍构成的无序树的基础上按重链（不清楚的话也可以百度），剖成有序树

------------



```cpp
int chain_query(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]>deep[top[v]])    swap(u,v);
        query_val(1,1,n,pos[top[v]],pos[v]);
        if(ans>0)    return 0;
        v=fa[top[v]];
    }
    if(deep[u]>deep[v])      swap(u,v);
    query_val(1,1,n,pos[u],pos[v]);
    int k=ans;
    if(k>1)
        return 0;
    ans=0;
    query_val(1,1,n,pos[u],pos[u]);
    if(k-ans==0)
        return 1;
    return 0;
}
```
把两个点之间的路径加起来，如果大于一，那么就不连通

------------



注意到上文中有一个chain-query函数


```cpp
int chain_query(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]>deep[top[v]])    swap(u,v);
        query_val(1,1,n,pos[top[v]],pos[v]);
        if(ans>0)    return 0;
        v=fa[top[v]];
    }
    if(deep[u]>deep[v])      swap(u,v);
    query_val(1,1,n,pos[u],pos[v]);
    int k=ans;
    if(k>1)
        return 0;
    ans=0;
    query_val(1,1,n,pos[u],pos[u]);
    if(k-ans==0)
        return 1;
    return 0;
}
```
or最后部分这么写
 if (dep[u]<dep[v]) swap(u,v);

    ans=ans+query(1,n,1,id[v],id[u])；

然后直接return ans就好了


------------


注意到解题的思想，怎么改变点值呢？其实只需要对线段树进行操作就好了，最后不要忘了更新全部的根


```cpp
void update(int cur,int l,int r,int tar,int val)
{
    if(l==r)
    {
        tree[cur]+=val;
        return ;
    }
    int mid=(l+r)>>1;
    if(tar<=mid)
        update(cur*2,l,mid,tar,val);
    else if(tar>mid)
        update(cur*2+1,mid+1,r,tar,val);
    tree[cur]=tree[cur*2]+tree[cur*2+1];
}
代码就不附带了，还有不懂的看看树链就好了
```

---

## 作者：OIer991215 (赞：2)

暴力数据结构爱好者。

在树剖之后建立一棵线段树，能支持单点修改和区间查询。

把两点之间的边转化成深度深的点的权值，进行修改和查询，就可以AC本题了。

——————————————————————————————

两点战争：深度深的点点权+1。两点和平：深度深的点点权-1。

不能到达：两点之间点权权值和大于0,（特判lca点权值可以为1）

能到达：两点之间点权权值和等于0

——————————————————————————————

不要问我为什么不写树状数组 差分什么的。。。。

因为打树剖线段树不用动脑子。

——————————————————————————————


代码量好像还不小（反正不动脑子


——————————————————————————————











```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N=300300,M=300300;
int n,m,ans;
int size[N],head[N],fa[N],son[N];
int deep[N],top[N],tree[N<<2];
int rec[N],pos[N];
struct next_list
{
    int next,to;
}e[M<<1];
struct pro
{
    int u,v;
}q[M];
int read()
{
    int rt=0,in=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        rt=rt*10+ch-48;
        ch=getchar();
    }
    return rt*in;
}
void add_edge(int u,int v)
{
    e[++head[0]].to=v;
    e[head[0]].next=head[u];
    head[u]=head[0];
}
int dfs1(int x)
{
    size[x]=1;
    for(int i=head[x]; i; i=e[i].next)
    {
        if(e[i].to==fa[x])
            continue;
        deep[e[i].to]=deep[x]+1;
        fa[e[i].to]=x;
        size[x]+=dfs1(e[i].to);
        if(!son[x] || size[e[i].to]>size[son[x]])
            son[x]=e[i].to;
    }
    return size[x];
}
void dfs2(int x,int root)
{
    rec[++rec[0]]=x;
    top[x]=root;
    if(son[x])
        dfs2(son[x],root);
    for(int i=head[x]; i; i=e[i].next)
    {
        if(e[i].to==fa[x]||e[i].to==son[x])
            continue;
        dfs2(e[i].to,e[i].to);
    }
}
void query_val(int cur,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        ans+=tree[cur];
        return ;
    }
    int mid=(l+r)>>1;
    if(R<=mid)
        query_val(cur*2,l,mid,L,R);
    else if(L>mid)
        query_val(cur*2+1,mid+1,r,L,R);
    else
    {
        query_val(cur*2,l,mid,L,mid);
        query_val(cur*2+1,mid+1,r,mid+1,R);
    }
}
int query_LCA(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]>deep[top[v]])    swap(u,v);
        query_val(1,1,n,pos[top[v]],pos[v]);
        if(ans>0)    return 0;
        v=fa[top[v]];
    }
    if(deep[u]>deep[v])      swap(u,v);
    query_val(1,1,n,pos[u],pos[v]);
    int k=ans;
    if(k>1)
        return 0;
    ans=0;
    query_val(1,1,n,pos[u],pos[u]);
    if(k-ans==0)
        return 1;
    return 0;
}
void modify(int cur,int l,int r,int tar,int val)
{
    if(l==r)
    {
        tree[cur]+=val;
        return ;
    }
    int mid=(l+r)>>1;
    if(tar<=mid)
        modify(cur*2,l,mid,tar,val);
    else if(tar>mid)
        modify(cur*2+1,mid+1,r,tar,val);
    tree[cur]=tree[cur*2]+tree[cur*2+1];
}
int main()
{
    n=read(),m=read();
    for(int i=1; i<n; i++)
    {
        int u,v;
        u=read(),v=read();
        add_edge(u,v);
        add_edge(v,u);
    }
    deep[1]=1;
    dfs1(1);
    dfs2(1,1);
    for(int i=1; i<=n; i++)
        pos[rec[i]]=i;
    int _=0;
    for(int i=1; i<=m; i++)
    {
        char ch;
        int u,v;
        cin>>ch;
        ans=0;
        if(ch=='Q')
        {
            u=read(),v=read();
            if(query_LCA(u,v))
                printf("Yes\n");
            else   printf("No\n");
        }
        if(ch=='C')
        {
            u=read(),v=read();
            if(deep[u]>deep[v])      swap(u,v);
            q[++_].u=u,q[_].v=v;
            modify(1,1,n,pos[v],1);
        }
        if(ch=='U')
        {
            u=read();
            modify(1,1,n,pos[q[u].v],-1);
        }
    }
    return 0;
}

```

---

## 作者：Holmes (赞：2)

与楼下同为~~数据结构学傻了~~数据结构爱好者，看到这个题的第一反应是：link cut tree啊！然后直接暴力cut和link，发生战争就cut，结束就link，第一次提交把'^'打成'!'就爆零了，改完一次A，运行速度光荣垫底，但貌似比标称短，防止卡常把link函数cut函数还有makeroot函数全都写成了define，有（fei）点（chang）丑

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define makeroot(x) Access(x);splay(x);rev[x]^=1;
#define Link(x,y) makeroot(x);fa[x]=y;
#define cut(x,y) makeroot(x);Access(y);splay(y);if(ch[y][0]==x) fa[x]=ch[y][0]=0;
#define maxx 300005
using namespace std;
struct ans{
    int u,v;
}e[300005];
int n,m,ch[maxx][2],fa[maxx],st[maxx],top;
bool rev[maxx];
bool isroot(int x){ return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x; }
void pushdown(int x)
{
    if(rev[x]){
        swap(ch[x][0],ch[x][1]); rev[x]=0;
        rev[ch[x][0]]^=1; rev[ch[x][1]]^=1;
    }
}
void rotate(int x)
{
    int y=fa[x],z=fa[y],l=ch[y][1]==x,r=l^1;
    if(!isroot(y)) ch[z][ch[z][1]==y]=x;
    fa[x]=z; fa[y]=x; fa[ch[x][r]]=y;
    ch[y][l]=ch[x][r]; ch[x][r]=y;
}
void splay(int x)
{
    st[++top]=x;
    for(int i=x;!isroot(i);i=fa[i]) st[++top]=fa[i];
    while(top) pushdown(st[top--]);
    while(!isroot(x)){
        int y=fa[x],z=fa[y];
        if(!isroot(y)){
            if(ch[y][0]==x^ch[z][0]==y) rotate(x);
            else rotate(y);
        }rotate(x);
    }
}
void Access(int x)
{
    for(int y=0;x;y=x,x=fa[x])
        splay(x),ch[x][1]=y;
}
int findrt(int x)
{
    while(fa[x]) x=fa[x];
    return x;
}
int main()
{
    int x,y,t=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;++i){
        scanf("%d%d",&x,&y);
        Link(x,y);
    }
    while(m--){
        char opt=' ';
        while(opt!='Q'&&opt!='C'&&opt!='U') opt=getchar();
        if(opt=='Q'){
            scanf("%d%d",&x,&y);
            if(findrt(x)==findrt(y)) puts("Yes");
            else puts("No");
        }else if(opt=='C'){
            scanf("%d%d",&x,&y);
            e[++t]=(ans){x,y};
            cut(x,y);
        }else{
            scanf("%d",&x);
            if(x>t) continue;
            if(findrt(e[x].u)!=findrt(e[x].v)) {
                Link(e[x].u,e[x].v);
            }
        }
    }
    return 0;
}
```
看了一下题解，真是……果然我是个只会打暴力的蒟蒻


---

## 作者：KEBrantily (赞：1)

板子题

## Description

三种操作

- `Q p q` 询问 $p$ 与 $q$ 是否连通；

- `C p q` 使相临的 $p,q$ 两点间的路断开，并进行编号；

- `U x` 使编号为 $x$ 的路变得可通。

## Solution

这里提供一种简单的想法。

初始每条边的边权是一，每当一条路变得不可同行时将其赋值为无穷大。所以两个点互相可达的充要条件就是其路径上的最大值不为无穷大。

至于每次战争，用结构体或者别的东西存下交战的双方和编号即可。

所以只需要维护一个最大值即可，同时注意点权下放。

## Code

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define rr register 
#define maxn 1200100 
#define INF 0x3f3f3f3f
//#define int long long
using namespace std;

int n,m,cnt,now,tot,head[maxn];
struct War{int fir,sec;}w[maxn];
struct edge{int fr,to,nxt;}e[maxn];

inline int read(){
    rr int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

void add(int fr,int to){e[++tot]=(edge){fr,to,head[fr]};head[fr]=tot;}

namespace Seg{
    #define ls x<<1
    #define rs x<<1|1
    int Max[maxn];
    void pushup(int x){Max[x]=max(Max[ls],Max[rs]);}
    
    void build(int x,int l,int r){
        if(l==r){Max[x]=1;return;}
        int mid=l+r>>1;build(ls,l,mid);build(rs,mid+1,r);
        pushup(x);
    }
    
    void update(int x,int l,int r,int pos,int val){
        if(l==r){Max[x]=val;return;}
        int mid=l+r>>1;
        if(pos<=mid) update(ls,l,mid,pos,val);
        else update(rs,mid+1,r,pos,val);
        pushup(x);
    }
    
    int getmax(int x,int l,int r,int L,int R){
        if(L<=l&&R>=r) return Max[x];
        int mid=l+r>>1,ans=-1;
        if(L<=mid) ans=max(ans,getmax(ls,l,mid,L,R));
        if(R>=mid+1) ans=max(ans,getmax(rs,mid+1,r,L,R));
        return ans; 
    }
}

namespace Cut{
    int fa[maxn],son[maxn],top[maxn];
    int dfn[maxn],dep[maxn],siz[maxn];
    void dfs1(int u,int fat){
        dep[u]=dep[fat]+1;
        siz[u]=1;fa[u]=fat;
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to;
            if(to==fat) continue;
            dfs1(to,u);siz[u]+=siz[to];
            if(siz[to]>siz[son[u]])son[u]=to;
        }
    }
    
    void dfs2(int u,int tp){
        top[u]=tp;dfn[u]=++now;
        if(son[u]) dfs2(son[u],tp);
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to;
            if(to==son[u]||to==fa[u])continue;
            dfs2(to,to);
        }
    }
    
    int query(int x,int y){
        int ans=-1;
        while(top[x]!=top[y]){
            if(dep[top[x]]<dep[top[y]]) swap(x,y);
            ans=max(ans,Seg::getmax(1,1,n,dfn[top[x]],dfn[x]));
            x=fa[top[x]];
        }
        if(dep[x]>dep[y]) swap(x,y);
        ans=max(ans,Seg::getmax(1,1,n,dfn[x]+1,dfn[y]));
        return ans; 
    }
}

int main(){
    n=read();m=read();
    for(int i=1,fr,to;i<n;i++){
        fr=read();to=read();
        add(fr,to);add(to,fr);
    }
    Seg::build(1,1,n);
    Cut::dfs1(1,0);Cut::dfs2(1,1);
    for(int i=1,fr,to,x;i<=m;i++){
        string opt;cin>>opt;
        if(opt=="Q"){
            fr=read();to=read();
            Cut::query(fr,to)<INF?printf("Yes\n"):printf("No\n");
        }
        else if(opt=="C"){
            w[++cnt].fir=fr=read(),w[cnt].sec=to=read();
            Seg::update(1,1,n,max(Cut::dfn[to],Cut::dfn[fr]),INF);
        }
        else{
            x=read();fr=w[x].fir;to=w[x].sec;
            Seg::update(1,1,n,max(Cut::dfn[to],Cut::dfn[fr]),1);
        }
    } 
    return 0;
}
```


---

## 作者：moosssi (赞：1)

树链剖分板子题。

这里先把边权转点权，把每条边的权值下放到点上即可，一般都可以这样处理。

转化题意，发起战争时，我们直接单点修改权值加一，停止战争同理权值减一即可。

对于询问，区间查询求和，如果答案为零则为没有战争，输出Yes，否则输出No。

询问时需要注意，因为下放边权，路径x到y，求完和之后要减去lca的权值。

由于我用的树剖，可以这样处理：当下x，y在不同链时，直接求和，在同一链时深度较小的即为lca，把求和的位置加一即可，具体见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int head[N],ver[N*2],net[N*2],tot;
int siz[N],far[N],deep[N],son[N];
int tp[N],id[N],cnt;
int n,m,l[N],r[N],q;
struct nod{
	int l,r,sum;
}tree[N*4];
void add(int a,int b){
	net[++tot]=head[a];
	head[a]=tot;
	ver[tot]=b;
}
void dfs(int x,int fa){
	deep[x]=deep[fa]+1;
	siz[x]=1;
	far[x]=fa;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		dfs(v,x);
		siz[x]+=siz[v];
		if(siz[son[x]]<siz[v])son[x]=v;
	}
}
void dfs2(int x,int fa,int num){
	tp[x]=num;
	id[x]=++cnt;
	if(!son[x])return ;
	dfs2(son[x],x,num);
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa||v==son[x])continue;
		dfs2(v,x,v);
	}
}
void build(int l,int r,int p){
	tree[p].l=l;
	tree[p].r=r;
	if(l==r)return ;
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
}
void chang(int x,int p,int k){
	if(tree[p].l==tree[p].r){
		tree[p].sum+=(tree[p].r-tree[p].l+1)*k;
		return ;
	}
	int mid=(tree[p].l+tree[p].r)/2;
	if(x<=mid)chang(x,p*2,k);
	else chang(x,p*2+1,k);
	tree[p].sum=tree[p*2].sum+tree[p*2+1].sum;
}
int find(int l,int r,int p){
	if(tree[p].l>=l&&tree[p].r<=r){
		return tree[p].sum;
	}
	int mid=(tree[p].l+tree[p].r)/2;
	int ans=0;
	if(l<=mid)ans+=find(l,r,p*2);
	if(r>mid)ans+=find(l,r,p*2+1);
	return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	dfs(1,0);
	dfs2(1,0,1);
	build(1,n,1);
	while(m--){
		int x,y,z;
		char op;
		cin>>op;
		if(op=='Q'){
			scanf("%d%d",&x,&y);
			int ans=0;
			while(tp[x]!=tp[y]){
				if(deep[tp[x]]<deep[tp[y]])swap(x,y);
				ans+=find(id[tp[x]],id[x],1);
				x=far[tp[x]];
			}
			if(deep[x]<deep[y])swap(x,y);
			ans+=find(id[y]+1,id[x],1);
			if(!ans)printf("Yes\n");
			else printf("No\n");
		}
		else if(op=='C'){
			scanf("%d%d",&x,&y);
			l[++q]=x,r[q]=y;
			if(far[y]==x)swap(x,y);
			chang(id[x],1,1);
		}
		else {
			scanf("%d",&z);
			x=l[z],y=r[z];
			if(far[y]==x)swap(x,y);
			chang(id[x],1,-1);
		}
	}
	return 0;
}
```


---

## 作者：洛水·锦依卫 (赞：1)

# Algorithm

树状数组

# Mentality

其实本来是想练手一下 $LCT$ 的，但是这题用 $LCT$ 实在显得牛刀杀鸡 ……

大致看了一下题解，都用了树剖和 $LCT$ 这样的，但其实有一种很简单的方法，只需要树状数组 + 随机数。

根据题目，对于一条路径 $u, v$ ，这条路径联通当且仅当 $u, v$ 上的边都没有被断开。

那么如何才能满足这个条件呢？换成对断边的要求，就是对于当前所有断开了的边，$u, v$ 要么都在它的子树内，要么都不在。

则我们可以考虑用 $dfn$ 序 + 树状数组维护子树信息，只要在每次断边的时候，给子树内每个点都赋上一个特有信息，然后询问的时候对 $u, v$ 查询上面的信息是否相等即可。

如何赋上这个特殊信息呢？很简单，对于每次断边都 $rand$ 一个特定权值，用树状数组给子树内的所有节点都加上这个权值即可。

查询的时候只需要查一下两点权值是否相同就行。

还原的时候再删掉就好了。

# Code

```cpp
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;
#define LL long long
#define go(G, x, i, v) \
  for (int i = G.hd[x], v = G.to[i]; i; v = G.to[i = G.nx[i]])
#define inline __inline__ __attribute__((always_inline))
inline LL read() {
  LL x = 0, w = 1;
  char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') w = -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = (x << 3) + (x << 1) + ch - '0';
    ch = getchar();
  }
  return x * w;
}

const int Max_n = 3e5 + 5, mod = 998244353;
int n, m;
int cntd, dep[Max_n], dfn[Max_n], siz[Max_n];
int c[Max_n];
struct graph {
  int hd[Max_n];
  int cntr, nx[Max_n << 1], to[Max_n << 1];
  void addr(int u, int v) {
    cntr++;
    nx[cntr] = hd[u], to[cntr] = v;
    hd[u] = cntr;
  }
} G;
struct que {
  int u, v, x;
} k[Max_n];

namespace Input {
void main() {
  n = read(), m = read();
  int u, v;
  for (int i = 1; i < n; i++) {
    u = read(), v = read();
    G.addr(u, v), G.addr(v, u);
  }
}
}  // namespace Input

namespace Init {
void build(int x, int fa) {
  dep[x] = dep[fa] + 1, siz[x] = 1, dfn[x] = ++cntd;
  go(G, x, i, v) if (v != fa) build(v, x), siz[x] += siz[v];
}
void main() { build(1, 0); }
}  // namespace Init

namespace Solve {
void add(int k, int x) {
  for (int i = k; i <= n; i += i & -i) (c[i] += x) %= mod;
}
int query(int k) {
  int ans = 0;
  for (int i = k; i; i -= i & -i) (ans += c[i]) %= mod;
  return (ans + mod) % mod;
}
void main() {
  srand((unsigned)time(NULL));
  int cnt = 0, u, v;
  char op;
  for (int i = 1; i <= m; i++) {
    scanf(" %c", &op);
    u = read();
    if (op == 'U')
      add(dfn[k[u].v], -k[u].x), add(dfn[k[u].v] + siz[k[u].v], k[u].x);
    else {
      v = read();
      if (op == 'Q')
        printf("%s\n", query(dfn[u]) == query(dfn[v]) ? "Yes" : "No");
      else {
        k[++cnt].x = rand() % mod;
        if (dep[u] > dep[v]) swap(u, v);
        add(dfn[v], k[cnt].x), add(dfn[v] + siz[v], -k[cnt].x);
        k[cnt].u = u, k[cnt].v = v;
      }
    }
  }
}
}  // namespace Solve

int main() {
#ifndef ONLINE_JUDGE
  freopen("3950.in", "r", stdin);
  freopen("3950.out", "w", stdout);
#endif
  Input::main();
  Init::main();
  Solve::main();
}
```


---

## 作者：little_sun (赞：1)

link-cut tree 板子题

这道题可以用来作为link-cut tree的练手题
 
C操作:把发生战争的俩部落的连边cut掉

U操作:把停战的俩部落link起来

Q操作:如果p部落和q部落在一棵树里(树根相同)，就输出"Yes",否则输出"No"

($lct$模板用的是P3690 【模板】Link Cut Tree （动态树）的模板代码)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MaxN = 300010;
int n, m, val[MaxN], p[MaxN], q[MaxN], war;
struct Link_Cut_Tree
{
    int top, ch[MaxN][2], fa[MaxN], sum[MaxN], q[MaxN], rev[MaxN];
    inline void pushup(int x) { sum[x] = sum[ch[x][0]] ^ sum[ch[x][1]] ^ val[x]; }
    inline void pushdown(int x)
    {
        int l = ch[x][0], r = ch[x][1];
        if (rev[x])
        {
            rev[l] ^= 1;
            rev[r] ^= 1;
            rev[x] ^= 1;
            swap(ch[x][0], ch[x][1]);
        }
    }
    inline bool isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
    void rotate(int x)
    {
        int y = fa[x], z = fa[y], l, r;
        if (ch[y][0] == x)
            l = 0;
        else
            l = 1;
        r = l ^ 1;
        if (!isroot(y))
        {
            if (ch[z][0] == y)
                ch[z][0] = x;
            else
                ch[z][1] = x;
        }
        fa[x] = z;
        fa[y] = x;
        fa[ch[x][r]] = y;
        ch[y][l] = ch[x][r], ch[x][r] = y;
        pushup(y), pushup(x);
    }
    void splay(int x)
    {
        top = 1;
        q[top] = x;
        for (int i = x; !isroot(i); i = fa[i])
            q[++top] = fa[i];
        for (int i = top; i; i--)
            pushdown(q[i]);
        while (!isroot(x))
        {
            int y = fa[x], z = fa[y];
            if (!isroot(y))
            {
                if ((ch[y][0] == x) ^ (ch[z][0] == y))
                    rotate(x);
                else
                    rotate(y);
            }
            rotate(x);
        }
    }
    void access(int x)
    {
        for (int t = 0; x; t = x, x = fa[x])
            splay(x), ch[x][1] = t, pushup(x);
    }
    void makeroot(int x)
    {
        access(x);
        splay(x);
        rev[x] ^= 1;
    }
    int find(int x)
    {
        access(x);
        splay(x);
        while (ch[x][0])
            x = ch[x][0];
        return x;
    }
    void split(int x, int y)
    {
        makeroot(x);
        access(y);
        splay(y);
    }
    void cut(int x, int y)
    {
        makeroot(x);
        if (find(y) != x || fa[x] != y || ch[x][1])
            return;
        fa[x] = ch[y][0] = 0;
        pushup(y);
    }
    void link(int x, int y)
    {
        makeroot(x);
        fa[x] = y;
    }
} t;
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i < n; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        t.link(u, v);
    }
    for(int i = 1; i <= m; i++)
    {
        std::string op;
        std::cin >> op;
        if(op == "Q")
        {
            int x, y;
            scanf("%d%d", &x, &y);
            int fx = t.find(x), fy = t.find(y);
            if(fx == fy)
                printf("Yes\n");
            else printf("No\n");
        }
        else if(op == "C")
        {
            ++war;
            scanf("%d%d", &p[war], &q[war]);
            t.cut(p[war], q[war]);
        }
        else
        {
            int x;
            scanf("%d", &x);
            t.link(p[x], q[x]);
        }
    }
    return 0;
}
```



---

## 作者：yzhang (赞：1)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10203241.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P3950)

### 这题用Link-Cut-Tree解决，[Link-Cut-Tree详解](https://www.cnblogs.com/yzhang-rp-inf/p/10201857.html)

我们用Link-Cut-Tree维护连通性~~（十分无脑）~~

一开始先把树中每条边的两端连接

U操作：把u,v两个点连起来

C操作：把u,v两个点分开来

Q操作：判断在这个森林里u的根和v的根是否相等（是否连通）

```cpp
#include <bits/stdc++.h>
#define N 300005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void Swap(register int &a,register int &b)
{
    a^=b^=a^=b;
}
struct Link_Cut_Tree{
	int c[N][2],fa[N],top,q[N],rev[N];
	inline bool isroot(register int x)
	{
		return c[fa[x]][0]!=x&&c[fa[x]][1]!=x;
	}
	inline void pushdown(register int x)
	{
		if(rev[x])
		{
			int l=c[x][0],r=c[x][1];
			rev[l]^=1,rev[r]^=1,rev[x]^=1;
			Swap(c[x][0],c[x][1]);
		}
	}
	inline void rotate(register int x)
	{
		int y=fa[x],z=fa[y],l,r;
		l=c[y][0]==x?0:1;
		r=l^1;
		if(!isroot(y))
			c[z][c[z][0]==y?0:1]=x;
		fa[x]=z;
		fa[y]=x;
		fa[c[x][r]]=y;
		c[y][l]=c[x][r];
		c[x][r]=y;
	}
	inline void splay(register int x)
	{
		top=1;
		q[top]=x;
		for(register int i=x;!isroot(i);i=fa[i])
			q[++top]=fa[i];
		for(register int i=top;i;--i)
			pushdown(q[i]);
		while(!isroot(x))
		{
			int y=fa[x],z=fa[y];
			if(!isroot(y))
				rotate((c[y][0]==x)^(c[z][0]==y)?(x):(y));
			rotate(x);
		}
	}
	inline void access(register int x)
	{
		for(register int t=0;x;t=x,x=fa[x])
		{
			splay(x);
			c[x][1]=t;
		}
	}
	inline void makeroot(register int x)
	{
		access(x);
		splay(x);
		rev[x]^=1;
	}
	inline int findroot(register int x)
	{
		access(x);
		splay(x);
		while(c[x][0])
			x=c[x][0];
		return x;
	}
	inline void split(register int x,register int y)
	{
		makeroot(x);
		access(y);
		splay(y);
	}
	inline void cut(register int x,register int y)
	{
		split(x,y);
		c[y][0]=0;
		fa[x]=0;
	}
	inline void link(register int x,register int y)
	{
		makeroot(x);
		fa[x]=y;	
	}	
}T;
int n,m,cnt;
int a[N],b[N];
int main()
{
	n=read(),m=read();
	for(register int i=1;i<n;++i)
	{
		int u=read(),v=read();
		T.link(u,v);
	}
	while(m--)
	{
		char ch=getchar();
		while(ch!='Q'&&ch!='C'&&ch!='U')
			ch=getchar();
		if(ch=='Q')
		{
			int x=read(),y=read();
			puts(T.findroot(x)==T.findroot(y)?"Yes":"No");
		} 
		else if(ch=='C')
		{
			a[++cnt]=read(),b[cnt]=read();
			T.cut(a[cnt],b[cnt]);
		}
		else
		{
			int x=read();
			T.link(a[x],b[x]);
		}
	}
}
```




---

## 作者：arfa (赞：1)

此题用树链剖分是大材小用了,因为它可以处理 $p,q$ 不相邻的情况。

简化一下题意:

- $Q\ p\ q$ 代表查询树上最短路径 $p\ q$ (也就是 $p->lca(p,q)->q$)之间有没有边的为黑色。有黑色就输出 $No$,全部都是白色输出 $Yes$。

- $C\ p\ q$ 代表让 $p,q$ 的连边变为黑色。($p,q$ 相邻)

- $U\ p$ 代表让第 $p$ 次修改的连边变为白色。

这都是一些树上的操作,乍一看可以用树剖直接搞。但是因为这里是 **边** 进行操作,所以我们可以 **以点代边** ,把边看做点。每一次查询的时候 $lca(p,q)$ 是不能算的。

修改的话就简单了,因为是相邻的,所以我们可以直接把 $dep$ 比较深的那个点记录 (用来结束战争) 并在线段树上单点 $+1$。对于每一次结束战争我们就把记录的那个点在线段树上 $-1$。

如果 $p,q$ 不相邻,我们可以加入树剖的修改操作,但是线段树的修改操作就必须是 **区间赋值**,需要打一个精妙的标记。

时间复杂度: $O(n\log^2 n)$,常数巨大。

```pascal
// luogu-judger-enable-o2

Uses math;

var
    recf,cnt,size,dfn,dep,top,father,son:array[-1..3100000] of longint;
    next,reach:array[-1..8500000] of longint;
    left,right:array[-1..8500000] of longint;
    ques:array[-1..3100000] of longint;
    tree:array[-1..15000000] of int64; // 线段树的空间要开大
    i,n,m,l,r,dfnum,tot,root,tail:longint;
    order:char;

procedure swap(var a,b:longint);var t:longint; begin t:=a; a:=b; b:=t; end;

procedure add(l,r:longint);
begin
    inc(tot);
    reach[tot]:=r;
    next[tot]:=cnt[l];
    cnt[l]:=tot;
end;

procedure Dfs_1(x:longint);
var i:longint;
begin
    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;
    while i<>-1 do
    begin
        if dep[reach[i]]=0 then
        begin
            dep[reach[i]]:=dep[x]+1;
            father[reach[i]]:=x;
            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);
            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];
        end;
        i:=next[i];
    end;
end;

procedure Dfs_2(x,centre:longint);
var i:longint;
begin
    inc(dfnum); dfn[x]:=dfnum; recf[dfnum]:=x; top[x]:=centre;
    if son[x]=0 then exit; Dfs_2(son[x],centre);
    i:=cnt[x];
    while i<>-1 do
    begin
        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);
        i:=next[i];
    end;
end;

procedure Build(k,l,r:longint);
var mid:longint;
begin
    left[k]:=l; right[k]:=r;
    if (l=r) then exit;
    mid:=(l+r) >> 1;
    Build(k << 1,l,mid); Build(k << 1+1,mid+1,r);
end;

procedure Change(k,x,modify:longint);
var mid:longint;
begin
    if left[k]=right[k] then begin inc(tree[k],modify); exit; end;
    mid:=(left[k]+right[k]) >> 1;
    if x<=mid then Change(k << 1,x,modify) else Change(k << 1+1,x,modify);
    tree[k]:=tree[k << 1]+tree[k << 1+1];
end;

function Query(k,x,y:longint):int64;
var mid:longint;
begin
    Query:=0;
    if x>y then exit(0);
    if (x<=left[k])and(right[k]<=y) then exit(tree[k]);
    mid:=(left[k]+right[k]) >> 1;
    if mid>=y then inc(Query,Query(k << 1,x,y)) else
    if mid<x then inc(Query,Query(k << 1+1,x,y)) else
    inc(Query,Query(k << 1,x,mid)+Query(k << 1+1,mid+1,y));
end;

function Refer(x,y:longint):string; // 查询
var tmp:longint;
begin
    while top[x]<>top[y] do
    begin
        if dep[top[x]]<dep[top[y]] then swap(x,y);
        tmp:=Query(1,dfn[top[x]],dfn[x]); if tmp>=1 then exit('No'); // 如果这一段有一个黑色,那么 No
        x:=father[top[x]];
    end;
    if dep[x]>dep[y] then swap(x,y);
    tmp:=Query(1,dfn[x]+1,dfn[y]); if tmp>=1 then exit('No'); // dfn[x]+1 是因为 lca(x,y) 不能加
    exit('Yes'); 
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    readln(n,m); root:=1; recf[-1]:=-1;
    for i:=1 to n-1 do begin readln(l,r); add(l,r); add(r,l); end;
    dep[root]:=1; father[root]:=1;
    Dfs_1(root); Dfs_2(root,root); Build(1,1,n);
    for i:=1 to m do
    begin
        read(order);
        if order='C' then begin readln(l,r); if dep[l]<dep[r] then l:=r; Change(1,dfn[l],1); inc(tail); ques[tail]:=l; end;
        if order='Q' then begin readln(l,r); writeln(Refer(l,r));end;
        if order='U' then begin readln(l); Change(1,dfn[ques[l]],-1);  end;
    end;
end.
```

---

## 作者：SofanHe (赞：1)

# 这是一篇假的树剖题解

###### ~~为什么是假的?因为我是用单点来搞的~~

### 题目分析

首先这是个树,维护一个路径的信息.

~~其次,这是一个学_树据结构_学傻了的人~~

我们把边能否通行视为它连接的相对较深的节点能否通行.

每次找路径我们就找这些点权就行了.

### 具体实现

初始每个点权都是0.

每进行一次战争就在较深的那个点上-1.

战争结束就在对应的点上+1.

那么整个路通不通就是路径上权值和是否是0.

### 还有个问题

**任何两个路径上的点,在LCA处的点权是无意义的**

为什么?LCA记录的是LCA与上面的点的相对关系,但是,我们**根本不走这条边!**

于是就得搞一下了.

#### 这里提供两种方法

1.每次查询在LCA处+1.

具体实现直接就树剖LCA一块就好了.

2.查到LCA了就转成重儿子.

因为一定是一个链了,那就直接转重儿子肯定还是一个链啊,而且还不会涉及LCA的点权.

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Nmax = 300010;
long long Pointval[Nmax],ans;
int to[Nmax<<1],net[Nmax<<1],fr[Nmax],cntside,n,m,r,p1,p2,p3;
void add_side(int froms,int tos){
	net[++cntside]=fr[froms];fr[froms]=cntside;to[cntside]=tos;
}
int fa[Nmax],size[Nmax],hson[Nmax],deep[Nmax];
void dfs1(int start,int fat){
	deep[start]=deep[fat]+1;
	fa[start]=fat;size[start]=1;
	for(int lzh=fr[start];lzh;lzh=net[lzh]){
		if(to[lzh]==fat)continue;
		dfs1(to[lzh],start);
		size[start]+=size[to[lzh]];
		if(size[to[lzh]]>size[hson[start]])
			hson[start]=to[lzh];
	}
}
int id[Nmax],cntid,top[Nmax];
void dfs2(int start,int tops){
	id[start]=++cntid;
	top[start]=tops;
	if(hson[start])
		dfs2(hson[start],tops);
	for(int lzh=fr[start];lzh;lzh=net[lzh]){
		if(to[lzh]==fa[start])continue;
		if(to[lzh]==hson[start])continue;
		dfs2(to[lzh],to[lzh]);
	}
}
#define mid ((ln+rn)>>1)
#define ls lson[num]
#define rs rson[num]
long long P,sum[Nmax<<1],pt;
int lson[Nmax<<1],rson[Nmax<<1],root;
void Change(int &num,int ln,int rn,int pos,int nd){
	if(!num)	num=++pt;	sum[num]+=nd;
	if(ln==rn)	return;
	if(pos<=mid)Change(ls,ln,mid,pos,nd);
	else 		Change(rs,mid+1,rn,pos,nd);
}
long long Gsum(int num,int ln,int rn,int ld,int rd){
	if(rn<ld||ln>rd)return 0;if(!num)return 0;
	if(ln>=ld&&rn<=rd)	return sum[num];
	return Gsum(ls,ln,mid,ld,rd)+Gsum(rs,mid+1,rn,ld,rd);
}

int Wars[Nmax],cntwar;
void work1(){
	scanf("%d%d",&p1,&p2);
	while(top[p1]!=top[p2]){
		if(deep[top[p1]]<deep[top[p2]])	swap(p1,p2);
		if(Gsum(root,1,n,id[top[p1]],id[p1])<0){cout<<"No\n";return;}
		p1=fa[top[p1]];
	}
	if(p1==p2){cout<<"Yes\n";return;}
	if(id[p1]>id[p2])swap(p1,p2);p1=hson[p1];
	if(Gsum(root,1,n,id[p1],id[p2])<0){cout<<"No\n";return;}
	cout<<"Yes\n";return;
}
void work2(){
	scanf("%d%d",&p1,&p2);
	if(fa[p1]==p2)	Change(root,1,n,id[p1],-1),Wars[++cntwar]=p1;
	else			Change(root,1,n,id[p2],-1),Wars[++cntwar]=p2;
}
void work3(){
	scanf("%d",&p1);
	Change(root,1,n,id[Wars[p1]],1);
}
char opt;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;++i){
		scanf("%d%d",&p1,&p2);
		add_side(p1,p2);add_side(p2,p1);
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=m;++i){
		for(opt=getchar();opt!='Q'&&opt!='C'&&opt!='U';opt=getchar());
		switch(opt){
			case 'Q':work1();break;
			case 'C':work2();break;
			case 'U':work3();break;
		}
	}
	return 0;
}
```

~~为了节省空间,我写了动态开点线段树,然而没有任何作用~~

$T^{hank}_{you}$ $F^{or}_{read}$

---

## 作者：半仙胡小桃 (赞：1)

##题意描述：


给你有N个点的一棵树。

C u v 表示 u v之间的道路不能通行

Q u v 表示 询问 u v之间是否有不可通行的道路

U u 表示 第u个 C操作失效

写一种数据结构，支持以上三种操作。

##题目分析：


~~Woc，这题目不会让我打LCT吧。~~

等一下，好像可以树剖解决唉！

~~钟爱暴力数据结构的我~~

我们先进行树剖，然后维护一颗边权线段树，支持区间修改和区间查询。

每次把封锁道路的时间视为 u->lca(u,v)->v上的路权值+1

查询的时候只要查询 u->lca(u,v)->v这条路上的权值是否为0即可

800ms左右，效率还可以，就不写树状数组和zhw了。

```cpp
#include <cstdio>
#include <iostream>
#define lson (o<<1),l,mid
#define rson (o<<1)+1,mid+1,r
using namespace std;
const int maxm=310000;
int deep[maxm],son[maxm],size[maxm],fa[maxm],top[maxm];
int head[maxm],to[maxm<<1],net[maxm<<1],cnt;
int p[maxm],val[maxm];
int id[maxm],tot;
int n,m,root;
struct node{
    int l,r,siz,maxi,sum,add;
};
node t[maxm*4];
struct war{
    int u,v;
};
war a[maxm];
inline void add(int x,int y)
{
    to[++cnt]=y;
    net[cnt]=head[x];
    head[x]=cnt;
}
int dfs1(int now,int fax,int dep)
{
    fa[now]=fax,deep[now]=dep,size[now]=1;
    int maxson=-1;
    for(int i=head[now];i;i=net[i])
    if(to[i]!=fax)
    {
        size[now]+=dfs1(to[i],now,dep+1);
        if(maxson<size[to[i]])
         son[now]=to[i],maxson=size[to[i]];
    }
    return size[now];
}
void dfs2(int now,int topx)
{
    id[now]=++tot;
    val[tot]=p[now];
    top[now]=topx;
    if(!son[now]) return;
    dfs2(son[now],topx);
    for(int i=head[now];i;i=net[i])
     if(!id[to[i]])
      dfs2(to[i],to[i]);
}
inline void update(int o)
{
    t[o].sum=(t[(o<<1)].sum+t[(o<<1)|1].sum);
    t[o].maxi=max(t[(o<<1)].maxi,t[(o<<1)|1].maxi);
}
inline void pushdown(int o)
{
    int adi=t[o].add;
    for(int i=0;i<=1;i++)
     t[(o<<1)+i].sum=(t[(o<<1)+i].sum+(t[(o<<1)+i].siz*adi)),t[(o<<1)+i].add=(t[(o<<1)+i].add+adi);
    t[o].add=0;
}
void build(int o,int l,int r)
{
    t[o].l=l,t[o].r=r,t[o].siz=r-l+1;
    if(l==r)
    {
        t[o].sum=t[o].maxi=val[l];
        return;
    }
    int mid=(l+r)>>1;
    build(lson),build(rson);
    update(o);
}
void adj(int o,int ql,int qr,int num)
{
    int l=t[o].l,r=t[o].r;
    if(ql<=l&&qr>=r)
    {
        t[o].sum=(t[o].sum+(t[o].siz*num));
        t[o].add=(t[o].add+num);
        return;
    }
    pushdown(o);
    int mid=(l+r)>>1;
    if(ql<=mid) adj((o<<1),ql,qr,num);
    if(qr>mid) adj((o<<1)|1,ql,qr,num);
    update(o);
}
int ask(int o,int ql,int qr)
{
    int l=t[o].l,r=t[o].r;
    if(ql<=l&&qr>=r)
     return t[o].sum;
    pushdown(o);
    int mid=(l+r)>>1;
    int p1=0,p2=0;
    if(ql<=mid) p1=ask((o<<1),ql,qr);
    if(qr>mid) p2=ask((o<<1)|1,ql,qr);
    return (p1+p2);
}
inline int tree_sum(int u,int v)
{
    int ans=0;
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) swap(u,v);
        ans=(ans+ask(1,id[top[u]],id[u]));
        if(ans) return ans;
        u=fa[top[u]];
    }
    if(deep[u]<deep[v]) swap(u,v);
    ans=(ans+ask(1,id[v]+1,id[u]));
    return ans;
}
inline void tree_x(int u,int v,int num)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) swap(u,v);
        adj(1,id[top[u]],id[u],num);
        u=fa[top[u]];
    }
    if(deep[u]<deep[v]) swap(u,v);
    adj(1,id[v]+1,id[u],num);
}
inline int read()
{
    int x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9') 
    {
        if(ch=='-') w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
int main()
{   
    freopen("lct.in","r",stdin);
    freopen("lct.out","w",stdout);
    n=read(),m=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    dfs1(1,0,0),dfs2(1,1);
    build(1,1,tot);
    char s[10];
    int nows=0;
    for(int i=1,u,v,x;i<=m;i++)
    {
        scanf("%s",s);
        if(s[0]=='U')
         x=read(),tree_x(a[x].u,a[x].v,-1);
        if(s[0]=='Q')
        {
            u=read(),v=read();
            if(tree_sum(u,v)) printf("No\n");
            else printf("Yes\n");
        }
        if(s[0]=='C')
        {
           a[++nows].u=read(),a[nows].v=read();
           tree_x(a[nows].u,a[nows].v,1);
        }
    }
    return 0;
}
```

---

## 作者：vectorwyx (赞：0)

来篇线段树+倍增lca的亲民题解。

我们把树上的边权初始化为 $0$，开战视为将 $p,q$ 两点间的边权 $+1$，停战视为 $-1$。那么 $p,q$ 两点互相可达等价于从 $p$ 到 $q$ 的简单路径的边权和为 $0$。

指定 $1$ 为根结点，考虑维护每个点到根结点的简单路径的边权和 $f_i$。询问 $p$ 到 $q$ 的边权和就可以转化为询问 $f_p+f_q-2\times f_{lca(p,q)}$。而将 $p,q$ （不妨设 $q$ 是 $p$ 的父亲）两点间的边权 $+k$（$k$ 为整数）就相当于把以 $p$ 为根的子树里的所有点的权值都 $+k$。这是经典问题，用一棵支持区间加单点查询的线段树维护 $dfs$ 序列即可（可以用树状数组代替）。时间复杂度为 $O((n+m)logn)$

代码如下（点个赞再走吧，谢谢您！QAQ）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ls(p) p<<1
#define rs(p) p<<1|1
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}

const int N=3e5+5,M=20;
struct Edge{
	int to,next;
}e[N<<1];

struct Node{
	int L,R,val=0,tag=0;
}tree[N<<2];
int head[N],tot,dfn[N],ti,dep[N],fa[N][M],n,q,lg,war[N],top,siz[N];

void connect(int x,int y){
	e[++tot]=(Edge){y,head[x]};
	head[x]=tot;
}

void dfs(int x){
	dfn[x]=++ti;
	siz[x]=1;
	for(int i=head[x];i;i=e[i].next){
		int p=e[i].to;
		if(dfn[p]) continue;
		dep[p]=dep[x]+1;
		fa[p][0]=x;
		dfs(p);
		siz[x]+=siz[p];
	}
}

void push_up(int now){tree[now].val=tree[ls(now)].val+tree[rs(now)].val;}

void build(int now,int L,int R){
	tree[now].L=L,tree[now].R=R;
	if(L==R) return;
	int mid=(L+R)>>1;
	build(ls(now),L,mid);
	build(rs(now),mid+1,R);
}

void push_down(int now){
	int lt=ls(now),rt=rs(now),k=tree[now].tag;
	tree[lt].val+=(tree[lt].R-tree[lt].L+1)*k;
	tree[lt].tag+=k;
	tree[rt].val+=(tree[rt].R-tree[rt].L+1)*k;
	tree[rt].tag+=k;
	tree[now].tag=0;
}

void update(int now,int aim_L,int aim_R,int k){
	if(tree[now].L>=aim_L&&tree[now].R<=aim_R){
		tree[now].val+=(tree[now].R-tree[now].L+1)*k;
		tree[now].tag+=k;
		return;
	}
	int mid=(tree[now].L+tree[now].R)>>1;
	if(tree[now].tag) push_down(now);
	if(aim_L<=mid) update(ls(now),aim_L,aim_R,k);
	if(aim_R>mid) update(rs(now),aim_L,aim_R,k);
	push_up(now);
}

int ask(int now,int aim){
	if(tree[now].L==tree[now].R) return tree[now].val;
	int mid=(tree[now].L+tree[now].R)>>1;
	if(tree[now].tag) push_down(now);
	if(aim<=mid) return ask(ls(now),aim);
	return ask(rs(now),aim);
}

int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	go(i,lg,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	if(x==y) return x;
	go(i,lg,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

int main(){
	cin>>n>>q;lg=log(n)/log(2);
	fo(i,1,n-1){
		int x=read(),y=read();
		connect(x,y);
		connect(y,x);
	}
	build(1,1,n);
	dep[1]=1;dfs(1);
	fo(j,1,lg)
		fo(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1];
	char ch;
	while(q--){
		ch=getchar();while(!isalpha(ch)) ch=getchar();
		if(ch=='Q'){
			int x=read(),y=read(),k=lca(x,y);
			puts(ask(1,dfn[x])+ask(1,dfn[y])==2*ask(1,dfn[k])?"Yes":"No");
		}else if(ch=='C'){
			int x=read(),y=read();
			if(fa[x][0]!=y) swap(x,y);
			war[++top]=x;//,war[top][1]=y;
			update(1,dfn[x],dfn[x]+siz[x]-1,1);
		}else{
			int p=read(),x=war[p];
			update(1,dfn[x],dfn[x]+siz[x]-1,-1);
		}
	}
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：K2sen (赞：0)

## 题意
1.（Q p q）从第 p 个部落出发的建筑工人想知道能否到达第 q 个部落了，你要回答的便是（Yes/No），注意大小写

2.（C p q）第 p 个部落与第 q 个部落开战了，保证他们一定是相邻的部落，且目前处于停战（未开战）状态

3.（U x ） 第 x 次发生的战争结束了，它将永远的被载入史册，不复存在（保证这个消息不会告诉你多次）

## solution
我们把不能通过的在线段树上赋成-1,然后只需要去一个区间min

判断一下是不是-1就知道能不能过去了.

区间min

```cpp
int query(int rt, int l, int r, int L, int R) {
		if (L <= l && r <= R) return tree[rt].min;
		int mid = (l + r) >> 1, ans = 1e9;
		if (L <= mid) ans = min(ans, query(lson, l, mid, L, R));
		if (R > mid) ans = min(ans, query(rson, mid + 1, r, L, R));
		return ans; 
	}
```

## code
```cpp
/*
	Auther:_Destiny
	time:2020.5.6
*/
#include <bits/stdc++.h>
#define ll long long
#define N 300010
#define M 1010

using namespace std;
int n, m, p[N], q[N];
int pre[N], dep[N], top[N], fath[N], siz[N], son[N], dfn[N], w[N];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

namespace Seg {
	#define lson rt << 1
	#define rson rt << 1 | 1
	struct node {
		int min;
	}tree[N << 2];
	void push_up(int rt) {
		tree[rt].min = min(tree[lson].min, tree[rson].min);
	}
	void build(int rt, int l, int r) {
		if (l == r) {
			tree[rt].min = w[pre[l]];
			return;
		}
		int mid = (l + r) >> 1;
		build(lson, l, mid);
		build(rson, mid + 1, r);
		push_up(rt);
	}
	void update(int rt, int c, int l, int r, int pow) {
		if (l == r) {
			tree[rt].min = c;
			return;
		}
		int mid = (l + r) >> 1;
		if (pow <= mid) update(lson, c, l, mid, pow);
		else update(rson, c, mid + 1, r, pow);
		push_up(rt);
	}
	int query(int rt, int l, int r, int L, int R) {
		if (L <= l && r <= R) return tree[rt].min;
		int mid = (l + r) >> 1, ans = 1e9;
		if (L <= mid) ans = min(ans, query(lson, l, mid, L, R));
		if (R > mid) ans = min(ans, query(rson, mid + 1, r, L, R));
		return ans; 
	}
}

namespace Cut {
	int head[N << 1], add_edge, cnt;
	struct node {
		int next, to;
	}edge[N << 1];
	void add(int from, int to) {
		edge[++add_edge].next = head[from];
		edge[add_edge].to = to;
		head[from] = add_edge;
	}
	void dfs(int x, int fa) {
		dep[x] = dep[fa] + 1, fath[x] = fa, siz[x] = 1;
		for (int i = head[x]; i; i = edge[i].next) {
			int to = edge[i].to;
			if (to == fa) continue;
			w[to] = 1;  
			dfs(to, x), siz[x] += siz[to];
			if (siz[son[x]] < siz[to]) son[x] = to;
		}
	}
	void dfs2(int x, int tp) {
		top[x] = tp, dfn[x] = ++cnt, pre[cnt] = x;
		if (son[x]) dfs2(son[x], tp);
		for (int i = head[x]; i; i = edge[i].next) {
			int to = edge[i].to;
			if (to == son[x] || to == fath[x]) continue;
			dfs2(to, to);
		}
	}
	bool askmin(int x, int y) {
		int ans = 11111;
		while (top[x] != top[y]) {
			if (dep[top[x]] < dep[top[y]]) swap(x, y);
			ans = min(ans, Seg::query(1, 1, n, dfn[top[x]], dfn[x]));
			x = fath[top[x]];
		}
		if (dfn[x] > dfn[y]) swap(x, y);
		ans = min(ans, Seg::query(1, 1, n, dfn[x] + 1, dfn[y]));
		if (ans == 1) return 1;
		else return 0;
	}
}

int main() {
	n = read(), m = read();
	for (int i = 1, x, y; i <= n - 1; i++) {
		x = read(), y = read();
		Cut::add(x, y), Cut::add(y, x);
	}
	Cut::dfs(1, 1), Cut::dfs2(1, 1), Seg::build(1, 1, n);
	char cc; int ji = 0;
	for (int i = 1, x, y; i <= m; i++) {
		cin >> cc;
		if (cc == 'Q') {
			x = read(), y = read();
			if (x == y) puts("Yes");
			else if (Cut::askmin(x, y) == 1) puts("Yes");
			else puts("No"); 
		} else if (cc == 'C') {
			x = read(), y = read();
			p[++ji] = x, q[ji] = y;
			Seg::update(1, -1, 1, n, max(dfn[x], dfn[y])); 
		} else if (cc == 'U') {
			x = read();
			Seg::update(1, 1, 1, n, max(dfn[p[x]], dfn[q[x]]));
		}	
	}
	return 0;
}
```

---

## 作者：FutureThx (赞：0)

最近一直没写树剖，基本忘光了，复习一下顺便写篇题解帮助自己理解

### 题目大意

给出一棵节点数为 $N$ 的树，要求处理三个操作

- ```C p q``` 在端点为 $q$ 与 $p$ 的边上打上标记

- ```Q p q``` 询问节点 $p$ 到节点 $q$ 的唯一路径中是否存在被打上标记的边

- ```U x``` 将第 $x$ 次 C 操作的两个端点的标记清除，数据保证不会重复清除

对于每一次 Q 询问，若路径存在标记边输出 ```No``` ，否则输出 ```Yes```

### 思路

首先发现这些操作使用树剖很容易操作，具体方法是将每一条边都初始化一个权值 $0$ ，然后对于每个操作依次运行

- 对于 C 修改操作： 可以将被打上标记的边的权值 + 1

- 对于 Q 询问操作： 询问路径中的最大权值，如果为 $0$ 则无标记边，否则就存在

- 对于 U 清除操作： 将这一条边的权值 - 1 即可

然后就是树剖的板子了

### 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;
#define MAX_N 300010
#define inf 0x3f3f3f3f
struct Tree{
    int dep,father,siz,son,id,top;
    vector<int> next;
}node[MAX_N];
void dfs1(int u,int fa,int deep){
    node[u].father = fa;
    node[u].dep = deep;
    node[u].siz = 1;
    int max_son = -1;
    for(int i = 0;i < node[u].next.size();i++){
        int v = node[u].next[i];
        if(v == node[u].father)continue;
        dfs1(v,u,deep+1);
        node[u].siz += node[v].siz;
        if(node[v].siz > max_son){
            max_son = node[v].siz;
            node[u].son = v;
        }
    }
}
int cnt = 0,a[MAX_N];
void dfs2(int u,int tops){
    cnt++;
    node[u].id = cnt;
    node[u].top = tops;
    a[cnt] = 0;
    if(node[u].son == 0)return;
    dfs2(node[u].son,tops);
    for(int i = 0;i < node[u].next.size();i++){
        int v = node[u].next[i];
        if(v == node[u].son || v == node[u].father)continue;
        dfs2(v,v);
    }
}
struct SegmentTree{
    int lson,rson;
    int dat;
}tree[MAX_N * 4];
int lazy_tag[MAX_N * 4];
void build(int p,int l,int r){
    tree[p].lson = l;
    tree[p].rson = r;
    if(l == r){
        tree[p].dat = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    tree[p].dat = max(tree[p*2].dat,tree[p*2+1].dat);
}
void pushdown(int p){
    if(lazy_tag[p] == 0)return;
    tree[p*2].dat += lazy_tag[p];
    tree[p*2+1].dat += lazy_tag[p];
    lazy_tag[p*2] += lazy_tag[p];
    lazy_tag[p*2+1] += lazy_tag[p];
    lazy_tag[p] = 0;
}
int query(int p,int l,int r){
    if(tree[p].lson >= l && tree[p].rson <= r)
        return tree[p].dat;
    pushdown(p);
    int mid = (tree[p].lson + tree[p].rson) >> 1,val = -inf;
    if(l <= mid)val = max(val,query(p*2,l,r));
    if(r > mid)val = max(val,query(p*2+1,l,r));
    return val;
}
void change(int p,int l,int r,int d){
    if(tree[p].lson >= r && tree[p].rson <= r){
        tree[p].dat += d;
        lazy_tag[p] += d;
        return;
    }
    pushdown(p);
    int mid = (tree[p].lson + tree[p].rson) >> 1;
    if(l <= mid)change(p*2,l,r,d);
    if(r > mid)change(p*2+1,l,r,d);
    tree[p].dat = max(tree[p*2].dat,tree[p*2+1].dat);
}
void updRange(int x,int y,int d){
    while(node[x].top != node[y].top){
        int topx = node[x].top,topy = node[y].top;
        if(node[topx].dep < node[topy].dep)swap(x,y),swap(topx,topy);
        change(1,node[topx].id,node[x].id,d);
        x = node[topx].father;
    }
    if(node[x].dep > node[y].dep)swap(x,y);
    change(1,node[x].id+1,node[y].id,d);
}
int qRange(int x,int y){
    int ans = -inf;
    while(node[x].top != node[y].top){
        int topx = node[x].top,topy = node[y].top;
        if(node[topx].dep < node[topy].dep)swap(x,y),swap(topx,topy);
        ans = max(ans,query(1,node[topx].id,node[x].id));
        x = node[topx].father;
    }
    if(node[x].dep > node[y].dep)swap(x,y);
    ans = max(ans,query(1,node[x].id + 1,node[y].id));
    return ans;
}
struct battles{
    int x,y;
}battle[MAX_N];
int t = 0;
int main(){
    ios::sync_with_stdio(false);
    int n,m;
    cin >> n >> m;
    for(int i = 1;i < n;i++){
        int u,v;
        cin >> u >> v;
        node[u].next.push_back(v);
        node[v].next.push_back(u);
    }
    dfs1(1,1,1);
    dfs2(1,1);
    build(1,1,n);
    while(m--){
        char opt;
        cin >> opt;
        if(opt == 'Q'){
            int x,y;
            cin >> x >> y;
            int ans = qRange(x,y);
            if(x == y)cout << "Yes" << endl;
            else if(ans == 0)cout << "Yes" << endl;
            else cout << "No" << endl;
        }
        else if(opt == 'C'){
            t++;
            cin >> battle[t].x >> battle[t].y;
            updRange(battle[t].x,battle[t].y,1);
        }
        else{
            int c;
            cin >> c;
            updRange(battle[c].x,battle[c].y,-1);
        }
    }
    return 0;
}
```

### 后记

$Updata \ 2021.1.11$ 完成题解

---

## 作者：DPair (赞：0)

为什么树链剖分的题目一定要用树链剖分来做呢？

## 【思路】
显然只需要查两点之间是否有断边即可。

那么断边标 $1$ ，然后就是用 dfs 序维护树上的链上信息，感觉挺板子的。

加一个边权转点权即可。

然后连边的话标回 $0$ 就行了。

由于 dfs 序套上线段树只能维护子树信息，考虑使用树上差分的思想，那么就可以维护链上信息了。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef unsigned int UI;
typedef pair <int, int> pi;

template <typename T>
inline void read(T &x){
    x = 0;int fu = 1;
    char c = getchar();
    while(c > 57 || c < 48){
        if(c == 45) fu = -1;
        c = getchar();
    }
    while(c <= 57 && c >= 48){
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x){
    if(x < 0) putchar(45), x = -x;
    if(x > 9) fprint(x / 10);
    putchar(x % 10 + 48);
}
template <typename T>
inline void fprint(T x, char ch){
    fprint(x);putchar(ch);
}
inline char next_char(){
    char ch = getchar();
    while(ch == 9 || ch == 10 || ch == 32) ch = getchar();
    return ch;
}

int n, m;

int head[300005], nxt[600005], e[600005], cnt;

inline void add(int u, int v){
    nxt[++ cnt] = head[u];
    head[u] = cnt;
    e[cnt] = v;
}
int fa[300005][21], tot, dep[300005], dfn[300005], low[300005];
void dfs(int x, int pre){
    dfn[x] = ++ tot;
    dep[x] = dep[pre] + 1;
    for (register int i = head[x];i;i = nxt[i]){
        if(e[i] == pre) continue;
        fa[e[i]][0] = x;
        for (register int j = 1;j <= 20;j ++) fa[e[i]][j] = fa[fa[e[i]][j - 1]][j - 1];
        dfs(e[i], x);
    }
    low[x] = tot;
}

#define LSON rt << 1, l, mid
#define RSON rt << 1 | 1, mid + 1, r

LL lazy[1200005], t[1200005];
inline void pushup(int rt){t[rt] = t[rt << 1] + t[rt << 1 | 1];}
inline void update(int rt, int l, int r, LL val){
    t[rt] += 1ll * (r - l + 1) * val;
    lazy[rt] += val;
}
inline void pushdown(int rt, int l, int r){
    if(lazy[rt]){
        int mid = (l + r) >> 1;
        update(LSON, lazy[rt]);
        update(RSON, lazy[rt]);
        lazy[rt] = 0;
    }
}
void modify(int rt, int l, int r, int x, int y, LL z){
    if(l > r) return ;
    if(x <= l && r <= y) return update(rt, l, r, z);
    pushdown(rt, l, r);
    int mid = (l + r) >> 1;
    if(x <= mid) modify(LSON, x, y, z);
    if(y > mid) modify(RSON, x, y, z);
    pushup(rt);
}
LL query(int rt, int l, int r, int x, int y){
    if(x <= l && r <= y) return t[rt];
    pushdown(rt, l, r);
    int mid = (l + r) >> 1;LL ret = 0;
    if(x <= mid) ret += query(LSON, x, y);
    if(y > mid) ret += query(RSON, x, y);
    return ret;
}
inline int LCA(int x, int y){
    if(dep[x] < dep[y]) swap(x, y);
    for (register int i = 20;i >= 0;i --){
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
        if(dep[x] == dep[y]) break;
    }
    if(x == y) return x;
    for (register int i = 20;i >= 0;i --){
        if(fa[x][i] ^ fa[y][i]){
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}
int _u[300005], _v[300005], _tot;
int main(){
    read(n);read(m);
    for (register int i = 1;i < n;i ++){
        int u, v;read(u);read(v);
        add(u, v);add(v, u);
    }
    dfs(1, 0);
    while(m --){
        char opt = next_char();
        int u, v;read(u);
        if(opt == 'U'){
            v = _v[u];u = _u[u];
            if(dep[u] < dep[v]) swap(u, v);
            modify(1, 1, n, dfn[u], low[u], -1);
        }
        if(opt == 'C'){
            read(v);
            _u[++ _tot] = u;_v[tot] = v;
            if(dep[u] < dep[v]) swap(u, v);
            modify(1, 1, n, dfn[u], low[u], 1);
        }
        if(opt == 'Q'){
            read(v);
            int lca = LCA(u, v);
            int num1 = query(1, 1, n, dfn[u], dfn[u]);
            int num2 = query(1, 1, n, dfn[v], dfn[v]);
            int num3 = query(1, 1, n, dfn[lca], dfn[lca]);
            printf("%s\n", num1 + num2 - (num3 << 1)? "No" : "Yes");
        }
    }
    return 0;
}
```

---

## 作者：1saunoya (赞：0)

$\text{这题是个树链剖分的板子题 （好像树剖跑的比 LCT 快）}$

$\text{这题的操作 ： 区间修改 区间查询}$

$\text{我们考虑题目所说的没有重复的x所以我们不用判重直接干}$

$\text{所以把每个加法操作即开战存在vector里面 然后结束了直接查询。。}$

$\text{Yes No 是区间查询 如果能到那个位置 就肯定没有战争即查询的是0}$



$\mathcal Code$

```cpp
//Isaunoya
#include<bits/stdc++.h>
using namespace std ;
inline int read() { register int x = 0 ; register int f = 1 ; register char c = getchar() ;
	for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
	return x * f ;
} int st[105] ;
template < typename T > inline void write(T x , char c = '\n') { int tp = 0 ;
	if(x == 0) return (void) puts("0") ;
	if(x < 0) putchar('-') , x = -x ;
	for( ; x ; x /= 10) st[++ tp] = x % 10 ;
	for( ; tp ; tp --) putchar(st[tp] + '0') ;
	putchar(c) ;
}
//#define Online_Judge
int n ;
vector < pair < int , int > > v ;
const int N = 3e5 + 10 ;
int a[N] ;
struct node {
	int v ;
	int nxt ;
};
node e[N << 1] ; int head[N] ;
int cnt = 0 ;
inline void Add(int u , int v) {
	e[++ cnt].v = v ;
	e[cnt].nxt = head[u] ;
	head[u] = cnt ;
	return ;
} 
int size[N] ;
int top[N] , son[N] ;
int fa[N] ; int id[N] ; int d[N] ;
int idx = 0 ;
inline void Dfs1(int u) {
	size[u] = 1 ;
	for(register int i = head[u] ; i ; i = e[i].nxt) {
		int v = e[i].v ;
		if(v ^ fa[u]) {
			fa[v] = u ;
			d[v] = d[u] + 1 ;
			Dfs1(v) ;
			size[u] += size[v] ;
			if(size[son[u]] < size[v]) son[u] = v ;
		}
	}
}
inline void Dfs2(int u , int t) {
	id[u] = ++ idx ;
	top[u] = t ;
	a[idx] = 0 ;
	if(! son[u]) return ;
	Dfs2(son[u] , t) ;
	for(register int i = head[u] ; i ; i = e[i].nxt) {
		int v = e[i].v ;
		if(v ^ fa[u] && v ^ son[u]) {
			Dfs2(v , v) ;
		}
	}
}
int sum[N << 2] ;
int tag[N << 2] ;
inline void build(int l , int r , int rt) {
	if(l == r) {
		sum[rt] = a[l] ; 
		tag[rt] = 0 ;
		return ;
	}
	int mid = l + r >> 1 ;
	build(l , mid , rt << 1) ;
	build(mid + 1 , r , rt << 1 | 1) ;
	sum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;
	return ;
}
inline void Push_down(int rt , int l , int r) {
	if(tag[rt]) {
		tag[rt << 1] += tag[rt] ;
		tag[rt << 1 | 1] += tag[rt] ;
		int mid = l + r >> 1 ;
		sum[rt << 1] += tag[rt] * (mid - l + 1) ;
		sum[rt << 1 | 1] += tag[rt] * (r - mid) ;
		tag[rt] = 0 ;
		return ;
	}
}
inline void Change(int a , int b , int l , int r , int rt , int val) {
	if(a <= l && r <= b) {
		sum[rt] += val * (r - l + 1) ;
		tag[rt] += val ;
		return ;
	}
	int mid = l + r >> 1 ;
	Push_down(rt , l , r) ;
	if(a <= mid) Change(a , b , l , mid , rt << 1 , val) ;
	if(b > mid) Change(a , b , mid + 1 , r , rt << 1 | 1 , val) ;
	sum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;
	return ;
}
inline int Query(int a , int b , int l , int r , int rt) {
	if(a <= l && r <= b) return sum[rt] ;
	int mid = l + r >> 1 ;
	int ans = 0 ;
	Push_down(rt , l , r) ;
	if(a <= mid) ans += Query(a , b , l , mid , rt << 1) ;
	if(b > mid) ans += Query(a , b , mid + 1 , r , rt << 1 | 1) ;
	return ans ;
}
inline int Query_Range(int x , int y) {
	int fx = top[x] ;
	int fy = top[y] ;
	int ans = 0 ;
	while(fx ^ fy) {
		if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
		ans += Query(id[fx] , id[x] , 1 , n , 1) ;
		x = fa[fx] ;
		fx = top[x] ;
	}
	if(id[x] > id[y]) swap(x , y) ;
	ans += Query(id[x] + 1 , id[y] , 1 , n , 1) ;
	return ans ;
}
inline void Change_Range(int x , int y , int val) {
	int fx = top[x] ;
	int fy = top[y] ;
	int ans = 0 ;
	while(fx ^ fy) {
		if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
		Change(id[fx] , id[x] , 1 , n , 1 , val) ;
		x = fa[fx] ;
		fx = top[x] ;
	}
	if(id[x] > id[y]) swap(x , y) ;
	Change(id[x] + 1 , id[y] , 1 , n , 1 , val) ;
}
signed main() {
#ifdef Online_Judge
	freopen("testdata.in" , "r" , stdin) ;
	freopen("testdata2.out" , "w" , stdout) ;
#endif
	n = read() ; int q = read() ;
	for(register int  i = 1 ; i <= n - 1 ; i ++) {
		int u = read() ;
		int v = read() ;
		Add(u , v) ;
		Add(v , u) ;
	}
	Dfs1(1) ;
	Dfs2(1 , 1) ;
	build(1 , n , 1) ;
	for(register int i = 1 ; i <= q ; i ++) {
		register char c = getchar() ;
		for( ; c != 'C' && c != 'Q' && c != 'U' ; c = getchar()) ;
		if(c == 'Q') {
			int x = read() , y = read() ;
			if(Query_Range(x , y)) puts("No") ;
			else puts("Yes") ;
		}
		if(c == 'C') {
			int x = read() , y = read() ;
			Change_Range(x , y , 1) ;
			v.push_back(make_pair(x , y)) ;
		}
		if(c == 'U') {
			int num = read() - 1 ;
			int x = v[num].first ;
			int y = v[num].second ;
			Change_Range(x , y , - 1) ;
		}
	}
	return 0 ;
}
```

---


# [信息与未来 2023] 电路布线

## 题目描述

电路布局布线（Circuit Layout and Routing）是电子设计自动化（EDA）领域的一个重要概念，它涉及到在电路板或集成电路上安排和连接电子元件的过程。这个过程的目标是在满足电气性能、信号完整性、电磁兼容性等要求的同时，实现对空间、成本和生产工艺的优化。

![](https://cdn.luogu.com.cn/upload/image_hosting/vcbssp42.png)

小小现在需要解决一个简化的电路布线问题，在一个 $n × m$ 的方格中进行电路布线。其中：
- 井号 `#` 标记的格子已经被占用，不能布线。
- 加号 `+` 标记的格子会连接到电路的其他部分，必须被布线。在给定的电路布线问题中，至少有一个格子必须被布线。
- 点号 `.` 标记的格子小小有权选择是否布线：布线即将该格标记为加号，不布线即保持为点号。

小小的任务是选择尽可能多的格子进行布线 (将 `.` 的格子标记为 `+`)，满足：
1. 布线电路连通。即从任意一个已布线的格子，都能通过上、下、左、右移动到相邻已布线格子的方式，到达任意另一个布线的格子。
2. 布线不存在短路 (回路)，即不存在某个布线的格子能通过 $> 2$ 步的上、下、左、右移动到相邻布线格子的方式回到自身，且经过的格子各不相同。

例如，以下是一个电路布线问题，已有三个格子被标记为必须布线 (加号)：
```plain
#....#
....+#
.+####
.+...#
```
以下展示了一种合法和两种不合法的布线方案：
```plain
#+.+.# #.+..# #++..#
+++++# ..+++# .++++#
.+#### .+#### .+####
.++++# .+...# .+...#
合法 不连通 有回路
```

## 说明/提示

### 数据规模

对于 $40\%$ 的数据，满足 $n × m \le 16$。

对于 $100\%$ 的数据，满足 $1\le n, m \le 6$。

### 评分标准

在你的布线方案合法（连通且无回路）的前提下：

- 如果你的方案是最优布线方案，即布线的格子最多，该测试点得满分。
- 否则，该测试点得一半分数。

>本题原始满分为 $20\text{pts}$。

---

SPJ Provider：@[scp020](https://www.luogu.com.cn/user/553625)

## 样例 #1

### 输入

```
2 2
+.
..```

### 输出

```
+.
++```

## 样例 #2

### 输入

```
3 5
...+#
..###
....+```

### 输出

```
++++#
.+###
+++++```

## 样例 #3

### 输入

```
5 6
..++..
.#..#.
.#..#.
.#..#.
......```

### 输出

```
++++++
+#.+#+
+#+.#+
+#++#+
++.+++```

# 题解

## 作者：Nangu (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/B3791)

闲话：过了这道题后的好几个月，突然有人来问我这道题的解法，于是就有了这篇题解。 

## 题意
给定一块 $n\times m$ 的方格，其中一些格子必须铺线，一些格子不能铺线，另一些可铺可不铺。要求：
- 电线联通。
- 不形成回路。

## 题解
这道题大概有以下几种方法：
1. 超纲并且难写的轮廓线DP
2. 正解但是难写的折半搜索
3. 难写的随机乱搞做法

~~反正都很难写就对了。~~

我们从起点开始走起。
### 40分做法：
爆搜即可。枚举每一个方格内放/不放电线，并在最终进行判断是否合法。我们需要实现一个搜索函数和一个判断电线合法的函数:
```cpp
bool dfs2(int x, int y, int prex, int prey){
	if(vis[x][y]) return 0;//有回路
	--cnt, vis[x][y]=1;
	for(auto [tx, ty]:d){
		tx+=x, ty+=y;
		if(tx==prex && ty==prey || tx<1 || ty<1 || tx>n || ty>m || t[tx][ty]!='+') continue;
		if(!dfs2(tx, ty, x, y)) return 0;
	}
	return 1;
}

void dfs(int x, int y, int tot){
	if(y==m+1) ++x, y=1;
	memset(vis, 0, sizeof vis);
	if(x==n+1){
		cnt=tot;//cnt表示总电线数减去搜索到的电线数；若cnt!=0，则该图不连通
		bool flag=0;
		if(tot>res && dfs2(sx, sy, -1, -1) && !cnt){
			memcpy(ans, t, sizeof t);
			res=tot;
		}
		return;
	}
	if(s[x][y]!='#'){
		t[x][y]='+';
		dfs(x, y+1, tot+1);
		t[x][y]=s[x][y];
	} 
	if(s[x][y]!='+') dfs(x, y+1, tot);
}
```
### 100分做法：
观察上述程序，我们发现有很多地方可以剪枝优化：
- 因为题目要求的是最大值，故若当前答案已经不可能成为了最大值，直接返回。
- 若一处有回路，则不管其他地方填不填电线都不影响此处回路。因此，每一次填电线时，我们就进行一次判断判断，若填此电线会造成回路，则直接返回。

改良后的代码：
```cpp
bool dfs2(int x, int y, int prex, int prey){
	if(vis[x][y]) return 0;
	--cnt, vis[x][y]=1;
	for(auto [tx, ty]:d){
		tx+=x, ty+=y;
		if(tx==prex && ty==prey || tx<1 || ty<1 || tx>n || ty>m || t[tx][ty]!='+') continue;
		if(!dfs2(tx, ty, x, y)) return 0;
	}
	return 1;
}

void dfs(int x, int y, int tot){
	if(y==m+1) ++x, y=1;
	if(0.8*((n-x)*m+m-y+1)+tot<=res) return;//1
	memset(vis, 0, sizeof vis);
	if(x==n+1){
		cnt=tot;
		bool flag=0;
		if(dfs2(sx, sy, -1, -1) && !cnt){
			memcpy(ans, t, sizeof t);
			res=tot;
		}
		return;
	}
	if(s[x][y]!='#'){
		t[x][y]='+';
		if(dfs2(x, y, -1, -1)) //2
			dfs(x, y+1, tot+1);
		t[x][y]=s[x][y];
	} 
	if(s[x][y]!='+') dfs(x, y+1, tot);
}
```
于是，我们就用简洁好写的剪枝搜索通过了这道题。

---

## 作者：fire_and_sweets (赞：5)

本题我们考虑一步一步剪枝优化得到最优解。

首先，我们考虑暴力做法。一位一位按照坐标顺序，枚举每一个格子即可。

判断图是否连通可以使用并查集或者深度优先搜索判断，这里不再赘述。关键问题在于如何判断图是否存在欧拉回路。

根据回路的性质，在一个环中，可以证明，其点数等于其边数。所以，我们可以算出原图中所有的点数，即一共放了多少个位置，再算出原图中的边数，即一共有多少个点对 $(x_1,y_1),(x_2,y_2)$ 满足他们上面都布了电路而且这两个格子相邻。

不难发现这样做的正确性可以保证，于是可以拿到 $40$ 分。下面给出代码：

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10, INF = 2e9;
const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};

int n, m, res = -INF;
char a[N][N], b[N][N];
bool st[N][N];

void flood(int x, int y)
{
    for (int i = 0; i < 4; i ++ )
    {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || nx > n || ny < 1 || ny > m || st[nx][ny] || a[nx][ny] != '+') continue;
        st[nx][ny] = true;
        flood(nx, ny);
    }
}

bool C1()
{
    int sx = -1, sy = -1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (a[i][j] == '+') sx = i, sy = j;
        }
    if (sx == -1 || sy == -1) return true;
    
    memset(st, 0, sizeof st);
    st[sx][sy] = 1;
    flood(sx, sy);
    
    int sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (a[i][j] == '+') sum1 ++ ;
            if (st[i][j]) sum2 ++ ;
        }
    return sum1 == sum2;
}

bool C2()
{
	int sum1 = 0, sum2 = 0;
	for (int i = 1; i < n; i ++ )
		for (int j = 1; j <= m; j ++ )
			if (a[i][j] == '+' && a[i + 1][j] == '+') sum1 ++ ;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j < m; j ++ )
			if (a[i][j] == '+' && a[i][j + 1] == '+') sum1 ++ ;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
			if (a[i][j] == '+') sum2 ++ ;
	return sum1 == sum2 - 1;
}

void dfs(int x, int y, int nums)
{
    int nx = x, ny = y + 1;
    if (ny > m) ny = 1, nx ++ ;
    
    if (nx > n)
    {
    	if (!C1() || !C2()) return;
        if (nums > res)
        {
            res = nums;
            for (int i = 1; i <= n; i ++ )
                for (int j = 1; j <= m; j ++ )
                    b[i][j] = a[i][j];
        }
        return;
    }
    if (a[nx][ny] == '#' || a[nx][ny] == '+')
    {
        if (a[nx][ny] == '+') dfs(nx, ny, nums + 1);
        else dfs(nx, ny, nums);
    }
    else
    {
        a[nx][ny] = '+';
        dfs(nx, ny, nums + 1);
        a[nx][ny] = '.';
        dfs(nx, ny, nums);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            cin >> a[i][j];
    memset(b, '.', sizeof b);
    if (a[1][1] == '#') dfs(1, 1, 0);
    else if (a[1][1] == '+') dfs(1, 1, 1);
    else
    {
        a[1][1] = '+';
        dfs(1, 1, 1);
        a[1][1] = '.';
        dfs(1, 1, 0);
    }
    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) cout << b[i][j];
        cout << endl;
    }
    return 0;
}
```

接下来考虑如何进行剪枝。这里不难想到两种剪枝方法：
- 可行性剪枝：如果原图中已经存在了回路，那么整个方案一定都是不合法的。
- 最优性剪枝：哪怕接下来的所有格子都布满电线，电线的数量都没有目前最优方案的高，那么这个方案也可以舍掉。

加上这两个剪枝，足以让我们通过这道题目。

需要说明的是，我在代码中开了一个 `con` 数组，其中 $con_{i,j}$ 表示 $(i,j)$ 这个格子有没有枚举到。

下面给出大家期待已久的满分代码。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10, INF = 2e9;
const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};

int n, m, res = -INF;
char a[N][N], b[N][N];
bool st[N][N], con[N][N];
int colors[N][N], ha[N * N], ha2[N * N];

void flood(int x, int y)
{
    for (int i = 0; i < 4; i ++ )
    {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || nx > n || ny < 1 || ny > m || st[nx][ny] || a[nx][ny] != '+') continue;
        st[nx][ny] = true;
        flood(nx, ny);
    }
}

void flood_with_colors(int x, int y, int col)
{
	for (int i = 0; i < 4; i ++ )
    {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || nx > n || ny < 1 || ny > m || colors[nx][ny] != 0 || a[nx][ny] != '+') continue;
        if (!con[nx][ny]) continue;
        colors[nx][ny] = col;
        flood_with_colors(nx, ny, col);
    }
}

bool C1()
{
    int sx = -1, sy = -1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (a[i][j] == '+') sx = i, sy = j;
        }
    if (sx == -1 || sy == -1) return true;
    
    memset(st, 0, sizeof st);
    st[sx][sy] = 1;
    flood(sx, sy);
    
    int sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (a[i][j] == '+') sum1 ++ ;
            if (st[i][j]) sum2 ++ ;
        }
    return sum1 == sum2;
}

bool C2()
{	
	memset(ha, 0, sizeof ha);
	memset(ha2, 0, sizeof ha2);
	memset(colors, 0, sizeof colors);
	int cnt = 0;
	for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (a[i][j] == '+' && !colors[i][j])
            {
            	colors[i][j] = ++ cnt;
            	flood_with_colors(i, j, cnt);
			}
        }
	int sum1 = 0, sum2 = 0;
	for (int i = 1; i < n; i ++ )
		for (int j = 1; j <= m; j ++ )
			if (a[i][j] == '+' && a[i + 1][j] == '+')
				if (con[i][j] && con[i + 1][j])
					if (colors[i][j] == colors[i + 1][j]) ha[colors[i][j]] ++ ;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j < m; j ++ )
			if (a[i][j] == '+' && a[i][j + 1] == '+')
				if (con[i][j] && con[i][j + 1])
					if (colors[i][j] == colors[i][j + 1]) ha[colors[i][j]] ++ ;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
			if (a[i][j] == '+' && con[i][j]) ha2[colors[i][j]] ++ ;
	for (int i = 1; i <= cnt; i ++ )
		if (ha[i] != ha2[i] - 1 && ha2[i] != 0)
			return false;
	return true;
}

void dfs(int x, int y, int nums)
{
    int nx = x, ny = y + 1;
    if (ny > m) ny = 1, nx ++ ;
    
    int cnt = 0;
    for (int j = y + 1; j <= n; j ++ )
        if (a[x][j] == '.' || a[x][j] == '+') cnt ++ ;
    for (int i = x + 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (a[i][j] == '.' || a[i][j] == '+') cnt ++ ;
    if (cnt + nums <= res) return;
    if (!C2()) return;
    
    if (nx > n)
    {
    	if (!C2()) return;
    	if (!C1()) return;
        if (nums > res)
        {
            res = nums;
            for (int i = 1; i <= n; i ++ )
                for (int j = 1; j <= m; j ++ )
                    b[i][j] = a[i][j];
        }
        return;
    }
    if (a[nx][ny] == '#' || a[nx][ny] == '+')
    {
    	con[nx][ny] = 1;
        if (a[nx][ny] == '+') dfs(nx, ny, nums + 1);
        else dfs(nx, ny, nums);
        con[nx][ny] = 0;
    }
    else
    {
    	con[nx][ny] = 1;
        a[nx][ny] = '+';
        dfs(nx, ny, nums + 1);
        a[nx][ny] = '.';
        dfs(nx, ny, nums);
        con[nx][ny] = 0;
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            cin >> a[i][j];
    memset(b, '.', sizeof b);
    con[1][1] = 1;
    if (a[1][1] == '#') dfs(1, 1, 0);
    else if (a[1][1] == '+') dfs(1, 1, 1);
    else
    {
        a[1][1] = '+';
        dfs(1, 1, 1);
        a[1][1] = '.';
        dfs(1, 1, 0);
    }
    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) cout << b[i][j];
        cout << endl;
    }
    return 0;
}
```

需要说明的是，本代码不能保证通过本题所有可以出的测试点。如果没有一个地方有障碍，此程序运行时间为两秒左右。

---

## 作者：17_zrz (赞：3)

### 题意
小小现在需要解决一个简化的电路布线问题，在一个 
$n×m$ 的方格中进行电路布线。其中：

井号 ```#``` 标记的格子已经被占用，不能布线。
加号 ```+``` 标记的格子会连接到电路的其他部分，必须被布线。在给定的电路布线问题中，至少有一个格子必须被布线。
点号 . 标记的格子小小有权选择是否布线：布线即将该格标记为加号，不布线即保持为点号。

小小的任务是选择尽可能多的格子进行布线 (将 ```.``` 的格子标记为 ```+```)，满足：

- 布线电路连通。即从任意一个已布线的格子，都能通过上、下、左、右移动到相邻已布线格子的方式，到达任意另一个布线的格子。

- 布线不存在短路 (回路)，即不存在某个布线的格子能通过大于 $2$ 步的上、下、左、右移动到相邻布线格子的方式回到自身，且经过的格子各不相同。
### 解析
首先我们考虑暴力枚举，很明显是不行的，那么我们就可以用深搜来做这道题。

我们依次遍历每一个位置，来确定这个位置要不要布线，把最终答案存到 $ans$ 数组中，最后输出就可以了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 6;
int n,m,res,tot,sx,sy;
char ch[N + 5][N + 5],t[N + 5][N + 5],ans[N + 5][N + 5];
bool st[N + 5][N + 5];
int dx[4] = {0,1,0,-1};
int dy[4] = {1,0,-1,0};
//偏移量就不多说了
bool _dfs(int x,int y,int prex,int prey,int& cnt){//判断能不能布线，能布线是true，不能布线是false
	if (st[x][y])
		return false;
	st[x][y] = true;
	cnt--;
	for(int i = 0;i < 4;i++){//上下左右四个方向遍历
		int tx = x + dx[i];
		int ty = y + dy[i];
		if (tx < 1 || tx > n || ty < 1 || ty > m)
			continue;
		if (tx == prex && ty == prey)
			continue;
		if (t[tx][ty] != '+')
			continue;
		if (!_dfs(tx,ty,x,y,cnt))
			return false;//不能布线
	}
	return true;//可以布线
}
void dfs(int x,int y,int tot){
	if (y == m + 1){
		x++;
		y = 1;
	}
   	//到下一行第一列搜索
	memset(st,0,sizeof st);
	if (((n - x) * m + m - y + 1) + tot <= res)
		return;
   	//小小的剪枝
	int cnt = 0;
	if (x == n + 1){
		cnt = tot;
		if (_dfs(sx,sy,-1,-1,cnt) && !cnt){
			memcpy(ans,t,sizeof t);
			res = tot;
		}
		return;
	}
	if (ch[x][y] == '.'){
		t[x][y] = '+';//默认为布线
		if (_dfs(x,y,-1,-1,cnt))//判断能不能布线
			dfs(x,y + 1,tot + 1);//找到一个点能布线，tot加一
		t[x][y] = ch[x][y];//回溯
	}
	dfs(x,y + 1,tot);//到下一列搜索
}
signed main(){
	cin >> n >> m;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++){
			cin >> ch[i][j];
			t[i][j] = ch[i][j];//方便回溯
			if (ch[i][j] == '+'){
				tot++;
				sx = i;
				sy = j;
			}
		}
	dfs(1,1,tot);//从第一行第一列开始搜索，总共有tot个点是'+'
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= m;j++)
			cout << ans[i][j];
		cout << "\n";
	}
    	//输出
	return 0;
}
```

---

## 作者：Hisy (赞：1)

## 解 1：爆搜+剪枝
暴力搜索很明显是枚举每一个为 ```.``` 的点保留原来的状态或者变为 ```+```，最后进行判断。时间复杂度 $2^{n\times m}\times n\times m$，第一个测试数据就是为了能够通过这样的数据构造的。

考虑剪枝优化。如果当前的答案之后就算加上了理论的全部可以为 ```+``` 的地方还是比不过原来的答案，那么就可以直接返回。

这个很像 IDA-star 中的估价函数，只不过这里的最大深度是搜过的答案。

IDA-star 是用于应对最小答案，方法是将答案估小。而这里要求的是最答案，所以应当将答案估大。比如当前答案为 $3$，最优答案为 $5$。假如当前答案扩展出来的答案更优，但是估价函数将其估小估到了 $4$，那就会被击毙从而导致答案可能错误。

这里可以估成之后所有点都为 ```+``` 的情况，一定不会 WA。

判断是否形成环也很好弄，并查集、dfs 或者 bfs 都是可以的。这里用了 dfs（带权并查集之前写挂了，现在还在痛恨并查集。），比如走着走着走到了之前标记的点，并且不是上一个点，那就有环。

发现这里的估价函数剪枝可能优化不了时间（原理同 K 短路的 A-star 算法被卡），还需要加上一些剪枝。

比如当前节点加上去就已经是有环的了，那么就不用往后搜。这个限制了指数（虽然本人很蒻算不出最少能卡多少个不对的情况），而且 dfs 判环最多 $6\times 6=36$，可以当成常数，所以在大数据下不比没剪枝的代码更劣。

加上去就能够 AC 了。
```cpp
#include<bits/stdc++.h>
#define MAXN 17
using namespace std;
int n,m,sx,sy,cnt,ans;
char mp[MAXN][MAXN];
char ouf[MAXN][MAXN];
char dfn[MAXN][MAXN];
bool vis[MAXN][MAXN];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
inline int goal(const int &x,const int &y){
	return n*m-(x-1)*m-y;
}
bool check(const int &x,const int &y,const int &px,const int &py){
	if(vis[x][y]){
		return false;
	}
	vis[x][y]=true;
	--cnt;
	for(register int i=0;i<4;++i){
		const int nx=x+dx[i];
		const int ny=y+dy[i];
		if(px==nx&&py==ny){
			continue;
		}
		if(1<=nx&&nx<=n&&1<=ny&&ny<=m&&mp[nx][ny]=='+'){
			if(!check(nx,ny,x,y)){
				return false;
			}
		}
	}
	return true;
}
void dfs(int x,int y,const int &sum){
	if(y==m+1){
		++x;
		y=1;
	}
	if(sum+goal(x,y)<=ans){
		return;
	}
	if(x==n+1){
		memset(vis,0,sizeof(vis));
		cnt=sum;
		if(check(sx,sy,-1,-1)&&!cnt){
			memcpy(ouf,mp,sizeof(mp));
			ans=sum;
		}
		return;
	}
	if(mp[x][y]=='.'){
		mp[x][y]='+';
		memset(vis,0,sizeof(vis));
		if(check(x,y,-1,-1)){
			dfs(x,y+1,sum+1);
		}
		mp[x][y]='.';
	}
	dfs(x,y+1,sum);
}
int main(){
	register int sum=0;
	scanf("%d %d",&n,&m);
	for(register int i=1;i<=n;++i){
		scanf("%s",mp[i]+1);
		for(register int j=1;j<=m;++j){
			if(mp[i][j]=='+'){
				++sum;
				sx=i;
				sy=j;
			}
			ouf[i][j]=mp[i][j];
		}
	}
	dfs(1,1,sum);
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=m;++j){
			putchar(ouf[i][j]);
		}
		putchar('\n');
	}
	return 0;
}
```
## 解 2：折半搜索
还是原来的复杂度：$2^{n\times m}\times n\times m$，折半搜索还是指数级别的优化。

原理是把上半部分搜一遍，把下半部分搜一遍，时间复杂度 $2^{\frac{n\times m}{2}}\times 2\times n\times m$。

但是具体怎么用折半搜索实现呢？Luogu 上目前没有，我从[官方题解](https://mp.weixin.qq.com/s?__biz=MjM5NTgwNzcwOQ==&mid=2451867312&idx=3&sn=153898fcbeb32adb160a0a7ecd47273a&chksm=b122ce0286554714bc489de0dffc453b2a982286af5e79198812dc819d24eef480d6f76ea3ec&mpshare=1&scene=23&srcid=0423JbwgZWrtNTQURBeKAVEe&sharer_shareinfo=1cfd5f2a3fe72189dc4aaf68170121eb&sharer_shareinfo_first=1cfd5f2a3fe72189dc4aaf68170121eb#rd)上找出了一个方法（本蒻蒻抛弃的自认为难写方法）。

枚举中转点，即在 $\frac{n}{2}$ 的位置，时间复杂度 $2^m$。之后向两边扩散最大的位置，时间复杂度 $2\times 2^{\frac{n}{2}\times m}$，最后判断整个有没有环。

但是，本人后面发现折半搜索各种写法的正确性问题：
- 如果枚举上下最优，那么有可能上面最优下面最优，连起来并不合法。
- 如果枚举上面最优，下面按照上面的网格图进行正确性剪枝，那么连起来可能并不最优。

这里，作者还是希望有人能够评论给出一种正确折半的思路的，谢谢各位观看！

[我是错解](https://www.luogu.com.cn/paste/s2hp4e3m)。

---


# [蓝桥杯青少年组国赛 2023] 数学实验

## 题目背景

本题原题为：[P3147 [USACO16OPEN] 262144 P](https://www.luogu.com.cn/problem/P3147)。

## 题目描述

老师在黑板上写出了一个正整数数列，让所有同学都来做一个数学实验，要求如下:  
1. 这组数总共不超过 $500000$ 个，每个数的大小范围在 $1 \sim 80$ 之间；  
2. 要从这组数中找出两个相邻且相同的数，删掉其中一个数，剩下的一个数加 $1$（例如: 两个相邻的 $6$，变成一个 $7$）；  
3. 重复执行第 $2$ 步；  
4. 当操作无法继续进行时，实验结束，此时，实验结果就是这组数里面最大的数。  

注意: 不同的实验方案得到的最大数不同。  

现在给定了一个正整数数列，请你编写程序计算出能够得到的实验结果最大是多少。

例如：当 $N=6$，这个正整数数列是 $1$、$2$、$2$、$2$、$3$、$4$ 时，得到最大数的方法如下：先将后面两个 $2$ 变成一个 $3$ ，然后 $3$ 和 $3$ 变成 $4$，最后 $4$ 和 $4$ 变成 $5$。可以证明，没有其它更好的方案，故输出 $5$。

## 样例 #1

### 输入

```
6
1 2 2 2 3 4```

### 输出

```
5```

# 题解

## 作者：DashZhanghanxu (赞：0)

# 解析
动态规划做法。

注：该代码仅限于本题可过，原题因为内存限制会有两个点超内存限制。

每个 $dp$ 数组中的元素都代表一个区间，$v$ 代表当前合并后可能可以得到的值。

先初始化 $dp$ 数组（每个数字本身就是一个自己到自己区间，所以记得判断最大值是否要更新），然后我们可以枚举每个区间是否可以合并（即 $[k+1,j]$ 也是 $v$），存在，就将其合并，并且更新当前最大值。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[500001];
unordered_map<int,int>dp[302];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    int n,mx=0;
	cin>>n;
    for(int i=0;i<n;cin>>a[i],mx=max(mx,a[i]),i++);//nothing here
    
    for(int i=0;i<n;dp[a[i]][i]=i,i++);//nothing here
    
    for(int v=1;v<300;v++)
        for(auto&p:dp[v])
            if(dp[v].count(p.second+1))
                dp[v+1][p.first]=dp[v][p.second+1],mx=max(mx,v+1);
    cout<<mx;
}    
```

---

## 作者：Phigros_11calors (赞：0)

双倍经验 [P3147](https://www.luogu.com.cn/problem/P3147)。

### 思路

这道题是区间 DP。

我们使用 $f[i][j]$ 表示以 $j$ 为左端点，第一个能得到数字 $i$ 的右端点的右边位置。首先初始化对于第 $k$ 个数字 $a_k$，$f[a_k][k]=k+1$。

那么想要得到 $i$，我们就需要两个 $i-1$ 进行操作。

由此我们可以得出，以 $j$ 为左端点，第一个能得到数字 $i$ 的右端点的右边位置可以这样求出：

$$f[i][j]=f[i-1][f[i-1][j]]$$

$f[i-1][f[i-1][j]]$ 是什么意思呢？

很明显 $f[i-1][j]$ 是以 $j$ 为左端点，第一个能得到数字 $i-1$ 的右端点的右边位置。

那么只需要从这个位置开始再得到一个 $i-1$，就可以得到 $i$ 了。

能得到的最大的 $i$ 就是答案。

如果 $500000$ 个数字全都是 $80$，那么最大能得到数字 $98$。因此 $i$ 至少需要从 $2$ 枚举到 $98$。

这里我们枚举到 $100$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[101][500005];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        int t;
        cin>>t;
        dp[t][i]=i+1;
    }
    int x;
    for(int i=2;i<=100;i++){
        for(int j=1;j<=n;j++){
            if(!dp[i][j]){
                dp[i][j]=dp[i-1][dp[i-1][j]];
            }
            if(dp[i][j])x=i;
        }
    }
    cout<<x;
}
```

---


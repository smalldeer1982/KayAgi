# [蓝桥杯青少年组国赛 2023] 月球疏散行动

## 题目背景

本题原题：[P5017 [NOIP 2018 普及组] 摆渡车](https://www.luogu.com.cn/problem/P5017)

## 题目描述

为了避免太阳爆发引起的灾难，人类决定给地球装上发动机，最终逃离太阳系。原计划要带着月球一起走，结果月球行星发动机发生灾难性故障，必须炸毁月球。为此，在月球上的工作人员都要疏散回地球。

月球基地有一艘太空穿梭机可以用来疏散工作人员。但是人们分散在各处，必须前往基地集合，他们到达基地的时间不等。穿梭机可以将抵达基地等待登机的工作人员先送回地球，然后再返回基地疏散下一批工作人员。

总共有 $N$ 名工作人员需要疏散，太空穿梭机从月球到地球往返一次花时间 $M$ 小时，第 $i$ 个人抵达基地等待登机的时刻为 $T_i$。

指挥官希望所有工作人员在基地等待的时间总和最小，而且他可以任意安排穿梭机的起飞时间，假定穿梭机足够大，可以装下所有工作人员，在不计登机和下机时间等因素的情况下，最小的等候时间总和是多少？

例如：$N=5$，$M=4$，1 号~5 号工作人员到达基地的时刻依次为 11、3、3、5、10，穿梭机可以在 3 时出发，先送 2 号、3 号工作人员去地球，然后于 7 时返回月球基地；此时，4 号工作人员已于 5 时到达基地，等候了 2 小时。这时让穿梭机马上送走他，然后于 11 时从地球返回基地；此时，5 号工作人员已于 10 时到达基地，等候了 1 小时；而 1 号工作人员刚好于 11 时到达基地，等候 0 小时；穿梭机于 11 时将两人送走，即完成全部疏散任务。总的等候时间 $=$ 4 号工作人员等候时间 $+$ 5 号工作人员等候时间 $=2+1=3$ 小时。无法再找到有更小等候时间总和的方案。

## 样例 #1

### 输入

```
5 4
11 3 3 5 10```

### 输出

```
3```

# 题解

## 作者：YZren (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4281)

# 思路

- 此题与[摆渡车](https://www.luogu.com.cn/problem/P5017)一模一样，很容易想到一个 DP 方程 $dp_i=\min\limits_{j=1}^{i-m} (dp_j+sum_i-sum_j)$ 其中 $dp_i$ 表示前 $i$ 时刻到达的所有学生等待的最小时间。

- 很明显直接做肯定超时，所以需要优化。

- 首先进行前缀和优化，由于 $sum_i$ 不好直接处理，所以分为 $tim_i$ 表示前 $i$ 时刻到达的总人数和 $s_i$ 表示前 $i$ 时刻所有学生到达的总时间，那么 $sum_i-sum_j=(tim_i-tim_j)\times i-s_i+s_j$ 这就可以优化 DP 方程。

- 这样还是会超时，注意到 DP 方程为 $dp_i=\min\limits_{j=1}^{i-m}(-tim_j\times i+s_j+dp_j)+tim_i\times i-s_i$ 很明显可以使用斜率优化，维护下凸壳即可。

- 推一下斜率方程，先令 $k<j<i-m+1$ 并且从 $j$ 转移更优，则 $-tim_j\times i+s_j-dp_j<-tim_k\times i+s_k+dp_k$ 化简可得，先令 $G_i=s_i+dp_i$ 那么 $i>\frac{G_j-G_k}{tim_j-tim_k}$ 就是斜率方程了。

- 有了斜率方程，我们就可以用单调队列优化了，不会的可以先学一下斜率优化。

# Code


```cpp
#include<bits/stdc++.h>
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=4e6+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),m=read(),tim[maxn],dp[maxn],ans,s[maxn],que[maxn],L=1,R,u,maxx;
inline double slop(int k,int j){
	int up=dp[j]+s[j]-dp[k]-s[k];
	if(tim[j]==tim[k]) return (double)up/1e-9;
	else return (double)(up/(tim[j]-tim[k]));
}
inline void work(){ 
	f(i,1,n) u=read(),tim[u]++,s[u]+=u,maxx=max(maxx,u);
	maxx+=m-1; f(i,1,maxx) tim[i]+=tim[i-1],s[i]+=s[i-1];
	f(i,1,maxx){
		if(i>=m){
			while(L<R&&slop(que[R-1],que[R])>=slop(que[R],i-m)) R--;
			que[++R]=i-m;
		}
		while(L<R&&slop(que[L],que[L+1])<=i) L++;
		dp[i]=tim[i]*i-s[i];
		if(L<=R) dp[i]=min(dp[i],dp[que[L]]+(tim[i]-tim[que[L]])*i-s[i]+s[que[L]]);
	}
	ans=dp[maxx-m+1]; f(i,maxx-m+1,maxx) ans=min(ans,dp[i]);
	write(ans);
}
signed main(){work();return !!!!!("YZren");}
```

---


# [ROIR 2023] 美丽序列 (Day 2)

## 题目背景

翻译自 [ROIR 2023 D2T2](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day2.pdf)。

给定一个整数集合 $A$，其中的元素都在 $1$ 到 $8$ 之间。

一个由 $n$ 个在集合 $A$ 中的整数组成的序列 $[a_1, a_2, \dots , a_n]$，如果对于任意数字 $x$，序列中等于 $x$ 的所有元素彼此之间的距离不小于 $x$，则称这个序列是美丽的。换句话说，如果对于任意数字 $x$ 和任意的 $1 \le i < j \le n$，只要 $a_i = a_j = x$，则不等式 $j - i \ge x$ 必然成立，那么这样的序列 $a$ 就被称为美丽的序列。

例如，当 $A=\{1,2,3,4,5\}$ 时，序列 $[2,3,2,4,3,1,1,4]$ 是美丽的，而 $[1,1,4,5,1,4]$ 不是美丽的，因为这个序列中的两个 $4$ 之间的距离是 $3$。

## 题目描述

给定数字 $n$ 和集合 $A$，求出长度为 $n$ 的符合要求的美丽的序列的个数，对 $10^9 + 7$ 取模。

## 说明/提示

在样例中，美丽的序列有 $[1, 1, 1],[1, 1, 2],[1, 2, 1],[2, 1, 1],[2, 1, 2]$。序列 $[2, 2, 2],[1, 2, 2],[2, 2, 1]$ 不是美丽的，因为这三个序列中都有两个数值为 $2$ 的元素相距为 $1$。

本题使用捆绑测试。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $A=\{1,2\},n\le10$ |
| $2$ | $17$ | $A=\{1,2\},n\le30$ |
| $3$ | $12$ | $A=\{1,2\}$ |
| $4$ | $6$ | $A=\{1,k\}$（$2\le k\le8$） |
| $5$ | $16$ | $A$ 中没有超过 $5$ 的元素 |
| $6$ | $15$ | 无特殊性质 |

对于 $100\%$ 的数据，$1 \le n \le 100,1 \le m \le 8$。

## 样例 #1

### 输入

```
3 2
1 2```

### 输出

```
5```

# 题解

## 作者：cff_0102 (赞：8)

数据范围表明这是状压 dp。

但是发现如果真的压缩状态需要使用第 $i$ 位用 $i$ 进制存储的方式来存储状态，太麻烦，所以干脆不压了。

设 $dp_{p,a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8}$ 表示填到第 $p$ 位，且上一个数 $x$ 到第 $p$ 位的距离为 $a_x$ 时，填完剩下位置的方案个数。

因为当 $a_x\ge x$ 时我们不需要关系它具体在哪个位置，只需要知道 $a_x$ 是大于等于 $x-1$ 的就行，所以把 $a_x\ge x$ 的状态全部压缩成 $x-1$。

这里用记忆化搜索实现，每次只需要枚举第 $p$ 位填的数即可，合法状态就继续 dfs，$p=n+1$ 就返回 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[105][1][2][3][4][5][6][7][8];//dp[i][a1][a2][a3][a4][a5][a6][a7][a8]：第 p 位，且上一个 x 到第 p 位的距离为 ax 时，填的方案个数
int mod=1e9+7;
int n;
bool b[10];
int dfs(int p,int a1,int a2,int a3,int a4,int a5,int a6,int a7,int a8){
	//cout<<p<<" "<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<" "<<a5<<" "<<a6<<" "<<a7<<" "<<a8<<endl;
	if(dp[p][a1][a2][a3][a4][a5][a6][a7][a8]!=-1)return dp[p][a1][a2][a3][a4][a5][a6][a7][a8];
	if(p==n+1)return 1;
	//枚举这一位填的数
	int ans=0;
	int a[10]={0,a1+1,a2+1,a3+1,a4+1,a5+1,a6+1,a7+1,a8+1};//到 i+1 的距离
	for(int i=1;i<=8;i++)if(b[i]){
		if(a[i]==i){//可以填 i
			int tmp=a[i];
			a[i]=0;//方便下一行
			ans+=dfs(p+1,min(a[1],0),min(a[2],1),min(a[3],2),min(a[4],3),min(a[5],4),min(a[6],5),min(a[7],6),min(a[8],7));
			ans%=mod;
			a[i]=tmp;//还原
		}
	}
	return dp[p][a1][a2][a3][a4][a5][a6][a7][a8]=ans;
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	memset(dp,-1,sizeof(dp));
	int m;cin>>n>>m;
	while(m--){
		int x;cin>>x;b[x]=1;
	}
	cout<<dfs(1,0,1,2,3,4,5,6,7);
	return 0;
}
```

---

## 作者：潘德理2010 (赞：7)

状压 dp。

假设现在已经填好了 $i$ 个数，考虑 $i+1$ 个数怎么填。

第 $i+1$ 个数怎么填取决于 $1-8$ 中每个数上一次出现的位置到 $i+1$ 的距离。对于数字 $j$，第 $i+1$ 位不能填 $j$，当且仅当数字 $j$ 上一次出现的位置到 $i+1$ 的距离小于 $j$。第 $i+1$ 位能填 $j$，当且仅当数字 $j$ 上一次出现的位置到 $i+1$ 的距离大于等于 $j$ 或没有出现。

我们发现，数字 $j$ 上一次出现的位置大于等于 $j$ 或没有出现，都对 $i+1$ 位以及之后没有影响。将所有这些情况归为一种。于是数字 $j$ 到 $i+1$ 的距离归为 $j$ 种不同状态，即 $0,1,...,j-1$，以及大于等于 $j$ 或没有出现。

而数字一共只有 $8$ 种，所以只有 $8!=40320$ 种状态。考虑状压 dp。

记 $d_{i,r}$ 为当前已经填完 $i$ 个数，状态为 $r$ 的方法数。考虑每一个 $j\in A$，如果在当前状态 $r$ 下能够填 $j$（也就是说 $j$ 上一次出现到 $i+1$ 距离大于等于 $j$ 或没有出现），那么就令 $d_{i+1,new}$ 加上 $d_{i,r}$（$new$ 为在 $i+1$ 位置填完 $j$ 后的状态）。

显然初始状态为 $d_{0,0}=1$，最后答案为对于每个状态 $r$，$d_{n,r}$ 的总和。

具体实现请见代码。

```cpp
#include<bits/stdc++.h>
#define p 1000000007
using namespace std;
int e[9],s[40500][9];// s[i] 为 i 解压后的状态 
int a[9];
int cp(){// 将状态 a 压缩 
	int res=0;
	for(int i=1;i<=8;i++){
		res+=a[i]*e[i];
	}
	return res;
}
int n,m,x,r=40320,d[105][40500],w,ans;
bool c[9];
int main(){
	e[8]=1;
	for(int i=7;i>=1;i--){
		e[i]=e[i+1]*(i+1);
	}
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&x);
		c[x]=true;
	} 
	for(int i=0;i<r;i++){// 确定每个数字所对应的状态 
		for(int j=2;j<=8;j++){// 因为 1 号位置只能为 0 所以从 2 开始 
			s[i][j]=(i%e[j-1])/e[j];
		}
	}
	d[0][0]=1;// 初始状态 
	for(int i=0;i<=n;i++){// 状压 dp 
		for(int j=0;j<r;j++){
			if(d[i][j]==0) continue;
			for(int k=1;k<=8;k++){
				if(s[j][k]!=0) a[k]=s[j][k]+1;
				else a[k]=0;
				if(a[k]>=k) a[k]=0;
			}
			w=cp();
			for(int k=1;k<=8;k++){				
				if(c[k]&&s[j][k]==0){
					int u;
					if(k==1) u=w;
					else u=w+e[k];
					d[i+1][u]=(d[i+1][u]+d[i][j])%p;
				}
			}
		}
	}
	for(int i=0;i<r;i++){// 统计答案 
		ans+=d[n][i];
		ans%=p;
	}
	printf("%d",ans);
}
```


---

## 作者：mincrafter_or_cy (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10099)
## ##
本题解有借鉴其他题解的思路。

考虑已经填完了后 $ i - 1 $ 位，要填倒数第 $ i $ 位。

对于每个 $ x \in A $，
如果 $ x $ 上一次出现的位置与 $ i $ 的距离 $ \ge x $，
第 $ i $ 位就可以填 $ x $。

看看数据范围，肯定要状压 dp。

但是压缩状态函数太难写，再看数据范围：$ m \le 8 $，$ n \le 100 $。


> $ \begin{aligned}
  8 \times 100 \times 8! &=8 \times  100 \times 40320 \\
                &= 32256000 \\
                &< 33000000 B\\
                &<33 MB \\
                &<512 MB
\end{aligned} $


开的下这么大的空间，所以开一个这样的dp数组。

```cpp
dp[105][1][2][3][4][5][6][7][8];
```

其中第一维表示已经填到第几位，其余第 $ i $ 维表示数字 $ i - 1 $ 上一次出现的位置与现在所填的位置的距离。
若该数字上一次出现的距离离 $ \ge i-1 $ 则视为 $ i-1 $。

因为正着写太肝了，所以采用记忆化搜索。如果可以填 $ x $ 那就假设填 $ x $ 往下搜索。

### AC代码 
```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 1000000007l
#define ll long long
int n,m;
ll dp[105][1][2][3][4][5][6][7][8];
bool has[10];//有没有这个数
ll dfs(int dep,int a,int b,int c,int d,int e,int f,int g,int h){//记忆化搜索
	if(~dp[dep][a][b][c][d][e][f][g][h]) return dp[dep][a][b][c][d][e][f][g][h];
	if(dep>n) return 1l;
	int dth[]={0,a+1,b+1,c+1,d+1,e+1,f+1,g+1,h+1};
	ll ret=0;
	//cout<<endl;
	for(int i=1;i<=8;i++)
		if(has[i]&&dth[i]==i){
			dth[i]=0;
			ret=(ret+dfs(dep+1,0,min(dth[2],1),min(dth[3],2),min(dth[4],3),min(dth[5],4),min(dth[6],5),min(dth[7],6),min(dth[8],7)))%p;//min防止溢出
			dth[i]=i;//记得复原
		}
	dp[dep][a][b][c][d][e][f][g][h]=ret;
	//cout<<ret<<endl;
	return ret;
}
int main(){
	cin>>n>>m;
	memset(dp,0xff,sizeof(dp));
	for(int i=1,sum;i<=m;i++){cin>>sum;has[sum]=1;}
	cout<<dfs(1,0,1,2,3,4,5,6,7)<<endl;
	return 0;
}
```
__不防溢出会 RE ！！！__
### 如果只用一个空间会 WA

```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 1000000007l
#define ll long long
short n,m;
ll dp[105][1][2][3][4][5][6][7][8];
bool has[10];//有没有这个数
short a[10]={0,0,1,2,3,4,5,6,7};
ll dfs(short dep){//记忆化搜索
	if(~dp[dep][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][a[7]][a[8]])
		return dp[dep][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][a[7]][a[8]];
	if(dep>n) return 1l;
	for(int i=1;i<=8;i++) a[i]=(a[i]==i-1?0:a[i]+1);
	ll ret=0;
	for(short i=1;i<=8;i++)
		if(has[i]&&a[i]==0) ret=(ret+dfs(dep+1))%p;
	for(int i=1;i<=8;i++) a[i]=(a[i]==0?i-1:a[i]-1);
	dp[dep][a[1]][a[2]][a[3]][a[4]][a[5]][a[6]][a[7]][a[8]]=ret;
	cout<<ret<<endl;
	return ret;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	memset(dp,0xff,sizeof(dp));
	for(short i=1,sum;i<=m;i++){cin>>sum;has[sum]=1;}
	cout<<dfs(1)<<endl;
	return 0;
}
```
### 附上我在考场上写的数学算法代码 
对前四个子任务打表分析可得 $ 50 $ 分。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define p 1000000007l
int n,m;
long long a[10],dp[105];
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>a[i];
	sort(a+1,a+m+1,less<int>());
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) dp[i]=(dp[i]+(i>a[j]?dp[i-a[j]]:1))%p;
	cout<<dp[n]<<endl;
	return 0;
}
```

---

## 作者：Crazyouth (赞：2)

## 分析

我们使用非常暴力的 dp。令 $dp_{i,j,k,l,m,n,o,p}$ 表示当前填到第 $i$ 位且最近的 $8,7,6,5,4,3,2$ 分别位于 $i-j+1,i-k+1,i-l+1,i-m+1,i-n+1,i-o+1,i-p+1$ 处（某一位等于 $0$ 则说明不存在）。由于对于一个 $i$ 我们并不关心 $i-x$ 位以前的 $x$，所以空间不会特别大。每次转移时判断当前位置填什么数，把位置设为 $1$，其余数字位置加一。若某个数字超出了我们关心的范围，将它设为 $0$。最后输出位置 $N$ 的 dp 值之和即可。时间复杂度 $O(n\times (m!)\times m)$，空间复杂度 $O(n\times (m!))$。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int dp[101][8][7][6][5][4][3][2],a[9];
int N,M;
signed main()
{
	cin>>N>>M;
	for(int i=1;i<=M;i++) cin>>a[i];
	dp[0][0][0][0][0][0][0][0]=1;
	for(int i=1;i<=N;i++)
	{
		for(int j=0;j<8;j++)
		for(int k=0;k<7;k++)
		for(int l=0;l<6;l++)
		for(int m=0;m<5;m++)
		for(int n=0;n<4;n++)
		for(int o=0;o<3;o++)
		for(int p=0;p<2;p++)
		{
			for(int r=1;r<=M;r++)
			{
				switch(a[r])
				{
					case 8:
						if(j) goto E;
						break;
					case 7:
						if(k) goto E;
						break;
					case 6:
						if(l) goto E;
						break;
					case 5:
						if(m) goto E;
						break;
					case 4:
						if(n) goto E;
						break;
					case 3:
						if(o) goto E;
						break;
					case 2:
						if(p) goto E;
						break;
					default:
						break;
				}
				dp[i][a[r]==8?1:(!j||j==7?0:j+1)][a[r]==7?1:(!k||k==6?0:k+1)][a[r]==6?1:(!l||l==5?0:l+1)][a[r]==5?1:(!m||m==4?0:m+1)][a[r]==4?1:(!n||n==3?0:n+1)][a[r]==3?1:(!o||o==2?0:o+1)][a[r]==2?1:0]=(1ll*dp[i][a[r]==8?1:(!j||j==7?0:j+1)][a[r]==7?1:(!k||k==6?0:k+1)][a[r]==6?1:(!l||l==5?0:l+1)][a[r]==5?1:(!m||m==4?0:m+1)][a[r]==4?1:(!n||n==3?0:n+1)][a[r]==3?1:(!o||o==2?0:o+1)][a[r]==2?1:0]+1ll*dp[i-1][j][k][l][m][n][o][p])%mod;
				E:;
			}
		}
	}
	long long ans=0;
	for(int j=0;j<8;j++)
	for(int k=0;k<7;k++)
	for(int l=0;l<6;l++)
	for(int m=0;m<5;m++)
	for(int n=0;n<4;n++)
	for(int o=0;o<3;o++)
	for(int p=0;p<2;p++)
	ans=(ans+1ll*dp[N][j][k][l][m][n][o][p])%mod;
	cout<<ans;
}

---

## 作者：mango2011 (赞：2)

这题为什么需要状压？

显然，对于一个元素 $x$，如果其长度太长显然没有意义，所以我们就可以开始状态设计了：

$dp_{i,a,b,c,d,e,f,g,h}$ 表示第 $i$ 为上，$1\sim8$ 距离 $i$ 的距离。特别的，如果某个元素不存在，我们直接设置为最大可能值即可（可以用这个办法设置初始值）。

考虑正向转移，依次考虑下一位能不能填某个数，然后根据状态定义转移即可。

总的复杂度非常优秀，被卡满的情况下是 $O(m! nm)$，可以通过。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int dp[105][1][2][3][4][5][6][7][8];
bool vis[10];
signed main(){
	ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL);
	dp[0][0][1][2][3][4][5][6][7]=1;
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		vis[x]=1;
	}
	for(int i=0;i<n;i++){
		for(int a=0;a<1;a++){
			for(int b=0;b<2;b++){
				for(int c=0;c<3;c++){
					for(int d=0;d<4;d++){
						for(int e=0;e<5;e++){
							for(int f=0;f<6;f++){
								for(int g=0;g<7;g++){
									for(int h=0;h<8;h++){
										int t=dp[i][a][b][c][d][e][f][g][h];
										if(!t){
											continue;
										}
										if(vis[1]){
											(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]+=t)%=mod;
										}
										if(vis[2]&&b>0){
											(dp[i+1][0][0][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]+=t)%=mod;
										}
										if(vis[3]&&c>1){
											dp[i+1][0][min(b+1,1)][0][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]+=t;
											if(dp[i+1][0][min(b+1,1)][0][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]>=mod){
												dp[i+1][0][min(b+1,1)][0][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]-=mod;
											}
										}
										if(vis[4]&&d>2){
											dp[i+1][0][min(b+1,1)][min(c+1,2)][0][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]+=t;
											if(dp[i+1][0][min(b+1,1)][min(c+1,2)][0][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]>=mod){
												dp[i+1][0][min(b+1,1)][min(c+1,2)][0][min(e+1,4)][min(f+1,5)][min(g+1,6)][min(h+1,7)]-=mod;
											}
										}
										if(vis[5]&&e>3){
											(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][0][min(f+1,5)][min(g+1,6)][min(h+1,7)]+=t)%=mod;
											if(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][0][min(f+1,5)][min(g+1,6)][min(h+1,7)]>=mod){
												dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][0][min(f+1,5)][min(g+1,6)][min(h+1,7)]-=mod;
											}
										}
										if(vis[6]&&f>4){
											dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][0][min(g+1,6)][min(h+1,7)]+=t;
											if(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][0][min(g+1,6)][min(h+1,7)]>=mod){
												dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][0][min(g+1,6)][min(h+1,7)]-=mod;
											} 
										}
										if(vis[7]&&g>5){
											dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][0][min(h+1,7)]+=t;
											if(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][0][min(h+1,7)]>=mod){
												dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][0][min(h+1,7)]-=mod;
											}
										}
										if(vis[8]&&h>6){
											dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][0]+=t;
											if(dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][0]>=mod){
												dp[i+1][0][min(b+1,1)][min(c+1,2)][min(d+1,3)][min(e+1,4)][min(f+1,5)][min(g+1,6)][0]-=mod;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	int ans=0;
	for(int a=0;a<1;a++){
		for(int b=0;b<2;b++){
			for(int c=0;c<3;c++){
				for(int d=0;d<4;d++){
					for(int e=0;e<5;e++){
						for(int f=0;f<6;f++){
							for(int g=0;g<7;g++){
								for(int h=0;h<8;h++){
									ans+=dp[n][a][b][c][d][e][f][g][h];
									if(ans>=mod){
										ans-=mod;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	cout<<ans<<endl; 
	return 0;
}
```

---

## 作者：cosf (赞：1)

一个稍微优美一点的解法。

---

暴力的思路是设状态 $\{i, c_1, c_2, c_3, \dots, c_8\}$，$i$ 表示第 $i$ 位，$c_j$ 表示还有多少位就能放 $j$（$0$ 表示当前位能放）。

转移方程即 $dp_{\{i, c_1, \dots, c_8\}} = \sum_{j=1}^8[c_j = (j-1)]dp_{\{i - 1, c_1 + 1, \dots, c_{j-1} + 1, 0, c_{j+1}+1, \dots, c_8 + 1\}}$。

然后，我们能发现 $c_j$ 的取值是 $0$ 到 $j-1$。~~也就是说 $c_1$ 没用。~~

我们可以用混合进制。具体而言，我们可以用整数 $\sum_{j=2}^8(j-1)!c_j$ 表示状态 $\{c_2, c_3, \dots, c_8\}$。

转移时，除了当前选的数，其他的 $c_j$ 都恰好减 $1$，因此我们可以先将所有 $c_j - 1$ 之后的状态预算出来，然后枚举当前数 $k$，将 $c_k$ 设为 $k-1$ 即可。

设 $8$ 为值域 $V$，则原本朴素的算法是 $O(nV!V^2)$ 的，优化之后少了一个 $V$。写起来也很方便。

---

```cpp
#include <iostream>
using namespace std;

#define MAXN 105
#define MAXM 10
#define MAXV 40320
#define MOD 1000000007ll

using ll = long long;

int bs[MAXM] = {0, 0, 1, 2, 6, 24, 120, 720, 5040};

inline int gt(int x, int p) // 获得状态 x 的 c_p
{
    if (p == 1)
    {
        return 0;
    }
    return x / bs[p] % p;
}

inline int st(int x, int p) // 设置状态 x 的 c_p 为 (p - 1)
{
    if (p == 1)
    {
        return x;
    }
    int c = gt(x, p);
    return x + (p - 1 - c) * bs[p];
}

inline int m1(int x, int p) // 将状态 x 的 c_p 减 1
{
    int c = gt(x, p);
    if (c > 0)
    {
        return x - bs[p];
    }
    return x;
}

int n, m;

bool bk[MAXM];

ll dp[MAXN][MAXV];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int x;
        cin >> x;
        bk[x] = true;
    }
    dp[0][0] = 1;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < MAXV; j++)
        {
            int rj = j;
            for (int l = 1; l < 9; l++)
            {
                rj = m1(rj, l);
            }
            for (int k = 1; k < 9; k++)
            {
                if (bk[k] && gt(j, k) == 0)
                {
                    int nj = st(rj, k);
                    dp[i + 1][nj] = (dp[i + 1][nj] + dp[i][j]) % MOD;
                }
            }
        }
    }
    ll res = 0;
    for (int j = 0; j < MAXV; j++)
    {
        res = (res + dp[n][j]) % MOD;
    }
    cout << res << endl;
    return 0;
}
```

---

## 作者：Rosick (赞：0)

## 题意
给出个数与大小均不大于 $8$ 的若干正整数元素，求用它们组成指定长度不大于 $100$ 的数列的方案数。数列要求：相同的数之间的间隔不小这个数本身。
## 分析
### 状态搭建
1. 此题求方案数，给出元素供我们选择以组成数列。可知，在转移中，方案数只与状态的长度有关，而与该状态在整个大数列中的位置无关，故可以往线性 dp 方向思考。

2. 定义一个原始的经典线性 dp 状态 $dp[i]$ 表示长度为 $i$ 的数列的方案数。不难发现，在这样的定义下，每一次转移都是从 $i$ 到 $i+1$，而转移的动力来源就是 $i+1$ 的位置所选择的元素。

3. 对于这个元素的选择，我们要遵循题目的要求：相同的数之间的间隔不小这个数本身。翻译一下：若 $i+1$ 位选择元素 $a$，那么从 $i+1$ 位往前数的第一个 $a$ 与它的距离必须大于等于 $a$。记距离为 $d$（若前方不存在相同元素则可把距离视为无穷大），因此对于一个元素的选择，可以粗略分为两种情况：$d \ge a$ 可放置； $d<a$ 不可放置。而元素有多个，对于每一次转移，我们都要从不同的元素去判断可行性，故我们要维护这些元素的情况。

4. 因此我们把状态更新为 $dp[i][j]$ 表示长度为 $i$，元素状况为 $j$ 时的方案数。接下来我们思考如何具体地用 $[j]$ 记录元素状况。
### 压缩方法
1. 在第上文中，我们粗略地将 $d$ 分为了两种情况，但是在转移过程中，$d$ 在变大，针对这两种情况有：$d \ge a$，$d$ 变大，其始终成立；$d<a$，$d$ 变大，可能会导致变成前一种情况。因此我们需要对第二种情况细分，以判断何时会发生改变。故对于一个元素，状况变成了 $1,2,3 ...  \ge a$。比如对于 3，有 $d=1,d=2,d \ge 3$，对于 4，有 $d=1,d=2,d=3,d \ge 4$。多举几个例子后，我们会发现，每个元素的情况数量与元素的大小相等，给了我们维护方法上的启发。

2. 类比普通的状态压缩，每一个元素都用二进制的 1 与 0 表示选与不选；在此题中，元素的情况不再是相同的选与不选两种，而是其数量与元素数值相同。对于前者，我们将元素情况转化为二进制数，再转化为十进制数；后者的元素情况数量不相等，思考可不可以将其转化为一个变进制数，再转化为十进制数以压缩。

3. 元素情况 -> 变进制数：类似于二进制的情况，选与 1 对应，不选与 0 对应；我们也把距离和数字一一对应即可，$d>=a$ 的对应为 0 即可。

4. 变进制数 -> 十进制数：类似于二进制的情况，如，有 $(1001)_{2}=(1 \times 2^{0}+0 \times 2^{1}+0 \times 2^{2}+1 \times 2^{3})_{10}$ ，若把二进制每一位上的数称为系数，其相乘的 $2^{n}$ 称为基数，那么我们要转化变进制数，已知系数，只要知道基数，就可以转化了。

5. 观察二进制的基数是怎么来的，如图所示：
	
    ![二进制](https://cdn.luogu.com.cn/upload/image_hosting/pdfl3z4b.png)
	
    第一位的 $1$ 等于十进制中个位的 $1$，而因为两位就会进位，所以第二位的一个 $1$ 由两个第一位的 $1$ 相加得来，故可表示十进制各位上的 $1+1=2$，而第三位后便可以此类推。我们发现，对于第 $i$ 的一个 $1$，其所代表的十进制的值，就是基数，其由 $i-1$ 位的基数乘上 $i-1$ 位的进制得来。比如，若设 $e[i]$ 表示第 $i$ 位的基数，则 $e[3]=e[3-1] \times 2=e[2] \times 2=2 \times 2=4$，$2^{n}$ 就是这么来的。我们可以得出基数求解公式 $e[i]=e[i-1] \times 2$。

6. 对于变进制数，大家可以自行参照上文画一下图，发现公式同样适用，只不过因为变进制数，该位对应的元素是多少，进制就是多少，故可以得出 $e[i]=e[i-1] \times (i-1)$。特别一点，因为对于元素 $1$，只有一种情况，无论如何都可以放置 $1$，故无需统计它，则元素 $2$ 是第一位，将它的基数视为 $1$，即 $e[2]=1$。

7. 知道了基数，那么就可以将所有元素的情况压缩为变进制数，再变为十进制数，用 $dp[i][j]$ 的 $[j]$ 表示。表示出的最大的十进制数即为方案数，我们判断一下是否会超内存。用 $(...)_{变}$ 表示变进制数，即将 $(7654321)_{变}$ 转化为十进制数，$(7654321)_{变}=(80000000)_{变}-1=e[9] \times 1-1=50319$，即 $j<=50319$，而 $i<=100$，故不会超限。
### 解压方法
1. 解压操作为：将十进制数转化为变进制数，变进制数一一对应成元素状况。因此我们可以预处理出 $p[i][j]$ 表示状态 $i$ 对应的元素 $j$ 的距离。

2. 可以 dfs 枚举每一种元素的组合情况，并用栈记录好，最后表示出 $[i]$ 后再出栈中数一一对应给 $[j]$。
### dp 过程
此后就类似于线性状压 dp 了，具体过程见代码注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
const int maxn = 110;
const int maxm = 10;
const int maxr = 40320;

int read() {
	int x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar();
	while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x;
}

int n, m, r;
int a[maxm];
int e[maxm];//基数 
int dp[maxn][maxr];
int stac[maxm];
int p_out[maxr][maxm];//解压数组 

int p_in(int x){//转移后压缩函数 
	int ans = 0;
	for(int i = 1; i <= m; ++i)
		if(p_out[x][a[i]]) //距离加上1，如果d>=a了，那么就不再会影响放置新元素，将其改为0，
			ans += (p_out[x][a[i]] + 1 < a[i] ? p_out[x][a[i]] + 1 : 0) * e[a[i]];//切记不进位
	return ans;
}

void dfs(int u){
	if(u == m){
		int res = 0;//维护对应的十进制数 
		for(int i = 2; i < a[u]; ++i){
			res += stac[i] * e[i];
		}
		for(int i = 0; i < a[u]; ++i){
			res += i * e[a[u]];
			stac[a[u]] = i;
			for(int j = 2; j <= a[u]; ++j)
				p_out[res][j] = stac[j];//记录每一位的系数 
			res -= i * e[a[u]];
		}
	}
	if(a[u] == 1) dfs(u + 1);//如果元素是1，跳过 
	for(int i = 0; i < a[u]; ++i){//枚举每一种选择 
		stac[a[u]] = i;
		dfs(u + 1);
	}
}

void sol() {
	n = read();
	m = read();
	e[2] = 1;
	for(int i = 3; i <= 8; ++i)
		e[i] = e[i - 1] * (i - 1);//预处理每一位的基数 
	for(int x, i = 1; i <= m; ++i) {
		a[i] = read();
		r += (a[i] - 1) * e[a[i]];//维护元素状况转化为的最大的十进制数 
	}
	dfs(1);//预处理解压数组
	for(int i = 1; i <= m; ++i)//预处理第一位 
		dp[1][e[a[i]]] = 1;
	for(int w, i = 1; i <= n; ++i){//枚举长度
		for(int j = 0; j <= r; ++j){//枚举状态
			if(!dp[i][j]) continue;//没有方案的直接跳过 
			w = p_in(j);//记录向后移一位后，该状态的元素状况的距离都变大一位后对应的十进制数 
			for(int v = 1; v <= m; ++v){//枚举下一位放置的元素
				if(p_out[j][a[v]]) continue;//如果解压后该位有数字
				//就说明这两个相同的数字间的距离小于它们自己，不能放置 
				dp[i + 1][w + e[a[v]]] = (dp[i + 1][w + e[a[v]]] + dp[i][j]) % mod;
				//在i+1位放上了一个元素，要更新状态，故有w+e[a[v]] 
			}
		}
	}
	int ans = 0;
	for(int i = 0; i <= r; ++i)
		ans = (ans + dp[n][i]) % mod;//统计最后一位放上每一种元素的方案数 
	printf("%d", ans);
}

int main() {
	sol();
	return 0;
}
```

---


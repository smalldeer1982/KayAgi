# 『STA - R4』踱步

## 题目描述

小 X 特别喜欢安静的环境，因为那可以让他心情愉悦。

现在给出 $N$ 分钟内每分钟屋内和屋外对小 X 的心情影响值，在这 $N$ 分钟内，小 X 可以从屋内踱步到屋外或是从屋外踱步到屋内**最多共** $K$ 次。（小 X 当且仅当每分钟初进行踱步，同一时刻至多踱步一次，并且踱步的时间忽略不计。第 $1$ 分钟初不可踱步，第 $N$ 分钟初可以踱步。但是在第 $1$ 分钟初可以自由选择初始状态）。

同时，过于频繁的改变会让小 X 心情烦躁，所以如果两次踱步的间隔**小于等于** $T$ 分钟，会对小 X 的心情额外造成 $P$ 点影响。（如果此次踱步是在第 $t_a$ 分钟初，上一次踱步是在第 $t_b$ 分钟初，那么这两次踱步的时间间隔为 $t_a - t_b$ 分钟）。

小 X 想知道自己的心情最好可以是多少，即第 $N$ 分钟末小 X 心情值的最大值。

若某一时刻小 X 的心情值为 $a$，之后小 X 的心情被影响了 $b$，那么在此之后小 X 的心情值将变为 $a + b$。

## 说明/提示

**【样例 #1 解释】**

对于第 $1$ 组数据，最优方案为初始时选择在屋内，分别在第 $4, 5, 7$ 分钟初进行踱步。

![](https://cdn.luogu.com.cn/upload/image_hosting/cx7tr8m2.png)

其中第 $2$ 次踱步与第 $1$ 次踱步之间的间隔为 $5 - 4 = 1$ 分钟，对小 $\text{X}$ 的心情产生 $3$ 的贡献，第 $3$ 次踱步与第 $2$ 次踱步之间的间隔为 $7 - 5 = 2$ 分钟，对小 X 的心情产生 $3$ 的贡献。

因此小 X 的心情值为

$$\left(0+5+8-7+0-4-3+0\right) + 6 = 5$$

前半部分为灰色格子的权值和，后半部分为两次频繁踱步产生的额外贡献，可以证明此方案最优。

**【样例 #2 解释】**

请注意答案可能超过 $32$ 位整型数字的范围。

**【样例 #3 解释】**

请注意答案可能为负数。


**【数据范围】**

对于 $100\%$ 的数据：

- $1 \le \text{TEST} \le 10^5$；
- $2 \le N \le 2 \times 10^5$；
- $1 \le K \le \min\left\{200, N\right\}$；
- $1 \le T \le \min\left\{2 \times 10^4, N\right\}$；
- $\left\lvert a_i \right\rvert,\left\lvert b_i \right\rvert,\left\lvert P \right\rvert \le 10^9$。
- $\sum N \cdot K \le 5 \times 10^7$。
- 保证单个测试点输入数据规模不超过 10 MB。

**本题采用捆绑测试。**

|Subtask 编号|数据范围|分值|依赖子任务|
|:--------:|:--------:|:--------:|:--------:|
|1|$N \le 20, \text{TEST} \le 10$|$5$||
|2|$\sum N^2K \le 5 \times 10^7$|$20$|$1$|
|3|$K \le 5, N \le 5 \times 10^4, \text{TEST} \le 10$|$15$||
|4|$P=-10^9, 0 \le \left\lvert a_i \right\rvert,\left\lvert b_i \right\rvert \le 100$|$30$||
|5|无特殊限制|$30$|$1,2,3,4$|

## 样例 #1

### 输入

```
0 2
8 3 2 3
0 -2
5 -10
8 0
-10 -7
0 -3
-4 -9
-9 -3
-7 0
8 3 2 -6
9 6
9 -6
3 7
-4 3
8 -9
6 0
-10 9
-8 -4
```

### 输出

```
5
36
```

## 样例 #2

### 输入

```
0 1
12 3 2 -35771156
797235777 25138038
801541087 -405462832
936777370 -973167834
74493410 60154946
263320806 782480907
-940214410 805511853
806065179 463119365
-295177485 -112301429
-403964212 202831413
122359196 611468120
-555210139 549749508
793784715 -38433603
```

### 输出

```
6706692096
```

## 样例 #3

### 输入

```
0 1
5 2 1 -100
-44 -72
-36 -23
-4 0
-22 -1
-88 3
```

### 输出

```
-65
```

# 题解

## 作者：Noby_Glds (赞：9)

首先对 $a,b$ 做前缀和，分别表示为 $s_{0},s_1$。

设 $f_{i,k,op}$ 表示对于前 $i$ 个位置，强制在 $i+1$ 分钟初踱步，总共踱步 $k$ 次，且第 $i$ 分钟在屋内（$op=0$）或屋外（$op=1$）的最大答案。

显然我们有以下转移方程：
$$f_{i,k,op}=\max_{j=k-1}^{i-1}{f_{j,k-1,1-op}}+s_{i,op}-s_{j,op}+[i-j\leq T]P$$

移项可得：
$$f_{i,k,op}-s_{i,op}=\max_{j=k-1}^{i-1}{f_{j,k-1,1-op}}-s_{j,op}+[i-j\leq T]P$$
滚动数组滚掉一维：
$$g_{i,op}-s_{i,op}=\max_{j=k-1}^{i-1}f_{j,1-op}-s_{j,op}+[i-j\leq T]P$$
分情况讨论：
### $i-j\leq T$
此时转移区间的范围是 $[i-T,i-1]$，且联系到区间求最值，我们很容易想到单调队列优化，别忘了把答案加上 $P$。
### $i-j>T$
转移区间为 $[k-1,i-T-1]$，注意到左端点固定，右端点递增，只需要开一个变量维护最大值。

最后，$op$ 有两个取值，记得要做两次转移。
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 200010
using namespace std;
int id,T,n,m,t,p;
int f[N][2],s[N][2],g[N][2],q[N];
int get(int x,int y){return f[x][y^1]-s[x][y];}
void work(int pos,int op){
	int now=-1e18,l=1,r=1;
	q[1]=pos-1;
	for(int i=pos;i<=n;i++){
		if(i-t-1>=pos-1) now=max(now,get(i-t-1,op));
		while(l<=r&&q[l]<i-t) l++;
		g[i][op]=max(now,get(q[l],op)+p)+s[i][op];
		while(l<=r&&get(i,op)>=get(q[r],op)) r--;
		q[++r]=i;
	}
} 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>id>>T;
	while(T--){
		cin>>n>>m>>t>>p;
		for(int i=1;i<=n;i++){
			cin>>s[i][0]>>s[i][1];
			s[i][0]+=s[i-1][0],s[i][1]+=s[i-1][1];
			f[i][0]=s[i][0],f[i][1]=s[i][1];
		} 
		int ans=max(s[n][0],s[n][1]);//不踱步
		for(int i=1;i<n;i++) ans=max(ans,max(f[i][0]+s[n][1]-s[i][1],f[i][1]+s[n][0]-s[i][0]));//一次踱步
		for(int pos=2;pos<=m;pos++){
			work(pos,0),work(pos,1);
			for(int i=pos;i<n;i++){
				f[i][0]=g[i][0],f[i][1]=g[i][1];
				ans=max(ans,max(f[i][0]+s[n][1]-s[i][1],f[i][1]+s[n][0]-s[i][0]));
			} 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：AbsMatt (赞：5)

此题解给一个常数较小的 $O(k^2\times n\times \log_2n)$ 的做法，致敬各位坚持数据结构的 OIer 们。

### [题目传送器](https://www.luogu.com.cn/problem/P10119)

### [更爽的阅读体验](https://www.luogu.com.cn/blog/yaohaoyou/solution-p10119)

## 题意
初始时可以选择在 $0$ 或 $1$ 的位置，之后每个时间点每次可以改变位置（也可以不改变）。若 $t$ 时间点在 $0$ 的位置则获得 $a_t$ 的贡献（可能是负数），在 $1$ 则获得 $b_t$ 的贡献（可能是负数）。若相邻两次移动位置的时间间隔小于等于 $T$，则获得 $P$ 的贡献（可能是负数）。总共最多改变 $k$ 次位置（初始位置不算），求 $n$ 分钟后贡献最大值。

## 做法
本题不太能想出贪心，于是尝试 DP。

### DP 状态
设 $dp_{i,j,0/1}$ 为前 $i$ 时刻改变了 $j$ 次位置后在 $0/1$ 的答案。$i \in [0,n]$，$j \in [0,k]$。空间复杂度为 $O(n \times k)$。

### DP 转移
尝试枚举上一个改变位置的时刻 $l$ 进行转移。
$$
dp_{i,j,0}=\begin{cases}
\max_{l=i}^{j-1}dp_{l,i-1,1}+\sum_{q=l+1}^{j-1}b_q+a_j+p & i=1 \wedge j-l \le t
\\
\max_{l=i}^{j-1}dp_{l,i-1,1}+\sum_{q=l+1}^{j-1}b_q+a_j+p & else\end{cases}
\\
dp_{i,j,1}=\begin{cases}
\max_{l=i}^{j-1}dp_{l,i-1,0}+\sum_{q=l+1}^{j-1}a_q+b_j+p & i=1 \wedge j-l\le t
\\
\max_{l=i}^{j-1}dp_{l,i-1,0}+\sum_{q=l+1}^{j-1}a_q+b_j & else
\end{cases}
$$
看上去很复杂，但是自己推一下还是挺显然的，就是将上一次的贡献和这一次的贡献加上即可。

### 优化 1（前缀和）
此时时间复杂度为 $O(k^2\times n^2)$，可以拿到 $5$ pts。一个非常明显的优化就是将 DP 转移中的 $\sum_{q=l+1}^{j-1} a_q$ 用前缀和优化。具体就是开始时将前缀和数组预处理，计算时就可以 $O(1)$ 计算静态区间和。此时时间复杂度为 $O(k^2\times n)$，可以拿到 $25$ pts。赛场上由于时间不足，我也只拿到了这一部分的分数，在这里也放一份代码。

```cpp
// I am too vegetable to get 100 points ~~~
#define int long long  // 记得开 long long
constexpr int maxn=2e5+10;
int n,k,t,p;
int a[maxn],b[maxn];
int dp[maxn][210][2];  // dp[i][j] 表示在前 i 个换了 j 次且当前在 k 的答案
// 前缀和优化
inline int calcA(int l,int r){return (l>r)?0:a[r]-a[l-1];}
inline int calcB(int l,int r){return (l>r)?0:b[r]-b[l-1];}
int ans;
void solve1(){
    scanf("%lld%lld%lld%lld",&n,&k,&t,&p);
    for(int i=1;i<=n;i++){
        scanf("%lld%lld",&a[i],&b[i]);
        a[i]+=a[i-1];b[i]+=b[i-1];
    }
    // 预设 DP 初值
    for(int i=0;i<=n;i++)
        for(int j=0;j<=k;j++)   dp[i][j][0]=dp[i][j][1]=-2e18;
    for(int i=1;i<=n;i++){
        dp[i][0][0]=calcA(1,i);dp[i][0][1]=calcB(1,i);
    }
    ans=-2e18;
    // 记得计算不改变的答案！！！
    ans=max(dp[n][0][0],dp[n][0][1]);
    dp[0][0][0]=dp[0][0][1]=0;
    for(int i=1;i<=k;i++){
        for(int j=i+1;j<=n;j++){
            for(int l=i;l<j;l++){
                // dp 转移
                dp[j][i][0]=max(dp[j][i][0],dp[l][i-1][1]+calcB(l+1,j-1)+calcA(j,j)+(i!=1&&j-l<=t)*p);
                dp[j][i][1]=max(dp[j][i][1],dp[l][i-1][0]+calcA(l+1,j-1)+calcB(j,j)+(i!=1&&j-l<=t)*p);
            }
            // 将剩下的补全并求答案
            ans=max(ans,dp[j][i][0]+calcA(j+1,n));
            ans=max(ans,dp[j][i][1]+calcB(j+1,n));
        }
    }
    printf("%lld\n",ans);
}
```
### 优化 2（线段树）
此时的 DP 状态空间是合法的，所以只需将时间优化就有机会通过。

以第 $1$ 条 dp 转移式为例，将前缀和拆开并移项，得到 $dp_{i,j,0}=\max_{l=i}^{j-1}dp_{l,i-1,1}+sumb_{j-1}-sumb_{l}+a_j+p=\max_{l=i}^{j-1}(dp_{l,i-1,1}-sumb_l)+(sumb_{j-1}+a_j+p)$。此时左边的括号只和 $l$ 和 $i$ 有关，右边的括号只和 $j$ 有关，所以可以将 $(dp_{l,i-1,1}-sumb_i)$ 存入线段树，维护区间最大值即可。

接下来发现 $p$ 的贡献不容易枚举，但其实 $p$ 有贡献的条件就是 $j-l\le t$，移项得 $l \ge j-t$。当想要 $p$ 的贡献时，$l \in [j-t,j-1]$，否则 $l \in[i,j-t)$。记得特判 $i$ 为 $1$ 时无法获得 $p$ 得贡献。

时间复杂度为 $O(k^2\times n \times \log_2n)$，可以获得 $40$ 分，这里依旧放一份主要部分代码。

```cpp
#define int long long
constexpr int maxn=2e5+10;
int n,k,t,p;
int a[maxn],b[maxn],c[maxn][2];
int dp[maxn][210][2];  // dp[i][j] 表示在前 i 个换了 j 次且当前在 k 的答案
int ans;
namespace SegmentTree{
    #define ls p<<1
    #define rs p<<1|1
    #define lson ls,l,mid
    #define rson rs,mid+1,r
    #define all 1,1,n
    int tr[maxn<<2][2];
    inline void pushup(int p){tr[p][0]=max(tr[ls][0],tr[rs][0]);tr[p][1]=max(tr[ls][1],tr[rs][1]);}
    void build(int p,int l,int r){
        tr[p][0]=tr[p][1]=-1e16;
        if(l==r)    return;
        int mid=(l+r)>>1;
        build(lson);build(rson);
        pushup(p);
    }
    void update(int p,int l,int r,int x,int s,int typ){
        if(l==r)    return tr[p][typ]=s,void();
        int mid=(l+r)>>1;
        if(x<=mid)  update(lson,x,s,typ);
        else    update(rson,x,s,typ);
        pushup(p);
    }
    int query(int p,int l,int r,int pl,int pr,int typ){
        if(pl>pr)   return 0;
        if(pl<=0)   pl=1;
        if(l>=pl&&r<=pr)    return tr[p][typ];
        int mid=(l+r)>>1,res=-2e18;
        if(pl<=mid) res=query(lson,pl,pr,typ);
        if(pr>mid)  res=max(res,query(rson,pl,pr,typ));
        return res;
    }
}
using namespace SegmentTree;
void solve2(){
    scanf("%lld%lld%lld%lld",&n,&k,&t,&p);
    for(int i=1;i<=n;i++){
        scanf("%lld%lld",&a[i],&b[i]);
        a[i]+=a[i-1];b[i]+=b[i-1];
    }
    for(int i=0;i<=n;i++)
        for(int j=0;j<=k;j++)   dp[i][j][0]=dp[i][j][1]=-2e18;
    for(int i=1;i<=n;i++){
        c[i][0]=b[i-1]+a[i]-a[i-1];
        c[i][1]=a[i-1]+b[i]-b[i-1];
    }
    build(all);
    for(int i=1;i<=n;i++){
        dp[i][0][0]=a[i];dp[i][0][1]=b[i];
        update(all,i,dp[i][0][0]-a[i],0);
        update(all,i,dp[i][0][1]-b[i],1);
    }
    ans=max(dp[n][0][0],dp[n][0][1]);
    for(int i=1;i<=k;i++){
        for(int j=i+1;j<=n;j++){
            if(i!=1)    dp[j][i][0]=max(dp[j][i][0],query(all,j-t,j-1,1)+c[j][0]+p);
            else    dp[j][i][0]=max(dp[j][i][0],query(all,1,j-1,1)+c[j][0]);
            dp[j][i][0]=max(dp[j][i][0],query(all,1,j-t-1,1)+c[j][0]);
            if(i!=1)    dp[j][i][1]=max(dp[j][i][1],query(all,j-t,j-1,0)+c[j][1]+p);
            else    dp[j][i][1]=max(dp[j][i][1],query(all,1,j-1,0)+c[j][1]);
            dp[j][i][1]=max(dp[j][i][1],query(all,1,j-t-1,0)+c[j][1]);
            ans=max(ans,dp[j][i][0]+a[n]-a[j]);
            ans=max(ans,dp[j][i][1]+b[n]-b[j]);
        }
        build(all);
        for(int j=i+1;j<=n;j++){
            update(all,j,dp[j][i][0]-a[j],0);
            update(all,j,dp[j][i][1]-b[j],1);
        }
    }
    printf("%lld\n",ans);
}
```
### 优化 3（zkw 线段树）
此时时间复杂度为 $O(k^2\times n\times \log_2n)$，只有 $9 \times 10^8$ 的数量级，$2$ s 的时限并非没有可能通过卡常通过，这里的线段树只需要单点修改，区间查询。可以通过常数极小的 zkw 线段树进行卡常。这里依旧放一份代码，但无法卡常通过（应该是本人技术太差了），但多卡过了几个点。
```cpp
#define R register
#define ll long long
constexpr int maxn=2e5+10;
int n,k,t,p;
ll a[maxn],b[maxn],c[maxn][2];
ll dp[maxn][2];  // dp[i][j] 表示在前 i 个换了 j 次且当前在 k 的答案
ll ans;
struct zkw{
    inline void ckmx(ll&x,ll y){(x<y)&&(x=y);}
    inline ll max(ll x,ll y){return x>y?x:y;}
    int M;
    ll mx[maxn<<2];
    inline void pu(int p){mx[p]=max(mx[p<<1],mx[p<<1|1]);}
    inline void build(){
        for(M=1;M<=n;M<<=1);
        for(int i=1;i<=n+M+5;i++)mx[i]=-1e16;
    }
    inline void upd(int p,ll k){for(mx[p+=M]=k;p>>=1;pu(p));}
    inline ll qry(int l,int r){
        l=max(1ll,l);if(l>r)    return -2e18;
        ll res=-2e18;
        for(l+=M-1,r+=M+1;l^r^1;l>>=1,r>>=1){
            if(!(l&1))ckmx(res,mx[l^1]);
            if(r&1)ckmx(res,mx[r^1]);
        }
        return res;
    }
}T[2];
void solve2(){
    scanf("%d%d%d%d",&n,&k,&t,&p);
    for(R int i=1;i<=n;++i){
        scanf("%lld%lld",&a[i],&b[i]);
        a[i]+=a[i-1];b[i]+=b[i-1];
    }
    for(R int i=1;i<=n;++i){
        c[i][0]=b[i-1]+a[i]-a[i-1];
        c[i][1]=a[i-1]+b[i]-b[i-1];
    }
    T[0].build();T[1].build();
    for(R int i=1;i<=n;++i){
        dp[i][0]=a[i];dp[i][1]=b[i];
        T[0].upd(i,dp[i][0]-a[i]);
        T[1].upd(i,dp[i][1]-b[i]);
    }
    ans=max(dp[n][0],dp[n][1]);
    for(R int i=1;i<=k;++i){
        for(R int j=i+1;j<=n;++j){
            dp[j][0]=dp[j][1]=-2e18;
            if(i!=1)    dp[j][0]=max(dp[j][0],T[1].qry(j-t,j-1)+c[j][0]+p);
            else    dp[j][0]=max(dp[j][0],T[1].qry(1,j-1)+c[j][0]);
            dp[j][0]=max(dp[j][0],T[1].qry(1,j-t-1)+c[j][0]);
            if(i!=1)    dp[j][1]=max(dp[j][1],T[0].qry(j-t,j-1)+c[j][1]+p);
            else    dp[j][1]=max(dp[j][1],T[0].qry(1,j-1)+c[j][1]);
            dp[j][1]=max(dp[j][1],T[0].qry(1,j-t-1)+c[j][1]);
            ans=max(ans,dp[j][0]+a[n]-a[j]);
            ans=max(ans,dp[j][1]+b[n]-b[j]);
        }
        T[0].build();T[1].build();
        for(R int j=i+1;j<=n;++j){
            T[0].upd(j,dp[j][0]-a[j]);
            T[1].upd(j,dp[j][1]-b[j]);
        }
    }
    printf("%lld\n",ans);
}
```
### 优化 4（ST 表）
仔细观察上面的代码会发现当次 DP 过程只需要用到上一轮的 DP 状态，无需边修改边查询，于是可以理解为 $k$ 次静态区间最大值，可以使用 ST 表。时间复杂度依旧是 $O(k^2\times n \times \log_2n)$，但瓶颈只在建 ST 表时，并且常数极小。终于，我们使用数据结构通过了本题！
```cpp
#define int long long
constexpr int maxn=2e5+10;
int n,k,t,p;
int a[maxn],b[maxn],c[maxn][2];
int dp[maxn][2];  // dp[i][j] 表示在前 i 个换了 j 次且当前在 k 的答案
int ans;
int Log2[maxn];
inline void init(){for (int i = 2; i < maxn; i++)Log2[i] = Log2[i / 2] + 1;}
struct ST{
    int st[18][maxn];
    inline int max(int x,int y){return x>y?x:y;}
    inline void build(){
        for (int j=1;j<=17;j++)
            for (int i=1;i<=n;i++)
                st[j][i]=max(st[j-1][i],st[j-1][i+(1<<j-1)]);
    }
    inline int qry(int l,int r){if(l=max(1,l);l>r)return -2e18;int k=Log2[r-l+1];return max(st[k][l],st[k][r-(1<<k)+1]);}
}T[2];
void solve2(){
    scanf("%lld%lld%lld%lld",&n,&k,&t,&p);
    for(int i=1;i<=n;i++){
        scanf("%lld%lld",&a[i],&b[i]);
        a[i]+=a[i-1];b[i]+=b[i-1];
    }
    for(int i=1;i<=n;i++){
        c[i][0]=b[i-1]+a[i]-a[i-1];
        c[i][1]=a[i-1]+b[i]-b[i-1];
    }
    for(int i=1;i<=n;i++){
        dp[i][0]=a[i];dp[i][1]=b[i];
        T[0].st[0][i]=dp[i][0]-a[i];
        T[1].st[0][i]=dp[i][1]-b[i];
    }
    T[0].build();T[1].build();
    ans=max(dp[n][0],dp[n][1]);
    for(int i=1;i<=k;i++){
        for(int j=i+1;j<=n;j++){
            dp[j][0]=dp[j][1]=-2e18;
            if(i!=1)    dp[j][0]=max(dp[j][0],T[1].qry(j-t,j-1)+c[j][0]+p);
            else    dp[j][0]=max(dp[j][0],T[1].qry(1,j-1)+c[j][0]);
            dp[j][0]=max(dp[j][0],T[1].qry(1,j-t-1)+c[j][0]);
            if(i!=1)    dp[j][1]=max(dp[j][1],T[0].qry(j-t,j-1)+c[j][1]+p);
            else    dp[j][1]=max(dp[j][1],T[0].qry(1,j-1)+c[j][1]);
            dp[j][1]=max(dp[j][1],T[0].qry(1,j-t-1)+c[j][1]);
            ans=max(ans,dp[j][0]+a[n]-a[j]);
            ans=max(ans,dp[j][1]+b[n]-b[j]);
        }
        for(int j=1;j<=i;j++)T[0].st[0][j]=T[1].st[0][j]=-2e18;
        for(int j=i+1;j<=n;j++){
            T[0].st[0][j]=dp[j][0]-a[j];
            T[1].st[0][j]=dp[j][1]-b[j];
        }
        T[0].build();T[1].build();
    }
    printf("%lld\n",ans);
}
```

## 总结
本做法时间复杂度为 $(k^2\times n \times \log_2n)$，ST 表实现版无需卡常，这是本蒟蒻第一次写月赛题解，同时用数据结构通过也感到很惊讶，希望以上内容能帮助大家。

---

## 作者：User_Unauthorized (赞：4)

首先考虑 $\mathcal{O}(N^2K)$ 做法，设 $f_{i, j, 0 / 1}$ 表示前 $i$ 分钟进行了 $j$ 次踱步，且第 $i$ 分钟在屋内 / 屋外的最大心情值，设 $g_{i, j, 0 / 1}$ 表示在第 $i$ 分钟**恰好**进行了 $j$ 次踱步，且第 $i$ 分钟在屋内 / 屋外的最大心情值。

通过枚举上一次踱步的时间可以实现从 $g$ 的转移，若已知 $g_{i, j, 0 / 1}$ 的值可以快速计算出 $f$ 的值，进而更新答案。

考虑如何优化，通过对位置贡献的区间和转化为前缀和的差可以将贡献式拆为只与上次踱步时间有关的形式，同时发现上式中转移 $g$ 主要有两种情况：

- 上次踱步在 $T$ 分钟前。
- 上次踱步在 $T$ 分钟内。

对于第一种情况，决策集合只增加不删除，维护最小值即可。

对于第二种情况，发现决策集合是一个左右端点均单调不降的区间的最小值，使用单调队列维护即可。

复杂度 $\mathcal{O}(NK)$，可以通过。

---

## 作者：nb_jzy (赞：2)

# 思路
根据数据范围 $\sum{n\times k}\le 5\times10^7$ 可知，出题人希望我们的做法是在 $\mathcal{O}(n\times k)$ 复杂度左右的。

那么就不难想到可以用 $dp$。求啥设啥，我们设 $f_{i,j,1/0}$ 表示在前 $i$ 个时间点，**第 $i$ 个时间点使用了第 $j$ 次踱步**，在第 $i$ 个时间点末处于房内/房外最大的心情值。

注意，我们在状态中特意强调了**第 $i$ 个时间点使用了踱步**，之前状态因为没有这一限定，导致一直过不了样例。

那么转移就比较显然：

$$f_{i,j,0/1}=\max_{k=j}^{i-1}{f_{k,j-1,1/0}+\sum_{z=k+1}^{i-1}{a_{z,1/0}}+a_{i,0/1} + [k-i\le t]\times p}$$
# 优化

很显然，后边那一坨求和可以用前缀和优化，于是就变成了：

$$f_{i,j,0/1}=\max_{k=j}^{i}{f_{k,j-1,1/0}+sum_{i-1,1/0}-sum_{k,1/0}+a_{i,0/1}+[k-i\le t]\times p}$$

但是即使这样，复杂度仍然是 $\mathcal O (n^2\times k)$ 的。考虑优化，很显然，我们可以将附加的 $p$ 分开讨论。于是神奇的事情发生了：很容易发现，需要加 $p$ 的那些状态，不就**恰好构成了一个长度为 $t$ 的滑动窗口**。于是我们可以用单调队列进行优化。而对于 $k-i>t$ 的那些状态，我们只需要用一个变量维护最大值即可。

然后转移就变成了 $\mathcal O(1)$，总时间复杂度为 $\mathcal{O}(n\times k)$。

还有一点小优化，就是 $j$ 这一维状态明显**可以滚动**。本人偷懒没有滚动，结果TLE+MLE。

现在我们就可以解答状态设定的细节了，因为如果不强调在第 $i$ 时刻踱步，我们就**无法知道上一次踱步的时间**，就无法知道是否需要加 $p$，而我们规定之后也并**不会漏状态**，总的答案即为：

$$\max_{i=1}^{n}\max_{j=0}^{k}f_{i,j,1/0}+sum_{n,1/0}-sum_{i,1/0}$$
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+5;
int id,test,n,k,t,p,f[maxn][2][2],sum[maxn][2],maxx0,maxx1,head1,tail1,head0,tail0,q0[maxn<<1],q1[maxn<<1];
static char buf[100005],*p1=buf,*p2=buf,obuf[100005],*p3=obuf;
inline char nc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,100005,stdin),p1==p2)? EOF:*p1++;}
inline void pc(char x){p3-obuf<100000? (*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x);}
int read(){
	int res=0,f=0;
	char ch=nc();
	while(ch<'0'||ch>'9') f|=ch=='-',ch=nc();
	while(ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^48),ch=nc();
	return f? ~res+1:res;
}
inline void write(int x){
	if(x<0) x=~x+1,pc('-');
	if(x>9) write(x/10);
	pc(x%10+48);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	id=read(),test=read();
	while(test--){
		n=read(),k=read(),t=read(),p=read();
		int u,v;
		for(int i=1;i<=n;i++){
			u=read(),v=read();
			sum[i][0]=sum[i-1][0]+u,sum[i][1]=sum[i-1][1]+v; 
		}
		for(int i=1;i<=n;i++){
			f[i][0][0]=sum[i][0],f[i][0][1]=sum[i][1];
		}
		int ans=max(sum[n][0],sum[n][1]);
		for(int j=1;j<=k;j++){
			head0=head1=maxn-5,tail0=tail1=maxn-6;
			q0[++tail0]=j,q1[++tail1]=j;
			maxx0=-1e16,maxx1=-1e16;
			for(int i=j+1;i<=n;i++){
				f[i][j&1][0]=f[i][j&1][1]=-1e16;
			}
			for(int i=j+1;i<=n;i++){
				while(head0<=tail0&&i-q0[head0]>t){
					head0++;
				}
				while(head1<=tail1&&i-q1[head1]>t){
					head1++;
				}
				if((i-t-1)>=j){
					maxx0=max(maxx0,f[i-t-1][j-1&1][0]-sum[i-t-1][0]);
					maxx1=max(maxx1,f[i-t-1][j-1&1][1]-sum[i-t-1][1]);
					f[i][j&1][0]=max(f[i][j&1][0],maxx1+sum[i-1][1]+sum[i][0]-sum[i-1][0]);
					f[i][j&1][1]=max(f[i][j&1][1],maxx0+sum[i-1][0]+sum[i][1]-sum[i-1][1]);
				}
				if(j>=2){
					if(head0<=tail0){
						f[i][j&1][0]=max(f[i][j&1][0],f[q0[head0]][j-1&1][1]+sum[i-1][1]-sum[q0[head0]][1]+sum[i][0]-sum[i-1][0]+p);
					}
					if(head1<=tail1){
						f[i][j&1][1]=max(f[i][j&1][1],f[q1[head1]][j-1&1][0]+sum[i-1][0]-sum[q1[head1]][0]+sum[i][1]-sum[i-1][1]+p);
					}
				}
				else{
					if(head0<=tail0){
						f[i][j&1][0]=max(f[i][j&1][0],f[q0[head0]][j-1&1][1]+sum[i-1][1]-sum[q0[head0]][1]+sum[i][0]-sum[i-1][0]);
					}
					if(head1<=tail1){
						f[i][j&1][1]=max(f[i][j&1][1],f[q1[head1]][j-1&1][0]+sum[i-1][0]-sum[q1[head1]][0]+sum[i][1]-sum[i-1][1]);
					}
				}
				while(head0<=tail0&&f[i][j-1&1][1]-sum[i][1]>=f[q0[tail0]][j-1&1][1]-sum[q0[tail0]][1]){
					tail0--;
				}
				while(head1<=tail1&&f[i][j-1&1][0]-sum[i][0]>=f[q1[tail1]][j-1&1][0]-sum[q1[tail1]][0]){
					tail1--;
				}
				q0[++tail0]=i,q1[++tail1]=i;
				ans=max(ans,max(f[i][j&1][0]+sum[n][0]-sum[i][0],f[i][j&1][1]+sum[n][1]-sum[i][1]));
			}
		}
		write(ans),pc('\n');
	}
	fwrite(obuf,p3-obuf,1,stdout);
	return 0;
}
```

---

## 作者：HPXXZYY (赞：1)

$\color{blue}{\texttt{[Solution]}}$

首先，应该可以很明显看出来这题是一道 dp 题。

记 $f_{j,i,0/1}$ 表示在 $i$ 分钟初**第** $j$ 次踱步（即第 $i$ 分钟初一定会踱步），踱步**后**在屋内/外的状态下，前 $(i-1)$ 分钟（为了方便转移，**不包括**第 $i$ 分钟）的总心情值的最大值。

~~（这一段话特别的拗口，没办法，语文水平不太高。大家多读几次将就一下吧。）~~

转移方程还是比较显然的，以 $f_{j,i,0}$ 为例：

$$f_{j,i,0}=\max\limits_{t=1}^{i-1} \left \{ f_{t,j-1,1}+\sum\limits_{k=t}^{\color{red}{i-1}}b_{k}+P\text{[if } i-t \leq T] \right \}$$

解释一下，由于第 $i$ 分钟踱步后进入了屋内，所以踱步前应该在屋外，所以中间加的应该是在屋外的心情值。

$f_{j,i,1}$ 同理，不过中间那一项应该是在屋外的心情值。

显然，我们可以用**前缀和**维护中间的连续求和项。不太好办的是那个 $P$。我们不能枚举 $t$，那样时间复杂度将是 $O(N^2 \times K)$，会超时。

那就分类讨论吧，对于 $i-T \leq t < i$ 的每一个 $t$，是要加上这个 $P$ 的，我们发现这个转移区间长度是确定的，但是左端点会每次加 $1$。这非常非常符合**单调队列优化 dp** 的要求。可以用单调队列优化至平均每次转移 $O(1)$。

对于 $t<i-T$ 的区间呢？我们发现，这个转移区间只会变长，不会变短或者删除某些解，于是用一个变量就可以维护。平均每次也是 $O(1)$ 的。

因此，总时间复杂度为 $O(NK)$。

另外，为了避免 MLE，应该要用**滚动数组**。

注意细节，要养成良好的清空数组的习惯。其它具体看代码。

$\color{blue}{\text{[code]}}$

```cpp
const int N=2e5+100;
typedef long long ll;
const ll inf=(ll)1e18;

ll sum[N][2],f[2][N][2],ans;
int q[N][2],hd[2],tl[2],n,k,t,p,T;

inline ll val(int pos,int Tim,int id){
	return f[Tim][pos][id]-sum[pos-1][id];
}

inline ll ckmax(ll &a,ll b){
	return (a=((a>b)?a:b));
}

inline int initdata(){
	for(int i=0;i<=n+2;i++)
		f[0][i][0]=f[1][i][1]=-inf;
	for(int i=0;i<=n+2;i++)
		sum[i][0]=sum[i][1]=0;
	for(int i=0;i<=n+2;i++)
		q[i][0]=q[i][1]=0;
	ans=-inf;
	
	return 0;
}//不能直接用 memset

int main(){
	read();T=read();
	while (T--){
		n=read();k=read();
		t=read();p=read();
		
		initdata();
		
		for(int i=1;i<=n;i++){
			sum[i][0]=sum[i-1][0]+read();
			sum[i][1]=sum[i-1][1]+read();
		}
		
		ans=max(sum[n][0],sum[n][1]);
		
		for(int i=1;i<=n;i++){
			f[0][i][0]=sum[i-1][0];
			f[0][i][1]=sum[i-1][1];
		}
		
		for(int j=1;j<=k;j++){
			int now=j&1,lst=now^1;
			for(int i=0;i<=n+2;i++)
				f[now][i][0]=f[now][i][1]=-inf;//记得清空
			hd[0]=hd[1]=1;tl[0]=tl[1]=0;
			
			ll max1=-inf,max0=-inf;
			
			for(int i=1;i<=n;i++){
				while (hd[0]<=tl[0]&&q[hd[0]][0]<i-t) hd[0]++;
				if (i>=j&&hd[0]<=tl[0]) f[now][i][0]=val(q[hd[0]][0],lst,1)+sum[i-1][1]+p*(j>1);
				注意这里，j=1 的时候无论如何也不能加上 p
				while (hd[0]<=tl[0]&&val(q[tl[0]][0],lst,1)<=val(i,lst,1)) tl[0]--;
				q[++tl[0]][0]=i;
				
				while (hd[1]<=tl[1]&&q[hd[1]][1]<i-t) hd[1]++;
				if (i>=j&&hd[1]<=tl[1]) f[now][i][1]=val(q[hd[1]][1],lst,0)+sum[i-1][0]+p*(j>1);
				while (hd[1]<=tl[1]&&val(q[tl[1]][1],lst,0)<=val(i,lst,0)) tl[1]--;
				q[++tl[1]][1]=i;
				
				if (i>t){
					ckmax(f[now][i][0],max1+sum[i-1][1]);
					ckmax(f[now][i][1],max0+sum[i-1][0]);
					ckmax(max1,val(i-t,lst,1));
					ckmax(max0,val(i-t,lst,0));
				}
			}
			
			for(int i=j;i<=n;i++)
				ckmax(ans,max(f[now][i][0]+sum[n][0]-sum[i-1][0],f[now][i][1]+sum[n][1]-sum[i-1][1]));
		}
		
		printf("%lld\n",ans);
	}
	
	return 0;
}
```

---

## 作者：wangshulin (赞：1)

# 整体思路
使用动态规划，状态 $f_{i,j,k}$ 表示在第 $i$ 时刻**刚好**进行第 $j$ 次踱步，踱步到了 $k$ 位置（$k=0$ 代表里面，$k=1$ 代表外面）
### 为什么要使用这种状态
如果将状态改为进行了 $j$ 次踱步，而不是**刚好**进行第 $j$ 次踱步，则无法判断与上次踱步的时间关系。而一种经典错误就是在动态规划中挂链，链向上一个更新此状态的状态来判断上一次踱步的时间，这会导致动态规划具有后效性

### 状态转移方程
设 $s_{i,k}$ 代表第 $i$ 时刻位置 $k$ 的权值的前缀和，有
$$f_{i,j,k}=\max_{x=1}^{i-1} f_{x,j-1,k \operatorname{XOR} 1}+s_{i-1,k \operatorname{XOR} 1}-s_{x,k \operatorname{XOR} 1}+v_{i,k}+[i−x \le t \wedge j>1] \times p$$

解释：
枚举上一次踱步的时间更新这一次踱步
- $k \operatorname{XOR} 1$ 就是不同于 $k$ 的另一个位置状态
- $f_{x,j-1,k \operatorname{XOR} 1}$ 就为上一次踱步最优值
- $s_{i-1,k \operatorname{XOR} 1}-s_{x,k \operatorname{XOR} 1}$ 就是中间间隔的没踱步时的权值和
- $v_{i,k}$ 代表踱步过来，加上此处的权值
- $[i−x \le t \wedge j>1] \times p$ 为判断当 $i-x\le t$ 且 $j>1$，此时满足间隔 $t$ 分钟内踱步两次，加上 $p$

# 25分做法
直接按照以上状态转移暴力枚举，时间复杂度 $O(n^2 k)$，期望得分 $25$ 分
### 代码
```cpp
#include<stdio.h>
#include<algorithm>
#define ll long long
const ll N=200010,K=205;
ll id,Q,n,m,t,p,ans,v[N][2],s[N][2],f[N][K][2],g[N][K][2];
int main(){
	scanf("%lld%lld",&id,&Q);
	while(Q--){
		scanf("%lld%lld%lld%lld",&n,&m,&t,&p);
		for(ll i=1;i<=n;i++){
			scanf("%lld%lld",&v[i][0],&v[i][1]);
			s[i][0]=s[i-1][0]+v[i][0];
			s[i][1]=s[i-1][1]+v[i][1];
		}
		for(ll i=1;i<=n;i++){
			for(ll j=1;j<=m;j++){
				for(ll k=0;k<=1;k++){
					f[i][j][k]=-1e18;
				}
			}
		}
		for(ll i=1;i<=n;i++){
			f[i][0][0]=s[i][0];
			f[i][0][1]=s[i][1];
		}
		ans=std::max(s[n][0],s[n][1]);
		for(ll i=1;i<=n;i++){
			for(ll j=1;j<=m;j++){
				for(ll k=0;k<=1;k++){
					for(ll x=1;x<i;x++){
						ll u=f[x][j-1][k^1]+s[i-1][k^1]-s[x][k^1]+v[i][k]+(i-x<=t&&j>1)*p;
						f[i][j][k]=std::max(f[i][j][k],u);
					}
					ans=std::max(ans,f[i][j][k]+s[n][k]-s[i][k]);
				}
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```
# 满分做法
可以发现以上状态转移方程大致分为两部分
- 当 $i-x>t$，同时发现 $x \ge j$，即 $j \le x < i-t$，可见当 $j$ 固定，发现枚举左端点（$j$）固定，右端点（$i-t-1$）递增，再加上没有 $p$ 的影响，可以直接维护其最大值更新
- 当 $i-x \le t$，又发现当一次踱步时间离此次踱步比另一次踱步远，所提供权值又比另一次踱步少，就可以只保留另一次踱步，可以使用单调队列优化，维护一个单调下降的更新序列

发现以上两个维护都是再遍历状态 $i$ 的同时维护状态 $x$，因此先枚举状态 $j$，再枚举状态 $i$ 可以省空间，而此时还是会爆空间，用滚动更新即可

时间复杂度 $O(nk)$，期望得分 $100$ 分
### 代码
```cpp
#include<stdio.h>
#include<algorithm> 
#define ll long long
const ll N=200010,K=205;
ll id,Q,n,m,t,p,ans,mx[2],l[2],r[2],v[N][2],s[N][2],q[N][2],f[N][2][2];
int main(){
	scanf("%lld%lld",&id,&Q);
	while(Q--){
		scanf("%lld%lld%lld%lld",&n,&m,&t,&p);
		for(ll i=1;i<=n;i++){
			scanf("%lld%lld",&v[i][0],&v[i][1]);
			s[i][0]=s[i-1][0]+v[i][0];
			s[i][1]=s[i-1][1]+v[i][1];
		}
		ans=std::max(s[n][0],s[n][1]);
		for(ll i=1;i<=n;i++){
			f[i][0][0]=s[i][0];
			f[i][0][1]=s[i][1];
		}
		for(ll j=1;j<=m;j++){//枚举转了j遍 
			mx[0]=mx[1]=-1e18;
			l[0]=l[1]=r[0]=r[1]=1;
			q[1][0]=q[1][1]=j;
			for(ll i=j+1;i<=n;i++){
				for(ll k=0;k<=1;k++){
					f[i][j&1][k]=-1e18;
				} 
			}
			for(ll i=j+1;i<=n;i++){//枚举在第i个位置转过来的
				for(ll k=0;k<=1;k++){
					if(i-t-1>=j) mx[k]=std::max(mx[k],f[i-t-1][j-1&1][k]-s[i-t-1][k]);//假设刚好在i-t-1转
					while(l[k]<=r[k]&&q[l[k]][k]<i-t) l[k]++;
				} 
				for(ll k=0;k<=1;k++){//枚举转到k位置
					if(i-t-1>=j){//距离上次转已经大于t了
						f[i][j&1][k]=std::max(f[i][j&1][k],mx[k^1]+s[i-1][k^1]+v[i][k]);
					}
					if(l[k^1]<=r[k^1]){//距离上次转小于等于t
						ll x=q[l[k^1]][k^1];
						if(j>1) f[i][j&1][k]=std::max(f[i][j&1][k],f[x][j-1&1][k^1]-s[x][k^1]+s[i-1][k^1]+v[i][k]+p);
						else f[i][j&1][k]=std::max(f[i][j&1][k],f[x][j-1&1][k^1]-s[x][k^1]+s[i-1][k^1]+v[i][k]);
					}
					ans=std::max(ans,f[i][j&1][k]+s[n][k]-s[i][k]);
				}
				for(ll k=0;k<=1;k++){
					while(l[k]<=r[k]&&f[q[r[k]][k]][j-1&1][k]-s[q[r[k]][k]][k]<=f[i][j-1&1][k]-s[i][k]) r[k]--;
					q[++r[k]][k]=i;
				}
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：CCComfy (赞：1)

# 踱步 题解

## 思路分析

本题的核心思想是使用单调队列维护滑动窗口最大值，从而优化分段取前缀最大值的 DP 转移。

我们先从 Sub2 入手，考虑 DP，设 $dp_{i,j,0/1}$ 表示钦定在第 $i$ 分钟进行第 $j$ 次踱步，**踱步到**屋内还是屋外，$i$ 时刻之前（不包含 $i$ 时刻）的最大心情值。

然后考虑转移，枚举上一次踱步的时间 $k$（以从屋内踱步到屋外为例），那么在 $k$ 到 $i-1$ 这部分时间内，小 $X$ 都在屋内，其心情值变化可以用前缀和 $\mathit{\Theta}(1)$ 计算，既 $suma_{i-1}-suma_{k-1}$，同时根据题目要求，若 $i-k \le T$，则还会使心情增加 $P$，加入贡献即可。

由此我们可以得到转移方程：

$$\begin{cases}
    dp_{i,j,1}=\max\{dp_{k,j-1,0}+suma_{i-1}-suma_{k-1}+P\times[i-k\le T]\}\\
    \\
    dp_{i,j,0}=\max\{dp_{k,j-1,1}+sumb_{i-1}-sumb_{k-1}+P\times[i-k\le T]\}
\end{cases}$$

有几个需要注意的地方：

- 第一次踱步不会加上 $P$ 的贡献，所以需要特判 $k=1$ 的情况，此时不能加 $P$。

- 每一个状态都可能对答案造成贡献，这种情况从 $i$ 开始到结束都不进行踱步，所以 $ans=\max\{dp_{i,j,0/1}+sum_{n}-sum_{i-1}\}$

- 可能全程都不踱步才是最优的情况，所以 $ans=\max\{suma_n,sumb_n\}$

但是直接这样转移的时间复杂度是 $\mathit{\Theta}(n^2K)$ 的，考虑优化。

我们发现每一个状态只会从前面的唯一一个状态转移过来，先从转移方程入手：

- 对于 $i-k>T$ 这一部分：

$$\begin{aligned}
    dp_{i,j,1}= & \max_{k=1}^{i-T-1}\{dp_{k,j-1,0}+suma_{i-1}-suma_{k-1}\}\\
              = & \max_{k=1}^{i-T-1}\{dp_{k,j-1,0}+suma_{k-1}\}+suma_{i-1}
\end{aligned}$$

此时我们维护前 $i-T-1$ 个位置的 $dp_{k,j}+suma_{k-1}$ 的前缀最大值，这个是好维护的，直接转移即可。

- 对于 $i-K\le T$ 这一部分：

$$\begin{aligned}
    dp_{i,j,1}= & \max_{k=i-T}^{i-1}\{dp_{k,j-1,0}+suma_{i-1}-suma_{k-1}+P\}\\
              = & \max_{k=i-T}^{i-1}\{dp_{k,j-1,0}+suma_{k-1}\}+suma_{i-1}+P
\end{aligned}$$

此时我们维护区间 $[i-T,i-1]$ 的 $dp_{k,j}+suma_{k-1}$ 的前缀最大值，该区间长度不变，不断右移，这不就是 [滑动窗口](https://www.luogu.com.cn/problem/P1886) 吗，使用单调队列实现，转移即可。

这样我们就优化掉了枚举 $k$ 的复杂度，总时间复杂度为 $\mathit{\Theta}(nK)$。


## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define ll long long
#define int long long
il ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
const ll inf=1ll<<60;
const int M=2e5+10;
const int MOD=24000;
ll dp[25000][1010][2];
int a[M],b[M];
ll suma[M],sumb[M];
ll mxa[1010],mxb[1010];
deque<pair<ll,int>> qa[1010],qb[1010];
main(){
    int id=read(),test=read();
    while(test--){
        int n=read(),K=read(),t=read(),p=read();
        for(int i=1;i<=n;i++)a[i]=read(),b[i]=read();
        for(int i=1;i<=n;i++)suma[i]=suma[i-1]+a[i],sumb[i]=sumb[i-1]+b[i];
        for(int i=0;i<=MOD+2&&i<=n+1;i++)
            for(int j=0;j<=K+1;j++)
                dp[i][j][0]=dp[i][j][1]=-inf;
        for(int j=0;j<=K+1;j++){
            qb[j].clear(),qa[j].clear();
            mxb[j]=mxa[j]=-inf;
        }
        dp[1][0][0]=0;
        dp[1][0][1]=0;
        qa[0].push_back(make_pair(0,1));
        qb[0].push_back(make_pair(0,1));
        ll ans=max(suma[n],sumb[n]);
        for(int i=2;i<=n;i++){
            for(int j=K;j>=1;j--){
                if(qb[j-1].size())dp[i%(MOD)][j][0]=qb[j-1].front().first+sumb[i-1]+p*(qb[j-1].front().second!=1);
                if(qa[j-1].size())dp[i%(MOD)][j][1]=qa[j-1].front().first+suma[i-1]+p*(qb[j-1].front().second!=1);
                if(i>t){
                    dp[i%(MOD)][j][0]=max(dp[i%(MOD)][j][0],mxb[j-1]+sumb[i-1]);
                    dp[i%(MOD)][j][1]=max(dp[i%(MOD)][j][1],mxa[j-1]+suma[i-1]);
                    mxb[j]=max(mxb[j],dp[(i-t)%MOD][j][1]-sumb[i-t-1]);
                    mxa[j]=max(mxa[j],dp[(i-t)%MOD][j][0]-suma[i-t-1]);
                }
                while(!qb[j].empty()&&dp[i%(MOD)][j][1]-sumb[i-1]>qb[j].back().first)qb[j].pop_back();
                qb[j].push_back(make_pair(dp[i%(MOD)][j][1]-sumb[i-1],i));
                if(i>=t)
                    while(!qb[j].empty()&&qb[j].front().second<=i-t)qb[j].pop_front();
                while(!qa[j].empty()&&dp[i%(MOD)][j][0]-suma[i-1]>qa[j].back().first)qa[j].pop_back();
                qa[j].push_back(make_pair(dp[i%(MOD)][j][0]-suma[i-1],i));
                if(i>=t)
                    while(!qa[j].empty()&&qa[j].front().second<=i-t)qa[j].pop_front();
                ans=max({ans,dp[i%(MOD)][j][0]+suma[n]-suma[i-1],dp[i%(MOD)][j][1]+sumb[n]-sumb[i-1]});
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：Ericnoi (赞：0)

# P10119 题解 
[题目传送门](https://www.luogu.com.cn/problem/P10119)

# 思路

不难看出是一道DP，观察一下数据范围，理想时间复杂度应该是 $O(nk)$。

定义 $dp_{i,j,c}(c \in \{0,1\})$ 为第 $i$ 分钟已经踱步了 $j$ 次现在在室内或者室外的最大心情。并且第 $i+1$ 分钟开始时必须踱步。

有显然的转移方程：

$$ dp_{i,k,c} = \max_{j=k-1}^{i-1}(dp_{j,k-1,1-c}+\sum_{s=j+1}^{i}a_{s,c}+[i-j\le t]\times p) $$

注意到可以用前缀和优化：

$$ dp_{i,k,c} = \max_{j=k-1}^{i-1}(dp_{j,k-1,1-c}+sum_{i,c}-sum_{j,c}+[i-j\le t]\times p) $$

整理为另一种形式：

$$ dp_{i,k,c} = \max_{j=k-1}^{i-1}(dp_{j,k-1,1-c}-sum_{j,c}+[i-j\le t]\times p)+sum_{i,c} $$

显然 $[k-1,i-1]$ 的区间可以根据 $[i-j\le t]$ 的值分为 $[k-1,i-t-1]$ 和 $[i-t,i-1]$ 两部分。前者范围内的最大值当 $k$ 固定时可以直接维护。后者范围内的最大值则是一个标准的单调队列优化。至此，时间复杂度实现了 $O(nk)$。

但是，如果我们开三维数组，空间依然会超限。注意到当前状态只与第二维为 $k-1$ 的状态有关。于是可以用滚动数组把第二维压缩掉。空间复杂度 $O(n)$。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define inf (0x3f3f3f3f3f3f3f3f)
#define pb push_back
#define ps push
#define fill(x, y) memset(x, y, sizeof(x))
#define chkmax(x, y) ((x) = max((x), (y)))
#define chkmin(x, y) ((x) = min((x), (y)))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline int read(int &x) { 
	int f = 1; x = 0; char s = getchar();
	while(!isnumber(s)) {if(s == '-') f = -1; s = getchar();}
	while(isnumber(s)) x = (x << 1) + (x << 3) + (s ^ '0'), s = getchar();
	return x *= f;
}
inline void print(int x, char suf = 0, int base = 10) {
	if(x < 0) {putchar('-'); x = -x;}
	if(x >= base) print(x / base, 0, base);
	putchar(48 ^ (x % base));
	if(suf) putchar(suf);
}
int cx = 1; // 测试数据组数，默认为1
const int N = 2e5 + 5;
const int K = 200 + 5;
int n, m, t, p, a[N][2], sum[N][2], dp[2][N][2];
deque<int> q;
int now = 0, old = 1; // now 指向当前操作的数组，old 指向之前操作的数组。当需要交替时，交换这两个变量。
int value(int i, int c) {
	return dp[old][i][1-c] - sum[i][c];
}
void solve() {
	int ans = -inf;
	read(n), read(m), read(t), read(p);
	for(int i = 1 ; i <= n ; i++) {
		for(int c = 0 ; c <= 1 ; c++) {
			read(a[i][c]);
			sum[i][c] = a[i][c] + sum[i-1][c];
			dp[now][i][c] = sum[i][c];
		}
	}
	chkmax(ans, max(sum[n][0], sum[n][1]));
	for(int i = 1 ; i < n ; i++) { // 单独处理只踱步一次的情况
		for(int c = 0 ; c <= 1 ; c++) {
			chkmax(ans, dp[now][i][c] - sum[i][1-c] + sum[n][1-c]);
		}
	}
	for(int k = 2 ; k <= m ; k++) {
		swap(old, now); // 数组滚动
		for(int c = 0 ; c <= 1 ; c++) {
			int mx = -inf; // 维护[k-1,i-t-1]的最大值
			q.clear();
			q.push_back(k - 1); // k - 1 单独讨论
			for(int i = k ; i <= n ; i++) {
				while(q.size() && q.front() < i - t) q.pop_front();
				if(i - t - 1 >= k - 1) chkmax(mx, value(i - t - 1, c));
				dp[now][i][c] = max(mx, value(q.front(), c) + p) + sum[i][c];
				while(q.size() && value(q.back(), c) < value(i, c)) q.pop_back();
				q.push_back(i);
			}
		}
		for(int i = k ; i < n ; i++) {
			for(int c = 0 ; c <= 1 ; c++) {
				chkmax(ans, dp[now][i][c] + sum[n][1-c] - sum[i][1-c]); // 更新 ans
			}
		}
	}
	print(ans, '\n');
}
signed main() {
    read(cx), read(cx);
    while(cx--) {
        solve();
    }
    return 0;
}
```

---

## 作者：zdd0342 (赞：0)

# [『STA - R4』踱步](https://www.luogu.com.cn/problem/P10119)

## Solution

看到题目保证了 $\sum NK\le 5\times 10^7$，就猜到做法是 $O(NK)$ 的。

首先，这个题目非常明显的 dp。

定义屋内状态为 0，屋外状态为 1。

先做一些转化，把贡献更改为下面：

> 对于每一个极长连续段，贡献为每一个数之和。
>
> 除了第一段和最后一段，如果这一段长度大于等于 $T$，那么有额外 $P$ 的贡献。
>
> 最多能有 $K+1$ 段。

不难发现，每一次踱步的位置都等价于两段的端点处。

定义状态 $dp_{0/1,t,i}$ 表示当前的段数为 $t$，最后一段**恰好**在 $i$ 处结尾，且状态是 $0/1$。

设 $C(op,l,r)$ 表示当前状态为 $op$，$[l,r]$ 段的贡献。

其中：
$$
C(0,l,r)=\sum_{i=l}^{r}a_i\\
C(1,l,r)=\sum_{i=l}^{r}b_i
$$
初始状态就是第一段的代价：$dp_{op,1,i}=C(op,1,i)$。

转移方程：
$$
dp_{op,t,i}=\max\left\{\begin{matrix} 
  dp_{op\oplus1,t-1,k}+C(op,k+1,i) & k\in[1,i-T-1]\\  
  dp_{op\oplus1,t-1,k}+C(op,k+1,i)+P & k\in[i-T,i-1]
\end{matrix}\right.
$$
定义 $g_{op,t,i}=dp_{op,t,i}-C(op\oplus1,1,i)$。

那么转移方程重写为：
$$
dp_{op,t,i}=\max\left\{\begin{matrix} 
  g_{op\oplus1,t-1,k}+C(op,1,i) & k\in[1,i-T-1]\\  
  g_{op\oplus1,t-1,k}+C(op,1,i)+P & k\in[i-T,i-1]
\end{matrix}\right.
$$
因为最后一段也是特殊段，答案为：
$$
\max(dp_{op,t,i}+C(op\oplus 1,i+1,n))
$$
其中 $i\in[1,n-1],t\in[1,K]$。

发现就是一个区间最值的形式。

直接上一个 $O(n)$ 预处理，$O(1)$ 查询的 RMQ 解法即可。注意细节。

我使用奇怪做法，码量比较小。

### How

类似笛卡尔树加 st 表，但是没有使用加一减一 RMQ 的性质。

假设现在有长度为 $n$ 的数组，需要求出区间最大值。

把数组每 $\log n$ 个数分成一段，一共 $\lceil\frac n{\log n}\rceil$ 段。

类似分块，对于整段查询，对于每一个段的最大值，处理出一个 st 表。复杂度 $O(\frac n{\log n}\times \log n)$，即为 $O(n)$。

对于段内查询，记录每一个数到段首的单调栈，因为 $n\le 10^9$，所以可以用整数压位记录。

然后，查询 $l,r$ 相当于查询 $r$ 的单调栈中，第一个大于等于 $l$ 的位置上的值。可以简单位运算得出，复杂度 $O(1)$。

st 表的复杂度也是 $O(1)$，整体就是 $O(1)$ 的。

实现看代码。

##  Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define F(i,a,b) for(int i=a;i<=(b);i=-~i)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
const int MAXN=2e5+5;
const int inf=1e18;
int n,K,T,P;
int w[2][MAXN];
inline int C(int op,int l,int r){
    return w[op][r]-w[op][l-1];
}
int dp[2][2][MAXN],g[2][2][MAXN];
namespace rmq{
    int A[MAXN];
    int block,L[MAXN],R[MAXN],bl[MAXN];
    int Mx[MAXN],z[MAXN],q[MAXN],tp;
    int st[20][MAXN],lg[MAXN];
    inline void init(){
        F(i,1,bl[n]){
            tp=0;int S=0;
            F(j,L[i],R[i]){
                while(tp&&A[q[tp]]<=A[j]){
                    S^=(1<<(q[tp]-L[i]));
                    tp--;
                }
                q[++tp]=j;
                S^=(1<<(j-L[i]));
                z[j]=S;
            }
        }
        lg[0]=-1;
        F(i,1,bl[n]){
            lg[i]=lg[i>>1]+1;
            st[0][i]=-inf;
            F(j,L[i],R[i])
                st[0][i]=max(st[0][i],A[j]);
        }
        F(i,1,19)F(j,1,bl[n]-(1<<i)+1){
            st[i][j]=max(st[i-1][j],st[i-1][j+(1<<(i-1))]);
        }
    }
    inline int qry1(int l,int r){
        if(l>r)return -inf;
        return A[l+__builtin_ctz(z[r]>>(l-L[bl[l]]))];
    }
    inline int qry2(int l,int r){
        if(l>r)return -inf;
        int k=lg[r-l+1];
        return max(st[k][l],st[k][r-(1<<k)+1]);
    }
    inline int qry(int l,int r){
        if(bl[l]==bl[r])return qry1(l,r);

        return max({
            qry1(l,R[bl[l]]),
            qry2(bl[l]+1,bl[r]-1),
            qry1(L[bl[r]],r)
        });
    }
    inline void All(){
        block=log2(n);
        F(i,1,n)bl[i]=(i-1)/block+1;
        F(i,1,n)R[bl[i]]=i;
        dF(i,n,1)L[bl[i]]=i;
    }
    inline void clr(int op,int tim){
        F(i,1,n)A[i]=g[op][tim][i];
        init();
    }
}
inline void solve(){
    cin>>n>>K>>T>>P,K++;
    rmq::All();
    F(i,1,n){
        cin>>w[0][i]>>w[1][i];
        w[0][i]+=w[0][i-1];
        w[1][i]+=w[1][i-1];
    }
    F(i,0,1)F(j,0,1)F(k,0,n)dp[i][j][k]=-inf,g[i][j][k]=-inf;

    int ans=max(C(0,1,n),C(1,1,n));
    F(op,0,1)F(i,1,n){
        dp[op][1][i]=C(op,1,i);
        g[op][1][i]=dp[op][1][i]-w[op^1][i];
        ans=max(ans,dp[op][1][i]+C(op^1,i+1,n));
    }
    F(j,2,K-1)F(op,0,1){
        rmq::clr(op^1,j-1&1);
        F(i,0,n)dp[op][j&1][i]=g[op][j&1][i]=-inf;
        F(i,1,n-1){
            if(i>T+1)dp[op][j&1][i]=rmq::qry(1,i-T-1)+w[op][i];
            if(max(1ll,i-T)<=i-1)dp[op][j&1][i]=max(dp[op][j&1][i],rmq::qry(max(1ll,i-T),i-1)+w[op][i]+P);

            g[op][j&1][i]=dp[op][j&1][i]-w[op^1][i];
            ans=max(ans,dp[op][j&1][i]+C(op^1,i+1,n));
        }
    }
    cout<<ans<<"\n";
}
signed main(){
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    int id,T;cin>>id>>T;
    while(T--)solve();
}
```

---

## 作者：Wei_Han (赞：0)

调了一亿年。

考虑 dp，令 $f_{i,j,0/1}$ 表示在第 $i$ 分钟末，恰好进行了 $j$ 次踱步，此时在内/外的最大心情值，也就是必须在第 $i$ 分钟初进行一次踱步。

这个状态的设计主要是为了方便确定贡献区间的范围，如果将 $j$ 的意义改为已经进行了 $j$ 次，那么我们将无法找到上一次具体的踱步位置。

令 $pre_{i,0/1}$ 分别表示内/外的前缀和，可以写出转移：

$$f_{i,j,op} = \max_{x=j-1}^{i-1} f_{x,j-1,1-op} + a_{i,op} + pre_{i-1,1-op} - pre_{x,1-op} + [i-x \geq T \wedge x > 1]P$$

可以将与 $x$ 无关的项提出来，然后分类讨论：

- 对于 $x < i-T$，转移是 $f_{i,j,op} = a_{i,op} + pre_{i-1,1-op} +\max_{x=j-1}^{i-1} f_{x,j-1,1-op}  - pre_{x,1-op}$，我们顺次枚举 $i$，那么后面的 $\max$ 用一个变量每次维护就好了。

- 对于 $x \geq i-T$，转移与上一种情况只是多了一个 $P$，而对于 $\max$，我们要维护 $i$ 之前 $T$ 个位置的 $\max$，这个单调队列就可以做到。

注意要预处理 $j=0,1$ 的情况，到这里，可以获得 $70$ 分。

```cpp
ll n,K,T,P,f[N][M][2],a[N][2],maxn[M][2];
deque<int> q[M][2];
inline ll gets(ll x,ll k,ll op){return f[x][k][op]-a[x][op];}
inline void upd(ll k,ll op,ll id)
{
	while(!q[k][op].empty()&&gets(id,k,op)>gets(q[k][op].back(),k,op)) q[k][op].pop_back();q[k][op].push_back(id);
	while(!q[k][op].empty()&&id-q[k][op].front()>=T) q[k][op].pop_front();
}
inline ll ask(ll k,ll op){if(!q[k][op].size()) return -INF;return gets(q[k][op].front(),k,op);}
inline void solve()
{
	read(n),read(K),read(T),read(P);
	fo(1,i,n) read(a[i][0]),read(a[i][1]),a[i][0]=a[i-1][0]+a[i][0],a[i][1]=a[i-1][1]+a[i][1];
	fo(0,i,n+1) fo(0,j,K+1) fo(0,op,1) f[i][j][op]=-INF;
	fo(0,j,K+1) fo(0,op,1) maxn[j][op]=-INF;
	fo(1,i,n) fo(0,op,1) f[i][0][op]=a[i][op];
	ll ans=max(a[n][0],a[n][1]);
	ll maxx[2]={-INF,-INF};
	fo(2,i,n) fo(0,op,1) f[i][1][op]=a[i-1][op^1]+a[i][op]-a[i-1][op],ans=max(ans,f[i][1][op]+a[n][op]-a[i][op]);
	fo(1,i,n){
		if(i-T>1) fo(1,j,K) fo(0,op,1) maxn[j][op]=max(maxn[j][op],f[i-T-1][j][op]-a[i-T-1][op]);
		Fo(K,j,2) fo(0,op,1) f[i][j][op]=max(P+a[i][op]-a[i-1][op]+a[i-1][op^1]+ask(j-1,op^1),a[i][op]-a[i-1][op]+a[i-1][op^1]+maxn[j-1][op^1]),ans=max(ans,f[i][j][op]+a[n][op]-a[i][op]);
		Fo(K,j,1) fo(0,op,1) upd(j,op,i);
	}
	wr(max({ans})),pr;
	fo(0,i,n+1) fo(0,j,K) fo(0,op,1) f[i][j][op]=0,maxn[j][op]=0,a[i][0]=a[i][1]=0;
	fo(0,j,K+1) fo(0,op,1) while(q[j][op].size()) q[j][op].pop_front();
}
``````

此时空间复杂度是 $O(nk)$ 的，无法通过。发现 $T \leq 2\times 10 ^4$，所以对于前缀 $\max$ 的维护只需要维护 $T$ 个就行，改成这样滚动就可以通过了。

时间复杂度 $O(nk)$，空间 $O(Tk)$。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar('\n')
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
//typedef int ll;
typedef long long ll;
//typedef __int128 ll;
typedef double db;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
const ll N=2e5+5,M=205,MOD=1e5+100;
ll n,K,T,P,f[MOD+100][M][2],a[N][2],pre[N][2],maxn[M][2],g[N][2];
deque<pii > q[M][2];
inline void upd(ll k,ll op,ll p,ll id)
{
	while(!q[k][op].empty()&&p>q[k][op].back().fi) q[k][op].pop_back();q[k][op].push_back({p,id});
	while(!q[k][op].empty()&&id-q[k][op].front().se>=T) q[k][op].pop_front();
}
inline ll ask(ll k,ll op){if(!q[k][op].size()) return -INF;return q[k][op].front().fi;}
inline void solve()
{
	read(n),read(K),read(T),read(P);
	fo(1,i,n) read(a[i][0]),read(a[i][1]),pre[i][0]=pre[i-1][0]+a[i][0],pre[i][1]=pre[i-1][1]+a[i][1];
	fo(0,i,n+1) fo(0,j,K+1) fo(0,op,1) f[i%MOD][j][op]=-INF;
	fo(0,j,K+1) fo(0,op,1) maxn[j][op]=-INF;
	fo(1,i,n) fo(0,op,1) f[i%MOD][0][op]=pre[i][op];
	ll ans=max(pre[n][0],pre[n][1]),maxx[2]={-INF,-INF};g[1][0]=g[1][1]=-INF;
	fo(2,i,n) fo(0,op,1) g[i][op]=pre[i-1][op^1]+a[i][op],ans=max(ans,g[i][op]+pre[n][op]-pre[i][op]);
	fo(1,i,n){
		fo(0,op,1) f[i%MOD][1][op]=g[i][op],f[i%MOD][0][op]=pre[i][op];
		if(i-T>1) fo(0,j,K) fo(0,op,1) maxn[j][op]=max(maxn[j][op],f[(i-T-1+MOD)%MOD][j][op]-pre[i-T-1][op]);
		Fo(K,j,2) fo(0,op,1) f[i%MOD][j][op]=max(P+a[i][op]+pre[i-1][op^1]+ask(j-1,op^1),a[i][op]+pre[i-1][op^1]+maxn[j-1][op^1]),ans=max(ans,f[i%MOD][j][op]+pre[n][op]-pre[i][op]);
		Fo(K,j,0) fo(0,op,1) upd(j,op,f[i%MOD][j][op]-pre[i][op],i);
	}
	wr(ans),pr;
	fo(0,i,n+1) fo(0,j,K) fo(0,op,1) g[i][op]=f[i%MOD][j][op]=0,maxn[j][op]=0,pre[j][op]=0,a[i][0]=a[i][1]=0;
	fo(0,j,K+1) fo(0,op,1) while(q[j][op].size()) q[j][op].pop_front();
}
signed main(){
	ll tt,Test;read(Test),read(tt);while(tt--){solve();}
	return 0;
}
``````

---

## 作者：船酱魔王 (赞：0)

# P10119 『STA - R4』踱步 题解

## 题意回顾

$ 2 $ 行 $ N $ 列的格子，你要在上面跑酷（由第 $ 1 $ 列到第 $ n $ 列），你初始可以选择在哪一列开始，在每个格子的开头（不含第一个格子）你可以选择是否要移动到另一行，你到达的每个格子都会影响你的分数，如果在相隔小于等于 $ T $ 个格子内移动两次的话，会额外加上 $ P $ 分，你最多移动 $ K $ 次。多测，$ Q $ 组数据。

$ 1 \le Q \le 10^5 $，$ 2 \le N \le 2 \times 10^5 $，$ 1 \le K \le 200 $，$ \sum N \cdot K \le 5 \times 10^7 $。

## 分析

题目规定了 $ N \times K $ 的和不超过 $ 5 \times 10^7 $，故猜测时间复杂度和 $ N \times K $ 有关，考虑设计以目前位置和已经移动的次数的二维动态规划，数据范围很大所以每次 DP 转移尽量 $ O(1) $。

设 $ f_{i,j} $ 为到达 $ a_j $，正好发生第 $ i $ 次移动，$ 1 \sim j-1 $ 列及移动带给你的最大分数，到达 $ b_j $ 情况记为 $ g_{i,j} $，这里我们只考虑 $ b $ 移动到 $ a $ 的情况，另一种情况对称处理即可。

下记 $ qa,qb $ 为 $ a,b $ 的前缀和数组。

考虑相隔 $ T $ 次以外的两次移动，设计状态转移方程如下：

$$ f_{i,j}=\max\{g_{i-1,k}+qb_{j-1}-qb_{k-1}\}(k<j-T) $$

考虑把方程写成 $ f_{i,j}=\max\{g_{i-1,k}-qb_{k-1}\}+qb_{j-1} $ 的形式，可以发现 $ \max $ 里面的式子和 $ j $ 无关，外面式子和 $ k $ 无关，而 $ k $ 的范围又是一个前缀，故考虑对于 $ g_{i-1,k}-qb_{k-1} $ 维护前缀 $ \max $ 处理。

考虑相隔 $ T $ 次及以内的两次移动，设计状态转移方程，转化后如下：

$$ f_{i,j}=\max\{g_{i-1,k}-qb_{k-1}\}+qb_{j-1}+P \ (j-T \le k < j) $$

同理 $ \max $ 里面式子和 $ j $ 无关，外面式子和 $ k $ 无关，而 $ k $ 是一个以 $ j-1 $ 为右端点的定长区间，考虑单调队列优化转移即可。

注意 $ K $ 是次数上限而非必须要求，$ a,b $ 不要打反，可以 `#define int long long` 避免数据溢出，答案下界为 $ -\inf $ 而非 $ 0 $。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
const int N = 2e5 + 5;
const long long inf = 1e18 + 5;
int sid, T;
int n, k, t, p;
int a[N], b[N];
int fa[2][N];
int fb[2][N];
int qa[N];
int qb[N];
int tp[N];
struct Queue {
    int st, ed;
    int num[N];
    void init() {st = 1, ed = 0;}
    void push(int x) {num[++ed] = x;}
    void pop() {st++;}
    int front() {return num[st];}
    int back() {return num[ed];}
    bool empty() {return (st > ed);}
    void popb() {ed--;}
} que;
signed main() {
    scanf("%lld%lld", &sid, &T);
    for(int ti = 1; ti <= T; ti++) {
        scanf("%lld%lld%lld%lld", &n, &k, &t, &p);
        for(int i = 1; i <= n; i++) scanf("%lld%lld", &a[i], &b[i]);
        for(int i = 1; i <= n; i++) {
            qa[i] = qa[i - 1] + a[i];
            qb[i] = qb[i - 1] + b[i];
        }
        fa[0][1] = fb[0][1] = -inf;
        //fx[fg][i]->first i-1, change in i
        for(int i = 2; i <= n; i++) {
            fa[0][i] = qb[i - 1];
            fb[0][i] = qa[i - 1];
        }
        int fg = 0;
        int ans = max(qa[n], qb[n]);
        for(int i = 2; i <= k; i++) {
            for(int j = 1; j <= n; j++) {
                ans = max(ans, max(fa[fg][j] + qa[n] - qa[j - 1], fb[fg][j] + qb[n] - qb[j - 1]));
            }
            fg ^= 1;
            //1->fa[fg^1]->fb[fg]
            
            //1.1->fb[fg][j]=fa[fg^1][k]-qa[k-1]+qa[j-1](k<j-t)
            for(int j = 1; j <= n; j++) {
                tp[j] = fa[fg ^ 1][j] - qa[j - 1];
            }
            tp[0] = -inf;
            for(int j = 1; j <= n; j++) {
                tp[j] = max(tp[j], tp[j - 1]);
            }
            for(int j = 1; j <= n; j++) {
                if(j <= 1 + t) {
                    fb[fg][j] = -inf;
                    continue;
                }
                fb[fg][j] = tp[j - t - 1] + qa[j - 1];
            }
            que.init();
            //1.2->fb[fg][j]=tp[k]+(qa[j-1]+p) (k>=j-t)
            for(int j = 1; j <= n; j++) tp[j] = fa[fg ^ 1][j] - qa[j - 1];
            for(int j = 1; j <= n; j++) {
                while(!que.empty() && que.front() < j - t) que.pop();
                if(j >= 2 && !que.empty()) {
                    fb[fg][j] = max(fb[fg][j], tp[que.front()] + qa[j - 1] + p);
                }
                while(!que.empty() && tp[que.back()] <= tp[j]) que.popb();
                que.push(j);
            }
            //2->fb[fg^1]->fa[fg]
            //2.1->fa[fg][j]=fb[fg^1][k]-qb[k-1]+qb[j-1](k<j-t)
            for(int j = 1; j <= n; j++) {
                tp[j] = fb[fg ^ 1][j] - qb[j - 1];
            }
            tp[0] = -inf;
            for(int j = 1; j <= n; j++) {
                tp[j] = max(tp[j], tp[j - 1]);
            }
            for(int j = 1; j <= n; j++) {
                if(j <= 1 + t) {
                    fa[fg][j] = -inf;
                    continue;
                }
                fa[fg][j] = tp[j - t - 1] + qb[j - 1];
            }
            que.init();
            //2.2->fa[fg][j]=tp[k]+(qb[j-1]+p) (k>=j-t)
            for(int j = 1; j <= n; j++) tp[j] = fb[fg ^ 1][j] - qb[j - 1];
            for(int j = 1; j <= n; j++) {
                while(!que.empty() && que.front() < j - t) que.pop();
                if(j >= 2) {
                    fa[fg][j] = max(fa[fg][j], tp[que.front()] + qb[j - 1] + p);
                }
                while(!que.empty() && tp[que.back()] <= tp[j]) que.popb();
                que.push(j);
            }
        }
        for(int j = 1; j <= n; j++) {
            ans = max(ans, max(fa[fg][j] + qa[n] - qa[j - 1], fb[fg][j] + qb[n] - qb[j - 1]));
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---


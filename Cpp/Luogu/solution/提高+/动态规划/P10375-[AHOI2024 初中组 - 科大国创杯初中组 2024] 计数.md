# [AHOI2024 初中组 / 科大国创杯初中组 2024] 计数

## 题目背景

**本题的数据不是官方数据。**

**本题征集（能够上传到这里的）官方数据。**

**（没法上传到这里的）官方数据：<https://www.luogu.com.cn/training/499869>**

**本题民间数据下载：<http://8.136.99.126/blog/3/67f0c2307aadac7b413b837b>**

## 题目描述

小可可做了一个梦，梦里从左到右有 $n$ 个糖果，每种糖果有一个颜色，用 $[1, m]$ 之间的一个正整数表示。

小可可每次会选择两个颜色相同的糖果，把它们以及它们之间的所有糖果吃掉。

小可可记得，对于梦里的糖果序列，存在一种方法把所有糖果吃完。

小可可醒来后忘记了梦中的糖果序列是什么，你能帮她求求在所有 $m^n$ 个可能的糖果序列中，有多少个糖果序列可能在小可可梦中（即存在一种全部吃完的方式）吗？

由于结果可能很大，你只要求出它除以 $10^9+7$ 得到的余数即可。 

## 说明/提示

### 样例 1 解释

一共有 $4$ 个合法的糖果序列：$[1,1,1],[1,2,1],[2,1,2],[2,2,2]$。

### 数据范围

对于 $10\%$ 的数据，$n \le 6$，$m \le 4$。

对于 $20\%$ 的数据，$n \le 6$，$m \le 100$。

对于另外 $30\%$ 的数据，$n \le 50$，$m \le 2$。

对于 $70\%$ 的数据，$n,m \le 100$。

对于 $80\%$ 的数据，$n,m \le 1000$。

对于 $100\%$ 的数据，$1 \le n \le 3000$，$1 \le m \le 10^9$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
4```

## 样例 #2

### 输入

```
6 3```

### 输出

```
405```

## 样例 #3

### 输入

```
30 2```

### 输出

```
73741759```

## 样例 #4

### 输入

```
100 100```

### 输出

```
566607183```

# 题解

## 作者：NaCly_Fish (赞：14)

先来写个时间复杂度 $\Theta(n \log^2 n)$ 的做法，进一步的优化待补充。

首先我们有一个朴素的 DP 就是

$$\begin{cases} f_{i,j}=g_{i-1,j-1}(m-j+1)+f_{i-1,j}(m-j)  \\ g_{i,j}=(f_{i-1,j}+g_{i-1,j})j \end{cases}$$

有初始值 $f_{1,1}=m$，最后的答案为 $\sum_i g_{n,i}$。
****
要考虑优化的话，比较直接的想法就是按 行/列 建立生成函数。如果要按行做的话，哈哈，那你就掉沟里了。

这题比较好的做法是按列来做，设 $F_j(x)$ 是 $\{ f_{i,j} \}_{i \geq 0}$ 的生成函数，$G_j(x)$ 同理，就能得到
$$F_j(x)=(m-j+1)x G_{j-1}(x)+(m-j)x F_j(x)$$
$$G_j(x)=jx (F_j(x)+G_j(x))$$
最终答案只和 $g$ 有关，所以也只用关注 $G_j(x)$ 的递推：

$$G_j(x)=\frac{j(m-j+1)x^2}{(1-jx)(1-(m-j)x)}G_{j-1}(x)$$
其中 $G_0(x)=1$，而答案就是
$$[x^n]\sum_{i \geq 1}G_i(x)=[x^n]\sum_{i = 1}^{\lfloor n/2 \rfloor} \prod_{j=1}^i \frac{j(m-j+1)}{(1-jx)(1-(m-j)x)}x^2$$
这个东西显然可以分治来计算。设 $P_j=G_j(x)/G_{j-1}(x)$，简单来说我们维护
$$S(l,r)=\sum_{i=l}^r \prod_{j=l}^i P_j$$
然后就能根据下式来分治计算： 
$$S(l,r)=S(l,\text{mid})+S(\text{mid}+1,r)\prod_{i=l}^{\text{mid}}P_i$$


注意将幂级数表示为分式的形式，这样分子和分母的度数都是 $\Theta(r-l)$ 的，时间复杂度也就是

$$T(n)=2T(n/2)+\Theta(n \log n)=\Theta(n \log^2 n)$$

给个答案对 $\color{red}998244353$ 取模的代码，不想写任意模了，仅供参考。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<algorithm>
#define N 524292
#define p 998244353
#define ll long long
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int siz;
int rev[N],rt[N];

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(int i=0;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    int w = power(3,(p-1)>>siz);
    rt[lim>>1] = 1;
    for(int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(int *f,int n){
    static unsigned long long a[N];
    int x,shift = siz-__builtin_ctz(n);
    for(int i=0;i!=n;++i) a[rev[i]>>shift] = f[i];
    for(int mid=1;mid!=n;mid<<=1)
    for(int j=0;j!=n;j+=(mid<<1))
    for(int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(int i=0;i!=n;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n);
    int x = p-(p-1)/n;
    for(int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

inline void _inv(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        dft(g,lim),dft(h,lim);
        for(int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

struct poly{
    vector<int> a;
    inline int operator [] (const int& x) const{ return x<a.size()?a[x]:0; }
    inline int& operator [] (const int& x){ return a[x]; }
    inline int deg() const{ return a.size()-1; }
	inline void resize(int n){ a.resize(n+1); }

	inline poly inverse(){
        static int f[N];
        int n = a.size()-1;
        for(int i=0;i<=n;++i) f[i] = a[i];
        _inv(f,n,f);
        poly res;
        res.resize(n);
        memcpy(res.a.begin().base(),f,(n+1)<<2);
        return res;
    }
};
inline bool operator < (const poly& f,const poly& g){ return f.deg() > g.deg(); }

inline poly operator * (const poly& f,const poly& g){
    static int A[N],B[N];
    int n = f.deg(),m = g.deg();
	poly res;
	res.resize(n+m);
	if(n<=4||m<=4){
		for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j)
			res[i+j] = (res[i+j] + (ll)f[i]*g[j])%p;
	}else{
		memcpy(A,f.a.begin().base(),(n+1)<<2),memcpy(B,g.a.begin().base(),(m+1)<<2);
		int lim = 1<<(32-__builtin_clz(n+m));
		memset(A+n+1,0,(lim-n)<<2),memset(B+m+1,0,(lim-m)<<2);
		dft(A,lim),dft(B,lim);
		for(int i=0;i!=lim;++i) A[i] = (ll)A[i]*B[i]%p;
		idft(A,lim);
		memcpy(res.a.begin().base(),A,(n+m+1)<<2);
	}
    return res;
}

inline poly operator + (const poly& f,const poly& g){
	int n = max(f.deg(),g.deg());
	poly res;
	res.resize(n);
	for(int i=0;i<=n;++i) res[i] = (f[i]+g[i])%p;
	return res;
}

int pd[N];
int n,m;

void prod(int l,int r,int u){
	if(l==r){
		pd[u] = (ll)l*(m-l+1+p)%p;
		return;
	}
	int mid = (l+r)/2;
	prod(l,mid,u<<1);
	prod(mid+1,r,u<<1|1);
	pd[u] = (ll)pd[u<<1]*pd[u<<1|1]%p;
}

pair<poly,poly> solve(int l,int r,int u){
	if(l==r){
		poly P,Q;
		P.resize(2), Q.resize(2);
		P[0] = P[1] = 0, P[2] = (ll)l*(m-l+1+p)%p;
		Q[0] = 1, Q[1] = p-m, Q[2] = (ll)l*(m-l+p)%p;
		return make_pair(P,Q);
	}
	int mid = (l+r)/2;
	pair<poly,poly> L = solve(l,mid,u<<1);
	pair<poly,poly> R = solve(mid+1,r,u<<1|1);
	L.first = L.first * R.second;
	L.second = L.second * R.second;
	for(int i=0;i<=R.first.deg();++i) R.first[i] = (ll)R.first[i]*pd[u<<1]%p;
	int k = (mid-l+1)*2;
	R.first.resize(R.first.deg() + k);
	for(int i=R.first.deg();i>=k;--i) R.first[i] = R.first[i-k];
	for(int i=k-1;i>=0;--i) R.first[i] = 0;
	return make_pair(L.first + R.first, L.second);
}

int main(){
	scanf("%d%d",&n,&m);
    m %= p;
	init(n*2);
	prod(1,n/2,1);
	pair<poly,poly> res = solve(1,n/2,1);
	poly f = res.first, g = res.second;
	f = f * g.inverse();
	printf("%d",f[n]);
	return 0;
}
```

---

## 作者：AHOI_Capzera (赞：8)

### 分析

通过对题目的分析，不难想到，如果一个串的首尾完全一样，那么一定可以消除。形如：

```cpp
a...a         a....b...c...a
```

当一个串首尾不同，但是可以进行多组分块，也可以完成消除。形如：

```cpp
a...ab....bc....cz...z
```

对于一个不能完成消除的串来说，我们可以选择增补数字使得它变成可以消除的串。形如：

```cpp
a...ab...bc...
```
只需在末尾增补 `a`，`b` 或 `c` 就可以使得上述情况变成可以消除的串。

所以，我们设 $f_{i,j,k}$ 表示前 $i$ 个元素，分成 $j$ 组，可以（$k = 1$）或不可以（$k = 0$）完成消除的方案数。

其中，我们认为形如 `a...ab` 这样的串为 $2$ 组，虽然 `b` 不能完成匹配。

### 边界

考虑 $dp$ 边界为只有 $1$ 个元素，分组为 $1$，一定是不能完成消除的情况，该情况共有 $m$ 种，分别是：

```cpp
1, 2, ..., m
```

即 $f_{1,1,0} = m$。

### 答案

考虑答案为使用 $n$ 个元素，不确定被分为几组，但是可以完成消除的方案数。

即输出为 $ans = \sum \limits_{i = 1}^{n} f_{n,i,1}$。

### 转移方程

考虑转移方程：

1. 一组可以完成消除的串 `a...a`，增补上先前没有出现的元素，可以使得组数多 $1$，变为 `a...ab`，共计 $m - j$ 种情况。

2. 不管原本是否是可以消除的串，在末尾增补上分组中含有的元素，可以使得它变为一个可以消除的串。`a...ab...` 在末尾新增 `a` 或 `b`；`a...ab...bc...c` 在末尾新增 `a`，`b` 或 `c` 可以使得串变为可以消除，共计 $j$ 种情况。

3. 原本不能完成消除的串，增补上分组中未出现的元素，仍然使得它无法完成消除。`a...ab...`，增补上 `c`，共计 $m - j$ 种情况。

所以我们可以写出转移方程为：
$$
\begin{cases}
f_{i,j+1,0}=f_{i-1,j,1}\times (m-j) \\

f_{i,j,1}=(f_{i-1,j,1} + f_{i-1,j,0}) \times j\\

f_{i,j,0}=f_{i-1,j,0}\times (m-j)
\end{cases}
$$

### 代码块

其中，使用 $i$ 个元素时，最多被分为 $i$ 组，所以第二层循环应该是 $j \le i$。我们可以写出代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, mod = 1e9 + 7;
long long f[3001][3001][2], ans;
int main() {
	cin >> n >> m;
	f[1][1][0] = m;
	for (int i = 2; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			f[i][j + 1][0] = (f[i][j + 1][0] + f[i - 1][j][1] * (m - j)) % mod;
			f[i][j][1] = ((f[i][j][1] + f[i - 1][j][0] + f[i - 1][j][1]) % mod * j) % mod;
			f[i][j][0] = (f[i][j][0] + f[i - 1][j][0] * (m - j)) % mod;
		} 
	}
	for (int i = 1; i <= n; i++) ans = (ans + f[n][i][1]) % mod;
	cout << ans;
	return 0;
}
```

时间复杂度：$O(n^2)$。

空间复杂度：$O(n^2)$。

### 优化

我们发现 $f_i$ 仅与 $f_{i-1}$ 有关，可以将原数组进行滚动操作，又发现 $f_{j+1}$ 与 $f_j$ 有关，所以顺序循环会导致当前这一层的值发生重复计算，所以对第二层循环可以采取逆序操作(例如0-1背包的转移方程优化)。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, mod = 1e9 + 7;
long long ans, f[3001][2];
int main() {
	cin >> n >> m;
	f[1][0] = m;
	for (int i = 2; i <= n; i++) {
		for (int j = i; j > 0; j--) {
			f[j + 1][0] = (f[j + 1][0] + f[j][1] * (m - j)) % mod;
			f[j][1] = ((f[j][1] + f[j][0]) * j) % mod;
			f[j][0] = (f[j][0] * (m - j)) % mod;
		} 
	}
	for (int i = 1; i <= n; i++) ans = (ans + f[i][1]) % mod;
	cout << ans;
	return 0;
}
```

时间复杂度：$O(n^2)$。

空间复杂度：$O(n)$。

---

## 作者：封禁用户 (赞：8)

*双倍经验：[P8386](/problem/P8386)。*

很明显，（只有）以下序列是合法的：

- 形如 `s**...**s` 的序列（即首尾项相等的序列），一次即可删除；
- 由多个合法的短序列拼接而成的长序列，每次删除一个短序列即可。

因此，所有合法的序列都长这样：

```plain
a**...**ab**...**bc**...**c......z**...**z
```

------------

现在，假设我们有以下的序列：

```plain
a**...**ab**...**bc**...**c......z**...**
```

考虑一下，如果在它末尾添加一项，如何才能让它合法：

- 添加 `a` 后显然合法；
- 添加 `b` 后可以分两次删除 `a...a` 和 `b...b`，合法；
- 添加 `c` 后可以分三次删除 `a...a`、`b...b` 和 `c...c`，合法；
- ……

综上所述，（只有）添加 `abc...z` 中的某一个才能让它合法。

观察发现：

- 第一个 `a` 前没有项，合法；
- 第一个 `b` 前是 `a...a`，合法；
- 第一个 `c` 前是 `a...ab...b`，合法；
- ……

**也就是说，对于某项 `s`（可以在任意位置，不要求第一次出现），如果它前面的序列（前缀）合法，那么可以保证：只要在序列末尾再添加一个 `s`，就可以使整个序列合法。**

------------

那么可以 DP 了：设 $g_{i,j,0/1}$ 表示长度为 $i$，满足以上条件的项的种数（不是个数）为 $j$ 的不合法 / 合法序列个数。

```plain
           Original sequence:     aabacebacdecdbe*****...
     Whether prefix is valid:  (1)010100111001110*****...
         Positions after 1's:     ^ ^ ^  ^^^  ^^^*****...
  Terms extracted from those:     a b c  acd  dbe*****...

  O(n^2) DP: g[length][extracted-unique-count][last]
  -> length = 15
  -> extracted-unique-count = 5
  -> last = 0
```

至于转移，按照「在末尾添加一项」的思想列出方程即可。

最终的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$ 或 $O(n)$。

**AC Code：**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;
long long g[3012][3012][2];
int main()
{
	int n,m;
	cin>>n>>m;
	memset(g,0,sizeof g);
	g[1][1][0]=m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			if(g[i][j][0])
			{
				g[i+1][j][0]+=g[i][j][0]*(m-j);
				g[i+1][j][0]%=P;
				g[i+1][j][1]+=g[i][j][0]*j;
				g[i+1][j][1]%=P;
			}
			if(g[i][j][1])
			{
				g[i+1][j][1]+=g[i][j][1]*j;
				g[i+1][j][1]%=P;
				g[i+1][j+1][0]+=g[i][j][1]*(m-j);
				g[i+1][j+1][0]%=P;
			}
		}
	long long ans=0;
	for(int i=1;i<=n;i++)
		ans+=g[n][i][1],ans%=P;
	cout<<ans;
	return 0;
}
```

---

## 作者：是青白呀 (赞：4)

首先考虑如何判定一个序列是合法的。

第一反应或许是贪心。但是能删就删，和尽可能往远处删的策略都能够容易举出反例。

那么考虑 dp 判定。区间 dp 的方式复杂度会爆炸且不便于优化，于是考虑直接从左往右按顺序 dp，设 $f_i$ 表示以 $i$ 结尾的前缀是否能删完。转移可以找到与 $a_i$ 值相同的位置 $j$，判断 $f_{j-1}$ 是否为 $1$ 即可。

在外层套计数，则需要考虑 dp 套 dp 类似物。你发现我们不关心前面究竟哪个位置是 $1$，只关心对于某个值 $v$，是否存在一个位置 $j$ 使得 $a_j=v$ 且 $f_{j-1}=1$。于是可以设 $f_{i,j,0/1}$ 表示考虑到第 $i$ 个位置，前面有 $j$ 个值满足上述条件，且当前序列是（或不是）合法序列的方案数。转移时讨论当前位置填的是不是 $j$ 个数之中的一个、以及转移来的序列是否合法即可。

第二维显然不超过序列长度，故复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=3002,M=1e6+5,S=(1<<20)+5,inf=2e9+7,mo=1e9+7,base=620071201;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m;
int dp[N][N][2];
signed main(){
    read(n),read(m);
    dp[0][0][1]=1;
    rep(i,1,n){
        rep(j,0,min(n,m)){
            if(j)dp[i][j][0]+=dp[i-1][j-1][1]*(m-j+1)%mo,dp[i][j][0]%=mo;
            dp[i][j][0]+=dp[i-1][j][0]*(m-j)%mo,dp[i][j][0]%=mo;
            dp[i][j][1]=(dp[i-1][j][0]+dp[i-1][j][1])*j%mo;
        }
    }
    int ans=0;
    rep(i,1,min(n,m))
        ans+=dp[n][i][1],ans%=mo;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：littlebug (赞：3)

## Solution

双倍经验：P8386。

一个 dp，但是还是想不到。/ll

考虑到若一个序列合法，一定形如 `a...ab...b......z...z`，于是考虑按照每个 `a...a` 的块计数，但是发现一点都不对。

但是我们注意力惊人，可以发现对于一个 `a`，如果把她拼到一个 **包含 `a`** 且 **原有的 `a` 前面的前缀合法** 的序列后面，那么所构成的序列也是合法的，考虑分成两块消掉即可。

于是这样 dp 就好了，设 $f_{i,j}$ 为长度为 $i$，后面接 $j$ 种字符可以构成合法序列的方案数。但是呢，在我们尝试转移的时候，发现会漏算 拼上一个不合法字符再拼上一个合法字符 的这种方案，于是再加一维状态，加一个 $0/1$ 表示当前是否合法，然后就可以转移了。转移分讨当前是否合法与加的字符是否合法即可，有式子：

$$
\begin{aligned}
f_{i,j,1} \times j & \to f_{i+1,j,1} \\
f_{i,j,1} \times (m-j) & \to f_{i+1,j+1,0} \\
f_{i,j,0} \times j & \to f_{i+1,j,1} \\
f_{i,j,0} \times (m-j) & \to f_{i+1,j,0}
\end{aligned}
$$

答案显然为 $\sum f_{n,j,1}$。

正确性显然，因为显然这个东西可以涵盖所有情况。

复杂度 $O(n^2)$。

## Code

```cpp
int n,m,f[MAXN][MAXN][2];

signed main()
{
    read(n,m);

    f[0][0][1]=1;
    rep(i,0,n-1) rep(j,0,i)
    {
        add(f[i+1][j][1],f[i][j][1]*j%mod);
        add(f[i+1][j][1],f[i][j][0]*j%mod);
        add(f[i+1][j+1][0],f[i][j][1]*(m-j)%mod);
        add(f[i+1][j][0],f[i][j][0]*(m-j)%mod);
    }

    int ans=0;
    rep(i,0,n) add(ans,f[n][i][1]);
    write(ans,'\n');

    return 0;
}
```

---

华风夏韵，洛水天依！

---

## 作者：iranai (赞：3)

# 思路
首先，看完题面，很容易就能想到 DP，~~但本蒟蒻就是想不出来~~。观摩了各位大佬的题解后，终于能够理解三维 DP 的做法了。

首先要先明确怎样的序列才是合法的。不难想到，一个序列合法，当且仅当这个序列以以下方式表示:

```
a....a
```
或

```
a....ab....bc....c(...)z....z
```
对于第一种情况，并不需要过多解释，可以一次消完。

对于第二种情况，可以通过一次一次进行局部的消除从而消除整体。

实际上，第一种情况也可以被包含在第二种情况内，是一种特殊情况。

那么我们该如何 DP 呢？

为了方便叙述，后文我将以“合法字串”来称呼 ```a....a``` 这样的串。

可以发现，对于一个串 ```a....ab....b```，我们在它后面添加一个不是 ```a``` 也不是 ```b``` 的字符，那它就是不合法的了。而如果添加一个 ```a``` 或 ```b```，它就依然是合法的。

而对于 ```a....ab``` 这样的串，我们在它后面添加一个不是 ```a``` 也不是 ```b``` 的字符，它依然是不合法的。而如果添加一个 ```a``` 或 ```b```，它就是合法的了。

由此，状态转移方程就自然而然地显现出来了。

设 $dp_{i,j,0/1}$ 表示在考虑前 $i$ 个字符、有 $j$ 组合法子串（如果该串不合法，那此处的 $j$ 表示的应该是有 $j - 1$ 组合法字串和剩下的 $1$ 组不合法字串）的情况下，且该串是不合法/合法字串，得到该形式的串有多少种情况。

那就可以通过刚才的推理得到：

$dp_{i+1,j,0}=dp_{i,j,0}\times(m-j)$

$dp_{i+1,j+1,0}=dp_{i,j,1}\times(m-j)$

$dp_{i+1,j,1}=dp_{i,j,0}\times j+dp_{i,j,1}\times j$

得到了状态转移方程，就可以直接敲代码了！

# 代码

```
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int mod=1e9+7;
int n,m;
LL dp[3010][3010][2]; 
LL ans;
int main(){
	cin>>n>>m;
	dp[1][1][0]=m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			dp[i+1][j][1]=(dp[i+1][j][1]+dp[i][j][0]*j+dp[i][j][1]*j)%mod;
			dp[i+1][j][0]=(dp[i+1][j][0]+dp[i][j][0]*(m-j))%mod;
			dp[i+1][j+1][0]=(dp[i+1][j+1][0]+dp[i][j][1]*(m-j))%mod;
		}
	}
	for(int i=1;i<=n;i++) ans=(ans+dp[n][i][1])%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：__yhz (赞：2)

双倍经验：[P8386](https://www.luogu.com.cn/problem/P8386)

考虑若给定一个序列 $a$，如何判断它是否满足条件：

显然删除的区间不会有交，若有交则可以只删去更大的区间。

考虑 DP。$f_i$ 表示区间 $[1,i]$ 的数是否可以删除，且$f_0=1$。则 $f_i=1$ 当且仅当存在 $j$ 满足 $1\le j<i$ 且 $f_{j-1}=1,a_j=a_i$。

对于计数的部分，也考虑 DP。设 $g_{i,j,0/1}$ 代表已经放了 $i$ 个数，后面可以放 $j$ 种数使得序列合法，$f_i=0/1$。

初始状态 $g_{1,1,0}=m$。

考虑放第 $i+1$ 个位置：
- 放一个能与前面匹配的数：$(g_{i,j,0}+g_{i,j,1})\times j\rightarrow g_{i+1,j,1}$

- 放一个不能与前面匹配的数：$g_{i,j,0}\times (m-j)\rightarrow g_{i+1,j,0},\quad g_{i,j,1}\times (m-j)\rightarrow g_{i+1,\red{j+1},0}$（这里 $j+1$ 是因为增加了一个 $f$ 的可以转移的位置）

答案是 $\sum\limits_{i=1}^n g_{n,i,1}$。

因为 $j\le i\le n$，时间复杂度 $O(n^2)$。
```cpp
#include <bits/stdc++.h>
#define ll long long
#define F(i,l,r) for(ll i=l;i<=r;i++)
using namespace std;
const ll _ = 1e9 + 7;
ll n, m, g[3005][3005][2], ans;
int main() {
    cin >> n >> m;
    g[1][1][0] = m;
    F(i, 1, n)F(j, 1, i) {
        (g[i + 1][j][1] += (g[i][j][0] + g[i][j][1]) * j) %= _;
        (g[i + 1][j][0] += g[i][j][0] * (m - j)) %= _;
        (g[i + 1][j + 1][0] += g[i][j][1] * (m - j)) %= _;
    }
    F(i, 1, n)(ans += g[n][i][1]) %= _;
    cout << ans;
    return 0;
}
```

---

## 作者：仙肉粽子 (赞：2)

# 题解：P10375 [AHOI2024 初中组] 计数

双倍经验：[P8386](https://www.luogu.com.cn/problem/P8386)

## 闲谈

作者太菜了，花了 3h 只切了 T1,2,3，然后干了 1h 喜得 10pts，现在才开始老老实实补做。

## 思考

### 10pts：暴力最光荣！

超普通的 dfs 套 dfs，应该不用说了。

```cpp
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define ull unsigned ll
#define inf 0x7f7f7f7f
#define ll long long
using namespace std;
const ll mod = 1e9 + 7;
ll n,m,ans,a[3010];
bool check(ll x,ll s){
	if(x > n) return 0;
	if(x == n) return s == a[n];
	bool f = 0;
	if(a[x] == s){
		f |= check(x + 1,s);
		f |= check(x + 2,a[x + 1]);
	}else f |= check(x + 1,s);
	return f;
}
void dfs(ll x){
	if(x > n){
		ans += check(2,a[1]);
		return ;
	}
	ll i;
	rep(i,1,m,1){
		a[x] = i;
		dfs(x + 1);
	}
}
int main(){
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    //freopen("d.in","r",stdin);
    //freopen("d.out","w",stdout);
	cin>>n>>m;
	dfs(1);
	cout<<ans;
    return 0;
}
```

### 20 至 30pts：暴力之花！

暴力还是要玩点技巧的，~~但是我不会玩~~。

因为小可可每次会选择两个颜色相同的糖果，把它们以及它们之间的所有糖果吃掉。所以只要串符合 `x......x` 就可以被吃掉，拼接起来也可以，记录哪里到哪里是符合这样的串，让这些串拼在一起，在最后乘上 $m^x$ 就行了。

~~代码就不放（xie）了。~~

### 100pts：正解！

现在是正（wai）经（men）推（xie）导（dao）过程！

显然 `x......x` 是符合的串，然后我们假设存在如下串：

``
x1...x1x2...x2x3...x3......xn...xn
``

显然，这个串合法，而且所有合法串都是如此。

我们假设有如下串：

``
x1...x1x2...x2x3...x3......xn...
``

1. 在末尾添加 $x_1$，可以吃完。

2. 在末尾添加 $x_2$，先吃 `x1...x1`，然后就可以吃完。

3. 在末尾添加 $x_3$，先吃 `x1...x1`，再吃 `x2...x2`，然后就可以吃完。

4. 省略一下

5. 在末尾添加 $x_n$，先吃 `x1...x1`，再吃 `x2...x2` ……，再吃 `xn-1...xn-1`，然后就可以吃完。

所以，我们证明，只要在末尾添加 $x_1$ 到 $x_n$ 任意一个，就可以使得这个串变得合法。

设 ${dp}_{i,j,0/1}$，$i$ 代表有多长，$j$ 代表上面的 $x_n$ 的 $n$，$0/1$ 代表是否是合法串。

那么，我们就可以得出如下公式：

$$
{dp}_{i,j,0} = {dp}_{i - 1,j,0} \times ( m - j ) + {dp}_{i - 1,j - 1,1} \times ( m - j + 1 )\\

{dp}_{i,j,1} = {dp}_{i - 1,j,0} \times j + {dp}_{i - 1,j,1} \times j
$$

那么，我们就可以亮出那~~无敌的，勇敢的，性感的，神秘的，迷人的，神气的，勤勉的，强势的，华丽的，激情的，可怕的，漂亮的，强大的灰色王子左特~~代码了！

```cpp
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define ull unsigned ll
#define INF 0x7f7f7f7f
#define ll long long
using namespace std;
const int P = 1e9 + 7;
int n,m,ans,dp[3010][3010][2];
int main(){
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#ifdef ONLINE_JUDGE
#else
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    cin>>n>>m;
    int i,j;
    dp[1][1][0] = m;
    rep(i,1,n,1) rep(j,1,i,1){
        dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][0] * (m - j)) % P;
        dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j - 1][1] * (m - j + 1)) % P;
        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][0] * j) % P;
        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1] * j) % P;
    }
    rep(i,1,n,1) ans = (ans + dp[n][i][0]) % P;
    cout<<ans;
    return 0;
}
```

---

## 作者：qiyichen12 (赞：2)

# 分析
第一眼看到此题就知道是 dp 题，考虑建立 dp 数组。因为求种类数，自然设 $dp_i$ 为 $i$ 个糖果的可吃种类。

仔细分析会发现，$dp_{i+1}$ 不仅与 $dp_i$ 有关还和前面序列的状况有关。~毕竟蓝题的 dp 怎么可能只有一维呢。~

手“吃”几次会发现只要前方有一段“可吃序列” $[1,r]$ 则第 $i+1$ 位只要与第 $r+1$ 相同便可使序列“可吃”。

所以考虑增加一维，用 $dp_{i,j}$ 中的 $j$ 表示有几种分段可以使 $[1,r]$ “可吃”。同时因为还要考虑“不可吃”的情况，所以改用 $dtp_{i,j}$ 和 $dfp_{i,j}$ 分别描述“可吃”与“不可吃”种数。

转移代码：

```cpp
dfp[i+1][j] += dfp[i][j]*(m-j);
dtp[i+1][j] += dfp[i][j]*j；
dtp[i+1][j] += dtp[i][j]*j；
dfp[i+1][j+1] += dtp[i][j]*(m-j)；
```
因为一个长度的糖果序列永“不可吃”，所以初始 $dfp_{1,1} = m$ 。最终答案即为 $∑dtp_{n,i}$。

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(l,r,i) for(int i = l;i <= r;i++)
long long dtp[3007][3007],dfp[3007][3007];
const int mod = 1e9+7;
int main()
{
    int n,m;
    long long sum = 0;
    cin >> n >> m;
    dfp[1][1] = m;
    For(1,n-1,i) //到n-1即可，因为处理的是 i+1
    {
        For(1,i,j)
        {
            dfp[i+1][j] += dfp[i][j]*(m-j),dfp[i+1][j] %= mod;
			dtp[i+1][j] += dfp[i][j]*j,dtp[i+1][j] %= mod;
            dtp[i+1][j] += dtp[i][j]*j,dtp[i+1][j] %= mod;
            dfp[i+1][j+1] += dtp[i][j]*(m-j),dfp[i+1][j+1] %= mod;
        }
    }
    For(1,n,i) sum += dtp[n][i],sum %= mod;
    cout << int(sum % mod);
}
```

---

## 作者：Kingna (赞：2)

考虑一个可删除区间包含另一个小的可删除区间，那么只保留最大的。而且一个区间如果可删除，一定满足 `a....ab....b....z.....z` 的形式。

考虑一个数加入但是无效的情况：`a.....ab`，此时如果加入 $c$，想要可删除，则必须加入 $a$ 或 $b$，则意味着 $c$ 被覆盖了。此时情况可以概括为：原序列不能被删除，然后加入了一个不能使原序列被删除的字符。

则可以定义 dp 为 $f_{i,j,k}$ 表示前 $i$ 个字符，可以加入 $j$ 个字符使得序列可以完全删除，$k=0/1$ 表示当前是否能够删除。

则转移有：

* $f_{i+1,j,1}=f_{i,j,1}\times j$
* $f_{i+1,j+1,0}=f_{i,j,1}\times (m-j)$
* $f_{i+1,j,1}=f_{i,j,0}\times j$
* $f_{i+1,j,0}=f_{i,j,0}\times (m-j)$。此情况就是加入但无效果。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 3005, mod = 1e9 + 7;
int n, m, f[N][N][2], res;

signed main() {
	cin >> n >> m;
	f[0][0][1] = 1;
	_for(i, 0, n - 1) {
		_for(j, 0, i) {
			f[i + 1][j][1] = (f[i + 1][j][1] + f[i][j][1] * j % mod) % mod;
			f[i + 1][j + 1][0] = (f[i + 1][j + 1][0] + f[i][j][1] * (m - j) % mod) % mod;
			f[i + 1][j][1] = (f[i + 1][j][1] + f[i][j][0] * j % mod) % mod;
			f[i + 1][j][0] = (f[i + 1][j][0] + f[i][j][0] * (m - j) % mod) % mod;
		}
	}
	_for(i, 0, n) res = (res + f[n][i][1]) % mod;
	cout << res << endl; 
}
```

---

## 作者：luckyqwq (赞：1)

# P10375 [AHOI2024 初中组] 计数 题解

### 大致思路：

首先，我们总会感觉这道题目是一道贪心题，遇到能删的立马删，但这种方法很容易找到反例，这类型的题如果不是贪心，那么 $80 \%$ 就是 dp 了。

我们考虑如何设计状态，感觉这道题无法设计合适的状态，那么我们考虑形如怎样的串是合法的，我们会发现 $a...a$ 这样一种给很特殊的串，我们发现只需要构造不同数量的这种串即可，那么转移状态就显现出来了，我们设 $dp_{i, j, 0/1}$ 为长度为 $i$ 的序列，有 $j$ 个形如 $a...a$ 的串，整个不合法/合法的方案数，转移方程也非常明显，因为我们知道如果一个串初始为 $q...qw...wx...x$ 接下来一位中，你可以添加 $q, w, x$ 中的一个来让序列合法，所以要考虑到之前放过的 $j$ 个数下一次放的时候，是否放在最后一个位置，分类讨论即可。

这样这道题目就完成啦！！！

---

## 作者：Soh_paramEEMS (赞：0)

## 题意

给定 $n$，$m$，求满足以下限制的长度为 $n$ 的序列数目：

1. 每个元素在 $[1,m]$ 之间；
2. 一次操作定义为删除一个长度至少为 $2$ 且区间两端相等的区间，该序列需要在若干次操作内被删空。

答案对 $10^9+7$ 取模。

$1 \le n \le 3000$，$1 \le m \le 10^9$。
## 思路
容易发现一个性质：对于一个序列 $S$，在后面加入 $x$，那么 $S$ 中第一次出现 $x$ 的位置直到末尾添加的 $x$ 都会被删去。

我们考虑对 $1\sim n$ 每一位填数字，我们发现填的数字是什么其实并不重要，因为我们要求的是序列数目而不是具体的序列种类。**我们需要知道的是有多少种 $x$ 可以被添加到末尾**。

根据上面的性质，我们可以知道一个可以被全部删除的序列长什么样子（下文称为合法的）：可以是首尾数字相同的序列 $S_0$，也可以是很多个不同的 $S_0$ 拼接而成的 $S$，它们都是合法的。

那我们考虑维护合法的和不合法的状态（不合法状态可以转移到合法的）。设 $f_{i,j,op}$ 表示前 $i$ 个数，出现了“有效的”数 $j$ 种，当前序列状态为 $op$ 的方案数：
- $op=0$ 表示该序列不合法，需要添加一个 $x$ 使之合法；
- $op=1$ 表示该序列合法。

有效的是什么意思？是指后面可以添加的 $x$ 是这 $j$ 种数的一个，使之变成合法的序列（在这里要搞清楚这个定义，后面有一个状态转移和这个强相关才能理解）。

初始时当然是 $f_{1,1,0}=m$，可以填 $m$ 种数中的一个。

考虑转移：枚举当前数列长度 $i$ 和数的种类数 $j\le\min(i,m)$，此处考虑向后转移。

对于 $f_{i+1,j,1}$，可以从前 $i$ 个不合法的转移过来，填 $j$ 种数中的一个；合法亦然。有效数的量不变：
$$\begin{matrix}
f_{i+1,j,1}\leftarrow f_{i,j,1}\times j\\ 
f_{i+1,j,1}\leftarrow f_{i,j,0}\times j
\end{matrix}$$

对于前 $i+1$ 个不合法的，可以是前 $i$ 个合法的，添加一个 $j$ 种数之外的数 $m-j$ 种，那么这个前 $i+1$ 个不合法的序列的有效数有 $j+1$ 个了：
$$f_{i+1,j+1,0}\leftarrow f_{i,j,1}\times(m-j)$$

也可以是前 $i$ 个不合法的转移过去，为了使这个长度为 $i+1$ 的序列不合法，我们也要添加 $j$ 种数之外的数 $x'$，可以有 $m-j$ 种。但是现在这个这个长度为 $i+1$ 的不合法序列的有效颜色有多少呢？

我们发现这个 $x'$ 不属于前 $i$ 个的 $j$ 种的任意一个，如果在这个这个长度为 $i+1$ 的不合法序列后面再添加一个 $x'$，是**不能将其变成合法的**。
![](https://cdn.luogu.com.cn/upload/image_hosting/m3fijyui.png)
因此有效数的种数并非 $j+1$，而是 $j$。

最后答案就是 $\displaystyle\sum_{i=1}^{m}f_{n,i,1}$。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=3002,mod=1e9+7;
ll n,m;
ll f[N][N][2];
//前i个，出现了j种数，后面可以加j种颜色中的一个使之合法
//当前序列，0不合法1合法，的方案数 
//后面加的什么颜色不重要 
int main()
{
	scanf("%lld%lld",&n,&m);
	f[1][1][0]=m;
	for(ll i=1;i<n;i++)
	{
		for(int j=1;j<=min(i,m);j++)
		{
			f[i+1][j][1]=(f[i+1][j][1]+f[i][j][0]*j%mod)%mod;
			//后面加已经有的j种颜色 
			f[i+1][j][1]=(f[i+1][j][1]+f[i][j][1]*j%mod)%mod;
			//后面加已经有的j种颜色 
			f[i+1][j+1][0]=(f[i+1][j+1][0]+f[i][j][1]*(m-j)%mod)%mod;
			//后面加还没有的m-j种颜色 
			f[i+1][j][0]=(f[i+1][j][0]+f[i][j][0]*(m-j)%mod)%mod;
			//后面加还没有的m-j种颜色，不合法
			//但是在后面直接加这个新加的颜色，整段还是不合法
			//因此在后面只能加原来的j种颜色 
		}
	}
	ll ans=0;
	for(int i=1;i<=m;i++)
	ans=(ans+f[n][i][1])%mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Like_Amao (赞：0)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P10375)

[双倍经验](https://www.luogu.com.cn/problem/P8386)

**思路**

不难发现，只有这种序列是合法的：

* 首尾项相同的序列，一次就可以删掉；
* 由多个短序列组成的长序列，删掉短序列就可以了。

假设存在一个这样的序列：



$a \cdots ab \cdots bc \cdots c \cdots$ （此处省略 $d$ 到 $y$ 的部分） $z \cdots$

稍作思考，以下几种方式可以让此序列合法：

* 直接在末尾添加 $a$ 后合法；
* 首先在末尾添加 $b$，然后分两次删掉 $a \cdots a$ 和 $b \cdots b$ 后合法；
* 首先在末尾添加 $c$，然后分三次次删掉 $a \cdots a$ 和 $b \cdots b$ 和 $c \cdots c$ 后合法；
* $\cdots$ （此处省略在序列末尾添加 $d$ 到 $z$ 保持合法的做法）。

仔细观察，发现：

* 当第一个 $a$ 无前项；
* 当第一个 $b$ 的前项是 $a \cdots a$；
* 当第一个 $c$ 的前项是 $a \cdots a$ 和 $b...b$；
* $ \cdots $（此处省略当第一个 $d$ 到 $z$ 的前项）。

因此，我们可以得到次结论：对于序列中任何一个字母，如果它的前项合法，那么只要在整个序列末尾再添加一个与此字母相同的字母，就可以使整个序列合法。

知道这些后，我们就可以使用动态规划来做这一道题目了。

**代码**


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[3001][3001][2];
signed main()
{
	int n,m,ans=0;
	cin>>n>>m;
	dp[1][1][0]=m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(dp[i][j][0])
			{
				dp[i+1][j][0]+=dp[i][j][0]%1000000007*(m-j)%1000000007;
				dp[i+1][j][0]%=1000000007;
				dp[i+1][j][1]+=dp[i][j][0]%1000000007*j%1000000007;
				dp[i+1][j][1]%=1000000007;
			}
			if(dp[i][j][1])
			{
				dp[i+1][j][1]+=dp[i][j][1]%1000000007*j%1000000007;
				dp[i+1][j][1]%=1000000007;
				dp[i+1][j+1][0]+=dp[i][j][1]%1000000007*(m-j)%1000000007;
				dp[i+1][j+1][0]%=1000000007;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans+=dp[n][i][1]%1000000007;
		ans%=1000000007;
	}
	cout<<ans;
	return 0;
}
```

---


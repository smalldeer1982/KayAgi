# 【MX-S2-T3】 跳

## 题目背景

原题链接：<https://oier.team/problems/S2C>。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/kq7nqgu8.png)

~~跳一跳世界第一。~~

~~不处，不收徒，差距自己找。~~

## 题目描述

给定一个坐标轴，范围是 $1\sim n$。每个点 $i$ 可以跳到 $i+1$（$i+1\le n$）或 $i-1$（$i-1\ge 1$）或他的因子处。每个点只能到达一次。问从点 $n$ 到点 $1$ 一共有多少方案。答案对 $p$ 取模。

两种方案不同当且仅当存在一次跳跃后的位置不同或存在一次跳跃的种类不同。

## 说明/提示

**【样例解释 \#1】**

设 $\rightarrow$ 表示向上或向下跳，$\Rightarrow$ 表示跳因子。共三种方案如下。
+ $3\Rightarrow1$
+ $3\rightarrow2\rightarrow1$
+ $3\rightarrow2\Rightarrow1$

**【样例解释 \#2】**

设 $\rightarrow$ 表示向上或向下跳，$\Rightarrow$ 表示跳因子。共七种方案如下。

+ $4\rightarrow3\Rightarrow1$
+ $4\rightarrow3\rightarrow2\rightarrow1$
+ $4\rightarrow3\rightarrow2\Rightarrow1$
+ $4\Rightarrow2\rightarrow3\Rightarrow1$
+ $4\Rightarrow2\rightarrow1$
+ $4\Rightarrow2\Rightarrow1$
+ $4\Rightarrow1$

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（8 pts）：$n\le20$。
- Subtask 1（11 pts）：$n\le150$。
- Subtask 2（23 pts）：$n\le300$。
- Subtask 3（26 pts）：$n\le1000$。
- Subtask 4（32 pts）：无特殊限制。

对于所有测试数据，$1\le n\le5\times10^3$，$2\le p\le 10^9+7$。

## 样例 #1

### 输入

```
3 1000000007```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1000```

### 输出

```
7```

## 样例 #3

### 输入

```
100 511609```

### 输出

```
272799```

# 题解

## 作者：CQ_Alice (赞：20)

~~666 这场比赛怎么全是 DP。~~

### 题意

连续 $n$ 个下标 $1,2,3,...,n$，最开始你在下标 $n$，每次可以从 $i$ 走到 $i-1$ 和 $i+1$，或者走到 $i$ 的约数下标（这是两种不同的走法），每个下标只能走一次，问你有多少种从 $n$ 走到 $1$的走法（不能走出 $1$ 到 $n$ 的范围）。

## 思考过程

如果只有向一边走的情况，那么这个题很容易做，但是这里多出来一种向回走的情况，这就不太好考虑了。

但是我们可以发现，向回走一定是只能一格一格的走，并且一定存在于原来某次跳约数的中间未被访问的部分。

比如下图中从 $8$ 跳到 $2$（跳约数），这样的话，$3$ 到 $7$ 的下标都没有被跳过，因此完全可以考虑这个时候从 $2$ 往回一格一格跳，比如考虑跳到 $5$，那么此时所有能够跳到 $8$ 的方案，通过 $2$ 一定能够跳到 $5$，所以此时可以让 $5$ 累加上跳到 $8$ 的方案，注意不是加 $2$ 的，$2$ 中包含有其他的方案，与我们现在讨论的不一致。

![](https://cdn.luogu.com.cn/upload/image_hosting/8f7x0tr3.png)

但是直接加上 $8$ 的就好了吗？实际上还存在一类问题。

绿色和红色是曾今走到 $8$ 的一种决策，这一决策经过了 $5$，而如今我们在对 $5$ 进行决策时，却没有考虑到 $5$ 已经被先前的某些方案所覆盖（已经被走过了），所以我们必须记录一下，点 $i$ 是从前面哪个点往后走到的，比如这里 $8$ 是从 $5$ 走到的，所以后来我们在考虑蓝色路径时（对 $5$ 的决策），只能让 $5$ 累加上从 $6,7$ 走到 $8$（这个东西就是个后缀和嘛），或者从 $8$ 后面来到 $8$ 的情况的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/0z3r7ehp.png)

所以接下来思路就很明确了：

定义状态 $f_{i,j}$ 表示从 $j,j+1,j+2,...,i$ 向后走走到的 $i$ 的方案数，这里我为了好统计，将 $f_{i,i}$ 的状态特殊定义为从 $i$ 后面走到 $i$ 的方案数。

对于向前一格的情况：$f_{i,i}=f_{i,i}+f_{i+1,i+1}$

对于从 $l$ 跳约数来到 $i$ 的情况：$f_{i,i}=f_{i,i}+f_{l,i+1}$（$i$ 是 $l$ 的约数）

### 接下来着重看一下往回跳的情况

下面是 $i=2$ 的情况，我们考虑 $j$ 通过约数的跳法来到 $i$，此时我们在 $i+1$ 到 $j-1$ 中枚举 $k$，此时将 $k$ 累加上 $j$ 从 $k+1,k+2,k+3,...,j$ 跳过来的方案数：对于 $i+1\le k\le j-1$ 有 $f_{k,i}=f_{k,i}+f_{j,k+1}$（从后面来到 $j$ 的方案数根据定义统计在 $f_{j,j}$ 中，被正常累计在 $k$ 上）。

我们是在对第 $f_{j,i}$ 中的第二维进行后缀和，第二维就是下图中的 $i$（对于每次枚举的 $i$，只需要修改 $f_{i,i}$ 和 $f_{k,i}$），所以对于每个 $i$ 计算完后，再刷一遍 $i$ 的后缀和就好了。具体的，每次关于 $i$ 的计算结束后，枚举 $1\le k\le n$，令 $f_{k,i}=f_{k,i}+f_{k,i+1}$


![](https://cdn.luogu.com.cn/upload/image_hosting/05q7fgk2.png)

---

## 时间复杂度

第一层循环一个 $i$，第二层循环 $i$ 的倍数 $j$（不包括 $i$），第三层循环 $i$ 到 $j$ 的所有数

第一层可以看成 $\frac{n}{2}$，因为再往上就不会有 $i$ 的倍数了（因为倍数都超过 $n$ ）。

接下来第二层和第三层是一个等差数列求和，公差为 $i$。对于一个 $i$，需要计算 $[i,2\times i],[i,3\times i],[i,4\times i],...,[i,n]$ 这些区间（每个区间长度比前一个多 $i$，共有 $\frac{n-i}{i}$ 个区间），计算次数就是 $(2\times i-i)+(3\times i-i)+(4\times i-i)+...+(n-i)$，这里直接把 $n-i$ 看成 $n$ 就好。

$i+2\times i+3\times i+...+n=\frac{n-i}{i}\times \frac{(n+i)}{2}$，$\frac{n-i}{i}$ 是项数。

把 $n-i$ 估大成 $n$，把 $n+i$ 估大成 $2\times n$。

得到 $\frac{n}{i}\times\frac{2\times n}{2}=\frac{2\times n^2}{2\times i}=\frac{n^2}{i}$，再把 $i$ 带入得到 $\displaystyle\sum_{i=1}^{\frac{n}{2}}\frac{n^2}{i}=n\times \displaystyle\sum_{i=1}^{\frac{n}{2}} \frac{n}{i}=n^2\times\ln(n)$，ok拿下。

```cpp
#include<bits/stdc++.h>
using namespace std ;
const int Max = 5e3 + 10 ; 
vector < int > Start[Max] , Prinm[Max] ; 
int g[Max][Max] ; 
int f[Max][Max] ;
int n , p ;
int main( ) {
	scanf("%d%d" , &n , &p ) ; 
	// 边界情况特殊处理 
	f[n + 1][n + 1] = 1 ; 
	for(int i = n ; i >= 1 ; i -- ) {
		// i 从 i+1 走来
		// 所以对 f[i][i] 修改即可 
		f[i][i] = ( f[i][i] + f[i + 1][i + 1] ) % p ;  
		
		for(int l = 2 * i ; l <= n ; l += i ) {
			// i 从 l 跳来，这里注意只有 l 是从 i+1,i+2,...,l 跳过来的方案需要被累计 
			f[i][i] = ( f[i][i] + f[l][i + 1] ) % p ; 
			
			for(int k = i + 1 ; k <= l - 1 ; k ++ ) {
				// l 从 k+1,k+2,...,l 跳过来
				// k 从 i 跳过来 
				f[k][i] = ( f[k][i] + f[l][k + 1] ) % p ; 
				
			}
		}
		// 每次 i 计算完，救刷新一下后缀和 
		for(int l = 1 ; l <= n ; l ++ ) f[l][i] = ( f[l][i] + f[l][i + 1] ) % p ; 
	}
	// 答案就是从 1 后面跳过来 
	printf("%d\n" , f[1][1] ) ;
	return false ; 
}
```

---

## 作者：无钩七不改名 (赞：16)

### 10pts

爆搜。

### 20pts/40pts

考虑一个 dp，$f_{i,j}$ 表示目前在 $i$，且前一步是从 $j$ 跳到 $i$ 的方案数。

我们分解一下跳一跳过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/vex5dvqk.png)

其中直线表示向上走或向下走，曲线表示跳因子。

可以看做以下两个部分的组合：

![](https://cdn.luogu.com.cn/upload/image_hosting/rlb37q48.png)

因此我们可以得到以下 dp 转移方程式：

$$
f_{n,n+1}=1
$$

$$
f_{i,i+1}=\sum_{x=i+2}^nf_{i+1,x},2\le i<n
$$

$$
f_{i,j}=\sum_{k=i+1}^j \sum_{x=j}^n f_{k,x},1\le i<j\le n,i+2\le j
$$

$$
f_{1,2}=2\times\sum_{x=3}^nf_{2,x}
$$

(其中 $j$ 是 $i$ 的整数倍。)

答案为 $\sum_{x=2}^nf_{1,x}$。

### 65pts/100pts

考虑一个前缀和优化。

令 $s_{i,j}=\sum_{k=j}^nf_{i,k}$，可以得到：

$$
f_{n,n+1}=1
$$

$$
f_{i,i+1}=s_{i+1,i+2},2\le i<n
$$

$$
f_{i,j}=\sum_{k=i+1}^j s_{k,k+1},1\le i<j\le n,i+2\le j
$$

$$
f_{1,2}=2\times s_{2,3}
$$

答案为 $s_{1,2}$。

### std

```cpp
//code by muxi
#include<bits/stdc++.h>
using namespace std;

const int N=5005; 

int n,p,dp[N][N];

int read(){
	int f=1,k=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=k*10+c-'0';
		c=getchar();
	}
	return f*k;
}

int main(){
	n=read();p=read();
	dp[n][n+1]=1;
	for(int i(n-1);i;--i){
		dp[i][i+1]=dp[i+1][i+2];
		for(int s(1);i*s<=n;++s){
			for(int j(i+1);j<=i*s;++j){
				dp[i][j]+=dp[j][i*s+1];
				if(dp[i][j]>=p)dp[i][j]-=p;
			}
		}
		for(int j(n-1);j>i;--j){
			dp[i][j]+=dp[i][j+1];
			if(dp[i][j]>=p)dp[i][j]-=p;
		}
	}
	printf("%d",dp[1][2]);
	return 0;
}
```

---

## 作者：1234567890sjx (赞：9)

这题难点不是在于设状态吗。。设 $f_{i,j}$ 表示当前在 $i$ 位置，上一次在 $j$ 位置 的不同方案数 ~~（状态居然设了二十分钟）~~ 但是这个 dp 显然不好转移。然后挖掘性质发现加一操作后面要么继续加一，要么跳因子。因此枚举加一到哪里然后枚举因子跳下去。可以惊人的发现此时 dp 图为 DAG，可以直接暴力转移。

因此可以列出 dp 转移方程。

+ $f_{n,n+1}=1$。
+ $f_{i,i+1}=\sum\limits_{k=j}^{n+1} [i\mid k]\sum\limits_{p=k+1}^{n+1} f_{j,p}$。

答案显然为 $\sum\limits_{i=2}^{n+1} f_{1,i}$。

此时可以写出 $O(n^3\log n)$ 的 dp 代码，得到 $42$ 分。

```cpp
    f[n][n + 1] = 1;
    for (int i = n - 1; i; --i)
        for (int j = i + 1; j <= n; ++j) {
            if (i + 1 == j)
                for (int x = i + 2; x <= n + 1; ++x)
                    f[i][j] = (f[i][j] + f[j][x]) % px;
            for (int k = j; k <= n + 1; ++k)
                if (k % i == 0)
                    for (int p = k + 1; p <= n + 1; ++p)
                        f[i][j] = (f[i][j] + f[j][p]) % px;
        }
    int s = 0;
    for (int i = 2; i <= n + 1; ++i)
        s = (s + f[1][i]) % px;
    printf("%lld\n", s);
```

然后发现里层枚举 $x$，$p$ 求的答案是形如求第一维为 $i$，第二维为一个 $f$ 数组后缀和的形式，因此动态开 $n$ 个后缀和维护答案。枚举 $k$ 可以直接 `for (int k = ((j + i - 1) / i) * i; k <= n + 1; k += i)`，于是就做完了。时间复杂度为 $O(n^2\log n)$。

还有就是这个题目氢微卡常，需要开 $O_2$，并且需要对取模做优化。比如说将值攒起来一起取模，或者说如果值 $v<2p$ 那么直接特殊判断求解。最后 `950ms` 惊险卡过。建议将时间限制放宽到 $3s$。

```cpp
long long f[5010][5010], g[5010][5010];
int n, pxx;
inline long long ga(long long v) {
    return v >= pxx ? v - pxx : v;
}
signed main() {
    scanf("%d%d", &n, &pxx);
    const int px = pxx;
    f[n][n + 1] = 1;
    for (int i = 1; i <= n + 1; ++i)
        g[n][i] = 1;
    for (int i = n - 1; i; --i) {
        for (int j = i + 1; j <= n; ++j) {
            if (i + 1 == j)
                f[i][j] = g[j][i + 2];
            for (int k = ((j + i - 1) / i) * i; k <= n + 1; k += i)
                f[i][j] += g[j][k + 1];
            f[i][j] %= px;
        }
        for (int j = n + 1; j; --j)
            g[i][j] = ga(g[i][j + 1] + f[i][j]);
    }
    long long s = 0;
    for (int i = 2; i <= n + 1; ++i)
        s = s + f[1][i];
    printf("%lld\n", s % px);
}
```

---

## 作者：Tom17 (赞：8)

如果只考虑“向左跳”和“跳到因子”这两种情况，是一个非常简单的题。加入“向右跳”后，原本的直接使用 dp 算法会导致出现后效性，那么我们希望把这种情况归到前两种情况之一之中。

如图，把“跳到因子”操作跳之前的数叫做 $i$，把“跳到因子”操作跳之后的数（$i$ 的因子）叫做 $z$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wzoag7cm.png)

注意到，**连续的“向右跳”操作只有可能发生在“跳到因子”操作后面**（如果是“向左跳”再“向右跳”，就违背题意：每个点只能到达一次），**且从 $z$ “向右跳”最多到达 $i$ 的前面一个数。**

![](https://cdn.luogu.com.cn/upload/image_hosting/mhnrt4xh.png)

**所以，把“跳到因子”和“连续向右跳”连在一起，当作一个操作。** 即 $i$ “跳到因子”操作后到 $z$ ，马上遍历所有“连续向右跳”跳到的位置（范围为 $[z,z+m]$，有 $z+m=i-1$），把贡献一并给到 $i$ 那里。

![](https://cdn.luogu.com.cn/upload/image_hosting/pbmi4bmq.png)

此时就有一个问题：$z$ “连续向右跳”跳到的位置可能与前面操作矛盾，或者 $z$ “连续向右跳”跳到的位置 $z'$ 的下一跳（向左跳）可能落到大于等于 $z$ 的数，都会导致结果出错 **（即有后效性）** 。**所以就新设 dp 的第二列对其有所约束：**

![](https://cdn.luogu.com.cn/upload/image_hosting/ka410744.png)

**设 $f(i,j)$ 为：当前是 $i$ 位置，且下一操作跳的位置在 $[1,j]$ 范围内的方案数 $(j<i)$。**（这里的**操作**有二：“跳到因子”和“连续向右跳”的合并操作、“向左跳”操作）**下面把 dp 的第二列 $j$ 称作约束范围**。

那么，前面提到的从 $z$ “连续向右跳”能到范围应该改为 $[z,j]$。答案取 $f(n,n-1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/adzzg2u5.png)

那么便有以下 dp 式子：

$$
f(i,j) \gets f(i,j)+f(i-1,j-1)\text{，当 }i=j+1
$$
$$
f(i,j) \gets f(i,j)+\sum_{z|i}^{}\sum_{k=z}^{j}f(k,z-1)
$$

解释：

第一个式子：当 $i=j+1$ 时，才有 $i$ “向左跳”的机会。

第二个式子：考虑“跳到因子”操作，对于 $z$ 来说，“连续向右跳”**能**跳到的位置才有贡献（范围为 $[z,j]$）。约束范围取 $[1,z-1]$，保证下一跳落到的数小于 $z$。

以上方法时间复杂度为 $O(n^3 \log n)$。

优化比较简单，**使用前缀和优化。** 具体地，枚举位置范围 $[z,j]$ 的值时，即 $f(k,z-1)$ 时，有枚举的约束范围 $z-1$ 不变，**且其枚举的约束范围一定比原约束范围小**（即 $z-1<j$）。那么，就可以在先前循环提前处理好前缀和（边循环边处理即可），到要用时直接调用。

优化后时间复杂度为 $O(n^2 \log n)$。


```cpp
#include<bits/stdc++.h>

#define N 5010

using namespace std;

int n,mod,dp[N][N],qianz[N][N];//dp[i][j]表示在第i位置，上一步在(1-j)范围内的方案数，qianz是前缀和数组

int yinzi[N][N];

int main()
{
    cin>>n>>mod;

    //预先处理因子
    for(int i=1;i<=n;++i)
    {
        for(int j=2;j<i;++j)//因子1不处理，下面直接赋值
        {
            if(i%j==0)
            {
                yinzi[i][++yinzi[i][0]]=j;
            }
        }
    }
    //这里调换了循环的位置，目的是外部循环约束范围，使前缀和数组顺次处理
    for(int j=0;j<=n;++j)
    {
        for(int i=j+1;i<=n;++i)//这里从j+1开始，优化一部分时间
        {
            dp[i][j]=1;//直接赋值
            if(i-1==j)
            {
                dp[i][j]+=dp[i-1][j-1];
                if(dp[i][j]>=mod) dp[i][j]-=mod;//取模优化
            }
            for(int cnt=1;cnt<=yinzi[i][0];++cnt)
            {
                int yz=yinzi[i][cnt];
                int val=qianz[j][yz-1]-qianz[yz-1][yz-1];
                if(val<0) val+=mod;
                dp[i][j]+=val;
                if(dp[i][j]>=mod) dp[i][j]-=mod;
            }
            qianz[i][j]=qianz[i-1][j]+dp[i][j];
            if(qianz[i][j]>=mod) qianz[i][j]-=mod;
        }
    }
    cout<<dp[n][n-1];
    return 0;
}

```

总的来说，这道题不算很难。就是有一点卡常，$O(n^2 \log n)$ 的时间复杂度需要常数优化。

---

## 作者：Richard_Whr (赞：5)

赛后10min过题，考场思路就差一点点，没调出来原因竟是因为不想写 8 分的暴力当拍子。

很像一个游走类 dp，但是转移顺序很不好搞，主要是后效性无法处理。

发现只有 $i \rightarrow i+1$ 这种能往右走，而剩余两种都能只能向左走，如果只有这两个是可以直接做的。

再仔细思考会发现如果我们是从右向左进行 dp 的话，使用向右走这种操作后到达的点只能再贡献给更靠左的点，这些点都会在之后处理，因此这样的就解决后效性了。

对每个点设一个 $f_i$ ，表示走到当前这个点，有多少种方法不使用向右走的方法走到 $i$。

再设 $add_{i,j}$ 表示从 $i$ 向右一直走到 $j$ ，贡献上去的方案数。

此时转移就是比较容易的了：

$$f_i=\sum\limits_{i|k}(f_k+\sum\limits_{j=i+1}^{k}add_{j,k})+f_{i+1}$$

$$add_{i,j}=\sum\limits_{i|k,k>j}(\sum\limits_{l=j+1}^{k}add_{l,k}+f_k)$$

从右向左枚举要贡献向右走方案数到 $j$，每次贡献完之后加上 $j$ 的贡献即可，相当于做一个后缀和。

用 $f_i$ 维护 $f_k$ 的后缀和，开一个 $Add$ 维护 $add_{j,k}$ 的后缀和即可。

代码很短，记得卡常，取模非常慢，如果一直取模的话就会变成 $68$ 分。

另一个优化是 $k$ 要满足是 $i$ 的倍数，还要比 $j$ 大，设 $k= d \times i$，有 $d \times i > j$，$d > \frac{j}{i}$。

实测不加这个过不了，加上就飞快。



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+10;
int f[N],add[N][N];
int n,mod;

inline void A(int &a,int b)
{
	if(a+b>=mod) a=a-mod+b;
	else a=a+b;
}

signed main()
{
	cin>>n>>mod;
	f[n]=1;
	for(int i=n-1;i>=1;i--)
	{
		int Add=0;
		for(int j=n;j>=i+1;j--)
		{
			A(add[i][j],(f[i]+Add)%mod);
			if(j%i==0) A(f[i],f[j]);
			for(int k=i*(j/i+1);k<=n;k+=i) A(Add,add[j][k]);
		}
		A(f[i],f[i+1]);
		A(f[i],Add);
	}
		
	cout<<f[1]<<"\n";
	return 0;
}
```

---

## 作者：luanyanjia2 (赞：3)

### 题目分析

考虑 DP。

显然当没有 $i$ 连向 $i+1$ 的边时，整个图是一个 DAG，可以直接 DP。所以我们 DP 要解决的唯一问题，就是考虑上 $i$ 到 $i+1$ 的边。

考虑从 $n$ 走到 $1$ 的过程。当我们从 $i$ **向前**跳到 $j$ 后，此时我们要么向前跳，要么往回走。又因为不能经过重复点，所以往回走最多只能走到 $j-1$。容易发现当到达 $i$ 点时，这个位置的状态只有当前点 $i$ 和跳过来的点 $j$ 两维，我们可以以此设计 DP。

我们从 $1$ 向 $n$ 来 DP。$f_{i,j}$ 代表当前从 $j$ **向前** 跳到点 $i$ 后，到 $1$ 的路径数目。此时可以向前跳到点 $i-1$ 或 $i$ 的因数。可以直接转移。（注意到此时限制已经从 $j$ 变成了 $i$）

$$f_{i,j} = f_{i-1,i} + \sum_{y|i}f_{y,i}$$

接下来就是往回走。状态为 $f_{i,j}$ 时，可以往回走到 $i+1$ 到 $j-1$ 之间的任意地方再向前跳。

$$f_{i,j} = f_{i,j} + \sum_{x=i-1}^{j+1}\sum_{(y|x) \land (y<i)}f_{y,i}$$

由于 $y<i$ 这个限制不是很好处理，但因为我们是从 $1$ 向 $n$ DP，所以只需要每计算完一个 $f$ 值就把它加到它的所有倍数上即可，将其记为 $s_{i,j}$ ，那原式变为：

$$f_{i,j} = f_{i,j} + \sum_{x=i-1}^{j+1}s_{y,i}$$

注意到这是一个区间查询，可以使用树状数组查询，复杂度 $O(n^2 \log^2n)$。（因为向因数连边，边数是 $\log n$ 级别的）

```cpp
for(int i=2;i<=n+1;i++)f[1][i]=1;xiangyinshulianbian
for(int x:son[1])
	for(int j=2;j<=n+1;j++)
		Add(x,f[1][j],j);
for(int i=2;i<=n;i++){
	int bas=0;
	for(int x:fa[i]){(bas+=f[x][i])%=p;}
	(bas+=f[i-1][i])%=p;
	for(int j=i+1;j<=n+1;j++){
		(f[i][j]+=bas)%=p;
		(f[i][j]+=(Query(j-1,i)-Query(i,i)+p)%p)%=p;
	}
	for(int x:son[i])
		for(int j=i+1;j<=n+1;j++)
			Add(x,f[i][j],j);
}
printf("%d\n",f[n][n+1]);
```
（其中 $son$ 是倍数，$fa$ 是因数）

但是她 T 了，所以要优化复杂度。

观察查询的过程，发现我们完全不需要树状数组，因为移动 $j$ 时，$f_{i,j}$ 只会改变一个数，一边求前缀和，一边改即可。时间复杂度 $O(n^2 \log n)$。

### 代码
```cpp
for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j+=i)
		son[i].push_back(j),
		fa[j].push_back(i);
for(int i=2;i<=n+1;i++)f[1][i]=1;
for(int x=2;x<=n;x++)
	for(int j=2;j<=n+1;j++)s[x][j]=1;
for(int i=2;i<=n;i++){
	long long bas=0;
	for(int x:fa[i])bas+=f[x][i];
	(bas+=f[i-1][i])%=p;
	long long now=0;
	for(int j=i+1;j<=n+1;j++){
		f[i][j]+=bas+now;
		now+=(s[j][i]%=p);
	}
	for(int j=i+1;j<=n+1;j++)f[i][j]%=p;
	for(int x:son[i]){
		for(int j=i+1;j<=n+1;j++)s[x][j]+=f[i][j];
	}
}
printf("%d\n",f[n][n+1]);
```

---

## 作者：xixisuper (赞：2)

# P10812 【MX-S2-T3】跳 题解

自我感觉本场比赛 T3 难度小于 T2。

这是一道好玩的 dp 题。

## 思路

我刚开始时的思路是这样的，设状态 $f(i)$ 表示从 $i$ 号点开始往 $1$ 跳的方案个数，然后发现一维的状态难以转移，再结合数据范围 $n\le5000$，猜测是二维状态，开始寻找关系。

我们重新审视一遍这几种转移方式：

- $x \rightarrow x-1$：这其实是最好分析的转移，因为到达 $x-1$ 号点后无法到达任何大于 $x-1$ 号点的位置了，并且如果我们通过该操作到达了 $j$ 号点，**所有小于 $j$ 的点我们一定都没有去过**。

-  $x \rightarrow x+1$：这一步其实很关键，我们设我们**本来在位置 $j$，通过数次该操作到达 $i$ 号点，可以知道的是所有小于 $j$ 的点我们一定都没有去过**。

- $x\rightarrow d,d \mid x$：与上述两种操作一样，如果我们通过该操作到达 $j$ 号点，**所有小于 $j$ 的点我们一定都没有去过**。

不难发现这三者都满足**所有小于某个点的点一定都没有去过**这一条件，所以我们可以根据这个来进行转移。

我们设状态 $f(i,j)$ 表示**在一个范围是 $1\sim j$ 的坐标轴上，从位置 $i$ 通过数次 $x\rightarrow x+1$ 操作到达 $j$ 号点后，再从 $j$ 号点到达 $1$ 号点的方案数**。根据定义，我们有 $f(n,n)$ 为最终的答案。这样设计状态有一个好处，那就是**所有小于 $i$ 的点我们一定都没有去过**。考虑如何对 $f(i,j)$ 进行计算。

当 $i\not=j$ 时，我们只能进行操作 $x\rightarrow d,d \mid x$，对于一个 $d$ 来说，它能够被走到当且仅当 $d\mid j$ 且 $d<i$，于是我们考虑枚举所有满足条件的 $d$。我们到达 $d$ 号点之后两种选择：要么向更小的点移动，要么向 $d+1$ 号点移动。我们可能经过多次向上移动后才会向下移动，不妨再枚举一个 $t$，表示经过了多少次向上移动后才向更小的点走，我们有 $t\geq0$ 且 $d+t<i$，对于每个 $t$ 都有 $f(d,d+t)$ 种走法，于是我们便得到了状态转移方程：

$$f(i,j)=\sum_{d\mid j,d<i}\sum_{t=0}^{i-d-1}f(d,d+t)$$

特别的，当 $i=j$ 时还可以额外进行 $x\rightarrow x-1$ 这一操作，方案数为 $f(i-1,j-1)$。综上，我们便得到了完整的状态转移方程：

$$
f(i,j)=
\begin{cases}
\sum_{d\mid j,d<i}\sum_{t=0}^{i-d-1}f(d,d+t) & i\not=j,\\
f(i-1,j-1)+\sum_{d\mid j,d<i}\sum_{t=0}^{i-d-1}f(d,d+t) & i=j.
\end{cases}
$$

这样暴力进行转移的时间复杂度约为 $O(n^4)$，但实际运行时会比理论复杂度小很多，足够通过前 3 个 subtask。

现在我们考虑优化，采用两个优化方式即可：

- 预处理出每个数的约数集合，每次使用约数时直接从对应集合中枚举即可，时间复杂度 $O(n^4)\rightarrow O(n\ln n+n^3\cdot d(n))$。

- 注意到枚举 $t$ 的实质是对 $f$ 的第二维进行区间求和，我们不妨采用前缀和优化，时间复杂度 $O(n\ln n+n^3\cdot d(n))\rightarrow O(n\ln n+n^2\cdot d(n))$。

优化后我们便能够通过第 4 个 subtask，要想通过第 5 个 subtask 要稍微卡下常。众所周知对一个变量进行取模运算是特别慢的，所以我们只需要把取模运算变成减法就能过了（详细的说就是当当前变量大于模数的时候，减去一个模数即可）。

## 代码

其实码量也不是很大。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define ll int
using namespace std;
const ll N=5e3+10;
ll n,p;
ll f[N][N],sum[N][N];
vector<ll> D[N];
void init(){
	for(ll i=1;i<=n;i++){
		for(ll j=1;j*i<=n;j++) D[i*j].push_back(i);
	}
} 
int main(){
	cin>>n>>p;
	init();
	for(register ll i=1;i<=n;i++){
		for(register ll j=i;j<=n;j++){
			if(i==1&&j==1) f[i][j]=1;
			else{
				if(i==1) f[i][j]=0;
				else{
					f[i][j]=0;
					if(i==j) f[i][j]=(f[i][j]+f[i-1][j-1]<p)?(f[i][j]+f[i-1][j-1]):(f[i][j]+f[i-1][j-1])-p;
					ll gt=D[j].size();
					for(ll d=0;D[j][d]<i&&d<gt;d++){
						if(D[j][d]==1) f[i][j]+=1;
						else{
							f[i][j]=f[i][j]+sum[D[j][d]][i-1]-sum[D[j][d]][D[j][d]-1];
							f[i][j]=(f[i][j]<0)?f[i][j]+p:(f[i][j]<p?f[i][j]:f[i][j]-p);
						}
					}
				}
			}
			sum[i][j]=sum[i][j-1]+f[i][j];
			sum[i][j]=sum[i][j]<p?sum[i][j]:sum[i][j]-p;
		}
	}
	cout<<f[n][n]%p; 
	return 0;
} 
```

---

## 作者：Thomas0702 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10812)

路径计数问题，考虑用 dp 实现。本题解从 $N$ 到 $1$ dp。先设计一个高复杂度的 dp，再优化。

因为可以向 $i+1$ 走，所以一个状态必须要知道最左边走到了哪里，才能不重复向 $i-1$ 走。

而为了不再次走到右边走过的地方，也要有一维表示右边走过的地方最靠左的坐标。

于是第一版 dp 出炉了。设 $f_{x,y,z}$ 表示当前位置为 $x$，最左边走到过 $y$，右边走过的地方最左边的坐标为 $z$，从 $N$ 走到这个状态的方案数，默认 $y\le x<z$。初始状态 $f_{N,N,N+1}=1$。可以列出转移方程：
$$\begin{equation}f_{x,x,x+1}=\sum\limits_{i=x+2}^{N+1}f_{x+1,x+1,i}\end{equation}$$
即从 $x+1$ 到 $x$。
$$\begin{equation}f_{x,x,z}=\sum\limits_{x|i,i\ge z}\sum\limits_{j=i+1}^{N+1}f_{i,z,j}\end{equation}$$
即从 $x$ 的倍数到 $x$，并且枚举 $x$ 的倍数的最左边到达的位置以及右边走过的地方最靠左的坐标。
$$\begin{equation}f_{x,y,z}=f_{x-1,y,z}\end{equation}$$
即从 $x-1$ 到 $x$，这里 $y>x$，注意枚举 $z$ 的时候 $x<z\le N+1$。

最后答案就是 $\sum\limits_{i=2}^{N+1}f_{1,1,i}$。这样可以过 $N\le 300$ 的测试点。
```cpp
#include<cstdio>
using namespace std;
void rd(){}
template<typename T,typename... U> void rd(T &x,U &...arg){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	x*=f;rd(arg...);
}
const int maxn=305;
int N,P;
int f[maxn][maxn][maxn];//当前位置 最左到达位置 右边到达过的最靠左的坐标 
int main(){
	rd(N,P);
	f[N][N][N+1]=1;
	for(int y=N-1;y;y--){
		for(int x=y;x<=N;x++){
			if(x==y){
				for(int z=x+2;z<=N+1;z++)//x+1到x 
					(f[x][x][x+1]+=f[x+1][x+1][z])%=P;
				for(int z=x+1;z<=N;z++)//右边到达过的最靠左的坐标 
					for(int i=((z-1)/x+1)*x;i<=N;i+=x)//x的倍数 
						for(int j=i+1;j<=N+1;j++)//i的右边 
							(f[x][x][z]+=f[i][z][j])%=P;
				continue;
			}
			for(int z=x+1;z<=N+1;z++)//x>y 只能从左边向右走 
				f[x][y][z]=f[x-1][y][z]; 
		}
	}
	long long ans=0;
	for(int i=2;i<=N+1;i++) (ans+=f[1][1][i])%=P;
	printf("%lld",ans);
	return 0;
}
```
发现第三维有点多余，造成了很多不必要的状态，考虑怎么通过转移的顺序压缩掉它。

瓶颈在于 $(2)$ 式。观察转移式，发现 $z$ 是共同的下标，并且 $z$ 在式子右边的第二维上。也就是说，状态 $f_{i,z}$ 就已经限制了这个状态可以转移到哪里，那么就可以在求出 $f_{i,z}$ 后直接向 $f_{x,x}$ 转移，即直接向因数转移，这样就不用管 $f_{x,x}$ 的第三维了。

注意到 $(1)$ 式在压掉第三维后可以 $O(1)$ 转移；而 $(2)(3)$ 式转移之后值相同，并且下标连续，差分即可。由于要向因数转移，所以时间复杂度是 $O(N^2logN)$。可能是我常数大，$f$ 数组要开 int 才行。

代码实现中将两维换了一下位置。
```cpp
#include<cstdio>
#include<vector>
using namespace std;
void rd(){}
template<typename T,typename... U> void rd(T &x,U &...arg){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	x*=f;rd(arg...);
}
const int maxn=5e3+5;
int N,P;
int f[maxn][maxn];//最小到达位置 当前位置
vector<int> vec[maxn];
int main(){
	rd(N,P);
	for(int i=1;i<=N;i++)
		for(int j=i+i;j<=N;j+=i)
			vec[j].push_back(i);
	f[N][N]=1;
	for(int j=N;j;j--){
		for(int i=j;i<=N;i++){
			(f[j][i]+=f[j][i-1])%=P;
			if(i==j) (f[i-1][i-1]+=f[i][i])%=P,(f[i-1][i]+=P-f[i][i])%=P;
			for(auto k:vec[i]){
				if(k>=j) break;
				(f[k][k]+=f[j][i])%=P,(f[k][j]+=P-f[j][i])%=P; 
			}
		}
	}
	printf("%d",f[1][1]);
	return 0;
}
```

---

## 作者：__YSC__ (赞：2)

# 题目描述

给定一根 $1$ 到 $N$ 的数轴。一开始有一个棋子在 $N$。每次棋子 $x$ 可以跳到 $x-1,x+1$ 或 $x$ 的因子处（不能超出 $1$ 到 $N$）。

每个点只能到达一次。求棋子到达 $1$ 的方案数。

# 思路

由于求倍数比因子简单，所以把问题变成从 $1$ 到 $N$，每次跳倍数。

我们可以发现，棋子的行走路径由两种类型的路拼在一起：

![](https://cdn.luogu.com.cn/upload/image_hosting/689jqk4t.png)

由于有先跳倍数再 $-1$ 的跳法，此时跳的倍数必须大于走过的最远的位置，所以状态中要记录最远走到哪里。

令 $dp_{i,j}$ 表示当前在 $i$，最远走到了 $j$ 的方案数。

当 $i=j$ 时，我们有转移 $dp_{i+1,i+1}\leftarrow dp_{i,j}$。

当然我们也可以跳倍数，也就是对于每个 $k=i\cdot m(m>1)$，那么都有转移 $dp_{x,k}\leftarrow dp_{i,j}(j<x\le k)$。

而这种转移可以使用前缀和维护。

空间复杂度 $O(N^2)$，时间复杂度 $O(N^2\log N)$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 5005;

int n, MOD, dp[MAXN][MAXN], sum[MAXN][MAXN];

int main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> n >> MOD;
  dp[1][1] = 1;
  for(int i = 1; i <= n; ++i) {
    for(int j = i; j <= n; ++j) {
      sum[j][i] = sum[j][i] + sum[j][i - 1] - (sum[j][i] + sum[j][i - 1] >= MOD ? MOD : 0);
      //cout << sum[j][i] << " \n"[j == n];
      dp[i][j] = dp[i][j] + sum[j][i] - (dp[i][j] + sum[j][i] >= MOD ? MOD : 0);
      //cout << dp[i][j] << " \n"[j == n];
      if(i == j) {
        dp[i + 1][max(i + 1, j)] = dp[i + 1][max(i + 1, j)] + dp[i][j] - (dp[i + 1][max(i + 1, j)] + dp[i][j] >= MOD ? MOD : 0);
      }
      for(int k = 2 * i; k <= n; k += i) {
        if(k > j) {
          sum[k][j + 1] = sum[k][j + 1] + dp[i][j] - (sum[k][j + 1] + dp[i][j] >= MOD ? MOD : 0);
        }
      }
    }
  }
  cout << dp[n][n];
  return 0;
}
```

---

## 作者：WaTleZero_pt (赞：2)

2024.7.30 对一处错误进行了修正。

~~我这个蒟蒻写了整整 2h 才通过。~~

显然我们一看就知道这是 dp 题。

### 思路分析

我们可以将题目倒过来看，即从点 $1$ 出发，可以从点 $x$ 跳到点 $x+1$（操作 $1$），点 $x-1$（操作 $2$） 或者点 $kx$（操作 $3$，其中 $k$ 为大于等于 $2$ 的正整数），最终要跳到第 $n$ 个点。每个点最多进 $1$ 次。

按照上述规则，我们不难发现从点 $x$ 进行几次（可以为 $0$ 次）操作 $2$ 后一定要至少进行 $1$ 次操作 $3$ 立刻跳过点 $x$，才能进行其他操作（如图），因此我们可以把操作 $2$ 和操作 $3$ 放在一起考虑。

![Picture Cannot Be Loaded Correctly](https://cdn.luogu.com.cn/upload/image_hosting/r0oraie6.png)

接下来考虑 dp。我们将第一维设置为当前所在的点，第二维设置为上一次所在的点。依据题意，初始化为 $dp_{1,0}=1$。我们可以得到状态转移方程和答案 $ans$ 如下：

操作 $1$：

$$dp_{i+1,i} \leftarrow dp_{i+1,i}+dp_{i,j}$$

操作 $2$ 与 操作 $3$ （注意要满足 $k(i-a) > i$）：

$$dp_{k(i-a),i} \leftarrow dp_{k(i-a),i}+dp_{i,j}$$

答案：

$$ans = \sum_{i=1}^{n-1} dp_{n,i}$$

这样做对于操作 $2$ 与 $3$ 来说是 $O(n^{3} \log n)$，应该怎么优化呢？

不难想到前缀和。令 $s_{i,j}= \sum_{k=1}^{j-1} dp_{i,k}$，则可优化如下：

$$dp_{k(i-a),i} \leftarrow dp_{k(i-a),i}+s_{i,i-a}$$

太好了！优化后的时间复杂度是 $O(n^{2} \log n)$，可以通过本题。注意尽可能使用 $32$ 位整型变量，避免超时。

### AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p;
int dp[5010][5010];
int qzh[5010];
int main(){
	scanf("%d%d",&n,&p);
	dp[1][0]=1;
	for(int i=1;i<=n;i++){
		memset(qzh,0,sizeof(qzh));
		for(int j=0;j<i;j++){
			dp[i+1][i]=(dp[i][j]+dp[i+1][i])%p;
			qzh[i]=(qzh[i]+dp[i][j])%p;
			qzh[j]=(qzh[j]-dp[i][j]+p)%p;
		}
		for(int j=i;j>0;j--){
			qzh[j]=((qzh[j]+qzh[j+1])%p+p)%p;
			for(int k=(i+j-1)/j*j;k<=n;k+=j){
				if(k<=i) continue;
				dp[k][i]=(dp[k][i]+qzh[j])%p;
			}
		}
	}
	int ans=0;
	for(int i=0;i<n;i++)
		ans=(ans+dp[n][i])%p;
	printf("%d",ans);
}
```

---

## 作者：EricWan (赞：1)

考试时智障版使用的自己会的最高级的数据结构——树状数组，喜提 T 飞的 68 分。

歪解不扯了，直接讲正解。

我们发现除了向右一点一点移动是唯一向右移动的方法，然而向右移动是非常烦人的，不如开一维维护这个。

不管当前是什么样子，我们一定可以从这个状态转移到答案。

定义 $f_{i,j}$ 为走到 $i$ 后向后连续移动到 $j$ 而且不打算继续向后移动的方案数。

我们直接考虑主动转移。

+ 向前移动一格，转移到 $f_{i-1,j-1}$（要求 $i=j$）
+ 向后移动一格，与定义冲突，舍
+ 大跃进，对于所有 $k<i$ 且 $j\mod k=0$ 且 $l\in[k,i)$ 转移到 $f_{k,l}$。

初始状态只有 $f_{n,n}$ 是 $1$，其他都是 $0$，答案就是 $f_{1,1}$。

~~我们就可以快乐写代码了，芜湖~~

[没有任何优化，这样的裸 DP 是 42 分的，赛时亲试](https://www.luogu.com.cn/record/168934642)

我们发现对于所有转移，都是一段连续的区间，考虑优化，~~使用[树状数组等带 $\log$ 的方法优化是 68 分的](https://www.luogu.com.cn/record/168935734)~~。

之后我们用前缀和优化就可以 AC，这个 DP 可能我用文字说的不是很明白，各位大佬可以看代码。

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, mod, dp[5005][5005], t[5005][5005];
vector<int> d[5005];
int query(int a, int x) {
    return t[a][x] = (t[a][x - 1] + t[a][x]) % mod;
}
void update(int a, int x, const int k) {
    t[a][x] += k;
}
signed main() {
	cin >> n >> mod;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++)
			if (i % j == 0)
				d[i].push_back(j);
	update(n, n, 1);
	for (int i = n; i >= 2; i--) {
		for (int j = i; j <= n; j++) {
			dp[i][j] = query(i, j);
			if (j == i) {
				update(i - 1, i - 1, dp[i][j]);
				update(i - 1, i, - dp[i][j]);
			}
			for (int k : d[j]) {
				if (k >= i) break;
				update(k, k, dp[i][j]);
				update(k, i, - dp[i][j]);
			}
		}
	}
	cout << (query(1, 1) + mod) % mod;
	return 0;
}
```

这样理论上复杂度大概是两亿，常数不大，但过了。

---

## 作者：Jadonyzx (赞：0)

注意到一次如果不考虑往更大的数字的跳跃，显然可以建出一个有向无环图跑拓扑排序即可，因此我们考虑将原转移转换为有向无环图上的动态规划。

难点在 $+1$ 操作上。

可发现，该操作只能与向因子移动组合在一起使用，不妨考虑在点 $i$ 时可以向哪些 $j$ 连接一条表示先进行若干次 $+1$ 再进行一次走向因子的边。

容易发现，这与之前到过的最小的比 $i$ 大的点有关。

考虑建分层图， $id_{i,j}$ 表示当前在 $i$ 点，之前到过的最小的比 $i$ 大的点为 $j$ 的点。

连边如下：

$id_{i,j}$ 连向 $id_{i-1,i}$ 表示减一操作。

$id_{i,j}$ 连向 $id_{k,i}$，其中 $k\mid i$。

$id_{i,j}$ 连向 $id_{k,i}$ ，其中存在 $j-1\geq q\geq i+1$ 且 $k\mid q$。

前两者复杂度优秀，第三个可以后缀和优化建图。

然后发现空间超限了。

打表发现答案在 __int128 范围内，较大数据打表即可。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P10812)

**题目大意**

> 给定 $1\sim n$ 数轴，每个位置至多经过一次，不可超出 $[1,n]$，每次可以从 $u$ 走到 $u-1,u+1$ 或 $u$ 的因子，求有多少 $n\to 1$ 的路径。
>
> 数据范围：$n\le 5000$。

**思路分析**

如果不存在 $u\to u+1$ 的操作，那么直接 dp 并没有后效性。

如果存在这种操作，我们就要将若干操作合并，我们以每次 $u$ 能使减少的操作为状态分段进行 dp。

即 $f_{u,v}$ 表示当前路径上一步是 $v\to u$，并且 $v>u$ 的方案数。

那么转移要么直接向 $u-1$ 移动成 $f_{u-1,u}$，要么枚举 $x\in[u,v)$ 并转移到 $x$ 的因数上。

我们可以对所有 $u$ 做后缀和，那么每个从 $x$ 向因数移动的所有转移都可以一次性处理掉，那么总转移数是均摊调和的。

时间复杂度 $\mathcal O(n^2\log n)$ 。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005;
vector <int> fac[MAXN];
int n,MOD,f[MAXN][MAXN];
inline void add(int &x,const int &y) { x=(x+y>=MOD)?x+y-MOD:x+y; }
signed main() {
	scanf("%d%d",&n,&MOD);
	for(int i=1;i<=n;++i) for(int j=i;j<=n;j+=i) fac[j].push_back(i);
	f[n][n+1]=1;
	for(int i=n;i>1;--i) {
		int s=0;
		for(int j=n;j>=i;--j) {
			add(s,f[i][j+1]);
			for(int k:fac[j]) if(k<i) add(f[k][i],s);
		}
		add(f[i-1][i],s);
	}
	int s=0;
	for(int i=1;i<=n+1;++i) add(s,f[1][i]);
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：是青白呀 (赞：0)

当我们在一个点 $x$ 时，我们有 $3$ 种可行方案：

- 直接跳到某个因子处；
- 往 $1$ 方向走若干步，走到 $1$ 或在中间的某个位置跳因子；
- 往 $n$ 的方向走若干步，然后跳因子。这种情况由于前面走过一些位置，所以往回走的步数是有限制的，并且只能跳到 $<x$ 的因子处。

三个操作都有“跳因子”的步骤，不妨先设 $f_{i,j}$ 表示下一步是从 $i$ 开始跳因子，且跳到 $1\sim j$ 的方案数。对于答案，可以设 $dp_{i,j}$ 表示现在在 $i$，往回走最多走到 $j$ 的方案数。对于 $f_{i,j}$，有 $i>j$；对于 $dp_{i,j}$，有 $i\leq j$。

两者可以互相转移：

- $f_{i,j}=\sum_{k\leq j,i\bmod x=0}dp_{k,j}$；


- $dp_{i,j}=\sum_{k=2}^{i-1}f_{k,k-1}+\sum_{k=i}^jf_{k,i-1}+1$，其中前一部分表示向 $1$ 方向走；后一个部分表示向 $n$ 方向走或直接跳因子，最后一个 $+1$ 是直接走回到 $1$ 而不跳因子的方案。

可以先枚举 $j$，再枚举 $i$，逐个转移，复杂度是 $O(n^3)$。

可以用 $sum1_i=\sum_{j=2}^if_{j,j-1}$ 和 $sum2_{i,j}=\sum_{k=j+1}^if_{k,j}$ 两个前缀和数组辅助转移，使得 $dp$ 能够 $O(1)$ 转移；对于 $f$ 数组，用调和级数的复杂度暴力枚举即可。

总复杂度为 $O(n^2\log n)$，不难通过。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=5005,M=3e5+5,mo=1e9+7,inf=1e9+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,p;
int dp[N][N],f[N][N],sum1[N],sum2[N][N];
signed main(){
	read(n),read(p);
	rep(i,1,n){
		dp[1][i]=1;
		rep(j,1,i-1){
			f[i][j]=1;
			if(i==j+1)sum1[i]=(sum1[i-1]+f[i][j])%p;
			sum2[i][j]=(sum2[i-1][j]+f[i][j])%p;
		}
	}
	rep(j,1,n){
		rep(i,2,n){
			if(i>j){//此处的 f 合法且更新完毕 
				if(i==j+1)sum1[i]=(sum1[i-1]+f[i][j])%p;
				sum2[i][j]=(sum2[i-1][j]+f[i][j])%p;
			}
			else{//此处的 dpi,j 合法 
				dp[i][j]=(sum1[i-1]+sum2[j][i-1]+1)%p;
				for(int k=i*2;k<=n;k+=i)
				    if(k>j)f[k][j]+=dp[i][j],f[k][j]%=p;
			}
		}
	}
	printf("%d\n",dp[n][n]);
	return 0;
}
```

---


# 「QMSOI R1」 三服同构

## 题目背景

前不久，三国杀上线了一位三服同构的赛事专属武将...

[那这道题与SP孙策的关系呢？](https://www.luogu.com.cn/paste/g68kquaa)

![](https://patchwiki.biligame.com/images/sgs/thumb/4/46/ekgr28n00suo1zkuksp047802wfl4a6.png/401px-SP%E5%AD%99%E7%AD%96-%E7%BB%8F%E5%85%B8%E5%BD%A2%E8%B1%A1.png)

## 题目描述

现在有 $4$ 种扑克牌：红桃 A，红桃 K，黑桃 A，黑桃 K，小 Q 的手上现在有 $n$ 张黑桃牌，$m$ 张红桃牌，其中有 $u$ 张黑桃 A，$v$ 张红桃 A，而对手有 $k$ 张牌。

现在小 Q 知道对手第 $i$ 张牌点数为 A 的概率为 $a_i$，接下来他将持续执行以下操作，直到他的回合结束。

1. 若你手中有至少 $1$ 张红桃 A 或红桃 K，则你**必须**等概率随机弃置 $1$ 张花色为红桃的牌，并与对手进行决斗。
2. 否则，你结束你的回合。

决斗的流程如下：

从对手开始，双方交替进行以下操作：

1. 若其手上有至少 $1$ 张红桃 A 或黑桃 A，则其**必须**等概率随机弃置 $1$ 张点数为 A 的牌。
2. 否则，其受到 $1$ 点伤害,并结束此次决斗。

现在你想要知道在你的回合结束前，对手期望会受到多少点伤害。

## 说明/提示

### 样例解释

可以得出对手牌中有 $0,1,2$ 张 A 的概率分别为 $0.16,0.68,0.16$。

当对手牌中有 $0$ 张 A 时，无论小 Q 每次耗费的哪张红色牌，都能对对手造成伤害，所以这种情况期望伤害为 $0.16*2=0.32$。

当对手牌中有 $1$ 张 A 时，假设小 Q 第一次耗费的是 A 进行决斗，那对手打出 A 后，小 Q 就会打出一张黑桃 A，对手没 A 了就会受到伤害，而小 Q 的另一张红桃 K 依然能被耗费，以进行决斗对对手造成伤害，所以这种情况期望伤害为 $0.68*0.5*2=0.68$。

当对手牌中有 $1$ 张 A 时，假设小 Q 第一次耗费的是 K 进行决斗，那对手打出 A 后，小 Q 打出黑桃 A 或红桃 A 的概率就是相等的，然后对手没 A 了就会受到伤害，但是如果打出的是红桃 A 就无法再进行决斗了，而打出黑桃 A 另一张红桃 A 依然被耗费，进行决斗对对手造成伤害，所以这种情况期望伤害为 $0.68*0.5*0.5*1+0.68*0.5*0.5*2=0.51$。

当对手牌中有 $2$ 张 A，这时如果小 Q 先耗费的 A 进行决斗，那对手打出 A 后，小 Q 就会打出一张黑桃 A，对手再打出 A 后，小 Q 就会受到伤害，而小 Q 的另一张红桃 K 依然能被耗费，以进行决斗对对手造成伤害，所以这种情况期望伤害为 $0.16*0.5*1=0.08$。

当对手牌中有 $2$ 张 A，这时如果小 Q 先耗费的 K 进行决斗，双方就会各打出两张 A，然后敌人受到伤害，小 Q 就不能再进行决斗了，所以这种情况期望伤害同样为 $0.16*0.5*1=0.08$。

所以对手受到的期望伤害就是 $0.32+0.68+0.51+0.08+0.08=1.67$。

### 数据范围
**本题使用 subtask 进行捆绑测试**，每个 subtask 的具体分值如下：
| 子任务 | 值域 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $1\le n,m\le 10$ | $30$ |
| $1$ | $1\le n,m\le 2000$ | $70$ |

对于所有的数据，满足 $1 \leq n,m,k \leq 2000,1\le u<n,1\le v <m$。

## 样例 #1

### 输入

```
2 2 1 1 2
0.2 0.8```

### 输出

```
1.670000000```

# 题解

## 作者：tkdqmx (赞：2)

出题人题解

### 30pts

用搜索枚举分别得出对手手上有 $i$ 张 A 的概率 $f_i$；小 Q 打出 $i$ 张 A 后，其中有 $j$ 张是红桃的概率 $g_{i,j}$；在减少一张红桃 A 的基础上，小 Q 打出 $i$ 张 A 后，其中有 $j$ 张是红桃的概率 $h_{i,j}$。

然后就可以枚举对手手上有 $i$ 张 A 的情况，这时我们分两种情况讨论：

第一种，小 Q 耗费的第一张红桃牌为 K，这时还要分两种子情况讨论：

子情况一，小 Q 手上的 A 点大于等于 $i$，此时第一次决斗一定能将敌人手上的 A 耗完，且还能使对手受到伤害，而剩下多少张红桃牌，小 Q 就可以再使对手受到多少点伤害，这种情况下的期望伤害即为 $\sum_{j=0}^{j \leq \min(i,v)} f_i \times \frac{m-v}{m}\times g_{i,j}\times (m-j)$。

子情况二，小 Q 手上的 A 点小于敌人 $i$，此时第一次决斗会将小 Q 手上的 A 点耗完，敌人手上则会剩下 $i-u-v-1$ 张 A 点，因为小 Q 还剩下 $m-v-1$ 张红桃 K，而每张红桃 K，又能耗掉对手一张 A，耗完后就能使敌人受到伤害，所以这种情况下的期望伤害为 $f_i \times \frac{m-v}{m}\times \max(0,(m-v-1)-(i-u-v-1))=f_i \times \frac{m-v}{m}\times \max(0,m-i+u)$。

第二种，小 Q 耗费的第一张红桃牌为 A，这时仍然分两种子情况讨论：

子情况一，小 Q 手上剩余的 A 点大于等于 $i$，此时第一次决斗一定能将敌人手上的 A 耗完，且还能使对手受到伤害，而剩下多少张红桃牌，小 Q 就可以再使对手受到多少点伤害，这种情况下的期望伤害即为 $\sum_{j=0}^{j \leq \min(i,v-1)} f_i \times \frac{v}{m}\times h_{i,j}\times (m-j)$。

子情况二，小 Q 手上的 A 点小于敌人 $i$，此时第一次决斗会将小 Q 手上的 A 点耗完，敌人手上则会剩下 $i-u-v$ 张 A 点，因为小 Q 还剩下 $m-v$ 张红桃 K，而每张红桃 K，又能耗掉对手一张 A，耗完后就能使敌人受到伤害，所以这种情况下的期望伤害为 $f_i \times \frac{v}{m}\times \max(0,(m-v)-(i-u-v))=f_i \times \frac{v}{m}\times \max(0,m-i+u)$。

最后将所有 $i$ 的期望伤害相加即为答案，复杂度 $O(2^{n+m}+km)$。

### 100pts

在 30pts 的基础上，把三个数组的计算方式由搜索改为概率 DP 即可。

我们设 $f_{i,j}$ 表示对手前 $i$ 张牌中有 $j$ 张 A 的概率，则 $f_n$ 即为 30pts 中的 $f$，其它两个数组的状态定义与 30pts 中的定义相同。

$f_{i,j}$ 可以从 $f_{i-1,j}$ 和 $f_{i-1,j-1}$ 转移过来，转移方程为 $f_{i,j}=(1-a[i])\times f_{i-1,j}+a_i\times f_{i-1,j-1}$，分别表示这一张是 A 与不是 A 的转移。

$g_{i,j}$ 同样可以从 $g_{i-1,j}$ 和 $g_{i-1,j-1}$ 转移过来，转移方程为 $g_{i,j}=\frac{u-i+j+1}{u+v-i+1}\times g_{i-1,j}+\frac{v-j+1}{u+v-i+1}\times g_{i-1,j-1}$，分别表示这张打出的牌是红桃与不是红桃的转移。

$h_{i,j}$ 同样可以从 $h_{i-1,j}$ 和 $h_{i-1,j-1}$ 转移过来，转移方程为 $h_{i,j}=\frac{u-i+j+1}{u+v-i}\times h_{i-1,j}+\frac{v-j}{u+v-i}\times h_{i-1,j-1}$，分别表示这张打出的牌是红桃与不是红桃的转移。

最后答案的计算与 30pts 相同，总复杂度 $O(kn+km)$。

~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2005
int n,m,u,v,k;
double ans,a[N],dp1[N][N],dp2[N<<1][N<<1],dp3[N<<1][N<<1];
int main(){
    dp1[0][0]=dp2[0][0]=dp3[0][0]=1;
    scanf("%d%d%d%d%d",&n,&m,&u,&v,&k);
    for(int i=1;i<=k;i++)  scanf("%lf",a+i);
    for(int i=1;i<=k;i++){
        dp1[i][0]=dp1[i-1][0]*(1-a[i]);
        for(int j=1;j<=i;j++)
            dp1[i][j]=dp1[i-1][j-1]*a[i]+dp1[i-1][j]*(1-a[i]);
    }
    for(int i=1;i<=min(u+v,k);i++){
        if(i<=u)  dp2[i][0]=dp2[i-1][0]*(u-i+1)/(u+v-i+1);
        for(int j=1;j<=min(i,v);j++){
            dp2[i][j]=dp2[i-1][j-1]*(v-j+1)/(u+v-i+1);
            if(i-j<=u)  dp2[i][j]+=dp2[i-1][j]*(u-i+j+1)/(u+v-i+1);
        }
    }
    for(int i=1;i<=min(u+v-1,k);i++){
        if(i<=u)  dp3[i][0]=dp3[i-1][0]*(u-i+1)/(u+v-i);
        for(int j=1;j<=min(i,v-1);j++){
            dp3[i][j]=dp3[i-1][j-1]*(v-j)/(u+v-i);
            if(i-j<=u)  dp3[i][j]+=dp3[i-1][j]*(u-i+j+1)/(u+v-i);
        }
    }
    for(int i=0;i<=k;i++){
        if(u+v>=i)
            for(int j=0;j<=min(i,v);j++)
                ans+=dp1[k][i]*(m-v)/m*dp2[i][j]*(m-j);
        else  ans+=dp1[k][i]*(m-v)/m*max(0,m-i+u);
        if(u+v>i)
            for(int j=0;j<=min(i,v-1);j++)
                ans+=dp1[k][i]*v/m*dp3[i][j]*(m-j);
        else  ans+=dp1[k][i]*v/m*max(0,m-i+u);
    }
    printf("%.9lf\n",ans);
}
~~~

---


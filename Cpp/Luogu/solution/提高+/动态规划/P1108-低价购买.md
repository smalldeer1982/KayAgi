# 低价购买

## 题目描述

“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。

这里是某支股票的价格清单：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \cr\hline
\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \cr\hline
\end{array}$$

最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textsf{日期} & 2 & 5 & 6 & 10 \cr\hline
\textsf{价格} & 69 & 68 & 64 & 62 \cr\hline
\end{array}
$$


## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67 78 62 98 87
```

### 输出

```
4 2
```

# 题解

## 作者：wjyyy (赞：179)

这不是一道简单的求最长下降子序列的问题。

### ——因为这个题要输出不同种的方案数

题目要求是“它们构成的价格队列不一样”，那么我准备拿一个数组存下这个最长下降子序列，但是这不现实，检查是否匹配是在最坏的情况下可能达到$Θ(N^3)$。

于是有了现在的解法，让我来**简单**~~证明~~**说明**一下

在$dp$过程中，$f$数组存的是最长下降子序列的长度，$f$数组的下标$i$是以$i$结尾的意思，所以最长下降子序列（除了最后一位外）的数据已经丢失，**因此不能**在方案数相加时**再**判断是否能加。

我们从头来看，
1. 如果一个数列的第一个数与另一个数列的第一个数相同，那么现在可以判断它们相等，即可以**把其中一个删掉**（在代码中的处理是$t[i]=0$）。当不同的数接在它的后面时，又可以将它们判断为两个数列，这是不互相影响的。因为两个数列都可以由这个相等的数列转移而来
1. 如果一个数列的第一个数与另一个数列的第一个数不同，那么它们不等，且无论后面添加什么，都不相等，即**不删去**，则按照普通的判断继续做。

由上面的两点，我们已经把重复的删掉，这样可以**防止重复计数**。

$tip$：本题如果出现在考试中，请不要冒险定义int，因为maxint是$2^{31}-1$，会爆int，这个题暂不做深究

Code：
---------

```cpp
#include<cstdio>
#include<cstring>
int max(int x,int y){return x>y?x:y;}
int a[5001],f[5001],t[5001];
//a[i]存的是第i天股票的价格
//f[i]存的是第i天最长下降子序列的长度
//t[i]存的是以i结尾的最长下降子序列的种类（方案）
int main()
{
    memset(f,0,sizeof(f));//初始化长度
    memset(t,0,sizeof(t));//初始化方案
    int n,maxx=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i;j++)
            if(a[i]<a[j])//延长已经存在的最长下降子序列
                f[i]=max(f[i],f[j]+1);
        if(f[i]==0)
            f[i]++;//如果当前的数是目前为止最大的，则最长下降子序列是自己
        if(f[i]>maxx)
            maxx=f[i];//在f数组更新完毕后，存下最长下降子序列的长度
        for(int j=1;j<i;j++)
            if(f[i]==f[j]&&a[i]==a[j])
                t[j]=0;//如果与前面的数列相同，则舍去前面的数列，防止重复计数
            else if(f[i]==f[j]+1&&a[i]<a[j])
                t[i]+=t[j];//如果可以接上前面的数列，则继承其方案数
        if(!t[i])//如果当前的数是目前为止最大的，则是初始方案
            t[i]=1;
    }
    int sum=0;//sum计数，用于存最长下降子序列（方案）的个数
    for(int i=1;i<=n;i++)
        if(f[i]==maxx)
            sum+=t[i];
    printf("%d %d",maxx,sum);
    return 0;
}

```

---

## 作者：HITZero (赞：98)

第一问求最长下降子序列, 有$O(n^2)$和$O(nlogn)$的求法。基于本题数据范围，直接选取$O(n^2)$的简单写法。
递推式为:
if(a[i] < a[j])	$ dp[i] = max(dp[i], dp[j] + 1);$ (i > j)


第二问求方案数，刚开始没想到，其实求方案数也是一类常见的dp问题。基于dp数组的dp。

```cpp
if(dp[i] == dp[j] + 1 && a[i] < a[j]) f[i] += f[j];
```

去重
```cpp
if(dp[i] == dp[j] && a[i] == a[j]) f[i] = 0;
```

```cpp

#include <bits/stdc++.h>
using namespace std;
const int maxn = 5005;
int n, a[maxn];
int dp[maxn];
int f[maxn];
int main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> n;
  for(int i = 1; i <= n ; i++)
    cin >> a[i];
  int ans1 = 0, ans2 = 0;
  for(int i = 1; i <= n; i++) {
    dp[i] = 1;
    for(int j = 1; j < i; j++)
      if(a[i] < a[j]) {
        dp[i] = max(dp[i], dp[j] + 1);
      }
    ans1 = max(ans1, dp[i]);
  }
  for(int i = 1; i <= n; i++) {
    if(dp[i] == 1) f[i] = 1;
    for(int j = 1; j < i; j++)
      if(dp[i] == dp[j] + 1 && a[i] < a[j]) f[i] += f[j];
      else if(dp[i] == dp[j] && a[i] == a[j]) f[i] = 0;
    if(dp[i] == ans1) ans2 += f[i];
  }
  cout << ans1 << " " << ans2 << endl;
}


```

---

## 作者：feecle6418 (赞：33)

首先我们来分析一下这道题说的到底是什么，然后便可以发现这是一个最长下降子序列的题。

第一文是求最长下降子序列的长度，自然用普通的dp算法。关键是第二问，求**不同的**最长下降子序列的个数。

我们仍然考虑递推求解。设$t[i]$表示以第i个元素结尾的**最长的下降子序列**的个数。在开始的时候，因为我们还不知道最长下降子序列的长度，所以我们把所有的$t[i]$都置为1。

在按照普通的dp方法求解最长下降子序列的时候，我们在中间统计：如果$f[i]<f[j]+1$，按照dp思想，我们就会用$f[j]+1$更新$f[i]$。这时，现在以$a[i]$结尾的最长的下降子序列的长度就只跟以$a[j]$结尾的最长的下降子序列的长度有关了。所以$t[i]$直接赋值为$t[j]$。如果$f[i]=f[j]+1$，那么我们在构造以$a[i]$结尾的最长下降子序列的长度的时候，既可以用原来算出$f[i]$值的那一个子序列来构造，也可以把第i个元素接在以第j个元素结尾的最长下降子序列后面，所以$t[i]+=t[j]$。最后统计，如果$f[x]$等于最长下降子序列的长度，便把$t[x]$计入答案总数中。

去重就比较简单了。在前一个元素和后一个元素相同的时候，我们只保留后一个元素的f值和t值就好了。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[5005],f[5005],t[5005];
int main(){
    int n,ans=1,ans2=0;
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	f[i]=t[i]=1;
    }
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            if(a[j]>a[i]){
                if(f[i]<f[j]+1)f[i]=f[j]+1,t[i]=t[j];
                else if(f[i]==f[j]+1)t[i]+=t[j];
            }
            if(a[j]==a[i])f[j]=t[j]=0;
        }
        ans=max(ans,f[i]);
    }
    cout<<ans;
    for(int i=1;i<=n;i++)if(f[i]==ans)ans2+=t[i];
    cout<<" "<<ans2;
    return 0;
}
```

---

## 作者：wwyx2001 (赞：27)

#nlogn的做法！！！！

[二分的第一问](http://blog.csdn.net/blue\_cuso4/article/details/54864529)好做，问题是方案数怎么统计

水题而已，大部分人都应该会做，我突然想挑战一下nlogn的做法，然后。。。。

b[i]表示以i结尾的方案数

每一个g存的数字都会被一个大于ta的数字替换，也就是说假如把所有的g值记录下来就是单调递增的，这样每次更新g的时候，方案数就是前一位比他大的数字方案数的和。

详见[这里](http://blog.csdn.net/Blue\_CuSO4/article/details/78207876)

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
using namespace std;
struct hh{int tim,z;};
vector<hh>nxt[5005];
int n,i,a[5005],g[5005],b[5005],ans,ll[5005];
int main()
{
    scanf("%d",&n);
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    int tot=0,maxx=0;
    a[++n]=-1e9;
    for (i=1;i<=n;i++)
    {
        int l=1,r=tot;
        while (l<=r)
        {
            int mid=(l+r)>>1;
            if (g[mid]<=a[i]) r=mid-1;
            else l=mid+1;
        }
        int now=i;
        if (!nxt[r+1].size() || a[i]!=a[nxt[r+1][nxt[r+1].size()-1].tim])//避免加入重复的数字 
          nxt[r+1].push_back((hh){i,a[i]});
        else now=nxt[r+1][nxt[r+1].size()-1].tim;
        b[now]=0;//把以前的清零，因为作为结尾的话后面的数字一定比前面的优 
        if (r)
        for (int j=ll[r];j<nxt[r].size();j++)
        {
            if (nxt[r][j].z<=a[i]) ll[r]++;
            else b[now]+=b[nxt[r][j].tim];
        }
        g[r+1]=a[i];
        tot=max(tot,r+1);
        if (!b[now]) b[now]=1; 
        //处理方式就是以前重复过的就覆盖以前的，因为最后手动加了一个最小数，以前所有的方案都会汇总到一起 
    }
    printf("%d %d",tot-1,b[n]);
}
```

---

## 作者：小白一枚 (赞：15)

看到提高+难度就试着做了下

然而只是个升级版的LIC?

f[序号]=最长长度

c[序号]=方法数量

当f[i]=f[j]+1,且数字满足大小关系时,c[i]+=c[j]

当f[i]=f[j],且数字相等时，c[j]=0,避免重复计算


[cpp] view plain copy

      
```cpp
#include<iostream>  
#include<cstdio>  
#include<algorithm>  
#include<cmath>  
using namespace std;  
long long f[6000];  
long long c[6000];  
int cnt=0;  
int n;  
long long a[6000];  
int main(){  
    scanf("%d",&n);  
    int i,j;  
    for(i=1;i<=n;i++){  
        scanf("%d",&a[i]);  
    }  
    int max1=0;  
    for(i=1;i<=n;i++){  
        for(j=1;j<i;j++) if(a[i]<a[j] && f[i]<f[j]+1)f[i]=f[j];  
        f[j]++;  
        if(f[j]==1)c[j]=1;  
        for(j=1;j<i;j++){  
            if(a[i]<a[j] && f[i]==f[j]+1){  
                c[i]+=c[j];   
            }  
            else if(a[i]==a[j] && f[i]==f[j]) c[j]=0;  
        }  
        if(f[i]>max1)max1=f[i];  
    }  
    for(i=1;i<=n;i++){  
        if(f[i]==max1)cnt+=c[i];  
    }  
    printf("%d %d",max1,cnt);  
    return 0;  
}  
```
2.
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
long long f[6000];
long long c[6000];
int cnt=0;
int n;
long long a[6000];
int main(){
    scanf("%d",&n);
    int i,j;
    for(i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    int max1=0;
    for(i=1;i<=n;i++){
          for(j=1;j<i;j++) if(a[i]<a[j] && f[i]<f[j]+1)f[i]=f[j];
        f[j]++;
          if(f[j]==1)c[j]=1;
        for(j=1;j<i;j++){
            if(a[i]<a[j] && f[i]==f[j]+1){
                c[i]+=c[j];    
            }
            else if(a[i]==a[j] && f[i]==f[j]) c[j]=0;
        }
        if(f[i]>max1)max1=f[i];
    }
    for(i=1;i<=n;i++){
        if(f[i]==max1)cnt+=c[i];
    }
    printf("%d %d",max1,cnt);
    return 0;
}
```
献上两堆（丑陋）的代码，请大佬查看


---

## 作者：I_AM_HelloWord (赞：9)

蒟蒻也是看题解做的（手动害羞），但是为了巩固做dp题的能力，所以在此做个小小的总结。

1.由于数据是5000的，而且需要统计方案数，所以我们对于第一个问题直接用个O(n^2)的最长下降子序列搞一搞就好了。

用f数组保存以第i个数字为结尾的最长下降序列的长度。

2.对于第2问，

有一个变种（比本题较为简单）：就是不去重的方案数。那么我们考虑维护另一个g数组

令g[i]表示以第i个数字为结尾的最长序列的个数，我们在1...i-1找到所有的满足a[j]>a[i]并且f[j]+1==f[i]，这样就说明i可以由j转移过来，那么我们把g[i]+=g[j]就好了，对于所有f[i]==1的，g[i]直接赋成1就好了。


然后我们再来考虑本题。

我们考虑一下什么样的方案是重复的？就是有同一个数字的。并且这个数字在同一个位置上。

转化成程序语言就是假设枚举到一个i时，存在一个j使得a[i]==a[j] && f[i]==f[j]，那么这个i与j显然就是完全等效的了，我们只需要一个，而i>j，所以直接把g[j]赋成0（直接去掉这个方案）就可以了。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=5010;
int a[N],f[N],g[N];
int res=-INF,n,tot=0;
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++)scanf("%d",&a[i]);
    for (int i=1;i<=n;i++){
        f[i]=1;
        for (int j=1;j<i;j++)
            if (a[i]<a[j])f[i]=max(f[i],f[j]+1);
        res=max(res,f[i]);
    }
    for (int i=1;i<=n;i++){
        g[i]=f[i]==1;
        for (int j=1;j<i;j++){
            if (a[i]==a[j] && f[i]==f[j])g[j]=0;
            if (a[i]<a[j] && f[i]==f[j]+1)g[i]+=g[j];
        }
    }
    for (int i=1;i<=n;i++)
        if (f[i]==res)tot+=g[i];
    printf("%d %d",res,tot);
    return 0;
}
```

---

## 作者：龙尊 (赞：8)

今天又来写题解了！  
## 剑气纵横三万里，一剑光寒十九洲！

------------
## 开门见山！  
最近一直在写DP，于是碰到了这道蓝蓝的题：  
#### [P1108 低价购买 ](https://www.luogu.com.cn/problem/P1108)！  
乍一看，这是道很简单的求最长下降子序列的题，但事实上并非如此！  
##### 他还要求你，输出能达到最大长度的不同方案数  
其实好像思想很简单，就是顺着退回去就好了，然后记录不同的方案数，但事实上，我试了一下，反正我是放弃了，因为他TLE了。。  
然后看了题解的写法，好像都是边Dp边记录（好吧其实我没看懂）  
所以我想了想，用了一个比较蠢的方法：  
##### 1.正常Dp
##### 2.对所有的DP结果按大小分类即DP长度分类
##### 那么，某一个数的dp结果是3，那么转移到他的方案书，就是，在他之前的，数值比他大的，dp结果为2的数方案数总和  
##### dp结果为n的数，就是序号在他之前，数值比他大，dp结果比他小1的各个数的方案数总和。  
##### 3.那么怎么去重呢？这个时候，我就用到了set的特性，相同的数值不会出现，这样就不会有重复的方案了。  
##### 那么显然，set里放的是某一位对应的数值，为了访问方便，可以再用vector维护每一个set，set的某一位的值，相对应着这个值对应的位，放在vector里。  
##### 如果将一个位置的数值放进相应的set时，set的长度不增加，说明方案重了，则对应的vector不将这个位置放入。
##### 那么每次dp结束后，就找到比这一位dp值小1的vector数组，将数组遍历一遍，将vector里每一位对应的位置上的方案数相加，就是这一位的方案数总和了。  
##### 最后将对应dp值最大的vector访问一遍，将对应位置上的方案数加起来，就是总方案数啦。  
##### 4.最后一个小点：当有这样一个点的时候 69 68 70 68 65  
##### 显然，第一个68放进去set【2】时，set【1】里有一个69，所以vector【2】里放入2，那么，set【2】中68对应的位置的方案书应该是2，因为69 68和70 68有两种方案，但是set放进68后，对应的值是1，因为下一个68不会被放进来，那么70 68这个点就没被统计到。  
##### 所以为了解决这个问题，当我们放入一个数值时，set长度不增加，我们就将vector访问一遍，看是哪个位置的值与当前值相等，将那位置对应的方案数变成当前位置的方案数，因为当前位置肯定在vector中记录位置的后面，因此可以保证大于等于，是正确的。  
    
    
#####  那么这就是全部过程了，好像挺繁琐的（确实挺繁琐的）。
##### 代码如下：  （时间复杂度算蒙了有没有大佬帮忙算一下）
```
#include<bits/stdc++.h>
using namespace std;
int n,a[5050];
long long maxn,ans,dp[5050],dpa[5050],l[5050];
vector< int >  v[5050];//v[i]对应的就是dp值为i的各个不同的数的位置
set< int > s[5050];//set[i]对应的就是dp值为i的各个不同的数的位置对应的数
int main(){
  cin>>n;

  
  dp[0]=0;
  a[0]=2147483647;
  v[0].push_back(0);
  dpa[0]=1;
  for(int i=1;i<=n;i++){
    cin>>a[i];
  }


  
  for(int i=1;i<=n;i++){
    for(int j=0;j<i;j++){
      if(a[i]<a[j]){
	dp[i]=max(dp[j]+1,dp[i]);//正常转移
      }
    }
    for(int j=0;j<v[dp[i]-1].size();j++){
      if(a[i]<a[v[dp[i]-1][j]])
      dpa[i]+=dpa[v[dp[i]-1][j]];//dp结果为n的数，就是序号在他之前，数值比他大，dp结果比他小1的各个数的方案数总和
    }
    
    s[dp[i]].insert(a[i]);
    if(s[dp[i]].size()>l[dp[i]]){
      v[dp[i]].push_back(i);
      l[dp[i]]++;
    }//set里放的是某一位对应的数值，再用vector维护每一个set，set的某一位的值，相对应着这个值对应的位，放在vector里
    else{
      for(int j=0;j<v[dp[i]].size();j++){
	if(a[v[dp[i]][j]]==a[i]){
	  dpa[v[dp[i]][j]]=dpa[i];
	}
      }
    }//当我们放入一个数值时，set长度不增加，我们就将vector访问一遍，看是哪个位置的值与当前值相等，将那位置对应的方案数变成当前位置的方案数，因为当前位置肯定在vector中记录位置的后面，因此可以保证大于等于，是正确的
  }


  
  for(int i=1;i<=n;i++){
    maxn=max(dp[i],maxn);
  }
  for(int i=0;i<v[maxn].size();i++){
      ans+=dpa[v[maxn][i]];
  }//最后将对应dp值最大的vector访问一遍，将对应位置上的方案数加起来，就是总方案数
  cout<<maxn<<" "<<ans<<endl;
  return 0;
}
```

------------
感谢阅读！
  
  by 龙尊



---

## 作者：封禁用户 (赞：7)

```cpp
//乍眼一看，哦？lis too ，于是就开始写代码
//结果呢,0% 仔细看了一下题目 嗯哼？计数？
//负责任的在写了一下 100%
//用t数组计数，转移方程（伪代码）：     
{
         if (a[j]>a[i]) and (f[j]+1=f[i]) 
          t[i]=t[i]+t[j] else
          if (a[j]=a[i]) and (f[i]=f[j]) then t[j]=0;
}
```
附上满分代码
```cpp
var
  n,m,i,j,k,p,max,ans:longint;
  a,f,t:array[0..100000] of longint;
begin
  readln(n);
  max:=1;
  for i:=1 to n do
  begin
     read(a[i]);
     f[i]:=1;
  end;
  for i:=1 to n do
  begin
     for j:=1 to i-1 do
       if (a[j]>a[i]) and (f[j]+1>f[i]) then
       begin
         f[i]:=f[j]+1;
         if f[i]>max then
           max:=f[i];
       end;
       if f[i]=1 then t[i]:=1;
     for j:=1 to i-1 do
       if (a[j]>a[i]) and (f[j]+1=f[i]) then//数量转移方程
          t[i]:=t[i]+t[j] else
          if (a[j]=a[i]) and (f[i]=f[j]) then t[j]:=0;//别忘了这里。。。去重，否则的话（嘿嘿嘿）
  end;
  write(max,' ');
  for i:=1 to n do
    if f[i]=max then
      ans:=ans+t[i];
    writeln(ans);//全加起来！！！！
end.
```

---

## 作者：lgnotus (赞：5)

这洛谷被usaco传染了？~~也开始养奶牛了~~

## 做法

这道题乍一看上去是一道简单的求最长下降子序列的题，可继续往下看，要算方案数，还要去重，蒻的要死的我找半天没找到样例的第二个方案，最后发了帖子，大佬才指出来是``69 68 67 62``



最长下降子序列模板自是不用说$if(a[i]<a[j])dp[i]=max(dp[i],dp[j]+1);i>j$

求出最长下降子序列以后在进行一次dp，定义**len[i]**表示以第i个数为结尾的最长下降子序列的长度，初始化$if(dp[i]==1)len[i]=1$，然后**j**循环从$1$~$i-1$扫一遍，不难发现，当$a[i]<a[j] \&\& dp[i]==dp[j]+1$时，表明$a[i]$和$a[j]$**可能**在一个最长下降子序列里，那么$len[i]+=len[j]$。



可是，问题来了，对于下面这组数据

``4 5 6 1 7 1``

最长下降子序列"$4,1$"与最长下降子序列"$4,1$" “看起来一样”（即子序列$a1,a4$与子序列$a_1,a_6$冲突）

还有子序列"$5,1$"与子序列"$5,1$"冲突，子序列"$6,1$"与子序列"$5,1$"冲突；

对于这种情况（即$a[i]==a[j]\&\&dp[i]==dp[j]$）时，我们需要把$len[i]-=len[j]$，即可去掉两个“看起来一样”的方案



### code

码风太丑，大佬们见谅

```cpp
#include<bits/stdc++.h>
using namespace std;
int ansa,ansb,n;
int a[5001],dp[5001],len[5001];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
        dp[i]=1;
        for(int j=1;j<=i;j++){
            if(a[i]<a[j])dp[i]=max(dp[i],dp[j]+1);
        }
        ansa=max(ansa,dp[i]);
    }
    for(int i=1;i<=n;i++){
        if(dp[i]==1)len[i]=1;
        for(int j=1;j<i;j++){
            if(a[i]<a[j]&&dp[i]==dp[j]+1)len[i]+=len[j];
            if(a[i]==a[j]&&dp[i]==dp[j])len[i]-=len[j];
        }
    }
    for(int i=1;i<=n;i++){
        if(ansa==dp[i])
            ansb+=len[i];
    }
    cout<<ansa<<' '<<ansb<<endl;
    return 0;
}
```


---

## 作者：szc2018302386 (赞：3)

首先我们可以想到这题是LIS的类型只不过是求一个最长子序列的方案数，方案数其实也可以dp。
其次我们想到的是求lis的n方算法和nlogn算法，这题我才用的是第一种，因为他可以记录一个最长子序列的末尾元素，这对于方案数的dp有很大的帮助的。

下面我们进行dp，首先先确定状态：

len[i]: i是状态-->表示以i结尾的最长子序列的长度。

p[i]: i是状态-->表示以i结尾的最长子序列的最多方案数

下面我们列状态转移方程：

1.dp子序列长度

if(num[i] < num[j])//表示i可以接到j结尾的降序列,num[i]存得是初始无序序列

len[i] = max(len[i], len[j] + 1);

2.当以i结尾的最长子序列的长度确定后我们dp以i结尾的最长子序列的方案数。

if(len[i] == len[j] && num[i] == num[j])//由题意可知此题要判重

p[j] = 0; // 消去前一个方案数，防止重复计数，注意不能令后面的方案数为0，不然第九个测试点会wa，至于为什么下面说。

if(len[i] == len[j] + 1 && num[i] < num[j])
//i可以继承j的方案数

p[i] += p[j]; //不能令p[i] = p[j]

下面我们来说为什么要消去前一个方案数，当两个子序列的长度相同，且末尾元素相同时，位于前一个元素结尾的最长子序列的方案数被包含在了后一个元素结尾的方案数中，我们可以想到，把前一个元素的所有方案数的子序列的最后一个元素删去代替之后一个元素，会发现子序列没有变化，则说明后一个元素具有前一个元素的所有方案数，而前一个元素的方案数不一定具有后一个元素的方案数，即p[j]<=p[i].用一个例子来说明。

8 2 9 2 // 前一个2的方案数为1（8 2），后一个2的方案数为2（8 2 和 9 2），这下可以清楚的知道两者之间的关系时单方面的包含关系，而不是等于关系。（这一点搞了半天才知道，半夜想到睡不着，太菜了）。

大概的思路已经说明具体细节在代码中提及
```cpp
#include<bits/stdc++.h>
using namespace std;

int len[5001];//dp长度 
long long p[5001]; //dp方案数
int num[5001];
//len[i]和p[i]分别代表以i结尾的最长子序列长度，和以i结尾的最长子序列的方案数 
int n;
int maxlen;
long long maxp;

void input();
void mydp();
void output();

int main()
{
	input();
	mydp();
	output();
	
	return 0;
}

void input()
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> num[i];
		len[i] = 1; //长度最小都为1
	}
}

void mydp()
{
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < i; j++)
		{ //先确定最长子序列的长度 
			if(num[i] < num[j])
			{
				len[i] = max(len[i], len[j] + 1);
			}
		}
		maxlen = max(maxlen, len[i]);
		//再确定以i结尾的最长子序列的方案数
		for(int j = 0; j < i; j++) 
		{
			if(num[i] == num[j] && len[i] == len[j])
			{ //去重 
				p[j] = 0; // 注意包含关系
			}
			
			else if((len[i] == len[j] + 1) && (num[i] < num[j]))
			{
				p[i] += p[j]; //继承方案数p[i]可能会继承多个方案数 所以不能用赋值语句
			}
		} 
		
		if(p[i] == 0) p[i] = 1;//即使不能继承也能自			成一种方案数 ，此步骤要注意，即使子序列长			度是1，也是一种方案数
	}
	
	for(int i = maxlen - 1; i < n; i++)
	{
		if(len[i] == maxlen)
		{//统计最长子序列的方案数
			maxp += p[i];
		}
	} 
}

void output()
{//输出，比较强迫症就是不喜欢在main里写东西
	cout << maxlen << ' ' << maxp << endl;
}

```







---

## 作者：yangyujia18 (赞：2)

这种题第二问总是很难qwq  
第一部分是很好求了，直接dp，f[i]表示前i天可以购买的最多次数  
f[i]=max(f[j]+1) j<i且gu[i]<gu[j]  
第二问比较麻烦，要在第一问结果已知情况下dp  
d[i]表示前i天最多次数的方案数  
默认初始化为0，f[i]==1时为1  
d[i]=sum(d[j]) j<i且gu[i]<gu[j]  
当f[i]==f[j]且gu[i]==gu[j]，即判定两种方案相同时，为防止重复计算，d[i]=0  
最后取max时要注意f[i]必须是最大的答案  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int gu[n+1],f[n+1],ans=0;
	long long d[n+1],ansd=0;
	memset(d,0,sizeof(d));
	for(int i=1;i<=n;i++)
		cin>>gu[i];
	for(int i=1;i<=n;i++)
	{
		f[i]=1;
		for(int j=1;j<i;j++)
			if(gu[i]<gu[j])
				f[i]=max(f[i],f[j]+1);
		ans=max(ans,f[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(f[i]==1)
			d[i]=1;
		for(int j=1;j<i;j++)
			if(f[i]==f[j]+1&&gu[i]<gu[j])
				d[i]+=d[j];
			else if(f[i]==f[j]&&gu[i]==gu[j])
				d[i]=0;
		if(f[i]==ans)
			ansd+=d[i];
	}
	cout<<ans<<' '<<ansd;
	return 0;
}
```


---

## 作者：ix35 (赞：2)

### **我用了一种比较神奇的方法**
#### **具体来说是树状数组优化dp...时间复杂度没有题解中的那种标准方法好，就算是提供一个思路吧**
大致想法：LIS就不说了，统计数量的时候以f[i][j]表示以i结尾长度为j的下降子序列数量，然后将每个数值看作树状数组的下标，子序列数量看作树状数组的值达到快速求和的目的，最终时间复杂度O(n^2\*logn）（我是开了O2才过的，不知道能不能优化一下常数直接过）

~~（虽然时间复杂度高而且难写但是容易想啊）~~

由于我们每次算出来的f值都存在树状数组里面，所以f[i][j]中的第一维可以省略，直接用f[i]表示当前长度为i的下降子序列的数量

那么转移方程就是f[i]=sum(i-1,a[i]-1),表示长度为i-1的已经出现过的下降子序列中末尾数字小于a[i]的f值之和（注意这里有n个树状数组分别维护长度为i的下降子序列的数量）

另外是几个细节处：

1. 离散化。条件中说a[i]的范围较大，所以先把a[i]压到n以内才好用树状数组，这里为了省事就直接把大数变小数，最后跑上升子序列就可以了。
1. 最后增加一个数。为了避免将所有f[ans]都加起来带来的重复性问题，在a数组最后加上一个大数，然后直接看截止到最后一个数的最长上升子序列个数就可以了。
1. 一开始要add(0,1,1)，并且离散化要从2开始。因为树状数组不能处理0的问题，所以数字从1开始编号，其实这里相当于在数组最前面加一个1（极小数），以这个数结尾长度为0的上升子序列数量是1个
1. 去重。这个有些玄学，改了很久才改对，大致就是每次往树状数组里加元素的时候检查一下本来有没有这个元素，如果有的话，就只要加这个元素与上一次出现时数量的差值**（因为在上一次出现过的上升子序列在这里还会出现一次，所以要排除掉）**

```
#include <bits/stdc++.h>
using namespace std;
const int MAXN=5010;
int n,ans1,cnt,p[MAXN],f[MAXN],c[MAXN][MAXN];
struct A {
	int p,q,v;
}a[MAXN];
bool cmp1 (A c,A d) {
	return c.p<d.p;
}
bool cmp2 (A c,A d) {
	return c.q<d.q;
}
int lowbit (int x) {
    return x&(-x);
}
int sum_ (int k,int x) {
    int ans=0;
    while (x>0) {
        ans+=c[k][x];
        x-=lowbit(x);
    }
    return ans;
}
void add_ (int k,int x,int v) {
    for (int i=x;i<=n+1;i+=lowbit(i)) {
        c[k][i]+=v;
    }
    return;
}
int main () {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) {
		scanf("%d",&a[i].p);
		a[i].p*=-1;
		a[i].q=i;
		p[i]=1;
	}
	sort(a+1,a+n+1,cmp1);
	cnt=2,a[1].v=2;
	for (int i=2;i<=n;i++) {
		if (a[i].p==a[i-1].p) {
			a[i].v=cnt;
		} else {
			a[i].v=++cnt;
		}
	}
	sort(a+1,a+n+1,cmp2);    //离散化
	a[n+1].v=++cnt;    //最后加一个大数
	for (int i=1;i<=n;i++) {
		for (int j=1;j<i;j++) {
			if (a[i].v>a[j].v) {
				p[i]=max(p[i],p[j]+1);
			}
		}
		ans1=max(ans1,p[i]);    //正常lis（这里用不用nlogn算法差不多，主要复杂度在后面）
	}
	printf("%d ",ans1);
	add_(0,1,1);    //开头加一个小数
	for (int i=1;i<=n+1;i++) {
		for (int j=1;j<=min(i,ans1+1);j++) {
			f[j]=sum_(j-1,a[i].v-1);
			add_(j,a[i].v,f[j]-(sum_(j,a[i].v)-sum_(j,a[i].v-1)));    //前面说过的“只要加这个元素与上一次出现时数量的差值”
		}
	}
	printf("%d",f[ans1+1]);
	return 0;
}
```


---

## 作者：zhy137036 (赞：1)

这道题很有意思，也有点难，很考查选手 dp 能力，写篇题解总结一下。

## 题意简述

- 给你一个长为 $n$ 的序列。
- 你需要求出这个序列的最长下降子序列的长度和方案数。
- 两个子序列选的数不同但值相同算作一种方案。

## 最长下降子序列的长度

第一问有复杂度 $O(n\log n)$ 的算法，但是因为 $O(n^2)$ 能过，而且第二问是 $O(n^2)$ 的，所以采用更简单的 $O(n^2)$ 算法。

设 $f_i$ 表示最长的以第 $i$ 个数结尾的下降子序列的长度。

$$\large f_i=\max_{j=1}^nf_j+1\qquad\qquad(a_j>a_i)$$

解释：枚举每一个可以作为倒数第二个数的数 $j$，用 $f_j$ 更新 $f_i$。

注意 $f_i$ 的初值应该为 $1$。

## 最长下降子序列的方案数

去重比较麻烦，先不考虑。

### 不去重

设 $g_i$ 表示以第 $i$ 个数结尾的最长下降子序列的数量。

$$\large g_i=\sum_{j=1}^ng_j\qquad\qquad(a_j>a_i)$$

挺好理解的，就是将累加每一个符合条件的 $g_j$。

但是“符合条件”只有这一个条件吗？不是。

试想如果 $f_j$ 过小，则以 $a_j$ 为倒数第二个数的序列并不是最长子序列，不应统计进来，所以还要添加一个条件：

$$\large g_i=\sum_{j=1}^ng_j\qquad\qquad(a_j>a_i)\quad(f_j=f_i-1)$$

注意如果 $g_i$ 为 $0$，说明这个数是目前最大的，应该赋为 $1$。

### 去重

容易想到每次转移时判断 $a_j$ 是否重复，但是这样并不好办。

换个角度想，如果已知两个数 $a_i,a_j(j<i)$ 相等，那后面的数转移时只能从 $a_i$ 转移，因为以 $a_j$ 结尾的序列一定可以在以 $a_i$ 结尾的序列中找到。

总结一下，如果两个数 $a_i,a_j(j<i)$ 相等，那在区间 $(j,i)$ 的数只能从 $a_j$ 转移，$>i$ 的数只能从 $a_i$ 转移。

所以在上述不去重的算法基础上，做如下改动：如果 $a_i=a_j$，就应该将 $a_j$ 无效掉，比如将 $g_j$ 归零。

## 代码

代码中边读入边计算 $f_i$ 和 $g_i$，最后统计所有 $f_i=\max$ 的 $g$。

```cpp
#include<iostream>
#include<algorithm>
#include<memory.h>
using namespace std;
unsigned int n,mx,a[5010],f[5010],g[5010];
//n,a,f,g意义同上，mx代表最长的长度。
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i]=1;//先赋初值
		for(int j=1;j<i;j++)
			if(a[i]<a[j])
				f[i]=max(f[i],f[j]+1);
		mx=max(mx,f[i]);//更新mx
		for(int j=1;j<i;j++){
			if(f[i]==f[j]+1&&a[i]<a[j])//如果符合条件就更新
				g[i]+=g[j];
			if(a[i]==a[j])//如果相同就无效掉j
				g[j]=0;
		}
		if(!g[i])g[i]=1;//如果没有就说明自己就是最长子序列。
	}
	unsigned int ans=0;
	for(int i=1;i<=n;i++)
		if(f[i]==mx)ans+=g[i];
	cout<<mx<<' '<<ans<<endl;
	return 0;
}
```

---

## 作者：jins3599 (赞：1)

翻了翻之前没$A$掉的题..翻到了这道。

第一问求$LIS$很简单。

主要是第二问的方案数。

按照以往的套路，求$dp$结果的方案数一般都是在$dp$**数组上进行**$dp$

我们设数组$f_i$为$dp$数组，$g_i$为方案数统计数组.

那么我们首先把$f$给$dp$一遍，之后我们对$g$进行处理。

- 若两个$f$的$LIS$相同，也就是说`f[i]=f[j] 且 a[i]=a[j]`时，把前一个的方案数置为零。

- 若$f_i$是能从$f_j$继承过来的，我们就让$g_i=g_i+g_j$

- 若进行了上述所有操作后，$g_i$仍为零，那我们就让他更新为一。

然后这道题就顺利完成了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5005;

int a[N] , n , f[N] , g[N] = {0 , 1} ,ans1 , ans2;

int main ()
{
    cin >> n;
    for(int i = 1 ; i <= n ; ++ i) cin >> a[i];
    for(int i = 1 ; i <= n ; ++ i) {
        f[i] = 1;
        for(int j = 1 ; j < i ; ++ j) 
            if(a[j] > a[i]) f[i] = max(f[i] , f[j] + 1);
        for(int j = 1 ; j < i;  ++ j) {
        	if(f[j] == f[i] && a[j] == a[i]) g[j] = 0;
			else if(f[j] + 1 == f[i] && a[j] > a[i]) g[i] += g[j];
		}
		if(!g[i]) g[i] = 1;
		ans1 = max(ans1 , f[i]);
    } 
    for(int i = 1 ; i <= n; ++ i) if(f[i] == ans1) ans2 += g[i];
    cout << ans1 << ' ' << ans2;
    return 0;   
}
```

---

## 作者：八重樱 (赞：1)

/\*
这道题数据范围太水了

用最大流是O(NlogN)的

不过既然给了O(N^2)的数据

那就用O(N^2)的DP做好了

<DEL=1>其实是我不会最大流</DEL> 

\*/
```cpp
#include<cstdio>
using namespace std;
inline long long llin(){register char c=getchar();while(c<48||c>57)c=getchar();register long long a=0;while(c>47&&c<58){a=(a<<1)+(a<<3)+c-48;c=getchar();}return a;}
inline void llot(long long a){if(a>9)llot(a/10);putchar(a%10+48);}
long long rbq[5555],wyf[5555],gc[5555]; 
//以上定义分别是:原数组,以rbq[i]结尾的最长序列长度,以rbq[i]结尾的最长序列方案数
int i=0; 
int main()
{
    long long n=llin();
    for(;i<n;i++)
    {
        rbq[i]=llin();
        wyf[i]=1;
        for(int j=0;j<i;j++)if(rbq[i]<rbq[j]&&wyf[i]<=wyf[j])wyf[i]=wyf[j]+1;
        //如果rbq[i]比前面的rbq[j]小,那么: 
        //以rbq[i]结尾的最长序列长度wyf[i]为MAX(wyf[j])+1
        for(int j=0;j<i;j++)if(rbq[i]==rbq[j]&&wyf[i]==wyf[j])gc[j]=0;//祛重 
        if(wyf[i]==1)gc[i]=1;else{gc[i]=0;//初始化
        for(int j=0;j<i;j++)if(rbq[i]<rbq[j]&&wyf[i]==wyf[j]+1)gc[i]+=gc[j];}
        //如果wyf[i]由wyf[j]+1得来,那么:
        //以rbq[i]结尾的最长序列方案数gc[i]为sum(gc[j]) 
    }
    rbq[i]=-1;//假装再放进去一个很小的数 
    wyf[i]=1;
    gc[i]=0;
    for(int j=0;j<i;j++)if(wyf[i]<=wyf[j])wyf[i]=wyf[j]+1;
    for(int j=0;j<i;j++)if(wyf[i]==wyf[j]+1)gc[i]+=gc[j];
    llot(wyf[i]-1);
    putchar(32);
    llot(gc[i]);
    return 0;
}
```

---

## 作者：Tardis (赞：1)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define N 5001
int dp1[N],dp2[N],a[N];
//dp1 lis
//dp2记录的是方案数 
//dp2[i]=Σdp2[j] 如果不去重复的话这是非常完美的
```
但是去重该怎么做呢？
有这个语句 if(dp1[i]==dp1[j]&&a[i]==a[j]) dp2[j]=0;这个语句可以保证不重复 我们举个例子

5   4   3    5   4   3

dp1 1   2   1    1   2   3

dp2 1   1   1    1   1   1

当到第三个数是没有重复 但是到了第四个数 那么它满足了语句 因为我们的dp2统计是从1扫到i-1那么他会扫到两边5 但实际上是一样的 出现了重复！ 因为5是lis第一个数 那么他前面没有数 所以 重复 直接将第一个5的dp2变成0 好的

现在到了第二个4(第5个数) 此时满足语句。那么此序列一定是一样的 5 4 和5 4 加入不是一样的比如说7 4和5 4那么最长序列为什么不是 7 5 4呢 矛盾了 假如是5 4和7 4 那么dp2[第一个4的位置]也=0，因为dp2[第二个4的位置]已经加上了这个方案数 下一次 直接从最后一个进行转移

也就是说 我们只记录 最长的 最后一个相同的数的dp2值 让最后一个 已经记录好之前的dp2值就OK了

```cpp
int n,ans,tot;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        dp1[i]=1;
        for(int j=1;j<i;j++)
        if(a[j]>a[i]) dp1[i]=max(dp1[i],dp1[j]+1);
        ans=max(ans,dp1[i]);
    }
    //printf("%d",ans);
//以上 lis 
    for(int i=1;i<=n;i++)
    {
        if(dp1[i]==1) dp2[i]=1;//没法转移初值为0
        for(int j=1;j<i;j++)
        {
            if(dp1[i]==dp1[j]+1&&a[i]<a[j]) dp2[i]+=dp2[j];//转移
            if(dp1[i]==dp1[j]&&a[i]==a[j]) dp2[j]=0;//去重
        }
    }
    for(int i=1;i<=n;i++)
    if(dp1[i]==ans) tot+=dp2[i];
    printf("%d %d",ans,tot);
}
```

---

## 作者：xzyxzy (赞：1)

这是一道很坑的题

不会判重，于是乎在书上找到了，照着打了一遍，发现RE了

啊啊啊**数组越界了**


于是乎改啊改，终于过了


其实难点只有两个

一个是常规的动归——**记录最长下降子序列长度**

这个就不详细讲解了，是最基础的动归


第二个嘛，，呵呵——**方案计数**

在草稿纸上打表可知，方案数可以单独弄出一个数组，然后进行运算，当遇到比当前更优的解时，延续那个解的方案数、

当遇到与以前一样优的解时，将那个解的方案数加到q[i]里

那么，，呵呵——**判重**

于是乎书上告诉我用一个bool数组，下标表示其已得到解的数值大小，用1来表示它用到过，避免下次再用

可是啊，，粗心的书没有看到数据范围可是到了**2147483648**啊/已哭晕在厕所/

RE了又RE，总算想到了个好办法：将搜到的值存在一个数组里，顺带一个整数指向它的存储位置，这样每次搜到最优解就讲它的存储位置初始化到1，再判断时就用一个check函数，也优化了原来的时间


ps: register是什么不用管它


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
int n;
inline int read()
{
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    register int h=0;
    while(ch>='0'&&ch<='9')
    {
        h=h*10+ch-48;
        ch=getchar();
    }
    return h;
}
int a[5012];//记录数值
int lon[5012];//记录队列长度
int q[5012];//记录前驱元素数量
int b[5012];//避免重复 
int t=0;
int check(int a)
{
    for(int i=1;i<=t;i++)
        if(b[i]==a) return 0;
    return 1;
}
int main()
{
    n=read();
    for(register int i=1;i<=n;i++) a[i]=read(); 
    for(register int i=1;i<=n;i++) lon[i]=1;
    for(register int i=1;i<=n;i++) q[i]=1;
    for(register int i=2;i<=n+1;i++)//从2开始是因为不会执行i等于1的情况，到n+1结束是因为为了方便统计所有这一串费用的方案次数之和 
    {
        register int maxlon=0;
        for(register int w=i-1;w>=1;w--)
        {
            if(a[w]>a[i]&&lon[w]>maxlon)//如果下降了而且长度长
            {
                maxlon=lon[w];
                t=0;
                b[++t]=a[w];
                q[i]=q[w]; 
            }    
            else 
              if(a[w]>a[i]&&lon[w]==maxlon&&check(a[w])==1)
              {
                  q[i]+=q[w];
                  b[++t]=a[w];
              } 
        }
        lon[i]=maxlon+1;
    }
    cout<<lon[n+1]-1<<" "<<q[n+1]; 
    return 0;    
}
```

---

## 作者：HeHere (赞：1)

**最长下降子序列+最佳方案数统计**


加法原理：如果一件事有k个选择，每个选择有![](https://latex.codecogs.com/gif.latex?\%20a\_i)种方案，则一共有![](https://latex.codecogs.com/gif.latex?%5Csum%20%7Ba\_i%7D)种方案。




```cpp
f[i] = max{f[j] | a[j] > a[i]}
(if there is no f[j] available, f[i]=1)
//最长下降子序列， 不解释
d[i] = sum(d[j] | f[j]=f[i]-1)
(if f[i]=0, d[i]=1)
//到达本节点的方案数，就是到达前继状态的方案和
```
本来这题就这样愉快地结束了，然而计数要求是：
当2种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这2种方案被认为是相同的。


//其实是为了便于思考，递进式构建转移方程

#d[i]的求解方式

d[i] = sum(d[j] | f[j]=f[i]-1)

- 对于a[j]相同的，只能取最大的d[j]，也就是j最大的。

- 当f[k]相同时，d[k]是单调上升的，于是我们只要取最后面的j。


//这话不好理解我承认

所以求d[i]的时候，把j从i-1向前扫到0，统计结果。

怎么保证同一个a[j]只取一次呢？

几个方案：

1. v[a[i]]表示a[i]是否统计过，不考虑a值同等的d。每次清零，时间要O(65536)一趟。//65536=2^16，于是超时，压常数见下面 @似水年华 的实现，TA没有重点将这个，但TA的题解不错。

2. 用集合(set)记录a[i]，O(p log p)一趟，p是符合条件的前继状态数。//我的方法，暂时没有人提到。


代码如下：

```cpp
    memset(f, 0, sizeof(f));
    memset(d, 0, sizeof(d));
    a[n+1] = -maxA;//放在最后的无穷小，方便输出答案。
    for(int i=1; i<=n+1; i++){
        f[i] = 1;
        for(int j=1; j<i; j++){
            if(a[j] > a[i]){
                f[i] = max(f[i], f[j] + 1);
            }
        }
        if(f[i] == 1){
            d[i] = 1; continue;//不开set加速
        }
        
        set <int> s;
        for(int j=i-1; j>0; j--){
            if(a[j] > a[i] && f[j] == f[i]-1 && !s.count(a[j])){//短路运算，进一步加速
                d[i] += d[j];
                s.insert(a[j]);
            }
        }
    }
    
    printf("%d %d\n", f[n+1]-1, d[n+1]);
    //最后一个要占一个长度，方案数不变
```

于是我交了“平衡树”的标签。


然而一切终究O(n^2)，不如 @55555g 的O(nlogn)算法好。


---

## 作者：Templ_1 (赞：1)

这个题..有以下几个坑

(f1[i]表示最长子序列，f2[i]表示方案数，arr[i]为读入数据)

例:
| arr | 68 69 54 64 68 64 70 67 78 62 98 87 |
| f1  | 3  4  1  2  3  2  3  2  2  1  2  1  |
| f2  | 2  2  1  1  0  0  1  1  1  1  1  1  |
^(下面有解释)

WA的童鞋检查一下这几点

1.方案去重 这里给出

     if(f1[i] == f1[j] && arr[i] == arr[j]) f2[j] = 0;

2.最大购买数(f1[i])不唯一

错误代码:

  loc=maxi=-1;

  for(int i = 0; i < N; i++)

    if( f1[i] > maxi) maxi = f1[i],loc = i;

....
   printf("%d ",f2[loc]);

正解:


```cpp
 int ans=0;
  for(int i=0; i<N;i++)
    if(f1[i] == maxi)
      ans+=f2[i];
  cout<<ans;
```
代码：






     



```cpp
#include<iostream>
#include<fstream>
//#define cin fin
#define ll long long
using namespace std;
//ifstream fin("test.in");
// f1[i] = max{ arr[x] > arr[i] & x < i | f1[x] + 1 };
// calculate f2[x]
// if( f1[y] == f1[x] + 1 && arr[y] < arr[x] ) f2[x]++;
const int MAXN = 5005;
int f1[MAXN];
ll f2[MAXN];
ll arr[MAXN];
int N;
int loc;
int maxi = -1;
void read()
{
  cin>>N;
  for(int i = 0; i < N; i++)
    cin>>arr[i];
}
void dp1()
{
  for(int i = 0; i < N; i++)
    f1[i] = 1;
  for(int i = N-1; i > -1; i--)
    for(int j = i+1; j < N; j++)
      {
    if(arr[i] > arr[j])
      f1[i] = max(f1[i], f1[j] + 1);
      }
  for(int i = 0; i < N; i++)
    if( f1[i] > maxi) maxi = f1[i],loc = i;
    cout<<maxi<<' ';
}
void dp2()
{
  for(int i = 0; i < N; i++)
    if(f1[i] == 1)  f2[i] = 1;
  for(int i = N-1; i > -1; i--)
    for(int j = i+1; j < N; j++)
      if( f1[i] == f1[j] + 1 && arr[i] > arr[j])
    {
      f2[i]+=f2[j];
    }
      else if(f1[i] == f1[j] && arr[i] == arr[j]) f2[j] = 0;
  int ans=0;
  for(int i=0; i<N;i++)
    if(f1[i] == maxi)
      ans+=f2[i];
  cout<<ans;
}
int main()
{
  read();
  dp1();
  dp2();
  printf1();
  printf2();
}

```

---

## 作者：heheabc (赞：1)

最大下降子序列，这道题的难点是要求拥有最大购买次数的不同方案数。

t[i]表示前i个股票的不同方案数，显然的，如果存在f[j]==f[i] && a[j]==a[i](1<=j<i)j会比i更优，所以就将t[i]赋为0，如果f[i]==f[j]+1(1<=j<i)，那么i可以从j转移过来，所以t[i]=t[i]+t[j]。最后统计t[i](1<=i<=n && f[i]==ans)的和。

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans,sum,a[10005],f[10005],t[10005];
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=n; i++)
    {
        scanf("%d",&a[i]);
        f[i]=1;
        for (int j=1; j<i; j++)
            if (a[j]>a[i]) f[i]=max(f[i],f[j]+1);
        if (f[i]==1) t[i]=1;
        for (int j=1; j<i; j++)
            if (f[i]-1==f[j] && a[j]>a[i]) t[i]+=t[j];
            else if (f[i]==f[j] && a[j]==a[i]) t[j]=0;
        if (f[i]>ans) ans=f[i];
    }
    for (int i=1; i<=n; i++)
        if (f[i]==ans) sum+=t[i];
    printf("%d %d\n",ans,sum);
    return 0;
}
```

---

## 作者：55555g (赞：1)

没人写二分栈的做法，我来写一个。

题意很好理解，求最长下降子序列，并求方案数。

我们定义stack[i]表示长度为i的下降子序列的最后一个数的大小。Len表示做到当前的时候找到的最长下降子序列长度。f[i]表示以第i个数结尾的最长下降子序列长度。

对于序列中的一个数a[i]来说，我们需要知道它可以接到哪个数的后面得到最长。于是在栈中进行二分查找，查找区间是(0,len)，找到栈中最后一个比a[i]大的数的位置。假设这个位置是p，那么f[i]=p+1。同时要对栈进行维护，如果stack[p+1]<a[i]，那么用a[i]替换stack[p+1]，因为留在栈中的数尽量越大越好。这样就能保证栈的单调性。

然后对于a[i]我们需要知道它的方案数，换言之就是它可以接到哪几个数的后面，于是定义w[i]表示以i结尾的最长下降子序列的方案数，可以得出w[i]=sum(w[j])，前提是(j<i,a[j]>a[i],f[j]+1=f[i])。

于是可以想到在栈中采用挂链的方式，将某些以它结尾的长度相等的数挂在stack[i]上，每次二分找出p后只要在p的那条链上找符合要求的w[j]，累加起来就行了。要注意的是二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这2种方案被认为是相同的。也就是说两个相同的序列就算位置不同也只能算一次。所以对于一条链来说，相同的数只能保留一个。

这样做的时间复杂度是O(nlogn)，对于5000的数据只要1ms，就算是100000的数据也能秒过。

附上代码

```pascal
var i,p,n,next,len:longint;
    a,w,q,h,stack,f:array[0..5010] of int64;
    s:int64;

function ef(l,r,x:longint):longint;
var mid:longint;
begin
if l=r then exit(l);
mid:=(l+r+1) shr 1;
if stack[mid]<=x then exit(ef(l,mid-1,x))
else exit(ef(mid,r,x));
end;

begin
read(n);
for i:=1 to n do read(a[i]);
stack[0]:=maxlongint;
inc(n);
a[n]:=-maxlongint;//在数列的最后放一个负无穷，那么所以的方案就直接汇集到n+1
for i:=1 to n do
        begin
        p:=ef(0,len,a[i]);
        s:=0;
        next:=h[p];
        while next<>0 do//在链中寻找合法的w[j]
                begin
                if a[next]>a[i] then inc(s,w[next]);
                next:=q[next];
                end;
        w[i]:=s;
        inc(p);
        f[i]:=p;
        if p>len then len:=p;
        if f[i]=1 then w[i]:=1;
        if stack[p]<a[i] then stack[p]:=a[i];//维护栈
        next:=h[p];
        while next<>0 do//将链中相同的数去掉
                begin
                if a[i]=a[next] then w[next]:=0;
                next:=q[next];
                end;
        q[i]:=h[p];h[p]:=i;//用静态链表挂链，h是一个表头，表示长度为i的最后一个数的位置
        end;
writeln(len-1,' ',w[n]);//最后那个加上去的负无穷算了一个长度，要减掉
end.
```

---

## 作者：似水年华 (赞：1)

##算法分析

先探索一下样例，最大购买次数为4次，共有2中方案，分别是69 68 64 62、69 68 67 62。

我们发现，这道题实际上是在一个数列中选出一个序列，使得这个序列是下降序列（即序列中的任意一个数必须大于它后面的任何一个数），且要使这个序列的长度最长。但是这道题要输出总的方案数，这就需要对原有的求解过程做一些变动。求方案总数最主要的是要剔除重复方案。当第2行N个数其中有两个以上价格相同时，可能就会产生重复方案。产生重复方案时，显然后面价格的要比前面的更优，因为以后面的价格结尾的最长下降序列的总数肯定不会比前一个少，而且其方案必定囊括了前面这个价格的所有方案。因此，在解题过程中，我们就可以只考虑相同价格中后面的那个。推广开来，如果当前状态之前存在重复的状态，我们只要考虑离当前状态位置最近的那一个即可。

设f[i]表示到第i天，能够买的最大次数，显然有：f[1]=1；f[i]=max{f[j]+1}(1<=j<=i-1，且ok[j]=1)，ok[j]=1表示相同价格时，该位置更优。

##参考程序

```cpp 
#include<stdio.h>
#include<string.h>
bool ok[50010];
int a[5010],b[5010],f[5010];
int n,i,j,k,max,num;
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    b[1]=1;
    f[1]=1;
    for(i=2;i<=n+1;i++)
    {
        max=0;
        f[i]=1;
        for(j=i-1;j>=1;j--)
            if(a[i]<a[j])
                if(b[j]>max)//b[j]表示以第j天结尾的最大购买次数 
                {
                    max=b[j];
                    memset(ok,1,sizeof(ok));
                    ok[a[j]]=0;
                    f[i]=f[j];
                }
                else
                    if(b[j]==max && ok[a[j]])
                    {
                        ok[a[j]]=0;
                        f[i]+=f[j];
                    }
        b[i]=max+1;
    }
    printf("%d %d",b[n+1]-1,f[n+1]);
}
```

---

## 作者：1507zhanyu (赞：1)

···cpp


//此题为lis的计重求方案数题，lis简单，计重难

//首先若不计重 ，则将代码中有关chong[]的东西去掉，那么g[]继承前一状态的方案数

//这样 像6 6 6 6 6 这样的数据会输出1 5 而答案为1 1

//其实如果i<j且a[i]==a[j],则j的f与g是优于或等于i的，转移时不考虑i(值标记“chong”来实现)，

//只考虑j；可将第二重循环倒过来实现这一点

```cpp
//最后统计时道理同上 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=5050,M=50000;//其实数据大小我也不知道，瞎猜一个M 
int a[N],f[N],g[N];
bool chong[M]={false};
int n;
int main() 
{
      scanf("%d",&n);
      fill(f,f+N,1);
      fill(g,g+N,1);
      for(int i=1;i<=n;i++)scanf("%d",&a[i]);
      for(int i=2;i<=n;i++){
          memset(chong,0,sizeof(chong));
          for(int j=i-1;j>=1;j--)
              if(a[i]<a[j]&&chong[a[j]]==false){
                  if(f[i]==f[j]+1)g[i]+=g[j];//与当前等长的序列g累加 
                  if(f[i]<f[j]+1){
                    f[i]=f[j]+1;
                    g[i]=g[j];//有更长的序列，g则更新 
                  }
                  chong[a[j]]=true;
              }
      }    
      int maxn=0,tot=0;//max为fmax ；tot为对应的g 
      memset(chong,0,sizeof(chong));
      for(int i=n;i>=1;i--)
      {
           if(chong[a[i]])continue;
           if(f[i]>maxn){
             maxn=f[i];
             tot=g[i];
          }
          else if(f[i]==maxn)
             tot+=g[i];
          chong[a[i]]=true;
      }
      cout<<maxn<<" "<<tot<<endl;
      return 0;
}
```
```cpp

---

## 作者：noip_Tom (赞：1)

```cpp
//其实这个题是导弹拦截的加强版吧
//思路：1.求LIS（最长不升子序列）
//           2.求方案数
//1.dp[i]=max( dp[j]+1,1)  基本功吧，不解释
//2.方案数有点难，要递推如下：
```
/\*

```cpp
for (i=1;i<=n;i++) 
for (j=1;j<i;j++) 
        if (dp[i]-1==dp[j]&&m[j]>m[i]) t[i]+=t[j];//注意相等
        else if (m[j]==m[i]&&f[i]==f[j]) t[j]=0;*/
//m[i]是股票价格
//说实在话讲起来方案数真的很玄看代码吧
#include <iostream>
#include <cstdio>
#define N 5001
using namespace std;
int n,i,j,Max,ans;
int m[N],f[N],t[N];
int main ()
{
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>m[i];
        for (j=1;j<i;j++) 
            if (m[j]>m[i]&&f[j]>f[i])
                f[i]=f[j];
                f[i]++;
            if (f[i]==1) t[i]=1;
        for (j=1;j<i;j++) 
        if (f[i]-1==f[j]&&m[j]>m[i]) t[i]+=t[j];
        else if (m[j]==m[i]&&f[i]==f[j]) t[j]=0;
        if (f[i]>Max) Max=f[i];
    }
    ans=0;
    for (i=1;i<=n;i++) if (f[i]==Max) ans+=t[i];
    cout<<Max<<" "<<ans;
    return 0;
}
```

---

## 作者：wmxwmx (赞：1)

简单点说就是第二问再搞一个数组就好了，运算可以和主循环放在一起，具体见代码。



```delphi

var n,i,j,max,ans:longint;
    m,f,t:array[1..5000]of longint;

begin
    readln(n);
    fillchar(f,sizeof(f),0);
    fillchar(t,sizeof(t),0);
    max:=0;
    for i:=1 to n do
    begin
        read(m[i]);
        for j:=1 to i-1 do
        if (m[j]>m[i])and(f[j]>f[i]) then
        f[i]:=f[j];
        inc(f[i]);
        if f[i]=1 then t[i]:=1;
        for j:=1 to i-1 do
        if (f[i]-1=f[j])and(m[j]>m[i]) then inc(t[i],t[j])
        else if (m[j]=m[i])and(f[i]=f[j]) then t[j]:=0;
        if f[i]>max then max:=f[i];
    end;
    ans:=0;
    for i:=1 to n do
    if f[i]=max then inc(ans,t[i]);
    writeln(max,' ',ans);
end.

```

---

## 作者：TsReaper (赞：1)

本题第一问是最长下降子序列，可以用O(n^2)的算法解决。

第二问求方案数比较有难度，因为要去掉重复的方案。

我的做法是：假定第i个数为a(i)，以它为结尾的最长下降子序列方案数为c(i)，则令j从i-1到1进行枚举，如果存在a(j1) = a(j2) (j1<j2)则不统计j1的答案。因为在两个数相等的前提下，排在后面的数对答案的贡献是不劣于前面的数的。这样不仅统计到了最长的子序列，还避免了重复统计。


---

## 作者：AKB48 (赞：1)

【问一】最长下降子串

状态的划分len[i]表示以a[i]为开头共的最长不下降子串的长度，则

Len[i]:=max{len[j]}+1   (1<=i<j<=n,a[i]>a[j])

也就是说由len[i]选择它的后一个序列，储存也是以len[j]为开头，这个状态一定是最大的。因为len[i]与len[j]只有大小和顺序关系，在子串上由于开头不一，存在独立，它满足最优子结构。算法n(n^2/2).

【问二】输出方案

这是本题最难的一点，难在一个误区，如果a[i]>a[j]  len[i]=len[j+1]则f[i]:=f[i]+f[j]。这样算法很完美了吗？我们不难举出反例：3，2，2因为“当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这2种方案被认为是相同的”比如“第一个和第二个”与“第一个与第三个”是一样的。如果这样还要枚举与记录重复的数据，上述方程式矛盾的。有以下两种方法：

（1）    采用列表记录下每一个方案最后在去重相乘，这个方法是对的，但是列表是一种高级的数据结构操作麻烦，不论是竞赛时间还是调试程序都不推荐使用。

（2）    J从i-1往1循环，如果碰到a[i]=a[j]则跳出循环，因为f[i]作用于循环中的f[j]，如果两个价格相等的话则f[j]>=f[i]，前面的元素已经加过一个这个价格的方案了，而且方案数可能还比这个大，就不必再加了。


---


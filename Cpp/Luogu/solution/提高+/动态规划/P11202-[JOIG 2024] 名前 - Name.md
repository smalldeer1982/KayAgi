# [JOIG 2024] 名前 / Name

## 题目描述

JOI 君和 IOI 君决定养一只狗。经过讨论，他们决定给狗取一个满足以下所有条件的名字：

1. 名字必须仅包含大写字母和小写字母；
2. JOI 君最喜欢的字符串是长度为 $N$ 的字符串 $S$，名字必须包含 $S$ 作为子序列；
3. IOI 君最喜欢的字符串是长度为 $M$ 的字符串 $T$，名字必须包含 $T$ 作为子序列；
4. 名字中任意两个相同的字符之间必须间隔至少 $K$ 个其他字符。

以上的所有条件**区分大小写**，例如，我们将 `A` 和 `a` 视为不同的字符。

一个字符串的子序列定义为删除其中若干个字符（可以为 $0$ 个）形成的字符串。例如该字符串为 `algorithm`，那么 `ai` 和 `lgtm` 是它的子序列，而 `joi` 和 `logarithm` 不是。

由于他们都认为名称越短越好，所以他们决定选用满足上述四个条件的且最短的名字。

给定字符串 $S,T$ 和整数 $K$，请你求出满足条件的名字的最短长度。

## 说明/提示

#### 【样例解释 #1】

字符串 `hottokeiki` 满足条件。可以证明，不存在长度更小的字符串满足条件，故答案为 $10$。

该样例满足子任务 $1,3,4,7,8$ 的限制。

#### 【样例解释 #2】

相较于上一个样例，仅有 $K$ 的值发生变化。

在该样例中，上一个样例的输出 `hottokeiki` 不满足第四个条件（任意两个相同的字符之间必须间隔至少 $K$ 个其他字符），因为两个 `t` 中没有其他字符。

而字符串 `hotNtokeiki` 满足条件，可以证明，不存在长度更小的字符串满足条件，故答案为 $11$。

该样例满足子任务 $2,3,5,6,7,8$ 的限制。

#### 【样例解释 #3】

相较于前两个样例，仅有 $K$ 的值发生变化。

在该样例中，上一个样例的输出 `hotNtokeiki` 不满足第四个条件（任意两个相同的字符之间必须间隔至少 $K$ 个其他字符），因为两个 `t` 之间仅有 $1$ 个字符，两个 `k` 之间仅有 $2$ 个字符，两个 `i` 之间仅有 $1$ 个字符。

而字符串 `hotarutokeiyuki` 满足条件，可以证明，不存在长度更小的字符串满足条件，故答案为 $15$。

该样例满足子任务 $3,8$ 的限制。

#### 【样例解释 #4】

字符串 `OJouhorinpikku` 满足条件。可以证明，不存在长度更小的字符串满足条件，故答案为 $14$。

请注意上面的条件区分大小写，因此诸如 `jouhorinpikku`（长度为 $13$）这样的字符串**不**符合条件。

该样例满足子任务 $4,7,8$ 的限制。

#### 【样例解释 #5】

字符串 `CoMaMiTeRTeRaCe` 是长度最小且满足条件的字符串，故答案为 $15$。

该样例满足子任务 $5,6,7,8$ 的限制。

#### 【样例解释 #6】

字符串 `JOIGEIGOI` 是长度最小且满足条件的字符串，故答案为 $9$。

该样例满足子任务 $7,8$ 的限制。

#### 【数据范围】

- $1\le N,M\le 500$；
- $0\le K\le 3$；
- $S,T$ 中仅包含大写字母和小写字母。

#### 【子任务】

1. （$2$ 分）$S=T$，$K=0$；
2. （$7$ 分）$S=T$，$K=1$；
3. （$16$ 分）$S=T$；
4. （$17$ 分）$K=0$；
5. （$13$ 分）$K=1$，$N,M\le 25$；
6. （$15$ 分）$K=1$；
7. （$20$ 分）$K\le 2$；
8. （$10$ 分）无附加条件。

## 样例 #1

### 输入

```
10 10 0
hottokeiki
hottokeiki```

### 输出

```
10```

## 样例 #2

### 输入

```
10 10 1
hottokeiki
hottokeiki```

### 输出

```
11```

## 样例 #3

### 输入

```
10 10 3
hottokeiki
hottokeiki```

### 输出

```
15```

## 样例 #4

### 输入

```
6 9 0
Jouhou
Orinpikku```

### 输出

```
14```

## 样例 #5

### 输入

```
9 7 1
CoMMiTTee
TeRRaCe```

### 输出

```
15```

## 样例 #6

### 输入

```
6 8 2
JOIIOI
JOIGEGOI```

### 输出

```
9```

# 题解

## 作者：Fated_Shadow (赞：9)

## 前言

看了下题解区，全是 bfs 写法，所以专门搓了一篇 dp 来补一下。

## 思路

发现去掉 $k$ 的限制（即 $k=0$ 的时候），就是类似公共子序列的做法，但是有 $k$ 的限制，这部分不太好处理。容易想到直接压进去前 k 位字母分别填了什么，这样是正确的，但是复杂度不允许，时空间 $O(52^k\times nm)$ 易爆炸。

现在考虑哪些状态可以优化掉。由于 $k$ 比较小，我们发现：如果需要向序列中补一些既不属于 $s$ 又不属于 $t$ 的字母（不如成为集合外的字母），那么我们并不用考虑集合外的字母之间的间隔问题（$k$ 很小，全集比较大），也就是说：需要补一些集合外的字母的情况，只会在只考虑集合中的字母之间间隔过小时出现。  
那么这 $k$ 维可以由 52 个状态优化成 4 个状态：这一位的字母是 选择的字符串 $S$ 中的字母 / 选择字符串 $T$ 中的字母 / 两者当前位相同的字母（即两个串都选择） / 补的集合外的字母。我们可以由这些状态推出前 $k$ 个字母中两个串各有几个，从而得出哪些字母不能选。  
为了方便，可以直接使用 4 进制的状压，直接进行滚动即可。

最后再处理一下往当前结尾的状态里面塞集合外的字母的最小值即可，时空复杂 $O(4^k\times nm)$。

## Code

**Talk is cheap, show me the code.**


```cpp
// Problem: P11202 [JOIG 2024] 名前 / Name
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11202
// Memory Limit: 1 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace FastIO {
    char gc() {
        static char buf[1 << 24], *is = buf, *it = buf;
        if (is == it) is = buf, it = is + fread(buf, 1, 1 << 24, stdin);
        return is == it ? EOF : *is ++;
    }
    char out[1 << 24];
    int len;
    void flush() { fwrite(out, 1, len, stdout), len = 0; }
    void pc(char x) {if (len == 1 << 24) flush(); out[len ++] = x;}
    struct Flusher {~Flusher() {flush();} } Fls;
    // #define gc() getchar()
    // #define pc(X) putchar(X)
    inline void read(char& ch) {ch = gc();}
    inline void read(char *s) {
        char ch = gc();
        while (ch < 33 || ch > 126) ch = gc();
        for (; ch >= 33 && ch <= 126; ch = gc()) *s++ = ch;
        *s = '\0';
    }
    template <class T>
    inline void read(T &x) {
        char c, flag = 0;
        while ((c = gc()) < '0' || c > '9') flag |= c == '-';
        x = c & 15;
        while ((c = gc()) >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + (c & 15);
        if (flag) x = ~x + 1;
    }
    template <class T, class ...T1>
    inline void read(T &x, T1 &...x1) {read(x), read(x1...);}
    template <class T>
    inline void _put(T x) {if(x > 9) _put(x / 10); pc((x % 10) | 48);}
    template <class T>
    inline void write(T x) {if(x < 0) pc('-'), x = ~x + 1; _put(x);}
    template <> inline void write(char x) {pc(x);}
    template <class T, class ...T1>
    inline void write(T x, T1 ...x1) {write(x), write(x1...);}
}
using FastIO::read;
using FastIO::write;
template <class T>
inline bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}
template <class T>
inline bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}

const int N = 5e2 + 10, M = 1 << 6;
int n, m, k, dp[N][N][M], ans, lim;
char s[N], t[N];
bool check(int i, int j, int sta, int f1, int f2) {
    int cs = 0, ct = 0, flag = 0;
    while(sta) cs += sta & 3 & 1, ct += (sta & 3 & 2) >> 1, sta >>= 2;
    if(f1) for(int p = 1; p <= cs && p < i; ++p) flag |= (s[i] == s[i - p]);
    if(f1) for(int p = 1; p <= ct && j - p - f2 + 1 > 0; ++p)
        flag |= (s[i] == t[j - p - f2 + 1]);
    if(f2) for(int p = 1; p <= ct && p < j; ++p) flag |= (t[j] == t[j - p]);
    if(f2) for(int p = 1; p <= cs && i - p - f1 + 1 > 0; ++p)
        flag |= (t[j] == s[i - p - f1 + 1]);
    return !flag;
}
void solve(int i, int j, int f1, int f2) {
    int now = f1 * 1 + f2 * 2;
    for(int sta = 0; sta <= lim; ++sta) if(check(i, j, sta, f1, f2))
        chkmin(dp[i][j][((sta << 2) + now) & lim], dp[i - f1][j - f2][sta] + 1);
    for(int sta = lim; ~sta; --sta) for(int p = 1; p <= k; ++p)
        chkmin(dp[i][j][(sta << (p * 2)) & lim], dp[i][j][sta] + p);
}

signed main() {
    // freopen(".in", "r", stdin);
    // freopen(".out", "w", stdout);
    read(n, m, k), read(s + 1), read(t + 1); memset(dp, 0x3f, sizeof dp);
    dp[0][0][0] = 0, ans = (n + m) * (k + 1), lim = (1 << (2 * k)) - 1;
    for(int i = 0; i <= n; ++i)
        for(int j = 0; j <= m; ++j) {
            if(i && j && s[i] == t[j]) solve(i, j, 1, 1);
            if(i) solve(i, j, 1, 0);
            if(j) solve(i, j, 0, 1);
        }
    for(int sta = 0; sta <= lim; ++sta) chkmin(ans, dp[n][m][sta]);
    write(ans);
    return 0;
}
```

## End

如有问题，欢迎指正。

---

## 作者：FFTotoro (赞：5)

套路地考虑动态规划：如果令 $f_{i,j}$ 表示匹配完了 $S$ 的前 $i$ 位和 $T$ 的前 $j$ 位的答案，你发现它没办法转移。

考虑增加状态：有一种比较朴素的方法是记录答案的最后 $K$ 位，这样确实是正确的，但是时间、空间复杂度都需要乘以一个 $|\Sigma|^3$（其中 $|\Sigma|=52$，表示字符集大小），过不了题。

接着观察到上面很多状态都是冗余的，因为我们只需要关心 $S$ 和 $T$ 的最后 $K$ 个字符。继续考虑记下答案的最后 $K$ 个字符，但是使用 `unordered_map` 存储状态并且使用 BFS 转移——因为大多数情况下只会使用 $S$ 和 $T$ 中的字符，若使用其他字符那么都是等价的；于是对于使用非 $S$ 和 $T$ 中字符的情况，通通用 `*` 或者某个其他字符来代替，这样能大大压缩状态数量，但是常数会上天。我在 VP 的时候实现了这种做法，可以获得 $70$ 分。

继续观察性质，考虑是否存在一些比较简洁且便于转移的状态。由于只需要记最后 $K$ 个字符，所以我们只用关心它们是否来自 $S$ 或 $T$（事实上这样就可以在转移过程中从状态“还原”这些字符，只需要从 $S$ / $T$ 的当前位置倒着推回去就可以得出；从而使得转移更加简洁明了）：使用二进制状态压缩这 $K$ 个字符，其中如果二进制数的从右到左第一位为 $1$ 表示它来自 $S$，反之亦然；第二位为 $1$ 表示它来自 $T$，反之亦然（使用二进制数的原因是这个字符可能同时来自 $S$ / $T$ 或者同时不来自 $S$ / $T$，后者即为上面所述的 `*` 的情况），时间复杂度后面乘上的系数就是 $4^K\le 64$，可以接受。根据定义直接枚举下一个字符需要是 $S$ 或 $T$ 中的字符，或者是一个 `*`，即可完成转移。

时间复杂度 $O(NM4^K)$。转移的时候使用 BFS 的写法可能比较简便。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline void chmin(int &x,int y){if(y<x)x=y;}
const int I=1e18;
main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n,m,k; string s,t; cin>>n>>m>>k>>s>>t;
  vector f(n+1,vector(m+1,vector(4,vector(4,vector<int>(4,I)))));
  queue<tuple<int,int,int,int,int> > q;
  f[0][0][0][0][0]=0,q.emplace(0,0,0,0,0);
  auto upd=[&](int u,int v,int x,int y,int z,int w){
    if(f[u][v][x][y][z]==I)q.emplace(u,v,x,y,z);
    chmin(f[u][v][x][y][z],w);
  }; // 状态转移
  while(!q.empty()){
    auto [u,v,x,y,z]=q.front(); q.pop();
    if(u==n&&v==m)cout<<f[u][v][x][y][z]<<endl,exit(0);
    vector<int> c={x,y,z};
    if(u<n&&v<m&&s[u]==t[v]){
      bool w=true;
      for(int i=0,a=u-1,b=v-1;i<k;i++){
        if(c[i]&1&&s[u]==s[a--])w=false;
        if(c[i]>>1&1&&s[u]==t[b--])w=false;
      } // 还原出最后 k 个字符，判断是否能进行转移
      if(w)upd(u+1,v+1,3,x,y,f[u][v][x][y][z]+1);
    }
    else{
      if(u<n){
        bool w=true;
        for(int i=0,a=u-1,b=v-1;i<k;i++){
          if(c[i]&1&&s[u]==s[a--])w=false;
          if(c[i]>>1&1&&s[u]==t[b--])w=false;
        }
        if(w)upd(u+1,v,1,x,y,f[u][v][x][y][z]+1);
      }
      if(v<m){
        bool w=true;
        for(int i=0,a=u-1,b=v-1;i<k;i++){
          if(c[i]&1&&t[v]==s[a--])w=false;
          if(c[i]>>1&1&&t[v]==t[b--])w=false;
        }
        if(w)upd(u,v+1,2,x,y,f[u][v][x][y][z]+1);
      }
    }
    upd(u,v,0,x,y,f[u][v][x][y][z]+1); // 加入一个 *
  }
  return 0;
}
```

---

## 作者：ran_qwq (赞：3)

$K=0$ 就是经典的最长上升子序列问题，考虑 dp，状态是取 $S$ 的前 $i$ 个，$T$ 的前 $j$ 个。但有相同字符必须间隔 $K$ 个字符的限制，直接做不可行。

考虑拓展此做法，注意到 $K\le 3$，在后面加 $K$ 维状态，记录**当前** $K$ **个字符**。转移新加一个字符，判断是否与前面的冲突。时间复杂度 $O(NM|\Sigma|^K)$，结合 $S=T$ 可得 $70$ 分。要注意的是，dp 状态可能成环，而边权为 $1$，可以用 **bfs** 代替 dp。

但字符集大小为 $52$，而 $K$ 只有 $3$，所以对所有不从 $S,T$ 取出来的字符，总存在一种合法方案不和其他字符产生矛盾，即可以看作通配符 `#`，不受相同字符间隔的限制。

现在新加入一个字符就只有 $4$ 种方案了：从 $S$ 中取、从 $T$ 中取、同时从 $S,T$ 中取、通配符。按 $70$ 分的方法 dp 即可。

```cpp
int n,m,k,l=1,r=1,ans=INF,dp[N][N][2][2][2][2][2][2];
string s,t;
struct NODE {int i,j,p,q,u,v,x,y;} _q[N*N*64];
void QwQ() {
	n=rd(),m=rd(),k=rd(),cin>>s>>t,s=" "+s,t=" "+t,mst(dp,-1),dp[0][0][0][0][0][0][0][0]=0;
	while(l<=r) {
		int i=_q[l].i,j=_q[l].j,p=_q[l].p,q=_q[l].q,u=_q[l].u,v=_q[l].v,x=_q[l].x,y=_q[l++].y;
		#define C dp[i][j][p][q][u][v][x][y]
		if(i==n&&j==m) return wr(C,"\n");
		auto T=[&](char c) {
			if(i&&k&&p&&s[i]==c||j&&k&&q&&t[j]==c||
			   i>p&&k>1&&u&&s[i-p]==c||j>q&&k>1&&v&&t[j-q]==c||
			   i>p+u&&k>2&&x&&s[i-p-u]==c||j>q+v&&k>2&&y&&t[j-q-v]==c) return;
			int f=i<n&&s[i+1]==c,g=j<m&&t[j+1]==c;
			#define D dp[i+f][j+g][f][g][p][q][u][v]
			if(!~D) D=C+1,_q[++r]={i+f,j+g,f,g,p,q,u,v};
		};
		T('!'); if(i<n) T(s[i+1]); if(j<m) T(t[j+1]);
	}
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

对于 $k = 0$ 的问题，是平凡的；令 $dp_{i,j}$ 表示匹配了 $s$ 的前 $i$ 个字符，$t$ 的前 $j$ 个字符的最小长度，状态转移方程为：

$$dp_{i,j} = \begin{cases} dp_{i - 1, j - 1} + 1 & s_i = t_j \\ \min(dp_{i,j - 1}, dp_{i - 1, j}) + 1 & s_i \ne t_j \end{cases}$$

时间复杂度为 $O(NM)$。

注意到 $k$ 很小，考虑状压，令 $dp_{i, j, S}$ 表示末尾 $k$ 为 $S$ 的最小长度，使用 bfs 转移，时间复杂度为 $O(NM|W|^k)$；其中 $|W| = 52$ 是字符集。

考虑优化，对于末尾的这 $k$ 个字符，我们只需要考虑匹配上了 $s,t$ 的字符，对于其它的字符是总可以找到一种填的方式和这些字符不同，可以看作通配符 `#`。

那么一个字符的状态只有 $4$ 种：

- 匹配了 $S$。
- 匹配了 $T$。
- 同时匹配了 $S$ 和 $T$。
- 统配符 `#`。

也可以使用 bfs 转移，时间复杂度为 $O(4^kNM)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define mkp(x, y) make_pair(x, y) 
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it = l; it != r; ++it) (*it)=x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1,s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i,l,r) for(register int i = l; i <= r; ++i)
#define _For(i,l,r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 505, M = 4;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int x, y;
	int a, b, c;
};
int n, m, k;
int dp[N][N][M][M][M];
char s[N], t[N];
queue<Node> q;
inline void update(int x, int y, int a, int b, int c, int v){
	if(dp[x][y][a][b][c] > v){
		dp[x][y][a][b][c] = v;
		q.push({x, y, a, b, c});
//		cerr << "add:" << x << ' ' << y << ' ' << a << ' ' << b << ' ' << c << ' ' << v << '\n';
	}
}
inline void bfs(){
	dp[0][0][0][0][0] = 0;
	q.push({0, 0, 0, 0, 0});
	while(!q.empty()){
		int x = q.front().x, y = q.front().y, a = q.front().a, b = q.front().b, c = q.front().c;
		q.pop();
		cerr << "move:" << x << ' ' << y << ' ' << a << ' ' << b << ' ' << c << ' ' << dp[x][y][a][b][c] << '\n'; 
		if(x == n && y == m){
			write(dp[x][y][a][b][c]);
			putchar('\n');
			return ;
		}
		vector<int> h = {a, b, c};
		if(x < n && y < m && s[x + 1] == t[y + 1]){
			bool F = 1;
			for(int u = x, v = y, i = 0; i < k; ++i){
				if((h[i] & 1) && (s[u--] == s[x + 1])){
					F = 0;
					break;
				}
				if((h[i] >> 1 & 1) && (t[v--] == s[x + 1])){
					F = 0;
					break;
				}
//				assert(u >= 0 && v >= 0);
			}
			if(F)
			  update(x + 1, y + 1, 3, a, b, dp[x][y][a][b][c] + 1);
		}
		else{
			if(x < n){
				bool F = 1;
				for(int u = x, v = y, i = 0; i < k; ++i){
					if((h[i] & 1) && (s[u--] == s[x + 1])){
						F = 0;
						break;
					}
					if((h[i] >> 1 & 1) && (t[v--] == s[x + 1])){
						F = 0;
						break;
					}
//					assert(u >= 0 && v >= 0);
				}
				if(F)
				  update(x + 1, y, 1, a, b, dp[x][y][a][b][c] + 1);
			}
			if(y < m){
				bool F = 1;
				for(int u = x, v = y, i = 0; i < k; ++i){
					if((h[i] & 1) && (s[u--] == t[y + 1])){
						F = 0;
						break;
					}
					if((h[i] >> 1 & 1) && (t[v--] == t[y + 1])){
						F = 0;
						break;
					}
//					assert(u >= 0 && v >= 0);
				}
				if(F)
				  update(x, y + 1, 2, a, b, dp[x][y][a][b][c] + 1);
			}
		}
		update(x, y, 0, a, b, dp[x][y][a][b][c] + 1);
	} 
}
bool End;
int main(){
	memset(dp, 0x3f, sizeof(dp));
	n = read(), m = read(), k = read();
	scanf("%s", s + 1);
	scanf("%s", t + 1);
	bfs();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 题解：P11202 [JOIG 2024] 名前 / Name
这个题目没什么好说的，套路的考虑动规（我不是很熟练）:
其实这个题目 $K=0$ 就是求 $S$ 的前 $i$ 个和 $T$ 的前 $j$ 个，这时你可能会觉得这道题很简单啊！但是你会发现他有相同字符必须间隔 $K$ 个字符的限制，没办法转移。

这时我们应该考虑别的扩展做法，我们会发现有一种做法就是记录答案的后 $K$ 位，经验证后发现确实可行，但是我们会发现时间、空间复杂度都过不了题目的限制。

$70$ 分做法：我们发现 $K \le 3$，所以我们只需要记下答案的最后 $K$ 个字符，使用 ```unordered_map``` 存储状态并且使用 BFS 转移, 这样能大大压缩状态数量，但是常数会很大。

正解：分析一通，我们发现只有 4 种方案，分别是：从 $S$ 中取，从 $T$ 中取，同时从 $S,T$ 中取，通配符（对所有不从 $S,T$ 取出来的字符，总存在一种合法方案不和其他字符产生矛盾）,然后按 $70$ 分做法 dp 即可。

注：参考了 [FFTotoro](https://www.luogu.com.cn/user/556366) 和 [ran_qwq](https://www.luogu.com.cn/user/743048) 的博客，做了一个总结，添加了一些我的看法。

---

## 作者：_qhbd_ (赞：0)

# 题意
给定两个长分别为 $N,M$ 的字符串 $S,T$，构造一个字符串使得 $S,T$ 均为该字符串子序列且该字符串中两两相同字符相隔至少为 $K$。
# 思路
如果没有关于 $K$ 的限制，那么这道题就很好做，令 $f_{i,j}$ 表示 $S,T$ 两串已分别按序填入了前 $i,j$ 个字符。

转移：
$$
f_{i,j}=\begin{cases}
min(f_{i-1,j},f_{i,j-1})+1 & S_i\ne T_j \\f_{i-1,j-1}+1 & S_i=T_j
\end{cases}
$$

但是如果多了 $K$ 就需要处理更多关系。注意到 $0\le K\le 3$，我们试着暴力表示最后 $K$ 位的字符，那么状态数有 $500^2\times 26^3$，空间爆炸。但是我们发现，我们可以记录最后 $K$ 位的字符来自于 $S$ 还是 $T$，或是 $S,T$ 共有，亦或是为了满足条件填充的其他字符。所以总状态数变成 $500^2\times 4^3$，在可以接受的范围。

令 $f_{i,j,a,b,c}$ 表示 $S,T$ 两串已分别按序填入了前 $i,j$ 个字符且最后三个字符的来源为 $a,b,c$。每次我们判断放入 $s_{i+1},t_{j+1}$ 时最小需要填充的其他字符，将 $a,b,c$ 往前挪动补充后续字符来源转移贡献。

关于填充字符具体是什么，其实不必关心，对于一个位置与它有关系的最多有 $2\times K$ 个，我们总共有 $52$ 个字符可供选择，直接找个与该位置有关字符不同的即可。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e2+5;
int n,m,k,f[N][N][4][4][4],ans=0x3f3f3f3f;
char s[N],t[N];
inline void check_min(int&x,int y){x=min(x,y);}
int main(){
	memset(f,0x3f,sizeof(f));
	f[0][0][2][2][2]=0;
	scanf("%d%d%d%s%s",&n,&m,&k,s+1,t+1);
	for(int i=0;i<=n;i++)
	for(int j=0;j<=m;j++)
	for(int a=0;a<=3;a++)
	for(int b=0;b<=3;b++)
	for(int c=0;c<=3;c++)if(f[i][j][a][b][c]!=0x3f3f3f3f){
		if(s[i+1]==t[j+1]){
int ff=0;
if(k>=1&&(((c==0||c==3)&&s[i]==s[i+1])||((c==1||c==3)&&t[j]==t[j+1])))ff=k;
else if(k>=2&&(((b==0||b==3)&&s[i-(c==0||c==3)]==s[i+1])||((b==1||b==3)&&t[j-(c==1||c==3)]==t[j+1])))ff=k-1;
else if(k>=3&&(((a==0||a==3)&&s[i-(b==0||b==3)-(c==0||c==3)]==s[i+1])||((a==1||a==3)&&t[j-(b==1||b==3)-(c==1||c==3)]==t[j+1])))ff=k-2;
check_min(f[i+1][j+1][(ff>1?2:(ff>0?c:b))][(ff>0?2:c)][3],f[i][j][a][b][c]+1+ff);
		}
		else{
int fs=0,ft=0;
if(k>=1&&(((c==0||c==3)&&s[i]==s[i+1])||((c==1||c==3)&&t[j]==s[i+1])))fs=k;
else if(k>=2&&(((b==0||b==3)&&s[i-(c==0||c==3)]==s[i+1])||((b==1||b==3)&&t[j-(c==1||c==3)]==s[i+1])))fs=k-1;
else if(k>=3&&(((a==0||a==3)&&s[i-(b==0||b==3)-(c==0||c==3)]==s[i+1])||((a==1||a==3)&&t[j-(b==1||b==3)-(c==1||c==3)]==s[i+1])))fs=k-2;
if(k>=1&&(((c==0||c==3)&&s[i]==t[j+1])||((c==1||c==3)&&t[j]==t[j+1])))ft=k;
else if(k>=2&&(((b==0||b==3)&&s[i-(c==0||c==3)]==t[j+1])||((b==1||b==3)&&t[j-(c==1||c==3)]==t[j+1])))ft=k-1;
else if(k>=3&&(((a==0||a==3)&&s[i-(b==0||b==3)-(c==0||c==3)]==t[j+1])||((a==1||a==3)&&t[j-(b==1||b==3)-(c==1||c==3)]==t[j+1])))ft=k-2;
check_min(f[i+1][j][(fs>1?2:(fs>0?c:b))][(fs>0?2:c)][0],f[i][j][a][b][c]+1+fs);
check_min(f[i][j+1][(ft>1?2:(ft>0?c:b))][(ft>0?2:c)][1],f[i][j][a][b][c]+1+ft);
		}
	}
	for(int i=0;i<=3;i++)
	for(int j=0;j<=3;j++)
	for(int l=0;l<=3;l++)
		ans=min(ans,f[n][m][i][j][l]);
	printf("%d",ans);
	return 0;
}
/*
2 3 3
CA
ACA
*/
```

---


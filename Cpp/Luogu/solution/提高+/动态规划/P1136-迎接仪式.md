# 迎接仪式

## 题目描述

LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。

为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。

## 说明/提示

**【样例说明】**

第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；

第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。

最后的串有 $2$ 个 `jz` 子串。

**【数据规模与约定】**

对于 $10 \%$ 的数据，有 $N \le 10$；  
对于 $30 \%$ 的数据，有 $K \le 10$；  
对于 $40 \%$ 的数据，有 $N \le 50$；  
对于 $100 \%$ 的数据，有 $1 \le N \le 500$，$1 \le K \le 100$。

## 样例 #1

### 输入

```
5 2 
zzzjj
```

### 输出

```
2
```

# 题解

## 作者：gorokokoro (赞：63)

网上九成以上的题解都不正确……

HACK：https://www.luogu.org/discuss/show/101076

大体的做法和上面的三个做法类似，不再赘述。这里讲明为什么会存在叉点。

大部分人都不记录最后一位被改成了什么……如果不记录，那么将第 $i$ 位的 `z` 改成 `j` 之后，若第 $i+1$ 位是 `z`，那么会这个 `jz` 会没有被统计。

解决方法是多记一维表示对于前 $i$ 个字符而言，第 $i$ 个字符被改成了 $0/1$ 。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <climits>
#define N 520
#define K 120
using namespace std;

char s[N];
int a[N];
int f[N][K][K][2];

int main(void)
{
    int n, m;
    int i, j, k;

    cin >> n >> m >> s;
    for(i = 1; i <= n; i ++)
        a[i] = s[i - 1] == 'z';

    for(i = 0; i < N; i ++)
        for(j = 0; j < K; j ++)
            for(k = 0; k < K; k ++)
                f[i][j][k][0] = f[i][j][k][1] = INT_MIN;

    f[0][0][0][1] = 0;
    for(i = 1; i <= n; i ++)
        for(j = 0; j <= m; j ++)
            for(k = 0; k <= m; k ++)
            {
                f[i][j][k][a[i]] = max(f[i - 1][j][k][0] + a[i], f[i - 1][j][k][1]);
                if(a[i])
                {
                    if(k)
                        f[i][j][k][0] = max(f[i - 1][j][k - 1][0], f[i - 1][j][k - 1][1]);
                }
                else
                {
                    if(j)
                        f[i][j][k][1] = max(f[i - 1][j - 1][k][0] + 1, f[i - 1][j - 1][k][1]);
                }
            }

    for(i = k = 0; i <= m; i ++)
        k = max(k, max(f[n][i][i][0], f[n][i][i][1]));
    cout << k << endl;

    return 0;
}

```

另：我没有想到正确的 $\mathrm O(N^2K)$ 做法，主要是考虑将第 $i$ 个字符交换到哪儿（设为 $k$）之后，区间 $(k,\,i)$ 中的字符还可能与 $k$ 之前的字符产生交换，这部分交换产生的做法无法统计。

错误的 $\mathrm O(N^2K)$ 做法：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <climits>
#define N 520
#define K 120
using namespace std;

char s[N];
int a[N];
int f[N][K][2], g[N][N];

int main(void)
{
    int n, m;
    int i, j, k;

    cin >> n >> m >> s;
    for(i = 1; i <= n; i ++)
        a[i] = s[i - 1] == 'z';

    for(i = 2; i <= n; i ++)
        f[i][0][a[i]] = f[i - 1][0][a[i - 1]] + (!a[i - 1] && a[i]);
    for(i = 1; i <= n; i ++)
        for(j = i + 1; j <= n; j ++)
            g[i][j] = g[i][j - 1] + (!a[j - 1] && a[j]);

    for(i = 0; i <= m; i ++)
    {
        f[0][i][0] = INT_MIN;
        for(j = 1; j <= n; j ++)
            f[j][i][!a[j]] = INT_MIN;
    }

    for(i = 1; i <= n; i ++)
        for(j = 1; j <= m; j ++)
        {
            f[i][j][!a[i]] = INT_MIN;
            f[i][j][a[i]] = max(f[i - 1][j][0] + a[i], f[i - 1][j][1]);
            for(k = 1; k < i; k ++)
                if(a[k] ^ a[i])
                {
                    if(k == i - 1)
                        f[i][j][!a[i]] = max(f[i][j][!a[i]], max(f[k - 1][j - 1][0] + a[i], f[k - 1][j - 1][1]) + (!a[i] && a[k]));
                    else
                        f[i][j][!a[i]] = max(f[i][j][!a[i]], max(f[k - 1][j - 1][0] + a[i], f[k - 1][j - 1][1]) + (!a[i] && a[k + 1]) + (!a[i - 1] && a[k]) + g[k + 1][i - 1]);
                }
        }
    cout << max(f[n][m][0], f[n][m][1]) << endl;

    return 0;
}

```


---

## 作者：hzoi_liuchang (赞：60)

## 分析

我们设$f[i][j][k][0]$为遍历了字符串的前$i$位，改变了$j$个$j$和$k$个$z$，并且当前的这一位为$j$所能达到的最大价值

设$f[i][j][k][1]$为遍历了字符串的前$i$位，改变了$j$个$j$和$k$个$z$，并且当前的这一位为$z$所能达到的最大价值

我们先来考虑$f[i][j][k][0]$

如果该字符串的第$i$位本来是$z$，那么我们把它改为$j$后，必定不会与前面的字符组成$jz$，而且必定会花费一次修改操作

因此当前的最大值应该在前面的字符变为$j$或变为$z$中取

$f[i][j][k][0]=max(f[i-1][j][k-1][0],f[i-1][j][k-1][1]);$

如果该字符串的第$i$位本来是$j$，那么我们就不需要进行修改操作

但是，当前的字符仍然不会与前面的字符组成$jz$

所以当前的最大值还应该在前面的字符变为$j$或变为$z$中取

$f[i][j][k][0]=max(f[i-1][j][k][0],f[i-1][j][k][1]);$

接下来我们再考虑$f[i][j][k][1]$

如果该字符串的第$i$位本来是$z$,那么如果上一位的字符为$j$，那么又可以组成一个$jz$,如果上一位为$j$，则不能组成

$f[i][j][k][1]=max(f[i-1][j][k][0]+1,f[i-1][j][k][1]);$

如果该字符串的第$i$位本来是$j$，那么我们就需要进行一次修改操作

$f[i][j][k][1]=max(f[i-1][j-1][k][0]+1,f[i-1][j-1][k][1]);$

最后我们再在$j$和$k$相等的方案中取一个最大值即可

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=505,maxk=105;
int n,m,f[maxn][maxk][maxk][3];
char s[maxn];
int main(){
    scanf("%d%d%s",&n,&m,s+1);
    memset(f,128,sizeof(f));
    f[0][0][0][1]=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int k=0;k<=m;k++){
                if(s[i]=='z'){
                    f[i][j][k][1]=max(f[i-1][j][k][0]+1,f[i-1][j][k][1]);
                    if(k) f[i][j][k][0]=max(f[i-1][j][k-1][0],f[i-1][j][k-1][1]);
                } else {
                    f[i][j][k][0]=max(f[i-1][j][k][0],f[i-1][j][k][1]);
                    if(j) f[i][j][k][1]=max(f[i-1][j-1][k][0]+1,f[i-1][j-1][k][1]);
                }
            }
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++){
        ans=max(ans,max(f[n][i][i][1],f[n][i][i][0]));
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：WIZeaz (赞：9)

(由于博客页和题解页的 LaTeX 渲染不一致，如果出现LaTeX渲染问题请到博客中查看)

## 题目分析
首先可以想到是：如果是调换的话一定是$j$和$z$调换，因为同字母调换是没有意义的。因此，$j$被换成$z$的个数一定会等同于$z$被换成$j$的个数，这样，我们就可以单独考虑改变某个字母的情况，而不必考虑具体是哪两个字母调换了，因为只要最后保证改变j的数量和改变z的数量一致，就一定存在这样的调换方法。我们可以用一个四维数组$ dp[i][j][k][l] $表示前$ i $个字符，改变了$ j $个$j$和$ k $个$z$，当前字符改变状态为$l$（$l=0$代表不改变当前字符，$l=1$相反）时的答案。

之所以要保存当前字符是否被改变的状态的原因是因为状态转移的时候我们需要知道前一个字符具体是什么，如果不分开保存的话不能保证正确性，因为对于$d[i][j][k]$有可能恰好第$i$个字符被改变了。但这道题的数据有点弱，一些不正确的写法也过了……

具体dp方程为：
$$
\begin{cases}
dp[i][j][k][0]&=max\{dp[i-1][j][k][0]+[s_{i-1}=j \space and \space s_{i}=z],dp[i-1][j][k][1]+[s_{i-1}=z \space and \space s_{i}=z]\}\\
dp[i][j][k][1]&=max\{dp[i-1][j-1][k][0]+[s_{i-1}=j],dp[i-1][j-1][k][1]+[s_{i-1}=z]\}&s_i=j\\
dp[i][j][k][1]&=max\{dp[i-1][j][k-1][0],dp[i-1][j][k-1][1]\} & s_i=z
\end{cases}
$$

时间复杂度为$O(nk^2)$

上面两个关于$dp[i][j][k][1]$方程可以合并，这样会写得比较短一点

## 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int d[1001][101][101][2];
char str[10001];
char inv(char s){
    if (s=='z') return 'j';
    if (s=='j') return 'z';
    return '#';
}
int check(char a,char b){
    if (a=='j' && b=='z') return 1;
    return 0;
}
int main(){
    int n,K;
    scanf("%d%d",&n,&K);
    scanf("%s",str+1);
    str[0]=str[n+1]='#';
    memset(d,0x80,sizeof(d));
    d[0][0][0][0]=d[0][0][0][1]=0;
    for (int i=1;i<=n;++i){
        // no change
        char Inv=inv(str[i-1]);
        char Invnow=inv(str[i]);
        for (int j=0;j<=K;++j){

            for (int k=0;k<=K;++k){
                d[i][j][k][0]=max(d[i][j][k][0],d[i-1][j][k][0]+check(str[i-1],str[i]));
                d[i][j][k][0]=max(d[i][j][k][0],d[i-1][j][k][1]+check(Inv,str[i]));
            }
        }
        //change
        int t1,t2;
        t1=t2=0;
        if (str[i]=='j') t1=1;
        else t2=1;

        for (int j=t1;j<=K;++j){
            char Inv=inv(str[i-1]);
            for (int k=t2;k<=K;++k){
                d[i][j][k][1]=max(d[i][j][k][1],d[i-1][j-t1][k-t2][0]+check(str[i-1],Invnow));
                d[i][j][k][1]=max(d[i][j][k][1],d[i-1][j-t1][k-t2][1]+check(Inv,Invnow));
            }
        }
    }

    int ans=0;
    for (int i=0;i<=K;++i){
        ans=max(ans,max(d[n][i][i][0],d[n][i][i][1]));
    }
    printf("%d",ans);
}
```


---

## 作者：Tyyyyyy (赞：8)

## 一道奇奇怪怪的dp
先说一下这题的基本思路：

开一个三维dp数组，$dp[i][j][k]$表示前$i$个字符中交换了$j$个$j$和$k$个$z$。

确定了dp状态，接下来需要推导转移方程。

分为4种情况：

若待交换的字符为‘jz’：$dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k]+1);$

若待交换的字符为‘jj’：$dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k-1]+1);$

若待交换的字符为‘zz’：$dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k]+1);$

若待交换的字符为‘zj’：$dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k-1]+1);$

应该还是很好理解的。
那么很容易想到如下的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[510][150][150],ans=0;//n,m为题中N,K
char c[550]; 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				if(c[i-1]=='j'&&c[i]=='z')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k]+1);
				if(c[i-1]=='j'&&c[i]=='j')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k-1]+1);
				if(c[i-1]=='z'&&c[i]=='z')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k]+1);
				if(c[i-1]=='z'&&c[i]=='j')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k-1]+1);
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=m;k++)
			{
				if(j==k)ans=max(ans,dp[i][j][k]);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
 ```
但是这里有一个很明显的问题：循环中会越界。

因此，我们可以在循环里加上边界判断。

但提交后你会发现wa掉8个点（亲身经历）。

那么我们肯定是忘记了某些东西：对$dp[i][j][k]$而言，如果是这样：‘zjz’，那么它不仅要与后面的互相判断（'jz’）,还要与‘zj’相判断。

所以在循环中补充一行代码：$dp[i][j][k]=dp[i-1][j][k];$。
```cpp
for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				dp[i][j][k]=dp[i-1][j][k];
				if(c[i-1]=='j'&&c[i]=='z')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k]+1);
				if(c[i-1]=='j'&&c[i]=='j'&&k)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k-1]+1);
				if(c[i-1]=='z'&&c[i]=='z'&&j)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k]+1);
				if(c[i-1]=='z'&&c[i]=='j'&&j&&k)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k-1]+1);
			}
		}
	}
```
现在还会wa掉2个点，~~有进步！~~
明显是初始化出了问题。

我们还需要处理dp数组（初始化）：
```cpp
memset(dp,245,sizeof(dp));
dp[0][0][0]=dp[1][0][0]=0;
```
但这样仍有一个问题：

将第 $i$ 位的 $z$ 改成 $j$ 之后，若第 $i+1$ 位是 $z$，那么会这个 $jz$ 会没有被统计。 
                          
因此只需要加个特判:$m!=1$时进行初始化就行了。                              

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[510][150][150],ans=0;//n,m为题中N,K
char c[550]; 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>c[i];
	if(m!=1)
	{
		memset(dp,245,sizeof(dp));
		dp[0][0][0]=dp[1][0][0]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				dp[i][j][k]=dp[i-1][j][k];
				if(c[i-1]=='j'&&c[i]=='z')dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k]+1);
				if(c[i-1]=='j'&&c[i]=='j'&&k)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j][k-1]+1);
				if(c[i-1]=='z'&&c[i]=='z'&&j)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k]+1);
				if(c[i-1]=='z'&&c[i]=='j'&&j&&k)dp[i][j][k]=max(dp[i][j][k],dp[i-2][j-1][k-1]+1);
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=m;k++)
			{
				if(j==k)ans=max(ans,dp[i][j][k]);//这里是因为题中要求‘互换’，所以当交换次数相同时才满足条件。
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：black_trees (赞：7)

### 我在这里提供一种新的做法（优化）

----
思路：

既然是 $DP$ ,那么从以下两个角度出发：

+ 我从哪里来？（当前状态可以由哪些状态得到？）

+ 我到哪里去？（当前状态可以去到哪几个状态？）

很容易的出楼上大佬们的状态：

设 $f[i][j][k][l]$ 表示考虑前 $i$ 位，交换 $j$ 次 $j$，$k$次 $z$ ，$l=0$ 表示当前位为 $j$，$l=1$表示当前位为 $z$，所得的最大 $jz$ 个数。

----

但是，我想了一想，这里可不可以优化一下，把后面的 $l$ 给去掉呢？

（去掉的话可以把空间复杂度降到原来的 $\frac{1}{2}$ 呢）。

所以设 $f[i][j][k]$ 表示考虑前 $i$ 位，交换 $j$ 次 $j$，$k$次 $z$，所得的最大 $jz$ 个数。


那我们考虑一下四种情况：

+ 扫到的子串是 $jz$:

这个时候不用交换，直接继承状态再加一，$i-2$ 是因为，我们扫的是一个 $2$ 位的字符串。

即是：$f[i][j][k]=f[i-2][j][k]+1$


+ 扫到的子串是 $zz$:

这时候需要交换一次，相当于将第一个字符变为 $j$ ，也就是要交换一次 $j$， 那么就有：

$f[i][j][k]=f[i-2][j-1][k]+1$

+ 扫到的子串是 $jj$:

思路同 $zz$ 情况，只是改变的位置不同，则有：

$f[i][j][k]=f[i-2][j][k-1]+1$

+ 扫到的子串是 $zj$:

这个时候只需要内部交换一下，所以 $j$ 和 $k$ 都要变化。所以有：

$f[i][j][k]=f[i-2][j-1][k-1]+1$

------

方程推出来了，自己理解一下，应该是可以写出来的了。



---

## 作者：A_Bit_Cold (赞：3)

dp 题，不过状态定义比较难想。

定义 $dp_{i,j,k,0}$ 表示前 $i$ 个字符中改变 $j$ 个 `j`，改变 $k$ 个 `z`，且第 $i$ 个字符为 `j` 能调整出的最多的 `jz` 的个数。

定义 $dp_{i,j,k,1}$ 表示前 $i$ 个字符中改变 $j$ 个 `j`，改变 $k$ 个 `z`，且第 $i$ 个字符为 `z` 能调整出的最多的 `jz` 的个数。

动态转移方程：

- 若 $s_{i}=$`j`，$dp_{i,j,k,0}=\max(dp_{i-1,j,k,0},dp{i-1,j,k,1})$

  -  若 $j\ge1$，则 $dp_{i,j,k,1}=\max(dp_{i-1,j-1,k,0}+1,dp_{i-1,j-1,k,1})$
  
- 若 $s_{i}=$`z`，$dp_{i,j,k,1}=\max(dp_{i-1,j,k,0}+1,dp_{i-1,j,k,1})$

   - 若 $k\ge1$，则 $dp_{i,j,k,0}=\max(dp_{i-1,j,k-1,0},dp_{i-1,j,k-1,1})$
   
主要看 $dp_{i,j,k,1}$ 的动态转移方程，因为其较为特殊，它的前面如果接上 `z`，就成为了一个字符组 `jz`，个数增加一，所以是如上的动态转移方程。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e2+5,M=1e2+5;
int dp[N][M][M][2];
int main() {
	memset(dp,-0x3f,sizeof(dp));
	dp[0][0][0][1]=0;
    int n,m,ans=0;
    string s;
    cin>>n>>m>>s;
    for(int i=n;i>=1;i--) s[i]=s[i-1];
    for(int i=1;i<=n;i++) {
		for(int j=0;j<=m;j++) {
			for(int k=0;k<=m;k++) {
				if(s[i]=='j') {
					dp[i][j][k][0]=max(dp[i-1][j][k][0],dp[i-1][j][k][1]);
					if(j>=1) dp[i][j][k][1]=max(dp[i-1][j-1][k][0]+1,dp[i-1][j-1][k][1]);
				}
				else {
					dp[i][j][k][1]=max(dp[i-1][j][k][0]+1,dp[i-1][j][k][1]);
					if(k>=1) dp[i][j][k][0]=max(dp[i-1][j][k-1][0],dp[i-1][j][k-1][1]);
				}
			}
		}
	}
	for(int i=0;i<=m;i++) ans=max(ans,max(dp[n][i][i][0],dp[n][i][i][1]));
	cout<<ans;
    return 0;
}
```


---

## 作者：lichenfan (赞：2)

### 主要思路DP
定义一个数组 $dp[i][j][f][l]$。  
若 $l=1$ 代表在前 $i$ 位内，有 $j$ 个 $j$ 和 $f$ 个 $z$ 改变过了，并且当前这位为 $z$。   
若 $l=0$ 代表在前 $i$ 位内，有 $j$ 个 $j$ 和 $f$ 个 $z$ 改变过了，并且当前这位为 $j$。
### 现在考虑动态转移方程
如果当前这一位 $i$ 为 $j$，那么更改之后就可能组成 $jz$。所以它的最大值为     $\max(dp[i-1][j][f][0]+1,dp[i-1][j][f][1])$。就是指在 $i-1$ 的字符前字符为 $j$ 或 $z$ 时，所达到的最大值。以为不可能再合成一个 $jz$，所以答案不变。  
同理可得，当这一位 $i$ 为 $z$，它的最大值为 $\max(dp[i-1][j][f][0],dp[i-1][j][f][1])$。因为改变之后不可能再合成一个 $jz$，所以答案不变。
### 核心代码:
```cpp
    for(int i=1;i<=n;i++)
	{
        for(int j=0;j<=k;j++)
		{
            for(int f=0;f<=k;f++)
			{
                if(s[i]=='j')
				{
                    dp[i][j][f][0]=max(dp[i-1][j][f][0],dp[i-1][j][f][1]);                          //动态转移方程，当这一位为j时，不可能产生jz，所以不变 
                    if(j!=0) dp[i][j][f][1]=max(dp[i-1][j-1][f][0]+1,dp[i-1][j-1][f][1]); 	 	    	//特判取前面最大值 
                }
				if(s[i]=='z')
				{
                    dp[i][j][f][1]=max(dp[i-1][j][f][0]+1,dp[i-1][j][f][1]);					//动态转移方程，当这一位为z时，可能产生jz，所以加一 
                    if(f!=0) dp[i][j][f][0]=max(dp[i-1][j][f-1][0],dp[i-1][j][f-1][1]);             //特判取前面最大值 
                }
            }
        }
    }
```

有了核心之后就很好做了，下面为全部代码（注释在上方了）
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48),ch=getchar();}
    return x*f;
}
char s[501];
int dp[501][101][101][3];
int n,k,m;
int sum;
int main(){
	memset(dp,128,sizeof(dp));
	dp[0][0][0][1]=0;
    n=read(),k=read();
    for(int i=1;i<=n;i++) cin>>s[i];
    for(int i=1;i<=n;i++)
	{
        for(int j=0;j<=k;j++)
		{
            for(int f=0;f<=k;f++)
			{
                if(s[i]=='j')
				{
                    dp[i][j][f][0]=max(dp[i-1][j][f][0],dp[i-1][j][f][1]);                          
                    if(j!=0) dp[i][j][f][1]=max(dp[i-1][j-1][f][0]+1,dp[i-1][j-1][f][1]); 	 	    
                }
				if(s[i]=='z')
				{
                    dp[i][j][f][1]=max(dp[i-1][j][f][0]+1,dp[i-1][j][f][1]);				
                    if(f!=0) dp[i][j][f][0]=max(dp[i-1][j][f-1][0],dp[i-1][j][f-1][1]);       
                }
            }
        }
    }
    for(int i=0;i<=k;i++) sum=max(sum,max(dp[n][i][i][0],dp[n][i][i][1]));
    cout<<sum;
}

```



---

## 作者：Eternality (赞：1)

这道题思路不是很好想，~~我也是看了题解才会的菜死了~~。
## 题意概述
给你一个只有字母 $z$ 和 $j$ 的串和 $k$ 次任意交换两个字母的机会，让你求最后串中最多有多少个 $jz$。
## 思路概述
大部分人一开始想这道题可能想的是用 $f_{i,j,k}$ 表示交换了 $i$ 次，第 $i$ 次交换了 $j$ 和 $k$ 上的字母，所能得到的最多的数量，但是发现很难转移，因为没有记录之前修改的状态，（如果你每次都记录状态也不是不行，除非题目给你几个 $G$ 的空间），~~于是我就看了题解~~，于是应该想别的状态。

首先交换的一定是两个不同的字母，相同的字母交换没有意义。

而且最后的状态一定是有几个 $j$ 换成了 $z$ 就有几个 $z$ 换成了 $j$。

#### 重点：而且只要 $j$ 换成 $z$ 的次数和 $z$ 换成 $j$ 的次数一样，就一定存在这样的调换方案，因为 $j$ 和 $z$ 是随意调换。这样只需要关心修改了多少个 $j$，修改了多少个 $z$，最后答案在这两个次数相等的情况取即可。

明确了这些以后就可以设计状态了，上面说的不是废话，肯定需要记录当前多少个 $j$ 换成 $z$，多少个 $z$ 换成 $j$ 了，最后直接在这两个次数相等的情况取答案。因为是随便换的，所以前 $i$ 个字母中改了多少个 $j$ 和改了多少个 $z$ 对后边怎么改是没有影响的，且当前位只与前一位有关,因为 $jz$ 是两个字母。

状态表示: $f_{i,j,k,1}$ 表示前 $i$ 个字母改了 $j$ 个 $j$，改了 $k$ 个 $z$，且当前位目前是 $z$ 的最大数量， $f_{i,j,k,0}$ 表示前 $i$ 个字母改了 $j$ 个 $j$，改了 $k$ 个 $z$，且当前位目前是 $j$ 的最大数量。

初始化：先初始化为负无穷，否则可能会从某些根本不存在的情况转移过来，（比如第一位是 $z$，你如果不初始化，那么 $f_{1,0,0,0}$ 会是零，这样的话 $f_{2,0,0,1}$ 就会等于 $f_{1,0,0,0}$ 加一，很显然这种情况不存在，而你却统计了个 $1$ 出来），然后把第一位的所有状态都先写出来，可以参考我下面的代码

#### 还有，因为都是从上一位转移过来，所以可以滚掉一维，不然就超内存了

## code
#### 原代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510;
int n,m;
char s[N];
int f[N][N][N][2];
int maxx;

int main()
{
	scanf("%d%d%s",&n,&m,s+1);
	memset(f,128,sizeof f);
	if(s[1]=='j')
	{
		f[1][0][0][0]=f[1][1][0][1]=0;
	}else 
	{
		f[1][0][0][1]=f[1][0][1][0]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				//j:
				if(s[i]=='j')f[i][j][k][0]=max(f[i-1][j][k][0],f[i-1][j][k][1]);
				else if(k>0)f[i][j][k][0]=max(f[i-1][j][k-1][0],f[i-1][j][k-1][1]);
				//z:
				if(s[i]=='z')f[i][j][k][1]=max(f[i-1][j][k][0]+1,f[i-1][j][k][1]);
				else if(j>0)f[i][j][k][1]=max(f[i-1][j-1][k][0]+1,f[i-1][j-1][k][1]);
				if(j==k)maxx=max(maxx,f[i][j][k][0]>f[i][j][k][1] ? f[i][j][k][0] : f[i][j][k][1]);
			}
		}
	}
	cout<<maxx;
	return 0;
}
```

#### 滚掉一维之后的
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510;
int n,m;
char s[N];
int f[2][N][N][2];
int maxx;

int main()
{
	scanf("%d%d%s",&n,&m,s+1);
	memset(f,128,sizeof f);
	//初始化1的所有状态: 
	if(s[1]=='j')
	{
		f[1][0][0][0]=f[1][1][0][1]=0;
	}else 
	{
		f[1][0][0][1]=f[1][0][1][0]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				int d=i%2;
				//j:
				if(s[i]=='j')f[d][j][k][0]=max(f[1-d][j][k][0],f[1-d][j][k][1]);
				else if(k>0)f[d][j][k][0]=max(f[1-d][j][k-1][0],f[1-d][j][k-1][1]);
				//z:
				if(s[i]=='z')f[d][j][k][1]=max(f[1-d][j][k][0]+1,f[1-d][j][k][1]);
				else if(j>0)f[d][j][k][1]=max(f[1-d][j-1][k][0]+1,f[1-d][j-1][k][1]);
				if(j==k)maxx=max(maxx,f[d][j][k][0]>f[d][j][k][1] ? f[d][j][k][0] : f[d][j][k][1]);
			}
		}
	}
	cout<<maxx;
	return 0;
}
```

---


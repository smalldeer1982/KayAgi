# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# 题解

## 作者：zzzyc (赞：126)

看到很多大佬写的都是些高端的dp。。。

小蒟蒻表示看不懂啊。。。

所以想了个简单的方法。。。

###解释在代码最后。。。

```cpp
#include<iostream>
using namespace std;
int n,m,k,a[201][201];
int sy[201][201],sn[201][201];
int fn[201][201],fy[201][201];
bool b[201][201];
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            char ch;
            cin>>a[i][j]>>ch;
            if(ch=='Y') b[i][j]=1;
        }
    for(int i=1;i<=m;i++)
    {
        int cnt=0;
        for(int j=n;j>=1;j--)
        {
            if(b[j][i]==1)
                sy[i][cnt]+=a[j][i];
            else
            {
                cnt++;
                sy[i][cnt]=sy[i][cnt-1]+a[j][i];
                sn[i][cnt]=sy[i][cnt-1]+a[j][i];
            }
        }
    }
    for(int x=1;x<=m;x++) 第x列
        for(int y=0;y<=k;y++) 总共y颗子弹
            for(int z=0;z<=n && z<=y;z++) 要用z颗
            {
                fy[x][y]=max(fy[x][y],fy[x-1][y-z]+sy[x][z]);
                if(z!=0) fn[x][y]=max(fn[x][y],fy[x-1][y-z]+sn[x][z]); 后打x列
                if(y-z>0) fn[x][y]=max(fn[x][y],fn[x-1][y-z]+sy[x][z]); 先打x列
// 解释的好像有点问题。。。但大意就参照下文吧。。。
            }
    cout<<fn[m][k];
}
// 有借子弹的情况，预处理：sy[i][j],sn[i][j]表示第i列用j个子弹的得分
// y表示最后一颗不是在i列打的，n表示是
// fn[i][j],fy[i][j]表示前i列一共消耗j颗子弹，最后一颗是否打在第i列上
// 这个题很神奇。。。用到的方法就是先算出每列用的子弹数。。。会得多少分
// 然后dp的时候处理一下每种情况下最后一颗子弹就可以了
// 因为最后不一定要一棵树上吊死，可是子弹不够怎么办。。。
// 假装有。。。到底有没有就不知道了。。。如果没有预处理的没有用。。。
// 不会对后来的情况造成影响。。。 
```
而且跑的蛮快的。。。


---

## 作者：psoet (赞：50)

个人推荐 @I_AM_HelloWord 的做法，但感觉他讲的不是很清楚……想了很久终于恍然大悟。提供一种更易懂的说法？

首先，还是只在N处转移。面对Y类砖块，你不需要进行决策。（只要能打，就一定打）

其实这个“借子弹”的说法很容易让人谔谔。**子弹本身不会增加，而是打砖块的顺序发生了变化。**

比如说，我们原本先打A，但可能此时先打B更优。这时候有一个结论：**最后一个打的砖块一定为N类砖块，除非所有砖块已经打完了。** 否则，你最后一个打的是Y类砖块，打完之后必定还有子弹。

我们在计算$[1,j]$列的最优解时，涉及到这些情况：

+ 1) 第j列根本不打（直接继承$[1,j-1]$的状态）
+ 2) 最后一发子弹在第j列上（就是之前提过的最后一发打的子弹）
+ 3) 最后一发子弹在$[1,j-1]$列中
+ 4) 最后一发子弹不在$[1,j]$列中（整体上来看，在$[j+1,m]$中，但与当前状态无关，你只需要知道“不在”）

这些情况是完备的，**可以进行状态转移了。**

sum1其实对应着**当前列是最后一发子弹打的地方，因而以N结尾**。sum2则为其余的情况：**不是最后一发子弹打的地方，故而最后只能是将Y打到头。**

而这个$dp(j,k,0/1)$其实表示：$[1,j]$列中，用k发子弹，最后一发子弹是否在$[1,j]$列中。（0在1不在）

转移1：
```
dp[j][k][0]=max(dp[j-1][k][0])//这一列一个都不打。
```
单纯的继承。
转移2：
```
dp[j][k][0]=max(dp[j-1][k-tot[j][i]][1]+sum1[j][i])
```
最后一发子弹在$[1,j]$中，**同时也在第j列，故而不在 $[1,j-1]$中**。

转移3：
```
dp[j][k][0]=max(dp[j-1][k-tot[j][i]][0]+sum2[j][i])
```
最后一发子弹在$[1,j]$中，**但不在第j列，显然在**$[1,j-1]$中。

转移4：
```
dp[j][k][1]=max(dp[j-1][k-tot[j][i]][1]+sum2[j][i])
```
最后一发子弹不在$[1,j]$中，显然也不再$[1,j-1]$中，显然也不在第j列。

代码就不放了，以前的题解有。

---

## 作者：I_AM_HelloWord (赞：42)

dalao们的题解永远是我们这群蒟蒻看不懂的。

其实dalao们的转移方程写的不好看，如果按我这么写就比较好理解了。

首先，我们可以有这样一个思路：将一个n上面所有的y都压缩到这个n上面来，因为只要打掉了这个n，上面的y都是免费打掉的。

但请注意，有的时候，我们选择打掉了这个n，却没有子弹来打上面的y了（即打掉这个n的是当前状态的最后一个子弹），于是我们只好将一连串的Y压缩成一个Y，但同时又要注意，有时我们可以将后面列的Y先打掉，那么当前的子弹数并不会减少，我们还是可以打掉当前的N，而我们如果先打掉当前的N，那么就会像上面一样，没有多余的子弹打掉后面的第一个Y了。这时，我们普通的分组背包就会产生后效性。就不对了。

我们稍稍变换一下上面的思路，我们增加一个状态，表示当前列是否在之前的几列中借了子弹。

什么叫借？举个例子吧：

4 2 3
1 N 1 Y

1 Y 1 N

1 Y 1 Y

1 N 1 N


我们设dp[i][j][0/1]表示前i列，共用了j个子弹，第i列0（没借），1（借）最多能够得到的分数。这个借表示借一个子弹给别的地方。

借的子弹是指我们刚好打完一个Y后奖励的那个子弹，我们不接着打后面的N了，而是留着打别的地方的N。

而我们的最后一个子弹，一定打得是个N，如果打得是个Y，我们显然还是可以接着打的。

这时，我们考虑一个借子弹的关系。预处理出一个sum1[i][j]表示第i列打到第j行所能得到的分数，sum2[i][j]表示第i列打到第j行同时把与第j行相连的一连串的Y全部打掉能得到的分数，tot[i][j]表示第i列打到第j行所需的子弹数。

那么首先，

```cpp
dp[j][k][0]=max(dp[j-1][k][0])//这一列一个都不打。
dp[j][k][0]=max(dp[j-1][k-tot[j][i]][1]+sum1[j][i])//打掉这个N用掉了从前面借来的最后一发子弹
dp[j][k][0]=max(dp[j-1][k-tot[j][i]][0]+sum2[j][i])//打掉一连串的Y后把多余的子弹借给前面列
dp[j][k][1]=max(dp[j-1][k-tot[j][i]][1]+sum2[j][i])//在前面借一个子弹，打完一连串的Y，然后还一个子弹回去。
```
只要方程理解了，程序就很好打了。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
template<class T>void ChkMax(T &a,T b){a=a<b?b:a;}
const int INF=0x3f3f3f3f;
const int N=201;
int cur[N],tot[N][N],a[N][N],b[N][N],sum1[N][N],sum2[N][N],dp[N][N][2]={0};
int n,m,k;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main(){
    n=read(),m=read(),k=read();
    for (int i=n;i>=1;i--)
        for (int j=1;j<=m;j++){
            a[i][j]=read();
            char cmd=getchar();
            while (cmd<'A' || cmd>'Z')cmd=getchar();
            if (cmd=='Y')b[i][j]=1;
        }
    int ans=0;
    for (int j=1;j<=m;j++){
        for (int i=1;i<=n;i++){
            if (!b[i][j]){cur[j]=i;break;}
            ans+=a[i][j];
        }
    }
    for (int j=1;j<=m;j++)
        for (int i=cur[j];i<=n;i++)
            sum2[j][i]=sum1[j][i]=sum1[j][i-1]+a[i][j];
    for (int j=1;j<=m;j++){
        tot[j][cur[j]]=1;
        for (int i=cur[j];i<=n;i++){
            int idx=i;
            while (b[idx+1][j])idx++;
            sum2[j][i]+=sum1[j][idx]-sum1[j][i];
            tot[j][idx+1]=tot[j][i]+1;
            i=idx;
        }
    }
    for (int j=0;j<=m;j++)
        dp[j][0][0]=-INF;
    for (int j=1;j<=m;j++){
        for (int tk=1;tk<=k;tk++){
            dp[j][tk][0]=dp[j-1][tk][0];
            dp[j][tk][1]=dp[j-1][tk][1];
            for (int i=cur[j];i<=n;i++)
                if (!b[i][j] && tk>=tot[j][i]){
                    ChkMax(dp[j][tk][0],dp[j-1][tk-tot[j][i]][1]+sum1[j][i]);
                    ChkMax(dp[j][tk][0],dp[j-1][tk-tot[j][i]][0]+sum2[j][i]);
                    ChkMax(dp[j][tk][1],dp[j-1][tk-tot[j][i]][1]+sum2[j][i]);
                }
        }
    }
    printf("%d",dp[m][k][0]+ans);
    return 0;
}
```

---

## 作者：Azuree (赞：31)

[查看原题请戳这里](https://www.luogu.org/problem/P1174)

## 导入

我们先来看一个看似正确的分组背包的方法：

我们将每一列拆分为n个物品，第$m$行第$k$个物品的价值是$\sum_{i=k}^na[i][m]$，其代价为$\sum_{i=k}^n[pd[i][m]=1]$。

简单的说，第$m$行第$k$个物品的价值是第$m$行$k-n$个砖块价值的总和，代价为打完这些砖块需要的子弹数。

然后，我们就以此来跑一边分组背包，~~于是就愉快的暴0了~~。

为什么呢？

因为如果当前一个标记为$Y$的砖块在最下方，但是我们手中并没有子弹了，那么虽然这个砖块在打前和打后我们拥有的子弹数不变，即代价为$0$，但我们却已经没有办法去打这个砖块了。

## 正解

#### 预处理

我们可以发现，如果我们当前有$Y$在最下方，而我们最新打的一个砖块的标记为$N$，那么我们完全可以先不打$N$，而是先打$Y$，然后再用新获得的子弹去打那个$N$。

由于当某个标记为$Y$的砖块在最下方时，直接去打掉这个砖块肯定是最优的，所以我们可以贪心地把所有的Y都压在一起。更确切的，我们是把这些标记为$Y$的砖块压到了这些砖块下方的那个砖块。根据引入中提到的那个问题，由于我们打完$N$以后可能恰好用完了所有的子弹，所以我们用$v[i][j][0]$表示第$i$列用$j$发子弹且最后一发子弹打到了$N$上能获得的价值，用$v[i][j][1]$表示第$i$列用$j$发子弹且最后一发子弹打到了$Y$上时获得的价值。

#### 状态设计

我们用$f[i][j][0]$表示前$i$行用$j$发子弹且最后一发子弹打到了标记为$N$的砖块能获得的最大价值，$f[i][j][1]$表示前$i$行用$j$发子弹且最后一发子弹打到了标记为$Y$的砖块能获得的最大价值。

#### 状态转移

先贴一波代码：

```cpp
for(int i = 1; i <= m; i++)
        for(int j = 0; j <= k; j++)
            for(int l = 0; l <= min(n,j); l++)
            {
                f[i][j][1] = max(f[i][j][1],f[i - 1][j - l][1] + v[i][l][1]);
                if(l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][1] + v[i][l][0]);
                if(j > l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][0] + v[i][l][1]);
            }
```

其中$i$是枚举到了前$i$列，$j$是前$i$列共用了$j$发子弹，$l$是第$j$列用了$l$发子弹。

```cpp
f[i][j][1] = max(f[i][j][1],f[i - 1][j - l][1] + v[i][l][1]);
```
这个转移是说我从$1$到$j-1$列借一发子弹(从最后一发子弹达到标记为$Y$的砖块进行转移，这样才能借到剩余的子弹)，先用原本分配给这一列的$l$枚子弹打完所以能打的$N$，然后再用借来的子弹把所以压缩到这个$N$上的$Y$打掉（特殊的，如果这个$N$后面没有$Y$，那我就不打，这样无论如何最终我都会剩余一颗子弹没有用）。

```cpp
if(l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][1] + v[i][l][0]);
```

这个转移是说如果我分配给了第$j$列了子弹（若$l=0$，则我并没有消耗子弹去打第$j$列的砖块，那么这个转移没有意义），我如果从$1$到$i-1$列借子弹能获得的最大价值。

```cpp
if(j > l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][0] + v[i][l][1]);
```

这个转移是说如果我让第$1$到$i-1$列消耗了一定量的子弹，且不从其中某列借子弹，第$1$到$i-1$列能够获得的最大价值。

注：在前两段中所说的`消耗子弹`是指打完某些砖块后总子弹数变少，只打标记为$Y$的砖块不算消耗子弹。

#### 代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

int n,m,k,cnt,a[205][205],b[205][205],v[205][205][2],f[205][205][2];

char c;

int main()
{
    n = read(); m = read();k = read();
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            cin >> a[i][j] >> c;
            if(c == 'Y') b[i][j] = 1;
        }
    for(int i = 1; i <= m; i++)
    {
        cnt = 0;
        for(int j = n; j >= 1; j--)
        {
            if(b[j][i]) v[i][cnt][1] += a[j][i];
            else cnt++,v[i][cnt][1] = v[i][cnt - 1][1] + a[j][i], v[i][cnt][0] = v[i][cnt - 1][1] + a[j][i];
        }
    }
    for(int i = 1; i <= m; i++)
        for(int j = 0; j <= k; j++)
            for(int l = 0; l <= min(n,j); l++)
            {
                f[i][j][1] = max(f[i][j][1],f[i - 1][j - l][1] + v[i][l][1]);
                if(l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][1] + v[i][l][0]);
                if(j > l) f[i][j][0] = max(f[i][j][0],f[i - 1][j - l][0] + v[i][l][1]);
            }
    printf("%d\n",f[m][k][0]);
    return 0;
}
```

---

## 作者：cqbzjyh (赞：23)

这题一看就是一道 $dp$ 

我们可以定义两个辅助数组 $dn[i][j]$ 和 $dy[i][j]$

$dn[i][j]$ 表示在第 $i$ 列打 $j$ 枪最后一枪打在 $\rm N$ 上所得分数

$dy[i][j]$ 表示在第 $i$ 列打 $j$ 枪最后一枪打在 $\rm Y$ 上所得分数

然后我们就可以开始 $dp$ 了

---

### 定义 $:$

$dpn[i][j]$ 表示在前 $i$ 列打 $j$ 枪最后一枪打在 $\rm N$ 上所得最大分数

$dpy[i][j]$ 表示在前 $i$ 列打 $j$ 枪最后一枪打在 $\rm Y$ 上所得最大分数

---

三层循环 $i,j,l$ 分别枚举前 $i$ 列，打 $j$ 发子弹，在第 $i$ 列打 $l$ 发子弹

### 状态转移：

$$
dpy_{i,j} = \max(dpy_{i,j}, dpy_{i-1,j-1} + dy_{i,l})
$$

$$ 
dpn_{i,j} =
\begin{cases} 
\max(dpn_{i,j},\ dpy_{i-1,j-l}+dn_{i,l}),  & \text{if }l \ne 0
\\
\max(dpn_{i,j},\ dpn_{i-1,j-l}+dy_{i,l}),  & \text{if }j \ne 0
\end{cases}
$$

---

此算法时间复杂度为 $\mathcal{O}(nmk)$

最后给出完整 **code**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
bool c[205][205];
char x;
int a[205][205];
int dy[205][405], dn[205][405], dpn[205][405], dpy[205][405];
int main() {
	scanf("%d %d %d\n", &n, &m, &k);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j] >> x;
			if (x == 'Y') c[i][j] = 1;
		}
	}
	for (int j = 1; j <= m; j++) {
		int tot = 0;
		for (int i = n; i >= 1; i--) {
			if (c[i][j] == 1) dy[j][tot] += a[i][j];
			else {
				tot++;
				dn[j][tot] = dy[j][tot - 1] + a[i][j];
				dy[j][tot] = dn[j][tot];
			} 
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 0; j <= k; j++) {
			for (int l = 0; l <= min(j, n); l++) {
				dpy[i][j] = max(dpy[i][j], dpy[i - 1][j - l] + dy[i][l]);
				if (l != 0) dpn[i][j] = max(dpn[i][j], dpy[i - 1][j - l] + dn[i][l]);
				if (j != l) dpn[i][j] = max(dpn[i][j], dpn[i - 1][j - l] + dy[i][l]);
			}
		}
	}
	printf("%d", dpn[m][k]);
	return 0;
}
```


---

## 作者：WLQ567 (赞：13)





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=200+10;
int a[maxn][maxn];
int dp_y[maxn][maxn],dp_n[maxn][maxn];//dp_y表示前j列打了i发子弹，最后一发不打第j列 (dp_n同理，但要打最后一发)
int dy[maxn][maxn],dn[maxn][maxn];//d_y表示第j列打第i发子弹，不打最后一发子弹(d_n同理，但要打最后一发) 
char c[maxn][maxn];
int main() {
    int k,n,m;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d %c",&a[i][j],&c[i][j]);
    int cnt;
    for(int i=1;i<=m;i++){ 
        cnt=n;//行数 
        while(cnt>0&&c[cnt][i]=='Y'){
            dy[i][0]+=a[cnt][i];
            cnt--;
        }
        for(int j=1;j<=n&&cnt>0;j++) {
            dn[i][j]=dy[i][j-1]+a[cnt][i];
            dy[i][j]=dn[i][j];//无Y,看作相同 
            cnt--;
            while(cnt>0&&c[cnt][i]=='Y') {
                dy[i][j]+=a[cnt][i];//有Y，可直接加入，不废子弹 
                cnt--;
            }
        }
    }
    for(int j=1;j<=m;j++)//枚举列 
        for(int i=0;i<=k;i++)//子弹数 
            for(int x=0;x<=n;x++)//打出的子弹数 
                if(x<=i){
                    dp_y[j][i]=max(dp_y[j][i],dp_y[j-1][i-x]+dy[j][x]);//dp_y[j][i]所包括的砖块除了在i发子弹能
                    //够直接打下的最大得分外，还有再多一发子弹就能打下的所有Y的砖块的得分。
                    if(x<i)dp_n[j][i]=max(dp_n[j][i],dp_n[j-1][i-x]+dy[j][x]);
                    //表示在j-1列中一定有一砖块是用我们手上的子弹直接打下来的，
                    //如果，该砖块是Y，我们可以打下它后，用奖励的那发子弹去打第j列靠上的Y砖块。
                    //如果，该砖块是N，我们可以先用一发子弹去打第j列所要打的Y砖块，用j列最后一个被打下的Y砖块所奖励的子弹去打那个N砖块。
                    if(x>0)dp_n[j][i]=max(dp_n[j][i],dp_y[j-1][i-x]+dn[j][x]);
                }
    printf("%d\n",dp_n[m][k]);
    return 0;
}
```

---

## 作者：Harry_Hedwig (赞：11)

# 0x00 思路
~~此题让我十分的销魂（销魂：极度悲伤）~~

先看题。
>小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下在刚开始的时候，有 $n$ 行 $\times m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，**打碎某一列当前处于这一列最下面的那块砖**，并且得到相应的得分。**某些砖块在打碎以后，还可能将得到一发子弹的奖励**。最后**当所有的砖块都打碎了，或者小红没有子弹了，游戏结束**。小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的**最大得分**，可是这个问题对于她来说太难了，你能帮帮她吗？

~~回答问题：不能~~。看完题目会有一个明显的区间 dp 思路,我们很明显可以定义一个 dp 数组来存储前 $i$ 列用 $j$ 个子弹最多所得分数。

# 0x01 初始化
由于我们需要用到每一列用 $i$ 颗子弹可以得到的分数（没有最大，因为分数唯一），为节省时间所以我们准备算出它们。

## coding
**注：(非最终答案)**
```c
for(i=1;i<=m;i++)//列
{
	for(j=1,w=n;j<=k&&w>0;j++,w--)//子弹未消耗完（j），砖块未打完（w）
	{
		if(c[w][i]=='Y')//Y不消耗子弹
			sum[i][--j]+=f[w][i];
		else
			sum[i][j]=sum[i][j-1]+f[w][i];
	}
}
```

好了，这个初始化出来了你就可以得一些分了（全是 $N$ 的情况）。

只想得部分分的同学可直接跳转0x02。
---

那么为了得 $100pts$ 的谷友们，你们可以先测试一下这组数据：（输出 $8$）
```
3 3 3
1 Y 1 Y 1 Y
1 N 1 N 1 N
1 Y 1 Y 1 Y
```

你会发现如果你的初始化是如上的初始化时，你的程序会输出 $9$ 。可你只能得到 $8$ 。

原因很简单，当你在打最后一块砖（一定是 $Y$）时你没子弹了！但是由于程序自动认为打 $Y$ 不消耗子弹，所以你的程序就将输出 $9$ 。

为了得到满分，可以思考 $Y$ 和 $N$ 的不同，既然这是 $2$ 种不同的砖块，那么可以用 $2$ 个数组来分别记录**最后**打到的砖是 $Y$ 和 $N$ 的得分，就阻止了上述情况的出现。

那么为了防止冷不丁在这一列中出现 $Y$ 而打得你措手不及，你的记录 $Y$ 的数组仍然要记录 $N$ 的状态。

## code
**注：最终代码**
```c
for(i=1;i<=m;i++)
{
	for(j=1,w=n;j<=min(n,k)&&w>0;j++,w--)//j,w意义同上
	{
		if(c[w][i]=='Y') //根据前文，dy为最后打'Y',dn为最后打'N'
			dy[i][--j]+=f[w][i];
		else
			dy[i][j]=dy[i][j-1]+f[w][i],dn[i][j]=dy[i][j];
	}
}
```
# 0x02 区间 dp
仍然分 $2$ 部分，前面是部分分，后面是满分。

定义数组 `dp[i][j]` : 用 $j$ 颗子弹打前 $i$ 列砖块的最大得分。

那么由于是区间 dp，所以假设用了 $l$ 颗子弹来打第 $i$ 列砖，那么前 $i-1$ 列就用了 $j-l$ 颗子弹，求得最大值即可。
## coding
```c
for(i=1;i<=m;i++)//第i列
{
	for(j=1;j<=k;j++)//前i列共用j颗子弹
	{
		for(l=0;l<=j;l++)//当前列使用的子弹数
			dp[i][j]=max(dp[i-1][l]+sum[i][j-l],dp[i][j]);
	}
}
```
（对于部分分）End
---
你会发现你根本没有办法得满分（状态转移如上的话），于是你就会再次思考：子弹打在 $Y$ 上和在 $N$ 上有什么区别？

由于打 $Y$ 会附赠一颗子弹，那么相当于没有使用子弹，但是打在 $N$ 上就没有这个反馈，因此最后一颗子弹**一定**打在 $N$ 砖块上。那么由于顺序不定，所以你可以先打后面再返回来打前面，所以这是最后一颗子弹有 $3$ 种打法：在此列使用、在前面的列使用或在之后使用。

仍然是 $3$ 重循环，分别表示前 $i$ 列用 $j$ 颗子弹，且当前列使用 $l$ 颗子弹。

那么我们里面的状态转移就会发生改变：先定义 $2$ 个 dp 数组，分别表示在前 $i$ 列**没有用光** $j$ 颗子弹（$dp1$），在前 $i$ 列**用光了** $j$ 颗子弹（$dp2$）。

根据我们上面的推论，这里就有 $2$ 种情况。

- 没打完。
	
    更新 $dp1$。
    ## code:    
    ```c
    dp1[i][j]=max(max(dp2[i-1][j-l],dp1[i-1][j-l])+dy[i][l],dp1[i][j]);
    ```
    **注:**
    1. $dp2[i-1][j-1]$ 在前 $i-1$ 列打完了 $j-l$ 颗子弹。
    2. $dp1[i-1][j-l]$ 在前 $i-1$ 列都没打完 $j-l$ 颗子弹。
    3. $dy[i][l]$ 在第 $i$ 列没打完 $l$ 颗子弹。
    
- 用完了
	- 在这一列用了第 $j$ 颗子弹
    
		前提是有条件（即你在这一行用了子弹）
   		 ## code:
    	```c
    	if(l>0)
					dp2[i][j]=max(dp2[i][j],dp1[i-1][j-l]+dn[i][l]);
   		 ```
    
	- 不在这一列用了第 $j$ 颗子弹
	
  	 前提是你没有在这一列用了全部的子弹
   	## code:
   	```c
   		if(l<j)
			dp2[i][j]=max(dp2[i][j],dp2[i-1][j-l]+dy[i][l]);
  	 ```
   	**注：**
    
    1. $dp2[i-1][j-l]$ 在前 $i-1$ 列用完了 $j-l$ 个子弹。
    2. $dy[i][l]$ 因为没有在这一列用第 $j$ 颗子弹，所以最后打的砖块用的也一定不是第 $j$ 个子弹，那你怎么能用 $dn[i][l]$ 呢？是吧。
   
在最后输出的时候输出 $dp2[m][k]$ 就好了，因为它代表在前 $m$ 列用了 $k$ 颗子弹最多所得分数（~~你本来就只有 $m$ 列 $k$ 颗子弹好吧~~）
# 结束语
说实话，这道题挺恶心的，因为它的思维量很大，所以很难去想怎么做。就给你一种：我知道它是区间 dp，但是就是做不出来的无奈心情。

但是不得不说，这个 dp 题真的挺好，不做可惜了QWQ。

（代码就不用给了吧……都已经放题解里了……）

---

## 作者：panda_eater (赞：9)

这道题非常妙啊...虽然看上去是线性dp，但还要加一个维度来记录状态。

思路：贪心+dp。

1. 首先找出最下面一行是Y的砖块，可以免费打掉。

2. 对于Y与N交叉的地方，将一个N上面全部的连续的Y的总分累加进N所在位置，用数组now储存。每一列前缀和用res储存，最后now要加上res，表示将该点下面所有的点都选了，而且把该点上面的连续的y砖块也打了。还要预处理出来在第j列，打掉前i个砖块所需的子弹，用ci数组储存。

3. 这时候用到分组背包的思想。dp[j][i][0]表示前j列总共耗费i个子弹，且之后不用"借"子弹，dp[i][j][1]表示之后还要”借“子弹，所能得到的最大分数（“借”的意思：比如第一列是 2 Y 2 N 且N必须先打掉，那么dp[1][1][0]=2,dp[1][1][1]=4），答案即为dp[m][k][0]。


状态转移方程： dp[j][k][0]=max(dp[j][k][0],max(dp[j-1][k-ci[j][i]][1],dp[j-1][k-ci[j][i]][0])+res[j][i]);

dp[j][k][0]=max(dp[j][k][0],dp[j-1][k-ci[j][i]][0]+now[j][i]);

dp[j][k][1]=max(dp[j][k][1],dp[j-1][k-ci[j][i]][1]+now[j][i]);

初始化： for(j=0;j<=m;j++) dp[j][0][0]=-inf;


---

## 作者：迷失之夜 (赞：3)

我来为楼下(关于DP方程)补充下解释(因为我之前就是看得一脸懵逼)：


dp[j][k][0]=max(dp[j][k][0],max(dp[j-1][k-ci[j][i]][1],dp[j-1][k-ci[j][i]][0])+res[j][i]);

//这里很好理解的，就是前面j-1列(找第j列借子弹)借或不借，但是当前第j列不去找别人借子弹


dp[j][k][0]=max(dp[j][k][0],dp[j-1][k-ci[j][i]][0]+now[j][i]);

//这里，是我之前一直纠结的地方，感觉这个方程多余了，其实是我的想法多余这里其实是前面不找第j列借，但是当前第j列可以找前面借子弹

Orz……


dp[j][k][1]=max(dp[j][k][1],dp[j-1][k-ci[j][i]][1]+now[j][i]);

//这里是处理dp[j][k][1]，上一行理解了，这一行就没什么难度了


博客：http://blog.qbudg.link/?p=845


---

## 作者：kczno1 (赞：2)

1:贪心 能直接免费打的先打了


2:预处理 计算第i列用j发子弹能打的砖块

由于存在"借"(即用完子弹后先借子弹把免费的打了再还子弹)与"不借"两种情况，故需分两个数组存储


3:动规 前i列用j发子弹能打的砖块(可转成1维存储)

最终答案不能全由"借"的状态构成(否则会剩有1组无人可借)

所以再用一个数组存储全由"借"的状态构成的答案，

该数组+"不借"状态=最终答案的一个方案。


```delphi

var
  n,m,k,i,j,base,x,o,cost,maxo:longint;
  f0,f,f1:array[0..200,0..200]of longint;
  c:array[0..200,0..200]of char;
  ans,ans1,l:array[0..200]of longint;
  kong:char;

function min(x,y:longint):longint;
begin
  if x<y then exit(x);
  exit(y);
end;

function max(x,y:longint):longint;
begin
  if x>y then exit(x);
  exit(y);
end;

begin
  readln(n,m,k);
  for i:=1 to n do
  begin
   for j:=1 to m do
    read(f0[i,j],kong,c[i,j]);
   readln;
  end;

  for j:=1 to m do
  begin
   l[j]:=n;
   while (l[j]>0)and(c[l[j],j]='Y') do
   begin
    inc(base,f0[l[j],j]);
    dec(l[j]);
   end;
  end;

  for j:=1 to m do
  begin
   i:=l[j]; x:=0;
   while i>0 do
   begin
    inc(x); 
    f[j,x]:=f1[j,x-1]+f0[i,j];
    f1[j,x]:=f[j,x];
    dec(i);
    while (c[i,j]='Y')and(i>0) do
    begin
     inc(f1[j,x],f0[i,j]);
     dec(i);
    end;
   end;
   l[j]:=x;
  end;

  for j:=1 to m do
   for i:=k downto 1 do
   begin
    maxo:=min(l[j],i);
    for o:=1 to maxo do
    begin
     ans1[i]:=max(ans1[i],ans1[i-o]+f1[j,o]);
     if o<i then
     begin
      ans[i]:=max(ans[i],ans[i-o]+f1[j,o]);
      ans[i]:=max(ans[i],ans1[i-o]+f[j,o]);
     end
     else ans[i]:=max(ans[i],ans[i-o]+f[j,o]);
    end
   end;

  writeln(base+ans[k]);
end.

```

---


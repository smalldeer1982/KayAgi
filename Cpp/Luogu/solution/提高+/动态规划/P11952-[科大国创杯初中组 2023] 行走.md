# [科大国创杯初中组 2023] 行走

## 题目描述

小可可和小多来到了一个网格图上进行最短路训练。

这是一个 $n \times n$ 的网格图，对于点 $(x, y)$，如果 $y < n$，则它向 $(x, y+1)$ 有一条有向边，边权为 $ea_{x,y}$；如果 $x < n$，则它向 $(x+1, y)$ 有一条有向边，边权为 $eb_{x,y}$。小可可需要在很短的时间内找到从 $(1,1)$ 到 $(n,n)$ 的最短路。

然而，小多会捣乱 $q$ 次：小雪会删去图中的一条边，然后小可可就需要重新计算 $(1,1)$ 到 $(n,n)$ 的最短路。当小可可计算完成后，小多就会恢复这条边。即：每次小多删掉的边只会影响到这一次小可可的计算。

小可可坚持尝试不借助外力，自己每次计算出答案。可惜小可可不是机器人，没过一会儿他就晕倒了。于是，计算最短路的任务就落到了你的头上。

## 说明/提示

### 数据规模与约定

对于 $20\%$ 的数据，满足 $n,q \leq 5, B = 1$；

对于 $40\%$ 的数据，满足 $n,q \leq 300$；

对于 $70\%$ 的数据，满足 $n \leq 300$；

对于 $100\%$ 的数据，有 $2 \leq n \leq 5000, 1 \leq q \leq 10^5, 1 \leq B \leq 30, 1 \leq x, y, x', y' \leq n$。

## 样例 #1

### 输入

```
4 4
10583998785722269293 2
2 2 2 3
2 3 3 3
1 2 2 2
1 1 1 2```

### 输出

```
5
4
7
9```

# 题解

## 作者：XZhuRen (赞：2)

图床挂了，重传。

这场的简单题……你谷评紫真就全员小学生？

考虑不操作，就是求网格图最短路。

断边，做两遍最短路。

操作情况下，即正反求一遍，发现最短路形如暴力把网格断开处 $\text{L}$ 形状的断边求一遍。

[![pEDR4df.png](https://s21.ax1x.com/2025/03/26/pEDR4df.png)](https://imgse.com/i/pEDR4df)

这里手动分讨一下就可以 $\mathcal{O}(nq)$，拿到 $70 \text{pts}$ 了。

注意到转移是后缀形式，两个后缀最小就好。

场上是可以新开数组的，洛谷这里卡了一下，直接把 $ea,eb$ 覆盖就好。

远古代码，码风较为“优美”。

```cpp

#include <bits/stdc++.h>
using namespace std;
const int N=5005,Q=100005;
typedef long long ll1;
ll1 n,q,B;
ll1 f[N][N],f1[N][N],ans;
ll1 ea[N][N],eb[N][N];
// ll1 sufmn1[N][N],sufmn2[N][N];
unsigned long long seed;
void xorshift64() {
	seed ^= seed << 13;
	seed ^= seed >> 7;
	seed ^= seed << 17;
}
const ll1 inf=1e16+8;
void init(){
	f[1][1]=0;
	f1[n][n]=0;
	for(int i=2;i<=n;i++)f[1][i]=f[1][i-1]+ea[1][i-1];
	for(int j=2;j<=n;j++)f[j][1]=f[j-1][1]+eb[j-1][1];
	for(int i=n-1;i>=1;i--)f1[n][i]=f1[n][i+1]+ea[n][i];
	for(int j=n-1;j>=1;j--)f1[j][n]=f1[j+1][n]+eb[j][n];
	for(int i=2;i<=n;i++)for(int j=2;j<=n;j++)f[i][j]=min(f[i][j-1]+ea[i][j-1],f[i-1][j]+eb[i-1][j]);
	for(int i=0;i<=n+1;i++)
		for(int j=0;j<=n+1;j++){
			if(i<1||j<1||j>=n||i>n)ea[i][j]=inf;
			if(i<1||j<1||j>n||i>=n)eb[i][j]=inf;
		}
	for(int i=n-1;i>=1;i--)for(int j=n-1;j>=1;j--)f1[i][j]=min(f1[i][j+1]+ea[i][j],f1[i+1][j]+eb[i][j]);
	for(int j=1;j<=n;j++)
	for(int i=n;i>=1;i--)
	ea[i][j]=min(ea[i+1][j],f[i][j]+f1[i][j+1]+ea[i][j]);
	for(int i=1;i<=n;i++)
	for(int j=n;j>=1;j--)
	eb[i][j]=min(eb[i][j+1],f[i][j]+f1[i+1][j]+eb[i][j]);
}
int main(){
	// freopen("1.in","r",stdin);
	scanf("%lld%lld",&n,&q);
	scanf("%llu%llu",&seed,&B);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j != n; j++) {
			xorshift64();
			ea[i][j] = seed & ((1 << B) - 1);
		}
	}
	for(int i = 1; i != n; i++) {
		for(int j = 1; j <= n; j++) {
			xorshift64();
			eb[i][j] = seed & ((1 << B) - 1);
		}
	}
	int i,j,qx1,qy1,qx2,qy2;
	init();
	while(q--){
		scanf("%d%d%d%d",&qx1,&qy1,&qx2,&qy2);
		ans=inf;
		if(qx1==qx2){
			j=qy1;
			ans=min(ans,ea[qx1+1][j]);
			i=qx1-1;
			ans=min(ans,eb[i][qy1+1]);
		}else{
			j=qy1-1;
			ans=min(ans,ea[qx1+1][j]);
			i=qx1;
			ans=min(ans,eb[i][qy1+1]);
		}
		printf("%lld\n",ans);
	}
}

```

---

## 作者：封禁用户 (赞：1)

[*作为一道令我印象深刻的题目，我有必要写篇题解！*](https://www.luogu.com.cn/article/ntirmev3)

不难看出，当存在一条最短路不经过所删去的边时，答案一定不变。我们只要额外对所有最短路必经边求出答案就可以了。

最短路必经边显然不超过 $2n-2$ 条，因为任意一条经过 $2n-2$ 条边的最短路都会把其他所有边标记为非必经边。这提示我们可以一条一条求解。

由于这是网格图，我们每走一条边，要么会把横坐标 $x_0$ 增加 $1$，要么会把纵坐标 $y_0$ 增加 $1$，而 $x_0+y_0$ 的值一定恰好增加 $1$。

也就是说，如果一条路径没有经过边 $(x_1,y_1) \to (x_2,y_2)$，那么只有两类情况：

- 经过了从 $(x_1,y_1)$ 出发的（除 $(x_1,y_1) \to (x_2,y_2)$ 之外唯一的，甚至可能不存在）另一条边 $(x_1,y_1) \to (x_3,y_3)$；
- 经过了另一个点 $(x_0,y_0)$，其中 $x_0+y_0=x_1+y_1$。

设 $f(x_0,y_0)$ 为 $(1,1) \to (x_0,y_0)$ 的最短路，$g(x_0,y_0)$ 为 $(x_0,y_0) \to (n,n)$ 的最短路，$h(x_1,y_1,x_3,y_3)$ 为（输入的）边 $(x_1,y_1) \to (x_3,y_3)$ 的边权，那么边 $(x_1,y_1) \to (x_2,y_2)$ 是最短路必经边，当且仅当（点的记号与上面相同）：

- $f(n,n)=f(x_1,y_1)+h(x_1,y_1,x_2,y_2)+g(x_2,y_2)$。
- $f(n,n)<f(x_1,y_1)+h(x_1,y_1,x_3,y_3)+g(x_3,y_3)$。
- $f(n,n)<f(x_0,y_0)+g(x_0,y_0)$。

最后，对于最短路必经边，$f(x_0,y_0)+g(x_0,y_0)$ 和 $f(x_1,y_1)+h(x_1,y_1,x_3,y_3)+g(x_3,y_3)$ 中的较小值就是该条边对应的答案。

**总流程：**

- $O(n^2)/O(n^2)$ 读入。
- $O(n^2)/O(n^2)$ 求解 $f,g$ 数组。
- $O(n^2)/O(n)$ 枚举 $x_0+y_0$ 的值并判断最短路必经边（同时求解答案）。
- $O(n \log n)/O(n)$ 用 `map` 存储最短路必经边删去时的答案。
- $O(q \log n)/O(1)$ 处理询问。

最终的时间复杂度为 $O(n^2+q \log n)$，空间复杂度为 $O(n^2)$。

**AC Code：**

```cpp
#include <bits/stdc++.h>
using namespace std;const int N = 5005, Q = 100005;int n, q, B;int ea[N][N], eb[N][N];int qx1[Q], qy1[Q], qx2[Q], qy2[Q];unsigned long long seed;void xorshift64() {  seed ^= seed << 13;  seed ^= seed >> 7;  seed ^= seed << 17;}
#define longlong int 
void init(){  cin >> n >> q;cin >> seed >> B;for (int i = 1; i <= n; i++) {for (int j = 1; j != n; j++) {xorshift64();ea[i][j] = seed & ((1 << B) - 1);}}for (int i = 1; i != n; i++) {for (int j = 1; j <= n; j++) {xorshift64();eb[i][j] = seed & ((1 << B) - 1);}}for (int i = 1; i <= q; i++) {scanf("%d%d%d%d", qx1 + i, qy1 + i, qx2 + i, qy2 + i);}}
long long m1[N][N],m2[N][N];
bool taga[N][N],tagb[N][N];
long long usuans;
struct E
{
	char t;
	int x;
	int y;
};
bool operator!=(E x,E y)
{
	return x.t!=y.t||x.x!=y.x||x.y!=y.y;
}
bool operator<(E x,E y)
{
	if(x.t!=y.t) return x.t<y.t;
	else if(x.x!=y.x) return x.x<y.x;
	else return x.y<y.y;
}
queue<E> w;
map<E,long long> mp;
int main()
{
	init();
	for(int i=2;i<=n;i++)
		m1[i][1]=m1[i-1][1]+eb[i-1][1];
	for(int i=2;i<=n;i++)
		m1[1][i]=m1[1][i-1]+ea[1][i-1];
	for(int i=2;i<=n;i++)
		for(int j=2;j<=n;j++)
			m1[i][j]=min(m1[i-1][j]+eb[i-1][j],m1[i][j-1]+ea[i][j-1]);
	for(int i=n-1;i>=1;i--)
		m2[n][i]=m2[n][i+1]+ea[n][i];
	for(int i=n-1;i>=1;i--)
		m2[i][n]=m2[i+1][n]+eb[i][n];
	for(int i=n-1;i>=1;i--)
		for(int j=n-1;j>=1;j--)
			m2[i][j]=min(m2[i][j+1]+ea[i][j],m2[i+1][j]+eb[i][j]);
	usuans=m1[n][n];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n-1;j++)
			if(m1[i][j]+m2[i][j+1]+ea[i][j]==usuans) taga[i][j]=true;
	for(int i=1;i<=n-1;i++)
		for(int j=1;j<=n;j++)
			if(m1[i][j]+m2[i+1][j]+eb[i][j]==usuans) tagb[i][j]=true;
	for(int i=2;i<=n+n-1;i++)
	{
		E sp=(E){'*',0,0};
		for(int j=min(i-1,n),k=i-j;j>=1&&k<=n;j--,k++)
		{
			if(taga[j][k])
			{
				if(sp!=(E){'*',0,0})
				{
					sp=(E){'*',0,0};
					break;
				}
				else sp=(E){'a',j,k};
			}
			if(tagb[j][k])
			{
				if(sp!=(E){'*',0,0})
				{
					sp=(E){'*',0,0};
					break;
				}
				else sp=(E){'b',j,k};
			}
		}
		if(sp!=(E){'*',0,0})
		{
			mp[sp]=123456789123456789;
			w.push(sp);
		}
	}
	while(!w.empty())
	{
		E sp=w.front();
		w.pop();
		long long c=123456789123456789;
		if(sp.t=='a')
		{
			for(int i=sp.x+1;i<=n;i++)
				c=min(c,m1[i][sp.y]+m2[i][sp.y]);
		}
		if(sp.t=='b')
		{
			for(int i=sp.y+1;i<=n;i++)
				c=min(c,m1[sp.x][i]+m2[sp.x][i]);
		}
		if(sp.y!=1&&sp.x!=n)
		{
			long long d=m1[sp.x+1][sp.y-1]+ea[sp.x+1][sp.y-1];
			c=min(c,d+m2[sp.x+1][sp.y]);
			for(int i=sp.x+2;i<=n;i++)
			{
				d=min(d+eb[i-1][sp.y],m1[i][sp.y-1]+ea[i][sp.y-1]);
				c=min(c,d+m2[i][sp.y]);
			}
		}
		if(sp.x!=1&&sp.y!=n)
		{
			long long d=m1[sp.x-1][sp.y+1]+eb[sp.x-1][sp.y+1];
			c=min(c,d+m2[sp.x][sp.y+1]);
			for(int i=sp.y+2;i<=n;i++)
			{
				d=min(d+ea[sp.x][i-1],m1[sp.x-1][i]+eb[sp.x-1][i]);
				c=min(c,d+m2[sp.x][i]);
			}
		}
		mp[sp]=c;
	}
	for(int i=1;i<=q;i++)
	{
		E sp=(E){'*',qx1[i],qy1[i]};
		if(qy2[i]!=qy1[i]) sp.t='a';
		else sp.t='b';
		if(!mp.count(sp)) cout<<usuans<<endl;
		else cout<<mp[sp]<<endl;
	}
	return 0;
}
```

---

## 作者：Priestess_SLG (赞：1)

狗屎题。下面提供一个在原有时空限制（$\textbf{2s}\ /\ \textbf{500MB}$）下能通过的算法。

首先因为图是网格图，所以容易想到设 $f_{i,j}$ 为从 $(1,1)$ 开始向下走到 $(i,j)$ 所需要的最小边权，转移容易。若此时无删除操作，则答案即为 $f_{n,n}$。

对于一次删除操作，若其不在最短路上，则显然答案仍然为 $f_{n,n}$。否则本质不同的边的数目只有 $2n-1<10^4$ 条。此时考虑经典结论：所有从 $(1,1)$ 到 $(n,n)$ 的路径对于每一个 $w\in[1,2n)$ 至少要经过一个 $x+y=w$ 的点 $(x,y)$。因此对于这样的询问直接暴力枚举所有满足 $x+y=w$ 的点然后钦定最短路经过这个点，用 $f,g$ 两个数组更新答案，取最小值即可。因为有 $Q$ 次询问，且 $Q$ 的量级远远大于 $O(n)$，因此需要对询问做记忆化，因为任意一条合法路径上从 $(1,1)$ 向 $(n,n)$ 走的过程中都必须恰好经过 $x+y=w$，$w\in[1,2n)$ 的 $(x,y)$ 一次，因此直接对 $x+y$ 的值做记忆化即可。

如果你希望快速的过掉这个题，那么你可以忽略下面一段的内容。如果你希望在原时空限制下过掉题，那么你应当阅读下面一段的内容。

该算法时空复杂度均为 $O(n^2)$，但是因为要开 $2$ 个 `int` 类型的 $n\times n$ 数组存储边权，两个 `long long` 类型的 $n\times n$ 数组存储 $f,g$ 两个 dp 信息，所以在原有空间限制下会爆炸（现在应该不会了）。感觉很♂受，于是分析 $f,g$ 数组存储信息的上界：恰好经过 $2n-1$ 条边，每条边边权最大不超过 $2^{30}$。因为 $2n-1<10^4$，所以乘起来的值小于 $2^{48}$，可以用 $3$ 个 `unsigned short` 压到一起存储计算答案。这样耗的空间为 `500.2MB`。考虑到还需要存储最短路的路径，而路径只有右 / 下两个方向，因此考虑用 `bitset` 压一下，此时空间耗费为 `482.8MB`，可以卡过。然后稍微卡一下常再用 `C++98 with O2` 就可以勉强卡过。下面是（这个人在疯了的时候写的）代码。

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool beginmemory;
const int N=200010;
namespace Mahiro{
    typedef long long ll;
    unsigned long long seed;
    int B;
    unsigned long long xorshift64(){
        seed ^= seed << 13;
        seed ^= seed >> 7;
        seed ^= seed << 17;
        return seed;
    }
} using namespace Mahiro;
class int48_t
{
public:
    int48_t();
    int48_t(unsigned long long value);

    int48_t operator+ (int48_t value);
    int48_t operator* (unsigned long long value);
    int48_t operator/ (unsigned long long value);

    void operator= (unsigned long long);
    void operator= (int48_t value);
    operator unsigned long long() const;

    // Declare prefix and postfix increment operators=
    unsigned long long value() const;

private:
    unsigned short mBytes[3];
};
int48_t::int48_t()
{
    mBytes[0] = 0 ;
    mBytes[1] = 0 ;
    mBytes[2] = 0 ;
}

int48_t::int48_t(unsigned long long value)
{
    mBytes[0] =  ( value         & 0xffff);
    mBytes[1] =  ((value >>  16)  & 0xffff);
    mBytes[2] =  ((value >> 32 ) & 0xffff);
}

int48_t int48_t::operator+(int48_t value)
{
    int48_t result ;
    unsigned long long myValue ;
    unsigned long long addValue;


    myValue = this->mBytes[2];
    myValue <<= 16 ;
    myValue |= this->mBytes[1];
    myValue <<= 16 ;
    myValue |= this->mBytes[0];

    addValue = value.mBytes[2];
    addValue <<= 16 ;
    addValue |= value.mBytes[1];
    addValue <<= 16 ;
    addValue |= value.mBytes[0];

    myValue += addValue;

    result = myValue;

    return result;
}

int48_t int48_t::operator*(unsigned long long value)
{
    (*this) = (*this).value() * value;
    return (*this);
}

int48_t int48_t::operator/(unsigned long long value)
{
    (*this) = (*this).value() / value;
    return (*this);
}

void int48_t::operator=(unsigned long long value)
{
    mBytes[0] =  ( value         & 0xffff);
    mBytes[1] =  ((value >> 16)  & 0xffff);
    mBytes[2] =  ((value >> 32 ) & 0xffff);
}

void int48_t::operator=(int48_t value)
{
    mBytes[0] = value.mBytes[0];
    mBytes[1] = value.mBytes[1];
    mBytes[2] = value.mBytes[2];
}

int48_t::operator unsigned long long() const
{
    return value();
}

unsigned long long int48_t::value() const
{
    unsigned long long retVal;

    retVal |= this->mBytes[2];
    retVal <<= 16;
    retVal |= this->mBytes[1];
    retVal <<= 16;
    retVal |= this->mBytes[0];

    return retVal;
}
int n,q;
signed you[5010][5010],xia[5010][5010];
inline int getid(int i,int j){return (i-1)*n+j;}
int48_t f[5010][5010];
int48_t g[5010][5010];
int48_t nmlgb[20010];
enum lesbians{YOU,XIA}Double_Light,Milthm;
bitset<5010*5010>yhb;
int jntm[20010];
//f: pre ;; g: suf
inline int48_t min(int48_t a,int48_t b){
    return a<b?a:b;
}
bool endmemory;
signed main(){
    cin.tie(0)->sync_with_stdio(false);
    cerr<<sizeof(int48_t)<<'\n';
    cerr<<"Memory Used "<<(double)(&beginmemory-&endmemory)/1048576.<<" MB.\n";
    // return 0;
    memset(jntm,-1,sizeof jntm);
    cin>>n>>q>>seed>>B;
    for(int i=1;i<=n;++i)
        for(int j=1;j<n;++j){
            xorshift64();
            you[i][j]=seed&((1ull<<B)-1);
        }
    for(int i=1;i<n;++i)
        for(int j=1;j<=n;++j){
            xorshift64();
            xia[i][j]=seed&((1ull<<B)-1);
        }
    // for(int i=2;i<=n;++i)f[1][i]=f[1][i-1]+you[1][i-1],f[i][1]=f[i-1][1]+xia[i-1][1];
    // yhb[1][1]=XIA;
    // for(int i=2;i<=n;++i)yhb[1][i]=YOU,yhb[i][1]=XIA;
    // for(int i=2;i<=n;++i)for(int j=2;j<=n;++j){
    //     int v1=f[i-1][j]+xia[i-1][j],v2=f[i][j-1]+you[i][j-1];
    //     if(v1<v2)f[i][j]=v1,yhb[i][j]=XIA;else f[i][j]=v2,yhb[i][j]=YOU;
    // }
    // for(int i=n-1;i;--i)g[n][i]=g[n][i+1]+you[n][i],g[i][n]=g[i+1][n]+xia[i][n];
    // for(int i=n-1;i;--i)for(int j=n-1;j;--j){
    //     int v1=g[i+1][j]+xia[i][j],v2=g[i][j+1]+you[i][j];
    //     g[i][j]=min(v1,v2);
    // }
    for(int i=1;i<=n;++i)f[i][0]=(int)(1ll<<47)-1,f[0][i]=(int)(1ll<<47)-1;
    f[0][1]=(int)0;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j){
            int48_t v1=(int)f[i][j-1]+(int)you[i][j-1],v2=(int)f[i-1][j]+(int)xia[i-1][j];
            if((int)v1<=(int)v2)f[i][j]=v1,yhb[getid(i,j)]=YOU;
            else f[i][j]=v2,yhb[getid(i,j)]=XIA;
        }
    for(int i=1;i<=n;++i)g[i][n+1]=(int)(1ll<<47)-1,g[n+1][i]=(int)(1ll<<47)-1;g[n][n+1]=(int)0;
    for(int i=n;i;--i)for(int j=n;j;--j){
        int48_t v1=(int)g[i][j+1]+(int)you[i][j],v2=(int)g[i+1][j]+(int)xia[i][j];
        if((int)v1<=(int)v2)g[i][j]=v1;else g[i][j]=v2;
    }
    // for(int i=1;i<=n;++i,cout<<'\n')
    //     for(int j=1;j<=n;++j)cout<<yhb[i][j]<<' ';
    assert(g[1][1]==f[n][n]);
    int gzq=n,lbx=n;while(gzq>1||lbx>1){
        if(yhb[getid(gzq,lbx)]==YOU)--lbx,nmlgb[gzq+lbx]=lbx;
        else --gzq,nmlgb[gzq+lbx]=n+gzq;
    }
    int ca=0;
    // cout<<"Wa "<<f[n][n]<<'\n';
    // return 0;
    while(q--){
        ++ca;
        // if(ca>50000)return 0;
        int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;
        if(x1==x2){
            //y2=y1+1,key:(x2,y2)
            // cout<<"incorrect "<<x1<<' '<<y1<<' '<<nmlgb[x1+y1]<<'\n';
            if(nmlgb[x1+y1]!=y1)cout<<f[n][n]<<'\n';
            else{
                // if(ca==1)throw;
                if(~jntm[x1+y1]){
                    cout<<jntm[x1+y1]<<'\n';
                    continue;
                }
                int48_t res=(1ll<<47)-1;
                for(int i=1;i<x1;++i)res=min(res,(int48_t)((int)f[i][y2]+(int)g[i][y2]));
                for(int i=1;i<=y1;++i)res=min(res,(int48_t)((int)f[x1+1][i]+(int)g[x1+1][i]));
                cout<<res<<'\n';
                jntm[x1+y1]=res;
            }
        }else{
            assert(y1==y2);
            //x2=x1+1,key:(x2,y2)
            if(nmlgb[x1+y1]!=x1+n)cout<<f[n][n]<<'\n';
            else{
                // if(ca==1)throw;
                if(~jntm[x1+y1]){
                    cout<<jntm[x1+y1]<<'\n';
                    continue;
                }
                int48_t res=(1ll<<47)-1;
                for(int i=1;i<=x1;++i)res=min(res,(int48_t)((int)f[i][y1+1]+(int)g[i][y1+1]));
                for(int i=1;i<y1;++i)res=min(res,(int48_t)((int)f[x2][i]+(int)g[x2][i]));
                cout<<res<<'\n';
                jntm[x1+y1]=res;
            }
        }
    }
    return 0;
}
```

---


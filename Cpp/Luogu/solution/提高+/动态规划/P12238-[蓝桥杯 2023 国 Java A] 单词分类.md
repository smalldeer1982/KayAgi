# [蓝桥杯 2023 国 Java A] 单词分类

## 题目描述

在遥远的 LQ 国，只存在三种字符：$\tt{l}$、$\tt{q}$ 和 $\tt{b}$（ASCII 码分别为 $108$、$113$、$98$），所有的单词都由这三种字符组合而来。小蓝为了更加快速的记忆单词，决定将词典上所有的单词按照单词前缀将其分为 $K$ 类，具体的要求是:

1. 选出 $K$ 个不同的单词前缀作为 $K$ 类；
2. 对于字典上的每个单词，只能属于 $K$ 类中的某一个类，不能同时属于多个类；
3. 对于 $K$ 类中的每个类，至少包含有一个单词。

现在已知字典上一共有 $N$ 个单词，小蓝想要知道将这 $N$ 个单词按照上述要求分为 $K$ 类，一共有多少种不同的方案。两个方案不同指的是两个方案各自选出的 $K$ 个单词前缀不完全相同。答案可能过大，所以你需要将答案对 $1\,000\,000\,007$（即 $10^9 + 7$）取模后输出。

## 说明/提示

### 样例说明

- 方案 1：$\tt{l}=\tt{lqb}, \tt{lql}$、$\tt{q}=\tt{qqq}, \tt{qql}$；
- 方案 2：$\tt{lq}=\tt{lqb}, \tt{lql}$、$\tt{q}=\tt{qqq}, \tt{qql}$；
- 方案 3：$\tt{l}=\tt{lqb}, \tt{lql}$、$\tt{qq}=\tt{qqq}, \tt{qql}$；
- 方案 4：$\tt{lq}=\tt{lqb}, \tt{lql}$、$\tt{qq}=\tt{qqq}, \tt{qql}$。

以方案 $1$ 为例，他表示选出的两类对应的前缀分别是 $\tt l$ 和 $\tt q$，属于前缀 $\tt l$ 的单词有 $\tt {lqb}$、$\tt{lql}$，属于前缀 $\tt q$ 的单词有 $\tt{qqq}$、$\tt{qql}$，方案 $1$ 将四个单词按照前缀分成了两类，且每类至少包含一个单词，每个单词仅属于一类，所以方案 $1$ 满足题意。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 10$，$1 \leq K \leq 5$；
- 对于 $50\%$ 的评测用例，$1 \leq N \leq 50$，$1 \leq K \leq 10$；
- 对于所有评测用例，$1 \leq N \leq 200$，$1 \leq K \leq 100$，$1 \leq$ 单词长度 $\leq 10$。

## 样例 #1

### 输入

```
4 2
lqb
lql
qqq
qql```

### 输出

```
4```

# 题解

## 作者：HPXXZYY (赞：2)

$\color{blue}{\texttt{[Analysis]}}$

既然都是字符串前缀的问题了，那当然首先就应该想到 Trie 树。

我们可以发现这么一个性质，如果选从根到 Trie 树上某一点形成给定字符串作为前缀，那么子树内所有的字符串都会被归为这个类，子树外的其它字符串都不会被归为这个类。

于是可以想到在 Trie 上进行 dp。用 $f_{u,k}$ 表示把子树 $u$ 内的字符串分为 $k$ 类的方案数。

根据上面的性质，其实这个 dp 等价于从 $u$ 及其子树中选出 $k$ 个点的方案数，因而转移方程显然。

但是需要注意的是，如果选择了 $u$ 这个点，那么 $u$ 的子树的点都不可以被选取，不然就会有些字符串被分入两个组中。当然，如果 $k=1$，那么选择 $u$ 也是可能的合法的选择。

另外，因为每个字符串都要被分入其中一个组，因此 $k$ 不能小于等于  $0$。

考虑清楚边界情况就可以开始写代码了。

> 注意有一种比较特别的情况：如果 Trie 树上一个非叶子节点 $u$ 也对应着某个字符串。此时字典存在某个字符串为另外一个字符串的前缀。这时 $u$ 的子树只能分为 $1$ 类，即以节点 $u$ 对应的字符串作为前缀分类。不然，要么节点 $u$ 对应的字符串无法被归为任何一类，要么 $u$ 的子树内的某个字符串被分入两类。

另外，由于每个节点最多也就 $3$ 个子树，因此没必要写得那么复杂，枚举每棵子树内选取多少个点就可以了。

时间复杂度最多 $O(NK^2 \times \max \{ |s| \})$。其中 $\max \{ |s| \}$ 表示字符串长度的最大值，实际上远远达不到这个上界。

$\color{blue}{\text{Code}}$

```cpp
const int mod=1e9+7;
const int N=210,M=110,L=2010;

int id(char ch){
	switch (ch){
		case 'l': return 0;
		case 'q': return 1;
		case 'b': return 2;
		default: return -1;
	}
}

struct Trie_Tree{
	int ch[L][3],ndcnt,cnt[L],child[L];
	bool flag[L];
	
	void init(){
		memset(ch,-1,sizeof(ch));
		memset(cnt,0,sizeof(cnt));
		memset(flag,false,sizeof(flag)); 
		memset(child,0,sizeof(child));
		ndcnt=0;
	}
	
	void insert(string s){
		int l=s.length(),u=0;
		
		for(int i=0;i<l;i++){
			int c=id(s[i]);
			
			if (ch[u][c]==-1){
				ch[u][c]=++ndcnt;
				++child[u]; 
			}
			
			++cnt[u];//统计字符串的数量 
			u=ch[u][c];
		}
		++cnt[u];
		flag[u]=true;
	}
}trie;

int f[L][M],n,m;

int dp(int u,int k){ 
	if (trie.cnt[u]<k) return 0;
	if (~f[u][k]) return f[u][k];
	if (k<=0) return 0; 
	if (trie.flag[u]) return k==1;
	
	int res=((k==1)?1:0);
	
	if (trie.child[u]==1){
		int c;
		if (~trie.ch[u][0]) c=trie.ch[u][0];
		else if (~trie.ch[u][1]) c=trie.ch[u][1];
		else c=trie.ch[u][2];
		
		res=(res+dp(c,k))%mod;
	}
	else if (trie.child[u]==2){
		int c1,c2;
		if (~trie.ch[u][0]){
			c1=trie.ch[u][0];
			if (~trie.ch[u][1]) c2=trie.ch[u][1];
			else c2=trie.ch[u][2];
		}
		else c1=trie.ch[u][1],c2=trie.ch[u][2];
		
		for(int i=1;i<k;i++)
			res=(res+1ll*dp(c1,i)*dp(c2,k-i)%mod)%mod;
	}
	else{
		for(int i=1;i<k;i++)
			for(int j=1;j<k-i;j++)
				res=(res+1ll*dp(trie.ch[u][0],i)*dp(trie.ch[u][1],j)%mod*dp(trie.ch[u][2],k-i-j)%mod)%mod;
	}
	
	return f[u][k]=res;
}

int main(){
	cin>>n>>m;
	trie.init();
	for(int i=1;i<=n;i++){
		string s;cin>>s;
		trie.insert(s);
	}
	
	memset(f,-1,sizeof(f));
	
	printf("%d",dp(0,m));
	
	return 0;
}
```

---

## 作者：P2441M (赞：2)

$\text{Upd 2025/6/28}$：改用了更低时间复杂度的做法。

## 题意

给定 $k$ 和仅由 $\texttt{l},\texttt{q},\texttt{b}$ 三种字符组成的 $n$ 个字符串 $s_i$。求有多少个由 $k$ 个不同的字符串组成的集合 $S$，满足：

- 对于每个 $1\leq i\leq n$，$S$ 中**有且仅有**一个字符串是 $s_i$ 的前缀。
- 对于 $S$ 中的每个字符串 $t$，至少存在 $1$ 个 $i(1\leq i\leq n)$，使得 $t$ 是 $s_i$ 的前缀。

$S$ 中**允许出现空串**。答案对 $10^9+7$ 取模。$1\leq n\leq 200$，$1\leq k\leq 100$，$1\leq |s_i|\leq 10$。

## 题解

字符串前缀相关，考虑建出 Trie。那么题目变成在 Trie 上选出 $k$ 个点，使得对于每个代表字符串末尾的节点，恰好有一个被选中的点是其祖先。树形 DP，令 $f_{u,i}$ 表示在 $sub_u$ 中选出 $i$ 个点的方案数。不难观察出，若选择点 $u$，则 $sub_u$ 中其他点都不能选，这种方案只能加到 $f_{u,1}$ 上面去。如果从 $v(v\in son_u)$ 的子树中选点，那就是很板的树形背包了。边界是当 $u$ 为某个字符串的末尾节点时，只能有 $f_{u,1}=1$。

因为允许出现空串，所以 $f_{rt,k}$ 即为答案。根据树形背包经典结论，时间复杂度为 $\mathcal{O}(n|s|k)$.

## 代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 205, L = 15, K = 105, MOD = 1e9 + 7;

inline int add(int x, int y) { return x += y, x >= MOD ? x - MOD : x; }
inline int sub(int x, int y) { return x -= y, x < 0 ? x + MOD : x; }
inline void cadd(int &x, int y) { x += y, x < MOD || (x -= MOD); }
inline void csub(int &x, int y) { x -= y, x < 0 && (x += MOD); }

int n, k;
char s[N][L];

inline int calc(char ch) {
	if (ch == 'l') return 0;
	if (ch == 'q') return 1;
	return 2;
}
struct Trie {
	int tot = 1, ch[N * L][3], f[N * L][K], sz[N * L];
	bool end[N * L];
	inline void ins(char *str, int len) {
		int p = 1;
		for (int i = 1, x; i <= len; ++i) {
			x = calc(str[i]);
			if (!ch[p][x]) ch[p][x] = ++tot;
			p = ch[p][x];
		}
		end[p] = 1;
	}
	inline void dp(int p) {
        sz[p] = 1;
		f[p][0] = 1;
		for (int i = 0, q; i < 3; ++i) {
			if (!(q = ch[p][i])) continue;
			dp(q);
			for (int j = min(sz[p], k); j >= 0; --j) {
				f[p][j] = 0;
				for (int m = 1; m <= min(j, sz[q]); ++m) cadd(f[p][j], (ll)f[p][j - m] * f[q][m] % MOD);
			}
            sz[p] += sz[q];
		}
		cadd(f[p][1], 1);
        if (end[p]) {
            for (int i = 0; i <= k; ++i) f[p][i] = 0;
            f[p][1] = 1;
        }
	}
} t;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) cin >> s[i] + 1, t.ins(s[i], strlen(s[i] + 1));
    t.dp(1);
    cout << t.f[1][k];
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

# p12238题解
## 题意

给定 $N$ 个由 `l`、`q`、`b` 组成的单词，需要将它们分成K类。每类用一个唯一的前缀表示，且每个单词必须属于且仅属于一个类。求分类方案数。

## 解析

首先将所有单词按字典序排序。这样具有相同前缀的单词会自然地聚集在一起。对于任意一段连续的单词区间 $[l,r]$，我们考虑计算它们的共同前缀长度，这个长度决定了可以有多少种前缀能唯一代表这个区间。后面就是较为基础的动规。

具体实现：
1. 每个区间 $[l,r]$ 的有效前缀数量等于它们的最长公共前缀长度减去与相邻区间重叠的部分。定义 $s_ {l,r}$ 代表区间 $[l, r]$ 内的单词能够形成的有效分类前缀的数量。
2. 累加方案数，其中 $dp_{i,j}$ 表示前i个单词分成j类的方案数。状态转移方程很容易就能推出是 $dp_{i,j}=dp_{i,j}+dp_{k-1,j-1}\times s_{k-1,i-1}$。
3. 特判，当 $K=1$ 时，所有单词必须属于同一类，此时方案数需要额外加 $1$。

## 代码
```
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1000000007;
int N, K;
string w[205];
int lcp[205][205];
int s[205][205];
int dp[205][105];

int main(){
    cin >> N >> K;
    for (int i = 0; i < N; ++i){
        cin >> w[i];
    }
    sort(w, w + N);
    for (int i = 0; i < N; ++i){
        for (int j = i; j < N; ++j){
            if (i == j){
                lcp[i][j] = w[i].length();
            } 
			else{
                int len = 0;
                while (len < w[i].length() && len < w[j].length() && w[i][len] == w[j][len]){
                    len++;
                }
                lcp[i][j] = len;
                lcp[j][i] = len;
            }
        }
    }
    for (int l = 0; l < N; ++l){
        for (int r = l; r < N; ++r){
            int ml = lcp[l][r];
            for (int k = l; k <= r; ++k){
                ml = min(ml, lcp[l][k]);
            }
            int ll = (l == 0) ? 0 : lcp[l - 1][r];
            int rl = (r == N-1) ? 0 : lcp[l][r + 1];
            s[l][r] = max(0, ml - max(ll, rl));
        }
    }
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= N; ++i){
        for (int j = 1; j <= K; ++j){
            for (int k = 1; k <= i; ++k){
                dp[i][j] = (dp[i][j] + s[k - 1][i - 1] * dp[k - 1][j - 1]) % MOD;
            }
        }
    }
    if (K == 1){
        dp[N][K] = (dp[N][K] + 1) % MOD;
    }
    cout << dp[N][K] << endl;
    return 0;
}
```

---

## 作者：Acit (赞：1)

介绍一个偏暴力的做法。

**思路**

考虑dp。先将所有单词排序，这样同一类单词必定对应了一个区间。设 $f_{i,j}$ 表示将前 $i$ 个单词划分为 $j$ 类的方案数，转移时对于所有满足 $k\le i$ 的 $k$ ，只需让 $f_{i,j}$ 加上 $s_{k,i} \cdot f_{k-1,j-1}$ 即可（$s_{l,r}$ 为将 $l$ 到 $r$ 划分为一类单词的方案数）。

以下记 $lcp_{l,r}$ 为 $l$ 到 $r$ 的最长公共前缀长度。

考虑如何计算 $s_{l,r}$：我们所选取的前缀一定是 $l$ 到 $r$ 的公共前缀且不能是 $l-1$ 或 $r+1$ 的前缀，所以有 $s_{l,r}=lcp_{l,r}-\max(lcp_{l-1,r},lcp_{l,r+1})$。

可以用字典树找 $lcp_{l,r}$，但暴力也可过。

注意 $K=1$ 时我们可以选空串作为前缀，此时答案要加一。

**Code**


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define forr(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
const int N=200+10,MOD=1e9+7;
int n,k;
string s[N];
int f[N][N],len[N];
int check(int l,int r){
	int ll=0,mn=0x3f3f3f3f;
	forr(i,l,r){
		mn=min(mn,len[i]);
	}
	forr(i,0,mn-1){
		int tag=0;
		forr(j,l+1,r){
			if(s[j][i]!=s[l][i]){
				tag=1;break;
			}
		}
		if(tag)break;
		ll++;
	}
	int tg1=0,tg2=0;
	if(l==1)tg1=ll;
	else {
		int ul=min(len[l-1],ll);
		forr(i,0,ul-1){
			if(s[l][i]!=s[l-1][i]){
				tg1=(ll-i);break;
			}
		}
	}
	if(r==n)tg2=ll;
	else {
		int ul=min(len[r+1],ll);
		forr(i,0,ul-1){
			if(s[l][i]!=s[r+1][i]){
				tg2=ll-i;break;
			}
		}
	}
	return min(tg1,tg2);
}
signed main(){
	ios::sync_with_stdio(0);
	//freopen("T2.in","r",stdin);
	//freopen("T2.out","w",stdout);
	cin>>n>>k;
	forr(i,1,n){
		cin>>s[i];
	}
	f[0][0]=1;
	sort(s+1,s+1+n);
	forr(i,1,n)len[i]=s[i].size();
	forr(ll,1,k){
		forr(i,1,n){
			roff(j,i-1,0){
				(f[i][ll]+=check(j+1,i)*f[j][ll-1])%=MOD;
			}
		}
	}
	if(k==1)f[n][k]++;
	cout<<f[n][k];
	return 0;
}

```

---

## 作者：KidA (赞：0)

看到前缀，考虑使用 trie，先把所有字符串扔到里面去。

然后发现要求方案数，于是考虑 dp，在本题中自然想到在 trie 上 dp 了。

具体而言，我们观察到 trie 有一种很好的性质：对于 trie 上的某个节点 $u$，$u$ 的子树内所有叶子节点所对应的字符串都有根节点到 $u$ 这条路径所对应的前缀。

这个性质有什么用呢？它意味着，我们只需选择某个节点，就可以将其子树内的所有字符串全部归于一类。

这样，问题转化为，在所有节点中选出 $k$ 个不同节点并且每个子树必须选一个（为了满足条件 $3$）的方案数。这是个经典的树上背包问题，转移是显然的。

然后这题就做完了，[实现](https://www.luogu.com.cn/paste/uqcngkxl)有一些小细节会在代码中标注。

---

## 作者：Stars_visitor_tyw (赞：0)

## 题解：P12238 [蓝桥杯 2023 国 Java A] 单词分类
### 题意
给定 $n$ 个字符串，选取恰好 $k$ 个字符串作为前缀，使得 $n$ 个字符串都恰好有 $1$ 个前缀是这 $k$ 个字符串，求选取的方案数，对 $10^9+7$ 取模。
### 分析
首先将 $n$ 个字符串插入字典树，标记每次插入时终止的节点。

我们注意字典树的一个性质：对于任意一个字符串 $s$，它的前缀字符串的终止节点一定在 $s$ 的终止节点到根的路径上。

所以，选取 $k$ 个前缀等价于在字典树上选 $k$ 个节点。选取后，$n$ 个字符串的每个终止节点到根的路径上恰好有 $1$ 个我们选取的点。

我们此时把问题转化一下：给定一棵树，有 $tot$ 个节点，标记其中 $k$ 个，使得 $n$ 个染色节点到根的路径上有且仅有一个点被我们标记，求标记的方案数。

这时候，我们就可以想到树形背包。定义状态 $dp_{i,j}$ 表示以 $i$ 为根的子树选 $j$ 个点标记的方案数。答案为 $dp_{0,k}$。

考虑转移。如果我们选择将节点 $cur$ 标记，$dp_{cur,1}=1$。接着从下往上转移，维护 $siz_{cur}$。转移：$dp_{cur,j}=(dp_{cur,j}+dp_{cur,j-p}\times dp_{nxt,p})(0 \le j \le \min(siz_{cur},k),1 \le p \le \min(j,siz_{nxt}))$。其中 $j$ 需要倒序维护。

注意几个小细节：

1. 因为背包时为了避免重复清空了部分 $dp$ 数组，所以 $dp_{cur,1}=1$ 应该在循环之后赋值，而初始状态 $dp_{cur,0}=1$ 在循环前赋值。
2. 为了避免重复，$p$ 从 $1$ 开始循环。
3. 如果 $cur$ 是终止节点，需要清空 $dp_{cur}$ 并将 $dp_{cur,1}$ 设为 $1$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n, k, tot=0, trie[20005][205], exist[20005], dp[20005][205], siz[20005];
vector<int> nbr[20005];
int get_num(char ch)
{
	if(ch=='l')return 1;
	if(ch=='q')return 2;
	if(ch=='b')return 3;
}
void insert(string s)
{
	int cur=0;
	for(int i=0;i<s.size();i++)
	{
		int ch=get_num(s[i]);
		if(trie[cur][ch]==0)
		{
			trie[cur][ch]=++tot;
			nbr[cur].push_back(trie[cur][ch]);
		}
//		cout<<"iakioi\n";
//		cout<<cur<<" "<<trie[cur][ch]<<"\n";
		cur=trie[cur][ch];
	}
	exist[cur]=1;
//	cout<<cur<<"\n";
}
void dfs(int cur)
{
	dp[cur][0]=1;
	siz[cur]=1;
	for(int nxt:nbr[cur])
	{
		dfs(nxt);
		siz[cur]+=siz[nxt];
//		cout<<"abcd\n";
		for(int j=min(siz[cur],k);j>=0;j--)
		{
			dp[cur][j]=0;
//			cout<<"jfdfjed\n";
			for(int p=1;p<=min(j,siz[nxt]);p++)
			{
//				cout<<nxt<<" "<<p<<" "<<dp[nxt][p]<<"\n";
				dp[cur][j]=(dp[cur][j]%mod+dp[cur][j-p]*dp[nxt][p]%mod)%mod;
//				cout<<dp[cur][j]<<" ";
			}
		}
		
	}
	dp[cur][1]++;
	if(exist[cur])
	{
		for(int i=0;i<=k;i++)dp[cur][i]=0;
		dp[cur][1]=1;
	}
//	dp[cur][1]++;
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0);
//	for(int i=0;i<=20004;i++)siz[i]=1;
//	memset(trie,-1,sizeof trie);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		insert(s);
	}
//	cout<<tot<<"\n";
	dfs(0);
	cout<<dp[0][k]%mod;
}
```

---


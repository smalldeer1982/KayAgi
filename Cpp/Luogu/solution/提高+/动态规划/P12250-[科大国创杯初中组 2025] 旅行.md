# [科大国创杯初中组 2025] 旅行

## 题目背景

Subtask 0 为民间数据，Subtask 1 为官方数据。

## 题目描述

小可可来到了 P 国旅行。

P 国共有 $n$ 个城市和 $m$ 条有向道路，其中第 $i$ 条道路为从城市 $u_i$ 到城市 $v_i$，长度为 $w_i$。**保证** $u_i < v_i$。

对于一次游览，假设小可可依次经过了城市 $x_1, x_2, \ldots, x_k$，其中从 $x_i$ 到 $x_{i+1}$ 经过的路径长度为 $y_i$。记 $s_i$ 表示 $y_1, y_2, \ldots, y_i$ 的**按位或**值。那么小可可认为这次游览就是从 $x_1$ 走到 $x_k$，疲劳度就是 $\operatorname{mex}(s_1, s_2, \ldots, s_{k-1})$。

其中 $\operatorname{mex}(a_1, a_2, \ldots, a_n)$ 表示最小的没有出现在 $a_1, a_2, \ldots, a_n$ 中的自然数。例如 $\operatorname{mex}(0, 2, 3) = 1$，$\operatorname{mex}(1, 4) = 0$，$\operatorname{mex}(0, 1, 2, 3, 4) = 5$。

小可可认为两座城市 $s, t$ 之间的距离为他从 $s$ 走到 $t$ 所有可能的游览方案中疲劳度的最大值，记作 $d(s, t)$。如果不能从 $s$ 走到 $t$，那么 $d(s, t) = -1$。规定 $d(s, s) = 0$。现在他想要知道任意两座城市之间的距离之和，即 $\displaystyle \sum_{i=1}^{n} \sum_{j=1}^{n} d(i, j)$。


## 说明/提示

### 样例 1 解释

当从 $1$ 走到 $3$ 时有两条路径。其中从 $1$ 直接到 $3$ 疲劳度为 $\operatorname{mex}(2) = 0$。从 $1$ 到 $2$ 再到 $3$ 疲劳度为 $\operatorname{mex}(0, 1) = 2$。所以 $1$ 到 $3$ 的距离为 $2$。

以此类推，有 $d(1, 1) = d(2, 2) = d(3, 3) = 0$。$d(2, 1) = d(3, 1) = d(3, 2) = -1$。$d(1, 2) = 1$，$d(1, 3) = 2$，$d(2, 3) = 0$。总和为 0。

### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 3$，$m \leq 5$。
- 对于 $25\%$ 的数据，保证 $n \leq 20$，$m \leq 40$。
- 对于 $45\%$ 的数据，保证 $n \leq 300$，$m \leq 500$。
- 对于 $60\%$ 的数据，保证 $n \leq 3000$，$m \leq 5000$。
- 对于另外 $10\%$ 的数据，保证 $w_i \geq 1$。
- 对于另外 $10\%$ 的数据，保证 $m = n - 1$，$u_i = i$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 3 \times 10^4$，$1 \leq m \leq 2 \times 10^5$，$1 \leq u_i < v_i \leq n$，$0 \leq w_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 2 0
1 3 2
2 3 1```

### 输出

```
0```

# 题解

## 作者：N1tr0us_Acid (赞：7)

很好的一道 bitset 练手题，考试时没有写掉有点遗憾了。

# $\texttt{Solution}$
前置知识：[bitset](https://oi-wiki.org/lang/csl/bitset/)。

看到这个 mex 和按位或，似乎可以发现路径疲劳度的一些限制。\
是的，不难发现，如果从某一点有一条道路通向另一点，那么路径的疲劳度只会有以下三种情况：

1. 若该路径经过的第一条边的边权不为 $0$，这条路径的疲劳度为 $0$。
2. 若该路径经过的所有边的边权都是 $0$，或从第一条边的边权开始有一段连续的 $0$，之后是一条边权不为 $1$ 的边，这条路径的疲劳度为 $1$。
3. 若该路径从第一条边的边权开始有一段连续的 $0$，之后是一条边权为 $1$ 的边，这条路径的疲劳度为 $2$。

可以发现，没有其他的情况。

这里有一点要说一下，情况 $2$ 可以简化为某条路径的第一条边的边权为 $0$，然后情况 $3$ 就会被包含在情况 $2$ 里，这意味着在真正开始统计情况 $3$ 之前，每一条满足情况 $3$ 的路径已经被统计了一遍，那么统计情况 $3$ 时就只需要对每条路径加 $1$ 而不是 $2$。

看看数据约定，发现有 $u_i < v_i$，显然，这是一个 DAG。

考虑使用 bitset 解决问题。

我们可以在原图的基础上先存一个反边，然后用拓扑排序求出每个点可以到达哪些点，这一步骤使用 bitset 将很好实现。这样，我们就可以统计出有多少条无法到达的路径，这样的路径的疲劳度是 $-1$。

需要注意的是，只有这个部分需要用拓扑排序。

```cpp
void solve() {
	for (int i = 1; i <= n; i ++ ) in4[i] = in[i];
	
	for (int i = 1; i <= n; i ++) {
		if(!in[i]) sta.push(i);
		
		bs[i].set(i, 1); // 每个点都可以到达自己本身
	}
	
	while (sta.size()) { // 拓扑排序
		auto u = sta.front();
		sta.pop();
		
		for (int i = head2[u]; i; i = nxt2[i]) {
			int j = to2[i]; // to2，head2，nxt2 均为反边。
			
			bs[j] |= bs[u]; // 如果点 u 可以到达某个点，那么与 u 有连边的 j 也可以到达这个点。
			
			if(-- in[j] == 0) sta.push(j);
		}
	}
	
	for (int i = 1; i <= n; i ++) {
		ans -= (n - bs[i].count()); // 一个点应该和所有的点（包括自己）有路径，所以 n - bs[i].count() 是这个点不能到达的点数。
	}
}
```

这样我们就完成了对疲劳度为 $-1$ 的路径的统计。

接下来就是对疲劳度为 $1$ 的路径的统计。

这个很好理解。对于一个点 $u$，如果有一条通向点 $v$ 的边且边权为 $0$，那么 $u$ 与 $v$ 所有可以到达的点的路径疲劳度都**至少**为 $1$，因为这里可能包含着情况 $3$。

遍历所有的边，对于所有边权为 $0$ 的边进行统计即可。

```cpp
void solve2() {
	for (int i = 1; i <= n; i ++) {
		now.reset(); // 这里使用 bitset 的原因是为了防止某两点间有多条满足要求的路径而导致重复计算了疲劳速度。
		
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 0) {
				now |= bs[j];
			}
		}
		
		ans += now.count(); // 先统计满足路径中第一条边的边权为 0 的点的数量，这样的路径疲劳度至少为 1。
	}
}
```

最后是对疲劳度为 $2$ 的路径的统计，即情况 $3$。

我们需要两步动作。

首先，统计出每个点通过一条满足第一条边的边权为 $1$ 的路径可以到达的点的数量。\
然后，统计有每个点只通过边权为 $0$ 的边可以到达的点，假定有一点 $u$，可以通过一条边权全部为 $0$ 的路径到达点 $v$，那么 $u$ 与所有满足 $v$ 通过一条满足第一条边的边权为 $1$ 的路径可以到达的点之间的路径疲劳度为 $2$。

有点绕，原谅我口才不太好，直接看看代码吧。

```cpp
void solve3() {
	for (int i = 1; i <= n; i ++) {
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 1) {
				bs1[i] |= bs[j]; // 这里统计了每一个点通过一条满足第一条边的边权为 $1$ 的路径可以到达哪些点。
			}
		}
	}
}

void solve4() {
	for (int i = n; i >= 1; i --) { // 这里有一个类似拓扑排序的顺序，所以要从大到小遍历。
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 0) { // i 与 j 之间的边权为 0
				bs0[i] |= bs0[j]; // 如果 j 与某个点间的路径疲劳度为 2，那么 i 与这个点间的疲劳度也是 2，这里其实统计了 i 到 j 这条边的边权不为整条路经中第一段连续 0 的最后一个 0 的情况。
				bs0[i] |= bs1[j]; // 统计了 i 到 j 这条边的边权为整条路经中第一段连续 0 的最后一个 0 的情况。
			}
		}
		
		ans += bs0[i].count(); // 因为之前统计疲劳度为 1 的路径时已经把这些路径计算了一遍，所以这里是加 1 而不是加 2。
	}
}
```

最后输出即可。

# $\texttt{Code}$
这里放一下完整的代码。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 2e5 + 10, M = 3e4 + 10;

bitset <M> bs[M], bs1[M], now, bs0[N];

int n, m;
int in[N];
int idx, to[N], nxt[N], w[N], head[N];
int idx2, to2[N], nxt2[N], w2[N], head2[N];
int ans;

typedef pair <int, int> pii;

vector <pii> G[M], G2[M];

void add(int a, int b, int C) {
	idx ++;
	
	to[idx] = b;
	nxt[idx] = head[a];
	head[a] = idx;
	w[idx] = C;
	
	G[a].push_back({b, C});
}

void add2(int a, int b, int C) { // 建反边
	idx2 ++;
	
	to2[idx2] = b;
	nxt2[idx2] = head2[a];
	head2[a] = idx2;
	w2[idx2] = C;
	
	G2[a].push_back({b, C});
}

queue <int> sta;

void solve() {	
	for (int i = 1; i <= n; i ++) {
		if(!in[i]) sta.push(i);
		
		bs[i].set(i, 1);
	}
	
	while (sta.size()) {
		auto u = sta.front();
		sta.pop();
		
		for (int i = head2[u]; i; i = nxt2[i]) {
			int j = to2[i];
			
			bs[j] |= bs[u];
			
			if(-- in[j] == 0) sta.push(j);
		}
	}
	
	for (int i = 1; i <= n; i ++) {
		ans -= (n - bs[i].count());
	}
}



void solve2() {
	for (int i = 1; i <= n; i ++) {
		now.reset();
		
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 0) {
				now |= bs[j];
			}
		}
		
		ans += now.count();
	}
}

void solve3() {
	for (int i = 1; i <= n; i ++) {
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 1) {
				bs1[i] |= bs[j];
			}
		}
	}
} 

void solve4() {
	for (int i = n; i >= 1; i --) {
		for (auto u : G[i]) {
			int j = u.first, w = u.second;
			
			if(w == 0) {
				bs0[i] |= bs0[j];
				bs0[i] |= bs1[j];
			}
		}
		
		ans += bs0[i].count();
	}
}

signed main(void) {
	cin >> n >> m;
	
	for (int i = 1; i <= m; i ++) {
        int u, v, c;
		cin >> u >> v >> c;
		
		add(u, v, c);
		add2(v, u, c); 
		
		in[u] ++;
	}
	
	solve();
	solve2();
	solve3(); 
	solve4();	

	cout << ans << endl; 
	
	return 0;
}
```

---

## 作者：WaterM (赞：6)

这道题演都不演，$n \le 3\times 10^4$，大概率是个 bitset。

先瞅瞅有没有什么性质。mex 和位运算一起出，觉得是诈骗。  
注意到前缀或**不降**，that is，只有前缀异或和为 $0,1,2,3\dots$ 才对答案有贡献。  
再注意到，mex 的最大值为 $2$。
- 证明：若 mex 大于 $2$，必有前缀或**依次**包含 $0,1,2$，但 $2$ 那一项必然从前面的 $1$ 转移过来，$1 \text{ or } x = 2$ 无解，因为对于“个”位，$1$ 或上任意数都为 $1$。矛盾，原命题成立。

我们通过这个观察，得到了几个性质。  

1. $\text d(i, j) = -1$ 等价于 $i, j$ 不连通。
2. $\text d(i, j) = 1$ 等价于存在一条 $i \to j$ 的路径，第 $1$ 条边为 $0$，且**不满足下面一点的条件**。
3. $\text d(i, j) = 2$ 等价于存在一条 $i \to j$ 的路径，一个前缀为 $000\dots 01$。
4. $\text{otherwise}$，$\text d(i, j) = 0$。

首先解决函数值为 $-1$ 的情况。  
定义 $able_{i}$ 为一个 bitset，表示 $i$ 能到的点。  
建反图，初始化 $able_{i, i}=1$，跑一遍拓扑排序，可以弄出 $able_i$。  
枚举一遍，点 $i$ 的贡献就是 $n-able_i.\text{count}()$。

定义 bitset $all1_i$ 为 $i$ 通过一条（第一条）权值为 $1$ 边可达的点。  
我们再枚举 $i$，枚举 $i$ 的所有出边，记通过权值为 $1$ 的边到达的点为 $j$，用 $able_j$ 更新 $all1_i$。

以下解决函数值为 $1,2$ 的情况：  
这里用一个 trick：可以认为函数值为 $2$ 的情形包含函数值为 $1$，将上面分析中的（2.）里粗体限制去掉，并将 $\text d = 2$ 的贡献调整为 $1$。这样可以正确算得答案。
1. 枚举 $i$，枚举 $i$ 的所有出边，记通过权值为 $0$ 的边到达的点为 $j$，则 $i$ 经过（第一条）一条权值为 $0$ 的边到达的点为 $able_j$ 的或。  
   这就是（3.【改】）的限制。将答案加入 $\text{count}$。
2. 进行一个类似于 DP 的东西。首先清空 $able$。**倒序**（无后效性）枚举 $i$，枚举 $i$ 的所有出边，记通过权值为 $0$ 的边到达的点为 $j$，可以用 $able_j$ 和 $all1_j$ 更新 $able_i$。  
   这里 $able_i$ 的定义为，经过 $000\dots01$ 的路径可达的点。转移应该挺容易理解的。  
   注意这里贡献要当成 $1$。

建议对 bitset 不熟练的同学先学习一下基础操作。

时间复杂度和空间复杂度都是 $O(\frac{n^2+nm}{w})$。

```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define Linf 0x3f3f3f3f3f3f3f3f
#define upw(i, a, b) for(int i = a; i <= b; ++i)
#define dnw(i, a, b) for(int i = a; i >= b; --i)
#define all(v) v.begin(), v.end()
#define pii pair<int, int>
using namespace std;

//#define filename "trip"
//#define multicase 1

template<class T> bool vmax(T &a, T b) { return b > a ? a = b, true : false; }
template<class T> bool vmin(T &a, T b) { return b < a ? a = b, true : false; }
template<class T> void clear(T &a) { T().swap(a); }

const int N = 3e4+2;

int n, m;
vector<pii> g[N], rg[N];

bitset<N> able[N];

int ind[N];
int q[N], h, t;
void Topsort() {
    h = 1, t = 0;
    upw(i, 1, n) if(ind[i] == 0) q[++t] = i;
    upw(i, 1, n) able[i].set(i, 1);
    while(h <= t) {
        int u = q[h++];
        for(auto e : rg[u]) {
            int v = e.first;
            able[v] |= able[u];
            if(--ind[v] == 0) q[++t] = v;
        }
    }
}

bitset<N> all1[N], tmp;

long long ans;

void Traveller() {
    cin >> n >> m;
    upw(i, 1, m) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        g[u].emplace_back(v, w), rg[v].emplace_back(u, w);
        ++ind[u];
    }

    Topsort();
    upw(i, 1, n) ans -= n - able[i].count();


    //cerr << ans << '\n';

    upw(u, 1, n) {
        for(auto e : g[u]) {
            int v = e.first, w = e.second;
            if(w == 1) all1[u] |= able[v];
        }
    }
    /*upw(i, 1, n) {
        upw(j, 1, n) cerr << all1[i][j] << ' ';
        cerr << '\n';
    }*/
    upw(u, 1, n) {
        tmp.reset();
        for(auto e : g[u]) {
            int v = e.first, w = e.second;
            if(w == 0) tmp |= able[v];
        }
        ans += tmp.count();
        //upw(j, 1, n) cerr << tmp[j] << ' ';
        //cerr << '\n';
    }


    //cerr << ans << '\n';


    upw(i, 1, n) able[i].reset();
    dnw(u, n, 1) {
        for(auto e : g[u]) {
            int v = e.first, w = e.second;
            if(w == 0) {
                able[u] |= able[v];
                able[u] |= all1[v];
            }
        }
        ans += able[u].count();
    }
    cout << ans << '\n';
}

signed main() {
#ifdef filename
    freopen(filename".in", "r", stdin);
    freopen(filename"5.out", "w", stdout);
#endif // filname

    signed T = 1;
#ifdef multicase
    scanf("%d", &T);
#endif // multicase

    while(T--) Traveller();
    return 0;
}
```

赛时代码，丑陋见谅。  

注意到代码 line 101 没有将文件名改回来！！！  
只有爆零的命了。

该代码可以通过民间数据。

---

## 作者：CSPAK_Zhangxiuqi0011 (赞：5)

## 前言
赛时本蒟蒻连这道题的第一步都没想出来，赛后大佬们都说是 bitset，本蒟蒻居然连 bitset 是啥都不知道……最后还是听我们班的一位大佬说的思路，于是就诞生了这篇题解。
## 前置知识
[bitset](https://oi-wiki.org/lang/csl/bitset/)，就是将原本 bool 变量优化成一个 bool 变量占一个比特。假设不使用 bitset 的时间复杂度和空间复杂度是 $O(n)$，那么使用 bitset 的时间复杂度和空间复杂度就是 $O(\frac{n}{w})$，其中 $w$ 为计算机字长，通常认为 $w=32$。具体请见上方链接。
## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/solution/P12250)  
~~不太简的~~简述:  
给定一张 $n$ 个节点 $m$ 条边的有向图，每条边都有一非负整数边权，且一定是从小编号节点到大编号节点。对于 $u,v$ 两节点，定义 $d(u,v)$ 为 $u$ 到 $v$ 的路径中所有边权的前缀按位或的 mex 是多少。特殊规定：若 $u$ 到 $v$ 不存在路径，则 $d(u,v)$ 值为 $-1$；若 $u$ = $v$，则 $d(u,v)$ 值为 $0$。求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^nd(i,j)$。
## 分析
### Step 1：分析 mex 可能出现的值。
首先，如果没有 $0$，那么 mex 肯定是 $0$。
接下来观察 $1$ 和 $2$ 的二进制位：
```
十进制数 1   2
二进制数 01  10
```
因为操作是按位或，所以一旦目前结果是 $1$，那么再按位或下去也不可能得到 $2$。同理 $2$ 也不能得到 $1$。也就是说，$1$ 和 $2$ 必定会有至少 $1$ 个数空缺。  
综上所述，mex 的值为 $0$ 或 $1$ 或 $2$。
### Step 2：分析 mex 对应不同的值时边权满足的情况。  
- 当 mex 为 $0$ 时，路径上第一条边的边权不为 $0$。
- 当 mex 为 $1$ 时，路径一定是一串 $0$ 后跟一些不为 $1$ 的数。  
  例：`00250` ~~我绝对不会告诉你这是我去年 CSP-S 准考证号~~。
- 当 mex 为 $2$ 时，路径一定是一串 $0$ 后跟一串 $1$ 再跟一些不为 $2$ 的数构成。  
  例：`00113`。
### Step 3：考虑如何解题
首先，对于走不到的情况，直接对于每个节点用 bitset 建立一个 vis 数组，遍历一遍即可。其中第 $i$ 个元素代表从当前节点为起点可以走到的点。   
然后，mex 为 $0$ 不用管，发现 mex 为 $1$ 或 $2$ 的时候前面一定会有一串 $0$，考虑拆贡献：
- 对于一条以 $0$ 开头的路径，贡献 $+1$；
- 对于一条以 $0$ 开头，后面跟 $1$ 的路径，贡献 $+1$；
  
可以发现这样做如果 mex 为 $1$，那么只计算了一次贡献。如果 mex 为 $2$，那么计算了两次贡献，符合 mex 值。  
具体实现方法和无解类似，可以先自己尝试着写，详细实现见代码。
## Code
代码采用存反图的方法写，~~最后发现居然没有正图好写~~，如果想存正图做，那么有的细节是不一样的，请不要盲目抄代码，谢谢。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node{
	int to,num;
};
vector<node>ve[30005];
bitset<30005>vis[30005],on[30005],ze[30005];
signed main() {
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	while(m--){
		int u,v,w;
		cin>>u>>v>>w;
		ve[v].push_back({u,w});
	}
	for(int i = 1;i<=n;i++){//vis[i]:记录第i个节点能到达的其他节点表示的状态 
		vis[i].set(i);//自己肯定能到自己 
	}
	int ans;
	ans = 0;
	for(int i = n;i;i--){
		ans = ans-(n-vis[i].count());//减去访问不到的，即题目中所说的d值为-1的情况 
		int l;
		l = ve[i].size();
		for(int j = 0;j<l;j++){//更新后面节点的状态 
			vis[ve[i][j].to] = vis[ve[i][j].to]|vis[i];
		}
	}
	for(int i = n;i;i--){//ze[i]:记录从第i个节点出发，且第一条边边权为0时，能到达的节点的状态 
		ans = ans+ze[i].count();//贡献加进答案 
		int l;
		l = ve[i].size();
		for(int j = 0;j<l;j++){
			if(!ve[i][j].num){
				ze[ve[i][j].to] = ze[ve[i][j].to]|vis[i];
			}
		}
	}
	//重点部分：计算mex=2的路径个数 
	for(int i = n;i;i--){//on[i]:记录从第i个节点出发，且第一条边边权为1时，能到达的节点的状态 
		int l;
		l = ve[i].size();
		for(int j = 0;j<l;j++){
			if(ve[i][j].num == 1){
				on[ve[i][j].to] = on[ve[i][j].to]|vis[i];
			}
		}
		ze[i].reset();
	}
	for(int i = n;i;i--){//这里的ze[i]就是从第i个节点出发，满足mex=2的路径格式(000111...)能到达的节点状态 
		ans = ans+ze[i].count();
		int l;
		l = ve[i].size();
		for(int j = 0;j<l;j++){
			if(!ve[i][j].num){
				ze[ve[i][j].to] = ze[ve[i][j].to]|ze[i]|on[i];//注意：如果当前边权为0，那么更新的时候既可以用当前节点的答案又可以用路径开头是1的。
															  //即ze[i]和on[i]都要用来更新 
			}
		}
	}
	cout<<ans<<"\n";
	return 0;
}

```

---

## 作者：yszkddzyh (赞：5)

[更好的阅读体验](https://www.luogu.com.cn/article/v6xhxlqs)

## 前言

打了这场比赛后才学会 bitset，伟大。

做法很多，思路一致，具体实现方法很多。

本文若有误请指出。

## 分析

### 一些性质

题目说 $u_i < v_i$，这表明给出的是一个 DAG。

根据题目给的条件，注意到所有路径的 $\operatorname{mex}$ 只可能为 $0, 1, 2$，分别满足一下条件：

- $\operatorname{mex} = 0$，当且仅当这个路径的第一条边的权值非 $0$。
- $\operatorname{mex} = 1$，当且仅当这个路径边权全是 $0$，或者这个路径序列形如 $(0, 0, \cdots, 0, x, \cdots)$，其中 $x > 1$。
- $\operatorname{mex} = 2$，当且仅当这个路径形如 $(0, 0, \cdots, 0, 1, \cdots)$。

读者自证不难。

### 距离为 $-1$

先考虑求距离为 $-1$ 的点对数。对每个点开一个 bitset，命名为 $con$，令 $con_{i,j} = 1$ 表示从 $i$ 可以到达 $j$，$con_{i, j} = 0$ 表示无法到达，特别地，$con_{i, i} = 1$。

$con$ 的求法是建反图，在反图上 dp，比较简单，最后见代码。

求得 $con$ 后，对答案的贡献就好求了，如下，其中 $c(A)$ 表示 $A$ 这个 bitset 中 $1$ 的个数，代码中可靠成员函数 `count()` 实现：

$$-1 \times \sum _ {i = 1} ^ n (n - c(con_i))$$

### 距离为 $2$

考虑求距离为 $2$ 的点对数。同样对每个点开一个 bitset，命名为 $me_2$，令 $me_{2 \hspace{0.05cm} i, j} = 1$ 表示（原图上）从 $i$ 到 $j$ 存在 $\operatorname{mex} = 2$ 的路径，$me_{2 \hspace{0.05cm} i, j} = 0$ 表示不存在。

$me_2$ 的求法仍然是在反图上 dp，但是我们需要先处理出 $sta_1$。

$sta_{1 \hspace{0.05cm} i, j} = 1$ 表示（原图上）存在一条从 $i$ 到 $j$ 的路径，且路径第一条边权值为 $1$，$sta_{1 \hspace{0.05cm} i, j} = 0$ 表示不存在。

$sta_1$ 的求法还是反图上 dp，转移方程如下（$E'$ 为反图的边集）：

$$sta_{1 \hspace{0.05cm} i} = \bigvee _ {(j, i, w) \in E', w = 1} con_j$$

求出 $sta_1$ 后，可以求出 $me_2$，由定义容易推得转移方程如下：

$$me_{2 \hspace{0.05cm} i} = \bigvee _ {(j, i, w) \in E', w = 0} (me_{2 \hspace{0.05cm} j} \operatorname{or} sta_{1 \hspace{0.05cm} j})$$

### 距离为 $1$

对每一个点开一个 bitset，命名为 $me_1$，令 $me_{1 \hspace{0.05cm} i, j} = 1$ 表示（原图上）从 $i$ 到 $j$ 存在 $\operatorname{mex} = 1$ 的路径（注意**不**保证不存在 $\operatorname{mex} = 2$ 的路径），$me_{1 \hspace{0.05cm} i, j} = 0$ 表示不存在 $\operatorname{mex} = 1$ 的路径。

类似于 $me_2$，如果我们求 $me_1$，那么要先求 $nst_1$。

$nst_{1 \hspace{0.05cm} i, j} = 1$ 表示（原图上）存在一条从 $i$ 到 $j$ 的路径，且路径第一条边权值大于 $1$，$nst_{1 \hspace{0.05cm} i, j} = 0$ 表示不存在。

用 dp 求 $nst_1$：

$$nst_{1 \hspace{0.05cm} i} = \bigvee _ {(j, i, w) \in E', w > 1} con_j$$

从而求出 $me_1$：

$$me_{1 \hspace{0.05cm} i} = \bigvee _ {(j, i, w) \in E', w = 0} (me_{1 \hspace{0.05cm} j} \operatorname{or} nst_{1 \hspace{0.05cm} j})$$

并且对于每个 $(j, i, w) \in E', w = 0$，令 $me_{1 \hspace{0.05cm} i, j} = 1$，因为全 $0$ 的路径也满足 $\operatorname{mex} = 1$。

### 距离为 $0$

因为对答案没有贡献，所以不需要计算。

### 计算答案

距离为 $2$ 的贡献：

$$2 \times \sum _ {i = 1} ^ n c(me_{2 \hspace{0.05cm} i})$$

距离为 $1$ 的贡献：

$$\sum _ {i = 1} ^ n c(me_{1 \hspace{0.05cm} i})$$

注意到 $me_1$ 可能与 $me_2$ 重合，即从 $i$ 到 $j$ 可能同时存在 $\operatorname{mex} = 1$ 和 $\operatorname{mex} = 2$ 的路径。而我们如果像上面那样算，会将这样的 $(i, j)$ 重复计算贡献，所以我们要将距离为 $1$ 的贡献的计算方式改为：

$$\sum _ {i = 1} ^ n c((me_{1 \hspace{0.05cm} i} \operatorname{xor} me_{2 \hspace{0.05cm} i}) \operatorname{and} me_{1 \hspace{0.05cm} i})$$

这就是在计算距离为 $1$ 的贡献时，忽略那些距离为 $2$ 的点对。读者可以好好理解一下。

## 代码

本代码中为了避免 MLE，没有定义 $me_1$，而是将 $con$ 重复利用。

但是内存仍然卡的很紧……

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 3e4 + 5;
struct edge{
	int v, w;
};
int n, m, tot, outd[N], ts[N], ans;
vector <edge> G[N], aG[N];
bitset <N> con[N], sta1[N], nst01[N], me2[N];
queue <int> Q;

void toposort(){
	for(int i = 1; i <= n; i++)
		if(!outd[i]) Q.push(i);
	while(!Q.empty()){
		int u = Q.front();
		Q.pop();
		ts[++tot] = u;
		for(edge e : aG[u]){
			outd[e.v]--;
			if(!outd[e.v]) Q.push(e.v);
		}
	}
}

int main(){
	
//	freopen("trip5.in", "r", stdin);
	ios :: sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1, u, v, w; i <= m; i++){
		cin >> u >> v >> w;
		G[u].emplace_back((edge){v, w});
		aG[v].emplace_back((edge){u, w});
		outd[u]++;
	}
	toposort();
	assert(tot == n);
	for(int i = 1; i <= n; i++){
		int u = ts[i];
		con[u][u] = 1;
		for(edge e : G[u])
			con[u] |= con[e.v];
	}
	for(int i = 1; i <= n; i++){
		int u = ts[i];
		for(edge e : G[u]){
			if(e.w == 1) sta1[u] |= con[e.v];
			if(e.w > 1) nst01[u] |= con[e.v];
		}
		sta1[u][u] = nst01[u][u] = 0;
	}
	for(int i = 1; i <= n; i++)
		ans += con[i].count() - n, con[i].reset();
	for(int i = 1; i <= n; i++){
		int u = ts[i];
		for(edge e : G[u]){
			int v = e.v, w = e.w;
			if(w) continue;
			me2[u] = ((me2[u] | me2[v]) | sta1[v]);
			con[u] = ((con[u] | con[v]) | nst01[v]);
			con[u][v] = 1;
		}
	}
	for(int i = 1; i <= n; i++){
		bitset <N> tmp = (con[i] ^ me2[i]);
		tmp &= con[i];
		ans += 2 * me2[i].count() + tmp.count();
	}
	cout << ans;
	
	return 0;
}
/*
Welcome to the Hotel California
Such a lovely place
Such a lovely face
Plenty of rooms at the Hotel California
Any time of year
You can find it here
*/
```

---

## 作者：qejwdi (赞：5)

注意到一个显然的性质：
> $\mathrm{mex}$ 只有可能是 $0,1,2$。

简单说明理由：如果想要到 $2$ 以上的话必须有 $0,1,2$ 的前缀 $or$，但是这显然是不可能的，因为前缀 $or$ 出 $1$ 后一定不能 $or$ 出 $2$。

所以我们对 $0,1,2$ 和无法到达考虑即可。

无法到达的使用 `bitset` 维护可达性即可求出。

接着为了好写点我做了一步拆贡献，就是分别统计最大 $\mathrm{mex}$ 大于等于 $1$ 的点对数和最大 $\mathrm{mex}$ 大于等于 $2$ 的点对数，这个显然是对的。

如果要 $\mathrm{mex}$ 大于等于 $1$，显然是第一条出边是 $0$，然后后面怎么走随便了。所以我们枚举起始点，然后再枚举第一条出边，接着看一下这条边的出点能到达多少点加起来就行。

如果 $\mathrm{mex}$ 要大于等于 $2$，显然是走了一串 $0$ 然后又走了一串 $1$，这个的话类似于 `dp` 的想法，对于每个点开个 `bitset` 记录经过一条边权为 $1$ 的出边可以到达的点的个数。然后再对于每个点考虑拼上前面的一串 $0$。对于一个点，枚举每个边权为 $0$ 的出边（显然这样才可能作为路径的第一条出边），然后要么是在后面拼上一串 $0$ 加上一串 $1$，要么是拼上一串 $1$，分别对 `bitset` 去 $or$ 上去即可。

代码很简单。

# Code:

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define all(vc) vc.begin(),vc.end()
#define ll long long
#define db double

using namespace std;

const int N=3e4+5;
int n,m,cnt[N];
vector<pair<int,int> >g[N];
bitset<N>can[N],zero[N],one[N];
ll ans=0;

int main(){

	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	// freopen("trip.in","r",stdin);
	// freopen("trip.out","w",stdout);

    cin>>n>>m;
    rep(i,1,m){
        int u,v,w;cin>>u>>v>>w;
        g[u].push_back({v,w});
    }
    per(i,n,1){
        can[i].set(i);
        for(auto j:g[i])can[i]|=can[j.first];
        cnt[i]=can[i].count();
        ans-=n-cnt[i];
    }
    per(i,n,1){
        for(auto j:g[i])if(!j.second)zero[i]|=can[j.first];
        ans+=zero[i].count();
    }
    rep(i,1,n)zero[i].reset();
    per(i,n,1){
        for(auto j:g[i])if(!(j.second-1))zero[i]|=can[j.first];
    }
    per(i,n,1){
        for(auto j:g[i])if(!j.second)one[i]|=one[j.first];
        ans+=one[i].count();
        one[i]|=zero[i];
    }
    cout<<ans<<'\n';


	return 0;
}

```

---

## 作者：Imerance1018 (赞：4)

赛时 5:10 想到了 bitset 但不会写遗憾离场，晚上 8:30 在车上想出正解，写篇题解纪念一下。

## Description

[传送门](https://www.luogu.com.cn/problem/P12250)

## Solution

### Part 1
首先由于 $u_i < v_i$，所以这是个 DAG，想到拓扑排序。

因为图是 DAG，所以先不考虑取最大值，研究单条链的贡献，显然距离只有 $0，1，2$ 这 $3$ 种。

证明：由于按位或运算结果单调不降，所以分 $3$ 种情况：

1. 从某个点出发，第一条边边权不是 $0$。那么后面不管怎么走，得到的疲劳度序列单调不降，第一条边的边权就是最小值，序列中不可能出现 $0$，所以 mex 是 $0$。

放张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/abuvv5jv.png)

从 1 出发，显然疲劳度序列不可能小于 $5$，所以 mex 必为 $0$。


2. 从某个点出发，第一条边边权是 $0$，第一条不是 $0$ 的边边权不是 $1$，或这条链上根本没有边权不是 $0$ 的边。同情况 1，此时序列中不可能出现 $1$，mex 是 $1$。

放张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/08u8baog.png)

从 1 出发，第一条边边权是 $0$，第一条不是 $0$ 的边权为 $2$，显然你是无法按位或出 $1$ 的，所以 mex 是 $1$。

3. 如果从某个点出发，第一条边边权是 $0$，第一条不是 $0$ 的边边权是 $1$，那么显然疲劳度序列中要么是 $0$，要么由于按位或 $1$ 而是偶数，mex 为 $2$。

放张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ejgq1cw.png)

从 $1$ 出发，第一条边边权是 $0$，第一条不是 $0$ 的边权为 $1$，显然你是无法按位或出 $2$ 的，所以 mex 是 $2$。

### Part 2

我们定义 bool 数组 $cnt_{i,j,k}$ 表示从 $i$ 到 $j$ 距离为 $k$ 是否可行，那么 $0 \le k \le 2$。

不妨令 $cnt_{i,j,3}$ 表示是否存在从 $i$ 到 $j$ 的路径使得第一条边边权为 $1$。

建个反图，拓扑排序，每次对拓展到的节点进行维护，类似 DAG 上 DP，而这是容易的。

贴一下暴力代码：

```cpp
if(z==0)
{
	for(int i=1;i<=n;i++)cnt[y][i][2]|=cnt[x][i][2];//如果前面有很多个 0，距离仍然可以是 2，所以要传递上来
	for(int i=1;i<=n;i++)
		if(cnt[x][i][3])
			cnt[y][i][2]=1,cnt[y][i][1]=cnt[y][i][0]=0;//注意 2
		else if((cnt[x][i][0]||cnt[x][i][1]||cnt[x][i][2]||x==i)&&cnt[y][i][2]==0)//注意 1
			cnt[y][i][1]=1,cnt[y][i][0]=0;//注意 2
}	
else
{
	for(int i=1;i<=n;i++)
		if((cnt[x][i][0]||cnt[x][i][1]||cnt[x][i][2]||x==i)&&cnt[y][i][2]==0&&cnt[y][i][1]==0)//注意 1
			cnt[y][i][0]=1;
}
if(z==1)
	for(int i=1;i<=n;i++)
		if(cnt[x][i][0]||cnt[x][i][1]||cnt[x][i][2]||x==i)
			cnt[y][i][3]=1;
``````

其中 $x$ 是拓扑排序时的队首，$y$ 是队首拓展到的点，$z$ 是 $x$ 和 $y$ 间的边权。

注意两个问题：

1.  如果从 $y$ 到 $i$ 已经有一条比新得到距离大的路径，就不必更新。
2.  更新距离后，要把从 $y$ 到 $i$ 之前得到的比当前距离小的路径删除。

### Part 3

$cnt$ 数组可以用 bitset 维护。

那么令 $cnt_{y,k}$ 表示以 $y$ 为起点到各顶点距离为 $k$ 是否可行。

发现上面的两个注意事项可以合并成一个：以 $cnt_{y,1}$ 为例，在 $cnt_{y,1}$ 中去掉 $cnt_{y,1}$ 与 $cnt_{y,2}$ 的公共部分即可。

那么只需在每次更新后将 $cnt_{y,2}$ 异或上 $2^n$，再用 $cnt_{y,1}$ 按位与这个值，就能去掉公共的部分。

$cnt_{y,0}$ 同理。

时间复杂度为 $O(\dfrac{nm}{w})$，空间复杂度为 $O(\dfrac{n^2}{w})$，完结撒花。

## Code
```cpp
//此代码中 cnt[i][0][i] 无意义，所以加了一点特判
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e4+10;
int n,m,ans,q[N],head=1,tail,d[N];
vector<pair<int,int> >G[N];
bitset<N>cnt[N][4],tmp;
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		G[v].emplace_back(make_pair(u,w));
		d[u]++;
	}
	tmp.set();
	for(int i=1;i<=n;i++)
		if(d[i]==0)q[++tail]=i;
	while(head<=tail)
	{
		int x=q[head++];
		for(int i=0;i<G[x].size();i++)
		{
			int y=G[x][i].first,z=G[x][i].second;
			d[y]--;
			if(z==0)
			{
				cnt[y][2]|=cnt[x][2];
				cnt[y][2]|=cnt[x][3];
				cnt[y][1]|=(cnt[x][1]|cnt[x][0]|cnt[x][2]);
				cnt[y][1][x]=1;
				
				cnt[y][1]&=(cnt[y][2]^tmp);
				cnt[y][0]&=(cnt[y][2]^tmp);
				cnt[y][0]&=(cnt[y][1]^tmp);
			/*	for(int i=1;i<=n;i++)
					if(cnt[x][i][3])
						cnt[y][i][2]=1,cnt[y][i][1]=cnt[y][i][0]=0;
					else if((cnt[x][i][0]||cnt[x][i][1]||cnt[x][i][2]||x==i)&&cnt[y][i][2]==0)
						cnt[y][i][1]=1,cnt[y][i][0]=0;*/
			}	
			else
			{
				cnt[y][0]|=(cnt[x][0]|cnt[x][1]|cnt[x][2]);
				cnt[y][0][x]=1;
				cnt[y][0]&=(cnt[y][2]^tmp);
				cnt[y][0]&=(cnt[y][1]^tmp);
			/*	for(int i=1;i<=n;i++)
					if((cnt[x][i][0]||cnt[x][i][1]||cnt[x][i][2]||x==i)&&cnt[y][i][2]==0&&cnt[y][i][1]==0)
						cnt[y][i][0]=1;*/
			}
			if(z==1)
			{
				cnt[y][3]|=(cnt[x][0]|cnt[x][1]|cnt[x][2]);
				cnt[y][3][x]=1;
			}
			if(d[y]==0)q[++tail]=y;
		}
	}
	for(int i=1;i<=n;i++)
	{
		int sum0=cnt[i][0].count(),sum1=cnt[i][1].count(),sum2=cnt[i][2].count();
		ans+=sum1+sum2*2-(n-1-sum0-sum1-sum2);
	}
	cout<<ans;
	return 0;
}
``````

---

## 作者：liuhaoyan0323 (赞：2)

**管理员大大求放吧，打回 $5$ 次了。关键每一次理由都不一样。**

这题非常离谱，`bitset` 刚刚下放普及组考纲马上就考到了。

问了下考场的其他人，好像得分率不高，今年一等线：$208$。

蒟蒻也是一路挂分 QwQ。

## 前话

这是一篇非本人独自写成的题解，思路是教练讲解的。

## 思路

考察位运算。

**【结论】**：\
$\operatorname{mex}$ 只有可能是 $0,1,2$。\
**【证明】**：

1. 若 $\operatorname{mex}=0$，需要 $\operatorname{mex}(1,3,..)$ 即可。即前缀或需要有 $1$ 即可，但不可有 $0$。
2. 若 $\operatorname{mex}=1$，需要 $\operatorname{mex}(0,2,4...)$ 即可。即前缀或需要有 $0$ 即可，且不能同时有 $0$ 和 $1$。
3. 若 $\operatorname{mex}=2$，需要 $\operatorname{mex}(0,1,5...)$ 即可。即前缀或必须需要有 $0,1$，且不可有 $2$。
4. 若 $\operatorname{mex}>2$（比如 $3$），则需要有类似 $\operatorname{mex}(0,1,2,5...)$。即前缀或必须需要 $0,1,2$。但其中的 $0$ 可以独立或运算得到，$1=1|0$，此时前缀或结果集既包括 $0$，也得包括 $1$，但包括 $1$ 时，不能再或运算出 $2$（因为 $1|any$，末尾肯定为 $1$，而 $2$ 的末尾为 $0$），即 $1$ 和 $2$ 不可能通过或运算后会同时存在。

故不存在大于 $2$ 的 $\operatorname{mex}$ 数值。\
**【推导】**：\
所以我们对 $0,1,2$ 和无法到达考虑即可：

- 一、无法到达的使用 `bitset` 维护可达性即可求出。这在以下“第一阶段”计算中计算出来。

- 二、$\operatorname{mex} \geq 1$（参照“第二阶段”逻辑）
  显然是第一条出边是 $0$，然后后面怎么走随便了。所以我们枚举起始点，然后再枚举
  第一条出边，接着看一下这条边的出点能到达多少点加起来就行。

- 三、如果 $\operatorname{mex} \geq 2$（参照“第三阶段”和“第四阶段”逻辑）
  显然是走了一串 $0$ 然后又走了一串 $1$，类似于 `dp` 思路，对于每个点开个 `bitset` 记录经过一条边权为 $1$ 的出边可以到达的点的个数。然后再对于每个点考虑
  拼上前面的一串 $0$。对于一个点，枚举每个边权为 $0$ 的出边（显然这样才可能作为
  路径的第一条出边），然后要么是在后面拼上一串 $0$ 加上一串 $1$，要么是拼上一串 $1$，
  分别对 `bitset` 去 $or$ 上去即可。

- 四、
  当 $\operatorname{mex}=0$ 时，$dis_{u,v}= \max (\operatorname{mex},s2,s3)$，即 $\operatorname{mex}=0$ 时，对 $dis$ 数值无影响，暂无需专门考虑。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N (int)(3e4+5)
using namespace std;
inline void read(int &num);
int n,m,cnt;
vector<pair<int,int> > g[N];
bitset<N> can[N],zero_w[N],one_w[N],one_m[N];
int ans;
signed main(){
	int u=0,len=0;
	int vex=0,w=0;
	read(n);
	read(m);
	for(int i=1;i<=m;++i){
		int u,v,w;
		read(u);
		read(v);
		read(w);
		g[u].push_back({v,w});
	}
  // 第一阶段：计算可达性（从后往前，保证拓扑顺序），计算出不可达线路，求出不可达城市的距离 
	for(u=n;u>=1;--u){
		can[u].set(u);
		len=g[u].size();
		for(int k=0;k<len;++k){
			vex=g[u][k].first;
			can[u]|=can[vex];
		}
		cnt=can[u].count();
		ans-=(n-cnt);
	}
  // 第二阶段：计算边权为0的情况
	for(u=n;u>=1;--u){
		len=g[u].size();
		for(int k=0;k<len;++k){
			vex=g[u][k].first;
			w=g[u][k].second;
			if(!w){
				zero_w[u]|=can[vex];
			}
		}
		ans+=zero_w[u].count();
	}
  // 第三阶段：计算边权为1的直接可达性
	for(u=n;u>=1;--u){
		len=g[u].size();
		for(int k=0;k<len;++k){
			vex=g[u][k].first;
			w=g[u][k].second;
			if(w==1){
				one_w[u]|=can[vex];
			}
		}
	}
  // 第四阶段：计算疲劳度为1的情况
	for(u=n;u>=1;--u){
		len=g[u].size();
		for(int k=0;k<len;++k){
			vex=g[u][k].first;
			w=g[u][k].second;
			if(!w){
				one_m[u]|=one_m[vex];
			}
		}
		ans+=one_m[u].count();
		one_m[u]|=one_w[u];
	}
	printf("%lld",ans);
	return 0;
}
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	num=x*f;
}
```

---

## 作者：CatFromMars (赞：2)

高龄老汉前来观摩，膜拜巨佬。

奶龙题。

$\operatorname{mex}$ 看上去就很难做。注意到，对于一条路径绝大部分情况下都是 $0$，只有在第一条边等于 $0$ 的情况下 $\operatorname{mex}\not= 0$。如果下一条边是 $1$，那么$\operatorname{mex} = 2$，否则 $\operatorname{mex} = 1$。我们发现这两条边足以确定这个路径的 $\operatorname{mex}$，因为在 $s_i = 1$ 之后任何的或至少会让这个值变大 $2$，不再连续。也可以看成：贪心的想，让 $\operatorname{mex}$ 最大的最好方法就是每次或上更高一位的 $1$，这样分析也能得到相同的结果。

所以得到结论：$d(u, v) = 2$ 当且仅当 $u$ 经过 $0, 0, 0, \dots, 0, 1$ 边后能到 $v$。否则如果 $u$ 只经过 $0$ 能到 $v$ 则 $d(u, v) = 1$，否则 $d(u, v) = 0$。反图拓扑维护一下几个集合就行了。具体请见代码。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e4, M = 2e5;
bitset <N + 10> zes[N + 10], oes[N + 10], cts[N + 10], fes[N + 10];
//cts 代表能到的点集
//fes 代表 0000001 能到的点集
//zes 代表 0000000 能到的点集
//oes 代表经过一条 1 能到的点集
struct node {
	int to, val;
	node(int T, int V) {
		to = T, val = V;
	}
};
vector <node> ngr[N + 10], gra[N + 10];
int deg[N + 10];
int n, m;

void topo() {
	queue <int> que;
	for(int i = 1; i <= n; i++) {
		if(!deg[i])
			que.push(i);
		cts[i][i] = 1;
	}

	while(!que.empty()) {
		int u = que.front(); que.pop();
		for(int i = 0; i < gra[u].size(); i++) {
			int v = gra[u][i].to, w = gra[u][i].val;
			deg[v]--;
			cts[v] |= cts[u];
			if(!w) {
				zes[v] |= (zes[u] | cts[u]);
				fes[v] |= (fes[u] | oes[u]);
			}
			if(w == 1) oes[v] |= cts[u];
			if(!deg[v]) que.push(v);
		}
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		gra[y].push_back(node(x, z));
		deg[x]++;
	}
	topo();

	bitset <N + 10> rest;
	int sum = 0;
	for(int i = 1; i <= n; i++) {
		rest = (zes[i] ^ fes[i]);
		int a = rest.count();
		int b = fes[i].count();
		int c = cts[i].count();
		sum += a * 1;
		sum += b * 2;
		sum -= (n - c);
	}
	cout << sum << endl;
}
```

---


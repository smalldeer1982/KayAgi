# 「HCOI-R2」DataErr0r

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/7mafbnqx.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

（图片来自 Arcaea 曲绘，如有侵权请联系出题人删除。）

> How do you know you are not a Program?

## 题目描述

小 N 有两个 $\tt01$ 串 $S$ 和 $T$，其长度分别为 $N$ 和 $N+1$。你可以对 $T$ 进行一些修改。

- 选定 $1\leq i \leq |T|$，删除 $T_i$，其余字符下标左移。
- 选定 $1\leq l\leq r\leq |T|$，对于所有 $l\leq i\leq r$ 且 $(l+i)\equiv 0\pmod 2$ 的 $i$ 执行 $T_i\gets T_i\oplus 1$。

小 N 想使得 $T = S$，但是她非常懒，所以你需要最小化操作次数。

**注意：你只需要输出这个最小化的操作次数即可，而无需给出构造。**

## 说明/提示

### 样例解释 1 
- $1\textbf 01\textbf 01\to 1\textbf11\textbf11$
- $1111\underline{1}\to 1111$

使用 $2$ 次步骤。

### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 0 (15pts)：$1\leq \sum N\leq 10$。
- Subtask 1 (35pts)：$1\leq \sum N\leq 10^3$。
- Subtask 2 (50pts)：无特殊限制。

对于所有数据，$1\leq K\leq 1000$，$1\leq \sum N\leq 10^6$，$1\leq N\le 10^6$。

## 样例 #1

### 输入

```
1
4
10101
1111```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1
11
1
3
1010
010
7
10110110
0001111```

### 输出

```
1
1
2```

# 题解

## 作者：weiyiqian (赞：5)

upd：数据更新。


---

注意到 $S$ 和 $T$ 的长度分别为 $N$ 和 $N+1$，所以删除操作有且仅有一次，并且操作 $2$ 相当于选一个区间并将区间内的奇数/偶数位取反。

所以就可以把题意转化为把 $T$ 的其中一个字符删去后，前后字符串拼接而成的新字符串和 $S$ 相等的最少操作次数（操作 $2$ 可以在删前执行也可以在删后执行）。

考虑预处理出 $T$ 的前缀和后缀通过操作 $2$ 使得两个字符串对应部分相同的最少操作次数 $pre_i$ 和 $ne_i$。于是我们就能枚举删掉第 $i$ 个字符，每次枚举计算一下操作次数 $pre_{i-1}+ne_{i+1}+1$，然后取最小值即可。

但是还需要注意：拼接成新字符串后，前后字符串的操作 $2$ 有可能合并在一起使得操作次数更少，所以如果出现可合并的操作，要将答案减一。接下来考虑如何合并。

我们可以发现操作合并只对当前字符后的字符串的前两位即 $i+1$ 和 $i+2$ 有效。考虑计算出操作合并出现在删除前和删除后的操作次数（不能一次合并在删除前，一次合并在删除后，因为这样会使同一个字符两次取反），删除前第 $i+1$ 位的操作可以和第 $i-1$ 位合并，第 $i+2$ 位的操作可以和第 $i-2$ 位合并，删除后同理。

考虑一种特殊情况（讨论区大佬的 hack）：
```
1 7
00000000
1110001
```
当删除第 4 位时，可以通过删除字符前后下标奇偶性改变的性质将前缀字符串的操作延伸到前后操作 $2$ 不相邻的后缀字符串，即  
先将操作 $2$ 延伸到要改变的后缀字符串，
```
00000000
->01010101
```
然后删除第 4 位字符，
```
->0100101
```
最后再次取反，将后缀字符串前不需要改变的字符变回来。
```
->1110001
```
那怎么判断这种情况呢？  
当 $i-1$ 位和 $i-2$ 位都需要改变且存在后缀字符串需要改变时，就可以将后缀字符串中的**一次**操作合并到前缀（因为这种操作只能是两次前缀字符串的操作中一次操作恢复另一次操作的前缀）；同理，当 $i+1$ 位和 $i+2$ 位都需要改变且存在前缀字符串需要改变时也能这么做。  

代码中怎么实现呢？  
预处理出两个数组 $ne\_id_i$ 和 $pre\_id_i$ 分别表示第 $i$ 位字符前后第一个需要改变的字符，按照上述思路判断即可。


---


注意数组 $ne$ 要清零和数组 $ne\_id$ 的边界处理。


---


代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,pre[N],ne[N],pre_id[N],ne_id[N];
char x[N],y[N];
int main(){
    int t;
    cin>>t;
    while(t--){
        cin>>n>>x+1>>y+1;
        int ans=1e9;
        bool flag[2]={0,0};
        for(int i=1;i<=n;i++){
            pre[i]=pre[i-1];
            pre_id[i]=pre_id[i-1];
            if(x[i]==y[i]) flag[i%2]=0;
            else{
                pre_id[i]=i;
                if(!flag[i%2]) pre[i]++;
                flag[i%2]=1;
            }
        }
        flag[1]=flag[0]=0;
        ne[n+2]=0;
        ne_id[n+2]=ne_id[n+3]=n+2;
        for(int i=n+1;i>=2;i--){
            ne[i]=ne[i+1];
            ne_id[i]=ne_id[i+1];
            if(x[i]==y[i-1]) flag[i%2]=0;
            else{
                ne_id[i]=i;
                if(!flag[i%2]) ne[i]++;
                flag[i%2]=1;
            }
        }
        for(int i=1;i<=n+1;i++){
            int res=pre[i-1]+ne[i+1]+1,p1=pre_id[i-1],p2=pre_id[i-2],n1=ne_id[i+1],n2=ne_id[i+2];
            //删前
            ans=min(ans,res-(i-1>=1&&x[i-1]!=y[i-1]&&i+1<=n+1&&x[i+1]!=y[i])-(i-2>=1&&x[i-2]!=y[i-2]&&i+2<=n+1&&x[i+2]!=y[i+1]));
            //删后
            ans=min(ans,res-(i-2>=1&&x[i-2]!=y[i-2]&&i+1<=n+1&&x[i+1]!=y[i])-(i-1>=1&&x[i-1]!=y[i-1]&&i+2<=n+1&&x[i+2]!=y[i+1]));
            //特殊情况
            if(i-2>=1&&p1==i-1&&p2==i-2){
                if(n1<=n+1) res--;
                else if(n2<=n+1) res--;
            }
            else if(i+2<=n+1&&n1==i+1&&n2==i+2){
                if(p1) res--;
                else if(p2) res--;
            }
            ans=min(ans,res);
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：modfish_ (赞：5)

Upd：更新为能通过讨论区 Hack 数据的做法。

## 思路
先不考虑删掉哪一位，让我们思考只有 $2$ 操作时答案如何。

明显地，先将 $T$ 与 $S$ 按位异或，问题转化为进行若干次操作把所有 $1$ 变成 $0$。把 $T$ 按位数奇偶性拆分，容易发现一次操作相当于对某个奇串或偶串的一段子串取反。答案即为两个串中极长连续 $1$ 子串的数量。

不妨设 $P_i$ 表示将 $S$ 与 $T$ 的前 $i$ 位中，与 $i$ 奇偶性相同的位置按位异或后顺次拼接得到的串。例如样例 $2$ 的第 $3$ 组测试，$T$ 和 $S$ 分别为：

```
10110110
0001111
```

欲求 $P_6$，先将前 $6$ 位按位异或，得到：

```
101010
```

随后取与 $6$ 奇偶性相同的位，即 $2,4,6$ 位，得到：

```
000
```

此即 $P_6$。类似地，定义 $U_i$ 表示将 $S$ 的第 $i-1$ 到第 $n$ 位，和 $T$ 的第 $i$ 到 $n+1$ 位，进行上述操作得到的串。

我们接下来定义 $f_i$ 表示 $P_i$ 的极长连续 $1$ 子串的数量，$g_i$ 表示 $U_i$ 的极长连续 $1$ 子串数量。

下面我们考虑删除某个位置。删掉 $1$ 时，答案即为 $g_2+g_3$；删掉 $n+1$ 时，答案即为 $f_n+f_{n-1}$。

删掉某个位置 $i$ 时，很明显，删掉后，序列的奇偶串必定是 $P_{i-1}+U_{i+2}$ 与 $P_{i-2}+U_{i+1}$，其中 $+$ 表示拼接。答案理应为 $f_{i-1}+g_{i+2}+f_{i-2}+g_{i+1}$。

不过，拼接时可能会减少极长连续 $1$ 子串数量。所以答案可以减少。当 $P_{i-1}$ 的串尾与 $U_{i+2}$ 的串头同为 $1$ 时，答案减少 $1$，$P_{i-2}$ 与 $U_{i+2}$ 同理。

还有一点：我们也可以在删除前进行 $2$ 操作，此时，我们可以一次操作消去 $P_{i-1}$ 串尾前缀 $1$ 与 $U_{i+1}$ 串头的后缀 $1$，或者 $P_{i-2}$ 串尾前缀 $1$ 与 $U_{i+2}$ 串头的后缀 $1$。

（以下为更新内容）：以及，我们还有一种方法：当前两个串的串尾都为 $1$，后两个串的串头都为 $0$ 时，可以将一个串尾和另一个串头的 $1$ 和 $0$ 反转。具体例如：

```
11   01
1    00
```

以上是讨论区的 Hack 中，$P_3,U_6,P_2,U_5$ 的串（从左到右，从上到下）。我们可以翻转 $P_2$ 的尾部 $1$ 与 $U_6$ 的头部 $0$：

```
11   11
0    00
```

然后拼起来就只剩一个连通块了，可以借此减少 $1$ 次操作。当然，这个操作的前提是 $U_6$ 不全为 $0$，需要特判。具体见代码。

进行如上讨论即可。时间复杂度 $O(\sum n)$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e6 + 5;

char s[maxn], t[maxn];
int f[maxn], g[maxn], ft[maxn], gt[maxn];

int main(){
    int T;
    scanf("%d", &T);
    while(T --){
        int n;
        scanf("%d %s %s", &n, t + 1, s + 1);
        for(int i = 1; i <= n; i ++) s[i] -= 48, t[i] -= 48;
        t[n + 1] -= 48;
        f[0] = ft[0] = g[n + 2] = gt[n + 2] = 0;
        for(int i = 1; i <= n; i ++){
            if(i > 1){
                ft[i] = s[i] ^ t[i];
                f[i] = f[i - 2] + ((!ft[i - 2] && ft[i]) ? 1 : 0);
            }else f[i] = ft[i] = s[i] ^ t[i];
        }
        for(int i = n + 1; i >= 2; i --){
            if(i <= n){
                gt[i] = s[i - 1] ^ t[i];
                g[i] = g[i + 2] + ((!gt[i + 2] && gt[i]) ? 1 : 0);
            }else g[i] = gt[i] = s[i - 1] ^ t[i];
        }
        int ans = min(f[n] + f[n - 1], g[2] + g[3]);
        for(int i = 2; i <= n; i ++){
            int res = f[i - 1] + f[i - 2] + g[i + 1] + g[i + 2];
            if(ft[i - 1] + ft[i - 2] + gt[i + 1] + gt[i + 2] == 4) res -= 2;
            else if(ft[i - 1] + ft[i - 2] + gt[i + 1] + gt[i + 2] == 3) res -= 1;
            else if(ft[i - 1] + ft[i - 2] + gt[i + 1] + gt[i + 2] == 2){
                if(ft[i - 1] + ft[i - 2] == 2){
                    if(g[i + 1] || g[i + 2]) res --;
                }else if(gt[i + 1] + gt[i + 2] == 2){
                    if(f[i - 1] || f[i - 2]) res --;
                }else res --;
            }
            ans = min(ans, res);
        }
        printf("%d\n", ans + 1);
    }
    return 0;
}
```

---


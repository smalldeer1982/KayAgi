# 信号放大器

## 题目描述

树型网络是最节省材料的网络。所谓树型网络，是指一个无环的连通网络，网络中任意两个结点间有且仅有一条通信道路。

网络中有一个结点是服务器，负责将信号直接或间接地发送到各终端机。如图上方，server 结点发出一个信号给结点 $a$ 和 $c$，$a$ 再转发给 $b$。如此，整个网络都收到这个信号了。

![](https://cdn.luogu.com.cn/upload/image_hosting/e4vb2e7t.png)

但是，实际操作中，信号从一个结点发到另一个结点，会出现信号强度的衰减。衰减量一般由线路长度决定。

如图下方，边上所标的数字为边的衰减量。假设从 server 出发一个强度为 $4$ 个单位的信号，发到结点 $a$ 后强度衰减为 $4-3=1$ 个单位。结点 $a$ 再将其转发给结点 $b$。由于信号强度为 $1$，衰减量为 $2$，因此信号无法发送到 $b$。

一个解决这一问题的方法是，安装信号放大器。信号放大器的作用是将强度大于零的信号还原成初始强度（从服务器出发时的强度）。

上图中，若在结点 $a$ 处安装一个信号放大器，则强度为 $4$ 的信号发到 $a$ 处，即被放大至 $4$。这样，信号就可以被发送的网络中的任意一个节点了。为了简化问题，我们假定每个结点只处理一次信号，当它第二次收到某个信号时，就忽略此信号。

你的任务是根据给出的树型网络，计算出最少需要安装的信号放大器数量。

## 样例 #1

### 输入

```
4
2 2 3 3 1
2 1 3 4 2
1 1 1
1 2 2
4```

### 输出

```
1
```

# 题解

## 作者：c60521c (赞：38)

# 题解
**~~2021第一篇题解~~**  
## **引言**  
这道题很明显是一个树形结构但在看完标签后发现还有贪心，于是就想到了这样的方法  。
## **思路**  
1. 不用从根节点往下dfs每条线。
1. 可以从叶子结点往上爬，一直爬到根节点。
1. 将每条线上的信号衰减值累加，与初始信号强度比较。
1. 若累加值小于初始信号长度则不用安放，大于等于时ans++  。
## **注意**  
**特判点：** 
```
if(mx >= len)
	printf("No solution.\n");
```
**说明**：  
当**衰减值和初始强度相等**时信号最后到达时会**衰减为0**，接收不到。
## 样例说明！
![样例说明](https://cdn.luogu.com.cn/upload/image_hosting/l80mti3h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
样例：   
4  
2 2 3 3 1  
2 1 3 4 2  
1 1 1  
1 2 2  
4  

2 2 3 3 1  
根节点有两个子节相连，分别为2和3，与之对应的信号衰减值为3和1。  
2 1 3 4 2  
节点2有两个节点相连，一个根节点另一个为四号节点，信号衰减值为3和2。  
1 1 1  
三号节点有一个节点相邻，衰减值为1，相连节点即为根节点  。  
1 2 2  
四号节点有一个节点相连，即为二号节点，衰减值为2 。  
4  
最后输入的是初始强度。
## **核心代码**
1、用vector来存而不是直接int
```
vector<int> g[20005], d[20005];
```
2、从叶节点往上找到根节点过程中的信号衰减值综合与信号强度比较
```
void dfs(int x, int fa)
{//搜索结点x，其父结点为fa
	for(int i = 0; i <= g[x].size(); i++)
	{//枚举所有和结点x的相连的结点
		int y = g[x][i];
		if(y != fa) //只要该结点非父结点
		{
			p[y] = d[x][i]; //记录第y个点及其父结点连边的权重
			dfs(y, x);
			dis[x] = max(dis[x], dis[y] + d[x][i]);
		}
	}
	if(dis[x] + p[x] >= len)
	{
		ans++;
		dis[x] = 0;
	}
}
```
3、//有向图 v为i的临界顶点，push到g中 
```
g[i].push_back(v);
d[i].push_back(w);
mx = max(mx, w);//存最大边长 w边长
```
## 接下来就是 AC Code
```
#include<cstdio>
#include<vector>
#include<cmath>
#include<iostream>
#include<algorithm> 
using namespace std;

vector<int> g[20005], d[20005];
int n, dis[20005], p[20005], ans, len;

void dfs(int x, int fa)
{//搜索结点x，其父结点为fa
	for(int i = 0; i < g[x].size(); i++)
	{//枚举所有和结点x的相连的结点
		int y = g[x][i];
		if(y != fa) //只要该结点非父结点
		{
			p[y] = d[x][i]; //记录第y个点及其父结点连边的权重
			dfs(y, x);
			dis[x] = max(dis[x], dis[y] + d[x][i]);
		}
	}
	if(dis[x] + p[x] >= len)
	{
		ans++;
		dis[x] = 0;
	}
}

int main()
{
	scanf("%d", &n);
	int mx = 0, v, w;//mx所有边最大边长 
	for(int i = 1; i <= n; i++)
	{
		int m;
		scanf("%d", &m);
		for(int j = 1; j <= m; j++)
		{
			scanf("%d%d", &v, &w);
			g[i].push_back(v);//有向图 v为i的临界顶点，push到g中 
			d[i].push_back(w);
			mx = max(mx, w);//存最大边长 w边长 
		}
	}
	scanf("%d", &len);
	dfs(1, 0); //结点1表示服务器
	if(mx >= len) //若边的最大损耗会超过信号初始强度则无解 
		printf("No solution.\n");
	else printf("%d\n", ans);
	
	return 0;
}    
```

------------

完美结束。~~留个赞吧。~~

---

## 作者：这有一只匿 (赞：18)

题解里好像大都是树形DP，我用的是贪心

我们设dis[x]表示x子树内到他最深距离。
因为不论是最小，还是不优的方法，你至少都要满足每个点都能被信号辐射到，所以可以从叶子节点开始往上爬，找到一个点，dis[x]+他到他父亲的距离大于初始信号强度，那么这个点需要且必须放一个信号放大器，然后把这个点的dis[x]赋为0.
之后一直按这种只有到不得不放信号放大器的时候才放信号放大器，这样得到的结果就是最优。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define re register int 
using namespace std;
const int MAX=2e4+5;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return *A++;};
template<class T>inline void read(T&x){
    char c;re y=1;while(c=gc(),c<48||57<c)if(c=='-')y=-1;x=c^48;
    while(c=gc(),47<c&&c<58)x=(x<<1)+(x<<3)+(c^48);x*=y;
}
int n,cnt,w,sss,ans;
int fi[MAX],dis[MAX],fa[MAX];
struct hehe{
    int nx,nd,co;
}e[MAX*2];
void add(int a,int b,int c)
{
    e[++cnt]=(hehe){fi[a],b,c},fi[a]=cnt;
}
void dfs(int x,int fat)
{
    for(int v=fi[x];v;v=e[v].nx)
    if(e[v].nd!=fat)
    {
        fa[e[v].nd]=e[v].co;//fa[x]表示x点到他父亲的距离
        dfs(e[v].nd,x);
        dis[x]=max(dis[e[v].nd]+e[v].co,dis[x]);
    }
    if(dis[x]+fa[x]>w)ans++,dis[x]=0;
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        int k;
        read(k);
        for(int j=1;j<=k;j++)
        {
            int b,c;
            read(b);read(c);
            add(i,b,c);
            sss=max(sss,c);
        }
    }
    read(w);
    if(sss>=w){cout<<"No solution.";return 0;}
    dfs(1,1);
    cout<<ans;
    return 0;
}
```

---

## 作者：MloVtry (赞：11)

树形DP

g[i]表示i号节点所需的最小信号强度，即要使子树中每个节点都接收到信号的最小强度


f[i]表示i为根节点的子树中最少需要多少个信号增强器


然后树形dp

g[i]=max(g[j]+len(i->j)),j为I的子节点

f[I]=Σf[j]

如果g[i]+len[father(i)->i]>h

那么g点要放置一个信号增强器，g[i]=1,f[i]++

如果一条边的长度>h,则必定无解

代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#define N 100010
#define M 200010
using namespace std;
int f[N],g[N],n,h;
int head[N],to[M],len[M],Next[M],e;
void buid(int u,int v,int l)
{
    Next[++e]=head[u];head[u]=e;
    to[e]=v;len[e]=l;
}
void dfs(int now,int fa)
{
    int fl=0,sons=0,tof;
    for(int i=head[now];i;i=Next[i])
    {
        int j=to[i];
        if(j==fa)
        {
            tof=i;
            continue;
        }
        if(len[i]>=h)
        {
            cout<<"No solution.\n";
            exit(0);
        }
        dfs(j,now);
        g[now]=max(g[now],g[j]+len[i]);
        f[now]+=f[j];
        sons++;
    }
    if(!sons)
    {
        f[now]=0;
        g[now]=1;
    }
    else
    {
        if(now!=1&&g[now]+len[tof]>h)
        {
            f[now]++;
            g[now]=1;
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int k;scanf("%d",&k);
        for(int j=1;j<=k;++j)
        {
            int v,l;scanf("%d%d",&v,&l);
            buid(i,v,l);
        }
    }
    scanf("%d",&h);
    dfs(1,0);
    cout<<f[1]<<endl;
    return 0;
}
```

---

## 作者：_xzhdsnh1364 (赞：6)

老师刚好讲了这道题，来发个题解开（hua）兴（ji）一下。
# 题目大意
从服务器（根节点）向下传递信号，每次经过一条路径消耗一定信号，信号 $\le 0$ 时且未传播所有节点则任务失败，现在要在节点上修建一些信号放大器，信号经过可恢复为初始信号，若仍旧任务失败，则输出 ```No solution.```。
# 思路分析
首先很容易想到一个策略，找到最大的子节点如果可以从这个子节点通过，就不用修建放大器，但我们可以很快举出反例：

# ![](https://cdn.luogu.com.cn/upload/image_hosting/fnphlwvd.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

若初始信号为 $8$，到 $2$ 和 $4$ 在往下时会信号不足，所以我们要看整个子树，那么，树形 DP，启动！

先将他的编号与权值存入树中，然后进入主要的 DFS 部分，参数有节点，与父亲连接的权值，父亲节点，父亲节点是用来判重的，也可以用数组判重，遍历子节点，如果这个子节点所对应的权值大于了初始信号，直接输出 ```No solution.```，然后往下递归，找出每个子节点向下递归所需的权值数，并求出所有子节点中的最大值。遍历完之后如果最大值加上目前权值比初始的信号大，则修建一个放大器，并将对应 DP 值清零。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n , k , u , x , cnt , p , dp[20005];
struct node{
    int id , w;
};
vector<node>g[20005];
void dfs(int x , int w , int fa){
    for(auto i : g[x]){
        if(i.id == fa)continue;//判重
        if(i.w >= p){
            cout << "No solution.";
            exit(0);//退出整个程序
        }
        dfs(i.id , i.w , x);//往下递归
        dp[x] = max(dp[x] , dp[i.id] + i.w);//算最大值
    }
    if(w + dp[x] >= p){dp[x] = 0;cnt++;}//需要修建放大器
}
int main(){
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> k;
        for(int j = 1;j <= k;j++){
            cin >> u >> x;
            g[i].push_back(node{u , x});//建树
        }    
    }
    cin >> p;
    dfs(1 , 0 , 0);
    cout << cnt;//完美的结束
    return 0;
}
```

---

## 作者：phmaprostrate (赞：4)

## 题意
选取最少的点建立放大器，使得从根点的信号能到达所有点。对于一个子节点它只有两种情况，被父亲或儿子更新。
## 分析
每个子节点的两种情况导致在贪心时不能确定是在它的儿子建立更优，还是在它的父亲更优，不考虑的话就会获得 $40pts$ 的好成绩。

所以，应该从子节点开始往上贪心，遇到不能传递的则直接建立个数增加，这是不需要考虑是否在儿子上更优。记录一个 $dis$ 表示该节点能到达的最远距离，当该节点到父亲节点的距离和到达最深节点的距离累加大于最大强度时，就该建立了。建立后 $dis$ 就可以归零，因为已经考虑过了，防止在往上更新时重复。

注意，要考虑无解情况，可以先存下最大边权，如果大于等于最大信号强度就是无解。等于也是！不能建双向变，因为样例给出的是建单向边，建双向边会多出一条边。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e4 + 10;
struct node {
	int to,next,w;
} tr[2 * N];
int n,h[N],k = 0,m,ans = 0;
void add(int from,int to,int w) {
	tr[++k].to = to;
	tr[k].next = h[from];
	tr[k].w = w;
	h[from] = k;
}
int maxx = 0 ;
int dis[N],fadis[N];
void check(int x,int fa) {
	for(int i = h[x] ; i ; i = tr[i].next) {
		int y = tr[i].to,w = tr[i].w;
		if(y != fa) {
			fadis[y] = w;
			check(y,x);
			dis[x] = max(dis[x],dis[y] + w); 
		}
	}
	if(dis[x] + fadis[x] > m) ans ++,dis[x] = 0;
}
int main() {
	cin >> n;
	for(int i = 1 ; i <= n ; i ++) {
		int cnt;
		cin >> cnt;
		for(int j = 1; j <=  cnt ; j ++) {
			int v,w;
			cin >> v >> w;
			add(i,v,w);
			maxx = max(maxx,w);
		}
	}
	cin >> m;
	if(maxx >= m) cout << "No solution.";
	else {

	check(1,1);
		cout << ans;
	}
	return 0;
}
```



---

## 作者：C3H5ClO (赞：3)

我的程序似乎比较短？emmm
```
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;
typedef pair<int,int> pii;
int n,k,x,y,s,f[100001]/*表示某点至少的信号强度*/,ans;
bool bo[100001];
vector<pii> edge[100001];//邻接表，first表示边的终点，second表示边的衰减量
void doit(int x)//树形dp,后序遍历
{
	bo[x]=1; f[x]=1;
	for(int i=0;i<edge[x].size();i++)
		if(!bo[edge[x][i].first])
		{
			if(edge[x][i].second>=s)printf("No solution."),exit(0);//判断No solution
			doit(edge[x][i].first);
			if(f[edge[x][i].first]+edge[x][i].second>s)ans++,f[edge[x][i].first]=1;//当点x至少的信号强度>起点信号强度，就在当前的儿子处放一个红石中继器，此时该儿子只需1的信号强度就可以放大成起点信号强度
			f[x]=max(f[x],f[edge[x][i].first]+edge[x][i].second);
		}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k);
		for(int j=1;j<=k;j++)scanf("%d%d",&x,&y),edge[i].push_back(pii(x,y));
	}
	scanf("%d",&s);
	doit(1);
	printf("%d",ans);
}
```

---

## 作者：hzx360 (赞：2)

前言：感谢管理大大百忙中审核 MnZn 题解。


------------
这是道披着蓝色外衣的水题 QAQ。

由于节点信号不能收两次，所以信号只能从根节点从上往下传。

故有结论：信号放大器肯定越在上面越好。

记录每个点传到叶子的最长距离（即最长链，但后面还要加一，因为信号强度也不能为 $0$），有两种情况（下面 $m$ 表示初始强度）。
    
- **Case1：** 若 $dis_v+w_{u \ to \ v}+1 \le m$
	
    这说明，$v$ 子树内的点可以全到达叶子结点，此时：$dis_u= \max ( dis_u,dis_v+w_i)$。
    
- **Case 2：** 反之
	
    这说明，$v$ 子树内的点全到达叶子结点不能再依赖父亲的信号放大了，此时：$dis_u= \max ( dis_u,w_i)$。即 $v$ 内问题自己解决，在 $v$ 装上放大器（答案加一），而 $u$ 只需保证可以到 $v$ 即可。
    
**注意：** 特判要输出的“No solution.”后面有一个点！


------------

 
### 代码：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+100;
int n,dis[N],m;
int head[N],to[N],w[N],ne[N],tot;
void add(int x,int y,int z){
	ne[++tot]=head[x];
	to[tot]=y,w[tot]=z;
	head[x]=tot;
}
int cnt=0;
void dfs(int u,int fa){
	for(int i=head[u];i;i=ne[i]){
		int v=to[i];
		if(v==fa) continue;
		dfs(v,u);
		if(dis[v]+w[i]+1>m) cnt++,dis[u]=max(dis[u],w[i]);
		else dis[u]=max(dis[u],dis[v]+w[i]);
	}
}
signed main(){
	cin>>n;
	int mx=-1;
	for(int i=1;i<=n;i++){
		int opt;
		scanf("%lld",&opt);
		for(int j=1;j<=opt;j++){
			int y,z;
			scanf("%lld%lld",&y,&z);
			add(i,y,z);
			mx=max(mx,z);
		}
	}
	cin>>m;
	if(m<=mx) return puts("No solution."),0;
	dfs(1,0);
	cout<<cnt;
}

---

## 作者：SLPing (赞：2)

挺好的贪心题。

因为是有根树，所以信息的传递路线是固定的。

令 $k$ 表示从 $1$ 号点出发的信息强度，$dp_i$ 表示传到 $i$ 号点的信号强度最小值，$p_i$ 表示向 $i$ 号点传递信息的边的衰减量。

对于叶子结点 $dp_i=1$,非叶子结点 $dp_i$ 等于其每个儿子的 $dp_j+p_j$ 的最大值。

则当且仅当 $dp_i+p_i>k$，需要在 $i$ 号点安装一个放大器。

注意安装放大器的点 $dp_i=1$。

最后记得特判，如果 $k \le$ 边的最大衰减量，直接输出“No solution.”。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,k,maxn,ans;
int dp[20005],p[20005];
struct dl
{
	int t,p;
};
vector<dl>s[20005];
void dfs(int x,int fa)
{
    dp[x]=1;
	for(int i=0;i<s[x].size();i++)
	{
		if(s[x][i].t!=fa)
		{
			p[s[x][i].t]=s[x][i].p;
			dfs(s[x][i].t,x);
			dp[x]=max(dp[x],dp[s[x][i].t]+s[x][i].p);
		}
	}
	if(dp[x]+p[x]>k)
	{
		ans++;
		dp[x]=1;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int m;
		scanf("%d",&m);
		for(int j=1;j<=m;j++)
		{
			int t,p;
			scanf("%d%d",&t,&p);
			s[i].push_back({t,p});
			maxn=max(maxn,p);
		}
	}
	scanf("%d",&k);
	dfs(1,0);
	if(maxn>=k)
		printf("No solution.\n");
	else
		printf("%d\n",ans);
}
```


---

## 作者：无咕_ (赞：2)

## 题解索引
1. **题目大意**
2.  **Solution**
3.  **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：50

------------

## 题目大意
题面：[<传送门>](https://www.luogu.com.cn/problem/P1269)

题意：给出一棵树，给出树的边权以及根节点点权 $w$ ，并作以下定义：

「信号」：点权。

「衰减量」：边权。

「通信」：改点的「信号」大于 $0$ 。

「传递信号」：从点 $u$ 向 $v$ 传递「信号」。「信号」会减去从 $u$ 至 $v$ 的「衰减量」，并将「信号」剩余值给 $v$ （若「信号」剩余值为负数则 $v$ 的「信号」为 $0$ ），且改点「通信」。

「信号放大器」：将此点的「信号」设置为 $w$ 。


~~术语理解：求一条红石线路最少放几个红石中继器~~

## Solution

首先，我们可以非常简单的知道，此题类型为 **树形DP** 。

所以，我们首先需要一个维护边权的数组，即 ```edge``` ，附带的还有 ```head``` （一维数组，记录点 $i$ 维护的最后一个点）、 ```num_edge``` （变量，记录边的总数）。

然后其附带的 ```add_edge``` 我就不多说了。重点讲 **DP** 。

首先，我们看一下这个题的最优做法。对于一条信号线路来讲，我们不到万不得已的情况下，我们不放信号放大器（即传不到下一个时就放）。此题本来就追求的是最小消耗，那么我们就从最小消耗开始模拟不就行了吗？

那么想到这里，我们也能想出，必须先遍历儿子再遍历父亲，不然的话上来下去非常的麻烦

上面有说过，使一个点通信的必要仅仅只要大于 $0$ ，也就是说只要是 $1$ 就能行。那么儿子的问题解决了，可父亲的呢？如果父亲所需要的能量比儿子的多，那么就证明一定能到儿子那里（因为到自己这里时已经算上了自己到儿子的那条边，所以差只要大于1就行了）；反之则更新。

那么考虑完这些之后，我们还需要考虑一下 ~~红石中继器~~ 信号放大器的放置问题。首先考虑简单的，如果此点没有儿子，则一定不需要信号放大器；如果有，首先要加上儿子所需要的信号放大器数量，然后再判断需不需要（如果需要的话无需再更新儿子结点的权值，因为都已经算过去，百分百能通过了）

再考虑的，就是大家最爱且我也最爱的问题——特例。也就是说不能通信的点。一条边的边权大于 $w$ ，即从 $u$ 到 $v$ 的衰减量大于最大传输量，即为不能传输。

## AC code
首先说下，具体的代码注释我都写在里面了。拒绝抄袭，从我做起（主要懂了就能写出来，没必要抄代码，不然还拿个棕名）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
const int MAX=4e4+9;
struct Edge{
    int to,nxt,w;
}edge[MAX];
int n,k,l,num_edge=0,head[MAX],dis[MAX],zjq[MAX];
void add_edge(int from,int to,int w){
    edge[++num_edge]=(Edge){to,head[from],w};
    head[from]=num_edge;
}void dfs(int s,int fa){
    int myfa;
    bool erzi=0;
    for(int i=head[s];i;i=edge[i].nxt){
        int to=edge[i].to;//儿子结点 
        if(to==fa){ 
            myfa=i;//记录父亲
            continue;
        }if(edge[i].w>=l){//永远无法通过 
            cout<<"No solution."<<endl;
            exit(0);
        }dfs(to,s);//访问儿子节点 
        erzi=1;//有儿子 
        zjq[s]+=zjq[to];//增加儿子结点的红石中继器 
        dis[s]=max(dis[s],dis[to]+edge[i].w);//更新所需能量（如果自己所需的能量比儿子多就不用换 
    }if(!erzi){//有儿子就不用更新 
        zjq[s]=0;//没有儿子证明一定没有额外的红石中继器 
        dis[s]=1;//需要1 
    }else if(s!=1&&dis[s]+edge[myfa].w>=l){//不能是红石块，且能量不够到儿子了，那么要放个红石中继器 
        zjq[s]++;//中继器数量加一 
        dis[s]=1;//需要1
    }
} 
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&k);
        for(int j=1;j<=k;j++){
            int to,w;
            scanf("%d %d",&to,&w);
            add_edge(i,to,w);
        }
    }scanf("%d",&l);
    dfs(1,2147483647);
    cout<<zjq[1];//输出根节点
    return 0;
}
```
AC记录[<传送门>](https://www.luogu.com.cn/record/46054350)

## 类似题型

[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

---

## 作者：孤叶残影 (赞：2)

此题可以这么考虑，

每个点有放与不放两种选择，

对于每次dfs时多传一个当前信号强度，

若大于衰减强度则可以有不放这种情况

（注：即使大于衰减强度，也要考虑放的情况），

~~并且数据很水不会超时~~

## f[i][0]表示不放，f[i][1]表示要放
------------
```cpp
#include<bits/stdc++.h>
#define N 20005
using namespace std; 
int n,head[N],cnt,frist,f[N][2],v[N];
bool flag=true;
struct node{
	int v,next,w;
}e[N<<1];
inline void add_edge(int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].next=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
inline void dfs(int x,int str)
{
	v[x]=1;//表示已经访问（双向边）
	int ant=0;
	for(int i=head[x];i;i=e[i].next)
	{
		if(v[e[i].v]) continue;
		if(e[i].w>=frist)
		{
			printf("No solution.\n");
			flag=false;
			exit(0);
		}
		ant++;
		if(str>e[i].w)//若大于衰减强度则可以有不放这种情况
		{
			dfs(e[i].v,str-e[i].w);//一搜到底在回溯
			f[x][0]=min(f[e[i].v][0],f[e[i].v][1]);
		}
		dfs(e[i].v,frist);//一搜到底在回溯
		f[x][1]=min(f[e[i].v][0]+1,f[e[i].v][1]+1);
	}
	if(!ant)//一个子节点也没有
	{
		f[x][0]=0;
		f[x][1]=1;
		return;		
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int k;
		f[i][0]=f[i][1]=1e9;//初始化
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			int v,ww;
			scanf("%d %d",&v,&ww);
			add_edge(i,v,ww);
		}
	}
	scanf("%d",&frist);
	dfs(1,frist);
	int ans=min(f[1][0],f[1][1]);
	if(flag) printf("%d\n",ans);
	return 0;
}
```


---

## 作者：like1 (赞：2)

贪心+树形结构；

我们设dis[x]表示x子树内到x最深距离。然后从叶子节点开始往上爬，找到一个点，dis[x]+他到他父亲的距离大于初始信号强度，那么这个点需要且必须放一个信号放大器，然后把这个点的dis[x]赋为0. 之后一直按这种只有到不得不放信号放大器的时候才放信号放大器，这样得到的结果就是最优。
```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

const int N=2e4+4;
int First[2*N],Next[2*N],go[2*N],w[2*N],tot;
int dis[N],father[N];
int n,m,k,x,y,z,s,maxn,ans;

inline void add(int u,int v,int c)
{
	Next[++tot]=First[u]; First[u]=tot; go[tot]=v; w[tot]=c;
}

inline void dfs(int u,int fa)
{
	for(int i=First[u];i;i=Next[i])
	{
		int v=go[i];
		if(v!=fa) 
		{
			father[v]=w[i];
			dfs(v,u);
			dis[u]=max(dis[u],dis[v]+w[i]);
		}
	}
	if(dis[u]+father[u]>s) 
	{
		ans++;
		dis[u]=0;
	}
}

int main( )
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			scanf("%d%d",&x,&y);
			add(i,x,y);
			maxn=max(maxn,y);
		}
	}
	scanf("%d",&s);
	dfs(1,1);
	if(maxn>=s) printf("No solution.\n");
	else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Camellia_Spoil (赞：1)

# 题意
给出一棵 $n$ 个节点的树，根节点会发出强度为 $m$ 的信号，信号经过长度为 $w_i$ 的边会衰减 $w_i$，只有强度大于 $0$ 时才有效。

现在可以在一些点上安装信号放大器，可以将传到该点的信号轻度重置为 $m$，求安装最少的放大器的数量。

# 分析
本题是树形 dp。

在不影响下面的覆盖范围时，放大器越往上放越优，可以覆盖到上面的点。

所以我们从叶子向上考虑，设 $f[u]$ 为点 $u$ 到叶子节点的最大距离。我们考虑转移，对于 $u$ 的每一个儿子 $v$，如果 $f[v]+w[u][v]<m$，则 $f[u]\gets\max(f[u],f[v]+w[u][v])$，否则 $f[v]+w[u][v]\ge m$，说明此时 $v$ 的一些子节点将收不到信号，那么在 $v$ 点就要放置一个放大器，此时 $v$ 的子节点已经考虑完毕，$v$ 节点就相当于叶子节点，转移就是 $f[u]\gets\max(f[u],w[u][v])$。

$m$ 为初始信号强度，$w[u][v]$ 为边 $u \to v$ 的长度。

最后考虑无解的情况，通过观察可得，如果其中一条边的长度要大于初始信号强度 $m$，那么就无解。

# AC Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define N 20010
using namespace std;
inline long long read()
{
	long  long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
struct tree{
    int v,w;
};
vector<tree>e[N];//用vector存树 
int ans,n,m,f[N];
void dfs(int u,int fa)
{
    f[u]=0;//初始化 
    for(auto k:e[u])//枚举它的子节点 
    {
        int v=k.v,w=k.w;
        if(v==fa) continue;//如果该点是父亲（说明已走过），则跳出该次循环 
        dfs(v,u);
        if(f[v]+w<m) f[u]=max(f[u],f[v]+w);//状态转移 
        else
        {
            ans++;
            f[u]=max(f[u],w);//统计答案
			 
        } 
    }
}
int main()
{
    int mx=-1;
    n=read();
    memset(f,-1,sizeof(f));//初始化 
    for(int i=1;i<=n;i++)
    {
        int k;k=read();
        for(int j=1;j<=k;j++)
        {
            int x,val;
            x=read();val=read();
            e[i].push_back({x,val});//存图 ，注意存树只存单向，因为在后面读入其它边的时候 ，该树边还会再读入一次 
            mx=max(mx,val); 
        }
    }
    m=read();
    if(mx>=m)//无解情况，上文已解释 
    {
        printf("No solution.");
        return 0;
    }
    dfs(1,0);//树形dp 
    printf("%d",ans);
	return 0;
}
```

---

## 作者：lhz2022 (赞：1)

刚刚打开题目的时候感觉是一道很水的贪心题目。

于是打了一个从上到下的贪心。

[代码（错误）](https://www.luogu.com.cn/paste/etca8ige)

很显然，这是错误的。

以下是一组可以卡掉这种贪心的数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/gk7r2q9s.png)

其中，$\text{信号强度}=5$。

显然当我们从上到下贪心的时候，需要在节点 $4,5,6,7,8$ 建立信号放大器。

但是我们其实可以只在节点 $2$ 建立信号放大器，这样一共只需要建立 $1$ 个放大器即可。

所以我们不妨用另外一种方式贪心，即自底向上（树形 DP）。

设 $dp_i$ 为**以 $i$ 为根的子树时的损耗**，$up_i$ 为**从父节点传到 $i$ 的损耗**。

那么如果 $dp_i+up_i\geq k$，就地建立一个信号站，即：

```cpp
if(dp[u]+up[u]>=k){
	ans++;
	dp[u]=0;
}
```

以下是几个实现易错的细节：

- 建树的时候注意一次建立一条单向边即可，不然会重边。
- 注意大于等于。
- 注意损耗是取最大值。

另外是无解的情况。显然当存在一条边的长度**大于等于**传输强度时就无解。

[代码](https://www.luogu.com.cn/paste/1j9h65hb)

---

## 作者：ncwzdlsd (赞：1)

贪心。

因为信号是从根节点向下传递的，容易想到，信号放大器房放在越高的位置越优。

从叶节点向上更新，累计其到根节点的距离。设 $dis_x$ 表示 $x$ 的子树中最长链的长度。若 $dis_x$ 与它到其父节点的距离小于 $m$，则继续向上更新；否则，累加答案并令 $dis_x=0$，因为每个节点的信号只接受一次，可以避免 $x$ 的子树的部分影响全局答案。

代码如下：

```
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=40005;
int head[maxn],ans,cnt,dis[maxn],len,v[maxn];
struct edge{int to,nxt,w;}e[maxn];

void add(int x,int y,int z){e[++cnt]={y,head[x],z},head[x]=cnt;}

void dfs(int x,int fa)
{
	for(int i=head[x];i;i=e[i].nxt)
	{
		if(e[i].to==fa) continue;
		v[e[i].to]=e[i].w;
		dfs(e[i].to,x);
		dis[x]=max(dis[x],dis[e[i].to]+e[i].w);
	}
	if(dis[x]+v[x]>len) ans++,dis[x]=0;
}

signed main()
{
	int n;cin>>n;
	int mxw=0;
	for(int i=1;i<=n;i++)
	{
		int k;cin>>k;
		for(int j=1,v,w;j<=k;j++) cin>>v>>w,add(i,v,w),mxw=max(mxw,w);
	}
	cin>>len;
	if(mxw>=len) cout<<"No solution.",exit(0);
	dfs(1,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：hehelego (赞：1)



> 给一个边带正权的有根树,选定一些点,其中1必须选.
> 使得除了根之外的每个点向根走长度小于$L$即可遇到关键点.  

## solution

首先判定无解,$\exists e\in E,\text{ s.t. }w(e)\geq L$则无解.否则把所有点都选定即可,每个点到父亲节点的距离小于$L$故存在可行解.

如果$dis(i,\mathrm{root})\geq L$那么$i$与根之间一定有被选中的点,更进一步地存在一个被选中的点,在$i$与根之间,并且与$i$的举例小于$L$.  
我们可以从每个$dis(i,\mathrm{root})\geq L$点$i$向上爬到$g(i)$使得$dis(i,g(i))<L$且$fa(g(i))=\mathrm{root}\lor dis(i,fa(g(i)))\geq L$.  
那么端点为$fa(i)$与$g(i)$的链上面,必须有至少一个选中的点.  

> 经典问题:区间覆盖.  
> 数轴上有一些闭区间,在数轴上放一些点,使得每个区间内都至少有一个点.  
> 
> 一个区间如果有点,那么选右端点可以覆盖更多的区间. 于是只选区间右端点一定不会劣,  
> 按照右端点排序,如果已经被覆盖则跳过,否则选中这个区间的右端点.  

这个做法可以轻松扩展到树上,我们把$[fa(i),g(i)]$按照$dep(g(i))$降序排列,选$g(i)$可以覆盖尽量多其他区间,于是一定不会更劣.  
依次考虑,如果$[fa(i),g(i)]$内有选中的点那么跳过,否则选中$g(i)$.  

只差一步: 判定是否有选中的点,就是这条链上选中的点数目是否大于0,差分一下就是两次求到根的路径上有多少选中的点.  
选中一个点$u$,那么$u$的子树中的所有点的根链上的选中点数量+1.  
于是这转化为区间+1,单点求值,用一个BIT可以解决.  


## code

```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
const int N=20000+10;
struct E{ int v,w; E(int a,int b):v(a),w(b){} };
std::vector<E> g[N];
int n,S0,fa[N],dep[N],pre[N],len[N],L[N],R[N],idx;
struct T{ int from,to; T(int a,int b):from(a),to(b){} };

// 区间加+1,单点求值.  
// 差分以下,就是单点+1/-1,求前缀和.   
int bit[N];
inline int lowbit(int x){ return x&(-x); }
void add(int x,int y){ while(x<=n){ bit[x]+=y; x+=lowbit(x); } }
int qry(int x){ int y=0; while(x){ y+=bit[x]; x^=lowbit(x); } return y; }
inline void put(int x){ add(L[x],1);add(R[x]+1,-1); }
inline int get(int x){ return qry(L[x]); }


std::vector<T> vec;
void dfs(int u,int f){
	L[u]=++idx; dep[u]=dep[fa[u]=f]+1; pre[dep[u]]=u;

// 二分,找到一个深度尽量小的点,使得在这个点与u之间选中一个点u就能收到信号.  
	if(len[u]>=S0){
		int l=2,r=dep[u]-1,mid=0,ans=-1;
		while(l<=r){
			mid=(l+r)>>1;
			if(len[u]-len[pre[mid]]<S0){
				ans=mid; r=mid-1;
			}else l=mid+1;
		}
		vec.push_back(T{u,pre[ans]});
	}
	
	for(const auto e:g[u]) if(dep[e.v]==0){
		len[e.v]=len[u]+e.w;
		dfs(e.v,u);
	}
	R[u]=idx; pre[dep[u]]=0;
}


int main(){
	n=read();int maxval=-1e5;
	for(int i=1;i<=n;i++){
		int k=read();
		for(int j=0;j<k;j++){
			int v=read(),w=read();
			g[i].push_back(E{v,w});
			maxval=std::max(maxval,w);
		}
	}
	S0=read();
	if(maxval>=S0){ puts("No solution."); return 0; }

	dfs(1,0);
	std::sort(vec.begin(),vec.end(),[](auto a,auto b){
		return dep[a.to]>dep[b.to];
	});
	int ans=0; for(auto v:vec){
		// 查询[fa(i),g(i)]内是否已经有选中点.  
		if(get(fa[v.from])-get(fa[v.to])>0) continue;
		ans++; put(v.to);
	}
	std::cout<<ans<<std::endl;
	return 0;
}
```

---

## 作者：rc_Taurus (赞：0)

大家好，我是 rc_Wechis。

[题目传送门](https://www.luogu.com.cn/problem/P1269)

# solution

## 思考

这题的算法已经很明显了吧？非常不加掩饰的贪心。

问题来了，怎么个贪心法？

由于是在树上操作，我们可以从服务器节点出发，DFS 递归计算每个节点到子节点的最大信号强度，并判断是否需要安装放大器。

具体来说，对于每个节点，我们计算其子节点路径的最大信号强度，并判断是否需要安装信号放大器。当信号强度低于某条边的权值时，需要在该节点处安装放大器，以恢复信号强度。

---

以上是有解的情况，怎样判断是否有解呢？

很简单，如果在 $a$ 点装了放大器后依然不能将信号传递至其子节点 $b$ ，就是无解，否则有解。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N=2e4+5;
int n,mx,s;
vector<pair<int,int> >g[N];
int q[N],tot[N],cnt;
void dfs(int x,int fa){
    for(auto i:g[x]){
        int f=i.first;
        int s=i.second;
        if(f==fa)continue;
        q[f]=s;
        dfs(f,x);
        tot[x]=max(tot[x],tot[f]+s);
    }
    if(tot[x]+q[x]>=s){
        cnt++;
        tot[x]=0;
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        int k;
        cin>>k;
        for(int j=1;j<=k;j++){
            int v,w;
            cin>>v>>w;
            g[i].push_back({v,w});
            mx=max(mx,w);
        }
    }
    cin>>s;
    dfs(1,0);
    if(mx>=s)cout<<"No solution.\n";
    else cout<<cnt<<endl;
    return 0;
}
```

## 对 dfs 的解释

- `void dfs(int x, int fa)`：从节点 $x$ 开始进行深度优先搜索，$fa$ 表示 $x$ 的父节点（避免回到父节点形成死循环）。
- `for(auto i:g[x])`：遍历节点 $x$ 的所有邻接节点 $i$，`i.first` 为邻接节点编号，`i.second` 为边的权值（信号衰减量）。
- `if(f==fa)continue;`：如果邻接节点 $f$ 是父节点，则跳过，避免回到父节点。
- `q[f]=s;`：记录从父节点 $x$ 到当前节点 $f$ 的边的权值。
- `dfs(f,x);`：递归调用，继续遍历子树。
- `tot[x]=max(tot[x],tot[f]+s);`：更新当前节点的 $tot[x]$ 值，即从所有子节点到当前节点的最大路径和。
- `if(tot[x]+q[x]>=s)`：如果从子节点到当前节点的信号强度加上从父节点到当前节点的边权值已经不能满足传递条件（即信号衰减到 0 以下），则需要在当前节点安装一个放大器。
- `cnt++;`：安装一个放大器，计数器 $cnt$ 加 1。
- `tot[x]=0;`：安装放大器后，将当前节点的 $tot$ 值重置为 0，因为信号已经被放大。

# 总结

这段代码的核心在于通过深度优先搜索的方式从服务器节点递归遍历整棵树，动态计算每个节点到其子节点的最大信号强度，判断是否需要安装信号放大器，并最终统计最少的安装数量。如果信号衰减大于初始强度，则直接输出无解。

---

## 作者：complicated_world (赞：0)

#第一种：搜索加优化

  f[x][sum]=min(∑f[v][sum-l],∑f[v][res-l]+1)

本人蒟蒻不会判断回路，用的去双向边

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <cstdlib>
using namespace  std;

const int M=100010,inf=20000000;
struct f1
{
  int nx,l,v;
}e[M];
int head[M],i,j,k,n,res,t,ans,u,v,Max;
int b[M];

void zs(int x)//去双向边
{
  b[x]=1;
  if(head[x]==0) return;
  int i=head[x];
  while(i!=0&&b[e[i].v]) 
    i=e[i].nx;
  head[x]=i;
  if(i==0) return; 
  int j=i;
  while(j>0)
  {
    if(b[e[j].v])
    {
      e[i].nx=e[j].nx;
      j=e[j].nx;
    }
    else 
    {
      zs(e[j].v);
      i=j;
      j=e[j].nx;
    }
  }
}

void init()
{
  scanf("%d",&n);
  for(i=1;i<=n;i++)
  {
    scanf("%d",&k);
    for(j=1;j<=k;j++)
    {
      scanf("%d %d",&u,&v);
      if(v>Max) Max=v; 
      t++; e[t].v=u; e[t].l=v; e[t].nx=head[i]; head[i]=t;
    }
  }
  zs(1);
  memset(b,0,sizeof(b));
  scanf("%d",&res);
}

int dfs(int x,int sum)
{
  int j=head[x],Min=inf,tmp=0;
  bool fl=false;
  while(j>0)
  {
    if(sum-e[j].l<=0) { fl=true; break; }
    j=e[j].nx;
  }
  if(!fl)
  {
    j=head[x];
    while(j>0)
    {
      int v=e[j].v;
      tmp+=dfs(v,sum-e[j].l);
      j=e[j].nx;
    }
    if(tmp<Min) Min=tmp;
  }
  if(Min>1)//优化点
  {
    tmp=1;
    j=head[x];
    while(j>0)
    {
      int v=e[j].v;
      tmp+=dfs(v,res-e[j].l);
      if(tmp>Min) break;//优化点
      j=e[j].nx;
    }
    if(tmp<Min) Min=tmp;
  }
  return Min;
}

int main()
{
  freopen("booster.in","r",stdin);
  freopen("booster.out","w",stdout);
  init();
  if(Max>=res)  printf("No solution.\n");
  else  cout<<dfs(1,res)<<endl;
  fclose(stdin);fclose(stdout);
  return 0;
} 
```

#第二种：后序遍历

dfs遍历返回以当前点为根所需的最大信号强度

若当前点与其父节点相连所需的信号强度+dfs(当前点)>能提供的最大信号强度，则ans++(不得不加)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdlib>

using namespace std;
const int MAX=100005;
struct tree
{
 int nx,v,w;
}e[MAX];
int dp[MAX][2],i,j,k,n,m,vv,ww,head[MAX],id,tmp,ans,tmp1;
bool vis[MAX];

void addedge(int u,int v,int w)
{
 id++; e[id].v=v; e[id].w=w; e[id].nx=head[u]; head[u]=id;
}

int dfs(int x)
{
 int i,v,j,w,p,tmp;
 bool flag=true;
 j=head[x];
 while (j!=-1)
  {
   v=e[j].v;
   if (!vis[v])
     {
      flag=false;
      break;
     }
    j=e[j].nx; 
  }
 if (flag) return 1; 
 i=head[x];
 vis[x]=true;
 tmp=-1;
 while (i!=-1)
  {
    if (!vis[e[i].v])
    {
      j=dfs(e[i].v);
      if (j+e[i].w>=m)//*
      {
        j=0;
        ans++;
      }
      if (j+e[i].w>tmp) tmp=j+e[i].w;//更新所需最大信号强度
    }
    i=e[i].nx;
  }
  return tmp;
}

int main()
{
 scanf("%d",&n);
 memset(head,-1,sizeof(head));
 for (i=1;i<=n;i++)
  {
   scanf("%d",&k);
   for (j=1;j<=k;j++)
    {
     cin>>vv>>ww;
     addedge(i,vv,ww);
     if (ww>tmp1) tmp1=ww;
    }
  }
 cin>>m;
 if (tmp1>=m) cout<<"No solution."<<endl;
 else
 {
  memset(vis,false,sizeof(vis));
  dfs(1);
  cout<<ans<<endl;
 }
 return 0;
}
```
程序应该有些bug，大神请不要在意orz。


---


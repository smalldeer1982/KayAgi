# “访问”美术馆

## 题目描述

经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer 知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要 $5$ 秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。假定他回到起点后还需要留至少 $1$ 秒逃跑。

![](https://cdn.luogu.com.cn/upload/image_hosting/7kbyjwgy.png)


## 样例 #1

### 输入

```
60
7 0 8 0 3 1 14 2 10 0 12 4 6 2
```

### 输出

```
2
```

# 题解

## 作者：Dog_Two (赞：37)

~~DP普及-，读入 IOI+~~

```cpp
设f[i,j]表示在结点i，拿了j幅画需要的最少时间；

边界：f[u,i]=i*5(0<=i<=c[u],u是叶子结点)；

目标: max{i}(f[root][i]<tim)；

决策：f[u][i+j]=min{f[lson][i]+f[rson][j]+2*(cost[lson]+cost[rson])}；

	  即在左儿子处偷i件，在右儿子处偷j件的最小消费
```
读入比较麻烦，我们可以按照给定的dfs序进行递归处理（见代码）。
```cpp
#include<bits/stdc++.h>
#define v first
#define w second
using namespace std;
const int maxn=600+10;
int n=1,tim;
int f[maxn][maxn];//在结点i偷到j幅画的最少时间 
int c[maxn];
vector<pair<int,int> >G[maxn];

void read(int u){
	int w,val;
	scanf("%d%d",&w,&val);
	if(val){//处理递归终点 
		G[u].push_back(make_pair(++n,w));
		c[n]=val;
		return;
	}
	G[u].push_back(make_pair(++n,w));
	int v=n;
	read(v); read(v);
	//读入v的两个儿子 
}

void input(){
	cin>>tim;
	read(1);
}

void dp(int u){
	if(G[u].empty()){
		for(int i=0;i<=c[u];++i) f[u][i]=i*5;
		return;
	}
	if(u==1){
		dp(G[u][0].v);
		f[u][0]=0;
		for(int i=1;i<=600;++i) f[u][i]=f[G[u][0].v][i]+G[u][0].w*2;
		return;
	}
	dp(G[u][0].v);
	dp(G[u][1].v);
	for(int i=0;i<=600;++i)
		for(int j=0;i+j<=600;++j){
			//经分析可知，每一层偷到的画不足120幅，这里用不影响效率的充分大数来代替 
			int lw=i?G[u][0].w:0,rw=j?G[u][1].w:0;
			f[u][i+j]=min(f[u][i+j],f[G[u][0].v][i]+f[G[u][1].v][j]+lw*2+rw*2);
		}
}

void solve(){
	memset(f,0x3f,sizeof(f));
	dp(1);
	int ans=0;
	for(int i=1;i<=600;++i) if(f[1][i]<tim) ans=i;
	cout<<ans;
}

int main(){
	input();
	solve();
	return 0;
}

```

---

## 作者：安好 (赞：27)

/\*
基础树形dp   有依赖性背包问题

f[i][j]表示当前节点为i用掉j秒所取得的最大值

转移的时候 如果当前节点是子节点，就判断能取多少

如果不是就枚举当前节点所分配给左树的时间，由左右子树的和转移来。

\*/



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 1001
using namespace std;
int n,cnt,tot;
int f[maxn][maxn];
void dfs()
{
    int root=++cnt,limit,time;
    scanf("%d%d",&limit,&tot);
    limit<<=1;
    if(tot)//子节点 
    {
        for(int time=limit;time<=n;time++)
          f[root][time]=min((time-limit)/5,tot);//判断取多少 
    }
    else
    {
        int left=cnt+1,right;dfs();
        right=cnt+1;dfs();
        for(int time=limit;time<=n;time++)
          for(int lctime=0;lctime<=time-limit;lctime++)//分配给左树的时间 
          {
              f[root][time]=max(f[root][time],f[left][lctime]+f[right][time-limit-lctime]);//左右子树的和 
          }
    }
}
int main()
{
    scanf("%d",&n);n--;
    dfs();
    printf("%d\n",f[1][n]);
    return 0;
}

```

---

## 作者：OHYEP (赞：12)

这道题感觉是树形DP“青春版”

就只用深搜和回溯（回溯的时候干干DP之事）就可以过

遍历到叶子的时候将其特殊处理一下

要注意几点：首先是每条路都要走两次（小偷总不能在管里头过夜），其次是最后一秒（不可以和阿sir撞个满怀）

最后给出代码（详细注解）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int f[100100][610];
int ls[100100],rs[100100];
int t,tot;
void build(int now)//dfs
{
	int x,y;//x代表路径长度
	scanf("%d%d",&x,&y);
	if(y==0)
	{
		ls[now]=++tot;build(ls[now]);
		rs[now]=++tot;build(rs[now]);
		for(int i=x*2+1;i<=t;i++)//从走完这条走廊的时间到最后
		for(int j=0;j<=i-x*2;j++)
//左儿子分配j的时间，右二子分配（i-2*x-j），也就是走完之前的走廊分配给儿子的时间减去左儿子分配到的时间
		f[now][i]=max(f[now][i],f[ls[now]][j]+f[rs[now]][i-2*x-j]);
	}
	else
	{
		for(int i=x*2+5;i<=min(x*2+y*5,t);i++)f[now][i]=(i-x*2)/5;
//这是叶子节点，所以只管偷画（应该可以不用这个min）
		for(int i=x*2+y*5+1;i<=t;i++)f[now][i]=f[now][i-1];
//画不够偷注意补齐喔
	}
}
int main()
{
	scanf("%d",&t);
	build(0);
	printf("%d",f[0][t-1]);
	return 0;
}
```


---

## 作者：Hugo_Minion (赞：12)

最近在学习树形$dp$，这是我第一道没有看题解AC的树形$dp$题（菜鸡
***
## dp状态转移方程
这是一道很经典的树形背包dp，可以说是多重背包，状态转移方程不难想到。  
看到题解里有人设$dp[i][j]$的$j$表示拿的画的数量，这里我用的是经典背包
问题的解法，设$dp[i][j]$为以$i$为根的子树，消耗$j$秒能拿的画的最大值。  
很显然，转移方程：  
$$dp[u][j]=max(dp[u][j],dp[u][j-k-w]+dp[v][k])$$  
$$(w<=j<=min(n,size[u]),0<=k<=min(j-w,size[v]))$$
其中，$v$是$u$的子结点，$k$表示在以$v$为根的子树的时间，$w$是边权，表示从$i$走到$son[i]$需要的时间，$size[i]$表示以$i$为根的子树中边权之和。  
到这里，这道题目的核心内容$dp$式子就解决了，接下来解决一些这道题中比较特殊的问题。  
***
## 读入一颗树  
这道题目的读入方式跟正常的题目不太一样，是用$dfs$序来读入，这需要我们用递归的方式来读入数据。  
对于每个节点，处理两个信息：$time$和$pic$。  
将它的父结点连到它，边权为父结点走到该节点的时间$time * 2$（小偷要来回跑同一条边）。  
对于非$0$的$pic$信息，由于题目说拿每一幅画都需要$5$秒时间，所以不能直接存储为$dp$中的值，于是我改用另一种方法：将每一幅画化为一条边，每有一幅画，就将该叶子节点（展览室）连一条向一个固定的虚拟结点（$0$号节点）的边，边权为$5$，即$add(x,0,5)$，然后设$dp[0][0]=1$就行了。  
最后的答案就是$max(dp[root][i])$，注意$1<=i<n$，因为题面中说“在警察赶来之前”，所以是严格小于。  
虽然这种方法空间复杂度较大（因为要连很多边），但将存边数组开大一点，不会MLE，亲测能过。  
***
## 代码（附注释）  
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int maxn=20005;	//空间开大点 

struct edge{
	int v,w,next;
}e[maxn];
int head[maxn],cnt;

void add(int u,int v,int w){	//存边 
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}

int n,tot,root,ans;
int dp[maxn][maxn];	//dp[i][j]表示以i为根的子树，消耗j秒能拿到的画的最大值 
int size[maxn];

void insert(int x,int fa){	//建图 
	int time,pic;			//上个点走到这个点的时间 ,这个点画的数量 	
	scanf("%d %d",&time,&pic);
	add(fa,x,time<<1);		//将父结点连到该节点 
	if(!pic){			//分成两条路 
		insert(++tot,x);	//tot是结点序号 
		insert(++tot,x);
	}
	else{				//叶子节点 
		while(pic--)		//每有一幅画，连一条边到0号结点 
			add(x,0,5);
	}
}
 
void dfs(int u){
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].v,w=e[i].w;
		dfs(v);
		size[u]+=size[v]+w;
		for(int j=min(n,size[u]);j>=w;j--)	//j秒的时间在u子树 
			for(int k=0;k<=min(j-w,size[v]);k++)  //k秒的时间走到v子树
				dp[u][j]=max(dp[u][j],dp[u][j-k-w]+dp[v][k]);
	}
}

int main(){
	scanf("%d",&n);
	n--;
	root=tot=1;
	insert(++tot,root);	//以root=1为起始节点 
	dp[0][0]=1;
	dfs(root);
	for(int i=1;i<n;i++)
		ans=max(ans,dp[root][i]);
	printf("%d",ans);
	return 0;
}
//树上多重背包 

```
看到这里，不知道你是否已经懂了呢？如果有不懂的地方，可以私信我或者在右边评论哦。

---

## 作者：communist (赞：10)

### $\text{一千个Oier程序中有一千种树形DP}$

思路都差不多的，但是每个人都有自己的状态定义与转移

不妨定义$dp[i][j]$表示，在$i$子树内，偷$j$张画，且不考虑根到$i$父节点路径代价的最短时间

$a[i]$表示$i$与其父节点的距离

$d[i]$表示$i$到根节点的距离

#### 不难想出转移

### $dp[i][j]=min\left\{dp[son1][k]+dp[son2][j-k]+dis[x]\right\}$

#### 统计答案

枚举每个节点选几个，如果$dp[i][j]+d[i]-a[i]<=s$，更新答案

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int size[1010],s,cnt,a[1010],v[1010],e[1010][2],dp[1010][2010],ans,d[1010];
void init(int x)
{
	int t,to;
	if(scanf("%d%d",&t,&to)!=2)
		return;
	d[x]+=2*t,a[x]=2*t,dp[x][0]=0;
	if(to)
		v[x]=to;
	else
	{
		d[++cnt]=d[x],init(e[x][0]=cnt);
		d[++cnt]=d[x],init(e[x][1]=cnt);
	}
}
void dfs(int x)
{
	if(!x)
		return;
	dfs(e[x][0]),dfs(e[x][1]);
	size[x]=v[x]+size[e[x][0]]+size[e[x][1]];
	if(v[x])
		for(int i=1;i<=v[x];i++)
			dp[x][i]=a[x]+dp[x][0]+5*i;
	else
		for(int i=1;i<=size[x];i++)
			for(int j=0;j<=i;j++)
				dp[x][i]=min(dp[x][i],dp[e[x][0]][j]+dp[e[x][1]][i-j]+a[x]);
}
int main()
{
	scanf("%d",&s);
	memset(dp,0x3f,sizeof(dp));
	init(++cnt);
	dfs(1);
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=size[i];j++)
			if(dp[i][j]+d[i]-a[i]<s)
				ans=max(ans,j);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ysj1173886760 (赞：4)

写篇题解压压惊

所有人都在用二叉树遍历只有我用多叉系列。

多叉遍历其实和二叉的遍历是一样的。

这道题就是很裸的树形背包。物品的体积就是时间了，价值就是1.

然后就是裸的树形背包的模板了。

首先dfs子节点。
然后枚举当前节点的体积，枚举子节点的体积。转移即可。

有一点要注意的是当前节点的体积需要倒叙枚举，不然会出错。因为后面的转移过程中用到了前面的，所以可能会用重。

对于叶子节点的处理就是类似01背包把，直接算也可以。

因为本人太蒻不会写二叉的，所以只能写多叉了。其实都一样。

读入的话用递归读就行了。

还有一点要注意的是用的时间要严格小于警察来的时间。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxn=1e4+10;

int tim,num,tot;
int hav[maxn],g[maxn],dp[maxn][610];
struct line
{
	int to,next,w;
}edge[maxn*2];

void add1(int a,int b,int c)
{
	edge[++tot].to=b;
	edge[tot].w=c;
	edge[tot].next=g[a];
	g[a]=tot;
}
void dfs(int cur,int fa)		//读入就不解释了。 
{
	int w=0,x=0;
	scanf("%d %d",&w,&x);
	add1(fa,cur,w*2);
	if(x)
	{
		hav[cur]=x;
		return;
	}
	dfs(++num,cur);
	dfs(++num,cur);
}
void dfs2(int cur)
{
	if(hav[cur])					//计算叶子节点的贡献 
	{
		for(int i=5;i<=tim;i++)dp[cur][i]=min(hav[cur],dp[cur][i-5]+1);
		return;
	}
	for(int i=g[cur];i;i=edge[i].next)//遍历儿子 
	{
		dfs2(edge[i].to);			//先dp儿子 
		for(int j=tim;j>=edge[i].w;j--)	//逆序枚举当前点用到的体积，，逆序的作用和滚动数组一样 
			for(int k=edge[i].w;k<=j;k++)	//枚举儿子的体积。 
				dp[cur][j]=max(dp[cur][j],dp[cur][j-k]+dp[edge[i].to][k-edge[i].w]);//给儿子k的体积，自己还剩j-k，到儿子要先走一条边，所以儿子能用的体积就是k-边权 
	}
}
void print(int cur)
{
	cout<<cur<<" ";
	for(int i=g[cur];i;i=edge[i].next)
		print(edge[i].to);
}
int main()
{
	scanf("%d",&tim);
	dfs(++num,0);		//读入 
	dfs2(0);			//dp 
	cout<<dp[0][tim-1];
	return 0;
}
```

---

## 作者：lych (赞：3)

总的来说，“访问”美术馆是一道比较考察综合能力的题目。

首先，审题是关键。只有读懂了题意，才可能写出正确的程序。可以说，这一道题目的输入是一个亮点。因为它不同于平常的读入，而是用深度优先搜索的方式读入。所以，编程人需要非常熟悉深搜，才可能正确地导入数据。

就算读入了数据，许多同学还是不能把握好。因为这道题目的数据量看似不大，所以有些同学可能会陷入搜索的死胡同。其实本题的数据量还是很大的，因为每条路的走廊也需要时间。所以，会让人没有头绪。

其实，题目已经把条件给的很清楚了，**[color=red]显然，美术馆就是一颗树，而且是一颗二叉树[/color]**。那么，说到二叉树，又说到最优解，那么思路就很明显了——树形动规。


说到树形动规，相信许多同学都有思路了。[u]**只要设f[x,p]表示第x和节点，还有p秒钟时的最优解，转移方程即可**[/u]。注意边界条件。


所以，现在就给出DP的核心代码，输入不再附程序，以便锻炼自己的编写能力。

```delphi

function dp(x,p:longint):longint;  
var  
  i,r,l,s:longint;  
begin    
  if p=0 then  
    exit(0);  //时间为0，显然只能偷到一幅画
  if f[x,p]<>-1 then  
    exit(f[x,p]);  //已经求过值，不再重复。类似于记忆化搜索的思想。不过不写应该也是没事的，只是为了保险而已。
  s:=p-a[x]<<1;  //穿过后还剩下的时间，显然有去有回，时间应*2
  if c[x,1]=0 then  //走到底的情况
    begin  
      f[x,p]:=min(b[x],s div 5); //最有情况为拥有的画和能偷到的画的最小值 
      exit(f[x,p]);  
    end;  
  r:=c[x,1]; l:=c[x,2];  //左节点和有节点
  for i:=0 to s do  
    f[x,p]:=max(f[x,p],dp(r,i)+dp(l,s-i));  //方程转移
  exit(f[x,p]);  
end; 
```

---

## 作者：wffms69_8 (赞：2)


要做好这道题，首先要仔细读题（有两个小坑），我就因为读错了题导致倒数第二个点多偷了一幅画。


《没有上司的舞会》是爆搜就能过的，于是这题我也先写了爆搜，结果40分…





    

```cpp
struct Node {
    int lc, rc, t, p; // 走廊长度，画的数量
    Node(int a = 0, int b = 0, int c = -1, int d = -1)
        : t(a), p(b), lc(c), rc(d) {
    }
} tree[666];
int n(0);
int build(int root) {
    int a, b;
    scanf("%d%d", &a, &b);
    tree[root] = (b ? Node(a * 2, b) : Node(a * 2, b, build(++n),
        build(++n))); // 深搜建树
    return root;
}
int dp(int root, int time) { // dp[i,j]表示用j秒回到i点最多拿几幅画
    if (tree[root].p)
        return std::min((time - tree[root].t) / 5, tree[root].p); // 叶节点
    int maxt(time - tree[root].t),
        ans(max(max(0, dp(tree[root].lc, maxt)), dp(tree[root].rc, maxt)));
    for (int i(0); i < maxt; ++i)
        ans = max(ans, dp(tree[root].lc, i) + dp(tree[root].rc, maxt - i));
    return ans;
}
```
于是我又改成了树形DP，就可以过了


```cpp
void dp(int root) {
    if (tree[root].lc >= 0) {
        dp(tree[root].lc);
        dp(tree[root].rc);
        for (int i(tree[root].t); i <= tot; ++i)
            for (int j(0); j <= i - tree[root].t; ++j)
                f[root][i] =
                    max(f[root][i], f[tree[root].lc][j] +
                f[tree[root].rc][i - tree[root].t - j]);
    }
    else
        for (int i(tree[root].t); i <= tot; ++i)
            f[root][i] = std::min((i - tree[root].t) / 5, tree[root].p);
}
```
这种树形DP是以每一棵子树为阶段，状态一般是二维的，第一维是子树的根节点，第二维是代价，DP值是所求的答案；用记忆化搜索来实现，要先判断是否为叶子节点，决策时要枚举可能的代价分给子树，递归后选取最优方案。

前人之述备矣，然则…

我这种算法会计算一些用不到的状态，但大大减少了递归调用的次数，然而还是比标程慢一些。

写完后发现，建树是后序遍历，DP也是后序遍历，二者的结构有着惊人的相似之处，所以，不用建树！

完整代码：

```cpp
// CodeVS 1163
#include<cstdio>
#include<algorithm>
using std::max;

int tot, n(0), dp[666][666]; // dp[i,j]表示用j秒回到i最多拿几幅画

void dfs(int root) {
    int time, pic;
    scanf("%d%d", &time, &pic);
    time *= 2; // 走廊要走两遍
    if (!pic) { // 如果不是叶节点
        int lc(++n), rc(++n); // 后序遍历
        dfs(lc);
        dfs(rc);
        for (int i(time); i <= tot; ++i)
            for (int j(0); j <= i - time; ++j) // 从去左边j秒，去右边可用时间减j秒
                    dp[root][i] =
                    max(dp[root][i], dp[lc][j] + dp[rc][i - time - j]);
    }
    else
        for (int i(time); i <= tot; ++i)
            dp[root][i] = std::min((i - time) / 5, pic);
}

int main() {
    scanf("%d", &tot);
    dfs(0);
    printf("%d\n", dp[0][tot]);
    return 0;
}
```

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P1270)

## 前置知识

树形DP。

## 题意描述

- 给定一棵树，边权给定，点权给定，问最多在给定值内能拿到多少点权。

# 树形DP

一看是一棵树，这显然又是一个DP，那么就树形DP。

我们得知，走了这条边进去，必要走这条边出来。不妨在建树时，对每个边权乘上2。

首先这题的输入格式跟一般题目不太一样，我们先要学会输入。

我们**递归**进行处理。

每次若第二个数是0，我们递归2次进行加点。

否则给他加权。

建边函数。
```cpp
void build(ll fa){
	n++;
	ll u=0,v=0;
	rd(u);rd(v);
	add(fa,n,u*2);
	ll aa=n;
	if(v==0) build(aa),build(aa);
	else a[n]=v;
}
```

主函数调用部分。

```cpp
	if(v==0) n=2,add(1,2,u*2),build(2),build(2);
	else add(1,2,u*2),n=2,a[2]=v;
```

然后我们一看，~~感觉~~典型的DP问题。（废话）

我们设 $f_{i,j}$ 为走到 $i$ 节点用了 $j$ 单位时间并**走回来**的**最大收益**。

因为每个节点若有儿子必只有**两个**（由题得），我们可以得到转移方程。

$ f_{x,j}=max{f_{x,j},f_{x,j-k}+f_{es[i].t,k-es[i].va}} $

如果我们在叶子节点时，用点权更新 $f$ 数组。

```cpp
for(ll i=5;i<=m;i++) f[x][i]=min(a[x],f[x][i-5]+1);
```


我们就可以从根节点开始递归处理，然后枚举 $j$ 和 $k$，不断更新得出答案。

### 答案有注意点，是 $f_{1,m-1}$，他不能和警察同时。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=605;
ll n,m,tot,hd[N],vst[N],cnt,a[N],f[N][N],ans;
struct edge{ll t,nxt,va;}es[N<<2];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
void add(ll u,ll v,ll w){
    es[++tot]=(edge){v,hd[u],w},hd[u]=tot;
}
void build(ll fa){
	n++;
	ll u=0,v=0;
	rd(u);rd(v);
	add(fa,n,u*2);
	ll aa=n;
	if(v==0) build(aa),build(aa);
	else a[n]=v;
}
void dfs(ll x){
	vst[x]=1;
	if(a[x]!=0){
		for(ll i=5;i<=m;i++) f[x][i]=min(a[x],f[x][i-5]+1);
		return ;
	}
    for(ll i=hd[x];i;i=es[i].nxt)
        if(!vst[es[i].t]){
        	dfs(es[i].t);
        	for(ll j=m;j>=es[i].va;j--)
        		for(ll k=es[i].va;k<=j;k++)
        			f[x][j]=max(f[x][j],f[x][j-k]+f[es[i].t][k-es[i].va]);
		}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(m);
	ll u=0,v=0;
	rd(u);rd(v);
	if(v==0) n=2,add(1,2,u*2),build(2),build(2);
	else add(1,2,u*2),n=2,a[2]=v;
	dfs(1);
	wr(f[1][m-1]);puts("");
	return 0;
}
```

然后你就A了一道蓝题QAQ。

---

## 作者：__gcd (赞：1)

* 写在前面

感冒了不能上课来颓一篇题解qwq

首先这道题是一道很明显的树上背包

如果你还没有听说过树上背包的话，推荐在做这道题目前刷刷[P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)和[P2014 选课](https://www.luogu.com.cn/problem/P2014)

至于不能理解树上背包的话~~这事就不要赖我身上了，说了让你先刷两道题的~~

那么我们就按照一般DP的讨论流程来吧qwq（定义状态、初始化、状态转移）

* 定义状态

这题的状态大概有两种定义方式

1. $dp[i][j]$:以 $i$ 为根的子树用 $j$ 秒的时间最多能偷多少幅画
2. $dp[i][j]$:以 $i$ 为根的子树偷 $j$ 幅画最少要用多少秒

定义的本质区别就是**对背包容量的定义**，看你是用时间还是用画

当然这道题我是用第二种写的

* 初始化

初始化比较简单

首先我们把 $dp$ 赋成极大值

对于叶子节点，偷一幅画就是5秒，那么偷 $i$ 幅就是 $i*5$ 秒

对于偷0幅的。。。~~好善良的小偷~~

* 转移方程

首先我们把树上背包的模板写一遍

```cpp
for(int j = s; j > 0; j--) // 01背包倒序循环，枚举要偷的画数量 
{
	for(int k = 0; k <= t; k++)  // 枚举在儿子结点偷k幅画
	{
            我是状态转移方程;
	}
}
                         
// s:以当前结点为根，最多可以偷的画数量 
// t:儿子结点最多可以偷的画数量
```

因为偷完是要带走的，所以对于每个子树它的终点都是当前子树的根

而且我们要下到儿子结点，边权需要走一遍

儿子结点又要回到父亲阶段，边权又要走一遍

所以这条边权就走了两遍

剩下花费的时间（在当前结点偷 $j-k$ 幅画的时间，儿子结点偷 $k$ 幅画的时间）直接加上就好

所以我们的状态转移方程就出来了

$dp[i][j]=min(dp[i][j],dp[i][j-k]+dp[son][k]+w*2)$

至于基本的01背包和滚动数组优化不要我讲吧

* 最后BB几句

不要抄题解！不要抄题解！不要抄题解！

至于有些人纠结的读入，难道不是直接递归读就可以了吗qwq

* 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int MAX_INT = (1 << 30);
const ll MAX_LONG = ((ll)1 << (ll)60);

struct In
{
	template <typename T>
	inline In& operator >> (T &x)
	{
		char c = getchar();
		int op = 0; x = 0;
		while(c ^ '-' && !isdigit(c))c = getchar();
		if(c == '-')op = 1, c = getchar();
		while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
		if(op)x = -x;
		return *this;
	}
} in; // cin党最爱的快读 

const int N = 110;
const int CNT = 20 * 100 + 10;

struct Edge
{
	int to, w;
};

int seconds, cnt = 1; // seconds:警察到来的时间 cnt：时间戳（其实就是给每个结点一个编号） 
int val[N], dp[N][CNT]; // val[i]:结点i画的数量 dp[i][j]：以节点i为根的子树里面偷j幅画最少时间 
bool leaf[N]; // 判断是不是叶子 
vector<Edge> nbr[N]; // 动态邻接表存图 

void make_subtree(int cur); // 构建一棵子树（输入部分） 

int dfs(int u); // DP 

int main()
{
	memset(dp, 0x3f, sizeof(dp)); // DP设为极大值
	// memset里面0x3f表示把每个字节赋值为3f（0x：16进制），int四个字节，即每个数都为0x3f3f3f3f 
	// 为什么要声明因为本人被memset坑过 
	in >> seconds; 
	make_subtree(1); // 构造一棵以1为根的子树，结点1只有一棵子树 
	// 以上为输入层  
	for(int i = 1; i <= cnt; i++) 
	{
		dp[i][0] = 0; // 偷0幅肯定是0啊qwq 
	}
	int maxi = dfs(1); // DP；maxi:最多能够偷到的画数量 
	for(int i = maxi; i >= 0; i--) // 从最多开始向下枚举所有解 
	{
		if(dp[1][i] < seconds) // 如果在警察来之前可以偷到i幅画 
		{
			cout << i;
			break; // 输出不解释 
		}
	}
	return 0;
}

// 开始写函数
 
void make_subtree(int cur) 
{
	int w, pic; // w：边权 pic：当前节点画的数量 
	in >> w >> pic;
	nbr[cur].push_back((Edge){++cnt, w}); // 有根树建单向边 
	if(pic == 0)
	{
		int boot = cnt;
		make_subtree(boot);
		make_subtree(boot);
		// 如果是0，构建两棵以cnt为根的子树 
        // 注意这里必须定义一个boot，因为cnt会变化
	}
	else 
	{
		val[cnt] = pic; // 记录当前结点画的数量 
		leaf[cnt] = true; // 标记为叶子节点 
		for(int i = 1; i <= pic; i++) // 对DP进行初始化 
		{
			dp[cnt][i] = i * 5; // 偷一幅画5s，不解释 
		}
	}
	return ;
}

int dfs(int u)
{
	if(leaf[u] == true) // 如果它是叶子节点 
	{
		return val[u]; // 返回它有多少幅画 
	}
	int s = 0; // 以当前结点为根，最多可以偷的画数量 
	for(int i = 0; i < nbr[u].size(); i++) // 遍历所有儿子 
	{
		int v = nbr[u][i].to; // 儿子编号 
		int w = nbr[u][i].w; // 边权 
		int t = dfs(v); s += t; // 记录儿子结点最多可以偷的画数量，并累加 
		for(int j = s; j > 0; j--) // 01背包倒序循环，枚举要偷的画数量 
		{
			for(int k = 0; k <= t; k++) // 枚举在儿子结点偷k幅画 
			{
				dp[u][j] = min(dp[u][j], dp[u][j - k] + dp[v][k] + w * 2); // 上面有，转移方程 
			}
		}
		// 树上背包模板，如果不会做我推荐的题目啊，那里也有题解的！！
	}
	return s; // 返回那啥（不想打了qwq） 
}
```

于是就做完了qwq

---

## 作者：ENDKING (赞：1)

刚看到这个题，被输入吓了一跳，于是用 完 全 二 叉 树 建了图，走上了贪心的不归路(  
然而贪心写完才发现不对，于是一怒之下写了个$\text{SimulateAnneal}$(  
然后讲下 *思路*  

首先，很容易就会想到先从入口走到离入口最近的叶子结点，取画，再从小偷所在的叶子结点走到距离最近的叶子结点，再取画，然后在画被取完，或者时间不够了的时候停下，输出结果。  

需要注意的是，到了每个叶子结点，画是肯定要尽量取完的，因为取每张画所需的时间相同，而取到一半去其他叶子结点会在路上产生额外的时间。

关于时间问题，在每个叶子结点时，需要考虑回入口的时间是否充足，所以需要记录下离入口的距离。

然而贪心确实很有问题，样例都过不了(  
所以可以加个模拟退火(  
代码如下(很可能被hack掉(

```cpp
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<iostream>
using namespace std;

bool isV[101];
int s,paintingNode[101],painting[101],tree[550],maxCnt=0,ans=0;
const int K=8;
int fa[550][K+1],faLen[550][K],dep[550];
inline void init(int u,int father){ //要求LCA和树上两点距离的啦,所以要初始化倍增数组 
	fa[u][0]=father;
	faLen[u][0]=tree[u];
	dep[u]=dep[father]+1;
	for (register int i=1;i<=K;++i){
		fa[u][i]=fa[fa[u][i-1]][i-1];
		faLen[u][i]=faLen[u][i-1]+faLen[fa[u][i-1]][i-1];
	}
	return;
}
void readDfs(int u,int father){//建图 
	int a,b;
	init(u,father);
	if (!(cin>>a>>b)) return;
	tree[u<<1]=a;
	if (b==0) readDfs(u<<1,u);
	else paintingNode[++maxCnt]=u<<1,painting[maxCnt]=b,init(u<<1,u);
	if (!(cin>>a>>b)) return;
	tree[(u<<1)|1]=a;
	if (b==0) readDfs((u<<1)|1,u);
	else paintingNode[++maxCnt]=(u<<1)|1,painting[maxCnt]=b,init((u<<1)|1,u);
	return;
}
inline int dis(int x,int y){//求树上两点距离 
	int res=0;
	if (dep[x]<dep[y]) swap(x,y);
	for (register int i=K;i>=0;--i)
		if (dep[fa[x][i]]>=dep[y]) res+=faLen[x][i],x=fa[x][i];
	if (x==y) return res;
	for (register int i=K;i>=0;--i)
		if (fa[x][i]!=fa[y][i]) res+=faLen[x][i]+faLen[y][i],x=fa[x][i],y=fa[y][i];
	res+=faLen[x][0]+faLen[y][0];
	return res;
}
int solve(int a){//贪心 模拟 我枯了( 
	int cur,cost=2147483647,pathCost,res=0,isVCnt=a;
	for (register int i=1;i<=maxCnt;++i){//找离根节点最近的叶子节点并走过去 
		if (isV[i]) continue;
		int temp=dis(1,paintingNode[i]);
		if (cost>temp) pathCost=cost=temp,cur=i;
	}
	isV[cur]=1;++isVCnt;
	for (register int i=1;i<=painting[cur];++i){
		cost+=5;++res;
		if (cost>s-pathCost){//取画的时候要留回去的时间 
			return res-1;
		}
	}
	while (1){
		pathCost=2147483647;
		int tempCur;
		for (register int i=1;i<=maxCnt;++i){//找到离所在叶子最近的叶子然后过去 
			if (isV[i]) continue;
			int temp=dis(paintingNode[cur],paintingNode[i]);
			if (pathCost>temp) pathCost=temp,tempCur=i;
			if (pathCost==temp){//如果有多个距离一样的点，找到离出口最近的 
				int x=dis(1,paintingNode[i]),y=dis(1,paintingNode[tempCur]);
				if (x<y) pathCost=temp,tempCur=i;
			}
		}
		if (isVCnt>=maxCnt) return res;//如果所有的叶子节点都访问过了直接退出 
		cur=tempCur;cost+=pathCost;
		isV[cur]=1;++isVCnt;
		pathCost=dis(1,paintingNode[cur]);//记录回到出口所需时间，为下面的循环做准备 
		for (register int i=1;i<=painting[cur];++i){
			cost+=5;++res;
			if (cost>s-pathCost){
				return res-1;
			}
		}
	}
}
void SA(){//光贪心是不可能的，还要随机化乱搞，这里推荐模拟退火，随机哪些叶子不去 
	const int T=1000;
	int k=1,cur,old=0,isVCnt=0;
	double t=T/log(1+k);
	bool deal[101];
	memset(deal,0,sizeof(deal));
	while (t>1e-3){
		int p=rand()%maxCnt+1;
		deal[p]=!deal[p];
		if (deal[p]) ++isVCnt;else --isVCnt;
		memcpy(isV,deal,sizeof(isV));
		cur=solve(isVCnt);
		if (cur>=old||exp(double(cur-old)/t)/double(RAND_MAX)>rand()) old=cur;
		else {if (deal[p]) --isVCnt;else ++isVCnt;deal[p]=!deal[p];}
		++k;
		if (k<100) t=T/log(1+k);
		else t=T/(1+2*k);
	}
	ans=max(ans,cur);
}
int main(){
	ios::sync_with_stdio(0);
	cin>>s;
	s--;
	memset(tree,-1,sizeof(tree));
	readDfs(1,0);
	srand(19260817); 
	int T=100;
	while (T--) SA();
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：zhutier (赞：1)

~~前面的大佬说，一千个OIER就有一千种树形DP，我觉得很有道理~~

双倍经验指路[P2014选课](https://www.luogu.org/problem/P2014)

**一个提醒，“第二个数”是画的数量不是价值**

~~估计全世界除了我也不会有人栽在这里。。。。~~

什么？二叉树？我听不见————

这是适用于好几叉树的写法（仅针对**DP部分**，读入还是二叉树的）

```cpp
void add(int x,int y,int z){
	en++;
	nxt[en]=head[x];
	head[x]=en;
	to[en]=y;
	w[en]=2*z;//记得要跑回去
}//链表存边（逃
void dfs(){
	for(int i=1;i<=cnt;i++){
		while(k>0&&fa[k][1]==2){
			fa[k][1]=0;	
			k--;	
		}
		fa[k][1]++;
		add(fa[k][0],i,a[i]);
		if(b[i]==0){
			k++;
			fa[k][0]=i;
		}
	}
}
```
把每个“通往两个走廊的走廊”定义为一间**没有画的藏画室**。于是就可以建起一棵树。

读入过程中，0为根节点，连接一条边到第一个（空）藏画室，通过回溯的方式确定每间藏画室的父节点。

具体操作：

用一个计数器（$fa[k][1]$是计数器，$fa[k][0]$是编号）。

当遇到一个新的空藏画室时，$k++$，

当计数器到了2时，$k--$。

```cpp
void ddp(int x){
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		ddp(y);
		for(int j=m;j>=w[i];j--)
			for(int k=j-w[i];k>=0;k--){
			if(j-k-w[i]>=0) dp[x][j]=max(dp[x][j],dp[x][j-k-w[i]]+dp[y][k]);
		}
	}
	if(b[x]!=0)
		for(int j=m;j>=5;j--){
			if(j-b[x]*5>=0) dp[x][j]=dp[x][j-b[x]*5]+b[x];
			else{
				int temp=j/5;
				dp[x][j]=dp[x][j-temp*5]+temp;
			}
		}//在同一个地方拿尽可能多的画一定比疯狂走路强
} 
int main(){
	scanf("%d",&m);	
	while(cin>>a[cnt]>>b[cnt]) cnt++;
	cnt--;
	m--;
	dfs();
	ddp(0);
	printf("%d",dp[0][m]);
	return 0;
} 
```

---

## 作者：abc123_abc123 (赞：0)

今天我们来学习treedp。treedp，就是在tree（树）上做DP。DP？不卡空间时，DFS=DP。于是我们开心的开始了DFS。

### 1. 用先序遍历建树。

它大概长这样：

```cpp
inline void dfs()
{
	len++;
	int now=len;
	scanf("%d%d",&a[now].val,&a[now].bj);
	a[now].val*=2;	//要走回去一遍，相当于两倍
	if(a[now].bj==0)
	{
		a[now].c[0]=len+1;
		dfs();
		a[now].c[1]=len+1;
		dfs();
	}
}
```

### 2. treedp 走起。

做法：treedp(now,val)表示第now个节点有val的时间能get到多少幅画。如果now是叶子节点（即展室），就偷画；如果now是过道岔路口，就用i从1到val枚举一条过道的时间分配，另一条过道就是val-i，继续搜下去，返回最多能偷到画的数目。

总的时间复杂度 O(n*s)，还是能过的。

~~那不是和其他题解的一样？~~

### 3.优化时间分配。

 **重点来了！** 我们发现很多的时间浪费在了枚举岔路口 **两条过道的时间分配** 上，例如有种情况左边过道给100时间最多3幅画，给16时间还是3幅画。
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/6c8db803.png)
 
 所以每次返回时可以多返回一个值p表示有多少空余时间，在分配时利用p进行优化。

但是我们发现为了选到每一种情况，只能把1~val枚举其中一条路优化成一次跳一小段，不能两边都跳，否则可能会这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/0a2901ug.png)

所以我们优化一条过道就好了，记得搜完要减一进入下一种情况，处理细节要小心。

在过道很多时这个方法其实也没有优化多少，优化力度最大的还是连接叶子节点的过道。总的时间复杂度 < O(n*s)。

update:

优化真的强！补上不用map的代码（[无O2] 13ms）：

```cpp
#include<cstdio>
using namespace std;
int s,len,k;
struct node{
	int val,c[2],bj;
}a[410];
inline void dfs()
{
	len++;
	int now=len;
	scanf("%d%d",&a[now].val,&a[now].bj);
	a[now].val*=2;
	if(a[now].bj==0)
	{
		a[now].c[0]=len+1;
		dfs();
		a[now].c[1]=len+1;
		dfs();
	}
}
bool mbj[210][610];
int mpv[210][610];
int mpp[210][610];
inline int mins(int a,int b)
{
	return a<b?a:b;
}
inline int treedp(int now,int val,int &p)
{
	if(mbj[now][val]==1){
		p=mpp[now][val];
		return mpv[now][val];
	}
	p=val;
	if(val<=0){return 0;}
	int u1,ans=0,up,u;
	if(a[now].bj!=0){
		u1=mins(val/5,a[now].bj);
		p=val-u1*5;
		return u1;
	}
	u1=val;
	ans=treedp(a[now].c[0],val-a[a[now].c[0]].val,p);
	while(u1>=0)
	{
		if(u1==0)
		{
			u=treedp(a[now].c[1],val-a[a[now].c[1]].val,up);
			if(u>ans)
			{
				ans=u;
				p=up;
			}
			break;
		}
		u=treedp(a[now].c[0],u1-a[a[now].c[0]].val,up);
		if(u<=0)
		{
			u=u1=0;continue;
		}
		u1-=up;	//优化所在
		u+=treedp(a[now].c[1],val-u1-a[a[now].c[1]].val,up);
		if(u>ans)
		{
			ans=u;
			p=up;
		}
		u1--;	//记得减一
	}
	mbj[now][val]=1;
	mpp[now][val]=p;
	mpv[now][val]=ans;
	return ans;
}
int main()
{
	scanf("%d",&s);
	dfs();
	printf("%d",treedp(1,s-1-a[1].val,k));	//减去进入时间，还要减一（题目坑点所在）
	return 0;
}
```

 吐槽一句：给出警察赶 **到** 的时间是真的坑，要在警察来之 **前** 逃离。

---

## 作者：liumingchen (赞：0)

一个有趣的树形动规。。。。

注意可以不把一个展厅的画取完，害的我找了半天的错。。

可以在每个叶节点（非展厅）把剩余时间与偷的画的数量记录下来

附上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
struct qe
{
    int is,t,fa,l[3],r;
}map[1000];
int n=1,ti;
int qw[103][603];
int we(int a,int b)
{
    if(b>a) return a;
    return b;
}
int work(int a,int time)
{
    if(qw[a][time]!=-1) return qw[a][time];    
    if(map[a].is!=0)
    if(map[a].t<=time) 
    {qw[a][time]=we(map[a].is,(time-map[a].t)/5);
    return qw[a][time];
    }
    else 
    {qw[a][time]=0;
    return 0;
    }    
    if(time-map[a].t<=0) return 0;
    time-=map[a].t;
    int l=map[a].l[1],r=map[a].l[2];
    int max=0;
    for(int i=0;i<=time;i++) 
    {
        int t1,t2;
        t1=work(l,time-i);
        t2=work(r,i);
        if(t1+t2>max) max=t1+t2;    
    }
    qw[a][time+map[a].t]=max;
    return max;
}
int main()
{
    int i,j,k;
    scanf("%d",&ti);
    for(i=1;;i++)
    {
        scanf("%d%d",&map[i].t,&map[i].is);
        map[i].r=1;
        if(i!=1)
        {
            for(j=i-1;j>=1;j--)
            {
                if(map[j].is==0&&map[j].r!=3)
                {
                    map[i].fa=j;
                    map[j].l[map[j].r]=i;
                    map[j].r++;
                    break;
                }
            }
        }
        int p=1;
        for(j=1;j<=i;j++) if(map[j].r!=3&&map[j].is==0) p=0;
        if(p==1) break;
    }
    n=i;
    for(i=1;i<=n;i++) 
    {
        map[i].t*=2;
    }
    for(i=1;i<=n;i++)for(j=0;j<=ti;j++) qw[i][j]=-1;
    int ans;
    ans=work(1,ti);    
    printf("%d",ans);    
    return 0;
}
```

---


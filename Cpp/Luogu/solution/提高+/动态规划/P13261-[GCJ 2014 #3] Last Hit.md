# [GCJ 2014 #3] Last Hit

## 题目描述

Diana 需要你的帮助，在她最喜欢的游戏中尽可能赚取更多金币。她经常会遇到这样一种情况：她站在自己的防御塔附近，面对着 $\mathbf{N}$ 个怪物。在这种情况下，Diana 和防御塔轮流攻击怪物，且 Diana 先手。在她的回合中，Diana 可以选择攻击任意一个怪物（也可以选择跳过回合）；在塔的回合中，塔会攻击距离它最近的存活怪物。

Diana 和塔都不能攻击已经死亡的怪物。

如果 Diana 攻击了某个怪物，则该怪物的生命值会减少 $\mathbf{P}$；如果塔攻击怪物，该怪物的生命值会减少 $\mathbf{Q}$。当怪物的生命值降到小于 1 时，它会被击杀。如果是 Diana 击杀了第 $i$ 个怪物，她将获得 $\mathbf{G}_{\mathrm{i}}$ 金币；如果是塔击杀了怪物，Diana 不会获得金币。

第 $i$ 个怪物初始生命值为 $\mathbf{H}_{\mathrm{i}}$。

怪物按照它们距离防御塔的远近顺序给出，也就是说，塔只有在编号小于 $i$ 的怪物都死亡之后，才会攻击第 $i$ 个怪物。

请你计算，Diana 最多可以获得多少金币？

## 说明/提示

**样例说明**

在第二个样例中，Diana 应该放弃第一个怪物。她应在前两个回合中攻击第三个怪物，将其生命值削减至 80 点，然后她就可以轻松地拿到对第二个和第三个怪物的最后一击，从而获得两者的金币奖励。

## 限制条件

- $1 \leq T \leq 100$
- $20 \leq \mathbf{P} \leq 200$
- $20 \leq \mathbf{Q} \leq 200$
- $1 \leq \mathbf{H}_{\mathrm{i}} \leq 200$
- $0 \leq \mathbf{G}_{\mathrm{i}} \leq 10^6$

### Small 数据集（10 分）

- 时间限制：~~60~~ 3 秒
- $1 \leq \mathbf{N} \leq 4$

### Large 数据集（14 分）

- 时间限制：~~120~~ 5 秒
- $1 \leq \mathbf{N} \leq 100$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2
20 40 3
100 100
20 100
60 100
20 60 3
80 100
80 200
120 300```

### 输出

```
Case #1: 300
Case #2: 500```

# 题解

## 作者：imnotcfz (赞：2)

# P13261 [GCJ 2014 #3] Last Hit 题解

本文是对官方题解的进一步解释。

## 0x01 分析

根据题意，Diana 每轮都可以射击任意怪物或者跳过，而防御塔每轮都会射击最近的怪物。

我们可以把 Diana 的行动分为三类：**射击防御塔的目标、射击非防御塔的目标和跳过回合**。

为什么这么分呢？实际上，我们可以这么想，若 Diana 射击**防御塔的目标**，没有死透的话，人头可能是防御塔的。而 Diana 射杀了**非防御塔的目标**，人头一定是 Diana 的。

所以 Diana 什么时候射击其实**并不重要**，重要的是**它是不是防御塔的目标**。所以 Diana 射击非防御塔的目标时，我们可以暂时不管它，把这发子弹存起来，接下来的回合中**随时都可以打出去**（也可以连发）。

## 0x02 解法

我们考虑 DP。

### 阶段

**防御塔当前的目标**。

根据题意，怪物的距离是**递增**的，所以这个数值也是从 $1$ 到 $N$ **递增**的。

### 状态

**当前怪物的剩余血量**和 **Diana 存下来的子弹数量**。

于是我们可以给出 DP 数组的定义：$dp_{i,j,k}$ 表示防御塔的目标为第 $i$ 个怪物，这个怪物剩余血量为 $j$，Diana 还有 $k$ 发子弹时，能获得的最大金币数。

### 转移

由于转移顺序较为复杂，且状态较多（见下文「实现」），这里考虑使用**记忆化搜索**。

- 若怪物已经死亡，则转移到下一个怪物。

- 若 Diana 有子弹，则可以选择打或不打。打，则将怪物血量减去 Diana 的伤害 $P$，子弹数量减一。

- 否则只能由防御塔进行攻击，怪物血量减去防御塔的伤害 $Q$，子弹数量加一。

综合一下，可以得到：
$$
dp_{i,j,k}=
\begin{cases}
dp_{i+1,H_{i+1},s} & j \le 0 \\
\max\{dp_{i,j-Q,k+1},dp_{i,j-P,s-1}+G_x[j\le p]\} & j,k>0 \\
dp_{i,j-Q,k+1} & \text{otherwise.} \\
\end{cases}
$$

### 答案

$dp_{1,H_1,1}$ 即为所求，从第 $1$ 个怪物开始，初始血量为 $H_1$，由于 Diana 先手，初始有 $1$ 发子弹。

## 0x03 实现

显然 DP 数组的前两维大小分别为 $N$ 和 $H_{max}$，第三维的大小为怪物的最大总血量比去 Diana 的伤害（即 $\displaystyle\frac{NH_{max}}{P}$）。则空间复杂度为 $\displaystyle O(\frac{N^2H_{max}^2}{P})$，也就是说数组要开 $100\times200\times1000=2\times10^7$ 个 int，可以接受。

俗话说得好：

> $\Large\text{Talk\ is\ cheap, show\ me\ the\ code.}$

```cpp
// 记忆化搜索
// 参数分别对应 dp 数组的三个维度
// x - 当前防御塔目标
// hp - 怪物剩余血量
// shots - 剩余子弹数量
int dfs(int x, int hp, int shots) {
  // 边界条件1：最后一个怪物被杀死
  if (hp <= 0 && x >= N) {
    return 0;
  }
  // 边界条件2：当前怪物被杀死
  if (hp <= 0) {
    return dfs(x + 1, H[x + 1], shots);
  }
  // 若已经计算过则直接返回，防止重复计算
  if (dp[x][hp][shots] != 0x80808080) {
    return dp[x][hp][shots];
  }
  // 无论 Diana 有无子弹，防御塔都可以进行攻击
  int res = dfs(x, hp - Q, shots + 1);
  // 若 Diana 有子弹，则可以选择打或不打
  if (shots > 0) {
    if (hp <= P) {
      res = max(res, dfs(x, hp - P, shots - 1) + G[x]);
    } else {
      res = max(res, dfs(x, hp - P, shots - 1));
    }
  }
  // 返回的同时记录答案
  return dp[x][hp][shots] = res;
}

// 初始化为极小值
memset(dp, 0x80, sizeof(dp));
cout << "Case #" << t << ": " << dfs(1, H[1], 1) << endl;
```

[提交记录](https://www.luogu.com.cn/record/225826394)

---


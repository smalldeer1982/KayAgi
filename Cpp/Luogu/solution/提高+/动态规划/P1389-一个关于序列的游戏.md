# 一个关于序列的游戏

## 题目描述

有一个序列，你可以在上面删除符合要求的连续段若干次。每次删除都会得到连续段长度对应的分数。

需要符合的要求为：

1. 相邻两个元素相差为 $1$。
2. 如果某个元素不在连续段的最左或最右，那么这个元素就不能同时小于相邻的左右两个元素。

$[1,2,3,4,3],[1,2],[3,2],[3]$ 都符合条件。

显然，删除掉连续段后，这个段的左边和右边并在一起成为相邻元素。

你的任务是对于给出的序列，计算出可能获得的最大总分。

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据 $,N \le 3$；
- 对于 $40\%$ 的数据 $,N \le 10$；
- 对于 $70\%$ 的数据 $,N \le 70$；
- 对于 $100\%$ 的数据 $,1 \le N \le 150$，$-10000 \le V_i \le 10000$，$0 \le A_i \le 1000000000$。相同的 $A_i$ 不会超过 $14$ 个。

## 样例 #1

### 输入

```
6
-100 5 6 10 0 0
3 1 2 3 4 10
```

### 输出

```
11
```

# 题解

## 作者：qjyzLfy (赞：25)

## 前言

1. 作者很菜，于是他假定**部分**读者和他一样菜，因此写得既详尽又冗长。

1. 若无特殊强调，本题解中的“连续”一般是指位置上而非数值上的连续。

1. 输入格式中的 $V_i$ 和 $A_i$ 在文中分别记为 $val_i$ 和 $num_i$ 。

1. 本题解设置了多层标题，建议读者跳过已理解的部分。

## 分析

题意：有一个正整数数列，每次消去**连续的**一段合法的数字，得到这段数字长度对应的分数。数列不必全部消去，求最终得分的最大值。其中“合法”，是指数字可分为恰有一个数重合的前后两段（每一段长度可为 $1$ ），前一段以 $1$ 为公差递增，后一段以 $-1$ 为公差递减。

这样的题目应该是用区间动规。

由于消去一些数字必须先使之连续，也就是必须先消去这段数字中间的所有数字，计算**部分消去**某段区间的最大得分就不太可行，因为转移时难以判断两个数字在什么条件下连续。所以更可行的办法计算**完全消去**一段连续区间的最大得分，记为 $ans_{l,r}$ 。

最后为了得出**部分消去**整段数列的最大得分，可对数列进行划分，直到每一段区间要么**全部**都被消去，要么**全部**都未被消去为止。这显然是可行的。

#### 动规转移

消去某段区间时，只有两种可能：一次性消去，或分步消去。

若分步，则必有最后一步。这是绝大多数动规的突破口。

最后一步是消去“连续”的一段数字，而这段数字初始时不一定连续，所以其空缺处的数字都已经被消去了。当然，这些空缺都构成连续区间，而且彼此独立。

所以可以枚举最后一步消去的数字，然后计算被这些数字隔离出的所有连续区间的 $ans$ 值之和，再加上消去数字的得分。其最大值就是当前计算的区间的 $ans$ 值。

#### 计算答案

现在要由**完全消去**某区间的得分的最大值，得出**部分消去**某区间的得分的最大值。可以用一个简单的动规。

一段区间，在最优方案下，除非它被完全消去，否则就可以被找到一个未消去的点 ~~（废话）~~。从这个点处（左边或右边）把区间分成两段，两段各自按最优解处理，就可以得到当前处理区间的最优解。所以只要枚举“断点”，就可以由小区间最优解得到大区间最优解了。

## 实现

#### 在完全消去时（第一次动规）：

无疑，转移时枚举消去的数字要靠搜索。为避免一个点一个点地找**数值上**相邻的数字（那样又难写又慢），可以使用（假）指针标记相邻数字。

这是就会发现可消情况可以表示为两棵树。把数列中的数视为点，为了使能一同消去的点连通，只需使让一棵树中每个点连接数值比它大 $1$ 的点，让另一棵树中每个点连接数值比它小 $1$ 的点即可。当然，这两棵树应该是单向的（从左到右或从右到左）。

现在我们有两种选择。

1. 最高点作根。向左向右分别建一棵下降的树。使用时分别在两棵树上搜索。

2. 最右边的点作根。向左建一颗向上的（即上升的，下同）树和一颗向下的树。使用时先在向上的树上搜索，并在每个子节点处尝试转换到向下的树上继续搜索。（当然从左边来也行）

显然方案 $1$ 搜索的深度更小，因此似乎应该更快。但考虑具体操作就会发现，搜索时无法立即确定消去的数字的长度，因为左右两边相互独立。因此，也就无法确定最优解。所以选择方案 $2$ 。

- 建树

数据范围很小，不妨枚举。第一个比当前点数值大 $1$ （小 $1$ ）的点为向上（向下）的树中当前点的长子，第一个与当前点数值相同的点为当前点的兄弟（两棵树中兄弟的情况是一样的，可以共用）。

- 动规的转移

假设待处理区间为 $[l,r]$ ，简记为 $S$ ， $ans_{l,r}$ 表示处理相应区间的最大得分。

在 $S$ 内枚举根节点 $t$ 开始搜索，每搜索到一个点，判断当前得分（即最后一步要消去的数到此为止，后面的数不再被消去时的得分，**下同**）是否大于当前区间的得分。然后，如果是在向上的树上，就搜索其向上和向下的子节点，搜到向下的子节点时进入向下的树；如果是在向下的树上，就只搜索向下的子节点。直到子节点在 $l$ 左边为止。（子节点不存在时将搜到 $0$ ，而 $0<l$ 。）

其中，当前得分的计算方法是：用一个参数 $red$ 记录消去数列中间空缺区间的得分。从父节点 $f$ 进入子节点 $s$ 时， $red_{s}=red_{f}+ans_{s+1,f-1}$ 。再用一个参数 $len$ 记录搜索到当前节点时消去数字的长度，最后 $p$ 点的当前得分就是 $red_{p}+ans_{l,p-1}+val_{len}$ 。显然要把根节点 $t$ 处的 $red$ 初始化为 $ans_{t+1,r}$ 。

为方便处理中间的区间为空（即消去的数字原本就连续，或者消去的数字和端点 $l,r$ 连续）的情况，令 $ans_{i+1,i}=0$ 。

#### 在部分消去时（第二次动规）：

这一步并不是复杂度的主要来源，可以无脑一些。下面用 $ans'_{l,r}$ 表示部分消去区间 $[l,r]$ 的最大得分。（读下一句话时请注意每个 $ans$ 右上角有没有 $'$ 。）

先把单个点的最大得分 $ans'$ 初始化，即 $ans'_{i,i}=max\{ans_{i,i},0\}$ ，然后计算 $ans'_{l,r}$ 时枚举断点 $t$ ，令 $ans'_{l,r}=max\{ans_{l,r},ans'_{l,t}+ans'_{t+1,r}\}$ 即可。

因为 $ans'$ 是在 $ans$ 的基础上与多个数比较取最大值得来的，可以直接用新最大值覆盖在原来的 $ans$ 上，不用定义新变量还省了初始化。

## 优化

优化当然是针对复杂度最大的第一次动规进行的，特别是针对其中的搜索进行的。

#### 优化 1 ：剪枝

搜索到一个点时，如果可以确定，不管接下来的情况再怎么顺利，都不能得到更优解，就可以剪枝了。

而最理想的情况应该是接下来所有点都连续的情况。因为这时可以绝对自由地选择消去方法。所谓“自由”是因为决定得分的只是每次消去的区间的长度，而所有长度“分配”方式现在都可以做到。

但即使如此依然有很多选择，而现在需要直接找到最优的一种。

按照游戏的正常逻辑，直接把一个长为 $k$ 的合法区间消去，应该比把它拆分为两个短的区间再消去要优。否则，所有长为 $k$ 的合法区间都可以这样拆分，就永远不会有消去长为 $k$ 的区间的操作了。

但是出题人未必如此出题。不过，既然所有长度为 $k$ 的区间都可以这样拆分，就用拆分后的得分代替原得分好了。即 $val'_{k}=max\{val_{k},val'_{t}+val'_{k-t}\}$ 。这一步要对所有的 $k$ 由小到大处理一遍。

这样做相当于把所有消去区间连续的消去操作“合并”了，所以不影响正确性。

在此基础上，消去一段连续合法数字的最优方法一定是直接一步消去，最理想情况下的最大得分也就是直接一步消去的得分了。

具体来说，对于区间 $[l,r]$ ，搜索到 $t$ 点时。假如 $ans_{l,r} \ge red_{t}+val_{len+t-l}$ ，就可以剪枝了。

现在，可以搜到一个点时剪枝（就是上面的写法），也可以在将要搜索某个点之前就判断并剪枝。后面一种策略避免了进入下一级函数，因而更快。相应判别式略。

#### 优化 2 ：省略

还记得搜索前需要枚举起点 $t$ 。而如果最后一次消去的区间右端点为 $t$ ，那么 $t$ 右边的连续段（不含 $t$ ）和左边的连续段（含 $t$ ）必然是各自独立地消去的。因为其它消去操作不可能跨过 $t$ 而消去其两边的数字。这时就可以直接用两段相加来代替搜索。即 $ans_{l,r}=max\{ans_{l,t}+ans_{t+1,r},ans_{t=r}\}$ 。

$t=r$ 时还是要搜索的。因为此时 $t$ 并没有把区间 $[l,r]$ 分成两段。

#### 优化 3 ：再次剪枝

与“省略”类似地可以推出，唯一值得搜索的最后一步消去，不但一定要始于 $r$ ，而且一定要终于 $l$ 。

向上搜索到 $t$ 时，只有在 $num_t>num_l$ 时才转入向下的搜索。只有 $t=l$ 时才将当前得分与 $ans_{l,r}$ 进行比较。这时当前得分为 $red+val_{len}$ 。

向下搜索到 $t$ 时，如果 $num_t=num_l+1$ ，直接连向 $l$ 。这样则不会出现 $num_t \le num_l$ 的情况。

#### $O_{2}$ 优化

如题。

## 代码

```cpp
#include <cstdio>
#include <algorithm>
#define LL long long
#define oo 0x3f7f7f7f
using namespace std;

const int nma=155;
int n,val[nma],num[nma];//输入 
int dso[nma],uso[nma],bo[nma];//树 
int ans[nma][nma];//意义同题解 
int i,j,l,r,d,t;


void dsea(int t,int len,int red){//向下搜索 
	if(num[t]==num[l]+1){//剪枝 2 
		ans[l][r]=max(ans[l][r],red+val[len+1]+ans[l+1][t-1]);
		return;
	}
	for(int ion=dso[t];ion>=l;ion=bo[ion]){
		if(red+ans[ion+1][t-1]+val[len+1+ion-l]>ans[l][r])//剪枝 1 
			dsea(ion,len+1,red+ans[ion+1][t-1]);
	}
	return;
}

void usea(int t,int len,int red){//向上搜索
	if(t==l)	ans[l][r]=max(ans[l][r],red+val[len]);
	for(int ion=uso[t];ion>=l;ion=bo[ion]){
		if(red+ans[ion+1][t-1]+val[len+1+ion-l]>ans[l][r])//剪枝 1
			usea(ion,len+1,red+ans[ion+1][t-1]);
	}
	if(num[t]>num[l]){//剪枝 2
		if(num[t]==num[l]+1){//剪枝 2
			ans[l][r]=max(ans[l][r],red+val[len+1]+ans[l+1][t-1]);
			return;
		}
		for(int ion=dso[t];ion>=l;ion=bo[ion]){
			if(red+ans[ion+1][t-1]+val[len+1+ion-l]>ans[l][r])
				dsea(ion,len+1,red+ans[ion+1][t-1]);
		}
	}
	return;
}

int main()
{
	//freopen("1.in","r",stdin);
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			ans[i][j]=-oo;//第一次动规时ans有负值. 
	for(i=1;i<=n;i++){
		scanf("%d",&val[i]);
		for(t=1;(t<<1)<=i;t++)	val[i]=max(val[i],val[t]+val[i-t]);
		ans[i][i]=val[1];
		ans[i+1][i]=0;
	}
	ans[1][0]=0;
	for(i=1;i<=n;i++){
		scanf("%d",&num[i]);
		for(j=i-1;j;j--)
			if(num[j]==num[i])	{ bo[i]=j; break; }
		for(j=i-1;j;j--)
			if(num[j]+1==num[i])	{ dso[i]=j; break; }
		for(j=i-1;j;j--)
			if(num[j]==num[i]+1)	{ uso[i]=j; break; }
	}
	//以上为读入,ans初始化,建树. 
	
	for(d=1;d<n;d++){
		for(l=1,r=l+d;r<=n;l++,r++){
			for(t=l;t<r;t++){
				ans[l][r]=max(ans[l][r],ans[l][t]+ans[t+1][r]);
			}
			usea(r,1,0);
		}
	}
	//以上为第一次动规 
	
	for(i=1;i<=n;i++)
		if(ans[i][i]<0)	 ans[i][i]=0;
	for(d=1;d<n;d++){
		for(l=1,r=l+d;r<=n;l++,r++){
			for(t=l;t<r;t++){
				ans[l][r]=max(ans[l][r],ans[l][t]+ans[t+1][r]);
			}
		}
	}
	//以上为第二次动规 
	
	printf("%d",ans[1][n]);
	return 0;
}
```

## 后记

#### 后记的前言

本后记为作者做本题的体会，供萌新为鉴，如果您觉得此题难度一般，则本后记对您应该没有任何帮助。如果您觉得此题难度只是**有一点**难，则建议您跳过“后记的正文”。

#### 后记的正文

做本题之前，我接触过的区间动规仅限于由小区间推出其合并而成的大区间。因此刚做到本题时，我觉得因为子区间中消去一些数字后剩下的数不连续，根本无法表述，因此也无法动规。尝试搜索无果后我毫不犹豫得点开了题解。（这里我犯的错误很明显：从第一步而不是最后一步开始考虑。）

然而当时还没有题解，于是我只好自己想。一开始我依然是考虑第一步。而且居然还有结果。我当时想到的是，把消去的中间一段两端剩下的点叫断点，后续消去操作中，如果不把断点一同消去，则用消去了其中一个断点的操作扩大中间的消去段，否则利用断点被一同消去的这次操作扩大中间的消去段。直到中间消去段不可扩大为止。但是消去段不可扩大的条件被我想得太简单了。

但是这个过程启发我想到了把目标区间中间的区间拿出来，使拿出的部分和剩下的部分都可算。于是最后终于想到了没有任何优化的半正确算法。（70分）

第一个优化，是把最理想的情况单独看成一项任务，重新考虑而想到的；第二个优化，把某一次搜索的情况画成个图，看看就想到了；第三个优化自然也就跟着想到了。

实际上，本题在我的任务栏里停了一个月，而实际做题大概用了四天。

#### 后记的后记

一些心得，美芹之献。

1. 有时候我们觉得完全没办法，其实是没有深入地思考，或者说没有思考的起点。这时候把目前能思考到的最后一步的情况详细描绘出来，从每一个最细微的局部去作考虑，有可能取得进展。

1. 区间动规中，合并小区间并不是得到大区间的唯一方法，但一般是最好的方法。

1. 常数优化的效果可能是惊人的。


---

## 作者：Link_Cut_qwq (赞：10)

我们发现这题每次只能取连续段，很像区间 *dp*，于是往这方面脑补，结果还是不会（悲）。

其实这题的确是区间 *dp*，作者觉得这题真特难想（作者很菜，如有意见请勿喷）。

+ 最暴力做法

先不着急求**可取部分**的情况，先把**全部取完**的情况求出来再通过**全部取完**转移成**可取部分**

我们用 $f_{l,r}$ 表示**全部取完** $l$ 到 $r$ 时的最大收益。对于 $f_{l,r}$，枚举全部取完 $l$ 到 $r$ 的最后一步取了哪些点，并将**全部取完这些点的收益与全部取完这些点之间的空隙区间的收益之和**取最大值，就是 $l$ 到 $r$ 区间的最大收益。

我们使用区间 *dp* 按区间长度从短到长求解，上述的空隙区间一定会在这之前求出。

设 $ans_{l,r}$ 为 $l$ 到 $r$ 的区间**可取部分**时的最大收益，可以直接暴力枚举断点，然后与 $f_{l,r}$ 比较，最后与啥都不取的 $0$ 比较（经典模板）。

可是这样很明显是过不了的。

+ 正解

考虑通过纯 *dp* 来代替搜索。

对于 $l$ 和 $r$ 不在同一次取走的情况，只需枚举断点即可，像这样：

```cpp
for (int k = l; k < r; k++)
	f[l][r] = max (f[l][r], f[l][k] + f[k+1][r]);
```

对于 $l$ 和 $r$ 在同一次取走的情况，说明取走 $l$ 和 $r$ 的这一步一定是全部取完 $l$ 到 $r$ 的最后一步。

由于合法的取数序列数值必定为先递增后递减（包括完全递增和完全递减），总之为山峰状。

我们可以枚举全部取完该区间的最后一步的取数序列中的最大值的位置 $k$（即峰顶），然后把该取数序列分成递增部分和递减部分。递增部分的开头是 $l$，结尾是 $k$，递减部分的开头是 $k$，结尾是 $r$。

既然两部分的开头和结尾都定下了，因为合法取数序列的数必须两两相差 $1$，两部分的长度也固定下来，为 $a_{k}-a_{l}+1$ 和 $a_{k}-a_{r}+1$。

那么全部取完该区间的最后一步的取数序列长度就是固定的了，现在只需要使得他们之间的空隙区间的收益和最大就行。于是我们考虑利用数组维护最大收益。

我们用 $u_{l,r}$ 表示两端分别为 $l$ 和 $r$ 且可以作为递增部分的取数序列中空隙区间的最大收益，用 $d_{l,r}$ 表示两端分别为 $l$ 和 $r$ 且可以作为递减部分的取数序列中空隙区间的最大收益。

转移长这样：

```cpp
for (int k = l; k <= r; k++) 
	f[l][r] = max (f[l][r], getAns (l, k, r));
```
那么怎么维护 $u$ 和 $d$ 呢？

对于已经求好的 $f_{l,r}$，尝试将取完 $l$ 到 $r$ 的取法换成 $f_{l,r}$ 的取法，$l-1$ 和 $r+1$ 归到最后取完 $l$ 到 $r$ 的那一步去，除 $l$ 到 $r$ 以外的部分用他们目前的取法，与原来的收益比较。因为相同的 $a_{i}$ 不会超过 $7$ 个，所以这样不会超时。

像这样：

```cpp
if (a[l-1] + 1 == a[r+1])
	for (int k = 1; k < l; k++)
		for (int q = r + 1; q <= n; q++)
			u[k][q] = max (u[k][q], u[k][l-1] + u[r+1][q] + f[l][r]);
if (a[l-1] == a[r+1] + 1)
	for (int k = 1; k < l; k++)
		for (int q = r + 1; q <= n; q++)
			d[k][q] = max (d[k][q], d[k][l-1] + d[r+1][q] + f[l][r]);
```
+ 献上代码一份

```cpp
#include <bits/stdc++.h>
#define N 200
#define Inf 2e9
using namespace std;

int u[N][N], d[N][N], f[N][N], ans[N][N], n, a[N], v[N];
//由于取值方便，up数组和down数组不包括最后一次操作的收益
int getAns (int l, int m, int r)	//得到分别是 up 和 down 的两个相邻区间组合后的答案 
{
	if (2 * a[m] - a[l] - a[r] + 1 > n) return -Inf;	//防止爆数组（不然凉凉） 
	if (a[m] < a[l] || a[m] < a[r]) return -Inf;
	return u[l][m] + d[m][r] + v[2*a[m]-a[l]-a[r]+1];
}

int main ()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> v[i];
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	memset (f, 245, sizeof (f));
	memset (u, 245, sizeof (u));	//初始化 	
	memset (d, 245, sizeof (d));
	for (int i = 1; i <= n; i++) u[i][i] = d[i][i] = 0, f[i][i-1] = 0;	 
	f[n+1][n] = 0;
	for (int i = -1; i < n; i++)	//细节，i的初值为 -1 
	{
		for (int j = 1; j + i <= n; j++)
		{
			int l = j, r = j + i;
			for (int k = l; k <= r; k++)	//l 和 r 属于同一次 
				f[l][r] = max (f[l][r], getAns (l, k, r));	//通过 up 和 down 组合成 取完该区间的那次操作 
			for (int k = l; k < r; k++)		//l 和 r 不属于同一次 
				f[l][r] = max (f[l][r], f[l][k] + f[k+1][r]);	//只需枚举断点，取 max 即可 
			if (a[l-1] + 1 == a[r+1])	//因为右边比左边大 1，所以更新 up 数组 
				for (int k = 1; k < l; k++)	//枚举需要更新的区间 
					for (int q = r + 1; q <= n; q++)
						u[k][q] = max (u[k][q], u[k][l-1] + u[r+1][q] + f[l][r]);
			if (a[l-1] == a[r+1] + 1)	//因为右边比左边小 1，所以更新 down 数组 
				for (int k = 1; k < l; k++)
					for (int q = r + 1; q <= n; q++)
						d[k][q] = max (d[k][q], d[k][l-1] + d[r+1][q] + f[l][r]);
			//更新方法：枚举需要更新的区间，考虑将区间内 l~r 这一段的取法变为 f[l][r] 的取法，
			//左侧和右侧都用 up 或 down 的取法，最后将三段的收益之和取 max，并与原来的取法比较，是否更新答案。 
		}
	}	//求 全部取完 的答案 
	for (int i = 0; i < n; i++)
	{
		for (int j = 1; j + i <= n; j++)
		{
			int l = j, r = j + i; ans[l][r] = max (ans[l][r], f[l][r]);	//初始值为 max(0, f[l][r]) 
			for (int k = l; k < r; k++)	//枚举断点 
				ans[l][r] = max (ans[l][r], ans[l][k] + ans[k+1][r]);
		}
	}	//求 取部分 的答案 
	cout << ans[1][n];
	return 0;
}

```
吸氧 $42ms$ 轻松拿到最优解。

+ 后记

做了这题感觉区间 *dp* 实力有提升，以前做的区间 *dp* 都是三重循环套板子的，这题就比较灵活。个人觉得是道好题。

---

## 作者：Rui_R (赞：10)

题意：给定一个序列，每次可以删除一段连续的先递增后递减，且元素间差值为1的序列，并得到对应分数。求可能的最大分数。

[原题](https://www.luogu.com.cn/problem/P1389)

这里提供一种不同的做法。是道很有意思的区间DP。

这道题的一大难点在于删去元素后，序列的位置会改变，这就导致不能简单的用小区间合并得到大区间。（因为可以先删中间的，再删两边的）

它的突破口在于，如何找到最后一步要消除的数。另一篇题解选择用搜索+一堆剪枝，我选择用DP。 

令$dp[i][j][1]$ 表示将 $i$~$j$ 这段**完全消去**的最大得分，$dp[i][j][0]$ 表示 $i$~$j$ 段可以得到的最大得分。

思考什么情况下，一个区间的 $dp[][][1]$  不能通过合并小区间得到：

**消去该区间最后一步含该区间两端点。**

（若最后一步右端不为 $j$ ，就可以用 $i$ 到最后一步的右端和最后一步右端+1到 $j$ 来合并）

（若最后一步左端不为 $i$ ，就可以用 $j$ 到最后一步的左端和最后一步左端-1到 $i$ 来合并）

于是想到令 $g[i][j][k]$ 表示将 $i$~$j$ 这段转化为能消去的，长为 $k$ 且含 $i$ , $j$的序列的最大得分，然后通过 $g[i][j][k]+val[k]$ 来尝试转移 $dp[i][j][1]$ 。

考虑如何维护 $g$ 数组：

既然需要包括该区间两端点，就有两种转移方法，即找i的下一个点和j的前一个点：

对于 $p$ 使 $a[p]=a[i]+1$，有 $g[i][j][k]=max(g[i][j][k],dp[i+1][p-1][1]+g[p][j][k-1])$

对于 $p$ 使 $a[p]=a[j]+1$，有 $g[i][j][k]=max(g[i][j][k],dp[p+1][j-1][1]+g[i][p][k-1])$

然后，就可以维护 $g$ 和 $dp[][][1]$ 了。至于$dp[][][0]$，只需尝试从合并小区间得到后与$dp[][][1]$ 取较大值即可。

由于题目限制每个数字的出现次数，枚举 $p$ 是完全可以接受的，只需要离散化然后用 vector之类的东西存对应的下标。

剩下的小细节请见代码。

$\texttt{Talk is cheap,show me your code.}$
```
#include <cstdio>
#include <algorithm>

const int maxn=155,inf=1e9+7;
int n,a[maxn],val[maxn];
int dp[maxn][maxn][2],g[maxn][maxn][maxn];

// std::map<int,std::vector<int> > M;偷懒的话可以用这个，但是需要O2才能过
int hash[maxn],size[maxn],LEN;
int v[maxn][maxn];

inline int max(int a,int b){
	return a>b?a:b;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&val[i]);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		hash[i]=a[i];
	}
	std::sort(hash+1,hash+n+1);LEN=std::unique(hash+1,hash+n+1)-hash-1;
	for(int i=1;i<=n;i++){
		int q=std::lower_bound(hash+1,hash+LEN+1,a[i])-hash;
		v[q][++size[q]]=i;//离散化并存下对应下标
	}
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n;k++) g[i][j][k]=-inf;
			dp[i][j][0]=dp[i][j][1]=-inf;
		}
	}
	for(int i=1;i<=n;i++){
		dp[i][i][0]=max(val[1],0),dp[i][i][1]=val[1];
		g[i][i][1]=0;
	}
	hash[LEN+1]=-1;
	for(int len=2;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			for(int k=2;k<=n;k++){//这里要从2开始，因为g[][][1]没有意义，毕竟i!=j,g至少也要包括i,j
				int q=std::lower_bound(hash+1,hash+LEN+1,a[i]+1)-hash;
				if(hash[q]==a[i]+1){
					for(int _=1;_<=size[q];_++){
						int p=v[q][_];if(p<i||p>j) continue;//得在区间内
						if(p==i+1) g[i][j][k]=max(g[i][j][k],g[p][j][k-1]);//防止i+1>p-1
						else g[i][j][k]=max(g[i][j][k],dp[i+1][p-1][1]+g[p][j][k-1]);
					}
				}
				q=std::lower_bound(hash+1,hash+LEN+1,a[j]+1)-hash;
				if(hash[q]==a[j]+1){
					for(int _=1;_<=size[q];_++){
						int p=v[q][_];if(p<i||p>j) continue;
						if(p==j-1) g[i][j][k]=max(g[i][j][k],g[i][p][k-1]);//同上
						else g[i][j][k]=max(g[i][j][k],dp[p+1][j-1][1]+g[i][p][k-1]);
					}
				}
				dp[i][j][1]=max(dp[i][j][1],g[i][j][k]+val[k]);
			}
			for(int _=i;_< j;_++){
				dp[i][j][1]=max(dp[i][j][1],dp[i][_][1]+dp[_+1][j][1]);
				dp[i][j][0]=max(dp[i][j][0],dp[i][_][0]+dp[_+1][j][0]);
			}
			dp[i][j][0]=max(dp[i][j][0],dp[i][j][1]);
		}
	}
	printf("%d\n",dp[1][n][0]);
	return 0;
}
/*
a[p]==a[i]+1

g[i][j][k]=max
dp[i+1][p-1] + g[p][j][k-1]

a[p]==a[j]+1

g[i][j][k]=max
dp[p+1][j-1] + g[i][p][k-1]

*/
```

事实证明这个跑得比搜索快，吸口氧就轻松拿到了最优解呢。

---

## 作者：cmk666 (赞：7)

[题目链接](/problem/P1389)

给一种严格 $O(n^3)$ 的，且不依赖于每个数出现的次数的区间 dp 做法，跑的飞快，而且码量极小。

可以发现，题目的意思是可以删一个先递增后递减且相邻两数之差为 $1$ 的区间。

设 $f_{i,j}$ 表示把 $i\sim j$ 删光的最大代价。

这样可以直接大力 dp，复杂度是 $O(n^5)$ 或 $O(n^4)$ 的，取决于实现。

考虑少枚举中间的决策点。再设 $l_{i,j},r_{i,j}$ 分别表示把 $i\sim j$ 删到只剩递增 / 减且 $i,j$ 必须保留的最大代价。

那么 $l,r$ 的转移很简单：

$$l_{i,j}=\max_{i\le k<j,a_k+1=a_j}l_{i,k}+f_{k+1,j-1}$$

$$r_{i,j}=\max_{i\le k<j,a_k-1=a_j}r_{i,k}+f_{k+1,j-1}$$

直接删掉 $i\sim j$ 这一整段的代价，可以枚举最大的点 $k$：

$$f_{i,j}=\max_{i\le k\le j}l_{i,k}+r_{k,j}+v_{2a_k+1-a_i-a_j}$$

以及区间 dp 套路的，分成多段：

$$f_{i,j}=\max_{i\le k<j}f_{i,k}+f_{k+1,j}$$

二者取 $\max$ 即可。

注意到最终答案不一定要删完，所以求答案还要再套一个简单 dp，这部分很简单，略过不提。

总时间复杂度 $O(n^3)$。核心代码如下：
```cpp
int n, j, v[409], a[409], l[409][409], r[409][409], f[409][409], ans[409], qwq;
int main()
{
	read(n), memset(f, 0xc0, sizeof(f)),
	memset(l, 0xc0, sizeof(l)), memset(r, 0xc0, sizeof(r));
	For(i, 1, n) read(v[i]); For(i, 1, n) read(a[i]);
	For(i, 1, n) l[i][i] = r[i][i] = f[i][i - 1] = 0, f[i][i] = v[1];
	For(len, 2, n) For(i, 1, n + 1 - len)
	{
		j = i + len - 1;
		For(k, i, j - 1)
		{
			if ( a[k] + 1 == a[j] ) l[i][j] = max(l[i][j], l[i][k] + f[k + 1][j - 1]);
			if ( a[k] - 1 == a[j] ) r[i][j] = max(r[i][j], r[i][k] + f[k + 1][j - 1]);
			f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j]);
		}
		For(k, i, j)
		{
			qwq = 2 * a[k] + 1 - a[i] - a[j];  // 这里要判断一下范围不然会 RE
			if ( 1 <= qwq && qwq <= n )
				f[i][j] = max(f[i][j], l[i][k] + r[k][j] + v[qwq]);
		}
	}
	qwq = 0;
	For(i, 1, n)
	{
		ans[i] = ans[i - 1];
		For(j, 1, i) ans[i] = max(ans[i], ans[j - 1] + f[j][i]);
		qwq = max(qwq, ans[i]);
	}
	return printf("%d\n", qwq), 0;
}
```

---

## 作者：JimmyF (赞：3)

很明显的区间动规，~~只是特难想~~。

首先要明确状态，对于此题来说，区间不一定要选完，很明显不能**一步到位**，就是说不可以直接将状态设成表示一段区间**部分选取**，这样的话转移会非常困难。而是应该考虑一段区间**全部选完**：设 $dp_{l,r}$ 表示 $[l,r]$ 区间全部选完的最大价值，考虑转移。

我们发现转移分两种情况：

1. 能拆分成两个子区间合并的
2. 不能拆分成两个子区间合并的

对于情况1，直接枚举断点 $k$，$dp_{l,r}= \max\limits_{l\leq k <r}dp_{l,k}+dp_{k+1,r}$

而对于情况2，不妨思考一个问题：如果不能通过两个子区间合并，则端点 $l,r$ 一定在同一次删除中（否则可以归到情况1）。而题目要求的两个条件，其实相当于只能先递增后递减，或者只有单调升/降（只能出现**山峰**），那么设 $f_{l,r,0},f_{l,r,1} $ 分别表示把 $l\sim r$ 删到只剩递增**或**递减且 $l,r$ 必须保留的最大代价。枚举**山峰** $k$，
$$dp_{l,r}= \max\limits_{l\leq k \leq r}f_{l,k,0}+f_{k,r,1}+v_{a_k-a_l+a_k-a_j+1}$$ 

$f$ 也很好维护：

$$f_{l,r,0}= \max\limits_{l\leq k < r,a_k+1=a_j}f_{l,k,0}+dp_{k+1,r-1}$$ 
$$f_{l,r,1}= \max\limits_{l\leq k < r,a_k-1=a_j}f_{l,k,1}+dp_{k+1,r-1}$$

值得注意的是：这里的转移具有**阶段性特征**，即以 $[l,r]$ 长度为阶段，$f$，$dp$ 的相互转移建立在 $len-1$ 基础上，所以无后效性。

最后就是一个较为简单的区间选取 $dp$ 了。

### Code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=300+10;
int n;
int a[N],v[N],ans[N];
int f[N][N][2],dp[N][N];
signed main(){
	cin>>n;
	for(int i=1; i<=n; ++i){
		scanf("%lld",&v[i]);
	}
	memset(dp,-0x3f,sizeof(dp));
	memset(f,-0x3f,sizeof(f));
	for(int i=1; i<=n; ++i){
		scanf("%lld",&a[i]);
		dp[i][i]=v[1];
		f[i][i][0]=f[i][i][1]=dp[i][i-1]=0;//注意初始化
	}
	for(int len=2; len<=n; ++len){
		for(int l=1; l<=n-len+1; ++l){
			int r=l+len-1;
			for(int k=l; k<r; ++k){
				if(a[k]+1==a[r])f[l][r][0]=max(f[l][r][0],f[l][k][0]+dp[k+1][r-1]);
				if(a[k]-1==a[r])f[l][r][1]=max(f[l][r][1],f[l][k][1]+dp[k+1][r-1]);
				dp[l][r]=max(dp[l][k]+dp[k+1][r],dp[l][r]);
			}
			for(int k=l; k<=r; ++k){
				int tmp=a[k]*2-a[l]-a[r]+1;
				if(tmp>=1&&tmp<=n)//这里需判断是否符合条件
				dp[l][r]=max(dp[l][r],f[l][k][0]+f[k][r][1]+v[tmp]);
			}
			
		}
	}
	int answ=0;
	for(int i=1; i<=n; ++i){
		ans[i]=ans[i-1];
		for(int j=0; j<i; ++j){
			ans[i]=max(ans[i],ans[j]+dp[j+1][i]);
		}
		answ=max(answ,ans[i]);
	}//简单的区间选取dp
	cout<<answ;
	return 0;
}
```


---

## 作者：0x3F (赞：1)

~~CSP-S 考前写题解涨 rp~~

首先考虑区间删除的 dp 套路：考虑 $dp_{l,r}$ 表示把区间 $[l,r]$ 删空时的答案，$tmp_{l,r,\texttt{其他一些状态}}$ 表示把区间 $[l,r]$ 删成某个特定形态时的答案。

我们发现，符合条件的被删除序列必然是**先上升后下降，且相邻元素差为** $\bold{1}$（只有上升或者只有下降也可以），得分只与长度有关，于是考虑记录区间 $[l,r]$ 剩下的那部分符合条件时的长度，最后一个数以及当前处于上升段还是下降段，也就是考虑 $tmp_{l,r,k,a,0/1}$，其中 $a$ 表示剩下的最右侧的数，$k$ 表示剩余的数的长度，$0/1$ 表示有没有下降。

但是这样是 $\mathcal{O}(n^5)$ 的，我们发现 $a$ 这一维记录未被删除的最右侧一个数，它有必要的原因只是 $r$ 本身可能已经被删除。

因此，我们让 $tmp_{l,r,k,0/1}$ 表示将 $[l,r]$ 删除至只剩 $k$ 个数，且**第 $\boldsymbol{r}$ 个数必须保留**，这些数满足先上升后下降，且 $0/1$ 表示当前有没有下降时，已经删除的数的得分之和的最大值。

在这种情况下，最后一个数必然是 $r$，我们只需要枚举倒数第二个数是否被删除，以及所删除的区间的左端点，就可以写出 $tmp$ 的转移方程，由于其他题解已经写的很清楚，这里不再详细列出。

时间复杂度为 $\mathcal{O}(n^4)$，但是有 $\frac{1}{24}$ 的常数，可以通过此题。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 160;
int n, v[_], a[_], dp[_][_], tmp[_][_][_][2], ans[_];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	memset(dp, 0xC0, sizeof(dp));
	memset(tmp, 0xC0, sizeof(tmp));
	for (int d = 1; d <= n; d++) {
		for (int l = 1, r = d; r <= n; l++, r++) {
			for (int m = l; m <= r; m++) {
				for (int k = 1; k <= m-l+1; k++) {
					if (m == l || a[r] == a[m-1] + 1) tmp[l][r][k][0] = max(tmp[l][r][k][0], ((m!=l)?(tmp[l][m-1][k-1][0]):(0)) + ((m!=r)?(dp[m][r-1]):(0)));
					if (m != l && a[r] == a[m-1] - 1) tmp[l][r][k][1] = max(tmp[l][r][k][1], max(tmp[l][m-1][k-1][0],tmp[l][m-1][k-1][1]) + ((m!=r)?(dp[m][r-1]):(0)));
				}
			}
			for (int k = 1; k <= d; k++) {
				dp[l][r] = max(dp[l][r], max(tmp[l][r][k][0], tmp[l][r][k][1]) + v[k]);
			}
		}
	}
	ans[0] = 0;
	for (int i = 1; i <= n; i++) {
		ans[i] = ans[i-1];
		for (int j = 1; j <= i; j++) {
			ans[i] = max(ans[i], ans[j-1] + dp[j][i]);
		}
	}
	cout << ans[n] << endl;
	return 0;
}
```

---


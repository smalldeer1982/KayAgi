# 子序列

## 题目描述

给定一个长度为 $N$（$N$ 为偶数）的序列，问能否将其划分为两个长度为 $N / 2$ 的严格递增子序列。

## 说明/提示

**【数据范围】**

共三组数据，每组数据行数<=50，0 <= 输入的所有数 <= 10^9

第一组(30%)：N <= 20

第二组(30%)：N <= 100

第三组(40%)：N <= 2000


## 样例 #1

### 输入

```
6 3 1 4 5 8 7
6 3 2 1 6 5 4
```

### 输出

```
Yes!
No!
```

# 题解

## 作者：深海鱼的眼泪 (赞：59)

如楼下所说，下面两个题解是有反例的，如输入数据为 6 1 2 3 4 5 1 时就不行了。

然而数据弱呀╮(╯▽╰)╭

那么这个题解的思路显然不是我自己的

http://blog.csdn.net/nike0good/article/details/8605219  

【蒟蒻表示花了很久看懂大神的题解……】

在前i位中找长j位的以第i位结尾的上升子序列，并且剩下的也是上升子序列，那么f[i][j]表示剩下的（即前i位中长i-j位的不以第i位结尾的）上升子序列的最后一位的最小值。

然后转移：

如果a[i]<a[i+1]，那么f[i+1][j+1]=min(f[i+1][j+1],f[i][j])，相当于可以直接把f[i][j]扩展到第i+1位。

如果f[i][j]<a[i+1]，那么f[i+1][i-j+1]=min(f[i+1][i-j+1],a[i])，相当于第i+1继承前i位中i-j位长的上升子序列。



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define INF (2139062143)
using namespace std;
void read(int& x){
    x=0;
    int y=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') y=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x=x*y;
}
int n,a[2001],f[2001][2001];
int main(){
    int i,j;
    while (~scanf("%d",&n)){
        memset(f,127,sizeof(f)); 
        for (i=1;i<=n;++i){
            read(a[i]);
        }
        f[1][1]=-1;
        for (i=1;i<=n;++i){
            for (j=1;j<=i;++j){
                if (f[i][j]!=INF){
                    if (a[i]<a[i+1])
                        if (f[i+1][j+1]>f[i][j]) f[i+1][j+1]=f[i][j];
                    if (f[i][j]<a[i+1]) 
                        if (f[i+1][i+1-j]>a[i]) f[i+1][i+1-j]=a[i];
                }
            }
        }
        if (f[n][n/2]==INF) printf("No!\n");
        else printf("Yes!\n");
    }
    return 0;
}
```

---

## 作者：yezl (赞：16)

### 题意概述：  
~~（其实这么短的题目不用吧qwq）~~

题目的意思是给我们不知道多少（总数不大于50）个长度为 $ n $ 的序列（ $\mathcal{n<=2000} $ ），要我们判断这个序列是否能分成**两个长度为 $\frac{n}{2}$ 的严格递增子序列**，可以输出 $ \mathrm{Yes!} $ ,否则输出 $ \mathrm{No!} $ 。

### 思路：

~~通过查看题目标签~~我们可以非常容易得想到用动态规划，那么要这么设置状态和状态转移方程呢？说实话这个要做多了题才有感觉，所以在这里我直接给大家定义出来：

**状态：** $ \texttt{f[i][j]} $代表 前 i 位中长度为 j 的最长上升子序列的最后一位的大小。  
**状态转移方程：** 
1. $ \texttt{f[i][j]=min(f[i][j],f[i-1][j-1])} $ $ if(a[i-1]<a[i]) $ 
2. $ \texttt{f[i][i-j+1]=min(f[i][i-j+1],a[i-1])} $ $ if(f[i-1][j-1]<a[i]) $ 

那么定义好了状态和方程，我们就开始写代码吧。注意：它是循环 $ \mathrm{while} $ 读入， $ so $ 它要停下来要手动 $ Ctrl+Z $ 放心不会影响测评。

### 不多说，直接上代码：

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=2e3+10;
int f[N][N],a[N];
int n;
//f[i][j]代表 前 i 位中长度为 j 的最长上升子序列的最后一位的大小 
int main()
{
	while(scanf("%d",&n)==1)
	{
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		memset(f,0x3f,sizeof(f));//将 f 数组初始化为极大值 
		f[1][1]=0;//因为答案可能是 0 所以最小值就应该设置成-1 
		for(int i=2;i<=n;i++)
		{//因为后面的DP方程中有 i-1 项,而 i-1 要大于等于 1,所以 i 从 2开始 
			for(int j=2;j<=i;j++) 
			{
				if(a[i-1]<a[i])
				{//贪心：因为结尾最小可以使后面能接的最长上升多 
					f[i][j]=min(f[i][j],f[i-1][j-1]);
				}
				if(f[i-1][j-1]<a[i])
				{// i-j 的意思是:
				 //因为我们已经知道前 j 个数已经是合法的了
				 //那么剩下的 i-j 个数也要是合法的 
					f[i][i-j+1]=min(f[i][i-j+1],a[i-1]);
				}
			}
		}
		if(f[n][n/2]<0x3f3f3f3f)
		{//如果前 n 个数中长度为 n/2 的最长上升子序列的最后一位小于0x3f3f3f3f 
			printf("Yes!\n");
		}
		else
			printf("No!\n");
	}
	return 0;
}
```

希望可以帮到大家。

---

## 作者：Steadywelkin (赞：5)

这里提供一个运用 $Dilworth$ 定理的方法

> **Dilworth 定理**

> 给定一个偏序关系，比如一个数出现的位置 $i$ 在另一个数出啊先的位置 $j$ 之前，并且满足 $a_i>a_j$ ，那么这个满足这个偏序关系的序列就称为链，关于链和反链的定义：

> * **链**： 一个偏序集 $S$ 的全序子集（全序是指任意两个元素可以比较）

> * **反链**： 一个偏序集 $S$ 的子集，其中任意两个元素不可比较

> **最大链的长度等于最少反链覆盖数，最大反链长度等于最少链覆盖数**

所以对于本题而言，我们可以先对于整个序列求一次最长反链，也就是最长不上升子序列的长度（下面设为 $len$ ），分类讨论：

* $len=1$ 说明此时的序列肯定是一个严格上升子序列，此时只要按奇偶划分就一定满足条件（当然取前后两部分也是可以的）

* $len>2$ 说明此时的序列至少要被划分两次以上才可以被划分为多个严格上升子序列，一定不能划分为两个严格上升子序列

* $len=2$ 这时候要考虑子序列的结构问题了

![](https://cdn.luogu.com.cn/upload/image_hosting/gebb17ef.png)

如图所示，当 $len=2$ 的时候，必然是因为在序列中 $pos$ 前后的两部分均为严格上升，只有个位置 $pos$ 出现了“断层”的情况，在这个位置 $pos$ 上，值域可以为 $[up,down]$ ，现在我们考虑将严格上升的部分划分出一部分给这个特殊位置 $pos$ ，使得两个序列的长度均为 $\begin{aligned}\frac{n}{2}\end{aligned}$

我们将 $a[pos]$ 的值横向映射过去，显然如果要划分子序列，图中 $len$ 的部分是不能划分给 $pos$ 所在的子序列的，因为要保证序列的严格上升，那么就可以得到：

* （1）如果 $\begin{aligned}len\le\frac{n}{2}\end{aligned}$ 那么可以通过划分将原序列分为两个严格上升子序列

* （2）如果 $\begin{aligned}len>\frac{n}{2}\end{aligned}$ 那么在 $pos$ 前的一个序列长度就已经超过了 $\begin{aligned}\frac{n}{2}\end{aligned}$ ，显然这种情况是不能划分的

但是这样划分还是不完备的，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jli53rm1.png)

虽然映射之后的 $len$ 是不到 $\begin{aligned}\frac{n}{2}\end{aligned}$ 的，但是很显然，这种情况也是不可能划分的，因为后面的部分不能划分到前面 $len1$ 的部分，所以对于上面的第 $2$ 中情况还要将 $len1$ $len2$ 求出（注意这里的 $len2$ 的长度是指低于第一部分的最高点的最高位置到 $pos$ 的长度，包含 $pos$），有（在上面 $2$ 的条件下）：

* $\begin{aligned}len2>\frac{n}{2}\end{aligned}$ 则无解

* 否则有解

至于 $pos$ 的具体位置，因为其他位置都满足单调性，可以直接 $O(n)$ 扫一遍找到

寻找映射到的位置可以通过二分查找，时间复杂度 $O(logn)$ 

加上前面的寻找最长不上升子序列的 $O(nlogn)$ ，总时间复杂度为 $O(nlogn)$ ，可以通过此题

---

## 作者：toolong114514 (赞：3)

## 解题思路
这道题要求将原序列分为两部分，这启发我们想到二分图。

遍历一遍所有元素，将所有满足 $a_i\geq a_j$ 且 $i<j$ 的点对 $(i,j)$ 之间连边，跑二分图染色。

如果染色全部成功，那么说明原序列能被划分成两段严格递增子序列。

这个时候直接输出 ```Yes!``` 或 ```No!``` 是存在谬误的，因为“原序列能被划分成两段严格递增子序列”是“原序列能被划分成两段均为 $\frac{n}{2}$ 的严格递增子序列”的**必要条件**，并不与原命题等价。

我们考虑一个可行性背包 DP。

记建好图后连通块总数为 $cnt$，记 $w_{i,0/1}$ 为第 $i$ 个连通块染黑/白色点的数量，每组 $w$ 必须选择一个。

定义 $f_{i,j}$ 为对于前 $i$ 个连通块，选取了 $j$ 个点作为左部点是否有解。有解记为 $1$，无解记为 $0$,并同时定义 $f_{0,0}=1$。

转移部分很好写，都是一些套路，就不展开了。

最后判断 $f_{cnt,\frac{n}{2}}$ 是否为 $1$，是的话输出 ```Yes!```，否则输出 ```No!```。

时间复杂度约为 $O(n^2)$，可以通过本题。
## 参考代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=4e6+10;
struct node{
	int to,nxt;	
}edge[2*N];
int head[5005];
int cnt;
void add(int u,int v){
	edge[++cnt]={v,head[u]};
	head[u]=cnt;
}
bool vst[5005];
bool f[5005][5005];
int a[5005],col[5005];
int w[5005][2];
bool flag;
int n,bl;
void dfs(int x){
	vst[x]=true;
	w[bl][col[x]]++;
	for(int i=head[x];i!=-1;i=edge[i].nxt){
		if(!flag) return;
		if(vst[edge[i].to]){
			if(col[edge[i].to]!=col[x]^1){
				flag=false;
				return;
			}
		}else{
			col[edge[i].to]=col[x]^1;
			dfs(edge[i].to);
		}		
	}
}
int main(){
	ios::sync_with_stdio(false);
	while(cin>>n){
		memset(head,-1,sizeof(head));
		memset(vst,0,sizeof(vst));
		memset(col,0,sizeof(col));
		memset(f,0,sizeof(f));
		memset(w,0,sizeof(w));
		cnt=bl=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1;i<=n;i++){
			for(int j=i+1;j<=n;j++){
				if(a[i]>a[j]){
					add(j,i);
					add(i,j);
				}
			}
		}
		flag=true;
		for(int i=1;i<=n;i++){
			if(!vst[i]){
				bl++; 
				dfs(i);
			}
		}
		if(!flag) cout<<"No!\n";
		else{
			f[0][0]=1;
			for(int i=1;i<=bl;i++){
				for(int j=0;j<=n;j++){
					if(j>=w[i][0]) f[i][j]|=f[i-1][j-w[i][0]];
					if(j>=w[i][1]) f[i][j]|=f[i-1][j-w[i][1]];
				}
			}
			if(f[bl][n/2]) cout<<"Yes!\n";
			else cout<<"No!\n";
		}
	}
	return 0;
}
```
[本代码可以通过原题数据评测。](https://www.luogu.com.cn/record/174578805)

通过讨论区广泛认同的[ hack 数据](https://www.luogu.com/discuss/494456) 的记录：[record](https://www.luogu.com.cn/record/174578884)。

与之对比的错误二分图做法记录：[record](https://www.luogu.com.cn/record/174580958) 以及 [code](https://www.luogu.com.cn/paste/rd85g10l)。

Written by [toolong114514](https://www.luogu.com/user/477821) on 2024/8/24.

---

## 作者：Vocalise (赞：2)

一个不同的 DP 做法：常数约为 $\dfrac 14$。

详细说说是怎么想到的。

---

首先考虑到的是 $f_{i,j}$ 表示前 $i + j$ 个数分割为长度 $i$ 和 $j$ 的两个序列，其中第 $i + j$ 个数属于 $i$，是否可行。

转移的思路是看第 $i + j - 1$ 个数属于哪个序列。

但是这样显然无法转移。于是尝试多维护一些信息。

设 $f_{i,j,k},k\in\{0,1\}$ 表示前 $i + j$ 个数，以 $i$（0）序列结尾或以 $j$（1）序列结尾，另一个序列最后一个数的最小值。

可以写出正确的代码。但是在这个状态中我们给序列标号，其实上不需要这个标号：这样设计的状态看似不同标号的序列相互依赖，实际是完全对称的。

所以设计出最终的状态。

$f_{i,j}$ 表示前 $i + j$ 个数，以 $i$ 序列结尾，$j$ 序列最后一个数的最小值。

特别地，若不存在这样的分割方案，$f_{i,j}=+\infty$；否则若 $j$ 序列为空，$f_{i,j}=-1$。（$+\infty$ 需大于所有数的最大值。）

有转移：

$$f_{n,m}=\min(\mathop{f_{n-1,m}}\limits_{a_{n+m-1}<a_{n+m}},\mathop{a_{n+m-1}}\limits_{f_{m,n-1}<a_{n+m}},+\infty)$$

$f_{n-1,m}$ 的情况是第 $n+m-1$ 个数和第 $n+m$ 个数同属一个序列。

否则，因为对于前 $n+m-1$ 个数是以 $m$ 序列结尾的，因此需满足 $f_{m,n-1}<a_{n+m}$。

对于 $m$ 为空的情况，若 $1\sim n$ 单调递增则 $f_{n,0}=-1$，否则为 $+\infty$。

认为不存在 $n$ 为空的情况，此时 $f_{0,m} = +\infty$。

发现这个转移有 $n$ 与 $m$ 的交换，不一定是从小到大的，于是采用记忆化搜索。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int N = 2001;
const int inf = 0x3f3f3f3f;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int n,a[N];
int dp[N][N];

int DP(int n,int m) {
	if(!n) return inf;
	if(dp[n][m]) return dp[n][m];
	dp[n][m] = inf;
	if(a[n + m - 1] < a[n + m]) dp[n][m] = std::min(dp[n][m],DP(n - 1,m));
	if(DP(m,n - 1) < a[n + m]) dp[n][m] = std::min(dp[n][m],a[n + m - 1]);
	return dp[n][m];
}

int main() {
	a[0] = -1;
	while(~std::scanf("%d",&n)) {
		for(int i = 1;i <= n;i++) a[i] = read();
		memset(dp,0,sizeof(dp)), dp[1][0] = -1;
		for(int i = 2;i <= n / 2;i++) {
			if(a[i - 1] < a[i] && dp[i - 1][0] != inf) dp[i][0] = -1;
			else dp[i][0] = inf;
		}
		std::puts(DP(n / 2,n / 2) != inf ? "Yes!" : "No!");
	}
	return 0;
}

```

---

## 作者：reek (赞：2)

我提供一种跑得非常慢的做法（时间效率O（n^2））。

显然，所有原数列中的逆序对（在这里是满足i<j且ai>=aj的数对）都不能分在同一组。因此，我们可以在所有逆序对间连边。

然后，我们对所有联通块进行二分图染色，并记录每个联通块的黑点数和白点数。如果有一个联通块无法染色，说明原数列不能分成两个严格递增的子序列，输出No。

最后，DP判断是否能过取出两个长度为n/2的严格递增子序列。

但是，很可惜，这样只能得到70分，还有3个点超时。

所以，我们需要3个特判：

1.如果原数列的最小数在后半序列中，那么直接输出No

2.如果原数列的最长上升子序列长度不足n/2，也直接输出No。最长上升子序列可以在O（nlogn）的时间内求出。

3.如果原数列的最长不上升子序列长度等于1，则直接输出Yes，大于2，则直接输出No。求法同上。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,tot,ii,p,ans,g[2333],a[2333],b[2333][2],cnt[2],v[2333],aa[8000100][2],first[2010];
bool f[2][2010],fg;
inline int read() {
    char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    int tmp=0;
    while (c>='0'&&c<='9') {
        tmp=(tmp<<1)+(tmp<<3)+c-48;
        c=getchar();
    }
    return tmp;
}
inline void ins_ed(const int&x,const int&y) {
    tot++;
    aa[tot][1]=y;
    aa[tot][0]=first[x];
    first[x]=tot;
}
inline bool dfs(const int&x,const bool&col) {
    v[x]=col+1; cnt[col]++;
    for (int i=first[x];i;i=aa[i][0]) 
    if (!v[aa[i][1]]) {
        if (!dfs(aa[i][1],!col)) return 0;
    } else if (v[aa[i][1]]==v[x]) return 0;
    return 1;
}
int main() {
    while(~scanf("%d",&n)) {
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        memset(aa,0,sizeof(aa));
        memset(first,0,sizeof(first));
        memset(v,0,sizeof(v));
        tot=0; ii=0;
        for (int i=1;i<=n;++i) {
            a[i]=read(); if (ii<1||a[i]<a[ii]) ii=i;
        }
        if (ii>n/2+1) {
            printf("No!\n");
            continue;
        }
        memset(g,0,sizeof(g));
        ans=0;
        for (int i=1;i<=n;i++) {
            if (g[ans]<a[i]) {
                g[++ans]=a[i]; continue;
            }
            p=lower_bound(g,g+ans,a[i])-g;
            g[p]=min(g[p],a[i]);
        }
        if (ans<(n>>1)) {
            printf("No!\n");
            continue;
        }
        memset(g,0,sizeof(g));
        ans=0; g[0]=-1e9;
        for (int i=1;i<=n;i++) {
            if (-g[ans]>a[i]) {
                g[++ans]=-a[i]; continue;
            }
            p=lower_bound(g,g+ans,-a[i])-g;
            g[p]=min(g[p],-a[i]);
        }
        if (ans==1) {
            printf("Yes!\n");
            continue;
        }
        if (ans>2) {
            printf("No!\n");
            continue;
        }
        for (int i=1;i<n;++i)
        for (int j=i+1;j<=n;++j)
        if (a[i]>=a[j]) ins_ed(i,j),ins_ed(j,i);
        tot=0;
        fg=1;
        for (int i=1;i<=n;++i) if (!v[i]) {
            cnt[0]=0; cnt[1]=0; 
            if (!dfs(i,0)) {fg=0; break;}
            b[++tot][0]=cnt[0]; b[tot][1]=cnt[1];
        }
        if (!fg) {
            printf("No!\n");
            continue;
        }
        memset(f,0,sizeof(f));
        f[0][0]=1;
        for (int i=1;i<=n;++i) {
            for (int j=0;(j<<1)<=n;++j) f[i&1][j]=0;
            for (int j=0;(j<<1)<=n;++j) if (f[(i&1)^1][j]) f[i&1][j+b[i][0]]=f[i&1][j+b[i][1]]=1;
        }
        if (f[n&1][n>>1]) printf("Yes!\n"); else printf("No!\n");
    }
    return 0;
}
```

---

## 作者：无解双八卦 (赞：1)

emmm,感觉这题有问题啊。

问题出在题目：问能否将其划分为两个长度为N/2的严格递增子序列。

先贴一个能ac的代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a[2005],a1[2005],a2[2005];
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
    {
        int i,t=0,a1max=0,a2max=0;
        for(i=1;i<=n;i++)
        {a1[i]=-1;a2[i]=-1;}
        for(i=1;i<=n;i++)
        {scanf("%d",&a[i]);
        if(t==0)
        {
            if(a[i]>a1max){a1[i]=a[i];a1max=a1[i];}
            else if(a[i]>a2max)
            {a2[i]=a[i];a2max=a2[i];}
            else t=1;}}
        if(t==0)printf("Yes!\n");
        else printf("No!\n");
    }
    return 0;
}
```
很明显上面的代码只是判断是否能分成两个单增子序列而不考虑长度限制，然而能过。
这个还可以用数据水来解释，然而下面是一个（我认为的）正解代码，结果过不了：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a[2005],a1[2005],a2[2005];
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
    {
        int i,t=0,a1len=0,a2len=0,a1max=0,a2max=0,k1,k2=0,j,res=0;//res表示能从a1移到a2的数的个数
        for(i=1;i<=n;i++)
        {a1[i]=-1;a2[i]=-1;}
        a2[0]=-1;a2[n+1]=1000000001;
        for(i=1;i<=n;i++)
        {scanf("%d",&a[i]);
        if(t==0)
        {
            if(a[i]>a1max){a1[i]=a[i];a1max=a1[i];a1len++;}
            else if(a[i]>a2max)
            {a2[i]=a[i];a2max=a2[i];a2len++;
            k1=k2;k2=i;
            for(j=k1+1;j<k2;j++)
            if(a1[j]!=-1&&a1[j]>a2[k1]&&a1[j]<a2[k2])res++;}//每当输入一个a2,就搜索从上一个a2到这个a2可以移到a2的a1
            else t=1;}}
        for(j=k2+1;j<n+1;j++)
        if(a1[j]!=-1&&a1[j]>a2[k2]&&a1[j]<a2[n+1])res++;//最后再搜一遍
        if(t==0&&a1len>=n/2&&a2len+res>=n/2)printf("Yes!\n");
        else printf("No!\n");
    }
    return 0;
}
```
然而这个码只能过一个点，其它都会有应该输出Yes!而输出No!的情况
（我觉得）这个码应该没啥问题，所以题目有问题。

如果只是想过这道题，忽略掉题目里的子序列长度限制就好。


---


# 经营与开发

## 题目描述

$4X$ 概念体系，是指在 PC 战略游戏中一种相当普及和成熟的系统概念，得名自 $4$ 个同样以 EX 为开头的英语单词。

- $\verb!eXplore!$（探索）
- $\verb!eXpand!$（拓张与发展）
- $\verb!eXploit!$（经营与开发）
- $\verb!eXterminate!$（征服）

——维基百科

今次我们着重考虑 exploit 部分，并将其模型简化：

你驾驶着一台带有钻头（初始能力值 $w$）的飞船，按既定路线依次飞过 $n$ 个星球。星球笼统的分为 $2$ 类：资源型和维修型。（$p$ 为钻头当前能力值）

1. 资源型：含矿物质量 $a_i$，若选择开采，则得到 $a_i\times p$ 的金钱，之后钻头损耗 $k\%$，即 $p\gets p\times (1-0.01k)$；
2. 维修型：维护费用 $b_i$，若选择维修，则支付 $b_i\times p$ 的金钱，之后钻头修复 $c\%$，即 $p\gets p\times (1+0.01c)$。

注：维修后钻头的能力值可以超过初始值（你可以认为是翻修 + 升级）

金钱可以透支。

请作为舰长的你仔细抉择以最大化收入。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据 $n \le 100$；
- 另有 $20\%$ 的数据 $n \le 1000$，$k=100$；
- 对于 $100\%$ 的数据 $n \le 100000$，$0 \le k,c,w,a_i,b_i \le 100$，保证答案不超过 $10^9$。

## 样例 #1

### 输入

```
5 50 50 10
1 10
1 20
2 10
2 20
1 30
```

### 输出

```
375.00```

# 题解

## 作者：poorpool (赞：77)

蒟蒻也能写出来的AC代码！其实刚拿到这道题是我是不会做的……因为我惯性思维了，老是想着从1推到n，但是这样是有后效性的。

不过，**正难则反**，既然从1到n有后效性了，那么我们想着从n推到1。可以看出来一个星球选择与否对后面的影响是成比例的，也就是说只是系数的差别。

举个例子，第i个是资源型，我们可以搞出dp[i+1]（代表从i+1开始选，1～i一概略过）的最大金钱数，钦定第i个开始选的系数为1，那么dp[i]=max(dp[i+1]/\*这个不选\*/, a[i]+dp[i+1]\*(1-0.01\*k)/\*第i个选了，加上金钱，当前钻头能力系数变为原来的(1-0.01\*k)，那么后面的得到的最大金钱数也变为原来的(1-0.01\*k)\*/)

代码量很少但是思维还是很有难度的qwq

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, f[100005], a[100005];
double c, k, w, dp[100005];
int main(){
    cin>>n>>k>>c>>w;
    for(int i=1; i<=n; i++)
        scanf("%d %d", &f[i], &a[i]);
    for(int i=n; i>=1; i--){
        if(f[i]==1)    dp[i] = max(dp[i+1], a[i]+dp[i+1]*(1-0.01*k));
        else        dp[i] = max(dp[i+1], -a[i]+dp[i+1]*(1+0.01*c));
    }
    printf("%.2lf", dp[1]*w);
    return 0;
}
```

---

## 作者：顾z (赞：38)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[P1412 经营与开发](https://www.luogu.org/problemnew/show/P1412)

## 分析

虽然看到$Rank_1$已经有了解释.

~~但我认为我能BB的更好~~

我还是决定来写一篇题解. qwq

### 列式

根据题意,我们很容易列出式子.(瞎~~j8~~写.

(变量名与题目描述相同.

$a_1 \times w+ (1-0.01 \times k)\times w \times a_2+(1-0.01 \times k)\times w\times(1-0.01\times k)\times a_3+\dots$

其中$(1-0.01 \times k)\times w$代表新的能力值.

提取公因式$w$. (是叫公因式还是公因子?,qwq

**新式子**
$w\times[a_1+ (1-0.01 \times k) \times a_2+(1-0.01 \times k)\times(1-0.01\times k)\times a_3+\dots]$

然后又可以写成这种形式.

$w\times[a_1+ (1-0.01 \times k) \times a_2+(1-0.01 \times k)^2\times a_3+\dots]$

再将$[]$中的式子变形(根据[秦九韶算法](https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196).

得到这样的式子

$w\times[a_1+ (1-0.01 \times k) \times (a_2+(1-0.01 \times k)\times a_3+\dots)]$

然后根据秦九韶一直拆下去.

(下面以$k^{'}$代表$(1-0.01\times k)$

所以我们会得到这样的式子.

$w*[a_1+k^{'}\times(a_2+k{'}\times(a_3+k{'}\times (a_4+\dots)))]$

然后写出来好长好长一段 qwq.

### 然后考虑正解**为什么是倒着枚举**？.

显然,我们从$1-n$枚举星球,钻头会受到影响.

即后面的答案会受到影响.(后效性.

而我们从后向前枚举则可以免去这种影响.(感觉这句话自己说的很虚啊.

如果不理解这句话的话,请回想秦九韶算法也是从里到外地求解.

对应到这个题的话我们就相当于从后向前枚举.

因为秦九韶算法的话,从里到外的拆分会乘上$k^{'}$.(钻头能力值会降低.

**简单来讲的话**

我们通过一直乘上$k^{'}$,最里层的式子,对应的就是我们最后一次使用钻头的情况.
同样,次里层的式子,对应的就是我们倒数第二次使用钻头的情况.

(无法正确组织语言. qwq.

如果不懂的话还是用笔试一下.

这样我们**模拟的就是这个从里向外求解的过程**.



所以我们求出来的一定会是我们的答案.

------------------代码-------------------

```cpp
#include<bits/stdc++.h>
#define R register
using namespace std;
int  n;
double k,c,w;
struct cod{int idx;double cost;}type[100008];
double ans;
int main()
{
	scanf("%d%lf%lf%lf",&n,&k,&c,&w);
	k=1-0.01*k;c=1+0.01*c;//我说我式子一开始带错了你信不信 qwq.
	for(R int i=1;i<=n;i++)
		scanf("%d%lf",&type[i].idx,&type[i].cost);
	for(R int i=n;i>=1;i--)
		if(type[i].idx==1)ans=max(ans,ans*k+type[i].cost);
		else ans=max(ans,ans*c-type[i].cost);
	printf("%.2lf",ans*w);
}
```

---

## 作者：Vin_1999 (赞：34)

这个我对楼下做出点补充，记最终答案为ans，其实对于每个星球不管是维修还是资源型，都可以把对钻头的改变度记作一个常数k，而且k是有后效性的。我们先具一个i=4的例子，ans=w\*k1\*a1+w\*k1\*k2\*a2+w\*k1\*k2\*k3\*a3+w\*k1\*k2\*k3\*k4\*a4,即ans=w\*(k1\*a1+k1\*k2\*a2+k1\*k2\*k3\*a3+k1\*k2\*k3\*a4),进一步提公因式就是ans=w\*(k1\*(a[1]+k2\*(a[2]+k3\*(a[3]+k4\*a[4]))))（这叫什么数学名词来着，蒟蒻忘了），实际上对于每个a[i]，a[i]前还要乘上一个符号变量t（维修+1，资源-1,不选乘0）。即ans=w\*(k1\*(t1\*a[1]+k2\*(t2\*a[2]+k3\*(t3\*a[3]+k4\*t4\*a[4]))))那么我们的题目就变为对每项选择最优的符号变量得出最大的答案值。照楼下的思路我们是要从最里面的括号开始推，确保每次括号里的值都最大。

这是因为我们要求的总问题就是使的w\*(内的值最大)。而每个阶段的决策是ti\*a[i]+ki\*（内的值）。因为后一项肯定为正，由最优子结构性质得（内的值一定是最大值）。这样以来楼下的思路就通了。


---

## 作者：csgc0131123 (赞：8)

/\*题解


对于k=100的情况，贪心


对于100%的数据


可以发现，当前的决策只对后面的开采有影响，且剩余耐久度与之后的开采收益成正比，

如果倒着考虑这个问题，得出i-n的星球1点耐久度所能获得的最大收益，

从后往前dp，得出最大值最后乘w就是答案\*/

/\*这道题目只要能想出倒着处理，一切都迎刃而解了！！\*/

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define N 100010
int flag[N];
double a[N];
int n;
double k,c,w;
double ans=0;
void input()
{
    scanf("%d%lf%lf%lf",&n,&k,&c,&w);
    for(int i=1;i<=n;++i)
    {
        scanf("%d%lf",&flag[i],&a[i]);
    }
    k=(1-0.01*k);
    c=(1+0.01*c);
}
int main()
{
    input();
    for(int i=n;i>=1;--i)
    {
        if(flag[i]==1)
          ans=max(ans,ans*k+a[i]);
        else ans=max(ans,ans*c-a[i]);
    }
    printf("%0.2lf",ans*w);
    return 0;
}
```

---

## 作者：king_xbz (赞：4)

这道题是我们模拟赛的压轴题，作为蒟蒻，我显然是不会的。所以我这只蒟蒻只好去打暴力辽。

## 最裸的暴力

很显然，对于每颗星球情况只有两种状态：开采/修复和啥都不干。那我们就针对这两种状态进行暴力的DFS即可。
可以设x为当前星球，cost为当前收入（+）/支出（-），zuan为目前剩余的能力

```cpp
inline void dfs(int x,double cost,double zuan)
{
	if(x==n)
	{
		ans=max(cost,ans); 
		return ;
	}
	if(tp[x+1]==1)
	{
		dfs(x+1,cost+(double)a[x+1]*zuan,zuan*(1-0.01*k));//开采 
		dfs(x+1,cost,zuan);//不开采 
	}
	if(tp[x+1]==2)
	{
		dfs(x+1,cost-(double)b[x+1]*zuan,zuan*(1+0.01*c));//维修
		dfs(x+1,cost,zuan);//不维修 
	}
	return ;
}
```

注意，有一种剪枝是钻子有能力开采，只在只对剩余钱数为正时维修，这样会1分拿不到的，惨！

复杂度$O(2^n)$，期望得分10pts。

# 贪心的正解

为什么复杂度这么高？显然是状态太多导致。为什么状态这么多？显然是受钻头能力值后效性的影响导致。那么，怎样消除这样的影响呢。事实上，我们初始为w的能力值其实实际上是一个阻碍。假设我们将w设为坐标原点，那么每次的变化都会在原点左右移动。我们不妨将这个原点设为1，在原点之后的能力值便是$1×(1-0.01k)$然后从后往前更新，当遇到两种修改任意一种可以使答案更大时，我们修改便可以更新。我们只要维护$i \ to \  n$的最大值，即可。

代码很短，10行搞定

```cpp
#include<bits/stdc++.h>
double n,k,c,w,a[100001],b[100001],tp[100001],ans;
int main(){
	std::cin>>n>>k>>c>>w;
	for(int i=1;i<=n;i++)
	std::cin>>tp[i],tp[i]==1?std::cin>>a[i]:std::cin>>b[i];
	for(int i=n;i>=1;i--)
	tp[i]==1?ans=std::max(ans*(1-0.01*k)+a[i],ans):ans=std::max(ans*(1+0.01*c)-b[i],ans);
	printf("%.2lf",ans*w);
} 
```
祝大家AC愉快！

---

## 作者：_Grey (赞：4)

# ~~写个题解来纪念我在6.13的爆0评测~~

## 结合题目具体分析一下

### “依次飞过n个星球”，第一反应就是动态规划，然后验证下无后效性即可。

### F[i]表示前i个星球的最优收入。很明显这是不行的，因为当前钻头能力会切实影响到后面的过程，也就是说，当前钻头能力有“后效性”。

### 但是这个当前钻头能力对后程的影响无非就是乘上一个数值。（就好像初始钻头能力为w，实际上你可以按1来做，最后再把ans乘上w）。

### 转移过程就变得简单：如果在第i个星球开采，那么第i+1--n个星球的初始钻头能力就是1*(1-0.01k)。换句话说，就是F[i+1]*(1-0.01k)。

### 也就成了所谓的 

    F[i] = max ( F[i+1] , F[i+1] * ( 1 - 0.01k )+a[i])



------------

下面上代码


    #include <bits/stdc++.h>
    #define maxn 100001
    using namespace std;
    inline int read(){
        int x = 0;char ch = getchar();
        while (!isdigit(ch)) ch = getchar();
        while (isdigit(ch)) x = (x << 3 ) + (x << 1) + ch - '0',ch = getchar();
        return x; 
    }
    int n,w,a[maxn],v[maxn];
    double ans,k,c;
    int main(){
        n = read(); k = read(); c = read(); w = read();
        k = 1 - 0.01*k; c = 1 + 0.01*c;
        for (int i = 1;i <= n; ++i) v[i] = read() , a[i] = read();
        for (int i = n;i >= 1; --i){
        if(v[i] == 1)	ans = max ( ans , ans * k + a[i]);
        else ans = max ( ans , ans * c - a[i]);
        }
        printf ("%.2lf",ans*w);
    }



---

## 作者：悦儿弯弯 (赞：3)

其实看起来没思路，做起来很好做，

ans表示i+1~n的最大收益


如果在i星球挖了矿，则i+1~n的最大收益会下降，即ans\*k


因此比较ans(不挖的状态），ans\*k+a[i]（挖了的状态）的大小


最后乘以w即可

```cpp
program ny001;
var
n,w,i:longint;
k,c,ans:real;
t,a:array[1..100005]of longint;
function max(x,y:real):real;
begin
if x>y then max:=x
    else max:=y;
end;
begin
read(n,k,c,w);
k:=1-0.01*k;
c:=1+0.01*c;
ans:=0;
for i:=1 to n do
    begin
        read(t[i],a[i]);
        readln;
    end;
    for i:=n downto 1 do
        if(t[i]=1)then ans:=max(ans,ans*k+a[i])
            else ans:=max(ans,ans*c-a[i]);
writeln(ans*w:0:2);
end.
```

---

## 作者：MZ_CXQ (赞：2)

[${\color{Pink}{>>my\;blog}}$](https://www.cnblogs.com/mzg1805/p/11425024.html)

这道题是当初考过的模拟题,当时理解得迷迷糊糊的,以至于今天又打一遍

按照常规的思路,从前往后推,每个星球选或不选

但仔细分析,发现这样是有后效性的

为什么呢?我们可以来推一推这个过程

初始为$w$,开采一次后(修复同理)变成$w*(1-\%k)$,假设又开采,金钱+$w*(1-\%k)*a_i$

把后面括起来,即+$w*((1-\%k)*a_i)$

看懂了吗?也就是说每开采一次,相当于后面每个$a_i$都缩小了$\%k$,即后面的问题规模缩小了$\%k$,后面的决策受到了前面的影响

所以我们从后往前推,令$f[i]$表示$i\to n$的最大收入,且$i$的规模为$1$

那么有



$$
f[i] = \left\{
\begin{matrix}
max(f[i+1],a[i]+f[i+1]*(1-\%k)),type = 1\\
max(f[i+1],-a[i]+f[i+1]*(1+\%c)),type = 2
\end{matrix}\right.
$$



最后再$*w$即可(我们算的是问题规模为$1$的$f[1]$)

代码如下
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <vector>
#define ll long long
using namespace std; 

template <typename T> void in(T &x) {
    x = 0; T f = 1; char ch = getchar();
    while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
    while( isdigit(ch)) {x = 10 * x + ch - 48; ch = getchar();}
    x *= f;
}

template <typename T> void out(T x) {
    if(x < 0) x = -x , putchar('-');
    if(x > 9) out(x/10);
    putchar(x%10 + 48);
}
//-------------------------------------------------------------

const int N = 1e5+7;
int n,k,c,w,a[N],t[N];
double f[N];

int main() {
	int i; in(n); in(k); in(c); in(w);
	for(i = 1;i <= n; ++i) in(t[i]),in(a[i]);
	f[n] = t[n] == 1 ? a[n]:0;
	for(i = n-1;i >= 1; --i) {
		if(t[i] == 1) f[i] = max(f[i+1],a[i]+f[i+1]*(1-k*0.01));
		else f[i] = max(f[i+1],-a[i]+f[i+1]*(1+c*0.01));
	}
	printf("%.2lf",f[1]*w);
	return 0;
}

```

---

## 作者：Skyjoy (赞：2)

啊在备考 CSP 之际重新整理一下过去刷过的题

这题还是要动动脑筋的

首先，我们根据题意，可以列出如果全部是1类型且全部选择开采的情况的柿子（其实为了方便打出公式）：

$$a_1\times w+(1-0.01\times k)\times a_2\times w+(1-0.01\times k)^2\times a_3\times w+...$$

当然别的情况的柿子也都是差不多的，至少计算方式和思路是一样的

可是我们发现这样直接算的复杂度是 $O(n^2)$ ，炸掉了，而且在比大小的时候 $w$ 值**不是定的**，那怎么办呢

这时候我们就可以使用我们中国伟大的数学家秦九韶提出的秦九韶算法，可以简化我们的多项式，详情方法自己可以百度查看，我这里就把化出来的结果放出来：

令 $kk=1-0.01\times k$

则

$$w\times(a_1+kk\times (a_2+kk\times (a_3+kk\times ...)))$$

于是我们可以从后往前算，就没有上面的顾虑了！

最后上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
const int N=100010;
using namespace std;
ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,type[N];
double k,c,w,ans,x[N];
int main(){
	scanf("%d%lf%lf%lf",&n,&k,&c,&w);
	k=1-0.01*k,c=1+0.01*c;
	for(int i=1;i<=n;i++)scanf("%d%lf",&type[i],&x[i]);
	for(int i=n;i;i--){
		if(type[i]==1)ans=max(ans,ans*k+x[i]);
		if(type[i]==2)ans=max(ans,ans*c-x[i]);
	}
	printf("%.2lf",ans*w);
	return 0;
}
```
其实本人用快读时一直都会出现一些奇怪的问题，于是就只能用 $scanf$ 了 $QAQ$

# 祝大家 CSP2020rp+=INF ！

---

## 作者：贞白周逸民 (赞：1)

## 引导：

看题的第一步看看测试数据范围，发现很大，这是我们就要想到动态规划。


------------

## 思路：

### 1: 这是我们有一个很简单想到的三维 DP ：f[i][j][k] : i 表示第 i 个数 ，j 表示维修次数， k 开采次数， 表示讨论完所能达到的最大收入。那么显然有状态方程： 

f[i][j][k]=max(f[i−1][j][k],f[i−1][j][k−1]+a[i]∗p),type[i]=1

f[i][j][k]=max(f[i−1][j][k],f[i−1][j−1][k]−b[i]∗p),type[i]=2

### 很明显，是不可取的，因为范围太大了，于是我们要想讲三维压成一维。

### 2: 可以发现，当前的决策只对后面的开采有影响，且剩余耐久度与之后的开采收益成正比，如果倒着考虑这个问题，得出 i - n 的星球 1 点耐久度所能获得的最大收益，从后往前 dp ，得出最大值最后乘 w 就是答案.

### 3：如果正着讨论不够优秀或者难以讨论（正难则反），考虑倒着讨论。注意到如果把答案列式计算下来，可以发现一个乘法分配率的形式，因为每次操作对p的改变都是乘上一个数。所以，如果定义 f[i] 为处理完区间 [i,n] 的星球得到的最大收入，

f[i]=max(f[i+1],(1−0.01k)∗f[i+1]+a[i]),type[i]=1
f[i]=max(f[i+1],(1+0.01c)∗f[i+1]−b[i]),type[i]=2


------------

## 个人建议：

~~DP是玄学，不重要~~，状态转移方程才重要！

```c
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n, a[1000005], f[1000005];
double w, c, k, dp[1000005];
int main()
{
    scanf("%d %lf %lf %lf", &n, &k, &c, &w);
	for (int i = 1; i <= n; i++)
        scanf("%d %d", &f[i], &a[i]);
	
	for (int i = n; i >= 1; i--)
    {
        if (f[i] == 1) dp[i] = max(dp[i + 1], dp[i + 1] * (1 - 0.01 * k) + a[i]);
        else dp[i] = max(dp[i + 1], dp[i + 1] * (1 + 0.01 * c) - a[i]);
    }
    printf("%.2lf", dp[1] * w);
    return 0;
} 
```

---

## 作者：shzaiz (赞：0)

### 题意简述

有一个初始耐久为$w$钻头。给出序列$\{a\},\{b\}$现在有$2$类星球可供停靠：

- $1$类：若当前钻头耐久为$p$,那么消耗$k\%$的耐久，获得$a_i\times p$的金钱。
- $2$类：若当前钻头耐久为$p$,那么获得$c\%$的耐久，消耗$b_i\times p$的金钱。

给定飞船的飞行顺序，选择$n$个星球停靠。

求解最大可以获得的金钱。

### 解答

#### 10$pts$

考虑进行暴力搜索。定义$\text{dfs}(x,\text{money},p)$函数，表示在当前第$x$个星球的时候停靠，现在有$\text{money}$的金钱，钻头的耐久为$p$.

不难得到$\text{dfs}$的方法：
$$
\text{dfs}(x,\text{money},p)\begin{aligned}

&\stackrel{\text{1，开采}}{\longrightarrow} \text{dfs}(x+1,\text{money}+a_{x+1}\times p,p\times(1-k\%))\\
&\stackrel{\text{1，不开采}}{\longrightarrow}  \text{dfs}(x+1,\text{money},p)\\
&\stackrel{\text{2，开采}}{\longrightarrow} \text{dfs}(x+1,\text{money}-b_{x+1}\times p,p\times(1+c\%))\\
&\stackrel{\text{2，不开采}}{\longrightarrow}  \text{dfs}(x+1,\text{money},p)\\

\end{aligned}
$$
注意，这里是一步一步枚举的。由于获得的金钱与钻头的耐久有关，那么我们发现从前往后没有办法设计没有后效性的状态。

您可以在[这里](https://paste.ubuntu.com/p/FD2Q89YPg2/)看到一份暴力代码。

#### 过渡

如果您曾做过[尼克的任务](https://www.luogu.com.cn/problem/P1280)，您会发现，如果我们假设$f[i]$为$1\sim i$的最大空闲时间，您会发现第$i$时刻的空闲时间依赖于$i+1$时刻的空闲时间。

因而，我们可以想到要倒着搜索。这一点您可以在上题题解区域更加深入地理解。

现在，我们面临着同样的问题。

#### 100$pts$

由于是否选择一个星球影响后续操作而不影响前驱操作，我们尝试借鉴[过渡](#过渡)中的思路，假设刚开始的耐久度为$1$, 从后往前考虑。

仔细考虑一下，剩余耐久度与之后的开采收益成正比，倒序考虑是没问题的。

- 定义$f[i]$为$i \to n$的时候最大的花费。那么：
  - 如果$\text{type}[i]=1$, 那么: $f[i]=\max\{f[i+1],a[i]+f[i+1]\times(1-k\%)\}$
  - 如果$\text{type}[i]=0$, 那么: $f[i]=\max\{f[i+1],-b[i]+f[i+1]\times(1+c\%)\}$

钻头的每次挖/修修改的百分比恒定，也就是说其更改只与挖/修的次数有关，即是说初始能力和最大花费之间成一定比例。

那么$f[1]\times w$即为答案。

```cpp
#include <bits/stdc++.h>
#include <iomanip>
#define D double
using namespace std;
#define MAXN 100010
D c,w,n,k,a[MAXN];
int t[MAXN];
double f[MAXN];
D ans = 0;
int main(){
	cin>>n>>k>>c>>w;
	for(int i=1;i<=n;i++) cin>>t[i]>>a[i];
	for(int i=n;i>=1;i--){
		if(t[i]==1) f[i] = max((D)f[i+1],(D)a[i]+(D)f[i+1]*(1-0.01*k));
		else if(t[i]==2) f[i] = max((D)f[i+1],(D)-a[i]+(D)f[i+1]*(1+0.01*c));
	}
	cout<<fixed<<setprecision(2)<<f[1]*w;
	return 0;
}
```

### 回顾

该题要向正确的解答需要了解状态之间的转移关系。

如果我们简化题目中数据，每次到访一个星球，会让稿子耐久更改$k$. 并且我们每次按照资源类型处理$a$, 设置函数$g(a)$，使得：
$$
g(x) = \{\begin{aligned}
& x & \text{选择，如果是资源型} \\ & -x & \text{选择，如果是维修型} \\
& 0 & \text{不选}
\end{aligned}
$$


我们最终的答案$ans$等于：
$$
ans=w*(k_1*\mathbf{(g(a[1])} +k_2*\mathbf{(g(a[2])}+k_3*\mathbf{(g(a[3])}+k_4*\mathbf{(g(a[4])}+k_5*\mathbf{g(a[5])}*(\cdots+k_n*\mathbf{g(a[n])})\cdots))))
$$
$k$是一个定值，要求得刚刚的定值，我们就从数学的角度了解了倒着求解的原理。

**如果有任何问题，请私信作者。感谢阅读。**

$\color{green}\texttt{</>} \qquad\text{Micoael_Primo}$







---

## 作者：SamariumPhosphide (赞：0)

神仙题。我们注意到，无论是钻头能力的变化，还是收入的变化，都是按照比例增大的，因此我们**无论最初能力值为多少**，每个星球上的决策一定不会变化。因此如果星球保持不变，最开始的能力值与最后的金额成正比。

这就解决了能力值为 double 格式，无法记录的问题，因为我们可以通过记录能力值为 1 的情况而推出任意一种能力值的情况。

比如说，从 $x$ 号星球出发，能力值为 $1$，最后总收入为 $s$；则若将能力值改为 $t$，则总收入相应变为 $s \times t$。

因此我们设 $dp[i]$ 为从 $i$ 号星球出发，此时能力值为 $1$ 那么最后总收入最大是多少。

分两种情况：
+ 维修性：$dp[i] = \max\{dp[i+1], dp[i+1] \times (1+c \times 0.01) - b[i]\}$
+ 资源性：$dp[i] = \max\{dp[i+1], dp[i+1] \times (1-k \times 0.01) + b[i]\}$

---

## 作者：Martian148 (赞：0)

### 题目链接
[题解 P1412 【经营与开发】](https://www.luogu.com.cn/problem/P1412)
### solve
看到题目，第一感觉就是动态规划，于是可以分析一下题目

$ans=a_1* w + (1-0.01k)* w * a_2+(1-0.01k) * (1-0.01k)* w * a_3+...$

$\Rightarrow w*[a_1+(1-0.01k)* a_2+(1-0.01k)^2+...]$

$\Rightarrow w* [a_1+(1-0.01k]* (a_2+(1-0.01k)* a_3...)]$

于是我们可以从最里面开始推，也就是反着推每次乘上(1-0.01k)即可。

我们定义F[i]表示后i+1个处理完了，现在处理第i个

转移方程就很简单了

无非就是一个钻或不钻(维修或不维修)的问题


$F[i] = max(F[i+1], a[i]+F[i+1]*(1-0.01*k))$


因为是反过来处理，所以最后答案就是$F[1]$。

### code 

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,a[100005],c,k,w,vis[100005];
double F[100005];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
    n=read(),k=read(),c=read(),w=read();
    for(int i=1; i<=n; i++)vis[i]=read(),a[i]=read();
    for(int i=n; i>=1; i--){
        if(vis[i]==1)    F[i] = max(F[i+1], a[i]+F[i+1]*(1-0.01*k));
        else        F[i] = max(F[i+1], -a[i]+F[i+1]*(1+0.01*c));
    }
    printf("%.2lf", F[1]*w);
    return 0;
}
```

---

## 作者：xiaohuang (赞：0)

[更好阅读体验](https://xiaohuang888.github.io/2019/12/11/%E3%80%8CLuogu%201412%E3%80%8D%E7%BB%8F%E8%90%A5%E4%B8%8E%E5%BC%80%E5%8F%91/)

### Solution

很容易想到是动态规划，按题目说的，我们分为两种情况，分别为$\rm type = 1$和$\rm type = 2$，但是如果直接顺序进行$\rm dp$，发现存在后效性，无法直接确定答案，所以我们倒着来，转移方程分别为：

1. 当$type = 1$时：$\rm dp[i] = \max(dp[i + 1], a[i] + dp[i + 1] * (1 - 0.01 * k))$

2. 当$type = 2$时，$\rm dp[i] = max(dp[i + 1], -a[i] + dp[i + 1] * (1 + 0.01 * c))$

答案就是$\rm dp[1]$。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

const int MAXN = 100005;
int n, k, c, w, typ[MAXN], a[MAXN];
double dp[MAXN];
int main() {
    scanf("%d%d%d%d", &n, &k, &c, &w);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &typ[i], &a[i]);
    memset(dp, 0, sizeof(dp));
    for (int i = n; i; i--)//注意倒着枚举
        if (typ[i] == 1) dp[i] = max(dp[i + 1], a[i] + dp[i + 1] * (1 - 0.01 * k)); else dp[i] = max(dp[i + 1], -a[i] + dp[i + 1] * (1 + 0.01 * c));//转移
    printf("%.2lf\n", dp[1] * w);//乘以初始的能力值
    return 0;
}
```

---

## 作者：abandentsky (赞：0)

思路：我是看了楼下大佬题解写到的。楼下大佬说的特别好，但是推导好像有点问题。我们设ans为能够获得最大金币数；则：
ans=W*a1+W*k1*a2+W*k1*k2*a3+W*k1*k2*k3*a4;
然后我们合并一下变成这个样子：
ans=W*[t1a1+k1(t2a2+k2(t3a3+k3(t4a4)))]
其中t表示取还是不取，就比如对于矿物性的，我们考虑挖还是不挖，如果挖就是1，不挖就是0.对于修理性的，1就是修理，0就是不修理。
这样就可以发现状态为dp[i]=max(dp[i+1],dp[i+1]*(1-0.01*k)+a[i])这是挖矿的，还有就是修理的dp[i]=max(dp[i+1],dp[i+1]*(1+0.01*c)+a[i])这是修理的。从后往前转移。这样就没有后效性了。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 100005
#define INF 0x3f3f3f3f
using namespace std;

int a[MAXN],b[MAXN];
double dp[MAXN];
int n,k,c,w;

int main()
{
    scanf("%d %d %d %d",&n,&k,&c,&w);
    for(int i=1;i<=n;i++)
    {
        scanf("%d %d",&a[i],&b[i]);
    }
    for(int i=n;i>=1;i--)
    {
        if(a[i]==1)
            dp[i]=max(dp[i+1],dp[i+1]*(1-0.01*k)+b[i]);
        else
            dp[i]=max(dp[i+1],dp[i+1]*(1+0.01*c)-b[i]);
    }
    printf("%.2lf\n",dp[1]*w);
    return 0;
}

```


---

## 作者：doby (赞：0)

这题我在组内的模拟测试见过了两次QvQ

可以用f[i][j][k]表示到达第i个星球，且之前开采过j次，维修过k次，此时的钻头能力即为w(k^j)(c^k)，此时即可得出一个O(n^3)的做法

这题主要难点在于当前的钻头能力难以得出并处理，某种意义上当前的钻头能力**可能**具有后效性……

正难则反，如果从n到1地进行DP，那么可以消除这个类似后效性的数值的作用

即f[i]表示i到n所能获得的最大收入并且假设当前的钻头能力为1

则有状态转移方程f[i]=max(f[i+1],(f[i+1]*(1-0.01*k)+b[i]))(a[i]=1);f[i]=max(f[i+1],(f[i+1]*(1+0.01*c)-b[i]))(a[i]=2)

此时答案即为f[1]*k
```cpp
#include<cstdio>
using namespace std;
int n,a[500010];
double k,c,w,b[500010],f[500010];
double max(double a,double b)
{
	return a>b?a:b;
}
int main()
{
	scanf("%d%lf%lf%lf",&n,&k,&c,&w);
	for(int i=1;i<=n;++i){scanf("%d%lf",&a[i],&b[i]);f[i]=-12960718.0;}//初始化
	for(int i=n;i>=1;--i)
	{
		if(a[i]==1){f[i]=max(f[i+1],(f[i+1]*(1-0.01*k)+b[i]));}
		else{f[i]=max(f[i+1],(f[i+1]*(1+0.01*c)-b[i]));}
	}
	printf("%.2f",(f[1]*w));
	return 0;
}
```

---

## 作者：日月影 (赞：0)

正解楼下有，我就说一下那50分的暴力吧

定义f[i][j]为开采i次，修理j次的最大收益。

那么就有方程   f[ i ][ j ] = f[ i-1 ][ j ] +c[ j ] \* p[ i -1 ] \* w \*a[ i ]  and

f[ i ][ j ] = f[ i ][ j - 1 ] +c[ j - 1 ] \* p[ i ] \* w \*b[ i ]

c [ j ]表示修理j次钻头的变化

p [ i ]表示开采i次钻头的变化

即c [ j ]=c[ j - 1] \*( c /100 )  p[ i ]=p [i -1 ]\*(p / 100)

”****参考**** （不完整）    代码如下：




                 
```cpp
int n,k,cc,w;
struct data
{
    int t,x;
}p[100100];
double f[110][110];
double pp[110];
double c[100010];
int a[110],b[1100];
double ff[100010];
    scanf("%d%d%d%d",&n,&k,&cc,&w);
    if(k==100)
    {
                for(int j=0;j<=n;j++)
                {
                    ff[j]=-1.34218e+100;
                }
            c[0]=1.0;
            for(int i=1;i<=n;i++)
            {
                c[i]=c[i-1]*(double)(1+(double)cc/100.0);
            }
            double maxx=0.0;
             for(int i=1;i<=n;i++)  
             {
               scanf("%d%d",&p[i].t,&p[i].x);
               if(p[i].t==1)  b[i]=b[i-1];
               else  b[i]=b[i-1]+1;
             }
             ff[0]=0.0;
             for(int i=1;i<=n;i++)
             {
                     for(int k=b[i];k>=0;k--)
                     {
                         if(p[i].t==1)
                         {
                             maxx=max(ff[k]+(double)w*c[k]*p[i].x,maxx);
                             //cout<<ff[k]<<' '<<(double)w<<' '<<c[k]<<' '<<p[i].x<<' '<<maxx<<endl;
                         }
                         else
                         {
                             if(k==0)  continue;
                             ff[k]=max(ff[k],ff[k-1]-(double) w*c[k-1]*p[i].x);    
                             //cout<<ff[k]<<' '<<k<<' '<<c[k-1]<<' '<<p[i].x<<"aaa"<<endl;    
                         }
                     }
                 }
                 printf("%0.2lf\n",maxx);
             }
 else{
        if(n<=100)
        {
            for(int i=0;i<=n;i++)
            {
                for(int j=0;j<=n;j++)
                {
                    f[i][j]=-0x7ffffff*1.0;
                }
            }
            pp[0]=1.0;c[0]=1.0;
            for(int i=1;i<=n;i++)
            {
                pp[i]=pp[i-1]*(double)(1-(double) k/100.0);
                c[i]=c[i-1]*(double)(1+(double)cc/100.0);
            }
            double maxx=0.0;
             for(int i=1;i<=n;i++)  
             {
               scanf("%d%d",&p[i].t,&p[i].x);
               if(p[i].t==1)  a[i]+=a[i-1]+1,b[i]=b[i-1];
               else  b[i]=b[i-1]+1,a[i]=a[i-1];
             }
             f[0][0]=0.0;
             for(int i=1;i<=n;i++)
             {
                 for(int j=a[i];j>=0;j--)
                 {
                     for(int k=b[i];k>=0;k--)
                     {
                         if(p[i].t==1)
                         {
                             if(j==0)  continue;
                             f[j][k]=max(f[j][k],f[j-1][k]+(double) w*pp[j-1]*c[k]*p[i].x);
                             maxx=max(f[j][k],maxx);
                         }
                         else
                         {
                             if(k==0)  continue;
                             f[j][k]=max(f[j][k],f[j][k-1]-(double) w*pp[j]*c[k-1]*p[i].x);        
                         }
                     }
                 }
             }
             printf("%0.2lf\n",maxx);
        }

```

---


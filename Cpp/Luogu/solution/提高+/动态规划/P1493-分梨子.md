# 分梨子

## 题目描述

Finley 家的院子里有棵梨树，最近收获了许多梨子。于是，Finley 决定挑出一些梨子，分给幼稚园的宝宝们。可是梨子大小味道都不太一样，一定要尽量挑选那些差不多的梨子分给孩子们，那些分到小梨子的宝宝才不会哭闹。

每个梨子都具有两个属性值，$A_i$ 和 $B_i$，本别表示梨子的大小和甜度情况。假设在选出的梨子中，两个属性的最小值分别是 $A_0$ 和 $B_0$。只要对于所有被选出的梨子 $i$，都满足 $C_1 \times (A_i-A_0)+C_2 \times (B_i-B_0) \le C_3$（其中，$C_1,C_2$ 和 $C_3$ 都是已知的常数），就可以认为这些梨子是相差不多的，可以用来分给小朋友们。

那么，作为幼稚园园长的你，能算出最多可以挑选出多少个梨子吗？

## 说明/提示

### 样例说明

可以选择 $1,3$ 两个梨子或者 $2,3$ 两个梨子。


## 样例 #1

### 输入

```
3
2 3 6
3 2
1 1
2 1
```

### 输出

```
2
```

# 题解

## 作者：__stick (赞：16)

# 题意
 $n$ 个梨子，每个梨子有两个参数 $a_{i},b_{i}$ ，给出三个参数 $ c_{1},c_{2},c_{3}$ ，选择若干个梨子使得对于选择的每个梨子 $i$ 都满足
 
 $$ c_{1} (a_{i}-a_{0})+c_{2} (b_{i}-b_{0}) \le c_{3} $$
 其中 $a_{0},b_{0}$ 是所有选择的梨子中的最小的 $a  /\  b$。
 

 # 想法
 
 这里提供一个 $\ O( n^{2} \log n \ )$ 的做法，不是很优秀，但是好想。
 
  首先是将公式移项，讲已知的放到一边，得：
  $$ c_{1} \times a_{i}+c_{2}\times b_{i} \le c_{3}+c_{2} \times b_{0}+c_{1} \times a_{0}  $$
  
  这样的话我们会发现只要所选出的 $\ a_{i},b_{i} \ $ 的最小值确定了，右边就是一个常数，为叙述方便记这个数为 $k$。问题也就变成了求给出题目中满足小于某定值的数的个数，所以我们考虑 枚举最小值 $a_{0},b_{0}$ ，再去一一检查数列中满足 $a_{i} \ge a_{0} \wedge b_{i} \ge b_{0} \wedge c_{1}\times a_{i}+c_{2}\times b_{i} \le k $ 的数的个数，复杂度显然是 $O(n^{3})$ ，不能接受，考虑优化。
  
 首先优化枚举的复杂度，由于不关心顺序，我们完全可以排序，我们先按 $a$ 从小到大排序，再依次枚举，就确定了 $a_{0}$， 那 $b_{0}$ 怎么办呢？我们会发现，其实我们关心的只是最小值，其他的都不会影响答案，所以我们可以~~骚气~~的对枚举到的 $a_{0}$ 后边的数组以 $b$ 为关键字进行降序排序，就又保证了 $b_{0}$ 的有序性，这样复杂度就能降下来了，为什么呐？
 
 我们想一下，既然我们已经确定了 $a_{0}$ ，那 $\ k\ $ 其实就是一个关于 $\ b_{0}$ 的一次函数，如果 $\ b_{0}\ $ 单调递减，那么 $k$ 也是单调递减的，那我们就能利用这个性质，如果一个梨子 $i$ 所算出来的值已经大于当前的 $k$ 那它在枚举下一个  $b_{0}$ 时一定也会大于所计算出来的 $k$（因为 $k$ 单调减）我们直接舍弃，所以我们用大根堆维护选择的梨子 枚举 
 $b_{0}$ 时讲当前题目的值压入堆，再弹出不合法的值，最后就是可选择的题目了，复杂度明显是 $\ O(n^{2} \operatorname{log}n)$，$n=2000$ 完全能过 ~~（吸氧才能过）~~。
 
  [代码](https://www.luogu.com.cn/paste/i1rp1oha)

---

## 作者：I_AM_HelloWord (赞：16)

哇，蒟蒻又来一发镇楼的题解啦！

反正蒟蒻没推出dp式子，但是把不等式化一化，然后弄个排序暴力模拟均摊N^2的效率跑过去了。

简单的讲一件怎么搞吧。

首先根据题意：c1\*(ai-a0)+c2\*(bi-b0)<=c3

---->c1\*ai+c2\*bi-c3<=c1\*a0+c2\*b0

显然，不等式的左边是关于i的一个常数，弄个数组d先保存好。然后我们来看看怎么处理右边。

我们常规的思路就是：枚举a0,b0(n^2),然后再暴力统计一下(n)，总的O(n^3)，我们借鉴一下单调队列优化dp的思路，考虑直接枚举a0，但是把b0排序好，然后按某种方式统计，看看能否提高效率。

先从理论上分析是否有提高的可能性：首先d数组必须要排序，由于d数组的单调不下降性，所以b0枚举如果是有序的，那么是可以节省一些时间的！

再来仔细分析一下怎么来优化：我们先一层循环枚举a0，然后一层循环枚举b0，然后一层循环在d数组统计答案。

显然，如果我们枚举到一个a0[i],b0[j],当枚举到d[k]时，不等式不成立了，那么另一句话就是从1...k-1不等式都是成立的，那么我们计算b0[j+1]的结果时，只有在原b数组中1....k-1中大于b0[j+1]的数字是不合法的，然后直接从k到n继续判断d[k]是否能使不等式成立就行了，

这时就是一个类似单调队列优化dp的过程了！

先给一段伪代码：

for i=1 to n

    for j=1 to n

      for k=k to n

第三层循环的k是不下降的，所以最多只会在j的循环下枚举n次（均摊意义），所以总的就是O(n\*n)的了！

那么如何维护一下1....k-1中大于某个数的数字个数呢？

想到逆序对没有？对呀，树状数组不就好了？

不过更巧妙的，由于我们这里有了一层循环，并且b0的枚举是有序的，我们直接开个桶，累计每个数字使用的次数，然后累加时把小于当前数字桶中的全减掉，然后把那个数字的桶清空，防止重复减就行了！

当然，想不到桶的做法也是没有关系的，毕竟n只有2000，用树状数组logn=11，那么就是2000\*2000\*11=4.4\*10^7。还是可以过的哟

(＾Ｕ＾)ノ~ＹＯ

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=2010;
struct Pear{
    int v,idx;
    bool operator < (const Pear &rhs) const{
        return v<rhs.v;
    }
    Pear(int v=0,int idx=0):v(v),idx(idx){}
}c[N],d[N];
int a[N],b[N],sum[N];
int n,c1,c2,c3;
int main(){
    scanf("%d%d%d%d",&n,&c1,&c2,&c3);
    //c1*(ai-a0)+c2*(bi-b0)<=c3
    //c1*ai+c2*bi-c3<=c1*a0+c2*b0
    for (int i=1;i<=n;i++){
        scanf("%d%d",&a[i],&b[i]);
        c[i]=Pear(b[i],i);
        d[i]=Pear(a[i]*c1+b[i]*c2-c3,i);
    }
    sort(c+1,c+n+1);sort(d+1,d+n+1);
    int res=0;
    for (int i=1,ans=0;i<=n;i++,ans=0){
        memset(sum,0,sizeof(sum));
        for (int j=1,k=0;j<=n;j++){
            for (;k<=n && d[k].v<=c1*a[i]+c2*c[j].v;k++){
                if (a[d[k].idx]>=a[i] && b[d[k].idx]>=c[j].v){
                    ans++;
                    sum[b[d[k].idx]]++;
                }
            }
            ans-=sum[c[j-1].v];
            sum[c[j-1].v]=0;
            res=max(res,ans);
        }
    }
    printf("%d",res);
    return 0;
}

```

---

## 作者：_J_C_ (赞：8)

**~~这是一道DP题吗……为什么有DP的标签………………~~**

暴力过了……

首先，我们发现，**如果一种方案中最小值定了，我们只需要枚举每个梨子是否满足条件**，即两个权均大于等于各自的最小值，并且满足题目中的等式，**就能够知道这种选法的最大值**。

我们令数组dp[x][y]表示第一个权为x，第二个权为y时的最大值（为什么叫dp呢……其实本来我以为会找出dp方程的）

每次输入，我们都暴力枚举x,y判断能否满足——**固定x，尝试移动y**。如果这个梨可以在这个方案中，++dp[x][y]

这是50分的，之后有优化、

```cpp
#include <cstdio>
#include <cstdlib>

int n;
long long a, b, c;
long long val[2123][2];

int dp[2123][2123];
int ans(0);
int main()
{
    scanf("%d%lld%d%lld", &n, &a, &b, &c);
    for (int i(0); i != n; ++i)
    {
        scanf("%lld%lld", &val[i][0], &val[i][1]);
        int x(val[i][0]), y(val[i][1]);//x即第一个权值的最小值，y即第二个权值的最小值
        while (x != 0)
        {
            if (b != 0) y = (a*(val[i][0] - x)+b*val[i][1]-c)/b;//y的最小值，由题目等式得到；实际上不一定可以取到（原因是int除法向下取整）
            else y = val[i][1];
            while (y <= val[i][1])
            {
                if (a*(val[i][0] - x)+b*(val[i][1] - y) <= c)//判断x,y是否满足条件
                    ++dp[x][y];
                if (dp[x][y] > ans) ans = dp[x][y];
                ++y;
            }
            --x;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

# ~~爽！50分到手~~

不不不，AC才是我们的目标……接下来考虑优化。

对于固定的x，我们发现其实y有**单调性**：如果y越大，即越接近输入的第二个权值，那么等式左边就越小，等式也越可能成立。

对于单调性……我们可以去**二分y**，使得y**直接到达一个满足不等式的值。**

修改后的代码如下：

```cpp
#include <cstdio>
#include <cstdlib>

int n;
long long a, b, c;
long long val[2123][2];

int dp[2123][2123];
int ans(0);
int main()
{
    scanf("%d%lld%d%lld", &n, &a, &b, &c);
    for (int i(0); i != n; ++i)
    {
        scanf("%lld%lld", &val[i][0], &val[i][1]);
        int x(val[i][0]), y(val[i][1]);
        while (x != 0)
        {
            int l((a*(val[i][0] - x)+b*val[i][1]-c)/b), r(val[i][1] + 1);
            if (l < 0) l = 0;
            while (r > l)
            {
                int mid((l + r) / 2);
                if (a*(val[i][0] - x)+b*(val[i][1] - mid) <= c)//满足条件
                {
                    y = mid;
                    r = mid;//尝试获取更小的y
                }
                else
                {
                    l = mid + 1;
                }
            }
            
            while (y <= val[i][1])//那么区间[y,val[i][1]]都是满足条件的y的取值
            {
                ++dp[x][y];
                if (dp[x][y] > ans) ans = dp[x][y];
                ++y;
            }
            --x;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

如果你真的把上面的代码拿去交……你会发现只有TM70分。。

# ~~其实够本了，不做了~~

其实距离AC**还有一个优化**，就是在确定y后，我们知道区间[y,val[i][1]]都是满足条件的。
### 然后我们就把dp一个一个加了过去……
O(**n**)，暴力的不行啊。

对，**区间加法**，而且加的还是同一个数哦。

~~马上想到线段树，树状数组~~

对于区间加法，我们修改dp的定义，将它的定义改成原来dp数组的**差分**……即新的**dp'[i][j] = dp[i][j] - dp[i][j - 1]**，特殊的，**dp'[i][0] = dp[i][0]**

注意，很容易得到dp'[x][y]的前缀和即dp[x][y]（差分是前缀和的逆操作）

那么，对于区间[l,r]的+1，就可以转换为++dp'[x][l]与--dp'[x][r+1]了！

还有一个非常重要的注意点……这会导致你50分（WA)，我交了7、8次才找出来。**下面代码中会有注释标出的**。

真·AC代码:

```cpp
#include <cstdio>
#include <cstdlib>

int n;
long long a, b, c;
long long m1, m2;
int dp[2123][2123];
int ans(0);
int main()
{
    scanf("%d%lld%d%lld", &n, &a, &b, &c);
    for (int i(0); i != n; ++i)
    {
        long long v1, v2;
        scanf("%lld%lld", &v1, &v2);
        if (v1 > m1) m1 = v1;
        if (v2 > m2) m2 = v2;
        int x(v1), y(v2);
        
        while (x != 0)
        {
            int l((a*(v1 - x)+b*v2-c)/b), r(v2 + 1);
            if (l < 0) l = 0;
            while (r > l)
            {
                int mid((l + r) / 2);
                if (a*(v1 - x)+b*(v2 - mid) <= c)
                {
                    y = mid;
                    r = mid;
                }
                else
                {
                    l = mid + 1;
                }
            }           
            if (y <= v2 + 1)//判断范围……不判断可能会出事情
            {
                ++dp[x][y];//差分
                --dp[x][v2 + 1];
            }
            y = v2 + 1; //这一步必不可少！！
                        //如果你不更新y为一个无效值（越大越好，至少大于v2），那么如果下次二分找不出有效的y值，就会使用上次的y值！而上次的y值对于现在的x已经没有意义了……
                        //当然……如果你的y定义在这个循环内并且初始化为一个无效值……那么就当没看见我这三行注释……
            --x;
        }
    }
    for (int i(0); i <= m1; ++i)
    {
        int sum(0);
        for (int j(0); j <= m2; ++j)
        {
            sum += dp[i][j];//前缀和获得原dp数组
            if (sum > ans) ans = sum;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：Uuuuuur_ (赞：7)

我是被《算法竞赛》上的二分练习骗过来的。

所以一开始我就在想怎么二分。

我尝试二分 $A_0$，突然发现这不太能二分的样子。

不过我汲取到了一个思路，就是可以枚举 $A_0$，然后去算最优方案。

在选择中，首先得满足 $A_i \le A_0$，然后，对于一个 $i$，$C_1(A_i-A_0)+C_2(B_i-B_0) \ge C_3$ 中只有 $B_0$ 一个变量，所以可以把它变换一下，得到

$$\lceil B_i - \frac{C_3-C_1(A_i-A_0)}{C_2}\rceil \le B_0 \le B_i$$
对于每个 $i$，这个区间都是定的。那么问题就转化成了区间最多覆盖点，差分数组可以完美地解决这个问题（但是因为建立在值域上，复杂度太高了，我们稍后讨论它的优化）。

还有一个限制，$B_0$ 必须存在于选择的 $B_i$ 之中，我们可以把这几个区间按照右端点（即 $B_i$）从大到小排个序。

![](https://cdn.luogu.com.cn/upload/image_hosting/20t2k1er.png)

你会发现这张图的精髓，按右端点从大到小排序后，每一次选择就是选择**图上的**左端点，然后将覆盖数 $+1$，并把右端点加入优先队列，如果当前左端点小于队头，不断弹出并覆盖数 $-1$。我们无形之中就完成了优先队列对差分数组的优化。


复杂度是 $O(n^2\log n)$，要吸氧。

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
struct node {
    ll a;
    ll b;
};
node f[2005];
int n;
int ans;
ll c1, c2, c3;
bool cmp(node x, node y) {
    return x.a < y.a;
}
bool cmp2(node x, node y) {
    return x.b > y.b;
}
void update(int x) {
    node t[2005];
    int cnt = 0;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (f[i].a >= x) {
            ll m = f[i].b - (c3 - (f[i].a - x) * c1) / c2;
            if (m <= f[i].b) {
                t[++cnt] = {m, f[i].b};
            }
        }
    }
    priority_queue<ll> q;
    sort(t + 1, t + 1 + cnt, cmp2);
    for (int i = 1; i <= cnt; i++) {
        while (!q.empty() && q.top() > t[i].b) {
            sum--;
            q.pop();
        }
        sum++;
        q.push(t[i].a);
        ans = max(ans, sum);
    }
}
int main() {
    scanf("%d", &n);
    scanf("%lld%lld%lld", &c1, &c2, &c3);
    for (int i = 1; i <= n; i++) {
        scanf("%lld%lld", &f[i].a, &f[i].b);
    }
    for (int i = 1; i <= n; i++) {
        update(f[i].a);
    }
    cout << ans;
    return 0;
}
```


---

## 作者：_ZSR_ (赞：6)

## [P1493 分梨子](https://www.luogu.com.cn/problem/P1493)
看到题目中给出的不等式，可以发现，我们只要确定了 $A,B$，那么便可以求出答案。于是便想到枚举 $A,B$。但是两重循环枚举就已经是 $O(n^2)$ 的了，我们计算还需要 $O(n)$ 的时间，总的时间复杂度是 $O(n^3)$ 的，这显然无法通过。

继续想，于是便想到将题目中的不等式化简一下可以得到什么。
$$C_1 \times A_i+C_2 \times B_i \leq C3+C_1 \times A_0+C_2 \times B_0$$

这样看来还是感觉没有什么特殊的地方。但是，题目中说 $A_0,B_0$ 是最小的，那么我们还有两个不等式
$$A_i \geq A_0,B_i \geq B_0$$

看到三个不等式，那是不是 CDQ 分治呢？CDQ 分治是 $a_i \geq a_j,b_i \geq b_j,c_i \geq c_j$ 的形式。为尽量贴近这样的形式，我们令 $X_i=C_1 \times A_i+C_2 \times B_i$。但是现在还有一个问题，那就是 $A_0,B_0$ 不一定是同一个下标，这怎么办呢？是不是不是 CDQ 分治呢？其实这是可以解决的，我们只要同时枚举到 $A_0,B_0$ 那不就相当于它们是同一下标的吗？

具体来说，我们将序列先按照 $A_i$ 从大到小排序，那么当我们从 $1$ 枚举到 $n$ 的时候，当前枚举到的 $A_i$ 就是最小的。类似的，我们开一个 `multiset`，记为 $S$。在我们从 $1$ 枚举到 $n$ 的过程中，每枚举到一个数（这里的数是一个包含 $A,B,X$ 的结构体），我们就将它丢入 $S$ 中，$S$ 内部按照 $B$ 从大到小排序。然后枚举 $S$ 中的每一个数，那么当前枚举到的数 $j$，它的 $B$ 就是最小的。这样我们就保证了 $A_0,B_0$ 是一起枚举到的。

那么剩余的就按照 CDQ 分治的做法就行了，还有一些细节看代码注释。

code

```
#include <bits/stdc++.h>
using namespace std;
const int N=2010;
typedef long long ll;
int n,c1,c2,c3,tot;
ll res;
ll b[N],c[N];
struct Node{
    ll a,b,c;
    bool operator< (const Node& t) const
    {
        return b>t.b;
    }
}node[N];
bool cmp(Node a,Node b)
{
    return a.a>b.a;
}
multiset <Node> s;
inline int get(ll x)
{
    return lower_bound(b+1,b+tot+1,x)-b;
}
inline int lowbit(int x)
{
	return x & -x;
}
inline void add(int x,int y)
{
    for (int i=x;i<=n;i+=lowbit(i)) c[i]+=y;
}
inline ll query(int x)
{
    ll res=0;
    for (int i=x;i;i-=lowbit(i)) res+=c[i];
    return res;
}
int main()
{
    scanf("%d%d%d%d",&n,&c1,&c2,&c3);
    for (int i=1;i<=n;++i) scanf("%lld%lld",&node[i].a,&node[i].b);
    sort(node+1,node+n+1,cmp);//开始按照A从大到小排序 
    for (int i=1;i<=n;++i)
    {
        node[i].c=c1*node[i].a+c2*node[i].b;//这里的C就是前面说的X 
        b[++tot]=node[i].c;
    }
    //C要进行离散化，因为1e9*2000是会超出int范围的 
    sort(b+1,b+tot+1);
    tot=unique(b+1,b+tot+1)-b-1;
    for (int i=1;i<=n;++i) node[i].c=get(node[i].c);
    for (int i=1;i<=n;++i)
    {
        s.insert(node[i]);
        memset(c,0,sizeof(c));//初始化树状数组 
        for(auto j=s.begin();j!=s.end();++j)
        {
            auto now=*j;
            //CDQ分治 
            add(now.c,1);
            ll d=c3+c1*node[i].a+c2*now.b;
            ll t=get(d);
            //因为我们默认d在b数组里没有出现，那么二分找到的就是后一个数，
			//因此query的时候-1。但是如果d在b数组中已经出现了，那么就不需
			//要-1，这个时候就要把1加回来 
            t+=b[t]==d;
            res=max(res,query(t-1)); 
        }
    }
    printf("%lld\n",res);
    return 0;
}
```


---

## 作者：LJ07 (赞：3)

## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P1493)

## 微薄の福利

事实证明本题除 $C3$ 外的所有数据均小于 $2000$。

## 思路简述

+ 套路的，先将梨子以 $B_i$ 为第一关键字， $A_i$ 为第二关键字排序。具体地，按照 $B_i$ **升序**排序，当 $B_i$ 相同时，按照 $A_i$ **降序**排序。看到 $n$ 的数据范围不太大，于是考虑枚举具体的最大最小值进行求解。
+ 问题就转化成了求 $\max_{i=1}^n\max_{j=i}^n\sum_{k=i}^n[A_k-\frac{(B_k-B_i)\times C_2-C_3}{C_1}\le A_j\le A_k]$。注意此时第 $i$ 个梨子一定要满足 $A_i-\frac{(B_k-B_i)\times C_2-C_3}{C_1}\le A_j\le A_i$。
+ $O(n^2\log n)$ 的做法已经烂大街了。那有没有针对此题的超水数据，更优，更好写的做法呢？
+ 不妨设如果此时选择第 $j$ 个梨子的 $A_j$ 为 $A_0$ ，那么可以选择的梨子个数为 $f_j$。
+ 那么对于第 $i+1$ 到第 $n$ 个梨子 $k$，将 $f_{[A_k-\frac{(B_k-B_i)\times C_2-C_3}{C_1}]\texttt{到}A_k}$ 全部加上1。
+ 对于第 $i$ 个梨子要特殊判断，因为
>第 $i$ 个梨子一定要满足 $A_i-\frac{(B_k-B_i)\times C_2-C_3}{C_1}\le A_j\le A_i$。
+ 所以若此时枚举到的 $A_0$ 不满足上述条件，那么就直接 pass，否则统计答案。
+ 如果值域扩展到很大，使用 map 或离散化即可解决。时间复杂度 $O(n^2\log n)$。

## 丑陋の代码
[click here](https://www.luogu.com.cn/paste/1h1h669m)

---

## 作者：redegg (赞：2)

以下是o2过，不开90，（我也不知道改了哪里）改之前80分的题解。

实际上，这题应该是个单调队列题。

所有的题解都是枚举三层，第三层是通过均摊来降低复杂度的。

什么叫均摊？就是尽管我写了三层循环，但是第三层循环枚举数实际上为一个定值，或者不大于一个值。

我们可以~~抄袭~~借鉴一下别的题解里拆解方程的做法。

同@I_AM_HelloWord的题解，设$d_i=c_1 \times a_i+c_2 \times b_i$，当$d_i \le c_1\times a_0+c_2 \times a_0 $时方程成立

我的做法同样是枚举$a_0$，$b_0$，把$b_0$排序，从大到小枚举$b_0$，那么我们可以知道$b_0$以前的编号，假设我们知道他的编号为$i$，那么因为$a$数组没排序，则如果$a_i \ge a_0$，且计算方程成立，则$i$这个梨子是可以放到现在情况$a_0$和$b_0$里面的。

由于$b_0$枚举是从大到小，现在$b_0$变小了，那么我们现在放进去的梨子出现了部分不满足方程的，这时候我们可以用一个优先队列来存储梨子的$d_i$，把最大的不满足方程的$pop$掉，这个操作是logn的，留在优先队列里的梨子数就是现在情况的最大值。

这样的复杂度可能大家会认为是$O(n^2logn)$，但是理论上，因为$a_0$不变时每个梨子最多在优先队列里进出一次，而优先队列的操作是$logn$的，所以我们把均摊的这个$logn$提出来，复杂度应该是$O(n^2+nlogn)$，那么问题来了，理论上这么优秀的复杂度，不开o2就要TLE，是我理论上算错了，还是什么玄学问题？

```
#include <bits/stdc++.h>
using namespace std;

int n;

long long c1,c2,c3;

struct ha
{
    long long d,x,y;
    bool operator <(const ha &aa)const
    {
        return d<aa.d;
    }
}a[100005];

struct yy
{
    long long v;
    int id;
}b[100005];

bool cmp(const yy &aa,const yy &bb)
{
    return aa.v<bb.v;
}

priority_queue<ha> p;

long long ans=0;

int main()
{
    scanf("%d",&n);
    scanf("%lld%lld%lld",&c1,&c2,&c3);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%lld",&a[i].x,&a[i].y);
        a[i].d=a[i].x*c1+a[i].y*c2-c3;
        b[i].id=i;
        b[i].v=a[i].y;
    }
    sort(b+1,b+1+n,cmp);
    for(int i=1;i<=n;i++)
    {
        long long k=0;
        for(int j=n;j>=1;j--)
        {
            int nx=b[j].id;
            if(a[nx].x>=a[i].x&&a[nx].d<=c1*a[i].x+c2*b[j].v)
            {
                p.push(a[nx]);
                k++;
            }
            else continue;
            while(!p.empty()&&p.top().d>c1*a[i].x+c2*b[j].v)
            {
                k--;
                p.pop();
            }
            ans=max(k,ans);
        }
        while(!p.empty())
            p.pop();
    }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：OIer_ACMer (赞：1)

~~这幼稚园福利不错！~~

------------
注：本题思路较简单，因此作者不会将证明以及原理讲得太过清楚，望周知！

------------
## 大致思路：
根据题目要求，最重要的条件就是要满足 $C_1 \times (A_i-A_0)+C_2 \times (B_i-B_0) \le C_3$ 这个公式。它也是我们 DP 的核心。

由于题目中的比较对象是**选出的梨子里面最小的 $a$ 和 $b$**，并且计算出来的值显然是具有单调性的，所以我们可以枚举所有的 $a$ 以及所有的 $b$，并且**统计满足当下情况的个数**，但是显然时间复杂度并不允许我们的 $O(n^3)$ 的做法。但是根据题目中的单调性我们可以对计算出的值以及 $b$ 进行**从小到大的排序这样**在内层检验是否合法时就不需要从头再枚举检验点。

为了满足上面的条件，我们可以继承从小的 $b$ 值转化过来的 $k$，所以我们将范围扩展到整个 $i$ 上面去,**枚举所有可能的 $a_0$，$b_0$ 计算每个满足每个 $a_0$，$b_0$ 的值**，发现此时需要维护的便是在 $1$ 到 $k$ 中小于某个数的个数（保证现在用**以比较的梨子是最小的梨子**），可以想到树状数组逆序对的做法，（并且时间复杂度是 $10^7$ 可以通过本题），本来讲解到这里就可以结束了。但这里其实还有一种**桶的做法**，累计每个数字使用的次数，然后**累加时把小于当前数字桶中的全减掉，然后把那个数字的桶清空**，防止重复减就行了。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 2009, inf = 0x3f3f3f3f3f3f;
struct hp
{
    int id, val;
} an[N], p[N];
int sum[N];
int a[N], b[N];
bool cmp(hp a, hp b)
{
    return a.val < b.val;
}
signed main()
{
    int n, c1, c2, c3;
    n = read();
    c1 = read();
    c2 = read();
    c3 = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        b[i] = read();
        p[i].id = i;
        p[i].val = b[i];
        an[i].id = i;
        an[i].val = (c1 * a[i] + c2 * b[i] - c3);
    }
    an[n + 1].val = inf;
    sort(an + 1, an + 1 + n, cmp);
    sort(p + 1, p + 1 + n, cmp);
    int ans = 0, anss = 0;
    for (int i = 1; i <= n; i++)
    {
        memset(sum, 0, sizeof(sum));
        ans = 0;
        for (int j = 1, k = 0; j <= n; j++)
        {
            for (; (an[k].val <= (c1 * a[i] + c2 * p[j].val)) && k <= n; k++)
            {
                if (a[an[k].id] >= a[i] && b[an[k].id] >= p[j].val)
                {
                    sum[b[an[k].id]]++;
                    // cout << "sum[" << "an[" << k << "].id]]=" << sum[b[an[k].id]] << endl;
                    ans++;
                }
            }
            ans -= sum[p[j - 1].val];
            sum[p[j - 1].val] = 0; 
            anss = max(ans, anss);   
        }
    }
    cout << anss;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122805307)

---


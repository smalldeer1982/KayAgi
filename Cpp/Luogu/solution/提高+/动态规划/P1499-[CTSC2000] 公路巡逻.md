# [CTSC2000] 公路巡逻

## 题目描述

在一条没有分岔的高速公路上有 $n$ 个关口，相邻两个关口之间的距离都是 $10\rm km$ 。所有车辆在这条高速公路上的最低速度为 $60\rm km/h$ ，最高速度为 $120\rm km/h$，并且只能在关口处改变速度。

巡逻的方式是在某个时刻 $T_{i}$ 从第 $n_{i}$ 个关口派出一辆巡逻车匀速驶抵第 $n_{i+1}$ 个关口，路上耗费的时间为 $t_{i}$ 秒。

两辆车相遇是指它们之间发生超车或者两车同时到达某关口（同时出发不算相遇）。

巡逻部门想知道一辆于 $6$ 点整从第 $1$ 个关口出发去第 $n$ 个关口的车（称为目标车）最少会与多少辆巡逻车相遇，请编程计算之。假设所有车辆到达关口的时刻都是整秒。

## 说明/提示

$1 < n < 50$，$1 < m < 300$，$1 \leq  n_{i} < n$，$300 \leq t_i \leq 600$，所有的 $T_i$ 不早于 $05:00$，不晚于 $23:00$。

CTSC2000 第一试


## 样例 #1

### 输入

```
3 2
1 060000 301
2 060300 600
```

### 输出

```
0
061301
```

# 题解

## 作者：yyy2015c01 (赞：12)

#具体看注释！！！

#具体看注释！！！

#具体看注释！！！

###**步骤：**

**1. 看代码

2. 看代码

3. 看代码**

```cpp
//不加注释的题解都是流氓
#include<iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cctype>
#include <climits>
#include <algorithm>
#include <map>
#include <queue>
#include <vector>
#include <string>
#include <cstring>
#include <sstream>
#include <fstream>
using namespace std;
const int INF=66666666;
struct node {
    int start,end;//start：出发时刻，end：到达时刻
} car[305][305];//car[i][j]：从i关口出发的第j辆车
int n,m;
int dp[55][33000]={0};//dp[i][j]：到达第i个关口耗时j秒遇到巡逻车的最小次数
int num[305]={0};//num[i]:从第i个关口出发的巡逻车数
int change(int time)//传入hhmmss格式的时间，返回从6点开始到这个时刻的秒数
{
    int h,m,s;
    h=time/10000;
    time-=h*10000;
    h-=6;
    m=time/100;
    time-=m*100;
    s=time;
    return (h*3600+m*60+s);
}
int changeBack(int T)//传入6点开始到现在的秒数，返回hhmmss格式的时间数字（不含前导0）
{
    int h,m,s;
    h=T/3600;
    T-=h*3600;
    h+=6;
    m=T/60;
    T-=m*60;
    s=T;
    return h*10000+m*100+s;
}
int main()
{
    freopen("patrol.in","r",stdin);
    freopen("patrol.out","w",stdout);
    scanf("%d %d",&n,&m);
    int n600=n*600;
    int ni,Ti,ti;
    memset(dp,50,sizeof(dp));
    for(int i=0; i<m; i++) {
        scanf("%d %d %d",&ni,&Ti,&ti);
        ni--;//因为数组从0开始
        Ti=change(Ti);
        car[ni][num[ni]].start=Ti;
        car[ni][num[ni]].end=ti+Ti;
        num[ni]++;
    }
    dp[0][0]=0;
    n--;//因数组从0开始
    bool b=false;
    for(int i=0; i<n; i++) {//枚举关口
        for(int j=i*300,i600=i*600; j<=i600; j++) {//枚举总耗时
            for(int k=300; k<=600; k++) {//枚举当前关口耗时
                int times=0,jk=j+k;
                for(int p=0; p<num[i]; p++) {
                    if((car[i][p].start>=j&&car[i][p].end>jk)||(car[i][p].start<=j&&car[i][p].end<jk))
                        continue;//没有超车
                    else
                        times++;//超车或同时到达
                }
                dp[i+1][jk]=min(dp[i+1][jk],dp[i][j]+times);//dp方程
                if (dp[i+1][jk]==0) {//优化：dp[i][j]=0,则dp[i][k](k>j)皆为0.
                    for (int p=jk+1,i602=i600+600;p<=i602;p++) {
                        dp[i+1][p]=0;
                    }    
                    b=true;
                    break;
                }
            }
            if (b) break;
        }
        if (b) {
            b=false;
            continue;
        }
    }
    int result=INF;
    int minTime;
    for(int i=n*300,n601=n600-600; i<=n601; i++) {//找最少的
        if(result>dp[n][i]) {
            result=dp[n][i];
            minTime=i;
        }
    }
    int printTime=changeBack(minTime);
    printf("%d\n",result);
    if (printTime<100000) printf("0");//补前导0
    printf("%d\n",printTime);
    return 0;
}
```

---

## 作者：神秘人哈哈 (赞：5)


    #include<bits/stdc++.h>
    using namespace std;
    #define all(x) (x).begin(), (x).end()
    #define for0(a, n) for (int (a) = 0; (a) < (n); (a)++)
    #define for1(a, n) for (int (a) = 1; (a) <= (n); (a)++)
    const int INF =0x3f3f3f3f;
    const int maxn=50;
     const int Tmin=300;
     const int Tmax=600;
     const int maxt=6*3600+300*50;
    int n,m;
    int dp[maxn+3][maxt+3];
    struct Node
    {
    int st,et;
    Node(){}
    Node(int st,int et):st(st),et(et){}
    bool operator<(const Node & y)const
    {

        return st<y.st;

    }

    };
     vector<Node >G[maxn+10];
     inline void init()
    {
    for1(i,n)
    {
        G[i].clear();
    }
    }
    void input()
    {
    int x,st,et;
    string s;
    for1(i,m)
    {
        cin>>x>>s>>et;
        st=10*(s[0]-'0')+s[1]-'0';
        st*=3600;
        st+=  60* (10*(s[2]-'0')+s[3]-'0' ) ;
        st+= 10*(s[4]-'0')+s[5]-'0';
        et+=st;//掉了
        G[x].push_back(Node(st,et));
    }

    for1(i,n)
    {
        sort(all(G[i]));
    }

    }

    int cal(int st,int et,int x)
    {
    int p=lower_bound(all(G[x]),Node(st,0))-G[x].begin();
    int cnt=0;
    for(int i=p;i<G[x].size();i++)//G[x][i].st>=st
    {
        if(G[x][i].st==st&&G[x][i].et==et||G[x][i].st!=st&&G[x][i].et<=et)
        {
              cnt++;
        }

    }
    p=upper_bound(all(G[x]),Node(st-1,0))-G[x].begin();

    for(int i=0;i<p;i++)//G[x][i].st<st
    {
        if(G[x][i].et >=et )  cnt++;
    }
    return cnt;

    }
       
       void work()
    {

    memset(dp,0x3f,(n+1)*sizeof dp[0]);
    dp[1][6*3600]=0;
    for1(i,n-1)
    {
        int st=6*3600+(i-1)*300;
        int ed=6*3600+(i-1)*600;
        for(int t=st;t<=ed;t++)
        {
            for(int add=Tmin;add<=Tmax;add++)
            {
                 int t2=t+add;
                 int tmp=cal( t,t2,i  );
                 dp[i+1][t2]=min(dp[i+1][t2],dp[i][t]+tmp);
            }
        }
    }
    int ans=INF,best=-1;
    int st=6*3600+(n-1)*300;
    int ed=6*3600+(n-1)*600;
    for(int t=ed;t>=st;t--)
    {
        if(ans>=dp[n][t])
        {
            ans=dp[n][t];
            best=t;
        }
    }
    printf("%d\n",ans);
    int hh,mm,ss;
    ss=best%60;
    best/=60;
    mm=best%60;
    best/=60;
    hh=best;



    printf("%02d%02d%02d\n",hh,mm,ss);
    }
    int main()
    {
    std::ios::sync_with_stdio(false);

    int kase=0;
    while(cin>>n>>m)
    {
        if(kase++)  putchar('\n');

        init();
        input();
        work();
    }
     return 0;
    }
     /*

    第二辆巡逻车
    3 2
    1 060000 301
    2 060300 600
    6*3600+3*60=21600+180=21780
    出发到          22380
    第1站到达时间  21600+300=21900
    第二站到达时间范围   22200  22500
    样例输出061301   21600+13*60+1=21600+781=22381
    */



---

## 作者：OIer_ACMer (赞：4)

~~这巡逻的警察真是累呀！~~

------------
注：本题思路较为简单，所以作者不会过多讲述其中的原理以及证明，望周知！

------------
## 大致思路：
本题主要涉及到了 DP 方程的构造以及时间的转化。

首先，我先来讲一下怎么处理时、分、秒。其实这个处理十分简单，我们只需要根据 c++ 独有的性质：**如果输入的数是一个整型变量，那么在输入的时候就会自动将前导 $0$ 去掉，例如我们输入 $012$，那么它只会保留后面的非 $0$ 部分**（反正我每次都是这样做的，如果有不对的地方可以指出来），当然，我们还要用 $\operatorname{trans}$ 函数将三个时间单位的数储存在 $st$ 数组里（记住，**在存的时候也要将两个不相邻的节点的时间给存下来**，不然的话跨点计算就会出问题），为之后的转移方程做准备。

接着，我们先要预处理一下每个检查点的距离，用 $ed$ 保存没两个检查点之间的距离（反正我们已经知道了每两个点之间的距离为 $10$ 千米），接着，我们用 $\operatorname{memset}$ 函数将 $dp$ 数组初始化全为 $0$（因为我们最终要求的是最大值，不然你就自己想一想会发生啥）。

之后，到了 DP 的环节。我们设 $dp_{i,t}$ 表示在时间 $t$ 到达关口 $i$，与**巡逻车最少相遇的次**数，那么我们第一个循环就从 $1$ 到 $n$，第二个就枚举时间 $300$ 到 $600$（记得，单位是秒）。接着，我们很容易就推出了状态转移方程：

$dp_{i,t} = \min(dp_{i,t}, dp_{i - 1,t - k} + \operatorname{count}(i - 1, t - k, t))$。

$\operatorname{count}(i,st_i,ed_i)$ 表示目标车在 $st_i$ 时刻从 $i$ 关口出发，$ed_i$ 时刻到达 $i+1$ 关口，途中会遇到几次巡逻车。我们设 $i$ 关口的每辆巡逻车 $st$ 时刻出发，$ed$ 时刻到达 $i+1$ 关口。则有三种情况：

1. 如果 $ed$ 等于 $ed_i$，则一定在终点相遇。

2. 如果 $st < st_i$ 且 $ed_i \le ed$，则巡逻车出发早却到的晚，一定在途中被超车。

3. 如果 $st > st_i$ 且 $ed_i \ge ed$，则巡逻车出发晚却到的早，没有相遇，一定在中途被超车了。

大致就是这三种情况，最后的操作就是将相遇次数记录下来同时记录时间，最后再用和 $\operatorname{trans}$ 函数相同的转换公式将到达各个关口的时间一一再变成小时，分钟，和秒。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 1009
#define inf 0x3f3f3f3f
int n, m, st[N][300], ed[N][300], dp[N][30000];
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline int trans(int x)
{
    return (x / 10000 - 6) * 3600 + x % 10000 / 100 * 60 + x % 100;
}
inline int count(int i, int sti, int edi)
{
    int res = 0;
    for (int j = 1; j <= st[i][0]; ++j)
    {
        if (edi == ed[i][j])
        {
            res++;
        }
        else if (st[i][j] < sti && edi <= ed[i][j])
        {
            res++;
        }
        else if (st[i][j] > sti && edi >= ed[i][j])
        {
            res++;
        }
    }
    return res;
}
int main()
{
    bool blank = 0;
    n = read();
    m = read();
    if (blank)
    {
        cout << endl;
    }
    else
    {
        blank = 1;
    }
    memset(st, 0, sizeof(st));
    while (m--)
    {
        int x = read(), t = read(), y = read();
        st[x][0]++;
        st[x][st[x][0]] = trans(t);
        ed[x][st[x][0]] = st[x][st[x][0]] + y;
    }
    memset(dp, 0x3f, sizeof(dp));
    dp[1][0] = 0;
    for (int i = 2; i <= n; ++i)
    {
        int lt = (i - 1) * 300, rt = (i - 1) * 600;
        for (int t = lt; t <= rt; ++t)
        {
            for (int k = 300; k <= 600; ++k)
            {
                dp[i][t] = min(dp[i][t], dp[i - 1][t - k] + count(i - 1, t - k, t));
            }
        }
    }
    int ans = inf, ansid = -1;
    for (int t = (n - 1) * 300; t <= (n - 1) * 600; ++t)
    {
        if (dp[n][t] < ans)
        {
            ans = dp[n][t], ansid = t;
        }
    }
    printf("%d\n%06d\n", ans, (ansid / 3600 + 6) * 10000 + ansid % 3600 / 60 * 100 + ansid % 60);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122807429)

---


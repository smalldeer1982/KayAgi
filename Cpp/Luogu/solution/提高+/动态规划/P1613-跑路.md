# 跑路

## 题目描述

小 A 的工作不仅繁琐，更有苛刻的规定，要求小 A 每天早上在 $6:00$ 之前到达公司，否则这个月工资清零。可是小 A 偏偏又有赖床的坏毛病。于是为了保住自己的工资，小 A 买了一个空间跑路器，每秒钟可以跑 $2^k$ 千米（$k$ 是任意自然数）。当然，这个机器是用 `longint` 存的，所以总跑路长度不能超过 `maxlongint` 千米。小 A 的家到公司的路可以看做一个有向图，小 A 家为点 $1$，公司为点 $n$，每条边长度均为一千米。小 A 想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证 $1$ 到 $n$ 至少有一条路径。

## 说明/提示

**【样例解释】**

$1 \to 1 \to 2 \to 3 \to 4$，总路径长度为 $4$ 千米，直接使用一次跑路器即可。

**【数据范围】**

$50\%$ 的数据满足最优解路径长度 $\leq 1000$；

$100\%$ 的数据满足 $2\leq n \leq 50$，$m \leq 10 ^ 4$，最优解路径长度 $\leq$ `maxlongint`。

## 样例 #1

### 输入

```
4 4
1 1
1 2
2 3
3 4
```

### 输出

```
1```

# 题解

## 作者：Hydra_ (赞：339)

## 分析 ##

这道题目求的是从1号点到n号点最少要几秒到达。我们可以看到这个跑路器，每秒跑2^k条边（每条边1km），所以呢，这道题目明显就和“倍增”扯上了关系。回忆倍增，我们总是用一个参数k表示2^k，这道题目也一样，我们需要用一个bool类型G数组，G[i][j][k]代表从i到j是否存在一条长度为2^k的路径。再用dis数组来记录两点之间需要用多久到达。这样我们可以用G来保存所有的边，并且进行预处理，把所有一秒能到的两个点之间都连上边，并把距离相应调整为1。那么我们就把所有一秒能到的点之间都铺上了边，接下来我们就要求出两点之间的最短路啦，那么，大家都明白了，对于50的数据，Floyd绝对是最简单可行的办法了。

下面上代码。

## 代码 ##

```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[60][60],n,m;
bool G[60][60][65];
/*以上是变量说明部分，dis[i][j]表示i到j的路径/边的长度
G[i][j][k]表示，i到j是否存在一条长度为2^k的路径
如果有，为true，没有就是false*/ 
void init()
{
    memset(G,false,sizeof(G));
    memset(dis,10,sizeof(dis));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        dis[x][y]=1;
        G[x][y][0]=true;
        /*初始化，x到y的路径（边）最短是1，也就是x到y存在
        一条长度为2^0的路径（边）*/ 
    }
}
void work()//此函数对G和dis做预处理 
{
    for(int k=1;k<=64;k++)
    //对于本题的数据，2^64已经足够。 
    for(int i=1;i<=n;i++)
    for(int t=1;t<=n;t++)
    for(int j=1;j<=n;j++)
    //枚举三个点
    if(G[i][t][k-1]&&G[t][j][k-1])
    /*如果i到t存在一条2^k-1长度的路径
    并且t到j存在一条2^k-1长度的路径
    就说明i到t，t到j都可以一秒到达，
    路程*2刚好是2的幂，也可以一秒到达*/ 
    {
        G[i][j][k]=true;
        //标记从i到j存在一条长度为2^k的路径 
        dis[i][j]=1;
        //i到j距离可以一秒到达 
    }
}
void floyd()
{
    for(int k=1;k<=n;k++)
    //这里的注意点：枚举中间点的循环放在最前面 
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    //松弛操作。 
}//Floyd图论求最短路。 
int main()
{
    init();
    work();
    floyd();
    printf("%d",dis[1][n]);
    return 0;
}
```

---

## 作者：DaCong (赞：86)

这道题是最短路径和倍增思想的结合题。

首先说一下一个明显的错误： **绝对不能直接求最短路**

原因很简单，题目中有说，有跑路器。


那么进一步思考，发现，任意 $$2^k$$ 的路径长度都可以在1秒内走完，因此如果有 u v 两点间的最短距离为 $$2^k$$ 即可认为这两点之间有一条边（本题中边权全部为1）。


接下来，思路就很简单了。令 $$f_{i,j,k}$$ 的意义为能否在 $$2^i$$ 时间内从点 j 走到点 k ，可以为1，不可以为0。进一步，由**倍增**的思想可以得到：若 $$f_{i-1, v, k}$$ 和 $$f_{i-1, k, u}$$ 同时为1，则 $$f_{i, v, u}$$ 为1。


在这些都预处理完成之后，在跑一个最短路，就正确了。


---

## 作者：GoldenPotato137 (赞：47)

蒟蒻博客传送门：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9177144.html)



------------

### Solution
挺有意思的一道题。

 .

题面已经挺明显的描述出了这题的主要思想：**倍增**。

先这样想，我们可以把这题这样建模：**有一堆点，若两个点之间的距离之和可以达到2的n次方，那么这两个点可以用1的时间相互到达**。

也就是说，我们**把距离能为2的n次方的点对用边权为1的边连上，再做一次最短路径**，就可以求出答案了。

.

 

接下来问题就是如何求出每两个点是否能以2的n次方的时间相互到达。

考虑使用DP。

我们**设f[i][j][k] 表示 i到j是否能以2的k次方的距离相互到达**。

转移的时候得运用倍增的思想：**若两个点能以两段2的k-1次方的距离相互到达，那么两个点就能以2的k次方的距离相互到达**。

接下来我们就可以运用类似Floyd的办法来处理这个DP，我们可以在最外层枚举这个k，里面三层和Floyd的意义一模一样，就是枚举中转点与起始点。

初始化就是题目中直接相连的两个点，它们的f[a][b][0]=1 （它们距离为1,是2的0次方）

 .

**时间复杂度： O(n^3*64)
**


------------
### Code
```cpp
//Luogu P1613 跑路
//June,13th,2018
//倍增+DP+最短路
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50+10;
const int K=65+10;
int f[N][N][K],dis[N][N],n,m;
int main()
{
    n=read(),m=read();
    memset(dis,0x3f,sizeof dis);
    for(int i=1;i<=m;i++)
    {
        int s=read(),t=read();
        f[s][t][0]=1;
        dis[s][t]=1;
    }
    
    for(int o=1;o<=64;o++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                    if(f[j][i][o-1]==true and f[i][k][o-1]==true)
                    {
                        f[j][k][o]=true;
                        dis[j][k]=1;
                    }
                
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                dis[j][k]=min(dis[j][k],dis[j][i]+dis[i][k]);
    
    printf("%d",dis[1][n]);
    return 0;
}

```


---

## 作者：准点的星辰 (赞：21)

### P1613 跑路

这道题看到大家都写倍增和$Floyd$或者$DP$，然而我只想到了暴力。

我的思路是用$bfs$把所有的到$n$的路径长度处理出来，然后把所有的长度暴力判断一遍，找最小值，**顺便加个卡时**。

这样肯定会有大量重复情况，不过有个比较显然的优化，就是你开一个桶把到达每个点的路径长度都记录一下，再次搜到相同的情况就不用入队。

代码:

```cpp
#include<iostream>
#include<climits>
#include<cstdio>
#include<vector>
#include<queue>
#include<ctime>
#define pii pair<int,int>
#define one first
#define two second
#define mp make_pair
using namespace std;
const int N=55,M=1e5+100;
int ed[N][N];
bool mark[N][M];
int n,m,minn=INT_MAX;
queue<pii>q;
vector<int>v;
inline int work(int x)
{
	int ans=0;
	while (x)
	{
		if (x&1)
		{
			ans++;
			if (ans>=minn) return ans;
		}
		x>>=1;
	}
	return ans;
}
inline void bfs(int x)
{
	q.push(mp(x,0));
	while (!q.empty()&&(double)clock()/CLOCKS_PER_SEC<=0.85)
	{
		pii k=q.front();
		if (k.one==n)
		v.push_back(k.second);
		q.pop();
		for (int i=1;i<=n;i++)
		{
			if (ed[k.one][i]&&!mark[i][k.two+1])
			{
				q.push(mp(i,k.two+1));
				mark[i][k.two+1]=1;
			}
		}
	}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		int s,e;
		scanf("%d%d",&s,&e);
		ed[s][e]=1;
	}
	bfs(1);
	for (int i=0;i<(int)v.size();i++)
	{
		minn=min(minn,work(v[i]));
		if (minn==1) break;
 	}
	printf("%d\n",minn);
	return 0;
}
```

这样就可以得到50分的好成绩,然后你就会发现剩下的点全部$RE$,考虑用$set$代替标记数组，并再用一个$set$存所有路径长度。

```cpp
#include<iostream>
#include<climits>
#include<cstdio>
#include<vector>
#include<queue>
#include<ctime>
#include<set>
#define pii pair<int,int>
#define one first
#define two second
#define mp make_pair
using namespace std;
const int N=55,M=1e6+100;
int ed[N][N];
set<int>s[N],v;
int n,m,minn=INT_MAX;
queue<pii>q;
inline int work(int x)
{
	int ans=0;
	while (x)
	{
		if (x&1)
		{
			ans++;
			if (ans>=minn) return ans;
		}
		x>>=1;
	}
	return ans;
}
inline void bfs(int x)
{
	q.push(mp(x,0));
	while (!q.empty()&&(double)clock()/CLOCKS_PER_SEC<=0.8)
	{
		pii k=q.front();
		if (k.one==n)
		v.insert(k.second);
		q.pop();
		for (int i=1;i<=n;i++)
		{
			if (ed[k.one][i]&&s[i].find(k.two+1)==s[i].end())
			{
				q.push(mp(i,k.two+1));
				s[i].insert(k.two+1);
			}
		}
	}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		int s,e;
		scanf("%d%d",&s,&e);
		ed[s][e]=1;
	}
	bfs(1);
	for (set<int>::iterator it=v.begin();it!=v.end();it++)
	{
		minn=min(minn,work(*it));
		if (minn==1) break;
 	}
	printf("%d\n",minn);
	return 0;
}
```
如果搜索加到最大$0.8s$这样你就会发现得分从60~100分不等。~~得多少分取决于测评机的心情。~~

但是我们由此知道这样暴力肯定能得出答案，也就是答案如果直接$O(ans*log(ans))$跑肯定不会超时，只不过需要优化时间复杂度。

然后我们想到了一个神奇的算法堆优化的$Dijkstra$，我们通过探寻本质发现在此题中如果用这种方法优化就保证了每次如果扩展的点的距离如果小于等于当前点扩展的可被扩展的最大值，
那么这个值就一定被入队过，可以考虑$bfs$的本质来理解。

所以我们就可以每一个点都记录一个可被扩展的最大值，如果当前扩展值小于等于最大值，则跳过，如果大于，则加入队列，同时更新最大值。

我们还发现了一个问题，貌似每次判断答案就是$log(x)$的，$x$是合法路径长度，貌似比$set$去重要优很多，同时这样卡时可以到$0.9s$。

~~然后这题就稳过了~~

其实这题如果吸氧卡时卡到$0.5s$也可以过。

```cpp
#include<iostream>
#include<climits>
#include<cstdio>
#include<queue>
#include<ctime>
#define pii pair<int,int>
#define mp make_pair
#define one first
#define two second
using namespace std;
const int N=55;
priority_queue<pii,vector<pii>,greater<pii> >q;
bool ed[N][N];
int n,m,minn=INT_MAX;
int maxx[N];
inline int work(int x)
{
	int ans=0;
	while (x)
	{
		if (x&1)
		{
			ans++;
			if (ans>=minn) return ans;
		}
		x=x>>1;
	}
	return ans;
}
inline void bfs(int x)
{
	q.push(mp(0,x));
	while (!q.empty()&&(double)clock()/CLOCKS_PER_SEC<=0.9)
	{
		pii k=q.top();
		if (k.two==n)
		{
			minn=min(minn,work(k.one));
			if (minn==1) return ;
		}
		q.pop();
		for (int i=1;i<=n;i++)
		if (ed[k.two][i]&&maxx[i]<k.one+1)
		{
			maxx[i]=k.one+1;
			q.push(mp(k.one+1,i));
		}
	}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		int s,e;
		scanf("%d%d",&s,&e);
		ed[s][e]=1;
	}
	bfs(1);
	printf("%d\n",minn);
	return 0;
}
```

---

## 作者：Kevin_F (赞：19)

这个题看很多人都在用Floyd和倍增的方法来做的。

那我就用spfa来跑最短路吧

a[i][j][k]:表示从i到j是否存在长2^k的边。

预处理的时候就将这些边赋值成1
（长2^k的边）（再补充一下：这些边用1s就能走完）

**注意一下：**

预处理的时候k循环在最外层，因为要所有的从u到v长度为2^k的边，然后赋值成1.

而打标记的时候k放在了最后一层循环上，因为要把u到v边上的情况全部试一遍。。好像不太清楚。。

就是u到v的边的值我们不确定，所以都枚举试一遍。
（从0开始，被这个卡了好几次）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int maxn = 55;

long long n,m,u,v,a[maxn][maxn][65]; 
long long f[maxn][maxn];
long long dis[maxn];
bool vis[maxn];

void spfa(int s){
	queue<int > q;
	for(int i=1;i<=n;i++){
		dis[i] = 1e9;
	}
	q.push(s);
	dis[s] = 0;
	vis[s] = 1;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		vis[cur] = 0;
		for(int v=1;v<=n;v++)
          if(f[cur][v] && dis[v] > dis[cur] + f[cur][v]){
            dis[v] = dis[cur] + f[cur][v];
            if(vis[v] == 0){
              vis[v]=1;
              q.push(v);
	        }
        }
	}
}

int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&u,&v);
		a[u][v][0] = 1;
	}
	for(int k=1;k<=64;k++)
      for(int j=1;j<=n;j++)
        for(int u=1;u<=n;u++)
          for(int v=1;v<=n;v++)
            if(a[u][j][k-1] && a[j][v][k-1])
              a[u][v][k]=1;
    
    for(int u=1;u<=n;u++)
      for(int v=1;v<=n;v++)
	    for(int k=0;k<=64;k++)
          if(a[u][v][k]){
             f[u][v]=1;
             break;
          }
    spfa(1);
    printf("%lld",dis[n]);
    return 0;
}
```

---

## 作者：三好代表 (赞：14)

**看见楼底下都用倍增+Floyd，蒟蒻按耐不住了**

一开始看这道题时，发现是最短路，可是搜的又是倍增的题无可分说这是**倍增+最短路**

但是Dijkstra，SPFA我又不熟，可是看了数据范围心中萌生一种用Floyd做的方法

------------
不扯了

先设一个三维bool数组是用来表示是否i到j之间有一条长度2^k的边

再设一个二维int数组是用来存时间的，再把n，m定上（定义完成）

如果说，bool数组f[i][j][k]中任意一组变为true，那么我们就可以让a[i][j]=1，表示i到j之间这一秒可以到达

那为什么不能直接在Floyd中判断ijk相等呢？因为题目中存在着环的情况，所以不行

预处理的时候最外层枚举的K，应该判断f[i][k][K-1]和f[k][j][K-1]，让f[i][j][K]=1
否则会出现没有那么多边但是a变成1的情况 

~~本蒟蒻代码，勿喷~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int n,m;
int u,v;
int a[N][N];
bool f[N][N][N];
int main()
{
	memset(a,0x3f3f3f,sizeof(a));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		a[i][i]=0;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v;
		f[u][v][0]=1;
		if(u==v)
			a[u][v]=0;
		else a[u][v]=1;
	}
	for(int s=1;s<=20;s++)
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if(f[i][k][s-1] && f[k][j][s-1])
	{
		f[i][j][s]=1;
		if(i==j)
			a[i][j]=0;
		else a[i][j]=1;
	}
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	cout<<a[1][n];
	return 0;
}
```

---

## 作者：asasas5d (赞：10)

为啥都是用最短路的题解，感觉是很明显的状压吧。  
预处理出每个点走 $2^i$ 距离可以到达的点集状态，这个可以用倍增做到。  
然后将所有的这样的状态给“或”起来，就可以得到每个点走一步能到达的点集状态。  

有一个显然的结论是最多走 n 步就能到达目的地（不需要重复经过任意点），所以直接 while(1) 更新状态，直到 n 点被纳入其中即可。


```cpp
#include <cstdio>
typedef long long LL ; 
LL reach[60][60] ;
LL reacher[60] ;
int main(){
    int n, m; scanf("%d %d", &n, &m) ;
    for(int i=1; i<=m; i++){
        int a, b; scanf("%d %d", &a, &b);
        reach[a][0] |= (1ll << b) ; 
        reacher[a] |= (1ll << b) ;
    }
    
    for(int j=1; j<60; j++){
        for(int i=1; i<=n; i++){
            // 求解 reach[i][j]
            LL staus = reach[i][j-1], res = 0 ;
            for(int k=1; k<=n; k++)
                if((1ll<<k) & staus)
                    res |= reach[k][j-1] ;
            reach[i][j] = res ; 
            reacher[i] |= reach[i][j] ;
        }
    }
    
    int ans = 0 ;
    LL temp = 2 ;
    while((temp & (1ll<<n)) == 0){
        ans ++ ;
        LL newres = temp ; 
        for(int i=1; i<=n; i++)
            if((1ll<<i) & temp)
                newres |= reacher[i] ;
        temp = newres ;
    }
    printf("%d\n", ans) ;


    return 0;
}
```


---

## 作者：Mr_Li (赞：6)

一看到2^k，就能猜出是倍增了吧。先求出小A一秒内能到达的点，具体公式是f[i][j][l]=∑(f[i-1][j][k]&&f[i-1][k][l])，若f[i][j][k]>0，则j与k之间有一条(2^i)km的路。反之亦无。接着是构图，若存在一个变量i，使得f[i][j][k]>0，则graph[j][k]=1，表示小A可以在1秒之内从j到k。最后对graph求一边最短路即可。求出小A一秒内能到达的点的时间复杂度为O(log maxlongint▪n^3)，构图最快O(log maxlongint▪n^2)，最短路最快O(n^2)，总时间复杂度为O(log maxlongint▪n^3)。

附代码（构图和最短路都没有用较快的算法，但总时间复杂度一致）：

```cpp

#include<iostream> 
using namespace std;
int n,m,i,j,graph[51][51]={},u,v,k,l;
bool map[65][51][51]={}; 
int main ()
{
    cin>>n>>m;
    for (i=1;i<=n;i++)
    for (j=1;j<=n;j++)
    graph[i][j]=65;
    for (i=1;i<=m;i++)
    {
        cin>>u>>v;
        map[0][u][v]=1;
        graph[u][v]=1;
    }
    for (i=1;i<=64;i++)
    for (j=1;j<=n;j++)
    for (k=1;k<=n;k++)
    for (l=1;l<=n;l++)
    if (map[i-1][j][k]&&map[i-1][k][l])
    {
                                       map[i][j][l]=1;
                                       graph[j][l]=1;
    }
    for (i=1;i<=n;i++)
    for (j=1;j<=n;j++)
    for (k=1;k<=n;k++)
    graph[j][k]=min(graph[j][k],graph[j][i]+graph[i][k]);
    cout<<graph[1][n];
    return 0;
}

```

---

## 作者：jins3599 (赞：5)

倍增预处理$+$最短路

我们首先预处理出来从一号节点走$2^k$步可以到达的所有结点，然后用$\text{floyd}$跑一遍最短路即可。

关键部分在预处理，我们要注意枚举顺序，外层枚举$k$，然后内层再$n^3$枚举转移。

先枚举$k$是为了在转移当前状态时，保证他前面所有的$2^{1...k-1}$步已经全部处理完成了。

于是代码就很好写了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 500;
int n , m;
int g[N][N];
int f[N][N][70];

void Pre () {	
for(int p = 1 ; p <= 32 ; p ++)
	for(int k = 1 ; k <= n ; k ++)
		for(int i = 1 ; i <=n ; i ++)
			for(int j = 1; j  <= n ; j ++) {		 
					if(f[i][k][p - 1] && f[k][j][p - 1]) {
						f[i][j][p] = 1 , g[i][j] = 1;
			}
		}
	for(int i = 1 ; i <= n ;i ++) g[i][i] = 0;
}

void Floyd() {
	for(int k =1 ; k <= n ;k ++)
		for(int i = 1 ; i <= n; i ++)
			for(int j = 1 ; j <= n ; j ++)
				if(i != j && j != k && i != k)
					g[i][j] = min(g[i][j] , g[i][k] + g[k][j]);
	cout <<g[1][n] << endl;
}

int main () {
	memset(g , 0x3f , sizeof(g));
	cin >> n >> m;
	for(int i = 1;  i <= m; i ++) {
		int u , v;
		cin >> u >> v;
	    g[u][v] = 1;
	    f[u][v][0] = 1;
	}
	Pre(); Floyd();
	return 0;
} 
```

---

## 作者：installb (赞：5)

### 1.先看题
题目意思:从1走到n,m条单向边,长度都为1,每秒能且只能移动$2^k$  
对于这种奇怪的规定，应该能想到是倍增  
倍增方法:  
如果i到k,k到j都存在长度为$2^{k-1}$的路径,那么i到j就存在长度为$2^k$的路径  
将k从小到大枚举即可

### 2.数据范围  
$n<=50$,立方级没问题,最为一道图论题,Floyd  
(Floyd的本质是**DP**)  

### 3.设计算法  
存两个数组,一个数组$p[k][i][j]$代表i到j是否存在长度为$2^k$的路径  
另一个数组$dis[i][j]$代表i到j的最短距离,初始值设为$INF$  
如果从i到j存在长度为$2^k$(此处k任意)的路径则$dis[i][j]=1$  
初始加边就是$k=0$ $(2^0=1)$  
最后跑一遍Floyd,1到n最短路  

### PS:  
虽然只有10000条边,但是可能要绕环走个好几圈才能达到最优解,所以k还是1到64吧(maxlongint)  

思路主要在前面讲了,代码写的比较短,里面也注释比较少了。
## code:  
```cpp
#include <map>
#include <list>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define LL long long
using namespace std;

LL p[65][55][55] = {0}; // 是否存在路径
LL dis[55][55] = {0};   // 最短路
LL n,m,u,v;

int main(){
	memset(dis,0x3f,sizeof(dis)); // 初始化
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(register int i = 1;i <= m;i ++){
		cin >> u >> v;
		p[0][u][v] = 1; dis[u][v] = 1; // u到v有一条长度为1(1=2^0)的边
	}
	for(register int t = 1;t <= 64;t ++)
		for(register int k = 1;k <= n;k ++)
			for(register int i = 1;i <= n;i ++)
				for(register int j = 1;j <= n;j ++)
					if(p[t - 1][i][k] && p[t - 1][k][j])
						p[t][i][j] = 1,dis[i][j] = 1;
						//上面所说方式更新dis和p
    for(register int k = 1;k <= n;k ++)
		for(register int i = 1;i <= n;i ++)
			for(register int j = 1;j <= n;j ++)
				dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);
                //Floyd kij
	cout << dis[1][n] << endl;
	return 0;
}
```

---

## 作者：Pleasun (赞：4)

这个题目其实感觉好水啊……

但是很好理解倍增思想

首先理解题意，就是说每次可以跑2^k步（k>=0）,那么先把图读进来，如果有两条权值一样的边，就合一起，成一条新边，然后就一直合，那么合起来的边只需要
花费1，存在图中，具体实现就是（看起来好像有点啰嗦）
```
    for(int i=1;i<=36;i++){
        for(int u=1;u<=n;u++){
            for(int v=1;v<=n;v++){
                for(int k=1;k<=n;k++){
                    if((f[i-1][u][k]==1)&&(f[i-1][k][v]==1)){//如果u到v可以通过走两条长度一样（2^(i-1)）的路到，就合在一起
                        f[i][u][v]=1;
                        g[u][v]=1;
                    }
                }
            }
        }
    }
```

然后题目又是求最短路，由于n<=50,上floyd就完事了

下面是完整代码：
```
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;
}
int n,m,g[55][55],f[40][55][55];
int main(){
    memset(g,127,sizeof(g));
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        g[u][v]=1;
        f[0][u][v]=1;
    }
    for(int i=1;i<=36;i++){
        for(int u=1;u<=n;u++){
            for(int v=1;v<=n;v++){
                for(int k=1;k<=n;k++){
                    if((f[i-1][u][k]==1)&&(f[i-1][k][v]==1)){
                        f[i][u][v]=1;
                        g[u][v]=1;
                    }
                }
            }
        }
    }
    
    for(int k=1;k<=n;k++){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(g[i][k]<=999999 && g[k][j]<=999999){
                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
                }
            }
        }
    }
    
    
    cout<<g[1][n];
    return 0;
}
```

---

## 作者：夢·壹生所愛 (赞：4)

emmm，emmmm，emmmmm，其实这道题是一道裸的A* 嘛（huaji）

好吧，其实是我不会打正解，只能用A* 来水了。

回归正题：

从题目中我们可以知道，他需要求出一条路径，使路径的长度转化为二进制后的1尽量的少，所以我们就可以用a* 求出前不知道多少条最短路，取里面二进制下最小的一条路径就可以了。

code：
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
struct node
{
	int to,next;
	int w ;
}edge[100010],edge2[100010];//两个图也，一个正的，一个反的  
int k;
int k2;
int head[200];
int head2[200];
int u,v;
int dist[200];
bool book[100010];
int ans=0x7f7f7f7f;
int cnt[10010];//记录每个点的入队次数 
int n,m;
bool re[51][51];//去重边 
struct point2//dijkstra的结构体 
{
	int id;
	int num;
	point2(int x,int y)
	{
		id=x;
		num=y;
	}
	bool friend operator < (point2 x,point2 y)
	{
		return x.num>y.num;
	}
};
struct point//a*的结构体 
{
	int id;
	int f;
	int g;
	bool friend operator < (point x,point y)
	{
		return x.g>y.g;
	}
};
void adde(int u,int v,int w)
{
	edge[++k].to=v;
	edge[k].w=w;
	edge[k].next=head[u];
	head[u]=k;
}
void adde2(int u,int v,int w)
{
	edge2[++k2].to=v;
	edge2[k2].w=w;
	edge2[k2].next=head2[u];
	head2[u]=k2;
}
void dijkstra(int s)//这个就不需要说了吧QWQ 
{
	memset(dist,0x7f7f7f7f,sizeof(dist));
	priority_queue<point2> q;
	dist[s]=0;
	q.push(point2(s,dist[s]));
	while(!q.empty())
	{
		point2 rp=q.top();
		q.pop();
		if(book[rp.id])continue;
		book[rp.id]=true;
		for(int i=head2[rp.id];i;i=edge2[i].next)
		{
			int mp=edge2[i].to;
			if(dist[mp]>dist[rp.id]+edge2[i].w)
			dist[mp]=dist[rp.id]+edge2[i].w,q.push(point2(mp,dist[mp]));
		}
	}
}
int check(int num)//这是判断当前的距离需要跑的步数 
{
	int sum=0;
	while(num>0)
	{
		sum+=num&1;
		num>>=1;
	}
	return sum;
}
void astar()//a*~\(≧▽≦)/~啦啦啦 
{
	priority_queue<point> q;
	point rp;
	rp.id=1;
	rp.f=0;
	rp.g=dist[rp.id]+rp.f;
	q.push(rp);//把起点丢进去 
	while(!q.empty())
	{
		point mp=q.top();
		q.pop();		
		ans=min(ans,check(mp.g));
		if(ans==1)return ;//如果发现答案已经为1了，那就不跑了 
		if(cnt[mp.id]>=30100)return ;//如果一个点都经过30000次了，那么这就是个环啊，不管他了，反正继续跑结果也不会变，返回 
		for(int i=head[mp.id];i;i=edge[i].next)
		{
			point sx;
			sx.id=edge[i].to;
			sx.f=mp.f+edge[i].w;
			sx.g=sx.f+dist[sx.id];
			q.push(sx);	
			cnt[sx.id]++;
			//标准的a*~\(≧▽≦)/~啦啦啦 
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		if(u==v)
		{
			printf("1");
			return 0;
		}	
		if(!re[u][v])
		adde(u,v,1),adde2(v,u,1),re[u][v]=true;//建反边跑反向的最短路，这是a*求k短路的关键 
	}	
	dijkstra(n);//尽量用dijkstra哦，关于spfa，他死了 
	astar();//astar 
	printf("%d",ans);
	return 0;
}
//dalao们不要hack我的代码丫QWQ 
```

---

## 作者：tttnns (赞：4)

什么是倍增？不知道


朴素floyd最短路+神奇dp



dp[v]=dp[u]+1 (u,v|2^k=dis[u][v])

特判自环


复杂度O(n^3+n^2)


4ms AC


 ![](https://cdn.luogu.com.cn/upload/pic/5572.png) 

无正确性


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n,m;
const int maxn=64;
const int inf=0x3f3f3f3f;
int g[maxn][maxn];
int f[maxn];
static void floyd(){
    for(int k=1;k<=n;++k)
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                if(g[i][j]>g[i][k]+g[k][j])
                    g[i][j]=g[i][k]+g[k][j];
}
static int dp(const int p){
    int &ans=f[p];
    if(ans!=-1)
        return ans;
    if(p==1)
        return ans=0;
    ans=inf;
    for(int i=1;i<=n;++i)
        if(g[i][p]!=inf){
            int dis=g[i][p];
            const int ids=g[i][i];
            int awd=1;
            for(;awd<dis&&awd>0;awd<<=1);
            if(awd>dis){
                while(awd>0){
                    const int ddd=awd-dis;
                    if(ddd%ids==0){
                        dis=awd;
                        break;
                    }
                    awd<<=1;
                }
            }
            if(awd==dis){
                ans=min(ans,dp(i)+1);
            }
        }
    return ans;
}
static void awd(){
    memset(g,0x3f,sizeof(g));
    scanf("%d%d",&n,&m);
    while(m--){
        int u,v;
        scanf("%d%d",&u,&v);
        g[u][v]=1;
    }
    floyd();
    memset(f,-1,sizeof(f));
    printf("%d\n",dp(n));
}
int main(){
    return awd(),0;
}
```

---

## 作者：nofind (赞：3)

这是道老题了,其它题解中似乎并未说明这就是倍增floyd,所以我写篇题解介绍一下,求过了~
------------

题意：

https://www.luogu.org/problemnew/show/P1613

解析：

首先上来跑floyd肯定是错的,因为有推进器的作用,它会缩短一些点
之间的距离。

我们发现推进器的作用是使路径长为(1<<K)的路径长度变为1,因此我们在跑floyd前就应该先处理出新的图,在图中如果原图中x,y两点长度为(1<<K),那么x,y在新图中就有一条长度为1的边。

那么问题就是如何预处理。

那么引入倍增floyd,我们都知道floyd的本质是DP,那么我们不妨将其**扩展一下**:f[i][j]表示i,j是否联通->f[i][j][k]表示i,j中是否存在长为(1<<K)的一条路径。(结合倍增)

转移方程:f[i][j][k]|=f[i][u][k-1]&&f[u][j][k-1]

if(f[i][j][k]) ->dis[i][j]=1

在构建新图后,我们就可以正常floyd来求出1->n的最短路。

ps1:倍增floyd:

用它的题目形式一般是:求经过k条边/点的最大/小路径长度

方程:f[i][j][k]表示从i到j,经过(1<<k)条边的最大/小长度,f[i][j][k]=min/max(f[i][u][k-1]+f[u][j][k-1])

优化：发现这就是矩阵乘法的形式,只不过改成了取min/max的形式,即f[i][j][k]->矩阵f[k]=f[k-1]* f[k-1]

由于同矩阵一样具有传递性,有时可以用矩阵快速幂优化,如:BZOJ [usaco2007 Nov]relays 奶牛接力跑

ps2:果还想做此类的题,可以看我的博客:https://www.luogu.org/blog/ddy/kai-keng-bei-zeng-floyd#

code:

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=60;
int n,m,t;
int dis[maxn][maxn];
bool f[maxn][maxn][70];
void init()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dis[i][j]=100;
	for(int i=1;i<=n;i++) dis[i][i]=0;
}
void pre()
{
	for(int cnt=1;cnt<=64;cnt++)
		for(int k=1;k<=n;k++)
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					if(f[i][k][cnt-1]&&f[k][j][cnt-1])f[i][j][cnt]=1,dis[i][j]=1;
}
int main()
{
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=m;i++)
	{
		int u,v;scanf("%d%d",&u,&v);
		f[u][v][0]=1,dis[u][v]=1;
	}
	pre();
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	printf("%d",dis[1][n]);
	return 0;
}
```







---

## 作者：the_Death (赞：2)

### [Luogu](https://www.luogu.org/problem/P1613)

一道思维题~~可能仅是对我来说，对于大佬们都是显然的~~

[或许会有更好的阅读体验](https://www.cnblogs.com/fallen-down/p/11589151.html)

-----------------

### **简化题意**

给你一个图，找到一个路径，使其路径的二进制位中$1$的个数最少

### **分析**

这题的题目就有两个坑点~~或许仅是对我而言~~
1. 每次走的时候，只有在端点才可以停下，即如果有一条路从$i$到$j$，如果其路径长为7，则不可以从$i$直接走到$j$，你要走$3$次。

2. 由于$1.$所以直接跑最短路不一定是最优。

然后想解法

首先，由于~~标签/路径太长了/牛*的~~机器特殊的跑路方式，所以我们想到了用倍增来解决这个问题

然后考虑这题最后还是要求最短路。我们又看到了数据范围$n<=50$，所以就想到弗洛伊德，求最短路。但由于上面的结论，我们不可以直接跑最短路，故而我们需要对这个图的做一个转化。这道题很难对图的点做出转化，所以我们选择对边/路径做出转化。

然后就考虑对路径的转化。考虑之前不能直接跑最短路的原因：我们无法在较短的时间里直接确定怎样的路径中二进制位的$1$的个数更少，所以当我们把路径的贡献转化为它在二进制中$1$的个数你就可以算的最短路。

所以先预处理出从$i$到$j$的最短路径中$1$的个数，然后再求一边最短路就好的。

对于求$i$到$j$的最短路径中$1$的个数，由于$i$到$j$的路径有一种性质~~我哦不知道具体的名字~~：$i$到$t$中个数为$k$,$t$到$j$中个数为$k$,那么$i$到$j$中的$1$的个数就是$k+1$。

故，我们可以用类似于传递闭包的方式来求的每两个点之间的最短路中的二进制位的$1$的个数

---------------

### **code**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,m,x,y,dis[55][55];
bool map[55][55][65];
inline void pre(){
    for(register int t=0;t<=64;t++)
        for(register int k=1;k<=n;k++)
            for(register int i=1;i<=n;i++)
                for(register int j=1;j<=n;j++)
                    if(map[i][k][t-1]&&map[k][j][t-1])
                        map[i][j][t]=1,dis[i][j]=1;
}
inline void floyed(){
    for(register int k=1;k<=n;k++)
        for(register int i=1;i<=n;i++)
            for(register int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]);
}
int main(){
    scanf("%d%d",&n,&m);
    memset(dis,0x3f,sizeof(dis));
    for(register int i=1;i<=m;i++)
        scanf("%d%d",&x,&y),
        dis[x][y]=1,map[x][y][0]=1;
    pre();floyed();printf("%d",dis[1][n]);
}
```
-----------

最后国际惯例，thankyou for your attention

---

## 作者：ttt_TTT (赞：1)

看到2 ^ k 就想到了倍增， 用一个数组to[x][j][y], 表示x + 2 ^ j能不能走到y， 能就标记1， 最后Floyed

中间一个倍增数组， i + 2^(o - 1) = j, j + 2^(o - 1) = k      i -> k   i + 2^o = k;

```cpp
#include <iostream>
#include <cstdio>
#define F(i, l, r) for(int i = l; i <= r; ++i)
using namespace std;
const int MAX = 51;
const int POW = 32;
const int INF = 1000000;
int N, M,dis[MAX][MAX];
bool to[MAX][POW + 1][MAX];
int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9') {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

void Input() {
    N = read(); M = read();
    F(i, 1, N)
        F(j, 1, N)
            dis[i][j] = INF;
    F(i, 1, M) {
        int x, y;
        x = read(); y = read();
        dis[x][y] = 1;
        to[x][0][y] = 1;
    }
    return;
}

void pre() {
    for(int o = 1; o <= POW; ++o)
      for(int i = 1; i <= N; i++)
          for(int j = 1; j <= N; j++)
            if(to[i][o - 1][j])
            for(int k = 1; k <= N; k++)
              if(to[j][o - 1][k])
                to[i][o][k] = 1, dis[i][k] = 1;
    return;
}

void Floyed() {
    F(k, 1, N)
        F(i, 1, N)
            F(j, 1, N)
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    return;
}

int main() {
    Input();
    pre();
    Floyed();
    printf("%d", dis[1][N]);
    return 0;
}
```

---

## 作者：Drifterming (赞：1)

```
//Pro:P1613 跑路

//Floyd 

//跑路机每次能跑的距离是2^k，也就是不能在中间停下来。
//用map[i][j][k]表示i和j之间是否存在一条长度为2^k的边。
//dis[i][j]存时间
//如果map[i][j][k]中有任一为true，那么就让dis[i][j]=1，表示i到j一秒可达 
//剩下的floyd去更新就好。 

//因为会有自环，所以不能在floyd里判ijk相等continue 

//发现了自己zz的错误
//预处理的时候最外层枚举的K，应该判断map[i][k][K-1]&&map[k][j][K-1]，让map[i][j][K]=1
//否则会出现没有那么多边但是dis变成1的情况 

//令我很不解的是，m<=1000，按理说2^14=16383，
//那么两点之间距离最多也就1000km，为什么最短路径长度是<=maxlongint呢？
//而且循环到17也过不了。 

#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

const int N=55;

int n,m;
int dis[N][N];
bool map[N][N][N];

int read()
{
	char c=getchar();int num=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

int main()
{
	freopen("testdata.in","r",stdin);
	memset(dis,0x3f,sizeof(dis));
	n=read(),m=read();
	for(int i=1;i<=n;++i)
		dis[i][i]=0;
	for(int i=1,u,v;i<=m;++i)
	{
		u=read(),v=read();
		map[u][v][0]=1;
		dis[u][v]=u==v?0:1;
	}
	for(int K=1;K<=17;++K)	//预处理可以1s到达的 
	{
		for(int k=1;k<=n;++k)
		{
			for(int i=1;i<=n;++i)
			{
				for(int j=1;j<=n;++j)
				{
					if(map[i][k][K-1]&&map[k][j][K-1])
					{
						map[i][j][K]=1;
						dis[i][j]=i==j?0:1;
					}
				}
			}
		}
	}
	for(int k=1;k<=n;++k)
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=n;++j)
			{
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
		}
	}
	printf("%d",dis[1][n]);
	return 0;
}
```

---

## 作者：707001933K (赞：1)

floyd传递闭包打错了4次= =

在讨论里我解释了一下题意，那么题目就比较简单了，我们需要预处理出每个点走2^K能刚好到哪些点，在他们之间添加一条长度为1的边，题目原本给的边其实长度也都为1，因为当k=0时走2^0=1可以刚好走完一条边。

先弄个传递闭包，再floyd一下（n只有50），但其实用spfa什么的是没有办法优化复杂度的，因为有一个传递闭包O(n^3)，虽然好像有什么鬼算法可以O(n^2logn)搞闭包，不过很麻烦没必要。

最楼下的那位说的很清楚，但不得不说他的floyd闭包的循环顺序不太对，但由于比较水的数据，也就过了。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=101;
int a[N][N];
int b[N][N][N];
int n,m;
int main(){
    memset(a,0x3f,sizeof(a));
    memset(b,0,sizeof(b));
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        a[u][v]=1;
        b[0][u][v]=1;
    }
    for (int l=1;l<=64;l++)
        for (int k=1;k<=n;k++)
            for (int i=1;i<=n;i++)
                for (int j=1;j<=n;j++){
                    b[l][i][j]|=b[l-1][i][k] && b[l-1][k][j];
                    if (b[l][i][j])a[i][j]=1;
                }
    for (int k=1;k<=n;k++)
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                a[i][j]=min(a[i][k]+a[k][j],a[i][j]);
    printf("%d",a[1][n]);
    return 0;
}
```

---

## 作者：EarthGiao (赞：0)

## 【思路】
倍增 + 弗洛伊德（或其他最短路的算法）    
先用倍增预处理出来两个点之间跳2^k能不能到达      
处理的时候不像是跑倍增      
有什么dfs什么的     
可以类似弗洛伊德       
从小到大枚举k，中间点和两个点      
然后如果两个点到中间点都是需要 $2^{k-1}$ 步就可以跑过去     
那么这两个点之间就可以通过 $2^k$ 跳过去     
然后如果这两个点可以跳起来          
那就可以用一个弗洛伊德常用的二维数组储存一下     
距离为1    

最后就可以跑弗洛伊德了     
枚举中间点和两个点      
如果两个点到中间点的距离和加起来小于两个点之间的直接距离    
那就替换掉     

输出f[1][n]就可以了      
注意：     
这是有向边！不要想当然的想成无向边！      

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;
const int Max = 55;
bool fa[Max][Max][34];
int n,m;
bool use[Max];
int f[Max][Max];

int main()
{
	memset(f,9999,sizeof(f));
	cin >> n >> m;
	int u,v;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> u >> v;
		f[u][v] = 1;
		fa[u][v][0] = true;
	}
	for(register int l = 1;l <= 32;++ l)
		for(register int k = 1;k <= n;++ k)
			for(register int i = 1;i <= n;++ i)
				for(register int j = 1;j <= n;++ j)
					if(fa[i][k][l - 1] == true && fa[k][j][l - 1] == true)
						fa[i][j][l] = true,f[i][j] = 1;
	for(register int k = 1;k <= n;++ k)
		for(register int i = 1;i <= n;++ i)
			for(register int j = 1;j <= n;++ j)
				if(i != k && j != k)
					f[i][j] = min(f[i][j],f[i][k] + f[k][j]);
	cout << f[1][n] << endl;
	return 0;
} 
```

---

## 作者：TheShadow (赞：0)

# 闲扯

一年前刚学倍增的时候老师给的训练题，一直没做，过来填坑了。

# 题面

[P1613 跑路](https://www.luogu.org/problem/P1613)

# Solution

因为每秒能跑的长度为 $2^k$ ，所以对于一对 $u,v$ ，如果它们之间的距离能用 $2^k$ 表示出来，那么我们就可以从 $u$ 向 $v$ 连一条长度为 $1$ 的边。

而这个问题的形式恰好是倍增能够解决的，所以我们直接用 $mp_{i,j,k}$ 表示从 $i$ 向 $j$ 的路径长度能否用 $2^k$ 表示，然后结合一下 $Floyd$ 的写法，得到所有的 $mp_{i,j,k}$ ，如果 $mp_{i,j,k}=1$ ，那么我们就从 $i$ 向 $j$ 连一条权值为 $1$ 的边，然后 $Floyd$ 跑最短路即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x/10) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 55; 
int mp[MAXN][MAXN][MAXN],dis[MAXN][MAXN],n,m,u,v;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),del(dis,0x3f);
	for(ri i=1;i<=m;++i){
		read(u),read(v);
		mp[u][v][0]=1,dis[u][v]=1;
	}
	for(ri t=1;t<32;++t)
		for(ri i=1;i<=n;++i)
			for(ri k=1;k<=n;++k)
				for(ri j=1;j<=n;++j)
					if(mp[i][k][t-1]&&mp[k][j][t-1])
						mp[i][j][t]=1,dis[i][j]=1;
	for(ri k=1;k<=n;++k)
		for(ri i=1;i<=n;++i)
			for(ri j=1;j<=n;++j)
				if(dis[i][k]+dis[k][j]<dis[i][j])
					dis[i][j]=dis[i][k]+dis[k][j];
	print(dis[1][n]);
	return 0;
}
```

# 总结

这道题有 $2^k$ 这种很好的形式，考虑到倍增就是以其为基础的，巧妙的运用倍增来解题。

---

## 作者：Harece (赞：0)

题目用倍增进行确定路径， Floyd来找到答案。

用一个三元数组f[i][j[k], i 与 j 表示从点i到点j，k表示这条路的长度为2 ^ k，当f[i][j][k] = 1时表示存在这样一条路，反正则无。 这样预处理后，跑一次Floyd就可以得出答案。

有一点需要注意，题目中m <= 10000, 而2的14次方已经大于10000，但在倍增时外循环的值k却要大于14才能AC此题的原因是如图

![](https://cdn.luogu.com.cn/upload/image_hosting/0jz9ztbg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)



我们可以发现把那个环跑两次就可以得到16的路程得到答案1，这时2 ^ 4大于边数10.所以由此可以推理当把环的长度变大时可能可以凑出一个k，这时2  ^ k 远大于10000.

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int inf = 777777;

int n, m;
int f[51][51][50], ans[51][51];

template<typename T>
inline void read(T &x){
	x = 0;
	T op = 1;
	char c = getchar();
	for(; c < '0' || c > '9'; c = getchar())
		if(c == '-')	op = -1;
	for(; c <= '9' && c >= '0'; c = getchar())
		x = (x << 3) + (x << 1) + c - '0';
	x *= op; 
} 

int main(){
	read(n), read(m);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= n; ++j){
			if(i != j)	ans[i][j] = inf;
			else ans[i][j] = 0;
		}
	for(int i = 1; i <= m; ++i){
		int x, y;
		read(x), read(y);
		f[x][y][0] = 1;
		if(x != y) ans[x][y] = 1;	
	}
	for(int k = 1; k < 50; ++k)
		for(int v = 1; v <= n; ++v)
			for(int i = 1; i <= n; ++i)
				for(int j = 1; j <= n; ++j)
					if(f[i][v][k - 1] && f[v][j][k - 1]){
						f[i][j][k] = 1;
						if(i != j) ans[i][j] = 1;
					}
	for(int k = 1; k <= n; ++k)
		for(int i = 1; i <= n; ++i)
			for(int j = 1; j <= n; ++j)
				ans[i][j] = min(ans[i][j], ans[i][k] + ans[k][j]);
	printf("%d\n", ans[1][n]);
	return 0;
}
```



---


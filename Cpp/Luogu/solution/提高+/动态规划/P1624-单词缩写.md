# 单词缩写

## 题目描述

树树发现好多计算机中的单词都是缩写，如 GDB 是全称 Gnu DeBug 的缩写。但是，有时候缩写对应的全称会不固定，如缩写 LINUX 可以理解为：

1. LINus’s UniX
2. LINUs’s miniX
3. Linux Is Not UniX

现在树树给出一个单词缩写，以及一个固定的全称（若干个单词组成，空格隔开）。全称中可能会有无效的单词，需要忽略掉，一个合法缩写要求每个有效单词中至少有一个字符出现在缩写中，所写必须按顺序出现在全称中。

对于给定的缩写和一个固定的全称，问有多少种解释方法？解释方法为所写的每个字母在全称每个有效单词中出现的位置，有一个字母位置不同，就认为是不同的解释方法。




## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 100$，每行字符串长度不超过 $150$，询问次数不超过 $20$，最后方案数不超过 $10^9$。

## 样例 #1

### 输入

```
2
and
of
ACM academy of computer makers
RADAR radio detection and ranging
LAST CASE```

### 输出

```
ACM can be formed in 2 ways
RADAR is not a valid abbreviation```

# 题解

## 作者：xgzc (赞：14)

**看大家都是N^4或N³算法，N²算法还没有，~~赶紧水一发~~**

基本思路:

把所有串连接起来，记录每个串的尾后位置，

设f[k][i]表示现在在处理缩写的第K个字符，在大字符串中第I个位置对前面字符的总贡献数，则f[k][i]=Σf[k-1][j]，

其中j表示满足条件的前一个缩写字符。其中满足条件的定义为“无空缺单词，且是前一个字母”。则答案为Σf[最后一个字符][j],(1<=j<=n)。

为避免出现同一字母出现位置的不同，用一个数组进行标记即可。

###标记要一次打完才能更新！！！

```cpp
#include<bits/stdc++.h>
#define RG register
using namespace std;

int n;
char a[110][200];//无效单词
char c1[200];
char c[200];
char all[200][200];//有效单词
int ma[26][200];//每个字母的有效位置
int tag[200];
int tag1[200];//两个标记
int cut[200];//单词的尾后位置
int sum[26];//出现的次数
int f[200][200];//dp数组

int main()
{
    scanf("%d\n",&n);
    for(RG int i=1;i<=n;i++)
    {
        scanf("%s",a[i]);
    }
    scanf("%s",c1);
    while(1)
    {
        RG int i_1_1=1;
        strcpy(c,c1);
        if(strcmp(c,"LAST")==0)
        {
            scanf("%s",all[i_1_1++]);
            if(strcmp(all[i_1_1-1],"CASE")==0) break;
        }
        while(cin>>all[i_1_1++])
        {
            RG int j=0;
            int len=strlen(all[i_1_1-1]);
            while(all[i_1_1-1][j]<'a'&&j<len) j++;
            if(j>=len)
            {
                strcpy(c1,all[i_1_1-1]);
                i_1_1--;
                break;
            }
            else
            {
                for(RG int i=1;i<=n;i++)
                {
                    if(strcmp(a[i],all[i_1_1-1])==0)
                    {
                        i_1_1--;
                        break;
                    }
                }
            }
        }
        i_1_1--;
        printf("%s ",c);
        int len=strlen(c);
        for(RG int i=0;i<len;i++)
        {
            c[i]=c[i]+32;
        }
        //读入
        if(len<i_1_1)//分类讨论
        {
            puts("is not a valid abbreviation");
        }
        else if(len==i_1_1)
        {
            int ans=1;
            for(RG int i=0;i<len;i++)
            {
                int len2=strlen(all[i+1]);
                RG int tmp=0;
                for(RG int j=0;j<len2;j++)
                {
                    if(all[i+1][j]==c[i]) tmp++;
                }
                if(tmp) ans*=tmp;
                else
                {
                    puts("is not a valid abbreviation");
                    break;
                }
            }
            printf("can be formed in %d ways\n",ans);
        }
        else //重点
        {
            memset(sum,0,sizeof(sum));
            memset(f,0,sizeof(f));
            memset(tag,0,sizeof(tag));
            memset(cut,0,sizeof(cut));
            memset(ma,0,sizeof(ma));
            int cz=strlen(all[1]);
            for(int i=2;i<=i_1_1;i++)
            {
                 strcpy(all[1]+cz,all[i]);
                 cut[i-1]=cz;
                 cz=strlen(all[1]);
            }
            //连串
            cut[i_1_1]=cz;
            for(int i=0;i<cz;i++)
            {
                int j=all[1][i]-'a';
                ma[j][++sum[j]]=i;
            }
            //记字母位置
            for(int k=0;k<len;k++)
            {
                int id=c[k]-'a';
                int ci=min(k+1,i_1_1);
                int ti=1;
                for(int i=0;i<cz;i++)
                {
                    tag1[i]=tag[i];
                }//备份
                for(int i=1;i<=sum[id]&&ma[id][i]<cut[ci];i++)
                {
                    while(ma[id][i]>=cut[ti]) ti++;
                    if(i_1_1-ti>len-k-1) continue;
                    if(k==0)
                    {
                        tag1[ma[id][i]]=0;//标记
                        f[k][i]=1;//初始值
                    }
                    else
                    {
                        int t=c[k-1]-'a';
                        for(int j=1;j<=sum[t];j++)
                        {
                            if(ma[t][j]<ma[id][i]&&ma[t][j]>=cut[ti-2]&&tag[ma[t][j]]==k-1)
                            {
                                f[k][i]+=f[k-1][j];//转移
                                tag1[ma[id][i]]=k;//标记×2
                            }
                        }
                    }
                }
                for(int i=0;i<cz;i++)
                {
                    tag[i]=tag1[i];//备份
                }
            }
            int ans=0;
            for(int i=1;i<=sum[c[len-1]-'a'];i++)
            {
                ans+=f[len-1][i];//求和
            }
            if(ans)
            {
                printf("can be formed in %d ways\n",ans);
            }
            else puts("is not a valid abbreviation");
        }
    }
    return 0;
}
```

---

## 作者：poorpool (赞：7)

蒟蒻也能写出来的AC代码！这题好坑啊QAQ，我写的时候输入写了一个小时，too many or too few lines又调了好久好久，状态转移方程还是抄的书。


设计状态转移方程的时候，如果是根据已知求当下会比较难设计，如果根据已知更新未知就相对好设计一些。我们拿$\ dp[i][j][k]$

表示做到缩写中的前$\ i$位，单词中的前$\ j-1$个单词外带第$\ j$个单词的前$\ k$位的合法的方案数，其中缩写中的第$\ i$位与第$\ j$个单词的第$\ k$位匹配。


显然从$\ dp[i][j][k]$可以做出两种转移：


- 转移到这个单词的第$\ l$位，其中$\ l>k$，且第$\ j$个单词的第$\ l$位是与缩写的第$\ i+1$位匹配的。即`dp[i+1][j][l]+=dp[i][j][k];`


- 转移到下一个单词的第$\ l$位，其中第$\ j+1$个单词的第$\ l$位是与缩写的第$\ i+1$位匹配的。即`dp[i+1][j+1][k]+=dp[i][j][k];`


可以发现每个合法状态都由合法状态转移而来。


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
struct Words{
    int len;
    char a[155];
}words[155], useless[105], e[2];
int n, cnt, dp[155][155][155], sum;
char ch[250];
bool deng(Words &x, Words &y){
    if(x.len!=y.len)    return false;
    for(int i=1; i<=x.len; i++)
        if(x.a[i]!=y.a[i])    return false;
    return true;
}//判断两个单词是否相等
bool work(){
    cnt = 0;//表示单词数
    char c=getchar();
    int len=0;
    while (!((c>='a'&&c<='z') || (c>='A'&&c<='Z') || c==' ')) c=getchar();
    while ((c>='a'&&c<='z') || (c>='A'&&c<='Z') || c==' '){
        ch[len++] = c;
        c = getchar();
    }
    memset(words[0].a, 0, sizeof(words[0].a));
    words[0].len = 0;
    for(int i=0; i<len; i++){
        if((ch[i]>='a' && ch[i]<='z') || (ch[i]>='A' && ch[i]<='Z'))
            words[cnt].a[++words[cnt].len] = ch[i];
        else{
            for(int i=1; i<=n; i++)
                if(deng(words[cnt], useless[i])){
                    cnt--;
                    break;
                }
            cnt++;
            words[cnt].len = 0;
            memset(words[cnt].a, 0, sizeof(words[cnt].a));
        }
    }
    for(int i=1; i<=n; i++)
        if(deng(words[cnt], useless[i])){
            cnt--;
            break;
        }
    //对最后一个单词的合法性进行检验
    if(deng(words[0], e[0]) && deng(words[1], e[1]))    return false;
    memset(dp, 0, sizeof(dp));
    char check[155];
    int checklen=words[0].len;
    for(int i=1; i<=words[0].len; i++)
        check[i] = words[0].a[i] - 'A' + 'a';
    dp[0][0][1] = 1;
    for(int i=0; i<checklen; i++)
        for(int j=0; j<=cnt; j++)
            for(int k=1; k<=words[j].len; k++)
                if(dp[i][j][k]){//小小优化
                    for(int l=k+1; l<=words[j].len; l++)
                        if(words[j].a[l]==check[i+1])
                            dp[i+1][j][l] += dp[i][j][k];
                    if(j<cnt)//要是j=cnt就肯定不用再往下一个单词扩展了，因为下一个单词都没了……
                        for(int l=1; l<=words[j+1].len; l++)
                            if(words[j+1].a[l]==check[i+1])
                                dp[i+1][j+1][l] += dp[i][j][k];
                }
    sum = 0;
    for(int i=1; i<=words[cnt].len; i++)
        if(check[checklen]==words[cnt].a[i])
            sum += dp[checklen][cnt][i];//统计答案
    if(sum)    printf("%s can be formed in %d ways\n", words[0].a+1, sum);
    else    printf("%s is not a valid abbreviation\n", words[0].a+1);
    return true;
}
int main(){
    cin>>n;
    e[0].a[1] = 'L';e[0].a[2] = 'A';e[0].a[3] = 'S';e[0].a[4] = 'T';
    e[1].a[1] = 'C';e[1].a[2] = 'A';e[1].a[3] = 'S';e[1].a[4] = 'E';
    e[0].len = e[1].len = 4;
    for(int i=1; i<=n; i++){
        scanf("%s", useless[i].a+1);
        useless[i].len = strlen(useless[i].a+1);
    }
    while(work())    ;
    return 0;
}
```

---

## 作者：caoruiqi (赞：4)

2024/10/16 upd：更改了 update 的写法。

# description

题目讲得很清楚了，唯一的坑点是**缩写中，不一定一个字母对应一个单词**。

---

# solution

看一眼数据范围，$len \le 150$，考虑 **dp**。

---

## 读入

先：

```cpp
cin>>s[0];//读入第一行缩写
```

然后再 while 循环处理：

```cpp
while(1){
    cin>>s[++sum];
    if(mp[s[sum]]){//去除无效字母
        sum--;
        continue;
    }
    if(sum==1&&s[0]=="LAST"&&s[1]=="CASE"){//结束条件
        break;
    }
    if(s[sum][0]>='A'&&s[sum][0]<='Z'){//开始处理的条件，即读到缩写就处理上一行
        sum--;//把下一行的缩写踢出去
```

以及：

```cpp
s[0]=s[sum+1];//将下一行缩写存到s[0]
sum=0;
```

---

## dp 实现

设 $dp_{i,j}$ 表示前 $i$ 个单词缩写，对应前 $j$ 个字母的方案数。那么，根据乘法原理和加法原理，可得转移为：

$$
dp_{i,j} = \sum_{k = i-1}^{j - 1} sum_{i,k,j-1} dp_{i-1,k}
$$

记 $s$ 为缩写从第 $k$ 到第 $j-1$ 个字母的子串，则 $sum _{i,k,j-1}$ 表示 $s$ 在第 $i$ 个单词中出现的次数。而求 $sum$ 的过程刚好对应求 $s$ 与第 $i$ 个单词最长公共子序列的长度刚好为 $s$ 的长度的计数。而我们有 [P2516 最长公共子序列](https://www.luogu.com.cn/problem/P2516)。

至于求和为什么是从 $i-1$ 到 $j-1$。因为一个单词至少对应一个缩写字母，前 $i-1$ 个单词要对应 $i-1$ 个字母，所以下界为 $i-1$。同理，第 $i$ 个单词至少要对应一个字母，所以上界为 $j-1$。

于是，~~欢愉地 AC 了~~。

---

# code

```cpp
//#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;
int max(int a,int b){
	return a>b?a:b;
}
int min(int a,int b){
	return a<b?a:b;
}
int read(){
	int x=0,lcs=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-'){
			lcs=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*lcs;
}
void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
	return;
}
int n,sum,i,j,ans,k,dp[151][151],lcs[2][151],num[2][151];
char c;
string fei[101],s[152],ss;
pair<int,int> dpp(int k,int l,int rr){
	int i,j;
	string a=" ",b=" "+s[k];
	for(i=l;i<=rr;i++){
		a=a+s[0][i];
	}
	int n=a.size()-1,m=b.size()-1,now=1,pre=0;
	for(i=0;i<=m;i++){
		num[0][i]=1; 
		num[1][i]=0;
		lcs[0][i]=0;
		lcs[0][i]=0;
	}
	num[1][0]=1;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			lcs[now][j]=max(lcs[pre][j],lcs[now][j-1]);
			num[now][j]=0;
			if(a[i]+32==b[j]){
				lcs[now][j]=max(lcs[now][j],lcs[pre][j-1]+1); 
			}
			if(a[i]+32==b[j]&&lcs[now][j]==lcs[pre][j-1]+1){
				num[now][j]+=num[pre][j-1];
			}
			if(lcs[pre][j]==lcs[now][j]){
				num[now][j]+=num[pre][j];
			}
			if(lcs[now][j-1]==lcs[now][j]){
				num[now][j]+=num[now][j-1];
			}
			if(lcs[pre][j-1]==lcs[now][j]){
				num[now][j]-=num[pre][j-1];
			}
		}
		now=pre;pre=1-pre;
	}
	return {lcs[pre][m],num[pre][m]};
}
map<string,bool> mp;
int main(){
	//freopen("abbr.in","r",stdin);
	//freopen("abbr.out","w",stdout);
	n=read();
	for(i=1;i<=n;i++){
		cin>>fei[i];
		mp[fei[i]]=1;
	}
	if(n!=0){
		c=getchar();	
	}
    cin>>s[0];
	while(1){
		cin>>s[++sum];
        if(mp[s[sum]]){
            sum--;
            continue;
        }
        if(sum==1&&s[0]=="LAST"&&s[1]=="CASE"){
            break;
        }
        if(s[sum][0]>='A'&&s[sum][0]<='Z'){
            sum--;
            for(i=0;i<=sum;i++){
                for(j=0;j<=s[0].size();j++){
                    dp[i][j]=0;
                }
            }
            for(i=1;i<=s[0].size()-sum+1;i++){
                pair<int,int> tmp=dpp(1,0,i-1);
                if(tmp.first==i){
                    dp[1][i]=tmp.second;
                }
                else{
                    break;
                }
            }
            for(i=2;i<=sum;i++){
                for(j=i;j<=s[0].size()-sum+i;j++){
                    for(k=j-1;k>=i-1;k--){
                        pair<int,int> tmp=dpp(i,k,j-1);
                        if(tmp.first==j-k){
                            dp[i][j]+=dp[i-1][k]*tmp.second;
                        }
                        else{
                            break;
                        }
                    }
                }
            }
            cout<<s[0];
            if(dp[sum][s[0].size()]!=0){
                printf(" can be formaed in ");
                write(dp[sum][s[0].size()]);
                puts(" weys");
            }
            else{
                puts(" is not a velid abbraviation");
            }
            s[0]=s[sum+1];
            sum=0;
        }
	}
	return 0;
}
```
附上几个[样例](https://www.luogu.com.cn/paste/8k0cpyln)。

---

## 作者：Itst (赞：3)

### ~~发题解的目的其实是安利stringstream~~
### 最开始$O(N)$暴力判有没有无用串
### DP状态：设$f_{i,j}$为匹配到第$i$个全称字符串，缩写串匹配到$j$时的方案数，从前往后扫，缩写中第$j$个与全程串中某一个相同，状转就是$f_{i,j}+=f_{i-1,j-1}+f_{i,j-1}$，最后答案就是$f_{num,size}$，$num$是有效串个数，$size$是匹配串长度。~~易知~~复杂度为$O(size^3)$，匹配环节可以使用$vector$模拟桶降低复杂度
### 关于$stringstream$用法与$cin$相似，可以模拟$cin$类型的输入输出流，对于这种奇葩输入以及$UVA,USACO$的各种奇怪输入数据有奇效$qwq$（要注意$getline$会读入'\r'所以最后的结束判断需要在最后加上'\r'）
### 凌乱的代码$qwq$
```
#include<bits/stdc++.h>
using namespace std;

string com[201] , no[201] , mod;
int ans[201][201];
vector < int > pot[26];

int main(){
    int N;
    cin >> N;
    for(int i = 1 ; i <= N ; i++)
        cin >> no[i];
    string s;
    stringstream ss;
    getline(cin , s);
    while(getline(cin , s) && s != "LAST CASE" && s != "LAST CASE\r"){
    //注意"LAST CASE\r"的判断！
		ss.clear();
        //清空输入输出流
        ss.str(s);
        //将输入输出流ss赋值为s
        ss >> mod;
        //这样子可以用stringstream模拟cin操作！
        for(int i = 0 ; i < 26 ; i++)
            pot[i].clear();
        for(int i = 0 ; i < mod.size() ; i++)
            pot[mod[i] - 'A'].push_back(i);
        int dir = 0;
        while(ss >> com[dir]){
            bool f = 0;
            for(int i = 1 ; !f && i <= N ; i++)
                if(com[dir] == no[i])
                    f = 1;
            if(!f)
                dir++;
        }
        memset(ans , 0 , sizeof(ans));
        ans[0][0] = 1;
        //DP!
        for(int i = 0 ; i < dir ; i++)
            for(int j = 0 ; j < com[i].size() ; j++)
                for(int k = pot[com[i][j] - 'a'].size() - 1 ; k >= 0 ; k--)
                    ans[i + 1][pot[com[i][j] - 'a'][k] + 1] += ans[i][pot[com[i][j] - 'a'][k]] + ans[i + 1][pot[com[i][j] - 'a'][k]];
        if(ans[dir][mod.size()])
            cout << mod << " can be formed in " << ans[dir][mod.size()] << " ways" << endl;
        else
            cout << mod << " is not a valid abbreviation" << endl;
    }
    return 0;
}
```

---

## 作者：ysner (赞：1)

先暴力去掉所有的单词，只对有效单词进行计算。

dp[i][j]表示前i个单词使用了前j个大写字母的方案数

初始条件dp[0][0]=1

转移：若第i个单词使用第j到第j+k个大写字母的方案数为temp[k]

则dp[i][j+k]=dp[i-1][j-1]\*temp[k]

最终ans=dp[n][m]

时间复杂度Ｏ（Ｌ１＊Ｎ＊Ｌ２＊Ｌ２）

空间复杂度Ｏ(Ｌ１\*Ｎ\*Ｌ２)

L1缩写长度   N全称中单词的个数   L2全称中一个单词的长度

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
char w[101][150];
char s[150],let[150];
char over[9]={'L','A','S','T',' ','C','A','S','E'};
struct word
{
    char c[150];
    int l;
}a[150];
int t,n,m,len;
int dp[100][150],temp[150];
bool Case_is_Over()
{
    for (int i=0;i<=8;i++)
        if (s[i]!=over[i]) return false;
    return true;
}
int main()
{
    freopen("abbr.in","r",stdin);
    freopen("abbr.out","w",stdout);
    scanf("%d\n",&t);
    for (int i=1;i<=t;i++) scanf("%s",w[i]);
    while (233)
    {
        char ch=getchar();len=0;
        while ( ! ( (ch>='a'&&ch<='z') || (ch>='A'&&ch<='Z') || ch==' ' ) ) ch=getchar();
        while ( (ch>='a'&&ch<='z') || (ch>='A'&&ch<='Z') || ch==' ' ) s[len++]=ch,ch=getchar();
        n=m=0;//设每个询问有n个单词，m个大写字母
        if (Case_is_Over()) break;
        int p=0;
        for (int i=1;i<150;i++) memset(a[i].c,0,sizeof(a[i].c)),a[i].l=0;
        while (s[p]>='A'&&s[p]<='Z')
        {
            printf("%c",s[p]);
            let[++m]=s[p]+32;
            p++;
        }
        p++;
        while (p<len)
        {
            n++;
            while (s[p]>='a'&&s[p]<='z')
            {
                a[n].c[a[n].l++]=s[p];
                p++;
            }
            for (int i=1;i<=t;i++)
                if (strcmp(w[i],a[n].c)==0)
                {
                    memset(a[n].c,0,sizeof(a[n].c));
                    a[n].l=0;
                    n--;break;
                }
            p++;
        }
        memset(dp,0,sizeof(dp));
        dp[0][0]=1;
        for (int i=1;i<=n;i++) //枚举单词
            for (int j=i;j<=i+m-n;j++) //枚举当前单词使用大写字母的起始位置
            {
                memset(temp,0,sizeof(temp));
                for (int p=0;p<a[i].l;p++) //第i个单词的第p个位置
                    for (int k=min(i+m-n-j,p);k>=0;k--) //恰好等于第j+k个大写字母
                        if (let[j+k]==a[i].c[p])
                            if (k) temp[k]+=temp[k-1];
                            else temp[k]++;
                for (int k=i+m-n-j;k>=0;k--)
                    dp[i][j+k]+=dp[i-1][j-1]*temp[k];
            }
        if (dp[n][m]) printf(" can be formed in %d ways\n",dp[n][m]);
        else printf(" is not a valid abbreviation\n");
    }
    return 0;
}

```

---

## 作者：lizicheng3042 (赞：0)

首先，看见有无用串我们考虑用 map 存，然后剩下的就是在单词串里找从每个单词里至少找出一个字母并拼成要求字符串的方案数。  
很容易想到设计一个 $dp_{i,j}$表示第 $i$ 个字符串，当前表示到要求字符串的第 $j$ 个字母的合法方案数，那么可以得知转移方程为下面的式子（设用 $A$ 表示给定的字符串，$a$ 表示正在处理的字符串，$b$ 表示 $a$ 的长度）： 
$$dp_{i,j}=\sum_{k=0}^{b-1}(dp_{i-1,j-1}+dp_{i,j-1})\times[A_j=a_k]$$  
当然，如果按正序枚举 $A$ 中字符的话会出问题(比如运行 ```AAA aaa aaa``` 这样的数据就会使答案过大)，所以我们倒序枚举，然后再加一些没什么用的滚动数组，这题就做完了。
## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
#include<iostream>
#include<string>
using namespace std;
typedef long long ll;
int n,now=-1,dp[155][2];
bool ok;
map<string,bool>k;
string o,b,w,y;
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;w="LAST";y="CASE";
	for(int a=1;a<=n;a++)
	{
		cin>>o;
		k[o]=true;
	}
	cin>>o;
	while(1)
	{
		dp[0][0]=1;
		if(now!=-1)
		{
			if(dp[o.size()][now^1]==0)
				cout<<o<<" is not a valid abbreviation"<<'\n';
			else
				cout<<o<<" can be formed in "<<dp[o.size()][now^1]<<" ways"<<'\n';			
			for(int a=1;a<=150;a++)
				dp[a][0]=dp[a][1]=0;
			o=b;	
		}
		int v=o.size();	
		cin>>b;now=1;
		if(b==y&&o==w)
			return 0;
		while(b[0]>'Z')
		{
			if(k[b]==true)
			{
				cin>>b;
				continue;
			}
			int u=b.size();
			for(int a=0;a<u;a++)
			{
				for(int c=v-1;c>=0;c--)
				{
					if(b[a]-'a'==o[c]-'A')
					{
						dp[c+1][now]+=dp[c][now^1]+dp[c][now];		
						ok=true;			
					}
				}
			}
			now^=1;
			for(int a=0;a<=v;a++)
				dp[a][now]=0;
			cin>>b;
		}
	}
	return 0;
}
```

---


# 二进制

## 题目描述

有三个整数 $A,B,C$，以下用 $N_{(2)}$ 表示 $N$ 的二进制（没有前导 $0$）。

设 $A_{(2)},B_{(2)},C_{(2)}$ 的最大长度为 $L$，你需要构造三个正整数 $X,Y,Z$，满足以下条件：

1. $X_{(2)},Y_{(2)},Z_{(2)}$ 的长度都不超过 $L$。
2. $A_{(2)}$ 与 $X_{(2)}$ 中 $1$ 的个数相同。
3. $B_{(2)}$ 与 $Y_{(2)}$ 中 $1$ 的个数相同。
4. $C_{(2)}$ 与 $Z_{(2)}$ 中 $1$ 的个数相同。
5. $X+Y=Z$。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，满足 $1 \le A,B,C \le 100$；
- 对于 $100\%$ 的数据，满足 $1 \le T \le 10$，$1 \le A,B,C \le 2^{30}$。

## 样例 #1

### 输入

```
4
7 6 9
1 1 1
1 1 4
3 3 9```

### 输出

```
10
-1
2
6```

# 题解

## 作者：木木！ (赞：15)

dalao 都用 DP，我发一发贪心的题解。

~~DP 题硬生生被做成了思维题~~

首先，不考虑长度限制，只考虑两个数字的 1 的个数。设 A 中 1 的个数为 $an$，B 中为 $bn$，C 中为 $cn$。

如果 $an+bn<cn$ 的话，显然无解，因为 1 不可能被凭空创生而来。如果 $an+bn=cn$ 的话，只需要不产生进位，即让两个加数的二进制表示全部错开就好。然后考虑 $an+bn>cn$ 的情况。

在这种情况下，我们需要通过进位消掉 $an+bn-cn$ 个 1，然后保证答案最小。

容易发现，可以简单地使用连续进位来消掉任意个数的 1：

```
 11111
+   1
------
100000
```

消掉的 1 的个数即为第一个加数的长度。

严格来说，消掉的 1 的个数的范围为 $[0,an+bn-1]$。因为，我们可以这样子：

```
 11111     1
+     111111
--------------
100000000000
```

（空格为 0）

可行性可以保证。然后就是考虑最优性。

很显然，对于这样一组连续进位，两个加数在连续进位之前的位必须都是 0。也就是说，算式里面最多只能有一组连续进位。如果有两组连续进位，可以将这两组合并，然后偷掉一个位（全 0 位显然可以直接抠掉），这样两个加数都会变小，和也会变小。

唯一的进位处就在那个连续进位的地方。

同理，这个连续进位必须在最高位。如果不是的话，可以交换顺序使它在最高位，然后偷掉一个位。

基本框架就确定了，由于消掉的 0 的个数确定，连续进位的长度也确定了，然后只需要在这个基础上贪心地将 1 用完就好了。

在这个连续进位式骨架上，我们可以做的事情包括将一个连续进位中的改成 1，以及在后面跟单独一个 1。容易证明，最优的解就是尽量用 1 填那个进位中的空，如果还有多余的 1，就在后面跟。

举个例子，例如 $an=4$，$bn=5$，$cn=5$。首先计算 $an+bn-cn=4$，所以可以先列连续进位式骨架：

```
 1111
+   1
----
10001
```

然后，还有 $an+bn-(an+bn-cn+1)=4$ 个多余的 1，其中三个可以填到空中，剩余一个放在末尾：

```
 1111
+11111
------
111101
```

程序指示 `30+31=61`，符合条件，并且正确。

代码如下：

```cpp
int a,b,c;
scanf("%d%d%d",&a,&b,&c);
		
const int l = max({
	32-__builtin_clz(a),
	32-__builtin_clz(b),
	32-__builtin_clz(c)
});

const int an = __builtin_popcount(a);
const int bn = __builtin_popcount(b);
const int cn = __builtin_popcount(c);

if(an+bn<cn || !cn)
{
	printf("-1\n");
	continue;
}
if(an+bn-cn == 0)
{
	printf("%d\n",allone(cn)); // cn个1
	continue;
}
if(an+bn-cn+1+max(2*cn-an-bn,0) > l) // 计算最终长度的式子
{
	printf("-1\n");
	continue;
}

const int diff = an+bn-cn;
int ans = 1<<diff;
for(int i=diff+1; i<an+bn; ++i)
{
	if(i-diff < diff) // 往空里填数
	{
		ans |= 1<<(i-diff);
	}
	else // 往末尾加数
	{
		ans = (ans<<1)|1;
	}
}
printf("%d\n",ans);
```

然后交上去，就会发现这份代码只能得 20 分。

如果 $an=4$，$bn=2$，$cn=3$，这个程序会给出下面的加式：

```
 111
+111
----
1110
```

实际上，加式是这个：

```
 1111
+ 11
-----
10101
```

这个只需要注意一下就好了。稍微修改一下代码，加一个特判，就可以 A 了。时间复杂度 $\Theta(\log n)$，常数极小，耗时 `2ms-3ms`，就是程序运行的基础时间。

附 AC 代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

inline int slen(int an,int bn,int cn) // 计算最终长度
{
	return max({an+bn-cn+1+max(2*cn-an-bn,0),an+1,bn+1});
}

inline int allone(int dig) // dig 个 1 组成的数字
{
	return (1<<dig)-1;
}

int main()
{
	int t;
	scanf("%d",&t);
	for(int asdf=1; asdf<=t; ++asdf)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		
		const int l = max({
			32-__builtin_clz(a),
			32-__builtin_clz(b),
			32-__builtin_clz(c)
		});

		const int an = __builtin_popcount(a);
		const int bn = __builtin_popcount(b);
		const int cn = __builtin_popcount(c);

		if(an+bn<cn || !cn)
		{
			printf("-1\n");
			continue;
		}
		if(an+bn-cn == 0)
		{
			printf("%d\n",allone(cn));
			continue;
		}
		if(slen(an,bn,cn) > l)
		{
			printf("-1\n");
			continue;
		}

		const int diff = an+bn-cn;  // 连续等式的长度
		const int flen = slen(an,bn,cn); // 最终结果的长度
		int ans = (1<<(flen-1))+allone(flen-diff-1); // 最终结果的骨架（连续进位式再加上末尾的1）

		for(int i=flen; i<an+bn; ++i)
		{
			ans |= 1<<(i-diff); // 因为末尾的 1 已经被加上，可以直接往空格里填 1
		}
		printf("%d\n",ans);
	}
}
```

---

## 作者：I_AM_HelloWord (赞：7)

#### 思路是借鉴楼下dalao的，Orz......Orz.......Orz

#### 这题应该是一个数位dp，我们考虑把数字都转换成二进制再进行dp。

#### 我们设dp[i][a][b][c][0/1]表示前i-1位，在数字X中已经用了a个1，数字Y中已经用了b个1，数字Z中已经用了c个1,0表示第i-1位没有进位，1则表示第i-1进位了。这时，方程就比较好写了，由于方程比较多，所以对于方程具体的解释就放在代码注释里了。

#### 考虑一下优化吧，首先，应该不用开longlong，但是那样的话写程序时就有点地方要小心（比如说dp数组刚开始时的赋的比较大的值有可能小于最终答案），其次，第i位，显然只和第i-1位有关，所以还可以弄个滚动数组搞一搞。这样，常数差不多就小了5倍（我的400+ms就跑过去了）


#### 参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define re register
#define REP(i,a,b) for (re int i=(a);i<=(b);i++)
using namespace std;
template<class T>inline void ChkMin(T &a,T b){if (b<a)a=b;}
const int N=33;
int dp[2][N][N][N][2],oo;
int A,B,C,l;
inline int Two(int k){
    re int s=0,tl=0;
    for (;k;k>>=1,++tl)s+=k&1;
    if (tl>l)l=tl;
    return s;
}
int main(){
    int T;
    scanf("%d",&T);
    while (T--){
        re int A,B,C,cur=1,pre=0,t=0;l=0;
        scanf("%d%d%d",&A,&B,&C);
        A=Two(A),B=Two(B),C=Two(C);
        memset(dp,0x7f,sizeof(dp));
        oo=dp[1][0][0][0][0];
        dp[1][0][0][0][0]=0;
        REP(i,1,l){
            pre^=1;cur^=1;
            memset(dp[cur],0x7f,sizeof(dp[cur]));//如果赋0x3f那么dp的最大值就是106.....，而有两个数据的答案达到了107......
            REP(a,0,A)REP(b,0,B)REP(c,0,C){
                t=dp[pre][a][b][c][0];
                if (t<oo){
                    ChkMin(dp[cur][a][b][c][0],t);//当前位都选0
                    ChkMin(dp[cur][a+1][b+1][c][1],t+(1<<i));//x和y当前位都选1，那么z当前位就是0，同时有一个进位。
                    ChkMin(dp[cur][a+1][b][c+1][0],t+(1<<(i-1)));//x当前位选1，y的当前位选0，那么z的当前位就是1，由于t记录的是i-1位不进位的最小结果，所以当前位也就不进位。
                    ChkMin(dp[cur][a][b+1][c+1][0],t+(1<<(i-1)));//和上面是对称的。
                }
                t=dp[pre][a][b][c][1];
                if (t<oo){
                    ChkMin(dp[cur][a][b][c+1][0],t);//x和y的当前位都选0，当时由于t记录的是i-1位进位的状态，所以z的当前位要选1
                    ChkMin(dp[cur][a+1][b+1][c+1][1],t+(1<<i));//x和y都选1，z在进位的情况下还是选1同时还要向前进位。
                    ChkMin(dp[cur][a+1][b][c][1],t+(1<<(i-1)));//x选1，y选0，z在进位的1+x的1=0，所以当前位是0,，同时向前进位。
                    ChkMin(dp[cur][a][b+1][c][1],t+(1<<(i-1)));//对称的。
                }
              }
        }
        if (dp[cur][A][B][C][0]<oo)printf("%d\n",dp[cur][A][B][C][0]);//如果不是无解，就输出dp
            else printf("-1\n");
    }
    return 0;
}
```

---

## 作者：巨型方块 (赞：4)

博客：http://blog.csdn.net/largecub233/article/details/74908225

我们考虑三个长度为l的串；

显然如果这3个串符合条件的话；

我们就只要保证增加2^l级别的值满足加法原则就好了；

所以我们大力dp;

f[i][a][b][c][0/1]

i表示位数

a表示x串前i-1个字符所有的1的数量；

b，c同理；

0/1表示c串在第i位是1还是0；

预处理

f[1][0][0][0][0]=0;其他都是inf；

转移就是考虑当前第i位a,b要不要放1；

然后对应的计算c新增的值；


```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
const int N=35;
Ll f[N][N][N][N][2],v;
int w,A,B,C,n;
int er(int x){
    int ans=0,sum=0;
    for(;x;x/=2,sum++)if(x&1)ans++;
    n=max(n,sum);
    return ans;
}
int main()
{
    scanf("%d",&w);
    while(w--){
        scanf("%d%d%d",&A,&B,&C);
        n=0;memset(f,14,sizeof f);
        A=er(A);B=er(B);C=er(C);
        f[1][0][0][0][0]=0;
        for(int i=1;i<=n;i++)
            for(int a=0;a<=A;a++)
            for(int b=0;b<=B;b++)
            for(int c=0;c<=C;c++){
                v=f[i][a][b][c][0];
                f[i+1][a  ][b  ][c  ][0]=min(f[i+1][a  ][b  ][c  ][0],v);
                f[i+1][a+1][b+1][c  ][1]=min(f[i+1][a+1][b+1][c  ][1],v+(1<<i));
                f[i+1][a+1][b  ][c+1][0]=min(f[i+1][a+1][b  ][c+1][0],v+(1<<i-1));
                f[i+1][a  ][b+1][c+1][0]=min(f[i+1][a  ][b+1][c+1][0],v+(1<<i-1));
                v=f[i][a][b][c][1];
                f[i+1][a  ][b  ][c+1][0]=min(f[i+1][a  ][b  ][c+1][0],v);
                f[i+1][a+1][b+1][c+1][1]=min(f[i+1][a+1][b+1][c+1][1],v+(1<<i));
                f[i+1][a+1][b  ][c  ][1]=min(f[i+1][a+1][b  ][c  ][1],v+(1<<i-1));
                f[i+1][a  ][b+1][c  ][1]=min(f[i+1][a  ][b+1][c  ][1],v+(1<<i-1));
            }
        if(f[n+1][A][B][C][0]>(1<<30))printf("-1\n");else printf("%lld\n",f[n+1][A][B][C][0]);
    }    
}
```

---

## 作者：913887524gsd (赞：3)

看到楼下dalao的题解表示的状态感觉不是很直观，可能是我~~太弱~~了吧。

然后我想到一个更容易直观表述的状态d[i][a][b][c][1/0]。不过这次的状态表述是指在第i位a，b，c已经有几位是1。最后一个状态表示c的第i位是0还是1。

这样比表述第i位之前的状态的表述且讨论是否进位的要明了多了
不过这样需要改一下状态转移方程：
```cpp
long long v=d[i][a][b][c][0];
            d[i+1][a  ][b  ][c  ][0]=min(d[i+1][a  ][b  ][c  ][0],v         );
            d[i+1][a+1][b+1][c+1][1]=min(d[i+1][a+1][b+1][c+1][1],v+(1<<i)  );
            d[i+1][a+1][b  ][c+1][0]=min(d[i+1][a+1][b  ][c+1][0],v+(1<<i-1));
            d[i+1][a  ][b+1][c+1][0]=min(f[i+1][a  ][b+1][c+1][0],v+(1<<i-1));
            v=d[i][a][b][c][1];
            d[i+1][a  ][b  ][c  ][0]=min(d[i+1][a  ][b  ][c  ][0],v         );
            d[i+1][a+1][b+1][c+1][1]=min(d[i+1][a+1][b+1][c+1][1],v+(1<<i  ));
            d[i+1][a+1][b  ][c  ][1]=min(d[i+1][a+1][b  ][c  ][1],v+(1<<i-1));
            d[i+1][a  ][b+1][c  ][1]=min(d[i+1][a  ][b+1][c  ][1],v+(1<<i-1));
```
最后只需要判断f[n][A][B][C][0]和f[n][A][B][C][1]的其中的最小值就可以了（
~~虽然可以直接判断n+1位~~）

---

## 作者：Jilin_1633 (赞：2)

作者：Jilin_1633（至少当时是）

算法：动态规划+bitset

简析：

可以设 $f[i][a][b][c][0/1]$，表示当前“对于第 $i$ 位，$X,Y,Z$ 分别已选择 $a,b,c$ 个 $1$ ，$Z$ 的第 $i$ 位是 $0/1$ ”情况下的 $Z$ 的最大值。

可以从 $a,b,c$ 下一位是否选择 $1$ 的方向进行考虑，状态转移较为简单易理解。具体参见代码。

其中需要求 $A,B,C$ 二进制位的数量和二进制 $1$ 的数量，因为时间充裕，此时可以使用 STL 的 bitset 进行计算，较为简便。

其他细节详见代码注释。

代码：
```cpp
#include<iostream>
#include<cstring>
#include<bitset>
using namespace std;

long long f[35][35][35][35][2];  //注意使用long long，否则喜提60pts

template<typename _Tp>
void is_min(_Tp &a,_Tp b){
	if(b<a) a=b;
} //意同 a=min(a,b)

int main(){
	int t; //t组数据
	cin>>t;
	while(t--){
		int A,B,C;
		cin>>A>>B>>C;
		bitset<32> bit_a(A),bit_b(B),bit_c(C); //将A,B,C存储于 bitset 中
		int Max=0; //A,B,C转换为二进制后位数的最大值
		Max=max(Max,(int)(32-bit_a.to_string().find_first_not_of('0')));
		Max=max(Max,(int)(32-bit_b.to_string().find_first_not_of('0')));
		Max=max(Max,(int)(32-bit_c.to_string().find_first_not_of('0')));
		A=bit_a.count(); //A的二进制中1的数量，下同
		B=bit_b.count();
		C=bit_c.count();
		memset(f,127,sizeof(f)); //初始化，各个字节设为127是最大值
		f[1][0][0][0][0]=0;
		for(int i=1; i<=Max; i++){
			for(int a=0; a<=A; a++){
				for(int b=0; b<=B; b++){
					for(int c=0; c<=C; c++){
						is_min(f[i+1][a][b][c][0],f[i][a][b][c][0]); //X,Y选择0，结果不变
						is_min(f[i+1][a+1][b+1][c][1],f[i][a][b][c][0]+(1<<i)); //X,Y都选1，结果增加2的i次方
						is_min(f[i+1][a+1][b][c+1][0],f[i][a][b][c][0]+(1<<i-1)); //X选1,Y选0，结果增加2的i-1次方
						is_min(f[i+1][a][b+1][c+1][0],f[i][a][b][c][0]+(1<<i-1)); //X选0,Y选1，结果增加2的i-1次方
						//下面与上面相同，只是Z的第i位在上一次积累成1
						is_min(f[i+1][a][b][c+1][0],f[i][a][b][c][1]);
						is_min(f[i+1][a+1][b+1][c+1][1],f[i][a][b][c][1]+(1<<i));
						is_min(f[i+1][a+1][b][c][1],f[i][a][b][c][1]+(1<<i-1));
						is_min(f[i+1][a][b+1][c][1],f[i][a][b][c][1]+(1<<i-1));
					}
				}
			}
		}
		if(f[Max+1][A][B][C][0]!=f[0][0][0][0][0]) cout<<f[Max+1][A][B][C][0];
		else cout<<"-1"; //判断无解
		cout<<"\n";
	}
	return 0; //结束
}
```

后记：这应该是一道正常的DP了，不过做的人挺少。~~刷到它也是因为1633是吉林市2024GDP啦。~~ 这种题还是很值得做的，可以提升DP的能力。

---

## 作者：ChenHaoQi (赞：2)

使用**动态规划**算法。

我们设状态 $f[i][a][b][c][0/1]$ 。

其中 $i$ 表示 **对于第 $i$ 位**，$a$ 表示 **$X$ 前面 $i-1$ 位 $1$ 的数量**，$b$ 表示 **$Y$ 前面 $i-1$ 位 $1$ 的数量**，$c$ 表示 **$Z$ 前面 $i-1$ 位 $1$ 的数量**，最后一维 $0/1$ 表示 **$Z$ 的第 $i$ 位是否为 $1$**。

初始状态对 $f$ 数组赋无穷值，设 $f[1][0][0][0][0]=0$，状态转移考虑第 $i$ 位是否选择 $1$，可以得到以下方程式的更新：
```cpp
f[i+1][a][b][c][0]=min(f[i+1][a][b][c][0],f[i][a][b][c][0]);//X，Y都选0
f[i+1][a+1][b+1][c][1]=min(f[i+1][a+1][b+1][c][1],f[i][a][b][c][0]+(1<<i));//X，Y都选1，则Z下一位为1，这一位为0
f[i+1][a+1][b][c+1][0]=min(f[i+1][a+1][b][c+1][0],f[i][a][b][c][0]+(1<<(i-1)));//X选1，则Z下一位为0，这一位为1
f[i+1][a][b+1][c+1][0]=min(f[i+1][a][b+1][c+1][0],f[i][a][b][c][0]+(1<<(i-1)));//Y选1，则Z下一位为0，这一位为1
f[i+1][a][b][c+1][0]=min(f[i+1][a][b][c+1][0],f[i][a][b][c][1]);//Z的进位
f[i+1][a+1][b+1][c+1][1]=min(f[i+1][a+1][b+1][c+1][1],f[i][a][b][c][1]+(1<<i));//X，Y都选1，Z进位，则Z下一位为1，这一位为1
f[i+1][a+1][b][c][1]=min(f[i+1][a+1][b][c][1],f[i][a][b][c][1]+(1<<(i-1)));//X选1，Z进位，则Z下一位为1，这一位为0
f[i+1][a][b+1][c][1]=min(f[i+1][a][b+1][c][1],f[i][a][b][c][1]+(1<<(i-1)));//Y选1，Z进位，则Z下一位为1，这一位为0
```

设 $a,b,c$ 分别表示数字 $A,B,C$ 转换为二进制后 $1$ 的数量，第一维计算到 $L+1$，则最终结果为 $f[L+1][a][b][c][0]$。若 $f[L+1][a][b][c][0]$ 未被更新（无穷值），则无解输出 `-1`。

[AC](https://www.luogu.com.cn/record/203277503) 代码如下：
```cpp
#include<iostream>
#include<cstring>
using namespace std;

#define MEM_MAX 127
const int maxn=30;
long long f[maxn+5][maxn+5][maxn+5][maxn+5][2];

int popcount(int x,int &Max){
	int sum=0,ans=0;
	while(x!=0){
		if((x&1)==1) ans++;
		x>>=1;
		sum++;
	}
	Max=max(Max,sum);
	return ans;
} 

int main(){
	int t;
	cin>>t;
	while(t--){
		int A,B,C;
		cin>>A>>B>>C;
		int L=-1;
		A=popcount(A,L);
		B=popcount(B,L);
		C=popcount(C,L);
		memset(f,MEM_MAX,sizeof(f));
		long long inf=f[0][0][0][0][0];
		f[1][0][0][0][0]=0;
		for(int i=1; i<=L; i++){
			for(int a=0; a<=A; a++){
				for(int b=0; b<=B; b++){
					for(int c=0; c<=C; c++){
						f[i+1][a][b][c][0]=min(f[i+1][a][b][c][0],f[i][a][b][c][0]);
						f[i+1][a+1][b+1][c][1]=min(f[i+1][a+1][b+1][c][1],f[i][a][b][c][0]+(1<<i));
						f[i+1][a+1][b][c+1][0]=min(f[i+1][a+1][b][c+1][0],f[i][a][b][c][0]+(1<<(i-1)));
						f[i+1][a][b+1][c+1][0]=min(f[i+1][a][b+1][c+1][0],f[i][a][b][c][0]+(1<<(i-1)));
						f[i+1][a][b][c+1][0]=min(f[i+1][a][b][c+1][0],f[i][a][b][c][1]);
						f[i+1][a+1][b+1][c+1][1]=min(f[i+1][a+1][b+1][c+1][1],f[i][a][b][c][1]+(1<<i));
						f[i+1][a+1][b][c][1]=min(f[i+1][a+1][b][c][1],f[i][a][b][c][1]+(1<<(i-1)));
						f[i+1][a][b+1][c][1]=min(f[i+1][a][b+1][c][1],f[i][a][b][c][1]+(1<<(i-1)));
					}
				}
			}
		}
		if(f[L+1][A][B][C][0]!=inf) cout<<f[L+1][A][B][C][0];
		else cout<<"-1";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：2)

考虑贪心。~~（其实这题多测试几个动归的结果之后规律就出来了）~~。

首先处理数据，将数字转化为 $1$ 的个数（记为 $m,n$，不妨设 $m<n$）和长度限制 $L$。

然后考虑极端情况：如果目标只有一个 $1$，必然是最低位两个 $1$ 相加然后全部进位；如果是 $m+n$ 个 $1$，必然是全部错位。这两种情况显然结果位数特别大（前者 $m+n+1$ 位；后者 $m+n$ 位，方便讨论接下来视作首位为 $0$ 的 $m+n+1$ 位），而任何结果都最少有 $n+1$ 位（除非如上全部错开，进位在所难免）。

考虑尽可能减少位数的构造：低位进位而来的 $1$ 和一个加数的 $1$ 进位产生的 $0$ 可以由另一个加数的 $1$ 填充，同时另一个加数独占的 $1$ 位数减少；若该独占 $1$ 有低位进位而来的 $1$，则 $1$ 的个数增多 $1$，同时位数减少 $1$。同理对于目标 $1$ 较多的情况，将首位进位的 $1$ 分配到独立位上，则 $1$ 的个数增多 $1$，同时位数增多 $1$。

同时，对于 $1$ 的个数少于 $m$ 的情况（进位产生的 $0$ 不少于 $n$ 个，但并没有 $m$ 个 $1$ 参与填充）和 $1$ 的个数多于 $n$ 的情况（以 $1$ 的个数显然）结果位数必然大于 $n+1$ 位，且可归纳位数的严格单调性。由此证明了位数变换的正确性。

确定了位数和 $1$ 的个数，最小值只需使结果合法的前提下 $1$ 尽可能靠后即可，即尽可能填充靠后的 $0$ 或将 $1$ 置于所有位之后即可。通过归纳可得出构造公式（见 AC 代码），是 $O(1)$ 的。
#### 代码
```python
def convert(i):
    return bin(int(i))

for _ in range(int(input())):
    a, b, c = map(convert, input().split())
    max_len = max(len(a), len(b), len(c))
    x = a.count('1')
    y = b.count('1')
    z = c.count('1')
    
    if z < min(x, y):
        ans = '0b1' + '0' * (x + y - z - z) + '1' * (z - 1) + '0'
    elif z < max(x, y):
        ans = '0b1' + '0' * (max(x, y) - z) + '1' * (min(x, y) - 1) + '0' + '1' * (z -min(x, y))
    elif z < x + y:
        ans = '0b' + '1' * (x + y - z) + '0' + '1' * (z + z - x - y)
    else:
        ans = '0b' + '1' * (x + y)#其实和上一组同理，但是前导零是个问题，所以单拿出来

    if len(ans) > max_len:
        print(-1)
    else:
        print(eval(ans))
```

---

## 作者：Sol1 (赞：2)

考虑 DP。

设 $f(i,a,b,c,0/1)$ 代表决策了最低的 $i$ 位，三个数分别用掉了 $a$、$b$、$c$ 个 $1$，在最高位不产生 / 产生进位时，$z$ 的最小值。

边界就是 $f(0,0,0,0,0)=0$。

转移分情况讨论：

1. 0+0+0=0/0，有转移 $f(i,a,b,c,0)\leftarrow f(i-1,a,b,c,0)$；
1. 1+0+0=0/0，有转移 $f(i,a,b,c,0)\leftarrow f(i-1,a-1,b,c,0)+2^{i-1}$；
1. 0+1+0=0/0，有转移 $f(i,a,b,c,0)\leftarrow f(i-1,a-1,b,c,0)+2^{i-1}$；
1. 0+0+1=0/0，有转移 $f(i,a,b,c,0)\leftarrow f(i-1,a-1,b,c,0)+2^{i-1}$；
1. 1+1+0=0/1，有转移 $f(i,a,b,c,1)\leftarrow f(i-1,a-1,b-1,c,0)$；
1. 1+0+1=0/1，有转移 $f(i,a,b,c,1)\leftarrow f(i-1,a-1,b,c,1)$；
1. 0+1+1=0/1，有转移 $f(i,a,b,c,1)\leftarrow f(i-1,a,b-1,c,1)$；
1. 1+1+1=1/1，有转移 $f(i,a,b,c,1)\leftarrow f(i-1,a-1,b-1,c-1,1)+2^{i-1}$。

（记号：$a$ 的第 $i$ 位 + $b$ 的第 $i$ 位 + $i-1$ 位进位 = $c$ 的第 $i$ 位 + 第 $i$ 位进位）

目标状态即为 $f(\lfloor\max\{\log A,\log B,\log C\}\rfloor+1,\operatorname{popcount}(A),\operatorname{popcount}(B),\operatorname{popcount}(C),0)$。

使用记忆化搜索实现，每一组测试数据都 **不需要清空 dp 数组**，总复杂度是 $O(T+\log^4 A)$。

```cpp#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline long long Abs(const long long& x) {return (x > 0 ? x : -x);}
inline long long Max(const long long& x, const long long& y) {return (x > y ? x : y);}
inline long long Min(const long long& x, const long long& y) {return (x < y ? x : y);}

long long dp[35][35][35][35][2], A, B, C;
bool vis[35][35][35][35][2];

inline long long Dfs(int idx, int a, int b, int c, bool flag) {
	if (idx < 0 || a < 0 || b < 0 || c < 0) return 0x3f3f3f3f3f3f3f3f;
	if (idx < 1) return dp[idx][a][b][c][flag];
	if (vis[idx][a][b][c][flag]) return dp[idx][a][b][c][flag];
	vis[idx][a][b][c][flag] = 1;
	long long &ans = dp[idx][a][b][c][flag];
	if (!flag) {
		ans = Min(ans, Dfs(idx - 1, a, b - 1, c - 1, 0) + (1ll << idx - 1));
		ans = Min(ans, Dfs(idx - 1, a - 1, b, c - 1, 0) + (1ll << idx - 1));
		ans = Min(ans, Dfs(idx - 1, a, b, c - 1, 1) + (1ll << idx - 1));
		ans = Min(ans, Dfs(idx - 1, a, b, c, 0));
	} else {
		ans = Min(ans, Dfs(idx - 1, a - 1, b - 1, c, 0));
		ans = Min(ans, Dfs(idx - 1, a - 1, b, c, 1));
		ans = Min(ans, Dfs(idx - 1, a, b - 1, c, 1));
		ans = Min(ans, Dfs(idx - 1, a - 1, b - 1, c - 1, 1) + (1ll << idx - 1));
	}
	//printf("(%d,%d,%d,%d,%d) %lld\n", idx, a, b, c, flag, ans);
	return ans;
}

inline int Count(long long x) {
	int ans = 0;
	while (x) {
		ans++;
		x >>= 1;
	}
	return ans;
}

int main() {
	memset(dp, 0x3f, sizeof(dp));
	dp[0][0][0][0][0] = 0;
	int t = 1;
	while (t--) {
		A = qread(); B = qread(); C = qread();
		long long ans = Dfs(Max(Max(Count(A), Count(B)), Count(C)), __builtin_popcount(A), __builtin_popcount(B), __builtin_popcount(C), 0);
		if (ans > 1e10) ans = -1;
		printf("%lld\n", ans);
	}
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}

```

---

## 作者：tbr666 (赞：2)

一道DP题

~~比较简单~~

可以定义一个四维数组 $f[i][a][b][c][j]$：当前枚举到第 $i$ 位时各用 $a,b,c$ 的几个 $1$，$j$ 表示最后一位是否有进位。
在枚举 $8$ 种进位的情况
得到方程式：
```cpp
long long x=f[i][j][k][l][0];//不进位
f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1], x+(1<<i+1));
f[i+1][j+1][k][l+1][0]=min(f[i+1][j+1][k][l+1][0], x+(1<<i));
f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0], x+(1<<i));
f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0], x);
x=f[i][j][k][l][1];//进位
f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1], x+(1<<i+1));
f[i+1][j][k+1][l][1]=min(f[i+1][j][k+1][l][1], x+(1<<i));
f[i+1][j+1][k][l][1]=min(f[i+1][j+1][k][l][1], x+(1<<i));
f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0], x);
```
AC代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int a, b, c, l, s1, s2, s3, T;
#define INF 0x7f7f7f7f7f7f7f
long long f[35][35][35][35][5];
int f1(int x)//统计转二进制时1的个数 
{
	int ans=0;
	while(x != 0)
	{
		ans+=x&1;
		x/=2;
	}
	return ans;
}
void dp() //枚举8种情况 
{
    for(int i=0; i<l; i++)
    {
        for(int j=0; j<=s1; j++)
        {
            for(int k=0; k<=s2; k++)
            {
                for(int l=0; l<=s3; l++)
                {
                    long long x=f[i][j][k][l][0];
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1], x+(1<<i+1));
                    f[i+1][j+1][k][l+1][0]=min(f[i+1][j+1][k][l+1][0], x+(1<<i));
                    f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0], x+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0], x);
                    x=f[i][j][k][l][1];
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1], x+(1<<i+1));
                    f[i+1][j][k+1][l][1]=min(f[i+1][j][k+1][l][1], x+(1<<i));
                    f[i+1][j+1][k][l][1]=min(f[i+1][j+1][k][l][1], x+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0], x);
                }
            }
        }
    }
}
int main()
{
	scanf("%d", &T);
    while(T--)
    {
    	scanf("%d%d%d", &a, &b, &c);
	    s1=f1(a), s2=f1(b), s3=f1(c);
	    l=max((int)log2(a)+1, max((int)log2(b)+1, (int)log2(c)+1));//a,b,c的最大长度 
	    memset(f, INF, sizeof f);//初始化 
	    f[0][0][0][0][0]=0;
	    dp();
	    if(f[l][s1][s2][s3][0] >= INF) printf("-1\n");//无解时 
	    else printf("%lld\n", f[l][s1][s2][s3][0]);
	}
    return 0;
}
```
[附赠一题](https://www.luogu.com.cn/problem/P4574)qwq

---

## 作者：Tenshi (赞：0)

~~我以为很多人都用的妙妙贪心，但是看上去大部分都选了正确性更显然的 DP。尽管我的 DP 方程是六维的，然而显然我的代码更简洁，所以分享一下。~~

## 分析

题目可以看作是二进制意义下的一个 $X+Y=Z$ 的竖式加法，我们考虑如何去填题目中的 $Z$ 值，$A, B, C$ 的值自然不重要，将它们的 $1$ 的位数存下来即可。然后将 DP 状态设为 $f(x, y, z, i, j, k)$，其中

- $i$ 表示（从低位到高位）已经填了 $i$ 个位。
- $x, y, z$ 分别表示第一个数已经用了 $x$ 个 $1$，第二个数已经用了 $y$ 个 $1$，第三个数已经用了 $z$ 个 $1$。
- $j$ 代表第 $i$ 位的值（$j \in \{0, 1\}$）。
- $k$ 代表第 $i$ 位有没有出现进位（$k \in \{0, 1\}$）。

下面考虑转移，可以发现对于第 $i$ 位，第一个数可以填 $0/1$，同理第二个数也可以填 $0/1$，即共有四种转移。

简洁起见，可以用两个循环来维护上面第一个数和第二数所填的值，然后根据所填的值更新对第 $i+1$ 位的**值以及进位**对应的**状态**即可。

## AC Code

```cpp
// Problem: P1633 二进制
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1633
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
 
#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()
 
#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;
 
#define int ll
#define bcnt __builtin_popcount
 
inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

int len(int x){
	return __lg(x)+1;
}

void chkmin(int &x, int y){
	x=min(x, y);
}

const int N=33;

int f[N][N][N][N][2][2];

void solve(){
	int A, B, C; cin>>A>>B>>C;
	int L=max({len(A), len(B), len(C)});
	int a=bcnt(A), b=bcnt(B), c=bcnt(C);
	
	memset(f, 0x3f, sizeof f);
	f[0][0][0][0][0][0]=0;
	rep(x, 0, a) rep(y, 0, b) rep(z, 0, c) rep(i, 0, L-1) rep(j, 0, 1) rep(k, 0, 1){
		rep(fir, 0, 1) rep(sec, 0, 1){
			int kx=x+fir, ky=y+sec;
			if(kx>a || ky>b) continue;
			int sum=k+fir+sec;
			int q=sum>>1, r=sum&1;
			int kz=z+r;
			if(kz>c) continue;
			chkmin(f[kx][ky][kz][i+1][r][q], f[x][y][z][i][j][k]+(r<<i));
		}
	}
	int res=min(f[a][b][c][L][0][0], f[a][b][c][L][1][0]);
	if(res>1e18) puts("-1");
	else cout<<res<<endl;
}

signed main(){
	int cs; cin>>cs;
	while(cs--) solve();
	return 0;
}
```

---

## 作者：Rosick (赞：0)

### 分析
1. 因为要求最小的 $Z$，考虑贪心的做法。
2. 预处理出 $A_{(2)}$，$B_{(2)}$，$C_{(2)}$ 中 1 的个数分别为 $a$，$b$，$c$，令 $x=a+b-c$，表示需要减少的 1。发现 $a$ 与 $b$ 的顺序不重要，那么令 $b<=a$。
3. 当 $a+b<c$ 时，没有办法凑出更多的 1，无解。
4. 反之，我们可以通过进位来减少多余的 1，此时需要明确两个思寻。
	1. 贪心思想：让最高位尽量小，因为 $2^{n}>\sum_{k=0}^{n-1}2^{k}$，如果为了让最高位前边的 1 位置低一点而使最高位变高，这是不值得的。同时让其他位的 1 尽量低。
	2. 减少 1 的思想：
		1. 对于一段连续的 1，只要加上一个该段最低位的 1，就可以将所有 1 消除，并在最高位的更高一位加上一个 1，而所加上的那个数除了最低位的那个 1，其他都保留。例如：
		```
		011111 //记为a
		000111 //记为b
		100110 //减去a的所有1，在a最高位更高一位增加1，保留b除了最低位以外的其他1
		```
		2. 对于两个二进制数相加，位于两个数中不同的两段1，是可以连续的，例如：
		```
		000111 //记为a
		011001 //记为b
		100001 //即相当于把a中的连续1和b中大于a最高位的连续1都删掉了
		```
5. 开始分类讨论
	1. $x\leq a$，此时靠减去 $X$ 中的 1 就可以达成目标，可以直接用第一种减 1 思想，$X$ 和 $Y$ 中多余的 1 放在减 1 部分的右边，因为如果放在左边需要多空 1 格，与我们的贪心思想相悖。例如：
	```
	0111 110 //a 5个1
	0111 001 //b 4个1
	1110 111 //变成6个1，要减去3个1，于是减1部分长度为3，剩下的不进位地放在后边
	
	0111 111 //a 6个1
	0011 000 //b 2个1
	1010 111 //变成5个1，要减去3个1，于是减1部分长度为3，剩下的不进位地放在后边
	```
	2. $a<x\leq a+b$，此时 $X$ 和 $Y$ 中都要减去 1 才能达成目标，用第二种减 1 思想。例如：
	```
	0011111 //a 5个1
	0100011 //b 3个1
	1000010 //变成2个1，要减去6个1，于是减1部分（包括a和b）长度为3
	```
6. 输出时判断一下最高位是否超出限制即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 1e5 + 10;

int read() {
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int n, x;
int a, b, c;

void pre(int tmp, int &p){
	int cnt = 0;
	while(tmp){
		if(tmp & 1) ++p;
		tmp >>= 1;
		++cnt;
	}
	n = max(n, cnt);
}

void sol() {
	n = 0;
	a = b = c = 0;
	pre(read(), a);
	pre(read(), b);
	pre(read(), c);
	if(b > a) swap(b, a);
	if(a + b < c){
		printf("-1\n");
		return;
	}
	x = a + b - c;
	if(!x){//特判一下
		printf("%d\n", (1 << c) - 1);
	} else if(x <= a){
		int tmp1 = a - x;
		int tmp2 = max(0, b - x);//注意还需要处理一下b的情况
		int tmp3 = tmp1 + tmp2 + x;//也可以再分一个情况写
		if(tmp3 >= n) printf("-1\n");
		else printf("%d\n", (1 << tmp3) + (((1 << tmp1 + b) - 1) ^ (1 << tmp1 + tmp2)));
	} else {
		if(x + 1 > n) printf("-1\n");
		else printf("%d\n", (((1 << c) - 1) ^ 1) + (1 << x));
	}
}

int main() {
	int t = read();
	while(t--)
		sol();
	return 0;
}
```

---

## 作者：xhhhh36 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P1633)

这题可以直接考虑数位 dp。设 $dp_{i,j,k,l,0/1}$ 为枚举到了前 $i$ 位，$a$ 用了 $j$ 个 $1$，$b$ 用了 $k$ 个 $1$，$c$ 用了 $l$ 个 $1$，最高位没有或有向下一位进位时 $c$ 的最小值。初始状态为 $dp_{0,0,0,0,0}=0$，其余值的为 $inf$，最终答案为 $dp_{\lfloor\max\{\log a,\log b,\log c\}\rfloor+1,\operatorname{popcount}(a),\operatorname{popcount}(b),\operatorname{popcount}(c),0}$。

考虑分类讨论进行转移，我使用的是填表法。

1. 当前最高位不进位，也就是考虑 $dp_{i,j,k,l,0}$ 从 $dp_{i-1}$ 中的哪些值转移。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位都不为 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j,k,l,0})$。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位共有一个 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j-1,k,l-1,0}+2^{i-1},dp_{i-1,j,k-1,l-1,0}+2^{i-1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位都不为 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j,k,l-1,1}+2^{i-1})$。
2. 当前最高位进位，也就是考虑 $dp_{i,j,k,l,1}$ 从 $dp_{i-1}$ 中的哪些值转移。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位都为 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,1}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k-1,l,1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位共有一个 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,1}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k,l,1},dp_{i-1,j,k-1,l,1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位没有 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k-1,l-1,1}+2^{i-1})$。

注意考虑边界的情况。
# AC code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=35,inf=0x3f3f3f3f3f3f3f3f;
int dp[N][N][N][N][2],pw[N];
int cal(int x){int ans=0;
	while (x){
		ans++;x>>=1;
	}return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0][0][0][0]=0;pw[0]=1;
	for (int i=1;i<=31;i++) pw[i]=pw[i-1]*2;
	for (int i=1;i<=31;i++){
		for (int j=0;j<=31;j++){
			for (int k=0;k<=31;k++){
				for (int l=0;l<=31;l++){
					int &now=dp[i][j][k][l][0];
					now=min(now,dp[i-1][j][k][l][0]);
					if (l) now=min(now,dp[i-1][j][k][l-1][1]+pw[i-1]);
					if (j&&l) now=min(now,dp[i-1][j-1][k][l-1][0]+pw[i-1]);
					if (k&&l) now=min(now,dp[i-1][j][k-1][l-1][0]+pw[i-1]);
					int &now1=dp[i][j][k][l][1];
					if (j) now1=min(now1,dp[i-1][j-1][k][l][1]);
					if (k) now1=min(now1,dp[i-1][j][k-1][l][1]);
					if (j&&k) now1=min(now1,dp[i-1][j-1][k-1][l][0]);
					if (j&&k&&l) now1=min(now1,dp[i-1][j-1][k-1][l-1][1]+pw[i-1]);
				}
			}
		}
	}
	int t;cin>>t;
	while (t--){
		int a,b,c;cin>>a>>b>>c;
		int ans=dp[max(cal(a),max(cal(b),cal(c)))][__builtin_popcount(a)][__builtin_popcount(b)][__builtin_popcount(c)][0];
		if (ans>=inf) cout<<-1<<"\n";
		else cout<<ans<<"\n";
	}
	return 0;
}
```

---


# OSU!

## 题目背景

原 《产品排序》 参见P2577

## 题目描述

osu 是一款群众喜闻乐见的休闲软件。 

我们可以把 osu 的规则简化与改编成以下的样子: 

一共有 $n$ 次操作，每次操作只有成功与失败之分，成功对应 $1$，失败对应 $0$，$n$ 次操作对应为 $1$ 个长度为 $n$ 的 01 串。在这个串中连续的  $X$ 个 $1$ 可以贡献 $X^3$ 的分数，这 $x$ 个 $1$ 不能被其他连续的 $1$ 所包含（也就是极长的一串 $1$，具体见样例解释） 

现在给出 $n$，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留 $1$ 位小数。

## 说明/提示

【样例说明】

$000$ 分数为 $0$，$001$ 分数为 $1$，$010$ 分数为 $1$，$100$ 分数为 $1$，$101$ 分数为 $2$，$110$ 分数为 $8$，$011$ 分数为 $8$，$111$ 分数为 $27$，总和为 $48$，期望为 $\dfrac{48}8 = 6.0$。

$n \leq 1 \times 10 ^ 5$。

## 样例 #1

### 输入

```
3 
0.5 
0.5 
0.5```

### 输出

```
6.0```

# 题解

## 作者：hall_of_history (赞：218)

有$ (x+1)^3$

$=(x+1)*(x+1)*(x+1)$

$=(x^2+2*x+1)*(x+1)$

$=x^3+2*x^2+x+x^2+2*x+1$

$=x^3+3*x^2+3*x+1;$

每多增加一个1，使答案变成$x^3+3*x^2+3*x+1,$

与原答案相比多了$3*x^2+3*x+1,$

维护这个增加值的期望

维护$x1[i]$表示$x$的期望;

维护$x2[i]$表示$x^2$的期望

$x1[i]=(x1[i-1]+1)*p[i];$

$x2[i]=(x2[i-1]+2*x1[i-1]+1)*p[i];$

那么  $ans[i]=ans[i-1]+(3*x2[i-1]+3*x1[i-1]+1)*p[i];$

最终答案就是$ans[n].$


代码：

```cpp
  #include<cstdio>
  #include<cstring>
  #include<iostream>
  #include<algorithm>

  #define maxn 111111
  #define int long long
  using namespace std;

  int n;
  double p[maxn];
  double x1[maxn],x2[maxn],ans[maxn];

  signed main()
  {
      scanf("%lld",&n);
      for(int i=1;i<=n;i++)
          scanf("%lf",&p[i]);
      for(int i=1;i<=n;i++){
          x1[i]=(x1[i-1]+1)*p[i];
          x2[i]=(x2[i-1]+2*x1[i-1]+1)*p[i];
          ans[i]=ans[i-1]+(3*(x1[i-1]+x2[i-1])+1)*p[i];
      }
      printf("%.1lf",ans[n]);
      return 0;
  }

```

---

## 作者：fdfdf (赞：190)

这道题目最后的式子看上去是很简单的，不到10行就码完了，但是求式子的过程并没有那么简单。

很容易想到一种枚举思路:
因为每一段连续的1都有一个结束位置，我们从左到右枚举这个结束位置，
再枚举在这个位置结束的连续的1的长度，最后把贡献加入答案。

用式子写出来就是:
$$\sum_{i=1}^{n}\sum_{j=1}^{i}p_{i,j}j^3$$

其中$p_{i,j}$表示**结束位置为$i$的连续1串，其长度为$j$的概率**

$p_{i,j}$可以预处理,这样做是$O(n^2)$的

如何做到$O(n)$?考虑**差分**

我们先从一个简单的问题开始

现在你有一个取值为$[1,a]$的整数随机数$x$，它取$i(1\le i\le a)$的几率为$p_i$,求$E(x)$
注意这里的$p$和前面的有所不同

根据数学知识我们知道$E(x)=\sum_{i=1}^{a}i\times p_i$

现在我们把这个求和式子**做一下变换:**
$$\sum_{i=1}^{a}i\times p_i=\sum_{i=1}^{a}\sum_{j=1}^{i}p_i=\sum_{i=1}^{a}\sum_{j=i}^{a}p_j$$
第一个等号显然
第二个等号交换了一下求和的顺序(如果不知道为什么的可以手画一下$a$较小的情况)

我们记$\sum_{j=i}^{a}p_j=f_i$，它表示**随机数的取值$\ge i$的概率**

于是我们现在得到了另一个公式:
$$E(x)=\sum_{i=1}^{a}i\times p_i=\sum_{i=1}^{a}f_i$$
从另一个角度理解这个式子:

当$a=1$时,显然$E(x)=f_1=p_1$

当$a=2$时,我们如果继续使用$f_1=p_1+p_2$作为答案,会发现我们把$x=2$对答案的贡献给算少了;

本来应该是$2\times p_2$，我们的原答案$(f_1)$里只有一个$p_2$

因此我们还要加上一个$f_2$,即$f_1+f_2$

当$a=3$时,我们如果继续使用$f_1+f_2=p_1+2p_2+2p_3$作为答案,会发现我们把$x=3$对答案的贡献给算少了;

本来应该是$3\times p_3$，我们的原答案$(f_1+f_2)$里只有两个$p_3$

因此我们还要加上一个$f_3$,即$f_1+f_2+f_3$
故每当$x$的可能取值范围扩大后，我们就需要**对于原来我们给出的期望进行补足**

回到这道题，我们要算的是$\sum_{i=1}^{n}\sum_{j=1}^{i}p_{i,j}j^3$
这里的$p$是前面的$p_{i,j}$
我们可以换成求$f_{i,j}$，它表示**结束位置为$i$的连续1串，其长度$\ge j$的概率**

如果我们只要算$\sum_{i=1}^{n}\sum_{j=1}^{i}p_{i,j}j$(没有了立方)

那么答案变成$\sum_{i=1}^{n}\sum_{j=1}^{i}f_{i,j}$

而这里的$f_{i,j}$非常好求，就是$\prod_{k=i-j+1}^{i}s_k$,

$s_k$表示第$k$个位置为$1$的概率

因为**只要$(i-j+1)$到$i$的位置全部为$1$，那么连续1串的长度一定$\ge j$**

如果我们记$x_i=\sum_{j=1}^{i}f_{i,j}$,那么递推式就是
$$x_i=p_ix_{i-1}+p_i$$
这就是大家喜闻乐见的第一个递推式

但是我们现在要算$Ans=\sum_{i=1}^{n}\sum_{j=1}^{i}p_{i,j}j^3$

使用前面的补足思想，当$x=i+1$的时候，$x^3$需要对之前补足的贡献是$(3i^2+3i+1)$

因此
$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{i}p_{i,j}j^3=\sum_{i=1}^{n}\sum_{j=1}^{i}[3(j-1)^2+3(j-1)+1]f_{i,j}$$

首先记$y_i=\sum_{j=1}^{i}j^2p_{i,j}=\sum_{j=1}^{i}[2\times (j-1)+1]f_{i,j}$，

由于$y_{i-1}\times p_i=\sum_{j=1}^{i-1}[2\times (j-1)+1]f_{i-1,j}\times p_i=\sum_{j=2}^{i}[2\times (j-2)+1]f_{i,j}$

故$y_i-y_{i-1}\times p_i=\sum_{j=2}^{i}2f_{i,j}+f_{i,1}=2x_{i-1}p_i+p_i$
因此$y_i$的递推式为
$$y_i=(y_{i-1}+2\times x_{i-1}+1)\times p_i$$

这就是大家喜闻乐见的第二个递推式

这样我们可以推到次数为$3$的情况,记

$dis_i=\sum_{j=1}^{i}p_{i,j}j^3=\sum_{j=1}^{i}f_{i,j}(3j^2+3j+1)$，

仿照$y_i$的方法我们有大家喜闻乐见的第三个递推式

$$dis_i=(dis_{i-1}+3\times y_{i-1}+3\times x_{i-1}+1)\times p_i$$

使用这三个递推式即可解决问题

虽然这三个递推式并不好理解

但难道我们只是为了$AC$数而做题的吗?

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;dd a[N],x[N],y[N],dis[N];
int main()
{
    n=read();
    for(RG int i=1;i<=n;i++){
        scanf("%lf",&a[i]);
        x[i]=(x[i-1]+1)*a[i];
        y[i]=(y[i-1]+2*x[i-1]+1)*a[i];
        dis[i]=dis[i-1]+(3*y[i-1]+3*x[i-1]+1)*a[i];
    }
    printf("%.1lf\n",dis[n]);
    return 0;
}
```




---

## 作者：ShineEternal (赞：147)

节选自[vercont的洛谷日报](https://www.luogu.org/problemnew/solution/P1654)


## 题目链接：
https://www.luogu.org/problemnew/solution/P1654

## 分析：
我们可以观察到每次对答案的贡献是三次方级别的。

吼啊，我不会三次方期望啊。

仔细观察，首先发现一次方的期望是很好弄的。

于是设$a[i]$表示前i位中第i位为1的长度的期望：

则有

$$a[i]=(a[i-1]+1)\times p[i]$$

$tag$：即为在i-1的末尾加一个概率为$p[i]$出现的1

接着推平方

设$b[i]$表示前i位中第i位为1的长度的平方的期望：

则有

$$b[i]=(b[i-1]+2\times a[i-1]+1)\times p[i]$$

$tag$:期望的线性延伸：

$$x^2->(x+1)^2->x^2+2x+1$$

运用这种方法，我们可以在求出$a[i]$的基础上推出$b[i]$

同理，设$f[i]$表示前i位中第i位为1的长度的立方的期望：

则有：

$$f[i]=(f[i-1]+3\times b[i-1]+3\times a[i-1]+1)\times p[i]$$

- 哇塞我要A紫题了！！！

然后在满心欢喜的提交上去后发现wa了。

![](https://i.loli.net/2019/08/13/nr152QKgxqmH3Xv.jpg)

显然，我们还有没考虑到的地方？

是什么呢？

是最后求得的答案与中间过渡式子的不同性。

其实，前三个式子我们都只考虑**第i位**，这样做是为了递推下面的式子，但是答案让我们求出最终的期望分数，也就是**前n位**，这时输出f[n]自然就炸了。

所以，只需把三次方递推式稍微变形一下即可；

$$f[i]=(f[i-1]+3\times b[i-1]+3\times a[i-1]+1)\times p[i]+f[i-1]\times (1-p[i])=f[i-1]+(3\times b[i-1]+3\times a[i-1]+1)\times p[i]$$

这样最终的$f[n]$就是答案喽！


### code：

```cpp
//AC记录：https://www.luogu.org/record/21569138
#include<cstdio>
using namespace std;
double a[100005],b[100005],f[100005],p[100005];
int main()
{
	int n;
   scanf("%d",&n);
   for(int i=1;i<=n;i++)
	{
       scanf("%lf",&p[i]);
       a[i]=(a[i-1]+1)*p[i];
       b[i]=(b[i-1]+2*a[i-1]+1)*p[i];
       f[i]=f[i-1]+(3*b[i-1]+3*a[i-1]+1)*p[i];
   }
   printf("%.1lf\n",f[n]);
   return 0;
}

```

~~学好数学期望，递推AC紫题！(其实这应该算dp~~

![](https://i.loli.net/2019/08/13/Ba9VxM6gkp3CvqQ.jpg)

$tag:$这题还可以扩展到k次，也就是$X^k$，用二项式定理$O(nk^2)$解决

觉得不够快？食用NTT对其加速可以达到$O(nklog_k)$

---

## 作者：kkxhh (赞：80)

我们设 $E(X_{i})$ 为在第 $i$ 个位置得的分数的期望

然后我们考虑 $E(X_{i+1})$ 和 $E(X_{i})$ 的关系

假设在 $i$ 位置连续 $1$ 串长度为 $l$ 的概率为 $p_{l}$ ，在 $i+1$ 位置是 $1$ 的概率为 $P$ ，那么对于每一个单独的 $l$ 它都有 $P$ 的概率对分数产生 $(3l^{2}+3l+1)$ 的额外贡献

我们把所有可能的 $l$ 一起考虑，就可以得到这个式子

$E(X_{i+1})=E(X_{i})+P\times\sum_{l=0}^{i}p_{l}(3l^{2}+3l+1)$

然后我们可以发现

$\sum_{l=0}^{i}p_{l}l^{2}=E(l^{2})$

$\sum_{l=0}^{i}p_{l}l=E(l)$

于是我们将式子转化为

$E(X_{i+1})=E(X_{i})+P\times(3E(l_{i}^{2})+3E(l_{i})+1)$

然后我们就成功得出了分数的期望

同时我们也要维护 $E(l)$ 和 $E(l^{2})$

$l$ 和 $l^{2}$ 都有 $1-P$ 的概率变成 $0$，$P$ 的概率增加

增加的量可以用上面类似的方法算出

$E(l_{i+1})=P\times(E(l_{i})+\sum_{l=0}^{i}p_{l})=P\times(E(l_{i})+1)$

$E(l_{i+1}^{2})=P\times(E(l_{i}^{2})+\sum_{l=0}^{i}p_{l}(2l+1))=P\times(E(l_{i}^{2})+2E(l_{i})+1)$

由此我们就得出了全部的递推关系

其实三个量完全不用用数组存，只要改变一下转移顺序就行了

代码如下

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n;
double ex,el,el2,P;

int main(){
    scanf("%d",&n);
    while(n--){
        scanf("%lf",&P);
        ex=ex+P*(3*el2+3*el+1);
        el2=P*(el2+2*el+1);
        el=P*(el+1);
    }
    printf("%.1f",ex);
    return 0;
}
```

---

## 作者：rsdbk_husky (赞：28)

~~放在前面：这是一道期望dp大水题，属于那种看题解一看就会，自己写一写就废的那种。~~

## 零. 安利：

[安利一下我的博客。](https://rsdbkhusky.github.io/)

## 一. 思路

~~（不想看我前面唠叨就直接看代码吧）~~

#### 1. 确定状态转移方程

$d_i$：$i$ 次操作后得的分数。则 $E(d_i)$：$i$ 次操作后期望的的分数。

第 $i$ 轮后，得分发生了怎样的变化了呢？我们先只看从最近一次失败后算起的成功的一段，$i$ 轮前得分是 $x^3$，如果低 $i$ 次成功，$i$ 轮后是 $(x+1)^3=x^3+3x^2+3x+1$，反之是 $0$。变化了 $3x^2+3x+1$。再加上之前的得分 $d_{i-1}$。

综上所述，已知成败情况的状转方程：

$x_i=\begin{cases}0~~~~~~~~~~~~~~~~~~~(fail)\\x_{i-1}+1~~~~~~~(success)\end{cases}$

${x^2}_i=\begin{cases}0~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fail)\\{x^2}_{i-1}+2x_{i-1}+1~~~~~~~~(success)\end{cases}$

$d_i=d_{i-1}+\begin{cases}0~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fail)\\3{x^2}_{i-1}+3x_{i-1}+1~~~~~~~~(success)\end{cases}$

设第 $i$ 次成功的几率为 $prob_i$。

**综上所述，期望状转方程**：

$E(x)_i=prob_i\times (E(x)_{i-1}+1)+(1-prob_i)\times 0$

$ ~~~~~~~~~~~=prob_i\times (E(x)_{i-1}+1)$

$E({x^2})_i=prob_i\times(E({x^2})_{i-1}+2E(x)_{i-1}+1)+(1-prob_i)\times 0$

$~~~~~~~~~~~~~=prob_i\times(E({x^2})_{i-1}+2E(x)_{i-1}+1)$

$E(d)_i=E(d)_{i-1}+prob_i\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1)+(1-prob_i)\times 0$

$~~~~~~~~~~~=E(d)_{i-1}+prob_i\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1)$



#### 2. 坑点

- $E(a^2)\ne E(a)^2$

  也就是说，不能将状转方程中的 $E(x^2)$ 用 $E(x)$ 表示。

- $d\ne x^3$

  $d$ 比 $x^3$ 还额外需要考虑之前的累计得分，也就是 $d_i$ 要加上 $d_{i-1}$。

- $E(d)$、$E(x^2)$ 和 $E(x)$ 更新的顺序

  如果你不开数组，就要格外注意这一点。$d$ 的期望状转方程中用到 $E(d)$、 $E(x^2)$ 和 $E(x)$；$x^2$ 的用到 $E(x^2)$ 和 $E(x)$；$x$ 的只用到自己，并且用的都是上一阶段的。所以先刷新 $E(d)$，再刷新 $E(x^2)$，最后 $E(x)$。

## 二. 代码

```cpp
#include<cstdio>
int n; double prob, d, x2, x;
int main() {
	scanf("%d", &n);
	while (n--) {
		scanf("%lf", &prob);
		d = d + prob * (3 * x2 + 3 * x + 1);
		x2 = prob * (x2 + 2 * x + 1);
		x = prob * (x + 1);
	}
	printf("%.1lf", d);
}
```



---

## 作者：蒟蒻wyx (赞：23)

# P1654 OSU!

- - **617**通过
  - **815**提交
- **难度** **省选/NOI-**
- **时空限制**1000ms / 128MB

## 题目描述

osu 是一款群众喜闻乐见的休闲软件。

我们可以把osu的规则简化与改编成以下的样子:

一共有$n$次操作，每次操作只有成功与失败之分，成功对应$1$，失败对应$0$，$n$次操作对应为$1$个长度为$n$的$01$串。在这个串中连续的 $X$ 个 $1$ 可以贡献 $X^3$ 的分数，这$x$个$1$不能被其他连续的$1$所包含（也就是极长的一串$1$，具体见样例解释）

现在给出$n$，以及每个操作的成功率，请你输出期望分数，**输出四舍五入后保留$1$位小数**。

## 输入输出格式

### 输入格式：

第一行有一个正整数$n$,表示操作个数。接下去$n$行每行有一个$[0,1]$的实数，表示每个操作的成功率。

### 输出格式：

只有一个实数，表示答案。答案**四舍五入后保留$1$位小数**。

## 输入输出样例

### 输入样例#1：

```
3
0.5
0.5
0.5
```

### 输出样例#1：

```
6
```

# 分析

## 简化的问题

>  如果在这个串中连续的 $X$ 个 $1$ 可以贡献 $X$ 的分数。

不要告诉我答案是多少，我们要从另一个角度入手

$f_{i,1} = f_{i-1, 1}\times (1 - p_i) + (f_{i - 1, 1} + 1)\times p_i$

合并同类项？没听说过

$1$是什么, 这里是成功连接的增加分数

显然后面这一项是成功连接上前面的一所产生的期望**总分数**

但是由于$f_i$本身的定义，导致这个并不是这一串连续$1$所产生的期望增加量

如果我们要知道在**成功连接的前提下**，这一串连续$1$所产生的期望值，我们可以将答案设为$x_{i, 1}$

$x_{i,1} = (x_{i - 1, 1} + 1)\times p_i$

这个值在接下来的过程中非常有用

## 更近一步

>  如果在这个串中连续的 $X$ 个 $1$ 可以贡献 $X^2$ 的分数。

$f_{i,2} = f_{i-1, 2}\times (1 - p_i) + (f_{i - 1, 2} + something-something)\times p_i$

$somethng-something$是什么, 这里是成功连接的增加分数

首先，我们要知道，$(\alpha + 1)^ 2=\alpha ^ 2 + 2 \alpha + 1$

所以，我们设当前的长度期望值为$l$，则有

$f_{i,2} = f_{i-1, 2}\times (1 - p_i) + (f_{i - 1, 2} + 2l + 1)\times p_i$

而这个不就是上一个问题的答案吗？

$f_{i,2} = f_{i-1, 2}\times (1 - p_i) + (f_{i - 1, 2} + 2x_{i - 1, 1} + 1)\times p_i$

同样的[^1]，我们可以将答案设为$x_{i, 2}$

$x_{i,2} = (x_{i - 1, 2} +2x_{i - 1, 1}+ 1)\times p_i$

## 最终答案

同理可得[^2]：

$f_{i,3} = f_{i-1, 3}\times (1 - p_i) + (f_{i - 1, 3} +3x_{i - 1. 2}+ 3x_{i - 1, 1} + 1)\times p_i$

代码不放了

[^1]: 由于$f_i$本身的定义，导致这个并不是这一串连续$1$所产生的期望增加量, 但是我们要知道在**成功连接的前提下**，这一串连续$1$所产生的期望值

[^2]: $(\alpha + 1)^ 3=\alpha ^ 3 +3\alpha ^ 2+ 3 \alpha + 1$



---

## 作者：Wow_Goodjob (赞：9)

**本文中的^指的都是幂运算**

先申明一点，这个分数是这么计算的：连续的1有x个，那么分值为x^3

### 下面开始真_题解

我们先审题，发现一个个算出分值的出现几率再累加明显是不够简洁的，所以我们需要一个更优秀的算法

我们再次读题，发现连续的n个数不好维护，那么我们就来考虑每个点的贡献值，我们又可以发现对于每一个1，他的贡献值是由前面的值决定的，与后面的值无关，话句话说，就是没有后效性。那么，就可以考虑一下**动态规划**，那么就来看看他是否满足以下三个条件

- 相同子问题
- 无后效性
- 最优子结构

貌似都满足的样子，那么bingo，就愉快地开始dp吧

我们来观察每个点的贡献值：设前面有i个1那么这一个点的如果还是1的话，他的贡献就是

(p+1)^3-p^3->(数学运算)->3p^2+3p+p;

那么很明显的，我们只要知道p^2与p便可以求出它的贡献

那么我们分别来算出前p位都为1($x$数组)的期望与连续p个数的平方的期望($y$数组)…………

当前i位为1，这一位为0的时候，贡献为0~~废话~~

当前i位为1，这一位也为1时，他的期望就是(前i位都为1的期望+1)*成功的几率

同样，我们可以很快的算出p^2的期望为(前i位p^2的期望+前i位为1的期望+1)*成功的几率

这样，我们就可以在O(n)的复杂度内算出所有的期望值

这时，我们的答案也显而易见了($dis$数组)，
就是

```cpp
dis[i]=dis[i-1]+(3*x[i-1]+3*y[i-1]+1)*let;
```

然后我们只要输出dis[n]就可以啦

最后照例奉献一波AC代码

(28ms(不开O2),4.28MB)

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
double let;
double x[100010]={};
double y[100010]={};
double dis[100010]={};

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	    scanf("%lf",&let);
	    x[i]=(x[i-1]+1)*let;
	    y[i]=(y[i-1]+2*x[i-1]+1)*let;
	    dis[i]=dis[i-1]+(3*x[i-1]+3*y[i-1]+1)*let;
	}
	printf("%.1lf",dis[n]);
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：7)

记打到第$i$个点的期望得分为$f_i$,记打到第$i$个点的期望长度为$d1_i$,期望长度的平方为$d2_i$。(之所以要分开统计是因为$E(l^2)$和$E(l)^2$显然不相等,不能用$d1_i^2$代替$d2_i$)  
考虑每个点的贡献:如果打中了,原来长度为$x$,现在应该变为$x+1$,得分变化为$(x+1)^3-x^3=3x^2+3x+1$。  
那么$f_i=(f_{i-1}+3d2_{i-1}+3d1_{i-1}+1)p_i$  
维护$d1$:很显然:$d1_i=(d1_{i-1}+1)p_i$  
$d_2$的维护:如果在当前打中,之前的连续长度(实际值)为$x$，则有$(x+1)^2-x^2=2x+1$。用期望维护就是$d2_{i}=(d2_{i-1}+2d1_{i-1}+1)p_i$  
```cpp
#include <cstdio>

using namespace std;

int main() {
	int n;
	double d1=0,d2=0,pi,sco=0;
	scanf("%d", &n);
	while(n--) {
		scanf("%lf", &pi);
		sco+=(3*d2+3*d1+1)*pi;
		d2=(d2+d1*2+1)*pi;
		d1=(d1+1)*pi;
	}
	printf("%.1lf\n", sco);
	return 0;	
}
```

---

## 作者：ButterflyDew (赞：6)

其实有一个卷积的想法，注意到如果普通的$f_{i,0/1}$转移的话发现$1$的转移是$1^3,2^3,\dots$什么的和$\prod p$什么的错位的在弄，但是我猜会爆精度。

事实上这个题在求连续1长度的三次方的期望，考虑先求出连续1长度1次方和2次方的期望，然后递推过来

设$a_i$代表前$i$位第$i$位为$1$的长度的期望

$$a_i=p_i(a_{i-1}+1)$$

即在末尾长度+1，成功的概率是$p_i$

然后$b_i$代表前$i$位第$i$位为$1$的长度的平方的期望
$$b_i=p_i(b_{i-1}+2a_{i-1}+1)$$
因为期望是线性的，所以可以直接按式子$x^2->x^2+2x+1$延伸贡献

形象点理解，其实这个两个式子求的都是$00\dots00111\dots11$这样的东西的期望。

然后延伸到立方其实是差不多的，但是为了统计答案需要稍微变形一下，$ans_i$代表前$i$位的答案
$$ans_i=(ans_{i-1}+3b_{i-1}+3a_{i-1}+1)p_i+ans_{i-1}(1-p_i)$$
$ans_{i-1}=c_{i-1}+oth_{i-1}$，事实上第一个式子应该这么拆开看，前面$c_{i-1}$是末尾极长$1$的答案，通过期望线性的方法和上面一样进行累加，$oth_{i-1}$的第$i-1$位是$0$，但它一样需要乘一下概率，后面的就是延长失败累加答案了。

化简一下式子就成了
$$ans_i=ans_{i-1}+(3b_{i-1}+3a_{i-1}+1)p_i$$

---

## 作者：paradoxhzy (赞：3)

应该是新的方法吧，也不知道有没有重，我尽量写的能看懂一些。 
  
  
变量说明中有一些很神奇的式子是公式的一部分，在后面会解释，放在最前面只是方便查看。  
（另外，计数从1开始）
>变量说明：  
>k[i]: 表示第i个操作的成功率。  
>E[i]: 为k[1]~k[x]中所有所有连续i个k的和，这里x是待定的。(eg.E[2] = k[1]k[2] + k[2]k[3] + ... + k[x-1]k[x])  
>d[i]: 访问到第i位时的E[2]+2E[3]+...+(i-1)E[i]。(eg.d[3] = k[1]k[2]+k[2]k[3]+2k[1]k[2]k[3])  
>l[i]: l[i] = i\*k[i]\*...\*k[1] + (i-1)\*k[i]\*...\*k[2] +...+ 1\*k[i]。  
>p[i]: p[i] = k[i]\*...\*k[1] + k[i]\*...\*k[2] + k[i]。  
  
首先来推公式。现在队列中已经有i-1次操作而且已经计算好了结果。考虑在队列的末尾再增加一次操作，成功率k[i]，考虑这个操作对最终结果的贡献。这个操作连成1的概率为k[i]\*(1-k[i-1])，贡献为k[i]\*(1-k[i-1])\*1^3。这个操作连成2的概率为k[i]\*k[i-1]\*(1-k[i-2])，由于连成2实际上只让结果增加了(2^3-1^3)，贡献为k[i]\*k[i-1]\*(1-k[i-2])\*(2^3-1^3)。以此类推，可以得出公式:  

$$
\begin{aligned}
&ans = \\ &k[1]*1^3 +  
      \\ &k[2]*(1-k[1])*1^3 + k[2]k[1]*(2^3-1^3) +
      \\ &k[3]*(1-k[2])*1^3 + k[3]k[2]*(1-k[1])*(2^3-1^3) + k[3]k[2]k[1]*(3^3-2^3) + ...
\end{aligned}
$$


计算展开并把所有的E[i]提出来可以得到 
$$ans = E[1] + 6*(E[2]+2E[3]+...+(n-1)E[n])$$ 

只需要求(E[2]+2E[3]+...+(n-1)E[n])即d[n]即可  
记l[i] = i\*k[i]\*...\*k[1] + (i-1)\*k[i]\*...\*k[2] +...+ 1\*k[i]  
  p[i] = k[i]\*...\*k[1] + k[i]\*...\*k[2] + k[i]
  
有
$$
\begin{aligned}
&p[i] = k[i] * p[i-1] + k[i]\\
&l[i] = k[i] * l[i-1] + p[i]\\
&d[i] = d[i-1] + l[i] - p[i]
\end{aligned}
$$

即可在O(n)时间内求出d[n]  
最后答案是E[1]+6\*d[n]

代码如下
```
#include <cstdio>
#include <iostream>
#define ll long long
#define maxn 100005
#define INF 1000000000
using namespace std;

int n;
double k[maxn];
double d[maxn];
double l[maxn];
double p[maxn];

int main()
{
    cin >> n;
    double sum = 0;
    for(int i = 1; i <= n; i++)
        scanf("%lf", &k[i]), sum += k[i];

    if(n == 1) printf("%.1lf", k[1]);
    else
    {
        d[2] = k[1] * k[2]; l[2] = 2*d[2] + k[2]; p[2] = d[2] + k[2];
        for(int i = 3; i <= n; i++)
        {
            p[i] = k[i] * p[i-1] + k[i];
            l[i] = k[i] * l[i-1] + p[i];
            d[i] = d[i-1] + l[i] - p[i];
        }
    }
    double ans = sum + 6*d[n];
    printf("%.1lf", ans);
    return 0;
}
```


---

## 作者：yeaDonaby (赞：2)

在这个串中连续的$X$个$1$可以贡献$X^3$的分数,考虑连续的$X$个$1$后增加一个$1$：

$(x+1)^3$=$x^3+3x^2+3x^1+1$

与原来相比增加了：

$3x^2+3x^1+1$

题目变成维护这个增加值的期望。

$x^2$与$x^1$不好一起处理，所以我们分开处理:

$x1[i]$表示$x^1$的期望;

$x2[i]$表示$x^2$的期望;

$x3[i]$表示答案的期望;

$x1[i]=(x1[i-1]+1)*p[i];$

$x2[i]=(x2[i-1]+x1[i-1]*2+1)*p[i];$

$x3[i]=(x3[i-1]+3*x2[i-1]+3*x1[i-1]+1)*p[i]+x3[i-1]*(1-p[i])$

所以，我们简化一下$x3$:

$x3[i]=x3[i-1]+(3*x2[i-1]+3*x1[i-1]+1)*p[i]$

答案是$x3[n]$。

此题还可以用滚动数组优化空间，~~但这题不用优化也能过~~。

```
#include<stdio.h>
#define R register
#define maxn 100001
int n;
double a[maxn],x1[maxn],x2[maxn],x3[maxn];
int main(void)
{
	scanf("%d",&n);
	for(R int i=1; i<=n; i++)
	{
		scanf("%lf",&a[i]);
		x1[i]=(x1[i-1]+1)*a[i];
		x2[i]=(x2[i-1]+x1[i-1]*2+1)*a[i];
		x3[i]=x3[i-1]+(x2[i-1]*3+x1[i-1]*3+1)*a[i];
	}
	printf("%.1lf",x3[n]);
	return 0;
}
```

---

## 作者：¶凉笙 (赞：2)

## [题解] P1654 OSU!

> [传送门](https://www.luogu.com.cn/problem/P1654)

### 解题报告

~~题意描述自己看吧。~~

考虑到两个公式：

$(a+b)^2=a^2+2ab+b^2$

$(a+b)^3=a^3+3a^2b+3ab^2+b^3$

不妨设 DP 数组 $f[i][0/1]$ 表示第 $1$ 到 $i$ 位 $1$ 的期望个数，其中 $0$ 维维护原始期望值，$1$ 维维护 **平方的期望值**（顺序不可颠倒）。

 小细节：$E(x^2)\not=E^2(x)$

注意到这个，就可以递推了，因为当前第 $i$ 位选 $0$ 对期望没有贡献，所以不用考虑。

因为每次代价都增加 $1$，也就是平方和立方的增量是 $1$，利用开始的两个公式和维护的值就可以递推。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <bits/stdc++.h>
#include <algorithm>
using namespace std;
template <typename T>
inline T read(){
	T x=0;char ch=getchar();bool fl=false;
	while(!isdigit(ch)){if(ch=='-')fl=true;ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);ch=getchar();
	}
	return fl?-x:x;
}
const int maxn = 1e5 + 17;
double f[maxn][2],p[maxn],ans[maxn];
int n;
int main(){
	scanf("%d",&n);
	f[0][0]=f[0][1]=0.0;
	for(int i=1;i<=n;i++)scanf("%lf",p+i);
	for(int i=1;i<=n;i++){
		f[i][0]=(f[i-1][0]+1)*p[i];//原始值
		f[i][1]=(f[i-1][1]+2*f[i-1][0]+1)*p[i];//平方的期望值
		ans[i]=ans[i-1]+(3*f[i-1][1]+3*f[i-1][0]+1)*p[i];//立方增量为1
	}
    //具体的说是因为，(x+1)^3=x^3+3*x^2+3*x+1
	printf("%.1lf\n",ans[n]);
	return 0;
}
```

---

## 作者：Smallbasic (赞：2)

显然把$x^3$改成$x^2$就是水dp

于是考虑拆分：

$$(x+1)^3-x^3=\sum_{i=1}^3 C_i^3x^i=3x^2+3x+1$$

于是分开维护$x^2$和$x$的期望为$x1$,$x2$

由于$E(x+y)=E(x)+E(y)$显然我们$x1/2_i$就是$x1/2_{i-1}+\text{多的期望}$

多的期望分别是：


$$(x+1)^2 - x^2=x^2+2x+1-x^2=2x+1=2x2_{i-1}+1$$

$$x+1-x =1$$

于是轻松得出递推式：

$$x1_i=p_i(x1_{i-1}+2x2_{i-1}+1)$$

$$x2_i=p_i(x2_{i-1}+1)$$

$$ans_i=ans_{i-1}+p_i(3x1_{i-1}+3x2_{i-1}+1)$$

然后递推就好了。。。~~所以又水过了一道紫题~~

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
double d, x = 0.0 , y = 0.0, f = 0.0;

int main() {
	scanf("%d", &n);
	while (n--) {
		scanf("%lf", &d);
		f += (3 * (x + y) + 1) * d; 
		y = (y + 2 * x + 1) * d;
		x = (x + 1) * d; 
	}
	printf("%.1lf", f);
	return 0;
}
```


---

## 作者：ELLIAS (赞：2)

## 本题可以使用滚动数组进一步优化空间.

>空间多精贵.~~强迫症？~~

### 订正一下本题题干:

>小H和小Z正在玩一个取石子游戏。 取石子游戏的规则是这样的，每个人每次可以从一堆石子中取出若干个石子，
每次取石子的个数有限制，谁不能取石子时就会输掉游戏。 小H先进行操作，他想问你他是否有必胜策略，如果有
，第一步如何取石子。

### 优化分析

看到楼下大佬的代码，用庞大的数组会造成大量的内存浪费。从算法中可以看到，一个状态只从它前一个状态转移而来，就可以使用滚动数组节约空间。

第一次使用数组取`0`位，每次转移将`pos ^ 1`.代码如下

```cpp
	for (rint i = 1; i <= n; i ++, pos ^= 1)
	{
		exp = !pos, k = getdou ();
		x[pos] = (x[exp] + 1) * k;
		y[pos] = (y[exp] + 2*x[exp] + 1) * k;
		v[pos] = v[exp] + (3*x[exp] + 3*y[exp]+1) * k;
	}

```

---

## 作者：littleseven (赞：1)

# 洛谷 P1654 OSU!

**题目链接：**[洛谷 P1654 OSU!](https://www.luogu.org/problem/P1654) 

**算法标签:**  `期望DP`、`动态规划（DP）`

## 题目

### 题目描述

osu 是一款群众喜闻乐见的休闲软件。

我们可以把osu的规则简化与改编成以下的样子:

一共有$n$次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，$n$次操作对应为1个长度为n的01串。在这个串中连续的 $X$ 个 $1$ 可以贡献 $X^3$ 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释）

现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数。

### 输入格式

第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。

### 输出格式

只有一个实数，表示答案。答案四舍五入后保留1位小数。

### 输入输出样例

**输入 #1**

```cpp
3 
0.5 
0.5 
0.5
```



### 说明/提示

【样例说明】

000分数为0，001分数为1，010分数为1，100分数为1，101分数为2，110分数为8，011分数为8，111分数为27，总和为48，期望为48/8=6.0

N<=100000

## 题解：

**期望（概率）DP**

说实话没有直接写出来，也没学过期望DP，（承认自己偷看了一下题解），但是这道题如果耐心推一推式子还是很简单就可以理解的，那么过程如下：

因为题目中讲到连续的1可以贡献$X^3$，那么我们来研究$X^3$这个式子，不难发现以下规律：

$(x + 1)^3 = (x + 1)^2 \times (x + 1) => x^3 + 3x^2 + 3x + 1$

所以： $(x + 1)^3 - x^3 = 3x^2 + 3x + 1$

这样我们发现了什么，我们可以完全的用关于$x$的多项式来表示$(x+1)$，同理$(x-1)$也可以表示$x$。那么对于下一步，我们考虑处理出$x$与$x^2$：

对于$x$的处理很简单，$x = (x-1) + 1    ~=>~ x_i = x_{i-1} + 1$

那么考虑$x^2$，我们可以推出$(x+1)^2=x^2+2x+1 ~=>~ x^2_i = x^2_{i-1} + 2 \times x_{i-1}+1  $

那么对于我们所求的$ans$：

​	$ans_i = ans_{i-1} + (3 \times x^2_{i-1}+3 \times x_{i-1}+1)$

因为这道题每一步都涉及到了概率（当前数位为1的概率），那么我们就在$x,x^2,ans$的表达式后边都乘上一个当前为概率$p[i]$，题目得解。

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

double p[N], x_1[N], x_2[N], ans[N], sum;

int n;

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%lf", &p[i]);
	}
	for (int i = 1; i <= n; i ++ )
	{
		x_1[i] = (x_1[i - 1] + 1) * p[i];
		x_2[i] = (x_2[i - 1] + 2 * x_1[i - 1] + 1) * p[i];
		ans[i] = ans[i - 1] + (3 * x_2[i - 1] + 3 * x_1[i - 1] + 1) * p[i];
	}
	printf("%.1lf\n", ans[n]);
	return 0;
}

```

---

## 作者：Leap_Frog (赞：1)

# P1654 OSU!（题解）

此题与[火枪打怪](https://www.luogu.org/problemnew/show/P1485)的二分的check类似。  
当多一个连续的x时，分数增加$(x+1)^3-x^3=3*(x^2+x)+1$  
所以我们维护$x^2$与$x$的值。

~~看到楼上开了四个数组，满脸懵逼——此题好像一个数组逗比用开吧。。。~~  

代码（压行码风勿喷）  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n;
double ans,in,x2,x1;	//ans就是答案，in是读入的数，x2是x的二次方，x1是x的一次方
int main()
{
    scanf("%d",&n),x1=x2=0;
    for(int i=1;i<=n;i++) scanf("%lf",&in),ans+=(3*(x1+x2)+1)*in,x2=(x2+2*x1+1)*in,x1=(x1+1)*in;
    //这里楼上已经解释很清楚了，我就不再讲述了。
    return printf("%.1lf\n",ans),0;
}
```

---

## 作者：lightup37 (赞：1)

### 题面

一序列$a$, 对于每一个$i$均有$a_i$有$p_i$的几率为1, 否则为$0$

求: $a$中极长全$1$子序列长度三次方**之和**的期望

### 前置知识

1. 基本期望(期望的概念总得会吧...
2. 脑子

### 解法

可以设$f(x)$表示 操作是否成功序列 (以下简称序列$a$)前$x$位**以$x$结尾**极长全$1$子序列长度的期望, $g(x)$表示$a$前$x$位**以$x$结尾**极长全$1$子序列长度平方的期望, $r(x)$表示$a$前$x$位**以$x$结尾**极长全$1$子序列长度三次方的期望(以下简称"期望")， $h(x)$表示$a$前$x$位极长全$1$子序列长度三次方**之和**的期望(即原题所求量)

为了叙述方便以下称原题给出的序列为$p$

由期望的定义$E(x) = \sum v_ip_i$, 有
$$
f(x) = (f(x-1)+1) \times p_i + 0 \times (1-p_i) = (f(x-1)+1) \times p_i
$$

同样有:
$$
g(x) = (\sqrt{g(x-1)}+1)^2 \times p_i + 0 \times (1-p_i) \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
$$
$$
 = (g(x-1)+2f(x)+1)\times p_i(\text{由定义易知}g(x)=f^2(x))
$$

以及

$$
r(x) = (r(x-1)+3g(x)+3f(x)+1)\times p_i
$$

然后有
$$
h(x) = h(x-1) \times (1-p_i) + (h(x-1)+r(x)-r(x-1)) \times p_i
$$

这里稍微解释一下, 因为$h(x)+r(x)$包括了以$x-1$结尾的期望两次($h(x)$包括了$[1, n-1]$的期望, $r(x)$包括了$[lst, n]$的期望(此处$lst$为以$x-1$(即$x$, 因为开头不变)结尾的极长全$1$子序列的开头的期望)), 所以要减去$[lst, n-1]$的期望, 即$r(x-1)$

展开原式得
$$
h(x) = h(x-1) + (3g(x-1)+3f(x-1)+1) \times p_i
$$

~~(发现$p$完全没有用呢)~~

接下来暴力扫一遍序列$p$求出$f, g, h$即可, 时间复杂度为$O(n)$

萌新求通过qwq

### Code

```cpp
/*code by tyqtyq*/
#include<bits/stdc++.h>
#define f(i,x,y) for(register int i=x, i##end=y; i<=i##end; ++i)
#define d(i,x,y) for(register int i=y, i##end=x; i>=i##end; --i)
#define FO(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
using namespace std;
int read(int& x){x=0; int f=1, ch=getchar(); while(!isdigit(ch)) f=ch=='-'?-1:f, ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); return x*=f;}
int read(){int x=0, f=1, ch=getchar(); while(!isdigit(ch)) f=ch=='-'?-1:f, ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); return x*f;}
int max(int x, int y){return x>y?x:y;} int min(int x, int y){return x<y?x:y;}
#define _ 100005
#define read(X) scanf("%lf", &X)
#define print(X) printf("%.1lf\n", X)
double px1[_], px2[_], ans[_], a[_];
int n;
int main(){
	scanf("%d",&n); for(int i=1;i<=n;++i) scanf("%lf", &a[i]);
	for(int i=1;i<=n;++i) {
		px1[i]=(px1[i-1]+1)*a[i];
		px2[i]=(px2[i-1]+2*px1[i-1]+1)*a[i];
		ans[i]=ans[i-1]+(3*px2[i-1]+3*px1[i-1]+1)*a[i];
	}
	print(ans[n]);
	return 0; //拜拜程序~ 
}
```

---

## 作者：BF_AlphaShoot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1654)

先设 $x$ 为当前连续成功数，当又连续的成功 $1$ 次时，有：
$$
(x+1)^3=x^3+3x^2+3x+1
$$
由于原先得分为 $x^3$ ，可知**每次 $+1$ 都会增加 $3x^2+3x+1$ 分**。

在代码实现过程中，用 $x$ 维护一维 $x$ ，$y$ 维护二维 $x^2$ ，就很容易实现了。

View code:

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ri register int
#define il inline

const int N=1e5+10;
int n;
double ans,x,y;
double v[N];
    
signed main(){
	scanf("%d",&n);
	for(ri i=1;i<=n;i++)
		scanf("%lf",&v[i]);
	for(ri i=1;i<=n;i++){
		ans=ans+(3*(x+y)+1)*v[i];//将 x 和 y 合并
		y=(y+2*x+1)*v[i];
		x=(x+1)*v[i];
	}
	printf("%.1lf",ans);
    return 0;
}
```

---

## 作者：alvis (赞：0)

## 题意
有一个长度为 $n$ 的 $01$ 序列，对于每一个位置都有 $p_i$ 的概率为 $1$。
定义序列的权值为所有极长的 $1$ 串长度 $X$ 的三次方和。求期望分数。

## 解决
一开始是没有思路的，但是看到 $X^3$，我们就要考虑它的特殊意义，所以考虑把它拆开或者组合意义。（但是我也不知道它的组合意义）

考虑期望的线性性，即

$E[A+B]=E[A]+E[B]$

所以

$E[(X+1)^3]=E[X^3+3\times X^2+3\times X+1]=E[X^3]+3\times E[X^2]+3\times E[X]+1$

所以我们只要分别维护和的期望 $E[X]$，以及和的平方的期望 $E[X^2]$，就可以更新和的三次方的期望 $E[X^3]$。

另外对于 $E[X^2]$，我们也可以采用拆项的方法，即

$E[(X+1)^2]=E[X^2]+2\times E[X]+1$

## 代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int N = 100001;
int n;
double p[N];
double x1[N], x2[N], x3[N];

int main(){
    cin >> n;
    for(int i = 1;i <= n;i ++) cin >> p[i];
    
    for(int i = 1;i <= n;i ++) {
        //更新E[x]
        x1[i] = (x1[i-1]+1)*p[i];
        //更新E[x^2]
        x2[i] = (x2[i-1]+2*x1[i-1]+1)*p[i];
        //更新E[x^3]
        x3[i] = x3[i-1]+(3*x2[i-1]+3*x1[i-1]+1)*p[i];
    }
    printf("%.1f", x3[n]);
    return 0;
}
```


---

## 作者：Unordered_OIer (赞：0)

# P1654 题解
[$\text{题目link}$](https://www.luogu.com.cn/problem/P1654)

由公式得（这里默认大家都学过因式分解）：  

$(x+y)^3=x^3+3x^2y+3xy^2+y^3$  
每增加$k$，都会增加$k(3x^2y+3xy^2+y^3)$  

那么我们定:  

$exdv_i$表示概率  
$r_i$代表第$i$次点击对得分期望的贡献   
$s_i=E[x_i]$(题目下$x_i$的贡献)  
$t_i=E[{x_i}^2]$(题目下${x_i}^2$的贡献)  

那么我们来推式子：  
$r_i=p_i(E[3{x_{i-1}}^2+3x_{i-1}+1])$  
$s_i=p_i(s_{i-1}+1)$  
$t_i=p_i(t_{i-1}+2g_i+1)$

答案就是$r_n$

然后根据这个式子去写代码就行了。  
估计不超过$20$行就能解决。  

代码太过简单，就不放了。

---

## 作者：pomelo_nene (赞：0)

同步更新于[动态规划100题第19题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)。

因为 $(x+1)^3=x^3+3x^2+3x+1$。

考虑到 $E(x)$ 中的 $x$ 增加 1，答案就多了 $E(3x^2+3x+1)$。又去考虑 $(x+1)^2$，同理可得。线性的比较简单，不再概述。

返回到题目，用 $osu1$ 维护 $x$ 的期望，$osu2$ 维护 $x^2$ 的期望，$dp$ 维护答案，也就是 $x^3$ 的期望，有：

$$osu1_i=(osu1_{i-1}+1) \times p_i$$

$$osu2_i=(osu2_{i-1}+2 \times osu1_{i-1} + 1) \times p_i$$

$$dp_i=dp_{i-1}+(3 \times osu2_{i-1} + 3 \times osu1_{i-1}+1) \times p_i$$

综上，答案为 $dp_n$。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
double osu1[100005],osu2[100005],dp[100005];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		double cure;
		scanf("%lf",&cure);
		osu1[i]=(osu1[i-1]+1)*cure;
		osu2[i]=(osu2[i-1]+2*osu1[i-1]+1)*cure;
		dp[i]=dp[i-1]+(3*osu2[i-1]+3*osu1[i-1]+1)*cure;
	}
	printf("%.1f",dp[n]);
	return 0;
}
```

---

## 作者：xryjr233 (赞：0)

我们记$pw3_i$表示前$i$个位置,结尾为$i$的最长全1子串的期望长度的立方。

如果我们钦定$p_{n+1}=0$,那么答案$=\sum_{i=1}^npw3_i\times(1-p_{i+1})$。乘上$(1-p_{i+1})$意思是这一位要在下一位为$0$的时候才有贡献。

设当前位置为$i$。

这一位有$p_i$的概率为1。那么考虑如何从$pw3_{i-1}$转移到$pw3_i$。

发现$(x+1)^3=x^3+3x^2+3x+1$。

我们记$pw2_i$表示前$i$个位置,结尾为$i$的最长全1子串的期望长度的平方,$pw1_i$表示前$i$个位置,结尾为$i$的最长全1子串的期望长度。

那么$pw3_i=(pw3_{i-1}+3pw2_{i-1}+3pw1_{i-1}+1)\times p_i$

然后我们还要转移$pw2$和$pw1$。

同理,$(x+1)^2=x^2+2x+1$。

所以$pw2_i=(pw2_{i-1}+2pw1_{i-1}+1)\times p_i$。

剩下一个就很简单了,$pw1_i=(pw1_{i-1}+1)\times p_i$。

做完了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double p[100010],pw1[100010],pw2[100010],pw3[100010],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%lf",&p[i]);
	for(int i=1;i<=n;++i)pw1[i]=(pw1[i-1]+1)*p[i],pw2[i]=(pw2[i-1]+2*pw1[i-1]+1)*p[i],pw3[i]=(pw3[i-1]+3*pw2[i-1]+3*pw1[i-1]+1)*p[i],ans+=pw3[i]*(1-p[i+1]);
	printf("%.1lf",ans);
    return 0;
}
```

---

## 作者：PrefixAMS (赞：0)

### 思路：通过二项式定理求出高次期望

显然，对于一次期望我们有 $x_{i}=(x_{i-1}+1)*P_{i}$。

然后进行二次推导。

$(x_{i}+1)^{2}= x_{i}^2+2x+1$

发现我们 $x_{i}^2$ 可以通过$x_{i}$得到，从而计算出每个点为成功时的期望。

```cpp 
for(int i = 1 ; i <= n ; i ++) { //a为x b为x^2
	a[i] = (a[i - 1] + 1) * p[i];
	b[i] = (b[i - 1] + 2 * a[i - 1] + 1) * p[i];
}
```

这个代码看起来很对 ~~(反正我一开始觉得很对)~~ 。

但是他却忽略了一点。

**我们是在求 $ 1\to n$ 的总期望，只求一个点必然会错。** 

思考一下，我们的 $1\to n$  其实是通过第 $n$ 个点成功或者不成功两种情况得来的。

所以我们只需要将不成功时的贡献加上即可。

```cpp
b[i] = (b[i - 1] + 2 * a[i - 1] + 1) * p[i] + b[i - 1] * (1 - p[i]);
```

化简得。

```cpp
b[i] = b[i - 1] + (2 * a[i - 1] + 1) * p[i];
```

### 思考：如果我们要求 $3$ 次以上的期望呢？

我们可以通过二项式定理一次一次的向上推。

例如这样（$3$ 次）：

```cpp 
for(int i = 1 ; i <= n ; i ++) {
	a[i] = (a[i - 1] + 1) * p[i];
	b[i] = (b[i - 1] + 2 * a[i - 1] + 1) * p[i];
	c[i] = c[i - 1] + (b[i - 1] * 3 + a[i - 1] * 3 + 1) * p[i];
}
```
这里需要注意一下的是 $b$ 数组也就是 $x^{2}$ 表示的是这个点成功的期望。

我们只需要对我们所需要的次数进行上一步成功和上一步不成功的期望累和。

化简后看起来就像是个 $\sum_{i=1}^{n} x_{i}^{3}$ 的形式啦。

这样问题就被我们完美解决啦！

---

## 作者：_Album_ (赞：0)

更好的阅读：[传送门](https://payphone-x.top/2019/11/12/luoguP1654/)

## 分析

简单的期望$\text{dp}$入门题目。

设$E(x_i)$表示前$i$个位置的期望得分，$E(l1_i)$表示打到第$i$个点的期望长度，$E(l2_i)$表示打到第$i$个点的期望长度的平方。

考虑单个位置对于答案的贡献。设之前的长度为$x$，若打中，则长度变为$x + 1$，对得分的贡献就是$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$

综上，可得状态转移方程

$$E(x_i) = E(x_{i - 1}) + p_i(3 \times E(l2_{i - 1}) + 3 \times E(l1_{i - 1}) + 1)$$

考虑如何维护$E(l1_i)$ 与 $E(l2_i)$ 。显然，

$$E(l1_i) = p_i(E(l1_{i - 1}) + 1)$$

对于$E(l2_i)$，则考虑当前位置是否打中，设之前长度为$x$，若打中，则有$(x + 1)^2 - x^2 = 2x + 1$。

将其带到 $E(l2_i)$ 中，则有 

$$E(l2_i) = p_i(E(l2_{i - 1}) + 2 \times E(l1_{i - 1}) + 1)$$

剩下的见代码即可。

-----------------------------------

## Code[Accepted]

```Cpp
#include <bits/stdc++.h>

#define N 100001

using namespace std;

int n;
long double f[N] , len1[N] , len2[N] , p1;

int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++){
        cin >> p1;
        f[i] = f[i - 1] + p1 * (3 * len2[i - 1] + 3 * len1[i - 1] + 1);
        len1[i] = p1 * (len1[i - 1] + 1);
        len2[i] = p1 * (len2[i - 1] + 2 * len1[i - 1] + 1);
    }
    cout << fixed << setprecision(1) << f[n] << "\n";
    return 0;
}
```

------------------------------------

# THE END




---


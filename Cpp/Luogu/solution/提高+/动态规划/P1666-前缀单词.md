# 前缀单词

## 题目描述

一组单词是安全的，当且仅当不存在一个单词是另一个单词的前缀，这样才能保证数据不容易被误解。现在你手上有一个单词集合 $S$，你需要计算有多少个子集是安全的。

注意空集永远是安全的。

## 说明/提示

### 数据范围及约定

- 对 $30\%$ 的数据，满足 $1 \le n \le 10$。
- 对于 $100\%$ 的数据，满足 $1 \le n \le 50$，字符串长度 $ \le 50$，没有两个字符串是完全相同的。

## 样例 #1

### 输入

```
3
hello
hell
hi```

### 输出

```
6```

# 题解

## 作者：I_AM_HelloWord (赞：17)

蒟蒻觉得楼下说的还不完全清楚（但终究是dalao，该Orz还得Orz），在其之上做些补充。

我们预处理一个f[i][j]表示第i个单词与第j个单词是否能共存，

然后考虑一个dp[i]表示在前i个单词中，必须包含第i个单词的子集个数，首先dp[i]=1（只包含自己一个元素的一个子集方案数）

那么如果前面存在一个j<i，并且f[i][j]=1（即i与j可以共存），那么j所有的子集方案数加上一个i元素就形成了对应新的方案，那么状态就由j转移到i了，最后，直接累计dp[1....n]即可，当然最后还要算上空集哟。

参考代码：

```cpp
#include<algorithm>
#include<iostream>
#include<string>
#define REP(i,a,b) for (register int i=(a);i<=(b);i++)
using namespace std;
const int N=61;
string a[N];
long long f[N][N],dp[N];
int n;
inline bool calc(int i,int j){
    if (a[i].size()>a[j].size())swap(i,j);
    return a[j].find(a[i])!=0;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    REP(i,1,n)cin>>a[i];
    sort(a+1,a+n+1);
    REP(i,1,n){
        dp[i]=1;
        REP(j,1,n)f[i][j]=calc(i,j);
    }
    REP(i,1,n)REP(j,i,n)dp[j]+=f[i][j]?dp[i]:0;
    long long ret=0;
    REP(i,1,n)ret+=dp[i];
    cout<<ret+1;
    return 0;
}
```

---

## 作者：Reanap (赞：12)

**引理：**

把这些字符串排序后，对于任意一组$j<i$且他们不互为前缀，则对于任意一组$k<j$且他们不互为前缀，则$k$与$i$不互为前缀。

**证明：**

若$k$与$i$互为前缀，则$k$的长度必然小于$i$，那么$i$与$k$之间必然仅有以$k$为前缀的字符串，则$k$必然为$j$的前缀，矛盾。

这个证明与后缀数组求高度数组的O（n）算法的证明有点像

于是dp式就显而易见了。

$dp_i$表示前i个数选i的方案总数，答案就是加起来后加一就行了。

代码如下:

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
string s[55];
int n , f[55][55];
long long dp[55];//2^50次方在longlong以内
int Compare(int x , int y) {
	if(s[x].length() > s[y].length()) swap(x , y);
	for (unsigned i = 0; i < s[x].length(); ++i) {
		if(s[x][i] != s[y][i]) return 1;
	}
	return 0;
}
int main() {
	scanf("%d" , &n);
	for (int i = 1; i <= n; ++i) cin >> s[i] , dp[i] = 1;//输入与初始化
	sort(s + 1 , s + 1 + n);
	long long ans = 1;
	for (int i = 2; i <= n; ++i) for (int j = i - 1; j >= 0; --j) if(Compare(i , j)) dp[i] += dp[j];//dp转移
	for (int i = 1; i <= n; ++i) ans += dp[i];//统计答案
	printf("%lld" , ans);
	return 0;
}

```

---

## 作者：shixinyi (赞：10)

看到楼上没有树dp的，蒟蒻给一个树dp的做法。

直接读入不用排序直接建字典树，复杂度O(n\*l)。

然后我们知道如果字典树上的两个串是祖先和子孙的关系就是不安全的，不能共存。

我们可以把字典树上多余的边略去，再弄一个超级根（假设为0号点），剩下一个只有n条边的树。

我们考虑树dp，一个节点有选和不选两种可能，如果他要选，那么他子树上除了他都不能选。

那么 $ dp[i]= \prod dp[z] \  (fa[z]==i) \   \   \   +1 $ 。

最后答案就是 dp[0] - 1。 因为0这个节点其实是没有选他这种可能的。

树dp复杂度O(n)。

code:

```cpp
//Serene
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll unsigned long long
const int maxn=50+5,maxs=maxn*maxn;
int n,son[maxs][30],p[maxs],t;
char s[maxn];
ll dp[maxn];

void add_s(int pos) {  //Trie
    int len=strlen(s+1),now=0,x;
    for(int i=1;i<=len;++i) {
        x=s[i]-'a';
        if(!son[now][x]) son[now][x]=++t;
        now=son[now][x];
    }
    p[now]=pos;
}

int fir[maxs],to[maxs],nxt[maxs],e=0;
void add(int x,int y) {
    to[++e]=y;nxt[e]=fir[x];fir[x]=e;
}

void dfs1(int pos,int now) { //get tree
    if(p[pos]) add(now,++t),now=t;
    for(int i=0;i<26;++i) if(son[pos][i]) dfs1(son[pos][i],now);
}

void dfs2(int pos) { //tree dp
    dp[pos]=1; int y,z;
    for(y=fir[pos];y;y=nxt[y]) {
        dfs2(z=to[y]);
        dp[pos]*=dp[z];
    }
    dp[pos]++;
}

int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%s",s+1),add_s(i);
    t=0;dfs1(0,0); dfs2(0);
    printf("%lld",dp[0]-1);
    return 0;
}
```

---

## 作者：honoka_desu (赞：5)

递推
字符串数组a[i]保存各个单词，按字典序排序。

数组f[i]表示以a[i]为字典序排序结尾的集合数。

数组v[i][j]表示a[i]，a[j]之间是安全的。

所以在j>i的情况下，如果a[i],a[j]是安全的，那么f[i]就是f[j]的一部分。

因此只要从左到右，对于每个j>i加上f[i]就可以

代码：



```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
string a[55];
long long pos[55],tot;
bool v[55][55];
long long f[55];
bool c(string a,string b)
{
    if(a.size()>b.size())
    {
        string buf = a;
        a=b;
        b=buf;
    }
    if(b.find(a)!=0)return 1;
    else return 0;
}
int main()
{
int n;
cin>>n;
for(int i = 1;i<=n ; i++)cin>>a[i];    
sort(a+1,a+n+1);
for(int i = 1; i <= n;i++)
{
    v[0][i]=1;
    v[i][0]=1;
    f[i]=1;
for(int j = 1; j <= n;j++)
{
    v[i][j]=c(a[i],a[j]);
}
}
f[0]=0;
for(int i = 1;i <= n;i++)
{
for(int j = i;j<= n; j++)
if(v[i][j])
{
    f[j]+=f[i];
}    
}
long long ans = 0;
for(int i = 1; i<= n ; i++)ans += f[i];
cout<<(ans+1);
}

```

---

## 作者：TangLongbin (赞：3)

# 树形背包问题 #
##### 前置知识 #####
- 字典树（Trie）
- 树形背包（DP）

我们先将题目所给字符串以字典树的形式建树；


```cpp
void insert(char *S){
	int len = strlen(S);
	int now = root;
	for(register int i = 0 ; i < len ; ++i){
		if(!ch[now][S[i]-'a'])ch[now][S[i]-'a'] = ++cnt;
		now = ch[now][S[i]-'a'];
	}
	flag[now] = true;
}
```


可以得到如下的一颗树（样例为例）：

![](https://cdn.luogu.com.cn/upload/pic/55709.png)

为了方便DP，我们可以进行一遍DFS将此图重建为一颗只含有关键节点的树（即Trie上的标记节点），并且保证不改变父子关系，可得到如下的一颗简单的树；

重建代码：

```cpp
void rebuild(int now ,int fa){
	if(flag[now]){
		Add(fa,now); fa = now;
	}
	for(register int i = 0 ; i < 26 ; ++i){
		if(!ch[now][i])continue;
		else rebuild(ch[now][i],fa);
	}
}
```

![](https://cdn.luogu.com.cn/upload/pic/55710.png)

接下来，我们可以清晰的认识到，如果两个节点在同一条树枝上，那么他们一定不能在一个集合，换句话说就是，如果选择了一个点，那么和他相连的所有子树节点都不能选了；

###### 于是我们就将这个题转换成了一个背包问题 ######

我们令F[i][1]，F[i][0]分别表示选择或者不选择第i号节点的方案数，当然这个方案数仅限于它和它的子树；

于是我们可以得到转移方程：

## f[i][1] = 1; ##
## f[i][0] =  $\prod_{j\in son[i]}(f[j][0]+f[j][1])$ ##

然后进行DP；


```cpp
void dp(int now){
	f[now][0] = f[now][1] = 1;
	for(register int i = fir[now] ; i ; i = nxt[i]){
		int y = to[i]; dp(y);
		f[now][0] *= f[y][0] + f[y][1];
	}
}
```

于是我们最后的答案就是**f[R][0]**

完整的代码：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define Max 10000
using namespace std;
int n,root;
long long f[Max][2];
bool flag[Max];
int ch[Max][30],cnt;
char s[100];
int fir[Max],nxt[Max<<1],to[Max],tot;

void Add(int u,int v){
	nxt[++tot] = fir[u]; fir[u] = tot; to[tot] = v;
}

void insert(char *S){
	int len = strlen(S);
	int now = root;
	for(register int i = 0 ; i < len ; ++i){
		if(!ch[now][S[i]-'a'])ch[now][S[i]-'a'] = ++cnt;
		now = ch[now][S[i]-'a'];
	}
	flag[now] = true;
}

void rebuild(int now ,int fa){
	if(flag[now]){
		Add(fa,now); fa = now;
	}
	for(register int i = 0 ; i < 26 ; ++i){
		if(!ch[now][i])continue;
		else rebuild(ch[now][i],fa);
	}
}

void dp(int now){
	f[now][0] = f[now][1] = 1;
	for(register int i = fir[now] ; i ; i = nxt[i]){
		int y = to[i]; dp(y);
		f[now][0] *= f[y][0] + f[y][1];
	}
}

int main(){
	scanf("%d",&n);
	for(register int i = 1 ; i <= n ; ++i){
		scanf("%s",s); insert(s);
	}
	for(register int i = 0 ; i < 26 ; ++i){
		if(!ch[root][i])continue;
		rebuild(ch[root][i],root);
	}
	dp(root);
	printf("%lld",f[root][0]);
	return 0;
}
```



---

## 作者：XL4453 (赞：2)

### 解题思路：

先把这玩意搬到字典树上去，然后考虑选择的限制。

容易发现，一旦选择了某一个字符串，所有一这个字符串为前缀的字符串和所有的这个字符串的前缀都不能选，也就是这个字符串的子树和到根节点的路径上的所有点都不能选。

那么就考虑一个在字典树上的树形 $\text{DP}$，设 $f_{i}$ 表示选择了 $i$ 子树中的某一个节点的方案数，对于一个非关键节点，直接往下继承，否则有 $f_{i}=\prod f_{son}+1$，表示从自己的子节点中任意选取或者是全都不选，只选择自己。实现的时候可以将多余的边省去，就直接让每一个节点都是关键节点，方便一点。

注意最后要减去只选择虚根节点的贡献 $1$。

复杂度 $O(n)$。

---
另一种做法复杂度劣一些，但是代码不用那么复杂。

设 $f_i$ 表示考虑前 $i$ 个字符串并且强制选第 $i$ 个的方案数，但是直接这样做的话会导致在选取了一个之后其它的内容之间是否有冲突无法被考虑。

于是就想到将所有的字符串按照字典序排序，这样就做到了无冲突的一定是一个前缀，也就是若 $j<k$ 无冲突，任意 $i<j$ 与 $k$ 无冲突。

这种方法要注意最后加上空集的贡献 $1$。

---
还有开 $\text{long long}$，最大可能方案为 $2^{50}$，即任意两者都没有冲突。

---
### 代码：

---

## 作者：破忆 (赞：2)

## 【题意】
给定n个字符串，要求选择若干个，使得其中没有互为前缀的字符串，求方案数
## 【分析】
构造字典树

互为前缀的字符串在字典树上肯定是祖先与后代的关系

显然，不互为祖先后代的节点是可以同时选取的

题目转化为：在树上选取若干点，使得选取的点中没有祖先后代的关系，求方案数

树形DP即可

$f_x$ 表示 $x$ 及其子树的方案数

若不选 $x$ ，由于各个子树内不会互相影响，将各个子树方案数相乘即可

若选$x$，则只能选择一个点

$f_x=\prod_{y∈sonx}f_y+1$

最后答案就是$f_{root}$

## 【解法】
字典树+树形DP
## 【代码】
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=55,maxt=maxn*maxn;
int n;
char s[maxn];
struct trie{
	int ch[26];
	int num;
}t[maxt];
LL f[maxt];
int tot;
void insert(){
	int len=strlen(s),now=0;
	for(int i=0;i<len;i++){
		s[i]-='a';
		if(!t[now].ch[s[i]]) t[now].ch[s[i]]=++tot;
		now=t[now].ch[s[i]];
	}
	t[now].num++;
}
void DFS(int x){
	f[x]=1;
	for(int i=0;i<26;i++){
		int y=t[x].ch[i];
		if(!y) continue;
		DFS(y);
		f[x]*=f[y];
	}
	f[x]+=t[x].num;
}
int main(){
	freopen("P1666.in","r",stdin);
	freopen("P1666.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		insert();
	}
	DFS(0);
	printf("%lld\n",f[0]);
	return 0;
}
```


---

## 作者：ZoeZhang (赞：1)

## 友情提醒：十年 OI 一场空，不开 long long 见祖宗。 
（~~我因为不开 long long 交了三遍才 AC~~）

题目传送门：[P1666 前缀单词](https://www.luogu.com.cn/problem/P1666)

这道题很明显是一道 dp 题。字符串数组 $word$ 储存各个单词。首先按字典序排序，中间第二个循环从 $i$ 开始向下枚举，然后判断 $word_i$  与 $word_j$ 是否有一个是另一个前缀的关系。如果一个字符串是另一个字符串的前缀就进行累加。最后要把答案加 $1$（空集）。$f_i$ 为含有字符串 $word_i$ 的集合的数量。 

下面是 AC 代码： 
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int n;
long long ans=0;
string word[55];
long long f[55];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>word[i];
		f[i]=1;
	}
	sort(word+1,word+n+1);//排序 
	for(int i=2;i<=n;i++)
		for(int j=i-1;j>=0;j--){
			int x=i,y=j;//x小y大 
			if(word[x].size()>word[y].size())swap(x,y);
			bool flag=true; //x是否为y的前缀 
			for(int k=0;k<word[x].size();k++)
				if(word[x][k]!=word[y][k]){
					flag=false;
					break;
				}
			if(flag==false)f[i]+=f[j];
		}
	for(int i=1;i<=n;i++)
		ans+=f[i];
	ans++;//记得空集永远是安全的 
	cout<<ans;
	return 0;
}
```

---

## 作者：lraM41 (赞：1)

### 放在最前面：不开 long long 见祖宗。

这题显然 dp 。

思路：先按字符串字典序排序，然后暴力枚举两个字符串，若它们其中一个不为另一个的前缀，就累计。

提示：集合可以含有 0-2 个字符串。

设 dp[i] 为集合中含有字符串 i 的数量。

```
#include<bits/stdc++.h>
using namespace std;
long long n,qwq,dp[55];
string a[55];
bool pd(string x,string y){//判断两个字符串是否为对方前缀。
	for(int i=0;i<min(x.size(),y.size());i++)
		if(x[i]!=y[i]) return 1;
	return 0;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],dp[i]=1;//输入+赋初值。
	sort(a+1,a+n+1);//排序。
	for(int i=2;i<=n;i++)//从 2 枚举。
		for(int j=i-1;j>=0;j--)
			if(pd(a[i],a[j])) dp[i]+=dp[j];//若符合条件，即累加。
	for(int i=1;i<=n;i++) qwq+=dp[i];//求和。
	cout<<qwq+1;//空串也可以。
	return 0;
}

---

## 作者：zplqwq (赞：1)

这道题我们考虑dp。

令 $dp_i$ 表示以 $s_i$ 结尾的满足条件的子集个数。

例如在样例中，$dp_1$ 就是 $1$ ，因为以 $\text{hello}$ 为结尾且满足条件的子集数只有它本身。

初始条件是 $dp_i=i$ ，因为无论如何，自己本身永远都是安全的。

接下来转移就是显然的：

$dp_j=dp_i$ 当且仅当 $s_i,s_j$ 可以共存。

如何判断能否共存的？

用这个引理：

> 把这些字符串排序后，对于任意一组 $j<i$ 且他们不互为前缀，则对于任意一组 $k<j$ 且他们不互为前缀，则 $k$ 与 $i$ 不互为前缀。


注意，这里排序是必须的，否则他会把一些不符合条件的子集算进去。

答案显然就是所有 $dp_i$ 的和**再加一**。因为空集也算。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
const int N=2010;
string s[N];
int dp[N];
int ans;
bool check[N][N];
bool pd(int i,int j)
{
	if(s[i].size() < s[j].size()) swap(i,j);
	return s[i].find(s[j])!=0;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i];
	sort(s+1,s+1+n);
	for(int i=1;i<=n;i++)
	{
		dp[i]=1;
		for(int j=1;j<=n;j++)
		{
			check[i][j]=pd(i,j);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			if(check[i][j]==1)dp[j]+=dp[i];
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans+=dp[i];
		//cout<<dp[i]<<endl;
	}
	cout<<ans+1<<endl;
	return 0;
}

```

---

## 作者：asuldb (赞：1)

好像硬生生将树形dp写成了树形搜索

这是一个$Trie$树上的dp，我们先将$Trie$树建出来，之后我们设$dp[i]$表示到了$Trie$树上的第$i$个位置只使用使用结束标记在$i$子树内的单词能形成的子集有多少个

我的做法比较sb，在中间dp的过程中不考虑空集，于是就有如下的转移

$$dp[i]=\prod_{\text{j是i的儿子}}dp[j]$$

这就是一个简单的乘法原理，当然这里只考虑了所有的$j$都不取空集的情况

我们还得考虑有一些$j$是取空集的情况

刚才是所有的$dp[j]$组合在一起，显然只需要一些$dp[j]$乘起来，而另外的一些$dp[j]$取空集也是可行的

所以我们其实是要搜一个组合数，我们要将任意个$dp[j]$乘在一起，之后加起来就是$dp[i]$

而如果$i$这个位置有一个结束标记的话，我们也可是让这个单词单独作为一个子集，由于这个单词一定会是刚才那些已经取好的单词的前缀，所以不能放到任意一个集合里去，于是$dp[i]++$，让这个单词单独成为一个集合

在最后就是$Trie$树根节点的位置，我们由于一直没有考虑空集，所以这个时候输出$dp[0]+1$就好了

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 51
int son[maxn*maxn][26],flag[maxn*maxn];
long long dp[maxn*maxn];
int n,cnt;
char S[maxn];
inline void ins()
{
    int now=0;
    int len=strlen(S+1);
    for(re int i=1;i<=len;i++)
    {
        if(!son[now][S[i]-'a']) son[now][S[i]-'a']=++cnt;
        now=son[now][S[i]-'a'];
    }
    flag[now]=1;
}
long long redfs(int r,int need,int pre)
{
	if(!need) return 1;
	long long ans=0;
	for(re int i=pre+1;i<26;i++)
	if(son[r][i])
		ans+=dp[son[r][i]]*redfs(r,need-1,i);
	return ans;
}
void dfs(int r)
{
    long long prod=1;
    int sn=0;
    for(re int i=0;i<26;i++)
    if(son[r][i])
    {
        dfs(son[r][i]);
        sn++;
        dp[r]+=dp[son[r][i]];
    }
    dp[r]+=flag[r];
	for(re int i=2;i<=sn;i++)
		dp[r]+=redfs(r,i,-1);
}
int main()
{
    scanf("%d",&n);
    for(re int i=1;i<=n;i++)
        scanf("%s",S+1),ins();
    dfs(0);
    std::cout<<dp[0]+1;
    return 0;
}
```

---

## 作者：ws_ccd (赞：1)

蒟蒻来贴一个DP吧。。

f[i][j]表示选出的长度为i且选到了第j个单词。

这样f[i][j]就可以从f[i-1][1——j]（j取不到）转移来了。

为了避免一些无法判断位置的情况，就先排一下序。

答案就很显然了。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
#include<set>
#define inf 0x7fffffff>>1
#define N 100005
#define MAXN 1000005
#define LL long long 
#define mod 1000000007
using namespace std;
inline int ra()
{
    int x=0,f=1; char ch=getchar();
    while (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}
string ch[55];
int n;
bool can[55][55];
LL f[55][55],ans;
bool check(int x, int y)
{
    if (ch[x].size()<ch[y].size()) swap(x,y);
    for (int i=0; i<ch[y].size(); i++)
    {
        if (ch[x][i]!=ch[y][i]) return 1;
    }
    return 0;
}
int main()
{
//    freopen("word.in","r",stdin);
//    freopen("word.out","w",stdout);
    n=ra();
    for (int i=1; i<=n; i++)
        cin>>ch[i];
    sort(ch+1,ch+n+1);
    for (int i=1; i<=n; i++) f[1][i]=1;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=n; j++)
            if (check(i,j)) can[i][j]=1;
    for (int i=2; i<=n; i++)
        for (int j=i; j<=n; j++)    
        {
            for (int k=1; k<j; k++)
                if (can[j][k])
                    f[i][j]+=f[i-1][k];
            ans+=f[i][j];
        }
    printf("%lld",ans+(LL)n+1LL);
//    fclose(stdin); fclose(stdout);
    return 0;
}
```

---


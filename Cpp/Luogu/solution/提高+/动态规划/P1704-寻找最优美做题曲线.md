# 寻找最优美做题曲线

## 题目背景

nodgd 是一个喜欢写程序的同学，前不久（好像还是有点久了）洛谷 OJ 横空出世，nodgd 同学当然第一时间来到洛谷 OJ 刷题。于是发生了一系列有趣的事情，他就打算用这些事情来出题恶心大家……

## 题目描述

洛谷 OJ 刷题有个有趣的评测功能，就是系统自动绘制出用户的“做题曲线”。所谓做题曲线就是一条曲线，或者说是折线，是这样定义的：假设某用户在第 $b_i$ 天 AC 了 $c_i$ 道题，并且 $b_i$ 严格递增，那么该用户的做题曲线就是平面上点 $(i,c_i)$ 依次连出的一条折线。比如你在第 $1$ 天做了 $3$ 道题，第 $3$ 天做了 $4$ 道题，第 $6$ 天做了 $1$ 道题，那么你在前 $6$ 天的做题曲线就是从点 $(1,3)$ 到点 $(2,4)$ 到点 $(3,1)$ 的连续折线。

nodgd 同学可以预测出自己未来 $N$ 天每条能够 $AC$ 题目的数量，同时有一个很无趣的爱好，就是单调递增，nodgd 强迫自己的做题曲线保持严格的单调递增。但是出于某些原因，nodgd 在某些日子（共有 $K$ 天）必须刷题，而且刷题数量一定是预计的数量（体现 nodgd 的神预测）。nodgd 同学想知道，在这样的情况下，自己最多有多少天可以刷题，不过 nodgd 同学还有大量的数学竞赛题、物理竞赛题、英语竞赛题、美术竞赛题、体育竞赛题……要做，就拜托你来帮他算算了。

## 说明/提示

### 数据范围及约定

对于全部数据，

- $1 \le N \le 500000$，$1 \le K \le N/2$；
- $1 \le p[i] \le N$，保证每个 $p[i]$ 不同，不保证 $p[i]$ 按大小顺序输入；
- $1 \le c[i] \le 10^9$。

## 样例 #1

### 输入

```
13 4
2 13 8 7
6 10 9 8 9 10 11 16 14 12 13 14 18 ```

### 输出

```
5```

# 题解

## 作者：lei_yu (赞：42)

# 分析题目

由于对于题目本身没用的信息太多，但是毕竟是洛谷原创我还是概括一下：

和题目无关的：

洛谷有一个强大功能即自动绘制出每天做题的数量的曲线提醒我是个废物。

以及nodgd奆佬有强迫症，每天都必须比前一天刷的题多（甚至一天十亿道题），不仅如此，他还可以预测自己未来的行为 ~~（因此他获得了几次彩票头奖）~~

上面全是瞎扯，下面才是正题

-----------
 _鄙人不才，如果有疏漏请指出。_ 

### 题目大意：
给定一个N个元素的序列，求**有某些限制**的最长上升子序列。

### 题目限制：
给定其中的一些位置，要求这些位置必须在最长上升子序列中。

### 例子：
下面这个序列

1 5 2 3 6 9

在**没有任何限制条件**的情况下，最长上升子序列为

1 2 3 6 9

如果我们固定要选第二个元素的话，**其有限制的**最长上升子序列为 

5 6 9

# 无限制求法

要想知道怎么求有限制的首先还是得知道怎么求没有限制的。

第一种方法是动态规划，由于没啥用直接省去。如果有需要可以百度。复杂度为平方级别。

第二种方法也就是用的最多的方法，**贪心+二分**。

###  算法流程：

从头开始遍历每一个原来的元素，然后在最长子序列数组中，将大于等于这个遍历到的元素的第一个元素的位置直接改为这个元素。（有一点绕）

例如目前有一个上升子序列 2 3 6 9，

然后我扫描到了一个7，

于是我找到上升子序列中的9将它改成7。

特别的，如果没有大于等于它的元素，便直接将它插入到上升子序列的末尾。

最后我们得到的上升子序列就是最长的了。

### 强行解释：

贪心原理：**对于一个上升子序列，在长度相同的情况下，其末尾的元素越小，越有利于接下来的增长。**

例如，序列2 3 5是比序列2 3 9更优的（想象这三个元素后面还有一个元素7）。

~~正确性显然~~

为了简化代码，我们不需要判断当前元素是否可以放到上升子序列的末尾，每一次直接替换掉大于等于它的第一个元素。等于可以排除两个相等的元素的影响，**避免序列中出现两个相同的元素使答案错误**。

~~正确性依然显然~~

找大于等于他的第一个元素直接用二分查找即可。

### 栗子

我们讨论以下这个序列：

1 5 3 7 4 6

显然他的最长上升子序列是1 3 4 6

首先找到第一个元素1，由于现在上升子序列中没有元素（相当于没有大于等于它的），直接插入。然后上升子序列变为1。

接着找到第二个元素5，也没有大于等于它的，直接插入。上升子序列变为 1 5。

接着找到第三个元素3，**根据贪心原理**，找到第一个大于等于它的元素5，将5改为3。上升子序列变为1 3。

然后找到第四个元素7，插入最后。上升子序列变为1 3 7。

然后找到第五个元素4，通过上述方法把7改成4。上升子序列变为1 3 4。

最后找到第六个元素6，插入最后。上升子序列变为1 3 4 6。

至此，算法完美结束。

有没有体会到一点？

# 有限制后的求法

由于有一些元素是必须选择的，我们的算法需要有所调整。

首先我们通过一张图直观的看看在两个必须选择的元素中间有哪些是显然不会被选择的。

![](https://cdn.luogu.com.cn/upload/image_hosting/nvn0e0bf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

图中橙色的1 2 4号都是不可能被选择的。

因为1号和二号比必选1更小，**要求序列严格上升，因此不可能出现在最终答案里面**。但是由于上面的算法会用它们去替换上升子序列中更大的元素甚至是必选的元素，因此**遍历它们会导致答案的错误**。

而4号比必选2更大，如果要选择必选2元素，**4号不可能出现在最终答案里面**。同样的，如果用上面的算法会把他们直接插入上升子序列的最后，**直接导致答案的错误**。

**他们对答案没有贡献，且会导致最终答案计算错误。**

而3号和5号的**大小介于两个必选之间，都是可能被选择的**。

根据上述分析，我们只需要删去两个必选之间比前一个必选更小的和比后一个必选更大的所有数（打一个标记就行），然后跑一遍之前说的没有限制的算法就可以得到最后的答案了。由于输入必选的元素编号不保证有序，我们需要排一次序。

无解的情况当且仅当必选的子序列不是单调上升的。（显然）

在打代码的时候需要注意细节，第一个必选之前和最后一个必选之后的区间也需要考虑。

# 代码

代码中使用了C++中的STL函数 lower_bound 

使用 lower_bound(a+1,a+n+1,x)-a 可以返回a数组中第一个大于等于x的数的下标。（首地址减去尾地址才能得到下标）

upper_bound和它使用方法相同，只不过返回第一个大于x的数的下标。

简直是懒人福利啊，在离散化中也可以使用它们简化代码。

当然，a数组必须是有序的。

码风奇怪，代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,k,a[1000001],p[1000001],cnt,t[1000001];
bool b[1000001];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	scanf("%d",&p[i]);//读入必选的元素，排序。 
	sort(p+1,p+k+1);
	
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);	
	for(int i=1;i<=k;i++)//无解的情况当且仅当必选的子序列不是单调上升的
	{
		if(a[p[i]]<=a[p[i-1]])
		{
			cout<<"impossible"<<endl;
			return 0;
		}
	}
	
	p[k+1]=n+1;
	a[n+1]=1e9+5;//第一个必选之前和最后一个必选之后的区间也需要考虑
	
	for(int i=1;i<=n;i++)//删去对答案没有贡献且会导致答案出现错误的元素 
	{
		if(p[cnt+1]==i)
		{
			cnt++;
			continue;
		}
		if(a[i]<=a[p[cnt]]||a[i]>=a[p[cnt+1]])b[i]=1;
	}
	
	cnt=0;//反复利用
	for(int i=1;i<=n;i++)
	{
		if(b[i])continue;//跳过标记的元素 
		if(a[i]>t[cnt])//正常的最长上升子序列算法 
		{
			t[++cnt]=a[i];
		}
		else
		{
			int x=lower_bound(t+1,t+cnt+1,a[i])-t;//正常的二分 
			t[x]=a[i];
		}
	}
	cout<<cnt<<endl;//正常的输出
	return 0;//非同寻常的退出程序 
}
```

如果你有幸看到了这篇题解的最后，就说明你觉得我的题解有帮助。这是我熬夜赶出来的题解（现在已经晚上11点了明天还要上课），所以为啥不点个赞呢？（真是无耻）

---

## 作者：一叶知秋。 (赞：9)

来个不算太一样的解法？

------------

题解中的都是跑了一遍整体的最长上升子序列（~~暴力不论~~），需要一些处理加判断

其实根本没有必要，仔细想想，我们完全可以求出几段区间的最长上升子序列的长度，相加再加上$k$即可

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

#define maxn 555555

inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r*f;
}

int n,k,len,ans,must[maxn],a[maxn],f[maxn];

inline int up(int ld,int rd,int L,int R){//区间最长上升子序列
	len=0;
	for(int i=L;i<=R;i++){
		if(a[i]<=ld||a[i]>=rd)continue;//记得判断是否大于右边，小于左边
		if(a[i]>f[len]){
			f[++len]=a[i];
			continue;
		}
		int l=0,r=len+1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(f[mid]<a[i])l=mid;
			else r=mid;
		}
		f[r]=a[i];
	}
	return len;
}

int main(){
	n=read(),ans=k=read();
	for(int i=1;i<=k;i++)must[i]=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(must+1,must+1+k);//因为题目并不保证有序，故需要排序
	a[0]=-1;//初始化
	must[k+1]=n+1;
	a[n+1]=2000000000;
	for(int i=0;i<=k;i++){
		if(a[must[i]]>=a[must[i+1]])return printf("impossible"),0;//如果这k个都不满足条件，输出impossible
		ans+=up(a[must[i]],a[must[i+1]],must[i]+1,must[i+1]-1);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：nodgd (赞：7)

题意就是寻找输入序列的最长上升子序列，且要包含输入的那K天的数。

#首先，要知道O(NlogN)的求朴素最长上升子序列算法

从第一个数开始，讨论到第k个数的时候dp[i]表示前k个数中长度为i的上升子序列最后一个数最小是多少，于是dp[i]具有单调递增的性质。对于a[k]，只需要二分查找找到恰比a[k]小的一个dp[i]再顺便把dp[i+1]改成a[k]就行了。最终答案就是所有被修改过的dp[i]中最大的一个i。

##然后，要让我们找到的最长上升子序列必须包含指定的K个数

一个序列中，如果某个数严格大于它之前的所有数，严格小于它之后的所有数，那么在寻找最长上升子序列是一定会包含这个数，否则将这个数加入序列中可以得到更长的上升子序列。于是我们只需要从原序列里面删除位置夹在两个必须选的数之间但数的大小不符合的再求最长上升就行了，这个操作时间复杂度只需O(N)。

总的来说，先对输入的K个数排序O(KlogK)，再扫一遍去掉不符合的数O(N)，最后求最长上升O(NlogN)，稳稳地AC。

```cpp

#include <cstdio>
#include <cstdlib>
using namespace std;
const int maxn=500005;
int a[maxn],f[maxn],b[maxn],p[maxn],N,K,tot;
void _qsort(int l,int r)
{
    int i,j,m,t;
    i=l;j=r;
    m=p[(i+j)>>1];
    while(i<=j)
    {
        while(p[i]<m)i++;
        while(p[j]>m)j--;
        if(i<=j)
        {
            t=p[i];p[i]=p[j];p[j]=t;
            i++;j--;
        }
    }
    if(i<r)_qst(i,r);
    if(l<j)_qst(l,j);
}
int _midfind(int l,int r,int k)
{
    int i,j,mid;
    i=l;j=r;
    while(i<=j)
    {
        mid=(i+j)>>1;
    if(f[mid]<k)i=mid+1;
    else j=mid-1;
    }
    return j;
}
void _work()
{
    int i,j,k,n;
    for(i=k=1;i<p[1];i++)
        if(a[i]<a[p[1]])
        {
            b[k]=a[i];
            k++;
        }
    b[k]=a[p[1]];k++;
    for(j=1;j<K;j++)
    {
        for(i=p[j];i<p[j+1];i++)
            if(a[p[j]]<a[i]&&a[i]<a[p[j+1]])
            {
                b[k]=a[i];
                k++;
            }
        b[k]=a[p[j+1]];k++;
    }
    for(i=p[K];i<=N;i++)
        if(a[i]>a[p[K]])
        {
            b[k]=a[i];
            k++;
        }
    n=k-1;
    f[0]=-999999999;
    f[1]=b[1];
    for(i=2;i<=n+5;i++)f[i]=999999999;
    tot=1;
    for(i=2;i<=n;i++)
    {
        j=_midfind(1,tot+1,b[i]);
        f[j+1]=b[i];
        if(j>=tot)tot=j+1;
    }
    printf("%d",tot);
}
void _input()
{
    int i,j,k;
    scanf("%d%d",&N,&K);
    for(i=1;i<=K;i++)
        scanf("%d",&p[i]);
    _qsort(1,K);
    for(i=1;i<=N;i++)
        scanf("%d",&a[i]);
    for(i=2;i<=K;i++)
        if(a[p[i-1]]>a[p[i]])
        {
            printf("impossible");
            return;
    }
    _work();
}
int main()
{
    _input();
    return 0;
}

```

---

## 作者：lx_zjk (赞：4)

# 暴力赛高！！！！ 60ms过了

首先讲一下这道题的题意

给你一个序列，规定必须选的数，要你求最长上升子序列

数据范围500000 ~~好像没有暴力都过了~~QAQ

思路就是 枚举要选数的区间 求当前区间的最长上升子序列，且规定子序列$\in $$[a[l],a[r]]$

分三种情况讨论 ，思路简单，~~码量比较大，也不算大，都是$Ctrl C  Ctrl V粗来的$~~

第一 三种情况 $\in [a[1],a[p[1])\in (a[p[m],a[n])$  这要特苏讨论 算最长上身子序列 其中$a[1]$ and $a[n]$可以取到，算他的最长上升子序列 

第二种情况 $ \in (a[i],a[i+1])$ 大体思路同上 不细讲了
QAQ

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
	ll f=1,x=0;
	char ch;
	do {
		ch=getchar();
		if(ch=='-')f=-1;
	} while(ch>'9'||ch<'0');
	do {
		x=x*10+ch-'0';
		ch=getchar();
	} while(ch>='0'&&ch<='9');
	return f*x;
}

const int MAX_N=500000 + 50;

int n,m,p[MAX_N],a[MAX_N]; 

int dp[MAX_N],b[MAX_N];

inline int dfs2(int l,int r){
	int ans=0,top=0;
	memset(b,0,sizeof(b));
	memset(dp,0,sizeof(dp));
	for(int i=l;i<=r;i++)if(a[i]<a[r])b[++top]=a[i];
//	for(int i=l;i<=r;i++) cout<<a[i]<<" ";
	for(int i=1;i<=top;i++) dp[i]=1;
	for(int i=1;i<=top;i++){
		for(int j=1;j<i;j++){
			if(b[i]>b[j]) dp[i]=max(dp[j]+1,dp[i]);
		}
		ans=max(ans,dp[i]); 
	}
	return ans;	
}	
	
inline int dfs3(int l,int r)
{
	int ans=0,top=0;
	memset(b,0,sizeof(b));
	memset(dp,0,sizeof(dp));
	for(int i=l;i<=r;i++)if(a[i]>a[l])b[++top]=a[i];
//	for(int i=l;i<=r;i++) cout<<a[i]<<" ";
	for(int i=1;i<=top;i++) dp[i]=1;
	for(int i=1;i<=top;i++){
		for(int j=1;j<i;j++){
			if(b[i]>b[j]) dp[i]=max(dp[j]+1,dp[i]);
		}
		ans=max(ans,dp[i]); 
	}
	return ans;	
}

inline int dfs(int l,int r){
	int ans=0,top=0;
	memset(b,0,sizeof(b));
	memset(dp,0,sizeof(dp));
	for(int i=l;i<=r;i++)if(a[i]>a[l]&&a[i]<a[r])b[++top]=a[i];
//	for(int i=l;i<=r;i++) cout<<a[i]<<" ";
	for(int i=1;i<=top;i++) dp[i]=1;
	for(int i=1;i<=top;i++){
		for(int j=1;j<i;j++){
			if(b[i]>b[j]) dp[i]=max(dp[j]+1,dp[i]);
		}
		ans=max(ans,dp[i]); 
	}
	return ans;	
}

int main(){
	int ans=0;
	n=read();m=read();
	for(int i=1;i<=m;i++) p[i]=read();
	for(int i=1;i<=n;i++) a[i]=read();
	sort(p+1,p+m+1);	
	for(int i=1;i<m;i++){
		if(a[p[i]]>=a[p[i+1]]) {
			//cout<<i<<endl;
			cout<<"impossible\n";
			return 0;
		}
	}
	ans+=dfs2(1,p[1]);
//	cout<<dfs2(1,p[1])<<endl;
	for(int i=1;i<m;i++){
//		cout<<i<<" "<<dfs(p[i],p[i+1])<<endl;
		ans+=dfs(p[i],p[i+1]);
	}
//	cout<<dfs3(p[m],n)<<endl;
	ans+=dfs3(p[m],n);
//	for(int i=1;i<=m;i++) cout<<a[p[i]]<<" ";
	cout<<ans+m<<endl;
	return 0;
}

```

---

## 作者：MorsLin (赞：4)

把必须要做题的$K$天看作一个个端点

因为这$K$天是我们必须要做题的，而我们又要保证做题数量单调递增，所以我们可以在每两个端点之间筛选出大于左端点小于右端点的数，然后整体跑一遍最长上升子序列，这样就可以保证满足题目条件

无解的情况就是存在一个右端点大于等于右端点

看了一眼题解区，全是手写二分，在这里提供一个STL的做法

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define LL long long
using namespace std;
LL read() {
    LL k = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') {
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
      k = k * 10 + c - 48, c = getchar();
    return k * f;
}
int p[500010], a[500010], ans[500010], b[500010], tot;
int main() {
    int n = read(), k = read();
    for(int i = 1; i <= k; ++i) p[i] = read();
    for(int i = 1; i <= n; ++i) a[i] = read();
    sort(p+1, p+k+1);
    for(int i = 1; i <= p[1]; ++i)
        if(a[i] < a[p[1]]) ans[++tot] = a[i];
    ans[++tot] = a[p[1]];
    for(int i = 2; i <= k; ++i) {
        if(a[p[i-1]] >= a[p[i]]) {
            printf("impossible\n"); return 0;
        }
        for(int j = p[i-1]+1; j <= p[i]; ++j) {
            if(a[j] < a[p[i]] && a[j] > a[p[i-1]]) ans[++tot] = a[j];
        }
        ans[++tot] = a[p[i]];
    }
    for(int i = p[k]; i <= n; ++i)
        if(a[i] > a[p[k]]) ans[++tot] = a[i];
    int cnt = 0;
    for(int i = 1; i <= tot; ++i) {
        if(ans[i] > b[cnt]) b[++cnt] = ans[i];
        else {
            int pos = lower_bound(b+1, b+cnt+1, ans[i]) - b;
            b[pos] = ans[i];
        }
    }
    cout << cnt << endl;
    return 0;
}
```

---

## 作者：Dilute (赞：3)

## 暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）**NB**的算法！

### [AC记录](https://www.luogu.org/record/show?rid=6705503)

这里似乎没有朴素的算法啊（啊当然Pascal不算哈）

我开始做题的时候还专门为了求稳去学习了一下$nlogn$的最长上升子序列呢

其实我们会发现，暴力的时间复杂度其实根本不是$O(n^2)$，就让我们来分析一下暴力的时间复杂度。

首先，读入，时间复杂度$O(n+k$)，即$O(n)$；

接下来，对必须做题的时间排序，复杂度$O(nlogn)$；

再下去，对每段进行最长上升子序列，在一般情况下$c_i$平均分布，复杂度为$O((n/k)^2 * k)$，即$O(n^2/k)$，但是，在某些奇葩的数据下，会出现这个复杂度退化为$O(n^2)$的情况，显然，这道题并没有这样的数据（啊当然NOIP的话你是可以看看CCF会不会出这种毒瘤数据，但是这种一般的题目出题人都是直接敲个随机生成就走人的）（不要问我为什么因为我自己出题就是这么干的）。

综上所述，暴力的时间复杂度为$O(n^2/k)$，似乎AC并没有多少问题。。。

上代码，具体的问题就看代码辣~~

```cpp
#include<bits/stdc++.h> // 万能头文件 

using namespace std;

bool cmp(int a, int b){ // sort需要的比较函数 
	return a < b;
}

int Num[1100000]; // 题面中的c 
int f[1100000];   // 最长上升子序列的数组 

int Get(int l, int r){ // Get(l,r)表示从Num[l+1~r-1]这段的最长上升子序列 
	int Lbound = Num[l]; // 表示左边的边界，如果数要被放进最长上升子序列中必须要大于这个边界 
	int Rbound = Num[r]; // 表示右边的边界，如果数要被放进最长上升子序列中必须要小于这个边界
	for(int i = l+1; i < r; i++){ // O(n^2)最长上升子序列应该不用我多说了吧 
		if(Num[i] > Lbound && Num[i] < Rbound){ // 判定这个数是否符合在两个边界之间的条件 
			f[i] = 1;
			for(int j = l+1; j < i; j++){ // 这里注意不要把l和r扫进去，会死得很惨 
				if(f[j] + 1 > f[i] && Num[j] < Num[i]) f[i] = f[j]+1;
			}
		}
	}
	int Ans = 0;
	for(int i = l+1; i < r; i++){ // 这个时候也是同理，别把l和r扫进去 
		if(f[i] > Ans)
			Ans = f[i];
	}
	return Ans;
}

int main(){
	memset(f, 0, sizeof(f)); 
	int n, k;
	//----------开始读入------------- 
	scanf("%d %d", &n, &k);
	int OI[500000];
	for(int i = 1; i <= k; i++){
		scanf("%d", &OI[i]);
	}
	sort(OI+1, OI+k+1, cmp);
	for(int i = 1; i <= n; i++){
		scanf("%d", &Num[i]);
	}
	//---------读入结束-------------- 
	Num[0] = -1; // 注意一下这句话，因为我们要保证在0~第一个必须做题的天之内左边界为无限小 
	int Ans = k + Get(0, OI[1]); // 特判一下从0~c[1]之间的这段 
	for(int i = 1; i < k; i++){ // 扫一遍所有区间 
		Ans += Get(OI[i], OI[i+1]); // 加上这个区间的最长上升子序列长度 
		if(Num[OI[i]] >= Num[OI[i+1]]){ // 特判：如果后面一个节点和前面一个节点并不严格单调，则无解 
			printf("impossible");
			return 0;
		}
	}
	Num[n+1] = 2147483647;  // 和上面的同理（n+1是为了把最后一天扫进去） 
	Ans += Get(OI[k], n+1);
	if(OI[1] == 0) Ans--; // 对于第七组数据的特判，看讨论里面所以加的，但是似乎是数据出错了。。。 
	printf("%d", Ans); // 直接输出答案 
	return 0;
}
```

---

## 作者：顾z (赞：2)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p1704 寻找最优美做题曲线](https://www.luogu.org/problemnew/show/P1704)

### 分析

首先需要明确的是,我们需要维护最长上升子序列.~~就像我的刷题记录~~ qwq

题目要求必须选一些位置,这些位置是必须选的.

所以我们需要考虑的是这些位置,两两之间的位置的合法性.

例如这样：

　　``蓝色部分必选.``

中间部分均不合法.我们标记一下即可。

![](https://i.loli.net/2018/10/11/5bbf2e9dc590c.png)

由于$p_i$不连续,所以我们需要$Sort$.

但是我们还**需要判断左右两端是否合法**.(这个坑死了.

求解单调递增序列的话就不多BB了.我这里用的是二分,并不是lower_bound

#### 小声bb

> 我们已经筛去了不合法的位置,所以合法位置一定是严格递增的。
>
> 又因为我们必选位置一定会是其中的一员,因此这些必选位置一定会被选.

``代码``

```c++
#include<cstdio>
#include<algorithm>
#include<cctype>
#define R register
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,stk[5000008],top,a[5000008];
int flg[5000008];
bool vis[5000008];
int main()
{
	in(n),in(m);stk[0]=-1;
	for(R int i=1,x;i<=m;i++)in(flg[i]);
	for(R int i=1;i<=n;i++)in(a[i]),vis[i]=true;
	sort(flg+1,flg+m+1);
	for(R int i=1;i<m;i++)
	{
		if(a[flg[i]]>=a[flg[i+1]])
		{
			puts("impossible");
			return 0;
		}
		for(R int j=flg[i]+1;j<flg[i+1];j++)
			if(a[j]<=a[flg[i]] or a[j]>=a[flg[i+1]])
				vis[j]=false;
	}
	for(R int i=1;i<flg[1];i++)
		if(a[i]>=a[flg[1]])vis[i]=false;
	for(R int i=flg[m]+1;i<=n;i++)
		if(a[i]<=a[flg[m]])vis[i]=false;
	for(R int i=1;i<=n;i++)
	{
		if(!vis[i])continue;
		if(a[i]>stk[top])
			stk[++top]=a[i];
		else
		{
			int l=1,r=top;
			while(l<=r)
			{
				int mid=(l+r)>>1;
				if(stk[mid]>a[i])r=mid-1;
				else l=mid+1;
			}
			stk[l]=a[i];
		}
	}
	printf("%d",top);
}
```



---

## 作者：MSqwq (赞：0)

## 考查内容：二分+DP  
题外话： $nodgd$ 太强了，$Orz$  
题意：在序列中，有一些数必须选，然后求要你求 $LIS$  
题解：  
若果一数在序列内严格比他前面的书大，比后面的数小，那么这个数一定存在于最长上升子序列中   
显然在规定必须选取的连续两天内，比前一天小的和比后一天大的一定不合法，去掉之后便可使规定选取数变为上述数    
删掉不合法数然后求一遍最长上升子序列就好，注意，第七组数据规定了必须要取第 $0$ 天，这是一个坑点，当然是 $O(nlogn)$ 的啦 QwQ  

代码如下：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll a[500010],b[500010],tmp[500010],v[500010];
ll len=1,n,m;
ll t=0;

ll q(ll x)
{
	ll l=1,r=len,mid;
	while(l<=r)
	{
		mid=(l+r)/2;
		if(tmp[mid]<a[x])l=mid+1;
		else r=mid-1;
	}
	return l;
}

int main () 
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++) 
	{
		scanf("%lld",&b[i]);
		if(b[i]==0)t=1;
	}
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	
	sort(b+1,b+m+1);
	for(int i=2;i<=m;++i) 
	{
		if(a[b[i]]<a[b[i-1]]) 
		{
			printf("impossible");
			return 0;
		}
	}
	
	for(int i=2;i<=m;i++)
	{
		for(int j=b[i-1]+1;j<b[i];j++)
		{
			if(a[j]<=a[b[i-1]]||a[j]>=a[b[i]])v[j]=1;
		}
	}

	for(int i=1;i<=b[1]-1;i++)
		if(a[i]>a[b[1]])v[i]=1;
	
	for(int i=b[m]+1;i<=n;i++)
		if(a[i]<=a[b[m]])v[i]=1;
	
	tmp[1]=a[1];
	
	for(int i=2;i<=n;i++)
	{
		if(v[i])continue;
		if(a[i]>tmp[len])tmp[++len]=a[i];
		else tmp[q(i)]=a[i];
	}

	printf("%lld",len+t);
}
```


---

## 作者：Azuree (赞：0)

[查看题目戳这里](https://www.luogu.org/problemnew/show/P1704)
# 一道最长上升子序列的裸题
由题目描述可以看出，我们选择的日期中每天做题数量一定是递增的。这样，我们就能很轻易地想到用最长上升子序列去完成这道题。在这里，由于数据范围较大，我们需要用[nlogn的算法](http://47.92.113.238/qxiangya/?p=176)去完成这道题。  
## 那么，怎么去处理这必须做题的k天呢？  
由于这k天做题数量一定是最长上升子序列的一部分，这样我们就可以发现有某些天是一定不能选的。当我们把这些一定不能选的日期删掉后就会发现，只要我们按照正常的算法去求最长上升子序列，那么这k天一定是包含在里面的。~~（想一想，为什么）~~  
至于判断是否有最长上升子序列，只需要判读这必选的k天是否单调上升即可。  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>

using namespace std;

int n,k,cnt,t,a[500005],c[250005],sta[500005];

int mysort(int a,int b) {return a < b;}

int judge()
{
	sort(c + 1, c + k + 1, mysort);
	for(int i = 2; i <= k; i++)
		if(a[c[i]] <= a[c[i - 1]])
		{
			printf("impossible");
			return 1;
		}
	return 0;
}

void clean()
{
	for(int i = 1; i < c[1]; i++)
		if(a[i] >= a[c[1]])
			a[i] = -1;
	for(int i = 1; i < k; i++)
		for(int j = c[i] + 1; j <= c[i + 1] - 1; j++)
			if(a[j] <= a[c[i]] || a[j] >= a[c[i + 1]])
				a[j] = -1;
	for(int i = c[k] + 1; i <= n; i++)
		if(a[i] <= a[c[k]])
			a[i] = -1;
	for(int i = 1; i <= n; i++)
		if(a[i] != -1)
			a[++cnt] = a[i];
}

void two_fen(int k)
{
	int l = 1,r = t,mid;
	while(l <= r)
	{
		mid = (l + r) >> 1;
		if(sta[mid] < k) l = mid + 1;
		else r = mid - 1;
	}
	sta[l] = k;
}

void work()
{
	sta[0] = -1008611;
	for(int i = 1; i <= cnt; i++)
	{
		if(a[i] > sta[t]) sta[++t] = a[i];
		else two_fen(a[i]);
	}
	printf("%d\n",t);
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1; i <= k; i++) scanf("%d",&c[i]);
	for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
	if(judge()) return 0;
	clean();
	work();
	return 0;
}
```


---


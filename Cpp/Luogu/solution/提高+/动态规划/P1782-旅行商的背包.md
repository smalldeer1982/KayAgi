# 旅行商的背包

## 题目描述

小 S 坚信任何问题都可以在多项式时间内解决，于是他准备亲自去当一回旅行商。在出发之前，他购进了一些物品。这些物品共有 $n$ 种，第 $i$ 种体积为 $V_i$，价值为 $W_i$，共有 $D_i$ 件。他的背包体积是 $C$。怎样装才能获得尽量多的收益呢？作为一名大神犇，他轻而易举的解决了这个问题。  

然而，就在他出发前，他又收到了一批奇货。这些货共有 $m$ 件，第 $i$ 件的价值 $Y_i$ 与分配的体积 $X_i$ 之间的关系为：$Y_i=a_iX_i^2+b_iX_i+c_i$。这是件好事，但小 S 却不知道怎么处理了，于是他找到了一位超级神犇（也就是你），请你帮他解决这个问题。

## 说明/提示

### 样例解释

前两种物品全部选走，最后一个奇货分给 $4$ 的体积，收益为$2 \times 3+4 \times 1+(-1) \times 16+8 \times 4+(-16)=10$。

### 限制与约定

对于 $100\%$ 的数据，$1 \le n \le 10^4$，$1 \le m \le 5$，$1 \le C \le 10^4$，$
1 \le W_i,V_i,D_i \le 1000$，$-1000 \le a_i,b_i,c_i \le 1000$。

## 样例 #1

### 输入

```
2 1 10
1 2 3
3 4 1
-1 8 -16```

### 输出

```
10```

# 题解

## 作者：I_AM_HelloWord (赞：50)

#### 此题是非常是坑啊。楼下说的好，AC的dalao发个题解方便大家（当然，给个AC的代码就更赞了）

#### 理论上，单调队列远快于二进制做法，但是。。

#### 先分析一下题目，前n个物品搞一个多重背包，后m个物品搞一个完全背包！仔细想想应该都能想到。

#### 但是。此题，时限卡的非常紧。

#### 我总结了几个不TLE的必备条件：

#### 不要随手加memset；不要懒得写读优；可以养成没事就加inline和register的习惯；单调队列千万别用STL的deque，求最大值的时候也不要用STL的max，手写一个if；数组大小不要开的太大（这也费时间），差不多就好。

#### 至于为什么单调队列跑不过二进制，这我也不太清楚，因为单调队列的效率分析本来就是在均摊意义下的Q\_Q，这题可以使多重背包和完全背包的一个练手的极佳模板题。至于并不怎么懂多重背包的优化的童鞋，可以参观一下我的blog，里面稍稍详细的总结了一下：http://blog.csdn.net/no1\_terminator/article/details/51896966

#### 参考代码【我良心吧？】

```cpp
#include<cstdio>
#include<algorithm>
#define re register
using namespace std;
const int N=1e4+1;
int n,m,c;
int q[N],f[N],dp[N];
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main()
{
    n=read(),m=read(),c=read();
    for(re int i=0;i<n;i++)
      for(re int v=read(),w=read(),d=read(),j=0;j<v;j++)
        for(re int h=0,t=0,k=0;k*v+j<=c;k++)
        {
            re int x=dp[k*v+j]-k*w;
            while(h!=t && x>f[t-1])t--;
            q[t]=k;f[t++]=x;
            if(q[h]+d<k)h++;
            dp[k*v+j]=f[h]+k*w;
        }
    for(re int i=0;i<m;i++)
      for(re int v=read(),w=read(),d=read(),j=c;j>=0;j--)
        for(re int k=0;k<=j;k++)
          if (dp[j-k]+(v*k+w)*k+d>dp[j])dp[j]=dp[j-k]+(v*k+w)*k+d;
    printf("%d",dp[c]);
    return 0;
}
```
最后，Orz一下最小面的dalao，他的单调队列写的确实漂亮，你们看了我的博客就知道差距了，学到了。


---

## 作者：emiyashilo (赞：26)

#本题十分良心，想学好背包都应该做。它包含了较普通背包的大部分知识及多种优化方法

**本人是炒鸡蘑菇（蒟蒻），提交了（20）遍才A了这道题哎，说起来都是泪啊。。。。那废话不多说，进入本题的AC方法As is known to all这道题时间卡的特别紧，朴素代码拿出来样例肯定过，但是提交时却会全都TLE（别问我为什么知道）。先谈一下基本思路吧。这道题一般分为两步，即先处理普通货物，再处理奇货因为奇货最多只有5个，所以可以直接朴素代码带走，主要问题是前面的那些普通货物，我的想法是通过二进制优化多重背包，转成01背包做。**

**方法是：将第i种物品分成若干件（用二进制）物品，其中每件物品都有一个系数2^k，k属于{1,2,4,8，16.......}，因为二进制可以表示所有数，所以我们用一个循环来模拟二进制，因为2^k<=vi\*di，所以不用担心k炸掉**

```cpp
for(int k=1;k<=d;k*=2){
v[++count]*=k;
w[count]*=k;
//进行操作
d[count]-=k}
if(d[count]>0)v[++count]*=d[count];w[count]*=d[count]；
```
**通过以上的一个循环就可以实现二进制,但是由于本题数据奇大，无存储，所以必须每次输入时进行操作，这样，就不用担心存储的问题循环输入时的for，就相当于朴素代码中dp时的第一个for但是即便如此，也还是不能A这道题，还是会tle几个点这时，我们首先想到的当然是输入优化，这是必须有的，否则会tle三个点。那我们还能怎样优化呢？那就是看这种物品是否可以全装到背包中，也就是在输入时先if（v\*d>n）如果是，那这个物件就可以当做完全背包中的一种物品，因为这个物品不可能全取，那就可以视为这种物品无限多，这样就可节省时间。如果v\*d<=n，再按多重背包用二进制做，即用else。这样，这道题就基本能A了**
最后，附上代码（可能有点乱）

```cpp
#include<bits/stdc++.h>//万能文件头
using namespace std;
int  n,m,c;//基本数据
long long f[10005];
int  v,w,d;//货物的v，w，d
int read(){//读入优化，也必须有
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1; c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0'; c=getchar();}
    return x*f;
}
int main()
{
    n=read();m=read();c=read();
    for(int i=1;i<=n;i++){
        v=read();w=read();d=read();
        if(d*v>c){//判断是不是完全背包
            for(int j=v;j<=c;j++){
                f[j]=max(f[j],f[j-v]+w);
                }
            }
        else {
        for(int k=1;k<=d;k*=2){//二进制优化
            if(c<v*k){//这句没啥用，但我懒得删了，大家无视就行了
                break;}
            for(int j=c;j>=v*k;j--){
                f[j]=max(f[j],f[j-v*k]+w*k);//非常基础的dp背包
            }
            d-=k;
        }
        if(d>0){
        for(int j=c;j>=v*d;j--){
            f[j]=max(f[j],f[j-v*d]+w*d);
        }}
    }}
    int j;
    for(int i=1;i<=m;i++){v=read();w=read();d=read();
        for(int j=c;j>=0;j--){//最后的奇货只用朴素代码就够了
            for(int k=0;k<=j;k++){
                f[j]=max(f[j],f[j-k]+(v*k+w)*k+d);
            }
        }
    }
    printf("%lld",f[c]);
}//本题解结束，祝大家compling快乐
```

---

## 作者：C_SUNSHINE (赞：20)

这题就是简单的多重背包，外加枚举奇货的体积。

恩，这样差不多能得60分。所以，还需加上单调队列优化，方可得满分。

真这么简单？就这么简单。



```cpp

#include<iostream> //By JOHNKRAM
using namespace std;
int n,m,c,v,w,d;
int a[10001],b[10001],f[10001];
int s,t,x,y;
int main()
{
    int i,j,k;
    scanf("%d%d%d",&n,&m,&c);
    for(i=0;i<n;i++)
      for(scanf("%d%d%d",&v,&w,&d),j=0;j<v;j++)
        for(s=t=k=0;k*v+j<=c;k++)
        {
          x=k;
          y=f[k*v+j]-k*w;
          while(s!=t&&y>b[t-1])t--;
          a[t]=x;
          b[t++]=y;
          if(a[s]+d<k)s++;
          f[k*v+j]=b[s]+k*w;
        }
    for(i=0;i<m;i++)
      for(scanf("%d%d%d",&v,&w,&d),j=c;j>=0;j--)
        for(k=0;k<=j;k++)
          f[j]>?=f[j-k]+(v*k+w)*k+d;
    printf("%d",f[c]);
    return 0;
}


```

---

## 作者：ViXpop (赞：11)

#### 纪念一下学会多重背包，发一个题解

这题就是一个裸的多重背包，无非多了一个关于奇货的操作，也还是很简单的

关于多重背包，有两种优化，一种是二进制优化，另一种是单调队列

但是单调队列并不在NOIP考察范围之内，这里就不做介绍，有兴趣的可以做一下[这个板子](https://www.luogu.org/problemnew/show/P1886)

### 下面说一下二进制优化多重背包

#### 首先讲一下多重背包最容易想到的暴力法

由于多重背包问题是介于01背包和完全背包之间的一种问题，我们很容易想到枚举选取的物品个数

假如对于一种数量为n[i]的物品，令f[i][v]表示前i种物品恰放
入一个容量为v的背包的最大权值，则有状态转移方程：
```
 f[i][v] = max(f[i-1][v-k*c[i]]+ k * w[i])
```


但是很显然，复杂度是O(V * Σn[i])，对于大数据来说是绝对炸飞的

#### 那么我们尝试将其转化为01背包进行求解

把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V * Σn[i])

小数据可以这样搞一下，大数据仍然炸飞

#### 接下来我们考虑二进制优化思想

将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数

使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品

分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难

这样一来，复杂度就改进了许多，变成了O(V * Σlog n[i])

### 当然多重背包还有一种更为快速的优化，就是我前面提到的单调队列优化

这个算法的思路是基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解，总的复杂度是O(V * n)，有能力的神仙可以尝试一下，本蒟蒻在这里就不作详细说明

### 下面是二进制优化的代码

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
inline int read(){
    int res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int max(int a,int b){
    return a>b?a:b;
}
const int N=1e5+5;
int n,m,T,dp[N],a,b,c,v,w,d;
void zeroone(int cost,int weight,int V){
    for(register int i=V;i>=cost;i--)
        dp[i]=max(dp[i],dp[i-cost]+weight);
}
void complete(int cost,int weight,int V){
    for(register int i=cost;i<=V;i++)
        dp[i]=max(dp[i],dp[i-cost]+weight);
}
void mutil(int cost,int weight,int num,int V){//二进制优化的多重背包
    if(cost*num>=V){//如果无法将所有物品装下，直接跑一个完全背包
        complete(cost,weight,V);
        return;
    }
    for(register int i=1;i<=num;i*=2){//二进制优化
        zeroone(i*cost,i*weight,V);
        num-=i;
    }
    if(num)zeroone(num*cost,num*weight,V);//如果有多余的，单独跑一个01背包
}
int main()
{
    n=read(),m=read(),T=read();
    for(register int i=1;i<=n;i++)
        v=read(),w=read(),d=read(),mutil(v,w,d,T);
    for(register int i=1;i<=m;i++){
        a=read(),b=read(),c=read();
        for(register int j=T;j>=0;j--)
            for(register int u=0;u<=j;u++)dp[j]=max(dp[j],dp[j-u]+a*u*u+b*u+c);
    }
    write(dp[T]);
    return 0;
}
```


---

## 作者：Adove (赞：10)

关于最后的m个物品的优化

我们学过二次函数

特判一次函数的情况

求二次函数顶点

显然单增的部分需要枚举，单降的部分取个左端点

开口向下的顶点如果不为正，就跳过

这样代码效率会高很多

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e4+5;

int n,m,C;
int f[MAXN],v[25],w[25];

inline int read()
{
	int x=0;bool fl=0;char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-') fl=1;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	return fl?-x:x;
}

int main()
{
	n=read(),m=read(),C=read();
	while(n--){
		int cnt=0,wgt=read(),val=read(),num=read();
		for(int i=1;i<=num;i<<=1){
			v[++cnt]=val*i;
			w[cnt]=wgt*i;
			num-=i;
		}if(num) v[++cnt]=num*val,w[cnt]=num*wgt;
		for(int i=1;i<=cnt;++i){
			for(int j=C;j>=w[i];--j){
				f[j]=max(f[j],f[j-w[i]]+v[i]);
			}
		}
	}while(m--){
		int a=read(),b=read(),c=read();
		if(!a){
			if(b<=0){
				if(c<=0) continue;
				for(int i=1;i<=C;++i) f[i]+=c;
				continue;
			}int x=max((double)-c/b,0.0);
			for(int j=C;j>=x;--j){
				for(int k=x;k<=j;++k){
					int val=b*k+c;
					f[j]=max(f[j],f[j-k]+val);
				}
			}continue;
		}int x=max((double)-b/(a<<1)+0.5,0.0);
		if(a>0){
			int cx=C+1;
			for(int i=x;i<=C;++i) if(a*i*i+b*i+c>c){cx=i;break;}
			for(int j=C;j>=cx;--j){
				if(c>0) f[j]+=c;
				for(int k=cx;k<=j;++k){
					f[j]=max(f[j],f[j-k]+a*k*k+b*k+c);
				}
			}continue;
		}int cx=x;
		for(int i=0;i<=x;++i) if(a*i*i+b*i+c>0){cx=i;break;}
		if(cx==x&&a*cx*cx+b*cx+c<0) continue;
		for(int j=C;j>=cx;--j){
			for(int k=cx;k<=min(x,j);++k){
				f[j]=max(f[j],f[j-k]+a*k*k+b*k+c);
			}
		}
	}printf("%d\n",f[C]);
	return 0;
}
```

---

## 作者：Creeper_LKF (赞：4)

单调队列+玄学快读（否则T2-4个点）
1572ms

关于玄学快读的事参考[玄学快读](https://www.luogu.org/blog/CreeperLKF/FastRead)

然后我们知道标准的多重背包的dp转移方程为

```
dp[i][j] = max{dp[i - 1][j - k * v[i]] + k * w[i]}
```

然而你可以发现需要求最大值的对象有不少是重复的

于是我们设

```
v = v[i]，a = j / v，b = j % v
```

然后有

```
dp[i][j] = max{dp[i - 1][b + k * v] - k * w[i]} + a * w[i]
```

于是我们的max从

```
dp[i - 1][j0] (j0 in b, b + v, b + 2v, ..., j)
```

出来，然后这一部分我们用单调队列维护一下即可

AC代码如下
注意卡常：快读+手写队列


```
#include <cstdio>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
using namespace std;
#define MAXN 10005

#define Finline __inline__ __attribute__ ((always_inline))

char *pc = (char *) mmap(NULL, lseek(0, 0, SEEK_END), PROT_READ, MAP_PRIVATE, 0, 0);

inline int read(){
    int num = 0;
    char c, sf = 1;
    while ((c = *pc++) < 45);
    if(c == '-') c = *pc++, sf = -1;
    while (num = num * 10 + c - 48, (c = *pc++) >= 48);
    return num * sf;
}
Finline void upmax(int &a, const int &b){
    if(a < b) a = b;
}

int dp[MAXN], num[MAXN];

struct Q{
    int s, t;
    int q[MAXN];
    Q(){
        s = 1 , t = 0;
    }
    Finline void clear(){
        s = 1, t = 0;
    }
    Finline bool empty(){
        return s > t;
    }
    Finline int front(){
        return q[s];
    }
    Finline int back(){
        return q[t];
    }
    Finline void pop_front(){
        s++;
    }
    Finline void pop_back(){
        t--;
    }
    Finline void push(int tar){
        q[++t] = tar;
    }
}q;

int main(){
    int n = read(), m = read(), c = read(), v, w, d, i, j, k, tmp1, tmp2, tmp3;
    for(i = 1; i <= n; ++i){
        v = read(), w = read(), d = read();
        for(j = 0; j < v; ++j){
            for(k = 0, q.clear(); (tmp1 = k * v + j) <= c; ++k){
                tmp3 = k * w;
                tmp2 = dp[tmp1] - tmp3;
                while(!q.empty() && tmp2 > num[q.t]) q.pop_back();
                q.push(k), num[q.t] = tmp2;
                if(q.front() + d < k) q.pop_front();
                dp[tmp1] = num[q.s] + tmp3;
            }
        } 
    }
    for(i = 1; i <= m; ++i){
        v = read(), w = read(), d = read();
        for(j = c; j; --j){
            for(k = 0; k <= j; k++){
                upmax(dp[j], dp[j - k] + (v * k + w) * k + d);
            }
        }
    }
    printf("%d", dp[c]);
    return 0;
}
```

---

## 作者：Hunter_Will (赞：4)

终于AC了，这道题还真是迷啊，建议AC的大神记得写题解，不然苣蒻就只能刷屏了。

来说一下这道题：

第一，不要用memset，不要用memset，不要用memset。如果你迷之全部tle，请检查一下是否使用了memset。

第二，不要用单调队列，如果你相信楼下的话。。。。相信你已经看到后果了，如果你不是来抄代码的话。

第三，最好在线处理，这样不用开队列，自然也不用memset，还能提高速度，何乐而不为？

为什么不要用单调队列，因为本人亲自实验会tle，看看提交记录就知道了。。。。虽说单调队列优化多重背包的复杂度是O(vn)

的，可是它就是A不了这道题，正确AC姿势是用二进制拆分+完全背包。个人觉得是单调队列的常数有点大，而本题的数据不是很强

（估计di很小）再加上评测机的速度可能变慢了，所以导致单调队列跑不过二进制拆分。

题解：多重背包相信大家都了解了，优化主要是单调队列和二进制拆分。先说二进制拆分，顾名思义，将物品数量按二进制拆开，

比如13就可以拆成1，2，4，6。注意最后的6是8拆不够了，这样对体积分别为1×v，2×v，4×v，6×v，价值分别为,1×w，2×w，4×w，6×w的物品跑01背包，就可以得到答案，这样拆分的依据是把x按二进制拆分后拆出来的数可以拼成1～x的任何一个数，证明请自行查找资料。二进制拆分的复杂度为O(vn×sum(log(num[i])))    num[i]为第i件物品的数量。

单调队列，是将dp转移方程变形后根据其下标单调性得出的，具体请自行百度。

PS：当物品数量太多以至于背包装不下时，可以当完全背包处理，复杂度O(vn)


---

## 作者：pipiispig (赞：3)

###
这个是个背包好题呀（优化！优化！优化）玄学优化写了个排名第3的最优解；

我们可以先想一下朴素的做法多重背包+完全背包，但是遗憾，会超时4-5个点，这时候我们可以进行对多重背包的二进制优化或者是单调队列优化，在此，我讨论一下二进制的优化方式,（单调队列比二进制优化要快，但是超出了noip的范围所以就不研究了（主要是我不会QwQ））,但是很遗憾，即使你进行了二进制优化还是会超时3个点，很显然完全背包的时间复杂度远小于多重背包，于是我们可以加个判断，如果多重背包的个数乘以它的体积大于背包的体积我们便可以将其转化为完全背包，这样就可以过这个题了；当然会读入优化更好了，max的判断当然也可以手写另外切记不要用stl！切记不要用stl!切记不要用stl!
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<deque>
using namespace std;
inline int read(){
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}//快读，最好掌握，有些卡常数题要用到，这个题就有点卡了；
int s[1000000][2];
int dp[100000];
int main(){
	std::ios::sync_with_stdio(false);
	int n=read(),m=read(),w=read();
	for(register int i=1;i<=n;i++){
		int cnt=0;
		int s1=1,a=read(),b=read(),c=read();
		if(c*a>w){
			for(register int j=a;j<=c;j++){
				if(dp[j-a]+b>dp[j])dp[j]=dp[j-a]+b;
			}
		}//这个地方就是我所谓的特判；对于时间的优化很大，主要原因就在于完全背包和多重背包比起来优越的时间复杂度；
		else{
			while(c>=s1){
				s[++cnt][0]=a*s1;
				s[cnt][1]=b*s1;
				c-=s1;
				s1<<=1;
			}
			if(c>0){
				s[++cnt][0]=a*c;
				s[cnt][1]=b*c;
			}//二进制优化，应为所有的元素都可以拆成2,4....2^n,s-2^n;将多重背包转化为01背包也是一种优化方式；
			for(register int j=1;j<=cnt;j++){
				for(register int k=w;k>=s[j][0];k--){
					if(s[j][1]+dp[k-s[j][0]]>dp[k]){
						dp[k]=dp[k-s[j][0]]+s[j][1];
					}
				}
			}
		}
		
	}
	for(register int i=1;i<=m;i++){
		int v=read(),o=read(),d=read();
		for(register int j=w;j>=0;j--){
			for(register int k=0;k<=j;k++){
			   if(dp[j-k]+(v*k+o)*k+d>dp[j])dp[j]=dp[j-k]+(v*k+o)*k+d;
			}//这个地方我个人认为没什么可以优化得了，有好的方法可以告诉我一下OTZ;
		}
	}
	cout<<dp[w];
}
```
所以很显然，这道题考察的重点就是背包的应用以及一些优化方式了，这些优化方式真的很重要，一个不加优化的朴素做法至少需要6000ms+，但是经过上述的优化方式后，时间可以控制在400ms以内，优化的成效足以显现；

---

## 作者：lemir3 (赞：3)

[*在我的博客阅读*](https://www.lemir3.red/2020/04/02/Project1782-%E6%97%85%E8%A1%8C%E5%95%86%E7%9A%84%E8%83%8C%E5%8C%85%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/)

[*题面*](https://www.luogu.com.cn/problem/P1782)

## 题目分析

先不考虑奇货,是一个分组背包,数据范围很大不能直接套01背包再枚举选多件,考虑优化.

可以用单调队列来分组转移,也可以用二进制拆分来把优化这个暴力选多件的过程,因为常数原因,这道题里用二进制拆分更加优秀.

拆分的思想就是用多个二的次幂来组合成小于原数的任意正整数,代码如下,很好理解:

```cpp
		int t=1;
		while(d)
		{
			if(d-t<=0)t=d,d=0;
			else d-=t;
			t<<=1;
		}
```

举个例子,13会被分解为{1,2,4,6},用{1,2,4,6}里面的数单个相加可以组成[0,13]的任意整数,就把枚举13个数来转移优化到了4个数.

现在加上奇货,直接枚举占多少体积,算出价值之后转移即可,注意一组参数只能用一次,所以背包的容量在外层循环,枚举奇货的体积在内层循环,这一点得好好理解下.

枚举奇货理论上是可以用二次函数的顶点来优化的,因为确认容量递增价值递减之后再枚举也没有意义了,但我没写.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cmath"
#include "cctype"
#include "algorithm"
#include "iomanip"
#include "set"
#include "time.h"
#include "queue"
#include "map"
#include "stack"
#include "vector"
#include "deque"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
#define max(a,b) a>=b?a:b
const lxl maxn=100010;
lxl n,m,c,cnt;
lxl d[maxn],f[maxn],v_[maxn],w_[maxn];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
int main(void)
{
	n=read(),m=read(),c=read();
	for(R int i(1);i<=n;++i)
	{
		lxl v=read(),w=read(),d=read();
		lxl t=1;
		while(d)
		{
			if(d-t<=0)t=d,d=0;
			else d-=t;
			w_[++cnt]=t*w,v_[cnt]=t*v;
			t<<=1;
		}
	}
	for(R int i(1);i<=cnt;++i)
		for(R int k(c);k>=v_[i];--k)
				f[k]=max(f[k],f[k-v_[i]]+w_[i]);
	for(R int i(1),a,b,c_;i<=m;++i)
	{
		a=read(),b=read(),c_=read();
		for(R int k(c);k>=0;--k)
		{
			for(R int j(0);j<=c;++j)
			{
				lxl v__=j,w__=a*j*j+b*j+c_;
				if(k>=v__)f[k]=max(f[k],f[k-v__]+w__);
			}
		}
	}
	printf("%lld\n",f[c]);
	return 0;
}
```

---


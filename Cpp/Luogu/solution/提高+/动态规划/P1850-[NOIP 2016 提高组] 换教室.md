# [NOIP 2016 提高组] 换教室

## 题目背景

NOIP2016 提高组 D1T3

## 题目描述

对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。


在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第 $i$（$1 \leq i \leq n$）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_i$ 上课，而另一节课程在教室 $d_i$ 进行。


在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $n$ 节安排好的课程。如果学生想更换第 $i$ 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$ 个时间段去教室 $d_i$ 上课，否则仍然在教室 $c_i$ 上课。


由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_i$，并且对于不同课程的申请，被通过的概率是互相独立的。


学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 $m$ 门课程，也可以不用完这 $m$ 个申请的机会，甚至可以一门课程都不申请。


因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。


牛牛所在的大学有 $v$ 个教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。 当第 $i$（$1 \leq i \leq n-1$）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。


现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。


## 说明/提示

**样例 1 说明**

所有可行的申请方案和期望收益如下：

- 不作申请，耗费的体力值的期望为 $8.0$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     无      |  $1.0$  |  $8$  |

- 申请更换第 $1$ 个时间段的上课教室，耗费的体力值的期望为 $4.8$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $1$      |  $0.8$  |  $4$  |
|     无      |  $0.2$  |  $8$  |

- 申请更换第 $2$ 个时间段的上课教室，耗费的体力值的期望为 $6.4$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $2$      |  $0.2$  |  $0$  |
|     无      |  $0.8$  |  $8$  |

- 申请更换第 $3$ 个时间段的上课教室，耗费的体力值的期望为 $6.0$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $3$      |  $0.5$  |  $4$  |
|     无      |  $0.5$  |  $8$  |

- 申请更换第 $1,2$ 个时间段的上课教室，耗费的体力值的期望为 $4.48$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $1,2$      |  $0.16$  |  $4$  |
|     $1$      |  $0.64$  |  $4$  |
|     $2$     |  $0.04$  |  $0$  |
|     无      |  $0.16$  |  $8$  |

- 申请更换第 $1,3$ 个时间段的上课教室，耗费的体力值的期望为 $2.8$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $1,3$      |  $0.4$  |  $0$  |
|     $1$      |  $0.4$  |  $4$  |
|     $3$     |  $0.1$  |  $4$  |
|     无      |  $0.1$  |  $8$  |

- 申请更换第 $2,3$ 个时间段的上课教室，耗费的体力值的期望为 $5.2$。

| 申请通过的时间段 | 出现的概率 | 耗费的体力值 |
| :--------: | :----: | :----: |
|     $2,3$      |  $0.1$  |  $4$  |
|     $2$      |  $0.1$  |  $0$  |
|     $3$     |  $0.4$  |  $4$  |
|     无      |  $0.4$  |  $8$  |

因此，最优方案为：申请更换第 $1,3$ 个时间段的上课教室。耗费的体力值的期望为 $2.8$。 

**提示**

1. 道路中可能会有多条双向道路连接相同的两间教室。 也有可能有道路两端连接的是同一间教室。
2. 请注意区分 $n,m,v,e$ 的意义, $n$ 不是教室的数量, $m$ 不是道路的数量。

**数据范围与说明**

| 测试点编号 | $n\le$ | $m\le$ | $v\le$ | 是否具有特殊性质 1 | 是否具有特殊性质 2 |
| :--------: | :----: | :----: | :----: | :----------------: | :----------------: |
|     1      |  $1$   |  $1$   | $300$  |      $\times$      |      $\times$      |
|     2      |  $2$   |  $0$   |  $20$  |      $\times$      |      $\times$      |
|     3      |  $2$   |  $1$   | $100$  |      $\times$      |      $\times$      |
|     4      |  $2$   |  $2$   | $300$  |      $\times$      |      $\times$      |
|     5      |  $3$   |  $0$   |  $20$  |      $\surd$       |      $\surd$       |
|     6      |  $3$   |  $1$   | $100$  |      $\surd$       |      $\times$      |
|     7      |  $3$   |  $2$   | $300$  |      $\times$      |      $\times$      |
|     8      |  $10$  |  $0$   | $300$  |      $\surd$       |      $\surd$       |
|     9      |  $10$  |  $1$   |  $20$  |      $\surd$       |      $\times$      |
|     10     |  $10$  |  $2$   | $100$  |      $\times$      |      $\times$      |
|     11     |  $10$  |  $10$  | $300$  |      $\times$      |      $\surd$       |
|     12     |  $20$  |  $0$   |  $20$  |      $\surd$       |      $\times$      |
|     13     |  $20$  |  $1$   | $100$  |      $\times$      |      $\times$      |
|     14     |  $20$  |  $2$   | $300$  |      $\surd$       |      $\times$      |
|     15     |  $20$  |  $20$  | $300$  |      $\times$      |      $\surd$       |
|     16     | $300$  |  $0$   |  $20$  |      $\times$      |      $\times$      |
|     17     | $300$  |  $1$   | $100$  |      $\times$      |      $\times$      |
|     18     | $300$  |  $2$   | $300$  |      $\surd$       |      $\surd$       |
|     19     | $300$  | $300$  | $300$  |      $\times$      |      $\surd$       |
|     20     | $2000$ |  $0$   |  $20$  |      $\times$      |      $\times$      |
|     21     | $2000$ |  $1$   |  $20$  |      $\times$      |      $\times$      |
|     22     | $2000$ |  $2$   | $100$  |      $\times$      |      $\times$      |
|     23     | $2000$ | $2000$ | $100$  |      $\times$      |      $\times$      |
|     24     | $2000$ | $2000$ | $300$  |      $\times$      |      $\times$      |
|     25     | $2000$ | $2000$ | $300$  |      $\times$      |      $\times$      |
 

特殊性质 1：图上任意不同的两点 $u,v$ 间，存在一条耗费体力最少的路径只包含一条道路。

特殊性质 2：对于所有的 $1≤ i≤ n,\ k_i= 1$。


## 样例 #1

### 输入

```
3 2 3 3
2 1 2
1 2 1
0.8 0.2 0.5 
1 2 5
1 3 3
2 3 1
```

### 输出

```
2.80```

# 题解

## 作者：ViXbob (赞：291)

# [NOIPTG2016换教室](https://www.luogu.org/problemnew/show/P1850)

## 0x00 [个人博客推广⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄](http://www.vixbob-lwc.pw/)

## 0x01 暴力

直接顺序枚举换几节课，并枚举所有的情况并算出答案，复杂度大概是$O(\sum_i^n(C_n^i) * f(n))$

$C_n^i$ 表示组合数，$f(n)$表示每次算答案的时间，期望得分$60$ ~ $80$ (常数优秀的话)

## 0x02 设计状态

这道题一开始如果往$DP$这个方向思考的话很容易设计出状态，$dp[i][j]$  表示走完前$i$个教室, 换了$j$次的最优方案。然后我再往下思考怎么转移的时候，就想不出来了，因为这样设计状态是没法转移到，因为处理当前走到的教室和上一次走到的教室是有关系的，你不知道上一次的教室就无法转移，因为我们设计的状态没有办法表示上一次的教室选择，所以很自然状态变为$dp[i][j][k]$， 前两维表示的意思没有改变第三维$k$表示处理到第$i$个教室，我有没有选择换教室

## 0x03转移

先考虑不换的情况，即$k = 0$时的情况

$C1 = c[i - 1], C2 = d[i - 1], C3 = c[i], C4 = d[i]$

$mp[i][j]$表示$i,j$间的最短路
	
$dp[i][j][0] =min\begin{cases} dp[i - 1][j][0] + mp[C1][C3]\\dp[i - 1][j][1] + mp[C1][C3] * (1 - k[i - 1]) + mp[C2][C3] * k[i - 1]\end{cases}$


显然如果$i-1$时没有换教室那么，$i - 1$到$i$只有一种情况就是都不换教室，如果$i - 1$时换了教室那么就有两种情况$i - 1$换成功了，或者没换成功所以就是对应的路径长乘上对应的概率

$dp[i][j][1] =min\begin{cases} dp[i - 1][j - 1][0] + mp[C1][C3] * (1 - k[i]) + mp[C1][C4] * k[i]\\dp[i - 1][j - 1][1] + mp[C2][C4] * k[i] * k[i - 1] + mp[C2][C3] * k[i - 1] * (1 - k[i]) + mp[C1][C4] * (1 - k[i - 1]) * k[i] + mp[C1][C3] * (1 - k[i - 1]) * (1 - k[i])\end{cases} $

有上面的经验对于为$k = 1$的情况也很好理解了,显然对于$i - 1$可以是$k = 0 || k = 1$,
对于$k = 0$那么就有两种情况，$k = 1$就有四种情况，就不一一列举了

## 0x04 预处理

对于这道题我们只用预处理出两点之间的最短路就好了又因为只有$300$个点，所以$Floyd$是一个很好的选择

```
for (register int k = 1; k <= v; k++)
    for (register int i = 1; i <= v; i++)
        for (register int j = 1; j <= v; j++)
            mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
```

$PS$ : $mp$初始化的时候不要开太大了，在$Floyd$中会爆$int$

## 0x05 代码

```
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e3 + 5;
const double inf = 1e17 + 5;
int n, m, v, e, c[MAXN][2], mp[305][305];
double k[MAXN], dp[MAXN][MAXN][2], ans;
inline int read() {
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) {if (ch == '-')f = -1; ch = getchar();}
    while (isdigit(ch)) {u = u * 10 + ch - 48; ch = getchar();}return u * f;
}
int main(){
    memset(mp, 63, sizeof(mp));
    n = read(); m = read(); v = read(); e = read();
    for (register int i = 1; i <= n; i++)c[i][0] = read();
    for (register int i = 1; i <= n; i++)c[i][1] = read();
    for (register int i = 1; i <= n; i++)scanf("%lf", &k[i]);
    for (register int i = 1; i <= e; i++){
        int x = read(), y = read(), w = read();
        mp[x][y] = mp[y][x] = min(mp[x][y], w);
    }
    for (register int k = 1; k <= v; k++)
        for (register int i = 1; i <= v; i++)
            for (register int j = 1; j <= v; j++)
                mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
    for (register int i = 1; i <= v; i++)mp[i][i] = mp[i][0] = mp[0][i] = 0;
    for (register int i = 0; i <= n; i++)
        for (register int j = 0; j <= m; j++)dp[i][j][0] = dp[i][j][1] = inf;
    dp[1][0][0] = dp[1][1][1] = 0;
    for (register int i = 2; i <= n; i++){
        dp[i][0][0] = dp[i - 1][0][0] + mp[c[i - 1][0]][c[i][0]];
        for (register int j = 1; j <= min(i, m); j++){
            int C1 = c[i - 1][0], C2 = c[i - 1][1], C3 = c[i][0], C4 = c[i][1];
            dp[i][j][0] = min(dp[i][j][0], min(dp[i - 1][j][0] + mp[C1][C3], dp[i - 1][j][1] + mp[C1][C3] * (1 - k[i - 1]) + mp[C2][C3] * k[i - 1]));
            dp[i][j][1] = min(dp[i][j][1], min(dp[i - 1][j - 1][0] + mp[C1][C3] * (1 - k[i]) + mp[C1][C4] * k[i], dp[i - 1][j - 1][1] + mp[C2][C4] * k[i] * k[i - 1] + mp[C2][C3] * k[i - 1] * (1 - k[i]) + mp[C1][C4] * (1 - k[i - 1]) * k[i] + mp[C1][C3] * (1 - k[i - 1]) * (1 - k[i])));
        }
    }
    ans = inf;
    for (register int i = 0; i <= m; i++)ans = min(ans, min(dp[n][i][0], dp[n][i][1]));
    printf("%.2lf", ans);
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：174)

$9.10upd$:我才发现我写错汉语描述了……真是越来越优秀了啊……

$\rm{First}$ $\rm{of}$ $\rm{all}$ , 我自认为这篇题解写的比大佬们要详细……比较适合提高组的新手$OIer$阅读$qwq$

嗯，这是我的第一篇期望的题解……这是本蒟蒻第一次一眼看出$DP$方程和预处理$qwq$，纪念一下！

但实际上，是$rqy$帮我解决的这道题的关键部分……此致敬礼$qwq$

那么对于这篇题解，我的定义是，没有什么优化，只是最简单的求解这个问题而已。至于优化什么的，本蒟蒻不会呀$qwq$.

那么对于这道题而言，先捋清楚题目是求什么的吧：

对于这个无向连通图，我们将每走一步定义为一个阶段。那么每一个阶段都有两种可能性：$p_i$的概率去$d_i$，但是在所有的$d[i]$ 中$(1<=i<=n)$至多可以走$m$个，$(1-p_i)$的概率去$c[i]$。而我们要求的，就是在这$n$个阶段结束之后的路程最小期望。

那么其实状态之间的转移，我们不难看出有两种状态的转移：从$d[i-1]$或从$c[i-1]$转移过来。而因为实际上对于这个$DP$而言，因为数据不大，所以不需要优化什么的$qwq$，记录每种状态是可行的。

那么很显然啊，我们首先要预处理出每两个点之间的最短路来，方便状态的转移。而在这里，最简单的就是$Floyd$啊$qwq$。$(n^3$显然可以接受$)$



```cpp
    for(qwq int k=1;k<=v;k++)
      for(qwq int i=1;i<=v;i++)
        for(qwq int j=1;j<i;j++)
          if(f[i][k]+f[k][j]<f[i][j])
             f[i][j]=f[j][i]=f[i][k]+f[k][j];
```

然后就是$DP$方程了:
### 我们定义$dp[i][j][0/1]$来表示当前为第$i$个阶段，连同这一次已经用了$j$次换教室的机会，当前这次换$(1)$不换$(0)$的最小期望路程总和。


那么转移就可以如此转移：

这次不换：
$dp[i][j][0]=$ $min($上次不换的$dp+$这两次之间的路程 $~~$，    $~~$上次概率换了之后的$dp+p[i - 1]\times$上次换了的教室与这次不换的教室之间的距离$+(1-p[i - 1])\times$上次不换的教室与这次不换的教室之间的距离$)$

“诶，为什么上次概率换了之后（即逗号之后的一大串）要加两个期望啊？”

这个问题就是$rqy$大佬给我解决的，现在我要农夫山泉一把了：因为在上一次换教室时是**“概率”**交换，所以不一定会换呀。所以要把两种情况的都加上$qwq$。

到这儿我们就可以发现，其实换教室比不换教室是要多一重状态的，因为换教室总要牵扯**“概率成功”**的问题$qwq$

那其实接下来的状态转移方程就很简单了：一次换一次不换，遇到不换就$(1-p[i])$，遇到换就$p[i]$；两次都不换就不用枚举概率。而且由于牵扯到两次都是概率性事件（比如两次都换）之类的，这个时候需要的就是乘法原理了。

那么$DP$即如下：
```cpp
#define qwq register 
for(qwq int i=2;i<=n;i++){
     double add1=f[c[i-1]][c[i]];
      for(qwq int j=0;j<=min(m,i);j++)
       {                     
          dp[i][j][0]=min(dp[i-1][j][0]+add1,dp[i-1][j][1]+f[d[i-1]][c[i]]*p[i-1]+f[c[i-1]][c[i]]*(1-p[i-1]));
          if(j!=0)
          dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*p[i]+f[c[i-1]][c[i]]*(1-p[i]),dp[i-1][j-1][1]+f[c[i-1]][c[i]]*(1-p[i-1])*(1-p[i])+f[c[i-1]][d[i]]*(1-p[i-1])*p[i]+f[d[i-1]][c[i]]*(1-p[i])*p[i-1]+f[d[i-1]][d[i]]*p[i-1]*p[i]);
       }   
    }                  
```


总结：遇到期望的题目时一定要全面考虑啊！我们可以发现这个题的$dp$方程其实并不难想。

完结撒花！

```cpp
//感谢rqy大佬qwqqq 
#include<iostream>
#include<cstdio>
#define qwq register 
using namespace std;
double p[10001],f[2001][2001],dp[2001][2001][2];
int a[2001][2001],c[20001],d[20001];
inline double min(double a,double b){
    return a<b?a:b;
}
inline int  qread(){
    int  k = 0;
    char c;
    c = getchar();
    while(!isdigit(c))c = getchar();
 	while(isdigit(c)){
        k = (k<<1)+(k<<3)+c-48;
    	c = getchar();
    }
    return k ;
}
int main()
{
    int n,m,v,e,a1,b1,c1;
    cin>>n>>m>>v>>e;
    for(qwq int i=1;i<=n;i++)c[i]=qread();
    for(qwq int i=1;i<=n;i++)d[i]=qread();
    for(qwq int i=1;i<=n;i++)cin>>p[i];
    
    for(qwq int i=1;i<=v;i++)
     for(qwq int j=1;j<i;j++)
      f[i][j]=f[j][i]=999999999;
   
    for(qwq int i=1;i<=e;i++){
    	a1=qread(),b1=qread(),c1=qread();
        f[a1][b1]=f[b1][a1]=min(f[a1][b1],c1);
    }
    
    for(qwq int k=1;k<=v;k++)
      for(qwq int i=1;i<=v;i++)
        for(qwq int j=1;j<i;j++)
          if(f[i][k]+f[k][j]<f[i][j])
             f[i][j]=f[j][i]=f[i][k]+f[k][j];
             
    for(qwq int i=1;i<=n;i++)
        for(qwq int j=0;j<=m;j++)
            dp[i][j][0]=dp[i][j][1]=999999999;
     
    dp[1][0][0]=dp[1][1][1]=0;
    for(qwq int i=2;i<=n;i++){
     double add1=f[c[i-1]][c[i]];
      for(qwq int j=0;j<=min(m,i);j++)
       {                     
          dp[i][j][0]=min(dp[i-1][j][0]+add1,dp[i-1][j][1]+f[d[i-1]][c[i]]*p[i-1]+f[c[i-1]][c[i]]*(1-p[i-1]));
          if(j!=0)
          dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*p[i]+f[c[i-1]][c[i]]*(1-p[i]),dp[i-1][j-1][1]+f[c[i-1]][c[i]]*(1-p[i-1])*(1-p[i])+f[c[i-1]][d[i]]*(1-p[i-1])*p[i]+f[d[i-1]][c[i]]*(1-p[i])*p[i-1]+f[d[i-1]][d[i]]*p[i-1]*p[i]);
       }   
    }          
                               
    double hahaha=9999999999;
    for(int i=0;i<=m;i++){
    hahaha=min(dp[n][i][0],min(dp[n][i][1],hahaha));}
    printf("%.2lf",hahaha);
}
```

## $By$ $Flower$ _ $pks$


















---

## 作者：FREEH (赞：108)

### 【题目】
![题目1](https://cdn.luogu.com.cn/upload/pic/28543.png)
![题目2](https://cdn.luogu.com.cn/upload/pic/28545.png)
### 【声明】

- f[i][j][0/1]表示前i个时间点，共申请了j次，第i个时间点否/是进行了申请。

- dis[a][b]表示a教室->b教室的距离

- c[i]表示默认的教室

- d[i]表示更换后的教室

- k[i]表示第i个教室申请成功的概率

### 【解题思路】

- 本题的分类讨论主要分成两大类，4小类，最后分成9个小项进行考虑。

- 一、当前教室没有申请
	- 如果前一教室有申请： $f[i][j][0]=min(f[i-1][j][1]$
    
		- （1）成功：$+k[i-1]*dis[d[i-1]][c[i]]$
		- （2）失败：$+(1-k[i-1])*dis[c[i-1]][c[i]]$
	- 如果前一教室没有申请：$,f[i-1][j][0]$,一定是前后均失败：$+dis[c[i-1]][c[i]])$


------------

- 二、当前教室有申请
	- 如果前一教室有申请：$f[i][j][1]=min(f[i-1][j-1][1]$
		- （1）前后均成功：$+k[i-1]*k[i]*dis[d[i-1]][d[i]]$
		- （2）前成功、后失败：$+k[i-1]*(1-k[i])*dis[d[i-1]][c[i]]$
		- （3）前失败、后成功：$+(1-k[i-1])*k[i]*dis[c[i-1]][d[i]]$
		- （4）前后均失败：$+(1-k[i-1])*(1-k[i])*dis[c[i-1]][c[i]]$
    - 如果前一教室没有申请：$,f[i-1][j-1][0]$
		- （1）后成功：$+k[i]*dis[c[i-1]][d[i]]$
		- （2）后失败：$+(1-k[i])*dis[c[i-1]][c[i]])$
- 总结出来的动态转移方程式是：

```cpp
    f[i][j][0]= min(f[i-1][j][1]+ k[i-1]*dis[d[i-1]][c[i]]+ (1-k[i-1])*dis[c[i-1]][c[i]] ,
f[i-1][j][0] +dis[c[i-1]][c[i]]);
```

```cpp
    f[i][j][1]=min(f[i-1][j-1][1]+k[i-1]*k[i]*dis[d[i-1]][d[i]]+k[i-1]*(1-k[i])*dis[d[i-1]][c[i]]+(1-k[i-1])*k[i]*dis[c[i-1]][d[i]]+(1-k[i-1])*(1-k[i])*dis[c[i-1]][c[i]] ,  
f[i-1][j-1][0]+k[i]*dis[c[i-1]][d[i]]+(1-k[i])*dis[c[i-1]][c[i]])
```

### 【解题反思】

- 做这题的时候发现推出来的公式很优秀，程序的Floyd和DP部分也很优秀，但是却总是错样例。结果发现是Floyd初始化的时候把x->x也赋值为了无穷大，gg。毕竟我很久没用Floyd，细节大半都忘记了……这题当做算是回忆起来一些细节了吧！

### 【参考程序】
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int INF=800000000;
int n,m,v,e;
int c[2005],d[2005],dis[305][305];
double k[2005],f[2005][2005][2];
void Read()
{
	scanf("%d%d%d%d",&n,&m,&v,&e);
	for (int i=1;i<=n;i++)
		scanf("%d",&c[i]);
	for (int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	for (int i=1;i<=n;i++)
		scanf("%lf",&k[i]);
	for (int i=1;i<=v;i++)
		for (int j=1;j<i;j++)
			dis[j][i]=dis[i][j]=INF;
	for (int i=1;i<=e;i++)
	{
		int a,b,w;
		scanf("%d%d%d",&a,&b,&w);
		dis[a][b]=min(dis[a][b],w);
		dis[b][a]=dis[a][b];
	}
}

void Floyd()
{
	for (int k=1;k<=v;k++)
		for (int i=1;i<=v;i++)
			for (int j=1;j<i;j++)
				if (dis[i][j]>dis[i][k]+dis[k][j])
					dis[j][i]=dis[i][j]=dis[i][k]+dis[k][j];
}

void DP()
{
	for (int i=1;i<=n;i++)
		for (int j=0;j<=m;j++)
		{
			f[i][j][0]=f[i][j][1]=INF;
		}
	f[1][0][0]=0;
	f[1][1][1]=0;
	for (int i=2;i<=n;i++)
		for (int j=0;j<=m;j++)
		{
			f[i][j][0]= min(f[i-1][j][1]+ k[i-1]*dis[d[i-1]][c[i]]+ (1-k[i-1])*dis[c[i-1]][c[i]], 
							f[i-1][j][0] +dis[c[i-1]][c[i]]);
			if (j!=0)
				f[i][j][1]=min(f[i-1][j-1][1]+k[i-1]*k[i]*dis[d[i-1]][d[i]]+k[i-1]*(1-k[i])*dis[d[i-1]][c[i]]+(1-k[i-1])*k[i]*dis[c[i-1]][d[i]]+(1-k[i-1])*(1-k[i])*dis[c[i-1]][c[i]],
							f[i-1][j-1][0]+k[i]*dis[c[i-1]][d[i]]+(1-k[i])*dis[c[i-1]][c[i]]);
		}
}

void Write()
{
	double ans=INF;
	for (int i=0;i<=m;i++)
		for (int j=0;j<=1;j++)
		{
			ans=min(ans,f[n][i][j]);
		}
	printf("%.2lf",ans);
}
int main()
{
	Read();
	Floyd();
	DP();
	Write();
	return 0;
}

```


---

## 作者：qwaszx (赞：68)

~~我想发一个吊打给我们出题的人的题解就是这样@Refun~~

少年，你知道什么叫效率么

168ms 空间3M rk1的题解

首先这是个经典期望dp

其实这题应该是绿题不该是蓝题

只要知道期望dp的基本套路就能做

期望的计算:如果概率为k的代价为w1,概率为(1-k)的代价为w2，那么期望就是概率乘代价，即

k*w1+(1-k)*w2

n个时段的期望等于每个时段的期望之和，显然的.

于是我们来看这个题

首先有最短路，floyed暴力预处理x和y之间的距离dis[x][y]

假如到i-1个时段已经走了距离d，那么有可以选择换和不换第i个时段的教室

如果不换，那么显然这一时段的教室只能为ci

这时上一次分为换和不换两种情况，教室有k[i-1]的概率为di和(1-k[i-1])的概率为ci

期望按上面的算就好,教室之间的dis乘上概率

如果换第i个时段的教室，那么有k[i]的概率为di和(1-k[i])的概率为ci

然后上一次的同理

这个时候有k[i]k[i-1]的概率两个教室分别为di和d[i-1]

剩下的情况同理

于是我们设f[i][j][k]为到第i个时段已经换了j个教室的期望，k描述这一次换不换，为0换，为1不换

于是状态转移方程很容易写出

按照上面的描述就好

具体的可以看代码

初值，f[1][1][1]=f[1][0][0]=0,其它为inf，很好理解

答案就是max{f[n][i][k]},i=0...m,k=0...1
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
using namespace std;
const int inf=1<<20;//
int n,m,v,e,a[2001],b[2001],dis[2001][2001];
double ans,f[2001][2001][2],c[2001];
inline char gc()//fread加速快读
{
    static char BB[1000001],*S=BB,*T=BB;
    return S==T&&(T=(S=BB)+fread(BB,1,1000000,stdin),S==T)?EOF:*S++;
}
inline int getin()//普通快读
{
    int x=0;char ch=gc();
    while(ch<'0'||ch>'9')ch=gc();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=gc();
    return x;
}
inline double rgetin()//仿照负数快读写实数快读
{
    double x=0;char ch=gc();
    while(ch<'0'||ch>'9')ch=gc();
    while(ch>='0'&&ch<='9')x=x*10+(ch-48),ch=gc();
    if(ch=='.')
    {
        double l=0.1;
        ch=gc();
        while(ch>='0'&&ch<='9')x=x+(ch-48)*l,l/=10,ch=gc();
    }
    return x;
}
int main()
{
    n=getin(),m=getin(),v=getin(),e=getin();
    for(register int i=1;i<=n;i++)a[i]=getin();//不换的教室
    for(register int i=1;i<=n;i++)b[i]=getin();//换的教室
    for(register int i=1;i<=n;i++)c[i]=rgetin();//概率
    for(register int i=1;i<=v;i++)
        for(register int j=1;j<i;j++)
            dis[i][j]=dis[j][i]=inf;//dis初始为inf，不用处理dis[i][i]的情况
    for(register int i=1;i<=e;i++)
    {
        register int x,y,w;//从x到y有一条权值为w的边
        x=getin(),y=getin(),w=getin(),dis[x][y]=dis[y][x]=min(dis[x][y],w);//无向图，防止重边
    }
    for(register int k=1;k<=v;k++)
        for(register int i=1;i<=v;i++)
            for(register int j=1;j<i;j++)//无向图，所以不用处理j>=i
                if(dis[i][k]+dis[k][j]<dis[i][j])
                    dis[i][j]=dis[j][i]=dis[i][k]+dis[k][j];
    for(register int i=1;i<=n;i++)
        for(register int j=0;j<=m;j++)
            f[i][j][0]=f[i][j][1]=inf;
    f[1][0][0]=f[1][1][1]=0;//初始化
    for(register int i=2;i<=n;i++)
    {
        register int mn=min(i,m);
        register double w1=dis[a[i-1]][a[i]],
        w2=dis[b[i-1]][a[i]]*c[i-1]+dis[a[i-1]][a[i]]*(1-c[i-1]),
        w3=dis[a[i-1]][b[i]]*c[i]+dis[a[i-1]][a[i]]*(1-c[i]),
        w4=dis[a[i-1]][a[i]]*(1-c[i-1])*(1-c[i])+dis[a[i-1]][b[i]]*(1-c[i-1])*c[i]+dis[b[i-1]][a[i]]*(1-c[i])*c[i-1]+dis[b[i-1]][b[i]]*c[i-1]*c[i];//预先算好加速，这是一个很不好看的递推式
        for(register int j=0;j<=mn;j++)
        {
            f[i][j][0]=min(f[i-1][j][0]+w1,f[i-1][j][1]+w2);
            if(j)f[i][j][1]=min(f[i-1][j-1][0]+w3,f[i-1][j-1][1]+w4);
        }//正常的dp
    }
    ans=inf;
    for(register int i=0;i<=m;i++)
        ans=min(ans,min(f[n][i][0],f[n][i][1]));//统计答案
    printf("%.2lf",ans);
}
```
如果做到这里，已经稳A了

但还不够快！

我们看到f[i][j][k]的值只和f[i-1][j,j-1][0,1]有关

所以滚动数组优化一波

保证f[i][j][k]是由上一次的递推过来，所以j倒着循环即可，和01背包是一样的

这个样子空间就优化到了一维，速度也提高了不少，虽然还是要看脸
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int inf=1<<20;
int n,m,v,e,a[2001],b[2001],dis[301][301];
double ans,f[2001][2],c[2001];
inline char gc()
{
	static char BB[1000001],*S=BB,*T=BB;
	return S==T&&(T=(S=BB)+fread(BB,1,1000000,stdin),S==T)?EOF:*S++;
}
inline int getin()
{
	int x=0;char ch=gc();
	while(ch<'0'||ch>'9')ch=gc();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=gc();
	return x;
}
inline double rgetin()
{
	double x=0;char ch=gc();
	while(ch<'0'||ch>'9')ch=gc();
	while(ch>='0'&&ch<='9')x=x*10+(ch-48),ch=gc();
	if(ch=='.')
	{
		double l=0.1;
		ch=gc();
		while(ch>='0'&&ch<='9')x=x+(ch-48)*l,l/=10,ch=gc();
	}
	return x;
}
int main()
{
	n=getin(),m=getin(),v=getin(),e=getin();
	for(register int i=1;i<=n;i++)a[i]=getin();
	for(register int i=1;i<=n;i++)b[i]=getin();
	for(register int i=1;i<=n;i++)c[i]=rgetin();
	for(register int i=1;i<=v;i++)
		for(register int j=1;j<i;j++)
			dis[i][j]=dis[j][i]=inf;
	for(register int i=1;i<=e;i++)
	{
		register int x,y,w;
		x=getin(),y=getin(),w=getin(),dis[x][y]=dis[y][x]=min(dis[x][y],w);
	}
	for(register int k=1;k<=v;k++)
		for(register int i=1;i<=v;i++)
			for(register int j=1;j<i;j++)
				if(dis[i][k]+dis[k][j]<dis[i][j])
					dis[i][j]=dis[j][i]=dis[i][k]+dis[k][j];
	for(register int j=0;j<=m;j++)
			f[j][0]=f[j][1]=inf;
	f[0][0]=f[1][1]=0;
	for(register int i=2;i<=n;i++)
	{
		register int mn=min(i,m);
		register double w1=dis[a[i-1]][a[i]],w2=dis[b[i-1]][a[i]]*c[i-1]+dis[a[i-1]][a[i]]*(1-c[i-1]),w3=dis[a[i-1]][b[i]]*c[i]+dis[a[i-1]][a[i]]*(1-c[i]),w4=dis[a[i-1]][a[i]]*(1-c[i-1])*(1-c[i])+dis[a[i-1]][b[i]]*(1-c[i-1])*c[i]+dis[b[i-1]][a[i]]*(1-c[i])*c[i-1]+dis[b[i-1]][b[i]]*c[i-1]*c[i];
		for(register int j=mn;j>=0;j--)
		{
			f[j][0]=min(f[j][0]+w1,f[j][1]+w2);
			if(j)f[j][1]=min(f[j-1][0]+w3,f[j-1][1]+w4);
		}
	}
	ans=inf;
	for(register int i=0;i<=m;i++)
		ans=min(ans,min(f[i][0],f[i][1]));
	printf("%.2lf",ans);
}
```

---

## 作者：米奇奇米 (赞：23)

## 题解- NOIPDay1T3  换教室

### 题目意思
 题面很长但是挺好懂的。就是你有$\leq m$次换课机会从班级$c[i]$转换到班级$d[i]$，但是只有$k\%$的概率能够成功转换，代价就是$c[i]$到$d[i]$的最短路。问你期望总和最小是多少？
 
### $Solution$

主要用到的算法为**最短路**以及**动态规划**

* **最短路**

就是求出任意两个点之间存在的最短路距离，用$floyed$就可以求解，$v\leq 300$所以$O(v^3)$能过的

* **动态规划**

首先我们要明确**状态**

$f[i][j][0/1]$ 表示到第$i$间教室用了$j$次转换机会第$i$次选或不选的最优解

**初始化：** $f[i][j][0/1]=inf,f[1][0][0/1]=0$

**转移：**

非常刺激的！首先存在两种大可能即$f[i][j][0/1]$第$i$次使不使用转换技能。然后再对这两种情况讨论：

**对于$f[i][j][0]$**

* $a.$就是$i-1$次你不使用技能，那么转移有一种小情况：$f[i-1][j][0]+dis[c[i-1]][c[i]]$

* $b.$就是你$i-1$次使用技能啦，又分两种小情况
	* 申请成功了：$f[i-1][j][1]+p[i-1]*dis[d[i-1]][c[i]$
    因为申请成功从$c[i-1]$转移到$d[i-1]$
    
    * 申请不成功：$f[i][j][1]+(1-p[i-1])*dis[c[i-1]][c[i]]$
   	因为申请不成功的概率为$1-p[i-1]$
    
* 于是将上述两种情况综合在一起则为：$f[i][j][0]=min(f[i-1][j][0]+dis[c[i-1]][c[i]],f[i-1][j][1]+p[i-1]*dis[d[i-1]][c[i]+(1-p[i-1])*dis[c[i-1]][c[i]]$


**对于$f[i][j][1]$**

* $a.$就是$i-1$次你不使用技能，那么转移有两种小情况
	* 第$i$次申请成功啦：$f[i-1][j-1][0]+p[i]*dis[c[i-1]][d[i]]$
    * 第$i$次申请失败啦：$f[i-1][j-1][0]+(1-p[i])*dis[c[i-1]][c[i]]$
    
    这个应该比较好理解就是如果你申请成功那么一定是由上次的$c[i]$到这次的$d[i]$否则还是$c[i]$

* $b.$就是$i-1$次你使用技能，那么转移有四种小情况
	* $i-1$次成功$i$次失败：$f[i-1][j-1][1]+((1-p[i])*p[i-1])*dis[d[i-1]][c[i]]$
    * $i-1$次成功$i$次成功：$f[i-1][j-1][1]+(p[i]*p[i-1])*dis[d[i-1]][d[i]]$
    * $i-1$次失败$i$次成功：$f[i-1][j-1][1]+(p[i]*(1-p[i-1]))*dis[c[i-1]][d[i]]$
 	* $i-1$次失败$i$次失败：$f[i-1][j-1][1]+((1-p[i])*(1-p[i-1]))*dis[c[i-1]][c[i]]$
    
* 于是将上述两种情况综合在一起则为：$f[i][j][1]=min(f[i-1][j-1][0]+p[i]*dis[c[i-1]][d[i]]+(1-p[i])*dis[c[i-1]][c[i]],f[i-1][j-1][1]+((1-p[i])*p[i-1])*dis[d[i-1]][c[i]]+(p[i]*p[i-1])*dis[d[i-1]][d[i]]+(p[i]*(1-p[i-1]))*dis[c[i-1]][d[i]]+((1-p[i])*(1-p[i-1]))*dis[c[i-1]][c[i]]$

**转移相当得长但是很好理解qwq**

### $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;

struct IO {
	#define gc getchar
	#define pt putchar

	inline int read() {
		int sum=0,ff=1; char ch=gc();
		while(!isdigit(ch)) {
			if(ch=='-') ff=-1;
			ch=gc();
		}
		while(isdigit(ch))
			sum=sum*10+(ch^48),ch=gc();
		return sum*ff;
	}

	inline void write(int x) {
	    if(x<0)
			pt('-'),x=-x;
	    if(x>9)
			write(x/10);
	    pt(x%10+48);
	}

	inline void writeln(int x) {
		write(x);
		pt('\n');
	}
} fast;

#define inf 1e8
#define db double 
const int maxn=2333;

int n,m,V,E,cnt;
int dis[maxn][maxn],c[maxn],d[maxn];
double p[maxn],f[maxn][maxn][3],ans;

int main() {
//	freopen("classroom.in","r",stdin);
//	freopen("classroom.out","w",stdout);
	n=fast.read();
	m=fast.read();
	V=fast.read();
	E=fast.read();
	for ( int i=1;i<=n;i++ ) c[i]=fast.read();
	for ( int i=1;i<=n;i++ ) d[i]=fast.read();
	for ( int i=1;i<=n;i++ ) scanf("%lf",&p[i]);
	
	for ( int i=1;i<=V;i++ )
        for ( int j=1;j<i;j++ )
            dis[i][j]=dis[j][i]=inf;
	for ( int i=1;i<=E;i++ ) { 
		int u=fast.read();
		int v=fast.read();
		int z=fast.read();
		dis[u][v]=min(dis[u][v],z);
		dis[v][u]=dis[u][v];
	}
	
	for ( int k=1;k<=V;k++ ) 
		for ( int i=1;i<=V;i++ ) 
			for ( int j=1;j<i;j++ ) 
				if(dis[i][j]>dis[i][k]+dis[k][j])
                    dis[j][i]=dis[i][j]=dis[i][k]+dis[k][j];
				
	for ( int i=1;i<=n;i++ ) 
		for ( int j=0;j<=m;j++ ) 
			f[i][j][0]=f[i][j][1]=inf;
	f[1][0][0]=f[1][1][1]=0;
	
	for ( int i=2;i<=n;i++ ) 
		for ( int j=0;j<=m;j++ ) {
			
			double casea=f[i-1][j][0]+(db)dis[c[i-1]][c[i]];
			double caseb=f[i-1][j][1]+p[i-1]*(db)dis[d[i-1]][c[i]];
			double casec=(1-p[i-1])*(db)dis[c[i-1]][c[i]];
//			printf("casea=%.3lf caseb=%.3lf casec=%.3lf\n",casea,caseb,casec);
			f[i][j][0]=min(casea,caseb+casec);
			
			if(j!=0) {
				double case1=f[i-1][j-1][1]+(p[i]*p[i-1])*(db)dis[d[i-1]][d[i]];
				double case2=(p[i]*(1-p[i-1]))*(db)dis[c[i-1]][d[i]];
				double case3=((1-p[i])*p[i-1])*(db)dis[d[i-1]][c[i]];
				double case4=((1-p[i])*(1-p[i-1]))*(db)dis[c[i-1]][c[i]];
				double case5=f[i-1][j-1][0]+p[i]*(db)dis[c[i-1]][d[i]];
				double case6=(1-p[i])*(db)dis[c[i-1]][c[i]];
				f[i][j][1]=min(case1+case2+case3+case4,case5+case6); 
			}
		}
	ans=inf;
//	for ( int i=0;i<=m;i++ ) 
//		printf("%.3lf %.3lf\n",f[n][i][0],f[n][i][1]);
	
	for ( int i=0;i<=m;i++ ) 
		ans=min(ans,min(f[n][i][0],f[n][i][1]));
	printf("%.2lf\n",ans);
	return 0;
}

```


---

## 作者：To_Carpe_Diem (赞：3)

# 前置知识

## 前言

既然没人讲与概率有关的知识的话，那就让我来简单介绍一下概率的相关知识吧，这个如果不知道的话这道题还是很难写的。

## 概率相关
### 定理 $1$：互补法则
**定义**：若事件 $A$ 发生的概率为 $P(A)$，则其不发生概率为 $1 - P(A)$。

**举例**：早上起来有两种选择，吃饭和不吃饭，若吃饭的概率为 $\dfrac{3}{10}$，则有不吃饭的概率为 $1 - \dfrac{3}{10} = \dfrac{7}{10}$。

### 定理 $2$：加法法则（互斥事件）
**定义**：若事件 $A_1 \sim A_n \in S$ 且 $A_i \cap A_j=\emptyset \quad \forall i, j\in\{1,2,\dots,n\},\quad i \neq j$。

那么集合中所有事件发生的概率 $P = \sum_{i=1}^n P(A_i)$。

**举例**：掷一次骰子时，点数大于 $4$ 的概率 $P = P(5) + P(6) = \dfrac{1}{6} + \dfrac{1}{6} = \dfrac{1}{3}$。

### 定理 $3$：乘法法则（无关事件）
**定义**：若事件 $A$ 与 $B$ 互相独立，不受影响，那么$ P(A \cap B) = P(A) \times P(B)$。

**举例**：早上吃饭的概率为 $\dfrac{3}{10}$，吃完饭写作业的概率为 $\dfrac{5}{6}$，那么早上吃完饭后去写作业的概率为 $\dfrac{3}{10} \times \dfrac{5}{6} = \dfrac{1}{4}$。

# 题目
## 题目大意

牛牛需要在 $n$ 个时间段内完成 $2n$ 节课程，每时间段有两节课程分别安排在教室 $c_i$ 和 $d_i$。牛牛可以申请更换教室，申请通过的概率为 $k_i$，最多申请 $m$ 次。更换教室后，牛牛需要在教室间移动，移动的体力消耗为最短路径的体力值。求**最小**的体力消耗期望值。

## 思路

### 题目类型

我们发现对于每一个时间段 $i$ 的课程，都有选 $c_i$ 和 $d_i$ 两种，我们可以很快想到用**动态规划**来解决**期望概率**的问题，而**最短路径**的话可以用弗洛伊德算法求解，因为本题 $1 \le v \le 300$，那么我们的状态如何设计呢？

### 状态设计

首先，对于每个**时间段**是一定要在状态里面的。其次，牛牛对于换教室这个事情其实是不感冒的，可以换或者不换，因此**换了多少个教室**是一定要在条件里面的。最后，因为我们按时间段向后 dp 的话，当前的 $i$ 时间段是由 $i - 1$ 推出的，但是无法记录上一个时间段到底换没换教室，如果要开个别的东西记录一下就太麻烦，因此就需记录**上一个时间段是否换了教室**。

所以我们可以这样记录状态，用 $dp_{i,j,k}$ 来表示，在第 $i$ 个时间段内，已经选了 $j$ 间教室更换，$k$ 表示当前的为这个时间段是否更换，$k \in \{0,1\}$。

### 转移方程（分类讨论）

#### 一：选择不更换当前的教室，再次分类讨论。

由**互补法则**可知，当前成功更换的概率为 $v_i$，失败的概率即为 $1 - v_i$，而下文的 $2$ 与 $3$ 属于**互斥事件**，因此用**加法法则**，将两者的概率加到一起。

1. 前一个教室**不做**更改，当前期望值即为 $f_{c_{i-1},c_i}$。
2. 前一个教室**做**更改，且更改**成功**，当前期望值即为 $v_{i-1} \times f_{d_{i-1},c_i}$。
3. 前一个教室**做**更改，且更改**失败**，当前期望值即为 $(1 - v_{i-1}) \times f_{c_{i-1},c_i}$。
   
总结第一大类的情况，为了求最小值，所以取小，即可得出选择不更换当前教室的转移方程：

$$
dp_{i,j,0} \gets \min(dp_{i-1,j,0} + f_{c_{i-1},c_i},dp_{i-1,j,1} + v_{i-1} \times f_{d_{i-1},c{i}} + (1 - v_{i-1}) \times f_{c_{i-1},c_i})
$$

#### 二：选择更换当前教室，再次分类讨论

下文的 $1$ 和 $2$ 属于**互斥事件**，而 $3,4,5,6$ 也属于**互斥事件**，因此用**加法法则**，将两者的概率加到一起。而对于 $3,4,5,6$，由**乘法法则**，则将两次概率相乘。

1. 前一个教室**不做**更改，且当前教室更改**成功**，当前期望值即为 $v_i \times f_{c_{i-1},d_i}$
2. 前一个教室**不做**更改，且当前教室更改**失败**，当前期望值即为 $(1 - v_i) \times f_{c_{i-1},c_i}$
3. 前一个教室**做**更改，且前一个更改**成功**，当前教室更改**成功**，当前期望值即为 $v_{i-1} \times v_i \times f_{d_{i-1},d_i}$
4. 前一个教室**做**更改，且前一个更改**成功**，当前教室更改**失败**，当前期望值即为 $v_{i-1} \times (1 - v_i) \times f_{d_{i-1},c_i}$
5. 前一个教室**做**更改，且前一个更改**失败**，当前教室更改**成功**，当前期望值即为 $(1 - v_{i-1}) \times v_i \times f_{c_{i-1},d_i}$
6. 前一个教室**做**更改，且前一个更改**失败**，当前教室更改**失败**，当前期望值即为 $(1 - v_{i-1}) \times (1 - v_i) \times f_{c_{i-1},c_i}$

总结第一大类的情况，这里的 $j$ 不要忘记 $-1$，即可得出选择更换当前教室的转移方程：

$$
dp_{i,j,1} \gets \min(dp_{i-1,j-1,0} + v_i \times f_{c_{i-1},d_i} + (1 - v_i) \times f_{c_{i-1},c_i},dp_{i-1,j-1,1} + v_{i-1} \times v_i \times f_{d_{i-1},d_i} + v_{i-1} \times (1 - v_i) \times f_{d_{i-1},c_i} + (1 - v_{i-1}) \times v_i \times f_{c_{i-1},d_i} + (1 - v_{i-1}) \times (1 - v_i) \times f_{c_{i-1},c_i})
$$

## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<iomanip>
using namespace std;

const int MAXN = 2005;
const int MAXV = 305;
double f[MAXV][MAXV];
int n,m,e,v;
int c[MAXN],d[MAXN];
double k[MAXN];
double dp[MAXN][MAXN][2];

signed main(){
	cin.tie(0) -> ios::sync_with_stdio(0);
	cin >> n >> m >> v >> e;
	for(int i = 1;i <= n;i ++) cin >> c[i];
	for(int i = 1;i <= n;i ++) cin >> d[i];
	for(int i = 1;i <= n;i ++) cin >> k[i];
	for(int i = 1;i <= v;i ++){
		for(int j = 1;j <= v;j ++){
			f[i][j] = 1e18;
		}
		f[i][i] = 0;
	}
	for(int u,v,w,i = 1;i <= e;i ++){
		cin >> u >> v >> w;
		f[v][u] = f[u][v] = min(f[u][v],w * 1.0);
	}
	for(int t = 1;t <= v;t ++){
		for(int i = 1;i <= v;i ++){
			for(int j = 1;j <= v;j ++){
				if(f[i][t] + f[t][j] < f[i][j]){
					f[i][j] = f[i][t] + f[t][j];
				}
			}
		}
	}
	for(int i = 1;i <= n;i ++){
		for(int j = 0;j <= m;j ++){
			dp[i][j][1] = dp[i][j][0] = 1e18;
		}
	}
	dp[1][1][1] = dp[1][0][0] = 0;
	for(int i = 2;i <= n;i ++){
		for(int j = 0;j <= m;j ++){
			dp[i][j][0] = min(dp[i - 1][j][0] + f[c[i - 1]][c[i]],dp[i - 1][j][1] + k[i - 1] * f[d[i - 1]][c[i]] + (1 - k[i - 1]) * f[c[i - 1]][c[i]]);
			if(j > 0) dp[i][j][1] = min(dp[i - 1][j - 1][0] + f[c[i - 1]][d[i]] * k[i] + f[c[i - 1]][c[i]] * (1 - k[i]),dp[i - 1][j - 1][1] + k[i - 1] * k[i] * f[d[i - 1]][d[i]] + k[i - 1] * (1 - k[i]) * f[d[i - 1]][c[i]] + (1 - k[i - 1]) * k[i] * f[c[i - 1]][d[i]] + (1 - k[i - 1]) * (1 - k[i]) * f[c[i - 1]][c[i]]);
		}
	}
	double ans = 1e18;
	for(int i = 0;i <= m;i ++){
		ans = min(ans,min(dp[n][i][1],dp[n][i][0]));
	}
	cout << fixed << setprecision(2) << ans << '\n';
	return 0;
}
```

好了，记得在进制转换的时候注意一下就可以了，本题做完可以试试 [Bag of mice](https://www.luogu.com.cn/problem/CF148D)，也是一个概率 dp。

---

## 作者：kind_aunt (赞：2)

# P1850 [NOIP2016 提高组] 换教室
个人认为这道蓝还是很水的。
## 思路
首先，需要将图上任意两点的距离求出来，方便后续转移，跑 $v$ 遍 Dijkstra 或用 Floyd 都可以。只不过 Dijkstra 会多一个 $O(\log e)$，可以忽略不计。

其次，根据题目要求 $n$ 个时间点最多申请 $m$ 次的耗费体力和的期望，定义 $dp_{i,j}$ 意为前 $i$ 个时间点申请 $j$ 次的最小期望。当然，$0\le j\le i$。

现在知道终点了，那起点是什么呢？所以还有再加一维 $0/1$，表示第 $i$ 个时间点是否申请。

考虑转移，如果当前这个点申请（无论 ta 是起点还是终点），成功的概率是 $k$，失败的概率是 $1-k$，在分别乘上 ta 们的距离，以此为中心思想就能得出转移方程了，大概是这样的：

```cpp
double ans1=dp[i-1][j][0]
      +1.0*dis[c[i-1]][c[i]];
double ans2=dp[i-1][j][1]
      +1.0*dis[c[i-1]][c[i]]*(1-k[i-1])
      +1.0*dis[d[i-1]][c[i]]*k[i-1];
dp[i][j][0]=min(ans1,ans2);
if(j){
  double ans3=dp[i-1][j-1][0]
        +1.0*dis[c[i-1]][c[i]]*(1-k[i])
        +1.0*dis[c[i-1]][d[i]]*k[i];
  double ans4=dp[i-1][j-1][1]
        +1.0*dis[c[i-1]][c[i]]*(1-k[i])*(1-k[i-1])
        +1.0*dis[d[i-1]][c[i]]*(1-k[i])*k[i-1]
        +1.0*dis[c[i-1]][d[i]]*k[i]*(1-k[i-1])
        +1.0*dis[d[i-1]][d[i]]*k[i]*k[i-1];
  dp[i][j][1]=min(ans3,ans4);
}
```
至此基本就讲完啦，全部代码就不贴了，~~防止你们抄~~自己写更有成就感。

时间复杂度为 $O(ve\log e+nm)$ 或 $O(v^3+nm)$。（前一种是 Dijkstra，后面的是 Floyd）

---

## 作者：aiyougege (赞：2)

### 换教室
#### Solution
　　这道题细节很多但是如果思路清晰的话应该不是很难.

　　这是一个动态规划题, 实际上问题就是说请求不超过m次换教室使得收益最大.　那么可以用$f(i,j,1)$表示第$i$个时刻已经请求了换$j$次教室而且请求了换当前的教室所花时间的期望;　用$f(i,j,0)$表示第$i$个时刻已经请求了换$j$次教室而且没有请求了换当前的教室所花时间的期望,那么转移方程可以这么写:
  
$$f(i,j,1)=\min\{f(i-1,j,0)+\text{time},f(i-1,j,1)+\text{time}\}$$
$$f(i,j,0)=\min\{f(i-1,j-1,0)+\text{time},f(i-1,j-1,1)+\text{time}\}$$

　　其中$\text{time}$为**两时刻来往教室间的时间的期望**,如何求它呢?

　　首先如果我在某一个时刻$i$**请求换教室**而且**第$\text{i+1}$个时刻没有换教室**, 那么有$k_i$的几率我成功换了教室, 也就是说在第$\text{i+1}$个时刻我有$k_i$的概率在第$d_i$个教室;　　有$1\text{-}k_i$的几率在第$c_i$个教室, 所以我从第$i$个时刻的教室到达第$\text{i+1}$个时刻的教室的期望花费时间为
  $$\text{dis}(c_i,c_{i+1})(1-k_i)+\text{dis}(d_i,c_{i+1})k_i$$
  
如果不光$i$时没有确定的位置(*i+1时请求了换教室因此在两个位置都有一定概率*), 而且$\text{i+1}$时我也没有具体的位置, 那么我需要考虑四种情况, 即
- $i$时换成功而且$\text{i+1}$时也换成功, 概率为$k_i\cdot k_{i+1}$.
- $i$时换成功, $\text{i+1}$时没换成功, 概率为$k_i\cdot (1-k_{i+1})$.
- $i$时没换成功, $\text{i+1}$时换成功, 概率为$(1-k_i)\cdot k_{i+1}$.
- $i$时没换成功而且$\text{i+1}$时也没换成功, 概率为$(1-k_i)\cdot (1-k_{i+1})$.

#### Code
```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 2005
#define M 305
#define inf 12345678999.123//定义无穷大
using std::min;

int n,m,v,e;
double q[M][M];//两个教室之前距离
int c[N],d[N];
double k[N];
double f[N][N][2];

int main(){
    scanf("%d%d%d%d",&n,&m,&v,&e);int a,b,cc;
    for(int i=0;i<=n;++i)for(int j=0;j<=m;++j)f[i][j][0]=f[i][j][1]=inf;//设为无穷大
    for(int i=1;i<=n;++i)scanf("%d",&c[i]);
    for(int i=1;i<=n;++i)scanf("%d",&d[i]);
    for(int i=1;i<=n;++i)scanf("%lf",&k[i]);
    for(int i=1;i<=v;i++)
        for(int j=1;j<i;j++)
            q[i][j]=q[j][i]=inf;//将两教室之间的距离设为无穷大
    for(int i=1;i<=e;++i){
        scanf("%d%d%d",&a,&b,&cc);
        q[a][b]=q[b][a]=min(q[a][b],cc*1.0);
    }
    for(int kk=1;kk<=v;kk++)
        for(int i=1;i<=v;i++)
            for(int j=1;j<i;j++)
                if(q[i][kk]+q[kk][j]<q[i][j])
                    q[i][j]=q[j][i]=q[i][kk]+q[kk][j];// Floyd求两点之间最短距离
	
    f[1][0][0]=f[1][1][1]=0;//初始化
    for(int i=2;i<=n;++i)
        for(int j=0;j<=m&&j<=i;++j){
            f[i][j][0]=f[i-1][j][0] + q[c[i-1]][c[i]];//i,i+1都没换
            f[i][j][0]=min(f[i][j][0], f[i-1][j][1] + q[d[i-1]][c[i]]*k[i-1] + q[c[i-1]][c[i]]*(1.0-k[i-1]));//i时换,i+1不换
            if(j)f[i][j][1]=f[i-1][j-1][0] + q[c[i-1]][d[i]]*k[i] + q[c[i-1]][c[i]]*(1.0-k[i]);// i时不换, i+1换
            if(j)f[i][j][1]=min(f[i][j][1], f[i-1][j-1][1] + q[c[i-1]][c[i]]*(1.0-k[i-1])*(1.0-k[i]) + q[c[i-1]][d[i]]*(1.0-k[i-1])*k[i] + q[d[i-1]][c[i]]*k[i-1]*(1.0-k[i]) + q[d[i-1]][d[i]]*k[i-1]*k[i]);//i时和i+1时都换
        }
    double ans=inf;
    for(int i=0;i<=m;++i)
        ans=min(ans,min(f[n][i][0],f[n][i][1]));//求出最小值
    printf("%.2f",ans);
    return 0;
}
```

---

## 作者：ShineEternal (赞：2)

[$My\ blog$](https://blog.csdn.net/kkkksc03)

天哪这道题真的是神仙。。。

orz出题人

能出这种dp转移都写吐血的题目真的tql

## description:

给出n个时间段，可申请m次换课，每次换课可申请从$c[i]$换到$d[i]$,并有$k[i]$的概率换课成功，每个教室有间距，问路程期望的最小值。

## solution：

首先这就是一道期望dp题。

说到期望，

https://45475.blog.luogu.org/mathematical-expectation

这篇日报大概会给你不少的启发。


**考虑Dp**

设$f[i][j][0/1]$表示前i节课申请了j次，第i次是否申请的期望最优解。

则：

$$f[i][j][0]=\min(f[i][j][0],f[i-1][j][0]+a[c[i-1]][c[i]],f[i-1][j][1]+(1-k[i-1])*a[c[i-1]][c[i]]+k[i-1]*a[d[i-1]][c[i]])$$

从两种情况转移而来：

- 上一次没申请换课，那么这两次直接都从$c$的规定走就行了。

- 上一次申请换课了：

1、通过了，那么就从上一次的d到现在的c

2、没通过，跟上一次没申请一样


$$f[i][j][1]=\min(f[i][j][1],f[i-1][j-1][0]+k[i]*a[c[i-1]][d[i]]+(1-k[i])*a[c[i-1]][c[i]],f[i-1][j-1][1]+k[i-1]*k[i]*a[d[i-1]][d[i]]+k[i-1]*(1-k[i])*a[d[i-1]][c[i]]+(1-k[i-1])*k[i]*a[c[i-1]][d[i]]+(1-k[i-1])*(1-k[i])*a[c[i-1]][c[i]])$$

### 重要提示：

dp式子真的很长，当然放在代码里写的应该比较短，会尽全力解释，但可以移步代码查看分步式子。

还是分两种：

- 上一次没申请：

1、这次通过了，那么从上一次的c到现在的d

2、没通过，c到c

- 上一次申请了：

~~现在热闹了~~

上一次申请的两种情况：

$$(1-k[i-1])\times c[i-1],k[i-1]*d[i-1]$$

这次申请的两种情况：

$$(1-k[i])\times c[i],k[i]*d[i]$$

现在，只要两两组合即可，共有$2\times2=4$种来源。

**a数组是什么？**

这是两点间距离数组，观察到教室数较少，Floyd求出即可


## code：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
double k[2005],a[305][305];
double f[2005][2005][2];
int c[2005],d[2005];
int main()
{
	int n,m,v,e;
	scanf("%d%d%d%d",&n,&m,&v,&e);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&c[i]);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&d[i]);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&k[i]);
	}
	for(int i=1;i<=301;i++)
	{
		for(int j=1;j<=301;j++)
		{
			a[i][j]=1000000000;
		}
	} 
	for(int i=1;i<=300;i++)
	a[i][i]=0; 
	for(int i=1;i<=e;i++)
	{
		int x,y;
		double z;
		scanf("%d%d%lf",&x,&y,&z);
		a[x][y]=a[y][x]=min(a[x][y],z);
	}
	
	for(int kk=1;kk<=v;kk++)
	{
		for(int i=1;i<=v;i++)
		{
			for(int j=1;j<=v;j++)
			{
				a[i][j]=min(a[i][j],a[i][kk]+a[kk][j]);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			f[i][j][0]=f[i][j][1]=1000000000;
		}
	}
	f[1][0][0]=f[1][1][1]=0;
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=min(i,m);j++)
		{
			f[i][j][0]=min(f[i][j][0],f[i-1][j][0]+a[c[i-1]][c[i]]);
			f[i][j][0]=min(f[i][j][0],f[i-1][j][1]+(1-k[i-1])*a[c[i-1]][c[i]]+k[i-1]*a[d[i-1]][c[i]]);
			if(j)
			{
				f[i][j][1]=min(f[i][j][1],f[i-1][j-1][0]+k[i]*a[c[i-1]][d[i]]+(1-k[i])*a[c[i-1]][c[i]]);
				f[i][j][1]=min(f[i][j][1],f[i-1][j-1][1]+k[i-1]*k[i]*a[d[i-1]][d[i]]+k[i-1]*(1-k[i])*a[d[i-1]][c[i]]+(1-k[i-1])*k[i]*a[c[i-1]][d[i]]+(1-k[i-1])*(1-k[i])*a[c[i-1]][c[i]]);
			}
		}
	}
	double ans=1000000000;
	for(int i=0;i<=m;i++)
	{
		ans=min(ans,f[n][i][1]);
		ans=min(ans,f[n][i][0]);
	}
	printf("%.2lf\n",ans);
	return 0;
}
```

---

## 作者：zhou2414 (赞：1)

# 思路
看到期望就想到 dp。  
题目中两个教室间的距离可以用 floyd ~~快速~~求出。

设 $dp_{i,j,0/1}$ 表示到第 $i$ 个课程，换了 $j$ 次课（包括这一次），当前课是否选择换课的期望距离最小值。
# 转移方程
设 $dis_{i,j}$ 表示第 $i$ 个教室和第 $j$ 个教室间的距离，第 $i$ 个课交换成功的概率为 $p_i$。
## 不交换
先考虑当前课不换的情况。

此时只有两种情况：上一次课换或不换。

对于上一次课不换的情况，显然有：
$$
dp_{i,j,0}=dp_{i-1,j,0}+dis_{c_{i-1},c_{i}}
$$
对于上一次课换的情况，由于上一次换课不一定成功，所以需要分类讨论。

当上一次换课成功时，两者距离为 $dis_{d_{i-1},c_{i}}$，失败则为 $dis_{c_{i-1},c_{i}}$。概率分别为 $p_{i-1}$ 和 $1-p_{i-1}$。

于是有：
$$
dp_{i,j,0}=dp_{i-1,j,1}+dis_{d_{i-1},c_{i}}p_{i-1}+dis_{c_{i-1},c_{i}}\cdot (1-p_{i-1})
$$
由于上次课换与不换的情况不能同时出现，且题目要求求期望最小值，所以两者取 $\min$ 即可。
## 交换
当前课交换的情况与不交换的情况的转移方程推导类似（~~大力分讨~~），希望读者自己推导，故不再赘述，直接放出结果：
$$
dp_{i,j,1}=\min(dp_{i-1,j-1,0}+dis_{c_{i-1},c_{i}}\cdot (1-p_{i-1})+dis_{c_{i-1},d_{i}}p_{i-1},\\
dp_{i-1,j-1,1}+\\

dis_{c_{i-1},d_i}\cdot(1-p_{i-1})p_i+dis_{d_{i-1},c_i}p_{i-1}\cdot(1-p_i)+\\dis_{c_{i-1},c_i}\cdot(1-p_{i-1})\cdot(1-p_i)+dis_{d_{i-1},d_{i}}p_{i-1}p_i
$$
（~~蒟蒻太菜式子丑见谅~~）  
注意取第一个式子的条件是 $j\geq 1$（即至少包含当前课），取第二个式子的条件是 $j\geq 2$（即至少包含当前课和上一节课）。

然后就可以愉快地 AC 啦！
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define dl double)
inline int read() {
	int x = 0, f = 1;
	char ch;
	while ((ch = getchar()) < 48 || ch > 57)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
char __sta[1009], __len;
inline void write(int x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	putchar(bo ? '\n' : ' ');
}
const ll V = 309, N = 2009, INF = 1e9+3, E = 90009;
ll n, m, v, e;
ll c[N], d[N];
dl p[N];
dl dp[N][N][2];//1换0不换
ll dis[V][V];
inline void init() {
	for (int i = 0; i <= v; i++)
		dis[i][i] = dis[0][i] = 0;
	for (int k = 1; k <= v; k++) {
		dis[0][k] = 0;
		for (int j = 1; j <= v; j++) {
			for (int i = 1; i <= v; i++) {
				if (i != k && j != k)dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
			}
		}
	}
}
void solve() {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= n; j++)
			dp[i][j][0] = dp[i][j][1] = INF;
	}
	for (ll i = 1; i <= n; i++) {
		for (int j = 0; j <= min(i, m); j++) {
			dp[i][j][0] = min(dp[i - 1][j][0] + dis[c[i - 1]][c[i]], dp[i - 1][j][1] + dis[d[i - 1]][c[i]] * p[i - 1] + dis[c[i - 1]][c[i]] * (1 - p[i - 1]));
			if (j > 0) {
				dp[i][j][1] = dp[i - 1][j - 1][0] + dis[c[i - 1]][d[i]] * p[i] + dis[c[i - 1]][c[i]] * (1 - p[i]);
				if (j > 1) {
					dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j - 1][1] + dis[c[i - 1]][c[i]] * (1 - p[i - 1]) * (1 - p[i]) +
													                     dis[c[i - 1]][d[i]] * (1 - p[i - 1]) * p[i] +
														                 dis[d[i - 1]][c[i]] * p[i - 1] * (1 - p[i]) +
															             dis[d[i - 1]][d[i]] * p[i - 1] * p[i]);
				}
			}
		}
	}
}
int main() {
	n = read(), m = read(), v = read(), e = read();
	for (int i = 1; i <= n; i++)
		c[i] = read();
	for (int i = 1; i <= n; i++)
		d[i] = read();
	for (int i = 1; i <= n; i++)
		scanf("%lf", &p[i]);
	memset(dis, 0x3f, sizeof(dis));
	for (int i = 1; i <= e; i++) {
		ll u = read(), p = read(), w = read();
		dis[u][p] = dis[p][u] = min(w, dis[p][u]);
	}
	init();
	solve();
	dl ans = INF;
	for (int i = 0; i <= m; i++)
		ans = min(ans, min(dp[n][i][1], dp[n][i][0]));
	printf("%.2lf\n", ans);
//	for(int i=1;i<=n;i++){
//	for(int j=1;j<=i;j++){
//	cout<<"dhw "<<i<<' '<<j<<endl;
//	cout<<dp[i][j][0]<<' '<<dp[i][j][1]<<endl;
//	}
//	}
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

首先读进来的图肯定要处理，所以先使用 Floyd 算法求出全源最短路，记 $(i,j)$ 间的最短路为 $f_{i,j}$。然后你会发现这张图已经没有用了，因为我们知道了任意两点间的最短距离。

由于牛牛需要按照顺序依次完成课程，且第 $i-1$ 个课程教室到第 $i$ 个课程教室的距离仅和第 $i-1,i$ 个课程是否提出申请相关。因此考虑分类讨论第 $i-1$ 个课程和第 $i$ 个课程是否提出申请：
- 若第 $i$ 个课程不提出申请，第 $i-1$ 个课程不提出申请。则有 $1$ 的概率走长度为 $f_{c_{i-1},c_i}$ 的路径。
- 若第 $i$ 个课程不提出申请，第 $i-1$ 个课程提出申请。则有 $k_{i-1}$ 的概率走长度为 $f_{d_{i-1},c_i}$ 的路径，有 $1-k_{i-1}$ 的概率走长度为 $f_{c_{i-1},c_i}$ 的路径。
- 若第 $i$ 个课程提出申请，第 $i-1$ 个课程不提出申请。则有 $k_i$ 的概率走长度为 $f_{c_{i-1},d_i}$ 的路径，有 $1-k_i$ 的概率走长度为 $f_{c_{i-1},c_i}$ 的路径。
- 若第 $i$ 个课程提出申请，若第 $i-1$ 个课程提出申请。我们知道当 $A,B$ 两个事件独立时，$P(AB)=P(A)P(B)$。而第 $i$ 个课程申请是否通过和第 $i-1$ 个课程申请是否通过，显然是两个独立的事件。所以有 $k_{i-1}k_i$ 的概率走长度为 $f_{d_{i-1},d_i}$ 的路径，有 $k_{i-1}(1-k_i)$ 的概率走长度为 $f_{d_{i-1},c_i}$ 的路径，有 $(1-k_{i-1})k_i$ 的概率走长度为 $f_{c_{i-1},d_i}$ 的路径，有 $(1-k_{i-1})(1-k_i)$ 的概率走长度为 $f_{c_{i-1},c_i}$ 的路径。

我们知道期望为：可能的结果乘以结果概率的总和。所以每一种分类讨论方案的路径长度期望为：所以可能的路径乘以走该路径的概率的总和。

设 $g_{i,j,0/1}$ 表示上完第 $i$ 个课程，使用 $j$ 次申请，且第 $i$ 个课程没有提出或提出申请的期望。转移时，$g_{i,j,0}$ 为上述前 $2$ 个分类讨论方案的期望的较小值，$g_{i,j,1}$ 为上述后 $2$ 个分类讨论方案的期望的较小值，注意 $g_{i,j,0}$ 要从 $g_{i-1,j,0/1}$ 转移，而 $g_{i,j,1}$ 要从 $g_{i-1,j-1,0/1}$ 转移。转移方程实在是太长了就不列了，结合上面的分类讨论即可。

时间复杂度 $O(v^3+nm)$。

代码展示（由于转移式子太长换行写，可能有点难看）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v,e,a,b,w,c[2001],d[2001],f[301][301];
double k[2001],g[2001][2001][2],s=INT_MAX>>1;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m>>v>>e;
	for(int i=1;i<=v;i++){
		for(int j=1;j<=v;j++){
			f[i][j]=INT_MAX>>1;
		}
		f[i][i]=0;
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=n;i++){
		cin>>k[i];
	}
	while(e--){
		cin>>a>>b>>w;
		f[a][b]=f[b][a]=min(f[a][b],w);
	}
	for(int i=1;i<=v;i++){
		for(int j=1;j<=v;j++){
			for(int k=1;k<=v;k++){
				f[j][k]=min(f[j][k],f[j][i]+f[i][k]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			g[i][j][0]=g[i][j][1]=INT_MAX>>1;
		}
	}
	g[1][0][0]=g[1][1][1]=0;
	for(int i=2;i<=n;i++){
		for(int j=0;j<=m;j++){
			g[i][j][0]=min(g[i-1][j][0]+f[c[i-1]][c[i]]
                          ,g[i-1][j][1]+k[i-1]*f[d[i-1]][c[i]]+(1-k[i-1])*f[c[i-1]][c[i]]);
			if(j!=0){
				g[i][j][1]=min(g[i-1][j-1][0]+k[i]*f[c[i-1]][d[i]]+(1-k[i])*f[c[i-1]][c[i]]
                              ,g[i-1][j-1][1]+k[i-1]*k[i]*f[d[i-1]][d[i]]+k[i-1]*(1-k[i])*f[d[i-1]][c[i]]
                              +(1-k[i-1])*k[i]*f[c[i-1]][d[i]]+(1-k[i-1])*(1-k[i])*f[c[i-1]][c[i]]);
			}
		}
	}
	for(int i=0;i<=m;i++){
		s=min({s,g[n][i][0],g[n][i][1]});
	}
	cout<<fixed<<setprecision(2)<<s;
	return 0;
}
```

---

## 作者：Y_QWQ_Y (赞：0)

#### 闲话
虽然本文又臭又长还比较抽，但是认真看完转移方程及讨论过程应该不会没有收获。

#### 解题思路
数据范围这么小，首先考虑 dp。

我们可以令 $f_{i,j}$ 表示走过 $i$ 个教室，换了 $j$ 次教室。但是我们发现这样转移不了，因为我们不知道上一次有没有换，无法算概率。那么我们再加一维 $k$ 表示换不换第 $i$ 个教室。

#### 状态转移
我们先用 Floyd 算出多源最短路，记作 $dis_{i,j}$。然后大力分讨。

1. 不换第 $i$ 个教室。

   1. 上一次不换，那么直接从 $c_{i-1}$ 走到 $c_i$。

   2. 上一次换。
  
       1. 上一次换成功了，有 $k_{i-1}$ 的概率成功，换成从 $d_{i-1}$ 走到 $c_i$。

       2. 上一次换失败了，有 $(1-k_{i-1})$ 的概率失败，相当于不换。

2. 换第 $i$ 个教室。

    1. 上一次不换。
       1. 这一次换成功了，有 $k_{i}$ 的概率成功，换成从 $c_{i-1}$ 走到 $d_i$。

       2. 这一次换失败了，有 $(1-k_{i-1})$ 的概率失败，相当于不换，即从 $c_{i-1}$ 走到 $c_i$。
      
    2. 上一次换。
  
       1. 上一次换成功了，有 $k_{i-1}$ 的概率成功。
          
          1. 这一次换成功了，有 $k_i$ 的概率成功，共有 $k_{i-1}\times k_i$ 的概率换成从 $d_{i-1}$ 到 $d_i$。
             
          2. 这一次换失败了，有 $(1-k_i)$ 的概率失败，共有 $k_{i-1}\times(1-k_i)$ 的概率换成从 $d_{i-1}$ 到 $c_i$
       2. 上一次换失败了，有 $(1-k_{i-1})$ 的概率失败。
          1. 这一次换成功了，有 $k_i$ 的概率成功，共有 $(1-k_{i-1})\times k_i$ 的概率换成从 $c_{i-1}$ 到 $d_i$。
             
          3. 这一次换失败了，有 $(1-k_i)$ 的概率失败共有 $(1-k_{i-1})\times(1-k_i)$ 的概率换成从 $c_{i-1}$ 到 $c_i$。
         
1 和 2 对应 $f_{i,j,0}$ 和 $f_{i,j,1}$，每种情况下的两种情况是互斥的，每种情况下两种情况下的情况和可以并存的，乘上概率加和，把这每种情况下两种情况的和取较小值就完成转移了。

写成转移方程就是：

```cpp
f[i][j][0] = min (
    f[i - 1][j][0] +
        dis[c[i - 1]][c[i]], 
    f[i - 1][j][1] +
        (1 - k[i - 1]) * dis[c[i - 1]][c[i]] +
        k[i - 1] * dis[d[i - 1]][c[i]]);
f[i][j][1] = min (
    f[i - 1][j - 1][0] +
        (1 - k[i]) * dis[c[i - 1]][c[i]] +
        k[i] * dis[c[i - 1]][d[i]], 
    f[i - 1][j - 1][1] +
        k[i - 1] * k[i] * dis[d[i - 1]][d[i]] +
        (1 - k[i - 1]) * k[i] * dis[c[i - 1]][d[i]] +
        k[i - 1] * (1 - k[i]) * dis[d[i - 1]][c[i]] +
        (1 - k[i - 1]) * (1 - k[i]) * dis[c[i - 1]][c[i]]);
```

---

## 作者：abc1856896 (赞：0)

期望的题。

# Solution

由于题目涉及到计算图上任意两点距离，因此先弗洛伊德预处理任意两点之间的距离。

注意到关键字眼**期望**，考虑期望动规。

定义 $dp_{i,j,0/1}$ 表示前 $i$ 个课，换了 $j$ 次，当前这个换或者不换。

分类讨论。

若当前这节课不换，那么上一节课可以有三种情况（注：讨论上一节课是因为要确定距离。）：
1. 上节课不申请，在 $c_{i-1}$ 上课。对应 $dp_{i-1,j,0}+dis_{c_{i-1},c_i}$。
2. 上节课申请了，未通过，在 $c_{i-1}$ 上课。
3. 上节课申请了，通过了，在 $d_{i-1}$ 上课。

后两种情况是一个式子里的，因为两者都是**上节课申请了**。对应 $dp_{i-1,j,1}+dis_{d_{i-1},c_i} \times k_{i-1}+dis_{c_{i-1},c_i} \times (1-k_{i-1})$。

若当前这节课换，那么当前有两种情况：
1. 申请了，未通过，在 $c_{i}$ 上课。
2. 申请了，通过了，在 $d_{i}$ 上课。

上一节课的情况和这节课不换的情况一样。即不申请和申请了通过与未通过三种情况。总共有 $6$ 种情况，分两类计算（当前通过与未通过）即可。记得要乘上这一节课申请成功的概率。

最后，答案即为 $\min dp_{n,i,0/1}$，其中 $1 \le i \le m$。

# Code

注意本题有重边


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,v,e;
int c[2005],d[2005];
double k[2005];
int f[305][305];
double dp[2005][2005][2];
signed main(){ 
	cin>>n>>m>>v>>e;
	for(int i=1;i<=v;i++) {
		for(int j=1;j<=v;j++) {
			if(i!=j) f[i][j]=1e18;
		}
	}
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=n;i++) cin>>d[i];
	for(int i=1;i<=n;i++) cin>>k[i];
	for(int i=1;i<=e;i++) {
		int u,v,w;
		cin>>u>>v>>w;
		f[u][v]=f[v][u]=min(f[u][v],w);//有重边
	}
	/*下面是预处理*/
	for(int k=1;k<=v;k++) {
		for(int i=1;i<=v;i++) {
			for(int j=1;j<=v;j++) {
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=0;j<=m;j++) {
			dp[i][j][0]=dp[i][j][1]=1e18;	
		}
	}
	dp[1][0][0]=dp[1][1][1]=0;
	for(int i=2;i<=n;i++) {
		for(int j=0;j<=min(m,i);j++) {
			//这一节课不换
			dp[i][j][0]=min(dp[i-1][j][0]+f[c[i-1]][c[i]], /*上一节课不换*/
							dp[i-1][j][1]+f[d[i-1]][c[i]]*k[i-1] /*上一节课换，通过了*/
							+f[c[i-1]][c[i]]*(1-k[i-1])); /*上一节课换，没通过*/
			//这一节课换
			if(j) dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*k[i]+f[c[i-1]][c[i]]*(1-k[i]), /*上节课不换*/
				dp[i-1][j-1][1]+f[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+f[c[i-1]][d[i]]*(1-k[i-1])*k[i] /*上节课换，没过*/
				+f[d[i-1]][c[i]]*(1-k[i])*k[i-1]+f[d[i-1]][d[i]]*k[i-1]*k[i]); /*上节课换，过了*/
		}
	}
	double ans=1e18;
	for(int i=0;i<=m;i++){
		ans=min(dp[n][i][0],min(dp[n][i][1],ans));
	}	
	cout<<fixed<<setprecision(2)<<ans;
	return 0;
}
```

---

## 作者：Eterna (赞：0)

设 $l_{i,j}$ 为从 $i$ 到 $j$ 的最短路长度。$f_{i,j,0/1}$ 为前 $i$ 个课程已申请 $j$ 个课程，第 $i$ 个课程不选 $/$ 选的最小期望。

注意到 $v \le 300$，所以我们可以 floyd 算出全源最短路。

第 $i$ 次的移动显然只可能是从 $c_{i-1}$ 或 $d_{i-1}$ 移动到 $c_i$ 或 $d_i$。也就是说 $f_{i,j,0/1}$ 只与 $f_{i-1,j,0/1}$ 和 $f_{i-1,j-1,0/1}$ 有关。

计算 $f_{i,j,0}$，如果上一次没有申请。只有一种情况，显然期望为 $f_{i-1,j,0}+l_{c_{i-1},c_i}$。

如果上一次申请了，有两种情况，即上一次申请通过或不通过。发生概率分别为 $k_{i-1}$ 和 $(1-k_{i-1})$，贡献分别为 $f_{i-1,j,1}+l_{d_{i-1},c_i}$ 和 $f_{i-1,j,1}+l_{c_{i-1},c_i}$。按期望的定义乘一下就行。

计算 $f_{i,j,1}$，如果上一次没有申请。有两种情况，即本次申请通过或不通过，发生概率分别为 $k_{i}$ 和 $(1-k_{i})$，贡献分别为 $f_{i-1,j,0}+l_{c_{i-1},d_i}$ 和 $f_{i-1,j,0}+l_{c_{i-1},c_i}$。

如果上一次也申请了，有四种情况，即上一次申请通过或不通过，本次申请通过或不通过。发生概率分别为 $k_{i-1}k_{i},(1-k_{i-1})k_{i},(1-k_{i})k_{i-1},(1-k_{i-1})(1-k_{i})$，贡献分别为 $f_{i-1,j-1,1}+l_{d_{i-1},d_i},f_{i-1,j-1,1}+l_{c_{i-1},d_i},f_{i-1,j-1,1}+l_{d_{i-1},c_i},f_{i-1,j-1,1}+l_{c_{i-1},c_i}$。

时间复杂度 $O(v^3+n^2)$。

---

## 作者：_wkjzyc (赞：0)

https://www.luogu.org/problem/P1850

题意？太长懒得概括。

### 期望概述

期望，记为$E(x)$,是对于若干个概率事件，结果与概率之积的总和。

期望的数学意义是：对于一个结果均匀分布的事件，期望是无数次实验结果的平均值。

对于非均匀分布的事件，期望反映平均取值的大小。

掷骰tou子结果的平均数为3.5，这类问题说明非均匀分布事件的期望值可能不等于任何一个结果。

（以上为个人理解，可能有误，欢迎指正）

### 分析

Floyd求最短路略。

首先明确，对于一个要换教室的集合，直接计算期望值是很难的。当然，可以枚举所有子集再计算，可是。。会TLE。所以考虑用递推（动态规划）的方式计算答案。

当前教室与之前教室都不换，答案为确定的距离，直接得出

$cost=dis[c[i-1]][c[i]]$

在当前教室i选择更换的情况下，可能成功也可能失败，则期望值是

$cost=dis[c[i-1]][c[i]]*(1-k[i])+dis[c[i-1]][d[i]]*k[i]$

在前一个教室选择更换的情况下，相应地有

$cost=dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1-k[i])$

而如果前一个教室选择更换，也相应会有两种情况。由乘法原理可以得到四种情况，相加则是

$cost=dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])$

$+dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]$

$+dis[d[i-1]][c[i]]*(1-k[i])*k[i-1]$

$+dis[d[i-1]][d[i]]*k[i-1]*k[i]$

我们根据当前节点是否选择，将上述代价分为两组。根据题意，还有两维：当前教室和已经更换的教室数目。即

$f[i][j][k](k\in\{0,1\})$

表示第i个教室之前，更换了j个教室，是否更换第i个教室的最小期望代价。

综上所述，状态转移方程为

```cpp
f[i][j][0]=min(f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1]),f[i-1][j][0]+dis[c[i-1]][c[i]])

f[i][j][1]=min(f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1-k[i]),f[i-1][j-1][1]+dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+dis[d[i-1]][c[i]]*(1-k[i])*k[i-1]+dis[d[i-1]][d[i]]*k[i-1]*k[i])
//如果阅读不方便请看上文的LATEX
```

### 代码

~~惯例：仍然是抄的~~

```cpp
//注：本题的状态定义为浮点数，要注意数据类型的转换
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=2005,MAXV=305;
int n,m,v,e;
int c[MAXN],d[MAXN];
double ans=1e9,k[MAXN],f[MAXN][MAXN][2],dis[MAXV][MAXV];//dis为距离
int x,y,z;
int main()
{
	
	scanf("%d %d %d %d",&n,&m,&v,&e);
	for(int i=1;i<=v;i++)
		for(int j=1;j<=v;j++)
			dis[i][j]=1e9;
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	for(int i=1;i<=n;i++)
		scanf("%lf",&k[i]);
	for(int i=1;i<=e;i++)
	{
		scanf("%d %d %d",&x,&y,&z);
		dis[y][x]=min(dis[y][x],(double)z);
		dis[x][y]=min(dis[x][y],(double)z);//处理重边
	}
	
	for(int i=1;i<=v;i++)
		dis[i][i]=0;//处理自环
	for(int t=1;t<=v;t++)
		for(int i=1;i<=v;i++)
			for(int j=1;j<i;j++)
				if(dis[i][t]+dis[t][j]<dis[i][j])
					dis[i][j]=dis[j][i]=dis[i][t]+dis[t][j];//Floyd
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
			f[i][j][1]=f[i][j][0]=1e9;
	f[1][0][0]=f[1][1][1]=0;//初始化
	for(int i=2;i<=n;i++)
		for(int j=0;j<=m&&j<=i;j++)
		{
			f[i][j][0]=min(f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1]),f[i-1][j][0]+dis[c[i-1]][c[i]]);
			if(j)
			f[i][j][1]=min(f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1-k[i]),f[i-1][j-1][1]+dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+dis[d[i-1]][c[i]]*(1-k[i])*k[i-1]+dis[d[i-1]][d[i]]*k[i-1]*k[i]);
            //状态转移
		}
	for(int i=0;i<=m;i++)
		ans=min(min(ans,f[n][i][1]),f[n][i][0]);//答案更换的教室数目不确定
	printf("%.2lf",ans);
	return 0;
}
```

最后，祝大家身体健康，再见。

---


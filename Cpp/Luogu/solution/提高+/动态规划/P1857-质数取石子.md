# 质数取石子

## 题目描述

桌上有若干个石子，每次可以取质数个。谁先取不了，谁就输。问最少几步能赢？（一个人取一次算一步）假设双方都使用最优策略，且必胜方会尽量快地取胜，必败方会尽可能拖延步数。

## 说明/提示

石子数 $\leq 20000$，$N\leq 10$


## 样例 #1

### 输入

```
3
8
9
16```

### 输出

```
1
-1
3```

# 题解

## 作者：Polaris_Lorna (赞：22)

这题是**一道非常复杂的博弈论题**

首先 通过近似线性筛的筛法 预处理出所有的质数

我们设SG函数为此游戏胜负的状态 sg[i]=0为负 1为正 表示当石子数=i时，当前操作的人必败/胜

用一个队列对所有sg函数进行预处理 所有必败状态加上一个质数必然为必胜状态** 因为当石子数=必败状态的石子数+质数的时候，当前操作的人仅需取走这个质数的石子便可以获胜**

~~别以为知道这些就能A掉了~~

电脑不像你想象的那么沙雕 **每当电脑觉得他要输的时候 电脑会想方设法拖延你获胜的步伐 同理 当你要赢的时候 你总是想快一点胜利**

那么最重要的一点要来了

我们需要在适当的时候取**最大或最小值**

枚举所有位置和当前位置可扩展的位置，我们且令f[x]为石子数=x时的最小步数

如果扩展到的位置没被扩展过，那么当前位置就给他一个初始值=f[l]+1 如果！！！上一个状态为必胜状态并且当前状态为必胜状态，那么扩展了这个节点毫无意义，直接跳过这个点；

如果上一个扩展而来的状态是必胜状态，当前点却是必败状态，如果你是人，你怕判断这个吗？？？直接-1就可以了，关键是要考虑对手的感受，**对手不愿意让你输，他会竭尽所能找你麻烦，步数要取max啦**。如果上一个扩展而来的状态是必败状态，当前点却是必胜状态。

同样想一想，如果你是你的对手，你要赢了，你怕判断这个吗？？？直接-1掉了，但是你是你，**你要速战速决，你要用最少的步数解决~~这个无聊的游戏~~，所以在这里f去的是min**。到这里最关键的地方就结束了。

好了O(1)的查询 此题AC了（本人写了七个小时）蒟蒻勿喷


```cpp
#include <bits/stdc++.h>
#define maxn 20000
using namespace std;
int f[20010];
int prime[20010];
int pd[20010];
int q[1000010];
int sg[20010];
int hsh[20010]; 
int lose[100010];
int n,x,l,r,standard=0,cnt=0,last,losenum;
inline void build_prime()
{
    pd[1]=1;
    for (int i=2;i<=maxn;i++)
    {
        int j=i;
        if (pd[i]) continue;
        while (j<=maxn)
        {
            j+=i;
            pd[j]=1;
        }
    }
    for (int i=2;i<=maxn;i++)
    {
        if (!pd[i])
          prime[++cnt]=i;
    }
}
void prepare()
{
    while (l<=r)
    {
      for (int i=1;i<=cnt;i++)
      {
        int next=prime[i]+q[l];
        if(next>maxn) continue; 
        int last=q[l];
        if (!sg[q[l]])
          sg[next]=1;
      }
      if (l==r) {
            for (int i=last+1;i<=maxn;i++)
            {
                if (sg[i]==0)
                {
                    last=i;
                    lose[i]=1;
                    q[++r]=i;
                    break;
                }
            }
                 }
      l++;

    }
}
inline void dp()
{
    while (l<=maxn)
    {
        for (int i=1;i<=cnt;i++)
        {
            int next=prime[i]+l;
            int lasti=l;
            int num=f[l]+1;
            if (next>maxn) continue;
            if (sg[l]&&sg[next]) continue;
            if (!lose[next]&&lose[l])
            {
                if (!f[next]) f[next]=num;
                else f[next]=min(f[next],num);
            }
            if (lose[next]&!lose[l])
            {
                if (!f[next]) f[next]=num;
                else f[next]=max(f[next],num);
        }
        l++;
    }
}
int main()
{   
    memset(hsh,0,sizeof(hsh));
    memset(pd,0,sizeof(pd));
    build_prime();
    l=1;r=2;
    memset(q,0,sizeof(q));
    memset(sg,0,sizeof(sg));
    //sg[i]=1 win sg[i]=0 lose
    for (int i=1;i<=20009;i++)
    {
        f[i]=standard;
    }
    sg[0]=0;sg[1]=0;sg[2]=1;sg[3]=1;
    q[1]=0;q[2]=1;
    f[0]=0;f[1]=0;
    hsh[0]=1;hsh[1]=1;
    last=1;
    memset(lose,0,sizeof(lose));
    prepare();
    lose[1]=1;lose[0]=1;//其实lose数组没什么必要
    //就是sg函数为0的情况
    memset(q,0,sizeof(q));
    q[1]=0;q[2]=1;
    f[0]=0;f[1]=0;
    l=0;r=2;
    dp();
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>x;
        if (sg[x]==0) cout<< -1 <<endl;
        else cout<<f[x]<<endl;
    }
}
```

---

## 作者：O2人 (赞：11)

应该算是DP题，难度一般吧。

### 一、简化问题

**我们先假装这题只是让我们求解先手必胜还是必负**

我的思路是先用求出$vis[i]=0/1$（$vis[i]$表示当有i颗石子时，先手取石子是必胜还是必败）。

很简单：

```cpp
//P数组存储的是素数
for (int i=2;i<N;i++){
	bool flg=false;
	for (int j=1;j<=len&&i-P[j]>=0;j++) flg|=1-vis[i-P[j]];
   //只要接下来的对方面临的状态有一个是必败的，那么我们先手就是必胜的
	vis[i]=flg;
}
```

求出了这个我们就可以开心地求出-1的情况啦。

### 二、求解问题

接下来是求$F[i]$（$F[i]$表示当有$i$颗石子时，先手取石子需要几步能取完）

很显然的是，如果先手必胜，我们要尽量加快获胜，如果先手必败，我们要减缓失败！

所以可以得出转移方程：

```cpp
for (int j=1;j<=len&&i-P[j]>=0;j++)
if (vis[i]) F[i]=min(F[i],vis[i-P[j]]?1<<30:F[i-P[j]])+1;
       else F[i]=max(F[i],F[i-P[j]])+1;
```

**注意这里有一个细节，因为我们如果是必胜的，我们绝对不能往失败的方向走——我们不是傻子！所以当$vis[i]==1$时，答案只能从$vis[i-P[j]]==0$的$F[i-P[j]]$转移过来。**

样例可以检测出来这个问题，刚开始我傻了没注意，还好样例点醒我，使我一遍A了这题（要是比赛样例也这么给力就好了$QAQ$）。

全部代码：

```cpp
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;
inline int read(){
	int red=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
	while (ch>='0'&&ch<='9') red=(red<<3)+(red<<1)+ch-'0',ch=getchar();
	return red*f;
}
const int N=20005;
int F[N],P[N],len,T;
bool vis[N];
void Make(){
	for (int i=2;i<N;i++){
		if (!vis[i]) P[++len]=i;
		for (int j=1;j<=len&&i*P[j]<N;j++){
			vis[i*P[j]]=true;
			if (i%P[j]==0) break;
		}
	}
}
int main(){
	freopen("text.in","r",stdin);
	freopen("text.out","w",stdout);
	Make();
	for (int i=2;i<N;i++){
		bool flg=false;
		for (int j=1;j<=len&&i-P[j]>=0;j++) flg|=1-vis[i-P[j]];
		vis[i]=flg;
	}
	for (int i=2;i<N;i++){
		int res=vis[i]?(1<<30):-(1<<30);
		for (int j=1;j<=len&&i-P[j]>=0;j++)
		if (vis[i]) res=min(res,vis[i-P[j]]?1<<30:F[i-P[j]]);else res=max(res,F[i-P[j]]);
		F[i]=res+1;
	}
	T=read();
	while (T--){
		int x=read();
		if (!vis[x]) printf("-1\n");
		else printf("%d\n",F[x]);
	}
	return 0;
}
```


---

## 作者：B1GGersnow (赞：10)

~~其实这是一道水题~~

事实上这道题也不要用到什么高级博弈论的知识，了解PN图就可以了,以及筛选素数的方法

具体得来说就是
## 一个点不是必败点就是必胜点，这个需要明确
当然，这个不一定说适用所有的博弈，至少对这个题是适用的

## 必败点(P点) :前一个选手(Previous player)将取胜的位置称为必败点。

## 必胜点(N点) :下一个选手(Next player)将取胜的位置称为必胜点。

我们对于前面的一些点先找下面的规律

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| P | P | N | N | N | N | N | N | N | P |

其实很容易得出，当**i - prime[j]**是一个必败点的时候(prime[j]是小于等于i的某个质数)，那么i就是必胜点了(因为你取这一个质数，使对手落入这个必败点就可以必胜了)。

既然如此，我们很容易就可以知道哪些点是P点，哪些点是N点。

但是题目还有一问，就是要求出如果可以赢，那就要你求出怎么赢最快。

其实这一问也挺简单，只要记录一下。

**令f[i]表示第i位赢的最少步数**

如果是必败点，我们就让f[i] = -1

同时，我们记g[i]表示这个必败点最长失败的步数。。

为什么是最长呢？

### 我们感性得理解一下，你可以理解为既然我都输了，那就不能让后面来承接我的人好过，所以我得是尽量步数多一点 ~~(其实这有一个定理，但是我并不会证)~~

### 下面贴代码

~~~cpp
#include<cstdio>
#include<cstring>
#define N 20005
#define min(a,b) (a < b ? a : b)
#define max(a,b) (a > b ? a : b)
using namespace std;
int v[20005],prime[3000],p;
int f[20005],g[20005],n;
int read(){
	char c = getchar();
	while(c < '0' || '9' < c)
		c = getchar();
	int x = 0;
	while('0' <= c && c <= '9'){
		x = 10 * x + c - '0';
		c = getchar();
	}
	return x;
}

int main(){
	for(int i = 2;i <= N;i++){//线性筛选素数 
		if(!v[i]){
			v[i] = i;
			prime[++p] = i;
		}
		for(int j = 0;j <= p;j++){
			if(v[i] < prime[j] || prime[j] * i > N)
				break;
			v[i * prime[j]] = i;
		}
	}
	
	
	memset(f,-1,sizeof(f));//默认初始化都是必败点 
	g[0] = g[1] = 0;//必败态0,1移动最少步数为0,当然也可以不用写出来,为了标注一下 
	for(int i = 2;i <= N;i++){
		for(int j = p;j >= 1;j--){//枚举素数 
			if(prime[j] <= i){//不能够超出范围了 
				if(f[i - prime[j]] == -1){//前面某一个状态为必败态，则这个状态就是必胜态，并且需要记录最少胜利的次数
					if(f[i] == -1){
						f[i] = 0x3f3f3f3f;
					}
					f[i] = min(f[i],g[i - prime[j]] + 1);
				}
			}
		}
		if(f[i] == -1){//到这里如果还是-1,那么前面循环肯定没有更新过,如果这个点是必败点，那么就要算如何败是最快的
			for(int j = p;j >= 1;j--){
				if(prime[j] <= i && f[i - prime[j]] > 0){
					g[i] = max(g[i],f[i - prime[j]] + 1);//这里的max很讲究，你可以理解为既然我都输了，那就不能让后面来承接我的人好过，所以我得是尽量步数多一点 
				}
			}
		}
	}
	
	
	n = read();
	for(int i = 1;i <= n;i++){
		printf("%d\n",f[read()]);
	}
	return 0;
}
~~~

---

## 作者：bikuhiku (赞：4)

实际上由于 $n$ 不大，我们完全可以比较暴力的在线性筛的过程中求一遍，最后 $O(1)$ 查询。

根据我们的经验，在取石子游戏中，一个节点当且仅当有一个及以上的必败状态作为后继状态时，才会成为必胜状态。

我们首先可知 $0$ 和 $1$ 都是必败状态，标记上 $tag_0 = tag_1 = \texttt{false}$。

接下来根据游戏规则和必胜状态的判断条件，对于每个数 $i$，我们枚举每一个小于 $i$ 的质数 $p$，则：

$tag_i = \begin{cases}\texttt{true} & \exists p,tag_{i-p} = \texttt{false}\\\texttt{false} & \textrm{Otherwise.}\end{cases}$

于是就能求到每个点是必胜还是必败状态了。

接下来考虑步数。

我们设 $dp_i$ 表示 $i$ 作为必胜状态时最少需要花多少步结束游戏；或是 $i$ 作为必败状态时最多需要花多少步结束游戏。

对于每一个必胜状态 $i$：

$$dp_i = \min\limits_{p \in prime\And tag_{i-p} = \texttt{false}}^{i}\left\{dp_{i-p}+1\right\}$$

对于每一个必败状态 $i$：

$$dp_i = \max\limits_{p \in prime}^{i}\left\{dp_{i-p}+1\right\}$$

注意求必胜状态 $i$ 的 $dp_i$ 时要判断一下 $i-p$ 是否为必败状态，否则我们就把胜利拱手让给对方了。

代码：

```cpp
#include <iostream>
#include <cstring>
const int N = 20001;
int prime[N];
int minprime[N];
bool notprime[N];
int dp[N];
bool cdt[N];
void line() {
	memset(cdt,false,sizeof(cdt));
	for(register int i = 2, upd, mhp;i < N;++i) {
		if(!notprime[i]) {
			dp[i] = 1;
			cdt[i] = true;
			prime[++prime[0]] = i;
			minprime[i] = i;
		} else {
			dp[i] = 0x3f3f3f3f;
			for(register int *j = prime+prime[0];j != prime;--j) 
				if(!cdt[i-(*j)]) {
					if(dp[i-(*j)]+1 < dp[i]) 
						dp[i] = dp[i-(*j)]+1;
					cdt[i] = true;
				}
			if(!cdt[i]) {
				dp[i] = 0;
				for(register int *j = prime+prime[0];j != prime;--j) 
					if(dp[i-(*j)]+1 > dp[i]) 
						dp[i] = dp[i-(*j)]+1;
			}
		}
		if(i <= (N>>1)) {
			upd = std :: min(N/i,minprime[i]);
			for(register int *j = prime+1;*j&&*j <= upd;++j) {
				mhp = i*(*j);
				minprime[mhp] = *j;
				notprime[mhp] = true;
			}
		}
	}
}
int T;
int n;
int main() {
	line();
	scanf("%d",&T);
	for(int outs = 1;outs <= T;++outs) {
		scanf("%d",&n);
		if(cdt[n]) {
			printf("%d\n",dp[n]);
		} else 
			printf("-1\n");
	}
	return 0;
}
```

2022.09.23：在管理员的贴心提示下规范了公式书写。

---

## 作者：feilongz (赞：3)

DP题，f[i]表示取i位时能否必胜，则如减去素数f[i-a[j]]==0，就是说对方必败，则f[i]==1.

因为我比较傻逼，所以WA了十次。


/\*Yeah!!!

All Hail FZ!


                                
\_\_\_\_\_\_\_\_

                         |F Z   |               
\_\_\--\_\_|\_-----.

  II=======OOOOO[/ ★02 \_\_\_|           

\_\_\_\_\_\_\_\_\_\_\_|/-----.

/\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|

\◎◎◎◎◎◎◎◎⊙/

~~~~~~~~~~~~~~~~

             
             

              
\*/







    
    
    

    

    

          
         
            
             

         
               
               
       
            


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int f[100000],a[100],d[1000000];             //f[i]表示i位置能否必胜。必胜为1，必败为0；
                                             //d数组记录步数。a数组输入。 
int sushulist[10000]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,10193,10211,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10709,10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,11159,11161,11171,11173,11177,11197,11213,11239,11243,11251,11257,11261,11273,11279,11287,11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,11447,11467,11471,11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,11779,11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,11987,12007,12011,12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,12277,12281,12289,12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,12451,12457,12473,12479,12487,12491,12497,12503,12511,12517,12527,12539,12541,12547,12553,12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12973,12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,13417,13421,13441,13451,13457,13463,13469,13477,13487,13499,13513,13523,13537,13553,13567,13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,13709,13711,13721,13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,13997,13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,14303,14321,14323,14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,14563,14591,14593,14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,14741,14747,14753,14759,14767,14771,14779,14783,14797,14813,14821,14827,14831,14843,14851,14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15287,15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,15683,15727,15731,15733,15737,15739,15749,15761,15767,15773,15787,15791,15797,15803,15809,15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,15973,15991,16001,16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,16273,16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,16567,16573,16603,16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,16889,16901,16903,16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,17041,17047,17053,17077,17093,17099,17107,17117,17123,17137,17159,17167,17183,17189,17191,17203,17207,17209,17231,17239,17257,17291,17293,17299,17317,17321,17327,17333,17341,17351,17359,17377,17383,17387,17389,17393,17401,17417,17419,17431,17443,17449,17467,17471,17477,17483,17489,17491,17497,17509,17519,17539,17551,17569,17573,17579,17581,17597,17599,17609,17623,17627,17657,17659,17669,17681,17683,17707,17713,17729,17737,17747,17749,17761,17783,17789,17791,17807,17827,17837,17839,17851,17863,17881,17891,17903,17909,17911,17921,17923,17929,17939,17957,17959,17971,17977,17981,17987,17989,18013,18041,18043,18047,18049,18059,18061,18077,18089,18097,18119,18121,18127,18131,18133,18143,18149,18169,18181,18191,18199,18211,18217,18223,18229,18233,18251,18253,18257,18269,18287,18289,18301,18307,18311,18313,18329,18341,18353,18367,18371,18379,18397,18401,18413,18427,18433,18439,18443,18451,18457,18461,18481,18493,18503,18517,18521,18523,18539,18541,18553,18583,18587,18593,18617,18637,18661,18671,18679,18691,18701,18713,18719,18731,18743,18749,18757,18773,18787,18793,18797,18803,18839,18859,18869,18899,18911,18913,18917,18919,18947,18959,18973,18979,19001,19009,19013,19031,19037,19051,19069,19073,19079,19081,19087,19121,19139,19141,19157,19163,19181,19183,19207,19211,19213,19219,19231,19237,19249,19259,19267,19273,19289,19301,19309,19319,19333,19373,19379,19381,19387,19391,19403,19417,19421,19423,19427,19429,19433,19441,19447,19457,19463,19469,19471,19477,19483,19489,19501,19507,19531,19541,19543,19553,19559,19571,19577,19583,19597,19603,19609,19661,19681,19687,19697,19699,19709,19717,19727,19739,19751,19753,19759,19763,19777,19793,19801,19813,19819,19841,19843,19853,19861,19867,19889,19891,19913,19919,19927,19937,19949,19961,19963,19973,19979,19991,19993,19997};
//20000以下的素数表，只有2600个数字，为了节省效率在其他程序上写。 
int sushu[30001],step=1;
int min(int a,int b)                //最大最小，字面所见。 
{
    if(a<b)
      return a;
    return b;
}
int max(int a,int b)
{
    if(a>b)
      return a;
    return b;
}
int main()
{
//    freopen("game.in","r",stdin);
//    freopen("game.out","w",stdout);
    memset(d,0,sizeof(f));              //数组初始值0 
    int n;
    scanf("%d",&n);
    f[2]=1;                            //2,3的时候取一次为0，必胜。4是保险作用。 
    f[3]=1;
    f[4]=1;
    int maxx=-1;
    for(int i=1;i<=n;++i)
    {
      scanf("%d",&a[i]);                 //读入。 
    }
  for(int len=1;len<=n;++len)                 //枚举每个读入 
  {
    for(int i=2;i<=a[len];++i)
      for(int j=0;j<=2261;++j)                      //此处我不小心掉了坑。数组sushulist实际上初始值是从0开始定义的。
                                                   //然而我写了从1枚举素数表。直接导致8次提交错误。 
      {
          if(sushulist[j]>i)
            break;
            if(f[i-sushulist[j]]==0)                  //DP，如果减去一个素数使得对方“必败”，则自己必胜，f为1 
            {
              f[i]=1;
              break;                                 //无需所有策略都必胜。 
          }
    }
   for(int i=2;i<=a[len];++i)
          {
         for(int j=0;j<=2261;++j)
           if(i<sushulist[j]) 
               break;
         else 
         if(f[i]&&!f[i-sushulist[j]])                            //这里根据网上是（原谅我）“因为 必败 所以 对方会用最快取胜策略，所以取min 
                                                                //同理必胜则对方会不断捣乱，那么取max 
             {
              if(d[i]==0) 
                  d[i]=d[i-sushulist[j]]+1;
                else 
              d[i]=min(d[i],d[i-sushulist[j]]+1);
           }
         else 
         if(!f[i]&&f[i-sushulist[j]])                        
         { 
           if(d[i]==0) 
           d[i]=d[i-sushulist[j]]+1;
           else   
            d[i]=max(d[i],d[i-sushulist[j]]+1);
             }
           } 
            if(f[a[len]]==0) {
            cout<<-1<<endl;
            continue;
            }                  //总结，必败输出-1 后con掉 
       cout<<d[a[len]]<<endl;                                            //反之输出步数 
}
```

---

## 作者：fxwqctb (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1857)  
这是一道比较水的蓝题，本人认为大概只有绿的水平。  
# 一、思路
### 1、只有先手和后手必胜的情况
首先先只考虑先手胜还是后手胜的情况。    
这道题是一道较为复杂的博弈论，由于每次可以取若干质数个石子，所以我们可以跑一遍线性筛，筛出 $20000$ 以内的所有质数。  

定义一个数组 $F$，当 $F_i=1$ 时代表先手必胜，否则为后手必胜。  
由于最小的质数为 $2$，所以 $F_0=F_1=1$，对于 $i\ge2$ 的情况，就要枚举一个质数 $j$，且保证 $i\ge j$，那么可以取一次，让石子个数为 $i-j$，如果取完一次石子后是后手必胜的情况，那么这个局面一定是先手必胜，如果无论如何取都是先手必胜的情况，则这个局面必定是先手必败的情况。  
所以我们可以跑遍 dp，就能算出所有后手必胜的情况。

### 2、考虑步数
步数是这一题的难点，必败方会拖延步数，必胜方会让步数尽量小。  
我们定义一个数组 $D$，代表步数，对于某个石子数 $i$，如果 $F_i=1$，则 $D_i$ 肯定要小，反之则要最大，定义变量 $min1$ 来记录最小，$max1$ 来记录最大，然后枚举质数 $j(j\le i)$，如果 $F_{i-j}=1$ 则更新最小值，否则更新最大值，最后判断一下结果，如果 $F_i=1$ 则 $D_i=min1+1$，否则 $D_i=max1+1$。

# 二、AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[20010],h[10000],f[20010],cnt=0,k[20010];
void ss(int n)//线性筛模板
{
	memset(a,1,sizeof(a));
	a[1]=0;
	for(int i=2;i<=n;i++)
	{
		if(a[i])h[++cnt]=i;
		for(int j=1;j<=cnt&&i*h[j]<=n;j++)
		{
			a[i*h[j]]=0;
			if(i%h[j]==0)break;
		}
	}
}
int main()
{
	ss(20000);
	f[0]=f[1]=-1;//初始化 F
	for(int i=2;i<=20000;i++)
	{
		int s=-1,c=0,d=99999;//c 为最小值，d 为最大值
		for(int j=1;j<=6000;j++)
		{
			if(i>=h[j]&&f[i-h[j]]==-1){s=1;d=min(d,k[i-h[j]]+1);}//最小值更新
			else if(i>=h[j]&&f[i-h[j]]!=-1)c=max(c,k[i-h[j]]+1);//最大值更新
		}
		f[i]=s;
		if(s==-1)k[i]=c;
		else k[i]=d;
	}
	int t;
	cin>>t;
	while(t--)
	{
		int e;
		cin>>e;
		if(f[e]==1)cout<<k[e]<<'\n';
		else cout<<f[e]<<'\n';
	}
	return 0;
}
```

---

## 作者：tyukp233 (赞：2)

很简单的蓝题。

这道题是**动态规划**的题目。

首先，该题只存在 必赢 和 必输 状态。

显然，如果一方所能到达的状态都是 必赢 的，那么该状态为 必输；否则可以进入 必输 状态，而此时该状态为 必赢。

状态转移对象就通过遍历小于当前数量的质数来实现，具体见代码。

处理步数时，由题意易知：对于 必胜 和 必输 状态，分别取 上一状态步数 的最小值和最大值即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t;
int ans[20005];
bool h[20005];
vector<int> p;

//埃氏筛
void get_prime() {
    for(int i=2; i<=20000; i++) {
        if(h[i])continue;
        p.push_back(i);
        for(int j=i; j<=20000; j+=i) h[j]=1;
    }
}

//主体
void solve() {
    memset(ans,0x3f,sizeof ans);
    ans[0]=ans[1]=-1;//下界
    for(int i=2; i<=20000; i++) {
        int maxm=0;
        for(auto j:p) {
            if(j>i)break;
            if(ans[i-j]<0) {
                ans[i]=min(ans[i],-ans[i-j]);
            } else {
                maxm=max(maxm,ans[i-j]);
            }
        }
        //没有被更新
        if(ans[i]==0x3f3f3f3f) {
            ans[i]=-maxm-2;
            //maxm=1 时 ans[i]= -3 以此类推
            //这样就对应到下个状态的相反数上
        }
    }
}

int main() {
    get_prime();
    solve();
    cin>>t;
    while(t--) {
        cin>>n;
        cout<<(ans[n]<0?-1:ans[n])<<"\n";
        //ans[n]为负值都表示必输，输出-1
    }
}

```


---

## 作者：违规用户名^3Zj=Oha (赞：2)

## 一、题目简述
桌上有若干个石子，每次可以取质数个。谁先取不了，谁就输。问最少几步能赢？

## 二、思路分析
接下来是求 $F[i]$ 表示当有 $i$ 颗石子时，先手取石子需要几步能取完

很显然的是，如果先手必胜，我们要尽量加快获胜，如果先手必败，我们要减缓失败！

注意这里有一个细节，因为我们如果是必胜的，我们绝对不能往失败的方向走——我们不是傻子！所以当 $vis[i] = 1$ 时，答案只能从 $vis[i-P[j]] = 0$ 的  $F[i-P[j]]$ 转移过来。


## 三、构造代码

```
#include<bits/stdc++.h>
using namespace std;
bool pr[1000000];
long long vis1[1000000],f1[1000000],vis2[1000000],f2[1000000],pri[1000000],ll;
long long dp1(int n);
long long dp2(int n){//递归调用dp
    if(vis2[n]) return f2[n];
    vis2[n]=1;
    for(int i=0;pri[i]<=n;i++) f2[n]=max(f2[n],1+dp1(n-pri[i]));//dp
    return f2[n];
}
long long dp1(int n){//递归调用dp
    if(vis1[n]) return f1[n];
    vis1[n]=1;
    for(int i=0;pri[i]<=n;i++) f1[n]=min(f1[n],1+dp2(n-pri[i]));//dp
    return f1[n];
}
int main(){
    vis1[0]=vis1[1]=1;
    vis2[0]=vis2[1]=1;
    f2[0]=0;
    f2[1]=0;
    for(int i=0;i<=20000;i++) f1[i]=1000000000;//初始化
    for(long long i=2;i<=20000;i++){
        if(pr[i]==0){
            vis1[i]=1;
            f1[i]=1;
            vis2[i]=1;
            f2[i]=1000000000;
            pri[ll++]=i;//预操作
            for(long long j=i*i;j<=20000;j+=i) pr[j]=1;
        }
    }
    int a;
    scanf("%d",&a);
    for(int i=0;i<a;i++){
        int n;
        scanf("%d",&n);
        printf("%lld\n",dp1(n)>=1000000000?-1:dp1(n));//输出
    }
    return 0; 
}
```

---

## 作者：cwfxlh (赞：1)

# P1857
## [题目传送门](https://www.luogu.com.cn/problem/P1857)   
## 题意简述
题面很清晰，就不复述了，那么我们直接开始分析题目。  
## 题目分析
题面要求，每次取掉的数都是质数，那么我们先不想什么，写一个质数筛。因为我懒，所以写了个暴力遍历判断的筛，当然也可以写欧拉筛。
```cpp
for(int i=2;i<=20000;i++)
{
	tot++;
	p[tot]=i;//p是素数列表
	for(int j=2;j*j<=i;j++)
	{
		if(i%j==0)
		{
			tot--;
			break;
		}
	}
}
```
那么接下来，我们再看一下题，很明显，这道题应该要把每个 $Q_i$ 的答案给预处理出来。那么对于每一个数，它最重要的性质就是在该点时先手是否必赢。  
如果一个值先手必赢，也就意味着它可以通过取掉一堆石子后，让后一个人面对剩余的局势时必输，而必赢的最小步数就是在对面必输的所有可能中，对面可以拖延的所有最长步数取 $\min$（有点绕，建议多读反复理解，因为这挺关键的）。  
必然地，我们也要考虑必输性质。对于每一个值取先手，如果无论怎么取，下一个人都是必赢，那这个人就必输了。而必输情况下的最大可拖延步数，就是所有取法中对面最短步数的 $\max$。  
到这里，我们就可以写代码了，对每一个值维护两个 $dp$ 值，一个是必输最大步数，一个是必赢最小步数，如果不必输或不必赢，就放个 $-1$ 进去。  
初始化时把 $0$ 和 $1$ 手打上去，再 $dp$ 就可以了。   
没了，上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int lose[200003],win[200003],n,x,tot,p[200003];
int main()
{
	for(int i=2;i<=20000;i++)
	{
		tot++;
		p[tot]=i;
		for(int j=2;j*j<=i;j++)
		{
			if(i%j==0)
			{
				tot--;
				break;
			}
		}
	}
	lose[0]=0;
	win[0]=-1;
	lose[1]=0;
	win[1]=-1;
	for(int i=2;i<=20000;i++)
	{
		for(int j=1;j<=tot&&p[j]<=i;j++)
		{
			if(win[i-p[j]]==-1)
			{
				lose[i]=-1;
				break;
			}
			lose[i]=max(lose[i],win[i-p[j]]+1);
		}
		win[i]=-1;
		for(int j=1;j<=tot&&p[j]<=i;j++)
		{
			if(lose[i-p[j]]!=-1)
			{
				win[i]=214748364;
				break;
			}
		}
		if(win[i]==214748364)
		{
			for(int j=1;j<=tot&&p[j]<=i;j++)
			{
				if(lose[i-p[j]]!=-1)
				{
					win[i]=min(win[i],lose[i-p[j]]+1);
				}
			}
		}
	}
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&x);
		printf("%d\n",win[x]);
	}
	return 0;
}
```


---

## 作者：Exiler (赞：1)

## 原题

[P1857 质数取石子](https://www.luogu.com.cn/problem/P1857)

---

## 思路概述

### 题意分析

给定 $n$ 个石子，先后手轮流取 $x(x∈prime)$ 个石子，最先取不了的一方失败。求先手方是否有必胜策略，如果有，输出步数（遵循必胜方尽快取胜，必败方尽可能拖延步数的策略）。

### 思路分析

由题意可知，本题是一道博弈论+动态规划算法的题。只需要打表推出 $n$ 的胜负态 $f(n)$ 就能知道先手方是否有必胜策略，再通过一定规律分析出必胜、必败方的最优策略即可求解。

由于本题每次取的石子数为质数，所以需先用线性筛法找出给定范围内的所有质数。关于质数线性筛，笔者不多作冗述，有需要可前往：

[P3383 【模板】线性筛素数 题解](https://www.luogu.com.cn/problem/solution/P3383)

---

## 算法推导

### 关于胜负态

虽然本题与博弈论有一定关系，但没有系统学习过博弈论（没错就是我）也没有太大影响，只需要对博弈游戏中的必胜/必败态有一定认识即可。

对于一个博弈游戏的任意状态（本题中表示为一元函数 $f(n)$ ）必然属于两类：若当前的先手方无论采用何种策略，都必然失败的状态称为必败态；反之，若先手方采用适当策略，必定能使对方处于必败态的状态称为必胜态。

由胜负态的基本定义可以得出胜负态的转移方程。我们定义博弈游戏的当前状态为 $f(n)$ （状态可以是一元函数，也可以是多元函数），当前状态的所有前驱状态（前驱状态不一定唯一）为 $pre_x=\{a_1,a_2...a_n \}$ （特别地，题目预设的游戏结束条件没有前驱状态），同时定义胜态函数值为 $1$ ，必败态函数值为 $0$ 。那么易得转移方程（假设边界条件是必败态）：

$$f(x)=\begin{cases}1,∃i∈pre_x\text{ and }f(i)=0\\0,\text{otherwise}\end{cases}$$

### 关于动态规划

* 有了胜负态转移方程，就可以推导出本题的转移方程。在递推前，先用线性筛选出既定范围内的所有质数$prime$。转移方程如下：

$$f(x)=\begin{cases}1,∃i=x-prime_j(j∈N^*,i∈N)\text{ and }f(i)=0\\0,\text{otherwise} \end{cases}$$

### 关于路径长度计数

由于题目不仅要求输出当前胜负态，并且当此时为必胜态时，还要输出最少步数（满足必胜方尽快取胜必败方尽量拖延的原则）。这就要求在DP过程中还要附带处理关于步数的问题。

由上述转移方程可以知道状态之间的关系可以用一个有向无环图来描述，即两个状态可以由一条有向边链接，而状态的转移就是有向边上的移动。由上述推导就能将尽快取胜/尽量拖延的策略转化为求当前状态对应节点到源节点（ $x=0,1$ ）的最短/最长路径走法。并且对于图中的任意节点都存在唯一的最长与最短路径的前驱。因此，我们只需要在每一个新状态进入考虑中的时候更新其最长路径前驱或最短路径前驱，在询问过程中模拟双方按最优策略轮流取石子的过程即可。

由于一个状态 $f(x)$ 的胜负是一定的，所以对于一个必胜态，无论谁取石子，都遵循尽快取胜的原则，反之亦然。因此，对于一个必胜态，就记录其最短路径前驱；反之，则记录其最长路径前驱。详细过程见代码。

---

## AC code
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<set>
#include<ctime>
#define RI register int
using namespace std;
const int maxn=2e4+10;
typedef struct
{
	bool ptw;
	int cnx,cni,prx,pri;
	inline void init(int x)
	{
		ptw=0;cnx=-1;cni=0x3f3f3f3f;prx=pri=-1;
		return;
	}
}node;
node e[maxn];
int T,n,rmx,cnt,ans;
int gtn[11],p[maxn],v[maxn];
bool sit;
inline int read();
inline void print(int x);
inline void gtp(int x);/*质数线性筛*/
inline void init(int x);/*预处理状态*/
int main()
{
	T=read();
	for(RI i=T;i>=1;--i) rmx=max(rmx,gtn[i]=read());
	/*由题目性质可知 不需要打出[1,20000]中的所有状态 只需要打出最大数据之前的所有状态即可*/
	gtp(rmx);init(rmx);
	for(;T;--T)
	{
		n=gtn[T];ans=0;
		if(!e[n].ptw) puts("-1");/*必败态*/ 
		else
		{
			sit=1;/*用变量sit来模拟当前是必胜或必败方操作*/
			for(RI i=n;i>1;i=sit?e[i].prx:e[i].pri)
			{
				++ans;
				sit^=1;/*当前方操作完毕 换对方操作*/
			}
			print(ans);putchar('\n');
		}	
	}
	return 0;
}
inline int read(void)
{
	char putin;bool isneg=false;RI ret=0;
	putin=getchar();
	while((putin>'9' || putin<'0') && putin!='-')
		putin=getchar();
	if(putin=='-')
	{
		isneg=true;
		putin=getchar();
	}
	while(putin>='0' && putin<='9')
	{
		ret=(ret<<3)+(ret<<1)+(putin&15);
		putin=getchar();
	}
	return isneg?-ret:ret;
}
inline void print(int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9) print(x/10);
	putchar(x%10+'0');
	return;
}
inline void gtp(int x)
{
	memset(v,0,sizeof(v));cnt=0;
	for(RI i=2;i<=x;++i)
	{
		if(!v[i])
		{
			p[++cnt]=i;
			v[i]=i;
		}
		for(RI j=1;j<=cnt && i*p[j]<=x;++j)
			if(p[j]>v[i]) break;
			else v[i*p[j]]=p[j];
	}
	return;
}
inline void init(int x)
{
	for(RI i=1;i<=x;++i) e[i].init(i);
	e[0]=e[1]=(node){0,0,0,0,0}; 
	for(RI i=0;i+2<=x;++i)
		for(RI j=1;j<=cnt && i+p[j]<=x;++j)
		{
			e[i+p[j]].ptw|=(e[i].ptw^1);
			if(e[i].ptw && e[i+p[j]].cnx<e[i].cni+1)/*必胜态 更新最短路径前驱*/
			{
				e[i+p[j]].cnx=e[i].cni+1;
				e[i+p[j]].prx=i;
			}
			else if(!e[i].ptw && e[i+p[j]].cni>e[i].cnx+1)/*必败态 更新最长路径前驱*/
			{
				e[i+p[j]].cni=e[i].cnx+1;
				e[i+p[j]].pri=i;
			}	
		}		
	return;
}
```


## Update

### 2022.11.18

修复了必胜态与必败态推导部分的表述问题。

---

## 作者：a1035719430 (赞：1)

第一次写题解 作为一只小蒟蒻 有点小激动。这道题是一个博弈论的题目，对于一个步数i，若减去小于i的任意质数后都为必胜情况，则为必负，若减去一个质数后为必负，则为必胜。

一开始质数用了打表....然后10个WA 提交了10多次 很难受...

f[i]存储的若为正数 为i步获胜需要的最少步数 若为负数 则为对方获胜需要的最少步数（为区分前面输的情况加了负号）。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x=1,Min,Max=0; 
int f[30010]={0},a[20],b[20],zhishu[10000],p[21000]={0}; 
inline void work()
{
 f[0]=0; 
 f[1]=0;
 for(int i=2;i<=b[n];++i)
  {
   if(x>n) break;   //如果要输出的数据都输出完了 跳出循环 
   Min=200000;Max=0;
   for(int j=i;j>1;--j)    
     if(!(p[j]))  //如果j是质数 
      {  
        if(f[i-j]<=0) {if(Min>(1-f[i-j])) Min=1-f[i-j];}    //拿去该石子对方为必输取最小 
          else if(f[i-j]+1>Max)  Max=f[i-j]+1;  //拿去该石子对方为必胜取最大 
      }
   if(Min!=200000) f[i]=Min; //判断 
   else f[i]=-Max;
  }
 return;
}
inline void init()
{
 scanf("%d",&n); 
 for(int i=1;i<=n;++i)
  scanf("%d",&a[i]);
 for(int i=1;i<=n;++i)
  b[i]=a[i];
 sort(b+1,b+n+1);//其实就是为了循环的时候找到最大值  一开始失了智 后面就懒得改了 
 return;
}
inline void first()//筛法，0表示质数，1表示合数 
{
    for(int i=2;i<=20000;++i)
    if(p[i]==0)
    {
        zhishu[++Max]=i;
        for(int j=i+i;j<=20000;j+=i)p[j]=1;
    }
    return;
}
inline void print()
{
 for(int i=1;i<=n;++i)
  if(f[a[i]]>0)printf("%d\n",f[a[i]]);  
   else printf("-1\n");  //如果负输出-1 
}
int main()
{ 
 first();//筛法求质数 
 init();//输入 
 work();//最主干的部分 
 print(); //输出 
 return 0;
}
```

---

## 作者：suyi1111 (赞：0)

非常简单的 $sg$ 函数基础题。

看到质数，先写上反正待会儿会用到的埃氏筛。~~（别问我为什么不用线性筛，问就是不会）。~~
```
int pr[20001],prlen=0;
bool ispr[20001];
void init(){
	for(int i=2;i<=20000;i++){
		ispr[i]=1;
	}
	for(int i=2;i<=20000;i++){
		if(ispr[i]){
			prlen++,pr[prlen]=i;
			for(int j=i*i;j<=20000;j+=i){
				ispr[j]=0;
			}
		}
	}
} 
```
接下来处理 $sg$ 函数。思路就是每个 $sg$ 函数有两个取值，一个表示能不能赢，另一个表示还要几步才能赢/输。赢要取最大值，输要取最小值。

```
struct the_sg_hanshu{
	bool sy;//输赢
	int bs;//步数 
}sg[20001];
void sghs(){
	sg[0].sy=0,sg[1].sy=0,sg[0].bs=0,sg[1].bs=0;//初始化 
	for(int i=2;i<=20000;i++){
		bool sfny=0;//是否能赢 
		for(int j=1;j<=prlen;j++){
			if(pr[j]>i){//这个质数比i大
				continue;//直接跳过 
			}
			if(sg[i-pr[j]].sy==0){//可以让对方输
				sfny=1; 
			} 
		}
		if(sfny){//能赢 
			sg[i].sy=1;
			int mi=0x7fffffff;
			for(int j=1;j<=prlen;j++){
				if(pr[j]>i){
					continue;
				}
				if(sg[i-pr[j]].sy==0){//我们需要最小的步数赢 
					mi=min(mi,sg[i-pr[j]].bs); 
				} 
			} 
			sg[i].bs=mi+1;//因为自己还要走一步，所以+1 
		}else{//输了 
			sg[i].sy=0;
			int ma=0;
			for(int j=1;j<=prlen;j++){
				if(pr[j]>i){
					continue;
				}
				//我们需要最大的步数输掉 
				ma=max(ma,sg[i-pr[j]].bs); 
			}
			sg[i].bs=ma+1;//因为自己还要走一步，所以+1 
		}
	}
}
```
~~附：把代码打完发现字数统计：1145 字符，恶臭的数字~~

最后，主函数：
```
int T,n;
int main(){
	init();
	sghs();
	cin>>T;
	while(T --> 0){
		cin>>n;
		if(sg[n].sy==0){
			cout<<-1;
		}else{
			cout<<sg[n].bs;
		}
		cout<<endl;
	}
	return 0;
}
```
然后，你就成功[A了](https://www.luogu.com.cn/record/185123835)一道蓝题了。

---

## 作者：OIer_ACMer (赞：0)

~~这个游戏蛮好玩嘛！~~

------------
注：本题思路比较简单，因此笔者不会过多赘述原理以及证明，望周知！

------------
## 大致思路：
本题一拿到题面，经典博弈论问题，先手必胜还是先手必败，除此之外，有一个问题即**必胜方会尽量快地取胜，必败方会尽可能拖延步数**。所以我们可以采取两个数组分别记录自己和对手的状态，状态石子数，存的是取石子的次数

先考虑必胜和必败的两种状态。如果**该状态上一状态存在一个必败状态，则该状态必胜，反之必败**。

所以问题就简单了，对于自己而言，**如果该状态必胜，则取石子的个数是上一状态（可以理解为对手必胜状态）的取个最小，然后加 $1$ 即可**。这个转移方程便很容易推出：

$f_i = \min(f_i, dp_{i-prime_j}+1)$（作为赢家一定要更少步数，所以用 $\min$ 来计算）。

如果该状态必败，则**等于是对手必胜状态**，那么，上一状态即是自己的必胜状态，取个最大加 $1$ 即可。这个时候要维护的是对手的状态，转移方程如下：

$dp_i = \max(dp_i,f_{i-prime_j} + 1)$（作为败家一定要更多步数，所以用 $\max$ 来计算）。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int mod = 1e9 + 7;
const int M = 1e8;
const int N = 4e6 + 5;
int prime[N], v[N];
int n, f[N], m, dp[N];
void Prime()
{
    for (int i = 2; i <= 2e4; i++)
    {
        if (!v[i])
        {
            v[i] = i, prime[++m] = i;
        }
        for (int j = 1; j <= m; j++)
        {
            if (prime[j] * i > 2e4 || prime[j] > v[i])
            {
                break;
            }
            v[i * prime[j]] = prime[j];
        }
    }
}
void init()
{
    Prime();
    memset(f, -1, sizeof(f));
    for (int i = 2; i <= 2e4; i++)
    {
        for (int j = m; j >= 1; j--)
        {
            if (i - prime[j] >= 0)
            {
                if (f[i - prime[j]] == -1)
                {
                    if (f[i] == -1)
                        f[i] = 1e18;
                    f[i] = min(f[i], dp[i - prime[j]] + 1);
                }
            }
        }
        if (f[i] == -1)
        {
            for (int j = m; j >= 1; j--)
            {
                if (i - prime[j] >= 0)
                {
                    if (f[i - prime[j]] != -1)
                    {
                        dp[i] = max(dp[i], f[i - prime[j]] + 1);
                    }
                }
            }
        }
    }
}
void solve()
{
    int n;
    n = read();
    cout << f[n] << endl;
}
int main()
{
    init();
    int T = 1;
    T = read();
    while (T--)
    {
        solve();
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122816435)

---

## 作者：Φρανκ (赞：0)

题意：从 $m$ 枚石子中依次取石子，求若先手有必胜策略在后手尽可能拖延的情况下至少需几步胜利。

核心思想：递推

解：

首先筛出质数。令 $f(i)$ 表示有必胜策略一方在另一方尽可能拖延的情况下所需最少胜利步数。则有 $f(0)=f(1)=0$，继而 $\forall\:i=p$ 或 $p+1$ 时 $f(i)=1$。

$\forall\:i$ 若存在 $0\le j<i$ 满足 $2|f(j)$ 且 $i-j\in\mathbb{P}$，即可以取石子使得后手（此时的先手）必败，则 $f(i)$ 应为所有 $f(j)+1$ 中最小者。若不存在则说明先手必败，此时应取所有满足 $i-j\in\mathbb{P}$ 的 $j$ 中使 $f(j)+1$ 最大者。

输入询问并输出即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a[11], b[20001], p[20001], flag, s[20001], q;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=2; i<=20000; i++)
	{
	    if(b[i]==0)
	      p[++flag]=i;
	    for(int j=1; j<=flag; j++)
		{
	      if(i*p[j]>20000) 
		  	break;
	      b[i*p[j]]=1;
	      if(i%p[j]==0)
	        break;
		}
    }
    b[1]=1;//筛质数
    for(int i=2; i<=20000; i++)
    {
    	if(b[i]==0 || b[i-1]==0)
    		s[i]=1;
    	else
	    	for(int j=0; j<i; j++)
	    		if(b[i-j]==0)
	    		{
	    			if(s[j]%2==0)
	    				if(s[i]%2==0)
	    					s[i]=s[j]+1;
	    				else
	    					s[i]=min(s[i], s[j]+1);
	    			if(s[j]%2==1 && s[i]%2==0)
	    				s[i]=max(s[i], s[j]+1);
				}//计算f
	}
	for(int i=1; i<=n; i++)
	{
		if(s[a[i]]%2==1)
			cout<<s[a[i]]<<endl;
		else
			cout<<-1<<endl;//输入输出
	}
	return 0;
}
```

---

## 作者：VinstaG173 (赞：0)

为什么我直接每次询问中调用 `dfs(n)` 会 WA 啊。。。

首先筛出所有质数。

然后我们考虑对于 $n$ 的操作情况。显然设所有质数为 $p_1<p_2<\dots$，$n$ 的后继状态为 $n-p_i$。

我们只要考虑 $n$ 的胜负情况。如果 $n$ 必胜，那么先手必须操作到必败后继状态上，想要尽快结束，对这些状态的步数求 $\min$ 后再加 $1$ 就能得到最少步数。

如果 $n$ 必败，那么先手想要尽量拖延时间，所以只要对后继状态的步数求 $\max$ 后再加 $1$ 就得到最多步数。

直接转移，对所有数处理一遍再 $O(1)$ 回答询问是 $O\left(\dfrac{n^2}{\log{n}}\right)+t$ 的，可以通过。

Code:
```cpp
#include<cstdio>
#define rg register
int mp[20033];
int pr[20033],cnt;
inline void init()
{
	for(rg int i=2;i<20030;++i)
	{
		if(!mp[i])pr[mp[i]=++cnt]=i;
		for(rg int j=1;j<=mp[i]&&(i*pr[j]<20030);++j)mp[i*pr[j]]=j;
	}
}
int win[20003];
int tmp[20003];
int step[20003];
void dfs(int x)
{
	if(x<=1)
	{
		win[x]=-1;
		step[x]=0;
		return;
	}
	win[x]=-1,step[x]=1;
	for(rg int i=1;pr[i]<=x;++i)
	{
		if(win[x-pr[i]]==-1)win[x]=1;
		tmp[i]=win[x-pr[i]]*step[x-pr[i]];
	}
	int mx=(~win[x])?-20003:0;
	for(rg int i=1;pr[i]<=x;++i)
	{
		if(tmp[i]*win[x]>0)continue;
		if(tmp[i]>mx)mx=tmp[i];
	}
	step[x]-=mx*win[x];
}
int t,n;
int main()
{
	init();
	scanf(" %d",&t);
	for(rg int i=0;i<=20000;++i)dfs(i);
	while(t--)
	{
		scanf(" %d",&n);
		printf("%d\n",(~win[n])?step[n]:-1);
	}
	return 0;
}
```

---

## 作者：s223568907 (赞：0)

博弈论的题目，对于一种情况，如果有前驱情况为必败态，则该情况必为必胜态，若前驱情况都为必胜态，则该情况为必败态。

且若当前情况为必胜态，则应从步数最少的前驱必败态转换而来（尽快胜利），

若当前情况为必败态，则应从步数最多的必胜态转换而来（阻止对方胜利）。

s[i][0]表示i个石子时的步数，s[i][1]=-1表示当前为必败态，s[i][1]=1表示为必胜态。

p数组存质数，pr数组为判定用。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[20010][2]={0},a[20]={0},pr[20010]={1,1},p[3000]={0},ma=0,sum=0;
inline int read(int &num)
{
    num=0;
    char c=getchar();
    for(;isdigit(c)==0;c=getchar());
    for(;isdigit(c)!=0;c=getchar())num=num*10+c-'0';
}

inline void init()
{
    read(n);
    for(int i=1;i<=n;++i)
    {
        read(a[i]);
        if(a[i]>ma)ma=a[i];//寻找最大值，以便线下操作
    }
    return;
}

inline void first()//筛法，pr[i]=0表示质数，pr[i]=1表示合数 
{
    for(int i=2;i<=ma;++i)
    if(pr[i]==0)
    {
        p[++sum]=i;//存储质数，可以节省时间
        for(int j=i+i;j<=ma;j+=i)pr[j]=1;
    }
    return;
}

inline void dp()
{
    s[0][1]=-1;s[0][0]=0;
    s[1][1]=-1;s[1][0]=0;
    s[2][1]=1;s[2][0]=1;
    s[3][1]=1;s[3][0]=1;//初始化几个点
    for(int i=4;i<=ma;++i)
    for(int j=sum;j>=1;--j)//j不能反过来，会WA
    if(p[j]<=i)
    { 
        if(s[i-p[j]][1]==-1)//前驱为必败态
        if(s[i][1]==0||s[i][1]==-1)//如果未判定状态
        {
            s[i][1]=1;//置必胜态
            s[i][0]=s[i-p[j]][0]+1;
        }
        else
        s[i][0]=min(s[i][0],s[i-p[j]][0]+1);//选取最小值
        
        if(s[i-p[j]][1]==1)//前驱为必败态
        if(s[i][1]==0)//如果未置状态
        {
            s[i][1]=-1;
            s[i][0]=s[i-p[j]][0]+1;
        }
        else if(s[i][1]==-1)//如果已置必败态
        s[i][0]=max(s[i][0],s[i-p[j]][0]+1);//寻找最大值
    }
    return;
}
    
inline void print()
{
    for(int i=1;i<=n;++i)
    if(s[a[i]][1]==-1)
    printf("-1\n");
    else printf("%d\n",s[a[i]][0]);
    return;
}

int main()
{
    init();
    first();
    dp();
    print(); 
    return 0;
}
```

---

## 作者：hibiki (赞：0)

博弈论的题目，都有必胜态的前导是必败态，必败态的前导是必胜态。所以枚举每一个点，看能否让它达到必败态。如果可以则这个点必胜，否则必败。先用筛法枚举出质数，然后dp解决。因为数据略小，所以每次直接处理完2W以内的全部结果。

计数的时候参考楼下说法，必败到必胜取max，必胜到必败取min

```pascal
Var
    ifP,dp:array[0..20010] of boolean;
    prime,count:array[0..20010] of longint;
    n,i,j,t,cnt:longint;
Begin
    readln(n);
    fillchar(ifP,sizeof(ifP),true);
    fillchar(dp,sizeof(dp),false);
    fillchar(count,sizeof(count),0);
    ifP[1]:=false;
    cnt:=0;
    for i:=2 to 20000 do begin
        if ifP[i] then begin
            for j:=2 to 20000 div i do begin
                ifP[i*j]:=false;
            end;
            inc(cnt);
                        //writeln(cnt);
            prime[cnt]:=i;
        end;
    end;
    dp[0]:=false;
    for i:=0 to 20000 do begin
        for j:=1 to cnt do begin
            if prime[j]>i then break;
            if not(dp[i-prime[j]]) then begin
                dp[i]:=true;
                break;
            end;
        end;
        for j:=1 to cnt do begin
            if prime[j]>i then break;
            if dp[i] and not(dp[i-prime[j]]) then begin
                if (count[i]=0) or (count[i-prime[j]]+1<count[i]) then count[i]:=count[i-prime[j]]+1;
            end else if not(dp[i]) and (dp[i-prime[j]]) then begin
                if (count[i]=0) or (count[i-prime[j]]+1>count[i]) then count[i]:=count[i-prime[j]]+1;
            end;
        end;
    end;
    for i:=1 to n do begin
        readln(t);
        if dp[t] then writeln(count[t]) else writeln(-1);
    end;
End.
```

---


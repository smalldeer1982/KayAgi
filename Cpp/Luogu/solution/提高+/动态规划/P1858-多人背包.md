# 多人背包

## 题目描述

求01背包前k优解的价值和

DD 和好朋友们要去爬山啦！

他们一共有 K 个人，每个人都会背一个包。这些包 的容量是相同的，都是 V。可以装进背包里的一共有 N 种物品，每种物品都有 给定的体积和价值。

在 DD 看来，合理的背包安排方案是这样的： 每个人背包里装的物品的总体积恰等于包的容量。 每个包里的每种物品最多只有一件，但两个不同的包中可以存在相同的物品。 

任意两个人，他们包里的物品清单不能完全相同。 在满足以上要求的前提下，所有包里的所有物品的总价值最大是多少呢？ 

## 说明/提示

对于100%的数据,$K\le 50,V\le 5000,N\le 200$


## 样例 #1

### 输入

```
2 10 5
3 12
7 20
2 4
5 6
1 1```

### 输出

```
57```

# 题解

## 作者：顾z (赞：101)

#  [顾z](https://www.cnblogs.com/-guz/)

题目描述--->[p1858 多人背包](https://www.luogu.org/problemnew/show/P1858)

## 分析:

很明显,这题是背包问题的一种变形.

**求解 次优解or第k优解.**

表示刚开始有点懵,看题解也看不太懂.

又中途去补看了一下[背包九讲](https://blog.csdn.net/stack_queue/article/details/53544109)

然后感觉有些理解,但还是不算太清楚.

所以自己思考了一下.(应该算是大致理解了意思.

来分享一下思路.

题解里都说是裸的此类问题,并没有给出解释。

~~(给出的解释也大多是背包九讲里的一些抽象定义~~

### 前置知识

首先根据01背包的递推式：(这里按照一维数组来讲)

**(v[i]代表物品i的体积,w[i]代表物品i的价值).**

$f(j)$=$max\left(f(j),f(j-v[i])+w[i]\right)$

~~很容易~~发现$f(j)$的大小只会与$f(j)$、$f(j-v[i])+w[i]$有关

所以我们**设$f[i][k]$代表体积为i的时候,第k优解的值.**

则从$f[i][1]$...$f[i][k]$一定是一个单调的序列.

**$f[i][1]$为体积为i的时候的最优解**

### 解析

很容易发现,我们需要**记录用其他物品来填充背包是否能得到更优解**.

因此我们需要**记录一个变量c1表示体积为j的时候的第c1优解能否被更新**.

再去**记录一个变量c2表示体积为j-v[i]的时候的第c2优解**.

	这就好像我们用5填充了5,得到的价值为10.
    而我们可以用2,3填充5,得到更大价值为18.
    而我们的3又可以被1,2填充,而使得我们得到更大价值
    如此往复,我们就可以一直更新体积为5的价值,来更新第几优解.

**简单概括一下**

	我们可以用v[i]去填充j-v[i]的背包去得到体积为j的情况,并获得价值w[i].
	同理j-v[i]也可以被其他物品填充而获得价值.
	此时,如果我们使用的填充物不同,我们得到的价值就不同.
    
这是一个**刷表**的过程(或者叫**推表**?

### 为什么是正确的?

(这里引用一句话)
  
  **一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。**
  
### 个人

我尝试输出了一下这个刷表的过程.

//我将初值赋成了自己的生日 qwq

**这里给出一部分的解释↓**	

    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	-20020983	
    -20020983	-20020983	
    24	-20020979	
    32	-20020971

当前情况为我们枚举完样例中体积为2的情况得到的表格.(我们仅得到了第一优解

**下面情况为我们枚举样例中体积为5的情况**

(此时我们再度刷新了表格..
	
(now代表当前枚举到的j.)

    now::10
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	-20020983	
    -20020983	-20020983	
    24	-20020979	
    32	22
	此时我们枚举到了j=10,发现我们的f[10][1](即最优解)
    大于用体积为5的物品去填充体积为5的背包.
    且我们的f[10][2]小于他,那我们就可以得到我们的体积为10的次优解.
    (因题目要求我们去求到前2优解的和,所以只考虑到第二列.
    
    now::9
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	-20020983	
    -20020983	-20020983	
    24	-20020979	
    32	22	
	这个时候我们发现无法更新f[9][1].(这个不能更新是指不能得到正的价值.
  	我们不能填充体积为4的背包来得到一个正的最优解(体积为4的背包价值也为负
    
    now::8
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	-20020983	
    18	-20020983	
    24	-20020979	
    32	22	
	此时我们发现可以更新f[8][1].
    即对于体积为3的,我们再去用体积为5的物品填充,发现可以得到正的价值.
    所以我们可以去更新f[8][1]，
	然后尝试继续更新f[8][2].
    因为我们的f[8]整整一列都是负数.(除了刚刚更新的f[8][1]
    而我们现在可以使用体积为5的物品填充体积为3的背包得到体积为8的背包.
    所以我们去检查是否存在f[3][2]能继续更新我们的f[8][2].
    很不幸,我们枚举之后,发现并不能更新.-->f[8][2]不变.
    
    now::7
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	10	
    18	-20020983	
    24	-20020979	
    32	22	
	同上面解释,此时体积为7的背包可以被体积为2的填充,
    通过比较发现填充得到的价值,不如之前得到的价值.
    所以我们去更新f[7][2].
    
	now::6
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	-20020987	
    -20020987	-20020987	
    20	10	
    18	-20020983	
    24	-20020979	
    32	22	
	没有体积为1的,所以无法更新f[6][1]与f[6][2]
    
    now::5
    -20021003	-20021003	
    4	-20020999	
    12	-20020991	
    -20020991	-20020991	
    16	6	
    -20020987	-20020987	
    20	10	
    18	-20020983	
    24	-20020979	
    32	22
    可以直接填充空背包(体积为0)得到体积为5的情况.
    此时通过比较发现直接填充所得到的价值为次优解.
    所以更新f[5][2]
    
希望大家更好地理解一下这个求　**次优解and第k优解**　的过程

---------------------代码(附输出中间表格)-------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
using namespace std;
IL void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int k,v,n,ans,cnt,now[55];
int V[288],W[288],f[5008][55];
int main()
{
	//freopen("data.out","w",stdout);
    //尝试输出中间变量我用了notepad,因为太长了啊! 辅助用
    in(k),in(v),in(n);
    for(RI i=0;i<=5000;i++)
        for(RI j=0;j<=50;j++)f[i][j]=-20021003;//赋初值为-inf
    f[0][1]=0;//体积为0的最优解为0.
    for(RI i=1;i<=n;i++)
        in(V[i]),in(W[i]);//V[i]为体积,W[i]为价值.
    for(RI i=1;i<=n;i++)
        for(RI j=v;j>=V[i];j--)
        {
            int c1=1,c2=1,cnt=0;
            while(cnt<=k)
            {
                if(f[j][c1]>f[j-V[i]][c2]+W[i])
                now[++cnt]=f[j][c1++];
                else now[++cnt]=f[j-V[i]][c2++]+W[i];
            }
            //这里我选择了开数组记录当前最优解的值,在下面直接赋值给f[j]即可。
            for(RI c=1;c<=k;c++)f[j][c]=now[c];
//			printf("now::%d\n",j);
//			for(RI w=1;w<=v;w++,puts(""))
//			for(RI c=1;c<=k;c++)printf("%d\t",f[w][c]);
//			puts("");//上面四行是输出中间变量的
        }
    for(RI i=1;i<=k;i++)ans+=f[v][i];
//	for(RI w=1;w<=v;w++,puts(""))
//		for(RI c=1;c<=k;c++)printf("%d ",f[w][c]);
    printf("%d",ans);
}
```

---

## 作者：CWWood (赞：37)

简单的背包问题。我们知道01背包的转移条件是 f[j]=max(f[j],f[j-w[i]]+c[i])，也就是说f[j]只会由f[j]与f[j-w[i]]转移过来，我们考虑多加一维k优解，那么显然，k优解依然从f[j][]与f[j-w[i]]转移过来。由于k很小，我们只需要用f[j][]与f[j-w[i]]暴力判断第k优解更新答案即可。**值得注意的是，这里的背包必须装满也就是f[V][1..k]的和**,因为原题是要求背包装满的。

```cpp
#include<cstdio>
#include<cstring>
int f[5010][60],ans=0;
int k,v,n,w[220],c[220],t[60];
int main(){
    memset(f,128,sizeof(f));
    scanf("%d%d%d",&k,&v,&n);
    for (int i=1;i<=n;i++) scanf("%d%d",&w[i],&c[i]);
    f[0][1]=0;
    for (int i=1;i<=n;i++)
        for (int j=v;j>=w[i];j--){
            int t1=1,t2=1,t[60],len=0;
            while (t1+t2<=k+1){
        if (f[j][t1]>f[j-w[i]][t2]+c[i]) 
            t[++len]=f[j][t1++];
                else t[++len]=f[j-w[i]][t2++]+c[i];
            }
            for (int K=1;K<=k;K++) f[j][K]=t[K];
        }
    for (int i=1;i<=k;i++) ans+=f[v][i];
    printf("%d",ans);
}
```

---

## 作者：凌幽 (赞：18)

- 01背包的一般转移:

假如我们用f[i][j]表示前i件物品体积为j的最大价值,w表示物品的体积,v表示该物品的价值

那么f[i][j]=max(f[i-1][j-w]+v)

- 同样,要求前k方案,我们可以再添加一维来限制

f[i][j][k]表示前i件物品,体积为j,此时是第k方案的价值

显然,k越大,对应的价值越小

观察上面的转移方程,每件物品有两种决策方案,选或者不选,在讨论第k方案时,我们可以通过前k-1的方案中,每种物品放或是不放转移过来,而此时,就构成了两个序列,一列是放,一列是不放,如何取价值最大值呢?于是,我们就联想到了归并排序

- 当然,像朴素0/1背包那样,我们可以省去第一维

- AC代码

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define R register
#define ll long long
#define inf 707406378
inline void in(int &x) {
    static int ch; static bool flag;
    for(flag = false,ch = getchar();ch < '0'||ch > '9';ch = getchar()) flag |= ch == '-';
    for(x = 0;isdigit(ch);ch = getchar()) x = (x<<1) + (x<<3) + ch - '0';
    x = flag ? -x : x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int k,v,n,sum;
int f[205][5005];// f[i][j] 第i大的背包,体积为j的价值 
int yes[5005],no[5005];
inline int dy(){
    in(k),in(v),in(n);
    for(R int i=0;i<=k;++i)
        for(R int j=0;j<=v;++j)f[i][j]=-inf;
    f[1][0]=0; 
    for(R int i=1;i<=n;++i){
        R int W,V; in(W),in(V);
        for(R int j=v;j>=W;--j)
            if(f[1][j-W]>=0){
                for(R int t=1;t<=k;++t)yes[t]=no[t]=0;
                R int qy=1,qn=1;
                for(R int t=1;t<=k;++t){
                    yes[t]=f[t][j-W]+V; //归并排序
                    no[t]=f[t][j];
                    if(yes[qy]>=no[qn])f[t][j]=yes[qy++];
                    else f[t][j]=no[qn++];
                }
            }
    }
    for(R int i=1;i<=k;++i)sum+=f[i][v];
    write(sum);
    exit(0);    
}
int QAQ = dy();
int main(){;}
```

---

## 作者：Acerkaio (赞：17)

# 原题链接 ：  

->[这](https://www.luogu.com.cn/problem/P1858)<-

# 题外话 ： 

好像许多题解区 daolaos 都引用了背包九讲里面的一些很抽象的语言，题解区第一的 dalao 用了所谓“刷表”方式证明。也很模糊。本题解重讲思路。 

# 思路 ：

此题大致同于 01 背包；

重点在： 

```cpp

/*核心代码*/
for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=v[i];j--)
		{
			int add=0,a=1,b=1;
			while(add<=k)
			{	
				if(f[j][a]>f[j-v[i]][b]+w[i])
				{
					x[++add]=f[j][a++];
				}
				else
				{
					x[++add]=f[j-v[i]][b++]+w[i];
				}
				
			}
			for(int t=1;t<=k;t++)
			f[j][t]=x[t];
		}	
	}
    
```

其中 $ f[i][j] $ 表示前 i 个数据最 j 优解；

$ add $ 表示到第几个优解了 , 所以只要 $ add\le k $ 都可进入状态转移；

$ x[i] $ 记录当前否被以前的替换掉 ( 此处如 01 背包 )，所以之后还要把  x 里的值刷回去；

a 与 b 分别记录现在、前面的优解；

就优解判断否被更新。

# 完整CODE：
```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;

int f[5001][101],v[10001],w[100001],x[100001]; 
signed main()
{
	int k,m,n;
	cin>>k>>m>>n;
	for(int i=1;i<=n;i++)
	{ 
	 	cin>>v[i]>>w[i];	
	}
	memset(f,~0x3f3f3f3f,sizeof(f));
	f[0][1]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=v[i];j--)
		{
			int add=0,a=1,b=1;
			while(add<=k)
			{	
				if(f[j][a]>f[j-v[i]][b]+w[i])
				{
					x[++add]=f[j][a++];
				}
				else
				{
					x[++add]=f[j-v[i]][b++]+w[i];
				}
				
			}
			for(int t=1;t<=k;t++)
			f[j][t]=x[t];
		}	
	}
	int sum=0;
	for(int i=1;i<=k;i++)
	sum+=f[m][i];
	cout<<sum<<'\n';
	return 0;	
}


```




---

## 作者：ysj1173886760 (赞：16)

写篇题解

首先还是推荐背包九讲，里面讲关于k优解得问题讲的很详细。

当然还是要先考虑3维的，设dp[i][j][k]为第i个物品，用了j的空间，的k优解。

很显然dp[i][j][1...k]单调递减。

把dp[i][j]看做是一个元素，那么我们对于每一个状态有一个长度为k的单调递减的队列。

然后就是考虑转移了，对于本来的背包问题，我们有dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])

那么dp[i][j]这个长度为k的序列的来源就有两个，一个是从dp[i-1][j]中取，一个是dp[i-1][j-w[i]]+v[i]这里取。

我们取这两个状态中的前k个给dp[i][j]即可。

关于合并呢？利用队列是单调的这一性质，每次取队头即可。

时间复杂度O(k)

总的复杂度O(nvk)

然后就是针对这道题的一些小细节了。

首先3维肯定mle，所以考虑滚动数组优化。

这里要注意的就是，如果直接更新的话，会用到新更新的值，也就是当前状态用到了当前状态的值，这是错误了，新加一个数组就行了。

更新完成后再赋给dp

还有就是初始化，这题是满包问题，所以初始化负无穷，dp[0][0][1]=0，注意不能初始化dp[0][0][2]什么的，否则就重复了。

最后代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

int k,m,n;
int w[210],v[210],dp[5010][60],temp[60];

int main()
{
	memset(dp,-0x3f,sizeof(dp));
	scanf("%d %d %d",&k,&m,&n);
	for(int i=1;i<=n;i++)scanf("%d %d",&w[i],&v[i]);
	dp[0][1]=0;		//初始化 
	for(int i=1;i<=n;i++)
		for(int j=m;j>=w[i];j--)
		{
			for(int l=1,p1=1,p2=1;l<=k;l++)	//p1 p2 为两个队头 
				temp[l]=(dp[j][p1]>dp[j-w[i]][p2]+v[i]?dp[j][p1++]:dp[j-w[i]][p2++]+v[i]);
			for(int l=1;l<=k;l++)dp[j][l]=temp[l];
		}
	int ans=0;
	for(int i=1;i<=k;i++)ans+=dp[m][i];
	cout<<ans;
	return 0;
} 
```

---

## 作者：zzr8178541919 (赞：6)



一道新型的背包dp题目，解释都在代码中\(^o^)/~

```cpp

//多人背包
//其实输出部分已经给了提示了
//求的就是普通背包的第k大
 
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int w[200005];
int c[200005];
int dp[5555][65];
int main()
{
	memset(dp,128,sizeof(dp));
	//现将dp数组定义成最大。 
	int k,m,n;
	scanf("%d%d%d",&k,&m,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&w[i],&c[i]);
	}
	dp[0][1]=0;
	//初始化的部分 
	for(int i=1;i<=n;i++)
	{//枚举每一个物品 
		for(int j=m;j>=w[i];j--)
		{//这个就是 
			int now1=1;
			int now2=1;
			int t[65];
			int len=0;
			//这里是在用之前的答案更新当前的数组 
			//now1记录的是体积为j的前k大
			//now2记录的是体积为j-w[i]的前k大。
			//这两个数组共同组成了dp[j]的前k大。
			//用双指针往后寻找即可 
			while(now1+now2<=k+1)
			{
				if(dp[j][now1]>dp[j-w[i]][now2]+c[i])
				t[++len]=dp[j][now1++];
				else
				t[++len]=dp[j-w[i]][now2++]+c[i];
			}
			for(int l=1;l<=k;l++)
    		{
	     		dp[j][l]=t[l];
    		}
    		//把临时数组转移回去 
		}	
	}
	int ans=0;
	for(int i=1;i<=k;i++)
	{
		ans=ans+dp[m][i];
	}//处理出前k大的和 
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：一念之间 (赞：5)

这道题目是在01背包的基础上求出前K个最优解。


dp[i][j]: 背包容量为i，第j优解的值。


由于任意两个背包不能完全相同，所以只初始化dp[0][1]=0;


因为要求必须恰好装满，所以其他的初始化为最小。



dp[i][1....k]=max(dp[i][1..k],dp[i-w][1...k]+v);

即dp[i][1....k]中的k个元素为dp[i][1..k]中的k个元素+dp[i-w][1...k]中的k个元素的前k大的元素。


合并两个数组的时候利用归并排序的原理合并。

```cpp
#include <stdio.h>  
int f[5001][51];  
int main()  
{  
    int k, v, n, a, b;  
    int i, j, u, t[51], p1, p2, ans;  
    scanf("%d%d%d", &k, &v, &n);  
    for(i = 0; i < v; ++i)  
        for(j = 0; j <= k; ++j)  
            f[i][j] = -99999999;  
    f[0][1] = 0;  
    for(i = 1; i <= n; ++i)  
    {  
        scanf("%d%d", &a, &b);  
        for(j = v; j >= a; --j)  
            if(f[j-a][1] >= 0)  // 累计，完全装满 
            {  
                p1 = 1, p2 = 1;  
                for(u = 1; u <= k; ++u)  
                {  
                    t[u] = f[j][u]; 
                    if(f[j-a][p2] + b > t[p1])  
                        f[j][u] = f[j-a][p2++] + b;  //一定是p2++，由前一状态推出 
                    else                             // P2++后推出比这个数小的，因为p2+1后  f[j-a][p2++]成了负的 
                        f[j][u] = t[p1++];  //保证当前状态最大 
                }  
            }  
    }  
    ans = 0;  
    for(i = 1; i <= k; ++i)  
        ans += f[v][i];  
    printf("%d\n", ans);  
    return 0;  
}
```

---

## 作者：glorious_dream (赞：3)

### 题目描述：

重点：求 $01$ 背包前 $k$ 优解的价值和，并且背包要装满。

### 算法分析：

首先，$01$ 背包大家应该很熟悉了，这里就不讲转移式了。

先讲第一部分：如何保证背包装满？

正常的 $01$ 背包是从数组初始值为 $0$ 开始，也就是说每一种体积都会转移，有可能会更新答案。

但如果要装满，显然，装不满的体积(也就是没有 $n$ 个物品的体积和能为这个体积)显然不能要。似乎感觉很难，但没关系，我们把 $f$ 数组先赋值为最小值。

这样有什么好处？会发现，因为是一层一层往下刷，那么第一层显然只有体积正好为第一个物品的那个体积，会更新最大值(因为别的都是负无穷，不会更新)。

然后开始刷第二层，显然，只有在第一层刷过的那个体积，才会接着往后转移(因为转移别的都是从负无穷转移过来的，没有意义，不可能是最大值)。

然后注意 $f$ 数组要有一个初始值是 $0$ (后面讲)。

来看第二部分：求前 $k$ 优解的价值和。

设 $f[i][j]$ 表示体积为 $i$，第 $j$ 优解的值。这时，上面说的 $f$ 数组初始值就可以赋值了。把 $f[0][1]$ 赋值为 $0$，因为体积为 $0$ 的最优解显然是 $0$。

我们需要考虑前 $k$ 优解。从最优解开始往后找。

$01$ 背包是 $f[j]$ 和 $f[j-w[i]]+v[i]$ 的转移，那么这道题可以借鉴这种思路。

设 $x$，$y$ 分别为两边的最优解。如果 $f[j][x] > f[j-w[i]][y]$，我们用一个数组 $rnk$ 来存前 $k$ 优解，这时 $rnk[++cnt] = f[j][x]$，并且把 $x+1$。反之同理。

这段话表示什么？就是记录这两种背包的容量，哪一种是大的。

最后在外面把 $f$ 数组在容积为 $j$ 的条件下的前 $k$ 优解赋值为 $rnk$ 数组的前 $k$ 个就可以了。

### 总代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
const int M = 5010;
int k,value,n,ans;
int w[M],v[M],f[M][60],rnk[M];
signed main(){
	k=read(),value=read(),n=read();
	for(re int i(1) ; i<=n ; ++i) scanf("%d%d",&w[i],&v[i]);
	memset(f,-0x7f7f7f7f,sizeof(f));
	f[0][1] = 0;
	for(re int i(1) ; i<=n ; ++i){
		for(re int j(value) ; j>=w[i] ; --j){
			int rn1=1,rn2=1,cnt=0;
			while(cnt<=k){
				if(f[j][rn1] > f[j-w[i]][rn2]+v[i]){
					rnk[++cnt] = f[j][rn1];
					rn1++;
				}
				else{
					rnk[++cnt] = f[j-w[i]][rn2]+v[i];
					rn2++;
				}
			}
			for(re int h(1) ; h<=k ; ++h) f[j][h] = rnk[h];
		}
	}
	for(re int i(1) ; i<=k ; ++i) ans += f[value][i];
	printf("%d",ans);
	return 0;
}

```


---

## 作者：celibacy (赞：3)

/\*本人第一次写题解，小小激动。。。

本题dp即可，不过需注意找的是前k个解，所以呢

可以开一个二维数组来存储，f[i][k]

k表示第几大，i则表示所用空间。。。

最后一波归并即可。。。

感谢支持，有些粗糙别介意。。。。

其实也可以去看下大牛的[博客](http://www.cnblogs.com/937337156Zhang/p/6036183.html)\*/


```cpp
#include<bits/stdc++.h>
using namespace std;
int k,v,n,f[5001][51],w[201],m[201],t[51];
void solve(int a[],int b[],int c)
{
    int i=1,j=1,pos=1;
    while (i+j<=k+1)
    {
        **if (a[i]>b[j]+c) t[pos++]=a[i++]; //用dp判断该解是否是最优解，并排序**
      **else t[pos++]=b[j++]+c;**
    }
    for (int i=1; i<=k; i++) a[i]=t[i]; //将临时变量t中所存储的解存储下来。
}
int main(){
    cin>>k>>v>>n;
    memset(f,128,sizeof(f));
    for (int i=1; i<=n; i++) cin>>w[i]>>m[i];    
    f[0][1]=0;
    for (int i=1; i<=n; i++)
        for (int j=v; j>=w[i]; j--)
        {
            solve(f[j],f[j-w[i]],m[i]);//去寻找前k大的解
        }
    int sum=0;
    for (int i=1; i<=k; i++) sum+=f[v][i];
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：管仲 (赞：2)

//今天我们又考试了，考试的第五题是这样的一道题目

//面对这样的一道题，我的第一想法是背包问题，可因为实力太弱，没有很好的想法，一共考试8个题，最终只能打暴力搜索 只有20分，8个TLE

//代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int w=0;
	bool q=1;
	char c=getchar();
	while ((c<'0'||c>'9') && c!='-') c=getchar();
	if (c=='-') q=0,c=getchar();
	while (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();
	return q? w:-w;
}
int k,v,n,tot,ans;
int a[5100],V[5100],w[5100];
void dfs(int x,int res,int now)
{
	if(res==v)
	{
	a[++tot]=now;
	return ;
	}
	if(x==n+1) return ;
	dfs(x+1,res,now);
	dfs(x+1,res+V[x],now+w[x]);
}
bool cmp(int x,int y){
	return x>y;
}
int main()
{
	k=read();v=read();n=read();
	for(int i=1;i<=n;i++)
	{V[i]=read();w[i]=read();}
	dfs(1,0,0);
	sort(a+1,a+1+tot,cmp);
	for(int i=1;i<=k;i++)
	ans+=a[i];
	cout<<ans<<endl;
	return 0;	
}
```


//今天晚上，静静地想一下这道题，揣摩了一下，没想到就出来了

//这种题目可以转化成第k个最优解的问题

//那我就用一个f[i][j]数组来表示，体积为i时，第j个最优解；而且被背包的空间要全部用完

//用一个b1来表示体积为j时，第b1组是否被更新

//同理用一个b2来表示当体积为j-c[i]时，b2是否被更新

//为什么这样做一定对呢？？

//因为对于任意的值你可以将 此空间分成两部分，再将分出的空间分出来，可以遍历他的每一种情况

//废话少说，立即上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,m;
int ans=0,now[55];
int c[5000],w[5000],f[5200][100];
int main()
{
	cin>>k>>m>>n;
	for(int i=1; i<=n; i++)
	cin>>w[i]>>c[i];
	for(int i=0; i<=5000; i++)
	for(int j=0; j<=50; j++)
	f[i][j]=-999999;

	f[0][1]=0;
	for(int i=1; i<=n; i++)
		for(int j=m; j>=w[i]; j--)
		{
			int b1=1,b2=1,cnt=0;
			while(cnt<=k)
			{
			if(f[j][b1]>f[j-w[i]][b2]+c[i])
			now[++cnt]=f[j][c1++];
			else now[++cnt]=f[j-w[i]][b2++]+c[i];
			}
			for(int c=1;c<=k;c++)
			f[j][c]=now[c];//利用now数组来记录他在j的k中最优解方案
		}
		for(int i=1;i<=k;i++)
		ans+=f[m][i];
		cout<<ans<<endl;
		return 0;
}
```

---

## 作者：hello_world_djh (赞：1)

本题解灵感来源于[题解 P1858 【多人背包】](https://www.luogu.com.cn/blog/RPdreamer/p1858)

sto [顾z](https://www.luogu.com.cn/user/87960) orz

本篇题解仅仅是对该题解的解释和说明。

主要对原题解的解析部分加以补充：

该文章中刷表的地方，是通过两个值去更新新的解。

这句话的意思是，因为我们原来01背包的 $f(j)$ 只有可能从 $f(j)$ 和 $f(j - v_i) + w_i$ 中更新，所以我们当前版本的值只会被更优版本的解更新，也就是只会取之前更优的解中没有更新更优解的次略解更新（此处可以类比 k 短路来理解）。

所以我们相当于从大到小枚举所有的次略解，去更新当前解。

> 一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。

这是 顾z 大佬的原话

也就是

```cpp
while(cnt<=k)
{
    if(f[j][c1]>f[j-V[i]][c2]+W[i])
    now[++cnt]=f[j][c1++];
    else now[++cnt]=f[j-V[i]][c2++]+W[i];
}
```

其他地方那篇文章已经讲得十分详细了，本文不多赘述。

---

## 作者：Error_Eric (赞：1)

### 题意

求 01 背包前 $k$ 佳方案的价值和。

### Sol

个人感觉这种方法更好理解。

dp 值不一定是整数或者实数。

01 背包的 $f[i]$ 表示的是体积为 $i$ 的最大价值。

那么我让 $f[i]$ 表示体积为 $i$ 的前 $k$ 大价值。

这个东西显然一个 int 存不下，所以我把 $f[i]$ 开成 vector。

这样就直接按照原问题的方程做就可以了。

（当然这种方法和题解区广泛采用的多加一维的方式在原理上是一致的，只是理解方式和实现方式都不同而已qwq）

### Code

如果把 kint 换成 int,add(x,y,z) 换成 x=max(x,y+z) 那么就是 01 背包。

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
#include<numeric>
#define minn(a,b) ((a<b)?a:b)
using namespace std;
const int inf=0x3fffffff;
typedef vector<int> kint;
int k,c,n,vi,wi;
kint f[5005];
void add(kint&k1,kint&k2,int x){
    for(int&x2:k2) k1.push_back(x2+x);
    sort(k1.begin(),k1.end(),[](int u,int v){return u>v;}),
    k1.resize(minn(k1.size(),k));// inplace_merge is also ok.
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    cin>>k>>c>>n,f[0].push_back(0);
    for(int i=1;i<=n;i++){
        cin>>vi>>wi;
        for(int j=c;j>=vi;j--)
            add(f[j],f[j-vi],wi);
    }
    cout<<accumulate(f[c].begin(),f[c].end(),0ull)<<endl;
}
```

---

## 作者：Coros_Trusds (赞：1)

$\verb!upd:!$ 修改了不标准的数字表示方法。

# 题目大意

求 $\rm 01$ 背包前 $k$ 优解的价值和。

# 题目分析

令 $dp_{i,j,k}$ 表示考虑了前 $i$ 个物品，总体积为 $j$ 的第 $k$ 优解。

根据定义，可以得到 $dp_{0,0,1}=0$。又根据“第 $k$ 优解”可看出 $dp_{i,j,1\cdots k}$ 单调递减。

那么我们如何转移呢？很简单，$dp_{i,j}$ 只可能从 $dp_{i-1,j}$ 或 $dp_{i-1,j-w_i}+v_i$ 转移而来，而我们要维护最优性，可以想到从 $dp_{i-1,j,1\cdots}$ 和 $dp_{i-1,j-w_i,1\cdots}+v_i$ 中取出前 $k$ 优解作为当前状态。

因为两个队列严格单调，所以用两个指针取出每次队头的最优值即可。

空间复杂度和时间复杂度均为 $\mathcal{O(vkn)}$。时间 $5\times 10^7$ 可以卡卡，但空间会炸，发挥传统艺能优化掉数组第一维就行了。

答案就是 $\sum\limits_{i=1}^kdp_{n,v,i}$。

# 代码

```cpp
//2022/3/13
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int ma1 = 5005,ma2 = 55,ma3 = 205;
int cost[ma3],value[ma3],ta[ma2],tb[ma2],dp[ma1][ma2];//dp[i][j]:体积为 i 的第 j 优解
int k,v,n;
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	k = read(),v = read(),n = read();
	for (register int i = 1;i <= n; ++ i) cost[i] = read(),value[i] = read();
	mst(dp,0xcf);
	dp[0][1] = 0;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = v;j >= cost[i]; -- j) {
			for (register int l = 1;l <= k; ++ l) {
				ta[l] = dp[j][l];
				tb[l] = dp[j - cost[i]][l] + value[i];
			}
			int l = 1,p1 = 1,p2 = 1;
			while (l <= k) {
				if (p1 > k && p2 > k) break;
				if (p1 > k) {
					dp[j][l] = tb[p2 ++];
				} else if (p2 > k) {	
					dp[j][l] = ta[p1 ++];
				} else if (ta[p1] > tb[p2]) {
					dp[j][l] = ta[p1 ++];
				} else if (ta[p1] <= tb[p2]) {
					dp[j][l] = tb[p2 ++];
				}
				l ++;
			}
		}
	}
	int ans = 0;
	for (register int i = 1;i <= k; ++ i) ans += dp[v][i];
	printf("%d\n",ans);

	return 0;
}
```

---

## 作者：KEBrantily (赞：1)

${\mathcal{For}}$ ${\mathcal{we}}$
${\mathcal{live}}$
${\mathcal{by}}$
${\mathcal{faith}}$
${\mathcal{,}}$
${\mathcal{not}}$
${\mathcal{by}}$
${\mathcal{sight}}$
${\mathcal{.}}$

------------
## Description

 N 种物品，有各自的价值 w 和代价 c；
 
 一个背包，容量为 V；
 
 背包内同样类型的物体只能装一个；
 
 求 K 种不同的方法，使得背包在被装满的情况下价值和最大。
 
------------
## Analysis

01背包问题最 k 优解问题；

先考虑如何求最大解，运用 01 背包基础思想解决；

$f[i]$ 表示当前背包装第 i 件物品的最大价值；

$$f[v]=max(f[v],f[v-cost]+weight)$$


但显然这并不能满足这个题的需要

### 那~
- 开一个二维数组 $f[i][j]$ 表示背包容量为 i 时的第 j 优解；

- 开两个变量 Yes 和 No 储存表示体积为 v 和 v - c[ ] 时的最优解；

- 开一个数组 Ans[ ] 来暂时存储答案；

- 开一个变量 cnt 记录当前是第 cnt 优解

方程式这里不好描述 ，具体见代码；


------------
## Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define maxn 2000100
#define maxm 4010
#define INF 0x3f3f3f3f
#define Init1(s) memset(s,0,sizeof s)
#define Init2(s) memset(s,INF,sizeof s)
#define Init3(s) memset(s,-INF,sizeof s)

using namespace std;

int k,v,n,w[maxn],c[maxn];
int f[maxm<<1][50];
int Res;
int Ans[maxm];
int cnt,Yes,No;

int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s*w;
}

void Pack01(int cost,int weight) {
	for(int i=v; i>=weight; i--) {
		Yes=1;No=1;cnt=0;
		while(cnt<=k) {
			if(f[i][Yes]>f[i-weight][No]+cost) Ans[++cnt]=f[i][Yes++];
			else Ans[++cnt]=f[i-weight][No++]+cost;
		}
		for(int j=1; j<=k; j++) f[i][j]=Ans[j];
	}
}

int main() {
	Init3(f);
	f[0][1]=0;
	k=read(),v=read(),n=read();
	for(int i=1; i<=n; i++) {
		w[i]=read();
		c[i]=read();
		Pack01(c[i],w[i]);
	}
	
	for(int i=1; i<=k; i++) Res+=f[v][i];
	printf("%d\n",Res);
	return 0;
}
```



------------


---

## 作者：flrs (赞：1)

# 概要：
算不上什么正经的题解吧，只是想把其他题解没有讲清楚的东西大概提一下，既是为了帮自己整理思路，也是为了帮大家更好地理解这道题。

# 正文

## P1：
为什么我不能像普通01背包那样求，然后每次把所有更新到的值都存下来，最后再排个序呢？

好思路。这是我最开始拿10分想了半个小时为什么错的思路。普通的01背包只存了每种状态的最优解而舍弃了次优解，而正解每次更新的时候都把前K优的解存了下来，这样确保所有的状态都不会丢失。普通的01背包目标即最后的最优解，并没有考虑保留任何的次优解，所以在后面转移的时候也不会出现，既是可能这些解最后转移的结果会大于部分最优解转移出来的结果，其依旧会被舍弃。

## P2:
为什么我只能更新dp[0][1]而不能更新其他的点呢？这不是偏心吗？？

话是这么说，但其实你要是更新了所有的dp[0][i]，会导致你前期的一个点被转移多次，一个方案会被多次重复计算，导致答案偏大。

## 总结：
背包等dp问题真的十分考验OIer的脑力思维，多想多练，总会方程就能信手拈来的。

---

## 作者：wangyangyang (赞：1)

1.在‘动态规划’问题中，用负无穷来代表不合法情况

相对应的,0为合法解


2.求解01背包第k小的方案时，在原动规数组上再开一维，记录第k小，并开两个（或二维）数组记录动态转移方程的前k组，，，，，，

附代码

```delphi

var  
  k,vm,n,i,j,l,l1,l0,ans:longint;  
  first:array[1..200,0..1]of longint;  
  f:array[0..5000,0..50] of longint;  
  v,w:array [1..200] of longint;  
begin  
  readln(k,vm,n);  
  for i:=1 to n do  
    readln(v[i],w[i]);  
  fillchar(f,sizeof(f),200);  
  f[0,1]:=0;                  //when m=0 the best solution is 0  
  
  for i:=1 to n do  
  for j:=vm downto v[i] do  
      begin  
        for l:=1 to k do  
          begin  
            first[l,0]:=f[j,l];  
            first[l,1]:=f[j-v[i],l]+w[i];  
          end;  
        l0:=1;                      // merge  
        l1:=1;  
        for l:=1 to k do  
          begin  
            if first[l0,0]>first[l1,1] then  
              begin  
                f[j,l]:=first[l0,0];  
                inc(l0);  
              end  
            else  
              begin  
                f[j,l]:=first[l1,1];  
                inc(l1);  
              end;  
          end;  
      end;  
  ans:=0;  
  for i:=1 to k do  
    inc(ans,f[vm,i]);  
  writeln(ans);  
end.  



```

---

## 作者：Clu3ter (赞：0)

题目链接：[[P1858 多人背包]](https://www.luogu.com.cn/problem/P1858)

------------

理一下思路

题意在第一句写的很清楚了，**求01背包前k优解的价值和**。

并且有个条件：**背包必须装满**。

根据01背包的递推式：

$$ f[i][j]=\min \{ f[i][j] ,  f[i][j-v[i]]+w[i] \} $$

不难发现**每一轮 $i$ 循环中 $f[i][j]$ 的变化只与其上一行 $f[i-1][j]$ 及 $f[i][j-v[i]]+w[i]$ 有关。**

而我们的结果是背包必须装满的情况，即 $f[N][V]$ 。

所以我们可以考虑：

**对于每一个 $i$ ，记录一个 _单调_ 的k优解序列，每次对于 $i$ 的k优解序列，从 $i-1$ 的k优解中转移。** 具体的来说，即 $f[i-1][j]$ 的k优解与 $f[i][j-v[i]]$ 的k优解加上 $w[i]$ 。

由于这个最优解序列是单调的，因此可以采取类似归并排序的方式进行转移。

又因为每轮 $i$ 的结果只和 $i-1$ 的结果有关，因此仍然可以采用**滚动数组优化**。

边界条件：体积为 $0$ 时仅有不装这一最优解，其他情况均为 $-\infty$ 。

------------

在01背包的基础上进行一些修改：

- 增加一维用于保存k优解序列

- 每次转移时转移整个k优解序列

- 最终求```f[V][k]```的和

```cpp
for(int i=0;i<=V;i++)
		for(int j=0;j<=K;j++)
			f[i][j]=-1e9;
f[0][1]=0;
for(int i=1;i<=N;i++){
	for(int j=V;j>=v[i];j--){
		c1=1,c2=1,k=0;
		while(k<=K){//归并转移本层的k优解 
			if(f[j][c1] > f[j-v[i]][c2]+w[i])
				t[++k]=f[j][c1++];
			else
				t[++k]=f[j-v[i]][c2++]+w[i];
		}
		for(int k=1;k<=K;k++){//覆盖
			f[j][k]=t[k];
		}	
	}
}
for(int k=1;k<=K;k++)
		ans+=f[V][k];
```

---

## 作者：kuroto (赞：0)

蒟蒻的第一次题解，dalao们手下留情

这是一道求01背包第k优解的dp，相信能做到这道题的各位一定对背包的状态转移十分了解，这里不加赘述，主要介绍本蒟蒻的思路。

我们设 w[i] 为物品i的花费，val[i] 表示物品i的价值，dp[p][j] 表示花费为j时的第p优解，很显然对于确定的j都有

### dp[p][j]>=dp[p+pi][j],(pi>0)
#### 也就是 dp[p][j] 是单调递减的

而每次更新答案后，上次更新产生的前k优解的顺序可能会发生改变，

因此我们需要设p1,p2来表示更新后与更新前方案的价值。

这样我们会发现，dp[p1][j],dp[p2][j-w[i]]+val[i]一共会产生2k种方案，

而我们需要的就是价值最大的前k种方案作为更新后的解，

又因为dp数组是单调的，我们只需从小到大枚举p1,p2即可。

**关于初始化问题**

dp数组初始化一定是负无穷。

因为如果初始化为0，那么从第一次更新开始，前k组解的情况都是一样的，

因此每次更新我们都会得到一样的结果，最后得到k种方案均为最优解。

而初始化为负无穷，第一次只有dp[1][0]会被更新，而只产生一种方案。

在下一次更新时，dp[1][w[1]]与dp[1][0]会产生两种新方案，

以此类最后推产生k种方案。

**ac代码**


```
#include<bits/stdc++.h>
using namespace std;
int k,v,n;
int dp[55][5001],w[201],val[201],now[55];
int main()
{
	cin>>k>>v>>n;
	for(int i=1;i<=k;i++)
	    for(int j=0;j<=v;j++)
	        dp[i][j]=-0x7fffffff;
	for(int i=1;i<=n;i++)
	    cin>>w[i]>>val[i];
	dp[1][0]=0;
	for(int i=1;i<=n;i++)
	    for(int j=v;j>=w[i];j--)
	    {
	    	int p1=1,p2=1;
	    	for(int c=1;c<=k;c++)
	    	{
			    if(dp[p1][j]>=dp[p2][j-w[i]]+val[i])
	    		    now[c]=dp[p1++][j];
	    		else now[c]=dp[p2++][j-w[i]]+val[i];
			}
/*这里是代码的核心，对于p1,p2比较dp[p1][j],dp[p2][j-w[i]]+val[i]的值，
大的存到now[]里，小的继续和下一个值比较，直到得到k种答案*/
			for(int c=1;c<=k;c++)
			{
			    dp[c][j]=now[c];
		    }  
		}
	long long ans=0;
	for(int i=1;i<=k;i++)
	    ans+=dp[i][v];
	cout<<ans;
}
```

---

## 作者：Saberlve (赞：0)

# 深入理解
此题模板[多人背包](https://www.luogu.org/problemnew/show/P1858)。

------------

大体题意：求01背包的前k优解的和。

### 思路：

1. 我们用f[i][j][k]来**表示体积为j时，选前i个物品所取得的第k优解**，根据一般的背包优化，第一维i可以省掉。

2. 接下来我们考虑怎么一步步的更新f数组，比较容易知道的是，只有再将背包恰好装满的时候才有所谓的第k优解。所以我们先把除f[0][1]（即体积为0时的最优解）以外的**所有位置赋一个很小的初值。**

3. 接着，我们用一个now数组记录当前取不取第i件物品所得到的k优解，然后赋给f数组以便下层循环更新

	即这段
    ```cpp
	for(RI i=1;i<=n;i++)
        for(RI j=v;j>=V[i];j--)
        {
            int c1=1,c2=1,cnt=0;//c1控制当前不取第i件物品所得到的c1优解
			//c2控制当前取第i件物品所得到的c1优解
			//now[cnt]即是取第i件物品时所得到的一波k优解 
            while(cnt<=k)
            {
                if(f[j][c1]>f[j-V[i]][c2]+W[i])
                now[++cnt]=f[j][c1++];
                else now[++cnt]=f[j-V[i]][c2++]+W[i];//与上文描述对应 
            }

            for(RI c=1;c<=k;c++)f[j][c]=now[c];//把这次所更新的k优解赋到f数组里，以便下次更新 
        }
	```



------------

这样就结束了。

#### 此题的要点在于，理解前面的c1,c2可以记录下来然后用来更新后面的吧
最后是代码
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
using namespace std;
IL void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int k,v,n,ans,cnt,now[100];
int V[300],W[300],f[10000][100];
int main()
{
    
    in(k),in(v),in(n);
    for(RI i=0;i<=5000;i++)
        for(RI j=0;j<=50;j++)f[i][j]=-20030916;
    f[0][1]=0;
    for(RI i=1;i<=n;i++)
        in(V[i]),in(W[i]);
    for(RI i=1;i<=n;i++)
        for(RI j=v;j>=V[i];j--)
        {
            int c1=1,c2=1,cnt=0;//c1控制当前不取第i件物品所得到的c1优解
			//c2控制当前取第i件物品所得到的c1优解
			//now[cnt]即是取第i件物品时所得到的一波k优解 
            while(cnt<=k)
            {
                if(f[j][c1]>f[j-V[i]][c2]+W[i])
                now[++cnt]=f[j][c1++];
                else now[++cnt]=f[j-V[i]][c2++]+W[i];//与上文描述对应 
            }

            for(RI c=1;c<=k;c++)f[j][c]=now[c];//把这次所更新的k优解赋到f数组里，以便下次更新 
        }
    for(RI i=1;i<=k;i++)ans+=f[v][i];
    printf("%d",ans);//输出 
}
```


---


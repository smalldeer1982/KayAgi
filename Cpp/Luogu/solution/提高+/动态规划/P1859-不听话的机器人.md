# 不听话的机器人

## 题目描述

机器人收到 $N$ 条指令，但它不想走到障碍物上或走出边界，所以决定拒绝一些指令。求最少拒绝多少条指令？

`FORWARD` 前进 $1$

`BACK` 后退 $1$

`LEFT` 左转 $90$ 度

`RIGHT` 右转 $90$ 度

初始时，机器人是面对着上方的。


## 样例 #1

### 输入

```
4 7 3 3
.***
..**
*..*
****
LEFT
FORWARD
LEFT
BACK
FORWARD
RIGHT
FORWARD```

### 输出

```
1```

# 题解

## 作者：荣一鸣 (赞：8)

本题是一道十分奇怪的dp题

首先，我们要对于这道题目做出一点抗议，那就是在一开始，机器人是**面对着上方的**

为了常试出这一点我交了好几次。。。

好吧，开始正题

很明显，我们可以记录当机器人在这个时间走到了$(i,j)$这个点并且面对的方向是$k$的时候的最小拒绝次数

即，用$dp[i][j][k][l]$来存走$l$次到这里的最小拒绝次数

然后就可以分类状态转移了，很显然在该点要么是这一次拒绝了，要么是从另一个状态转移过来

首先是$LEFT$

在我这里0~3分别表示右，下，左，上

那么$LEFT$的转移方程就是

$dp[i][j][k][l]=min(dp[i][j][k][l-1]+1,dp[i][j][(k+1)$%$4][l-1])$

同理科的$RIGHT$得方程

然后就是$BACK$

$dp[i][j][k][l]=min(dp[i][j][k][l-1]+1,dp[i+dx[k]][j+dx[k]][k][l-1])$

$FORWORD$同$BACK$

然后就是代码

```cpp
#include<bits/stdc++.h>
#define y0 kjdskjfkdsj
using namespace std;
int n,m,x0,y0,dp[110][110][4][2];
char mp[110][110],s[10];
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};

char readchar(){
	char c=getchar();
	while(c!='.'&&c!='*') c=getchar();
	return c;
}

int main(){
	scanf("%d%d%d%d",&m,&n,&x0,&y0);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			mp[i][j]=readchar();
	memset(dp,0x3f,sizeof(dp));dp[x0][y0][3][0]=0;
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		switch(s[0]){
			case 'L':{
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						for(int l=0;l<=3;l++)
							dp[j][k][l][i%2]=min(dp[j][k][l][(i%2)^1]+1,dp[j][k][(l+1)%4][(i%2)^1]);
				break;
			}
			case 'R':{
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						for(int l=0;l<=3;l++)
							dp[j][k][l][i%2]=min(dp[j][k][l][(i%2)^1]+1,dp[j][k][(l+3)%4][(i%2)^1]);
				break;
			}
			case 'F':{
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						for(int l=0;l<=3;l++)
							dp[j][k][l][i%2]=min(dp[j][k][l][(i%2)^1]+1,dp[j-dx[l]][k-dy[l]][l][(i%2)^1]);
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						if(mp[j][k]=='*')
							for(int l=0;l<=3;l++)
								dp[j][k][l][i%2]=0x3f3f3f3f;
				break;
			}
			case 'B':{
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						for(int l=0;l<=3;l++)
							dp[j][k][l][i%2]=min(dp[j][k][l][(i%2)^1]+1,dp[j+dx[l]][k+dy[l]][l][(i%2)^1]);
				for(int j=1;j<=m;j++)
					for(int k=1;k<=m;k++)
						if(mp[j][k]=='*')
							for(int l=0;l<=3;l++)
								dp[j][k][l][i%2]=0x3f3f3f3f;
				break;
			}
		}
	}
	int ans=0x3f3f3f3f;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			for(int l=0;l<=3;l++)
				ans=min(ans,dp[i][j][l][n%2]);
	printf("%d",ans);
}
```

---

## 作者：913887524gsd (赞：4)

这道题居然没有题解！！！（~~害我打了一晚上~~）

这是一道非常优（du）良（liu）的dp（damoni）好题，首先是一个矩阵，还有方向要求（注意初始的时候机器人的朝向是上方）我们很容易可以得出需要一个三维数组   d[i][j][k]去定义状态,其中i，j代表的是机器人所处在的位置，k代表的是方向。

然后这整一个状态是指机器人到达状态中最小拒绝次数。这样定义了状态之后就可以去开心（~~修仙~~）打代码了。如果根据状态去一步步递推在原数组上更改数值是一个非常愚蠢的方式（~~刚开始我就是这么打出来的~~），因为这样子会出现状态重叠的错误
（上一个状态的更改牵连到这一个状态的改变从而又在这个状态上进行这一轮状态更新），导致只能拿10分。

那么我们就可以想到再加一维[n]去记录每一步的值，但是这样会导致空间复杂度为m^2*n*4很浪费空间（会不会MLE我没有试过）。于是就需要滚动数组优化

如果看到这里还不知道如何去进行递推的话下面给出状态转移方程（back和right的状态就不重复列出了）

froward:d[i+dx[k]][j+dy[k]][k][flag^1]=d[i][j][k][flag];（被讨论的状态未确定）

d[i+dx[k]][j+dy[k]][k][flag^1]=min(d[i+dx[k]][j+dy[k]][k][flag^1],d[i][j][k][flag]);（被讨论的状态已经确定）

left   :d[i][j][(k-1+4)%4][flag^1]=d[i][j][k][flag];（被讨论的状态未确定）

d[i][j][(k-1+4)%4][flag^1]=min(d[i][j][(k-1+4)%4][flag^1],d[i][j][k][flag]);（被讨论状态已经确定）


注意一定要注意好dx和dy所代表的方向是上下左右，如果你有其他定义方法请另请高明

下面给出代码和注释：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int d[101][101][4][2];
char map[101][101];
char c[101];
int m,n,x,y,flag;
int dx[]={-1,0,1,0};//注意方向的设置 
int dy[]={0,1,0,-1};
int main()
{
	//freopen("data.txt","r",stdin);
	memset(d,-1,sizeof(d));//d的初值设为-1是为了确定状态是否存在 
	scanf("%d%d%d%d",&m,&n,&x,&y);
	d[x][y][0][0]=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			cin>>map[i][j];//读取单字符只好用cin 
	for(int t=1;t<=n;t++,flag^=1)//滚动数组优化 
	{
		scanf("%s",c+1);
		for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)for(int k=0;k< 4;k++)
		if(d[i][j][k][flag]!=-1)d[i][j][k][flag^1]=d[i][j][k][flag]+1;//先列出如果拒绝请求到下一个状态所要的时间 
		if(c[1]=='F')//根据读入数据的特性进行判断 
		{
			for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)for(int k=0;k< 4;k++)
			if(d[i][j][k][flag]!=-1)
			{
				if(i+dx[k]>0&&i+dx[k]<=m&&j+dy[k]>0&&j+dy[k]<=m&&map[i+dx[k]][j+dy[k]]!='*')
				{
					if  (d[i+dx[k]][j+dy[k]][k][flag^1]==-1)d[i+dx[k]][j+dy[k]][k][flag^1]=d[i][j][k][flag];
					else d[i+dx[k]][j+dy[k]][k][flag^1]=min(d[i+dx[k]][j+dy[k]][k][flag^1],d[i][j][k][flag]);
				}
			}
		}
		if(c[1]=='B')
		{
			for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)for(int k=0;k< 4;k++)
			if(d[i][j][k][flag]!=-1)
			{
				if(i-dx[k]>0&&i-dx[k]<=m&&j-dy[k]>0&&j-dy[k]<=m&&map[i-dx[k]][j-dy[k]]!='*')
				{
					if  (d[i-dx[k]][j-dy[k]][k][flag^1]==-1)d[i-dx[k]][j-dy[k]][k][flag^1]=d[i][j][k][flag];
					else d[i-dx[k]][j-dy[k]][k][flag^1]=min(d[i-dx[k]][j-dy[k]][k][flag^1],d[i][j][k][flag]);
				}
			}
		}
		if(c[1]=='L')
		{
			for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)for(int k=0;k< 4;k++)
			if(d[i][j][k][flag]!=-1)
			{
				if  (d[i][j][(k-1+4)%4][flag^1]==-1)d[i][j][(k-1+4)%4][flag^1]=d[i][j][k][flag];
				else d[i][j][(k-1+4)%4][flag^1]=min(d[i][j][(k-1+4)%4][flag^1],d[i][j][k][flag]);
			}
		}
		if(c[1]=='R')
		{
			for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)for(int k=0;k< 4;k++)
			if(d[i][j][k][flag]!=-1)
			{
				if  (d[i][j][(k+1)%4][flag^1]==-1)d[i][j][(k+1)%4][flag^1]=d[i][j][k][flag];
				else d[i][j][(k+1)%4][flag^1]=min(d[i][j][(k+1)%4][flag^1],d[i][j][k][flag]);
			} 
		}
	}
	int mi=1e8;//放一个极大值 
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k< 4;k++)
				if(d[i][j][k][flag]!=-1)mi=min(mi,d[i][j][k][flag]);
	printf("%d\n",mi);
	return 0;
}
```
~~只有风暴才能击倒大树~~，只有肝题才能认识到自己弱。。。。

---

## 作者：SFWR (赞：1)

好像题解中都没有怎么提到关于i%2与（i%2）^1的问题

我就重点说一下这个吧

首先我们明确的是，我们是不能不加第四维，如果我们不加第四维，就意味着直接在原数组上更改，这样的话我们经过模拟可以得知，并不满足DP的条件

这样我们就要考虑一下，我们还是要保存之前的数组，那么不难想到加入第四维L来表示第几步，但这样又会出现一个问题，$100*100*4*1000=4*10^7$是会爆空间哒

~~但由于本体数据较水，经实测L开到500即可~~

[https://www.luogu.org/recordnew/show/18717688](卡过记录)

我们就要考虑一下优化，既然L是由L-1转移得到，也就意味着L-1只会作用于L，而对之后的L并没有影响，这就是题解中所说的滚动数组所在，我们用i%2与(i%2)^1分别表示L与L-1，这样就把原来的空间大大减少，可以稳稳的过去了

[https://www.luogu.org/recordnew/show/18717533](改后记录)


QAQ

---

## 作者：FreedomKing (赞：0)

简单清晰的 dp 题。

### 思路

发现地图很小只有 $100\times 100$，操作数也很小，能很直接地想到可以对于每次操作维护以每个方向到达地图上每个点最少需要拒绝多少指令，时间复杂度是 $O(M^2N)$ 的可以通过。

关于状态转移，因为太多了而且很直观这里只简单举例。

设 $dp_{i,j,k,p}$ 代表在第 $p$ 次指令位于 $(i,j)$ 时面向 $k$ 的最小拒绝指令数量，其中 $k=0,1,2,3$ 分别表示朝上、右、下、左，由于题目内存限制比较小直接把 $p$ 这一维滚动掉就行。

指令分为移动和转向两类，转移都比较类似：

- 若指令为 `FORWARD`，对于点 $(i,j)$，考虑从上次状态的相邻的点前进到这里或拒绝指令，进行更新，有 $dp_{i,j,0,1}=\min(dp_{i,j,0,0}+1,dp_{i+1,j,0,0})$，其他情况类似见参考代码。

- 若指令为 `LEFT`，对于点 $(i,j)$，同样考虑从上次状态的同个点不同方向转到现在的方向或拒绝指令，进行更新，有 $dp_{i,j,0,1}=\min(dp_{i,j,0,0}+1,dp_{i,j,1,0})$，其他情况类似见参考代码。

### AC Code

因为懒得想更简洁的做法所以直接把转移展开了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+5;
inline int qread(){
#define qr qread()
	int x=0,t=1,ch=getchar();
	while(ch<'0'||ch>'9'){
		t^=(ch=='-');
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return (t?x:-x);
}
inline void qwrite(int x){
#define qw(_) qwrite(_)
#define qws(_) qw(_),putchar(' ')
#define qwe(_) qw(_),putchar('\n')
	if(x<0) x=-x,putchar('-');
	if(x>9) qw(x/10);
	putchar(x%10+'0');
	return;
}
inline int qpow(int x,int p,int mod){
	mod=(mod?mod:LONG_LONG_MAX);
	x=(p?x:1);
	int t=1;
	while(p>1){
		if(p&1) t=(t*x)%mod;
		x=(x*x)%mod;
		p>>=1;
	}
	return (x*t)%mod;
}
string s[N];
int dp[105][105][4][2];
signed main(){
	int n=qr,m=qr,x=qr,y=qr;
	memset(dp,0x3f,sizeof(dp));
	dp[x][y][0][0]=0;
	for(int i=1;i<=n;i++) cin>>s[i];
	int l=1;
	for(int p=1;p<=m;p++){
		string op;
		cin>>op;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(s[i][j-1]=='*') continue;
				if(op=="FORWARD"){
					dp[i][j][0][l]=min(dp[i][j][0][l^1]+1,dp[i+1][j][0][l^1]);
					dp[i][j][1][l]=min(dp[i][j][1][l^1]+1,dp[i][j-1][1][l^1]);
					dp[i][j][2][l]=min(dp[i][j][2][l^1]+1,dp[i-1][j][2][l^1]);
					dp[i][j][3][l]=min(dp[i][j][3][l^1]+1,dp[i][j+1][3][l^1]);
				}
				if(op=="BACK"){
					dp[i][j][0][l]=min(dp[i][j][0][l^1]+1,dp[i-1][j][0][l^1]);
					dp[i][j][1][l]=min(dp[i][j][1][l^1]+1,dp[i][j+1][1][l^1]);
					dp[i][j][2][l]=min(dp[i][j][2][l^1]+1,dp[i+1][j][2][l^1]);
					dp[i][j][3][l]=min(dp[i][j][3][l^1]+1,dp[i][j-1][3][l^1]);
				}
				if(op=="LEFT"){
					dp[i][j][0][l]=min(dp[i][j][0][l^1]+1,dp[i][j][1][l^1]);
					dp[i][j][1][l]=min(dp[i][j][1][l^1]+1,dp[i][j][2][l^1]);
					dp[i][j][2][l]=min(dp[i][j][2][l^1]+1,dp[i][j][3][l^1]);
					dp[i][j][3][l]=min(dp[i][j][3][l^1]+1,dp[i][j][0][l^1]);
				}
				if(op=="RIGHT"){
					dp[i][j][0][l]=min(dp[i][j][0][l^1]+1,dp[i][j][3][l^1]);
					dp[i][j][1][l]=min(dp[i][j][1][l^1]+1,dp[i][j][0][l^1]);
					dp[i][j][2][l]=min(dp[i][j][2][l^1]+1,dp[i][j][1][l^1]);
					dp[i][j][3][l]=min(dp[i][j][3][l^1]+1,dp[i][j][2][l^1]);
				}
			}
		}
		l^=1;
	}
	int ans=INT_MAX;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=0;k<=3;k++) ans=min(ans,dp[i][j][k][l^1]);
	qw(ans);
	return 0;
}
```

我写完后结果过不了样例，找了十分钟发现是最后统计答案统计的是倒数第二个状态，警钟长鸣。

---

## 作者：qiliu (赞：0)

# 思路

首先我们要知道一秒是能跑过 $1e7$ 的。~~然而我忘了。~~

我们设状态 $f_{i,j,k,s}$ 表示第 $s$ 步走到 $(i,j)$ 位置，面向方向 $k$ 时的最少拒绝次数。易得转移方程：

（设 $mov$ 指移面向方向 $k$ 移动时横纵坐标的变化量。）

- 当这一步是移动（以向前移动为例），则 $f_{i,j,k,s}=\min(f_{i,j,k,s-1}+1,f_{i-mov_{k,0},j-mov_{k,1},k,s-1})$ 即原地不动拒绝次数加一，或从上一次（即当前状态向后一步）向前一步得来。

- 当这一步是旋转操作（以向右旋转为例），则 $f_{i,j,k,s}=\min(f_{i,j,k,s-1}+1,f_{i,j,k-1,s-1})$ 即原地不动拒绝次数加一，或从上一次（即当前状态左转一次）右转一次得来。

-----

# Code

这里我定义的方向是 $3,0,1,2$ 分别对应上右下左，加一右转一次，实际可以凭个人喜好选择。


```cpp
#include<bits/stdc++.h>
#define int long long
//#define DEBUG(x) cerr<<#x<<'='<<x<<endl
#define endl '\n'
using namespace std;
int rd(){
    char t=getchar();int f=1,x=0;
    while(t<'0'||t>'9'){ if(t=='-')f*=-1; t=getchar(); }
    while(t>='0'&&t<='9') x=x*10+t-'0',t=getchar();
    return x*f;
}void wt(int t){
    if(t<0)putchar('-'),t=-t;
    if(t>9)wt(t/10);
    putchar(t%10+'0');
    return;
}
const int MAX_LEN=105,MAX_M=1005,INF=1e18;
int n,m,x_0,y_0,ans=INF;
bool mp[MAX_LEN][MAX_LEN];
int f[MAX_LEN][MAX_LEN][4][2];//3 0 1 2 上 右 下 左
//s 开两个滚动数组优化下空间，不然可能会炸
int book(string t){return t[0]=='F'?2:(t[0]=='B'?3:(t[0]=='L'?-1:1));}
int a[MAX_M];
int mov[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
signed main(){
    // ios::sync_with_stdio(false);
    // cin.tie(0);
    // cout.tie(0);
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    n=rd(),m=rd(),x_0=rd(),y_0=rd();
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){char t;cin>>t;mp[i][j]=(t=='*'?0:1);}
    for(int i=1;i<=m;i++){string t;cin>>t;a[i]=book(t);}
    memset(f,0x3f,sizeof(f));
    f[x_0][y_0][3][0]=0;
    for(int s=1;s<=m;s++)
        if(abs(a[s])==1){//右转+1，左转-1。
            for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
                if(mp[i][j]) for(int k=0;k<4;k++)
                    f[i][j][k][s&1]=min(f[i][j][(k-a[s]+4)%4][(s&1)^1],f[i][j][k][(s&1)^1]+1);}
        else if(a[s]==2){
            for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
                if(mp[i][j]) for(int k=0;k<4;k++)
                    f[i][j][k][s&1]=min(f[i-mov[k][0]][j-mov[k][1]][k][(s&1)^1],f[i][j][k][(s&1)^1]+1);}
        else if(a[s]==3){//若是后退，将减改成加即可。
            for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
                if(mp[i][j]) for(int k=0;k<4;k++)
                    f[i][j][k][s&1]=min(f[i+mov[k][0]][j+mov[k][1]][k][(s&1)^1],f[i][j][k][(s&1)^1]+1);}
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
        for(int k=0;k<4;k++) ans=min(ans,f[i][j][k][m&1]);
    wt(ans);
    // fclose(stdin);
    // fclose(stdout);
    return 0;
}
```

---

希望有帮到你。

---

## 作者：HNOIRPplusplus (赞：0)

一道很浅显而平凡的 DP 题。

我们设 $dp_{i,x,y,f}$ 表示机器人接受了 $x$ 个命令，位于坐标 $(x,y)$，并且现在的朝向是 $f$，在这种状态下它最少可以忽略多少个命令。

然后进行大暴力转移即可。

接下来是一些 tricks：

- 我们可以假设上方向为 $0$，然后顺时针排序，从而得到 $dx$ 数组为 $\{-1, 0, 1, 0\}$，$dy$ 数组为 $\{0, 1, 0, -1\}$。这样排列的好处在于 $dx_f$ 和 $dy_f$ 直接分别加在 $x$ 和 $y$ 上就可以求出来 $f$ 方向前进一步的新坐标，而且方向是很容易可以变换的。

- 如上定义的话，$(f+1)\bmod4$ 为 $f$ 顺时针旋转 $90\degree$ 的方向，而 $(f-1)\bmod4$ 就是逆时针旋转的方向。  
  不过，我们用位运算 $(f+1) \& 3$ 和 $(f+3) \& 3$ 可以优化一点常数，其中 $\&$ 是位运算与符号。可以看出 $f-1$ 和 $f+3$ 对 $4$ 取模效果一致，而对 $3$ 按位与和对 $4$ 取模也一样。

- 如果真的这么定义 $dp$ 状态，空间肯定会爆炸的。不过发现 $dp_i$ 开头的所有内容都只会转移到 $dp_{i+1}$，启示我们可以状态压缩。

综上所述，实际上这个题除了写代码以外的过程其实都很简单。遇到网格图问题，掌握上面的换向技巧，能够起到事半功倍的效果。

代码：
```
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int M = 105, N = 1005;
const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

int dp[2][M][M][4];
char c[M][M];

signed main() {
  int m, n, x0, y0;
  cin >> m >> n >> x0 >> y0;
  for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= m; j++) {
      cin >> c[i][j];
    }
  }
  for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= m; j++) {
      for(int k = 0; k < 2; k++) {
        for(int f = 0; f < 4; f++) {
          dp[k][i][j][f] = 1145141919810;
        }
      }
    }
  }
  dp[0][x0][y0][0] = 0;
  for(int i = 0; i < n; i++) {
    for(int x = 1; x <= m; x++) {
      for(int y = 1; y <= m; y++) {
        for(int f = 0; f < 4; f++) {
          dp[(i + 1) & 1][x][y][f] = 1145141919810;
        }
      }
    }
    string s;
    cin >> s;
    for(int x = 1; x <= m; x++) {
      for(int y = 1; y <= m; y++) {
        if(c[x][y] == '*') {
          continue;
        }
        for(int f = 0; f < 4; f++) {
          if(s == "LEFT") {
            dp[(i + 1) & 1][x][y][(f + 3) & 3] = min(dp[(i + 1) & 1][x][y][(f + 3) & 3], dp[i & 1][x][y][f]);
          } else if(s == "RIGHT") {
            dp[(i + 1) & 1][x][y][(f + 1) & 3] = min(dp[(i + 1) & 1][x][y][(f + 1) & 3], dp[i & 1][x][y][f]);
          } else if(s == "FORWARD") {
            dp[(i + 1) & 1][x + dx[f]][y + dy[f]][f] = min(dp[(i + 1) & 1][x + dx[f]][y + dy[f]][f], dp[i & 1][x][y][f]);
          } else {
            dp[(i + 1) & 1][x - dx[f]][y - dy[f]][f] = min(dp[(i + 1) & 1][x - dx[f]][y - dy[f]][f], dp[i & 1][x][y][f]);
          }
          dp[(i + 1) & 1][x][y][f] = min(dp[(i + 1) & 1][x][y][f], dp[i & 1][x][y][f] + 1);
          // cout << i << ' ' << x << ' ' << y << ' ' << f << ' ' << dp[i & 1][x][y][f] << '\n';
        }
      }
    }
  }
  int ans = n;
  for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= m; j++) {
      if(c[i][j] != '*') {
        for(int f = 0; f < 4; f++) {
          ans = min(ans, dp[n & 1][i][j][f]);
        }
      }
    }
  }
  cout << ans;
}
```

---

## 作者：smallpeter (赞：0)

# 不听话的机器人

## 题目描述

有一个 $M\times M$ 的矩阵，矩阵上有一些障碍物。机器人一开始位于  $(x_0,y_0)$，朝向上方。机器人收到 $N$ 条指令，但它不想走到障碍物上或走出边界，所以决定拒绝一些指令。求最少拒绝多少条指令？

指令 `FORWARD` 前进 1

指令 `BACK` 后退 1

指令 `LEFT` 左转 $90^{\circ}$

指令 `RIGHT` 右转 $90^{\circ}$

- $M\le 100$
- $N\le 1000$

## 题目解法

看到这题的数据范围，不难想到设计状态 $f_{i,x,y,tw}$ 表示处理到第 $i$ 个指令，当前位置为 $(x,y)$，朝向 $tw$ 状态。其中 0 状态为朝上，1 状态为朝右，2 状态为朝下，3 状态为朝左。

不难想到通过讨论第 $i$ 个指令拒不拒绝来转移状态。

### 状态转移

分几类情况讨论：

#### 1. 第 $i$ 条命令为 `FORWARD`
$$f_{i,x,y,tw}=\min(f_{i-1,x+w_{wt,0},y+w_{wt,1},wt},f_{i-1,x,y,tw}+1)$$

第一个状态表示第 $i$ 条指令执行了，由上个状态顺着方向走了一步到了 $(x,y)$。第二个状态表示第 $i$ 条指令没有执行，上个状态是怎样这个状态仍是怎样。

其中 $w_{tw,0}$、$w_{tw,1}$ 分别表示朝向状态行的变化和列的变化量。（下文中再次出现也是一样的意义）

#### 2. 第 $i$ 条命令为 `BACK`
$$f_{i,x,y,tw}=\min(f_{i-1,x-w_{wt,0},y-w_{wt,1},wt},f_{i-1,x,y,tw}+1)$$

跟上面的状态转移差不多，只不过一个是向前走一个是向后退。


#### 3. 第 $i$ 条命令为 `LEFT`
$$f_{i,x,y,tw}=\min(f_{i-1,x+w_{wt,0},y+w_{wt,1},wt},f_{i-1,x,y,tw}+1)$$

第一个状态表示第 $i$ 条指令执行了，由上个状态向左转了 $90^{\circ}$，到了此状态。第二个状态表示第 $i$ 条指令没有执行，上个状态是怎样这个状态仍是怎样。


#### 4. 第 $i$ 条命令为  `RIGHT`
$$f_{i,x,y,tw}=\min(f_{i-1,x+w_{wt,0},y+w_{wt,1},wt},f_{i-1,x,y,tw}+1)$$

跟上面的状态转移差不多，只不过一个是向左转 90°，另一个是向右转 90°。

### 初始化

一开始的时候机器人在 $(x_0,y_0)$ 的时候朝着上方，没有拒绝任何一条指令，于是初始化就是下方这个式子。

$$f_{0,x_0,y_0,1} = 0$$

### 细节

讲完重要部分再来讲讲细节，从 $A$ 状态**改变了一些状态**转移到了当前状态，于是 $A$ 状态是由当前状态**把改变的状态改回去**。所以 $A$ 状态走了一步，到了 $B$。而 $B$ 状态应退一步到 $A$。而不是前进一步。这是一个非常容易跳的坑。

当你满心欢喜的把按照状态码出来的代码交了上去，等待片刻，突然发现........全 MLE 了？？？？

第一维状态记录当前枚举到了第 $i$ 条指令，细心的读者肯定发现了第一维状态可以用滚动数组优化。于是这题就完美的解决了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e3+10,M=1e2+10,INF=1e8;

int m,n,x,y,f[2][M][M][4];//0为朝上，1为朝右，2为朝下，3为朝左 

int w[N][2]={{-1,0},{0,1},{1,0},{0,-1}};

char c[M][M];

string op[N];

int main()
{
	scanf("%d%d%d%d",&m,&n,&x,&y);
	for(int i=1;i<=m;i++)
	{
		cin>>(c[i]+1);
	}
	for(int i=1;i<=n;i++)
	{
		cin>>op[i];
	}
	memset(f,0x3f,sizeof(f));
	f[0][x][y][0]=0;//初始化 
	for(int i=1;i<=n;i++)  
	{
		for(int nowx=1;nowx<=m;nowx++)
		{
			for(int nowy=1;nowy<=m;nowy++)
			{
				if(c[nowx][nowy]=='*') continue;
				for(int tw=0;tw<4;tw++)
				{
					if(op[i]=="FORWARD") //执行前进指令的转移 
					{
						f[i&1][nowx][nowy][tw]=min(f[(i&1)^1][nowx][nowy][tw]+1,f[(i&1)^1][nowx-w[tw][0]][nowy-w[tw][1]][tw]);
					}
					else if(op[i]=="BACK") //执行后退指令的转移 
					{
						f[i&1][nowx][nowy][tw]=min(f[(i&1)^1][nowx][nowy][tw]+1,f[(i&1)^1][nowx+w[tw][0]][nowy+w[tw][1]][tw]);
					} 
					else if(op[i]=="LEFT") //执行左转90°的转移 
					{
						f[i&1][nowx][nowy][tw]=min(f[(i&1)^1][nowx][nowy][tw]+1,f[(i&1)^1][nowx][nowy][(tw+1)%4]);
					}
					else //执行右转90°的转移 
					{
						f[i&1][nowx][nowy][tw]=min(f[(i&1)^1][nowx][nowy][tw]+1,f[(i&1)^1][nowx][nowy][(tw+3)%4]);
					}
				}
			}
		}
	} 
	int sum=INF; 
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(c[i][j]=='*') continue;
			for(int tw=0;tw<4;tw++)
			{
				sum=min(sum,f[n&1][i][j][tw]);
			}
		}
	}
	printf("%lld\n",sum);
}
```

完结撒花~



---

## 作者：翼德天尊 (赞：0)

## Idea

首先有一点题目中没有说到，机器人的初始方向是朝上的。

然后考虑 dp。

很容易发现机器人的状态，是由横纵坐标，当前方向，以及已经进行了几次操作组成的。于是我们可以设 $dp_{k,i,j,f}$，表示已经进行了 $k$ 次操作，走到了位置 $(i,j)$，面向 $f$ 方向的最低拒绝指令次数。

这个状态的转移是非常好想的，根据题目要求，每一个状态都可以由上一个操作的状态直接赋值过来，表示进行该操作，也可以保持原答案加上 $1$，表示拒绝该操作，将两者取最小值即可转移。

但是我们发现这个状态最多会有 $100\times 100\times 1000\times 4$ 种，空间明显超额，又发现每一个操作的状态都只能由上一个操作转移过来，于是就可以考虑使用滚动数组，用 $0/1$ 表示当前进行到的操作，然后滚动转移即可。

----------

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1005;
const int M=105;
int m,n,sx,sy,zl[N],dp[2][M][M][4];
char ma[M][M],op[10];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
} 
int tule(int x){//左转函数
	if (x==0) return 2;
	if (x==1) return 3;
	if (x==2) return 1;
	if (x==3) return 0;
}
int turi(int x){//右转函数
	if (x==0) return 3;
	if (x==1) return 2;
	if (x==2) return 0;
	if (x==3) return 1;
}
int main(){
	memset(dp,0x3f,sizeof(dp));
	m=read(),n=read(),sx=read(),sy=read();
	for (int i=1;i<=m;i++){
		scanf("%s",ma[i]+1);
	}
	for (int i=1;i<=n;i++){
		scanf("%s",op);
		if (op[0]=='F') zl[i]=0;
		else if (op[0]=='B') zl[i]=1;
		else if (op[0]=='L') zl[i]=2;
		else zl[i]=3; 
	}
	dp[0][sx][sy][0]=0;
	for (int k=1;k<=n;k++){
		for (int i=1;i<=m;i++){
			for (int j=1;j<=m;j++){
				if (ma[i][j]=='*') continue;
				for (int f=0;f<4;f++){
					if (zl[k]==0) dp[k&1][i][j][f]=min(dp[(k-1)&1][i][j][f]+1,dp[(k-1)&1][i-dx[f]][j-dy[f]][f]);
					else if (zl[k]==1) dp[k&1][i][j][f]=min(dp[(k-1)&1][i][j][f]+1,dp[(k-1)&1][i+dx[f]][j+dy[f]][f]);
					else if (zl[k]==2) dp[k&1][i][j][f]=min(dp[(k-1)&1][i][j][f]+1,dp[(k-1)&1][i][j][turi(f)]);
					else dp[k&1][i][j][f]=min(dp[(k-1)&1][i][j][f]+1,dp[(k-1)&1][i][j][tule(f)]); 
				}
			}
		}
	}
	int ans=1e9;
	for (int i=1;i<=m;i++){
		for (int j=1;j<=m;j++){
			for (int f=0;f<4;f++)
				if (ma[i][j]!='*')
					ans=min(ans,dp[n&1][i][j][f]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---


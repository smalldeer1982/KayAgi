# 魔法物品

## 题目描述


有两种类型的物品：普通物品和魔法物品。普通物品没有魔法属性，而魔法物品拥有一些魔法属性。每种普通物品有一个价值 $P$，但每种魔法物品有两种价值：鉴定前的价值 $P_1$ 和鉴定后的价值 $P_2$（当然，$P_2$ 总是大于 $P_1$）。

为了鉴定一个魔法物品，你需要购买一个鉴定卷轴，用它来鉴定魔法物品。鉴定完一件魔法物品以后，鉴定卷轴便会消失。每个鉴定卷轴将会消耗 $P_i$ 元钱。如果没有足够的钱，你将无法购买任何鉴定卷轴。    
现在，你正在一个集市中，同时拥有很多物品。你知道每件物品的价值并且想要出售全部物品。那么，你最多能够获得多少钱呢？

你可以假定：

- 开始的时候你没有钱。
- 所有的魔法物品都还没有被鉴定。
- 只要你有足够的钱，你可以购买任意多的鉴定卷轴。

## 说明/提示

对于 $30\%$ 的数据，$1\le N \le 50$。  
对于 $100\%$ 的数据，$1 \le N \le 1000$。

## 样例 #1

### 输入

```
2 10
10
20 100
```

### 输出

```
100
```

# 题解

## 作者：Drifterming (赞：11)

```
//又是一个好(nan)题好(nan)题 
//首先，普通物品一开始就卖掉就可以，因为它不会增值
//至于魔法物品
//如果一个魔法物品使用了卷轴后的价值减去买卷轴的钱还不如鉴定前的价值高，那么我们鉴定这个魔法物品是要亏本的
//这样的魔法物品我们把它称为假的魔法物品，当成普通物品处理就好 
//否则如果鉴定之后可以赚钱，就把它称之为真的魔法物品 

//后边怎么体现买了卷轴的时候有点绕，其实看看算魔法药品利润的那个式子就很好理解了 
 
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<sstream>
using namespace std;

const int N=1005;
const int M=1e7+5;

int n,P;
int allv,v;
//allv是所有魔法物品鉴定前和普通物品的价值的和， v是普通物品的价值和，是初始资金 
int dp[M];
//dp[i]表示通过卖魔法物品得到i元钱所赔的最小利润的和 
int mf,p1[N],profit[N];
//mf是真真的魔法物品的数量，p1是是鉴定前的价值，profit是鉴定后能获取的利润 

int main()
{
	string S;
	scanf("%d%d",&n,&P);
	getline(cin,S);		//一定要用getline读换行，不要用getchar() 
	for(int i=1;i<=n;++i)
	{
		stringstream s;		//字符串流黑科技，不懂的百度 
		getline(cin,S);		//读入这一行的内容 
		s<<S;	//将字符串S转化成一个流字符串 
		int a,b;
		s>>a;	//第一个价值 
		allv+=a; 
		if(s>>b&&b-P-a>0)	//如果这是个真的魔法物品  s>>b表示这一行还有第二个数字，b-P-a>0表示鉴定之后能获得利润 
		{
			++mf;
			p1[mf]=a;	//鉴定前价值 
			profit[mf]=b-P-a;	//鉴定后价值 
		}
		else	//假的魔法物品，当成普通物品处理 
			v+=a;
	}
//	cout<<allv<<" "<<v;
	if(v<P)	//手中卖掉普通物品后的初始资金不够买卷轴 
	{
		for(int i=1;i<=allv-v;++i)	//卖掉鉴定前的真的魔法物品最多可以获得allv-v元钱 
			dp[i]=999999999;
		for(int i=1;i<=mf;++i)		//枚举魔法物品个数 
		{
			for(int j=allv-v;j>=p1[i];--j)	//卖魔法药品得到j元钱要损失多少利益 
			{
				dp[j]=min(dp[j],dp[j-p1[i]]+profit[i]);		//求最少损失 
			}
		}
		int minn=999999999;
		for(int i=P-v;i<=allv-v;++i)	//找最小损失    i=P-v是因为我们最少需要P-v元钱就可以买卷轴 
			minn=min(minn,dp[i]);
		if(minn==999999999)		//卖完所有的魔法药品仍然买不了卷轴，那么只能全部按鉴定前价格出售 
			printf("%d",allv);
		else	//能买卷轴了 
		{
			for(int i=1;i<=mf;++i)	//加上鉴定后能获得的的利润 
				allv+=profit[i];
			printf("%d",allv-minn);		//要减掉卖魔法物品的利润损失 
		}
	}
	else	//不卖魔法药品就能买卷轴 
	{
		for(int i=1;i<=mf;++i)	//加上利润 
			allv+=profit[i];
		printf("%d",allv);
	}
	return 0;
}
```

---

## 作者：xkcdjerry (赞：8)

dp 好题，来写一个题解 ~~顺便整一个超短解~~。

先考虑哪些东西一定要直接卖：  
* 普通物品（原因显然）
* 满足 $a_i \leqslant b_i-p$ 的魔法物品（买了卷轴鉴定之后的收益小于直接卖）

那么可以读入的时候就把这些物品变卖掉，只留下有价值讨论的物品：
```c++
for(i=0;i<n;i++)
{
    scanf("%d",&x);
    if(getchar()==' ')
    {
        scanf("%d",&y);
        if(x>=y-p) v+=x;
        else a[m]=x,b[m++]=y;
    }
    else v+=x;
}
```

顺便吐槽一句，这个题的输入比较恶心，翻了一下题解都是用 `stringstream` 科技或者是手写输入。  
但是实际上如果是魔法物品第一个数字后面是空格，反之是回车，利用这个特性并灵活使用 `getchar()` 函数可以简单判断是否是魔法物品。

接下来分类讨论，如果 $v \leqslant p$ 那就直接累加所有的 $b_i-p$ 即可（因为赚钱永远不会出现没钱买卷轴的情况）。

否则需要卖掉一些物品凑够买卷轴的钱。卖掉魔法物品 $i$ 会产生 $a_i$ 的现实收益并丢弃 $b_i-p$ 的未来收益，所以买掉它就会凑 $a_i$ 的钱（体积为 $a_i$）并且增加 $b_i-a_i-p$ 的损失（收益为 $b_i-a_i-p$）。  
可以看到这是 01 背包变体：01 背包要求总体积小于等于背包体积的前提下收益最大，而这个是要求总体积大于等于背包体积的前提下收益最小，所以也可以使用 dp 解决：
```c++
for(i=v+1;i<=p;i++) f[i]=inf;
for(i=0;i<m;i++) v+=b[i]-p;
for(i=0;i<m;i++) for(j=p;j>=a[i];j--)
    f[j]=min(f[j],f[j-a[i]]+b[i]-p-a[i]);
printf("%d",v-f[p]);
```
但是如果你这么交上去，会得到 [80 分](https://www.luogu.com.cn/record/69710787)的高分，原因是你可能变卖所有东西都无法凑够一个鉴定卷轴 ~~万恶的马太效应~~，所以需要特判这种情况并输出以未鉴定价格卖出所有物品。

最终代码：
```c++
#include <cstdio>
enum{inf=0x3f3f3f3f};
int n,p,m,a[1010],b[1010],f[5010],v,sv;
int min(int a,int b){return a<b?a:b;}
int main()
{
    int i,j,x,y;
    scanf("%d%d",&n,&p);
    for(i=0;i<n;i++)
    {
        scanf("%d",&x);
        if(getchar()==' ')
        {
            scanf("%d",&y);
            if(x>=y-p) v+=x;
            else a[m]=x,b[m++]=y;
        }
        else v+=x;
    }
    for(i=v+1;i<=p;i++) f[i]=inf;
    for(i=0,sv=v;i<m;i++) v+=b[i]-p,sv+=a[i];
    for(i=0;i<m;i++) for(j=p;j>=a[i];j--)
        f[j]=min(f[j],f[j-a[i]]+b[i]-p-a[i]);
    printf("%d",f[p]==inf?sv:v-f[p]);
}
```
[AC 记录](https://www.luogu.com.cn/record/69711967) （仅 25 行 594B 而且可读性也不差）

---

## 作者：cdcq (赞：7)


普通物品肯定直接卖了

令a原价，b为开后价，m为买卷的钱

b[i]-a[i]<=m的也直接卖了

接下来思考性质

1.开每个物品的花费是一样的

这个性质看上去比较吸引人

2.卖物品没有顺序，只需考虑开哪些物品

一开始想了个假解，就是忘了物品出售没有顺序的

3.开包一时爽，一直开包一直爽

本题的核心

需要注意到我们决定先开再卖的物品全部满足b[i]-a[i]>m

那么这些物品也满足b[i]>m

即如果开了一个物品，那么它的售价字词我们开下一个

结合性质1，只要先垫钱开一个物品，剩下的值得开的物品都安排上了

问题转化为垫够钱的前提下使损失最小

因为有些物品本来卖b[i]，为了垫钱只能卖a[i]

背包DP

f初值为负无穷，但f[普通物品和不值得卖的物品价格和]=0

背包容量为m+max{a}（比这个大的花费肯定不优，因为把a最大的物品拿掉后仍然能垫够钱）

然后令物品重量为a[i]，收益为a[i]-b[i]，往里塞，表示拿这个物品去攒钱

最后检查m到m+max{a}中的最大值即可（因为权值都是负的，所以最大权值为最小损失）

总复杂度O(nm)

----------------

这题是我通过DP标签找到的，一开始想各种DP没有任何思路

因为有后效性，顺序枚举物品的话，后边没枚举到的物品是否直接卖会影响到前边的物品能不能攒够钱买卷

（我也不知道这个算不算后效性，反正先考虑前i个物品的DP搞不成）

最后居然是先发现性质，然后DP解决子问题

非常有意思

以及，这题输入数据真糟

还好我读入处理玩得6，不喜欢字符串处理的同学要被练了

-----------------------

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int oo=1000000007;
int n,m;
int a[11000],b[11000];
bool flg[11000];
int f[21000];
char s[11000];  int lth;
int main(){
	//freopen("ddd.in","r",stdin);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		//scanf("%d%d",&a[i],&b[i]);
		char ch=getchar();
		while(ch=='\n'||ch=='\r')  ch=getchar();
		lth=0;
		while(ch!='\n'&&ch!='\r'){
			s[++lth]=ch;  //注意顺序
			ch=getchar();
		}
		bool flg=false;
		for(int j=1;j<=lth;++j){
			if(s[j]==' ')  flg=true;
			else if(!flg)  a[i]=a[i]*10+s[j]-'0';
			else  b[i]=b[i]*10+s[j]-'0';
		}
	}
	int bwl=0;
	for(int i=1;i<=n;++i){
		flg[i]=(b[i]-a[i]<=m);
		if(flg[i])  bwl+=a[i];
	}
	if(bwl>=m){
		for(int i=1;i<=n;++i)if(!flg[i])  bwl+=b[i]-m;
		printf("%d\n",bwl);
	}
	else{
		int M=20000;
		for(int i=0;i<=M;++i)  f[i]=-oo;
		f[bwl]=0;
		for(int i=1;i<=n;++i)if(!flg[i])
			for(int j=M;j>=a[i];--j)  f[j]=max(f[j],f[j-a[i]]+a[i]-b[i]+m);  //注意m
		int mx=-oo;
		for(int i=m;i<=M;++i)  mx=max(mx,f[i]);
		if(mx==-oo){
			for(int i=1;i<=n;++i)if(!flg[i])  bwl+=a[i];
			printf("%d\n",bwl);
		}
		else{
			for(int i=1;i<=n;++i)if(!flg[i])  bwl+=b[i]-m;  //注意m
			printf("%d\n",bwl+mx);
		}
	}
	return 0;
}




```

---

## 作者：Snitro (赞：3)

[http://blog.csdn.net/fine\_rose/article/details/72859562](http://blog.csdn.net/fine\_rose/article/details/72859562)

- **如果一个魔法物品，它的魔法值减去它的价值小于魔法卷轴的价格，那就说明购买魔法卷轴来件鉴定这件物品是无用的，因此将这类魔法物品视为普通物品**

- **普通物品由于没有魔法价值，因此只能将其出售，可以将普通物品的价值和视为初始资金 v (下同)**

- **分类讨论 v 与 p （魔法卷轴价格，下同） 的关系：**

     - **如果 v >= p:**

- **说明初始资金足够购买一个魔法卷轴，将购买卷轴后鉴定出的魔法物品按照魔法物品的价格售出后，将会获得更多的钱，而此时手中所拥有的钱肯定能够继续购买魔法卷轴来鉴定魔法物品**

- **因此如果初始资金 v >= p,那么可以将所有的魔法物品鉴定出来，并且按照魔法价格出售**

     - **如果 v < p：**

- **需要将一部分的魔法物品按照其价格售出，是资金足够购买魔法卷轴**

- **当能够购买一个魔法卷轴后按照 v >= p 的思路购买所有的魔法物品**

- **此部分需要使用动归计算最小损失和**

- **注意 ： 数据中会出现售出所有的魔法物品仍然不能购买一个魔法卷轴的情况**

- **注意 ： 所有数据均不会出现初始资金 v 能够购买魔法卷轴的情况**


##**源代码**


```cpp
#include<iostream>
#include<cstdio>
#include<sstream>
#include<cstring>
#include<algorithm>
using namespace std;
int f[10000005];
int n,p;
int th_len; // 魔法物品的个数
struct thing {
    int v;
    int p;
    int t;
}th[1005];
int main(){
    freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    string in;
    cin >> n >> p;
    getline(cin,in); // 读取换行
    int v = 0,allv = 0,callv;
    for(int i = 1;i <= n;i++){
        stringstream st;
        getline(cin,in);
        st << in;
        int a,b;
        st >> a;
        allv += a;
        if(st >> b && b - a > p){ // st >> b 读取成功 代表存在魔法属性
            th[++th_len].v = a;
            th[th_len].p = b;
            th[th_len].t = b - a - p; // 损失差，方便下一步的动归求解
        }else
            v += a;
    }
    callv = allv; //由于接下来会对 allv 进行操作，所以用 callv 保存所有物品的价格和，以便出现卖出所有魔法物品后仍无法购买卷轴时直接输出
    for(int i = 0;i <= th_len;i++){
        for(int j = 1;j <= allv;j++){
            f[j] = 999999999;
        }
    }
    if(p > v){ //当初始资金无法购买一个魔法卷轴
        for(int i = 1;i <= th_len;i++){
            for(int j = allv;j >= 1;j--){
                f[j] = f[j];
                if(j - th[i].v>= 0){
                    f[j] = min(f[j],f[j - th[i].v] + th[i].t);
                }
            }
        }
        int mi = 999999999;
        for(int i = p - v;i <= allv;i++)
            if(f[i] < mi)
                mi = f[i];
        for(int i = 1;i <= th_len;i++)
            allv += th[i].t;
        if(allv - mi <= 0)
            cout << callv;
        else
            cout << allv - mi;
    }else{ // 初始资金能够购买一个魔法卷轴
        for(int i = 1;i <= th_len;i++)
            allv += th[i].t;
        cout << allv;
    }
    return 0;
}
```

---

## 作者：zyxyzm_77 (赞：2)

首先，本题是一道DP**水题**。[消灭零题解。]

其次，我的程序时间空间都挺差的（好吧差的不是一点点……我没优化）。除了能把此题AC掉以外没有任何优点……（貌似缩进还能看？→\_→）


1.一边读入一边先计算普通物品的价值和S（要把p2-p1<=d的物品视作普通物品）。

2.此时如果S不足以买一个卷轴，对于魔法物品，动规。找出一个最小的损失和，满足p1之和加上之前的S够买第一个卷轴。

3.能够买第一个卷轴后，后面的都不是问题了……

4.对每个p2-p1，减去卷轴价值再动规。（直接用p1-p2动规来找最小值也不是不行，然而需要计算中间卖出的物品个数（这里大概需要记录路径……）并且在最小值方案有多种时选择物品个数最大的方案（这里的选择……我只搞出了一个并不怎么靠谱的做法，然后WA了……）……）

5.我真的不知道还能讲什么了……


另：从不同角度，贪心做法可以骗20分或40分。用递归也是40分。


以下为废话，强烈建议自动跳过。

一道水成这样的题犯了千奇百怪的错误提交了23遍才AC有点心塞，写篇题解纪念一下。其中十几遍提交都在和记录路径纠缠不清自己还乱搞出了两种奇怪的记录法和一种奇怪的貌似是动规的东西……没错我就是那个直接用p1-p2动规来找最小值的逗比。

交了22遍以后已经只想A掉没有心情优化了好吗好吗好吗！！！→\_→

以及感谢学弟的帮助。（虽然并没有把我从坑里拉出来最终还是自己跳出来的→\_→）

唔一不小心把本题平均分拉低了10分我觉得很抱歉……


代码如下：


```delphi

program luop1899;  
type GKing=record  
     x,y:longint;  
     end;  
var p:array[1..1000] of GKing;  
    x1:array[1..2] of longint;  
    i,j,n,d,s,k,kx,min,t,sp:longint;  
    f:array[-10000..5000,0..1000] of longint;  
  
begin  
  readln(n,d);  
  k:=0;  
  s:=0;  
  for i:=1 to n do  
    begin  
      kx:=0;  
      while not eoln do 
        begin  
          inc(kx);  
          read(x1[kx]);  
        end;  
      if kx=1 then s:=s+x1[1]  
              else  
          if x1[2]-x1[1]<=d then s:=s+x1[1]  
                          else  
              begin  
                inc(k);  
                p[k].x:=x1[1];  
                p[k].y:=x1[2]-x1[1];  
              end;  
      readln;  
    end;  
  
  if (s<d) and (k>0) then  
    begin  
      sp:=0;  
      t:=d-s;  
      for i:=1 to k do  
        begin  
          sp:=sp+p[i].x;  
          p[i].y:=p[i].y-d;  
        end;  
      if sp<t then  
        begin  
          writeln(s+sp);  
          halt;  
        end;  
      for i:=-10000 to 5000 do  
       for j:=0 to 1000 do  
         f[i,j]:=1000000;  
      for i:=0 to 1000 do //这边注意一下是0（我能说我为此差点跪了一次吗……） 
        for j:=-10000 to 0 do  
          f[j,i]:=0;  
      for i:=1 to k do  //动规在这里。
        for j:=1 to t do  
          begin  
            if f[j-p[i].x,i-1]+p[i].y>f[j,i-1]  
                               then f[j,i]:=f[j,i-1]  
                               else f[j,i]:=f[j-p[i].x,i-1]+p[i].y;  
          end;  //动规在这里。
      s:=s-f[t,k];  
    end;  
  
  for i:=1 to k do  
    s:=s+p[i].x+p[i].y;  
  writeln(s);  
end.

```

---

## 作者：yxy666 (赞：1)

这道题我的想法是先凑齐第一件鉴定卷轴的钱。很简单，由于普通物品不能升值，我们就先把普通物品先给全卖了。接下来我看一下是否买得起鉴定卷轴。如果买得起，我可以说以后我都可以买得起。因为我又不傻，鉴定后还亏本的我才不去鉴定呢。什么类型我们不用去鉴定呢？那就是普通售卖价格 $+$ 鉴定卷轴的价格 $>$ 鉴定后的价格。如果买不起，我就得牺牲一些魔法卷轴，贱卖出去，以便我能买得起第一件卷轴。简单来说，就是普通物品用贪心，魔法物品用动态规划，也是蛮有意思的了。

$code$ :
```
#include<bits/stdc++.h>
#define maxn 1005
#define maxv 5005
using namespace std;
int N,P,w[maxn],p[maxn],F[maxv],S[2],INF;
inline int read(){
	int ret=0;char ch=getchar();
	while (!isdigit(ch)) ch=getchar();
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
	return ret;
}
inline int read_check(int &x){
	int ret=0;char ch=getchar();
	while (!isdigit(ch)) ch=getchar();
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
	if (ch==' ') x=-1;else x=0;
	return ret;
}
int main(){
	N=read(),P=read();
	for (int i=1;i<=N;i++){
		int x;w[i]=read_check(x);
		S[0]+=w[i];
		if (!x) {S[1]+=w[i];continue;}
		p[i]=max(read()-P-w[i],0);
		if (!p[i]) S[1]+=w[i];else S[1]+=p[i]+w[i];
	}
	if (S[0]<P){printf("%d\n",S[0]);return 0;}
	memset(F,63,sizeof F);
	INF=F[0],F[0]=0;
	for (int i=1;i<=N;i++)
	for (int j=P-1;j>=0;j--)
	  if (F[j]!=INF) F[min(P,j+w[i])]=min(F[min(P,j+w[i])],F[j]+p[i]);
	printf("%d\n",S[1]-F[P]);
	return 0;
}
```


---

## 作者：YAOhc2012 (赞：1)

首先我们考虑普通物品，由于普通物品不用做决定。所以直接卖了它即可。

然后我们考虑魔法物品，如果这个物品鉴定后的价值减去鉴定卷轴的价格比它的鉴定前的价值还小，那么直接看作普通物品即可。

那么分类讨论，如果我手上的钱已经够买鉴定卷轴了，那么每个剩下的物品都可以获得鉴定后的价值减去鉴定卷轴的价格。

否则我们就要动态规划，我们定义 $dp_i$ 表示使我有 $i$ 元的最小亏损价格。

那么对于每个物品 $x$，令 $a_x$ 表示它鉴定前的价格，$b_x$ 表示它鉴定后的价格。

那么我们如果按鉴定前的价格卖出 $x$，会获得 $a_i$ 元，但是会在之后少得到 $b_i-P$ 元，所以它的亏损价格就是 $b_i-P-a_i$。然后我们直接看成背包问题即可。

注意当我卖掉所有的物品都不够买鉴定卷轴时那答案就是所有普通物品价格加上所有魔法物品鉴定前的价格。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,p,x[5005],y[5005],sum,dp[5005],s;
vector<pair<int,int>>v;
int main()
{
    cin>>n>>p;
    for(int i=1;i<=n;i++)
    {
        cin>>x[i];
        char ch=getchar();
        if(ch==' ')
        {
            cin>>y[i];
            if(y[i]-p<=x[i])sum+=x[i];
            else v.push_back(make_pair(x[i],y[i])),s+=x[i];
        }
        else sum+=x[i];
    }
    if(sum>=p)
    {
        int ans=sum;
        for(auto i:v)ans+=i.second-p;
        cout<<ans;
        return 0;
    }
    for(int i=sum+1;i<=p;i++)dp[i]=2e9;
    s=sum;
    for(auto i:v)sum+=i.second-p,s+=i.first;
    for(auto i:v)
    {
        for(int j=p;j>=i.first;j--)
        {
            dp[j]=min(dp[j],dp[j-i.first]-i.first-p+i.second);
        }
    }
    if(dp[p]==2e9)cout<<s;
    else cout<<sum-dp[p];
    return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：0)

## 题目大意

- 给定 $n$ 个物品，有一些是魔法物品，一些普通物品。

- 普通物品仅有一个价值 $P$，而魔法物品有鉴定前的价格 $P_1$，和鉴定后的价格 $P_2$。

- 鉴定一个物品需要花费 $P_i$ 元买魔法卷轴，假设魔法卷轴足够多。

- 现在你要卖出这些物品，那么你最多能赚多少钱。要注意的是卖出物品是**有顺序的**。

## 解题思路

首先，普通物品可以直接卖出，假设卖出后得到了 $s$ 元。

实际上，对于每一个魔法物品，如果 $P_2-m<P_1$，还不如直接卖出，于是我们按照 $P_2-P_1$ 作为关键字排序，把鉴定会亏本的魔法物品也卖出。

如果卖完上述物品后 $s>m$，也就是说，我们可以买卷轴了，因为剩下的物品鉴定后总比鉴定前赚得多，所以全部进行鉴定即可，答案为：

$$s+\sum_{i=1}^{z}(P_{i,2}-m)$$

其中 $z$ 为鉴定后不亏本的魔法物品的数量。

若 $s<m$，也就是我们需要卖出一些不亏本的魔法物品，以购买卷轴，假设 $D_i$ 为一个物品鉴定后比鉴定前多赚的钱，我们需要从中取一些魔法物品所组成的集合 $T$，使得

 $$(1)\ \ \ s+\sum_{i\in T}P_{i,1}\geq m$$
 $$(2)\ \ \ \min(\sum_{i\in T} D_i)$$

很容易想到 dp。

假设 $f_i$ 为卖出有收益的魔法物品共 $i$ 元时的最小损失，于是得到转移方程：

$$f_i=\min(f_i,f_{i-P_{j,1}}+d_j)$$

需要注意的是，$f$ 数组的初始值应为无穷大。

## 参考代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e3+5;
const int MR=1e4+5;
int n,m;
int p1,p2;
int ap=0;
int s=0,z=0,minn=1e9;
bool flag=true;
int f[MR];
struct thing{
	int before,now,bader;
}a[MAXN];
bool read(){
	p1=p2=0;
	char c=getchar();
	while(c>'9'||c<'0') c=getchar();
	while(c>='0'&&c<='9') p1=10*p1+c-'0',c=getchar();
	while(c>'9'||c<'0'){
		if(c=='\n'||c=='\r')
			return false; 
		c=getchar();
	} 
	while(c>='0'&&c<='9') p2=10*p2+c-'0',c=getchar();
	return true;
}
bool cmp(thing x,thing y){
	return x.now-x.before>y.now-y.before;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		if(read()){
			a[++z].before=p1,a[z].now=p2-m;
			ap+=p1;
		}
		else
			s+=p1;
	}
	ap+=s;
	sort(a+1,a+z+1,cmp);
	while(a[z].now<a[z].before)
		s+=a[z--].before;
	for(int i=1;i<MR;i++)
		f[i]=1e9;
	for(int i=1;i<=z;i++)
		for(int j=MR-1;j>=a[i].before;j--)	
			f[j]=min(f[j],f[j-a[i].before]+a[i].now-a[i].before);
	if(s>=m)
		minn=0;
	else
		for(int i=m-s;i<MR;i++)
			minn=min(minn,f[i]);
	if(ap<m){
		for(int i=1;i<=z;i++)
			s+=a[i].before;
		cout<<s;
	}
	else{
		for(int i=1;i<=z;i++)
			s+=a[i].now;
		cout<<s-minn;
	}
}
```


---

## 作者：Jayton (赞：0)


**普通物品开局卖** 

AND魔法物品咩···

1.若某个魔法物品消耗了卷轴后但价值减去买卷轴的钱还不如鉴定前的价值高呢 ，或者说是亏本买卖，就说这个东东为浮云魔法物品**那么浮云类魔法物品就当成普通滴物品来算咧**
 
2.先存点钱$_$，然后安排所有真魔法物品
那么此题就变为在存￥的情况下浪费最少

**3.物品没顺序！！
那么可以先把所有浮云类魔法物品&普通物品先卖掉攒攒钱，接下来在用卷轴**。

4.买了第一个卷轴，剩下的都不是问题 

5.若不够钱，~~借钱~~，**DP啊** 

**那么，本题就成了是先卖掉浮云类魔法物品&普通物品后，让剩下的魔法物品获得的利益尽量高**
 —— 
------------
**上代码！**
```
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1100],b[1100],f[1100000],tot,cnt,mon;
string s1;
int main(){
	scanf("%d%d",&n,&k);
	getline(cin,s1);
	for(int i=1;i<=n;i++){
		stringstream s;
		getline(cin,s1);
		s<<s1;
		int x,y;
		s>>x;
		tot+=x;
		if(s>>y&&y-x>k){
			a[++cnt]=x;
			b[cnt]=y-x-k;
		}
		else mon+=x;
	}
	if(mon>=k){
		for(int i=1;i<=cnt;i++)tot+=b[i];
		cout<<tot;
	}
	else {
		for(int i=1;i<=tot-mon;i++)f[i]=1e9;
		for(int i=1;i<=cnt;i++){
			for(int j=tot-mon;j>=a[i];j--){
				f[j]=min(f[j],f[j-a[i]]+b[i]);
			}
		}
		int wax=1e9;
		for(int i=tot-mon;i>=k-mon;i--){
			wax=min(wax,f[i]);
		}
		if(wax==1e9)cout<<tot;
		else {
			for(int i=1;i<=cnt;i++){
				tot+=b[i];
			}
			cout<<tot-wax;
		}
	}
}
```



------------
 注：

1、DP要用好

2、getline(cin,s1);意为从指定输入流文件中读入一行字符串给s1

3、多重判断，找出最值得用卷轴的魔法物品

**求管理员通过QAQ**

---

## 作者：Rainbow_qwq (赞：0)



[P1899 魔法物品](https://www.luogu.com.cn/problem/P1899)

---

一开始看到这个题目，觉得就是个贪心水题。

对于普通物品，直接卖了拿钱。

对于魔法物品，如果 $P1\ge P2-P$ 那拿去鉴定反而会亏钱，也直接当普通物品，卖了拿钱。

剩下的鉴定，当魔法物品卖了。

~~然后就会发现WA了~~

为什么呢？因为卖了拿钱后，不一定能买一个鉴定卷轴，钱不够。此时只好把一些魔法物品当普通物品卖，凑到买鉴定卷轴的钱。

考虑 $\text{DP}$ 。

设$f[i]$表示到把一些魔法物品当普通物品卖卖了$i$元钱，“损失”最少的钱。

这里“损失”的意思是把一些件魔法物品当普通物品，会少多少钱，就是 $P2_i-P1_i-P$ 元。

转移方程：

$f(i)=min(f(i),f(\max(i-P1[j],0))+P2[j]-P1[j]-p)$

意思是，先凑 $\max(i-P1[j],0)$ 元（就是 $f[\max(i-P1[j],0)]$ ），然后卖了 $j$ 这件物品，损失 $P2[j]-P1[j]-p$ 元。

这里取$\max$是为了不 `RE`。

边界条件：$f[0]=0$，设 $sum=\sum \text{普通物品价值}$ ， 答案就是$sum-f[p-sum]+\sum P2[i]-p$ 。

代码：
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
#define maxn 1003
int n,p,res;
int tot,a[maxn],b[maxn];
int f[10007];
signed main()
{
	n=read(),p=read();
	For(i,1,n){
		int x,y;cin>>x;
		if(getchar()==' '){
			cin>>y;
			if(y-p<=x)res+=x;
			else a[++tot]=x,b[tot]=y;
		}else res+=x;
	}
	if(res>=p){
		For(i,1,tot)res+=b[i]-p;
		cout<<res;
		return 0;
	}
	//f[i]:装>=i时最小代价
	//f[i]=min(f[max(i-a[j],0)]+b[j]-a[j]-p)
	memset(f,63,sizeof f);f[0]=0;
	For(j,1,tot)
		Rep(i,p-res,1)
			f[i]=min(f[i],f[max(i-a[j],0)]+b[j]-a[j]-p);
	if(f[p-res]>=0x3f3f3f3f){
		For(i,1,tot)res+=a[i];
		cout<<res;
		return 0;
	}
	res-=f[p-res];
	For(i,1,tot)res+=b[i]-p;
	cout<<res;
    return 0;
}
```

---


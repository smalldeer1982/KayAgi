# 长方形

## 题目描述

小明今天突发奇想，想从一张用过的纸中剪出一个长方形。

为了简化问题，小明做出如下规定：

（1）这张纸的长宽分别为 $n,m$。小明将这张纸看成是由$n\times m$个格子组成，在剪的时候，只能沿着格子的边缘剪。

（2）这张纸有些地方小明以前在上面画过，剪出来的长方形不能含有以前画过的地方。

（3）剪出来的长方形的大小没有限制。

小明看着这张纸，想了好多种剪的方法，可是到底有几种呢？小明数不过来，你能帮帮他吗？


## 说明/提示

【数据规模】

对 $10\%$ 的数据，满足 $1\leq n\leq 10,1\leq m\leq 10$

对 $30\%$ 的数据，满足 $1\leq n\leq 50,1\leq m\leq 50$

对 $100\%$ 的数据，满足 $1\leq n\leq 1000,1\leq m\leq 1000$


## 样例 #1

### 输入

```
6 4
....
.***
.*..
.***
...*
.***```

### 输出

```
38```

# 题解

## 作者：铃宕 (赞：128)

#### 使用单调栈求解 O（nm）

------------

*update 于 2019-8-11*
~~ _写得很差，建议还没看过的就不要看了_ ~~

------------

>我们要解决的第一个问题是如何求总方案数

1. 对每一行统计以其为底边构造的长方形的数量(怎么求后面讲)

1. 每行的方案数之和及为总方案数（因为一个长方形不可能有两个底边，所以此方法可以保证**不重不漏**）


------------

>那么怎么求对每一行统计以其为底边构造的长方形的方案数呢？


------------

>>首先我们了解一下什么是单调栈（不过神犇们都应该会了）

##### 1.定义 

单调栈是一种可以以 $O(n)$ 的时间复杂度解决类似求对于每一个数 $i$ **左边**（或**右边**）第一个（从 $i$ 开始）比它**小**（或**大**）的数的问题的算法 ~~（语文不好）~~

下面以求对于每一个数 $i$ 左边第一个（从 $i$ 开始）不大于它的数为例

##### 2. 怎么做？

首先定义一个栈（先进后出）栈中存的是目前**还没有答案的数**，易得栈中元素**递减**（不然与栈的定义不符），对于每一次要将元素压入栈，先将栈顶**所有大于**它的元素记录答案（就是要压入的元素）并弹出，因为我们要求左边第一个，所以以**从右向左**的顺序入栈（因为是先入栈再记录答案，所以要从元素从答案入栈）
```
//代码，单调栈
void ddzl(){
    top=0;//清空栈
    for(int i=m;i>=1;i--){
        while(top!=0&&h[i]<=h[k[top]]) l[k[top]]=i,top--;//记录答案
        top++;
        k[top]=i;//入栈
    }
    while(top) l[k[top]]=0,top--;//对没有答案做特殊处理
}
```


------------

>>扯了一堆，是时候说如何统计以其为底边构造的长方形的方案数了

1. 定义 $h_i$ 为当前行第 $i$ 列可**向上延伸**多少（即有多少为图画的块，如果当前块被图画那么值为$0$）

1. 使用单调栈算出 $l_i$ 和 $r_i$ ，分别是 $h$ 中**左边第一个**（从 $h_i$ 开始）**不大于** $h_i$ 的数和**右边第一个**（从 $h_i$ 开始）**小于** $h_i$ 的数

1. 对每一列求出被这一列的高度限制的长方形数，即为($i$ $-$ $l_i$)$\times$($r_i$ $-$ $i$)$\times$ $h_i$ 将所有列的答案相加就是以当前行为底边构造的长方形的方案数了

**为什么第3步不会重复：** 有重复是只有一种情况，即当 $l_i$ 到 $r_i$ 之间有一个 $j$ 使 $h_j$ 小于 $h_i$ ，但是这是不可能的，因为$l_i$ 和 $r_i$ 分别是 $h$ 中**左边第一个**（从 $h_i$ 开始）**不大于** $h_i$ 的数和**右边第一个**（从 $h_i$ 开始）**小于** $h_i$ 的数，所以在 $l_i$ 到 $r_i$ 之间不存在 $j$ 使 $h_j$ 小于 $h_i$

**举个例子：**

```cpp
对于某条情况如下图的底边
（0为没图画，1为有图画）
     0 1 0 1 0 0
     1 0 1 0 1 0
     1 0 0 1 0 0
     1 0 1 0 0 0
   h:0 3 0 1 2 4
   l:0 1 0 3 4 5
   r:7 3 7 7 7 7
方案：0 3 0 3 4 4
总方案数：14，验算后发现没错
```

#### update:

关于一些问题的解答：

> Q1：为什么公式是这样的呢？

**解答：** 对于**每次**求方案数，我们要先选**底边**（叫底边好像不太合理，凑合着看吧），由于我们是要求被这一列的高度限制的长方形数，所以底边**必须包含这一列**，那么底边**左端点的方案数**即为 $i$ $-$ $l_i$，同理**右端点的方案数**为 $r_i$ $-$ $i$，**底边的方案数**即为($i$ $-$ $l_i$)$\times$($r_i$ $-$ $i$)，而**高的方案数**则为 $h_i$ (不要理会这个称呼)，所以公式就是 ($i$ $-$ $l_i$)$\times$($r_i$ $-$ $i$)$\times$ $h_i$

> Q2: 为什么 $l_i$ , $r_i$ 是一个不大于，一个小于呢?

**解答：**一个不大于，一个小于是因为如果有**相邻**的且  $h_i$ **相等** 的，两个都是不大于会**有重复**，而两个都是小于有会有一些长方形**没数到**，而,一个不大于，一个小于是相当于**去了重复的**

------------

>时间复杂度

$O(nm)$，单调栈复杂度 $O(m)$ ,因为有 $n$ 行，所以复杂度为 $O(nm)$
 

------------

##### code
```cpp
#include<bits/bycx++.h>
using namespace std;
char ch;
long long l[1020],r[1020],h[1020],k[1020],n,m,top;
int d[1020][1020];
long long ans;
void ddzl(){//单调栈，前面的代码有注释
    top=0;
    for(int i=m;i>=1;i--){
        while(top!=0&&h[i]<=h[k[top]]) l[k[top]]=i,top--;
        top++;
        k[top]=i;
    }
    while(top) l[k[top]]=0,top--;
}
void ddzr(){//同上
    top=0;
    for(int i=1;i<=m;i++){
        while(top!=0&&h[i]<h[k[top]]) r[k[top]]=i,top--;
        top++;
        k[top]=i;
    }
    while(top) r[k[top]]=m+1,top--;
}
void work(){
    ddzl();
    ddzr();//两次单调栈预处理l，r
    for(int i=1;i<=m;i++){
        ans+=(i-l[i])*(r[i]-i)*h[i];//统计
    } 
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){//输入
        for(int j=1;j<=m;j++){
            cin>>ch;
            if(ch=='*') d[i][j]=1;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){h[j]++;if(d[i][j]) h[j]=0;}//预处理h
        work();统计当前行
    }
    cout<<ans;//输出
//} 不要抄代码
```
头文件防抄袭

有问题请私信作者

---

## 作者：3493441984zz (赞：53)

# 本蒟蒻只会$n^3$

唉，还是太弱了，靠刷点水题过日子


------------
# 思路：

我们枚举出矩形左下角的点，坐标为$(i,j)$，并且枚举这个点向右的长度$k$，那么以$(i,j)$为左下角，宽度为$k-j+1$的矩形自然就是能向上扩展的高度最小值了，光说可能不太清楚，下面模拟一下（有图哦$qwq$）

我们以下面为例子，粗略讲一下（不会全部模拟）

样例：

$4$

$WWWW$

$WWBW$

$WWWW$

$WWWW$

那么假设我们枚举$i,j$分别为$4,1$，也就是第四行第一列，那么我们向右枚举$k$

当$k=1$时，我们求出以$i,j$为左下角，宽度为$k-j+1$也就是$1$的矩形有多少个，我们可以看到有$4$个，分别是:

![](https://i.loli.net/2019/02/12/5c62baaac721d.png)
![](https://i.loli.net/2019/02/12/5c62baee7c52f.png)
![](https://i.loli.net/2019/02/12/5c62bb6bbdcf1.png)
![](https://i.loli.net/2019/02/12/5c62bba2a8f1e.png)

我们其实可以发现就是能向上扩展的高度个矩形

当$k=2$时,我们发现以$i,j$为左下角，宽度为$2$的矩形也有$4$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bc64a2f0b.png)
![](https://i.loli.net/2019/02/12/5c62bc88ce1fb.png)
![](https://i.loli.net/2019/02/12/5c62bca0b5c98.png)
![](https://i.loli.net/2019/02/12/5c62bcbbbd140.png)

当$k=3$时，我们发现以$i,j$为左下角，宽度为$3$的矩形有$2$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bd1f2eb35.png)
![](https://i.loli.net/2019/02/12/5c62bd37ac4c3.png)

当$k=4$时，我们发现以$i,j$为左下角，宽度为$4$的矩形有$2$个，分别为：

![](https://i.loli.net/2019/02/12/5c62bd9e0c7ac.png)
![](https://i.loli.net/2019/02/12/5c62bdbb22180.png)

那么到这里我们就枚举出了左下角为$4,1$的所有矩形

而且我们可以发现，矩形个数就是能向上扩展的高度

那么我们会枚举$i,j$，让每一个点作为矩形左下角，同时枚举宽度，一层一层下来，最后就是不遗漏的所有矩形个数，具体证明就省略了，自己想想就知道了

时间复杂度$O(n^3)$

下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1007
#define int long long
using namespace std;
int n,m,now,ans;
int high[N];
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			char in;
			scanf(" %c",&in);
			if(in=='.')
				++high[j];
			else
				high[j]=0;
		}
		for(int j=1;j<=m;++j)
		{
			now=high[j];
			for(int k=j;k<=m;++k)
			{
				if(!high[k])
					break;
				now=min(now,high[k]);
				ans+=now;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
}
~~~

---

## 作者：Caro23333 (赞：35)

楼上的题解很强......但是我认为对于我这种蒟蒻来说讲得不是很清楚，所以我再写一个略有不同的做法吧。

这道题呢我首先考虑的是，计算出包含至少一个画过的点的方案数，再用总的方案数减去它即可。

那么对于一个点(i,j)，考虑以它为右下角的矩形中，有多少个包含了至少一个画过的点。

我们发现，如果在以(i,j)这个点为右下角，以(1,1)为左上角的矩形中，找到所有已经被画过的点，设为(x,y)，将以(x,y)为右下角，以(1,1)为左上角的矩形范围打上一个标记，那么以(i,j)为右下角的矩形中，包含至少一个画过的点的矩形数量，就是被标记的点的数量。

这是很容易理解的，因为以(i,j)为右下角的矩形包含至少一个画过的点，当且仅当它的左上角被标记过，这样在它左上角的右下方会有至少一个画过的点。

我们如何对于(i,j)去统计这样被标记的点的数量呢？

从上到下、从左到右遍历(i,j)，维护一个数组maxa,其中maxa[j]表示在前i行，第j列上最靠下的的已经画过的点的纵坐标

然后维护一个栈stack,使得对于栈中任意的两个元素i,j，其中i在j的上方，有i>j且maxa[i]<maxa[j]（这样的栈也被称作**单调栈**）

在从左到右遍历j的时候，每次都更新栈的元素，使得j在栈顶并且满足这个单调栈的性质

那么对于这个点j，考虑压入j之前栈顶的元素k(maxa[k]>maxa[j]且j>k)，对于j这个点的答案就是对于k点的答案再加上maxa[j]*(j-k)

可以理解为在k以及k之前的列都没有被j这一列上画过的点打上新的标记，而k+1~j这些列的1~maxa[j]行都被第j列的标记覆盖了

那么最后输出的答案就是n*(n+1)*m*(m+1)/4（总方案数）再减去每个点之前统计的数量

qwq

代码:
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>

using namespace std;
const int MAXN = 1005;
typedef long long ll;
int n,m,map[MAXN][MAXN],maxa[MAXN],stack[MAXN],tmp[MAXN],top = 0;

int main()
{
    char c;
    cin >> n >> m;
    for(int i = 1; i<=n; i++)
        for(int j = 1; j<=m; j++)
        {
            cin >> c;
            map[i][j] = c=='*';
        }
    ll ans = (ll)n*(ll)m*(ll)(n+1)*(ll)(m+1)/4;
    for(int i = 1; i<=n; i++)
    {
    	memset(stack,0,sizeof(stack));
    	memset(tmp,0,sizeof(tmp));
    	top = 0;
        for(int j = 1; j<=m; j++)
        {
            if(map[i][j]) maxa[j] = i;
            while(top>0&&maxa[stack[top]]<=maxa[j]) top--;
            ans -= tmp[j] = tmp[stack[top]]+maxa[j]*(j-stack[top]);
            stack[++top] = j;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：loceaner (赞：21)

## [传送门](https://www.luogu.org/problem/P1950)

## 思路

首先定义$h$数组，$h[i][j]$表示第$i$行第$j$列最多可以向上延伸多长（直到一个被用过的格子）

然后使用单调栈算出 $l_i$和 $r_i$ ，分别是 $h[i]$ 中左边第一个（从 $h[i][j]$ 开始）不大于$h[i][j]$的数和右边第一个（从$h[i][j]$开始）小于$h[i][j]$的数

最终答案为$ans +=\ (j - l[j]) * (r[j] - j) * h[i][j]$

即在当前行i中，左边在$l[j]$到$j$之间任选位置，右边在$j$到$r[j]$之间任选位置，相乘便得到了底边的方案，高的方案是$h[i][j]$，所以再乘$h[i][j]$

## 代码
```cpp
//知识点:单调栈 
/*
By:Loceaner
*/
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

const int N = 1e3 + 11;

int n, m, h[N][N], st[N], l[N], r[N], top = 0;
char a[N][N];
long long ans;

inline void work(int x) {
	top = 0;
	for(int i = 1; i <= m; ++i) {
		while(top && h[x][st[top]] >= h[x][i]) {
			r[st[top--]] = i;
		}
		st[++top] = i;
	}
	while(top) r[st[top--]] = m + 1;
	for(int i = m; i >= 1; --i) {
		while(top && h[x][st[top]] > h[x][i]) {
			l[st[top--]] = i;
		}
		st[++top] = i;
	}
	while(top) l[st[top--]]=0;
}

int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; i++) scanf("%s", a[i] + 1);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i][j] == '*') h[i][j] = 0;
			else h[i][j] = h[i - 1][j] + 1;
		}
	}
	for(int i = 1; i <= n; i++) {
		work(i);
		for(int j = 1; j <= m; j++) {
			ans += (j - l[j]) * (r[j] - j) * h[i][j];
		} 
	}
	cout << ans << '\n';
	return 0;
}

```

---

## 作者：wlzhouzhuan (赞：14)

题目链接：[洛谷P1950 长方形](https://www.luogu.com.cn/problem/P1950)

## Description

给定你一个$n\times m$的矩阵，询问有多少个内部全是$1$的子矩阵。

数据范围$1\le n,m\le 1000$。

## Solution

先想如何暴力。

枚举这个子矩阵的两长和两宽，在暴力$check$该子矩阵内的所有点是否为$1$。

复杂度：$O(n^6)$，期望得分：$10$分。

我们发现，这个$check$部分可以利用**二维前缀和**来优化，因此可以预处理$cnt[i][j]=\sum_{p=1}^{i}\sum_{q=1}^{j}a_{i,j}$。

复杂度：$O(n^4)$，期望得分：$30$分。

考虑框定了该子矩形的**左端**和**右端**，那么我们可以扫**行**，并进行**简单计数**即可。

复杂度：$O(n^3)$，期望得分：$30$~$100$分。

接下来，我们用：

$h_{i,j}$表示$(i,j)$这个点往上连续$1$的最长长度。

$l_{i,j}$表示从$(i,j)$开始第一个满足$h_{i,l_{i,j}}\le h(i,j)$的点，如果不存在，令$l_{i,j}=0$。

$r_{i,j}$表示从$(i,j)$开始第一个满足$h_{i,r_{i,j}}\le h(i,j)$的点，如果不存在，令$r_{i,j}=m+1$。

那么，对于$(i,j)$为矩形底的贡献，就是$val=(j-l_{i,j})*(r_{i,j}-j)*h_{i,j}$。

考虑一下，这样做如何保证答案不重不漏。

**不重**：当且仅当在同一行存在两个数$l_{i,j_1}=l_{i,j_2}$并且$r_{i,j_1}=r_{i,j_2}$的时候，才有可能算重矩形。
但是这种情况是不存在的，因为$l_{i,j}$满足了左边第一个小于等于的，右边第一个小于的，显然无法构造出这种情况。

**不漏**：对于一个矩形，总有一个$l_{i,j},r_{i,j}$能框住一个矩形的两边，故这个矩形一定能被计算到。

我们可以通过一个单调栈来计算$l_{i,j}$和$r_{i,j}$，复杂度$O(n^2)$。

但是我写代码的时候$sb$了，所以用了一个单调队列来维护，但本质上是一样的。

###Code

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;

#define rint register int
const int N = 1005;
bool a[N][N];
int h[N][N], l[N][N], r[N][N], n, m;

deque <int> deq;

void push_l(int i, int j) {
  while (!deq.empty() && h[i][deq.back()] > h[i][j]) r[i][deq.back()] = j, deq.pop_back();
  deq.push_back(j);
}
void push_r(int i, int j) {
  while (!deq.empty() && h[i][deq.back()] >= h[i][j]) l[i][deq.back()] = j, deq.pop_back();
  deq.push_back(j);
}

int main() {
  scanf("%d%d", &n, &m);
  for (rint i = 1; i <= n; i++) {
    for (rint j = 1; j <= m; j++) {
      char x = getchar();
      while (x != '.' && x != '*') {
        x = getchar();
      }
      a[i][j] = x == '.';
    }
  }
  for (rint j = 1; j <= m; j++) {
    for (rint i = 1; i <= n; i++) {
      if (a[i][j]) h[i][j] = h[i - 1][j] + 1;
      else h[i][j] = 0;
    }
  }
  long long ans = 0ll;
  for (rint i = 1; i <= n; i++) {
    while (!deq.empty()) deq.pop_back();
    for (rint j = 1; j <= m; j++) {
      push_l(i, j);
    } 
    while (!deq.empty()) r[i][deq.back()] = m + 1, deq.pop_back();
    for (rint j = m; j >= 1; j--) {
      push_r(i, j);
    }
    while (!deq.empty()) l[i][deq.back()] = 0, deq.pop_back();
    for (rint j = 1; j <= m; j++) {
      //printf("l[%d][%d] = %d, r[%d][%d] = %d\n", i, j, l[i][j], i, j, r[i][j]);
      //printf("h[%d][%d] = %d\n", i, j, h[i][j]);
      ans += 1ll * (j - l[i][j]) * (r[i][j] - j) * h[i][j];
    }
  }
  printf("%lld\n", ans);
  return 0;
}
```

---

## 作者：囧仙 (赞：13)

## 题目大意

询问在一个 $n\times m$ 的长方形中，所有不包含记号的矩形的总数。

## 题解

题解区里大多都是 $\mathcal O(n^2)$ 的单调栈写法。但单调栈其实并不怎么好想……这里提供一个 $\mathcal O(n^2 \log n)$ 的比较容易想到的线段树解法吧。

考虑从上到下，从左到右枚举矩阵的**右下角**。不妨设当前处理到 $(i,j)$ ，我们如何从它左侧的一个点 $(i,j-1)$ 转移过来呢？

显然，右下角为 $(i,j)$ 的矩形，它的最大高度为 $(i,j)$ 到上方最近的标记（或者边界）的距离，不妨记为 $F_{i,j}$ 。 $F_{i,j}$ 比较容易求得。

$$F_{i,j}=\begin{cases} 0 & (i,j) \text{ 就是标记 } \cr F_{i-1,j}+1 & (i,j) \text{ 不是标记 }\end{cases}$$

我们能够发现，**右下角为 $(i,j)$ ，高度为 $h$ 的矩阵的方案数，就是 右下角为 $(i,j-1)$ ，高度为 $h$ 的矩阵的方案数 $+1$**。因为，每个高度为 $h$ 的方案，相当于一根高度为 $h$ 的柱子，再从左侧拼接了一个高度为 $h$ 的矩形。考虑维护不同高度的矩阵的方案数。我们需要以下三种操作：

- 清空高度为 $(F_{i,j}+1)\sim +\infty$ 的矩阵的方案数。

- 将高度为 $1 \sim F_{i,j}$ 的矩阵的方案数全部 $+1$ 。

- 求高度为 $1 \sim F_{i,j}$ 的矩阵的方案数的和。

我们可以用线段树实现这三个操作。当然，$+\infty$ 只要取 $n+1$ 就行了。

因此总复杂度为 $\mathcal O(n^2\log n)$ 。由于 $n\le 10^3$ ，因此能够通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int readln(char *s){
    int len=0,c; while((c=getchar())==10||c==13);
    if(c==EOF) return -1;
    s[len++]=c;  while((c=getchar())!=10&&c!=13&&c!=EOF)
    s[len++]=c;  s[len]=0; return len;
}
#define lc(t) (t<<1)
#define rc(t) (t<<1|1)
const int MAXN =1e3+3,SIZ=MAXN*4;
int W[SIZ],B[SIZ]; bool A[SIZ];
void upd(int t,int a,int b){
    if(a==b) return; int mid=a+b>>1;
    if(A[t]) A[lc(t)]=A[rc(t)]=true,B[lc(t)]=B[rc(t)]=W[lc(t)]=W[rc(t)]=0;
    if(B[t]){
        B[lc(t)]+=B[t],B[rc(t)]+=B[t];
        W[lc(t)]+=(mid-a+1)*B[t],W[rc(t)]+=(b-mid)*B[t];
    }
    A[t]=B[t]=0,W[t]=W[lc(t)]+W[rc(t)];
}
void add(int t,int l,int r,int a,int b){
    if(l<=a&&b<=r){W[t]+=b-a+1,++B[t];return;}
    int mid=a+b>>1; upd(t,a,b);
    if(l<=mid) add(lc(t),l,r,a,mid  );
    if(r> mid) add(rc(t),l,r,mid+1,b);
    W[t]=W[lc(t)]+W[rc(t)];
}
void clc(int t,int l,int r,int a,int b){
    if(l<=a&&b<=r){W[t]=0,A[t]=true,B[t]=0;return;}
    int mid=a+b>>1; upd(t,a,b);
    if(l<=mid) clc(lc(t),l,r,a,mid  );
    if(r> mid) clc(rc(t),l,r,mid+1,b);
    W[t]=W[lc(t)]+W[rc(t)];
}
void qry(int t,int l,int r,int a,int b,int &o){
    if(l<=a&&b<=r){o+=W[t]; return;}
    int mid=a+b>>1; upd(t,a,b);
    if(l<=mid) qry(lc(t),l,r,a,mid  ,o);
    if(r> mid) qry(rc(t),l,r,mid+1,b,o);
}
int n,m,F[MAXN][MAXN],v; LL ans; char S[MAXN][MAXN];
int main(){
    n=qread(),m=qread(),v=n+1,memset(S[0],'*',sizeof(S[0]));
    up(1,n,i) readln(S[i]+1);
    up(0,n,i) up(1,m,j) if(S[i][j]=='*') F[i][j]=i; else F[i][j]=F[i-1][j];
    up(1,n,i){
        int x=0; 
        clc(1,1,v,1,v); up(1,m,j){
            if(S[i][j]=='*'){clc(1,1,v,1,v);continue;}
            int w=i-F[i][j],t=0; clc(1,w+1,v,1,v),add(1,1,w,1,v),qry(1,1,w,1,v,t);
            ans+=1ll*t;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：金爷爷哈哈 (赞：13)

每次A了一个题之后发现没有题解都忍不住过来水一波。。。。

就算我讲的不好也比没有题解要强吧(hh)


本题一开始我也是懵逼的，因为之前做过一个类似的可以N三次方水过的题，，，


我们只统计以一个点为右下角的长方形有多少，这就是最后答案。

大致只用单调栈记录对于每个节点向左第一个比它低的是哪个，然后每加进去一个点我们就累加答案，从栈底开始，累加的答案就是

（h[i]-h[i-1]）\*(j-pos[i-1])  [for(i=1;i<=top;i++)]

为什么是这个呢？？

因为高度小于等于h[i-1]的长方形，之前已经统计过了，我们只需要统计高度>h[i-1]且<=h[i]的长方形，又因为当前的j与pos[i-1]+1之间的点的高度一定是>=h[i]的（由单调栈的性质决定的），所以要再乘个(j-pos[i-1])



不过这么做的复杂度很玄学，对于随机数据的话就是N方再乘个不大的常数。。。。但如果出题人特意卡的话可以卡到N三方的。。。

不过好像出题人很friedly，并没有卡我。。。。不然我就好再想个前缀和优化搞一搞了。。。。


code:
```cpp
#include<bits/stdc++.h>
#define ll int
using namespace std;
ll up[1005],n,m,top;
struct node{
    ll h,pos;
}s[10005];
ll lef[1005],rig[1005],ans=0,now;
int main(){
    scanf("%d%d",&n,&m);
    char ch;
    for(ll i=1;i<=n;i++){ 
        top=0; s[++top]=(node){0,0};
        for(ll j=1;j<=m;j++){
            ch=getchar(); while(ch!='.'&&ch!='*') ch=getchar();
            if(ch=='.'){
            up[j]++;
            while(s[top].h>=up[j]) top--;
            lef[j]=s[top].pos;
            s[++top]=(node){up[j],j};
            for(ll k=0;k<top;k++) ans+=(s[k+1].h-s[k].h)*(j-s[k].pos);
            }else up[j]=0,s[top=1]=(node){0,j};
        }     
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：EarthGiao (赞：5)

## 【思路】
单调栈     
先输入数据     
处理处每个点往上一共有多少个连续的没有被画过的点    
然后每一行f[i][0]和f[i][m + 1]要赋值一个超级小的数    
为了让区间边界终止与此    

然后顺序扫一遍找出每一个点     
左边距离他最近的一个比他矮的点    
然后倒叙扫一遍找出每一个点    
右边距离他最近的一个比他矮的店    
中间的就是它能够构成的矩阵    
矩阵组成方式是    
左边区间的长度（包括中间点） * 右边区间的长度（包括中间点） * 宽（也就是f[i][j]）         
累加起来输出就好了      
 
要开long long 哦不然最后两个点过不了      

## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#define int long long

using namespace std;
const int Max = 1005;
int f[Max][Max];
int a[Max]; 
int r[Max],l[Max];
signed main()
{
	char c;
	int n,m;
	cin >> n >> m;
	for(register int i = 1;i <= n;++ i)
	{
		for(register int j = 1;j <= m;++ j)
		{
			cin >> c;
			if(c == '*')f[i][j] = 0;
			else
			f[i][j] = f[i - 1][j] + 1;
		}
	}
	for(int i = 1;i <= n;++ i)
		f[i][0] = f[i][m + 1] = -0x7fffffff;
	int ans = 0;
	for(register int i = 1;i <= n;++ i)
	{
		stack<int>s1,s2;
		s1.push(1),s2.push(m);
		for(register int ii = 2,jj = m - 1;ii <= m + 1,jj >= 0;jj --,++ ii)
		{
			while(!s1.empty() && f[i][ii] < f[i][s1.top()])
			{
				r[s1.top()] = ii;
				s1.pop();
			}
			while(!s2.empty() && f[i][jj] <= f[i][s2.top()])
			{
				l[s2.top()] = jj;
				s2.pop();
			}
			s1.push(ii);s2.push(jj);
		}
		for(register int j = 1;j <= m;++ j)
			ans += (j - l[j]) * (r[j] - j) * f[i][j];
	}
	cout << ans << endl;
	return 0;
}
```

---


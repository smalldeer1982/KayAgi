# 摇钱树

## 题目描述

Cpg 正在游览一个梦中之城，在这个城市中有 $n$ 棵摇钱树。这下，可让 Cpg 看傻了。可是 Cpg 只能在这个城市中呆 $k$ 天，但是现在摇钱树已经成熟了，每天每棵都会掉下不同的金币（不属于 Cpg！）。Cpg 每天可以砍掉其中一颗，并获得其树上所有的金币（怎么会有这种好事）。请你帮助 Cpg 算出他在这 $k$ 天中最多能获得多少金币。

## 说明/提示

#### 数据范围与约定

- 对于 $100\%$ 的数据，$1 \le n, k \le 10^3$，$1 \le m_i \le 10^5$，$1 \le b_i \le 10^3$。

## 样例 #1

### 输入

```
3 3
10 20 30
4 5 6
4 3
20 30 40 50
2 7 6 5
0 0
```

### 输出

```
47
104
```

# 题解

## 作者：浅色调 (赞：19)

###贪心+DP###

不会告诉你们这道题就是：养猪  (题目名)

欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/7804548.html)

**思路：**首先，吐槽一下题目数据，没有指出Mi>=Bi，大家应该把这个当作隐藏条件。至于思路，我们先思考，很明显若只选1棵树，那就选价值最大的，若要选多棵树，则要先选消耗最大的(不一定价值最大)。为什么呢？假设我们有3棵树且要选全部，每棵价值和每次消耗分别为m1,m2,m3;b1,b2,b3;则总价值=m1+m2+m3-k1\*b1-k2\*b2-k3\*b3，其中k为第几次选-1，很明显消耗的大的系数要小，即消耗大的要先取。以此我们可以推及到n棵树选k棵的情况(明显就是dp了嘛)，先按消耗从大到小贪心排序，这样去取肯定保证最优，然后考虑dp，设f[i][j]表示前i棵树选j棵得到的最大值，则很容易得到状态转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-1]+max(0,m[i]-b[i]\*(j-1))) 。

**注意：**价值减小到0后直接赋为0。

**代码：**

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
#define ll long long
#define il inline
int n,k,f[1005][1005],ans;
struct pig{
int a,p;
}zhu[1005];
il bool cmp(pig a,pig b){return a.p>b.p;}
il int gi()
{
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
il int max(int a,int b){if(a>b)return a;return b;}
int main()
{
    while(1){
        n=gi(),k=gi();
        if(n==0&&k==0)return 0;
    ans=0;
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)zhu[i].a=gi();
    for(int i=1;i<=n;i++)zhu[i].p=gi();
    sort(zhu+1,zhu+n+1,cmp);
    for(int i=1;i<=k;i++)
    for(int j=1;j<=n;j++)
    {
        int x=zhu[j].a-zhu[j].p*(i-1);
        x=x>0?x:0;
        f[j][i]=max(f[j-1][i],f[j-1][i-1]+x);
    }
    for(int i=1;i<=k;i++)ans=max(f[n][i],ans);
    printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Llf0703 (赞：10)

感觉现有的两篇题解都没有严格证明为什么要按照``p``从大到小排序，所以我就写了这篇题解。

广告：https://llf0703.com

## 方法

贪心+dp。贪心策略是按``P``从大到小排序，然后01背包决定砍不砍即可。贪心证明如下：

假设最初的顺序是 $$ A[1],A[2],...,A[x],A[x+1],...,A[n] $$ 及 $$ P[1],P[2],...,P[x],P[x+1],...,P[n] $$ 

对于第 $ x $ 和第 $x+1$  棵树，砍了它们获得的利益和 $ W1 $ 是 

$$ A[x]-P[x]\times (x-1)+A[x+1]-P[x+1]\times x $$

如果我们交换第 $ x $ 和第 $ x+1 $  棵树，利益和 $ W2 $ 就变成了

$$ A[x]-P[x]\times x+A[x+1]-P[x+1]\times (x-1) $$

肯定是有更多利益我们才会交换，所以需要满足

$$ W2-W1=P[x+1]-P[x]>0 $$即 $$ P[x+1]>P[x] $$ 

交换后就是 $ P[x]>P[x+1] $ 了，所以按照``p``从大到小排序。

剩下的就是标准01背包，由于数据不大，用不用滚动数组都可以。方程式是：

$$ f[i][j]=\max \begin{cases} f[i-1][j] \\ f[i-1][j-1]+\max(0,A[i]-P[i]*(j-1)) \end{cases} $$

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>

using namespace std;

inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while (ch<'0' || ch>'9')
    {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}

int n,k,f[1005][1005],ans;
struct pig{
    int a,p;
} s[1005];

inline bool cmp(pig x,pig y)
{
    return x.p>y.p;
}

int main()
{
    while (~scanf("%d%d",&n,&k) && n && k)
    {
        memset(f,0,sizeof(f));
        ans=0;
        if (k>n) k=n;
        for (int i=1;i<=n;i++) s[i].a=read();
        for (int i=1;i<=n;i++) s[i].p=read();
        sort(s+1,s+n+1,cmp);
        for (int i=1;i<=n;i++)
            for (int j=k;j;j--)
                f[i][j]=max(f[i-1][j-1]+max(0,s[i].a-s[i].p*(j-1)),f[i-1][j]);
        for (int i=1;i<=k;i++) ans=max(ans,f[n][i]);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：ctq1999 (赞：6)

## 题解

可以发现，当前的状态是记录不了的，那么需要按一定顺序进行dp。

若一组数列，$n=k$，需要都选，如果第 $i$ 棵树是第 $C_i$ 次选它，$sum$ 表示 $\sum M_i$，那么答案就是 $ans=sum-(C_i-1)\times B_i$。**可以发现 $ans$ 取最大值时，必定是按 $B_i$ 从大到小选的。** 同理，$(M_{x_1},M_{x_2},\dots,M_{x_k})$，$(x_1,x_2,\dots,x_k)$ 为选择的树的下标序列，也同样是按照从大到小的。

所以按照 $B_i$ 进行排序，再进行dp，就免去记录状态了。

设 $f[i][j]$ 为到第 $i$ 棵树时，已选择了 $j$ 棵树的金币的最大值。那么转移就是从前一棵树转移到当前的树。

```
num = max(0, M[i] - B[i] * (j - 1));
f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + num);
```

注意最后答案并不是 $f[n][k]$。相信很多人都有疑惑。我来讲一下。

$f[n][k]$ 表示在第 $n$ 棵树已选了 $k$ 棵树。有人会说，就算最优的序列只有前几个产生了贡献，后面白嫖不就行了。很可惜，想到了后面，没想到前面。

$$k=4$$
$$M[]: 2,\dots,2,2,100,100$$
$$B[]: 2,\dots,2,2,1,1$$

若输出 $f[n][k]$，则为 $197$。
若输出 $f[n][2]$，则为 $199$。

发现了吗？若在最后，前面的树浪费了次数却没有产生贡献。

故，$ans = \text{MAX}\{f[n][i]\}$。

本题中 $f$ 数组可以滚到 $1$ 维上。

时间复杂度 $O(t \times n \times k)$。

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 1010
#define ll long long

using namespace std;

int n, k, ans;

struct node {
	int m, b;
}a[MAXN];

bool cmp(node x, node y) {
	return x.b > y.b;
}

int f[MAXN];

int main() {
	scanf("%d%d", &n, &k);
	while (n || k) {
		k = min(k, n);
		memset(f, 0, sizeof(f));
		for (int i = 1; i <= n; i++) {
			scanf("%d", &a[i].m);
		}
		for (int i = 1; i <= n; i++) {
			scanf("%d", &a[i].b);
		}
		sort(a + 1, a + n + 1, cmp);
		for (int i = 1; i <= n; i++) {
			for (int j = k; j >= 1; j--) {
				int num = a[i].m - a[i].b * (j - 1);
				if (num < 0) num = 0;
//				f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + num);
				f[j] = max(f[j], f[j - 1] + num);
			}
		}
		ans = 0;
//		for (int i = 1; i <= k; i++) ans = max(ans, f[n][i]);
		for (int i = 1; i <= k; i++) ans = max(ans, f[i]);
		cout << ans << endl;	
		scanf("%d%d", &n, &k);
	}
	return 0;
}
```

---

## 作者：Erinyes (赞：4)

## Part 1：题目分析
这道题看起来像一个背包，但不同的是每一个物品的价值每天都会减少。

先来看看普通的 01 背包。由于物品的价值不会减少，所以对于一个物品，先取还是后取没有区别，所以可以直接从 $1\sim n$ 枚举物品，然后按照剩余的背包容量舍去即可。

在这道题中，每一棵摇钱树都可以看成一个物品，它在每一天的金币数量就是它的价值（会减少）。所以总的天数（$k$）就可以看成背包容量。并且由于每一棵摇钱树只能被砍一次，所以这是一个 01 背包。

由于每一个物品的价值都会减少，所以我们可以采取一种贪心的思想，将物品每天减少的价值**从大到小**排序，再跑 01 背包即可。

这种贪心的正确性也很好证明，01 背包对物品的取舍并不受物品顺序的影响，也就是说，如果这个选择一个物品会使结果增加，那么无论它在 $1\sim n$ 的哪一个位置都不会受到影响。

## Part 2：题目求解
由于我们要将这 $n$ 个物品按照每天减少的价值排序，所以最好的选择便是结构体。
```cpp
struct node{int m,b;}t[maxn];
bool cmp(node a,node b){return a.b>b.b;} //重定义sort中的cmp函数
```
接下来便是 01 背包的过程了。

与一般的 01 背包不同的是，选择一个物品所得到的价值并不是这个物品的价值。因为当我们在第 $j$ 天选择这个物品时，这个物品已经减少了 $j-1$ 天的价值，所以得到的价值应该是这个物品的价值减去已经减少的价值。

状态转移方程应该是：

$$f_{i,j}=\max \begin{Bmatrix} f_{i-1,j}
 \\
f_{i-1,j-1}+m_i-b_i\times(j-1)
\end{Bmatrix} $$

```cpp
//滚动数组优化
for(int i=1;i<=n;i++) //枚举物品
	for(int j=k;j>0;j--) //枚举剩余背包容量
		f[j]=max(f[j],f[j-1]+t[i].m-t[i].b*(j-1)); //转移
```
在这里 $f_j$ 初始化为 $0$，所以并不需要考虑 $f_{i-1,j-1}+m_i-b_i\times(j-1)$ 小于 $0$ 的情况。

还有一点，我们不一定要把 $k$ 天全部用完，所以最后需要枚举 $f_0\sim f_k$，求出最大值。

```cpp
int ans=0;
for(int i=0;i<=k;i++) ans=max(ans,f[i]); //更新最大值
```
## Part 3：Code
多组数据，记得清零数组！

```cpp
#include<bits/stdc++.h>
#define maxn 10005
using namespace std;
struct node{int m,b;}t[maxn];
int n,k;
int f[maxn];
bool cmp(node a,node b){return a.b>b.b;} //重定义sort中的cmp函数
int main(){
	while(~scanf("%d %d",&n,&k) and n and k){
		for(int i=1;i<=n;i++) scanf("%d",&t[i].m);
		for(int i=1;i<=n;i++) scanf("%d",&t[i].b);
		sort(t+1,t+n+1,cmp); //排序
		memset(f,0,sizeof(f));
		for(int i=1;i<=n;i++) //枚举物品
			for(int j=k;j>0;j--) //枚举剩余背包容量
				f[j]=max(f[j],f[j-1]+t[i].m-t[i].b*(j-1)); //转移
		int ans=0;
		for(int i=0;i<=k;i++) ans=max(ans,f[i]); //更新最大值
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：天南地北 (赞：2)

大意：算出$Cpg$在这$K$天中，通过砍每天会掉金币的摇钱树，最多能够获得的金币数量。

**贪心+$DP$($01$背包问题)**

由于我们想要尽可能的去拿金币，我们不能考虑金币数量最多这一个因素（顾此失彼）。

我们可以**考虑先选择摇钱树每天掉金币数量更大的，再选择每天掉金币数量更小的。**

**证明：**

设$money$数组为这棵树本身有的金币，$cost$数组为每天掉的金币 

假设当前为第i天，正在选$X$和$Y$两颗树。

先砍$X$树，利益为$money[x]-cost[x]*(i-1)+money[y]-cost[y]*i$---------①

先砍$Y$树，利益为$money[y]-cost[y]*(i-1)+money[x]-cost[x]*i$---------②

①-②得$cost[X]-cost[Y]$

此时如果$cost[X]>cost[Y]$，则先砍$X$的利益更大。

**状态转移方程**

设$f[i][j]$ 为前$i$棵树砍了$j$天的最大值

经考虑，只可能从$f[i-1][j-1]$和$f[i-1][j]$这种情况转移过来（砍一棵树和不砍树）

所以状态转移方程不难想到：


$f[i][j]=max\begin{cases}f[i-1][j]&& \\f[i-1][j-1]+max(money[i]-cost[i]*(j-1),0)\end{cases}$

当然了我们可以去掉$[i]$这一维度，又可得：

$f[j]=max\begin{cases}f[j]&& \\f[j-1]+max(money[i]-cost[i]*(j-1),0)\end{cases}$

**答案**


最后的答案不在第$f[k]$中，这是因为有可能存在

一些树，每天掉落的钱少，且本身钱多；一些树，每天掉落的钱多，但本身树上的钱少；

如果后者的钱掉光时还没有被选中，那么它的$cost[i]$变为$0$，而此时前者的$cost[i]>0$，

也就是违背了我们的贪心策略,那么在他们后面的树往前填更优。

也就出现了后面的树填在前面，而$f[k]$不是最优解的情况。

**参考程序**
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,k,f[1005],ans;
struct tree
{
    int money,cost;
} trees[1005];
bool cmp(tree x,tree y)
{
    return x.cost>y.cost;
}
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n>>k;
    while (n&&k)
    {
        memset(f,0,sizeof(f));
        ans=0;
        if (k>n) k=n;
        for (int i=1;i<=n;i++) 
			cin>>trees[i].money;
        for (int i=1;i<=n;i++) 
			cin>>trees[i].cost;
        sort(trees+1,trees+1+n,cmp);
        for (int i=1;i<=n;i++)
            for (int j=k;j;j--)
                f[j]=max(f[j-1]+max(0,trees[i].money-trees[i].cost*(j-1)),f[j]);
        for (int i=1;i<=k;i++) ans=max(ans,f[i]);
        printf("%d\n",ans);
        cin>>n>>k;
    }
    return 0;
}
```



---

## 作者：Fortitude (赞：2)

这题和**P1659 养猪**有什么区别吗（黑人问号！？）

先按每天掉的苹果数量排序

然后就是01背包

**f[j]=max(f[j],f[j-1]+max(tree[i].m-tree[i].b\*(j-1),0));**

最后扫一遍，输出K天内最优值即可





```cpp
 #include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int MaxN=1005;
struct node
{
    int m,b;
}tree[MaxN];
int f[MaxN];
int N,K,ans;
bool flag=true;
inline int Get_Val()
{
    int s=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
        s=s*10+ch-'0',ch=getchar();
    return s;
}
inline bool cmp(node i,node j)
{
    if(i.b!=j.b) return i.b>j.b;
    return i.m>j.m;
}
int main()
{
    int i,j;
    while(flag)
    {
        N=Get_Val(),K=Get_Val(),ans=0;
        if(!N&&!K) return 0;
        memset(f,0,sizeof(f));
        for(i=1;i<=N;i++)
            tree[i].m=Get_Val();
        for(i=1;i<=N;i++)
            tree[i].b=Get_Val();
        sort(tree+1,tree+N+1,cmp);//多组数据每次要先初始化
        for(i=1;i<=N;i++)
            for(j=max(K,i);j>0;j--)
                f[j]=max(f[j],f[j-1]+max(tree[i].m-tree[i].b*(j-1),0));
        for(i=1;i<=K;i++)
            ans=max(ans,f[i]);
        printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：0xFF (赞：1)

#### 思路分析


------------
本题思路与 [烹调方案](https://www.luogu.com.cn/problem/P1417) 类似，都属于物品价值随时间变化逐渐变小的一类动态规划问题。

考虑将物品按照某一标准排序。

原序列中两物品 $A_i,A_{i+1}$ 的价值为 $m_i- b_i \times i + m_{i+1} - b_{i+1} \times (i+1) $

交换两物品后价值为 $m_i - b_i \times (i+1)+m_{i+1}-b_{i+1}\times i$

将两式作差后得到 $b_i - b_j$

若 $b_i > b_j$ 则不交换两物品

反之则交换。

综上，按照 $b_i$ 的价值排序后 DP 即可。

$f_{i,j}$ 表示前 $j$ 天选了在前 $i$ 棵树中选 $j$ 棵的最大价值

每天要么选择拿走当前这棵树上所有的金币要么选择不选这棵树。

$\mathit{f}_{i,j}  =\max \left\{\begin{array}{l}
f_{i-1,j} \\
f_{i-1,j-1}+\max (0, m_i-b_i \times (j-1))
\end{array}\right.$

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<climits>
#include<queue>
#include<vector>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f;
const int mod = 998244353;
const int N = 3e3 + 10;
const int M = 1e5 + 10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
int f[N][N];
struct Node{
	int v,p;
}a[N];
bool cmp(Node x,Node y){
	return x.p > y.p;
}
int n,k,ans;
void Sol(){
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++) a[i].v = read();
	for(int i=1;i<=n;i++) a[i].p = read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			f[i][j] = max(f[i-1][j],f[i-1][j-1] + max(0ll,a[i].v - a[i].p * (j - 1)));
		}
	}
	ans = 0;
	for(int i=1;i<=n;i++){
		ans = max(ans,f[n][i]);
	}
	cout<<ans<<"\n";
}
signed main(){
	while(cin>>n>>k){
		if(n == 0 && k == 0) break;
		Sol();
	}
	return 0;
}
```


---

## 作者：qzcbw (赞：1)

## 题目分析
这道题只需要在排序后做一个 $01$ 背包就可以了 ~~（然而考场上一直没想出来）~~
方程式是：

$f[i][j]=max\begin{cases}f[i-1][j]\\f[i-1][j-1]+max(x[i]-y[i]*(j-1),0))\end{cases}$


这里我用了滚动数组，那么方程式就是：

$f[j]=max(f[j],f[j-1]+max(x[i]-y[i]*(j-1),0))$
## code
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
    int x,y;
}a[1039];
int f[1039];
int n,k,ans;
inline bool cmp(node i,node j){
    if(i.y!=j.y) return i.y>j.y;
    return i.x>j.x;
}
int main(){
    register int i,j;
    while(1){
    	ans=0;
    	scanf("%d%d",&n,&k);
      	if(!n&&!k) return 0;
    	memset(f,0,sizeof(f));
    	for(i=1;i<=n;i++)
        	scanf("%d",&a[i].x);
    	for(i=1;i<=n;i++)
        	scanf("%d",&a[i].y);
    	sort(a+1,a+n+1,cmp);
    	for(i=1;i<=n;i++)
        	for(j=max(k,i);j>0;j--)
            		f[j]=max(f[j],f[j-1]+max(a[i].x-a[i].y*(j-1),0));
    	for(i=1;i<=k;i++)
        	ans=max(ans,f[i]);
    	printf("%d\n",ans);
    }
    return 0;
}
```


---

## 作者：foglake (赞：0)

# P1987 摇钱树
这是一道~~小水~~题~，想通了就简单了。
## 错误解法：
模拟，每天选剩下的最多钱的树。

很明显，这样贪心是错的。容易举出反例：

```
2 2
100 50
1 50
```
显然，答案是先选第二棵树。但贪心就会挂（~~蓝题果然不是这么好水的呜呜呜~~）。
## DP（背包）解法：
（~~偷看标签中~~）。

让我们换种说法：
$n$ 个物品，选 $k$ 个。被选的物品价值减少一定价值。选得越晚价值越低。

欸，这样看起来就很像**背包**了嘛。至于后面的问题，举个栗子来看。

假如我们选了这么几个物品。

```
100 200 300
10 20 30
```
那么，怎么调整选的顺序使价值最大化呢？

明显地，**先选消耗大的**。那么，做背包时，先将消耗大的放在前，就保证选的消耗大的物品一定在前面。

### 人见人爱的代码：
```
#include <bits/stdc++.h>
using namespace std;
int dp[1001];
struct tree {
	int los, mon;// los 代表损耗， mon 代表原始价值。
}t[1001];
bool cmp(tree a, tree b) {
	return a.los > b.los;
}
int main() {
	while (1) {
		memset(dp, 0, sizeof(dp));//记得清空数组。
		int n, m, ans = 0;
		scanf("%d%d", &n, &m);
		if (!n && !m) break;
		for (int i = 1; i <= n; i++)
			scanf("%d", &t[i].mon);
		for (int i = 1; i <= n; i++)
			scanf("%d", &t[i].los);
		sort(t + 1, t + 1 + n, cmp);//损耗大的在前。
		for (int i = 1; i <= n; i++)
			for (int j = min(i, m); j > 0; j--)//倒序压维，基本操作。
				dp[j] = max(dp[j], dp[j - 1] + max(t[i].mon - (j - 1) * t[i].los, 0));//掉成负数其实就是掉完了（即 0）。
		for (int i = 0; i <= min(n, m); i++) ans = max(ans, dp[i]);//找最优解。
		printf("%d\n", ans);
	}
}
```
如有不足，请提出。

---

## 作者：ListenSnow (赞：0)

## 题意

给定 $n$ 棵摇钱树，第 $i$ 棵摇钱树上的初始金币为 $a_i$，每天会掉下 $b_i$ 个金币。在 $k$ 天内，每天都可以砍一棵摇钱树，第 $i$ 天砍第 $j$ 棵摇钱树可以得到 $a_j-(i-1)*b_j$ 个金币，求最终得到的金币数量的最大值。

## 思路

首先可以将题目中的 $k$ 天看成是一个容量为 $k$ 的背包，第 $j$ 棵摇钱树看成是一个体积为 $1$，价值为 $\max(a_j-(i-1)*b_j,0)$ 的物品。其中 $i$ 表示该物品是第 $i$ 个放进背包的物品。那么也就可以将题目转化为一个 经典的 $01$ 背包问题。

但是由于有 $(i-1)$ 这个变量在影响价值，所以枚举物品放进背包的顺序不同，答案也会不同。所以需要先按照 $b_i$ 的大小对物品进行**排序**，再进行状态转移。这是因为本题满足一个贪心性质：在放**同样多**的物品的所有方案中，先放 $b_i$ **大**的物品的方案最优。


------------


证明：

设当前背包中已经放了 $p$ 个物品，现在要放 $i$ 和 $j$ 两个物品。

先放物品 $i$ 的价值：$f[p]+a_i-(p-1)*b_i+a_j-p*b_j$------ ①。

先放物品 $j$ 的价值：$f[p]+a_j-(p-1)*b_j+a_i-p*b_i$------ ②。

① 式减去 ② 式，可以得到：$b_i-b_j$。

当 $b_i>b_j$ 时，先放物品 $i$ 更优；当 $b_i<b_j$ 时，先放物品 $j$ 更优。

故同样放 $i$ 个物品时，先放 $b_i$ 大的物品更优。所以最终的答案就是 $\max(f[i])$



------------
需要注意的是，最终的答案**不一定**为 $f[k]$，如下面这组数据：
```cpp
3 3
1000000 2 1
1000 10000 111111
```
显然在这组数据中，先一个物品时最优。但是上面的**贪心性质就决定**了把要所有物品都放进去时，不可能先放第一个物品。而在所有方案中，满足第一个物品最先放进去的方案，就只有 $f[1]$ ，所以在这组样例中的答案就是 $f[1]$。

由这组样例可以发现，如果要放所有物品，就有可能会放价值已经降到 $0$ 的物品，而白白浪费了后面价值更大的物品。所以不一定放所有的物品最优。

因此，最终的答案为 $\max_{1\leq i \leq k}f[i] $。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1010;
int n,k,f[N];
struct node{
	int m,b;
	bool operator <(const node &t)const{
	    return b>t.b;
	}
}tr[N];
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int main()
{
	while(scanf("%d%d",&n,&k),n)
	{
		memset(f,0,sizeof(f));
		int ans=0;
		for(int i=1;i<=n;i++) scanf("%d",&tr[i].m);
		for(int i=1;i<=n;i++) scanf("%d",&tr[i].b);
		sort(tr+1,tr+n+1);
		for(int i=1;i<=n;i++)
		    for(int j=min(k,n);j>=1;j--)
		        f[j]=max(f[j],f[j-1]+max(tr[i].m-(j-1)*tr[i].b,0));
		for(int i=1;i<=k;i++) ans=max(ans,f[i]);
		printf("%d\n",ans);
	}
	return 0;
}

```


---

## 作者：Link_Space (赞：0)

一道比较简单的背包，很容易可以想到贪心思想：将每棵树按每天掉的钱的数量从小到大排序，先拿掉的快的，使能得到的利益最大化，严谨证明如下：

设$A$数组为这棵树本身有的金币，$B$数组为每天掉的金币
假设当前为第$k$天，正在选$x$和$y$两颗树。

如果先砍$x$树，利益为$A[x]-B[x]*(k-1)+A[y]-B[y]*k$ ---------①

如果先砍$y$树，利益为$A[y]-B[y]*(k-1)+A[x]-B[x]*k$ ---------②

①-②得$B[x]-B[y]$

此时如果$B[x]>B[y]$，则先砍$x$的利益更大

反之，先砍$y$的利益更大

所以可得，谁每天掉落得多，先砍谁得到的总收益就最大。

知道了这个之后，我们发现这道题已经成为了一个01背包模板题，只需要枚举将这棵树放到什么时候砍即可即可，由于只跟每一天都只前一天有关，所以可以滚动数组优化为一维，所以最后定义$dp[i]$为将当前枚举到的这棵树放到第i个砍，然后最后枚举$dp[1]-dp[k]$中的最大值，有的同学可能会问为什么，这不是很简单的道理吗？你当然需要枚举最后一棵树放到什么时候砍是最好的来找到最大值。

以下是代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int dp[1005];
int maxn[1005];
bool aim[1005];
struct node{
	int fir;
	int out;
} ss[10005];
bool cmp(node a,node b)
{
	return a.out > b.out;
}
int main()
{
	int n, m;
	while(scanf("%d%d",&n,&m)&&(n||m))
	{
		memset(dp, 0, sizeof dp);
		if(m>n)
			m = n;
		for (int i = 1;i<=n;i++)
			scanf("%d", &ss[i].fir);
		for (int i = 1;i<=n;i++)
			scanf("%d", &ss[i].out);
		sort(ss + 1, ss + n + 1, cmp);
		for (int i = 1; i <= n;i++)
		{
			for (int j = m; j > 0;j--)
			{
				dp[j] = max(dp[j - 1] + max(0,(ss[i].fir - ss[i].out * (j - 1))), dp[j]);
			}
		}
		int maxn = 0;
		for (int j = 1; j <= m;j++)
			maxn = max(dp[j], maxn);
		printf("%d\n", maxn);
	}
}
```


---

## 作者：夏菡德佑 (赞：0)

总的思路其他题解已经讲的很清楚了：贪心加01背包

但是很多人看完其他题解可能会有这样一个问题：为什么跑完01背包后要跑一遍1~k来找答案呢？

我看完就有这样一个问题，然后翻完所有题解（包括百度上的）都没有任何关于此的解释，然后我想下载数据来康康，然而并不能下……

最后在与同学的讨论中得出了答案。

原因是：如果存在这样一种情况：有一些树，每天掉落的钱少，且本身钱多；另一些树，每天掉落的钱多，但本身树上的钱少；如果后者的钱掉光时还没有被选中，那么它的B[i]变为0，而此时前者的B[i]>0，也就是违背了我们的贪心策略，那么在他们后面的树往前填更优,也就出现了后面的树填在前面，而dp[k]不是最优解的情况

请看下面一组数据

```
5 4
1 1 1 100 100
2 2 2 1 1
5 4
100 1 1 100 100
2 2 2 1 1
0 0
```
这组数据答案取dp[k]时结果为
```
196
295
```
而答案取max{dp[1~k]}的结果为
```
199
297
```
大家可以自己手算加深理解。

而且经我实测，除了数据点1，其他的九个点都存在k>n的情况。~~别问我是怎么测出来的~~，这样的话，就更需要跑1~k找答案，因为这种情况下，只有前1~n中有数据。

最后，上个代码给大家参考一下。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct Tree {
	int w,b;
}a[1005];
inline bool cmp(Tree a,Tree b) {return a.b>b.b;}
inline int cg(int a) {return a<0?0:a;}
inline int MAX(int a,int b) {return a>b?a:b;}
int dp[1005];
int main() {
	int n,k;
	while(1) {
		scanf("%d%d",&n,&k);
		if(n==0 && k==0) break;
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=n;i++) scanf("%d",&a[i].w);
		for(int i=1;i<=n;i++) scanf("%d",&a[i].b);
		sort(a+1,a+1+n,cmp);
		for(int i=1;i<=n;i++)
			for(int j=k;j>0;j--)
				dp[j]=MAX(dp[j],dp[j-1]+cg(a[i].w-(j-1)*a[i].b));
		int ans=0;
		for(int i=1;i<=k;i++) ans=MAX(ans,dp[i]);
		printf("%d\n",ans);
	}
	return 0;
}
```


---


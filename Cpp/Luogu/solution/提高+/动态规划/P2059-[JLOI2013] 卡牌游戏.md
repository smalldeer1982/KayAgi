# [JLOI2013] 卡牌游戏

## 题目描述

$N$ 个人坐成一圈玩游戏。一开始我们把所有玩家按顺时针从 $1$ 到 $N$ 编号。首先第一回合是玩家 $1$ 作为庄家。每个回合庄家都会随机（即按相等的概率）从卡牌堆里选择一张卡片，假设卡片上的数字为 $X$，则庄家首先把卡片上的数字向所有玩家展示，然后按顺时针从庄家位置数第 $X$ 个人将被处决(即退出游戏)。然后卡片将会被放回卡牌堆里并重新洗牌。被处决的人按顺时针的下一个人将会作为下一轮的庄家。那么经过 $N-1$ 轮后最后只会剩下一个人，即为本次游戏的胜者。现在你预先知道了总共有 $M$ 张卡片，也知道每张卡片上的数字。现在你需要确定每个玩家胜出的概率。

这里有一个简单的例子：

例如一共有 $4$ 个玩家，有四张卡片分别写着`3,4,5,6`.

第一回合，庄家是玩家 $1$ ，假设他选择了一张写着数字 $5$ 的卡片。那么按顺时针数 `1,2,3,4,1`，最后玩家 $1$ 被踢出游戏。

第二回合，庄家就是玩家 $1$ 的下一个人，即玩家 $2$.假设玩家 $2$ 这次选择了一张数字 $6$，那么 `2,3,4,2,3,4`，玩家 $4$ 被踢出游戏。

第三回合，玩家 $2$ 再一次成为庄家。如果这一次玩家 $2$ 再次选了 $6$，则玩家 $3$ 被踢出游戏，最后的胜者就是玩家 $2$。

## 说明/提示

对于 $30\%$ 的数据，有 $1\le N\le 10$。

对于 $50\%$ 的数据，有 $1\le N\le 30$。

对于 $100\%$ 的数据，有 $1\le N\le 50$, $1\le M\le 50$, $1\le$ 每张卡片上的数字 $\le 50$。

## 样例 #1

### 输入

```
5 5
2 3 5 7 11
```

### 输出

```
22.72% 17.12% 15.36% 25.44% 19.36%
```

## 样例 #2

### 输入

```
4 4
3 4 5 6```

### 输出

```
25.00% 25.00% 25.00% 25.00%```

# 题解

## 作者：学委 (赞：98)

*2018-10-24 更新*

## 思路

与先前写题解的大佬们略有不同，我觉得可能更好理解一些。

如果有情况A有 $m$ 的概率发生，且它有 $n$ 的概率直接转换情况B，那么情况B发生的概率可加上 $m×n$。

概率可以层层（一层指的是淘汰一次）继承，可以考虑用DP。

这道题直觉是顺序递推，第一个人有 $\frac{1}{m}$ 的几率选择某一张牌，所以下一个状态出现的概率为 $\frac{1}{m}$。但是下一个状态很古怪，因为这个状态除了包括概率值，**还包括“谁被淘汰了”**，后者也会影响接下来的淘汰结果。仔细考虑发现不好实现。

最好有一种继承方式不需要保留“谁被淘汰”这个状态。那就是**倒序递推，从环内人数只有1的状态开始。**

___

模拟一下样例1。现在卡牌是给定了，上面写着2，3，5，7，11。

___

当环内只有一个人时（没人钦定这是谁），这个人已经赢了，赋胜率100%。

___

考虑环内有两个人的情况（这也是不指定的两人）。这时的庄家可以从5张牌中任意选一个，每张牌被选中的概率都是 $\frac{1}{5}$。

如果选2。淘汰对方，自己胜利。

如果选3，5，7，11中的一张牌，可算出他淘汰了自己，留下了第二个人。

可见，余留两个人时，庄家胜率20%，坐在他后面的人胜率80%。

暂时看不出什么端倪。其实，**“还剩两人”的状态对于解决“还剩三人”特别有利。**

___

考虑环内有三个人的情况。

庄家 $\frac{1}{5}$ 几率选2。结果是第2个人遭到了淘汰，**剩下的3，1两人就组成了标准的两人环的情况！**

![](https://cdn.luogu.com.cn/upload/pic/31310.png)

若庄家选择牌2，则2号被淘汰（不会得到胜率贡献），3号（成为两人环的庄主）的胜率就将是20%，1号（成为两人环的小二）的胜率就将是80%。

当然这样分配胜率的前提是“本轮中庄家确实选了牌2”，实际概率仅 $\frac{1}{5}$；所以对3号胜利的真正贡献是 $\frac{1}{5} × 20\%$，对1号胜利的真正贡献是 $\frac{1}{5} × 80\%$。

庄家还可能选择别的牌（还可能淘汰自己）。但是**淘汰掉三人中的一个后，接下来的两人形成新环（庄主可能改变），所以可以直接从两人环的情况继承。**

*这种方法不用保留谁被淘汰掉的状态。*

___

四个人成环的情况，同样枚举庄家选择了什么牌，被淘汰的人之后的三个人的情况就可以利用已求出的三人环了。

```cpp
//在第四层内，我们将根据已求出的三人环求出四人环内每个人的胜利几率。
//下面所有“4”是第四层的的意思，仅供模拟当前层。a[]数组存储着牌上的数字

  for(int k = 1; k <= m; ++k)//枚举4人中的庄家选的牌
  {
      int p = (a[k] % 4 == 0) ? 4 : a[k] % 4;
      //如果取a[k]这张牌，淘汰掉p（p = a[k] % 4），那么下一轮p+1坐庄，p+2将是二号
      //因此p+1获得“下一盘庄主的胜率 × 1/m”，p+2获得“下一盘小二的胜率 × 1/m”...

      for(int j = 1; j <= 4-1; ++j)//被淘汰者的后面的3个人，就成为新3人环的第1、2、3个人，因此可以获得一些胜率
      {
          ++p;//后面一个人
          if(p > 4)//这是回到环首了
              p = 1;				
          f[4][p] += f[4-1][j] / (double)(m);//根据上一层状态继承。本层第p个对应上一层第j个。注意这一选择的实际发生几率只有1/m
      }
  }
```

## 代码

```cpp
//头文件等没特别
int n, m;
int a[51];//存各个牌上的数字

double f[51][51];
//对于指定的的卡牌，f[i][j]指的是i人形成的环中，第j个人的胜率
//我们将倒序递推出f数组

int main()
{
	n = getint(), m = getint();
	for(int i = 1; i <= m; ++i)
		a[i] = getint();
	
	f[1][1] = 1.0;//只剩一个人时，此人100%获胜
 
	for(int i = 2; i <= n; ++i)//根据i-1人环，求出i人环的情况
		for(int k = 1; k <= m; ++k)//枚举本轮庄家选择的牌
		{
			int p = (a[k] % i == 0) ? i : a[k] % i;
			//如果取a[k]，第a[k] % i（用p记录）人被淘汰，下一轮p+1坐庄
            
			for(int j = 1; j <= i-1; ++j)
			{
				++p;//下一个人
				if(p > i)
					p = 1;				
				f[i][p] += f[i-1][j] / (double)(m);
			}
		}
			
	for(int i = 1; i <= n; ++i)
		printf("%.2lf%% ", f[n][i] * 100.0);
	return 0;
}
```

---

## 作者：Drinkkk (赞：36)

【题目描述】

$n$个人坐成一圈玩游戏。一开始我们把所有玩家按顺时针从$1$到$n$编号。首先第一回合是玩家$1$作为庄家。每个回合庄家都会随机（即按相等的概率）从卡牌堆里选择一张卡片，假设卡片上的数字为$x$，则庄家首先把卡片上的数字向所有玩家展示，然后按顺时针从庄家位置数第$x$个人将退出游戏。然后卡片将会被放回卡牌堆里并重新洗牌。被处决的人按顺时针的下一个人将会作为下一轮的庄家。那么经过$n-1$轮后最后只会剩下一个人，即为本次游戏的胜者。现在你预先知道了总共有$m$张卡片，也知道每张卡片上的数字。现在你需要确定每个玩家胜出的概率。

这里有一个简单的例子：

例如一共有$4$个玩家，有四张卡片分别写着$3,4,5,6$。

第一回合，庄家是玩家$1$，假设他选择了一张写着数字$5$的卡片。那么按顺时针数$1,2,3,4,1$，最后玩家$1$被踢出游戏。

第二回合，庄家就是玩家1的下一个人，即玩家$2$。假设玩家$2$这次选择了一张数字$6$，那么$2,3,4,2,3,4$，玩家$4$被踢出游戏。

第三回合，玩家$2$再一次成为庄家。如果这一次玩家$2$再次选了$6$，则玩家$3$被踢出游戏，最后的胜者就是玩家$2$。

【输入输出格式】

- 输入格式

第一行包括两个整数$n,m$分别表示玩家个数和卡牌总数。

接下来一行是包含$m$个整数，分别给出每张卡片上写的数字。

- 输出格式

输出一行包含$n$个百分比形式给出的实数，四舍五入到两位小数。分别给出从玩家$1$到玩家$n$的胜出概率，每个概率之间用空格隔开。

【输入输出样例】

- 输入样例$1$

```
4 4
3 4 5 6

```

- 输出样例$1$

```
25.00% 25.00% 25.00% 25.00% 
```

- 输入样例$2$

```
5 5
2 3 5 7 11

```

- 输出样例$2$

```
22.72% 17.12% 15.36% 25.44% 19.36% 
```

【数据范围】

对于$30$%的数据，有$1 \leq n \leq 10$；

对于$50$%的数据，有$1 \leq n \leq 30$；

对于$100$%的数据，有$1 \leq n \leq 50$，$1 \leq m \leq 50$，$1 \leq $每张卡片上的数字$ \leq 50$。

思路：这道题目很明显可以通过枚举来确定最后的胜利者是谁。然后我们就可以根据所有的结果来分析每一个人的胜率了。下面我将举出一个$n=2,m=3$的例子：
```
2 3
1 2 3

```

第$1$种情况：$1$号拿了$1$号卡牌，上面的数字是$1$。因此$1$号出局，$2$号胜利。

第$2$种情况：$1$号拿了$2$号卡牌，上面的数字是$2$。因此$2$号出局，$1$号胜利。

第$3$种情况：$1$号拿了$3$号卡牌，上面的数字是$3$。因此$1$号出局，$2$号胜利。

根据上面的结果，我们发现：$1$号赢了$1$次，$2$号赢了$2$次。因此$1$号的胜率为$\frac{1}{3}$，$2$号的胜率为$\frac{2}{3}$。将$1$号和$2$号的胜率四舍五入到两位小数时他们的胜率分别为$33.33$%和$66.67$%。$dfs()$的复杂度是$O(m^n)$的，感谢各位大佬提醒！

那么我们怎样才能够进一步地优化我们的程序呢？

其实我们可以使用一种叫做概率动态规划的算法，即我们常说的**概率DP**。

我们可以用概率DP来解决这个问题。我们可以用$f[i][j]$来表示在还剩下$i$个人时，从庄家开始数第$j$个人的获胜的概率。其实还有一种时间复杂度约为$O(\sum_1^{n-1}\sum_{j=1}^n\sum_{k=1}^{n-i} {m})$的一种方法，在这里我就不做介绍了，在这篇文章中我只介绍上面的这种时间复杂度约为$O(mn^2)$的一种办法。

首先我们可以确定当还有$1$个人时第$1$号的胜率为$100$%，即$1.0$。我们不难发现$f[i][]$的状态可以从$f[i-1][]$中转移过来。那么怎么转移我们的$f$数组呢？

> 我们可以首先枚举庄家抽到的卡牌$k$，得到这一轮被淘汰的人的位置$c$。当然，如果$c=j$ ，就不要考虑了（因为这表示此轮第$j$个人被淘汰）。

> 而第$c$个人被淘汰之后，剩下的$i-1$个人要组成一个新的环，庄家为第$c$个人的下一个。容易算出，当$c>j$时，第$j$个人是新的环里从新庄家数起的第$i-c+j$个人，当$c<j$时，第$j$个人是新的环里从新庄家数起的第$j-c$个人。

上面的引用部分里的内容摘自[@xyz32768的博客](https://www.luogu.org/blog/user29936/)，放入题解时有删改。

因此我们可以得出状态转移方程：

当$c>j$时，$f[i][j]=f[i][j]+f[i-1][i-c+j] \div m$，即$f[i][j]=f[i][j]+\frac{f[i-1][i-c+j]}{m}$；

否则当$c<j$时，$f[i][j]=f[i][j]+f[i-1][j-c] \div m$，即$f[i][j]=f[i][j]+\frac{f[i-1][j-c]}{m}$。

其中，$j \leq i$会更加优，感谢@Yunxuan的建议。

下面上$100$分（满分）代码：

```cpp
#include <cstdio>
double f[1001][1001];
int a[10001];
int main()
{
	int n=0,m=0;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
	}
	f[1][1]=1.0;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=1;k<=m;k++)
			{
				int c=(a[k]%i!=0)?(a[k]%i):i;
				if(c>j)
				{
					f[i][j]+=f[i-1][i-c+j]/m;
				}
				else if(c<j)
				{
					f[i][j]+=f[i-1][j-c]/m;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("%.2lf%% ",f[n][i]*100.0);
	}
	return 0;
}
```

---

## 作者：xyz32768 (赞：16)

刚刚学了莫比乌斯反演，但是题目我一直都没有思路（因为我太弱了），只好来这里刷水题了，顺便发一发题解。

建立$DP$模型：$f[i][j]$表示$i$个人坐成一圈玩游戏，第$1$个人为庄家，到最后第$j$个人胜出的概率。这样就可以实现$O(n^2)$的状态数，$O(n)$的转移。

怎样转移呢？

首先枚举庄家抽到的卡牌$k$，得到这一轮被淘汰的人的位置$d$。当然，如果$d==j$，就不要考虑这个$k$值了（因为这表示此轮第$j$个人被淘汰）。

而第$d$个人被淘汰之后，剩下的$i-1$个人要组成一个新的环，庄家为第$d$个人的下一个。容易算出，当$d>j$时，第$j$个人是新的环里从新庄家数起的第$i-d+j$个人，当$d<j$时，第$j$个人是新的环里从新庄家数起的第$j-d$个人。

容易推出状态转移方程为：

$$
```cpp
f[i][j]+=
\begin{cases}
f[i-1][i-d+j]/m,   & \text{$d>j$} \\
f[i-1][j-d]/m,      & \text{$d<j$} \\
0,                       & \text{$d==j$}
\end{cases}
```
$$
最后第$i$个人胜出的概率就是$f[n][i]$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 55;
int n, m, num[N]; double f[N][N];
int main() {
    int i, j, k; n = read(); m = read();
    for (i = 1; i <= m; i++) num[i] = read();
    f[1][1] = 1;
    for (i = 2; i <= n; i++) for (j = 1; j <= i; j++)
    for (k = 1; k <= m; k++) {
        int d = num[k] % i; if (!d) d = i;
        if (d > j) f[i][j] += f[i - 1][i - d + j] / m;
        else if (d < j) f[i][j] += f[i - 1][j - d] / m;
    }
    for (i = 1; i <= n; i++) printf("%.2lf%% ", f[n][i] * 100);
    printf("\n");
    return 0;
}
```

---

## 作者：Hanzelic (赞：9)

这道题十分的巧妙啊。  
看到这道题的第一眼感觉挺简单，但是事实证明我想错了。  
我想到的最基本的 dp 思路是枚举第 $i$ 个人在第 $j$ 个位置时抽到的卡牌为 $k$ 没有被踢出去的概率。  
但是显然，这种 dp 会重复计算 $i$ 的不合法状态，因为你在转移方程的时候不能计算之前 $i$ 有没有被踢出去。  
既然这种方法不行的话我们就可以考虑改变 dp 的维度，即   


**$dp_{i,j}$ 用来表示当前还剩余 $i$ 个人的时候从庄主开始（包括庄主）第 $j$ 人能够不被踢出去的概率**。   


至于为什么，因为你的回合数是跟人数密切相关的。假设在第 $q$ 回合的时候还剩 $i$ 个人，那么显然 $i=n-(q-1)$。同时你不被踢出去的概率只同庄主和第 $i$ 个人的位置之间的关系还有抽到的卡牌 $k$ 相关。  
我们可以枚举剩余人的个数 $q$ 和抽到的卡牌的数字 $card_{j}$，进而求出每个  $card_{j}$ 所对应的被淘汰的人 $p$（记得判断一下不要让 $p$ 溢出），   

**那么可以得到 $p+1$ 就是下一回合的庄主。在这些基础上继续枚举从庄主开始的每一个人 $i$，由此得到一个递推式：**  
$$dp_{q,p}=\sum_{i=1}^{q-1}\frac{dp_{q-1,i}}{m}$$ 
我们能知道当只剩一个人的时候他是百分百不会被踢出去的，那么 $dp_{1,1}=1$，最后进行递推就可以了。  
那么这道题也就结束了。  
最后附上代码：
```cpp
#include<bits/stdc++.h>
#define M 55
using namespace std;
int n,m,a,b,c;
int card[M]; 
double dp[M][M];
int main(){
	scanf("%d%d",&n,&m);
	for(int q=1;q<=m;q++){
		scanf("%d",&card[q]);
	}
	dp[1][1]=1;
	for(int q=2;q<=n;q++){
		for(int i=1;i<=m;i++){
			int p=card[i]%q==0?q:card[i]%q;
			for(int o=1;o<=q-1;o++){
				p++;
				if(p>q)p=1;
				dp[q][p]+=dp[q-1][o]/m;
			}
		}
	}
	for(int q=1;q<=n;q++){
		printf("%.2lf%% ",dp[n][q]*100);
	}
	return 0;
} 
```


---

## 作者：bzy369258147 (赞：7)

看了其他题解发现自己太弱了，大佬们都是O($n^2*m$)的优秀DP，而我只能想出来一个O($n^3*m$)的垃圾DP,唯一优秀一点的是空间复杂度为O(n)，AC这题是绰绰有余了.

思路是枚举该次统计$i$获胜的概率，然后设$dp_j$为本轮庄家顺时针到i的距离，然后枚举 轮数、使用卡片、j 转移即可转移方程为

$$dp[ j-card[u]\%j + turn] += dp[j]*(1/m)$$
或
$$dp[ j-card[u]\%j] += dp[j]*(1/m)$$

然后代码如下:

```
#include<bits/stdc++.h>
using namespace std;

double dp[55];
double dt[55];
int  card[55];

bool isPn(int x){
    for(int i = 2;i <= sqrt(x);i ++)if( x % i == 0 )return false;
    return true;
}
bool calc(int x){
    for(int i = 2;i <= sqrt(x);i ++)if( x % i == 0 and !isPn(x/i) )return false;
}

int main(){
    int n,m;cin >> n >> m;double e = 1.0 / m;
    for(int i = 1;i <= m;i ++)cin >> card[i];
    for(int i = 1;i <= n;i ++){
        for(int j = 0;j <= n;j ++)dp[j] = 0.0;dp[i] = 1.0;
        for(int j = n;j > 1;j --){
            for(int k = 0;k <= n;k ++)dt[k] = 0.0;
            for(int u = 1;u <= m;u ++){
                int nln = card[u] % j;
                if( nln == 0 )nln = j;
                for(int v = 1;v <= n;v ++){
                    if( nln > v )dt[v + j - nln] += dp[v] * e;
                    if( nln < v )dt[v - nln] += dp[v] * e;
                }
            }
            for(int k = 0;k <= n;k ++)dp[k] = dt[k];
        }  
        printf( "%.2lf%% ",dp[1] * 100 );
    }
    return 0;
}
```

---

## 作者：FLORIZ (赞：6)

## **思路构建**

首先他给了几个人和几张牌，咱们会发现这几个人没什么本质不同，只是编号不一样。每次抽牌都是放回的，显然每次抽牌的可能性也是相同的。

所以对于这个问题，确定了一开始的庄家，它的整个”结构“是确定的，和人数并没什么特殊关系。

换句话说，这个题我们在牌组已经确定的情况下，不考虑什么时间空间，能求任意几个人的情况下每个人的胜率。

这里就类似前面做的组合数学里的排列选数（P2606），那个是二叉树，也是结构已经确定，通过结构的结论得出。不过那个确定数之后结构才确定，而且结构也就是完全（接近）二叉树的优美结构。这个的具体结构需要自己找，而且不必要限定数量。

（好像所有 dp 题都有这么一个“结构”，像那个题 red is good 。）

接下来，问题在于，怎么找？

首先， dp 的 $f$ 数组该怎么设计？它的数据最大在50以内，因此我们有信心大胆开到三，甚至四维（？）。针对它要输出每个人的各自胜率，我们可以确定有一维存的是人的编号。

剩下的不好直接断定，主要有剩下的人数，比赛进行的轮数，庄家是谁，这轮抽到的牌是第几张……不太好说，但是我们知道要用什么。

最想要的大概就是每轮过后剩下的人有哪几个吧，状压能压到一维，但是 $n$ 的值比较大，50，这样不行，就算拆分成很多维内存也会炸；而且这样给我们 $f$ 数组的状态也变多了不少，时间复杂度也会炸。这个大抵是存不下来的；

其次呢，我们发现剩下的人数和比赛进行的轮数能简单互推，总人数-(比赛轮数+1）就是剩下的人数，这俩存下来就是一个意思。这个想存的话肯定是能存的，而且这个能给我们提供 dp 的“进度条”，是肯定要存的；

再有，我们是不是要存这轮庄家是谁？这个按普通的模拟的想法是不好求的，但是我们只要确定了结构，确定在每个人当庄家的时候状态要怎么更新并不难，而且大抵复杂度不会炸（因为没有确定怎么更新所以不能断定），存一下也好。

现在问题在于，我们不知道每轮游戏有谁活着，因此也就很难绕开一些不可能存在的状态对答案产生的影响，那有没有办法绕开具体谁没出局？

如果是正着推，从第一轮开始，我们会发现我们在枚举下一个情况的时候编号是不能忽略的，所以一定会用到死亡情况。

如果是反着推：

剩一个人的时候，他是庄家而且肯定赢了；

两个人的时候，咱们枚举牌抽到哪个，也能判断哪个人最后剩下；

三个人的时候，也是枚举牌抽到哪个，也能判断剩下两个人的时候谁是庄家，然后过渡到两个人的结构；

……

也就是说只要第一次能指定庄家，后面的概率就都确定了。

（这里好像不指定庄家，庄家在所有人里面随机决定，算出来的每个人胜负概率也是相等的。）

而我们恰好知道第一次是1为庄家，所以后面庄家的也都确定了。所以我们不用存每一轮谁是庄家，只要知道抽到这张牌的时候下一轮庄家是这一轮编号中的谁,用于更新状态,即可。

而且这些人没本质不同，不管编号，每次把庄家都提到第一个人的位置，前面的推结构也都是成立的（毕竟推出来的时候就没管编号）。



--————————————————————

## 结论

状态转移：

枚举人数 $i$；

枚举抽到的牌 $k$；

找到这一轮处决谁 $p$；

按照上一轮从 $p+1$ 到 $p$ 的上一个 的顺序更新胜率。（也就是默认从 $i-1$ 到 $i$ 新加的那个人正好是应该出局的。)

$f[i][p]=\frac{1}{m}\sum f[i-1][j]$；	

边界：$f[1][1]=1$；

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
	{int f(1),x(0);
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return f*x;
	}

#define maxm 51
int n,m;
int a[maxm];

double f[maxm][maxm];

int main()
	{n=read(),m=read();
	for(int i=1;i<=m;i++)
		{a[i]=read();
		}
	f[1][1]=1;
	for(int i=2;i<=n;i++)
		{for(int k=1;k<=m;k++)
			{for(int j=1,p=(a[k]%i==0)? i:a[k]%i;j<=i-1;j++)	
				{p++;
				if(p>i)
					{p%=i;
					}
				f[i][p]+=f[i-1][j]/(double)(m);
				}
			}
		}
	for(int i=1;i<=n;i++)
		{printf("%.2lf",100*f[n][i]),putchar('%');
		if(i!=n) putchar(' ');
		}
	return 0;
	}
```
当然，看到 $f[i]$ 的状态只和 $f[i-1]$ 有关，我们也可以大大方方地拿滚动数组滚掉一维。

如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
	{int f(1),x(0);
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return f*x;
	}

#define maxm 51
int n,m;
int a[maxm];
bool pan;
double f[2][maxm];

int main()
	{n=read(),m=read();
	for(int i=1;i<=m;i++)
		{a[i]=read();
		}
	
	f[0][1]=1.0;
	
	for(int i=2;i<=n;i++)
		{pan^=1;
		for(int j=1;j<=i-2;j++)
			{f[pan][j]=0;
			}
		for(int k=1;k<=m;k++)
			{for(int j=1,p=(a[k]%i==0)? i:(a[k]%i);j<=i-1;j++)	
				{p++;
				if(p>i)
					{p=1;
					}
				f[pan][p]+=f[pan^1][j]/(double)(m);
				}
			}
		}
	
	for(int i=1;i<=n;i++)
		{printf("%.2lf",100*f[pan][i]),putchar('%');
		if(i!=n) putchar(' ');
		}
	return 0;
	}
    
```
审核辛苦了。

---

## 作者：TempestMiku (赞：6)

# [P2059题目传送门](https://www.luogu.com.cn/problem/P2059)

## 思路设计

按照一般思路，$N$ 个人有 $m$ 张牌，最后需要求 $N$ 个人胜利的概率。动态规划转移方程肯定会有一维表示**第几人**。

但是这道题是**约瑟夫环**的基础上进行游戏，每轮游戏完之后会踢出一个人，所以每轮游戏的人数是不一样的。

先考虑这样一个**关键**的问题，这道题是顺推还是逆推？

- 假设是顺推，我们需要从第一场游戏（即剩下 $n$ 个人）推到第 $n-1$ 场比赛（即剩下 $1$ 个人），~~显然~~你不知道最开始每个人赢的概率，所以不能顺推。

- 相反的，如果是逆推，我们需要从第 $n-1$ 场游戏（即剩下 $1$ 个人）推到第 $1$ 场比赛（即剩下 $n$ 个人），总共进行 $n-1$ 场游戏。

于是我们可以用 $dp[i][j]}$ 表示剩下 $i$ 个人的时候，**从庄家开始**第 $j$ 个人的存活概率。

可能有人会问：为什么不用进行到第 $i$ 轮游戏或者编号为 $j$ 的人的获胜概率呢？

- 因为剩下 $i$ 个人就可以表示出来进行到第几轮游戏了（每轮游戏踢出一个人）。

- 如果是编号为 $j$ 的人的获胜概率，那么你的初始状态可能无法设计，假设只剩下 $1$ 个人了，每个人都有一定的概率获胜，而分别获胜的概率又是根据随机抽牌决定的。所以初始状态难以设计。

## 动态规划转移

设 $dp[i][j]$ 表示剩下 $i$ 个人的时候，**从庄家开始**第 $j$ 个人的存活概率。

可以看出这里 $j$ 表示的人的编号并不是确定的。

按照套路，先找出转移边界：$dp[1][1]=1$。意思是剩下 $1$ 个人的时候，从庄家开始第一个人获胜的概率是 $1$。

然后第一层循环从 $i=2$ 开始枚举剩下几个人，第二层循环 $j$ 枚举抽到的卡牌数。

根据**约瑟夫环**，根据抽到的牌和这轮的人数算出这轮踢出的人。

算出来剩下 $i$ 个人的时候，所有踢出人的位置，抽到对应每个人的概率显然就是牌的数量，即 $\frac{1}{m}$。

然后通过剩下 $i-1$ 个人的状态推出剩下 $i$ 个人的状态。剩下 $i$ 个人的时候踢出的人的下一个人就是剩下 $i-1$ 个人的时候的庄家。

然后根据这两轮庄家后相同的人转移：剩下 $i-1$ 个人的时候，假设庄家是 $o$，剩下 $i$ 个人的时候，假设庄家是 $p$，那么我们可以将剩下 $i-1$ 个人的时候 $o$ 之后的每个人的概率都转移到剩下 $i$ 个人的时候 $p$ 的之后每个人的上面。

![](https://cdn.luogu.com.cn/upload/image_hosting/9qurmfgo.png)

如图，左边是剩下 $i$ 个人的情况，右边是剩下 $i-1$ 个人的情况，我们可以将左侧编号 $1$ 转移到右侧编号 $1$，左侧编号 $2$ 转移到右侧编号 $2$ 等等。



设 $p$ 和 $k$ 是第 $i$ 轮的庄家后第 $p$ 个人和第 $i-1$ 轮庄家后第 $k$ 个人。这里要枚举庄家后每一个人，将每轮对应庄家转移，那么最后对于第 $i$ 个人来说，他获胜的概率是 $dp[n][i]$。因为剩下 $n$ 个人的时候，$1$ 为最初的庄家，庄家后第 $i$ 个人就是对应编号的第 $i$ 个人。

最后放上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace Testify{
    inline int read(){
        int f(1),x(0);
        char ch=getchar();
        for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
        for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
        return f*x;
    }
    inline void Write(int x){
        if(x>9) Write(x/10);
        putchar(x%10+48);
    }
    inline void write(int x){
        if(x<0) putchar('-'),x=-x;
        Write(x);
        putchar(' ');
    }
}
using namespace Testify;
const int N=1e5+5;
int n,m;
double dp[55][55];//剩下i个人，赢的人从庄家 数起是j的概率()
int card[55];
signed main(void){
    n=read(),m=read();
    for(register int i=1;i<=m;i++){
        card[i]=read();
    }
    dp[1][1]=1.0;//只剩下1个人力
    for(register int i=2;i<=n;i++){//
        for(register int j=1;j<=m;j++){
            int p=card[j]%i;
            if(p==0) p=i;
            for(register int k=1;k<i;k++){//上一个状态
                p++;
                if(p>i) p=1;
                dp[i][p]+=(dp[i-1][k]/m);
            }
        }
    }
    
    for(register int i=1;i<n;i++){
        printf("%.2lf%% ",dp[n][i]*100);
    }
    printf("%.2lf%%",dp[n][n]*100);
    return 0;
}
```


---

## 作者：maomao9173 (赞：4)

补充一张图片便于理解。本身思想和解法请参考 @钟梓俊 的题解。

![](https://cdn.luogu.com.cn/upload/pic/33475.png )

Code:附相对详细的注释
```cpp
    f[1][1]=1.0;//表示还剩一个人的时候
	//f[i][j]表示在还剩下i个人时，从庄家开始数第j个人的获胜的概率 
	//最终归纳出来得到庄家是1号，所以可以直接硬上
	//与普通DP不太一样，期望DP的写法更常见于从确定态(最终态)向初始态反向转移。 
    for(rint i=2;i<=n;++i){//一共有n-1局/记录剩余人数 
        for(rint j=1;j<=i;++j){
			//在每一局中f[i][j]所记录的内容都不具有对象针对性。但是对于最终解就是可以直接利用推导。 
            for(rint k=1;k<=m;++k){
                int c=(num[k]-1)%i+1;//本局被淘汰的人是c
				//如果被淘汰的是j不做处理 
				//经过淘汰c以后过渡到上一个状态，所以要区分c在前面和c在后面 
				if(c>j)f[i][j]+=f[i-1][j-c+i]/m;//上一个状态胜率/m(m种选择)叠加 
				//对答案的算法是不被淘汰的概率，也是题目的初始态要求 
                if(c<j)f[i][j]+=f[i-1][j-c]/m;//求解赢的次数比上所有可能选择
				/*
					逆推比较抽象而难以理解. 
					原本是顺时针走的,这里处理成逆时针走.
					如果本局删除的人在j的后面,则在下一局(上一个状态)中,j的庄家就在其后。
					那么对于在剩余i-1个人的时候，第j个人相对于第c+1个人的位置就是j-c+i; 
					同理可以得到j-c 
				*/
            }
        }
    }
```

---

## 作者：Boxxxxxx (赞：3)

[救救访问量](https://blog.csdn.net/qq_43804974/article/details/104500679)


首先仔细读题目
**按顺时针从庄家位置数第X个人将被处决即退出游戏**，

x为1的时候被处决的就是庄家，千万不要理解错位庄家的位置+x就是被处决人的位置。

~~我一开始就是这么理解然后调完发现怎么加起来答案是1但是和样例长的不一样~~ 

我们思考下怎么做，对于如此小的数据范围，肯定是可以枚举每一次游戏某一个人获得胜利的概率，如果比如数据范围偏大，那就dp的设计就要去想一次dp得全部答案的方法，要有这个设计方程前的理性思考。

如果我们要得到每个人胜利的概率就需要明确的是

 1. 在进行的所有轮次，主人公必定不能死。
 2. 我们不去关心到底现在谁是还活着的人。

为什么我们不需要关心现在谁活着？因为对于任意一轮，都是庄家选牌，然后某个人死了，然后庄家换人。

不管在场的人是谁，在选牌概率方面都是不会有影响的，明确了这点之后就可以舍弃掉枚举现在谁还活下来这种状态。

接下来是，我们需要什么状态？除了最后一轮之前，我们必然会拥有的东西是什么？**主人公和庄家！！！！**这两个是必然会存在（可能是同一人）。

明确了这上面这一点后就是要找出主人公和庄家最重要的关系。就是**位置！！！**

庄家选牌，然后从庄家位置数第X个人将被处决，我们的状态可以设计为庄家到主人公顺时针的位置距离。因为这样我们就可以知道庄家选了这张牌后，到底我们的主人公死没死。

设计f[i][j], 表示的是现在在第i轮， 庄家与主人公的距离为j的概率。

状态设计完了后，我们要考虑怎么转移，其实就是我们要算出新的庄主与主人公的顺时针距离是多少。

 

z1 : 当前庄主与新庄主的顺时针距离，

 z2:当前庄主与主人公的顺时针距离
 
 num:当前轮的人数是多少（还没杀死人）
 
我们需要知道新庄主与主人公的顺时针距离，手动玩一玩推一推就可以知道是


```cpp
int  t;
	if (z1 >= z2)t =  ((num + 1) - (z1 - z2 + 1) + 1);
	else  t = z2  - z1 + 1;
```


因为是顺时针距离，

如果z1 >= z2那么就是要让新庄主跑一个大圈回到主人公，要从新庄主走到从1开始的位置让在走到主人公。

如果是z1 < z2 那么就是直接新庄主往前跑一点点就是可以到达主人公，不需要新走一遍。

由于我们是设计的状态只是主人公与庄主是位置。所以我们可以这么认为每一新的轮次都把庄主看做在位置1就比较方便理解。

然后写代码的话就是从f[0][j] = 1,j就是主人公与庄主的位置，不断向外部转移就好了。

最后答案就是f[n-1][1],1就是指的庄主与主人公位置是1，也就代表着，庄主就是主人公。最后的幸存者。

~~其实我觉得唯一的难点是那个推出新庄主与主人公的顺时针位置，我推了好久~~ 

下面是代码主体

```cpp
int n,m,node[max_];//f[i][j]:第i论，庄家与主人公的顺时针距离为j
double f[max_][max_];
int get_len(int z1, int z2,int num) {
	int  t;
	if (z1 >= z2)t =  ((num + 1) - (z1 - z2 + 1) + 1);
	else  t = z2  - z1 + 1;
	 while (t > num){
		 t -= num;
	 }
	 return t;
}

signed main() {
	n = read(), m = read();
	for (int i = 1; i <= m; i++) {
		node[i] = read();
	}
	double stander = 1.0 / m;
	for (int i = 1; i <= n; i++) {
		//主人公是i
		memset(f, 0, sizeof(f));
		f[0][i] = 1.0;
		for (int j = 0; j < n; j++) {
			//游戏进行到第j轮
			for (int z = 1; z <= n; z++) {
				//庄家与主人公的距离为z
				if (f[j][z] < eps)continue;
				int num = n - j;
				for (int x = 1; x <= m; x++) {
					//枚举所有牌
					int wei = node[x];
					while (wei > num){
						wei -= num;
					}
					if (wei == z)continue;
					wei++;
					while (wei > num ) {
						wei -= num ;
					}
					int len = get_len(wei, z, num);
					f[j + 1][len] += stander * f[j][z];
				}
			}
		}
		printf("%.2lf", f[n - 1][1] * 100);
		cout << '%';
		if (i != n)cout << " ";
	}
	return 0;
}
```



---

## 作者：Santiego (赞：2)

# [JLOI2013]卡牌游戏 概率DP

[$\text{My Blog}$](https://www.cnblogs.com/santiego/p/11437925.html)

$dfs$复杂度爆炸，考虑DP。发现决策时，我们只用关心当前玩家是从庄家数第几个玩家与当前抽到的牌是啥。于是设计状态$f[i][j]$表示有$i$个人时，**从庄家数第$j$个人**的胜率。又因为此时终态确定$f[1][1]=1$（只有一个人时那个人胜率为100%），所以倒推回去。

转移时，枚举抽到的牌，算出从庄家数第$t$个会出局，那么下一局庄家就是第$t+1$个，当前局第$j$个就是下一局的第$j-t(t< j)$或$i-t+j(t> j)$个，状态于是就从$i$转移到了$i-1$

```cpp
if(t>j) f[i][j]+=f[i-1][i-t+j]/m;
else if(t<j) f[i][j]+=f[i-1][j-t]/m;
```
代码：


```cpp
#include <cstdio>
#define MAXN 1001
using namespace std;
double f[MAXN][MAXN];
int a[MAXN];
int n,m;
int main(){
	scanf("%d %d", &n, &m);
	for(int i=1;i<=m;++i) scanf("%d", &a[i]);
	f[1][1]=1;
	for(int i=2;i<=n;++i)
		for(int j=1;j<=i;++j)
			for(int k=1;k<=m;++k){
				int t=((a[k]%i==0)?i:(a[k]%i));
				if(t>j) f[i][j]+=f[i-1][i-t+j]/m;
				else if(t<j) f[i][j]+=f[i-1][j-t]/m;
			}
	for(int i=1;i<=n;++i) printf("%.2f%% ", f[n][i]*100);
	return 0;
}
```



---

## 作者：TsReaper (赞：2)

这是一个约瑟夫问题的变种。

一、约瑟夫问题

1、什么是约瑟夫问题：

n个人（编号0~(n-1）），从0开始报数，报到（m-1）的退出，剩下的人继续从0开始报数。求胜利者的编号。（来自百度百科）

2、约瑟夫问题的解法

记f(i)表示i个人玩约瑟夫游戏的最终胜利者。

显然f(1) = 0

如果n个人玩约瑟夫游戏，显然，第一轮游戏后，(m-1) mod n号玩家将会退出。问题变成了剩下的n-1个人玩约瑟夫游戏。

我们将这n-1个人重新编号，令k = m mod n（也就是退出游戏的玩家的下一位）。

k --> 0

k+1 --> 1

k+2 --> 2

...
...
k-2 --> n-2

假如我们知道f(n-1)的答案是x，那么x号玩家在n个人玩的游戏中的编号应该是(x+m) mod n。

也就是说f(n) = (f(n-1)+m) mod n

这样我们就得到了递推式，根据该式就可以得到约瑟夫问题的答案。

二、本问题

由于m的值在本问题中无法确定，那么游戏的胜利者也无法确定。

所以，我们记f(i,j)为i个人玩约瑟夫游戏，j号玩家胜利的概率。

由约瑟夫问题可知，f(i+1,j) = 求和(f(i,k)\*1/m) 。设第x张卡片上的数字为px，则k为满足(k+x) mod (i+1) = j的所有数。

这样我们就求出了所有玩家获胜的概率。


---

## 作者：gryql (赞：1)

题目中的注释应该够了吧，像是猴子选大王一样的约瑟夫环问题，不过直接搜索的话超时是一定的，需要用DP扫描一遍，时间复杂度O(M\*N^2);


var f:array[1..50,1..50] of real;//f[i,j]表示i个人玩游戏第j个人获胜概率

```cpp
    a:array[1..50] of longint;
    n,m,i,j,k,w:longint;
begin
    readln(n,m);
    for i:=1 to m do read(a[i]);
    fillchar(f,sizeof(f),0);
    f[1,1]:=1;//一共一个人了还打啥，赢了呗
    for i:=2 to n do //总共剩下i人
        for j:=1 to n do //当前是j的庄家
            for k:=1 to m do //枚举可能的牌数
                begin
                    w:=a[k] mod i;
                    if w=0 then w:=i;
                    if w>j then f[i,j]:=f[i,j]+f[i-1,(i-w+j)]/m;
                    if w<j then f[i,j]:=f[i,j]+f[i-1,j-w]/m;
                end;
    for i:=1 to n do write((f[n,i]*100):0:2,'%',' ');
end.

```

---

## 作者：ysner (赞：1)

看见题解没有C++代码，本蒟蒻冒昧为C++党献上一份。

此题为概率DP。

有一个很重要的性质：当前人获胜的概率只与其在排列中与庄家的相对位置和人数有关，跟具体有哪些人无关。

那么我们可以用f[i][j]表示还有i人时从庄家开始数第j个人获胜的概率。

于是可以枚举当前每种可能然后从f[i-1][\*]转移，这就可以写成一个DP了。


```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
double f[55][55]={};
int n,m,i,j,k,w,a[55]={};
il int gi()//读入优化
{  
  re int x=0;
  re short int t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  n=gi();m=gi();
  fp(i,1,m) a[i]=gi();
  f[1][1]=1;//只有一个人时即胜利
  fp(i,2,n)//剩下i人
    fp(j,1,n)//当前是j的庄家
      fp(k,1,m)//枚举牌数
      {
          w=a[k]%i;
          if(w==0) w=i;
          if(w>j) f[i][j]+=f[i-1][i-w+j]/m;
          if(w<j) f[i][j]+=f[i-1][j-w]/m;
      }
  fp(i,1,n) printf("%.2lf%% ",f[n][i]*100.0);//输出%要打两个%。。。
  return 0;
}

```

---

## 作者：Che_001 (赞：0)

## 题意

$n$ 个人坐成一圈，按顺时针从 $1$ 到 $n$ 编号。第一回合是玩家 $1$ 作为庄家。每个回合随机从卡牌堆里选择一张卡片，设卡片上的数字为 $val_k$，将按顺时针从庄家位置数第 $val_k$ 个人处决。被处决的人按顺时针的下一个人将会作为下一轮的庄家。求每个玩家胜出的概率。

## Solution

显然概率 dp。发现每个人的编号是不重要的，只有相对位置是有意义的信息。故设 $dp_{i,j}$ 为当前有 $i$ 个人，庄家为 $j$ 的获胜概率，枚举每一张卡牌 $val_k$，则有转移方程：
$$
\begin{cases}\, dp_{i,j}\gets \dfrac{dp_{i-1,j-val_k}}{m},&val_k\lt j\\\,dp_{i,j} \gets 0,&val_k=j\\\,dp_{i,j}\gets \dfrac{dp_{i-1,j+i-val_k}}{m},& val_k\gt j \end{cases}
$$
初始状态为 $dp_{1,1}=100\%$。时间复杂度为 $\mathcal{O}(n^2\times m)$，可以通过本题。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,flag=1;
	char ch=getchar();
	while(!isalnum(ch)) (ch=='-')?flag=-1:1,ch=getchar();
	while(isalnum(ch)) res=res*10+ch-'0',ch=getchar();
	return res*flag;
}
int val[100];
double dp[100][100];
int main(int argc,const char *argv[])
{
	int n=read(),m=read();
	for(int i=1;i<=m;i++)
		val[i]=read();
	sort(val+1,val+m+1);
	dp[1][1]=1.0;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=1;k<=m;k++)
			{
				int pos=val[k]%i;
				if(pos==0)
					pos=i;
				if(pos<j)
					dp[i][j]+=dp[i-1][j-pos]/m;
				if(pos==j)
					dp[i][j]+=0.0;
				if(pos>j)
					dp[i][j]+=dp[i-1][j+i-pos]/m;
			}
		} 
	}
	for(int i=1;i<=n;i++)
		printf("%.2f%% ",dp[n][i]*100.0);
	return 0;
}
```

---

## 作者：leozhang (赞：0)

非常好的一道题

看到这道题，肯定能想到概率dp，但是状态的设计与转移都是一个难点

如果正向模拟来设计状态，那么不难发现是很难以转移的

所以我们考虑反向模拟，用类似博弈的方法来转移

不难发现，如果只剩了最后一个人，那么这个人获胜的概率是1

而如果只剩两个人，我们完全可以通过摸牌的情况算出每个人的胜率（这里的胜率是先手和后手之分）

而如果剩三个人，我们发现通过摸牌会先淘汰一个人，然后就变成了两个人的局势，同时可以找出一个人在三人局中的位置和他在两人局中位置的对应关系

而这不就是一个转移吗

其余更多部分也就是同理啦

设状态为f[i][j]表示局中还剩i个人时，第j个人的胜率

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
double f[55][55];
int n,m;
int a[55];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&a[i]);
    }
    f[1][1]=1;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int temp=a[j]%i;
            if(!temp)
            {
                temp=i;
            }
            for(int k=1;k<i;k++)
            {
                temp++;
                if(temp>i)
                {
                    temp=1;
                }
                f[i][temp]+=f[i-1][k]*(double)1.0/(double)m;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%.2lf%% ",f[n][i]*100.0);
    }
    return 0;
}

```


---

## 作者：G_A_TS (赞：0)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10355569.html)  

------------
概率dp  
不懂的同学可以先看[这里](https://blog.csdn.net/ever_glow/article/details/81987176)  
然后关于本题。。。~~这张图说明了一切~~  
![](https://i.loli.net/2019/02/07/5c5c30cb19c28.png)  
摘自[钟梓俊](https://www.luogu.org/space/show?uid=48269)dalao题解  
上代码  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int num[60];
double dp[60][60];//表示剩i个时从庄家数第j个的获胜概率 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>num[i];
	}
	dp[1][1]=1;
	for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            for(int k=1;k<=m;k++)
            {
                int c=(num[k]%i)?(num[k]%i):i;
                if(c>j)
                {
                    dp[i][j]+=dp[i-1][i-c+j]/m;
                }
                else
					if(c<j)
                	{
                    	dp[i][j]+=dp[i-1][j-c]/m;
                	}
            }
        }
    }
	for(int i=1;i<=n;i++)
	{
		printf("%.2lf",dp[n][i]*100);
		cout<<"% ";//玄学输出？ 
	}
} 
```

---


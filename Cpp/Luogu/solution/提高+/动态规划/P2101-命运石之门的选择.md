# 命运石之门的选择

## 题目描述

在某一条不知名世界线的冈伦今天突然接到了一条dmail，上面说世界线将会发生巨大变动，未来的他无论如何都无法扭转这种变动回到原来的世界线。而世界线变动的原因是现在的他不久后错过了与助手的约会。他约好要和助手去约会，但是在去约会之前，由于一直拖欠房租，房东大叔要求他帮忙完成一幅画的上色，然而他没有以最快的速度完成这个任务，导致他错过了与助手的约会，从而导致世界线的剧变。现在到了拯救世界的时候，由于冈伦并不擅长画画，于是他找到了同样不擅长画画的你来帮他解决这个问题（这是命运石之门的选择）。不管怎样现在拯救世界的重任交到了你的手上，而你虽然不擅长画画，但是你可以使用编程来帮助你解决这个问题。

一幅画由 $N$ 个宽度为 $1$ 高度为 $H_i$ 的矩形组成，矩形并排排列，相邻的矩形间没有空隙，初始情况下每个矩形都是没有颜色的。你有一个宽度为 $1$ 的刷子，可以竖直或水平的刷，每次使用刷子，刷子都必须保证一直全部处于矩形中，即不能刷到矩形以外的地方去，当然每次刷的时候也不能拐弯。每刷一次，要花费 $1$ 的时间，这和刷的长度无关，比如你可以从最左边刷到最右边（当然是不经过矩形以外的部分），这也只花费 $1$ 的时间。你的目的是将全部的矩形都涂满颜色。请你计算并输出这个最短的时间。

## 说明/提示

对于 $30\%$ 数据，$N\leq20, H_i\leq100$

对于 $60\%$ 数据，$N\leq100, H_i\leq1000$

对于 $100\%$ 数据，$N\le5000, H_i\leq10^9$

## 样例 #1

### 输入

```
5
2 2 1 2 1```

### 输出

```
3```

# 题解

## 作者：keep_ (赞：21)

# P2101 命运石之门的选择 （分治)

## 介绍 
**El Psy Congroo**

题目[链接](https://www.luogu.com.cn/problem/P2101)

没错，作为石头门厨，怎么能不做石头门的题呢？(在搜石头门的时

候搜到了本题)

本题作为一道分治基础练习题还是不错的，虽然看起来挺简单,但还

是有不少需要思考的地方的。(~~可能是我太菜了~~)

## 分析

我们对本题进行分析，

就拿下面这个图举例

[![D3n1rn.md.png](https://s3.ax1x.com/2020/11/21/D3n1rn.md.png)](https://imgchr.com/i/D3n1rn)


我们首先观察到了红色部分，红色部分是当前所能构成的最大矩形

我们拥有两种涂色方法，横着涂和竖着图，因为涂一次色的代价与涂

色面积无关，所以我们每一次涂色需要尽可能的多涂。

对于红色部分，显然，全部采用同一种涂色方法是要比两

种方法同时采取更优的，因为当我们混用涂色方法时，一定是可以

通过去掉某一次涂色来降低所需代价的。

针对红色部分，如果我们全部采用竖着涂，因为我们要尽可能的多

涂，所以我们既然可以竖着涂完红色部分，也可以在同代价下涂完

整个图，所以我们目前涂完整个图的代价就是当前图形的宽度，如

果我们采用横着图，涂完整张的总代价就是（该图形中最低的小矩

形的高度）+（涂完红色部分以外部分的最小代价）

我们所要求的答案就是这两种方法的代价最小值

那如何求出涂完红色部分以外部分的最小代价呢？

这时候就要采用分治思想了，

我们用原图形减去红色部分，得到了一个或几个图形，我们目前要

求的就是涂完所有新图形的最小代价，我们针对每一个新图形都按

先前求原图形的最小代价的方法处理，最后将其合并即可。

放一下代码

```c++
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#define int long long
using namespace std;
const int maxn=1e4;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')	
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
int n;
int m;
int a[maxn];
int slove(int l,int r){
	if(l==r){
		return 1;//边界
	}
	int t=r-l+1;//目前图形的宽度
	int minn=0x3f3f3f3f;
	for(int i=l;i<=r;i++){
		if(a[i]<minn){
			minn=a[i];//找到最低矩形的高度
		}
	}
	int ans=minn;
	for(int i=l;i<=r;i++){
		a[i]-=minn;//减掉红色部分
	}
	int ll=l;
	for(int i=l;i<=r;i++){
		if(a[i]&&!a[i-1])
			ll=i;
		if(a[i]&&(!a[i+1]||i==r)){
			ans+=slove(ll,i);//分治处理
		}
	}
	return min(ans,t);
}
signed main(){
//	freopen("a.txt","r",stdin);
	n=read(); 
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	cout<<slove(1,n); 
	return 0;
} 
```
**这一切都是命运石之门的选择**

---

## 作者：qsmoonzh (赞：15)

这题标签是DP

题解都是分治

那我就来发一篇DP的

我们考虑到一个矩形要么竖着把它刷完（ans+=1），要么横着刷完（ans+=z，z的最大值是该矩形高度，z具体是什么值还与前面刷矩形的方式有关）

主要就是这个z难求，直接递推不好搞，记忆化搜索会更清晰，更好写

我们定义一个“有效横刷高度”来求z，第i个矩形可以利用的“有效横刷高度”就是前面的矩形横着刷延伸到第i个矩形的最大高度。第i个矩形如果横着刷，那么它可以利用“有效横刷高度”，再加上一个花费（可能为0），把该矩形刷完

那么，dp[i][x]=dfs(i,x)表示刷完[i,n]的矩形，其中第i个矩形可以利用的“有效横刷高度”为a[x] 的总花费

竖着刷第i个矩形，“有效横刷高度”为min(a[x],a[i])

那么花费为dfs(i+1,a[x]<a[i]?x:i)+1

横着刷第i个矩形，若a[i]>=a[x],“有效横刷高度”为a[i]，若a[i]<a[x]，“有效横刷高度”也为a[i]

那么花费为dfs(i+1,i)+max(a[i]-a[x],0)

所以dp[i][x]=min(dfs(i+1,a[x]<a[i]?x:i)+1,dfs(i+1,i)+max(a[i]-a[x],0));

然后记忆化即可

不过要注意一下，开int不要开long long，long long会MLE

开int要注意，a[i]最大值为1e9，dp可能会爆，那么怎么办？从另一篇题解得到启发的：只要所有矩形竖着刷，那么ans=n，也就是说，最终一定有ans<=n

所以这样
```cpp
if(a[i]-a[x]>n) ans=dfs(i+1,a[x]<a[i]?x:i)+1;
else ans=min(dfs(i+1,a[x]<a[i]?x:i)+1,dfs(i+1,i)+max(a[i]-a[x],0));
dp[i][x]=ans;
```

代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int n,a[5005],dp[5005][5005];
int dfs(int i,int x) {
	int ans;
	if(i==n+1) return 0;
	if(dp[i][x]!=-1) return dp[i][x];
	if(a[i]-a[x]>n) ans=dfs(i+1,a[x]<a[i]?x:i)+1;
	else ans=min(dfs(i+1,a[x]<a[i]?x:i)+1,dfs(i+1,i)+max(a[i]-a[x],0));
	dp[i][x]=ans;
	return ans;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	memset(dp,-1,sizeof(dp));
	printf("%d",dfs(1,0));
	return 0;
}
```

题解还没写完

一开始我发现long long会MLE

然后我就用map来存状态，确实不MLE了，因为并不是5000*5000个状态都会被使用，，，然后TLE了一个点。。。

不过我觉得这个做法还是有可取之处的

```cpp
#include <algorithm>
#include <cstring>
#include <map>
using namespace std;

struct node {
	int i,x;
	bool operator <(const node &the) const {
		if(i==the.i) return x<the.x;
		else return i<the.i ;
	}
};
long long n,a[5005];
map<node,long long>state;
long long dfs(int i,int x) {
	long long ans;
	node qwq;
	qwq.i=i;
	qwq.x=x;
	if(i==n+1) return 0;
	if(state[qwq]!=0) return state[qwq];
	if(a[i]-a[x]>n) ans=dfs(i+1,a[x]<a[i]?x:i)+1;
	else ans=min(dfs(i+1,a[x]<a[i]?x:i)+1,dfs(i+1,i)+max(a[i]-a[x],0ll));
	qwq.i=i;
	qwq.x=x;
	state[qwq]=ans;
	return ans;
}
int main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	printf("%lld",dfs(1,0));
	return 0;
}
```







---

## 作者：Mr_Li (赞：8)

显然，答案绝对不会超过n，因为无论这张图具体怎样，只要竖着刷图，就只需要n个单位时间。所以，我们尝试构造出一个时间小于n个单位时间的方案。之前我们只考虑竖着刷，我们现在可以尝试横着刷。设最低的矩形高度为x，则我们只有横着刷掉自底向上x个单位长度的地方之下的所有部分，然后再用最快的方式刷掉其他部分。如果自底向上x个单位长度的地方之下的某一个部分没有被涂掉，那么就只能竖着一个一个刷掉这些地方，需要n个单位时间。


 ![](https://cdn.luogu.com.cn/upload/pic/2352.png) 

设最低的矩形高度为x，则我们只有横着刷掉自底向上x个单位长度的地方之下的所有部分

 ![](https://cdn.luogu.com.cn/upload/pic/2353.png) 

如果自底向上x个单位长度的地方之下的某一个部分没有被涂掉，那么就只能竖着一个一个刷掉这些地方


至于如何用最快的方式刷掉其他部分，那就要靠分治了。看上两张图，你会发现剩下的部分被分成了几个连续的矩形，对他们做类似的操作即可。


可以算出，时间复杂度为O(n^2)。


下面是代码（不知道我UBB能不能用）：

[codec/]

```cpp
#include<iostream>
using namespace std;
int n,i,h[5001];
int DC (int first=1,int last=n,int down=0)
{
    if (first==last)
    return 1;
    int i,minimum=1000000001,j,temp=0;
    for (i=first;i<=last;i++)
    minimum=min(minimum,h[i]);
    for (i=first;i<=last;i++)
    if (h[i]>minimum)
    {
        for (j=i;j<last&&h[j+1]>minimum;j++);
        temp+=DC(i,j,minimum);
        i=j;
    }
    return min(temp+minimum-down,last-first+1);
}
int main()
{
    cin>>n;
    for (i=1;i<=n;i++)
    cin>>h[i];
    cout<<DC();
    return 0;
}
[codec]
```

---

## 作者：Juvenile (赞：5)

### 这道题是分治的好题


------------
#### 首先讲解一下分治（分而治之）


>就是把一个复杂的问题分成两个或更多的子问题

>再把子问题分成更小的子问题……直到最后子问题可以**简单的**直接求解，原问题的解即**子问题的解的合并**。

>在计算机科学中，分治法就是运用分治思想的一种很重要的算法。 --百度百科


------------

若您像我一样是**蒟蒻**，请前往**递归，快排、归并**

回到这道题：就是从最低端往上扫，找出在当前（l，r）区间的最小高度，不断做，最后合并答案。

>边界情况，当l=r返回值为1。

>**特判**：返回min(r-l+1,ans)

横着涂的话可能会产生不连通块

此时竖着涂可能更优

#### 此时递归代码易实现，别忘了开 long long：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
#define ll long long
ll a[5009];
ll solve(int l,int r,ll high){
    if(l==r) return 1;
    ll ans,mn=-1,tmp=r-l+1;
    for(int i=l;i<=r;i++)
    	if(mn==-1 || mn>a[i]) mn=a[i];
    ans=mn-high;
    for(int i=l;i<=r;i++)
	{
        int pos;
        if(a[i]==mn) continue;
        for(int j=i;j<=r;j++)
		{
            pos=j; 
            if(j==r || a[j+1]==mn) break;//连续的一段结束,跳出
        }
        ans+=solve(i,pos,mn);
        i=pos+1;
    }
    return min(tmp,ans);//取纵、横更优值
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	printf("%lld",solve(1,n,0));//从1-n开始拆分
	return 0;
}	
```


---

## 作者：Rui_R (赞：4)

石头门厨前来报到。

题解里面似乎都是 $O(n^2)$ 的？

这里提供一个 $O(n \log n)$ 的做法。

[原题](https://www.luogu.com.cn/problem/P2101)

首先，每次要么出现横涂，要么全是竖涂；而如果出现横涂，先横涂再竖涂一定不会劣于先竖涂再横涂。

其次，横涂先涂最底层也不会劣于后涂最底层。因为早晚都要涂掉最底层。

再次，每次涂如果是横涂，必然是一口气做掉当前最矮的矩形并消掉能消掉的部分。

原因：如果不把最矮的消完，横涂就跟没涂一样，因为列数不变，剩下的还是要一列一列涂过去。而且，我们是先涂最底层的。

那么做法就很明显了：每次涂可以出现横涂，此时可以把该部分中最矮的横涂掉，再把该部分所有矩形高度减掉最矮的部分，接着递归计算被涂掉的部分左右两边所需时间。

而如果不出现横涂，那么有几列要涂就要几步。

比较二者大小，取较小值即为答案。

到这里，已经可以 $O(n^2)$ 按上述过程模拟解决了。

但是抱着对~~助手~~石头门深切的热爱，我决定优化复杂度。

观察上述过程：每次尝试横涂时，必然消掉一列，也就是函数最多会被调用 $n$ 次。

然后我们要找最小值，以及区间修改。这可以用线段树做到 $\log n$ 。

于是加个线段树上去就好了。

代码里有注释，希望能解答您的疑惑。

```
#include <cstdio>
#include <cstdlib>

const int maxn=1e5+5;const int inf=1e9+7;

template<typename T>
inline T min(T a,T b){
	return a<b?a:b;
}

template<typename T1=int,typename T2=int>
struct pair{
	T1 ft;T2 sd;
	pair():ft(),sd(){}
	pair(T1 _ft,T2 _sd):ft(_ft),sd(_sd){}
	bool operator<(const pair _Tp)const{
		if(sd!=_Tp.sd) return sd<_Tp.sd;
		return ft<_Tp.ft;
	}
};

int n,a[maxn];

struct Sgt{
	struct node{
		#define null 0
		node *l,*r;pair<> minn;int tag;
		node(){
			l=r=null;tag=0;
		}
		void push_up(){
			if(!l&&!r) return;
			minn=min(l->minn,r->minn);
		}
		void push_down(){
			if(!l&&!r) return;
			if(tag){
				l->tag+=tag;l->minn.sd+=tag;
				r->tag+=tag;r->minn.sd+=tag;
				tag=0;
			}
		}
	}*rt,*pt;
	void init(int Size){pt=(node*)malloc(sizeof(node)*Size*2);}
	node* build(int l,int r){
		node *now=pt++;
		if(l==r){
			now->minn=pair<>(l,a[l]);
			return now;
		}
		int mid=(l+r)>>1;
		now->l=build(l,mid),now->r=build(mid+1,r);
		return now->push_up(),now;
	}
	pair<> wonder_minn(int _l,int _r,node *now,int l,int r){
		if(r<_l||l>_r) return pair<>(004,inf);
		if(_l<=l&&r<=_r) return now->minn;
		now->push_down();int mid=(l+r)>>1;
		return min(wonder_minn(_l,_r,now->l,l,mid),wonder_minn(_l,_r,now->r,mid+1,r));
	}
	void modify(int _l,int _r,node *now,int l,int r,int tag){
		if(r<_l||l>_r) return;
		if(_l<=l&&r<=_r){
			now->tag+=tag,now->minn.sd+=tag;
			return;
		}
		now->push_down();int mid=(l+r)>>1;
		modify(_l,_r,now->l,l,mid,tag),modify(_l,_r,now->r,mid+1,r,tag);
		return now->push_up();
	}
}s;
//为什么要用指针？胸针让我这么干的，据说是为了迷惑机关

int Sg(int l,int r){//第l根柱子到第r根柱子
	int answer=r-l+1;
	pair<> ChrisTina=s.wonder_minn(l,r,s.rt,1,n);//最小值
	if(ChrisTina.sd>=answer) return answer;
	if(ChrisTina.sd) s.modify(l,r,s.rt,1,n,-ChrisTina.sd);
	return min(answer,ChrisTina.sd+Sg(l,ChrisTina.ft-1)+Sg(ChrisTina.ft+1,r));
	//也许你会好奇，同时是最小值的柱子有可能不止一个，于是会弄出来0，导致横消不能
	//但是无妨，那样ChrisTina会找到0，然后递归左右两边，这样就会自动把0给分开
}

int main(){
	scanf("%d",&n);for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	s.init(n);s.rt=s.build(1,n);
	printf("%d\n",Sg(1,n));
	return 0;
}

```

然后因为常数感人并跑不过 $O(n^2)$ 。

---

## 作者：Inui_Sana (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2101) [双倍经验](https://www.luogu.com.cn/problem/CF1400E)

## 解题思路：分治

这篇题解主要解释进行各种操作的原因。

先放张图，帮助大家理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/pim1q6el.png)

先想最劣方案，所有都竖着涂，要涂 $n$ 次。然后思考如何用横着涂来减少操作次数，这里有几个性质。

### 性质 1：如果有一块横涂，那么在它下面的与它相连的每一块也都是横涂。

这个很好理解，如果下面不是的话，就肯定还是需要竖涂，最后发现竖涂部分还会盖住横涂部分（形象的理解）。

### 性质 2：每次横涂一定是尽可能涂多的格子，即涂到两边不能再涂。

这个很也好理解，毕竟它没说不能重复涂……

就算真的要求不重复涂，结合性质 1，我们会发现，横涂只是把竖涂部分“挤”上去了一格，甚至是“挤”没了。

### 性质 3：每一个横涂的部分一定是“顶”着某一列的顶端的。

这个说起来有点奇怪，但是它和性质 1 的理由是一样的，是为了避免多余。

根据这几个性质，我们可以直接进行模拟横涂。如果没涂的部分分成了两个互不相连的块，就可以用分治的方法解决，最后合并即可。

code：

```cpp
int n,m,e[N];
int divide(int l,int r){//根据1，从上到下模拟
	if(l>r)return 0;
	if(l==r)return 1;//只剩一列，直接竖涂
	int ret=0,now=infi,num;
	for(int i=l;i<=r;i++)now=min(now,e[i]);//根据3，找到“顶”的位置
	int lst=l;
	for(int i=l;i<=r;i++){
		e[i]-=now;
		if(!e[i]){
			ret+=divide(lst,i-1);//根据2，找到两边边界
			lst=i+1;
		}
	}
	ret+=divide(lst,r);
	return min(r-l+1,ret+now);
}
void solve(){
	scanf("%d",&n);
	bool flag=false;
	for(int i=1;i<=n;i++)scanf("%d",&e[i]),flag=flag||e[i];
	if(!flag)printf("0"),exit(0);
	printf("%d",divide(1,n));
}
signed main(){
	int t=1;
	while(t--)solve();
}
```

El Psy Kongroo

---

## 作者：破忆 (赞：2)

## 【题目大意】
一排墙需要刷，可以横着刷一排也可以竖着刷一列，但必须刷在墙上，求把墙刷完的最小代价

------------
## 【分析】
分析一下两种刷法
### 竖刷

显然最少次数就是区间大小

### 横刷

对于一个区间，横刷的最优刷法是从下往上刷，这样每次刷墙可以覆盖尽可能多的墙面，直到某处无法再刷

这时就把当前区间分成两个子区间，再以同样的方法递归即可

------------

## 【算法】
分治

------------

## 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e3+5;
int n;
int a[maxn];
int f[maxn][maxn][2];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int DFS(int l,int r,int low){
	if(l>r) return 0;
	if(l==r){
		if(low==a[l]) return 0;
		else return 1;
	}
	int id=f[l][r][1],x=f[l][r][0];
	return min(r-l+1,x-low+DFS(l,id-1,x)+DFS(id+1,r,x));//横刷竖刷取其优者，横刷分治求
}
int main(){
 	freopen("P2101.in","r",stdin);
 	freopen("P2101.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++) f[i][i][0]=a[i]=read(),f[i][i][1]=i;
	for(int i=1;i<n;i++)
	for(int j=i+1;j<=n;j++){
		if(f[i][j-1][0]<a[j]) f[i][j][1]=f[i][j-1][1],f[i][j][0]=f[i][j-1][0];
		else f[i][j][1]=j,f[i][j][0]=a[j];
	}
    //先预处理出区间最低高度以及其编号
	printf("%d\n",DFS(1,n,0));
	return 0;
}
```


---

## 作者：AlicX (赞：2)

### 前言

马上就要春测了，正好做到这道题：“命运石之门的选择”，题目寓意就十分的好啊，看到还可以写题解，于是就来攒 rp 了。

## Solution

这道题相信大多数人拿到题就会打暴力了吧，先来看一下暴力思路：暴力枚举区间，找到最小值（这里其实可以用线段树优化），并让 $a_i$ 减去这个值，周而复始，一直到所有的值为 $0$ 为止，而竖直的刷法只是操作的次数就是这个区间的宽度，因为我们可以从一段的最高点刷到最低点，这显然是最优的。

然后我们考虑正解，我们可以发现我们在暴力枚举区间，但其实有些值为 $0$ 的区间是不用再次计算的，所以我们的时间显然可以被大大缩短。这时候我们就用分治的思想，当 $a_i$ 减去区间最小值后，我们就跳过值为 $0$ 的区间，计算值不为 $0$ 的区间就可以了。这样就可以大大缩减了时间复杂度，总的时间复杂度为 $O(n^2)$，是可以通过此题的。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=5010;
int n;
int a[N];
int query(int l,int r){
//	cout<<l<<" "<<r<<endl;
	if(l==r) return 1;
	int x=1e9+7;
	for(int i=l;i<=r;i++) x=min(x,a[i]);
	int hh=l;
	int ans=x;
	for(int i=l;i<=r;i++) a[i]-=x;
	for(int i=l;i<=r;i++){
		if(a[i]&&!a[i-1]) hh=i;
		if(a[i]&&(i==r||(i<r&&!a[i+1]))) ans+=query(hh,i);
	}
	return min(ans,r-l+1);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cout<<query(1,n)<<endl;
	return 0;
} 
```

祝大家春测都取得理想成绩呀！

---

## 作者：IAWNA (赞：0)

这是一道好题，

~~虽然我做过同一道题的其他版本~~

闲话不多说，我们先来分析题目。

首先，我们看到，对于一个区间 $[l,r]$  ,有两种方法可以把它刷完。

一种方法是对于这个区间内的每个矩形都自上而下刷，这样子一共要刷 $(l-r+1)$ 次。

还有一种方法就是我们找到这个区间内最低的那个矩形（设它的高度为 $lw$ ），从下往上一行一行的刷，每一行刷满，显然刷到高度 $lw$ 就刷不了了。

但是，由于区间里的矩形不一样高（废话），所以我们这样刷是刷不完的，那些高于 $lw$ 的部分就刷不到了。但是我们再来观察这些剩下的部分（注意可能不止一个），我们发现这又相当于一个 $[l,r]$ 的区间，其中区间里的每个矩形的高度都减去了 $lw$ 。然后我们就可以用刚才的办法继续做下去，直到每个区间刷完。将这些区间刷的次数累加起来，和第一种方法取最小值就行了。

典型分治。

代码（~~好短啊~~）：

```cpp
#include<cstdio>
#include<algorithm>
int a[5005];
inline int dfs(int l,int r,int nd)
{
	if(l>r)return 0;
	int ans=(r-l+1),lw=2000000000,nans=0;
	for(int i=l;i<=r;++i)lw=std::min(lw,a[i]);
	nans=lw-nd;
	for(int i=l;i<=r;++i)
	if(a[i]==lw)
	nans+=dfs(l,i-1,lw),l=i+1;
	if(l<=r)nans+=dfs(l,r,lw);
	return std::min(nans,ans);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	scanf("%d",&a[i]);
	printf("%d",dfs(1,n,0));
	return 0;
}
```


---

## 作者：Rainsleep (赞：0)

**前置芝士：分治，线段树**

考虑一行一行向上涂色，这样一定是最高效的，对于区间 $[l,r]$ 来说，不妨设其中现高度最小的为 $minn$，不难发现当涂色到 $minn$ 时，区间被斩为了左右两段，不妨此时分治处理。

对于一段区间 $[l,r]$ 而言，如果一列一列竖着刷，次数总共是 $r-l+1$ 次，所以将该区间清零的最小次数即为 $\min \{r-l+1,f(l,pos-1) +minn+f(pos+1,r)\}$。

代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 5010;
int a[N], n;

inline int min(int x, int y)
{
	return x < y ? x : y;
}

inline int f(int l, int r)
{
	if(l > r)
		return 0;
	if(l == r)
		return min(a[l], 1);
	int pos = l, minn = INT_MAX;
	for(int i(l);i <= r; ++ i)
		if(a[i] < minn)
			pos = i, minn = a[i];
	for(int i(l);i <= r; ++ i)
		a[i] -= minn;
	return min(r - l + 1, f(l, pos - 1) + minn + f(pos + 1, r));
}

int main()
{
	scanf("%d", &n);
	for(int i(1);i <= n; ++ i)
		scanf("%d", &a[i]);
	int res = f(1, n);
	printf("%d", res);
	return 0;
}
```

不难发现每一层递归树扫描需要的总时间为 $O(n)$，问题在于递归树的深度。

我们每一次都是找区间内的**最小值**，然后以其为分界线分割为两个区间，那么不妨构造一个单调递减的数列，每一次从结尾处斩断，总共需要斩断 $n$ 次，最坏时间复杂度即为 $O(n^2)$。

#### 优化

在面对大数据时，$O(n^2)$ 的时间复杂度是颇为吃力的，考虑优化这个算法。

观察代码，我们有两步可以优化。
+ 求区间内的最小值。
+ 区间内所有值减去最小值。

这两步都可以用线段树实现，最坏的时间复杂度可以达到 $O(n\log_2n)$ 的级别，常数稍大。

优化代码：
```cpp
#include<bits/stdc++.h>
 
using namespace std;
 
const int N = 5010;
int a[N], n;
 
struct node
{
    int l, r;
    int minn, pos;
    int minus;
} tr[N << 2];
 
inline int min(int x, int y)
{
    return x < y ? x : y;
}
 
inline void pushup(int idx)
{
    tr[idx].minn = min(tr[idx << 1].minn, tr[idx << 1 | 1].minn);
    tr[idx].pos = (tr[idx].minn == tr[idx << 1].minn ? tr[idx << 1].pos : tr[idx << 1 | 1].pos);
    return ;
}
 
inline void pushdown(int idx)
{
    node &root = tr[idx];
    node &left = tr[idx << 1], &right = tr[idx << 1 | 1];
    if(root.minus)
    {
        left.minus += root.minus;
        right.minus += root.minus;
        left.minn -= root.minus;
        right.minn -= root.minus;
        root.minus = 0;
    }
    return ;
}
 
inline void build(int idx, int l, int r)
{
    tr[idx] = {l, r, 0, 0, 0};
    if(l == r)
        tr[idx].minn = a[l], tr[idx].pos = l;
    else
    {
        int mid = l + r >> 1;
        build(idx << 1, l, mid);
        build(idx << 1 | 1, mid + 1, r);
        pushup(idx);
    }
    return ;
}
 
inline void update(int idx, int l, int r, int k)
{
    if(l <= tr[idx].l and r >= tr[idx].r)
    {
        tr[idx].minus += k;
        tr[idx].minn -= k;
        return ;
    }
    pushdown(idx);
    int mid = tr[idx].l + tr[idx].r >> 1;
    if(l <= mid)
        update(idx << 1, l, r, k);
    if(r > mid)
        update(idx << 1 | 1, l, r, k);
    pushup(idx);
    return ;
}
 
inline node query(int idx, int Ql, int Qr) // 返回区间最小值及其下标
{
    if(Ql <= tr[idx].l and Qr >= tr[idx].r)
        return tr[idx];
    pushdown(idx);
    int mid = tr[idx].l + tr[idx].r >> 1;
    node Lres = {INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX};
    node Rres = {INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX};
    if(Ql <= mid)
        Lres = query(idx << 1, Ql, Qr);
    if(Qr > mid)
        Rres = query(idx << 1 | 1, Ql, Qr);
    pushup(idx);
    return Lres.minn < Rres.minn ? Lres : Rres;
}
 
inline int f(int l, int r)
{
    if(l > r)
        return 0;
    if(l == r)
        return min(query(1, l, r).minn, 1);
    node t = query(1, l, r);
    int pos = t.pos, minn = t.minn;
    update(1, l, r, minn);
    return min(r - l + 1, f(l, pos - 1) + minn + f(pos + 1, r));
}
 
int main()
{
    scanf("%d", &n);
    for(int i(1);i <= n; ++ i)
        scanf("%d", &a[i]);
    build(1, 1, n);
    int res = f(1, n);
    printf("%d", res);
    return 0;
}
```
虽然但是，优化完只比原来快了 2ms...

---

## 作者：free_fall (赞：0)

# 题目大意
有 $n$ 个连续的宽度为 $1$ 高度为 $a_i$ 的矩形，要求给它全部涂上颜色，有两种涂法，一种横着涂，一种竖着涂，只能涂一个连续的区域，每涂一次代价为 $1$。
# 思路
第一眼看到题目发现 $n$ 的范围很小，打算暴力枚举涂底下的行数，剩下的全部竖着涂，最后算出最小的代价，时间复杂度为 $O(n^2)$，看起来貌似可以过。但是这种算法是一种假贪心，只能拿到 $10$ 分（悲）。

很容易就能举出反例，当其中有几个区间所涂的横行高度不同时，这种假贪心就废了。可以被以下这个简简单单的样例卡掉：
```
10
3 7 5 4 8 2 10 4 7 7
```
那么正确的写法是怎么样的？

我们可以借上面这种错误写法继续发挥，很快想到了另一种 ~~Bigger , Better , Stronger~~ 的正确写法。

其实一个区间可以分为两部分，下面所有矩形都包括的横行以及上面的若干个更小的区间。马上就能发现涂完这个区间的代价为这个区间种的矩形数量和涂掉下面横行的代价加上上面若干个小区间的代价中的最小值。

其实这就是一种分治的写法，使用深搜来计算每一个从 $l$ 到 $r$ 区间的最小代价，当 $l$ 与 $r$ 相等时，返回代价为 $1$，代码很短，主要考察了分治的思想。
# 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5;
int n,a[N];
int dfs(int l,int r){
	if(l==r)return 1;
	int mi=1e9+7,sum=0;
	for(int i=l;i<=r;i++){
		mi=min(mi,a[i]);
	}
	for(int i=l;i<=r;i++){
		a[i]-=mi;
	}
	for(int i=l;i<=r;i++){
		if(a[i]!=0){
			int now=i;
			while(a[now]!=0)now++;
			now--;
			sum+=dfs(i,now);
			i=now;
		}
	}
	return min(r-l+1,sum+mi);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	printf("%d",dfs(1,n));
	return 0;
}
```

---


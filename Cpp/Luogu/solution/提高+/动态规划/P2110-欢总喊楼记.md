# 欢总喊楼记

## 题目描述

诗经有云：

关关雎鸠，在河之洲。窈窕淑女，君子好逑。

又是一个被风吹过的夏天……一日欢总在图书馆中自习，抬起头来，只见一翩跹女子从面前飘过，真是回眸一笑百媚生，六宫粉黛无颜色！一阵诗情涌上欢总心头，他顺手写下那诗句：

啊，你是爱，是暖，是希望，你是人间四月天！

任时光匆匆而过，欢总一直没能忘记那女子。人言单思苦，欢总偏单思。夜夜难入梦，此心淑可知。偶然一次机会，欢总得知了那女孩的信息。一日，欢总终于鼓起了勇气，他向她表白！

那晚的夜色格外美丽，欢总在楼下慷慨激昂，气氛浪漫而感人。女孩有点心动了，但是直接答应是不是有点太不矜持了呢？于是，她想难难欢总，看看他到底有多少诚意。

女孩给出了两个整数 L 和 R，她要欢总数出到底有多少个这样的 X：L <= X <= R，且 X 的最高位与最低位相等（十进制下）。比如，2、101、329873可以是这样的 X，而23、4567就不是。

孩子们，欢总下辈子的幸福生活就靠你们帮忙了！


## 说明/提示

【数据规模】

50% 1<=L<=R<=10^6

100% 1<=L<=R<=10^18


## 样例 #1

### 输入

```
2 47```

### 输出

```
12```

# 题解

## 作者：lonlyn (赞：47)

乍一看还以为是什么高深的数位dp（应该可以这么做，然而蒟蒻我不会啊orz）。。。。。。

其实，我们可以用简单的找规律方法来解决这个问题啊=￣ω￣=

求L到R的数目不太好想，那我们转化一下，设sum（x）代表从1到x合法的数有多少个。

那么结果就是sum（R）-sum（L-1）。

那么怎么求sum（x）呢？

sum（x）=x        （x<=9）  （你要是这个再不懂就没办法了。。）

我们可以发现，从10开始，每10个数分一组（10-19,20-29.......230-239......），每一组中有且只有一个合法的数。

这个很好理解，当最高位确定的时候，最低位有0...10十种情况，但只有1种符合。

所以我们就可以再加上一位数的9种情况得到sum（x）=9+x/10  （x>=10）

但仔细一想，这就完了吗？有没有让结果变大了？

当x=2333时是可以的，但当x=3332时，x所处的组（3330-3339）中3333是合法的，但是取不到。

所以当个位<最高位的时候，要记得减去取不到的一种。


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long 
using namespace std;
ll l,r;
ll ans;
ll getsum(ll x){
    if (x<=9) return x;
    ll a=x%10;
    ll ans=x/10+9;
    ll b=x; while (b>=10) b/=10;
    if (b>a) --ans;
    return ans;
}
int main(){
    scanf("%lld%lld",&l,&r);
    printf("%lld",getsum(r)-getsum(l-1));
    return 0;
}
```

蒟蒻丑陋的代码附上orz


---

## 作者：YuYuanPQ (赞：3)

# 洛谷 P2110 题解

## 题目大意

此为简要概括：

女孩给出 $L$ 和 $R$ 两个数，求 $[L,R]$ 中 $X$ 的个数，而 $X$ 必须满足**最高位与最低位相等**这个条件（十进制下）。

## 分析

我们可以发现：

如果直接**暴力枚举**，必然**超时**（请看数据范围）。

所以，我们可以通过**仔细观察**发现：题目问的问题只限制最高位与最低位相等，那么这就是此题的突破口。

接着，我们假设已经确定了**最高位**。

那么此时的**最低位**只有 $1$ 种可能（因为最高位与最低位**相等**）。

这就说明，每 $10$ 个数中，**只有** $1$ 个符合题目条件的 $X$。

由此得出本题做法（见下）。

## 具体做法

将 $[L,R]$ 中的数字分成每 $10$ 个 $1$ 组，然后就可以得到：$[1,N]$ 中 $X$ 的个数为 $N\div10+9$。当然，还有特殊情况，比如最低位小于最高位时，应当 $-1$。

解释一下：

加的 $9$ 是因为 $[1,9]$ 这个区间中有 $9$ 个 $X$。

## 注意事项

- 记得看**数据范围**，开 `long long`。
- 不要像我一样，刚开始的时候把 $L$ 和 $R$ **打反了**......

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll l,r,ans;
ll solve(ll n)
{
    if(n<10) return n;
    ll sum=n/10+9;
    ll p=n;
    while(p>9)
    {
        p/=10;
    }
    ll q=n%10;
    if(q<p) sum--;
    return sum;
}
int main()
{
    scanf("%lld%lld",&l,&r);
    //ans=solve(l)-solve(r-1);
    ans=solve(r)-solve(l-1);
    printf("%lld\n",ans);
    return 0;
}
```

## 另附

- [题目链接](https://www.luogu.com.cn/problem/P2110)
- 如有**更好**做法，欢迎[私信我](https://www.luogu.com.cn/chat?uid=1029900)。
- [我的提交记录](https://www.luogu.com.cn/record/list?pid=P2110&user=1029900&page=1)
- 这是我第 $4$ 次写题解，如有错误请各位大佬**指出**。

---

## 作者：AcerMo (赞：3)

### 搜索大法好
#### 记忆化搜索
定义dfs(int p,int jd,int z,int tp,int la)

表示当前枚举到第p位，当前位有没有限制，有没有前导零，最高位是什么，上一位是什么，然后直接套一发裸的记搜就好了
### 代码
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define lli long long int
using namespace std;
lli f[20][20],lim[20];
inline lli dfs(int p,bool jd,bool z,int t,int la)
{
	if (p==0) return la==t;
	if (!jd&&f[p][t]!=-1) return f[p][t];
	int emm=jd?lim[p]:9;lli ans=0;
	for (int i=0;i<=emm;i++)
	{
		if (z&&i!=0) ans+=dfs(p-1,jd&(i==emm),0,i,i);
		else ans+=dfs(p-1,jd&(i==emm),z&(i==0),t,i);
	} 
	if (!jd&&!z) f[p][t]=ans;
	return ans;
}
inline lli slove(lli x)
{
	int len=0;
	while (x) lim[++len]=x%10,x/=10;
	memset(f,-1,sizeof(f));
	lli ans=dfs(len,1,1,0,0);
	return ans;
}
signed main()
{
	lli l,r;cin>>l>>r;
	cout<<slove(r)-slove(l-1);
	return 0;
}
```

---

## 作者：love_saber (赞：3)

大佬们都是在写数位DP,但是这道题可以用二分做。

考虑一个问题，当一个数（比如，3xxx3),形如这样的数最小是30003，最大是39993，如果输入的L,R,满足L<=30003,R>=39993,那么3xxx3这1000个数都是满足条件的。

如果30003<L呢？那么我们把中间的  xxx  增加一些（比如30003变成30013），如果此时30013>=L,那么001~999这些就都是满足条件的，并且，我们发现，所以只要找到第一个abc,使得3abc3>=L，且abc是有单调性的，因此，可以二分。

R的话同理。

代码
```
#include<bits/stdc++.h>
using namespace std;

long long L,R;

long long get_val(long long len,long long po){//len中间填的数是几位数，为了方便，是1，10，100这样子，po是首尾的数
	long long l=(po*len+0)*10+po;//30003这样的数
	long long r=(po*len+len-1)*10+po;//39993这样的数
	long long lenl=0;//表示000
	long long lenr=len-1;//表示999
	if(r<L)return 0;//完全不相交
	if(l>R)return 0;
	if(L<=l&&r<=R)return len;//完全包含
	if(r>R){//二分找右端点
		long long tmpl=0,tmpr=len-1;
		long long ans;
		while(tmpl<=tmpr){
			long long mid=(tmpl+tmpr)/2;
			if((po*len+mid)*10+po<=R)ans=mid,tmpl=mid+1;
			else tmpr=mid-1; 
		}
		lenr=ans;
	}
	if(l<L){//二分找左端点
		long long tmpl=0,tmpr=len-1;
		long long ans;
		while(tmpl<=tmpr){
			long long mid=(tmpl+tmpr)/2;
			if((po*len+mid)*10+po>=L)ans=mid,tmpr=mid-1;
			else tmpl=mid+1; 
		}
		lenl=ans;
	}
	return lenr-lenl+1;
}

int main(){
	scanf("%lld%lld",&L,&R);
	long long ans=0;
	if(L<=9)ans+=10-L;//1~9特判
	for(long long len=1;len<=1e16;len*=10){
		for(long long po=1;po<=9;po++){
			ans+=get_val(len,po);
		}
	}
	printf("%lld\n",ans);
	
	return 0;
}
```


---

## 作者：caijiahuangya (赞：2)

楼下大佬怎么都在用 dp 我~~根本看不懂~~觉得没必要

仔细分析一下，其实这题很简单

这里借用了楼下大佬 lonlyn 的思路
------------

我来深度解析一下，其实可以运用前缀和求区间和的思路，假定存在一个~~练习两年半的~~函数 $\operatorname{chicken}(x)$ 进行计算在 $x$ 前面有几个符合题意的数，再进行处理，即：$\operatorname{chicken}(r)-\operatorname{chicken}(l-1)$ 即可得到结果

```cpp
chicken(r)-chicken(l-1);
```


接下来，实现函数

首先进行一位数的特判，当 $x<10$ 的时候，直接返回 $x$ （因为只有 $x$ 个数）

```cpp
if(x<10) return x;
```


接着不难发现，超过 $10$ 之后，每 $10$ 个数只有 $1$ 个数符合题意，因此结果为 $x/10+9$，但是考虑到如 $302$ 这种数，在 $300-309$ 这个范围内应该可以取到 $303$ ，但是 $1-302$ 取不到，所以应该进行特判

```cpp
    int a=x%10;//处理最低位
    ll b=x;
    while(b>=10) b/=10;//处理最高位
    if(b>a) ans--;//进行特判
```

整个函数就是这样

```cpp
ll chicken(ll x){//计算用的函数
    if(x<10) return x;//1~9特判
    ll ans=x/10+9;//个数处理
    int a=x%10;//处理最低位
    ll b=x;
    while(b>=10) b/=10;//处理最高位
    if(b>a) ans--;//进行特判
    return ans;
}
```

最后上 AC 代码

```cpp
#include <bits/stdc++.h>//万能头
#define ll long long
using namespace std;
ll chicken(ll x){//计算用的函数
    if(x<10) return x;//1~9特判
    ll ans=x/10+9;//个数处理
    int a=x%10;//处理最低位
    ll b=x;
    while(b>=10) b/=10;//处理最高位
    if(b>a) ans--;//进行特判
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    ll l,r;
    cin>>l>>r;
    cout<<chicken(r)-chicken(l-1);
    return 0;//完美结束
}
```


---

## 作者：UNNN (赞：2)

 首先我们看题目可知，对于一个正整数 $n$，如果它的最高位与最低位相同，那么这个数就是合法的。现在让我们求的是一个范围内合法数的个数。
 
 如果我们将大于等于 $10$ 数字按每十位为一行列出来，可以发现，每一行合法的数有且仅有一个，所以只要我们在一行中判断出来一个合法数后就可以直接忽略掉这一排，直接进行下一排。
 
 知道了这个，由于我们是只需要求一个范围内的数量的，所以只需要让 $l$ 和 $r$ 的值是一个整十数就行了，将它们变成整十数以后，就可以求区间 $[l, r]$ 内所有合法的数了。因为每十个数中只有一个合法的数，所以在求这个区间的个数时，可以直接把它们的个位忽略掉，然后计算右边减去左边值。例如：当 $l = 30, r = 170$ 时，它们之间合法的数就是将它们的个位去除，然后计算 $17-3$ 的值，也就是 $14$。
 
 我们再考虑一下，因为我们输入的 $l$ 和 $r$ 不可能是整十数，它还有零数，那这怎么处理呢？其实也很好解决，首先，对于 $l$，如果它的个位比它的最高位小或相等，那么总个数必须加一个，因为我们是要求 $l$ 和 $r$ 之间合法的数，所以当 $l$ 的个位比最高位小时，说明该行往后存在合法的数；当然如果比最高位大，那么往后就不会有合法的数了。再来考虑 $r$，这时候我们要类比 $l$ 来思考，还是那句话，求的是 $l$ 和 $r$ 的范围，那么 $r$ 的处理思路必须和 $l$ 的处理思路反过来，所以当 $r$ 的个位大于等于最高位时，总个数需要加一个。最后，将 $l$ 变成不小于它本身的最小整十数，$r$ 变成不大于它的最大整十数即可，再按上一自然段的规律去比较。
 
 但是，如果在范围内存在只有一位的数，那么我们就需要特判。当 $l$ 小于 $10$ 时，将个位的合法数全部统计出来，然后直接让 $l$ 变成 $10$。如果在 $l$ 是一位数的同时 $r$ 也是一个一位数，那么最后的答案其实就是 $r - l + 1$。
 
 最终的 AC 代码：
 
 ```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
ll l, r;
ll ans = 0;
ll pnum(ll n){ // 统计位数
	ll x = n, sum = 0;
	while(x > 0){
		x = x / 10;
		sum++;
	}
	return sum;
}
inline ll geth(ll n){ // 获取最高位
	return n / pow(10, pnum(n) - 1);
}
inline ll getl(ll n){ // 获取最低位
	return n % 10;
}
int main()
{
	scanf("%lld%lld", &l, &r);
	if(l == r){ // 这是一个特判，l和r相等的情况
		if(getl(l) == geth(l)){
			printf("1");
			return 0;
		}
		else{
			printf("0");
			return 0;
		}
	}
	if(l < 10){
		if(r < 10){
			ans = ans + r - l + 1;
			printf("%lld", ans);
			return 0;
		}
		ans = ans + 9 - l + 1;
		l = 10;
	}
	if(getl(l) <= geth(l)) ans++;
	if(getl(r) >= geth(r)) ans++;
	l = l + 10 - (l % 10);
	r = r - (r % 10);
	ans = ans + (r / 10 - l / 10);
	printf("%lld", ans);
	return 0;
}

```

 这是一位初二蒟蒻的第一篇题解，做的不好，轻喷。

---

## 作者：hgzxwzf (赞：2)

第一篇题解祭。
## 解题思路：
我一般写数位 dp 的题习惯用记忆化搜索的写法（~~只会这个,比较模板~~）。

我们需要在 dfs 参数中带入最高位的数字，当所有数位都枚举完了，判断一下最低为是否等于最高位即可。

这题还要考虑前导零，不过不需要像其他的数位 dp 那样在 dfs 参数中带 bool 变量记录或者 dp 数组里多开一维，因为我们有最高位的数字，当最高位不是 $0$ 时就说明没有前导零。

当出现第一个非 $0$ 位，就得到了最高位的数。

## 记忆化搜索数位 dp ：
定义二维 dp 数组，其中第一维表示最高位的数字，第二维表示当前枚举到了第几位，或者说还剩多少位没有填数。

首先将数字十进制分解，得到每一位的数字，再从高位枚举起。

为什么这样？\
因为高位数字对一个数影响更大，比如 $91$ 和 $19$，虽然 $19$ 的个位远大于 $91$ 的个位，但 $91$ 的十位远大于 $19$ 的十位，所以 $91>19$。\
因此说更高位对一个数影响更大。

定义 $lim$ 为当前能填的最大数。

在 dfs 参数里需要带上 $f$，表示之前的数位上的数有没有取满，也就是说，是不是取到的每个数都等于那一位的 $lim$。

选好了这一位的数，显然有：$f(pos-1)=(f(pos)\land(i=lim))$。

考虑 $lim$：\
Case $1$：如果当前$f=true$，那么有 $lim=num(pos)$，因为如果大于了 $num(pos)$，那就会导致最后的数大于了最大数。\
举个例子：最大数为 $324$，当百位取了 $3$，且十位取了 $2$，那么显然个位不能取比 $4$ 大的数。

Case $2$：如果当前 $f=false$，那么有 $lim=9$，因为上文已经说明过，高位数字对一个数的影响更大。
同样用 $324$ 举个例子：当百位取了$3$，而十位取了$1$，那么显然，个位取 $0\sim9$ 都可以。

当得到了当前位数填所有可行数的方案数的总和 $sum$，当当前 $f=false$ 时才能更新 dp 数组，因为我们不知道后面的数填的情况，也许这次的合法方案在下一次就不合法了，而当 $f=false$ 时,由上面所说可知，后面的数不管怎么填都合法，因此可以记录。
# **Code：**
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define For(x,y,z) for(int x=y;x<=z;x++)
using namespace std;
#define int long long//偷懒
int dp[20][20],num[20];
int dfs(int pos,int high,int pre,bool f)//记录pre用于所有数位枚举完了
{
	if(pos==0) return pre==high&&high!=0;
	if(!f&&high&&(~dp[pos][high])) return dp[pos][high];//带上!f，不然全wa 
	int lim=f?num[pos]:9,sum=0;
	For(i,0,lim) 
	sum+=dfs(pos-1,high==0?i:high,i,f&&i==lim);//考虑对于最高位的更新
	return f?sum:dp[pos][high]=sum;//记忆化
}
int work(int x)
{
	int len=0,sum=0;
	while(x) num[++len]=x%10,x/=10;
	For(i,0,num[len])
	{
		sum+=dfs(len-1,i,i,i==num[len]);
	}
	return sum;
}
signed main()
{
	memset(dp,-1,sizeof(dp));
	int L,R;
	scanf("%lld%lld",&L,&R);
	printf("%lld",work(R)-work(L-1)); 
	return 0;
}
```


---

## 作者：p_b_p_b (赞：2)

#### 数位DP题解

其实这题我第一眼是想用一些玄学找规律做的。然而，一看标签：动态规划，DP……

行吧，那就写吧

dp[i][j][0/1]指：还剩i位，开头数字为j，是否有前导0，没有到limit，方案数~~（再一次感到语文不好的悲哀……）~~

然后，这就是一个简单的DP了，码量很小，30分钟随便做

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll dp[20][10][2];
int bit[20],c;
ll dfs(int cur,int fir,int l,bool limit,bool zero)
{
	if (!cur) return zero==0&&l==fir;
	if (!limit&&~dp[cur][fir][zero]) return dp[cur][fir][zero];
	int end=(limit?bit[cur]:9);
	ll ret=0;
	for (int i=0;i<=end;i++)
	{
		if (cur==c) ret+=dfs(cur-1,i,i,i==end,i==0);
		else if (zero) ret+=dfs(cur-1,i,i,0,i==0);
		else ret+=dfs(cur-1,fir,i,limit&&i==end,0); 
	}
	if (!limit) dp[cur][fir][zero]=ret;
	return ret;
}
ll query(ll x)
{
	if (!x) return 0;
	int cnt=0;memset(bit,0,sizeof(bit));
	while (x) bit[++cnt]=x%10,x/=10;
	c=cnt;
	return dfs(cnt,0,0,1,1);
}
int main()
{
	ll n,m;
	cin>>n>>m;
	if (n>m) return 0&printf("0");
	memset(dp,-1,sizeof(dp));
	cout<<query(m)-query(n-1);
}
```

---

## 作者：LSG_waterf (赞：2)

兄弟们，代码可能有点丑，考试的时候debug心态已经炸了，考完发现$a*fpow(b,c)$写成了$a*(b,c)$,有点血亏．．．

接下来说一下我的思路：


拿两个数出来看看：123　54321

我是分步计算的，代码比别人的长，但是很好理解．首先算120到200的个数：首先我们用ｑ数组把123的每一位都存起来，len为第一个输入的数的，如果最低位大于最高位，我们就不能讨论首位与末位都是１的情况了．反则可以加上去．到999，最低位与最高位只可以是１，就有$121　131　141　151　161　171　181　191$这几种，如果输入的数更大的话就按每一位循环处理：
```cpp
for(int i=len1-1;i>=2;i--) ans+=(9-q[len1-i+1])*fpow(10,i-2);
```
这句话应该还是很好理解的．
接着再算200-999的个数．很明显，还有(9-q[len])个最低位与最高位相同的数字符合题意，每个都有$10^{len-2}$，所以200-999的个数就是$(9-2)*10^{len-2}$．后面的再同理计算即可．

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int fpow(int a,int b)
{
	int ans=1,base=a;
	while(b)
	{
		if(b&1) ans=ans*base;
		base=base*base;
		b>>=1;
	}
	return ans;
}
int getbit(int a) {int sum=0;while(a){sum++;a/=10;}return sum;}
int pd(int x)
{
	int sum=0,s=x; while(x){x/=10;sum++;}
	if((s%10)==(s/(fpow(10,sum-1)))) return 1;
	else return 0;
}
int l,r,ans,q[110],p[110];
signed main()
{
	//freopen("digit.in","r",stdin);
	//freopen("digit.out","w",stdout);
	cin>>l>>r;
	int len1=getbit(l),len2=getbit(r);
	if(len1==len2&&len1>7)
	{
		int x=l%10,y=l/fpow(10,len1-1),ss=l,rr=len1;
		while(ss){q[rr]=ss%10;ss/=10;rr--;}
		if(y>=x) {for(int i=len1-1;i>=2;i--) ans+=(9-q[len1-i+1])*fpow(10,i-2);ans++;}
		else if(y<x) for(int i=len1-1;i>=2;i--) ans+=(9-q[len1-i+1])*fpow(10,i-2);
		
		int xx=r%10,yy=r/fpow(10,len2-1);ss=r,rr=len1;
		while(ss){p[rr]=ss%10;ss/=10;rr--;}
		if(xx>=yy) {for(int i=2;i<=len1-1;i++) ans+=p[len1-i+1]*fpow(10,i-2);ans++;}
		else for(int i=len2-1;i>=2;i--) ans+=p[len1-i+1]*fpow(10,i-2);
		
		int z=yy-y-1;
		ans+=fpow(10,len1-2)*z;
	}
	else if(len1!=len2)
	{
		int x=l%10,y=l/fpow(10,len1-1),ss=l,rr=len1;
		while(ss){q[rr]=ss%10;ss/=10;rr--;}
		if(y>=x) {for(int i=len1-1;i>=2;i--) ans+=(9-q[len1-i+1])*fpow(10,i-2);ans++;}
		else if(y<x) for(int i=len1-1;i>=2;i--) ans+=(9-q[len1-i+1])*fpow(10,i-2);
		
		int xx=r%10,yy=r/fpow(10,len2-1);ss=r,rr=len2;
		while(ss){p[rr]=ss%10;ss/=10;rr--;}
		if(xx>=yy) {for(int i=2;i<=len2-1;i++) ans+=p[len2-i+1]*fpow(10,i-2);ans++;}
		else for(int i=len2-1;i>=2;i--) ans+=p[len2-i+1]*fpow(10,i-2);
		
		ans+=(9-y)*fpow(10,len1-2);ans+=(yy-1)*fpow(10,len2-2);
		//cout<<len1<<" "<<len2<<endl;
		for(int i=len1+1;i<=len2-1;i++) ans+=9*fpow(10,i-2);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：青丘杨哲 (赞：1)

其实个人认为自己的做法是数位$DP$与计数问题的杂糅，或者说以数位$DP$的形式进行小学生的统计。

首先令$f_{i,j}$表示数的长度为$i$位，最高位和最低位都等于$j$的数的个数，则$i \in [1,18],j\in [1,9]$。那么一旦位数和两端的数字确定，即可得到$f_{i,j}=10^{\max(i-2,0)}$（$\max(i-2,0)$的目的是避免一位数时出现错误）。

设$L$的位数为$x$，$R$的位数为$y$。$l_1,l_2$分别表示$L$的最高位和最低位，$r_1,r_2$分别表示$R$的最高位和最低位。

很显然，答案由三部分组成：位数为$x$的数，位数为$y$的数，位数在$[x+1,y-1]$的数。

最后一部分的数量比较好求，即$\sum\limits_{i=x+1}^{y-1}\sum\limits_{j=1}^{9}f_{i,j}$。

接下来考虑位数为$x$的情况。

如果$l_1 \leqslant l_2$，那么两端为$\min(l_1,l_2)+1$或更大的数一定大于$L$，因此答案的一部分是$\sum\limits_{i=\min(l_1,l_2)+1}^{9}f_{x,i}$。另外一部分就是两端的数字与$\min(l_1,l_2)$相等，此时将两端的数字去掉后中间剩下的那个数字必须要严格比$L$中间那个数字大（如果$l_1=l_2$则也可以相等），所以答案为$10^{x-2}$与中间那个数字之差再减去$1$。当$l_1=l_2$时，答案需要再自增。

如果$l_1>l_2$，那么两端为$\max(l_1,l_2)+1$或更大的数一定大于$L$，因此答案的一部分是$\sum\limits_{i=\max(l_1,l_2)+1}^{9}f_{x,i}$。另外一部分就是两端的数字与$\max(l_1,l_2)$相等，这时因为$l_1$已经严格大于$l_2$，去掉两端后中间剩下的那个数字只要大于等于$L$去掉两端后剩下的那个数即可。答案为$10^{x-2}$与中间那个数字之差。

例如$42356$，当两端的数字都是$4$的时候，显然$42354$是小于它的，从$42364$开始才符合要求，那么我们要统计的就是符合条件的诸如$236,237,...,999$这样的数字，数量为$1000-235-1=764$。

同理，位数为$y$时，也可以用相似的方法计算。

如果$r_1≥r_2$，则两端为$\max(r_1,r_2)-1$或更小的数字一定符合要求。若两端为$\max(r_1,r_2)$且去除两端后中间那个数字一定要严格小于$R$去掉两端后的那个数，答案就是$R$去掉两端后的数。如果$r_1=r_2$，则答案自增。

如果$r_1<r_2$，则两端为$\min(r_1,r_2)-1$或更小的数字一定符合要求。若两端为$\min(r_1,r_2)$，则去掉两端后中间的数字只需小于等于$R$去掉两端后的数即可，答案为$R$去掉两端后的数加$1$。

注意，如果是一位数，那么去掉两端后的数应被当作$0$来计算，而不是$10^{-1}$。

**需要注意的是，如果$x=y$，则不能用上面的方法求答案。** 但是上面的结果仍然可以利用，将位数为$x$时求得的答案记为$ans_1$，位数为$y$时求得的答案记为$ans_2$。说明$x$位数中大于等于$L$的合法答案有$ans_1$各，小于等于$R$的合法答案有$ans_2$个。可以利用容斥原理，先求出所有$x$位的答案数量$t=\sum\limits_{i=1}^{9}f_{x,i}$，则既大于等于$L$又小于等于$R$的答案数量就是$ans_1+ans_2-t$。

至于如何求出位数、求出去除两端后剩下的数字，实现方法很多，不再提及。

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef double DB;
const int MAXL=20;
const int MAXN=10;
LL L,R,pw[MAXL]; int x,y,l1,l2,r1,r2;
LL f[MAXL][MAXN],ans,ans1,ans2;
int main(){
	scanf("%lld%lld",&L,&R),pw[0]=1;
	x=floor(log10((DB)L))+1,y=floor(log10((DB)R))+1;
	for (int i=1;i<=18;i++) pw[i]=pw[i-1]*10LL;
	l1=floor((DB)L/(DB)pw[x-1]),r1=floor((DB)R/(DB)pw[y-1]);
	l2=L%10LL,r2=R%10LL;
	for (int i=1;i<=18;i++)
		for (int j=1;j<=9;j++)
			f[i][j]=pw[max(i-2,0)];
	if (l1<=l2){
		for (int i=min(l1,l2)+1;i<=9;i++) ans1+=f[x][i];
		ans1+=(pw[max(0,x-2)]-(L/10)%pw[max(0,x-2)]-1);
		if (l1==l2) ans1++;
	}
	else{
		for (int i=max(l1,l2)+1;i<=9;i++) ans1+=f[x][i];
		ans1+=(pw[max(0,x-2)]-(L/10)%pw[max(0,x-2)]);
	}
	if (r1>=r2){
		for (int i=1;i<=max(r1,r2)-1;i++) ans2+=f[y][i];
		ans2+=((R/10)%pw[max(y-2,0)]);
		if (r1==r2) ans2++;
	}
	else{
		for (int i=1;i<=min(r1,r2)-1;i++) ans2+=f[y][i];
		ans2+=((R/10)%pw[max(y-2,0)]+1);
	}
	for (int i=x+1;i<=y-1;i++)
		for (int j=1;j<=9;j++) ans+=f[i][j];
	ans+=(ans1+ans2);
	if (x==y){
		LL tmp=0;
		for (int i=1;i<=9;i++) tmp+=f[x][i];
		ans=ans1+ans2-tmp;
	}
	printf("%lld",ans);
	return 0;
}

```

愿你历遍山河，依然觉得人间值得。

---

## 作者：MloVtry (赞：0)

数位dp的写法

将问题转换成求1~x合法数的个数，设f（x）=(1~x合法数的个数)，然后ans=f(r)-f（l-1）;

首先枚举这个合法数的位数，如果位数比x的位数小，那么不受限制，则首位以及末尾位可以选择1~9当中的任意数，然后中间的位数可以随意选，即为10^(max(0,i-2))

最后是位数为x位数时的情况

设x[i]为x的第i位数（正序，从高位到低位）

首先首位数小于x[1]的情况和之前无异，只是首位只能选择1~（x[1]-1）

如果首位=x[1],末尾也必定=x[末位]，而假设末位比首位小，则倒数第二位（十位）可选范围-1，使末位可以选择任意数

而中间的可选方案则是中间这个数

（比如16662331，去掉两个1，中间可选方案是666233）

代码：

```cpp
#define ll long long
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int a[20],b[20],n,m;
ll A,B;
void turn(ll it,int c[])
{
    int w=0;
    int tmp[20]={0};
    while(it)
    {
        tmp[++w]=it%10;it/=10;
    }
    int j=w;
    c[0]=w;
    for(int i=1;i<=w;++i) c[i]=tmp[j--];
}
ll po[20];
ll doit(int c[])
{
    ll re=0;
    for(int i=1;i<=c[0];++i)
    {
        if(i==c[0])
        {
            re+=(c[1]-1)*po[i-1];
            if(c[c[0]]<c[1]) c[c[0]-1]--;//理论上需要高精减法，不过洛谷数据，大家都懂
            ll up=0;
            for(int i=2;i<c[0];++i)
            {
                up=up*10+c[i];
            }
            re+=up;
        }
        else re+=po[i-1]*9;
    }
//    cout<<re<<endl;
    return re;
}
int main()
{
    scanf("%lld%lld",&A,&B);
    turn(max(A-1,0*1ll),a);turn(B,b);
    po[0]=1,po[1]=1;
    for(int i=2;i<=20;++i) po[i]=po[i-1]*10;
    cout<<doit(b)-doit(a)<<endl;
    return 0;
}
//今天也没有捞到厌战岛风47呢
//活动已咸鱼
```

---


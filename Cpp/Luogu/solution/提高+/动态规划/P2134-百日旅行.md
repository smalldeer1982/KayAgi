# 百日旅行

## 题目背景

> 重要的不是去哪里，而是和你在一起。——小红

对小明和小红来说，$2014$ 年 $7$ 月 $29$ 日是一个美好的日子。这一天是他们相识 $100$ 天的纪念日。

（小明：小红，感谢你 $2$ 场大考时默默的支持，$100$ 个日夜的陪伴；感谢你照亮我 $100$ 个美好的日子，给我留下无数美好的回忆……在这个美好的日子里，我准备带你去旅行。）

## 题目描述

小明和小红还剩下 $n$ 天的假期，小明可以安排旅行的计划。如果连续 $x$ 天旅游，小明需要花旅行费用  $p \times x \times x$ 元；如果连续 $x$ 天不旅游，小明需要请小红吃饭，花费为 $q \times x$ 元（ $p,q$ 都是输入的常数）。

请你帮小明写一个程序，计算出假期里他至少需要花费多少元。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 数据，$1 \le n \le 20$。
- 对于 $90\%$ 数据，$1 \le n \le 10^3$，$1 \le p \le 2 \times 10^3$，$1 \le q \le 10^4$。
- 对于 $100\%$ 数据，$1 \le n \le 2 \times 10^5$，$1 \le p \le q \le 10^4$。

## 样例 #1

### 输入

```
6 1 7```

### 输出

```
20```

# 题解

## 作者：shixinyi (赞：51)

看到楼上都是dp，我来发一个贪心的题解。


由于请小红吃饭的代价是  $ Q \times x $ 。


所以如果请小红吃饭的总时间一定那么请小红吃饭的代价就是一定的。


我们考虑当请小红吃饭的天数是 $ i $ ，那么需要旅游的总时间就是 $ n-i $ ，旅游最多可以被吃饭分成 $ i+1 $ 次。


我们很容易可以证明每次旅游时间最平均的时候是最优的。


于是我们枚举请小红吃饭的总时间，然后计算旅游的最少代价。


这样时间复杂度为O(n)、空间复杂度为O(1)。


表示大常数选手贪心跑得比dp还要慢一些。


code:

```cpp
//Serene
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll long long
const int maxn=2e5+10;
const ll INF=1e17;
ll n,p,q,ans=INF;

ll trav(ll day,ll times) {
    ll x=day/times,y=day%times;
    return p*(times-y)*x*x+p*y*(x+1)*(x+1);//贪心，将除不尽多出的部分也平均分配
}

int main() {
    scanf("%lld%lld%lld",&n,&p,&q);
    for(int i=0;i<=n;++i) ans=min(ans,i*q+trav(n-i,i+1));//枚举请小红吃饭的总时间，计算最小的旅游代价
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：中国飞鱼 (赞：9)

先考虑$O(n^2)$算法,

设$f_i$表示最后一天$i$旅游的最小花费,

设$g_i$表示最后一天$i$不旅游的最小花费.

则显然有$f_i=min(f_i,g_j+p*(i-j)^2);$

$g_i=min(g_i,f_j+q*(i-j));$

总时间复杂度:$O(n^2)$

这样就获得了$90$分

放一个$90$分代码
```
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=1005;
int re(){
    int x=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*w;
}
int n,p,q,f[N],g[N];
int main(){
    memset(f,63,sizeof(f));
    memset(g,63,sizeof(g));
    n=re(),p=re(),q=re();
    f[0]=g[0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<i;j++){
            f[i]=min(f[i],g[j]+p*(i-j)*(i-j));
            g[i]=min(g[i],f[j]+q*(i-j));
        }
    printf("%d\n",min(f[n],g[n]));
    return 0;
}
```
满分算法:**斜率优化**

先看$g_i$的转移,拆开括号有$g_i=f_j+q*i-q*j$

如果记一个变量$Min$维护$0$~$i-1$中$f_j-q*j$的最小值,就可以$O(1)$计算$g_i$的值

再看$f_i$,可以发现这是一个非常斜率优化的式子,拆开括号有:

$$f_i=g_j+pi^2-2pij+pj^2$$
$$g_j+pj^2=i*2pj+f_i-pi^2$$
其中$y=g_j+pj^2,k=i,x=2pj,b=f_i-pi^2$且$k,x$均单调递增

为使$b$最小化,需要维护一个下凸壳,用单调队列做到$O(n)$

总时间复杂度:$O(n)$

放一个$100$分代码
```
#define ll long long
#define y(i) (g[i]+p*i*i)
#define x(i) (2*p*i)
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=200005;
int re(){
    int x=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*w;
}
int n,r,l,Q[N];
ll p,q,Min,f[N],g[N];
int main(){
    n=re(),p=re(),q=re();
    for(int i=1;i<=n;i++){
        g[i]=Min+q*i;
        while(r>l&&i*(x(Q[l+1])-x(Q[l]))>=y(Q[l+1])-y(Q[l]))l++;
        f[i]=g[Q[l]]+p*(i-Q[l])*(i-Q[l]);
        Min=min(Min,f[i]-q*i);
        while(r>l&&(y(i)-y(Q[r]))*(x(Q[r])-x(Q[r-1]))<=
              (x(i)-x(Q[r]))*(y(Q[r])-y(Q[r-1])))r--;
        Q[++r]=i;
    }
    printf("%lld\n",min(f[n],g[n]));
    return 0;
}
```

---

## 作者：SFWR (赞：7)

提供另外一个方法，是对$O(N^2)$的优化，凭借这个优化就可以通过那个数据极大的点了

我们来想一下，加入对于一个K长度区间，如果我们选择$K^2$,那就应该有$P*K*K<Q*K$,即$K<Q/P$，我们将满足这样一个个的的K（1,2，……Q/P）当做体积，而$P*K*K$作为质量，那么本题就是一个完全背包问题了

新方法的复杂度$O(N*Q/P)$，比原来要快很多了，而且在Q于P相近时效率较高，也算是对于和我一样不会斜率优化的一个方法
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,p,q;
long long int f[201000][2],a[121321];
int main()
{
	cin>>n>>p>>q;
	if(q<=p){cout<<q*n<<endl;return 0;}
	int t=q/p;
	for(int i=1;i<=t;i++)a[i]=p*i*i;
	for(int i=1;i<=n;i++)f[i][0]=f[i][1]=0x3f3f3f3f;
	f[0][0]=f[0][1]=0;
	for(int i=1;i<=n;i++)
	{
		f[i][1]=min(f[i][1],f[i-1][0]+q);
		for(int j=1;j<=t;j++)if(i>=j)f[i][0]=min(f[i][0],f[i-j][1]+a[j]);
	}
	cout<<min(f[n][1],f[n][0]);
}
```


---

## 作者：Minclxc (赞：6)

看到下面斜率优化、单调队列优化吓坏了

O(n^2)加上特判最后一个点（请吃饭最省钱）就好了

这里介绍一下O(logn)的方法

楼下贪心的方法是对的，而贪心出来的公式是一个单峰函数

因为函数带取整符号，我求不出极值点，如果有数学大佬可以试试O(1)算法

对于单峰函数，可以用三分的方法，注意一下单调的情况就好了

不懂三分的可以去查【模板】三分

三分效率是O(logn)的

打的三分有些难看

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define LL long long
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())    a=a*10+c-'0';
    return f?-a:a;
}
int n,p,q;
LL F(int x){
    int k=(n-x)/(x+1),r=(n-x)%(x+1);
    return 1ll*q*x+1ll*p*(k+1)*(k+1)*r+1ll*p*k*k*(x+1-r);
}
LL min(LL a,LL b){return a<b?a:b;}
int main(){
    n=read(),p=read(),q=read();
    int l=0,r=n;LL fl=F(l),fr=F(r);
    while(l+2<r){
        int m1=l+(r-l)/3,m2=r-(r-l)/3;
        LL f1=F(m1),f2=F(m2);
        if(fl>=f1&&f1>=f2&&f2>=fr)l=m2,fl=f2;
        else if(fl>=f1&&f1>=f2&&f2<=fr)l=m1,fl=f1;
        else if(fl>=f1&&f1<=f2&&f2<=fr)r=m2,fr=f2;
        else r=m1,fr=f1;
    }
    printf("%lld",min(min(fl,fr),F(l+r>>1)));
    return 0;
}
```

---

## 作者：Weakest_Konjac (赞：3)

# 一道~~好水~~的蓝题
刚看到题目的我：
## dp
仔细思考一下，
## 贪心
蹦入脑中~~(贪心是个好东西，代码短小)~~

设吃饭天数为 _**i**_ 天，则旅游天数为 _**n-i**_ 天

易知：
## 把旅游天数平均分配到每一块，花钱最少
### （注意旅游花钱是平方哦）
所以我们可以得出

```cpp
int d=n-i,t=i+1;//d为旅游天数，t为最多块数
ans=min(ans,i*q+p*(t-d%t)*(d/t)*(d/t)+p*(d%t)*(d/t+1)*(d/t+1));
```
所以代码如下：
```cpp
#include<cstdio>
#include<algroithm>
int n,p,q,ans,i;
using namespace std;
int main(){
	ans=0x3f3f3f3f;
	scanf("%d%d%d",&n,&p,&q);
	for (i=0;i<=n;i++){
		int d=n-i,t=i+1;
		ans=min(ans,i*q+p*(t-d%t)*(d/t)*(d/t)+p*(d%t)*(d/t+1)*(d/t+1));
	}
	printf("%d",ans);
	return 0;
}
```
最后祝大家
# 2019 RP++

---

## 作者：Special_zyy (赞：1)

## 直接进入正题
首先，用$f[i][0]$表示第i天旅游的最小花费，$f[i][1]$表示第i天吃饭的最小花费。那么接下来最简单的操作就是枚举第i天和第j天（第j天就是刚好还没有开始旅游或者吃饭的那天，即从第j+1天开始，到第i天都是吃饭或旅游）。
### 这部分代码略过（~~不知道是不是因为之前加了这段代码所以题解一直没通过~~）
然而如果直接枚举并不能A掉这道题，这时，我们可以从P、Q入手，如果旅游的花费超过了吃饭的花费，很明显，这个时候我们就不用继续枚举之前的天数了，因为再往前找的话，旅游的费用必然还会大于吃饭的费用，因为旅游费用的计算方式里面有平方嘛。同时也说明，接下来的那一天一定是吃饭更省钱，这样的一个特判就可以过掉这道题了。也不知道是不是数据的问题qwq，（雾）。

### 下面就是代码咯：

~~~cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 5000005
#define INF 0x7ffffff
long long m,n,k,P,Q; 
long long f[MAXN][2];
int main()
{
	memset(f,63,sizeof f);
	cin>>n>>P>>Q;
	f[0][1]=f[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		f[i][1]=f[i-1][0]+Q;
		for(int j=i-1;(i-j)*(i-j)*P<=(i-j)*Q and j>=0;j--)
	  	  f[i][0]=min(f[i][0],f[j][1]+P*(i-j)*(i-j));
	}
	cout<<min(f[n][0],f[n][1])<<endl;
	return 0;
}

~~~

---

## 作者：xzyxzy (赞：1)

表示楼下贪心很好，花样dp也不错，但好像都没我的短

正常90分都很容易想到，dp[0][i]表示到第i天且第i天还在旅行的最小代价
那么就是这样的90分
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define ll long long
#define inf 100000000000000
using namespace std;
ll dp[2][200001],N,P,Q;
int main()
{
    cin>>N>>P>>Q;
    for(ll i=1;i<=N;i++)dp[0][i]=dp[1][i]=inf;
    for(ll i=1;i<=N;i++)
        for(ll j=0;j<i;j++)
        {
            dp[0][i]=min(dp[0][i],dp[1][j]+P*(i-j)*(i-j));
            dp[1][i]=min(dp[1][i],dp[0][j]+Q*(i-j));
        }
    printf("%lld\n",min(dp[0][N],dp[1][N]));
    return 0;
}
```
然后dp[1]的转移由于没有平方，那么很容易优化

至于dp[0]的优化，那就是若旅行花费还大于吃饭，那就吃饭去吧
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define ll long long
#define inf 100000000000000
using namespace std;
ll dp[2][200001],N,P,Q，Min0;
int main()
{
	cin>>N>>P>>Q;
	for(ll i=1;i<=N;i++)dp[0][i]=dp[1][i]=inf;
	for(ll i=1;i<=N;i++)
	{
		dp[1][i]=Min0+Q*i;
		for(ll j=i;(i-j)*(i-j)<=Q&&j>=0;j--)
			dp[0][i]=min(dp[0][i],dp[1][j]+P*(i-j)*(i-j));
		Min0=min(Min0,dp[0][i]-Q*i);
	}
	printf("%lld\n",min(dp[0][N],dp[1][N]));
	return 0;
}

```

---

## 作者：Great_Influence (赞：0)

dp加双向队列优化。

虽然楼上有斜率优化的，但是我打得并不是斜率优化，所以稍微有些不同。

可以考虑一个显然的dp:


$$f(x)=\min(f(x-1)+q,g(k)+p(x-k)^2)(k< x)$$


(g(x)表示上一次强制吃饭的最小花费,f(x)为最优答案)

这个dp是$O(n^2)$的，所以考虑优化。

可以发现，主要时间耗在了后面转移的选择。而可以将后面转移写成新函数$d_k(x)=p(x-k)^2+f(k)$，表示从k开始旅游到x的最小花费。显然决策点具有单调性，于是可以考虑用单调队列维护$d(x)$，时间复杂度优化成$O(n)$。

代码：

```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("P2134.in","r",stdin);
        freopen("P2134.out","w",stdout);
        #endif
    }
    const int MAXN=201001;
    static long long n,q,p,f[MAXN];
    static struct line
    {
        long long t,h;
        inline long long calc(long long x){return (x-t)*(x-t)*p+h;}
    }K;
    static deque<line>G;
    static deque<line>::iterator it;
    #define Chkmin(a,b) a=a<b?a:b
    int main(void){
        file();
        read(n);read(p);read(q);
        G.push_back((line){0,0});
        Rep(i,1,n)
        {
            f[i]=f[i-1]+q;
            it=G.begin();++it;
            while(it!=G.end()&&it->calc(i)<=G.front().calc(i))G.pop_front(),++it;
            Chkmin(f[i],G.front().calc(i));
            K=(line){i,f[i-1]+q};
            while(!G.empty()&&G.back().calc(i+1)>=K.calc(i+1))G.pop_back();
            G.push_back(K);
        }
        printf("%lld\n",f[n]);
        return 0;
    }

```

---

## 作者：cyz_bhcs (赞：0)

诡异的题目，话说n^2算法轻松过最后一个点，出题人也是n^2算法，不过标解应该还是要严谨的

dp方程就不解释了，这里说一下，G[I]表示第i天旅游的时候选择第G[I]天作为开始旅游的时间

```cpp
#include <stdio.h>
#include <iostream>
#include <math.h>
#include <algorithm>
#include <stdlib.h>
#include <vector>
#include <queue>
#include <string.h>
#define INF 2147483645
#define MOD 1000000007
#define LL long long
using namespace std;
LL f[2000005][2],g[2000005];
int n,p,q;
void init(){
    cin>>n>>p>>q;
}
void work(){
    if(q<=p){cout<<q*n<<endl;return ;}
    for(int i=1;i<=n;i++){
        f[i][0]=min(f[i-1][0],f[i-1][1])+q;
        f[i][1]=min(f[i-1][0]+p,f[g[i]][0]+(i-g[i])*(i-g[i])*p);
        g[i+1]=g[i];
        for(int j=g[i+1]+1;j<=i;j++){
            if(f[j][0]+(i-j+1)*(i-j+1)*p<f[g[i+1]][0]+(i-g[i+1]+1)*(i-g[i+1]+1)*p){g[i+1]=j;}
        }
    }
    cout<<min(f[n][0],f[n][1])<<endl;
}
int main(){
    //freopen("2134.in","r",stdin);
    //freopen("2134.out","w",stdout);
    init();
    work();
    return 0;
}
```
运用逼近法，虽然看上去和n^2形式上区别不大，但是实际上可以优化到nlogn左右（测试中自做100万0.7s）
归根到底还是数据太水的锅


---

## 作者：呼啸山庄 (赞：0)

## 思路

考虑在连续的X天内，旅行和吃饭的费用那个会更大，可得方程$px^2 = qx$，解得$\left \{\begin{aligned} &{x_1 = 0} \\ &{x_2 = \frac{q}{p}} \end{aligned} \right .$

又因为$x \in (0,+\infty) ,x \in N^*$ ，所以$\left \{\begin{aligned} &{Ans  = q*n , p \ge q} \\  &{Ans = \min((n / T) * (p * {x}^2 + q), T = x + 1,x= \sqrt{\frac{q}{p}} ,p < q} \\ &{Ans = p*n^2, x= \sqrt{\frac{q}{p}} \ge N,p < q} \end{aligned} \right .$。然而用这个式子贪心并不对T^T(只有50cent，不过话说居然没有$Q <= P$的情况）。

好吧，我们Dp，(´Д｀)y-~

我么设$F[0][i]$表示第$i$天旅行的最小花费，$F[1][i]$表示第$i$天吃饭的最小花费，则$\left \{\begin{aligned} &F[0][i] = min_{i - 1 \to i - \frac{q}{p}}^ {j} (F[1][j] + (i -  j)^2 * P) \ \text{(1)}\\ &F[1][i] = min_{i-1 \to 1}^j(F[0][j] + i*Q - j *Q) \ \text{(2)} \end{aligned} \right .$。

关于$\text{(1)}$式，因为我们之前算出了限制条件，所以只考虑$\text{(1)}$式的转移一般情况下并不会变成$O(n^2)$的，但是第二个就很不友好了，但是如果把$F[0][j] -j*Q$看成一个整体那么$\text{(2)}$式就变成了$F[1][i] = min_{i-1 \to 1}^j(F[0][j] - j *Q) + i*Q \ \text{(2)}$(话说本来就是好吗 ╮(─▽─)╭)，看一个变量记录$i$之前$F[0][j] - j *Q$的最小值，那么就实现了$O(1)$的转移。

## 代码

首先是那个50分的

```c++
#include <cmath>
#include <cstdio>
template <typename _Tp>
inline _Tp min(const _Tp &A ,const _Tp &B) {
    return A < B ? A : B;
}

int N, P, Q;

int X2, X, T1, T2;
long long Ans1, Ans2, Tmp;
int main() {
    scanf("%d%d%d", &N, &P, &Q);
    if(!N)
        printf("0");
    else if(Q <= P)
        printf("%lld", (long long)Q * N);
    else {
        X2 = Q / P;
        X = X2 = (int)sqrt(Q / P);
        X += X * X * P < Q;
        T1 = X + 1;
        T2 = X2 + 1;
        if(T1 > N)
            Ans1 =  (long long)P * N * N;
        else {
            Tmp = (long long)(N - N / T1 * T1);
            Ans1 = (long long)(N / T1) * (P * X * X + Q) + P * Tmp * Tmp;
        }
        if(T2 > N)
            Ans2 =  (long long)P * N * N;
        else {
            Tmp = (long long)(N - N / T2 * T2);
            Ans2 = (long long)(N / T2) * (P * X2 * X2 + Q) + P * Tmp * Tmp;
        }
        printf("%lld", min(Ans1, Ans2));
    }
    return 0;
}
```

然后是100 Cent的

```c++
#include <cstdio>
#include <cstring>
template <typename _Tp>
inline _Tp min(const _Tp &A, const _Tp &B) {
    return A < B ? A : B;
}
const long long INF = (unsigned long long)(-1) >> 1;
const int maxN = 200000 + 5;

int N, P, Q;

long long F[2][maxN];
void Dp() {
    register long long Min = 0;
    register int T = Q / P;
    memset(F, 0x7f, sizeof(F));
    F[0][0] = F[1][0] = 0;
    for(int i = 1; i <= N; ++i) {
        for(int j = (i - T > 0 ? i - T : 0); j < i; ++j)
            F[0][i] = min(F[0][i], F[1][j] + (long long)(i - j) * (i - j) * P);
        F[1][i] = Min + (long long)Q * i;
        Min = min(Min, F[0][i] - (long long)Q * i);
    }
}

int main() {
    scanf("%d%d%d", &N, &P ,&Q);
    Dp();
    printf("%lld", min(F[0][N], F[1][N]));
    return 0;
}
```


---

## 作者：Limerick (赞：0)

同样,感谢yd大神对我的指导@sgygd2004

首先吐槽一下题目,这是恋爱片吗(看到第一句话时,我的内心是拒绝的)？

接下来进入正题,说明一下题意:如果连续x天旅游,那么花费x\*x\*p,如果连续x天吃饭,则花费x\*q.

很明显的dp,但是普通的dp时间复杂度是O(n^2)的,肯定超时.

所以我们需要加个优化,(本蒟蒻原来写的是n^2,yg大神点醒了我),就是说枚举i~j天旅游,如果旅游所花的费用一定要小于i~j天吃饭的费用,否则还不如不旅游省钱.

OK,闲话少叙,贴上AC代码(有注释):

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<ctime>
using namespace std;
```
/\*
P2134 百日旅行

\*/
const int N=200005,maxn=1000000000000000000ll;//丧心病狂别理我

long long n,p,q,f[N][2],i,j;//f是滚动数组,f[][1]是旅游花费,f[][0]是吃饭花费

```cpp
int main(){
    scanf("%lld%lld%lld",&n,&p,&q);
    for(i=1;i<=n;i++){
        f[i][0]=maxn;//初始化,因为要求最小值,所以初始化全部取∞,这里无限大定义为一个很大的数
        f[i][1]=maxn;//同上
    }
    for(i=1;i<=n;i++){//枚举i
        f[i][0]=(f[i-1][0]<f[i-1][1]?f[i-1][0]:f[i-1][1])+q;//吃饭花费为第1~i-1天里的最小花费+q*1
        for(j=i;j>=1&&p*(i-j+1)*(i-j+1)<q*(i-j+1);j--){//枚举j,1<=j<=i,注意这里的优化,如果i~j天旅游,那么连续的(i-j+1)天旅游的费用必须小于连续的(i-j+1)天吃饭的费用,不然还不如直接吃饭划算
            f[i][1]=f[i][1]<(f[j-1][0]+p*(i-j+1)*(i-j+1))?f[i][1]:(f[j-1][0]+p*(i-j+1)*(i-j+1));//旅游花费为之前的吃饭话费+第i~j天旅游的费用与当前取最小
        }
    }
    printf("%lld",f[n][1]<f[n][0]?f[n][1]:f[n][0]);//取一直到第n天吃饭和旅游的最小花费输出
    //system("pause");
    exit(0);
}
[特别注明:本段文字引用https://www.luogu.org/space/show?uid=13185#wiki_list]
```

---

## 作者：金爷爷哈哈 (赞：0)

（据说N^2也能过，表示被吓坏）


这个题被我硬生生的做成了斜率优化。。。。。

复杂度骤降O（N）（然而并没有比N^2跑的快到哪里去。。。）


f(i)表示第i天不旅行的最小花费。。。

显然 f(i)=min{0<=j<i|f(j)+(i-j-1)^2\*p+q}。

最后答案就是f(n+1)-q.


那么如何快速计算f呢？


把上式化简之后可以得到： 2\*i\*(j+1)\*p +f(i)-i^2\*p-q = f(j)+(j+1)^2\*p 。

然后直接套斜率优化，双端队列维护凸包，维护之后的队首就是最优的j。


code:



    
        
        
        
    
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define maxn 200005
struct node{
    ll x,y;
}s[maxn];
ll hd=1,tl=0;
ll n,m,p,q;
ll now,xl;
ll nx,ny;
inline ll calc(ll x,ll y){
    return s[x].y-s[x].x*y;
}
int main(){
    cin>>n>>p>>q;
    s[++tl]=(node){1,p};
    for(ll i=1;i<=n+1;i++){
        xl=2*i*p;
        while(hd<tl&&calc(hd,xl)>=calc(hd+1,xl)) hd++;
        now=calc(hd,xl)+i*i*p+q;
        if(i>n){
            printf("%lld\n",now-q);
            return 0;
        }
        nx=i+1,ny=(i+1)*(i+1)*p+now;
        while(hd<tl&&(double)(ny-s[tl].y)/(double)(nx-s[tl].x)<=(double)(s[tl].y-s[tl-1].y)/(double)(s[tl].x-s[tl-1].x)) 
           tl--;
        s[++tl]=(node){nx,ny};
    }
    return 0;
}
```

---


# 方块消除

## 题目描述

Jimmy 最近迷上了一款叫做方块消除的游戏。游戏规则如下：$n$ 个带颜色方格排成一列，相同颜色的方块连成一个区域（如果两个相邻方块颜色相同，则这两个方块属于同一区域）。为简化题目，将连起来的同一颜色方块的数目用一个数表示。

例如，`9 122233331` 表示为

```plain
4
1 2 3 1
1 3 4 1
```

游戏时，你可以任选一个区域消去。设这个区域包含的方块数为 $x$，则将得到 $x^2$ 个分值。方块消去之后，其余的方块就会竖直落到底部或其他方块上。而且当有一列方块被完全消去时，其右边的所有方块就会向左移一格。Jimmy 希望你能找出得最高分的最佳方案，你能帮助他吗？


## 样例 #1

### 输入

```
4
1 2 3 1
1 3 4 1
```

### 输出

```
29
```

# 题解

## 作者：wangyibo201026 (赞：18)

## 思路

首先考虑区间 DP，那么设 $f_{i, j}$ 为颜色块 $i$ 到颜色块 $j$ 全部消完的最大价值。那么转移显然可以这么写：

$$f_{i, j} = \max(f_{i, j}, f_{i, k} + f_{k + 1, j})$$

此时 $k$ 为枚举的断点，但是显然不够，因为可能出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/vpa61lrj.png)

此时明显 $f_{i, k} + f_{k + 1, j}$ 就不是最优的消除方案，因该先把蓝色的全部消掉，再消红色的。

但最大的问题还不是这个，请看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g0f0yoj3.png)

此时 $l$ 是在枚举断点时的一个断点，那么最优方案此时就不是 $f_{i, l} + f_{l + 1, j}$，因为明显是要红色的连起来消最优。

很明显，以上情况用两维的 $f$ 都无法解决，所以我们再开一维：

$f_{i, j, k}$ 表示在块 $i$ 到 $j$ 以及后面连续 $k$ 个与块 $j$ 颜色相同的小格最优的消除价值。这里比较抽象，感性理解。

此时又两种转移：

1. 在 $j$ 后面补上 $k$ 位（注意：并非指块）：

$$f_{i, j, k} = \max(f_{i, j, k}, f_{i, j, 0} + (num_j + k) ^ 2)$$

2. $k$ 为 $[i, j]$ 断点，当 $color_k = color_j$ 时，合并 $[i, j]$ 和 $j$ 以及 $j$ 后面 $t$ 位：

$$f_{i, j, t} = \max(f_{i, j, t}, f_{i, k, num_j + t} + f_{k + 1, j - 1, 0})$$

此时只需预处理出 $suf_i$ 表示 $i$ 色块后面有多少个连续位置的颜色与 $i$ 相同就可以了。


## 代码

Code：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 505;

int n;
int color[N], num[N], suf[N], f[N][N][N];

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        cin >> color[i];
    }
    for(int i = 1; i <= n; i++){
        cin >> num[i];
    }
    for(int i = 1; i <= n; i++){   //预处理出 suf[i]
        for(int j = i + 1; j <= n; j++){
            if(color[i] == color[j]){
                suf[i] += num[j];
            }
        }
    }
    memset(f, 0xcf, sizeof(f));
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= suf[i]; j++){
            f[i][i][j] = (num[i] + j) * (num[i] + j);   //这里预处理出 f 数组
        }
    }
    for(int len = 2; len <= n; len++){
        for(int i = 1; i + len - 1 <= n; i++){
            int j = i + len - 1;
            for(int k = 0; k <= suf[j]; k++){   //注意：0 也可以
                f[i][j][k] = max(f[i][j][k], f[i][j - 1][0] + (num[j] + k) * (num[j] + k));
            }
            for(int k = i; k <= j - 2; k++){   //这里为什么 j - 1 不行，因为要删掉 k + 1 到 j - 1 的，而 k = j - 1 是无效的
                if(color[k] == color[j]){
                    for(int t = 0; t <= suf[j]; t++){
                        f[i][j][t] = max(f[i][j][t], f[i][k][num[j] + t] + f[k + 1][j - 1][0]);    //这里为什么是 num[j] + t，因为 k 和 j 合并了，所以 j 后面一共有 num[j] + t 个
                    }
                }
            }
        }
    }
    printf("%d\n", f[1][n][0]);
	return 0;
}   
```

本题真的很难，如果有不理解可以私信。

---

## 作者：sto__Liyhzh__orz (赞：13)

[传送门](https://www.luogu.com.cn/problem/P2135)

考虑三维区间 DP。

请区别开区间与方块。

$dp_{i,j,k}$ 表示消除 $i\sim j$ 区间且后面有 $k$ 个方块与 $j$ 区间（也可以说成 $j$ 区间最后一个块，因为 $j$ 区间颜色相同）颜色相同。

有两种情况：

1. $l\sim r-1$ 区间自己消，将第 $r$ 区间跟后面 $k$ 个一起消。

   $$dp_{l,r,k}=\max(dp_{l,r,k},dp_{l,r-1,0}+(b[r]+k)^2)$$
  
2. 枚举 $l\sim r-1$ 中与第 $r$ 区间颜色相同的块 $i$，就可以先消去 $i+1\sim r-1$ 块，这样 $i$ 和 $r$ 就成了一个块，再消去 $l\sim i$ 就可以了。

   $$dp_{l,r,k}=\max(dp_{l,r,k},dp_{l,i,k+b[r]}+dp_{i+1,r-1,0})$$

处理出来后答案就是 $dp_{1,n,0}$。

```cpp
#include<bits/stdc++.h>
#define endl char(10)
#define lowbit(x) x&(-x)
using namespace std;

typedef double db;
typedef long long ll;
typedef __int128 III;
const db eqs=1e-6;
const int inf=1e9;
void ll_cmax(ll &a,ll b){a=a>b?a:b;}
void ll_cmin(ll &a,ll b){a=a<b?a:b;}
void int_cmax(int &a,int b){a=a>b?a:b;}
void int_cmin(int &a,int b){a=a<b?a:b;}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}
bool number(char ch){return ch>='0' && ch<='9';}
bool lowerchar(char ch){return ch>='a' && ch<='z';}
int sqlong(int n){int sq=sqrt(n)+1;return min(sq,n);}

const int MAXN=50+5,MAXM=1000+5;
int dp[MAXN][MAXN][MAXM],a[MAXN],a1[MAXN],b[MAXN],b1[MAXN],n; 

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	int sum=0;
	for(int i=1;i<=n;i++) cin>>a1[i];
	for(int i=1;i<=n;i++) cin>>b1[i],sum+=b1[i];
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(a1[i]!=a1[i-1]) a[++cnt]=a1[i],b[cnt]=b1[i];
		else b[cnt]+=b1[i];
	}
	n=cnt;
	for(int i=1;i<=n;i++)
	{
		for(int l=1;l<=n-i+1;l++)
		{
			int r=l+i-1;
			for(int j=0;j<=sum;j++) int_cmax(dp[l][r][j],dp[l][r-1][0]+(b[r]+j)*(b[r]+j));
			for(int j=l;j<r;j++)
			{
				if(a[j]==a[r])
				{
					for(int k=0;k<=sum;k++) int_cmax(dp[l][r][k],dp[l][j][k+b[r]]+dp[j+1][r-1][0]);
				}
			}
		}
	}
	cout<<dp[1][n][0]<<endl;
	return 0;
}
//by Matrix_Power
```

---

## 作者：Froranzen (赞：11)

### [题目传送门~](https://www.luogu.com.cn/problem/P2135)


------------
# 思路

------------
求一个区间内分数的最大值，我们容易想到用**区间dp**来做这道题。

首先，我们来定义一下数组： 

$dp[l][r]$ 表示 将 $l$~$r$ 这段区间消除得到的最大分数值。   
$color[l]$ 表示 $l$ 这段区间的颜色。  
$len[l]$ 表示 $l$ 这段区间的长度。

但是在写代码时，我们发现：如果在 $r$ 后面有一段长度为 $k$ 的区间颜色和 $r$ 区间 一样，那么在消除 $l$~$r$ 区间时，会顺带着把 $k$ 区间也消除了。所以我们就加上一维数组来维护这个 $k$ ：

$dp[l][r][k]$ 表示 **消除 $l$~$r$ 这段区间且在 $r$区间 后有 $k$ 个与 $r$ 区间颜色相同的方块的最大分数值**。

接下来我们考虑**状态的转移**。

1. 首先，我们可以直接消除 $r$ 这一段区间，再加上消除 $l$ ~ $r-1$ 区间的最大值，那么转移方程就为：
	$$dp[l][r][k] = dp[l][r-1][0] + (len[r] + k)^2$$
2. 其次，我们可以枚举 $l$~$r$ 间的一段区间 $i$，使 $i$ 区间的颜色与 $r$ 区间的颜色相同，然后我们可以先消除 $i+1$ ~ $r-1$ 区间。这样的话， 就可以将 $r$ 和 $i$ 两个区间合并成一个颜色相同的区间，然后再计算消除 $l$~$i$ 区间的最大值，那么转移方程就为： 
	$$dp[l][r][k] = max (dp[l][i][len[r] + k] + dp[i +1][r -1][0])$$
3. 当然，$l == r$ 时，我们直接返回 $(len[r]+k) ^2$ 即可。


------------

# 代码

### 记忆化搜索
```cpp
#include <cstdio>
using namespace std;

inline char nc () {
	static char buf[100000], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2) ? EOF :*p1++;
}

inline int read () {
	register int x(0), f(1);
	char ch = nc ();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
			f = ~f +1;
		ch = nc ();
	}
	while (ch <= '9' && ch >= '0') {
		x = (x << 3) + (x << 1) + (ch ^48);
		ch = nc ();
	}
	return x *f;
}
 
inline int max (int a, int b) {
	return a > b ? a :b;
}

int n;
int color[55];
int len[55];
int qwq[55][55][555];

int dfs (int l, int r, int k) {
	if (qwq[l][r][k]) return qwq[l][r][k];
	if (l == r) return (len[r] + k) * (len[r] + k);
	qwq[l][r][k] = dfs (l, r - 1, 0) + (len[r] + k) * (len[r] + k);
	for (register int i(l); i < r - 1; ++i)
		if (color[i] == color[r])
			qwq[l][r][k] = max (qwq[l][r][k], dfs (l, i, len[r] + k) + dfs (i + 1, r - 1, 0));
	return qwq[l][r][k];
}

int main () {
	n = read ();
	for (register int i(1); i <= n; ++i) color[i] = read ();
	for (register int i(1); i <= n; ++i) len[i] = read ();
	printf ("%d", dfs (1, n, 0));
	return 0;
}
```

------------
（悄悄[要个关注](https://www.luogu.com.cn/user/361432)不过分吧, qwq）


---

## 作者：DiaoHantong (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P2135)

## 思路

这道题一看就是区间DP，每消除一个区域的方块，就可以得到 $b_i^2$ 的分数，假设 $f_{i,j}$ 为消除区间 $[i,j]$ 的最高分，那么，对于区域 $j$ ，就有两种决策：

决策1：消除区域 $j$，那么 $f_{i,j}=f_{i,j-1}+b^2_i$

决策2：暂时不消除区域 $j$,与之前的某个同色块连在一起消除，但对于决策2，我们需要清楚知道区间 $[i,j-1]$ 中每一个区域的消除情况，状态数过多，我们可以换一种思路。

决策2会对未来行动产生影响，所以我们可以再加一个维度来假设未来情况。

设 $f_{i,j,k}$ 表示消除区间 $[i,j]$ 且区域 $j$ 之后有 $k$ 个与区域 $j$ 同色的方块的最大得分，对于区域 $j$，有以下两种决策：

决策1：消除区域 $j$ 和与之相连的 $k$ 个同色方块，那么 $f_{i,j,k}=f_{i-1,j-1,0}+(b_j+k)^2$。

决策2：暂时不消除区域 $j$ 区域，与之前的某个同色区域连在一起消除。假设区间 $[i,j-1]$ 中与区域 $j$ 同色的区域所在位置为 $p$，那么 $f_{i,j,k}=f_{i,p,k+b_j}+f_{p+1,j-1,0}$ 。

综上所述， 

$f_{i,j,k}=\max(f_{i-1,j-1,0}+(b_j+k)^2,f_{i,p,k+b_j}+f_{p+1,j-1,0})$。 

边界为 $f_{i,j,k}=0,f_{i,i,k}=(b_i+k)^2$ ,

即消除区间 $[i,i]$ 的方块且区域 $i$ 之后有 $k$ 个与区域 $i$ 同色的方案最大得分为 $(b_i+k)^2$。

目标解为 $f_{1,n,0}$ ,即消除区域 $[1,n]$ 的方块且区域 $n$ 后有 $0$ 个与区域 $n$ 同色的方块的最大得分。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int c[55],b[55];
long long f[55][55][1005];
//f[i][j][k]代表消除区间[i,j]的方块且区域j之后(未来)有k个与区域j同色的方块的最大得分
int main(){
    int n,s=0;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>c[i];
    for(int i=1;i<=n;i++)cin>>b[i],s+=b[i];
    for(int len=1;len<=n;len++){//枚举阶段
        for(int i=1;i+len-1<=n;i++){//枚举状态
            int j=i+len-1;
            for(int k=0;k<=s;k++){//决策1
                f[i][j][k]=max(f[i][j][k],f[i][j-1][0]+(b[j]+k)*(b[j]+k));
            }
            for(int p=i;p<j-1;p++){//决策2
                if(c[p]==c[j]){
                    for(int k=0;k<=s;k++){
                        f[i][j][k]=max(f[i][j][k],f[i][p][k+b[j]]+f[p+1][j-1][0]);
                    }
                }
            }
        }
    }
    cout<<f[1][n][0];//输出目标解f[1][n][0];
    return 0;
}
```

---

## 作者：_Cheems (赞：3)

挺好一道区间 dp。~~题解区写的都啥啊，根本看不懂。~~

首先假如相邻颜色段颜色相等，我们就将其合并，记颜色为 $a_i$，数量为 $b_i$。可以证明，我们一定不会把一个颜色段拆开来操作，因为价值是平方，有 $(x+y)^2\ge x^2+y^2$。

容易想到定义 $g_{i,j}$ 表示消除 $[i,j]$ 内的所有颜色段的最大价值。转移就是枚举段内颜色，将所有该颜色的单独拎出来最后一起操作，然后价值就是其余段的 $g$ 之和以及该颜色数量的平方。

但这是错误的！因为不一定要把所有该颜色的都放在一起最后消掉，我们可以选取一部分让它先被消掉以满足某些需求。

例如：

```
5
1 2 1 2 1
4 6 1 6 4
```

可以先消中间那段 `1`，使得两段 `2` 合并，最后合并两端的 `1`。这样更优。

如何解决？不妨将所有选取方案（即选择放在最后消掉的元素）分为两类：$r$ 被选和不被选。假如 $r$ 不被选，那么正常进行区间合并即可枚举到所有情况。假如 $r$ 被选，必须记录当前被选元素的总数（$\sum b$）。

$r$ 是区间右端点。不妨记 $f_{i,j,k}$ 为 $[i,j]$ 中，选取元素颜色为 $a_j$ 且 $j$ 一定被选取，选取元素数量之和为 $k$ 时，的最大价值（注意先不计算选取元素的价值）。那么选 $r$ 方案最大值就是 $\max\limits_k f_{i,j,k}+k^2\to g_{i,j}$。

转移很 simple，枚举 $[i,j-1]$ 中 $a_p=a_j$ 的 $p$，再枚举 $k$，那么：$f_{i,p,k}+g_{p+1,j-1}\to f_{i,j,k+b_j}$。

记 $m=\sum b$，复杂度 $O(n^3m)$，瓶颈在 $f$ 转移上。注意卡好枚举上下界，轻松跑过。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 55, C = 1e3 + 5;
int _n, n, a[N], b[N], f[N][N][C], g[N][N], sm[N][N]; 

signed main(){
	memset(f, -1, sizeof f); //不要出现非法情况 
	cin >> _n;
	for(int i = 1; i <= _n; ++i) scanf("%lld", &a[i]);
	for(int i = 1; i <= _n; ++i) scanf("%lld", &b[i]);
	for(int i = 1; i <= _n; ++i) //去重 
		if(a[i] == a[n]) b[n] += b[i];
		else a[++n] = a[i], b[n] = b[i];
	for(int i = 1; i <= n; ++i){		
		g[i][i] = b[i] * b[i], f[i][i][b[i]] = 0;
		for(int j = 1; j <= _n; ++j) sm[i][j] = sm[i - 1][j] + (a[i] == j ? b[i] : 0); //下面转移的循环上界 
	}
	for(int len = 2; len <= n; ++len)
		for(int i = 1; i + len - 1 <= n; ++i){
			int j = i + len - 1;
			f[i][j][b[j]] = g[i][j - 1]; //假如只有j被选取 
			for(int k = i; k < j; ++k){
				g[i][j] = max(g[i][j], g[i][k] + g[k + 1][j]);
				if(a[k] == a[j])
					for(int p = b[k]; p <= sm[k][a[k]] - sm[i - 1][a[k]]; ++p)
						if(f[i][k][p] != -1)
							f[i][j][p + b[j]] = max(f[i][j][p + b[j]], f[i][k][p] + g[k + 1][j - 1]);
			}
			for(int p = b[j]; p <= sm[j][a[j]] - sm[i - 1][a[j]]; ++p) 
				if(f[i][j][p] != -1) g[i][j] = max(g[i][j], f[i][j][p] + p * p);
		}
	cout << g[1][n];
	return 0;
}
/*
5
1 2 1 2 1
4 6 1 6 4
209
*/
```

---

## 作者：dmc0702 (赞：3)

# P2135
## 分析
一道区间 dp 的题。$dp_{i,j,k}$ 表示在 $i$ 到 $j$ 区间中，$j$ 右边有 $k$ 个与 $j$ 相同颜色的方块时的最大分数。此时可得出两种状态转移方程：

1.$dp_{i,j,k}=dp_{i,j-1,0}+(b_j+k)\times(b_j+k)$

2.$dp_{i,j,k}=\max(dp_{i,j,k},dp_{i,p,k+b_j}+dp_{p+1,j-1,0})$
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[55],b[55],dp[55][55][1005],s;
int main(){
	ios::sync_with_stdio(false),cin.tie(0);
	int m;
	cin>>m;
	for(int i=1;i<=m;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i],s+=b[i];
	for(int len=1;len<=m;len++){
		for(int i=1;i+len-1<=m;i++){
			int j=i+len-1;
            for(int k=0;k<=s;k++)dp[i][j][k]=max(dp[i][j-1][0]+(b[j]+k)*(b[j]+k),dp[i][j][k]);
			for(int p=i;p<j-1;p++)
				if(a[p]==a[j])
					for(int k=0;k<=s;k++)
						dp[i][j][k]=max(dp[i][j][k],dp[i][p][k+b[j]]+dp[p+1][j-1][0]);
		}
	}
	cout<<dp[1][m][0];
	return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：2)

题解区没看到有这做法的，就发一篇题解吧。

$f_{l,r}$ 表示 $l$ 到 $r$ 全部消除所获得的最大收益，考虑如何处理一个区间 $l,r$。

首先区间最左（或最右）的颜色是可以放到组后消除并不影响答案的，所以我们钦定最后消除这个区间左端点，对于每个区间做一个背包，$g_{r,k}$ 表示最后一次消除的颜色中最后面的位置为 $r$ 且此颜色数量为 $k$ 的最大收益（不包括此颜色），最后取 $\max_{k,r}\{k^2+g_{r,k}\}$ 即为 $f_{l,r}$。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 60;
int n,co;
int f[N][N],g[N][1001];
int c[N],a[N];
inline void get(int l,int r)
{
	int s=0,p=c[l],res=0;
	g[l][a[l]]=0,s=a[l];
	res=a[l]*a[l]+f[l+1][r];
	for(int i=l+1;i<=r;i++)
	{
		if(c[i]!=p)continue;
		s+=a[i];
		for(int j=l;j<i-1;j++)
		{
			if(c[j]!=p)continue;
			for(int e=a[i];e<=s;e++)
				g[i][e]=max(g[i][e],g[j][e-a[i]]+f[j+1][i-1]),res=max(res,g[i][e]+e*e+f[i+1][r]);
		}
	}
	s=a[l];
	for(int i=l+1;i<=r;i++)
	{
		if(c[i]!=p)continue;
		s+=a[i];
		for(int j=l;j<i-1;j++)
		{
			if(c[j]!=p)continue;
			for(int e=a[i];e<=s;e++)
				g[i][e]=-1e9;
		}
	}
	f[l][r]=res;
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	memset(g,0xcf,sizeof g);
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=n;i++)cin>>a[i],f[i][i]=a[i]*a[i];
	for(int len=2;len<=n;len++)
		for(int l=1;l+len-1<=n;l++)
					get(l,l+len-1);
	cout<<f[1][n];
}
```

---

## 作者：A_Đark_Horcrux (赞：2)

## 区间DP

看到区间分数最大值就想到区间DP咯qwq

定义 $f_{l,r,k}$ 表示di第 $r$ 个方块后面跟了 $k$ 个颜色相同的方块时，区间 $[l,r]$ 的分数最大值。

为什么这样定义状态呢？假如说定义 $f_{l,r}$ 为区间 $[l,r]$ 的分数最大值，由于区间内可能存在方块能与区间外的方块消除得分，因此这种方法是错误的。为了能与前后建立联系，同时也方便转移，所以定义这样一个奇怪的状态qwq

再假设 $len[i]$ 表示第 $i$ 个颜色串的长度。

现在考虑转移方程，对于 $f_{l,r,k}$ ，我们有两种处理方法：

- 1.直接将第 $r$ 个方块和后面跟的 $k$ 个颜色相同的方块消掉，贡献为 $(len_r+k)^2$ ，再加上前面一段就是当前状态的得分；

- 2.枚举分割点 $i$ ，如果第 $i$ 个方块与第 $r$ 个方块颜色相同，则后面一段可以先算出得分，再加上前面一段，就是当前状态的得分。

还有一种特殊情况：若 $l=r$ ，则当前状态得分为 $(len_r+k)^2$ 。

此处我们采用记忆化搜索，思路比较清晰qwq

```cpp
//搜索部分
int dfs(int l,int r,int k)
{
	if(f[l][r][k]) return f[l][r][k];//记忆化，如果到过这个状态，直接转移
	if(l==r) return (len[r]+k)*(len[r]+k);//l=r,返回(len_r+k)^2
	f[l][r][k]=dfs(l,r-1,0)+(len[r]+k)*(len[r]+k);//第一种方案
	for(int i=l;i<r-1;i++)//枚举中间点
		if(color[i]==color[r])//如果和第r个方块颜色相同
			f[l][r][k]=max(f[l][r][k],dfs(l,i,len[r]+k)+dfs(i+1,r-1,0));//得分取max
          		//第一个dfs的k，是r所在的那一段的长度加上后面的k个方块；
           		//第二个dfs的k是0，因为后面k个方块的贡献在第一个dfs计算完了
	return f[l][r][k];//回溯
}//完结撒花awa
```

---

## 作者：Strelitzia (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2135)

---

记录~~生活~~学习情况。

资料：[对一类动态规划问题的研究](https://wenku.baidu.com/view/83d0a76925c52cc58bd6bea8)

我们可以发现，定义 $dp_{i,j}$ 表示 $\text{[i,j]}$ 这个区间合并最大值是不行的，因为有颜色的转移。

所以我们要考虑有多少个同色块会连上来。

我们定义 $dp_{i,j,k}$ 表示 $[i,j]$ 这个区间且后面又有 $\text k$ 个与 $a_j$ 同色的块。

这样，我们就可以考虑到后面的新的木块了。

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int MAXN = 200 + 5;

int T,n,tot,a[MAXN],cnt[MAXN],dp[MAXN][MAXN][MAXN],vis[MAXN][MAXN][MAXN],tag;

int dfs(int l,int r,int k) {
	if (dp[l][r][k]) return dp[l][r][k];
	if (l == r) return (cnt[l] + k) * (cnt[l] + k);
	dp[l][r][k] = dfs(l,r - 1,0) + (cnt[r] + k) * (cnt[r] + k);
	for (int i = l ; i < r ; ++ i) {
		if (a[i] == a[r]) dp[l][r][k] = Max(dp[l][r][k],dfs(l,i,cnt[r] + k) + dfs(i + 1,r - 1,0));
	}
	return dp[l][r][k];
}

int main () {
	read(n);
	for (int i = 1 ; i <= n ; ++ i) read(a[i]);
	for (int i = 1 ; i <= n ; ++ i) read(cnt[i]);
	print(dfs(1,n,0));
	return 0;
}
```

---

## 作者：jiangjiangQwQ (赞：1)

### 题目大意
有 $n$ 个色块，第 $i$ 个色块颜色为 $a_i$，所含方块数为 $cnt_i$，每次可以合并相邻色块 $i$ 和 $j$，贡献为 $cnt_i*cnt_j$，最大化贡献和。 
### 思路
观察数据范围 $1 \leq m \leq 50$，大区间的答案可以由小区间的合并而来，显然就是区间动态规划了。按照寻常的套路，令 $f[i][j]$ 表示区间 $i \to j$ 的答案，但是需要注意的是两个相邻色块合并了之后，两旁的色块可以重新组合成同一种颜色的进行下一次合并，考虑多加一个维度变成 $f[i][j][k]$，表示区间 $i \to j$，$j$ 之后的区间消掉后会有 $k$ 个与 $a_j$ 相同的色块，如果直接将 $j$ 与其之后的 $k$ 个一起消掉，贡献为 $(cnt_j+k)^2$，即 $f[i][j][k]=dfs(i,j-1,0)+(cnt_j+k)^2$，接着继续合并区间 $i \to j-1$，这时 $j$ 后没有与其相同的色块了，$k = 0$，当然还可以查找区间 $i \to j-1$ 中与 $a_j$ 相同的色块 $p$，考虑先将 $p+1 \to j-1$ 消掉，然后 $p$ 端就可以和 $j$ 端合并，此时的转移为 $f[i][j][k]=dfs(i,p,cnt_j+k)+dfs(p+1,j-1,0)$。

---

## 作者：dread_breaker (赞：0)

## 思路：

设 $f_{i,j,k}$ 表示 $i$ 到 $j$ 这个区间后有 $k$ 个颜色与第 $j$ 块颜色相同。只需先预处理第 $i$ 块后有多少个颜色与第 $i$ 块相同的方块。


计算时分为两种情况：

①：$l \sim r-1$ 一起消，$r$ 和后面 $k$ 个一起消。

②：把 $l \sim r$ 分为 $l \sim i$ 和 $i+1 \sim r$ 两端，$l \sim i$ 一起消，$i+1 \sim r$ 和后面 $j$ 个一起消。

## 代码：
$a_{i}$ 表示第 $i$ 块的颜色。

$s_{i}$ 表示第 $i$ 块的数量。

$b_{i}$ 表示第 $i$ 块后有多少与第 $i$ 块颜色相同的方块。


```
#include<bits/stdc++.h>
using namespace std;

const int M = 55, N = 1e3 + 5; // N = 50 * 20 + 5，k 表示 j 后有 k 个颜色与第 j 块颜色相同的方块，所以 k 这一维要开大点！！！ 
int m, a[M], s[M], b[M], f[M][M][N];

inline void init() {
	for(int i = 1; i <= m; i++)
		for(int j = i + 1; j <= m; j++)
			if(a[i] == a[j]) b[i] += s[j];
	memset(f, -0x3f, sizeof(f));
	for(int i = 1; i <= m; i++)
		for(int j = 0; j <= b[i]; j++)
			f[i][i][j] = max(f[i][i][j], (s[i] + j) * (s[i] + j));
	return;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> m;
	for(int i = 1; i <= m; i++) cin >> a[i];
	for(int i = 1; i <= m; i++) cin >> s[i];
	init();
	for(int len = 2; len <= m; len++) {
		for(int l = 1; l <= m - len + 1; l++) {
			int r = l + len - 1;
			
			// 情况 1 
			for(int k = 0; k <= b[r]; k++)
				f[l][r][k] = max(f[l][r][k], f[l][r - 1][0] + (s[r] + k) * (s[r] + k));
				
			// 情况 2 
			for(int i = l; i < r; i++)
				if(a[i] == a[r])
					for(int j = 0; j <= b[r]; j++)
						f[l][r][j] = max(f[l][r][j], f[l][i][s[r] + j] + f[i + 1][r - 1][0]);
		}
	}
	cout << f[1][m][0] << "\n";
	return 0;
}
```

---

## 作者：OpheebopZ (赞：0)

区间 DP 必学好题。

考虑状态 $f _ {l, r}$ 表示消去区域 $l$ 到 $r$ 最大价值，发现不可行，因为区域像俄罗斯方块一样可以连消，当前决策必须考虑到要不要和前面的一起消，这样我们需要记录之前所有的消除情况，无法承受。

此时就有了一个思想，现在对过去的影响就是现在对未来的影响。我们**可以通过假设未来的情况，消除后效性**。

所以再考虑状态 $f _ {l, r, k}$ 表示区域 $l, r$ 和后面与区域 $r$ 颜色相同的 $k$ 个方块一起消掉的最大价值。

那么对于每个 $l, r, k$，有两种决策：

1. 区域 $r$ 与颜色相同的 $k$ 个方块直接一起消掉，则 $f _ {l, r, k} = f _ {l, r - 1, 0} + (num _ r + k) ^ 2$。
2. 区域 $r$ 与前面的一段与颜色相同的 $k$ 个方块一起消掉，则枚举断点 $p$，$p$ 及之前的区域与区域 $r$ 一起考虑连在一起消，其余的区域直接消掉，那么 $f _ {l, r, k} = f _ {l, p, k + num _ r} + f _ {p + 1, r - 1, 0}$。

事实上，决策一是决策二的特殊情况，即不与前面一段消掉。

最终的答案即为 $f _ {1, m, 0}$，因为最后未来绝对没有任何区域能和区域 $m$ 消掉。

## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXM = 55;

int m;
int a[MAXM], b[MAXM];
int f[MAXM][MAXM][1005];

int main() {
	cin >> m;
	int s = 0;
	for (int i = 1; i <= m; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i], s += b[i]; // s 是 k 枚举的上限
	// 这里 len 从 1 开始是因为没有给边界值
	// 先给 f[i][i][k] = (num[i] + k) * (num[i] + k) 就可以从 2 开始了
	for (int len = 1; len <= m; len++) {
		for (int l = 1; l <= m - len + 1; l++) {
			int r = l + len - 1;
			// 决策一：区域 r 与后面的 k 个同色方块一起消掉
			for (int k = 0; k <= s; k++) {
				f[l][r][k] = max(f[l][r][k], f[l][r - 1][0] + (b[r] + k) * (b[r] + k));
			}
			// 决策二：区域 r 与前面的一起同 k 个同色方块消掉
			for (int p = l; p <= r - 2; p++) { // 枚举断点 p
				if (a[p] == a[r]) {
					for (int k = 0; k <= s; k++) {
						f[l][r][k] = max(f[l][r][k], f[l][p][b[r] + k] + f[p + 1][r - 1][0]);
					}
				}
			}
		}
	}
	// 目标状态
	cout << f[1][m][0] << endl;
	return 0;
}
```

---

## 作者：mengdai (赞：0)

f[i][j][k]表示在i，j区间中，在j的右侧已经累积了k个与j相同颜色的方块时可以获得的最大积分

状态转移方程{

1.直接消掉，j与k连成的方块。f[i][j][k]=f[i][j-1][0]+(len[j]+k)^2;

2.在i，j区间中，寻找一个p连续方块，使得p与j是同一种类型的，那么可以，把p，j之间的方块消掉再进行消除:f[i][j][k]=f[i][p][len[j]+k]+f[p+1][j-1][0];

} 
ps:len[n]表示连续的方块n的长度


本人挚爱记忆化搜索

以下是记忆化搜索代码，没有剪枝，跑得不够快，见谅。

======================================================================================

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int jiyi[53][53][2003];
int zhong[53],num[53];
int m,i,ans;
int dp(int x,int y,int zong){
    int& fanhui=jiyi[x][y][zong];
    if(fanhui!=0){
        return fanhui;
    }else{
        if(x==y){
            fanhui=(num[x]+zong)*(num[x]+zong);
        }else{
            fanhui=dp(x,y-1,0)+(num[y]+zong)*(num[y]+zong);
            for(int xun=x;xun<=y-1;xun++){
                if(zhong[xun]==zhong[y]){
                     fanhui=max(fanhui,dp(x,xun,num[y]+zong)+dp(xun+1,y-1,0));
                }
            }
        }
    }
    return fanhui;
}
int main(){
    cin>>m;
    for(i=1;i<=m;i++){
        cin>>zhong[i];
    }
    for(i=1;i<=m;i++){
        cin>>num[i];
    }
    ans=dp(1,m,0);
    cout<<ans;
    return 0;
}
```

---


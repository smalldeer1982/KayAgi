# 翻硬币

## 题目描述

小 Z 离开家的时候忘记带走了钱包，掉下的硬币在桌子上排成了一列。正在等着哥哥回来的小 D 坐在桌子旁边，无聊地翻着桌子上的硬币。

出于某种爱好，小 D 一次一定会同时翻转 $M$ 枚硬币。由于小 D 是一个爱动脑的小学生，这样进行了若干次之后她很快想到了一个问题：有多少种方法能够在 $K$ 次翻转后把硬币由原来的状态变成现在这样呢？

因为小 D 是个好学的小学生，她只需要你告诉她方案数对 $10^9+7$ 取模的值以方便她进行验算就可以了。

## 说明/提示

### 样例解释

存在两种方案：

- $100 \to 101 \to 001$；
- $100 \to 000 \to 001$。

### 数据规模

- 对于 $30\%$ 的数据，$N \le 4$，$0 \le K \le 5$；
- 对于 $60\%$ 的数据，$N \le 10$；
- 对于 $100\%$ 的数据，$1 \le N \le 100$，$0 \le K \le 100$，$0 \le M \le N$。

## 样例 #1

### 输入

```
3 2 1
100
001```

### 输出

```
2```

# 题解

## 作者：Granger (赞：18)

本蒟蒻默默来水一发题解。。

话说回来真的有必要吐槽一句，取模的优先级好低啊，一开始一直没有加足够的括号导致有七个点一直爆炸，最后在每个取模的地方都加了括号，终于过了~

另外数组是要开long long的，应该不会有人像我一样傻吧。


说思路：

此题很明显的DP，状压DP，但计算一下纯打状压DP的话时间复杂度会炸的，同时我们能够发现，其实翻哪里的硬币是不重要的，重要的是最后是不是翻成了原来的样子，于是三重循环——

第一重枚举翻的次数

第二重枚举当前状态与目标状态不同硬币的个数

第三重枚举要翻转的与目标状态不同的硬币的个数

【话说刚开始写成了相同的，然后一直炸】


dp[i][j]表示翻转i次，还有j个与目标状态不同位置的方案数

方程就很好想啦，详见代码~


另外，由于本蒟蒻是刚做完组合数问题然后做这道，自然第一反应就是杨辉三角组合数问题。于是对于枚举的状态，从相同的里面挑需要翻的数量、从不同的里面挑需要翻的数量，然后应用乘法原理乘起来得出方案数【一定要加括号取模！】


最后输出结果就好啦


然后上代码



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mo 1000000007
using namespace std;
int n,k,m,tot;
char a[201],b[201];
long long sum[201][201],dp[201][201];
int main(){
    scanf("%d%d%d",&n,&k,&m);
    scanf("%s%s",a+1,b+1);//刚刚学会的直接从1位置开始读字符串 
    //for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    //for (int i=1;i<=n;i++) scanf("%d",&b[i]);
    for (int i=1;i<=n;i++)
     if (a[i]!=b[i]) tot++;
    for (int i=0;i<=max(n,m);i++) sum[i][0]=sum[i][i]=1;
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)
      sum[i][j]=(sum[i-1][j]+sum[i-1][j-1])%mo;
    //杨辉三角的问题 
    dp[0][tot]=1;//对于开始状态的初始化 
    for (int i=1;i<=k;i++)//i枚举翻转的次数 
     for (int j=0;j<=n;j++)//j枚举当前状态与目标状态不同硬币的个数 
      for (int r=0;r<=min(j,m);r++){//r枚举要翻转的与目标状态不同的硬币的个数 
          if (j-2*r+m>=0&&j-2*r+m<=n){//j-2*r+m表示除了翻转后剩下的不同于目标状态的硬币的个数 
              dp[i][j-2*r+m]=(dp[i][j-2*r+m]%mo+((dp[i-1][j]*((sum[n-j][m-r]*sum[j][r])%mo))%mo))%mo;
              //应用乘法原理进行方案数的求解，相邻两项之间的连接用乘不用加 
          }
         }
    printf("%lld",dp[k][0]);
    return 0;
}
代码略丑\(-.-)/不喜勿喷
```

---

## 作者：sun_yh (赞：6)

我们老师告诉我们让我们做这道题是练字符串处理。。。

窝：？？？

---

说回正题，分析一下题，~~显然~~每枚硬币彼此之间没有关系，所以我们可以把它们**分开处理**。

换句话说，我们不需要知道现在有哪些硬币没有被翻过来，我们只需要知道**已经翻了多少硬币、已经翻了几次**就可以推出从初始状态到当前状态的方案数。

所以，我们得出：

设$f_{i,j}$为翻了$i$次，有$j$枚硬币与目标状态相同的方案数，$l$枚举翻了$l$枚与目标状态不同的，$m$为翻$m$次，$n$为硬币数，$k$为一次翻的硬币数（~~不要问为什么与题目给的不一样~~）。

目标：$f_{m,n}$

转移:$f_{i,j}=\displaystyle\sum_{l=0}^{k}f_{i-1,j-l+(k-l)}\times{{n-(j-l\times2+k)}\choose l}\times{{j-l\times2+k}\choose{k-l}}$

初始：$f_{0,_\text{初始状态与目标状态相同的硬币数}}=1$

把转移方程翻译成人话，我们当前翻了$i$次，那上一个状态必然是$i-1$次。

把$l$枚与目标状态不同的换成与目标状态相同的，那就一定把$k-l$枚与目标状态相同的转成了与目标状态不同的，所以上一个状态一定比现在少$l$个相同的、多$k-l$个不同的。

那这$l$个从哪里选呢？当然是从不同的里面选，即（总数-相同个数）选$l$，即${{n-(j-l\times2+k)}\choose l}$，另一个是从相同的里面选$k-l$个再翻成不同的，即${{j-l\times2+k}\choose{k-l}}$，根据[乘法原理](https://baike.baidu.com/item/乘法原理/7538447?fr=aladdin)将它们相乘，取模
**（能取几遍就取几遍！！！）**。

AC代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<ctime>
#include<cmath>
#define ll long long
#define inf 0x3f3f3f3f
#define mod 1000000007
using namespace std;
int n,m,k,s1[101],s2[101],same;
ll c[102][102],f[101][101];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%1d",&s1[i]);//读入，%1d控制读入域宽 
	for(int i=1;i<=n;i++)
		scanf("%1d",&s2[i]);
	for(int i=1;i<=n;i++)
		if(s1[i]==s2[i])
			same++;
	c[1][1]=1;
	for(int i=2;i<=n+1;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;//处理组合数 
	f[0][same]=1;
	for(int i=1;i<=m;i++)
		for(int j=0;j<=n;j++)
			for(int l=0;l<=k;l++){
				int num=j-l*2+k;
				if(num<0)//几种不合法的情况，记得特判 
					continue;
				if(n-num<0)
					continue;
				if(k-l<0)
					continue;
				f[i][j]+=((f[i-1][num]*c[n-num+1][l+1])%mod*c[num+1][k-l+1]%mod)%mod;
				f[i][j]%=mod;
			}
	printf("%lld\n",f[m][n]);
	return 0;
}
```

---

## 作者：Clouder (赞：4)

本文亦发表于[笔者博客](https://www.codein.icu/lp2182/)。

## 题意

$N$ 个硬币，一次翻转恰好 $M$ 个，恰好 $K$ 次后到达目标状态的方案数。

## 朴素解法

先将正反面转化为是否与目标状态相同方便处理。

定义 $f(i,k)$ 为翻转了 $i$ 次，与目标状态有 $k$ 个硬币相同的方案数。

考虑转移，枚举翻转 $m$ 个硬币中，$j$ 个硬币从相同翻为不同， $m - j$ 个硬币从不同翻为相同。

那么计算得出新的相同数量即为 $k + m - 2 \times j$，判断是否在合法范围内。

从状态 $f(i-1,k)$ 转移到 $f(i,k + m - 2 \times j)$ 时，要在 $k$ 选择 $j$ 个相同的硬币翻转为不同，$n - k$ 中选择 $m - j$ 个硬币翻转为相同，乘上相应的组合数即可。

可以得到朴素的 DP 解法，复杂度约为 $O(kn^2)$。

代码实现中使用了滚动数组优化空间。

```cpp
#include <stdio.h>
#include <memory.h>
const int maxn = 110;
const int mod = 1000000007;
int n,k,m;
int dif;
char s1[maxn],s2[maxn];
long long f[2][maxn];//f[i] i sames.
long long c[maxn][maxn];
int main()
{   
    scanf("%d %d %d",&n,&k,&m);
    c[1][1] = 1;
    for(int i = 2;i<=n+1;++i)
        for(int j = 1;j<=i;++j)
            c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;
    scanf("%s",s1+1);
    scanf("%s",s2+1);
    for(int i = 1;i<=n;++i) dif += (s1[i] != s2[i]);
    int now = 0,last = 1;
    f[last][n - dif] = 1;
    while(k--)
    {
        memset(f[now],0,sizeof(f[now]));
        for(int i = 0;i<=n;++i)// origin same
            for(int j = 0;j<=m;++j)//choose j same->diff, n - j diff->same
            {
                int num = i - j + m - j;
                if(num > n || num < 0) continue;
                f[now][num] += ((f[last][i] * c[i+1][j+1]) % mod * c[n-i+1][m-j+1]) % mod;
                if(f[now][num] > mod) f[now][num] %= mod;
            }
        now ^= 1,last ^= 1;
    }
    printf("%lld",f[last][n] % mod);
    return 0;
}
```

## 矩乘优化

不难发现，每次的转移都是在累加上次的某个状态的结果乘上某个系数，并且系数是不变的。

$f(i,k + m - 2 \times j) += f(i - 1,k) \times \ldots$

那么整理一下，一定可以写成：

$f(i,k) = \sum f(i-1,j) \times A(j,k)$

可以使用矩阵乘法来加速DP。

具体地，用原先的DP过程来构造 $A$ 矩阵，用矩阵快速幂获得 $A^k$，再乘上初始状态矩阵即可获得最终状态矩阵。

该方法在 $n$ 较小， $k$ 较大时表现出色，但在本题中并无优势。

代码实现中，将矩阵整体下标加一避免零的出现。

```cpp
#include <cstdio>
const int maxn = 110;
const long long mod = 1000000007;
int n, m, k, cnt;
char s1[maxn], s2[maxn];
long long c[maxn][maxn];
inline void init()
{
    c[1][1] = 1ll;
    for (int i = 2; i <= n + 5; ++i)
        for (int j = 1; j <= i; ++j)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}
struct matrix
{
    int n, m;
    long long a[maxn][maxn];
    matrix(int n, int m)
    {
        this->n = n, this->m = m;
        for (int i = 1; i <= n; ++i) 
            for (int j = 1; j <= m; ++j)
                a[i][j] = 0;
    }
    matrix operator*(const matrix b)
    {
        matrix res(n, b.m);
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j)
                for (int k = 1; k <= b.m; ++k)
                    res.a[i][k] = (res.a[i][k] + a[i][j] * b.a[j][k]) % mod;
        return res;
    }
};
signed main()
{
    scanf("%d %d %d", &n, &k, &m), init();
    scanf("%s", s1 + 1), scanf("%s", s2 + 1);
    for (int i = 1; i <= n; ++i) cnt += (s1[i] == s2[i]);
    matrix A(n + 1, n + 1), S(1, n + 1), T(n + 1, n + 1);
    for (int i = 0; i <= n; ++i) for (int j = 0; j <= m; ++j)
    {
        int num = i + m - 2 * j;
        if (num > n || num < 0) continue;
        A.a[i + 1][num + 1] = (A.a[i + 1][num + 1] + c[i + 1][j + 1] * c[n - i + 1][m - j + 1]) % mod;
    }
    S.a[1][cnt + 1] = 1;
    for (int i = 1; i <= T.n; ++i) T.a[i][i] = 1;
    for (; k; k >>= 1)
    {
        if (k & 1) T = T * A;
        A = A * A;
    }
    S = S * T;
    printf("%lld\n", S.a[1][n + 1]);
    return 0;
}
```


---

## 作者：spire001 (赞：3)

## P2182 题解

### 题目意思
$k$ 次翻转，每次翻转 $m$ 枚不同的硬币，求最后与目标硬币正反面相同的方案数。

### 思路
很明显的动态规划组合计数题，这里给出一个 $O(k\times n\times m)$ 的做法。

设计 $dp_{i,j}$ 表示翻转 $i$ 次后有 $j$ 个相同的方案数。

从每一个状态最多可以推出 $O(2\times m)$ 个状态，不妨设从 $p$ 状态推出 $j$ 状态。

我们需要知道该如何翻转硬币，设翻 $x$ 枚同方向硬币，$y$ 枚反向硬币。

由于一定会同时翻转 $M$ 枚硬币：
$$
x+y=m
$$
又因为翻同方向的硬币，相同的硬币数减一，反之加一，则：
$$
p-x+y=j
$$

解得：
$$
(p,j)=(\frac{m-j+p}{2}, \frac{m+j-p}{2})
$$

根据乘法原理：
$$
dp_{i,j}=dp_{i-1,p}\times C_p^{\frac{m-j+p}{2}}\times C_{n-p}^{\frac{m+j-p}{2}}
$$

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL; // 记得开 long long

constexpr int mod = 1e9 + 7, N = 102;
int n, k, m, a[N], b[N]; LL dp[N][N], C[N][N];
char _a[3][N + 5];

void pre() // 预处理组合数
{
  for (int i = 0; i != N; i++) C[i][0] = 1;
  
  for (int i = 1; i != N; i++)
    for (int j = 1; j <= i; j++)
      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;

  return;
}

int main()
{
  cin >> n >> k >> m >> _a[1] >> _a[2]; pre();

  for (int i = 1; i <= n; i++) a[i] = _a[1][i - 1], b[i] = _a[2][i - 1];

  int tot = 0;
  for (int i = 1; i <= n; i++) tot += a[i] == b[i];
  dp[0][tot] = 1; // 初始状态

  for (int i = 1; i <= k; i++)
  {
    for (int j = 0; j <= n; j++)
    {
      for (int p = max(0, j - m); p <= min(n, j + m); p++) // j 状态由 p 状态推出
      {
        if ((m + p - j) % 2) continue; // 判断是 2 的倍数
        
        dp[i][j] = (dp[i][j] + (dp[i - 1][p] * C[p][(m - j + p) >> 1] % mod) * C[n - p][(m + j - p) >> 1] % mod) % mod; // 状态转移，记得取模
      }
    }
  }

  cout << dp[k][n] << endl;

  system("pause");
  return 0;
}

---

## 作者：Leap_Frog (赞：3)

### Problem.
刚开始有一个长度为$N$的硬币状态。  
求每次翻$M$次后变成结束状态的方案数。  

### Solution.
首先，我们考虑dp。  
我们观察题目，发现有一个性质：  
硬币所在的位置并不影响硬币的翻转！  
所以我们并不需要记录每枚硬币具体位置和状态，  
只需要记录有几枚硬币朝上就可以表示一个状态了。  
当然，由于结束状态不好表示，可以先把初始状态先全都异或上结束状态。  
相当于可以记录还有多少枚硬币和结束状态不相同。  

$dp[i][j]$表示翻了$i$次，和结束状态还有$j$个不同硬币的方案数。  
则起始状态为：$dp[0][dif]=1$，其他都为$0$（dif表示起始状态和结束状态差别的硬币数。  
$dp[i][j]$可以从$dp[i-1][?]$转移过来。  
我们可以枚举选的$M$枚硬币中有多少枚和结束状态不相同。  
~~虵~~设我们选了$l$枚与结束状态不相同的硬币，那么就有$M-l$枚硬币和结束状态相同。  
那么少了$l$枚的与硬币与结束状态不相同的硬币，多了$M-l$枚与结束状态不相同的硬币。（对不起，这里有点绕，笔者要慢慢写，才能把笔者绕清楚  
那么也就是多了$M-l\times2$枚与结束状态不相同的硬币。  
那么$dp[i][j+M-l\times2]$是从$dp[i-1][j]$转移过来的。  
此时相当于在$j$枚与结束状态不同的硬币中选出了要翻转的$l$枚和结束状态不相同的硬币，  
以及在$N-j$枚与结束状态相同的硬币中选出要反转的$M-l$枚和结束状态相同的硬币。  
所以这一步的方案数是$C_j^l\times C_{N-j}^{M-l}$。  
所以
$$dp[i][j+M-l\times2]=\sum_{l=1}^{M\&0\leq j+M-l\times2\leq N}dp[i][j]\times C_j^l\times C_{N-j}^{M-l}$$  
~~终于推出来了，能去写代码了~~  
~~没错，您没听错，我这个菜逼先写题解后写代码的！~~

### Coding.
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;//不解释
const int N=105,P=1000000007;//N范围，P是模数
int n,k,m,dif,a[N],dp[N][N],c[N][N];
//n,k,m都是题目中的，dif是Solution.中的dif，dp是dp数组
//c是组合数，a是暂时存储起始状态的数组
int main()
{
	scanf("%d%d%d",&n,&k,&m),dif=0;//读入，把dif清零
	for(int i=1;i<=n;i++) scanf("%1d",a+i);//读入起始状态
	for(int i=1,x;i<=n;i++) scanf("%1d",&x),dif+=(a[i]^x);//求出起始状态与终止状态差的硬币数
	memset(dp,0,sizeof(dp)),dp[0][dif]=1,memset(c,0,sizeof(c));//初始化，具体见Solution.
	for(int i=0;i<=n;i++) c[i][0]=1;//初始化求组合数
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%P;//求组合数
	for(int i=1;i<=k;i++)
		for(int j=0;j<=n;j++)//枚举dp[i][j]
			for(int l=0;l<=m;l++)//枚举l
				if(j-(l<<1)+m>=0&&j-(l<<1)+m<=n)//检查l的范围
					dp[i][j-(l<<1)+m]=(dp[i][j-(l<<1)+m]+1ll*dp[i-1][j]*c[j][l]%P*c[n-j][m-l]%P)%P;//dp转移
	return printf("%d\n",dp[k][0]),0;//输出答案并结束
}
```

---

## 作者：xuchuhan (赞：1)

刚看到题目的时候想到状压 DP，然后恍惚了一下把状态个数当成 $100$ 了，随便胡了一下准备开写才发现状态个数是 $2^{100}$。

回到正题。我们发现以上 DP 的不优秀之处在于我们记录了每一步的具体状态，考虑只记录当前状态与目标状态的不相同个数。设 $dp_{i,j}$ 表示当前是第 $i$ 次操作，当前状态与目标状态有 $j$ 个不相同的硬币的方案数。

考虑转移从何而来。可以再枚举 $l$ 表示当前操作变换的 $m$ 个硬币中，有多少是与目标状态不同的。也就是说，经过这一次操作之后，$l$ 枚硬币从不同变成相同，$m-l$ 枚硬币从相同变成不同，那么下一轮状态则有 $j-l+m-l=j+m-2l$ 枚硬币不同。

为了使得边界处理更加容易，不妨使用扩散型 DP，即设 $p=j+m-2l$，则 $dp_{i,p}\leftarrow dp_{i-1,j}\times \dbinom{j}{l}\times\dbinom{n-j}{m-l}$，后面两个组合数分别表示在原有的 $j$ 个不同硬币中选 $l$ 个不同硬币和在原有的 $n-j$ 个不同硬币中选 $m-l$ 个相同硬币进行操作，由于这两步操作互相独立，使用乘法原理计算贡献。

代码就很容易了，但是注意每一步都要取模，调一小时的惨痛教训啊。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=105,mod=1e9+7;
int n,k,m,diff,fac[N],dp[N][N];
string s,t;
int _fpow(int a,int b,int p){int ans=1;while(b){if(b&1)ans=ans*a%p;a=a*a%p,b>>=1;}return ans;}
int _inv(int x,int p){return _fpow(x,p-2,p);}
int C(int n,int m,int p){if(n<m||m<0)return 0;return ((fac[n]*_inv(fac[m],p))%p*_inv(fac[n-m],p))%p;}
signed main(){
	cin>>n>>k>>m>>s>>t,fac[0]=1;
	for(int i=1;i<=n+1;i++)fac[i]=fac[i-1]*i%mod;
	for(int i=0;i<n;i++)if(s[i]!=t[i])diff++;
	dp[0][diff]=1;//初始状态 
	for(int i=1;i<=k;i++){
		for(int j=0;j<=n;j++){
			for(int l=0;l<=min(m,j);l++){
				int p=j+m-2*l;
				if(p<0||p>n)continue;
				dp[i][p]+=(dp[i-1][j]%mod*C(j,l,mod)%mod*C(n-j,m-l,mod)%mod)%mod,dp[i][j]%=mod;//注意这里dp[i-1][j]一定要取模!不取模就是75分! 
			}
		}
	}
	cout<<dp[k][0];//最终状态 
	return 0;
}
```

---

## 作者：_fairytale_ (赞：1)

首先，可以想到一个朴素的状压 DP，即直接把每个硬币的状态都压下来，然后暴力转移，这个显然会 T 飞。

然后其实我们并不关心现在每个硬币的状态，我们只关心有几个硬币和目标状态相同。

所以不妨设 $f[i][j]$ 表示已经翻转了 $i$ 次，有 $j$ 枚硬币和目标状态相同的方案数。

注意题目中的 $K$ 和下文的 $k$ 做了区分。 

转移的时候，我们枚举翻转的 $m$ 枚硬币中有 $k$ 个从相同翻成不同，就可以得到转移方程：

$$
f[i][j]=\sum_{k=0}^{m}f[i-1][(j+k)-(m-k)]\times {(j+k)-(m-k)\choose k}\times{n-[(j+k)-(m-k)]\choose m-k}
$$

解释一下，我们目前的 $j$ 个相同的硬币中，有 $k$ 个是这次翻转翻成不同的，有 $(m-k)$ 个是从不同翻成相同的，所以 $f[i-1]$ 的第二维是 $(j+k)-(m-k)$ 注意我们现在是由第 $i$ 次翻转反推第 $i-1$ 次翻转，所以都要变号。

然后之前的这 $(j+k)-(m-k)$ 个相同的硬币中，我们可以从中随意挑 $k$ 个翻成不同的，$n-[(j+k)-(m-k)]$ 个不同的硬币中，我们可以随意挑 $m-k$ 个翻成相同的，所以要乘两个组合数。

最后答案即为 $f[K][n]$。

```cpp

#include<bits/stdc++.h>
#define re register
#define ll long long
#define rep(x,a,b) for(re int (x)=(a);(x)<=(b);++(x))
using namespace std;
#define maxn 110
#define mod 1000000007
int n,K,m;
string s,t;
ll ans;
int cnt;
ll f[maxn][maxn];
int fac[maxn];
int invfac[maxn];
inline int qp(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*res*x%mod;
		y>>=1;
		x=1ll*x*x%mod;
	}
	return res;
}
inline int inv(int x){
	return qp(x,mod-2);
}
inline int C(int x,int y){
	if(y>x||x<0||y<0)return 0;
	return 1ll*fac[x]*invfac[y]%mod*invfac[x-y]%mod;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n>>K>>m;
    fac[0]=1;
    rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;   
    rep(i,0,n)invfac[i]=inv(fac[i]);
	cin>>s>>t;
    s=" "+s,t=" "+t;
    rep(i,1,n)if(s[i]==t[i])++cnt;
    f[0][cnt]=1;
    rep(i,1,K){
    	rep(j,0,n){
    		//j+k+k-m>=0 -> k+k>=m-j
    		for(re int k=n;k+k>=m-j;--k){
    			f[i][j]=(f[i][j]+1ll*f[i-1][j+k+k-m]*C(j+k+k-m,k)%mod*C(n-(j+k+k-m),m-k)%mod)%mod;
			}
		}
	}
	cout<<f[K][n];
	return 0;
}
/*
input:

output:


*/



```

---

## 作者：hanzhongtlx (赞：1)

半退役蒟蒻水一个不正常写法。  

我们发现我们不关心一个位置具体翻的次数，只关心他翻了奇数次还是偶数次。  

于是再看这个数据范围，思路就比较明了了。 

当然要先求出偶数次翻转的位置有 $s$ 个。

设 $dp_{i,j}$ 为 翻了 $j$ 次，有 $i$ 个硬币被翻了偶数次的方案数。 

显然有 $dp_{n,0}=1$。  

我们根据小学组合知识可以得到转移方程。  

当翻了 $j$ 个，其中有 $l$ 个从前是翻了偶数次的，可以得到这一操作的贡献为:  

$$dp_{i+m-2l,j+1}\xleftarrow{+} dp_{i,j}\times \dbinom{i}{l}\times\dbinom{n-i}{m-l}$$  

然后你问：这样做之后 $dp_{s,k}$ 就是答案吗？ 

当然不是，我们 dp 是是乱选的，而最后是有序的。  

我们需要除以所有排法，就是把 $s$ 个偶数和 $n-s$ 个奇数排列，奇数和奇数，偶数和偶数之间没有差别。 

根据简单的组合知识能够知道，答案是 $\dfrac{dp_{s,k}}{\dbinom{n}{s}}$，模意义下除法要写逆元哦！  

时间复杂度是 $\mathcal O(n^2k)$。

```
#include"iostream"
#include"cmath"
#include"cstdio"
using namespace std;

#define read(x) scanf("%d",&x)
#define MAXN 105
#define ll long long
#define MOD 1000000007

int n,m,k,s;
ll C[MAXN][MAXN],dp[MAXN][MAXN];
char c[MAXN],cc[MAXN];

ll quickpow(ll a,ll b)
{
	ll ans=1,base=a;
	while(b)
	{
		if(b&1) ans=ans*base%MOD;
		base=base*base%MOD;
		b>>=1;
	}
	return ans%MOD;
}

int main()
{
	read(n),read(k),read(m);
	scanf("%s",c),scanf("%s",cc);
	for(int i=0;i<n;i++) if(c[i]==cc[i]) s++;
	for(int i=0;i<=100;i++) C[i][0]=1ll;
	for(int i=1;i<=100;i++)
	{
		for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;
	}
	dp[n][0]=1ll;
	for(int i=0;i<k;i++)
	{
		for(int j=0;j<=n;j++)
		{
			for(int l=0;l<=min(j,m);l++)
			{
				if(n-j<m-l) continue;
				dp[j+m-2*l][i+1]=(dp[j+m-2*l][i+1]+dp[j][i]*C[j][l]%MOD*C[n-j][m-l]%MOD)%MOD;
			}
		}
	}
	printf("%lld\n",dp[s][k]*quickpow(C[n][s],MOD-2)%MOD);
	return 0;
}
```

---

## 作者：zhouenji (赞：1)

初看此题，第一反应60%状压dp，然后就打了,就过了60，然后看大佬代码恍然大悟；

此题可以抛开硬币的位置，而只看当前的序列与最后的序列有多少不同就行；

于是可以用dp【i】【j】表示翻转了i次后与最后序列有j个不同的方案数；

然后你考虑每次可以翻转m个硬币，每次可以翻转与目标序列相同的，也可以翻转与目标序列不同的，

于是就可以考虑枚举一个l，表示翻转与目标序列相同的l个；

然后就是组合数学的部分了；

详情见代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const long long maxn=100+10;
const long long mod=1e9+7;
long long C[maxn][maxn],dp[maxn][maxn];
long long a[maxn],b[maxn];
long long n,K,m,sum;
int main()
{
    C[0][0]=1;
    for(long long i=1;i<=100;i++){
        C[i][0]=1;
        for(long long j=1;j<=i;j++)(C[i][j]=C[i-1][j]+C[i-1][j-1])%=mod;
    }
    scanf("%lld%lld%lld",&n,&K,&m);
    for(long long i=1;i<=n;i++){
        scanf("%1lld",&a[i]);
    }
    for(long long i=1;i<=n;i++){
        scanf("%1lld",&b[i]);
    }
    for(long long i=1;i<=n;i++){
        if(a[i]!=b[i])sum++;
    }dp[0][sum]=1;
    for(long long i=1;i<=K;i++){
        for(long long j=0;j<=n;j++){
            for(long long l=0;l<=min(j,m);l++){
                if(0<=j-l+(m-l) && j-l+(m-l)<=n){
                    (dp[i][j-l+(m-l)]=dp[i][j-l+(m-l)]%mod+(dp[i-1][j]*(C[j][l]*C[n-j][m-l]%mod)%mod)%mod)%=mod;
                }
            }
        }
    }printf("%lld\n",dp[K][0]);
}
```
这里我也给出状压的代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1000000+10;
const int mod=1000000007;
int dp[1<<11][105],q[maxn];
int x,n,m,K,cnt;
int main()
{
    scanf("%d%d%d",&n,&K,&m);
    for(int i=1;i<=n;i++){
        int a;
        scanf("%1d",&a);
        if(a==1){
            x|=1<<i-1;
        }
    }dp[x][0]=1;x=0;
    for(int i=1;i<=n;i++){
        int a;
        scanf("%1d",&a);
        if(a==1){
            x|=1<<i-1;
        }
    }
    for(int i=1;i<1<<n;i++){
        int y=i,sum=0;
        while(y){
            if(y&1)sum++;y>>=1;
        }
        if(sum==m)q[++cnt]=i;
    }
    for(int i=1;i<=K;i++){
        for(int j=0;j<1<<n;j++){
            if(!dp[j][i-1])continue;
            for(int k=1;k<=cnt;k++){
                (dp[j^q[k]][i]+=dp[j][i-1])%=mod;
            }
        }
    }printf("%d\n",dp[x][K]);
}
```

---

## 作者：sjr3065335594 (赞：0)

## P2182 翻硬币

挺妙的一道题。

这题最开始想到状压，但是发现 $N\le 100$ 没法压，不过由于题目中硬币是正还是反不重要，我们只需要知道有多少和最终状态不同就可以了，于是设计状态 $f[i][j]$ 表示已经翻了 $i$ 次并且有 $j$ 个硬币与最终状态相同。

转移需要用到组合数。

$$f[i][j]=\sum\limits_{k=0}^{m}f[i-1][j-k+m-k]\times C_{n-(j-k+m-k)}^{k}\times C_{j-k+m-k}^{j-k}$$
 
$k$ 表示这一次翻的时候将 $k$ 个原本与目标不相同的转成了相同的，所以就会有 $m-k$ 个被转成不同的，这些转成相同的硬币肯定要从原本不同的里边选，反之同理，用组合数就可以了。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp(x,y) make_pair(x,y)
#define CLR(a,x) memset(a,x,sizeof(a))
#define int long long
//#define int __int128
using namespace std;
const int N=1e5+5;
const int M=1e6+5;
const int INF=2e9+5;
const int mod=1e9+7;
int n,K,m,f[105][105],c[105][105];
char s[105],t[105];
signed main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%lld%lld%lld",&n,&K,&m);
	scanf("%s%s",s+1,t+1);
	int d=0;
	for(int i=1;i<=n;i++)if(s[i]==t[i])d++;
	c[1][1]=1;
	for(int i=2;i<=n+1;i++)  {
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	}
	f[0][d]=1;
	for(int i=1;i<=K;i++) {
		for(int j=0;j<=n;j++) {
			for(int k=0;k<=m;k++) {
				int l=j-k*2+m;
				if(l<0||l>n||k>m)continue;
				f[i][j]+=(f[i-1][l]*c[n-l+1][k+1])%mod*c[l+1][m-k+1]%mod;
				f[i][j]%=mod;
			}
		}
	}
	printf("%lld\n",f[K][n]);
	return 0;
}

```


---

## 作者：XL4453 (赞：0)

注意这题的换行符有不止'\n'，还有'\r'，如果用字符读入两个都需要判断。

------------
题目分析：

考虑 DP。

设立状态 $f_{i,j}$ 表示已经翻过 $i$ 次，当前状态有 $j$ 个和最终状态不一样的硬币的可能方案数。

转移时，枚举接下来有 $k$ 硬币翻为和最终状态一样，显然有：由不一样翻为一样的为 $k$，由一样的翻为不一样的为 $m-k$，接下来不一样的位置数为 $j-k+m-k$，也就是 $j-2\times k +m$。

然后运用组合数学的知识，发现由不一样翻为一样的方案为 $\dbinom{k}{j}$，然后由一样的翻为不一样的方案为 $\dbinom{m-k}{n-j}$，由乘法原理可知，对于每一个原方案，新的方案数为两者乘积，即：$\dbinom{m-k}{n-j}\times\dbinom{k}{j}$。

------------
代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int MOD=1000000007;
int n,k,m,diff,f[105][105],sum[105][105];
int a[105];
char c;
int main(){
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;i++){
		c=getchar();
//		while(c!='0'&&c!='1')c=getchar();
		while(c=='\r'||c=='\n')c=getchar();
		a[i]=c-'0';
	}
	for(int i=1;i<=n;i++){
		c=getchar();
//		while(c!='0'&&c!='1')c=getchar();
		while(c=='\r'||c=='\n')c=getchar();
		if(a[i]!=c-'0')diff++;
	}
	for(int i=0;i<=n;i++)
	sum[i][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++)
		sum[i][j]=(sum[i-1][j]+sum[i-1][j-1])%MOD;
	}
	f[0][diff]=1;
	for(int i=1;i<=k;i++){
		for(int j=0;j<=n;j++)
		for(int k=0;k<=m;k++)
		if(j-2*k+m<=n&&j-2*k+m>=0){
			f[i][j-2*k+m]=(f[i][j-2*k+m]+1ll*f[i-1][j]*((1ll*sum[n-j][m-k]*sum[j][k])%MOD)%MOD)%MOD;
		}
	}
	printf("%d",f[k][0]%MOD);
	return 0;
}
```


---


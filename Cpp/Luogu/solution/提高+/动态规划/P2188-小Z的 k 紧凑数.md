# 小Z的 k 紧凑数

## 题目描述

小 Z 在草稿纸上列出了很多数，他觉得相邻两位数字差的绝对值不超过 k 的整数特别奇特，称其为 k 紧凑数。

现在小 Z 想知道 [l，r] 内有多少个 k 紧凑数，希望你帮帮他。


## 说明/提示

【数据规模】

对于 30% 的数据，r − l ≤ 10^5；

对于另外 30% 的数据，l = 1，r 为 10 的倍数；

对于 100% 的数据，1 ≤ l ≤ r ≤ 10^18，0 ≤ k ≤ 8。


## 样例 #1

### 输入

```
1 13 1```

### 输出

```
12```

# 题解

## 作者：夏色祭 (赞：13)

楼上题解好鬼畜。

数位dp模板题啊。

我们可以把答案拆成query(1,r)-query(1,l-1)。

那么我们只要求出1~x的这个区间的k紧凑数的数量就行了。

f[i][j]表示第i位上的数为j的k紧凑数的数量。


$f[i][j]=\sum_{k=0}^{9}f[i-1][k] (|k-j|<=n)$

对于统计就是先统计最高位比x小的方案数，然后再逐位统计。

例如query(1,432)=query(1,399)+query(400,429)+query(430,432)

然后把符合条件的加上就行了。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<set>
#include<vector>
#include<map>
#include<cmath>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
using namespace std;
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
ll l,r,n,f[20][10],num[20],len;
//il int abss(int x){return x?x:-x;}
il vd dp(){
    For(i,0,9) f[1][i]=1;
    For(i,2,20)
        For(j,0,9)
            For(k,0,9)
                if (abs(j-k)<=n) f[i][j]+=f[i-1][k];
}
il ll query(ll x){
    len=0;
    For(i,0,20) num[i]=0;
    while (x>0){
        num[++len]=x%10;
        x/=10;
    }
    ll ans=0;
    For(i,1,len-1)
        For(j,1,9)
            ans+=f[i][j];
    Dow(i,len,1){
        For(j,0,num[i]-1){
            if (i==len&&!j) continue;
            if (abs(num[i+1]-j)<=n||i==len) ans+=f[i][j];
        }
        if (abs(num[i]-num[i+1])>n&&i!=len) break;
    }
    return ans;
}
int main(){
    l=read(),r=read(),n=read();
    dp();
    return printf("%lld",query(r+1)-query(l)),0;
}
```

---

## 作者：zjh111111 (赞：5)

### $P2188$ $ $
[小 $Z$ 的 $k$ 紧凑数](https://www.luogu.com.cn/problem/P2188)


[blog](https://www.luogu.com.cn/blog/75762/solution-p2188)食用效果更佳

【题意】

~~字面意思~~

样例就是$1...12$共12个数

【思路】

**数位$dp$**

把$0$~$r$与$0$~$l$-$1$ 的紧凑数求出来后相减即为答案，即

$$ans = check(r)-check(l-1)$$

设

$f[i][j][0/1]$ 表示**第$i$位上放数字$j$,前$i$位是$(1)$否$(0)$全部与最大值 $($即$r$或$l-1)$相同的状态下的紧凑数个数**

$cnt$ 为最大值的位数

$sum[i]$ 为最大值从高位到低位的第$i$位，

如最大值为$233$, 则$sum[1]=2,$ $ $ $sum[2]=sum[3]=3$

于是就有:

$0:$

$$f[i][j][0]=\sum_{k=max(j-L,0)}^{min(j+L,9)} f[i-1][k][0]$$

如果$j$小于$num[i]($ 等于就是转移到$f[i][j][1]$ 了 $)$, 则

$$f[i][j][0]+=\sum_{k=max(j-L,0)}^{min(j+L,9)} f[i-1][k][1](j<num[i])$$

$1:$

$$f[i][num[i]][1]=\sum_{k=max(num[i]-L,0)}^{min(num[i]+L,9)} f[i-1][k][1]$$

**注意**

#### 当$j-L>0$时, $f[i][j][0]++$

因为前导零可能会使紧凑数的最高位与$0$相减后$>L$，而被判为非法

如最大值为980，$L=3$

当你做到$8$时,$8-L=5$即下界只能到$5$，这是前面有数的情况，
而在前面全$0($即无数$)$的情况下，$8$开头显然是符合的，所以要加上去


(上述的$i\in[2,cnt])$

$ $

**预处理**

$$f[1][j][0] = 1 (j\in[0,num[1]))$$

$$f[1][num[1]][1]=1$$

**统计答案**

$$res = \sum_{i=0}^9 f[cnt][i][0]+f[cnt][i][1]$$

【理解】

其实可以发现$f[i][j][1]$的值只能是$0/1($全部一样不就最多一种嘛$..)$,而如果最大值上第$p$位与第$p-1$位相差$>L$，则
$$f[i][num[i]][1]=0(i\in[p,n])$$

【代码】
```cpp
#include <bits/stdc++.h>
#define For(i,l,r) for (register int i=l; i<=r; i++)
using namespace std;
typedef unsigned long long LL;
typedef signed long long ll;
template <typename T>
inline void read(T &x) {
	char c = getchar(); int w = 1; x = 0;
	while (!isdigit(c))
		(c == '-') && (w = -w), c = getchar();
	while (isdigit(c))
		x = (x << 1) + (x << 3) + (c ^ '0'), c = getchar();
	x *= w;
}

ll l, r, L, ncnt, f[20][20][2];
inline ll check(ll x) {
	if (x < 10) return x+1;             //防止x=-1或0
	ll nx = x, cnt = 0, res = 0;
	LL w = 1;                           //要开unsigned
	while (nx) w *= 10, nx /= 10, ++cnt;//分解每一位
	memset(f, 0, sizeof(f));            //清零
	w /= 10;
	for (register int i = 0; i <= x/w; ++i)
		f[1][i][(i == (x/w))] = 1;      //预处理
	for (register int i = 2; i <= cnt; ++i) {
		w /= 10; ll num = x / w % 10;   //num即为上面所说的num[i]
		for (register int j = 0; j < 10; ++j) {
			for (register int k = max(j-L, 0ll); k <= min(j+L, 9ll); ++k) {
				f[i][j][0] += f[i-1][k][0];
				if (j < num) f[i][j][0] += f[i-1][k][1];
					else if (j == num) f[i][j][1] += f[i-1][k][1];
			}
			if (j-L > 0) f[i][j][0] ++; //前导零影响
		}
	}
	for (register int i = 0; i < 10; ++i)
		res += f[cnt][i][0] + f[cnt][i][1]; //统计
	return res;
}
int main() {
	read(l); read(r); read(L);
	/*ll l = 0, r = 1e18, ans = -1, ncnt = check(n);
	while (l <= r) {
		ll mid = ((r-l+1)>>1) + l;
		if (check(mid)-ncnt >= k) ans = mid, r = mid-1;
			else l = mid+1;
	}*/
	cout << check(r)-check(l-1);
	getchar();
	return 0;
}

```


【拓展】

求大于$n$的第$k$个紧凑数

在原来基础上加个二分即可$($答案具有单调性$)$

```cpp
int main() {
	read(n); read(k); read(L);
	ll l = 0, r = 1e18, ans = -1, ncnt = check(n);
	while (l <= r) {
		ll mid = ((r-l+1)>>1) + l;
		if (check(mid)-ncnt >= k) ans = mid, r = mid-1;
			else l = mid+1;
	}
	cout << ans;
	getchar();
	return 0;
}
```

$check()$部分与上相同.

稍微想一下，挺显然的。

【总结】

挺好的一道数位$dp$，建议好好研究后做一下。

最好把拓展也实现一下









---

## 作者：mlvx (赞：3)

### 题意

给定 $l,r$，求出 $[l,r]$ 中任意相邻两位数字之差的绝对值均**不超过** $k$ 的数字个数。

### 分析

数位 dp 题。

数位 dp 题我一般都用记搜写，因为这样清楚还好些。

给 dfs 四个参数 $x,pre,lm,f$ 来描述当前的状态。

- $x$ 表示当前考虑到了原数的第几位（从低位向高位数）。

- $pre$ 表示上一个数字是什么。

- $lm$ 表示是否受原数该数位的限制。

- $f$ 表示是否没有前导零。

然后搞个记忆化就行了。

具体看代码里的注释。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int k,len,num[21];ll l,r,dp[21][10];
ll dfs(int x,int pre,int lm,int f){
	if(!x)return 1;
	if(!lm&&f&&~dp[x][pre])return dp[x][pre];//记忆化
	int maxc=lm?num[x]:9;ll ret=0;
	for(int i=0;i<=maxc;i++)if(!f||abs(i-pre)<=k)ret+=dfs(x-1,i,lm&&i==maxc,f||i);//有前导零 或者 这一位和上一位之差的绝对值不超过k
	return !lm&&f?dp[x][pre]=ret:ret;
}ll solve(ll x){
	for(len=0;x;x/=10)num[++len]=x%10;
	return dfs(len,-k,1,0);//把pre赋值成-k是因为第一位不受前面的限制
}int main(){
	memset(dp,-1,sizeof dp);
	cin>>l>>r>>k;
	cout<<solve(r)-solve(l-1);
	return 0;
}
```

---

## 作者：SunsetSamsara (赞：3)

这题是个数位 dp 模板题，难度不大。这道题很像 [P2657 \[SCOI2009\] windy 数](https://www.luogu.com.cn/problem/P2657)，把那道题的代码改一改就 A 了

首先，可以使用 `char*` 形式读入 $l,r$，最终答案就是 $solve(r)-solve(l)+check(l)$，其中 $solve(x)$ 表示 $[1,x]$ 的 $k$ 紧凑数，$check(x)$ 表示若 $x$ 符合条件则为 $1$，否则为 $0$。

那么我们就可以用记忆化搜索解决了。这个 Dfs 要用四个参数 $t,x,f,g$；$t$ 表示当前在第几位，$x$ 表示这一位是几，$f$ 表示当前是否还是前导零，$g$ 表示目前与这个数前 $t$ 位是否相等。根据相应的条件设定记忆数组就可以了。

最后奉上码风清奇的代码(请勿抄袭,否则后果自负~)：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
char L[20],R[20];
char *now;
int k;
long long mem[20][20][2][2];
long long Dfs(int t,int x,char f,char g){
	if(!now[t])return 1;
	if(mem[t][x][f][g]>=0)return mem[t][x][f][g];
	long long ans=0;
	if(f){
		int mx=now[t]-'0';
		for(int i=0;i<=|mx;++i)
			if(g){
				if(!i)ans+=Dfs(t+1,i,i==mx,1);
				else ans+=Dfs(t+1,i,i==mx,0);
			}else if(abs(i-x)<=k)ans+=Dfs(t+1,i,i==mx,0);
	}else{
		for(int i=0;i<=9;++i)
			if(g){
				if(!i)ans+=Dfs(t+1,i,0,1);
				else ans+=Dfs(t+1,i,0,0);
			}else if(abs(i-x)<=k)ans+=Dfs(t+1,i,0,0);
	}
	return mem[t][x][f][g]=ans/;
}
long long solve(char *t){
	now=/t;
	memset(mem,-1,sizeof(mem));
	return Dfs(0,0,1,1);
}
char check(char *s){
	for(int i=1;s[i];++i)
		if(abs(s[i]-s[i-1])>?k)return 0;
	return 1;
}
int main(){
	scanf("%s%s%d",&L,&R,&k);
	printf("%lld\n",solve(R)-solve(L)+check(L));
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：2)

跟[模板题](https://www.luogu.com.cn/problem/P2657)差不了多少。

定义 $f_{i,j}$ 为 $i$ 位且第 $i$ 位上数位 $j$ 的紧凑数个数，那么有 
$$f_{i,j}=\sum_{k=0}^{k\leq9}f_{i-1,k}(|j-k|\leq K)$$

统计时只要拆分即可。例如：

$$query(2333)=f_{1,1999}+f_{2000,2299}+f_{2300,2329}+f_{2330,2333}$$

注释见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 25;
ll f[N][N], a[N], l, r, lmt;
ll query(ll n) {
	ll sum = 0, ans = 0;
	while (n) a[++ sum] = n % 10, n /= 10; // 分解数位
	for (int i = 1; i < sum; i ++)
		for (int j = 1; j <= 9; j ++)
			ans += f[i][j]; // 对于sum - 1位上的紧凑数，是必定包含在求和区间里的 
	for (int i = sum; i >= 1; i --) {
		for (int j = 0; j < a[i]; j ++)
			if (!(i == sum && j == 0) && (i == sum || abs(a[i + 1] - j) <= lmt)) // 如果最高位是0，直接跳过
				ans += f[i][j];
		if (abs(a[i] - a[i + 1]) > lmt && i != sum) break; // 如果不符合条件，直接跳出循环
	}
	return ans;
}
int main() {
	cin >> l >> r >> lmt;
	for (int i = 0; i <= 9; i ++)
		f[1][i] = 1;
	for (int i = 2; i < N; i ++)
		for (int j = 0; j <= 9; j ++)
			for (int k = 0; k <= 9; k ++)
				if (abs(j - k) <= lmt) f[i][j] += f[i - 1][k]; // dp部分
	cout << query(r + 1) - query(l) << '\n';
	return 0;
}
```


---

## 作者：mydiplomacy (赞：2)

算法：记忆化搜索+数位dp

**以下引用内容引用自我的[另一篇题解](https://www.luogu.org/blog/user38212/solution-cf1036c)，熟悉数位dp的同学可以直接跳过**

> 一般地，数位dp可以用来解决下面的问题： 给定一个结果为bool类型的函数f(x)，求$[L,R]$内有多少个数满足$f(x)$是真。其中一般$L,R<=1e7$或更大，且f(x)与数位相关。

注意到，如果从前到后遍历每个数位可能的取值，每位能取哪些值只与这个数位的前一个数位取哪个值相关。

因此，本题中，我们可以用$dp[i][j]$表示，计算到第i位，上一位是j的情况下，后面的每一个数位有$dp[i][j]$不同种情况。

> 这样我们就很容易处理[1,pow(10,t)][1,pow(10,t)]中的答案。

> 现在假设我们需要求[1,3812]的答案。当我们从第一位开始dfs时，从0遍历到3（最高位最大为3），如果第一位是0或1或2，则后面的数据无需考虑限制，都可以从0遍历到9。如果第一位是3，则第二位最大是8。我们使用数组上界变量代表这个限制，如果变量为0代表这一位无需考虑限制，否则代表这一位需要考虑限制。

我写的是dfs记忆化搜索+数位dp，具体细节见代码。

```cpp

#include <iostream>
#include <cmath>
#include <cstdio> 
#include <cstring>
using namespace std;

typedef long long ll;

ll dp[20][10]; //如上述
int tot,a[20]; //tot代表数位的数量，a里面存当前要处理的数的每个数位上的数
int k; 

ll dfs(int pos/*当前处理到哪位，在我的程序里个位是第0位*/, int pre /*上一个数位上的值*/, bool lead/*在这个数位之前，是否每一位都是0（前导零）*/, bool limit/*如上述限制*/)
{
    if(pos==-1) return 1; //因为个位是第零位，若pos=-1，证明已经遍历了所有数位
    if(dp[pos][pre]!=-1 && !lead && !limit) return dp[pos][pre]; //记忆化搜索
    ll res=0; int up=limit?a[pos]:9;
    for(int i=0;i<=up;i++)
        if(lead || abs(i-pre)<=k) //如果当前这一位是第一位（lead=true），或当前这位和前面一位绝对值之差<=k，这一位是合法的
            res+=dfs(pos-1/*处理下一位* /,i/*下一位的上一位就是这一位*/,lead&&i==0/*如果之前所有位都是零，且这位也是零，那么lead继续是true*/,limit&&i==a[pos]/*类似lead*/); //累加答案
    if(!lead && !limit) dp[pos][pre]=res; //记忆化搜索
    return res; 
}

ll solve(ll x)
{
    for(tot=0;x>0;a[tot++]=x%10,x/=10); //for循环分离出x的每个数位，写成while循环也可以
    return dfs(tot-1,0,true,true);
}

int main()
{
    memset(dp,-1,sizeof(dp)); //务必不要忘了写初始化QwQ
    ll l,r;
    cin>>l>>r>>k;
    cout<<solve(r)-solve(l-1)<<endl; 
    return 0;
}

```

---

## 作者：Fa_Nanf1204 (赞：1)

### 分析：
挺水的一道数位 dp 题。

考虑设计状态来表示方案数，因为题目中所要求相邻的两个数位上的数字绝对值不超过 $k$，所以考虑记录上一个数字是什么。那么状态就出来了，$dp_{x,pre}$ 表示当前第 $x$ 位，前一个数字为 $pre$ 时的方案数。

最后再考虑前导零和最大值的限制，用记忆化直接套板子即可。
### Code:

```cpp
#include<bits/stdc++.h>
#define N 20
#define ll long long
using namespace std; 
ll l,r,a[N],dp[N][N],k;
ll dfs(int x,int cnt,bool lim,bool zero){
	if(x==0) return 1;
	if(!lim and !zero and dp[x][cnt]!=-1) return dp[x][cnt];
	ll ret=0,maxn=lim?a[x]:9;
	for(int i=0;i<=maxn;i++){
		if(cnt!=-114 and abs(i-cnt)>k){
			continue;
		}
		ret+=dfs(x-1,(zero&(i==0))?-114:i,lim&(i==maxn),zero&(i==0));
	}
	if(!lim and !zero) dp[x][cnt]=ret;
	return ret;
}
ll solve(ll x){
	int cnt=0;
	while(x!=0){
		a[++cnt]=x%10;
		x/=10;
	} 
	return dfs(cnt,-114,1,1);
}
int main(){
	cin>>l>>r>>k;
	memset(dp,-1,sizeof dp);
	cout<<solve(r)-solve(l-1);
	return 0;
}
```

---

## 作者：Laisira (赞：1)

### 题面
定义关于 $n$ 的紧凑数为一个数相邻两位之差小于 $n$。

求 $[l,r]$ 中的紧凑数个数。

### 思路
跟同类分布很相似，直接考虑数位动态规划。

把 $[l,r]$ 拆成 $[0,r]-[0,l-1]$。

然后设 $f_{i,j,k=0/1,p=0/1}$ 为第 $i$ 位时 $j$ 时，前面的是或否有数，到此位是或否顶满最上界。

然后转移：

当从 $p=0$ 时：

- $k=0$：$f_{i,j,0,0}\gets f_{i-1,k,0,0}$
- $k\not =0$ 且 $|j-k|\leq n$：$f_{i,j,1,0}\gets f_{i-1,k,0,0}$

- 另外的：$|j-k|\leq n$：$f_{i,j,1,0}\gets f_{i-1,k,1,0}$

很容易理解吧，分别是没有贡献没有，没有贡献有，有贡献有。

然后考虑顶满上界的即 $p=1$ 转移给谁（下面 $bit_i$ 指上界的第 $i$ 位的数），状态就没有上面复杂了：

$$f_{i,j,1,1}\gets f_{i-1,bit_{i-1},1,0}+f_{i-1,bit_{i-1},1,1}$$

最后呢就是开始状态的设计，因为我们要维护 $k,p$，所以我们需要把 $i=1$ 直接处理，因为 $i=0$ 对于 $p$ 没有意义。

所以：

$$f_{1,j,0,[j=bit_1]}\gets 1,[0\leq i\leq 9]$$

然后就没了。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int bit[20],f[20][10][2][2];
int solve(int n,int h) {
    int g=0;
    bit[0]=9;
	if(!n)bit[++g]=0;
    while(n) bit[++g]=n%10,n/=10;
    reverse(bit+1,bit+1+g);
    memset(f,0,sizeof(f));
    for(int i=0;i<=bit[1];i++)
        f[1][i][0][(i==bit[1])]=1;
    for(int i=2;i<=g;i++) {
        for(int k=0;k<=9;k++)
            for(int j=0;j<=9;j++) {
                if(!k)f[i][j][0][0]+=f[i-1][k][0][0];
                else if(abs(j-k)<=h)f[i][j][1][0]+=f[i-1][k][0][0];
                if(abs(j-k)>h)continue;
                f[i][j][1][0]+=f[i-1][k][1][0];
            }
        int k=bit[i-1];
        for(int j=0;j<=bit[i];j++) {
            if(abs(j-k)>h)continue;
            f[i][j][1][(j==bit[i])]+=f[i-1][k][0][1];
            f[i][j][1][(j==bit[i])]+=f[i-1][k][1][1];
        }
    } int ans=0;
    for(int i=0;i<=9;i++)
        ans+=f[g][i][0][0]+f[g][i][1][0];
    ans+=f[g][bit[g]][0][1]+f[g][bit[g]][1][1];
    return ans;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int l,r,k;
    cin>>l>>r>>k;
    cout<<solve(r,k)-solve(l-1,k);
    return 0;
}
```

---

## 作者：reclusive (赞：1)

[更好的阅读体验](https://www.cnblogs.com/reclusive2007/p/17761858.html)

## 题目描述

小 Z 在草稿纸上列出了很多数，他觉得相邻两位数字差的绝对值不超过 $k$ 的整数特别奇特，称其为 $k$ 紧凑数。

现在小 Z 想知道 $[l,r]$ 内有多少个 $k$ 紧凑数，希望你帮帮他。

## 具体思路

首先，要求数的个数，自然想到数位 dp。

然后可以用容斥原理拆询问。

$$ans=\sum_{i=l}^r calc(i)=\sum_{i=1}^r calc(i)-\sum_{i=1}^{l-1} calc(i)$$

由于只有一组询问，我们可以采用记忆化搜索的方式来解决本题。

要让相邻两位数字差的绝对值不超过 $k$，我们只需要在每次搜索时记录上一位数字即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=20;
LL k,f[N][N],a[N];
LL dfs(int pos,int last,int lead,int limit){
	if(!pos)return 1;
	if(!limit&&!lead&&~f[pos][last])return f[pos][last];
	LL res=0,up=limit?a[pos]:9;
	for(int i=0;i<=up;i++){
		if(lead||abs(i-last)<=k){
			res+=dfs(pos-1,i,lead&&!i,limit&&i==up);
		}
	}
	if(!limit&&!lead)f[pos][last]=res;
	return res;
}
LL calc(LL x){
	int cnt=0;
	while(x){
		a[++cnt]=x%10;
		x/=10;
	}
	memset(f,-1,sizeof(f));
	return dfs(cnt,0,1,1);
}
int main(){
	LL l,r;scanf("%lld%lld%lld",&l,&r,&k);
	printf("%lld",calc(r)-calc(l-1));
	return 0;
} 
```

---

## 作者：tututu (赞：1)

应该是数位DP的，我按照自己思路做了（没学过数位DP）...

直接求l~r比较麻烦，于是可以求出0~r的再减0~l-1，用0而不用1可以方便处理。。

设f[i,j,1]表示前i位，末位是j，并且该前i位已经小于r的前i位的总情况数,f[i,j,2]表示该前i位等于r的前i位的总情况数。

i枚举第几位，从高位到个位，数字刚好相反，不是downto，j枚举当前的末位，t枚举前一位的末位，范围是j-k~j+k且在[0..9]中。

分3种情况

若当前位j小于r中的对应位则只可能用f[i,j,1]，前一位可以是任意。

若等于，1，2皆可，可以发现1才能到1，2才能到2，

若大于，必定更高位已经小于了，则也只有1种情况。

f[len]之和即为答案(包括0).

同理再做一遍0~l-1，减去，不要忘记数组清空。

```cpp
uses math;
var
  i,j,t,k,len:longint;
  sum,l,r,tt:int64;
  f:array[-1..22,-1..22,1..2] of int64;
function q(x:int64;i:longint):longint;//找出数x中，从高到低第i位的数
begin
  for i:=1 to len-i do x:=x div 10;
  exit(x mod 10);
end;
begin
  readln(l,r,k);
  tt:=r;
  while tt>0 do begin tt:=tt div 10; inc(len); end;//len记录长度
  for i:=0 to q(r,1)-1 do f[1,i,1]:=1;
  f[1,q(r,1),2]:=1;
  for i:=2 to len do
    for j:=0 to 9 do
      begin
        if j<q(r,i) then//情况1
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1]+f[i-1,t,2];
            end else
        if j=q(r,i) then//2
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1];
              f[i,j,2]:=f[i,j,2]+f[i-1,t,2];
            end else//3
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1];
            end;
        if j>k then inc(f[i,j,1]);
      end;
  //for i:=1 to len do for j:=0 to 9 do writeln(f[i,j,1],' ',f[i,j,2]);
  for i:=0 to 9 do
    sum:=sum+f[len,i,1]+f[len,i,2];
  dec(l);//同理，l需-1
  fillchar(f,sizeof(f),0);
  tt:=l;
  len:=0;
  while tt>0 do begin tt:=tt div 10; inc(len); end;
  for i:=0 to q(l,1)-1 do f[1,i,1]:=1;
  f[1,q(l,1),2]:=1;
  for i:=2 to len do
    for j:=0 to 9 do
      begin
        if j<q(l,i) then
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1]+f[i-1,t,2];
            end else
        if j=q(l,i) then
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1];
              f[i,j,2]:=f[i,j,2]+f[i-1,t,2];
            end else
          for t:=max(j-k,0) to min(j+k,9) do
            begin
              f[i,j,1]:=f[i,j,1]+f[i-1,t,1];
            end;
        if j>k then inc(f[i,j,1]);
      end;
  for i:=0 to 9 do
    sum:=sum-f[len,i,1]-f[len,i,2];
  if l=0 then dec(sum);
  write(sum);
end.
```

---

## 作者：coding_goat (赞：0)

数位 dp 喵。

先将问题转换为 $[1,r]$ 中 $k$ 紧凑数的个数减去 $[1,l-1]$ 中 $k$ 紧凑数的个数。

设 $f_{idx,lim,ze,lst}$ 分别表示数字的第 $idx$ 位，是否前面的数都为最大值，是否有前导 $0$，上一个数是什么。

要使得下一位满足条件，要么是这个数的第一位，要么当前的数字 $i$ 满足 $|i-lst|\le k$。

代码见下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define mem(aqwqawa,bqwqawa) memset((aqwqawa),(bqwqawa),sizeof(aqwqawa))
#define m0(aqwqawa) memset((aqwqawa),0,sizeof(aqwqawa))
#define lb(xqwqawa) ((xqwqawa)&-(xqwqawa))
#define lc(xqwqawa) ((xqwqawa)<<1)
#define rc(xqwqawa) (((xqwqawa)<<1)|1)
#define pb(Gqwqawa,xqwqawa) (Gqwqawa).push_back((xqwqawa))
#define For(Aqwqawa,Bqwqawa,Cqwqawa) for(int Aqwqawa=(Bqwqawa);Aqwqawa<=(Cqwqawa);Aqwqawa++)
#define For1(Aqwqawa,Nqwqawa) for(int Aqwqawa=1;Aqwqawa<=(Nqwqawa);Aqwqawa++)
#define foR(Aqwqawa,Bqwqawa,Cqwqawa) for(int Aqwqawa=(Bqwqawa);Aqwqawa>=(Cqwqawa);Aqwqawa--)
#define foR1(Aqwqawa,Nqwqawa) for(int Aqwqawa=(Nqwqawa);Aqwqawa;Aqwqawa--)
#define in1(Aqwqawa) Aqwqawa=read();
#define in2(Aqwqawa,Bqwqawa) Aqwqawa=read(); Bqwqawa=read();
#define in3(Aqwqawa,Bqwqawa,Cqwqawa) Aqwqawa=read(); Bqwqawa=read(); Cqwqawa=read();
#define inn(Aqwqawa,Nqwqawa) For1(Iqwqawa,Nqwqawa) Aqwqawa[Iqwqawa]=read();

#define ll long long
using namespace std;
inline int read(){
	int xx=0;int f=1;
	char c = getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f = -1;
		c = getchar();
	}
	while(c>='0'&&c<='9'){
		xx = (xx<<1)+(xx<<3)+(c^48);
		c = getchar();
	}
	return xx*f;
}
#define maxn 200050
int x,y,k;
int f[20][2][2][10];
int num[20],top;
int dfs(int idx,int lim,int ze,int lst){

	if(!idx) return 1;
	if(f[idx][lim][ze][lst]!=-1) {
//		puts("IAKIOI");
		return f[idx][lim][ze][lst];
	}
	int res=0;
	For(i,0,9){
		if((!lim)||(i<=num[idx])||top==1){
			if(ze||abs(i-lst)<=k) 
				res+=dfs(idx-1,((i==num[idx])&lim),((i==0)&ze),i);
		}
	}
//	cout<<num[idx]<<' '<<idx<<' '<<lim<<' '<<ze<<' '<<lst<<'\n';
//	cout<<"res="<<res<<'\n';
	f[idx][lim][ze][lst]=res;
	return res;
}
int solve(int X){
//	puts("\n");
	mem(f,-1);
	m0(num);
	top=0;
	while(X){
		num[++top]=X%10;
		X/=10;
	}
//	foR1(i,top) cout<<num[i];
//	puts("");
	if(top==1) return num[1]+1;
	return dfs(top,1,1,0);
}
signed main(){
	in3(x,y,k);
//	cout<<solve(y)<<' '<<solve(x-1)<<'\n';
	cout<<solve(y)-solve(x-1);
	return 0;
}
/*
10 20 1
*/
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2188)

# 前置知识

[数位 DP](https://oi-wiki.org/dp/number/) | [记忆化搜索](https://oi-wiki.org/dp/memo/)

# 解法

基础数位 DP，与 [luogu P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 类似，记录当前位置、上一位填的数码，接着记忆化搜索即可。

需要注意的是有前导零时，此时不需要管相邻两位数字差的绝对值不超过 $k$ 的限制。 

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
ll a[20],f[20][20];
ll divide(ll n,ll a[])
{
	ll len=0;
	while(n)
	{
		len++;
		a[len]=n%10;
		n/=10;
	}
	return len;
}
ll dfs(ll pos,ll pre,ll lead,ll limit,ll k)
{
	if(pos<=0)
	{
		return 1;
	}
	if(f[pos][pre]!=-1&&lead==0&&limit==0)
	{
		return f[pos][pre];
	}
	ll ans=0,maxx=(limit==0)?9:a[pos],i;
	for(i=0;i<=maxx;i++)
	{
		if(lead==1||abs(pre-i)<=k)
		{
			ans+=dfs(pos-1,i,(i==0)*lead,(i==maxx)*limit,k);	
		}
	}
	return (lead==0&&limit==0)?f[pos][pre]=ans:ans;
}
ll ask(ll n,ll k)
{
	ll len=divide(n,a);
	return dfs(len,0,1,1,k);
}
int main()
{
	ll l,r,k;
	cin>>l>>r>>k;
	memset(f,-1,sizeof(f));
	cout<<ask(r,k)-ask(l-1,k)<<endl;
	return 0;
}
```

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2188)
## 思路
数位 $\verb!DP!$ 板子。

接下来手把手教各位读者写数位 $\verb!DP!$。

首先，我们通常把数位 $\verb!DP!$ 写成 $\verb!DFS!$ 的样子，这样比较易于理解，在这个 $\verb!DFS!$ 中有 $5$ 个参数：$pos,tag,la,k,zero$，分别表示当前枚举到第几位，当前是否贴着上界，上一个填的数是什么，当前的 $k$ 以及是否为前导零。

接下来就是第一部分代码：

```cpp
if (pos<0) return 1;//如果枚举完了，说明当前有一个数符合条件，return 1。
if (!tag && !zero && f[pos][la]) return f[pos][la];//如果当前没有限制条件而且当前状态已经搜过了，那么直接 return 即可。
```

然后，我们就要处理上界的问题了，第二部分代码：

```cpp
int end=tag?p[pos]:9;
```

如果我们当前贴着上界，我们最多只能填当前这个位置上的数，不然可以填到 $9$。

然后，就直接枚举：

```cpp
for (int i=0;i<=end;++i)
if (zero || abs(la-i)<=k) res+=dfs(pos-1,tag&(i==end),i,k,zero&(i==0));//如果当前是前导零，说明没有数填过，自然是符合条件的，而如果当前的数本来的差就小于等于 k，自然也符合条件。
```
接下来，再加一个记忆化操作：

```cpp
if (!tag && !zero) f[pos][la]=res;
```

这样，一道数位 $\verb!DP!$ 模板题就做完了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int>p;int f[2010][2010];
inline int dfs(int pos,int tag,int la,int k,int zero){
	if (pos<0) return 1;
	if (!tag && !zero && f[pos][la]) return f[pos][la];
    int end=tag?p[pos]:9;int res=0;
    for (int i=0;i<=end;++i)
        if (zero || abs(la-i)<=k) res+=dfs(pos-1,tag&(i==end),i,k,zero&(i==0));
	if (!tag && !zero) f[pos][la]=res;
	return res;
}
inline int solve(int x,int k){
	memset(f,0,sizeof(f));
	p.clear();
	while (x) p.push_back(x%10),x/=10;
	return dfs(p.size()-1,1,0,k,1);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int l,r,k;cin>>l>>r>>k;
	cout<<solve(r,k)-solve(l-1,k)<<'\n';
	return 0;
}
```


---


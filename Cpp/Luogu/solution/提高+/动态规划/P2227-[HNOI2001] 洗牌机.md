# [HNOI2001] 洗牌机

## 题目描述

剀剀和凡凡有 $n$ 张牌（依次标号为 $1,2,\ldots,n$）和一台洗牌机。假设 $n$ 是奇数。洗牌机的功能是进行如下的操作：对所有位置 $i(1\le i\le n)$，如果位置 $i$ 上的牌是 $j$，而且位置 $j$ 上的牌是 $k$，那么通过洗牌机后位置 $i$ 上的牌将是 $k$。

剀剀首先写下数值 $1,2,\ldots,n$ 的一个随机排列：$a_1,a_2,\ldots,a_n$。然后他这样来排列牌的顺序：位置 $a_i$ 放置牌 $a_{i+1}$, （对于 $1\le i\le n-1$），而 $a_n$ 放置牌 $a_1$。这样排列后，牌的顺序就为 $x_1,x_2,\ldots ,x_n$。然后，他把这种顺序排列的牌放入洗牌机洗牌 $s$ 次，得到牌的顺序为 $p_1,p_2,\ldots,p_n$。现在，剀剀把牌的最后顺序和洗牌次数告诉凡凡，要凡凡猜出牌的最初顺序 $x_1,x_2,\ldots,x_n$。


## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1\le n,s\le 10^3$。

数据保证，从 $i=1$ 开始，设第 $i$ 张牌上数是 $j$，则赋值 $i=j$ 后继续此操作，最终会遍历所有牌。

## 样例 #1

### 输入

```
5 2          
4 1 5 3 2
```

### 输出

```
2 5 4 1 3```

# 题解

## 作者：distantlight (赞：9)

《潘震皓：置换群快速幂运算研究与探讨》（2005年国集论文）里面有详细说这题。本质上上一个置换开方问题，每洗牌一次，相当于把置换平方以下，总共2^s次，所以逆运算就是把置换p1..pn开2^s次方

由于n是奇数，gcd(2^s,n)=1，并且根据题意，这个置换是一个轮换（只有一个循环节），根据论文所属，在此情况下置换开方有唯一解，并且可以在O(n)搞定。大致思路如下：

1.将p写成轮换形式，设为a1..an
2.倒推k=2^s次方根的轮换b1..bn，根据论文，有b[1+(i-1)*k]=a[i]（下标都在模n的意义下）
3.由b再倒推出置换x

关键的第二步，原文有图，洛谷传图实在是不方便。。自己去找原文吧。。

附代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1009;
int n,s,x[N],p[N],A[N],B[N],z=1;
int main(){
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n;i++) scanf("%d",&p[i]);
    for (int i=1,j=1;i<=n;i++,j=p[j]) A[i]=p[j];
    for (int i=1;i<=s;i++) z=(z*2)%n;
    for (int i=1,j=1;i<=n;i++,j=(j+z-1)%n+1) B[j]=A[i];
    for (int i=1;i<=n;i++) x[B[i]]=B[i%n+1];
    for (int i=1;i<=n;i++) cout<<x[i]<<" ";
    return 0;
}
```


---

## 作者：楚泫 (赞：7)

# 纯枚举.（qwq）
- 最开始读错了题意，以为是正着推。于是写完后题解对了（特殊情况），交上后30分重新读题才发现不对QAQ
- 输了几组数据打表找规律，于是发现：
	### 逆推次数=周期数-正推次数（%周期数）

------------

#### ~~由于逆推过程复杂，蒟蒻实在想不出qaq……~~思路如下：
-  洗牌过程存在周期数，因此先正推得出周期数 __ （本题数据不考虑洗牌到一定次数后一直相同，如“12345”这样的情况） __ 
- 于是可求出逆推次数
- 根据逆推的次数正推一下
- 更新，输出！
### 代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,s,a[1005],b[1005],c[1005],cnt,z;
int main(){
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++){	//读入 
        scanf("%d",&a[i]);
        b[i]=a[i];	//令b数组与a相同，用于修改判断 
    }			
    for(z=1;z<=n;z++){		//正推（洗牌），推导出第几次时和a相同，得到的z即为周期数 
    	for(int j=1;j<=n;j++){
            c[j]=b[b[j]];	//c数组为b正推（洗牌）出的下一个 
        }
        for(cnt=1;cnt<=n;cnt++){
        	if(a[cnt]!=c[cnt]) break;	//一旦不同退出循环 
		}
		if(cnt==n+1) break;		//判断是否与a相同，相同则退出循环 
        for(int j=1;j<=n;j++){
            b[j]=c[j];	//让b数组更新为当前数组 
        }
	}
	s=z-s%z;	//重点！倒推次数即周期数-正推次数（%周期） 
    while(s--){		//洗牌 
    	for(int j=1;j<=n;j++) b[j]=a[a[j]];
    	for(int j=1;j<=n;j++) a[j]=b[j];
	}    
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";	//输出 
}
```

---

## 作者：WYXkk (赞：6)

看一眼题，这题大概就是传说中的「【模板】置换开根」了吧（虽然数据范围很小……）。

可以发现，题目中的「洗牌」操作，其实就是对置换平方。

然后，众所周知，对于一个环长度为 $n$ 的置换 $A$，$A^n=I$，其中 $I$ 为单位置换。

于是 $\sqrt{A}=\sqrt{A^{n+1}}=A^{(n+1)/2}$，因此做 $k$ 遍置换快速幂即可。

时间复杂度 $O(kn\log n)$。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1005;
int n,k;
struct zh{int a[N];int& operator[](int x){return a[x];}};
zh operator*(zh x,zh y){zh z;F(i,1,n) z[i]=x[y[i]];return z;}
zh I(){zh a;F(i,1,n) a[i]=i;return a;}
zh qp(zh x,int k){if(!k) return I();zh w=qp(x,k>>1);w=w*w;return k&1?w*x:w;}
int main()
{
	zh x;
	rd(n);rd(k);
	F(i,1,n) rd(x[i]);
	F(i,1,k) x=qp(x,(n+1)/2);
	F(i,1,n) printf("%d ",x[i]);
	return 0;
}
```

---

## 作者：xh2010 (赞：4)

这是一道和数学有关的题，准确来说是组合数学或者图论。

先考虑洗牌一次的情况。我们可以这样做，设第i号位置上的数a[i]，则将i与a[i]连一条有向边，这样就构成了一个n个顶点n条边的图。

第一种方案是枚举上一次洗牌的情况，即设上一次i号位置上为b[i]，通过枚举b[1]来逐一判断（如果b[1]是确定的，那么其他的也可以随之确定）。复杂度为O(n\*n)，加上s次判断，复杂度总共为O(n\*n\*s)，完美超时。


下面我们来进一步分析题目，还是设上一次i号位置上是b[i]，模拟一下上一次的洗牌，并将i与b[i]连一条有向边，可以得到下面这张图：

1-->b[1]-->4-->b[4]-->3-->b[3]-->5-->b[5]-->2-->b[2]-->1，其中第一个1和最后一个1意义相同。这一共有十个顶点，每个数字出现两次，因此这是一个周期出现了两次，故我们可得到b[1]=5,b[2]=3,b[3]=1,b[4]=2,b[5]=4。

设t=(n-1)/2。那么第i位置上的牌为，a[i]的下一个的下一个的……（共有t个）。我们可以用一维数组记录下这张图和顶点在数组中位置，这种操作时间复杂度为O(n)，那么总复杂度为O(s\*n)。


我的语文可能比较差，请各位见谅，下面附上我丑陋的代码：


        
            
        
    
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<stack>
#include<queue>
#include<map>
#include<list>
#include<functional>
#include<vector>
#include<set>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<algorithm>
#define ll long long
using namespace std;
int n,s;
int nxt[1010],a[1010],b[1010],c[1010],ps[1010];
int main()
{
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for (int i=1;i<=s;i++)
    {
        memset(nxt,0,sizeof(nxt));
        memset(b,0,sizeof(b));
        memset(c,0,sizeof(c));
        memset(ps,0,sizeof(ps));
        for (int j=1;j<=n;j++)
            nxt[j]=a[j];
        int j=1;
        int k=1;
        c[j]=k;
        ps[k]=j;
        while (j<n)
        {
            k=nxt[k];
            j++;
            c[j]=k;
            ps[k]=j;
        }
        int t=(n-1)/2;
        for (int j=1;j<=n;j++)
            b[j]=c[(ps[a[j]]+t-1)%n+1];
        for (int j=1;j<=n;j++)
            a[j]=b[j];
    }
    for (int i=1;i<=n;i++)
        printf("%d ",a[i]);
}
```

---

## 作者：AzureHair (赞：2)

首先我没有剩下几篇题解的大佬的思维强，所以我就用了最好理解的方法做了出来（虽然也借鉴了题解，但是有些难懂所以打算再来写一篇题解）

简明题干：

每次将一个序列中的 $a_i$ 置换为 $a_{a_{i}}$，进行 $s$ 次该操作，现给出 $s$ 次操作后的序列求原始序列。

在这里容易发现如果逆推根本时间爆炸，枚举每一种情况去验证要 $n!$ 直接炸裂。那么正难则反，考虑顺推。经过对样例的枚举我们发现了重要现象。

```cpp
4 1 5 3 2

3 4 2 5 1

2 5 4 1 3

5 3 1 2 4

4 1 5 3 2
```
转了一圈又转回来了！

于是这道题就迎刃而解了。你逆推 $s$ 步就相当于顺推。

```cpp
cnt-s%cnt
```
这么多步，其中 $s$ 是逆推的步数，$cnt$ 是周期步数。然后暴力更新即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1010],b[1010],c[1010],s,cnt=0;
int main()
{
	cin>>n>>s;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		cnt++;//求周期步数 
		bool flag=1;
		for(int j=1;j<=n;j++)
		{
			c[j]=b[b[j]];
			if(c[j]!=a[j])
			{
				flag=0;
			}
		}
		if(flag) break;
		for(int j=1;j<=n;j++)
		{
			b[j]=c[j];
		}
	}
	s=cnt-s%cnt;//计算顺推次数 
	for(int i=1;i<=n;i++)
	{
		b[i]=a[i];
	}
	for(int i=1;i<=s;i++)
	{
		for(int j=1;j<=n;j++)
		{
			c[j]=b[b[j]];//暴算出奇迹 
		}
		for(int j=1;j<=n;j++)
		{
			b[j]=c[j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<b[i]<<" ";
	}
	return 0;
} 
```
希望大家早日AC！

---

## 作者：q1847497680 (赞：1)

推荐完成的前置题目：

[ABC367E](https://www.luogu.com.cn/problem/AT_abc367_e)
、[ABC377E](https://www.luogu.com.cn/problem/AT_abc377_e)

解法 $1$，置换开方 $O(kn)$：

对于一个置换 $P$，执行一次题目中的洗牌操作，$P$ 会变成 $P^2$。题目中一共执行了 $k$ 次洗牌操作，初始的置换变成了 $P^{2^k}$。也就是题目给你 $P^{2^k}$，要你求出初始的置换 $P$。

我们知道对于一个置换 $P$,$P^n = I,(I 是单位置换，就是 (1,2,3,\dots,n))$。所以 $P^{n+1} = P$。

那么对于 $S = P^2$，要还原成 $P$，就是对 $S$ 开根号，$\sqrt {S} = \sqrt {S^{n+1}} = {S^{\frac{n+1}{2}}} = P$。$n$ 是奇数，所以 $\frac{n+1}{2}$ 总是能被整除，一次开根号的时间复杂度是 $O(n)$ 或者 $ O(nlogn)$，具体取决于你的写法。

那我们对 $P^{2^k}$ 做 $k$ 次开根操作，就能得到初始的置换 $P$。

代码放最后。

解法 $2$，找规律 $O(n)$：

题目中的原来的置换 $P = (2,5,4,1,3)$,对应的轮换是 $(1\space2\space5\space3\space4)$(看不习惯可以理解为 `1->2->5->3->4->1`)。在这个序列上走 $2^2$ 次就是题目给我们的 $S = (4,1,5,3,2)$。

那如果我们求出了轮换，就能把原来的置换还原回来了：
比如说 $S$ 的第一个元素 $4$，就是往回退 $2^2 - 1 = 3$ 得到 $2$，其它元素同理（为什么要减 $1$? 不减 $1$ 就是单位置换了）。

所以接下来的任务就是根据 $S$ 求出轮换。

$S = (4,1,5,3,2)$

根据 $S$ 我们可以得到，在原来的轮换里：单位置换的 $1$ 走了 $2^2$ 步得到 $4$, $2$ 走了 $2^2$ 步得到 $1$ , $3$ 走了 $2^2$ 步得到 $5$，$4$ 走了 $2^2$ 步得到 $3$，$5$ 走了 $2^2$ 步得到 $2$。

重排一下就是 `1-(4)->4-(4)->3-(4)->5-(4)->2`。根据这个就可以推出原来的轮换了，具体实现的话参考后面的代码。

还有就是，这样做是正确的前提是轮换里走的步数：$0,2^k,2 \times 2^k,3\times 2^k,\dots,(n-1)\times 2^k$ 在模 $n$ 下必须是不同的，因为 $n$ 是奇数，$\gcd(2^k,n) = 1$，所以这个前提成立。

```
解法1:O(nk)
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 10;
int ans[N],vis[N];
int a[N];
void qkp(int a[],int n) {
	for(int i=1;i<=n;++i) vis[i] = 0;
	for(int i=1;i<=n;++i) {
		if(!vis[i]) {
	    	vector<int> v;
	        int j = i;
	        while(!vis[j]) {
	            vis[j] = 1;
	            v.push_back(j);
  				j = a[j];
	        }
	        int p = v.size();
	        int step = n + 1 >> 1;
	        for(int j=0;j<p;++j) {
	            int pos = (j + step) % p;
	            ans[v[j]] = v[pos];
	        }
	    }
	}
	for(int i=1;i<=n;++i) a[i] = ans[i];
}
signed main() {
	int n,k;
	cin >> n >> k;
	for(int i=1;i<=n;++i) cin >> a[i];
	for(int i=1;i<=k;++i) qkp(a,n);
	for(int i=1;i<=n;++i) cout << a[i] << " ";
    return 0;
}
解法2:O(n)
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 10;
int ans[N],pos[N];
int a[N];
int qkp(int a,int b,int p) {
	int res = 1;
	for(;b;b>>=1) {
		if(b&1) res = res * a % p;
		a = a * a % p;
	}
	return res;
}
signed main() {
	int n,k;
	cin >> n >> k;
	for(int i=1;i<=n;++i) cin >> a[i];
	int step = qkp(2,k,n);
	vector<int> v(n);
	v[0] = 1; pos[1] = 0; // v是轮换
	for(int i=1,j=0,k=a[1];i<n;++i) {
		int nx = (j + step) % n;  // 从0开始，每次走step步
		v[nx] = k; pos[k] = nx;
		j = nx; k = a[k];
	}
	for(int i=1;i<=n;++i) {
		int p = pos[a[i]];  // 第i个元素在轮换里的位置
		ans[i] = v[(p-(step-1)+n) % n]; // 往前走step-1步
	}
	for(int i=1;i<=n;++i) {
		cout << ans[i] << " ";
	}
    return 0;
}
```

---

## 作者：liu_ruoyu (赞：0)

纯枚举的解法一开始误解了题意，原本以为是正向推进。通过几组数据的规律发现，逆推次数等于周期数减去正推次数取模周期数。基于这个发现，我进行了以下的实现：

1. 正推得出周期数。
2. 根据周期数，计算逆推次数。
3. 正推到达逆推次数的状态并输出结果。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,s,a[1005],b[1005],c[1005],cnt,z;
int main(){
    scanf("%d%d",&n,&s);    // 输入n和s
    for(int i=1;i<=n;i++){  // 初始化a数组和b数组
        scanf("%d",&a[i]);
        b[i]=a[i];          // b数组用来存储中间结果
    }
    for(z=1;z<=n;z++){      // 洗牌过程，推导出周期数
        for(int j=1;j<=n;j++) c[j]=b[b[j]];  // 计算b的下一个状态存入c
        for(cnt=1;cnt<=n;cnt++) if(a[cnt]!=c[cnt]) break;  // 判断是否与a相同
        if(cnt==n+1) break;  // 如果完全相同，结束
        for(int j=1;j<=n;j++) b[j]=c[j];  // 更新b
    }
    s=z-s%z;  // 计算逆推次数
    while(s--){  // 进行逆推
        for(int j=1;j<=n;j++) b[j]=a[a[j]];
        for(int j=1;j<=n;j++) a[j]=b[j];
    }
    for(int i=1;i<=n;i++) cout<<a[i]<<" ";  // 输出结果
}
```

---

## 作者：chenruikai (赞：0)

### 题意
给定最初序列 $x_1,x_2,\dots,x_n$，经过 $s$ 次变换后得最终序列 $p_1,p_2,\dots,p_n$，求最初序列。
### 题解
看到各位大佬置换开根等的高级题解，真真的想看又看不懂，就搬出了自己的思路。

本提重点：**手推**。

手推样例，最后一次洗牌前的序列可以推出。根据手推的过程，我们可以发现，只要确定上一序列中的一个数，就可以推出整个序列了。根据题目最后“数据保证”~~题快写完我才看到~~，可知，应枚举第一个数字。

在刚刚得到的序列基础之上，再往前推一次（相当于最终序列反着洗牌两次），可以直接得出答案。由此，我们貌似已经得到人工解法了：通过枚举上一序列第一个数，一层层往前推，推 $s$ 次，即为答案。

在考虑打代码，又通过“数据保证”，可以发现题目中给了个很是妙哉的方法去推序列~~由于我之前没看到，我是用图论中求欧拉回环的方法去解决的，荣获80pts~~。详见代码。

变量名与题目不符，谅解。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define unclear -1
#define debug 0
#define puterr(...) if(debug)printf(__VA_ARGS__)
#define debugpart if(debug)
int arr_len = 0;
int num[1000] = {0};
int res[1000] = {0};
int times = 0;
bool compute_res_sub()
{
    int pos = 0;
    int pos_write = num[pos];
    pos = res[pos] - 1;
    for(;res[pos] == 0;pos = res[pos] - 1)
    {
        res[pos] = pos_write;
        pos_write = num[pos];
    }
    if(res[pos] == pos_write)
        return true;
    else
    {
        for(int i = 1;i < arr_len;i++)
            res[i] = 0;
        return false;
    }
}
void compute_res()
{
    for(res[0] = 1;res[0] <= arr_len;res[0]++)
        if(compute_res_sub() == true)
            break;
}
int main()
{
    cin >> arr_len >> times;
    for(int i = 0;i < arr_len;i++)
        cin >> num[i];
    for(int i = 0;i < times;i++)
    {
        memset(res , 0 , sizeof(int) * arr_len);
        compute_res();
        swap(res , num);
    }
    for(int i = 0;i < arr_len;i++)
        cout << num[i] << " ";
    puts("");
    // debugpart
    // {
    //     res[0] = 5;
    //     cout << compute_res_sub(0) << endl;
    //     for(int i = 0;i < arr_len;i++)
    //         cout << res[i] << " ";
    //     puts("");
    // }
    return 0;
}
```
注意，该代码方法简单，而且粗暴，复杂度毕竟没有大佬的低。

玥玥月月如今朝。

---


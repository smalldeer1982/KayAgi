# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# 题解

## 作者：panyf (赞：17)

本人太弱，~~不会DP~~，于是就有了这个**只用DFS**的题解

首先，我们会想到暴力做法，时间复杂度约为O(C(n,r)C(m,c)rc)，可以得到60分，代码就不提供了

暴力做法之所以慢，是因为进行了重复的计算，而且缺少剪枝。

矩阵的分值包含两部分，**一是同一行两个数差的绝对值，二是同一列两个数差的绝对值**。如果我们先搜索行再搜索列，第二种分值就可以在搜索行时计算，而第一种分值在搜索列时边搜索边计算。

我们还可以加上搜索常用的最优性剪枝，就是当此时矩阵的分值已经大于等于当前最优答案，那么就退出搜索

代码如下：
```cpp
void dfsl(ci&x,ci&y,ci&z){//const类型传参，卡常数必备，x为上一列，y为已搜索的列数，z为当前答案
	if(y==c){
		s=z;//更新答案
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;//register类型卡常数，en为搜索终止位置
	for(;i<en;++i){
		zz=z+p[i];//p数组存储第二种分值
		if(zz>=s)continue;//剪枝
		if(x!=0){
			for(j=0;j<r;++j){
				zz+=abs(v[e[j]][i]-v[e[j]][x]);//累加第一种分值
			}
		}
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){//搜索行
	if(y==r){
		dfsl(0,0,0);//搜完则搜索列
		return;
	}
	register int i=x+1,en=y+n-r+2,j,q[19];//q数组必须在dfsh函数内定义，用于回溯
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				q[j]=abs(v[x][j]-v[i][j]),p[j]+=q[j];
			}
		}
		e[y]=i,dfsh(i,y+1);//e数组保存取出的行
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=q[j];//回溯
		}
	}
}
```
80分，超时，需要继续优化

我们会发现abs进行调用的次数很多，因此可以预处理所有分值，减少重复计算

代码如下：
```cpp
for(i=1;i<n;++i){//预处理第二种分值
		for(j=i+1;j<=n;++j){
			for(k=1;k<=m;++k){
				g[i][j][k]=abs(v[i][k]-v[j][k]);
			}
		}
	}
	for(i=1;i<m;++i){//预处理第一种分值
		for(j=i+1;j<=m;++j){
			for(k=1;k<=n;++k){
				h[i][j][k]=abs(v[k][i]-v[k][j]);
			}
		}
	}
```
同时相应修改DFS函数：
```cpp
void dfsl(ci&x,ci&y,ci&z){
	if(y==c){
		s=z;
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;
	for(;i<en;++i){
		zz=z+p[i];
		if(zz>=s)continue;
		if(x!=0){
			for(j=0;j<r;++j){
				zz+=h[x][i][e[j]];//累加第一种分值
			}
		}
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){
	if(y==r){
		dfsl(0,0,0);
		return;
	}
	register int i=x+1,en=y+n-r+2,j;
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				p[j]+=g[x][i][j];//第二种分值
			}
		}
		e[y]=i,dfsh(i,y+1);
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=g[x][i][j];//回溯
		}
	}
}
```
依然是80分，但是速度相比之前略快，需要继续剪枝

我们可以考虑将累加第一种分值在dfsh函数中进行，因为dfsh调用次数少于dfsl，因此可以减少重复计算

代码如下：
```cpp
void dfsl(ci&x,ci&y,ci&z){
	if(y==c){
		s=z;
		return;
	}
	register int i=x+1,en=y+m-c+2,j,zz;
	for(;i<en;++i){
		zz=z+p[i]+w[x][i];//可以一次性求出两种分值之和
		if(zz<s)dfsl(i,y+1,zz);
	}
}
void dfsh(ci&x,ci&y){
	if(y==r){
		dfsl(0,0,0);
		return;
	}
	register int i=x+1,en=y+n-r+2,j,k;
	for(;i<en;++i){
		if(x!=0){
			for(j=1;j<=m;++j){
				p[j]+=g[x][i][j];
			}
		}
		for(j=1;j<m;++j){
			for(k=j+1;k<=m;++k){
				w[j][k]+=h[j][k][i];//用w数组保存第一种分值
			}
		}
		e[y]=i,dfsh(i,y+1);
		if(x!=0){
			for(j=1;j<=m;++j)p[j]-=g[x][i][j];
		}
		for(j=1;j<m;++j){
			for(k=j+1;k<=m;++k){
				w[j][k]-=h[j][k][i];//注意w数组也要回溯
			}
		}
	}
}
```
这样就可以得到[100分](https://www.luogu.com.cn/record/24211528)了

---

## 作者：lizh (赞：6)

题目要求在n行m列中选择r行c列，交叉部分构成一个新矩阵。

暴力的做法就是枚举列和行，共有$C_n^r*C_m^c$种情况，计算统计答案。

然后可以dp进行优化，在枚举完行和列的其中一个变量后，剩下的另一个变量就不需要继续暴力枚举，而可以采用dp优化的方式进行统计最优解。

假设我们先dfs来枚举每一种列的选择方式，然后我们设一个变量$f[i][j]$表示前$i$行选了$j$列的最优解。

转移方程$f[i][j]=min(f[i][j],f[k][j-1]+tot)$，其中$k∈[1,i-1]$，$tot$表示选了第$i$行且上一行是第$k$行时对答案的贡献值.

然后是$tot$的计算方法，我们在dfs列时，对枚举到的列打上标记，之后在计算中,对有标记的地方进行计算就行。

初始化时要注意的是，i要从2开始枚举，否则k无法进入循环，因此初始化时我们要对全部$f[i][1]$进行初始化，而因$f[i][1]$对答案无影响，我们直接初始化为第$i$行的横向相邻数的总值。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

int lr[100],f[100][100],a[100][100],d[100][100];
int n,m,r,c,ans=1e9;

void search(int x,int num)
{
	if(num==c)
	{
		for(int i=0;i<=17;i++)
		{
			for(int j=0;j<=17;j++)
			{
				d[i][j]=1e9;
			}
		}
		memset(f,0x3f,sizeof(f));
		for(int i=0;i<=n;i++) f[i][0]=0;
		for(int i=1;i<=n;i++)
		{
			f[i][1]=0;
			int last=0;
			for(int j=1;j<=m;j++)
			{
				if(lr[j])
				{
					if(last)
					{
						f[i][1]+=abs(a[i][j]-last);
					}
					last=a[i][j];
				}
			}
		}
		for(int j=2;j<=r;j++)
		{
			for(int i=j;i<=n;i++)
			{
				for(int k=1;k<i;k++)
				{
					int tot=0,last=0;
					for(int l=1;l<=m;l++)
					{
						if(lr[l])
						{
							tot+=abs(a[i][l]-a[k][l]);
							if(last)
							{
								tot+=abs(a[i][l]-last);
								last=a[i][l];
							}
							else last=a[i][l];
						}
					}
					f[i][j]=min(f[i][j],f[k][j-1]+tot);
//					cout<<i<<" "<<j<<" "<<f[i][j]<<" "<<tot<<endl;
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			ans=min(ans,f[i][r]);
		}
//		cout<<ans<<endl;
		return ;
	}
	for(int i=x+1;i<=m;i++)
	{
		lr[i]=1;
		search(i,num+1);
		lr[i]=0;
	}
	return ;
}

int main()
{
//	freopen("submatrix.in","r",stdin);
//	freopen("submatrix.out","w",stdout);
	scanf("%d%d%d%d",&n,&m,&r,&c);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	search(0,0);
	cout<<ans;
	return 0;
 }
```


---

## 作者：RikoHere (赞：4)

在矩阵中求解最优情况，其中$n \leq 16$

假设现在已经得到保留的行与列的编号，递推矩阵分值的复杂度是$O(n^2)$遍历一遍就ok

50pts 假设行列全部枚举全排列的话，枚举次数在最坏情况下是$(C_{12}^6)^2=924^2$,在加上求分值的复杂度则总复杂度还是勉强可以接受的?

直接看100pts解法,仍然枚举一次行的全排列，复杂度是$O(C_m^c)$，这个时候我们得到的其实是一行数列，数列上的每个数有选择和不选择两种状态，选择每个数会增加分值，分别是：

 - 自身的分数(该列上下数字差值绝对值和)
 
 - 相对左侧(右侧)的分数,左侧和右侧的选择都会影响这种相对分数
 
 那么提前预处理出数列上每个数两两之间相对的分数和自身的分数，因为要枚举$m$的原因，所以复杂度是$O(n^3)$
 
 进行dp，设$f[i][l]$为已选择到数列上第$i$个数，已选择$l$个数的最大值，很明显$f[i][l]=min(f[k][l-1]+sum[k][i])$ 其中$k \subseteq[1,i-1]$，不需要太多优化，只要枚举$i,k,l$就可以在$O(n^3)$之内解决问题，该种方法总复杂度$O(C_m^c n^3)$可以通过$n=16$的数据


```
//2019/7/19->Riko->AtNCU->luoguP2258
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;

bool digit (int ch) { return (ch <= '9' and ch >= '0');}
inline int in () {
    int x = 0, ch = getchar(), base = 1;
    while (!digit(ch)) {
    	if (base == '-') base = -1;
        ch = getchar();
    }
    while (digit(ch)) x = x*10+ch-'0', ch = getchar();
    return x*base;
}
template <typename T> inline void smin (T& x, T y) { if (x > y) x = y;}
inline int abs (int x) { return (x < 0) ? -x : x;}

const int N = 24;
int n, m, r, c, ans, cnt;
int f[N][N], a[N][N], sum[N][N], suml[N], bol[N];

void work () {
    memset(sum, 0, sizeof(sum));
    memset(suml, 0, sizeof(suml));
    memset(f, 0x3f, sizeof(f));
    for (int i = 1; i <= n; ++i) {
        for (int j = i+1; j <= n; ++j) {
            int seg = 0;
            for (int l = 1; l <= m; ++l) {
                if (bol[l]) seg += abs(a[i][l]-a[j][l]);
            }
            sum[i][j] = sum[j][i] = seg;
        }
        int last = 0;
        for (int l = 1; l <= m; ++l) {
            if (bol[l]) {
                if (last) suml[i] += abs(a[i][l]-last);
                last = a[i][l];
            }
        }
    }
    for (int i = 1; i <= n; ++i) { f[i][1] = suml[i];}
    for (int i = 1; i <= n; ++i) {
        for (int l = 2; l <= r; ++l) {
            int Min = f[0][0];
            for (int j = 1; j < i; ++j) {
                smin(Min, f[j][l-1]+sum[j][i]);
            }
            f[i][l] = Min+suml[i];
        }
    }
    for (int i = 1; i <= n; ++i) { smin(ans, f[i][r]);}
}
void dfs (int idx, int num) {
    if (num == c) {
        work();
        return;
    }
    for (int i = idx; i <= m; ++i) {
        bol[i] = true;
        dfs(i+1, num+1);
        bol[i] = false;
    }
}
void prepare () {
    n = in(); m = in();
    r = in(); c = in();
    ans = 999999999;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            a[i][j] = in();
        }
    }
    dfs(1, 0);
    printf("%d", ans);
} int main () { prepare();}
```


---

## 作者：Ian_NIE (赞：2)

## 0x00 闲话&前言

本人第三篇题解，但是前两篇都被我自己删掉了，就算是第一篇吧。

## 0x01 题目大意

给定一个矩阵，请选出 $r$ 行和 $c$ 列，这些东西的交点被选中，依次组成

**分数的定义：**

矩阵中每一对相邻元素之差的绝对值之和。

## 0x02 算法思路

对于“选出”这种问题，显然需要使用 dfs 算法。我们先使用 dfs 来选出从 $n$ 行中选出 $r$ 行，之后开始进行动态规划。 

经过 dfs，我们把选中的 $r$ 列存储在 $plan_i$ 里面。然后我们开始动态规划。现在，我们需要的是从 $m$ 列中选出 $c$ 列然后高效地求出答案。此时，一个简单的状态表示出现了。这时候，（**我的意思是，必须在选定了 $plan$ 中的这些元素的条件下**）用 $dp_{i, j}$ 表示对于前 $i$ 列，选中 $j$ 列的答案的值。

状态转移方程？我们先进行一个初始化，显然，当 $j = 1$ 的时候，答案就是第 $i$ 列行为 $plan_i$ 的元素组成的矩阵的结果。现在我们做一个设想，正向思考一下。我们已经得到了 $dp_{k, j - 1}$，这时候下一列可以安排在哪里？设问题结果为 $i$，显然 $k < i \le m$，此时答案为 $dp_{i, j}$。反过来我们就得到了我们的状态转移方程：

$$dp_{i, j} = \min\{dp_{k, \;j - 1} + cal_{i, \;k}, \;d-_{i, j}\}$$

其中，$cal$ 函数计算对出来 $i$ 一列比原来的答案多出来的部分，显然是由当前 $i$ 这一列相邻的元素之差的和，以及当前列 $i$ 与原来的列 $k$ 的元素相邻两个元素之差的和。

所以，最终的答案就是：

$$ANS = \max\{dp_{i,\; c}\}\;\;\;(c \le i \le m)$$

显然，只有在前 $c$ 行开始的时候，才有可能选出 $c$ 个元素。

## 0x03 部分代码实现

### 0x01 dfs 从 $n$ 行中选出 $r$ 行

这个很简单，注意按顺序从小到大，把选中的行的编号存入 $plan$。选中成功之后，进入 $calc$ 函数进行动态规划。

```cpp
void dfs(int x, int cnt)
{ // x表示当前元素，cnt表示已经选择了的元素个数
    if(cnt > r) return ;
    if(x == n + 1)
    {
        if(cnt == r)
            calc();
        return ;
    }
    plan[++cnt] = x, dfs(x + 1, cnt);
    plan[cnt--] = 0, dfs(x + 1, cnt); 
}
```

### 0x02 动态规划部分

首先，**多测清空**。接下来按照上文进行初始化 $dp_{i, 1}$。然后状态转移，最后求解答案 $ans$。$ans$ 是一个全局变量，直接就是我输出的答案，不需要进行多测清空。

```cpp
void calc()
{
	// 多测清空 
	memset(dp, 0x3f, sizeof dp);
    //初始化
    for(int i = 1; i <= m; i++)
    {
    	dp[i][1] = 0;
    	for(int j = 2; j <= r; j++)
    		dp[i][1] += abs(a[plan[j]][i] - a[plan[j - 1]][i]);
	}
	// 状态转移 
	for(int i = 2; i <= m; i++) // 对于前i列 
		for(int j = 2; j <= min(c, i); j++) // 选择j列，显然i>j 
			for(int k = j - 1; k < i; k++) // 这是状态转移用的前面一列 
				dp[i][j] = min(dp[k][j - 1] + cal(i, k), dp[i][j]); 
	// 求出答案 
	for(int i = c; i <= m; i++)
		ans = min(ans, dp[i][c]);
	return ;
}
```

### 0x03 $cal$ 函数

这个简单，包括当前 $i$ 这一列相邻的元素之差的和，以及当前列 $i$ 与原来的列 $k$ 的元素相邻两个元素之差的和。

```cpp
int cal(int x, int y)
{ // x是当前列，y是状态转移用的前面的一列
	int res = 0;
	for(int i = 2; i <= r; i++) // x列内部的答案
		res += abs(a[plan[i]][x] - a[plan[i - 1]][x]);
	for(int i = 1; i <= r; i++) // 两列之间的部分
		res += abs(a[plan[i]][x] - a[plan[i]][y]);
	return res;
}
```

## 0x04 [整体代码](https://www.luogu.com.cn/paste/540tq0pu)

一个整合而已，具体解释在前面的部分。

## 0x05 后记

笔者水平不高，有错误请见谅。

书写不易，点个赞再走吧~

管理大大求过，[AC记录](https://www.luogu.com.cn/record/212590108)。

---

## 作者：xmy201315 (赞：1)

这道题一定要好好读题！~~我就被坑了~~

这道题是一道模拟+dp 的题目。

首先我们一个个枚举行选出了哪些行，接着我们 dp 列，令 $f_{i,j}$ 为前 $i$ 列选了 $j$ 列，并且选了第 $i$ 列，再令前面选的一个是 $k$，那么转移是 $f_{i,j} = \min(f_{k,j-1}+s1_{i}+s2_{k,i})$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e1stzf3w.png)
那么这道题就能做出来啦！（细节详看代码）

**AC code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 20;
const int inf = (1 << 29);
int n, m, r, c, ans = inf;
int a[N][N], row[N], s1[N], s2[N][N], dp[N][N];
int main() {
	scanf("%d%d%d%d", &n, &m, &r, &c);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	for (int S = 0; S < (1 << n); S++) {
		int cnt = 0;
		for (int i = 0; i < n; i++)
			if (S & (1 << i)) {
				row[cnt] = i + 1;
				cnt++;
			}
		if (cnt != r)continue;
		for (int i = 1; i <= m; i++) {
			s1[i] = 0;
			for (int j = 0; j < cnt - 1; j++)
				s1[i] += abs(a[row[j]][i] - a[row[j + 1]][i]);
			for (int k = i + 1; k <= m; k++) {
				s2[i][k] = 0;
				for (int j = 0; j < cnt; j++)
					s2[i][k] += abs(a[row[j]][i] - a[row[j]][k]);
			}
		}
		for (int i = 0; i <= m; i++)for (int j = 0; j <= c; j++)
				dp[i][j] = inf;
		dp[0][0] = 0;
		for (int i = 1; i <= m; i++) {
			dp[i][1] = s1[i];
			for(int j = 2; j <= c;j++)
				for (int k = 1; k < i; k++)
					dp[i][j] = min(dp[i][j], dp[k][j - 1] + s1[i] + s2[k][i]);
			ans = min(ans,dp[i][c]);
		}
	}
	printf("%d",ans);
}
```

完结撒花！

---

## 作者：tony0530 (赞：0)

### solution

------

#### 题目

[传送门](https://www.luogu.com.cn/problem/P2258)

给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列交叉而成的子矩阵，使得这个子矩阵的矩阵中每一对相邻元素(四联通)之差的绝对值之和最小，并输出这个值。

-------

#### 算法一

时间复杂度：${O(C_n^r \times C_m^c)}$。

~dfs+玄学剪枝应该能过,我没试过不确定。~

------

#### 算法二

考虑 DP
- **状态** $f_{i,j}$ 表示在前 $i$ 行选 $j$ 列的最小，$g_{i,j}$ 表示选了第 $i$ 行并且上一行是第 $j$ 的最小值。
- **转移** $f_{i,1} = 1$，$ \underset{1 \le k < i}{\min}f_{k, j-1}+g_{i,k}$。

------

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int n, m, r, c;
int matrix[N][N];
int f[N][N];
int cw[N], rw[N][N];
int q[N];

int count1(int x)
{
    int res = 0;
    for(int i = 0 ; i < n ; i ++ ) res += x >> i & 1;
    return res;
}
int main()
{
    cin >> n >> m >> r >> c;
    for(int i = 0 ; i < n ; i ++ )
        for(int j = 0 ; j < m ; j ++ )
            cin >> matrix[i][j];
    
    int res = INF;
    for(int state = 0; state < 1 << n; state ++ )
        if(count1(state) == r)
        {
            for(int i = 0, j = 0 ; i < n ; i ++ )
                if(state >> i & 1)
                    q[j ++ ] = i;
            for(int i = 0 ; i < m ; i ++ )
            {
                cw[i] = 0;
                for(int j = 1 ; j < r ; j ++ )
                    cw[i] += abs(matrix[q[j]][i] - matrix[q[j - 1]][i]);
            }
            for(int i = 0 ; i < m ; i ++ )
                for(int j = i + 1 ; j < m ; j ++ )
                {
                    rw[i][j] = 0 ;
                    for(int k = 0 ; k < r ; k ++ )
                        rw[i][j] += abs(matrix[q[k]][i] - matrix[q[k]][j]);
                }
            for(int i = 0 ; i < m ; i ++ )
            {
                f[i][1] = cw[i];
                for(int j = 2 ; j <= c ; j ++ )
                {
                    f[i][j] = INF;
                    for(int k = 0 ; k < i ; k ++ )
                        f[i][j] = min(f[i][j], f[k][j - 1] + cw[i] + rw[k][i]);
                }
                res = min(res, f[i][c]);
            }
        }
    cout << res;
    return 0;
}
```

---

## 作者：JingchenBian (赞：0)

## 思路一——深搜
本题 DFS 的时间复杂度为 $O(C_m^c\times C_n^r)$。

加一些剪枝可能能玄学过。~~我没试过不确定。~~
## 思路二——DP 优化
在 DFS 时可以用动态规划求解，不必使用搜索。

下面是 DP 部分。
### 状态
$f[i][j]$ 表示前 $i$ 行选择 $j$ 列的最优答案。
### 边界
$f[i][1]=1$。
### 转移
$f[i][j]=\min{(f[i][j],f[k][j-1]+res)}$。

其中 $k\in [1,i-1]$，$res$ 表示选了第 $i$ 行且上一行是第 $k$ 行时对答案的贡献值。

---

## 作者：algo_h (赞：0)

本题解在枚举行的组合，利用动态规划优化列的组合的框架下，尝试给出一种尽量减少重复计算的方案。

首先借助递归以增序枚举行的组合。在此过程中，维护两个变量：

* 每列（$j$）取当前选中的所有行作为子矩阵，因元素上下相邻而产生的分数（对应代码中的 $\mathrm{dp}[0][j]$）
* 每两列（$i$，$j$）取当前选中的所有行作为子矩阵，因元素左右相邻而产生的分数（对应代码中的 $\mathrm{inc}[i][j]$）

以上两个变量可以在递归枚举的过程中进行增量更新，且可以在递归退回时进行回溯。行的组合方案固定后，列的组合方案便可从列数为 $1$ 开始，根据子矩阵最优必有子矩阵去除最后一列后在可选范围内仍然最优的性质，以子矩阵列数和最后一列在原矩阵中的下标构成的二元组为状态，利用动态规划进行优化，逐步扩展到列数为 $c$ 的最优解。完整代码实现如下：

```c++
#include <algorithm>
#include <iostream>

using namespace std;

int n, m, r, c;
int M[16][16];
int R[16];  // 保存已选中行的下标

int min_score = 0x3fffffff;
int dp[16][16];   // [i, j] -> 选择 i + 1 列，以 j 为终点的最小分数
int inc[16][16];  // [i, j] -> 在第 i 列后增加第 j 列，因元素左右相邻而增加的分数

// 已知 dp[0] 和 inc，优化列的选择方案
void solve()
{
  // 动态规划，从选择 1 列开始，逐步扩展到选择 c 列时的最优解
  for(int i = 1; i < c; ++i) {    // 从选择 i 列扩展到选择 i + 1 列
    for(int j = i; j < m; ++j) {  // 枚举当前列的选择
      // 因元素上下相邻而增加的分数固定为 dp[0][j]，只需优化左右相邻贡献的分数
      dp[i][j] = dp[i - 1][i - 1] + inc[i - 1][j];
      for(int k = i; k < j; ++k) dp[i][j] = min(dp[i][j], dp[i - 1][k] + inc[k][j]);
      dp[i][j] += dp[0][j];
    }
  }
  int score = *min_element(&dp[c - 1][c - 1], &dp[c - 1][m]);
  min_score = min(min_score, score);
}

// 递归枚举行的组合，将选中的行填入 R 中
// 当前选择子矩阵的第 i 行，在原矩阵中至少为第 rmin 行
void solve(int i, int rmin)
{
  if(i == r) return solve();
  R[i] = rmin;

  // 新增一行，更新 dp[0] 和 inc
  for(int j = 0; i && j < m; ++j) dp[0][j] += abs(M[R[i]][j] - M[R[i - 1]][j]);
  for(int j = 0; j < m - 1; ++j) {
    for(int k = j + 1; k < m; ++k) inc[j][k] += abs(M[R[i]][j] - M[R[i]][k]);
  }

  solve(i + 1, rmin + 1);

  // 回溯
  for(int j = 0; j < m - 1; ++j) {
    for(int k = j + 1; k < m; ++k) inc[j][k] -= abs(M[R[i]][j] - M[R[i]][k]);
  }
  for(int j = 0; i && j < m; ++j) dp[0][j] -= abs(M[R[i]][j] - M[R[i - 1]][j]);

  if(n - (rmin + 1) >= r - i) solve(i, rmin + 1);
}

int main()
{
  cin >> n >> m >> r >> c;
  for(int i = 0; i < n; ++i) {
    for(int j = 0; j < m; ++j) cin >> M[i][j];
  }
  solve(0, 0);
  cout << min_score << endl;
  return 0;
}
```

总的复杂度为 $O(\mathrm C_n^r(2 + c)m^2)$，主要体现为常数优化，相比对每个行的组合方案独立预处理的复杂度 $O(\mathrm C_n^r(r + c)m^2)$ 可减少约一半的计算量，实测用时 $126\ \mathrm{ms} / 166\ \mathrm{ms}$（包含大小样例）。此外，注意到转置矩阵并相应交换行、列参数不会改变答案，故如果这一操作可以带来运算次数的显著减少，也可以作为一种独立的优化方案。

---

参考用时来源：

* https://www.luogu.com.cn/record/197498062
* https://www.luogu.com.cn/record/197490552

---

## 作者：ty_mxzhn (赞：0)

好题，怎么现在才发现。

## 算法 1

直接暴力，复杂度 $O(C_n^rC_m^c)$。

不知道加入减枝是否能够通过。

## 算法 2

考虑先枚举行的选取情况，这一部分时间复杂度为 $O(C_{n}^r)$。

然后考虑使用动态规划求解列的选取方案。设计 $f_{i,j}$ 表示前 $i$ 列选了包含第 $i$ 列的 $j$ 列作为子矩阵。

转移的时候枚举上一次选的列，时间复杂度 $O(C_{n}^r m^3)$ 足以通过。

---


# [SDOI2010] 地精部落

## 题目描述

传说很久以前，大地上居住着一种神秘的生物：地精。

地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 $n$ 的山脉 $h$ 可分为从左到右的 $n$ 段，每段有一个**独一无二**的高度 $h_i$，其中 $h_i$ 是 $1$ 到 $n$ 之间的正整数。

如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。

类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。

地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。

地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。

地精们希望这 $n$ 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。

现在你希望知道，长度为 $n$ 的可能有地精居住的山脉有多少种。两座山脉 $a$ 和 $b$ 不同当且仅当存在一个 $i$，使得 $a_i\ne b_i$。由于这个数目可能很大，你只对它除以 $p$ 的余数感兴趣。

## 说明/提示

共有 $10$ 种可能的山脉，它们是：

![](https://cdn.luogu.com.cn/upload/image_hosting/zh1bw5gr.png)

其中标记的数字表示可以设立瞭望台的山峰，其它表示可以设立酒馆的山谷。

**【数据规模和约定】**

对于 $20\%$ 的数据，满足 $N \le 10$；

对于 $40\%$ 的数据，满足 $N \le 18$；

对于 $70\%$ 的数据，满足 $N \le 550$；

对于 $100\%$ 的数据，满足 $3 \le N \le 4200$，$P \le 10^9$。


## 样例 #1

### 输入

```
4 7```

### 输出

```
3```

# 题解

## 作者：残梦断忆 (赞：193)

##DP + 滚动数组优化空间

这道题卡了差不多一个上午，思维难度灰常大，代码极简;

##题意，求波动数列

**首先我们必须要搞清楚3个性质**

>- First: 在一个波动数列中，若两个 i 与 i+1 不相邻，那么我们直接交换这两个数字就可以组成一个新的波动数列；
举个栗子： 5  2  3  1  4

4  2  3  1 5

>- Second: 把波动数列中的每个数字Ai 变成 (N+1)-Ai 会得到另一个波动数列，且新数列的山峰与山谷情况相反；

举个栗子： 1 4 2 5 3   （用 6 - 每个数）  1是山谷，4是山峰，后面类推

5 2  4 1 3      这个数列也是波动的 ，且 5是山峰，2是山谷；

>- Third: 波动序列有对称性。
栗子：1 4 2 5 3 to 3 5 2 1 4

这样我们的DP方程可以写成是：DP[I][J]表示 选 1 To I 这些数字，第一个数为山峰（山峰山谷比较形象），且第一个数为 J；

答案就是 ∑ DP[N][j] (j = 1 to N)

如何转移？这里我先上代码；


#DP[i][j]=DP[i][j-1]+DP[i-1][i-j+1]; 

##首先，我每次求 j作序列头，且表示山峰

由性质一可知，当j与j-1不相邻的时候，j作为头所有的方案数与j-1作为头的方案数相同，于是就有DP[I][J]=DP[I][J-1];

对于DP[i][j]+=DP[i-1][i+j-1];就是当j 与 j-1相邻时的情况；

**我们可以这么想，我第一个数选择了J 并且定义为山峰，那我第二个数j-1必定为山谷，后面的数属于[1,j-1]和[j+1,i]；

###此时问题转化成了求 i-1个数，j-1为头，但是j-1 为山谷的方案数，由性质2可知，j-1作山谷和作山峰的方案数相同；

现在的问题就是，此时的区间和我DP方程的区间意义不同；

###没关系；因为山峰与山谷是相对位置关系，将[j+1,i]区间的每个数都减一，这样是不改变相对大小关系的，并且此时就符合我们的方程了；

另外，我DP[i-1][j-1]表示的是J-1为山顶时的个数，为了让其表示J-1为山谷的情况，要改成DP[i-1][(i-1+1)-(j-1)]；

这样就得到了我们的转移方程，我们可以用滚动数组优化空间；

贴代码：


```cpp
cpp

#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005;
int f[2][MAXN]; //f[i][j]表示选前i个数，j是第一个数且为山峰；
int n,mod;
int main(){
    scanf("%d%d",&n,&mod);    
    f[0][2]=1;
    for(int i=3;i<=n;i++)
       for(int j=2;j<=i;j++){
       f[i&1][j]=(f[i&1][j-1]+f[(i-1)&1][i-j+1])%mod;}
//f[i][j]=f[i][j-1](把j 与  j-1直接交换掉，且j-1保证为山峰)+f[i-1][(i-1+1)-(j-1)]
//后面的式子表示，去掉 j ，让j-1当数列首位，则j-1保证为山谷，此时我们只构造了j-1为山峰的情况，用i-1+1-(j-1)即可； 
    int ans=0;
    for(int j=2;j<=n;j++){
    ans=(ans+f[n&1][j])%mod;    
    }
    printf("%d",(ans<<1)%mod);

}
```

---

## 作者：George1123 (赞：108)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P2467 【\[SDOI2010\]地精部落】](https://www.luogu.org/problem/P2467)

### 此题算法:奇怪的$dp$

一堆奇怪的$dp$,好像都能AC的样子

正确的$dp$却深藏不露(...

![](https://s2.ax1x.com/2019/10/22/K8tBdO.jpg)

![](https://s2.ax1x.com/2019/10/22/K8teRs.jpg)

↑一堆dp:

1.(错)生成山顶数列，山谷数列，合并

![](https://s2.ax1x.com/2019/10/22/K8a7fe.jpg)

2.(错)左一个合法数列，右一个合法数列

![](https://s2.ax1x.com/2019/10/22/K8df3Q.jpg)

3.(错)记录剩下的数。

想了这么多方法可见我这个下午有多苦恼

4.(正解)变♂幻♂山♂谷

①$dp[i][j]$表示数列中有$i$个数，第一个数为山顶且是$j$(你想最后一个数是$j$也可以)。

②分两种情况讨论$dp[i][j]$的值:

<1>翻转$dp[i-1][i-j+1]$得出第二个数为$j-1$的情况。

<2>交换不相邻的$j$和$j-1(dp[i][j-1])$。

所以$dp[i][j]=dp[i-1][i-j+1]+dp[i][j-1]$

好好想想为什么吧↑

$dp[i][j]$有而$dp[i][j-1]$没有的部分:

$dp[i-1][i-j+1]$↓ 

![](https://s2.ax1x.com/2019/10/22/K8hP9s.jpg)

$dp[i][j]$包含$dp[i][j-1]$方案的部分:

$dp[i][j-1]$↓

![](https://s2.ax1x.com/2019/10/22/K8gwIs.jpg)



## 以下是代码+注释
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4210;
int n,p,ans,dp[2][N]; //滚动数组
int main(){
	scanf("%d%d",&n,&p);
	dp[0][2]=1;
	for(int i=3;i<=n;i++)
		for(int j=2;j<=i;j++)
			dp[i&1][j]=( 
			dp[i&1][j-1]+ 
			dp[i&1^1][i-j+1])%p;
	for(int i=2;i<=n;i++)
		ans=(ans+dp[n&1][i])%p;
	printf("%d\n",(ans<<1)%p);
	return 0;
}

```
思路可能有重复，但图为手画的，喜欢就点个赞吧

谢谢大家! !


---

## 作者：zhaotiensn (赞：73)

翻了一翻题解，发现没有人用**组合数**之类的东西做这题，所以决定发一份题解。

这题因为要求出波动山脉的数量，所以应该不难看出是**DP**(不得不说这题的正解实在是太神了)，然而我一眼看下去总觉得是跟数论中的**组合数**有关，所以就有了这份**组合数加DP**奇怪的题解。

首先把波动山峰分成两种类型，一种第一位为山峰，一种第一位为山谷，分别表示为f[i][1]和f[i][0]。f[i][0]表示长度为i的波动山脉数量，第一位为山峰，f[i][1]表示长度为i的波动山脉数量，第一位为山谷。

不难得出在一段波动山脉中，如果**不考虑山峰和山谷**的限制，可以按照最大的那个数分成两段，一段的方案数和另一段的方案数的乘积再乘以组合数就是最大的数在某个位置时的方案数，再暴力枚举最大的数所在的位置，将所有方案数加起来，就是最大数确定时的总方案数。具体代码可以写成这样：

```cpp
for(int i=1;i<=n;i++)//f[i]表示长度为i的波动山脉数量
	for(int j=0;j<=i-1;j++)//j暴力枚举最大数的位置
		f[i]+=f[j]*f[i-1-j]*C[i-1][j];//C[i-1][j]表示i-1个数中取j个
```

这是显然成立的，所以接下来就是要将山峰和山谷考虑进去。

假设我们知道一段波动山脉的长度和第一位的状态(为山峰或山谷)，那么我们就不难得出最后一位的状态，同样倒过来也成立，所以一开始的分类就起了关键的作用。当**最大的数放在偶数位后**时，它前面的一段山峰数为偶数，又因为最大的数前的一定是山谷，所以前面的山脉的开头就一定是山峰，后面的山脉开头显然是山谷，所以就可以得到一个正确的转移方程：

```
if(j%2==0)f[i][1]+=f[j][1]*f[i-1-j][0]*C[i-1][j];
```

同理就可以得出另外一个**j为奇数**时的转移方程：

```
if(j&1)f[i][0]+=f[j][0]*f[i-1-j][0]*C[i-1][j];
```

接下来就不难打出能够AC的代码了。

```
cin>>n>>p;
f[1][1]=1;f[1][0]=1;f[0][1]=1;f[0][0]=1;
c[0][0]=1;//杨辉三角求组合数，听说用EX卢卡斯好像也可以过
for(int i=1;i<=n;i++){
	c[i][0]=1;
	for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
}
for(int i=2;i<=n;i++){
	for(int j=0;j<=i-1;j++){//转移方程
		if(j&1)f[i][1]=(f[i][1]+(long long)c[i-1][j]*f[j][1]%p*f[i-1-j][0])%p;
		else   f[i][0]=(f[i][0]+(long long)c[i-1][j]*f[j][0]%p*f[i-1-j][0])%p;
	}
}
cout<<(f[n][0]+f[n][1])%p<<endl;
```

其实题解到这里已经好了，但是看了别的题解后我意识到了可以对这份代码进行优化。
因为波动山脉的对称性(即山峰和山谷的位置变化)，简单的说山峰开头的方案数和山谷开头的方案数是一样的，这一应该也不难得出，所以f[i][0]其实就是f[i][1]，所以可以将方程合并，就有了一下这份代码：

```
for(int i=2;i<=n;i++)
	for(int j=0;j<=i-1;j++)
		if(j&1)f[i]=(f[i]+(long long)c[i-1][j]*f[j]%p*f[i-1-j])%p;
```

然后因为bzoj上会MLE，所以对杨辉三角进行**滚动数组**优化，可以大大的减小空间，然后就有了以下代码：

```
#include<iostream>
#include<cstdio>
using namespace std;

int n,p,f[5000],c[2][5000];

int main(){
    ios::sync_with_stdio(false);
    cin>>n>>p;
    f[0]=1;f[1]=1;
    c[0][0]=1;
    c[1][0]=1;c[1][1]=1;
    for(int i=2;i<=n;i++){
    	for(int j=1;j<=i;j++)c[i&1][j]=(c[i&1^1][j-1]+c[i&1^1][j])%p;
        for(int j=0;j<=i-1;j++){
            if(j&1){
                f[i]=(f[i]+(long long)c[i&1^1][j]*f[j]%p*f[i-1-j])%p;
            }
        }
    }
    cout<<f[n]*2%p<<endl;
    return 0;
}
```

---

## 作者：xzyxzy (赞：35)

~~可以算是优质题解？虽然我也是看了题解才完成的本题~~

只用一维DP，没有那么复杂

- 首先发现一个性质：/\/\\....和\/\/的数量一样多
- 设f[i]表示1到i的排列中，首个下降的波动序列个数
- 转移：加入i，一定是放在山峰的位置，枚举在第j个位置，则$f[i]+=f[j-1]*f[i-j]*C[i-1][j-1]$
- 意思是在剩余的i-1个数中选j-1个放在左边，然后左右的数字分别离散话之后的方案就是f[j-1]、f[i-j]

代码很简单
```cpp
#include<iostream>
using namespace std;
const int N=4210;
int C[2][N],f[N],P,n;
int main()
{
	cin>>n>>P;C[0][0]=C[1][0]=f[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			if(j&1) (f[i]+=1ll*f[j-1]*f[i-j]%P*C[(i-1)&1][j-1]%P)%=P;
			C[i&1][j]=(C[(i-1)&1][j]+C[(i-1)&1][j-1])%P;
		}
	cout<<2ll*f[n]%P<<endl;
}
Blog:https://www.cnblogs.com/xzyxzy
```
C要滚动因为要卡空间（BZOJ）

---

## 作者：伤风 (赞：21)

设f[i][j]表示i个数中j个数不符合序列,且第二个数比第一个数大

如5 1 2 3 4中3应比2小，4应比3小 此则j=2

f[1][0]=1,(1);

f[2][0]=1,(1,2);f[2][1]=1,(2,1);

推导出f[i+1][j]=f[i+1][j]+f[i][j];（将新加入的最大值插入到最后或倒数第二，如5 1 2 3 4->5 1 2 3 6 4,5 1 2 4 3->5 1 2 4 3 6)

f[i+1][j-1]=f[i+1][j-1]+f[i][j]\*j;(将新加入的最大值插入到不符合序列的数前，如5 1 2 3 4->5 1 2 6 3 4,5 1 2 3 6 4)

f[i+1][j+1]=f[i+1][j+1]+f[i][j]\*(i-j);(将新加入的最大值插入到剩下的数前）

```cpp
#include<cstdio>
long long i,j,k,n,m,p,f[4205][4205];
int main(){
    scanf("%lld%lld",&n,&p);
    f[1][0]=1;
    for(i=1;i<=n;++i)
        for(j=0;j<=i;++j){
     k=f[i][j];
     f[i+1][j]=(f[i+1][j]+k)%p;
     f[i+1][j+1]=(f[i+1][j+1]+k*(i-j)%p)%p;
     if(j)f[i+1][j-1]=(f[i+1][j-1]+(k*j)%p)%p;
}
printf("%lld",(f[n][0]<<1)%p);
}
```

---

## 作者：Froggy (赞：20)

看了题,准备自己写一下(因为我dp太差)

交了,惊现AC

看了看题解,发现大家代码聚短,而且都是$O(n^2)$的,蒟蒻只敲了个$O(n^2logn)$的...

而且挺长的,还是窝太菜..

---

$dp_{i,j}$表示考虑前$i$个数以$j$结尾的方案数,这$i$个数是1~i的一个排列

转移到下一个状态时,可以这样想:

$dp_{i,j}$相当于$dp_{i-1,k}$中原排列大于等于$j$的数都加1,再把j插到末尾后的新合法排列的方案数

听不懂?举个例子:

上一个排列:

```
4 2 3 1
```

比如当j=3时,那么变化后的排列为:

```
4+1 2 3+1 3
即:
5 2 4 1 3
```

那么状态转移就很显然了

答案有两种--"M"型与"W"型,显然方案数是一样的,这里只考虑"W"型的,最后把答案*2就行了

当i为奇数时, $dp_{i,j}=\sum_{k=j}^{i-1}dp_{i-1,k}$

当i为偶数时, $dp_{i,j}=\sum_{k=1}^{j-1}dp_{i-1,k}$

于是我们可以得到一个$O(n^3)$的做法:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define N 4211
#define M(a) ((a)<=mod?(a):(a-mod))
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,mod;
int dp[N][N],ans=0;
int main(){
	n=read(),mod=read();
	for(int i=1;i<=n;i++){
		dp[1][i]=1;
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i&1){
				for(int k=j;k<i;k++){
					dp[i][j]=M(dp[i][j]+dp[i-1][k]); 
				}
			}
			else{
				for(int k=1;k<j;k++){
					dp[i][j]=M(dp[i][j]+dp[i-1][k]);
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans=M(ans+dp[n][i]);
	} 
	cout<<2*ans%mod<<endl;
	return 0;
}

```
---

优化很显然,弄个前缀和就可以了..这样的话是$O(n^2)$ (但窝一时脑抽,写了个树状数组,写完才发现写个前缀和不完事了么..qwq)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define N 4211
#define M(a) ((a)<=mod?(a):(a-mod))
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,mod;
int dp[N][N],ans=0;
int b[N];
int lowbit(int x){
	return x&(-x);
}
void Add(int x,int d){
	while(x<=n){
		b[x]=M(b[x]+d);
		x+=lowbit(x);
	}
}
int Ask(int x){
	int ans=0;
	while(x){
		ans=M(ans+b[x]);
		x-=lowbit(x);
	}
	return ans;
}
int main(){
	n=read(),mod=read();
	for(int i=1;i<=n;i++){
		dp[1][i]=1;
		Add(i,1);
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i&1){
				if(i>j){
					dp[i][j]=M(Ask(i-1)-Ask(j-1)+mod);
				}
			}
			else{
				dp[i][j]=Ask(j-1);
			}
		}
		memset(b,0,sizeof(b));
		for(int j=1;j<=n;j++){
			Add(j,dp[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		ans=M(ans+dp[n][i]);
	} 
	cout<<2*ans%mod<<endl;
	return 0;
}

```
  
### [_Froggy's blog_](https://www.luogu.org/blog/1445353309froggy/)

我是一只快乐的菜蛙


---

## 作者：学委 (赞：18)

**我觉得先做[卡牌游戏（蓝题）](https://www.luogu.org/problemnew/show/P2059)，这道题不一定比那题难，只要有逆向DP的思维就好了。**

题意就是给1到n进行排列，排列后对于任意一个数，两边的数都比它大，或都比它小。求方案数。

如果从头开始递推，取走一个高度以后，发现“取走的是第几高的高度”对后面的递推是有影响的，非常棘手。但是

如果从“还剩1个高度没有取”的方案数，

反推出“还剩2个高度没有取”的方案数，

反推出“还剩3个高度没有取”的方案数……

递推就变得顺利，我发现逆向递推还是经常派得上用场的。

如果你没打过卡牌游戏的话，你可以

(1)做掉那道蓝题，然后你可能再想想就会这道题了。

(2)试试往下看。

***

怎么想到可以逆向递推？

假设这里有 $i$ 个高度。如果取了第 $j$ 高的作为第一个，下一个我可以

(1)“往高里取”，使下一个成为山峰。当然，这里有许多比 $j$ 更高的高度 $H$，都是可能的山峰。**为了保证 $H$ 是一个山峰，再下一个只能取比 $H$ 低的。**

![](https://cdn.luogu.com.cn/upload/pic/31932.png)

可用 $f[i][j][0]$ 表示有 $i$ 个数时，选取第 $j$ 高的，再往高里取的方案数，用 $f[i][j][1]$ 表示往低里取的方案数。

求 $f[i][j][0]$ 的办法是：

```cpp
for(int H = j; H <= n-1; ++H)
	f[i][j][0] += f[i-1][H][1];
    
//注意，i个数中，选第j大的以后，还剩i-1个数，则原本第j+1大的变成第j大的，原本第i大的变成第i-1大的。

/*所以，i个数中，选第j大的以后，再往高里取（再下一个是只能往低里取的），方案数就是：

在i-1个数中

    选第j大以后往低里取的方案数
+ 选第j+1大以后往低里取的方案数
……
+ 选第i-1大以后往低里取的方案数
*/
```

(2)“往低里取”。则下一个必是山谷，又不得不往高里取。一模一样！

```cpp
for(int H = 1; H < j; ++H)
	f[i][j][1] += f[i-1][H][0];
```

可见，如果有 $f[i-1]$，则 $f[i]$ 可以推出来。所以是逆推的。

**核心代码**

```cpp
f[1][1][0] = f[1][1][1] = 1;
for(int i = 1; i <= n; ++i)
	for(int j = 1; j <= i; ++j)
    {
		for(int H = j; H <= n-1; ++H)
			f[i][j][0] += f[i-1][H][1];
            
		for(int H = 1; H < j; ++H)
			f[i][j][1] += f[i-1][H][0];		
    }
    
int ans = 0;
for(int i = 1; i <= n; ++i)
	ans += f[n][i][1] + f[n][i][0], ans %= p;   
```

End~

个鬼啊，时间爆炸 $n^3$，空间爆炸 $2n^2$（$4200 × 4200 × 2 × 4 B = 134.6MB$），另外输入n=1时发现答案错误，咳咳。

***

首先，$f[i]$ 只由 $f[i-1]$ 推导，且最后只要用 $f[n]$ 求答案。所以开 $f[2][4201][2]$ 就好了，第一维滚动起来（$f[flag]$ 只由 $f[!flag]$ 推导）。

***

第二，手动模拟时很容易发现

$f[i][j+1][0] = sum(f[i-1][(j+1)\;to\;(i-1)][1])$——①

$f[i][j][0] = sum(f[i-1][(j)\;to\;(i-1)][1])$——②

所以求 $f[i][\text{所有}j][0]$时，不用对每个 $f[i][j][0]$ 都重新求一次 $sum(f[i-1][(j)\;to\;(i-1)][1])$，

而是根据①，倒序枚举 $j$，然后 $f[i][j][0] = f[i][j+1][0] + f[i-1][j][1]$。

***

第三，n=1的情况，这里对只剩的1个数进行了分类讨论，即接下来向上和接下来向下。其实1个数后面没有向上或向下。不优美的是，这个方法需要特判1。不过1以外都能正确。

***

第四！**推导所有的 $f[i][j][0]$，使用的是所有 $f[i-1][j][1]$；$f[i][j][1]$ 是与之对称的。如果你真的手动模拟一下**

![](https://cdn.luogu.com.cn/upload/pic/31946.png)

**你很可能发现，可以不开第三维，只要保证前缀和是用上一层的，而且是倒序累加的就能求出本层的其中一个方向的情况。**（模拟时会知道倒序累加即表示上一层的另一方向的情况之和）

当然不必要作这个简化，用前三个提示稍稍修改上面那段代码就可以了。

结果我是这么A的：

```cpp
#include <bits/stdc++.h>
#define LL long long 

using namespace std;

int n;
LL p;

LL f[2][4210];
int flag = 1;

int main()
{
	cin >> n >> p;
	
	if(n == 1)
	{
		printf("1\n");
		return 0;
	}
	
	f[flag][1] = 1; 
	
	for(int i = 2; i <= n; ++i)
	{
		flag = !flag;
		f[flag][1] = 0;//本层末端，向末端方向，不合法
		LL sum = 0;
		for(int j = i-1; j >= 1; --j)//指针倒过来，累加上一层
		{
			sum += f[!flag][j];
			sum %= p;
			f[flag][i-j + 1] = sum;
			f[!flag][j] = 0;
		}
	}
	
	LL ans = 0;
	for(int i = 1; i <= n; ++i)
		ans += f[flag][i], ans %= p;
	ans *= 2;//只求了各个点的一个方向啊，另一个方向完全对称
	ans %= p;
	
	printf("%lld\n", ans);
	return 0;
}

```

A之前并没有看题解，后来发现与先前的题解代码还有相似之处喔！我表述不好，这必然不是最好理解的，只是提供另一种想法啦。

---

## 作者：ezuyz (赞：17)

[**传送门**](https://www.luogu.com.cn/problem/P2467)

[**可能更好的阅读体验**](https://www.cnblogs.com/ezuyz/p/14720622.html)

## 题意：
求可行的**波动序列**的个数（序列为全排列）。

## 思路：
看到标签是 DP，我们就知道对于长度为 $n$ 的可行序列的方案要由 $n-1$ 推来，但具体怎么推呢？我们要先从简单的例子看起。


### 4 的答案如何由 3 推来：

长度为 3 时的可行序列：
```
2 1 3
3 1 2
2 3 1
1 3 2
```

由 3 的可行方案得扩展到 4 的可行方案，我们可以看作向 3 的序列中**插入**一个**极大**的数，这个数比其他所有的数**都要大**。

那我们先拿一个例子

```
2 1 3
```
        
我们在 2,1 之间插上 4

```
2 4 1 3
```
        
那么 2 就由原来的山峰变为了山谷，而**插入**的 4 一定比 1 大，所以 1 还会保持原有的山谷的形态，因此可以看作整个的序列形态不变。把 4 插到 1,3 之间也一样。

而对于

```
1 3 2
```

我们可以在序列最前或最后插入那个新的极大元素，而它一定比序列开头或末尾的数要大，因此 1 或 2 还会维持原有山谷的形态，那么整个序列的形态也可看作是不变的。
 
### 推广到一般：

对于一个序列：

- 如果它的一个边界是山峰，那我们就在其与和它相邻的那个数之间插入新元素。

- 如果它的一个边界是山谷，那我们就在最边上插入这个元素。

这样我们就可以维持这个序列**原有的形态**，而一个序列有两个边界，因此我们可获得的新的且维持原有形态（即不合法元素数数量不变）的序列的个数就会是原来个数的**两倍**。
 
再回到 3 到 4 的例子，根据以上操作，我们就能由原来 $n$ 为 3 时的 4 个可行序列获得 8 个新的可行序列了（不合法元素的个数为 0）。

那剩下的两个可行序列从哪里来呢？

我们先把 $n$ 为 3 时的两个不可行序列列出来：

```
1 2 3
3 2 1
```

无疑，它们都是递增或递减的，中间的 2 是不合法的。


不难发现，我们只要将 4 插到 2 和 1 之间，2 就可以变为合法的山谷，而 1 比 4 小，因此还可维持山谷的形态，所以序列就由原来的不可行转为可行了，我们就得到剩下的那两个可行序列了。
 
###  推广到一般：
对于不可行的序列（一定有一段或多段子序列是递增或递减的），我们只需将新元素插入到不合法的元素与那个比它小的元素之间，就是**原不合法元素变成了山谷**，而对插入位置另一边的元素无影响（因为一定还是比它大）。

那么原不可行序列的不合法元素的个数就一定会**减少 1**。那如果原序列有 $p$ 个不合法元素，那我们就有 $p$ 个位置可以插入，这样我们就通过插入由一个含有 $p$ 个不合法元素的序列得到了含有 $p-1$ 个不合法元素的序列。

由以上两个一般推论我们可以发现：对于一个长度为 $x$ 的含有 $a$ 个不合法元素的序列，有两个位置可使我们为其插入新元素后其还拥有 $a$ 个不合法元素，有 $a$ 个位置可使我们插入新元素后使其不合法元素减 $1$，并且这两种情况的位置一定是不会相重合的，那么我们就得到了长度为 $x+1$ 的 **2 个含有 $a$ 个不合法元素和 $a$ 个含有 $a-1$ 个不合法元素的序列**。

但我们知道对于长度为 $x$ 的序列有 $x+1$ 个位置是可以插入的，那应得到 $x+1$ 个新序列，那剩下的 $x-1-a$ 个序列呢？

可知，剩下的位置有以下几种情况：
（$z$ 代表插入位置）

1. 位于边界山峰之外：

	```
    2 1 3 z
    ```   
   这样 3 成了不合法元素。
   
   即原边界山峰因比新添元素小而成不合法元素。
   
2. 位于不合法元素与比它大的那个元素之间：

	```
    2 1 3 4 z 6 5
    ```
     
   这样 6 成了不合法元素。

   即那个与不合法元素相连的山峰合法元素因比新添元素小而成不合法元素。

3. 位于合法元素之间：

	```
    1 5 z 2 3
    ```
    
   这样 5 成了不合法元素。

   即与新添位置相邻的山峰元素变为不合法元素。

不难发现无论是以上那种情况，都会使 **不合法元素个数加 1**，其实把三种情况合起来，就是因为添了一个**极大元素**而使**原山峰元素变为不合法**。

因此对于一个长度为 $x$ 的含有 $a$ 个不合法元素的序列，我们可以通过插入得到长度为 $x+1$ 的 **2 个含有 $a$ 个合法元素和 $a$ 个含有 $a-1$ 个不合法元素和 $x-1-a$ 个含有 $a+1$ 个不合法元素的序列**。
 
至此我们就可以用 DP 愉快地得到所有状态了，最后输出长度为 $n$ 不合法元素为 0 的序列的的个数就行了。

注意别忘了开 `long long int` 并用滚动数组哦！

### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,p;
ll f[2][4260];
int main()
{
	cin>>n>>p;
	f[1][0]=4,f[1][1]=2;
	for(register int i=4;i<=n;i++)
	{
		for(int j=0;j<=i-2;j++)
        	f[0][j]=f[1][j],f[1][j]=0; 
		for(register int j=0;j<=i-3;j++)
		{
			f[1][j]=(f[1][j]+f[0][j]*2)%p;
			if(j) 
            	f[1][j-1]=(f[1][j-1]+f[0][j]*j)%p;
			f[1][j+1]=(f[1][j+1]+f[0][j]*(i-2-j))%p;
		}
	}
	cout<<f[1][0];
} 
```
代码还是很友善的对吧~





---

## 作者：chzhc (赞：12)

此题解对第一的题解进行完善，原题解有几处小错误

首先，有三个性质：

1. 在一个满足条件的数列中，如果 $x$ 和 $x+1$ 不相邻，那么直接交换这两个数字也可以得到一个满足条件的数列，比如：5 2 3 1 4 $→$ 4 2 3 1 5

2. 把满足条件的数列中的每个数字 $H_i$ 变成 $N-H_i+1$ 会得到另一个满足条件的数列，且新数列的山峰与山谷情况相反，比如：1 4 2 5 3（1，2，3 是山谷，4，5 是山峰）$→$ 5 2 4 1 3（2，1 是山谷，5，4，3是山峰）

3. 满足条件的数列反转后得到的数列也合法。比如：
   1 4 2 5 3 $→$ 3 5 2 4 1
  
考虑 DP，设 $dp(i,j)$ 表示选择 $1∼i$ 这些数字，第一个数为山峰，且第一个数为 $j$ 的方案数，根据性质 2，答案为 $2×∑_{i=1}^Ndp(N,i)$。

   我们要求 $j$ 放在第一个时满足条件的方案数。分两种情况：

   1. $j$ 与 $j-1$ 不相邻，根据性质 1，将 $j$ 放在第一个时的方案数与将 $j-1$ 放在第一个时的方案数是相同的，因为将 $j$ 和 $j-1$ 交换也能得到合法方案并且 $j-1$ 放在第一个时 $j$ 不可能放在第二个，所以两个方案数相同。
      即 $dp(i,j-1)→dp(i,j)$。

   2. $j$ 与 $j-1$ 相邻，那么显然 $j$ 为山峰，$j-1$ 为山谷，且去掉第一位之后的数都属于 $[1,j-1]∪[j+1,i]$，问题转化为 $j-1$ 为第一位且为山谷，有 $i-1$ 个数，由性质 2 可得：当 $j-1$ 作为山谷的方案数与 $(i-1)-(j-1)+1$ 作为山峰的方案数是相同的，现在的问题变成 $dp(i-1,(i-1)-(j-1)+1)$ 所对应的区间与我们想求的区间不同，但是不影响，因为山峰山谷考虑的只是相对大小关系，所以我们将 $[j+1,i]$ 全部减去 $1$ 对当前方案的可行性也不产生影响，并且处理之后对应的区间就是 DP 方程所代表的含义了。
		即 $dp(i-1,(i-1)-(j-1)+1)→dp(i,j)$。
      
初始 $dp(2,2)=1$（因为 $1$ 不能为山峰），时间复杂度 $\mathcal O(n^2)$。

考虑到空间为 125 MB 且 $dp(i,j)$ 只与 $dp(i-1,k)$ 有关，所以滚动数组优化空间复杂度即可，空间复杂度 $\mathcal O(n)$。
      
code：
```cpp
#include <bits/stdc++.h>

const int N = 4200; 

using namespace std;

int n, p, ans;
int dp[2][N];

int main()
{
	cin >> n >> p;
	dp[2 & 1][2] = 1;
	
	for (int i = 3; i <= n; ++ i)
		for (int j = 2; j <= n; ++ j)
			dp[i & 1][j] = (dp[i & 1][j - 1] + dp[(i - 1) & 1][(i - 1) - (j - 1) + 1]) % p;
	
	for (int i = 1; i <= n; ++ i) 
		ans = (ans + dp[n & 1][i]) % p;

	cout << ans * 2 % p << endl;
	
	return 0;
} 
```

---

## 作者：yqaty (赞：9)

写一份用差分的题解（嘤嘤嘤dalao们代码量都暴打我。。。

~~感觉这个dp还是挺好想的吧~~

考虑填数，我们用f[i][j][0/1]表示填第i个数，剩下的数中有j个数比在第i个位置的数大，0/1表示i使山峰还是山谷。

我们发现，在dp中我们只要考虑数的相对大小即可，不论i处填哪个数字，只要剩下的数中有j个数比它大，那么它对答案的贡献是一样的。

然后我们开始顺推（我比较喜欢顺推吧。。。我的这个思路也比较适合顺推）

对于f[i][j][0]，它可以选择j个数字作为放在i+1处，所以f[i+1][0~j-1][1]都要加上它的贡献；同理，对于f[i][j][1]，f[i+1][j~n-i-1][0]要加上它的贡献。

复杂度为O(n^3)，超时妥妥的，差分优化，复杂度O(n^2)。

最后，数组还会超空间（134MB），可以用滚动数组。

code：

```cpp
#include<bits/stdc++.h>
#define IL inline
using namespace std;
const int N=4203;
int n,p,f[2][N][2],ans;
IL int in(){
	char c;int f=1;
	while((c=getchar())<'0'||c>'9')
	  if(c=='-') f=-1;
	int x=c-'0';
	while((c=getchar())>='0'&&c<='9')
	  x=x*10+c-'0';
	return x*f;
}
IL void mod(int &x){if(x>=p) x-=p;}
int main()
{
	n=in(),p=in();
	for(int i=0;i<n;++i) f[1][i][0]=f[1][i][1]=1;
	if(n==1){cout<<1<<endl;return 0;}
	for(int i=1,op=1;i<n;++i,op^=1){
		for(int j=1;j<=n-i;++j)
		  mod(f[op^1][0][1]+=f[op][j][0]),
		  mod(f[op^1][j][1]+=p-f[op][j][0]);
		for(int j=0;j<n-i;++j)
		  mod(f[op^1][j][0]+=f[op][j][1]),
		  mod(f[op^1][n-i][0]+=p-f[op][j][1]);
		for(int j=1;j<n-i;++j) 
		  mod(f[op^1][j][0]+=f[op^1][j-1][0]),
		  mod(f[op^1][j][1]+=f[op^1][j-1][1]);
		for(int j=0;j<=n-i;++j) f[op][j][0]=f[op][j][1]=0;
	}
	mod(ans=f[n&1][0][0]+f[n&1][0][1]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Bartholomew (赞：9)

#By Bartholomew

--------
~~其实不要小看一道地精部落，有比较大的思维量在里面！~~
##小结论：
我们首先知道 3 个性质：

**如果有想看证明的，请自动转到代码片下面，因为考虑有些人不想看证明**

>$First$:
>**对于每一个 数字 i 和 i+1 ， 如果这两个数不是相邻的，那么交换两个数字的对应的方案数是一样的！**
>比如有 波动序列 $3 2 4 1 5$ 和 $1 2 4 3 5$  
>$Second$:
>**我们由 1~n 的波动数列的任意一种，将每一个 $a_{i}$ 都可以用（n+1） 减去，那么得到的新的序列其实还是合法的,而且相对的山谷和山峰会改变！**
>比如有 波动序列 $32415$ 和 $34251$
>$Third$:
>**波动数列具有对称性......**

##DP转移：
**其实就是变成了 $dp[i][j] =$ $dp[i-1][j] +$ $dp[i-1][i+1-j]$**
$dp[i][j]$ 表示可以 用 当前**离散化**之后的1~i 号的以$j$为开头的山峰的**方案个数**
我们可以思考一下：
一.
我们假设有 $j$ 与 $j+1$ 并不相邻--->那么我们就是方案数为 $dp[i-1][j]$
为什么？ 
>因为$dp[i][j-1]$ 表示的是 将j放入第一个的方案数,而且 $j-1$就是山峰,那么我们就知道了$j$**肯定不是第二个**,那么这样$j-1$**就不是山峰了**!

二.
如果$j$ 与 $j-1$ 是相邻的,那么此时的方案数就是 dp[i+1-j] 
因为我们可以考虑就是 $j$ ,$j-1$ , $????...$ 
那么就是相当于转换成了 $1$~$i-1$ 的数字 $j-1$ 为山谷的情况了! 因为 $j>j-1 $那么j-1 的右边只能是 比$j-1$ 要大的数字,也就是它是**山谷**的时候了!
那么我们根据**性质二**可以知道就是等同于 给你 $[1,j-1] U [j+1,i] $的数,让你求以 $j-1$ 为**开头的山谷的方案数**.那么其实又可以发现$[j+1,i]$ 的数 其实也就是相当于 $[j,i-1]$ ,可以自行**思考一发**!
那么就是求 1~i-1 以 $j-1$ 为开头的山谷的方案数. 也就是同时 用 $i-1+1$ 减去之后的方案数,即 **dp[i-1][i-1+1-(j-1)] = dp[i-1][i+1-j]**的方案数.!

##代码:
用了**滚动数组**!
```cpp
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <map>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#define MAXN 4201
#define N 1000050
#define INF 0x3f3f3f3f
#define P pair<int,int>
#define ll long long
using namespace std;
int n,MOD,dp[2][MAXN];
inline ll read()
{
    ll x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;	c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int main(int argc,char const* argv[])
{
    n = read(); MOD = read();
    dp[0][2] = 1;
    for(register int i=3;i<=n;++i) 
        for(register int j=1;j<=i;++j)
            dp[i&1][j] = (dp[i&1][j - 1] + dp[(i-1)&1][i-j+1]) % MOD;// dp[i-1][i-j+1] = dp[i-1][(i-1+1) - (j-1)];
 	int ans = 0;
 	for(int i=2;i<=n;i++) ans = (ans + dp[n&1][i])%MOD;
 	printf("%d",(ans<<1) % MOD);
 	return 0;
}
``` 

##证明:
>$First:$
>比如有 **j ..... j+1**
>**那么他们左右的数字要么是比 j-1 要小 要么是比 j+1要大,那么我们列一列情况会发现没有什么不合法的情况**
>$Second:$
>意会一下...

>$Third:$
>意会一下...

---

## 作者：Jason__Zhan (赞：7)

蒟蒻有一个神奇的想法，跟其他的题解有些不同（虽然比较相似），代码简单，无需分类讨论，但是有一些神奇的处理办法

首先直接大力令f[i]为长度为i的山脉的个数，不讨论第一个是修建瞭望台或酒馆的情况

首先很容易发现如果n为偶数，那么将一个长度为n的情况左右反转（类似将一个 1 3 2 4 的序列变为 4 2 3 1），由于开头和末尾修建的设施不同，那么可以通过左右反转来得到末尾相反的一种情况，且一一对应，则有开头/末尾为瞭望台和开头/末尾为酒馆的情况相等。

类似的，如果n为奇数，那么将一个长度为n的情况上下反转并且将对应下标a[i]改为n+1-a[i]（类似将一个 5 1 3 2 4 的序列变为 1 5 3 4 2），由于开头和末尾修建的设施相同，那么可以通过上下反转来得到末尾相反的一种情况，且一一对应，则有开头/末尾为瞭望台和开头/末尾为酒馆的情况相等。

所以，我们枚举最后一个高度所在的位置，可以轻松地得到转移
```
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<i;j++)
            dp[i]+=(1ll*c[i-1][j]*dp[j]/2)*dp[i-j-1]/2;
    }

```
其中$c[i][j]$为组合数，可以用杨辉三角轻松处理
$dp[j]$是第i个左边的情况，由于最后一个一定为酒馆，所以要将$dp[j]/2$,$dp[i-j-1]/2$也是。

当然，如果你这么写会样例都过不去。$dp[i]$虽然大多数都是偶数，但也有特例。当$i=1$是$dp[i]=1$,上下反转后保持不变，所以不能直接$/2$,这里可以令$dp[1]=2$，直接视其为两种情况，就可以$/2$。类似的，$dp[0]=0$，但是当最高峰左边无元素时，也会产生贡献，也令$dp[0]=2$。

好的，还剩最后一个问题，那就是取模。如果直接每一步$mod p$，将会收获40分的好成绩。这是因为$a=b(mod p)$不等价于$a/2=b/2(mod p)$。我的第一想法是费马小定理处理逆元，但是p不一定为质数，所以很可能在模p意义下2的逆元不存在，依然不能解决问题。

但是我们发现由于每次只需要$/2$,所以我们在每次操作时考虑不$mod p$，而是$mod p*2$.显然有$a%p=a%（p*2）%p$,而在$mod p*2$意义下的偶数x，有$(x/2)%(p*2)=(x%(p/2))/2$，所以可以在运算中先$mod p*2$，最后输出时再$mod p$，即可$AC$。

附上代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#include<cmath>
#include<stack>
using namespace std;
int c[4201][4201];
long long dp[4201];
signed main()
{
    int n,mod;
    scanf("%d%d",&n,&mod);
    for(int i=0;i<=n;i++)
        c[i][0]=c[i][i]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            c[i][j]=((long long)c[i-1][j]+c[i-1][j-1])%(mod*2);
    dp[0]=dp[1]=dp[2]=2;
    if(n==1){printf("1");return 0;}
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<i;j++)
            dp[i]+=(1ll*c[i-1][j]*dp[j]/2)%(mod*2)*dp[i-j-1]/2,dp[i]%=(mod*2);
    }
	printf("%d\n",dp[n]%mod);
    return 0;
}

```


---

## 作者：风浔凌 (赞：7)

**欢迎到博客观看->[戳我qwq](https://www.cnblogs.com/fengxunling/p/9749462.html)**

提供一个简单一点的思路，不需要滚动数组，也不需要一些奇奇怪怪的性质。
 
我们考虑设$f[i]$为$1$到$i$中有多少种波动数列。

我们可以注意到，波动数列分为先降后升和先升后降两种，但是我们发现其实它们对称，所以只算一个就可以了。

之后我们令$f[i]$表示的先降后升序列种类数，最后输出的时候答案乘以二就可以了。

我们在计算$f[i]$的时候，枚举其中最大数$j$的位置$k$。因为我们先计算的是先降后升序列，所以显然这个位置只能在奇数位上面。

我们计算的时候就是按上面所说枚举k，然后把$C_{i-1}^{k-1}\times f[i]\times f[i-k]$相加求和即可。

具体看代码：
```
#include<cstdio>
#include<algorithm>
using namespace std;
const int N = 1050;
int n,mod;
int f[N];
long long zuhe[N][N];
int main()
{
	scanf("%d%d",&n,&mod);
	for(int i=0;i<=n;i++)
	{
		zuhe[i][0]=1;
		for(int j=1;j<=i;j++)
			zuhe[i][j]=((long long)zuhe[i-1][j-1]+zuhe[i-1][j])%mod;
	}
	f[0]=1;
	for(int i=1;i<=n;i++)
	{
		f[i]=0;
		for(int j=1;j<=i;j+=2)
			f[i]=(f[i]+((long long)f[j-1]*f[i-j])%mod*zuhe[i-1][j-1]%mod)%mod;
	}
	int ans=(f[n]*2)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：EnochWenzhou (赞：5)

事实证明目前和我方法相同的人好像没有

我在考试时没想到任何前缀和或组合数的玄学做法

于是凭感觉打了一个非常奇怪而复杂的做法

以高度一个一个插入山脉

那么容易发现每一次插入一座山脉,此山脉必然成为山峰（因为是目前最高的）

因此加入此点会使山峰个数加0or1

以$f[i][j]$表示已经插入了i个山脉，而此时山峰个数为j的个数

首先暂时不考虑边界点

1.山峰数不变

也就是插在一座山峰j的两边即可

那么容易发现i会覆盖j成为山峰而此时山峰的个数不会变

那么有$f[i][j]+=f[i-1][j]\star(2\star j)$

2.山峰数加1

容易发现插在除了山峰旁边都会使山峰数增加1

那么有$f[i][j+1]+=f[i-1][j]\star (i-2\star j)$

但是现在要考虑有边界的情况

那么可以再开一维来表示目前边界的情况是什么

比如
0表示两个边界都是山谷

1表示一个边界为山谷另一个为山峰

2表示两个边界都是山峰

那么再推一推公式即可了。

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define rint register int
using namespace std;
int n,P;
LL f[4210][4210][3];
int main(){
	cin>>n>>P;
	f[3][1][0]=2,f[3][1][1]=2,f[3][2][2]=2;
    
	for(int i=4;i<=n;i++){
		for(int j=1;j<=i;j++){
        
			(f[i][j+1][0]+=f[i-1][j][0]*(i-2*j-2)%P)%=P;
			(f[i][j][0]+=f[i-1][j][0]*2*j%P)%=P;
			(f[i][j][0]+=f[i-1][j][1])%=P;
            
			(f[i][j+1][1]+=f[i-1][j][1]*(i-2*j-1)%P)%=P;
			(f[i][j][1]+=f[i-1][j][1]*(2*j-1)%P)%=P;
			(f[i][j][1]+=f[i-1][j][2]*2%P)%=P;
			(f[i][j+1][1]+=f[i-1][j][0]*2%P)%=P;
            
			(f[i][j+1][2]+=f[i-1][j][2]*(i-2*j)%P)%=P;
			(f[i][j][2]+=f[i-1][j][2]*(2*j-2)%P)%=P;
			(f[i][j+1][2]+=f[i-1][j][1]%P)%=P;
            
		}
	}
    
	if(n&1)cout<<(f[n][n/2][0]+f[n][n/2+1][2])%P;
	else cout<<f[n][n/2][1];
    
}
```
但是很容易发现一交上去时间空间纷纷爆炸

考虑到%操作比较慢，$f[][][]\star j$不会炸LL

那么可以将被加数合并并且只保留最后的%P：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define rint register int
using namespace std;bool f1;
int n,P;
LL f[4210][4210][3],t;
bool f2;int main(){
	cin>>n>>P;
	f[3][1][0]=2,f[3][1][1]=2,f[3][2][2]=2;
	for(int i=4;i<=n;i++){
		for(int j=1;j<=i;j++){
			(f[i][j+1][0]+=f[i-1][j][0]*(i-2*j-2))%=P;
			(f[i][j][0]+=f[i-1][j][0]*2*j+f[i-1][j][1])%=P;
			(f[i][j+1][1]+=f[i-1][j][1]*(i-2*j-1)+f[i-1][j][0]*2)%=P;
			(f[i][j][1]+=f[i-1][j][1]*(2*j-1)+f[i-1][j][2]*2)%=P;
			(f[i][j+1][2]+=f[i-1][j][2]*(i-2*j)+f[i-1][j][1])%=P;
			(f[i][j][2]+=f[i-1][j][2]*(2*j-2))%=P;
		}
	}
	if(n&1)cout<<(f[n][n/2][0]+f[n][n/2+1][2])%P;
	else cout<<f[n][n/2][1];
}
```

在有些空间范围较大的oj上是已经能A了

因此可以考虑滚动数组于是AC了luogu上的：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define rint register int
using namespace std;bool f1;
int n,P,t=0;
LL f[5][4205][3];
bool f2;int main(){
	cin>>n>>P;
	f[t][1][0]=2,f[t][1][1]=2,f[t][2][2]=2;
	for(int i=4;i<=n;i++){
		t^=1;
		for(int j=1;j<=i+1;j++)f[t][j][0]=f[t][j][1]=f[t][j][2]=0;
		for(int j=1;j<=i;j++){
			(f[t][j+1][0]+=f[t^1][j][0]*(i-2*j-2))%=P;
			(f[t][j][0]+=f[t^1][j][0]*2*j+f[t^1][j][1])%=P;
			(f[t][j+1][1]+=f[t^1][j][1]*(i-2*j-1)+f[t^1][j][0]*2)%=P;
			(f[t][j][1]+=f[t^1][j][1]*(2*j-1)+f[t^1][j][2]*2)%=P;
			(f[t][j+1][2]+=f[t^1][j][2]*(i-2*j)+f[t^1][j][1])%=P;
			(f[t][j][2]+=f[t^1][j][2]*(2*j-2))%=P;
		}
	}
	if(n&1)cout<<(f[t][n/2][0]+f[t][n/2+1][2])%P;
	else cout<<f[t][n/2][1];
}
```
个人认为是一种比较好理解的做法

---

## 作者：Yahbim (赞：3)

#### 题目分析：

做法：前缀和DP。很容易想到，不用复杂的性质分析。

设计状态： $f(i,j,0/1)$  表示使用了前 $i$ 
个数字，末尾数为 $j$ ，且末尾处为山峰或山谷时，方案数的总和。

**以下是重点：**

当末尾的山峰值为 j 时，每一个值低于 j 的山谷都有可能转移至 $f(i,j)$ 。这是一个从 $1$ 到 $j-1$ 的区间。考虑前缀和。定义 $s(i,j)$ 表示使用了第 $i$ 个数字时， $1$ 到 $j$ 的方案数总和。那么我们有：

$f(i,j,0/1) = s(i-1,j-1,1/0)$

我们不需要考虑值为 $i$ 的点在哪里。 $i$ 之所在必为山峰，因为 $i$ 最大。

从而可以写出如下代码：

```cpp

for(int i=1;i<=n;i++)
	for(int j=1;j<=i;j++){
		f[i][j][0]=s[i-1][j][1];
  		f[i][j][1]=s[i-1][j][0];
		s[i][j][0]+=f[i][j][0];
  		s[i][j][1]+=f[i][j][1];
	}
	
```

转移方程已经基本完成。随后：
* 不妨令末尾都为山峰，避免打两次代码
* 加入滚动数组和取模
* 初始化

就得到了最终代码：

**CODE:**

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,p,f[2][4505],s[2][4505];

int main(){
	scanf("%d%d",&n,&p);
	s[0][2]=1;//可以确定，此时方案有且只有一种，就从这初始化
	for(int i=3;i<=n;i++)
		for(int j=2;j<=i;j++){
			f[i&1][j]=(s[(i-1)&1][i-1]-s[(i-1)&1][i-j]+p)%p;//避免负数
			s[i&1][j]=(s[i&1][j-1]+f[i&1][j])%p;
		}
	printf("%d\n",(s[n&1][n]<<1)%p);
	return 0;
}
```

---

## 作者：漠寒 (赞：3)

## 题意简化

给定一个数 $n$，求满足以下二者条件之一的 $n$ 的排列的个数：1、对于所有奇数项，大于所有与它相邻的项；2、对于所有奇数项，小于所有与它相邻的项，由于答案可能很大，输出答案对 $mod$ 取模后的值。

## 做法

易得到两种情况的个数是相等的（可以自己打小数据的表），所以我的思路是在加入一个新的大数后，奇数项较大的情况有多少。

所以这个大数应该是放在奇数项，然后对于放在 $j$ 位置，左边的就应有 $f[j-1]$ 种情况，右边则为 $i-j$ 。

我们还想到左边这 $j-1$ 个数肯定不是固定的，所以我们还需要组合数，来求出这 $j-1$ 可能的组合情况。

那么组合数如何求呢？我们想到了一个有趣的模型——杨辉三角。为了节省空间，我们可以在递推 $dp$ 时，采用倒着的顺序顺带着将组合数求出，这样可以避免错误，组合数也只需要一维数组即可。

所以此题的两个核心式子便得到了。最后将得到的 $dp$ 乘2，对于 $n$ 为1特判即可。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
unsigned long long f[2005],ms,n,c[2005],cs=2;
int main()
{
	//freopen("dp.in","r",stdin);
	//freopen("dp.out","w",stdout);
	cin>>n>>ms;
	f[1]=1;
	f[0]=1;
	c[1]=1;//初始化，这里将杨辉三角右移了一下
	for(int i=2;i<=n;i++){
		for(int j=i;j>=1;j--){
			//cout<<j<<" "<<c[j-1]<<endl;
			c[j]+=c[j-1];//杨辉三角递推式
			c[j]%=ms;
			if(j&1)f[i]=(f[j-1]*f[i-j]%ms*c[j]+f[i])%ms;//dp转移式
		}
	}
	if(n==1){//特判
		cout<<1<<endl;
		return 0;
	}
	cout<<(f[n]*cs)%ms<<endl;
	return 0;
}

```


---

## 作者：xuanxuan001 (赞：3)

本蒟蒻第一次不看题解A了道紫题~~可我估计它要蓝了~~，而且发现我的方法和题解里的不一样，于是就发了这篇题解。

正文
-
这题DP，用$dp_{i,j,k}$表示一个长度为$i$的序列，记为$a_{1,2,\dots,i}$的最后一项为$j$，如果$k=1$，则$a_i<a_{i-1}$，否则$a_i>a_{i-1}$的合法序列总数膜$p$。

转移方程呢就是把最后一个数$j$删去，在将剩下的数离散化，由$1$到$i$的排列变成由$1$到$i-1$的排列，然后就可以列出一下的转移方程：

$$\begin{cases}
\sum\limits_{l=1}^{j-1} dp_{i-1,l,1}(k=0)\\
\\
\sum\limits_{l=j}^{n} dp_{i-1,l,0}(k=1)
\end{cases}$$

注意$k=1$的$\sum$的下面是$l=j$，因为原来的$j$被删除了，原来的$j+1$是现在的$j$，$\sum$其实就是求的前后缀，用一个数组$sum$来储存（注意$k=1$的维护前缀，$k=0$的维护后缀）。

然后上代码：
```
#include<cstdio>
#define MAXN 4202
using namespace std;
int n,p,dp[MAXN][MAXN][2],sum[MAXN][MAXN][2];
int main(){
	scanf("%d%d",&n,&p);
	if(n==1){//注意这里要特判，否则n=1时会输出2
		printf("1");
		return 0;
	}
	dp[1][1][0]=dp[1][1][1]=sum[1][1][0]=sum[1][1][1]=1;
	for(int i=2;i<=n;i++){
		for(int j=i;j>=1;j--){//k=0
			dp[i][j][0]=sum[i-1][j-1][1];
			sum[i][j][0]=(sum[i][j+1][0]+dp[i][j][0])%p;
		}
		for(int j=1;j<=i;j++){//k=1
			dp[i][j][1]=sum[i-1][j][0];
			sum[i][j][1]=(sum[i][j-1][1]+dp[i][j][1])%p;
		}
	}
	printf("%d",(sum[n][2][0]+sum[n][n-1][1])%p);
	return 0;
}
```
But这份代码会$\color{#0d3359}{MLE}$，所以要想办法压空间。

首先发现在每个循环里，数组$dp$只是被付了数组$sum$中的另一个值，然后与$sum$中的另一个值进行运算，所以数组$dp$可以直接被$sum$代替。

所以改良成这样：
```
//上个代码中的注释不在这里重写，下同 
#include<cstdio>
#define MAXN 4202
using namespace std;
int n,p,sum[MAXN][MAXN][2];
int main(){
	scanf("%d%d",&n,&p);
	if(n==1){
		printf("1");
		return 0;
	}
	sum[1][1][0]=sum[1][1][1]=1;
	for(int i=2;i<=n;i++){
		for(int j=i;j>=1;j--) sum[i][j][0]=(sum[i][j+1][0]+sum[i-1][j-1][1])%p;
		for(int j=1;j<=i;j++) sum[i][j][1]=(sum[i][j-1][1]+sum[i-1][j][0])%p;
	}
	printf("%d",(sum[n][2][0]+sum[n][n-1][1])%p);
	return 0;
}
```
这样虽然过了，可是还可以压，就是把$i$那一维压掉，不过这样必须把新的答案放到另一个数组里，然后放回原数组，比较复杂:
```
#include<cstdio>
#define MAXN 4202
using namespace std;
int n,p,sum[MAXN][2],t[MAXN][2];//t数组用于存放新的答案 
int main(){
	scanf("%d%d",&n,&p);
	if(n==1){
		printf("1");
		return 0;
	}
	sum[1][0]=sum[1][1]=1;
	for(int i=2;i<=n;i++){
		for(int j=i;j>=1;j--) t[j][0]=(t[j+1][0]+sum[j-1][1])%p;
		for(int j=1;j<=i;j++) t[j][1]=(t[j-1][1]+sum[j][0])%p;
		for(int i=1;i<=n;i++){
			sum[i][0]=t[i][0];
			sum[i][1]=t[i][1];
		}
	}
	printf("%d",(sum[2][0]+sum[n-1][1])%p);
	return 0;
}
```
后记
-
这题的思想比较难写清楚~~应该是我太蒻了说不清楚~~，所以如果有人哪没看懂，欢迎在评论区反（爆）馈（D）

---

## 作者：AquaRio (赞：3)

# 没用滚动数组瞎写居然没有被卡空间！！！！

这题在省选题里还是算比较简单的   
~~蒟蒻第一次写题解~~

------------

# 题意分析
首先我们根据题意   
  
  
**·这N段山脉每段都可以修建瞭望台或酒馆的其中之一**

就是要求长度为n的上下滚动的数组数量，例如  
```
（n=5) 1 4 2 5 3
```
就是一组。  


------------


# 方法分析
~~冥思苦想两分钟好像并没有此类公式...偷懒失败~~~  
  
  
很容易想到用dp，我们用f ( i , j )表示**当 n = i 时，以j为开头的方案数量**   
  
我们不妨设第一个j是山峰（由对称性最后ans*2即可）
  
先上转移方程（递推公式）

 _**f(i,j)=f(i,j-1)+f(i-1,i-j+1)**_   
   
 接下来解释为什么  
 考察j与j-1的位置关系  
 1. 若j与j-1不相邻  
 互换j与j-1，仍然得到的是一族合法的序列，且以j-1开头。具体为什么...自己写几个就会发现规律~    
 所以   _**f(i,j)+=f(i,j-1)**_   
 
 2. 若j与j-1相邻  
 这个情况复杂一些
 其实只需要计算以j-1为山谷的排列数量  
 山谷怎么办呢？  
 想到把后面的数字全部反转，即 l --> n+1-l 不难发现得到的仍是合法序列。  
 并且讨厌的山谷，变成了山峰！  
 所以  _**f(i,j)+=(i-1,i-j+1)**_  
   
**我们就得到了转移方程~~~**  
  
#   代码欣赏   
~~惊现邪教活动代码！~~
```cpp
//僕らのラブライブ！サンシャイン！！
//P2467
#include<bits/stdc++.h>
using namespace std;
const int maxn=4205;
int f[maxn][maxn];
int n,mod,ans;
int main(){
	cin>>n>>mod;
	f[1][1]=1;
	f[2][2]=1; //初始条件
	for(int i=3;i<=n;i++){
		for(int j=2;j<=i;j++){
			f[i][j]=(f[i][j-1]+f[i-1][i-j+1])%mod;
		}
	}
	for(int j=2;j<=n;j++) {
		ans+=f[n][j];
		ans%=mod;  
	}
	cout<<ans*2%mod;  //别忘记模了
} 
```


---

## 作者：miaowey (赞：3)

my\_blog: blog.csdn.net/miaomiao\_ymxl/article/details/54822060


定义f[i][j][k]为取1至i的数字，它们在最终序列中被分成j块，并且两头的块加新的大数字不合法的个数为k（0至2）

转移方程：

1.把原来两块的连起来：f[i+1][j−1][k]+=f[i][j][k]∗(j−1)

2.和其中一块连起来：f[i+1][j][k+1]+=f[i][j][k]∗(2−k)

3.自己单独创块：f[i+1][j+1][k]+=f[i][j][k]∗(j+1−k)


答案：f[n][1][0]+f[n][1][1]+f[n][1][2]

再把数组滚一滚就可以了


''







```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define LL long long
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define N (4200+5)
LL f[2][N][3];
int main(){
    int n, P;
    scanf("%d%d", &n, &P);
    int a = 1;
    f[1][1][0] = 1;
    For(i, 1, n-1){
        Set(f[a^1], 0);
        For(j, 1, min(i, n-i+1)) For(o, 0, 2)
            if(f[a][j][o]){
                if(j > 1) f[a^1][j-1][o] = (f[a^1][j-1][o]+f[a][j][o]*(j-1)%P)%P;
                if(o < 2) f[a^1][j][o+1] = (f[a^1][j][o+1]+f[a][j][o]*(2-o)%P)%P;
                f[a^1][j+1][o] = (f[a^1][j+1][o]+f[a][j][o]*(j+1-o)%P)%P;
            }
        a^=1;
    }
    printf("%lld\n", (f[a][1][0]+f[a][1][1]+f[a][1][2])%P);
    return 0;
}
''
```

---

## 作者：tiandong123 (赞：2)

# 题意：
求有多少$1--n$的排列$a$满足对于任意$a_i$

要么$a_{i+1}>a_i\&\&a_i<a_{i-1}$

要么$a_{i+1}<a_i\&\&a_{i}>a_{a-1}$

# $solution:$
假设题目的问题不是对于一个排列而是对于一个元素可以重复的数组来说的话。

我们考虑$dp[i][j][0/1]$表示在第$i$个位置，上一项的数字是$j$,上一项数字是否大于它的前面一项的方案数。

转移就是

$dp[i][j][0]=\sum_{x=j+1}^{n} dp[i-1][x][1]$

$dp[i][j][1]=\sum_{x=1}^{j-1}dp[i-1][x][0]$

但现在的问题是对于一个排列来讲的，那么上述转移必然会产生一些重复的数字。

我们考虑一个类似于离散化的操作。每个数只代表着它在当前区间的**排名**。

那么对于我们往区间后面插入一个数，带来的影响就是把原本比它大的数的排名$+1$，而比它小的数排名不变。

比如说我们原来的排名数列是$\{5,3,4,2,1\}$

我们插入了一个原本大小在第二大到第三大之间的数

那么我们得到的排名数列是$\{6,4,5,2,1,3\}$

并且我们发现，进行一次这样的改变是**不会影响**到原来的约束条件的。就是说原来为山峰的依旧是山峰，山谷的依旧是山谷。

我们利用这样的一种方法进行转移的话就可以去除数字重复的影响了。

我们枚举后面插入的数在数列中的排名，就可以$O(n^2)$转移了

转移方程

$dp[i][j][0]=\sum_{x=j}^{i-1} dp[i-1][x][1]$

$dp[i][j][1]=\sum_{x=1}^{j-1}dp[i-1][x][0]$

然后因为本题卡空间，$dp$用滚动数组记录

滚动数组就是在进行
$dp[i][j][0/1]$的转移时，我们发现$dp[i][j][0/1]$是只和$dp[i-1][j][0/1]$有关的。所以我们只需要存前一项和当前项就好了。

# $code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 4208
#define int long long
bool vis[maxn];
int dp[2][maxn][2];
int sum[2][maxn][2];
int n,mod;
int ans=0;
/*
比我小的排名都不变
比我大的排名都+1
*/
signed main(){
    scanf("%lld%lld",&n,&mod);
    if(n==1){
        cout<<1%mod<<endl;
        return 0;
    }
    dp[1][1][1]=1;
    dp[1][1][0]=1;
    sum[1][1][0]=1;
    sum[1][1][1]=1;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            int now=i&1,last=!now;
            (dp[now][j][0]=(sum[last][i-1][1]-sum[last][j-1][1]+mod))%=mod;
            (dp[now][j][1]=sum[last][j-1][0])%=mod;
            (sum[now][j][0]=sum[now][j-1][0]+dp[now][j][0])%=mod;
            (sum[now][j][1]=sum[now][j-1][1]+dp[now][j][1])%=mod;
        }
    }
    cout<<(sum[n&1][n][1]+sum[n&1][n][0])%mod<<endl;
    return 0;
}
```

---

## 作者：jkchen (赞：2)

 [**blog原文**](https://blog.csdn.net/jk_chen_acmer/article/details/87872649)

**原题：** https://www.luogu.org/problemnew/show/P2467

**题意：**

1~n这n个数的排列，要求“此起彼伏”，问方案数%P

**解析：**

>发现自己已经独立做出两题省选难度题了，之前遇到省选一脸懵逼来着。可能是省选题越来越水了吧~

因为所有数都不一样，所以数之间只有大小关系，即1,2,3和1,100,105其实是一样的。

这样有什么好处：

 - 假设轮到了一个数，对于剩下的数，只需要记录有几个大的即可（小的可以通过总数-大的算出，省一维）

那么写出数组涵义，$dp[滚动数组][sta][i]$，`sta==0`表示当前点为下凹点，反之上凸；i表示比当前数大的数量。

**转移方程：**

 - 下凹转上凸选一个大的：$dp[!f][!sta][j<i]<<dp[f][sta][i]$
 - 上凸转下凹选一个小的：$dp[!f][!sta][j<=n-now-i]<<dp[f][sta][i]$


以大数为例，其维护过程如下：
![ ](https://img-blog.csdnimg.cn/20190222092933533.png?x-oss-process=image/watermark)

计算时间复杂度：循环维护O(n)，每次选择大数数量O(n)，选择目标大数数量O(n)，n==4000，O(n^3)就炸了。

观察上图，你会发现后面个O(n)可以轻松合到一起。只有5更新4，5还会更新4以下的所有，所以可以累加一个更新，一路往下做。

```c
	int sum=0;
    for(int i=n-now;i>=1;i--){
        sum=(sum+dp[f][sta][i])%mod;
        dp[!f][!sta][i-1]=(dp[!f][!sta][i-1]+sum)%mod;
    }
```
再考虑小数
![ ](https://img-blog.csdnimg.cn/20190222094806227.png?x-oss-process=image/watermark)
和大数不同，小的是往上累加（43210，4321，432，43，4）


**AC代码：**
```c
#include<bits/stdc++.h>
using namespace std;

int n, mod;
int dp[2][2][4300];
//f 滚动数组 sta=0 当前为下凹 i 比当前数大的数量
int main() {
    scanf("%d%d", &n, &mod);
    int f = 1;

    for(int sta = 0; sta <= 1; sta++) {
        for(int i = 0; i < n; i++) {
            dp[f][sta][i] = 1;
        }
    }
    for(int now = 1; now < n; now++) {
        int sta = 0;
        int sum = 0;
        for(int i = n - now; i >= 1; i--) {
            sum = (sum + dp[f][sta][i]) % mod;
            dp[!f][!sta][i - 1] = (dp[!f][!sta][i - 1] + sum) % mod;
        }
        sta = 1;
        sum = 0;
        for(int i = n - now; i >= 1; i--) { // 小的数量
            // 下一个状态也是 to(大的数量) ，因为选的是小的，最小值不会变
            int to = n - now - i;
            sum = (sum + dp[f][sta][to]) % mod;
            dp[!f][!sta][to] = (dp[!f][!sta][to] + sum) % mod;
        }
        f = !f;
        memset(dp[!f], 0, sizeof(dp[!f]));
    }
    printf("%d\n", (dp[f][0][0] + dp[f][1][0]) % mod);
}

```


---

## 作者：无咕_ (赞：2)

## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：24

------------

## 题目大意
题面： [<传送门>](https://www.luogu.com.cn/problem/P2467)

题意：给出 $n,p$，所有序列长度为 $n$，某个序列中的元素就是 $1\sim n$ 的排列。已知一个合法方案满足以下要求之一：

1. 序列中存在 $i$，使得 $a_{i-1}<a_i>a_{i+1}$。

2. 序列中存在 $i$，使得 $a_{i-1}>a_i<a_{i+1}$

求出合法方案数 $\bmod\,p$ 的值。

~~术语理解： DP+组合数。~~

## Solution

首先，我们看到题目，一看到有关排列的问题，就能知道与排列组合有关。

观察一下序列，~~易知~~按数大小分化，可划分为两种：

1. 降升降升降升……

2. 升降升降升降……

等等，这不是波动数列么？而且，因为是排列，所以我们只需要考虑其中一种，因为它是对称的！

状态：设 $f_i$ 表示序列长度为 $i$ 的可行方案数 $\bmod\,p$ 值（其实这里取不取模都一样，最好是取模防止爆，反正时间够）

那最后我们输出 $f_n\times 2$ 即可！

可是初始化和转移？

首先手推一下初始化，$f_1=1$。那么 $f_0$ 怎么设定？算了不管了，初始化是取决于转移的，转移后我们再考虑即可。

既然我们是利用的组合数，就要先把组合数求出来。数组开 `long long g[4209][4209]` 指定没希望了，因为这题数据卡的很严。

我们就没办法了吗？不，我们可以压到一维，然后算到哪用到哪！

接着考虑转移，既然我们选用了类似前缀和的状态，那么我们也可以利用一下前缀和的思想！

通过研究~~易知~~，我们发现合法方案一定会出现在奇数位（别问，问就玄学）。对于长度为 $i$ 的合法方案数，我们需要倒序遍历枚举最大值（倒序是为了先算下标小的，我的方法是倒序，其实也可以正序），跑转移，而且这个位置还要是奇数位。

有人可能问，为啥只算奇数位？因为奇数位是一种序列，而偶数位也是一种序列，我们完全可以根据之前说的对称性来合并两种情况。

那么转移方程究竟是啥？先丢后讲：

设当前枚举位置为 $j$，序列长度为 $i$ ：

$$f_i=(f_i+C_{i-1}^{j-1}\times f_{j-1}\times f_{i-j})\bmod p$$

我们以 $j$ 为分界点，左边的方案数是 $f_{j-1}$，右边为 $f_{i-j}$（注意序列右端点为 $i$），至于那个组合数嘛……是排列的方案数。

为啥是 $C_{i-1}^{k-1}$ （$i-1$ 中选 $k-1$ 个的排列数）？因为我们要得到 $1\sim i$ 排列，不考虑位置 $j$，那么剩下就是 $i-1$ 个情况。左边有 $j-1$ 个位置，所以我们要选 $j-1$ 个数。为啥不算右边的？因为我这里是根据右边的情况来确定的，所以右边是固定的。

当然，你也可以固定左边，把式子写成：

$$f_i=(f_i+C_{i-1}^{i-j}\times f_{j-1}\times f_{i-j})\bmod p$$

不过要注意组合数求出来的时机。

最后注意求得 $f_n$ 后 $\times 2$ 然后取模！

式子过程中可以多取几次模，

## AC code

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
const int MAX=4e5+9;
typedef long long ll;
inline ll read(){
    register ll x=0,f=1;register char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}ll n,mods,f[MAX],g[MAX];
int main(){
    n=read();mods=read();
    f[0]=1,f[1]=1;g[1]=1;
    for(int i=2;i<=n;i++){
        for(int j=i;j>=1;j--){
            g[j]+=g[j-1];
            g[j]%=mods;
            if(j&1)f[i]=((g[j]%mods*(f[j-1]%mods*f[i-j]%mods)%mods)%mods+f[i]%mods)%mods;
        }
    }printf("%lld\n",(f[n]*2)%mods);
    return 0;
}
```

AC 记录 [<传送门>](https://www.luogu.com.cn/record/57378760)

---

## 作者：妩媚的ak萝莉 (赞：1)

### 题目：问有多少1~n的排列是波浪序列（即每个数要么比相邻两个数都大，要么比相邻两个数都小）

注意到本题中并不关心数字具体是几，而只关心数字之间的相对关系，而且只关心最后一个数的相对大小，于是我们可以用一个两维的dp状态压缩所有信息：

$dp[i][j][0/1]$表示已经放好$i$个数了，其中最后一个数在剩下的$n-i$个数中比$j$个数大$(0<=j<=n-i)$，且

0：下一个数比最后一个数小；

1：下一个数比最后一个数大的方案数

转移：$ dp[i][j][1]=\sum dp[i-1][k][0] (j<k<=n-i+1) $

$dp[i][j][0]=\sum dp[i-1][k][1] (0<=k<=j)$

初始化：$dp[0][0][0]=dp[0][0][1]=1$;答案：$\sum dp[n][a][0/1]$

显然可以用滚动数组和前缀和优化时间和空间复杂度，优化后时间复杂度：$O(n^2)$ 空间复杂度 :$O(n)$ (不用滚动数组的话会MLE。。)

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4350;

int dp[N][2],n,p,qi[N][2],tmp[N][2],ans;

int main()
{
	scanf("%d%d",&n,&p);
	for(int i=0;i<n;i++)
		for(int a=0;a<2;a++)
			dp[i][a]=1;
	for(int i=2;i<=n;i++){
		qi[0][0]=dp[0][0];
		qi[0][1]=dp[0][1];
		for(int j=1;j<=n-i+1;j++) 
			for(int a=0;a<2;a++)
				qi[j][a]=(qi[j-1][a]+dp[j][a])%p;
		for(int j=0;j<=n-i;j++){
			tmp[j][0]=qi[j][1];
			tmp[j][1]=(qi[n-i+1][0]-qi[j][0])%p;
		}
		for(int j=0;j<=n-i;j++) 
			for(int a=0;a<2;a++)
				dp[j][a]=tmp[j][a];
	}
	ans=(dp[0][0]+dp[0][1])%p;
	printf("%d\n",(ans+p)%p);
	return 0;
}
```

---

## 作者：ppp204 (赞：1)

[安利自己的~~丑陋~~博客](https://i.cnblogs.com/EditPosts.aspx?postid=11771268)

> 做法：DP+组合数

首先我们定义$dp[i]$为长度为i时的方案数。

不难想到，如果要满足每一个点都满足为山峰或者山谷的话，肯定是曲折的。（及若山谷为0，山峰为1，肯定是$010101010101\cdots$ 或者 $101010101010\cdots$）

我们把这一个长度为n分成两个部分，设左边的长度为j，则右边的长度为i-j

发现这样不太好转移，于是我们把dp的状态再**定义严格一点**。

我们定义$dp[i]$表示长度为i，**且第一个严格为山峰**的方案书。

那么我们此时此刻，左边的开头与右边的开头就都是山峰了。

由上面的$01$串可得，我们的左边最后一个也得是山峰，也就是说，我们左边的长度得是**奇数**

最后一个问题：如何保证**左边最后一个**与**右边第一个**一定为山峰？

我们把中间放上了一个最小值不就好了吗？

因此我们得到dp转移方程

$dp[i] = \sum_{j=1}^{i-1} dp[j] * dp[i-1-j]*C_{i-1}^{j}(j\%2==1)$

然后进行dp就好了。

对于山谷，与山峰的情况是完全一样的，因此我们直接\*2即可

#### Code:

```cpp
#include<bits/stdc++.h>
#define re register
#define rep(i,a,b) for(re int i=a,i##end=b; i<=i##end; i++)
#define drep(i,a,b) for(re int i=a,i##end=b; i>=i##end; i--)
#define repp(i,a,b) for(re int i=a,i##end=b; i<i##end; i++)
#define drepp(i,a,b) for(re int i=a,i##end=b; i>i##end; i--)
#define Erep(i,x) for(re int i=head[x]; i; i=Edge[i].nxt)
#define lowbit(x) ((x)&-(x))
#define ms(x,a) memset(x,a,sizeof x)
#define debug(x) cerr<<#x<<" = "<<x<<endl
#define CM cerr<<(&S2-&S1)/1024./1024.<<"MB"<<endl
#define PII pair<int,int>
#define PLL pair<ll,ll>
#define fi first
#define se second
#define coint const int
#define coll const ll
typedef long long ll;
using namespace std;
template<class T>inline T rd(){
	static char ch;static bool neg;static T x;
	for(neg=0, ch=0; ch>'9'||ch<'0'; neg|=(ch=='-'),ch=getchar());
	for(x=0; ch<='9'&&ch>='0'; x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar());
	return neg?-x:x;
}
template<class T>inline T Max(const T &x, const T &y) { return x>y?x:y; }
template<class T>inline T Min(const T &x, const T &y) { return x<y?x:y; }

bool S1;

int n,p;

struct P100{
	static coint N=4200+5;
	int dp[N]; // dp[i] -> 长度为i,符合条件 且 严格定义第一个为山峰(山谷同理)的方案数
	int C[N][N];
	inline void Upd(int &x, coint y){
		x+=y; x-=(x>=p?p:0); return;
	}
	inline void solve(){
		rep(i,0,N-5){
			C[i][i]=C[i][0]=1;
			repp(j,1,i) Upd(C[i][j],C[i-1][j]+C[i-1][j-1]);
		}
		dp[0]=dp[1]=1;
		rep(i,2,n){
			repp(j,1,i) if(j&1){ // 保证中间'1'的两边都是山峰
				dp[i]=(dp[i]+1ll*dp[j]*dp[i-1-j]%p*C[i-1][j]%p)%p;
			}
		}
		Upd(dp[n],dp[n]);
		printf("%d\n",dp[n]);
		return;
	}
}p100;

bool S2;

int main(){
//	CM;
//	freopen("goblin.in","r",stdin);
//	freopen("goblin.out","w",stdout);
	n=rd<int>(),p=rd<int>();
	if(n<=10) return p20.solve(),0;
	if(n<=18) return p40.solve(),0;
	p100.solve();
//	fclose(stdin); fclose(stdout);
	return 0;
}
```

---

## 作者：cccgift (赞：1)

# pascal的题解好少……

看着$dp$训练场点进来的，肯定是得用$dp$。

本题中有一些特殊的地方：每段山脉独一无二，且属于$[1,n]$。

由此可以知道，高度很小，且没有相同的高度。

于是，我们可以把高度当作一个状态，设$f[i,j]$表示前$i$座山脉，第$i$座山脉的高度为$j$，的方案数。

所以，状态转移方程如下：

### $f[i,j]=f[i,j]+\sum_{k=1}^{j-1}f[i-1,k]$（$i$为山峰）

### $f[i,j]=f[i,j]+\sum_{k=j+1}^{i-1}f[i-1,k]$（$i$为山谷）

因为对于山峰，它前面那一个肯定比它矮，对于山谷，它前面那一个肯定比它高。

最后的答案就是$\sum_{i=1}^{n}f[n,i]$。

最后别忘了，山峰可以在奇数位上，也可以在偶数位上，答案要乘$2$。

时间复杂度为$O(n^3)$。

对于$f[i,j]$，我们可以利用前缀和优化，$s[i,j]$表示$\sum_{k=1}^{j}f[i,k]$，转化就可以达到$O(1)$。

最终的时间复杂度为$O(n^2)$。

但是，我的原来的代码挂了……面对小数据会$WA$，也许是取余时减法出现了负数……，但是怎么调都没用，所以用到了骗分，小数据$O(n^3)$，大数据$O(n^2)$。

~~但是，如果没有取余，这个方法绝对是正解。~~

#### 代码如下：

```pascal
var f:array[0..1,0..4200] of int64;
    g:array[0..550,0..550] of int64;
    n,i,j,a,k:longint;
    mo,tot:int64;
begin
  readln(n,mo);
  if n<=18 then
  begin
    for i:=0 to n do g[1,i]:=1;
  for i:=2 to n do
  begin
    a:=i and 1;
    if a=0 then
      for j:=1 to i do
        for k:=1 to j-1 do
          g[i,j]:=(g[i,j]+g[i-1,k]) mod mo
    else
      for j:=i downto 1 do
        for k:=j to i-1 do
          g[i,j]:=(g[i,j]+g[i-1,k]) mod mo;
  end;
  {for i:=1 to n do
  begin
    for j:=1 to n do write(f[i,j],' ');
    writeln;
  end;}
  for i:=1 to n do tot:=(tot+g[n,i]) mod mo;
  writeln((tot shl 1) mod mo);
    exit;
  end;
  a:=n and 1;
  for i:=0 to n do f[1,i]:=i+1;
  for i:=2 to n do
  begin
    a:=a xor 1;
    if a=0 then
      for j:=1 to i do
        f[i and 1,j]:=(f[i and 1,j-1]+f[i and 1 xor 1,j-1]) mod mo
    else
      for j:=1 to i do
        f[i and 1,j]:=((f[i and 1,j-1]+f[i and 1 xor 1,i-1]-f[i and 1 xor 1,j-1]) mod mo+mo) mod mo;
  end;
  {for i:=1 to n do
  begin
    for j:=1 to n do write(f[i,j],' ');
    writeln;
  end;}
  writeln((f[n and 1,n] shl 1) mod mo);
end.
```

---

## 作者：LovEver_Rv (赞：1)

写在前面：学dp不久，感觉自己dp掌握的不熟，同学就安利了这题，晚22:30开始想，0:30才通过；本题解希望尽量降低读者的理解难度（看了前面的一些题解感觉理解难度并不低），也算是希望与各位共同学习吧～


一开始方向错了，大概过了快1小时才写出正确的状态转移方程，下面写出完整的思维过程：

一种合法方案一定是山峰（下称summith）和山谷（下称valley）交替出现的，或者说一定是一个波动数列（下面可能多次出现“合法方案”和“波动数列”混用的表述）。观察前几组数据可以猜想（也是直观的）每一个数字都可以放在开头。下面，我们考虑summit(i,n)表示以数字i开头长度为n，且i为山峰的合法方案数。类似地，定义vally(i,n)表示以i开头长度为n，且i为山谷的合法方案数。总的合法方案数就是:
![](https://cdn.luogu.com.cn/upload/pic/48349.png)

接下来我们发现，如果一种合法方案以i开头，长度为n，且i作山峰，后面一定跟着一段开头是山谷的长度为n-1的合法方案（波动数列），并且后面这段波动数列的开头数字一定要小于i。似乎只要把valley(k,n-1)从1到i-1求和即可。然而后面这段波动数列的数字是从1到n-1的，并且有可能已经包含了i！

这时候只要想到一种长度为n-1的合法方案事实上是代表了n-1个互不相同的数的一种排列，即：最小的数排在哪里，第二小的数排在哪里……而不仅仅代表1排在哪里，2排在哪里。理解了这点，我们做一个操作：对于每个长度为n-1的合法方案，把i变成i+1，然后把i+1变成i+2……把n-1变成n，这样，位于该合法方案中任何位置的数的“第几小”是不会改变的。对每个i，每次把一种长度为n-1的合法方案按照这样操作，然后把i插入这个方案的最开头，就得到了一种长度为n的合法方案。

于是有dp方程：
![](https://cdn.luogu.com.cn/upload/pic/48350.png)

接下来要求valley(i,n)，其实也是一样的思想，一种合法方案以i开头，长度为n，且i为山谷的话，后面就要接上长度为n-1且开头为山峰的波动数列，并且开头的数要比i大。对于每一段长度为n-1的合法序列，把i变成i+1，把i+1变成i+2……把n-1变成n。就能使得这种连接成立。由于这里做了这个操作，要注意到实际上我们是把summit(k,n-1)从 _**i 到 n-1**_ 求和。

dp方程如下：
![](https://cdn.luogu.com.cn/upload/pic/48352.png)

另外，i=1和i=n的特殊情况下，容易发现这样求出来的summit(1,n)和valley(n,n)都是0，所以不会有问题。

下面就可以码代码了。我用f表示valley，用g表示summit，由于N>=3，只要从2开始赋初值就行。这是第一版代码：
```cpp
#include <iostream>
using namespace std;

int f[4300][4300];
int g[4300][4300];
int main()
{
    int n,p;
    cin >> n >> p;
    f[1][2]=1%p;
    g[2][2]=1%p;
    for(int i=3;i<=n;i++)
    {
        for(int a=1;a<=i;a++)
        {
            for(int b=a;b<=i-1;b++) f[a][i]=(f[a][i]+g[b][i-1])%p;
            for(int b=1;b<=a-1;b++) g[a][i]=(g[a][i]+f[b][i-1])%p;
        }
    }
    int res=0;
    for(int i=1;i<=n;i++) res=(res+f[i][n]+g[i][n])%p;
    cout << res;
    return 0;
}
```

不过这代码是过不了这题的，会TLE三个点。这是因为对f(k,n-1)和g(k,n-1)的求和效率过低。只要想到对f(k,n-1)和g(k,n-1)做一个对k的前缀和就能解决了。于是加入fsum和gsum数组，这里要小心在赋初值的时候，f(2,2)为0，但是你要为fsum(2,2)赋一个初值1。

进一步你会发现其实f和g数组都已经没用了……把它们删掉防止MLE。我的AC代码如下：
```cpp
#include <iostream>
using namespace std;

//int f[4300][4300];
int fsum[4300][4300];
//int g[4300][4300];
int gsum[4300][4300];
int main()
{
    int n,p;
    cin >> n >> p;
    //f[1][2]=1%p;
    fsum[1][2]=1%p;
    fsum[2][2]=1%p;
    //g[2][2]=1%p;
    gsum[2][2]=1%p;
    for(int i=3;i<=n;i++)
    {
        for(int a=1;a<=i;a++)
        {
            int fai,gai;
            fai=(gsum[i-1][i-1]-gsum[a-1][i-1]+p)%p;
            fsum[a][i]=(fsum[a-1][i]+fai)%p;
            gai=(fsum[a-1][i-1])%p;
            gsum[a][i]=(gsum[a-1][i]+gai)%p;
        }
    }
    int res=(fsum[n][n]+gsum[n][n])%p;
    cout << res;
    return 0;
}
```

这个代码优化得显然没有前面发题解的dalao们好。如果再深入探讨，fsum和gsum之间是有关系的，可以不需要两个这么大的数组，以进一步优化空间。

---

## 作者：1517460958dyc (赞：1)

# 试图挑战最短~~（失败了）~~
#### 好吧，不说废话，主要借鉴了[@伤风](https://www.luogu.org/space/show?uid=20285)大佬的思路并做了优（ya）化（hang）
#### 首先，请大家记住：十年OI一场空，不开long long见祖宗！不开long long的头铁（怕MLE）的我，愣是调了很久……这题开全局变量可不初始化全部，不用部分不占内存，可防MLE。
#### 再说说具体优化：从推出状态变为继承状态，省去了一些不必要的转移，还能防止溢出。注意，i>j甚至i==j都是无用状态（i==j为0）。
#### 看不懂可私信或参考[@伤风](https://www.luogu.org/space/show?uid=20285)大佬的代码
```cpp
#include<cstdio>
using namespace std;
int n,mod;
long long ans[4210][4210]={};
int main()
{
    scanf("%d%d",&n,&mod);
    ans[1][0]=1;
    for (int i=2;i<=n;++i)
        for (int j=0;j<i;++j)
            ans[i][j]=(((ans[i][j]+ans[i-1][j])%mod+ans[i-1][j+1]*(j+1)%mod)%mod+((j)?ans[i-1][j-1]*(i-j)%mod:0))%mod;
    printf("%lld",(ans[n][0]<<1)%mod);
    return 0;
}
```

---

## 作者：Smokey_Days (赞：1)


这一题的题面很复杂，但形式化地概括则很简单：

对于一个长度为n的全排列，求出其中有多少排列A满足，对于任意i属于n，$$(A_{i}-A{i-1})*(A_{i}-A_{i+1})>=0;$$

然后我们观察排列的特点，我们可以发现，对于排列A中的一个元素$A_{i}$，我们可以发现，如果$A_{i}$是山峰，那么将$A_{i}$的值无论添加多少，都不改变这个序列的可居住性；对于山谷，则反之。
于是，我们可以发现，一个合法的排列，如果我们要在它末尾添上一个数让它形成一个新的合法排列，对于除了最后一个数以及这个数是属于山峰以及山谷以外，我们不关心其他的属性。 
因此我们可以用$f[i][j][k]$表达当前长度为i，最后一个数为j，最后一个数的状态为k的时候的状态数。其中k==0表示山谷，而k==1表示山峰。 
则很容易可以得到状态转移方程：
$$f[i][j][k]+=f[i-1][l][k\ xor\ 1](k?(0<l<=j-1):(j-1<l<=i))$$
但是这样子的复杂度是N^3的，对于4200的数据显然是不能通过的。这时候考虑优化。
我们发现求和的东西是一段区间，因此我们可以考虑前缀优化。
这样子就将复杂度从$n^3$降低到了$n^2$，于是可以通过。
但是这样子需要的空间是3E7的，对于128MB的空间是非常危险的，这时候考虑滚动数组优化，这样是可以通过的。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,p,f[4205][2],pre[4205][2];
void init(){
    scanf("%lld%lld",&n,&p);
    int l,r;
    f[1][1]=f[1][0]=pre[1][0]=pre[1][1]=1;
    for(int i=2;i<=n;++i){
        pre[i][0]=pre[i-1][0],pre[i][1]=pre[i-1][1];
        for(int j=1;j<=i;++j){
            for(int k=0;k<=1;++k){
                l=k?0:j-1;
                r=k?j-1:i;
                f[j][k]=(pre[r][k^1]-pre[l][k^1]+p)%p;
//                printf("(%d,%d)[%d,%d]%lld|",l,r,pre[l][k^1],pre[r][k^1],f[j][k]);
            }
//            printf(" ");
        }
        pre[0][0]=pre[0][1]=0;
        for(int j=1;j<=i;++j){
            pre[j][0]=(pre[j-1][0]+f[j][0])%p;
            pre[j][1]=(pre[j-1][1]+f[j][1])%p;
        }
//        puts("");
    }
    long long ans=(pre[n][0]+pre[n][1])%p;
    printf("%lld",ans);
}
int main(){
    init();
    return 0;
}

```

---

## 作者：chaijing (赞：1)

想了好久...姑且算是自己做出来了吧

dp状态比较容易想到： _dp[i][j]_ 表示用前i个数字，存在j个不合法段的方案数。

例如：1 2 3    有1个不合法段

1 2 3 4 5 有3个不合法段

1 2 3 6 5 4 有3个不合法段（1 2 3 6算两个，6 5 4算一个）

那么转移分三种：1.合法->合法，2.合法->不合法，3.不合法->合法

（大家操作一下会发现不合法->不合法是不存在的）

大力观察了一下，转移1每次都有两个位置可以放新数字（手玩一下！），转移3可取位置数就是 _dp[i][j]_ 中的j，剩下的位置就是转移2的位置。

~~啊啦啊啦，马上就上大学了好快乐呀~~




```cpp
//luogu P2467 [SDOI2010]地精部落
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn=4205;
LL dp[mxn][mxn]; //前i个数字，有j个不合法段的方案数 
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	dp[3][0]=4,dp[3][1]=2;
	for(int i=4;i<=n;i++)
	  for(int j=0;j<=i-2;j++)
	  {
	  	  dp[i][j]=(dp[i][j]+2*dp[i-1][j])%p;  //合法变合法
		  dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1))%p; //不合法变合法 
		  if(j) dp[i][j]=(dp[i][j]+dp[i-1][j-1]*(i-j-1))%p; //合法变不合法 
	  }
	printf("%lld\n",dp[n][0]);
	return 0;
}
```

---

## 作者：xyz32768 (赞：1)

题意：若序列$A$是$1$到$n$的一个排列，求满足$∀1<i<n,A[i-1]>A[i]<A[i+1]$或$A[i-1]<A[i]>A[i+1]$的序列$A$的个数。

解法：$DP$+前缀和优化。设$f[i][j]$为$i$个数的排列（只考虑相对大小），第$i$个数的**排名**（排名越前数值越大，数值最大的数排名为$1$）为$j$，且满足第$1$个数大于第$2$个数，第$2$个数小于第$3$个数，第$3$个数大于第$4$个数，第$4$个数小于第$5$个数，…的长度为$i$的序列个数。

边界条件为$f[1][1]=1$，当$i>1$时，转移为：

当$i$为奇数且$1<=j<i$时，$f[i][j]=sigma(f[i-1][k],j<=k<i)$。

当$i$为偶数且$1<j<=i$时，$f[i][j]=sigma(f[i-1][k],1<=k<j)$。

这里解释一下这个转移方程。

当$i$为奇数时，一定有$A[i-1]<A[i]$，也就是说$A[i-1]$在$i$个数的排名要比$A[i]$要靠后，这个定义也就等于$A[i-1]$在$A[1]...A[i-1]$中的排名必须大于等于$j$。所以此时$f[i][j]=sigma(f[i-1][k],j<=k<i)$。而$1<=j<i$就表示$A[i]不能为$A[1]...A[i]$的最小值，否则没有合法的$A[i-1]$。

当$i$为偶数时，一定有$A[i-1]>A[i]$，也就是说$A[i-1]$在$i$个数的排名要比$A[i]$要靠前，这个定义也就等于$A[i-1]$在$A[1]...A[i-1]$中的排名必须小于$j$。所以此时$f[i][j]=sigma(f[i-1][k],1<=k<j)$。而$1<j<=i$就表示$A[i]$不能为$A[1]...A[i]$的最大值，否则没有合法的$A[i-1]$。

再设$g[i][j]$为$i$个数的排列（我在这里不知道把$f$和$g$都存下来会不会爆空间，所以我把$f$算了两遍，第二遍算的就是$g$，具体看代码），第$i$个数的排名为$j$，且满足第$1$个数小于第$2$个数，第$2$个数大于第$3$个数，第$3$个数小于第$4$个数，第$4$个数大于第$5$个数，…的长度为$i$的序列个数，边界也是$g[1][1]=1$，$i>1$时的转移方程为：当$i$为偶数且$1<=j<i$时，$g[i][j]=sigma(g[i-1][k],j<=k<i)$，当$i$为奇数且$1<j<=i$时，$g[i][j]=sigma(g[i-1][k],1<=k<j)$，推理和$f$一样。

对于$DP$中的求和计算，可以利用前缀和进行优化。

最后答案为$sigma(f[n][i],1<=i<=n)+sigma(g[n][i],1<=i<=n)$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 4205;
int n, PYZ, f[N][N], sm[N];
int main() {
    int i, j, ans = 0, sig;
    n = read(); PYZ = read();
    f[1][1] = sm[1] = 1;
    for (i = 2; i <= n; i++) {
        sig = i & 1; if (sig) for (j = 1; j < i; j++)
            f[i][j] = (sm[i - 1] - sm[j - 1] + PYZ) % PYZ;
        else for (j = 2; j <= i; j++)
            f[i][j] = (sm[j - 1] - sm[0] + PYZ) % PYZ;
        sm[0] = 0; for (j = 1; j <= i; j++)
            sm[j] = (sm[j - 1] + f[i][j]) % PYZ;
    }
    for (i = 1; i <= n; i++) (ans += f[n][i]) %= PYZ;
    memset(f, 0, sizeof(f)); f[1][1] = sm[1] = 1;
    for (i = 2; i <= n; i++) {
        sig = i & 1; if (!sig) for (j = 1; j < i; j++)
            f[i][j] = (sm[i - 1] - sm[j - 1] + PYZ) % PYZ;
        else for (j = 2; j <= i; j++)
            f[i][j] = (sm[j - 1] - sm[0] + PYZ) % PYZ;
        sm[0] = 0; for (j = 1; j <= i; j++)
            sm[j] = (sm[j - 1] + f[i][j]) % PYZ;
    }
    for (i = 1; i <= n; i++) (ans += f[n][i]) %= PYZ;
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：xuxinyu (赞：1)

题意：求波动序列的个数


首先，了解波动序列的对称性


序列如果为 1 4 2 5 3


对称序列为 5 2 4 1 3


如果原序列开始递减，那么同n+1减每个数，就变成了递减序列的对称递增序列


所以我们只需要求递减序列，乘2就是总个数


dp[i][j] 表示 前i个数的排列中，第1个数为j，且开始递减的序列个数


f[i][j] 表示 前i个数的排列中，第1个数为j，且开始递增的序列个数


当第1个数是j时，后面可以填1,2,3，……j-1，j+1，j+2……n


把>j的每个数-1，就是1,2,3，……j-1，j，j+1，j+2……n-1


即变成了n-1的排列


如果开始递减


当第1个数是j时，将>j的数全部-1，那么后面可以填的数就是一个n-1的排列


这个排列要求 第一个数<j，且开始递增


即dp[i][j]= Σ f[i-1][k]  k∈[1,j-1]


根据对称性，dp[i][j]= Σdp[i-1][k]  k∈[i-j+1,i-1]


时间复杂度：O（n^3），空间复杂度：O（n^2）


使用前缀和优化，可以 优化到时间O（n^2）,空间O（n）


代码请转至 http://www.cnblogs.com/TheRoadToTheGold/p/7305170.html


---

## 作者：aiyougege (赞：1)

看题目大概可以明白

这个题目要求求 1-n的全排列中为抖动序列的排列个数

还要mod P 得出答案

 
抖动排列 根据字面意思

就是 排列中的一个数两边的数都同时比这个数大或者小

如果是排列两端的数 就没限制了，可以任意大小

 
如果一个一个枚举所有排列的话

长度为n的全排列有 n!

这个题数据是 n<=4200

 
4200的阶乘的话，大概有4094位

一般计算机每秒计算也就是 1e9-10 次

肯定会超时

 
所以就要采用更加快速的方法

 
三个引理

大神推出三个引理

 
1、在n->n-1的转化过程中，我们删除了一个点后，我们可以将n-1个点视为仍是1~n-1的排列。

2、在若排列Pn为一个合法抖动子序列，则交换i∈[1,n)与i+1,必能得到另一个抖动子序列。

3、抖动序列的对称性，若存在第一段上升的长度为n的抖动子序列，则以n+1-x代x必能得到一个第一段下降的长度为n的抖动子序列。

设f[i][j]为长度为i的，以j开头的，第一段下降的抖动子序列的个数，则循题意可得2\*f[n+1][n+1]即为答案。

 
思路
根据上述三个引理

设 f [i] [j] 为 排列 [ 1 , i ] 中开头为 j 的且第一段上升的方案数

这个方案数可以递推而来

根据引理,

如果j 和 j-1 不相邻 , 把抖动序列中的 j 和 j-1 交换仍然得到一个抖动序列,而且是一一对应的

或者j 和 j-1 相邻 ,这部分方案数来自于 f [ i-1 , i-j+1]

去掉 j ,则区间变为[1,j-1]并[j+1,i]

把[j+1,i]下移一位,则变为[1,i-1],那么只要再求出这部分第一段下降的方案数即可

根据 引理3,   求出f[i-1][(i-1)-(j-1)+1]加上即可

 
最后<<1

是因为我们求的是第一部分为上升的

下降只需引理3一遍就可以

 
 
则方程 f[i][j]=f[i][j-1]+f[i-1][i-j+1];

 
初始化:f[1][1]=1;

 
在洛谷上用 int 做这个题只能过4个点

换成 long long 即可全部通过

 
  
  
  
 
```cpp
#include<iostream> 
#include<string> 
#include<cstdio> 
#define N 42005 
using namespace std; 
typedef long long LL; 
LL ans; 
int n,p; 
LL f[2][N]; 
int main() 
{ 
    scanf("%d%d",&n,&p); 
    f[1][1]=1; 
    bool q; 
    for(int i=2;i<=n;++i) 
    { 
        q=i&1; 
        for(int j=1;j<=i;++j) 
            f[q][j]=LL(f[q][j-1]+f[!q][i-j+1])%p; 
    } 
    for(int i=1;i<=n;++i) 
        ans=LL(ans+f[q][i])%p; 
    printf("%lld",(ans<<1)%p); 
    return 0;  
} 
```
其中一份,最后把长度为 n 的第一个数枚举一遍加上即为ans
 
  
  
  
 
```cpp
#include<iostream> 
#include<string> 
#include<cstdio> 
#define N 42005 
using namespace std; 
typedef long long LL; 
int ans; 
int n,p; 
int f[2][N]; 
int main() 
{ 
    scanf("%d%d",&n,&p); 
    f[1][1]=1; 
    bool q; 
    for(int i=2;i<=n+1;++i) 
    { 
        q=i&1; 
        for(int j=1;j<=i;++j) 
            f[q][j]=(f[q][j-1]+f[!q][i-j+1])%p; 
    } 
    printf("%d",(f[q][n+1]<<1)%p); 
    return 0;  
} 
```
另一份差不多
求的是n+1的序列

因为n+1第一个数是什么根本无所谓

而且包含着n的所有方案

所以不用最后累加


---

## 作者：_HLLY_ (赞：1)

其实这个题第一眼是没有任何思路的


强行无视题解，经过漫长的找规律，终于推出了一个可行的方法：


f[i][0/1]i表示最高位的数字，0表示开始是上升，1表示开始是下降。


为什么会推出这个？


1、因为所谓抖动序列和每个数的具体值没有关系，只与它的大小有关系，


2、在下一个循环中，枚举开头数字，所以只和上一种情况的最高位有关，在数位依次递增的时候循环开头的每个情况即可。


例：        若为1、 2、 3、 4、 5：


开始是2，    后面是1、 3、 4、 5，分别对应4个数时的1 、2、 3、 4；


转移条件即为上一次递推 <2 上升 作为最高位为 2 的下降方案数


上一次递推 >=2 下降 作为最高位为 2 的上升方案数


在搞上前缀和+后缀和优化，减掉一维 就可以n^2出解   （强行无视巨大的常数）


代码：


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,p,dowh,ans,i,f[2][5000][2],j;
int main()
{
    scanf("%d%d",&n,&p);
    dowh=1;
    f[0][1][0]=1;
    f[0][1][1]=1;
    f[0][2][1]=1;
    f[0][2][0]=1;
    for(i=3;i<=n;i++,dowh^=1)
    {
        for(j=1;j<=i;j++)
        f[dowh][j][0]=f[dowh^1][j][1];
        for(j=1;j<=i;j++)
        f[dowh][j][1]=f[dowh^1][j-1][0];
        if(i!=n)
        {
        for(j=i;j>=1;j--)
        f[dowh][j][1]=(f[dowh][j][1]+f[dowh][j+1][1])%p;
        for(j=1;j<=i;j++)
        f[dowh][j][0]=(f[dowh][j][0]+f[dowh][j-1][0])%p;
}
    }
    dowh^=1;
    for(i=1;i<=n;i++)
    {
        ans+=f[dowh][i][0];
        ans%=p;
        ans+=f[dowh][i][1];
        ans%=p;
    }
    cout<<ans%p;
}
```

---

## 作者：eternal (赞：1)

很容易想到一个比较基本的做法：f[i][j]表示前i个中，最后一个为j，两边比j小，g[i][j]表示，前i个，最后一个为j，两边都比j高；

则f[i][j]=g[i-1][k](0<k<j);g[i][j]=f[i-1][k](j<k<n)

然后发现可以直接定义e[i][j]为前i个最后的数字为1~j，两边比j小的情况和，那么e[i][j]=e[i-1][j]+e[i][j-1]

然后可以发现这是对称的。。。

即a1,a2,a3,a4,a5是递增的，则n+1-a1,n+1,a2,n+1-a3,n+1-a4,n+1-a5是递减的，而且是一一对应的；

则f[i][j]=g[i][i+1-j]

那么最后答案就需要乘2即可。。

/\*
ID:Agreement

LANG:C++

\*/
```cpp
// Invincible
#include <bits/stdc++.h>
#define rep( i , l , r ) for( int i = (l) ; i <= (r) ; i++ )
#define per( i , r , l ) for( int i = (r) ; i >= (l) ; i-- )
#define erep( i , u ) for( int i = head[(u)] ; ~i ; i = e[i].nxt )
using namespace std;
inline int _read(){
    register int x = 0 , f = 1;
    register char ch = getchar();
    while( ch > '9' || ch < '0' ) { if( ch == '-' ) f = -1; ch = getchar(); }
    while( ch >= '0' && ch <= '9' ){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int maxn = 10000 + 5;
int f[2][maxn];
int main(){
    int N = _read() , p = _read() , x = 0;
    f[0][2] = 1;
    rep( i , 3 , N + 1 ){
        x = i & 1;
        rep( j , 1 , i ) f[x][j] = (f[x][j - 1] + f[!x][i - j + 1]) % p;
    }
    cout << ( f[x][N] * 2 ) % p << endl; 
    return 0;
}
```

---

## 作者：raincity (赞：0)

[更好的阅读体验](https://blog.calvincheng1231.org.cn/default/69.html)

## 分析
感觉这个思路比较正常，常数也不大。

首先这是个明显的 DP 题。

显然至少应该设 $dp_{i,j}$ 为前 $i$ 个数的排列中，以 $j$ 结尾的方法数。

发现不好转移，因为无法判断最后一个数和倒数第二个数之间的大小关系。

扩充一下 DP 状态：设 $dp_{i,j,0/1}$ 为前 $i$ 个数的排列中，以 $j$ 结尾的方法，最后一个数比前一个数小/大的方法数。

转移方程显然：

$$dp_{i,j,0}=\sum_{k=j}^{i-1}dp_{i-1,k,1}$$

$$dp_{i,j,1}=\sum_{k=1}^{j-1}dp_{i-1,k,0}$$

（考虑最后一个数插入的位置即可）

这样转移是 $O(n^3)$ 的，可能可以 70 分。

考虑优化一下。显然 $dp_{i,j,0/1}$ 转移只和 $dp_{i-1,k,0/1}$ 中连续的一段有关。可以滚动数组 & 前缀和优化。

时间复杂度 $O(n^2)$。

## 解决
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 4205;
int dp[N][2], sum[N][2], n, p;

int main() {
    cin >> n >> p;
    dp[1][0] = dp[2][1] = 1;
    for (int i = 3; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            sum[j][0] = (sum[j - 1][0] + dp[j][0]) % p;
            sum[j][1] = (sum[j - 1][1] + dp[j][1]) % p;
        }
        for (int j = 1; j <= i; j++) {
            dp[j][0] = (sum[i - 1][1] - sum[j - 1][1] + p) % p;
            dp[j][1] = sum[j - 1][0];
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) ans = (ans + (dp[i][0]+ dp[i][1]) % p) % p;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：devout (赞：0)

**description**

求长度为 $n$ 的每个位置都是极值的排列的个数对 $p$ 取模的结果。

$n\leq 4200$

**solution**

我们观察发现，对于一个最开始是极大值的满足条件的序列，如果把整个序列翻过来，即 $a_i=n+1-a_i$ 时，一定也是可以的。

所以我们只需要求第一个位置为极大值的序列个数。

设 $f_i$ 表示一个 $1$ 到 $i$ 的排列，第一个位置为极大值的方案数。

考虑将这些数从小到大放进去，考虑到 $i$ 时，设他排在第 $j$ 个位置，那么可以得到转移

$$f_i=\sum_{j=1,j\bmod 2=1}^i f_{j-1}\times f_{i-j}\times\binom{i-1}{j-1}$$

这样的转移就是 $O(n^2)$ 的了，只需要最后 $\times 2$ 就可以了

**code**

```cpp
# include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(register int i=a;i<=b;i++)
# define _Rep(i,a,b) for(register int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=4205;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int f[N];
int C[2][N];

int main()
{
	read(n),read(m);
	f[0]=1;
	C[0][0]=C[1][0]=1;
	Rep(i,1,n){
		Rep(j,1,i)
			if(j&1)(f[i]+=1ll*f[j-1]*f[i-j]%m*C[i&1^1][j-1]%m)%=m;
		Rep(j,1,i)C[i&1][j]=(C[i&1^1][j]+C[i&1^1][j-1])%m;
		C[i&1][0]=1;
	}
	printf("%d\n",2*f[n]%m);
	return 0;
}
```


---


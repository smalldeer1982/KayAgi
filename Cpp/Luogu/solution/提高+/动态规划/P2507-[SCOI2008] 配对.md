# [SCOI2008] 配对

## 题目描述

你有 $n$ 个整数 $A_i$ 和 $n$ 个整数 $B_i$。你需要把它们配对，即每个 $A_i$ 恰好对应一个 $B_{p[i]}$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如 $A = \{5, 6, 8\}$，$B = \{5, 7, 8 \}$，则最优配对方案是 $5 \sim 8$、$6 \sim 5$、$8 \sim 7$，配对整数的差的绝对值分别为 $3, 1, 1$，和为 $5$。注意，$5 \sim 5$、$6 \sim 7$、$8 \sim 8$ 是不允许的，因为相同的数不许配对。


## 说明/提示

$30 \%$ 的数据满足：$n \le {10}^4$；  
$100 \%$ 的数据满足：$1 \le n \le {10}^5$，$A_i$ 和 $B_i$ 均为 $1$ 到 ${10}^9$ 之间的整数。


## 样例 #1

### 输入

```
3
3 65
45 10
60 25
```

### 输出

```
32
```

## 样例 #2

### 输入

```
3
5 5
6 7
8 8
```

### 输出

```
5
```

# 题解

## 作者：浅色调 (赞：44)

### Solution：

　　这个贪心神了。。。`～`

　　我们首先考虑没有限制条件，即不需要满足配对时$a_i\neq b_i$这个条件，那么很容易想到贪心的思路，直接对$a,b$从小到大排一遍序，然后累加同项之差相减的绝对值即可。

　　但是现在有了限制，各种方法骚，没有刚过，感觉完全不可做。

　　后面仔细看题，发现一个超级重要的条件，保证$a$中数各不相同，$b$中数各不相同。

　　那么就好搞了，我们先对$a,b$各自从小到大排一遍序，然后进行以下操作：

　　首先考虑输出$-1$的情况：很显然只有当序列长度为$1$且$a_1=b_1$时无解，因为当$n\geq 2$时，由于数各不相同，那么同一个数$a,b$中顶多各自出现一次，我们就可以用后面的数和前面的数配对（显然一定不会相等）。

　　其次，当有解时，我们贪心的想到，因为每个数顶多在$a,b$中各出现一次，所以当某次$a_i=b_i$时，则$a_i\neq b_{i-1}$且$a_i\neq b_{i+1}$（$b_i$同理），于是我们可以让其和$a_{i-1},b_{i-1}$或者$a_{i+1},b_{i+1}$搭配，或者三个互相搭配，在中间取最小值就好了。（**即使这三对数，每对相同，但由于$a,b$中数各自不同，那么这三对数一定可以搭配出两两不同的情况**）

　　那么由于前两次需要判断边界，且$i+1$可能越界。于是将过程改为$a_i,a_{i-1},a_{i-2}$三个比较取最小值（都一样的）。

　　排序后，求解的整个过程是线性的，于是用$DP$的思想来转移实现。

 　　定义状态$f[i]$表示前$i$个配对能得到的最小值，因为每次转移是三个比较，则初值$f[1]=|a_1-b_1|$，$f[2]=min(f[1]+|a2-b2|,|a1-b2|+|a2-b1|)$（**注意当配对的两个数相等时，将其算出的值赋为$inf$**）。

　　那么不难得出状态转移方程：

　　$f[i]=f[i-1]+|a_i-b_i|$（直接配对$a_i$和$b_i$）

　　$f[i]=min(f[i],f[i-2]+|a_i-b_{i-1}|+|a_{i-1}-b_i|)$（$i$和$i-1$配对）

　　$f[i]=min(f[i],f[i-3]+|a_i-b_{i-2}|+|a_{i-1}-b_{i-1}|+|a_{i-2}-b_i|)$（三个配对时，让$i$和$i-2$配对）

　　$f[i]=min(f[i],f[i-3]+|a_i-b_{i-2}|+|a_{i-1}-b_i|+|a_{i+1}-b_{i-1}|)$（三个配对时，$a,b$两两匹配的一种情况）

　　$f[i]=min(f[i],f[i-3]+|a_i-b_{i-1}|+|a_{i-1}-b_{i-2}|+|a_{i+1}-b_i|)$（三个配对时，$a,b$两两匹配的另一种情况）

　　最后目标状态$f[n]$就是答案。

$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9116359.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）
### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Min(a,b) ((a)>(b)?(b):(a))
#define la(a,b) ((a!=b)?((a-b)>0?(a-b):(b-a)):233333333)
using namespace std;
const int N=100005;
ll n,f[N],a[N],b[N];

il int gi(){
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+x-48,x=getchar();
    return f?-a:a;
}

int main(){
    n=gi();
    For(i,1,n) a[i]=gi(),b[i]=gi();
    sort(a+1,a+n+1);sort(b+1,b+n+1);
    if(a[1]==b[1]&&n==1){cout<<-1;return 0;}
    f[1]=la(a[1],b[1]);
    f[2]=Min(f[1]+la(a[2],b[2]),la(a[1],b[2])+la(a[2],b[1]));
    For(i,3,n){
        f[i]=f[i-1]+la(a[i],b[i]);
        f[i]=Min(f[i],f[i-2]+la(a[i],b[i-1])+la(a[i-1],b[i]));
        f[i]=Min(f[i],f[i-3]+la(a[i],b[i-2])+la(a[i-2],b[i])+la(a[i-1],b[i-1]));
        f[i]=Min(f[i],f[i-3]+la(a[i],b[i-1])+la(a[i-1],b[i-2])+la(a[i-2],b[i]));
        f[i]=Min(f[i],f[i-3]+la(a[i],b[i-2])+la(a[i-1],b[i])+la(a[i-2],b[i-1]));
    }
    cout<<f[n];
    return 0;
}
```

---

## 作者：蒟蒻中的zzh (赞：4)

这题我们看第一眼都可以想到一个贪心的东西：如果没有被不能把相同的数字配对限制住的话，我们可以直接对 $a$ 数组和 $b$ 数组排个序，然后从第一个配对到最后一个就好了。那么现在我们考虑的是被限制住的话要怎么办。

首先，假设现在我们配对到了第 $i$ 个，现在 $a_i = b_i$。那么，如果上一对配对是 $a_{i-1}$ 和 $b_{i-1}$ 配对的话，我们可以直接把 $a_{i-1}$ 和 $b_{i-1}$ 拆开，把 $i-1$ 和 $i$ 交叉配对。用图表示出来就是这样的（连线表示配对，`=` 表示 $a = b$）：

![](https://s1.ax1x.com/2023/01/06/pSEYwSU.png)

另一种情况就是 $a_{i-1} = b_{i-1}$，且 $i-1$ 还没有配对（没有找到合适的位置配对），那么我们同样是让 $i-1$ 和 $i$ 交叉配对：

![](https://s1.ax1x.com/2023/01/06/pSEYsm9.png)

接下来就是 $i-1$ 和 $i-2$ 交叉配对的情况，我们就需要让他们三个交叉配对：

![](https://s1.ax1x.com/2023/01/06/pSEtSmj.png)

那有没有可能有四个交叉配对的情况呢？显然不可能，因为如果真的是四个交叉配对的话我们可以把他拆成两个交叉配对，这样子的答案还更小。五个同理。那么，我们就用三种情况概括了 $a_i = b_i$ 的情况。那么接下来分类讨论就行了

吧？

貌似不行，因为这样子的话还是可能出错，因为我们记录了每一步的状态（及每一个 $a_i$ 和哪一个 $b_i$ 配对），但是我们当前的最优状态可能用在下一步**转移**的时候就不是最优结果了。我们前面的分析只能保证在当前**状态**下是最优的。

那我们记录每一种状态的最优解再来**转移**？等等，这不就变成 dp 了吗？我们可以压一压状态吗（前面的状态太难转移了）。

发现是 dp 之后，我们就很容易可以想到怎么压状态了：直接设 $f_i$ 表示配对到第 $i$ 对时的最优答案是多少。其实前面的具体状态对我们来说不是很重要，因为每一种情况都可以进行那三种转移，我们只需要在三种转移中取最小值就好了。

[AC 记录](https://www.luogu.com.cn/record/98843112)

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e5+5;
int a[N],b[N],f[N],n;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i]>>b[i];
	if(n==1&&a[1]==b[1]){
		cout<<-1<<endl;
		return 0;
	}
	sort(a+1,a+n+1);sort(b+1,b+n+1);
	memset(f,127,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;++i){
		if(f[i-1]!=f[N-1]&&a[i]!=b[i])
			f[i]=f[i-1]+abs(a[i]-b[i]);
		if(f[i-2]!=f[N-1]&&a[i]!=b[i-1]&&a[i-1]!=b[i])
			f[i]=min(f[i],f[i-2]+abs(a[i]-b[i-1])+abs(a[i-1]-b[i]));
		if(f[i-3]!=f[N-1]){
			if(a[i]!=b[i-2]&&a[i-2]!=b[i]&&a[i-1]!=b[i-1])
				f[i]=min(f[i],f[i-3]+abs(a[i]-b[i-2])+abs(b[i]-a[i-2])+abs(a[i-1]+b[i-1]));
			if(a[i]!=b[i-2]&&a[i-2]!=b[i-1]&&a[i-1]!=b[i])
				f[i]=min(f[i],f[i-3]+abs(a[i]-b[i-2])+abs(a[i-2]-b[i-1])+abs(a[i-1]-b[i]));
			if(a[i-2]!=b[i]&&a[i-1]!=b[i-2]&&a[i]!=b[i-1])
				f[i]=min(f[i],f[i-3]+abs(a[i-2]-b[i])+abs(a[i-1]-b[i-2])+abs(a[i]-b[i-1]));
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```

---

## 作者：MD_17L (赞：3)

## DP
1. 如果n==1并且a[1]==b[1]时,无法配对
2. 将a,b数组分别由小到大排序
 	- 此时按顺序两两取绝对值,总和最小
	- but可能有相等的情况,所以需要交换
	- 此时交换的范围越小,绝对值和越小
	- 只考虑3个之间的交换(玄学)
- 例如
- a1-b1
- a1-b2,a2-b1(两两交换)
- a1-b2,a2-b3,a3-b1(3个之间的交换)
- a1-b3,a2-b1,a3-b2(3个之间的交换) 


 附上代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=100005;
const long long M=1e13;
int a[N],b[N],n;
long long f[N],ans;

 long long Min(long long a,long long b)
{
	if (a<b) return a;
	return b;
}
 long long js(int l,int r)
{
	if (a[l]==b[r]) return M;
	return abs(a[l]-b[r]);
}
 int main()
{
	scanf("%d",&n);
	for (int i=1; i<=n; i++) scanf("%d%d",&a[i],&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	if (n==1&&a[1]==b[1]) printf("-1\n");
	else
	{
		f[0]=0;
		for (int i=1; i<=n; i++)
		{
			ans=M;
			if (i>=1) ans=Min(ans,f[i-1]+js(i,i)); 
			if (i>=2) ans=Min(ans,f[i-2]+js(i-1,i)+js(i,i-1));
			if (i>=3) 
			{
				ans=Min(ans,f[i-3]+js(i-2,i-1)+js(i-1,i)+js(i,i-2));
				ans=Min(ans,f[i-3]+js(i-2,i)+js(i-1,i-2)+js(i,i-1));
			} 
			f[i]=ans;
		}
		printf("%lld\n",f[n]);
	}
	return 0;
}
```


---

## 作者：Tgotp (赞：2)

沙茶了。没看到a中，b中元素互不相同，还想用费用流做。。。。


令f[i]表示在 i 位置时最小话费。


首先放结论：


对于一个位置，最优情况只会是a[i]对应b[i],b[i-1],b[i-2]组合的情况。


证明：


对于一个位置，若a[i]与b[i-3]组合 ， 那么(a[i-1] - b[i-3]) < (a[i] - b[i-3])


所以更优秀的可以用a[i-1]替换a[i]，然后把a[i-1]对应的b[j]对应到a[i]上。


并且肯定能满足a[i] != b[j] && b[i-3] != a[k]


然后对于a[i]对应b[i],b[i-1],b[i-2]组合的情况分别讨论。


然后扫一遍就好了。


强迫症，套了滚动数组

[蒟蒻代码](http://tgotp.science/1237-scoi2008%E9%85%8D%E5%AF%B9/)


---

## 作者：eternal (赞：2)

不难发现，a和b匹配的最远距离不会超过2位，否则肯定不是最优解，这样就可以直接递推过去了

```cpp
// Invincible
#include <bits/stdc++.h>
#define rep( i , l , r ) for( int i = (l) ; i <= (r) ; ++i )
#define per( i , r , l ) for( int i = (r) ; i >= (l) ; --i )
#define erep( i , u ) for( int i = head[(u)] ; ~i ; i = e[i].nxt )
using namespace std;
inline int _read(){
    register int x = 0 , f = 1;
    register char ch = getchar();
    while( ch > '9' || ch < '0' ) { if( ch == '-' ) f = -1; ch = getchar(); }
    while( ch >= '0' && ch <= '9' ){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
typedef long long ll;
const ll INF = 0x7f7f7f7f7f7fll;
inline ll calc( const int &x , const int &y ){
    return x == y ? INF : (ll)abs( x - y );
}
const int maxn = 2 * 1e5;
ll f[maxn];
int a[maxn] , b[maxn];
int main(){
    int N = _read();
    rep( i , 1 , N ) a[i] = _read() , b[i] = _read();
    sort( a + 1 , a + N + 1 );
    sort( b + 1 , b + N + 1 );
    f[1] = calc( a[1] , b[1] );
    f[2] = min( f[1] + calc(a[2] , b[2]) , calc(a[1] , b[2]) + calc(a[2] , b[1]));
    rep( i , 3 , N ){
        f[i] = f[i - 1] + calc( a[i] , b[i] );
        f[i] = min( f[i] , f[i - 2] + calc(a[i - 1] , b[i]) + calc(a[i] , b[i - 1]));
        f[i] = min( f[i] , f[i - 3] + calc(a[i - 2] , b[i - 1]) + calc(a[i - 1] , b[i]) + calc(a[i] , b[i - 2]));
        f[i] = min( f[i] , f[i - 3] + calc(a[i - 2] , b[i]) + calc(a[i - 1] , b[i - 1]) + calc(a[i] , b[i - 2]));
        f[i] = min( f[i] , f[i - 3] + calc(a[i - 2] , b[i]) + calc(a[i] , b[i - 1]) + calc(a[i - 1] , b[i - 2]));
    }
    if( f[N] >= INF ) puts("-1");
    else cout << f[N] << endl;  
    return 0;
}

```

---

## 作者：yx666 (赞：0)

# P2507 [SCOI2008] 配对题解
[题面传送门](https://www.luogu.com.cn/problem/P2507)
## Part 1：题意
### Part 1.1：题目内容
给定两个长度为 $n$ 的数列 $a$ 和 $b$，满足同一数列中元素互不相同。

求将数列 $a$ 随机打乱后，并满足 $\forall i\in[1,n]$，$a_i\ne b_i$ 时，$\sum_{i=1}^n \left|a_i-b_i\right|$ 的最小值。

### Part 1.2：限制
- $n\in[1,10^5]$。

- $\forall i\in[1,n],a_i,b_i\in[1,10^9]$。

- 时间：$1$ s，空间 $125$ MB，所有输入均为整数。

## Part 2：思路
考虑 dp。

### Part 2.1：定义问题状态
对 $a$、$b$ 进行排序，接着设 $f_k$ 表示将前 $k$ 对数配对后的最小值，即：

$$f_k=\begin{cases}\sum_{i=1}^k \left|a_i-b_i\right|\qquad&\forall i\in[1,k]，a_i\ne b_i
\\\inf &\text{otherwise} \end{cases}$$

### Part 2.2：状态转移方程
定义函数 $ckabs$：

$$ckabs(x)=\begin{cases}\left|x\right|& x\ne0\\\inf &x=0
\end{cases}$$

#### Part 2.2.1：$a_i$ 与 $b_i$ 配对：
$$f_i=f_{i-1}+ckabs(a_i-b_i)$$ 

#### Part 2.2.2：$a_i,a_{i-1}$ 与 $b_i,b_{i-1}$ 相互配对：
此时只用考虑 $(a_i,b_{i-1})$ 与 $(a_{i-1},b_i)$：

$$f_i=\min(f_i,f_{i-2}+ckabs(a_i-b_{i-1})+ckabs(a_{i-1}-b_i))$$

#### Part 2.2.3：三对数配对：
借助贪心的思想，发现：对于 $a_i\footnotesize(i\in[2,n-1])$ 最优的搭配，是将它与 $b_{i-1}$、$b_i$ 或 $b_{i+1}$ 搭配时（即让 $a_{i-1},a_i,a_{i+1}$ 与 $b_{i-1},b_i,b_{i+1}$ 互相搭配，花费最小时就是最优搭配）。

改一下下标，有以下三种搭配：

1. $(a_i,b_{i-1}),(a_{i-1},b_{i-2}),(a_{i-2},b_i)$。
2. $(a_i,b_{i-2}),(a_{i-1},b_{i-1}),(a_{i-2},b_i)$。
3. $(a_i,b_{i-2}),(a_{i-1},b_i),(a_{i-2},b_{i-1})$。

得到状态转移方程：

$$f_i=\begin{cases}\min(f_i,f_{i-3}+ckabs(a_i-b_{i-1})+ckabs(a_{i-1},b_{i-2})+ckabs(a_{i-2},b_i))\\
\min(f_i,f_{i-3}+ckabs(a_i-b_{i-2})+ckabs(a_{i-1},b_{i-1})+ckabs(a_{i-2},b_i))\\
\min(f_i,f_{i-3}+ckabs(a_i-b_{i-2})+ckabs(a_{i-1},b_{i})+ckabs(a_{i-2},b_{i-1}))\end{cases}$$

#### Part 2.2.4：四对数配对
可以证明这重复了，因为四对数可以被拆成两个两对数。

### Part 2.3：初始化与边界状态
- 初始化：注意下标，对 $f_1$，$f_2$ 特殊关照：

$$f_1\gets ckabs(a_1-b_1)\\f_2\gets\min(f_1+ckabs(a_2-b_2),ckabs(a_1-b_2)+ckabs(a_2-b_1))$$

- 边界状态：$i=n$。

### Part 2.4：计算顺序与答案
- 计算顺序：$1\to n$。

- 答案：$f_n$（对于题目中所说的不成立的情况，只有在 $n=1$ 且 $a_1=b_1$ 是才会出现，特判一下就 OK）。

## Part 3：代码实现
注意开 `long long`。

``` cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

#define T int
inline T read(){T x=0;char ch=getchar();while(ch<'0'||'9'<ch) ch=getchar();while('0'<=ch&&ch<='9') {x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}return x;}
void write(T x){if(x>9) write(x/10);putchar(x%10+'0');return ;}
#undef T

constexpr int inf=0x3f3f3f3f;

inline int min(int x,int y){return x<y?x:y;}

#define N 100005
#define pii pair<int,int>

int n;
int a[N],b[N],f[N];
signed main(){
	n=read();
	for(int i=1;i<=n;++i){
		a[i]=read(),b[i]=read();
	}
	if(n==1){
		if(a[1]==b[1]) puts("-1");
		else write(abs(a[1]-b[1]));
		return 0;
	}
	
	sort(a+1,a+1+n),sort(b+1,b+1+n);
	
	auto ckabs=[](int x){return x==0?inf:x<0?-x:x;};
	
	f[1]=ckabs(a[1]-b[1]);
	f[2]=min(f[1]+ckabs(a[2]-b[2]),ckabs(a[1]-b[2])+ckabs(a[2]-b[1]));
	for(int i=3;i<=n;++i){
		f[i]=f[i-1]+ckabs(a[i]-b[i]);
		f[i]=min(f[i],f[i-2]+ckabs(a[i]-b[i-1])+ckabs(a[i-1]-b[i]));
		f[i]=min(f[i],f[i-3]+ckabs(a[i]-b[i-1])+ckabs(a[i-1]-b[i-2])+ckabs(a[i-2]-b[i]));
		f[i]=min(f[i],f[i-3]+ckabs(a[i]-b[i-2])+ckabs(a[i-1]-b[i-1])+ckabs(a[i-2]-b[i]));
		f[i]=min(f[i],f[i-3]+ckabs(a[i]-b[i-2])+ckabs(a[i-1]-b[i])+ckabs(a[i-2]-b[i-1]));
	}
	write(f[n]);
	return 0;
}
```

[AC 记录（提交时最优）](https://www.luogu.com.cn/record/158756882)。

---

## 作者：Parrhesiates (赞：0)

典型的自己想破脑袋也不会，但一看题解秒会的题目。

这题第一眼看就大概有一个贪心的思路了，首先排序，然后每位依次匹配就好了，但是题目有个限制条件 $a_i \ne b_i$，这就有些难搞了，接下来讨论一下如果遇到相等的情况该如何匹配。

首先，肯定能想到进一步的贪心做法，如果某一位对应相等，那我们就在前面找一位或者后面找一位换一下，但是这样的话需要处理的就比较多了。

那么我们考虑 dp ，这里的 dp 定义较为简单，就不展开了，重点讲一下怎么转移，按上面的方法转移肯定是没法写的，因为你无法保证你前后前后交换之后没有相同的，既然不能前后来回换，为什么不能直接在最后面处理呢，要知道我们写的是 dp 啊。

这里又有另外一个贪心，一个数肯定是和离得越近的数配越好，同时相邻三个数必然存在一种配对方式，那么就知道了，每个数只可能和它前面的一个配或者和后面一个配。

到这里就解决了，我们在计算的时候给相等的数定义一个极大值，那么就可以选择性避开不合法的配对了。

顺便提一嘴关于 $-1$ 的判断，这个好想啊，由于每个数都不同，那么除非你只有一个数并且 $a_1 = b_1$ 才会输出 $-1$，特判一下就好了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,inf=1e9+7;
int n,a[N],b[N],dp[N];
inline int cal(int x,int y){
	return x==y?inf:abs(x-y);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i]>>b[i];
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	if(n==1&&a[1]==b[1]){cout<<-1;return 0;}
	dp[1]=cal(a[1],b[1]);
	dp[2]=min(dp[1]+cal(a[2],b[2]),cal(a[1],b[2])+cal(a[2],b[1]));
	for(int i=3;i<=n;++i){
		dp[i]=dp[i-1]+cal(a[i],b[i]);
		dp[i]=min(dp[i],dp[i-2]+cal(a[i-1],b[i])+cal(a[i],b[i-1]));
		dp[i]=min(dp[i],dp[i-3]+cal(a[i-2],b[i-1])+cal(a[i-1],b[i])+cal(a[i],b[i-2]));
		dp[i]=min(dp[i],dp[i-3]+cal(a[i-2],b[i])+cal(a[i-1],b[i-2])+cal(a[i],b[i-1]));
	}
	cout<<dp[n];
	return 0;
}
```

---


# [HAOI2010] 计数

## 题目描述

现在给定一个数，你可以删掉这个数中的任意多个数位 $0$（或不删）并将其他的数位任意重新排序。请求出能产生出多少个不同的这个数小的数（注意这个数不会有前导 0）。


## 说明/提示

$n$ 的长度不超过 $50$，答案不超过 $2^{63}-1$。

样例解释：$12,21,102,120,201,210,1002,1020$。

## 样例 #1

### 输入

```
1020```

### 输出

```
7```

# 题解

## 作者：巨型方块 (赞：69)

https://www.luogu.org/problem/show?pid=2518

对于一个数，把其中的0删掉，相当于把0放到了前面；

所以这个问题就是让我们求一下给我们的数的全排列比当前小的有几个；

我们假设a[i]代表数字i 0~9有几个；

那么用这些来表示全排列

(a[0]+a[1]+...+a[9])!/a[0]!/a[1]!/.../a[9]!;

当然如果a[i]==0那么不参与运算；

但是这样的话，longlong表示存不下；

~~所以我们要用高精度~~

所以我们在想想；

假如现在有m个位置；

我们先把0放法放好

C(m,a[0]);

之后就只有m-a[0]个位置；

然后在放1

C(m-a[0],a[1]);

所以答案是

C(m,a[0])xC(m-a[0],a[1])x...xC（m-a[0]-a[1]-..-a[8],a[9]）;

就可以算全排列；

思路和数位dp差不多；

一位一位向前推进；


```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define Ll long long
using namespace std;
Ll CC[1001][1001];
Ll C(Ll n,Ll m){
    if(CC[n][m])return CC[n][m];
    if(m==1)return n;
    if(m==0||m==n)return 1;
    if(m>n)return 0;
    CC[n][m]=C(n-1,m)+C(n-1,m-1);
    return CC[n][m];
}
int a[10],v[100];
Ll ans;
int n;
char c;
Ll cfb(){
    Ll ans=1;
    int m=n;
    for(int i=0;i<=9;i++)if(a[i])ans*=C(m,a[i]),m-=a[i];
    return ans;
}
int main()
{
    while(cin>>c)if(isdigit(c))v[++n]=c-48,a[v[n]]++;
    int nn=n;
    for(int i=1;i<=nn;i++){
        n--;
        for(int j=0;j<v[i];j++)
        if(a[j]){a[j]--;ans+=cfb();a[j]++;}
        a[v[i]]--;
    }
    printf("%lld",ans);
}
```


---

## 作者：C3H5ClO (赞：42)

~~总感觉题面很不清楚啊，看了题解才搞明白~~

搞了半天才发现，这不就是可重复元素排列的康托展开！0~9数字随便排，求一下有多少排列字典序比题目给的排列小。

先说普通的康托展开吧。其实运用了数位DP的思想。

例如，给你一个排列：２　４　５　３　１，求字典序比它小的排列有几个。

先看第一位。当第一位小于2时后4位无论怎样都比原排列小。而小于2且未被使用的数只有1一个。因此答案加上1×4!。当第一位等于2时，后4位必须小于原排列后4位。此时将2标记为已使用，继续循环。

看第二位。第一位小于4的数去除已使用的2还有2个，因此答案加上2×3!。然后将4标记为已使用，继续处理第二位为4的情况。

以此类推，可算得原排列康托展开为1×4!+2×3!+2×2!+1×1!+0×0!=41

可重复元素排列的康托展开也用同样的方法处理。

先存储0~9中每个元素的个数。对于每一位，枚举所有小于原排列中当前位的数。然后计算其他未被使用的数的全排列加入答案。最后将原排列中当前位的元素的值的个数减一，继续循环。具体看代码。

算可重复元素全排列个数的方法其他几位dalao已经讲的很清楚了。
```cpp
#include<cstdio>
using namespace std;
#define ri register int
#define ll long long
ll ans,c[55][55];
int a[10],len,n[55],cnt;
ll multiqpl(int a[],int l)
{
    ll res=1;
    for(ri i=0;i<=9;i++)
    {
        res*=c[l][a[i]];
        l-=a[i];
    }
    return res;
}
int main()
{
    for(char ch=getchar();ch>='0'&&ch<='9';ch=getchar())a[n[++len]=ch-48]++;
    c[0][0]=1;
    for(ri i=1;i<=len;i++)
    {
        c[i][0]=c[i][i]=1;
        for(ri j=1;j<i;j++)c[i][j]=c[i-1][j]+c[i-1][j-1];
    }
    for(ri i=1;i<=len;i++)
    {
        cnt=0;
        for(ri j=0;j<n[i];j++)
            if(a[j])
            {
                a[j]--;//将j放到第i位上
                ans+=multiqpl(a,len-i);
                a[j]++;//将j拿走，换下一个
            }
        a[n[i]]--;
    }
    printf("%lld",ans);
}
```

---

## 作者：DengDuck (赞：20)

数位 DP？高精度？太神秘啦！是时候换个写法，`__int128` 薄纱全场！

较小的数字形态显然是一段相同的前缀，一个小于原数字的位置，后面随便放，随便放的排列数为：

$$
\frac {(\sum\limits_{i=0}^9 cnt_i)!}{\prod\limits_{i=0}^9 (cnt_i!)}
$$
$cnt_x$ 表示 $x$ 的出现次数。

这时候题解区似乎为了求这个东西弄出了很多神秘的算法，但是，我们完全可以用一个非常简单的思路！弄一个很大的质数当模数！然后直接算答案！

要多大？答案小于 $2^{63}-1$，小粉兔推荐了一个神秘的网站叫做 [WolframAlpha](https://m.wolframalpha.com/)，生成了一个大于这个值质数，是 $9223372036854775837$，在模意义下，直接求阶乘逆元来解决除法即可。

什么紫题？赶紧降红！

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
//#define fir first
//#define sec second
using namespace std;
//const LL inf;
const LL N=55;
const LL M=50;
__int128 mod,fac[N],inv[N],ans;
//const LF eps;
//const LL P;
__int128 ksm(__int128 x,__int128 y)
{
	__int128 ans=1;
	while(y)
	{
		if(y&1)ans=ans*x%mod;
		x=x*x%mod,y>>=1;
	}
	return ans;
}
char c[N];
LL n,a[N],b[N];
void print(__int128 x)
{
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int main()
{
	mod=9223372036854;
	mod*=1000000;
	mod+=775837;
	fac[0]=1;
	for(int i=1;i<=M;i++)fac[i]=fac[i-1]*i%mod;
	inv[M]=ksm(fac[M],mod-2);
	for(int i=M-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;
	scanf("%s",c+1);
	n=strlen(c+1);
	for(int i=1;i<=n;i++)
	{
		a[i]=c[i]-'0';
		b[a[i]]++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=a[i]-1;j++)
		{
			if(!b[j])continue;
			b[j]--;
			LL s=0;
			__int128 cnt=1;
			for(int k=0;k<=9;k++)s+=b[k];
			cnt=fac[s];
			for(int k=0;k<=9;k++)cnt=cnt*inv[b[k]]%mod;
			b[j]++;
			ans=(ans+cnt)%mod;
		}
		b[a[i]]--;
	}
	print(ans);
	return 0;
}
//RP++
```

---

## 作者：YangQuijote (赞：14)

对于题目给的整数n，我们先想象这个数之前的那些数，其中一部分数的位数与n相等，而另一些则位数比n少。对于位数比n少的数，我们在它们前面加上前导0。因为位数比n少完全是由于按照题目所说的方法插入0的个数较少所致，所以**加入前导0补全后，所有数字中0~9出现的次数都和n相等了。**

这让人想到什么？全排列，但是是带重复元素的全排列。**我们要求的正是在全排列中小于n的数的个数。**

首先，带重复元素全排列计算方法为元素总个数的阶乘除以各个元素个数阶乘之积。

公式有了，接下来考虑怎么保证排列出的数字小于n。这种情况下就需要数位DP了。**设dp[i][j]表示前i-1位已经固定，在决定第i位上的数字为j的情况下，小于n的数字个数。**要保证统计到的数不重复不遗漏，且都小于n，数位DP中较常用的办法是**当前i-1位被固定下来时，这i-1位数字应当与n的前i-1位数字相同，而第i位上的数字的取值范围为[0,n[i])**,其中n[i]表示n的第i位上的数。这样，从第i+1位开始到最后一位上无论是什么数，**都一定小于n。**

在实际的计算中并不需要把dp值存在数组里，因为我们最后求的是它们的和，因此**实时计算并加入ans**里即可，代码中也是这么处理的。

因此最后的做法是当前i-1位固定时，从可以用来做全排列的元素集合中删去它们，枚举第i位是元素集合中的哪个元素，并**将剩下的元素做全排列。**

做全排列时存在阶乘的值暂时溢出了long long的可能，即使最终答案并没有溢出。可以注意到最多也就是算50的阶乘左右，循环次数很小，因此我们可以采取耗费更多的时间来防止溢出的办法。具体操作起来是将全排列公式中的分母部分，即各个元素的阶乘之积，拆开成连续的多个数相乘，再把它们装到一个类似桶排序的桶子的数组中(程序中使用了pool这一数组名)。在计算所有元素个数的阶乘时，没乘上一个数，就扫描一遍检查是否有除以桶子中某个数字的可能，能除则除。由于保证答案不溢出，所以这样做也就不会溢出。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char a[100];
long long len,mem[100],cont[10],pool[1000],poi,ma=0;
//len为n的位数，pool为桶子，cont为元素集合，并记录了各个元素的个数，mem为拆位后的整数n，ma为元素最个数最多的元素有几个。
void build(long long x)
{
    poi=0;
    memset(pool,0,sizeof(pool));
    --cont[x];//由于第i+1位填了x，因此暂时将其从元素集合去除
    int i,j;
    for(i=0;i<=9;++i)
    {
        for(j=2;j<=cont[i];++j)//除以1没有意义，因此为了优化运行时间不作考虑。
        {
            ++pool[j];
        }
    }
    ++cont[x];//为了后续计算再将x加入集合
}//往桶子里装数字的过程
long long getsum(long long x)
{
    long long ans=1,i,j;
    for(i=1;i<=x;++i)
    {
        ans*=i;
        for(j=2;j<=ma;++j)
        {
            for(;;)
            {
                if(pool[j]==0||ans%j!=0)//能除则除
                {
                    break;//不能除退出循环
                }
                else
                {
                    --pool[j];
                    ans/=j;
                }
            }
        }//扫描桶子
    }
    return ans;
}
int main()
{
    long long i,j;
    long long ans=0;
    memset(cont,0,sizeof(cont));
    scanf("%s",&a[0]);
    len=strlen(a);
    for(i=0;i<len;++i)
    {
        ++cont[a[i]-'0'];
        if(cont[a[i]-'0']>ma)
        {
            ma=cont[a[i]-'0'];
        }
        mem[i+1]=a[i]-'0';
    }//拆数与构造数字元素集合
    for(i=1;i<=len;++i)
    {
        for(j=0;j<mem[i];++j)
        {
            if(cont[j]>0)
            {
                build(j);
                ans+=getsum(len-i);//计算全排列，不必保存，直接加入ans。
            }
        }//枚举第i位，取值范围[0,n[i])
        --cont[mem[i]];//确定第i位（即与n的第i位相同）后就将对应的元素从集合拿出。
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：cccgift (赞：10)

### 看到其它题解写的都是组合计数或者看不懂的数位dp，这里给出一种易懂的数位dp。

我们发现原问题就转化成了一个有重复元素全排列在全排列中的排名，于是考虑数位dp。

记录下每个数字出现的次数（$0$不必记录），进行数位dp时，能取就取，并且记录一个$limit$表示是否有最高位限制。

接下来分两种情况：

1、有最高位限制：继续dp。

2、没有最高位限制：我们发现，此时后面的数无论怎么排，构成的排列也一定比读入的排列小，所以我们可以直接计算后面的全排列并计入答案。

关键在于如何求全排列，有重复元素全排列个数是：$\dfrac {\left( \sum a_{i}\right) !}{\Pi \left( a_{i}\right) !}$

但是，分子可能会很大，我们不能直接用阶乘去算，这该怎么办呢？

我们可以用质因数分解的办法把分子分解的每一项质因子的系数存好，分母各项直接去除就可以了。

### 具体细节详见代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<utility>
#include<algorithm>
#include<iostream>
using namespace std;
#define res register int
#define ll long long
const ll prime[16]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47}; //质数表，只要打到这里就够了。
char s[51];
int tong[16],num[10],len1,sum,a[51],len; //tong数组记录质因子出现次数
inline void ins(int x) { //乘法
    for(res i=1;i<=15;++i)
      while(!(x%prime[i])&&x) ++tong[i],x/=prime[i];
}
inline void del(int x) { //除法
    for(res i=1;i<=15;++i)
      while(!(x%prime[i])&&x) --tong[i],x/=prime[i];
}
inline ll query(int len,int s) {
	if(len<sum-s) return 0; //这里有个细节：如果剩下的非0个数仍大于需要填的数，此时不可能达到排列，直接返回0。
    memset(tong,0,sizeof(tong));
    for(res i=1;i<=len;++i) ins(i);
    for(res i=1;i<=9;len-=num[i++]) for(res j=1;j<=num[i];++j) del(j);
    for(res i=1;i<=len;++i) del(i); //剩下的len就是0的个数，也需要除
    ll tot=1;
    for(res i=1;i<=15;++i)
      for(res j=1;j<=tong[i];++j) tot*=prime[i]; //最后把每一项乘起来就能得到答案了。
    return tot;
}
ll dfs(int len,int s,bool ff) {
    ll tot=0;
    if(!len) return s==sum;
    if(!ff) return query(len,s); //没有限制直接求答案
    int end=ff?a[len]:9;
    for(res i=0;i<=end;++i) {
        if(!num[i]&&i) continue;
        --num[i],tot+=dfs(len-1,s+(i>0),ff&&i==end),++num[i]; //回溯
    }
    return tot;
}
int main()
{
    cin.sync_with_stdio(false); //sync加速（貌似这题没什么用）
    cin>>s,len1=strlen(s);
    for(res i=len1-1;~i;--i) {
        if(s[i]^48) ++num[s[i]-48],++sum; //sum表示非0数个数，num记录每个数出现次数。
        a[++len]=s[i]-48;
    }
    printf("%d\n",dfs(len,0,true)-1);
    return 0;
}
```

---

## 作者：maomao9173 (赞：6)

对$RK1$的题解作一个补充，思路是一样的，流程上可能讲的会更好懂一点。
#### [题目链接  $Click$  $Here$](https://www.luogu.org/problemnew/show/P2518)

很好很妙的一个题目。

其实可以生成的数字，一定是原数的一个排列，因为$0$被放在前面就可以认为不存在了嘛~。也就是说现在求的就是全排列中所有小于该数的排列。对每一位我们考虑两类情况：

- 第一类情况 : 前 $i$ 位上均相等, 且第 $i$ 位上当前数是 $j$ (比 $arr_i$ 小)
  - 这一位已经满足了约束条件小于，那么后面就可以放开了搞。也就是说后$n-i$个数形成的全排列中，每一个排列都是可以使用的，即答案加上一个全排列。
  - 为了避免高精度计算，这里使用了比较特殊的方法计算可重集的全排列。
- 第二类情况 : 当前位置依然相等。
  - 对此我们要在桶里去掉和这一位相等的数字，然后就可以去进行下一位计算啦。

最后让我们来一起复习一下~~差点把我卡死的~~可重集排列数公式吧$QwQ$：

$$(a[0]+a[1]+...+a[9])!/a[0]!/a[1]!/.../a[9]!$$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 55;

int C[N][N];

int ch, n, ans, tot[10], arr[100];

int get_ans (int n) {
    int res = 1;
    for (int i = 0; i <= 9; ++i) {
    	if (tot[i] != 0) {
    		res *= C [n][tot[i]];
			n -= tot[i];
		}
	}
	return res;
}

signed main () {
	C[0][0] = 1;
	for (int i = 1; i <= 50; ++i) {
		for (int j = 0; j <= 50; ++j) {
			C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
		}
	}
    while (true) {
    	if (isdigit (ch = getchar ())) {
	    	arr[++n] = ch - '0';
			tot[arr[n]]++;
		} else break;
	}
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < arr[i]; j++) {
        	if (tot[j] != 0) {
				//第一类情况 : 前 i 位上均相等, 且第 i 位上当前数是 j (比 arr[i] 小)
				tot[j] = tot[j] - 1;
				ans += get_ans (n - i);
				tot[j] = tot[j] + 1;
				//选中当前数 j, 对剩下的数求全排列 (可以随便选择了)
			}
		}
		//第二类情况 : 当前位置依然相等, 去掉相等的数字, 进行下一位计算
        tot[arr[i]]--;
    }
    cout << ans << endl;
}
```





---

## 作者：Libra_ (赞：3)

一个纯数位 DP，不需要数学的做法。

## 题目 [P2518](https://www.luogu.com.cn/problem/P2518)
给你一个整数 $n$ 你可以任意排列它各个位上的数，求产生的所有数中，比 $n$ 小的数有多少个。

## 分析
按照一般数位 DP 的做法，我们需要在 DFS 的过程中枚举每个位置上填什么并记忆化搜索。

最基本的 DP 状态：$dp[pos][limit]$。分别代表着，第 $pos$ 位，是否顶着上界。

此题不同的是，我们使用的 0~9 的个数是有限的，所以我们还需要的一维状态是当前每个数还剩几个可以使用。

对于维护每个数还剩几个可以用，一般想到的都是开个数组 $num[i]$ 表示数字 $i$ 还剩 $num[i]$ 个。那么怎么把它加到 DP 状态里呢？

我的做法是:
```cpp
map<vector<int>,long long> dp[55][2];
```

vector 的大小开到 10，第 $i$ 位代表数字 $i$ 使用的个数。

## 代码
[我的代码](https://www.luogu.com.cn/paste/eaont7np)

---

## 作者：Youngsc (赞：3)

[Youngsc](https://youngscc.github.io/)  

** 蒟蒻表示这辈子最讨厌的就是高精度 **  
** 所以计算排列时我采用了质因数分解法解决的这个问题 **  
** 考虑所有符合条件的数，那么用零将他们同时补全到原数长度时,这些数字就是原数字的一些排列 **  
** 那么我们首先将$0 \sim 9$ 每个数字出现的次数开一个桶记录下来**  
** 然后我们从高位到低位枚举这些数字**  
** 显然当我们枚举的数字小于原数字对应位置上的数，那么显然将剩下的数全排列一下接在后边都是合法数字 **  
** 注意由于有重复的元素，所以要做有重复元素的全排列，就是最后在除以每一个桶的阶乘 **  
** 由于直接算这个排列数中间会炸长整型，因此我采用了刚才提到的质因数分解法**  
** 将每个质数出现的次数统计出来，然后做一个累乘就可以了 **  
** 如果当前枚举到的数字与原数字的对应位置相等的话，显然就必须考虑后边的数字了**  
** 所以处理完当前位置后，从桶里拿出原来的数字放回去，在枚举下一位 **  
** 时间复杂度比较麻烦就不分析了**  

### 代码

```cpp
# include <bits/stdc++.h>
# define R register
# define LL long long
# define N 2010
# define mod 1000000009

#define Rf(a,b,c) for(int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(int (a)=(b);(a)>=(c);--(a))

using namespace std;

LL ans;
int p,pri[60],t[10],n;
bool v[60];
char s[60];

template <typename T> inline void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

template <typename T> inline void minn(R T& a,const T b){a>b ? a=b:0;}
template <typename T> inline void maxx(R T& a,const T b){a<b ? a=b:0;}

inline void pre(){
    for (R int i=2; i<=n; ++i)
    {
        if (!v[i]) pri[++p] = i;
        for (R int j=1; j<=p&&pri[j]*i<=n; ++j)
        {
            v[i*pri[j]] = 1;
            if (i%pri[j] == 0) break;
        }
    }
}

inline LL powe(R LL x,R LL y){
    R LL ret = 1;
    while (y)
    {
        if (y&1) ret = ret*x;
        x*=x;
        y >>= 1;
    }
    return ret;
}

inline LL calc(R LL now){
    // for (R int i=0; i<=9; ++i) printf("%d ",t[i]);
    // printf("\n");
    R LL ans=1;
    for (R int i=1; i<=p; ++i)
    {
        R LL x = now,sum = 0;
        while (x) sum += x/pri[i],x /= pri[i];
        for (R int j=0; j<=9; ++j)
        {
            R LL x = t[j];
            while (x) sum -= x/pri[i],x /= pri[i];
        }
        ans *= powe(pri[i],sum);
    }
    return ans;
}

int main(){
    scanf("%s",s+1);
    n = strlen(s+1);
    pre();
    for (R int i=1; i<=n; ++i) t[s[i]-'0']++;
    for (R int i=1; i<=n; ++i)
    {
        for (R int j=0; j<s[i]-'0'; ++j) //枚举当前位置上放谁
        {
            if (!t[j]) continue;
            t[j]--;
            ans += calc(n-i); //计算排列数
            t[j]++;
        }
        t[s[i]-'0']--;
    }
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：01190220csl (赞：2)

首先，我们可以在数前补上前导0，于是就是0~9的排列。

考虑已填上前$i-1$位，并且都和$n$相等，于是：第$i$位小于$n_i$时，在剩下的位做全排列；等于$n_i$时，跳转到填第$i+1$位。

现在讲讲全排列的求法。

- 设$0,1,\cdots,9$分别出现$n_0,n_1,\cdots,n_9$次，$n=n_0+n_1+\cdots+n_9$，则全排列数为$\frac{n!}{n_0!n_1!\cdots n_9!}$。

显然$n!$会爆long long。

注意到题面中有一句：答案不超过$2^{63}-1$，因此有下面两种方法（都是数论方法）：

1. $ans=ans\mod2^{63}$，于是我们只要求$\frac{n!}{n_0!n_1!\cdots n_9!}\mod2^{63}$。我们设分子上的数为$a\times2^p$，分母上的数为$b\times2^q$（其中$p,q$为自然数，$a,b$为奇数），要求的式子就变成$(\frac{a}{b}\times2^{p-q})\mod 2^{63}$。

$\because b\text{为奇数}$

$\therefore\gcd(b,2^{63})=1$

$\therefore b^{-1}\equiv b*(\varphi(2^{63})-1)\pmod {2^{63}}$

然后就可以带进去（用数论方法）算了（$\varphi(2^{63})=2^{62}$）。

2. 我们也可以取模数为$m$，确保$m>2^{63}$，同时希望$m$没有小于$50$的质因数。随便打个表就可以发现$m$能取$9223372036854775817=6619867\times1393286607851$，且$\varphi(m)=9223370643561548100$，然后就可以用逆元做了。

注意点：模数炸long long，要用ull存；求逆元只能用欧拉定理$a^{\varphi(p)}\equiv a\pmod p$，（扩欧中途会爆ull)；乘法要快速乘，加法要快速加（雾，详见代码），然后就没有了。

```cpp
//只有第二种做法
#include<bits/stdc++.h>
#define mod 9223372036854775817u
#define phimod 9223370643561548100u
#define ull unsigned long long
using namespace std;
int num[10];
ull ans = 0;
ull frac[51], invfrac[51];
ull ksj(ull a, ull b) {
//这个东西是防止a+b炸ull的，原理应该很明显了\
但a,b只可能比ull的上界的一半大一点点，所以a+b/2就不会炸ull了
	if (b & 1) ++a;
	b >>= 1;
	return ((a+b)%mod+b)%mod;
}
ull ksc(ull a, ull b) {
	ull ans = 0;
	while (b) {
		if (b & 1) ans = ksj(ans, a) % mod;
		a = ksj(a, a) % mod;
		b >>= 1;
	}
	return ans;
}
ull ksm(ull a, ull b) {
	ull ans = 1;
	while (b) {
		if (b & 1) ans = ksc(ans, a) % mod;
		a = ksc(a, a) % mod;
		b >>= 1;
	}
	return ans;
}
int main() {
	string s;
	cin >> s;
	for (int i = 0; i < s.size(); i++) ++num[s[i]-'0'];
	frac[0] = invfrac[0] = 1;
	for (int i = 1; i <= 50; i++) frac[i] = ksc(frac[i-1],i), invfrac[i] = ksm(frac[i],phimod-1);
	for (int i = 0; i < s.size(); i++) {
		for (int j = 0; j < s[i]-'0'; j++) {
			ull now = frac[s.size()-i-1];
			for (int k = 0; k <= 9; k++) now = ksc(now, invfrac[num[k]-(k==j)]);
			ans += now;
		}
		--num[s[i]-'0'];
	}
	cout << ans << endl;
}
```

---

## 作者：heyuhhh (赞：2)

这个题可以默认有前导0，然后那些位数比输入数据小的数就可以被一起统计了。

之后就从第一位开始往后面扫，对于每一位，看是否达到限制，没有的话剩下的数随便排列就行，那么此时我们需要解决的就是**可重集的全排列问题**；如果达到限制就继续考虑之后的一位。

下面重点说下怎么解决可重集的全排列问题：

设$S=\{n_1*a_1,n_2*a_2,\cdots,n_k*a_k\}$是由$n_1$个$a_1$,$n_2$个$a_2$，...$n_k$个$a_k$组成的多重集。则S的全排列个数为：
$$\frac{n!}{n_1!*n_2!*\cdots*n_k!}$$
这个式子可以等于:
$$C_n^{n_1}*C_{n-n_1}^{n_1+n_2}*\cdots*C_{n-\sum_{i-1}^{k-1}n_i}^{\sum_{i=1}^{k}n_ui}$$
因为最后数据保证答案不超过long long的范围，所以我们这样直接把答案计算出来就好了，就不用担心阶乘溢出了。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 55;
ll cnt[10];
ll ans ;
char s[N] ;
ll C[N][N] ;
int main() {
    scanf("%s", s + 1) ;
    int n = strlen(s + 1);
    for(int i = 1; i <= n; i++) cnt[s[i] - '0']++;
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(int i = 2; i < N; i++) {
        C[i][0] = 1;
        for(int j = 1; j < N; j++)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j] ;
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < s[i] - '0'; j++) {
            if(cnt[j] >= 1) {
                ll res = 1;
                cnt[j]--;
                ll sum = n - i;
                for(int k = 0; k <= 9; k++) res *= C[sum][sum - cnt[k]], sum -= cnt[k] ;
                cnt[j]++;
                ans += res;
            }
        }
        cnt[s[i] - '0']--;
    }
    cout << ans;
    return 0;
}

```

---

## 作者：Owen_codeisking (赞：2)

$Python$ 大法好！

其实也可以不用，就是写着玩嘛~~（水高精度的题还是很有意思的）~~

$Code\ Below:$

```python
n=int(input())
a=[0]*20
b=[0]*60
m=0;ans=0
while n>0:
    a[n%10]=a[n%10]+1
    m=m+1;b[m]=n%10;
    n=n//10
i=m
while i>0:
    for j in range(0,b[i]):
        if a[j]>0:
            a[j]=a[j]-1
            p=i-1;ret=1
            for k in range(1,10):
                for t in range(p-a[k]+1,p+1):
                    ret=ret*t
                for t in range(1,a[k]+1):
                    ret=ret//t
                p=p-a[k]
            ans=ans+ret;a[j]=a[j]+1
    a[b[i]]=a[b[i]]-1;i=i-1
print(int(ans))
```

---

## 作者：Naoxiaoyu (赞：1)

# 思路
关于这道题，我们首先要知道**可重集全排列**该如何来求，给出 $a_1$ 个 $b_1$，$a_2$ 个 $b_2$，$a_3$ 个 $b_3$ 一直到 $a_k$ 个 $b_k$，设这些数的总数为 $n$。

首先从 $a_1$ 开始考虑，选择 $b_1$ 个 $a_1$ 进入排列的方法有 $C_{n}^{b_1}$ 种，再考虑 $a_2$，此时的总数要减去 $b_1$，所以再选择 $b_2$ 个 $a_2$ 进入排列的方法有 $C_{n-b_{1}}^{b_2}$ 种，以此类推，不难得出 $C_{n}^{b_1} \times C_{n-b_{1}}^{b_2} \times … \times C_{n-b_{1}-b_{2}-…-b_{k-1}}^{b_k} $ 就是我们要求的公式。

回到题目，这道题说可以删掉若干个 $0$，我们可以理解为**将若干个 $0$ 放到数的开头**，那么这道题就是求出给定整数的每一位数全排列中比该数小的有多少个。

我们采用**数位 dp** 的思想，用**控制上限**的方法从高到低枚举每一位数，如果前面所有数都等于上限，从 $0$ 到上限枚举下一位数，否则将剩下的数进行**可重集全排列**，累加答案即可。

详细请看代码。
# code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char s[110];
int a[110];
int cnt[50];
ll ans=0;
ll com(int a,int b)
{
	ll p=1;
	int x=b-a+1;
	for(int i=1;i<=a;i++)
	{
		p*=x;
		p/=i;
		x++;
	}
	return p;
}//组合，注意要随时进行除法，否则会爆longlong
int main()
{
	int n;
	scanf("%s",s);
	n=strlen(s);
	for(int i=0;i<=n-1;i++)
	{
		a[i+1]=s[i]-'0';
	}
	for(int i=1;i<=n;i++)
	{
		cnt[a[i]]++;
	}//统计每个数字的数量
	for(int i=1;i<=n;i++)//从高到低枚举每一位数
	{
		for(int j=0;j<=a[i]-1;j++)//控制上限枚举填数
		{
			if(cnt[j])
			{
				ll res=1;
				int sum=n-i;
				cnt[j]--;要先减去选的数
				for(int k=0;k<=9;k++)
				{
					if(cnt[k])
					{
						res*=com(sum-cnt[k],sum);
						sum-=cnt[k];
					}
				}//将剩余数进行可重集全排列
				cnt[j]++;//复原
				ans+=res;//累加答案
			}	
		}
		cnt[a[i]]--;//前面所有数都等于下一位时继续向下枚举，此时这里只能填入a[i]，所以a[i]的数量中要减去1
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Locix_Elaina_Celome (赞：1)

# 康托展开

本题题解在后面，会康托展开可跳过该部分。

## 定义
> 康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。
>
> 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。——百度百科

再说一下我的理解：

对于一个 $n$ 个数的排列，康托展开就是把这个“具体的排列转化为全排列中的第 $X$ 个”（从 $0$ 开始计数）。

举个例子：

假设对于一个长度为 $5$ 的排列，则 $12345$ 对应的康托展开值为 $0$，$12354$ 对应 $1$，$12435$ 对应 $2$……

很明显，如果知道了康托展开值，就可以倒推出原排列。这个就是**康托逆展开**。

而有的时候，这个排列内元素不唯一，是个多重集，这时候问题就成了**多重集康托展开**。

因为很多时候把一个排列完整地存下来很费空间，而康托展开把排列映射成了数，可以节省空间。所以可以把它当作一个可逆的哈希。

同时，在一些奇奇怪怪的题目中，康托展开的定义使它可以有些神奇的作用。

甚至有的题目转换一下后直接求康托展开就可以了。

## 实现
### 1.普通康托展开
设排列长度为 $n$，康托展开值为 $x$，$A_i$ 表示这个数后面比它小的数的个数（逆序对）。

则有 $x= \sum\limits_{i=1}^n (n-i)!A_i$。

解释一下为什么。

因为我们要求这个排列是第几个，也就是有多少个排列比当前排列小。

遍历每一位，固定这一位之前的数字与原排列相同。因为要求比当前排列小的个数，就可以用后面任意一个比当前原数小的数替换当前位。剩下的乱排都不影响,也就是乘一个全排列。但是可能有的排列当前为及之前的都相同，但还是更小，这时候就固定当前位，以同样的方式处理下一位。

这个过程用数学表达式表示出来就是上面的公式。

### 2.普通康托逆展开

就按康托展开的流程到着来就行了。

设要逆展开的数为 $x$，逆展开的结果为 $B$。

先用一个集合 $S$ 表示当前还没有用的数。

每次 $B_i$ 等于 $S$ 中的第 $x/(n-i)!+1$ 大的数,然后 $x$ 对 $(n-i)!$ 取模，再把 $B_i$ 从 $S$ 中删除。

### 3.多重集康托展开
前面的问题都是对于一个元素不重复的排列，而如果有重复元素如何计算?

思路其实和普通康托展开类似，但是在“以后面更小的数替换当前位并计算方案”这一步有变化。

同样遍历每一位，固定这一位之前的数字与原排列相同，每次假设用后面的一个更小的值替换当前位（同样的值只计算一次）。然后计算这样排的方案，也就是剩余元素的多重集排列数。然后以同样的方法处理下一位。

### 4.多重集康托逆展开
网上一直找不到这东西，尝试自己推了一个。

因为多重集的康托展开比普通的康托展开求法复杂很多，因此其逆操作很难直接求解，所以我们可以考虑一定的枚举。

根据普通康托逆展开，依葫芦画瓢可以得出下面的求法：

每次枚举当前位填的数，再求出剩下没选的数的多重集排列数（这一步和多重集康托展开相同），设这个排列数为 $x$，多重集康托逆展开的参数为 $k$，则使 $x < k$ 且 $x$ 尽可能大的数就是这一位要填的数。然后 `k-=x`。

这个是个 $\mathcal{O}(n^4)$ 的老王八算法，非常的慢，当然这个应该影响不大，而且这个应该也用不上……

### 代码
```cpp
int a[N],f[N];//a为排列，f[i]表示i! 
int n;
void Init(){
	f[0]=1;//注意，0的阶乘等于1
	for(int i=1;i<=n;i++)
		f[i]=f[i-1]*i;
}
int cantor(){//康托展开
	int sum=0;//可根据需要初始化为1 
	for(int i=1;i<=n;i++){
		int cnt=0;//用来求公式中的A[i]，也可用树状数组优化
		//建议数据范围小的时候不用树状数组，避免蜜汁bug 
      //当然大多数时候数据范围都挺小，毕竟范围太大康托展开的返回值会炸掉
		for(int j=i+1;j<=n;j++)
			cnt+=(a[j]<a[i]);
		sum+=cnt*f[n-i];
	}
	return sum;
}
int b[N];//用于存储康托逆展开的结果

Splay s;//不会用STL查找第k大，一怒之下copy了一棵平衡树
//数据范围较小的时候建议直接暴力（我懒得写）
void rev_cantor(int sum){//康托逆展开
	s.build();for(int i=1;i<=n;i++)s.insert(i);//平衡树的初始化，不用管它，和康托展开无关 
	for(int i=1;i<=n;i++){
		b[i]=s.ask_val(sum/f[n-i]+1);//查找第sum/f[n-i]+1大的数
		s.erase(b[i]);
		sum%=f[n-i];
	}
}

int h[N];//辅助数组，用于存储每个数出现的次数 
int mx;//mx是所有数的最大值
int multicantor(){//多重集康托展开
	int sum=0;
	for(int i=1;i<=n;i++){
		for(int i=1;i<=n;i++)h[a[i]]=0;//记得清空辅助数组
		for(int j=i;j<=n;j++)
			h[a[j]]++;
		for(int j=0;j<a[i];j++){
			if(h[j]){
				h[j]--;//这个数固定了在当前位，所以要暂时滚出去 
				int x=f[n-i];
				for(int k=0;k<=mx;k++) 
					x/=f[h[k]];//计算多重集的排列数，具体求法bdfs 
				sum+=x;
				h[j]++;//刚刚暂时滚出去了，现在滚回来 
			}
		}
	}
	return sum;
}
vector<int> v;
void rev_multicantor(int kk){//多重集康托逆展开
    v.clear();for(int i=1;i<=n;i++)v.push_back(a[i]);//将所有数扔进可用的集合 
    for(int i=1;i<=n;i++){
		for(int j=0;j<=mx;j++)h[j]=0;//记得初始化
        for(int j=0;j<v.size();j++)h[v[j]]++;
        int x=0,id=0;
        for(int j=0;j<v.size();j++){
            int sum=0;
            for(int k=0;k<v[j];k++){
                if(h[k]){
                    h[k]--;
                    int x=f[n-i];
                    for(int t=0;t<=mx;t++)//计算这样填的方案 
                        x/=f[h[t]];
                    sum+=x;
                    h[k]++;
                }
                if(sum<=kk&&sum>x){//更新答案 
                    id=j;
                    x=sum;
                }
            }
        }
        b[i]=v[id];//把这里填上去 
        kk-=x;//继续下一位之前要把这里的贡献减去 
        v.erase(v.begin()+id);//把这个数移出待选集合 
    }
}
```

# 题目

[P2518 [HAOI2010] 计数](https://www.luogu.com.cn/problem/P2518)

如果没有插入 $0$，就是个多重集的康托展开。

考虑插入 $0$。我们可以先准备很多个 $0$，按需要插入在每个位置，没有用上的 $0$ 就放在最开头，很明显这不影响答案。于是就成了多重集的康托展开。

这个阶乘要炸 `long long`，很难受，但是时代的进步让我们无需高精，直接 `__int128`。

代码：

```cpp
using namespace std;
#include<bits/stdc++.h>
#include<stdio.h>
#include<string.h>
//#include<string>
//#include<iostream>
//#include<utility>
//#include<algorithm>
#define REG register 
#define INL inline
#define MAX(x,y) (x<y?y:x)
#define MIN(x,y) (x<y?x:y)
#define ABS(x) (x<0?-x:x)
#define N 55
#define int long long
#define INF 1145141919
#define EPS 0.00001
template<typename T>INL T Max(REG T x,REG T y){return MAX(x,y);}
template<typename T>INL T Min(REG T x,REG T y){return MIN(x,y);}
template<typename T>INL T Abs(REG T x){return ABS(x);}
template<typename T>INL void Swap(REG T&x,REG T&y){x^=y^=x^=y;}
template<typename T>
INL void read(REG T&x){
x=0;REG char c=getchar();/*REG T fl=1;*/
while(c<'0'||c>'9'){/*if(c == '-')fl=-1;*/c=getchar();}
while('/'<c&&c<':'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}/*x*=fl;*/}
template<typename T>
void write(T&&x){if(x>9)write(x/10);putchar(x%10^48);}
int a[N];
__int128 f[N];//a为排列，f[i]表示i! 
int n;
void Init(int n){
	f[0]=1;//注意，0的阶乘等于0 
	for(int i=1;i<=n;i++)
		f[i]=f[i-1]*i;
}
int h[N];//辅助数组，用于存储每个数出现的次数 
int mx;//mx是所有数的最大值
__int128 multicantor(){//注意数据范围，要开int128 
	__int128 sum=0;
	for(int i=1;i<=n;i++){
		for(int i=1;i<=n;i++)h[a[i]]=0;//记得清空辅助数组
		for(int j=i;j<=n;j++)
			h[a[j]]++;
		for(int j=0;j<a[i];j++){
			if(h[j]){
				h[j]--;//这个数固定了在当前位，所以要暂时滚出去 
				__int128 x=f[n-i];
				for(int k=0;k<=mx;k++) 
					x/=f[h[k]];//计算多重集的排列数，具体求法bdfs 
				sum+=x;
				h[j]++;//刚刚暂时滚出去了，现在滚回来 
			}
		}
	}
	return sum;
}
char s[N];
signed main(){
	scanf("%s",(s+1));
	n=strlen(s+1);
	for(int i=1;i<=n;i++)
		a[i]=s[i]-'0',mx=Max(mx,a[i]);
	Init(Max(mx,n));
	write(multicantor());
	return 0;
}
```

---

## 作者：liugh_ (赞：0)

## [[HAOI2010] 计数](https://www.luogu.com.cn/problem/P2518)

结合数据范围想到数位 dp，关键在于处理每一个数出现的次数。朴素地，设 $f(d,full,cnt_{0..9})$ 为从高到低处理到第 $d$ 位，是否取满上界，每个数 $i$ 还能选的次数为 $cnt_i$ 时的方案数。接下来考虑记忆化，当没取满上界且 $cnt$ 数组完全一样时显然不需要继续往下搜，记忆化哈希值即可。双哈希更严谨，但实测单哈希也能水过。

```cpp
#define int unsigned long long
constexpr int get(int* cnt){
	int res=B;
	for(int i=0;i<=9;i++)
		res=(res*B+cnt[i])%P;
	return res;
}
int dfs(int d,bool full){
	if(d==0)return !full;
	int hs=get(cnt);
	if(!full&&~f[hs])return f[hs];
	int bound=full?dig[d]:9;
	int res=0;
	for(int i=0;i<=bound;i++){
		if(!cnt[i])continue;
		cnt[i]--;
		res+=dfs(d-1,full&&i==bound);
		cnt[i]++;
	}
	if(!full)f[hs]=res;
	return res;
}
```

---

## 作者：complete_binary_tree (赞：0)

[P2518 [HAOI2010] 计数](https://www.luogu.com.cn/problem/P2518)

样例解释坑人。明明只有 $7$ 个数为什么要写 $8$ 个。建议修复。

这题只有 $50$ 个数，容易发现 $51^{10} < 2 \times 10^{18}$，我们考虑状压。

我们把这个数拆成一个 $51$ 进制数，其中第 $i$（$i$ 从 $0$ 开始，不然存不下）位表示 $i$ 这个数有几个。

取出的时候直接使用快速幂算 $51^n$ 即可，当然也可以手算。

然后就可以愉快地记搜了。

`dfs(pos,num,lim)`

`pos`：位置，从高位到低位。

`num`：（状压后的）剩余各位数的量。

`lim`：是否顶到最高位。

每一次选择完数需要判断是否在 `num` 中存在，然后 `num` 减掉那个数，继续往下搜。

我们需要记 `num` 来记忆化搜索，所以需要 `unordered_map` 来存。（否则你会 TLE40pts）

还有由于数字比较长需要用 `string` 存。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

int wei[55], cnt;

ll nnum = 0, kksm[11];

unordered_map<ll, ll> mp;

ll dfs( int pos, ll num, bool lim ){
    //统计答案
    if( pos > cnt && num == 0 ) return 1;
    //记搜
    if( !lim && mp.find( num ) != mp.end() ) return mp[num];
    ll ans = 0;
    //统计
    for( int i = 0; i <= ( lim ? wei[cnt - pos + 1] : 9 ); ++i )
        if( num >= kksm[i] && ( num / kksm[i] ) % 51 ) ans += dfs( pos + 1, num - kksm[i], lim && i == wei[cnt - pos + 1] );
    return ( lim ? ans : mp[num] = ans );
}

string x;//ll存不下

int main(){
    kksm[0] = 1;
    for( int i = 1; i < 10; ++i ) kksm[i] = kksm[i - 1] * 51;
    cin >> x;
    for( int i = x.length() - 1; i >= 0; --i ) wei[++cnt] = x[i] - 48, nnum += kksm[( x[i] - 48 ) % 10 ];
    cout << dfs( 1, nnum, 1 ) - 1 << endl;
    return 0;
}
```

---

## 作者：咯咯咯 (赞：0)

首先我们可以轻易得从高位到低位进行数位DP 在前i-1位都取和s相同的值时，如果第i位取的值小于s[i],那么后面n-i位的值就可以随便选，显然这样的方案数为$((n-i)!)/(\Pi_{i=0}^{9} cnt[i]!)$ 还有为了防止溢出我对每一个处理的数都质因数分解，放桶里，最后在乘起来
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<map>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define LL long long
char s[1000];
LL n,cnt[1000],num[1000],ans;
LL solve(LL x)
{
	For(i,1,100) num[i]=0;
	For(i,1,x) 
	{
		int temp=i;
		For(p,2,temp) 
		{
			while (temp%p==0) 
			{
				num[p]++;
				temp/=p;
			}
		}
	}
	For(i,0,9) 
	{
		For(j,1,cnt[i])
		{
			int temp=j;
			For(p,2,temp)
			{
				while (temp%p==0)
				{
					num[p]--;
					temp/=p;
				}
			}	
		}		
	}
	LL ans=1;For(i,1,100) For(j,1,num[i]) ans=ans*i;
	return ans;
}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	For(i,1,n) cnt[s[i]-'0']++;
	For(i,1,n)
	{
		For(j,0,s[i]-'0'-1) if (cnt[j]) 
		{
			cnt[j]--;
			ans+=solve(n-i);
			cnt[j]++;
		}
		cnt[s[i]-'0']--;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---


# [ZJOI2006] 碗的叠放

## 题目描述

小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：

![](https://cdn.luogu.com.cn/upload/pic/1706.png)


## 说明/提示

数据范围：100%数据满足n<=9。所有输入的数绝对值不超过1000。


## 样例 #1

### 输入

```
3
50 30 80
35 25 70
40 10 90```

### 输出

```
55```

# 题解

## 作者：Honor誉 (赞：2)

Description

小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：

![](http://192.168.102.138/JudgeOnline/upload/attachment/image/20170807/20170807201859_19060.jpg)

Input

第一行一个整数n，表示碗的数目。以下n行，每行三个整数h，r1，r2。分别表示碗高及两个半径。

Output

仅一个数，表示最小的高度。答案四舍五入取整。

Sample Input
```cpp
3
50 30 80
35 25 70
40 10 90
```
Sample Output

55

HINT

数据范围：100%数据满足n < = 9。所有输入的数绝对值不超过1000。

n<=9，直接想一下暴力枚举每一种放置顺序，求最小的答案即可。

那我们怎么求一种排序方案的高度呢？

分几种情况讨论：

## 最简单的两种：

1.如果上面的碗的碗底半径比下面的碗的碗口半径还要大（或者等于），直接卡住。

2.如果上面的碗的碗口半径比下面的碗的碗口半径还要小（或等于），可以放进去，但有可能在下底面卡住。

## 如果这两种情况都不是，那只能看一下碗壁的斜率了。

1.下面的碗壁大于上面的碗壁的斜率

算出在哪里是卡住的，再加上即可。

2.下面的碗壁小于等于上面的碗壁的斜率

同理。

但是有一个小情况：有可能放完碗后中间是凹下去的，这时要取得是外面的碗高。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
	double a,b,c,d;
}a[21],b[21];
int n,c[21];
double x,y,z;
data putin(double a,double b,double c,double d)
{
	data aa;
	aa.a=a;
	aa.b=b;
	aa.c=c;
	aa.d=d;
	return aa;
}
double getxl(data a)
{
	return (a.d-a.b)/(a.c-a.a);
}
double work(data a,data b)//两个碗放置的高度 
{
	double p=a.b;
	if(b.a>=a.c)
	{
		return a.d;
	}
	a.b=0;
	a.d-=p;
	if(getxl(a)>getxl(b))
	{
		if(b.c>=a.c)
		{
			double k=a.d-(a.c-b.a)*getxl(b);
			return p+max(k,0.0);
		}
		double k=a.d-b.d-(a.c-b.c)*getxl(a);
		return p+max(k,0.0);
	}else{
		if(a.a>b.a)
		{
			return p;
		}
		double k=a.d-(a.c-b.a)*getxl(a);
		return p+max(k,0.0);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf%lf",&x,&y,&z);
		a[i]=putin(y,0.0,z,x);
	}
	for(int i=1;i<=n;i++)
	{
		c[i]=i;
	}
	double minn=1e9;
	while(1)//计算每种排列的总高度 
	{
		b[0]=putin(1e9,0.0,1e9,0.0);
		for(int i=1;i<=n;i++)
		{
			double maxn=0;
			for(int j=0;j<i;j++)
			{
				maxn=max(maxn,work(b[j],a[c[i]]));
			}
			b[i]=putin(a[c[i]].a,a[c[i]].b+maxn,a[c[i]].c,a[c[i]].d+maxn);//放好的碗 
		}
		double maxn=0;
		for(int i=1;i<=n;i++)
		{
			maxn=max(maxn,b[i].d);
		}
		minn=min(minn,maxn);
		if(!next_permutation(c+1,c+n+1))//下一种排列 
		{
			break;
		} 
	}
	printf("%.0lf\n",minn);
	return 0;
} 
```

---

## 作者：L_zaa_L (赞：0)

我们首先可以直接枚举一下碗的顺序，然后就直接判断最高的位置在哪里就可以了。

那怎么判断高度呢

如果一个碗能被另一个碗卡住，这个卡住的位置肯定比其他所有碗能卡住高，于是我们来讨论一下两个碗会被怎样卡住。

通过分类讨论我们可以发现两个碗如果叠在一起一共有 $5$ 种情况：

定义：$l_x$ 表示 $x$ 这个碗的侧边的斜率，$h_x,r_x,R_x$ 如题面所述。

我们上面的杯子称为 $A$，下面的杯子称为 $B$。

![](https://picx.zhimg.com/80/v2-15807bf23ecb2b71e97f09c7d63f48e2_720w.png)

- 对于第一种的情况如果想要满足，肯定需要 $R_A>R_B\land r_A<R_B\land l_A> l_B$，然后既然想要正好卡在 $B$ 的碗顶上，那么下面那个地方肯定不能碰到 $B$ 的底部（不然就是第 $5$ 种情况），根据相似可以得到 $\frac{(R_B-r_A)}{R_A-r_A}\times h_A\le h_B$。

- 对于第二种情况如果想要满足首先要满足 $R_A<R_B\land l_A> l_B$，然后他的下面也不能碰到底部，也可以根据相似推出限制条件。

- 然后第三种情况有 $l_A<l_B\land r_A>r_B$，就没有然后了。

- 第四种情况更简单，只需要满足 $r_A>R_B$ 就可以了。

- 第五种就直接判断是不是在上面 $4$ 种情况，不是就只有这种情况了。

然后我们可以通过上面五种情况分别计算出每种情况上面的那个碗的碗底到下面那个碗的碗底高度。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls(x) ((x)*2)
#define rs(x) ((x)*2+1)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=1e4+5,Mod=998244353;
const double eps=1e-10;
bool SSS;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
//inline void Add(int &x,int y){(x=x+y+Mod)%Mod;}
typedef __int128_t i128;
i128 _base=1;
inline int mol(int x){return x-Mod*(_base*x>>64);}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
int n;
double h[N],r[N],R[N];
double hight[N],xs[N];
inline double l(int x){
	return 1.0*(R[x]-r[x])/h[x];
}
inline double check(int A,int B){//A到B的距离
	if(r[A]>=R[B]){//第四种
		return h[B];
	}
	if(l(A)>=l(B)&&R[B]<=R[A]&&(R[B]-r[A])*h[A]<h[B]*(R[A]-r[A])){//第一种情况
		return h[B]-(double)(R[B]-r[A])/(double)(R[A]-r[A])*(double)h[A];
	}
	if(l(A)>=l(B)&&R[A]<=R[B]&&r[B]<=R[A]&&(R[A]-r[B])*h[B]>=h[A]*(R[B]-r[B])){//第二种
		return (double)(R[A]-r[B])/(double)(R[B]-r[B])*(double)h[B]-h[A];
	}
	if(l(A)<l(B)&&r[A]>=r[B]){	//第三种
		return (double)(r[A]-r[B])/(double)(R[B]-r[B])*(double)h[B];
	}
	return 0;//最后一种
}
int q[N];
inline void solve(){
	n=read();
	For(i,1,n) h[i]=read(),r[i]=read(),R[i]=read();
	double answer=1e16; 
	For(i,1,n) q[i]=i;
	do{
		double ans=h[q[1]];
		For(i,1,n) hight[i]=0;
		For(i,2,n){
			Rof(j,i-1,1){
				double p=check(q[i],q[j]);
				p+=(double)hight[j];
				if(hight[i]<p) hight[i]=p;
			}
			ans=max(ans,(hight[i]+h[q[i]]));
		}
		answer=min(answer,ans);
	}while(next_permutation(q+1,q+n+1));
	cout<<fixed<<setprecision(0)<<(double)answer<<endl;
	return;
}
bool TTT;
signed main(){
	_base=(_base<<64)/Mod;
//	freopen("input.txt","r",stdin);
//freopen("output.txt","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	int T=1;
	while(T--){solve();}
#ifdef LOCAL
	Debug("\nMy Memories: %lldMib\n",(int)(&TTT-&SSS)/1024/1024);
    Debug("\nMy Time: %.3lfs\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---


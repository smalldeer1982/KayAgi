# [ZJOI2008] 生日聚会

## 题目描述

今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：

对于任意连续的一段，男孩与女孩的数目之差不超过k。

很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……

假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。


## 说明/提示

对于30%的数据，n , m ≤ 20；

对于100%的数据, n , m ≤ 150，k ≤ 20。

    

## 样例 #1

### 输入

```
1 2 1```

### 输出

```
1```

# 题解

## 作者：i207M (赞：42)

对于任意连续的一段，男孩与女孩的数目之差不超过k。求方案数。

n , m ≤ 150，k ≤ 20

~~这个题我觉得其他题解写的都有问题，状态定义有误~~


$f[i][j][k][h]$表示放了i个男生，j个女生，**所有后缀**中，男生减女生的差最大为k，女生减男生的差最大为h的方案数；

转移时枚举下一位放置男生还是女生；

如果这一位放置男生，那么所有前一位的后缀都要加上这个男生，所以男生最大数量会多1，女生会相应减1；

也就是：

```
(f[i+1][j][k+1][max(h-1,0)]+=tmp)%=md;
```
如果这一位放女生：

和上一种情况类似，这次女生数量增加，男生数量减少；

```
(f[i][j+1][max(k-1,0)][h+1]+=tmp)%=md;
```

注意取模；

注意取max(0)；

~~其他题解认为这代表任意一段，但是这样无法转移呀~~

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
#include<ctime>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pairint pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc()
{
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0;
    bool f = 0;
    char c = gc();
    while (c < '0' || c > '9')
    {
        if (c == '-') f = 1;
        c = gc();
    }
    while ('0' <= c && c <= '9')
    {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = gc();
    }
    if (f) x = -x;
}
#undef gc
#define pb push_back
#define int ll
#define md 12345678
int n,m,d;
int f[155][155][22][22];
il int max(const int &a,const int &b)
{
    return a>b?a:b;
}
signed main()
{
#ifdef M207
    freopen("in.in", "r", stdin);
#endif
    in(n),in(m),in(d);
    f[0][0][0][0]=1;
    for(ri i=0;i<=n;++i)
        for(ri j=0;j<=m;++j)
            for(ri k=0;k<=d;++k)
                for(ri h=0;h<=d;++h)
                    if(f[i][j][k][h])
                    {
                        // printf("%lld %lld %lld %lld: %lld\n",i,j,k,h,f[i][j][k][h]);
                        int tmp=f[i][j][k][h];
                        (f[i+1][j][k+1][max(h-1,0)]+=tmp)%=md;
                        (f[i][j+1][max(k-1,0)][h+1]+=tmp)%=md;
                    }
    int ans=0;
    for(ri i=0;i<=d;++i)
        for(ri j=0;j<=d;++j)
            (ans+=f[n][m][i][j])%=md;
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：Crabby_Maskiv (赞：21)

这道题最优复杂度是 $O(\min(n,m)k^2)$ 的（大概）。

考虑在一个网格图上从 $(0,0)$ 走到 $(n,m)$，放男生代表向上走 $1$，女生代表向右走 $1$。

那么我们把这个问题转化成了：走一条路径到 $(n,m)$，对于路径上每个点 $(x,y)$，$y-x$ 最大值和最小值差不超过 $k$。

（解释一下：假如走了 $i$ 步到了点 $(x,y)$，$y-x$ 就代表了前 $i$ 个人男生人数减去女生人数，这样取出两个点将它们的 $y-x$ 之相减，就代表了这两个点之间，也就是对应区间的男生人数减去女生人数）

我们考虑一个弱化的问题：

计数满足这样条件的路径个数：对于路径上每个点 $(x,y)$，$y-x\in[a,b]$。

这个很简单，$O(nm)$ 在网格图上递推即可。

那么我们对于每个 $b-a=k$ 做一遍求和，是不是就是最后的答案呢？

不是这样的，假如这条路径满足 $y-x$ 最大值和最小值差的绝对值**恰等于** $k$，设最大值为 $max$，最小值为 $min$，那么$a=min,b=max$的时候这个路径会被计数，做法是对的。但如果 $max-min=k-1$，那么 $a=min-1,min$ 的时候这个路径都会被计数，算重了一次。一般化的，假如一条路径 $max-min=k-p$，那么这个路径会被这种方法计数 $p+1$ 次。

假如 $ans_k=$ “对于任意连续的一段，男孩与女孩的数目之差**最大值恰等于** $k$”的方案数，那么这种方法得到的结果是 $ans_k+2ans_{k-1}+3ans_{k-2}+...+kans_1$

我们要求 $ans_k+ans_{k-1}+ans_{k-2}+...+ans_1$

你会发现，对于每个 $b-a=k-1$ 做一遍求和，二者一减就出来了。

这样做复杂度是 $O(nmk)$ 的，但是在路径计数的时候，我们发现遍历到的区域只有 $O(\min(n,m)k)$ 量级的大小，使用bfs就可以进一步优化到最优复杂度了。

PS：笔者实现了 $O(nmk)$ 做法拿到了目前的最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=150+5;
const int mod=12345678;
int n,m,k;
int d[N][N];
int main(){
	int i,j;
	cin>>n>>m>>k;
	int ans=0;
	for(int p=0;p<=k;p++){
		memset(d,0,sizeof(d));
		d[0][0]=1;
		for(i=0;i<=n;i++){
			for(j=0;j<=m;j++){
				if(j<i-p||j>i+k-p) continue;
				d[i+1][j]=(d[i+1][j]+d[i][j])%mod;
				d[i][j+1]=(d[i][j+1]+d[i][j])%mod;
			}
		}
		if(m<n-p||m>n+k-p) continue;
		ans=(ans+d[n][m])%mod;
	}
	k--;
	for(int p=0;p<=k;p++){
		memset(d,0,sizeof(d));
		d[0][0]=1;
		for(i=0;i<=n;i++){
			for(j=0;j<=m;j++){
				if(j<i-p||j>i+k-p) continue;
				d[i+1][j]=(d[i+1][j]+d[i][j])%mod;
				d[i][j+1]=(d[i][j+1]+d[i][j])%mod;
			}
		}
		if(m<n-p||m>n+k-p) continue;
		ans=(ans-d[n][m]+mod)%mod;
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：安好 (赞：18)

/\*
开始想状态dp[i][j][k]:前i个人中j男k女方案数

但貌似不会转移 因为有任意一段差值不大于k的限制 考虑如何在状态中把限制表现出来

又前i个人不是男就是女(废话) 知道男就能推出女

所以令dp[i][j][x][y]:前i个人中有j个是男生,任意一段男生比女生最多多x人，女生比男生最多多y人的方案数

转移时显然四重循环  枚举多的人数

\*/



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define mod 12345678
#define N 157
using namespace std;
int f[N<<1][N][21][21],n,m,ans,cnt,k;
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    f[0][0][0][0]=1;
    for(int i=0;i<=n+m-1;i++)
      for(int j=0;j<=n;j++)
        for(int x=0;x<=k;x++)
          for(int y=0;y<=k;y++)
           if(f[i][j][x][y])
           {
                     if(j+1<=n&&x+1<=k) (f[i+1][j+1][x+1][max(y-1,0)]+=f[i][j][x][y])%=mod;
                if(i+1-j<=m&&y+1<=k) (f[i+1][j][max(x-1,0)][y+1]+=f[i][j][x][y])%=mod;
           }
    for(int i=0;i<=k;i++)
      for(int j=0;j<=k;j++)
        ans=(ans+f[n+m][n][i][j])%mod;
    printf("%d\n",ans);       
    return 0;
}
```

---

## 作者：pigstd (赞：5)

貌似没有和我一样的 dp 方法。

将对于第 $i$ 个人，如果是男的就是 $1$，否则是 $-1$，设前缀和为 $S_i$，那么不难发现，如果 $\max (S_i) - \min (S_i) \le k$，那么就是合法的。

我们其实可以不用考虑 $\min (S_i)$ 的值，只要考虑当前的 $S_i - \min (S_i)$ 与 $\max (s_i) - \min (S_i)$ 就可以了。

设 $dp_{i,j,a,b}$ 表示用了 $i$ 个男的，$j$ 个女的，当前的 $S_{i+j}-\min (S_i)$ 为 $a$，$max(S_{i})-\min (S_i)$ 为 $b$ 的方案数。

不难得到：

$\begin{cases} dp_{i,j,a,b}=dp_{i,j-1,a+1,b}+dp_{i,j-1,a,b-1} \ \ \ (a =0) \\ dp_{i,j,a,b}=dp_{i-1,j,a-1,b-1}+dp_{i-1,j,a-1,b} \ \ \ \ (a=b)\\ dp_{i,j,a,b}=dp_{i,j-1,a+1,b}+dp_{i-1,j,a-1,b} \ \ \ \ (a \ne b \ ,\ a \ne 0) \end{cases}$ 

直接 dp 即可。

[code](https://www.luogu.com.cn/paste/3xil9v4h)

---

## 作者：Nt_Tsumiki (赞：4)

反射容斥好题啊。

提供一种理论复杂度 $O(n\log_p n)$ 的做法（默认 $n,m$ 同阶），其中 $p$ 为题目给定的模数，在为质数时可以做到线性。

首先将本题转化到网格图上：

对于 $k\ge\max\{n,m\}$ 的情况一定是 $\binom{n+m}{n}$，不再讨论。

对于坐一个女孩，我们可以看成 $(x,y)\to(x,y+1)$，对于坐一个男孩可以看成是 $(x,y)\to(x+1,y)$，那么题目中的限制实际是 $\max_{i=1}^{n+m}\{y_i-x_i\}-\min_{i=1}^{n+m}\{y_i-x_i\}\le k$，为了方便不妨令前面的 $\max$ 等于 $S_0$，后面的 $\min$ 为 $S_1$。

我们考虑怎么在网格图上刻画这个东西，我们不妨枚举两个边界 $y=x+i$ 和 $y=x+i+k$，那么在这两条线中间的路径必然有 $S_0-S_1\le k$。

但是这样会算重，对于一条合法的路径它会被算 $k-(S_0-S_1)+1$ 次，但是惊奇的发现这是一个等差数列的形式，我们再减去 $k
\gets k-1$ 的结果不就是我们想要的了嘛。

然后上面的格路计数部分可以使用反射容斥计算，需要算 $O(k\times \frac{n}{k})=O(n)$ 次组合数，因为本题模数过于魔怔，故可以使用 exlucas 去计算，复杂度为 $O(n\log_p n)$。

PS：由于 exlucas 常数过大，实际上本题数据范围下跑不过 $O(n^2)$ 预处理组合数的写法。

附两种计算组合数方法的提交记录：[link1](https://www.luogu.com.cn/record/181244254)，[link2](https://www.luogu.com.cn/record/181245987)

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

#define LL long long
#define MOD 12345678
#define N 10000005

inline int R() {
    int x=0; bool f=0; char c=getchar();
    while (!isdigit(c)) f|=(c=='-'),c=getchar();
    while (isdigit(c)) x=x*10+c-'0',c=getchar();
    return f?-x:x;
}

template<typename T>
void W(T x,int op=0) {
    if (x<0) return putchar('-'),W(-x,op);
    if (x>9) W(x/10); putchar(x%10+'0');
    if (op) putchar(op==1?' ':'\n');
}

using namespace std;
int n,m,k;

namespace EXlucas {
    LL quickpow(LL a,LL k,int P) {
        LL res=1;
        while (k) {
            if (k&1) res=res*a%P;
            a=a*a%P,k>>=1;
        }
        return res;
    }

    LL exgcd(LL a,LL b,LL &x,LL &y) {
        if (!b) return x=1,y=0,a;
        LL d=exgcd(b,a%b,x,y),tx=x;
        x=y,y=tx-(a/b)*y;
        return d;
    }

    LL mul(LL a,LL b,int P) {
        a=(a%P+P)%P,b=(b%P+P)%P;
        LL res=0;
        while (b) {
            if (b&1) res=(res+a)%P;
            a=(a+a)%P,b>>=1;
        }
        return res;
    }

    LL excrt(int n,LL *r,LL *mod) {
        LL R=r[1],P=mod[1];
        for (int i=2;i<=n;i++) {
            LL x,y,d=__gcd(P,mod[i]),tm=P/d*mod[i];
            exgcd(P/d,mod[i]/d,x,y);
            R=(R+mul((r[i]-R)/d,mul(x,P,tm),tm))%tm,P=tm;
        }
        return (R+P)%P;
    }

    LL f(int n,int p,int P) {
        if (!n) return 1;
        LL k=1,d=1;
        for (int i=1;i<=P;i++)
            if (i%p) k=k*i%P;
        k=quickpow(k,n/P,P);
        for (int i=P*(n/P);i<=n;i++)
            if (i%p) d=d*(i%P)%P;
        return f(n/p,p,P)*k%P*d%P;
    }

    LL g(int n,int p) {
        if (n<p) return 0;
        return n/p+g(n/p,p); 
    }

    LL exlucas(int n,int m,int P) {
        if (n<m or n<0 or m<0) return 0;
        LL *r=new LL[2*(int)sqrt(P)],*c=new LL[2*(int)sqrt(P)];
        int cnt=0;
        for (int i=2;i*i<=P;i++)
            if (P%i==0) {
                int tmp=1,phi;
                while (P%i==0) tmp*=i,P/=i;
                phi=tmp/i*(i-1);
                c[++cnt]=tmp;
                r[cnt]=f(n,i,tmp)*quickpow(f(m,i,tmp),phi-1,tmp)%tmp
                    *quickpow(f(n-m,i,tmp),phi-1,tmp)%tmp
                    *quickpow(i,g(n,i)-g(m,i)-g(n-m,i),tmp)%tmp;
            }
        if (P>1) {
            c[++cnt]=P;
            r[cnt]=f(n,P,P)*quickpow(f(m,P,P),P-2,P)%P
                *quickpow(f(n-m,P,P),P-2,P)%P
                *quickpow(P,g(n,P)-g(m,P)-g(n-m,P),P)%P;
        }
        LL res=excrt(cnt,r,c);
        delete[] r,c;
        return res;
    }
} using EXlucas::exlucas;

LL calc(int k) {
    LL res=0;
    for (int l=min(m-n,0)-1,r=min(m-n,0)+k+1;r>max(m-n,0);l--,r--)
        for (int i=(n+r)/(r-l);n-i*(r-l)<=n+m;i--)
            (res+=exlucas(n+m,n-i*(r-l),MOD)-exlucas(n+m,n-i*(r-l)+r,MOD))%=MOD;
    return (res+MOD)%MOD;
}

int main() {
    n=R(),m=R(),k=R();
    if (k<abs(n-m)) return W(0,2),0;
    if (k>=max(n,m)) return W(exlucas(n+m,n,MOD),2),0;
    W((calc(k)-calc(k-1)+MOD)%MOD,2);
    return 0;
}
```

---

## 作者：Engulf (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2592)

[更好的阅读体验](https://www.luogu.com.cn/blog/t-m-j-y-h-0-9/solution-p2592)

## 分析

### 状态定义

本题需要统计方案数，可以使用 dp 求解。

但是本题的状态比较难定义，既有男孩又有女孩，又有不同的相差数量，看起来难以下手。

想起教练的一句名言：

> 若状态难定义，就多加几维。

再看到数据范围，$n,m\le 150, k\le 20$。

所有我们不妨定义四维状态 $dp_{i,j,k1,k2}$ 表示**有 $i$ 个男孩和 $j$ 个女孩，男孩比女孩最多多 $k1$ 人，女孩最多比男孩多 $k2$ 人**。

这个状态可以满足转移的需求了，且空间也可以接受。

### 状态转移

对于每个状态 $dp_{i,j,k1,k2}$，都可以**放男孩**或**放女孩**，那么放了之后的状态就会加上当前状态的方案数。

还有一个问题，如果当前状态放的全是男生或全是女生，减一之后就会越界访问，所以需要对 $0$ 取一个 $\max$。

状态转移方程代码实现：

```cpp
dp[i+1][j][k1+1][max(k2-1,0LL)]+=dp[i][j][k1][k2];
dp[i][j+1][max(k1-1,0LL)][k2+1]+=dp[i][j][k1][k2];
```

### 边界条件

作为统计方案数的 dp，一定要注意边界条件。

对于本题，当男孩女孩数量都是 $0$ 时，相差最大值也是 $0$，也属于一种方案，所以边界条件：

```cpp
dp[0][0][0][0]=1;
```

### 统计答案

题目要求差值不超过 $k$，故所有小于 $k$ 的方案均可累加。

最终的答案就是 $\large\sum\limits_{i,j=0}^{k}dp_{n,m,i,j}$。

---

## 作者：ZhaiOverflow (赞：2)

前 $i$ 个人，其中有 $j$ 个不是妹子，当妹子少 $q$ 个（或者少0个）时，如果可以加上一个男生则加上之后不会超出。

**当前状态加上一个男生后对应得状态的方案数可以加上当前状态的方案数。**

如果发现加上女生后男生比女生要少，其实可以理解为男生不比女生多。

可以由所有女生比男生多的状态得到。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=150+2;
const int MAXK=20+2;
const int MOD=12345678;
int F[2*MAXN][MAXN][MAXK][MAXK];
int N,M,K;

#define add(x, y) x += y; if (x >= MOD) x-= MOD;

int main(){
    scanf("%d %d %d",&N,&M,&K);
    F[0][0][0][0]=1;
    for(int i=0;i<N+M;i++){
        for(int n=0;n<=N;n++){
            for(int zk=0;zk<=20;zk++){
                for(int fk=0;fk<=20;fk++){
                     
                    if(!F[i][n][zk][fk])continue;
                     
                    int now=F[i][n][zk][fk];
                    int rem_n=N-n;
                    int rem_m=M-(i-n);
                     
                    if(rem_n && zk<K){
                        int nfk=max(0,fk-1);
                        add(F[i+1][n+1][zk+1][nfk], now)

                    }
                    if(rem_m && fk<K){
                        int nzk=max(0,zk-1);
                        add(F[i+1][n][nzk][fk+1], now)
                    }
                }
            }
        }
    }
     
    int ans=0;
    for(int zk=0;zk<=K;zk++){
        for(int fk=0;fk<=K;fk++){
            add(ans, F[N+M][N][zk][fk])
        }
    }
     
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：doge233 (赞：2)

看到并没有题解就无耻的写一发

首先观察到数据很小不妨可以来一发4维的dp

这道题确实思路很神奇

f[i][j][x][y] 表示前i个人中有j个男生其中任意一段男生最多比女生多x个女生最多比男生多y个的方案数

有了状态我们来思考一下如何转移

如果男生人数没有达到上限，那么放男生的情况是f[i+1][j+1][x+1][max(y-1,0)]+=f[i][j][x][y]

同理那么女生的转移应该和男生是相同的，自己思考一下，不会的话参考下面的代码


if(j+1<=n&&x+1<=k) (f[i+1][j+1][x+1][max(y-1,0)]+=f[i][j][x][y])%=mod;

if(i+1-j<=m&&y+1<=k) (f[i+1][j][max(x-1,0)][y+1]+=f[i][j][x][y])%=mod;

思路很重要，代码超短一看就懂的

跟学长学到了一种很炫酷的写法


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define F(i,j,n) for(int i=j;i<=n;i++)
#define D(i,j,n) for(int i=j;i>=n;i--)
#define maxn   10005
#define inf   (~0U>>1)
#define mod  12345678
using namespace std; 
inline int read()
{
    int num=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')  {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') {
        num*=10;
        num+=ch-'0';
        ch=getchar();
    }
    return num*f;
 }
 int f[301][151][21][21];
 int n,m,k,ans;
 int main()
 {
    n=read();
    m=read();
    k=read();
    f[0][0][0][0]=1;
    F(i,0,n+m-1) F(j,0,n) F(x,0,k) F(y,0,k) if(f[i][j][x][y]){
        if(j+1<=n&&x+1<=k) (f[i+1][j+1][x+1][max(y-1,0)]+=f[i][j][x][y])%=mod;
        if(i+1-j<=m&&y+1<=k) (f[i+1][j][max(x-1,0)][y+1]+=f[i][j][x][y])%=mod;
     }
     F(i,0,k) F(j,0,k) (ans+=f[n+m][n][i][j])%=mod;
     printf("%d\n",ans);
     return 0;
 }

```

---

## 作者：danny101 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2592)

这是一道典型的思维能力要求较高的 $DP$。

我们先定义状态 $f[i][j][k][l]$ 表示前 $i$ 个男生与前 $j$ 个女生的安排方案数，且满足男生比女生多不超过 $k$ 个，女生比男生多不超过 $l$ 个。

接下来枚举每一位：

如果放男生，那么这段区间的男生比女生多的数量增加了 $1$ ，递推公式为：

```
f[i+1][j][k+1][max(l-1,0)]=(f[i][j][k][l]+f[i+1][j][k+1][max(l-1,0)])%mod
```

而如果是女生，那么这段区间的女生比男生多的数量增加了 $1$ ，递推公式就为：

```
f[i][j+1][max(k-1,0)][l+1]=(f[i][j][k][l]+f[i][j+1][max(k-1,0)][l+1])%mod
```

注意！！！为了不要看到大红大紫的评测结果，一定要在 $k-1$ 或 $l-1$ 的时候与 $0$ 取 $\max$！

上代码：

```cpp
#include<bits/stdc++.h>
#define mod 12345678
using namespace std;
int n,m,t,f[152][152][22][22];
long long ans;
int main(){
    cin>>n>>m>>t;
    f[0][0][0][0]=1;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int k=0;k<=t;k++){
                for(int l=0;l<=t;l++){
                    if(f[i][j][k][l]){
                        f[i+1][j][k+1][max(l-1,0)]=(f[i][j][k][l]+f[i+1][j][k+1][max(l-1,0)])%mod;
                        f[i][j+1][max(k-1,0)][l+1]=(f[i][j][k][l]+f[i][j+1][max(k-1,0)][l+1])%mod;
                    }
                }
            }
        }
    }
    for(int i=0;i<=t;i++)for(int j=0;j<=t;j++)ans=(f[n][m][i][j]+ans)%mod;
    cout<<ans;
}
```

---

## 作者：nomonick (赞：1)

# 题解 P2592 【[ZJOI2008]生日聚会】

[P2592 [ZJOI2008]生日聚会](https://www.luogu.com.cn/problem/P2592)

和明显这是一道 $dp$ 计数的问题所以优先考虑如何构建 $dp$ 的数组。

$$
dp[i][j][l][t] 
$$

表示表示这样的排列已经放了 $i$ 个男生，同时放了 $j$ 个女生，此时前面的排列男生减女生的人数为 $l$，前面的排列女生减男生的人数为 $t$。

所以考虑在这放男生还是女生，因此方程如下：

$$
dp[i+1][j][l+1][\max(t-1,0)] = (dp[i+1][j][l+1][\max(t-1,0)] + dp[i][j][l][t]) % mod	
$$
$$
dp[i][j+1][\max(l-1,0)][t+1] = (dp[i][j+1][\max(l-1,0)][t+1] + dp[i][j][l][t]) % mod
$$

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 155;
const int limit = 25;
const int mod = 12345678;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		f = (ch == '-' ? -1 : 1);
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,m,k,ans;
int dp[SIZE][SIZE][limit][limit];

int main()
{
	n = read();m = read();k = read();
	dp[0][0][0][0] = 1;
	for (int i = 0; i <= n; ++i)
	{
		for (int j = 0; j <= m; ++j)
		{
			for (int l = 0; l <= k; ++l)
			{
				for (int t = 0; t <= k; ++t)
				{
					if (dp[i][j][l][t])
					{
						dp[i+1][j][l+1][max(t-1,0)] = (dp[i+1][j][l+1][max(t-1,0)] + dp[i][j][l][t]) % mod;
						dp[i][j+1][max(l-1,0)][t+1] = (dp[i][j+1][max(l-1,0)][t+1] + dp[i][j][l][t]) % mod;
					}
				}
			}
		}
	}
	for (int i = 0; i <= k; ++i)
	{
		for (int j = 0; j <= k; ++j)
		{
			ans = (ans + dp[n][m][i][j]) % mod;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Polaris_Dane (赞：1)

考虑$dp[x][y][i][j]$表示已经有$x$个男生，$y$个女生，$i$表示当前后缀中中男生减女生的最大值，$j$表示当前后缀中女生减男生的最大值

原题是对一段区间限制，我们这里取其后缀是因为我们并不是一个完整的序列，所以后缀就对应了完整的序列的一个区间

考虑转移，如果放一个男生

$dp[x+1][y][i+1][\max(j-1,0)]=dp[x][y][i][j]$

如果放一个女生

$dp[x][y+1][\max(i-1,0)][j+1]=dp[x][y][i][j]$

为什么要跟$0$取$\max$，因为如果加入一个男生$j$归零了之后，当再次加入女生后，我们肯定是从新的女生开始算，而不是算上以前的

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#define M 160
#define inf 0x3f3f3f3f
#define LL long long
const double eps=1e-6;
const int mod=12345678;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int n,m,k,dp[M][M][30][30],ans;
signed main(void){
	n=read(),m=read(),k=read();dp[0][0][0][0]=1;
	for (int x=0;x<=n;x++)
		for (int y=0;y<=m;y++)
			for (int i=0;i<=min(x,k);i++)
				for (int j=0;j<=min(y,k);j++){
					(dp[x+1][y][i+1][max(j-1,0)]+=dp[x][y][i][j])%=mod;
					(dp[x][y+1][max(i-1,0)][j+1]+=dp[x][y][i][j])%=mod;
				}
	for (int i=0;i<=k;i++)
		for (int j=0;j<=k;j++)
			(ans+=dp[n][m][i][j])%=mod;
	printf("%d",ans);
	return 0;
}

```


---

## 作者：Su_Zipei (赞：0)

## 分析

　　这个题想都不用想一看就是DP，但这道题的状态不是很好确定，状态怎么找呢，可以确定的是，男孩和女孩的人数一定占两个状态，因为这个是可以确定他们的方案数的，剩下的我想维护男生与女生之间的差值，但这样显然是会出问题的，假如差值为2，那么有可能男生比女生多2，有可能女生比男生多2，这是两个方案，而这么定义状态的话就会出现少算方案数的情况，所以我们必须要维护男生比女生多的人数，女生比男生多的人数，这样状态就有了，定义$dp[a][b][c][d]$为共有$a$个女孩，$b$个男孩，男孩比女孩多$c$，女孩比男孩多$d$，那么每放一个人，就有两种可能，男生或女生，转移两次即可。是不是挺玄学的。。。
  
  ```
#include<iostream>
#define g dp[i][j][c][d]
#define mod 12345678
using namespace std;
int dp[160][160][25][25];
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    dp[0][0][0][0]=1;
    for(int i=0;i<=m;i++)
    for(int j=0;j<=n;j++)
    for(int c=0;c<=k;c++)
    for(int d=0;d<=k;d++){
        dp[i][j+1][c+1][max(d-1,0)]=(dp[i][j+1][c+1][max(d-1,0)]+g)%mod;
        dp[i+1][j][max(c-1,0)][d+1]=(dp[i+1][j][max(c-1,0)][d+1]+g)%mod;
    }
    int ans=0;
    for(int i=0;i<=k;i++)
        for(int j=0;j<=k;j++)
            ans=(ans+dp[m][n][i][j])%mod;
    cout<<ans<<endl;
}
  ```

---

## 作者：HH_Halo (赞：0)

### **题目大意**

* 男生女生排座，任意抓一把上来，男孩与女孩的数目之差都不超过k，求方案数

* 给的信息很少，输入就三个数，啥也没看出来

## 思路分析

* 不妨先想一想从区间长度入手？按常规考虑一下f数组记录区间的起点和终点，那数组存啥？而且求得还是方案数，而且男生女生得分开吧，看样子区间dp也不行
* 这么一想，最起码题目的关键信息有了，即男生数，女生数，男生与女生的差，女生和男生的差（均>=0）（两个不一样，混一起显然会让你不知道该放男生还是女生）
* 将以上信息整合在一起，我们就需要维护一个四维的DP数组，详见代码注释

## $Code$

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int maxn = 150+10;
const int maxk = 20+5;
const int MOD = 12345678;
int n,m,k,ans;
int dp[maxn][maxn][maxk][maxk];//前两维分别表示男生和女生的个数，后两维分别表示男生比女生多的，女生比男生多的
int main(){
    scanf("%d%d%d", &n, &m, &k);
    dp[0][0][0][0]=1;
    for (int i=0;i<=n;i++)//前i个男生
        for (int j=0;j<=m;j++)//前j个女生
            for (int k1=0;k1<=k;k1++)
                for (int k2=0;k2<=k;k2++){//然后判断能否再放进来男生或女生
                    if(k1+1<=k) dp[i+1][j][k1+1][max(k2-1,0)]=(dp[i+1][j][k1+1][max(k2-1,0)]+dp[i][j][k1][k2])%MOD;
                    if(k2+1<=k) dp[i][j+1][max(k1-1,0)][k2+1]=(dp[i][j+1][max(k1-1,0)][k2+1]+dp[i][j][k1][k2])%MOD;
                }//这里的max表示不能小于0，可以避免特判
    for (int i=0;i<=k;i++){
        for (int j=0;j<=k;j++)ans=(ans+dp[n][m][i][j])%MOD;
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Erotate (赞：0)

对于这种求方案数的题目，我们很容易想到递推或动态规划。很显然，这题应该用动规来实现。

------------

我们先来定义一下状态，即 $f$ 数组表示什么：

首先，男孩和女孩各需要一维，共两维；其次，我们发现对于若干个人，要么男生比女生多，要么男生比女生多，所以再加上两维，一共四维。
 
于是我们可以用 $f[i][j][x][y]$ 表示前 $i$ 个男孩 和前 $j$ 个女孩，任意连续的若干个人，要么男孩最多比女孩多 $x$ 人，要么女孩最多比男孩多 $y$ 人时有几种方法。
 
------------
 
再看看状态转移方程：

在增加了一个女孩后，$x$ 肯定会减一，$y$ 肯定会加一，所以状态转移方程如下：

```
f[i][j+1][max(x-1,0)][y+1]=(f[i][j][x][y]+f[i][j+1][max(x-1,0)][y+1])%mod;
```
这里用 $\max$ 是为了防止越界。还有，记得求模。

同理可得增加了一个男孩后的方程：

```cpp
f[i+1][j][x+1][max(y-1,0)]=(f[i][j][x][y]+f[i+1][j][x+1][max(y-1,0)])%mod;
```

------------

最后还有一步，不要漏掉：

可以发现，只要男女数目相差小于等于 $k$ 就是一种可行的方案，所以我们需要统计每一种可能。

```cpp
for(int i=0;i<=k;++i)//男生比女生多
   for(int j=0;j<=k;++j)//女生比男生多
      ans=(f[n][m][i][j]+ans)%mod;
```


------------
AC 代码：

```cpp
#include<bits/stdc++.h>
#define mod 12345678
using namespace std;
int n,m,k,f[155][155][25][25];
long long ans;
int main(){
    cin>>n>>m>>k;
    f[0][0][0][0]=1;
    for(int i=0;i<=n;++i)
        for(int j=0;j<=m;++j)
            for(int x=0;x<=k;++x)
                for(int y=0;y<=k;++y){
                    if(f[i][j][m][n]){
                        f[i][j+1][max(x-1,0)][y+1]=(f[i][j][x][y]+f[i][j+1][max(x-1,0)][y+1])%mod;
                        f[i+1][j][m+1][max(n-1,0)]=(f[i][j][m][n]+f[i+1][j][m+1][max(n-1,0)])%mod;
                    }
                }
    for(int i=0;i<=k;++i)
        for(int j=0;j<=k;++j) ans=(f[n][m][i][j]+ans)%mod;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：花样百出 (赞：0)

题解:

我们设dp[a][b][c][d]表示目前已经有a个男生,b个女生,在某一时刻男生最多比女生多c个,在某一时刻女生最多比男生多d个.

所以就可以转移了:

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<set>
#define MAXN 500010
#define RG register
#define LL long long int
using namespace std;
const int INF=1e9;
const int mod=12345678;
int n,m,k;
LL dp[155][155][25][25];
LL ans;
int main()
{
  freopen("1.in","r",stdin);
  scanf("%d%d%d",&n,&m,&k);
  dp[0][0][0][0]=1;
  for(int a=0;a<=n;a++)
    for(int b=0;b<=m;b++)
      for(int c=0;c<=k;c++)
    for(int d=0;d<=k;d++)
      {
        (dp[a+1][b][c+1][max(d-1,0)]+=dp[a][b][c][d])%=mod;
        (dp[a][b+1][max(c-1,0)][d+1]+=dp[a][b][c][d])%=mod;
      }
  for(int c=0;c<=k;c++)
    for(int d=0;d<=k;d++)
      (ans+=dp[n][m][c][d])%=mod;
  printf("%lld\n",ans);
  return 0;
}

(dp[a+1][b][c+1][max(d-1,0)]+=dp[a][b][c][d])%=mod;

(dp[a][b+1][max(c-1,0)][d+1]+=dp[a][b][c][d])%=mod;

```

---


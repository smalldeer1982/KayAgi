# 带通配符的字符串匹配

## 题目背景

通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\*)等，其中，“?”可以代替一个字符，而“\*”可以代替零个或多个字符。

现又定义一个通配符“@”，规定在一个字符串中，“@”代替的字符个数是固定的。


## 题目描述

用户在使用“@”时，当然希望输入的“@”越少越好。现在给出一个带有“?”“\*”通配符的字符串和一个原字符串，要求首先判断通配符字符串与原字符串是否匹配，若匹配则求出将原通配符字符串中的“?”“\*”字符替换为“@”且保证修改后的通配符字符串与原字符串匹配，最少需要多少个通配符“@”。


## 说明/提示

【样例说明1】

两字符串显然可以匹配，通配符字符串1\*456??可以替换为1@@@456@，最少需要4个“@”，其中每个“@”代替两个字符，可以证明，此为最优情况。

通配符字符串1\*456??也可以替换为1@@@@@@456@@，此时每个“@”代替一个字符，需要8个“@”，没有上面的情况优。


【样例说明2】

两字符串不可以匹配。


【数据范围】

对于100%的数据，字符串的长度均小于3000。

保证原字符串中仅出现字母和数字，通配符字符串中仅出现字母、数字和通配符“?”“\*”，且保证匹配方式唯一。


## 样例 #1

### 输入

```
1*456??
111111145678```

### 输出

```
matched
4```

## 样例 #2

### 输入

```
1*456
1111111452```

### 输出

```
not matched```

# 题解

## 作者：加里纳利 (赞：5)

另放上出题者dropD的C++源代码。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int f[3005][3005]={0},q[3005]={0},prt[3005][3005]={0};
string st1,st2;
int gcd(int a,int b)
{   if(b==0)return a;
    return gcd(b,a%b);
}
void Get(int x,int y)
{   if(x==0&&y==0)return;
    int lx=x-1,ly=prt[x][y];
    if(st1[x]=='*'&&y!=ly){q[++q[0]]=y-ly;}
    Get(lx,ly);
}
int main()
{   cin>>st1>>st2;
    int i,j,k,bj,div,ans=0,len1=st1.length(),len2=st2.length();
    st1=' '+st1;st2=' '+st2;
    f[0][0]=1;
    for(i=1;i<=len1;i++)
       for(j=0;j<=len2;j++)
         {if(st1[i]=='?'||st1[i]==st2[j])
            {f[i][j]=f[i-1][j-1];
             if(f[i][j])prt[i][j]=j-1;
            }
          else if(st1[i]=='*')
            {for(k=j,bj=0;k>=0;k--)
                if(f[i-1][k]){bj=1;break;}
             if(bj){f[i][j]=1;prt[i][j]=k;}
            }
         }
    if(f[len1][len2])
      {cout<<"matched\n";
       for(i=1;i<=len1;)//处理?匹配符 
         {j=i;
          while(st1[j]=='?')j++;
          if(i!=j)q[++q[0]]=j-i;
          i=j+1;
         }
       Get(len1,len2);//递归处理*匹配符 
       if(q[0]==0)cout<<0;
       else if(q[0]==1)cout<<1;
       else if(q[0]>=2)
         {div=gcd(q[1],q[2]);
          for(i=3;i<=q[0];i++)div=gcd(div,q[i]);
          for(i=1;i<=q[0];i++)ans+=q[i]/div;
          cout<<ans;
         } 
      }
    else cout<<"not matched";
    return 0;
}
思路完全一样
```

---

## 作者：_adil_ (赞：0)

首先考虑两个串能否匹配，可以使用动态规划。

设让长 $n$ 的模式串 $s$ 匹配长 $m$ 的主串 $t$，$dp_{i,j}$ 表示 $s$ 的前 $j$ 位能否匹配上 $t$ 的前 $i$ 位（为了方便在这里 $t$ 放在前面），则若 $s_{j+1}\ne*$ 且 $s_{j+1}$ 和 $t_{i+1}$ 可以匹配，有：
$$
dp_{i,j}\to dp_{i+1,j+1}
$$
若 $s_{j+1}=*$，对于 $\forall k,i\le k\le m$ 都有：
$$
dp_{i,j}\to dp_{k,j+1}
$$
这里可以通过打一个标记，及时记录一个点是否可以从之前的星号转移过来，保证复杂度。

```cpp
if(s[j+1]=='*')dp[i][j+1]=1,tag[i][j+1]=1;
if(tag[i][j])tag[i+1][j]=1,dp[i+1][j]=1;
//星号可以代表空串，每次也可以不用模式串的位数来匹配一位主串
```
能否匹配就是 $dp_{m,n}$ 是否等于 $1$。

接下来的就十分简单了。由于题目保证匹配方式唯一，我们可以对于每一个 $dp$ 值来记录它的前驱 $pr$，进而算出每一个全由通配符组成的连续段的长度。$@$ 能代表的最多位数也就是所有连续段长度的最大公约数，将通配符占据的总长度除以它即是答案。


```cpp
#include<bits/stdc++.h>
#define N 3009
#define M 500009
#define INF 0x3f3f3f3f
#define mod 998244353
using namespace std;
typedef long long ll;
typedef long double ldb;
typedef pair<int,int> pii;
int n,m;
int out,sum;
bool dp[N][N],tag[N][N];//用int会mle
string s,t;
vector<int> ans;
pii pr[N][N];
int gcd(int x,int y){
  if(!y)return x;
  return gcd(y,x%y);
}
void work(int mp,int np){
  if(!mp&&!np)return;
  if(s[np]=='?'){
    int tmp=0;
    while(s[np]=='?'||pr[mp][np]==make_pair(mp,np-1)){
      if(pr[mp][np]!=make_pair(mp,np-1))tmp++;
      pii nw=pr[mp][np];//一段连续的问号和代表空串的星号算在连续的一段里
      mp=nw.first,np=nw.second;
    }
    sum+=tmp;
    ans.push_back(tmp);
    work(mp,np);
  }else if(s[np]!='?'&&s[np]!='*'){
    pii nw=pr[mp][np];//不是通配符，不管
    mp=nw.first,np=nw.second;
    work(mp,np);
  }else{
     pii nw=pr[mp][np];
     if(mp-nw.first)ans.push_back(mp-nw.first);
     sum+=mp-nw.first;//不是空串的星号单独占一个连续段
     mp=nw.first,np=nw.second;
     work(mp,np);
  }
}
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin>>s>>t;
  n=s.size(),m=t.size();
  s=" "+s,t=" "+t;
  int pos=1;
  dp[0][0]=1;
  for(int i=0;i<=m;i++){
    for(int j=0;j<=n;j++){
      if(!dp[i][j])continue;
      if(s[j+1]!='?'&&s[j+1]!='*'&&s[j+1]==t[i+1])dp[i+1][j+1]=1,pr[i+1][j+1]={i,j};
      if(s[j+1]=='?')dp[i+1][j+1]=1,pr[i+1][j+1]={i,j};
      if(s[j+1]=='*')dp[i][j+1]=1,tag[i][j+1]=1,pr[i][j+1]={i,j};
      if(tag[i][j])tag[i+1][j]=1,dp[i+1][j]=1,pr[i+1][j]=pr[i][j];
    }
  }
  if(!dp[m][n]){cout<<"not matched";exit(0);}
  cout<<"matched\n";
  work(m,n);
  if(!ans.size()){cout<<"0";exit(0);}
  out=ans[0];
  for(int i=1;i<ans.size();i++)out=gcd(out,ans[i]);
  cout<<sum/out;
  return 0;
}
```

---


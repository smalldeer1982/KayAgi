# 最大收益

## 题目描述

现在你面前有 $n$ 个物品，编号分别为 $1,2,3,\cdots,n$。你可以在这当中任意选择任意多个物品。其中第 $i$ 个物品有两个属性 $W_i$ 和 $R_i$，当你选择了第 $i$ 个物品后，你就可以获得 $W_i$ 的收益；但是，你选择该物品以后选择的所有物品的收益都会减少 $R_i$。现在请你求出，该选择哪些物品，并且该以什么样的顺序选取这些物品，才能使得自己获得的收益最大。

注意，收益的减少是会叠加的。比如，你选择了第 $i$ 个物品，那么你就会获得了 $W_i$ 的收益；然后你又选择了第 $j$ 个物品，你又获得了 $W_j-R_i$ 收益；之后你又选择了第 $k$ 个物品，你又获得了 $W_k-R_i-R_j$ 的收益；那么你获得的收益总和为 $W_i+(W_j-R_i)+(W_k-R_i-R_j)$。

## 说明/提示

### 数据范围及约定

- $20\%$ 的数据满足：$n \le 5$，$0 \le W_i,R_i \le 1000$；
- $50\%$ 的数据满足：$n \le 15$，$0 \le W_i,R_i \le 1000$；
- $100\%$ 的数据满足：$n \le 3000$，$0 \le W_i,R_i \le 2\times 10^5$。

### 样例解释

我们可以选择 $1$ 号物品，获得了 $5$ 点收益；之后我们再选择 $2$ 号物品，获得 $3-2=1$ 点收益。最后总的收益值为 $5+1=6$。

## 样例 #1

### 输入

```
2
5 2
3 5```

### 输出

```
6```

# 题解

## 作者：FendtSilence (赞：23)

这个题感觉无论是难度标签还是算法标签都有一些偏差。

这种最优化问题套路往往在DP之中，这里就来一种DP做法。

首先我们发现如果直接使用DP方程的话会有后效性，但是没有关系，我们先写出DP方程；

对于“n个物品选任意个”我们就可以想到一种递推方法，即设$f[i][j]$表示前$i$个物品选$j$个的最大收益

我们发现正着转移并不好转移，我们可以倒着转移，使选择的当前第$i$号物品为第一个物品，这样的话我们就发现这个物品对答案做的贡献就变成了$a[i].w-a[i].r*(j-1)$，于是写出转移方程：

$f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i].w-a[i].r*(j-1))$

以此得出，对于整个方程，我们要想使收益最大，在倒着转移的情况下贪心为$R_i$从大到小进行排序，而不是一开始的认为的从小到大排序。

献上代码

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
const int maxn=3001;
struct proj
{
    int w,r;
}a[maxn];
bool cmp(const proj &a,const proj &b)
{
    return a.r>b.r;
}
int f[maxn][maxn];
int n,ans;
void solve()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].w>>a[i].r;
    sort(a+1,a+1+n,cmp);
    f[1][1]=a[1].w;
    for(int i=1;i<=n;i++) for(int j=1;j<=i;j++)
    f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i].w-a[i].r*(j-1));
    for(int i=1;i<=n;i++) ans=max(f[n][i],ans);
    cout<<ans;
}
int main()
{
    solve();
    return 0;
}
```
这个题应该是动态规划的算法成分比较大，标签只有贪心是不是有失公正？


---

## 作者：Created_equal1 (赞：10)

算法1：

首先考虑最暴力的做法，枚举每个物品是选还是不选。得到一个物品的集合后，枚举其全排列。在所有方案中找到最大值。时间复杂度O(2^n\*n!)，可以通过20%的数据。

算法2：

考虑对题目进行一个等价的变换：即选择某个物品后，选择该物品前所有选择的物品的收益减少Ri。

然后我们可以贪心地对Ri从大到小排个序，然后搜索的时候只需要枚举每个物品是选还是不选，无需枚举全排列了。时间复杂度是O(2^n)，可以通过50%的数据。

算法3：

受算法2的启发，我们可以设计一个动态规划算法。首先仍然是要按照Ri从大到小排个序。然后设F[i][j]表示前i个物品中选j个可以获得的收益最大值。

状态转移方程：F[i][j]=max{F[i-1][j],F[i-1][j-1]+W[i]-R[i]\*(j-1)}

边界条件：F[1][1]=W[1]

最后的答案=max{F[n][i]}

算法2和算法3的贪心的正确性不难证明。


---

## 作者：hwx12233 (赞：5)

很容易可以看出

一共选$k$个时
选第$j$个为$i$的贡献为$aw_i-ar_i*(k-j-1)$

这样看有点麻烦

不如倒着来选 第$j$个时对后面的影响就为$aw_i-ar_i(j-1)$

那么我们只用考虑$\sum_{j=1}^k \ ar_i(j-1)$最小就好了(i为要选的物品数)

但是问题来了怎么转移才最优呢$？$

很容易   ~~大佬指点~~ 得出

这不就是一个排序不等式吗！

这里不详细证明直说结论：

序列A和序列B乘积
$(a_1 * b_1+a_2 * b_2+...)$的最小值是A的增序* B的减序

于是乎，这里的$j-1$是递增的

那只要使$a_r$递减不就可以是最小的了吗？

排序！

设$dp[i][j]$表示在前i个商品中选j个最大收益

```cpp
dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1))
```
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll

inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}

struct node{
	int w,r;
}a[3100];
int n,dp[3100][3100],ans=0;
inline bool cmp(node x,node y){return x.r>y.r;}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].w>>a[i].r;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
    	for(int j=1;j<=i;j++)
	dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1));
	for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);
	cout<<ans;
} 
```

---

## 作者：liuyi0905 (赞：4)

$\operatorname{dp}$ 模版题。

边界：无。

定义状态：$\operatorname{dp}_{i,j}$ 表示前 $i$ 个物品中选 $j$ 个的最大收益。

状态转移方程：$\operatorname{dp}_{i,j}=\max\{\operatorname{dp}_{i-1,j},\operatorname{dp}_{i-1,j-1}+W_i-R_i\times(j-1)\}$。

为了找到最优方案，要将每件物品按照 $R$ 从大到小排序。

直接将方程带入代码中：
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 3005
using namespace std;
int n,dp[N][N],ans;
struct thing{int w,r;}t[N];
int cmp(thing x,thing y){return x.r>y.r;}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>t[i].w>>t[i].r;
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++)
    	for(int j=1;j<=i;j++)dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+t[i].w-t[i].r*(j-1));
	for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：StarPatrick (赞：2)

这题好像与 [FTLOI 一次公开赛的题目](https://www.luogu.com.cn/problem/T217220)有异曲同工之妙。

题目已经明示了你要排序，显然 $R$ 大的放后面。

排完序以后，我们就可以进行记忆化搜索（和 DP 一样，但我打多了记忆化习惯了）。首先想出来的**错误算法**的就是传两个参数 $i,u$ 分别表示当前选到的物品和前面选的物品对当前物品的影响，但是 $R$ 很大，我们开不下数组。那么，我们发现，选了一个物品之后会对以后所有选的物品造成相同的影响，假如以后我们要选 $x$ 个物品（**包括当前物品**），那么选完当前物品对全局的影响就为（即物品的价值，转化为 01 背包）：$W_i-(x-1)\times R_i$，那么我们怎么知道这个 $x$ 呢？直接传入搜索参数，这样我们总共传了两个参数：$i,u$，表示当前选的物品和我们还要选多少个物品。最后我们枚举（预测）一下还要选多少个物品，复杂度 $O(n^2)$。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, dp[3005][3005];
struct e
{
	int w, r;
}a[3005];
bool cmp(e x, e y)
{
	return x.r<y.r;
}
int dfs(int i, int u)
{
	if (dp[i][u]!=-1)
	{
		return dp[i][u];
	}
	if (u==0)//边界
	{
		return dp[i][u]=0;
	}
	if (i==n+1)//边界
	{
		return dp[i][u]=-1e9;
	}
	return dp[i][u]=max(dfs(i+1, u), dfs(i+1, u-1)+a[i].w-a[i].r*(u-1));
}
int main()
{
	memset(dp, -1, sizeof(dp));
	cin>>n;
	for (int p=1;p<=n;p++)
	{
		cin>>a[p].w>>a[p].r;
	}
	stable_sort(a+1, a+n+1, cmp);
	int ans = 0;
	for (int p=1;p<=n;p++)
	{
		ans = max(ans, dfs(1, p));
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：青鸟_Blue_Bird (赞：2)

身为两个死对头，这题很好地将贪心和 $dp$ 结合了起来。

首先考虑一下买一个东西对之后所有东西的影响。不难发现，当我们所买的东西相同的时候，肯定是先买影响最小物品最划算。所以我们要 **排序**。

现在，我们就把问题转化为了：

	如何买一堆物品，每个物品有一个价值，且价值取决于之后所购买的物品的数量，使得总价值最大。
    
不妨设 $dp_{i,j}$ 表示在**从后往前**第 $i$ 个物品这里，买了 $j$ 个物品的最大收益。而如果我们倒着转移，会有些不方便（~~不习惯~~）。于是，把排序反一下，大的排在前面，然后设当前第 $i$ 个物品为最早买的就好啦。

至于 $dp$ 方程，考虑买与不买两种情况。

1. 对于买的情况，我们的价值没有变。$dp_{i,j} = dp_{i-1,j}$
1. 对于不买的情况，考虑价值的变化量。 $dp_{i,j-1} = dp_{i-1,j-1} + w_i - p_i * j$。
1. 边界：$dp_{1,1} = w_1$，即只买第一个物品。

综合起来取 $max$ 就好啦！

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 3010
#define ll long long

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

int dp[N][N]; 
int w[N], p[N]; 
int n; 
int ans = 0; 

struct node{
	int w, p; 
	
	bool operator < (const node& a) const{
		return p > a.p; 
	}
} a[N];

int main(){
	read(n);
	for(int i = 1; i <= n; i++)
		read(a[i].w), read(a[i].p); 
	sort(a + 1, a + n + 1); 
	dp[1][1] = a[1].w; 
	for(int i = 2; i <= n; i++){
		for(int j = 0; j <= i; j++){
			if(j) dp[i][j] = max(dp[i][j], dp[i-1][j-1] + a[i].w- a[i].p * (j - 1));   // 买第 i 个 
			dp[i][j] = max(dp[i][j], dp[i-1][j]); 
		}	
	}
	for(int i = 1; i <= n; i++)
		ans = max(ans, dp[n][i]); 
	cout << ans << endl;
	return 0; 
}
```


---

## 作者：linyinuo2008 (赞：1)

这是一道非常好的逆向思维+贪心+ $\text{DP}$ 题。当然可以简单的进行暴搜全排列，复杂度 $O(2^n \times n!)$ ，可以通过 $20\%$ 的数据。

这个时候可以倒着想一想，用记忆化搜索的思。令 $f_{i,j}$ 为前 $i$ 个物品中选 $j$ 个的最大收益（因为每一个物品转移时的收益与选了多少个有关，所以要状态升维），把当前搜索到的位置作为一个初始位置，可以得到当前位置的来源： $f_{i-1,j}$ 和 $f_{i-1,j-1}$ 。

我们可以不选这个物品，即为 $f_{i-1,j}$ ，要是选的话这个物品的收益为 $w_i-r_i \times (j-1)$ 。

所以转移方程为：
$$ f_{i,j}=\max(f_{i-1,j},f_{i-1,j-1}+w_i-r_i \times (j-1)$$

但是为了保证算法的正确性，我们在动归前还要进行一次贪心。不难看出， $r_i$ 大的物品选的次数要尽量少，因此应当放在前面，所以要先从大到小排个序（使用结构体排序）。

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=3005;

struct item
{
	int w,r;	
}a[N];

bool cmp(item p,item q)
{
	return p.r>q.r;
}

int f[N][N]; 

int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].w>>a[i].r;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			f[i][j]=f[i-1][j];
			f[i][j]=max(f[i][j],f[i-1][j-1]+(a[i].w-a[i].r*(j-1)));
		}
	int ans=0;
	for(int i=1;i<=n;i++)
		ans=max(ans,f[n][i]);
	cout<<ans;
	return 0;
}
```
**若有错误，欢迎指出！**

---

## 作者：Lates (赞：1)

贪心利用排序不等式可以发现按 r 从小到大排序时再选最优。

因为对于每个位置后面要选的物品个数是单调不降的，所以 r 递增最优。

考虑 $f[i][j]$ 表示前 $i$ 个数选了 $j$ 个的最大收益。

但是发现，r 对答案的损失与 $i$ 以后选了啥有关，转移不了。

那么可以倒着转移，设 $f[i][j]$ 为第 $i$ 个数到第 $n$ 个的最大收益。

那么 $f[i][j]=\max(f[i+1][j-1]+w[i]-r[i]\times(j-1),f[i+1][j])$。

写的时候可以把这个改一改。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define int long long 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAXM=200005,MAX=3005;
int n;
struct E{
	int w,r;
}e[MAX]; 
inline bool cmp(E x,E y){
	return x.r>y.r;
}
int ans,f[MAX][MAX];
signed main(){
	n=read();
	for(register int i=1;i<=n;++i)e[i]=(E){read(),read()};
	sort(e+1,e+1+n,cmp);
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=i;++j){
			f[i][j]=max(f[i-1][j],f[i-1][j-1]-(j-1)*e[i].r+e[i].w);
		}
	}
	for(register int i=1;i<=n;++i)ans=max(ans,f[n][i]);
	printf("%d\n",ans);
	return 0;
}

```




---

## 作者：⊱⋛赫宇⋚⊰ (赞：1)



[博客食用更佳](https://blog.csdn.net/yhhy666/article/details/109148562)## 题目描述

现在你面前有n个物品，编号分别为1，2，3，……，n。你可以在这当中任意选择任意多个物品。其中第i个物品有两个属性Wi和Ri，当你选择了第i个物品后，你就可以获得Wi的收益；但是，你选择该物品以后选择的所有物品的收益都会减少Ri。现在请你求出，该选择哪些物品，并且该以什么样的顺序选取这些物品，才能使得自己获得的收益最大。

注意，收益的减少是会叠加的。比如，你选择了第i个物品，那么你就会获得了Wi的收益；然后你又选择了第j个物品，你又获得了Wj-Ri收益；之后你又选择了第k个物品，你又获得了Wk-Ri-Rj的收益；那么你获得的收益总和为Wi+(Wj-Ri)+(Wk-Ri-Rj)。

## 输入格式

第一行一个正整数n，表示物品的个数。

接下来第2行到第n+1行，每行两个正整数Wi和Ri，含义如题目所述。

## 输出格式

输出仅一行，表示最大的收益。

## 输入输出样例

2
5 2
3 5

6

## 说明/提示

20%的数据满足：n<=5，0<=Wi,Ri<=1000。

50%的数据满足：n<=15，0<=Wi,Ri<=1000。

100%的数据满足：n<=3000，0<=Wi,Ri<=200000。

样例解释：我们可以选择1号物品，获得了5点收益；之后我们再选择2号物品，获得3-2=1点收益。最后总的收益值为5+1=6。

### 贪心+dp

看到题目我们肯定会想到dp,但是怎么Dp呢，题目中的可以多选和对后面价值有影响让人无从下手，我们不妨反着思考。
设立状态：dp[i][j] 表示的是前i个物品选择j个，选的第一个物品是第i个，注意是选的第一个物品是第i个。为什么是第一个物品是第i个呢，因为这样的影响就是对 j-1个有影响。
再考虑选的顺序，既然是按i从1—n来dp，那么肯定是影响大的放后面选，影响小的放前面选择，所以先按每个物品的影响值从大到小排个序。

再来考虑转移方程
1.不选 ：dp[i-1][j]
2.选 ：dp[i-1][j-1]+w[i]-r[i]*(j-1)

dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1)));
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){res=(res<<1)+(res<<3)+(ch&15);ch=getchar();}
    return res*f;
}
int n;
struct node
{
	int r;
	int w;
}a[3500];
int tot;
int dp[3500][3500];
inline bool cmp(node x,node y)
{
	return x.r>y.r;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i].w=read(),a[i].r=read();
    sort(a+1,a+1+n,cmp);//按照r的值从大到小进行排序
    for(int i=1;i<=n;i++)
    for(int j=1;j<=i;j++)
    {
	 dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1)));//转移
	 tot=max(dp[i][j],tot);//打擂台
	}
	cout<<tot;
	return 0;
}

```


---

## 作者：lytqwq (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P2647)

假设选物品的顺序为$a_1,a_2,a_3,...,a_x$

把收益拆开看,就是:

$$(\sum_{i=1}^{x}W_{a_i})-(\sum_{i=1}^{x}R_{a_i}*(i-1))$$

当选的物品固定时,只要让$R$小的在前面就行了,所以可以先按$R$的大小排序,选的顺序就是排的顺序

然后我们就要解决要选哪些物品.

因为选了一个物品后,后面的物品价值会改变,所以我们可以从后往前考虑,这样就没有了后效性,可以$DP$

设$f_{i,j}$为到第$j$个物品时,一共选了$i$个物品的最大收益

$DP$方程:$f_{i,j}=\max(f_{i,j+1},f_{i-1,j+1}+W_j-R_j*(i-1))$

最后取最大值输出就行了

~~应该是要开longlong的吧~~

因为一直在从后一个往前面转移,所以可以用滚动数组(下面的代码并没用

AC情况:[https://www.luogu.com.cn/record/39276954](https://www.luogu.com.cn/record/39276954)

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3010;
int n;
long long int f[N][N],maxn;
struct d{
	int w,r;
	bool operator < (const d x) const{return r<x.r;}
}qwq[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&qwq[i].w,&qwq[i].r);
	}
	sort(qwq+1,qwq+n+1);
	for(int i=n;i>=1;i--){
		for(int o=1;o<=n;o++){
			f[o][i]=max(f[o][i+1],f[o-1][i+1]+qwq[i].w-1LL*qwq[i].r*(o-1));
		}
		if(i==1){
			for(int o=0;o<=n;o++){
				maxn=max(maxn,f[o][i]);
			}
		}
	}
	printf("%lld\n",maxn);
}
```



---

## 作者：闲鱼 (赞：1)

因为每件物品的 $r$ 值都会影响后面所选物品的收益，所以正向处理就需要统计前面所选物品的累加r值，比较影响最优性处理，可以考虑**逆序操作**。

### 算法一（贪心，50分）：

将所有物品按 $r$ 值从大到小排序（显然先选 $r$ 值小的物品对后面收益的影响更小，但因为需要逆序操作，所以就从大到小排），然后枚举每一个物品选还是不选，时间复杂度 $O(2^n)$。

### 算法二（动态规划 $\&$ 贪心，100分）：

考虑如何优化枚举过程，可以想到动态规划。

一看 $Wi$ 和 $Ri$ 的范围很大，设状态的话首先要一个 $i$ 表示第 $i$ 个物品，第二维肯定不能和收益或损失的收益沾边。

于是设 $dp[i][j]$ 表示前 $i$ 个物品选 $j$ 个所能获得的最大收益。

对于每一个物品，有选和不选两种情况（类似01背包）。

如果要选第 $i$ 个物品，则总收益要减去 $a[i].r * (j - 1)$。

状态转移方程：

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + a[i].w - a[i].r * (j - 1))$

最后在 $dp[n][j]$ 中选最大值即可。

代码：

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;

#define N 3005
#define re register

struct P{
    int w, r;
}a[N];

int dp[N][N];

template<typename T> inline void read(T &x)
{
    x = 0; char ch = getchar(); bool flag = false;
    while(ch < '0' || ch > '9'){if(ch == '-') flag = true; ch = getchar();}
    while('0' <= ch && ch <= '9'){x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    if(flag) x = -x;
}

inline void write(int a)
{
    if(a > 9) write(a / 10);
    putchar(a % 10 + '0');
}

inline int Max(int x, int y){ return x > y ? x : y; }

inline bool cmp(P x, P y){ return x.r > y.r; }

int main()
{
    int n, ans;
    read(n);
    for(re int i = 1;i <= n;i++) {
        read(a[i].w), read(a[i].r);
    }
    sort(a + 1, a + n + 1, cmp);
    dp[1][1] = a[1].w, ans = a[1].w;
    for(re int i = 1;i <= n;i++) {
        for(re int j = 1;j <= i;j++) {
            dp[i][j] = Max(dp[i - 1][j], dp[i - 1][j - 1] + a[i].w - a[i].r * (j - 1));
            if(i == n) ans = Max(ans, dp[i][j]);
        }
    }
    write(ans);
    return 0;
}
```

对于上述代码，还可以使用滚动数组优化。

去掉第一维，柿子变为 

$dp[j] = Max(dp[j], dp[j - 1] + a[i].w - a[i].r * (j - 1))$

因为柿子中的状态调用的是上一个物品的状态，所以第二层循环需要倒着枚举，避免重复计算该物品的收益。

代码：

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;

#define N 3005
#define re register

struct P{
    int w, r;
}a[N];

int dp[N];

template<typename T> inline void read(T &x)
{
    x = 0; char ch = getchar(); bool flag = false;
    while(ch < '0' || ch > '9'){if(ch == '-') flag = true; ch = getchar();}
    while('0' <= ch && ch <= '9'){x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    if(flag) x = -x;
}

inline void write(int a)
{
    if(a > 9) write(a / 10);
    putchar(a % 10 + '0');
}

inline int Max(int x, int y){ return x > y ? x : y; }

inline bool cmp(P x, P y){ return x.r > y.r; }

int main()
{
    int n, ans;
    read(n);
    for(re int i = 1;i <= n;i++) {
        read(a[i].w), read(a[i].r);
    }
    sort(a + 1, a + n + 1, cmp);
    dp[1] = a[1].w, ans = a[1].w;
    for(re int i = 1;i <= n;i++) {
        for(re int j = i;j >= 1;j--) {
            dp[j] = Max(dp[j], dp[j - 1] + a[i].w - a[i].r * (j - 1));
            if(i == n) ans = Max(ans, dp[j]);
        }
    }
    write(ans);
    return 0;
}
```


---

## 作者：Stars_visitor_tyw (赞：1)

## P2647 最大收益 题解
### 思路
一道 DP 好题。

定义状态为：`dp[i][j]` 表示前 $i$ 个物品中选 $j$ 的最大收益。（其实题目有提示了）

状态转移方程：`dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+w[i]-r[i]*(j-1)`，从题目便可推理出来。

最后，我们要想使收益最大，需要将 $R$ 数组在倒着进行状态转移时使用贪心思想从大到小排序，然后在 `dp[n][i]` 里取最大值即可得到答案。
### 代码
```cpp
#include<assert.h> 
#include<ctype.h> 
#include<errno.h> 
#include<float.h> 
#include<math.h> 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#include<time.h> 
#include<wchar.h> 
#include<wctype.h>
#include<algorithm> 
#include<bitset> 
#include<cctype> 
#include<cerrno> 
#include<clocale> 
#include<cmath> 
#include<complex> 
#include<cstdio> 
#include<cstdlib> 
#include<cstring> 
#include<ctime> 
#include<deque> 
#include<exception> 
#include<fstream> 
#include<functional> 
#include<limits> 
#include<list> 
#include<map> 
#include<iomanip> 
#include<ios> 
#include<iosfwd>
#include<iostream> 
#include<istream> 
#include<ostream> 
#include<queue> 
#include<set> 
#include<sstream> 
#include<stack> 
#include<stdexcept> 
#include<streambuf> 
#include<string> 
#include<utility> 
#include<vector> 
#include<cwchar> 
#include<cwctype>
#define int long long
using namespace std;
int n,dp[3005][3005],ans;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct node
{
	int w,r;
}t[3005];
bool cmp(node x,node y)
{
	return x.r>y.r;
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		cin>>t[i].w>>t[i].r;
	}
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+t[i].w-t[i].r*(j-1));
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,dp[n][i]);
	}
	cout<<ans;
	return 0;
}

---

## 作者：LIUYC_C (赞：0)

[题目链接。](https://www.luogu.com.cn/problem/P2647)

个人觉得真不能算难。

## 大体思路：

思路已经有大佬说了，我具体解释一下。

嗯，拿到这题，我还是和往常一样看错了题目。

没看见可以任意选多个物品，代价不是全局叠加吗，那行，我直接贪心，排序后搞一下就好了，这也能算蓝题？

(嗯，怎么贪的，就是他的减少是对全局的物品而言，因此肯定要让 $R_{i}$ 值小的先选，这样对后面的削减最少，从而让价值最大。)

蒟蒻错误代码：

[link。](https://www.luogu.com.cn/paste/l4clpbsb)

嗯，只有 20 分，再看了看题目，嗯，还有 20 分。

**接下来正经做法：**

遇到这种任意选择算贡献，dp 不用说。（有点类似多重背包？）

考虑状态设计：

我们先用最简单的脑子去思考，肯定会设 $f_{i,j}$ 表示前 $i$ 个数中，选择了 $j$ 次的最大价值。

那接下来考虑转移喽，这个时候，我们就会思考，怎么从 $i-1$ 转移到 $i$ 呢？

有两种转移方式。

第一种是选择第 $i$ 个物品。

因为我每选一个数就会导致所有未选的物品的收益都会减少 $R_{i}$, 而我在选第 $i$ 个数之前，我肯定选了 $j-1$ 个数，那么选第 $i$ 个数的代价这样肯定就不好转移，为什么？

因为我选的第 $j$ 个物品的影响是对没选的物品有影响的，对于已选的 $j-1$ 个数没有效果，具有后效性，转移的代价该怎么从前面计算过来呢，叠加是很不现实的，所以正着不好转移，那么，**最妙也最难的地方来了**，我们可以转换思路，转移方程表示我要选 $j$ 个数，但我选的第 $i$ 个数是在这 $j$ 个数前被选的，因此剩下的 $j-1$ 个数都会被第 $i$ 个数的贡献影响到，可以轻易写出转移方程。

$$f_{i,j}=\min(f_{i-1,j-1}+W_{i}-(j-1)\times R_{i})$$

我们可以想到这个转移方程要得到最优解，肯定是要用到我那 20 分的贪心思路，让最先枚举的物品的 $R_{i}$ 最小，保证全局最优解，正确性也很显然了。

第二种是不选择第 $i$ 个物品。

不必多说，肯定就是 $f_{i,j}=\min(f_{i-1,j})$ 了。

## 代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3010;
int f[N][N];
struct node{
    int r;
    int w;
}a[N];

bool cmp(node a,node b){
    if(a.r==b.r)return a.w<b.w;
    return a.r>b.r;
}


int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d%d",&a[i].w,&a[i].r);
    }
    sort(a+1,a+n+1,cmp);    
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){//上界似乎可以取到i，但我觉得n更保险
            f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[i].w-a[i].r*(j-1));
        }
    }
    
    int maxl=0;
    for(int i=1;i<=n;i++){
        maxl=max(maxl,f[n][i]);
    }
    cout<<maxl<<endl;
    
    return 0;
}

```
时间复杂度 $O(n^2+n\log n)$。

---

## 作者：WaterSun (赞：0)

# 思路

简单DP。

我们令 $dp_{i,j}$ 表示在前 $i$ 个物品中选 $j$ 件的最大收益。

根据题意，我们的状态转移方程就很好推出来了：$dp_{i,j} = \max(dp_{i - 1,j},dp_{i - 1,j - 1} + w_i - (j - 1) \times r_i)$。

那么我们最终的答案为：$\max(dp_{n,i})$。

其实，我们要在递推前对 $r$ 从大到小排序一遍。

这里用上了一个贪心的思想，因为对于每一个 $r$ 越后取它，代价就越大。那么如果 $r$ 越大的放在后面，它的代价就会比 $r$ 越小的放在后面的代价大。

# code

```cpp
#include <bits/stdc++.h>
#define re register

using namespace std;

const int N = 3010;
int n,ans;
int dp[N][N];

struct node{
	int w;
	int r;
	bool operator <(const node &t) const{//排序规则 
		return r > t.r;
	}
}arr[N];

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

int main(){
	n = read();
	for (re int i = 1;i <= n;i++){
		arr[i].w = read();
		arr[i].r = read();
	}
	sort(arr + 1,arr + 1 + n);//排序 
	dp[1][1] = arr[1].w;//这里要注意一下 
	for (re int i = 1;i <= n;i++){
		for (re int j = 1;j <= i;j++) dp[i][j] = max(dp[i - 1][j],dp[i - 1][j - 1] + arr[i].w - (j - 1) * arr[i].r);//递推 
	}
	for (re int i = 1;i <= n;i++) ans = max(ans,dp[n][i]);//取最大值 
	printf("%d",ans);
	return 0;
}
```

---

## 作者：一架飞机 (赞：0)

因为 dp 需要满足无后效性，但这里$r[i]$有后效性。所以我们**倒着选**，（可以想象成倒着选了 $j$ 个数之后再反过来）。现在在 $i$ 位置选择 $j$ 号物品的收益就是：$w[j]-(i-1) \times r[j]$。


我们要让这个收益最大。像不像一个**01背包**？但是这里对选择顺序是有要求的（改变顺序会让结果改变）。所以**先用贪心确定最优顺序**：假设现在已经选出来了 $k$ 个数，怎么排才能让收益最大呢？当然是 $r[i]$ 大的排前面。所以一个物品只能排在 $r$ 比它大的物品的后面。所以先以 $r[i]$ 降序排列。

然后就是一个01背包板子了。

AC代码（部分）：
```cpp
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
	for(int j=1;j<=n;j++){
		dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1));
	}
}
for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);
cout<<ans;
```



---


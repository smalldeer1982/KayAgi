# 原核生物培养

## 题目描述

W 教授最近正在研究一种原核生物，这种生物的生长方式很奇特，只能通过吃掉同类而生长。两个该种生物相遇，较大质量的会把较小的吃掉（相同的话就看 RP 了），吃掉后较大的生物的质量会变为两只原核生物重量之和，但这个过程会消耗酶，消耗的酶近似为它们重量之和。

W 教授现在有 $n$ 只原核生物，他每次会从培养皿中取重量最小的 $m$ 个生物进行实验，让它们自相残杀。

实验的操作是这样的，教授将这 $m$ 个原核生物按某种重量大小的顺序放在一个环形的管道里，然后给其中相邻两只原核生物酶，如此反复。最后把剩下的那只放回培养皿，接着进行下次实验。W 教授希望经过 $k$ 次实验后耗能最少。输入数据保证，不会出现生物不够的情况。


## 说明/提示

对于 $100\%$ 的数据，$1<n\leq 1000$, $1\leq m\leq 10$, $1\leq k\leq 100$。数据保证结果不超过 $2^{31}$。

样例解释：

第一次是用重量为 $1, 2$ 消耗酶 $3$，变为一个重量 $3$。

第二次是用重量为 $3, 3$ 消耗酶 $6$，变为一个重量 $6$。

第三次是用重量为 $4, 5$ 消耗酶 $9$，变为一个重量 $9$。

所以消耗总酶为 $18$。


## 样例 #1

### 输入

```
10 2 3
1 2 3 4 5 6 7 8 9 10
1 2
1 2
1 2```

### 输出

```
18```

# 题解

## 作者：kkksc03 (赞：17)

合并果子+石子归并。

取出最小的m个有两种办法，一是堆，而是开第二个队列保证有序（参看合并果子题解。）

堆就不用说了。

新开一个队列就是把剩下的那个放入第二个队列，然后再取就去两个队列中最小的m个。第二个队列一定是有序的。

然后dp

假设有菌AiAi+1……Aj需要合并的最小消耗,简记为F[i,j].由于是环形的，j最大可以是2\*m-1

当i=j时,表示只有一堆石头,不能合并,因此得分为零,所以F[i,j]=0;

当i<j时,可利用最优子结构性质来计算F[i][j],

F[i,j]=F[i,k]+F[k+1,j]+totalValue(i,j)(i<=k<j) 



---

## 作者：Binary_Search_Tree (赞：3)

[合并果子](https://www.luogu.org/problemnew/show/P1090)+[石子合并](https://www.luogu.org/problemnew/show/P1880#sub)(没做的可以先做一下)

本蒟蒻认为没有提高+/省选-的难度。

这个~~看似复杂的~~问题实际上是由两个较为简单的问题组成的

第一个：**如何每次选出最小的m个生物？**

第二个：**选出m个生物后如何算出最少的酶？**

首先解决第一个问题。

可以用堆做，也可以用数组。

用堆做的话就是建一个小根堆，每次取出最小的m个，再把他们的和放进去。

但是由此观察到**每次放进去的和一定是递增的**，所以可以用两个数组，一个是原数组，一个是每次的和。每次用归并的思想，从两个数组中取出较小的m个，再把结果扔到第二个里面去。

**综合来讲，数组更麻烦一点，但效率高。**虽然在本题中没什么用，但这是一种优化的方法。在[蚯蚓](https://www.luogu.org/problemnew/show/P2827)中有用哒

再解决第二个问题。

其实就是**区间DP**。F[i,j]=F[i,k]+F[k+1,j]+totalValue(i,j)(i<=k<j)

但本题是一个环，可以**把原区间复制一份**，变为长度为m+m的一条链。另外要预处理出前缀和算i到j的和。**DP时也要循环到m+m!**

**代码**

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;
const int M=1005;
const int N=25;
const int INF=2147483647;
int front1,front2,back1,back2,m,k,ans;
int a[M],b[M],p[N],q[N],now[N],f[N][N];
inline int read(){
	char c=getchar();int ans=0;
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans;
}//快读（其实没什么用）
int min(int u,int v){return u<v?u:v;}
int max(int u,int v){return u>v?u:v;}
void work(){
	for (int i=1;i<=m+m;i++)
		for (int j=i+1;j<=m+m;j++) f[i][j]=INF;//初始化
	for (int l=2;l<=m;l++)
		for (int i=1;i<=m+m-l+1;i++){
			int j=i+l-1;
			for (int k=i;k<j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+q[j]-q[i-1]);
		}
	int nans=INF;
	for (int i=1;i<=m;i++) nans=min(nans,f[i][i+m-1]);
	ans+=nans;
	return;
}//区间DP
int main(){
	back1=read(),m=read(),k=read();front1=front2=1;
	for (int i=1;i<=back1;i++) a[i]=read();
	sort(a+1,a+1+back1);//一定要记得排序！
	while (k--){
		for (int i=1;i<=m;i++) now[i]=read();
		for (int i=1;i<=m;i++){
			if (back1<front1) p[i]=b[front2++];
			else if (back2<front2) p[i]=a[front1++];
			else if (a[front1]<b[front2]) p[i]=a[front1++];
			else p[i]=b[front2++];
		}//类似于归并，从a,b两个数组中选较小的
		for (int i=1;i<=m;i++) q[i]=0;//初始化
		for (int i=1;i<=m;i++) q[i]=q[i-1]+p[now[i]];
		for (int i=1;i<=m;i++) q[i+m]=q[i-1+m]+p[now[i]];
		b[++back2]=q[m];
	    work();
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：SHOJYS (赞：2)

# 原核生物培养

[link](https://www.luogu.com.cn/problem/P2654).    

我们把它分为两个部分，一个是区间动规部分，一个是维护最小值。  

## 区间动规部分  

一看就认为这个是区间动规。我们可以看一下这道题[ NOI1995 石子合并](https://www.luogu.com.cn/problem/P1880)。  
看完后可知状态转移方程就是是求合并石子最小得分。  
我们设 $dp_{i,j}$ 是第 $i$ 个生物至第 $j$ 个生物互相残杀所消耗酶最小值，则我们可以得到以下状态转移方程式：  
$$dp_{i,j}=\min\{dp_{i,j},dp_{i,k}+dp_{k+1,j}+\sum\limits_{p=i}^{j} a_p\}$$  
显而易见，求和部分 $\sum \limits_{p=i}^{j}a_p$ 直接可以用前缀和优化。    
由于是环形，所以要断环为链，数组需要复制 $1$ 倍。  
此处代码展示：  

```cpp
int a[31],dp[40][40];
signed main(){
   	m1=m<<1;
	for(p=1;p<=k;p++){
		for(i=1;i<=m1;i++)a[i]+=a[i-1],dp[i][i]=0;//前缀和+初始化
		md=0x7f7f7f;
		for(len=2;len<=m;len++)
			for(i=1,j=i+len-1;i<=m1&&j<=m1;i++,j=i+len-1)
				for(t=i;t<j;t++)dp[i][j]=min(dp[i][j],dp[i][t]+dp[t+1][j]+a[j]-a[i-1]);
		for(i=1;i<=m;i++)md=min(md,dp[i][i+m-1]);
	}
}
```

## 维护最小值

与[合并果子](https://www.luogu.com.cn/problem/P1090)极其相似，我们可以用堆做。  
用 STL 即可。我们需要维护最小值，那么我们需要小根堆。  
维护最小值：  

```cpp
for(j=1;j<=m;j++){
	cin>>kkk;
	a[kkk+m]=a[kkk]=st.top();
	st.pop();
}
st.push(a[m]);
```

## 代码  

给主要代码：  

```cpp
typedef long long LL;
priority_queue<int,vector<int>,greater<int> >st;
int a[31],dp[40][40];
signed main(){
	register int i,j,p,len,t;
	int n,m,k,kkk,md,m1;
	LL ans(0);
   cin>>n>>m>>k;
	m1=m<<1;
	for(i=1;i<=n;i++){
		qrw.read(kkk);
		st.push(kkk);
	}
	for(p=1;p<=k;p++){
		memset(dp,0x7f7f,sizeof(dp));
		memset(a,0,sizeof(a));
		for(j=1;j<=m;j++){
			cin>>kkk;
			a[kkk+m]=a[kkk]=st.top();
			st.pop();
		}
		for(i=1;i<=m1;i++)a[i]+=a[i-1],dp[i][i]=0;
		st.push(a[m]);
		md=0x7f7f7f;
		for(len=2;len<=m;len++)
			for(i=1,j=i+len-1;i<=m1&&j<=m1;i++,j=i+len-1)
				for(t=i;t<j;t++)dp[i][j]=min(dp[i][j],dp[i][t]+dp[t+1][j]+a[j]-a[i-1]);
		for(i=1;i<=m;i++)md=min(md,dp[i][i+m-1]);
		ans+=md;
	}
	cout<<ans;
    exit(0);
    return 0;
}
```


---

## 作者：没见过AC (赞：1)

对于拿出质量最小的 $m$ 个生物，可以用堆，也可以维护一个有序的数列。这里我们使用更方便一些的堆。


之后 dp 出每次操作的最小值，这个 dp 很板子，具体可以参考[石子合并](https://www.luogu.com.cn/problem/P1880)。

状态转移方程如下：

$$dp_{l,r}=\min(dp_{l,p}+dp_{p+1,r}+\sum\limits_{i=l}^rw_i)$$

其中 $w_i$ 的求和可以用前缀和优化掉。

最后剩下的生物的质量显然为 $m$ 个生物的质量和。将其加入堆，重复进行 $k$ 次操作即可。

细节处理见代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+100,M=50;
#define reg register
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
    char c=getchar();ll x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*f;
}
ll m,n,k,a[N],b[M],dp[M][M],ans=0,sum[M];
priority_queue<int,vector<int>,greater<int> > xiao;//小根堆 
int main()
{
    n=read();
    m=read();
    k=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		xiao.push(a[i]);
	}
	while(k--)
	{
		memset(dp,0x3f,sizeof dp);
		memset(sum,0,sizeof sum);
		memset(b,0,sizeof b);
		for(int i=1;i<=m;i++)
		{
			int x=read();
			b[x]=xiao.top();
			b[x+m]=xiao.top();//将环转化成链 
			xiao.pop();
		}
		for(int i=1;i<=m*2;i++)//注意是从1到2m 
		{
			sum[i]=sum[i-1]+b[i];
			dp[i][i]=0;
		}
		for(int l=2;l<=m;l++)
		{
			for(int i=1;i<=2*m-l+1;i++)
			{
				int j=i+l-1;
				for(int p=i;p<j;p++)
				{
					dp[i][j]=min(dp[i][j],dp[i][p]+dp[p+1][j]+sum[j]-sum[i-1]);//转移方程 
				}
			}
		}
		ll xyz=1145141919810;
		for(int i=1;i<=m;i++)
		{
			xyz=min(xyz,dp[i][i+m-1]);//因为是转化成链处理，所以还要再找到最优的链 
		}
		ans+=xyz;
		xiao.push(sum[m]);//放回去剩下的那个生物 
	}
	cout<<ans;
	return 0;
}


```

---

## 作者：toolong114514 (赞：1)

# P2654 原核生物培养 题解
## 题面大意
[传送门。](https://www.luogu.com.cn/problem/P2654)
## 解题思路
比较板子，~~黄 + 黄（绿？）=蓝~~。

首先考虑如何取出前 $m$ 小的生物，并且在自相残杀完后放回去。

直接用一个小根堆维护生物的质量，每次连续 $m$ 次拿出堆顶元素，然后将它们的和扔回去即可。

然后考虑计算自相残杀的最小代价。

记放置好的生物的质量序列为 $a$。

每个生物只能吃掉相邻的或被相邻的吃掉，所以考虑区间 DP。

定义 $f_{i,j}$ 为区间 $[i,j]$ 中的生物自相残杀，组成一个生物后，花费的最小代价。

容易发现，$\forall i\in[1,m],f_{i,i}=0$，这是 $f$ 的初始条件。

如果想让 $[i,j]$ 内的生物合为一体，那么需要枚举最后两个生物是如何合并出来的。

所以有转移方程如下：

$$f_{i,j}=\min_{t=i}^{j-1}{f_{i,t}+f_{t+1,j}+\sum^{j}_{p=i}a_p}$$

又因为管道是环状的，所以要破环成链，长度翻倍，取所有长度为 $m$ 的区间答案的最小值。

对于每一次实验，累加这个最小值即可。

时间复杂度约为 $O(km^3+km\log{n})$，可以通过本题。
## 参考代码

```cpp
#include<iostream>
#include<queue>
using namespace std;
#define int long long
const int INF=0x3f3f3f3f;
priority_queue<int,vector<int>,greater<int> > q;
int f[1005][1005];
int qz[1005];
int n,m,k,ans;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		q.push(x);
	}
	while(k--){
		int sum=0;
		for(int i=1;i<=m;i++){
			int p;
			cin>>p;
			f[p][p]=q.top();
			sum+=q.top();
			//cout<<q.top()<<endl;
			q.pop();
		}
		q.push(sum);
		for(int i=m+1;i<=2*m;i++){
			f[i][i]=f[i-m][i-m];
		}
		for(int i=1;i<=2*m;i++){
			qz[i]=qz[i-1]+f[i][i];
			f[i][i]=0;
		}
		for(int len=2;len<=m;len++){
			for(int i=1;i<=2*m&&i+len-1<=2*m;i++){
				int j=i+len-1;
				f[i][j]=INF;
				for(int t=i;t<j;t++){
					f[i][j]=min(f[i][j],f[i][t]+f[t+1][j]+qz[j]-qz[i-1]);
				}
			}
		}
		int minn=INF;
		for(int i=1;i<=m;i++){
			//cout<<f[i][i+m-1]<<" ";
			minn=min(minn,f[i][i+m-1]);
		}
		//cout<<endl;
		ans+=minn;
	}
	cout<<ans;
	return 0;
}
```
[本代码可以通过洛谷评测。](https://www.luogu.com.cn/record/173621376)

Written by [toolong114514](https://www.luogu.com/user/477821) on 2024/8/19.

---

## 作者：破忆 (赞：1)

### 题目大意
有一些原核生物，多次按特定方式排序，让它们自相残杀，自相残杀需要消耗酶，求最少需要多少酶


------------

### 分析
#### 排序
每次挑最小的进行试验，也就是多次挑最小，自然而然就想到了**堆**

把所有生物放入堆，每次挑最小，每次试验完把总和重新放回堆即可

（也可以调用STL的堆、优先队列、集合等数据结构，不过手码堆的效率最高，因此题数据范围较小，手码堆的高效体现不出来）

#### 求最小花费
按特定方式排序，并归并，套区间DP的模板就行了

注意此题生物是呈环形排列的，把原数列往后复制一段即可


------------

### 解法
堆+区间DP


------------
### 代码
```cpp
#include<bits/stdc++.h>
#define IN inline
#define RE register
using namespace std;
const int maxn=1e3+5,maxm=25;
int n,m,k;
int hep[maxn],len;
int a[maxm],s[maxm],f[maxm][maxm],ans;
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
IN void put(int x){//手码的堆稍微有点冗长，但代码量换效率还是一份好买卖
	hep[++len]=x;
	int son=len;
	while(son>1&&hep[son]<hep[son>>1]){
		swap(hep[son],hep[son>>1]);
		son>>=1;
	} 
}
IN int get(){
	int ret=hep[1],son,fa=1;
	hep[1]=hep[len--];
	while((fa<<1)<=len){
		if((fa<<1|1)>len||hep[fa<<1]<hep[fa<<1|1]) son=fa<<1;else son=fa<<1|1;
		if(hep[son]<hep[fa]) swap(hep[fa],hep[son]),fa=son;else break;
	}
	return ret;
}
IN void DP(){//区间DP
	for(RE int i=1;i<=m;i++) a[i+m]=a[i];//原数组往后复制一段
	int mm=m<<1;
	memset(f,63,sizeof f);
	for(RE int i=1;i<=mm;i++) s[i]=s[i-1]+a[i],f[i][i]=0;//构造前缀和并附初值
	for(RE int len=2;len<=m;len++)//接下来套区间DP模板即可，len表示长度
	for(RE int i=1;i+len-1<=mm;i++){//i枚举区间起点
		int j=i+len-1;//j表示终点
		for(RE int t=i;t<j;t++) f[i][j]=min(f[i][j],f[i][t]+f[t+1][j]);//转移方程也不难推，枚举一个分割点t就好了
		f[i][j]+=s[j]-s[i-1];
	}
	int now=1<<30;
	for(RE int i=1;i<=m;i++) now=min(f[i][i+m-1],now);
	ans+=now; 
}
int main(){
	freopen("P2654.in","r",stdin);
	freopen("P2654.out","w",stdout);
	n=read(),m=read(),k=read();
	for(RE int i=1;i<=n;i++) put(read());//先把所有数字赛进堆
	for(RE int i=1;i<=k;i++){
		for(RE int j=1;j<=m;j++) a[read()]=get();//按题目要求填尽数组
		DP();
		put(s[m]);/记得把总和放回去
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：kczno1 (赞：1)


n<=1000 m<=10 k<=100

第i次实验后

1插排:O(n\*k)<=10^5

每一次：

x=上次实验中重量之和,

二分查找一个位置i使a[i]<x<=a[i+1],O(log2(n));

插入,O(n)

2数组a中的存储位置变为i\*(m-1)+1..n


第i次实验中:

取数组a中(i-1)\*(m-1)+1..(i-1)\*(m-1)+m复制到数组b中数据给出的位置

进行操作:

复制一份在数组b尾；(环形)

用规模进行动规(规模2..m);

再取f[i,i+m-1]的最小值(i=1..m).

每一次时间:O(2\*m+m\*2m+m)<=20+200+10=230

总时间<=230\*100=2.3\*10^5


别忘了一开始快排一次，否则0分。。。

```delphi

var
  n,m,k,i,j,k1,ans,t,ans1,num:longint;
  a:array[1..1000] of longint;
  b,sum:array[0..20] of longint;
  f:array[1..20,1..20] of longint;
  x,l,r,mid:longint;

function min(x,y:longint):longint;
begin
  if x<y then exit(x);
  exit(y);
end;

procedure swap(var x,y:longint);
var t:longint;
begin
  t:=x;
  x:=y;
  y:=t;
end;


procedure qsort(l,r:longint);
var
  i,j,mid,mida:longint;
begin
  i:=l; j:=r; mid:=(i+j)div 2;
  mida:=a[mid];
  repeat
    while a[i]<mida do inc(i);
    while a[j]>mida do dec(j);
    if i<=j then
    begin
      if i<j then
      begin
        swap(a[i],a[j]);
      end;
      inc(i); dec(j);
    end;
  until i>j;
  if i<r then qsort(i,r);
  if l<j then qsort(l,j);
end;

begin
  readln(n,m,k);
  if m=1 then
  begin
   write(0);
   halt;
  end;
  for i:=1 to n do
   read(a[i]);

  qsort(1,n);

  for i:=1 to k do
  begin
   for j:=1 to m do
   begin
    read(num);
    b[num]:=a[j+(i-1)*(m-1)];
   end;
   for j:=1 to m-1 do
    b[j+m]:=b[j];

   for j:=1 to 2*m-1 do
    sum[j]:=sum[j-1]+b[j];

   for t:=2 to m do
    for j:=1 to 2*m-t do
    begin
     f[j,j+t-1]:=maxlongint;
     for k1:=j to j+t-2 do
      f[j,j+t-1]:=min(f[j,j+t-1],f[j,k1]+f[k1+1,j+t-1]);
     if f[j,j+t-1]=maxlongint then f[j,j+t-1]:=0;
     inc(f[j,j+t-1],sum[j+t-1]-sum[j-1]);
    end;

   ans1:=f[1,m];
   for j:=2 to m do
    ans1:=min(ans1,f[j,j+m-1]);
   inc(ans,ans1);

   x:=sum[j];
   l:=i*(m-1)+2;
   if x<a[l] then a[l-1]:=x
   else
   begin
    r:=n;
    while l+1<r do
    begin
     mid:=(l+r) div 2;
     if a[mid]>=x then r:=mid
     else l:=mid;
    end;
    for j:=i*(m-1)+2 to l do
     a[j-1]:=a[j];
    a[l]:=x;
   end;
  end;

  writeln(ans);
end.

```

---

## 作者：_JF_ (赞：0)

[Link](https://www.luogu.com.cn/problem/P2654)

很板的题。

容易发现，每次操作相当于，总是前 $m$ 小的数删除，然后在原序列里加入一个数，这个操作很好实现，直接考虑把原序列前 $m$ 个数删掉，然后在最后一个位置加上新的数，然后对整个数组排序即可。

关于加入的这个数，是前 $m$ 小的数的和，因为剩余最后一个生物质量是他们质量总和，这个显然。

所以说，每次操作是互不影响的，考虑一次操作，一次操作其实就是把这 $m$ 个数按照一定顺序放置，每次可以删掉相邻两个。代价是他们的和，以及把他们的和放到删掉数的位置上去。

不难想到区间动态规划，考虑设 $dp_{i,j}$ 表示删除了 $[i,j]$ 以后的最小代价，发现只需要枚举中间断点 $k$，看作是 $[i,k]$ 剩下的生物和 $[k+1,j]$ 生物残杀，代价就是整个区间的和。

$$dp_{i,j}=\min\{dp_{i,k}+dp_{k+1,j}+s_j-s_{i-1}\}$$

其中 $s$ 是前缀和。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1001;
#define int long long 
int n,m,k,sum,a[N],dp[21][21],c[21],s[21],dis[N];
void Add(){
	int node=-1,lst,ans=0;
	for(int i=1;i<=m;i++)	ans+=a[i];
	for(int i=m+1;i<=n;i++)	a[i-m]=a[i];
	n-=m,n++,a[n]=ans;
	sort(a+1,a+n+1);
}
void DP(){
	memset(dp,0x3f,sizeof(dp));
	int ans=dp[0][0];
	for(int i=1;i<=m;i++)	c[i]=c[i+m]=a[dis[i]];
	for(int i=1;i<=2*m;i++)	s[i]=s[i-1]+c[i],dp[i][i]=0;
	for(int len=2;len<=m;len++)
		for(int i=1;i<=2*m-len+1;i++){
			int j=(i+len-1);
			for(int k=i;k<j;k++)	
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+s[j]-s[i-1]);
		}
	for(int i=1;i<=m;i++)	ans=min(ans,dp[i][i+m-1]);
	sum+=ans;
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)	cin>>a[i];
	sort(a+1,a+n+1);
	while(k--){
		for(int i=1;i<=m;i++)	cin>>dis[i];
		DP(),Add();
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：紊莫 (赞：0)

简单题。

首先考虑取出题目要求的最小的 $m$ 个数字，显然可以使用优先队列在线维护。考虑取出后如何计算贡献，由于这是一个区间 DP 板子，所以我在这里直接给出方程：  

$$f_{l,r}=\min(f_{l,p}+f_{p+1,r}+\sum_{i=l}^{r} a_i)$$  

显然后面那个东西前缀和优化一下就没了。  

[示例代码。](https://www.luogu.com.cn/paste/qr6gkeiy)  

注意一个地方，动态规划后算出来的共享显然是比 $\sum_{i=l}^{r} a_i$ 要大的，所以在优先队列加入新节点的时候不能把 DP 算出来的答案加进去。

---


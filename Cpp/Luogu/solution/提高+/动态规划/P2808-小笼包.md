# 小笼包

## 题目背景

JOI同学的午饭，是在中华料理店买的小笼包。这是一种用小麦粉制成的皮包着馅和热汤的料理，吃的时候，热汤会飞溅出来。


## 题目描述

JOI 同学点的小笼包套餐，由馅料不同的 $N$ 个小笼包组成。$N$ 个小笼包等间隔排成一列，编号为 $1$ 到 $N$。第 $i$ 个小笼包与第 $j$ 个小笼包之间的距离是绝对值 $\vert i - j \vert$。
JOI 同学按照顺序吃小笼包。最初，所有的小笼包的美味度都是 $0$。吃第 $i$ 个小笼包时，汤汁向周围飞散，与第 $i$ 个小笼包距离 $D_i$ 以下的小笼包都淋上了汤汁，而被淋上汤汁的小笼包的美味度会增加 $A_i$。也就是说，吃第 $i$ 个小笼包的时候，第 $j$ 个小笼包 $(1 \leq j \leq N $ 并且 $ i - D_i \leq j \leq i + D_i)$ 还没有吃到的话，第 $j$ 个小笼包的美味度就增加 $A_i$。

 ![](https://cdn.luogu.com.cn/upload/pic/2340.png) 

JOI 同学要在吃小笼包的顺序上下功夫，让吃的小笼包的美味度的合计最大化。

## 说明/提示

样例 $1$ 的说明：以第 $5 \rightarrow$ 第 $3 \rightarrow$ 第 $1 \rightarrow$ 第 $2 \rightarrow$ 第 $4$ 的顺序吃的话，美味度合计为 $20$，因为美味度超过 $20$ 的吃法是不存在的，所以这是最好的。

本题是 2014 年日本信息学奥林匹克（JOI）预选第 6 题。

## 样例 #1

### 输入

```
5
1 0 1 1 2
0 2 6 3 4```

### 输出

```
20```

## 样例 #2

### 输入

```
10
5 2 7 2 6 5 3 5 3 6
8 7 8 4 0 6 0 10 10 0```

### 输出

```
237```

# 题解

## 作者：朱江黄河 (赞：10)

DP
我们发现当前这个包子的美味度最多只与它前后14个包子的顺序有关

于是我们用f[i][j]表示前i个包子并且最后8个吃的顺序为j的最大值

则f[i][j]=max(f[i-1][后7位和j的前7位相同的顺序]+第i个包子造成的美味值)

具体顺序实现用康托展开枚举全排列

注意在i不足8个时不用取max,并且全排列不到8位

```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    #define maxn 105
    #define maxs 40350
    int a[maxn],d[maxn],f[2][maxs],maxd,w[10],w1[10];
    const int fac[]={1, 1, 2, 6, 24, 120, 720, 5040, 40320};//阶乘,不够用可以再加 
    int cantor(int a[],int k){//康托展开 
        int ans=0,tmp;
        for(int i=0;i<k;i++){
            tmp=0;//记录有几个比它小的数 
            for(int j=i+1;j<k;j++){
                if(a[j]<a[i])tmp++;
            }
            ans+=tmp*fac[k-i-1];
        }
        return ans;
    }
    void uncantor(int a[],int k,int num){//逆康托展开
        int b[10];//b表示剩下的数,并且按升序排列 
        for(int i=0;i<k;i++)b[i]=i+1;
        b[k]=0;
        for(int i=0,x;i<k;i++){
            x=num/fac[k-i-1],num%=fac[k-i-1],a[i]=b[x];//x表示当前数是剩下的数中的第几个 
            for(int j=x;b[j];j++){
                b[j]=b[j+1];
            }
        }
    }
    void nextpermutation(int a[],int k){//下一个全排列 
        for(int i=k-2;i>=0;i--){
            if(a[i]<a[i+1]){//找到最后一个非降序的值 
                int j;
                for(j=k-1;j>i;j--){
                    if(a[i]<a[j])break;
                }
                a[i]^=a[j],a[j]^=a[i],a[i]^=a[j];//将最后一个非降序的数与后面第一个大于它的数互换 
                reverse(a+i+1,a+k);//将后面的数按升序排序,但因为是降序,所以反转一下就行了 
                return;
            }
        }
    }
    int calc(int w[],int k,int r){//计算美味值 
        int ans=0;
        for(int i=0,j=r-k;i<k;i++,j++){
            if(w[i]>w[k]){
                if(k-i<=d[r])ans+=a[r];
            }
            else{
                if(k-i<=d[j])ans+=a[j];
            }
        }
        return ans;
    }
    int main(){
        int n,ans=0;scanf("%d",&n);
        for(int i=0;i<n;i++)scanf("%d",d+i),maxd=max(maxd,d[i]);
        for(int i=0;i<n;i++)scanf("%d",a+i);
        for(int i=0;i<n;i++){
            int k=min(i,maxd);
            for(int j=0;j<k;j++){
                w[j]=j+1;
            }
            for(int j=1;j<=fac[k];j++,nextpermutation(w,k)){
                int x=0;
                if(i<=maxd)x=f[!(i&1)][cantor(w,k)];
                else{
                    for(int l=1;l<=k;l++)w1[l]=w[l-1];
                    for(int l=1;l<=k+1;l++){
                        w1[0]=l;
                        for(int m=1;m<=k;m++)if(w1[m]>=w1[0])w1[m]++;
                        x=max(x,f[!(i&1)][cantor(w1,k+1)]);
                        for(int m=1;m<=k;m++)if(w1[m]>w1[0])w1[m]--;
                    }
                }
                for(int l=1;l<=k+1;l++){
                    w[k]=l;
                    for(int m=0;m<k;m++)if(w[m]>=w[k])w[m]++;
                    f[i&1][cantor(w,k+1)]=max(f[i&1][cantor(w,k+1)],x+calc(w,k,i));
                    for(int m=0;m<k;m++)if(w[m]>w[k])w[m]--;
                }
            }
        }
        for(int i=0;i<fac[8];i++){
            ans=max(ans,f[!(n&1)][i]);
        }
        printf("%d",ans);
        return 0;
}
```

---

## 作者：zqy1018 (赞：3)

这是一道运用了类似于状态压缩方法的题目。

原理看这里：[题解](http://leanote.com/blog/post/593d36f3ab64413b7d0014ee)

代码如下，也有注释，结合题解应该比较好懂

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cctype>
#define INF 2000000000
using namespace std;
typedef long long ll;
int f[2][7000000]={0},permu[10],permu2[10];
int n,d[105],a[105]; 
int read(){
    int f=1,x=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return f*x; 
}    
void init_permu(){
    for(int j=0;j<7;j++)
        permu[j]=j;
} 
int ptoi(int *L){
    int res=0;
    for(int i=0;i<7;i++)
        res=res*10+L[i];
    return res;
}
void init(){
    n=read();
    for(int i=0;i<n;i++)d[i]=read();
    for(int i=0;i<n;i++)a[i]=read();
}
void solve(){
    for(int i=0;i<n;i++){
        init_permu();
        int B=(i&1),B_=(B^1),cnt,code1,code2;
        do{
            code1=ptoi(permu);
            for(int k=0;k<=7;k++){
            //枚举新加入的位置
                cnt=0;
                int contribution=0;
                //在第i个被吃掉之前他被泼到的 
                for(int kk=0;kk<k;kk++){
                    int loc=i-1-permu[kk];
                    if(loc>=0&&permu[kk]+1<=d[loc])
                        contribution+=a[loc];
                    if(permu[kk]<6)
                        permu2[cnt++]=permu[kk]+1;
                }
                permu2[cnt++]=0;
                //在第i个被吃掉之后他被泼到的
                for(int kk=k;kk<7;kk++){
                    int loc=i-1-permu[kk];
                    if(loc>=0&&permu[kk]+1<=d[i])
                        contribution+=a[i];
                    if(permu[kk]<6)
                        permu2[cnt++]=permu[kk]+1;
                }
                code2=ptoi(permu2);
                f[B_][code2]=max(f[B_][code2],f[B][code1]+contribution);
            }
            f[B][code1]=0;
        }while(next_permutation(permu,permu+7));
    }
    int ans=0;
    init_permu();
    do{
        ans=max(ans,f[n&1][ptoi(permu)]);
    }while(next_permutation(permu,permu+7));
    printf("%d\n",ans);
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：哈撒各一 (赞：2)

前置芝士：[康托展开](https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80)

本片题解主要解决前几篇题解看不懂的情况，如果能看懂前面几篇题解请自行跳过。

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 110
#define J 5100
int n,d[N],a[N];
int fac[10]={1,1,2,6,24,120,720,5040};
int p[10],w[10],f[N][J],ans;
bool used[10];

//逆康拓展开 
inline void split(int x){
	memset(used,0,sizeof(used));
	x-=1;
	for(int i=1,ret,now;i<=7;++i){
		ret=x/fac[7-i];
		for(now=1;now<=n;++now){
			if(!used[now]){
				if(!ret)break;
				ret--;
			}
		}
		p[i]=now;
		used[now]=1;
		x%=fac[7-i];
	}
}
//康拓展开 
inline int merge(){
	int res=0;
	for(int i=1,ret;i<=7;++i){
		ret=0;
		for(int j=i+1;j<=7;++j){
			if(w[i]>w[j]){
				++ret;
			}
		}
		res+=ret*fac[7-i];
	}
	return res+1;
}
inline void init(){
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%d",d+i);
	}
	for(int i=1;i<=n;++i){
		scanf("%d",a+i);
	}
} 
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//ios::sync_with_stdio(false);
	//cin.tie(0),cout.tie(0);
	init();
	for(int i=1;i<=n;++i){
		for(int now=1;now<=fac[7];++now){//通过枚举康拓展开来枚举每一个顺序 
			split(now);//还原康拓展开到数组p中 
			for(int j=1,ret;j<=8;++j){
			//枚举第i+1个小笼包的顺序
				ret=0;
				for(int k=1;k<=7;++k){
					if(p[k]<j)w[k]=p[k];
					else w[k]=p[k]+1;
				}	
				w[8]=j;
				
			//计算第k个小笼包对第i+1个小笼包美味值的影响 
				for(int k=1;k<=7;++k){
			//以下三个判断条件依次是：
			//1.距离i+1号小笼包(7-k)的小笼包是否存在:
			//	如i+1==5时，距离为6的小笼包-1就不存在。
			//2.重新编号为k的小笼包是否在第i+1号小笼包之前被吃:
			//  显然只有在i+1号小笼包之前被吃才会对i+1号小笼包的美味值产生影响。 
			//3.重新编号为k的小笼包是否能够溅射到i+1号小笼包。 
					if((i-(7-k))>0&&w[k]<w[8]&&d[i-(7-k)]>=8-k){
						ret+=a[i-(7-k)];
					}
				}
			//计算第i+1个小笼包对第k个小笼包美味值的影响 
				for(int k=1;k<=7;++k){
					if((i-(7-k))>0&&w[k]>w[8]&&d[i+1]>=8-k){
						ret+=a[i+1];
					}
				}
				
			//此处为了记录[i-6,i+1]区间的选择情况，排除第i-7号的影响
			//例:2 4 5 1 3 6 7 8
			//=> 2 3 4 1 2 5 6 7 
				for(int k=2;k<=8;++k){
					if(w[k]>w[1])w[k]--;
				}
				for(int k=1;k<=7;++k){
					w[k]=w[k+1];
				}
			//再次康拓展开记录状态。 
				int x=merge();
				f[i+1][x]=max(f[i+1][x],f[i][now]+ret);
			}
		}
	}
	for(int i=1;i<=fac[7];++i){
		ans=max(ans,f[n][i]);
	}
	cout<<ans<<endl;
	return 0;
}

```


---


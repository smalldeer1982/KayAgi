# 加油问题

## 题目描述

一个美国旅行代理商经常被要求去估计开车从一个城市旅行至另一个城市的最小费用。他有一个在通常路线上的大多数加油站的列表。列表包括了所有加油站的位置及当前每加仑汽油的价格。

为了简化估计费用的过程，代理商使用了以下的简化汽车驾驶员行为的规则：

- 除非汽车无法用油箱里的汽油达到下一个加油站（如果有的话）或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。
- 在每一个停下的加油站，驾驶员总是将油加满。
- 在一个加油站停下之后，驾驶员将为旅程在快餐和糖果上花去 $2.00$ 元。
- 在驶向加油站或目的地时，驾驶员不需要超过必须量的汽油。不需要“安全余量”。
- 驾驶员开始旅行时油箱总是满的
- 每个加油站付款时四舍五入到分（ $1$ 元等于 $100$ 分）。

你必须写一个程序以估计驾驶员在旅程上至少要为汽油和食品付多少钱。


## 说明/提示

### 数据范围及约定

对于全部数据，$n \le 51$。

## 样例 #1

### 输入

```
475.6
11.9 27.4 14.98 6
102.0 99.9
220.0 132.9
256.3 147.9
275.0 102.9
277.6 112.9
381.8 100.9```

### 输出

```
27.31```

# 题解

## 作者：jinfanhao (赞：1)

这道题考虑搜索加剪枝。\
油箱内的油的余量大于等于油箱容量一半时，不能主动停下来，只能被动加油。所以我们在大于等于一半时要选择不加油，除非被动加油。\
如果小于油箱容量一半，那么我们就搜索加油与不加油，但是如果被动加油，这个时候就必须加油，不能不加油。\
记住输出时到分和保留两位小数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;
double len,L,S,sum,x[N],y[N],minx;
int n;
void dfs(int t,double ans,double sum){
	if(sum>minx)return;
	if(t==n+1){
		minx=min(minx,sum);	
		return;
	}
	if(ans*S>=x[t+1]-x[t]){
		if(ans>=L/2)dfs(t+1,ans-(x[t+1]-x[t])/S,sum);
		else{
			dfs(t+1,ans-(x[t+1]-x[t])/S,sum);
			dfs(t+1,L-(x[t+1]-x[t])/S,sum+2+(L-ans)*y[t]);
		}
	}else dfs(t+1,L-(x[t+1]-x[t])/S,sum+2+(L-ans)*y[t]);
}
signed main(){
	cin >> len >> L >> S >> sum >> n;
	minx=sum;
	for(int i=1; i<=n; ++i){
		cin >> x[i] >> y[i];
		y[i]/=100;
		minx+=20+L*y[i];
	}
	minx = 2e18;
	x[n+1]=len;
	dfs(1,L-x[1]/S,sum);
	printf("%.2lf",minx);
	return 0;
} 
```

---

## 作者：OIer_ACMer (赞：1)

~~第一次十二分钟切一道蓝题。~~

# 题目解析：

本题由于 $n \le 51$，我们就直接从搜索思考，（毕竟这么小的数据不练习搜索真是浪费了）。

我们可以借用一点闫氏动态规划分析法的思想，找出最后一个不同点：**是否在一个站加油**。我们在深度优先搜索中设三个参数：$wz$ 表示在那个油站，$mon$ 表示此时花掉的钱，至于 $oil$，则表示此时邮箱的剩余油量，如果加油，那么我们要考虑是否满足**在油箱里还有不少于最大容量一半的汽油**，因为，这是题目条件，后续操作就是用当地油价乘以差值加上两块钱餐费。不加油的话，只用让 $wz$ 加 $1$ 就行了，就是直接去下一个站。

什么，你问我为什么在不加油时不用对 $oil$ 操作，我要告诉你，我们在函数的**一开始就要将 $oil$ 减去从当前站到前一个站的耗油量**，如果在最后更新 $wz$ 算的话，额，也行。

最后，注意两个点，一个是要判断当前的点是否到达 $n + 1$ 的位置，因为，我们在主函数中设 $n + 1$ 为终点，并且将一开始输入的两点之间的总距离存入 $n +1$ 的距离数组中，方便计算耗油量，到了终点不下车就不对了。

第二个，如果我们判断此时的 $oil$ 已经小于目前站点到原来站点的耗油量，直接退出，不然的话将负数带进去算会出锅，懂得都懂。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
double dis, rl, w, mon;
int n;
struct node
{
    double jl, jg;
} zhan[1000009];
double ans = INT_MAX;
void dfs(int wz, double mon, double oil)
{
    if (oil < (zhan[wz].jl - zhan[wz - 1].jl) / w)
    {
        return;
    }
    else if (wz == n + 1)
    {
        ans = min(ans, mon);
        return;
    }
    oil -= (zhan[wz].jl - zhan[wz - 1].jl) / w;
    if (oil <= rl / 2)
    {
        dfs(wz + 1, mon + 2.00 + (1.0 * (zhan[wz].jg * (rl - oil)) / 100.0), rl); // 加油
    }
    dfs(wz + 1, mon, oil); // 不加油
}
int main()
{
    cin >> dis >> rl >> w >> mon;
    cin >> n;
    zhan[n + 1].jl = dis;
    zhan[0].jg = 0;
    for (int i = 1; i <= n; i++)
    {
        cin >> zhan[i].jl >> zhan[i].jg;
    }
    dfs(1, mon, rl);
    cout << fixed << setprecision(2) << ans;
    return 0;
}

```

---

## 作者：meimu75 (赞：0)

# 题解：P2836 加油问题

## 题目简化

   你要开长途车，车要加油，你要吃饭。你可以选择在一些加油站停下来，加油、吃饭。加油要钱，吃饭要钱，开车要耗油，让你算最少花多少钱从起点走到终点。

## 初步思路

   观察数据范围，发现 $n\le51$，结合上面的题目简化，感觉可以用 dfs 枚举每个加油站到底停不停。

## 确定状态

   这是一道二进制枚举 dfs 的题，因此必然有一个 `step` 来记录你准备看第几个加油站加不加油；其次，你需要记录一个答案，因为你在确定好每个加油站加不加油之后再来计算又麻烦又费时间；再者，你还需要看你目前有多少油，这会影响你的答案。

## 转移

   1. 被动加油

      题目中确定了如果目前油箱里的油不支持你跑到下一个加油站或者目的地，那么必须加油，不管你油箱里的油有没有超过容量的一半。

   2. 主动加油

      如果以目前油箱里的油支持你走到下一个加油站或者目的地，并且油量**低于**容量的一半，那么你可以选择加油，也可以选择不加油。

   3. 不能加油

      如果以目前油箱里的油支持你走到下一个加油站或者目的地，并且油量**不低于**容量的一半，那么不加油，直接走到下一站。

## 初始状态

   1. `step`

      你准备选择要不要再第一个加油站加油，那么 `step` 就是1。

   2. 答案

      你在起点花了一些钱来加满油，所以初始时的答案就是输入第一行的第三个数。

   3. 油量

      你从起点走到第一个站，走了 $dis_1$（就是第一个加油站里起点的距离）英里，消耗了 $\frac{dis_1}{miles}$（$miles$ 代表每升汽油能走多少英里）升汽油，所以这里初始的油量就是 $cup-\frac{dis_1}{miles}$ （$cup$ 代表油箱的容量，$miles$ 的含义跟前面一样）升。

## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
double dis;
double cap,tne,gnt,ans = 1e18;int n;
double tnt[55],tol[55];
void dfs(int step,double sum,double oil)
{
	if(sum > ans)return;
	if(step > n)
	{
		ans = min(ans,sum);
		return;
	}
	if(oil*tne < tnt[step+1]-tnt[step])
	{
		dfs(step+1,sum+(cap-oil)*tol[step]/100+2,cap-(tnt[step+1]-tnt[step])/tne);
	}
	else
	{
		if(oil >= cap*0.5)
		{
			dfs(step+1,sum,oil-(tnt[step+1]-tnt[step])/tne);
		}
		else
		{
			dfs(step+1,sum,oil-(tnt[step+1]-tnt[step])/tne);
			dfs(step+1,sum+(cap-oil)*tol[step]/100+2,cap-(tnt[step+1]-tnt[step])/tne);
		}
	}
	return;
}
int main()
{
	cin >> dis;
	cin >> cap >> tne >> gnt >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> tnt[i] >> tol[i];
	}
	tnt[n+1] = dis;
	dfs(1,gnt,cap - tnt[1] / tne);
	cout << fixed << setprecision(2) << ans;
	return 0;
}
``````

---

## 作者：sccc_ (赞：0)

对于这道题，我们可以考虑 dfs 搜索加贪心。

贪心策略：
- 如果当前油量不能到达下一个加油站，我们必须需要加满油。

- 如果当前油量可以到达下一个加油站：

  - 若剩下的油小于油箱总容量的一半，我们可以选择不加油，也可以选择加油。
   
  - 若剩下的油大于油箱总容量的一半，完全不用加油，直接来到下一个加油站。

最后我们可以加一个剪枝，当现在求的答案已经大于之前的最优解了，我们结束当前方案。


```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
double dis;
double max_oil, mile, st;
int n;
int half;
double ans;

struct node
{
	double dis;
	double fare;
}a[55];

void dfs (int cur, double oil, double cost)
{
	if (cost > ans)
		return ;
	if (cur == n + 1)
	{
		ans = min (ans, cost);
		return ;
	}
	if (oil * mile >= a[cur + 1].dis - a[cur].dis)
	{
		if (oil >= half)
		{
			dfs (cur + 1, oil - (a[cur + 1].dis - a[cur].dis) / mile, cost);
		}
		else
		{
			dfs (cur + 1, oil - (a[cur + 1].dis - a[cur].dis) / mile, cost);
			dfs (cur + 1, max_oil - (a[cur + 1].dis - a[cur].dis) / mile, cost + 2 + (max_oil - oil) * a[cur].fare);
		}
	}
	else
	{
		dfs (cur + 1, max_oil - (a[cur + 1].dis - a[cur].dis) / mile, cost + 2 + (max_oil - oil) * a[cur].fare);
	}
	return ;
}

signed main()
{
	cin >> dis;
	cin >> max_oil >> mile >> st;
	cin >> n;
	half = max_oil / 2;
	ans = 1e18;
	for (int i = 1; i <= n; i ++)
	{
		cin >> a[i].dis >> a[i].fare;	
		a[i].fare /= 100;
	}
	a[n + 1] = {dis, 0.00};
	dfs (1, max_oil - a[1].dis / mile, st);
	printf("%.2lf", ans);
	return 0;
}
```

---

## 作者：yr409892525 (赞：0)

### [P2836 加油问题](https://www.luogu.com.cn/problem/P2836)
我们发现每到一个加油站。         
有两种情况：
1. 当前的油不足到下一个加油站。            
- 必须在这个加油站加油。
2. 当前的油可以到下一个加油站。 
- 加油（当前的油比一半少）           
- 不加油

所以就是选和不选，时间：$O(2^{51})$ 所以需要剪枝。         
添加最优性剪枝。       
当现在的总花费高于最小花费时。       
再往后跑一定比最小值大。         
可以直接停止。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
double m;
double L,speed,p;
int n;
struct code{
	double x,y;
}a[100];
double siz(int i,int j){
	return (a[j].x-a[i].x)/speed;
}
double mi=1e18;
void dfs(int x,double sum,double y){
  if(sum>mi) return ;
	if(x==n+1){
		mi=min(mi,sum);
		return ;
	}
	double len=siz(x,x+1);
	if(len>y){
		dfs(x+1,sum+(L-y)*a[x].y+2,L-len); 
	}else{
		dfs(x+1,sum,y-len);
		if(y<L/2){
			dfs(x+1,sum+(L-y)*a[x].y+2,L-len);
		}
	} 
	return ;
}
int main(){
	cin>>m>>L>>speed>>p>>n;
	a[n+1].x=m;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		a[i].y/=100;
	}
	dfs(0,p,L);
	printf("%.2f\n",mi);
	return 0;
}
```

---

## 作者：tkm2013 (赞：0)

### [传送门](https://www.luogu.com.cn/problem/P2836)

~~终于找到梦中水蓝了！！！~~



## 分析题目

$n\le 51$ 呀，这不妥妥的暴搜吗？那我们该如何暴搜呢？

我们来考虑三种情况:
#### 剩下的油不够跑到下一个加油站

把油加满,因为在每一个停下的加油站，驾驶员总是将油加满。如果不加油就跑步到下一个加油站了。


```cpp
if(siz>d*y){
    dfs(sum+(g-y)*yj[x]+2,x+1,g-siz/d);
}
```

#### 油箱里还有不少于最大容量一半的汽油

这时我们不能加油(题目里的第 $1$ 点)，直接跑到下一站去。


```cpp
if(y>=g/2){
		dfs(sum,x+1,y-siz/d);
}
```

#### 油箱里的油少于等于了最大容量一半的汽油

这时我们可以加油也可以不加油。


```cpp
if(y<g/2){
    dfs(sum,x+1,y-siz/d);
    dfs(sum+(g-y)*yj[x]+2,x+1,g-siz/d);
}
```

由于题目中是以美分为单位，所以在输入时需要转换单位。

最后每次加油时别忘了加上快餐和糖果的钱，和在起点站加油花的钱。

## 代码如下

```cpp
#include<bits/stdc++.h>//用完能头，不容易错
using namespace std;
const int N=55;//养成好习惯，变量放一起定义
double jl[N];
double yj[N];
double g,d;
int n;
double k;
double minn=1e18;
void dfs(double sum,int x,double y){
	if(minn<sum){//小小优化
		return;
	}
	if(x==n){//到终点了
		minn=min(minn,sum);
		return;
	}
	double siz=jl[x+1]-jl[x];
	if(siz>d*y){//不能到下一个加油站
		dfs(sum+(g-y)*yj[x]+2,x+1,g-siz/d);
	}else if(y>=g/2){//油箱里还有不少于最大容量一半的汽油
		dfs(sum,x+1,y-siz/d);
	}else{//油箱里还有不少于最大容量一半的汽油
		dfs(sum,x+1,y-siz/d);
		dfs(sum+(g-y)*yj[x]+2,x+1,g-siz/d);
	}
	return;
}
int main(){
	cin>>k>>g>>d>>yj[0]>>n;
	for(int i=1;i<=n;i++){
		cin>>jl[i]>>yj[i];
		yj[i]/=100;//单位转换
	}
	jl[++n]=k;//把重点存储下来
	dfs(yj[0],1,g-(jl[1])/d);
	printf("%.2lf",minn);//保留两位四舍五入
	return 0;
}

```


###### [双倍经验](https://www.luogu.com.cn/problem/P1180)

---

## 作者：2b2b2bbb (赞：0)

# 思路
这道题目我们可以用搜索的方法求解。那么我们就要进行分类讨论。

当剩下的油数能到达下一个加油站，我们就分两种情况讨论：

① 当剩下的油量要大于总容量的一半时，我们是不能停下来加油的，这是题目的要求。

② 否则的话，我们就有两种情况了，在这个加油站你即可停下来加油，也可以继续往后走，那么你就可以直接搜索两种情况。

这里还有一个被动条件，也就是被动触发的。就是当剩下的油数不能到达下一个加油站，就必需要加满油。否则你就到达不了终点了。

然后其实我们还可以优化一下时间。比如，你现在求出的答案，就大于了我们以前求出的答案。那么就不用找了，因为现在的情况不可能让答案更小了。
## code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
double dis;
double maxn,mile,st;
int n;
int half;
double ans = 1e18 + 5;
struct pi{
	double fare,dis;
}a[55];
void dfs(int cur,double oil,double cost){
	if(cost > ans)return ;
	if(cur == n + 1){
		ans = min(ans , cost);
		return ;
	}
	if(oil * mile >= a[cur + 1].dis - a[cur].dis){
		if(oil >= half){
			dfs(cur + 1, oil - (a[cur + 1].dis - a[cur].dis) / mile, cost);
		}else{
			dfs(cur + 1 , oil - (a[cur + 1].dis - a[cur].dis) / mile, cost);
			dfs(cur + 1 , maxn - (a[cur + 1].dis - a[cur].dis) / mile , cost + 2 + (maxn - oil) * a[cur].fare);
		}
	}else{
		dfs(cur + 1 , maxn - (a[cur + 1].dis - a[cur].dis) / mile , cost + 2 + (maxn - oil) * a[cur].fare);
	}
	return ;
}
signed main(){
	cin >> dis >> maxn >> mile >> st >>n;
	half = maxn / 2;
	for(int i = 1 ; i <= n ; i ++){
		cin >> a[i].dis >> a[i].fare;	
		a[i].fare /= 100;
	}
	n ++;
	a[n].dis = dis;
	a[n].fare = 0.0;
	dfs(1 , maxn - a[1].dis / mile , st);
	printf("%.2lf", ans);
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：0)

一道搜索+贪心的好题。

怎么进行搜索呢？

当剩下的油数能到达下一个加油站，分两种情况讨论：

1. 若剩下的油数 $\ge$ 油箱容量的一半，不能加油，直接来到下一个加油站；

2.  若剩下的油数 $<$ 油箱容量的一半，变成选或不选问题：要么不加油直接到下一个加油站，要么加满油继续往后走。

当剩下的油数不能到达下一个加油站，就加满油。

然后我们加上一个最优性剪枝：若当前答案 $\ge$ 之前求得的最小答案，直接结束状态。

为了防止 ctj，请欣赏我的超绝英文单词代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
double dis;
double capacity,mile,cost,halfoil;
int n;
double kilometre[55],costoil[55];
double answer=1e18;
void dfs(double nowoil,double nowcost,int current){
	if(nowcost>answer){
		return;
	}if(current==n+1){
		answer=min(answer,nowcost);
		return;
	}if(nowoil*mile>=kilometre[current+1]-kilometre[current]){
		if(nowoil>=halfoil){
			dfs(nowoil-(kilometre[current+1]-kilometre[current])/mile,nowcost,current+1);
		}else{
			dfs(nowoil-(kilometre[current+1]-kilometre[current])/mile,nowcost,current+1);
			dfs(capacity-(kilometre[current+1]-kilometre[current])/mile,2+nowcost+(capacity-nowoil)*costoil[current],current+1);
		}
	}else{
		dfs(capacity-(kilometre[current+1]-kilometre[current])/mile,2+nowcost+(capacity-nowoil)*costoil[current],current+1);
	}
}
int main(){
	cin>>dis>>capacity>>mile>>cost>>n;
	halfoil=capacity/2;
	for(int i=1;i<=n;i++){
		cin>>kilometre[i]>>costoil[i];
		costoil[i]/=100;
	}kilometre[n+1]=dis;
	costoil[n+1]=0.0;
	dfs(capacity-kilometre[1]/mile,cost,1);
	cout<<fixed<<setprecision(2)<<answer;
	return 0;
} 
```
双倍经验：[P1180 驾车旅游](https://www.luogu.com.cn/problem/P1180)

---

## 作者：sieve (赞：0)

# 题解：[P2836 加油问题](https://www.luogu.com.cn/problem/P2836)

## 思路

这题就是一道 DFS 加加油站贪心的题目，个人感觉实际难度黄。

我们考虑两种情况：

- 当前的油可以走到下一个点。

- 当前的油走不到下一个点。

第一种情况又可以分：

- 当前的油有一半，必须不加油。

- 当前的油没有一半，可以加油，也可以不加油。

然后，按照这几种情况直接模拟，递归即可。

要注意，因为是美分要转为美元，所以在过程中除以 $100$。还有，吃东西也要花费 $2$ 美元。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+5;
double dist,cap,travel_dist,oil_cost;
int n;
double d[N],oil[N],mn=1e18;
void dfs(double last_oil,double sum,int x)
{
	if(sum>mn) return;
	if(x>n)
	{
		mn=min(mn,sum);
		return;
	}
	double need=(d[x+1]-d[x])/travel_dist;
	if(last_oil*travel_dist>=d[x+1]-d[x])
	{
		if(last_oil>=cap/2)
		{
			dfs(last_oil-need,sum,x+1);
		}
		else
		{
			dfs(last_oil-need,sum,x+1);
			dfs(cap-need,sum+2+(cap-last_oil)*oil[x]/100.0,x+1);
		}
	}
	else
	{
		dfs(cap-need,sum+2+(cap-last_oil)*oil[x]/100.0,x+1);
	}
	return;
}
signed main()
{
	cin>>dist>>cap>>travel_dist>>oil_cost>>n;
	for(int i=1;i<=n;++i) cin>>d[i]>>oil[i];
	d[n+1]=dist; 
	dfs(cap-d[1]/travel_dist,oil_cost,1);
	printf("%.2f",mn);
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P2836)

看到数据范围这么小，直接考虑搜索。

### 思路

使用搜索加上剪枝，使用选与不选搜索，判断是否在这个点加油。

### 注意点

油箱内的油的余量大于等于一半时，不能主动停下来，所以我们在大于等于一半时就不能选择加油，但是如果小于一半，那么我们就可以加油也可以不加油，但是如果走不到下一个点，这个时候就必须加油。

并且一开始的时候油箱也需要加油。

### 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 1;
double k, c, d, l;
int n;
double a[N], oil[N], minn = 1e18;
void dfs(int cur,double il, double cnt){
	if (cnt > minn) return ; // 最优性剪枝。
	if (cur > n){
		minn = min(minn, cnt);
		return ;
	}
	if (il * d >= a[cur + 1] - a[cur]){ // 如果能走到下一个点。
		if (il >= c / 2.0){ // 不能加油
			dfs (cur + 1, il - (a[cur + 1] - a[cur]) / d, cnt);
		}else { // 可以加也可以不加
			dfs (cur + 1, il - (a[cur + 1] - a[cur]) / d, cnt);
			dfs (cur + 1, c - (a[cur + 1] - a[cur]) / d, cnt + 2 + (c - il) * oil[cur]);
		}
	}else{ // 必须加油，走不到下一个点
		dfs (cur + 1, c - (a[cur + 1] - a[cur]) / d, cnt + 2 + (c - il) * oil[cur]);
	}
}
signed main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> k >> c >> d >> l >> n;
	for (int i = 1;i <= n;i ++){
		cin >> a[i] >> oil[i];
		oil[i] /= 100; // 注意分要变成元需要除以100
	}
	a[n + 1] = k;
	dfs (1, c - a[1] * 1.0 /d, l); // 搜索
	printf ("%.2lf", minn); // 注意保留两位小数
	return 0;
}

```

---

## 作者：Genius_Star (赞：0)

### 思路：

这里定义 $A$ 为油箱大小，$B$ 为每千米速度。

发现数据范围很小，考虑深度优先搜索算法。

传参为 $pos,sum,t$，分别表示当前在第 $pos$ 个加油站，当前花费的总价钱，当前剩余的油量。

首先 $d_{pos}-d_{pos-1}$ 表示从上一个加油站到当前加油站的距离，那么 $h=\frac{d_{pos}-d_{pos-1}}{B}$ 表示需要消耗的油量，若 $t < h$，那么无法到达，则退出；否则将当前油量减去消耗的油量。

之后只有当前汽油 $t \le \frac{A}{2}$ 时，可以进行加油，此时将 $t$ 更新为 $A$，将 $sum$ 更新为 $sum+2+\frac{w_{pos} \times (A-t)}{100}$。

因为过程中有剪枝，负责度玄学，但是跑的还挺快的。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=55;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n;
db m,ans=1e9;
db A,B,C;
db a[N],b[N];
void dfs(ll pos,db sum,db t){
	t-=(a[pos]-a[pos-1])/B;
	if(t<0)
	  return ;
	if(pos==n+2){
		ans=min(ans,sum);
		return ;
	}
	if(t<=A/2)
	  dfs(pos+1,sum+2.00+(b[pos]*(A-t)/100.0),A);
	dfs(pos+1,sum,t);
}
int main(){
	scanf("%lf",&m);
	scanf("%lf%lf%lf%lld",&A,&B,&C,&n);
	for(int i=1;i<=n;i++)
	  scanf("%lf%lf",&a[i],&b[i]);
	a[n+1]=m,b[n+1]=0;
	dfs(1,C,A); 
	printf("%.2lf\n",ans);
	return 0;
}
```

---


# 序列变换

## 题目描述

给定一个长度为 $n$ 的数列 $A_i$。

你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。

求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。


## 说明/提示

对于 $30 \%$ 的数据，满足 $1 \le n \le 10$。

对于 $60 \%$ 的数据，满足 $1 \le n \le 1000$。

对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le A_i \le {10}^6$。


## 样例 #1

### 输入

```
5
6 3 7 8 6
```

### 输出

```
2
```

# 题解

## 作者：MspAInt (赞：19)

[P3411](https://www.luogu.com.cn/problem/P3411)

主打的就是一个正难则反！

问最少的操作次数，其实就是最多的不操作次数。这样说可能有点怪，来个结论：

每个数至多操作一次（自证不难）。

所以本题等价于求最多几个数可以原地不动。显然，原地不动的数在最后序列变成有序的时候必然都是有序的，我们要做的是在原序列中提取一个有序的最长子序列。

好像是……板子？

戳啦，这个序列还有一个性质必须满足：是目标序列的子串。假设我们已经求出了这个合法的子序列，那么子序列的空隙里（不会有人不知道子序列可以是断断续续的吧）就是不能加入到子序列里做贡献的数，它们得被移开。而移开后，这个子序列就会凑到一起，变成目标序列的子串。

而这个子串有什么特点？那就是它们并非单纯的大于小于关系，而是对于一对相邻的数 $a_{i-1},a_i$（$a_{i-1}<a_i$），无法找到一个使得 $a_i>a_j>a_{i-1}$ 的 $j$（这个就是很显然的排序的性质）。

于是我们可以开一个桶套 `vector` 存储对应值的下标，从小到大加入队列，过程中判断即可。

得到了最多的不操作次数，再结合上面的结论，答案显而易见。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,a[N],l=1,r=1,ans,res,Max;
vector<int>v[N];
deque<int>d;
signed main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),v[a[i]].push_back(i),Max=max(Max,a[i]);
    for(int i=1;i<=Max;i++){
        for(int j=v[i].size()-1;j>=0;j--){
            int now=v[i][j];
            while(d.size()&&d.front()>now){//最大值在次大值前面
                while(d.size()&&a[d.back()]<a[d.front()])d.pop_back();//前面也失效了
                d.pop_front();
            }
            ans=max(ans,(int)d.size()+(int)v[i].size()-j);//目前合法序列长度
        }
        for(int j=0;j<v[i].size();j++)d.push_front(v[i][j]);
    }
    printf("%d\n",n-ans);
    // system("pause");
    return 0;
}
```

[record](https://www.luogu.com.cn/record/113794313)

---

## 作者：在想Peach (赞：9)

首先无论如何我们可以暴力以我也不知道多少次移动将队列搞成单调不下降的样子，也就是说你可以在队首或队尾安排一个单调不下降队列以这个队列的长度次数完成，那么为了不做多于功，就要先保证你安排了队首和队尾的单调不下降队列后没有变的也不用再变也满足了

### 也就是说要找  最长无缝子队列 ——沃兹基硕德

无缝子队列就是在排序之后

没有除了这个子队列里的数以外的数留在这个拼合后队列中的子队列

就是说没有别的数妨碍这个子队列的合体

那么显然 总数-最长无缝子序列 就是最优解

那么我们这里要用二分查找（懒人可SLT）+贪心来找这么个小东西，比如样例：

6 3 7 8 6
处理为

3 最左：2  最右：2  总数：1

6 最左：1  最右：5  总数：2

7 最左：3  最右：3  总数：1

8 最左：4  最右：4  总数：1

首先我们想办法合并，对于两个数字来说，当较小数的最右小于较大数的最左时，这两个数可以合并当作一个数来处理。

不能的话也要榨干旁边数的价值，因为对于同一个数的最后状态，一开始的分布是没有要求的，所以用二分查找前后数可以利用的前一段或后一段数加入答案，当然对于可以合并的就没有必要贪心了，~~都是一家人了~~

上代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
int n,c[1000005],ans[1000005],m,ansl;
vector<int>a[1000005];
int cun[1000005],tot;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];a[c[i]].push_back(i);m=max(m,c[i]);
	}
	for(int i=1;i<=m;i++)
	{
		if(a[i].size()!=0)cun[++tot]=i;
	}
	for(int i=1;i<=tot;i++)
	{
		int now=cun[i],last=cun[i-1],nxt=cun[i+1];
		ans[i]=a[now].size();
		if(i!=1)
		{
			if(a[now].front()>a[last].back())ans[i]+=ans[i-1];
			else 
			{
				int aa=lower_bound(a[last].begin(),a[last].end(),a[now].front())-a[last].begin();
				ans[i]+=aa;
			}
		}
		if(i!=tot)
		{
			if(a[now].back()>a[nxt].front())
			{
			    int aa=lower_bound(a[nxt].begin(),a[nxt].end(),a[now].back())-a[nxt].begin();
			    ans[i]+=(a[nxt].size()-aa);
		    }
		}
		ansl=max(ansl,ans[i]);
	}
	cout<<n-ansl<<endl;
	return 0;
}
```


---

## 作者：荣一鸣 (赞：8)

在这道题里，我们可以将该序列中的任何一个数放到后面或前面，而我们要这个操作次数最少，那么我们就要使保持不动的点最多，而如果任意两个点（数）不动，**那么就不能将任何原本不在该两个数中间的数插入这两个数中间**。

因此，我们就要求出一个连续的最长子序列。

何为连续？

就是说该序列必须是最后的结果序列的**子串**

即，如果该数的前一个不同的数（pre）和后一个不同的数（next）都在之中，那么这个数必须全部都在pre和next中间。

所以我们可以一个数一个数考虑，并将可以存在的数放在单调队列中

条件1：该队列中的数在保证不减的同时保证原序号递增

条件2：同时如果该序列中将要放入b这个数，而a小于b，若大小等于a的数并没有全部在队列里，那么小于a的数都不能在队列里

代码中的注释应该可以有助理解

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000010],ans;
deque<int> q;//双端队列模拟单调队列
vector<int> b[1000010];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[a[i]].push_back(i);//将同一个大小的数的id记录下来
        //（因为从前向后读入所以保持单调）
        m=max(m,a[i]);//最大的数是多少
    }
    for(int i=1;i<=m;i++){//从小到大将数加入单调队列
        int lt=b[i].size();
        for(int j=lt-1;j>=0;j--){
            int k=b[i][j];//拿出大小为i，id在i中大小为第j大及以后的数中最靠前的数的id
            //只要该数能放入队列中，序号比该数大，大小与它相同的都能放入
            while(!q.empty()&&q.back()>k){//把队列处理成能将k放入的状态
                while(q.size()>=1&&a[q.front()]<a[q.back()]) q.pop_front();
                //这个while保证条件二
                q.pop_back();
                //因为条件一，所以序号越大的数越在队列的后面
            }
            int lm=q.size();
            ans=max(ans,lm+lt-j);//更新答案
        }
        for(int j=0;j<lt;j++) q.push_back(b[i][j]);//将该数加入队列
    }
    printf("%d",n-ans);//答案是总长减去最长序列的长度
}
```

注意，队列的长度（即q.size()与int不是同一类型的变量，不能放max里比）~~（别问我为什么，我也不知道）~~

还有，STL的deque比手动模拟要慢，但加O2优化会比手动模拟要快

---

## 作者：凑个热闹吖 (赞：7)

貌似所有用纯 DP 做的题解都被 hack 掉了。

剩下的题解都是用贪心或者单调队列做的。

其实通过分类讨论还是可以用单纯的 DP 过掉这道题的。

我这种解法也暂时拿下了洛谷的最优解。

# solution

容易发现，我们需要找出一个**最长的不下降子序列**，并且这个子序列必须是原序列**从小到大**排序后的**子串**。

因为如果我们钦定两个元素不移动的话，那大小在这两个元素之间，但位置不在这两个元素之间的元素，我们无论如何移动都无法将其移动至这两个元素之间。

即我们选择的子序列中的每一个元素，它的前一个元素只有两种可能：大小**等于**它，或者大小**小于且最接近**它(下面称为**次小于**)。

我们可以先对原序列**从小到大**排序，预处理出每个元素**次小于**它的元素，记元素 $i$ **次小于**它的元素为 $las[i]$。

依次枚举每一个元素，由于每一个元素可以接在等于或者次小于它的元素后面，可以得到转移方程：

$$f[a[i]] = max(f[a[i]] + 1 , f[las[a[i]]] + 1)$$

但这是正确的吗？

举个例子：```6 2 6 6 7 8 9```，按照上面的方法得出的子序列为 ```2 6 6 7 8 9```，但是我们可以发现对于最前面的那个 ```6```，我们无论如何移动都无法将其移动至合法的位置。

那是不是说如果一个元素要接在次小于它的元素后面，必要条件是子序列已经包含所有次小于它的元素呢？

也不一定。

再举个例子：```2 2 6 6 8 2```，肉眼可见合法的最大不下降子序列为 ```2 2 6 6 8```，只需将最后的那个元素移到最前面即可。

也就是说，若当前元素的次小于它的元素是选取子序列中最小的元素，就可以直接接上，否则就要选择**所有**次小于它的元素才能接上。

按照这个思路进行分类讨论即可。

## [code](https://www.luogu.com.cn/paste/nkobfh0o)

---

## 作者：楠山 (赞：6)

考察：动态规划，单调队列

经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：

子序列单调递增；

若子序列中最小数是L，最大数是R，则子序列必须包含[L+1,R-1]中的数列中的所有数。

用单调队列求出满足这两个条件的子序列的最大长度，用n减去就是答案。

即这个子序列保持不动，其余数向前或后移动一次。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<map>
#include<iomanip>
#include<queue>
#include<set>
using namespace std;
const int SIZE = 1000010;
int a[SIZE], q[SIZE];
int n, m, ans;
vector<int> b[SIZE];
int main()
{
//    freopen("change.in","r",stdin);
//    freopen("change.out","w",stdout);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        b[a[i]].push_back(i);
        m = max(m, a[i]);
    }
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++)
    {
        reverse(b[i].begin(), b[i].end());
        for (int j = 0; j < b[i].size(); j++)
        {
            int k = b[i][j];
            while (l <= r && q[r] > k)
            {
                while (l < r && a[q[l]] < a[q[r]]) l++;
                r--;
            }
            ans = max(ans, r - l + 2 + j);
        }
        for (int j = b[i].size() - 1; j >= 0; j--)
        {
            q[++r] = b[i][j];
        }
        //cout << ans << endl;
    }
    cout << n - ans << endl;
}

```

---

## 作者：FLY_lai (赞：3)

自己做不出来，看现在题解区的题解讲的都不咋清楚。懂了之后来为后人铺路。~~而且我的马蜂比较好看~~

[题目传送门](https://www.luogu.com.cn/problem/P3411)

我能看懂这道题，主要是依靠了[这篇题解](https://www.luogu.com.cn/blog/ShaoJia/solution-p3411)的帮助。

首先我们只关注数的相对关系，所以可以离散化。注意到值域 $10^6$，用数组离散化。

这道题可以用**贪心**做。（有一些定义先往下看）

定义一个无缝子序列：一个子序列中最小值为 $mn$，最大值为 $mx$，且原数组中所有值在 $[mn,mx]$ 中的数全部在子序列中，再并且这个子序列单调不减，称这个子序列是 “无缝的”。

例如原序列离散化后是 `1 4 4 2 3 7 5 4 5 6`，那么子序列 `5 5 6` 是无缝的；子序列 `4 4 4 6` 不是无缝的，因为 $5$ 没有包含在子序列中；子序列 `4 4 5 4 5 6` 也不是无缝的，因为不单调不减。

再定义一个无缝子序列的拓展长度：假设一个无缝子序列的最小值为 $mn$，最大值为 $mx$，长度为 $len$。第一个 $mn$ 左边有 $cnt1$ 个 $mn-1$。最后一个 $mx$ 右边有 $cnt2$ 个 $mx+1$。称这个无缝子序列的拓展长度为 $len+cnt1+cnt2$。

现在抛出贪心的结论：答案就是 $n-x$，$x$ 是最大的 “无缝子序列拓展长度”。注意这里表示的**不是** “最长的无缝子序列” 的拓展长度。

为什么呢？首先我们证明存在一组解，可以构造出 $n-x$ 次操作。

假设无缝子序列 $\{num\}$ 使得它的拓展长度为 $x$。

那就可以固定 $\{num\}$ 中所有数和所有计算拓展长度时统计到的 $mn-1$ 和 $mx+1$。这些数不进行操作。

剩下所有数，分成两拨：小于 $mn$ 的和大于 $mx$ 的。

将小于 $mn$ 的数从大到小排序，依次将每个数放在开头；将大于 $mx$ 的数从小到大排序，依次将每个数放在结尾。

这样每个没固定的数都使用了一次操作，共 $n-x$ 次操作使得整个序列排好了序。

下面证明不存在比 $n-x$ 还小的解。假设更小的解是 $k$。

那么说明至少有 $n-k$ 个数没有进行操作。这些没进行操作的数一定形成一个 “无缝子序列拓展” 的形式。因为假如它中间有数没有出现，一定需要将外界的数移到中间来，这需要移动这 $n-k$ 个数；假如它不是单调不减，需要重新排序，也需要移动这些数。

综上所述，最终的答案就是 $n-x$。

那具体怎么求呢？对每个位置求出 $nxt$ 和 $pre$ 表示后一个/前一个和它相等的数的所在位置。再对每一种数值求出 $l,r$ 表示这种数值最左边的数和最右边的数的位置。还有每种数值的出现次数 $cnt$。

一个无缝子序列的充要条件是：对于任意 $x<y$ 且 $x,y$ 属于无缝子序列，$r_x<l_y$。

发现如果 $r_x<l_y,r_y<l_z$ 则 $r_x<l_z$。
那么可以从小到大遍历每种数值，如果当前数值不能再扩张了，就把之前记录下的所有数值共同构成一个无缝子序列，计算其拓展长度并更新最大值。

注意最后输出 $n$ 减去这个最大值。

~~最后看在题解写的这么详细的份上，给个关注呗~~

喜闻乐见的代码：

```
#include <bits/stdc++.h>

using namespace std;

int n;
int a[1000005];
int b[1000005];

int l[1000005], r[1000005];
int cnt[1000005] = {};
int pos[1000005] = {}, pre[1000005], nxt[1000005] = {};

int cal(int mn, int mx) { //计算最小值为mn最大值为mx 的无缝子序列拓展长度 
	int res = 0;
	for (int i = mn; i <= mx; i++) //先加上子序列内的数个数 
		res += cnt[i];
	for (int i = l[mn - 1]; i && i < l[mn]; i = nxt[i]) //在mn左边的mn-1个数 
		res++;
	for (int i = r[mx + 1]; i > r[mx]; i = pre[i]) //在mx右边的mx+1个数 
		res++;
	return res;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		b[a[i]] = 1;
	}
	for (int i = 1; i <= 1000000; i++)
		b[i] += b[i - 1];
	for (int i = 1; i <= n; i++)
		a[i] = b[a[i]]; //离散化 
	
	for (int i = 1; i <= n; i++)
		if (l[a[i]] == 0)
			l[a[i]] = i;
	for (int i = n; i >= 1; i--)
		if (r[a[i]] == 0)
			r[a[i]] = i;
	
	for (int i = 1; i <= n; i++) {
		pre[i] = pos[a[i]];
		pos[a[i]] = i;
	}
	memset(pos, 0, sizeof pos);
	for (int i = n; i >= 1; i--) {
		nxt[i] = pos[a[i]];
		pos[a[i]] = i;
	} //求辅助数组们 
		
	int UL = 0;
	for (int i = 1; i <= n; i++) {
		UL = max(UL, a[i]); //求最大值好遍历 
		cnt[a[i]]++;
	}
	
	int lst = 1;
	int ans = 0;
	for (int i = 2; i <= UL + 1; i++)
		if (r[i - 1] > l[i] || i == UL + 1) {
			ans = max(ans, cal(lst, i - 1));
			lst = i;
		}
	printf("%d", n - ans);
	return 0;
}
```

---

## 作者：I_am_Accepted (赞：3)

[给出几组 Hack 数据](https://www.luogu.com.cn/paste/q1m794w3)

这里是 $O(n)$ 正解。

首先，题目等价于要求出最长的子序列，使得：

* 子序列单调非降。

* 若子序列中最小 / 大值为 $lv,rv$，则值属于 $[lv+1,rv-1]$ 的元素均在此子序列里。

我们设 $a_1,\dots,a_n$ 为原序列，定义 $L_x,R_x$ 表示值为 $x$ 的元素下标的最小 / 大值。

所以我们要满足 $\forall v\in[lv+2,rv-1],R_{v-1}<L_v$。

我们把满足上述条件的连续值域区间称为「值域段」。我们分别考虑每一个值域段，设当前值域为 $[lx,rx]$。

由于我们想让子序列最长，所以贪心地将 $[lx,rx]$ 值域内的元素全选，然后我们再选进 下标 $<L_{lx}$ 值为 $lx-1$ 的元素 和 下标 $>R_{rx}$ 值为 $rx+1$ 的元素。

最后每一个值域段取最大值即可。

[AC 记录](https://www.luogu.com.cn/record/79130016)

```cpp
//We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define Rof(i,j,k) for(int i=(j),i##_=(k);i>=i##_;i--)
#define ckmx(a,b) a=max(a,b)
#define ckmn(a,b) a=min(a,b)
#define N 1000005
int L[N],R[N],a[N],lim,ans=0,st,s[N],n,b[N],nxt[N],cnt[N];
int work(int lv,int rv){
	int res=0;
	For(i,lv,rv) res+=cnt[i];
	for(int i=L[lv-1];i;i=nxt[i]) res+=(i<L[lv]);
	for(int i=L[rv+1];i;i=nxt[i]) res+=(i>R[rv]);
	return res;
}
int calc(int x){
	st=0;
	for(int i=L[x],j=L[x+1];i||j;)
		if(!j||(i&&i<j)) s[++st]=0,i=nxt[i];
		else s[++st]=1,j=nxt[j];
	For(i,1,st) s[i]+=s[i-1];
	int res=0,sz=cnt[x+1];
	For(i,0,st) ckmx(res,i+sz-2*s[i]);
	return res;
}
int main(){
	scanf("%d",&n);
	For(i,1,n) scanf("%d",a+i);
	For(i,1,n) b[a[i]]=1;
	For(i,1,N-1) b[i]+=b[i-1];
	For(i,1,n) a[i]=b[a[i]];
	fill(L+1,L+1+(lim=b[N-1]),n+1);
	fill(b+1,b+1+lim,0);
	Rof(i,n,1) ckmx(R[a[i]],i),ckmn(L[a[i]],i),nxt[i]=b[a[i]],b[a[i]]=i,cnt[a[i]]++;
	For(i,1,lim) ckmx(ans,cnt[i]);
	For(i,1,lim-1) ckmx(ans,calc(i));
	int lst=1;
	For(i,2,lim+1) if(R[i-1]>L[i] || i==lim+1) ckmx(ans,work(lst,i-1)),lst=i;
	printf("%d\n",n-ans);
return 0;}
```

---

## 作者：enderrainy (赞：3)

求出最长的a[l]<a[r]&&所有a[l]<=a[k]<=a[r]都有l<=k<=r

答案为n-上面所求；//虽然我也不知道为什么等于

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<vector>
using namespace std;
int n,m,ans,l,r;
int a[1000001],q[1000001];
vector<int> b[1000001];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      {scanf("%d",&a[i]);
       b[a[i]].push_back(i);
       m=max(m,a[i]);}
    l=1;r=0;
    for(int i=1;i<=m;i++)
      {reverse(b[i].begin(), b[i].end());
       for(int j=0;j<b[i].size();j++)
         {int k=b[i][j];
          while(l<=r&&q[r]>k)
            {while(l<r&&a[q[l]]<a[q[r]]) l++;
             r--;}
          ans=max(ans,r-l+2+j);}
       for(int j=b[i].size()-1;j>=0;j--)
         q[++r]=b[i][j];}
    printf("%d",n-ans);
return 0;}
```

---


# [POI 2015] LAS

## 题目描述

圆桌上摆放着 $n$ 份食物，围成一圈，第 $i$ 份食物所含热量为 $c_i$。相邻两份食物之间坐着一个人，共有 $n$ 个人。每个人有两种选择，吃自己左边或者右边的食物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假如某个人改变自己的选择后（其他 $n-1$ 个人的选择不变），可以使自己获得比原先更多的热量，那么这个人会不满意。请你给每个人指定应该吃哪一份食物，使得所有人都能够满意。

## 说明/提示

**【数据范围】**

对于所有数据，$2\leqslant n\leqslant 10^6$，$1\leqslant c_i\leqslant 10^9$。

----

原题名称：Łasuchy

感谢 @KSkun 为本题提供 SPJ。

## 样例 #1

### 输入

```
5
5 3 7 2 9
```

### 输出

```
2 3 3 5 1
```

# 题解

## 作者：wmrqwq (赞：8)

# 原题链接

[P3584 [POI2015] LAS](https://www.luogu.com.cn/problem/P3584)

# 题目简述

有 $n$ 个人围成一圈，每个人的左边和右边都有一个食物，每个食物都有不同的热量，每个人可以吃掉他左边或者右边的食物，假如有 $2$ 个人同时选择了一个食物，那么两个人会同时吃掉这个食物并平分这个食物的热量，否则自己一个人独自吃掉这个食物，现在需要每一个人吃到的热量是位于自己左边食物的热量和右边食物的热量的最大值，你需要给出每个人吃食物的方案。若无解，则输出 `NIE`。

# 解题思路

这道题是一道 dp 题，下面我就来详细的讲解一下。

因为每个食物是一定只有 $4$ 种状态的，分别是被左边的人吃掉，被右边的人吃掉，被左边的人和右边的人同时吃掉，没被人吃掉。

对于每一个状态，我们只需要根据题意模拟即可，这里别的题解已经详细讲过了，在此不再赘述。

那么现在就有一个问题：应该怎么开始 dp 呢？实际上，只需要想一下就会发现，每个人的状态一共就只有四种，所以，我们只需要将第一个人的四个状态都枚举一遍，然后进行 dp 即可。

这个时候为什么这么枚举一定是正确的呢？因为假如中间有人无法做选择时，后面的人也会无法做出选择了，因此这么判断一定是正确的。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define QwQ return 0;
int n,dp[1000010][5],a[1000010],ans[1000010];
bool pd(int x) 
{
	for(int i=1;i<=1000000;i++)
		dp[i][0]=0,dp[i][1]=0,dp[i][2]=0,dp[i][3]=0,dp[i][4]=0;//将每一个状态初始化
	dp[1][x]=1;
	for(int i=2;i<=n+1;i++) 
	{//判断状态，更新状态
		if(dp[i-1][1] && a[i-1]<=a[i]*2) 
			dp[i][1]=1;
		if(dp[i-1][1] && a[i-1]<=a[i]) 
			dp[i][3]=1;
		if(dp[i-1][2] && a[i]<=a[i-1]*2) 
			dp[i][2]=2;
		if(dp[i-1][2] && a[i]<=a[i-1]) 
			dp[i][4]=2;
		if(dp[i-1][3] && a[i]<=a[i-1]) 
			dp[i][2]=3;
		if(dp[i-1][3] && a[i]*2<=a[i-1]) 
			dp[i][4]=3;
		if(dp[i-1][4] && a[i-1]<=a[i]) 
			dp[i][1]=4;
		if(dp[i-1][4] && a[i-1]*2<=a[i]) 
			dp[i][3]=4;
	}
	return dp[n+1][x];//判断最后一项，如果无解就返回0
}
int main() 
{
	cin>>n;
	for(int i=1;i<=n;i++) 
		cin>>a[i];
	a[n+1]=a[1];
	for(int i=1;i<=4;i++) 
	{
		if(pd(i)) //如果有解
		{
			int m=i;
			for(int j=n+1;j>=1;j--) 
			{
				if(m==1) 
					ans[j-1]=(j-1)%n+1;
				if(m==2) 
					ans[j]=(j-1)%n+1;
				if(m==3) 
					ans[j-1]=ans[j]=(j-1)%n+1;
				m=dp[j][m];//根据 dp 状态更新答案
			}
			for(int i=1;i<=n;i++) 
				cout<<ans[i]<<" ";//输出答案
			QwQ;
		}
	}
	cout<<"NIE";//若无解，则输出 NIE
	QwQ;
}
```

---

## 作者：bits。 (赞：8)

[在博客阅读感受更佳](https://www.cnblogs.com/newbiezqy/p/14983809.html)

提供一个新颖的做法 先%一发 Itst

首先，把它看做一个环，点是食物，边是人。我们要把每条边定向。

环的细节自己判一下。对于 $ a_i > 2 \times a_{i+1} $ 或 $ a_i > 2 \times a_{i-1} $ 的人肯定直接选 $ i $ 食物。

如果整个环中没有这种情况，就直接朝一个方向选，很显然这样做是对的。

否则，对于每个一个已选的食物，我们直接让 $ a_i \leftarrow {a_i \over 2} $ 并把这个人删掉。很显然，这样删完之后，环形成了若干条链。对于每条链，都有这样一条性质： $ a_i \in [{a_{j} \over 2},a_j \times 2 ] ( j=i-1/i+1) $ 。因此，我们可以直接把链上的点权最小值抠出来，并以它为分界点，左边的选左边的食物，右边的选右边的食物。这样可以保证方案是对的。

还有一些细节看代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read(){
	int f=1,r=0;char c=getchar();
	while(!isdigit(c))f^=c=='-',c=getchar();
	while(isdigit(c))r=(r<<1)+(r<<3)+(c&15),c=getchar();
	return f?r:-r;
}
const int N=1e6+7;
int n,ans[N<<1];
ll a[N<<1];
int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read()<<1;
	bool flg=1;
	for(int i=1;i<=n;i++){
		int j=i%n+1;
		if(a[i]>2*a[j])ans[i]=i,a[i]>>=1,flg=0;
		else if(a[i]*2<a[j])ans[i]=j,a[j]>>=1,flg=0;
	}
	for(int i=n;i;i--){
		if(ans[i])continue;int j=i%n+1;
		if(a[i]>2*a[j])ans[i]=i,a[i]>>=1,flg=0;
		else if(a[i]*2<a[j])ans[i]=j,a[j]>>=1,flg=0;
	}//可能有这样一种情况：7 4 1。这样有可能4除完后，7又要除，因而发生类似一种链式反应。我们可以通过正反都扫一遍来解决这一问题、
	if(flg){for(int i=1;i<=n;i++)printf("%d ",i);exit(0);}
	for(int i=1;i<=n;i++)a[i+n]=a[i];
	int Pos=0;
	for(int i=1;i<=n;i++)if(ans[i]){Pos=i;break;}
	for(int i=Pos;i<n+Pos;i++){
		if(ans[(i-1)%n+1])continue;
		int j=i;while(!ans[j%n+1] && j<n+Pos-1)j++;
		int pos=i;
		for(int k=i+1;k<=j+1;k++)
			if(a[pos]>a[k])pos=k;
		for(int k=i;k<pos;k++)ans[(k-1)%n+1]=(k-1)%n+1;
		for(int k=pos;k<=j;k++)ans[(k-1)%n+1]=k%n+1;
		i=j;
	}
	for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	return 0;
}

```


---

## 作者：nofind (赞：8)

题意:https://www.luogu.org/problem/P3584

考虑对每个人设状态,发现转移相当复杂,不妨对食物设状态

$f[i][0/1/2/3]$表示食物没被选/被左边的人吃/被右边的人吃/被两边的人吃这个状态的决策点(这是为了输出方案)

转移时讨论$a[i]$和$a[i-1]$的大小关系

$f[i][0]=min(2(a[i-1]>=a[i]),3(a[i-1]/2>=a[i]))$

讨论第$i$个不选,那么第$i$个左边的人必定选第$i-1$个,讨论第$i-1$个是一个人还是两个人吃,贪心地优先选一个人吃

$f[i][1]=min(0(a[i-1]<=a[i]),1(a[i-1]/2<=a[i]))$

既然第$i$个左边的人打算吃,那么必定满足吃$i-1$不会更优,讨论第$i-1$个的状态,即$i-1$左边的那个人是否选择它

以下同理,直接给出,不做解释

好吧还是解释一下吧~~立完就拔的flag~~

$f[i][2]=min(2(a[i]/2<=a[i-1]),3(a[i]/2<=a[i-1]/2))$

既然第$i$个左边的人不打算和第$i$个右边的人共享(~~小气鬼~~),而选了第$i-1$个,那么必定有原因,讨论第$i-1$个的状态

$f[i][3]=min(0(a[i-1]<=a[i]/2),1(a[i-1]/2<=a[i]/2))$

既然第$i$个左边的人放着第$i-1$个不吃,却蹭第$i$个,必定有原因,讨论$i-1$个的状态

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000010;
int n;
int a[maxn],ans[maxn];
int f[maxn][4];
bool flag;
inline void move(int pre,int now)
{
	if(~f[pre][2]&&a[pre]>=a[now])f[now][0]=2;
	else if(~f[pre][3]&&a[pre]>=a[now]*2)f[now][0]=3;
	if(~f[pre][0]&&a[pre]<=a[now])f[now][1]=0;
	else if(~f[pre][1]&&a[pre]<=a[now]*2)f[now][1]=1;
	if(~f[pre][2]&&a[pre]*2>=a[now])f[now][2]=2;
	else if(~f[pre][3]&&a[pre]>=a[now])f[now][2]=3;
	if(~f[pre][0]&&a[pre]*2<=a[now])f[now][3]=0;
	else if(~f[pre][1]&&a[pre]<=a[now])f[now][3]=1;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int s=0;s<4;s++)
	{
		memset(f,-1,sizeof(f));
		f[1][s]=4;
		for(int i=2;i<=n;i++)move(i-1,i);
		move(n,1);
		if(f[1][s]<4)
		{
			int k=f[1][s];
			for(int i=n;i;i--)
			{
				if(k==1||k==3)ans[(i-2+n)%n+1]=i;
				if(k==2||k==3)ans[i]=i;
				k=f[i][k];
			}
			for(int i=1;i<=n;i++)printf("%d ",ans[i]);
			flag=1;break;
		}
	}	
	if(!flag)puts("NIE");
	return 0;	
}
```


---

## 作者：zac2010 (赞：5)

注：为了方便叙述，在下文中，我们用 $\text{next}(i)$ 表示第 $i$ 个人右边的食物，$\text{pre}(i)$ 表示第 $i$ 个人左边的食物。

看到题目时一个直观的想法：对于所有 $c_{\text{pre}(i)}\geq c_{\text{next(i)}}\times 2$ 或者 $c_{\text{next}(i)}\geq c_{\text{pre}(i)}\times 2$ 的人，他必定是取左右两边较大的食物的。

考虑把确定上述那些人的选择。具体的，我们把这些人选择的食物热量给去掉一半。之后，可能会出现新的满足条件的人。故而我们采用一个广搜的思想，把新的人也给加入一个队列进行拓展。

最后我们还会剩下一个环，其中环上任意节点满足：要不是他已经选择过食物了，就是他左右两边的食物不满足上述条件。直接对每个位置进行贪心取就行了：$c_{\text{pre}(i)}$ 和 $c_{\text{next}(i)}$ 哪个大取哪个。贪心正确性显然。

为了防止出现浮点数，我在代码中把每个 $c_i$ 都乘上了 $2$。易发现这样不影响答案。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e6 + 10;
int n, a[N], b[N], ans[N];
queue<pair<int, int> > q;
int pre(int i){return (i - 1 + n) % n;}
int nxt(int i){return (i + 1) % n;}
void psh(int i){
	if(!~ans[i] && b[i] >= b[nxt(i)] * 2ll){
		q.emplace(i, i);
		b[ans[i] = i] -= a[i];
	}
	if(!~ans[i] && b[nxt(i)] >= b[i] * 2ll){
		q.emplace(i, nxt(i)), b[ans[i] = nxt(i)] -= a[nxt(i)];
	}
}
int main(){
	scanf("%d", &n);
	fill(ans, ans + n, -1);
	FL(i, 0, n - 1){
		scanf("%d", &a[i]);
		b[i] = a[i] << 1;
	}
	FL(i, 0, n - 1) psh(i);
	while(!q.empty()){
		auto u = q.front(); q.pop();
		psh(pre(u.second)), psh(u.second);
	}
	FL(i, 0, n - 1){
		if(~ans[i]) printf("%d ", ans[i] + 1);
		else{
			if(b[i] > b[nxt(i)])
				printf("%d ", i + 1), b[i] -= a[i];
			else printf("%d ", nxt(i) + 1), b[nxt(i)] -= a[nxt(i)];
		}
	}
	return 0;
}
```


---

## 作者：Alex_Wei (赞：4)

> [P3584 [POI2015]LAS](https://www.luogu.com.cn/problem/P3584)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

第一个想法是若出现相邻的两个食物 $(x,y)$ 满足 $2a_x<a_y$ 或 $2a_y<a_x$，说明能够选择食物 $x,y$ 的人一定会选择 $a$ 值较大的那一个，因为就算有人和他抢食物他也能吃到热量较高的那个。

可能出现钦定一个人在 $x,y$ 之间选择 $y$ 后 $y,z$ 又出现了一个数大于另一个数的两倍的情况，所以用队列进行 “松弛”。

松弛完毕后，对于没有钦定食物的所有人贪心地选择他相邻两个食物中热量较高的那个即可。若 $x$ 选了食物 $x+1$，那么 $x+1$ 就一定不会选食物 $x+1$，因为 $\dfrac{a_{x+1}}{2}\leq a_{x+2}$。故两个没有钦定食物的人不可能选到同一食物，所以每个人的决策互不干扰，贪心正确性得以保证。

为防止出现小数的情况，可以在一开始将所有食物热量乘以 $2$。注意此时判断 $2a_x<a_y$ 需要开 `long long`。时间复杂度线性。

```cpp
const int N = 1e6 + 5;
int n, q[N << 1], res[N], hd = 1, tl; ll c[N];
int check(int p) {
	if(res[p]) return -1;
	int pre = p, suf = p % n + 1;
	if(c[pre] << 1 < c[suf]) return suf;
	if(c[suf] << 1 < c[pre]) return pre;
	return -1;
}

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) c[i] = read() << 1;
	for(int i = 1; i <= n; i++) {
		int p = check(i);
		if(p != -1) q[++tl] = i;
	} while(hd <= tl) {
		int t = q[hd++], p = check(t);
		if(p == -1) continue;
		res[t] = p, c[p] >>= 1;
		if(check(p)) q[++tl] = p;
		if(check(p == 1 ? n : p - 1)) q[++tl] = p == 1 ? n : p - 1;
	}
	for(int i = 1; i <= n; i++) if(!res[i]) {
		int pre = i, suf = i % n + 1;
		if(c[pre] > c[suf]) res[i] = pre, c[pre] >>= 1;
		else res[i] = suf, c[suf] >>= 1;
	}
	for(int i = 1; i <= n; i++) print(res[i]), pc(' '); 
	return cerr << "Time : " << clock() << " ms" << endl, flush(), 0;
}
```

---

## 作者：z7z_Eta (赞：4)

搜索，目前是$luogu\text{最优解}$

------

这道题我直接想到的是很暴力的做法。

我们只要迭代寻找不满意的客人，当所有人都满意时结束即可。

设`d`数组，1表示选右边的食物，0表示选左边的。每次寻找是$\Theta(n)$的。

很暴力对吧？但是我们可以想到的是每个人的要求有限，但是圆满的结局有很多。
跑不满是种信仰，是人类智慧。

不过我想说的是……

人就是很脆弱的嘛，眼前的利益，当然多多益善。想不到dp的状态，贪心一样是可以快速求解问题的。贪心永远不比dp要差，即使是局限的贪心，也是人类能够出现创新的路标。

```cpp
// Etavioxy
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#define re register
#define ll long long
#define il inline
#define rep(i,s,t) for(re int i=(s);i<=(t);i++)
#define pt(ch) putchar(ch)
#define pti(x) printf("%d",x)
#define ptll(x) printf("%lld",x)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
// c_ints
il int ci(){
	re char ch;int f=1;
	while(!isdigit(ch=getchar()))f= ch=='-'?-1:1 ;
	re int x= ch^'0';
	while(isdigit(ch=getchar()))x=(x*10)+(ch^'0');
	return f*x;
}

enum{N=1000024};
int a[N],d[N];

int main(){
	int n=ci();
	rep(i,1,n) a[i]=ci()*2;
	rep(i,1,n) d[i]=0;

	while(1){
		bool find=0;
		d[0]=d[n];
		rep(i,1,n-1){
			int L= d[i-1]==1?a[i]/2:a[i],
				R= d[i+1]==0?a[i+1]/2:a[i+1];
			if( L!=R && ((L<R)^(d[i])) ){
				find=1, d[i]^=1;
			}
		}
		int L= d[n-1]==1?a[n]/2:a[n],
			R= d[1]==0?a[1]/2:a[1];
		if( L!=R && ((L<R)^(d[n])) ){
			find=1, d[n]^=1;
		}
		if( !find ) break;
	}

	rep(i,1,n-1) pti(i+d[i]),pt(' ');
	pti(d[n]?1:n);
	pt('\n');
	return 0;
}

```

但是欢迎$hack$。

---

## 作者：猫粮寸断 (赞：4)

这里有一个玄学做法

首先这道题的正解是DP，然后我也确实写了DP，但是由于我太弱了，~~到现在还没有调到满分~~

我们可以发现，在DP时，当一个人左边和右边的人的选择都已经确定，这个人可以选择的状态也是确定的，对于每一个人而言总共有八种情况

可以开一个数组dp[i][u][v][w]，表示第i个人，左边的人为u，自己为v，右边的人w，其中u，z，w等于0时表示选左边的菜，等于1时表示选右边的菜，这样我们就可以进行转移

由于第一个人的状态是不确定的，我们枚举第一个人的八种情况，并且用或运算进行储存

部分代码类似于这样
```cpp
if(c[i]>=c[i+1])
		{
		  	dp[i][0][0][1]=dp[i-1][0][0][0]|dp[i-1][1][0][0];
			if(c[i]>=2*c[i+1])
		 	{
		 	 	 dp[i][1][0][1]=dp[i-1][0][1][0]|dp[i-1][1][1][0];
		 	 	 dp[i][1][0][0]=dp[i-1][0][1][0]|dp[i-1][1][1][0];
		 	}
		}
```

---

## 作者：CmsMartin (赞：3)

[更好的阅读体验](http://cmsblog.top/archives/poi2015las)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P3584)

## 思路

~~这题黑是恶意评分吧~~

考虑 dp，先想状态怎么设。

很容易想到的第一种 dp，假设 $dp_{i,j}$（$j \in \{1,2\}$），表示第 $i$ 个人吃了左边（$j = 1$）或者 右边（$j = 2$）的食物，可是这样似乎没有什么转移关系，所以做不了（~~或者我太菜了不会转移~~）。

既然这样状态做不了，考虑 dp 食物，假设 $dp_{i,j}$（$j \in \{1,2,3,4\}$），表示第 $i$ 食物被左边的人吃（$j = 1$）或者 被右边的人吃（$j = 2$）或者 被两边的人同时吃（$j = 3$）或者 不被吃（$j = 4$）。

考虑转移，对于这种初始状态不确定的，我们可以考虑强制确定第一个食物的状态，然后递推获得后面状态的可行性，并记录从那个状态转移过来，最后根据 dp 数组倒推得到答案。

讨论都很类似，在此仅讨论 $dp_{i,1}$ 的转移（$C$ 为热量数组）：

$$
dp_{i,1} =\left\{ 
    \begin{array}{lc}
        1 \ \ \ \ \ C_{i-1} \le C_i \times 2 \\
        4 \ \ \ \ \ C_{i-1} \le C_i \ \ \  \texttt{如果同时满足上下两条条件取下面这条（贪心）}
    \end{array}
\right.
$$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e6 + 10;

int N;
int Dp[MAXN][5] , Num[MAXN] , Ans[MAXN];

bool Dynamic_Programming(int s) {
	memset(Dp , 0 , sizeof Dp);
	Dp[1][s] = 1;
	for(int i = 2; i <= N + 1; i++) {
		if(Dp[i - 1][1] && Num[i - 1] <= Num[i] * 2) Dp[i][1] = 1;
		if(Dp[i - 1][1] && Num[i - 1] <= Num[i]) Dp[i][3] = 1;
		if(Dp[i - 1][2] && Num[i] <= Num[i - 1] * 2) Dp[i][2] = 2;
		if(Dp[i - 1][2] && Num[i] <= Num[i - 1]) Dp[i][4] = 2;
		if(Dp[i - 1][3] && Num[i] <= Num[i - 1]) Dp[i][2] = 3;
		if(Dp[i - 1][3] && Num[i] * 2 <= Num[i - 1]) Dp[i][4] = 3;
		if(Dp[i - 1][4] && Num[i - 1] <= Num[i]) Dp[i][1] = 4;
		if(Dp[i - 1][4] && Num[i - 1] * 2 <= Num[i]) Dp[i][3] = 4;
	}
	return Dp[N + 1][s];
}

int main() {
	scanf("%d" ,&N);
	for(int i = 1; i <= N; i++) {
		scanf("%d" ,Num + i);
	}
	Num[N + 1] = Num[1];
	for(int i = 1; i <= 4; i++) {
		if(Dynamic_Programming(i)) {
			int x = i;
			for(int j = N + 1; j >= 1; j--) {
				if(x == 1) {
					Ans[j - 1] = (j - 1) % N + 1;
				}
				if(x == 2) {
					Ans[j] = (j - 1) % N + 1;
				}
				if(x == 3) {
					Ans[j - 1] = Ans[j] = (j - 1) % N + 1;
				}
				x = Dp[j][x];
			}
			for(int i = 1; i <= N; i++) {
				printf("%d " ,Ans[i]);
			}
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：FreeTimeLove (赞：1)

首 A 黑题，发题解以纪念。

由题意可知，一个人不满意**当且仅当**他选择另一份食物可以获得更多的热量。

那么这里有一个**贪心**的想法：我们将所有的人扫一遍，对于每一个不满意的人，改变他的选择，同时判断他旁边两个人是否满意，如果不满意则同样改变选择并判断左右两人，直到**所波及到**的人都满意为止，再去判断下一个人。

那怎么判断无解的状态呢？不用判断，因为本题**一定有解**！

如果存在无解的状态，那么一定**总是有人不满意**。此时对于一个不满意的人 $i$（假设当前**只有**这一个人不满意），我们改变他的选择后，他左右一定**至少**有一方不满意。我们钦定他右边的人 $(i+1)$ 一定不满意，那么改变选择后**一定**是第二个人右边的人 $(i+2)$ **或**第一个人左边的人 $(i-1)$ 不满意。

这样一圈下来，所有人都改变了选择。再进行一圈，所有人都回到了原来的选择，而按理此时的选择却比最开始**更优**，矛盾，因此本题一定是有解的。

当扫到第 $i$ 个人的时候，我们会确保第 $i$ 个人一定满意；在之后的操作中，我们每次都会确保第 $i$ 个人满意。因此我们只要扫一遍，就能确保所有的人都满意。

在此基础上我们还可以进一步优化：如果一个人当前已知是满意的，我们就给它打上标记，同时计数器加 $1$。遍历所有人的时候，如果此人有标记，直接跳过；否则额外打上标记。当计数器等于 $n$ 时跳出即可。

### AC code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define ll long long
#define db double
using namespace std;
const int N=1e6+5;
ll n,f[N],c[N],l,r,bk[N]/*标记*/,tot;
queue<int>que;
ll read(){
	ll ans=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		ans=(ans<<3)+(ans<<1)+(ch^48);
		ch=getchar();
	}
	return ans;
}
bool gt(int i){//判断是否满意
	db x,y;
	l=(i==1)?n:i-1;
	r=(i==n)?1:i+1;
	x=double(c[i])*((f[l]==i)?0.5:1.0);
	y=double(c[r])*((f[r]==r)?0.5:1.0);
	if(f[i]!=i)swap(x,y);
	return x<y;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		f[i]=i;
		c[i]=read();
	}
	for(int i=1;tot<n&&i<=n;i++){
		if(bk[i])continue;
		if(gt(i))que.push(i);
		else{bk[i]=1;tot++;}
		while(!que.empty()){
			int u=que.front();
			que.pop();
			f[u]=((u<n)?((u<<1)+1):(n+1))-f[u];
			if(bk[i]==0){
				bk[i]=1;
				tot++;
			}
			int v=u%n+1;
			if(gt(v))que.push(v);
			v=(u-1)%n+n*(u==1);
			if(gt(v))que.push(v);
		}
	}	
	for(int i=1;i<=n;i++)printf("%lld ",f[i]);
	puts("");
	return 0;
} 
```
### $\text{The End.}$

---

## 作者：Captain_Paul (赞：0)

神奇的$dp$

按照每个人的选择设计状态是不可行的

考虑按照食物设计状态

$f[i][S](S∈[0,4])$表示第$i$个食物没有被选/左边选/右边选/同时选的状态是由哪一个状态转移来的

我们需要满足两个条件：

- 每个人只能选择一个

- 改变选择之后不会比当前获得热量多

讨论$a_i$和$a_{i-1}$的大小关系进行转移

输出方案的时候由后向前推过去就好

像这样的环形$dp$，一般套路都是先固定第一个的状态进行$dp$，枚举第一个的不同情况就可以了

```
#include<cstdio>
#include<cstring>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#define reg register
using namespace std;
const int N=1e6+5;
int n,a[N],ans[N],f[N][4];//0:Á½±ß¶¼²»Ñ¡ 1:×ó±ß 2:ÓÒ±ß 3:Á½±ß¶¼Ñ¡ 
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
inline bool work(int k)
{
	memset(f,-1,sizeof(f)); f[1][k]=1;
	for (reg int i=2;i<=n;i++)
	{
		if (~f[i-1][2]&&a[i-1]>=a[i]) f[i][0]=2;
		if (~f[i-1][3]&&a[i-1]>=a[i]*2) f[i][0]=3;
		if (~f[i-1][0]&&a[i]>=a[i-1]) f[i][1]=0;
		if (~f[i-1][1]&&a[i]*2>=a[i-1]) f[i][1]=1;
		if (~f[i-1][2]&&a[i-1]*2>=a[i]) f[i][2]=2;
		if (~f[i-1][3]&&a[i-1]>=a[i]) f[i][2]=3;
		if (~f[i-1][0]&&a[i]>=a[i-1]*2) f[i][3]=0;
		if (~f[i-1][1]&&a[i]>=a[i-1]) f[i][3]=1;
	}
	return ~f[n][k];
}
inline void print(int k)
{
	--n;
	for (reg int i=n;~i;i--)
	{
		if (k==1) ans[i]=i%n+1;
		if (k==2) ans[i+1]=i%n+1;
		if (k==3) ans[i]=ans[i+1]=i%n+1;
		k=f[i+1][k];
	}
	for (reg int i=1;i<=n;i++) printf("%d ",ans[i]);
	exit(0);
}
int main()
{
	n=read();
	for (reg int i=1;i<=n;a[i++]=read()); a[++n]=a[1];
	for (reg int i=0;i<4;i++) if (work(i)) print(i);
	puts("NIE");
	return 0;
}
```

---


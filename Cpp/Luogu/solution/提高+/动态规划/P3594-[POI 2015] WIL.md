# [POI 2015] WIL

## 题目描述

给定一个长度为 $n$ 的序列，你有一次机会选中一段连续的长度不超过 $d$ 的区间，将里面所有数字全部修改为 $0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 $p$。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le d \le n \le 2 \times 10^6$，$0 \le p \le 10^{16}$，$1 \leq w_i \leq 10^9$。

----

原题名称：Wilcze doły。

## 样例 #1

### 输入

```
9 7 2
3 4 1 9 4 1 7 1 3```

### 输出

```
5```

# 题解

## 作者：Nemlit (赞：37)

定义$sum[x] = \sum_{i = 1}^x a[i]$

首先不难想到，我们枚举左右端点，然后贪心的减去这一段区间中$sum[x] - sum[x - d + 1]$的最大值，这样枚举是$O(N^3)$的

然后我们发现，对于一个左端点，我们肯定要尽可能的往后去找右端点，同理，对于一个右端点，我们肯定要尽可能找满足条件的最偏左的左端点

可以把枚举改成双指针，复杂度变成了$O(N^2)$

我们重新来看一下题意的式子：枚举右端点$r$，找到$max(sum[r] - sum[l - 1] - max(sum[x] + sum[x - d + 1]))$的值

我们复杂度的瓶颈在于维护$max(sum[x] + sum[x - d + 1])$，不难发现这个式子是单调的，所以我们可以使用单调队列来维护

右指针每次往右边移动的时候，把$max(sum[x] + sum[x - d + 1])$加入队列并弹出不单调的值

如果当前队列的最大值（队首）所对应的端点比我们求出的左端点小了，就可以弹出了
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 2000005
int n, p, d, ans, a[maxn], l, sum[maxn], h, t, q[maxn];
signed main() {
	n = read(), p = read(), d = read();
	rep(i, 1, n) a[i] = read(), sum[i] = sum[i - 1] + a[i];
	ans = d, q[t] = d, l = 1;
	rep(i, d + 1, n) {
		while(h <= t && sum[i] - sum[i - d] > sum[q[t]] - sum[q[t] - d]) -- t;
		q[++ t] = i;
		while(h <= t && sum[i] - sum[l - 1] - sum[q[h]] + sum[q[h] - d] > p) {
			++ l;
			while(h <= t && q[h] - d + 1 < l) ++ h;
		}
		ans = max(ans, i - l + 1);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：asuldb (赞：26)

第一篇题解确实会被讨论区里的数据hack掉，那么就随便水一个不会被hack掉的题解吧

首先我们尝试着发现这道题的一些结论，**你就会发现答案是单调的不降的**

这里的答案不降指的是**选择每一个位置$i$作为结尾能形成的最长区间的左端点是单调不降的**，这个很好证明，将$i-1$这个位置作为结尾形成的最长区间的左端点不可能比$i$作为结尾形成的最长区间的左端点更靠右

如果更靠右的话，那么$i-1$形成的区间还能更靠左一些，这与我们的假设不符，所以这个结论是成立的

之后我们就可以利用这个结论计算每一个$i$为结尾的区间的左端点在哪里了

由于$i$的左端点不可能比$i-1$的更靠左，所以我们就直接来将$i-1$的左端点$last$为起始端点就好了

如果$p[i]-p[last-1]$即这段区间的和减去这个区间内所有**长度为$d$的区间和的最大值**还是超过$p$，那么我们就让$last++$，直到满足条件为止

至于怎么维护一个区间内所有长度为$d$的区间和的最大值，我们用一个单调队列就好了

时间复杂度其实是均摊了两次，但是还是非常优秀的$O(n)$

代码

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdio>
#define re register
#define maxn 2000005
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define LL unsigned long long
LL n,p,d;
LL a[maxn],pre[maxn];
LL ans,t[maxn],last;
inline LL read()
{
    LL x=0;
    char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
      x=x*10+c-48,c=getchar();
    return x;
}
int main()
{
    n=read();
    p=read();
    d=read();
    for(re int i=1;i<=n;i++)
        a[i]=read();
    for(re int i=1;i<=n;i++)
        pre[i]=pre[i-1]+a[i];
    std::deque<int> q;
    for(re int i=d;i<=n;i++)
        t[i]=pre[i]-pre[i-d];//t[i]表示[i-d+1,i]这个区间的和
    ans=d;//最开始ans为d
    q.push_back(d);
    last=1;
    for(re int i=d+1;i<=n;i++)
    {
        while(!q.empty()&&t[i]>t[q.back()]) q.pop_back();
        q.push_back(i);//在队尾加入一个元素
        while(!q.empty()&&q.front()-d+1<last) q.pop_front();
        //，如果队首元素的左端点比last还小，那么就弹出不合法的队首元素
        while(!q.empty()&&pre[i]-pre[last-1]-t[q.front()]>p)
        {
            last++;
            while(!q.empty()&&q.front()-d+1<last) q.pop_front();
            //last++后也要维护队首的合法性
        }
        ans=max(ans,i-last+1);
    }
    std::cout<<ans;
    return 0;
}
```

---

## 作者：花里心爱 (赞：10)

### P3594 题解
思路比较清晰的一道题qwq

首先观察题目，"选中一段连续的长度不超过d的区间全部修改为0"一定是能选就选（因为没有负数，选之后和一定会变小）

然后想贪心。

首先答案一定大于等于d（因为这段区间的数都被删掉了，所以区间和为0）。

我们发现如果最终的区间$[l, r]$确定了，那么一定是要选和最大的那段区间变为0，这样的话会有更多的机会扩展区间。

先想最简单的算法。我们可以枚举`l,r`，扫一遍$[l,r]$，选择和最大的长度为d的区间，将它删掉，看结果是不是不超过`p`。这样复杂度是$O(n^3)$的。

然后想到尺取法。当`l`固定时，右边界`r`一定是能扩展就扩展，这样我们就可以维护2个指针`l,r`，当`r`不能再向右扩展时将`l`这个数删掉。时间复杂度$O(n^2)$。

我们还会发现，当我们移动`l,r`的时候，"长度为d的区间和最大的区间"的左端点在l右边，右端点在r左边（~~显然~~）。

于是我们就可以预处理出`t[i]`表示$[i-d+1, i]$的区间和。

因为要求最大的区间和，所以我们用单调队列来维护。每次r向右移动时，将`t[r]`加入队列，l向右移动时，如果队首为`t[l+d]`（也就是左端点为l的区间），将队首出队。

时间复杂度$O(n)$。

下面给出代码，这里我的实现方式是每次将`r`右移看当前`l`是否可行，如果不可行将`l`右移。
```cpp
#include <cstdio>
#include <cctype>
#define ll long long
#define maxn 2000005
inline ll read() {
    ll d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48;ch=getchar();}return d;
}
inline ll mmax(ll x, ll y) {
    return x>y?x:y;
}
ll n, p, d;
ll a[maxn], s[maxn]; // a 为原数列， s 为前缀和
ll t[maxn]; // t 为[i-d+1, i]的区间和
ll now, mx;
int q[maxn], he = 1, ta = 0; // 单调队列
int l = 1, r;
int main() {
    n = read(), p = read(), d = read();
    for(int i = 1; i <= n; ++i) {
        a[i] = read();
        s[i] = s[i-1]+a[i];
    }
    for(int i = d; i <= n; ++i)
        t[i] = s[i] - s[i-d]; // 预处理出 t[i]
    mx = d; // 答案一定大于等于d
    now = s[d];
    q[++ta] = d; // 将第一个数放进队列
    for(int r = d+1; r <= n; ++r) { // 因为前d个数可以直接变为0，所以r从d+1开始枚举
        now += a[r];
        while(he <= ta && t[q[ta]] <= t[r]) --ta;
        q[++ta] = r; // t[r]入队
        while(now-t[q[he]] > p) {
            if(q[he] < l+d) ++he;
            now -= a[l++]; // 检查当前l是否合法，若不合法将l右移
        }
        mx = mmax(mx, r-l+1); // 更新当前答案
    }
    printf("%lld", mx);
    return 0;
}
```

---

## 作者：PanH (赞：7)

~~看来还是单调队列做少了，外面套个双指针就没想到做法了。~~

**不过还是用一个 $O(n\log n)$ 的二分答案水过了这题。**

简单地说，二分一个序列最长是多少，在 ```check()``` 函数中枚举每个区间判断是否可行。

直接 $O(n^2)$ 判肯定不行，于是再上单调队列维护当前区间中和最大的长为 $d$ 的子串。

code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	while(!isdigit(ch)) f=ch=='-',ch=getchar();
	while(isdigit(ch))	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
const int N=2e6+5;
int n,p,d,a[N],tur[N],sum[N];
int q[N],head,tail;
bool check(int h)
{
	head=1,tail=0;
	int res=0x3f3f3f3f3f3f3f3f;
	for(int i=d;i<=n;i++)
	{
		while(head<=tail&&q[head]-d<i-h)	head++;
		while(head<=tail&&tur[q[tail]]<=tur[i])	tail--;
		q[++tail]=i;
		if(i>=h)	res=min(res,sum[i]-sum[i-h]-tur[q[head]]);
	}
	return res<=p;
}
signed main()
{
	read(n),read(p),read(d);
	for(int i=1;i<=n;i++)	read(a[i]),sum[i]=sum[i-1]+a[i];
	for(int i=d;i<=n;i++)	tur[i]=sum[i]-sum[i-d];
	int l=d,r=n,mid,res=0;
	while(l<=r)
	{
		mid=l+r>>1;
		if(check(mid))	l=mid+1,res=mid;
		else	r=mid-1;
	}
	printf("%lld",res);
	return 0;
}
```


---

## 作者：翼德天尊 (赞：6)

## 题目大意

给定一个长度为 $n$ 的序列，将其中长度**不超过 $d$** 的一段改为 $0$ 后，求区间和不超过 $p$ 的子区间的最大长度。 

注意，序列中的元素都是**正整数**！

## 解题思路

首先考虑一个问题。

由于序列中的数都是正整数，我们在选中区间覆盖 $d$ 个长度一定比覆盖 $d-1$ 个长度优。即使我们只选了 $d-1$ 个数，多选一个一定还是更优的（长度变长了）。所以我们可以将覆盖长度默认为 $d$。

而默认之后，可以供我们选择覆盖、长度为 $d$ 的区间只剩下了 $n-d+1$ 个。

题意让我们先覆盖一段为 $0$ 在选区间，这样太麻烦，区间不好选，我们不要。

于是我们反过来想。如果我们先选区间，再选择一段覆盖，那么由于覆盖长度确定，我们覆盖的一定是该区间之中区间和最大的一段长度为 $d$ 的区间。所以我们可以考虑先选择区间。

考虑找到每一个 $r$，随着 $r$ 的值不断递增，$l$ 一定也是单调递增的。又因为我们选择的覆盖区间一定是所选区间的一部分，所以覆盖区间大体上也是单调递增的。

于是我们突然想到了单调队列。

考虑从 $d$ 开始枚举每一个 $r$，并将该 $r$ 产生的新的长度为 $d$ 的区间 $(r-d+1,r)$ 按照正常程序放入单调队列（剔除队尾区间和小于该区间区间和的区间（莫名绕口））。

注意放入单调队列时，由于我们可以通过 $r$ 来推出区间和，而不能通过区间和推出 $r$，所以只需要放入 $r$ 即可代表整个区间。

然后我们再来审视目前的区间，如果此时的区间和减去最大的覆盖区间和仍然大于 $p$（覆盖区间和即为单调队列队首区间的区间和），我们就可以将 $l$ 加 $1$，并剔除单调队列队首在所选区间范围之外的覆盖区间。


单调队列的实现可以用双端队列，用数组实现即可。

区间和可以通过预处理前缀和快速求出。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 2000005
int n,d,a[N],ans,head=1,tail;
ll sum[N],deq[N],p;
ll read(){
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
ll len(ll x){//求以x为结尾的长度为d的区间和
	return sum[x]-sum[x-d];
}
int main(){
	n=read(),p=read(),d=read();
	for (int i=1;i<=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];
	//输入+前缀和
	for (int l=1,r=d;r<=n;r++){
		while (head<=tail&&len(deq[tail])<len(r)) --tail;//剔除区间和小的区间
		deq[++tail]=r;//将该区间加入队列
		while (sum[r]-sum[l-1]-len(deq[head])>p){//如果条件不满足
			++l;//将区间变小
			if (head<=tail&&deq[head]<l+d-1) ++head;//剔除队首在所选区间之外的区间
		}
		ans=max(ans,r-l+1);//更新答案
	}
	printf("%d\n",ans);//输出
	return 0;
}
```

如果对你有帮助，记得点个赞哦！


---

## 作者：HoshiuZ (赞：5)


给定一个长度为$n$的序列，你有一次机会选中一段连续的长度不超过$d$的区间，将里面所有数字全部修改为$0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过$p$。

### 链接

[[POI2015]WIL-Wilcze doły](https://www.luogu.com.cn/problem/P3594) 

### 思路

由于每个数都是正数，那么当然修改的越多越好，干脆直接修改长度为$d$的区间。

枚举选中的连续区间的左右端点和被修改区间的左端点，便可以得到一个$O(n^3)$的算法，TLE。

```cpp
#include<bits/stdc++.h>
#define N 2000010
#define ull unsigned long long 

using namespace std;

int n,d,ans=0;
ull p,a[N],sum[N];

int main() {
	cin>>n>>p>>d;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	
	for(int i=d;i<=n;i++) {
		for(int j=1;j<=i-d+1;j++) {
			for(int k=j;k<=i-d+1;k++) {
				if(sum[i]-sum[j-1]-(sum[k+d-1]-sum[k-1])<=p) ans=max(ans,i-j+1);
			}
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

这种选连续数和不超过一个数值的题型让我想到了挑程上的尺取法。于是便采用了这种方法进行优化，向一个队列中加数，当和大于了$p$，就开始从被选的数列中枚举修改为$0$的区间的左端点，若不存在修改后小于等于$p$的修改区间，则将队头出队。过程中记录最大区间长度即可。时间复杂度$O(n^2)$，还是TLE。

```cpp
#include<bits/stdc++.h>
#define N 2000010
#define ull unsigned long long 

using namespace std;

int n,d,ans=0,l=1;
ull p,a[N],sum[N],s=0;

int main() {
	cin>>n>>p>>d;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	
	for(int i=1;i<=n;i++) {
		s+=a[i];
		if(i-l+1<=d) {
			ans=max(ans,i-l+1);
			continue;
		}
		if(s>p) {
			bool flag=false;
			for(int j=l;j<=i-d+1;j++) {
				if(s-(sum[j+d-1]-sum[j-1])<=p) {
					flag=true;
					ans=max(ans,i-l+1);
				}
			}
			if(!flag) s-=a[l++];
		}
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

明显， 被修改的长为$d$的区间内的数和越大越好，于是可以在用尺取法的过程中用单调队列维护单调递增的目前尺取的区间内长为$d$的区间和的区间左端点进行优化即可。

时间复杂度$O(n)$，AC。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 2000010
#define ull unsigned long long 

using namespace std;

int n,d,ans=0,l=1,q[N],head=1,tail=1;
ull p,a[N],sum[N],s=0;

int main() {
	cin>>n>>p>>d;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		if(i<=d) s+=a[i];
	}
	
	q[head]=d;
	for(int i=d+1;i<=n;i++) {
		s+=a[i];
		while(head<=tail&&sum[i]-sum[i-d]>=sum[q[tail]]-sum[q[tail]-d]) tail--;
		q[++tail]=i;
		while(head<=tail&&q[head]-d+1<l) head++;
		while(s-(sum[q[head]]-sum[q[head]-d])>p) {
			s-=a[l++];
			while(head<=tail&&q[head]-d+1<l) head++;
		}
		ans=max(ans,i-l+1);
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```



---

## 作者：attack (赞：4)

题目保证n是正整数


那么我们所要修改的区间的长度一定是d


这样的话我们可以预处理出所有数的xigame(i,i+d)的值


考虑如何解决区间问题


我们假设已经有一个区间(l,r)


那么当这个区间的值-区间内xigame(i,i+d)的最大值仍然大于p的话，我们考虑让l++


如此枚举下去，对于每一个区间，我们所选择的xigame(i,i+d)一定是最大的，那么这个区间一定是最优的


那么我们如何维护xigame(i,i+d)的最大值呢？


经过上面的分析，我们不难想到，l是随着r的增大而增大的


这样就满足了单调的性质，那么我们就可以用单调队列来维护这个值了


时间复杂度：O(n)


**还有！**

**不开long long 见祖宗**

**多年oi一场空！！！**###\_\_


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<deque>
#define LL long long 
using namespace std;
const LL MAXN=2000010;
inline void read(LL &n)
{
    char c=getchar();n=0;bool flag=0;
    while(c<'0'||c>'9')    c=='-'?flag=1,c=getchar():c=getchar();
    while(c>='0'&&c<='9')    n=n*10+c-48,c=getchar();flag==1?n=-n:n=n;
}
struct node
{
    LL pos,val;
    node(){pos=val=0;}
    node(LL a,LL b)    {    pos=a;val=b;    }
};
LL n,p,d;
LL a[MAXN];
LL sum[MAXN];// 前缀和
LL change[MAXN];//xigema(i,i+d) 
int main()
{
    read(n);read(p);read(d);
    for(LL i=1;i<=n;i++)
        read(a[i]),sum[i]=sum[i-1]+a[i];
    for(LL i=1;i<=n-d;i++)    change[i]=sum[i+d]-sum[i];
    for(LL i=n-d+1;i<=n;i++)    change[i]=sum[n]-sum[i];
    deque<node>q;
    LL ans=d;// 最小就是d
    LL l=0;// l 
    for(LL i=d+1;i<=n;i++) 
    {
        while(q.size()>0&&q.back().val<change[i-d])    q.pop_back();
        q.push_back(node(i-d,change[i-d]));
        while(l<i-d&&sum[i]-sum[l]-q.front().val>p)    
        {
            l++;
            while(l>q.front().pos)    q.pop_front();
        }
        ans=max(ans,i-l);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：shight (赞：1)

大家好像都是dp做的，那我来提供一种二分加单调队列的做法吧。（虽然慢一些但复杂度没问题。）

首先看到题目中说最长的满足条件的序列，且由于所有权值皆正，若长度为 $p$ 的连续区间成立则长度为 $p-1$ 的子串也必然成立，就不由自主的想到二分其长度。

并且，由于题目中说删去的区间长度不超过 $d$,但所有权值都是大于$0$的，所以删去的区间长度一定为 $d$。

在得到长度后,我们只需要通过单调队列来得出对于每一个位置，在以他为末尾的大区间中哪一段长度为 $d$ 的区间区间和最大，就可以轻松计算出以其为末尾的长度为当前二分出来的值的区间的最小和，即为这段区间的区间和减去这段区间内长度为 $d$ 的最大区间和。只需要每次判断一下是否有区间和大于 $p$ 即可。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
#define N 2000001
using namespace std;
int n,p,d,a[N],sum[N],q[N],f[N];
int check(int nw)
{
	int l=1,r=0;
	q[++r]=d;f[d]=sum[d];
	for(int i=d+1;i<=n;i++)
	{
		while(l<=r&&q[l]-d<i-nw)l++;
		while(l<=r&&sum[q[r]]-sum[q[r]-d]<sum[i]-sum[i-d])r--;
		q[++r]=i;f[i]=sum[q[l]]-sum[q[l]-d];
	}
	for(int i=nw;i<=n;i++)
	{
		int tmp=sum[i]-sum[i-nw]-f[i];
		if(tmp<=p)return 1;
	}
	return 0;
}
signed main()
{
	scanf("%lld %lld %lld",&n,&p,&d);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i];
	int l=d,r=n,ans;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(check(mid))
		{
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：Luciylove (赞：1)

[题目描述](https://www.luogu.com.cn/problem/P3594)

我们设:

#### $a[i]$ 为数列上的第$i$位

#### $sum[i]=\sum_{j=1}^{i}a[i]$

#### $size[i]=\sum_{j=i-d+1}^{i}a[i]$

然后二分答案答案 $ans$ 值，考虑这样的一个$check$函数:

若存在一段区间 $l,r$ ,长度为 $ans$ 使得将其区间和减去其里面的最大字段和(长度$\leq d$) $\leq p$，就返回合法。

我们发现其剩下的和可以描述为:
  
### $f_i=sum_i-sum_{i-ans}-\max(size[j])$

其中:$i\geq j \geq i-val+d$

我们发现这个取$max$对于单调队列就是基操,于是,我们就可以用$O(n\log_2n)$的时间解决.

代码:
```cpp
#include<iostream>
#include<cstdio>
#define N 3000005
using namespace std;
namespace IO { //IO
	inline int read(){
		char ch=getchar();
		int x=0,f=1;
		while(ch<'0'||ch>'9'){
			if(ch=='-') f=-1;
			ch=getchar();
		}
		while('0'<=ch&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	inline void write(int x){
		if (x<0) x =~x+1,putchar('-');
		if (x>9) write(x/10);
		putchar(x%10+'0');
	}
}
long long a[N],sum[N],q[N],size[N]; //十年OI一场空，不开long long见祖宗
int n,k,p,head,tail,ans;
bool check(int val){
	long long res=0x3f3f3f3f3f3f3f3f;
	head=1,tail=0;
	for(int i=k;i<=n;i++){
		while(head<=tail&&q[head]<i-val+k) head++; //保证最大的size[i]合法
		while(head<=tail&&size[q[tail]]<size[i]) tail--; //插入新的size[i]
		q[++tail]=i;
		if(i>=val)res=min(res,sum[i]-sum[i-val]-size[q[head]]); //计算对于i这个为结束点的和
	}
	return res<=p;
}
int main(){
   n=IO::read(); //读入
   p=IO::read();
   k=IO::read(); //d
   for(int i=1;i<=n;i++){
 	int x=IO::read();
 	sum[i]=sum[i-1]+x; //sum[i]
   }
   for(int i=k;i<=n;i++)
   	size[i]=sum[i]-sum[i-k]; //计算size[i]
   int l=0,r=n+1;
   while(l<=r){ //二分答案
   	int mid=l+r>>1;
   	if(check(mid)) l=mid+1,ans=mid;
   	else r=mid-1;
   }
   printf("%d",ans);
   return 0;
} 
```






---

## 作者：_Anchor (赞：1)

# 题面

[传送门](https://www.luogu.com.cn/problem/P3594)

![](https://img2020.cnblogs.com/blog/2013965/202012/2013965-20201212173405200-1488982653.png)


# 分析

一道较为简单的单调队列题目

思路和[上一道题](https://www.luogu.com.cn/problem/P2564)很像，就是枚举右端点，然后找到满足条件的“最左”的左端点

怎么找呢，我们发现随着右端点的右移，其实左端点也在不断地右移，那么就是**左端点单调不减**

然后我们就可以想到单调队列来维护了

队列当中维护的信息是什么呢...

左端点位置？不是。

因为这样维护的话我们每次还要在当前区间当中找到最大的长度为$d$的区间，很麻烦

所以我们直接维护这个长度为$d$的区间的和的最大值，以及这个区间的左端点即可

（就是说队列里存的是这个区间和的最大值对应区间的位置，而且在这个过程中，我们顺带记一下左端点$st$的位置）

然后总复杂度就是$O(n)$的，具体细节看代码

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
#define ll long long
const int N=2e6+5;
ll n,p,d,hh,tt=-1,que[N],a[N],pre[N],val[N],st=1,ans; 
int main(){
	read(n),read(p),read(d);
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[i];
	for(int i=d;i<=n;i++) val[i]=pre[i]-pre[i-d];
	que[++tt]=d,ans=d;
	for(int i=d+1;i<=n;i++){
		while(hh<=tt&&val[i]>val[que[tt]]) tt--;//维护最大的长度为$d$的区间
		que[++tt]=i;
		while(hh<=tt&&pre[i]-pre[st-1]-val[que[hh]]>p) st++;
                while(hh<=tt&&que[hh]-d+1<st) hh++;//如果本身这个最大值已经不在当前$st-i$的区间内，直接弹出
		ans=max(ans,i-st+1);
	}
	write(ans);
	return 0;
}
```


---

## 作者：Cry_For_theMoon (赞：1)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P3594)

&emsp;&emsp;区间转点然后用单调队列维护。


&emsp;&emsp;设 $f(i)$ 为以 $w_i$ 为右端点，最靠左的一个点满足两点之间的和（可以有一部分清零）满足条件。显然 $f(i)$ 是 **单调上升的**，$f(i)$ 的取值范围应为 $[f(i-1),i]$

&emsp;&emsp;考虑让 $f(i-1)$ 成为 $f(i)$ 的值。那么我们可以去掉一段长度小于等于 $t$ 的，因此根据贪心法，应该去掉一个**和最大的长度小于等于 $t$ 的子区间**。这里如果子区间长度不定，不方便优化，贪心可以得到最后整体而言选取的那个线段长度一定为 $t$，但这样的话可能一个长度为 $t-1$ 的本来最优的选择区间因为左端点出界了而被排除。但是如果发生这种情况，**一定有一种把它右移的方法，使得移动过后该线段完全被包含且覆盖了原本线段在 $[i,j]$ 里覆盖了的部分**。所以我们可以直接视作清零线段长度就是 $t$

&emsp;&emsp;我们已经发现这里单调队列存的是区间了，让每个点对应一个区间的结尾，那么 $\sum_{j=i-t+1}^{i}a_i$  就是元素 $i$ 的值。

&emsp;&emsp;继续考虑如果 $f(i-1)$ 不满足，往前移的情况。此时询问区间（就是单调队列的滑动窗口）右端点不变，左端点右移一个，根据刚才的分析，同样只需要考虑长度为 $t$ 的区间。因此类似地，像加入之前清除掉"过时"的节点一样，询问区间更改后对队首节点进行弹出操作（如果不满足）。一直缩小到满足为止，此时就得到了答案。

&emsp;&emsp;主要还是这里单调队列的复杂度，每个点（其实是区间）只会被进队一次，那么均摊下来就还是 $O(n)$ 的，不过单调队列的常数emmm，建议还是手写 deque

```cpp
//POI,2015
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=2e6+10;
int n,d,ans;
long long p,w[MAXN],sum[MAXN];
int f[MAXN],q[MAXN];
int main(){
	scanf("%d%lld%d",&n,&p,&d);
	for(int i=1;i<=n;i++){
		scanf("%lld",&w[i]);
		sum[i] = sum[i-1]+w[i];
	}
	f[0] = 1;
	int head=1,rear=1;
	for(int i=1;i<=n;i++){
		int start = f[i-1];
		//答案区间在[start,i]之间
		int tmp = 0;
		long long value = sum[i] - sum[max(0,i-d)];
		while(head < rear && max(1,q[head]-d+1) < start)head++;
		while(head < rear && sum[q[rear-1]] - sum[max(0,q[rear-1]-d)]<= value)rear--;
		q[rear++] = i;
		while(sum[i]-sum[start-1]-(sum[q[head]] - sum[max(0,q[head]-d)]) > p){
			start++;
			while(head < rear && q[head] < start)head++;
		}
		f[i] = start;
		ans = max(ans,i-f[i]+1);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：GoPoux4 (赞：1)

### 解法

定义 $sum_i$ 为 $a$ 的前缀和，即 $sum_i=\sum_{j=1}^i a_j$。

首先最长区间用双指针来枚举。当区间确定时，考虑删去其中区间和最大的长度为 $d$ 的区间，使得修改过的区间和最小。

删去的区间长度是固定的，所以用单调队列求。

注意右指针应该从 $d+1$ 开始枚举。单调队列中开始要加入 $d$ ，因为一个长度为$d$，和为 $0$ 的区间一定满足条件。

---

### 代码

这里有两种初始化不同的单调队列写法：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 2000005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,d,p,sum[maxn],ans;
lxl q[maxn],l,r;

int main()
{
	//freopen("P3594.in","r",stdin);
	n=read(),p=read(),ans=d=read();
	for(R int i=1;i<=n;++i)
		sum[i]=sum[i-1]+read();
	lxl j=0;
	q[++r]=d;
	for(R lxl i=d+1;i<=n;++i)
	{
		while(l<r&&sum[q[r]]-sum[q[r]-d]<sum[i]-sum[i-d]) --r;
		q[++r]=i;
		while(l<r&&q[l+1]-d<j) ++l;
		while(l<r&&sum[i]-sum[j]-sum[q[l+1]]+sum[q[l+1]-d]>p)
		{
			++j;
			while(l<r&&q[l+1]-d<j) ++l;
		}
		ans=max(ans,i-j);
	}
	printf("%lld\n",ans);
	return 0;
}
```

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 2000005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

lxl n,d,p,sum[maxn],ans;
lxl q[maxn],l=1,r;

int main()
{
	n=read(),p=read(),ans=d=read();
	for(R int i=1;i<=n;++i)
		sum[i]=sum[i-1]+read();
	lxl j=0;
	q[++r]=d;
	for(R lxl i=d+1;i<=n;++i)
	{
		while(l<=r&&sum[q[r]]-sum[q[r]-d]<sum[i]-sum[i-d]) --r;
		q[++r]=i;
		while(l<=r&&q[l]-d<j) ++l;
		while(l<=r&&sum[i]-sum[j]-sum[q[l]]+sum[q[l]-d]>p)
		{
			++j;
			while(l<=r&&q[l]-d<j) ++l;
		}
		ans=max(ans,i-j);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Alex_Wei (赞：0)

> [P3594 [POI2015]WIL-Wilcze doły](https://www.luogu.com.cn/problem/P3594)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

考虑实时维护对于当前 $[l,r]$ 所有连续 $p$ 个数的和的最大值，前缀和 + 双指针 + 单调队列优化即可。

$r\to r+1$ 时往单调队列加入 $\sum_{i=r-p+2}^{r+1} a_i$，不满足条件令 $l\to l+1$ 时若单调队列队首是 $\sum_{i=l}^{l+p-1}a_i$ 则弹出。时间复杂度线性。

```cpp
const int N = 2e6 + 5;
int n, len, ans, hd = 1, tl, d[N];
ll w[N], p, val[N];
int main(){
	cin >> n >> p >> len;
	for(int i = 1; i <= n; i++) w[i] = read() + w[i - 1];
	for(int l = 1, r = len; r <= n; r++) {
		ll sum = w[r] - w[r - len];
		while(hd <= tl && sum >= val[tl]) tl--;
		d[++tl] = r, val[tl] = sum;
		while(w[r] - w[l - 1] - val[hd] > p) {if(d[hd] == l + len - 1) hd++; l++;}
		if(r - l + 1 > ans) ans = r - l + 1;
	} cout << ans << endl;
	return 0;
}
```

---

## 作者：bifanwen (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P3594)

考虑枚举右端点 $r$，不妨设对应其最优的左端点为 $a_r$，首先我们应证明 $a$ 单调不减。

考虑到，如果 $[l,r]$ 在 $r$ 最优，而 $[p,r+1](p<l)$ 亦最优的话，那么 $[l,r] \rightarrow [p,r]$ 便是最优，矛盾。于是 $a$ 单调不减。

本来我们考虑预处理前缀和，然后直接枚举 $a_r$ 就可以做到 $\mathcal{O}(n^2)$ 的复杂度。但是考虑到 $a$ 单调不减，于是我们可以用单调队列来维护当前区间长度为 $d$ 的最大和，然后用一个指针去扫 $a_r$ 即可。（其实你说是 $a_r,r$ 的双指针也没问题）

时间复杂度：$\mathcal{O}(n)$.

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e6+1;
typedef long long ll; 

inline ll read(){char ch=getchar(); int f=1; while(ch<'0' || ch>'9') {if(ch=='-') f=-f; ch=getchar();}
	ll x=0; while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar(); return x*f;}

inline void write(int x) {
	if(x<0) {putchar('-');write(-x);return;}
	if(x<10) {putchar(char(x%10+'0'));return;}
	write(x/10);putchar(char(x%10+'0'));
}

int n,d,w[N];
ll p,s[N];
deque<int> q;

int main() {
	n=read(),p=read(),d=read();
	for(int i=1;i<=n;i++) w[i]=read(),s[i]=s[i-1]+w[i];
	int last=1,ans=0;
	for(int i=d;i<=n;i++) {
		while(!q.empty()) {
			int x=q.back();
			if(s[i]-s[i-d]>=s[x]-s[x-d]) q.pop_back();
			else break;
		} while(!q.empty() && q.front()-d+1<last) q.pop_front();
		q.push_back(i);
		while(!q.empty() && s[i]-s[last-1]-(s[q.front()]-s[q.front()-d])>p) {
			last++;
			if(!q.empty() && q.front()-d+1<last) q.pop_front();
		} ans=max(ans,i-last+1);
	} printf("%d\n",ans);
	return 0;
}


```

---

## 作者：SamariumPhosphide (赞：0)

好玩的题目。

这道题目我们可以换一个顺序，我们先选一个区间，然后在这个区间里面选一个长度为 $d$ 的序列改为 $0$。如果可以通过这种操作改为合法序列的 $[l, r]$，我们称之为“可行的”。

那么对于每个 $r$，可以找到一个**最小的** $l$，使得 $[l,r]$ 是“可行的”，那么显然，随着 $r$ 单调上升，$l$ 单调不降。

那么我们首先预处理出 $w$ 的前缀和 $s$，那么 $[l,r]$ 可行当且仅当 $s[r] - s[l-1] - \max\limits_{i=l+d-1}^r(s[i] - s[i-d]) \leq p$。

显然 $\max$ 里面的东西我们可以用单调队列进行维护。

然后对于每个 $r$ 把 $l$ 不断向上枚举即可，注意一个细节。

```cpp
for (int l = 1, r = d; r <= n; r++) {
  while (head < tail && suff(q[tail - 1]) < suff(r)) tail--;
  q[tail++] = r;
  while (s[r] - s[l - 1] - suff(q[head]) > p) {
    l++;
    while (head < tail && q[head] < l + d - 1) head++;
  }
  ans = std::max(ans, r - l + 1);
}
```

在此处在 `l++` 之后，注意，此处左端点处可能有一些区间超出了 $[l,r]$ 的范围，也就是右端点 $< l+d-1$ 了，注意要删除。

[Code](https://www.luogu.com.cn/paste/teqefi2m)

---

## 作者：学委 (赞：0)

右端点向右拓展后，左端点不可能向左。所以只要单调队列维护最大的能减去的区间，就可以对每个右端点求出最优解。

```cpp
#include <cstdio>
#include <cctype>
typedef long long LL; const int N = 2e6 + 10;
void maxup(int& h, int g) { if (h < g) h = g; }
char ibuf[1 << 23], *is = ibuf, *it = ibuf;
inline char getc() { if (is == it)
   it = (is = ibuf) + fread(ibuf, 1, 1 << 23, stdin);
  return is == it ? EOF : *is++;
} inline LL getint() { LL res = 0, ch = getc();
 while (not isdigit(ch) and ch != EOF) ch = getc();
 while (isdigit(ch)) res = res * 10 + ch - 48, ch = getc();
 return res; } int n, d; LL p, w[N], sum[N];
int q[N], head = 1, tail = 0;
LL calc(int x) { return sum[x] - sum[x - d]; }
signed main() {
  n = getint(), p = getint(), d = getint();
  for (int i = 1; i <= n; ++i) w[i] = getint(), sum[i] = sum[i - 1] + w[i];
  q[++tail] = d; int l = 1, ans = d;
  for (int i = d + 1; i <= n; ++i) {
    while (head <= tail and calc(i) >= calc(q[tail])) --tail;
    q[++tail] = i;
    while (sum[i] - sum[l - 1] - calc(q[head]) > p) {
      ++l; while (q[head] - d + 1 < l) ++head;
    }
    maxup(ans, i - l + 1);
  }
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：QMQMQM4 (赞：0)

# 题解 P3594

### 题意

给定一个区间，可以有d的长度把区间内的数字变为零，但只能用一次，求和不超过p的最大区间长度

### 算法

考虑这样一个问题，题目中说是小于等于d，但是按照贪心，我们每次修改d的长度是不会更差的，因为是序列是正整数。

碰到序列求和问题先维护前缀和，于是就有了大体思路，枚举区间长度，再在区间里寻找一个点$i$，使得这次改动收益最大，注意题中$n<=2000000$，需要线性算法，不难想到$twopointers$(不知道的可以先做下逛画展那道题）

然后就变成了在一个区间中寻找$sum[i]-sum[i-d]$的最大值，类似滑动窗口问题，用单调队列。

注释见代码

```
#include<cstdio>
#include<iostream>
using namespace std;

typedef long long ll;
const int maxn = 2e6+5;
ll q[maxn],sum[maxn],a[maxn],n,p,d,l,head,tail,ans;
//head，tail维护单调队列
//l，r是two pointers中两个指针，以r做循环变量
//q[]代表单调队列的元素对应编号，也可用dequeue来写
int main()
{
	scanf("%lld%lld%lld",&n,&p,&d);
	for(int i = 1;i<=n;++i)
		scanf("%lld",&a[i]),sum[i] += sum[i-1]+a[i];
	//初始化
   ans = d;
	tail = 0;
	l = 1;
	q[tail] = d;
	head = 1;
	for(int r = d+1;r<=n;++r)
	{
		while(head<=tail&&sum[r]-sum[r-d]>sum[q[tail]]-sum[q[tail]-d])
			tail--;
		q[++tail] = r;
      //维护单调队列
		while(head<=tail&&sum[r]-sum[l-1]-sum[q[head]]+sum[q[head]-d]>p)
		{
			l++;
        //维护双指针
			while(head<=tail&&q[head]-d+1<l)
				head ++;
		}
		ans = max(ans,r-l+1);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Xiefan_Guo (赞：0)

首先发现答案是**单调不降的**。即选择每一个位置 $i$ 作为右端点能形成的最长区间的**左端点是单调不降的**。将 $i-1$ 这个位置作为结尾形成的最长区间的左端点不可能比 $i$ 作为结尾形成的最长区间的左端点更靠右

$sum[]$ 为数列前缀和。 $start$ 为起始左端点。如果 $sum[i]-sum[start-1]$ 即这段**区间的和**减去这个区间内所有**长度为 $d$ 的区间和的最大值**超过 $p$ ，那么我们就让 $start++$ ，直到满足条件为止。

```c
#include<bits/stdc++.h>

using namespace std;

const int maxn = 2000005;
int n, d, l, r, start, ans;
int que[maxn];
long long p, a[maxn], sum[maxn], ad[maxn];

int solve()
{
    l = r = 1;
    start = 1;
    for(int i = d; i <= n; i++){
        ad[i] = sum[i] - sum[i - d];
    }
    int ret = d;
    que[r++] = d;
    for(int i = d + 1; i <= n; i++){
        while(l < r && ad[i] > ad[que[r - 1]]) r--;
        que[r++] = i;
        while(l < r && sum[i] - sum[start - 1] - ad[que[l]] > p){
            start++;
            while(l < r && que[l] - d + 1 < start) l++;
        }
        ret = max(ret, i - start + 1);
    }
    return ret;
}
int main()
{
    scanf("%d%lld%d", &n, &p, &d);
    for(int i = 1; i <= n; i++){
        scanf("%lld", &a[i]);
        sum[i] = sum[i - 1] + a[i];
    }
    ans = solve();
    printf("%d\n", ans);
    return 0;
}
```

---


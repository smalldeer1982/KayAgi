# 将军令

## 题目背景


> 历史/落在/赢家/之手  
> 至少/我们/拥有/传说  
> 谁说/败者/无法/不朽  
> 拳头/只能/让人/低头  
> 念头/却能/让人/抬头  
> 抬头/去看/去爱/去追  
> 你心中的梦

## 题目描述

又想起了四月。

如果不是省选，大家大概不会这么轻易地分道扬镳吧？  只见一个又一个昔日的队友离开了机房。

凭君莫话封侯事，一将功成万骨枯。


 
梦里，小 F 成了一个给将军送密信的信使。

现在，有两封关乎国家生死的密信需要送到前线大将军帐下，路途凶险，时间紧迫。小 F 不因为自己的祸福而避趋之，勇敢地承担了这个任务。

不过，小 F 实在是太粗心了，他一不小心把两封密信中的一封给弄掉了。

小 F 偷偷打开了剩下的那封密信。他 发现一副十分详细的地图，以及几句批文——原来 这是战场周围的情报地图。他仔细看后发现，在这张地图上标记了 n 个从 1 到 n 标号的 驿站，n − 1 条长度为 1 里的小道，每条小道双向连接两个不同的驿站，并且驿站之间可以 通过小道两两可达。

小 F 仔细辨认着上面的批注，突然明白了丢失的信的内容了。原来，每个驿站都可以驻 扎一个小队，每个小队可以控制距离不超过 k 里的驿站。如果有驿站没被控制，就容易产 生危险——因此这种情况应该完全避免。而那封丢失的密信里，就装着朝廷数学重臣留下的 精妙的排布方案，也就是用了最少的小队来控制所有驿站。

小 F 知道，如果能计算出最优方案的话，也许他就能够将功赎过，免于死罪。他找到了 你，你能帮帮他吗？  当然，小 F 在等待你的支援的过程中，也许已经从图上观察出了一些可能会比较有用的 性质，他会通过一种特殊的方式告诉你。


## 说明/提示

【样例 1 说明】

如图。由于一号节点到周围的点距离均是 1，因此可以控制所有驿站。

【样例 2 说明】

如图，和样例 1 类似。



 ![](https://cdn.luogu.com.cn/upload/pic/9813.png) 

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

关于 t 的含义如下： t = 0：该测试点没有额外的特殊性质；  t = 1：保证最多 8 个点的所连接的小道超过 1 条； t = 2：保证所有点到 1 号点的距离不超过 2。


每个测试点的数据规模及特点如下表

![](https://cdn.luogu.com.cn/upload/pic/9812.png)


## 样例 #1

### 输入

```
4 1 0 
1 2 
1 3 
1 4```

### 输出

```
1 
 ```

## 样例 #2

### 输入

```
6 1 0 
1 2 
1 3 
1 4 
4 5 
4 6```

### 输出

```
2 
```

# 题解

## 作者：csyakuoi (赞：25)

此题有$O(n)$做法。

把驿站看做节点，则整张图就是一颗树，假设$1$号节点为根节点。

令$f(x)$表示编号为$x$的节点与以其为根节点的子树中最近一个未被控制的节点的距离$+k$，如果没有这样的节点，则$f(x)$表示编号为$x$的节点与以其为根节点的子树中最近一个驻有军队的节点的距离。

这意味着当$f(x)>k$时，在以$x$为根节点的子树中，存在不被控制当节点。$f(x)>2k$时，节点$x$必须驻扎军队。于是，我们可以求出每一个节点的$f(x)$值，从而贪心求出最优方案下需要的军队数量。

核心代码：

```cpp
int dfs(int node)
{
	vis[node]=1;
	int res1=-1,temp=-1;
	int res2=99999999;		res1表示最大值，res2表示最小值。
	for(int i=first[node];i!=-1;i=next[i]){
		if(vis[to[i]]==1)
			continue;
		temp=dfs(to[i]);
		遍历子节点，求最大最小值。
		if(res1<temp)
			res1=temp;
		if(res2>temp)
			res2=temp;
	}
	if(res1==2*k||(node==1&&res1+res2>=2*k)){
		ans++;
		return 0;		如果不驻扎军队，则有节点控制不到。
	}
    if(temp==-1)
		return k+1;		该节点是叶子节点。
	if(res1+res2<2*k)
		return res2+1;
	return res1+1;
	在这里计算f(x)值，并返回。
    具体的计算方法请读者自己思考。
    f(x)的意义比较难理解，即使理解了，写起来也很容易出错。
    在考场上遇到这种题还是不要尝试O(n)算法。
    毕竟O(nk)算法也能过。
}
```

---

## 作者：Accoty_AM (赞：24)

~~大佬们是不是想难了。。这道题是考试20分钟打的，当时我还想，是不是想简单了~~

做这道题后建议做这道 [P3523 [POI2011]DYN-Dynamite](https://www.luogu.org/problem/P3523)

### 贪心做法

我们每个节点记录两个值，f[x][0] 表示x到最近控制驿站的距离，f[x][1]表示x到最远没被控制点的距离

当f[x][0]+f[x][1]<=k时说明这个点能被控制，不能对上面的点贡献

当f[x][1]=k时，点x必须被控制，把f[x][0]改成0,f[x][1]改成-1,++ans,因为这时已经到达能控制点的最远距离，如果再向上，x就无法被控制，树上两点间的路径是唯一的

特判根节点是否能被控制，不能则++ans;

细节：稍微模拟可知统计答案时，f[x][0]和f[x][1]只有一个有用，当f[x][0]不能控制f[X][1]时，f[x][0]就失去作用了

### 贪心思路证明：
考虑被控制节点x，如果x可以向上移动一，并且仍然能控制x移动前能控制的点，就把x向上移动，显然，这样做是不会使答案变差的。

我们不知道x向上移动后能控制多少点，但显然，x有可能控制更多的点，这时把x移动到不能移动为止，x就成为了最优答案。

code 150ms ~~开O(2)变慢了，不造为啥~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cmath>
using namespace std;
namespace OI{
	#define rg register
	template<class T>
	inline void read(T &x){
		x=0;
		static char ch;
		static int f;
		ch=getchar();
		f=0;
		while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
		while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
		x=f?-x:x;
	}
	const int N=200010;
	int head[N],nxt[N<<1],ver[N<<1],tot;
	int n,k,t,ans;
	//0 最近被控制点
	//1 最远没控制点
	int f[N][2];
	inline void add(int x,int y){
		ver[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
	const int inf=0x3f3f3f3f;
	void dfs(int x,int fa){
		f[x][0]=inf;//初始
		f[x][1]=0;
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
			if(y==fa) continue;
			dfs(y,x);
			if(~f[y][1]) f[x][1]=max(f[x][1],f[y][1]+1);//这里如果下面的点被控制，就不考虑（因为如过继续考虑会多算贡献）
			f[x][0]=min(f[x][0],f[y][0]+1);
		}
		if(f[x][1]==k){//加控制点
			++ans;
			f[x][0]=0;
			f[x][1]=-1;
		}
		if(f[x][1]+f[x][0]<=k) f[x][1]=-1;//被控制标记
	}
	void main(){
		read(n),read(k),read(t);
		for(int x,y,i=1;i<n;++i){
			read(x),read(y);
			add(x,y);
			add(y,x);
		}
		dfs(1,0);
		if(~f[1][1]) ++ans;//特判根节点
		cout<<ans<<endl;
	}
}
int main(){OI::main();return 0;}	
```
~~希望能过QAQ~~




---

## 作者：fstqwq (赞：18)

这里提供的是 std。

如果需要题解，请参考 [ppt](https://www.luogu.org/discuss/show?postid=26609)，或者其他同学的题解。


```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 100005

struct edge {
    int next, to;
} e[MAXN * 2];

int head[MAXN], ecnt = 0;

void add(int u, int v) {
    e[++ecnt] = (edge) {head[u], v}; head[u] = ecnt;
    e[++ecnt] = (edge) {head[v], u}; head[v] = ecnt;
}

int n, K, t, ans = 0;
int q[MAXN], fa[MAXN], f[MAXN];

void bfs() {
    int he = 1, ta = 2;
    q[he] = 1; fa[1] = 1;
    while (he < ta) {
        int x = q[he++];
        for (int o = head[x]; o; o = e[o].next) {
            if (!fa[e[o].to]) {
                fa[e[o].to] = x;
                q[ta++] = e[o].to;
            }
        }
    }
}

void update(int x) {
    if (!f[x]) return;
    for (int o = head[x]; o; o = e[o].next) {
        if (f[e[o].to] < f[x] - 1) {
            f[e[o].to] = f[x] - 1;
            update(e[o].to);
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &K, &t);
    for (int i = 1, u, v; i < n; i++) {
        scanf("%d%d", &u, &v);
        add(u, v);
    }
    bfs();
    memset(f, -1, sizeof f);
    for (int i = n; i; i--) {
        if (f[q[i]] == -1) {
            ans++;
            int j = q[i];
            for (int k = K; k; k--) j = fa[j];
            f[j] = K;
            update(j);
        }
    }
    printf("%d\n", ans);
}
```

---

## 作者：hytree (赞：11)

## 看到题解区似乎都没有我这样思路的DP,就来提一下我的DP做法  

### 思路分析:

题意让我们求最小的覆盖点数,又由于我最近树形DP做的有点多,就有了这个优美的DP.    

**约定：**  

我们令$f_i$为$i$的子树中最远的未被覆盖的点到$i$的距离。  

$g_i$ 为$i$的子树中被选择建立小队的驿站到$i$的最远距离.  

$END.$    

**情况与讨论:**  

那么我们的搜索过程就有了以下3种情况来更新我们的$f$与$g$数组.  

$1.$当$g_u > k $时,我们之前选的小队就覆盖不到当前点了,那么我们的 $f_u$就还要计算自己的贡献,即 $f_u=\max(0,f_u);$  

$2.$当$f_u + g_u \leqslant k$ 时,我们先前选的驿站就能覆盖到$u$中最远的点,此时$u$中就没有点未被覆盖了,就令 $f_u = -INF$.  

3.当$f_u == k$的时候 $f_u$必须覆盖,就令 $f_u = -INF$,同时更新$g$数组,令 $g_u = 0$,同时把我们用于统计答案个数的$ans++$.  

**实现方式:**  

我们可以直接通过$DFS$的方式求解$ans$,输出即可.

### Code:

$Talk\ is\ cheap,\ show\ you\ the\ code.$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define INF 0x3fffffff
int ans,n,k,t,kx,ky,cnt=1,h[100010],f[100010],g[100010];
struct STAR{int v,nxt;}e[200010];
void add(int u,int v){e[++cnt]=(STAR){v,h[u]};h[u]=cnt;}
void DFS(int u,int fa)
{
	f[u]=-INF;g[u]=INF;
	for(int i=h[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa)continue;
		DFS(v,u);
		f[u]=max(f[u],f[v]+1);
		g[u]=min(g[u],g[v]+1);
	}
	if(g[u]>k) f[u]=max(0,f[u]);
	if(f[u]+g[u]<=k) f[u]=-INF;
	if(f[u]==k) f[u]=-INF,g[u]=0,ans++;
}
int main()
{
	cin>>n>>k>>t;
	for(re int i=1;i<n;++i) 
	scanf("%d%d",&kx,&ky),add(kx,ky),add(ky,kx);
	DFS(1,0); if(f[1]>=0) ans++;
	cout<<ans;
	return 0;
}
```
### 后话:
做完这道题后就可以尝试用这种想法去写[另一道题](https://www.luogu.com.cn/problem/P3523).

---

## 作者：roufaen (赞：10)

怎么？似乎大家都是用贪心做的？发一篇动态规划的题解吧。

dp[u][i]表示节点u控制范围为状态i时最少驻扎小队数，其中：

i>0表示u可以控制上方i个节点；

i=0表示u恰好控制自己；

i<0表示u等待上方节点控制其下方i层的节点（包括自己）；

但是由于数组下标不能为负，因此把所有数组下标的值都加上k就可以了。

时间复杂度 _O(nk)_ ，虽然不如贪心好写，但是想不到贪心的时候也不失为一种选择。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200000+10
#define MAXK 40+10

int n, k, t, dp[MAXN][MAXK];
int head[MAXN], adj[MAXN], next[MAXN], tot=0;

void Init(){
	memset(head, -1, sizeof(head));
	memset(adj, -1, sizeof(adj));
	memset(next, -1, sizeof(next));
	memset(dp, 1, sizeof(dp));
}

void Addedge(int u, int v) {adj[++tot]=v, next[tot]=head[u], head[u]=tot;}

void Input(){
	Init();
	scanf("%d%d%d", &n, &k, &t);
	for(int i=1, u, v; i<n; i++)
		scanf("%d%d", &u, &v),
		Addedge(u, v), Addedge(v, u);
}

void Work(int u, int fa){
	int sum[MAXK], flag=0;  memset(sum, 0, sizeof(sum));
	for(int tmp=head[u]; tmp!=-1; tmp=next[tmp])
		if(adj[tmp]!=fa){
			Work(adj[tmp], u), flag=1;
			for(int i=-k; i<=0; i++)  sum[i+k]+=dp[adj[tmp]][i+k];
		}
	if(!flag){//如果该节点是叶子节点，则直接进行赋值 
		for(int i=-k; i<0; i++)  dp[u][i+k]=0;
		for(int i=0; i<=k; i++)  dp[u][i+k]=1;
		return;
	}
	for(int tmp=head[u]; tmp!=-1; tmp=next[tmp])//从该节点向上控制的情况（该节点不驻扎小队） 
		if(adj[tmp]!=fa)
			for(int i=0; i<k; i++)
				dp[u][i+k]=min(dp[u][i+k], sum[-i+k]-dp[adj[tmp]][-i+k]+dp[adj[tmp]][i+k+1]);
	//等待上方节点控制的情况 
	for(int i=-k; i<0; i++)  dp[u][i+k]=sum[i+k+1];
	//该节点驻扎小队的情况 
	dp[u][k+k]=sum[-k+k]+1;
	//有时控制区域广的方案驻扎小队数比控制区域窄的方案还要少，因此可以用前一种方案覆盖后一种 
	for(int i=k; i>-k; i--)  dp[u][i+k-1]=min(dp[u][i+k-1], dp[u][i+k]);
}

int main(){
	Input();
	Work(1, 0);
	printf("%d\n", dp[1][0+k]);
	return 0;
}
```

---

## 作者：Anakin (赞：5)

//因为n个点被n-1条边联通，所以肯定是个树，把树建出来，然后bfs找father（顺便把节点按深度排序）

//再用贪心的思想，从深度最深的点开始扫，扫到一个没有被控制的点，计数器++

//并在其控制范围内最远的没有被控制的祖先建立控制点

//用dfs搜到这个建立控制点的点，这样沿途的点也被控制

//扫到根节点后，计数器的值便是最少的小队数

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
#define MAXN 100000+10
using namespace std;
int read(){//读入优化
    int out=0,f=1;
    char c=getchar();
    if(c=='-') f=-1;
    while(c<48||c>57) c=getchar();
    while(c<=57&&c>=48){
        out=(out<<1)+(out<<3)+c-48;
        c=getchar();
    }
    return out*f;
}
void write(int x){//输出优化
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int n,k,t,ans;
int dis[MAXN],father[MAXN],deep[MAXN];
queue<int>q;
struct Node{int v,w;};
vector<Node> node[MAXN];
bool vis[MAXN],vis1[MAXN];//vis1用来记录该点是否被控制
int que[MAXN];//记录各点按深度排序后的顺序
void BFS(){
    father[1]=1;
    q.push(1);
    vis[1]=1;
    deep[1]=0;
    int cnt=0;
    que[++cnt]=1;
    while(!q.empty()){
        int u,v;
        u=q.front();
        q.pop();
        for(int i=node[u].size()-1;i>=0;i--){
            v=node[u][i].v;
            if(!vis[v]){
                deep[v]=deep[u]+1;
                father[v]=u;
                q.push(v);
                que[++cnt]=v;//把点按深度顺序存入que数组
                vis[v]=1;
            }
        }
    }
}
void init(){
    memset(vis,0,sizeof(vis));
    memset(vis1,0,sizeof(vis1));
    cin>>n>>k>>t;
    for(int i=1;i<=n-1;i++){
        int u=read();
        int v=read();
        node[u].push_back(Node{v,1});
        node[v].push_back(Node{u,1});
    }
    BFS();
}
void dfs(int u,int dep){
    vis1[u]=1;dis[u]=dep;
    if(!dep) return;
    for(int i=0;i<node[u].size();i++){
        int v=node[u][i].v;
        if(dis[v]<dis[u]-1||!vis1[v]) dfs(v,dep-1);
    }
}
void solve(){
    int ans=0;
    for(int i=n;i>=1;i--){
        int v=que[i];
        if(!vis1[v]){
            ans++;
            for(int j=k;j>=1;j--) v=father[v];
            dis[v]=k;
            dfs(v,k);
        }
    }
    write(ans);
}
int main(){
    init();
    solve();
    return 0;
}

```

---

## 作者：Varuxn (赞：2)

# 解体思路
## 暴力
对于本题的暴力，直接 DFS 就好，但是考试的时候一开始想的是在树上直接进行的 DFS ，然后发现深度搜索好像压根就不行。。。

于是我们用将近 1h 换来了几乎 0pts ，然后考虑更改 DFS 思路。

想到一个比较妙的方法，我们不是在树上进行 DFS ，而是对于**可以覆盖到的驿站，以及有小队的驿站的数量**进行深搜，然后对于每一个没有过小队的点进行尝试。

* 注意：一定要在加小队的同时，扩散可以覆盖到的驿站，并及时进行回溯，不然就会 5pts ( [code ](https://www.luogu.com.cn/paste/o3t5v7i0))。

然后我们考虑特殊性质，发现对于所有节点到 1 距离不超过 2 的情况我们直接在 1 节点加入小队，在有子节点的深度为 1 的节点处加小队就好了。

暴力+特殊性质共计 50pts 。

当然，如果你打过小胖守皇宫这个题的话，对于 k=1 的情况也是 50pts （反正我是一点都不记得了。。）。

## 正解
与[消防局的设立](https://www.luogu.com.cn/problem/P2279)有**亿些**相似。

正解是**贪心**，首先对于深度从大到小排序，用 dis 数组记录距离这个点最近的有小队的驿站的数量。

如果一个点的 dis 大于 k ，那么我们直接在他的第 k 级祖先加入小队，然后更新深度更小的节点的 dis 值就好了。

最后统计一下 dis 为 0 的节点数就是答案了。

# code
## 暴力 code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,M=N<<1,INF=1e9;
int n,m,ans=INF,task,dep[N],f[N][20];
vector<int> v[N];
bool vis[N],vis1[N];
struct Edge
{
	int tot,head[N],nxt[M],ver[M];
	void add(int x,int y)
	{
		ver[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
}e;
void check()
{
	freopen("date.in","r",stdin);
//	freopen("date.out","w",stdout);
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	for(int i=0;f[x][i];i++)
		f[x][i+1]=f[f[x][i]][i];
	for(int i=e.head[x];i;i=e.nxt[i])
		if(e.ver[i]!=fa)
			dfs(e.ver[i],x);
}
int LCA(int x,int y)
{
	if(x==y)
		return x;
	if(dep[x]>dep[y])
		x^=y^=x^=y;
	for(int i=20;i>=0;i--)
		if(dep[f[y][i]]>=dep[x])
			y=f[y][i];
	if(x==y)
		return x;
	for(int i=20;i>=0;i--)
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	return f[x][0];
}
int dist(int x,int y)
{
	return dep[x]+dep[y]-2*dep[LCA(x,y)];
}
void dfs1(int tot,int cnt)
{
	if(cnt>n)
		return ;
	if(tot>=n)
	{
		ans=min(ans,cnt);
		return ;
	}
	if(cnt>=ans)
		return ;
	vector<int > vi;
	for(int i=1;i<=n;i++)
	{
		if(vis[i])
			continue;
		bool temp=vis1[i];
		vis[i]=vis1[i]=true;
		vi.clear();
		for(int j=1;j<=n;j++)
		{
			if(vis1[j])
				continue;
			for(int k=0;k<v[j].size();k++)
				if(vis[v[j][k]])
				{
					vis1[j]=true;
					tot++;
					vi.push_back(j);
					break;
				}
		}
		dfs1(tot+(!temp),cnt+1);
		tot-=vi.size();
		vis[i]=false;
		vis1[i]=temp;
		for(int j=0;j<vi.size();j++)
			vis1[vi[j]]=false;
	}
}
void solve_1()
{
	dfs(1ll,0ll);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			int dis=dist(i,j);
			if(dis<=m)
			{
				v[i].push_back(j);
				v[j].push_back(i);
			}
		}
	dfs1(0ll,0ll);
}
void solve_2()
{
//	/*
	dfs(1,0);
	int flag=0;
	int sum=0;
	for(int i=2;i<=n;i++)
		if(dep[i]==2&&e.nxt[e.head[i]])
			sum++;
	ans=sum+1;
//	*/
//	ans=2;
}
#undef int 
int main()
{
	#define int register long long
	#define ll long long
	scanf("%lld%lld%lld",&n,&m,&task);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		e.add(x,y);
		e.add(y,x);
	}
	if(!m)	ans=n;
	else if(task!=2)	solve_1();
	else	solve_2();
	printf("%lld",ans);
    return 0;
}
```
## 正解 code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,M=N<<1,INF=1e9;
int n,m,ans,task,id[N],dep[N],fa[N],dis[N],f[N];
struct Edge
{
	int tot,head[N],nxt[M],ver[M];
	void add(int x,int y)
	{
		ver[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
}e;
void dfs(int x,int fat)
{
	dep[x]=dep[fat]+1;
	fa[x]=fat;
	for(int i=e.head[x];i;i=e.nxt[i])
		if(e.ver[i]!=fat)
			dfs(e.ver[i],x);
}
bool comp(int x,int y)
{
	return dep[x]>dep[y];
}
#undef int 
int main()
{
	#define int register long long
	#define ll long long
	scanf("%lld%lld%lld",&n,&m,&task);
	fill(dis+0,dis+n+1,INF);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		e.add(x,y);
		e.add(y,x);
	}
	for(int i=1;i<=n;i++)
		id[i]=i;
	dfs(1ll,0ll);
	sort(id+1,id+n+1,comp);
	for(int i=1;i<=n;i++)
	{
		int cnt=0,x=id[i];
		if(dis[x]<=m)
			continue;
		f[0]=x;
		while(cnt<m&&f[cnt])
		{
			f[cnt+1]=fa[f[cnt]];
			cnt++;
			if(f[cnt])
				dis[x]=min(dis[x],dis[f[cnt]]+cnt);
		}
		if(!f[cnt])
			cnt=max(cnt-1,0ll);
		if(dis[x]>m)
		{
			dis[f[cnt]]=0;
			int fat=f[cnt],sum=0;
			while(fat&&sum<=m)
			{
				dis[fat]=min(dis[fat],sum);
				fat=fa[fat];
				sum++;
			}
		}
	}
	for(int i=1;i<=n;i++)
		if(!dis[i])
			ans++;
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：Ryan_ (赞：2)

看各位大佬的题解都好长啊，蒟蒻瑟瑟发抖

# 思路：分治，贪心

首先，每个叶子节点都要被至少一个小队控制，

则贪心地放置小队，

放置之后没被覆盖的点跟属于控制范围的点无关，

又属于新的“叶子”，继续递归。

如何贪心地放置？

对于每一个点，我们求出离它最远的没被覆盖的点,

若距离超过k-它离最近的小队的距离,

则必定放置小队，

并把离它距离小于等于k的父亲标记，值为离它距离。

双倍经验[消防局的设立](https://www.luogu.org/problem/P2279)

消防局的设立解法的推广[我的博客](https://www.luogu.org/blog/larryzero/ban-jing-wei-k-di-zui-xiao-fu-gai-wen-ti)

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int N=200005;
int first[N],nxt[N],go[N],tot,n,k,t,rep[N],sum[N],ans;
void add(int x,int y) {
	nxt[++tot]=first[x];
	first[x]=tot;
	go[tot]=y;
}
void dfs(int u,int fa) {
	for(int i=first[u]; i; i=nxt[i]) {
		int v=go[i];
		if(v==fa)continue;
		dfs(v,u);
		rep[u]=max(rep[u],rep[v]+1);
		sum[u]=max(sum[u],sum[v]-1);
	}
	rep[u]=max(rep[u],0);
	if(sum[u]>=rep[u])rep[u]=-1;
	if(rep[u]==k) {
		sum[u]=k;
		rep[u]=-1;
		ans++;
	}
}
int main() {
	scanf("%d%d%d",&n,&k,&t);
	memset(rep,-1,sizeof(rep));
	memset(sum,-1,sizeof(sum));
	for(int i=1,u,v; i<n; i++) {
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	if(sum[1]>=rep[1])rep[1]=-1;
	if(rep[1]!=-1)ans++;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：洛桃 (赞：1)

## 贪心
这似乎是经典题，贪心思想简单，只要每次取出当前深度最大的节点，然后判断其是否被覆盖，如果没有，就在它的 $k$ 级祖先处放一个小队。

为什么这么贪是正确的呢？~~我也不知道~~

大概是因为距离当前未覆盖节点的长度小于 $k$ 的节点有很多，但是它们能覆盖到的节点，$k$ 级祖先都能覆盖到，且能覆盖到更多的点，这么贪就行了。

我们可以用 $d[x]$ 来表示其与离它最近的小队的距离，每次用它的 $k$ 个祖先的d数组值更新。

如果更新之后距离仍然大于 $k$ ，说明没有覆盖，那么在 $k$ 级祖先放个小队，并把 $k$ 级祖先的 $k$ 个祖先的d值全部更新一遍即可。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+10;
int n,k,t,a[N],f[30],ans;
int head[N<<1],Next[N<<1],ver[N<<1],tot;
int dep[N],d[N],father[N];
void add(int x,int y)
{
	ver[++tot]=y;Next[tot]=head[x];head[x]=tot;
}
void dfs(int x,int fa)
{
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(y==fa)continue;
		dep[y]=dep[x]+1;
		dfs(y,x);
		father[y]=x;
	}
}
bool cmp(int x,int y)
{
	return dep[x]>dep[y];
}
int main()
{
	scanf("%d%d%d",&n,&k,&t);
	a[1]=1;d[1]=d[0]=N;
	for(int i=2;i<=n;i++)
	{
		a[i]=i;d[i]=N;
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		int v=a[i];
		f[0]=v;
		for(int j=1;j<=k;j++)
		{
			f[j]=father[f[j-1]];
			d[v]=min(d[v],d[f[j]]+j);
		}
		if(d[v]>k)
		{
			d[f[k]]=0;f[0]=f[k];ans++;
			for(int j=1;j<=k;j++)
			{
				f[j]=father[f[j-1]];
				d[f[j]]=min(d[f[j]],j);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```
思路来自P2279第一篇题解

---

## 作者：the_Death (赞：1)

##### 初始数组忘了赋初值，，，我真是个机灵鬼
##### 还有这题是三倍经验P2279&&P2016，这题的代码实现思想来自P2279首个题解
 


------------
[或许更好的阅读体验](https://www.cnblogs.com/fallen-down/p/11577534.html)

------------


### [luogu](https://www.luogu.org/problem/P3942)

### 简化题意
给你一棵树，你有一些可以覆盖范围为$k$的障碍物，问最少放几个障碍物可以使树上所有节点覆盖

### 思想
这题贪心的思路其他题解写的十分清楚。首先，每一次选的点不和之前选的点所覆盖的区间重合，否则不优（这点很显然），所以我们每次可以找到一个最低的点，选取它的第K级祖先来覆盖这个点。$ta$和$ta$的祖先之间就标记为已覆盖

### 代码实现讲解
实现难点在判断该点是否被覆盖，每个点被覆盖的情况有三种

- 被自己的孩子所覆盖
	1. 此时直接在$ta$的孩子建立时就标记
- 被自己的祖先所覆盖
	1. 开一个数组${fa[]}$去记录
- 被自己的兄弟所覆盖
	1. 开一个数组${dis[i]}$表示离$i$最近的障碍物离$i$的距离，当${dis[fa[i]]==k-1}$时，我们就可以确定，$i$肯定就会被覆盖
    
每次在放置完障碍物之后，还要记得更新${dis[]}$的值

顺便一提，这种方法的普适性很强，可以解决半径为k的最小覆盖问题。而且不用存图。只需要把维护“父亲和爷爷”改成维护“上位k位祖先”即可，复杂度O(N*K)，常数也很小。————[BJpers2](https://www.luogu.org/problemnew/solution/P2279)

这题的代码实现就是这句话的延申

### 代码实现
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=1e6+10;
struct ziji{int id,dep;}mn[maxn];
#define id(i) mn[i].id
#define dep(i) mn[i].dep
int n,k,t,fa[maxn],dis[maxn],ans,tot;
int head[maxn],ver[maxn<<1],nxt[maxn<<1];
inline bool cmp(ziji a,ziji b){
    return a.dep>b.dep;
}
inline int g() { register int x=0,f=1;
	register char ch; while(!isdigit(ch=getchar())) f=ch=='-'?-1:f;
	do x=x*10+(ch^48); while(isdigit(ch=getchar())); return x*f;
} 
inline void add(int x,int y){
    ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;
}
inline void dfs(int x,int f){
    dep(x)=dep(f)+1;fa[x]=f;
    for(register int i=head[x];i;i=nxt[i]){
        int y=ver[i];if(y==f) continue;dfs(y,x);
    }
}
int main(){
    n=g(),k=g(),t=g();
    id(1)=1,dis[0]=dis[1]=maxn;
    for(register int i=1;i<=n;i++) id(i)=i;
    memset(dis,0x3f,sizeof(dis));
    for(register int i=2;i<=n;i++){
        int x,y;x=g(),y=g();
        add(x,y),add(y,x);
    }dfs(1,1);
    sort(mn+1,mn+1+n,cmp);
    for(register int i=1;i<=n;i++){
        int x=id(i),y=x;
        for(register int j=1;j<=k;j++)
            y=fa[y],dis[x]=min(dis[x],dis[y]+j);
        if(dis[x]>k){
            dis[y]=0,ans++;
            for(register int j=1;j<=k;j++)
                y=fa[y],dis[y]=min(dis[y],j);
        }
    }
    printf("%d",ans);
}
```


------------
最后国际惯例，thankyou for your attention

---

## 作者：1gnat2 (赞：1)

第一反应是写个$\mathcal{O}(NK)$的DP，然后听说可以直接贪心，想了想发现挺对的。


任选一点作为树根，自底向上地贪心。抽象地说就是不到万不得已时不选。


于是只需要知道每个子树是能向上覆盖，还是需要子树外的被选节点去覆盖。


看了下楼上的题解，其实不太需要真的去覆盖，只需要知道当前节点的所有儿子的子树中，无法被覆盖的最深的节点，或者能够向上覆盖最远的节点。


具体详见代码。


```cpp
#include <cctype>
#include <cstdio>
#include <algorithm>
#define rep(i,x,y) for (int i=x; i<=y; ++i)

int get()
{
    char c;
    while (!isdigit(c=getchar()));
    int k=c-'0';
    for (; isdigit(c=getchar()); k=k*10+c-'0');
    return k;
}

using namespace std;
const int N=1e5+10;
int n,k,ans;
struct edge
{
    int v;
    edge *nxt;
} pool[N*2],*tp=pool,*fst[N];

int dfs(int x,int fa)
{
    int t,mn=0,mx=0;
    for (edge *i=fst[x]; i; i=i->nxt)
        if (i->v!=fa)
            (t=dfs(i->v,x))<0? mn=min(mn,t):mx=max(mx,t);
    if (mx>-mn)
        return mx-1;
    else if (-mn==k || x==1)
        return ++ans,k;
    else
        return mn-1;
}

int main()
{
    n=get(),k=get(),get();
    rep(i,2,n)
    {
        int u=get(),v=get();
        *tp=(edge){v,fst[u]},fst[u]=tp++;
        *tp=(edge){u,fst[v]},fst[v]=tp++;
    }
    dfs(1,0);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：司徒stuart (赞：1)

嗯差不多是个贪心问题

就像楼下大佬说的那样 根节点控制的范围最广 然后就从最边上的结点向根节点找

所以要预先处理一下深度 也就是遍历顺序 具体一些要注意的细节写在代码里了

最后祝大家noip rp++

···

```cpp
#include<queue>
#include<vector>
#include<cstdio>
#include<stack>
#include<cstring>
#include<iostream>
#include<algorithm>
#define MAXN 100010 
using namespace std;
int n,k,t,fa[MAXN];
queue<int > q; 
stack<int > q1;
struct node{
    int id;
};node edge;
int dis[MAXN];
bool exist[MAXN];
bool vis[MAXN];
vector<node > G[MAXN];
void bfs()//预处理结点的顺序  
{
    fa[1]=1;
    q.push(1);
    q1.push(1);
    vis[1]=true;
    while(!q.empty())
    {
        int k=q.front();q.pop();
        for(int i=0;i<G[k].size();i++)
        {
            int v=G[k][i].id;
            if(!vis[v])
            {
                fa[v]=k;
                 q.push(v);
                  q1.push(v);  //我这里的q1是栈！是栈！是栈！！不是队列
                               //比赛的时候脑子一抽写成了队列 然后20
                             //因为要记录遍历顺序并且根据贪心原则 要从叶子节点往根找
                             //所以是后进先出，用栈  （话说用队列居然还有20分 太可怕了）    
                vis[v]=true;          
            }
        }
    }
}
int dfs(int u,int dep)//dfs的作用就是把要设立小队的点 的控制范围内的点标记上 
{
    exist[u]=true;dis[u]=dep;
    if(!dep) return 0;
    for(int i=0;i<G[u].size();i++)
    {
        int dd=G[u][i].id;
        if(dis[dd]<dis[u]-1||!exist[dd]) dfs(dd,dep-1);//要加入判断dis[dd]<dis[u]-1这一条件的原因是
                                                        //与当前点相连的下一个点可能被访问过了
                                                        //举个例子 可能下一个点上次被访问的时候 可控制的范围还剩下1
                                                        //但是本次访问 可控制的距离还剩下2 如果不更新的话 会导致漏点
                                                        //最后导致答案变多 70分就是这么得的 
    }
}
int main()//听说从主程序开始阅读是个好习惯 
{
    int ui,vi;
    cin>>n>>k>>t;
    for(int i=1;i<n;i++)// 存边 用vector存 像我这种蒟蒻完全不会什么链表啊之类的 也看不懂只好用vector了 
    {
        node ddd;
        cin>>vi>>ui;
        ddd.id=ui;
        G[vi].push_back(ddd);
        ddd.id=vi;
        G[ui].push_back(ddd);
    }
    bfs();//预处理一下结点的顺序 
    int ans=0;
    memset(exist,false,sizeof(exist));
    memset(dis,0,sizeof(dis));
    memset(vis,false,sizeof(vis));
    while(!q1.empty())
    {
        int v=q1.top();q1.pop();
        if(!exist[v])//如果当前节点不在控制范围内 
        {
            ans++;//点+1 
            for(int j=k;j>=1;j--)
            {
                v=fa[v];//往上找k个结点 也就是能控制当前节点的最远祖先 
            } 
            dis[v]=k;
            dfs(v,k);
        }
    }
    cout<<ans<<endl;
    return 0;
}
···
```

---

## 作者：Dispwnl (赞：1)

> 11.29 修改了排版

看到题以为是 消防局的设立

其实贪心就能过了

最深的点是最难控制的，把$1$当成树的根节点

先用$bfs$处理出各个点的深度和父节点

从最深的点开始，向上跳$k$次，即到达它的第$k$个祖先

因为这个点只有它自己到它的$k$祖先才能被控制

根据贪心，越靠近根的点控制范围越大

所以选择它的$k$祖先，从$k$祖先$dfs$

$dfs$处理深度为$k$的点，处理出能控制的点并标记

顺便记录深度，除了没遍历的点

如果$deep_{i_{next}}<deep_i-1$ 

则下一个点也要$dfs$，因为可能它遍历时没有遍历彻底

在遍历一遍使它的子节点也完全遍历，这样扩大范围

比如说$x$遍历到它的子节点$y$时，已达到最大遍历深度，而另一个点$z$也能到$y$

而它没到达最大遍历深度，但到了$y$的时候因为$y$已经遍历了，所以不会接着遍历

所以要加上另一个条件

总之就是$bfs$+$dfs$+贪心


代码：
```
# include<iostream>
# include<cstdio>
# include<queue>
# include<cstring>
#define is isdigit(ch)
#define ge getchar()
#define ini inline int
#define inv inline void
using namespace std;
struct p{
    int x,y;
}c[200001];
int n,k,t,num,num1;
int h[100001],deep[100001],rt[100001],q[100001];
bool use[100001],vis[100001];
queue<int> qu;
inv add(int x,int y)
{
    c[++num].x=h[x];
    c[num].y=y;
    h[x]=num;
}
ini read()
{
    int x=0;
    char ch=ge;
    while(!is)
    ch=ge;
    while(is)
    {
        x=x*10+ch-48;
        ch=ge;
    }
    return x;
}
inv bfs()
{
    qu.push(1);
    q[1]=1;
    use[1]=1;
    rt[++num1]=1;
    while(!qu.empty())
    {
        int tt=qu.front();
        qu.pop();
        for(int i=h[tt];i;i=c[i].x)
          if(!use[c[i].y])
          {
              use[c[i].y]=1;
            rt[++num1]=c[i].y;
              q[c[i].y]=tt;
              qu.push(c[i].y);
          }
    }
}
inv dfs(int x,int tot)
{
    vis[x]=1;
    deep[x]=tot;
    if(!tot) return;
    for(int i=h[x];i;i=c[i].x)
      if(!vis[c[i].y]||deep[c[i].y]<deep[x]-1)
      dfs(c[i].y,tot-1);
}
int main()
{
    n=read(),k=read(),t=read();
    for(int i=1;i<n;i++)
      {
          int x=read(),y=read();
          add(x,y);
          add(y,x);
      }
    bfs();
    int ans=0;
    for(int i=n;i>=1;i--)
      if(!vis[rt[i]])
      {
          ans++;
          int kk=rt[i];
          for(int j=k;j>=1;j--)
          kk=q[kk];
        vis[kk]=1;
        deep[kk]=k;
          dfs(kk,k);
      }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：fzwfzwfzw (赞：0)

## 这一道题题意大概就是给你一棵树，

## 然后让你选择最少的军队的情况下

## 能够控制所有的节点。

### 所以，我们来考虑一下如何来做这一道题。

首先我们看到k的范围，在3以内，可以考虑树形dp，但是需要向下拓展

三层，所以代码并不是那么的美观和好写。所以我们从目的开始考虑。

#### 当然，既然要控制所有的节点，那么最深的一个节点也要被控制。


然后呢，我们就将这些节点按照深度进行排序。

从头枚举每一个没有被控制的节点，找到他的第k级父亲，选择控制。

如果想让一个点在没被控制的情况下选择最优的点来控制，那么最好的

选择方法就是找到他的第k级父亲。

下面是毒瘤的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
	int n,m,k;
struct node
{
	int next,to;
}e[200005];
int cnt,h[200005];
void add(int a,int b)
{
	cnt++;
	e[cnt].to=b;
	e[cnt].next=h[a];
	h[a]=cnt;
}
struct cnn
{
	int dep1,x;
}dep[100005];//在这里，分别记录深度和节点。
int f[100005],cmt=1;
void dfs(int x,int fa)//第一次dfs记录深度和父亲
{
	f[x]=fa;
	dep[x].dep1=cmt;
	dep[x].x=x;
	for(int i=h[x];i;i=e[i].next)
	{
		if(e[i].to!=fa)
		{
			cmt++;
			dfs(e[i].to,x);
			cmt--;
		}
	}
}
int vis[100005];
bool cmp(cnn a,cnn b)//按深度排序的cmp
{
	return a.dep1>b.dep1;
}
void bj(int o,int p,int fw)//当选择了点过后dfs进行标记
{
	vis[o]=1;
	if(p==k)
	{
		return ;
	}
	for(int i=h[o];i;i=e[i].next)
	{
		if(e[i].to!=fw)
		bj(e[i].to,p+1,o);
	}
}
int main(){
	n=read();
	k=read();
	m=read();
	if(k==0)//如果只能单独选择一个点控制那么就是所有的点
	{
		cout<<n<<endl;
		return 0;
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		x=read();
		y=read();
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	sort(dep+1,dep+n+1,cmp);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(!vis[dep[i].x])
		{
			ans++;
			int chance=dep[i].x;
			for(int w=1;w<=k;w++)
			{
				chance=f[chance];
			}
			bj(chance,0,0);
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
-----------------------------------
分割一下
---------------------------------
好了，这就结束了
## 祝大家csp   
## RP++

---

## 作者：ljk123 (赞：0)

# 将军令题解
首先，每个叶子节点都要被至少一个小队控制，

则贪心地放置小队，

放置之后没被覆盖的点跟属于控制范围的点无关，

又属于新的“叶子”，继续递归。

如何贪心地放置？

对于每一个点，我们求出离它最远的没被覆盖的点,

若距离超过k-它离最近的小队的距离,

则必定放置小队，

并把离它距离小于等于k的父亲标记，值为离它距离。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200006;
int n,t,t1,t2,k,cnt=0,ans=0,f[N],dis[N],head[N];
//f[x]:x的父亲,dis[x]:x到最近的小队的距离
struct edge{int nxt,to;}e[N<<1];
inline void add(int u,int v){e[++cnt].nxt=head[u],e[cnt].to=v,head[u]=cnt;}
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
int dfs(int x){
    int maxa=1;
    for(int i=head[x];i;i=e[i].nxt)
        if(e[i].to!=f[x])
             f[e[i].to]=x,maxa=max(maxa,dfs(e[i].to)+1);
    if(maxa>k){
       if(dis[x]<maxa){
          ++ans,t=x;
          for(int i=k+1;i>=1;--i) dis[t]=max(dis[t],i),t=f[t];
       }
    }
    if(dis[x]&&dis[x]>=maxa) maxa=0;
    if(x==1&&dis[x]<maxa) ++ans;
    return maxa;
}
int main(){
   n=read(),k=read(),t=read();
   for(int i=2;i<=n;++i) t1=read(),t2=read(),add(t1,t2),add(t2,t1);
   dfs(1),printf("%d",ans);
   return 0;
}
```


---

## 作者：hulean (赞：0)

思路楼上楼下都给的很清楚了，这里只是详细解析一下

### 本题算法：贪心+排序+搜索+并查集+图论

输入中的t可以不用管，毕竟这只是特殊情况的标志

题目中虽然没有很明确地说明这是一棵树，但是题目中说有n个点，但是只有n-1条边，想用这n-1条边把整个图连通起来，那么只有可能是棵树。（不信可以自己画画看）

竟然是一棵树了，那么就可以用找到每个节点唯一的父亲、爷爷、曾祖父、曾曾祖父、曾曾曾祖父......（此时可以开个数组记录一下每个节点的父亲）。

接下来，运用到了贪心的思想，因为一个小队能控制的最远距离为k，那么找当前最深的没有被访问过的节点的第k位祖宗所能覆盖的节点数才会更多。

找到了当前节点的第k位祖宗，就以这位祖宗为起点，用BFS向四周扩散k个单位，标记被扩散到的节点为已访问。

如果直接这样写，会出现一个问题

第19个点MLE---95分

究竟是哪出问题了呢？问题出在BFS身上，此时需要一个小小的剪枝技巧：

```
如果当前节点最大扩散出去的单位比现要求扩散的单位还要大的话，此节点就没必要进行扩散了。
```

具体细节详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100000+1;
int fa[MAXN];//记录父亲节点
int n,k,meiyouyong;
vector<int>ver[MAXN];//存图
struct Node
{
	int id;//记录当前节点编号，防止sort时打乱
	int deep;//当前节点的深度
}node[MAXN];
int bin[MAXN];//记录每个节点扩散的最大单位，用于剪枝
struct BFS
{
	int t;//当前遍历到的节点
	int cnt;//扩散cnt个单位
};
bool vis[MAXN];//是否遍历到过
inline int read()
{
	int tot=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		tot=tot*10+c-'0';
		c=getchar();
	}
	return tot;
}
inline void init(int now)//初始化
{
	for(int i=0;i<ver[now].size();i++)
	{
		int x=ver[now][i];
		if(node[x].deep)continue;
		node[x].deep=node[now].deep+1;//深度比父亲深1个单位
		node[x].id=x;
		fa[x]=now;
		init(x);
	}
}
inline int find(int now)//找到now节点的第k位祖宗
{
	int tot=now;
	for(int i=1;i<=k;i++)
	{
		tot=fa[tot];
	}
	return tot;
}
inline bool cmp(Node u,Node v)
{
	return u.deep>v.deep;
}
inline void bfs(int x)
{
    queue<BFS>q;
    q.push((BFS){x,k});
    vis[x]=1;
    while(q.size())
    {
        BFS now=q.front();
        if(now.cnt==0)break;//扩散结束
        q.pop();
        for(int i=0;i<ver[now.t].size();i++)
        {
            int x=ver[now.t][i];
            if(now.cnt<=bin[x])continue;//剪枝技巧
            bin[x]=now.cnt;//更新最大值
            vis[x]=1;//标记
            q.push((BFS){x,now.cnt-1});
        }
    }
}
int main()
{
	int x,y;
	n=read();k=read();meiyouyong=read();
	node[1].deep=1;
	fa[1]=1;
	node[1].id=1;
	for(int i=2;i<=n;i++)
	{
		x=read();y=read();
		ver[x].push_back(y);
		ver[y].push_back(x);
	}
	init(1);
	sort(node+1,node+1+n,cmp);
	/*for(int i=1;i<=n;i++)cout<<fa[i]<<" ";
	cout<<endl;*/
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(vis[node[i].id])continue;
        //若此节点已被遍历过，那么就没必要在去找一遍了
		int grand=find(node[i].id);
		//cout<<grand<<endl;
		bfs(grand);
		ans++;
		//cout<<i<<endl;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：猫粮寸断 (赞：0)

比赛的时候就想到了正解思路，但是一点小细节没有处理好，只有70（主要是懒得打对拍。。。）

首先用动态数组存下这棵树，以1号点为根节点构造有根树并求出每个节点的深度，将深度由大到小排序

此处运用一点贪心思想，最深的点一定是最难覆盖的，所以我们优先选取刚好能控制最深点的点，于是很容易就可以想到剪枝，如果一个点已被控制，下一次就跳过它

**但是！！！**

这是不对滴（我的30分就是这么丢的）

可以想到，我们走到每一个点时，都会有一个从这个点可以控制的剩余距离，假如这个剩余距离比以前的要大，应该再对其进行一次更新（直接跑两倍距离的没有这个问题，但和我一样先找父节点的可能会被卡）

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int f[100010],shen[100010],kong[100010];
vector<int> q[100010];

struct node{
    int ceng,num;
}p[100010];

int cmp(const node&x,const node&y)
{
    return x.ceng>y.ceng;
}

void kuo(int v,int ci)
{
    if(ci==0)
     return ;
    int d=q[v].size();
    for(int i=0;i<d;i++)
    {
        int u=q[v][i];
        if(kong[u]<ci)  //就是这个地方！！！
         {
             kong[u]=ci;
             kuo(u,ci-1);
         }
    }
}
void dfs(int v,int fa)
{
    int d=q[v].size();
    for(int i=0;i<d;i++)
    {
        int u=q[v][i];
        if(u!=fa)
        {
            shen[u]=shen[v]+1;
            f[u]=v;
            dfs(u,v);
        }
    }
}
int main()
{
    int n,k,t,i,a,b,j,sum=0;
    scanf("%d%d%d",&n,&k,&t);
    for(i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        q[a].push_back(b);
        q[b].push_back(a);
    }
    for(i=1;i<=n;i++)
     f[i]=i;
    shen[1]=1;
    dfs(1,-1);
    for(i=1;i<=n;i++)
     {
         p[i].ceng=shen[i];
         p[i].num=i;
     } 
    sort(p+1,p+n+1,cmp);
    for(i=1;i<=n;i++)
    {
        
        a=p[i].num;
        if(kong[a])
         continue;
        j=0;
        while(f[a]!=a&&j<k)
        {
            j++;
            a=f[a];
        }
        if(j==k)
         {
             kong[a]=k; 
             kuo(a,k);
             sum++;
         }
         else
         {
             sum++;
             break;
         }
    }
    printf("%d",sum);
    return 0;
}
```

---


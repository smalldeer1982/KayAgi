# 多边形染色

## 题目背景

Flokirie有一个美丽的凸n边形，顶点编号为1~n，每条边长都不相等。

他想把每个顶点都染成1~c中某一颜色，且相邻顶点颜色不能相同。


## 题目描述

他想知道所有可行方案共有多少。于是他在纸上算了算，5分钟就解决了这题。

于是他觉得太low了，便定义了以下骚操作。

① 1 x p：表示第x个顶点必须染颜色p。

② 2 x p：表示第x个顶点必须不染颜色p。

③ 3 x y：表示更改第x个顶点与第y个顶点之间边的属性（保证y=x±1，且x,y≠1,n），第x个顶点必须与第y个顶点颜色相同。

现在，他想知道所有可行的方案共有多少种。由于结果可能过大，你只需输出它对987654321取模的结果即可。


## 说明/提示

所有测试点满足以下约定：

![](https://cdn.luogu.com.cn/upload/pic/11531.png)


## 样例 #1

### 输入

```
3 0 3```

### 输出

```
6```

## 样例 #2

### 输入

```
5 2 5
2 3 4
3 2 3```

### 输出

```
208```

# 题解

## 作者：AmamiyaUmi (赞：13)

咸鱼的blog：[http://www.neptuuz.com/wordpress/?p=237](http://www.neptuuz.com/wordpress/?p=237)

经典的环形dp，枚举开头，对结尾的状态要与开头判断一下是否合法


dp[i][j]表示第i个顶点染颜色j的方案数，可以得到

dp[i][j] = ∑dp[i-1][k] (颜色j可以被染上 && i和i-1被改变边属性时：j=k；否则j != k)

复杂度O(nc^3)


然后这题坑的地方是2操作对于同一顶点有多个，也就是说对于一个顶点可能不能染多种颜色（卡了两个点不然AK了QAQ）

```cpp
#include<stdio.h>
#include<iostream>
#include<string.h>
#define MAXN 50010
#define MOD 987654321
using namespace std;

int n, m, c, uncol[MAXN][15], e[MAXN], dp[MAXN][15], ans;

int main() {
    scanf("%d%d%d", &n, &m, &c);
    for (int i = 1, opt, x, y; i <= m; ++i) {
        scanf("%d%d%d", &opt, &x, &y);
        if (opt == 1) {
            for (int j = 1; j <= c; ++j) {
                if (j != y) uncol[x][j] = 1;
            }
        } else if (opt == 2) {
            uncol[x][y] = 1;
        } else {
            if (x > y) swap(x, y);
            e[y] = x;
        }
    }
    for (int p = 1; p <= c; ++p) {
        if (uncol[1][p]) continue;
        memset(dp, 0, sizeof(dp));
        dp[1][p] = 1;
        for (int i = 2; i < n; ++i) {
            for (int j = 1; j <= c; ++j) {
                if (uncol[i][j]) continue;
                if (e[i]) {
                    dp[i][j] += dp[i-1][j];
                    dp[i][j] %= MOD;
                } else for (int k = 1; k <= c; ++k) {
                    if (j == k) continue;
                    dp[i][j] += dp[i-1][k];
                    dp[i][j] %= MOD;
                }
            }
        }
        for (int i = 1; i <= c; ++i) {
            if (uncol[n][i] || i == p) continue;
            if (e[n]) {
                dp[n][i] += dp[n-1][i];
                dp[n][i] %= MOD;
            } else for (int j = 1; j <= c; ++j) {
                if (i == j) continue;
                dp[n][i] += dp[n-1][j];
                dp[n][i] %= MOD;
            }
        }
        for (int i = 1; i <= c; ++i) {
            ans += dp[n][i];
            ans %= MOD;
        }
    }
    printf("%d\n", ans);
    return 0;
}```

---

## 作者：asuldb (赞：8)

这个$dp$非常无脑，随便优化一下就能变成$O(nc^2)$

我们设$dp[i][j]$表示第$i$个位置染成$j$的方案数

于是如果没有限制则有

$$dp[i][j]=\sum_{k=1}^{c}dp[i-1][k]*[k!=j]$$

后面的那个是逻辑表达式

我们可以考虑直接维护一个$sum$表示$\sum_{k=1}^{c}dp[i-1][k]$，于是我们转移的时候就不用再去一个一个加了，转移$dp[i][j]$可以直接用这个$sum$减去$dp[i-1][j]$

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
#define re register
#define maxn 50005
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
const LL mod=987654321;
std::vector<int> b[maxn];
int f[maxn],a[maxn];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
LL dp[maxn][11];
LL ans=0;
int n,m,c;
int main()
{
	n=read();c=read();m=read();
	int opt,x,y;
	for(re int i=1;i<=c;i++)
	{
		opt=read(),x=read(),y=read();
		if(opt==1)
		{
			if(a[x]&&a[x]!=y) 
			{
				puts("0");
				return 0;
			}
			a[x]=y;
		}
		if(opt==2) 
		{
			if(a[x]&&a[x]==y) 
			{
				puts("0");
				return 0;
			}
			b[x].push_back(y);
		}
		if(opt==3) f[max(x,y)]=1; 
	}
	for(re int T=(a[1]?a[1]:1);T<=(a[1]?a[1]:m);T++)
	{
		if(find(b[1].begin(),b[1].end(),T)!=b[1].end()) continue;
		memset(dp,0,sizeof(dp));
		dp[1][T]=1;
		LL sum=1;
		for(re int i=2;i<=n;i++)
		{
			if(f[i])
			{
				for(re int j=1;j<=m;j++)
					dp[i][j]=dp[i-1][j];
				if(a[i]) 
				{
					for(re int j=1;j<=m;j++)
					if(j!=a[i]) dp[i][j]=0;
				}
				for(re int j=0;j<b[i].size();j++)
					dp[i][b[i][j]]=0;
				sum=0;
				for(re int j=1;j<=m;j++)
					sum=(sum+dp[i][j])%mod;
				continue;
			}
			for(re int j=(a[i]?a[i]:1);j<=(a[i]?a[i]:m);j++)
			{
				if(find(b[i].begin(),b[i].end(),j)!=b[i].end()) continue;
				dp[i][j]=(dp[i][j]+sum-dp[i-1][j]+mod)%mod;
			}
			sum=0;
			for(re int j=(a[i]?a[i]:1);j<=(a[i]?a[i]:m);j++)
			{
				if(find(b[i].begin(),b[i].end(),j)!=b[i].end()) continue;
				sum=(sum+dp[i][j])%mod;
			}
		}
		for(re int j=1;j<=m;j++)
			if(j!=T) ans=(ans+dp[n][j])%mod;
	}
	std::cout<<ans;
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：4)

一道 dp 题。

假设 $f_{i,j}$ 表示第 $i$ 个点染第 $j$ 种颜色的方案数，$col_{i,j}$ 表示第 $i$ 个点能否使用颜色 $j$。

如果要求 $i,i+1$ 颜色相同，得到转移方程：

$$f_{i,j}=f_{i-1,j}\times col_{i,j}$$

如果要求不相同，得到转移方程：

$$f_{i,j}=(sum-f_{i-1,j})\times col_{i,j}$$

这里，$sum=\sum_{k=1}^cf_{i-1,k}$。

得到这些，我们还要考虑第 $n$ 点和第 $1$ 点之间不能相同。于是我们开一个额外点 $n+1$。$col_{n+1,i}=col_{1,i}$。枚举第一个点的颜色，每次答案增加 $f_{n+1,col}$ 即可。

Tip. 注意特判无解。

代码
```cpp
#include<iostream>
using namespace std;
#define ll long long
const int MAXN=5e4+5;
const int MR=11;
const int MOD=987654321;
int n,m,c;//block,CaoZuo Times,color. 
ll f[MAXN][MR];//f[i][j] When i 's block,j color's FangAn.
bool used[MAXN][MR];
bool same[MAXN];//Is same from i-1 and i.
void dp(){
	for(int i=2;i<=n+1;i++)
		if(same[i]){
			for(int j=1;j<=c;j++)
				if(used[i][j])
				f[i][j]=f[i-1][j];
		}
		else{
			ll sum=0;
			for(int j=1;j<=c;j++)
				sum=(sum+f[i-1][j])%MOD;
			for(int j=1;j<=c;j++)
				if(used[i][j])
					f[i][j]=(sum-f[i-1][j]+MOD)%MOD;
		}
	return;
}
int work(){
	ll ans=0;
	for(int i=1;i<=c;i++)
		if(used[1][i]){
			//cout<<"OK";
			for(int j=1;j<=n;j++)
				for(int k=1;k<=c;k++)
					f[j][k]=0;
			f[1][i]=1;
			dp();
			ans=(ans+f[n+1][i])%MOD;
		}
	return ans;
}
int main(){
	cin>>n>>m>>c;
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=c;j++)
			used[i][j]=true;
	for(int i=1;i<=m;i++){
		int opt,x,y;
		cin>>opt>>x>>y;
		if(opt==1){
			if(used[x][y]==false){
				cout<<"0";
				return 0;
			}
			for(int j=1;j<=c;j++)
				used[x][j]=false;
			used[x][y]=true;
		}
		if(opt==2)
			used[x][y]=false;
		if(opt==3)
			same[max(x,y)]=true;
	}
	cout<<work();
	return 0;
}
```


---

## 作者：2021sunzishan (赞：2)

这是一道很好的 dp 题。

## 题目大意：

给定 $n$ 个顶点，呈环状，每个顶点都可以染 $p$ 种颜色 。现给出一些染色限制，求染色的方案有多少种。

## 思路：

这题看似复杂，其实只要想到了就挺简单的。
###### ~~关键是想不到~~。

定义 $f[i][j]$ 表示第 $i$ 个位置染颜色 $j$ 的方案数。

如果没有限制条件，那么 $f[i][j]$ 就应该是：

$f[i][j]=\sum\limits_{k=1}^cf[i-1][k]$

那么加上限制呢？

首先加两个辅助数组，$vis[i][j]$ 代表第 $i$ 个位置能不能染颜色 $j$，$e[i]$ 代表第 $i$ 个位置和第 $e[i]$ 个位置的颜色必须一样。

那么当必须和 $e[i]$ 一样时：

$f[i][j]=f[e[i]][j]$

不能染颜色 $j$ 时：

$f[i][j]+=f[i-1][k]$
且 $k\neq j$

这里要注意，因为是凸多边形上的点，所以是一个环，所以点 $n$ 需要特殊处理一下，要判断和第 $1$ 个点的颜色相不相同。

那么以上就是本题的思路了，具体实现请看代码吧！

### 切勿抄袭！！！

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int vis[50005][15],n,m,f[50005][15],e[50005],c; 
//本代码vis[i][j]=1表示i不能染颜色j，反之亦然 
int ans=0;
inline int read() {//快读 
	int a=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9') {
		if  (c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		a=a*10+(c-'0');
		c=getchar();
	}
	return f*a;
}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),m=read(),c=read();
	int mod=987654321;//这题要取模 
	for (int i=1; i<=m; i++) {
		int k=read();
		int x=read(),y=read();
		if(k==1) {
			for (int j=1; j<=c; j++)
				if(j!=y)vis[x][j]=1;
			//必须是颜色y，所以其他的都不行 
		}
		if(k==2)
			vis[x][y]=1;//不能是颜色y 
		if(k==3) {
			if(x>y)swap(x,y);
			e[y]=x;//这里为了方便，保证x<y 
		}
	}
	for (int l=1; l<=c; l++) {//枚举第一个位置的颜色 
		if(vis[1][l]==1)continue;
		//如果不行，就重来 
		memset(f,0,sizeof(f));
		f[1][l]=1;//否则就初始化成1 
		for (int i=2; i<=n; i++) { 
			for  (int j=1; j<=c; j++) {//枚举第i个位置的颜色 
				if(vis[i][j])continue;//如果不行，就重来 
				if(i==n&&(vis[i][j]||j==l))continue;
				//i==n，特判j和l的关系 
				if (e[i]) {//如果必须染e[i] 
					f[i][j]=f[e[i]][j];
					f[i][j]%=mod;
				} else for (int k=1; k<=c; k++) { //枚举第i-1个位置的颜色 
						if (j==k) continue;//i不能染和第i-1个一样的颜色 
						f[i][j]+=f[i-1][k];
						f[i][j]%=mod;
					}
			}
		}
		for (int i=1;i<=c;i++)
			ans=(ans+f[n][i])%mod;//统计 
	}
	printf("%d\n",ans);//最后输出 
	return 0;
}


```
## 总结：

这道题的思路不好想，本蒟蒻也是看了大佬的题解才懂的……但大佬的题解很难懂 ，所以本蒟蒻写了一篇更容易懂的题解，希望可以看懂！

---

## 作者：Celebrimbor (赞：1)

赛前一发题解，CSP2021 RP++！

## 分析

十分~~板子~~典型的暴力dp，要注意环、三种限制的处理。

1. 处理环：设计状态时，用 $f_{i,c,c_1}$ 表示前 $i$ 个点，$i$ 号点颜色为 $c$，$1$ 号点颜色为 $c_1$ 的方案数，最终统计 $\sum_{c_n \neq c_1}f_{n,c_n,c_1}$ 即为答案。

2. 限制：读入时记录，注意1、2型限制可能互相矛盾。转移时根据点的限制讨论，具体地：
- 若确定某点颜色为 $c_i$，则只需枚举上一个点的颜色，$f_{i,c_i,c_1} = \sum_{c'\neq c_i}f_{i-1,c',c1}$。
- 若确定某点与上一个点同色，体现在转移上就是 $f_{i,c_i,c_1}=f_{i-1,c_i,c_1}$。
- 至于第二种限制，枚举颜色时判断一下即可。

时间复杂度 $O(n\times c^3)$，按照第二篇题解中的做法加个前缀和优化可以做到 $O(n\times c^2)$，当然都能过就是了。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int MAXN = 50005;
const int P = 987654321;
int n, m, c, f[MAXN][11][11], st[MAXN];
bool sm[MAXN], ust[MAXN][11];

int main() {
	scanf("%d %d %d", &n, &m, &c);
	int op, x, y;
	for (int i = 1; i <= m; i++) {
		scanf("%d %d %d", &op, &x, &y);
		if (op==1) {
			if (ust[x][y] || (st[x]!=0&&st[x]!=y)) {
				printf("0\n");
				return 0;
			}
			st[x] = y;
		}
		else if (op==2) {
			ust[x][y] = 1;
			if (st[x] == y) {
				printf("0\n");
				return 0;
			}
		}
		else {
			if (x > y) swap(x, y);
			sm[y] = 1;
		}
	}
	for (int i = 1; i <= c; i++) f[1][i][i] = 1;
	for (int i = 2; i <= n; i++) {
		if (st[i]) {
			if (sm[i]) {
				for (int c1 = 1; c1 <= c; c1++)
					f[i][st[i]][c1] = f[i-1][st[i]][c1];
			}
			else {
				for (int c1 = 1; c1 <= c; c1++)
					for (int _c = 1; _c <= c; _c++)
						if (st[i] != _c)
							f[i][st[i]][c1] = (f[i][st[i]][c1]+f[i-1][_c][c1])%P;
			}
		}
		else {
			if (sm[i]) {
				for (int c1 = 1; c1 <= c; c1++)
					for (int _c = 1; _c <= c; _c++)
						if (!ust[i][_c])
							f[i][_c][c1] = f[i-1][_c][c1];
			}
			else {
				for (int ci = 1; ci <= c; ci++)
					for (int c1 = 1; c1 <= c; c1++)
						for (int _c = 1; _c <= c; _c++)
							if (!ust[i][ci] && ci != _c)
								f[i][ci][c1] = (f[i][ci][c1]+f[i-1][_c][c1])%P;
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= c; i++)
		for (int j = 1; j <= c; j++)
			if (i != j)
				ans = (ans+f[n][i][j])%P;
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：OIer_ACMer (赞：0)

# 题目解析：

本题我们一开始可能会从排列组合来思考，但很快我们就会发现我们似乎行不通，因为，样例都过不了。

所以，我们只能用稍微暴力一点的动态规划下手，由于题目只要求我们相邻顶点颜色不能相同，每个点有 $c$ 种颜色可能。所以，我们设 $dp_{i,j}$ 表示地 $i$ 个点染色是 $j$ 的方案数，根据上面的条件，转移方程便不难推出（要不是加了方程二字说它是暴力我都信）：

$$ans=\sum_{k=1}^c dp_{i-1,k}$$

注意，在求和时我们要保证 $k$ 不等于 $j$，因为相邻顶点颜色不能相同。

剩下的情况，我们分两种讨论。

一种，对于有相邻颜色一样的点，**就可以从上一步的相同颜色转移而来**，同时注意一下是不是有其他两种操作即可。

第二种，若没有相邻颜色限制，则**从有固定颜色的枚举上一个所有不同于固定颜色的颜色转移**；有不能填的颜色的枚举上一个所有颜色特判一下就行。

由于这是一个环形动态规划，我们可以选定一个颜色，进行 $c$ 次动态规划就行了。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mod 987654321
int n, m, c;
// struct node
// {
//     int a, b;
// } yq1[1000009], yq2[1000009], yq3[1000009];
// int syq1, syq2, syq3;
int gl[50010][20];
int ok[1000009];
int dp[50010][20];
int ans = 0;
signed main()
{
    cin >> n >> m >> c;
    for (int i = 1; i <= m; i++)
    {
        int opt, x, y;
        cin >> opt >> x >> y;
        if (opt == 1)
        {
            for (int i = 1; i <= c; i++)
            {
                if (i != y)
                {
                    gl[x][i] = 1;
                }
            }
        }
        else if (opt == 2)
        {
            gl[x][y] = 1;
        }
        else
        {
            if (y > x)
            {
                swap(x, y);
            }
            ok[x] = y;
        }
    }
    for (int p = 1; p <= c; ++p)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= c; j++)
            {
                dp[i][j] = 0;
            }
        }
        dp[1][p] = 1;
        for (int i = 2; i < n; i++)
        {
            for (int j = 1; j <= c; j++)
            {
                if (gl[i][j])
                {
                    continue;
                }
                if (ok[i])
                {
                    dp[i][j] += dp[i - 1][j];
                    dp[i][j] %= mod;
                }
                else
                {
                    for (int k = 1; k <= c; k++)
                    {
                        if (k == j)
                        {
                            continue;
                        }
                        dp[i][j] += dp[i - 1][k];
                        dp[i][j] %= mod;
                    }
                }
            }
        }
        for (int i = 1; i <= c; i++)
        {
            if (gl[n][i])
            {
                continue;
            }
            if (i == p)
            {
                continue;
            }
            if (ok[n])
            {
                dp[n][i] += dp[n - 1][i], dp[n][i] %= mod;
            }
            else
            {
                for (int j = 1; j <= c; j++)
                {
                    if (i == j)
                    {
                        continue;
                    }
                    dp[n][i] += dp[n - 1][j];
                    dp[n][i] %= mod;
                }
            }
        }
        for (int i = 1; i <= c; i++)
        {   
            ans += dp[n][i], ans %= mod;
        }
    }
    cout << ans % mod;
    return 0;
}

```

---


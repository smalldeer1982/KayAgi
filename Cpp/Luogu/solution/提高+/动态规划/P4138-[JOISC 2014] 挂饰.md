# [JOISC 2014] 挂饰

## 题目描述

JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。


## 说明/提示

$1\leq N\leq 2000$

$0\leq Ai\leq N(1\leq i\leq N)$

$-10^6\leq Bi\leq 10^6(1\leq i\leq N)$



## 样例 #1

### 输入

```
5
0 4
2 -2
1 -1
0 1
0 3```

### 输出

```
5```

# 题解

## 作者：违规用户名U56916 (赞：41)

~~莫名其妙找了这道题，然后莫名其妙的做了好几天。~~

想看题解发现是个dfs记忆剪枝，不是动规于是自己苦打终于打出来了

**其实这是一道很好的背包题**

费用是一维————————挂钩

但是我没有敢压缩状态，所以开了二维数组

f[i][j]表示前i件物品在有j个挂钩的情况下的最大价值

然后状态转移为~~f[i][j]=max(f[i-1][j],f[i-1][j-w[i]+1]+v[i])~~

这是错的

因为j-w[i]+1可能是个负数，没有意义，这时候就要考虑这物品直接挂在手机上即j=1，也就需要我们把j-w[i]和0取最大值保证有意义

所以正解方程为**f[i][j]=max(f[i-1][j],f[i-1][max(j-w[i].a,0)+1]+w[i].b);**//这里的a是钩子，b是价值

为什么我用结构体呢？

并不是我闲的*疼，而是我们要进行一个排序让钩子多的在前面先计算，这个因为把钩子少的先计算很有可能多次挂在手机上没有意义

然后赋初值

我们应该把不可能的情况赋成极**小**值即

**for(int i=0;i<=n;i++) f[0][i]=MAXN,f[i][n+1]=MAXN;**

然后**f[0][1]=0**这是初始状态

下面贴AC代码

```cpp
#include<bits/stdc++.h>//注意万能头比赛不能用
using namespace std;
const int MAXN=-1000000000;
int f[3010][3010];//蒙的数据范围
struct wu{
    int a,b;
}w[3010];
bool cmp(wu i,wu j){
    return i.a>j.a;
}
int ans=-2147483647;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d%d",&w[i].a,&w[i].b);
    sort(w+1,w+1+n,cmp);
    for(int i=0;i<=n;i++) f[0][i]=MAXN,f[i][n+1]=MAXN;
    f[0][1]=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=n;j++){
            f[i][j]=max(f[i-1][j],f[i-1][max(j-w[i].a,0)+1]+w[i].b);
        }
    }
    for(int i=0;i<=n;i++) ans=max(ans,f[n][i]);//每个钩子都有可能
    cout<<ans;
    return 0;
}
```


---

## 作者：FreeDr (赞：14)

大体思路是贪心+背包dp

对于物品可以分成四类

1.有挂钩，装饰度非负

2.有挂钩，装饰度为负数

3.无挂钩，装饰度非负

4.无挂钩，装饰度为负数

可见对于第1种拿取是最优的，对于第4种不拿是最优的，那么就只剩2、3两种需要判断了。

对于第2种物品，可以用f[i]表示当还有i个剩余挂钩时的最大装饰度，做一次01背包即可求f[]数组。

对于第3种物品，只要拿价值最大的就可以了，那么降序排序后的前缀和s[i]就可以表示当挂钩数为[i]时的最大装饰度。

那么答案就是max(f[i]+s[i])了，注意还要加上第1种物品给答案的贡献。

（似乎不把第一种物品单独拿出来，和第二种一起做01背包也是可以的？？）

下面贴代码=v=

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
const int N = 2010;
const int inf = 0x3f3f3f3f;
using namespace std;
struct ITEM
{
	int hk, v;
}a[N]; int sza;
int b[N], s[N]; int szb;
int n;
int anssum, anscnt;
int f[N];

bool cmp1(const int A, const int B) {return A > B; }

void input()
{
	anssum = 1;
	int x, y;
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	{
		scanf("%d%d", &x, &y);
		if(x == 0)
		{
			if(y <= 0) -- i, -- n;
			else ++ szb, b[szb] = y;
		}
		else
		{
			if(y >= 0) anssum += x-1, anscnt += y;
			else ++ sza, a[sza].hk = x-1, a[sza].v = y;
		}
	}
	anssum = min(anssum, n);
}

void work()
{
	for(int i = 0; i <= 2000; ++ i)
		f[i] = -inf;
	for(int i = 0; i <= anssum; ++ i)
		f[i] = 0;
	for(int i = 1; i <= sza; ++ i)
		for(int j = 2000; j >= a[i].hk; -- j)
			f[j] = max(f[j], f[j-a[i].hk] + a[i].v);
	for(int i = n - 1; i >= 0; -- i)
		f[i] = max(f[i], f[i+1]);
	sort(b + 1, b + 1 + szb, cmp1);
	for(int i = 1; i <= 2000; ++ i)
		s[i] = s[i-1] + b[i];
	int ans = 0;
	for(int i = 0; i <= 2000; ++ i)
	{
		ans = max(ans, f[i]+s[i]);
	}
	printf("%d\n", ans+anscnt);
}

int main()
{
	input();
	work();
	return 0;
}
```

---

## 作者：空の軌跡 (赞：12)

# 这是一道有操作的 01背包 问题

## 思路：

通过思考，我们可以想到无论运算过程中是否缺少钩子，但只要
最终结果剩余的钩子不小于 0 也就是不缺少钩子，就满足要求，因为我们可以通过改变挂钩的顺序来使得过程中不会出现缺少挂钩的情况，因此，我们可以 **忽略挂饰顺序所带来的影响** 。

用  **maxx [ i ] 表示 还剩 i 个挂钩时所能获取的最大喜悦值** , 然后就利用 **01背包** 的转移 (如果不会背包请先简单的学习一下)  。

最终结果显然就是 **max{ maxx [ 0 ~ INF ] }** 。

## 处理数组越界的情况：

1≤N≤2000 ，0≤Ai≤N(1≤i≤N)

可以看到挂钩最多可以有大约2000 × 2000 = 4000000 个，显然我们不能开这么多数组来一个一个转移 , 要不然就 T 了。

通过观察我们看到 N 只有2000 ，也就是最多只会使用 2000 个钩子，所以当计算到钩子数超过2000的转移，我们直接把结果的钩子数量当做2000来看，因为2000就是极限了，这并不会影响答案。

## 注意：
为了应对负数的情况，我让 **maxx [ ] 的下标全部增加 2000** ，这样就可以表示在负数范围内的值了。

## 转移：

有人在讨论中讨论可不可以转一维 ，不知是不是在讨论转移的问题 ，对此我们只要判断 Ai 是否小于 1 就行了 。

如果 Ai >= 1 说明安装此挂饰后剩余挂钩的数量不会减少，那我们反向枚举转移 ，可以保证不会重复选择该挂饰 。

反之则正向枚举转移 ，也可以保证不会重复选择（请和 **完全背包** 区别开 ，这两个的 **正向枚举** 有本质上的区别）

如果某些情况下的转移难以处理，导致出锅，而我们又没有解决的办法。那么就需要使用更多的状态，为了优化空间，我们可以使用滚动数组优化内存，像分组背包中就可以使用这种操作。

## 初始化：

把所有的 maxx [  ] 赋值为-INF，将 maxx [ 2001 ] 赋值为 0 ,  这样在转移的时候就可以判断是否存在为当前挂钩数量的情况 ，如果不存在也就是 **maxx[  ] == -INF** , 这就可以直接 continue 了。

# 代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int maxx[4010];
int main()
{
	int n,a,b;cin>>n;
	memset(maxx,-0x3f,sizeof(maxx)); 			  	 // 初始化
	maxx[2001]=0;					  
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		--a;						  	 // 自己占用钩子
		if(a>0)							 // a>0 则反向枚举转移
		{
			for(int j=4000;j>=0;j--)
			{
				if(maxx[j]==-0x3f3f3f3f)continue; 	 // 目前不存在的情况
				if(j+a>=4000)			  	 // 如果超越了上限，那就直接向上限转移
				maxx[4000]=max(maxx[j]+b,maxx[4000]);
				else maxx[j+a]=max(maxx[j]+b,maxx[j+a]); // 否则常规转移
			}
		}
		else							 // a<=0 则正向枚举转移
		{
			for(int j=0;j<=4000;j++)
			{
				if(maxx[j]==-0x3f3f3f3f)continue;	 // 同上
				maxx[j+a]=max(maxx[j]+b,maxx[j+a]);
			}
		}
	}
	int ans=0;
	for(int i=2000;i<=4000;i++)					 // 选择出一个最大的答案
	ans=max(maxx[i],ans);
	cout<<ans;
}
```
# 结束

---

## 作者：FreeTimeLove (赞：9)

## 简化题意

通过仔细观察题目，我们可以对题意进行**简化和归纳**：

给定 $n$ 个物品，第 $i$ 个物品体积 $v_i=1-a_i$，价值 $w_i=b_i$，求总体积**不大于** $1$ 的物品的**最大价值**。

$1\le n\le 2\times 10^3,a_i\in [0,n],b_i\in[-10^6,10^6]$

## 思路

我们发现经过化简，这道题就是一道体积、价值**可以为负**的 $01$ 背包 DP。

直接套用经典 $01$ 背包的模板是行不通的，因为总体积可能**为负**，会导致数组越界。我们应该将体积的存储地址整体右移，令**总体积为最小值**时的最大价值存入 $c_0$，这样就可以防止数组越界。

但是，假如我们这样做，体积数组的大小为  $O(n^2)$，时间复杂度就会达到恐怖的 $O(n^3)$。通过观察可以发现，总体积最大只会到达 $2\times 10^3$，这意味着只要当前体积 $v\le -2\times 10^3$，总体积**一定小于** $1$ ，再单独计算此时价值的最大值就无意义了，都归入体积为 $-2\times 10^3$(**有意义**的体积最小值)时的状态即可。

那么我们就找到了解法：令 $v=-2\times 10^3$ 时最大价值存入 $c_0$，$v=0$ 时的最大价值存入 $c_{2\times 10^3}$，$v=2\times 10^3$ （体积最大值）时的最大价值存入 $c_{4\times 10^3}$。如果实际体积小于 $-2\times 10^3$，其最大价值一并存入 $c_0$。

因为价值**可能为负**，开始前，我们先令所有状态为 $-\infty$（也表示这种状态不能到达），令 $c_{2\times 10^3}$ （即 $v=0$，不挂东西时）为 $0$。 

在求解 $01$ 背包的时候进行判断：如果 $v_i=1$，就按典型 $01$ 背包求解；如果 $v_i\le0$，就从上一层状态（前 $i-1$ 个物品能达到的最大总价值）向当前层状态（前 $i$ 个物品能达到的最大总价值）转移，如果 $v<-2\times 10^3$ 就将状态存入 $c_0$。**需要注意的是**，在转移状态的时候，如果该状态的上一层状态为 $-\infty$，说明上一层状态**并不存在**，此时就不能进行转移。

这里我们采用**滚动数组**优化空间，因此 $v_i=1$ 时**倒序**转移状态，$v_i\le 0$ 时**正序**转移状态。

最终答案为 $\max_{i=0}^{2\times10^3+1}c_i$ （体积不大于 $1$ 时的最大总价值）。

### AC code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int N=2e3+5,INF=0x3f3f3f3f;
int n,m=4005,v[N],w[N],c[4010],ans;//为了防止溢出，令m略微大一点 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
		v[i]=1-v[i];
	}
	//初始化 
	for(int j=0;j<=m;j++)c[j]=-INF;
	c[2000]=0;
	//01背包DP 
	for(int i=1;i<=n;i++){
		if(v[i]==1){//v[i]=1 <=> v[i]>0 
			for(int j=m;j;j--)
				if(c[j-1]!=-INF)
					c[j]=max(c[j],c[j-1]+w[i]);
		}
		else{
			for(int j=0;j<=m;j++)
				if(c[j]!=-INF){
					int x=max(0,j+v[i]);
					//v[i]<=0，因此x<=j一定成立，应该正序更新 
					c[x]=max(c[x],c[j]+w[i]);
				}
		}
	}
	for(int i=0;i<=2001;i++)
		if(c[i]!=-INF)
			ans=max(c[i],ans);
	cout<<ans<<endl; 
	return 0;
} 
```

### The End.



---

## 作者：Sin_qwq (赞：6)

## 思路
看到题目让我们求最大的喜悦值之和，便不难想到这题可以用 dp 来做。此题中，钩子是会被消耗的，所以可以看作容积，喜悦值可以看作价值。想到这里，这题就变成了一道仅加了有的物品会补充容积这一条件的 $01$ 背包问题。


------------


## dp 转移方程
我们设 $f_{i,j}$ 表示**挂好了前 $i$ 个物品，剩余 $j$ 个钩子未使用的最大喜悦值**。此文章中啊 $a[i].con$ 表示第 $i$ 个物品的挂钩数, $a[i].vl$ 表示第 $i$ 个物品所带来的的喜悦值。

根据题意分两种情况进行转移

第一种：当 $j>0$ 时，也就是还可以挂物品时
$$
f[i][j-1+a[i].con]=\max(f[i-1][j]+a[i].vl,f[i-1][j-1+a[i].con])
$$
用人话来说就是当挂好前 $i$ 个物品的最大喜悦值等于挂好前 $i-1$ 个物品的最大喜悦值加上第 $i$ 个物品的喜悦值与挂好前 $i-1$ 个物品的喜悦值的较大值，并且所剩的挂钩数 $j$ 该加加，该减减，就可以了。

第二种：当 $j\le0$ 时
$$
f[i][j]=\max(f[i-1][j],f[i][j])
$$
也就是继承上一次状态


------------


## AC 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
const int N=1e4+7;
const int INF=0x3f3f3f3f;
int n;
int ans=-INF;
int f[N][N];
struct node{
	int con,vl;
}a[N];
inline bool cmp(node x,node y){return x.con>y.con;}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].con>>a[i].vl;
    sort(a+1,a+n+1,cmp);//按挂钩数量排序，让有挂钩的优先转移，不然转移不起来 
    for(int i=0;i<=n;i++)
    {
    	for(int j=0;j<=(n<<1);j++) f[i][j]=-INF;//初始值都赋成负无穷 
	}
	f[0][1]=0;//开始本身相当于有一个挂钩，并赋成0进行转移 
    for(int i=1;i<=n;i++)
    {
    	for(int j=0;j<=(n<<1);j++)
    	{
		    f[i][j]=max(f[i-1][j],f[i][j]);
    		if(j>0) f[i][j-1+a[i].con]=max(f[i-1][j]+a[i].vl,f[i-1][j-1+a[i].con]);		
		}
	}
	for(int i=0;i<=(n<<1);i++) ans=max(f[n][i],ans);//统计答案 
	cout<<ans<<endl;
	return 0;
}
```


------------

完结撒花

---

## 作者：Otue (赞：5)

动态规划水题。



## $\rm Step \ 1$ 定义状态
首先你看又有挂饰又有挂钩，那么就很好定义。

定义 $dp_{i,j}$ 表示挂完前 $i$ 个挂饰（可挂可不挂）且挂 $j$ 个挂钩的最大欢喜值。

## $\rm Step \ 2$ 状态转移
可以考虑第 $i$ 个挂饰挂不挂，分两种情况。
* 如果不挂，等价于前 $i-1$ 个挂饰挂 $j$ 个挂钩。即 $dp_{i,j}=dp_{i-1,j}$。
* 如果要挂，等价于前 $i-1$ 个挂饰挂 $j-a_i+1$ 个挂钩.

	可以这样理解：设前 $i-1$ 个挂饰挂了 $x$ 个挂钩，反正你前 $i$ 个挂饰挂了 $j$ 个挂钩的，则可得 $x-1+a_i=j$（要挂第 $i$ 个挂钩，肯定要花费一个挂钩去挂，然后挂上去的是 $a_i$ 个挂钩）,解得 $x=j-a_i+1$ 。
    
但是这样子 $j-a_i+1$ 有可能小于 $1$，因为你要挂这个挂饰，则必须需要一个挂钩来挂他，则必须要**强制**他为 $1$。

## $\rm Step \ 3$ 注意事项
1. 开数组的时候怎么开呢，你会发现第二维确定不下来，但开大点要 MLE ，所以可以把第一维滚了。
2. 因为你挂钩数量越多则可能产生的喜悦值越多，则按挂钩数量从大到小排个序。

## $\rm Step \ 4$ 具体代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n;
struct stu{
	int x,y;//挂钩数量，喜悦值 
}ed[100005];
bool cmp(stu a,stu b){
	return a.x>b.x;
}
int dp[2][1000005],maxn=-1000;
int main(){
	memset(dp,-0x3f3f3f3f,sizeof dp);
	dp[0&1][1]=0;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>ed[i].x>>ed[i].y;
	sort(ed+1,ed+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			if(j-ed[i].x+1<1){//他小于1就把他变成1
				dp[i&1][j]=max(dp[(i-1)&1][j],dp[(i-1)&1][1]+ed[i].y);
			}
			else{
				dp[i&1][j]=max(dp[(i-1)&1][j],dp[(i-1)&1][j-ed[i].x+1]+ed[i].y);
			}
		}
	} 
	for(int i=0;i<=n;i++){
		maxn=max(maxn,dp[n&1][i]);
	} 
	cout<<maxn<<endl;
} 
```

---

## 作者：zhousy (赞：5)

 _//预处理

//正值有多余挂钩的直接挂上去

//负值没有多余挂钩的直接去掉

//正值没有多余挂钩的由值的大小存起来 ，有多余的挂钩必然挂值大的_ 

dfs+记忆剪枝完事
```cpp
#include <iostream>  
#include <cstdio>
#include <algorithm>    
using namespace std;

int mark[1000002] = {0},zheng[1000002] = {0},jy[1000002] = {0};
int zd = 0,zdgg = 1,n,fs = 0,sxzs = 1;

class zsy{public: int z;int g;}g[1000002];

bool bi(int x,int y){return y < x;}

int dfs(int dq,int gg)
{
    if(gg >= sxzs) gg = sxzs - 1;
	if(dq <= jy[gg]) return 0;
	jy[gg] = dq;
	if(dq + zheng[gg] > zd) zd = dq + zheng[gg];
	for(int i = 0; i < fs;i++)
	{
		if(!mark[i])
		{
			mark[i] = 1;
			dfs(dq + g[i].z,gg + g[i].g - 1);
			mark[i] = 0;
		}
	}
	return 0;
} 

int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		int t1,t2;
		cin >> t1 >> t2;
		if(t1 > 0 && t2 > 0)
		{
			zd += t2;
			zdgg += t1 - 1;
		}
		else if(t1 < 2 && t2 <= 0) continue;
		else
		{
			if(t2 > 0) zheng[sxzs++] = t2;
			else 
			{
				g[fs].g = t1;
				g[fs].z = t2;
				fs++;
			}
		}
	}
	sort(zheng + 1,zheng + sxzs + 1,bi);
	jy[1] = -0x3f3f3f;
	jy[0] = -0x3f3f3f;
	for(int i = 2; i < sxzs ;i++)
	{
		zheng[i] = zheng[i - 1] + zheng[i];
		jy[i] = -0x3f3f3f;
	}
	dfs(zd,zdgg);
	cout << zd;
	return 0;
} 
```

---

## 作者：一只书虫仔 (赞：4)

#### Description

> 有 $n$ 个挂饰，第 $i$ 个挂饰有 $a_i$ 个钩子，挂在墙上有 $b_i$ 的喜悦值，最开始墙上有 $1$ 个钩子，挂饰可以挂在其他挂饰的钩子上，求挂好后得到的喜悦值总和的最大值是多少。

#### Solution

先对这 $n$ 个挂饰对 $b_i$ 从大到小排序（结构体），然后考虑 $f_{i,j}$ 为考虑到第 $i$ 个挂饰，还剩下 $j$ 个钩子没有挂东西，我们考虑主动转移：

- 挂第 $i-1$ 个挂饰：将 $f_{i-1,j}$ 转移到 $f_{i,\min\{n,j-1+a_i\}}$，需要保证 $j \ne 0$；
- 不挂第 $i-1$ 个挂饰：将 $f_{i-1,j}$ 转移到 $f_{i,j}$。

初始化时要注意全部为 $-\infty$，除了 $f_{0,1}=0$。

第 $2$ 维的上限不难发现超过 $n$ 是没有意义的，所以直接截止到 $n$（见上方第一个转移方程）。

#### Code

```cpp
for (int i = 1; i <= n; i++)
	for (int j = 0; j <= n; j++) {
		if (j != 0) dp[i][min(n, j - 1 + a[i].num)] = max(dp[i - 1][j] + a[i].beu, dp[i][min(n, j - 1 + a[i].num)]);
		dp[i][j] = max(dp[i - 1][j], dp[i][j]);
	}
```

---

## 作者：cqbz_luoyiran (赞：2)

[[JOISC2014]挂饰](https://www.luogu.com.cn/problem/P4138)

难度：提高+/省选-

分类：动态规划，01背包，贪心，剪枝

分析：初看这道动态规划题，可以看出是一道01背包题，但这道题不同于其他01背包的地方在于挂钩的问题，其挂钩数量如果少于后面挂饰挂钩的数量，便会多次挂上却没有意义，于是我们可以设置一个结构体，将结构体按照挂钩数量从大到小排序，保证先算挂钩数量多的，让后按照01背包模板打上去就可以了，但要注意下表小于0的情况，就把这个挂件扔到手机上就行了，于是可得转移方程:
$$dp[i][j] = max(dp[i - 1][j],dp[i - 1][max(j - c[i].a,0) + 1] + c[i].b)$$
注意要先将dp数组赋为极小值，起始状态为$dp[0][1] = 0$
目标:$max(dp[n][i])$
#### code
```
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,dp[5][2005],ans;//可用滚动数组优化
struct node{
	int a,b;//a表示挂钩数量，b表示喜悦值
}c[2005];
bool cmp(const node &x,const node &y) {
	return x.a > y.a;//按照挂钩数量从小到大排序
}
int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
	scanf("%d %d",&c[i].a,&c[i].b);
	sort(c + 1,c + n + 1,cmp);
	memset(dp,-0x3f3f3f3f,sizeof(dp));//极小值
	dp[0][1] = 0;//初始状态
	for(int i = 1;i <= n;i ++) {
		for(int j = 0;j <= n;j ++) {
			dp[i & 1][j] = max(dp[(i - 1) & 1][j],dp[(i - 1) & 1][max(j - c[i].a,0) + 1] + c[i].b);//dp方程
		}
	}
	ans = -0x3f3f3f3f;
	for(int i = 0;i <= n;i ++)
	ans = max(ans,dp[n & 1][i]);//答案
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Harry_Hedwig (赞：2)

# 0x00 思路
先看题。
>JOI君有 $N$ 个装在手机上的挂饰，编号为 $1$ ~ $N$ 。 JOI君可以将其中的一些装在手机上。JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。**直接挂在手机上的挂件最多有 $1$ 个**。此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。JOI君想要**最大化**所有挂饰的喜悦值之和。注意**不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的**。

对于每一个挂件，我可以选择挂或不挂，那么由于每个挂件只有 $1$ 个，所以这是一个 $01$ 背包。

可是这又与 $01$ 背包有一点区别：每一个物品多了一个属性：挂钩数,因此为了适应这个多出来的属性，我们决定把它变成背包容量。

接着因为我们认为，挂钩越多越有用（因为能挂的挂件越多欢喜值越大（都是整数的情况下）），所以我们按照挂钩的数量从大到小排序。

# 0x01 定义状态
对于 $d[i][j]$，我们定义：**挂完或选择不挂后**第 $i$ 个挂件后还剩余 $j$ 个空挂钩所得的最大喜悦值。

# 0x02 状态转移方程
那么很容易，我们可以发现有 $2$ 种情况：

1. 不选用它
	
   这个状态很简单，由于是 $01$ 背包，所以 $d[i][j]=d[i-1][j]$ 。 
1. 选用它

	这个状态有 $2$ 种情况。
   
   一种是 $j \geq A_i$ : 那么此时的 $d[i][j]$ 就等于 $d[i-1][j-A_i+1]+B_i$ (这个挂件需要 $1$ 个挂钩)。
    
   另一种是 $j<A_i$ : 由于我们挂了这个挂件，所以必须得有一个挂钩来挂这个挂件，而此时 $j-A_i+1<0$，所以我们**强行**认为它是 $1$。

所以状态转移方程就是 $d[i][j]=\max(d[i-1][j],d[i-1][\max(j-A_i,0)+1]+B_i)$。

# 0x03 注意优化！
$\color{red} attention :$ 此处优化有一点不同！它需要 $2$ 行来存储答案，否则的话就会酿成悲剧…… QWQ 

为什么呢？

由于 $A_i$ 可能为 $0$ ，而 $j>0$，所以可能会用到 $d[i-1][j+1]$ 的值，而用一维数组的话 $j+1$ 已经被赋成 $d[i][j+1]$ 了，所以只能用 $2$ 行。

# code
```c
#include<bits/stdc++.h>
using namespace std;
int d[2005][2005];
struct gs
{
	int gg,hxz;
}a[2005];
bool cmp(gs b,gs c)
{
	return b.gg>c.gg;
}
int main()
{
	int n,m,i,j,ans=0;
	scanf("%d",&n);
	memset(d,128,sizeof(d));
	d[0][1]=0;
	for(i=1;i<=n;i++)
		scanf("%d %d",&a[i].gg,&a[i].hxz);
	sort(a+1,a+1+n,cmp);
	for(i=1;i<=n;i++)
		for(j=0;j<=n;j++)
			d[i][j]=max(d[i-1][j],d[i-1][max(j-a[i].gg,0)+1]+a[i].hxz),ans=max(ans,d[i][j]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：moye到碗里来 (赞：2)

贪心+dp

显然有挂钩的开心值为正的挂钩直接挂更优，没有或者只有一个挂钩的负开心值一定不能挂，先去掉这些多余状态，对剩下的负贪心值做一次背包，对正的拍一遍序枚举挂钩数取最大值就是答案
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2000 + 5;
int n;
struct node{
    int a,b;
}can[MAXN];
int dp[MAXN][MAXN];
int sum[MAXN];
int val[MAXN];
bool cmp(int a,int b){
    return a > b;
}
int main()
{
//	freopen("pendant.in","r",stdin);
//	freopen("pendant.out","w",stdout);
    scanf("%d",&n);
    int a,b;
    int ans = 0,cnt = 0,cnt2 = 0,tot = 1;
    for(int i = 1; i <= n; ++i){
        scanf("%d %d",&a,&b);
         if(a > 0 && b > 0){ans += b,tot += a - 1;}
         if(a == 0 && b > 0){val[++cnt] = b;}
         if(a > 1 && b < 0){can[++cnt2] = (node){a,b};}
    }
    sort(val + 1,val + 1 + cnt,cmp);
    for(int i = 1; i <= cnt; ++i)sum[i] = sum[i - 1] + val[i];
    memset(dp,-0x3f,sizeof(dp));
    if(tot > cnt)tot = cnt;
    for(int i = 0; i <= n; ++i)dp[i][0] = 0;
    for(int i = 1; i <= cnt2; ++i){
        for(int j = 0;j <= cnt - tot; ++j){
            int num = j + can[i].a - 1;
            if(num > cnt - tot)num = cnt - tot;
            dp[i][num] = max(dp[i - 1][num],dp[i][num]);
            dp[i][num] = max(dp[i][num],dp[i - 1][j] + can[i].b);
        }
    }
    int ans2 = -1000000000;

    for(int i = tot; i <= cnt; ++i){
        ans2 = max(ans2,sum[i] + dp[cnt2][i - tot]);
    }
    printf("%d",ans + ans2);
}
```

---

## 作者：cqbz_lipengcheng (赞：1)

### 分析：
#### 1.状态：
$dp[i][j]$表示已经挂好了前i个挂饰还有j个挂钩
#### 2.状态转移方程：
当$j>0$时
$$dp[i][j - 1 + c[i].a] = max(dp[i - 1][j] + c[i].b, dp[i - 1][j - 1 + c[i].a]);$$
$$dp[i][j] = max(dp[i - 1][j], dp[i][j]);$$
否则
$$dp[i][j] = max(dp[i - 1][j], dp[i][j]);$$
#### 3.具体实现：
首先要排个序，将挂钩多的挂饰先挂（尽可能加大可以挂的空间），然后想到这，可能有的人会直接一个三重暴力枚举，但是显然这是不行的，我们需要更少的时间。但是如果把程序优化到二维，那么此时就要考虑如何求得当前的挂钩数了，方法很多，这里提几个：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, dp[2005][4010], _max = -0x3f3f3f3f;
struct node {
    int a, b;
} c[2005];
int cmp(node x, node y) { return x.a > y.a; }
int main() {
    memset(dp, -0x7f, sizeof(dp));
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &c[i].a, &c[i].b);
    }
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= 2 * n; j++) {
            dp[i][j] = -0x3f3f3f3f;
        }
    }
    dp[0][1] = 0;
    sort(c + 1, c + 1 + n, cmp);
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= 2 * n; j++) {//应为若考虑极端那么最多就是两个挂钩数量为n的挂在一起所以最多2*n个钩子
            if (j > 0) {
                dp[i][j - 1 + c[i].a] = max(dp[i - 1][j] + c[i].b, dp[i - 1][j - 1 + c[i].a]);//将每个dp[i][j]取第i个的情况提前计算出来
                dp[i][j] = max(dp[i - 1][j], dp[i][j]);
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j]);
            }
        }
    }
    for (int i = 0; i <= 2 * n; i++) {
        if (dp[n][i] > _max) {
            _max = dp[n][i];
        }
    }
    printf("%d", _max);
    return 0;
}
```


---

## 作者：LlLlCc (赞：1)

## 典型的背包问题
首先，所有的挂钩一起处理有些复杂，我们可以分类讨论，对每种情况进行不同的选择，我们可以分成四类

- a[i]>=1并且b[i]>=0

- a[i]=0并且b[i]<0

- a[i]<1并且b[i]>0

- a[i]<=1并且b[i]<=0

有两个很明确的方向

1. 第一种必选

2. 第四种肯定不选

证明过程：~~显然~~

所以对于第一种情况我们直接加上答案，第四种情况我们可以直接跳过

那么对于二、三种情况我们应该怎么处理呢？

先想一个问题，如果我们现在可以选k件第二种类型的挂钩，我们会怎么选？贪心的想法告诉我们，因为a[i]都相等，所以肯定挑b[i]更大的前k个

这里想通了，问题就迎刃而解了

现在就转化为背包了

对于第三种情况，b[i]为价值，a[i]为空间，刷一趟01背包就OK

详见代码：
```
#include<bits/stdc++.h>
#define maxn 2000005
#define ll long long
using namespace std;
int tota,totb,T,n,a[maxn],x,y;
ll Cnt,f[maxn],Ans,sum[maxn];
struct lc{
	ll x,y;
}A[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
    while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
int main(){
	n=read();T=1;
	for (int i=1;i<=n;i++){
		x=read(),y=read();
		if (x<=1&&y<=0) continue;
		if (x&&y>=0) T+=x-1,Ans+=y;else
		if (!x&&y>0) a[++tota]=y;else
		if (x>1&&y<0) A[++totb]=(lc){x-1,y};
	}
	sort(a+1,a+tota+1);reverse(a+1,a+tota+1);
	for (int i=1;i<=2000000;i++) sum[i]=sum[i-1]+a[i],f[i]=-(1<<30);
	for (int i=1;i<=totb;i++){
		for (int j=tota;j>=A[i].x;j--) f[j]=max(f[j],f[j-A[i].x]+A[i].y);
    	for (int j=1;j<A[i].x;j++) f[j]=max(f[j],A[i].y);
}
	for (int i=0;i<=1500000;i++) Cnt=max(Cnt,f[i]+sum[i+T]);
	printf("%lld",Ans+Cnt);
	return 0;
}
```


---

## 作者：ShineEternal (赞：0)

[如有LaTeX显示问题可查看这里](https://blog.csdn.net/kkkksc03/article/details/102016431)


## description：
JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。

## solution：
$设f[i][j]表示前i个挂钩，有j个挂饰时的最大喜悦值$

$那么f[i][j]=max(f[i-1][j],f[i-1][max(j-d[i].a,0)+1]+d[i].b);$

显然在普通背包的基础上考虑负值带来的影响就行了

还有就是注意要排序，因为如果先算钩子少的极有可能多次挂上没有意义

## code:

```cpp
#include<cstdio>
#include<algorithm>
#define minx -1000000000
using namespace std;
struct ben
{
	int a,b;
}d[2005];
int cmp(const ben &x,const ben &y)
{
	return x.a>y.a;
}
int f[2005][2005];
int main()
{
	int n;
	scanf("%d",&n);
	int m=0;
	for(int i=0;i<=n;i++)
	{
		f[0][i]=f[i][n+1]=minx;
	}
	f[0][1]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&d[i].a,&d[i].b);
	}
	sort(d+1,d+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=n;j++)
		{
			f[i][j]=max(f[i-1][j],f[i-1][max(j-d[i].a,0)+1]+d[i].b);
		}
	}
	int ans=-2000000000;
	for(int i=0;i<=n;i++)
	{
		ans=max(ans,f[n][i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Christopher_Yan (赞：0)

#### 解题思路
我们设数组$dp[i][j]$表示前$i$个物品，剩余$j$个钩子时的最优值，0/1背包的模板，但是这样显然不能AC，因为这个挂挂饰的顺序是影响最优解的。


然后我们可以贪心的想一想：我们可以假设已经有选好的一系列物品，那么我们可以认为按照钩子数从多到少来挂一定能最优解。

那么排序后在做一遍背包就可以了。

#### AC代码
```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=3000,INF=2147000000;
int n,ans=-INF,dp[N][N];
struct Pool{
	int a,b;
}w[N];
bool cmp(Pool x,Pool y){
	return x.a>y.a;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;++i) 
		cin>>w[i].a>>w[i].b;
	sort(w+1,w+n+1,cmp);
	memset(dp,-10000000,sizeof(dp));
	dp[0][1]=0;
	for(int i=1;i<=n;++i)
		for(int j=0;j<=n;++j)
			dp[i][j]=max(dp[i-1][j],dp[i-1][max(j-w[i].a,0)+1]+w[i].b);
	for(int i=0;i<=n;++i) 
		ans=max(ans,dp[n][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：初雪_matt (赞：0)

### 题目大意：

给定你 $n$ 个关系，$a_i$ 与 $b_i$ 分别为可以挂住另一个物品的个数与该物品的喜爱值，问可以获得的最大喜爱值。

### 思路：

既然问的是最大喜爱值，喜爱值的多少(数量上)又跟挂的钩子有关系，所以第一时间想到的是贪心，贪什么呢？先贪挂钩数量，如果相等就贪喜爱值，不难得出下面代码。

```cpp
struct node{
    int x,y;//x代表挂钩数量，y表示喜爱值
    bool operator<(const node&t)const{
        if(x==t.x){//如果挂钩相等则贪喜爱值
            return y>t.y;
        }
        return x>t.x;//挂钩不相等返回挂钩多的为好
    }
}a[N];

```
现在不妨设 $dp[i][j]$ 代表选到第 $i$ 个挂钩时，还有 $j$ 个挂钩还空缺的最大喜爱值，如果不想挂第 $i$ 个钩子时(当前物品喜爱值负数且没有挂钩)，则将 $dp[i-1][j]$ 转移到 $dp[i][j]$ 上去，否则将 $dp[i-1][max(j-a[i].x,0)+1]+a[i].y$ 转移到 $dp[i][j]$ 上去，因为如果选了第 $i$ 个挂钩挂物品，需要将 $j$ 减去当前挂的物品带有的钩子，如果为负数则取零，记得要加一(此处请读者自己思考为什么要加上一)，还需将 $dp$ 数组提前设为无限小，并且 $dp[0][1]$ 必须等于 $0$ ，易得代码如下。

```cpp
memset(dp,-0x3f,sizeof(dp));
dp[0][1]=0;
for(int i=1;i<=n;i++){
   for(int j=0;j<=n;j++){
       dp[i][j]=max(dp[i-1][j],dp[i-1][max(j-a[i].x,0)+1]+a[i].y);
   }
}
for(int i=0;i<=n;i++){
   ans=max(ans,dp[n][i]);
}
```

### 完整代码

```cpp
#include<bits/stdc++.h>
#define N 3005
using namespace std;
int n,ans,mini,dp[N][N];
struct node{
    int x,y;//x代表挂钩数量，y表示喜爱值
    bool operator<(const node&t)const{
        if(x==t.x){//如果挂钩相等则贪喜爱值
            return y>t.y;
        }
        return x>t.x;//挂钩不相等返回挂钩多的为好
    }
}a[N];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].x>>a[i].y;//读入
    }
    sort(a+1,a+n+1);//贪心排序
    memset(dp,-0x3f,sizeof(dp));//将整个dp数组设为无限小
    dp[0][1]=0;//切记这里要初始化成0，不然会已无穷小来操作以下dp转移
    for(int i=1;i<=n;i++){//枚举n样物品
        for(int j=0;j<=n;j++){
            dp[i][j]=max(dp[i-1][j],dp[i-1][max(j-a[i].x,0)+1]+a[i].y);//上面推出的转移方程
        }
    }
    for(int i=0;i<=n;i++){
        ans=max(ans,dp[n][i]);//方案取最大值
    }
    cout<<ans<<endl;//输出答案
    return 0;//完美撒花~
}
```


---

## 作者：Tgotp (赞：0)

容易贪心的想到，既有挂钩又有正价值的点一定能加入，即可以把这个挂在手机上，把原来的接上去。

做这一步的时候要考虑原来是否已经有加入，有的话挂钩量要减一。

然后考虑对于负价值的点，令f[i]表示能提供i个挂钩的最小价值，做一遍dp

然后和原来的合并即可，因为原来的是按顺序加入，那么扫一遍就能得到最优方案了。

c++代码如下：
```
#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x;i >= y; -- i)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template<typename T>inline bool chkmin(T&x,T y) { return x > y ? x = y,1 : 0; }
template<typename T>inline bool chkmax(T&x,T y) { return x < y ? x = y,1 : 0; }
inline char gc()
{
	static char buf[1 << 16],*S,*T;
	if(S == T) { T = (S = buf) + fread(buf,1,1<<16,stdin); if(S == T) return EOF; }
	return *S ++ ;
}
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = gc(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = gc();	 }while(isdigit(c));
	x *= sign;
}
 
const int N = 2e3 + 50;
int f[N],ans; //有i个挂钩 最小花费 
struct DATA { int a,b; }a[N];
 
const bool cmp(DATA a,DATA b) { return a.b > b.b; }
int g[N],q[N],st,en,cnt;
int n;
 
int main()
{
	read(n);
	rep(i,1,n) read(a[i].a), read(a[i].b);
	sort(a + 1,a + 1 + n,cmp);
	
	int k; st = 1;bool e = 0;
	rep(i,1,n + 1) 
		if(a[i].b <= 0) { k = i; break; }
		else 
		{
			if(a[i].a > 0)
			{
				ans += a[i].b;
				cnt += a[i].a - e;
				e = 1;
			}
			else q[++en] = a[i].b;
		}
	while(cnt && st <= en) ans += q[st++],--cnt;
	rep(i,st,en) g[i-st+1] = g[i-st] + q[i];
	
	memset(f,-0x3f,sizeof f);f[0] = 0;
	rep(i,k,n) if(a[i].a)
		repd(j,n,a[i].a - 1)
			chkmax(f[j],f[j - a[i].a + 1] + a[i].b);
	
	int t = ans;
	rep(i,en-st+2,n) g[i] = g[i-1];
	if(!e) rep(i,1,n) chkmax(ans,f[i-1] + g[i] + t);
	else rep(i,1,n) chkmax(ans,f[i] + g[i] + t);
	cout << ans << endl;
	
	return 0;
}
```

[博客地址](http://tgotp.science/4247-%E6%8C%82%E9%A5%B0/)

---

## 作者：生而为人 (赞：0)

# 题目描述
JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。

输入格式
第一行一个整数N，代表挂饰的个数。

接下来N行，第i行(1<=i<=N)有两个空格分隔的整数Ai和Bi，表示挂饰i有Ai个挂钩，安装后会获得Bi的喜悦值。

输出格式
输出一行一个整数，表示手机上连接的挂饰总和的最大值

此题为裸的背包问题，钩子为体积，喜好度为val。
但又因为起始的钩子数会影响之后的转移，故按钩子的个数进行排序。再跑一遍背包。
具体细节 代码详注。
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace  std;
const int N=3005;
struct node
{
	int num;
	int val;
}a[N];
int f[N][N];
int n;
bool cmp(node a,node b)
{
	return  a.num>b.num;//  按钩子数量排序。 
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&a[i].num,&a[i].val);
	sort(a+1,a+1+n,cmp);//为什么要按钩子排一遍序，因为这样是更优的，假如有一个极小值的钩子数目更多则可通过0进行翻悔。 
	memset(f,-0x3f,sizeof(f));// 挂饰的喜爱度可以为负值故必须赋为极小值。 
	f[0][1]=0;//起始时手机可挂一个故设为0 
	for(int i=1;i<=n;i++)
	for(int j=0;j<=n;j++)// 背包板子 
	{
		f[i][j]=f[i-1][j];
		
		f[i][j]=max(f[i][j],f[i-1][j-a[i].num+1]+a[i].val);
	}
	int ans=-(1e6+5);
	for(int i=0;i<=n;i++)//输出答案。 
	ans=max(ans,f[n][i]);	
	cout<<ans;

}
```


---


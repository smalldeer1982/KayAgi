# [SCOI2009] 生日快乐

## 题目描述

windy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 $X$ 和 $Y$ 的矩形蛋糕。

现在包括 windy，一共有 $N$ 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。

windy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。

这样，要切成 $N$ 块蛋糕，windy 必须切 $N-1$ 次。

为了使得每块蛋糕看起来漂亮，我们要求 $N$ 块蛋糕的长边与短边的比值的最大值最小。

你能帮助 windy 求出这个比值么？


## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le X,Y \le 10^4$，$1\le N\le 10$。


## 样例 #1

### 输入

```
5 5 5```

### 输出

```
1.800000```

# 题解

## 作者：浅色调 (赞：38)

### Solution：

　　本题不需要多想直接$dfs$。

　　首先我们假设当前的矩形长为$x$，宽为$y$，要分出$k$块，那么不难想到分出的一块的长$mx$最短为$x/k$，宽$my$最短为$y/k$，而且每次切的长度一定是$mx$的倍数或$my$的倍数（很好理解，不是倍数就无法保证之后切出至少长$mx$的矩形或宽$my$的矩形，可以自行画图）。

　　于是我们递归搜索，每次切长或者宽，在分出的两块中取比值的最大值，更新最大值的最小值，返回就$OK$了。
  
  $\quad\;\;$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/9046419.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define For(i,a,b) for(double (i)=(a);(i)<=(b);(i)++)
using namespace std;
int n,x,y;
il double dfs(double x,double y,int k){
    if(k==1){return max(x,y)*1.0/min(x,y);}
    double ans=233333333,mx=x*1.0/k,my=y*1.0/k,t1,t2;
    For(i,1,k/2){
        t1=max(dfs(mx*i,y,i),dfs(x-mx*i,y,k-i));
        t2=max(dfs(x,my*i,i),dfs(x,y-my*i,k-i));
        ans=min(ans,min(t1,t2));
    }
    return ans;
}
int main(){
    cin>>x>>y>>n;
    printf("%.6lf",dfs(x,y,n));
    return 0;
}
```

---

## 作者：Huah (赞：8)

dfs模拟，由于每次只能横向切或者纵向切，于是我们每次要把长x宽y的矩形分成d块。那么这一刀只能使切成两块后，第一块的面积为i/d，第二块的面积为(d-i)/d，这里i,d都为整数。

然后就转换成了两个子问题，一个是把面积为i/d的蛋糕均分为i块，另一个是把面积为(d-i)/d的蛋糕分成(d-i)块，这样递归切割下去，最后只剩1块的蛋糕的面积一定为x*y/d。

因此可以使用深搜暴力解决这个问题，不记忆化也能过这道题，如果需要记忆化可以通过最简分数形式进行哈希。
```c
#include<bits/stdc++.h>
using namespace std;
double x,y,n;
double dfs(double x,double y,double d)
{
    double ans=1000000000;
    if(d==1)
    {
        if(x<y) swap(x,y);
        return x/y;
    }
    double mx=x/d,my=y/d;
	double ans1,ans2;
	for(int i=1;i<=d/2;i++)
    {
        ans1=max(dfs(mx*i,y,i),dfs(x-mx*i,y,d-i));
        //i/d的面积分为i块，（d-i)/d的面积分为d-i块
        ans2=max(dfs(x,my*i,i),dfs(x,y-my*i,d-i));
        ans=min(ans,min(ans1,ans2));
    }
	return ans;
}

int main()
{
	scanf("%lf%lf%lf",&x,&y,&n);
	printf("%.6lf",dfs(x,y,n));
}

```


---

## 作者：Jesselrj (赞：5)

# 生日快乐 [SCOI2009]

原题链接：[luogu P4160][4]

## 解题思路
这题题目很明显就是用来吓唬你的，“最大值的最小值”，让人以为是二分，其实是一道深搜。当时愣是想不出，样例是哪来的，后来经过学长的讲解，终于明白了。

![样例][5]

样例

根据题意：我们要平行着x轴或y轴切，且只能切n-1刀，然后的面积要相等，所以我们只能切x/n或y/n的倍数。

由于n比较小，考虑dfs
## AC代码如下：
```
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

int x,y,n;

double dfs(double x,double y,int k)
{
	if(k==1)return max(x,y)*1.0/min(x,y)*1.0;//返回解
	double ans=2333333333.333;
	double nx=x*1.0/k*1.0,ny=y*1.0/k*1.0;//只能切x/n和y/n
	for(double i=1.0;i<=k*1.0/2.0;i+=1.0)
	{
		double temp1=max(dfs(nx*i,y,i),dfs(x-nx*i,y,k-i));//是取这一刀下去的左边，还是这一刀下去的右边。
		double temp2=max(dfs(x,ny*i,i),dfs(x,y-ny*i,k-i));//平行y轴。
		ans=min(ans,min(temp1,temp2));//更新最优解
	}
	return ans;
}

int main()
{
	cin>>x>>y>>n;
	printf("%.6lf",dfs(x,y,n));
	return 0;
}
```
[4]:https://www.luogu.org/problemnew/show/P4160
[5]:http://thyrsi.com/t6/365/1535555159x-1404755462.png

---

## 作者：Night_Aurora (赞：5)

这道题一眼看上去像是个DP问题

因为每一层很明显要么横着切，要么纵着切，还要往两边分配各自的切次数

但是先不管X和Y的范围

切割过程中会出现实数集的长宽来，所以DP并不可取

---

然后大部分复杂度不行又没法优化的DP都是贪心题

但是这道题就算了

---

考虑到N很小，我们可以试试搜索

暴力强搜不可取，我们考虑一下怎么优化

首先要保证每一块大小一样，这样就使得每一层的切割方案是有限的

这样我们可以模仿DP一样写一个DFS函数

``` Function DFS(X,Y as rational,N as an integer) ```

X,Y表示长宽，N表示还要切几刀(与输入的N意义不一样)

凭感觉的话我们发现会有很多同样的状态

就像一刀在中间切会切出来两个一模一样的状态

所以我们考虑记忆化

长宽切来切去很明显是有理数,我们可以保存为最简分数

然后开一个map,来保存(X,Y,N)这个三元组来实现记忆化

复杂度: $O($玄学$*log^2N)$

实际上还是跑的非常快的，0ms过

考虑到极端情况，最简分数应该用long long int 来存

代码:

```
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <map>

typedef long long _L;

_L GCD(_L a,_L b)
{
	_L Tmp;
	while(b)
	{
		Tmp=b;
		b=a%b;
		a=Tmp;
	}
	return a;
}	
//a/b

typedef std::pair<_L,_L> RTL;

void Release(RTL&i)
{
	_L g=GCD(i.first,i.second);
	i.first/=g;
	i.second/=g;
}

RTL operator *(int b,RTL a)
{
	a.first*=b;
	Release(a);
	return a;
}

RTL operator /(RTL a,int b)
{
	a.second*=b;
	Release(a);
	return a;
}

typedef std::pair<std::pair<RTL,RTL>,int> STATUS;

std::map<STATUS,double> Map;

int X,Y,N;

void Input()
{
	scanf("%d %d %d",&X,&Y,&N);
}
double max(double a,double b){return a>b?a:b;}
double min(double a,double b){return a>b?b:a;}

double DFS(RTL a,RTL b,int N)
{
	if(!N)
	{
		double fa,fb;
		fa=1.0*a.first/a.second;
		fb=1.0*b.first/b.second;
		if(fa<fb)
		{
			fa+=fb;
			fb=fa-fb;
			fa=fa-fb;
		}
		return fa/fb;
	}
	STATUS bf=std::make_pair(std::make_pair(a,b),N);
	if(Map.count(bf))
		return Map[bf];
	double Ans=1000000;
	int wi;
	for(wi=0;wi<N;++wi)
	{
		Ans=min(Ans,max(DFS((wi+1)*(a/(N+1)),b,wi),DFS((N-wi)*(a/(N+1)),b,N-wi-1)));
		Ans=min(Ans,max(DFS(a,(wi+1)*(b/(N+1)),wi),DFS(a,(N-wi)*(b/(N+1)),N-wi-1)));
	}
	Map[bf]=Ans;
	return Ans;
}


int main()
{
	Input();
	RTL a,b;
	a.second=b.second=1;
	a.first=X;
	b.first=Y;
	double Ans=DFS(a,b,N-1);
	printf("%.6lf",Ans);
	return 0;
}

```




---

## 作者：MaxDYF (赞：5)

这题看过去，一时间还真没有什么头绪……

但是，经过洛谷题解和CSDN的各位巨佬的讲解之后，我也初步明白了怎么做。

这题，其实是一个**DFS（或是递归）标准题**。其实，我们只需要设置状态DFS(x,y,n)表示将长为x,宽为y的长方形蛋糕，切成n块的最小比值。

由于每一块蛋糕的面积必须是相等的，所以当我们要切成n块时，长最小是x/n，宽最小是y/n。所以，我们只要枚举把蛋糕按长和宽切成两块的最大值，取其中的最小值即可。边界条件：n==1时，返回x/y。

### AC代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
double decom(double x,double y,int n)
{
	if(n==1) return max(x,y)/min(x,y);
	double dx=x/n,dy=y/n;
	double ans=233333333.00000;
	for(double i=1.0;i<=(n/2.0);i+=1.0)
	{
		double t=max(decom(dx*i,y,i),decom(x-dx*i,y,n-i));
		double p=max(decom(x,dy*i,i),decom(x,y-dy*i,n-i));
		ans=min(ans,min(t,p));
	}
	return ans;
}
int main()
{
	double x,y;
	int n;
	cin>>x>>y>>n;
	printf("%.6lf",decom(x,y,n));
}
```

---

## 作者：小黑AWM (赞：3)

屑题，不过窃以为题面具有较强的误导性，容易让人想偏，第一眼二分答案，后来发现不是很具有单调性，然后又因为读错题面写了个二进制枚举（以为只能一块一块切过去切的每块都是$1/n$

读懂之后并不是很难。看到数据范围，考虑搜索。

考虑*只有两种切法*：

### 即沿着x切或沿着y切

并且对于没一刀切下去，必然把这块蛋糕切成两块，又由于最后切完之后的每块蛋糕都是$1/n$的面积。

易知切出来的两块蛋糕必定是$k/n + (n-k)/n , k \in N$

所以我们便可以枚举$k$进行多情况拓展。

可以顺手加个简单的记忆化优化，虽然并不是很有必要。
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
typedef pair<double,pair<double ,int> > pddi; 
double x, y;
int n;
map<pair<double,pair<double ,int> >, double> memory;
double dfs(double x, double y, int num){
    pddi temp = make_pair(x,make_pair(y, num));
    if(memory.count(temp))
        return memory[temp];
    double ans = 1000000.0;
    if(num == 1)
        return max(x, y)/min(x, y);
    for(int i = 1; i <= num-1; i++)
        ans = min(ans, max(dfs(x, y*i/num, i), dfs(x, y*(num-i)/num, num-i)));//切y有两种状态，切两分
    for(int i = 1; i <= num-1; i++)
        ans = min(ans, max(dfs(x*i/num, y, i), dfs(x*(num-i)/num, y, num-i))); 
    memory[temp] = ans;
    return ans;
}
int main(){
    scanf("%lf%lf%d", &x, &y, &n);
    printf("%.6lf", dfs(x, y, n));
    return 0;
}
```

---

## 作者：小钻钻钻石 (赞：1)

# ~~蒟蒻题解系列~~
~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~ ~~          
  
   
      
        
          
            
            
以下为大佬可以省略的内容:

这道题我一眼看上去非常像最近在学的dp算法，但是老师正在重复讲dfs呀！！！

所以大家不要被题面给吓住了

还有一点就是要有小数，我采用了double类型

用printf+%.6f 

但是cout还是不行的，会全部爆紫RE，所以用的printf，但是因为我刚开始在网上看到了double，所以就没用%.6f

~~因为本蒟蒻不会保留小数，还要上网查一下~~

# AC代码放上

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
int a,b,c;
double s;
double dfs(double x,double y,int n)
{
    if(n==1)
    {
        return max(x/y,y/x);
    }
    double ans=0x7fffffff;
    for(int i=1;i<=n/2;i++)
    {
        double kkksc=x*i/n,chenzhe=y*i/n;
        ans=min(ans,max(dfs(kkksc,y,i),dfs(x-kkksc,y,n-i)));  
        ans=min(ans,max(dfs(x,chenzhe,i),dfs(x,y-chenzhe,n-i)));  
    }
    return ans;
}
int main()
{
    scanf("%d%d%d",&a,&b,&c);
    s=(a*b)/c;
    printf("%lf",dfs(a,b,c));
    return 0;
}
```

---

## 作者：IRipple (赞：1)

小蒟蒻被这个~~毒瘤~~搜索搞了好久orz [题目链接](https://www.luogu.org/problemnew/show/P4160)

首先数据范围，$n≤10$很容易想到搜索。

对于这个搜索我们可以枚举每一刀切到的位置，~~我考场上没想到枚举的分度值是怎么搞就GG了~~（其实枚举了$10$ $^-$ $^5$也一样GG了）

这个分度值其实很好想，因为每一块面积都是已知的，切一刀时平行于刀的那条边长度是不变的。因此枚举切割所在边的n等分点就可以了。

之后在代码实现上，需要注意用dfs返回值保存答案，对切开的两份取max。

```
	double xx=x*i/dep;//dep是当前正在几等分
	double yy=y*i/dep;
	ans=min(ans,min(max(dfs(i,xx,y),dfs(dep-i,x-xx,y)),max(dfs(i,x,yy),dfs(dep-i,x,y-yy))));
    //返回横切纵切两种方法的最小值，对切法中切开的两段取max
```
然后当递归到最底层时，其比值一定是两个边之比的最大值

```
if(dep==1){
		return max(x/y,y/x);
}
```
其实这个题想清楚也不是很难（果然是我太菜了QwQ）

完整代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
double dfs(int dep,double x,double y){
    if(dep==1){
        return max(x/y,y/x);
    }
    double ans=1e10;
    for(int i=1;i<=dep/2;i++){//只需要枚举一半
        double xx=x*i/dep;
        double yy=y*i/dep;
        ans=min(ans,min(max(dfs(i,xx,y),dfs(dep-i,x-xx,y)),max(dfs(i,x,yy),dfs(dep-i,x,y-yy))));
    }
    return ans;
    
}
int main(){
    //freopen("cake.in","r",stdin);
    //freopen("cake.out","w",stdout);
    cin>>x>>y>>n;
    printf("%.6lf",dfs(n,x,y));
    return 0;
}
```


---

## 作者：G_A_TS (赞：0)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10346991.html)  

------------
本题可以用~~大法师~~DFS氵过(虽然我一开始想的是DP)  
易证x上分割点(姑且把ta当点)>=x/n,y同理  
然后dfs(当前某边长,其邻边长,需分几块)  
~~愉快的大法师即可~~  
上代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int IP1,IP2,IP3;
double dfs(double x,double y,int n)
{
	if(n==1)
	{
		return max(x,y)/min(x,y);//所求为长边比短边,边界为需分出1块(不需分?)
	}
	double ans=9999999999,mx=x/n,my=y/n;//mx(y)=minx(y)？
	for(int i=1;i<=n/2;i++)
	{
		ans=min(ans,max(dfs(mx*i,y,i),dfs(x-mx*i,y,n-i)));
		ans=min(ans,max(dfs(x,my*i,i),dfs(x,y-my*i,n-i)));
	}
	return ans;
}
int main()
{
	cin>>IP1>>IP2>>IP3;//IP即input
	printf("%.6lf",dfs(IP1,IP2,IP3));
} 
```

---


# [JSOI2016] 扭动的回文串

## 题目描述

JYY 有两个长度均为 $N$ 的字符串 $A$ 和 $B$。

一个扭动字符串 $S(i,j,k)$ 由 $A$ 中的第 $i$ 个字符到第 $j$ 个字符组成的子串与 $B$ 中的第 $j$ 个字符到第 $k$ 个字符组成的子串拼接而成。

比如，若 $A= \mathtt{XYZ}$，$B= \mathtt{UVW}$，则扭动字符串 $S(1,2,3)=\mathtt{XYVW}$。

JYY 定义一个扭动的回文串为如下情况中的一个：

1. $A$ 中的一个回文串；
2. $B$ 中的一个回文串；
3. 或者某一个回文的扭动字符串 $S(i,j,k)$。

现在 JYY 希望找出最长的扭动回文串。

## 说明/提示

**样例解释**
最佳方案中的扭动回文串如下所示（不在回文串中的字符用 . 表示）：

```pain
.BC..
..ECB
```

对于所有的数据，$1 \leq n \leq 10 ^ 5$

## 样例 #1

### 输入

```
5
ABCDE
BAECB```

### 输出

```
5```

# 题解

## 作者：Rain_cyl (赞：3)

前两种情况直接哈希+二分。

对于第三种情况，只需在确定中心点后，先在原本的串上找到最长的回文串，再分别到 $sa$ 和 $sb$ 上扩展。

可以证明这是最优的，因为如果你从原本串上非最长的回文串开始扩展，那如果要达到原来的长度，就需要 $sa$ 和 $sb$ 有更长的一段是回文的，显然不优。

例如：
$$sa = \texttt{DEABCBAX}$$
$$sb = \texttt{XYZUVWED}$$
      
那若 $sa$ 的 $\texttt{C}$ 为中心点，选最长的 $\texttt{ABCBA}$ 开始扩展，可以得到 $\texttt{DE}$ 和 $\texttt{ED}$ 是回文的;

而如果从 $\texttt{BCB}$ 开始扩展，要达到原来长度，就要求 $\texttt{DEA}$ 和 $\texttt{WED}$ 回文，但并非回文，因此不优。

时间复杂度 $O(n\log n)$。

目前题解中长度最短的代码：
```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N=1e5+5,P=13331;

int n;
char sa[N],sb[N];
ULL p[N],ha[N],rha[N],hb[N],rhb[N];

int getH(ULL h[],int l,int r){
    return h[r]-h[l-1]*p[r-l+1];
}

int getlen(ULL h[],ULL rh[],int ll,int rr){ //正着的是h，从ll往左，反着的是rh，从rr往右
    int l=0,r=min(ll,n-rr+1);
    while(l<r){
        int mid=l+r+1>>1;
        if(getH(h,ll-mid+1,ll)==getH(rh,n-rr-mid+2,n-rr+1)) l=mid;
        else r=mid-1;
    }
    return l;
}

int main(){
    scanf("%d%s%s",&n,sa+1,sb+1);
    p[0]=1;
    for(int i=1; i<=n; i++){
        p[i]=p[i-1]*P;
        ha[i]=ha[i-1]*P+sa[i];
        hb[i]=hb[i-1]*P+sb[i];
    }
    for(int i=n; i; i--){
        rha[n-i+1]=rha[n-i]*P+sa[i];
        rhb[n-i+1]=rhb[n-i]*P+sb[i];
    }
    
    int res=1;
    for(int i=2; i<n; i++){ //回文串长为奇数
        int la=getlen(ha,rha,i,i),lb=getlen(hb,rhb,i,i);
        res=max(res,la*2-1+getlen(ha,rhb,i-la,i+la-1)*2);
        res=max(res,lb*2-1+getlen(ha,rhb,i-lb+1,i+lb)*2);
    }
    for(int i=1; i<n; i++){ //回文串长为偶数
        int la=getlen(ha,rha,i,i+1),lb=getlen(hb,rhb,i,i+1);
        res=max(res,la*2+getlen(ha,rhb,i-la,i+la)*2);
        res=max(res,lb*2+getlen(ha,rhb,i-lb+1,i+lb+1)*2);
    }
    
    printf("%d",res);
    return 0;
}
```

---

## 作者：shinzanmono (赞：3)

省流：PKUSC2024D1T1。

前两种情况直接二分哈希即可，关键在于第三种情况。

我们对于每个回文中心，找出最大的回文半径，然后再向下继续拓展，可以证明这样的做法一定是正确的。

证明：

假设以 $p$ 为回文中心的最长回文串长度为 $x$，即拐点为 $p+x-1$，我们会从 $p+x-1$ 和 $p-x$ 分别向右和向左拓展。如果缩小 $x$ 至 $y$，那么会从 $p+y-1$ 和 $p-y$ 分别拓展。很显然，如果想要达到原来一样的长度，充要条件是 $down_{p+y-1\ldots p+x-2}=\mathrm{rev}(up_{p-x+1\ldots p-y})$，	显然不优。

```cpp
#include<iostream>
#include<algorithm>
const int sz=1e5+10;
const unsigned base=151;
unsigned u[sz],d[sz],iu[sz],id[sz],pows[sz];
bool check(unsigned *o,int r,unsigned *d,int dr,int len){
    return o[r]-o[r-len]*pows[len]==d[dr]-d[dr-len]*pows[len];
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::string s,t;
    std::cin>>n>>s>>t,s=" "+s,t=" "+t;
    pows[0]=1;
    for(int i=1;i<=n;i++)pows[i]=pows[i-1]*base;
    for(int i=1;i<=n;i++)u[i]=u[i-1]*base+s[i];
    for(int i=1;i<=n;i++)d[i]=d[i-1]*base+t[i];
    std::reverse(s.begin()+1,s.end());
    std::reverse(t.begin()+1,t.end());
    for(int i=1;i<=n;i++)iu[i]=iu[i-1]*base+s[i];
    for(int i=1;i<=n;i++)id[i]=id[i-1]*base+t[i];
    int ans=1;
    for(int i=1;i<=n;i++){
        int l=1,r=std::min(i,n-i+1);
        while(l<r){
            int mid=l+r+1>>1;
            if(check(u,i,iu,n-i+1,mid))l=mid;
            else r=mid-1;
        }
        l=i-l,r=i+r-1;
        int bl=0,br=std::min(l,n-r+1);
        while(bl<br){
            int mid=bl+br+1>>1;
            if(check(u,l,id,n-r+1,mid))bl=mid;
            else br=mid-1;
        }
        ans=std::max(ans,r-l+2*bl);
    }    
    for(int i=1;i<=n;i++){
        int l=1,r=std::min(i,n-i+1);
        while(l<r){
            int mid=l+r+1>>1;
            if(check(d,i,id,n-i+1,mid))l=mid;
            else r=mid-1;
        }
        l=i-l+1,r=i+r;
        int bl=0,br=std::min(l,n-r+1);
        while(bl<br){
            int mid=bl+br+1>>1;
            if(check(u,l,id,n-r+1,mid))bl=mid;
            else br=mid-1;
        }
        ans=std::max(ans,r-l+2*bl);
    }
    for(int i=1;i<n;i++){
        int l=0,r=std::min(i,n-i);
        while(l<r){
            int mid=l+r+1>>1;
            if(check(u,i,iu,n-i,mid))l=mid;
            else r=mid-1;
        }
        l=i-l,r=i+r;
        int bl=0,br=std::min(l,n-r+1);
        while(bl<br){
            int mid=bl+br+1>>1;
            if(check(u,l,id,n-r+1,mid))bl=mid;
            else br=mid-1;
        }
        ans=std::max(ans,r-l+2*bl);
    }    
    for(int i=1;i<n;i++){
        int l=0,r=std::min(i,n-i);
        while(l<r){
            int mid=l+r+1>>1;
            if(check(d,i,id,n-i,mid))l=mid;
            else r=mid-1;
        }
        l=i-l+1,r=i+r+1;
        int bl=0,br=std::min(l,n-r+1);
        while(bl<br){
            int mid=bl+br+1>>1;
            if(check(u,l,id,n-r+1,mid))bl=mid;
            else br=mid-1;
        }
        ans=std::max(ans,r-l+2*bl);
    }
    std::cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：fede (赞：1)

# 前言

这道题非常练手，是一道~~很好的题~~。

# 正文

## 分析

**扭动的回文串**有三种情况：
1. 仅用 $A$ 中的字符
2. 仅用 $B$ 中的字符
3. $A$ 和 $B$ 中的字符都用

### 第一、二两种情况

对于第一种和第二种情况，很经典的二分哈希。   
可以二分的原因是：设 $S$ 是回文串，将 $S$ 的头和尾各删去一个字符得到 $S_1$，那么 $S_1$ 也一定是一个回文串，如回文串 `TLELT` 与 `LEL`。

### 第三种情况

对于第三种情况，我们要着重分析一下。

$O(n^3)$ 的代码十分好想，若 $S(x,y,z)$，那么我们枚举每一个 $x,y,z$，在判断其实不是回文串即可。

但是显然，这样的时间复杂度实在太高了。

于是我们想到，$S(x,y,z)$ 中，我们只要枚举 $x$ 和 $y$ 就可以了，枚举了 $x$ 和 $y$，在通过回文串的性质二分长度，就能够完成第三种情况，时间复杂度 $O(n^2\log n)$。

然而，时间复杂度还是不足以通过本题，我们还要再次优化。

既然 $z$ 的枚举是可以优化掉的，那么 $x$ 的枚举是否同样可以优化呢？

为了优化掉 $x$，则枚举 $y$ 对本题的贡献实在太小了，于是将枚举 $y$ 换成枚举回文串的中点位置 $i$。

此时有了疑惑，那 $y$ 要怎么找呢？   
答案很简单，我们枚举了回文串的中点位置，然后就可以二分出 $y$ 的位置，就像字符串 `ABCDCBG`，当枚举到了 $i=3$，我们就可以二分出仅在一个串中的最大回文半径 $len_1$，也就等同于找到了 $y$，然后我们二分在两个串的回文半径 $len_2$，从 $i$ 向左向右拓展 $len_2$，我们也就可以从 $y$ 分到第二个串。然后我们就得到了正解，时间复杂度 $O(n\log n)$。

可以找个样例证明这种做法：   
$A=\mathtt{ABCDCBH}$   
$B=\mathtt{EDGCDAE}$   
当我们遍历到中点 $i=4$，我们二分找到了 $A$ 的不算中心点最大回文半径 $len_1=1$，然后在向下拓展到 $B$，再进行二分，于是就找到了真正的最大回文半径 $len_2=3$，答案即为 $7$。

我们打算分到第二个串，一定是越晚分越好。   
因为要是 $i+len_1$ 的位置提前到 $x$ 的位置向下分也是成立的，那么为了提前分的达到 $len_1$ 的长度，则 $B$ 从 $x$ 到 $i+len_1-1$ 的子串 $B_1$ 要与 $A$ 从中点 $x+1$ 到 $i+len_1$ 的子串  $A_1$ 相同，显然不优。

## 思路

**Hash**

分类讨论，我们首先要区分回文串中点在 $A$ 串还是在 $B$ 串，还要再区分回文串长度的奇偶。

因此我们要写 $10$ 种 $check$：

|序号|情况|中点位置|长度|范围|
|:-:|:-:|:-:|:-:|:-:|
|①|第一种|||仅在 $A$ 串|
|②|第二种|||仅在 $B$ 串|
|③|第三种|在 $A$ 串|奇数|仅在 $A$ 串|
|④|第三种|在 $A$ 串|奇数|全部|
|⑤|第三种|在 $A$ 串|偶数|仅在 $A$ 串|
|⑥|第三种|在 $A$ 串|偶数|全部|
|⑦|第三种|在 $B$ 串|奇数|仅在 $B$ 串|
|⑧|第三种|在 $B$ 串|奇数|全部|
|⑨|第三种|在 $B$ 串|偶数|仅在 $B$ 串|
|⑩|第三种|在 $B$ 串|偶数|全部|

当然也可以合并几个 $check$。

## 代码

很考验代码能力，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int p=31;
const int mod=1e9+7;
const int N=2e5+10; 
int n,ans;
int pw[N];
inline int calc(int x){
	return n-x+1;
}
inline int mm(int x){
	return (x%mod+mod)%mod;
}
struct ha{
	int hsh[N];
	int gethsh(int j,int i){
		if(j>i){
			return -1;
		}
		if(j<=0){
			return -1;
		}
		return (hsh[i]-hsh[j-1]*pw[i-j+1]%mod+mod)%mod;
	}
};
ha a1,a2,b1,b2;
bool check1(int mid){
	for(int i=1;i<=n-mid+1;i++){
		if(a1.gethsh(i,i+mid-1)==a2.gethsh(n-(i+mid-1)+1,n-i+1)){
			return 1;
		}
	}
	return 0;
}
bool check2(int mid){
	for(int i=1;i<=n-mid+1;i++){
		if(b1.gethsh(i,i+mid-1)==b2.gethsh(n-(i+mid-1)+1,n-i+1)){
			return 1;
		}
	}
	return 0;
}
bool check3(int len,int x){
	if(len==0){
		return 1;
	}
	return a1.gethsh(x-len,x-1)==a2.gethsh(calc(x+len),calc(x+1));
}
bool check4(int len,int x,int y){
	if(len==0){
		return 1;
	}
	if(x==y){
		return a1.gethsh(x-len,x-1)==mm(b2.gethsh(calc(x+len-1),calc(y)));
	}
	return a1.gethsh(x-len,x-1)==mm(mm(b2.gethsh(calc(x+len-1),calc(y))*pw[y-x])+a2.gethsh(calc(y),calc(x+1)));
}
bool check5(int len,int x){
	if(len==0){
		return 0;
	}
	return a1.gethsh(x-len+1,x)==a2.gethsh(calc(x+len),calc(x+1));
}
bool check6(int len,int x,int y){
	if(len==0){
		return 0;
	}
	if(y==x){
		return a1.gethsh(x-len+1,x)==mm(mm(b2.gethsh(calc(x+len-1),calc(y))));
	}
	return a1.gethsh(x-len+1,x)==mm(mm(b2.gethsh(calc(x+len-1),calc(y))*pw[y-x])+a2.gethsh(calc(y),calc(x+1)));
}

bool check7(int len,int x){
	if(len==0){
		return 1;
	}
	return b2.gethsh(calc(x+len),calc(x+1))==b1.gethsh(x-len,x-1);
}
bool check8(int len,int x,int y){
	if(len==0){
		return 1;
	}
	if(x==y){
		return b2.gethsh(calc(x+len),calc(x+1))==mm(a1.gethsh(x-len+1,y));
	}
	return b2.gethsh(calc(x+len),calc(x+1))==mm(mm(a1.gethsh(x-len+1,y)*pw[x-y])+b1.gethsh(y,x-1));
}
bool check9(int len,int x){
	if(len==0){
		return 0;
	}
	return b2.gethsh(calc(x+len-1),calc(x))==b1.gethsh(x-len,x-1);
}
bool check10(int len,int x,int y){
	if(len==0){
		return 0;
	}
	if(y==x){
		return b2.gethsh(calc(x+len-1),calc(x))==mm(mm(a1.gethsh(x-len+1,y)));
	}
	return b2.gethsh(calc(x+len-1),calc(x))==mm(mm(a1.gethsh(x-len+1,y)*pw[x-y])+b1.gethsh(y,x-1));
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	pw[0]=1;
	for(int i=1;i<N-1000;i++){
		pw[i]=mm(pw[i-1]*p);
	}
	string s1,s2;
	cin>>n>>s1>>s2;
	s1=' '+s1;
	s2=' '+s2;
	for(int i=1;i<=n;i++){
		a1.hsh[i]=mm(mm(a1.hsh[i-1]*p)+(s1[i]-'A'+1));
		a2.hsh[i]=mm(mm(a2.hsh[i-1]*p)+(s1[calc(i)]-'A'+1));
		b1.hsh[i]=mm(mm(b1.hsh[i-1]*p)+(s2[i]-'A'+1));
		b2.hsh[i]=mm(mm(b2.hsh[i-1]*p)+(s2[calc(i)]-'A'+1));
	}
	int l=1,r=n;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check1(mid)){
			l=mid;
		}else if(check1(mid+1)){
			l=mid;
		}else{
			r=mid;
		}
	}
	if(check1(r)){
		ans=max(ans,r);
	}else{
		ans=max(ans,l);
	}
	l=1,r=n;
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check2(mid)){
			l=mid;
		}else if(check2(mid+1)){
			l=mid;
		}else{
			r=mid;
		}
	}
	if(check2(r)){
		ans=max(ans,r);
	}else{
		ans=max(ans,l);
	}
	for(int i=1;i<=n;i++){
		int len;
		l=0,r=i-1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check3(mid,i)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check3(r,i)){
			len=r;
			ans=max(ans,r+r+1);
		}else{
			len=l;
			ans=max(ans,l+l+1);
		}
		l=len,r=i-1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check4(mid,i,i+len)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check4(r,i,i+len)){
			ans=max(ans,r+r+1);
		}else{
			ans=max(ans,l+l+1);
		}
	} 
	for(int i=1;i<=n;i++){
		int len;
		l=0,r=i;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check5(mid,i)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check5(r,i)){
			len=r;
			ans=max(ans,r+r);
		}else{
			len=l;
			ans=max(ans,l+l);
		}
		l=len,r=i;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check6(mid,i,i+len)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check6(r,i,i+len)){
			ans=max(ans,r+r);
		}else{
			ans=max(ans,l+l);
		}
	} 
	for(int i=1;i<=n;i++){
		int len;
		l=0,r=i-1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check7(mid,i)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check7(r,i)){
			len=r;
			ans=max(ans,r+r+1);
		}else{
			len=l;
			ans=max(ans,l+l+1);
		}
		l=len,r=i-1;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check8(mid,i,i-len)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check8(r,i,i-len)){
			ans=max(ans,r+r+1);
		}else{
			ans=max(ans,l+l+1);
		}
	}
	for(int i=1;i<=n;i++){
		int len;
		l=0,r=i;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check9(mid,i)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check9(r,i)){
			len=r;
			ans=max(ans,r+r);
		}else{
			len=l;
			ans=max(ans,l+l);
		}
		l=len,r=i;
		while(l+1<r){
			int mid=(l+r)>>1;
			if(check10(mid,i,i-len)){
				l=mid;
			}else{
				r=mid;
			}
		}
		if(check10(r,i,i-len)){
			ans=max(ans,r+r);
		}else{
			ans=max(ans,l+l);
		}
	} 
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：ran_qwq (赞：1)

提供一个巨好想，但巨难调的两只 log 做法。

前置知识：判一个串是否回文可以用从左到右哈希和从右到左哈希判等，一个串最长回文串可以枚举中点然后二分+哈希。问题就是第三种可以扭动的情况。

还是枚举中点 $x$，有这么几种情况：

1. 中点在两串中间。
1. 中点在第一个串。
1. 中点在第二个串。

第一种是简单的，一个二分搞定。第二种和第三种极其类似，这里只说第二种。

显然也可以二分出长度 $len$，这样可以确定起点 $s$ 和终点 $t$。问题就在于转折点 $y$ 在哪里，这需要满足：

- 以 $x$ 为中点，$y\sim x$ 长度为半径的字符串是回文串。
- $y\sim t$ 的字符串和以 $s$ 为起点与之同长度的字符串是相等的。

这两个条件都满足单调性，一个是从 $x$ 开始到某个临界点 $p$ 的区间，一个是从 $t$ 开始到另一个临界点 $q$ 的区间。

所以最终得到的 $y$ 集合是一个区间，只需要判断这个区间是否存在，即 $q\le p$ 即可。

两层二分，复杂度两只 log。

```cpp
#include<bits/stdc++.h>
#define il inline
#define ui unsigned int
#define ll long long
#define ull unsigned ll
#define lll __int128
#define db double
#define ldb long double
#define pii pair<int,int>
#define vi vector<int>
#define gi greater<int>
#define qi queue<int>
#define fir first
#define sec second
#define gc getchar
#define pc putchar
#define mst(arr,val) memset(arr,val,sizeof arr)
#define pb push_back
#define lb lower_bound
#define ub upper_bound
#define pct __builtin_popcount
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f,base=23333;
const ll INFll=0x3f3f3f3f3f3f3f3f;
il int rd() {int x=0,f=1; char ch=gc(); while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=gc();} while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=gc(); return x*f;}
il ll rdll() {ll x=0; int f=1; char ch=gc(); while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=gc();} while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=gc(); return x*f;}
il void wr(int x) {if(x<-2147483647) {printf("-2147483648"); return;} if(x<0) {pc('-'),wr(-x); return;} if(x<10) {pc(x+'0'); return;} wr(x/10),pc(x%10+'0');}
il void wrll(ll x) {if(x<-9223372036854775807) return (void)printf("-9223372036854775808"); if(x<0) return pc('-'),wrll(-x); if(x<10) return (void)pc(x+'0'); wrll(x/10),pc(x%10+'0');}
il void wr(int x,char *s) {wr(x),printf("%s",s);}
il void wrll(ll x,char *s) {wrll(x),printf("%s",s);}
int n,ans; ull pw[N],hshL[2][N],hshR[2][N]; char ch[2][N];
ull ccL(int k,int l,int r) {return hshL[k][r]-hshL[k][l-1]*pw[r-l+1];}
ull ccR(int k,int l,int r) {return hshR[k][l]-hshR[k][r+1]*pw[r-l+1];}
int fd1(int k,int x) {
	int l=0,r=min(x-1,n-x),mid;
	while(l<=r) mid=l+r>>1,ccL(k,x-mid,x+mid)==ccR(k,x-mid,x+mid)?l=mid+1:r=mid-1;
	return r<<1|1;
}
int fd2(int k,int x) {
	int l=1,r=min(x,n-x),mid; if(ch[k][x]!=ch[k][x+1]) return 0;
	while(l<=r) mid=l+r>>1,ccL(k,x-mid+1,x+mid)==ccR(k,x-mid+1,x+mid)?l=mid+1:r=mid-1;
	return r<<1;
}
int chk3(int x,int y,int z) {
	int s=x-z,t=x+z-1,l=0,r=z,mid; if(ch[0][s]!=ch[1][t]) return 0;
	while(l<=r) mid=l+r>>1,ccL(0,s,s+mid)==ccR(1,t-mid,t)?l=mid+1:r=mid-1;
	return s+r+1>=x-y;
}
int chk4(int x,int y,int z) {
	int s=x-z+1,t=x+z-1,l=0,r=z,mid; if(ch[0][s]!=ch[1][t]) return 0;
	while(l<=r) mid=l+r>>1,ccL(0,s,s+mid)==ccR(1,t-mid,t)?l=mid+1:r=mid-1;
	return s+r>=x-y;
}
int chk5(int x,int y,int z) {
	int s=x-z+1,t=x+z,l=0,r=z,mid; if(ch[0][s]!=ch[1][t]) return 0;
	while(l<=r) mid=l+r>>1,ccL(0,s,s+mid)==ccR(1,t-mid,t)?l=mid+1:r=mid-1;
	return t-r-1<=x+y;
}
int chk6(int x,int y,int z) {
	int s=x-z+2,t=x+z,l=0,r=z,mid; if(ch[0][s]!=ch[1][t]) return 0;
	while(l<=r) mid=l+r>>1,ccL(0,s,s+mid)==ccR(1,t-mid,t)?l=mid+1:r=mid-1;
	return t-r-1<=x+y;
}
int fd3(int x) {
	int len=fd1(0,x)-1>>1,l=len+1,r=min(x-1,n-x+1),mid;
	while(l<=r) mid=l+r>>1,chk3(x,len,mid)?l=mid+1:r=mid-1;
	return r<<1|1;
}
int fd4(int x) {
	int len=fd2(0,x)>>1,l=len+1,r=min(x,n-x+1),mid; if(ch[0][x]!=ch[0][x+1]) return 0;
	while(l<=r) mid=l+r>>1,chk4(x,len,mid)?l=mid+1:r=mid-1;
	return r<<1;
}
int fd5(int x) {
	int len=fd1(1,x)-1>>1,l=len+1,r=min(x,n-x),mid;
	while(l<=r) mid=l+r>>1,chk5(x,len,mid)?l=mid+1:r=mid-1;
	return r<<1|1;
}
int fd6(int x) {
	int len=fd2(1,x)>>1,l=len+1,r=min(x+1,n-x),mid; if(ch[1][x]!=ch[1][x+1]) return 0;
	while(l<=r) mid=l+r>>1,chk6(x,len,mid)?l=mid+1:r=mid-1;
	return r<<1;
}
int fd7(int x) {
	int l=1,r=min(x-1,n-x),mid; if(ch[0][x]!=ch[1][x]) return 0;
	while(l<=r) mid=l+r>>1,ccL(0,x-mid,x)==ccR(1,x,x+mid)?l=mid+1:r=mid-1;
	return l<<1;
}
void QwQ() {
	n=rd(),scanf("%s%s",ch[0]+1,ch[1]+1),pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=pw[i-1]*base;
	for(int i=0;i<2;i++) for(int j=1;j<=n;j++) hshL[i][j]=hshL[i][j-1]*base+ch[i][j];
	for(int i=0;i<2;i++) for(int j=n;j;j--) hshR[i][j]=hshR[i][j+1]*base+ch[i][j];
	for(int i=1;i<=n;i++) ans=max({ans,fd1(0,i),fd1(1,i),fd3(i),fd5(i),fd7(i)});
	for(int i=1;i<n;i++) ans=max({ans,fd2(0,i),fd2(1,i),fd4(i),fd6(i)});
	wr(ans,"\n");
}
signed main() {
	int T=1; while(T--) QwQ();
}
```

---

## 作者：wuxigk (赞：0)

现有题解好像都带个 $\log$，这里给个线性时间解法。前两种情况用Manacher算法可以直接做到线性，因此主要关注第三种情况。

可以注意到如下性质：**存在某个最长扭动回文串，其 $AB$ 分界线到回文中心的距离等于回文中心在原串中的最长回文半径**。

证明是直观的：任意考虑一个最长扭动回文串，如果它已经满足这一性质，则结束，否则不妨设回文中心在 $A$ 中。将分界线不断地向右移动，可以发现只要不移出最长回文半径的范围，得到的串就不会改变，因此可以一直把分界线移到最长回文半径处，得到一个最长且满足性质的扭动回文串。

上述性质说明可以通过扩展极长回文子串的方式得到答案，由此得到一个 $O(n\log{n})$ 的做法，即枚举每个回文中心，以最长回文半径为下界做二分，用字符串哈希判断是否回文。

为了消掉 $\log$，可以维护当前已知的最大长度，枚举回文中心时先对最大长度加一用字符串哈希 $O(1)$ 时间判断一下，如果不回文说明不可能更优，如果回文就逐字符扩展，直到不回文，稍微分析一下就会发现这部分用时是线性的。

核心代码如下：
```cpp
int solve(const string& a, const string& b) {
	int n = a.length();
	string aa("#"), raa("#"), rbb("#");
	for (int i = 0; i < n; i++) {
		aa += a[i];
		aa += '#';
		raa += a[n - i - 1];
		raa += '#';
		rbb += b[n - i - 1];
		rbb += '#';
	}
	n = 2 * n + 1;
	auto man = manacher(aa);
	str_hash hash(aa), hrash(raa), hrbsh(rbb);
	int mx = 1;
	for (int i = 1; i < n; i++) {
		mx = max(mx, man[i]);
		if (i + mx >= n)
			continue;
		auto lh = hash.substr_hash(i - mx, i);
		auto rhl = hrash.substr_hash(n - i - man[i] - 1, n - i - 1), rhr = hrbsh.substr_hash(n - i - mx + 1, n - i - man[i]);
		pair<int, int> rh{ (rhl.first + 1LL * rhr.first * hash.pow1[man[i] + 1] % mod1) % mod1,(rhl.second + 1LL * rhr.second * hash.pow2[man[i] + 1] % mod2) % mod2 };
		if (lh.first != rh.first || lh.second != rh.second)
			continue;
		int d = mx + 1;
		while (i - d >= 0 && n - i - d + 1 >= 0 && aa[i - d] == rbb[n - i - d + 1])
			d++;
		mx = max(mx, d - 1);
	}
	return mx;
}
int main() {
	read<int>();
	string a, b;
	cin >> a >> b;
	auto ra = a, rb = b;
	reverse(ra.begin(), ra.end());
	reverse(rb.begin(), rb.end());
	cout << max(solve(a, b), solve(rb, ra));
	return 0;
}
```

---

## 作者：jr_zch (赞：0)

# 扭动的回文串

## 前言

发现题解区所有题解似乎都用了这个性质：

> 选定中心后在当前串上尽可能多的扩展一定不劣。

我做题的时候没有考虑去枚举回文中心，所以写一下我这个新做法。

## 解题思路

前两种都是模板，不再赘述，仅讨论第三种情况。

根据题目描述，最终答案所对应的回文串一定是前一段属于 $A$ 串，后一段属于 $B$ 串的。

![](https://cdn.luogu.com.cn/upload/image_hosting/u6gcdpbz.png)

先假定 $A$ 串所占的部分比 $B$ 串更长，于是可以把 $B$ 串部分对称过来得到中间一个更小的回文串。

![](https://cdn.luogu.com.cn/upload/image_hosting/e7lpc55r.png)

如果把字符串 $S$ 翻转后的新字符串记为 $S^R$，那么答案串一定是由这三个串组成的：

- 一个属于 $A$ 的字符串 $S$。
- 一个属于 $A$ 或 $B$ 的**回文串**。
- 一个属于 $B$ 的字符串 $S^R$。

考虑枚举 $S$ 的起点位置，设 $ans_i$ 表示 $S$ 以 $i$ 为起点时，整个串的最长长度，**需要注意的是，左右两边的字符串和中间的回文串是可以为空的**。

那么当我们求出 $ans_i$ 之后，容易发现 $ans_{i+1}$ 可以沿用 $ans_i$ 的一部分（图中粉色段）。

![](https://cdn.luogu.com.cn/upload/image_hosting/721lntb8.png)

也就是说 $ans_{i+1} \geq ans_i-2$。

移项得 $ans_{i} \leq ans_{i+1}+2$。

考虑从后往前求解 $ans$ 这样在求解当前 $ans$ 时就已经知道上界了，可以直接暴力枚举 $ans$ 去判断可不可行，时间复杂度可以用类似 $\text{KMP}$ 的方法去证，这其实是一个很常见的 $\text{trick}$。

现在问题变成了已知起点和答案长度，判断是否可行。

令上图中紫色括号长度为 $len$，因为中间的是回文串，显然当 $len$ 较小时存在方案，则 $len$ 较大时一定也存在方案，考虑二分出最大的 $len$ 使得前后两个串互为相反的关系，用字符串 $\text{hash}$ 可以做到 $O(1)$ 去 $\text{check}$。

最后我们就可以计算出中间的回文串两端点分别在 $A$ 串和 $B$ 串中的下标，如果**存在至少一个**串是回文就可以统计进答案。

总时间复杂度 $O(n \log n)$。

### Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=1e5+7;
int n,ans;
char s[maxn],t[maxn];

//字符串 hash 
struct hash_table{
	int seed,mod;
	int base[maxn],f[maxn],g[maxn];
	void init(int _seed,int _mod,char *p){
		seed=_seed,mod=_mod,base[0]=1;
		for(int i=1;i<=n;i++) base[i]=base[i-1]*seed%mod;
		for(int i=1;i<=n;i++) f[i]=(f[i-1]*seed+p[i])%mod;
		for(int i=n;i;i--) g[i]=(g[i+1]*seed+p[i])%mod;
		return ;
	}
	int query_f(int l,int r){
		return (f[r]-f[l-1]*base[r-l+1]%mod+mod)%mod;
	}
	int query_g(int l,int r){
		return (g[l]-g[r+1]*base[r-l+1]%mod+mod)%mod;
	}
	bool check(int l,int r){
		if(l>r||l>n||r>n) return 0;
		int mid=l+r>>1;
		if((r-l+1)%2) return query_f(l,mid)==query_g(mid,r);
		else return query_f(l,mid)==query_g(mid+1,r);
	}
}a,b;

signed main(){
	scanf("%lld%s%s",&n,s+1,t+1);
	a.init(233,998244853,s);
	b.init(233,998244853,t);
	//第 1 种情况 
	for(int i=1;i<=n;i++){
		int l=1,r=min(n-i+1,i),res=0;
		while(l<=r){
			int mid=l+r>>1;
			if(a.query_f(i-mid+1,i)==a.query_g(i,i+mid-1)) res=max(res,2*mid-1),l=mid+1;
			else r=mid-1;
		}
		l=1,r=min(n-i,i);
		while(l<=r){
			int mid=l+r>>1;
			if(a.query_f(i-mid+1,i)==a.query_g(i+1,i+mid)) res=max(res,mid<<1ll),l=mid+1;
			else r=mid-1;
		}
		ans=max(ans,res);
	}
	//第 2 种情况 
	for(int i=1;i<=n;i++){
		int l=1,r=min(n-i+1,i),res=0;
		while(l<=r){
			int mid=l+r>>1;
			if(b.query_f(i-mid+1,i)==b.query_g(i,i+mid-1)) res=max(res,2*mid-1),l=mid+1;
			else r=mid-1;
		}
		l=1,r=min(n-i,i);
		while(l<=r){
			int mid=l+r>>1;
			if(b.query_f(i-mid+1,i)==b.query_g(i+1,i+mid)) res=max(res,mid<<1ll),l=mid+1;
			else r=mid-1;
		}
		ans=max(ans,res);
	}
	//第 3 种情况 从后往前枚举起点 
	for(int i=n,pre=0;i;i--){
		//计算答案上界 
		int now=min(pre+2,n-i+2);
		//枚举答案 
		while(now>=2){
			int j=now+i-2,l=1,r=now/2,res=0;
			//二分出最远紫色段长度 
			while(l<=r){
				int mid=l+r>>1;
				if(a.query_f(i,i+mid-1)==b.query_g(j-mid+1,j)) res=mid,l=mid+1;
				else r=mid-1; 
			}
			//特判两头为空 
			if(!res&&(a.check(i,i+now-1)||b.check(i,i+now-1))) break;
			int len=now-res-res;
			//特判中间为空 
			if(!len) break;
			//判断中间串是否可以成为回文 
			if(a.check(i+res,i+res+len-1)||b.check(i+res-1,i+res+len-2)) break;
			now--;
		}
		pre=now;
		ans=max(ans,now);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Inui_Sana (赞：0)

来个考场上的 $O(n\log n)$ 二分哈希做法。

看到回文串，想到先选定回文中心。如果只有一个序列自然是可以直接二分的。但是有两个序列还要选一个折点。怎么选？

我们发现在回文中心所在序列向两端拓展尽可能远是不劣的。钦定中心在 $A$，如果可以先换行走到 $B_i$，又可以直接走到 $A_i$，因为两种走法到 $B_i$ 的距离是相同的，所以可以直接走到 $A_i$ 再一步到 $B_i$。反过来，如果先换行，就不能走回去。

所以先确定中心，二分出最长回文半径，找到折点，再在这个基础上进行一次二分，求出最大答案。

自然溢出 hash 其实是可以的，只要给每个字符赋一个随机权值就行。

还有一个小处理就是发现这样无法解决回文串长为偶数的情况，所以我们可以把字符串变成这样（以样例为例）：

```
*A*B*C*D*E**
**B*A*E*C*B*
```

就可以解决了。

code：

```cpp
int n,m;
ull c[207],f[N][2],g[N][2],pw[N];
char str[N],s[N],t[N];
mt19937 rnd(time(0));
const ull base=114514191811ull;
il ull getHash(int l,int r,int op,int fl){
	if(!fl){
		if(!op){
			return f[r][0]-f[l-1][0]*pw[r-l+1];
		}
		return f[l][1]-f[r+1][1]*pw[r-l+1];
	}
	if(!op){
		return g[r][0]-g[l-1][0]*pw[r-l+1];
	}
	return g[l][1]-g[r+1][1]*pw[r-l+1];
}
void Yorushika(){
	scanf("%d%s",&n,str+1);
	rep(i,1,n){
		s[i+i-1]='*',s[i+i]=str[i];
	}
	s[n+n+1]=s[n+n+2]='*';
	scanf("%s",str+1);
	rep(i,1,n){
		t[i+i+1]=str[i],t[i+i]='*';
	}
	t[1]=t[n+n+2]='*';
	n=n+n+2;
	rep(i,0,200){
		c[i]=1ull*rnd()*rnd()*rnd()*rnd();
	}
	pw[0]=1;
	rep(i,1,n){
		pw[i]=pw[i-1]*base;
	}
	rep(i,1,n){
		f[i][0]=f[i-1][0]*base+c[s[i]];
		g[i][0]=g[i-1][0]*base+c[t[i]];
	}
	drep(i,n,1){
		f[i][1]=f[i+1][1]*base+c[s[i]];
		g[i][1]=g[i+1][1]*base+c[t[i]];
	}
	int tans=0;
	rep(i,1,n){
		int l=1,r=min(i,n-i+1),ans=1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(getHash(i-mid+1,i+mid-1,0,0)==getHash(i-mid+1,i+mid-1,1,0)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		int L=i-ans+1,R=i+ans-1;
		l=0,r=min(L-1,n-R+1),ans=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(getHash(L-mid,L-1,0,0)==getHash(R,R+mid-1,1,1)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		tans=max(tans,i-L+1+ans);
	}
	rep(i,1,n){
		int l=1,r=min(i,n-i+1),ans=1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(getHash(i-mid+1,i+mid-1,0,1)==getHash(i-mid+1,i+mid-1,1,1)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		int L=i-ans+1,R=i+ans-1;
		l=0,r=min(L,n-R),ans=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(getHash(L-mid+1,L,0,0)==getHash(R+1,R+mid,1,1)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		tans=max(tans,i-L+1+ans);
	}
	printf("%d\n",tans-1);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---

## 作者：xzCyanBrad (赞：0)

PKUSC2024 Day1T1

有一个非常重要的性质就是直接在最长回文半径上拓展一定有最优值。

证明：

>  考虑回文中心点 $i$ 在往下的那个点 $j$ 左边的情况（即 $i<j$），右边或 $i=j$ 可以类似考虑。设 𝑖*i* 的最长回文半径为 $l$。那么显然 $j\le i+l$。
>
> 那么我们可以发现，$B_j$ 必须等于 $A_{2i-j-1}$，同理 $B_{j+1}=A_{2i-j-2}$，以此类推，$B_{i+l-1}=A_{i-l}$。又因为 $\forall k\in[i,i+l],A_k=A_{2i-k}$，所以 $A_{i+l}=A_{i-l}$。我们可以发现，要想这个中心点 $i$、下去点 $j$ 的情况成为答案，$B_{i+l-1}=A_{i+l}$。
>
> 但是这样，原来的方案下一步拓展必须是 $B_{i+l}$。这也可以由 $A_{i+l}$ 来完成，并且也合法。综上，原方案被采用最长回文半径的方法完美覆盖，故采用最长回文半径的情况中一定有最优值。
>
> 证毕。

这样我们就把候选答案的范围从 $\Theta(n^2)$ 级别变成了 $\Theta(n)$ 级别。直接求出每个最长回文半径（可以二分哈希），然后往底下继续二分哈希地拓展，就结束了。复杂度 $\Theta(n\log n)$，注意他（Ta）卡（ka）哈（ha）希（shi），模数不能自然溢出，推荐 $10^9+23$。

代码被 PKU 吃了。

---


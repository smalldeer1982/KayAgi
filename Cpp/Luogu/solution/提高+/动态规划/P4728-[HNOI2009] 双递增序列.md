# [HNOI2009] 双递增序列

## 题目描述

考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \dots, a_n$ 的一个划分 $U=\{ a_{i_1}, a_{i_2}, \dots, a_{i_{n/2}} \}, V=\{ a_{j_1}, a_{j_2}, \dots, a_{j_{n/2}} \}=\{ a_1, a_2, \dots, a_n \}-U$，且 $i_1<i_2< \dots <i_{n/2}, a_{i_1}<a_{i_2}< \dots <a_{i_{n/2}}, j_1<j_2< \dots <j_{n/2}, a_{j_1}<a_{j_2}< \dots <a_{j_{n/2}}$。

比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\{3, 4, 8\}, V=\{1, 5, 7\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。

现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。


## 说明/提示

对于 $10\%$ 的数据，$n \le 100$。  
对于 $40\%$ 的数据，$n \le 300$。  
对于 $100\%$ 的数据，$1 \le n \leq 2000$，$1 \le m \leq 25$，$0 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
2
6 3 1 4 5 8 7
6 3 2 1 6 5 4```

### 输出

```
Yes!
No!```

# 题解

## 作者：Ryo_Yamada (赞：18)

这题“思维难度极高，代码难度极低”。

这题的状态定义非常神仙，用我们老师的话来说就是转移的艺术qaq。

对于枚举过的前 $i$ 个元素，若分成 $2$ 个子序列，必定有一个子序列的末尾是 $A_i$。所以首先可以想到，对于 $dp_i$，表示前 $i$ 个元素已经枚举，有一个子序列的末尾是 $A_i$。

当然这些不够，再加一维：对于 $dp_{i,j}$，表示表示前 $i$ 个元素已经枚举，有一个子序列的末尾是 $A_i$，其中不包含 $A_i$ 的子序列长度为 $j$ ，则包含 $A_i$ 的子序列长度为 $i-j$，用 $dp_{i,j}$ 表示该子序列末尾的最小值。

这样，我们就用两维的状态表示出了四个信息，最终答案是 $dp_{n, \frac{n}{2}}$。

再考虑转移：

- $A_i < A_{i+1}$：此时将 $A_{i+1}$ 拼接在 $A_i$ 后面，转移方程： $dp_{i+1,j+1}=\min(dp_{i+1,j+1}, dp_{i,j})$。
- $dp_{i,j} < A_{i+1}$：此时将 $A_{i+1}$ 拼接在另一个序列上面。为符合我们对状态的定义，我们需交换两个序列。转移方程：$dp_{i+1,i-j+1}=\min(dp_{i+1,i-j+1}, a_i)$。

最后，$dp$ 数组初始值全部设为 $+\infty$，$dp_{1,1}=-\infty$，时间复杂度 $O(n^2)$。

$\text{Code}$：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int inf = 0x3f3f3f3f;
const int N = 2005; 

int T, n;
int a[N], dp[N][N];

int main() {
	cin >> T;
	while(T--) {
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) scanf("%d", a + i);
		memset(dp, 0x3f, sizeof dp);
		dp[1][1] = -inf;
		for(int i = 1; i < n; i++) {//由于我的转移是转移i+1，所以i<n。
			for(int j = 1; j <= min(n / 2, i); j++) {//剪去无用状态
				if(a[i] < a[i + 1]) dp[i + 1][j + 1] = min(dp[i][j], dp[i + 1][j + 1]);
				if(a[i + 1] > dp[i][j]) dp[i + 1][i - j + 1] = min(a[i], dp[i + 1][i - j + 1]);//转移
			}
		}
		if(dp[n][n / 2] == inf) puts("No!");
		else puts("Yes!");
	}	
	return 0;
}
```


---

## 作者：aakennes (赞：6)

# 题面描述

大概意思是要我们把给定序列划分为两个长度相同的不下降序列，由于本题数据很水，给出两种错解和一种正解

# 解法1（错解）：求$LIS$（最长不下降子序列）

## 思路：

根据$Dilworth$定理，最长链剖分 $=$ 最长反链长度，具体证明略，其最经典的应用为导弹拦截

开题一看，最长不下降子序列，很容易想到$LIS$的模型，那么如何转化呢？

这样想：要把整个序列划分为两个序列，其实就是两条链，可以直接应用$Dilworth$定理，求一下最长下降子序列，最后判断一下序列长度即反链个数是否为$2$。当然，这里我们假定两条正链的长度对本题结果没有影响，因为长链中的元素**大部分**可补到短链

## 代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e3+6,INF=0x3f3f3f3f;
int n,m,f[maxn],a[maxn];
int main(){
    cin>>m;
    while(m--){
        memset(f,0,sizeof(f));
        cin>>n;
        int ans=0;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            for(int j=1;j<i;j++){
                if(a[i]<a[j])f[i]=max(f[i],f[j]+1),ans=max(ans,f[i]);
            }//LIS板子，二分优化也行
        }
        if(ans>1)cout<<"No!"<<endl//由于初始化值为0，所以反链个数为ans+1
        else cout<<"Yes!"<<endl;
    }
}
```

## 缺陷：

很明显，$LIS$的正确性无法证明，先上一组$hack$数据

```
6 2 6 1 3 4 5
```

正确答案为$No$，$LIS$跑出的答案确实$Yes$

在前面我们假定正链的长度对结果并无影响，但显然是存在错误的，如上面一组数据中，正链分别为：$2$ $6 $和 $1$ $3$ $4$ $5$，但第二条长链中并不能把其中的元素分到第一条短链

# 解法2（错解）： 贪心 $+$ 队列

## 思路：

粗暴的来想，我们倒序枚举整个序列，把最后一个元素插入到地一个队列中，然后往前查找，如果能找到比第一个队列队首大的元素，就另开一个队列存，然后把小于第一队列队首的放入第一队列中，反之反到第二队列中。最后进行调整的操作，如果较长队列中的元素能放入第一队列中，就放，直到扫完整个队列（不合理情况）或两队列长度相等（合理情况）。但其正确性显然无法保证，$hack$数据同上

## 代码：

```


#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5+10;

struct node{
	int id,v;
}a[maxn],cur[maxn],q[maxn];

int now,cnt;
int flag;

int main(){
	int T;scanf("%d",&T);
	while(T--){
		int n;scanf("%d",&n);
		flag = 0;
		now = 0;
		cnt = 0;
		for(int i = 1;i <= n;++i){
			scanf("%d",&a[i].v);
			a[i].id = i;
		}
		for(int i = n;i;--i){
			if(cnt && a[i].v > q[cnt].v){
				if(!now){
					cur[++now].v = a[i].v;
					cur[now].id = a[i].id;
					continue;
				}
				if(a[i].v > cur[now].v){
					flag = 1;
					break;
				}
				if(a[i].v <= cur[now].v){
					cur[++now].v = a[i].v;
					cur[now].id = a[i].id;
					continue;
				}
			}
			q[++cnt].v = a[i].v;
			q[cnt].id = a[i].id;
		}
		if(flag == 1){printf("No!\n");continue;}
		if(cnt == n/2){printf("Yes!\n");continue;}
		if(cnt < n/2){swap(cur,q);swap(now,cnt);}
		if(cnt > n/2){
			int count = cnt;
			for(int i = cnt;i;--i){
				int v = q[i].v;
				int Id = q[i].id;
				for(int j = now;j;--j){
					if((j != now && cur[j + 1].v <= v && cur[j].v >= v && cur[j + 1].id < Id && cur[j].id > Id) || (j == now && v <= cur[j].v && Id < cur[j].id) || (j == now && v >= cur[j].v && Id > cur[j].id))count--;
					if(count == n/2){flag = 1;printf("Yes!\n");break;}
				}
				if(flag)break;
			}
			if(!flag)printf("No!\n");
		}
	}
	return 0;
}

```

# 解法3（正解）：

引用带佬原话

"
实际上是划分成两个集合
当从前往后考虑的时候，肯定有一个集合是有$a_i$这个元素的
所以设 $f_{i,j}$ 表示考虑到第 $i$ 位，其中含有第 $a_i$ 的集合大小为j，此时只关注另外一个集合的最大值。
目的是让另外一个集合的最大值尽量小，这样更能方便进行转移，所以 f_{i,j} 的取值为另一个集合的最大值最小能是多少。
转移只要考虑

$1.$ $a_i <= a_{i+1}$ ，那么可以直接给 $j+1$ 转移到下一位

$2.$ $f_{i,j} <= a_{i+1}$ ，那么可以交换两个集合转移
" 

——————某巨强预备国集带佬



* 难点一：状态的定义。一般$f_{i,j}$在这类类似$LIS$的题中都定义为前$i$个数选了$j$个的最优情况，显然在这题中能这么用，即前$i$个元素且第一序列选了$j$个，末尾元素为$a_{i}$的第二序列的长度，这样能进行状态的转移
* 难点二（/stars /stars /stars）：第二个转移条件。由于我们定义$a_{i}$一直在第一个序列中，显然无法对第二个序列产生影响。此时考虑轻微改变定义：$f_{i,j表示}$前$i$个元素，末尾元素为$a_{i}$的序列选了$j$个元素，这样就可以在转移中交换两个序列操作，以此改变两个序列

### 状态转移方程：

 $if(a[i]<a[i+1])f[i+1][j+1]=min(f[i+1][j+1],f[i][j]);$//把$a[i+1]$接上	

 $if(f[i][j]<a[i+1])f[i+1][i-j+1]=min(f[i+1][i-j+1],a[i]);$//交换序列让原来不放$a_{i+1}$的序列放上$a_{i}$
    
## 代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e3+5;
int a[maxn],f[maxn][maxn],n;
int main(){
	int T;
	cin>>T;
	while(T--){
		memset(f,0x3f,sizeof(f));
		cin>>n;
		for(int i=1;i<=n;++i)cin>>a[i];
		f[1][1]=-1; 
		for(int i=1;i<n;++i){//题解里貌似没有刷表的，这里我用的刷表
			for(int j=1;j<=n>>1&&j<=i;++j){
				if(a[i]<a[i+1])f[i+1][j+1]=min(f[i+1][j+1],f[i][j]);
				if(f[i][j]<a[i+1])f[i+1][i-j+1]=min(f[i+1][i-j+1],a[i]);
			}
		}
		puts(f[n][n>>1]==0x3f3f3f3f?"No!":"Yes!");
	}
	return 0;
}

```

---

## 作者：redegg (赞：5)

这题主要是状态定义。

我们可以定义$dp[i][j][k][l]$是$1$序列的末尾是$i$，$2$序列的末尾是$j$，$1$序列选了$k$个，2序列选了$l$个，明显转移是会超时的。

但是大家会发现，状态可以省略到$dp[i][j][k]$，因为如果我们知道现在$2$个序列的长度总和为$i$，$1$序列选了$k$个，则$2$序列一定是$i-k$个。

但是这样依然会超时。。。

我们能不能只枚举$2$维呢？

我们会发现上面定义的状态，$dp[i][j][k]$的存在意义仅仅是表示这样的状态成立（也就是$dp$是个$bool$类型），而实际上我们可以存更多的东西。

我们设定$dp[i][j]=k$表示做到第$i$个位置，且$i$为$1$序列末尾，$1$序列里$j$个元素，$dp[i][j]$为$2$序列的末尾的可能的最小值，也就是$k$,因为$1$序列和$2$序列无差异(名字不同而已)。

若我们做到$i$,发现$a[i]>a[i-1]$,那么第一种转移是$dp[i][j]=dp[i][j-1]$，若我们发现$dp[i][j]>dp[i-1][i-j]$（$i-j$表示i-1的时候2序列的长度，2后来和1序列交换了），我们就可以把二序列和一序列交换然后更新。

一开始dp为不合法，无穷大，只有必选的为0；

```
#include <bits/stdc++.h>
using namespace std;


int t;
int n;
int a[2006];
int dp[2005][2005];

int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1; i<=n; i++)
            scanf("%d",&a[i]);

        memset(dp,0x3f,sizeof(dp));

        dp[1][0]=a[1];
        dp[2][1]=a[1];
        dp[2][0]=a[2];
        dp[2][2]=0;
        dp[1][1]=0;

        for(int i=3; i<=n; i++)
        {
            dp[i][0]=a[i];
            for(int j=0; j<=i; j++)
            {
                if(a[i]>a[i-1]&&j-1>=0)
                    dp[i][j]=min(dp[i-1][j-1],dp[i][j]);
                if(a[i]>dp[i-1][i-j]&&i-j>=0)
                    dp[i][j]=min(a[i-1],dp[i][j]);
            }
        }
        if(dp[n][n/2]<100000000)
        {
            printf("Yes!\n");
        }
        else
            printf("No!\n");
    }
    return 0;
}

```

---

## 作者：zfio (赞：4)


原文：[欢迎来玩](https://www.cnblogs.com/Zfio/p/13364440.html)

## 讲解

**这题相当邪乎。。。**

一开始看到这题，同班的大佬们一直认为就是一道 $Dilworth$ 定理的水题，于是一发LIS，都不用带优化的就过了。。。

然而这真的对吗，并不对。。。虽然数据能过，但是他的正确性是无法证明的，事实上有位大佬给出了hack数据，但是我并没看到。。。

所以说去网上看正解，但是死活理解不了，比如洛谷里大佬的那篇题解，光是那堆初始化就看的我一脸懵。代码也不带打个注释的   ~~（明明自己菜还要喷别人）~~

所以，还是要靠自(da)己(lao)啊(感恩wzx)。

从暴力到优化的思路大家可以参考那篇题解，这里只介绍一下正解(我以为的)。

我们重新定义一下 $f$ 数组：

**$f[i][j]=k$ 表示，前 $i$ 个数中，含有 $a[i]$ 的一个集合长度为 $j$，不含 $a[i]$ 的那个集合的最后一位的最小值，即 $k$ 。**

可能有点绕，但大家一定要好好理解一下，因为这道题完全就是在吃定义，如果无法理解定义的话是没办法做的。

我们简单的认为含 $a[i]$ 的那个集合为第一个集合，另一个为第二个集合。

理解之后我们来考虑如何转移。

我这里采用了刷表法，大家可以自己YY填表法。。。

我们枚举 $i$，对于每个 $i$，我们考虑 $i+1$，选择无非只有两种，一：把 $a[i+1]$ 接到含有 $a[i]$ 集合后面，二：把 $a[i+1]$ 接到另一个集合后面。

两个集合没有本质区别，所以第二个转移有一个很神奇的交换两个集合的操作，大家注意一下。

第一个转移：

把 $a[i+1]$ 接到含有 $a[i]$ 的那个集合后面，此时要满足 $a[i+1] >= a[i]$ （可能有人对这个>=有疑惑，理论上是>没错，不过可能是数据的问题这样写也行，主要是老师给题的时候说明了是单调不下降，这道题给的是上升，意会就好，下面也是同理）

转移方程为：$f[i+1][j+1]=min(f[i+1][j+1],f[i][j])$

为什么这么写呢，还是吃定义：我们维护的值是第二个集合的最后一位的最小值，我们在第一个集合后面接东西与他何关？所以直接取min

第二个转移：

把 $a[i+1]$ 接到不含 $a[i]$ 的那个集合后面，此时要满足 $a[i+1] >= f[i][j]$

转移方程为：$f[i+1][i-j+1]=min(f[i+1][i-j+1],a[i])$

我想大家可能对这个式子很迷惑，这都什么跟什么啊，~~我的 $f[i][j]$ 去哪里了qwq。~~

我们把 $a[i+1]$ 接到不含 $a[i]$ 的那个集合也就是第二个集合的后面，那么此时，第二个集合变成了对于 $i+1$ 而言的第一个集合，因为此时第二个集合最后一位是 $a[i+1]$ ，符合我们的第一个集合的定义，他的长度是 $i-j+1$，所以我们要更新 $f[i+1][i-j+1]$，为什么要用 $a[i]$ 来更新呢，因为此时原来的第二个集合变成了第一个集合，自然原来的第一个集合（结尾为 $a[i]$）就变成了现在的第二个集合。

然后这道题就基本结束了，要注意的是初始化 $f[1][1]=-1$，因为数据里可能有0。

转移时枚举 $j$ 从 1 到 $i$。

最后判断 $f[n][n/2]$ 是否被更新即可。

```c++
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
const int maxn = 2000 + 10;
inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-') w = -1; c = getchar();}
	while(c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
	return s * w;
}
int n, m;
int a[maxn];
int f[maxn][maxn];
int main(){
	m = read();
	while(m--){
		n = read();
		for(int i = 1; i <= n; i++)
			a[i] = read();
		memset(f, 0x3f, sizeof f);
		f[1][1] = -1;
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= i; j++){
				if(a[i + 1] >= a[i])
					f[i + 1][j + 1] = std:: min(f[i + 1][j + 1], f[i][j]);
				if(a[i + 1] >= f[i][j])
					f[i + 1][i - j + 1] = std:: min(f[i + 1][i - j + 1], a[i]);
			}
		}
		if(f[n][n / 2] > 1e7) printf("No!\n");
		else printf("Yes!\n");
	}
	return 0;
}

``` 

---

## 作者：panrui_SCZ (赞：3)

根据题目要求，容易发现我们得到的两个序列中是不能有任何逆序对的。考虑把原序列建成一张图，若原序列中 $a_i$ 和 $a_j$ 满足：
  $a_i>a_j$ 且 $i<j $，则在图的结点 $i$ 和 $j$ 之间建边。
  
  于是题目就被转化成：把一张图分成结点数相同的两部分，每一部分内部没有边相连。

  自然地考虑到二分图。若建出来的图不是二分图，则原序列一定不符合要求；若建出来的图是二分图，那么考虑将图中的每个连通块进行染色，分别记下每个连通块中被染成两种不同颜色的结点数。容易得知，要得出两个符合要求的子序列，必须存在一种方案，在每个连通块中取出一种颜色的结点，使得取出的所有结点数之和为 $\dfrac n2$。直接 dp 即可。
  
Code：
```cpp
//sxy bless pr
#include<bits/stdc++.h>
using namespace std;
int n,a[2005];
vector<int> e[2005];
int c[2005];
int cl[2005],now;
bool f[2005][4005];
bool dfs(int x,int co){
	if(c[x]) return true;
	c[x]=co;
	cl[co]++;
	bool flag=true;
	for(int i=0;i<e[x].size();i++){
		if(!c[e[x][i]]){
			flag=(dfs(e[x][i],now*2+1-co)&&flag);
		}
		else if(c[e[x][i]]==c[x]) return false;
	}
	return flag;
}
void solve(){
	scanf("%d",&n);
	memset(c,0,sizeof(c));
	memset(cl,0,sizeof(cl));
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) e[i].clear();
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(a[i]>=a[j]){
				e[i].push_back(j);e[j].push_back(i);
			}
		}
	}
	now=1;
	for(int i=1;i<=n;i++){
		if(!c[i]){
			if(!dfs(i,now)){
				puts("No!");
				return;
			}
			now+=2;
		}
	}
	memset(f,0,sizeof(f));
	f[1][cl[1]]=f[1][cl[2]]=1;
	for(int i=3;i<=now;i+=2){
		for(int j=0;j<=n;j++){
			f[i][j+cl[i]]|=f[i-2][j];
			f[i][j+cl[i+1]]|=f[i-2][j];
		}
	}
	if(f[now][n/2]) puts("Yes!");
	else puts("No!");
}
int main(){
	int m;
	cin>>m;
	for(int i=1;i<=m;i++) solve();
}
```

---

## 作者：chen_hx (赞：3)

## 这题的做法其实和以前大佬的很像，但是第二个那个交换序列的转移我太弱了真的想不到，所以在此提出新的转移方式  
状态定义：$f[len][i]$ 表示处理到第 $i$ 个数 $a[i]$ ，将其放入 $U$ 集合中，则此时 $V$ 集合内最后的元素的最小值。  

在此并不讨论把 $a[i]$ 放入的是 $U$ 还是 $V$ 集合，因为放不放入元素的是相对的，就是这个集合放入则那个集合不放入，反之亦然。因此将 $U$ 和 $V$ 对调也是没问题的 

## 转移：
分两种情况：  
①在 $f[len-1][i-1]$ 的基础上，将 $a[i]$ 直接加入集合，要求 $a[i]>a[i-1]$，这个跟前面的大佬是一样的  

② $f[len][i] = a[i-1]$ ，其实就是选取 $U$ 集合的上一个元素 $a[k]$ $0≤k≤i-1$），然后把 $a[k+1]$ 到 $a[i-1]$ 全部加入 $V$ 中，然后把 $a[i]$ 加入 $U$ 中，跟在 $a[k]$ 后面，要求  
1） $a[k]<a[i]$   
2） $a[k+1]$ 到 $a[i-1]$ 是严格单调递增的  
3） $a[k+1]>f[len-1][k]$，因为要把 $a[k+1]$ 接到 $f[len-1][k]$ 后面，就是放到 $V$ 后面  
## 实现：
 $sij[i]$ 表示 $a$ 中的 $k$ 项到 $i-1$ 项满足严格单调递增时 $k$ 的最小值，即 $a[sij[i]]$ 到 $a[i-1]$ 严格单调递增  
 不难发现对于 $a[i]$ 的转移一定有 $sij[i]-1≤k≤i-1$ 
 
 $t[i]$ 表示 $a[sij[i]-1]$ 到 $a[i-1]$ 中满足 $a[j]<a[i]$ 时 $j$ 的最大值  
 不难发现其实 $a[sij[i]]$ 到 $a[t[i]]$ 都是小于 $a[i]$ 的，当然如果 $sij[i]>t[i]$ 那就无法转移了 
 
那么第二种转移的条件就转换成：    

**对于长度为 $len$ 的每个 $i$ 在指定区间内是否存在$a[k+1]>f[len-1][k]$**  

若 $a[sij[i]-1]<a[i]$，则这个指定区间是 $[sij[i]-1,t[i]]$  
否则这个指定区间是 $[sij[i],t[i]]$  

是否存在 $a[k+1]>f[len-1][k]$ 这一条件其实与 $f[len]$ 这一维无关而与上一维 $f[len-1]$ 有关，因此在转移 $f[len]$ 时，哪些 $a[k+1]>f[len-1][k]$ 的条件已经存在了并且定了下来，因此可以在每一维转移前先处理出来，而询问区间的话只需要处理出前缀和就行了


因为第一项不好搞，就把 $f[][1]$ 先处理出来，而只有 $f[0][1]$ 和     $f[1][1]$ 是合法的，后面 $len$ 的都是非法的，所以在 dp 转移的时候就不用转移 $i=1$ 的情况了

（代码如下）

## 代码：


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||'9'<ch)f^=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?x:-x;
}
const int N=2005;
int f[N][N],n,m,a[N],sij[N],t[N],s[N],ok[N];
//f[j][i]：处理到a[i]，是U集合中第j个时，V集合最后一个元素的最小值 
void solve(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	memset(f,0x3f,sizeof(f));
	memset(t,-1,sizeof(t));
	memset(ok,0,sizeof(ok));
	sij[1]=1,f[0][0]=-1e18,f[1][1]=-1e18,f[0][1]=a[1];
   	//初始化一定不能是0，一定要小于0
	a[0]=-1e18;
	for(int i=2;i<=n;i++){
		sij[i]=1;
		for(int j=i-1;j>=1;j--){
			if(a[j-1]>=a[j]){
				sij[i]=j;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=sij[i]-1;j<=i-1;j++){
			if(a[j]<a[i])t[i]=j;
		}
	}
	for(int i=2;i<=n;i++){
		if(sij[i]==1){
			if(a[i]>a[i-1])f[0][i]=a[i];
		}
		else break;
	}
	for(int len=1;len<=n/2;len++){
		for(int k=0;k<=n;k++){
			if(a[k+1]>f[len-1][k])ok[k]=1;
			s[k]=s[max(0LL,k-1)]+ok[k];
		}
  		//ok[i]就是之前a[i+1]>f[len-1][i]是否成立
		for(int i=2;i<=n;i++){
			if(a[i]>a[i-1])f[len][i]=f[len-1][i-1];
			int down;
			if(a[i]>a[sij[i]-1])down=sij[i]-1;
			else down=sij[i];
           		//确定定区间[down,t[i]]
			if(t[i]>=down){
				if((down==0)?(s[t[i]]>0):(s[t[i]]-s[down-1]>0)){
                			//s[-1]不合法，要特判一下
					f[len][i]=min(f[len][i],a[i-1]);
				}
			}
		}
	}
	if(f[n/2][n]!=f[n][1])printf("Yes!\n");	//用来判断是否为0x3f
	else printf("No!\n");
}
signed main(){
	int T=read();
	while(T--)solve();
}
```


---

## 作者：nofind (赞：3)

## [题意](https://www.luogu.com.cn/problem/P4728)

这个DP状态有点神。

首先考虑一个最暴力的状态：$f_{i,j,k,u}$表示第一个选了$i$个，第二个选了$j$个，第一个结尾为$k$，第二个结尾为$u$是否可行。

现在考虑消减状态：  

1.首先知道了处理到第几个，那么只要知道一个长度就能推出另一个。 因此状态可以改为$f_{i,j,k,u}$表示处理到了第$i$个，第一个序列选了$j$个，第一个序列结尾为$k$,第二个序列结尾为$u$是否可行。（这并没有减少维数，只是转化下，方便处理。）

2.既然所有的数都要选，假设当前处理到了第$i$个，那么第$i-1$个必定在结尾，因此我们可以消去一维：  
$f_{i,j,k}$表示处理到第$i$个，结尾是$a_i$的那个序列长度为$j$，另一个结尾为$k$是否可行。

3.贪心地想，一个序列结尾越小越容易接数，因此可以将一维放到DP的值中：  
$f_{i,j}$表示处理到第$i$个，结尾是$a_{i-1}$的那个序列长度为$j$，另一个结尾最小是多少。

现在我们已经将DP减到二维，于是就可以转移了: 

$a_i>a_{i-1}$：此时$a_i$可以拼接在$a_{i-1}$后面：  
$f_{i,j}=\min(f_{i,j}f_{i-1,j-1})$。  

$a_i>f_{i-1,i-j}$：此时我们可以将$a_i$接到另一个序列后面，于是我们**交换**两个序列，因为另一个序列后面接了$a_i$，我们要符合定义，于是可得：  
$f_{i,j}=\min(f_{i,j},a_{i-1})$。

最后判断$f_{n,n/2}$是否为$inf$。

数据范围不知道，到某dark上看了看，$n\leqslant2000$。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2010;
int T,n;
int a[maxn];
int f[maxn][maxn];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		memset(f,0x3f,sizeof(f));
		f[0][0]=-1;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=min(n/2,i);j++)
			{
				if(a[i]>a[i-1])f[i][j]=min(f[i][j],f[i-1][j-1]);
				if(a[i]>f[i-1][i-j])f[i][j]=min(f[i][j],a[i-1]);
			}
		puts(f[n][n/2]<0x3f3f3f3f?"Yes!":"No!");
	}
	return 0;
}
```


---

## 作者：critnos (赞：3)

一个随机化乱搞做法

其实我觉得随机化挺有意义的，毕竟思维难度低。在省选上有限的时间推这题的 dp 不如写个随机化。

有一个非常好想的思路：

对 $a$ 扫一次，维护两个队列 $x,y$。一开始两个队列都为空，当扫到 $a_i$ 如果大于其中一个队列的末尾就说明可以加入这个队列。如果都不行则说明无解。

但是这样有个问题，就是当两个都可以时你不知道加哪一个。

那就随机。经过若干次的实验发现，如果 $[rand(0,p)+i<rand(0,p)]$ 则加入第一个队列这个函数的效果很好，$p$ 我取 $10$。

这里我后来看了代码才发现一个实现细节：最后没有判断队列长度是否为 $\dfrac n 2$。直接如果可以扫完就输出 `Yes!`。

这个东西看起来毫无正确性。。但它还是过了，事实上我也不是很清楚它为什么能过。

跑 30 次就没有大问题了。

```cpp
s=prea=preb=0;
for(j=1;j<=n;j++)
{
	if(a[j]>a[prea]&&a[j]>a[preb])
	{
		if(s+rand()%10<j-s-1+rand()%10)
			prea=j,s++;
		else
			preb=j;
	}
	else
	{
		if(a[j]>a[prea]) prea=j;
		else if(a[j]>a[preb]) preb=j;
		else break;
	}
}
```


---

## 作者：ListenSnow (赞：2)

## 题意

给出一个长度为**偶数**的序列，判断是否能将该序列分成**两个长度为 $\dfrac{n}{2}$ 的严格上升子序列**。

#### 数据范围

$1 \leq n \leq 2000$，$1 \leq m \leq 25$，$0 \le a_i \le 10^6$ 。

### 思路

首先发现本题有两个限制条件，一个条件是分成两个长度为 $\dfrac{n}{2}$ 的子序列。另一个条件是**严格单调递增**。

对于第二个条件，可以想到一个贪心性质：相同长度子序列中，最后一个数字**最小**的最优。因为这样更容易在序列后面再扩充一个数（在[导弹拦截](https://www.luogu.com.cn/problem/P1020)中的 $O(n \log n)$ 做法就利用了这个贪心性质）。

同时可以发现，如果在前 $i$ 个数中选了 $j$ 个数到第一个序列中，那么剩下的 $i-j$ 个数就必然在另一个序列中。同时这两个序列都必须单调递增。由于只需要保证新选的数比当前序列的最后一个数大即可。故可以考虑动态规划：

设 $f[i][j]$ 表示在前 $i$ 个数中选了 $j$ 个数且 $a_i$ 在第一个序列中时的所有合法方案中，另一个序列的最后一个数的**最小值**（根据上面的贪心性质）。

初始时，将 $f$ 全部赋值为无穷大，再将 $f[1][1]$ 设成一个负数（因为此时另一个序列不存在，同时 $a_i \geq 0$）。

根据状态设计，从前 $i$ 个数转移到前 $i+1$ 个数需要分 $a_{i+1}$ 是否分到 $a_i$ 所在的序列进行讨论：

1.$a_i$ 和 $a_{i+1}$ 在同一个序列中。当然，前提条件是 $a_i < a_{i+1}$，此时另一个序列没有变化，得到转移方程：

$f[i+1][j+1]=\min(f[i+1][j+1],f[i][j])$

2.$a_i$ 和 $a_{i+1}$ 不在同一个序列中。那么也就是把 $a_{i+1}$ 放在最后一个数为 $f[i][j]$ 的序列中。也就能得到转移的前提条件是 $a_{i+1} > f[i][j]$，此时 $a_i$ 所在的长度为 $j$ 的序列没有发生变化，并且 $a_i$ 成了另一个序列的最后一个数，所以 $a_{i+1}$ 所在的序列长度就是 $i+1-j$。可以得到转移方程：

$f[i+1][i+1-j]=\min(f[i+1][i+1-j],a[i])$。

由于最终的两个序列长度都是 $n/2$，故最后只需要判断一下 $f[n][n/2]$ 是否为无穷大即可。
 
### code：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=2020;
const int INF=0x3f3f3f3f;
int n,a[N],f[N][N];
int min(int a,int b){return a<b?a:b;}
int main()
{
//    freopen("nlc.in","r",stdin);
	int T;scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		memset(f,0x3f,sizeof(f));
		f[1][1]=-1;
		for(int i=1;i<n;i++)
		    for(int j=1;j<=min(n/2,i);j++)
		    {
		    	if(a[i+1]>f[i][j]) f[i+1][i+1-j]=min(f[i+1][i+1-j],a[i]);
		    	if(a[i+1]>a[i]) f[i+1][j+1]=min(f[i+1][j+1],f[i][j]);
			}
//		printf("%d\n",f[n][n/2]);
		if(f[n][n/2]==INF) puts("No!");
		else puts("Yes!");       
	}
	return 0;
}
```


---

## 作者：zhendelan (赞：2)

看到$O(n^2)$能过还是先考虑dp吧。  

有一个显然的$O(n^4)$dp。  

设$f_{i,j,k,l}$为一个长度为$i$，另一个长度为$j$，最后一个分别为$k,l$是否可行。  

方程很简单，可以尝试自己推导。  

可行性转化为最优化，把$l$提到值域就可以做到$O(n^3)$。  

考虑到因为$a$中每个数都要取，$i,j$中必有一个最大值是$a_{i+j}$。  

所以我们只需要记录谁拿了最后一个。我们可以固定一定是$i$拿了最后一个。 

dp方程如下：  

$f_{i,j} \gets f_{i-1,j},a_{i+j}>a_{i+j-1}$  

$f_{i,j}\gets f_{j,i-1},a_{i+j}>f_{j,i-1}$  

$\gets$
表示更新。  

实际上就只有两种转移，第一种是$a_{pos}$由拿了$a_{pos-1}$的继续拿，另一种表示$a_{pos-1}$由没拿$a_{pos-1}$的拿了。  

```cpp
#include<bits/stdc++.h>
using namespace std;
#define debug(x) cerr<<#x<<':'<<x<<endl;
const int N = 1020;
const int inf = 1e6+20;
int f[N][N];
int a[N*2];
int main()
{
	int T,n;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		for(int i=0;i<=n/2;i++)
			for(int j=0;j<=n/2;j++)f[i][j]=inf;
		f[0][0] = -1;a[0] = -1;
		for(int pos=1;pos<=n;pos++)
		{
			for(int i=1;i<=pos&&i*2<=n;i++)
			{
				int j = pos-i;
				if(j>n/2)continue;
				if(a[pos]>a[pos-1])f[i][j]=min(f[i][j],f[i-1][j]);
				if(a[pos]>f[j][i-1])f[i][j]=min(f[i][j],a[pos-1]);
			}
		}
		if(f[n/2][n/2]!=inf)printf("Yes!\n");
		else printf("No!\n");
	}
	return 0;
}

```

---

## 作者：yzx72424 (赞：0)

**一道dp题目
**

注释很详细

```
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;//4个   一开始打成3个查了很长时间 
const int maxn=3500;
int f[maxn][maxn], a[maxn], m;//f[i][j]表示前i个数中选中i的序列长度为j的情况下，另一个序列的最大项
inline char nc(){//fread加速快读 
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){//快读 
    char ch=nc();int sum=0;
    while(!(ch>='0'&&ch<='9'))ch=nc();
    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();
    return sum;
}
int main(){
    int T;
    T=read();//T组数据 
    while(T--){
        m=read();
        for(int i=1;i<=m;i++)a[i]=read();
        a[0]=-1;
        memset(f,INF,sizeof(f));//初始化 
        f[0][0]=-1;
        for(int i=1;i<=m;i++)
            for(int j=0;j<=i;j++){
                if(f[i-1][i-j]<a[i])f[i][j]=a[i-1];
                if(a[i-1]< a[i])f[i][j]= min(f[i][j], f[i-1][j]);/*!!dp方程式
		f[i][j] = min{ f[i-1][j-1](a[i-1] < a[i])  ,a[i-1](f[i-1][i-j] < a[i])}
		*/
            }
     if(f[m][m/2]==INF){puts("No!");continue;}
       puts("Yes!");
    }
    return 0;
}
```


---


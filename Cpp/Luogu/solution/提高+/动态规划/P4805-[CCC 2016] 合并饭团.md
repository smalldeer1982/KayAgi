# [CCC 2016] 合并饭团

## 题目描述

**译自 [CCC2016](https://cemc.math.uwaterloo.ca/contests/computing/2016/index.html) Senior T4「[Combining Riceballs](https://cemc.math.uwaterloo.ca/contests/computing/2016/stage%201/seniorEn.pdf)」**

Alphonse 有 $N$ 个美味的饭团，它们大小不一，摆放成一行。他想把最大的饭团让给自己的基友。他可以执行以下操作：

 - 如果两个**相邻的**饭团大小相同，Alphonse 可以把它们合并成一个新的饭团。新饭团的大小是两个原饭团大小之和。它将占据两个原饭团先前占据的位置。

 - 如果两个饭团大小相同，且它们之间只有一个饭团，Alphonse 也可以把它们合并成一个新的饭团。（中间的饭团大小没有规定。）新饭团的大小是三个原饭团大小之和，并占据三个原饭团先前的位置。

Alphonse 可以按照他的意愿执行任意次操作。

在执行 0 或更多次操作后，确定他应该把哪个饭团让给基友。

## 说明/提示

#### 样例解释 1
有一种可能的合并方案为：合并大小同为 $12$ 的两个饭团，得到一个大小为 $24$ 的饭团。然后合并大小同为 $9$ 的两个饭团，得到一个大小为 $18$。接着合并大小为 $3,18$ 和 $3$ 的三个饭团，得到一个大小为 $24$ 的饭团。最后合并大小同为 $24$ 的两个饭团，得到一个大小为 $48$ 的饭团。

#### 样例解释 2
我们无法进行操作，所以答案为 $3$。

对于 $\frac1{15}$ 的数据，$N = 4$。

对于另外 $\frac2{15}$ 的数据，$N \le 10$。

对于另外 $\frac5{15}$ 的数据，$N \le 50$。

## 样例 #1

### 输入

```
7
47 12 12 3 9 9 3```

### 输出

```
48```

## 样例 #2

### 输入

```
4
1 2 3 1```

### 输出

```
3```

# 题解

## 作者：kai586123 (赞：37)

同时发布于个人Blog：[Baka's Blog](https://baka.online/ccc-2016%E5%90%88%E5%B9%B6%E9%A5%AD%E5%9B%A2/)

看到题目中的合并，可以发现本题是一道区间DP。

将合并分为合并两个饭团和合并三个饭团分开讨论。合并两个饭团的操作如同[石子合并](https://www.luogu.org/problemnew/show/P1880)这道题，复杂度$O(N^3)$，不再讨论。显然，合并两个饭团不是解决本题的瓶颈。

考虑合并三个饭团的暴力做法。在区间内枚举中间区间的左右端点，判断可否合并，复杂度$O(N^4)$，无法通过本题。

---

观察本题的特殊性质（下面提到的区间都是可由子区间合并而来的，即值非0）：

- 对于区间$[l, r]$，合并后区间$[l, r]$的值必为**原输入中的$[l, r]$段之和**。因为区间和一定，所以区间越长，区间值越大。

- 确定一个左端点$l$，那么对于右端点$r1 < r2 < r3 < ...$，有$[l, r1] < [l, r2] < [l, r3] < ... $，即**区间值具有单调性**。确定右端点同理。

所以，我们可以得到以下结论与方案：

- 在一个区间内，只要找到一种满足题目要求的合并方案，就可确定这段区间的值。可以以此减少循环次数。

- 在合并三个饭团时，若枚举到的中间区间为$[k, t]$，随着$k$与$t$向中间靠近，$[l, k - 1]$与$[t + 1, r]$逐渐增大。可以使用**双指针**，减少一层循环。

于是本题得解，时间复杂度$O(N^3)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, f[500][500], ans;

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> f[i][i];
        ans = max(ans, f[i][i]);
    }

    for (int len = 2; len <= n; ++len) {
        for (int l = 1, r = len; r <= n; ++l, ++r) {
            // 两个合并
            for (int k = l; k < r; ++k) {
                if (f[l][k] && f[k + 1][r] && f[l][k] == f[k + 1][r]) {
                    f[l][r] = f[l][k] + f[k + 1][r];
                    break;
                }
            }

            // 双指针，三个合并
            for (int k = l, t = r; k < t - 1; ) {
                if (f[l][r]) break;
                if (!f[l][k]) ++k;
                else if (!f[t][r]) --t;
                else if (f[l][k] == f[t][r]) {
                    if (f[k + 1][t - 1])
                        f[l][r] = f[l][k] + f[k + 1][t - 1] + f[t][r];
                    else ++k, --t;
                }
                else if (f[l][k] < f[t][r]) ++k;
                else if (f[l][k] > f[t][r]) --t;
            }
            ans = max(ans, f[l][r]);
        }
    }

    cout << ans << endl;
    return 0;
}
```



---

## 作者：Cx114514 (赞：11)

# 一道经典区间dp
看到大家都用的双指针，那我来个不一样的
### 分析
题目中有两种合并饭团的情况。    

1.如果两个相邻的饭团大小相同，Alphonse 可以把它们合并成一个新的饭团。新饭团的大小是两个原饭团大小之和。它将占据两个原饭团先前占据的位置。    

2.如果两个饭团大小相同，且它们之间只有一个饭团，Alphonse 也可以把它们合并成一个新的饭团。（中间的饭团大小没有规定。）新饭团的大小是三个原饭团大小之和，并占据三个原饭团先前的位置。   

我们先考虑情况1，这就是一道很普通的一个区间模板（详情看[P1880 石子合并](https://www.luogu.com.cn/problem/P1880)）。

重点在于情况2，我们需要在 $\left [ i, j \right ]$ 中枚举两个饭团，用来表示要合并在一起的三个饭团间的分界点（可以看成三个区间）。显而易见，时间复杂度是 $O\left (  n^{4} \right )$ 的，在这道题目的数据范围下明显是无法通过的。     
### 优化
我们可以发现，在枚举两个饭团时，明显有一些饭团是多余的（区间内的小饭团本身就无法合并为新饭团），那这样便会浪费很多时间。顺水推舟，我们可以使用 $vector[i]$ 来存储饭团 $i$ 可以与哪些饭团合并成新饭团。这样便可省去枚举无效状态的多余时间。

### 代码
```
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
	int f = 1;
	char c = getchar();
	while (!isdigit(c))
	{
	    if (c == '-') f = -1;
	    c = getchar();
    }
	int x = 0;
	while (isdigit(c))
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}//快读

int buf[15];

inline void write(int x)
{
	int p = 0;
	if (x < 0)
	{
	    putchar('-');
	    x = -x;
	}
	if (x == 0) putchar('0');
	else
	{
		while (x)
		{
			buf[++p] = x % 10;
			x /= 10;
		}
		for (int i = p; i >= 1; i--)
			putchar('0' + buf[i]);
	}
}//快写

int n, ans, a[405], s[405];

bool f[405][405];

vector < int > v[405];

int main()
{
	n = read();
	for (int i = 1; i <= n; i++)
		a[i] = read();
	for (int i = 1; i <= n; i++)
		s[i] = s[i - 1] + a[i];
	for (int i = 1; i <= n; i++)
	{
		ans = max(ans, a[i]);
		f[i][i] = 1;
		v[i].push_back(i);
	}
	for (int i = 1; i < n; i++)//枚举区间长度
		for (int j = 1; j <= n - i; j++)//枚举左端点
			for (int k = 0; k < v[j].size(); k++)//第一个饭团的可能性
			{
				if (f[v[j][k] + 1][j + i] && s[j + i] - s[v[j][k]] == s[v[j][k]] - s[j - 1])
				{
					f[j][j + i] = 1;
					v[j].push_back(j + i);
					ans = max(ans, s[j + i] - s[j - 1]);
					break;
				}//中间没有饭团间隔
				bool b = 0;
				for (int l = 0; l < v[v[j][k] + 1].size(); l++)//中间那个饭团的可能性
				{
					if (f[v[v[j][k] + 1][l] + 1][j + i] && s[j + i] - s[v[v[j][k] + 1][l]] == s[v[j][k]] - s[j - 1])
					{
						f[j][j + i] = 1;
						v[j].push_back(j + i);
						ans = max(ans, s[j + i] - s[j - 1]);
						b = 1;
						break;
					}
				}
				if (b) break;//如果该区间能取到饭团，那就不必继续枚举情况浪费时间，可直接跳出循环
			}
	write(ans);
	printf("\n");
    return 0;
}


```
初次提交发现会TLE两个点，开O2+快读快写可以卡过去。

## 既然都看到这里了，就点个赞吧


---

## 作者：Areka6219 (赞：10)

## 题意

题目要求实现两个操作：

1. 如果两个**相邻的**饭团大小相同，可以把它们合并成一个新的饭团。新饭团的大小是两个原饭团大小之和。
2. 如果两个饭团大小相同，且它们之间只有一个饭团，也可以把它们合并成一个新的饭团。

 ## 分析

- 对于 `1`  操作，我们发现，它和 [P1880 石子合并](https://www.luogu.com.cn/problem/P1880) 非常相似，只是把环变为了链，于是我们可以枚举断点 `k`，设当前区间左端点为 `l`，右端点为 `r`，当 $dp(l,k)=dp(k + 1，r)$ 时，我们认为区间 $[l,k]$ 和区间 $[k + 1, r]$ 的饭团可以合并。

- 对于 `2` 操作，我们发现，它是在 `1` 操作的基础上扩展为**两个相等饭团中间夹有一个饭团时**可以合并，于是我们想到枚举双指针 $k_1$、$k_2$，当 $dp(l,k_1) = dp(k_2, r)$ 时，我们认为三个区间 $[l,k_1]$ 、$[k_1 + 1,k_2 - 1]$ 、$[k_2, r]$ 的饭团可以合并。

- 注意到双指针的复杂度为 $O(n ^ 3) = 6.4 * 10 ^ 8$ 会超时，于是我们可以 吸 $O_2$ 过掉这道题。

- 注意以 `-1` 来判断不合法的情况。 

## Code

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  inline int read() {
      register int x = 0, f = 1;
      register char ch;
      while(!isdigit(ch = getchar())) (ch == '-') && (f = -1);
      for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));
      return x * f;
  }
  
  const int maxn = 401;
  
  int n, ans;
  int dp[maxn][maxn];
  
  signed main() {
      n = read();
  
      for(int i = 1; i <= n; ++i)
          for(int j = 1; j <= n; ++j)
              dp[i][j] = -1;
  
      for(int i = 1; i <= n; ++i)
          dp[i][i] = read(), ans = max(ans, dp[i][i]);
  
      for(int len = 1; len <= n; ++len)
          for(int l = 1; l + len <= n; ++l) {
              int r = l + len;
              
              for(int k = l; k < r; ++k) {
                  if(dp[l][k] == dp[k + 1][r] and dp[l][k] != -1)
                      dp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r]);
              }
  
              for(int k1 = l; k1 < r; ++k1) {
                  for(int k2 = r; k2 - 1 > k1; --k2) {
                      if(dp[l][k1] == dp[k2][r] and dp[k2][r] != -1 and dp[k1 + 1][k2 - 1] != -1)
                          dp[l][r] = max(dp[l][r], dp[l][k1] + dp[k1 + 1][k2 - 1] + dp[k2][r]);
                  }
              }
  
              ans = max(ans, dp[l][r]);
          }
      
      printf("%d\n", ans);
      
      #ifndef ONLINE_JUDGE
          getchar();
      #endif
      return 0;
  }
  ```

---

## 作者：wangif424 (赞：7)

锰锌的第一篇蓝题题解。

从合并石子过来，看到要合并区间，断定是一道区间动规题。

因为每个区间合并的结果就是这个区间所有元素的和，所以我们可以用一个前缀和数组维护区间和，再用 $f_{l,r} $ 维护 $[l,r]$ 是否能合并成一个区间。

#### 简明题意

对一个长度为 $n$ 的数组进行若干次合并操作，求合并后的最大值

题目中给出了两种合并操作：

- 将两个相邻且相等的数合并为一个数，这个数的值为这两个数之和。

- 若两个相等的数中间只隔了一个数，可以将这三个数合并为一个数，这个数的值为这三个数之和。

#### 统一两种操作

对于两种操作，我们分别要在 $[l,r]$ 枚举一个和两个断点，不难想到当操作二的两个断点重合时，就是操作一。

#### 完成代码

首先套用区间动规的标准写法，枚举长度，区间，断点，可以得出代码：

```cpp
	for(int len=1;len<n;len++){
		for(int l=1,r=l+len;l<n&&r<=n;r++,l++){
			for(int i=l;i<r&&!f[l][r];i++){
				if(s[i]-s[l-1]==s[r]-s[i] && f[l][i] && f[i+1][r])f[l][r]=1;
				for(int j=i+1;j<r&&!f[l][r];j++){
					if(f[i+1][j] && s[i]-s[l-1]==s[r]-s[j] && f[l][i] && f[j+1][r]){
						f[l][r]=1;
					}
				}
			}
		}
	}
```
吸口氧，提交，过啦！

关氧气，再来，超时啦！

- 超时思考~~卡常~~优化。

- 因为每个数都是正整数，所以每个区间能合并的最大值随区间的长度增长，具有**单调性**，可以使用**双指针**优化减少一维循环。

就此得出代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[401],s[401];
int f[401][401];
int ans;
inline int read(){
	register int r=0;register char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c<='9'&&c>='0')r=(r<<3)+(r<<1)+c-'0',c=getchar();
	return r;
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		f[i][i]=f[i][i-1]=1;
		s[i]=s[i-1]+a[i];
	}
	for(int len=1;len<n;len++){
		for(int l=1,r=l+len;l<n&&r<=n;r++,l++){
			int i=l,j=r;
			while(i+1<=j){
				while(((!f[j][r])||s[r]-s[j-1]<s[i]-s[l-1])&&j>i)j--;
				if(f[l][i]&&f[j][r]&&f[i+1][j-1]&&s[r]-s[j-1]==s[i]-s[l-1])f[l][r]=1;
				i++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(f[i][j])ans=max(ans,s[j]-s[i-1]);
		}
	}
	cout << ans;
	return 0;
}

```

提交，过啦！

---

## 作者：Wf_yjqd (赞：6)

区间 dp 好题，调了半晌。。

------------

考虑用 $dp_{i,j}$ 表示初始第 $i$ 个第 $j$ 个合成的饭团大小，若无法合成则为 $0$。

那么，输入的第 $i$ 个数即为 $dp_{i,i}$，接下来考虑如何进行合并。

首先考虑相邻两个的，直接从当前的左端点到右端点枚举，如果两边都能合成且大小相等，就可以进行合并。

三个的情况呢？考虑双指针再次枚举区间，因为两边的大小都是单调递增的，所以可以保证 $\operatorname{O}(n)$ 合并。

那总体复杂度就是 $\operatorname{O}(n^3)$ 的了。

------------
还是比较板的，应该没人看代码吧。。提防 `RE`。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,ll,rr,dp[484][484];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&dp[i][i]);
    for(int len=2;len<=n;len++){
        // if(len==3)
        //     puts("Sherry!!!");
        for(int l=1,r=0;r<n;l++){
            r=l+len-1;
            // printf("%d %d %d Sherry\n",l,r,len);
            for(int i=l;i<r;i++)
                if(dp[l][i]&&dp[l][i]==dp[i+1][r]){
                    dp[l][r]=dp[l][i]+dp[i+1][r];
                    break;
                }
            if(dp[l][r])
                continue;
            ll=l;
            rr=r;
            // printf("%d %d Sherry\n",ll,rr);
            while(ll<=rr-2){
                // puts("Sherry");
                while(!dp[l][ll]&&ll<=rr-2)
                    ll++;
                while(!dp[rr][r]&&ll<=rr-2)
                    rr--;
                if(dp[l][ll]<dp[rr][r])
                    ll++;
                else if(dp[l][ll]>dp[rr][r])
                    rr--;
                else if(!dp[ll+1][rr-1]){
                    ll++;
                    rr--;
                }
                else{
                    dp[l][r]=dp[l][ll]+dp[ll+1][rr-1]+dp[rr][r];
                    break;
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            ans=max(ans,dp[i][j]);
    printf("%d",ans);
    return 0;
}
```



---

## 作者：༺請༒癌༻ (赞：5)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[100010],f[1000][1000],ans=0;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) 
	scanf("%d",&a[i]),a[i]+=a[i-1],f[i][i]=1;
	
	for(int i=n-1;i;i--) 
	for(int j=i+1;j<=n;j++) {
		for(int k=i;k<j;k++) 
		if(a[j]-a[k]==a[k]-a[i-1]) f[i][j]|=f[i][k]&f[k+1][j];
		
		if(f[i][j]) continue;
		int l=i,r=j,s1=a[l]-a[l-1],s2=a[r]-a[r-1];
		while(l<r-1) {
			while(l<r-1&&s2<s1) r--,s2+=a[r]-a[r-1];
			if(s2==s1) f[i][j]|=f[i][l]&f[l+1][r-1]&f[r][j];
			l++;s1+=a[l]-a[l-1];
		}
		
	}
	
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j++)
	if(f[i][j]) ans=max(ans,a[j]-a[i-1]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Doraven (赞：4)

那么很明显可以看出这是一道区间DP题了，这里主要说一下方程。另外，合并两个与三个其实可以一起处理，不用像楼上说的那样分开。

具体来说，我们用$can[i][j]$表示i~j的范围能被合并，$s[i]$表示前缀和，采用区间DP的方式转移。
枚举长度及区间左右端点，区间内部再枚举点k，w，若发现有：

$(s[j]-s[w-1])==(s[k]-s[i-1])&&can[i][k]&&can[w][j]&&can[k+1][w-1]$

即说明i~j亦可合并，则赋值$can[i][j]=1$.

这样，我们就得到了易个初步的转移方法，代码如下：

```

for(int len=2;len<=n;len++)
	    for(int i=1;i+len-1<=n;i++)
	    {
	    	int j=i+len-1;
            int k,w;
	    	for(k=i;k<=j;k++)
	    	{
                for(w=k;w<=j;w++)
	    		if((s[j]-s[w-1])==(s[k]-s[i-1])&&can[i][k]&&can[w][j]&&can[k+1][w-1]) can[i][j]=1;
			}
		}
        
```
可惜，这个方法复杂度O(n^4),过不去，需优化。

注意$s[i]$递增（显然)，因此$s[j]-s[w-1]$与$s[k]-s[i-1]$ 是单调的。所以，不用枚举整个区间，只用开两个指针分别扫就行了，只有n个区间可能满足要求。
于是复杂度降为O(n^3).
代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int can[410][410],s[410],n,ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int k;
		cin>>k;
		s[i]=s[i-1]+k;
	}
	for(int i=1;i<=n;i++) can[i][i]=1,can[i][i-1]=1; //因为考虑合并两个时可能出现can[i][i-1],这里初始化就不用再讨论了。
	for(int len=2;len<=n;len++)
	    for(int i=1;i+len-1<=n;i++)
	    {
	    	int j=i+len-1;
	    	int k=i,w=j;  //双指针
	    	for(k;k<=j;k++)
	    	{
	    		while((s[j]-s[w-1])<(s[k]-s[i-1])&&w>=i) --w;
	    		if((s[j]-s[w-1])==(s[k]-s[i-1])&&can[i][k]&&can[w][j]&&can[k+1][w-1]) can[i][j]=1;
			}
		}
	for(int i=1;i<=n;i++)
	    for(int j=i;j<=n;j++) if(can[i][j]) ans=max(ans,s[j]-s[i-1]);
	cout<<ans;
}
```

---

## 作者：white_carton (赞：4)

[$\color{#52C41A}\text{题目传送门}$](https://www.luogu.com.cn/problem/P4805)

[$\color{#52C41A}\text{更好的体验}$](https://starback24.github.io)

---

### 题意

给你一排数，有两种操作，问你进行任意次操作能得到的最大值是多少。

- 操作一：将两个相邻且相等的数合并为一个数，这个数的值为这两个数之和。

- 操作二：若两个相等的数中间只隔了一个数，可以将这三个数合并为一个数，这个数的值为这三个数之和。

---

### 分析

很容易可以发现这题是区间DP。

我们可以把操作一表示为两个相同的数中间有一个值为 $0$ 的操作二，所以我们可以把操作一换为操作二处理。

我们用 $f_{i,j}$ 来表示 $[i,j]$ 区间能否合并为一个区间， $s$ 表示前缀和，枚举区间长度和左端点，区间内部枚举点 $x$ ，$y$ 将区间分割为三个子区间，判断第一个区间和第三个区间和是否相等以及三个子区间能否合并，得出下列转移方程：
```cpp
for(int len=2;len<=n;len++)
{
	for(int i=1;i+len-1<=n;i++)
	{
		int j=i+len-1;
		for(int x=i;x<=j;x++)
		{
			for(int y=x;y<=j;y++)
			{
				if((s[j]-s[y-1])==(s[x]-s[i-1])&&f[i][x]&&f[y][j]&&f[x+1][y-1])//判断第一个区间和第三个区间和是否相等以及三个子区间能否合并
				{
					f[i][j]=1;
				}
			}
		}
	}
}
```
但是这个方法是 $O(n^4)$ 的，显然不行，我们需要进一步优化。

update：$O(n^4)$ 不吸氧会超时，但是吸氧就过了，~~请求加强数据~~。

显然得知， $s$ 数组是递增的，所以我们可以只开两个指针扫区间，可以降一重循环。

代码：
```cpp
for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1,x=i,y=j;
			for(;x<=j;x++)
			{
				while((s[j]-s[y-1])<(s[x]-s[i-1])&&y>=i)
				{
					y--;
				}
				if((s[j]-s[y-1])==(s[x]-s[i-1])&&f[i][x]&&f[y][j]&&f[x+1][y-1])
				{
					f[i][j]=1;
				}
			}
		}
	}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define fir first
#define sec second
#define inl inline
#define reg register
#define int long long
#define VI vector<int>
#define MII map<int,int>
#define PII pair<int,int>
#define PRT_Q priority_queue
using namespace std;
int s[410],n,ans,maxn;
bool f[410][410];
signed main()
{
	//freopen("rice.in","r",stdin);
	//freopen("rice.out","w",stdout);
	cin>>n;
	int a;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		s[i]=s[i-1]+a;
		f[i][i]=1;
		f[i][i-1]=1;
	}
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1,x=i,y=j;
			for(;x<=j;x++)
			{
				while((s[j]-s[y-1])<(s[x]-s[i-1])&&y>=i)
				{
					y--;
				}
				if((s[j]-s[y-1])==(s[x]-s[i-1])&&f[i][x]&&f[y][j]&&f[x+1][y-1])
				{
					f[i][j]=1;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			if(f[i][j])
			{
				ans=max(ans,s[j]-s[i-1]);
			}
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：JasonL (赞：3)

## P4805 [CCC 2016]合并饭团

[题目传送门](https://www.luogu.com.cn/problem/P4805)



### 分析

首先注意到合并后的新饭团的大小是原饭团的大小之和.那么，对于$1\le l \le r\le n,[l,r]$区间的饭团组成的新饭团大小等于该区间所有饭团的大小之和.因而我们可以通过前缀和的方式表示一段区间组成的饭团大小.

考虑使用区间DP.我们先用$f[i][j]$表示是否存在一种方式使得$[i,j]$区间的饭团可以合并为一个饭团.那么有

$f[i][i]=true,i\in[1,n]$

合并两个饭团可以看作两个饭团中间夹着一个大小为0的饭团,即合并三个饭团的情况.因而我们先考虑三个饭团的情况.此时有

$f[i][j]=f[i][l] \text{ and } f[l+1][r-1] \text{ and }f[r][j](l,r\in[i,j],l+1<r)$

条件是$[i,l]$的区间和等于$[r+1,j]$的区间和.and表示按位与运算.

同理,对于两个饭团的合并有

$f[i][j]=f[i][l]\text{ and }f[l+1][j],l\in[i,j]$

条件是$[i,l]$区间和等于$[l+1,j]$区间和.

我们枚举区间长度,左端点以及断点,便可以求得所有$f[i][j]$的值.此时时间复杂度$O(n^4)$,循环此时有四层.

我们继续考虑对其做优化.在上面的情况中,由于饭团大小是正整数,我们有

$[l,r]<[l,r+1]<[l,r+2]<\dots<[l,j]$,即固定左端点,只移动右端点时区间和具有单调性.固定右端点时同理.

那么对于$l'=l+1$,若要满足$[i,l'],[r',j]$区间和相等,新的$r'$只可能在$[l'+1 ,r)$ 内.于是可以在移动左端点的同时调整右端点.省去一层循环.此时时间复杂度为$O(n^3)$,足够通过本题.


最后令$ans=\max\limits_{1\le i\le j \le n} sum[i][j](f[i][j]=true)$即可.注意不要略去$i=j$的情况.

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int maxn=402;
bool f[maxn][maxn];//[i,j]是否能组成饭团
int n;
int sum[maxn];//前缀和
inline int read(){
	int res=0;
	char ch=getchar(),ch1=ch;
	while(!isdigit(ch))ch1=ch,ch=getchar();
	while(isdigit(ch))res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return ch1=='-'?-res:res;
}
int main()
{
	n=read();
	int ans=0;
	for(register int i=1,x;i<=n;++i){
		x=read();
		sum[i]=sum[i-1]+x;//记录前缀和
		f[i][i]=true;//初始化
		ans=max(ans,x);//i=j时的情况
	}
	for(register int i=1;i<n;++i){
		for(register int j=1;j+i<=n;++j){
			for(register int l=j,r=j+i;l<r&&!f[j][j+i];++l){
				// 选出[j,l][r,j+i]区间
				while(sum[j+i]-sum[r-1]<sum[l]-sum[j-1]&&l<r-1)--r;//根据左端点情况移动右端点
				if(sum[j+i]-sum[r-1]==sum[l]-sum[j-1]){
					if(l==r-1)f[j][j+i]|=f[j][l]&f[r][j+i];//断点重合,此时为两个饭团
					else f[j][j+i]|=f[j][l]&f[l+1][r-1]&f[r][j+i];//三个饭团
				}
			}
			if(f[j][j+i])
				ans=max(ans,sum[j+i]-sum[j-1]);
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：daniEl_lElE (赞：2)

区间 $dp$。

## 思路

考虑 $dp_{i,j}$，表示 $i,j$ 区间是否可以合并出来一个大饭团，转移可以枚举中间某两个点然后判断是否三段可行，复杂度 $O(n^4)$，不可以通过。

考虑对于 $i,j$ 区间，对于某个 $k$，最多只有一个 $l$ 满足 $i\sim k$ 的和等于 $l\sim j$ 的和，所以我们只需要用双指针优化原来的暴力两个点枚举即可，复杂度 $O(n^3)$，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[405][405];
int pre[405];
signed main(){
	int n;
	cin>>n;
	int a[n+1],maxv=0;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) dp[i][i]=1,maxv=max(maxv,a[i]),pre[i]=pre[i-1]+a[i],dp[i][i-1]=dp[i+1][i]=1;
	for(int len=2;len<=n;len++){
		for(int l=1,r=len;r<=n;l++,r++){
			int L=l,R=r,sum1=0,sum2=0;
			while(L<=R){
				if(sum1>=sum2){
					sum2+=a[R];
					R--;
				}
				else{
					sum1+=a[L];
					L++;
				}
				if(sum1==sum2){
					dp[l][r]|=(dp[l][L-1]&dp[R+1][r]&dp[L][R]);
				}
			}
			maxv=max(maxv,dp[l][r]*(pre[r]-pre[l-1]));
		}
	}
	cout<<maxv;
	return 0;
}
```

---

## 作者：yeshubo_qwq (赞：2)

## Solution

区间 DP。

不难发现，当一堆饭团被合并了，它们的大小就是它们的和，因此我们只需要判断一段区间能否被合并成一个饭团即可。

于是设 $ok_{i,j}$ 表示区间 $\left[ i,j\right]$ 能否被合并成一个饭团。

分别考虑由两个饭团构成和由三个饭团构成转移过来。

- 由两个饭团构成：如果区间 $\left[ i,j\right]$ 由两个饭团构成，那么它一定可以被分成和相等的两段，二分找到断点，判断两个小区间能否合并即可。

- 由三个饭团构成：如果区间 $\left[ i,j\right]$ 由三个饭团构成，那么它一定是左右两段和相等，中间另有一段。直接枚举中间一个饭团会 T，用双指针即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=405;
int n,i,L,j,l,r,mid,x,Sl,Sr,ans,a[N],sum[N];
bool ok[N][N];
int query(int l,int r){return sum[r]-sum[l-1];}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++) cin>>a[i],ans=max(ans,a[i]),sum[i]=sum[i-1]+a[i],ok[i][i]=true;
	for (L=2;L<=n;L++)
		for (i=1,j=L;j<=n;i++,j++){
			l=i,r=j-1;
			while (l<=r){
				mid=(l+r)>>1;
				if (query(i,mid)<=query(mid+1,j)) l=(x=mid)+1;
					else r=mid-1;
			}
			if (query(i,x)==query(x+1,j) && ok[i][x] && ok[x+1][j]){
				ok[i][j]=true,ans=max(ans,query(i,j));
				continue;
			}
			l=i,r=j,Sl=a[i],Sr=a[j];
			while (l+1<r){
				if (Sl==Sr && ok[i][l] && ok[l+1][r-1] && ok[r][j]){
					ok[i][j]=true,ans=max(ans,query(i,j));
					break;
				}
				if (Sl<=Sr) Sl+=a[++l];
				else Sr+=a[--r];
			}
		}
	return cout<<ans,0;
}
```

然后我们发现，由两个饭团构成其实本质上是由三个饭团构成的特殊情况（中间没有饭团），于是代码可以进一步简化。

修改后的核心部分：

```cpp
	for (i=1;i<=n;i++) cin>>a[i],ans=max(ans,a[i]),sum[i]=sum[i-1]+a[i],ok[i][i]=true,ok[i][i-1]=true;//注意这里 ok[i][i-1] 也要赋值，防止下面 l+1>r-1。
	for (L=2;L<=n;L++)
		for (i=1,j=L;j<=n;i++,j++){
			l=i,r=j,Sl=a[i],Sr=a[j];
			while (l<r){
				if (Sl==Sr && ok[i][l] && ok[l+1][r-1] && ok[r][j]){
					ok[i][j]=true,ans=max(ans,query(i,j));
					break;
				}
				if (Sl<=Sr) Sl+=a[++l];
				else Sr+=a[--r];
			}
		}

```


---

## 作者：DengDuck (赞：1)

这道题我们可以设 $f_{i,j}$ 表示区间 $[i,j]$ 是否可以合并。

于是我们不难得到这样一个式子：

$$
f_{i,j}=\bigvee_{i\leq t\leq k\leq j}([(i,k)=(t,j)]\land f_{i,k}\land f_{k+1,t-1}\land f_{t,j})
$$

这里的 $(i,j)$ 是我发明的表示区间和的不规范用法，$[x]$ 是艾佛森括号，若里面的条件真则为 $1$ 否则为 $0$。

可是这样时间复杂度是 $O(n^4)$ 的，我们需要加上一个双指针来优化。

具体地，不难发现我们想要 $(i,k)=(t,j)$ 那么 $t$ 随着 $k$ 增大而减小。

这个就可以用双指针维护了。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,a[405],sum[405],f[405][405],ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		ans=max(ans,a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)f[i][j]=1;
	}
	for(int L=2;L<=n;L++)
	{
		for(int i=1;i+L-1<=n;i++)
		{
			LL j=i+L-1,t=j;
			for(int k=i;k<=t;k++)
			{
				while(k<t&&sum[j]-sum[t-1]<sum[k]-sum[i-1])t--;
				if(sum[k]-sum[i-1]==sum[j]-sum[t-1]&&f[k+1][t-1]&&f[i][k]&&f[t][j])ans=max(ans,sum[j]-sum[i-1]),f[i][j]=1;
			}
			
		}
	}
	cout<<ans<<endl;
}
```

---

## 作者：FReQuenter (赞：0)

考虑区间 DP。$f_{i,j}$ 表示 $i\sim j$ 全部合并后的最大饭团。

分类讨论：

1. 两个饭团合并。就是石子合并，枚举分段点 $k$，若 $f_{i,k}=f_{k+1,j}$，则它们的和能够对 $f_{i,j}$ 产生贡献。

2. 三个饭团合并。如果直接枚举两个分段点，那么时间复杂度会到 $O(n^4)$。~~事实上，开 O2 后这是能过的。~~ 时间复杂度不能接受。考虑优化：因为输入的值都是正整数，所以在从一个大区间向它包含的小区间靠近时，$f_{l,r}$ 的值会持续缩小（即它又单调性）。我们可以使用双指针优化。两个指针 $k1,k2$ 分别从 $l,r$ 向 $r,l$ 靠近，找 $f_{l,k1}=f_{k2,r}$ 的区间对 $f_{l,r}$ 产生贡献。

注意细节。几个坑：判定区间相等时检查区间是否能被切出来、双指针注意边界、三个一起合并时注意夹中间的那个也要能被合并出来。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define MAXN 405
#define int long long
using namespace std;
int n,f[MAXN][MAXN];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>f[i][i];
	for(int len=2;len<=n;len++){
		for(int l=1;l<=n;l++){
			int r=l+len-1;
			if(r>n) break;
			for(int k=l;k<r;k++){
				if(f[l][k]==f[k+1][r]&&f[l][k]) f[l][r]=max(f[l][r],f[l][k]+f[k+1][r]);
			}
			for(int k1=l,k2=r;k1<k2-1;){
				if(!f[l][k1]) k1++;
				else if(!f[k2][r]) k2--;
				else if(f[l][k1]==f[k2][r]&&f[l][k1]){
					if(f[k1+1][k2-1]) f[l][r]=max(f[l][r],f[l][k1]+f[k1+1][k2-1]+f[k2][r]);
					k1++,k2--;
				}
				else if(f[l][k1]>=f[k2][r]) k2--;
				else k1++;
			} 
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			ans=max(ans,f[i][j]);
		}
	}
	cout<<ans;
}
```

---


# [CCO 2014] 狼人游戏

## 题目描述

**本题译自 [CCO 2014](https://cemc.math.uwaterloo.ca/contests/computing/2014/index.html) Day1 T3「[Werewolf](https://cemc.math.uwaterloo.ca/contests/computing/2014/Stage%202/day1.pdf)」**

和往常一样，$N$ 个机器人在玩狼人游戏，机器人从 $1$ 到 $N$ 编号。$W$ 个机器人扮演狼人，剩下的扮演市民。虽然狼人游戏包括不同的角度，但我们将只着眼于其中一个角度。

机器人指控其他人是狼人并且防止其他机器人无辜地指控它。

狼人知道其他人的角色以及：

- 一个狼人从不指控其他狼人；

- 任何狼人机器人保护的都是其他狼人机器人。

市民可能会指控或保护任何类型的机器人。

其他的一些限制使得题目更简单：

- 没有机器人又被指控又被保护；

- 没有机器人被指控或保护一次以上；

- 如果有一个编号为 $A$ 机器人指控或保护编号为 $B$ 的机器人，那么我们保证$A<B$。

你将知道 $N$ 个机器人间的所有指控和保护关系，并且知道狼人数为 $W$。每个机器人所扮演的角色要么是狼人要么是市民。你的目标是计算出符合上述限制的角色安排方案数。

## 说明/提示

#### 样例解释 1
如果机器人 $1$ 是狼人，机器人 $2$ 也必须是，那么狼人就太多了！唯一的可能是机器人 $2$ 是唯一的狼人。

#### 样例输出 2
没有额外的保护或指控信息的话，机器人 $1$ 和机器人 $2$ 都可能是狼人。

#### 样例解释 3
如果机器人 $1$ 是狼人，机器人 $2$ 将是市民，机器人 $3$ 也是狼人；或者机器人 $1$ 是市民，那么机器人 $2$ 和 $3$ 将是狼人。

对于 $20\%$ 的数据，$1\le N\le 20$；

对于 $100\%$ 的数据，$1\le N\le 200,$ $0\le W\le N,$ $0\le M<N$。

## 样例 #1

### 输入

```
2 1 1
D 1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
2 1 0```

### 输出

```
2```

## 样例 #3

### 输入

```
3 2 2
A 1 2
D 1 3```

### 输出

```
2```

# 题解

## 作者：SuperJvRuo (赞：11)

成功拿下此题首杀！NOIP提高组水平的选手们，只要认真读题，就可以做出来。

- 没有机器人又被指控又被保护
- 没有机器人被指控或保护一次以上
- 如果有一个编号为$A$机器人指控或保护编号为$B$的机器人，那么我们保证$A<B$。

这三条限定为什么会使题目更简单呢？

因为它保证了这个图是树形图的集合。我们就可以把这道题当做树形DP来做。

先对每个树形图单独做DP。对于每个树形图中的每个节点，有两种转移：

对于一条“指控”边，狼人儿子可以转移到平民父亲，平民儿子可以转移到狼人或平民父亲；

对于一条“保护”边，平民儿子可以转移到平民父亲，狼人儿子可以转移到狼人或平民父亲。

最后对所有树形图做DP，统计答案，具体的转移方程见代码。

f数组如果不滚动的话，像我这样开得大一点，大概是$205\times205\times2\times205\times8\div2^{20}=131MB$，似乎还是滚动一下比较好。

```
#include<cstdio>
#include<vector>
#define LL long long
#define MOD 1000000007

struct Edge
{
	int to,next,eff;
    //eff==1表示指控，eff==2表示保护
}edge[205];
int head[205],cnt;

void Add_edge(int u,int v,int opt)
{
	edge[++cnt]=(Edge){v,head[u],opt};
	head[u]=cnt;
}

std::vector<int> root;

LL f[205][2][2][205];
//f[i][j(滚动)][0/1][j]:以i为根的子树，算到第j个儿子，i是/不是狼人，子树中有j个狼人的方案数 
int size[205],son[205];
int indeg[205],outdeg[205];
//入度为0的点一定是一个树形图的根

//求出子树大小、每个节点的儿子数量
void dfs(int u)
{
	size[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		++son[u];
		dfs(v);
		size[u]+=size[v];
	}
}

void calc(int u)
{
	f[u][0][1][1]=f[u][0][0][0]=1;
	for(int i=head[u],num=1;i;i=edge[i].next,num^=1)
	{
		int v=edge[i].to;
		calc(v);
		for(int j=0;j<=size[u];++j)
		{
			f[u][num][0][j]=f[u][num][1][j]=0;
			for(int k=0;k<=size[v];++k)
			{
				if(j>=k)
				{
                	//平民父亲可以由狼人或平民转移
					f[u][num][0][j]+=(f[u][num^1][0][j-k])*(f[v][son[v]&1][0][k]+f[v][son[v]&1][1][k]);
					if(edge[i].eff==1)
					{//狼人一定指控平民
						f[u][num][1][j]+=(f[u][num^1][1][j-k])*(f[v][son[v]&1][0][k]);
					}
					else
					{//狼人一定保护狼人
						f[u][num][1][j]+=(f[u][num^1][1][j-k])*(f[v][son[v]&1][1][k]);
					}
					f[u][num][0][j]%=MOD;
					f[u][num][1][j]%=MOD;
				}
			}
		}
	}
}

LL res[205][205];
//前i个树形图，含j个狼人的方案数

void solve(int n,int w)
{
	for(int i=1;i<=n;++i)
	{
		if(!indeg[i])
		{
			root.push_back(i);
		}
	}
	res[0][0]=1;
    //dp起点，0个狼人的方案数为1
	for(int i=0;i<(int)root.size();++i)
	{
		dfs(root[i]);
		calc(root[i]);
		for(int j=0;j<=size[root[i]];++j)
		{
			for(int k=0;k<=w;++k)
			{
				if(k>=j)
				{
					res[i+1][k]+=res[i][k-j]*(f[root[i]][son[root[i]]&1][1][j]+f[root[i]][son[root[i]]&1][0][j]);
					res[i+1][k]%=MOD;
				}
			}
		}
	}
}

int main()
{
	int n,w,m;
	scanf("%d%d%d",&n,&w,&m);
	char opt[5];
	int u,v;
	for(int i=0;i<m;++i)
	{
		scanf("%s %d %d",opt,&u,&v);
		++indeg[v];
		++outdeg[u];
		Add_edge(u,v,opt[0]=='A'?1:2);
	}
	solve(n,w);
	printf("%lld",res[(int)root.size()][w]);
	return 0;
}
```

---

## 作者：GZY007 (赞：6)

这是一道树形dp题。

而题目中哪里有树呢？

题目中有三个限制：

- 没有机器人又被指控又被保护。

- 没有机器人被指控或保护一次以上。

- 如果有一个编号为 $A$ 机器人指控或保护编号为 $B$ 的机器人，那么我们保证 $A<B$ 。

我们把机器人看作节点，每一个关系表示成一个单向边，由指控或保护者指向被指控或被保护者，那么第一二个限制保证了每一个节点入度只能为 $0$ 或 $1$ ，第三个限制保证了图中无法出现环。

综合起来，其实整个图其实就是一个森林，这样就可以进行树形dp了。

我们定义 $dp_{i,j,k}$ 为以 $i$ 为根节点的子树有多少个狼人，其中 $k=1$ ,表示 $i$ 节点是狼人，否则是市民。

而图中只可能出现这 $6$ 种父子关系：

- 狼人父亲指控市民儿子

- 市民父亲指控狼人儿子

- 市民父亲指控市民儿子

- 狼人父亲保护狼人儿子

- 市民父亲保护狼人儿子

- 市民父亲保护市民儿子

这样，我们便可以列出状态转移方程。设 $u$ 为父亲， $v$ 为儿子。

当这条是指控边时：
$$dp_{u,j,1}=dp_{u,j-k,1}\times dp_{v,k,0}$$
$$dp_{u,j,0}=dp_{u,j-k,0}\times \left( dp_{v,k,1}+dp_{v,k,0}\right)$$

当它是保护边时：
$$dp_{u,j,1}=dp_{u,j-k,1}\times dp_{v,k,1}$$
$$dp_{u,j,0}=dp_{u,j-k,0}\times \left(dp_{v,k,0}+dp_{v,k,1}\right)$$

那么如何处理森林呢？

我们可以建立一个超级源点，连向所有树的根，然后在超级源点上直接处理即可。

代码如下： 

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long p=1e9+7;
int n,w,m,in[210],siz[210];
long long dp[210][210][2];
char c[2];
struct node{
	int v,x;
};
vector<node> G[210];
void dfs(int u){
	siz[u]=1;
	dp[u][0][0]=1;
	dp[u][1][1]=1;
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i].v;
		dfs(v);
		siz[u]+=siz[v];
		for(int j=siz[u];j>=0;j--){
			int d1=0,d0=0;
			for(int k=min(j,siz[v]);k>=0;k--){
				if(G[u][i].x){
					d1=(d1+dp[v][k][0]*dp[u][j-k][1])%p;
					d0=(d0+dp[u][j-k][0]*dp[v][k][1]+dp[u][j-k][0]*dp[v][k][0])%p;
					
				}else{
					d1=(d1+dp[u][j-k][1]*dp[v][k][1])%p;
					d0=(d0+dp[v][k][0]*dp[u][j-k][0]+dp[u][j-k][0]*dp[v][k][1])%p;
				}
			}
			dp[u][j][0]=d0;
			dp[u][j][1]=d1;
		}
	}
}
int main(){
	cin>>n>>w>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%s%d%d",c,&u,&v);
		if(c[0]=='A') G[u].push_back((node){v,1});
		else G[u].push_back((node){v,0});
		in[v]=1;
	}
	for(int i=1;i<=n;i++){
		if(!in[i]){
			G[0].push_back((node){i,1});
		}
	}
	dfs(0);
	cout<<dp[0][w][0];
	return 0;
}
```


---

## 作者：船酱魔王 (赞：1)

# P4815 [CCO2014] 狼人游戏 题解

## 题意回顾

有 $ N $ 个点，$ M $ 个边，组成森林。每个点属性可能是狼人和市民，狼人对市民的边不会是保护属性，狼人对狼人的边不会指控属性，市民对其他点的边属性随意。

已知狼人点总数，请求出给每个点确定属性总共有多少方案。

$ N \le 200 $。

## 分析

对于每个子树的根节点 $ u $，我们设计状态 $ dp_{u,l,j,0/1} $ 表示前 $ l $ 个子树中 $ j $ 个狼人，$ u $ 的状态为市民还是狼人。

我们考虑 $ v $ 为根的子树，枚举子树的狼人数，来转移状态。市民态显然可以由子树的任何态转移而来，狼人态考虑与子树根的连边，按照题目定义转移。

可以把中间一维用滚动数组实现以节省空间。

最后我们考虑每个树的树根的状态转移到总的答案上，还是枚举树的狼人数转移。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 205;
const int mod = 1e9 + 7;
int n, w, m;
struct node {
	int to;
	int typ;//1 - 指控，2 - 保护 
};
node make(int t0, int tp0) {
	node res;
	res.to = t0;
	res.typ = tp0;
	return res;
}
vector<node> g[N];
int cnt[N];
long long dp[N][2][N][2];
int fg[N];
int sz[N];
long long ans[N];
void dfs(int u) {
	sz[u] = 1;
	dp[u][0][0][0] = 1;
	dp[u][0][1][1] = 1;
	fg[u] = 0;
	for(int i = 0; i < g[u].size(); i++) {
		fg[u] ^= 1;
		for(int j = 0; j <= w; j++) {
			dp[u][fg[u]][j][0] = dp[u][fg[u]][j][1] = 0;
		}
		int v = g[u][i].to;
		int tp = g[u][i].typ;
		dfs(v);
		for(int j = 0; j <= min(sz[u], w); j++) {
			for(int k = min(sz[v], w - j); k >= 0; k--) {
				dp[u][fg[u]][j + k][0] += (dp[v][fg[v]][k][0] + dp[v][fg[v]][k][1]) * dp[u][fg[u] ^ 1][j][0] % mod;
				dp[u][fg[u]][j + k][0] %= mod;
				if(tp == 1) {
					dp[u][fg[u]][j + k][1] += dp[v][fg[v]][k][0] * dp[u][fg[u] ^ 1][j][1] % mod;
				} else {
					dp[u][fg[u]][j + k][1] += dp[v][fg[v]][k][1] * dp[u][fg[u] ^ 1][j][1] % mod;
				}
				dp[u][fg[u]][j + k][1] %= mod;
			}
		}
		sz[u] += sz[v];
	}
}
int main() {
	cin >> n >> w >> m;
	char op;
	int a, b;
	for(int i = 1; i <= m; i++) {
		cin >> op >> a >> b;
		if(op == 'A') {
			g[a].push_back(make(b, 1));
		} else {
			g[a].push_back(make(b, 2));
		}
		cnt[b]++;
	}
	for(int i = 1; i <= n; i++) {
		if(cnt[i] == 0) {
			dfs(i);
		}
	}
	ans[0] = 1;
	for(int i = 1; i <= n; i++) {
		if(cnt[i] == 0) {
			for(int j = w; j >= 0; j--) {
				for(int k = min(j, sz[i]); k >= 1; k--) {
					ans[j] += ans[j - k] * (dp[i][fg[i]][k][0] + dp[i][fg[i]][k][1]) % mod;
					ans[j] %= mod;
				}
			}
		}
	}
	cout << ans[w] << endl;
	return 0;
}
```

---

## 作者：NaN_HQJ2007_NaN (赞：1)

看题目限制，可以发现如果将机器人作为点，指控和保护关系作为边，可以建出一个森林，就下来就是传统的树形背包了。

设 $f_{i,j,0/1}$ 表示当前点为 $i$，子树内有 $j$ 个狼人，当前点是否为狼人的方案数。

初始化：$f_{u,0,0} = f_{u,1,1} = 1$

当前点为狼：

- 指控：$f_{u,j,1}=f_{u,j-k,1} \times f_{v,k,0}$
- 保护：$f_{u,j,1}=f_{u,j-k,1} \times f_{v,k,1}$

当前点为民：$f_{u,j,0}=f_{u,j-k,0} \times (f_{v,k,0}+f_{v,k,1})$

最后还需要把没棵树合并起来：$g_j=g_{j-k} \times (f_{i,k,0}+f_{i,k,1})$

### code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 200 + 5, mod = 1e9 + 7;
int n, num, m, vis[N];
ll f[N][N][2], tmp[N][2], g[N];
struct node{
	int v, w;
	node(int v = 0, int w = 0):v(v), w(w){}
};
vector<node> adj[N];
void dfs(int u) {
	vis[u] = 1;
	f[u][0][0] = f[u][1][1] = 1;
	for (int i = 0; i < adj[u].size(); ++i) dfs(adj[u][i].v);
	for (int i = 0; i < adj[u].size(); ++i) {
		int v = adj[u][i].v, w = adj[u][i].w;
		memset(tmp, 0, sizeof(tmp));
		for (int j = num; j >= 1; --j) {
			for (int k = 0; k < j; ++k) {
				tmp[j][1] = (tmp[j][1] + f[u][j - k][1] * f[v][k][w]) % mod;
			}
		}
		for (int j = num; j >= 1; --j) f[u][j][1] = tmp[j][1];
	}
	for (int i = 0; i < adj[u].size(); ++i) {
		int v = adj[u][i].v, w = adj[u][i].w;
		memset(tmp, 0, sizeof(tmp));
		for (int j = num; j >= 1; --j) {
			for (int k = 0; k <= j; ++k) {
				tmp[j][0] = (tmp[j][0] + f[u][j - k][0] * (f[v][k][0] + f[v][k][1])) % mod;
			}
		}
		for (int j = num; j >= 1; --j) f[u][j][0] = tmp[j][0];
	}
}
int main() {
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> num >> m;
	for (int i = 1; i <= m; ++i) {
		char type; int u, v;
		cin >> type >> u >> v;
		adj[u].push_back(node(v, (type == 'D')));
	}
	g[0] = 1;
	for (int i = 1; i <= n; ++i) {
		if (!vis[i]) {
			dfs(i);
			memset(tmp, 0, sizeof(tmp));
			for (int j = num; j >= 1; --j) {
				for (int k = 0; k <= j; ++k) {
					tmp[j][0] = (tmp[j][0] + g[j - k] * (f[i][k][0] + f[i][k][1])) % mod;
				}
			}
			for (int j = num; j >= 1; --j) g[j] = tmp[j][0];
		}
	}
	cout << g[num] << endl;
	return 0;
}
```


---

## 作者：glorious_dream (赞：1)

[洛谷 P4815 [CCO2014] 狼人游戏](https://www.luogu.com.cn/problem/P4815)

首先题目中有 $3$ 个限制：

 - 没有机器人又被指控又被保护；
 
 - 没有机器人被指控或保护一次以上；
 
 - 如果有一个编号为 $A$ 机器人指控或保护编号为 $B$ 的机器人，那么我们保证 $A<B$。

那么我们把每一个机器人看成一个节点，每一个关系看成一条对应的边，由指控或保护者指向被指控或被保护者，那么结合前两个限制，容易发现，每一个点的入度只能为 $0$ 或者 $1$，第三个限制保证了整个图没有环。那么整张图就变成了一个森林。

设 $f[i][j][k]$ 表示以 $i$ 为根的子树，有 $j$ 个狼人的方案数，其中 $k=0$ 表示节点 $i$ 不是狼人，$k=1$ 表示节点 $i$ 是狼人。那么一共只有 $6$ 种对应的父子关系。

指控：
 - 狼人父亲指控市民儿子
 
 - 市民父亲指控市民儿子
 
 - 市民父亲指控狼人儿子

保护：
 - 狼人父亲保护狼人儿子
 
 - 市民父亲保护市民儿子
 
 - 市民父亲保护狼人儿子

这样的话我们可以列出转移方程，设 $u$ 为父亲，$v$ 为儿子。

当这条边是指控边时：
$$f[u][j][1] = f[u][j-k][1] \times f[v][k][0]$$

$$f[u][j][0] = f[u][j-k][0] \times (f[v][k][0] + f[v][k][1])$$

当这条边是保护边时：
$$f[u][j][1] = f[u][j-k][1] \times f[v][k][1]$$
$$f[u][j][0] = f[u][j-k][0] \times (f[v][k][0] + f[v][k][1])$$

接下来考虑如何处理森林。我们可以新建一个超级源点 $0$，连向所有的树根，然后我们最终的答案直接在超级源点上处理即可，即为 $f[0][w][0]$。

我们需要注意，在树形 DP 转移的时候，我们需要用一个变量来代替前面的 $f[u][j][0]$ 和 $f[u][j][1]$ 来进行转移，在后面把 $f[u][j][0]$ 和 $f[u][j][1]$ 给赋值，因为在转移的过程中，我们要保证 $f[u][j][0]$ 和 $f[u][j][1]$ 的值不能被实时更新，在转移的时候需要用到原来的 $f[u][j][0]$ 和 $f[u][j][1]$。

```cpp
#include <bits/stdc++.h>
#define re register
#define ll long long
#define rep(a,b,c)  for(re int a(b) ; a<=c ; ++a)
#define drep(a,b,c) for(re int a(b) ; a>=c ; --a)
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
    return x*f;
}
const int M = 210;
const int mod = 1e9+7;
int n,s,m,cnt;
int head[M],siz[M],son[M],du[M];
ll f[M][M][2]; //0 市民 1 狼人 
struct edge{
	int to,nxt,w; //w=1 指控 w=2 保护 
}e[M<<1];
inline void add(int u,int v,int w){
	e[++cnt].to = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
void dfs(int u){
	siz[u] = 1;
	f[u][0][0] = f[u][1][1] = 1;
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to,w = e[i].w;
		dfs(v);
		siz[u] += siz[v];
		drep(j,min(s,siz[u]),0){
			int dp0 = 0,dp1 = 0;
			rep(k,0,min(j,siz[v])){
				if(w == 1){
					dp0 += f[u][j-k][0] * (f[v][k][0] + f[v][k][1]) % mod;
					dp1 += f[u][j-k][1] * f[v][k][0] % mod;
					dp0 %= mod,dp1 %= mod;
				}
				else{
					dp0 += f[u][j-k][0] * (f[v][k][0] + f[v][k][1]) % mod;
					dp1 += f[u][j-k][1] * f[v][k][1] % mod;
					dp0 %= mod,dp1 %= mod;
				}
			}
			f[u][j][0] = dp0;
			f[u][j][1] = dp1;
		}
	}
}
signed main(){
	n = read(),s = read(),m = read();
	rep(i,1,m){
		char ch;
		cin >> ch;
		int u = read(),v = read();
		if(ch == 'D') add(u,v,2);
		else add(u,v,1);
		du[v]++;
	}
	rep(i,1,n) if(!du[i]) add(0,i,1);
	dfs(0);
	printf("%lld\n",f[0][s][0]);
	return 0;
}
```


---

## 作者：Hisy (赞：0)

## 分析
很明显，看到这一条保证：
>如果有一个编号为 $A$ 机器人指控或保护编号为 $B$ 的机器人，那么我们保证 $A<B$。

就可以推出这一个关系是一棵树。这时候，我们就可以使用树形 dp 来解。
### 建边
很明显，当一条指控边出现，只可能是：
- 狼人指控村民。
- 村民指控狼人。
- 村民指控村民。

当一条保护边出现，只可能是：
- 狼人保护狼人。
- 村民保护狼人。
- 村民保护村民。

所以，利用这两点来建边就可以进行 dp 了。
### dp
具体可以使用记忆化搜索来实现。由于可能有森林的出现，所以定义一个根节点 $0$ 来连接其他点。从 $0$ 开始搜索，向下搜索，设 $dp_{i,j,k}(1\le i\le n,1\le j\le m,k\in\{0,1\})$ 为当前是节点 $i$，前面出现了 $j$ 个狼人，当前节点是否为狼人的方案数。

接下来，设 $u,v$ 表示 $u$ 有一条边通向 $v$，那么分类讨论：
- 如果要计算为狼人的情况，并且为指控边，那么子节点必须为村民，则有 $dp_{u,j,1}=dp_{u,j-k,1}\times dp_{v,k,0}$。
- 如果要计算为狼人的情况，并且为保护边，那么子节点必须为狼人，则有 $dp_{u,j,1}=dp_{u,j-k,1}\times dp_{v,k,1}$。
- 如果要计算为村民的情况，并且为指控边，那么子节点可以为村民和狼人，需要加和，有 $dp_{u,j,0}=dp_{u,j-k,0}\times(dp_{v,k,0}+dp_{v,k,1})$。
- 如果要计算为村民的情况，并且为保护边，那么子节点可以为村民和狼人，需要加和，有 $dp_{u,j,0}=dp_{u,j-k,0}\times(dp_{v,k,0}+dp_{v,k,1})$。

之后，就可以愉快的 AC 了！
## 代码
```cpp
#include<bits/stdc++.h>
#define MAXN 202
#define MAXM 40004
#define MOD 1000000007
using namespace std;
typedef long long ll; 
struct node{
	int next,to;
	bool type;
}edge[MAXM<<2];
int n,m,k,cnt,head[MAXN];
bool vis[MAXN];
inline void addedge(int from,int to,bool type){
	edge[++cnt].to=to;
	edge[cnt].type=type;
	edge[cnt].next=head[from];
	head[from]=cnt;
} 
ll dp[MAXN][MAXN][2];
int size[MAXN];
bool in[MAXN];
void dfs(int u){
	size[u]=1;
	dp[u][0][0]=dp[u][1][1]=1ll;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		dfs(v);
		size[u]+=size[v];
		for(int j=size[u];j>=0;--j){
			ll ans1=0,ans0=0;
			for(int k=min(j,size[v]);k>=0;--k){
				if(edge[i].type){
					(ans1+=dp[u][j-k][1]*dp[v][k][0])%=MOD;
				}else{
					(ans1+=dp[u][j-k][1]*dp[v][k][1])%=MOD;
				}
	 			(ans0+=dp[u][j-k][0]*(dp[v][k][0]+dp[v][k][1]))%=MOD;
			}
			dp[u][j][0]=ans0;
			dp[u][j][1]=ans1;
		}
	}
}
int main(){
	scanf("%d %d %d",&n,&m,&k);
	while(k--){
		int u,v;
		char s[3]="";
		scanf("%s %d %d",s,&u,&v);
		if(*s=='A'){
			addedge(u,v,true);
		}else{
			addedge(u,v,false);
		}
		in[v]=true;
	}
	for(int i=1;i<=n;++i){
		if(!in[i]){
			addedge(0,i,true);
		}
	} 
	dfs(0);
	printf("%lld",dp[0][m][0]);
	return 0;
}
```

---

## 作者：Tenderfoot (赞：0)

一道树形 dp 的题

设 $Dp_{i,Check,j,Opt}$ 表示编号为 $i$ 的节点成为狼人 or 平民时有 $j$ 个狼人的方案数，注意第二维表示连续两次的答案（即上一次和这一次），要用滚动数组存储之。

**状态转移方程**

$$\begin{aligned}Dp_{u,Check,j+l,0}&=\sum_{i\in Tree(x)}Dp_{u,Check\bigoplus1,j,0}\times(Dp_{v,Size,l,0}+Dp_{v,Size,l,1})\\ Dp_{u,Check,j+l,1}&=\sum_{i\in Tree(x)}Dp_{u,Check\bigoplus1,j,1}\times Dp_{v,Size,l,n}\ (E_iOpt=D,n=1)\end{aligned}$$

其中第一个方程为平民的转移方程，第二个为狼人的转移方程。

因为平民可以指控狼人或者平民，所以要把两种可能相加。

而狼人只会举报平民而保护本方狼人，因此只需要一种可能性且 $Opt=D$ 即可进行转移。

因此指控的时候子节点一定是平民，保护的时候子节点一定为狼人。

进行方案统计的时候，我们也可以按照上述思路进行下去。

设 $Ans_{Check,i}$ 表示有 $i$ 个狼人的方案数，转移方程与上面类似

**状态转移方程**

$$Ans_{Check,j+l}=\sum_{i\in Tree(x)}Ans_{Check\bigoplus 1,j}\times(Dp_{v,Size,l,0}+Dp_{v,Size,l,1})$$

其中，方程 $1$ 的 $j$ 从 $min\{w,g_x\}$ 开始递减，方程 $2$ 的 $j$ 从 $w$ 开始递减，所有的 $l$ 均从 $min\{w-j,g_v\}$ 开始递减。

**代码**

```cpp
#include<bits/stdc++.h>

#define INF 1000000007
#define Work(x , y) ((x += (y)) >= INF && (x -= INF))
#define int long long
#define MAXN 100010
#define Enter puts("")
#define Space putchar(' ')
 
using namespace std;

static inline int Read()
{
	int Ans = 0;
	char Ch = getchar(), Las = ' ';
	while (!isdigit(Ch))
	{
		if (Ch == '-')
			Las = '-';
		Ch = getchar();
	}
	while (isdigit(Ch))
	{
		Ans = Ans * 10 + Ch - '0';
		Ch = getchar();
	}
	if (Las == '-')
		Ans = -Ans;
	return Ans;
}

static inline void Write(int x)
{
	if (x < 0)
	{
		x = -x;
		putchar('-');
	}
	if (x >= 10)
		Write(x / 10);
	putchar(x % 10 + '0');
}

struct Edge
{
	int To,Next;
	char Opt;
} E[210];

int s[2][210] , t[210] , g[210] , Dp[210][2][210][2] , Dgr[210] , Head[210];
int n , m , w , Cnt;

static inline void Add_Edge(int u , int v , char Opt)
{
	E[++Cnt] = Edge{v , Head[u] , Opt};
	Head[u] = Cnt;
}

static inline int Sum(int x , const int &y)
{
	return x + y >= INF ? x + y - INF : x + y;
}

static inline void DP(const int & x)
{
	g[x] = Dp[x][0][0][0] = Dp[x][0][1][1] = 1;
	int Check = 1;
	for(register int i = Head[x]; i; i=E[i].Next , Check^=1)
	{
		int v = E[i].To;
		memset(Dp[x][Check] , 0 , sizeof(Dp[x][Check]));
		DP(v);
		for(register int j = min(w , g[x]); ~j; j--)
			for(register int l = min(w - j , g[v]); ~l; l--)
			{
				Work(Dp[x][Check][j + l][0] , 1ll * Dp[x][Check ^ 1][j][0] *
				    Sum(Dp[v][t[v]][l][0] , Dp[v][t[v]][l][1])),
				Work(Dp[x][Check][j + l][1] , 1ll * Dp[x][Check ^ 1][j][1] *
				    Dp[v][t[v]][l][E[i].Opt == 'D']);
			}
		g[x] += g[v] , t[x] ^= 1;
	}
}
static inline int Solve()
{
	register int Check=1;
	s[0][0] = 1;
	for(register int i = Head[0]; i; i=E[i].Next , Check^=1)
	{
		int v = E[i].To;
		memset(s[Check] , 0 , sizeof(s[Check]));
		DP(v);
		for(register int j = w; ~j; j--)
			for(register int l = min(w - j , g[v]); ~l; l--)
				Work(s[Check][j + l] , 1ll * s[Check ^ 1][j] *
				    Sum(Dp[v][t[v]][l][0] , Dp[v][t[v]][l][1]));
	}
	return s[Check ^ 1][w];
}

signed main()
{
	ios::sync_with_stdio(false);
	n = Read() , w = Read() , m = Read();
	for(register int i = 1; i <= m; i++)
	{
		char Opt;
		int x , y;
		cin >> Opt >> x >> y;
		Add_Edge(x , y , Opt);
		Dgr[y]++;
	}
	for(register int i = 1; i <= n; i++)
		if(!Dgr[i]) 
			Add_Edge(0 , i , '*');
	Write(Solve());
	return 0;
}
```

**这个代码改动了一点，如果直接抄代码的话只能得 $10$ 分，希望能自己进行思考并按照自己的想法写代码。**

---


# 毒瘤之神异之旅

## 题目背景

题目名称是吸引你点进来的……

我们的出题人CYJian由于出了过多毒瘤题被D死之后，OIer们将他埋葬在地狱十八层之下……

## 题目描述

已知地狱有$K$个守护者,每个守护者有一个能力值$a_i$。但是我们并不知道他们确切的能力值。只知道这些人的能力值的和为$N$。但是在地狱中守护者的威力会得到加强，具体来说每一个守护者的威力为$a_i^M$。

现在给出$N$,$M$,$K$,请求出所有可能的方案的威力值之和。

## 说明/提示

Subtask1(20 pts):

$1 \leq N,M \leq 10$

$1 \leq K \leq N$

Subtask 2(40 pts):

$1 \leq N,M \leq 4096$

$1 \leq K \leq N$

Subtask 3(40 pts):

$1 \leq N,M \leq 10000$

$1 \leq K \leq N$

其中所有的$a_i$均需要是正整数.

不要喷出题人毒瘤卡常，每一档部分分的时间和空间都至少开了标程的两倍。

由于数据只有一组，可能强度较弱，所以需要每5个点捆绑测试。

## 样例 #1

### 输入

```
5 2 3```

### 输出

```
100
```

## 样例 #2

### 输入

```
7 3 1```

### 输出

```
28```

# 题解

## 作者：Goldia (赞：3)

真是一道毒瘤的卡空间题

n^2的dp应该很容易理解
- 111111111
- 1111111
- 1111111
- 1111
- 1

我们很容易可以想到题目要求的数组a就是如上阶梯状的东西，在第一行添加一个数或者新添一行数量为整个阶梯的宽的一行。

- 所以设$f[i][j]$表示当前还剩i个‘1’宽为j的方案数

- $f[i][j]=f[i-1][j-1]$(第一行添加一个数)+$f[i-x][x]$(新添一行数量为整个阶梯的宽的一行);

### code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
const int mod=1e9+7; 
int m,k,cheng[10005],n,f[10005][10005];
int poww(int x,int nn)
{
	int res=1;
	while(nn)
	{
		if(nn&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		nn>>=1;
	}
	return res;
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=10000;i++)
		cheng[i]=poww(i,m);
	for(int i=0;i<=n;i++)
		f[i][i]=1;
	for(int x=1;x<=k;x++)
		for(int i=x;i<=n;i++)
			f[i][x]=(f[i-1][x-1]+f[i-x][x])%mod;
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++)
		{
			int num=0;
			if(i*j<=n)num+=f[n-i*j][k-j];
			ans=(ans+1ll*num*cheng[i]%mod)%mod;
		}
	cout<<ans;
	return 0;
}
```

但这毒瘤题卡空间 怎么办？

没关系，我们可以用动态开空间的方法过去

$*p=new int [n];$开一段长度为n的数组

$delete []p;$删除数组的空间

然后这题就这样水过去了

### code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
const int mod=1e9+7; 
int m,k,cheng[10005],n,*f[10005];
int poww(int x,int nn)
{
	int res=1;
	while(nn)
	{
		if(nn&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		nn>>=1;
	}
	return res;
}
int ans=0;
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;i++)
		cheng[i]=poww(i,m);
	//for(int i=0;i<=n;i++)f[i][i]=1;
	f[0]=new int[n+k+1];
	for(int i=0;i<=n;i++)
		f[0][i]=0;
	f[0][0]=1;
	for(int j=0;j<k;j++)
	{
		f[j+1]=new int[n+k+1];
		for(int i=0;i<=n;i++)
			f[j+1][i]=0;
		f[j+1][j+1]=1;
		for(int i=j+1;i<=n;i++)
			f[j+1][i]=(f[j][i-1]+f[j+1][i-j-1])%mod;
		for(int i=1;i<=n;i++)
		{
			int num=0;
			if(i*(k-j)<=n)(num+=f[j][n-i*(k-j)])%=mod;
			ans=(ans+1ll*num*cheng[i]%mod)%mod;
		}
		delete []f[j];
		f[j]=0;	
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：狂犇 (赞：1)

Subtask1

感觉不必多说.暴力dfs有请。。

Subtask2

这个的话。。我们可以考虑一个神奇的做法:首先N*N计算N个数里面划分K个数的方案这个会吧。

如果不会请出门[P1025数的划分](https://www.luogu.org/problemnew/show/P1025)。

然后现在我们考虑如何用这个东西算。

我们考虑连续取k个相同的数字x的该数字的答案。这样不会算重。

那么答案就是∑f[n−k∗x][m−k]∗xp∗k

Subtask3

这个是基于Subtask2的。

只需要在计算f[i][j]的时候把n和m的顺序反过来就可以滚动数组了。

标程：
```cpp
#include <bits/stdc++.h>
#define pir pair<int, int> 
#define reg register
#define ge getchar()
#define Num(a) isdigit(a)
#define ll long long
#define MAXN 10001
#define mod 1000000007
inline int read() {
    reg int x = 0, ch;
    while(!Num(ch = ge));
    while(Num(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
    return x;
}
inline int quick_pow(reg int a, reg int k) {
    reg int s = 1;
    while(k) {
        if(k & 1) s = 1LL * s * a % mod;
        a = 1LL * a * a % mod;
        k >>= 1;
    }
    return s;
}
int main() {
    reg int mul[MAXN];
    reg int C[2][MAXN]; memset(C, 0, sizeof(C));
    reg int n = read(), k = read(), m = read();
    reg int i, j, l, s, res = 0, o = 0, t = 1;
    for(i = 1; i <= n; i++) mul[i] = quick_pow(i, m);
    C[0][0] = 1; if(n % k == 0) res = mul[(n / k)];
    for(j = 1; j < k; ++j) {
        for(i = j, l = (n - j) % (k - j), s = (n - j) / (k - j); i < n; ++i, --l) {
            C[t][i] = C[o][i - 1] + (i >= (j << 1) ? C[t][i - j] : 0);
            C[t][i] -= C[t][i] >= mod ? mod : 0;
            if(!l) res = (res + 1LL * C[t][i] * mul[s]) % mod, --s, l = k - j;
        }
        std::swap(o, t);
  }
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 思路

求方案数这种题目应该要很快反应过来是 dp 了。

那么这道题我们怎么样 dp 呢？很显然的是本题就是要求把 $N$ 拆分成 $K$ 个数的方案，可以参考：

[P1025](https://www.luogu.com.cn/problem/P1025)

我们设 $a_i$ 递增，把 $a_i$ 转化为一个二维表，如下形式

```Plain Text
1
111
1111
1111
111111
111111
...
```


第 $i$ 行有多少个 $1$ 就表示 $a_i$ 的值是多少。假设目前已经用了 $N$ 中的 $k$ 个 $1$（我们把 $N$ 拆分为 $N$ 个 $1$ 来分配），那么怎么样使得 $k$ 增加呢？很简单，有以下两个方法：

- 新增一行

- 在当前行加 $1$

为了维护递增性质，我们约定新增一行的操作为：新增一行，且该行的 $1$ 的个数和之前的最后一行相同。

设 $f_{i,j}$ 为使用了 $i$ 个 $1$，且当前行的 $1$ 的个数（同时也是所有行中 $1$ 的个数的最大值）为 $j$ 的方案数。

转移可以写成 $f_{i,j}=f_{i-1,j-1}+f_{i-j,j}$。前者表示在当前行加 $1$，后者表示新增约一行。二维 dp 即可。

---

可是上面的题目仅仅是要求我们求方案数，怎么样求方案呢？

这个好办，也是需要理解的重点。我们扫描一遍 $f$ 数组，如果扫描到 $f_{i,j}=x$，那么就把答案加上 $j^M\times x$（想一想，因为我们要求**所有情况**中的取值之和，那么 $f$ 数组中每个位置记录的方案数都是当前位置对应的 $a$ 的取值（即 $j$）的方案数，这些在统计时都是要加入答案中的）。

空间的话……这边建议**滚动数组**吧！

## 代码

注意 $N,K,M$ 的输入顺序。

```C++
#include<bits/stdc++.h>
#define rep(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define per(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
#define int long long
#define pii pair<int,int>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=2e4+5;
const int INF=1e18+5;
const int MOD=1e9+7;
int ans,n,m,s,K;
int f[2][N],t[N];

int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=(res*a)%MOD;
		a=(a*a)%MOD;
		b>>=1;
	}
	return res;
}

signed main(){
	
	int n=rd,k=rd,m=rd;
	for(int i=1;i<=n;i++){
		t[i]=ksm(i,m);//预处理a_i每个取值对应的M次方
	}
//	for(int i=1;i<=n;i++)f[0][i]=10;
	f[0][0]=1;
//	cerr<<"OKJ";
	for(int j=0;j<k;j++){
		for(int i=0;i<=n;i++)f[j&1^1][i]=0;
		f[j&1^1][j+1]=1;
//		cerr<<"j="<<j<<" j&1^1="<<(j&1^1)<<endl;
		for(int i=j+1;i<=n;i++)f[j&1^1][i]=(f[j&1][i-1]+f[j&1^1][i-j-1])%MOD;
		for(int i=1;i<=n;i++){
			int res=0;
			if(i*(k-j)<=n){
				res=f[j&1][n-i*(k-j)];
				res%=MOD;
			}
			ans=(ans+res*t[i]%MOD)%MOD;
		}
		
	}
	cout<<ans<<endl;
}

```




---


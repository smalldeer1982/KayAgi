# [JLOI2011] 基因补全

## 题目描述

在生物课中我们学过，碱基组成了$DNA$（脱氧核糖核酸），他们分别可以用大写字母$A,C,T,G$表示，其中$A$总与$T$配对，$C$总与$G$配对。两个碱基序列能相互匹配，当且仅当它们等长，并且任意相同位置的碱基都是能相互配对的。例如$ACGTC$能且仅能与$TGCAG$配对。一个相对短的碱基序列能通过往该序列中任意位置补足碱基来与一个相对长的碱基序列配对。补全碱基的位置、数量不同，都将视为不同的补全方案。现在有两串碱基序列$S$和$T$，分别有$n$和$m$个碱基($n\geq m$)，问一共有多少种补全方案。

## 说明/提示

样例解释：  
$TCC$的$4$种补全方案（括号中字符为补全的碱基）  
$(GA)TC(AT)C(TTC)$  
$(GA)TC(ATCTT)C$  
$(GA)T(CAT)C(TT)C$  
$(GATCA)TC(TT)C$  

数据范围：  
对于$30\% $数据，$n\leq 1000,m\leq 2$  
对于$50\% $数据，$n\leq 1000,m\leq 4$  
对于$100\% $数据，$n\leq 2000,m\leq n$  

## 样例 #1

### 输入

```
10 3
CTAGTAGAAG
TCC```

### 输出

```
4```

# 题解

## 作者：AquaRio (赞：2)

### [我的博客](http://39.105.95.125/index.php/archives/160/)

### 题目传送门：[P5484](https://www.luogu.org/problem/P5484)

## 思路：

此题考虑直接dp，设 $f[i][j]$ 表示A串匹配了 $i$ 个，B串匹配了 $j$ 个的方案数。  

想想怎么转移？  

我们关注A串。当A串增添一个字符 $a_i$，即从 $f[i-1][j]$ 转移到 $f[i][j]$ 的时候。

假如 $a_i$ != $b_j$，那么显然有 $f[i][j]=f[i-1][j]$ 。  

假如 $a_i$ == $b_j$，那么所有的 $f[i-1][j-1]$ 包含的串都可以在后面接上 $a_i,b_i$ ，同样地，那么所有的 $f[i-1][j]$ 包含的串，都可以把B串的最后一个去掉，然后再分别填上 $a_i,b_i$ 。所以 $f[i][j]=f[i-1][j-1]+f[i-1][j](when \ a_i == b_j)$   

我们想象到方案数巨多，并且没有取模，所以肯定要用高精。  

此时又有一个问题，每个状态都要开一个二维数组，还要处理高精，容易MLE，怎么办呢？  

我们容易想到到 $i$ 可以用滚动数组优化（具体看我的代码里面qaq），然后我们就可以A一道省选题啦！  

## 代码：(~~压8位高精~~)

```cpp
#include<bits/stdc++.h>
#define lovelive 100000000
using namespace std;

int n,m,p=1,l;

char a1[2009],a2[2005];

struct aqours{
	int s[105],l;
	aqours(){l=1;}
}f[2][2005];

aqours operator + (aqours a,aqours b){//重载运算符 
	aqours c;
	c.l=max(a.l,b.l);
	memset(c.s,0,sizeof c.s);
	for(int i=1;i<=c.l;i++){
		c.s[i]+=a.s[i]+b.s[i];
		if(c.s[i]>=lovelive){
			c.s[i]-=lovelive;
			c.s[i+1]++;				//压8位高精qaq 
		}
	}
	if(c.s[c.l+1]) c.l++;
    return c;
}


bool chikatakami(char a,char b){//判断是否可以匹配 
	return 
	(a=='A'&&b=='T') ||
	(a=='C'&&b=='G') ||
	(a=='T'&&b=='A') ||
	(a=='G'&&b=='C');
}


void print(aqours a){
	cout<<a.s[a.l];
	for(int i=a.l-1;i;i--){
		printf("%08d",a.s[i]);
	}
} 

int main(){
	scanf("%d%d%s%s",&n,&m,a1+1,a2+1);
	f[0][0].s[1]=1;f[1][0].s[1]=1;
	for(int i=1;i<=n;i++,p^=1,l^=1)//滚动数组
        for(int j=1;j<=m;j++){
            f[p][j]=f[l][j];
            if(chikatakami(a1[i],a2[j])) f[p][j]=f[p][j]+f[l][j-1];//DP
        }
    print(f[l][m]);
    return 0;
}




---

## 作者：紊莫 (赞：1)

简单 DP。

$f_{i,j}$ 表示第一个串前 $i$ 位，后一个串前 $j$ 位的配对数量。

那么考虑当前的 $i$ 和 $j$ 发现有两种可能，一种是这两个配对成功了，那么就可以从 $f_{i-1,j-1}$ 转移而来，另一种是失败了，那么就可以从 $f_{i-1,j}$ 转过来。

初始设 $f_{0,0}=1$ 即可，如果你愿意可以把第一维优化掉，此外需要高精度。

[示例代码。](https://www.luogu.com.cn/paste/t1mllkth)

---

## 作者：Provicy (赞：1)

刚看到这题的时候，也许会想到[这题](https://www.luogu.org/problem/P1140)

但事实上，这一道题难度没有那么大，$DP$转移方程也比那一题好写多了。

根据题目的配对条件，我们尝试把长度$(m<=n)$较小的字符串$T$反转，反转完后题意就是求两个字符串的**公共子序列**的个数

那么显然，我们可以设$dp[i][j]$为在字符串$S$的前$i$个和字符串$T$的前$j$个所能组成的方案个数。

如果说$s[i]==t[j]$，那么$i$之前所有相同的子序列都可以接上$s[i]$这个字母，同时，之前已经包含$s[i]$的子序列也被包含其中。否则，$dp[i][j]$就直接从上一层的$dp[i-1][j]$转移过来即可。

综上，可以得到：

$dp[i][j]=\begin{cases}dp[i-1][j-1]+dp[i-1][j](s[i]==t[j])\\dp[i-1][j](s[i]!=t[j])\end{cases}$

同时，我们观察这个状态转移方程，看到f[i][j]的转移仅和$i-1$与$j-1$有关系，那么我们就可以用一个滚动数组优化其空间，方程如下：

$dp[j]+=dp[j-1]$$(s[i]==t[j])$

别忘了初始化时把$dp[0]=1$，否则算到最后都是$0$

观察数据范围，我们需要用高精，如果觉得不稳可以使用压位高精，本人此处使用压8位高精。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2100;
const int M=2010;
const int Loveti_you_xiao_you_qiang_wu_di_la_QwQ=100000000;
int n,m;
struct Node
{
	int x[N],lens;
	Node() { lens=1;}
}dp[M];
char s[N],t[N];
Node operator + (const Node& a,const Node& b)
{
	Node res;
	res.lens=max(a.lens,b.lens);
	memset(res.x,0,sizeof(res.x));
	for(int i=1;i<=res.lens;i++)
	{
		res.x[i]+=a.x[i]+b.x[i];
		if(res.x[i]>=Loveti_you_xiao_you_qiang_wu_di_la_QwQ)
		{
			res.x[i+1]++;
			res.x[i]-=Loveti_you_xiao_you_qiang_wu_di_la_QwQ;
		}
	}
	if(res.x[res.lens+1]) res.lens++;
	return res;
}
int main()
{
	scanf("%d%d%s%s",&n,&m,s+1,t+1);
	for(int i=1;i<=m;i++)
	{
		if(t[i]=='A') t[i]='T';
		else if(t[i]=='T') t[i]='A';
		else if(t[i]=='C') t[i]='G';
		else if(t[i]=='G') t[i]='C';
	}
	dp[0].x[1]=dp[0].lens=1;
	for(int i=1;i<=n;i++) for(int j=m;j;j--) if(s[i]==t[j]) dp[j]=dp[j]+dp[j-1];
	cout<<dp[m].x[dp[m].lens];
	for(int i=dp[m].lens-1;i;i--) printf("%08d",dp[m].x[i]); printf("\n");
	return 0;
}
```


---

## 作者：Ofnoname (赞：1)

显然 ，把第一个或者第二个序列翻转，剩下的任务就可以看做是公共子序列的个数.

反转后，设$f[i][j]$表示长序列里前i个，短序列里前j个得到的方案数。

```
ACACAAG
ACG
```

比如求$f[7][3]$，此时$A[7]=B[3]$，都为字母G。所以7以前所有的$AC$都可以接上这个$G$，而之前6个字母已经组成的$ACG$也算在内，即$f[7][3]+=f[6][2]+f[6][3]$

所以$f[i][j]=f[i-1][j-1]+f[i-1][j],A[i] == B[j]$，否则$f[i][j]=f[i-1][j]$。

由于$f[i][]$只会由$f[i-1][]$得到，$f[][j]$只会由$f[][j]$和$f[][j-1]$得到，所以倒序枚举可以省去第一维。

边界： 没有任何字符的方案数应设为1（$f[0]=1$）。否则加来加去都是0。

**另外：这道题答案超过了__int128的范围，需要用到高精。**

```cpp
int N,M;
char A[2005],B[2005];

int main()
{
    scanf("%d%d\n",&N,&M);
    scanf("%s\n%s",A+1,B+1);
    for (register int i=1; i<=M; i++)
	{
		if (B[i] == 'A') B[i] = 'T';
		else if (B[i] == 'T') B[i] = 'A';
		else if (B[i] == 'C') B[i] = 'G';
		else if (B[i] == 'G') B[i] = 'C';
	}
    f[0].d[0] = f[0].size = 1;
    for (register int i=1; i<=N; i++)
        for (register int j=M; j>=1; j--)
            if (A[i] == B[j]) f[j]+=f[j-1];
    f[M].output();
} 
```



---

## 作者：huhangqi (赞：0)

挺水的。

直接用 $dp_i$ 表示已经配对到第 $i$ 位的方案数。

那么直接从后往前遍历字符串进行配对即可。

这里从后往前是为了转移上一步的状态而不是转移这部分的状态。

关键是要看出来是高精度。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
char s[10005],t[10005];
struct BN{
	int c[1005],len;
	BN(){
		memset(c,0,sizeof(c));
		len=1;
	}
	BN(int x){
		memset(c,0,sizeof(c));
		len=0;
		while(x){
			c[++len]=x%10;
			x/=10;
		}
	}
	BN friend operator+(BN a,BN b){
		BN c;
		c.len=max(a.len,b.len);
		for(int i=1;i<=c.len;i++){
			c.c[i]=a.c[i]+b.c[i];
		}
		for(int i=1;i<=c.len;i++){
			c.c[i+1]+=c.c[i]/10;
			c.c[i]%=10;
		}
		while(c.c[c.len+1]){
			c.len++;
			c.c[c.len+1]+=c.c[c.len]/10;
			c.c[c.len]%=10;
		}
		return c;
	}
	void print(){
		for(int i=len;i>=1;i--)cout<<c[i];
	}
}dp[2005];
signed main(){
	cin>>n>>m;
	cin>>s+1>>t+1;
	dp[0]=1;
	for(int i=1;i<=n;i++){
		if(s[i]=='C')s[i]='G';
		else if(s[i]=='G')s[i]='C';
		else if(s[i]=='A')s[i]='T';
		else if(s[i]=='T')s[i]='A';
		for(int j=m;j>=1;j--){
			if(s[i]==t[j])dp[j]=dp[j]+dp[j-1];
		}
	}
	dp[m].print();
	return 0;
}

``````

---

## 作者：Cure_Wing (赞：0)

[P5484 [JLOI2011] 基因补全](https://www.luogu.com.cn/problem/P5484)

### 思路

这种题目长得就很像动态规划，规划字符串的截取状态。

于是想到设 $f_{i,j}$ 表示当 $S$ 串取到第 $i$ 个位置时，$T$ 串能够匹配到第 $j$ 个位置的方案数（字符串下标从 $1$ 开始）。

转移很好想：当 $S$ 串取到第 $i$ 个位置时，不匹配 $T$ 串第 $j$ 个位置时，$f_{i-1,j}\to f_{i,j}$，没有任何限制条件；匹配 $T$ 串第 $j$ 个位置时，$f_{i-1,j-1}\to f_{i,j}$，但是要满足条件 $S$ 串第 $i$ 个位置与 $T$ 串第 $j$ 个位置匹配。

对于边界的处理，就是 $f_{0,0}=1$，原因显然。

由于本题内存较小，实现时需要滚动数组优化。

由于本题答案较大，实现时还需要高精度。

时间复杂度 $O(nm)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using std::cin;using std::cout;
constexpr int N=2003;
int n,m;
std::string s,t;
struct Bigint{//高精度部分
	int a[200],len;
	Bigint(){memset(a,0,sizeof(a));len=0;}
	Bigint(int x){if(x==0){a[1]=0;len=1;}if(x==1) a[1]=len=1;}
	inline void print(){for(int i=len;i>=1;--i) cout<<a[i];}
	inline int& operator[](int i){return a[i];}
	inline void flatten(int L){
		len=L;
		for(int i=1;i<=len;++i){a[i+1]+=a[i]/10;a[i]%=10;}
		for(;!a[len]&&len>1;--len);
	}
}f[2][N];
inline Bigint operator+(Bigint a,Bigint b){
	Bigint c;c.len=std::max(a.len,b.len)+1;
	for(int i=1;i<=c.len;++i) c[i]=a[i]+b[i];
	c.flatten(c.len);
	return c;
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>m>>s>>t;f[0][0]=Bigint(1);s=" "+s;t=" "+t;//边界条件
	for(int j=1;j<=n;++j){
		for(int i=0;i<=m;++i){
			f[j&1][i]=f[!(j&1)][i];//第一种无条件转移
			if(t[i]+s[j]=='A'+'T'||t[i]+s[j]=='C'+'G') f[j&1][i]=f[j&1][i]+f[!(j&1)][i-1];//第二种带条件转移
		}
	}
	f[n&1][m].print();
	return 0;
}
```

---

## 作者：TLE_AK (赞：0)

### 题意
给定长度分别为 $n$ 与 $m$ 的字符串 $S$ 与 $T$。当它们等长且任意的 $i$ 的 $S_i=T_i$ 配对（两个字母分别为 `A` 与 `T` 或者 `G` 与 `C`）时，它们匹配，求有几种补充 `T` 的方案使 `S` 与 `T` 匹配。 
## 思路
计数类问题，因为限制较多，所以放弃排列组合，转为 `dp`。  
设 $dp[i[j]$ 表示 $S$ 中前 $i$ 个与 $T$ 中前 $j$ 个匹配时有的方案数，那就会有 $2$ 种情况：
1. $S[i]=T[j]$
2. $S[i] \ne T[j]$

在 $2$ 种情况中，我们都可以自己添加让 $S_i$ 匹配的字母，使它们匹配，这时 $j$ 不会有变化，也就是 $dp[i][j]=dp[i-1][j]$。

但在第 $1$ 种情况中，我们可以直接让第 $j$ 个去匹配，那么这时的方程就变为 $dp[i][j]=dp[i-1][j]+dp[i-1][j-1](\texttt{if} S_i=T_i)$。

最后很明显初始值为 $dp[0][0]=1$ 因为啥事都没干，结束值为 $dp[n][m]$（因为要用完）。

令人痛苦的，因为 $n \le 2000$ 所以要写高精度，但是不能直接开三维，所以直接滚动数组压缩一维后倒序枚举就可以了。
### 代码
```
#include<bits/stdc++.h>
using namespace std;
namespace acac
{
	int A[2010],B[2010];
	char S1[2010],S2[2010];
	int dp[2010][1010],len[2010];
	int zh(char ch)//转化字符
	{
		if(ch=='A')return -1;
		else if(ch=='T')return 1;
		else if(ch=='C')return -2;
		else return 2;
	}
	void add(int w,int w2)//高精度
	{
		len[w]=max(len[w],len[w2]);
		int jw=0;
		for(int i=1;i<=len[w];i++)	
		{
			int h=dp[w][i]+dp[w2][i]+jw;
			jw=h/10;
			dp[w][i]=h%10;
		}
		if(jw)
		{
			len[w]++;
			dp[w][len[w]]=jw;
		}
	} 
	int main()
	{
		int n,m;
		scanf("%d%d",&n,&m);
		scanf("%s%s",S1+1,S2+1);
      //这里我将字母转为数字，这样直接看和是否等于0就行了
		for(int i=1;i<=n;i++)
		{
			A[i]=zh(S1[i]);
		}
		for(int i=1;i<=m;i++)
		{
			B[i]=zh(S2[i]);
			len[i]=1;
		}
		dp[0][1]=1;
		for(int i=1;i<=n;i++)
		{
			for(int j=min(i,m);j>=0;j--)//倒序枚举，不然顺序会乱
			{
			//	int ydp=dp[j];
			//	dp[j]=dp[j];
				if(j&&A[i]+B[j]==0)add(j,j-1);//相等时更新
				
			}
		}
		for(int i=len[m];i;i--)//output
		{
			cout<<dp[m][i];
		}
		return 0;
	}
}
int main()
{
	acac::main();
	return 0;
}
```

---

## 作者：Chivas_Regal (赞：0)

# 思路

## 任务简化

要匹配的话我们按要求把字符串 $A$ 转译一下  
由于我们可以在字符串 $B$ 中加入任何字符变成 $A$  
反过来就是问我们在字符串 $A$ 的子序列中能找到多少个 $B$  

## 问题解法

这个问题就很简单了  
我们枚举字符串 $A$ 的下标 $i$ ，$A_i$ 能做出的贡献就是：  
对于所有的 $B_j=A_i$ ，若 $j>1$ ，那么在字符串 $A$ 的所有 $B_{j-1}$ 字符全都接着 $B_j$ 这个字符再往后走一步  
如果 $j=0$ 就是他自己要 $+1$   
那就是妥妥的 计数 $dp$ 了
  
## 伪代码设计
  
所以我们设置 $dp_j$ 表示外层枚举到 $A_i$ 时，子序列结尾为 $B_j$ 的方案数  
那么转移方程为 ：  
$\begin{aligned}&for\;i[0\longrightarrow n-1]:\\&\quad for\;j[m-1\longrightarrow 0]:\\&\quad\quad \quad if\;j>0:&dp_j=dp_j+dp_{j-1}\\&\quad\quad\quad else:&dp_j=dp_j+dp_{j-1}\end{aligned}$  
>注意，这里倒着枚举 $j$ 是防止同一步之前更新过的 $j-1$ 加给 $j$

# 代码

数过大，普通的类型会溢出  
这里只给出直观的普通类型 C++ 代码，改大数可以自行更改（我用的是 java
```cpp
ll dp[2005];

int main () {
        ll n, m; cin >> n >> m;
        string s, t; cin >> s >> t;
        // 转义
        for ( int i = 0; i < n; i ++ ) {
                if ( s[i] == 'A' ) s[i] = 'T';
                else if ( s[i] == 'T' ) s[i] = 'A';
                else if ( s[i] == 'C' ) s[i] = 'G';
                else s[i] = 'C'; 
        } 
        // 计数
        for ( int i = 0; i < n; i ++ ) {
                for ( int j = m - 1; j >= 0; j -- ) {
                        if ( s[i] == t[j] ) {
                                if ( j ) dp[j] += dp[j - 1];
                                else dp[j] ++;
                        }
                }
        }
        cout << dp[m - 1] << endl;
}
```

---

## 作者：_lfxxx_ (赞：0)

UPD：更正错字，以及新增一小点内容。

不难发现，题意就是问我们序列 $T$ 是否能与序列 $S$ 的一部分能否匹配，这样一来我们就好进行 DP 了。

设 $f_{i,j}$ 为 $T$ 的前 $j$ 个能在 $S$ 前 $i$ 个中能匹配的方案数。

首先不考虑 $T$ 多的那一个，那么能从 $f_{i-1,j}$ 转移过来。

多的那一位只有匹配上才对当前有用，所以如果匹配上，那么就可以从 $f_{i-1,j-1}$ 转移过来。

边界是 $f_{0,0}=1$，因为空串可以匹配出 $1$ 种。

所以：
$$
f_{i,j}\gets\left\{
\begin{aligned}
f_{i-1,j}&+f_{i-1,j-1}&(S_i=T_j)\\
f_{i-1,j}&&(S_i\neq T_j)
\end{aligned}
\right.
$$

看到 DP 只跟 $j$ 有关系，可以把第一维滚掉，即：
$$f_j\gets f_j+f_{j-1}(S_i=T_j)$$

**别忘了打高精，还要压位！**
### 代码：
[高精模板](https://www.luogu.com.cn/paste/ia5bn6zq)
```cpp
int n,m,a[2005],b[2005];
bignum f[2005]={1};
int main(){
	char ch;
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>ch;
		if(ch=='A')
			a[i]=1;
		else if(ch=='T')
			a[i]=2;
		else if(ch=='C')
			a[i]=3;
		else
			a[i]=4;
	}
	for(int i=1;i<=m;++i){
		cin>>ch;
		if(ch=='A')
			b[i]=2;
		else if(ch=='T')
			b[i]=1;
		else if(ch=='C')
			b[i]=4;
		else
			b[i]=3;
	}
	for(int i=1;i<=n;++i)
		for(int j=m;j>=1;--j)
			if(a[i]==b[j])
				f[j]+=f[j-1];
	cout<<f[m]<<endl;
	return 0;
}
```

---

## 作者：Daniel2020 (赞：0)

## 我的第一篇题解

题意很明了，求对 $ T $ 的一种补全方案 **(添加字符)** 使其与 $ S $ 配对 **( A - T / T - A / C - G / G - C )**。

首先将 $ T $已有的字符逆过来(即变为配对所需的字符)，就可以发现 **实际是求 $ S $ 中和 $ T $ 相同的子串数量**。

于是这道题就~~做完了~~做法很明了...

记 $ f_i $ 为以 $ T $ 中第 $ i $ 个字符结尾的字串数量 **（此时字符下标从 1 开始计算）**。

将 $ S $ 从前往后扫一遍，更新数组。

那么具体如何更新呢？

我们知道，**当我们在 $ S $ 的第 $ i $ 位中扫到 $ T $ 中的第 $ j $ 个字符时，它能与所有先前在 $ S $ 中以 $ T $ 中第 $ j-1 $ 个字符结尾的子串构成合法子串** ，于是据此得到 DP 方程：

$ f_i = f_i + f_{i-1} (S_i = T_j)$

$ f_m $为最终所求（根据题意， $ m $ 为字符串 $ T $ 的长度）。

注意：
- 运算中数据很大，要开**高精度**。
- DP 数组要**从后往前扫**，否则会因为在同一位上不合法的重复更新 **（即对 $ S $ 中同一个字符的反复使用更新 DP 数组）** 而 WA （可以类比为 0-1 背包和完全背包之间的区别）。
- 在处理 $ T $ 时注意看清代码，不要出现将一个字符变为其对应的字符后又还原的情况（否则会因为~~变回原字符~~转换字符无效卡 BUG）。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2002;
int n,m,ans[N][N],len[N];
char a[N],b[N];
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= n;i++)
		cin>>a[i];
	for(int i = 1;i <= m;i++)
	{
		cin>>b[i];
		if(b[i] == 'A') b[i] = 'T';
		else if(b[i] == 'T') b[i] = 'A';
		else if(b[i] == 'C') b[i] = 'G';
		else if(b[i] == 'G') b[i] = 'C';
	}
	for(int i = 1;i <= m;i++) len[i] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = m;j >= 1;j--)
		{
			if(a[i] == b[j])
			{
				if(j == 1)
				{
					ans[1][1]++;
					int pos = 1;
					while(ans[1][pos] >= 10)
					{
						ans[1][pos+1]++;
						ans[1][pos] %= 10;
						pos++;
						len[1] = max(len[1],pos);
					}
				}
				else
				{
					int maxlen = max(len[j],len[j-1]);
					for(int k = 1;k <= maxlen;k++)
						ans[j][k] += ans[j-1][k];
					for(int k = 1;k <= maxlen;k++)
						if(ans[j][k] >= 10)
						{
							ans[j][k+1]++;
							ans[j][k] %= 10;
						}
					len[j] = maxlen;
					if(ans[j][maxlen+1]) len[j] = maxlen+1;
				}
			}
		}
	for(int i = len[m];i >= 1;i--)
		cout<<ans[m][i];
	return 0;
}
```

后记：

Update:

2021.12.17： 更新了 LaTeX 和内容。

2021.12.18： 更新内容。

2021.12.18： 更新LaTeX。


---


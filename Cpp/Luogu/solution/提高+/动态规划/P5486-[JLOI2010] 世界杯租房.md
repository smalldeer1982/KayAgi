# [JLOI2010] 世界杯租房

## 题目描述

南非世界杯组委会指定了在此期间可提供的一些旅馆供球迷租赁，名为阿凡达的即是其中一所。因为阿凡达旅馆房子的数目不超过$26$，所以它们可以用$26$个大写字母表示。  
有一天，刘经理的电话响了，他接到了一个租赁房屋的请求，要求从$6$月$12$日晚起租到$6$月$19$日中午。于是他察看了预定表，但是并没有发现一间房屋能够直接满足要求。比如房主可能因为一些私人原因需要留在自己的房子中，所以这个游客不得不在其中的一间先住上几天再搬到另一间住上几天。他详细检查了预定表后，对旅客说：“我将你先在$B$安置$3$天，再将你安排到$F$去度过剩余的旅途。”  
你的目标是使得游客从一间房屋搬到另一间房屋的次数最少。  
注意在旅馆的计费中，总是将某一天的晚上到第二天的中午视作一天。  

## 样例 #1

### 输入

```
10 7
XXXXXXX
XOXXXXO
XOXXXXO
XOXXXOX
OXXOXOX
XOXOXOX
OXXOXOX
OXXXXOX
XXXXXXX
XXXXXXX
2 9
0 0```

### 输出

```
Case 1:

B: 2-5
F: 5-9```

# 题解

## 作者：Reply_ (赞：12)

# 题意简述

-  给出旅馆中所有房间的空闲情况，求从第 $s$ 天到第 $t$ 天的住房方案 。


- 要求方案的字典序最小(重要！！！)。



- 若不存在这样的方案，输出一行“Not available”。

# 题目分析
- 第一眼贪心，打了一个发现出问题，于是开始考虑别的算法(~~看算法标签~~)。



- 明显这道题要用 dp ，然后我们会发现正着推它不好推，所以我们考虑倒着推，从 $t-1$ 开始倒着推到 $s$。

- 定义 $f_{i,j}$ ：第 $i$ 天在 $j$ 号房入住时共换了几次房，一开始全赋值为最大值即可。

- 定义 $g_{i,j}$ ：第 $i$ 天在 $j$ 号房号房入住时第 $i+1$ 天能到换房次数最少、字典序最小的房间编号。



- 因为房间变了换房次数就要 +1，所以有如下状态转移方程：      $f_{i,j}=\min(f_{i,j},f_{i+1,k}+(j\neq k))$，$g$ 数组在 $f$ 更新时顺便记录即可




### 转移：
```cpp
for(int i = t-1;i>=s;i--)
	{
		F(j,1,m)
		{
			F(k,0,m)
			{                          
				if(c[i+1][k]=='X' || c[i][j] =='X') continue;//判断该状态合法以及转移而来的状态合法
				int nw=f[i+1][k]+(j!=k);
				if(f[i][j]>nw&&k!=0)
				{
					g[i][j]=k;//顺带转移了g数组
				}
				f[i][j]=min(f[i][j],f[i+1][k]+(j!=k));
			}
		}	
  
```

### 输出

这里也是有点难度(对于我来说)，卡了我有一会儿

```cpp
for(int i = s;i<=t;i++)
	{
		if(g[i][w]!=w)
		{
			if(w<1 || w>26) return;
			cout << char((w+'A'-1));
			cout << ": "<<nw << "-"<<i+1<<'\n';
			w=g[i][w];
			nw=i+1;
		} 
	}
```

 其他的代码希望读者自行编写
 
 
 另外，感谢某位不愿透露姓名的同学的帮助给予一些思路





---

## 作者：Infinity_Fantasy (赞：5)

一道模拟题，根据题意写代码即可。中间有一个部分需要区间 dp，很经典的枚举区间和断点，求出最小中转次数并记录断点，便于输出。

**注意题目中要求不能输出多余的空行。**
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[110][30],d[110][30];
char a[110][30];
int n,m,s,t,i,j,k,ans,T;
//由于输出格式特殊，因此封装函数
void print(int s,int i,int j){
    if(i==t) return;
    if(d[i][j]!=j){
        printf("%c: %d-%d\n",'A'+j-1,s,i+1);
        print(i+1,i+1,d[i][j]);
    }else print(s,i+1,j);
}
int main(){
    while(cin>>m>>n&&n){
        for(i=1;i<=m;i++)
            scanf("%s",a[i]+1);
        cin>>s>>t;
        //多测记得初始化
        memset(f,0x3f,sizeof f);
        f[t][0]=0;
        for(i=t-1;i>=s;i--)
            for(j=1;j<=n;j++)
                if(a[i][j]=='O')
                    for(k=0;k<=n;k++)
                        //如果有更小的就更新答案
                        if(f[i+1][k]+(j!=k)<f[i][j]){
                            f[i][j]=f[i+1][k]+(j!=k);
                            d[i][j]=k;
                        }
        ans=0x3f3f3f3f;
        for(i=1;i<=n;i++)
            if(f[s][i]<ans)
                ans=f[s][i],j=i;
        printf("Case %d:\n\n",++T);
        if(ans==0x3f3f3f3f) puts("Not available"); //没搜到答案
        else print(s,s,j);
        puts("");
    }
    return 0;
}
```

---

## 作者：AchorX (赞：3)

### 题意

- 已知部分房间使用情况，求从第 $s$ 天晚上到第 $t$ 天早上换房次数最少的方案
- 字典序最小
因此我们以有序数对 < $i$ , $j$ > 来表示状态：第 $i$ 天晚上住在第 $j$  个房间

### 分析

1. 首先求“最少”，先考虑贪心。从某一个房间开始尽量不换房地住，但是显然，无法保证当前最优解（指从第一天到第 $i$ 天的最优解）一定是全局最优解的一部分。叉掉
2. 然后可以想到搜索。
	DFS：对时间复杂度进行分析：$n$ 天，每天最多有 $m$ 种选择，即最差为 $n^m$ 种，无法承受。
	BFS：每一个存在的状态都会入队，为 $nm$ ；每一个入队的状态都会枚举以后要住的所有房间（前一天或后一天，后文讨论），假设每一次枚举都会入队，就是 $nm^2$ ，但可能重复进队，不妨再算上一个 $m$  （ $nm^3$ )，也同样可以承受。
3. 既然都搜索了肯定可以思考一下可不可以 dp。
	由BFS可以想到状态定义只需要记录 < $i$  , $j$ > 就可以。
	设 $dp_{i,j}$  为第 $i$ 天晚上住在第 $j$  个房间时的最少换房次数，显然，在状态更新时换房 +1，不换房直接更新
	时间复杂度 $nm^2$ ，分别是枚举时间、房间、下一个房间

然后我们来到了第二个问题，字典序最小

我们的两种方法都是在最终的状态取最优，也就是说，在算出所有可能的答案以后才可以知道最优解。我觉得这句话不好懂，但我语言表达能力有限，所以我们来举个例子：

假设我们从第 $s$ 天开始计算，那么我们可以且仅可以在第 $t$ 天得到每一种情况答案，也就是 $dp_{t,j}$ 。虽然我们可以在计算时顺便记录前后节点，但是我们可以根据最后的第 $t$ 行状态来确定最小的字典序吗？显然不可以。最后一行的字典序与最小字典序（从第一行开始）无关。
因此，我们需要让最后的状态可以确定最小的字典序，也就是让第一行成为最后的状态，人话——倒序。
倒序就一定能保证字典序最小吗？一定。
```cpp
for (int i = t - 1; i >= s; --i) //第i天
		for (int j = 1; j <= m; ++j) //欲入住j
			for (int k = 1; k <= m; ++k) { //欲换房到k
				if (able[i][j] || able[i + 1][k]) continue;
				if (dp[i][j] > dp[i + 1][k] + (j != k)) 
					pre[i][j] = k;
				dp[i][j] = min(dp[i + 1][k] + (j != k), dp[i][j]);
			}
```

我们在枚举时是有顺序的，都是从小到大；相等的情况不更新，所以只要更新，就是当前最小字典序的最优状态。

以下为综合了DP和BFS的代码，作者的目标是尽可能让代码易懂，可能会有更好的写法，欢迎私信交流。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 105;
int n, m, dp[N][N], pre[N][N], s, t, num, beg;
//pre[i][j] 表示第i天的上一个状态的房间号
bool able[N][N];
void clear() {
	memset(pre, -1, sizeof pre);
	memset(able, 0, sizeof able);
}
void prin() {
	printf("Case %d:\n\n", num);
	int ans = 0x3f3f3f3f, k = 0;
	for (int i = 1; i <= m; ++i) {
		if (dp[s][i] < ans) {//第s行的最优解和最小字典序
			ans = dp[s][i];
			k = i;//房间号
		}
	}
	if (ans == 0x3f3f3f3f) {
		printf("Not available\n");
		return ;
	}
	char x = k - 1 + 'A';
	int benum = s;
	for (int i = s; i <= t; ++i) {
		if (pre[i][k] != k) {
			printf("%c: %d-%d\n", x, benum, i + 1);//后一天早上才离开，故+1
			k = pre[i][k];
			x = k - 1 + 'A';
			benum = i + 1;
		}
	}
}

void DP() {
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			dp[i][j] = 0x3f3f3f3f;
	t--;//在第t天早上退房，但只需要考虑t-1天的晚上能不能住
	for (int i = 1; i <= m; ++i) if (!able[t][i]) dp[t][i] = 1;
	for (int i = t - 1; i >= s; --i) //第i天
		for (int j = 1; j <= m; ++j) //欲入住j
			for (int k = 1; k <= m; ++k) { //欲换房到k
				if (able[i][j] || able[i + 1][k]) continue;
				if (dp[i][j] > dp[i + 1][k] + (j != k)) pre[i][j] = k;
				dp[i][j] = min(dp[i + 1][k] + (j != k), dp[i][j]);
			}
}
void read() {
	for (int i = 1; i <= n; ++i) {
		scanf(" ");
		for (int j = 1; j <= m; ++j) {
			char x;
			scanf("%c", &x);
			able[i][j] = (x == 'X');//able = 1表示不可以住
		}
	}
	scanf("%d%d", &s, &t);
}
struct Node {
	int i, j, w;
};
queue<Node>q;
void bfs() {
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			dp[i][j] = 0x3f3f3f3f;
	--t;
	for (int i = 1; i <= m; ++i) if (!able[t][i]) q.push({t, i, 1}), dp[t][i] = 1;
	while (!q.empty()) {
		int i = q.front().i, j = q.front().j;
		q.pop();
		if (i == s) continue;
		for (int k = 1; k <= m; ++k) {
			if (able[i - 1][k]) continue;
			if (dp[i][j] + (j != k) < dp[i - 1][k]) {
				dp[i - 1][k] = dp[i][j] + (j != k);
				pre[i - 1][k] = j;
				q.push({i - 1, k, dp[i - 1][k]});
			}
		}
	}
}
int main() {
	while (1) {
		clear();
		scanf("%d%d", &n, &m);
		if (n == m && n == 0) break;
		if (num) puts("");
		num++;
		read();
		bfs();
//		DP();
		prin();
	}
	return 0;
}
```

---

## 作者：Awatesolo (赞：2)

# [JLOI2010] 世界杯租房 题解
## 题目大意
* 根据房间的空闲情况求每天的住房情况，并按**一定格式**输出换房情况。
* 答案应保证字典序最小。
## 算法选择
* 一眼看上去贪心：能住多久就住多久不行吗？
* 仔细思考：题目要求方案的字典序最小，那就否定了我们的贪心算法，而应使用 区间 DP 算法。
## 转移方程
* 我们定义，$f_{i,j}$ 为第 $i$ 天住第 $j$ 号房的最优方案，则 $f_{i,j}=\max(f_{i,j},f_{i+1,k}+flag)(0 \leq k\leq n)$ 其中若换房 $flag=1$，否则 $flag=0$。
## 程序步骤
1. 输入 $m,n,s,t$ 和二维字符矩阵。

2. 由于我们的答案**越小越优**，则我们应当使我们的 DP 数组**填满最大值**，由于一开始没有进行换房，所以 $f_{t,0}=0$。

3. DP 寻找最优解，并使用 $dis$ 数组**记录各个住房**。

4. 找到最优的**起始**换房点。

5. 通过 $dis$ 数组**找到各个换房点**并输出。
## 时空复杂度分析
* 时间复杂度: $O(T\times n^2 \times m)$ 其中 $T$ 为测试数据组数，瓶颈在于 DP。
* 空间复杂度: $O(n\times m)$。
## 代码
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
char a[105][105];
int f[110][110],dis[110][100];
template<typename T>
inline void read(T &x) {
    x = 0;
    register char c = getchar();
    register short f = 1;
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    x *= f;
}
template <typename T, typename... Args>
inline void read(T &x, Args &...temps)
{
	read(x), read(temps...);
}
signed main(){
	int s,t;
	int tot=0;
	read(m,n);
	while(m||n){
		tot++;
		for(int i=1;i<=m;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j];//单字符输入
			}
		}
		read(s,t);
		memset(f,1145,sizeof f);//初始化dp数组
		f[t][0]=0;
		for(int i=t-1;i>=s;i--){//为获得第i天各个房间的最优方案，应先知道i+1
			for(int j=1;j<=n;j++){
				if(a[i][j]=='O'){
					for(int k=0;k<=n;k++){
						int fshf=0;
						if(j!=k) fshf=1;//查看是否换房
						if(f[i+1][k]+fshf<f[i][j]){
							f[i][j]=f[i+1][k]+fshf;
							dis[i][j]=k;//记录换房点
						}
					}
				}
			}
		}
		int ans=1e9,k;
		for(int i=1;i<=n;i++){
			if(f[s][i]<ans){
				ans=f[s][i];
				k=i;
			}
		}//找到最优的起始换房点
		printf("Case %d:\n\n",tot);
		if(ans==1e9) cout<<"Not available"<<endl;
		else{
			char now='A'+k-1;
			int befor=s;
			for(int i=s;i<=t;i++){
				if(dis[i][k]!=k){//若有换房，则输出
					printf("%c: %d-%d\n",now,befor,i+1);
					k=dis[i][k];
					now='A'+k-1;
					befor=i+1;
				}
			}
		}
		cout<<endl;
		read(m,n);
	}
	return 0;
}

```

---

## 作者：Melo_DDD (赞：1)

一道好的区间 dp & 我的第 $100$ 蓝。

# 题目大意

最少要转几次房以及字典序最小的解。

# 题目实现

因为不知道用什么其他算法，所以考虑动规。

然后发现是一道很明显的区间 dp 题。

所以顺理成章地设 $dp_{i,j}$ 为第 $i$ 天住第 $j$ 号房所需的最少换房次数。

由于要求字典序最小，所以再设一个 $r_{i,j}$ 表示在最优的情况下第 $i$ 天住第 $j$ 号房使下一天字典序最小的房间号。

更新很简单。

按照惯用套路，求字典序最小，从后往前推。

输出比较特殊，但是比较好理解（统计前后端点即可），看代码即可。

注意空格。

## 代码

```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 107 ;
int dp[N][N] ,ans ,s ,t ,r[N][N] ,num ,tot = 1 ;
char a[N][N] ;
template < typename T > inline void read (T &x) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
inline void init () {
	memset (dp ,0x3f ,sizeof (dp)) ;
	ans = 0x3f3f3f3f ;
	dp[t][0] = 0 ;
}
inline void print (int num ,int i ,int j) {
	if (j == t) return ;
	if (r[j][num] != num) {
		char ch = '@' + num ;
		cout << ch << ": " << i << "-" << j + 1 << '\n' ;
		print (r[j][num] ,j + 1 ,j + 1) ;
	}
	else {
		print (num ,i ,j + 1) ;
	}
}
int main () {
	for ( ; ; ) {
		int m ,n ;
		read (m) ,read (n) ;
		if (m == 0 && n == 0) goto her ;
		f (i ,1 ,m ,1) {
			cin >> a[i] + 1 ;
		}
		read (s) ,read (t) ;
		init () ;
		#define f_(i ,m ,n ,x) for (int i = (m) ;i >= (n) ;i -= (x)) 
		f_ (i ,t - 1 ,s ,1) {
			f (j ,1 ,n ,1) {
				if (a[i][j] == 'O') {
					f (k ,0 ,n ,1) {
						if (dp[i][j] > dp[i + 1][k] + (j != k)) {
							dp[i][j] = dp[i + 1][k] + (j != k) ;
							r[i][j] = k ;
						}
					}
				}
			}
		}
		#undef f_
		f (i ,1 ,n ,1) {
			if (ans > dp[s][i]) {
				ans = dp[s][i] ;
				num = i ;
			}
		}
		cout << "Case " << tot << ": " << '\n' ;
		tot ++ ;
		cout << '\n' ;
		if (ans == 0x3f3f3f3f) {
			puts ("Not available") ;
			cout << '\n' ;
			continue ;
		}
		print (num ,s ,s) ;
		cout << '\n' ;
	}
	her : return 0 ;
}
//kafka & かみや & 申鶴
```

---


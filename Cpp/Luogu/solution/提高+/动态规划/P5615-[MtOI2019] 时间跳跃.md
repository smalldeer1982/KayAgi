# [MtOI2019] 时间跳跃

## 题目背景

就算知道方法，也绝对不能去改变过去，绝不能将存在的可能性转变为既定的现实，未来是没有人能预测的，是无法重来的，正因如此人们才能接受各种痛苦，不幸与飞来横祸，迈步前进。

![](https://cdn.luogu.com.cn/upload/image_hosting/tz4v415b.png)

## 题目描述

因为某些原因，Rintaro 欠了 Mayuri 一根香蕉。

为了封上 Mayuri 的嘴，Rintaro 与 Mayuri 约定，只要 Mayuri 答对这个问题，Mayuri 想要多少香蕉都没问题：

---

机关有 $N$ 条秘密通道，第 $i$ 条秘密通道的长度为 $i$，机关会从 $2^n$ 种选择方式种**等概率**随机选出一些秘密通道，如果选出来的这些秘密通道能组成一个凸多边形，那么这个方案的权值就是选出的秘密通道数量，否则权值为 $0$。

那么请你求出选出来秘密通道的权值的期望模 $10^9+7$ 的值。（两种选择秘密通道的方案不同当且仅当存在一个秘密通道，在一个方案中被选择，而在另一个方案中未被选择。注意，空集也算一个方案。）

---

Kurisu：这不就只要...

Rintaro：助手你闭嘴！

Mayuri 在纸上画呀画，结果啥也没画出来，于是 Mayuri 就只能找你帮忙了。

## 说明/提示

#### 样例解释 1

容易发现，当 $n$ 小于等于 $3$ 的时候是一定无法组成合法的多边形的。

当 $n=4$ 的时候选出来的边长为这些集合的时候是权值不为 $0$ 的：

$\{1,2,3,4\}$，$\{2,3,4\}$。

答案就是 $\frac{7}{16} \equiv 937500007\ (\bmod 1000000007)$

当 $n=5$ 的时候选出来的边长为这些集合的时候是权值不为 $0$ 的：

$\{1,2,3,4\}$，$\{2,3,4\}$，$\{1,2,3,5\}$，$\{2,3,4,5\}$

$\{1,3,4,5\}$，$\{1,2,4,5\}$，$\{2,4,5\}$，$\{3,4,5\}$，$\{1,2,3,4,5\}$。

答案就是 $\frac{34}{32} \equiv 562500005\ (\bmod 1000000007)$

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 5000$，$1\leq T \leq 5000$

本题共 $5$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$20$分）：$1 \leq n \leq 10$。

子任务 $2$（$30$分）：$1 \leq n \leq 20$。

子任务 $3$（$15$分）：$1 \leq n \leq 50$。

子任务 $4$（$15$分）：$1 \leq n \leq 300$。

子任务 $5$（$20$分）：无特殊限制。

### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T3

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
5
1
2
3
4
5

```

### 输出

```
0
0
0
937500007
562500005```

# 题解

## 作者：CYJian (赞：10)

## 时间跳跃

首先给出一个结论: 对于 $n$ 条边, 这 $n$ 条边能组成一个 $n$ 边形当且仅当 最长边边长小于其余所有边长之和…

啥? 你问我怎么证? 三角函数会不会?? 三角形剖分也行啊…

#### Subtask1 20pts

~~给这一档部分分纯属好玩…~~

发现下发的样例中有了 $n=1,2,3,4,5$ 的点, 然后只需要算 $n=6,7,8,9,10$ 的点…手算就有 $20$ 分了QwQ…

#### Subtask2 30pts

如果您是猛汉, 那么就可以手算 $n=11, 12, 13, 14, 15, 16, 17, 18, 19, 20$ 的点, 然后打表就行了…

如果您是暴力选手, 那么就可以 $O(2^n)$ 枚举子集之后计算贡献…

#### Subtask3 15pts

首先我们可以发现, 我们对于一个边集, 其实是只关心 最长边的长度 和 所有边的长度之和 的…

然后可以暴力dp: 设状态 $f[i][j][k]$ 表示考虑长度为 $1$~$i$ 的边, 选出 $k$ 条出来, 长度和为 $j$ 的方案数…

然后我们可以发现, 我们每一次只需要统计: 当 $i$ 作为最长边的时候, $1$~$i-1$ 所组成的所有边集的方案对 $i$ 的贡献就行了…(这一步就是求每一次加入一条边的增量…)

那么我们就只需要统计, 有多少在 $1$~$i-1$ 中选出边数为 $k$ 的边集, 长度之和大于 $i$…

这个我们只需要在每一次 $dp$ 加入长度为 $i$ 的边的时候统计就好了…

然后暴力统计, 复杂度 $O(n^4)$ …

#### Subtask4 15pts

我们发现, 上一个算法中 $dp$ 的第二维我们要 $O(n^2)$ 的空间去存储…

但是实际上很没有必要…

我们考虑补集转化: 每一次统计所有的方案, 然后统计不合法的方案就行了…

发现: 不合法的方案就是 除去最长边后, 其余边的长度和小于等于 $i$…

然后这样子我们就可以把第二维压缩至 $O(n)$ 级别了…

统计的时候也就只要 $O(n^3)$ 去计算了…

考虑怎么计算所有集合的贡献和:

其实就是下面这个式子:
$$
\sum_{i=1}^{n} i \times \binom{n}{i}
$$
意思就是: 从 $n$ 条边中选出 $i$ 条来放到边集中, 这样的边集的权值为 $i$, 那么总贡献就是这个的和…

每次统计总贡献的复杂度就是 $O(n)$ 的…

所以总复杂度是 $O(n^3)$ …

#### Subtask5 20pts

还是考虑这个 $dp$ 的做法…

第二维是没法压缩了…

然后我们发现, 事实上我们在计算答案的时候并不需要第三维的限制, 只是计算时当做一个权重乘上去…

我们考虑能不能在 $dp$ 的时候就把这个权重给带进去…

考虑设状态 $f[i][j]$ 表示前 $i$ 条边中选出边长和为 $j$ 的方案数(第二维用 ${\rm Subtask4}$ 中的方法压缩)

再设状态 $g[i][j]$ 表示前 $i$ 条边中选出边长和为 $j$ 的权值和…

考虑怎么转移:

首先 $f$ 的转移很显然就是一个背包…

考虑 $g$ 的转移: 我们考虑加入一条长度 $i+1$ 的边加入边集, 那么如果是从 $g[i][j-i-1]$ 转移到 $g[i +1][j]$, 那么 就会在 $g[i][j - i - 1]$ 的所有状态的边集中加入一条长度为 $i+1$ 的边…然后考虑$g[i][j - i - 1]$ 的不同的边集个数是 $f[i][j - i - 1]$ 那么在每一个边集中加入一条边的权值和, 就等价于在原本的权值和的基础上加上等同于边集的个数的数…

这样我们就有了这个转移:
$$
g[i][j] = g[i-1][j]+g[i-1][j-i]+f[i-1][j-i]
$$
这样就可以把状态数压缩至 $O(n^2)$ 的级别…

由于状态之间的转移是 $O(1)$ 的, 所以复杂度就是 $O(n^2)$ 的…可以通过本题…

---

## 作者：一扶苏一 (赞：9)

## Description

给定 $n$ 条边，第 $i$ 条边的长度为 $i$，每条边都有 $50\%$ 的概率被选择，求如果选出的边能组成一个平面凸多边形，则方案的权值是方案中边的数量，否则权值为 $0$。求权值的期望对大质数取模的值。

有 $T$ 组数据。

## Limitations

$1 \leq n \leq T \leq 5000$

## Solution

因为 [$\mathsf \color{black}d\mathsf{\color{red} {isangan233}}$](https://www.luogu.org/space/show?uid=72679) 在 [yLOI](https://www.luogu.org/contest/20125) 的时候用倒数第二档子任务的做法[过了C题](https://www.luogu.org/blog/disangan233/solution-p5522)，所以我也要在 [MtOI](https://www.luogu.org/contest/22614) 用倒数第二档子任务的做法过掉他的 [C题](https://www.luogu.org/problem/P5615)

注意到因为所有情况的概率是相同的，因此只需要求出所有情况的总边数，除以 $2^n$ 即为期望。

考虑 DP。

根据平面几何的某定理，对于 $n$ 条线段，它们能组成一个平面凸多边形的充要条件是任意 $(n-1)$ 条线段的长度之和大于剩下一条线段的长度。

证明上必要性可以通过两点之间线段最短的公理证得，充分性可以对选择的线段数进行数学归纳。

得到推论：对于本题，选出的边能组成平面凸多边形的充要条件是最长的边的长度小于其他边长度之和。

证明上，考虑将最长的边换成其它的边，该边长度变小，剩余边长度之和变大，不等号方向不会改变。

设 $f_i$ 是所有边的长度都不超过 $i$ 时的所有能构成凸多边形情况的边数和。

考虑这些情况一共分两类，第一类是不包括长度为 $i$ 的边的情况，第二类是包括长度为 $i$ 的边的情况。

对于第一类情况，边数和就是 $f_{i - 1}$。

对于第二类情况，考虑剩下的边长度之和只要大于 $i$ 即可。

设 $g_j$ 是选至少两条边且边的长度和为 $j$ 时（不要求构成凸多边形）所有情况的边数和，$h_j$ 是选至少两条边且边的长度和为 $j$ 时（不要求构成凸多边形）的总情况数。这两个值均要求所选的边的长度不超过 $i$，实际上是省略了这两个值的第一维。

因此有

$$f_{i} = f_{i - 1} + \sum_{j = i + 1}^{i^2} (g_j + h_j)$$

这里加 $h_j$ 是因为对于每种情况都可以加一条长度为 $i$ 的边来构成一个凸多边形，对于所有情况，每种情况可以加一条边，一共可以加 $h_j$ 条边，而 $g_j$ 是这种情况原有的边数。

考虑递推 $g$ 和 $h$。

考虑从小到大枚举 $i$，即边长上限增加时，$g$ 和 $h$ 的变化。

对于 $g_j$，所有任选两条边且边权和为 $(j - i)$ 的情况，都可以加入这条边来达到边权和为 $j$，同时还有不选择加入长度为 $i$ 的边这种情况，因此有 

$$g_j = g_j + g_{j - i} + h_{j - i}~~~~~(j > i)$$

当然，对于选 $i$ 和另一条边的情况，也能对 $g$ 产生贡献，因此有 

$$g_{j + i} = g_{j + i} + 2~~~~~~(j < i)$$

对 $h$ 的递推同理：

$$h_j = h_j + h_{j - i}~~~~~(j > i)$$

$$h_{j + i} = h_{j + i} + 1~~~~~(j < i)$$

然后用得到的 $g$ 和 $h$ 递推 $f$ 即可。

考虑复杂度：所有边之和是 $O(n^2)$ 级别的，因此每次更新 $g$ 和 $h$ 都是 $O(n^2)$ 的，一共更新 $O(n)$ 次，因此更新 $g$ 和 $h$ 的总复杂度 $O(n^3)$。而递推 $f$ 时每次也是 $O(n^2)$ 的，一共更新 $O(n)$ 次，所以复杂度也是 $O(n^3)$。因此总时间复杂度 $O(n^3)$，可以通过前 $4$ 个子任务。

但是注意到我们的空间复杂度是 $O(n^2)$ 的，因此对于第 $5$ 个子任务，我们的空间完全能够承受，同时时间复杂度仍然是多项式级，因此 **本地挂机打表** 即可通过子任务 $5$，表的长度是 $48k$，甚至不需要用字符加密来缩短代码长度，直接存明文即可。

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int maxn = 100005;
const int MOD = 1000000007;
const int MODP = 1000000005;

int T, N;
int query[maxn];
ll frog[maxn], gorf[maxn], h[maxn];

ll mpow(const ll x, int y);

int main() {
  freopen("1.in", "r", stdin);
  qr(T);
  for (int i = 1; i <= T; ++i) {
    qr(query[i]);
    N = std::max(N, query[i]);
  }
  gorf[3] = 2; h[3] = 1;
  for (int i = 3, upceil = 3; i <= N; ++i) {
    for (int j = i + 1; j <= upceil; ++j) {
      (frog[i] += gorf[j] + h[j]) %= MOD;
    }
    (frog[i] += frog[i - 1]) %= MOD;
    upceil += i;
    for (int j = upceil; j >= i; --j) {
      (gorf[j] += gorf[j - i] + h[j - i]) %= MOD;
      (h[j] += h[j - i]) %= MOD;
    }
    for (int j = 1; j < i; ++j) {
      (gorf[j + i] += 2) %= MOD;
      (h[j + i] += 1) %= MOD;
    }
  }
  for (int i = 1; i <= T; ++i) {
    qw(frog[query[i]] * (mpow(mpow(2, query[i]), MODP)) % MOD, '\n', true);
  }
  return 0;
}

ll mpow(const ll x, int y) {
  ll _ret = 1, _tmp = x;
  while (y) {
    if (y & 1) (_ret *= _tmp) %= MOD;
    (_tmp *= _tmp) %= MOD;
    y >>= 1;
  }
  return _ret;
}
```



---

## 作者：mrsrz (赞：6)

[可能更好的体验](https://mrsrz.github.io/2019/11/03/lg5615/)

$k(k>2)$ 条边能组成凸 $k$ 边形的充要条件是，其中最长的边的长度严格小于其他边的长度之和。

考虑对每条边，计算出这条边作为最大边时的贡献。我们通过总贡献减去不合法方案数的方式来计算。

令 $f_{i,j}$ 表示前 $i$ 条边，选择的边长和为 $j$ 的方案数，$g_{i,j}$ 表示前 $i$ 条边，选择的边长和为 $j$ 的所有方案的贡献之和。

转移的时候，考虑边 $i$ 选或者不选，容易得出 $f_{i,j}=f_{i-1,j}+f_{i-1,j-i}$。

$g_{i,j}$ 类似，不过对于 $g_{i-1,j-i}$ 的每一种情况，转移时都会产生额外的 $1$ 的贡献。

因此 $g_{i,j}=g_{i-1,j}+g_{i-1,j-i}+f_{i-1,j-i}$。

然后，从 $n$ 条边里任选的总贡献为：
$$
\sum_{i=1}^ni\binom n i
$$
这个可以 $O(n)$ 求出单个。

上述转移时，$j$ 这一维是 $n^2$ 级别的，但我们考虑的是不合法方案，所以每次只考虑不超过当前 $i$ 的，所以只需转移 $n$ 个即可。

所以时间复杂度 $O(n^2)$。可以通过打表进行优化。

空间的话，开两个 $n^2$ 的整形数组会超，所以滚动数组优化一下即可。

## Code：

```c++
#include<iostream>
using namespace std;
const int md=1e9+7,N=5050,n=5000;
typedef long long LL;
int a[N],T,ans[N],f[2][N],g[2][N],_2[N],fac[N],iv[N];
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=(LL)a*a%md)
	if(b&1)ret=(LL)ret*a%md;
	return ret;
}
inline int C(int n,int m){return fac[n]*(LL)iv[m]%md*iv[n-m]%md;}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	f[0][0]=1;
	for(int i=_2[0]=1;i<=n;++i)_2[i]=(_2[i-1]<<1)%md;
	for(int i=*fac=1;i<=n;++i)fac[i]=(LL)fac[i-1]*i%md;
	iv[n]=pow(fac[n],md-2);
	for(int i=n-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;
	for(int i=1;i<=n;++i){
		for(int j=0;j<=n;++j)
		f[i&1][j]=f[i&1^1][j],g[i&1][j]=g[i&1^1][j];
		for(int j=i;j<=n;++j)
		upd(f[i&1][j]+=f[i&1^1][j-i]-md),
		g[i&1][j]=(g[i&1][j]+(LL)g[i&1^1][j-i]+f[i&1^1][j-i])%md;
		ans[i]=_2[i-1];
		for(int j=1;j<i;++j)
		ans[i]=(ans[i]+(LL)j*C(i-1,j))%md;
		for(int j=0;j<=i;++j)
		upd(ans[i]-=g[i&1^1][j]),upd(ans[i]-=f[i&1^1][j]);
	}
	for(int i=1;i<=n;++i)upd(ans[i]+=ans[i-1]-md);
	for(cin>>T;T--;){
		int n;
		cin>>n;
		cout<<(ans[n]*(LL)pow(_2[n],md-2))%md<<'\n';
	}
	return 0;
}
```


---

## 作者：Tommy_clas (赞：5)

[传送门](https://www.luogu.org/problem/P5615)

题目大意：给你$n$根木棍，第$i$根木棍的长度为$i$，每次从中随机取一些木棍（每根木棍取到的概率为$50$%），设取到的木棍数量为$m$，如果取到的木棍能组成一个凸多边形，你就能得到大小为$m$的分数，否则将得不到分数。求每次能得到的期望分数。

根据：期望$=$结果$\times$概率

对于每一种确定的取木棍的方案，它发生的概率一定是$\frac{1}{2^n}$。

所以我们只需要求出所有方案能得到的分数之和，然后再乘上概率即可。

接下来就是如何去求所有方案能得到的分数。

这里先给出如下的$DP$数组
~~~cpp
tot[i]：在前i根木棍中选取木棍的所有方案的假定权值之和（不论是否合法）
f[i]：取到的木棍长度和为i的方案的权值的和
g[i]：取到的木棍长度和为i的方案的数量
ansf[i]：在前i根木棍中选取木棍的所有方案的权值之和
~~~
首先是为何要求$f$与$g$：

让我们先考虑一下三角形的三边关系：两边之和大于第三边。其实本质就是最长边的长度一定要小于其他边的长度之和（否则将不能形成封闭图形）。

那么我们把边的关系拓展到多边形上：最长边长小于其它边长之和。

至于凸多边形的条件，你可以发现任何非凸多边形最后都能变成凸多边形，所以不予考虑。

那么我们每次选完木棍以后判断它是否能组成多边形只需要判断最长边长是否小于其它边长之和即可。

然后怎么做呢？

这时候就可以用上$f$数组和$g$数组，首先枚举最长边$i$，那么使用第$i$条边作为最长边的方案的权值和就可以表示为$\sum_{j>i}f[j]$，然而这个实现起来并不容易，因为$j$的上界是$n^2$级的，转移的复杂度太高。

不过这启发了我们使用容斥思想：因为$i$的范围很小（只到$5000$），所以我们先求出所有取木棍的方案的假定权值之和，然后再减去不合法的即可，即：$tot[i]-\sum_{0≤j≤i}(f[j]+g[j])$。

等等，为何$f[j]$要再加上$g[j]$？因为我们计算的$f$是在**已经确定边数**的前提下求出的权值之和，但是我们“确定好的边数”并没有算上最长边$i$。幸亏每个方案的权值是使用的木棍的个数，因此我们计算边$i$的贡献只需要再加上方案数即可（这里需要感性理解一下）。

$f$与$g$如何求出来呢？接着往下看。

在这之前先介绍一下$ansf$。

显然$ansf[n]$是所有方案能得到的分数，考虑如何转移。

对于前$i$条边，所需要讨论的无疑是“$i$是否是最长边”，如果不是，直接从$ansf[i-1]$中转移而来，如果是，则按照上述容斥的方法解决。

即：$ansf[i]=ansf[i-1]+tot[i-1]-\sum_{0≤j≤i}(f[j]+g[j])$

每次更新完$ansf[i]$之后，我们还要更新$tot[i]$、$f$和$g$。

因为我们考虑的是前$i-1$根木棍的方案（第$i$根木棍已经假定为最长木棍），所以应当先更新$ansf$再更新$tot$、$f$与$g$。

$tot$的更新过程和$ansf$相似，考虑是否选择第$i$根木棍，不选的贡献为$tot[i-1]$，选了的贡献为$tot[i-1]+2^{i-1}$（$2^{i-1}$即为方案数）

即：$tot[i]=tot[i-1]\times 2+2^{i-1}$

$f$与$g$的更新类似于背包，只需要考虑边$i$对数组做出的贡献即可，转移式如下：

~~~cpp
g[j]+=g[j-i]
f[j]+=f[j-i]+g[j-i]
~~~
不要忘了倒序枚举，因为新状态$f[j]$利用的$f[j-i]$是之前的旧状态。

最后的答案$answer=\frac{ansf[n]}{2^n}$。

时间复杂度：$O(n^2)$

上代码：
```cpp
#include<cstdio>
#define N 5005
#define ll long long
using namespace std;
int n,T;
ll f[N],g[N],invp[N],inv2,ansf[N];
const ll mod=1000000007;
int quick_pow(int base,int x)
{
	int res=1;
	while(x)
	{
		if(x&1)res=1ll*res*base%mod;
		base=1ll*base*base%mod,x>>=1;
	}
	return res;
}
void init()
{
	invp[0]=1,g[0]=1;
	inv2=quick_pow(2,mod-2);
	ll p=1,tot=0;
	for(int i=1;i<=5000;i++)
	{
		ansf[i]=(ansf[i-1]+tot+p)%mod;
		tot=(tot*2+p)%mod;
		p=p*2%mod;
		for(int j=0;j<=i;j++)
			ansf[i]=((ansf[i]-f[j]+mod)%mod-g[j]+mod)%mod;
		for(int j=5000;j>=i;j--)
		{
			g[j]=(g[j]+g[j-i])%mod;
			f[j]=(f[j]+f[j-i]+g[j-i])%mod;
		}
		invp[i]=1ll*invp[i-1]*inv2%mod;
	}
}
int main()
{
	init();
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		printf("%lld\n",1ll*ansf[n]*invp[n]%mod);
	}
	return 0;
}
```


---

## 作者：Rui_R (赞：4)

来晚了，但是石头门天下第一。

[原题](https://www.luogu.com.cn/problem/P5615)

首先那个凸多边形就是诈骗。我们可以发现，对于一个凹多边形，只要把它所有凹进去的的地方翻出来它就是个凸多边形了。也就是说，只要选出来的边可以拼成一个多边形，它就是合法的。

能够拼成一个多边形的边满足什么条件呢？如果最长边小于其余边长度的和，它就是合法的。（否则拼不起来）

那么，考虑枚举最长边：设 $g(i)$ 表示最长边小于等于 $i$ 时的总贡献。最长边小于 $i$ 的部分写在 $g(i-1)$ 里，那么只要算最长边为 $i$ 的部分就好了。

接下来，设 $h(i,j)$ 表示选出 $j$ 条互不相等且小于 $i$  的边，使其和大于 $i$ 的方案数。那么，可以得到
$$
g(i)=g(i-1)+\sum_{j=2}(j+1)h(i,j)
$$
考虑从 $h(i,j)$ 转移到 $h(i+1,j)$ ：

如果不使用 $i$ ，那么就是 $h(i,j)$ 减去恰好为 $i+1$ 的部分。令 $f(i,j)$ 表示选出 $j$ 条不同的边，它们的和为 $i$ 的方案数。那么这部分就是  $h(i,j)-f(i+1,j)$

如果使用 $i$ ，就是在剩下小于 $i$ 的边中选出 $j-1$ 条，使它们的和大于1，也就是闭着眼睛乱选，即组合数。

这里有个很有趣的细节，会写在代码里。

整理一下，就是
$$
h(i+1,j)=h(i,j)-f(i+1,j)+\binom{i-1}{j-1}
$$
这里 $h$ 可以滚动数组优化空间。

那么现在只剩下最后一个问题：求 $f$ 。

将 $f(i,j)$ 的方案分为两种：包括 $1$ 和不包括 $1$ 的。

其中，对于不包括 $1$ 的，我们可以将它们所有人一起减掉 $1$ ，此时方案数就是 $f(i-j,j)$

（可以理解为对于 $f(i-j,j)$ 中的每种方案，往里面每个数都加 $1$）

而对于包括 $1$ 的，我们先把 $1$ 拿出来，再把其它人都减掉 $1$ ，此时方案数就是 $f((i-1)-(j-1),j-1)=f(i-j,j-1)$ 

也就是，$f(i,j)=f(i-j,j)+f(i-j,j-1)$ 。

胜利的时刻已经到来。

（其余有一些优化可以参考代码，好歹是最优解，应该会有一些参考价值）

```cpp
#include <cstdio>
#include <cstring>

const int maxn = 5e3+5,mod = 1e9 + 7;

template<typename T>
inline T max(const T &a,const T &b){
	return a>b?a:b;
}

int fastpow(int x,int y){
	if(y==0) return 1;
	int tmp=fastpow(x,y>>1);
	return y&1?1ll*tmp*tmp%mod*x%mod:1ll*tmp*tmp%mod;
}

int n=0,f[maxn][maxn],g[maxn],h[2][maxn];
int frac[maxn],inv_frac[maxn];
int Okabe[maxn],Rintaro[maxn];

inline int binom(int x,int y){
	if(x<0||x>y) return 0;
	return 1ll*frac[y]*inv_frac[x]%mod*inv_frac[y-x]%mod;
}

inline int El_Psy_Congroo(int x){
	return (x+1)*x/2;//1+2+3..x
}

int main(){
	int cas;scanf("%d",&cas);
	for(int i=1;i<=cas;i++) scanf("%d",&Okabe[i]),n=max(n,Okabe[i]);
	Rintaro[0]=1,Rintaro[1]=fastpow(2,mod-2);
	for(int i=2;i<=n;i++) Rintaro[i]=1ll*Rintaro[i-1]*Rintaro[1]%mod;
	frac[0]=1;for(int i=1;i<=n;i++) frac[i]=1ll*frac[i-1]*i%mod;
	inv_frac[n]=fastpow(frac[n],mod-2);
	for(int i=n-1;i>=0;i--) inv_frac[i]=1ll*inv_frac[i+1]*(i+1)%mod;
	f[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;El_Psy_Congroo(j)<=i;j++){//(1+2+..j)如果大于i，那就不可能了
			f[i][j] = f[i-j][j] + f[i-j][j-1];
			f[i][j] %= mod;
		}
	}
	for(int i=1;i<=n;i++){
		g[i] = g[i-1];int now = i&1;
		for(int j=2;j<i;j++){
			g[i] += 1ll*(j+1)*h[now][j]%mod;
			g[i] %= mod;
		}
		for(int j=2;j<=i;j++){
			h[!now][j] = h[now][j] - f[i+1][j];//这里在 j=2 的时候会多减1（i+1=1+i，而这是不应减去的）
			h[!now][j] += binom(j-1,i-1);h[!now][j]%=mod;//这里在 j=2 的时候会多加1（不应选择1）
		}
	}
	for(int i=1;i<=cas;i++){
		n = Okabe[i];
		printf("%lld\n",(1ll*g[n]*Rintaro[n]%mod+mod)%mod);
	}
	return 0;
}

```


$$
\texttt{El Psy Congroo}
$$





---

## 作者：Rhodoks (赞：4)

选边的总方案数为$2^n$，所以只需要求所有合法方案的边数之和。因为周长最大能到$\frac{n*(n+1)}{2}$，不妨考虑不合法的情况。

选出来的边**不能**组成一个凸多边形的充要条件是：所有非最长的边长度之和小于等于最长边的长度。

不妨钦定最长边为$x$,那么问题就转化成，只允许取长度$1$到$x-1$的边，选出的边小于等于$x$的方案的边数之和。

最长边为$k$时，令$cnt_k[i]$为选出边长和为$i$的方案数，$dp_k[i]$为选出边长和为$i$时所有方案边数和。

那么：

$$dp_{k+1}[j]=dp_{k}[j]+dp_k[j-k]+num_k[j-k]$$ 

$$num_{k+1}[j]=num_k[j]+num_k[j-k]$$

边界条件是

$$num_0[0]=1$$

$cnt[k]=\sum_{i=0}^{k}(dp_k[i]+num_k[i])$是$k$为最长边时，所有不合法选边方案的边数总和。

那么答案就是$ans[k]=\frac{n}{2}-\frac{\sum_{i=0}^{k}cnt[i]}{2^k}$

AC代码：
```cpp
#include <bits/stdc++.h>
#define INL inline
#define REG register
#define DB double
#define LDB long double
#define ULL unsigned long long
#define LL long long

#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)
#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)
#define MST(a,b) memset((a),(b),sizeof(a))
#define MRK() cout<<"Mark"<<endl;
#define WRT(x) cout<<#x<<" = "<<(x)<<endl;

#define MAXN 5020
#define MAXM 10000
#define MOD 1000000007
#define INF 0x3f3f3f3f
#define LLINF 0x3f3f3f3f3f3f3f3f
#define EPS 1e-5

#define _ 0
using namespace std;

LL cnt[MAXN],ans[MAXN],num[MAXN],dp[MAXN],sum[MAXN];
int n;

LL mpow(LL x,LL n)
{
	LL ans=1;
	while (n)
	{
		if (n&1)
			ans=ans*x%MOD;
		x=x*x%MOD;
		n>>=1;
	}
	return ans;
}

LL inv(LL x)
{
	return mpow(x,MOD-2);
}

int main()
{
	const LL inv2=inv(2);
	n=5010;
	num[0]=1;
	for (int i=1;i<=n;i++)
	{
		for (int j=0;j<=i;j++)
			cnt[i]+=dp[j]+num[j];
		cnt[i]%=MOD;
		for (int j=n;j>=i;j--)
		{
			dp[j]=(dp[j]+dp[j-i]+num[j-i])%MOD; 
			num[j]=(num[j]+num[j-i])%MOD;
		}
	}
	LL tmp=1;
	for (int i=1;i<=n;i++)
	{
		tmp=tmp*inv2%MOD;
		sum[i]=(sum[i-1]+cnt[i])%MOD;
		ans[i]=((i*inv2-sum[i]*tmp)%MOD+MOD)%MOD;
	}
	int t,x;
	cin>>t;
	while (t--)
	{
		scanf("%d",&x);
		printf("%lld\n",ans[x]);
	}
	return ~~(0^_^0);
}

```


---

## 作者：飞雨烟雁 (赞：3)

原题链接：[P5615 [MtOI2019] 时间跳跃](https://www.luogu.com.cn/problem/P5615)。

本题解提供两种 $\Theta(n\sqrt n)$ 计算的方法。

------------

**下设集合** $T_n=\{k\in \mathbb Z\mid 1\le k\le n\}$。

首先，**若干条边能否组成多边形等价于最长边小于其他边长之和**。那么答案就可以被表示为：

$$
2^{-n}\sum_{S\subseteq T_n}|S|[2\max (S)<\text{sum}(S)]
$$

这引导我们去枚举最长边的长度，定义 $f_n$ 为最长边为 $n$ 时的集合大小之和：

$$
f_n=\sum_{A\subseteq T_{n-1}}(1+|A|)[\text{sum}(A)>n]
$$

那答案就是 $2^{-n}(f_4+f_5+\cdots +f_n)$。

利用容斥的思想，我们可将 $f_n$ 表示为：

$$
\begin{aligned}f_n&=\sum_{A\subseteq T_{n-1}}(1+|A|)-\sum_{A\subseteq T_{n-1}}(1+|A|)[\text{sum}(A)\le n]\\&=(n+1)2^{n-2}-\sum_{A\subseteq T_{n-1}}(1+|A|)[\text{sum}(A)\le n]\\\end{aligned}
$$

这里很明显地出现了和互异分拆数相关的表达式，我们先设 $g_n$ 为：

$$
g_n=\sum_{A\subseteq T_n}(1+|A|)[\text{sum}(A)= n]
$$

那么就有：

$$
f_n=(n+1)2^{n-2}-(g_0+g_1+\cdots+g_n-2)
$$

这里的 $-2$ 是因为 $g_n$ 含有 $A=\{n\}$ 这一项，但这在 $f_n$ 中是不合法的，需要减掉。

习见的互异分拆数可用 $\prod(1+x^n)$ 来表示。此处需对集合大小求和，我们稍做修改，用 $y$ 来计数集合大小得：

$$
\sum_{n=0}^\infty g_nx^n=\dfrac{\partial}{\partial y}\left(y\prod_{n=1}^\infty(1+yx^n)\right)\Bigg|_ {y=1}
$$

假设我们能求出 $\{g_i\}_ {0\le i\le n}$，就能在 $\Theta(n)$ 时间内求出答案。下面，我将介绍两种 $\Theta(n\sqrt n)$ 的计算方法。

------------

**法一：欧拉五边形数定理**

从上面的式子出发，直接计算有：

$$
\sum_{n=0}^\infty g_nx^n=\left(1+\sum_{n=1}^\infty\dfrac{x^n}{1+x^n}\right)\prod_{n=1}^\infty(1+x^n)
$$

$\sum$ 那堆东西可以 $\Theta(n\log n)$ 求出，关键在于如何处理这个连乘。

这里需要用到欧拉的五边形数定理：

$$
\prod_{n=1}^\infty (1-x^n)=\sum_{n\in \mathbb Z}(-1)^nx^{(3n^2+n)/2}
$$

它的证明有很多，[数学杂记【26 - 50】](https://www.luogu.com.cn/paste/dw7dlyke)中的 39, 40 条提供了一个基于 Jacobi 三重积的证明。

利用该定理有：


$$
\prod_{n=1}^\infty(1+x^n)=\dfrac{\prod_{n=1}^\infty(1-x^{2n})}{\prod_{n=1}^\infty(1-x^n)}=\dfrac{\sum_{n\in \mathbb Z}(-1)^nx^{3n^2+n}}{\sum_{n\in \mathbb Z}(-1)^nx^{(3n^2+n)/2}}
$$

分子和分母低于 $n$ 次项的项数都是 $\Theta(\sqrt n)$ 的。而乘、除一个 $\Theta(\sqrt n)$ 项的多项式的时间复杂度均为 $\Theta(n\sqrt n)$。

综上，我们只需先 $\Theta(n\log n)$ 求得那个 $\sum$。再依次乘除 $\Theta(\sqrt n)$ 项的多项式就行了。总时间复杂度为 $\Theta(n\sqrt n)$。

注：法一可用 FFT/NTT 优化到 $\Theta(n\log n)$ 的时间复杂度。

------------

**法二：不知道叫啥的等式**

我们先证明下式：

$$
\prod_{n=1}^\infty(1+yx^n)=\sum_{n=0}^\infty\dfrac{x^{n(n+1)/2}y^n}{(1-x)(1-x^2)\cdots(1-x^n)}
$$

暂记左式为 $F(x,y)$，易证下式成立：

$$
F(x,y)=(1+xy)F(x,xy)
$$

设 $F(x,y)=\sum\limits_{n=0}^\infty G_n(x)y^n$，于是有：

$$
\sum\limits_{n=0}^\infty G_n(x)y^n=(1+xy)\sum\limits_{n=0}^\infty G_n(x)x^ny^n
$$

两边同时提取 $y^n$ 系数得：

$$
G_n(x)=G_n(x)x^n+G_{n-1}(x)x^n
$$

因为 $G_0(x)=F(x,0)=1$，累乘得：

$$
G_n(x)=\dfrac{x^n}{1-x^n}G_{n-1}(x)=\dfrac{x^{n(n+1)/2}}{(1-x)(1-x^2)\cdots(1-x^n)}
$$

代入即证。

于是利用这条公式有：


$$
\begin{aligned}\sum_{n=0}^\infty g_nx^n&=\dfrac{\partial}{\partial y}\left(y\sum_{n=0}^\infty\dfrac{x^{n(n+1)/2}y^n}{(1-x)(1-x^2)\cdots(1-x^n)}\right)\Bigg|_ {y=1}\\&=\sum_{n=0}^\infty\dfrac{(n+1)x^{n(n+1)/2}}{(1-x)(1-x^2)\cdots(1-x^n)}\end{aligned}
$$

这条式子可以在 $\Theta(n\sqrt n)$ 时间内完成计算，具体参考下面的代码。

------------

**注记：**

这两种方法均可以做到 $\Theta(n\sqrt n)$。个人比较推荐第二种写法，代码更短，常数更小，2s 内能跑 $10^6$ 的数据。那这道题完全可以拿来加强啊！

虽然有多项式科技可以做到 $\Theta(n\log n)$。但如果模数不是质数，且不借助法一 or 法二，就只能分治 $\Theta(n\log ^2n)$ 了。

------------


以下是 AC 代码，两种求法对应了两个 `GetPoly` 函数。我没有精细实现法一，因此其代码严格地讲应当是 $\Theta(n^2)$ 的。

```cpp
#include <cstdio>
#define ll long long

const int Mod = 1e9 + 7, Mx = 5002, Inv2 = 5e8 + 4;

int F[Mx], G[Mx], H[Mx];
void GetPoly_Euler(int n){
	F[0] = 1;
	for(int d = 1; d <= n; ++d) for(int k = 1; k <= n / d; ++k) F[k * d] += k & 1 ? 1 : -1;
	for(int d = 0; 3 * d * d + d <= n * 2; ++d) H[(3 * d * d + d) / 2] = d & 1 ? 1 : -1;
	for(int d = 1; 3 * d * d - d <= n * 2; ++d) H[(3 * d * d - d) / 2] = d & 1 ? 1 : -1;
	for(int i = 0; i <= n; i += 2) if(H[i / 2]){
		for(int j = i; j <= n; ++j) G[j] -= F[j - i] * H[i / 2];
	}
	for(int i = 0; i <= n; ++i){
		F[i] = G[i];
		for(int j = 1; j <= i; ++j) if(H[j]) F[i] = (F[i] + 1ll * H[j] * F[i - j]) % Mod;
	}
}

int X[Mx], Y[Mx];
void GetPoly_Vladeta(int n){
	X[0] = Y[0] = 1;
	for(int d = 1; d * (d + 1) / 2 <= n; ++d){
		int k = d * (d + 1) / 2;
		for(int i = d; i <= n - k; ++i) Y[i] = (Y[i] + Y[i - d]) % Mod;
		for(int i = k; i <= n; ++i) X[i] = (X[i] + (d + 1ll) * Y[i - k]) % Mod;
	}
}

int Pow2[Mx], g[Mx];
void Init(int n){
	Pow2[0] = 1;
	for(int i = 1; i <= n; ++i) Pow2[i] = (Pow2[i - 1] << 1) % Mod;
	g[0] = X[0] + X[1] - 2;
	for(int i = 1; i <= n; ++i) g[i] = (g[i - 1] + X[i + 1]) % Mod;
	for(int i = 0; i <= n; ++i) g[i] = ((i + 2ll) * Pow2[i - 1] - g[i]) % Mod;
	for(int i = 4; i <= n; ++i) g[i] = (g[i] + g[i - 1]) % Mod;
	ll prd = 1ll * Inv2 * Inv2 % Mod * Inv2 % Mod;
	for(int i = 3; i <= n; ++i){
		prd = prd * Inv2 % Mod;
		g[i] = g[i] * prd % Mod;
	}
	g[0] = 0;
}

int main(){
	int T;
	scanf("%d", &T);
	GetPoly_Euler(5001);
	GetPoly_Vladeta(5001);
	Init(5000);
	while(T--){
		int n;
		scanf("%d", &n);
		printf("%d\n", g[n - 1] < 0 ? g[n - 1] + Mod : g[n - 1]);
	}
	return 0;
} 
```

---

## 作者：冰霜_凯撒 (赞：3)

  首先，我们注意到一共有$2^n$种情况，而且每一种情况的数量是相同的，再看一眼数据范围$1≤n≤T≤5000$，于是想到了O($n^2$)的dp。
  
  我们不难发现，当我们确定一条最长边时，我们便可以设一个dp数组，其中$dp[x][y]$代表在$1$~$x$的长度中选取长度之和小于等于$y$的方案个数，于是推出递推式$:$
  >$dp[x][y]=dp[x-1][y]+(dp[x-1][y-x]+1)(y>=x)$
  
 （$dp[x-1][y]$表示不选$x$时的方案个数，$dp[x-1][y-x]$表示选$x$时的后面的方案个数，最后的$+1$表示只选x时的方案个数），并使所有的$dp[0][i]=1$,即可推出方案数。
  
  **但是**，仅仅推出方案数并不足以使我们得出答案，我们还需要知道一个$sum[x][y]$表示在$1$~$x$中选取长度之和小于等于$y$的答案值，再在之前推出的$dp[x][y]$上类比得$:$
  >$sum[x][y]=sum[x-1][y]+(sum[x-1][y-x]+dp[x-1][y-x]+1)(y>=x）$
  
  （要加$dp[x-1][y-x]$是因为要加上选取$x$所增加的贡献值），然后得到
  >$ans=\sum_{n}^{i=1}$（$dp[i-1][i]+sum[i-1][i]+1$）
  
  （每一个$i$代表最长边的长度为i的答案值）
  
  最后再加$1$表示什么都没有选时的情况。
  
  **以上是不符合的答案值。**
  
  然后我们枚举$2$的所有情况：
  
  >{$\varnothing$}、{$1$}、{$2$}、{$1，2$}
  
  我们发现可以合并{$\varnothing$}、{$1，2$}和{$1$}、{$2$}。所以答案总值就是
  >$\frac{n*2^n}{2}=n*2^{(n-1)}$
  
  再将答案总值$tot-ans$就是我们要求的分母。(分子是$2^n$求逆元就不讲了吧)。
  
  最后，我们在预处理完所有的$ans[i]$后，我们愉快地提交，然后快乐地得到了80分（因为空间爆了），所以我们要改成滚动数组才能通过。
  
##   **话不多说了，具体细节请看代码：**
  
  ```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define ll long long
using namespace std;
int n,T;
const ll mod=1e9+7;
const ll ni2=500000004;   //预处理2的逆元的值 
ll dp[2][5005],sum[2][5005]; //dp,sum都要滚动,不然会爆空间 
ll ans[5005],tot[5005];
ll ny[5005],lg[5005];  //lg[i]代表2^i,ny[i]存储2^i的逆元 
int a[5005],ma;
ll totl,suml;
int gun;
int main()
{
	scanf("%d",&T);
	register int i,j;
	for(i=1;i<=T;++i){
		scanf("%d",&n);
		a[i]=n;
		ma=max(ma,n);
	}
	n=ma;
	ny[0]=1;lg[0]=1;
	for(i=1;i<=n;++i) ny[i]=(ny[i-1]*ni2)%mod,lg[i]=(lg[i-1]*2)%mod;
	for(i=1;i<=n;++i) tot[i]=(i*lg[i-1])%mod;
	for(i=1;i<=n;++i) dp[0][i]=1,sum[0][i]=1;  //预处理dp[0][i],sum[0][i]的值 
	for(i=2;i<=n;++i){
		gun=gun^1;
		for(j=1;j<=n;++j){
			dp[gun][j]=dp[gun^1][j];
			sum[gun][j]=sum[gun^1][j];
			if(j>=i){
				dp[gun][j]=(dp[gun][j]+dp[gun^1][j-i]+1)%mod;
				sum[gun][j]=(sum[gun][j]+dp[gun^1][j-i]+sum[gun^1][j-i]+1)%mod;
			}
		}
		ans[i]=(ans[i-1]+sum[gun^1][i]+dp[gun^1][i]+1)%mod;
	}
	for(i=1;i<=T;++i){
		n=a[i];
		totl=ny[n];
		suml=((tot[n]-ans[n]-1)%mod+mod)%mod;   //-1代表空集的时候贡献的答案 
		totl=(totl*suml)%mod;
		printf("%lld\n",totl);
	}
	return 0;
}
```


---

## 作者：hepan (赞：2)

### 题目大意
 
等概率随机 $\{1,2,\cdots ,n\}$ 的子集，求集合的大小乘是否构成凸多边形。

多次询问，对 $10^9+7$ 去膜。

$n,T\le5000$

### 题解

本题求期望等价于求方案数，然后除以 $2^n$ 。

设选中的数从小到大分别为 $a_1,a_2,\cdots,a_k$ ，能构成凸多边形等价于 $\sum_{i=1}^{k-1}a_i>a_k$ 。

考虑 dp 。

设 $dp_{i,j}$ 表示考虑到前 $i$ 个数，和为 $j$ 的方案数，$f_{i,j}$，表示考虑到前 $i$ 个数，和为 $j$ 的权值之和。

考虑是否选取，容易写出 dp 方程。

$$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-i}$$

$$f_{i,j}=f_{i-1,j}+f_{i-1,j-i}+dp_{i-1,j-i}$$

因为 $i$ 可取到 $n$，$j$ 可以取到 $\frac{n(n+1)}2$。

所以总复杂度 $\Theta(n^3)$ 。

考虑将计算所有方案，再减去不合法方案。

$$ans=\left (\sum_{i=1}^n \binom{n}{i}\times i\right)- \left(\sum_{i=0}^{n-1}\sum_{j=0}^{i+1}(dp_{i.j}+f_{i,j})\right)$$

转移时滚动数组+预处理 f 与 dp 的前缀和可以做到时间复杂度 $\Theta(n^2+nT)$ ，空间复杂度 $\Theta(n)$ 。

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<=n;i++)
#define per(i,a,n) for (int i=a;i>=n;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
mt19937 mrand(random_device{}()); 
const int mod=1000000007;
const ll mod2=1ll*mod*mod;
const int maxn=5000+10;
int rnd(int x){return mrand()%x;}
int quick(int a,int b){int res=1;a%=mod;assert(b>=0); for(;b;b>>=1){if(b&1)res=1ll*res*a%mod;a=1ll*a*a%mod;}return res;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int ans,ans2,dp[2][maxn],f[2][maxn],fac[maxn],faci[maxn],aaa[maxn];
int t,n,now;
int C(int a,int b){
	if(a<b) return 0;
	return 1ll*fac[a]*faci[b]%mod*1ll*faci[a-b]%mod;
}
int main(){
	dp[0][0]=1;
	n=5000;
	fac[0]=1;
	rep(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;
	faci[n]=quick(fac[n],mod-2);
	per(i,n-1,0) faci[i]=1ll*faci[i+1]*(i+1)%mod;
	aaa[0]=1;
	rep(i,1,n){
		now^=1;
		per(j,n,0){
			dp[now][j]=dp[now^1][j];
			f[now][j]=f[now^1][j];
			if(j-i>=0) (dp[now][j]+=dp[now^1][j-i])%=mod,(f[now][j]+=(f[now^1][j-i]+dp[now^1][j-i])%mod)%=mod;
		}
		rep(j,0,i+1) aaa[i]=(aaa[i]+(dp[now][j]+f[now][j])%mod)%mod;
	}
	cin>>t;
	rep(_,1,t){
		scanf("%d",&n);
		ans=0,ans2=0;
		rep(i,1,n) ans=(ans+1ll*C(n,i)*i%mod)%mod;
		rep(i,1,n) ans2=(ans2+aaa[i-1])%mod;
		ans-=ans2;
		if(ans<0) ans+=mod;
		ans=1ll*ans*quick(500000004,n)%mod;
		printf("%d\n",ans);
	}
}
```

---

## 作者：ping_fan (赞：2)

题目：[洛谷P5615 [MtOI2019]时间跳跃](https://www.luogu.org/problem/P5615)

来个非 $dp$ 做法？ 

首先，我们要知道，凸 $n$ 边形成立的条件是： $n≥3$且最大的边要小于其它所有边之和。

~~然后就没有思路了~~

不过我们可以打表，算出前面前面几项的权值和：
>
>  | n | | ans |
>| :----------: | :----------: | :----------: |
>| 4 | | 7 |
>| 5 | | 34 |
>| 6 | | 113 |
>| 7 | | 321 |
>| 8 | | 830 |
>| 9 | | 2017 |
>| 10 | | 4705 |

~~并没有什么规律~~

接着，算出每一项中的边为 $k$ 个时的权值和：

>| $n$↓$k$: | | 3 | | 4 | | 5 | | 6 | | 7 | | 8 | | 9 | | 10 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 4 | | 3 | | 4 | |  | |  | |  | |  | |  | |  |
>| 5 | | 9 | | 20 | | 5 | |  | |  | |  | |  | |  |
>| 6 | | 21 | | 56 | | 30 | | 6 | |  | |  | |  | |  |
>| 7 | | 39 | | 128 | | 105 | | 42 | | 7 | |  | |  | |  |
>| 8 | | 66 | | 252 | | 280 | | 168 | | 56 | | 8 | |  | |  |
>| 9 | | 102 | | 448 | | 630 | | 504 | | 252 | | 72 | | 9 |
>| 10 | | 150 | | 740 | | 1255 | | 1260 | | 840 | | 360 | | 90 | | 10 |

~~似乎有丶东西~~

然后，再算出每一项中的边为 $k$ 个时的个数（记为数组 $ans$ ）：

>| $n$↓$k$: | | 3 | | 4 | | 5 | | 6 | | 7 | | 8 | | 9 | | 10 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 4 | | 1 | | 1 | |  | |  | |  | |  | |  | |  |
>| 5 | | 3 | | 5 | | 1 | |  | |  | |  | |  | |  |
>| 6 | | 7 | | 14 | | 6 | | 1 | |  | |  | |  | |  |
>| 7 | | 13 | | 32 | | 21 | | 7 | | 1 | |  | |  | |  |
>| 8 | | 22 | | 63 | | 56 | | 28 | | 8 | | 1 | |  | |  |
>| 9 | | 34 | | 112 | | 126 | | 84 | | 36 | | 9 | | 1 | |  |
>| 10 | | 50 | | 185 | | 251 | | 210 | | 120 | | 45 | | 10 | | 1 |

好像跟杨辉三角有点像？

于是打出杨辉三角（记为数组 $tri$ ）并减去上面的表（ 一 一 对应）可以得到数组 $a$ （空则为 $0$ ）：

>| $i$↓$j$: | | 0 | | 1 | | 2 | | 3 | | 4 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 1 | | 1 | | 1 | |  | |  | |  |
>| 2 | | 1 | | 2 | | 1 | |  | |  |
>| 3 | | 1 | | 3 | | 3 | | 1 | |  |
>| 4 | | 1 | | 4 | | 6 | | 3 | |  |
>| 5 | | 1 | | 5 | | 10 | | 7 | |  |
>| 6 | | 1 | | 6 | | 15 | | 13 | | 1 |
>| 7 | | 1 | | 7 | | 21 | | 22 | | 3 |
>| 8 | | 1 | | 8 | | 28 | | 34 | | 7 |
>| 9 | | 1 | | 9 | | 36 | | 50 | | 14 |
>| 10 | | 1 | | 10 | | 45 | | 70 | | 25 |

根据上表我们可以发现以下结论：

1. 当 $0≤j≤2$ 时:

>   $a[i][j]=s[i][j]$

2. 当 $j=3$ 且 $i≥2$ 时：

>   $a[i][3]=a[i-1][2]+a[i-2][3]$

3. 当 $j≥4$ 且 $i≥j-1$ 时：

>   $a[i][j]=a[i-j+1][j]+a[i-j+1][j-1]$
    
因此，我们可以通过求出数组 $tri$ 和数组 $a$ 并相减得到数组 $ans$ 得到答案,	期望得分： $0$~$80$ 

为什么？

仔细观察内存限制，两个 $5000 * 5000$ 的数组是装不下的，至多只能开一个数组。

再看上面的结论，不难发现数组 $a$ 只与所求的一列和其上一列有关系，所以可以滚动数组 $a$ ，边求数组 $a$ 边得到数组 $ans$ ，期望得分： $100$ 

下面上代码（时间复杂度：$O(n^2)$,空间复杂度:$O(n^2)$）:

```cpp
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<cstdio>
#define N 5005
#define mod 1000000007
#define rd register int
#define ll long long
using namespace std;
int t,n,tri[N][N],a[N][2];
ll ans;

//快速幂 
inline ll ksm(ll aa,ll bb,ll p){
	ll an=1,a=aa,b=bb;
	for(;b;b>>=1,a=(a*a)%p)
		if(b&1)
			an=(an*a)%p;
	return an;
}

signed main(){
	scanf("%d",&t);
	
	//求杨辉三角
	for(rd i=1;i<N;++i)
		tri[i][0]=tri[i][i]=1;
	for(rd i=2;i<N;++i)
		for(rd j=1;j<i;++j)
			tri[i][j]=((ll)tri[i-1][j]+tri[i-1][j-1])%mod;
	
	//结论2
	for(rd i=2;i<N;++i)
		a[i][1]=((ll)tri[i-1][2]+a[i-2][1])%mod;
		
	//结论3 
	for(rd i=4,j;i<N;++i){
		for(j=i-1;j<N;++j)
			a[j][i&1]=((ll)a[j-i+1][i&1]+a[j-i+1][!(i&1)])%mod;
			
		//滚动 
		for(j=0;j<N;++j)
			tri[j][i-1]=(((ll)tri[j][i-1]-a[j][!(i&1)])%mod+mod)%mod,a[j][!(i&1)]=0;
	}
	for(rd i=1;i<N;++i)//最后一列的滚动 
		tri[i][N-1]=((tri[i][N-1]-a[i][!(N&1)])%mod+mod)%mod;
	
	//结论1 
	for(rd i=1;i<N;++i)
		tri[i][0]=tri[i][1]=tri[i][2]=0;
	
	//计算答案 
	for(rd i=1,j;i<=t;++i){
		ans=0;
		scanf("%d",&n);
		for(j=3;j<=n;++j)
			ans=(ans+((ll)tri[n][j]*j)%mod)%mod;
		printf("%lld\n",((ll)ans*ksm(ksm(2,n,mod),mod-2,mod))%mod);
	}
	return 0;
}
```


---

## 作者：gyh20 (赞：2)

首先考虑什么样的情况可以构成凸多边形。

不难想到，只要除最大边的所有边之和大于最大边即可。(证法与三角形两边之和小于第三边相似)

所以，原题转化为在1~n之中，选出一条基准边i再在1~i-1中选出一些边使它们的权值和大于i。求这样的边的条数和。

再看到n<=5000,T<=5000的数据，可知本题一定是离线。

设两个状态：

#### f[i][j]:在1~i中选出一些边使它们的长度和大于j的方案数

#### g[i][j]:在1~i中选出一些边使它们的长度和大于j的权值和

状态转移方程:
#### f[i][j]=f[i-1][j]从1~i-1中选取大于j的方案数+f[i-1][max(j-i,0)]选i之后再选大于j-i的方案数+(i>j)能不能单独只选i

#### g[i][j]=g[i-1][j]同上+g[i-1][max(j-i,0)]同上+f[i-1][max(j-i,0)]之前的每个方案会多一个数(i)+(i>j)同上

初始值比较简单，就看代码吧

最终求的即为 f[i][i+1]+g[i][i+1]的和

时间复杂度O(n^2)
但是5000*5000的数组太大了，过不了

因为最后求的是f[i][i+1]和g[i][i+1]，每次转移也只和i-1有关，可以想到滚动数组，将空间压到O(n),再用q[i]和q1[i]来保存f[i][i+1]和g[i][i+1]

代码如下：
```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline long long read(){
	re long long t=0;
	re char v=getchar();
	while(v<'0'||v>'9')v=getchar();
	while(v>='0'&&v<='9'){
		t=(t<<3)+(t<<1)+(v^48);
		v=getchar();
	}
	return t;
}
const long long M=1e9+7;
long long n,m,ans,pos,t;
long long f[5005],g[5005],q[5005],q1[5005];
inline long long ksm(re long long p,re long long b){
	if(b==0)return 1;
	if(b==1)return p;
	long long tmp=ksm(p,b>>1);
	if(b&1)return tmp*tmp%M*p%M;
	return tmp*tmp%M;
}
int main(){

	for(re long long i=1;i<=5000;++i){
		for(re long long j=5000;j>=1;--j){
			if(j>=i)g[j]+=g[j-i]+f[j-i],f[j]+=f[j-i];
			else g[j]+=g[0]+f[0],f[j]+=f[0];
			if(i>j)f[j]++,g[j]++;
			g[j]%=M;
			f[j]%=M;

		}
		g[0]=((g[0]<<1)+f[0]+1)%M;
		f[0]=((f[0]<<1)+1)%M;

		q[i]=g[i+1];
		q1[i]=f[i+1];
	}

	t=read();
	while(t--){
    n=read();
	ans=0;
	for(re long long i=n-1;i>=1;--i){
		ans+=q[i];
		if(q[i])ans+=q1[i];
		ans%=M;
	}
	printf("%lld\n",(ans*ksm(ksm(2,n),M-2)%M));
		}
}
```
总时间复杂度O(n^2+nT)

当然，可以直接预处理出每一个n的答案将时间复杂度降至O(n^2+n+n)=O(n^2)

---

## 作者：Argon_Cube (赞：1)

如何判定能不能组成多边形其它题解说过了，就是除了最长边以外的其它边长度之和大于最长边。

那么我们枚举最长边，设它长度为 $n$。我们发现选一些小于 $n$ 的数使得和大于 $n$ 是不好做的，那么正难则反，我们选一些数使得它们的和小于等于 $n$。

这时我们就可以计数了。我们设 $g_n$ 是所有选取正整数数使得和不超过 $n$ 的方案中选出来数的个数的和，$f_i$ 是选取正整数数使得和不超过 $n$ 的方案数。

先特判 $n=1$，在确定最长边 $n$ 的情况下，我们先忽略 $n$ 带来的贡献，那么选取剩下的数造成的总贡献显然是 $(n-1)2^{n-2}$，其中不合法的贡献是 $g_n-1$（减的 $1$ 是只选一个 $n$ 的方案）。考虑 $n$ 带来的贡献，它在每个合法方案中都会带来一次贡献，显然合法方案数是 $2^{n-1}-(f_n-1)$（减的 $1$ 同样是只选一个 $n$ 的方案）。

这样最长边为 $n$ 时总贡献就是 $(n+1)2^{n-2}-g_n-f_n+2$。

怎么 $\Theta(n^2)$ 地求出 $f,g$ 其它题解说的很清楚了，但是显然 $f$ 就是互异分拆数的前缀和，$g$ 就是整数拆分中所有方案大小之和的前缀和。

换句话说，我们只需要求出 [$\mathrm A000009$](https://oeis.org/A000009) 然后做前缀和就是 $f$，[$\mathrm A015723$](https://oeis.org/A015723) 做前缀和就是 $g$。

然后它们的生成函数满足一个神奇的公式：

$$\mathrm A015723(x)=\mathrm A048272(x)\mathrm A000009(x)$$

[$\mathrm A048272$](https://oeis.org/A048272) 显然可以 $\Theta(n\log n)$ 求吧，$\mathrm A000009$ 显然可以套路的用计算分拆数的 $\exp\ln$ 方法（见 P5824 和 P4389），也可以 $\Theta(n\log n)$ 求（但是模数是 $10^9+7$ 所以你要写一个任意模数 $\ln$ 和 $\exp$）。然后卷起来就是 $\mathrm A015723$。

于是我们就以 $\Theta(n\log n)$ 的时间复杂度解决了这题。

---

## 作者：tommymio (赞：1)

前置知识：一个 $n$ 条边的多边形是凸多边形，当且仅当这个多边形的最长边 $<$ 其他边长度之和。

非常好的一道计数题，其实和 $\text{CSP-S2019 D2T1}$ 很像，~~所以队爷 $\color{black}\rm{C}\color{red}\rm{YJian}$ 禁赛三年（bushi~~

有一个非常 $\text{Naive}$ 的想法。由于概率相等，所以实际是求一个带权的总贡献。设 $f_{i,j,k}$ 为前 $i$ 条边选了 $j$ 条，权值和为 $k$ 的总贡献。我们很容易发现 $j$ 这一维只是用来加权的，可以将这一维优化掉。

正难则反。我们先将所有边的方案都算入答案中，无论它是否合法，即 

$$
\sum_{i=1}^n i\binom{n}{i}
$$

现在考虑去除不合法的方案数。可以发现，由于我们从 $1\sim i$ 转移，所以当前枚举的 $i$ 一定是前 $i$ 条边的最大边。如果我们能够求出前 $i-1$ 条边中长度之和 $\leq i$ 的贡献，就能够求出 $ans$。

设 $g_{i,j}$ 为前 $i$ 条边长度之和为 $j$ 的贡献，那么有：

$$
ans=\sum_{i=1}^n i\binom{n}{i}-\sum_{i=1}^{n}\sum_{j=0}^{i} g_{i-1,j}+f_{i-1,j}
$$

如何求出 $g_{i,j}$ 呢？有 $g_{i,j}=g_{i-1,j}+g_{i-1,j-i}+\Delta$，其中$\Delta$ 表示一个增量。观察发现从 $g_{i-1,j-i}$ 转移过来，对于它的每个方案都增了 $1$ 的贡献，也就是说加上长度为 $i$ 的边的增量为：前 $i-1$ 条边长度之和为 $j-i$ 的方案数。那么设 $f_{i,j}$ 为前 $i$ 条边长度之和为 $j$ 的方案数，有：

$$
g_{i,j}=g_{i-1,j}+g_{i-1,j-i}+f_{i-1,j-i}
$$
$$
f_{i,j}=f_{i-1,j}+f_{i-1,j-i}
$$

用前缀和优化一下求 $ans$ 的柿子，用最大边长限定一下 $j$ 的上界，将其限定在 $O(n)$ 的空间复杂度内，用滚动数组优化空间，这题就做完了。

空间复杂度 $O(n)$，时间复杂度 $O(n^2+T)$。

**Show the Code**

```cpp
#include<cstdio>
#define int ll
typedef long long ll;
const int N=5000;
const ll mod=1e9+7;
int f[5005],g[5005],ans[5005],fac[5005],inv[5005],sum[5005]; 
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline int pow(int x,int p) {int res=1;for(;p;p>>=1) {if(p&1) res=res*1ll*x%mod; x=1ll*x*x%mod;} return res;}
inline int binom(int n,int m) {return fac[n]*1ll*inv[m]%mod*1ll*inv[n-m]%mod;}
signed main() {
	int T=read(); fac[0]=inv[0]=1;
	for(register int i=1;i<=N;++i) fac[i]=fac[i-1]*1ll*i%mod;
	for(register int i=1;i<=N;++i) inv[i]=pow(fac[i],mod-2);
	f[0]=1;
	for(register int i=1;i<=N;++i) {
		sum[0]=1;
		for(register int j=1;j<=i;++j) sum[j]=(sum[j-1]+g[j]+f[j])%mod;
		for(register int j=1;j<i;++j) ans[i]=(((ans[i]-1ll*j*binom(i-1,j)%mod)%mod)%mod+mod)%mod;
		for(register int j=1;j<=i;++j) ans[i]=(ans[i]+1ll*j*binom(i,j)%mod)%mod; 
		ans[i]=((ans[i]-sum[i])%mod+mod)%mod; ans[i]=(ans[i]+ans[i-1])%mod;
		for(register int j=N;j>=i;--j) {
			f[j]=(f[j]+f[j-i])%mod;
			g[j]=(g[j]+g[j-i]+f[j-i])%mod;
		}
	}
	while(T--) {int n=read();printf("%d\n",ans[n]*pow(pow(2,n),mod-2)%mod);}
	return 0;
}
```


---

## 作者：梧桐灯 (赞：1)


## 首先，组成凸多边形的条件是最长边<其它边之和。

QAQ考场时我只想到了$n^3$方的做法，后来同学跟我说**拿总的方案数减去不可行的不就是$n^2$的了**……

我……

但是我看到数据范围只有5000，所以，我打表水过了此题！

先来说说$n^3$的做法。

设$f[i]$表示到第i个边长能组成的总集合长度。

显然$f[i] = f[i - 1] + \text{以i为最大边长的凸多边形的集合总长。}$

令$g[k]$表示到目前为止（不算第$i$条边）其它边长和为k的总集合长度，$num[k]$表示方案数，这样转移时$f[i]$要加$\sum ^{now }_{j=i+1}g\left[ j\right] +num\left[ j\right]$就可以了，因为所有集合都要再加上i这条边，对于总贡献就是加了$num[k]$次，所以是$g[j]+num[j]$。其中$now$表示$\sum ^{i-1}_{j=1}j$。

这是~~代码~~打表的程序：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 5003, MOD = 1000000007;
int Q, n;

int a[N], f[N], ans;
int g[N * N >> 1], num[N * N >> 1];

inline int ksm (int p, int x) {
	int s = 1;
	while (x) {
		if (x & 1) s = 1ll * s * p % MOD;
		p = 1ll * p * p % MOD;
		x >>= 1;
	}
	return s;
}

int main () {
	int i, now = 0; n = 5000;
	g[0] = 0;
	num[0] = 1;
	for (i = 1; i <= n; ++i) {
		f[i] = f[i - 1];
		for (register int j = i + 1; j <= now; ++j) {
			f[i] += 1ll * (g[j] + num[j]) % MOD;
			f[i] = f[i] >= MOD ? f[i] - MOD : f[i];
		}
		for (register int j = now; ~j; --j) {
			g[j + i] += g[j] + num[j];
			num[j + i] += num[j];
			num[j + i] %= MOD;
			g[j + i] %= MOD;
		}
		now += i;
	} //n^3方暴力转移
	
	scanf ("%d", &Q);
	while (Q--) {
		scanf ("%d", &n);
		printf ("%d\n", 1ll * f[n] * ksm (ksm (2, n), MOD - 2) % MOD);
	} //只要令输入为1~5000就可以把所有答案跑出来啦。
	return 0;
}
```

看上去是n^3，但因为跑不满+本地O2+只有循环，PC跑了2min就出解了，当然打表程序交上去只用了[15ms](https://www.luogu.org/record/26190268)就A掉了。


正解就是用总方案-不可行的，这个也很好写，把上面边界改一改就OK了（@[Binary_Search_Tree](https://www.luogu.org/space/show?uid=40985)）写的就是正解!（虽然没非正解快……）


---

## 作者：幻影星坚强 (赞：1)

本题主要是要求合法的序列长度之和

我们先预处理出前$n$条边的选择方案数$A_n$与序列长度总和$L_n$

由于每一条边都可以选或不选，所以总方案数为$2^n-1$（不能为0）。而$L_{n-1}$可以选的$L_n$照样能选，且$L_{n-1}$中都能加上$n$后再选，$n$也能单独选,所以$L_n=2*L_{n-1}+A_{n-1}+1$
```
for (int i = 1; i <= maxs; i++)
    {
        l[i] = i > 1 ? l[i - 1] * 2 + a[i - 1] + 1 : 1;
        a[i] = i > 1 ? a[i - 1] * 2 + 1 : 1;
        l[i] %= MOD;
        a[i] %= MOD;
        //printf("%d %d\n",a[i] , l[i]);
    }
```
如果能够成一个凸多边形，那么最大边就应该小于其余边的和。

所以之后我们要求前$n$条边无法构成凸多边形的序列长度总和

设$a_i$为边长度和为i的方案数，$l_i$为边长度和为i的序列长度总和，$n$每增加$1$就更新一次数组，代表必须选择$n$，且$n$最大。假如最大的边长为$n_0$，则$a_{i+n_0}$的方案数就会增加$a_i$，则$l_{i+n_0}$就会增加$a_i+l_i$（就是用$n_0$这条边来进行过渡）

```
for (int j = maxs; j >= 0; j--)
        {
            if (j + i <= maxs)
            {
                a[j + i] += a[j];
                l[j + i] += a[j] + l[j];
                a[j + i] %= MOD;
                l[j + i] %= MOD;
            }
        }
```
对于最大边为$n_0$时不满足要求的序列个数与序列总和就分别是$\sum\limits_{i=1}^{n_0}a_i$ 与$\sum\limits_{i=1}^{n_0}l_i$ 
```
long long cant = 0;//不满足要求的序列总和
long long cantg = 0;//不满足要求的序列个数
for (int j = 1; j <= i; j++)
{
    cant += l[j];
    cantg += a[j];
    cantg %= MOD;
    cant %= MOD;
}
```
所以最大边为$n_0$时可以选择的数量为$A_{n_0-1} - cantg$（前$n_0-1$的总方案减去边长总和小于等于$n_0$的方案）   
最大的序列长度和为$ans_{n_0}=A_{n_0-1} - cantg + L_{n_0-1} - cant$（前$n_0-1$边长总和大于$n_0$的方案的序列总长，并且每一个序列的长度都增加了$1$）

如果要求选择$0$~$n_0$中的任意几条边的话，结果就是$\sum\limits_{i=1}^{n_0}ans_i$

剩下要做的就是求出每一个$ans_i$，然后求出每一段$0$~$n_0$的$ans_i$的总和，最后除以$2^n$再取模即可

下面是我考试时的代码：

```
#include <iostream>
#include <cstdio>
using namespace std;
//R.I.P wowaka
const long long MOD = 1e9 + 7;
long long have[10010], half, len[10010], ge[10010], gib[10010], zge[10010], ans[10010];
long long ksm(long long x, long long y)
{
    long long maretu = 1;
    for (; y; y >>= 1)
    {
        if(y & 1)
        {
            maretu = maretu * x % MOD;
        }
        x = x * x % MOD;
    }
    return maretu;
}
int n, t, maxs;
int que[10010];
void print(long long o)
{
    if (o <= 0) return;
    print(o / 10);
    printf("%c",(char)((int)o % 10 + '0') );
}
int main()
{
    half = ksm(2, MOD - 2);
    scanf("%d", &t);
    for (int i = 0; i < t; i++)
    {
        scanf("%d", &que[i]);
        maxs = max(maxs, que[i]);
    }
    ge[0] = 1;
    zge[0] = 1;
    for (int i = 1; i <= maxs; i++)
    {
        gib[i] = i > 1 ? gib[i - 1] * 2 + zge[i - 1] + 1 : 1;
        zge[i] = i > 1 ? zge[i - 1] * 2 + 1 : 1;
        gib[i] %= MOD;
        zge[i] %= MOD;
        //printf("%d %d\n",zge[i] , gib[i]);
    }
    for (int i = 1; i <= maxs; i++)
    {
        long long cant = 0;
        long long cantg = 0;
        for (int j = 1; j <= i; j++)
        {
            cant += len[j];
            cantg += ge[j];
            cantg %= MOD;
            cant %= MOD;
        }
        for (int j = maxs; j >= 0; j--)
        {
            if (j + i <= maxs)
            {
                ge[j + i] += ge[j];
                len[j + i] += ge[j] + len[j];
                ge[j + i] %= MOD;
                len[j + i] %= MOD;
            }
        }
        ans[i] = (gib[i - 1] - cant + zge[i - 1] - cantg + MOD) % MOD;
        ans[i] += ans[i - 1];
        ans[i] %= MOD;
    }
    long long now = 1;
    for (int i = 1; i <= maxs; i++)
    {
        now *= half;
        now %= MOD;
        ans[i] --;
        if (ans[i] < 0) {
            ans[i] += MOD;
        }
        ans[i] *= now;
        ans[i] %= MOD;
    }
    for (int i = 0; i < t; i++)
    {
        if (ans[que[i]] == 0)
        {
            printf("0");
        }
        else
        print(ans[que[i]]);
        printf("\n");
    }
}

```


---

## 作者：opened (赞：0)

- 设 $f_i$ 为选出边长和为 $i$ 的不合法方案数

- 设 $w_i$ 为选出边长和为 $i$ 的不合法权值和

对于 $f$ 的转移，直接背包即可。

对于 $w$ 的转移: 我们考虑加入一条长度 $i$ 的边加入边集,那么如果是从 $w[j-i]$ 转移到 $w[j]$ , 那么就会在 $w[j-i]$ 的所有状态的边集中加入一条长度为 $i$ 的边然后考虑的不同的边集个数是 $f[j-i]$

那么在每一个边集中加入一条边的权值和, 就等价于**在原本的权值和的基础上加上等同于边集的个数**。

然后从小到大枚举并且累加答案即可。

```
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const int N=5010,p=1e9+7;
int T,n;
ll f[N],w[N],s[N];
ll pow(ll a,int b){
    ll ans=1;
    while(b){
    	if(b&1) ans=(ans*a)%p;
    	a=(a*a)%p;
		b>>=1;
	}
    return ans;
}
int main(){
	f[0]=1;
    for(int i=1;i<=5000;i++){
        s[i]=s[i-1];
        for(int j=0;j<=i;j++) s[i]=(s[i]+(f[j]+w[j])%p)%p;
        for(int j=5000;j>=i;j--) f[j]=(f[j]+f[j-i])%p,w[j]=(w[j]+f[j-i]+w[j-i])%p;
    }
	scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        cout<<pow(pow(2,n),p-2)%p*((pow(2,n-1)%p*n%p-s[n]%p)+p)%p<<'\n';
    }
	return 0;
}
```

---


# [GZOI2017] 取石子游戏

## 题目背景

GZOI2017 D1T1

## 题目描述

Alice 和 Bob 在玩一个古老的游戏。现在有若干堆石子，Alice 和 Bob 轮流取，每次可以选择其中某一堆的石子中取出任意颗石子，但不能不取，谁先取完使得另一个人不能取了算赢。

现在场地上有 $N$ 堆石子，编号为 $1$ 至 $N$。Alice 很快发现了这个游戏存在一些固定的策略。阴险的 Alice 想赢得这场比赛就来找到主办方你，希望你在这 $N$ 堆石子中选出若干堆石子作为最后游戏用的石子堆并使得 Alice 能获得胜利。你自然不想让 Alice 得逞，所以你提出了一个条件：Alice 在这个游戏中第一次取的那堆石子的编号需要你来指定（仅指定取的石子堆编号，不指定第一次取多少个，这个指定的石子堆必然包含在最后游戏用的石子堆中）。

现在你很好奇，你想算算有多少种方案让 Alice 不能获胜。注意，即使选出的石子堆的编号的集合完全相同，指定第一次取的石子堆的编号不同，也认为方案是不同的。

## 说明/提示

【样例 $1$ 解释】

第一种：选编号 $1$ 和编号 $2$，指定编号 $1$。

第二种：选编号 $1$ 和编号 $3$，指定编号 $1$。

第三种：选编号 $1$、编号 $2$ 和编号 $3$，指定编号 $2$。

第四种：选编号 $1$、编号 $2$ 和编号 $3$，指定编号 $3$。

第五种：选编号 $2$ 和编号 $3$，指定编号 $2$。

【数据约束】

| 数据编号 | $N$ | 每堆石子数量 |
| :-: | :-: | :-: |
| $1$ | $\le 5$ | $\le 5$ |
| $2$ | $\le 10$ | $\le 10$ |
| $3$ | $\le 100$ | $\le 100$ |
| $4$ | $\le 200$ | $\le 200$ |
| $5$ | $\le 200$ | $\le 200$ |

## 样例 #1

### 输入

```
3
2 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
3
1 2 2```

### 输出

```
6```

# 题解

## 作者：TonyYin (赞：22)

2022/08/04，fix：第一堆石子应小于其他堆

# Nim类石子游戏介绍

（学过的话可以跳到**题目分析**部分

## $\rm{Description}$

给定数列 $n_1, n_2, \cdots, n_k$，表示有 $k$ 堆物品，第 $i$ 堆物品的数量为 $n_i$。

两人轮流从中取物品，规则：**每次可以从一堆中拿走任意正整数个物品**。先拿走最后一根的人胜利。

对于给定的数列，判断先手是否必胜，若必胜，输出第一次应该在哪堆取多少物品。

## $\rm{Solution}$

### 必胜必败分析

**先手必胜，当且仅当 $n_1\oplus n_2\oplus\cdots\oplus n_k\neq 0$。**

对于其他 `nim游戏` ，假设状态表示为 $(a_1, a_2, \cdots,a_n)$，那么先手必胜，当且仅当 $\operatorname{sg}(a_1)\oplus \operatorname{sg}(a_2)\oplus\cdots\oplus \operatorname{sg}(a_n)$，证明BFS。

本题中 $\operatorname{sg}(i)=i$，所以有上面的结论。

### 证明

设 $s=n_1\oplus n_2\oplus\cdots\oplus n_k$.

也就是证明：

1. 当 $s \neq 0$ 时，存在一种取法，使得 $s=0$.
2. 当 $s=0$ 时，无论怎么取物品，$s$ 都不等于 $0$.

#### 命题一

因为 $s\neq 0$，根据异或的定义，存在一堆物品 $i$，满足 $n_i\oplus s<n_i$ ，那么就从第 $i$ 堆取走 $n_i-(n_i\oplus s)$，剩下 $n_i\oplus s$ 个物品。

此时，$s_{\rm{new}}=n_1\oplus n_2\cdots\oplus n_k\oplus s=s\oplus s=0$.

所以命题一成立。

#### 命题二

反证法。若否，则 $s=0$ 时，存在一种取物品的方法使得 $s_{\rm{new}}=0$.

设取走第 $i$ 堆的若干物品，第 $i$ 堆剩余 $n_i'$ 个物品。

所以 $s_{\rm{new}}=n_1\oplus n_2\cdots\oplus n_i'\oplus\cdots\oplus n_k=0=s$.

把 $s$ 的定义式代入，得到 $n_i=n_i'$，产生矛盾。

所以命题二成立。

# 题目分析

显然，可以看出这个问题与`Nim`类游戏相关。`Nim`类游戏先手**必胜，当且仅当每堆石子的数量的异或和不为 $0$**。

所以Alice先手必败仅有两种情况：

1. 异或和为 $0$；
2. 异或和不为 $0$，但`Alice`选择的第一堆石子无法使异或和变成0.

第一种情况容易处理，对于第二种情况，可以发现：**只有指定选的第一堆石子数量，小于其他堆的异或和**时，才能够做到：删去一堆棋子，异或和也不为 $0$.

所以就可以枚举`Alice`先选择哪一堆，然后每次`DP`处理：有多少种选择方法使得异或和等于 $j$.

通过数学方法进行分析，容易得到上一段中的 $j\in[0, 256]$，于是直接二维 `DP` 即可。

`DP`状态：$f_{i, j}$ 表示，当固定一堆不选时，其余的前 $i$ 堆，异或和为 $j$ 的方案数量。

每次从上一行转移过来，具体看代码就行了。

## 代码

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 208, MAXJ = 270, mod = 1e9 + 7; 
int n;
int a[MAXN];
int dp[MAXN][MAXJ]; //dp[i][j]表示，当固定一堆不选时，其余的前i堆，异或和为j的方案数量 
signed main() {
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
	}
	int ans = 0; dp[0][0] = 1;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			for(int k = 0; k < 256; k++) {
				if(i == j) dp[j][k] = dp[j-1][k];
				else dp[j][k] = (dp[j - 1][k] + dp[j - 1][k ^ a[j]]) % mod;
			} 
		}
		for(int j = a[i]; j < 256; j++) {
			ans = (ans + dp[n][j]) % mod;
		}
	}
	cout << ans << endl;
	return 0;
}
```



---

## 作者：cjlak1o1 (赞：8)

这道题目蒟蒻看了很多大佬的解释，感觉不太适合新手，所以打算再写一篇。(~~主要是自己看了好久，一些细节问题把本蒟蒻给整懵了~~)  
### 题目大意:

- 现在有 $n$ 堆石子。

- 找到几堆石子异或和不为 $0$，使得先手**可以**获胜。

- 在几堆石子中找到一堆，让先手取这一堆中**任意数量**的石子都不能使异或和为 $0$，使对手进入必胜状态。

- 求满足上述情况方案数。

(如果您未学过博弈论，请先移步到 [OI_Wiki-博弈论](https://oi-wiki.org/math/game-theory/impartial-game/) 学习 Nim 游戏)

### 如何使先手必败:

**即让先手无法使剩余石子数异或和为 $0$，使对手进入必胜状态。** 

我们都知道，**只有两个相等的数**异或和才为 $0$，那么我们先求出除了我们选的**第一堆以外的其他几堆中任意几堆石子**的异或和，如果这个异或和**大于等于(因为必须取)** 我们所选的第一堆石子数量，那么先手无论如何都不能使第一堆石子与异或和相等，无法使异或和变为 $0$。

### 做法:

- 直接枚举第一堆石子选那一堆 $i$。

- 枚举 $j$ 从 $1$ 到 $n$，表示从前 $j$ 堆中任意选几堆石子(保证不包括第 $i$ 堆)。

- 枚举 $k$ 从 $0$ 到 $255$，表示异或和可能的情况，由于 $a_i$ 较小，所以可以枚举。

- 若 $i=j$ 延续并跳过。

- $i\ne j$ 则 $dp_{j,k}\leftarrow dp_{j-1,k}+dp_{j-1,k\oplus a_j}$。

($dp_{j-1,k}$ 表示不选 $j$ 就异或为 $k$)  
($dp_{j-1,k\oplus a_j}$ 表示选 $j$，将 $k\oplus a_j$ 与 $a_j$ 异或后等于 $k$)

- 枚举大于等于 $a_i$ 的异或和将方案数加起来。

代码看各位大佬的，写的非常好。

**蒟蒻拙见，请指教。**



---

## 作者：decoqwq (赞：7)

考虑一个普通的 $Nim$ 游戏，先手必胜当且仅当各堆石子的数量异或起来不为 $0$ ,这样就可以转移到一个异或起来为 $0$ 的必败态

需要让 $Alice$ 必败的条件便是，要么选择的石子堆中数量异或为 $0$，要么 $Alice$ 无法在这一堆中选择足够的石子使得剩下的异或为 $0$ ，所以给定 $Alice$ 选择的这堆石子的数量一定需要大于等于其他选择的堆的数量的异或值

考虑枚举让 $Alice$ 先选择哪一堆，对于其他的石子堆，可以 $dp$ 求出前 $i$ 堆中任意选择一些使得异或值为 $j$ 的方案数，然后就可以直接计算答案了

时间复杂度 $O(n^2 \times 256)$，注意到异或后值域会变大，要计算到 $256$

```cpp

#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,a[210],dp[210][260];
void dps(int x)
{
	memset(dp,0,sizeof(dp));
	dp[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<256;j++)
		{
			if(i==x)
			{
				dp[i][j]=dp[i-1][j];
				continue;
			}
			dp[i][j]=(dp[i-1][j]+dp[i-1][j^a[i]])%mod;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		dps(i);
		for(int j=a[i];j<256;j++)
		{
			ans=(ans+dp[n][j])%mod;
		}
	}
	cout<<ans;
}
```

---

## 作者：David_Mercury (赞：6)

Update: 添加关于结论的证明。

提供一种 $O(nV \log V)$ 的使用线性基的做法。

------------

### 题意简述

[传送门](https://www.luogu.com.cn/problem/P5675)

对于经典 Nim 游戏，在给定石子堆中选出若干堆，并选择某一堆作为先手所选的第一堆，问使得先手必败的方案数。

------------

### 算法

对于 Nim 游戏的结论部分，别的题解已经叙述得很清楚了，在此略过。

其实这个算法的主体部分和其它题解是一样的——固定一堆石子 $i$ 第一堆选，并计算此时其它堆异或和为 $j$ 的方案数。这里使用线性基对求方案数的过程进行了优化。

如果此时我们有了除了 $i$ 以外的石子堆组成的线性基，我们便可以求出该方案数。从高斯消元的角度来理解，**当消元最后的矩阵有 $k$ 个空行时，则有 $2^k$ 种不同的方案数**。在线性基上来说，如果有 $k$ 个数在插入时被消为了 $0$，则有 $2^k$ 种不同的方案数。

> 关于上述结论为何成立（如果你觉得结论很显然，可以跳过）：
>
> 首先考虑不选择空行的情况。我们设线性基能够表出的集合为 $S$。根据平面向量基本定理，$S$ 中的每一个数此时都只有唯一的表出方案。
>
> 接着我们强制选择一个在线性基中被消为 $0$ 的数 $x$（即“空行”），并观察 $S$ 是否因 $x$ 的加入而改变。强制加入 $x$ 后，线性基能表出的集合为 $T = \{t | t = s \text{ xor } x, s \in S\}$。因为 $x$ 被消为空行，有 $x \in S$；又因为 **$S$ 关于异或运算具有封闭性**（即 $a, b \in S \Rightarrow a \text{ xor } b \in S$），所以 $T = S$。故 $S$ 不因为 $x$ 的加入而改变。
>
> 因此，我们任意选择空行，对线性基能够表出哪个数没有影响。故有 $2^k$ 种不同的方案。

那么该如何求出除 $i$ 以外的石子堆组成的线性基呢？

我们先需要求出一个**前缀线性基**、一个**后缀线性基**，分别记作 $p_1[i], p_2[i]$。以求 $p_1[i]$ 为例，我们每次将 $p_1[i-1]$ 复制到 $p_1[i]$，再在 $p_1[i]$ 中插入 $a_i$。此过程的复杂度为 $O(n \log V)$。注意，在插入过程中要维护被消为 $0$ 的数的个数。

在枚举第一个选的石子堆 $i$ 时，我们则将 $p_1[i-1]$ 与 $p_2[i+1]$ **两个线性基进行合并**，即暴力地将 $p_2[i+1]$ 的每一个数插入 $p_1[i-1]$ 中，如此便得到了除 $i$ 以外的石子堆组成的线性基。这一步复杂度为 $O(n \log^2 V)$。同样，这一步也要注意维护被消为 $0$ 的数的个数。

接着就枚举每一个异或结果 $j$，如果其既可以被线性基表出、又满足 Nim 游戏的必败条件，则将答案累加 $2^k$。这一步复杂度为 $O(n V \log V)$。（通过将计算方法换作 DFS 枚举在线性基中选取哪些数应该能够做到 $O(nV)$，但是懒得写。）

总时间复杂度为 $O(n V \log V)$。

------------

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXT = 10, MAXN = 1<<MAXT, Mod = 1e9+7;
int n, m, a[MAXN], p1[MAXN][MAXT], p2[MAXN][MAXT], p[MAXT], h[MAXN], Pow[MAXN], ans;

inline void Insert(int p[], int x){
	for(int j = 8; j >= 0; j--){
		if(!(x&(1<<j)))	continue;
		if(!p[j])	{p[j] = x; break;}
		else		x ^= p[j];
	}
	if(!x)	++p[9];//p[9] 记录被消为 0 的数的个数
	return;
}

inline bool Check(int p[], int x){
	for(int j = 8; j >= 0; j--)
		if(x&(1<<j))	x ^= p[j];
	return !x;
}

int main(){
	cin>>n;
	for(int i = 1; i <= n; i++)	cin>>a[i];
	for(int i = 1; i <= n; i++){
		for(int j = 0; j <= 9; j++)	p1[i][j] = p1[i-1][j];
		Insert(p1[i], a[i]);
	}
	for(int i = n; i >= 1; i--){
		for(int j = 0; j <= 9; j++)	p2[i][j] = p2[i+1][j];
		Insert(p2[i], a[i]);
	}
	for(int i = 1; i < 1<<9; i++)	h[i] = log2(i);
	Pow[0] = 1;
	for(int i = 1; i < 1<<9; i++)	Pow[i] = Pow[i-1]*2%Mod;
	for(int i = 1; i <= n; i++){
		for(int j = 0; j <= 9; j++)	p[j] = p1[i-1][j];
		for(int j = 0; j <= 8; j++)	if(p2[i+1][j]) Insert(p, p2[i+1][j]);
		p[9] += p2[i+1][9];
		for(int j = 0; j < 1<<9; j++)
			if(Check(p, a[i]^j) and (!(a[i]&(1<<h[j])) or !j))	ans = (ans+Pow[p[9]])%Mod;
	}
	cout<<ans;
	
	return 0;
}
```

---

## 作者：pomelo_nene (赞：6)

我们因为不知道第一堆石子到底是哪一堆，所以说我们直接枚举

我们考虑让$Bob$后手赢这场游戏，所以说$Alice$在一开始或者第二回合变成必败状。做了nim游戏的板子的都知道必败状是$a_1 \otimes a_2 \otimes ... \otimes a_n=0$（$\otimes$为异或符号），我们要让$Alice$面对必败状，我们只能让剩下的$n-1$堆石子异或起来大于等于第一堆。因为如果小于的话，$Alice$一定能找到一种方法取第一堆石子使得$a_1 \otimes a_2 \otimes ... \otimes a_n=0$

同时，我们发现$a_i$极其之小，异或起来最多也不过$2^8-1$，我们考虑把它作为dp数组的一维

那么我们定义$dp[i][j]$为前$i$堆除了枚举的第$k$堆外异或起来的数为$j$的方案，然后每次跑一边dp，统计一遍答案即可

时间复杂度$\Theta ( n^2 \log a_i)$，其中$\log a_i$最大为$8$，近似于常数

代码如下

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#define MOD 1000000007ll
using namespace std;
long long n,a[205],dp[205][260],ans;
int main(){
	scanf("%lld",&n);
	dp[0][0]=1;
	for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]);
	for(long long i=1;i<=n;++i)
	{
		for(long long j=1;j<=n;++j)
		{
			for(long long k=0;k<=255;++k)
			{
				if(i==j)	dp[j][k]=dp[j-1][k];//这里一定要跳过，去掉我们枚举的“第一堆”
				else	dp[j][k]=dp[j-1][k]+dp[j-1][k^a[j]],dp[j][k]%=MOD;
			}
		}
		for(long long j=a[i];j<=255;++j)	ans+=dp[n][j],ans%=MOD;//统计第i堆作为第1堆的答案
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：4)

$\text{nim}$ 游戏是很 $\text{basic}$ 的公平组合游戏。

做此题前，你需要先学会 [nim 游戏](/problem/P2197)，然后发现这题还是一个模板。

枚举强制先选的堆，如果所有的异或和为 $0$ 或超过了先选的堆，$\text{Alice}$ 就无法做到操作之后异或和为 $0$，于是 $\text{Bob}$ 必胜。

实现时对于前后缀做异或和背包即可，预处理是 $O(nC)$ 的，而合并时 $O(C^2)$ 的，需要进行 $n$ 次合并，所以总复杂度为 $O(nC^2)$，可以通过。

还可以再优化，使用 $\text{FWT}$ 维护集合对称差卷积或者在 $\text{01trie}$ 上查 $C$ 次，这样将总复杂度降到了 $O(nC\log_2C)$，但这不是考点，没有必要。

通过的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=302,M=1e9+7;
int f[N][N],g[N][N],n,a[N],ans,now,h[N];
inline void add(int &x,int y){
	if((x+=y)>=M)x-=M;
}
int main(){
	ios::sync_with_stdio(false);
	int i,j,k,l,r;
	for(i=1,cin>>n;i<=n;++i)cin>>a[i];
	f[0][0]=g[n+1][0]=1;
	for(i=1;i<=n;++i)
		for(j=0;j<256;++j)
			f[i][j]=(f[i-1][j]+f[i-1][j^a[i]])%M;
	for(i=n;i;--i)
		for(j=0;j<=256;++j)
			g[i][j]=(g[i+1][j]+g[i+1][j^a[i]])%M;
	for(i=1;i<=n;++i){
		for(l=0;l<256;++l)h[l]=0;
		for(l=0;l<256;++l)
			for(r=0;r<256;++r)
				add(h[l^r],ll(f[i-1][l])*g[i+1][r]%M);
		add(ans,h[a[i]]);
		for(l=a[i]+1;l<256;++l)
			add(ans,h[l^a[i]]);
	}printf("%d\n",(ans%M+M)%M);
	return 0;
} 
```

---

## 作者：是个妹子啦 (赞：4)

$Nim$游戏：各堆石子异或和为$0$，先手必败，否则必胜

如果第一堆石子数目大于其它石子异或和，先手可以拿走大于的数量，转为必胜态

所以要让第一堆石子数$\le$其它石子异或和

定义$f[i][j]$为前$i$堆石子$xor$和为$j$的方案数，注意转移需要跳过枚举的第一堆石子，异或和最大为256

$O(n^3)$

```cpp
int f[205][260],a[205],n,ans;
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;++i) scanf("%d",&a[i]);
	f[0][0] = 1;
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= n;++j)
			for(int k = 0;k < 256;++k){
				if(i == j) f[j][k] = f[j-1][k];//跳过 
				else f[j][k] = (f[j-1][k] + f[j-1][k^a[j]]) % mod;
			}
		for(int j = a[i];j <= 255;++j) ans += f[n][j],ans %= mod;
	}
	printf("%d",ans);
}
```



---

## 作者：xujindong_ (赞：1)

考虑合法条件，要么异或和为 $0$，要么异或和不为 $0$ 且 Alice 不能通过取选定的堆使异或和变为 $0$。后者要求选定的这堆石子数小于其他石堆的异或和。

因为选定的石堆不同方案也不同，枚举选定的石堆，问题变为从其他石堆中选一个集合使异或和大于等于选定的石堆。简单的做法是直接 DP，$O(nV^2)$。

考虑使用线性基，我们知道一个集合表出任一可表出的数的方案数是 $2^{n-cnt}$，其中 $n,cnt$ 分别为集合大小和线性基大小。我们可以预处理每个前缀和后缀的线性基，这样可以合并出序列扣掉每个数的线性基，$O(2^{cnt})$ 枚举基内数即可知道每个能表出的数。$O(nV)$。

进一步地，我们可以直接按位贪心出线性基有几种方式组合出大于等于某个值，具体方式是分类讨论一下，枚举组合出的值与这个数的 LCP，如果在某一位比较出来了，线性基中比这一位低的数可以随便选。$O(n\log^2V)$。

瓶颈只剩怎么快速获得扣掉任意一个数的线性基。注意到删掉会给线性基带来影响的数一定在基内，共 $O(\log V)$ 个，我们只对这些数进行线性基合并，$O(\log^3V)$ 不是瓶颈。复杂度 $O(n\log V)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
int n,a[205],p[205],ans;
bool vis[205];
template<typename T,int maxn>struct basis{
  T b[maxn];
  basis(){
    memset(b,0,sizeof(b));
  }
  bool insert(T k){
    for(int i=maxn-1;i>=0;i--){
      if(k>>i&1){
        if(!b[i])return b[i]=k,1;
        k^=b[i]; 
      }
    }
    return 0;
  }
  int query(int k,int ans=0){
    int num[maxn]={1};
    for(int i=1;i<maxn;i++)num[i]=num[i-1]*(b[i-1]?2:1);
    for(int i=maxn-1,now=0;i>=0;i--){
      if(k>>i&1){
        if(~now>>i&1){
          if(b[i])now^=b[i];
          else return ans;
        }
      }
      else{
        if(now>>i&1){
          ans+=num[i];
          if(b[i])now^=b[i];
          else return ans;
        }
        else if(b[i])ans+=num[i];
      }
    }
    return ans+1;
  }
};
template<typename T,int maxn>basis<T,maxn>merge(basis<T,maxn>a,basis<T,maxn>b){
  for(int i=0;i<maxn;i++)a.insert(b.b[i]);
  return a;
}
basis<int,8>pre[205],suf[205];
int main(){
  p[0]=1,cin>>n;
  for(int i=1;i<=n;i++)cin>>a[i],p[i]=2ll*p[i-1]%mod;
  for(int i=1;i<=n;i++)pre[i]=pre[i-1],vis[i]=pre[i].insert(a[i]);
  for(int i=n;i>=1;i--)suf[i]=suf[i+1],suf[i].insert(a[i]);
  for(int i=1;i<=n;i++){
    int cnt=0;
    basis<int,8>t=vis[i]?merge(pre[i-1],suf[i+1]):pre[n];
    for(int j=0;j<8;j++)if(t.b[j])cnt++;
    ans=(ans+1ll*p[n-cnt-1]*t.query(a[i]))%mod;
  }
  return cout<<ans<<'\n',0;
}
```

---

## 作者：Error_Eric (赞：1)

这里提供另外一种 dp 方法。

### 题意

[传送门](https://www.luogu.com.cn/problem/P5675)

### 解法

有一个重要的结论就是当且仅当存在一种方案使得 Alice 取了一次后，剩下的石子异或和为 $0$ 时，Alice 可以必胜。

具体的证明可以看 [这道题](https://www.luogu.com.cn/problem/P2197) 。

> 枚举 Alice 先取哪个的确是一种方法，其他题解已经讲的很详细了。这里提供另外一种dp思路。

- 记第 $i$ 堆石子个数为 $a_i$

- 记所有我们选出的石子堆中，除了我们让 Alice 先取的那一堆 $p$，的个数的异或和为 $k$。

- 若 $a_p>k$ 则 Alice 可以取出 $a_p-k$ 个石子，那么 Alice 就赢定了。

因此我们求的本质上是 $a_p\le k$ 的方案数目。

令 $f_{i,j,k}$ 表示 $[1,i]$ 的石子堆中，**至少取了一个**，并且**没有取** $\bm{a_j}$ 的条件下， 异或和为 $k$ 的方案数。

特殊地，若 $j=0$ 则表示 $[1,i]$ 的石子堆中，至少取了一个，异或和为 $k$ 的方案数。

那么转移方程是显然的：

$f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j,k\oplus a_i}+[k=a_i](j<i)$

$f_{i,i,k}=\sum f_{i-1,0,k}$ 。

$i$ 这一维可以滚动掉。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<vector>
using namespace std;
#define il inline
il const void readln(int &I){
    I=0;char C=getchar();
    while(!isdigit(C))C=getchar();
    while( isdigit(C))I=I*10+C-'0',C=getchar();
}
const int maxn=205,modd=1e9+7;
int n,a[maxn],l,xsum;
struct cnter{int val;cnter(){val=0;}cnter(int v){val=v;}};
cnter operator+ (cnter ca,cnter cb){return (ca.val+cb.val)%modd;}
cnter operator+=(cnter&ca,cnter cb){return ca=ca+cb;}
cnter f[2][maxn][258];// f[n&1][j][k]  a[j] not selected,how many ways to get xorsum k.
cnter ans;
int main(){
    readln(n);
    for(int i=1;i<=n;i++)
        readln(a[i]);
    for(int i=1;i<=n;i++){
        f[i&1][i][xsum]+=(i!=1),xsum^=a[i],l=((i&1)^1);
        for(int j=0;j<i;j++){
            for(int k=0;k<256;k++)
                f[i&1][j][k]=f[l][j][k]+f[l][j][k^a[i]],f[i&1][i][k]=f[l][0][k];
            f[i&1][j][a[i]]+=1;
        }
    }
    for(int j=1;j<=n;j++)
        for(int k=a[j];k<256;k++)
            ans+=f[n&1][j][k];
    printf("%d\n",ans.val);
}

```

---

## 作者：BigSmall_En (赞：0)

## 现有题解的一些补充

算法的原理的实现别的题解都说得很清楚了。但是题解都没提到为什么 **只有指定选的第一堆石子数量，大于其他堆的异或和时，才能做到 nim 和为** $0$。（其实也非常好想）

这里证明一下：

假设第 $i$ 堆石子为 $a_i$ 个，取 $k$ 个后 nim 和为 $0$ 。设其他堆的异或和为 $b$ 。则
$$
(a_i-k)\oplus b=0
$$

$$
\therefore a_i-k=b,a_i-b=k
$$

因为 $k>0$

$$
\therefore a_i-b>0,a_i>b
$$

## 题解

两种情况下先手无法取胜

1. 所有堆石子 nim 和为零 。
2. 指定一堆先手必须选，这一堆选任意石子都无法使 nim 和为零 。

现在题目要求选出来的石子堆必能先手获胜。考虑如何满足情况 2 。

因为不能使得 nim 和为 $0$，所以自然的 $a_i\leq b$ 。（这里 $a,b$ 的定义见上方证明）

这时问题就转化为了求不取第 $i$ 堆石子，其他堆任意选的异或值大于等于 $a_i$ 的方案数。

```cpp
const ll MOD=1000000007;
int n,a[N];
ll dp[N][256],ans;//异或后值会大于200
int main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i){//枚举必须选哪一堆石子
		dp[0][0]=1ll;
		for(int j=1;j<=n;++j){
			for(int k=0;k<256;++k){
				if(i==j)dp[j][k]=dp[j-1][k];
				else dp[j][k]=(dp[j-1][k]+dp[j-1][k^a[j]])%MOD;
			}
		}
		for(int k=a[i];k<256;++k)
			ans=(ans+dp[n][k])%MOD;
	}printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5679)

### 题意：

-  $n$ 堆石子，第 $i$ 堆有 $a_i$ 个。

- 指定一些石子堆使得先手必胜并指定一个先手第一个取的位置使得先手必败。

- 求有多少方案数。

### 分析：

- 根据 $NIM$ 游戏，只要石子数异或和为 $0$ 则先手必败。

- 然后我们考虑枚举指定先手先去哪一堆石头，我们要选择一些石子堆使没有任何一种方法取走一些石头使得先手必败。

- 我们用 $f_{i,j}$ 表示在不包括枚举的石头堆的情况下，前 $i$ 堆石头有多少种选择方案使得其异或和为 $j$ 。然后若强制先手选择第 $k$ 堆石头那么方案数就是：

	$\sum\limits_{i=a_k}^\infty a_i$
    
时间复杂度： $O(n^3)$ （还是能过的）。

**code：**
```cpp
#include<cstdio>
const int mod=1e9+7;
int n,a[205],dp[205][256],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	for(int k=1;k<=n;++k){
		dp[0][0]=1;//初始化 
		for(int i=1;i<=n;++i){
			if(i==k){
				for(int j=0;j<256;j++)dp[i][j]=dp[i-1][j];
			}else{
				for(int j=0;j<256;++j)dp[i][j]=(dp[i-1][j]+dp[i-1][j^a[i]])%mod;//状态转移
			}
		}
		for(int i=a[k];i<256;++i)ans=(ans+dp[n][i])%mod;//取模，累积答案 
	}
	printf("%d",ans);
	return 0;
}
```
Bye！

---

## 作者：gzqlbx666 (赞：0)

### 题外话
第一次写蓝题题解有点紧张&激动……


------------

[$\color{blue} \text{P5675 题目传送门}$](https://www.luogu.com.cn/problem/P5675)
# NIM 游戏介绍

## 介绍
NIM 游戏的规则：有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个，每次可以从某一堆中取走若干个，先后手轮流取，最后无石子可取的人败。

## 结论
NIM 游戏结论：将这 $n$ 堆石子的数量异或起来（即 $a_1 \ \oplus \ a_2 \ \oplus ~...~\oplus \ x_n$），假如不为 $0$，那么先手必胜，否则先手必败。

由于这东西的证明需要用到二进制，所以下面的证明都在二进制意义下讨论。

## 证明

首先要知道两个定义：

> 必胜态：双方足够聪明的情况下，在该状态时拥有操作权者必胜
> 必败态：双方足够聪明的情况下，在该状态时拥有操作权者必败

以及一些基础知识：如果一个状态能转移到任意一个必败态，那么该状态就是必胜态，如果不能，就是必败态。

**在 Nim 游戏中，异或和不为 $0$ 就是必胜态，否则是必败态。**

先考虑必胜态怎么必胜：

假设他们异或起来为 $k(k\neq 0)$，且 $k$ 的最高位为第 $p$ 位，那么至少存在一个 $a_i$，满足 $a_i$ 的第 $p$ 位是 $1$，那么我们只需要让 $a_i$ 异或上 $k$ 即可，由于 $a_i$ 的第 $p$ 位是 $1$，所以 $a_i$ 异或 $k$ 肯定是减少了。

异或完后，所有石子的异或和就变成了 $0$ ，也就是必败态，由于能转移到必败态，所以一开始的状态为必胜态。

再考虑必败态为什么必败：

这个就简单很多了,由于此时异或和为 $0$，不管怎么拿，拿完之后肯定不为 $0$，也就是说，这个状态只能转移到必胜态，那么这个状态就是必败态了。

# 题目分析
## 题目理解
$n$ 堆石子，第 $i$ 堆有 $a_i$ 个。指定一些石子堆使得先手必胜并指定一个先手第一个取的位置使得先手必败，求有多少方案数。
## 分析
- 根据 NIM 游戏，只要石子数异或和为 $0$ 则先手必败。

- 然后我们考虑枚举指定先手先去哪一堆石头，我们要选择一些石子堆使没有任何一种方法取走一些石头使得先手必败。

- 我们用 $f_{i,j}$ 表示在不包括枚举的石头堆的情况下，前 $i$ 堆石头有多少种选择方案使得其异或和为 $j$ 。然后若强制先手选择第 $k$ 堆石头那么方案数就是
 $\sum\limits_{i=a_k}^∞f_{n,i}$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=210,XJQ=1e9+7;
int n,a[N],f[N][256],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int k=1;k<=n;k++)
    {
		f[0][0]=1;
		for(int i=1;i<=n;i++)
			if(i==k)
				for(int j=0;j<256;j++)
					f[i][j]=f[i-1][j];
			else
				for(int j=0;j<256;j++)
					f[i][j]=(f[i-1][j]+f[i-1][j^a[i]])%XJQ;
		for(int i=a[k];i<256;i++)
			ans=(ans+f[n][i])%XJQ;
	}
	printf("%d",ans);
}
```



---

## 作者：Xu__ (赞：0)

[[GZOI2017] 取石子游戏](https://www.luogu.com.cn/problem/P5675)

考虑 Nim 游戏的获胜条件，先手必胜当前仅当开始局面异或和为 $0$，为了让阴险的 Alice 不能获胜，有以下两种办法：


- 开局异或和为 $0$。
- 开局异或和不为 $0$，但是指定的一堆石子数量小于其他石子的异或和。  


第一种情况可以认为是指定的一堆石子必须等于其他石子的异或和，所以我们的任务就是：从 $n$ 堆石子中选择任意堆，从选择的石子堆里面选出一堆，使其数量小于等于选择的其他石子的异或和。

考虑钦定 Alice 选哪一堆，然后用动态规划求出其余石子异或和大于等于选定石子个数的方案数即可。

设钦定 Alice 选择第 $i$ 堆石子， $f_{j, k}$ 表示前 $j$ 堆里，异或和等于 $k$ 的方案数，容易得到转移方程：

$$
f_{j,k}=\begin{cases}
f_{j-1,k}&i=j\\
f_{j-1,k}+f_{j-1,k\oplus A_j}&i\not ={j}
\end{cases}
$$

分两种情况的原因是钦定的石子堆是不能用来转移的。

```cpp
#include <bits/stdc++.h>
//#define int long long
#define FL(a, b, c) memset(a, b, c)
#define RE() cout << "What Happened?" << endl
#define TE() cerr << "Time : " << clock() << "(ms)" << endl
#define DG(x) cout << "Debug : " << #x << " = " << x << endl
#define IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a <= c; ++a)
#define OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a >= c; --a)
#define ER(a, b, c, ...) for(int a(head[b]), c(ver[a]), ##__VA_ARGS__; a; a = next[a], c = ver[a])
using namespace std;
struct FastIN {
	template < class T > inline FastIN& operator >> (T& x) {
		x = 0; bool sd(false);
		char ch(getchar());
		while (!isdigit(ch) and (ch != '-')) ch = getchar();
		if (ch == '-') sd = true, ch = getchar();
		while (ch >= '0' and ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
		if (sd == true) x = -x;
		return *this;
	}
} IN;
const int INF(~0u >> 1);
template < class T > inline void CL(T& x_) { FL(x_, 0, sizeof x_); }
template < class T, class... Args> inline void CL(T &x_, Args& ...others) { FL(x_, 0, sizeof x_), CL(others...); }

const int kN(222), kV(257), Mod(1e9 + 7);
int N, A[kN], Ans;
int F[kN][kV];

signed main() {
#ifdef FIO
	freopen("I:/Code/Data/In.in", "r", stdin);
	freopen("I:/Code/Data/Out.out", "w", stdout);
#endif
  IN >> N; IR(i, 1, N) IN >> A[i];
	IR(i, 1, N) {
		FL(F, 0, sizeof F);
		F[0][0] = 1;        
		IR(j, 1, N) {
			IR(k, 0, 255) {
				if (i == j) F[j][k] = F[j - 1][k];
				else F[j][k] = (F[j - 1][k] + F[j - 1][k ^ A[j]]) % Mod;
			}
		}
		IR(j, A[i], 255) Ans = (Ans + F[N][j]) % Mod;
	}
	cout << Ans << "\n";

}
```

---

## 作者：VinstaG173 (赞：0)

[转载：这里是供题人的题解](https://www.cnblogs.com/LanrTabe/p/10329145.html)

首先题目里那个什么【古老的游戏】其实就是[Nim游戏](https://www.luogu.com.cn/problem/P2197)了。

Nim游戏的结论就是如果各堆石子数异或和为$0$那么先手必败，否则先手必胜。

也就是说我们只要使Alice不能通过一次在某指定的堆中的操作使剩余的石子满足各堆数目异或和为$0$就行了。

考虑到每堆石子都是独立的，所以只要枚举哪堆石子是被指定的再求和就行了。

对于每堆石子，我们只要当它不存在，然后考虑到每堆石子数和石子堆数都极少，所以就只要进行一个暴力dp递推处理出除掉这堆石子后前$i$堆中选一些使异或和为$j$的方案数就行了。

然后我们考虑一下哪些情况会使Alice有机会获胜。显然如果对于选定的这堆石子有其他堆石子的异或和小于这堆石子数时，Alice必可以进行一次操作使这堆石子剩余数量和其他堆石子的异或和相等，即使所有堆石子异或和为$0$。于是Alice可以获胜。

所以我们只要对于每堆石子计算其他石子中选出一些使异或和不小于这堆石子个数的方案数再求和就可以了。

Code在供题人的题解里有了，就不放了。

---


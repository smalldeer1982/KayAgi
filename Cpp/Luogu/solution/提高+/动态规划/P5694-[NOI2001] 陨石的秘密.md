# [NOI2001] 陨石的秘密

## 题目描述

公元11380年，一颗巨大的陨石坠落在南极。于是，灾难降临了，地球上出现了一系列反常的现象。当人们焦急万分的时候，一支中国科学家组成的南极考察队赶到了出事地点。经过一番侦察，科学家们发现陨石上刻有若干行密文，每一行都包含5个整数：

```
1 1 1 1 6
0 0 6 3 57
8 0 11 3 2845
```

著名的科学家 SS 发现，这些密文实际上是一种复杂运算的结果。为了便于大家理解这种运算，他定义了一种 SS 表达式：

1. SS 表达式是仅由 `{`, `}`, `[`, `]`, `(`, `)` 组成的字符串。
2. 一个空串是 SS 表达式。
3. 如果 $ A $ 是SS表达式，且 $ A $ 中不含字符 `{`, `}`, `[`, `]`，则 $ (A) $ 是SS表达式。
4. 如果 $ A $ 是 SS 表达式，且 $ A $ 中不含字符 `{`, `}`，则 $ [A] $ 是 SS 表达式。
5. 如果 $ A $ 是 SS 表达式，则 $ \{A\} $ 是 SS 表达式。
6. 如果 $ A $ 和 $ B $ 都是 SS 表达式，则 $ AB $ 也是 SS 表达式。

一个 SS 表达式 $ E $ 的深度 $ D(E) $定义如下：

$$
\scriptstyle{
D(E) =
\begin{cases}
 \scriptstyle{0}, & \scriptstyle{\text{如果 } E \text{ 是空串}} \\
 \scriptstyle{D(A) + 1}, &  \scriptstyle{\text{如果 } E = (A) \text{ 或者 } E = [A] \text{ 或者 } E = \{A\}, \text{ 其中 } A \text{ 是 SS 表达式}} \\
 \scriptstyle{\max(D(A), D(B))}, &  \scriptstyle{\text{ 如果 } E = AB, \text{其中 } A, B \text{ 是 SS 表达式}}
\end{cases}
}
$$

例如 `(){()}[]` 的深度为 $ 2 $。

密文中的复杂运算是这样进行的：

设密文中每行前 $ 4 $ 个数依次为 $ L_1, L_2, L_3, D $，求出所有深度为 $ D $，含有 $ L_1 $ 对 `{}`，$ L_2 $ 对 `[]`，$ L_3 $ 对 `()` 的 SS 串的个数，并用这个数对当前的年份 $ 11380 $ 求余数，这个余数就是密文中每行的第 $ 5 $ 个数，我们称之为“神秘数”。

密文中某些行的第五个数已经模糊不清，而这些数字正是揭开陨石秘密的钥匙。现在科学家们聘请你来计算这个神秘数。


## 说明/提示

$ 0 \le L_1, L_2, L_3 \le 10$，$0 \le D \le 30 $。

## 样例 #1

### 输入

```
1 1 1 2```

### 输出

```
8```

# 题解

## 作者：Little09 (赞：17)

这是一道挺好的dp题，我的方法会理解起来稍微简单点。

题目大意就不赘述了，我们直接考虑**状态**。

令$f[i][j][k][l]$表示选$i$组{},$j$组[],$k$组()且深度为$l$的组合有几种。但是我们发现这样对于S=AB的状态转移是很难实现的。因为AB的深度都不知道，需要依次枚举。

我们可以考虑微调状态，令$f[i][j][k][l]$表示选$i$组{},$j$组[],$k$组()且深度**小于等于**$l$的组合有几种。那么这样的话，状态转移~~貌似~~就容易实现一点。

但是还有问题：对于一些复杂的SS串，可能会有不止一种分法使它分成AB的形式。

举个具体的例子：枚举A为串 $()[]$ ，B为串 $[()]$ 时，组合为 $()[][()] $，但是枚举A为串$()$，B为串$[][()]$时，组合也为$()[][()]$。这样就重复了。

所以有这样~~神奇~~的转移法出现了：对于每个**非空**SS串，有且仅有一种分法：找到两个SS串A,B，使得S=(A)B或[A]B或{A}B

（~~证明应该很显然吧~~）

所以这题就基本完结了。转移方程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/t5hdd54n.png)

最后还有几个细节稍微说一下：

1.要预处理$f[0][0][0][i]=0$，因为可以进行转移的是非空串

2.当输入d=0时，输出特判。其余情况，输出$f[a][b][c][d]-f[a][b][c][d-1]$

3.$f[a][b][c][d]-f[a][b][c][d-1]$由于取过模，可能是负数，处理一下就好

4.题目描述里有3组样例不要错过

代码应该不用放了吧qwq

---

## 作者：一只书虫仔 (赞：9)

#### Description

> 求有多少个由 $L_1$ 对小括号，$L_2$ 对中括号，$L_3$ 对大括号组成的深度为 $D$ 的合法括号串，深度的定义请见 [题面](https://www.luogu.com.cn/problem/P5694)。       
> （原题面中 $L_1$ 为大括号数量，$L_3$ 为小括号数量，本文为了写起来方便就调了个个）

#### Solution

设 $f_{i,j,k,d}$ 为由 $i$ 对小括号，$j$ 对中括号，$k$ 对大括号组成的深度 **至少为** $d$ 的合法括号串的个数（关于为什么是至少为作者也不怎么懂，应该是为了转移方便），输出的时候输出 $f_{L_1,L_2,L_3,D}-f_{L_1,L_2,L_3,D-1}$ 即可。

考虑将一个串分为两个合法括号串的方法其实不怎么好，因为容易重复，也不好排重，因此可以考虑通过原有的串去生成新串，即由两个合法括号串 `A`，`B` 去生成 `A(B)`，`A[B]` 和 `A{B}`。

然后考虑转移：

- $i=j=k=0$，$f_{i,j,k,d}=1$。
- 否则，分三种情况考虑：
	- `A(B)`，因为按照题面中所述，括号是有优先级的，因此 `()` 里不能有 `[]` 和 `{}`，故 `A(B)` 可以从下面这个状态转移过来：
    $$\sum\limits_{p_1=0}^{i-1}f_{i-p_1-1,j,k,d} \times f_{p_1,0,0,d-1}$$
    - `A[B]`，与 `A(B)` 同理，考虑优先级，可以从下面这个状态转移过来：
    $$\sum\limits_{p_2=0}^{j-1}\sum\limits_{p_1=0}^if_{i-p_1,j-p_2-1,k,d} \times f_{p_1,p_2,0,d-1}$$
    - `A{B}`，大括号优先级最高，因此直接枚举所有括号即可：
    $$\sum\limits_{p_3=0}^{k-1}\sum\limits_{p_2=0}^j\sum\limits_{p_1=0}^if_{i-p_1,j-p_2,k-p_3-1,d} \times f_{p_1,p_2,p_3,d-1}$$
- 整理一下，如果不是 $i=j=k=0$，转移方程应如下：
$$f_{i,j,k,d}=\sum\limits_{p_1=0}^{i-1}f_{i-p_1-1,j,k,d} \times f_{p_1,0,0,d-1}+\sum\limits_{p_2=0}^{j-1}\sum\limits_{p_1=0}^if_{i-p_1,j-p_2-1,k,d} \times f_{p_1,p_2,0,d-1}+\sum\limits_{p_3=0}^{k-1}\sum\limits_{p_2=0}^j\sum\limits_{p_1=0}^if_{i-p_1,j-p_2,k-p_3-1,d} \times f_{p_1,p_2,p_3,d-1}$$

#### Code

注意一些细节问题，比如说 $D=0$ 时的特判等等。

```cpp
int ans1 (int i, int j, int k, int d) {
	int ans = 0;
	for (int p1 = 0; p1 < i; p1++) {
		int tmp = dp[i - p1 - 1][j][k][d] * dp[p1][0][0][d - 1];
		tmp %= Mod;
		ans += tmp;
	}
	return ans % Mod;
}

int ans2 (int i, int j, int k, int d) {
	int ans = 0;
	for (int p2 = 0; p2 < j; p2++)
		for (int p1 = 0; p1 <= i; p1++) {
			int tmp = dp[i - p1][j - p2 - 1][k][d] * dp[p1][p2][0][d - 1];
			tmp %= Mod;
			ans += tmp;
		}
	return ans % Mod;
}

int ans3 (int i, int j, int k, int d) {
	int ans = 0;
	for (int p3 = 0; p3 < k; p3++)
		for (int p2 = 0; p2 <= j; p2++)
			for (int p1 = 0; p1 <= i; p1++) {
				int tmp = dp[i - p1][j - p2][k - p3 - 1][d] * dp[p1][p2][p3][d - 1];
				tmp %= Mod;
				ans += tmp;
			}
	return ans % Mod;
}

for (int i = 0; i <= L1; i++)
	for (int j = 0; j <= L2; j++)
		for (int k = 0; k <= L3; k++)
			for (int d = 1; d <= D; d++) 
				if (i == 0 && j == 0 && k == 0) continue;
				else {
					dp[i][j][k][d] = ans1(i, j, k, d) + ans2(i, j, k, d);
					dp[i][j][k][d] %= Mod;
					dp[i][j][k][d] += ans3(i, j, k, d);
					dp[i][j][k][d] %= Mod;
				}
```

---

## 作者：AK_IOI的琪琪 (赞：7)

# 一、题目大意

求出所有由L1个{}、L2个[]以及L3个()组成的合法括号串中，深度为D的个数。这里合法的定义为()不能套在[]、{}的外面，[]不能套在{}的外面。对于一个合法的串S，深度d(S)={0 S为空串；d(A)+1 S=(A)、[A]、{A}；max{d(A),d(B)} S=AB}。

# 二、思路

今天老师上课给我们讲的题，这里发个题解再深刻理解一下~~

既然已有dalao发了记忆化搜索的题解，这里就用纯dp的写法。

考虑状态f[l1][l2][l3][d]为选l1个{},选l2个[],选l3个()并且深度为d的个数。分析一下一个合法串的样子，只有可能是两种：S=(A)、[A]、{A}或S=AB，分别转移一下。第一种情况比较容易，枚举一下最外层是什么括号，需要注意的一点是若外面是[]，那么A就不能含有{}；若外面是()，那么A就不能含有{}、[]。

第二种情况，我们发现，要让max{d(A),d(B)}=d的AB枚举起来十分繁琐，此时我们想一下是否可以微调一下状态。我们考察状态f[l1][l2][l3][d]为选l1个{},选l2个[],选l3个()并且深度**不超过**d的个数。我们再反观一下这种状态的情况一，发现转移方程和之前的一模一样。不过这时的情况二相较而言就好写一些，
但是仍需注意下面的code是有问题的：
```
f[l1][l2][l3][d] += f[i][j][k][d] * f[l1 - i][l2 - j][l3 - k][d]
```
因为对于

### S=()()(),

### A=()、B=()()；

### A=()()、B=()

会被多算一次。

所以我们要保证A为**最短的**形如A=(A')、[A']、{A'}的合法串。这时我们只需枚举合法的A'(注意是A’不是A)和B就可以了，其正确性也是显然的：

对于S=A1B1,S=A2B2,只需说明至多会被这两个算一次。不妨A1比A2长。

S=(__ A1'__)B1

S=(A2')(A2'')B2'，这就与A1的最小性矛盾。

# 三、细节

此题细节比较多。

1.初值：不仅对于f[0][0][0][0]=1，f[0][0][0][0~D]都要赋成1。

2.第二种情况时，要减掉B为**空串**时，因为这已经被第一种情况算过了。

3.由于code比较麻烦，所以要时刻警惕()不能套在[]、{}的外面，[]不能套在{}的外面。

4.答案：对于D=0时，直接输出f[L1][L2][L3][D]；其余情况输出f[L1][L2][L3][D]-f[L1][L2][L3][D-1]。

5.要对11380取模。

# 四、code
```
# include <bits/stdc++.h>
# define MOD 11380
using namespace std;

int L1, L2, L3, D;
int f[15][15][15][35];

int main()
{
    scanf("%d%d%d%d", &L1, &L2, &L3, &D);
    for (int i = 0; i <= D; i++) f[0][0][0][i] = 1;
    for (int l1 = 0; l1 <= L1; l1++)
        for (int l2 = 0; l2 <= L2; l2++)
            for (int l3 = 0; l3 <= L3; l3++)
                for (int d = 1; d <= D; d++) {
                    if (l1) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1 - 1][l2][l3][d - 1]) % MOD;
                    if (!l1 && l2) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1][l2 - 1][l3][d - 1]) % MOD;
                    if (!l1 && !l2 && l3) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1][l2][l3 - 1][d - 1]) % MOD;
                    for (int i = 1; i <= l1; i++)
                        for (int j = 0; j <= l2; j++)
                            for (int k = 0; k <= l3; k++) {
                                int tmp = f[l1 - i][l2 - j][l3 - k][d];
                                if (i == l1 && j == l2 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                                f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[i - 1][j][k][d - 1] * tmp) % MOD;
                            }
                    for (int j = 1; j <= l2; j++)
                        for (int k = 0; k <= l3; k++) {
                            int tmp = f[l1][l2 - j][l3 - k][d];
                            if (l1 == 0 && j == l2 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                            f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[0][j - 1][k][d - 1] * tmp) % MOD;
                        }
                    for (int k = 1; k <= l3; k++) {
                        int tmp = f[l1][l2][l3 - k][d];
                        if (l1 == 0 && l2 == 0 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                        f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[0][0][k - 1][d - 1] * tmp) % MOD;
                    }
                }
    if (!D) printf("%d\n", f[L1][L2][L3][D]);
    else printf("%d\n", (f[L1][L2][L3][D] - f[L1][L2][L3][D - 1] + MOD) % MOD);
    return 0;
}
```


---

## 作者：jiangtaizhe001 (赞：4)

[在CSDN上查看](https://blog.csdn.net/jiangtaizhe/article/details/108028837)  
[题目传送门](https://www.luogu.com.cn/problem/P5694)  
## 思路
首先我们发现可以搜索，但是明显会TLE，因为组合数学的结果是以指数倍增长的，结果会很大，明显不行。  
由于不要输出路径，那么考虑DP。   
令 $f_{i,j,k,d}$ 为深度 $d$ ，`{}` $i$ 对，`[]` $j$ 对，`()` $k$ 对的结果。  
我们发现这样很难得出结果。  
我们令 $f_{i,j,k,d}$ 为深度小于等于 $d$ ，`{}` $i$ 对，`[]` $j$ 对，`()` $k$ 对的结果，~~貌似~~可以好一点得到结果。  

我们利用`{}[]()`将字符串进行分割。令`A` `B`，那么就有三种情况：`{A}B` `[A]B` `(A)B`，当然`A` `B`也可能是空串。不难证明这种DP方式是**不重不漏**的。
DP式如下：  
$$f_{i,j,k,d}=\sum^{i-1}_{a=0}\sum^{j}_{b=0}\sum^{k}_{c=0}f_{a,b,c,d-1}\times f_{i-a-1,j-b,k-c,d}\ +\ \sum^{j-1}_{a=0}\sum^{k}_{b=0}f_{i,j-1-a,k-b,d}\times f_{0,a,b,d-1}\ +\ \sum^{k-1}_{a=0}f_{i,j,k-a-1,d}\times f_{0,0,a,d-1}$$
初值： $f_{0,0,0,0}=1$ （空串深度为$0$只有$1$种可能）
## 细节
得出最后的 结果是$f_{l_1,l_2,l_3,d}-f_{l_1,l_2,l_3,d-1}$。
但是，如果这么做，其实是错误的，因为$l_1,l_2,l_3,d$有可能会为$0$，那么我们就可以发现以下结论：  

| $l_1,l_2,l_3$ | $d$ | 结果 | 解释 |
| -- | -- | -- | -- |
| 都为$0$ | $0$ | $1$ | 空串深度为$0$只有$1$种可能 |
| 都为$0$ | 不为$0$ | $0$ | 空串不可能深度为$1$ |
| 不都为$0$ | $0$ | $0$ | 非空串的深度一定大于等于$1$ |
最后注意**精度问题**，要用**unsigned long long**。
## 代码
```cpp
#include<cstdio>
#include<iostream>
#define maxn 12
#define MOD (ll)11380
#define MODx f[i][j][k][d]%=MOD;
using namespace std;
typedef unsigned long long ll;
ll f[maxn][maxn][maxn][39];
int l1,l2,l3,D;
int main(){
	scanf("%d%d%d%d",&l1,&l2,&l3,&D);
	for(int i=0;i<=D;i++)
	    f[0][0][0][i]=1;
	for(int d=1;d<=D;d++)
	for(int i=0;i<=l1;i++)
	for(int j=0;j<=l2;j++)
	for(int k=0;k<=l3;k++){
		if(i==0&&j==0&&k==0) continue;
		for(int a=0;a<i;a++)
		for(int b=0;b<=j;b++)
		for(int c=0;c<=k;c++){
		f[i][j][k][d]=(f[i][j][k][d]+(ll)f[i-a-1][j-b][k-c][d]*f[a][b][c][d-1])%MOD;
		}
		
		for(int a=0;a<j;a++)
		for(int b=0;b<=k;b++){
		f[i][j][k][d]=(f[i][j][k][d]+(ll)f[i][j-a-1][k-b][d]*f[0][a][b][d-1])%MOD;
		}
		
		for(int a=0;a<k;a++){
		f[i][j][k][d]=(f[i][j][k][d]+(ll)f[i][j][k-a-1][d]*f[0][0][a][d-1])%MOD;
		}
	}
	if(D==0){
		if(l1==0&&l2==0&&l3==0) printf("1");
		else printf("0");
	}
	else if(l1==0&&l2==0&&l3==0){
		printf("0");
	}
	else cout<<(f[l1][l2][l3][D]-f[l1][l2][l3][D-1]+MOD)%MOD;
	return 0;
}

```

---

## 作者：封禁用户 (赞：3)

# P5694 [NOI2001] 陨石的秘密 题解
## 思路
dp 状态找的很巧妙：
dp $f(i,j,k,l)$ 表示深度不超过 $i$ ，用了 $j$ 对花括号， $k$ 对中括号， $l$ 对小括号组成的括号序列的数量。
这样只需要枚举四层：
```
枚举深度
	枚举花括号的个数
		枚举中括号的个数
			枚举小括号的个数
```
枚举的顺序也是要注意的，因为 $SS$ 表达式的要求。
接下来考虑转移：

划分依据是将括号序列分为第一部分和第二部分。
由于两个 $SS$ 序列拼接时，深度为 $\max(d1,d2)$ ，所以第二部分的长度可以为 $(1,i)$ 中的任意数，对应到 dp 数组的第一维为 $i$ 。

由于是求的数量，所以是乘法原理，根据第一部分最外层的不同括号进行再次枚举。

比如当第一部分最外层为花括号时，第一部分里面可以是花括号、中括号、小括号，就要进行三层 for 枚举。
```cpp
for(int p=1;p<=j;p++)
    						for(int q=0;q<=k;q++)
    							for(int r=0;r<=l;r++)
    								dp[i][j][k][l]=(dp[i][j][k][l]+dp[i-1][p-1][q][r]*dp[i][j-p][k-q][l-r])%mod;
```
假设第一部分花费了 $p$ 个花括号， $q$ 个中括号， $r$ 个小括号，留给第二部分的就是 $j-p$ 个花括号， $k-q$ 个中括号， $l-r$ 个小括号。由于第一部分的最外层已经确定是花括号了，所以对应转移的深度范围也变成了 $(i,i-1)$ ，对应 dp 的第一维为 $i-1$ 。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll>PLL;
typedef pair<int, int>PII;
typedef pair<double, double>PDD;
#define I_int ll
inline ll read()
{
    ll x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
#define read read()
#define closeSync ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define multiCase int T;cin>>T;for(int t=1;t<=T;t++)
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define repp(i,a,b) for(int i=(a);i<(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define perr(i,a,b) for(int i=(a);i>(b);i--)
ll ksm(ll a, ll b, ll p)
{
    ll res = 1;
    while(b)
    {
        if(b & 1)res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
const int inf = 0x3f3f3f3f;
#define PI acos(-1)
const double eps = 1e-8;
const int maxn = 2e5 + 7,mod=11380;
int dp[31][11][11][11],l1,l2,l3,l4,d;
int main()
{
    l1=read,l2=read,l3=read,d=read;
    for(int i=0;i<=d;i++) dp[i][0][0][0]=1;
    for(int i=1;i<=d;i++)///枚举深度
    	for(int j=0;j<=l1;j++)
    		for(int k=0;k<=l2;k++)
    			for(int l=0;l<=l3;l++){
    				if(j>0){///第一层最外层是{}
    					for(int p=1;p<=j;p++)
    						for(int q=0;q<=k;q++)
    							for(int r=0;r<=l;r++)
    								dp[i][j][k][l]=(dp[i][j][k][l]+dp[i-1][p-1][q][r]*dp[i][j-p][k-q][l-r])%mod;

    				}
    				if(k>0){///第一层最外面是[]
    					for(int q=1;q<=k;q++)
    						for(int r=0;r<=l;r++)
    							dp[i][j][k][l]=(dp[i][j][k][l]+dp[i-1][0][q-1][r]*dp[i][j][k-q][l-r])%mod;
    				}
    				if(l>0){
    					for(int r=1;r<=l;r++)
    						dp[i][j][k][l]=(dp[i][j][k][l]+dp[i-1][0][0][r-1]*dp[i][j][k][l-r])%mod;
    				}
    			}
    int tmp=dp[d][l1][l2][l3];
    if(d) tmp-=dp[d-1][l1][l2][l3];
    if(tmp<0) tmp=(tmp+mod)%mod;
    cout<<tmp;
    return 0;
}
```

---

## 作者：koreyoshi_lemon (赞：3)

本题是一道线性 dp 的题目。

由于数据范围比较小，我们设状态是怎么暴力怎么来，转移也是怎么费劲怎么来。。直接设 $f_{i,j,k,l}$ 表示深度是 $i$，三个括号分别用 $j,k,l$ 个的方案数，转移方程也比较好想，就不赘述了。

但是，如果用 $i$ 一维来表示深度不超过 $i$，转移方程、代码实现都会更容易。

初始状态显然 $f_{i,0,0,0}=1$，因为此时 $i$ 表示“不超过这个深度”

转移方程嘛，偷张图过来。。。

![](https://cdn.luogu.com.cn/upload/image_hosting/t5hdd54n.png)

我这里来解释一下：深度不超过 $D-1$，内部括号数分别为 $i,j,k$ 的方案与深度不超过 $D$，括号数分别为 $l_1-i-1,l_2-j,l_3-k$ 的状态合并所表示的含义确实是 $f_{D,l_1,l_2,l_3}$，且两个状态的方案相互独立，所以统计时应该相乘再求和。由于不能出现小括号包含中括号之类的限制，所以求小括号分割的方案数时，内部中括号大括号数都必须是零。


贴上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e1+7;
const int mod=11380;
int f[N][N][N][N];
int d,l1,l2,l3;
int main(void)
{
	scanf("%d%d%d%d",&l1,&l2,&l3,&d);
	for(int i=0;i<=d;i++)
		f[i][0][0][0]=1;
	for(int i=1;i<=d;i++)
		for(int j=0;j<=l1;j++)
			for(int k=0;k<=l2;k++)
				for(int l=0;l<=l3;l++)	{
					if(j)
						for(int a=1;a<=j;a++)
							for(int b=0;b<=k;b++)
								for(int c=0;c<=l;c++)	{
									f[i][j][k][l]+=f[i-1][a-1][b][c]*f[i][j-a][k-b][l-c];
									f[i][j][k][l]%=mod;
								}
					if(k)
						for(int b=1;b<=k;b++)
							for(int c=0;c<=l;c++)	{
								f[i][j][k][l]+=f[i-1][0][b-1][c]*f[i][j][k-b][l-c];
								f[i][j][k][l]%=mod;
							}
					if(l)
						for(int c=1;c<=l;c++)	{
							f[i][j][k][l]+=f[i-1][0][0][c-1]*f[i][j][k][l-c];
							f[i][j][k][l]%=mod;
						}
				}
	int ans=f[d][l1][l2][l3];
	if(d) ans-=f[d-1][l1][l2][l3];
	printf("%d\n",(ans%mod+mod)%mod);
	return 0;
}
```

如果各位感觉我码风丑陋，不妨看一看 XuHt 大佬的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 11380;
int f[31][11][11][11], L1, L2, L3, D;
int main() {
    cin >> L1 >> L2 >> L3 >> D;
    for (int i = 0; i <= D; i++) f[i][0][0][0] = 1;
    for (int i = 1; i <= D; i++)
        for (int j = 0; j <= L1; j++)
            for (int k = 0; k <= L2; k++)
                for (int l = 0; l <= L3; l++) {
                    if (j > 0) { // 第一段最外层是{}
                        for (int p = 1; p <= j; p++)
                            for (int q = 0; q <= k; q++)
                                for (int r = 0; r <= l; r++)
                                    f[i][j][k][l] = (f[i][j][k][l] + f[i - 1][p - 1][q][r] * f[i][j - p][k - q][l - r]) % mod;
                    }
                    if (k > 0) { // 第一段最外层是[]
                        for (int q = 1; q <= k; q++)
                            for (int r = 0; r <= l; r++)
                                f[i][j][k][l] = (f[i][j][k][l] + f[i - 1][0][q - 1][r] * f[i][j][k - q][l - r]) % mod;
                    }
                    if (l > 0) { // 第一段最外层是()
                        for (int r = 1; r <= l; r++)
                            f[i][j][k][l] = (f[i][j][k][l] + f[i - 1][0][0][r - 1] * f[i][j][k][l - r]) % mod;
                    }
                }
    cout << (f[D][L1][L2][L3] - (D ? f[D - 1][L1][L2][L3] : 0) + mod) % mod << endl;
}
```

---

## 作者：nao_nao (赞：3)

### 题意：

定义一种由  `()` `[]` `{}` 做成的表达式：ss表达式。

其中，空串为ss表达式，ss表达式中括号嵌套 : `[]` 中不能有 `{}` ,`()`中不能有 `[]` 和 `{}`。

给定三种括号的数量，要求深度为 k 的ss表达式共有多少种。

### 题解：

我们设状态：$dp[b1][b2][b3][d]$ 为使用了b1个`{}`，b2个`[]` ，b3个`()`，且深度小于等于d的方案数量。

接下来是重头戏：如何转移状态？

- 我们可以将一个ss表达式外面加上括号，转移到另一个ss表达式；
- 也可以将两个ss表达式拼接起来，转移到另一个ss表达式。

显然这有两种转移规则并不好弄，并且第二条还有致命问题 

我们考虑ss表达式 `{[(())[()][]]}` ，我们发现它只能从 `[(())[()][]]` 转移来，这很显然。

~~也就是`()`转移到`(())`。~~

但是对于ss表达式 `[()()][(())][]` , 我们发现我们既可以将 `[()()]` 接上个 `[(())][]` 得到，也可以从 `[()()][(())]` 接上 `[]` 来得到。

~~也就是`()`到`()()()`和`()()`到`()()()`。~~

考虑将这两种转移方式统一，更重要的是不能出现重复情况。

我们考虑采用： `A` 转移到 `(A)B` 的转移方式。
这样我们从`[()()]`转移到 `[()()][(())][]`，转移方案唯一。

特别的，当B为空串的时候就相当于在ss表达式外面套了一个括号。

确定了转移方式那么就很好想了。
我们枚举A外面的括号种类。
当为大括号的时候则：
```cpp
FOR(b1,a1-1) FOR(b2,a2) FOR(b3,a3){
(dp[a1][a2][a3][d] += dp[b1][b2][b3][d-1]*dp[a1-b1-1][a2-b2][a3-b3][d]%P)%=P;		
}

```
中括号的时候：
```cpp
FOR(b2,a2-1) FOR(b3,a3){
(dp[a1][a2][a3][d] += dp[0][b2][b3][d-1]*dp[a1][a2-1-b2][a3-b3][d]%P)%=P ;				
}
```
小括号的时候
```cpp
FOR(b3,a3-1){
(dp[a1][a2][a3][d] += dp[0][0][b3][d-1]*dp[a1][a2][a3-b3-1][d]%P)%=P;
}
```

当我们枚举A外面的括号种类时，我们要在转移方程里将这种括号减去一个。然后将A的方案数与B的方案数相乘。
转移边界是 $dp[0][0][0][d] = 1$


完整代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define FOR(x,y) for(int x = 0;x <= y;x ++)
#define Pri 
using namespace std;

int read()
{
	int a = 0,x = 1;
	char ch = getchar();
	while(ch > '9' ||ch < '0'){
		if(ch == '-') x = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		a = a*10 + ch-'0';
		ch = getchar();
	}
	return a*x;
}
const int N=100,P=11380;
int l1,l2,l3,D;
ll dp[20][20][20][N];
int main()
{
	l1=  read(),l2 = read(),l3 = read(),D = read();
	FOR(a1,l1) FOR(a2,l2) FOR(a3,l3) FOR(d,D){
		if(a1 == 0 && a2 == 0 && a3 == 0){
			dp[a1][a2][a3][d] = 1;
				continue;
		}
		if(!d) continue;
		FOR(b1,a1-1) FOR(b2,a2) FOR(b3,a3){
					(dp[a1][a2][a3][d] += dp[b1][b2][b3][d-1]*dp[a1-b1-1][a2-b2][a3-b3][d]%P)%=P;		
				}
			
		
		FOR(b2,a2-1) FOR(b3,a3){
				(dp[a1][a2][a3][d] += dp[0][b2][b3][d-1]*dp[a1][a2-1-b2][a3-b3][d]%P)%=P ;				
			}
		
		FOR(b3,a3-1){
			(dp[a1][a2][a3][d] += dp[0][0][b3][d-1]*dp[a1][a2][a3-b3-1][d]%P)%=P;
		}
				
	}
	if(D == 0){
		printf("%lld",dp[l1][l2][l3][D]);
		return 0;
	}
	printf("%lld",(P+dp[l1][l2][l3][D] - dp[l1][l2][l3][D-1])%P);
	return 0;
}
```


---

## 作者：bingxin (赞：2)

### 题意

给定 $L1$ 个 `{}`，$L2$ 个 `[]`，$L3$ 个 `()`，让你使用它们组成一些括号序列，规定：

- 在纵向上，大、中、小括号只能依次嵌套，如 `{[()]}`；
- 在横向上，小的括号序列能任意拼接成更大的括号序列，如 `[](){}`；
- 一个括号序列的深度定义为纵向嵌套中嵌套的最大层数。

问合法的深度为 $D$ 的括号序列有多少种？

### 解法：计数 DP

根据题意，我们思考怎么把原问题划分成规模更小的**子问题**，其中，有 `{}`、`[]`、`()` 和 `+`（连接）四种方式，我们可以从这里入手。同时，注意到横向上的拼接点可能有多种，需要避免重复计数。

我们这里用一种计数 DP 常用的处理方法，划分子问题时，将一个大的问题只划分为构成“第一段”的部分和剩下的部分，作为子问题，放在这题我们就设想对于 `[S]{[SS](SSS)}`，我们选取 `[S]` 作为它的第一段序列，其中不能有任何其他在横向上的拼接。这样，我们保证了每个横向拼接只在第一个位置处断开，避免重复。

划分完之后，我们考虑 DP **状态**的设计，在构造序列的过程中，有几个量是需要考虑的：当前的**深度**，当前大、中、小括号各自的**数量**。我们可以有一个初步想法就是设 $f_{p, i, j, k}$ 表示深度为 $p$ 时，分别使用了 $i, j, k$ 个不同括号时的方案数，在转移时我们考虑枚举第一段的外层括号以及第一段的深度、两端各自的括号数即可。

这样做未免有些麻烦，我们考虑发现，无论我们处于转移时的哪个阶段，都需要考虑深度一直从 $0$ 到 $p$ 的所有情况，每一个都需要来这样一个 for。那我们就可以简化一下状态的定义，重新设为 $f_{p, i, j, k}$ 表示深度 **不超过** $p$ 时，分别使用了 $i, j, k$ 个不同括号时的方案数。这样我们在计算时，加上去就可以了；转移时，也不用 for 循环枚举，都很方便。

现在 DP 状态的转移即为：

1. 考虑第一段的最外层括号
2. 枚举第一段的括号构成

如果最外层是大括号，那么这三种括号都是可以的，我们枚举第一段的括号，有转移方程：
$$f_{p, i, j, k} = \sum_{u = 1}^i \sum_{v = 0}^j \sum_{w = 0}^k f_{p - 1, u - 1, v, w} \times f_{p, i - u, j - v, k - w}$$
如果最外层是中括号，那么相应的，第一段中就不能有大括号，少一个 $\sum$，有转移方程：
$$f_{p, i, j, k} = \sum_{v = 1}^j \sum_{w = 0}^k f_{p - 1, 0, v - 1, w} \times f_{p, i, j - v, k - w}$$
如果最外层是小括号……请读者自行推导完成。

初值：$f_{i, 0, 0, 0} = 1$，目标：$f_{D, L1, L2, L3} - f_{D - 1, L1, L2, L3}$，复杂度：$O(DL^6)$。

如果感觉完全理解了，本题转移方程较长，建议自己在纸上自行独立推导一遍；如果没有完全理解，可以重新看一遍题，同时这里附上代码，帮助辅助理解，Code：

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MOD = 11380;
int L1, L2, L3, D;
int f[35][15][15][15];
signed main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    cin >> L1 >> L2 >> L3 >> D;
    for (int i = 0; i <= D; i++)
        f[i][0][0][0] = 1;
    for (int p = 1; p <= D; p++)
        for (int i = 0; i <= L1; i++)
            for (int j = 0; j <= L2; j++)
                for (int k = 0; k <= L3; k++)
                {
                    if (i) // 最外层括号是 {}
                        for (int u = 1; u <= i; u++)
                            for (int v = 0; v <= j; v++)
                                for (int w = 0; w <= k; w++)
                                    (f[p][i][j][k] += f[p - 1][u - 1][v][w] * f[p][i - u][j - v][k - w] % MOD) %= MOD;
                    if (j) // 最外层括号是 []
                        for (int v = 1; v <= j; v++)
                            for (int w = 0; w <= k; w++)
                                (f[p][i][j][k] += f[p - 1][0][v - 1][w] * f[p][i][j - v][k - w] % MOD) %= MOD;
                    if (k) // 最外层括号是 ()
                        for (int w = 1; w <= k; w++)
                            (f[p][i][j][k] += f[p - 1][0][0][w - 1] * f[p][i][j][k - w]) %= MOD;
                }
    // Tips: 如果深度为 0，就不需要再减一遍了，需要一个小特判
    if (D)
        cout << (f[D][L1][L2][L3] - f[D - 1][L1][L2][L3] + MOD) % MOD;
    else
        cout << f[D][L1][L2][L3];
    return 0;
}
```


---

## 作者：Mars_Dingdang (赞：1)

一道有趣的高维计数 DP。同步发表于 [博客园](https://www.cnblogs.com/Mars-LG/p/P5694.html)。

## 题目大意
定义合法的括号串为：
1. 仅由 `()`, `[]`, `{}` 组成；
2. 空串是合法括号串；
3. $A$ 是合法括号串且不含 `[]`, `{}`，则 $(A)$ 是合法括号串；
4. $A$ 是合法括号串且不含 `{}`，则 $[A]$ 是合法括号串；
5. $A$ 是合法括号串，则 $\{A\}$ 是合法括号串；
6. $A,B$ 均为合法括号串，则 $AB$ 也是合法括号串。

定义一个括号串的深度为最大的括号嵌套数，求使用了 $L_1,L_2,L_3$ 对 `{}`, `[]`, `()` 且深度为 $D$ 的合法括号串数量，答案对 $11380$ 取模。

## 大体思路
由于 $L_1\sim L_3,D$ 均不大，直接使用高维 DP，状态定义照抄题面。故定义 $F(d,i,j,k)$ 表示使用了 $i,j,k$ 对大、中、小括号且深度为 $d$ 的数量。

状态转移自然是将当前串分割成两个串 $TS$，使得 $S$ 的深度为 $d$，用某一种括号去套一个合法的串 $T$。由于嵌套一层后深度 $\le d$，要求这个合法串 $T$ 的深度不大于 $d-1$。

这时，我们发现需要枚举所有 $\le d-1$ 的深度，太过麻烦，因此对 $F$ 做前缀和处理，即将状态定义改为 $F(d,i,j,k)$ 表示使用了 $i,j,k$ 对大、中、小括号且深度 $\le d$ 的数量。

对当前串 `TS`，可以通过一个括号嵌套变成 `(T)S`，`[T]S`，`{T}S`。我们可以通过枚举 $T$ 中包含多少 `{}, [], ()`，得到状态转移方程：

$$F(d,i,j,k)=
\sum_{a=0}^{i-1}\sum_{b=0}^j\sum_{c=0}^k F(d-1,a,b,c)\times F(d,i-1-a,j-b,k-c)$$

$$+\sum_{b=0}^{j-1}\sum_{c=0}^k F(d-1,0,b,c)\times F(d,i,j-1-b,k-c)$$

$$+\sum_{c=0}^{k-1} F(d-1,0,0,c) \times F(d,i,j,k-1-c)
$$

特殊地，对于 $i=j=k=0$ 时，$F(d,0,0,0)=1$。

输出时，通过前缀和做差即可，需要特判 $D=0$ 以及 $L_1=L_2 = L_3 = 0$ 的情况。时间复杂度 $O(DL^6)$。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const ll mod = 11380;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll L1, L2, L3, D, f[35][12][12][12];
int main () {
	read(L1); read(L2); read(L3); read(D);
	f[0][0][0][0] = 1;
	rep(d, 1, D) {
		f[d][0][0][0] = 1;
		rep(i, 0, L1) rep(j, 0, L2) rep(k, 0, L3) {
			if(!i && !j && !k) continue;
			rep(a, 0, i - 1) rep(b, 0, j) rep(c, 0, k)
				(f[d][i][j][k] += f[d - 1][a][b][c] * f[d][i-1 - a][j - b][k - c]) %= mod;
			rep(b, 0, j - 1) rep(c, 0, k)
				(f[d][i][j][k] += f[d - 1][0][b][c] * f[d][i][j-1 - b][k - c]) %= mod;
			rep(c, 0, k - 1)
				(f[d][i][j][k] += f[d - 1][0][0][c] * f[d][i][j][k-1 - c]) %= mod;
		}
	}
	if(!D) writeln(((!L1 && !L2 && !L3) ? 1 : 0));
	else if(!L1 && !L2 && !L3) writeln(0);
	else writeln((f[D][L1][L2][L3] - f[D - 1][L1][L2][L3] + mod) % mod);
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：1)

根据标签来看，这是一道动态规划的题目。

对于给出的这些变量，设 $f[i][j][k][d]$ 表示串中有 $i$ 个( )、$j$ 个[ ]、$k$ 个{ }、深度不大于 $d$ 时的方案总数。

由定义可知，两个 SS 串拼在一起也是一个 SS 串，我们可以借此来进行动态规划。但是，若一个 SS 串为 ABC，在计算时就会将 $AB+C$ 和 $A+BC$ 作为两个方案计算在内，但实际上是同一种方案。

因此，为了避免重复，可以在动态规划时令一个串强制在最外面加上一个括号(就是满足要求的最小括号)。

所以，首先枚举一个串中有的每种括号的数量，然后把所有括号分成两部分，对答案的贡献即为分成的两个串的乘积。

不过要注意取模。

那么输出的答案是什么呢？？？

显而易见，如果 $d$ 的值为 $0$，那么我们只用输出
```
f[l1][l2][l3][d]
```
深度都是 $0$ 了，那肯定输出这个呀！！


反之，就输出
```
(f[l1][l2][l3][d]-f[l1][l2][l3][d-1]+mod)%mod
```
注意不要写成
```
(f[l1][l2][l3][d]-f[l1][l2][l3][d-1])%mod
```
这两个式子不一定相等（虽然我也算不出来为什么，只不过是猜对的）。。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
const int mod=11380;
int l1,l2,l3,d;
int f[15][15][15][35];
int main()
{
    cin>>l1>>l2>>l3>>d;
    f[0][0][0][0]=1;
    for(int i=0;i<=l1;i++)
    {
    	for(int j=0;j<=l2;j++)
    	{
    		for(int k=0;k<=l3;k++)
    		{
    			for(int l=1;l<=d;l++)
    			{
    				if(i!=0||j!=0||k!=0)
    				{
    					int F=0;
    					for(int a=0;a<k;a++)
    					{
    						F=(F+f[i][j][k-a-1][l]*f[0][0][a][l-1])%mod;
						}
						for(int a=0;a<j;a++)
    					{
    						for(int b=0;b<=k;b++)
    						{
    							F=(F+f[i][j-a-1][k-b][l]*f[0][a][b][l-1])%mod;
							}
						}
						for(int a=0;a<i;a++)
						{
							for(int b=0;b<=j;b++)
							{
								for(int c=0;c<=k;c++)
								{
									F=(F+f[i-a-1][j-b][k-c][l]*f[a][b][c][l-1])%mod;
								}
							}
						}
						f[i][j][k][l]=F;
					}
					else
					{
						f[i][j][k][l]=1;
					}
				}
			}
		}
	}
	if(d>0)
	{
		cout<<(f[l1][l2][l3][d]-f[l1][l2][l3][d-1]+mod)%mod;
	}
	else
	{
		cout<<f[l1][l2][l3][d];
	}
    return 0;
}
```

我是一个爱写题解的初一党蒟蒻。。

---

## 作者：WB_TS_欧寒 (赞：1)

## 1. 思路：
-----------------------------------------------
### (1) 题意：  

   给定()[]{}的数量分别为l1，l2，l3(0<=l1，l2，l3<=10)，规定()不能套在[]和{}的外面，[]不能套在{}的外面，即{} [] ()优先级递减，现在想最大组成嵌套深度为d(0<=d<=30)的串，问一共有多少种方法。

### (2) 题解:    
         
  首先很容易想到记忆化dfs，dp[a][b][c][d]表示{}[]()分别有a b c个形成最大嵌套深度为d的方法数，然后找到子状态，但是麻烦的是d是多个子问题求max得到的，这样在dfs的过程中没办法控制哪一个是最大的，看了下提示瞬间石化。      
  
   dp[a][b][c][d]表示{}[]()分别有a b c个形成最大嵌套深度小于等于d的方法数，这样能得到子状态，由于优先级的问题改变遍历{}[]()的顺序即可，枚举当前在左边套在最外面的是{}[]或()，最后得到答案为dp[a][b][c][d] – dp[a][b][c][d-1]（d == 0时候答案为dp[a][b][c][d]）。因为dfs时分开的两个串是独立的，所以不会有重复计数。

### (3) PS：
	1. 网上有一个想法说的很好：把括号的嵌套看成是一棵树就简单些，这棵树的最大深度为 D，()节点下面不能有{}[]节点，[]节点下面不能有{}节点，然后从上往下依次摆放节点。
2. 思路和代码实现参考了这篇博客：[⭕](https://blog.csdn.net/Flying_Stones_Sure/article/details/7954114)

# 2. 代码：
```c
#include <bits/stdc++.h>
using namespace std;
const int mod = 11380;
int dp[11][11][11][31];
bool v[11][11][11][31];
int dfs(int l1, int l2, int l3, int deep)
{
	if (l1 == 0 && l2 == 0 && l3 == 0)
	{
		v[l1][l2][l3][deep] = 1;
		return dp[l1][l2][l3][deep] = 1;
	}
	if (deep == 0)
	{
		v[l1][l2][l3][deep] = 1;
		return dp[l1][l2][l3][deep]  = 0;
	}
	if (v[l1][l2][l3][deep])
		return dp[l1][l2][l3][deep];
	int ans = 0;
	for (int i = 0; i <= l3; i++)
	{
		if (i)
		{
			ans = (ans + dfs(0 , 0, i - 1, deep - 1) * dfs(l1, l2, l3 - i,deep)) % mod;
		}
		for (int j = 0 ; j <= l2; j++)
		{
			if (j)
			{
				ans = (ans + dfs(0, j - 1, i, deep - 1) * dfs(l1, l2 - j,l3 - i, deep)) % mod;
			}
			for (int k = 1; k <= l1; k++)
			{
				ans = (ans + dfs(k - 1, j, i, deep - 1) * dfs(l1 - k, l2 - j,l3 - i, deep)) % mod;
			}
		}
	}
	v[l1][l2][l3][deep] = 1;
	return dp[l1][l2][l3][deep] = ans;
}
int main()
{
	int n, m, d, t;
	while(~scanf("%d%d%d%d", &n, &m, &t, &d))
	{
		dfs(n, m, t, d);
		if(d) dfs(n, m ,t, d - 1);
		if(d) printf("%d\n", (dp[n][m][t][d] - dp[n][m][t][d - 1] + mod ) %mod);
		else printf("%d\n", dp[n][m][t][d]);
	}
}
```


---

## 作者：TH911 (赞：0)

> [题目传送门](https://www.luogu.com.cn/problem/P5694)

# 题意分析

先说一个坑：当 $l_1=l_2=l_3=d=0$ 时不是绝对无解。

***

我们考虑 $\large f_{l_1,l_2,l_3,d}$ 表示所有含有 $l_1$ 对 `{}`，$l_2$ 对 `[]`，$l_3$ 对 `()` 的深度**小于等于** $d$ 的 SS 串的个数。

关于为什么是“小于等于”，我们考虑这样一件事。

对于 SS 串 $S=AB$，若 $A$ 的深度 $D(A)=d$，那么 $B$ 的深度 $D(B)$ 只要满足 $D(B)\leq d$，都有 $D(S)=d$。又考虑到形如 $(A),[A],\{A\}$ 的构造方式构造出来的 SS 串都可以视为一个 SS 串拼接了一个**空串**。因此统计答案时，我们可以通过统计拼接构造的 SS 串的答案来统计所有答案（见下文）。那么对于 $D(A)=d$，$D(B)$ 的真实取值并不重要，因此可以统计深度小于等于 $d$ 的所有方案方便转移。

我们可以只考虑两个 SS 串相接的情况。因为如果考虑三个 SS 串 $S=ABC$，完全可以有 $T=BC,S=AT$。

那么我们可以枚举拼接到后面的 SS 串的大、中、小括号的个数 $i,j,k$。

当 SS 串形如 $\{A\}B$ 时，则有：

$$
\large f_{l_1,l_2,l_3,d}\leftarrow f_{l_1,l_2,l_3,d}+f_{l_1-i-1,l_2-j,l_3-k}f_{i,j,k,d-1}
$$

同理，形如 $[A]B$ 时有：

$$
\large f_{l_1,l_2,l_3,d}\leftarrow f_{l_1,l_2,l_3,d}+f_{0,l_2-j-1,l_3-k}f_{0,j,k,d-1}
$$

形如 $(A)B$ 时有：

$$
\large f_{l_1,l_2,l_3,d}\leftarrow f_{l_1,l_2,l_3,d}+f_{0,0,l_3-k-1}f_{0,0,k,d-1}
$$

最终答案即 $\large f_{l_1,l_2,l_3,d}-f_{l_1,l_2,l_3,d-1}$。

## 边界情况

$$
f_{0,0,0,d}=1
$$

这仅仅是因为上文递推式中会取到，因此取 $1$ 不影响答案。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int L=10,D=30,mod=11380;
int l[4],dd;
int f[L+1][L+1][L+1][D+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d %d",l+1,l+2,l+3,&dd);
	if(!l[1]&&!l[2]&&!l[3]&&dd){
		printf("0\n");
		return 0;
	}
	for(int d=0;d<=dd;d++){
		f[0][0][0][d]=1;
	}
	for(int l1=0;l1<=l[1];l1++){
		for(int l2=0;l2<=l[2];l2++){
			for(int l3=0;l3<=l[3];l3++){
				for(int d=1;d<=dd;d++){
					
					for(int i=0;i<l1;i++){
						for(int j=0;j<=l2;j++){
							for(int k=0;k<=l3;k++){	
								f[l1][l2][l3][d] = ( f[l1][l2][l3][d] + f[l1-i-1][l2-j][l3-k][d] * f[i][j][k][d-1] ) % mod;
							}
						}
					}
					
					for(int j=0;j<l2;j++){
						for(int k=0;k<=l3;k++){	
							f[l1][l2][l3][d] = ( f[l1][l2][l3][d] + f[l1][l2-j-1][l3-k][d] * f[0][j][k][d-1] ) % mod;
						}
					}
					
					for(int k=0;k<l3;k++){	
						f[l1][l2][l3][d] = ( f[l1][l2][l3][d] + f[l1][l2][l3-k-1][d] * f[0][0][k][d-1] ) % mod;
					}
				}
			}
		}
	}
	printf("%d\n",(f[l[1]][l[2]][l[3]][dd] - f[l[1]][l[2]][l[3]][dd-1] + mod ) % mod);
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：ljx20130810 (赞：0)

学校模拟赛的时候想出来的非常抽象做法。~~第 3 个测试点学校的评测机跑了 1.000 秒~~

定义 $dp[a][b][c][d][e]$ 为深度为 $d$，含有 $a$ 对 `{}`，$b$ 对 `[]`，$c$ 对 `()` 的 SS 串的个数。其中，

* $e=0$ 表示无额外限制；
* $e=1$ 表示不能出现 `{}`，即 $a=0$；
* $e=2$ 表示只能出现 `()`，即 $a=b=0$。

状态转移：

对于每个状态，考虑找到**最右边的一个括号与和它匹配的那个括号**之间的一个 SS 串。

枚举这个 SS 串中出现三种括号的对数，然后考虑最右边的一个括号的类型。

* 如果是 `}`，说明被它围起来的一个 SS 串中没有限制，即 $e=0$；
* 如果是 `]`，说明被它围起来的一个 SS 串中不能出现 `{}`，即 $e=1$；
* 如果是 `)`，说明被它围起来的一个 SS 串中只能出现 `()`，即 $e=2$。

然后考虑 SS 串的深度。

* 如果这个 SS 串深度小于 $D$，则去掉这个 SS 串后，剩下的串深度必然等于 $D$。
* 否则，剩下的串深度可以是 $0$ 到 $D$ 中的任何数。

使用前缀和统计深度在 $0$ 到 $D$ 之间时方案的总和即可。（`1.09s -> 508ms`）

代码（含注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 11380
int dp[11][11][11][31][3], ds[11][11][11][31][3];
int main(){//赛时的文件IO
	//freopen("secret.in", "r", stdin);
	//freopen("secret.out", "w", stdout);
	int l1, l2, l3, d;
	cin >> l1 >> l2 >> l3 >> d;//初始化
	dp[0][0][0][0][0] = dp[0][0][0][0][1] = dp[0][0][0][0][2] = 1;
	for(int i = 0; i <= d; i++)ds[0][0][0][i][0] = ds[0][0][0][i][1] = ds[0][0][0][i][2] = 1;
	for(int i = 0; i <= l1; i++){//枚举各种东西
		for(int j = 0; j <= l2; j++){
			for(int k = 0; k <= l3; k++){
				if(i == 0 && j == 0 && k == 0)continue;
				for(int p = 1; p < 3; p++){
					for(int D = 1; D <= d; D++){
						for(int i2 = 0; i2 <= i; i2++){
							for(int j2 = 0; j2 <= j; j2++){
								for(int k2 = 0; k2 <= k; k2++){
									if(i2 == 0 && j2 == 0 && k2 == 0)continue;
									for(int g = 2; g >= p; g--){//判定各种括号的数量是否满足限制条件
										if(g == 0 && i2 == 0)continue;
										if(g == 1 && (i2 > 0 || j2 == 0))continue;
										if(g == 2 && (i2 > 0 || j2 > 0 || k2 == 0))continue;
										if(g == 0){
											for(int x1 = 1; x1 <= D; x1++){//根据乘法原理，总方案数=前面的方案数*最后一个部分的方案数
												if(x1 < D)dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2 - 1][j2][k2][x1 - 1]/*由于外圈已经用掉了一对括号所以去掉1*/[g] * dp[i - i2][j - j2][k - k2][D][p]) % mod;
												else dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2 - 1][j2][k2][x1 - 1][g] * ds[i - i2][j - j2][k - k2][D][p]) % mod;
											}
										}else if(g == 1){
											for(int x1 = 1; x1 <= D; x1++){
												if(x1 < D)dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2][j2 - 1][k2][x1 - 1][g] * dp[i - i2][j - j2][k - k2][D][p]) % mod;
												else dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2][j2 - 1][k2][x1 - 1][g] * ds[i - i2][j - j2][k - k2][D][p]) % mod;
											}
										}else{
											for(int x1 = 1; x1 <= D; x1++){
												if(x1 < D)dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2][j2][k2 - 1][x1 - 1][g] * dp[i - i2][j - j2][k - k2][D][p]) % mod;
												else dp[i][j][k][D][p] = (dp[i][j][k][D][p] + dp[i2][j2][k2 - 1][x1 - 1][g] * ds[i - i2][j - j2][k - k2][D][p]) % mod;
											}
										}
									}
								}
							}
						}//统计前缀和
						ds[i][j][k][D][p] = (ds[i][j][k][D - 1][p] + dp[i][j][k][d][p]) % mod;
					}
				}
			}
		}
	}
	cout << dp[l1][l2][l3][d][0];
	return 0;
}
````

别乱抄。

---

## 作者：_zuoqingyuan (赞：0)

最开始以为自己写的假做法，后来改了一下，发现也可以过。

upd：加了一些上界优化，终于不是最劣解了。

# 思路分析

显然可以列出很基础的 dp。

设 $f_{i,j,k,l}$ 表示用了 $i$ 对大括号，$j$ 对中括号，$k$ 对小括号，深度为 $l$ 的 SS 表达式的方案数。

由题意可得：

$$f_{0,0,k,l}\gets f_{0,0,k,l}+f_{0,0,k-1,l-1}$$

$$f_{0,j,k,l}\gets f_{0,j,k,l}+f_{0,j-1,k,l-1}$$

$$f_{i,j,k,l}\gets f_{i,j,k,l}+f_{i-1,j,k,l-1}$$

这几个转移都很简单，就是最外层套了一层括号的情况。

$$f_{i,j,k,l}\gets f_{i,j,k,l}+\sum_{a\le i,b\le j,c\le k,\max(t,d)=l} f_{a,b,c,d}\times f_{i-a,j-b,k-c,t}$$

这个转移略复杂，统计的是形如 $AB$（$A,B$ 均为 SS 表达式）的 SS 表达式的方案数。我们枚举 $A$ 是什么，$B$ 是什么，然后用乘法原理乘起来，注意特殊处理 $t=d=l$ 的情况。

这个 dp 实际上是错的，为什么？观察这样一个方案：

`()[()]{()}`

我们期望的是这个方案可以按照 $A:$`()`，$B:$`[()]{()}` 这样的形式统计一次，但实际上, $A:$`()[()]`，$B:$`{()}` 也会把这种方案统计一次，也就是说，我们可能会将同一方案统计多次。

我们对 dp 的状态设计略作修改。

定义 S 表达式为形如 $(A),[A],\{A\}$ 的字符串，其中 $A$ 是 SS 表达式。

在保持上文 $f$ 定义的基础下，定义 $g_{i,j,k,l}$ 为用了 $i$ 对大括号，$j$ 对中括号，$k$ 对小括号，深度为 $l$ 的 S 表达式的方案数。

显然可以得到

$$g_{i,j,k,l}\gets g_{i,j,k,l}+f_{i-1,j,k,l-1}$$

剩下两个同理可得。我们将第四个转移方程修改：

$$f_{i,j,k,l}\gets f_{i,j,k,l}+\sum_{a\le i,b\le j,c\le k,\max(t,d)=l} g_{a,b,c,d}\times f_{i-a,j-b,k-c,t}$$

还是上文的例子，此时的 $A:$`()[()]`，$B:$`{()}` 就并非一种合法方案，因为此时 $A$ 并非一个 S 表达式。这样的话对于任意一种方案，都有唯一的划分方法，自然也不会重复统计。

# Code

时间复杂度大概是 $O(L^6D^2)$，看上去很大但是跑不满，通过本题还是没问题的，可能会有前缀和优化的方法，但是我懒得写，这里就提供一份最基础的暴力。


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int mod=11380;
int l1,l2,l3,mx,f[11][11][11][31],g[11][11][11][31];
int main(){
	cin>>l1>>l2>>l3>>mx;
	f[0][0][0][0]=1;
	for(int a=0;a<=l1;a++){
		for(int b=0;b<=l2;b++){
			for(int c=0;c<=l3;c++){
				if(!a&&!b&&!c)continue;
				for(int d=1;d<=a+b+c&&d<=mx;d++){
					if(a)g[a][b][c][d]=f[a-1][b][c][d-1];
					else if(b)g[a][b][c][d]=f[a][b-1][c][d-1];
					else if(c)g[a][b][c][d]=f[a][b][c-1][d-1];
					g[a][b][c][d]%=mod;
                    f[a][b][c][d]=g[a][b][c][d];
					for(int i=0;i<=a;i++){
						for(int j=0;j<=b;j++){
							for(int k=0;k<=c;k++){
								if(i==0&&j==0&&k==0)continue;
								if(i==a&&j==b&&k==c)continue;
								for(int l=1;l<=i+j+k&&l<d;l++){
									f[a][b][c][d]+=g[i][j][k][l]*f[a-i][b-j][c-k][d];
									f[a][b][c][d]+=g[i][j][k][d]*f[a-i][b-j][c-k][l];//这里为了卡常去除了一些取模。
								}
                                f[a][b][c][d]%=mod;
								f[a][b][c][d]+=g[i][j][k][d]*f[a-i][b-j][c-k][d]%mod;
								f[a][b][c][d]%=mod;
							}
						}
					}
				}
			}
		}
	}
	cout<<f[l1][l2][l3][mx]%mod<<endl;
	return 0;
}
```


如有错误，请指出。

---

## 作者：block_in_mc (赞：0)

## 题目大意

定义 SS 表达式满足如下特征：

1. 一个空串是 SS 表达式，且其深度为 $0$；
2. 若 $A$ 是 SS 表达式，且 $A$ 中不含 $\texttt\{$, $\texttt\}$, $\texttt[$, $\texttt]$，则 $\texttt(A\texttt)$ 是 SS 表达式，且其深度为 $A$ 的深度加 $1$；
3. 若 $A$ 是 SS 表达式，且 $A$ 中不含 $\texttt\{$, $\texttt\}$，则 $\texttt[A\texttt]$ 是 SS 表达式，且其深度为 $A$ 的深度加 $1$；
4. 若 $A$ 是 SS 表达式，则 $\texttt\{A\texttt\}$ 是 SS 表达式，且其深度为 $A$ 的深度加 $1$；
5. 若 $A$ 和 $B$ 都是 SS 表达式，则 $AB$ 也是 SS 表达式，且其深度为 $A$ 的深度与 $B$ 的深度中的较大值。

求含有 $L_1$ 对 $\texttt\{\texttt\}$，$L_2$ 对 $\texttt[\texttt]$，$L_3$ 对 $\texttt(\texttt)$，且深度为 $D$ 的 SS 表达式的个数，对 $11380$ 取模。

## 解题思路

定义 $dp_{l,i,j,k}$ 为深度**不大于** $l$，且含有 $i$ 对 $\texttt\{\texttt\}$，$j$ 对 $\texttt[\texttt]$，$k$ 对 $\texttt(\texttt)$ 的 SS 表达式的个数。初始状态为 $dp_{i,0,0,0}=1$，处理了由规则 1 生成的 SS 表达式。

考虑状态如何转移。对于由规则 2 / 3 / 4 生成的 SS 表达式，容易记录；但对于规则 5，我们不能枚举 $A$ 和 $B$，否则形如 $\texttt{[]()()}$ 的 SS 表达式会由 $\texttt{[]}+\texttt{()()}$ 和 $\texttt{[]()}+\texttt{()}$ 转移而来，造成重复枚举。因此，我们需要找到一种分解方法，使得一个 SS 表达式的分解方式唯一，且能枚举到每一个 SS 表达式。

不难证明，对于每一个非空的 SS 表达式，都可以唯一地表示为 $\texttt\{A\texttt\}B$，$\texttt[A\texttt]B$ 或 $\texttt(A\texttt)B$ 中的一个，其中 $A$，$B$ 可以是空的 SS 表达式。这样覆盖了由规则 2 / 3 / 4 / 5 生成的 SS 表达式，且不会造成重复枚举。

分别考虑每种情况的状态转移方程，若现在正在计算 $dp_{l,i,j,k}$：

- 若 $i\not=0$，则 SS 表达式可以表示为 $\texttt\{A\texttt\}B$ 的形式，枚举 $A$ 含有的 $\texttt\{\texttt\}$、$\texttt[\texttt]$、$\texttt(\texttt)$ 的数量 $i_2,j_2,k_2$（$i_2<i$，$j_2\le j$，$k_2\le k$），则 $A$ 有 $dp_{l-1,i_2,j_2,k_2}$ 种可能，$B$ 有 $dp_{l,i-i_2-1,j-j_2,k-k_2}$ 种可能，利用乘法原理计算即可；
- 若 $j\not=0$，则 SS 表达式可以表示为 $\texttt[A\texttt]B$ 的形式，由于 $A$ 中不能含有 $\texttt\{\texttt\}$，枚举 $A$ 含有的 $\texttt[\texttt]$、$\texttt(\texttt)$ 的数量 $j_2,k_2$（$j_2<j$，$k_2\le k$），则 $A$ 有 $dp_{l-1,0,j_2,k_2}$ 种可能，$B$ 有 $dp_{l,i,j-j_2-1,k-k_2}$ 种可能，利用乘法原理计算即可；
- 若 $k\not=0$，则 SS 表达式可以表示为 $\texttt(A\texttt)B$ 的形式，由于 $A$ 中不能含有 $\texttt[\texttt]$ 和 $\texttt\{\texttt\}$，枚举 $A$ 中含有的 $\texttt(\texttt)$ 的数量 $k_2$（$k_2<k$），则 $A$ 有 $dp_{l-1,0,0,k_2}$ 种可能，$B$ 有 $dp_{l,i,j,k-k_2-1}$ 种可能，利用乘法原理计算即可。

对于枚举的每一种情况，将其结果相加即可。答案为 $dp_{D,L_1,L_2,L_3}-dp_{D-1,L_1,L_2,L_3}$。

需要注意的是：

- 特判 $D=0$ 的情况；
- $dp_{D,L_1,L_2,L_3}-dp_{D-1,L_1,L_2,L_3}$ 可能小于 $0$。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll P = 11380;
ll a, b, c, d, dp[32][12][12][12];
int main() {
    cin >> a >> b >> c >> d;
    if (d == 0) {
        printf("%d", a == 0 && b == 0 && c == 0);
        return 0;
    }
    for (int i = 0; i <= d; i++)
        dp[i][0][0][0] = 1;
    for (int l = 1; l <= d; l++) {
        for (int i = 0; i <= a; i++) {
            for (int j = 0; j <= b; j++) {
                for (int k = 0; k <= c; k++) {
                    if (i != 0)
                        for (int ii = 0; ii <= i - 1; ii++)
                            for (int jj = 0; jj <= j; jj++)
                                for (int kk = 0; kk <= k; kk++)
                                    dp[l][i][j][k] = (dp[l][i][j][k] + dp[l - 1][ii][jj][kk] * dp[l][i - ii - 1][j - jj][k - kk]) % P;
                    if (j != 0)
                        for (int jj = 0; jj <= j - 1; jj++)
                            for (int kk = 0; kk <= k; kk++)
                                dp[l][i][j][k] = (dp[l][i][j][k] + dp[l - 1][0][jj][kk] * dp[l][i][j - jj - 1][k - kk]) % P;
                    if (k != 0)
                        for (int kk = 0; kk <= k - 1; kk++)
                            dp[l][i][j][k] = (dp[l][i][j][k] + dp[l - 1][0][0][kk] * dp[l][i][j][k - kk - 1]) % P;
                }
            }
        }
    }
    printf("%lld", ((dp[d][a][b][c] - dp[d - 1][a][b][c]) % P + P) % P);
    return 0;
}
```

---

## 作者：Isprime (赞：0)

 算法竞赛进阶指南上推荐的 dp 练习题，确实是个好题。

思路有借鉴@九九九九 神仙的题解。

设 $f_{i,j,k,l}$ 表示深度为 $i$，有$j$ 个 `{}`， $k$ 个 `[]` 和 $l$ 个 `()` 时的个数。

我们可以发现串可以拆成 `(A)` 或 `[A]` 或 `{A}` 或 `AB` 的形式，但这样似乎很难转移，因为枚举 `AB` 是个很麻烦的东西。

但是我们可以换个角度看看。 `(A)` （包括其他两种）不就是 `(A)B` 的形式的 $B$ 为空串的特殊情况吗！`AB` 中把 $A$ 再拆开（$AB$ 中 $A,B$ 一定都不是空串否则这种拆法没有意义）不就是 `(C)B` （或是其他两种括号）吗！

所以其实每个字符串都可以且仅可以拆成`(A)B` （`[A]B`,`{A}B`）的形式，这样就方便转移了。

考虑转移方程，以 `(A)B` 为例，它的个数其实就是 $A$ 的个数乘上 $B$ 的个数（组合数学入门题？）所以枚举这两个玩意儿乘一下就好了，其他的同理。

而对于三种括号都没有的显然是初始化为 $1$。

即 $f_{i,j,k,l}=1(j=0,k=0,l=0),f_{i,j,k,l}=\sum^{l-1}_{x=0}f_{i,0,0,x}*f_{i,j,k,l-1-x}+\sum^{k-1}_{x=0}\sum^{l}_{y=0}f_{i,0,x,y}*f_{i,j,k-1-x,l-y}+\sum^{j-1}_{x=0}\sum^{k}_{y=0}\sum^{l}_{z=0}f_{i,x,y,z}*f_{i,j-1-x,k-y,l-z}$。

方程还是好理解的，因为括号的数量不变，注意拆分的时候用了哪种括号这种括号的数量就要减一。

@九九九九 没放代码，我放一个吧

```cpp
#include <cstdio>
using namespace std;
inline int read() {
	int res=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0'; ch=getchar();}
	return res*f;
}
const int mod=11380;
int l1,l2,l3,d;
int f[31][11][11][11];
signed main() {
	l1=read(); l2=read(); l3=read(); d=read();
	f[0][0][0][0]=1;
	for(register int i=1;i<=d;++i) 
		for(register int j=0;j<=l1;++j)
			for(register int k=0;k<=l2;++k)
				for(register int l=0;l<=l3;++l) {
					if((j==0&&k==0)&&l==0) f[i][j][k][l]=1;
					for(register int x=0;x<l;++x) 
						f[i][j][k][l]=(f[i][j][k][l]+f[i-1][0][0][x]*f[i][j][k][l-1-x])%mod;
					for(register int x=0;x<k;++x)
						for(register int y=0;y<=l;++y)
							f[i][j][k][l]=(f[i][j][k][l]+f[i-1][0][x][y]*f[i][j][k-1-x][l-y])%mod;
					for(register int x=0;x<j;++x)
						for(register int y=0;y<=k;++y)
							for(register int z=0;z<=l;++z)
								f[i][j][k][l]=(f[i][j][k][l]+f[i-1][x][y][z]*f[i][j-1-x][k-y][l-z])%mod;
				}
	if(d==0) printf("%d\n",f[d][l1][l2][l3]);//要特判一下d=0的情况
	else printf("%d\n",(f[d][l1][l2][l3]-f[d-1][l1][l2][l3]+mod)%mod);
	return 0;
}
```

---


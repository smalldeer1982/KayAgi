# 「Wdsr-1」仓库建设

## 题目背景

有一天，人间之里出现了饥荒。

## 题目描述

因为幻想乡倡导“幻想乡命运共同体”意识，河童们决定帮助人类修建一些粮仓防止饥荒再次发生。

人间之里有 $n$ 座城市和 $m$ 条双向道路，第 $i$ 条道路连接 $u_i，v_i$ 两座城市，长度为 $w_i$ 个单位。

由于每座城市的科技水平不同，从不同城市出发的运粮车的储油量不同。第 $i$ 座城市的运粮车的储油量只能支持运粮车行驶 $x_i$ 个单位。当然，城市与城市之间是友好的，无论到达哪个城市，热心的当地民众都会给运粮车**加满油**。

河童科技高度发达，所以仓库容纳的粮食可以视作无限。只有粮仓能发出运粮车。

现在要选择一些城市建设仓库，使得每一个城市都可以从粮仓中得到粮食。为了节约资源，河童希望仓库的数量最小。

但妖怪有时会占据一个城市，所以需要算出在任意一个城市不能建设粮仓时需要的最小粮仓数。

## 说明/提示

#### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/jg6fg91l.png)

这是样例画出来的图，显然在 3 号城市建立粮仓就可以解决问题，当 3 号城市不能建粮仓时，其他的城市无论怎么建粮仓，粮食也运不到 3 号城市，输出 ```-1```。

---

#### 数据范围

对于 $25\%$ 的数据，保证 $1\le n，m\le 10 ^ 3$。  

对于另外 $25\%$ 的数据，保证 $m=n-1$。  

对于 $100\%$ 的数据，保证 $1\le n，m \le 3\times 10^5，1\le u_i，v_i\le n，1\le w_i，x_i\le 10^6$，保证图联通。

## 样例 #1

### 输入

```
4 4
1 2 2
1 3 3
2 4 1
3 4 4
2 1 3 2```

### 输出

```
1 1 1 -1 1```

# 题解

## 作者：FQ04gty (赞：5)

##### [原题链接](https://www.luogu.com.cn/problem/P6310)

---

首先，本题并不需要 DP。

考虑一个城市作为粮仓时可以使多少城市无需作为粮仓。

建出图的 Kruskal 重构树，倍增地找到深度最浅的，且权值不大于第 $i$ 个城市运粮车油量的点 $loc_i$（在原图中是边）。

可以发现，让父亲作为粮仓，一定比让儿子作为粮仓优——可以覆盖更多节点。

记 $cnt_i$ 为重构树中 $i$ 节点是几个叶子倍增找到的权值最大点。

因此，只需要从根节点开始 dfs，遇到最近的满足 $cnt_i>0$ 的节点将答案增加 $1$ 并返回。这样就得出了第一个答案 $ans$。

该部分时间复杂度 $O(n\log n)$。

考虑统计每个节点不作为粮仓时的答案。

可以发现：

- 当 $loc_i$ 不属于刚才 dfs 出的点集时，答案为 $ans$。

- 否则，当 $cnt_{loc_i}>1$ 时，只需要把粮仓换成相同效果的另一个点，答案依然为 $ans$。
- 否则，当 $cnt_{loc_i}=1$ 时，我们按照刚刚从根节点开始的 dfs 方式从 $loc_i$ 开始 dfs，统计新增的点数 $k$，答案为 $ans+k-1$。需要注意的是，如果 dfs 到了 $i$，则无法将粮食运到 $i$，输出 $-1$。

分析时间复杂度：

前两种情况单次都是 $O(1)$ 的。

后一种情况，考虑重构树被若干个 $cnt_i>0$ 的点分隔成若干个连通块，每次只会访问到其中一个。总共访问的点数是 $O(n)$ 级别的。

因此，该算法总时间复杂度为 $O(n\log n)$。

### Code

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int SIZE=6e5+10,BIT=25,inf=0x3f3f3f3f;
inline int read()
{
    int x=0,opr=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')opr=-opr;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=getchar();
    return x*opr;
}
vector<int>son[SIZE];
int n,m,f[SIZE],val[SIZE],sizep,fa[SIZE][BIT],maxv[SIZE][BIT],g[SIZE],cnt[SIZE],loc[SIZE],ans;
bool need[SIZE];
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
struct edge{int u,v,w;inline void build(){u=read(),v=read(),w=read();};inline bool operator<(edge x){return w<x.w;}}e[SIZE];
void dfs(int thisp)
{
    for(int i=1;i<BIT;i++)fa[thisp][i]=fa[fa[thisp][i-1]][i-1],maxv[thisp][i]=max(maxv[thisp][i-1],maxv[fa[thisp][i-1]][i-1]);
    for(int nxt:son[thisp])dfs(nxt);
}
int tot;
inline int get(int x){int G=g[x];for(int i=BIT-1;~i;i--)if(maxv[x][i]<=G)x=fa[x][i];return x;}
int solve(int thisp){if(cnt[thisp]||thisp<=n)return tot++,need[thisp]=1;int res=0;for(int nxt:son[thisp])res+=solve(nxt);return res;}
int test(int thisp,int from){if(thisp==from)return SIZE;if(cnt[thisp]&&thisp!=loc[from]||thisp<=n)return 1;int res=0;for(int nxt:son[thisp])res+=test(nxt,from);return res;}
int main()
{
    sizep=n=read(),m=read();
    for(int i=1;i<=n;i++)f[i]=i;
    for(int i=1;i<=m;i++)e[i].build();
    for(int i=1;i<=n;i++)g[i]=read();
    sort(e+1,e+m+1);
    for(int i=1,u,v;i<=m;i++)
    {
        u=find(e[i].u),v=find(e[i].v);
        if(u==v)continue;
        val[++sizep]=e[i].w,maxv[u][0]=maxv[v][0]=e[i].w,fa[u][0]=fa[v][0]=f[u]=f[v]=f[sizep]=sizep,son[sizep].push_back(u),son[sizep].push_back(v);
    }
    maxv[sizep][0]=inf,dfs(sizep);
    for(int i=1;i<=n;i++)cnt[loc[i]=get(i)]++;
    printf("%d ",ans=solve(sizep));
    for(int i=1,res;i<=n;i++)
    {
        if(cnt[loc[i]]>1||!need[loc[i]]){printf("%d ",ans);continue;}
        res=ans-1+test(loc[i],i);
        printf("%d ",res>=SIZE?-1:res);
    }
    return 0;
}
```

---

## 作者：UltiMadow (赞：3)

一道kruskal重构树的题目

思路并不难，首先把kruskal重构树建出来，接下来dp

dp之前要倍增预处理一下，求出每个点可以控制的范围，并把那个点标记+1

设 $f_u$ 为若 $u$ 可以选则控制 $u$ 的子树需要多少仓库

明显，若 $u$ 的标记 $\geq1$ 则 $f_u=1$，其他情况 $f_u=\sum_{v\in son\{u\}} f_v$

设 $tag_u$ 为 $u$ 到根有多少可控的节点；若 $tag_u>1$ 则表示 $u$ 节点不选不影响答案；若 $tag_u=0$ 则表示要把 $u$ 的答案变成 $f_{root}-1+\sum_{v\in son\{u\}}f_v$

判断 -1只要判断每个叶子节点的 $tag$ 是否为 1 即可

std:
```cpp
#include<bits/stdc++.h>
#define MAXN 1000010
using namespace std;
int n,m;
struct Node{int to,fr,val;}Edge[MAXN<<1];int cnt_Edge;
void Add_Edge(int u,int v,int w){Edge[++cnt_Edge]={v,u,w};}
vector<int>G[MAXN<<1];
bool cmp(Node x,Node y){return x.val<y.val;}
int fa[MAXN<<1][31],val[MAXN<<1];
int tot;
int fat[MAXN<<1];
int get(int x){return (x==fat[x])?x:fat[x]=get(fat[x]);}
void dfs(int u)
{
	for(int i=1;i<=27;i++)
		fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		dfs(v);
	}
}
void kruskal()
{
	sort(Edge+1,Edge+m+1,cmp);
	tot=n;
	for(int i=1;i<=n;i++)fat[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=Edge[i].fr,v=Edge[i].to,w=Edge[i].val;
		int a=get(u),b=get(v);
		if(a==b)continue;
		tot++;
		fat[a]=fat[b]=fat[tot]=tot;
		val[tot]=w;
		G[tot].push_back(a);
		G[tot].push_back(b);
		fa[a][0]=fa[b][0]=tot;
	}
	dfs(tot);
}
int f[MAXN],pos[MAXN];
int tag[MAXN];
void dp(int u)
{
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		dp(v);
		f[u]+=f[v];
	}
	if(pos[u]){f[u]=1;return;}
}
void dfs2(int u,int fl)
{
	tag[u]=fl;
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		dfs2(v,fl+pos[u]);
	}
}
int ans[MAXN];vector<int>pnt[MAXN];
void dfs3(int u)
{
	if(pos[u]>1||tag[u])
		for(int i=0;i<pnt[u].size();i++)
			ans[pnt[u][i]]=f[tot];
	else if(pos[u])
	{
		ans[pnt[u][0]]=f[tot]-1;
		for(int i=0;i<G[u].size();i++)ans[pnt[u][0]]+=f[G[u][i]];
		if(tag[pnt[u][0]]<=1)ans[pnt[u][0]]=-1;
	}
	for(int i=0;i<G[u].size();i++)
	{
		int v=G[u][i];
		dfs3(v);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		Add_Edge(u,v,w);
	}
	kruskal();
	for(int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);
		int u=i;
		for(int j=27;j>=0;j--)
			if(fa[u][j]&&val[fa[u][j]]<=x)
				u=fa[u][j];
		pos[u]++;pnt[u].push_back(i);
	}
	dp(tot);dfs2(tot,false);dfs3(tot);
	printf("%d",f[tot]);
	for(int i=1;i<=n;i++)printf(" %d",ans[i]);
	return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

## 前言

这题同学问我怎么做的，他想了 4 个小时没想出来（前提是他不会重构树）给他讲了就会了。

## Step 1 分析问题

不难发现这个 $ x\ge w_{i}$ 才能移动的性质可以用 kruskal 重构树维护，不知道的移步[这里](https://www.cnblogs.com/qfxlzhe/p/15153705.html)。

然后我们对于每个 $u$ 都倍增跳到深度**最浅**且点权不大于的点 $t_{u}$。

不难发现直接覆盖 $t_{u}$ 一定最优，也就是实际上只需要考虑 $t_{u}$ 的覆盖即可。

## Step 2 求解答案

考虑先计入原来的答案，我们记录 $tag_{u}$ 表示节点 $u$ 是几个原节点跳到的最浅祖先。

这样答案就很浅显了，从根节点进行 dfs，我们还需要记录一个数组 $vis$ 表示访问集合。

不难发现有：

- 当 $tag_{u}$ 不为 $0$ 时直接覆盖它，答案为 $1$，且**令** $vis_{u}=1$。

- 否则将 $u$ 儿子答案之和计入即可。

我们这样就得到了原答案 $ans$。

考虑统计不能选取点 $i$ 对原答案 $ans$ 的影响。令 $x$ 表示 $t_{i}$。

- 当 $vis_{x}=0$ 时对答案没有影响，因为如果没有访问到的话就说明它的祖先一定被访问到了。

- 否则，当 $cnt_{x} > 1$ 时显然也没有影响，直接换成一个等效的点即可。

- 再者，当 $cnt_{x} = 1$ 时，我们可以直接像求解之前求解 $ans$ 一样 dfs 一下求解答案即可，令新增的答案为 $k$，那么此时答案为 $ans-1+k$。

但是注意到还有**无解**的情况。可以暴力把每个点的区间都维护出来然后区间加判断是否有解，但是没有必要，这里我们考虑直接 dfs 更新答案时判断。

## Step 3 时间复杂度分析与代码

时间复杂度分析一下，预处理部分为 $O((m+n)\log n)$。对于求解答案为 $O(n)$。

当 $cnt_{x}=1$ 时我们 dfs 的复杂度实际上均摊时 $O(n)$ 量级的，不妨将 $cnt_{u}>0$ 的点都分割出来形成一个森林，每次我们 dfs 就是访问了其中的某一棵树，而每颗树**只会被访问一次**所以说总和为 $O(n)$。

所以时间复杂度瓶颈在于预处理的 $O((m+n)\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5,inf=1e9;
struct Point{
	int u,v,w;
}a[N]; 
int n,m,b[N],tot,f[N],tag[N],tmp[N];
vector <int> e[N];
void add(int u,int v){
	e[u].push_back(v);
}
bool cmp(Point x,Point y){return x.w<y.w;}
int getf(int u){
	if(f[u]==u)return u;
	return f[u]=getf(f[u]);
}int u,v,fa[N][21];
void dfs(int u){
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i];
		fa[v][0]=u;
		dfs(v);
	}
}int getup(int x,int k){
	for(int i = 20;i >= 0;i--)
		if(b[fa[x][i]]<=k&&fa[x][i])
			x=fa[x][i];
	return x;
}int c[N],ans;
int calc(int u,int last){
	if(u==last)return inf;int sum=0;
	if(tag[u]&&u!=tmp[last]||u<=n)return 1;
	for(int i = 0;i < e[u].size();i++)sum+=calc(e[u][i],last);return sum;
}int vis[N];
int dfs1(int u){
	if(tag[u]||u<=n){return tot++,vis[u]=1;}int sum=0;
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i];
		sum+=dfs1(v);
	}return sum;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;tot=n;
	for(int i = 1;i <= m;i++)cin >> a[i].u >> a[i].v >> a[i].w;
	sort(a+1,a+1+m,cmp);for(int i= 1;i <= n;i++)f[i]=i;
	for(int i = 1;i <= m;i++){
		u=getf(a[i].u),v=getf(a[i].v);
		if(u!=v){
			b[++tot]=a[i].w,f[u]=f[v]=f[tot]=tot;
			add(tot,u);add(tot,v);
		}
	}dfs(tot);
	for(int j = 1;j <= 20;j++)for(int i = 1;i <= tot;i++)fa[i][j]=fa[fa[i][j-1]][j-1];
	for(int i = 1;i <= n;i++)cin >> c[i],tag[tmp[i]=getup(i,c[i])]++;
	ans=dfs1(tot);cout << ans << " ";
	for(int i = 1;i <= n;i++){
		if(tag[tmp[i]]>1||!vis[tmp[i]]){
			cout << ans<< " ";
			continue;
		}int ans1=ans+calc(tmp[i],i)-1;
		if(ans1>n)cout << -1 << " ";
		else cout << ans1 << " ";
	}
	return 0;
}

```

---

## 作者：TimSwn090306 (赞：0)

提供一种**不**基于 Kruscal 重构树的 $O(n\log n)$ 做法。

问题可以转化为有 $n$ 个点集，从中挑出最少数量的点集使得每个点至少在一个点集里出现。并钦定第 $i\in[1,n]$ 个点集不能选择时的最少点集选取数量。

设第 $i$ 个点能够到达的点构成的点集为 $S_i$。

> 引理 1：对于 $\forall i\ne j$，$S_i$ 与 $S_j$ 要么不交，要么呈包含关系。
>
> 证明：不妨设 $x_i\ge x_j$，若存在点 $k$ 使得 $i,j$ 均可到达，则点 $i$ 一定可以通过 $j$ 到达 $k$ 的路径返回并到达所有其他 $j$ 可以到达的点（边权 $\le x_j\le x_i$）。

据此，我们有一个不考虑限制条件的做法，即贪心地按 $x_i$ 从大到小选择，如果当前点能被比它大的 $x_p$ 到达，那么不选择；反之选择。

考虑限制某个点集 $S_i$ 无法选择对答案造成的影响。

> 引理 2：对于每一个在不考虑限制条件中没有被选择的点 $i$，存在唯一一个 $j$ 使得 $S_i$ 是 $S_j$ 的子集，且点 $j$ 是被选择的。
>
> 证明：显然若 $j,k$ 都被选择，$S_i$ 同时是 $S_j,S_k$ 的子集，那么 $|S_j|,|S_k|$ 中较小的那一个一定是不必选择的（引理 1 可知此时 $S_j,S_k$ 一定是包含关系），与 $j,k$ 被选择矛盾。

分讨点 $i$ 在不考虑限制条件时是否被选择。

- 若点 $i$ 没有被选择，那么它对答案没有影响。

- 若点 $i$ 被选择，那么它的点集 $S_i$ 需要使用其他的点集来拼凑。具体的，枚举 $S_i$ 的子集 $S_j$，按 $x$ 从大到小贪心选择，这个问题与上述不考虑限制条件问题等价。由于 $S_j$ 最多是一个被选择的 $S_i$ 的子集（引理 2 得），所以每个点最多被枚举一次，时间复杂度是对的。

总时间复杂度 $O(n\log n)$，瓶颈在于对 $x_i$ 排序。

代码如下：


```cpp
#include <bits/stdc++.h>
#define fin(str) freopen(str,"r",stdin)
#define fout(str) freopen(str,"w",stdout)
#define ll long long
using namespace std;

const int maxn=3e5+5;
const int maxw=1e6+5;

int n,m;

struct edge{
	int to,w,next;
}e[maxn<<1];
int tot=1,h[maxn];
inline void addEdge(int x,int y,int z){
	e[++tot]=(edge){y,z,h[x]};
	h[x]=tot;
}

struct node{
	int x,id;
	inline bool operator < (node tmp) const{
	    if (x!=tmp.x) return x<tmp.x;
	    return id<tmp.id;
	}
}w[maxn];

int cnt,vis[maxn],val[maxn];
vector <int> block[maxn];
inline void dfs(int x,int val){
	vis[x]=cnt;
	block[cnt].push_back(x);
	for (int i=h[x];i;i=e[i].next){
		int v=e[i].to;
		if (vis[v] || e[i].w>val) continue;
		dfs(v,val);
	}
}
int ans_del[maxn],in[maxn];
inline void search(int x,int val,int id){
	vis[x]=true;
	for (int i=h[x];i;i=e[i].next){
		int v=e[i].to;
		if (vis[v] || in[v]!=id || e[i].w>val) continue;
		search(v,val,id);
	}
}
inline void solve(int id){
	int res=0;
	for (int i=1;i<block[id].size();i++){
		int x=block[id][i];
		if (!vis[x]){
			res++;
			search(x,val[x],id);
		}
	}
	if (!vis[block[id][0]]) ans_del[block[id][0]]=-1;
	else ans_del[block[id][0]]=res;
}

int main(){

	scanf("%d%d",&n,&m);
	for (int i=1,x,y,z;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		addEdge(x,y,z);
		addEdge(y,x,z);
	}
	for (int i=1;i<=n;i++){
		scanf("%d",&w[i].x);
		val[i]=w[i].x,w[i].id=i;
	}
	
	sort(w+1,w+n+1);
	
	for (int i=n;i;i--){
		if (!vis[w[i].id]){
			cnt++;
			dfs(w[i].id,w[i].x);
		}
	}
	
	for (int i=1;i<=cnt;i++){
		for (int j=0;j<block[i].size();j++){
			int x=block[i][j];
			in[x]=i;
		}
		block[i].clear();
	} 
	for (int i=n;i;i--) block[in[w[i].id]].push_back(w[i].id);
	
	memset(vis,0,sizeof(vis));
	for (int i=1;i<=cnt;i++){
		solve(i);
	}
	printf("%d ",cnt);
	for (int i=1;i<=n;i++){
		if (ans_del[i]!=0){
			if (ans_del[i]==-1) printf("-1 ");
			else printf("%d ",cnt-1+ans_del[i]);
		}else printf("%d ",cnt);
	}
	return 0;
}
```

---

## 作者：MadokaKaname (赞：0)

玄学题目，做了三个小时，~~绝大部分在调错误的代码结果发现脑抽少加了点东西~~。

## solution

~~首先观察标签，发现是 dp，然后你开始思考 dp，然后就没有然后了。~~

~~我绝对不会告诉你我是在找 dp 题的时候做到这题的！~~

这里提供一种~~除排序外~~ $O(n\alpha(n))$ 的算法。

前置知识：Kruskal 重构树（[oiwiki](https://oiwiki.org/graph/mst/#kruskal-%E9%87%8D%E6%9E%84%E6%A0%91)，[洛谷日报](https://www.luogu.com.cn/blog/me-immortal/kruskal-chong-gou-shu)）

发现选择点的点权与两点之间路径权值的最小值有关，考虑 Kruskal 重构树。

我们先考虑所有点都可以选的情况。

考虑在从小到大插入边的时候进行一些操作。发现我们可以将点权从小到大排序，再每次修改。因此我们考虑带权并查集。每一次插入边前对在权值在两次插入之间的点的并查集权值更改为 1。每次合并即为权值相加，最后的答案即为最终并查集的权值，记为 $ans$。

再考虑有某个点无法选择的情况。发现每一次插入点时在 Kruskal 重构树上标记的话，当一颗子数的根节点本来有选中却不允许时，答案只与其再往下一层有标记的点有关。具体来说，当 dfs 时目前点是第一个被标记的点时，对这个点进行标记过的点的答案与 $ans$ 的差值 $\Delta ans$ 为

$$
\begin{cases}
  & 0 \text{ if } cnt_i\ge 2 \\
  & \inf\text{ if } \exists {a_1,a_2.....a_j},father_{a_1}=i,father_{a_i}=a_{i-1}(2 \le i\le j),\forall i\le j,flag_{a_i}=0 \\
  & sum_i-1\text{ otherwise } 
\end{cases}

$$

其中 $cnt_i$ 表示在 $i$ 位置上打上 tag 的次数，$flag_i$ 表示 $i$ 位置是否曾经打过 tag，$sum_i$ 表示在以 $i$ 为根的子树上 dfs 第一次遇到的打过   tag 个的点个数。

用感性思维来理解，就是如果这个点打过 tag 的次数不止一次，那么对这个点打 tag 的所有点可以任意选择，不受影响；否则先判断无解，即为存在一条路径无法满足；否则计算以该节点为根的子树上第一次遇到的打过 tag 的点的个数，答案即为个数 -1.

[Code](https://www.luogu.com.cn/paste/1ivhs4kw)





 








---


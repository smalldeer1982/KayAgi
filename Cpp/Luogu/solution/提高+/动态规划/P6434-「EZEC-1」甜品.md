# 「EZEC-1」甜品

## 题目背景

小 X 最喜欢甜品了！

马上就要开学了，但是小 X 并没有写完作业，他十分悲伤地走在街上。忽然，他发现了一家新开的甜品店，悲伤的心情一消而散，随即信步走进甜品店。

## 题目描述

小 X 发现，店里总共有 $n$ 种甜品，而他想挑选其中的 $k$ 种，并按照一定的顺序来品尝。

每种甜品都有一个美味值 $a_i$，小 X 吃甜品的顺序是有讲究的，他不想使连续两种甜品之间的美味值相差太小，不然他将无法品味出两种甜品之间的差别；但他也不想使连续两种甜品之间的美味值相差太大，否则他将受不了这巨大的味觉冲击。他十分纠结，不知道该如何选择，于是他向你求助。

你要从 $n$ 种甜品中选择 $k$ 种甜品，并且第 $i$  种甜品（ $i \in [ 2 , k ] $）需要满足如下两个条件：

- 第 $i$ 种甜品的美味值必须**大于等于**第 $i-1$ 种甜品的 $l$ 倍。

- 第 $i$ 种甜品的美味值必须**小于等于**第 $i-1$ 种甜品的 $r$ 倍。

问现在你有多少种方案？$k$ 种甜品的美味值之和最大为多少？

因为答案太大，所以两个问题你都需要对 $1000000007$($10^9+7$)  取模。

#### 注：方案总数只考虑 $k$ 种甜品的搭配，不考虑排列顺序。即若存在某 $k$ 种甜品，按照不同顺序品尝都满足条件，仍然只算一种方案。

## 说明/提示

【样例解释】

样例1：只能选 $(4,3,1)$，共 $1$ 种。

样例2：$(1,2)$ 或 $(3,4)$ 或 $(4,5)$，共 $3$ 种。美味值之和最大的是 $ (4,5)$，为 $100$。

------------

【 数据范围】
| 测试点编号 | $n\le$ | $k\le$ | $a_i\le$ |
| :----------: | :----------: | :----------: | :----------: | 
|$1 \sim 4$ | $20$ | $3$ | $100$ | 
| $5 \sim 8$ | $10^3$ | $4$ | $10^3$ | 
| $9 \sim 12$ | $10^5$ | $10$ | $10^5$ | 
| $13 \sim 16$ | $2\times 10^6$ | $10$ | $10^9$ | 
| $17 \sim 20$ | $2\times 10^6$ | $10$ | $10^9$ | 
- 对于 $90\%$ 的数据，$a_i$ 随机生成。
- 对于 $100\%$ 的数据，$k \le 10$，$k \le n \le 2\times 10^6$，$1 \le l \le r \le 10$，$a_i \le 10^9$。


## 样例 #1

### 输入

```
4 3 2 3
7 5 3 1```

### 输出

```
1
11```

## 样例 #2

### 输入

```
5 2 4 4
1 4 5 20 80```

### 输出

```
3
100```

## 样例 #3

### 输入

```
20 3 2 5
88 24 35 53 5 44 45 30 29 43 46 33 21 24 64 43 23 71 63 53 ```

### 输出

```
33
153```

## 样例 #4

### 输入

```
5 5 2 4
1 2 3 4 5```

### 输出

```
0
0```

# 题解

## 作者：君のNOIP。 (赞：7)

## 首先是问题一：

#### 20分：$O(2^n)$ 直接爆搜即可。

#### 40分：$O(kn^2)$ 暴力 $dp$。

**首先将美味值排序。**

设 $dp_{i,j}$ 为**以第 $i$ 种结尾**选了 $j$ 种的方案数。

可以发现 $dp_{i,j}$ 为 $\sum\limits_{a_p\times l\le a_i}^{a_p\times r\ge a_i} dp_{p,j-1}$

这个过程三重 $for$ 循环模拟即可。 

答案就是 $\sum\limits_{i=k}^n dp_{i,k}$

#### 60分：由于 $a_i$ 比较小，这是给开桶的做法过的，这里不详解了。

#### 100分: $O(nk + nlogn)$

参考40分思路，我们发现瓶颈在于第 3 重循环的寻找符合条件的 $p$ 

我们可以设 $dp_{i,j}$ 为**到第 $i$ 种选了 $j$ 种**的方案数。
 
首先很显然 $dp_{i,j}\gets dp_{i-1,j}$

然后我们只需知道对于每个 $i$ 最大的 $p$ 和最小的 $p$ ，满足 $a_p\times l\le a_i$ ，$a_p\times r\ge a_i$

这个过程我们可以 $O(n)$ 预处理得出。 

如下：

------------
```cpp
int mi[MlX_N],ma[MlX_N];
int li=0,la=0;
for(int i=1;i<=n;i++) {
	while(va[la+1] * l <= va[i] && la < i-1)la++;
	while(va[li+1] * r < va[i] && li < i-1)li++;
	mi[i]=li;
	ma[i]=la;
	dp[i][1]=i; //初始化
}
```
------------

其中 $ma_i$ 表示最大的 $p$ 使 $a_p\times l\le a_i$ ， 而 $mi_i$ 表示最大的 $q$ 使 $a_q \times r < a_i$ （这样保证$a_{q+1} \times r \ge a_i$）

那么 $\sum\limits_{a_p\times l\le a_i}^{a_p\times r\ge a_i} dp_{p,j-1}$ 就是 $dp_{ma_i,j-1} - dp_{mi_i,j-1}$

综上转移方程为：

```cpp
dp[i][j] = (dp[i-1][j] + dp[ma[i]][j-1] - dp[mi[i]][j-1] + mod) % mod;
```



注意：

- 由于一开始卡空间，这里给的是滚动数组。

- 转移前要判断，若 $dp_{ma_i,j-1} < dp_{mi_i,j-1}$ 则加上 $mod$ ，以保证不出现负数，同时也不超 $int$

------------

## 对于问题二，有两种方法：

- 贪心：从最大的往前选，然后每次跳到 $ma_{now}$ ，第一次选满 $k$ 种即为最优解，就输出答案并直接 $exit(0)$

时间复杂度：$ O(???) $

由于是爆搜，时间复杂度很玄学，在随机数据下会比第二种方法 $dp$ 快。


#### 部分代码：

------------

```cpp

void dfs(int t,int now,int s){
	if(t==1){
		cout<<s;
		exit(0);
	}
	for(int i=ma[now];i>mi[now];i--)
    		dfs(t-1, i, (s + va[i]) % mod );
}

int main(){
	for(int i=n;i>=k;i--)
		if(va[i] != va[i+1])
			dfs(k, i, va[i]);
            
	cout<<0;
}
```

------------

- 还是 $dp$ ， 转移方程也仅有一行。

设 $f_{i,j}$ 为到第 $i$ 种选了 $j$ 种的美最大味值之和。

很显然还是 $f_{i,j}\gets f_{i-1,j}$

然后可以发现 $f_{i,j}\gets f_{ma_i,j-1} + a_i$

二者取最大值即可。

但仅当以第 $i$ 种结尾选 $k$ 种的方案存在时，我们才能考虑后者。

所以转移方程为：

```
f[i][j&1]= max(f[i-1][j&1], (dp[i][j&1] != dp[i-1][j&1] ? f[ma[i]][j&1^1] + va[i] : 0 ) )%mod ;
```


------------


#### 完整代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#define mod 1000000007
#define G() Cr=getchar()
int Xr;char Cr;
inline int rd(){
    Xr=0,G();
    while(Cr<'0'||Cr>'9')G();
    while(Cr>='0'&&Cr<='9')Xr=(Xr<<3)+(Xr<<1)+Cr-'0',G();
    return Xr;
}
#define MlX_N 2000005
int n,k;
int l,r;
int va[MlX_N];
int li,la;
int mi[MlX_N],ma[MlX_N];
int dp[MlX_N][2];
int f[MlX_N][2];
int main(){	
	n=rd(),k=rd(),l=rd(),r=rd();
	for(int i=1;i<=n;i++)va[i]=rd();
	sort(va+1, va+1+n);
	for(int i=1;i<=n;i++) {
		while(va[la+1] * l <= va[i] && la < i-1)la++;
		while(va[li+1] * r < va[i] && li < i-1)li++;
		mi[i]=li;
		ma[i]=la;
		dp[i][1]=i;
		f[i][1]=va[i];
	}

	for(int j=2;j<=k;j++) {
		for(int i=1;i<=n;i++) {
			if(dp[ma[i]][j&1^1] < dp[mi[i]][j&1^1])
				dp[i][j&1] = (dp[i-1][j&1] + dp[ma[i]][j&1^1] - dp[mi[i]][j&1^1] + mod ) % mod;
			else
				dp[i][j&1] = (dp[i-1][j&1] + dp[ma[i]][j&1^1] - dp[mi[i]][j&1^1] ) % mod;
		
			f[i][j&1] = max(f[i-1][j&1], (dp[i][j&1] != dp[i-1][j&1] ? f[ma[i]][j&1^1] + va[i] : 0 ) ) % mod;
		}
	}
	
	cout<<dp[n][k&1]<<endl<<f[n][k&1];
}
```

------------


### 总结：思路较为简单，细节较多，~~可以瞎搞骗分~~。


---

## 作者：HPXXZYY (赞：2)

$\color{blue}{\texttt{[Problem]}}$

从 $a_{1\cdots n}$ 中选出 $k$ 个数（**不要求下标递增**），使得这 $k$ 个数 $b_{1 \cdots k}$ 满足：

$$l \times b_{i} \leq b_{i+1} \leq r \times b_{i}(i \in [1,k))$$

求方案数对 $(10^9+7)$ 取模的结果及可能的 $\left (\sum\limits_{i=1}^{k} b_{i}\right)$ 的最大值。

**无解输出 `0 0`。**

$1 \leq n \leq 2 \times 10^6,1 \leq k \leq 10,1 \leq a_{i} \leq 1\times 10^9,1 \leq l \leq r \leq 10$。

$\color{blue}{\texttt{[Solution]}}$

因为选的顺序任意，所以我们先将 $a_{i}$ 从小到大**排序**。这样可以方便后面的处理。

记 $g_{i,j}$ 表示考虑 $a_{1 \cdots i}$ ，必选 $a_{i}$ 且已经选了 $j$ 个数的方案数，类似的，$f_{i,j}$ 表示和的最大值（注意 $a_{i}$ **必选**）。

$$
g_{i,j}=\sum\limits_{k \to i}g_{k,j-1}\\
f_{i,j}=\max\limits_{k \to i}\{f_{k,j-1}\}+a_{i}
$$

其中 $k \to i$ 表示 $a_{i}$ 的**前一个**被选的数是 $a_{k}$.

我们发现，对于一个固定的 $i$，所有的 $k$ 是**固定**的，而且**集中在一个区间**内（**排序后**），这就是我们排序的意义所在。

用 `two-pointers` 即可 $O(n)$ 的求出每个 $i$ 的转移区间 $[L_{i},R_{i}]$，则转移可以写成：

$$
g_{i,j}=\sum\limits_{k \in [L_{i},R_{i}]} g_{k,j-1}\\
f_{i,j}=\max\limits_{k \in [L_{i},R_{i}]} \{f_{k,j-1} \} +a_{i}
$$

$g_{i,j}$ 可以用**前缀和**优化，$f_{i,j}$ 可以**单调队列**优化。优化后总时间复杂度为 $O(nk)$。

更进一步地，我们可以用**滚动数组**把空间复杂度优化到 $O(n)$。

**一定记得开 `long long`。**

$\color{blue}{\texttt{[code]}}$

```cpp
const int N=2e6+100;
const int mod=1e9+7;
typedef long long ll;
const ll inf=1e15;//无穷 
int n,k,cnt,L[N],R[N];
int a[N],g[N],l,r,pre[N];
ll f[N][2],ans;int q[N],h,t;
int main(){
	n=read();k=read();
	l=read();r=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		f[i][1]=a[i];g[i]=1;
	}//初始化，含义显然
	for(int i=1,sub=1;i<=n;i++){
		while (sub<=n&&1ll*a[sub]*r<a[i]) sub++;
		L[i]=sub;//在 a[i] 左边的最左的转移点 
	}
	for(int i=1,sub=1;i<=n;i++){
		while (sub<=n&&1ll*a[sub]*l<=a[i]) sub++;
		R[i]=sub-1;//在 a[i] 左边的最右的转移点 
	}
	for(int i=1;i<=n;i++)
		if (l==1) R[i]=i-1;
	//注意 R[i] 一定会小于 i
	for(int j=2;j<=k;j++){
		memset(pre,0,sizeof(pre));
		for(int i=1;i<=n;i++)
			pre[i]=(pre[i-1]+g[i])%mod;
		memset(q,0,sizeof(q));h=1;t=0;
		for(int i=1;i<=n;i++)
			f[i][j&1]=-inf,g[i]=0;
		for(int i=1,sub=1;i<=n;i++){
			if (L[i]<=R[i]&&i>=j) g[i]=(pre[R[i]]-pre[L[i]-1]+mod)%mod;
			while (h<=t&&q[h]<L[i]) h++;//维护单调队列的队头 
			if (L[i]<=R[i]&&i>=j) f[i][j&1]=f[q[h]][(j&1)^1]+a[i];
			while (sub<=n&&sub<=R[i+1]){//维护单调队列的队尾 
				while (h<=t&&f[sub][(j&1)^1]>=f[q[t]][(j&1)^1]) t--;
				q[++t]=sub;sub++;//只更新到 R[i+1] 
			}
		}
	}
	ans=0;cnt=0;
	for(int i=k;i<=n;i++){
		cnt=(cnt+g[i])%mod;
		ans=max(ans,f[i][k&1]);
	}
	if (cnt==0&&ans==-inf) printf("0\n0");//无解
	else printf("%d\n%lld",cnt,ans%mod);
	return 0;
}
```

---

## 作者：VioletIsMyLove (赞：2)

首先先预处理，把每个甜品按照从小到大排序（因为方案总数只考虑 $k$ 种甜品的搭配，不考虑排列顺序），然后找出吃每个甜品所能吃的下一种甜品的左端点和右端点。但普通的处理时间复杂度就是 $n^2$ 的，必须要把时间复杂度降下来。我们发现，把甜品排完序后，每个甜品的后一个能吃的甜品都是连续并且递增的，而且下一个甜品所能吃的后一个甜品只需要在前一个的基础上左端点往右缩进，右端点往右推，果断用单调队列（如果只看出连续而没发现可以在上一次的基础上往右推的话就只能用二分，但这是 $O(nlogn)$ 的还是会超时【无奈】【摊手】）。然后开一个数组 $f[j][i]$,表示在吃了第 $j$ 个的时候吃到 $i$，所能吃到的最大值。有了这个基础，那我们就从右往左推，造出前缀和之后用容斥就能 $O（1）$ 算出这个值，最后累加一下 $f[k][i](i是1---n)$ 就是第一问的答案，时间复杂度算上预处理近似是 $O(n*k)$。

对于第二问，我们说，只要这个甜品往右吃能吃到 $k$ 个，那么它所累加的值就对比在它左边的大！那么只需从右往左找，只要有一个甜品能吃 $k$ 个，那么答案就累加上它，再把 $k--$，继续从n开始往左枚举，$k=0$ 时就输出答案就ok了，第二问的时间复杂度也近似是 $O(n*k)$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int TT=1000000007;
struct ZS{
	int l,r;
}b[2000002];
int n,k,l,r,ans,lsth,lstt;
int hed,til;
int a[2000002],maxn[2000002];
int s[10][2000002];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	n=read();k=read();l=read();r=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+1+n);k--;
	for(int i=1;i<=n;i++){
		while(hed<=n+1&&a[hed]<a[i]*l)
		hed++;
		while(til<=n&&a[til+1]<=a[i]*r)
		til++;til=min(til,n);
		if(hed<=n)b[i].l=hed,b[i].r=til;
	}
	for(int i=1;i<=n;i++)s[0][i]=1;
	for(int j=1;j<=k;j++){
		for(int i=1;i<=n;i++)s[j-1][i]=(s[j-1][i]+s[j-1][i-1])%TT;
		for(int i=1;i<=n;i++)s[j][i]=(s[j-1][b[i].r]-s[j-1][b[i].l==0?-1:max(i,b[i].l-1)]+TT)%TT;
	}
	for(int i=1;i<=n;i++)ans=(ans+s[k][i])%TT;
	printf("%d\n",ans);
	if(!ans){printf("0\n");return 0;}ans=0;
	for(int i=n;i>=1;i--)if(s[k][i]){
		int now=i;ans+=a[i];
		for(int j=k-1;j>=0;j--){
			for(int g=b[now].r;g>=b[now].l;g--)
			if(s[j][g]-s[j][g-1]){ans=(ans+a[g])%TT;now=g;break;}
		}
		break;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Narcissusany (赞：2)

upd: 因为被 hack 了所以改了一点部分…
____


~~第一次写题解~~

下午先开的 D 再开的 C 的时候。做 D 的时候发现只会 40 分，并且很奇怪的被卡成了 35…然后 C 就边摸边做，写挂了不少地方。

考虑首先由于是无序选取，那么理应排个序之后重编号。之后可以根据 $r$ 来定出每个点能选的编号的左边界，根据 $l$ 选出右边界。其中 $r$ 可以用一个单调队列状物来维护，$l$ 由于从 $1$ 开始连续，所以可以直接枚举。

之后考虑两问分别怎么做。第一问的话，考虑一个 $dp$，$f_{i,j}$ 表示已经选了 $i$ 个点之后，最大选了 $j$ 号点(从小到大重编号之后)的方案数。考虑这样暴力转移是 $O(n^2k)$ 的。但是发现，对于每个点而言，随着点编号递增，转移区间 $[l_j,r_j]$ 都是递增的。于是可以外层枚举 $i$ ，内部用单调性优化一下，就是 $O(nk)$ 的了。

考虑第二问。个人给出的解法是贪心。因为无论怎么选，都是选 $k$ 个，那一定是越大越好。所以首先要找出最大的、满足可以选 $k$ 个元素的编号（有些元素过大，不可以和其它的组合），然后迭代向前找，每次找决策区间右端点就一定是最优的了。

注意事项：

1、第二个答案也要取模(一众 65 的来历)。

2、赛时卡了空间。其实这个问题不大，把 $f$ 的第一维滚掉就好了。

3、注意决策右端点不要取到 $i$ （当 $l=1$ 时这样显然会挂）。


```cpp
const int P = 1000000007 ; 

ll ans1 ; 
ll ans2 ;
int h, t ;
int q[N] ; 
int base[N] ;  
int f[2][N] ; 
ll n, l, r, k ;
int trans[N][2] ; 

il void _add(ll &x, ll y){ x += y ; if (x >= P) x -= P ; }
il void _dec(ll &x, ll y){ x -= y ; if (-x > 0) x += P ; }

int main(){
	cin >> n >> k >> l >> r ; h = 1, t = 0 ;
	for (int i = 1 ; i <= n ; ++ i) base[i] = qr() ; 
	sort(base + 1, base + n + 1) ; 
	for (int i = 1 ; i <= n ; ++ i){
		while (h <= t && 1ll * base[q[h]] * r < base[i]) q[h ++] = 0 ;
		trans[i][0] = h > t ? i : q[h] ; q[++ t] = i ;  
	}
	int top = 0 ; //debug(base,1,n);
	for (int i = 1 ; i <= n ; ++ i){
		while (base[i] >= 1ll * base[top] * l && top <= i) ++ top ; 
		trans[i][1] = top - 1 ; if (trans[i][1] == i) trans[i][1] -- ;
	}
	int ed, num = 1 ;
	int dl = 1, dr = 0 ; 
	trans[1][0] = 0 ; trans[1][1] = 0 ;
	for (int i = 1 ; i <= n ; ++ i) f[1][i] = 1 ; 
/*	for (int i = 1 ; i <= n ; ++ i) 
		cout << trans[i][0] << " " << trans[i][1] << '\n' ; */
	for (int d = 0, j = 2 ; j <= k ; ++ j, d ^= 1){
		fill(f[d], f[d] + n + 1, 0) ; 
		dl = 1, dr = 0 ; ll sum = 0 ;
		for (int i = j ; i <= n ; ++ i){
			while (dl < trans[i][0]) _dec(sum, f[d ^ 1][dl]), ++ dl ;
			while (dr < trans[i][1]) ++ dr, _add(sum, f[d ^ 1][dr]) ;
			f[d][i] = sum ;
		}	
	}
	for (int i = 1 ; i <= n ; ++ i) _add(ans1, f[k & 1][i]) ;
	for (int i = n ; i >= 1 ; -- i) 
		if (f[k & 1][i]) { ed = i ; break ; }
	if (ans1){
		while (num < k){
			(ans2 += base[ed]) %= P ;
			ed = trans[ed][1] ; ++ num ;
			while (trans[ed][0] > trans[ed][1]) ed -- ;
		}
		(ans2 += base[ed]) %= P ; 
	}
	if (!ans1) ans2 = 0 ; 
	cout << ans1 << "\n" << ans2 % P << '\n' ; return 0 ; 
}
```


---

## 作者：yxy666 (赞：2)

还算是比较 $easy$ 的 $DP$ ,  $opt[i][j]$ 表示前 $j$ 件物品取 $i$ 个的所有方案数,其中 $A[j]$ 必取, $F[i][j]$ 当然就是最大加和了啊。

```cpp
-------|--------------|------------|--------|----------
     mi[j]            k         ma[j]       j      

      注意 k 的取值范围 (mi[j],ma[j]])
```
对于 $mi[]$ 和 $ma[]$  ，可以再上一次的基础之上进行推导即可，因为 $a[]$ 已经单调。再一个就是 $F[i][j]$ 是单调不降的序列。

$code$ :
```cpp
#include<bits/stdc++.h>
#define maxn 2000005
#define TT 1000000007
#define LL long long
using namespace std;
int read(){
    int ret=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
    while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
    return ret*f;
}
int n,k,l,r,a[maxn],mi[maxn],ma[maxn],opt[2][maxn],f[2][maxn];
int main(){
    freopen("dessert.in","r",stdin);
    freopen("dessert.out","w",stdout);
    n=read(),k=read(),l=read(),r=read();
    for (int i=1;i<=n;i++) a[i]=read();
    sort(a+1,a+1+n);
    int hed=0,til=0;
    for (int i=1;i<=n;i++){
        while (til<i-1&&(LL)a[til+1]*l<=(LL)a[i]) til++;
        while (hed<i-1&&(LL)a[hed+1]*r< (LL)a[i]) hed++;
        mi[i]=hed,ma[i]=til;
        opt[1][i]=i,f[1][i]=a[i];
    }
    for (int i=2;i<=k;i++)
    for (int j=1;j<=n;j++){
        opt[i&1][j]=(opt[i&1][j-1]+((opt[1-i&1][ma[j]]-opt[1-i&1][mi[j]])%TT+TT)%TT)%TT;
        f[i&1][j]=max(f[i&1][j-1],(opt[i&1][j]!=opt[i&1][j-1]?f[1-i&1][ma[j]]+a[j]:0))%TT;
    }
    printf("%d\n%d\n",opt[k&1][n],f[k&1][n]);
    return 0;
}
```


---


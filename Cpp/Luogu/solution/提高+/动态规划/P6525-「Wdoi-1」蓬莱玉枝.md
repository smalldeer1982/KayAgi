# 「Wdoi-1」蓬莱玉枝

## 题目背景

辉夜的游戏机没电了。

## 题目描述

由于游戏机在妖怪之山充电，辉夜玩起了蓬莱玉枝。

具体来说，辉夜面前有 $n$ 条蓬莱玉枝，第 $i$ 条蓬莱玉枝的长度为 $a_i$ 。  

辉夜会从这 $n$ 条玉枝中选出若干条来，称作一次选择方案。一个方案被辉夜认为是"不无聊的"，当且仅当在选出的玉枝中，存在某三条玉枝能够 **构成一个三角形**。  

当一个方案被认为是"无聊的"时，辉夜认为它的有趣程度为 $0$；当一个方案被辉夜认为是"不无聊的"时，若选出的玉枝数量为 $k$，选出的玉枝中最长的玉枝长度为 $m$ ，则这个方案的有趣程度为 $km$ 。

现在，辉夜想要知道，所有选择方案的有趣程度之和是多少。然而，辉夜的玉枝太多了，所以她找到了聪明的你来帮她算出答案，作为回报，你可以得到参加月都万象展的邀请。

辉夜认为一个巨大的数字也是很无趣的，因此你只需要输出答案对 $20060723$ 取模后的结果即可。

## 说明/提示

#### 样例说明  

"不无聊的"方案有：

$\left\{4, 7, 8\right\}$，$\left\{4, 8, 11\right\}$，$\left\{7, 8, 11\right\}$ 和 $\left\{4, 7, 8, 11\right\}$。

故答案为 $\left(8 \times 3 + 11 \times 3 + 11 \times 3 + 11 \times 4\right) \bmod 20060723 = 134$。

#### 数据范围与约定  

**本题采用捆绑测试：一个子任务通过，当且仅当该子任务中全部测试点通过。**
| 子任务编号 | $n$ | 时限 | 空限 | 分值 |
| :--------: | :-: | :--: | :--: | :--: |
| $1$ | $20$ | $1\operatorname s$ | $500\operatorname{MB}$ | $15$ |
| $2$ | $100$ | $1\operatorname s$ | $500\operatorname{MB}$ | $20$ |
| $3$ | $200$ | $0.5\operatorname s$ | $500\operatorname{MB}$ | $10$ |
| $4$ | $1000$ | $1\operatorname s$ | $500\operatorname{MB}$ | $15$ |
| $5$ | $1500$ | $1\operatorname s$ | $500\operatorname{MB}$ | $15$ |
| $6$ | $2000$ | $5\operatorname s$ | $256\operatorname{MB}$ | $10$ |
| $7$ | $5000$ | $2\operatorname s$ | $500\operatorname{MB}$ | $15$ |

对于 $100\%$ 的数据，$0 < n \le 5000$，$0 < a_i \le 10^9$。

## 样例 #1

### 输入

```
4
7 4 8 11```

### 输出

```
134```

# 题解

## 作者：Alex_Wei (赞：14)

> [题面传送门](https://www.luogu.com.cn/problem/P6525)。

> 题意简述：从给出的 $n$ 个数中选出若干个数 $b_1,b_2,\cdots,b_m$，其分值为 $m\times \max b_i$。求所有满足存在 $i,j,k$ 使得 $b_i,b_j,b_k$ 能组成一个三角形的方案的分值之和。

题目还是挺不错的，如果模数是质数 / 不卡空间就更棒了。

---

正着算不方便，考虑用所有方案减去不满足的方案。

首先将给定的数从小到大排序，然后从左往右 DP：设 $l_{i,j},c_{i,j}$ 分别为倒数第二个数是 $a_i$，倒数第一个数是 $a_j$ 且不能构成三角形的方案**长度之和 / 个数**。

考虑一个状态能扩展到哪些状态，显然有：

$$(i,j)\to (j,p)\quad(a_i+a_j\leq a_p)$$

即 $l_{j,p}\gets l_{j,p}+l_{i,j}+c_{i,j},\ c_{j,p}\gets c_{j,p}+c_{i,j}\quad(a_i+a_j\leq a_p)$。

初值：$l_{0,i}=c_{0,i}=1$。目标：$\sum a_j\times l_{i,j}$。

直接三重循环枚举显然不行，接下来是一些优化：

- **每一次内层循环** $j$ 的时候，决策 $p$ 是单调的，可以用一个变量维护，均摊复杂度 $O(n)$。
- 可以发现每次转移的是一段区间（准确来说是 $a$ 的一个后缀），用~~树状数组~~前缀和维护即可做到 $O(1)$ 转移。

易知所有方案分值之和为：$\sum_{i=1}^{i\leq n}\sum_{j=1}^{j\leq i}a_i\times j\times \binom{i-1}{j-1}$，其中 $i$ 表示倒数第一个数为 $a_i$，$j$ 表示选出的数的个数为 $j$。

因为本题模数不是质数（毒瘤），所以需要时空 $O(n^2)$ 预处理组合数（毒瘤）。

时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$。

```cpp
int n,tot,sub,a[N],l[N][N],c[N][N],C[N][N];

int main(){
	n=read(); for(int i=1;i<=n;i++)a[i]=read(),l[0][i]=c[0][i]=1; sort(a+1,a+n+1);
	C[0][0]=1; for(int i=1;i<=n;i++)for(int j=0;j<=i;j++)C[i][j]=!j?1:(C[i-1][j-1]+C[i-1][j])%P;
	for(int i=1;i<=n;i++){
		int p=i+1; for(int j=0;j<i;j++){
			if(j)l[j][i]=(l[j][i-1]+l[j][i])%P,c[j][i]=(c[j][i-1]+c[j][i])%P;
			while(p<=n&&a[j]+a[i]>a[p])p++;
			if(p<=n)l[i][p]=(l[i][p]+l[j][i]+c[j][i])%P,c[i][p]=(c[i][p]+c[j][i])%P;
			sub=(sub+1ll*l[j][i]*a[i])%P;
		}
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=i;j++)tot=(tot+1ll*C[i-1][j-1]*j%P*a[i])%P;
	cout<<(tot-sub+P)%P;
	return 0;
}
```


---

## 作者：KaguyaH (赞：6)

Changelog: 重构。

[原文](https://www.luogu.com.cn/paste/60mpok16)。

---

首先排序。下面认为 $a$ 不降。

不考虑是否无聊，用所有选择方案的贡献减无聊的方案的贡献。

全部方案的贡献为
$$\sum_{i = 1}^n a_i \sum_{j = 0}^{i - 1} (j + 1) \binom {i - 1} j = \sum_{i = 1}^n 2^{i - 2} (i + 1) a_i$$

考虑在一个大小至少为 $2$ 的无聊方案 $S$ 后加入 $a_i$ 是否无聊。设 $j, k$ 为 $S$ 中最大的两个位置，则新方案无聊当且仅当 $a_j + a_k \le a_i$。

设 $f_{i, j}, h_{i, j}$ 分别表示方案中最大位置为 $i$、次大位置为 $j$ 的大小之和、方案数，则

$$f_{i, j} = \sum_{k < j \land a_k + a_j \le a_i} (f_{j, k} + h_{j, k}) + 2$$
$$h_{i, j} = \sum_{k < j \land a_k + a_j \le a_i} h_{j, k} + 1$$

其中 $k$ 的范围可以在枚举 $j$ 的同时双指针得到。

时空复杂度 $O(n^2)$。

```cpp
namespace khin { namespace main {
  constexpr lu const mod(20'060'723);
  constexpr hu const n_max(5'000);
  hu n; lu a[n_max + 1]; lu f[n_max + 1][n_max + 1], h[n_max + 1][n_max + 1]; lu ans;
  inline void main(dint, char*[]) {
    get(n); for (size_t i(1); i <= n; ++i) get(a[i]); sort(a + 1, a + n + 1);
    {
      lu pow(1);
      for (size_t i(2); i <= n; pow = pow * 2 % mod, ++i) ans = (ans + (1ull * (i + 1) * pow % mod - 1 + mod) * a[i]) % mod;
    }
    for (size_t i(1); i <= n; ++i) for (size_t j(1), k0(i); j < i; ++j) {
      while (k0 && a[k0] + a[j] > a[i]) --k0;
      size_t const k(min(k0, j - 1));
      f[i][j] = (f[j][k] + h[j][k] + 2) % mod, h[i][j] = (h[j][k] + 1) % mod;
      ans = (ans - 1ull * f[i][j] * a[i] % mod + mod) % mod;
      f[i][j] = (f[i][j - 1] + f[i][j]) % mod, h[i][j] = (h[i][j - 1] + h[i][j]) % mod;
    }
    put(ans, '\n');
  }
} }
```

---

## 作者：Kazdale (赞：5)

思路：DP + BIT

- ## 分析

	首先因为与位置无关，所以我们可以对数组进行升序排序，这样只需要保证 $\exists\;i,\;j,\;k$ 使得 $i < j < k\;\wedge\;a_i + a_j > a_k$ 即可。
    
   计算有趣程度和相当于计算方案数，于是思考 DP。
   
   发现正着算不是很好算，于是考虑用所有取法的有趣程度和减去非法取法的有趣程度和即可。
   
   很顺的思路是把最大值和数量都计入状态，但是稍微手推一会转移方程可以发现显然需要将次大值存入状态否则转移将为 $\mathcal{O(n^2)}$ 的。于是将最大值和次大值存入状态，考虑如何不借助蓬莱玉枝的数量计算有趣程度和。
   
   发现若取了一个新的蓬莱玉枝，那么所有方案中的玉枝总数都要加一，相当于加一个方案数，那么蓬莱玉枝的总数就等于转移来的蓬莱玉枝总数和加上总方案数，如果能求出蓬莱玉枝的总数，那么由于最大值在状态中，所以有趣程度和也可以计算出来。
   
   于是就可以列出转移方程，设 $f_{i,j}$ 表示最大值为 $a_j$，次大值为 $a_i$ 的非法取法中方案的总数，$g_{i,j}$ 表示最大值为 $a_j$，次大值为 $a_i$ 的非法取法中蓬莱玉枝的总数，特别地，若不存在次大值，那么 $i=0$，则有：
   
   $$f_{i,j} = \sum_{k}^{i-1}f_{k,i}(a_k + a_i \leq a_j)$$
   
   $$g_{i,j} = \sum_{k}^{i-1}(g_{k,i}+f_{k,i})(a_k + a_i \leq a_j)$$
  
 	边界条件为 $\forall i \in [1,n],\;f_{0,i}=g_{0,i}=1$。
   
   然后研究所有取法的有趣程度和如何计算，不难推出式子：
   
   $$ans = \sum_{i=1}^n\sum_{j=0}^{i-1} \binom{i-1}{j-1} \times (j + 1) \times a_i$$
   
- ## 优化时间

	本题解讲的是 $\mathcal{O(n^2 \log n)}$ 解法，若想学习 $\mathcal{O(n^2)}$ 解法请移步至其他题解。
    
   由移项得，满足能转移到 $i,j$ 的所有 $k$ 需要满足 $a_k \leq a_j - a_i$。
   
   那么我们只需要二分找到最后一个小于等于 $a_i - a_j$ 的 $a$，然后将 DP 值转移到这个 $a$ 上。
   
   因为可能会有多个 $a_i$ 相等，所以对于查询也要二分找到最后一个小于等于 $a_i$ 的值，否则可能就会查询不到一些可以转移的 DP 值。
   
- ## 优化空间

	首先 $20060723$ 是合数，所以需要一个 $5000 \times 5000$ 的数组预处理组合数。
    
   其次对于两个 DP 值，我们各需要一个 DP 数组和一个 BIT 数组，所以还需要四个 $5000 \times 5000$ 的数组。
   
   发现我们最多同时需要两个数组（DP 的时候需要一个 DP 数组和一个 BIT 数组），所以我们可以对数组进行复用，这样就只需要开两个 $5000 \times 5000$ 的数组就可以了。
   
   特别地，我们发现 $g$ 转移的就是 $\sum (f + g)$，所以我们在转移 $g$ 的时候不需要清空 BIT 数组，直接在上面加上 $g$ 值即可。
   
- ## 优化常数

	发现此题需要很多取模，于是考虑取模优化。
    
   因为大部分操作都是加法，所以我们可以判两个数的和是否大于等于 $20060723$，如果大于等于，就将和减去一个 $20060723$，可以证明若前面的两个数小于 $20060723$，操作后的数也一定小于 $20060723$。
   
   这样就将大常数的取模变为了小常数的减法，最后时间复杂度 $\mathcal{O(n^2 \log n)}$，空间复杂度 $\mathcal{O(n^2)}$，可以通过本题。
   
- ## 代码

```
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
constexpr int MAXN(5007);
constexpr int mod(20060723);
int sum[MAXN][MAXN], f[MAXN][MAXN];
int a[MAXN];
int n, ans1, ans2, tmp;
struct PRE_BIT{
	int tr[MAXN];
	PRE_BIT() { memset(tr, 0, sizeof(tr)); }
	inline int lowbit(int x) { return x & -x; }
	inline void update(int x, int val) {
		for (int i(x); i <= n + 1; i += lowbit(i)) {
			tr[i] += val;
			if (tr[i] >= mod)  tr[i] -= mod;
		}
	}
	inline int query(int x) {
		int res(0);
		for (int i(x); i; i -= lowbit(i)) {
			res += tr[i];
			if (res >= mod)  res -= mod;
		}
		return res;
	}
}Luka[MAXN];
inline void read(int &temp) { cin >> temp; }
inline int max(long long x, long long y) { return (x > y) ? x : y; }
signed main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	read(n);
	for (int i(1); i <= n; ++i)  read(a[i]);
	sort(a + 1, a + n + 1);
	for (int i(0); i <= n; ++i)  sum[0][i] = 1;
	for (int i(1); i <= n; ++i) {
		for (int j(1); j <= i; ++j) {
			sum[j][i] = sum[j - 1][i - 1] + sum[j][i - 1];
			if (sum[j][i] >= mod)  sum[j][i] -= mod;
		}
	}
	for (int i(1); i <= n; ++i)
		for (int j(0); j <= i - 1; ++j)  ans1 = (ans1 + 1ll * sum[j][i - 1] * (j + 1ll) % mod * a[i] % mod) % mod;
	memset(sum, 0, sizeof(sum));
	for (int i(0); i <= n; ++i) {
		for (int j(i + 1); j <= n; ++j) {
			if (!i)  sum[i][j] = 1;
			else  sum[i][j] = Luka[i].query(upper_bound(a + 1, a + n + 1, a[j] - a[i]) - a);
			Luka[j].update(upper_bound(a + 1, a + n + 1, a[i]) - a - 1 + 1, sum[i][j]);
		}
	}
	for (int i(0); i <= n; ++i) {
		for (int j(i + 1); j <= n; ++j) {
			if (!i)  sum[i][j] = 1;
			else  sum[i][j] = Luka[i].query(upper_bound(a + 1, a + n + 1, a[j] - a[i]) - a);
			Luka[j].update(upper_bound(a + 1, a + n + 1, a[i]) - a - 1 + 1, sum[i][j]);
		}
	}
	for (int i(0); i <= n; ++i) {
		for (int j(i + 1); j <= n; ++j) {
			ans2 = ans2 + 1ll * sum[i][j] * a[j] % mod;
			if (ans2 >= mod)  ans2 -= mod;
		}
	}
	cout << (ans1 - ans2 + mod) % mod << endl;
	return 0;
}
```

---

## 作者：wxkk (赞：4)

首先注意到一种方案中三边的偏序关系一定，故为了转移方便，我们对 $ a $ 数组从大到小排序。
 
发现正着算不方便，考虑用所有方案的贡献减去“不合法（无聊的）”方案所带来的贡献。
-  ### 状态设计
由于贡献的计算需要知道选择的数量 $ k $ 和最长的长度 $ m $ ，又考虑到方案是否合法的判断需要三条边的大小关系，设计状态为 $ f_{i,j} $ 表示最大的边为 $ a_j $ ，次大的边为 $ a_i $ 的**所有方案的长度之和**，显然要求 $ i < j $ ， $ g_{i, j} $ 表示最大的边为 $ a_j $ ，次大的边为 $ a_i $ 的方案数。

 - ### 状态转移
 
 考虑当前状态可以转移到哪些状态，显然有 
  	$ (i, j) \rightarrow (j, k) $ $ | $ ( $ a_i + a_j \le a_k $ )。

即 

(1)  $ f_{j, k} \leftarrow f_{j, k} + f_{i, j} + g_{i, j} $ ,  


(2)  $ g_{j, k} \leftarrow g_{j, k} + g_{i, j} $  $ | $ ( $ a_i + a_j \le a_k $ )。

总方案的贡献和：
$$ \sum_{i=1}^n\sum_{j=1}^ia_i \times j \times \tbinom{i-1}{j-1}$$

初始化： 
$$ f_{0, i} = g_{0, i} = 0 $$
目标： 
$$ \sum_{i=1}^n \sum_{j=0}^{i-1}a_i \times f_{j, i} $$

  ##### 转移细节 

1.  循环 $ j $ 时 $ k $ 的决策单调递增。
2. 每次向一段后缀区间转移，即
 $f_{i, j} \rightarrow f_{j, k}$ | $(1 \le k \le n \land a_i + a_j \le a_k)$
，可用前缀和优化。
2. 可以边转移边计算。

- ### 代码


```cpp
#include <bits/stdc++.h>
#define For(i, l, r) for (int i = (l); i <= (r); i ++ ) 
#define Fer(i, r, l) for (int i = (r); i >= (l); i -- )
// #define int long long
using namespace std;
typedef long long LL;
typedef __int128 LLL;
typedef unsigned long long ULL;
typedef pair<int, int> PII;
typedef pair<LL, LL> PLL;
typedef pair<ULL, ULL> PUU;
const int N = 1e4 + 10, M = 5e5 + 10;
const LL INF = 2e18;
const int mod = 20060723;

int read()
{
    int x = 0, k = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') k = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
    return x * k;
}

void write(int x)
{
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int n;
int a[N];
int f[N][N], g[N][N];
int C[N][N];

signed main()
{
    // freopen("S.in", "r", stdin);
	n = read();
	LL tot = 0, sub = 0;
    For (i, 1, n) a[i] = read(), f[0][i] = g[0][i] = 1;
	sort(a + 1, a + n + 1);
	C[0][0] = 1;
	For (i, 1, n) For (j, 0, i) 
		if (!j) C[i][j] = 1;
		else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;	
	For (i, 1, n) 
	{
		int k = i + 1;
		For (j, 0, i - 1) 
		{
			if (j) f[j][i] = (f[j][i] + f[j][i - 1]) % mod, g[j][i] = (g[j][i - 1] + g[j][i]) % mod;
			while (k <= n && a[i] + a[j] > a[k]) k ++ ;
			if (k <= n) f[i][k] = (f[i][k] + f[j][i] + g[j][i]) % mod, g[i][k] = (g[i][k] + g[j][i]) % mod;
			sub = (sub + 1ll * f[j][i] * a[i]) % mod;
		}
	}
	For (i, 1, n) For (j, 1, i) tot = (tot + 1ll * C[i - 1][j - 1] * j % mod * a[i] % mod) % mod;
	printf("%lld\n", (tot - sub + mod) % mod);	
    return 0;
}
```



---

## 作者：大眼仔Happy (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6525)

模拟赛放了这题，感觉很简单啊！

这种题就是很难从正面突破啊，那就正难则反。

首先给 $a$ 排个序，考虑设 $f_{i, j}$ 表示最大的为 $a_i$，次大的为 $a_j$ 的不合法方案数的长度总和，哦当然还要设 $g_{i, j}$ 表示方案个数总和。

$$
f_{i, j}\gets \sum_{a_k \le a_i - a_j} f_{j, k} + g_{j, k} \\

g_{i, j}\gets \sum_{a_k \le a_i - a_j} g_{j, k}
$$

那么合法的 $k$ 就是一段前缀嘛，二分求一下 $k$，然后前缀和维护就好了。

至于总方案，假设选择的最大的为 $i$，那么 $i$ 是必选的，然后因为方案数为 $2 ^ {i - 1}$，所以就贡献 $2 ^ {i - 1}$。对于前面的 $i - 1$ 个数，有一半可能贡献，那么就是 $(i - 1) 2 ^ {i - 2}$，所以总的来说就是 $(i + 1) 2 ^ {i - 2}$。

时间复杂度 $O(n ^ 2\log n)$。

不知道会不会卡，那就双指针一下 $O(n ^ 2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e3 + 5;
#define ll long long
int inline read() {
	int num = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		num = (num << 3) + (num << 1) + (ch ^ 48);
		ch = getchar();
	}
	return num * f;
}
int n, P, ans; 
int pw[N], a[N], f[N][N], g[N][N];
int inc(const int &x, const int &y) { int res = x + y; if(res >= P) res -= P; return res; }
void binc(int &x, const int &y) { x += y; if(x >= P) x -= P; }
int main() {
#ifdef file
	freopen("P6525.in", "r", stdin);
	freopen("P6525.out", "w", stdout);
#endif
	n = read(), P = read();
	for(int i = 1; i <= n; ++i) a[i] = read();
	sort(a + 1, a + 1 + n);
	for(int i = 0; i <= n; ++i) f[0][i] = 1; 
	for(int i = 1; i <= n; ++i) {
		f[i][0] = g[i][0] = 1; 
		int k = 0; 
		for(int j = i - 1; j; --j) {
			--k; 
			while(k + 1 < j && a[k + 1] <= a[i] - a[j]) ++k;
			g[i][j] = g[j][k];
			f[i][j] = inc(f[j][k], g[j][k]);
		}
		/*
		for(int j = 1; j < i; ++j) {
			int k = upper_bound(a + 1, a + 1 + n, a[i] - a[j]) - a - 1; 
			printf("%d ", k);
			k = min(j - 1, k);
			g[i][j] = g[j][k];
			f[i][j] = inc(f[j][k], g[j][k]);
		}
		printf("\n");
		*/
		for(int j = 1; j <= n; ++j) binc(f[i][j], f[i][j - 1]), binc(g[i][j], g[i][j - 1]);
	}
	pw[2] = 1; 
	for(int i = 3; i <= n; ++i) pw[i] = inc(pw[i - 1], pw[i - 1]);
	for(int i = 2; i <= n; ++i) {
		int cnt = (1ll * (i + 1) * pw[i] + P - f[i][i]) % P; 
		ans = (ans + 1ll * cnt * a[i]) % P; 
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

貌似还没有和我做法一样的题解，发一篇吧！

我们考虑 $dp_{i,j}$ 表示选出来的数中最大的为 $a_i$，次大的为 $a_j$ 时的**构不成三角形的**方案个数，$t_{i,j}$ 表示方案长度之和，显然全部方案数可以简单地算出，状态转移方程为：

$$dp_{l,i}=dp_{l,i}+dp_{i,j},t_{l,i}=t_{l,i}+t_{i,j}+dp_{i,j}$$

发现这玩意可以单调队列优化一下，再套个前缀和，均摊复杂度 $O(n^2)$。

代码：

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define rep(i,x,y,z) for(int i=(x);i<=(y);i+=(z))

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=20060723;
const long double EPS=1e-7;
const int MAXN=5010;

long long a[MAXN];
int dp[MAXN][MAXN];
int t[MAXN][MAXN];
int C[MAXN][MAXN];
int diffDp[MAXN][MAXN];
int diffT[MAXN][MAXN];
int Sumdp[MAXN];
int SumT[MAXN];

signed main()
{
	ios::sync_with_stdio(false);

	int n;

	cin>>n;

	for(int i=1;i<=n;i++)
		cin>>a[i];

	C[0][0]=1;

	for(int i=1;i<=n;i++)
	{
		C[i][0]=1;

		for(int j=1;j<=i;j++)
		{
			C[i][j]=C[i-1][j-1]+C[i-1][j];

			C[i][j]%=MOD;
		}
	}

	sort(a+1,a+1+n);

	long long ans=0;
	//int beg=3;

	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i-1;j++)
		{
			dp[i][j]=1,t[i][j]=2;

			ans+=((1ll*C[i-1][j])*(((j+1)*(a[i]%MOD))%MOD));
			ans%=MOD;
		}
	}

	//cout<<ans<<endl;

	//dp[2][1]=1;

	for(int i=1;i<=n;i++)
	{
		int beg=i+1;

		for(int j=1;j<=i-1;j++)
		{
			Sumdp[j]+=diffDp[i][j];
			SumT[j]+=diffT[i][j];
			Sumdp[j]%=MOD;
			SumT[j]%=MOD;
			dp[i][j]+=Sumdp[j];
			t[i][j]+=SumT[j];
			dp[i][j]%=MOD;
			t[i][j]%=MOD;

			beg=max(beg,i+1);

			for(int l=beg;l<=n;l++)
			{
				if(a[i]+a[j]<=a[l])						//a[i]+a[j]单调不下降
				{
					diffDp[l][i]+=dp[i][j],diffT[l][i]+=t[i][j]+dp[i][j];
					beg=l;
					diffDp[l][i]%=MOD;
					diffT[l][i]%=MOD;

					break;
				}
				else
				{
					beg=l;
				}
			}
		}
	}

	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i-1;j++)
		{
			t[i][j]%=MOD;

			ans-=(1ll*t[i][j]*(a[i]%MOD))%MOD;
			ans+=MOD;
			ans%=MOD;
			//cout<<dp[i][j]<<" ";
		}

		//cout<<endl;
	}

	cout<<(ans+MOD)%MOD<<endl;

	return 0;
}
```

---

## 作者：Wf_yjqd (赞：0)

不需要什么优化，不过转移有点烦。

---

显然可以对 $a$ 排序，然后从小到大选。

如何判断是否存在能构成三角形的三条边？

考虑枚举最大边，根据两边之和大于第三边，最好的情况一定选择比他小的边中最大的两条。

据此设出状态 $f_{i,j,0/1}$ 表示前 $i$ 条边中选择的最大两条边为 $i$ 和 $j$，是否构成三角形的方案数。

发现转移过程中好像还需要枚举一维 $k$ 然后从 $f_{j,k,0/1}$ 转移过来。

如果我们按是否能构成三角形（比较 $a_j+a_k$ 和 $a_i$）把 $k$ 分成两类。

临界的 $k$ 的取值会随着 $j$ 的增加而减少，所以枚举 $j$ 和 $k$ 的整体复杂度是 $\operatorname{O}(n)$。

每类 $k$ 的取值都是连续的，转移都是相同的，所以可以前缀和优化。

同时选中的边的最大值也能得到，就差选择边的个数了。

用 $g_{i,j,0/1}$ 表示前 $i$ 条边中选择的最大两条边为 $i$ 和 $j$，是否构成三角形的所有方案中边数的和。

每次转移时每种方案都会增加一条边，所以总边数增加方案数条。与 $f$ 类似地使用前缀和优化下。

总体复杂度 $\operatorname{O}(n^2)$。

---

注意事项：

+ 还有一种特殊情况是从一条边没选的状态转移来，答案显然。
+ 发现所有的转移都只需要前缀和，此题有点卡空间，若开不下前缀和数组可考虑直接覆盖原 dp 数组。
+ 多模。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=5e3+26,mod=20060723;
int n,a[maxn],f[maxn][maxn][2],g[maxn][maxn][2];
ll ans;
inline void M(auto &x){
    (x=x%mod+mod)%=mod;
    return ;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    f[2][1][0]=1;
    g[2][1][0]=2;
    for(int i=3;i<=n;i++){
        for(int j=i-1,k=0;j;j--){
            f[i][j][0]=1;
            g[i][j][0]=2;
            while(k+1<j&&a[k+1]<=a[i]-a[j])
                k++;
            if(k>j-1)
                k=j-1;
            if(k){
                M(f[i][j][0]+=f[j][k][0]);
                M(g[i][j][0]+=g[j][k][0]+f[j][k][0]);
            }
            f[i][j][1]=f[j][j-1][1];
            M(g[i][j][1]=g[j][j-1][1]+f[j][j-1][1]);
            M(f[i][j][1]+=f[j][j-1][0]-f[j][k][0]);
            M(g[i][j][1]+=f[j][j-1][0]-f[j][k][0]+g[j][j-1][0]-g[j][k][0]);
            M(ans+=1ll*a[i]*g[i][j][1]);
            // printf("%d %d %d %d %d %d %d %d\n",i,j,k,a[i],f[i][j][1],g[i][j][1],f[i][j][0],g[i][j][0]);
        }
        for(int j=2;j<=i-1;j++){
            M(f[i][j][0]+=f[i][j-1][0]);
            M(f[i][j][1]+=f[i][j-1][1]);
            M(g[i][j][0]+=g[i][j-1][0]);
            M(g[i][j][1]+=g[i][j-1][1]);
        }
    }
    printf("%lld",ans);
    return 0;
}
/*
f[i][j][0/1] 前 i 个，选 i，上个选 j，是否已构成三角形的方案数
f[i][j][0]=/sum a[k]<=a[i]-a[j] (f[j][k][0])
f[i][j][1]=/sum a[k]<=a[i]-a[j] (f[j][k][1]) + /sum a[k]>a[i]-a[j] (f[j][k][0/1])
g[i][j][0/1] 前 i 个，选 i，上个选 j，是否已构成三角形的所有方案的个数和
g[i][j][0]=/sum a[k]<=a[i]-a[j] (g[j][k][0]+f[j][k][0])
g[i][j][1]=/sum a[k]<=a[i]-a[j] (g[j][k][1]+f[j][k][1]) + /sum a[k]>a[i]-a[j] (g[j][k][0/1]+f[j][k][0/1])
*/
```

---


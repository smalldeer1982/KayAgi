# [COCI 2019/2020 #2] Zvijezda

## 题目描述

Mirko 和 Slavko 正在通过玩多边形和观看新一季的《The Biggest Loser》来打发空闲时间。Mirko 最近画了一个有偶数个顶点 $N$ 的凸多边形。然后 Slavko 考虑每对相对的边（如果两边之间有 $\frac N2 - 1$ 条边，则它们是相对的），画出位于这些边上的直线，并将它们与包含多边形的平面部分一起着色。最后，Mirko 找到了一组 $Q$ 个点，并决定挑战 Slavko，要求他回答每个点是位于着色部分还是未着色部分。新的《The Biggest Loser》剧集即将开始，Slavko 没有时间回答 Mirko 的查询。你能帮助他吗？

## 说明/提示

#### 数据规模及约定

本题采用捆绑测试。

| Subtask 编号 | 分值 | 数据范围 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $20$ | $1 \le n, q \le 2000$，$T = 0$|
| $2$ | $30$ | $1 \le n, q \le 10^5$，$T = 0$|
| $3$ | $60$ | $1 \le n, q \le 10^5$，$T = 1$|。

此外，对于 $100\%$ 的数据，$0 \le |x_i|, |y_i| \le 10^9, 0 \le |a_i|, |b_i| \le 2 \times 10^{18}$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #2](https://hsin.hr/coci/archive/2019_2020/contest2_tasks.pdf) *T5 Zvijezda*。**

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
0
4
1 1
5 1
4 3
2 2
4
3 2
2 4
6 2
4 5
```

### 输出

```
DA
NE
DA
NE```

## 样例 #2

### 输入

```
0
6
-1 -1
2 -1
3 3
2 4
1 4
-2 1
6
2 2
3 0
1 -6
2 6
-5 5
5 10
```

### 输出

```
DA
DA
NE
NE
NE
NE```

## 样例 #3

### 输入

```
1
6
-1 -1
2 -1
3 3
2 4
1 4
-2 1
6
2 2
3 0
1 -6
2 6
-5 5
5 10
```

### 输出

```
DA
DA
DA
NE
NE
NE```

# 题解

## 作者：Lieyiqi (赞：1)

设 $A_i$ 表示输入多边形中的第 $i$ 个 $(\bmod{n})$ 点，$X$ 表示 ```Mirko``` 的查询点。如果 $\operatorname{ccw}(A_i,A_i+1,X)>0$，则在我们的多边形的第 $i$ 条边上写入 $1$，否则写入 $0$。


那么现在有一个问题，“是否存在一对相反的边，但它们都写有 $1$”。

显然，不能暴力对每个查询都检查每条边上写的内容，因为这将导致 $O(nq)$ 的算法复杂度。所以我们要创造一个高效的算法来解决这个问题。

不难看出，如果两条边上都写有 $1$，则它们之间的所有边（在一个方向上）也都写有 $1$。

另外的，只有当一段连续的 $1$ 的区间包含至少 $\dfrac{n}{2}+1$ 个元素时，答案才是 ```DA```。这是显而易见的，因为在 $\dfrac{n}{2}+1$ 个连续的边中必定存在两条相对的边。现在，我们考虑一条任意的边及其相反边，并观察它们上写的值。如果它们都写有 $1$，则可以直接输出 ```DA```。如果它们都写有 $0$，则可以直接输出 ```NE```。如果其中一条边写有 $1$，另一条边写有 $0$，则我们可以将数组分为两部分，每部分以我们已检查的一条边开头。一部分的形式 ```111...000```，另一部分的形式为 ```000...111```。我们想在其中一部分找到最后一个 $1$，在另一部分找到第一个 $1$。这可以用二分搜索快速完成。现在，我们已经找到了一个连续的 $1$ 的区间的端点，并且可以检查条件是否成立。

时间复杂度：$O(\operatorname{q}\log{n})$。


```cpp
// VS Code C/C++
#include<iostream>
#include<cmath>
#include<vector>

#define I using
#define AK namespace
#define NOIP std;
#define f1 first
#define s2 second
#define db double
#define pb push_back
#define FOR(i,a,b) for(int i=a;i<b;i++)
I AK NOIP

typedef long long ll;
typedef pair<ll,ll> pll;

int n;
vector<pll> py;
ll x,y;

inline db cmp(pll a,pll b,pll c){
	return db(a.f1)*(b.s2-c.s2)+
	db(b.f1)*(c.s2-a.s2)+
	db(c.f1)*(a.s2-b.s2);
}

inline bool get(int i){
	return cmp(py[i],py[(i+1)%n],{x,y})>=0;
}

const string o[]={"NE","DA"};

inline int mj(int l,int r){
	int li=l,hi=r,mid;
	while(li!=hi){
		mid=(li+hi+1)/2;
		if(get(mid)==get(l)) li=mid;
		else hi=mid-1;
	}
	int ret=li-l+1;
	if(!get(l)) ret=n/2-ret;
	return ret;
}

inline bool solve(){
	int mid=n/2;
	int a=get(0);
	int b=get(mid);
	if(a==b) return a;
	return mj(0,mid-1)+mj(mid,n-1)>mid;
}
signed main(){
	ios::sync_with_stdio(false);
	int t;
	cin>>t>>n;
	FOR(i,0,n){
		cin>>x>>y;
		py.pb({x,y});
	}
	int q;
	ll da=0;
	cin>>q;
	FOR(i,0,q){
		cin>>x>>y;
		x^=da*da*da*t;
		y^=da*da*da*t;
		int ans=solve();
		da+=ans;
		cout<<o[ans]<<'\n';
	}
	return 0;
}


```


---

## 作者：Fool_Fish (赞：0)

有趣。。。

首先设这些边的编号为 $1$~$n$ ，一个点被相对的两条边包含，即一个点被编号相距 $\frac{n}{2}$ 的两条边包含

每条边都可以把整个平面分为两部分：有多边形的和没有多边形的，我们称有多边形的这一个区域为在这条线的“内部”

那么这个点需要同时满足在编号相距 $\frac{n}{2}$ 的两条边的 “内部”，设这两条边为 $x,x+\frac{n}{2}$ （需要膜的请大家自行脑补）

所以如果这个点被 $x,x+\frac{n}{2}$ 包含，那么说明这个点同时在$x,x+\frac{n}{2}$两条直线的 “内部”，又由于这是凸多边形，所以这个点一定同时在 $x$到$x+\frac{n}{2}$ 所有直线的 “内部”

接下来讲一讲怎么实现：

首先任选一条边，为了方便，选为 $1$

拿到这条边的对边 $1+\frac{n}{2}$

判断这这个点是否同时在两条边的内部，如果都在，则是可以的，如果都不在，则一定不可以

否则的话，也就是一边可以一边不可以，那么必然是这样的情况：

![](https://img-blog.csdnimg.cn/img_convert/f83638e4fdf617fee923c3c4b1976b17.png)

如图，红色的线表示这个点在这条线的外部，绿色表示在内部

那么，中间一定有且只有一个分界点

我们只需要从可以的那一条边开始（上图是 $1$）开始，找到一个最远的可以的边（上图是 $3$）,接下来，重新反向去找这条边的对面的边，判断这两条边是否可以，最终的答案就是这样的。

最后放一下代码：

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int MAXN=1e5+5;
int n,m,q,k;
int len;
vector<int> g[MAXN];
void add(int u,int v){
	g[u].push_back(v);
}
queue<int> p;
int ans[MAXN],sum,Now=0;
bool vis[MAXN];
void bfs(){
	while(sum){
		Now++;
		for(int step=1;step<=Now*k;step++){
			for(int i=1,Size=p.size();i<=Size;i++){
				int u=p.front();
				p.pop();
				for(int j=0;j<g[u].size();j++){
					int v=g[u][j];
					if(vis[v]==1){
						continue;
					}
					vis[v]=1;
					ans[v]=Now;
					sum--;
					p.push(v);
				} 
			}
		}
	}
}
int main(){
	scanf("%d %d %d %d",&n,&m,&q,&k);
	sum=n-q;
	for(int i=1;i<=q;i++){
		int x;
		scanf("%d",&x);
		vis[x]=1;
		ans[x]=0;
		p.push(x);
	}
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		add(x,y);
		add(y,x);
	}
	bfs();
	for(int i=1;i<=n;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}
```

---

## 作者：Niko！ (赞：0)

考虑对于哪些边，这个点在这条边的多边形所在的那一侧，如果有一对对边满足，那就满足题意。

我们发现这样的边是一个（环上的)连续段，也就只需要检查这个连续段长度是否达到 $\frac{n}{2}$

因为是环不太好处理，我们可以先做一点微小的工作，检查第 $1$ 条边和 $\frac{n}{2}+1$ 条边是否满足。如果都满足显然 YES，都不满足 NO，否则只有一个满足，我们可以从不满足的那个向满足的那个倍增（二分也可以），找到最远的满足的位置，检查它和它的对边是否都满足即可。

```
#include <bits/stdc++.h>
#define ll long long
#define maxn 100005
ll x[maxn],y[maxn],xt,yt,xorv;
int n,q,t;

int check(ll x1,ll y1,ll x2,ll y2,ll x3,ll y3) {
	return (__int128)(x1-x3)*(y2-y3)-(__int128)(y1-y3)*(x2-x3)>=0;
}

int chk(int p,ll xt,ll yt) {
	return check(x[p],y[p],x[p%n+1],y[p%n+1],xt,yt);
}

int inc(int x,int y) {
	return (x+y-1)%n+1;
}

ll cube(ll x){
	return x*x*x;
}

int main(){
//	freopen("in.txt","r",stdin);
	scanf("%d",&t);
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld%lld",&x[i],&y[i]);
	scanf("%d",&q);
	for(int i=1;i<=q;++i){
		scanf("%lld%lld",&xt,&yt);
		if (t) {
			xt ^= cube(xorv);
			yt ^= cube(xorv);
		}
	//	for(int i=1;i<=n;++i)printf("%d",chk(i,xt,yt));puts("");
		int d1 = chk(1,xt,yt), d2 = chk(n/2+1,xt,yt);
		if (d1 && d2) { puts("DA"); xorv++; continue; }
		if (!d1 && !d2) { puts("NE"); continue; }
		int u = d1 ? 1 : n/2+1;
	//	printf("%d -> ",u);
		int sum = 0;
		for (int i = 17; i >= 0; i --) {
			if ( sum + (1<<i) < n/2 && chk(inc(u,(1<<i)),xt,yt)) {
				u = inc(u,1<<i);
				sum += (1<<i);
			}
		} //printf("%d\n",u); 
		if (chk(inc(u,n/2),xt,yt)) { puts("DA"); xorv++; }
		else puts("NE");
	}
	return 0;
}
```




---


# 「StOI-2」好多表达式

## 题目背景

本题为 [StOI](https://www.luogu.com.cn/team/24701) 第二场公开赛 [StOI Round2](https://www.luogu.com.cn/contest/32483) 之第一题.

__注意:如果这个数是一个多位数，不会将它拆开__ By LHQing ,14:09

:)

## 题目描述

给定一个仅由数字、`+`、`*` 组成的表达式，请求出它的所有子表达式运算值之和对 $998,244,353$ 取模的结果。

一个表达式的子表达式定义为 `一段连续的数字与其中的运算符构成的表达式` 。

如果您仍然无法理解，**可以参看样例解释**。

## 说明/提示

## 样例解释

所给定的表达式共有六个子表达式：
$1$、$2$、$3$、$1+2$、$2 \times 3$、$1+2 \times 3$ ，值分别为 $1$、$2$、$3$、$3$、$6$、$7$ ，和为 $22$ 。

---

## 数据范围

对于 $20\%$ 的数据：$1 \leq n \leq 1000$ 。   
对于另 $20\%$ 的数据：不存在 `+` 。  
对于另 $20\%$ 的数据：仅存在一个 `+` 。   
对于另 $20\%$ 的数据：仅存在一个 `*` 。   
对于 $100\%$ 的数据：$1 \leq n \leq 10^{5}$ ，所有数字均不大于 $10^{9}$ ，运算符只包含 `+` 、`*` 。

## 样例 #1

### 输入

```
3
1 + 2 * 3```

### 输出

```
22```

## 样例 #2

### 输入

```
6
1 * 1 * 4 * 5 * 1 * 4```

### 输出

```
414```

## 样例 #3

### 输入

```
3
16 + 750 + 7```

### 输出

```
3069```

# 题解

## 作者：lndjy (赞：9)

首先，`所有子表达式运算值之和` 的意思就是所有区间的运算和，这样表述下文方便。

考虑在一个表达式后面，加上一个符号和一个数字，这对答案有什么贡献。

数字 $a_i$ 对答案有贡献的区间是 $[1,i],[2,i]...[i,i]$。其他的区间前面计算好了，不需要考虑。

先考虑没有加号的情况。对于前面的每个区间，都是乘了 $a_i$，根据乘法分配律，也就是对前面的积乘 $a_i$。然后加上 $[i,i]$ 本身，也就是 $a_i$。

然后考虑加号有什么影响。

首先，就加号本身而言，是对前面的所有区间产生了 $+a_i$ 的贡献，这个很好理解。然后在后面的计算中，碰到加号时，对最近一个加号以前的数字没有乘的贡献，但是有加上目前这段连续乘的贡献。

用两个变量模拟当前连续乘乘和累加的结果，然后按照上文计算贡献即可。

代码：

```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+5,p=998244353;
int a[N],n;
char c[N];
signed main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	cin>>a[i]>>c[i];
	cin>>a[n];
	bool flag=0;
	int mul=1,sum=0,ans=0;
	for(int i=1;i<=n;i++)
	{
		if(flag) mul=(mul*a[i]+a[i])%p;
		else mul=(i*a[i])%p;
		flag=1;
		ans=(ans+mul+sum)%p;
		if(c[i]=='+')
		{
			flag=0;
			sum=(sum+mul)%p;
		}
	}
	cout<<ans;
	return 0;
}
```

题外话:考虑加上一步有什么贡献，这是一个很常见的套路。CSP的括号树，NOIO的优秀子序列。都是这个思想。

---

## 作者：LeavingZzz (赞：2)

## $\mathsf{Solution\space For \space P6796}$  
### $\mathsf{Description}$  
给定一个数字个数为 $N$ 的由数字和 `+` 以及 `*` 组成的表达式，求这个表达式所有子表达式的值的和  
结果对 $998244353$ 取模  
$1\le N \le10^5$  
### $\mathsf{Analysis}$  
前言：这里说的符号均对应输入中每个符号**后面**的那个数字的编号  
例如 $1+2\times 3$ 加号是第 $2$ 个，乘号是第 $3$ 个
#### 首先我们来看一种只有加号的情况如何递推式求解。 
设 $f[i]$ 为前 $i$ 个数字组成的表达式的所有子表达式值之和。  

设 $d[i]$ 为 $\sum\limits_{j=1}^{i}\sum\limits_{k=j}^i a_k$ （以 $a_i$ 结尾的 $i$ 个表达式的和）。  

容易发现  
$$d[i]=d[i-1]+i\times a_i,f[i]=f[i-1]+d[i-1]+i\times a_i=f[i-1]+d[i]$$  

（感性理解一下就是前 $i-1$ 个位置延伸到第 $i-1$ 个位置有 $i-1$ 个表达式，现在这些表达式最后要加上 $a_i$，然后 $a_i$ 自己也是一个表达式，于是就加上了 $i\times a_i$）  



------------
#### 考虑出现全部是乘号的情况。  
 

模仿只有加法的情况  

设 $f[i]$ 为前 $i$ 个数字组成的表达式的所有子表达式值之和。  

设 $p[i]$ 为 $\sum\limits_{j=1}^{i}\prod\limits_{k=j}^i a_k$ （以 $a_i$ 结尾的 $i$ 个表达式的和，因为这里只有乘号所以 $\sum$ 便乘了 $\prod$）。  

容易发现  
$$p[i]=p[i-1]\times a_i+a_i,f[i]=f[i-1]+a_i+p[i-1]\times a_i=f[i-1]+p[i]$$  
（前 $i-1$ 个表达式乘入 $a_i$ 的同时 $a_i$ 自成一个表达式）


------------
#### 考虑加乘混合的情况，先考虑有一个乘号的情况。  

实际上乘法可以用分配律便乘加法，$a\times b=a+(b-1)\times a$。  

所以在第 $i$ 个数字前面出现一个乘号的时候可以视为加上 $a_{i-1}\times(a_i-1)$，套上只有加号的解法即可。  
#### 考虑加乘混合的情况，多个乘号  

模仿一个乘号的情况，用乘法分配律把乘法拆成加法，但是这里就不能直接加上 $a_{i-1}\times (a_i-1)$  

举个例子： $1+2\times3\times4$，当在 $4$ 处的时候，我们应该加上  
$$2\times 3\times(4-1),1\sim 4$$  
$$2\times 3\times(4-1),2\sim 4$$  
$$3\times (4-1),3\sim 4$$  
$$4,4\sim 4$$  
具体怎么实现？  

因为全部是乘号的情况我们已经会了，关键在于遇到第一个乘号时的处理，在上面的例子中，第一个乘号在 $3$ 处，此时应当加上两个 $(3-1)\times 2$ 因为有两个以 $2$ 结尾的表达式（$2,1+2$），也就是说，当在 $i$ 处遇到第一个乘号时，应该加上 $(i-1)$ 个 $a_{i-1}\times(a_i-1)$  

不必特判第一个乘号，只用在每一个加号处让 $p[i]=i\times a_i$ 即可，遇到乘号的时候依然用全部乘号的 $p[i]=p[i-1]\times a_i+a_i$  

所以这里 $p[i]$ 的意义即为：以 $a_i$ 结尾的 $i$ 个表达式中每个表达式最后一段连续乘积之和

然后 $d$ 的递推在加号中仍然是 $d[i]=d[i-1]+i\times a_i$  
在乘号中便乘 $d[i]=d[i-1]+a_i+p[i-1]\times (a_i-1)$  
（$i-1$ 个表达式最后一段乘积乘上 $a_i$ 相当于加上自身的 $a_i-1$ 倍，$a_i$ 自成一个表达式）  
所以 $f$ 的递推就能从上面搬过来啦/cy  
$$f[i]=f[i-1]+d[i]$$  
### $\mathsf{Code}$  
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
using namespace std;
typedef long long LL;
const int maxn=100007;
const int mod=998244353;
LL f[maxn],d[maxn],p[maxn];
LL A[maxn];
int op[maxn];
int N;
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("1.in","r",stdin);
	#endif
	scanf("%d",&N);
	char c;
	scanf("%lld",&A[1]);
	for(int i=2;i<=N;i++)
	{
		while((c=getchar())!='+'&&c!='*');
		if(c=='*') op[i]=2;
		else op[i]=1;
		scanf("%lld",&A[i]);
	}
	f[1]=d[1]=p[1]=A[1];
	for(int i=2;i<=N;i++)
	{
		if(op[i]==1)
		{
			d[i]=(d[i-1]+i*A[i]%mod)%mod;
			p[i]=i*A[i]%mod;
			f[i]=(f[i-1]+d[i])%mod;
		}
		else
		{
			d[i]=(d[i-1]+A[i]+p[i-1]*(A[i]-1)%mod)%mod;
			p[i]=(p[i-1]*A[i]%mod+A[i])%mod;
			f[i]=(f[i-1]+d[i])%mod;
		}
	}
	printf("%lld",f[N]);
	return 0;
}
```  
然后因为 $f,d,p$ 第 $i$ 项只和 $i-1$ 项有关，可以把三个数组压缩成三个变量/cy  
加上 `fread` 快读之后卡一卡便乘了最优解/cy

---

## 作者：operator_ (赞：1)

# P6796 「StOI-2」好多表达式

[题目传送门](https://www.luogu.com.cn/problem/P6796)

## 题解

你跟我说这是蓝题？不信……

简单 dp，定义状态 $f_i$ 表示以第 $i$ 个数字结尾的表达式运算值之和，那么答案就是所有 $f$ 的和。

为了方便，我们默认第一个数字前的符号是加号。

分讨转移：

+ 第 $i$ 个符号是加号

很简单，对于以第 $i-1$ 个数字结尾的所有表达式都加上这个数即可，加上空集共有 $i$ 个，有 $f_i=f_{i-1}+(i-1)\times a+a$。

+ 第 $i$ 个符号是乘号

我们发现不好转移了，因为它不是整体乘上一个数，而是对最后一部分的**连乘**进行运算。

以样例为例：

```
1 + 2 * 3
```

以 $2$ 结尾的表达式有：$1+2$、$2$，其值之和为 $5$。

转移到以 $3$ 结尾后：$1+2\times3$、$2\times3$、$3$，其值之和为 $16$。

对比一下，有变化的是：$1+2$ 的 $2$ 变成了 $2\times3$，$2$ 变成了 $2\times3$ ，还多出了自身 $3$。

容易发现，是对最后一个加和运算的后面部分整体乘上这个数，因此我们可以记录一下当前**以第 $i$ 个数字结尾的表达式最后一部分之和** $g_i$，然后就可以方便地转移了。

$$f_i=f_{i-1}-g_{i-1}+g_{i-1}\times a+a$$

$$g_i=g_{i-1}\times a$$

对于第一种情况的 $g$ 转移很方便，不多说了。

你乐意的话可以只开变量记录，然后你就会发现做这题甚至不需要数组（笑）。

代码（本蒟蒻马蜂有点丑，轻喷）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
const int M=998244353;
int n,a;
char c;
int f,g,ans;
signed main() {
	cin>>n;
	f=g=ans=rd();
	for(int i=2;i<=n;i++) {
		cin>>c>>a;
		if(c=='+') {
			f=(f+i*a)%M;
			g=i*a%M; 
		}
		else {
			f=(f-g+g*a+a+M)%M;
			g=(g*a+a)%M;
		}
		ans=(ans+f)%M;
	}
	cout<<ans%M;
	return 0;
}

```

---

## 作者：一只书虫仔 (赞：1)

#### Description

> 给定一个只由数字，`+` 和 `*` 组成的算式，求所有子算式之和。

#### Solution

还是 dp 好理解，本题解参考 ~~誊写~~ 了 [LeavingZ](https://www.luogu.com.cn/user/215697) 巨佬的题解。

下文 $[a_l,a_r]$ 意为从第 $l$ 个数字到第 $r$ 个数字这个区间里的子表达式的结果。

首先考虑对于只有加法与乘法怎么做，设 $f_i$ 为以第 $i$ 个数字结尾的表达式的所有子表达式之和，$g_i$ 为表达式 $[a_1,a_i],[a_2,a_i],\cdots,[a_i,a_i]$ 的和，则有转移：

- 对于加法，有：
	- 对于 $g$ 数组，这 $i$ 个区间里的表达式都加上了 $a_i$，即为 $a_i \times i$：$g_i=g_{i-1}+a_i \times i$；
    - 对于 $f$ 数组，$g_i$ 即为转移量：$f_i=f_{i-1}+g_i$；
- 对于乘法，有：
	- 对于 $g$ 数组，这 $i$ 个区间里的表达式都乘上了 $a_i$，则在前 $i-1$ 个表达式转移过来时乘上 $a_i$，对于 $[a_i,a_i]$，再加上一个 $a_i$ 即可：$g_i=g_i \times a_i+a_i$；
    - 对于 $f$ 数组，$g_i$ 即为转移量：$f_i=f_{i-1}+g_i$。
    
对于如果只有一个乘号，设其为 $a_q \times a_{q+1}$，就可以将其作为 $a_q+(a_q-1) \times a_{q+1}$，当做一个加法来做了。

接下来思考正解，对于不止一个加号不止一个乘号怎么做。

考虑维护 $g'_i$ 为 $[a_1,a_i],[a_2,a_i],\cdots,[a_i,a_i]$ 中每个区间的最后一段连续乘积之和，$g_i$ 与 $f_i$ 的意义仍不变，我们对每个符号加上 $a_i$ 考虑贡献：

- 如果这个符号是加法，有：
	- 对于 $g'$ 数组，加法即只有 $a_i$ 算最后一段连续乘积：$g'_i=i \times a_i$；
    - 对于 $g$ 数组，加法中不变：$g_i=g_{i-1}+a_i \times i$；
	- 对于 $f$ 数组，$g_i$ 即为转移量：$f_i=f_{i-1}+g_i$；
- 如果这个符号是乘号，有：
	- 对于 $g'$ 数组，与全部乘法中 $g$ 数组的处理类似：$g'_i=g'_{i-1} \times a_i+a_i$；
    - 对于 $g$ 数组，还记得上面对于只有一个乘号的时候我们是怎么做的吗，只不过乘的对象从单乘单变成了单乘多了而已，把他模拟到这里来就可以了：$g_i=g_{i-1}+g'_{i-1} \times (a_i-1)+a_i$；
	- 对于 $f$ 数组，$g_i$ 即为转移量：$f_i=f_{i-1}+g_i$。

输出 $f_n$ 即可。

听说还能优化（数组 -> 变量），反正这个能过就不管了，优化起来不算难。
    
然后这题就做完了，总之还是感觉这题非常神仙，可能是因为第一次接触这类题吧，之后会多多练习这种题锻炼已经死了好久的脑子的。

#### Code

```cpp
#include <bits/stdc++.h>
#define Mod 998244353

using namespace std;

long long n;
long long f[100015];
long long g[100015];
long long g1[100015];

int main () {
	scanf("%lld", &n);
	scanf("%lld", &f[1]);
	g[1] = f[1];
	g1[1] = f[1];
	for (long long i = 2; i <= n; i++) {
		char opt;
		long long x;
		scanf(" %c%lld", &opt, &x);
		x %= Mod;
		if (opt == '+') {
			g1[i] = i * x;
			g1[i] %= Mod;
			g[i] = g[i - 1] + ((x * i) % Mod);
			g[i] %= Mod;
			f[i] = f[i - 1] + g[i];
			f[i] %= Mod; 
		}
		if (opt == '*') {
			g1[i] = g1[i - 1] * x + x;
			g1[i] %= Mod;
			g[i] = g[i - 1] + ((g1[i - 1] * (x - 1) + x) % Mod);
			g[i] %= Mod;
			f[i] = f[i - 1] + g[i];
			f[i] %= Mod;
		}
	}
	printf("%lld\n", f[n] % Mod);
	return 0;
}
```

---

## 作者：Kun_is_Me (赞：0)

### 题意。

给定一个由数字、```+```、```*``` 组成的表达式，需要我们求出它的所有子表达式运算值之和对 $998,244,353$ 取模的结果。

### 思路。

我们可以考虑，在一个表达式后面加上一个数字或符号，会对这一个表达式造成什么影响。

我们可以发现，数字 $a_i$ 会对 $[1,i],[2,i]\dots[i,i]$ 几个区间造成影响。

#### 插入问答环节。

Q：为什么 $a_i$ 不会对其他的区间造成影响？

A：因为前面已经计算过力。

#### 回到正题。

先考虑没有加号的情况。

我们本身对加号而言，就是对前面的所有区间乘上 $a_i$，（很好理解吧？）根据乘法分配律，也就是对前面几项的积乘 $a_i$，然后再加上 $[i,i]$ 本身。

然后考虑加号有什么影响。

首先，就加号本身而言，他就是一个加号。

其实是对前面的所有区间产生了加上 $a_i$ 的贡献，很好理解。在后面的计算中，碰到加号时，是对**最近一个加号以前的数字**没有乘的贡献，但是有加上目前这段连续乘的贡献。

我们可以直接使两个变量模拟当前连续乘乘和累加的结果，然后按照上文计算贡献即可。

### 代码。

```cpp
#include<iostream>
using namespace std;
const int N=114514,mod=998244353;
int a[N],n;
char c[N];
int i;
int main()
{
	cin>>n;
	for(i=1;i<n;i++) cin>>a[i]>>c[i];
	cin>>a[n];
	bool flag=0;
	int m=1,s=0,ans=0;
	for(i=1;i<=n;i++)
	{
		if(flag) m=(m*a[i]+a[i])%mod;
		else m=(i*a[i])%mod;
		flag=1;
		ans=(ans+m+s)%mod;
		if(c[i]=='+')
		{
			flag=0;
			s=(s+m)%mod;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：under_the_time (赞：0)

## 题意

> 给定一个长度为 $n$ 的数组 $a$，两个相邻的数用一个加号或者乘号连接。定义一个表达式的**子表达式**为取出 $a$ 中的一个子串以及子串中的加号和乘号组成的表达式。求出 $a$ 的所有子表达式的值的和。对 $998244353$ 取模。仅包含一个数字的表达式也视为子表达式之一。
>
> $n\le 10^5$，$a_i\le 10^9$。

## 解法

考虑 dp。令 $f(i)$ 表示以 $i$ 为右端点所有子表达式的值的和，最终答案即为 $\sum_{i=1}^n f(i)$。初始有 $f(1)=a_1$。然后我们按照 $a_i$ 前的运算符进行分类讨论。如果是个加号，那么对于所有以 $i-1$ 为右端点的表达式，都可以直接加上 $a_i$ 得到新的子表达式；以 $i-1$ 为右端点的子表达式显然有 $i-1$ 个，加上只选 $a_i$ 作为子表达式的情况，那么有转移：
$$
f(i)=f(i-1)+i\times a_i
$$
如果是个乘号，不妨举个例子：
$$
a_1+a_2+a_3\times a_4\times a_5\times\color{red}a_6
$$
假设现在考虑到了 $a_6$，只选自己值为 $a_6$，选 $[5,6]$（这里 $[l,r]$ 表示选择 $a_l\cdots a_r$）值为 $a_5a_6$，选 $[4,6]$ 值为 $a_4a_5a_6$，选 $[3,6]$ 值为 $a_3a_4a_5a_6$。我们先考虑到这里，此时的子表达式值之和为 $a_6+a_5a_6+a_4a_5a_6+a_3a_4a_5a_6$。我们再看看考虑 $a_5$ 的情况，类似的我们只选到 $a_3$ 就停止，此时的子表达式值之和为 $a_5+a_4a_5+a_3a_4a_5$。我们来看看从 $a_5\to a_6$ 产生的变化：
$$
\begin{aligned}a_5+a_4a_5+a_3a_4a_5&\to 1+a_5+a_4a_5+a_3a_4a_5\\&\to (1+a_5+a_4a_5+a_3a_4a_5)\times a_6\\&\to a_6+a_5a_6+a_4a_5a_6+a_3a_4a_5a_6\end{aligned}
$$
总结一下规律：对于一个**极长的连乘段** $[l,i]$，即 $a_{l+1},a_{l+2},\cdots,a_i$ 之前都是乘号且满足长度最长，我们令对于前面是乘号的 $a_i$，左端点在 $[l,i]$ 右端点为 $i$ 的所有子表达式值之和为 $g(i)$；那么就有：
$$
g(i)=(g(i-1)+1)\times a_i
$$
对于左端点在 $[1,l-1]$ 的子表达式呢？我们可以把 $[l,i]$ 视为一个数 $x=\prod _{j=l}^i a_j$，相当于在所有右端点为 $l-1$ 的子表达式后面加上这个 $x$ 得到一个新表达式，这里不包括只选择 $x$ 的情况防止算重。综合两个部分可以得到此时 $f(i)$ 的转移：
$$
f(i)=g(i)+f(l-1)+x\times (l-1)
$$
 我们就可以在 $O(n)$ 的时间解决这个问题了。

## 实现

我们可以记一个 $len$ 表示当前极长连乘段的长度，当然直接用上文的 $l$ 也可以；然后分别记 $p,q$ 表示 $g(i)$ 和当前的 $x$。对于一个加号，我们令 $len\gets 1,p=a_i+1,q=a_i$；对于一个乘号，我们先更新这三个变量，但是 $p$ 先不加一，算完后再加一。~~自己做的时候的构思实现方法。~~

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
struct Number { char opt; int val; } a[maxn];
int f[maxn]; const int P = 998244353;
int add(int x, int y) { return (x + y) % P; }
void addto(int &x, int y) { x = (x + y) % P; }
int mul(int x, int y) { return 1ll * x * y % P; }
void multo(int &x, int y) { x = 1ll * x * y % P; }
int main() {
	int n; scanf("%d", &n); scanf("%d", &a[1].val);
	for (int i = 2; i <= n; i ++)
		scanf(" %c %d", &a[i].opt, &a[i].val);
	f[1] = a[1].val; int ans = f[1];
	for (int i = 2, len = 1, prod = a[1].val, prod0 = add(a[1].val, 1); i <= n; i ++) {
		if (a[i].opt == '+') {
			f[i] = add(f[i - 1], mul(a[i].val, i));
			len = 1, prod = prod0 = a[i].val;
			addto(prod0, 1);
		} else {
			len ++, multo(prod0, a[i].val), multo(prod, a[i].val);
			f[i] = add(add(f[i - len], mul(prod, i - len)), prod0);
			addto(prod0, 1);
		}
		addto(ans, f[i]);
	} printf("%d\n", ans);
	return 0;
}
```

---

## 作者：wangzc2012 (赞：0)

# P6796 「StOI-2」好多表达式
## 题意概括
给出一个由 $n$ 个正整数和乘号及除号组成的表达式，求出它的所有子表达式运算值之和对 $998244353$ 取模的结果。
## 思路分析
我们将表达式中乘号和除号分开来讨论。
- 假设第 $i$ 个符号为加号
如果第 $i$ 个符号为加号，那么很显然，以第 $i-1$ 个数字结尾的所有表达式的值都将被加上这个数。
- 假设第 $i$ 个符号为乘号
如果第 $i$ 个符号为乘号，就不那么好处理了，所以我们先用样例来举个例子。
```
1 + 2 * 3
```
在没有乘号前，表达式有：$1$、$2$、$1+2$，增加了乘号后，表达式有：$1$、$2$、$1+2$、$2\times3$、$1+2\times3$、$3$。其中有变化的是以 $2$ 为结尾的表达式，全部乘 $3$,同时新增了一个表达式 $3$。    
通过观察不难发现，在表达式后增加一个乘号，会导致最后一个表达式的最后一部分整体乘上这个数，同时增加这个数本身。
## 算法实现
使用数组 $dp _ {i}$ 用于存储以第 $i$ 个数结尾的表达式之和，同时定义数组 $x _ {i}$ 用于存储以第 $i$ 个数字结尾的表达式最后一部分之和，变量 $a$ 和 $b$ 用于存储当前数字和符号。由此可以得出：
- 如果第 $i$ 个符号为加号    
$$dp _ {i}=(dp _ {i-1}+(i-1)\times a+a)$$    
$$x _ {i}=((i-1)\times a+a)$$  
解释：$dp_{i-1}$ 为之前所有表达式的和；$(i-1) \times a$ 代表以第 $i-1$ 个数字为结尾的 $i-1$ 个表达式的值全部加上 $a$；最后的 $+a$ 是加上 $a$ 自身带来的贡献。

- 如果第 $i$ 个符号为乘号    
$$dp _ {i}=((dp_ {i-1}-x_ {i-1})+(x_ {i-1}\times a)+a)$$
$$x _ {i}=(x _ {i-1} \times a+a)$$
解释：$(dp_ {i-1}-x_ {i-1})$ 为没有变化的表达式值的和；$(x_ {i-1}\times a)$ 为当前这个乘法表达式对前面表达式的贡献；最后的 $+a$ 是加上 $a$ 自身所带来的贡献。

当然，为了是程序简便，代码中没有使用数组，而是使用了变量量代替。  
思路很清晰，就不再赘述了，如果没理解，就来康康代码吧！
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
long long n;
long long dp,x;
long long ans;
long long a;
char b;
int main(){
    cin>>n;
    cin>>dp;
    ans=dp;x=dp;
    for (int i=2;i<=n;i++){
        cin>>b>>a;
        if (b=='+'){
            dp=(dp+(i-1)*a+a)%mod;
            x=((i-1)*a+a)%mod;
        }
        else {
            dp=((dp-x)+(x*a)+a)%mod;
            x=(x*a+a)%mod;
        }
        ans=(ans+dp)%mod;
    }
    cout<<ans%mod;
    return 0;
}
```

注：本题解在2024年7月5日已审核通过，2024年7月26日优化了表达方式，辛苦管理员再次审核，谢谢！

---

## 作者：irris (赞：0)

### Preface

LHQ 的人品不说如何，他很 real！出的题也很 real！

### Problem

给你一个只有 `+` 和 `*` 的表达式，问你所有子表达式（所有 $[l, r](1 \leq l \leq r \leq n)$ 区间内的数和运算符构成的表达式）的值之和。

$1 \leq n \leq 10^5$。

### Solution

我觉得这个蓝色是不是虚高。

考虑递推，每次加进来一个数 $a_i = x$ 和一个运算符 $op$，我们考虑维护 $f_i$ 表示 $r = i$ 的所有区间的答案和。

1. 如果 $op$ 是 `+`：

+ 加法是底层运算。
+ 我们考虑直接令 $f_i \gets f_{i-1} + ix$ 即可。

2. 如果 $op$ 是 `*`：

+ 乘法可能和先前的若干乘法发生连环反应，直到遇到第一个加号，加号后的内容不受这个乘法的管辖。
+ 这导致我们不能粗暴地让 $f_i \gets x(f_{i-1} + 1)$，所以我用了额外的两个数组来维护。
+ 一个是 $g$，表示直到当前的连乘的子区间的表达式值和。这个可以用我们上文提及的 $g_i \gets x(g_{i-1} + 1)$ 维护。
+ 一个是 $m$，表示直到当前的最大乘积，就是 $m_i \gets xm_{i-1}$ 这种形式了。
+ 如果我们的 $l$ 使得 $[l, r]$ 区间全部是乘号，所有 $l$ 的贡献和即为 $g_i$。
+ 否则，这一段连乘对所有前面的区间的贡献都是 $+m_i$，找到这个加号的位置，可以用指针维护，这里我们就可以用到前面算出来的 $f_i$ 来计算。

注意我们在乘号上讨论了这么多，别忘了在加号的时候同时维护 $g_i = m_i = x$，万一它后面一个是乘号呢。

### Code

```cpp
#include <bits/stdc++.h>

constexpr long long MOD = 998244353;
#define MAXN 100001
long long f[MAXN], g[MAXN], m[MAXN];

char op;
int main() {
	int N; std::cin >> N >> f[1]; m[1] = g[1] = f[1];
	for (long long i = 2, x, l = 0; i <= N; ++i) {
		std::cin >> op >> x;
		if (op == '+') {
			g[i] = m[i] = x, l = i - 1;
			f[i] = (i * x % MOD + f[i - 1]) % MOD;
		} else {
			m[i] = x * m[i - 1] % MOD;
			g[i] = x * (g[i - 1] + 1) % MOD;
			f[i] = ((f[l] + l * m[i] % MOD) % MOD + g[i]) % MOD;
		}
	}
	long long ans = 0;
	for (int i = 1; i <= N; ++i) 
		ans = (ans + f[i]) % MOD;
	return std::cout << ans, 0;
}
```

---


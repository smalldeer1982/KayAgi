# 「EZEC-4.5」走方格

## 题目描述

有 $n\times m$ 的方格矩阵，小 A 从 $(1,1)$ 出发到 $(n,m)$ ，只能向下或向右走，获得的分数为他经过方格的权值之和。

已知每个方格 $(i,j) $的权值 $a_{i,j}$，你可以将其中任意一个方格上的权值变为 $0$，求变化后小 A 最多能获得分数的**最小值**。

## 说明/提示

[大样例](https://www.luogu.com.cn/paste/aeqswjyj)

### 本题使用捆绑测试。

### 【样例解释】：

样例1： 将 $(2,2)$ 的权值变为 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(2,2)$ ，获得分数为 $3+6+0=9$。

样例2： 将 $(2,1)$ 的权值变成 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(3,1)$  ->$(3,2)$  ->$(3,3)$ ，获得分数为 $1+0+3+1+1=6$。

### 【数据范围】：

$Subtask1(40分):1\le n,m \le 100$。

$Subtask2(30分):1\le n,m \le 500$。

$Subtask3(30分):1\le n,m \le 2 \times 10^3$。

对于 $100\%$ 的数据：$1\le n,m\le 2\times 10^3,1\le a_{i,j} \le 10^9$。

## 样例 #1

### 输入

```
2 2
3 3 
6 4```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
1 1 1
2 1 2
3 1 1```

### 输出

```
6```

# 题解

## 作者：Liynw (赞：44)

### 前言

[题目传送门](https://www.luogu.com.cn/problem/P6855)

**正解：动态规划**

挺 duliu 一道题，难度较大 qwq。

>PS：因为此篇题解前后改动较多，如果有什么错误请各位奆佬提出，本蒟蒻感激不尽 awa。

### 题意简述

给你一个 $n\times m$ 大小的方格阵，可以把方格中的任意一个数改为 $0$，每次从 $(1,1)$ 到 $(n,m)$ 的得分为路上所有数字的和。求每次改动数字后能得到的最大值的最小值。


### 法一：时间复杂度 $Θ(m^2n^2)$ （TLE）

这但凡是个正常人都会想到吧……前两层循环枚举变为 $0$ 的方格坐标，后两层按照正常的方格取数做法求最大值。


结果，被校 OJ 卡了没骗到分。

### $Code$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int m,n,t,a[2005][2005];
ll ans=LONG_LONG_MAX,dp[2005][2005];
int main(){
	scanf("%d %d",&m,&n);
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int x=1;x<=m;x++){
		for(int y=1;y<=n;y++){
			memset(dp,0,sizeof(dp));
			t=a[x][y];
			a[x][y]=0;
			for(int i=1;i<=m;i++){
				for(int j=1;j<=n;j++){
					dp[i][j]=max(dp[i][j-1],dp[i-1][j])+a[i][j];
				}
			}
			ans=min(ans,dp[m][n]);
			a[x][y]=t;
		}
	}
	printf("%lld",ans);
	return 0;
} 
```

### 法二：正解，时间复杂度 $Θ(mn)$

>PS * 2：因为 me 习惯用 $m$ 表示行 $n$ 表示列，所以下列题解就会这么写。

有点麻烦。

如果每个点只能遍历一次，那么必须不变值和变为 $0$ 这两种情况需要同时考虑。

首先我们可以考虑先求出从 $(1,1)$ 点出发走到 $(i,j)$ 点和从 $(m,n)$出发走到 $(i,j)$ 点能拿到的最大分数，分别存在 $dp1$ 数组和 $dp2$ 数组里。

这两个数组很好求，按照每个初学 DP 者都要打的取数板子就珂以了。至于为什么要求这两个数组，我先卖个关子，待会儿就知道了（逃。

我们知道，如果你从 $(1,1)$ 出发，在走的时候不经过某个坐标为 $(i,j)$ 的点（也就是绕过这个点），你有两种情况可以绕开它：

1. 从左边绕。

1. 从上边绕。

给这两种方法更严谨的定义 $(i>0)$ ：

1. 从左边绕：经过点 $(x,y-i)$。

1. 从上边绕：经过点 $(x-i,y)$。

对于这两种情况，我们可以分别用两个二维数组 $l$ （左边绕）和 $d$ （上边绕）来存：

- $l_{i,j}$ 表示从左边绕过 $(i,j)$ 点能获得的最大值。

- $d_{i,j}$ 表示从上边绕过 $(i,j)$ 点能获得的最大值。

但是如何求这两个数组呢？

直接切入可能比较麻烦。这个时候我们可以先分析这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/w1jlcv0e.png)

不管是往哪边绕，也不管前面怎么走，都**紧贴**着点 $(i,j)$ 过路方便分析，即，从左绕一定经过点 $(i,j-1)$，从上绕一定经过点 $(i-1,j)$。

首先分析从左边绕的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/5urpub8q.png)

看图，蓝色区域表示从 $(1,1)$ 出发到点 $(i,j-1)$ **有可能**会经过的区域，红色区域表示从点 $(i+1,j-1)$ 到 $(m,n)$ 有可能会经过的区域。至于为什么选这两个点呢，相信大家看图也能明白，因为选择这两个点可以做到**经过的格子不重不漏**，考虑到每种情况。

如果这么算，那么从点 $(i,j-1)$ 绕过去能拿到的最大分数就是：

$$score=dp1_{i,j-1}+dp2_{i+1,j-1}$$

现在大家知道两个 $dp$ 数组的意义了吧，就是用来求**某个区域的最大分数**的。因为如果每次循环到一个点就计算此点到终点的分数还需要两层循环会超时，基于走方格的方向是可逆的，我们只需要计算终点到每个点的最大分数就可以啦 OvO。

那我们现在只求了最贴近点 $(i,j)$ 的绕法，那我们如何求出往左绕的所有情况的最大值呢？

我们之前不是用了一个数组来存往左边绕的值吗？因为循环的顺序是**从上到下，从左到右**的，所以在求点 $(i,j)$ 的值时，我们已经把它左上方的所有值都求出来了。现在我们可以利用这些值，每一次，我们求当前 $score$ 与之前最大分数的较大值，那每次都求最大值就是所有情况中的最大值。

那么最后的结果就是：

$$l_{i,j}=\max(dp1_{i,j-1}+dp2_{i+1,j-1},i_{i,j-1})$$

至于为什么我们利用的是 $l_{i,j-1}$，大家可以自己画图感知，这个格子就位于我们前面求的必须经过的那个格子 $(i,j-1)$，那么绕过它我们就会求必须经过点 $(i,j-2)$，这样我们就又需要考虑绕过这个格子的情况，就又必须经过点 $(i,j-3)$……这么一层一层往左推，最后可以推到点 $(i,1)$，从而把每种情况都考虑到。

从上面绕分析方法也差不多，这里不多说画张图让读者感知一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/utekzl0f.png)

~~（您看看这两张图多像，连大小都差不多26 KB）~~

最后求出 $d_{i,j}$ 的式子为：

$$d_{i,j}=\max(dp1_{i-1,j}+dp2_{i-1,j+1},d_{i-1,j})$$

最后求答案有些麻烦，因为题目要求的是**变化后最能获得的最大分数的最小值**，所以 $\max$ 和 $\min$ 是真的挺容易用混的，这里需要特别注意。

首先每对一个格子进行操作，最后得到的答案会是下列三种情况中的一种：

1. 从左边绕过去得到的最大分数。

1. 从上边绕过去得到的最大分数。

1. 经过这个格子得到的最大分数。

前两个我们已经求解了，但其实第三种情况是灰常简单的！因为要保证经过点 $(i,j)$，所以我们只需要求 $dp1_{i,j}+dp2{i,j}$ 就可以了。但是上面那个式子算了两次 $(i,j)$ 的值，而我们因为把它变成 $0$ 了，就一次都不能算。所以还需要减去两个 $a_{i,j}$。

所以最后的答案终于可能被更新了 owo：

$$ans=\min\big(ans,\max(l_{i,j},d_{i,j},dp1_{i,j}+dp2_{i,j}-2\times a_{i,j})\big)$$

**最后再强调一遍要注意最大值和最小值别用反了啊！** ~~别问我为什么知道（悲）。~~

### $Code$

```cpp
#include<bits/stdc++.h>
#define ll long long //记得要开long long哦！
using namespace std;
//温馨提示细节：因为最后答案还是求的最小值，所以 ans 需要定义极大值
ll m,n,ans=LONG_LONG_MAX,a[2005][2005],dp1[2005][2005],dp2[2005][2005],l[2005][2005],d[2005][2005];
int main(){
	//输入
	scanf("%lld %lld",&m,&n);
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			scanf("%lld",&a[i][j]);
		}
	}
   	//求两个 dp 数组的值
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1])+a[i][j];
		}
	}
	for(int i=m;i;i--){
		for(int j=n;j;j--){
			dp2[i][j]=max(dp2[i+1][j],dp2[i][j+1])+a[i][j];
		}
	}
   	//核心代码开始
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			l[i][j]=max(l[i][j-1],dp1[i][j-1]+dp2[i+1][j-1]);
			d[i][j]=max(d[i-1][j],dp1[i-1][j]+dp2[i-1][j+1]);
			ans=min(ans,max(max(l[i][j],d[i][j]),dp1[i][j]+dp2[i][j]-2*a[i][j]));
		}
	}
   	//核心代码结束，输出答案
	printf("%lld",ans);
	return 0;
}
```

### 写在最后

这真的是一道很好的动态规划题，很考验思维，也有很多需要注意的细节。最后，看在本人写了那么久的份上，就请您随手点一下左下角那个小小的赞吧 qwq。

---

## 作者：stoorz (赞：7)

首先我们发现，改动为 $0$ 的格子一定在最长路径上，否则改了这个格子最长路径长度没变，显然不是最优解。

因为从点 $(1,1)$ 到 $(n,m)$ 且只可以往下或往右的任意一条路径长度都为 $n+m-1$，所以答案只可能是修改这 $n+m-1$ 个点中的一个。

我们先求出 $f[i][j]$ 表示点 $(1,1)$ 到 $(i,j)$ 的最长路径长度，$g[i][j]$ 表示点 $(n,m)$ 到 $i,j$ 的最长路径长度，然后枚举最长路径上的每一个点 $(x,y)$，需要求出将这个点权值设为 $0$ 之后从 $(1,1)$ 到 $(n,m)$ 的最长路径。

经过点 $(x,y)$ 的最长路径长度为 $f[x][y]+g[x][y]-2\times a[x][y]$，对于不经过点 $(x,y)$ 的点，我们枚举这条路径从第 $x$ 行走向第 $x+1$ 行是在哪一列，设为 $k$，那么设 $h[k]$ 表示这条路径从第 $x$ 行到第 $x+1$ 行走的是第 $k$ 列，且不经过 $(x,y)$ 的最长路径。

那么有
$$h[k]=\left\{\begin{matrix}-\infty\ (k=y)\\ \max(h[k-1],f[x-1][k])+a[x][k]\ (k\neq y)\end{matrix}\right.$$

此时从第 $k$ 列下去的路径长度最大值就是 $h[k]+g[x+1][k]$。

所以将 $(x,y)$ 赋值为 $0$，路径长度最大值就是
$$\max(h[k]+g[x+1][k],f[x][y]+g[x][y]-2\times a[x][y])$$

在所有答案中取 $\min$ 即可。

由于我们只尝试将 $n+m-1$ 个点赋值为 $0$，每个点计算复杂度是 $O(n)$，总时间复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=2010;
const ll Inf=1000000000000000000LL;
int n,m;
ll ans,f[N][N],g[N][N],h[N],a[N][N];

int main()
{
	memset(f,0xcf,sizeof(f));
	memset(g,0xcf,sizeof(g));
	scanf("%d%d",&n,&m);
	ans=Inf; f[0][1]=f[1][0]=g[n+1][m]=g[n][m+1]=0;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			scanf("%lld",&a[i][j]);
			f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
		}
	for (int i=n;i>=1;i--)
		for (int j=m;j>=1;j--)
			g[i][j]=max(g[i+1][j],g[i][j+1])+a[i][j];
	for (int x=n,y=m;x!=1 || y!=1;)
	{
		ll maxn=0;
		h[0]=-Inf;
		for (int i=1;i<=m;i++)
		{
			if (i==y) h[i]=-Inf;
			else
			{
				h[i]=max(h[i-1],f[x-1][i])+a[x][i];
				maxn=max(maxn,h[i]+g[x+1][i]);
			}
		}
		maxn=max(maxn,f[x][y]+g[x][y]-a[x][y]*2LL);
		ans=min(ans,maxn);
		
		if (x==1) y--;
		else if (y==1) x--;
		else if (f[x-1][y]>f[x][y-1]) x--;
		else y--;
	}
	printf("%lld",min(ans,f[n][m]-a[1][1]));
	return 0;
}
```

---

## 作者：RBI_GL (赞：3)

### 题意：

$n$ $∗$ $m$ 的网格，每个格子有一个数，可以选择一个位置变为 $0$。要求最小化最大权值和路径。

### 思路：

考虑枚举哪个位置变为 $0$，一个位置变为 $0$ 后我们将路径分为两种路径，一种是经过该点的路径，一种是不经过该点的路径。

我们预处理出 $f_{i,j}$ 表示 $(1,1)$ 走到 $(i,j)$ 的最大权和， $g_{i,j}$ 表示 $(i,j)$ 走到 $(n,m)$ 的最大权和。然后我们发现如果不走 $(x,y)$ 这个位置，那么一会走 $(i,y)->(i,y+1)$ 其中 $i<x$；或者 $(x,j)->(x+1,j)$ 其中 $j<y$。用 $g$ 和 $f$ 计算这些走法的最大权值和即可。

时间复杂度 $O(nm)$

------------

### Code：


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,a[2005][2005],f[2005][2005],g[2005][2005],ar[2005][2005],br[2005][2005];
int main() {
	cin>>n>>m;
	for(ll i=1; i<=n; i++)
		for(ll j=1; j<=m; j++) {
			cin>>a[i][j];
			f[i][j] = max(f[i-1][j],f[i][j-1])+a[i][j];
		}
	for(ll i=n; i>=1; i--)
		for(ll j=m; j>=1; j--) {
			g[i][j] = max(g[i+1][j],g[i][j+1])+a[i][j];
			ar[i][j] = f[i][j]+g[i+1][j];
			br[i][j] = f[i][j]+g[i][j+1];
		}
	ll ans=1e18;
	for(ll i=1; i<=n; i++)
		for(ll j=1; j<=m; j++) {
			ll z = max(f[i][j]+g[i][j]-2*a[i][j],max(ar[i][j-1],br[i-1][j]));
			ans = min(ans,z);
			if(j!=1) ar[i][j] = max(ar[i][j],ar[i][j-1]);
			if(i!=1) br[i][j] = max(br[i][j],br[i-1][j]);
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：君のNOIP。 (赞：3)

下文中视 $n,m$ 同阶。

### $Subtask1:$ $O(n^4)$ 暴力枚举。

设 $f_{i,j}$ 为从 $(1,1)$ 走到 $(i,j)$ 得分的最大值。

由于 $(i,j)$ 只能由 $(i-1,j),(i,j-1)$ 走来，显然有： $f_{i,j} = max(f_{i-1,j},f_{i,j-1})+a_{i,j}$

所以 $O(n^2)$ 枚举权值变为 $0$ 的点，每次再 $O(n^2) $ dp 求出最大得分并取其最小值即可。 

------------


### $Subtask2:$ $O(n^3)$ 

还是考虑枚举权值变为 $0$ 的点 $(i,j)$， 显然此时最大得分为**不经过该点的最大得分**与 **经过该点的最大得分减去** $a_{i,j}$  的最大值。

关键是如何得出不经过该点的最大得分？

我们可以先考虑如何得出经过 $(i,j)$ 的最大得分。

设 $g(i,j)$ 为从 $(n,m)$ 走到 $(i,j)$ 得分的最大值。

同理易得：$g_{i,j} =max(g_{i+1,j},g_{i,j+1})+a_{i,j}$

显然经过 $(i,j)$ 的最大得分为 $f_{i,j}+g_{i,j}-a_{i,j}$

由于只能向下或向右走，因此我们可以发现不经过 $(i,j)$ 的路径一定是经过该点**同行左边一点并向下走**或**同列上面一点并向右走**，这样就不可能经过 $(i,j)$ 了。

于是将 $(i,j)$ 权值变为 $0$ 时的最大得分为： $\max (f_{i,j}+g_{i,j}- 2 \times a_{i,j} , \max( f_{x,j}+g_{x,j+1}  ), \max( f_{i,y}+g_{i+1,y} ) ), x \in [1,i), y \in [1,j)$

答案取其最小值即可。


------------

### $Subtask3:$ $O(n^2)$  

#### 方法一：

发现 $\max( f_{x,j}+g_{x,j+1}  )$ 和 $ \max( f_{i,y}+g_{i+1,y} )$, $x \in [1,i), y \in [1,j)$ 可以预处理出来。

设 $F_{i,j,0}$ 为 $ \max( f_{i,y}+g_{i+1,y} )$， $F_{i,j,1}$ 为 $\max( f_{x,j}+g_{x,j+1}  )$。

可得 $F_{i,j,0} = \max(F_{i,j-1,0}, f_{i,j} + g_{i+1,j})$,

$F_{i,j,1} = \max(F_{i-1,j,0}, f_{i,j} + g_{i,j+1})$。

答案即为： $\min( \max(f_{i,j}+g_{i,j}- 2 \times a_{i,j}, \max(F_{i,j-1,0}, F_{i-1,j,1})) )$

#### Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
using namespace std;
#define G() Cr = getchar()
#define LL long long
int Xr, Fr; char Cr;
inline int rd() {
	Xr = 0, Fr = 1, G();
	while(Cr < '0' || Cr > '9') {if(Cr == '-') Fr = -1; G();}
	while(Cr >= '0' && Cr <= '9') Xr = (Xr<<1) + (Xr<<3) + (Cr&15), G();
	return Xr * Fr;
}
#define MAX_N 2005
int n, m;
LL va[MAX_N][MAX_N], f[MAX_N][MAX_N], g[MAX_N][MAX_N], F[MAX_N][MAX_N][2], ans = 1e18; // F[i][j][0] -> left
int main() { 
	n = rd(), m = rd();
	for( int i = 1; i <= n; i++)
		for( int j = 1; j <= m; j++)
			va[i][j] = rd();
	for( int i = 1; i <= n; i++ )
		for( int j = 1; j <= m; j++ )
			f[i][j] = va[i][j] + max(f[i-1][j],f[i][j-1]);
	for( int i = n; i >= 1; i-- )
		for( int j = m; j >= 1; j-- ) 
			g[i][j] = va[i][j] + max(g[i+1][j],g[i][j+1]);
	for( int i = 1; i <= n; i++ )
		for( int j = 1; j <= m; j++ )
			F[i][j][0] = max( F[i][j-1][0], f[i][j] + g[i+1][j]),
			F[i][j][1] = max( F[i-1][j][1], f[i][j] + g[i][j+1]),
			ans = min(ans, max( max( F[i][j-1][0], F[i-1][j][1]), f[i][j] + g[i][j] - 2 * va[i][j] ) );
	cout << ans;
}
```


------------

####  方法二：

这次考虑走的步数，预处理出走 $k$ 步时经过各点 $(i,k-i)$ 时的最大得分及其橫坐标 $i$，以及经过各点的最大得分的次大值（可与最大值相同）。

最大得分显然都是 $f_{n,m}$，枚举权值变为 $0$ 的点 $(i,j)$ 时每次便判断 $i$ 是不是走 $i+j$ 步最大得分的横坐标，若不是，则最大得分就是 $f_{n,m}$， 即变该点权值不会影响答案；否则说明该点是最大得分路径上一点，则最大得分为其次大值和经过 $(i,j)$ 的最大得分的最大值。

#### Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
using namespace std;
#define G() Cr = getchar()
#define LL long long
int Xr, Fr; char Cr;
inline int rd() {
	Xr = 0, Fr = 1, G();
	while(Cr < '0' || Cr > '9') {if(Cr == '-') Fr = -1; G();}
	while(Cr >= '0' && Cr <= '9') Xr = (Xr<<1) + (Xr<<3) + (Cr&15), G();
	return Xr * Fr;
}
#define MAX_N 2005
int n, m;
LL va[MAX_N][MAX_N], f[MAX_N][MAX_N], g[MAX_N][MAX_N], F[MAX_N][MAX_N], G[4005][2], Gx[4005], ans = 1e18; // G[i][0] max G[i][1] 2th_max
int main() { 
	n = rd(), m = rd();
	for( int i = 1; i <= n; i++)
		for( int j = 1; j <= m; j++)
			va[i][j] = rd();
	for( int i = 1; i <= n; i++ )
		for( int j = 1; j <= m; j++ )
			f[i][j] = va[i][j] + max(f[i-1][j],f[i][j-1]);
	for( int i = n; i >= 1; i-- )
		for( int j = m; j >= 1; j-- ) 
			g[i][j] = va[i][j] + max(g[i+1][j],g[i][j+1]);
	for( int i = 2; i <= n + m; i++ )
		for( int k = max(1,i-m); k < min(i,n+1) ; k++ )
			if( f[k][i-k] + g[k][i-k] - va[k][i-k] > G[i][0] ) G[i][1] = G[i][0], G[i][0] = f[k][i-k] + g[k][i-k] - va[k][i-k], Gx[i] = k;
			else if( f[k][i-k] + g[k][i-k] - va[k][i-k] > G[i][1] ) G[i][1] = f[k][i-k] + g[k][i-k] - va[k][i-k];
	for( int i = 1; i <= n; i++ )
		for( int j = 1; j <= m; j++ ) {
			if( Gx[i+j] == i ) F[i][j] = max(G[i+j][0] - va[i][j], G[i+j][1] );
			else F[i][j] = G[i+j][0];
			ans = min(F[i][j],ans);
		}
	cout << ans;
}
```


---

## 作者：lndjy (赞：1)

有趣的 dp 题。

一个点变为 0 时，最长路径有两种情况，第一种是经过这个 0，第二种是不经过这个 0.

先看经过这个 0 的。

要先走到这个点的上面或左面，这部分没有修改的点，直接 dp 就行。

设 $st[i][j]$ 表示起点到 $(i,j)$ 的最大值，很显然有

$$st[i][j]=\max(st[i][j-1],st[i-1][j])+a[i][j]$$

然后走过这个 0，对答案没有贡献。

然后从这个点的下面或右面，走到终点。

这部分倒着做一遍上面的 dp 就可以了。（代码里为 $en[i][j]$).

然后考虑不经过这个 0。可以从它的左面或者是上面经过。

设 $l[i][j]$ 表示左面到 $(i,1)-(i,j)$ 再到终点的最大值。

$$l[i][j]=\max(l[i][j-1],st[i][j]+en[i+1][j])$$

设 $d[i][j]$ 表示左面到 $(1,j)-(i,j)$ 再到终点的最大值。

$$	d[i][j]=\max(d[i-1][j],st[i][j]+en[i][j+1])$$

这种情况的答案就是 $l$ 和 $d$ 的最大值。

然后和第一种情况取最大值就行了。

代码：
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
const int N=2e3+5;
int st[N][N],en[N][N],a[N][N],l[N][N],d[N][N];
int n,m,ans=1e18;
signed main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	a[i][j]=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	st[i][j]=max(st[i][j-1],st[i-1][j])+a[i][j];
	for(int i=n;i>=1;i--)
	for(int j=m;j>=1;j--)
	en[i][j]=max(en[i][j+1],en[i+1][j])+a[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		l[i][j]=max(l[i][j-1],st[i][j]+en[i+1][j]);
		d[i][j]=max(d[i-1][j],st[i][j]+en[i][j+1]);
	 } 
	 for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	 ans=min(ans,max(max(st[i-1][j],st[i][j-1])+max(en[i][j+1],en[i+1][j]),max(l[i][j-1],d[i-1][j])));
	 cout<<ans;
	return 0;
}
```


---

## 作者：zythonc (赞：1)

## 题意简述

任选一个位置改为 $0$，求改动后最小的最大权值路径权值和

## 题意分析

显然我们可以 $O(n^2)$ 暴力枚举修改的位置，对于每个位置跑一次 $O(n^2)$ 的动态规划

总时间复杂度 $O(n^4)$，显然是不可以的

我们考虑修改的位置，易知修改的位置一定在**原来没改之前的最长路上**

**证明：** 如果没有在最长路上，那么不管在其他位置上怎么改，因为有这条路径存在的缘故，结果不变

所以我们只需要枚举 $n+m$ 个位置即可

时间复杂度降至 $O((n+m)n^2)$

但是这依然不够，对于 $2\times10^3$ 的数据++不过去的

**重新思考，我们求的是什么？**

无非是将一个位置修改为 $0$ 之后，**经过这个位置的最长路和不经过这个位置的最长路**的最小值罢了

~~**[我们发现这是一个模板题](https://www.luogu.com.cn/problem/CF1163F)**~~

**避开一个位置，无非就是走这一行的时候不走这个位置罢了**

所以我们枚举这一行即可

$\text{pre}[i][o]$ 表示原先 $(1,1)\;-\;(i,o)$ 这个区间的最长路

$\text{suf}[i][o]$ 表示原先 $(i,o)\;-\;(n,m)$ 这个区间的最长路

对于修改位置 $(i^\prime,o^\prime)$

$\text{q}[i][o]$ 表示修改后 $(1,1)\;-\;(i,o)$ 这个区间的最长路

$\text{h}[i][o]$ 表示修改后 $(i,o)\;-\;(n,m)$ 这个区间的最长路

**以上两个数组均满足不经过位置 $(i^\prime,o^\prime)$ 这个条件**

![](https://cdn.luogu.com.cn/upload/image_hosting/z6ut594r.png)

（红色是避开的位置，绿色是原最长路径）

显然有 

$(o^\prime< k\leq m)$

$\text{q}[i^\prime][k]=\begin{cases}\text{pre}[i^\prime-1][k]+\text{v}[i^\prime][k]&(k=o^\prime+1)\\\text{max}(\text{q}[i^\prime][k-1],\text{pre}[i^\prime-1][k])+\text{v}[i^\prime][k]&\text{otherwise.}\end{cases}$

$\text{h}$ 数组同理

统计答案时直接枚举

$ans=\begin{cases}max(ans,h[i^\prime][k]+pre[i^\prime][k]-v[i^\prime][k])&(1\leq k<o^\prime)\\max(ans,q[i^\prime][k]+suf[i^\prime][k]-v[i^\prime][k])&(o^\prime<k\leq m)\end{cases}$

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 1000001
#define M 5001
#define int long long
#define R register int
#define fx(l,n) inline l n
#define set(l,n) memset(l,n,sizeof(l))
using namespace std;
const int INF=21000000000000;
int n,m,v[M][M],pre[M][M],suf[M][M],l=1,r=1,ans,eans=INF,q[M][M],h[M][M];
short way[M][M];//1 is right,2 is down
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(R i=1;i<=n;i++)
		for(R o=1;o<=m;o++)
			cin>>v[i][o];
	for(R i=1;i<=n;i++)
		for(R o=1;o<=m;o++)
			pre[i][o]=max(pre[i-1][o],pre[i][o-1])+v[i][o];
	for(R i=n;i>=1;i--){
		for(R o=m;o>=1;o--){
			if(suf[i+1][o]>suf[i][o+1]){
				suf[i][o]=suf[i+1][o]+v[i][o];
				way[i][o]=2;
			} else {
				suf[i][o]=suf[i][o+1]+v[i][o];
				way[i][o]=1;
			}
		}
	}
	while(l<=n&&r<=m){
		ans=pre[l][r]+suf[l][r]-(v[l][r]<<1);
		h[l][r-1]=(l==n?0:suf[l+1][r-1]+v[l][r-1]);
		for(R i=r-2;i>=1;i--){
			h[l][i]=max(h[l][i+1],suf[l+1][i])+v[l][i];
		}
		for(R i=r-1;i>=1;i--) ans=max(ans,h[l][i]+pre[l][i]-v[l][i]);
		q[l][r+1]=(l==1?0:pre[l-1][r+1]+v[l][r+1]);
		for(R i=r+2;i<=m;i++){
			q[l][i]=max(q[l][i-1],pre[l-1][i])+v[l][i];
		}
		for(R i=r+1;i<=m;i++) ans=max(ans,q[l][i]+suf[l][i]-v[l][i]);
		if(way[l][r]==1) r+=1;
		else l+=1;
		eans=min(eans,ans);
	}
	cout<<eans;
}
```

---

## 作者：pocafup (赞：1)

验题人来讲一下做法，跟std的不一样（

考虑某一个点变为 0 对答案的贡献 -- 答案变为经过这个点和不经过这个点的路径的最大值。

可以发现，经过这个点的最大值为起点到这个点的上面或左边的最大值 + 终点到这个点的下面有右边的最大值。

而如果不经过这个点，那么他一定在这个点的左边往下走了，或者在他上面往右走了。

对于从上面走的点，答案一定起点到这个上面点最大值 + 从上面点的右边到终点的最大值。

对从左边走的点，答案一定起点到这个左边点的最大值 + 从左边点的下边到终点的最大值。

发现从起点和从终点的距离都可以预处理，从上面点和左边点的最大值可以使用前缀和优化，总复杂度 $O(n^2)$

dfs 复杂度为 $O((n\times m))!$，考虑每个点变成 0 重构的复杂度为 $O(n^4)$，不用前缀和优化的正解复杂度为 $O(n^3)$，对最长路径的每个点变为 0 判断的复杂度为 $O(n^3)$，都不足以过。

```cpp
signed main(){
   n= read(); m = read();
   For(i,1,n)
     For(j,1,m)
       pos[i][j] = read(),
       dp[i][j] = chkmax(dp[i-1][j],dp[i][j-1])+pos[i][j];
   FOR(i,n,1)
     FOR(j,m,1)
       maxi[i][j] = chkmax(maxi[i+1][j],maxi[i][j+1])+pos[i][j];
   For(i,1,n)
     For(j,1,m)
       down[i][j] = chkmax(down[i][j-1],dp[i][j]+maxi[i+1][j]),
       rt[i][j] = chkmax(rt[i-1][j],dp[i][j]+maxi[i][j+1]);

   For(i,1,n){
     For(j,1,m){
       int tmp = 0;
       if (i-1) tmp = chkmax(tmp,rt[i-1][j]);
       if (j-1) tmp = chkmax(tmp,down[i][j-1]);
       tmp = chkmax(tmp,chkmax(dp[i-1][j],dp[i][j-1])+chkmax(maxi[i][j+1],maxi[i+1][j]));
       ans = chkmin(ans,tmp);
     }
   }
   writeln(ans);
}
```

---

## 作者：TulipeNoire (赞：1)

首先大家得知道，我们设正常情况下取得最大值的路径为$A$,如果修改点不在 $A$ 上，那么最大值还是原来的最大值——直接走 $A$ 就行了。

这样就只用枚举 $n+m-1$ 个点并求最小值了。

但是如果要 $dp$ 的话还需要再进行 $O(nm)$ 的运算，那么总时间复杂度就是 $O(nm\times(n+m))$ ,还是过不了。这时,我们就需要对 $O(nm)$ 的运算进行优化。

我们会发现，对于任意路径，我们都能在图中找到一条横着或竖着的线段，只经过了路径上的一个点，我们称为定点。那么此时路径就被分为了上下或左右两个部分。这两个部分是不互相干预的。

我们可以用两个$dp$数组去存储。 $dp1[i][j]$ 表示从左上角到 $(i,j)$ 最大和, $dp2[i][j]$ 表示从右下角到     $(i,j)$ 的最大和。那么如果这个定点被确定为$(x,y)$ ,最大和:

$$f(x,y)=dp1[x][y]+dp2[x][y]-2\times a[x][y]$$

那么最大值答案之一就是这个。

但是如果要规避修改，就不能这样做了。我们设将$(X,Y)$修改，那么 $f(X-1,Y-1)$ 就有可能是无效的。但我们发现，只要这个点横坐标或纵坐标与修改点相同，就可以有效避开。

举例子：如果确定 $(X-1,Y)$ ,那么这时取到的最大值为 $dp1[X-1][Y]+dp2[X-1][Y+1]$ 。以此类推。时间复杂度为    $O((n+m)^2)$ ,可以过。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;  
int a[2005][2005], dp1[2005][2005], dp2[2005][2005];
bool pre[2005][2005];
signed main() {
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            scanf("%lld", &a[i][j]);
            if(dp1[i-1][j]>dp1[i][j-1]) pre[i][j]=1;
            dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1])+a[i][j];
        }
    } 
    for(int i=n;i>=1;i--){
        for(int j=m;j>=1;j--) {
            dp2[i][j]=max(dp2[i+1][j],dp2[i][j+1])+a[i][j];
        }
    }
    int x=n,y=m,ans=dp1[n][m];
    for(int total=1;total<n+m;total++) {
        int Ans=dp1[x][y]+dp2[x][y]-2*a[x][y];
        for (int i=1;i<x;i++) Ans=max(Ans,dp2[i][y+1]+dp1[i][y]);
        for (int i=1;i<y;i++) Ans=max(Ans,dp2[x+1][i]+dp1[x][i]);
        for (int i=x+1;i<=n;i++) Ans=max(Ans,dp2[i][y]+dp1[i][y-1]);
        for (int i=y+1;i<=m;i++) Ans=max(Ans,dp2[x][i]+dp1[x-1][i]);
        ans=min(ans,Ans);
        if(pre[x][y]) x--;
        else y--;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：yf最qhhh (赞：1)

 一开始以为是一道水题，就兴致勃勃开始做，然后代码写成了这样。。。。
```cpp
#include<bits/stdc++.h>
using namespace std;
int arr[3005][3005];
bool brr[3005][3005],l=0;
int n,m,ans=INT_MAX;
void dfs(int x,int y,int tot){
	if(tot>=ans)return;
	if(x==n&&y==m){
		if(tot<ans)ans=tot;
		return;
	}	
	brr[x][y]=true;
	if(x+1<=n&&!brr[x+1][y]){
		dfs(x+1,y,tot+arr[x+1][y]);
		if(!l){
			l=1;
			dfs(x+1,y,tot);
			l=0;
		}
	}
	if(y+1<=m&&!brr[x][y+1]){
		dfs(x,y+1,tot+arr[x][y+1]);
		if(!l){
			l=1;
			dfs(x,y+1,tot);
			l=0;
		}
	}
	brr[x][y]=false;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>arr[i][j];
	dfs(1,1,arr[1][1]);	
	l=1;
	dfs(1,1,0);
	cout<<ans;
	return 0;
}
```
 没错我用的深搜

~~超时都是小问题，主要是这份代码还是错的~~

当时是这样想的，把每走一步的情况都模拟一遍，后来发现事情并非那么简单

算了不多说了，直接看我代码吧(我对代码动了点手脚，直接交的话可能会错或者40分噢qwq，还是请多多思考一下吧）
```cpp
#include<iostream>
using namespace std;
int a[2005][2005],f[2005][2005],g[2005][2005],under[2005][2005],right[2005][2005],ans=999999,MAX;
//数据范围是2000，所以就开2005了，ans是最后更新答案用的，所以赋一个比较大的值
int main(){
	int n,m;//输入就不说了
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
		}
	}//从前往后和从后往前算一次
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			g[i][j]=max(g[i+1][j],g[i][j+1])+a[i][j];
		}
	}//下方的情况和右边的情况
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			under[i][j]=max(under[i][j-1],f[i][j]+g[i+1][j]);
		}
	} 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			right[i][j]=max(right[i-1][j],f[i][j]+g[i][j+1]);
		}
	}
  	MAX=1;//给这个临时变量赋一个值
	for(int i=n;i>=1;i--){
     	for(int j=m;j>=1;j--){
       		if(i-1>=0){//这两个是边界情况
       			MAX=max(MAX,right[i-1][j]);
			}
       		if(j-1>=0){
       			MAX=max(MAX,under[i][j-1]);
			}
       		MAX=max(MAX,max(f[i-1][j],f[i][j-1])+max(g[i][j+1],g[i+1][j]));//算出一个值并和ans进行比较
       		ans=min(ans,MAX);
     	}
   	}
   	printf("%d\n",ans);
	return 0; 
}
```
基本的思路和其他题解差不多，就不多赘述了
~~（其实是我懒）~~

另外，关于我代码精简度的问题欢迎各位奆佬发私信指出qwq

---

## 作者：Harry_Hedwig (赞：0)

# 0x00 思路
先看题。
>有 $n\times m$ 的方格矩阵，小 A 从 $(1,1)$ 出发到 $(n,m)$ ，**只能向下或向右**走，获得的分数为他**经过方格的权值之和**。已知每个方格 $(i,j)$ 的权值 $a_{i,j}$ ，你可以将其中**任意一个**方格上的权值变为 $0$，求变化后小 A **最多**能获得分数的**最小值**。

那么我们首先会想到使用枚举的方式讲我把某一个点设为 $0$ 之后小 A 能获得的最大分数，接着求这些最大分数的最小值。

# 0x01 初始化
为了优化时间，我们一定会先把 $(1,1)$ 点到达每一个点得到的最大分数求出。

**可是光这样就行了吗？**

因为我们需要的是从 $(1,1)$ 点到第 $(n,m)$ 点**经过** $(i,j)$ 点的分数最大值，所以我们还需要求出从 $(i,j)$ 点到 $(n,m)$ 点分数的最大值。由于 $(i,j)$ 点不固定，所以我们无法快速地算出分数的最大值，但是我们可以倒过来想：从 $(n,m)$ 点走到 $(i,j)$ 点分数的最大值。

所以我们需要 $2$ 个数组来分别存储从 $(1,1)$ 点到 $(i,j)$ 点与 $(i,j)$ 点到 $(n,m)$ 点（虽然我们是按照从 $(n,m)$ 点走到 $(i,j)$ 点计算但是这里仍写 $(i,j)$ 点到 $(n,m)$ 点。）

那么就有一个简单的初始化了！
## code：
```c
for(i=1;i<=n;i++)//从(1,1)走到(i,j)
	for(j=1;j<=m;j++)
		d[i][j]=max(d[i-1][j],d[i][j-1])+a[i][j];/*a[i][j]为输入,由于d[i][j]只能从d[i-1][j]
或d[i][j-1]过来并求最大值,所以表达式如上。*/
for(i=n;i>0;i--)//从(i,j)走到(n,m)
	for(j=m;j>0;j--)
		p[i][j]=max(p[i+1][j],p[i][j+1])+a[i][j];//反过来求
```

剩下的部分就是 dp 了（~~虽然一点也不像~~）。

# 0x02 动态规划
## 0x02.1 定义状态
$dp[i][j]$：把 $(i,j)$ 点值置为 $0$，从 $(1,1)$ 点走到 $(n,m)$ 点此时的总分最大值。

## 0x02.2 状态转移
这时我们有 $2$ 种选择：一种是经过 $(i,j)$ 点，一种是不经过，由于要求最大值所以需要用```max```。

1. 经过 $(i,j)$ 点

这个状态十分好找，由于我们之前找过从 $(1,1)$ 点到 $(i,j)$ 点（$d[i][j]$）分数的最大值，从 $(i,j)$ 点到 $(n,m)$ 点（$p[i][j]$）分数的最大值，所以直接可以求得。
### code:
```c
dp[i][j]=d[i][j]+p[i][j]-2*a[i][j];/*a[i][j]未改变，但是dp[i][j]表示
为将a[i][j]置为0后取得的最大值。*/
```

2. 不经过 $(i,j)$ 点

这个可能性下还有 $2$ 种可能，因为绕过 $(i,j)$ 点可以从它的左边越过或上面越过具体情况如下:

![](https://cdn.luogu.com.cn/upload/image_hosting/6giwxs4m.png)

也就是说，我们可能从左边的**任意一排**或上方的**任意一排**经过，我们只需要分别算出从左边和上面越过的两种情况分数的最大值即可。

但是很明显暴力找会有 $80\%$ 及以上的几率超时，所以我们需要优化。（~~其实是我没写代码~~）
## 0x02.3 优化

那么我们就可以根据 $(i-1,j)$ 点和 $(i,j-1)$ 点知道前面的所有从左边和上面绕过 $(i,j)$ 点的最大值（都把 $(i-1,j)$ 点和 $(i,j-1)$ 点绕过了还绕不过 $(i,j)$ 点吗？）再算出从 $(i-1,j)$ 与 $(i,j-1)$ 两点绕过 $(i,j)$ 的可能性算出来求最大值就是这种方案的最大值了。
### code:
```c
 	up[i][j]=max(d[i-1][j]+p[i-1][j+1],up[i-1][j]);
	le[i][j]=max(d[i][j-1]+p[i+1][j-1],le[i][j-1]);
```

# 0x03 实现
哦对了，不要忘了开```long long```,由于数据最大为$4\times 10^3\times 10^9=4\times 10^{12}$，```int```明显装不下，所以得开```long long```。
```c
#include<bits/stdc++.h>
using namespace std;
long long d[2005][2005],p[2005][2005],dp[2005][2005],a[2005][2005],up[2005][2005],le[2005][2005];
int main()
{
	int n,m,i,j;
	long long ans=2e32;
	scanf("%d %d",&n,&m);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			scanf("%lld",&a[i][j]);
			d[i][j]=max(d[i-1][j],d[i][j-1])+a[i][j];
		}
	}
	for(i=n;i>0;i--)
		for(j=m;j>0;j--)
			p[i][j]=max(p[i+1][j],p[i][j+1])+a[i][j];
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			dp[i][j]=d[i][j]+p[i][j]-2*a[i][j];
			up[i][j]=max(d[i-1][j]+p[i-1][j+1],up[i-1][j]);
			le[i][j]=max(d[i][j-1]+p[i+1][j-1],le[i][j-1]);
			dp[i][j]=max(dp[i][j],max(up[i][j],le[i][j]));
			ans=min(ans,dp[i][j]);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ZCETHAN (赞：0)

# [T2](https://www.luogu.com.cn/problem/P6855)
## 题目大意
给定一个矩阵($n*m$)，则你可以求从左上走到右下路径上的权值累加和的最大值（要求只能向右或下走）。此时你可以将其中的任意一个元素改成0，求改动哪一个元素，可以使最大值最小。并输出这个最小的最大值。
## 题解
这题的难点就是在你可以将一个格子变成0，那么不妨我们来思考如何求不变成0的最大值。

那就是一道方格取数的问题，$dp$的入门题。

设$dp[i][j]$表示从$(1,1)\to(i,j)$的路径权值的最大值，矩阵存在$a[][]$中，则有：

$$dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]$$

这样可以十分轻松地求得最大值。

---
- 这里是骗分。

此时，我们可以来考虑改动了。如果我改动的元素不在这条已有的最大值的路径上，那么最大值肯定还是这条路径（矩阵元素都是非负的）。所以我改的肯定是在这条路径上会使得答案更小。

那么很容易想到记录一下路径，然后枚举一下路径上的点变成0，然后再求一遍最大值，不断更新答案，就可以求解，复杂度$O(n^3)$，常数较大。


结果$TLE$只有40分。


那么考虑优化这个算法，我们可以发现，对于一个改动的元素，只有其右下方的$dp$数据会随之改变，因此，枚举的时候只需要改动右下方的即可，大大减小了常数。

[这是$TLE$的代码](https://paste.ubuntu.com/p/tKTD6VY87N/)

结果还是被卡了，$TLE$ 70分。

---
- 接下来是正解。

想想有没有一个方法可以$O(1)$地查询**经过**任意一个点的最大权值路径。
其实很简单，只要从起点开始跑一次$dp$，再同样的从终点开始跑一次$dp$，然后对于同一个点，只要两个$dp$加起来就可以了。

那么知道了这个有什么用呢？

那么对于任意的一个格子我就可以知道它改动了之后的结果是多少。

由于任意一条路径总是会穿过一条斜行，那么不妨我们对于一个斜行进行分析：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005211920490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nY2hpemM=,size_16,color_FFFFFF,t_70#pic_center)

如图，如果过红色格子的那条是这一斜行中最大的，那么如果我将这一斜行中别的改动，结果肯定仍然是红色这里最大，如果我改动红色，那么别的节点中次大的有希望超过红色。

因此我只需要求出最大和次大，然后将最大改动后和次大相比较最大的就是这一斜行所能做到的最小值了。

因此我们只需要遍历每一个斜行，然后求一下答案，不断更新，复杂度$O(n^2)$，可以AC。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1<<30
using namespace std;
const int MAXN=2010;
ll dp1[MAXN][MAXN],dp2[MAXN][MAXN];
//分别是从前往后和从后往前
ll a[MAXN][MAXN];
ll get(int x,int y){return dp1[x][y]+dp2[x][y]-a[x][y];}//取过(x,y)的最大路径
//注意两个dp都重复算了(x,y)，因此要减去。
int main()
{
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lld",&a[i][j]),
			dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1])+a[i][j];
	for(int i=n;i>=1;i--)
		for(int j=m;j>=1;j--)
			dp2[i][j]=max(dp2[i+1][j],dp2[i][j+1])+a[i][j];
	ll ans=dp1[n][m];
	for(int i=1;i<=n;i++){
		ll fmax=0,smax=0;int xx,yy;
		//fmax-first_max   smax-second_max
		for(int x=i,y=1;x>=1&&y<=m;x--,y++)
			if(get(x,y)>fmax) smax=fmax,fmax=get(x,y),xx=x,yy=y;
			else if(get(x,y)>smax) smax=get(x,y);
		ans=min(ans,max(smax,fmax-a[xx][yy]));
	}//遍历上三角斜行
	for(int j=2;j<=m;j++){
		ll fmax=0,smax=0;int xx,yy;
		for(int x=n,y=j;x>=1&&y<=m;x--,y++)
			if(get(x,y)>fmax) smax=fmax,fmax=get(x,y),xx=x,yy=y;
			else if(get(x,y)>smax) smax=get(x,y);
		ans=min(ans,max(smax,fmax-a[xx][yy]));
	}printf("%lld\n",ans);
}
```
## END
- 从前往后在从后往前做两遍预处理的技巧

- 对于改动后求最大和最小应该想到次大的问题，联想换根

---


# 「EZEC-6」跳一跳

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zq0mhuy7.png)

小 A 最近迷上了 “跳一跳” 这个游戏。

## 题目描述

小 A 玩的 “跳一跳” 规则如下：

1. 设定一个计数器 $\text{cnt}$，将其初始值设置为 $2$。
2. 若跳上下一个格子但没跳到其中心，加 $1$ 分，将 $\text{cnt}$ 重置为 $2$。
3. 若跳上下一个格子且跳到了其中心，加 $\text{cnt}$ 分，将 $\text{cnt}$ 翻倍。
4. 若下一个格子为特殊格 $x_i$ 且跳到了其中心，额外加 $y_i$ 分。
5. 终止条件为没跳上下一个格子或者跳完了所有格子。

已知共有 $n$ 个格子，编号 $1$ 到 $n$（不包含起始格）。

小 A 跳上下一个格子但**没跳到**其中心的概率为 $a\%$，跳上下一个格子且**跳到了**其中心的概率为 $b\%$，剩余 $(100-a-b)\%$ 为没跳上下一个格子的概率。

求他的期望得分，并对 $10^9+7$ 取模。

## 说明/提示

**【样例 1 解释】**

小 A 每次都会跳上下一个格子且跳到其中心，期望得分为 $2+4+8=14$ 分。

**【样例 2 解释】**

小 A 每次都会跳上下一个格子但没跳到其中心，期望得分为 $1+1+1=3$ 分。

**【样例 3 解释】**

小 A 不可能跳上下一个格子，期望得分为 $0$ 分。

**【样例 4 解释】**

小 A 每次都会跳上下一个格子且跳到其中心，期望得分为 $2+10+4+10+8+10=44$ 分。

**【数据规模与约定】**

**本题采用捆绑测试。**

下表中斜杠代表无特殊限制。

| 子任务 | 分值 | $n$ | $a$ | $b$ | $m$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $=1$ | $=50$ | $=50$ | / |
| $2$ | $9$ | $\le 20$ | / | / | $=0$ |
| $3$ | $10$ | $\le 20$ | / | / | / |
| $4$ | $10$ | $\le 10^5$ | / | / | $=0$ |
| $5$ | $20$ | $\le 10^5$ | / | / | / |
| $6$ | $5$ | / | $=0$ | $=100$ | / |
| $7$ | $5$ | / | $=100$ | $=0$ | / |
| $8$ | $15$ | / | / | / | $=0$ |
| $9$ | $25$ | / | / | / | / |

对于 $100\%$ 的数据，$1\le n\le 10^{18}$，$0\le a,b,a+b\le 100$，$0\le m\le \min(n,10^5)$，$1\le x\le n$，$1\le y\le 100$。

## 样例 #1

### 输入

```
3 0 100
0```

### 输出

```
14```

## 样例 #2

### 输入

```
3 100 0
0```

### 输出

```
3```

## 样例 #3

### 输入

```
3 0 0
0```

### 输出

```
0```

## 样例 #4

### 输入

```
3 0 100
3
1 10
2 10
3 10```

### 输出

```
44```

## 样例 #5

### 输入

```
114 5 14
3
14 15
92 65
100 100```

### 输出

```
190259152```

# 题解

## 作者：幻影星坚强 (赞：9)

官方题解没推式子，于是我们来推式子。

特殊格的贡献可以单独算出，于是转换成没有特殊格的情况。

首先有个非常显然的 $O(n^2)$ 的做法：（以下 $a,b$ 为百分数）

$$
\sum\limits_{k=1}^{n}(\sum\limits_{i=0}^{k-1}(2b)^ia(a+b)^{k-1-i})+(2b)^k
$$

我们把外面的那项进行等比数列求和

$$
\sum\limits_{k=1}^{n}(\sum\limits_{i=0}^{k-1}(2b)^ia(a+b)^{k-1-i})+(2b)^k
$$
$$
=(\sum\limits_{k=1}^{n}(\sum\limits_{i=0}^{k-1}(2b)^ia(a+b)^{k-1-i}))+ \dfrac{(2b)^{n+1}-2b}{2b-1}
$$
$$
=(a\sum\limits_{k=1}^{n}(\sum\limits_{i=0}^{k-1}(2b)^i(a+b)^{k-1-i}))+ \dfrac{(2b)^{n+1}-2b}{2b-1}
$$

我们换一下求和的顺序

$$
\sum\limits_{k=1}^{n}\sum\limits_{i=0}^{k-1}(2b)^i(a+b)^{k-1-i}
$$
$$
=\sum\limits_{i=0}^{n-1}\sum\limits_{k=i+1}^n(2b)^i(a+b)^{k-1-i}
$$
$$
=\sum\limits_{i=0}^{n-1}(2b)^i\sum\limits_{k=i+1}^n(a+b)^{k-1-i}
$$
$$
=\sum\limits_{i=0}^{n-1}(2b)^i\dfrac{(a+b)^{n-i}-1}{a+b-1}
$$

于是我们便有了一个 $O(n)$ 的做法。

继续化简

$$
\sum\limits_{i=0}^{n-1}(2b)^i\dfrac{(a+b)^{n-i}-1}{a+b-1}
$$
$$
=(a+b-1)\sum\limits_{i=0}^{n-1}(2b)^i((a+b)^{n-i}-1)
$$
$$
=(a+b-1)\sum\limits_{i=0}^{n-1}(2b)^i(a+b)^{n-i}-(2b)^i
$$
$$
=(a+b-1)(\dfrac{(2b)^{n+1}-(a+b)^{n+1}}{b-a}-(2b)^n-\dfrac{(2b)^{n}-1}{2b-1})
$$

于是可以 $O(logn)$ 求出。

但实际交上去你发现过不了，因为会出现 $a=b,b=1/2,a+b=1$ 三种情况导致分母为0，所以这些地方特判即可，具体方式就是把这些值带进原式去然后再进行计算化简。

~~除此之外，可以将原 O(n^2) 做法的式子直接扔进 wolframs里，然后他会自动帮你变成 O(logn) 做法的式子。~~

考场代码有很多处细节没处理（指数据没卡），这里贴一个wolframs的式子得到的代码。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const long long MOD = 1e9 + 7;
long long n, a, b;
long long ksm(long long x, long long y)
{
	long long m = 1;
	for (; y; y >>= 1)
	{
		if(y & 1)
		m = m * x % MOD;
		x = x * x % MOD;
	}
	return m;
}
int main()
{
	scanf("%lld%lld%lld", &n, &a, &b);
	int m;
	scanf("%d", &m);
	long long ans = 0;
	long long div100 = ksm(100, MOD - 2);
	a = a * div100 % MOD;
	b = b * div100 % MOD;
	for (int i = 1; i <= m; ++ i)
	{
		long long x, y;
		scanf("%lld%lld", &x, &y);
		(ans += ksm((a + b) % MOD, x - 1) * (b % MOD) % MOD * y % MOD) %= MOD;
	}
	if((a + b) % MOD == 1)
	{
		if(a == b)
		{
			(ans += ksm(4, MOD - 2) * n % MOD * (n + 5) % MOD) %= MOD;
		}
		else
		{
			(ans += (ksm(2, n + 1) * ksm(b, n + 2) % MOD + 2 * b % MOD * b % MOD * (n - 1) - 3 * b * n + n) * ksm(ksm(1 - 2 * b, 2), MOD - 2) % MOD + MOD) %= MOD;
		}
	}
	else
	if(a == b)
	{
		(ans += b * (ksm(2, n + 2) * ksm(b, n + 1) % MOD + ksm(2, n + 1) * n % MOD * ksm(b, n + 1) % MOD - (3 + n) * (ksm(2 * b, n)) - 4 * b + 3) % MOD * ksm(ksm(1 - 2 * b, 2), MOD - 2) % MOD + MOD) %= MOD;
	}
	else
	if(b == (MOD + 1) / 2)
	{
		(ans += (-4 * a % MOD * a % MOD * (ksm(2, n) - ksm(2 * a + 1, n)) % MOD - 2 * a % MOD * (-(ksm(2 * a + 1, n)) + ksm(2, n) * ((n + 1) % MOD) % MOD) % MOD + ksm(2, n) * (n % MOD) % MOD + MOD) * ksm(ksm(1 - 2 * a % MOD + MOD, 2) * ksm(2, n) % MOD, MOD - 2) % MOD + MOD) %= MOD;
	}
	else
	(ans += (a * a % MOD * (2 * b - 1) % MOD * (ksm(a + b, n) - 1) % MOD + a * b % MOD * ((2 * b - 1) * ksm(a + b, n) % MOD - ksm(2 * b, n + 1) + 1) % MOD - 2 * (b - 1) % MOD * b % MOD * b % MOD * (ksm(2 * b, n) - 1) % MOD + MOD) * ksm((2 * b - 1) * (a - b) % MOD * (a + b - 1) % MOD, MOD - 2) % MOD) %= MOD;
	printf("%lld", (ans + MOD) % MOD);
}
```

后记：谢谢良心数据（？）让我比第二个人早17秒拿到首A。

---

## 作者：Ecrade_ (赞：9)

**P0：题外话**

这题其实还可以推式子，这里也不再赘述了。

---

**P1：题解**

### 预处理

先用逆元把百分号处理了：$a\%=\dfrac{a}{100}\equiv a\times 100^{10^9+7-2}\equiv a\times (57\times 10^7+4)\ \ \ \ \ (\bmod \ 10^9+7)$

**下文中为了简便，$a,b$ 均表示经逆元处理后的 $a\%,b\%$。**

再把特殊格处理掉。

按照题目意思，额外加到特殊格 $x$ 的分数 $y$ 概率为 $(a+b)^{x-1}\times b$，即均跳上前 $x-1$ 个格子且跳到了第 $x$ 个格子中心的概率。

故可以预先算出所有特殊格的期望得分之和，即 $\sum\limits_{i=1}^{m}(a+b)^{x_i-1}\times b\times y_i$。

---
### $\text{Subtask 1}$

小 A 有 $50\%$ 概率拿到 $1$ 分，有 $50\%$ 概率拿到 $2$ 分，再加上特殊格，可得期望得分为 $\dfrac{3+y_1}{2}$。

时间复杂度 $O(1)$。
```cpp
int main(){
	cin>>n>>a>>b>>m;
	if (m) cin>>x>>y;
	cout<<(3 + y) * qp(2,mod - 2) % mod;
	return 0;
}
```
---
### $\text{Subtask 2, 3}$

深搜即可，不再赘述。

时间复杂度 $O(2^n)$。
```cpp
void dfs(ll x,ll y,ll z){
	if (x > n) return;
	ans2 = (ans2 + y * z % mod) % mod;
	dfs(x + 1,1,z * a % mod),dfs(x + 1,(y ? 2 * y % mod : 2),z * b % mod);
}
```
---
### $\text{Subtask 4, 5}$

除去特殊格的额外加分，令 $f[i]$ 为第 $i$ 个格子的期望得分。则：

$f[1]=(a+b)^0\times a\times b^0\times2^0+b^1\times2^1$

$f[2]=(a+b)^1\times a\times b^0\times2^0+(a+b)^0\times a\times b^1\times2^1+b^2\times 2^2$

$f[3]=(a+b)^2\times a\times b^0\times2^0+(a+b)^1\times a\times b^1\times2^1+(a+b)^0\times a\times b^2\times2^2+b^3\times 2^3$

$f[4]=(a+b)^3\times a\times b^0\times2^0+(a+b)^2\times a\times b^1\times2^1+(a+b)^1\times a\times b^2\times2^2+(a+b)^0\times a\times b^3\times 2^3+b^4\times2^4$

$\vdots$

发现每个 $f[i]$ 的最后一项 $(2b)^i$ 很碍事，于是我们定义 $f'[i]$ 为 $f[i]-(2b)^i$ 的值。

易推得 $f'[i]=(a+b)\times f'[i-1]+a\times (2b)^{i-1}$

进而 $f$ 数组前 $i$ 项和 $s[i]$ 的递推式为 $s[i]=s[i-1]+f'[i]+(2b)^i$

最终答案为 $s[n]$ 加上特殊格的期望得分，时间复杂度 $O(n)$。
```cpp
int main(){
	n = read(),a = read(),b = read(),m = read(),init();
	for (ll i = 0;i < m;i += 1){
		x = read(),y = read();
		ans = (ans + qp(a + b,x - 1) * b % mod * y % mod) % mod;
	}
	for (ll i = 1;i <= n;i += 1){
		f[i] = ((a + b) * f[i - 1] % mod + a * bb % mod) % mod;
		bb = 2 * b * bb % mod;
		s[i] = (s[i - 1] + f[i] + bb) % mod;
	}
	cout<<(s[n] + ans) % mod;
	return 0;
}
```
---
### $\text{Subtask 6}$

易得答案为 $2^{n+1}-2$ 加上特殊格的期望得分，时间复杂度 $O(\log n)$。

---
### $\text{Subtask 7}$

易得答案为 $n$ 加上特殊格的期望得分，时间复杂度 $O(1)$。

---
### $\text{Subtask 8, 9}$

矩阵优化下前面的递推式即可。

构造矩阵：

$\begin{Bmatrix}s[0]&f[0]&2ab&2b \end{Bmatrix}  \times \begin{Bmatrix}1&0&0&0 \\ 1&a+b&0&0  \\ 0&1&2b&0 \\ 1&0&0&2b\end{Bmatrix}^n=\begin{Bmatrix}s[n]&f[n]&a(2b)^{n+1}&(2b)^{n+1} \end{Bmatrix}$

其中 $s[0]=0,f[0]=a$。

答案为 $s[n]$ 加上特殊格的期望得分，时间复杂度为 $O(\log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,a,b,x,y,ans,hx = 57e7 + 4,mod = 1e9 + 7;
struct st{ll m[5][5];}ma,mb;
inline ll read(){
   ll s = 0,w = 1;
   char ch = getchar();
   while (ch < '0'|| ch > '9'){ if (ch == '-') w = -1; ch = getchar();}
   while (ch >= '0'&& ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
   return s * w;
}
ll qp(ll x,ll y){
	if (!y) return 1;
	ll p = qp(x,y / 2);
	if (y & 1) return p * p % mod * x % mod;
	return p * p % mod;
}
st calc(st a,st b){
    st res; fill(res.m[0],res.m[0] + 5 * 5,0);
    for (int i = 1;i <= 4;i += 1)
        for (int j = 1;j <= 4;j += 1)
            for (int k = 1;k <= 4;k += 1)
                res.m[i][j] = (res.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
    return res;
}
ll qpmx(ll p){
    while (p){
        if (p & 1) ma = calc(ma,mb);
        mb = calc(mb,mb),p >>= 1;
    }
    return ma.m[1][1];
}
void init(){
	a = a * hx % mod,b = b * hx % mod;
	ma.m[1][2] = a,ma.m[1][3] = a * b % mod * 2 % mod,ma.m[1][4] = 2 * b % mod;
	mb.m[1][1] = mb.m[2][1] = mb.m[4][1] = mb.m[3][2] = 1;
	mb.m[2][2] = (a + b) % mod,mb.m[3][3] = mb.m[4][4] = 2 * b % mod;
}
int main(){
	n = read(),a = read(),b = read(),m = read(),init();
	for (ll i = 0;i < m;i += 1){
		x = read(),y = read();
		ans = (ans + qp(a + b,x - 1) * b % mod * y % mod) % mod;
	}
	cout<<(qpmx(n) + ans) % mod;
	return 0;
}
```


---

## 作者：苏联大货司机 (赞：6)

提供一个和 Ecrade_大佬不一样的矩阵构造方式:

(基于Ecrade_的思路展开)

根据Ecrade_的推理可知:
$\begin{cases}S[n]\ \ \ \ \ \ \ \ =1×  S[n-1]+f^{'}[n]+(2b)^n \\ f^{'}[n+1]=0×S[n-1]+(a+b)×f^{'}[n]+a×(2b)^n\\ (2b)^{n+1\ \ \ \ }=0×S[n-1]+0×f^{'}[n]+2b×(2b)^n\end{cases}$

得式子:
$$\begin{bmatrix}S[n]\\f[n+1]\\(2b)^{n+1} \end{bmatrix}=\begin{bmatrix}1&1&1\\0&a+b&a\\0&0&2b\end{bmatrix}×\begin{bmatrix}S[n-1]\\f^{'}[n]\\(2b)^n\end{bmatrix}$$
$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  =\begin{bmatrix}1&1&1\\0&a+b&a\\0&0&2b\end{bmatrix}^{n-1}×\begin{bmatrix}S[1]\\f^{'}[2]\\(2b)^2\end{bmatrix}$$
设$\begin{bmatrix}1&1&1\\0&a+b&a\\0&0&2b\end{bmatrix}$为$A$,则有
$$\begin{bmatrix}S[n]\\f[n+1]\\(2b)^{n+1} \end{bmatrix}=A^n×\begin{bmatrix}a+b×2\\(a+b)×a+a×b×2\\4b^2\end{bmatrix}$$
用$B$储存$A^n$最终得到式子:
$$S[n]=B[1][1]*(a+b×2)+B[1][2][(a+b)×a+a×b×2]+B[1][2]×4b^2$$

**放代码:**

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long 
using namespace std;
const ll p=1000000007;
inline ll Read(){
	ll dx=0,fh=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')	fh=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		dx=dx*10+c-'0';
		c=getchar();
	}
	return dx*fh;
}
ll quick_pow(ll x,ll y){
	ll r=1,base=x,yy=y;
	while(y){
		if(y&1)	r=(r*base)%p;
		base=(base*base)%p;
		y>>=1;
	}
	return r%p;
}
ll n,a,b,m,spe;
struct Matricx{
	ll val[5][5];
};
Matricx Mul(Matricx x,Matricx y){
	Matricx Ans;
	for(int i=1;i<=4;++i)
		for(int j=1;j<=4;++j){
			Ans.val[i][j]=0;
			for(int k=1;k<=4;++k)	Ans.val[i][j]=(Ans.val[i][j]+((x.val[i][k]%p)*(y.val[k][j]%p))%p)%p;
			Ans.val[i][j]%=p;
		}
	return Ans;
}
Matricx quickpow(Matricx x,ll y){
	Matricx r,base=x;
	for(int i=1;i<=4;++i){
		for(int j=1;j<=4;++j)	r.val[i][j]=0;
		r.val[i][i]=1;
	}
	while(y){
		if(y&1) r=Mul(r,base);
		base=Mul(base,base);
		y>>=1;
	}
	return r;
}
Matricx A,B;
int main(){
	n=Read(),a=Read(),b=Read(),m=Read();
	a=a*570000004%p,b=b*570000004%p;
	for(int i=1;i<=m;++i){
		ll spe_num=Read(),spe_score=Read();
		spe=(spe+quick_pow(a+b,spe_num-1)*b%p*spe_score%p)%p;
	}
	A.val[1][1]=1,A.val[1][2]=1,A.val[1][3]=1;
	A.val[2][1]=0,A.val[2][2]=a+b,A.val[2][3]=a;
	A.val[3][1]=0,A.val[3][2]=0,A.val[3][3]=2*b;
	B=quickpow(A,n-1);
	ll s1=(a+b*2)%p,f2=( ((a+b)*a)%p + (a*b*2)%p  )%p;
	printf("%u\n",(((B.val[1][1]*s1%p + B.val[1][2]*f2%p)%p + B.val[1][3]*((4*b*b)%p)%p)%p +spe%p)%p);
	return 0;
}

```
### 记住打完代码后一定要检查一下每个式子有没有漏取模！本人因为这玩意从早上九点查到了下午三点半！

---

## 作者：ZigZagKmp (赞：3)

~~居然没有直接用期望的线性性来推柿子做的题解~~

### 题意简述

有 $n$ 个格子，每一次可以跳到下一个格子。现在要从 $0$ 号格子出发，得分如下计算：

- 有一个计数器 $cnt$ ，初值为 $2$
- 选择跳法 $A$ ，得分 $+1$ ，$cnt:=2$
- 选择跳法 $B$ ，得分 $+cnt$，$cnt:=2\times cnt$
- 跳失败，得分不变，游戏结束。
- 有 $m$ 个特殊格，第 $i$ 个特殊格编号为 $x_i$ ，如果跳上这些格子时选择跳法 $B$ ，得分 $+y_i$
- 选择跳法 $A$ 的概率为 $a\%$，跳法 $A$ 的概率为 $b\%$，其余跳失败。

求得分期望。

$n\le 10^{18},m\le 10^5$

### 算法分析

这里先把百分比转化为概率，求逆元即可。

下设 $A=a\%\ ,\ B=b\%$。

由期望的线性性，我们可以把三种得分变化分别计算，最后相加即为答案。

1. 选择跳法 $A$ ，得分 $+1$

我们发现对于一个格子，只要能跳到这个格子前一个格子，且这一步选择跳法 $A$ ，就可以贡献 $1$ 的得分，答案即为：

$$\sum\limits_{i=1}^n(A+B)^{i-1}\times A$$

其中 $(A+B)^{i-1}$ 表示前 $i-1$ 步跳成功，$A$ 表示恰好第 $i$ 步选 $A$ 。

这个式子容易用等比数列求和公式计算，即：

$$
\begin{cases}
A\times n&A+B=1\\
A\times \frac{1-(A+B)^n}{1-(A+B)}&A+B\neq1
\end{cases}
$$

2. 特殊格 $x_i$ ，用跳法 $B$ ，得分 $+y_i$

同样，我们要能跳到这个格子前一个格子，且这一步选择跳法 $B$ ，就有 $y_i$ 的贡献，答案即为：

$$\sum\limits_{i=1}^m(A+B)^{x_i-1}\times B\times y_i$$

其中 $(A+B)^{x_i-1}$ 表示前 $x_i-1$ 步跳成功，$B$ 表示恰好第 $i$ 步选 $B$ 。

这个可以快速幂直接算出，时间复杂度为 $O(m\log n)$ 。

3. 选择跳法 $B$ ，得分 $+cnt$

我们首先要求出第 $i$ 个格子上 $cnt$ 的期望值，记为 $E(i)$ ，则答案为：

$$\sum\limits_{i=1}^{n}E(i-1)\times B$$

其中 $E(i-1)$ 表示跳完第 $i-1$ 格后 $cnt$ 的期望，也就是跳第 $i$ 格时可能加上的 $cnt$ 的期望。

下面我们考虑如何求出 $E(i)$ 。由期望的线性性，我们把 $E(i)$ 拆成这个格子翻倍和这个格子重归 $2$ 两种情况，不难得出如下式子：

$$E(i)=2B\times E(i-1)+2A\times (A+B)^{i-1}$$

前面表示 $B$ 的概率翻倍，这里要 $\times2$，后面表示 $A$ 的概率重归 $2$ ，都有 $2$ 的贡献，同时还要求能跳到第 $i-1$ 个格子，即乘上 $(A+B)^{i-1}$ 。

这里直接计算时间复杂度为 $O(n)$ ，无法接受，考虑优化。

发现 $n$ 很大，但是相关联的信息很少，考虑矩阵加速。因为最后统计的是前缀和，我们在矩阵中还要再加一维对前缀和的转移。记 $S(n)=\sum\limits_{i=0}^nE(i)$ ，则有如下转移：

$$\begin{aligned}
E(i)&=2B\times E(i-1)+2A\times (A+B)^{i-1}\\
(A+B)^i&=(A+B)\times(A+B)^{i-1}\\
S(i-1)&=S(i-2)+E(i-1)
\end{aligned}$$

如下设计转移矩阵：
$$\begin{Bmatrix}E(i-1)&(A+B)^{i-1}&S(i-2) \end{Bmatrix} \times \begin{Bmatrix}2B&0&1 \\ 2A&A+B&0 \\ 0&0&1\end{Bmatrix}=\begin{Bmatrix}E(i)&(A+B)^{i}&S(i-1) \end{Bmatrix}$$

加上矩阵快速幂优化即可，时间复杂度 $O(3^3\log n)$ 。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000005
#define maxm 2000005
#define inf 0x3f3f3f3f
#define int long long
#define ull unsigned long long
#define mod 1000000007
#define eps 1e-6
#define local
template <typename Tp> void read(Tp &x){
	int fh=1;char c=getchar();x=0;
	while(c>'9'||c<'0'){if(c=='-'){fh=-1;}c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c&15);c=getchar();}x*=fh;
}
int ksm(int b,int p,int Mod=mod){int ret=1;while(p){if(p&1)ret=1ll*ret*b%Mod;b=1ll*b*b%Mod;p>>=1;}return ret;}
int n,m,A,B;
int ans;
int xi[maxn],yi[maxn];
int tmp[3];
struct Mat{
	int a[3][3];
	Mat(){memset(a,0,sizeof(a));}
	Mat operator *(Mat b)const{//矩阵乘法
		Mat c;
		for(int i=0;i<3;++i){
			for(int j=0;j<3;++j){
				for(int k=0;k<3;++k){
					c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j]%mod)%mod; 
				}
			}
		}
		return c;
	}
	void mul(int *b){//1*n的矩阵左乘n*n的矩阵可以优化到n^2
		memset(tmp,0,sizeof(tmp));
		for(int j=0;j<3;++j){
			for(int k=0;k<3;++k){
				tmp[j]=(tmp[j]+1ll*b[k]*a[k][j])%mod;
			}
		}
		memcpy(b,tmp,sizeof(tmp));
	}
};
int ksm(int p){//矩阵快速幂
	int ret[3]={2,1,0};
	Mat b;
	b.a[0][0]=2*B;b.a[1][0]=2*A;b.a[1][1]=A+B;b.a[0][2]=1;b.a[2][2]=1;
	while(p){
		if(p&1)b.mul(ret);
		b=b*b;
		p>>=1;
	}
	return ret[2];
}
signed main(){
	read(n);read(A);read(B);
	A=A*ksm(100,mod-2)%mod;
	B=B*ksm(100,mod-2)%mod;//预处理逆元
	read(m);
	for(int i=1;i<=m;++i){
		read(xi[i]);read(yi[i]);
	}
	ans=ksm(n)*B%mod;//跳 B
	if((A+B)%mod==1){//跳 A
		ans=(ans+n%mod*A%mod)%mod;
	}
	else{
		ans=(ans+(1-ksm(A+B,n))*ksm(1-A-B,mod-2)%mod*A%mod)%mod;
	}
	for(int i=1;i<=m;++i){//特殊格
		ans=(ans+1ll*ksm(A+B,xi[i]-1)*B%mod*yi[i]%mod)%mod;
	}
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：佬头 (赞：2)

## Description
[**跳一跳**](https://www.luogu.com.cn/problem/P7385)规则如下：
1. 设定一个计数器 $\text{cnt}$，将其初始值设置为 $2$。
2. 若跳上下一个格子但没跳到其中心，加 $1$ 分，将 $\text{cnt}$ 重置为 $2$。
3. 若跳上下一个格子且**跳到了其中心**，加 $\text{cnt}$ 分，将 $\text{cnt}$ 翻倍。
4. 若下一个格子为特殊格 $x_i$ 且跳到了其中心，额外加 $y_i$ 分。
5. 终止条件为没跳上下一个格子或者跳完了所有格子。

已知共有 $n$ 个格子，编号 $1$ 到 $n$（不包含起始格）。

小 A 跳上下一个格子但**没跳到**其中心的概率为 $a\%$，跳上下一个格子且**跳到了**其中心的概率为 $b\%$，剩余 $(100-a-b)\%$ 为没跳上下一个格子的概率。

求他的期望得分，并对 $10^9+7$ 取模。

## Solution
转移矩阵好像还有好多种，那我就再来一种。

首先加分大致有两种：
-	跳到某个格子，根据 $2,3$ 规则加分；
-	跳到指定格子的中心，获得指定加分。

两者之间没有太大关系，可以分开考虑。

对于第二种，只要求出跳到 $x_i-1$ 的概率，再乘上跳到 $x_i$ 中心的概率 $b\%$ 和加分 $y_i$，就是 $x_i$ 在规则 $4$ 中的期望得分。显然能跳上下一个格子的概率是 $(a\%+b\%)$，那么跳到 $x_i-1$ 的概率就是 $(a\%+b\%)^{x_i-1}$，然后更新答案 $ans\gets ans+(a\%+b\%)^{x_i-1}b\%y_i$。$x_i$ 的范围很大，需要用到[**快速幂**](https://www.luogu.com.cn/problem/P1226)。

对于第一种，看看能不能找规律，设 $f_n$ 表示第 $n$ 个格子的期望得分：
$$\begin{aligned}

f_1&=(a\%+2b\%)

\\f_2&=(a\%+b\%)a\%\times1+a\%b\%\times2^1+(b\%)^2\times2^2
\\&=(a\%+b\%)a\%+2(a\%+2b\%)b\%
\\&=(a\%+2b\%)2^1(b\%)^1+(a\%+b\%)a\%

\\f_3&=(a\%+b\%)^2a\%\times1+(a\%+b\%)a\%b\%\times2^1+a\%(b\%)^2\times2^2+(b\%)^3\times2^3
\\&=(a\%+b\%)^2a\%+2(a\%+b\%)a\%b\%+2^2(a\%+2b\%)(b\%)^2
\\&=(a\%+2b\%)2^2(b\%)^2+(a\%+b\%)a\%2b\%+(a\%+b\%)^2a\%
\\&\dots
\end{aligned}$$

密密麻麻的，放在一起看：
$$\begin{aligned}

f_1&=(a\%+2b\%)

\\f_2&=(a\%+2b\%)2^1(b\%)^1+(a\%+b\%)a\%

\\f_3&=(a\%+2b\%)2^2(b\%)^2+(a\%+b\%)a\%2b\%+(a\%+b\%)^2a\%
\\&\dots
\end{aligned}$$
那递推式不就是：
$$f_n=f_{n-1}\times2b\%+(a\%+b\%)^{n-1}a\%$$

然后再求一个前缀和。但是还不够：$1\le n\le10^{18}$。考虑[**矩阵快速幂**](https://www.luogu.com.cn/problem/P3390)优化。设 $s_n$ 表示 $\sum\limits_{i=1}^{n}f_i$。（显然递推式就是 $s_n=s_{n-1+f_n}$）

根据上述两个式子，先构造出一个矩阵（把式子里有用的都加进去）：

$$\begin{bmatrix}s_n&f_{n+1}&(a\%+b\%)^{n+1}\end{bmatrix}$$

然后尝试构造出转移矩阵：
$$A=\begin{bmatrix}1&0&0\\1&2b\%&0\\0&a\%&a\%+b\%\end{bmatrix}$$

那么：
$$\begin{aligned}

\begin{bmatrix}s_n&f_{n+1}&(a\%+b\%)^{n+1}\end{bmatrix}&=

\begin{bmatrix}s_{n-1}&f_n&(a\%+b\%)^n\end{bmatrix}\times

A\\&=

\begin{bmatrix}0&a\%+2b\%&a\%+b\%\end{bmatrix}\times

A^n

\end{aligned}$$

看到这么多 $a\%,b\%$ 相乘的同时还要取模，肯定要先把 $a\%,b\%$ 在模 $10^9+7$ 下的[**逆元**](https://www.luogu.com.cn/blog/Glory-of-the-King/ni-yuan)求出来。

最后回过头来再看我们的这个式子：
$$f_n=f_{n-1}\times2b\%+(a\%+b\%)^{n-1}a\%$$

考虑正向推导一下：
-	跳到第 $n$ 格的中心。事实上如果把规则 $2$ 的“加 $1$ 分”理解为“将 $\text{cnt}$ 重置为 $1$，然后进入规则 $3$”，那么我跳到 $n$ 的中心后，就是把跳到 $n-1$ 格的所有贡献都乘上 $2$，即“$\text{cnt}$ 翻倍”了，然后再乘上概率 $b\%$。贡献是 $f_{n-1}\times2b\%$。
-	跳到第 $n$ 格但没跳到中心。基本与跳特殊格类似，首先算出跳到 $n-1$ 格的概率，只不过最后乘上的是 $a\%$。贡献是 $(a\%+b\%)^{n-1}a\%$。

剩下的套个模板就行。时间复杂度 $\mathcal O(m\log n)$

不开 `long long` 见祖宗！！~~WA 了两发，先是 n 没开，又是 x 没开。~~

## Code
```cpp
#include <iostream>
#define ll long long
using namespace std;
const int mod = 1000000007;
ll n;
int a, b, m;
ll read(){
	ll x = 0;
	bool tf = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a == '-'? tf = 1: -1 ,a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return tf? -x: x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
struct mat{
	int a[3][3];
	mat operator *(const mat &nex){
		mat ans;
		for(int i = 0; i < 3; ++ i)
			for(int j = 0; j < 3; ++ j){
				ans.a[i][j] = 0;
				for(int k = 0; k < 3; ++ k)
					ans.a[i][j] = (ans.a[i][j] + (ll)a[i][k] * nex.a[k][j]) % mod;
			}
		return ans;
	}
} ans, base;
void inv(int &a){
	int p = mod - 2, base = 100;
	while(p > 0){
		if(p & 1) a = (ll)a * base % mod;
		base = (ll)base * base % mod;
		p >>= 1;
	}
}
int main(){
	n = read(), a = read(), b = read();
	inv(a), inv(b);
	ans.a[0][1] = (a + (b << 1) % mod) % mod, ans.a[0][2] = (a + b) % mod;
	base.a[0][0] = 1, base.a[1][0] = 1;
	base.a[1][1] = (b << 1) % mod, base.a[2][1] = a;
	base.a[2][2] = (a + b) % mod;
	while(n > 0){
		if(n & 1) ans = ans * base;
		base = base * base;
		n >>= 1;
	}
	m = read();
	for(int i = 1; i <= m; ++ i){
		ll x = read() - 1;
		int y = read(), v = b, t = a + b;
		while(x > 0){
			if(x & 1) v = (ll)v * t % mod;
			t = (ll)t * t % mod;
			x >>= 1;
		}
		ans.a[0][0] = (ans.a[0][0] + (ll)y * v) % mod;
	}
	write(ans.a[0][0]);
	return 0;
}
```

---

## 作者：lndjy (赞：1)

递推式部分可以去看出题人的题解，这里提供另一种 $3\times 3$ 的矩阵构造方法。

首先根据递推式得到目标矩阵：

$$\begin{vmatrix}f_i\\s_i\\(2b)^i\end{vmatrix}$$

然后我们观察到 $s_i=s_{i-1}+f_i+(2b)^i$ 中，$s_i$ 的转移需要 $f_i$，不能直接转移。但是 $f_i$ 可以通过 $f_{i-1}$ 转移到，所以 $s_i$ 也可以通过 $f_{i-1}$ 转移到，只要在 $s_i$ 的转移中加上 $f_i$ 转移对应的系数就可以了。

于是可以得到如下转移矩阵：

$$\begin{vmatrix}a+b&0&a\\a+b&1&a+2b\\0&0&2b\end{vmatrix}$$

初始矩阵只有 $2b$ 那一项是 $1$（$(2b)^0$ 次方为 $1$），其他是 $0$。

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int N=1e5+5,p=1e9+7;
struct matrix
{
	int a[4][4];
	matrix(){memset(a,0,sizeof a);}
	matrix operator *(matrix b)
	{
		matrix c;
		for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		for(int k=1;k<=3;k++)
		c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j]%p)%p;
		return c;
	}
}base,ans;
int qp(int x,int y)
{
	int ans=1;
	while(y)
	{
		if(y&1) ans=ans*x%p;
		x=x*x%p;
		y>>=1;
	}
	return ans;
}
int n,A,B,m,sum;
signed main()
{
	cin>>n>>A>>B>>m;
	A=A*qp(100,p-2)%p;
	B=B*qp(100,p-2)%p;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		sum=(sum+qp((A+B)%p,x-1)*B%p*y%p)%p;
	}
	base.a[1][1]=(A+B)%p;
	base.a[1][3]=A;
	base.a[2][1]=A+B;
	base.a[2][2]=1;
	base.a[2][3]=(A+2*B%p)%p;
	base.a[3][3]=2*B%p;
	ans.a[3][1]=1;
	while(n)
	{
		if(n&1) ans=base*ans;
		base=base*base;
		n>>=1;
	}
	cout<<(sum+ans.a[2][1])%p;
	return 0;
}
```


---

## 作者：破壁人罗辑 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7385)

这篇题解将给出一种新的矩阵构造思路。

## 题意简述

1. 设定一个计数器 $\text{cnt}$，将其初始值设置为 $2$。
2. 若跳上下一个格子但没跳到其中心，加 $1$ 分，将 $\text{cnt}$ 重置为 $2$。
3. 若跳上下一个格子且跳到了其中心，加 $\text{cnt}$ 分，将 $\text{cnt}$ 翻倍。
4. 若下一个格子为特殊格 $x_i$ 且跳到了其中心，额外加 $y_i$ 分。
5. 终止条件为没跳上下一个格子或者跳完了所有格子。

已知共有 $n$ 个格子，编号 $1$ 到 $n$（不包含起始格）。

跳上下一个格子但没跳到其中心的概率为 $a\%$，跳到下一个格子的中心的概率为 $b\%$，剩余 $(100-a-b)\%$ 为没跳上下一个格子的概率。

求期望得分对 $10^9+7$ 取模。

## 解题思路

为简便，下文中的 $a,b$ 均表示模 $10^9+7$ 意义下的 $\frac{a}{100},\frac{b}{100}$。

设 $cnt_n$ 表示成功跳到第 $n$ 次的情况下 $cnt$ 的期望值，$val_n$ 表示成功进行第 $n$ 次跳跃的情况以及在第 $n$ 次跳跃前已经没跳上格子的情况的得分的期望值。

易知 $cnt_0=2,val_0=0,val_{n+1}=val_n+(a+b)^{n-1}(a+b\cdot cnt_{n-1})$。

当 $a+b=0$ 时，$a+b=0,val_n=0$。

当 $a+b\neq 0$ 时，我们可以得到以下等式：

$$cnt_n=2\left(\frac{2b}{a+b}\right)^n+\frac{2a}{a+b}\sum_{i=0}^{n-1}\left(\frac{2b}{a+b}\right)^i$$

- 当 $a\neq b$ 时，我们可以得到以下等式：

$$\begin{aligned}
	cnt_n&=2\left(\frac{2b}{a+b}\right)^n+\frac{2a}{a+b}\sum_{i=0}^{n-1}\left(\frac{2b}{a+b}\right)^i\\
	&=2\left(\frac{2b}{a+b}\right)^n+\frac{2a}{a+b}\frac{\left(\frac{2b}{a+b}\right)^n-1}{\frac{2b}{a+b}-1}\\
	&=\left(2+\frac{2a}{b-a}\right)\left(\frac{2b}{a+b}\right)^n-\frac{2a}{b-a}
\end{aligned}\\
\begin{aligned}
	val_n&=val_{n-1}+(a+b)^{n-1}(a+b\cdot cnt_{n-1})\\
	&=val_{n-1}+(a+b)^{n-1}\left\{a+b\left[\left(2+\frac{2a}{b-a}\right)\left(\frac{2b}{a+b}\right)^{n-1}-\frac{2a}{b-a}\right]\right\}\\
	&=val_{n-1}+\left(a-\frac{2ab}{b-a}\right)(a+b)^{n-1}+b\left(2+\frac{2a}{b-a}\right)(2b)^{n-1}
\end{aligned}$$

所以我们可以构造如下矩阵：

$$\begin{aligned}\begin{pmatrix}
	val_n\\(a+b)^n\\(2b)^n
\end{pmatrix}&=\begin{pmatrix}
	1&a\left(1-\frac{2b}{b-a}\right)&b\left(2+\frac{2a}{b-a}\right)\\
	0&a+b&0\\
	0&0&2b
\end{pmatrix}\begin{pmatrix}
	val_{n-1}\\(a+b)^{n-1}\\(2b)^{n-1}
\end{pmatrix}\\
&=\begin{pmatrix}
	1&a\left(1-\frac{2b}{b-a}\right)&b\left(2+\frac{2a}{b-a}\right)\\
	0&a+b&0\\
	0&0&2b
\end{pmatrix}^n\begin{pmatrix}0\\1\\1\end{pmatrix}\end{aligned}$$

- 当 $a=b$ 时，我们可以得到以下等式：

$$cnt_n=2\left(\frac{2b}{a+b}\right)^n+\frac{2a}{a+b}\sum_{i=0}^{n-1}\left(\frac{2b}{a+b}\right)^i=n+2\\\begin{aligned}
val_n&=val_{n-1}+(a+b)^{n-1}(a+b\cdot cnt_{n-1})\\
&=val_{n-1}+(2b)^{n-1}b(n+2)
\end{aligned}$$

- - 若 $2a=2b=1$，则我们可以得到以下等式：

$$\begin{aligned}
val_n&=val_{n-1}+\frac{n}2+1\\
&=val_0+\sum_{i=1}^n\left(\frac{i}{2}+1\right)\\
&=\frac{n^2+5n}{4}
\end{aligned}$$

- - 否则，我们可以得到以下等式：

$$\begin{aligned}
	val_n+(2a)^na\left(\frac{n}{1-2a}+\frac{3-4a}{(1-2a)^2}\right)&=val_{n-1}+(2a)^{n-1}a\left(\frac{n-1}{1-2a}+\frac{3-4a}{(1-2a)^2}\right)\\
    &=\frac{3a-4a^2}{(1-2a)^2}\\
	val_n&=\frac{(2a)^na[(2a-1)n+4a-3]+3a-4a^2}{(1-2a)^2}
\end{aligned}$$

## AC 代码
```cpp
#include<bits/stdc++.h>
#define MOD 1000000007ll
#define div100 570000004ll
using namespace std;
int qpow(int x,int n){
	int r=1;
	while(n){
		if(n&1)r=r*(long long)x%MOD;
		x=x*(long long)x%MOD;n>>=1;
	}
	return r;
}
template<class t>
t Read(){
	char c=getchar();while(c<'0')c=getchar();
	t r=0;while(c>='0'){r=r*10+(c^48);c=getchar();}
	return r;
}
struct matrix{
	int a[3][3];
};
matrix operator*(matrix x,matrix y){
	matrix ret;
	for(int i=0;i<3;i++)for(int j=0;j<3;j++)
		ret.a[i][j]=(x.a[i][0]*(long long)y.a[0][j]+x.a[i][1]*(long long)y.a[1][j]+x.a[i][2]*(long long)y.a[2][j])%MOD;
	return ret;
}
matrix qpow(matrix x,long long n){
	matrix ret;ret.a[0][0]=ret.a[1][1]=ret.a[2][2]=1;
	ret.a[0][1]=ret.a[1][0]=ret.a[0][2]=ret.a[2][0]=ret.a[1][2]=ret.a[2][1]=0;
	while(n){
		if(n&1)ret=ret*x;
		x=x*x;n>>=1;
	}
	return ret;
}
signed main(){
	long long n=Read<long long>();int a=Read<int>(),b=Read<int>(),ans;
	if(a==100){
		printf("%lld",n%MOD);
		return 0;
	}
	if(b==100){
		ans=(qpow(2,(n+1)%(MOD-1))+MOD-2)%MOD;
		b=1;
	}
	else{
		a=a*div100%MOD;b=b*div100%MOD;
		if(a==b){
			if((a+b)%MOD==1){
				n%=MOD;
				ans=((5+n)*n%MOD)*a%MOD*a%MOD;
			}
			else ans=(((2+n)%MOD*qpow(b<<1,(n+1)%(MOD-1))%MOD-(3+n)%MOD*qpow(b<<1,n%(MOD-1))-4ll*b+3)*b%MOD*qpow((b<<1)-1,MOD-3)%MOD+MOD)%MOD;
		}
		else{
			matrix m;
			m.a[0][0]=1;m.a[1][0]=m.a[1][2]=m.a[2][0]=m.a[2][1]=0;
			m.a[1][1]=a+b;m.a[2][2]=b<<1;
			m.a[0][1]=(a*(1-b*2ll*qpow(b-a,MOD-2)%MOD)%MOD+MOD)%MOD;
			m.a[0][2]=(b*(2+a*2ll*qpow(b-a,MOD-2)%MOD)%MOD+MOD)%MOD;
			m=qpow(m,n);
			ans=(m.a[0][1]+m.a[0][2])%MOD;
		}
	}
	if(b){
		int m=Read<int>();
		while(m--){
			int x=(Read<long long>()-1)%(MOD-1);
			ans=(ans+Read<long long>()*qpow(a+b,x)%MOD*b%MOD)%MOD;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---


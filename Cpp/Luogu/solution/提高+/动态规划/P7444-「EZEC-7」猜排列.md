# 「EZEC-7」猜排列

## 题目背景

Update：数据已经经过加强。

## 题目描述

Alice 手上有一个长度为 $n$ 的排列 $a$，排列中的数为 $0,1,2,\cdots,n-1$。

Bob 闲来无事，想去猜它。但 Alice 不想让他轻易猜到。

于是他抛给了 Bob 一些条件，让他来猜这个排列。

我们定义 $f(l,r)=\text{mex}\{a_l,a_{l+1},\cdots,a_r\}$，其中 $\text{mex}$ 函数代表一个可重集中**没有出现过**的最小**非负整数**。

而 Alice 说出的条件包含 $n$ 个数，第 $i$ 个数代表着满足 $1 \leq l \leq r \leq n$ 且 $f(l,r)=i-1$ 的二元组 $(l,r)$ 的个数。

Bob 一下就知道这并不能确认整个排列了，因此他想知道符合已有条件的排列数量。

## 说明/提示

**【样例解释】**

第一个样例中存在两个满足条件的排列，分别为：

$\{1,0,2,3\}$ 和 $\{3,2,0,1\}$ 。

第二个样例可以通过枚举发现没有符合题意的解。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（4 points）：$n\leq 8$。
* Subtask 2（8 points）：$n\leq 20$。
* Subtask 3（16 points）：$n\leq 100$。
* Subtask 4（32 points）：$n\leq 2\times 10^3$。
* Subtask 5（20 points）：$n\leq 10^5$。
* Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5 $，$c_i \ge 0$，保证 $\sum^{n}_{i=1}c_i=\frac{n(n+1)}{2}-1$。

## 样例 #1

### 输入

```
4
4 3 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
4 0 3 2```

### 输出

```
0```

# 题解

## 作者：Mophie (赞：14)

提示：下列设 Alice 给出的数为 $a_1,a_2, \ldots ,a_n$，他手中的排列为 $b_1,b_2, \ldots ,b_n$。

### $\texttt{Subtask 1}$ 

啥都不用说了，爆搜吧（

时间复杂度 $O(n^3 \times n!)$ 

当然你也可以无聊地将它优化成 $O(n^2 \times n!)$ …… 不过不需要。

期望得分：$5$

### $\texttt{Subtask 2}$ 

专门留给一些指数做法和爆搜剪枝做法，听一些神仙说好像可以。

自己没试过。

时间复杂度 $O(?)$

期望得分： $15$

### $\texttt{Subtask 3}$ 

首先经过一定的思考过后，我们发现做完后再 check 的方法并不好。

那就考虑能不能从小到大塞进去。

因为很显然，若 $i>j$，则 $i$ 的位置不会影响 $j$。 

换而言之，就是只有当 $i \leq j$ 时，$i$ 的位置才会影响 $j$。

那么首先，若需 $f_{l,r}=j$ ,则 $b_l,b_{l+1},...,b_r$ 必须包含 $1 - (j-1)$ 中所有的数。

则设包含这些数的最小区间的左端点为 $L$，右端点为 $R$。

分三种情况讨论：

- $j$ 在 $[L,R]$ 中



那么很显然，此时必须满足 $a_j=0 $。 

- $j$ 在 $[1,L-1]$ 中



此时，设 $j$ 的位置为 $pos$，则左端点可以选取 $[pos+1,L]$，右端点可以选取 $[R,n]$，所以 $a_j=(n-R+1) \times (L-pos)$。

- $j$ 在 $[R+1,n]$ 中



与上面完全对称，可以得出 $a_j=L \times (pos-R)$。

可以发现， $a_j$ 的值完全只与 $L,R,pos$ 有关。而且很显然， $pos$ 可以轻松用 $a_j,L,R$ 表示和检验是否成立。

那么就可以用 $dp_{i,l,r}$ 来表示当选了 $i$，满足 $a_i$ 的条件且包含 $1-i$ 的最小区间为 $[l,r]$ 的情况种数。

转移方程应该以 $i-1$ 转移到 $i$ 来写更加方便（个人认为）。

若 $a_i = 0$，因为 $i$ 必须放在 $[l,r]$ 中间，所以 $dp_{i,l,r}=dp_{i-1,l,r} \times [r-l+1-(i-1)]=dp_{i-1,l,r} \times (r-l-i+2)$。

若 $a[i] \neq 0$，分两种情况：

- 若 $pos<l$

则根据上文推出的结论，当 $(n-r+1)\mid a_i$ 时，设 $\dfrac{a_i}{n-r+1}=p$。

则 $l-pos=p$，$pos=l-p$，区间扩张成 $[pos,r]$ 即 $[l-p,r]$，

所以可以得到 $dp_{i,l-p,r}+=dp_{i-1,l,r}$。

- 若 $pos>r$

推理过程与上面类似，最终可以得到设 $\dfrac{a_i}{l}=p$，则区间扩张成 $[l,r+p]$，所以可以得到 $dp_{i,l,r+p}+=dp_{i-1,l,r}$。

只需枚举 $i,l,r$ 即可，时间复杂度 $O(n^3)$。

期望得分： $35$ 

### $\texttt{Subtask 4}$  

因为在 $\texttt{Subtask 3}$ 中，定义的状态是三维的，显然过不了这个点。

那么就要尝试将它压到二维的。

通过一番找规律，可以发现：

**每一个 $dp_{i,l,r}$，当它的状态是存在的时侯，一个 $l$ 只对应唯一的 $r$**

证明如下：

因为可以得到所有 $1-i$ 的数都在区间 $[l,r]$ 内，所以若 $f_{l_1,r_1}> i$ ,则 $l_1\leq l,r_1 \geq r$。

故根据乘法原理得 $\sum_{k=i+1}^{n+1}a_k=l \times (n-r+1)$ 。

而 $\sum_{k=i+1}^{n+1}a_k$ 是原有的。

所以当一个 $l$ 固定时， $n-r+1$ 也是固定的。

因此 $r$ 是固定的。

计算 $\sum_{k=i+1}^{n+1}$ 时可先算出 $\sum_{p=1}^{i}a_p$ ,然后因为


$\sum_{k=i+1}^{n+1}a_p=\sum_{j=1}^{n+1}a_j-\sum_{p=1}^{i}a_p $。 


所以 $\sum_{k=i+1}^{n}a_k$ 也就算出来了。

因此每一个 $l$ 可以轻松算出另一个 $r$ ，成功把状态压成了 $2$ 位。

当然你把他优化成滚动数组那更好（

**注意特判 $i=1$**

时间复杂度 $O(n^2)$。

期望得分： $65$

### $\texttt{Subtask 5}$  

可以发现 $\texttt{Subtask 4}$ 的做法中有很多无用状态，不需要全部枚举。

- 若 $a_i \neq 0$

此时 $dp_{i-1,l}$ 对 $dp_{i,k}$ 有贡献的话必须满足 $l\mid a_i$ 或 $(n-r+1)\mid a_i$。

那么枚举 $l$ 和 $(n-r+1)$ 即可，时间复杂度为 $O(\sum\sqrt{a_i})$。

而根据柯西不等式：

$$(\sum_{i=1}^{n} \sqrt{a_i})^2\leq (1 \times n)(\sum_{i=1}^{n}a_i)=(1\times n)(n\times(n+1)/2)<n^{\frac{3}{2}}$$

可以得到时间复杂度为 $O(n\sqrt n)$

- 若 $a_i=0$

根据 $\texttt{Subtask 3}$ 的思路，当 $a_i=0$ 时左区间的长度要从  $1-(n-i+1)$ 全部遍历一遍来转移。

首先可以发现，$0$ 的个数可能很多，比如把 $1,2$ 放两端，则会有 $n-2$ 个 $0$。

所以算法可能会退化成 $O(n^2)$。

但考虑到这样做有点浪费，因为很多 $dp(i,l)$ 对后面的答案会造成影响。

又可以发现，在这些数放的时候，$l,r$ 的值是不变的。

又因为转移式子是 $dp_{i,l}=dp_{i-1,l}\times (r-l-i+2)$。

所以若当 $i$ 在区间 $[L,R]$ 内时 $a_i=0$。

则可以得到转移式子：

当 $l\mid a_i$ 时：

$$dp_{R+1,l}+=dp_{L-1,l}\times \prod_{k=r-l-R+2}^{r-l-L+2} k(r-l-R+2>0)$$

而 

$$\prod_{k=r-l-R+2}^{r-l-L+2} k=\frac{(r-l-L+2)!}{(r-l-R+1)!}$$

可以预处理阶乘的模数和逆元，故是 $O(1)$ 的。

所以时间复杂度为 $O(n\sqrt n)$ ,足以通过此题。

期望得分：$100$

###  $\texttt{Extra}$：

可以发现这样做常数有点大。

而经过一番思考，可以发现无用状态数太多了。

那怎样呢？从上一步转移过来！

这样可以省去很多常数。

经过一些计算，可以发现因为上一个状态数很难到 $\sqrt n$。

所以这样做的常数是很小的。跑的会更快一些。
 
### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline long long read()
{
	long long sum=0,nega=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')nega=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')sum=sum*10+ch-'0',ch=getchar();
	return sum*nega;
}
const long long N=5e5+9,mod=998244353;
long long n,ans,a[N],dp[2][N],fac[N],inv[N],sum=1,len,pos,cnt,use[2][N],tot[2],l,r,p,check[2][N],res;
inline long long Pow(long long x,long long y)
{
	long long res=1,base=x;
	while(y)
	{
		if(y&1)res=res*base%mod;
		base=base*base%mod;
		y>>=1;
	}
	return res;
}
inline long long Gcd(long long x,long long y)
{
	if(y==0)return x;
	return Gcd(y,x%y);
}
signed main()
{
	n=read();
	for(register int i=1;i<=n;i++)a[i]=read(),sum=sum+a[i];
	fac[0]=1;
	if(sum!=n*(n+1)/2)
	{
		puts("0");
		return 0;
	}
	for(register int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
	inv[n]=Pow(fac[n],mod-2);
	for(register int i=n-1;i>=1;i--)inv[i]=inv[i+1]*(i+1)%mod;
	inv[0]=1;
	sum-=a[1];
	cnt=1,pos=1;
	for(register int i=1;i<=n;i++)
		if(i*(i-1)/2+(n-i)*(n-i+1)/2==a[1])
		{
			dp[1][i]=1,tot[cnt]++,use[cnt][tot[cnt]]=i;
		}
	for(register int i=2;i<=n;i++)
	{
		if(a[i]!=0)
		{	
			cnt++;
			long long x=Gcd(a[i],sum);
			for(register int j=1;j<=tot[((cnt-1)&1)];j++)
			{
				l=use[((cnt-1)&1)][j];r=n+1-sum/l;
				if(x%(n+1-r)==0)
				{
					p=a[i]/(n+1-r);
					if(l-p>=1&&l<=r)
					{	
						dp[(cnt&1)][l-p]=(dp[(cnt&1)][l-p]+dp[((cnt-1)&1)][l]*fac[r-l-pos+1]%mod*inv[r-l-i+2]%mod)%mod;
						if(check[((cnt)&1)][l-p]==0)tot[(cnt&1)]++,use[(cnt&1)][tot[(cnt&1)]]=l-p,check[((cnt)&1)][l-p]=1;
					}
				}
				if(x%l==0)
				{
					p=a[i]/l;
					if(r+p<=n&&r>=l)
					{
						dp[(cnt&1)][l]=(dp[(cnt&1)][l]+dp[((cnt-1)&1)][l]*fac[r-l-pos+1]%mod*inv[r-l-i+2]%mod)%mod;
						if(check[((cnt)&1)][l]==0)tot[(cnt&1)]++,use[(cnt&1)][tot[(cnt&1)]]=l,check[((cnt)&1)][l]=1;
					}
				}
			}
			for(register int j=1;j<=tot[((cnt-1)&1)];j++)
				dp[((cnt-1)&1)][use[((cnt-1)&1)][j]]=0,check[((cnt-1)&1)][use[((cnt-1)&1)][j]]=0;
			res+=tot[(cnt-1)&1];
			tot[(cnt-1)&1]=0; 	
			pos=i;
		}
		sum-=a[i];
	}
	if(dp[(cnt&1)][1]==0)puts("0");
	else printf("%lld\n",dp[(cnt&1)][1]*fac[n-pos]%mod);
	return 0;
}
```


---

## 作者：pomelo_nene (赞：13)

实感 2D 严格小于 2C。可能风格不太合口味。

显然根据 $c_1$ 我们可以确定 $0$ 在整个序列的最多两个合法的位置。

直接算肯定是不太行的，考虑将数一个一个加进去。定义 $dp_{i,l,r}$ 表示，填了 $0 \sim i-1$，在排列里构成的极大区间为 $[l,r]$ 的合法排列个数。分类讨论。

假设 $c_i=0$，那么新加入的这个数一定存在于之前的区间 $[l,r]$。可以根据 $i$ 得到 $[l,r]$ 的空位剩下多少，随便加一个就行了。转移显然。

否则，新加入的数可能在 $[l,r]$ 左边或者右边。以左边为例。考虑 $c_i$ 的构成，假设我们插入的位置为 $L$，那么就会有 $(l-L+1) \times (n-r+1)$ 个 $\operatorname{mex}$ 等于 $i$ 的子数组。那么显然 $c_i | n-r+1$。这个时候判断随便算算扩大区间就行了。可以看 80pts 代码实现。

实际上到这里可以猜测因为限制十分紧可以猜测实际可以得到的状态很少所以用个啥 `map` 存一存转移就可以得到 80pts 了。这题这点不行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=998244353;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
void write(LL x)
{
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct State{
	LL i,l,r;
	State(){}
	State(LL I,LL L,LL R){i=I,l=L,r=R;}
	bool operator < (State ano) const
	{
		if(i!=ano.i)	return i<ano.i;
		if(l!=ano.l)	return l<ano.l;
		if(r!=ano.r)	return r<ano.r;
		return false;
	}
};
map<State,bool> al;
map<State,LL> dp;
queue<State> Q;
LL n,c[500005];
LL Calc(LL x){return x*(x+1)/2;}
int main(){
	n=read();
	for(LL i=1;i<=n;++i)	c[i]=read();
	for(LL i=1;i<=n;++i)
	{
		LL l=i-1,r=i+1;
		if(Calc(l)+Calc(n-r+1)==c[1])
		{
			State tmp=State(1,i,i);
			dp[tmp]=1;
			Q.push(tmp);
		}
	}
	while(!Q.empty())
	{
		State now=Q.front();
		Q.pop();
		if(al[now])	continue;
		al[now]=true;
		LL nxt=now.i+1,l=now.l,r=now.r;
		if(nxt>n)	continue;
		if(c[nxt]==0)
		{
			LL rest=(r-l+1)-now.i;
			if(rest>0)
			{
				State stt=State(nxt,l,r);
				(dp[stt]+=dp[now]*rest)%=MOD;
				Q.push(stt);
			}
		}
		else
		{
			LL L=0,R=0;
			LL lef=l,rig=n-r+1;
			if(c[nxt]%lef==0)
			{
				R=r+c[nxt]/lef;
				if(R<=n)
				{
					State stt=State(nxt,l,R);
					(dp[stt]+=dp[now])%=MOD;
					Q.push(stt);
				}
			}
			if(c[nxt]%rig==0)
			{
				L=l-c[nxt]/rig;
				if(L>=1)
				{
					State stt=State(nxt,L,r);
					(dp[stt]+=dp[now])%=MOD;
					Q.push(stt);
				}
			}
		}
	}
	State Ans=State(n,1,n);
	write(dp[Ans]);
	return 0;
}
```

将上面的代码写成数组 dp 的形式的空间为 $O(n^3)$。滚动数组可以优化一维。考虑到 $l,r$ 的消息不好消除，将 dp 内容输出可以发现 $dp_{i,l}$ 中最多有一个 $r$ 使得 $dp_{i,l,r} \neq 0$。

证明可以考虑转移的过程中的两种不同情况左端点一定不同。存下区间左端点也没官方题解说的那么麻烦，开个数组就行了。这样空间就被压到 $O(n)$ 了。

最后需要考虑的是证明状态数足够少。根据我们上面的发现显然状态数上界 $O(n^2)$。仔细考虑 $a_i$ 之后发现所有的状态数实际会和 $\sum \sqrt{a_i}$ 扯上关系。通过柯西不等式证明其小于等于 $n \sqrt n$，可以把时间复杂度看为 $O(n \sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define Sunset namespace
#define Toybox std
using Sunset Toybox;
typedef long long LL;
const LL MOD=998244353;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
void write(LL x)
{
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
LL Calc(LL x){return x*(x+1)/2;}
LL n,c[500005],dp[2][500005],st[2][500005];
bool vis[500005];
vector<LL> sp,pre,nxt;
int main(){
	n=read();
	for(LL i=0;i<n;++i)	c[i]=read();
	for(LL i=1;i<=n;++i)
	{
		LL l=i-1,r=i+1;
		if(Calc(l)+Calc(n-r+1)==c[0])	sp.push_back(i);
	}
	if(LL(sp.size())==0)	return puts("0")&0;
	dp[0][sp[0]]=1;
	st[0][sp[0]]=sp[0];
	pre.push_back(sp[0]);
	for(LL i=1;i<n-1;++i)
	{
		nxt.clear();
		LL lst=(i-1)&1;
		for(auto j:pre)
		{
			LL l=j,r=st[lst][l];//dp{i,l} -> r
			if(vis[l])	continue;
			vis[l]=true;
			if(!c[i])
			{
				if(r-l-i>=0)
				{
					(dp[i&1][l]+=dp[lst][l]*(r-l+1-i)%MOD)%=MOD;
					st[i&1][l]=r;
					nxt.push_back(l);
				}
			}
			else
			{
				LL lef=l,rig=n-r+1;
				if(c[i]%rig==0)
				{
					LL L=l-c[i]/rig;
					(dp[i&1][L]+=dp[lst][l])%=MOD;
					st[i&1][L]=r;
					nxt.push_back(L);
				}
				if(c[i]%lef==0)
				{
					LL R=r+c[i]/lef;
					(dp[i&1][l]+=dp[lst][l])%=MOD;
					st[i&1][l]=R;
					nxt.push_back(l);
				}
			}
		}
		for(auto j:pre)	vis[j]=false,dp[lst][j]=0;
		nxt.swap(pre);
	}
	LL ans=0;
	for(LL i=1;i<=n;++i)	(ans+=dp[(n-2)&1][i])%=MOD;
	write(ans*LL(sp.size())%MOD);
	return 0;
}
```

---


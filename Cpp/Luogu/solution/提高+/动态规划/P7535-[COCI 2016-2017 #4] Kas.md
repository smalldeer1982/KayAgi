# [COCI 2016/2017 #4] Kas

## 题目描述

Kile 和 Pogi 在路上捡到了 $N$ 张钞票。他们将分别取走若干张钞票，使得每人所得的总金额相同。同时要尽可能保证分得的总金额最大。

接着，他们会带着剩下的钞票前往赌场。由于他们的运气很好，因此他们将剩余金额作为赌注后，会得到双倍的金额。然后，他们会将得到的金额再次平分，并加入每个人的总金额中。

求每个人能够分得的总金额是多少。

## 说明/提示

**【样例 1 解释】**

Kile 可以选择取走面额分别为 $2,3,1$ 的钞票，而 Pogi 可以取走面额为 $6$ 的钞票。由于没有剩余钞票，因此每人所得总金额为 $6$。

**【样例 2 解释】**

Kile 可以选择取走面额分别为 $5,8$ 的钞票，而 Pogi 可以取走面额为 $13$ 的钞票。剩下的钞票面额分别为 $2,3$，因此在前往赌场之后，每人所得总金额为 $13+2+3=18$。

**【数据规模与约定】**

对于 $50\%$ 的数据，$N \le 13$。

对于 $70\%$ 的数据，$N \le 50$，$\sum c_i \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 500$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #4](https://hsin.hr/coci/archive/2016_2017/contest4_tasks.pdf) _T3 Kas_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
4
2
3
1
6```

### 输出

```
6```

## 样例 #2

### 输入

```
5
2
3
5
8
13```

### 输出

```
18```

# 题解

## 作者：liangbowen (赞：20)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P7535)

[更好的阅读体验？](https://www.luogu.com.cn/blog/liangbowen/solution-p7535)

比赛时考到了这一题，于是写一篇题解纪念一下。

## 思路

设 $dp_{i, j}$ 表示前 $i$ 张钞票分给两人，两人差尽可能接近 $j$ 的情况下，获得的总钱数。此时不考虑赌场操作。

显然可以分三种情况讨论：

+ 不用第 $i$ 张钞票：即 $dp_{i-1, j}$。
+ 把第 $i$ 张钞票给第一个人：显然为 $dp_{i-1, |j - a_i|} + a_i$
，其中 $|x|$ 表示 $x$ 的绝对值。
+ 把第 $i$ 张钞票给第二个人：同理，是 $dp_{i-1, j + a_i}$。

因此，状态转移方程为：

$$dp_{i, j} = \begin{cases}dp_{i-1, j}\\dp_{i-1, |j - a_i|} + a_i\\dp_{i-1, j + a_i}\end{cases}$$

重点代码如下。这里加了滚动数组的空间优化。

```cpp
int n, sum = 0;
scanf("%d", &n);
for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
for (int i = 1; i <= n; i++) sum += a[i];
//求最大值，就赋值无穷小。注意 dp[0] = 0。
for (int i = 1; i <= sum; i++) dp[i] = -2147483647; 
for (int i = 1; i <= n; i++) //dp[i] 是主动规数组，tdp[i] 是滚动数组。
{
	for (int j = 0; j <= sum; j++) tdp[j] = max(max(dp[abs(j - a[i])], dp[j + a[i]]) + a[i], dp[j]);	
	for (int j = 0; j <= sum; j++) dp[j] = tdp[j]; //复制进主数组里。
}
```

那么，两人平均分到 $\left\lfloor dp_{n, 0} \div 2\right\rfloor$ 的钱，剩下 $\Big(\small sum - \left\lfloor dp_{n, 0} \div 2\right\rfloor\Big)$ 的钱去赌场。返回双倍钱，则两人都分得 $\Big(\small sum - \left\lfloor dp_{n, 0} \div 2\right\rfloor\Big)$ 这些钱。

```cpp
printf("%d", sum - dp[0] / 2);
```

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
const int N = 505, M = 2e5 + 5;
int a[N], dp[M], tdp[M];
int main()
{
	int n, sum = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) sum += a[i];
	//求最大值，就赋值无穷小。注意 dp[0] = 0。
	for (int i = 1; i <= sum; i++) dp[i] = -2147483647; 
	for (int i = 1; i <= n; i++) //dp[i] 是主动规数组，tdp[i] 是滚动数组。
	{
		for (int j = 0; j <= sum; j++) tdp[j] = max(max(dp[abs(j - a[i])], dp[j + a[i]]) + a[i], dp[j]);	
		for (int j = 0; j <= sum; j++) dp[j] = tdp[j]; //复制进主数组里。
	}
	printf("%d", sum - dp[0] / 2);
	return 0;
}
```

希望能帮助到大家！

---

## 作者：V1mnkE (赞：16)

~~校内模拟赛的题~~

## 思路
看到这道题可以很快想出一个 $O(n (\sum c_i)^2)$ 的方法：用 $dp_{i,j,k}$ 表示表示第 $1 \sim i$ 张钞票里，能否使得 Kile 分到 $j$ 块钱，Pogi 分到 $k$ 块钱，可以得到状态转移方程：
$$ dp_{i,j,k}|= \begin{cases}
dp_{i-1,j,k}\\
dp_{i-1,j-c_i,k}\\
dp_{i-1,j,k-c_i}
\end{cases}$$

但是这样空间要开到 $500\times 500\times 10^5$ ，会爆空间。所以我们再观察一下，可以用一个显然的结论来优化空间：知道两个数的和、差就可以求出这两个数的值。我们重新定义一下 $dp$ 数组，令 $dp_{i,j}$ 表示**第 $1 \sim i$ 张钞票里， Kile 和 Pogi 分到钱的差值为 $j$ 时，两人钱数之和的最大值，** 可以得到柿子：
$$ dp_{i,j}= \max\begin{cases}
dp_{i-1,|j-c_i|}+c_i\\
dp_{i-1,j}\\
dp_{i-1,j+c_i}+c_i
\end{cases}$$

注意到每次转移第一维只从 $i-1$ 转移过来，可以用滚动数组优化，不过不加也可以过。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[600],dp[505][100005],tot,now;
int main(){
	memset(dp,-0x7f,sizeof(dp));
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		tot+=a[i];
	}
	dp[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=tot;j++){
			dp[i][j]=max(dp[i-1][j],max(dp[i-1][j+a[i]]+a[i],dp[i-1][abs(j-a[i])]+a[i]));
		}
	}	
	cout<<tot-dp[n][0]/2;
	return 0;
}
```

---

## 作者：MurataHimeko (赞：8)

（~~看见同机房大佬爆切这道题，本蒟蒻也来凑个热闹）~~

## P7535


------------



### 50分思路

我们先把这 $n$ 张钞票分给两个人。然后定义 **$dp[i][j][0/1]$ 表示在第 $1/2$ 个人手里，第 $1 \sim i$ 张钞票中，能否凑出 $j$ 块钱。** DP 即可。

转移柿子如下：
$$ dp[i][j][0/1] \mid \ = dp[i-1][j-c[i]][0/1] $$


然后我们倒序枚举 $j$，这样就可以压掉第一维了。

初始化 $dp[0][0] = dp[0][1] = 1$。   
最后答案就是  $\sum_{i=1}^{n} c[i] \ - \ \max \limits_{dp[j][1] = dp[j][0] = 1} {j}$。

现在的问题就是，如何将 $n$ 张钞票分给两个人呢？这里我们考虑状压 DP 的思想，因为一共有 $2^n$ 种分钞票的方案， 所以枚举 $0 \sim 2^n$ ，若当前枚举到数字 $u$ 的二进制上第 $i$ 位为 0， 则第 $i$ 张钞票分给 Kile；否则分给 Pogi。

总时间复杂度为 $O(2^n * \sum_{i = 1}^{n} c[i])$。


------------

### 50分代码
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
#define max_(a, b) a > b ? a : b
#define min_(a, b) a < b ? a : b
#define INF 0x3f3f3f3f
#define rep(i, f, t) for(register int i(f); i <= t; ++i)
#define per(i, t, f) for(register int i(t); i >= f; --i)
 
 
/***************??***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}

#ifndef ONLINE_JUDGE
#endif

template<class I>
inline void read(I &x) {
    x = 0; I f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc(); }
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = gc(); }
    x *= f;
}

template<class I>
inline void write(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define in(x) read(x)
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')

} using namespace IO;

/***************??***************/


int n;
int val[14];
int dp[1002][2];
int a[14], b[14];
int la, lb;
int ans = INF, tmp, cnt, sum, now;

int main () {
    read(n);
    if(n > 13) return 0;
    rep(i, 0, n-1) read(val[i]), sum += val[i];
    rep(i, 1, ((1<<n)-1)) {
        la = lb = 0;
        tmp = cnt = 0;
        memset(dp, 0, sizeof(dp));
        rep(j, 0, n-1) {
            if((1<<j) & i) a[++la] = j, tmp += val[j];
            else b[++lb] = j, cnt += val[j];
        }
        dp[0][0] = dp[0][1] = 1;
        rep(j, 1, la) {
            per(k, tmp, 0) {
                if(k >= val[a[j]]) {
                    dp[k][0] |= dp[k-val[a[j]]][0];
                }
            }
        }
        rep(j, 1, lb) {
            per(k, cnt, 0) {
                if(k >= val[b[j]]) {
                    dp[k][1] |= dp[k-val[b[j]]][1];
                }
            }
        }
        now = min_(cnt, tmp);
        per(j, now, 0) {
            if(dp[j][0] && dp[j][1]) {
                ans = min_(ans, sum - j);
                break;
            }
        }   
    }
    out(ans);
}
```


------------

### 70分思路

在 50 分思路里，最大的问题就是 $dp$ 数组的定义。 50 分代码的 $dp$ 数组实质上只有第一维有用，第二维开两个数组就可以代替。因为只有一维，所以 $dp$ 数组只能存储一个人的信息，从而要花费 $O(2^n)$ 的时间去把钞票分成两部分，太过浪费。我们重新定义 **$dp[i][j][k]$ 表示第 $1 \sim i$ 张钞票里，能否使得 Kile 分到 $j$ 块钱，Pogi 分到 $k$ 块钱。** 这样 $dp$ 数组就能存储两个人的信息，就不需要再花费 $O(2^n)$ 的时间把钞票分成两部分了。

转移柿子如下：

$$ dp[i][j][k] \mid \ = \left\{
\begin{array}{rcl}

dp[i-1][j][k] \\
dp[i-1][j-c[i]][k]\\
dp[i-1][j][k-c[i]]

\end{array}\right.

$$

倒序枚举 $j$ 和 $k$ 即可压掉第一维。

最后答案就是  $\sum_{i=1}^{n} c[i] \ - \max \limits_{dp[j][j] = 1} {j}$。

时间复杂度为 $O(n* (\sum_{i=1}^{n}c[i])^2)$。

### 70分代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
#define max_(a, b) a > b ? a : b
#define min_(a, b) a < b ? a : b
#define INF 0x3f3f3f3f
#define rep(i, f, t) for(register int i(f); i <= t; ++i)
#define per(i, t, f) for(register int i(t); i >= f; --i)
 
 
/***************??***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}

#ifndef ONLINE_JUDGE
#endif

template<class I>
inline void read(I &x) {
    x = 0; I f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc(); }
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = gc(); }
    x *= f;
}

template<class I>
inline void write(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define in(x) read(x)
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')

} using namespace IO;

/***************??***************/

int n;
int val[55];
int sum, now, ans = INF;
int dp[5003][5003];

int main () {
    read(n);
    rep(i, 1, n) read(val[i]), sum += val[i];
    dp[0][0] = 1;
    rep(i, 1, n) {
        per(j, sum, 0) {
            per(k, sum, 0) {
                if(k >= val[i]) dp[j][k] |= dp[j][k-val[i]];
                if(j >= val[i]) dp[j][k] |= dp[j-val[i]][k];
            }
        }
    }
    per(i, sum, 0) {
        if(dp[i][i]) {
            ans = i;
            break;
        }
    }
    ans = sum - ans;
    out(ans);
}
```


------------


### 100分思路

（~~码字累死了终于要结束了~~）

在 70 分思路里，我们为了存储两个人的信息，花费了 $O(\sum_{i=1}^{n}c[i])^2)$ 的时间复杂度，无法通过 100 分的数据。那么有同样能存储两个人的信息，且时间复杂度更低的方法吗？答案是有的。

（~~bdfs后~~)

我们重新定义 **$dp[i][j]$ 表示第 $1 \sim i$ 张钞票里， Kile 和 Pogi 分到钱的差值为 $j$ 时，两人钱数之和的最大值**。这样 $dp$ 数组就能存储两个人的信息，且比 70 分代码的 $dp$ 数组少了一维。

转移柿子如下：

$$ dp[i][j] = \max \left\{
\begin{array}{rcl}
	
dp[i-1][j] \\
dp[i-1][j+c[i]] \ + \ c[i]\\ 
dp[i-1][abs(j-c[i])] \ + \ c[i]

\end{array}\right.
	
$$

不过要注意一点，就是可能 $dp[i-1][j]$ 这个状态是不合法的，也就是第 $1 \sim i$ 张钞票里， Kile 和 Pogi 分到钱的差值为 $j$ 这种情况不存在，此时就不能转移。

发现每次只会从 $i-1$ 转移来，可以通过滚动数组压掉第一维。

最后答案就是  $\sum_{i=1}^{n} c[i] \ - $ dp[n&1][0] / 2。

时间复杂度为 $O(n*\sum_{i=1}^{n}c[i])$，可以通过此题。


------------


### 100分代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
#define max_(a, b) a > b ? a : b
#define rep(i, f, t) for(register int i(f); i <= t; ++i)
typedef long long ll;
 
/***************??***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}

#ifndef ONLINE_JUDGE
#endif

template<class I>
inline void read(I &x) {
    x = 0; I f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc(); }
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = gc(); }
    x *= f;
}

template<class I>
inline void write(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define in(x) read(x)
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')

} using namespace IO;

/***************??***************/

int n;
int val[550];
int sum, now, ans;
int dp[3][100093];

int main () {
    read(n);
    rep(i, 1, n) read(val[i]), sum += val[i];
    memset(dp, -0x3f, sizeof(dp));
    dp[0][0] = 0;
    rep(i, 1, n) {
        rep(j, 0, sum) {
            dp[i&1][j] = dp[i&1^1][j];
            dp[i&1][j] = max_(dp[i&1^1][abs(j-val[i])] + val[i], dp[i&1][j]);
            dp[i&1][j] = max_(dp[i&1^1][j+val[i]] + val[i], dp[i&1][j]);
        }
    }
    out(sum - dp[n&1][0]/2);
}
```


------------

感谢您能阅读本篇博客~ 最后，欢迎您常来本蒟蒻博客玩啊（

---

## 作者：JWRuixi (赞：7)

这道题简单来说就是求两人得到的钱等有多接近，看一下数据范围，不难发现，爆搜是肯定过不了的。

- ### 题目分析：
对于这类求最好情况的题， 估计这就是贪心或 dp，再简单造几组数据发现贪心他死了，所以确定这道题肯定是 dp。

- ### 思路：
来研究一下状态转移方程一张钞票要么谁都不给，要么给其中一个。
所以，可以考虑用 $dp[i][j]$ 表示选钱 $i$ 张钞票，差距为 $j$ 
的时候单人分到的最大钱数（不算不选的）。

则可以得到状态转移方程：
```cpp
dp[i][j] = max(dp[i - 1][j], max(dp[i - 1][j + a[i]] + a[i], dp[i - 1][abs(j - a[i])] + a[i]));
```
好心的朋友们测一下，不难发现这样搞会空间起飞。
幸好，我们只用到 $i - 1$ 和 $i$。所以可以直接压成两个一维数组，这样就好了。

- ### 于是有code如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
//这里的变量非常的常规就不说了。
int n, a[505], dp[2][100005], sum;
int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf ("%d", &a[i]);
		sum += a[i];//计算和
	}
	memset(dp, -0x3f, sizeof dp);//初始状态赋值极小
	dp[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= sum; j++) {
			dp[i & 1][j] = max(dp[i & 1 ^ 1][j], max(dp[i & 1 ^ 1][j + a[i]] + a[i], dp[i & 1 ^ 1][abs(j - a[i])] + a[i]));//美丽的状态转移方程
		}
	}
	printf ("%d", sum - dp[n & 1][0] / 2);//答案
}
```
**如有错误请大佬指出！**

---

## 作者：Jairon314 (赞：3)

$ \text{首先，我们考虑dfs处理出所有可能的情况} $

那么，我们的这个``dfs``怎么写呢？

1. 先考虑搜索顺序，从 $1$ 搜到 $n$

2. 再考虑上传的参数以及状态的转移， $dfs(now)$ 代表搜到第 $now$ 张钞票，然后 $dfs$ 三次，分别是该钞票给第一个人、给第二个人和谁也不给

然后看代码 :

> ~~快读有点长，希望不要介意~~

```cpp
// #include <map>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;

#define int long long

#define maxn 10000010
#define rep(i,f,t) for(int i(f);i<=(t);++i)
#define pre(i,t,f) for(int i(t);i>=(f);--i)

inline void FILE_();

/***************快读***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {
  return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
}

#ifndef ONLINE_JUDGE
#endif

#define gc getchar

struct Reader {
    template<class T>Reader&operator()(T&x){x=0;T f=1;char ch=gc();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=gc();x*=f;return*this;}
    int operator()(){int x;operator()(x);return x;}
    Reader&operator()(char*x){scanf("%s",x);return*this;}
    template<class T>Reader&operator()(T*x,int n,int st=1){rep(i,st,n){operator()(x[i]);}return*this;}
}read;

template<class I>
inline void out(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define outn(x) out(x), putchar('\n')
#define out_(x) out(x), putchar(' ')

template<class I,I *v>
inline void readline(register int limit){
    rep(i,1,limit){read(v[i]);}
}

template<class I,I *v>
inline void outline(register int limit){
    rep(i,1,limit){out_(v[i]);}
}

template<class I,I *v,I weight>
inline void assign(register int limit){
    rep(i,1,limit){v[i]=weight;}
}

template<class I>
inline int Max(I a,I b){
    return a<b?b:a;
}

template<class I>
inline int Min(I a,I b){
    return a>b?b:a;
}

template<class I>
inline int Abs(I a){
    return a<0?(-a):a;
}

} using namespace IO;

/***************快读***************/

int n,m,k,t,p;
int Array[maxn];
int assign[maxn];
int ans=0;
int res1,res2;

// res1 -> 第一个人的总钱数
// res2 -> 第二个人的总钱数

int dfs(int now){
    if(now==n){
        int res=0;
        res1+=Array[now];
        if(res1==res2){res=std::max(res,res1);}
        res1-=Array[now];
        res2+=Array[now];
        if(res1==res2){res=std::max(res,res2);}
        res2-=Array[now];
        if(res1==res2){res=std::max(res,res1);}
        return res;
    }
    int res=0;
    // 给第一个人
    res1+=Array[now];
    res=std::max(res,dfs(now+1));
    res1-=Array[now];
    // 给第二个人
    res2+=Array[now];
    res=std::max(res,dfs(now+1));
    res2-=Array[now];
    // 谁也不给
    res=std::max(res,dfs(now+1));
    return res;
}

/*****************************************/

/*int*/ signed main(){
    // FILE_();
    read(n);
    int sum=0;
    for(int i=1;i<=n;i++){read(Array[i]);sum+=Array[i];}
    int ans=dfs(1);
    outn(ans+sum-(ans<<1));
    return 0;
}

/*****************************************/

inline void FILE_(){
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
}

/*
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA
*/
```

$ 不用说，该代码复杂度爆炸，只能拿一半的分数 $

那我们怎么优化呢？可以考虑 $dp$ ,因为我们能够比较轻松的推出状态转移方程。但是我使用了记忆化搜索，跟 $dp$ 差不多，然后就可以愉快的 $AC$ 啦！

代码如下 :

```cpp
// #include <map>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;

// #define int long long

#define maxn 1000010
#define rep(i,f,t) for(int i(f);i<=(t);++i)
#define pre(i,t,f) for(int i(t);i>=(f);--i)

inline void FILE_();

/***************快读***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {
  return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;
}

#ifndef ONLINE_JUDGE
#endif

#define gc getchar

struct Reader {
    template<class T>Reader&operator()(T&x){x=0;T f=1;char ch=gc();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=gc();x*=f;return*this;}
    int operator()(){int x;operator()(x);return x;}
    Reader&operator()(char*x){scanf("%s",x);return*this;}
    template<class T>Reader&operator()(T*x,int n,int st=1){rep(i,st,n){operator()(x[i]);}return*this;}
}read;

template<class I>
inline void out(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define outn(x) out(x), putchar('\n')
#define out_(x) out(x), putchar(' ')

template<class I,I *v>
inline void readline(register int limit){
    rep(i,1,limit){read(v[i]);}
}

template<class I,I *v>
inline void outline(register int limit){
    rep(i,1,limit){out_(v[i]);}
}

template<class I,I *v,I weight>
inline void assign(register int limit){
    rep(i,1,limit){v[i]=weight;}
}

template<class I>
inline int Max(I a,I b){
    return a<b?b:a;
}

template<class I>
inline int Min(I a,I b){
    return a>b?b:a;
}

template<class I>
inline int Abs(I a){
    return a<0?(-a):a;
}

} using namespace IO;

/***************快读***************/

int n,m,k,t,p;
int Array[maxn];
int memory[1007][100007];
int ans,sum;

int dfs(int now,int corn){
    // 剪枝
    if(corn>sum/2){return -0x3f3f3f3f;}
    if(memory[now][corn]!=-1){return memory[now][corn];}
    if(now==n){
        if(corn!=0){return memory[now][corn]=-0x3f3f3f3f;}
        return memory[now][corn]=0;
    }
    memory[now][corn]=std::max(dfs(now+1,corn),Array[now]+dfs(now+1,corn+Array[now]));
    memory[now][corn]=std::max(memory[now][corn],dfs(now+1,corn));
    memory[now][corn]=std::max(memory[now][corn],Array[now]+dfs(now+1,corn+Array[now]));
    memory[now][corn]=std::max(memory[now][corn],dfs(now+1,IO::Abs(Array[now]-corn))+std::max(0,Array[now]-corn));
    return memory[now][corn];
}

/*****************************************/

int /*signed*/ main(){
    // FILE_();
    memset(memory,-1,sizeof memory);
    // 初始化 memory 均为 -1
    read(n);
    // int sum=0;
    for(int i=1;i<=n;i++){read(Array[i-1]);sum+=Array[i-1];}
    int ans=dfs(0,0);
    outn(ans+sum-(ans<<1));
    return 0;
}

/*****************************************/

inline void FILE_(){
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
}

/**/
```



---

## 作者：Foreverxxx (赞：1)

广告：[蒟蒻的博客](https://www.luogu.com.cn/blog/Foreverxxx/)

建议将难度设置为绿题。

## 50分思路

考虑到数据范围直接开始爆搜。

分别用三个变量记录剩下的钱的数目以及两个人拥有的钱的数目，对于每一张钞票分别搜索三种情况，分别是给第一个人，给第二个人和两人都不拿，枚举完所有钞票时更新答案即可。

时间复杂度 $O(3^n)$。

## 100分思路

分析一下 50 分的算法，我们分别记录了第一个人，第二个人和剩下的钱的数目，以及钞票的数量，非常明显这样是很难优化的。

我们可以发现，我们需要记录的应该是两个人拥有的钱的数量差，而不是他们拥有的钱的数量，可以事先统计出所有的钞票的价值，计算出答案后相减就可以了。

此时一个动态规划的思路以及比较明显地浮现在脑海中。

可以用函数 ``calc(num,cha)`` 计算出当已经分配了 num 张钞票，其中两个人拥有的钱的差为 cha 时的最优解，我们便可以推出以下柿子：

$
clac(num,cha)=\begin{cases}
clac (num+1,cha)\\
\max (clac(num+1,cha+a[num]))+a[num]\\
clac(num+1,abs(cha-a[num]))+\max (0,a[num]-cha)))
\end{cases}
$

其中，为了记录信息，我们可以选择利用一个 dp 数组记录信息，其中 $dp_{i,j}$ 表示分配到第 i 张钞票时，两个人的差为 j 时的最优情况。

不过这样一直调用也只有 50 分，接下来我们考虑剪枝。

剪枝 1

既然我们能够记录两人拥有的钱的差值，在差值大于总数目的一半时就可以返回无法实现，因为就算剩下的所有钱都给钱少的那个人，最后他们的钱也不可能相等。

剪枝 2

可以用 dp 数组排除冗杂的搜索，当搜索到 ``calc(num,cha)`` 时，如果 $dp_{num,cha}$ 已经被赋值，则可以直接返回它的值，避免二次计算。

（可能还有其它剪枝，不过蒟蒻暂时没有想出来）

通过以上剪枝，我们已经排除了大量的冗杂情况，成功 AC。

AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int sss=0,www=1;
    char chh=getchar();
    while(chh<'0'||chh>'9'){
		if(chh=='-')www=-1;
		chh=getchar();
	}
    while(chh>='0'&&chh<='9') sss=sss*10+chh-'0',chh=getchar();
    return sss*www;
}
void write(int x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,sum=0;
//sum表示所有的钱 
int money[505];
int dp[505][50005];
int calc(int give_num,int cha_num) {
	//give_num表示分配的钞票数
	//cha_num表示两个人的钱的数量差值 
    if(cha_num>sum/2) 
		return -1e9;//差值已经大于所有钱的一半，怎么分也不可能实现 
    int& tmp=dp[give_num][cha_num];//int& 表示两个东西的值一起改变(tmp 和 dp[give_num][cha_num]的值同时被改变) 
    if(tmp!=-1)
    	return tmp;//已经算出来了 
    if(give_num==n)
    	return tmp=(cha_num!=0)*(-1e9);
    return tmp=max(calc(give_num+1,cha_num),//两人都不拿
                    max(calc(give_num+1,cha_num+money[give_num])/*钱给更多的那个人*/+money[give_num],
                    calc(give_num+1,abs(cha_num-money[give_num]))/*钱给更少的那个人*/+max(0,money[give_num]-cha_num)));
}

int main(){
  	n=read();
  	for(register int i=0;i<n;i++) {
    	money[i]=read();
    	sum+=money[i];
    }
    memset(dp,-1,sizeof dp);//初始化dp数组 
    write(sum-calc(0,0));
	return 0;
}
```
欢迎来我的博客玩！[一名Blink的博客](https://www.luogu.com.cn/blog/Foreverxxx/)

---

## 作者：f_x_f (赞：1)

[题目](https://www.luogu.com.cn/problem/P7535)(被校内的~~大佬爆切~~)
## 分析
首先 由于题目所说“同时要尽可能保证分得的总金额最大。”所以可以想到是贪心或者是 dp 转移。但是不难发现贪心一定是 WA 的。所以我们就应当考虑 dp 转移。

我们设 $dp_{i,j}$ 表示在 $1-i$ 个钞票之中使得两人钱数之差为 $j$ 的情况时两人中选到最多的钱数是多少。

## dp转移方程
$dp_{i,j} = max \begin{cases}
   dp_{i-1,j}  \\
   dp_{i-1,j+c_i}+dp_{i+c_i}+c_i  \\
   dp_{i-1,abs(j-c_i)}+c_i
\end{cases}$

$ dp_{i-1,j}$ 表示如果第 $i$ 个钞票不选的情况。

$ dp_{i-1,j+c_i}+c_i$ 表示第 $i$ 个钞票给目前钱数多的那个人。

$  dp_{i-1,abs(j-c_i)}+c_i$ 表示第 $i$ 个钞票给目前钱数少的那个人。

于是就可以写出代码了， ~~本蒟蒻~~ 在此就不奉上代码了。

---


# [COCI 2012/2013 #1] MARS

## 题目描述

科学家在火星上发现了一些奇怪的细菌，正在研究它们。他们注意到细菌的数量是 $2$ 的次方，因为每一种细菌都会分裂成两种新的细菌，而初始有一种细菌。因此，在第一代中只有一种细菌，第二代中有两种细菌，第三代中有四种细菌，以此类推，直到第 $K + 1$ 代中有 $2^K$ 种细菌。

科学家们用 $1$ 至 $2^K$ 之间的整数给细菌进行了编号，方法如下：

- 第 $K$ 代细菌的后代按顺序分别为：$\{1,2\},\{3,4\},\{5,6\},\cdots,\{2^K-1,2^K\}$
- 第 $K - 1$ 代细菌的后代按顺序分别为：$\{1,2,3,4\},\{5,6,7,8\},\cdots,\{2^K-3,2^K-2,2^K-1,2^K\}$
- 第 $K - 2$ 代细菌的后代按顺序分别为：$\{1,2,3,4,5,6,7,8\},\cdots,\{2^K-7,2^K-6,2^K-5,2^K-4,2^K-3,2^K-2,2^K-1,2^K\}$
- $\cdots$
- 第 $1$ 代细菌的后代按顺序分别为：$\{1,2,\cdots,2^{K-1}\},\{2^{K-1}+1,2^{K-1}+2,\cdots,2^K\}$

其中花括号表示一个细菌的一组后代。

也就是说，对当前这一代的 $2^K$ 个细菌进行编号，使得任何较老细菌的后代都有连续的编号。**注意这些细菌存在许多种不同的 仍然满足任何较老细菌的后代都有连续编号的条件 的排列。**

科学家想把细菌排列成一个**长度尽可能短**的序列。细菌序列的长度是**所有相邻的细菌对之间的距离的总和**。

确切地说，每两个细菌之间都有一定的**排斥值**。如果它们在序列中相邻，这个排斥值就是它们之间的最小距离（序列中不相邻的细菌之间的排斥值不起作用）。给定所有细菌对的排斥值，找出满足上述后代规则的细菌序列（排列）的最小长度。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，保证 $1 \le K \le 9$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $160$。

题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T6 MARS___。

## 样例 #1

### 输入

```
2
0 7 2 1
7 0 4 3
2 4 0 5
1 3 5 0```

### 输出

```
13```

## 样例 #2

### 输入

```
3
0 2 6 3 4 7 1 3
2 0 7 10 9 1 3 6
6 7 0 3 5 6 5 5
3 10 3 0 9 8 9 7
4 9 5 9 0 9 8 4
7 1 6 8 9 0 8 7
1 3 5 9 8 8 0 10
3 6 5 7 4 7 10 0```

### 输出

```
32```

# 题解

## 作者：Tuibro (赞：3)

## 前言

苯题在%拟赛时，~~压根没想到可以用 dp~~，见识短浅。赛后发现是一道 dp 优化的好题，里面优化的思路可以借鉴。

## 思路

首先观察到题目的区间类型是“完全二叉树”类型区间，且 $t$ 较小。容易发现，对于属于不同子树的区间是独立的，且所求的最小长度恰是以上述区间为下标的相邻元素之和。

故原问题可以转化为：**调整顺序，依次去合并上述区间，最后花费的最小值**。设第一个区间的右端点为 $i$，第二个区间的左端点为 $j$，其中的花费即为 $val_{i,j}$。

考虑 dp。

## 做法

而我们是从小区间逐渐向上合并，且是“完全二叉树”类型区间，故可以考虑用分治协助实现 。

* 设计状态：$dp_{dep,i,j}$，表示为分治到第 $dep$ 层的区间，左端点编号为 $i$，右端点编号为 $j$。

状态设计好了，转移方程也易想到一种 $O(n^4)$ 的方式，即枚举两个区间的左右端点，下面给出代码。

```cpp
void solve(int dep,int l,int r)
{
	if(l==r)
	{
		dp[dep][l][r]=0;
		return ;
	}
	int mid=l+r>>1;
	solve(dep+1,l,mid),solve(dep+1,mid+1,r);//分治 
	
	for(R int i=l;i<=mid;i++)
		for(R int j=mid+1;j<=r;j++)	
		{
			for(R int x=l;x<=mid;x++)
				for(R int y=mid+1;y<=r;y++)
					dp[dep][i][j]=min(dp[dep][i][j],dp[dep+1][i][x]+dp[dep+1][y][j]+val[x][y]);
			/*
			第一个区间 为 i ~ x
			第二个区间 为 y ~ j
			*/
			dp[dep][j][i]=dp[dep][i][j];
		}
			
	return ;
}
```

但是此复杂度不足以通过此题，那么我们考虑在以上方程与转移上进行优化。

观察方程：
$$
dp_{dep,i,j}=\min(dp_{dep+1,i,j}+dp_{dep+1,y,j}+val_{x,y})
$$

我们发现，可以先开一个辅助数组 $f_{i,j}$ 记录 $dp_{dep+1,i,x}+val_{x,y}$ 的最小值，即先将区间拆为 $[i,x]$ 与 $[x,y]$，进行合并。$f_{i,j}$ 即表示为在当前区间下的最小值。

再将区间 $[i,y]$ 与 $[y,j]$ 合并，即用先前的 $f_{i,j}$ 进行合并与更新。

这样我们两次转移的复杂度都为 $O(n^3)$，总时间复杂度为 $O(n^3\times \log(n))$，足以通过此题。

上全部 code：

```cpp
#include<bitsdc++.h>
using namespace std;
#define R register
const int M=513;
bool f1;

char IO;
int read()
{
    int num=0;bool f=0;
    while(IO=getchar(),IO<48||IO>57)if(IO=='-')f=1;
    do num=(num<<1)+(num<<3)+(IO^48);
    while(IO=getchar(),IO>=48&&IO<=57);
    return f?-num:num;
}

int t,ans=1e9;
int b[M][M];
int dp[11][M][M],f[M][M];

void solve(int dep,int l,int r)
{
	if(l==r)
	{
		dp[dep][l][r]=0;
		return ;
	}
	int mid=l+r>>1;
	solve(dep+1,l,mid),solve(dep+1,mid+1,r);
	
	for(R int i=l;i<=mid;i++)
		for(R int j=mid+1;j<=r;j++)	
		{
			f[i][j]=1e9;
			for(R int x=l;x<=mid;x++)
				f[i][j]=min(f[i][j],dp[dep+1][i][x]+b[x][j]);
		}
	for(R int i=l;i<=mid;i++)
		for(R int j=mid+1;j<=r;j++)
		{
			for(R int x=mid+1;x<=r;x++)
				dp[dep][i][j]=min(dp[dep][i][j],f[i][x]+dp[dep+1][x][j]);
			dp[dep][j][i]=dp[dep][i][j];
		}
			
	return ;		
}

bool f2;
int main()
{
//  cout<<1.0*(&f2-&f1)/1024.0/1024.0<<endl;
	memset(dp,0x3f,sizeof(dp));
	t=read();
	int n=(1<<t);
	for(R int i=1;i<=n;i++)
		for(R int j=1;j<=n;j++)
			b[i][j]=read();

	solve(0,1,n);
	
	for(R int i=1;i<=n;i++)
		for(R int j=1;j<=n;j++)
			ans=min(ans,dp[0][i][j]);
	
	printf("%d",ans);
}

```

## 总结

对于这种类型的 dp 优化方式还是非常好的，值得学习！


---

## 作者：天南地北 (赞：3)

本题第一篇题解。

【本题大意】
	
给一堆细菌，细菌与细菌之间有排斥值，我们需要满足排列一个序列，使得这个几个细菌组合成的序列长度最小。细菌本身不算一个长度，也就是说，他们序列长度等于相邻之间细菌的排斥值之和，即为它们的序列长度。

【大体思路】

本题核心：分治+$DP$

本题主要是将一堆细菌，通过分治思想将其分成多个小问题，并且利用$DP$传递，计算出第$1$个到第$2^k$个的答案。

通过分治的方法，我们可以将其分为两堆（本来也就$2^k$个），然后进行组合，由于影响其序列长度的，只有这两堆相邻的两个细菌，所以我们可以通过从两堆细菌中枚举相邻的两个细菌组合，并用细菌之间的排斥值，计算答案。

【具体实现】

设$dp[depth][i][j]$指为当前分治到第$depth$层，从第$i$个到第$j$个组成最小序列的答案。$tmp[i][j]$为指为当前分治到第$depth$层，从第$i$个到第$j$个组成最小序列没有右半部分的答案（比较难解释，可以看下面程序）

部分程序：

```cpp
void solve(int depth, int l, int r)//深度为depth,区间为[l,r)状态
{
   if(l+1==r) //当只有一个数
   {
      dp[depth][l][l]=0;//序列长度为0
      return;
   }
   int m=l+r>>1;
   solve(depth+1,l,m);
   solve(depth+1,m,r);//分治
   int sz=(r-l)>>1;//计算这个区间的一半长度
   for(int i=l;i<m;i++) 
     for(int j=m;j<r;j++) 
     {
       tmp[i][j]=0x7fffffff;
       for(int k=0;k<sz;k++) 
          tmp[i][j]=min(tmp[i][j],dp[depth+1][i][l+k]+num[l+k][j]);
     }
  for(int i=l;i<m;i++) 
     for(int j=m;j<r;j++) 
     {
       for(int k=0;k<sz;k++) 
          dp[depth][i][j]=min(dp[depth][i][j],tmp[i][m+k]+dp[depth+1][m+k][j]);
       dp[depth][j][i]=dp[depth][i][j];//方便l+k>j,i>l+k等多种需要特判分写状态转移方程的一种方法，不影响最终答案
     }
}
```
后面这部分的大体意思是为了计算出$dp[depth][i][j]$的答案。这里分了两个部分来写。

$tmp[i][j]=min(tmp[i][j],dp[depth+1][i][l+k]+num[l+k][j]);$指没有右半部分$dp[depth+1][l+k][j]$的答案，当前$tmp[i][j]$的答案，通过下一层第$i$个到第$l+k$的答案以及$l+k$与$j$排列在一起的排斥值

$dp[depth][i][j]=min(dp[depth][i][j],tmp[i][m+k]+dp[depth+1][m+k][j]);$这里是用已知左部分答案，然后结合右边部分的答案求当前状态答案，$tmp[i][m+k]$就是左边部分，并且包括两部分排斥值的答案，$dp[depth+1][m+k][j]$指下一层$m+k$个到第$j$的答案

答案的取值都是通过下一层的答案来推出当前这一层的答案。

【参考程序】
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#define rep(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
const int maxn=(1<<9)+10;
int n;
int num[maxn][maxn];
int dp[11][maxn][maxn],tmp[maxn][maxn];
void solve(int depth, int l, int r)
{
    if (l+1==r) 
	{
        dp[depth][l][l]=0;
        return;
    }
    int m=l+r>>1;
    solve(depth+1,l,m);
    solve(depth+1,m,r);
    int sz=(r-l)>>1;
    for(int i=l;i<m;i++) 
        for (int j=m;j<r;j++) 
        {
        	tmp[i][j]=0x7fffffff;
            for (int k=0;k<sz;k++) 
                tmp[i][j]=min(tmp[i][j],dp[depth+1][i][l+k]+num[l+k][j]);
   		}
    for(int i=l;i<m;i++) 
        for(int j=m;j<r;j++) 
		{
            for(int k=0;k<sz;k++) 
                dp[depth][i][j]=min(dp[depth][i][j],tmp[i][m+k]+dp[depth+1][m+k][j]);
            dp[depth][j][i]=dp[depth][i][j];
    	}
}
int main()
{
    scanf("%d",&n);
    for (int i=0;i<(1<<n);i++) 
        for (int j=0;j<(1<<n);j++) 
            scanf("%d",&num[i][j]);
    memset(dp,0x3f,sizeof(dp));
    solve(0,0,1<<n);
    int ans=1<<30;
    for(int i=0;i<(1<<n);i++) 
        for(int j=0;j<(1<<n);j++)
            ans=min(ans,dp[0][i][j]);
    printf("%d\n",ans);
}
```


---

## 作者：ZnPdCo (赞：2)

首先考虑朴素的 dp，设 $f_{p,i,j}$ 为长度为 $2^{p}$，最左边子孙为 $i$，最右边子孙为 $j$ 的最小权值。

那么有朴素的转移方程：

$$
f_{p,i,j}\gets f_{p-1,i,x}+w_{x,y}+f_{p-1,y,j}
$$

其实这是可以优化的，发现 $f_{p-1,i,x}+w_{x,y}$ 与 $f_{p-1,y,j}$ 是两个独立的部分，可以设 $d_{i,y}$ 表示 $f_{p-1,i,x}+w_{x,y}$，然后原方程可以转换为：

$$
f_{p,i,j}\gets d_{i,y}+f_{p-1,y,j}
$$

时间复杂度是 $O(n^3)$ 的，但是因为不会跑满，就可以过。

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 600
#define K 11
int k, n, f[K][N][N];
int w[N][N];
int d[N][N];
int ans = 1e9;
void dfs(int p, int l, int r) {
	if(l == r) {
		return;
	}
	int mid = (l + r) >> 1;
	dfs(p-1, l, mid);
	dfs(p-1, mid+1, r);
	
	
	for(int i = l; i <= r; i++) {
		for(int j = 1; j <= r; j++) {
			f[p][i][j] = 1e9;
			d[i][j] = 1e9;
		}
	}
	for(int i = l; i <= mid; i++) {
		for(int x = l; x <= mid; x++) {
			for(int y = mid+1; y <= r; y++) {
				d[y][i] = d[i][y] = min(d[i][y], f[p-1][i][x] + w[x][y]);
			}
		}
	}
	for(int i = l; i <= mid; i++) {
		for(int y = mid+1; y <= r; y++) {
			for(int j = mid+1; j <= r; j++) {
				f[p][j][i] = f[p][i][j] = min(f[p][i][j], d[i][y] + f[p-1][y][j]);
			}
		}
	}
}
int main() {
	scanf("%d", &k);
	n = (1 << k);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			scanf("%d", &w[i][j]);
		}
	}
	dfs(k, 1, n);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			ans = min(ans, f[k][i][j]);
		}
	}
	printf("%d", ans);
}
```



---

## 作者：y3kkc (赞：2)

## 题意  
给你一棵 $t+1$ 层的满二叉树，将叶子节点从左到右编号为 $1...2^t$，现在你可以任意交换二叉树上非叶子结点的左右儿子，得到一个叶子结点的序列 $A_1...A_{2^t}$, 定义这个序列的权值为 $\sum_{i = 1}^{2^t - 1}B_{A_i,A_{i + 1}}$，求所有序列的权值的最小值。    

## 反思  
膜你赛时一眼想到区间 dp，但设计状态时卡住了，就设了一个很暴力的状态，完全没法优化。  

## 分析  
这道题每个区间看起来是独立的，把每个区间看做一个子问题显然是一个区间 dp。  

但楼主在做时发现转移还需要两边的编号，于是多开了两维记录了两边的情况，于是喜提 MLE 以及 TLE。  

然而我们仔细想想发现区间其实可以不用记录，直接在转移中体现即可。  

具体一点，我们可以一层一层处理，我们设当前节点的子叶子节点的编号为 $[l,r]$，那么显然他只能从 $[l,mid]$ 和 $[mid+1,r]$ 合并过来（$mid$ 为 $l$,$r$ 的中点），于是我们便不用记录区间了，只需记录端点编号即可。  

于是乎，我们就可以愉快地在二叉树上由深至浅的转移了。  

为了防止转移时由不合法的方案转移过来，我们还是再加一维 $d$,表示处理到了第 $d$ 层的情况。  

那么我们的状态就可以成功地设出来了：$dp_{d,i,j}$ 表示处理到第 $d$ 层时左端点编号为 $i$，右端点编号为 $j$ 的最小花费。  

$i$，$j$ 分别固定为左区间左端点和右区间右端点，我们只需枚举左区间的右端点 $x$ 以及右区间的左端点 $y$ 进行转移。  
据此，我们不难想出状态转移方程：
$$dp_{d,i,j}=\min(dp_{d+1,i,x}+b[x][y]+dp_{d+1,y,j})$$  

转移代码大概就长这个样子：  
```cpp
    for (int i = l; i <= mid; ++i) {
        for (int j = mid + 1; j <= r; ++j) {
            for (int x = l; x <= mid; ++x) {
                for (int y = mid + 1; y <= r; ++y) {
                    dp[d][i][j] = min(dp[d][i][j], dp[d + 1][i][x] + b[x][y] + dp[d + 1][y][j]);
                }
            }
            dp[d][j][i] = dp[d][i][j];
        }
    }
```  

但此时转移内部是 $n^4$ 的，还是会 TLE。  

考虑继续优化。  
  
我们肯定想到要去掉一层循环。  

也就是说如果我们只枚举 $x$ 行不行？  
  
发现与最常规的区间 dp 略有不同， 该区间 dp 是分三段累加得到的。   

也就是说 $y$,$j$ 根本不会对 $x$ 产生影响，他们是相对独立的。  
  
我们考虑预处理出 $f_{x,j}$ 表示 $\min(b_{x,y} + dp_{d+1,y,j})$。  

这一段暴力扫就行了，也是三层循环。  

转移 $dp$ 数组时直接将最后一层循环用 $f_{x,j}$ 替换掉，也成了三层循环。  

虽然看似时间复杂度为 $O(n^3\log n)$，但是前几层根本跑不满，所以可以过掉本题。  
  
## 代码  
[link](https://www.luogu.com.cn/paste/9znd18lc)。  

## 总结  
该题难点分为两点，状态设计和优化。  
* 状态设计的话我们可以利用题目特性，并不是一个完全意义的区间 dp。  

* 优化的话对于这种分三段的转移，其中两段互不干扰，我们可以尝试预处理。  



---

## 作者：Add_Catalyst (赞：0)

# P7587 [COCI2012-2013#1] MARS 题解

---

## 知识点

线性 DP，位运算，二叉树。

---

## 题意分析

给定一棵深度为 $K+1$ 的满二叉树，其中叶节点从 $1$ 编号到 $2^{K}$，可以随意地交换每个节点的左右子节点。

取出叶节点的排列 $A_1,A_2,\ldots,A_{2^K}$，规定其权值为 $\sum_{i=1}^{2^K-1} B_{A_i,A_{i+1}}$，其中 $B$ 是给定的数组。

求能够得到的最小叶节点排列权值。

---

## 思路分析

### 部分分

首先，我们能够简单的得到一个略显暴力的想法：用类似区间 DP 的方式记一个 $f_{i,j}$，表示左、右端点分别为 $i,j$ 的情况下，该段区间的权值最小值，转移也十分简单。

直接做一个 DFS，暴力选取左右子节点的后代区间，然后累加即可：
$$
f_{li,rj} = \min_{lj \in ls_{u},ri\in rs_{u}} (f_{li,lj} + B_{lj,ri} + f_{ri,rj}) \\
\forall li \in ls_u \land rj \in rs_u \lor li \in rs_u \land rj \in ls_u \\
$$
复杂度大概 $O(2^{4K})$，卡卡能拿到 $K \le 8$ 的点，但 $K = 9$ 的点是完全过不了。

### 正解

#### $O(2^{3K})$

我们考虑优化上面的解法。

发现对于同一对 $lj,rj$，$B_{lj,ri}+f_{ri,rj}$ 的使用有大量的重复，那么我们可以直接预处理出来 $g_{lj,rj}$，表示 $g_{lj,rj} = \min_{ri} (B_{lj,ri}+f_{ri,rj})$，转移时直接调用，复杂度降为 $O(2^{3K})$。

由于有效状态较少，这种方法是可以过的。

#### $O(2^{2K}K)$

如果我们把 $K$ 的范围提高到 $K \le 11$ 呢？

上面的方法明显就不行了，我们需要换一个状态。

我们考虑一个个加入叶节点，我们发现，当**加入节点数**和**上一个节点**已知时，那么下一个能加入的节点范围是固定且连续的，它的**长度**取决于**加入节点数**，**范围区间**取决于**上一个节点**，举个例子：

一共有 $8$ 个叶节点，已经加入了 $6$ 个，现在加入第 $7$ 个，设加入的点的数列为 $A_1,A_2,\ldots,A_{8}$，我们可以按二叉树左右子节点的分法来划分区间：$\{ \{A_1,A_2,A_3,A_4\},\{ \{A_5,A_6\},\{A_7,A_8\} \} \}$，那么很明显，放在 $A_7$ 这个位置的点只能是与 $A_6$ 的最近公共祖先为 $A_6$ 的父节点的父节点的点。

我们可以依照这个性质，运用位运算来快速解决这个问题：在到每一位的时候，枚举上一位数，求得范围后再枚举下一位数，最后简单统计即可。

在复杂度方面，刚刚说到：当**加入节点数**和**上一个节点**已知时，那么下一个能加入的节点范围是固定且连续的，它的**长度**取决于**加入节点数**，**范围区间**取决于**上一个节点**。我们依照这个性质，可以得到：

1. 枚举上一位是 $O(2^K)$ 级别的。
2. 枚举位置以及范围区间大小是 $O(\sum_{i=1}^K 2^{K-i}2^i)$，即 $O(2^K K)$。

相乘即：$O(2^{2K}K)$。

---

## CODE

#### $O(2^{3K})$

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define Vi vector<int>
#define Vii vector<Vi>
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(int i=(a);i<=(int)(b);++i)
#define Range(j,i) FOR(j,i<(siz>>1)?(siz>>1):0,i<(siz>>1)?siz-1:(siz>>1)-1)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=(1<<9)+1;
int l,n,idx,ans=INF;
int dfn[N];
int a[N][N];
#define lu (u<<1)
#define ru (u<<1|1)
#define siz (1<<(l-dep-1))
void dfs(int u,int dep,Vii &f){
	if(dep==l-1)return dfn[u]=++idx,++idx,f[0][1]=a[dfn[u]][dfn[u]+1],f[1][0]=a[dfn[u]+1][dfn[u]],void();
	if(dep==l)return f[0][0]=0,dfn[u]=++idx,void();
	Vii ls(siz,Vi(siz,INF)),rs(siz,Vi(siz,INF)),mi(siz<<1,Vi(siz<<1,INF));
	dfs(lu,dep+1,ls),dfs(ru,dep+1,rs),dfn[u]=dfn[lu];
	FOR(ri,0,siz-1)Range(rj,ri){
		if(rs[ri][rj]<INF)FOR(lj,0,siz-1)tomin(mi[lj][rj+siz],a[dfn[lu]+lj][dfn[ru]+ri]+rs[ri][rj]);
		if(rs[rj][ri]<INF)FOR(lj,0,siz-1)tomin(mi[rj+siz][lj],rs[rj][ri]+a[dfn[ru]+ri][dfn[lu]+lj]);
	}
	FOR(li,0,siz-1)Range(lj,li){
		if(ls[li][lj]<INF)FOR(rj,0,siz-1)tomin(f[li][rj+siz],ls[li][lj]+mi[lj][rj+siz]);
		if(ls[lj][li]<INF)FOR(rj,0,siz-1)tomin(f[rj+siz][li],mi[rj+siz][lj]+ls[lj][li]);
	}
	ls.clear(),rs.clear();
}
#undef lu
#undef ru
#undef siz
signed main(){
	cin>>l,n=1<<l;
	FOR(i,1,n)FOR(j,1,n)cin>>a[i][j];
	Vii f(1<<l,Vi(1<<l,INF));
	dfs(1,0,f);
	FOR(i,0,(1<<l)-1)FOR(j,0,(1<<l)-1)tomin(ans,f[i][j]);
	cout<<ans<<endl;
	return 0;
}
```

#### $O(2^{2K}K)$

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(int i=(a);i<=(int)(b);++i)
#define RCL(a,b,c,d) memset((a),(b),sizeof(c)*(d))
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
namespace IOstream{
#define getc() getchar()
#define putc(c) putchar(c)
#define blank(c) ((c)==' '||(c)=='\n'||(c)=='\r'||(c)==(EOF))
#define isdigit(c) (('0'<=(c)&&(c)<='9'))
	template<class T>inline void rd(T &x){
		static bool sign(0);
		static char ch(0);
		for(x=0,sign=0,ch=getc();!isdigit(ch);ch=getc())if(ch=='-')sign^=1;
		for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^'0'),ch=getc());
		return x=sign?-x:x,void();
	}
#undef blank
#undef digit
}using namespace IOstream;
constexpr int N=(1<<9)+10;
int k,n,ans=INF,*f,*g;
int a[N][N],DP[2][N];
signed main(){
	rd(k),n=1<<k;
	FOR(i,0,n-1)FOR(j,0,n-1)rd(a[i][j]);
	f=DP[1],g=DP[0],RCL(f,INF,int,n);
	for(int i=1,low=i&-i;i<n;++i,low=i&-i,swap(f,g),RCL(f,INF,int,n))
		FOR(j,0,n-1)FOR(k,(j^low)&~(low-1),((j^low)&~(low-1))+low-1)tomin(f[k],g[j]+a[j][k]);
	FOR(i,0,n-1)tomin(ans,g[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

---

## 作者：ZXZ_ (赞：0)

## 题意

给出一棵 $t+1$ 层的满二叉树，叶子节点的编号为 $1 \cdots 2^t$，你可以交换非叶子节点的左右子树从而得到一个由叶子节点组成的序列 $Q_{1,2,3 \cdots 2^t}$，依题意得，此序列的贡献为 $\sum _  {i=1} ^ {2^t-1} W_{A_{i},A_{i+1}}$。

## 做法：DP 和分治

状态：设 $f_{\text{dep},i,j}$ 为枚举到这棵满二叉树的第 $\text{dep}$ 层的区间时，左、右端点的编号分别为 $i,j$ 时的最小花费，易得一个时间复杂度为 $O(n^4)$ 的代码。

```
int mid=l+r>>1;
for(int i=l;i<=mid;i++)
  for(int j=mid+1;j<=r;j++)
	for(int L=l;L<=mid;L++)
	  for(int R=mid+1;R<=r;R++)
		f[dep][i][j]=min(f[dep][i][j],f[dep+1][i][L]+f[dep+1][R][j]+w[L][R]);
```


但是会爆炸。

于是我们考虑优化。

### 优化

观察代码：

```
f[dep][i][j]=min(f[dep][i][j],f[dep+1][i][L]+f[dep+1][R][j]+w[L][R]);
```

可以发现 $R,j$ 的值不会影响 $L$，所以可以处理出: 

$$g_{L,j} \gets \min(f_{dep,R,j} + w_{L,R})$$

这样就可以去掉一重循环以通过本题。

## code
```cpp
#include<cstdio>  
#include<cstring>  
#include<iostream>  
#define  N  600  
#define  ll  long  long  
const  ll  pow[10]={1,2,4,8,16,32,64,128,256,512};  
ll  k,w[N][N],s[N],f[11][N][N],tmp[N][N];  
void  solve(ll  dep,ll  l,ll  r){  
	if(l==r){f[dep][l][r]=0;return;}  
	ll  mid=l+r>>1;  
	solve(dep+1,l,mid),solve(dep+1,mid+1,r);  
	for(int  i=l;i<=mid;i++)  
		for(int  j=mid+1;j<=r;j++){  
			tmp[i][j]=0x3f3f3f3f;  
				for(int  k=mid+1;k<=r;k++)  
					tmp[i][j]=std::min(tmp[i][j],w[i][k]+f[dep+1][k][j]);  
		}  
	for(ll  i=l;i<=mid;i++)  
		for(ll  j=mid+1;j<=r;j++){  
			for(ll  L=l;L<=mid;L++)  
				f[dep][i][j]=std::min(f[dep][i][j],f[dep+1][i][L]+tmp[L][j]);  
			f[dep][j][i]=f[dep][i][j];  
		}  
	return;  
}  
int  main(){  
	scanf("%lld",&k);  
	for(ll  i=1;i<=pow[k];i++)  
		for(ll  j=1;j<=pow[k];j++)  
			scanf("%lld",&w[i][j]);  
	for(int  i=0;i<=10;i++)  
		for(int  j=1;j<=512;j++)  
			for(int  k=1;k<=512;k++)  
				f[i][j][k]=2147483647;  
	solve(0,1,pow[k]);  
	ll  ans=2147483647;  
	for(int  i=1;i<=pow[k];i++)  
		for(int  j=1;j<=pow[k];j++)  
			ans=std::min(ans,f[0][i][j]);  
	printf("%lld",ans);  
}
``` 



---


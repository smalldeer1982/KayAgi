# [COCI 2009/2010 #7] KRALJEVI

## 题目描述

Mirko 和 Slavko 在一个 $R \times C$ 的棋盘上游戏。他们各自在棋盘上摆放一定数量的王——王每步可以任选 $8$ 个方向中的一个移动 $1$ 步。现规定：

- 两个王之间的「距离」为其中一个王移动到另一个王所在棋格所需的最少步数。
- 一个玩家的「扩张度」为该玩家所有的王两两之间距离总和。

分别求出 Mirko 和 Slavko 的「扩张度」。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$ 的数据，棋盘上王的总数不超过 $5000$。
- 对于 $60\%$ 的数据，$R,C \le 300$。
- 对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 5 KRALJEVI_。**

**本题分值按 COCI 原题设置，满分 $120$。**

## 样例 #1

### 输入

```
2 3
SMS
MMS```

### 输出

```
3 5```

## 样例 #2

### 输入

```
2 3
S.M
M..```

### 输出

```
2 0```

## 样例 #3

### 输入

```
4 5
M....
..S.M
SS..S
.M...```

### 输出

```
10 13```

# 题解

## 作者：kkxacj (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8075)

[双倍经验（更简单）](https://www.luogu.com.cn/problem/P3964)

#### 思路

首先容易发现，两个王之间的距离为 $\max \left \{ \left |X_1-X_2  \right |,\left | Y_1 - Y_2 \right | \right \} $，直接求是 $c^2$ 的， $c$ 是点的个数，时间难以接受。

考虑进行改进，我们肯定希望能将 $\max$ 操作优化掉，联想到曼哈顿距离是 $\left |  x_1 - x_2\right | +\left |  y_1 - y_2\right | $，求这东西是很快的，考虑是否能将两个东西进行转化，可以将曼哈顿距离绝对值拆开，这样就存在了 $\max$，原式子就转化为 $\max\left\{x_1-x_2+y_1-y_2,x_1-x_2+y_2-y_1,x_2-x_1+y_1-y_2,x_2-x_1+y_2-y_1\right\}$

整理一下变为
$\max\left\{\left(x_1+y_1\right)-\left(x_2+y_2\right),-\left(x_1+y_1\right)+\left(x_2+y_2\right),\left(x_2+y_1\right)-\left(x_1+y_2\right),-\left(x_2+y_1\right)+\left(x_1+y_2\right)\right\}$

$\max\left\{\left|\left(x_1+y_1\right)-\left(x_2+y_2\right)\right|,\left|\left(x_2+y_1\right)-\left(x_1+y_2\right)\right|\right\}$

$\max\left\{\left|\left(x_1+y_1\right)-\left(x_2+y_2\right)\right|,\left|\left(-x_1+y_1\right)-\left(x_2-y_2\right)\right|\right\}$

$\max\left\{\left|\left(x_1+y_1\right)-\left(x_2+y_2\right)\right|,\left|\left(-x_1+y_1\right)+\left(-x_2+y_2\right)\right|\right\}$

这玩意就和之前那个 $\max \left \{ \left |X_1-X_2  \right |,\left | Y_1 - Y_2 \right | \right \} $ 很像了,$x_1+y_1=X_1,x_2+y_2=X_2,-x_1+y_1=Y_1,-x_2+y_2=Y_2$。

就可以解出 $x_1 = \frac{X_1+Y_1}{2},y_1 = \frac{X_1-Y_1}{2},x_2 = \frac{X_2+Y_2}{2},y_2 = \frac{X_2-Y_2}{2} $。

然后就转换成曼哈顿距离了。

曼哈顿距离就很好求了，将两个人分开算，直接树状数组维护比 $x$ 小的数和比 $x$ 大的数的和和个数就行了。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
int n,m,tot,tot1,ans,b[1000010],cnt1,c[1000010][2],c1[1000010][2],cnt,sum,sum1;
char cs;
struct w
{
	int x,y;
}a[1000010],d[1000010];
map<int,int>mp,mp1; 
inline void add(int x,int y,int y1,int id){while(x <= n*m) c[x][id]+=y,c1[x][id]+=y1,x+=x&-x;}
inline int query(int x,int id){int ans = 0; while(x) ans+=c[x][id],x-=x&-x; return ans;}
inline int query1(int x,int id){int ans = 0; while(x) ans+=c1[x][id],x-=x&-x; return ans;}
signed main()
{
	read(n); read(m);
	for(int i = 1;i <= n;i++) 
		for(int j = 1;j <= m;j++)
		{
			cin >> cs;
			if(cs == 'M') a[++tot].x = i+j,a[tot].y = j-i,b[++cnt1] = a[tot].y;
			else if(cs == 'S') d[++tot1].x = i+j,d[tot1].y = j-i,b[++cnt1] = d[tot1].y;
		}
	sort(b + 1,b + 1 + cnt1);
	for(int i = 1;i <= cnt1;i++) if(!mp[b[i]]) mp[b[i]] = ++cnt;
	cnt = cnt1 = 0;
	for(int i = 1;i <= tot;i++) b[++cnt1] = a[i].x;
	for(int i = 1;i <= tot1;i++) b[++cnt1] = d[i].x;
	sort(b + 1,b + 1 + cnt1);
	for(int i = 1;i <= cnt1;i++) if(!mp1[b[i]]) mp1[b[i]] = ++cnt;
	for(int i = 1;i <= tot;i++) 
	{
		add(mp[a[i].y],a[i].y,1,0),add(mp1[a[i].x],a[i].x,1,1);
		sum+=a[i].x,sum+=a[i].y;
		ans += (2*query1(mp1[a[i].x],1)-i)*a[i].x + sum - 2*query(mp1[a[i].x],1);
		ans += (2*query1(mp[a[i].y],0)-i)*a[i].y + sum1 - 2*query(mp[a[i].y],0);
	}
	for(int i = 1;i <= tot;i++) sum-=a[i].x,sum1-=a[i].y,add(mp[a[i].y],-a[i].y,-1,0),add(mp1[a[i].x],-a[i].x,-1,1); 
	print(ans>>1); pc(' ');
	ans = 0;
	for(int i = 1;i <= tot1;i++) 
	{
		add(mp[d[i].y],d[i].y,1,0),add(mp1[d[i].x],d[i].x,1,1);
		sum+=d[i].x,sum1+=d[i].y;
		ans += (2*query1(mp1[d[i].x],1)-i)*d[i].x + sum - 2*query(mp1[d[i].x],1);
		ans += (2*query1(mp[d[i].y],0)-i)*d[i].y + sum1 - 2*query(mp[d[i].y],0);
	}
	print(ans>>1);
	flush();
	return 0;
}
```

---

## 作者：serene_analysis (赞：8)

[MoYuFang](https://www.luogu.com.cn/user/474113) 写了一个我看不太懂的 DP，我来写个套路一些的解法。

---

观察可以发现 Mirko 和 Slavko 的扩张度各自独立，可以分开考虑。

棋盘距离是 $\max\{|x_1-x_2|,|y_1-y_2|\}$，同时带了 $\max$ 和绝对值不好处理，考虑将其转换为求和快的曼哈顿距离 $|x_1-x_2|+|y_1-y_2|$。根据公式，将原来的点 $(x,y)$ 变成 $(\dfrac{x+y}{2},\dfrac{x-y}{2})$ 即可将切比雪夫距离转为曼哈顿距离。（更详细的说明可见[这篇题解](https://80358.blog.luogu.org/solution-p3964)）

其实到这里已经做完了，可以直接找出所有点，按横坐标排序，使用树状数组维护纵坐标，处理绝对值分开讨论即可。具体实现时可以不急着除以 $2$，在最后统一除可以避免实数运算。同时因为有负数，树状数组里要整体偏移。$\mathcal{O}(nm\log nm)$。

稍加思考，你发现树状数组没有任何必要。因为曼哈顿距离两个维度互相独立，可以先按横坐标排序并统计横坐标贡献，再按纵坐标排序并统计贡献。时间复杂度不变，但会好写一点。

第二个做法时间复杂度瓶颈在排序，因此只要传入时就是有序的就可以抛掉排序了。方法很多，我选择的是枚举转换前和转换后的横坐标以统计横坐标贡献，枚举转换前后的纵坐标以统计其贡献。因为不需要排序，因此时间复杂度 $\mathcal{O}(nm)$，达到了下界，其常数相比直接在棋盘上 DP 可能略小，也更好写一些，不失为一种优秀解法。

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
const int maxn=1e3+5;
const int maxm=1e3+5;
typedef long long ll;
struct point{
	int x,y;
}mir[maxn*maxm],sla[maxn*maxm];
int mcnt,scnt;
int n,m;
char mp[maxn][maxm];
ll get(point *poi,int n,bool calx){
	ll ret=0,got=0;
	if(calx)for(int i=1;i<=n;i++)ret+=1ll*(i-1)*poi[i].x-got,got+=poi[i].x;
	else for(int i=1;i<=n;i++)ret+=1ll*(i-1)*poi[i].y-got,got+=poi[i].y;
	return ret;
}
ll mans,sans;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("\n%s",mp[i]+1);
	for(int x=2;x<=n+m;x++)for(int i=1;i<=n;i++){
		if(x-i>=1&&x-i<=m){
			if(mp[i][x-i]=='M')mir[++mcnt]=(point){x,x-2*i};
			if(mp[i][x-i]=='S')sla[++scnt]=(point){x,x-2*i};
		}
	}
	mans+=get(mir,mcnt,true),sans+=get(sla,scnt,true),mcnt=scnt=0;
	for(int y=1-m;y<=n-1;y++)for(int j=1;j<=m;j++){
		if(y+j>=1&&y+j<=n){
			if(mp[y+j][j]=='M')mir[++mcnt]=(point){y+2*j,y};
			if(mp[y+j][j]=='S')sla[++scnt]=(point){y+2*j,y};
		}
	}
	mans+=get(mir,mcnt,false),sans+=get(sla,scnt,false);
	printf("%lld %lld",mans/2,sans/2);
	return 0;
}
```

感谢你的阅读。

---

## 作者：WhiteSunFlower (赞：5)

[原题传送门](https://www.luogu.com.cn/problem/P8075)

[My Blog](https://www.luogu.com.cn/blog/guicai-qq-1443870605/)

## 写在前面
本片题解详细地写了思考的过程，所以会有~~亿~~一点点长，建议慢慢阅读，也许会加深你对 DP 的理解，码字不易，感谢观看

## 观察和思考

观察数据，暴力的 $n^4$ 显然是不可行的，所以我们在计算时不可以单独一对一的计算，而是必须同时处理多个国王，第一想到的自然是 DP 动态规划。

根据套路我们首先敲定一个状态，设 $F[i][j]$ 为从 $ (0,0) $ 到 $ (i,j) $，所有国王和 $ (i,j) $ 距离的和。

思考不难发现，这个状态设置的并不全面，因为F状态只能计算到从左上所有国王到 $ (i,j) $ 的距离和，但是不排除会存在右上仍有国王，我们再套路性的设置一个状态 $G[i][j]$ 为从 $ (0,m) $ 到 $ (i,j) $ 中，所有棋子和 $ (i,j) $ 距离的和。

DP 的重点就是对状态进行转移,我们先思考 $F$ 的状态转移，因为想出 $F$ 之后，$G$ 也就迎刃而解了，学过 DP 的都知道，我们想要从已知状态 $A$ 转移到目标状态 $B$，那么要求 $A \subseteq B$（$B$ 包含 $A$ 的所有状态）。

根据这个条件，我们发现简单的从 $F[i-1][j]$ 或 $F[i][j-1]$ 推到 $F[i][j]$ 是不可行的，因为 $ (0,0) $ 到 $ (i-1,j-1) $ 中的点都没必要经过 $ (i-1,j) $ 或者 $ (i,j-1) $。

## 思考的发现
想到这里，是不是一切都那么的自然而然，实际上这个问题已经被我们解决了，就在上一行，你可能会感到疑惑，别急，听我慢慢讲。

我们已知 $ (0,0) $ 到 $ (i-1,j-1) $ 的所有点走到 $ (i,j) $ 的最短路线都不会经过 $ (i-1,j) $ 或者 $ (i,j-1) $，那么他们是不是会经过 $ (i-1,j-1) $ 呢？

仔细思考，你就会惊喜的发现居然确实如此！以此为依据，我们又可以发现 $ (i,j) $ 左边的点都会经过 $ (i-1,j) $，$ (i,j) $ 上面的点都会经过 $ (i,j-1) $（注意这里我们考虑的是 $F$ 状态，$G$ 需要考虑的是右方和上方）。

我们将 $L[i][j]$ 设置为 $ (i,j) $ 左侧的的国王和 $ (i,j) $ 距离的和。 
$U[i][j]$ 设置为 $ (i,j) $ 上方的的国王和 $ (i,j) $ 距离的和。于是我们就成功得出了一半的状态了。验证一下

$ F_{i-1,j-1}\cup L_{i-1,j}\cup U_{i,j-1}=F_{i,j}$

$ F_{i-1,j-1}\cap L_{i-1,j}\cap U_{i,j-1}=\emptyset$

简直完美的状态，形象的可以理解成下图。（蓝色为 $F[i-1][j-1]$,绿色为 $U[i][j-1]$,橙色为 $L[i-1][j]$ ，红色为 $ (i,j)$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/71ilzdqa.png)

## 状态转移

对于 DP 理解较好的同学这时候已经可以开始推算状态转移方程了，因为满足
$$ F_{i-1,j-1}\cup L_{i-1,j}\cup U_{i,j-1}=F_{i,j}$$


$$ F_{i-1,j-1}\cap L_{i-1,j}\cap U_{i,j-1}=\emptyset$$


的状态设置只能用完美来形容。

那么怎么转移呢，显然光知道总距离是远远不够的，我们还得知道国王的数量，接下来就好办了，从 $ (i-1,j-1)(i,j-1)(i-1,j)$ 走到 $(i,j)$ 的步数都是 $1$，只要加上国王的数量即可。数量用前缀和的原理即可。
我们用小写字母表示数量，大写字母表示步数。

```cpp

l[i][j]=l[i][j-1]+a[i][j];//a[i][j]=1表示(i,j)有国王，0则没有
L[i][j]=L[i][j-1]+l[i][j-1];
u[i][j]=u[i-1][j]+a[i][j];
U[i][j]=U[i-1][j]+u[i-1][j];
f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+a[i][j];
F[i][j]=F[i-1][j-1]+f[i-1][j-1]+L[i][j]+U[i][j];

r[i][j]=r[i][j+1]+a[i][j];
R[i][j]=R[i][j+1]+r[i][j+1];
g[i][j]=g[i][j+1]+g[i-1][j]-g[i-1][j+1]+a[i][j];
G[i][j]=G[i-1][j+1]+g[i-1][j+1]+R[i][j]+U[i][j];


```
最后求出
$$ \sum_{i=1}^{n} \sum_{j=1}^{m}[ a_{i,j}=1 ](F_{i,j}+G_{i,j}-U_{i,j}-R_{i,j}) $$
即可，（$U,R$ 会重复计算）。

注意最高答案会达到 $n^3m^2$，故要开 long long。

于是你就会快乐的 MLE 了（丧心病狂的空间限制）。

观察发现 $F$ 和 $G$ 必须分开做且完全独立，那么就可以让 $F$ 代替 $G$，$R$ 代替 $L$。然后收获蓝题 AC 一枚。

## 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 1005
#define fr(i,a,b)  for(register int i=(a);i<=(b);++i)
#define dfr(i,a,b) for(register int i=(a);i>=(b);--i)
ll n,m;
ll r[N][N],R[N][N],f[N][N],F[N][N],u[N][N],U[N][N];
ll a[N][N];
char s[N][N];
inline ll dp(ll n,ll m){
	ll ans=0;
	fr(i,1,n)fr(j,1,m){
		r[i][j]=r[i][j-1]+a[i][j];
		R[i][j]=R[i][j-1]+r[i][j-1];
		u[i][j]=u[i-1][j]+a[i][j];
		U[i][j]=U[i-1][j]+u[i-1][j];
		f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+a[i][j];
		F[i][j]=F[i-1][j-1]+f[i-1][j-1]+R[i][j]+U[i][j];
		if(a[i][j])ans+=F[i][j];
	}
	fr(i,1,n)dfr(j,m,1){
		r[i][j]=r[i][j+1]+a[i][j];
		R[i][j]=R[i][j+1]+r[i][j+1];
		f[i][j]=f[i][j+1]+f[i-1][j]-f[i-1][j+1]+a[i][j];
		F[i][j]=F[i-1][j+1]+f[i-1][j+1]+R[i][j]+U[i][j];
		if(a[i][j])ans+=F[i][j]-R[i][j]-U[i][j]; 
	}
	return ans;
}
int main(){
	cin >> n >> m;
	fr(i,1,n){
		getchar();getchar();//本机测需要删一个
		fr(j,1,m)s[i][j]=getchar();
	}
	fr(i,1,n)fr(j,1,m)a[i][j]=(s[i][j]=='M');
	ll a1,a2;
	a1=dp(n,m);
	fr(i,1,n)fr(j,1,m)a[i][j]=(s[i][j]=='S');
	a2=dp(n,m);
	cout << a1 << " " << a2 << endl;
	return 0;
}
 
 

```

---

## 作者：MSqwq (赞：2)

非 DP 的线性做法。

------------

首先你要知道**切比雪夫距离**是个什么东西，如果不清楚的可以看这个佬的[博客](https://80358.blog.luogu.org/solution-p3964#) 可以顺便做一下这个例题，这样你对切比雪夫距离会有一个更深刻的理解。 

------------
   
好的你现在已经会了，来看这题，首先考虑任意两点的「距离」该怎么算，你可以画个图，比如:  
![](https://i.hd-r.cn/6aee5e515b2818c20ca57b1cf4fd55a3.png)   
那么 A 一定是先斜着到达 B 的那一行，然后再到横着走到 B 那里取的，因为题目很特殊，告诉你斜着走的代价等于横着竖着走的代价，所以最终距离就是 $\max(\left| x_a-x_b \right|,\left| y_a-y_b \right|)$。  
你发现这就是**切比雪夫距离**，本题就变成了求任意两点的切比雪夫距离罢。但是你发现有绝对值，还有 $\max$ 巨麻烦，要分很多类讨论，但是你想想我们会什么，我们会 **曼哈顿距离** 啊，我们贼熟悉这个，考虑两者转化，其实上面的博客已经说的很清楚了，其原理就是分类讨论绝对值情况，几何证明其实就是曼哈顿距离相等的点是正方形，要变成切比雪夫距离要旋转 $45^{\circ}$ 。  
特殊的，因为如果直接转化切比雪夫距离是 $A(x,y)=A(\frac{x+y}{2},\frac{x-y}{2})$（当然前面减后面加也是可以的），你会发现除以 $2$ 会出现小数，所以我们同一不除，因为后面都是一次项相加，所以答案除以二就行。  
那么就好算了啊，而且横纵坐标还互不干涉，可以分开算，问题就变成了求 $\sum\limits_{i=1}^n \sum\limits_{j=i+1}^n \left| a_i-a_j \right|$。  
有正负我们避免正负，永远让大的减小的，所以排个序，进行计算。  
如果你还是不会，那我举个例子 $a={1,3,4,7}$，你要算这个式子，那么我们就避免绝对值中减为负数，那么就是 $(3-1)+(4-1)+(4-3)+(7-1)+(7-3)+(7-4)$，然后你就发现每个数的贡献就是前面数的个数乘本身然后减去前缀和。那么就可以 $O(n)$ 完成。  
所以最终复杂度为 $O(nm)$。  
注意开 long long 吧，比较这个乘起来还是巨大。  
代码如下：  
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=998244353;
const int INF=0x3f3f3f3f;

inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0',c=getchar();}
	return x*f;
}
const int N=1e3+10;
char a[N][N];
vector<int>mx,my,sx,sy;
ll work(vector<int>v)
{
	ll res=0,sum=0,p=0;
	for(auto x:v)res+=p*x-sum,p++,sum+=x;
	return res;
}
int main()
{
	int r=read(),c=read();
	for(int i=1;i<=r;i++)cin>>a[i]+1;
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			if(a[i][j]=='M')mx.push_back(i+j),my.push_back(i-j);
			if(a[i][j]=='S')sx.push_back(i+j),sy.push_back(i-j);
		}
	}
	sort(mx.begin(),mx.end()),sort(my.begin(),my.end());
	sort(sx.begin(),sx.end()),sort(sy.begin(),sy.end());
	ll ans1=work(mx)+work(my),ans2=work(sx)+work(sy);
	printf("%lld %lld\n",ans1/2,ans2/2);
	return 0;
}

```


---

## 作者：MoYuFang (赞：1)

[P8075 [COCI2009-2010#7] KRALJEVI](https://www.luogu.com.cn/problem/P8075)

为了方便这里用 $n$ 代替行数，$m$ 代替列数，坐标 $(i,j)$ 代表第 $i$ 行第 $j$ 列。

对于两个坐标 $(i,j),(x,y)$，定义它们的大小关系 $(i,j)<(x,y)\Leftrightarrow i<x\vee(i=x\wedge j<y)$，也就是二元组的字典序。

读完题可以发现，M 与 S 完全可以分开考虑，以下只考虑一种国王两两之间的距离。

基本的思路很好想，就是对每个坐标 $(i,j)$，用 dp 维护每个坐标 $(x,y)$ 满足 $(x,y)<(i,j)$ 的国王到 $(i,j)$ 的距离之和，设它为 $dp(i,j)$。

于是答案就是有国王的位置的 $dp(i,j)$ 之和。

若两个国王的坐标分别为 $(x_1, y_1),(x_2,y_2)$，则它们之间的距离就是 $\max\{|x_1-x_2|,|y_1-y_2|\}$，即行距离与列距离中较大的那个。

根据这个性质，容易看出当 $x_2$ 和 $y_2$ 同时 $+1$ 时，这个距离一定会 $+1$，这启示我们用按照 $i$ 与 $j$ 同时增加的方式进行 dp 转移。

设

$a(i,j)$ 表示坐标 $(i,j)$ 上是否有国王，若有则 $a(i,j)=1)$，没有则 $a(i,j)=0$。

$f(i,j)$ 表示所有坐标 $(x,y)$ 满足 $x\le i,y\le j$ 的国王的数量，$F(i,j)$ 表示它们与坐标 $(i,j)$ 的距离之和。

$f,F$ 相当于对左上部分做了统计。

$g(i,j)$ 表示所有坐标 $(x,y)$ 满足 $x\le i,y\ge j$ 的国王的数量，$G(i,j)$ 表示它们与坐标 $(i,j)$ 的距离之和。

$g,G$ 相当于对右上部分做了统计。

$r_1(i,j)$ 表示所有坐标 $(x,y)$ 满足 $x=i,y\le j$ 的国王的数量，$R_1(i,j)$ 表示它们与坐标 $(i,j)$ 的距离之和。

$r_1,R_1$ 相当于对同一行的左边做了统计。

$r_2(i,j)$ 表示所有坐标 $(x,y)$ 满足 $x=i,y\ge j$ 的国王的数量，$R_2(i,j)$ 表示它们与坐标 $(i,j)$ 的距离之和。

$r_2,R_2$ 相当于对同一行的右边做了统计。

$c(i,j)$ 表示所有坐标 $(x,y)$ 满足 $x\le i,y=j$ 的国王的数量，$C(i,j)$ 表示它们与坐标 $(i,j)$ 的距离之和。

$c,C$ 相当于对同一列的上边做了统计。

于是容易写出转移方程：

$$
\begin{aligned}
&r_1(i,j)=r_1(i,j-1)+a(i,j) & R_1(i,j)=R_1(i,j-1)+r(i,j-1)\\
&r_2(i,j)=r_2(i,j+1)+a(i,j) & R_2(i,j)=R_2(i,j+1)+r(i,j+1)\\
&c(i,j)=c(i-1,j)+a(i,j) & C(i,j)=C(i-1,j)+c(i-1,j)\\
\end{aligned}
$$

$$
\begin{aligned}
&f(i,j)=f(i-1,j-1)+r_1(i,j)+c(i,j)-a(i,j)\\
&F(i,j)=F(i-1,j-1)+R_1(i,j)+C(i,j)\\
&g(i,j)=g(i-1,j+1)+r_2(i,j)+c(i,j)-a(i,j)\\
&G(i,j)=G(i-1,j+1)+R_2(i,j)+C(i,j)\\
\end{aligned}
$$

然后考虑不重不漏的统计答案：
$$
ans=\sum_{i=1}^{n}\sum_{j=1}^{m}\left(F(i,j)+G(i,j)-R_2(i,j)-C(i,j)\right)
$$

其中减去 $R_2(i,j)$ 和 $C(i,j)$ 是因为这两部分是算重的。

单次转移都是 $O(1)$，所以总时间复杂度为 $O(nm)$。

最后注意棋盘上国王的数量是 $O(nm)$，两两之间的距离之和是 $O(n^3m^2)$ 所以要开 ```long long```。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
using namespace std;

#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define db double
#define ull unsigned long long
#define _for(i, a, b) for(re int i = (a); i < (b); ++i)
#define _rfor(i, a, b) for(re int i = (a); i <= (b); ++i)
#define _drfor(i, b, a) for(re int i = (b); i >= (a); --i)
#define _fev(p, u) for(re int p = head[u]; p; p = nex[p])
#define inf 0x7fffffff
#define maxn 1005
#define mod 998244353ll

template <class T>
void print(string name, T arr[], int n, int flag = 1){
	cout<<name<<":";
	_for(i, 0, n)cout<<" "<<arr[i+flag];
	cout<<endl;
}

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

char str[maxn][maxn];
bool a[maxn][maxn];
ll r[maxn][maxn], c[maxn][maxn], f[maxn][maxn],
	R[maxn][maxn], C[maxn][maxn], F[maxn][maxn];

ll dp(re int n, re int m){
	re ll ans = 0;
	_rfor(i, 1, n) _rfor(j, 1, m){
		r[i][j] = r[i][j-1] + a[i][j];
		R[i][j] = R[i][j-1] + r[i][j-1];
		c[i][j] = c[i-1][j] + a[i][j];
		C[i][j] = C[i-1][j] + c[i-1][j];
		f[i][j] = f[i-1][j] + f[i][j-1] - f[i-1][j-1] + a[i][j];
		F[i][j] = F[i-1][j-1] + f[i-1][j-1] + R[i][j] + C[i][j];
		if (a[i][j]) ans += F[i][j];
	}
	_rfor(i, 1, n) _drfor(j, m, 1){
		r[i][j] = r[i][j+1] + a[i][j];
		R[i][j] = R[i][j+1] + r[i][j+1];
		f[i][j] = f[i-1][j] + f[i][j+1] - f[i-1][j+1] + a[i][j];
		F[i][j] = F[i-1][j+1] + f[i-1][j+1] + R[i][j] + C[i][j];
		if (a[i][j]) ans += F[i][j] - R[i][j] - C[i][j];
	}
	return ans;
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("sample.in", "r", stdin);
	//freopen("sample.out", "w", stdout);
	#endif

	re int n = rdnt(), m = rdnt();
	re ll a1, a2;
	_rfor(i, 1, n) sf("%s", str[i]+1);
	
	_rfor(i, 1, n) _rfor(j, 1, m) a[i][j] = str[i][j] == 'M';
	a1 = dp(n, m);
	
	_rfor(i, 1, n) _rfor(j, 1, m) a[i][j] = str[i][j] == 'S';
	a2 = dp(n, m);
	
	pf("%lld %lld\n", a1, a2);

	return 0;
}

```








---

## 作者：内拉组里 (赞：0)

首先要知道什么是**切比雪夫距离**（以下简称切距），以及与曼距之间的转化关系。

> 摘自 [**OI-Wiki**](https://oi-wiki.org/geometry/distance/#%E7%BB%93%E8%AE%BA)：
>
> - 将一个点 $ (x,y) $ 的坐标变为 $ (x + y,x - y) $ 后，原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离。
> - 将一个点 $ (x,y) $ 的坐标变为 $ (\frac{x + y}2,\frac{x - y}2) $ 后，原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离。

然后就可以开始了。

# Thoughts：

观察到 $ R $ 的范围并不大，能够接受 $ \Theta (R^2) $ 的复杂度，

而两点间的切距最大只有 $ \max \{ R,C \} $，故每个位置的横纵坐标的和差最多只有 $ 1000 $ 种。

考虑先调整坐标系把求切距转化为求曼距，然后开桶记录每个横（纵）坐标上的点数。

最后枚举坐标轴上每个横（纵）坐标，两坐标的距离和对应坐标的点数的乘积即为贡献。

# Details：

- 题目中的**距离**不考虑路径上对方的棋子。

# Analyses：

> 总时间复杂度 $ \Theta (RC) $。
>
> 总空间复杂度 $ \Theta (RC) $。

# Code：

```cpp
/* reference : @ZLOJ. Zhang_Jiahao[art] */
#include	<iostream>
#include	<map>
#define		int		long long
using namespace std;
constexpr int maxc = 1e3+4;

int r, c;
char G[maxc][maxc];

inline int calc (char C)
{
	map<int,int> sm, dt;
	for (int i = 1; i <= r; i++)
	{
		for (int j = 1; j <= c; j++)
		{
			if (G[i][j] == C)
			{
				sm[i + j]++;
				dt[i - j]++;
			}
		}
	}
	int ans = 0;
	for (auto i = sm.begin(); i != sm.end(); i++)
	{
		for (auto j = next (i); j != sm.end(); j++)
		{
			ans += abs (i->first - j->first) * i->second * j->second;
		}
	}
	for (auto i = dt.begin(); i != dt.end(); i++)
	{
		for (auto j = next (i); j != dt.end(); j++)
		{
			ans += abs (i->first - j->first) * i->second * j->second;
		}
	}
	return ans >> 1;
}

signed main (void)
{
	cin >> r >> c;
	for (int i = 1; i <= r; i++) cin >> G[i] + 1;
	cout << calc ('M') << ' ' << calc ('S') << endl;
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

一道切比雪夫距离转曼哈顿距离的板子题。  
我们考虑对于一个人的答案，记下出现的所有棋子位置，假设一共有 $cnt$ 个，表达式写为$\sum_{i=1}^{cnt}\sum_{j=i+1}^{cnt} \max(|x_i-x_j|,|x_i-y_j|)$  
但是这显然不好优化，又是 $\max$ 又是绝对值的，所以我们考虑将切比雪夫距离转为曼哈顿距离，对于一个坐标系，如果将每个点 $(x,y)$，变为 $(\frac{x-y}{2},\frac{x+y}{2})$ 的话，原坐标系中的切比雪夫距离相当于当前坐标系的曼哈顿距离，具体证明可以看 [OI Wiki](https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96)。  
那这道题就变成水题了，我们记录 $pre_{1,i}$ 表示前若干行前 $i$ 列的棋子个数，$pre_{2,i}$ 表示前若干行前 $i$ 列的棋子位置乘列号，$sum_1$ 表示前若干行的棋子总数，$sum_2$ 表示前若干行的棋子位置乘行号，那么对于一个点 $(i,j)$，它对于答案的贡献为 $pre_{1,j}\times j-pre_{2,j}+(pre_{2,n}-pre_{2,j})-(pre_{1,n}-pre_{1,j})\times j+sum_1\times i-sum_2$，但是还有与他同一行的棋子到他的距离没有计算，我们记录 $x$ 表示前面有几颗棋子，和 $y$ 表示棋子位置乘列号，那么这一部分的贡献为 $i\times x-y$。  
但是我们发现坐标转换时可能出现小数，因此我们可以选择对于答案整体除二即可。

```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define int long long
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
int R,C,n,ans1,ans2,cnt,tag;
int mp[3005][3005],pre[2][3005];
char c[1005][1005];
signed main(){
	read(R),read(C);
	for(int i=1;i<=R;i++)scanf("%s",c[i]+1);
	tag=max(R,C);
	for(int i=1;i<=R;i++)
		for(int j=1;j<=C;j++)
			mp[i+j+tag][i-j+tag]=(c[i][j]=='M'?1:(c[i][j]=='S'?2:0));
	n=R+C+tag;
	for(int i=1,sum1=0,sum2=0,x,y;i<=n;i++){
		x=0,y=0;
		for(int j=1;j<=n;j++){
			if(mp[i][j]==1){
				ans1+=x*j-y;
				ans1+=sum1*i-sum2;
				ans1+=pre[0][j]*j-pre[1][j];
				ans1+=(pre[1][n]-pre[1][j])-(pre[0][n]-pre[0][j])*j;
				x++;
				y+=j;
			}
		}
		for(int j=1,val1=0,val2=0;j<=n;j++){
			if(mp[i][j]==1){
				sum1++;
				sum2+=i;
				val1++;
				val2+=j;
			}
			pre[0][j]+=val1;
			pre[1][j]+=val2;
		}
	}
	memset(pre,0,sizeof(pre));
	for(int i=1,sum1=0,sum2=0,x,y;i<=n;i++){
		x=0,y=0;
		for(int j=1;j<=n;j++){
			if(mp[i][j]==2){
				ans2+=x*j-y;
				ans2+=sum1*i-sum2;
				ans2+=pre[0][j]*j-pre[1][j];
				ans2+=(pre[1][n]-pre[1][j])-(pre[0][n]-pre[0][j])*j;
				x++;
				y+=j;
			}
		}
		for(int j=1,val1=0,val2=0;j<=n;j++){
			if(mp[i][j]==2){
				sum1++;
				sum2+=i;
				val1++;
				val2+=j;
			}
			pre[0][j]+=val1;
			pre[1][j]+=val2;
		}
	}
	write(ans1>>1),Spa,write(ans2>>1);
}
```

---

## 作者：xixisuper (赞：0)

# P8075 [COCI2009-2010#7] KRALJEVI 题解

好玩题。

算是曼哈顿距离与切比雪夫距离的互化的板子。

## 思路

首先 Mirko 和 Slavo 显然是可以分别计算的，于是我们暂时只考虑其中一方。

注意到题目中两个王的距离等价于两点之间的切比雪夫距离，所以题目实际上要求的就是所有点对之间的切比雪夫距离之和。

但是由于点的数量是 $O(RC)$ 量集的，于是点对的数量就是 $O(R^2C^2)$ 量级，暴力枚举显然是过不了的，于是我们考虑优化。

对于点对之间的距离快速求和，我们不难想到如果点对之间是曼哈顿距离，则我们能够以更快的速度求出点对之间距离之和，而本题的关键点在于**切比雪夫距离与曼哈顿距离是可以互化的**。

### 关于曼哈顿距离与切比雪夫距离的互化

我们记两点间的切比雪夫距离为 $Q(a,b)$，曼哈顿距离为 $M(a,b)$，有：
$$
Q(a,b)=\max\{|X_a-X_b|,|Y_a-Y_b|\}
$$
$$
M(a,b)=|x_a-x_b|+|y_a-y_b|
$$

注意到曼哈顿距离有一个绝对值，又因为：

$$|a-b|\ge a-b$$
$$|a-b|\ge b-a$$

所以我们可以把曼哈顿距离拆开，拆成带 $\max$ 的形式：

$$
\begin{aligned}
M(a,b)&=|x_a-x_b|+|y_a-y_b|\\
&=\max\{(x_a-x_b)+(y_a-y_b),-(x_a-x_b)+(y_a-y_b),(x_a-x_b)-(y_a-y_b),-(x_a-x_b)-(y_a-y_b)\}\\
&=\max\{x_a-x_b+y_a-y_b,-x_a+x_b+y_a-y_b,x_a-x_b-y_a+y_b,-x_a+x_b-y_a+y_b\}\\
&=\max\{(x_a+y_a)-(x_b+y_b),-(x_a-y_a)+(x_b-y_b),(x_a-y_a)-(x_b-y_b),-(x_a+y_a)+(x_b+y_b)\}\\
&=\max\{|(x_a+y_a)-(x_b+y_b)|,|(x_a-y_a)-(x_b-y_b)|\}\\
&=\max\{|X_a-X_b|,|Y_a-Y_b|\}
\end{aligned}
$$

于是令：

$$
\begin{cases}
X_a=x_a+y_a\\
X_b=x_b+y_b\\
Y_a=x_a-y_a\\
Y_b=x_b-y_b
\end{cases}
\medspace\medspace\medspace\medspace\medspace\medspace\medspace\medspace\medspace
\begin{cases}
x_a=\frac{X_a+Y_a}{2}\\
x_b=\frac{X_b+Y_b}{2}\\
y_a=\frac{X_a-Y_a}{2}\\
y_b=\frac{X_b-Y_b}{2}
\end{cases}
$$

此时 $M(a,b)=Q(a,b)$。

所以对于某个在棋盘上位置 $(i,j)$ 的点，将其视为在 $(\frac{i+j}{2},\frac{i-j}{2})$ 上，然后就变成了求点对之间曼哈顿距离的和了。

如何求点对之间曼哈顿距离的和呢？我们重新观察曼哈顿距离的式子：

$$
M(a,b)=|x_a-x_b|+|y_a-y_b|
$$

所以对答案的贡献可以拆成 $x$ 坐标和 $y$ 坐标两部分，而每一部分都是形如 $|a-b|$ 的绝对值形式，所以我们考虑用一个树状数组维护值域，然后求出所有 $\le b$ 的 $a$ 的个数 $cnt$ 以及和 $sum$，则其对答案的贡献为 $cnt\cdot b-sum$。

归到时间复杂度分析，由于一共有 $O(RC)$ 量级的点，设 $V$ 表示值域，则总时间复杂度为 $O(RC\log V)$，可以通过此题。

最后我们再考虑一些实现细节：

- 实际上只需要把点视为 $(i+j,i-j)$ 即可，这样能够免去对实数的讨论，最后只需要把最终答案除以 $2$ 即可。
- 注意到 $i-j$ 可能 $\le 0$，所以用树状数组维护值域的时候要加上一个偏移量。
- 由于你维护值域的时候加上了一个偏移量，所以实际上值域不是 $2\max\{R,C\}$ 量级的，而是 $3\max\{R,C\}$ 量级的，注意树状数组不要开小了。

## 代码

十分不优美的代码，不喜勿喷。

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const ll N=1e6+10;
const ll min_RC=1005;
const ll PY=1000;
const ll H=min_RC<<2;
ll n,m,totM,totS;
string s[min_RC]; 
pair<ll,ll> Mirko[N],Slavko[N];
ll cnt[H],sum[H];
inline ll lowbit(ll x){return x&(-x);}
inline void add(ll p,ll x){
	for(ll i=p;i<H;i+=lowbit(i)){
		sum[i]+=x;
		cnt[i]+=1;
	}
}
inline pair<ll,ll> query(ll p){
	pair<ll,ll> ret=make_pair(0,0);
	for(ll i=p;i;i-=lowbit(i)){
		ret.first+=sum[i];
		ret.second+=cnt[i];
	}
	return ret;
}
void init(){for(ll i=0;i<H;i++) cnt[i]=sum[i]=0;}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;i++){cin>>s[i];s[i]=' '+s[i];}
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++){
			if(s[i][j]=='M') Mirko[++totM]=make_pair(i+j,i-j);
			if(s[i][j]=='S') Slavko[++totS]=make_pair(i+j,i-j);
		}
	}
	ll ansM=0,ansS=0;
	for(ll i=1;i<=totM;i++) add(Mirko[i].first+PY,Mirko[i].first);
	for(ll i=1;i<=totM;i++){
		pair<ll,ll> L=query(Mirko[i].first+PY);
		ansM+=L.second*Mirko[i].first-L.first;
	}
	init();
	for(ll i=1;i<=totM;i++) add(Mirko[i].second+PY,Mirko[i].second);
	for(ll i=1;i<=totM;i++){
		pair<ll,ll> L=query(Mirko[i].second+PY);
		ansM+=L.second*Mirko[i].second-L.first;
	}
	init();
	cout<<ansM/2<<' ';
	for(ll i=1;i<=totS;i++) add(Slavko[i].first+PY,Slavko[i].first);
	for(ll i=1;i<=totS;i++){
		pair<ll,ll> L=query(Slavko[i].first+PY);
		ansS+=L.second*Slavko[i].first-L.first;
	}
	init();
	for(ll i=1;i<=totS;i++) add(Slavko[i].second+PY,Slavko[i].second);
	for(ll i=1;i<=totS;i++){
		pair<ll,ll> L=query(Slavko[i].second+PY);
		ansS+=L.second*Slavko[i].second-L.first;
	}
	cout<<ansS/2;
	return 0;
}
```

---


# [Cnoi2021] 未来试题

## 题目背景

在 Cnoi2021 验题查重环节中，Cirno 发现在遥远的未来，2077 年蚯蚓科技大学（某不知名外界学校）的新生赛中的一道题竟然意外地与这套试题的某题有着 $9\%$ 的相似度。

>给你一个正整数 $n$，求等概率生成一个长度为 $n$ 的全排列时，全排列中逆序对数量的期望在$\bmod 10^9+7$ 的意义下的答案。（2077-xidian-freshman-online Problem.D）

答案显然是 $\frac{n(n-1)}{4}$。

作为算术天才，Cirno 一眼就看了出来。

但无需担忧，与未来试题相撞不算撞题，所以这道题便出现在了你的面前。

## 题目描述

给你两个正整数 $n,k$。

对 $\forall i \in [0,k)$，求等概率生成一个长度为 $n$ 的全排列时，全排列中逆序的个数对 $k$ 取模后，余数为 $i$ 的概率，答案对 $998244353$ 取模。


## 说明/提示



**样例解释**

|逆序对数|排列|
|-----|-----|
|0|$(1,2,3,4)$|
|1|$(1,2,4,3)(1,3,2,4)(2,1,3,4)$|
|2|$(1,3,4,2)(1,4,2,3)(2,1,4,3)(2,3,1,4)(3,1,2,4)$|
|3|$(1,4,3,2)(2,3,4,1)(2,4,1,3)(3,1,4,2)(3,2,1,4)(4,1,2,3)$|
|4|$(2,4,3,1)(3,2,4,1)(3,4,1,2)(4,1,3,2)(4,2,1,3)$|
|5|$(3,4,2,1)(4,2,3,1)(4,3,1,2)$|
|6|$(4,3,2,1)$|

**数据范围**

对于 $100\%$ 的数据保证 $1\le n\le 10^5$，$2\le k\le1000$。

## 样例 #1

### 输入

```
4 5```

### 输出

```
166374059 166374059 457528662 748683265 457528662```

# 题解

## 作者：SpeMars (赞：13)

这道题显然是DP我们可以考虑设 $ f_{i,j} $ 表示 $ [1,i] $ 的排列中逆序对个数 $ \bmod \ k$ 为 $ j $ 时的排列个数。

那么我们不难想出一个比较简单的转移。

我们可以考虑往后更新(因为比较好打)

为什么呢，其实很~~简单~~。

我们考虑放入一个新的数，前面 $i-1$ 个数的排列我们完全不用管。

我们插入的这个数 $i$ 一定是最大的，那么这个数对逆序对数量的贡献就为：

这个数 $i$ 插入到排列 $[1,i-1]$ 中它后面有多少个数。

所以一个 $i$ 插入到 $[1,i-1]$ 的排列中最多可以贡献 $i-1$ 对逆序对。

最少则 $0$ 对，我们令 $l$ 为插入 $i$ 后新产生的逆序对个数。

然后就能推出 $ f_{i+1,(j+l)\bmod k} = f_{i+1,(j+l)\bmod k} + f_{i,j}$

所以就有了一个 $ O(n^2k)$ 的做法……

```cpp
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+10,K=1e3+10,mod=998244353;
int n,k,f[N][K],invjc=1;
int fpow(int x,int y){
	int sum=1;
	for(;y;y>>=1ll){
		if(y&1ll)sum=(sum*x)%mod;
		x=(x*x)%mod;
	}
	return sum;
}
int inv(int x){return fpow(x,mod-2);}
signed main(){
	scanf("%lld%lld",&n,&k);
	f[1][0]=1;
	for(int i=2;i<=n;++i)invjc=(invjc*i)%mod;
	invjc=inv(invjc);
	for(int i=1;i<n;++i){
		for(int j=0;j<k;++j){
			for(int l=0;l<=i;++l){
				f[i+1][(j+l)%k]=(f[i+1][(j+l)%k]+f[i][j])%mod;
			}
		}
	}
	for(int i=0;i<k;++i)printf("%lld ",(f[n][i]*invjc)%mod);
	puts("");
	return (0^0);
}
```

~~稳稳地T飞了~~

所以我们可以开始考虑优化。

## 空间

对于这种只由前一层更新过来的我们通常会使用滚动数组。

这样空间就不会炸了。(好像不开没炸？？？)

## 时间

我们尝试~~提高代码复杂度~~将DP的转移从从前往后更新改为从由前面转移。

会麻烦一些，我们先定义下限 $d=(j-i+1)\bmod k$

那么我们会推出以下转移方程

当$ d \le j $ 时 只要 $ d \le x \le j $ 时 $ f_{i-1,x} $ 是可以更新到 $ f_{i,j} $ 的。

因为如上文所述，每次插入的 $i$ 可以至多产生 $i-1$ 个逆序对。

最少则为 $0$ 个。

所以在这个下限 $d$ 到上限 $j$ 这个范围内都是可以更新过来的。

为什要考虑 $d$ 的大小呢？

因为 这个 $d$ 是 $ \bmod \ k $ 意义下的，所以原始可能为负，

那么 $d$ 就会大于 $j$ 。

此时当 $ d \le x < n $ 时 $ f_{i-1,x} $ 也是对 $ f_{i,j} $ 有贡献的。

但是还有 $ 0 \le x \le j$ 的这一部分，我们也要算上。

综上所述，我们要两种讨论去转移。

然后就有了DP由前面转移的版本。

```cpp
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
const int K=1e3+10,mod=998244353;
int n,k,f[2][K],invjc=1;
int fpow(int x,int y){
	int sum=1;
	for(;y;y>>=1ll){
		if(y&1ll)sum=(sum*x)%mod;
		x=(x*x)%mod;
	}
	return sum;
}
int inv(int x){return fpow(x,mod-2);}
signed main(){
	scanf("%lld%lld",&n,&k);
	f[1][0]=1;
	for(int i=2;i<=n;++i)invjc=(invjc*i)%mod;
	invjc=inv(invjc);
	for(int i=2;i<=n;++i){
		int u=(i&1),v=(u^1);
		for(int j=0;j<k;++j){
			int d=((j-i+1)%k+k)%k;
			if(d<=j)for(int l=d;l<=j;++l)f[u][j]=(f[u][j]+f[v][l])%mod;
			else{
				for(int l=d;l<k;++l)f[u][j]=(f[u][j]+f[v][l])%mod;
				for(int l=0;l<=j;++l)f[u][j]=(f[u][j]+f[v][l])%mod;
			}
		}
		for(int j=0;j<k;++j)f[v][j]=0;
	}
	for(int i=0;i<k;++i)printf("%lld ",(f[(n&1)][i]*invjc)%mod);
	puts("");
	return (0^0);
}
```

~~居然有分！！！~~

其实时间复杂度还是 $ O(n^2k) $ 但是这样就可以方便我们优化了。

我们发现每次 $ f_{i,j} $ 的转移都是由连续的一段或两段的上一次的DP值转移的。

所以我们搞一个前缀和优化，每次转移就是 $O(1)$ 的了！

但是由于取模常数很玄学~~ex~~。

这样带滚动数组的 $ O(nk) $ 做法过不了……

所以我打表发现了一个规律。

当 $ n \ge k $ 时，所有值的答案都为 $ 1/k $ 所以这样 $ O(nk) $ 做法就蜕变为 $ O(k^2) $ 做法啦！！！

取模常数啥的就基本没问题了！

然后就可以欢乐AC了！

# AC code

```cpp
#include<cstdio>
#include<iostream>
#define int long long
using namespace std;
const int K=1e3+10,mod=998244353;
int n,k,f[2][K],g[2][K],invjc=1;
int fpow(int x,int y){
	int sum=1;
	for(;y;y>>=1ll){
		if(y&1ll)sum=(sum*x)%mod;
		x=(x*x)%mod;
	}
	return sum;
}
int inv(int x){return fpow(x,mod-2);}
signed main(){
	scanf("%lld%lld",&n,&k);
	if(n>k){
		n=inv(k);
		for(;k--;)printf("%lld ",n);
		puts("");
		return (0^0);
	}
	f[1][0]=g[1][0]=1;
	for(int i=1;i<k;++i)g[1][i]=1;
	for(int i=2;i<=n;++i)invjc=(invjc*i)%mod;
	invjc=inv(invjc);
	for(int i=2;i<=n;++i){
		int u=(i&1),v=(u^1);
		for(int j=0;j<k;++j){
			int d=((j-i+1)%k+k)%k;
			if(d<=j){
				if(d==0)f[u][j]=(g[v][j])%mod;
				else f[u][j]=((g[v][j]-g[v][d-1])%mod+mod)%mod;
			}
			else{
				f[u][j]=((g[v][k-1]-g[v][d-1])%mod+mod)%mod;
				f[u][j]=(f[u][j]+g[v][j])%mod;
			}
			if(j==0)g[u][j]=f[u][j];
			else g[u][j]=(g[u][j-1]+f[u][j])%mod;
		}
	}
	for(int i=0;i<k;++i)printf("%lld ",(f[(n&1)][i]*invjc)%mod);
	puts("");
	return (0^0);
}
```

小小的提示：

注意负数取模和最后乘上全排列总数的逆元。

祝A ~~(看到这了还不点赞吗QWQ)~~

---

## 作者：EnofTaiPeople (赞：3)

考场上秒掉了这道题，来写篇题解，首先这道题要将阶乘逆元打表，因为要求组合数和有理数取余，参考这两道模板：[P5431](/problem/P5431)，[P2613](problem/P2613)。

接下来可以进行线性 dp，使用差分优化，滚动数组（不滚也可以），每次递推时整个的 k 可以视为全局加一，剩余的在差分数组上直接修改即可，最后将差分数组转换为实际数组。

具体实现，记 $md=i\bmod k,cd=i/k$，减少常数，$f$ 数组为上一状态，$g$ 数组为这一次状态的差分数组（循环末尾将 $g$ 数组转换为 $f$ 数组）。对于 $0\le b<k$ 都会对下一状态造成 $cd\times f[b]$ 的影响，对于剩余的余数，只对 $b-(b+md)\bmod k$ 的数字造成 $f[b]$ 的影响，于是考场 AC 代码就出来啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=998244353;
typedef long long ll;
char buf[N+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline void read(int &x){
	x=0;while(!isdigit(c=gc));
	do x=x*10+c-'0';while(isdigit(c=gc));
}
inline ll qp(ll a,int x){
	ll bs=a;
	for(a=1;x;x>>=1){
		if(x&1)a=a*bs%M;bs=bs*bs%M;
	}return a;
}
int n,k,md,cd;
ll f[N],g[N],jc;
int main(){
	read(n),read(k);int a,b,d;
	for(a=jc=1;a<=n;++a)jc=jc*a%M;jc=qp(jc,M-2);f[0]=1;
	for(a=1;a<n;++a){
		if(++md==k)md=0,++cd;
		for(b=0;b<k;++b){
			g[0]=(g[0]+f[b]*cd)%M;d=b+md;if((g[b]+=f[b])>=M)g[b]-=M;
			if(d<k){if((g[d+1]-=f[b])<0)g[d+1]+=M;}
			else{
				if((g[0]+=f[b])>=M)g[0]-=M;
				if((g[d-k+1]-=f[b])<0)g[d-k+1]+=M;
			}
		}
		for(f[0]=g[0],g[0]=0,b=1;b<k;g[b++]=0)
			if((f[b]=f[b-1]+g[b])>M)f[b]-=M;
	}
	for(b=0;b<k;++b)printf("%lld ",f[b]*jc%M);
	return 0;
}
```

---

## 作者：TheShuMo (赞：0)

~~OJ远古题，甚至加了点无关紧要的数据范围~~

## 题目分析

很大的直接算似乎很困难，考虑从小到大一个个加入数。

注意到加入一个数 $a$ 时，$a$ 大于任意当前数列中的数，那么其加入在数列的第 $i$ 位时，就会产生 $n-i$ 个逆序对（因为其后面的数都小于它）。

然后，由于是等概率生成的所有字符串，有其插入所有位置的概率都相同。

定义 $f_{i,j}$ 表示当前插入 $i$ 逆序对数模 $k$ 为 $j$ 的概率。

那么我们有
$$
f_{i,j} = \frac{\sum\limits_{l=0}^{l-1} f_{i-1,(j+l \bmod k)}}{i}
$$

直接转移是 $O(nk^2)$ 的，空间复杂度也是 $O(nk)$。

发现每次取到贡献的都是一段连续区间。容易滚动数组加上前缀和优化到时间复杂度 $O(nk)$，空间复杂度 $O(n)$。

足以通过此题。
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define fi first
#define se second
#define PII pair<int,int>
namespace IO {
    #define gh getchar
    inline int read(){char ch=gh();int x=0;bool t=0;while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();return t?-x:x;}
    inline char getc(){char ch=gh();while(ch<'a'||ch>'z') ch=gh();return ch;}
    inline void write(int x){if(x < 0){putchar('-');x = -x;}if(x > 9){write(x / 10);}putchar((x % 10 + '0'));}
}
using namespace IO;
using namespace std;
#define Tp template<typename T>
#define Ts template<typename T,typename... Ar>
namespace Debug{
	Tp void _debug(char* f,T t){cerr<<f<<'='<<t<<endl;}
	Ts void _debug(char* f,T x,Ar... y){while(*f!=',') cerr<<*f++;cerr<<'='<<x<<",";_debug(f+1,y...);}
	#ifdef LOCAL
	#define gdb(...) _debug((char*)#__VA_ARGS__,__VA_ARGS__)
	#else                                               
	#define gdb(...) void()
	#endif
}using namespace Debug;
const int Maxn = 1e5 + 10, mod = 998244353;
int a[Maxn];
int qPow(int a, int b = mod - 2){
    int res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
int f[2][Maxn];
int s[Maxn];
int qry(int l, int r){
    if(l > r) return 0;
    if(l < 0) return 0;
    return s[r] - (l == 0 ? 0 : s[l - 1]);
}
signed main(){
    int n = read(), k = read();
    if(k <= n){
        int x = qPow(k, mod - 2);
        gdb(k, x);
        for(int i = 1; i <= k; i++) cout << x << ' ';
    }else {
        f[0][0] = 1;
        
        s[0] = f[0][0];
            for(int j = 1; j < k; j++) s[j] = s[j - 1] + f[0][j];
        for(int i = 1; i <= n; i++){
            gdb(i);
            for(int j = 0; j < k; j++){
                gdb(j);
                int sm = 0;
                //0 ~ (i - 1)
                int lft = j;
                int rgt = k - (i - lft) + 1;
                if(j > (i - 1)){
                    f[i%2][j] = qry(j - i + 1, j);
                    gdb(j-i+1,j, qry(j - i + 1, j));
                }else {
                    f[i%2][j] = qry(0, j) + qry(rgt,k-1);
                    gdb(lft,rgt);
                }
                f[i%2][j] %= mod;
                f[i%2][j] = f[i%2][j] * qPow(i) % mod;
            }
            s[0] = f[i % 2][0];
            for(int j = 1; j < k; j++) s[j] = s[j - 1] + f[i % 2][j];
            
        }
            for(int j = 0; j < k; j++)
                cout << f[n%2][j] << ' ';
    }
}
```

---

## 作者：yanbinmu (赞：0)

## P8107 [Cnoi2021] 未来试题

## 分析

考虑概率的转移不方便，所以我们考虑方案数。

首先我们可以暴力枚举每一种排列，但是这道题好像没有这个部分分。

我们考虑是否可以进行动态规划。

对于一个 $dp_i$ 我们发现我们要考虑两个内容：

1. 有哪些可能的逆序对个数；
2. 产生某一个**逆序对个数**的方案数。

如果有两个要维护的内容，我们不容易考虑最优性问题，所以我们可以将其中一维放入状态中。

这里我们显然将逆序对个数放入状态更优。

那我们就有了状态，我们用 $i$ 表示枚举到了前 $i$ 个，则 $\displaystyle dp_{i, x}$ 表示前 $i$ 个数全排列，全排列中逆序的个数对 $k$ 取模后，余数为 $x$ 的方案数。

那我们可以怎么转移呢？

首先，我们发现如果我们有了前 $i - 1$ 的全排列，如果我再加入一个数 $i$，那他一定比其中任意一个数都大，那我们可以考虑将 $i$ 插到哪里，他会比后面的数都大，所以后面有多少个数，我们会多出来多少对逆序对，我们就可以枚举第 $i$ 个数插到哪里，然后更新答案。

时间复杂度：$O(n^2k)$

空间给的比较小，我们挂一个滚动数组。

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int Mod = 998244353;
const int N = 1e5;

int qpow(int a, int b) {
	int res = 1;
	while(b) {
		if(b & 1) {
			res *= a;
			res %= Mod;
		}
		a *= a;
		a %= Mod;
		b >>= 1;
	}
	return res;
}

int f[2][1005];

signed main() {
	int n, k;
	cin >> n >> k;
	if(n >= k) {
		for(int i = 1;i <= k;i ++ ) {
			cout << qpow(k, Mod - 2) << " " ;
		}
		return 0;
	}
	int fac = 1;
	for(int i = 1;i <= n;i ++ ) {
		fac *= i;
		fac %= Mod;
	}
	fac = qpow(fac, Mod - 2);
	f[1][0] = 1;
	for(int i = 2;i <= n;i ++ ) {
		int u = (i & 1);
		int v = (u ^ 1);
//		cout << u << " " << v << "\n"; 
		for(int j = 0;j < k;j ++ ) {
			for(int l = 1;l <= i;l ++ ) {
				f[u][(j + (i - l)) % k] += f[v][j];
				f[u][(j + (i - l)) % k] %= Mod;
			}
		}
		for(int j = 0;j < k;j ++ ) f[v][j] = 0; // 记得清空！！！
	}
	for(int i = 0;i < k;i ++ ) {
		cout << f[n & 1][i] * fac % Mod << " ";
	}
	return 0;
}
```

时间复杂度爆炸，可以获得 [33pts](https://www.luogu.com.cn/record/191080804)。

我们看看可以怎么优化。

我们发现我们一个状态只会推向 $k$ 个状态，那么我们可以考虑一个状态能推向什么状态，这样我们可以将时间复杂度优化为 $O(nk^2)$。

如果是由 $j$ 推向 $y$，由上面的式子我们可以得出：
$$
y = j + (i - l) \mod k\\
\Rightarrow j = y - (i - l) \mod k
$$
其中 $l \in [1, i]$，所以 $j$ 的下界是 $y - (i - 1) \mod k$，上界是 $y$。

那我们就知道了从哪些状态转移过来，应注意的是，由于取模的原因，下界可能比 $y$ 要大，要特判一下。

时间复杂度：$O(nk^2)$。

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int Mod = 998244353;
const int N = 1e5;

int qpow(int a, int b) {
	int res = 1;
	while(b) {
		if(b & 1) {
			res *= a;
			res %= Mod;
		}
		a *= a;
		a %= Mod;
		b >>= 1;
	}
	return res;
}

int f[2][1005];

signed main() {
	int n, k;
	cin >> n >> k;
	if(n >= k) {
		for(int i = 1;i <= k;i ++ ) {
			cout << qpow(k, Mod - 2) << " " ;
		}
		return 0;
	}
	int fac = 1;
	for(int i = 1;i <= n;i ++ ) {
		fac *= i;
		fac %= Mod;
	}
	fac = qpow(fac, Mod - 2);
	f[1][0] = 1;
	for(int i = 2;i <= n;i ++ ) {
		int u = (i & 1);
		int v = (u ^ 1);
//		cout << u << " " << v << "\n"; 
		for(int j = 0;j < k;j ++ ) {
			int d = ((j - i + 1) % k + k) % k; // d ~ j
			if(d <= j) {
				for(int l = d;l <= j;l ++ ) {
					f[u][j] += f[v][l]; 
					f[u][j] %= Mod;
				}
			}
			else {
				for(int l = d;l < k;l ++ ) {
					f[u][j] += f[v][l];
					f[u][j] %= Mod;
				}
				for(int l = 0;l <= j;l ++ ) {
					f[u][j] += f[v][l];
					f[u][j] %= Mod;
				}
			}
		}
		for(int j = 0;j < k;j ++ ) f[v][j] = 0;
	}
	for(int i = 0;i < k;i ++ ) {
		cout << f[n & 1][i] * fac % Mod << " ";
	}
	return 0;
}
```

获得 [67pts](https://www.luogu.com.cn/record/191050945)。

再次发现，我们每次都是由一整段的东西之和转移给过来，我们可以用前缀和优化。

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int Mod = 998244353;
const int N = 1e5;

int qpow(int a, int b) {
	int res = 1;
	while(b) {
		if(b & 1) {
			res *= a;
			res %= Mod;
		}
		a *= a;
		a %= Mod;
		b >>= 1;
	}
	return res;
}

int f[2][1005];
int sum[2][1005];

signed main() {
	int n, k;
	cin >> n >> k;
	if(n >= k) {
		for(int i = 1;i <= k;i ++ ) {
			cout << qpow(k, Mod - 2) << " " ;
		}
		return 0;
	}
	int fac = 1;
	for(int i = 1;i <= n;i ++ ) {
		fac *= i;
		fac %= Mod;
	}
	fac = qpow(fac, Mod - 2);
	f[1][0] = 1;
	for(int j = 0;j < k;j ++ ) {
		sum[1][j] = sum[1][j - 1] + f[1][j];
	}
	for(int i = 2;i <= n;i ++ ) {
//		sum[i][0] = 0;
		int u = (i & 1);
		int v = (u ^ 1);
//		cout << u << " " << v << "\n"; 
		
		for(int j = 0;j < k;j ++ ) {
			int d = ((j - i + 1) % k + k) % k; // d ~ j
			if(d <= j) {
//				for(int l = d;l <= j;l ++ ) {
//					f[u][j] += f[v][l]; 
//					f[u][j] %= Mod;
//				}
				f[u][j] += sum[v][j] - sum[v][d - 1];
				f[u][j] %= Mod;
			}
			else {
//				for(int l = d;l < k;l ++ ) {
//					f[u][j] += f[v][l];
//					f[u][j] %= Mod;
//				}
//				for(int l = 0;l <= j;l ++ ) {
//					f[u][j] += f[v][l];
//					f[u][j] %= Mod;
//				}
				f[u][j] += sum[v][k - 1] - sum[v][d - 1];
				f[u][j] %= Mod;
				f[u][j] += sum[v][j];
				f[u][j] %= Mod;
			}
			sum[u][j] = sum[u][j - 1] + f[u][j];
            sum[u][j] %= Mod;
		}
		for(int j = 0;j < k;j ++ ) f[v][j] = 0;
	}
	for(int i = 0;i < k;i ++ ) {
		cout << f[n & 1][i] * fac % Mod << " ";
	}
	return 0;
}
```

时间复杂度：$O(nk)$。

但是会 T 一个点。

再考虑优化，我们回归原始，考虑加入一个数时逆序对数的变化，同上文所言，他会多出插入位置后面的元素个数个逆序对。

若设 $p_{n,i}$ 表示在 $n$ 个元素的排列中，逆序数 $\mod n$ 等于 $i$ 的方案数，则：
$$
p_{n,i} = \sum_{j=0}^{k - 1} p_{n-1, ((i - k) \mod n)} \cdot \frac{1}{n}
$$

因为 $n \leq k$，则我们将复杂度转化为 $O(k^2)$。

完结撒花！

---

## 作者：int08 (赞：0)

## 前言
How I found this problem:

"[P8107 - onoken](https://music.163.com/#/song?id=29734684)"

# Solution

看到这道题目，考虑动态规划。

设 $dp_{i,j}$ 表示排列中有 $i$ 个数，逆序对数量模 $k$ 为 $j$ 的概率。

我们考虑排列第 $i$ 个数的贡献，由于排列随机，发现第 $i$ 位在前 $i$ 位中的排名是在 $1$ 到 $i$ 中等概率随机的，产生 $0$ 到 $i-1$ 个逆序对的概率相等。

于是依照这个枚举第 $i$ 位在前 $i$ 位中的排名，复杂度 $O(n^2k)$，空间复杂度 $O(k)$（滚动数组优化）。

接着又发现每次产生的逆序对数模 $k$ 的值才重要，这个是好计算的，于是不用枚举排名了，复杂度变为 $O(nk^2)$。

猜测复杂度是 $O(nk)$ 尝试继续优化。

发现一个重要的事情：“每次产生的逆序对数模 $k$ 的值”这个序列是有性质的，具体来说，形如前面一段 $x+1$ 后面一段 $x$，所以转移系数序列形如一段加 $(x+1)·dp_{i,j}$，一段加 $x·dp_{i,j}$，是两个区间加（被模 $k$ 截断会变成三个），于是考虑差分一下，最后计算前缀和就好啦，复杂度 $O(nk)$，大概可以通过了。

不过还有优化：当 $i$ 是 $k$ 倍数时候的转移很奇妙：$0$ 到 $k-1$ 系数相等，这样转移一次之后各项概率就相等了，容易发现之后只会一直相等，就是 $\frac{1}{k}$。

于是当 $n\ge k$ 直接输出，复杂度变成了 $O(k^2)$，通过了。

注意实现的时候将概率改为求方案数，最后再除以总方案数得到概率。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 998244353
#define int long long
int qp(int x,int y)
{
	int ans=1;
	for(int i=1,j=x;i<=y;i*=2,j=j*j%mod) if(i&y) ans=ans*j%mod;
	return ans;
}
#define N 1145
int n,k,od[N],nw[N],in=1,i,j;
signed main()
{
	cin>>n>>k;
	od[0]=1;
	if(n>=k)
	{
		for(i=1;i<=k;i++) cout<<qp(k,mod-2)<<" ";
		return 0;
	}
	for(i=2;i<=n;i++) in=in*qp(i,mod-2)%mod;
	for(i=2;i<=n;i++)
	{
		for(j=0;j<k;j++)
		{
			int l=j,r=(j+i-1)%k;
			if(r>l) (nw[l]+=od[j])%=mod,(nw[r+1]-=od[j]-mod)%=mod;
			else (nw[l]+=od[j])%=mod,(nw[0]+=od[j])%=mod,nw[r+1]=(nw[r+1]-od[j]+mod)%mod;
		}
		for(j=1;j<k;j++) (nw[j]+=nw[j-1])%=mod;
		for(j=0;j<k;j++) od[j]=nw[j],nw[j]=0;
	}
	for(i=0;i<k;i++) cout<<(od[i]*in)%mod<<" ";
}
```
# The End.

---

## 作者：Sakura_xyz (赞：0)

### 题目描述

给定两个正整数 $n,k$ 。对 $\forall i \in [0,k)$ ，求等概率生成一个长度为 $n$ 的全排列时，全排列中逆序的个数对 $k$ 取模后，余数为 $i$ 的概率。

### 分析

看到这道题后，有一个暴力做法是显然的，设 $dp_{i,j}$ 为生成长度为 $i$ 的序列时，逆序对个数对 $k$ 取模后余数为 $j$ 的概率。

则有以下转移：

$dp_{i,j}=\frac{1}{i}\sum_{l=0}^{i-1}dp_{i-1,(j-l)\bmod{k}}$

给出这个转移的解释：我们考虑这样一件事情，对于一种长度为 $i$ ，逆序对个数为 $j$ 的全排列序列，移去数字 $i$ 后，所减少的逆序对数量可能有 $0,1,... ,(i-1)$ 个。因为在这个序列中， $i$ 是最大的数字，其与所有序列中在其后面的元素均可以构成逆序对，而 $i$ 在每个位置的概率均为 $\frac{1}{i}$ ，因此，转移方程成立。

代码如下：

```cpp
dp[1][0]=1;
for(int i=2;i<=n;i++){
	for(int j=0;j<k;j++){
		dp[i][j]=0;
		for(int l=0;l<i;l++){
			dp[i][j]+=dp[i-1][((j-l)%k+k)%k];
			dp[i][j]%=mod;
		}
		dp[i][j]=(dp[i][j]*(inv[i])%mod;
	}
}
```
可以发现，这个转移的时间复杂度是 $O(n^{2}k)$ 的，显然不能通过本题，我们考虑可以在此基础上进行优化。

### 优化

一个很显然的优化是：

我们发现，一个很显然的事情是：$\forall j \in [0,k)$ ,在对于 $l$ 的遍历时，都被至少算了 $\lfloor \frac{i}{k} \rfloor$ 次。

而同理可得，对于剩余的不满一次的遍历，也一定构成一个连续的区间。

因此，我们可以对于每一个 $i$ ,考虑维护一个 $dp_{i}$ 的前缀和，转移时分类讨论即可。转移中的细节比较多，需多加注意。

这样，时间复杂度就是 $O(nk)$ ，可以通过本题。

### 细节
* 在 $n\geq k$ 时，每种情况出现的概率显然均为 $\frac{1}{k}$ ，直接输出即可，这样，我们成功地将 $n,k$ 降到了同一个数量级。

* 很显然，这个转移可以使用滚动数组进行优化，避免空间复杂度的爆炸。

### AC代码

```cpp
#include<iostream>
#include<cstdio>
#define int long long

using namespace std;

const int mod=998244353;

int dp[2][1001]={},sum[2][1001]={},inv[100001]={};

signed main(){
	int n,k,tmp,t1,t2;
	scanf("%lld%lld",&n,&k);
	if(n>k) n=k;
	dp[1][0]=1;
	for(int i=0;i<k;i++) sum[1][i]=1;
	inv[1]=1; for(int i=2;i<=n;i++) inv[i]=(inv[mod%i]*(mod-mod/i))%mod;
	for(int i=2;i<=n;i++){
		for(int j=0;j<k;j++){
			dp[i&1][j]=0; sum[i&1][j]=0;
			dp[i&1][j]=((i/k)*sum[(i-1)&1][k-1])%mod;
			if(j>=(i%k)){
				dp[i&1][j]+=((sum[(i-1)&1][j]-sum[(i-1)&1][j-(i%k)])%mod+mod)%mod;
				dp[i&1][j]%=mod;
			}
			else{
				t1=j+1,t2=i%k-1;
				dp[i&1][j]+=((sum[(i-1)&1][((j-t1)%k+k)%k]-sum[(i-1)&1][((((j-t2)%k+k)%k-1)%k+k)%k])%mod+mod)%mod;
				dp[i&1][j]%=mod;
				dp[i&1][j]+=sum[(i-1)&1][j]; dp[i&1][j]%=mod;
			}
			dp[i&1][j]%=mod;
			dp[i&1][j]=(dp[i&1][j]*inv[i])%mod;
			sum[i&1][j]=dp[i&1][j]; if(j) sum[i&1][j]+=sum[i&1][j-1];
			sum[i&1][j]%=mod;
		}
	}
	for(int i=0;i<k;i++) printf("%lld ",dp[n&1][i]);
	return 0;
}
```


---

## 作者：zhouyuhang (赞：0)

~~给一种 OEIS 解法~~

首先不管模 $k$ 的限制，直接把样例解释里的逆序对数扔到 OEIS 上，我们发现这个玩意儿的 GF 是：
$$\prod_{i=1}^n\sum_{j=1}^ix^j$$
然后考虑怎么算。由于乘出来的式子的项数是 $n^2$ 数量级的，因此任何多项式做法都不用想了。于是我们考虑把模 $k$ 的限制拿回来做 dp。$f_{i,j}$ 表示在第 $i$ 个因式处，所有次数模 $k$ 余 $j$ 的项的系数和。于是直接写出转移方程：
$$f_{i,j}=\sum_{l=1}^i f_{i-1,(j-l)\bmod k}$$
然而暴力转移的复杂度是 $O(nk^2)$，显然不行。所以我们需要加速转移过程。不难发现，$\sum\limits_{l=1}^if_{i-1,(j-l)\bmod k}$ 的第二维是在模意义下是连续的。因此你维护一个前缀和，就把复杂度压到 $O(nk)$ 了。关于空间，上个滚动数组压掉第一维即是 $O(k)$。具体见 Code：
```cpp
dp[0][0] = 1;
for(int i = 1; i <= k; ++i) sum[0][i] = 1;
for(int i = 1; i < n; ++i){
	int t = (i & 1), p = i % k;
	sum[t][0] = 0;
	for(int j = 0; j < k; ++j){
		dp[t][j] = sum[t ^ 1][k] * (i / k) % MOD;
		if(j >= p) dp[t][j] = (dp[t][j] + sum[t ^ 1][j + 1] - sum[t ^ 1][j - p]) % MOD;
		else dp[t][j] = (dp[t][j] - sum[t ^ 1][j - p + k] + sum[t ^ 1][j + 1] + sum[t ^ 1][k] + MOD) % MOD;
		sum[t][j + 1] = (sum[t][j] + dp[t][j]) % MOD;
	}
}
```
最后，统计答案时不要忘了乘上 $n!$ 的逆元。

upd：其实这个 GF 是我自己推出来的。本质上它就是在枚举每一位所选的数与之前的相对大小关系，因此直接 dp 也没有任何问题。~~不过假托 OEIS 之手更有意思~~

---


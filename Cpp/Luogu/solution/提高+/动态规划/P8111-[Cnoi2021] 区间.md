# [Cnoi2021] 区间

## 题目背景

Cirno 有一个区间 $[a,b](1\le a \le b \le n)$，而你的任务是在规定的次数内帮 Rumia 猜出这个区间。

每次，你可向 Cirno 询问一个数字 $k$，而 Cirno 会告诉你这个数字与区间 $[a,b]$ 的关系。

## 题目描述

为了猜到这个区间，你需要实现一个函数 `std::pair<int,int> Guess(int n,int c)`，这个函数的作用是在不超过 $c$ 次询问中猜对 $[1,n]$ 中的一个子闭区间 $[a,b]$，返回值为你最终确定的区间，以 `std::pair<int,int>` 的形式返回。

你可以调用交互库中一个叫做 `Query` 的函数，其原型为 `int Query(int x)`，返回值为：

 - 若 $x < a$，返回 $-1$。
 - 若 $x \in [a,b]$，返回 $0$。
 - 若 $x > b$，返回 $1$。

你调用 `Query` 函数的次数不超过 $c$ 才能得到这个点的分数，否则这个点为 $0$ 分。有关该函数的调用请参考「说明/提示」部分。

在一个测试点中，你的 `Guess` 函数可能被调用多次，最多不超过 $5000$ 次。为了保证你的程序不会超时，你需要额外实现一个函数 `void init()`，这个函数只会在开始时被交互库调用一次。当然，它的实现可以为空。

由于 Rumia 的编译器只支持 C++，所以你只能使用 C++ 语言（包括 C++，C++11，C++14，C++17）来解决本题。

## 说明/提示

**样例解释**

需要求的区间是 $[2,3]$，区间左右端点可能的范围是 $[1,5]$，你最多猜 $5$ 次。

**数据范围与约定**

对于所有数据保证 $1 \le a \le b \le n$；除 SubtaskExtra 外，保证 $1\le n\le1500$。

**子任务**

Subtask1（$10$ points）：$c=n$。

Subtask2（$30$ points）：$c=30$。

Subtask3（$30$ points）：$c=22$。

Subtask4（$30$ points）：$c=20$。

**附加任务**

SubtaskExtra（$1$ point）：$1\le n\le 10^6$，$c=\lfloor\log_2 n\rfloor+\lfloor\log_2 \frac{4n}{3}\rfloor$。

本题使用 Special Judge，$100$ 与 $101$ 分均视作 Accepted.

**提示**

如果你不知道怎么解决交互题，可以参考[这题](https://www.luogu.com.cn/problem/P1947)。

本题模板程序与模板交互库见附件中的 `SampleProgram.cpp` 与 `SampleInteractor.cpp`。

## 样例 #1

### 输入

```
5 2 3 5```

### 输出

```
2 3 0```

# 题解

## 作者：WYXkk (赞：10)

不困难但非常有意思的题目。

我们先考虑一下，假设第一次调用了 `Query(pos)`：

- 返回 $-1$：最快的方法显然是把 $[1,n-pos]$ 的方法搬到 $[pos+1,n]$ 上。
- 返回 $0$：最快的方法是在 $[1,pos]$ 和 $[pos,n]$ 上分别二分左右端点。(\*)
- 返回 $1$：最快的方法显然是当作 $[1,pos-1]$ 的问题做。

> (\*) 似乎不太显然，此处给出证明：  
> 再调用 `Query(pos)` 已经没有意义；对于 $u<pos$ 调用 `Query(u)` 只能得到待猜区间左端点和 $u$ 的大小关系（大于或小于等于）；对于 $u>pos$ 调用 `Query(u)` 只能得到待猜区间右端点和 $u$ 的大小关系（小于或大于等于）。  
> 这样原问题就变成了两个互不影响的问题（分别猜测左右端点），每个问题都可以用一次询问来得到两种答案之一，因此至少需要 $\lceil\log_2|L|\rceil+\lceil\log_2|R|\rceil$ 次询问，其中 $|L|,|R|$ 表示两个问题的可能解集大小。  
> 这两个问题都是经典二分问题，使用二分恰好能做到上面给出的最小值。因此二分即为最优。

那么，如果记保证能猜对的最小猜测次数为 $f(n)$，显然有：

$f(n)=1+\min\limits_{1\le a\le n}\{\max\{f(a-1),f(n-a),\lceil\log_2a\rceil+\lceil\log_2(n-a+1)\rceil\}\}$

边界条件为  $f(0)=f(1)=0$。

在 `init()` 内如此暴力递推并记录转移位置即可获得 $100$ 分。*我没写这部分做法，不保证这句话正确*

注：$f(1500)=20$。出题人卡的很死（无贬义或辱骂情绪）。

------

那么 $101$ 分做法呢？

上面的递推很难优化，我们应该试图寻找最优转移位置的规律。记 $n$ 的最小最优转移位置为 $p(n)$。

我写了一段打表 js：

```javascript
f=[0,0];
p=[0,1];
for(n=2;n<=99;++n)
{
    f.push(n);p.push(1);
    for(i=1;i<=n;++i)
    {
        c=1+Math.max(Math.ceil(Math.log2(i))+Math.ceil(Math.log2(n-i+1)),f[i-1],f[n-i]);
        if(c<f[n]) f[n]=c,p[n]=i;
    }
}
console.log(p);
```

观察输出结果，规律实在太明显了：

```javascript
[0, 1, 
 1, 
 1, 
 1, 2, 
 1, 2, 
 1, 2, 3, 4, 
 1, 2, 3, 4, 
 1, 2, 3, 4, 5, 6, 7, 8, 
 1, 2, 3, 4, 5, 6, 7, 8, 
 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 
 1, 2, 3, 4]
```

稍微提炼一下，规律可以表示为：对于 $2^m\le n<2^{m+1}$，$p(n)=(n\bmod 2^{m-1})+1$。

*此规律可以和 Bonus 中提到的其他规律使用数学归纳法一起证明。细节由读者补充。*

那么我们就有了 $O(\log n)$ 计算 $p(n)$ 的方法，时间复杂度 $O(T\log^2n)$，显然不会超时。实测可以拿到 $101$ 分。

也可以把 $p(n)$ 搬到 `init()` 内进行线性预处理，时间复杂度 $O(n+T\log n)$。*我没写这部分做法，不保证这句话正确*

------

参考实现：

```cpp
#include <utility>//因为这个 CE 了一次
int Query(int);//因为这个 CE 了第二次
inline int getGuessPosition(int len)//return in [0,len)
{
	int i=0;while(len>>i)++i;
	return len%(1<<(i-2));
}
inline std::pair<int,int> finalGuess(int l,int mid,int r)
{
	int l0,r0,mid0;
	l0=l,r0=mid;
	while(r0>l0)
	{
		mid0=(l0+r0)>>1;
		if(Query(mid0)) l0=mid0+1;else r0=mid0;
	}
	int a=l0;
	l0=mid,r0=r;
	while(r0>l0)
	{
		mid0=(l0+r0)>>1;
		if(Query(mid0+1)) r0=mid0;else l0=mid0+1;
	}//这两个二分实际上可以写一起
	int b=l0;
	return std::make_pair(a,b);
}
std::pair<int,int> guess(int l,int r)
{
	if(l==r) return std::make_pair(l,r);
	int pos=l+getGuessPosition(r-l+1);
	int ret=Query(pos);
	if(ret==-1) return guess(pos+1,r);
	if(ret==0) return finalGuess(l,pos,r);
	return guess(l,pos-1);//一开始 1 和 -1 应该执行的操作写反了一次
}
std::pair<int,int> Guess(int n,int c)
{
	return guess(1,n);
}
void init(){}
```

------

Bonus：$f(n)$ 的表达式

用上面那段程序计算 $f(n)$，规律也很明显：

```javascript
[0, 0, 
 2,
 3,
 4, 4,
 5, 5,
 6, 6, 6, 6,
 7, 7, 7, 7,
 8, 8, 8, 8, 8, 8, 8, 8,
 9, 9, 9, 9, 9, 9, 9, 9,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 13, 13, 13, 13]
```

也就是：对于 $2^m\le n<2^{m+1}$，$f(n)=2m+[n\ge3\cdot2^{m-1}]$。

容易发现 $m+[n\ge3\cdot2^{m-1}]$ 可以表示为 $\lfloor\log_2\frac{4n}3\rfloor$，因此 $f(n)=\lfloor\log_2n\rfloor+\lfloor\log_2\frac{4n}3\rfloor$，与题目中的表达式一致。出题人你卡的真死（无贬义或辱骂情绪）。

------

Bonus Bonus：所有最优转移位置

上面我们只计算了最小最优转移位置，那么所有最优转移位置是个什么情况呢？

我们用 $P(n)$ 代表 $n$ 的所有最优转移位置构成的集合。

仍然使用上面那段程序，计算结果我使用 Excel 可视化了一下：

![148.png](https://s2.loli.net/2022/02/05/iaB3Myjm58blrdx.png)

标灰代表此位置不存在，标黑代表这是最优转移位置，标白代表这不是最优转移位置。

稍微提炼一下：对于$2^m\le n<2^{m+1}$，$1\le i\le n$，$i\in P(n)$ 当且仅当 $(i-1)\bmod 2^{m-1}\ge n\bmod 2^{m-1}$。

结论和图片都很美。

P.S. 可以算出（图形无穷大时）$S=\dfrac{5}{24}a^2$，$a$ 为底边长。



---

## 作者：dingcx (赞：7)

~~赛时本应该拿 $70$ 跑路的。~~

## 思路

### 总体思路

题目说询问一个区间，其实就是询问左右端点。

把左右端点分开考虑，分别**二分**求，每次询问中间点是否在区间内。

这样确定每个点需要询问 $\lceil \log_2 1500 \rceil =11$ 次，共 $22$ 次，能过 $70$ 分。

核心代码（二分）

```cpp
while(l<=r){ //二分求左端点
	mid=(l+r)>>1;
	if(Query(mid)==-1) l=mid+1; //在区间外，偏左
	else r=mid-1,L=mid; //在区间里，偏右，记录答案
}
while(l<=r){ //二分求右端点
	mid=(l+r)>>1;
	if(Query(mid)!=1) l=mid+1,R=mid; //在区间里，偏左，记录答案
	else r=mid-1; //在区间外，偏右
}
```

### 优化 1

首先一步很显然的优化，在求左右端点时第一次询问的点其实是同一个点（也就是整个数组的中间点），所以这次询问的结果可以**共用**。

于是在求左端点的时候，记录一下第一次询问的答案，这样求右端点的第一次询问就可以直接使用记录下的答案省略掉了。

这样可以优化 $1$ 次，变成 $21$ 次。但是还差 $1$ 次。

### 优化 2

这一步优化应该是这道题最巧妙的地方。

观察数据范围：$n \le 1500$，很容易产生疑惑：$2^{10}=1024,2^{11}=2048$，和 $1500$ 都差的很远，为什么数据范围不设成 $1000$ 或 $2000$ 呢？

有了这样的思考，再想目前的 $21$ 次的解法，$21$ 分为第一次公用的和左右端点各 $\lceil \log_2 750 \rceil =10$ 次，也就是 $21=1+\lceil \log_2 750 \rceil+\lceil \log_2 750 \rceil$，观察这个式子，然后~~突然灵光乍现~~发现可以让两边稍微不平均一点，**两边变成 $500$ 和 $1000$**，这样式子变成 $1+\lceil \log_2 500 \rceil+\lceil \log_2 1000 \rceil$，也就等于 $20$ 了。

具体做法，就是第一次询问的点取在左侧 $\frac{1}{3}$ 的位置，就可以做到 $20$ 次了。

但是有一个比较重要的细节，就是左右端点可能都取在有 $1000$ 个数的区间中（也就是都 $> \frac{n}{3}$），就又变成 $21$ 次了，不过这也问题不大，因为既然第一次二分进入相同区间，第二次询问的点又是同一个点，**又可以共用**结果（相当于前面的优化 $1$），就可以优化掉 $1$ 次，变回 $20$ 次了。

## 代码

~~这道题因为月赛的时候各种小细节改了很多遍，码风可能比较难看，大家凑合着看。~~

```cpp
#include<cstdio>
#include<iostream>
#define PII pair<int,int>
using namespace std;
int Query(int x);
void init(){} //用不上
PII Guess(int n,int c){
	int L,R; //大写的 L,R 记录最终答案
	int l=1,r=n,mid=(l+r)/3,nl,nr; //二分变量，nl,nr 是第二次二分的初始值
	int d=Query(mid); //第一次询问共用答案，取在 1/3 处
	if(d==-1) l=mid+1; //缩短第一次二分的区间
	else r=mid-1,L=mid;
	if(d!=1) nl=mid+1,nr=n,R=mid; //缩短第二次二分的区间
	else nr=mid-1,nl=1;
	if(d==-1){ //特判左右端点都在右 2/3 的情况，上面的过程再来一遍
		mid=(l+r)>>1;
		d=Query(mid);
		if(d!=1) nl=mid+1,nr=n,R=mid;
		else nr=mid-1,nl=l;
		if(d==-1) l=mid+1;
		else r=mid-1,L=mid;
	}
	while(l<=r){ //二分求左端点
		mid=(l+r)>>1;
		if(Query(mid)==-1) l=mid+1;
		else r=mid-1,L=mid;
	}
	l=nl,r=nr; //利用优化得到的范围比较小的初始值
	while(l<=r){ //二分求右端点
		mid=(l+r)>>1;
		if(Query(mid)!=1) l=mid+1,R=mid;
		else r=mid-1;
	}
	return make_pair(L,R); //华丽结束
}
```

看完不要忘了点赞~

---

## 作者：enucai (赞：4)

## Preface

给一种不用 Dp 计算最优决策点，直接二分的做法。

## Analysis

分别二分左右两个端点，但是如果直接二分，显然 Subtask4 都过不去。但是考虑为什么每次二分的效率无法达到 $\left\lfloor \log n \right\rfloor$，由于每次查询后范围不是 $\div 2$ 向下取整的，我们称每一次询问后无法将区间大小严格减半的询问（即新区间长度 $>$ 原区间长度 $\div 2$）为冗余的询问。

如果第一次就询问一个 $2$ 的幂次数，就不会有冗余的询问了，效率最高。

但是当 $n=1500$ 是，大于它的第一个数 $2$ 的幂次数是 $2048$，$\log_2 2048=11$，所以确定左右端点各要 $11$ 次询问，共计 $22$ 次询问，还是过不了 Subtask4。

考虑到左右端点分别二分时一开始会有很多重复询问的数，因此只需将询问过的数用 $map$ 进行记录，即可通过此题，实测得分 $101$ 分，[测评记录](https://www.luogu.com.cn/record/68880331)。

## Code

**Talk is cheap, show me the code.**

```cpp
if(n==1) return make_pair(1,1);
int cnt=1;
while(1){
	if((1<<(cnt+1))<n) cnt++;
	else break;
}//寻找大于 n 的最小 2 的幂次数
cnt++;
map<int,int> mp;//用于记录已经询问过的数。
int l=1,r=(1<<cnt),mid,a=-1,b=-1;
while(l<=r){//二分左端点
	mid=(l+r)/2;
	int x;
	if(mid>n) x=1;
	else{
		if(!mp.count(mid)) mp[mid]=Query(mid);
		x=mp[mid];
	}
	if(x==-1) l=mid+1;
	else if(x==0) a=mid,r=mid-1;
	else r=mid-1;
}
l=1,r=(1ll<<cnt),mid;
while(l<=r){//二分右端点
	mid=(l+r)/2;
	int x;
	if(mid>n) x=1;
	else{
		if(!mp.count(mid)) mp[mid]=Query(mid);
		x=mp[mid];
	}
	if(x==-1) l=mid+1;
	else if(x==0) b=mid,l=mid+1;
	else r=mid-1;
}
return make_pair(a,b);
```

---

## 作者：Super_Cube (赞：1)

# Solution

假设 $[a,b]\subseteq[l,r]$，此时询问 $x\in[l,r]$，若返回 $-1$，则 $l\gets x+1$；若返回 $1$，则 $r\gets x-1$；若返回 $0$，则 $a\in[l,x],b\in[x,r]$，可通过二分确定 $a,b$ 的具体值。

问题：如何确定 $x$ 的最优取值？

设 $dp_i$ 表示区间长度为 $i$ 时的最少询问次数。依据上述过程可得转移：$dp_i=1+\displaystyle\min_{j=1}^i\{dp_{j-1},dp_{i-j},\lceil\log_2j\rceil+\lceil\log_2(i-j+1)\rceil\}$。那么 $x$ 的最优取值即为 dp 时的最优决策点。

跑下来 $dp_{1500}=20$，恰能通过前四个 Subtask，可获得 100 pts，参考代码如下。

```cpp
#include<bits/stdc++.h>
int Query(int x);
inline int find1(int l,int r){
	int res=r--;
	while(l<=r){
		int mid=l+r>>1,x=Query(mid);
		if(x)l=mid+1;
		else res=mid,r=mid-1;
	}
	return res;
}
inline int find2(int l,int r){
	int res=l++;
	while(l<=r){
		int mid=l+r>>1,x=Query(mid);
		if(x)r=mid-1;
		else res=mid,l=mid+1;
	}
	return res;
}
int id[1501];
std::pair<int,int> Guess(int n,int c){
	if(n==1)return std::pair<int,int>(1,1);
	int l=1,r=n,x,y;
	while(true){
		y=Query(x=l+id[r-l+1]-1);
		if(y==-1)l=x+1;
		else if(y)r=x-1;
		else break;
	}
	return std::pair<int,int>(find1(l,x),find2(x,r));
}
int dp[1501];
void init(){
	id[1]=1;
	for(int i=2;i<=1500;++i){
		dp[i]=0x3f3f3f3f;
		for(int j=1;j<=i;++j)
			if(dp[i]>std::max(std::max(dp[j-1],dp[i-j]),std::__lg(j)+(__builtin_popcount(j)!=1)+std::__lg(i-j+1)+(__builtin_popcount(i-j+1)!=1)))
				dp[i]=std::max(std::max(dp[j-1],dp[i-j]),std::__lg(j)+(__builtin_popcount(j)!=1)+std::__lg(i-j+1)+(__builtin_popcount(i-j+1)!=1)),id[i]=j;
		++dp[i];
	}
}
```

复杂度瓶颈在于 dp。

尝试对最优决策点打表，发现 $dp_i$ 的最优决策点为 $(i\bmod 2^{\lfloor\log_2i\rfloor-1})+1$。

可以通过 SubtaskExtra，可以获得 101 pts。

注意：特判 $n=1$，此时无需询问，可直接返回答案。

# Code

```cpp
#include<bits/stdc++.h>
int Query(int x);
inline int find1(int l,int r){
	int res=r--;
	while(l<=r){
		int mid=l+r>>1,x=Query(mid);
		if(x)l=mid+1;
		else res=mid,r=mid-1;
	}
	return res;
}
inline int find2(int l,int r){
	int res=l++;
	while(l<=r){
		int mid=l+r>>1,x=Query(mid);
		if(x)r=mid-1;
		else res=mid,l=mid+1;
	}
	return res;
}
inline int id(int n){
	return (n==1?0:(n%(1<<std::__lg(n)-1)));
}
std::pair<int,int> Guess(int n,int c){
	if(n==1)return std::pair<int,int>(1,1);
	int l=1,r=n,x,y;
	while(true){
		y=Query(x=l+id(r-l+1));
		if(y==-1)l=x+1;
		else if(y)r=x-1;
		else break;
	}
	return std::pair<int,int>(find1(l,x),find2(x,r));
}
void init(){}
```

---

## 作者：dingshengyang (赞：1)

我们知道，这道题的思路应该是二分找左右端点。

然而……二分不行，会超限制。

我们有没有办法算的更快呢？

答案是肯定的。

我们查看数据范围，如果 $n \le 1024$，直接莽。

我们否则 ```Query(512)``` 一下：

如果整个区间左端点都在 $512$ 以上，二分右边；

如果整个区间右端点都在 $512$ 以下，二分左边；

否则，说明区间跨越 $512$,两边都二分以下，听天由命吧。

虽然只有 $100$ 分（

```cpp
#include <bits/stdc++.h>
using namespace std;

int Query(int);

void init(){};

int binary_search_for_max(int l, int r) {
  while (l < r) {
    int mid = (l + r + 1) / 2;
    int res = Query(mid);
    if (res == 1)
      r = mid - 1;
    else if (res == 0)
      l = mid;
  }
  return l;
}

int binary_search_for_min(int l, int r) {
  while (l < r) {
    int mid = (l + r) / 2;
    int res = Query(mid);
    if (res == -1)
      l = mid + 1;
    else if (res == 0)
      r = mid;
  }
  return l;
}

pair<int,int> naive_guess(int l, int r) {
  int l1 = l, l2 = r;
  int r1 = l, r2 = r;
  while (l1 < l2) {
    int mid = (l1 + l2) / 2;
    int t = Query(mid);
    if (t == -1)
      l1 = mid + 1;
    else if (t == 0)
      l2 = mid, r1 = max(r1, mid);
    else
      l2 = mid - 1, r2 = mid - 1;
  }
  r1 = max(r1, l1);

  while (r1 < r2) {
    int mid = (r1 + r2 + 1) / 2;
    int t = Query(mid);
    if (t == 0)
      r1 = mid;
    else if (t == 1)
      r2 = mid - 1;
    else
      assert(false);
  }
  return {l1, r1};
}

pair<int,int> Guess(int n, int c) {
  if (n <= 1024)
    return naive_guess(1, n);
  int res = Query(512);
  if (res == 0)
    return {binary_search_for_min(1, 512), binary_search_for_max(512, n)};
  if (res == -1)
    return naive_guess(513, n);
  return naive_guess(1, 511);
}

```

---

## 作者：qzmoot (赞：1)

**大家一定要开始时候就选择自动语言，否则就会像我一样傻傻地找半个小时的错误，呜呜**
# 正题开始
## 题目解读
[传送门](https://www.luogu.com.cn/problem/P8111)

这道题目要求我们通过询问数字与给定区间的关系来猜出这个区间。我们需要实现一个函数

```std::pair<int,int> Guess(int n, int c)```，其中 $n$ 表示区间的范围,$c$ 表示最多询问的次数。函数返回一个```std::pair<int,int>```类型的变量，表示最终确定的区间。

我们可以调用一个名为```Query(int x)```的函数来获取数字与区间的关系，其返回值有三种情况：

若 $x < a$，返回 $-1$

若 $x ∈ [a, b]$，返回 $0$

若 $x > b$，返回 $1$

函数调用次数不得超过 $c$，否则这个点得分为 $0$。

根据题目要求，我们还需要实现一个函数```void init()```，它会在开始时被调用一次，但我们可以空置该函数。

输入和输出的样例已经给出，在样例中，需要猜测的区间是 $[2,3]$，可能的范围是 $[1,5]$，最多可询问 $5$ 次。
## 正式解题
我们进行普通的二分尝试，漂亮，10 分，洗洗睡吧。

还不能停下！我们还没开始优（骗）化（分）呢！
### 优化来了！
我们可以先去求左右端点，在接着看询问的中间点是否在区间。

但是因为查询的都是同一个中间点，所以结果自然可以合并咯。

于是我们直接噼里啪啦写完代码，然后一交。

欸，70 分，我们还是洗洗睡吧。
### 优化又双叒叕来了
我们查看一下这个可恶的复杂度啊，我在上一个优化过后是可以达到 $21$ 次查询的，也就是 $\lceil\log_2750\rceil\times2+1$。

我们知道，在 $20$ 次的时候是可以稳过的，那么该怎么办捏？

此时，我们看到了这个可爱的 $750$，如果这里不是 $750$，那复杂度会变大还是变小呢？

我大概算了一下，在刚好 $500$ 的时候 $1000$，我们的公式 $\lceil\log_2500\rceil+\lceil\log_21000\rceil+1=20$。

（蒟蒻疯狂!!!.jpg）

于是，这个 $500$，刚好是 $1500$ 的三分之一，我们第一次查询时的点定在三分之一处就可以轻松搞定了！
## 代码来了
```cpp
#include<bits/stdc++.h>
using namespace std;

int Query(int x);

void init(){}

pair<int,int> Guess(int n, int c) {
    int L, R;
    int l = 1, r = n, nl, nr;
    
    // 初始猜测位置为区间的三分之一处
    int mid = (l + r) / 3;
    int d = Query(mid);
    
    // 根据与查询数字的关系来调整搜索范围
    if (d == -1) {
        l = mid + 1;
    } else {
        r = mid - 1;
        L = mid;
    }
    
    // 如果查询结果不是1，则将新的搜索范围设为mid+1到n
    if (d != 1) {
        nl = mid + 1;
        nr = n;
        R = mid;
    } else {
        nr = mid - 1;
        nl = 1;
    }
    
    // 第二次查询
    if (d == -1) {
        mid = (l + r) >> 1;
        d = Query(mid);
        
        if (d != 1) {
            nl = mid + 1;
            nr = n;
            R = mid;
        } else {
            nr = mid - 1;
            nl = l;
        }
        
        if (d == -1) {
            l = mid + 1;
        } else {
            r = mid - 1;
            L = mid;
        }
    }
    
    // 二分搜索确定最终区间的左边界
    while (l <= r) {
        mid = (l + r) >> 1;
        
        if (Query(mid) == -1) {
            l = mid + 1;
        } else {
            r = mid - 1;
            L = mid;
        }
    }
    
    l = nl;
    r = nr;
    
    // 二分搜索确定最终区间的右边界
    while (l <= r) {        
        mid = (l + r) >> 1;
        
        if (Query(mid) != 1) {
            l = mid + 1;
            R = mid;
        } else {
            r = mid - 1;
        }
    }
    
    return make_pair(L, R);
}
```
看完之后给偶点个小小的赞吧！

---

## 作者：CodingOIer (赞：0)

## P8111 [Cnoi2021] 区间 题解

### 思路分析

考虑二分。

显然，我们可以二分左端点和右端点。

对于左端点，令 $r$ 为 `Query(mid)` 的返回值：

- $r = -1$，这个点不可能成为答案，左于左端点，将二分的左下界向右移动；
- $r = 0$，这个点有可能成为答案，可能右于左端点，将二分的右上界向左移动；
- $r = 1$，这个点不可能成为答案，右于左端点，将二分的右上界向左移动。

右端点同理。

然后考虑优化。

提交后 $70$ 分，考虑优化。

一个显然的优化是先记录下每一个点询问的答案，但是**在目前阶段**对正确性没有影响。

考虑看看我们的二分所需的次数：
$$
\lceil \log_{2}{n} \rceil + \lceil \log_{2}n \rceil = \lceil \log_{2}1500 \rceil + \lceil \log_{2}1500 \rceil = 21
$$
然后，这个 $1500$ 很扎眼，$\log_{2}{1500} \approx 10.5$，不上不下的。

显然，我们可以把第一个二分 $mid$ 设为 $1000$，这样两个区间的长度就是 $1000$ 和 $500$，$\log_{2}$ 分别是 $9$ 和 $11$，亦可通过此题。

### 代码实现

```cpp
#include <utility>
#include <vector>
int Query(int x);

void init()
{
}

int getMid(int l, int r, int n)
{
    if (l == 1 && r == n)
    {
        return n / 3;
    }
    return (l + r) / 2;
}

int want(std::vector<int> &vis, int x)
{
    return vis[x] == 2 ? vis[x] = Query(x) : vis[x];
}

std::pair<int, int> Guess(int n, int c)
{
    std::vector<int> vis(n + 5, 2);
    int ll, lr;
    int les;
    int rl, rr;
    int res;
    ll = rl = 1;
    lr = rr = n;
    les = -1;
    res = -1;
    for (; ll <= lr;)
    {
        int mid = getMid(ll, lr, n);
        int r = want(vis, mid);
        if (r == 0)
        {
            les = mid;
            lr = mid - 1;
        }
        else if (r == 1)
        {
            lr = mid - 1;
        }
        else if (r == -1)
        {
            ll = mid + 1;
        }
    }
    for (; rl <= rr;)
    {
        int mid = getMid(rl, rr, n);
        int r = want(vis, mid);
        if (r == 0)
        {
            res = mid;
            rl = mid + 1;
        }
        else if (r == -1)
        {
            rl = mid + 1;
        }
        else if (r == 1)
        {
            rr = mid - 1;
        }
    }
    return {les, res};
}

```

---

## 作者：Hanx16Kira (赞：0)

# [Cnoi2021] 区间

[Luogu P8111](https://www.luogu.com.cn/problem/P8111)

## Solution

很妙的一个题。

最简单的方式就是分别二分确定 $l$ 和 $r$，这样询问次数为 $2\lceil\log 1500\rceil=22$，可以获得 70pts。

会发现其实二分 $l$ 和 $r$ 的时候有些询问重复了。因此可以开始的时候询问一次 $\text{mid}$，就可以把 $l$ 和 $r$ 的范围减小一半，这样数量变成了 $21$ 次，还是没法得到 100pts。

假设第一步询问的位置是 $p$，那么可以将答案表示成为 $\lceil\log p\rceil+\lceil\log(n-p)\rceil$，发现 $p=\text{mid}$ 并非是最优的，实际上 $p$ 的位置大概是 $\dfrac 1 3$ 的时候更优，因为 $\lceil\log 500\rceil+\lceil\log 1000\rceil=20$，这样可以得到 100pts，但是因为数据加强了而过不去 Bonus。

个人觉得不是很好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
int Query(int x);
void init() {}
pair<int, int> Guess(int N, int total) {
    if (N == 1) return make_pair(1, 1);
    int L = 1, R = N;
    int l = 1, r = N, mid = (l + r) / 3, nl, nr;
    int d = Query(mid);
    if (d == -1) l = mid + 1;
    else r = mid - 1, L = mid;
    if (d != 1) nl = mid + 1, nr = N, R = mid;
    else nr = mid - 1, nl = 1;
    if (d == -1) {
        mid = (l + r) >> 1;
        d = Query(mid);
        if (d != 1) nl = mid + 1, nr = N, R = mid;
        else nr = mid - 1, nl = l;
        if (d == -1) l = mid + 1;
        else r = mid - 1, L = mid;
    }
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) == -1) l = mid + 1;
        else r = mid - 1, L = mid;
    }
    l = nl, r = nr;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) != 1) l = mid + 1, R = mid;
        else r = mid - 1;
    }
    return make_pair(L, R);
}
```


### Bonus

考虑 DP，设 $f_i$ 表示 $n=i$ 的最小询问次数，那么枚举询问的点 $p$，按照 $p$ 的返回值进行分类讨论。

- 返回 $-1$，那么最优的询问方法一定是 $f_{i-p}$。
- 返回 $1$，那么最优的询问方法一定是 $f_{p-1}$。
- 返回 $0$，那么 $l$ 和 $r$ 相当于是按照 $p$ 分割成了两半，相互独立，因此直接在左侧和右侧二分就是最优解。

也就是：

$$
f_i=\min\limits_{p=1}^i {\Large\{}\max\{f_{p-1},f_{i-p},\lceil\log p\rceil+\lceil\log (i-p+1)\rceil\}{\Large\}}
$$

时间复杂度 $\mathcal O(n^2)$，只需要记录每次 DP 的决策点 $p_i$ 即可获得 100pts。

```cpp
#include <bits/stdc++.h>
#define For(i, a, b) for (int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
int Query(int x);
const int _N = 1500 + 5;
int f[_N], p[_N];
void init() {
    memset(f, 0x3f, sizeof f);
    f[1] = 0, p[1] = 1;
    f[0] = 0, p[0] = 1;
    For(i, 2, 1500) {
        For(j, 1, i) {
            int cnt = ceil(log2(j)) + ceil(log2(i - j + 1));
            int val = max({f[j - 1], f[i - j], cnt}) + 1;
            if (val < f[i])
                f[i] = val, p[i] = j;
        }
    }
}
pair<int, int> Solve2(int L, int R, int pos) {
    int l, r, mid;
    pair<int, int> res;
    l = L, r = pos - 1;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) == -1) l = mid + 1;
        else r = mid - 1;
    }
    res.first = l;
    l = pos + 1, r = R;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) == 1) r = mid - 1;
        else l = mid + 1;
    }
    res.second = r;
    return res;
}
pair<int, int> Solve1(int L, int R) {
    if (L == R) return {L, R};
    int pos = p[R - L + 1] + L - 1;
    int res = Query(pos);
    if (res == -1) return Solve1(pos + 1, R);
    if (res == 1) return Solve1(L, pos - 1);
    return Solve2(L, R, pos);
}
pair<int, int> Guess(int N, int C) {
    return Solve1(1, N);
}
```

容易发现复杂度瓶颈其实是在 DP 部分，考虑观察决策点有什么性质。打表发现，记 $t$ 是满足 $2^t\le i$ 的最大值，有 $p_i=(i\bmod 2^t)+1$。那么就可以 $\mathcal O(1)$ 的时间计算 $p_i$ 的值。可以通过 Bonus 数据。

```cpp
#include <bits/stdc++.h>
using namespace std;
int Query(int x);
void init() {}
inline int GetPos(int i) {
    int lim = 1 << __lg(i);
    return (i & ((lim >> 1) - 1)) + 1;
}
pair<int, int> Solve2(int L, int R, int pos) {
    int l, r, mid;
    pair<int, int> res;
    l = L, r = pos - 1;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) == -1) l = mid + 1;
        else r = mid - 1;
    }
    res.first = l;
    l = pos + 1, r = R;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (Query(mid) == 1) r = mid - 1;
        else l = mid + 1;
    }
    res.second = r;
    return res;
}
pair<int, int> Solve1(int L, int R) {
    if (L == R) return {L, R};
    int pos = GetPos(R - L + 1) + L - 1;
    int res = Query(pos);
    if (res == -1) return Solve1(pos + 1, R);
    if (res == 1) return Solve1(L, pos - 1);
    return Solve2(L, R, pos);
}
pair<int, int> Guess(int N, int C) {
    return Solve1(1, N);
}
```

---

## 作者：Moeebius (赞：0)

> 比赛时二分太粗糙，10 分QWQ

## 题意
在规定的次数内根据交互猜出一个闭区间。

实现一个函数```Guess```，他可以通过函数```Query```询问一个数是否在区间内，最后返回区间的左右端点。

## 分析
### sol #1
这道题的「原题」是[这题](https://www.luogu.com.cn/problem/P1947)。

对于简单的猜单个数字，我们可以二分查找猜数，代码略去。

现在，对于一个区间，有什么好的解决办法？一个简单的思路就是二分两次，分别猜左端点和右端点。

> [代码](https://www.luogu.com.cn/paste/8opqwsh6)

应该可以获得 70 分的高分？

### sol #2
考虑优化。
- 优化 #1:特判。

注意到 $n=1$ 时不用询问就可以得出答案，
而且 $mid>n$ 时也没有必要询问。

- 优化 #2:记忆化。

注意到两次二分的初始上下界相同，这势必会导致两次二分有很多相同的询问，这是完全没有必要的。开个```map```记录即可。

> [代码](https://www.luogu.com.cn/paste/76ye5asq)

应该还是 70 分的高分？！

### sol#3
考虑继续优化。

**二分过程已经无可挑剔，再下去只有上下界可以修改。**

> 由于每次范围并没有（如预想中的）$\div2$ 向下取整，二分的效率并没有达到预期的 $\left\lfloor log_2n \right\rfloor$。 ——wsyear

很明显，为了让每一次范围减半，我们应该从一个 $2$ 的正整数幂开始询问。

可以使用一个小巧的 ```while``` 找到
第一个 $\ge n$ 的二的正整数次幂。
```cpp
ll maxv=1;
while(maxv<n) maxv*=2;
```

放一下完整代码吧。

```cpp
/*
* @ Author: Xiaohuba
* @ Usage: Luogu Problem
* @ Language: C++
*/
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lll __int128
#define pii pair<int,int>
#define mkp make_pair
/* ---File Head--- */
int Query(int x);

void init() { }

std::pair<int,int> Guess(int n, int c) {
    if(n==1) return mkp(1,1);//特判
    ll maxv=1;
    while(maxv<n) maxv*=2;//找上界
    int low=1,high=maxv,a,b;
    map<int,int> dat;
    while(low<=high)
    {
        int mid=(low+high)>>1;
        int st;
        if(mid>n) st=1;//大于n，没有必要询问
        else {
            if(!dat.count(mid)) dat[mid]=Query(mid);
            st=dat[mid];
            //记忆化
        }
        if(st>0) high=mid-1;//大了，上界下移
        else if(st<0) low=mid+1;//小了，下界上移
        else a=mid,high=mid-1;//因为要搜下界，所以往下搜
    }
    low=1,high=maxv;
    while(low<=high)
    {
        int mid=(low+high)>>1;
        int st;
        if(mid>n) st=1;
        else {
            if(!dat.count(mid)) dat[mid]=Query(mid);
            st=dat[mid];
        }
        if(st>0) high=mid-1;
        else if(st<0) low=mid+1;//同理
        else b=mid,low=mid+1;//因为要搜上界，所以往上搜
    }
    return mkp(a,b);
}
```

---


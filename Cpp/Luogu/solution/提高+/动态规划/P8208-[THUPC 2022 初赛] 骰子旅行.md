# [THUPC 2022 初赛] 骰子旅行

## 题目描述

在乐队 f 开巡演之前，按照惯例是要先组织乐队成员进行骰子旅行放松身心的。一次骰子旅行包括 $N$ 个地点，这些地点分别标号为 $1, 2, \cdots, N$。乐队成员们事先约好在 $s_0$ 处集合；而到了骰子旅行当天，大家都来到了集合地点 $s_0$，骰子旅行就算正式开始了。

骰子旅行的一大乐趣就是由骰子决定旅行的下一个目的地。当然，这个骰子不一定非得是六面的。我们可以认为，如果当前乐队成员们位于地点 $i$，那么下一个目的地会等概率地从 $m_i$ 个互不相同的候选地点中产生，这些候选地点分别是 $l_{i, 1}, l_{i, 2}, \cdots, l_{i, m_i}$。我们记第 $t$ 次投掷的结果是 $s_t$，那么第 $(t+1)$ 次将会前往 $s_t$ 处掷骰子。第 1 次投掷在起点 $s_0$ 处进行；而由于乐队之后还需要为了巡演排练，事先约定无论前往了哪些地点，投掷完第 $T$ 次骰子，前往 $s_T$ 后骰子旅行都得结束。

当然，享受 $s_0, s_1, \cdots, s_T$ 这些景点也是骰子旅行的一大乐趣。无论是否之前来过，每次到一个地点 $s_t$，乐队成员们都会尽情地浏览美景，品尝美食。只是如果之前来过 $s_t$，负责掷骰子的键盘手 S 在掷这第 $(t+1)$ 次骰子之前一定会说：“上次来到 $s_t$ 仿佛还是上一次 $t'$，上一次在这里掷出了 $s_{t'+1}$，不知道这一次会掷出什么结果。”鼓手 Y 特别喜欢废话梗，所以每次 S 说这句话时，他都会把 $s_{t'+1}$ 记下来。特别地，如果 $s_T$ 是之前经过的地点，那么 S 会说：“上次来到 $s_t$ 仿佛还是上一次 $t'$，上一次在这里掷出了 $s_{t'+1}$，不过这一次就不投掷了，因为骰子旅行到这里就要告一段落了。”当然，Y 也会把这个 $s_{t'+1}$ 记下来。

作为这次骰子旅行的总结，Y 会把所有记录下来的 $s_{t'+1}$ 加起来，作为 S 的废话指数。

f 的下一次巡演马上就要开始了，于是 S 又盘算着带大家去参加骰子旅行。听说你是 f 的粉丝，S 找到了你，希望你能帮他算一下他这次骰子旅行的废话指数的期望值。

## 说明/提示

【样例解释 1】

对答案有贡献的方案为：从点 $1$ 出发走到 $2, 3, 4$ 中的任意一个点并返回点 $1$。对于某个点 $i (i=2, 3, 4)$，走到点 $i$ 并返回点 $1$ 的概率为 $1/6$，而贡献为 $i$，故期望为 

$$\frac{1}{6} \times (2+3+4) = \frac{3}{2} .$$

由 $499122178 \times 2 = 998244356 \equiv 3 \pmod {998244353}$ 可知 $3/2$ 在模 $998,244,353$ 意义下为 $499,122,178$，所以正确输出为 $499,122,178$。

【样例解释 2】

转换前的答案为 $1625/432\approx 3.761574$，而 $432\times 274979351 = 118791079632 \equiv 1625 \pmod{998244353}$，所以模意义下的答案为 $274979351$。

【样例 3】

见附件。

【数据范围】

对于 $100\%$ 的数据，保证 $1\le N\le 100$，$1\le T\le 100$，$1\le s_0\le N$，$1\le m_i\le N$，$\sum_{i=1}^N m_i\le 5000$，$1\le l_{i, j}\le N$，且 $\forall 1\le i\le N, \forall 1\le j_1<j_2\le m_i, l_{i, j_1}\ne l_{i, j_2}$。

## 样例 #1

### 输入

```
5 1 2
3 2 3 4
2 1 5
2 1 5
2 1 5
3 2 3 4```

### 输出

```
499122178```

## 样例 #2

### 输入

```
7 1 4
6 2 3 4 5 6 7
6 1 3 4 5 6 7
6 1 2 4 5 6 7
6 1 2 3 5 6 7
6 1 2 3 4 6 7
6 1 2 3 4 5 7
6 1 2 3 4 5 6```

### 输出

```
274979351```

# 题解

## 作者：I_am_Accepted (赞：5)

### Analysis

有向图随机游走问题，本题**概率 DP** 没跑了。

一般地，设 $d_i$ 表示 $i$ 点的**出度**，$e_i$ 表示 $i$ **一步能到达的点集**，$|e_i|=d_i$。所有式子均在模 $998,244,353$ 意义下运算。

$f(s,i)$ 表示从 $i$ 开始用骰子走 $s$ 步，废话指数的期望值，那我们有

$$\begin{aligned}
f(0,i)&=0\\
f(s,i)&=\frac{1}{d_i}\sum_{j\in e_i}f(s-1,j)+j\cdot p(s-1,j,i)
\end{aligned}$$

其中 $p(s,x,y)$ 表示从点 $x$ 走 $s$ 步，**经过**（$1$ 次或以上均可）点 $y$ 的概率。

柿子解释：首先 $i$ 到 $e_i$ 中的点都是等概率的，所以每个分别计算取平均值即可；正常来说 $f(s-1,j)$ 就对了，除非又绕回了 $i$，这时以概率 $p(s-1,j,i)$ 多贡献 $j$。

时间 $O(Tn\sum\!m)$

### Code

```cpp
//Said no more counting dollars. We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=j;i<=k;i++)
#define ll long long
const ll mod=998244353;
inline ll pw(ll x,ll y){ll r=1;while(y){if(y&1)r=r*x%mod;x=x*x%mod;y>>=1;}return r;}
inline void mad(ll &a,ll b){a=(a+b)%mod;while(a<0)a+=mod;}
inline void mmu(ll &a,ll b){a=a*b%mod;while(a<0)a+=mod;}
#define inv(a) pw(a,mod-2)
#define int long long
#define N 102
#define gc getchar
#define pc putchar
inline int read(){
	int x=0;char c=gc();bool f=0;
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){x=(x<<3)+(x<<1)+c-48;c=gc();}
	if(f)x=-x;return x;
}
inline void write(int x){if(x<0){pc('-');x=-x;}if(x>9)write(x/10);pc(x%10+'0');}

int p[N][N][N];//i steps j -> k
int f[N][N];//i steps start from j
int n,S,m,co[N];
vector<int> e[N];
signed main(){
	n=read();S=read();m=read();
	int x,y;
	For(i,1,n){
		x=read();
		co[i]=inv(x);
		while(x--){
			y=read(); 
			e[i].pb(y);
		}
	}
	For(i,1,n) For(j,1,n) p[0][i][j]=(i==j);
	For(T,1,m){
		For(i,1,n){
			For(j,1,n){
				if(i==j){
					p[T][i][j]=1;
					continue;
				}
				p[T][i][j]=0;
				for(int k:e[i]) mad(p[T][i][j],p[T-1][k][j]);
				mmu(p[T][i][j],co[i]);
			}
		}
	}
	For(i,1,n) f[0][i]=0;
	For(T,1,m){
		For(i,1,n){
			f[T][i]=0;
			for(int j:e[i]){
				mad(f[T][i],f[T-1][j]+p[T-1][j][i]*j%mod);
			}
			mmu(f[T][i],co[i]);
		}
	}
	write(f[m][S]);
return 0;}
```

---

## 作者：阿丑 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8208)

#### 前置知识：

期望 dp。

#### 题意：

- $n$ 个点，第 $i$ 个点有 $m_i$ 条出边，第 $j$ 条连向 $l_{i,j}$。
- 从点 $s_0$ 出发，每次从当前点的所有出边随机选一条走，共走 $T$ 次。设时刻 $t$ 走到的点为 $s_t$，每次走到 $s_t$ 后设上一次（如果有）走到 $s_t$ 是时刻 $t'$，将 $s_{t'+1}$ 累加进废话指数。求废话指数期望。
- $n\le100$，$T\le100$，$\sum m\le5\times10^3$。

#### 分析：

若正向考虑，需记录每一个点上一次往哪个点走，不如反向考虑：每次走到 $s_t$ 设下一次（如果有）走到 $s_t$ 是时刻 $t'$，将 $s_{t+1}$ 累计进废话指数。

此时对废话指数的贡献与是否**再次**走到 $s_t$ 有关，而与在哪个时刻走到无关；并且对废话指数的贡献与 $s_{t+1}$ 有关。

记 $f(t,x,z)$ 表示在 $t$ 时刻位于 $x$ 点，之后走到 $z$ 的概率，则走到 $s_{t+1}$ 后，有 $f(t+1,s_{t+1},s_t)$ 的概率接下来会回到 $s_t$，即有 $f(t+1,s_{t+1},s_t)$ 的概率 $s_{t+1}$ 会累加进废话指数。

再记 $g(t,x)$ 表示在 $t$ 时刻走到 $x$ 点的概率，则有 $g(t,x)\times\dfrac1{m_x}$ 的概率在 $t$ 时刻从 $x$ 走到 $y$（$y=l_{x,j}$），即有 $g(t,x)\times\dfrac1{m_x}\times f(t+1,y,x)$ 的概率 $y$ 会累加进答案。

所以答案即为 $\sum\limits_{t=0}^{T-1}\sum\limits_{x=1}^n\sum\limits_{\forall(x,y)\in E}g(t,x)\times\dfrac1{m_x}\times f(t+1,y,x)\times y$。

考虑 $f,g$ 如何转移。由于范围较小，可以不做优化暴力枚举。具体地，转移式为：

$f(t,x,z)=\begin{cases}1&x=z\\\dfrac1{m_x}\sum\limits_{\forall(x,y)\in E}f(t+1,y,z)&x\ne z\end{cases}$

边界条件为 $f(T,x,z)=\begin{cases}1&x=z\\0&x\ne z\end{cases}$

$g(t,x)=\sum\limits_{\forall(y,x)\in E}\dfrac1{m_y}g(t-1,y)$

边界条件为 $g(0,x)=\begin{cases}1&x=s_0\\0&x\ne s_0\end{cases}$

时间复杂度 $\mathcal O(Tn\sum m)$，复杂度瓶颈在计算 $f$。

---

给出代码。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l, _=r; i<=_; ++i)
#pragma GCC diagnostic ignored "-Wparentheses"
using namespace std;
bool Mbe;
typedef long long ll;
const int mN=1e2+9, mM=5e3+9, mod=998244353;
#define pm(a) ((a)<mod? a: (a)-mod)
#define inc(a, b) a=pm(a+(b))
inline int qpow(int x, int y) {
	int res=1;
	for(; y; y>>=1, x=(ll) x*x%mod) if(y&1) res=(ll) res*x%mod;
	return res;
}
int n, s0, T, m[mN], invm[mN], l[mN][mN];
int f[mN][mN][mN], g[mN][mN], ans;

bool Men;
int main() {
	cerr<<"memory: "<<(&Men-&Mbe>>20)<<" MB"<<endl;

	scanf("%d%d%d", &n, &s0, &T);
	rep(i, 1, n) {
		scanf("%d", m+i), invm[i]=qpow(m[i], mod-2);
		rep(j, 1, m[i]) scanf("%d", l[i]+j);
	}
	g[0][s0]=1;
	rep(t, 0, T-1) rep(x, 1, n) {
		int z=(ll) g[t][x]*invm[x]%mod;
		rep(j, 1, m[x]) inc(g[t+1][l[x][j]], z);
	}
	rep(x, 1, n) f[T][x][x]=1;
	for(int t=T-1; t>=0; --t) {
		rep(x, 1, n) rep(z, 1, n) {
			if(x==z) {
				f[t][x][z]=1;
				continue;
			}
			rep(j, 1, m[x]) inc(f[t][x][z], f[t+1][l[x][j]][z]);
			f[t][x][z]=(ll) f[t][x][z]*invm[x]%mod;
		}
	}
	rep(t, 0, T-1) rep(x, 1, n) rep(j, 1, m[x])
		ans=(ans+(ll) g[t][x]*invm[x]%mod*f[t+1][l[x][j]][x]%mod*l[x][j])%mod;
	printf("%d\n", ans);
	return 0;
}
```

注意处理自环。

---

## 作者：Alex_Wei (赞：4)

> B. [P8208 [THUPC2022 初赛] 骰子旅行](https://www.luogu.com.cn/problem/P8208)

根据期望的线性性，考虑对每个位置 $i$，求出从 $i$ 出发恰好 $k$ 的时间 **第一次** 回到 $i$ 时的废话指数 $g_{i, k}$（仅考虑 $i$ 这一点作为 $s_{t'}$），也就是对于 $i$ 的所有出边 $(i, j)$，$j$ 在 $k - 1$ 时刻 **第一次** 回到 $i$ 的概率，乘以 $\dfrac{j}{m_i}$。一次预处理 $T\sum m_i$，对每个位置均预处理一遍，时间复杂度 $\mathcal{O}(nT\sum m_i)$。

不能直接求从 $i$ 出发恰好 $k$ 时间回到 $i$ 的概率乘以 $i$ 的所有出点编号 $j$ 之和除以 $m$ 是因为每个 $j$ 回到 $i$ 的概率不同。

剩下来就简单了。求出在 $t$ 时刻恰好在 $i$ 的概率 $f_{t, i}$（$T\sum m_i$ 时间复杂度），然后枚举下一次回到 $i$ 的时刻 $k$，则答案加上 $f_{t, i}\sum g_{i, k - t}$，后者容易预处理做到 $nT$，但不必要，因为复杂度瓶颈在于预处理 $g$。

注意自环。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100 + 5;
const int mod = 998244353;
int n, ans, s0, T, inv[N], f[N][N], g[N][N];
vector <int> e[N];
int main() {
	cin >> n >> s0 >> T, inv[1] = 1;
	for(int i = 2; i < N; i++) inv[i] = mod - 1ll * mod / i * inv[mod % i] % mod;
	for(int i = 1; i <= n; i++) {
		int m, id; scanf("%d", &m);
		for(int j = 1; j <= m; j++) scanf("%d", &id), e[i].push_back(id);
	}
	for(int i = 1; i <= n; i++) {
		memset(f, 0, sizeof(f));
		for(int it : e[i]) f[1][it] = 1ll * it * inv[e[i].size()] % mod;
		for(int j = 0; j < T; j++) {
			for(int k = 1; k <= n; k++)
				if(f[j][k] && k != i) {
					int v = 1ll * f[j][k] * inv[e[k].size()] % mod;
					for(int it : e[k]) f[j + 1][it] = (f[j + 1][it] + v) % mod;
				}
			g[i][j + 1] = f[j + 1][i];
		}
	}
	memset(f, 0, sizeof(f)), f[0][s0] = 1;
	for(int i = 0; i < T; i++) {
		for(int j = 1; j <= n; j++)
			if(f[i][j]) {
				for(int k = 1; k + i <= T; k++)
					ans = (ans + 1ll * f[i][j] * g[j][k] % mod) % mod;
				int v = 1ll * f[i][j] * inv[e[j].size()] % mod;
				for(int it : e[j]) f[i + 1][it] = (f[i + 1][it] + v) % mod;
			}
	}
	cout << ans << endl;
	return 0;
}
```



---

## 作者：xzzduang (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8208)

首先看到题应该想到根据期望的线性性把答案拆开算，即枚举一条边 $v\rightarrow u$，然后再枚举一个时刻 $t$，表示在此时刻通此边到达 $u$，且在旅行结束之前回到过 $v$，对答案的贡献就是这个事件发生的概率乘上 $u$。设这个概率为 $p_{u,v,t}$。

考虑求解 $p$，是否可以 $f_{u,v,t}$ 表示从 $u$ 出发，用了**恰好** $t$ 的时间到了 $v$ 的概率呢？$f$ 显然是可以 $\mathcal{O}(n^4)$ 转移的，但这样会算重，因为如果 $u$ 在之后回到了 $v$ 多次的话，就会对答案产生多次的贡献。

所以强制只让第一次回到 $u$ 产生贡献，于是记 $g_{u,v,t}$ 表示从 $u$ 出发，用了**恰好** $t$ 的时间回到了 $v$，且中途没有回到过 $v$ 的概率。求解 $g$ 可以考虑每次减去不合法的概率：
$$
g_{u,v,t}=f_{u,v,t}-\sum_k g_{u,v,k}f_{v,v,t-k}
$$
利用 $g$ 和 $f$，我们不难得到 $p$，再用 $p$ 得出答案。最后，整个算法的时间复杂度为 $\mathcal{O}(n^4)$。

注意一下这题是有自环的，这个恶心了我很久。

```cpp
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<vector>
#define N 105
#define mo 998244353
#define int long long
using namespace std;
inline int read(){
	int x=0,f=0; char ch=getchar();
	while(!isdigit(ch)) f|=(ch==45),ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?-x:x;
}
int n,s,T,f[N][N][N],g[N][N][N],mp[N][N],m[N],ans,inv[N];
inline void red(int &x){x>=mo?x-=mo:0;}
signed main(){
	n=read(),s=read(),T=read();
	inv[1]=1;for(int i=2;i<=n;++i) inv[i]=(mo-mo/i)*inv[mo%i]%mo;
	for(int i=1;i<=n;++i){
		m[i]=read();
		for(int j=1;j<=m[i];++j) mp[i][read()]=1;
	}
	for(int i=1;i<=n;++i) f[i][i][0]=1;
	for(int t=0;t<T;++t){
		for(int u=1;u<=n;++u){
			for(int v=1;v<=n;++v){
				for(int k=1;k<=n;++k){
					if(!mp[v][k]) continue;
					red(f[u][k][t+1]+=f[u][v][t]*inv[m[v]]%mo);
				}
			}
		}
	}
	for(int t=0;t<=T;++t){
		for(int u=1;u<=n;++u){
			for(int v=1;v<=n;++v){
				g[u][v][t]=f[u][v][t];
				for(int k=0;k<t;++k){
					red(g[u][v][t]+=mo-g[u][v][k]*f[v][v][t-k]%mo);
				}
			}
		}
	}
	for(int t=1;t<=T;++t){
		for(int u=1;u<=n;++u){
			for(int v=1;v<=n;++v){
				if(!mp[v][u]) continue;
				int p=0;
				for(int k=0;k<=T-t;++k) red(p+=g[u][v][k]);
				p=p*f[s][v][t-1]%mo*inv[m[v]]%mo;
				red(ans+=p*u%mo);
			}
		}
	}
	cout<<ans;
	return 0;
}
```



---


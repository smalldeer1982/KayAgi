# [THUPC 2022 初赛] 挑战

## 题目描述

**足够聪明**的 Alice 和 Bob 在玩一种棋盘游戏。这个游戏需要用到一个有 $(n+1)$ 个格子的长条棋盘，按从左到右的顺序给每个格子编号 $0, 1, \cdots, n$。除了编号为 $n$ 的格以外，每一格都有两个数 $p_i, q_i$。游戏开始前，将一个棋子放在第 $0$ 格。游戏由二人轮流操作，这里我们不妨假设 Alice 先手。

轮到其中一位玩家进行操作时，这位玩家可以根据当前格子的 $p$ 值决定前进的步数。具体地说，假设当前棋子位于第 $k$ 格，那么当前进行操作的玩家可以将棋子向前移动 $x$ 格，其中 $x$ 可以是满足 $1\le x\le p_k$ 的任意整数。如果玩家没有走满 $p_k$ 格，即 $x<p_k$，那么该玩家可以在完成移动后选择是否进行一次挑战。如果选择不进行挑战，那么由另一位玩家进行下一轮操作。否则，如果当前玩家选择挑战，那么系统将会产生两个随机**整数** $u$ 和 $v$，其中：$u$ 表示挑战的能量，它在 $\left[1, p_k-x\right]$ 中等概率产生；$v$ 表示挑战所需的活化能，它在 $\left[0, q_k + q_{k+x}\right]$ 中等概率产生。根据 $u$ 和 $v$ 的值，系统会根据以下规则自动判定挑战结果：

如果 $u>v$，则挑战成功，对方玩家的操作被跳过一轮，由当前玩家继续操作；
如果 $u=v$，则挑战结果为平手，什么事情都不会发生，由对方玩家进行操作；
如果 $u<v$，则挑战失败，当前玩家下一轮操作将会被跳过，即对方玩家可以连续操作两轮。
为了防止其中一方玩家一直被跳过，规定：

如果当前玩家通过自身的挑战获得额外操作机会，则该玩家在该额外操作机会中不能进行第二次挑战；
如果当前玩家通过对方玩家的挑战获得额外操作机会，则该玩家不能在其第一次操作结束时发起挑战，只能在第二次操作结束时选择是否进行挑战，并且当且仅当挑战成功时可以进行第三次操作。
需要注意的是，无论连续进行多少次操作，每次操作都需要将棋子向前移动至少 $1$ 格。同大多数游戏一样，谁将棋子移动到终点（即编号为 $n$ 的格）谁就获胜。

Alice 和 Bob 都足够聪明，可以心算出对于当前棋子的位置，能使自己获胜概率最大的操作。作为一名旁观者，你没有他们那么强的心算能力；但是你也想通过自己编程的能力，计算出当 Alice 先手从第 $0$ 格开始进行操作时，Alice 的胜率。

## 说明/提示

【样例解释 1】

Alice 先手，由于可以直接从第 $0$ 格移动到终点的第 $3$ 格，Alice 会直接将棋子移动到第 $3$ 格，故 Alice 必胜。

【样例解释 2】

Alice 先手，但是不能直接移动到第 $3$ 格，并且无论结束操作时棋子在第 $1$ 格还是第 $2$ 格，Bob 都可以直接将其移动到终点的第 $3$ 格，因此 Alice 必须尝试挑战。将棋子移动到第 $1$ 格并发动挑战，挑战成功的概率为 $1/4$，故 Alice 的胜率为 $1/4$。

【数据范围】

对于 $100\%$ 的数据，保证 $1\le n\le 100000$，$1\le p_i, q_i\le 333$。

## 样例 #1

### 输入

```
3
3 3 3
1 2 3```

### 输出

```
1.000000000000000000```

## 样例 #2

### 输入

```
3
2 3 3
1 2 3```

### 输出

```
0.250000000000000000```

## 样例 #3

### 输入

```
10
2 1 4 7 4 8 3 6 4 8
3 1 4 1 5 9 2 6 5 3```

### 输出

```
0.833333333333333333
```

# 题解

## 作者：_Arahc_ (赞：4)

诈骗题毒害人类。/fad

## 题意

题目传送门：[Link to Luogu](https://www.luogu.com.cn/problem/P8213)。

> 两个人玩一个博弈，每人每轮可以选择把棋子向前移不超过 $p_i$ 格，然后选择是否发起一次挑战，挑战结果是根据所在格子的两个参数 $p_i,q_i$ 随机产生的。根据挑战结果会发生下面事情之一：
> 
>  1. 什么都不发生。
>  2. 这个人再行动一轮。
>  3. 这个人的下一个回合被跳过。
> 
> 求两人都用最优策略时先手的胜率，误差不超过 $10^{-6}$。
> $n\leqslant 10^5,p_i,q_i\leqslant 333$。

当然这里说的很糊，具体题面还要去原题仔细阅读。

## 题解

本来一看到博弈论+概率以为是线性规划啥的，结果是个动态规划的诈骗题。因为本质是诈骗所以题目不算难，题解还是写得清楚一点好，老少皆宜。

考虑自己能否选择挑战的情况：要么可以挑战；要么不能发起挑战；要么就是别人给我送了一轮，则我连续操作两次，根据题意，第一次不能挑战，第二次能挑战。

注意：这里的“可以挑战”不代表“必须挑战”。

于是设一个这样的状态：$f_{i,0/1/2}$ 表示棋子在第 $i$ 格，目前接手的这个人（有代入感地假设是自己）能否挑战的情况为上述三种里的哪一种（$0/1/2$ 依次对应上面说的三种情况），此时这个人的胜率。

发现这样转移大概是 $\mathcal O(np)$ 的还带 $3$ 的常数所以刚好卡在了 $10^8$ 线……

估计完复杂度了，来看怎么转移。倒序枚举 $i$。先考虑不能挑战的情况，只能向前移动棋子，此时我的最大胜率就应该是对方的最大败率，即：

$$
f_{i,1} \gets \max_j^{p_i} (1-f_{i+j,0})
$$

其中 $j$ 枚举的是我移动多少步，后文和代码的 $j$ 都是这个含义。

然后是第一步不能挑战，然后能挑战的情况，也比较显然（转移方程就是这句话的字面意思）：

$$
f_{i,2} \gets \max_j^{p_i} (f_{i+j,0})
$$

最后看看能挑战吧 =.=，显然能挑战并不代表必须挑战，此时 $f_{i,0}$ 和 $f_{i,1}$ 一样，重点是挑战的情况（这里说的“贡献”指的是对我的胜率的贡献）：

1. 挑战成功，下一步继续移动，但不能挑战，产生的贡献是下一步移动的胜率（即 $f_{i+j,1}$）乘上挑战成功的概率。
2. 挑战平局，下一步是对方，贡献是对方的败率（即 $1-f_{i+j,0}$）乘上挑战平局概率。
3. 挑战失败，白给对方一步，贡献是对方连走两步的败率（即 $1-f_{i+j,2}$）乘上挑战失败的概率。

于是思路很清晰了，考虑成功、平局、失败的概率，因为三者加起来是 $1$，我们就只算前两个吧。

直接用成功/平局的结局数除以总的结局数 $n\times(m+1)$ 即可，两种情况的结局数如下：

+ 成功：钦定挑战能量，则活化能可以是小于挑战能量的任何数，根据 $n$ 是否不超过 $m$ 分类讨论即可。
+ 平局：二者必须相同，显然方案数为 $\min(n,m)$。

具体还可以看代码理解。

到这里所有的问题都已经解决了，复杂度是 $\mathcal O(np)$，带有约为 $3$ 的常数因子。可以通过本题。

## 代码

注意一些小细节即可，比如 $j=p_i$ 的时候是不能挑战的，等等。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=100005;
inline int read(){
    int x=0;bool w=0;char c=getchar();
    while(c<'0' || c>'9') w|=c=='-',c=getchar();
    while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10^48);
}

double f[max_n][3];
int n,p[max_n],q[max_n];

inline double P(int n,int m){ // 成功概率
    if(n<=m) return (n+1)/2.0/(m+1);
    return (2*n-m)/2.0/n;
}
inline double Q(int n,int m){ // 平局概率
    return min(n,m)*1.0/n/(m+1);
}
inline double R(int n,int m){ // 失败概率
    return 1-P(n,m)-Q(n,m);
}

signed main(){
    n=read();
    for(register int i=0;i<n;++i)
        p[i]=read();
    for(register int i=0;i<n;++i)
        q[i]=read();
    for(register int i=n-1;i>=0;--i){
        for(register int j=1,up=min(p[i],n-i);j<=up;++j){ // 不能移出界……
            f[i][1]=max(f[i][1],1-f[i+j][0]),
            f[i][2]=max(f[i][2],f[i+j][0]);
            if(j!=p[i])
                f[i][0]=max(f[i][0],max(f[i][1],f[i+j][1]*P(p[i]-j,q[i]+q[i+j])+(1-f[i+j][0])*Q(p[i]-j,q[i]+q[i+j])+(1-f[i+j][2])*R(p[i]-j,q[i]+q[i+j])));
            else
                f[i][0]=max(f[i][0],f[i][1]);
        }
    }
    printf("%.10lf",f[0][0]);
    return 0;
}
```

---

## 作者：PrincessQi (赞：0)

考虑倒着 DP。

设 $dp_{i,0}$ 表示当前在第 $i$ 位能走，但是不能挑战的胜率，$dp_{i,1}$ 表示当前在第 $i$ 位能走，而且能挑战的胜率，$dp_{i,2}$ 表示当前在第 $i$ 位能走两步的胜率。

初始状态：$dp_{n,\{0,1,2\}}=0$（你当前在第 $n$ 位你就输了，因为对手走到了第 $n$ 位）。

设 $j$ 表示能走到的格子，进行赢的概率为 $w_j$，平局的概率为 $t_j$，输的概率为 $l_j$，则 $dp_{i,0}=\max\{1-dp_{j,1}\}$（在所有能走到的格子中，对面哪个格子胜率小）；

$dp_{i,1}=\max\{dp_{i,0},w_j\times dp_{j,0}+t_j\times(1-dp_{j,1})+l_j\times(1-dp_{j,2})\}$（先看挑战不挑战，再看赢、平局、输的情况）；

$dp_{i,2}=\max\{dp_{j,1}\}$（在所有能走到的格子中，自己哪个格子胜率大）。

$w_j,t_j,l_j$ 均可以使用等差数列求和公式 $O(1)$ 计算。

```c++
#include<bits/stdc++.h>
using namespace std;
int n,p[100005],q[100005];
double dp[100005][3];
int main(){
	scanf("%d",&n);
	for(int i=0;i<=n-1;i++)
		scanf("%d",&p[i]);
	for(int i=0;i<=n-1;i++)
		scanf("%d",&q[i]);
	for(int i=n-1;i>=0;i--)
		for(int j=i+1;j<=min(n,i+p[i]);j++){
			int P=i+p[i]-j,Q=q[i]+q[j];
			double w,l,t;
			if(P<=Q)w=1.*(P+1)/2/(Q+1),l=1.*(2*Q-1-P)/2/(Q+1),t=1./(Q+1);
			else l=1.*Q*(Q-1)/2/P/(Q+1),t=1.*Q/P/(Q+1),w=1.*(2*P-Q)/2/P;
			dp[i][0]=max(dp[i][0],1-dp[j][1]);
			if(j!=i+p[i])dp[i][1]=max(dp[i][1],max(1-dp[j][1],w*dp[j][0]+t*(1-dp[j][1])+l*(1-dp[j][2])));
			else dp[i][1]=max(dp[i][1],1-dp[j][1]);
			dp[i][2]=max(dp[i][2],dp[j][1]);
		}
	printf("%.10lf\n",dp[0][1]);
	return 0;
}
```

---


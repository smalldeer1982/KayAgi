# [PA 2021] Od deski do deski

## 题目描述

给定 $n$，$m$，求满足以下限制的长度为 $n$ 的序列数目：

1. 每个元素在 $[1,m]$ 之间；
2. 一次操作定义为删除一个长度至少为 $2$ 且区间两端相等的区间，该序列需要在若干次操作内被删空。

答案对 $10^9+7$ 取模。

## 说明/提示

### 样例解释

合法序列有：

$[1,1,1,1]$

$[1,1,2,1]$

$[1,1,2,2]$

$[1,2,1,1]$

$[1,2,2,1]$

$[2,1,1,2]$

$[2,1,2,2]$

$[2,2,1,1]$

$[2,2,1,2]$

$[2,2,2,2]$

### 数据范围

$1 \le n \le 3000$，$1 \le m \le 10^9$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
10```

# 题解

## 作者：Semsue (赞：20)

### 题意

> 对于一个长度为 $n$ 的序列 $A_1,A_2,\dots, A_n$ 每次你可以选择两个值相同但位置不同的元素 $A_i,A_j$，然后将 $A_i,A_{i+1},\dots, A_j$ 删除.
> 
> 如果一个序列可以通过上述操作删为空序列，那么就称这个序列是好的。
>
> 问有多少长度为 $n$ 且元素在 $[1,m]$ 内的好的序列.
>
> $1\le n\le 3000,1\le m\le 10^9.$

### 题解

如果有包含关系的那么肯定删那个更大的，于是删除的区间不会有交。

考虑一个序列 $S$，如果 $S+x$ 是 合法的，那么 $S+x+x$ 也必然是合法的。于是可以考虑 dp，设 $f_{i,j,1/0}$ 代表长度为 $i$ 的序列，在后面放 $j$ 种数可以变成合法的，当前是否合法。答案显然为 $\sum f_{n,i,1}$。

考虑如何转移，如果当前合法，那么继续填那 $j$ 种显然会继续合法，并且合法数量不会增多。于是 $f_{i,j,1}\times j\to f_{i+1,j,1}$。如果填剩下的 $m-j$ 种数中的某个，显然不合法了且会多出来一种你填的这个可以消掉变成合法的，于是 $f_{i,j,1}\times (m-j)\to f_{i+1,j+1,0}$。如果当前不合法，显然还是可以转移到合法 $f_{i,j,0}\times j\to f_{i+1,j,1}$。然后考虑第二种转移，和前面唯一的区别是，你如果再选一遍你当前选的，你还是寄。也就是你只能这么转移 $f_{i,j,0}\times (m-j)\to f_{i+1,j,0}$。

总结一下四种转移：

$$
f_{i,j,1}\times j\to f_{i+1,j,1}
$$
$$
f_{i,j,1}\times (m-j)\to f_{i+1,j+1,0}
$$
$$
f_{i,j,0}\times j\to f_{i+1,j,1}
$$
$$
f_{i,j,0}\times (m-j)\to f_{i+1,j,0}
$$

思考一下发现 $i$ 个数的时候最多 $i$ 种合法的，所以时空复杂度均为 $O(n^2)$。


```cpp
int main(){
	cin>>n>>m;
	f[0][0][1]=1;
	for(int i=0;i<n;i++){
		for(int j=0;j<=i;j++){
			if(f[i][j][1]){
				f[i+1][j][1]=add(f[i+1][j][1],mul(f[i][j][1],j));
				f[i+1][j+1][0]=add(f[i+1][j+1][0],mul(f[i][j][1],dec(m,j)));
			}
			if(f[i][j][0]){
				f[i+1][j][1]=add(f[i+1][j][1],mul(f[i][j][0],j));
				f[i+1][j][0]=add(f[i+1][j][0],mul(f[i][j][0],dec(m,j)));
			}
		}
	}
	for(int i=0;i<=n;i++)ans=add(ans,f[n][i][1]);
	cout<<ans;
	return 0;
}
```

-------

2023/6/21 修改了错别字。

---

## 作者：SilviaLss (赞：12)

小清新计数题。

首先你考虑怎么判断一个序列是否满足条件，设 $f_i=(0/1)$ 表示这个序列的前 $i$ 项是否满足条件，特殊的，$f_0=1$。

不难得出如果 $\exists j\in[1,i-1]$ , $(f_{j-1}=1) \land (a_i=a_j)$，那么 $f_i$ 就是 $1$，不然为 $0$。


我们根据判断条件来设计 dp，设 $f_{i,j}$ 表示前 $i$ 位，有 $j$ 种数所对应的其中一个下标 $i$ 满足 $f_{i-1}=1$，并且当前序列不满足条件的方案数。$g_{i,j}$ 表示前 $i$ 位，有 $j$ 种数所对应的其中一个下标 $i$ 满足 $f_{i-1}=1$，并且当前序列满足条件的方案数。

转移式子很显然： 

1. $f_{i-1,j}\times j\to g_{i,j}$，表示一个不合法的加了一个数变成合法的了。
2. $g_{i-1,j}\times j\to g_{i,j}$，表示一个本来就合法的加了一个数仍然合法。
3. $f_{i-1,j}\times(m-j)\to f_{i,j}$，表示一个本来就不合法的序列，加了一个数，仍然不合法。
4. $g_{i-1,j-1}\times(m-j+1)\to f_{i,j}$，表示一个原本不合法的序列，加了一个数变成不合法的了，此时满足条件的数又增加了一个。（因为不合法，不会和前面的数重复）

时间复杂度 $O(n^2)$。

---

## 作者：035966_L3 (赞：5)

很明显，（只有）以下序列是合法的：

- 形如 `s**...**s` 的序列（即首尾项相等的序列），一次即可删除；
- 由多个合法的短序列拼接而成的长序列，每次删除一个短序列即可。

因此，所有合法的序列都长这样：

```plain
a**...**ab**...**bc**...**c......z**...**z
```

------------

现在，假设我们有以下的序列：

```plain
a**...**ab**...**bc**...**c......z**...**
```

考虑一下，如果在它末尾添加一项，如何才能让它合法：

- 添加 `a` 后显然合法；
- 添加 `b` 后可以分两次删除 `a...a` 和 `b...b`，合法；
- 添加 `c` 后可以分三次删除 `a...a`、`b...b` 和 `c...c`，合法；
- ……

综上所述，（只有）添加 `abc...z` 中的某一个才能让它合法。

观察发现：

- 第一个 `a` 前没有项，合法；
- 第一个 `b` 前是 `a...a`，合法；
- 第一个 `c` 前是 `a...ab...b`，合法；
- ……

**也就是说，对于某项 `s`（可以在任意位置，不要求第一次出现），如果它前面的序列（前缀）合法，那么可以保证：只要在序列末尾再添加一个 `s`，就可以使整个序列合法。**

------------

那么可以 DP 了：设 $g_{i,j,0/1}$ 表示长度为 $i$，满足以上条件的项的种数（不是个数）为 $j$ 的不合法 / 合法序列个数。

```plain
           Original sequence:     aabacebacdecdbe*****...
     Whether prefix is valid:  (1)010100111001110*****...
         Positions after 1's:     ^ ^ ^  ^^^  ^^^*****...
  Terms extracted from those:     a b c  acd  dbe*****...

  O(n^2) DP: g[length][extracted-unique-count][last]
  -> length = 15
  -> extracted-unique-count = 5
  -> last = 0
```

至于转移，按照「在末尾添加一项」的思想列出方程即可。

最终的时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$ 或 $O(n)$。

**AC Code：**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;
long long g[3012][3012][2];
/*
           Original sequence:     aabacebacdecdbe*****...
     Whether prefix is valid:  (1)010100111001110*****...
         Positions after 1's:     ^ ^ ^  ^^^  ^^^*****...
  Terms extracted from those:     a b c  acd  dbe*****...

  O(n^2) DP: g[length][extracted-unique-count][last]
  -> length = 15
  -> extracted-unique-count = 5
  -> last = 0
*/
int main()
{
	int n,m;
	cin>>n>>m;
	memset(g,0,sizeof g);
	g[1][1][0]=m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			if(g[i][j][0])
			{
				g[i+1][j][0]+=g[i][j][0]*(m-j),g[i+1][j][0]%=P;
				g[i+1][j][1]+=g[i][j][0]*j,g[i+1][j][1]%=P;
			}
			if(g[i][j][1])
			{
				g[i+1][j][1]+=g[i][j][1]*j,g[i+1][j][1]%=P;
				g[i+1][j+1][0]+=g[i][j][1]*(m-j),g[i+1][j+1][0]%=P;
			}
		}
	long long ans=0;
	for(int i=1;i<=n;i++)
		ans+=g[n][i][1],ans%=P;
	cout<<ans;
	return 0;
}

```

---

## 作者：Pekac (赞：5)

[P8386](https://www.luogu.com.cn/problem/P8386)

感谢 @platelett 讲的题。

先考虑给定序列怎么做。

问题显然可以转化为能否将序列分成若干个子序列。令 $f_i$ 表示前 $i$ 个数是否能够删完。则有 $f_i = f_j[a_i=a_j,  f_j=1]$。这样是 $n^2$ 的，也无法扩展至所有数列的情况。

建立一个辅助数组 $g$ 表示是否存值为 $i$ 的数前的值都被删完。则有 $f_i = g_{a_i}$，$g_{a_i} \mid=f_{i-1}$。

设 $h_{i}$ 表示长度为 $i$ 的数列能被删完的方案数。但这样显然是无法转移的。

发现影响能否删完的 $f$ 只有三个影响的地方 $(f_i, g_i)$，这个 $f$ 是可以在计算时直接用一个变量存下的，$a_i$ 是不需要存的。$g$ 是一个数组是不好存的。但是发现实际上 $h$ 转移的时候只需要知道 $g$ 有多少个地方是 $1$，这样就做完了。

定义 $h_{i,j,0/1}$ 表示长度为 $i$ 的数列中，$g$ 中有 $j$ 个 $1$ 且序列合法 / 不合法的情况有多少种。转移方程是显然的了，即 $h_{i,j,0}=(h_{i-1,j,0}+h_{i-1,j,1})\times j$，$h_{i,j,1} = h_{i-1,j,0} \times(m-j)+h_{i-1,j-1,1}\times (m-j+1)$。

最后的答案就是 $\sum h_{n,i,0}$。

时空复杂度均为 $\mathcal{O}(n^2)$。

代码：
```cpp
const int N = 3e3 + 10, mod = 1e9 + 7;
int add(int x, int y){ return (x + y) % mod; }
int n, m;
int f[N][N][2];

int main() {
	cin >> n >> m;
	f[1][1][0] = m;
	for (int i = 2; i <= n; ++i) for (int j = 1; j <= n; ++j) {
		f[i][j][0] = add(f[i - 1][j][0] * 1ll * (m - j) % mod, j ? f[i - 1][j - 1][1] * 1ll * (m - j + 1) % mod : 0),
		f[i][j][1] = add(f[i - 1][j][0], f[i - 1][j][1]) * 1ll * j % mod;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
		ans = add(ans, f[n][i][1]);
	cout << add(ans, mod) << "\n";
	return 0;
}
```

---

## 作者：_maojun_ (赞：3)

好像完全不同的，很绕的思路。来自大佬 @[缪凌锴_Mathew](https://www.luogu.com.cn/user/372409) /bx/bx/bx。

---

首先观察不到区间无交，所以我们考虑寻思一些用以统计的东西。

定义一种“关键点”。定义 $1$ 为关键点，若 $i(i>1)$ 为关键点，则 $[1,i-1]$ 可消，且不存在 $j<i$ 且 $a_j=a_i$ 使得 $j$ 为关键点。

这样若用 $f_i=0/1$ 表示 $i$ 是否为关键点，则可以把原序列映射到一个 $01$ 序列上，再对于 $f$ dp 计数原序列。这就是大体思路。

设一个 $dp_{i,j}$ 表示前 $i$ 个数设置了 $j$ 个关键点，钦定 $i$ 为关键点。观察到关键点不相邻，$j\le\left\lceil\frac i2\right\rceil$。

枚举上一个关键点的位置 $k(k\le i-2)$，这样可以从 $dp_{k,j-1}$ 转移过了。发现系数比较复杂。

考虑填入 $[k+1,i]$。$i$ 为关键点，所以 $i$ 不为之前关键点的颜色，$i-1$ 为之前关键点的颜色。记一个 $g_{i,j}$ 表示 $i$ 种有关键点颜色，要填入 $j$ 个空，且最后一个一定不是关键点颜色，倒数第二个一定是关键点颜色。则转移系数为 $g_{j-1,i-k}$。

对于 $g$，枚举一个采取关键点颜色的点数 $k$，由定义得关键点和非关键点都至少一个，则

$$g_{i,j}=\sum\limits_{k=1}^{j-1}i^k(m-i)^{j-k}$$

考虑计算答案。若 $n$ 为关键点显然不可行，否则需考虑 $[i+1,n]$ 填什么，于是类似的记一个 $h_{i,j}$ 作为系数，同于 $g$ 的是 $n$ 一定用的是关键点颜色，不同于 $g$ 的是不需要钦定某个数为非关键点颜色，于是

$$h_{i,j}=\sum\limits_{k=1}^ji^k(m-i)^{j-k}$$

则可以得到一个 $O(n^3)$ 的 dp：

$$dp_{1,1}=m$$

$$dp_{i,j}=\sum\limits_{k=1}^{i-2}g_{j-1,i-k}dp_{k,j-1}$$

$$\mathrm{ans}=\sum\limits_{i=1}^{n-1}\sum\limits_{j=1}^{\left\lceil\frac i2\right\rceil}h_{j,n-i}dp_{i,j}$$

---

接下来就是一些套路的优化：

首先观察到 $g_{i,j-1}=\sum\limits_{k=1}^{j-2}i^k(m-i)^{j-k-1}$。

于是有

$$
\begin{aligned}
g_{i,j}
&=\sum\limits_{k=1}^{j-1}i^k(m-i)^{j-k}\\
&=(m-i)(\sum\limits_{k=1}^{j-2}i^k(m-i)^{j-k-1})+i^{j-1}(m-i)\\
&=(g_{i,j-1}+i^{j-1})(m-i)
\end{aligned}
$$

这样可以 $O(n^2)$ 递推出 $g$，$h$ 同理。

然后观察到 $dp_{i-1,j}=\sum\limits_{k=1}^{i-3}g_{j-1,i-k-1}dp_{k,j-1}$

于是有

$$
\begin{aligned}
dp_{i,j}&=\sum\limits_{k=1}^{i-2}g_{j-1,i-k}dp_{k,j-1}\\
&=\sum\limits_{k=1}^{i-3}g_{j-1,i-k}dp_{k,j-1}+g_{j-1,2}dp_{k,j-1}\\
&=\sum\limits_{k=1}^{i-3}(g_{j-1,i-k-1}+(j-1)^{i-k-1})(m-j+1)dp_{k,j-1}+g_{j-1,2}dp_{k,j-1}\\
&=(m-j+1)(\sum\limits_{k=1}^{i-3}g_{j-1,i-k-1}dp_{k,j-1}+\sum\limits_{k=1}^{i-3}(j-1)^{i-k-1}dp_{k,j-1})+g_{j-1,2}dp_{k,j-1}\\
&=(m-j+1)(dp_{i-1,j}+\sum\limits_{k=1}^{i-3}(j-1)^{i-k-1}dp_{k,j-1})+g_{j-1,2}dp_{k,j-1}\\
\end{aligned}
$$

再记一个辅助数组 $s_{i,j}=\sum\limits_{k=1}^{i-3}(j-1)^{i-k-1}dp_{k,j-1}$，则 $dp_{i,j}=(m-j+1)(dp_{i-1,j}+s_{i,j})+g_{j-1,2}dp_{k,j-1}$。

发现 $g$ 只剩一个 $g_{j-1,2}=(j-1)(m-j+1)$ 了，可以不用预处理了。

继续观察到 $s_{i-1,j}=\sum\limits_{k=1}^{i-4}(j-1)^{i-k-2}dp_{k,j-1}$

于是有

$$
\begin{aligned}
s_{i,j}&=\sum\limits_{k=1}^{i-3}(j-1)^{i-k-1}dp_{k,j-1}\\
&=(j-1)(\sum\limits_{k=1}^{i-4}(j-1)^{i-k-2}dp_{k,j-1})+(j-1)^2dp_{i-3,j-1}\\
&=(j-1)s_{i-1,j}+(j-1)^2dp_{i-3,j-1}
\end{aligned}
$$

这样就 $O(n^2)$ 地完成了转移。真的非常绕呢。

---

但是代码还是很好写的。

```cpp
typedef long long ll;
const int N=3e3+5,MOD=1e9+7;
int n,m;

ll dp[N][N],h[N][N],s[N][N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)for(int j=1,k=1;j<=n;j++)		// 预处理
		h[i][j]=(h[i][j-1]*(m-i)+(k=(ll)k*i%MOD))%MOD;
	dp[1][1]=m;
	for(int i=3;i<=n;i++)for(int j=1;j<=i+1>>1;j++){	// 转移
		s[i][j]=(dp[i-3][j-1]*(j-1)%MOD*(j-1)+s[i-1][j]*(j-1))%MOD;
		dp[i][j]=(dp[i-2][j-1]*(j-1)+dp[i-1][j]+s[i][j])%MOD*(m-j+1)%MOD;
	}
	ll res=0;
	for(int i=1;i<n;i++)for(int j=1;j<=i+1>>1;j++)		// 计算答案
		res=(res+h[j][n-i]*dp[i][j])%MOD;
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：SunsetLake (赞：3)

一道很抽象的 $\text {dp}$?

状态就比较抽象。注意到 $m$ 有 $10^9$，肯定不能带到状态里。但是我们可以注意到：如果当前序列 $S$ 已经合法，且有 $S+x$ 合法，那么 $S+x+x$ 也一定合法，因为我们可以把两个 $x$ 消掉。因此，可以设计 $f_{i,j}$ 表示长度为 $i$ 的序列，往后放 $j$ 种数依然合法的方案数。同时还要考虑当前序列是否合法，于是增加一维 $0/1$ 表示当前序列是否合法。

然后考虑转移。首先如果当前为 $f_{i,j,1}$，那么长为 $i+1$ 的序列再往后放这 $j$ 种数依然合法，因为可以互相消掉，且种类不会增多。当前这一位可以有 $j$ 种放法，所以 $f_{i+1,j,1} \gets f_{i,j,1} \times j$。同时如果当前 $f_{i,j,0}$ 是不合法的，那就是说单出来一个数不能配对，因此我们考虑在 $i+1$ 填 $j$ 种数中的一个，使它能与之前的配对并消除，变成合法.因此 $f_{i+1,j,1} \gets f_{i,j,0} \times j$。

再来看不合法的情况。如果当前 $f_{i,j,1}$，我们在后面填了另外的 $m-j$ 种数，此时这个数就会单出来无法与前面的匹配消掉，并会让种数加一，$f_{i+1,j+1,0} \gets f_{i,j,1} \times (m-j)$。同理，如果当前不行，那再加那 $m-j$ 种数中的一个依然不合法。所以 $f_{i+1,j,0} \gets f_{i,j,0} \times (m-j)$。

答案就是 $\sum_{i=1}^{n} f_{n,i,1}$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
ll m,dp[3005][3005][2],ans;
const int mod=1e9+7;
int main(){
	cin>>n>>m;
	dp[0][0][1]=1;
	for(int i=0;i<n;++i){
		for(ll j=0;j<=i;++j){
			dp[i+1][j][1]=(dp[i+1][j][1]+dp[i][j][1]*j%mod)%mod;
			dp[i+1][j+1][0]=(dp[i+1][j+1][0]+dp[i][j][1]*(m-j)%mod)%mod;
			dp[i+1][j][0]=(dp[i+1][j][0]+dp[i][j][0]*(m-j)%mod)%mod;
			dp[i+1][j][1]=(dp[i+1][j][1]+dp[i][j][0]*j%mod)%mod;
		}
	}
	for(int i=1;i<=n;++i)ans=(ans+dp[n][i][1])%mod;
	cout<<ans;
	return 0;
}
```



---

## 作者：CmsMartin (赞：2)

[可能更好的阅读体验](http://cmsblog.top/archives/pa2021oddeskidodeski)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P8386)

## 思路

计数题，很容易想到 dp。

难点在于状态的设计，显然有一维状态是序列长度，有一维表示合法与否，dp 值表示为方案数，记为 $f_{i,{0/1}}$。

这样是没有办法转移的，因为我们接下来要填什么与之前填的数字有关，考虑加维。

发现对于一个合法序列 $S$，假设在后面加数字 $x$ 得到结果 $S+x$ 仍是合法的，不妨加一个维度表示加上后可以合法的数字数量。

设 $f_{i,,j,{0/1}}$ 表示长度为 $i$ 的序列，在后面加有 $j$ 种可以使得其合法的方案，当前合法与否。

#### $f_{i,j,1}$ 的转移

根据定义转移。

$$
f_{i,j,1} = f_{i-1,j,1} \times j + f_{i-1,j,0} \times j
$$

#### $f_{i,j,0}$ 的转移

根据定义，$f_{i,j,0}$ 是不合法的有两种加法：

在长度为 $i-1$ 的序列**不合法序列**结尾加上了不属于这 $j$ 种字符的答案，这样显然可以使序列变为合法的方案数不变。即：

$$
f_{i,j,0} = f_{i-1,j,0} \times (m - j)
$$

另一种是在长度为 $i-1$ 的序列**合法序列**结尾加上了不属于这 $j$ 种字符的答案，这样会使序列变为合法的方案数加一，因为我们新加上的这个字符再加一个也能使序列合法。即：

$$
f_{i,j,0} = f_{i-1,j-1,1} \times (m - j)
$$

时间复杂度 $\Theta(n^2)$，使用滚动数组，空间复杂度 $\Theta(n)$。





---


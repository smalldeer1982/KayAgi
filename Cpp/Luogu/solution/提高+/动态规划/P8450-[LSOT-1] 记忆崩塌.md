# [LSOT-1] 记忆崩塌

## 题目背景

“铃铃铃”，上课铃打响。一阵眩晕，小 H 突然倒在地上。只是隐约间，感受到周围有人赶过来。

“这是哪里？我不是在上课吗？”小 H 望向周围。

“欢迎来到 OI 世界。我负责带你熟悉 OI 世界。”一个奇怪的人走到这里来。

“OI 世界？”

“对。这里没有文化课，你可以在这里尽情学习 OI。”那人解释道。

紧接着，那人将小 H 带到了一个自称是心理学家的人面前。

“你在干什么？”小 H 望着那个心理学家。他正准备把一个奇怪的东西戴到小 H 头上。

“这个可以帮你恢复你在 whk 世界的记忆。”心理学家淡淡地说。

仪器戴到头上后，小 H 大喊：“我什么都想起来了！”

然而，真的什么都想起来了吗……

从那个人带着小H前往OI世界观光开始，这一切，全都乱了……

## 题目描述

**这是一道交互题。**

小 H 失忆了。

现在，小 H 过去的记忆化成了 $n$ 个记忆碎片。医生拥有 $n$ 种长度的取样条（长度为 $1\dots n$）。记忆碎片会与长度为 $i$ 的取样条发生大小为 $\gcd(n,i)$ 的情感共鸣。

医生有一个机器，可以测出长度为 $i$ 的取样条与小 H 产生的情感共鸣大小。现在你可以用这个机器测量一定的次数，医生希望你能告诉他若用完 $n$ 种长度的取样条小 H 总共会发生多大的情感共鸣。

### 交互格式
你可以用以下格式来询问医生你想知道的东西：

`TheSame? m`：下接 $m$ 行，每行两个数 $p_i,k_i$，医生会告诉你数小 H 的记忆碎片数量是否与 $\displaystyle\prod_{i=1}^mp_i^{k_i}$ 相等。`Yes` 代表相同或 `No` 代表不同。

`GetGCD. m`：下接 $m$ 行，每行两个数 $p,k$ ，医生会告诉你$\displaystyle\prod_{i=1}^mp_i^{k_i}$  与小 H 的记忆碎片产生的情感共鸣大小。

所有询问的 $p_i$ 为素数，$k_i$ 为正整数，不符合上述限制的交互不保证交互库会做出预期行为。

***

你可以用以下格式来告诉医生你知道的东西：

`IFoundTheAnswer! m`：以此来告诉评测器我已经知道了小 H 总共产生的情感共鸣大小为 $m$，并评判是否正确。

***

你一共可以与医生交互 $1050$ 次。交互库的所有输出与你输出的答案均应对 $998244353$ 取模。

***

你需要从**标准输出**中输出，代表你询问的内容。

每一次询问后都应当**清空缓冲区**，不然你会无缘无故 TLE。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

然后你需要从**标准输入**中输入，代表评测机返回的结果。

## 说明/提示

【数据范围】

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(10 pts)：}1 \le\ n\le 500$；
- $\texttt{Subtask 2(25 pts)：}1 \le\ n\le 10^6$；
- $\texttt{Subtask 3(25 pts)：}$保证 $n$ 的唯一分解形式仅有前 $100$ 个质数；
- $\texttt{Subtask 4(40 pts)：}$无特殊限制。

对于 $100\%$ 的数据，满足 $n$ 的唯一分解形式质数数量不超过 $1000$，且质因子最大不超过 $7919$（注：$7919$ 为第 $1000$ 个质数），且质数的次数不超过 $10000$。

【其他提示】

因为交互库的效率较低，所以附件中给出交互库的代码。如果你想利用下面的交互库代码进行调试，你可以在官方的 [SPJ 说明](https://www.luogu.com.cn/blog/luogu/special-judge) 中下载 ```testlib.h``` 头文件后将两个程序的输出输入到另一个程序中。当然，你也可以模拟交互库的计算来手动输入到你的程序中。

## 样例 #1

### 输入

```
1
No
2
Yes```

### 输出

```
GetGCD. 0
TheSame?  0
GetGCD. 1
2 1
TheSame? 1
2 1
IFoundTheAnswer! 3```

# 题解

## 作者：良心WA题人 (赞：5)

设 $f_n$ 表示答案，则显然 $f_n=\Sigma_{d|n}\phi_\frac{n}{d}\times d$

令 $g_x=x$，显然 $g_x$ 为积性函数。那么右半边就是 $f_x$ 与 $g_x$ 的迪利克雷卷积。又因为 $\phi_x$ 为积性函数，而根据积性函数的性质不难知道 $f_x$ 是积性函数。所以，$f_x$ 的值仅与 $f_{p^k}$ 有关。并且，不难推出来 $f_{p^k}=p^k+p^k\times(1-\dfrac{1}{p})\times k$。所以，我们只需要知道如何才能得到 $n$ 的因数 $p^k$。

我们可以询问 $gcd(p^\infty ,n)$。然后得到的值 $a$ 就是 $n$ 的因数 $p^k$。因为返回的值对$P$取模，所以，我们就得到了一个同余方程：$p^k \equiv a \pmod P$

那么，我们就可以用 $BSGS$ 求出第一个解。然后通解就知道了。将通解存到一个数组里，那么我们可以二分这个数组，找到数组中的 $k$，使返回值 $gcd(p^k,a)=a$ 且 $gcd(p^{k-1},a)\not=a$，那么这个 $p^k$ 就是 $n$ 的因子，计算答案即可。。。。？

注意到，这样做只能得到前三个 ```subtask``` 的分。输出一下每个解是膜多少的剩余类，发现所有的都大于 $10000$ 。所以在次数为 $0$ 到 $10000$ 的范围内只会有一个解。那么，直接用得到的解就行了。


std：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=1004,P=998244353;
int prime[NN],vis[NN*100];
int qmi(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1)
			res=1ll*res*a%P;
		a=1ll*a*a%P;
		b>>=1;
	}
	return res;
}
int bsgs(int a,int b)
{
	if(1%P==b%P)
		return 0;
	unordered_map<int,int>hash;
	int k=sqrt(P)+1;
	for(int i=0,j=b%P;i<k;i++)
	{
		hash[j]=i;
		j=1ll*j*a%P;
	}
	int ak=1;
	for(int i=1;i<=k;i++)
		ak=1ll*ak*a%P;
	for(int i=1,j=ak;i<=k;i++)
	{
		if(hash.count(j))
			return i*k-hash[j];
		j=1ll*j*ak%P;
	}
	return -1;
}
int main()
{
	vis[1]=true;
	int cnt=0;
	for(int i=2;cnt<=1000;i++)
		if(!vis[i])
		{
			prime[++cnt]=i;
			for(int j=i*i;j<=1e5;j+=i)
				vis[j]=true;
		}
	int ans=1;
	for(int i=1;i<=cnt;i++)
	{
		printf("GetGCD. 1 %d 1000000\n",prime[i]);
		fflush(stdout);
		int k;
		scanf("%d",&k);
		int t=bsgs(prime[i],k);
		ans=1ll*ans*((k+1ll*k*(prime[i]-1)%P*qmi(prime[i],P-2)%P*t%P)%P)%P;
	}
	printf("IFoundTheAnswer! %d",ans);
	return 0;
}
```

---

## 作者：01bit (赞：1)

设 $m=998244353,f_n=\sum^n_{i=1}\gcd(n,i)$ ， $n$ 的唯一分解形式为 $\prod p^k$ 。

易知 $\gcd(n,i)|n$ 。

又易知 $\forall\gcd(\frac{n}{j},i)=1,\gcd(n,i)=j$ 。

所以 $f_n=\sum_{j|n}\varphi(\frac{n}{j})j$ 。

因为 $\varphi,j$ 均为积性函数，所以 $f$ 也为积性函数。

则 $f_n=\prod f_{p^k}$ 。

易知：
$$\begin{aligned}
f_{p^k}&=\varphi(p^k)+\varphi(p^{k-1})p+\dots+p^k\\&=(p-1)p^{k-1}+(p-1)p^{k-1}+\dots+p^k\\&=k(p-1)p^{k-1}+p^k
\end{aligned}$$

由 `GetGCD` 操作可得到 $p^k\bmod m$ ，使用 BSGS 可求出 $k$ 。

通过计算(你也可以说是打表……)可知前 $1000$ 个质数的阶都大于 $10000$ ，所以 $k$ 唯一。

设 $n=1000,k=10000$ ，则时间复杂度 $O(n\sqrt m+n\log k)$ ，可以通过此题。

```cpp
#include <cmath>
#include <iostream>
#include <unordered_map>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
ll m, ans = 1;

ll qpow(ll x, ll y) {
    ll z = 1;
    while (y) {
        if (y & 1)
            z = z * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return z;
}

const ll N = 7919;
bool np[N + 5];
ll pri[N + 5], cnt = 0;
void init() {
    m = ceil(sqrt(mod));
    for (ll i = 2; i <= N; i++) {
        if (!np[i])
            pri[++cnt] = i;
        for (ll j = 1; j <= cnt; j++) {
            if (i * pri[j] > N)
                break;
            np[i * pri[j]] = true;
            if (i % pri[j] == 0)
                break;
        }
    }
}

unordered_map<ll, ll> mp;
ll BSGS(ll a, ll b) {
    mp.clear();
    ll x = b;
    for (ll i = 0; i <= m; i++) {
        mp[x] = i + 1;
        x = x * a % mod;
    }
    for (ll i = 0; i <= m; i++) {
        x = qpow(a, i * m);
        if (mp[x])
            return i * m - mp[x] + 1;
    }
    return -1;
}
int main() {
    init();
    for (ll i = 1; i <= cnt; i++) {
        ll x, p = pri[i], k;
        cout << "GetGCD. 1" << endl;
        cout << p << " 10000" << endl;
        cin >> x;
        if (x == 1)
            continue;
        k = BSGS(p, x);
        ll y1 = k * (p - 1) % mod * qpow(p, k - 1) % mod;
        ll y2 = qpow(p, k);
        ans = ans * (y1 + y2) % mod;
    }
    cout << "IFoundTheAnswer! " << ans << endl;
    return 0;
}
```

---

## 作者：Hooch (赞：1)

**提供一种非官方乱搞做法**。

我们读了题后发现这个题是要求 $\gcd(1,n)+\gcd(2,n)+\cdots+\gcd(n,n)$，那么我们就先考虑该如何快速求出这个东西。

***
#### 用 $O(\tau(n))$ 的时间复杂度求出上述式子。

我们通过可以通过枚举 $\gcd$ 的取值来算出 $\sum_{i=1}^n\gcd(i,n)$ 的和。

设 $\gcd(i,n)=d$，那么显然 $\gcd(\frac{i}{d},\frac{i}{n})=1$。

所以满足 $\gcd(i,n)=d$ 的 $\frac{i}{d}$ 就有 $\varphi(\frac{n}{d})$ 个。

所以他们的和就是 $\sum_{d\mid n}^nd\times\varphi(\frac{n}{d})$。

但是此算法时间复杂度为 $O(\tau(n)\cdot\sqrt{n})$，其中 $\tau(n)$ 为 $n$ 的约数个数，最坏情况差不多是 $2\sqrt{n}$ 的，不可取。考虑优化。

设 $g(n)=\sum_{d\mid n}^nd\times\varphi(\frac{n}{d})$，并假设 $\gcd(m,n)=1$，那么 $g(n)g(m)=\left(\sum_{d\mid n}d\cdot \varphi(\frac nd)\right)\left(\sum_{e\mid m}e\cdot \varphi(\frac me)\right) = \sum_{d\mid n}\sum_{e\mid m}de\cdot \varphi(\frac nd)\varphi(\frac me)$。

此时显然 $\gcd(\frac{n}{d},\frac{m}{e})=1$，所以 $\varphi(\frac{n}{d})\times \varphi(\frac{m}{e})=\varphi(\frac{nm}{de})$。

于是原式等于 $\sum_{d\mid n}^n\sum_{e\mid m}^m de\cdot \varphi(\frac{mn}{de})=\sum_{h\mid nm}^{nm}h\cdots\varphi(\frac{nm}{h})=g(nm)$

所以 $g$ 为积性函数。

将 $n$ 质因数分解：

$$
n=\prod_{i=1}^kp_i^{a_i}=p_1^{a_1}\cdot p_2^{a_2}\cdots p_k^{a_k}
$$

并且 $p_i$ 均为质数。

所以 $g(n)=\prod_{i=1}^kg(p_i^{a_i})$。

考虑 $g(p^a)=\sum_{d\mid p^a}^{p^a}d\cdot\varphi(\frac{p^a}{d})=\sum_{i=0}^ap^i\varphi(p^{a-i})=\sum_{i=0}^{a-1}p^i\varphi(p^{a-i})+p^a\varphi(1)$。

即

$$
g(p^a)=p^a+\sum_{i=0}^{a-1}p^i(p^{a-i}-p^{a-i-1})=p^a+\sum_{i=0}^{a-1}(p^a-p^{a-1})=(a+1)p^a-ap^{a-1}
$$

所以我们分解质因数就能算出 $\sum_{i=1}^n\gcd(i,n)$ 了。
***

回归到题目上，有了上面的结论，现在我们只用求出 $n$ 了。

我们发现题目中有一条特殊性质：

> $n$ 的唯一分解形式质数数量不超过 $1000$，且质因子最大不超过 $7919$，且质数的次数不超过 $10000$。

那么我们就对每一个 $1\sim 7919$ 中的每一个质数逐一提问 `GetGCD`，然后每次只问这个质数和这个质数的 $10001$ 次方，这样的 $\gcd$ 总是最大的，然后我们就知道了这个质数的次数。

既然知道了每一个质数，结合上面的性质，我们便能解决此题。

### 代码细节

我们先进行一个质数筛，筛出那 $1000$ 个质数，然后枚举。

但是写着写着我们会发现一个问题：这道题十分讨厌地加了一个模数 $998244353$，那么所有回答都会被取模，这样我们无法得出真实的 $\gcd$。但是题目保证了质数的次数不超过 $10000$，那么我们枚举一个质数的次数，一直取模，直到最后得到的质数模之后的答案与交互库给出的答案相同，这样我们就能得到这个质数和次数了。

并且在结论中式子中含有 $p^{a-1}$，但是被取模了之后不能简单地将 $p^a\div p$ 之后得到。所以要记一个 `last` 来存储 $p^{a-1}$。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 8005, mod = 998244353;
int prime[N], cnt; bool st[N];
signed main(void) {
	for (int i = 2; i <= 7919; ++i) {
		if (!st[i]) prime[++cnt] = i;
		for (int j = 1; prime[j] * i <= 7919; ++j) {
			st[prime[j] * i] = 1;
			if (i % prime[j] == 0) break;
		}
	}
	int n = 1, ans = 1; 
	for (int i = 1; i <= 1000; ++i) {
		printf("GetGCD. 1\n");
		fflush(stdout);
		printf("%lld %lld\n", prime[i], 10001);
		fflush(stdout);
		int res; scanf("%lld", &res); int k = 1, last = 1;
		for (int j = 1; j <= 10000; ++j) {
			(k *= prime[i]) %= mod;
			if (k == res) {
				(ans *= ((j + 1) * k % mod + mod - last * j % mod) % mod) %= mod;
				break;
			} last = k;
		}
	} 
	printf("IFoundTheAnswer! %lld\n", ans);
	fflush(stdout);
}
```

---

## 作者：Sharpsmile (赞：1)

# 记忆崩塌非官方乱搞题解

~~官方做法超简洁还比我快，我这个做法垃圾滴很~~

## 题目大意
有一个整数 $n$，保证他的任一质因子大小不超过 $7919$（第一千个质数），且任一质因子次数不超过 $10000$。求 $\sum\limits_{i=1}^n \gcd(n,i)$。

作为交互题，你可以进行如下操作：询问一堆质数的幂的乘积是否等于 $n$ ，询问一堆质数的幂的乘积与 $n$ 的公因数（对 $998244353$ 取模），输出答案（答案对 $998244353$ 取模）。

最多进行 $1050$ 次操作。

## 题目解法
### Step 1 获取 $n$
 
首先看到题目说了次数不超过 $10000$ 且质数个数不超过一千。考虑每次询问他的一个质因子的次幂数，具体的，我们询问 $\gcd(p^{10001},n)$，得到的值就是 $n$ 的最大的素数 $p$ 因子的幂次，而要求出这个幂次，我们注意到前一千个质数对于 $ 998244353$ 取模的阶都在 $10000$ 以上，直接暴力找即可。

### Step 2 计算 part 1
~~怎么第二步就计算了~~

这里我们发现，我们强行令一个 $n$ 的因数 $d$ 成为他的质因子，那么 $\varphi(\frac{n}{d})$ 就是与 $n$ 公因数为 $d$ 的数的个数，即现在答案转化为 $\sum\limits_{d|n}d\times \varphi(\frac{n}{d})$。这坨东西看起来不是很好搞，我们考虑再次把欧拉函数拆开。得到了 $\sum\limits_{d|n}d\prod\limits_{p|\frac{n}{d},p\in \mathbb{P},\gcd(p^{k+1},\frac{n}{d})=p^k}(p-1)p^{k-1}$。

现在再看，我们发现在计算欧拉函数的时候，只要不把某个质因数直接除完，那么这些因数就会出现在 $d$ 上，这种情况下 $d\times \varphi(\frac{n}{d})=\varphi(n)$。这种情况的数量比较好算。计这部分答案为 $res$ 。

### Step 3 计算 part 2

令 $p_i$ 表示第 $i$ 个质数，$s_i$ 表示第 $i$ 个质数在 $n$ 中的次数。

而对于剩下的情况，也就是需要我们把一些质因数完全删除。这一部分我们考虑 dp。具体的，我们令 $dp[i]$ 表示最后一个删完的（按照质因子大小排序）质因子是第 $i$ 个质数的前 $i$ 个质数的贡献，显然这部分贡献由三部分组成——上一个被取完的质因子和其之前的贡献 、中间的没有被用完的贡献、这次删完了的贡献。我们假设上一个被取完的质数是第 $j$ 个质数，则三部分的贡献应分别为 $dp[j]$、$\prod\limits_{k=j+1}^{i-1}\varphi(p_k^{s_k})\times s_k$、$p_i^{s_i}$。一三部分不多赘述，第二部分和上文 part 1 类似。


枚举 $j$ 即可，第二部分容易发现是一个从 $i$ 开始的后缀积，故从后向前枚举直接算即可。

### Step 4 整合答案

part 1 和 part 2 无关联，直接加和。

part 2 部分中，对于每一个以这个质数为最后一个被删完的质数的贡献再乘上剩下的没被计算在其中的后 $1000-i$ 个质数的贡献即可。这部分和计算 part 2 中的第二部分一样。

故答案 $ans=res+\sum\limits_{i=1}^{1000}dp[i] \prod\limits_{j=i+1}^{1000}\varphi(p_j^{s_j})\times s_j$。

然后就没了。

~~输出答案之前记得输出那个 `IFoundTheAnswer` ，我赛时因为这个玩意调了半小时~~

### Code
代码不放了，赛时代码丑的要死，而且实现的也比较劣，就不拿出来误人子弟了。

---


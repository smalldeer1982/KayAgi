# 「KDOI-02」一个网的路

## 题目背景

「{*^$&#$~!@ovo}（他们也有路网？有趣。）」  
「{&%#@~akoio!@}（该干的活先干完吧，玩物丧志的东西待会再说。）」  
「{!%_&#%@yw?}（您语文是不是没学好？）」  
蔚蓝的天空下，人们还不知道危险的来临。

## 题目描述


敌对文明被惹怒了。他们想用一种有趣的方式摧毁地球的路网。地球的路网可以近似为一个含有 $n$ 个节点 $m$ 条无向边的**森林**。他们想用以下 $2$ 种操作：  
- 炸毁一个城市 $u$ 向外连接的所有道路。
- 在城市 $u,v$ 间新建一条道路。  

来将地球上的路网改成效率最低的形式：一条链。可惜的是，他们的智商都不怎么高。于是，他们抓住了你，要求你给出一种方案，使得他们操作的次数最少。可怜的你在万般无奈之下，决定写一个程序，帮助他们算出结果。

## 说明/提示

**【样例解释】**

+ **样例 1 解释：**  
初始图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/2z6ava49.png)  
对城市 $2,3$ 进行操作二。  
![](https://cdn.luogu.com.cn/upload/image_hosting/lqhomfm5.png)  
此时已经成为了一条链。

***

**【数据范围】**

对于 $100\%$ 的数据，$0\le m<n\le2\times10^6$ 且保证输入合法。

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim2$|$10$|A|
|$3\sim6$|$500$|无|
|$7\sim8$|$10^4$|A|
|$9$|$10^4$|B|
|$10\sim12$|$10^4$|无|
|$13\sim15$|$10^6$|无|
|$16\sim20$|$2\times10^6$|无|

+ 特殊性质 A：保证每个连通块都为二叉树。
+ 特殊性质 B：保证每个顶点的度数不超过 $2$。

**【提示】**

本题 I/O 量较大，推荐使用较快的 I/O 方式。

## 样例 #1

### 输入

```
3 1
1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
见附件中的 traffic2.in```

### 输出

```
见附件中的 traffic2.ans```

## 样例 #3

### 输入

```
见附件中的 traffic3.in```

### 输出

```
见附件中的 traffic3.ans```

# 题解

## 作者：xieyikai2333 (赞：26)

- [题目传送门](https://www.luogu.com.cn/problem/P8595)

---

## 闲话

- 赛时爆肝 T2，结果 T2 是个紫的没打出来，然后这题没时间了，打了个 $20$ 分的暴力滚蛋了。

---

## 解题思路

- 显然，我们先进行操作 1 再进行操作 2 一定不劣，否则操作 2 连上去的边可能又被炸掉。

- 考虑把森林炸成若干链，然后连起来，显然如果我们炸了 $x$ 条边，那么操作 2 的次数可以表示为 $(n-1)-(m-x)$。于是我们只要**使炸掉的边数（$x$）+炸掉的点数（操作 1 的次数）最小**即可。

- 考虑对于每个无根树随便取个根进行**树形DP**。

### 状态设计

- 设 $dp_{i,0/1/2}$ 表示 $i$ 的子树已经被炸成若干链了且 $\begin{cases}
   \text{这个点被炸了} &0\\
   \text{这个点没有被炸，它的儿子有 1 个连着它} &1\\
   \text{这个点没有被炸，它的儿子有 2 个连着它} &2
   \end{cases}$

### 状态转移

- 约定：记 $son_u$ 为点 $u$ 的儿子集合，$d_u$ 为点 $u$ 的度数，$FIR_{sth}$ 是一类数中的最大值，$SEC_{sth}$ 是一类数中的次大值。

- 对于状态 $0$：
    - 转移方程：
      $$dp_{u,0}=\sum_{v \in son_{u}} \min\{dp_{v,0}-1,dp_{v,2}\}+d_{u}+1$$
    - 解释说明：
        - 如果一个点被炸掉，那么它的子树无论何种情况都可以转移。
        - 之所以 $dp_{v,0}$ 要减去 $1$ 是因为如果 $u$ 和 $v$ 都炸它们之间的边被重复计算了。
        - 之所以不用考虑 $dp_{v,1}$，是因为 $dp_{v,1}$ 一定大于 $dp_{v,2}$，原因由后面会给出的 $dp_{v,2}$ 的转移方程可知。
        - 加上 $d_{u}$ 是因为又炸了 $d_{u}$ 条边，加上 $1$ 是因为又炸了一个点
- 对于状态 $1$：
    - 转移方程：
      $$dp_{u,1}=(\sum_{v \in son_{u}} dp_{v,0})-\max\{0,FIR_{v \in son_{u}}(dp_{v,0}-dp_{v,1})\}$$
    - 解释说明：
        - 由定义，$u$ 的儿子最多有一个不被炸，所以最多有一个儿子状态可以是 $1$ 其他都必须被炸。
- 对于状态 $2$：
    - 转移方程：
      $$dp_{u,2}=dp_{i,1}-\max\{0,SEC_{v \in son_{u}}(dp_{v,0}-dp_{v,1})\}$$
    - 解释说明：
        - 由定义，$u$ 的儿子最多有两个不被炸。在有一个不被炸的基础上再减去第二大的即可。
    - **由转移方程可知，$dp_{u,2} \lt dp_{u,1}$ 显然成立。**
        
### 最终答案

- 约定：$ANS$ 是最终答案，$root$ 是每棵树的根节点组成的集合。

$$ANS=\sum_{u \in root}\min\{dp_{u,0},dp_{u,2}\}$$

至于为什么不用管 $dp_{u,1}$，不用我多说了吧？

---

## 代码实现

好像没什么要注意的细节。。。

**AC 代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int dp[N][3];
bool vis[N];
vector<int> nodes[N];
void dfs(int u)
{
	vis[u]=true;
	int fir=0,sec=0;
	for(int v:nodes[u])
	{
		if(vis[v])continue;
		dfs(v);
		int delta=dp[v][0]-dp[v][1];
		if(delta>fir)sec=fir,fir=delta;
		else if(delta>sec)sec=delta;
		dp[u][0]+=min(dp[v][0]-1,dp[v][2]);
		dp[u][1]+=dp[v][0];
	}
	dp[u][0]+=nodes[u].size()+1;
	dp[u][1]-=fir;
	dp[u][2]=dp[u][1]-sec;
	return;
}
int main()
{
	int n,m;
	scanf("%d %d",&n,&m);
	int ans=(n-1)-m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		nodes[u].push_back(v);
		nodes[v].push_back(u);
	}
	for(int i=1;i<=n;i++)if(!vis[i])dfs(i),ans+=min(dp[i][0],dp[i][2]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Error_Yuan (赞：11)

考虑 DP。

设 $f[u][0/1][0/1]$ 表示将以 $u$ 为根的子树变成一条链的最小操作次数，且是 $(1)$ 否 $(0)$ 对点 $u$ 执行第一种操作，点 $u$ 是否位于链的端点位置。

下面，我们分四种情况讨论转移：

1. 对 $u$ 执行第一种操作。  
此时我们断开了 $u$ 与它所有儿子的连边，所以最后需要再连一些边，具体的操作次数就是 $u$ 的儿子个数。设 $f_0[v]=\min(f[v][0][0],f[v][1][0],f[v][0][1],f[v][1][1])$，则

$$
f[u][1][0]=f[u][1][1]=1+son[u].size+\sum_{v\in son[u]}f_0[v]
$$

2. 对 $u$ 不执行第一种操作。  
有三种转移方案：一是保留 $u$ 的其中一个儿子节点 $v$ 的连边，这要求 $v$ 是链的端点，然后从其他儿子处断开与 $u$ 的连边，这样既可以转移到 $f[u][0][0]$，也可以转移到 $f[u][0][1]$。  
二是保留 $u$ 的两个儿子节点 $v,w$，这要求 $v,w$ 都是链的端点，然后从其他儿子处断边，这样 $u$ 必为链的一个中间点，只能转移到 $f[u][0][0]$。  
最后一种是不保留 $u$ 的任何一个儿子，这种情况下也可以转移到 $f[u][0][0]$ 和 $f[u][0][1]$。

于是我们对于每颗树分别指定一个根做一次 DP，最后的答案就是这些根的 $f_0$ 值之和再加上树的个数减一（就是 $n-m$）。

这种做法的时间复杂度会被菊花图卡到上界，是 $\Theta(n^2)$ 的，仅能通过前 $4$ 个 $\text{Subtask}$，要通过第 $5$ 个 $\text{Subtask}$，我们需要加一些剪枝来优化。

不难发现，复杂度瓶颈在于第二种情况的分类二，这样会多次枚举 $u$ 的儿子，由于儿子 $v$ 对 $u$ 的影响实际上只有 $f[v][0/1][0/1]$ 的值，对于 $f[v][0/1][0/1]$ 的全部相同的两个以上 $v$，我们只需要任意从其中两个选取就行了。这点容易用 map 实现。

总时间复杂度 $\mathcal{O(n \log n)}$

AC 代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 10;

typedef long long ll;

typedef pair<int, int> pii;

struct edge {
	int v, nxt;
} e[MAXN << 1];

int head[MAXN], tot;

void add(int u, int v) {
	e[++tot] = { v, head[u] }, head[u] = tot;
}

int dp[MAXN][2][2];

void dfs(int u, int f) {
	int size = 0, sum1 = 0, sum2 = 0;
	for (int i = head[u], v; i; i = e[i].nxt) {
		v = e[i].v;
		if (v == f) continue;
		dfs(v, u);
		size++;
		sum1 += min(dp[v][0][0], min(dp[v][0][1], min(dp[v][1][0], dp[v][1][1])));
		sum2 += min(dp[v][0][1], dp[v][1][1]);
	}
	if (!size) {
		dp[u][0][0] = 0;
		dp[u][0][1] = 1;
		dp[u][1][0] = dp[u][1][1] = 0x3f3f3f3f;
		return;
	}
	dp[u][0][1] = 1 + size + sum1;
	dp[u][1][1] = 1 + size + sum1;
	dp[u][0][0] = 0x3f3f3f3f;
	for (int i = head[u], v; i; i = e[i].nxt) {
		v = e[i].v;
		if (v == f) continue;
		dp[u][0][0] = min(dp[u][0][0], dp[v][0][0] + sum2 - min(dp[v][0][1], dp[v][1][1]));
	}
	dp[u][0][0] = min(size - 1 + dp[u][0][0], sum2 + size);
	dp[u][1][0] = dp[u][0][0];
	if (size == 1) return ;
	int t = 0x3f3f3f3f;
	map<pair<pii, pii>, int> mp;
	unordered_map<int, bool> mp2;
	for (int i = head[u], v; i; i = e[i].nxt) {
		v = e[i].v;
		if (v == f) continue;
		if (mp[{ { dp[v][0][0], dp[v][0][1] }, { dp[v][1][0], dp[v][1][1] } }]) mp2[v] = 1;
		mp[{ { dp[v][0][0], dp[v][0][1] }, { dp[v][1][0], dp[v][1][1] } }] = v;
	}
	for (auto i = mp.begin(); i != mp.end(); ++i) {
		int v = i->second;
		for (auto j = i; j != mp.end(); ++j) {
			if (!mp2[v] && i == j) continue;
			int w = j->second;
			t = min(t, sum2 - min(dp[v][0][1], dp[v][1][1]) - min(dp[w][0][1], dp[w][1][1]) + dp[v][0][0] + dp[w][0][0]);
		}
	}
	dp[u][1][0] = min(dp[u][1][0], t + size - 2);
}

int fa[MAXN];

int find(int k) {
	return k == fa[k] ? k : fa[k] = find(fa[k]);
}

void merge(int x, int y) {
	if ((x = find(x)) ^ (y = find(y))) fa[x] = y;
}

int n, m, cnt, ans;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) fa[i] = i;
	for (int i = 1, u, v; i <= m; i++) scanf("%d%d", &u, &v), add(u, v), add(v, u), merge(u, v);
	for (int i = 1; i <= n; i++) {
		if (find(i) == i) {
			cnt++;
			dfs(i, 0);
			ans += min({ dp[i][0][0], dp[i][1][0], dp[i][0][1], dp[i][1][1] });
		}
	}
	printf("%d", ans + cnt - 1);
}

```

---

## 作者：快斗游鹿 (赞：9)

出题人题解。

------------
#### 思路

考虑操作进行顺序。可以证明，先进行操作 $1$ 一定不会比先进行操作 $2$ 更劣。因为先连的边后面也有可能被炸毁，那么这次连边操作就是无意义的。因此，我们应该先考虑将每个连通块炸成若干条链，最后再将它们连接起来。

假设点 $u$ 的子树已经被炸成若干条链。

定义 $f_{u,0}$ 表示点 $u$ 本身被炸了的最小代价。

定义 $f_{u,1}$ 表示点 $u$ 没有被炸且与它的父亲有连边的最小代价。

定义 $f_{u,2}$ 表示点 $u$ 没有被炸且与它的父亲没有连边的最小代价。

考虑转移。记 $d_u$ 为点 $u$ 度数。


对于 $f_{u,0}$，其代价为本次被炸掉的边数加一，因为最后还需要把这几条边连上。而其儿子可以选择被炸或不保留其与父亲的连边。如果其儿子被炸了，那么它连向它儿子的那条边就已经被炸过了，它现有的边数就要减一。得到转移方程为 $f_{u,0}=\sum_{v\in son[u]} \min(f_{v,0}-1,f_{v,2})+d_u+1$。

定义 $cost_v$ 为 $f_{v,0}-f_{v,1}$。假设点 $u$ 的儿子是点 $v$，记 $F_u$ 为点 $u$ 所有儿子中最大的 $cost_v$。$S_u$ 为点 $u$ 所有儿子中次大的 $cost_v$。

对于 $f_{u,1}$，它最多就只能和一个儿子保留连边，其它儿子都要炸掉。那么显然，应当保留代价最小的那个儿子。得到转移方程为 $f_{u,1}=\sum_{v\in son[u]}f_{v,0}-F_u$。

对于 $f_{u,2}$，它最多就只能和两个儿子保留连边，其它儿子都要炸掉。则只需在保留一个儿子的基础上，再保留一个代价次小的儿子就行了。得到转移方程为 $f_{u,2}=f_{u,1}-S_u$。

假设每棵树根节点为 $u$，最后每棵树的答案即为 $\min(f_{u,0},f_{u,2})$。

最终答案为每棵树的答案加上树的棵数减一。

总时间复杂度为 $O(n)$。

---

## 作者：LittleMoMol (赞：7)

## 前言

看了第一篇题解才会的，自己写一个详细的加深印象。

[更差的阅读体验](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution_LuoGu_P8595.html)

## 定义

树形 $DP$，这个挺明显的，我认为 $DP$ 让读者理解的最重要的一步是：定义。

所以我先详细说明 $f$ 数组的定义，至于为什么这么定义后面再讲。

$f_{u, type}$，其中 $type=0,1,2$ 

$f_{u,0}$ 表示：在原森林中，以 $u$ 为根节点的子树变成链的最小代价，其中 $u$ **必须被**炸掉。

$f_{u,1}$ 表示：在原森林中，以 $u$ 为根节点的子树变成链的最小代价，其中 $u$ **必须不被**炸掉，且 $u$ **最多**有一个儿子。

$f_{u,2}$ 表示：在原森林中，以 $u$ 为根节点的子树变成链的最小代价，其中 $u$ **必须不被**炸掉，且 $u$ **最多**有两个儿子。

## 为什么这样定义

首先，一个节点炸或者不炸，是会影响它向父亲节点转移的，所以必须分类：炸掉、不炸掉。

而一个点如果不被炸掉，那么它应该有几个儿子呢？可以**一个都没有**，所有儿子都被炸掉；可以**有一个或者两个**，对应链的情况。**如果有超过三个儿子，那么不可能形成链。**

所以就先这么定义，看看能不能转移。

## 状态转移方程

### 类型 0

考虑 $f_{u,0}$ 的状态转移方程。

首先，$u$ 点必须被炸掉，所以**代价加一**。

其次，炸了 $u$ 之后，$u$ 有几个儿子就需要再连几条边，因为最后要形成链，所以**代价加上 $u$ 的儿子数量**。

最后，你还需要把儿子节点的信息传递上来，由于炸了 $u$ 之后，$u$ 和它的所有儿子都不联通，那么 $u$ 的儿子的类型是几并不重要，那么代价还需要加上 $\sum\limits_{v\in son_u } \min(f_{v,0}-1, f_{v,1}, f_{v,2})$ 

为什么有一项是 $f_{v,0}-1$？为啥要减一？因为在之前遍历到 $v$ 的时候，$u,v$ 之间的边被炸了一次；现在炸 $u$ 的时候，$u,v$ 之间的边又被炸了一次，重复了。

我们令 $d_u$ 表示 $u$ 的儿子的数量，那么 $f_{u,0} = \sum\limits_{v\in son_u } \min(f_{v,0}-1, f_{v,1}, f_{v,2}) + d_u + 1$

### 类型 1

首先，$u$ 不能被炸，如果让 $u$ 只剩下 $1$ 个儿子，我们可以来一个简单的容斥。

先把 $u$ 的所有儿子都炸掉，然后选择一个儿子恢复，当然有可能不选，因为是**最多一个儿子**。

考虑第一步，代价很简单，为 $\sum\limits_{v\in son_u} f_{v,0}$ 

对于第二步，我们要挑选一个 $v$，先将代价减去 $f_{v,0}$ ，表示我不炸这个 $v$ 了，让它留着做 $u$ 的儿子；再将代价加上 $f_{v,1}$，表示将信息转移到父亲，至于为什么和 $f_{v,2}$ 没有关系，后面再说。

所以儿子都炸完之后，我们要找一个最大的 $f_{v,0} - f_{v,1}$，让原来的代价减去它,即为最终代价，如果所有的 $f_{v,0} - f_{v,1}$ 都小于零，那就不要儿子了，因为要上儿子只能使代价变大。

为什么和 $f_{v,2}$ 没有关系？因为不可能由 $f_{v,2}$ 转移过来，因为一个点有一个儿子，而这个儿子又有两个儿子，那么肯定不可能组成一条链，如果还不懂的话，我画个图：

![如果你可以什么操作都不做把它画成一条链我就当场认爹](https://cdn.luogu.com.cn/upload/image_hosting/4xqoilgt.png)

所以状态转移方程为：$f_{u,1} = \sum\limits_{v\in son_u} f_{v,0} - \max(0, \max_{v\in son_u}(f_{v,0} - f_{v,1}))$

### 类型 2

这个简单，在类型 1 的基础上再减去一个次大的大于零的 $f_{v,0} - f_{v,1}$ 即可。

即 $f_{u,2} = f_{u,1} - \max(0, SEC_{v \in son_u}(f_{v,0} - f_{v,1}))$ （这里的 $SEC$ 指第二大的数）

### 整理

$f_{u,0} = \sum\limits_{v\in son_u } \min(f_{v,0}-1, f_{v,1}, f_{v,2}) + d_u + 1$

$f_{u,1} = \sum\limits_{v\in son_u} f_{v,0} - \max(0, \max_{v\in son_u}(f_{v,0} - f_{v,1}))$

$f_{u,2} = f_{u,1} - \max(0, SEC_{v \in son_u}(f_{v,0} - f_{v,1}))$ 

## 求答案

首先对于每一棵树，我们的答案很显然：为 $\min(f_{u,0}, f_{u,1}, f_{u,2})$，但这是一个森林，所以我们还需要加上一些边让整森林变成一颗大树，加边数量为：$n-1-m$，即总共需要 $n-1$ 条边，题目给了 $m$ 条边，那么还需要再加上 $n-1-m$ 条边

所以 $Ans = \sum\limits_{u\in root} \min(f_{u,0}, f_{u,1}, f_{u,2}) + n - 1 - m$

### code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 2e6 + 10, M = 2 * N;

int n, m, ans;
int h[N], e[M], ne[M], idx;
int d[N], f[N][3];
bool vis[N];

int read()
{
	int s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		s = s * 10 + c - '0';
		c = getchar();
	}
	return s * w;
}

void add(int a, int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx ++ ;
	return;
}

void dfs(int u)
{
	vis[u] = true;
	int fir = 0, sec = 0;
	for (int i = h[u]; ~i; i = ne[i])
	{
		int ver = e[i];
		if (vis[ver]) continue;
		dfs(ver); 
		int delta = f[ver][0] - f[ver][1];
		if (delta > fir) sec = fir, fir = delta;
		else if (delta > sec) sec = delta;
		f[u][0] += min(f[ver][0] - 1, min(f[ver][1], f[ver][2]));
		f[u][1] += f[ver][0];
	}
	f[u][0] += d[u] + 1;
	f[u][1] -= fir;
	f[u][2] = f[u][1] - sec;
	return;
}

int main()
{
	n = read(), m = read();
	ans = (n - 1) - m;
	memset(h, -1, sizeof h);
	for (int i = 1; i <= m; i ++ )
	{
		int a, b;
		a = read(), b = read();
		add(a, b);
		add(b, a);
		d[a] ++ ;
		d[b] ++ ;
	}
	for (int i = 1; i <= n; i ++ )
	{
		if (!vis[i]) 
		{
			dfs(i);
			ans += min(f[i][0], min(f[i][1], f[i][2]));
		}
	}
	cout << ans << endl;
	return 0;
}

/*
   _____
  /     \
 /  'v'  \
/  __O__  \
\____|____/
*/
```

---

## 作者：anonymous_person (赞：7)

### KDOI 官方题解  

显然，一边删点一边连边一定不比先删点再连边优，那么这一题就可以转化为求把一个森林通过删除操作变为许多链的情况下，执行删除操作的个数和删掉的边的个数的和 $k$ 的最小值，最终的答案即为 $n-1-m+k_{min}$。  
先考虑森林中的一棵树。
假设我们 $(a,b)$ 表示一条链以结点 $a$、结点 $b$ 为首尾的链，$\text{LCA}(a,b)$ 表示结点 $a$、结点 $b$ 的最近公共祖先。  
我们可以发现，如果想要保证这一棵树被分为了许多条链，那么一个结点 $u$ 可以被区分为以下三种情况：  
情况①：结点 $u$ 被删除。  
情况②：结点 $u$ 未删除，且有一条满足 $\text{LCA}(a,b)=a$ 或 $\text{LCA}(a,b)=b$ 的链 $(a,b)$ 经过结点 $u$。  
情况③：结点 $u$ 未删除，且有一条满足 $\text{LCA}(a,b)\neq a$ 且 $\text{LCA}(a,b)\neq b$ 的链 $(a,b)$ 经过结点 $u$。  
故而可以使用树形DP来求解 $k_{min}$，令 $dp[u][x]$ 维护以 $u$ 为根的子树中，达成情况 $x$，在该子树内执行删除操作的个数和删掉的和该子树中结点相连的边的个数的最小值。  
当 $x=0$ 时，表示 $u$ 结点被删除，即 $dp[u][0]$ 维护情况①。  
当 $x=1$ 时，表示 $u$ 结点未被删除，$u$ 结点的子结点中最多有一个未被删除，即 $dp[u][1]$ 维护情况②。  
当 $x=2$ 时，表示 $u$ 结点未被删除，$u$ 结点的子结点中最多有两个个未被删除，即 $dp[u][2]$ 维护情况②和情况③的最小值。  
下面我们考虑转移  
令 $m1$ 表示 $\forall v\in{son[u]}$，$dp[v][1]-dp[v][0]$ 的最小值，$m2$ 表示 $\forall v\in{son[u]}$，$dp[v][1]-dp[v][0]$ 的次小值，此处的含义是找到可以向上接的链中，最优和次优的两条。  
记 $cnt_{u}$ 表示结点 $u$ 的度数，对于 $dp[u][0]$，其初始值为 $cnt_{u}+1$，注意当结点 $u$ 和结点 $v$ 均被删除时，需要对连接结点 $u$ 和结点 $v$ 的边进行去重，易得  
$$
dp[u][0]=\sum_{v\in{son[u]}}{\min\{dp[v][0]-1,dp[v][2]\}}
$$
对于 $dp[u][1]$，最多从子结点中找到一个为情况②的结点，接上其所维护的那条链，易得  
$$
dp[u][1]=\min\{0,m1\}+\sum_{v\in{son[u]}}{dp[v][0]}
$$
对于 $dp[u][1]$，对于其中的情况③，我们需要从子结点中找到两个个为情况②的结点，接上其所维护的那条链，即 $m2+dp[u][1]$ 即可，易得  
$$
dp[u][2]=\min\{0,m2\}+dp[u][1]
$$
完整代码如下  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NUM=2000005;
int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
int n,m,num,head[NUM],dp[NUM][3],siz[NUM];
bool vis[NUM];
struct edge
{
    int next,to;
}e[NUM<<1];
void add_edge(int from,int to)
{
    siz[to]++;
    e[++num].next=head[from];
    e[num].to=to;
    head[from]=num;
}
void dfs(int u)
{
    int v,m1=0,m2=0;
    dp[u][0]=siz[u]+1;
    vis[u]=true;
    for(int i=head[u];i;i=e[i].next)
    {
        v=e[i].to;
        if(!vis[v])
        {
            dfs(v);
            dp[u][1]+=dp[v][0];
            if(m1>dp[v][1]-dp[v][0])
            {
                m2=m1;
                m1=dp[v][1]-dp[v][0];
            }
            else m2=min(m2,dp[v][1]-dp[v][0]);
            dp[u][0]+=min(dp[v][2],dp[v][0]-1);
        }
    }
    dp[u][1]+=m1;
    dp[u][2]=dp[u][1];
    dp[u][2]+=m2;
}
int main()
{
    int u,v,ans=0;
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        u=read(),v=read();
        add_edge(u,v),add_edge(v,u);
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            dfs(i);
            ans+=min(dp[i][0],dp[i][2]);
        }
    }
    printf("%d",n-1-m+ans);
}
```


---

## 作者：ღꦿ࿐ (赞：4)

一眼丁真鉴定为 难度贴近 CSPT3（？），简单题。

$O(n)  \ \text{solution}$

题意：

给你一片森林，你需要进行最少的操作次数把他变成链。

* 删除一个点周围的所有存在的边

* 连接一条边

---

先分析性质：

最后的链之间是联通的，所以最后所有连通块会被联通到一起，需要 $n - 1- m$ 条边，这些边应该在最后被链接，因为在之前连接两个不同连通块不会产生更优秀的决策。 

所以我们的策略应该是先把每个联通块做成一条链，最后在合起来。

连通块之间独立，考虑如何计算连通块。

有两类操作不好统计，试图把第二类操作给绑定在第一类上。

连接显然只会连接两条链的两个端点，否则肯定不优。

我们一定是把每个连通块炸成若干条链，最后再连起来，连接次数为炸掉的边数。

每一条边被炸掉都会分离出两个连通块，在后来需要用一条边连接以将连通块数减少 1 ， 所以我们可以把代价归到第一类操作上。


* 删除一个点周围所有存在的边，其代价为删除的边数 + 1

1 表示本次操作代价，其它删除的边都会增加一次二类操作的代价。

---

然后就可以非常简单地 dp 了 ， 发现子树特征信息只和这个点的状态相关，所以记录下这个点的状态即可。

$f_{i,0}$ 表示炸掉这个点的，子树内形成若干链的最小代价。

$f_{i,1}$ 表示不炸掉这个点，且保留父亲和他连边（即儿子内只能连最多一条边）的代价。

$f_{i,2}$ 表示不炸掉这个点，且不保留父亲和他连边（即儿子内只能最多两条边）的代价。

初值：

$f_{leaf,0} = 2 , f_{leaf,1} = f_{leaf,2} = 0$ ， leaf 为叶子。

转移：

$f_{u,0} = \sum_{\text{s is a son of u}} \min\{f_{son,0} - 1,f_{son,2}\}$
 
儿子可以选择炸或者不保留父亲之间的边，如果炸的话要减去父亲 -> 儿子这条连边，因为儿子炸掉后父亲不用炸了。

$f_{u,1} =\min \sum_{\text{s is a son of u} , \sum_{t_s}\leq 1} f_{s,t_s} (t_s\in\{0,1\})$

$f_{u,2} =\min \sum_{\text{s is a son of u} , \sum_{t_s}\leq 2} f_{s,t_s} (t_s\in\{0,1\})$

感觉这个转移用文字阐述比式子方便的多。

如果和父亲之间保留了连边，最多就只能和一个儿子保留连边，其它儿子都要炸掉。

如果和父亲之间保留了连边，最多就只能和两个儿子保留连边，其它儿子都要炸掉。

具体转移可以选择求出 $f_{s,1} - f_{s,0}$ 的最大值和次大值，也可以选择做一个大小为 1 和 2 的背包 ， 题解直接懒，使用了 sort ， 故代码复杂度是  $O(n \log n)$ ， 使用 nth_element 即可做到 $O(n)$ 。

代码（只放了dfs）

```cpp
void dfs(int x,int fa) {
    vis[x] = 1; 
    if(ed[x].size() == 0 || (ed[x][0] == fa && ed[x].size( ) == 1) )  {
        f[x][0] = 2; f[x][1] = 0 ; f[x][2] = 0 ;
        return ; // 这里写的很臭，其实不用初值的。
    }
    Array sv ; 
    f[x][0] = (int)ed[x].size( ) + 1 , f[x][1] = 0 , f[x][2] = 0;
    for(int p:ed[x]) {
        if(p == fa) continue;
        dfs(p , x) ;
        f[x][0] += min(f[p][0] - 1 , f[p][2]);
        f[x][1] += f[p][0] ;
        f[x][2] += f[p][0] ; 
        sv.emplace_back(f[p][1] - f[p][0]); 
    }    
    sort(sv.begin( ) , sv.end( )) ;
    /*you can change it to nth_element , then it's O(n)*/
    f[x][1] += min(sv[0] , 0) ;
    f[x][2] += min(sv[0] , 0) ;
    (sv.size() > 1) && (f[x][2] += min(sv[1] , 0));
}

```
[完整版 | 三月月可爱](https://www.luogu.com.cn/paste/hogk6hkc)


---

## 作者：_farawaystar_ (赞：3)

#### 闲话

(在打模拟赛的过程中， A 掉了 T1 ，极度兴奋，揪住T3就一顿胡搞……结果喜提 20pts ，回来好好读了一下题……用了不到一个小时思路加代码都出来了然后就 A 掉了……)

------------

#### 关于题意

~~本题最大难点~~注意这个是删除**每一个点上的所有边**而不是其中一条

#### 解题思路

树型 DP ，**线性**时间复杂度，注意该题**卡常**，需要优化读入。

每次找一个**没有访问过的节点**当做根节点进行 DP 。

具体方法就是对当前节点（只考虑**当前节点子树的贡献**不需要考虑和父亲的关系）分 4 种情况进行分类讨论：

1. $f[x][0]$ 自己炸掉；

2. $f[x][1]$ 自己不炸但是与儿子无连边；

3. $f[x][2]$ 自己不炸只与一个儿子有连边；

4. $f[x][3]$ 自己不炸与两个儿子有连边。

不会有再多了，再多就**不可能成链**了。

其中:

$f[x][0]=(\sum\limits_{u∈son[x]}^{}\min(f[u][0],f[u][1],f[u][2],f[u][3])+1)+1$

$f[x][1]=\sum\limits_{u∈son[x]}^{}f[u][0]+1$

情况 $0$ ：节点不会与儿子的 $4$ 种情况发生冲突。对每一个儿子 $+1$ 的原因是炸掉之后每一个儿子都需要再次连边。最后 $+1$ 是爆炸当前点的贡献 。

情况 $1$ : 只能将每一个儿子的第一种情况 $+1$ 作为贡献。该情况**与儿子没有连边**而且**自己没炸掉**则必然儿子都被炸掉了。

情况 $2$ : 在 $1$ 的基础上，保留 $1$ 个儿子即可。这时，我们只需要计算出每一个儿子的 $\min(f[son][1],f[son][2])-f[son][0]-1$ （**计算保留哪一个儿子最合算**）选取最大的再加上 $f[x][1]$ 即可。该情况下，因为要与那个儿子有连边，所以该儿子不能是情况 $0$ （炸掉就没边了）和情况 $3$ （无法成链），其它情况不冲突。 

情况 $3$ : 同情况 $2$ ，比情况 $2$ 要多选一个**次大值**计入贡献。

最后记录 $ans$ 为 $\min(f[rt][0],f[rt][1],f[rt][2],f[rt][3])$ 的和。

答案就是 $ans+n-m-1$ (上面是对**单棵树**计算，最后需要把森林连成一棵树)。

```cpp
#include<iostream>
#include<cstdio>
#define N 2000006
using namespace std;
int n,m,to[2*N],last[2*N],nx[2*N],tot,f[N][4],ans;
bool opt[N];
void add(int x,int y){
	to[++tot]=y;
	nx[tot]=last[x];
	last[x]=tot;
}
void dp(int x,int fa){
	opt[x]=1;
	int son=0,mi=N,mi2;
	for(int i=last[x];i;i=nx[i]){
		if(to[i]==fa)continue;
		son++;
		dp(to[i],x);
		f[x][0]+=min(min(f[to[i]][0]+1,f[to[i]][1]+1),min(f[to[i]][2]+1,f[to[i]][3]+1));
		f[x][1]+=f[to[i]][0]+1;
		if(min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1<mi){
			mi2=mi;
			mi=min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1;
		}
		else if(min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1<mi2)mi2=min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1;
		f[x][3]=f[x][2]=f[x][1];
		f[x][2]+=mi;
		f[x][3]+=mi+mi2;
	}
	f[x][0]++;
	if(!son)f[x][2]=f[x][3]=N;
	else if(son==1)f[x][3]=N;
}
int main(){
	cin>>n>>m;
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!opt[i]){
			dp(i,0);
			ans+=min(min(f[i][0],f[i][1]),min(f[i][2],f[i][3]));
		}
	cout<<ans+n-m-1;
	return 0;
}
//无向图，记得开2倍空间
```

### 祝 CSP 大捷！ rp++

---

## 作者：佬头 (赞：2)

## Description

有一片 $n$ 个节点 $m$ 条无向边组成的[**森林**](https://www.luogu.com.cn/problem/P8595)（很多棵树）。用以下 $2$ 种操作：  
- **炸点**：炸毁点 $u$ 向外连接的所有边。
- **连边**：在点 $u,v$ 间新建一条双向边。  

将这片森林改成效率最低的形式：一条链。要求你给出一种方案，使得操作的次数最少，并输出最少的操作次数。

## Solution

如果先**连边**再**炸点**可能会导致原先连的边被炸掉，那么前面的**连边**操作就是无效的，因此选择先炸完所有要炸的点再将它们连起来。

考虑对每个无根树随便取个根进行**树形 DP**（$i$ 可能存在的父节点不被算在以 $i$ 为根的子树中）。
- $dp_{i,0}$ 表示以 $i$ 为根的子树被操作成一条链且点 $i$ 被炸（与它可能存在的父节点无连边）的最少操作次数。
- $dp_{i,1}$ 表示以 $i$ 为根的子树被操作成一条链（点 $i$ 在链的一端）且点 $i$ 没被炸（与它可能存在的父节点有连边）的最少操作次数。
- $dp_{i,2}$ 表示以 $i$ 为根的子树被操作成一条链（点 $i$ 在链的中间）且点 $i$ 没被炸（与它可能存在的父节点有连边）的最少操作次数。

可以将 $dp_{i,1}$ 和 $dp_{i,2}$ 看成同一类。把 $i$ 的 $k$ 个子节点 $x$ 都炸掉（即 $dp_{x,0}$ 的情况）就可以连成一条链了，显然这并不是最优的，因为可能 $dp_{x,0}+1\gt dp_{x,1}$，此时需要有所保留。

对于 $dp_{i,1}$ 我们需要找一个**要保留的** $x'$（若存在），使得 $dp_{x',0}+1-dp_{x',1}$ 最大，则
$$dp_{i,1}=(\sum_{j=1}^{k}dp_{x_j,0}+1)-(dp_{x',0}+1-dp_{x',1})$$

而对于 $dp_{i,2}$ 我们需要再找一个**要保留的** $x''$（若存在），使得 $dp_{x'',0}+1-dp_{x'',1}$ 次大，则
$$\begin{aligned}dp_{i,2}&=(\sum_{j=1}^{k}dp_{x_j,0}+1)-(dp_{x',0}+1-dp_{x',1})-(dp_{x'',0}+1-dp_{x'',1})\\&=dp_{i,1}-(dp_{x'',0}+1-dp_{x'',1})\end{aligned}$$

由于 $dp_{i,0}$ 表示的这条链与 $i$（根节点除外）的父节点无连边，因此 $dp_{i,0}+1$ 也就可以表示 $dp_{i,1}$ 和 $dp_{i,2}$ 了，而所有边需要在炸完点之后连，则应当在 $dp_{i,0}\lt dp_{i,2}$ 时将 $dp_{i,2}$ 更新为 $dp_{i,0}$。显然 $dp_{i,2}\le dp_{i,1}$，因此 $dp_{i,1}$ 就不必更新了。那么
$$\begin{aligned}dp_{i,0}&=\sum_{j=1}^{k}\min(dp_{x_j,0},dp_{x_j,2})+1\\&=\sum_{j=1}^{k}dp_{x_j,2}+1\end{aligned}$$ 

设一共有 $w$ 棵树，每棵树根节点取为 $q$，把他们连起来的代价为 $w-1$，最终答案就是
$$(\sum\limits_{x=1}^{w}dp_{q_x,2})+w-1=(\sum\limits_{x=1}^{w}dp_{q_x,2}+1)-1$$

时间复杂度 $\mathcal{O}(n)$。

## Code

```cpp
#include <iostream>
using namespace std;
const int N = 2000006;
int n, m, head[N], nex[N<<1], to[N<<1], cnt, dp[N][3], ans;
bool vis[N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
void add(int &a, int &b){
	to[++ cnt] = b;
	nex[cnt] = head[a];
	head[a] = cnt;
}
void dfs(int &x){
	dp[x][0] = vis[x] = 1;
	int max1 = 0, max2 = 0;
	for(int i = head[x]; i; i = nex[i])
		if(!vis[to[i]]){
			dfs(to[i]);
			dp[x][0] += dp[to[i]][2] + 1;
			dp[x][1] += dp[to[i]][0] + 1;
			if(dp[to[i]][0] + 1 - dp[to[i]][1] > max1) max2 = max1, max1 = dp[to[i]][0] + 1 - dp[to[i]][1];
			else if(dp[to[i]][0] + 1 - dp[to[i]][1] > max2) max2 = dp[to[i]][0] + 1 - dp[to[i]][1];
		}
	dp[x][1] -= max1;
	dp[x][2] = dp[x][1] - max2;
	if(dp[x][0] < dp[x][2]) dp[x][2] = dp[x][0];
}
int main(){
	n = read(), m = read();
	for(int i = 1; i <= m; ++ i){
		int u = read(), v = read();
		add(u, v), add(v, u);
	}
	for(int i = 1; i <= n; ++ i) if(!vis[i]) dfs(i), ans += dp[i][2] + 1;
	write(ans - 1);
	return 0;
}
```
~~补一发蓝题题解。~~

---

## 作者：Demon_master (赞：2)

## P8595 「KDOI-02」一个网的路

## 序章

考虑将不同的树分开单独看，最后再合起来，这一定是可以的。

书上问题，考虑树形 $DP$ ，设 $dp[i][0,1]$ 表示当前节点炸或者不炸，使其子树变成一条链所用的最小操作数。

设节点 $u$ 为节点 $v$ 的儿子，有转移方程：
$
dp_{v,0}=\sum\limits_u \min(dp_{u,0}+1,dp_{u,1}+1)+1\\
dp_{v,1}=\sum\limits_u \min(dp_{u,0}+1,dp_{u,1})+K
$
其中对于第二个转移方程，解释如下：

当前节点不爆炸则可以保留至多两个儿子节点来减少操作数，所以 $K$ 表示最小的两个 $dp_{u,1}-(dp_{u,0}+1)$ ，当然，这个$K$ 也一定是要小于 $0$ 的，不然选择儿子节点爆炸最优。

**然后**当某人拿着这个转移方程开开心心地去跑大样例时，发现结果比答案少（某人绝望了便去吃了顿饭，回来继续考试）。

观察转移方程，我们发现状态少了一个维度，即当前树所成的链是否以当前节点为根，看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/p9qaqxrx.png)

我们可以发现在之前的定义中，有 $dp_{1,1}=0$ ，我们在更新节点 $4$ 时，会有 $dp_{4,1}=0$ 这显然是不合适的，因为若操作数为 $0$ 则当前数不可能变为链。

## 正片开始

设 $dp[i][0/1/2]$ 分别表示节点 $i$ 爆炸变为链，没爆炸变为链且以当前节点为链头，没爆炸且当前节点不是（有可能是）链头

所以有转移方程：

$dp[s][0]= \sum \min(min(dp[t][2],dp[t][0]),dp[t][1])+1$

$dp[s][1]=\sum (dp[t][0]+1)+\min(K_1,0)$

$dp[s][2]=\sum (dp[t][0]+1)+\min(K_1,0)+\min(K_2,0)$

其中 $K_1,K_2$ 表示 $dp[t][1]-(dp[t][0]+1)$ 的最小两个值。

#### CODE

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
using namespace std;
const ll maxn = 2e6+3;
inline ll read_int(){
	ll a=0;bool f=0;char g=getchar();
	while(g<'0'||'9'<g) {if(g=='-') f=1;g=getchar();}
	while('0'<=g&&g<='9') a=a*10+g-'0',g=getchar();
	return f ? -a : a;
}

inline void write(ll a,bool b=1){
	if(a<0) a=-a,putchar('-');
	ll lin[30],top=0;
	while(a) lin[++top]=a%10,a/=10;
	if(top==0) lin[++top]=0;
	while(top) putchar(lin[top--]+'0');
	if(b) putchar('\n');
}

ll n,m;
struct E{
    ll t,n;
}edge[maxn*2];
ll l,head[maxn];
ll dp[maxn][3];
ll vis[maxn];
ll jl[maxn];

inline void DP(ll s,ll fa){
    vis[s]=1;
    dp[s][1]=1;
    for(ll i=head[s];i;i=edge[i].n){
        ll t=edge[i].t;
        if(t==fa) continue;
        DP(t,s);
        dp[s][1]+=min(min(dp[t][2],dp[t][0]),dp[t][1])+1;
    }
    ll cnt=0;
    jl[1]=1e9,jl[2]=1e9;
    for(ll i=head[s];i;i=edge[i].n){
        ll t=edge[i].t;
        if(t==fa) continue;
        dp[s][0]+=dp[t][1]+1;
        jl[++cnt]=dp[t][0]-dp[t][1]-1;
    }
    sort(jl+1,jl+1+cnt);
    dp[s][0]=(dp[s][0]+min(jl[1],0ll));
    dp[s][2]=(dp[s][0]+min(jl[2],0ll));
}

inline void read(){
    n=read_int(),m=read_int();
    for(ll i=1;i<=m;i++){
        ll t=read_int(),f=read_int();
        l++,edge[l]=(E){t,head[f]},head[f]=l;
        l++,edge[l]=(E){f,head[t]},head[t]=l;
    }
    ll ans=-1;
    for(ll i=1;i<=n;i++){
        if(vis[i]) continue;
        DP(i,i);
        ans+=min(dp[i][1],min(dp[i][0],dp[i][2]))+1;
    }
    write(ans);
}

int main (){
    read();
}
```



## 结尾

某人由于将 $2e6$ 打成了 $1e6$ ，喜提 $100$ 变 $85$ 


---

## 作者：CHNZhang (赞：1)

## 写在前面

本人在赛时把`void`写成了`int`，本地没报错，交上去炸了，直接100->5。
```cpp
inline int add(int u,int v)
{
	to[++tot]=v;
	nex[tot]=hd[u];
	hd[u]=tot;
}
```
大概就是这种效果。

提醒大家（主要是我自己）要避免这种错误（虽然大家可能都很细心）。

## 大体思路


题目给出了一个森林，若其中有$x$棵树，我们在将所有的树都变成链后，再进行$x-1$次操作就可以让图变为一条链。

我们考虑如何计算一棵树需要的操作次数。

我们考虑树形DP。

## 状态转移

设 $f[i][0/1][0/1]$ ，下面是每一维的含义。
* 第一维中的 $i$ 代表编号为 $i$ 的节点。
* 第二维如果为 $0$ ，代表以 $i$ 为根节点的子树被变成了一条链， $1$ 代表   $i$ 有两个儿子，且以那两个儿子为根节点的子树是一条链。
* 第三维如果为 $0$ ，代表我们没有炸毁 $i$ 向外联接的所有道路，如果为 $1$ ，代表我们炸毁了 $i$ 向外联接的所有道路。

接下来是怎么转移。

我们设 $i$ 为当前的节点， $u$ 为其子节点。

* 如果 $i$ 是叶节点，那么 $f[i][0][0]$ 和$ f[i][1][0]$ 为 $0$ ， $f[i][0][1]$ 和 $f[i][1][1]$ 为 $1$ 。
* 如果 $i$ 是非叶节点， $f[i][0][1]$ 和 $f[i][1][1]$ 都等于 $f[u][0][0]+1$ 、 $f[u][0][1]+1$ 、 $f[u][1][0]+1$ 、 $f[u][1][1]+1$ 中的最小值的和。这个转移比较直观， $+1$ 是因为 $i$ 到其子节点的路被切断了，所以要重建。
* 对于 $f[i][0][0]$ ，至多存在一个子节点， $i$ 与其之间的边未被切断。我们可以先认为 $i$ 与其所有子节点之间的边都被切断， $f[i][0][0]$ 的值**暂时**等于 $f[u][0][1]+1$ 和 $f[u][1][1]+1$ 中的最小值的和。同时我们记录   $1+min(f[u]][0][1],f[u][1][1])-f[u][0][0]$ 的最大值 $mx1$ ，这个式子的含义是保证以 $u$ 为根节点的子树是一条链，保留 $i$ 与 $u$ 之间的通路，与断开 $i$ 与 $u$ 之间的通路相比，能节省的操作次数。我们将 $f[i][0][0]-mx1$ 即为最少的操作次数。
* 对于 $f[i][1][0]$ ，转移与上一条相似，我们记录 $1+min(f[u]][0][1],f[u][1][1])-f[u][0][0]$ 的次最大值 $mx2$ ，其他步骤不变，将 $f[i][1][0]-mx1-mx2$ 即可。

以上保证 $mx1$ 与 $mx2$ 不小于 $0$ 。

## 计算答案

对于每一棵树，我们设树根为 $root$ ，这棵树的操作次数就是 $f[root][0][0]$ ， $f[root][1][0]$ ， $f[root][0][1]$ ， $f[root][1][1]$ 中的最小值。

找出森林中有多少棵树相对简单，我是每次以一个为访问的点为根进行树形DP，每一个点被访问后进行标记。

答案就是每棵树的次数的和加树的数量减1。

每个点仅被访问一次，没有使用STL，复杂度为 $O(n)$ 。

```cpp
#include<bits/stdc++.h>
#define rint register int
#define LL long long int
using namespace std;
inline int read()
{
	int x = 0, ff = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') ff = -ff; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * ff;
}
int hd[2000005],nex[4000005],to[4000005],tot,vis[2000005];
inline void add(int u,int v)
{
	to[++tot]=v;
	nex[tot]=hd[u];
	hd[u]=tot;
}
int n,m,f[2000005][2][2];//编号为i的点，形态(0-链)(1-二叉树)，是否爆炸(0-不炸)(1-爆炸) 
void solve(int u,int pre)
{
	if(vis[u]==1)return ;
	f[u][0][0]=f[u][1][0]=0;
	f[u][0][1]=f[u][1][1]=1;
	vis[u]=1;
	int i,ok=0;
	int dx=0,ddx=0,nw;
	for(i=hd[u];i;i=nex[i])
	{
		if(to[i]!=pre)
		{
			ok=1;	
			solve(to[i],u);
			f[u][0][1]+=1+min(min(f[to[i]][0][0],f[to[i]][0][1]),min(f[to[i]][1][0],f[to[i]][1][1]));
			f[u][1][1]+=1+min(min(f[to[i]][0][0],f[to[i]][0][1]),min(f[to[i]][1][0],f[to[i]][1][1]));
			f[u][0][0]+=1+min(f[to[i]][0][1],f[to[i]][1][1]);
			f[u][1][0]+=1+min(f[to[i]][0][1],f[to[i]][1][1]);
			nw=1+min(f[to[i]][0][1],f[to[i]][1][1])-f[to[i]][0][0];
			if(nw>dx)
			{
				ddx=dx;
				dx=nw;
			}
			else if(nw>ddx)
			{
				ddx=nw;
			}
		}	
	} 
	if(ok==0)
	{
		return ;
	}
	f[u][0][0]-=dx;
	f[u][1][0]-=dx+ddx;
}
int main()
{
	//freopen("traffic3.in","r",stdin);
	rint i,j,u,v,cnt=0,ans=0;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		u=read();v=read();
		add(u,v);
		add(v,u);
	}
	for(i=1;i<=n;i++)
	{
		if(vis[i]==0)
		{
			solve(i,0);
			ans+=min(min(f[i][0][0],f[i][0][1]),min(f[i][1][0],f[i][1][1]));
			cnt++;
		}
	}
	//cout<<cnt<<endl;
	cout<<ans+cnt-1<<endl;
	return 0;
}

```


---

## 作者：lsj2009 (赞：1)

## Problem

给定一个 $n$ 点 $m$ 边的森林，可以进行若干次如下两种操作的一种：

1. 连接一条边 $(u,v)$。
2. 把所有与点 $u$ 直接相连的点 $v$ 之间的边 $(u,v)$ 全部断掉。

求至少进行多少次操作可以使该森林变成一条链。

## Solution

首先约定：对于森林中的每一棵树的根节点为该树中编号最小的节点，并以 $R$ 表示所有根的集合，以 $S_u$ 表示 $u$ 的儿子集合。

显然是一道树型 DP。

首先对于任意一个点 $u$ 至多会对其进行 $1$ 次操作二。原因显然：如果断掉的边有且仅有原图上的边，则断一次就可以全部断掉；如果断掉的边中有新建的边，则还不如不连这条边。

所以赛时第一反应是定义状态 $f_{u,0/1}$ 表示将 $u$ 及其子树变成一条以 $u$ 为根的链且会(不会)对点 $u$ 进行操作二的最少步数。则答案就是 $(\sum\limits_{u\in R} \min\{f_{u,0},f_{u,1}\}+1)-1$？（把每条链头尾相接）。

然而这样少了一种情况。不妨看下图：

![](https://s1.ax1x.com/2022/10/23/xgzqM9.png)

显然如果按上述说，则答案为 $2$(断掉边 $(1,2)$，连上边 $(2,3)$)，但是，如果我们把这棵树以 $3$(或 $2$)为根节点，则可以看到该树本身就是一条链。

或许有人认为解决这种情况的方法是令 $2$(或 $3$)为树的根节点。然而这十分难操作，这里讲一下我的方法：显然这样子的情况大抵可以概括成以点 $u$ 为根的子树中，$u$ 的左子树是一条链，$u$ 的右子树也是一条链。则我们不妨再定义状态 $f_{u,2}$ 表示刚才所述的状态。

转移方程可见赛时代码。

## Code


``` cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
//#define int long long
#define PII pair<int,int>
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=2e6+5;
int head[N],len;
struct node {
	int to,nxt;
}; node edge[N<<1];
void add_edge(int u,int v) {
	edge[++len]={v,head[u]}; head[u]=len;
}
int f[N][3],ans;
bool used[N];
void dfs(int u,int from) {
	used[u]=true;
	//solve f[u][0] - 叉掉 u
	int tot=0,minn1=INF,minn2=INF,cnt=0;
	f[u][0]=1; f[u][2]=INF;
	for(int i=head[u];i;i=edge[i].nxt) {
		int v=edge[i].to;
		if(v!=from) {
			dfs(v,u); f[u][0]+=min(f[v][0],min(f[v][1],f[v][2]))+1; tot+=f[v][0]+1; ++cnt;
			int val=f[v][1]-(f[v][0]+1);
			if(val<minn1)
				minn2=minn1,minn1=val;
			else if(val<minn2)
				minn2=val;
		}
	}
	//solve f[u][1] - 不叉掉 u,但叉掉所有的儿子
	f[u][1]=tot;
	//solve f[u][1] - 不叉掉 u,保留一条主链
	f[u][1]=min(f[u][1],tot+minn1);
	//solve f[u][2] - 不叉掉 u,保留两条链
	if(cnt>=2)
		f[u][2]=min(f[u][2],tot+minn1+minn2);
//	printf("(%d,%d) %d %d %d\n",u,from,f[u][0],f[u][1],f[u][2]);
}
signed main() {
	int n,m;
	scanf("%d%d",&n,&m);
	rep(i,1,m) {
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
		add_edge(v,u);
	}
	rep(i,1,n) {
		if(!used[i]) {
			dfs(i,0); ans+=min(f[i][0],min(f[i][1],f[i][2]))+1;
		}
	}
	printf("%d\n",ans-1);
	return 0;
}
```

---

## 作者：404Not_Found (赞：0)

CSP 前一天涨 rp。

场外选手淦了两个小时 A 掉了，考场我大概做不出来。

考虑先把每个连通块变成链，最后再把每个连通块连起来，这样一定是不劣的。

考虑一个对每一棵树树形 dp。一棵树形成一条链，有下面几种情况：

1. 一个孤点

2. 根节点只有一个儿子

3. 根节点有两个儿子

不妨以这些作为 dp 的状态，其中第 $1$ 种情况还有两种可能：自己被炸，所有儿子被炸。

状态设计：

$f(u,0)$：$u$ 炸了，没有儿子。

$f(u,1)$：$u$ 没炸，没有儿子。

$f(u,2)$：$u$ 没炸，有一个儿子。

$f(u,3)$：$u$ 没炸，有两个儿子。

先把转移方程写出来吧：

$$f(u,0)=1+\sum_{v\in \rm{son}(u)}(\min\{f(v,0),f(v,1),f(v,2),f(v,3)\}+1)$$

这个比较显然，$u$ 炸了那么儿子任何时候都是可以转移的。每个儿子 $+1$ 是因为还要连边。外面的 $+1$ 是炸自己的代价。

$$f(u,1)=\sum_{v \in \rm{son}(u)} (f(v,0)+1)$$


$u$ 不炸就只能是每个儿子炸了。

$$f(u,2)=f(u,1)+\min_{v\in \rm{son}(u)}(\min\{f(v,1),f(v,2)\}-f(v,0)-1)$$

贪心地想，我们当然要保留代价最小的儿子；在 $f(u,1)$ 的基础上加上新的代价，$f(v,1)$ 和 $f(v,2)$ 都是可以转移的，而 $f(v,0)$ 会导致 $u,v$ 不连通，$f(v,2)$ 就不是一条链了。不能选。同时也要减去 $f(u,1)$ 中 $f(v,0)$ 转移来的部分。

$f(u,3)$ 同理，只是还要记录次小值。

时间复杂度：$\mathcal{O}(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6+5;
struct edge{
	int to,nxt;
} e[N<<1];
int head[N],cnt;
inline void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int n,m,ans;
int f[N][4],vis[N];
void dfs(int u,int fa)
{
	vis[u]=1; int mn1=1e9,mn2=1e9;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		f[u][0]+=min({f[v][0],f[v][1],f[v][2],f[v][3]})+1;
		f[u][1]+=f[v][0]+1;
		if(min(f[v][1],f[v][2])-f[v][0]-1<mn1){mn2=mn1;mn1=min(f[v][1],f[v][2])-f[v][0]-1;}
		else if(min(f[v][1],f[v][2])-f[v][0]-1<mn2){mn2=min(f[v][1],f[v][2])-f[v][0]-1;}
	}
	f[u][0]++;
	f[u][2]+=f[u][1]+mn1; f[u][3]+=f[u][1]+mn1+mn2;
}
int main()
{
	freopen("traffic2.in","r",stdin);
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v); add(v,u);
	}
	for(int i=1;i<=n;i++)
		if(!vis[i]){dfs(i,0);ans+=min({f[i][0],f[i][1],f[i][2],f[i][3]});}
	printf("%d\n",ans+n-1-m);
	return 0;
}
```













---


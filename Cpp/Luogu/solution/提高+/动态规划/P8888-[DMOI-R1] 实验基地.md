# [DMOI-R1] 实验基地

## 题目背景

小 A 和小 B 用实验基地全新的装备进行了一场世纪蒟蒻之战。

## 题目描述

众所周知，实验基地的武器都是一次性的。现在，小 A 选取了 $n$ 把不同的武器，小 B 也获取了 $m$ 把不同武器。每个人的武器都可以用编号 $1$ 到编号 $n$ 或 $m$ 依次表示，他们将会按此顺序逐个使用武器。

实验仓库记录了所有武器的火力。小 A 的第 $k$ 把武器能爆发出 $a_k$ 的能量，而小 B 的第 $k$ 把武器能爆发出 $b_k$ 的能量。特别的，当小 A 的第 $i$ 把武器与小 B 的第 $j$ 把武器同时使用，会释放 $d_{i,j}$ 的能量。由于某些不可描述的组合的奇效，$a,b,d$ **都可能小于** $0$。

当某人第一个使用了武器，战斗就正式开始，记为第 $1$ 秒，直至某人使用完武器后再无人使用武器,记此时为第 $t$ 秒（$t$ **不为输入数据**）。也就是说，**在第 $1$ 秒和第 $t$ 秒必须有人使用武器，而在 $1$ 至 $t$ 秒内在符合其他条件下，每一秒双方可以选择按顺序使用武器或不使用**。

为了避免打死对方，**双方都不一定使用完武器**。

由于实验基地有发电装置，如果小 A 没有连续使用武器释放能量，而是休息了 $x$ 秒，那么祂将会吸收掉  $Ax+B\ (A,B \in \mathbb{N})$ 的能量。同样，小 B 间隔 $y$ 秒将吸收 $Cy+D\ (C,D \in \mathbb{N})$ 的能量。连续两秒都释放武器间隔时间为 $0$ 秒，以此类推。

为了防止基地被核爆，你需要算出战斗结束后可能释放的最大总能量（可能为负数）。

**若对题目细节有疑惑请先读提示内的额外解释。**

## 说明/提示

1. 战斗的开始时间（第 $1$ 秒）为双方某人最先释放出第一个技能的时间，战斗结束时间为双方某人释放出最后一个技能的时间。**结束时间不定**。

2. 技能必须按顺序释放，但**不一定需要在战斗中释放完**。

3. $a,b,d$ 可以为负数，总计能量可能为负，“吸收能量”指总能量减少 $Ax+B$ 或 $Cy+D$，也就是**间隔时总能量一定减少**，而且时间越长减少越多。

4. 本题 IO 量较大，建议使用合适的读入方式。

### 样例解释：

样例 1：每个人在 $1$ 到 $6$ 秒依次使用自己的编号为 $1$ 到 $6$  的武器即可取到最大值。

样例 2：小 B 在 $1$ 到 $4$ 秒依次使用自己的编号为 $1$ 到 $4$ 的武器，小 A 在第 $4$ 秒使用自己的 $1$ 号武器可以取到最大值。其中单个武器释放的能量为 $(-2)+(2+3+4+9) = 16$，武器碰撞释放 $d_{1,4} = 4$ 单位的能量，小 A 在前 $3$ 秒吸收了 $A \times 3 + B = 5$ 单位的能量。

### 数据范围：

|Subtask|$n\leq$|$m\leq$|分值|
|-|-|-|-|
|$1$|$10$|$10$|$20$|
|$2$|$500$|$500$|$30$|
|$3$|$3000$|$3000$|$50$|

**本题采用捆绑测试**，您只有通过了一个 Subtask 中的所有测试点才能得到这个 Subtask 的分数。

对于 $100\%$ 的数据：$0 \le |a_k|,|b_k|,|d_{i,j}|,A,B,C,D \leq 1000$, $1\leq n, m\leq 3000$。

## 样例 #1

### 输入

```
7 6
1 9 1 9 8 1 0
1 1 4 5 1 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
1 0 1 0```

### 输出

```
45```

## 样例 #2

### 输入

```
4 4
-2 -2 -2 -2
2 3 4 9
4 -2 0 4
0 0 0 0
-1 0 1 0
0 0 2 0
1 2 1 0```

### 输出

```
15```

# 题解

## 作者：NightTide (赞：12)

## [DMOI] 官方题解

### 20pts

首先能够发现性质，由于 $A,B,C,D$ 均为正数，所以一定不可能出现某一个时刻两个人都没有使用武器的情况。

然后开始打爆搜，每个时刻有三种情况，同时记录下每个人距离上次使用武器的时间。

时间复杂度 $O(3^{n + m})$，期望得分 20pts。

### 50pts

根据上面说的性质我们能够发现，总时间不会超过 $n + m$。考虑用动态规划：

设 $dp_{i,j,k}$ 表示在时刻 $i$，小 $A$ 用了 $j$ 把武器，小 $B$ 用了 $k$ 把武器所释放的最大能量。

根据上面说的性质，上一秒一定有至少一个人用了武器。

不妨分三种情况讨论：

1. 上一秒二人一起用
2. 上一秒只有小 $A$ 用武器
3. 上一秒只有小 $B$ 用武器

第一种情况直接转移，后两种情况枚举另一个人上一次使用武器的时间进行转移，时间复杂度 $O(n^4)$。

发现可以使用单调栈辅助转移，转移优化到 $O(1)$，时间复杂度优化到 $O(n^3)$，期望得分 50pts。

### 100pts

由于吸收的能量与休息时间成一次函数关系，时间一维其实可以薅掉。

设 $dp_{i,j,0/1,0/1}$ 表示小 $A$ 用了 $i$ 把武器，小 $B$ 用了 $j$ 把武器。后面两维分别表示当前时刻小 $A$ 是 $/$ 否使用了武器，当前时刻小 $B$ 是 $/$ 否使用了武器。

其他的贡献的计算都很简单，主要是能量吸收量的计算。以小 $A$ 为例。

先考虑 $B = 0$ 的情况。

若小 $A$ 当前时刻没有使用武器。小 $A$ 的休息时间相当于多了 $1$ 个单位时间，那么他就会再吸收 $A$ 的能量。

直接在转移的时候减去 $A$ 就好。

但是 $B \not= 0$ 怎么办？

发现加吸收 $B$ 的能量的次数与休息的次数是一致的，我们在转移的时候可以钦定一个规则：当上一时刻使用了武器，但是当前时刻没有使用武器，那么小 $A$ 的休息次数就会加 $1$，此时就减去 $B$。

具体实现参见代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 3001
#define INF 0x3f3f3f3f
using namespace std;
int n, m, A, B, C, D;
int a[MAXN], b[MAXN], d[MAXN][MAXN];
int dp[MAXN][MAXN][2][2];
inline int read(){
   int s = 0, w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){ if(ch == '-') w = -1; ch = getchar(); }
   while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
   return s * w;
}
int main(){
    // freopen("data.in", "r", stdin);
    // freopen("std.txt", "w", stdout);
    n = read(); m = read();
    for(int i = 1; i <= n; i++) a[i] = read(); //scanf("%d",&a[i]);
    for(int i = 1; i <= m; i++) b[i] = read(); //scanf("%d",&b[i]);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            // scanf("%d",&d[i][j]);
            d[i][j] = read();
        }
    }
    scanf("%d%d%d%d",&A,&B,&C,&D);
    memset(dp, -0x3f, sizeof(dp));
    dp[1][0][1][0] = a[1] - C - D;
    dp[0][1][0][1] = b[1] - A - B;
    dp[1][1][1][1] = a[1] + b[1] + d[1][1];
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= m; j++){
            if(i != 0){
                // dp[i][j][1][0];
                dp[i + 1][j][1][0] = max(dp[i + 1][j][1][0], dp[i][j][1][0] + a[i + 1] - C);
                dp[i][j + 1][0][1] = max(dp[i][j + 1][0][1], dp[i][j][1][0] + b[j + 1] - A - B);
                dp[i + 1][j + 1][1][1] = max(dp[i + 1][j + 1][1][1], dp[i][j][1][0] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]);
            }
            if(j != 0){
                // dp[i][j][0][1];
                dp[i + 1][j][1][0] = max(dp[i + 1][j][1][0], dp[i][j][0][1] + a[i + 1] - C - D);
                dp[i][j + 1][0][1] = max(dp[i][j + 1][0][1], dp[i][j][0][1] + b[j + 1] - A);
                dp[i + 1][j + 1][1][1] = max(dp[i + 1][j + 1][1][1], dp[i][j][0][1] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]);
            }
            if(i != 0 && j != 0){
                // dp[i][j][1][1];
                dp[i + 1][j][1][0] = max(dp[i + 1][j][1][0], dp[i][j][1][1] + a[i + 1] - C - D);
                dp[i][j + 1][0][1] = max(dp[i][j + 1][0][1], dp[i][j][1][1] + b[j + 1] - A - B);
                dp[i + 1][j + 1][1][1] = max(dp[i + 1][j + 1][1][1], dp[i][j][1][1] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]);
            }
        }
    }
    int ans = -INF;
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= m; j++){
            ans = max(ans, dp[i][j][1][0]);
            ans = max(ans, dp[i][j][0][1]);
            ans = max(ans, dp[i][j][1][1]);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：玉树临风英俊潇洒 (赞：2)

哇！ P8888 竟然还能交题解！

废话不多说，直接进入主题。

- # 题目大意
  这题还算是讲的很清楚。两个人放技能，同时放技能会有 buff ，如果有一秒没放会倒扣能量。
- # 解决思路
  由题目可知：一旦没放技能能量一定会减少，所以没有时间间隔，每秒至少有一个人放技能。

  数组 $F$ 表示小 A 用了 $i$ 把武器，小 B 用了 $j$ 把武器，$c=0$ 两者都没休息，$c=1$ 表示 $i$ 休息，$c=2$ 表示 $j$ 休息。（这样可以省去第四维）

  **注意**题目中的 $B$ 和 $D$ 不带参数，所以实际上每增加一秒只会减少 $A$ 或 $C$ 的能量。

  **注意**分类讨论，一定不要漏情况。

  最后暴力取最大值就行，还有数组一定要初始化。
- # 代码实现
  因为这题给了我们比较多的时间所以不需要快读。

```cpp
#include<bits/stdc++.h>
#define N 3001
#define inf 1e9
using namespace std;
int n,m;
int f[N][N][3]; //0 两者都没休息，1 i休息，2 j 休息
int a[N],b[N],d[N][N],A,B,C,D,ans=-inf;
main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=m;i++)
        cin>>b[i];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>d[i][j];
    cin>>A>>B>>C>>D;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            f[i][j][0]=f[i][j][1]=f[i][j][2]=-inf;
    f[0][0][0]=0;
    f[1][0][2]=a[1]-C-D;
    f[0][1][1]=b[1]-A-B;
    ans=max(f[1][1][0],max(f[1][0][2],f[0][1][1]));
    for(int i=2;i<=n;i++)f[i][0][2]=f[i-1][0][2]+a[i]-C,ans=max(ans,f[i][0][2]);
    for(int i=2;i<=m;i++)f[0][i][1]=f[0][i-1][1]+b[i]-A,ans=max(ans,f[0][i][1]);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j][0]=max(f[i-1][j-1][0],max(f[i-1][j-1][1],f[i-1][j-1][2]))+d[i][j]+a[i]+b[j];
            f[i][j][1]=max(f[i][j-1][0]-A-B,max(f[i][j-1][1]-A,f[i][j-1][2]-A-B))+b[j];
            f[i][j][2]=max(f[i-1][j][0]-C-D,max(f[i-1][j][2]-C,f[i-1][j][1]-C-D))+a[i];
            ans=max(max(ans,f[i][j][0]),max(f[i][j][1],f[i][j][2]));
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Aiden604 (赞：1)

本题解适用于刚学动态规划的萌新。
# 题目大意
两人每秒可使用一个武器，使用将释放能量，不使用能量将被吸收。
# 分析
通过 $n,m$ 的数据范围可知时间复杂度约是 $O(n^2)$ 。\
因为每一秒的状态都可以被转移，所以考虑 **动态规划** 。\
由于 $A,B,C,D$ 为正整数，所以每等待的时间越长，被吸收的能量肯定就越多。如果两人这一秒都不用武器，那么纯属浪费能量，所以**每秒至少有一人释放技能**。（这样就不用考虑时间一维了。）
### 定义状态
根据上面的分析,不难可以想出， $dp_{i,j,0/1,0/1}$ 代表小 A 用了 $i$ 把武器，小 B 用了 $j$ 把武器，小 A 这时是否用了武器，小 B 是否用了武器。
### 状态转移
注意细节！ $B,D$ 的系数是 $1$ 。意思是例如小 A 刚开始休息（前一秒在使用武器）被吸收能量为 $A+B$ ，而休息的第 $2$ 秒开始被吸收能量就为 $A$ 了。\
**分类讨论**
- $i \neq 0$ 时，可以由 $dp_{i,j,1,0}$ 转移。
- $j \neq 0$ 时，还可以由 $dp_{i,j,0,1}$ 转移。
- $i \neq 0 \& j \neq 0$ 时，还可以由 $dp_{i,j,1,1}$ 转移。

（因为不可能在使用武器的时候，使用武器的数量等于 $0$ 。）\
**具体见代码，注释很详细**。
### 初始化
因为上面的状态转移没有从 $dp_{0,0,0/1,0/1}$ 转移的步骤，所以得手写初始化。
# 代码

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N=3005;
const int nINF=-0x7f7f7f7f;
int a[N],b[N],d[N][N],A,B,C,D;
int dp[N][N][2][2];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	/*输入*/
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>b[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>d[i][j];
	}
	cin>>A>>B>>C>>D;
	/*dp*/
	memset(dp,-0x7f,sizeof(dp));//初始化为极小值
	
	//因为下面没有从dp[0][0]转移的步骤，所以得手写初始化
	dp[1][0][1][0]=a[1]-(C+D);//小A使用武器，小B开始休息1秒，要减(1*C+D)
	dp[0][1][0][1]=b[1]-(A+B);//小B使用武器，小A开始休息1秒，要减(1*A+B)
	dp[1][1][1][1]=a[1]+b[1]+d[1][1];//小A小B同时使用武器，不用减
	for(int i=0;i<=n;i++){//小A已使用i个武器
		for(int j=0;j<=m;j++){//小B已使用第j个武器
			if(i!=0){/*分类讨论*/
				/*那么可以从dp[i][j][1][0]转移*/
				//小A使用武器，小B继续休息1秒，只用减1*C
				dp[i+1][j][1][0]=max(dp[i+1][j][1][0],dp[i][j][1][0]+a[i+1]-C);
				//小B使用武器，小A开始休息1秒，要减(1*A+B)
				dp[i][j+1][0][1]=max(dp[i][j+1][0][1],dp[i][j][1][0]+b[j+1]-(A+B));
				//小A小B同时使用武器，不用减（记得加d[i][j]，下同）
				dp[i+1][j+1][1][1]=max(dp[i+1][j+1][1][1],dp[i][j][1][0]+a[i+1]+b[j+1]+d[i+1][j+1]);
			}
			if(j!=0){/*不要用else if!*/
				/*那么可以从dp[i][j][0][1]转移*/
				//小A使用武器，小B开始休息1秒，要减(1*C+D)
				dp[i+1][j][1][0]=max(dp[i+1][j][1][0],dp[i][j][0][1]+a[i+1]-(C+D));
				//小B使用武器，小A继续休息1秒，只用减1*A
				dp[i][j+1][0][1]=max(dp[i][j+1][0][1],dp[i][j][0][1]+b[j+1]-A);
				//小A小B同时使用武器，不用减
				dp[i+1][j+1][1][1]=max(dp[i+1][j+1][1][1],dp[i][j][0][1]+a[i+1]+b[j+1]+d[i+1][j+1]);
			}
			if(i!=0&&j!=0){
				/*那么可以从dp[i][j][1][1]转移*/
				//小A使用武器,小B开始休息1秒，要减(1*C+D)
				dp[i+1][j][1][0]=max(dp[i+1][j][1][0],dp[i][j][1][1]+a[i+1]-(C+D));
				//小B使用武器，小A开始休息1秒，要减(1*A+B)
				dp[i][j+1][0][1]=max(dp[i][j+1][0][1],dp[i][j][1][1]+b[j+1]-(A+B));
				//小A小B同时使用武器，不用减
				dp[i+1][j+1][1][1]=max(dp[i+1][j+1][1][1],dp[i][j][1][1]+a[i+1]+b[j+1]+d[i+1][j+1]);
			}
		}
	}
	//计算dp的最大值
	int ans=nINF;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++) ans=max({ans,dp[i][j][1][0],dp[i][j][0][1],dp[i][j][1][1]});//加个大括号即可将多个数据一起max
	}
	cout<<ans;//完结撒花~
	return 0;
}
```
对于合适的读入方式，我选择的是 `ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);` 。

---

## 作者：许多 (赞：0)

前言：被题号吸引过来的。


小清新 DP 题。

首先我们不难发现一个性质：在任意时刻不存在小 A 和小 B 都不使用武器，很好证明，在上一秒二人停止作战或在这一秒使用武器必然比该策略更优。

我们设 $f_{i,j,0/1/2}$ 表示目前小 A 使用了 $i$ 个武器，小 B 使用了 $j$ 个武器释放的最大总能量。其中在这一秒内，$0$ 双方都没休息，$1$ 表示小 A 休息，$2$ 表示小 B 休息。

对于 $i=0$ 和 $j=0$ 的情况我们单独处理，不难得到状态转移方程：

$f_{i,0,2}=f_{i-1,0,2}+a_i-C$。

$f_{0,i,1}=f_{0,i-1,1}+b_i-A$。

而剩余情况就也比较好推，处理一下两人是否是在**本秒内开始**休息即可。

```cpp
f[i][j][0]=max(f[i-1][j-1][0],max(f[i-1][j-1][1],f[i-1][j-1][2]))+d[i][j]+a[i]+b[j];
f[i][j][1]=max(f[i][j-1][0]-A-B,max(f[i][j-1][1]-A,f[i][j-1][2]-A-B))+b[j];
f[i][j][2]=max(f[i-1][j][0]-C-D,max(f[i-1][j][2]-C,f[i-1][j][1]-C-D))+a[i];
```

---

## 作者：Melo_DDD (赞：0)

冲着题号来的（刚交了 P8887 的题解），动规好题。

# 题目大意

两个人放技能，同时放技能会有 buff，如果有一秒没放会倒扣能量。

# 题目实现

注意题目中的 $A,B,C,D\in\N$，所以**一旦没放技能能量一定会减少**，由此尽量让两个人尽快放完技能，因此咱们就不用考虑间隔的问题了（每秒至少有一个人放技能），直接暴力循环动规即可。

考虑转移方程：

- 初始：$dp_{i ,j ,k}$ 表示第 $i$ 时刻小 A 用了 $j$ 个，小 B 用了 $k$ 个时的最大能量。

- 发现数组大小将近 $10^{10}$，肯定会炸，考虑优化。

- 发现第一维的时刻可以滚掉，改为 $dp_{i,j,1/0,1/0}$，$1/0$ 表示此时用或没用技能。

注意题目中的 $B$ 和 $D$ 不带参数，所以实际上每增加一秒只会减少 $A$ 或 $C$ 的能量。

注意分类讨论，一定不要漏情况。

最后暴力取最大值就行，还有数组一定要初始化。

``本题 IO 量较大，建议使用合适的读入方式。``

我选择快读。

## 代码：

感觉挺清晰的，有不懂的看代码应该就能明白。

```cpp
#include <bits/stdc++.h> 
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define maxx(a ,b ,c ,d ,e) max (max (max (max (a ,b) ,c) ,d) ,e)
using namespace std ;
const int N = 3e3 + 7 ;
int n ,m ,a[N] ,b[N] ,d[N][N] ,dp[N][N][2][2] ,ans = INT_MIN ,aa ,bb ,c ,dd ;
inline int read () {
	char ch = getchar () ,f = 0 ;
	int t = 0 ;
	for ( ;ch < '0' or ch > '9' ;ch = getchar ()) {
		if (! (ch ^ 45)) f = 1 ;
	}
	for ( ;ch >= '0' and ch <= '9' ;ch = getchar ()) {
		t = (t << 1) + (t << 3) + (ch ^ 48) ;
	}
	return f ? - t : t ;
}
namespace shin {
	inline void init () {
		dp[1][0][1][0] = a[1] - c - dd ;
		dp[0][1][0][1] = b[1] - aa - bb ;
		dp[1][1][1][1] = a[1] + b[1] + d[1][1] ;
	}
	inline void get_ans () {
		rep (i ,0 ,n ,1) {
			rep (j ,0 ,m ,1) {
				if (i) {
					dp[i + 1][j][1][0] = max (dp[i + 1][j][1][0] ,dp[i][j][1][0] + a[i + 1] - c) ;
					dp[i][j + 1][0][1] = max (dp[i][j + 1][0][1] ,dp[i][j][1][0] + b[j + 1] - aa - bb) ;
					dp[i + 1][j + 1][1][1] = max (dp[i + 1][j + 1][1][1] ,dp[i][j][1][0] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]) ;
				}
				if (j) {
					dp[i][j + 1][0][1] = max (dp[i][j + 1][0][1] ,dp[i][j][0][1] + b[j + 1] - aa) ;
					dp[i + 1][j][1][0] = max (dp[i + 1][j][1][0] ,dp[i][j][0][1] + a[i + 1] - c - dd) ;
					dp[i + 1][j + 1][1][1] = max (dp[i + 1][j + 1][1][1] ,dp[i][j][0][1] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]) ;
				}
				if (i and j) {
					dp[i][j + 1][0][1] = max (dp[i][j + 1][0][1] ,dp[i][j][1][1] + b[j + 1] - aa - bb) ;
					dp[i + 1][j][1][0] = max (dp[i + 1][j][1][0] ,dp[i][j][1][1] + a[i + 1] - c - dd) ;
					dp[i + 1][j + 1][1][1] = max (dp[i + 1][j + 1][1][1] ,dp[i][j][1][1] + a[i + 1] + b[j + 1] + d[i + 1][j + 1]) ;
				}
			}
		}
	}
}
int main () {
	n = read () ;
	m = read () ;
	rep (i ,1 ,n ,1) {
		a[i] = read () ;
	}
	rep (i ,1 ,m ,1) {
		b[i] = read () ;
	}
	rep (i ,1 ,n ,1) {
		rep (j ,1 ,m ,1) {
			d[i][j] = read () ;
		}
	}
	aa = read () ;
	bb = read () ;
	c = read () ;
	dd = read () ;
	memset (dp ,-0x3f ,sizeof (dp)) ;
	shin :: init () ;
	shin :: get_ans () ;
	rep (i ,0 ,n ,1) {
		rep (j ,0 ,m ,1) {
			ans = maxx (ans ,dp[i][j][0][0] ,dp[i][j][0][1] ,dp[i][j][1][0] ,dp[i][j][1][1]) ;
		}
	}
	cout << ans << '\n' ;
	#define kafka try //卡妈\se\se
	return 0 ;
}
```

###### 你是否承认卡芙卡和狼谷的美貌举世无双？

---


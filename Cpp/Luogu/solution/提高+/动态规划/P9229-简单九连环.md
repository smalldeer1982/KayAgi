# 简单九连环

## 题目背景

**提示：此题有大样例。**

**提示：本题中的九连环与传统九连环不同。**

九连环是一种源于中国的传统智力游戏。如图所示，九个的圆环套在一把“剑”上，并且互相牵连。

![](https://cdn.luogu.com.cn/upload/pic/17568.png)

在传统的九连环中，第 $k(k\ge 2)$ 个环可以装上“剑”（记为 $1$）或拆下“剑”（记为 $0$），当且仅当第 $k-1$ 个环在剑上，且再之前的环不在剑上；特别地，第 $1$ 个环可以任意上下。

本题中我们将会讨论更一般的情形，虽然这种简单九连环不一定可以在物理意义上造出。

## 题目描述

一个简单九连环，可以看作两个 `01` 串——规则串 $s$ 和状态串 $t$，满足 $|s|=|t|-1$。其中 $t_i = \texttt 1$ 表示第 $i$ 个环是装上的，$t_i = \texttt 0$ 表示第 $i$ 个环是拆下的。

$s$ 在同一局游戏中是不变的，而 $t$ 每步会变化一个位置上的值（从 `0` 变成 `1` 或从 `1` 变成 `0`）。简单九连环被拆下，当且仅当 $t_i$ 全是 `0`；简单九连环被装上，当且仅当 $t_i$ 全是 `1`。

简单九连环规定，$t_i$ 可以变化，当且仅当 $t_{1\sim i-1}$ 是 $s$ 的一个**后缀**。可以看出，传统的九连环就是 $s$ 为 `00...01` 的特殊情形。

给出一个 $s$，问从拆下状态到装上状态至少需要几步，答案对 $10^9+7$ 取模。

## 说明/提示

### 样例 1 解释

初始时刻所有环都不在简单九连环的剑上，状态串 $t$ 为 `0000`。

第 1 步装上第 $1$ 个环，$t$ 变成 `1000`。

第 2 步装上第 $2$ 个环，$t$ 变成 `1100`。

第 3 步装上第 $3$ 个环，$t$ 变成 `1110`。

接下来你不能直接装上第 $4$ 个环，因为 `111` 并不是规则串 $s$ `011` 的后缀。因此第 4 步应拆下第 $1$ 个环，$t$ 变成 `0110`。

然后第 5 步装上第 $4$ 个环，$t$ 变成 `0111`。

最后一步装上第 $1$ 个环，$t$ 变成 `1111`，完成目标。

### 样例 2 解释

这就是传统的九连环，且恰好有 $9$ 个环。

### 样例 3 解释

样例 3 满足测试点 $7$ 的限制。

### 样例 4 解释

样例 4 满足测试点 $15$ 的限制。

### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 2000$，$s_i\in\{\texttt 0,\texttt 1\}$。

|测试点编号|$\vert s\vert\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 3$|$3$||
|$4\sim 6$|$15$||
|$7\sim 11$|$300$||
|$12\sim 13$|$1000$||
|$14$|$2000$|$s_i$ 全为 `0`|
|$15\sim 17$|$2000$|$s$ 末尾为 `1`，其余位置为 `0`|
|$18\sim 25$|$2000$||

## 样例 #1

### 输入

```
3
011
```

### 输出

```
6
```

## 样例 #2

### 输入

```
8
00000001
```

### 输出

```
341
```

## 样例 #3

### 输入

```
见附件中的 samples/rings3.in```

### 输出

```
见附件中的 samples/rings3.ans```

## 样例 #4

### 输入

```
见附件中的 samples/rings4.in```

### 输出

```
见附件中的 samples/rings4.ans```

# 题解

## 作者：Graphcity (赞：14)

看到这种跟汉诺塔非常像的解谜游戏，首先就是需要拆解它们的步骤。大体的步骤分三步：

1. 把前面 $n$ 个字符变成规则串。
2. 消耗一步装上第 $n+1$ 个环。
3. 把前面 $n$ 个字符变成 `11111...` 的形式。

我们设 $f(x,y,z)$ 表示考虑前 $x$ 个字符，当前状态是后缀 $y$（$y=0$ 表示全零，$y=n+1$ 表示全一），最终需要变成后缀 $z$ 的所需步数。那么答案就等于 $f(n,0,n)+1+f(n,n,n+1)$。

- 对于 $f(n,0,n)$

我们从后往前扫描，如果当前的字符和最终这个位置需要的字符一致则跳过。此时我们找到了第一个不符的位置 $i$，我们需要对它进行一次变换。进行变换就必须得让前 $i-1$ 个字符变成规则串长为 $i-1$ 的后缀，变换完后再改成目标状态。

写成式子就是 $f(n,0,n)=f(i-1,0,i-1)+1+f(i-1,i-1,n)$。

- 对于 $f(n,n,n+1)$

我们还是从后往前扫描到第一个不符合的位置，然后再对它进行变换。类似的，可以得到 $f(n,n,n+1)=f(i-1,n,i-1)+1+f(i-1,i-1,n+1)$。

我们注意到这个三维的状态中每一步都有一组数字是相同的。自然地，设 $f(x,y)=f(x,y,x)$，$g(x,y)=f(x,x,y)$，那么可以得到：
$$
\begin{cases}
f(x,y)&=f(i-1,y)+1+g(i-1,x)\\
g(x,y)&=f(i-1,x)+1+g(i-1,y)
\end{cases}
$$

使用记搜实现，状态有 $O(n^2)$ 种，每次扫描时间 $O(n)$，总时间复杂度 $O(n^3)$，跑的很快。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e3,Mod=1e9+7;

int n,ans,s[Maxn+5];
int f[Maxn+5][Maxn+5],g[Maxn+5][Maxn+5];
bool fv[Maxn+5][Maxn+5],gv[Maxn+5][Maxn+5];
int F(int x,int y);
int G(int x,int y);

inline int Get(int x,int y)
{
    if(x==0) return 0; if(x==n+1) return 1;
    return s[n-(x-y)];
}
inline int F(int x,int y)
{
    if(x==0) return 0;
    if(fv[x][y]) return f[x][y];
    int res=0;
    for(int i=x;i;i--) if(Get(x,i)!=Get(y,i))
        {res=(F(i-1,y)+1+G(i-1,x))%Mod; break;}
    fv[x][y]=1,f[x][y]=res; return res;
}
inline int G(int x,int y)
{
    if(x==0) return 0;
    if(gv[x][y]) return g[x][y];
    int res=0;
    for(int i=x;i;i--) if(Get(x,i)!=Get(y,i))
        {res=(F(i-1,x)+1+G(i-1,y))%Mod; break;}
    gv[x][y]=1,g[x][y]=res; return res;
}

int main()
{
    scanf("%d",&n);
    For(i,1,n) scanf("%1d",&s[i]);
    ans=(F(n,0)+1+G(n,n+1))%Mod;
    cout<<ans<<endl;
    return 0;
}
```

注意到一个时间复杂度瓶颈在于扫描上。事实上，扫描需要解决的问题就是一个串不同前缀的最长公共后缀。我们再设一个动态规划数组 $h(x,y)$ 表示前缀 $x,y$ 的最长公共后缀。有转移
$$
\begin{cases}
h(x,y)&=h(x-1,y-1)+1 & s_x=s_y,x>0,y>0\\
h(x,0)=h(0,x)&=h(0,x-1)+1 & s_x=0,x>0\\
h(x,n+1)=h(n+1,x)&=h(n+1,x-1)+1 & s_x=1,x>0
\end{cases}
$$
注意第二，三种转移应放到第一种转移后进行，否则会出现冲突。总时间复杂度 $O(n^2)$，但时间效率反而不如上面的代码。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e3,Mod=1e9+7;

int n,ans,s[Maxn+5],h[Maxn+5][Maxn+5];
int f[Maxn+5][Maxn+5],g[Maxn+5][Maxn+5];
bool fv[Maxn+5][Maxn+5],gv[Maxn+5][Maxn+5];
int F(int x,int y);
int G(int x,int y);

inline int F(int x,int y)
{
    if(x==0) return 0;
    if(fv[x][y]) return f[x][y];
    int res=0,id=(y>=1 && y<=n?n-(y-x):y);
    int len=min(x,h[n][id]),i=x-len;
    if(i) res=(F(i-1,y)+1+G(i-1,x))%Mod;
    fv[x][y]=1,f[x][y]=res; return res;
}
inline int G(int x,int y)
{
    if(x==0) return 0;
    if(gv[x][y]) return g[x][y];
    int res=0,id=(y>=1 && y<=n?n-(y-x):y);
    int len=min(x,h[n][id]),i=x-len;
    if(i) res=(F(i-1,x)+1+G(i-1,y))%Mod;
    gv[x][y]=1,g[x][y]=res; return res;
}

int main()
{
    scanf("%d",&n);
    For(i,1,n) scanf("%1d",&s[i]);
    For(i,1,n) For(j,1,n) if(s[i]==s[j])
        h[i][j]=h[i-1][j-1]+1;
    For(i,1,n) if(s[i]==0) h[0][i]=h[i][0]=h[0][i-1]+1;
    For(i,1,n) if(s[i]==1) h[n+1][i]=h[i][n+1]=h[n+1][i-1]+1;
    ans=(F(n,0)+1+G(n,n+1))%Mod;
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：离散小波变换° (赞：6)

## 题解

为了方便起见，我们记 $s_i$ 表示**在打算修改第 $i$ 个位置的情况下**，$t_{1},t_2,\cdots,t_{i-1}$ 所应该成为的字符串，也就是给定的字符串 $s$ 的后缀 $s[n-i+2:n]$。特别地，我们记 $s_{0}=000\cdots 000$ 是一个长度为 $n+1$ 的全 $0$ 串。

因为我们最后要使得 $t$ 达到 $111\cdots 111$ 的局面，容易想到一个贪心：

- 先用最少步数把 $t_1,t_2,\cdots,t_{n}$ 给变成 $s_{n+1}$，并修改 $s_{n+1}$ 为 $1$；
- 从上一位开始一直往前找，直到找到一个位置满足 $t_x=0$。那么我们要做的是把 $t_{1},t_2,\cdots,t_{x-1}$ 给变成 $s_x$，然后修改 $t_x$ 为 $1$；
- 从上一位开始一直往前找，直到找到一个位置满足 $t_y=0$。那么我们要做的是把 $t_{1},t_2,\cdots,t_{y-1}$ 给变成 $s_y$，然后修改 $t_y$ 为 $1$；
- 重复以上步骤向前找非 $1$ 元素，将其修改为 $1$。容易发现按照这样的贪心策略，最后的步数肯定是最少的。

在上述过程中频繁出现了「原来 $t_1,t_2,\cdots,t_{u-1}$ 是 $s_u$，现在要将 $t_1,t_2,\cdots,t_{v-1}$ 给修改成 $s_v$」的操作。这启发我们定义一个这样的状态：

- 记 $\mathit{dp}(x,y)$ 表示当前 $t$ 的前缀为 $s_x$，现在修改一次 $y$ 位置，所需要的最少步数。其中 $x=0$ 或者 $x>y$。

同样是按照刚刚所述的贪心的思想，因为我们要修改 $y$ 位置，所以要把 $t_1,t_2,\cdots,t_{y-1}$ 给变成 $s_y$，那从 $t_{y-1}$ 开始向前找，找到最大的 $i$，满足 $s_x[i]\neq s_y[i]$。这个时候就得把 $t_1,t_2,\cdots,t_{i-1}$ 先给变成 $s_i$，所花的步数显然是 $dp(x,i)$。需要注意的是，在修改完后，$t_1,t_2,\cdots,t_{i-1}$ 已经变成了 $s_i$，所以在修改 $i$ 前面某位数字 $j$ 时就不再是计算 $dp(x,j)$，而是计算 $dp(i,j)$。

为此，先令 $l=x$。找到最大的 $i<y$ 满足 $s_{x}[i]\neq s_{y}[i]$，花 $dp(l,i)$ 步数修改 $t_i$，此时 $l\gets i$。修改完后，再找最大的 $i<y$ 满足 $s_{x}[i]\neq s_{y}[i]$，花 $dp(l,i)$ 步数修改 $t_i$，再令 $l\gets i$……如此循环，直到没有这样的 $i$，退出程序。

上述过程可以用代码机械地描述出来，其中 $F$ 数组用于记忆化：

```cpp
int dp(int x, int y){
    if(F[x][y] != -1) return F[x][y];
    F[x][y] = 1; int l = x;
    dn(y - 1, 1, i){
        char a = S[n - y + 1 + i];
        char b = S[n - l + 1 + i];
        if((l == 0 && a == '1') || (l != 0 && a != b)){
            F[x][y] = (F[x][y] + dp(l, i)) % MOD;
            l = i;
        }
    }
    return F[x][y];
}
```

这样我们得到了一个 $\mathcal O(n^3)$ 复杂度的算法，喜提 $56$ 分。下面考虑优化。

这个算法复杂度的瓶颈在于转移时花费的 $\mathcal O(n)$ 时间。如果能设法优化就好了。我们记全过程中 $l$ 取值变化分别为 $l_1=x,l_2,l_3,\cdots$，那么这一连串的算式对 $dp(x,y)$ 的贡献为：

$$\sum dp(l_i, l_{i+1})$$

接着注意到：

$$\begin{aligned}
(l_1,y)&\to l_2, \quad \text{贡献}=dp(l_1,l_2)\cr
(l_2,y)&\to l_3, \quad \text{贡献}=dp(l_2,l_3)\cr
(l_3,y)&\to l_4, \quad \text{贡献}=dp(l_3,l_4)\cr
(l_4,y)&\to l_5, \quad \text{贡献}=dp(l_4,l_5)\cr
\cdots 
\end{aligned}$$

记 $g(l_0,y)$ 表示在 $l$ 一开始为 $l_0$ 时，产生的总贡献。可以发现转移方程：

$$g(l_0,y)=\begin{cases}dp(l_0,l)+g(l,y) & l<\min(l_0,y),\ s_{l0}[l]\neq s_y[l] \text{ 且 } l \text{最大} \cr 0  & \text{不存在这样的 } l\end{cases}$$

怎么找这样的 $l$？暴力枚举。可以写出这样的代码进行记忆化：

```cpp
int dp1(int l, int y){
    if(G[l][y] != -1) return G[l][y];
    G[l][y] = 0;
    dn(min(l == 0 ? n + 1 : l, y) - 1, 1, i){
        char a = S[n - y + 1 + i];
        char b = l == 0 ? '0' : S[n - l + 1 + i];
        if(a != b){
            G[l][y] = (dp1(i, y) + dp2(l, i)) % MOD;
            return G[l][y];
        }
    }
    return G[l][y];
}
int dp2(int x, int y){
    if(F[x][y] != -1) return F[x][y];
    F[x][y] = 1; int l = x;
    F[x][y] = (F[x][y] + dp1(l, y)) % MOD;
    return F[x][y];
}
```

看上去这份代码复杂度仍然是 $\mathcal O(n^3)$，但很神奇的是，它可以在很短时间内通过所有测试数据。

~~优质解答：我不知道。复杂度可能确实是平方，留作读者思考。~~

这里提供另外一个更容易证明复杂度是 $\mathcal O(n^2)$ 的做法。观察上述代码，发现复杂度可能的瓶颈在于使用循环来找两个子串最靠后的不同的字符出现在哪里。那我们只需要再开一个 $h(x,y)$，表示两个分别以 $x,y$ 结尾的子串，到最靠后的不同的字符的距离。容易得到转移方程：

$$h(x,y)=\begin{cases}h(x-1,y-1)+1 & s[x]=s[y] \cr 0 & s[x]\neq s[y]\end{cases}$$

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
const int MAXN= 2e3 + 3;
const int MOD = 1e9 + 7;
int F[MAXN][MAXN]; char S[MAXN];
int n;
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
int G[MAXN][MAXN], H[MAXN][MAXN], T[MAXN];
int dp1(int l, int y);
int dp2(int x, int y);
int cc = 0;
int dp3(int x, int y){
    if(H[x][y] != -1) return H[x][y];
    if(S[x] != S[y])
        return H[x][y] = 0;
    return H[x][y] = 1 + dp3(x - 1, y - 1);
}
int dp1(int l, int y){
    if(G[l][y] != -1) return G[l][y];
    G[l][y] = 0;
    int t = 0, i = 0;
    if(l == 0) i = T[y]; else {
        int u = min(l, y) - 1;
        t = dp3(n - y + 1 + u, n - l + 1 + u);
        i = u - t;
    }
    if(i >= 1){
        G[l][y] = (dp1(i, y) + dp2(l, i)) % MOD;
    }
    return G[l][y];
}
int dp2(int x, int y){
    if(F[x][y] != -1) return F[x][y];
    F[x][y] = 1; int l = x;
    F[x][y] = (F[x][y] + dp1(l, y)) % MOD;
    return F[x][y];
}
int main(){
    n = qread();
    scanf("%s", S + 1);
    up(1, n + 1, i){
        dn(i - 1, 1, j) if(S[n - i + 1 + j] == '1') {T[i] = j; break;}
    }
    up(0, n + 1, i) up(0, n + 1, j) F[i][j] = -1;
    up(0, n + 1, i) up(0, n + 1, j) G[i][j] = -1;
    up(1, n + 1, i) up(1, n + 1, j) H[i][j] = -1;
    int ans = 0, l = 0;
    dn(n + 1, 1, i){
        if(l == 0 || S[n - l + 1 + i] != '1')
            ans = (ans + dp2(l, i)) % MOD, l = i;
    }
    printf("%d\n", ans);
    return 0;
}
```



---

## 作者：yummy (赞：6)

# D. Rings

### 和正解关系不大的分

Testcases $1\sim 3$：暴力 BFS，或者直接手玩 $14$ 种情况。

Testcases $4\sim 6$：DFS，但是要避免重复搜索。由于所有状态构成一棵树，所以实际上这是 $O(n^22^n)$ 的。

Testcase $14$：如果 $s_i$ 全是 $0$ 则从后往前依次将 $t$ 对应值改成 $1$，若 $s_i$ 全是 $1$ 则从前往后，都只要输出 $n+1$。

Testcases $15\sim 17$：经典九连环的分。手玩，设从全 $0$ 到全 $1$ 步数为 $a_n$，把全 $0$ 串仅把最后一个数变成 $1$ 步数为 $b_n$，则有 $b_n=2b_{n-1}+1$（要先将倒数第二个数变成 $1$，将最后一个数变成 $1$ 然后将之前 $b_{n-1}$ 步撤回），而 $a_n=b_{n-1}+1+a_{n-2}$（将最后两个环摆好然后再管前面两个）。实际上这一块你谷相关题目很多，网上也有很多资料。

将上面的内容混合在一起，可以得到 $45$ 分：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=1000000007;
int n;
string s;
int dfs(string t,int lst)//当前的 t，以及上一次改变哪个环
{
	int ret=0;
	for(int i=0;i<=n;i++)
		if(t[i]!='1')ret=0x3f3f3f3f;
	if(ret==0)return 0;//如果装上了返回 0，否则接着看
	for(int i=0;i<=n;i++)
		if(i!=lst && s.substr(n-i,i)==t.substr(0,i))//如果修改第 i 个环符合题意就试试
		{
			string cur=t;
			cur[i]^=1;
			ret=min(ret,dfs(cur,i)+1);
		}
	return ret;
}
int b(int n)
{
	if(n==1)return 1;
	return (b(n-1)*2+1)%Mod;
}
int a(int n)//请注意，这种写法实为 O(n^2) 的，但是本题时间宽裕，所以并没有优化 
{
	if(n<=2)return n;
	return (b(n-1)+1+a(n-2))%Mod;
}
int main()
{
	cin>>n>>s;
	string t0(n+1,'0');
	if(n<=15)//Testcases 1-5
		cout<<dfs(t0,-1);
	else
	{
		if(s[n-1]==s[n-2]) // Testcase 12
			printf("%d\n",n+1);
		else	//Testcases 13-15
			printf("%d\n",a(n+1));
	}
	return 0;
}
```

### $O(n^3)$ 做法

我们要解决形如”我为了装上 $10$ 环将前 $9$ 个环变成了 $s$ 的后缀，现在我要将前 $7$ 个环变成 $s$ 的后缀需要多少步“的问题——因为除了最开始的全 $0$ 状态，每次需要将某一段变成 $s$ 的后缀时，当前的 $s$ 一定是上一次留下的”烂摊子“。

令 $f(l,a,c)$ 表示将 $s_{a,\ldots,a+l}$ 变成 $s_{c,\ldots,c+l}$ 所需最少步数，根据最后一个字符是否需要修改，可以写出转移方程：$f(l,a,c)=\begin{cases}f(l-1,a,c) & s_{a+l}=s_{c+l}\\f(l-1,a,n-l)+1+f(l-1,n-l,c) & s_{a+l}\ne s_{c+l}\end{cases}$。转移是 $O(1)$ 的，总时间复杂度 $O(n^3)$。

这里有一些实现技巧：如果我们在 $s$ 前面补上 $n$ 个 $0$，那么目标也是将 $f$ 的前缀转化成后缀的问题。下面是参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=1000000007;
char s[605];
int n,dp[2][605][605],cnt[605];
int main()
{
	scanf("%d",&n);
	scanf("%s",s+n);
	for(int i=0;i<n;i++)
		s[i]='0';
	int dt=1;
	for(;s[2*n-dt]=='1';dt++);//数一数有几个末尾的 1，也就是一次可以安装几个环
	for(int l=0;l<n;l++)
	{
		int r=(l&1)^1;
		for(int a=0;a+l<n*2;a++) //因为补了 n 个 0 所以这里长度是 2n
			for(int c=0;c+l<n*2;c++)
				if(s[a+l]==s[c+l])
					dp[l&1][a][c]=dp[r][a][c];
				else
					dp[l&1][a][c]=(dp[r][a][n*2-l]+1+dp[r][n*2-l][c])%Mod;
		if(n*2-l-1-dt>=0)
			cnt[l]=dp[l&1][n*2-l-1-dt][n*2-l-1];
	}
	long long res=dp[(n&1)^1][0][n]+1;
	for(int i=n-dt-1;i>=-1;i-=dt)
		if(i==-1)res++;
		else res+=cnt[i]+1;
	printf("%lld\n",res%Mod);
	return 0;
}
```

### $O(n^2)$ 做法

实际上我们只要求 $s$ 的每个子段变成后缀的方案数，但上面的做法浪费了大量空间和时间。

如果我们预处理所有子段和 $s$ 本身的最长公共后缀，那么我们只需要让 $f(l,e)$ 表示将 $s_{e-l,\ldots,e}$ 变成 $s$ 的后缀所需步数即可。由于时间复杂度瓶颈不在预处理最长公共后缀，加上这是普及组比赛，所以不必使用高端方法。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=1000000007;
char s[4005];
int n,lcs[4005][4005],dp[4005][4005];
//lcs[i][j] 记录 s[1..i] 和 s[1..j] 的最长公共后缀。如果你采用其他方法计算也是可以的。
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)s[i]='0';
	scanf("%s",s+n+1);
	for(int i=1;i<=2*n;i++)
		for(int j=1;j<=2*n;j++)
			if(s[i]==s[j]) lcs[i][j]=lcs[i-1][j-1]+1;
			else lcs[i][j]=0;
	for(int b=1;b<=n*2;b++)
		dp[0][b]=(s[b]!=s[n*2]);
	for(int l=1;l<n;l++)
		for(int e=l+1;e<=n*2;e++)
		{
			int lce=lcs[e][n*2];
			if(lce>l)dp[l][e]=0;//整段相同
			else if(lce==l)dp[l][e]=1;//第一个字符不同
			else dp[l][e]=(dp[l-lce-1][e-lce-1]+1+dp[l-lce-1][2*n-lce-1])%Mod;
		}
	int dt=1;
	long long res=dp[n-1][n]+1;
	for(;s[2*n+1-dt]=='1';dt++);
	for(int i=n-dt;i>=0;i-=dt)
	{
		if(i==0)res++;
		else res+=dp[i-1][n*2-dt]+1;
	}
	printf("%lld\n",res%Mod);
	return 0;
}
```

### Bonus

如果你比较细致，那么可能会问，为什么这个方法最优？

实际上，我们可以证明，所有状态构成一棵树。

根据上面的做法我们知道，所有 $2^{n+1}$ 个状态是连通的。

然后考虑有多少种情形是可以修改第 $k$ 个环的。要能修改第 $k$ 个环，显然前 $k-1$ 个环都唯一确定，有 $2^{n+2-k}$ 种不同的情况。把所有情况数相加得到 $2^{n+2}-2$，由于每条边被算了两次，因此一共有 $2^{n+1}-1$ 条边。

所以说，只要一个方法没有连续两次改变同一个环，它都是最优的。

### 题外话

yummy 个人装九连环最快成绩是在 $4\min$ 以内。但是高一那年学校科技节比赛的时候 yummy 紧张+外接暴风雨般噪音干扰变成丢人的 $6\min+$，喜提三等奖。

---

## 作者：bmatrix (赞：2)

[题面](https://www.luogu.com.cn/problem/P9229)。

非常好问题，使我大脑爆破，爱来自瓷器。

本文字符串下标均从 $1$ 开始。对于字符串 $s$，记 $s[i]$ 表示下标为 $i$ 的字符，记 $s[l:r]$ 为 $s[l],s[l+1],\dots,s[r]$ 构成的子串。对于题目中的规则串 $s$，记 $s_i$ 表示长为 $i$ 的后缀，即 $s[n-i+1:n]$，特别地，$s_0$ 表示长为 $n$ 的全 $0$ 串。

我们可以简单地将这个问题分为三步：

1. 将 $t[1:n]$ 即 $s_0$ 变为 $s$；
2. 将 $t[n+1]$ 变为 $1$；
3. 将 $t[1:n]$ 即 $s$ 变为全 $1$ 串。

先考虑第一步，我们考虑从后往前修改，因为后面的字符不会影响前面的：（即无后效）

1. 从 $n$ 开始从后往前找到最大的满足 $t[i]\neq s[i]$（即 $s_0[i]\neq s[i]$）的 $i$，把 $t[1:i-1]$（即 $s_0[1:i-1]$）修改为 $s_{i-1}$，然后对 $t[i]$ 取反；

2. 从 $i-1$ 开始从后往前找到最大的满足 $s_{i-1}[j]\neq s[j]$（因为此时 $t[1:i-1]$ 就是 $s_{i-1}$）的 $j$，把 $t[1:j-1]$（此时等于 $s_{i-1}[1:j-1]$）修改为 $s_{j-1}$，然后对 $t[j]$ 取反；

   $\dots$

3. 直到 $t[1:n]=s$ 为止。

而再考虑这里的第一步，我们还可以类似地递归下去，于是我们设 $f(x,y)\>\>(x>y)$ 为将 $s_x[1:y]$ 修改为 $s_y$ 的最少步数，进行记忆化搜索，按照上述方法循环转移可做到 $O(n^3)$。核心代码：

```cpp
int dfs(int x, int y) {
    // f 是记忆化数组，get(i, j) 返回 s_i[j]
    if(f[x][y] != -1) return f[x][y];
    f[x][y] = 0;
    int lst = x;
    for(int i = y; i; --i) {
        if(get(lst, i) != get(y, i)) {
            (f[x][y] += dfs(lst, i - 1) + 1) %= mod;
            lst = i - 1;
        }
    }
    return f[x][y];
}
```

发现瓶颈在于转移，考虑优化转移。

当我们找到第一个 $s_x[i]\neq s_y[i]$ 时，我们先将 $s_x[1:i-1]$ 改为了 $s_{i-1}$，然后将 $s_x[i]$ 取反。在这之后的操作其实就是把 $s_{i-1}$ 改成 $s_y[1:i-1]$，把它反过来，也就是变成将 $s_y[1:i-1]$ 改成 $s_{i-1}$，操作次数是不变的。所以 $f(x,y)=f(x,i-1)+1+f(y,i-1)$。

代码：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define rep(i, s, e) for(int i = s, i##E = e; i <= i##E; ++i)
#define per(i, s, e) for(int i = s, i##E = e; i >= i##E; --i)
#define F first
#define S second
#define int ll
#define gmin(x, y) (x = min(x, y))
#define gmax(x, y) (x = max(x, y))
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double f128;
typedef pair<int, int> pii;
template<class T = int> const T& read() {
    static T x; cin >> x; return x;
}
constexpr int N = 2005, mod = 1e9 + 7;
int n, f[N][N];
char s[N];
char get(int l, int i) {
    return l ? s[n - l + i - 1] : '0';
}
int dfs(int x, int y) {
    if(f[x][y] != -1) return f[x][y];
    f[x][y] = 0;
    per(i, y, 1) {
        if(get(x, i) != get(y, i)) {
            f[x][y] = (dfs(x, i - 1) + 1 + dfs(y, i - 1)) % mod;
            break;
        }
    }
    return f[x][y];
}
signed main() {
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
#endif
    cin >> n >> s;
    memset(f, 255, sizeof f);
    int ans = dfs(0, n) + 1;
    int l = n;
    per(i, n, 1) {
        if(get(l, i) != '1')
            (ans += dfs(l, i - 1) + 1) %= mod, l = i - 1;
    }
    cout << ans << endl;
    return 0;
}
```

虽然看起来还是 $O(n^3)$ 的，但是跑得飞快。

---

## 作者：djh0314 (赞：0)

[洛谷](https://www.luogu.com.cn/problem/P9229)。

## 题面

初始状态为全是 $0$，将某一为变化的前提是当前节点的前缀（不包括当前节点）是 $s$ 串的一个后缀，每次变化需要 $1$ 的代价。问最后要使所有都为 $1$ 的最小代价。

## 分析

很有意思的一道题，~~感觉玩起来跟喵了个喵一样上头~~。



首先，我们肯定是要先让 $n$ 这个位置变成 $1$，然后再将前边的第一个是 $0$ 的变成 $1$，反复进行该操作。                         
我们令 $t_i$ 表示要将 $i$ 这个位置翻转的前缀，后面的位置用 $0$ 补全至长度为 $n$。                           
再看要使 $i$ 这个位置翻转的方案，是由当前的第一个与 $t_i$ 不同的节点 $j$ 开始，将当前的前缀变成 $t_j$ ，翻转 $j$，继续寻找不同。                    
我们可以发现啊，我们的每次操作其实都是从某一个前缀变成另一个前缀，由此，我们可以设计出我们的第一个状态与第一个 dfs，$f_{i,j}$ 表示从 $t_i$ 变成 $t_j$ 的最小代价。

~~~cpp
inline int dfs(int u,int v) {
	if(~f[u][v]) return f[u][v];
	int tot=1,x=u;
	for(int now=v-1; now; --now) {
		if(s[x][now]!=s[v][now]) {
			ADD(tot,dfs(x,now));
			x=now;
		}
	}
	return f[u][v]=tot;
}
~~~

时间复杂度：$O(n^3)$，拿下 $56pts$。



## 优化

我们从代码上分析一下，我们的代价实质上是做了什么计算呢，对于计算 $dfs(i,j)$，我们令不断枚举中的数字分别为 $st_1=u$，$st_2$，$\dots$，$st_{top}$，$dfs(i,j)=1+\sum f_{st_i,st_{i+1}}$。


我们有一部分是反复计算的，考虑将这一部分进行记忆化，而我们的这一部分，则是与 $v$ 相比较的。由此，设计出一个辅助的转移的数组 $g_{i,j}$，$g_{i,j}$ 表示从 $i$ 开始的与 $j$ 比较所计算出来的值。

~~~cpp
inline int redfs(int u,int v) {
	if(~g[u][v]) return g[u][v];
	int tot=0;
	for(int now=u-1; now; --now) {
		if(s[u][now]!=s[v][now]) {
			ADD(tot,dfs(u,now)+redfs(now,v));
			break;
		}
	}
	return g[u][v]=tot;
}

inline int dfs(int u,int v) {
	if(~f[u][v]) return f[u][v];
	int tot=1;
	for(int now=v-1; now; --now) {
		if(s[u][now]!=s[v][now]) {
			ADD(tot,dfs(u,now)+redfs(now,v));
			break;
		}
	}
	return f[u][v]=tot;
}
~~~

由此，我们的 $O(n^3)$ 得到了极大的优化，可以通过此题。



剩下就需要优化我们的扫描上，有一种思路，我们可以使用字符串哈希加二分来处理，时间复杂度：$O(n^2\times \log n)$，时间复杂度计算上勉强可以过。

另一种想法，我们可以利用我们的字符串的性质，我们的字符串都是同一个字符串的后缀，由此，我们可以预处理我们的扫描，时间复杂度：$O(n^2)$。



---

## 作者：Butterfly_qwq (赞：0)

本题使用了记忆化搜索。

设 $dp_{i,j,k}$ 表示考虑到前 $i$ 个字符，后缀状态为 $j$，要变成状态 $k$ 的最小步数。

其中状态 $i$ 中 $i=0$ 是全 $0$，$i=n+1$ 是全 $1$。

答案就是 $dp_{n,0,n}+dp_{n,n,n+1}+1$。

预处理出 $h_{i,j}$ 表示状态 $i$ 和状态 $j$ 的最长公共后缀。

那么有如下方程式：

$\begin{cases} h_{i,j}=h_{i-1,j-1}+1,s_i=s_j\\h_{i,0}=h_{0,i}=h_{0,i-1}+1,s_i=0\\h_{i,n+1}=h_{n+1,i}=h_{n+1,i-1}+1,s_{i}=1\end{cases}$

那么我们可以在 $O(1)$ 的时间内求出两个状态 $i,j$ 最靠后的不相同的地方。

那么我们有：

$dp_{n,0,n}=dp_{k-1,0,k-1}+dp_{k-1,k-1,n}+1$；

$dp_{n,n,n+1}=dp_{k-1,n,k-1}+dp_{k-1,k-1,n+1}+1$。

其中 $k$ 表示最靠后的不匹配（就是两个字符串的 $k$ 位置不一致）的位置。 

注意到要求的 $dp_{i,j,k}$ 肯定满足 $i=j$ 或 $i=k$。 

所以令 $f_{i,j}=dp_{i,j,i},g_{i,j}=dp_{i,i,j}$ 即可。 

时间复杂度 $O(n^2)$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,s[2005],f[2005][2005],g[2005][2005],h[2005][2005];
int F(int,int);
int G(int,int);
int main()
{
	memset(f,-1,sizeof(f));
	memset(g,-1,sizeof(g));
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		char ch;
		cin>>ch;
		s[i]=ch^48;
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(s[i]==s[j])h[i][j]=h[i-1][j-1]+1;
	for(int i=1;i<=n;i++)
	{
		if(s[i])h[n+1][i]=h[i][n+1]=h[n+1][i-1]+1;
		else h[0][i]=h[i][0]=h[0][i-1]+1;
	}
	cout<<(F(n,0)+G(n,n+1)+1)%mod;
}
int F(int i,int j)
{
	if(!i)return 0;
	if(~f[i][j])return f[i][j];
	int t=h[n][(j>=1&&j<=n?n+i-j:j)];
	if(i>t)f[i][j]=(F(i-min(i,t)-1,j)+G(i-min(i,t)-1,i)+1)%mod;
	else f[i][j]=0;
	return f[i][j];
}
int G(int i,int j)
{
	if(!i)return 0;
	if(~g[i][j])return g[i][j];
	int t=h[n][(j>=1&&j<=n?n+i-j:j)];
	if(i>t)g[i][j]=(F(i-min(i,t)-1,i)+G(i-min(i,t)-1,j)+1)%mod;
	else g[i][j]=0;
	return g[i][j];
}
```

---


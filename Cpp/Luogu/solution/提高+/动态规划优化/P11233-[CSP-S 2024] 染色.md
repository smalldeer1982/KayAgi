# [CSP-S 2024] 染色

## 题目描述

给定一个长度为 $n$ 的正整数数组 $A$，其中所有数从左至右排成一排。

你需要将 $A$ 中的每个数染成红色或蓝色之一，然后按如下方式计算最终得分：

设 $C$ 为长度为 $n$ 的整数数组，对于 $A$ 中的每个数 $A_i$（$1 \leq i \leq n$）：

- 如果 $A_i$ 左侧没有与其同色的数，则令 $C_i = 0$。
- 否则，记其左侧**与其最靠近的同色数**为 $A_j$，若 $A_i = A_j$，则令 $C_i = A_i$，否则令 $C_i = 0$。

你的最终得分为 $C$ 中所有整数的和，即 $\sum \limits_{i=1}^n C_i$。你需要最大化最终得分，请求出最终得分的最大值。

## 说明/提示

**【样例 1 解释】**

对于第一组数据，以下为三种可能的染色方案：

1. 将 $A_1, A_2$ 染成红色，将 $A_3$ 染成蓝色（$\red{1}\red{2}\blue{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，由于其左侧没有蓝色的数，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
2. 将 $A_1, A_2, A_3$ 全部染成红色（$\red{121}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_2$。由于 $A_2 \neq A_3$，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
3. 将 $A_1, A_3$ 染成红色，将 $A_2$ 染成蓝色（$\red{1}\blue{2}\red{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，由于其左侧没有蓝色的数，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 = A_3$，所以 $C_3 = A_3 = 1$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 1$。

可以证明，没有染色方案使得最终得分大于 $1$。

对于第二组数据，可以证明，任何染色方案的最终得分都是 $0$。

对于第三组数据，一种最优的染色方案为将 $A_1, A_2, A_4, A_5, A_7$ 染为红色，将 $A_3, A_6, A_8$ 染为蓝色（$\red{35}\blue{2}\red{51}\blue{2}\red{1}\blue{4}$），其对应 $C = [0, 0, 0, 5, 0, 2, 1, 0]$，最终得分为 $8$。

**【样例 2】**

见选手目录下的 color/color2.in 与 color/color2.ans。

**【数据范围】**

对于所有测试数据，保证：$1\leq T\leq 10$，$2\leq n\leq 2\times 10^5$，$1\leq A_i\leq 10^6$。

::cute-table{tuack}

| 测试点 | $n$ | $A_i$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $\leq 15$ | $\leq 15$ |
| $5\sim 7$ | $\leq 10^2$ | $\leq 10^2$ |
| $8\sim 10$ | $\leq 2000$ | $\leq 2000$ |
| $11,12$ | $\leq 2\times 10^4$ | $\leq 10^6$ |
| $13\sim 15$ | $\leq 2\times 10^5$ | $\leq 10$ |
| $16\sim 20$ | ^ | $\leq 10^6$ |

## 样例 #1

### 输入

```
3
3
1 2 1
4
1 2 3 4
8
3 5 2 5 1 2 1 4```

### 输出

```
1
0
8```

# 题解

## 作者：PassName (赞：302)

PS：声明，本做法由同机房巨佬 @[hanss6](https://www.luogu.com.cn/user/537719) 提供，经其本人同意后在此记录。

提供一个代码实现非常简单十分简短的做法。

返璞归真，状态没必要设置那么复杂，设 $f_i$ 表示考虑到第 $i$ 位的答案。显然的，对于每一个位置 $i$ 可以令 $f_i = f_{i-1}$。

用 $lst_i$ 记录 $i$ 上一次出现的位置，初始化令所有的 $lst_i = 0$，每遍历到一个位置，动态更新 $lst_{a_i} = i$。然后枚举区间更新 $f_i$，也可以预处理出来一个 $g$ 数组辅助转移，复杂度 $O(n^2)$。

[50pts code](https://www.luogu.com.cn/paste/62aiymf9)

使用前缀和优化，每当 $a_i=a_{i-1}$ 时，更新前缀和数组 $s_i$。最后对于 $a_i$ 如果 $lst_{a_i}$ 存在，对于 $f_i$ 的转移为：

$$f_i=\max_{i=1}^{n}\{f_{lst_{a_i}+1}+a_i+s_i-s_{lst_{a_i}}\}$$

最终的答案为 $f_n$。

复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>

#define int long long
#define rint register int
#define endl '\n'
#define m(a) memset(a, 0, sizeof a)

using namespace std;

const int N = 1e6 + 5;

int n, T;
int a[N], lst[N], f[N];
int s[N], ans; 

signed main() 
{
	cin >> T;
	while (T--) 
	{
		cin >> n;
		m(a), m(lst), m(f), m(s);
		for (rint i = 1; i <= n; i++) cin >> a[i];
		for (rint i = 2; i <= n; i++) s[i] = (a[i] == a[i - 1] ? s[i - 1] + a[i] : s[i - 1]);
		for (rint i = 1; i <= n; i++) 
		{
			f[i] = f[i - 1];
			if (lst[a[i]]) f[i] = max(f[i], f[lst[a[i]] + 1] + a[i] + s[i] - s[lst[a[i]] + 1]);
			lst[a[i]] = i;
		}
		cout << f[n] << endl;
	} 
	return 0;
}
```

---

## 作者：cff_0102 (赞：145)

2024/10/27 更新：增加了一些详细的描述。其实这个思路不难，同机房大佬也说“如果按我这个思路那么这题只有绿”，所以不应该花太多文字去讲，否则看起来更加混乱。但是因为有人问到了一些细节的问题，那就在这里补充一下。

设 $dp_{i,j}$ 表示考虑前 $i$ 个数，最后一个数涂的颜色是 $j$（$j\in\{0,1\}$）的最大得分。

对于第 $i$ 位，它可能产生贡献，也可能不产生贡献。

如果它没有贡献，直接 $dp_{i,0}=dp_{i,1}=\max(dp_{i-1,0},dp_{i-1,1})$。

如果它有贡献，以 $dp_{i,0}$ 为例：

那么前面一定也有一个染成了颜色 $0$ 的相同的数，且这之间所有数都染成了颜色 $1$。

不难想到要选择前面的最后一个相同的数，因为如果不是最后一个，就可以在这两个数中间所有染成 $1$ 的数里面找到另一个相同的数，把它也染 $0$ 收益更大。

设前面这个相同的数的位置为 $l$（可以 $O(n)$ 预处理出来），那么 $dp_{i,0}$ 可以拆成三个部分计算：

- 位置在 $1\sim l+1$ 的数产生的贡献，其中 $l+1$ 染成了颜色 $1$。这个贡献即为 $dp_{l+1,1}$。此时不需要担心 $l$ 没有被染成颜色 $0$ 的问题，因为 $dp_{l+1,1}$ 会选择最优策略，那么 $l$ 此时是可以选择不和 $l+1$ 染成同一个颜色的。
- 位置在 $l+2\sim i-1$ 的数产生的贡献，这个贡献即为将 $l+1\sim i-1$ 全部染成同一个颜色会产生的贡献。设 $s_i$ 表示 $1\sim i$ 染成同一个颜色的贡献，那么 $l+1\sim i-1$ 全部染成同一个颜色会产生的贡献，或者说位置在 $l+2\sim i-1$ 的数产生的贡献，就是 $s_{i-1}-s_{l+1}$。
- 位置在 $i$ 的数产生的贡献，它等于 $a_i$。

因此如果第 $i$ 个数产生了贡献，那么 $dp_{i,0}=a_i+dp_{l_i+1,1}+s_{i-1}-s_{l_i+1}$，这样转移是 $O(1)$ 的。当然要特判一下 $a_i=a_{i-1}$ 的情况，此时 $dp_{i,0}=dp_{i-1,0}+a_i$。$dp_{i,1}$ 按同样的方法计算即可。

在产生贡献和不产生贡献的最大得分取 $\max$ 即可，也就是 $dp_{i,0}=\max(dp_{i-1,0},dp_{i-1,1},a_i+dp_{l_i+1,1}+s_{i-1}-s_{l_i+1})$（如果 $a_i\ne a_{i-1}$），$dp_{i,1}$ 同理。最后输出 $\max(dp_{n,0},dp_{n,1})$。

其实 $dp_{i,0}$ 应该等于 $dp_{i,1}$ 的来着，没必要开两倍空间，不过考场上也没想着优化了，反正能过就行。

[代码见此](https://www.luogu.com.cn/paste/pgbjsm3k)。

---

## 作者：W_Sibo (赞：117)

update 2024/12/15：更新了图片

讲一个在考场上独到的解析思路：
## 思路
不妨设：
$$a_{i}=a_{j}$$

发现：如果想让一个数**有价值**，就要将 $a_{i}$ 与 $a_{j}$ 置为**一种颜色**（假设为红），中间的颜色置为**不同的颜色**（假设为蓝）。样例：
![](https://cdn.luogu.com.cn/upload/image_hosting/0c1nl6g5.png)

那么我们更进一步：既然需要将中间的颜色置为同一种颜色，那我们可以将 $i+1$ 位置与 $j-1$ 位置连接一条边权为 $a_{i}$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/vmc7mbp2.png)

当不相交的边的权值和最大时，即为最优情况。我们以考场大样例第一个为例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/1a7hdhob.png)

较为特殊的情况（如上图红色框）：若 $j=i+1$，那么最优的情况一定是将 $a_{i}$ 与 $a_{j}$ 画为同一种颜色。

证明：若 $a_{i}$ 与 $a_{j}$ 不为同一种颜色，那么既会得不到 $a_{j}$ 的贡献，也不会得到某条跨过 $a_{i}$ 与 $a_{j}$ 的边权。相反，若 $a_{i}$ 与 $a_{j}$ 为同一种颜色，他们不会影响任何其他的值。

所以我们直接把 $a_{i}$ 加入答案 $ans$ 中。

当我们只选择边权为 $13$ 的边时，结果最大。

## 求解
所以，怎么办呢？

设:

+ $t_{i}$：数字 $i$ 上一次出现的位置。

+ $out_{i}$：以 $i$ 为终点的连边的起点。

+ $v_{i}$：以 $i$ 为终点的连边的边权。

则有：

$$dp_{i}=\max(dp_{i-1},dp_{out_{i}-1}+v_{i})$$ 

解析：要么选择这条边，那么就从 $out_{i}-1$ 位置转移方程。因为这一段都不能选择，线不可以交叉。要么不选择，答案就是上一个点的值。

那么代码就非常容易啦：

## code


```cpp
#include <bits/stdc++.h>
using namespace std;
const int M=1e6+10,N=2e5+10;
typedef long long ll;
ll n,a[N],dp[N],out[N],t[M],ans=0,v[N],p;
int main(){
	cin>>p;
	for(int k=1;k<=p;k++){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(t[a[i]]){ //如果 a[i] 存在上一个数
				if(t[a[i]]==i-1){ //如果与上一个数挨着
					ans+=a[i]; //答案直接加上
				}else{
					out[i-1]=t[a[i]]+1;
              	//将i-1 与 上一个 a[i] 的后一个连边
					v[i-1]=a[i];//将边权设置为 a[i]
				}
			}
			t[a[i]]=i; //存下 a[i] 位置
		}
		for(int i=1;i<=n;i++){
			dp[i]=dp[i-1];
			if(out[i]) dp[i]=max(dp[i],dp[out[i]-1]+v[i]);
              // 状态转移
		}
		ans+=dp[n]; //加上特殊的答案
		cout<<ans<<'\n';
          //别忘了多组数据清空！我就因为这个T2寄了
		for(int i=1;i<=n;i++){
			t[a[i]]=0;
			a[i]=0;
			out[i]=0;
			v[i]=0;
			dp[i]=0;
		} 
		ans=0;
	}
}
```
时间复杂度：$O(tn)$

thanks！

---

## 作者：Exp10re (赞：51)

赛前写过类似的 Trick。

结果一看怎么题解区没有一个和我思路一样的，补一个题解。

## 解题思路

记 $f_i$ 表示位置 $i$ 的颜色与位置 $i-1$ 的颜色不同时前 $i$ 位的得分最大值。

显然有一个 $O(n^2)$ 转移的做法：

$$f_{i}=\max\limits_{1\leq j\lt i} (f_j+\sum\limits_{k=j+1}^{i-1} [a_k=a_{k-1}]a_k+[a_i=a_{j-1}]a_i)$$

边界为 $f_1=0$，答案为 $f_{n+1}$。

其中从 $f_j$ 转移到 $f_i$ 的含义为第 $j$ 个数到第 $i-1$ 个数颜色相同，第 $j-1$ 个数与第 $i$ 个数颜色相同且与中间的一段不同时的得分转移。

考虑优化，记：

$$b_i=\begin{cases}
a_i &\ a_{i}=a_{i-1} \\
0 &\ otherwise \\
\end{cases}
$$

则上式可以被表示为：

$$f_{i}=\max\limits_{1\leq j\lt i} (f_j+\sum\limits_{k=j+1}^{i-1} b_k+[a_i=a_{j-1}]a_i)$$

则对 $b$ 作前缀和，记 $pre_i=\sum\limits_{j=1}^{i} b_j$，则上式转移可以被优化至 $O(n)$：

$$f_{i} =\max\limits_{1\leq j\lt i} (f_j+pre_{i-1}-pre_{j}+[a_i=a_{j-1}]a_i)$$

提出去一个 $pre_{i-1}$ 可以得到：

$$f_{i} =\max\limits_{1\leq j\lt i} (f_j-pre_{j}+[a_i=a_{j-1}]a_i)+pre_{i-1}$$

发现如果不考虑 $[a_i=a_{j-1}]a_i$ 一项的话就是前 $i-1$ 项的 $f_{j}-pre_{j}$ 最大值与 $pre_{i-1}$ 的和，而考虑 $[a_i=a_{j-1}]a_i$ 得到的值一定比这个更大，即 $f_{j}-pre_{j}$ 的前缀最大值与 $pre_{i-1}$ 的和是 $f_i$ 的一个下限，故将转移分开两块分别计数求更大值。

具体的，记 $s_i=f_i-pre_i$，则：

$$f_i=\max({\max\limits_{1\leq j\lt i} s_j},{\max\limits_{1\leq j\lt i,a_{i}=a_{j-1}} s_j+a_i})+pre_{i-1}$$

考虑将该转移式优化。

$\max\limits_{1\leq j\lt i} s_j$ 一项可以对 $s$ 求最大值，记为 $maxn$，从而将这一项的计算转为 $O(1)$。

而对于后一项 $\max\limits_{1\leq j\lt i,a_{i}=a_{j-1}} s_j+a_i$ 则考虑到 $a$ 的值域较小，可以对于每一个 $a_i=x$ 的 $i$ 记录 $s_{i+1}+x$ 的最大值，记为 $mxn_x$，如此后面一项也可以 $O(n)$ 进行转移。

整理一下转移步骤：

- $f_{i}=\max(maxn,mxn_{a_{i}})+pre_{i-1}$。
- 用 $f_i-pre_i$ 更新 $maxn$。
- 用 $f_i-pre_i+a_{i-1}$ 更新 $mxn_{a_{i-1}}$。

$maxn$ 初始值为 $0$，所有 $mxn_i$ 初始值为 $-\infty$。

这个转移的复杂度显然是 $O(1)$，所有转移的时间复杂度之和是线性的。由此我们得到了 $O(T(n+V))$ 的解。

## 代码

读懂上面的部分，代码是好理解的。


```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=1010010,INF=1e18;
long long f[MAXN],mxn[MAXN],maxn,pre[MAXN],a[MAXN],n;
void work()
{
	long long i;
	scanf("%lld",&n);
	for(i=0;i<=MAXN-1;i++)
	{
		mxn[i]=-INF;
		a[i]=0;
	}
	for(i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	pre[1]=0;
	for(i=2;i<=n;i++)
	{
		if(a[i]==a[i-1])
		{
			pre[i]=a[i];
		}
		else
		{
			pre[i]=0;
		}
		pre[i]+=pre[i-1];
	}
	maxn=0;
	for(i=2;i<=n+1;i++)
	{
		f[i]=max(maxn,mxn[a[i]])+pre[i-1];
		maxn=max(maxn,f[i]-pre[i]);
		mxn[a[i-1]]=max(mxn[a[i-1]],f[i]-pre[i]+a[i-1]);
	}
	printf("%lld\n",f[n+1]);
	return;
}
int main()
{
//	freopen("P11233.in","r",stdin);
//	freopen("P11233.out","w",stdout);
	long long T;
	scanf("%lld",&T);
	while(T--)
	{
		work();
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：Register_int (赞：50)

设 $dp_{i,0/1}$ 表示当前填到第 $i$ 个，**且 $i-1$ 的颜色是否已经确定与 $i$ 不同**。

首先我们可以放弃第 $i$ 个点，有转移：

$$dp_{i,0}\overset{\max}{\gets}dp_{i-1,0}$$
$$dp_{i,1}\overset{\max}{\gets}dp_{i-1,0}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/2mejh0n3.png)

然后处理特殊情况。$i$ 在 $i-1$ 没被确定时可以与 $i-1$ 相同，被确定时可以与 $i-2$ 相同且转移到 $i-1$。有：

$$dp_{i,0}\overset{\max}{\gets}dp_{i-1,0}+a_i$$
$$dp_{i,1}\overset{\max}{\gets}dp_{i-1,1}+a_i$$

![](https://cdn.luogu.com.cn/upload/image_hosting/tj5knqe7.png)

然后可以枚举上一个颜色相同的数。记 $c_i$ 表示所有满足 $\le i$ 且 $a_j=a_{j+1}$ 的 $j$ 的 $a_j$ 之和，可以做差快速算出一个区间全部同色的贡献。于是有：

$$dp_{i,0}\overset{\max}{\gets}\max^{i-2}_{j=1}(dp_{j+1,1}+(c_{i-2}-c_j)+a_i)$$
$$dp_{i,1}\overset{\max}{\gets}\max^{i-3}_{j=1}(dp_{j+1,1}+(c_{i-2}-c_j)+a_i)$$

![](https://cdn.luogu.com.cn/upload/image_hosting/egwm5slr.png)

对每个 $x$ 记录所有 $a_i=x$ 的 $dp_{i+1,1}-c_i$ 的最大值即可 $O(1)$ 转移，时间复杂度 $O(V+Tn)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;
const int MAXM = 2e6 + 10;

int T, n, a[MAXN]; ll dp[MAXN][2], c[MAXN], val[MAXM];

int main() {
	freopen("color.in", "r", stdin);
	freopen("color.out", "w", stdout);
	for (scanf("%d", &T); T--; ) {
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (int i = 1; i <= n; i++) c[i] = c[i - 1] + (a[i] == a[i + 1] ? a[i] : 0);
		memset(dp, 0, sizeof dp), memset(val, 0x80, sizeof val);
		for (int i = 1; i <= n; i++) {
			dp[i][0] = max(dp[i][0], dp[i - 1][0]);
			dp[i][1] = max(dp[i][1], dp[i - 1][0]);
			if (a[i] == a[i - 1]) dp[i][0] = max(dp[i][0], dp[i - 1][0] + a[i]);
			if (a[i] == a[i - 2]) dp[i][1] = max(dp[i][1], dp[i - 1][1] + a[i]);
			dp[i][1] = max(dp[i][1], val[a[i]] + c[i - 2] + a[i]);
			if (i > 2) val[a[i - 2]] = max(val[a[i - 2]], dp[i - 1][1] - c[i - 2]);
			dp[i][0] = max(dp[i][0], val[a[i]] + c[i - 2] + a[i]);
		}
		printf("%lld\n", dp[n][0]);
	}
}
```

---

## 作者：RoyWu1207 (赞：31)

## **Solution**

相邻相同数字可以直接贡献答案，所以我们可以先进行类似缩点的操作，使后续操作更方便。

记缩点部分答案为 $ans$，缩点后数组 $a_i$ 长度为 $n$。

注意到只有相同数字相同颜色才有贡献，于是记每个数字后第一个相同数字的位置为 $suf_i$。

考虑两段答案区间之交，只有前一段区间的右端点与后一段区间左端点相邻可同时取到。

于是记 $f_i$ 表示从后往前统计，在 $a_i$ 中位置 $i$ 的答案最大为 $f_i$。

则有状态转移方程：

$$f_i=\max(f_{i+1},f_{suf_i-1}+a_i)$$

最后答案则为 $ans+f_1$。

## **Code**


```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, t[1000001], suf[200001], f[200001]; vector<int > a;

void solve() {
	cin >> n; a.clear(); a.push_back(0);
	memset(t, 0, sizeof(t));
	memset(suf, 0, sizeof(suf));
	memset(f, 0, sizeof(f));
	int ans = 0;
	for (int i = 1, v; i <= n; i++) {
		cin >> v;
		if (!a.size() || v != a.back())
			a.push_back(v);
		else
			ans += v;
	} n = a.size() - 1;
	for (int i = 1; i <= n; t[a[i]] = i, i++)
		if (t[a[i]])
			suf[t[a[i]]] = i; 
	for (int i = n; i; i--)
		if (suf[i])
			f[i] = max(f[i + 1], f[suf[i] - 1] + a[i]);
		else
			f[i] = f[i + 1];
	cout << ans + f[1] << '\n';
}

signed main() {
	cin.tie(0)->sync_with_stdio(false);
	// freopen("color.in", "r", stdin);
	// freopen("color.out", "w", stdout);
	int t; cin >> t;
	while (t--) solve();
	return 0;
}

```

---

## 作者：Genius_Star (赞：26)

给一个考场 20min 想到的思路。

### 思路：

考虑朴素的 dp，令 $dp_{i,j}$ 表示 $i$ 左侧第一个同色为第 $j$ 个数字，先令：
$$
\operatorname{get}(i,j) = 
\begin{cases} 
a_i & a_i = a_j \\ 
0 & a_i \ne a_j
\end{cases}
$$
令 $h_i = \operatorname{get}(i - 1, i)$ 则状态转移方程为：
$$
\begin{cases}
dp_{i,0} = dp_{i - 1, 0} + h_{i - 1}\\ 
dp_{i, i - 1} = h_i + \max dp_{i - 1, k}(k < i - 1) \\
dp_{i, j} = \operatorname{get}(i, j) + \max (dp_{j + 1, l} + \sum\limits_{t = j + 2}^{i - 1} h_i) (l < j)
\end{cases}
$$
朴素实现是 $O(n^4)$ 的，可以拿到 20pts，考虑优化。

考虑令：
$$
s_i = \max\limits_{j = 0}^{i - 1} dp_{i,j}, t_i = \max\limits_{j = 0}^{i - 2} dp_{i,j}
$$

$$
sum_i = \sum_{i = 1}^i h_i
$$

则状态转移方程可以优化为：
$$
\begin{cases} 
dp_{i,0} = dp_{i - 1, 0} + h_{i - 1} \\ 
dp_{i, i - 1} = h_i + s_{i -1} \\ 
dp_{i, j} = \operatorname{get}(i, j) + \max(dp_{j + 1, l} + sum_{i - 1} - sum_{j + 1})(l < j)
\end{cases}
$$
主要是下面那个式子不好做，整理下得：
$$
\begin{aligned}
dp_{i,j} 
&= \operatorname{get}(i, j) + sum_{i - 1} - sum_{j+1} + \max(dp_{j + 1, l}) (l <j) \\
&= \operatorname{get}(i, j) + sum_{i - 1} - sum_{j + 1} + t_{j + 1}
\end{aligned}
$$
时间复杂度优化为 $O(n^2)$。

然后注意到答案是 $s_n$，考虑如何快速求出 $s_i$：
$$
\begin{aligned}
s_i
&= \max\limits_{j = 0}^{i - 2} dp_{i,j} \\
&= sum_{i - 1} + \max\limits_{j = 0}^{i - 2} \operatorname{get}(i, j) - sum_{j + 1} + t_{j + 1} \\
& =
\begin{cases}
sum_{i - 1} + a_i + \max\limits_{j = 1}^{i - 1} (t_j - sum_j) & a_i = a_j \\
sum_{i - 1} + \max\limits_{j = 1}^{i - 1} (t_j - sum_j) & a_i \ne a_j
\end{cases}
\end{aligned}
$$
这样就可以快速求出 $s_i$，开一个桶 $Max_i$ 表示所有使得 $a_j = i$ 的 $t_j - sum_j$ 的最大值即可，此时时间复杂度为 $O(nw)$，其中 $w$ 是值域。

注意当 $a_i \ne a_j$ 时，是求一个 $j \in [1, a_i - 1] \cup [a_i +1, w]$ 的 $Max_j$ 最大值，即两个区间的最大值，需要支持单点修改，树状数组维护即可。

时间复杂度为 $O(n \log w)$。

先给个赛后补的 Code。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e5 + 10, M = 1e6 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int T, n;
ll pre;
ll a[N], s[N], dp[N], t[N], Max[M];
namespace Tree{
	ll a[M], b[M];
	void init(){
		for(int i = 0; i < M; ++i)
		  a[i] = b[i] = -1e18;
	}
	void add(int x, ll v){
		for(int i = x; i < M; i += lowbit(i))
		  a[i] = max(a[i], v);
		x = M - x - 1;
		for(int i = x; i < M; i += lowbit(i))
		  b[i] = max(b[i], v);
	}
	ll query(int x){
		ll ans = -1e18;
		for(int i = x - 1; i > 0; i -= lowbit(i))
		  ans = max(ans, a[i]);
		x = M - x - 2;
		for(int i = x; i > 0; i -= lowbit(i))
		  ans = max(ans, b[i]);
		return ans;
	}
};
inline ll get(int x, int y){
	if(!x || !y)
	  return 0;
	if(a[x] == a[y])
	  return a[x];
	return 0;
}
void solve(){
	memset(dp, -0x7f, sizeof(dp));
	memset(t, -0x7f, sizeof(t));
	memset(Max, -0x7f, sizeof(Max));
	n = read();
	for(int i = 1; i <= n; ++i){
		a[i] = read();
		s[i] = s[i - 1] + get(i - 1, i);
	}
	Tree::init();
	dp[1] = pre = 0;
	for(int i = 2; i <= n; ++i){
		t[i] = dp[i] = pre + get(i - 2, i - 1);
		pre = dp[i];
		dp[i] = max(dp[i], s[i - 1] + a[i] + Max[a[i]]);
//		cerr << Max[a[i]] << '\n';
		dp[i] = max(dp[i], s[i - 1] + Tree::query(a[i]));
		Max[a[i - 1]] = max(Max[a[i - 1]], dp[i] - s[i]);
		Tree::add(a[i - 1], dp[i] - s[i]);
		dp[i] = max(dp[i], get(i - 1, i) + dp[i - 1]);
	}
	write(dp[n]);
	putchar('\n');
}
bool End;
int main(){
//	open("A.in", "A.out");
	T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：封禁用户 (赞：21)

# Solution
容易想到 $O(n^2)$ 的 dp，设状态 $f_{i,j}$ 为前 $i$ 个数字中，第 $[j,i]$ 的颜色相同，第 $j-1$ 的颜色不同的最大得分。  
转移为 
$$
f_{i,j}=\left\{
\begin{aligned}
\max^{i-1}_{k=1}{f_{i-1,k}+[a_{k-1}=a_{i}]\times a_i},i=j\\
f_{i-1,j}+[a_{i-1}=a_i] \times a_i,i>j
\end{aligned}
\right.
$$
这个式子是不能直接优化的，我们需要贪心一下，其实第一个方程只需要找到最大的 $k$ 使得 $a_k=a_j$就行了，令其为 $last$，再把第一维滚掉，式子便优化成了
$$
f_j=\left\{
\begin{aligned}
\max(\max^{i-1}_{k=1}{f_k},f_{last+1}+a_i),i=j\\
f_j+[a_{i-1}=a_i]\times a_i,i>j
\end{aligned}
\right.
$$
每个 $i$ 对应的 $last$ 可以直接维护，第一条式子用一个变量直接维护最大值，再加上单点查，第二条式子需要区间加，可以用树状数组实现。

PS：可以不用树状数组，直接用一个标记维护全局加的操作，更新 $f_i$ 的时候提前减去当前标记，这样用到 $f_i$ 的时候加上现在的全局加标记就是 $f_i$ 的真实取值。
# Code
## $O(n \log n)$（赛时代码）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5,M=1e6;
int t,n,a[N+5],tre[N+5],mp[N+5];
vector<int>g[M+5];
int lb(int x){return x&-x;}
void add(int x,int y){for(int i=x;i<=n;i+=lb(i))tre[i]+=y;}
int query(int x){int ret=0;for(int i=x;i>=1;i-=lb(i))ret+=tre[i];return ret;}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i],g[a[i]].push_back(i),mp[i]=g[a[i]].size()-1;
		int ans=0;
		for(int i=1;i<=n;i++){
			if(mp[i]){
				int val=max(ans,query(g[a[i]][mp[i]-1]+1)+a[i]);
				add(i,val),add(i+1,-val);
			}
			else add(i,ans),add(i+1,-ans);
			int val=(a[i]==a[i-1])*a[i];
			add(1,val),add(i,-val);
			ans=max(ans+val,query(i));
		}
		cout<<ans<<'\n';
		for(int i=1;i<=n;i++)tre[i]=0;
		for(int i=1;i<=n;i++)g[a[i]].clear();
	}
}
```
# Thanks
在此感谢 [zzzz1234567](https://www.luogu.com.cn/user/1218357) 大佬帮我将原本 $O(n \log n)$ 的复杂度优化为 $O(n)$，感谢 [sgxsz](https://www.luogu.com.cn/user/341864) 大佬帮我用线段树实现来证明了我原本的复杂度的正确性，感谢 [Cindy_Li](https://www.luogu.com.cn/user/565091) 大佬指出文中的批漏。

---

## 作者：zyn_ (赞：20)

## 前言

今天是 2024-10-26，CSP-S 考试日。

明天是 2024-10-27，也就是 [花神诞日](https://www.luogu.com.cn/problem/P10200)。

作为 Nahida 的忠实信仰者，我就写一下 P10200 的题解，以庆祝这个重要的日子吧！（埋下伏笔）

现在是上午 $10$ 点，我开始写题解；现在是上午 $11$ 点，题解写完了，明天再提交审核。

## 进入正题

看到将一个序列分为红蓝两个子序列，并且要最大化的最终得分与一个子序列的相邻两项有关。如果做过 [P10200](https://www.luogu.com.cn/problem/P10200)（伏笔回收），那么应该很快能反应过来设计一个 $O(n^2)$ 的 DP 然后数据结构优化。

设 $dp_{i,p,t}$ 表示 $a_i$ 染红色（$t=0$）或蓝色（$t=1$），上一个与 $a_i$ 异色的元素为 $a_p$（$p=0$ 代表这样的元素不存在）时，数组前 $i$ 项的最大得分。

设 $[X]$ 表示若 $X$ 为真其值为 $1$，若 $X$ 为假其值为 $0$。转移方程为：

$$
dp_{i,p,t}=
\begin{cases}
dp_{i-1,p,t}+a_i[a_i=a_{i-1}],\space p\neq i-1 \\
\max\{dp_{i-1,0,1-t},\max_{c=1}^{i-2}\{dp_{i-1,c,1-t}+a_i[a_i=a_c]\}\},\space p=i-1
\end{cases}
$$

注意一个结论，若 $\{A_i\}$ 中 $A_{p_1}=A_{p_2}=\dots=A_{p_k}=y$ 为所有值为 $y$ 的元素，则它们染同色一定更优。如果染了不同色，改为全染红色后得分中 $C_i=y$ 部分的贡献增加 $y$，且蓝色子序列中值不为 $y$ 的元素，有一些元素从不相邻变为相邻，对得分贡献不减。

于是

$$
dp_{i,i-1,t}=
\max\{dp_{i-1,0,1-t},\max_{c=1}^{i-2}\{dp_{i-1,c,1-t}+a_i[a_i=a_c]\}\}
$$

那个枚举 $c=1,2,\dots,i-2$ 的 $\max$ 当 $a_c=a_i$ 时只在 $c$ 为上一个 $a_c=a_i$ 的位置时较优。设 $pre_i$ 为上一个与 $a_i$ 值相等的位置。

$$
dp_{i,i-1,t}=
\max\{\max_{c=0}^{i-2}\{dp_{i-1,c,1-t}\},dp_{i-1,pre_i,1-t}+a_i\}
$$

现在考虑**滚动数组**，去除 $i$ 这一维。$p\neq i-1$ 的转移变为区间加，$p=i-1$ 的转移是区间最大值，线段树维护即可。

然后发现 $dp_{i,p,0}$ 与 $dp_{i,p,1}$ 完全对称，消去 $t$ 这一维。$i-1$ 转移至 $i$ 时：

$$
dp_{p}\gets
\begin{cases}
dp_{p}+a_i[a_i=a_{i-1}],\space p\neq i-1 \\
\max\{\max_{c=0}^{i-2}\{dp_{c}\},dp_{pre_i}+a_i\},\space p=i-1
\end{cases}
$$

时间复杂度 $O(n\log n)$。这题和 P10200 真是像的不能再像了。

Happy birthday to Nahida!

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 200009
#define M 1000000
int T,n,pre[N],lst[M+9];ll a[N],x[N<<2],t[N<<2],val;
void bd(int l,int r,int p){
	x[p]=t[p]=0;if(l==r)return;
	int mid=(l+r)>>1;bd(l,mid,p<<1);bd(mid+1,r,p<<1|1);
}
inline void tg(int p,ll d){x[p]+=d,t[p]+=d;}
inline void pd(int p){if(t[p])tg(p<<1,t[p]),tg(p<<1|1,t[p]),t[p]=0;}
void upd(int l,int r,int pl,int pr,int p,ll d){
	if(l<=pl&&pr<=r){tg(p,d);return;}
	pd(p);int mid=(pl+pr)>>1;
	if(l<=mid)upd(l,r,pl,mid,p<<1,d);
	if(r>mid)upd(l,r,mid+1,pr,p<<1|1,d);
	x[p]=max(x[p<<1],x[p<<1|1]);
}
ll qr(int l,int r,int pl,int pr,int p){
	if(l<=pl&&pr<=r)return x[p];
	pd(p);int mid=(pl+pr)>>1;ll res=-0x3f3f3f3f3f3f3f3fll;
	if(l<=mid)res=max(res,qr(l,r,pl,mid,p<<1));
	if(r>mid)res=max(res,qr(l,r,mid+1,pr,p<<1|1));
	return res;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=M;++i)lst[i]=0;
		for(int i=1;i<=n;++i)scanf("%lld",&a[i]),pre[i]=lst[a[i]],lst[a[i]]=i;
		bd(0,n,1);
		for(int i=2;i<=n;++i){
			val=qr(0,i-2,0,n,1);
			if(pre[i])val=max(val,qr(pre[i],pre[i],0,n,1)+a[i]);
			upd(i-1,i-1,0,n,1,val);
			if(a[i]==a[i-1])upd(0,i-2,0,n,1,a[i]);
		}
		printf("%lld\n",qr(0,n-1,0,n,1));
	}
	return 0;
}
```

---

## 作者：Yujinhe469 (赞：17)

考虑每个数对于答案的贡献。

如样例中第一个 $5$ 对答案没有贡献，但是第二个 $5$ 有，因为它的加入导致答案增加。

![](https://cdn.luogu.com.cn/upload/image_hosting/j5qjfugu.png)

首先注意到如果有两个连续的同色数，它们**必为同色**。于是我们就可以处理到只剩一个，其他的都直接计入答案。

这样做的好处是：处理后的序列不会有连续的数对答案有贡献，即每个数的**左侧与其最靠近的同色数**与其之间有间隔。

设 $f_i$ 表示前 $i$ 个数中，第 $i$ 个数对答案作出贡献的方案中得分的最大值。记 $pre_i$ 为每个数**左侧与其最靠近的同色数**的下标，显然若 $pre_i=0$ ，那么第 $i$ 个数对答案不会作出贡献，也即 $f_i$ 无需计算。$pre_i$ 是可以在线性时间内预计算的。

对$f_i$作出贡献的方案中，$i$ 本身以及 $pre_i$ 是必须同色的，且这两个数中间的都与它们异色。

![](https://cdn.luogu.com.cn/upload/image_hosting/annul9xs.png)

$f_i$ 由以下三种情况得来：

$1°$ $pre_i$ 对答案有贡献

此时相邻的两个红色块之间的蓝色块对答案都没有贡献（由于之前已经处理掉了相邻的同色块），只有 $pre_i$ 的前后两格可能有贡献，需要特判

$f_i=f_{pre_i} + a_i$

若 $a_{pre_i-1} = a_{pre_i+1}$，那么 $f_i$ 需要额外加上 $a_{f_{pre_i+1}}$ 的值。

![](https://cdn.luogu.com.cn/upload/image_hosting/s4yle8vh.png)

$2°$ $pre_i$ 对答案无贡献

同理，$pre_i+2$以后的到 $i$ 之前的都对答案没有贡献，只有 $pre_i+1$ 有可能。

$(1)$ $pre_i+1$ 的确有贡献

$f_i = f_{pre_i+1} + a_i$

![](https://cdn.luogu.com.cn/upload/image_hosting/pzw6hwd9.png)

$(2)$ $pre_i+1$ 没有贡献

这也就意味着 $pre_i$ 之前的与它之后的贡献没有关系，分别处理即可。

$f_i = $ $\displaystyle\max_{j=1}^{pre_i-1} f_{j} + a_i$

前缀最大值可以随着求解 $f$ 而得出。

![](https://cdn.luogu.com.cn/upload/image_hosting/w08p9f26.png)

这个做法的时间是线性的。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200009;
ll n,a[N],b[N],ans,len;
void solveBF(){
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int k=0;k<(1<<n);k++){
		ll now0=0,now1=0,cnt=0;
		for(int i=1;i<=n;i++){
			int p=(k>>(i-1))&1;
			if(p==0){
				if(now0==a[i]) cnt+=a[i];
				now0=a[i]; 
			}else{
				if(now1==a[i]) cnt+=a[i];
				now1=a[i];
			}
		} 
		ans=max(ans,cnt);
	}
	cout<<ans<<endl;
	ans=0;
}
int pre[5*N],nxt[5*N];
ll f[N],fm[N];
ll max(ll num1,ll num2){
	if(num1>num2) return num1;
	return num2;
} 
void solve(){
	for(int i=1;i<=n;i++){
		cin>>b[i];
		if(b[i]==a[len]) ans+=b[i];
		else a[++len]=b[i];
	}
	n=len;
	for(int i=n;i>=1;i--){
		pre[nxt[a[i]]]=i;
		nxt[a[i]]=i;
	}
	f[0]=fm[0]=0;
	for(int i=1;i<=n;i++){
		fm[i]=fm[i-1];
		if(pre[i]==0) continue;
		f[i]=f[pre[i]]+a[i]+(a[pre[i]-1]==a[pre[i]+1])*a[pre[i]+1];
		f[i]=max(f[i],f[pre[i]+1]+a[i]);
		f[i]=max(f[i],fm[pre[i]-1]+a[i]);
		fm[i]=max(fm[i-1],f[i]);
	}
	cout<<ans+fm[n]<<endl;
	for(int i=1;i<=n;i++) f[i]=a[i]=pre[i]=nxt[a[i]]=0;
	len=ans=0;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	freopen("color.in","r",stdin);
	freopen("color.out","w",stdout);
	int T;
	cin>>T;
	while(T--){ 
		cin>>n;
		if(n<=15)
			solveBF();
		else
			solve();
	}
	return 0;
} 
```

其中 $solveBF$ 函数为暴力部分分。

---

## 作者：wosile (赞：17)

我们可以设 $f_{i,j}$ 表示考虑前 $i$ 个数，与 $A_i$ 颜色不同的最后一个数是 $A_j$ 的最大价值，然后就得到了一个优秀的 50 分做法。$f_{i,j}$ 可以转移到 $f_{i+1,i}$ 和 $f_{i+1,j}$。

发现 $f_{i+1,i}$ 好像很关键！于是我们直接把 $f_i$ 的定义改成原来的 $f_{i,i-1}$。这样我们有 $f_i=\max\limits_{j=1}^{i-1}(f_j+[A_{j-1}=A_i]A_i+\sum\limits_{k=j}^{i-2}[A_k=A_{k+1}]A_k)$。这个 $\sum$ 已经可以直接全局加做了，但是我们把相邻的相同数提前缩起来就没有这个 $\sum$ 了。

然后只有一个前缀 max 和同颜色前缀 max。

一个我也不知道对不对但是过了大样例的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005],n,Tc;
typedef long long ll;
ll f[200005],mx[1000005],Mx;
int main(){
    freopen("color.in","r",stdin);
    freopen("color.out","w",stdout);
    scanf("%d",&Tc);
    while(Tc--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        ll ans=0;
        for(int i=1;i<n;i++)if(a[i]==a[i+1])ans+=a[i];
        n=unique(a+1,a+n+1)-a-1;
        Mx=0;
        memset(mx,-0x3f,sizeof(mx));
        for(int i=1;i<=n;i++){
            f[i]=max(Mx,mx[a[i]]+a[i]);
            Mx=max(Mx,f[i]);
            mx[a[i-1]]=max(mx[a[i-1]],f[i]);
        }
        printf("%lld\n",Mx+ans);
    }
    return 0;
}
```

---

## 作者：__builtin__BaoziVerh (赞：15)

### 题意
在一个长为 $n$ 的的数组上选择给每个数涂色，计算所有上个(即下标比它小)的同样颜色数的数之和$\\$
### 问题转化
显而易见得就可以发现，对于每个配上对(即提供了贡献的)组，在这对数中间的数只有位置连续的重复的数字和处于两端能提供贡献，而如果将位置连续的重复的数字染上不同的颜色肯定是不优的，所以我们可以转化为在一个数轴上,选择哪些线段使贡献和最高,考虑 dp$\\$
### 解法
如 $333,4,4,7,8,5,333,5$ 我们可以将两个 $333$ 染成蓝色，剩下四个数染为红色，在两个 $333$ 中间有贡献的只有连续的 $4$ 和边上的 $5$ 。$\\$
首先我们预处理 $lastplace_i$，记录i上一次出现的位置并处理出所有重复的数。$\\$
然后进行 dp。$\\$
状态: $dp[i][0/1]$ 表示从$0$到$i$的序列中 $lastplace_i$ 到 $i$ 这一段有/没有选择$\\$
我们可以推出这样的状态转移方程$\\$
$dp[i][0]=\max(dp[i-1][1],dp[i-1][0])\\$
$dp[i][1]=\max(dp[lastplace_i][1],dp[lastplace_i][0],dp[lastplace_i+1][1],dp[lastplace_i+1][0])+a[i]\\$
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[200000+10],last[1000000+10],lastplace[200000+10],tag,dp[200000+10][3];
signed main(){
    cin>>t;
    while(t--){
        tag=0;
        memset(dp,0,sizeof(dp));
        memset(last,0,sizeof(last));
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            lastplace[i]=last[a[i]];
            last[a[i]]=i;
            if(a[i]==a[i-1]){
                tag+=a[i];
                dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
                dp[i][1]=dp[i-1][1];
            }else{
                dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
                if(lastplace[i])dp[i][1]=max(max(dp[lastplace[i]][0],dp[lastplace[i]][1]),max(dp[lastplace[i]+1][0],dp[lastplace[i]+1][1]))+a[i];
            }
        }
        cout<<max(dp[n][0],dp[n][1])+tag<<endl;
    }
}
```

---

## 作者：luanyanjia (赞：12)

我们设 $r_i$ 为最后一个填的是红色，上一个填蓝色的值为 $i$ 的最大答案，$b_i$ 意义类似。

先写出朴素的转移方程。

当上一个和这一个都是红色：

$$ r_i = r_i + [ a_i = a_{i-1} ] \times a_i$$

上一个蓝色，这一个红色：

$$ r_i = \max(maxb , b_{a_i} + a_i) $$

其中 $maxb$ 是 $b_i$ 的最大值。

染蓝色的情况同理，这样我们的复杂度就是 $O(n \times V)$ 的了。

注意到我们对数组的操作只有单点改，全局 $\max$ 和全局加，~~然后可以直接线段树维护~~，可以分别存下两个数组的全局加 $tag$ 和 全局 $\max$ 即可。实现非常简单。

其实这个可以再优化。

注意到 $r$ 数组和 $b$ 数组是完全对称的，也就是说我们只保留转移方程的一半也能计算出答案，其实就是把转移的定义改为了和上一个的颜色是否相同罢了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void rd(){}
template<typename T,typename ...U>
inline void rd(T &x,U &...args){
	char ch=getchar();
	T f=1;x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;rd(args...);
}
typedef long long ll;
const int N=2e5+5,V=1e6+5;
int T,n,a[N];ll r[V];
inline void Solve(){
	memset(r,-0x3f,sizeof r);
	ll mxr=0,tgr=0;rd(n);
	for(int i=1;i<=n;i++){
		rd(a[i]);
		ll tmpr=max(mxr,r[a[i]]+a[i])+tgr;
		if(a[i]==a[i-1])tgr+=a[i];
		r[a[i-1]]=max(r[a[i-1]],tmpr-tgr);
		mxr=max(mxr,r[a[i-1]]);
	}
	mxr=0;
	for(int i=1;i<=1000000;i++)mxr=max(mxr,r[i]);
	printf("%lld\n",mxr+tgr);
}
signed main(){
	rd(T);
	while(T--)Solve();
	return 0;
}
```

---

## 作者：ThisIsLu (赞：11)

首先考虑朴素，优雅的暴力。

设 $dp_{i,j}$ 表示考虑前 $i$ 个，与 $i$ 最近的异色数距离为 $j$ 的最大值。

转移是显然的：

$$
dp_{i,j}=
\begin{cases}
dp_{i-1,j-1}+[a_i=a_{i-1}]a_i & j>1\\
\max\limits_{0\le k <i-1}dp_{i-1,i-1-k}+[a_k=a_i]a_i &j=1
\end{cases}
$$

然后你会发现这个转移几乎是确定性的，不难得到：

$$dp_{i,j}=\sum_{i-j+1<k\le i}[a_k=a_{k-1}]a_k+dp_{i-j+1,1}$$

这里我们设 $f_i=dp_{i,1}$。

得到：

$$
f_i=\max\limits_{0\le k <i-1}\sum_{k+1<j<i}[a_{j-1}=a_j]a_j+f_{k+1}+[a_k=a_i]a_i
$$

设 $s_i=\sum_{1<j\le i} [a_j=a_{j-1}]a_j$，则转移可以简化为：

$$
f_i=\max\limits_{0\le k <i-1}s_{i-1}-s_{k+1}+f_{k+1}+[a_k=a_i]a_i
$$

开桶处理即可。

代码等公示。

upd:

代码公示了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
const int N=2e5,M=1e6;
const long long INF=1e18;
int a[N+5];
long long maxx,ans,sum[N+5],dp[N+5],mp[M+5];
void solve(){
    cin>>n;
    maxx=ans=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]==a[i-1]) sum[i]=sum[i-1]+a[i];
        else sum[i]=sum[i-1];
        if(i>2){
            maxx=max(maxx,dp[i-1]-sum[i-1]);
            mp[a[i-2]]=max(mp[a[i-2]],dp[i-1]-sum[i-1]);
            dp[i]=max(maxx,mp[a[i]]+a[i])+sum[i-1];
        }
    }
    for(int i=1;i<=n;i++){
        ans=max(ans,dp[i]-sum[i]+sum[n]);
        mp[a[i]]=-INF;
    }
    cout<<ans<<"\n";
}
signed main(){
    cin>>T;
    for(int i=1;i<=M;i++) mp[i]=-INF;
    while(T--) solve();
    return 0;
}
```

---

## 作者：cosf (赞：8)

先考虑朴素 dp。

令 $f_{i, j}$ 表示填到第 $i$ 位，上一个与 $i$ 不同色的数的 $a$ 值为 $j$，则有以下转移（全部取 $\max$）：

$$
dp_{i, j} = dp_{i-1, j} + a_i \times [a_i = a_{i - 1}]\\
dp_{i, a_{i-1}} = \max_j\{a_i \times [a_i = a_j] + dp_{i-1, j}\}
$$

其中第一个表示与 $i-1$ 同色，第二个表示与 $i-1$ 异色。

容易发现，第一个式子就是一个全局加。第二个式子可以理解为：

$$
\max\{dp_{i-1, j}, dp_{i-1, a_i} + a_i\}
$$

全局 $\max$ 和单点求值。

可以发现，只需支持全局加、全局 $\max$、单点求值、单点修改，$O(n)$ 就能解决。

初始值即 $dp_{0, 0} = 0, dp_{0, i} = -\infty(i \not=0)$。答案即 $\max_jdp_{n, j}$。

---

## 作者：伊地知虹夏 (赞：8)

# CSP T3 题解

考虑设 $f_{i, j} $ 表示考虑前 $i$ 个数，最大的颜色不等于 $i$ 的数权值为 $j$ 的最大收益。

转移为：

1. $f_{i, j} + [a_i=a_{i+1}]a_i \to f_{i+1,j}$
1. $f_{i, j} + [j = a_{i+1}]j \to f_{i+1, a_i}$

我们考虑用数据结构维护 $f_i$，要支持 单点查/单点 chkmax/全局求 max/全局加，线段树可以轻松维护，时间复杂度 $\mathcal{O}(n\log n)$。

实际上可以只用数组加上一个 tag 来维护，所以也能做到 $\mathcal{O}(n)$。

---

## 作者：kkxacj (赞：7)

#### 思路

容易发现我们只需要关心红蓝两个颜色最后一次出现是在哪里，设 $f_{0/1,i,j}$ 表示第 $i$ 个位置颜色为红色或蓝色与其相反的颜色最后一次出现在 $j$ 的最大贡献，很容易想到转移式： 

1. $f_{z,i,j} = \max(f_{z,i,j},f_{z,i-1,j} + a_i\times\left[a_i == a_{i-1}\right])$。
1. $f_{z,i,i-1} = \max(f_{z,i,i-1},f_{!z,i,j}+a_i\times\left[a_i == a_j\right])$。

考虑优化，首先对于 $f_{z,i,j}$，若 $j$ 不等于 $i-1$，看 $a_i$ 是否和 $a_{i-1}$ 相等即可，可以用一个 $mx_{0/1}$ 在统计其最大值，$sum$ 记这个和。

否则，记 $v_{0/1,j}$ 表示值为 $j$ 染成红色或蓝色时最大贡献是多少，$f_{z,i,i-1} = \max(f_{z,i,i-1},mx_{!z},v_{z,a_i}+a_i)$，注意 $v$ 的初值要赋的很小，不然会出问题。

在算完 $f_{z,i,i-1}$ 后，若 $a_i$ 等于 $a_{i-1}$ 要减去一个 $a_i$，因为它并不能加，时间复杂度合法，至于空间可以把第二维优化掉，因为只跟前一个有关系，后面答案就是最大值加 $sum$。

赛后凭记忆写了一份，能过民间数据，后期官方代码公布了在换。

[代码](https://www.luogu.com.cn/paste/p904ry85)

---

## 作者：Zzzcr (赞：7)

记录下场上想法，比较奇怪。

对于一对 $a_i=a_j$，把 $i,j$ 填红，中间填蓝（或者相反）可以让 $a_j$ 对答案造成贡献。我们称这种操作是选择了线段 $[i,j]$，这条线段的价值为 $a_j$。

容易发现：

- 对于每种颜色，只考虑相邻两个构成的线段一定不劣。
- 一种操作方案是合法的，当且仅当线段两两之间交集 $\le 2$。

于是原问题等价于 $O(n)$ 条线段选出若干条，使得两两之间交集 $\le 2$，最大化选出的线段价值和。BIT 优化 dp 即可。

---

## 作者：_O_v_O_ (赞：6)

设 $dp_i$ 为前 $i$ 个数的答案，设 $b_i=\sum_{j=1}^{i=1}a_j[a_j=a_{j-1}]$，那么对于一个 $i$，我们可以，设 $S_i$ 为与 $i$ 相同的下标 $j$ 的集合：

- 放弃 $i$：$dp_i=\max\{dp_i,dp_{i-1}\}$
- 选择 $i$，$dp_i=\max_{j\in S_{a_i}\land j<i}\{dp_i,dp_{j+1}+b_{i}-b_{j+1}+a_i\}$

我们注意到前面选择 $i$ 时那一大坨可以拆成 $dp_i=\max_{j\in S_{a_i}\land j<i}\{dp_i,dp_{j+1}-b_{j+1}\}+a_i+b_{i-1}$。

考场做法：那么我们可以用 $V$ 个堆来维护相同 $a_j$ 时 $\max \{dp_{j+1}-b_{j+1}\}$ 的值，$O((n+V)\log V)$。  
但事实是我们注意到我们直接用一个长度为 $V$ 的数组每次取 $\max$ 维护就行了，$O(n+V)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int read(){
	int num=0,fg=1;
	char c=getchar();
	while((c<'0'||'9'<c)&&c!='-') c=getchar();
	if(c=='-'){
		fg=-1;
		c=getchar();
	}
	while('0'<=c&&c<='9'){
		num*=10,num+=c-'0';
		c=getchar();
	}
	return num*fg;
}

void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x<10){
		putchar(x+'0');
		return;
	}
	write(x/10);
	putchar(x%10+'0');
}

const int N=2e5+5,V=1e6+5;
int T,n,a[N];
ll b[N],dp[N];
priority_queue<ll> qp[V];

signed main(){
	T=read();
	while(T--){
		n=read();
		fill(dp+1,dp+n+1,0);
		for(int i=1;i<=V-5;i++) while(!qp[i].empty()) qp[i].pop();
		for(int i=1;i<=n;i++) a[i]=read();
		for(int i=1;i<=n;i++) b[i]=b[i-1]+(a[i]==a[i-1])*a[i];
		for(int i=1;i<=n;i++){
			if(a[i]==a[i-1]) dp[i]=dp[i-1]+a[i];
			else{
				if(qp[a[i]].empty()) dp[i]=dp[i-1];
				else dp[i]=max(dp[i-1],qp[a[i]].top()+a[i]+b[i-1]);
			}
			if(i>1) qp[a[i-1]].push(dp[i]-b[i]);
		}
		write(dp[n]);putchar('\n');
	}
	return 0;
}
```

upd：考场代码没开 `long long` 挂了 $25$ 分，导致民间数据通过，警示后人。

---

## 作者：Unnamed114514 (赞：6)

直接大力线性 dp，经典模型是直接定义 $f_i$ 表示 $i$ 的答案，然后枚举前面的 $j$ 进行转移。

放到本题中，$j$ 就是 $i$ 前面第一个和 $i$ 同色/异色的位置，如果是异色的话，$j$ 的贡献不是很好算，直接在状态上做手脚，把 $f_i$ 的定义改成钦定 $i$ 和 $i+1$ 颜色不同时的答案。

转移就看 $i$ 和 $i-1$ 的颜色关系，不妨令 $i$ 和 $i-1$ 同色，异色同理。

枚举 $j$ 表示 $[1,i-2]$ 中最后一个和 $i$ 异色的位置，那么 $j$ 和 $i+1$ 颜色相同，有转移 $f_i\gets\max\{f_i,f_j+\sum\limits_{k=j+1}^{i-1}[a_k=a_{k+1}]a_k+[a_j=a_{i+1}]a_j\}$。

令 $s_i=\sum\limits_{j=1}^{i-1}[a_j=a_{j+1}]a_j$，有转移 $f_i\gets\max\{f_i,f_j+s_{i-1}-s_j+[a_j=a_{i+1}]a_j\}$。

这时已经容易想到讨论 $a_j$ 和 $a_{i+1}$ 的关系了。

若 $a_j=a_{i+1}$，那么容易想到令 $j$ 为 $[1,i-2]$ 最后一次出现 $a_j$ 的位置一定不劣，这种情况单独算即可。

若 $a_j\ne a_{i+1}$，其实可以把 $a_j=a_{i+1}$ 的情况放一起算，因为少加上了 $a_j$ 一定不优，就是 $f_i\gets\max\{f_i,f_j+s_{i-1}-s_j\}$，用前缀 $\max$ 维护一下即可。

---

## 作者：Missa (赞：6)

现在的题解好像都没代码。补个代码，包括一个 $O(n^2)$ 暴力，$27$ 行。

观察此题，dp 是少不了。注意到只有两个序列的最末位是重要的，可以设 dp 状态：$f_{i, x, y}$ 表示考虑前 $i$ 个数，红序列的末位为 $i$，蓝序列的末位为 $j$，的最大值，转移为：

$$
f_{i-1, x, y} + a_i \cdot [x = a_i] \to f_{i, a_i, y} \\
f_{i-1, x, y} + a_i \cdot [y = a_i] \to f_{i, x, a_i} \\
$$

其中第一个对应填到红序列上，第二个对应填到蓝序列上，$[]$ 为艾佛森括号，若括号内条件满足则为 $1$，否则为 $0$。

考虑优化。注意到，如果当前要考虑的数为 $a_i$，则两个序列中一定有一个的末位为 $a_{i-1}$，不妨设其为红序列。那么，只有 $f_{a_{i-1},*}$ 是有用的。据此，不妨设 $f_{i, j}$ 为：考虑前 $i$ 个数，第 $i$ 个数属于红序列，蓝序列的末位为 $j$，此时的最大值。有转移：

$$
f_{i-1, j} + a_i \cdot [a_{i-1}=a_i] \to f_{i, j} \\
f_{i-1, j} + a_i \cdot [a_{i} = j] \to f_{i, a_{i-1}}
$$

一份使用了滚动数组的实现：

```cpp
#include <bits/stdc++.h>

using LL = long long;

void solve() {
  int n; scanf("%d", &n);
  std::vector<int> a(n);
  int mx = 0;
  for (int &x : a) scanf("%d", &x), mx = std::max(mx, x);
  LL sum = 0;
  std::vector<LL> f(mx + 1, -1e18);
  for (int i = 1; i < n; i++) {
    int t = a[i] == a[i - 1] ? a[i] : 0;
    std::vector<LL> g(mx + 1, -1e18);
    g[a[i - 1]] = std::max(g[a[i - 1]], sum);
    for (int j = 1; j <= mx; j++) {
      g[a[i - 1]] = std::max(g[a[i - 1]], f[j] + (j == a[i] ? a[i] : 0));
      g[j] = std::max(g[j], f[j] + t);
    }
    f.swap(g), sum += t;
  }
  printf("%lld\n", *std::max_element(f.begin(), f.end()));
}

int main() {
  int T; scanf("%d", &T); while (T--) {
    solve();
  }
}
```

考虑去掉第一维直接转移。第一个转移相当于全局加，因为与 $j$ 无关。第二个转移可以分成 $j \neq a_i$ 部分和 $j=a_i$ 部分，前部分只需要找到 $f_i$ 的最大值转移，后半部分是平凡的。

至于初始化，先初始化所有 $f_i$ 为负无穷，接着让 $i$ 从 $2$ 到 $n$ 考虑，每次加入蓝序列恰为 $\{a_1 \sim a_{i-1}\}$ 且红序列恰为 $\{a_i\}$ 的情况，这是因为这个 dp 无法处理有一个序列为空的情况，需要枚举第一段属于同序列的数的长度。

考虑代码实现。维护一个 $tag$ 表示全局加的标记，设 $t=a_i \cdot [a_i=a_{i-1}]$，因为转移时需要全局加 $t$，$f_j-t$ 为之前的 $f$ 数组。转移完后 $tag \gets t$。因为这个 $tag$ 恰好就是蓝序列恰为 $\{a_1 \sim a_{i-1}\}$ 且红序列恰为 $\{a_i\}$ 时的值，将这个情况考虑进 dp 数组，相当于 $f_{a_{i-1}}$ 对 $tag-tag=0$ 取 $\max$。

为了处理 $j \neq a_i$ 的转移，需要维护全局最大值。

```cpp
#include <bits/stdc++.h>

using LL = long long;

void solve() {
  int n; scanf("%d", &n);
  std::vector<int> a(n);
  int mx = 0;
  for (int &x : a) scanf("%d", &x), mx = std::max(mx, x);
  LL MAX = -1e18, sum = 0;
  std::vector<LL> f(mx + 1, -1e18);
  for (int i = 1; i < n; i++) {
    int t = a[i] == a[i - 1] ? a[i] : 0;
    f[a[i - 1]] = std::max(f[a[i - 1]], 0ll); // a[i] 为红序列，a[0] ~ a[i-1] 为蓝序列
    f[a[i - 1]] = std::max(f[a[i - 1]], MAX - t); // j != i 的情况
    f[a[i - 1]] = std::max(f[a[i - 1]], f[a[i]] - t + a[i]); // j = i 的情况
    MAX = std::max(MAX, f[a[i - 1]]);
    sum += t;
  }
  printf("%lld\n", MAX + sum);
}

int main() {
  int T; scanf("%d", &T); while (T--) {
    solve();
  }
}
```

---

## 作者：Cure_Wing (赞：5)

[P11233 [CSP-S 2024] 染色](https://www.luogu.com.cn/problem/P11233)

### 解析

设 $f_{i,0/1,0/1}$ 表示选到第 $i$ 个数，第 $i$ 个数选了红色（$0$）或者蓝色（$1$），第 $(i-1)$ 个数选了红色或者蓝色的最大值。

可以得到这样的转移方程：

$$f_{i,0,0}=\max\{f_{i-1,0,0},f_{i-1,0,1}\}+[a_{i-1}==a_i]\times a_i$$

$$f_{i,1,1}=\max\{f_{i-1,1,0},f_{i-1,1,1}\}+[a_{i-1}==a_i]\times a_i$$

这两个同色转移是 $O(1)$ 的，不多叙述。

对于剩下的转移，设 $g(i,j)$ 表示 $[i,j+1)$ 内相邻两数相同的数对的和，即 $g(i,j)=\sum\limits_{k=i}^{j-1}[a_k==a_{k+1}]\times a_k$。

那么接下来我们枚举上一个不同颜色段 $[j,i)$，有：

$$f_{i,0,1}=\max\limits_{j=0}^{i-1}\{f_{j,1,0}+[a_{j-1}==a_i]\times a_i+g(j,i-1)\}$$

$$f_{i,1,0}=\max\limits_{j=0}^{i-1}\{f_{j,0,1}+[a_{j-1}==a_i]\times a_i+g(j,i-1)\}$$

这两个异色转移是 $O(n)$ 的，考虑优化。

发现 $g$ 函数满足差分，所以 $g(j,i-1)=g(1,i-1)-g(1,j)$。

此时就有：

$$f_{i,0,1}=\max\limits_{j=0}^{i-1}\{f_{j,1,0}+[a_{j-1}==a_i]\times a_i-g(1,j)\}+g(1,i-1)$$

$$f_{i,1,0}=\max\limits_{j=0}^{i-1}\{f_{j,0,1}+[a_{j-1}==a_i]\times a_i-g(1,j)\}+g(1,i-1)$$

考虑转移中的 $[a_{j-1}==a_i]$，于是想到用线段树存储转移到 $a_i$ 时的 $f$。即线段树上叶子节点从左到右第 $k$ 个存储所有 $a_{j-1}$ 的 $f_{j,1,0}+[a_{j-1}==k]\times k-g(1,j)$ 和 $f_{j,0,1}+[a_{j-1}==k]\times k-g(1,j)$ 的最大值，这样转移就做到了 $O(\log_2v)(v=\max\limits_{i=1}^n\{a_i\})$。更新时只需要将值域分为 $3$ 段：$[0,a_{i-1}),\{a_{i-1}\},(a_{i-1},v](v=\max\limits_{i=1}^n\{a_i\})$。从上面的转移方程可以看出，对于每一段，它们更新的最大值是相同的。

这样总时间复杂度为 $O(T(n\log_2v+v))(v=\max\limits_{i=1}^n\{a_i\})$，空间复杂度为 $O(n+v)$。

[代码](https://www.luogu.com.cn/paste/v3qo1s33)。

后来发现红蓝颜色互换其实是一样的，考虑转移方程只做一半是不是就可以了？

---

## 作者：篮网总冠军 (赞：4)

第一次考场切蓝，纪念一下。

大家好像都跟我不一样/bx。

下面那位大佬已经很全了，但是我想说，$dp_{i,0}$ 直接求 $\max(dp_{i-1,0},dp_{i-1,1})$ 即可，因为第 $i$ 个不选的话，最大值一定是前一个选或不选的最大值。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[200005];
int md[1000005];
long long dp[200005][2];
long long s[200005];
int main(){
//	freopen("color.in","r",stdin);
//	freopen("color.out","w",stdout);
	int t;
	cin>>t;
	while(t--){
		memset(dp,0,sizeof(dp));
		memset(s,0,sizeof(s));
		memset(md,0,sizeof(md));
		int n;
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++){
			if (a[i]==a[i-1]) s[i]=s[i-1]+a[i];
			else s[i]=s[i-1];
		}
		for(int i=1;i<=n;i++){
			int r=md[a[i]];
			dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
			if (md[a[i]]>0) dp[i][1]=max(dp[r+1][0],dp[r+1][1])+a[i]+s[i-1]-s[r];
			dp[i][1]=max(dp[i][1],dp[i][0]);
			md[a[i]]=i;
		}
		cout<<max(dp[n][0],dp[n][1])<<endl;
	}
	return 0;
}
```

---

## 作者：xcxxx_ (赞：4)

由于一共只有两种颜色，因此每个数左边的数要么与其颜色相同要么不同，我们称与左边的数颜色不同的数为关键点，可以发现非关键点是否产生贡献只需要看他与其左边的数是否相同，而关键点只需要看其与上一个关键点的上一个位置的数是否相同即可，因此考虑对关键点 $dp$，设 $dp_i$ 表示 $i$ 是最后一个关键点时前 $i$ 个数的最大得分，设 $s_i=\sum\limits_{j=1}^i [a_j=a_{j-1}]$，容易列出 $dp$ 方程：
$$
dp_i=\max\{s_{i-1},\max\limits_{j=1}^{i-1}(dp_j+s_{i-1}-s_j+[a_i=a_{j-1}]\cdot a_i)\}
$$
这样是 $\mathcal{O}(n^2)$ 的，考虑优化。

观察转移式，若 $a_{j-1}\neq a_i$，则转移相当于 $dp_i\leftarrow dp_j+s_{i-1}-s_j$，分离有关 $j$ 的部分，设 $M=\max (dp_j-s_j)$ ，直接将 $M+s_{i-1}$ 转移到 $dp_i$ 即可。

而对 $a_i=a_{j-1}$ 的情况，类似地记录 $m_x$ 表示$\max\limits_{a_{j-1}=x}(dp_j-s_j)$ ，将 $m_{a_i}+s_{i-1}+a_i$ 转移到 $dp_i$ 即可。

计算出 $dp_i$ 后更新 $M$ 和 $M_{a_i}$ 的值。

答案即为 $\max\limits_{i=1}^n dp_i+s_n-s_i$，即为前 $i$ 个数的得分加上最后 $n-i$ 个数颜色都一样的得分，复杂度 $\mathcal{O}(n)$

---

## 作者：Colinxu2020 (赞：4)

考虑设 $s_1$ 表示当前红色元素中的最后一个，$s_2$ 表示当前蓝色元素中的最后一个，一个显然的动态规划是设 $f_{i,x,y}$ 表示数组的前 $i$ 个元素中，$s_1=x,s_2=y$ 的最大总得分，有 $dp_{i,ai_i,y}=\max({\max({dp_{i-1,x,y})}}, dp_{i-1,ai_i,y}+ai_i)$，修改 $x$ 同理，复杂度为 $N \times (\max a_i)^3$，期望获得 $35$分。

考虑优化，容易发现 $f_{i,x,y}$ 有值的必要条件是 $x=ai_i$ 或 $y=ai_i$，因此很多的状态都浪费了，又发现 $s_1$ 与 $s_2$ 可以互换，转而设 $f_{i,x}$ 表示前 $i$ 个元素中，$s_1,s_2$ 中有一个 $=ai_i$，另一个 $=x$ 的最大收益，记这个 $=ai_i$ 的是 $s_k$。

计算转移方程，下记 $g(x,y)$ 当 $a_x=a_y$ 时为 $a_x$，否则为 $0$，假如 $s_k=s_{k-1},f_{i,x}=f_{i-1,x}+g(i,i-1)$，否则 $x$ 一定等于 $ai_{i-1},f_{i,ai_{i-1}}=\max(f_{i-1, ?}, f_{i-1,ai_i}+ai_i)$，运用这两个方程即可 $O(N \max a_i)$ 转移，获得 $65$ 分。

记 $dpmax_i$ 表示 $\max f_{i,x}$，考察两次 DP 转移之间的变化，对于 $\neq ai_{i-1}$ 的 $x$ 来说，只是整体加了 $g(i,i-1)$，而 $f_{i,ai_{i-1}}=\max(dpmax_{i-1}, f_{i-1, ai_i}+ai_i)$，先滚动状态一下，将空间复杂度压下来，容易发现后面的部分只影响 $O(1)$ 个元素，可以直接暴力转移，前面的部分我们维护全局的偏移量 $offset=\sum g(i,i-1)$ 即可，这样对于其他的元素 $f_{i,x}-offset$ 就没有变化，复杂度为严格线性 $O(N+\max a_i)$，获得 $100$ 分，注意需要开 `long long`。

代码将在公示后放出。

---

## 作者：晴空一鹤 (赞：3)

这种东西很好 dp。

一个观察是在最优策略下一个位置的数有贡献当且仅当他和他前面最后一个和他相同的数（记作 $pre_i$）在同一子序列。

证明可由调整法得。

于是设 $dp_{i,0/1}$ 表示到 $i$ 为止且 $i$ 和 $i-1$ 在/不在同一子序列时的最大值。转移很容易，对于在同一子序列，直接判一下 $a_i$ 和 $a_{i-1}$ 是否相同。不在同一子序列，用 $pre_i$ 前的 dp 值转移即可。

暂时没有代码，以后可能会加。

---

## 作者：happybob (赞：3)

考虑记 $f_{i,0/1}$ 表示 $1$ 到 $i$，且 $i$ 的颜色为 $0/1$ 时的答案。

对于转移，要么 $i$ 不产生贡献，即 $\max\{f_{i-1,0},f_{i-1,1}\}$，要么选择一个位置 $j$ 使得 $a_j=a_i$，将 $j$ 与 $i$ 染成对应的颜色，且 $(j,i)$ 必须全染另一种。把这个式子写出来之后发现只需要维护全局加全局 $\max$，直接做就行。复杂度 $O(TV)$。

目前没有获得代码。

---


# BZOJ4350 括号序列再战猪猪侠

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

括号序列是一个仅由 `()` 构成的序列。以下的括号序列是合法的：
1. `()` 是一个合法序列。
2. 如果 `A` 是一个合法序列，则 `(A)`  也是一个合法序列。
3. 如果 `A` 和 `B` 都是合法序列，则 `AB` 也是一个合法序列。

定义 $match_i$ 表示从左往右数第 $i$ 个左括号所对应的是第几个右括号。

现在得到了一个长度为 $2n$ 的括号序列，提供 $m$ 个信息，第 $i$ 个信息形如 $a_i,b_i$，表示 $match_{a_i}<match_{b_i}$。

现问，若根据这些信息还原出合法括号序列的方案数一共有多少？答案对 $998244353$ 取模。

## 说明/提示

对于所有数据，保证 $1\leq T\leq 5$，$1\leq n\leq 300$，$1\leq a_i,b_i\leq n$。

## 样例 #1

### 输入

```
5
1 0
5 0
3 2
1 2
2 3
3 2
2 1
2 3
3 3
1 2
2 3
3 1```

### 输出

```
1
42
1
2
0```

# 题解

## 作者：Redamancy_Lydic (赞：9)

根据题目要求，容易想到区间计数动态规划。

我们只考虑左括号，设 $dp_{l,r}$ 表示当前考虑从第 $l$ 到第 $r$ 个左括号时的方案数，注意，这里的状态同时包含了这些左括号对应的右括号。

考虑转移，我们设 `A` 为一个合法括号串，它表示的左括号区间是 $[l,r]$，可以很自然的分三种情况：

- `(A)`，此时需满足 $[l,r]$ 中所有右括号都没有要求大于第 $l-1$ 个左括号的右括号的限制。

- `()A`，此时和上面类似，需满足 $[l,r]$ 中所有右括号都没有要求小于第 $l-1$ 个左括号的右括号的限制。

- `(A`，同时把 `A` 从中间断开插入右括号，设当前枚举的断点为 $k$，此时需满足 $[l,k]$ 中所有右括号都没有要求大于第 $l-1$ 个左括号的右括号的限制，以及 $[l-1,k]$ 中所有右括号都没有要求大于区间 $[k+1,r]$ 中所有左括号的右括号的限制。

对于这些限制的快速判断我们可以维护一个矩阵，每条信息相当于矩阵上的一个点，这样对于前文的要求可以快速用二位前缀和的值的存在与否判断是否全部满足。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;	
const int maxn=500+10;
const int inf=1e13+7;
int n,m;
int dp[maxn][maxn],sum[maxn][maxn],a[maxn][maxn];
int ask(int l1,int r1,int l2,int r2)
{return sum[l2][r2]-sum[l1-1][r2]-sum[l2][r1-1]+sum[l1-1][r1-1];}
void Main()
{
	n=read(),m=read();
	for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)a[i][j]=sum[i][j]=0;
	bool ff=1;
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		a[x][y]=1;
		if(x==y)ff=0;
	}
	if(!ff){puts("0");return ;}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		}
	}
	memset(dp,0,sizeof dp);
	for(int i=1;i<=n;i++)dp[i][i]=1;
	for(int len=2;len<=n;len++)
	{
		for(int l=1;l<=n-len+1;l++)
		{
			int r=l+len-1;
			if(!ask(l,l+1,l,r))(dp[l][r]+=dp[l+1][r])%=mod;
			if(!ask(l+1,l,r,l))(dp[l][r]+=dp[l+1][r])%=mod;
			for(int k=l+1;k<r;k++)
			{ 
				if(!ask(l,l+1,l,k)&&!ask(k+1,l,r,k))
				{
					dp[l][r]=(dp[l][r]+dp[l+1][k]*dp[k+1][r]%mod)%mod;
				}
			}
		}
	}
	printf("%lld\n",dp[1][n]);
}
signed main()
{
#ifdef Lydic
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
//  #else
//   	freopen("Stone.in","r",stdin);
//   	freopen("Stone.out","w",stdout);
#endif
	int T=read();
	while(T--)Main();
    return 0;
}
```

---

## 作者：woshishabi11451444 (赞：6)

首先题目已经给了我们很多启发，观察括号序列的产生你应该能想到一个最初始的状态：令 $dp_{l, r}$ 表示以第 $l$ 个左括号开始到第 $r$ 个左括号其中的字符串构成合法括号序列的方案数。那么不能想到有如下转移式：

$$dp_{l, r} = dp_{l + 1, r} + \sum \limits_{k = l}^{r - 1} dp_{l, k} \times dp_{k + 1, r}$$

这个根据题目中构造括号序列的方式得来，其中 $dp_{l + 1, r} \rightarrow dp_{l, r}$ 这是题目中构造合法括号串的第一种方法，$dp_{l, k} \times dp_{k + 1, r} \rightarrow dp_{l, r}$ 这是题目中构造合法括号串的第二种方法。

由于题目给定的 $match_a < match_b$ 的要求，所以你的转移可能是非法的，你可以记录一个 $N \times N$ 的二维矩阵，其中这个矩阵的 $(i, j)$ 项表示 $match_i$ 是否小于 $match_j$，对这个矩阵做一个二维前缀和，由于每次只需访问 $match_x, match_{x + 1}, \dots match_y$ 中是否存在一个元素小于 $match_i, match_{i + 1}, \dots match_j$ 的任意一个值，这个可以理解为在这个二维矩阵上询问矩阵总和。

然后如果你照着这个 dp 状态写，你会发现这个状态会算重。

问题就处在两个合法序列的合并，这样可能会发生重复。

比如说合法括号序列：$()()()$，这个在如上的状态会计算多次。

考虑在此基础上重新设计状态，$dp_{l, r}$ 表示表示以第 $l$ 个左括号开始到第 $r$ 个左括号其中的字符串构成合法括号序列中 $match_l$ 不是 $match_{l}, match_{l + 1}, \dots match_r$ 中的最大值，$f_{l, r}$ 表示表示以第 $l$ 个左括号开始到第 $r$ 个左括号其中的字符串构成合法括号序列中 $match_l$ 是 $match_{l}$。

稍作思考，得到状态转移方程：

$$dp_{l, r} = \sum \limits_{k = l}^{r - 1} f_{l, k} \times (dp_{k + 1, r} + f_{k + 1, r})$$

$$f_{l, r} = f_{l + 1, r} + dp_{l + 1, r}$$

其实本质上我们算 $dp_{l, r}$ 是在考虑 $match_l$ 是在哪个 $match_{i} + 1, match_{i} + 2, match_{i} + 3, \dots, match_{i + 1} - 1$ 的范围内，这样必然就不会重复计算一个合法的括号序列多次。 

上面已经说了如何处理非法转移，这里不过多赘述了。

注意特判 $a_i = b_i$ 的情况。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 305;
const int mod = 998244353;

long long f[N][N], dp[N][N];
int T, n, m, v[N][N], s[N][N], sum[N][N];

void ps(long long &a, long long b){
  a += b;
  if(a >= mod) a -= mod;
}

long long Get(int al, int ar, int bl, int br){
  return sum[ar][br] - sum[ar][bl - 1] - sum[al - 1][br] + sum[al - 1][bl - 1];
}

void Solve(){
  cin >> n >> m;
  for(int i = 1; i <= n; i++){
    for(int j = 1; j <= n; j++) v[i][j] = 0;
    for(int j = i; j <= n; j++) dp[i][j] = f[i][j] = 0;
  }
  bool flag = 0;
  for(int i = 1, a, b; i <= m; i++){
    cin >> a >> b;
    v[a][b] = 1;
    if(a == b){
      flag = 1;
    }
  }
  if(flag){
    cout << 0 << '\n';
    return ;
  }
  for(int i = 1; i <= n; i++){
    for(int j = 1; j <= n; j++){
      s[i][j] = s[i - 1][j] + v[i][j];
    }
    for(int j = 1; j <= n; j++){
      sum[i][j] = sum[i][j - 1] + s[i][j];
    }
  }
  for(int i = 1; i <= n; i++) dp[i][i] = 0, f[i][i] = 1;
  for(int len = 2; len <= n; len++){
    for(int r = len; r <= n; r++){
      int l = r - len + 1;
      if(!Get(l, l, l + 1, r)){
        ps(f[l][r], f[l + 1][r]);
        ps(f[l][r], dp[l + 1][r]);
      }
      for(int i = l; i < r; i++){
        if(!Get(i + 1, r, l, i)) ps(dp[l][r], f[l][i] * (f[i + 1][r] + dp[i + 1][r]) % mod);
      }
    }
  }
  cout << (dp[1][n] + f[1][n]) % mod << '\n';
}

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  for(cin >> T; T--; Solve()){
  }
  return 0;
}
```

---

## 作者：white_tiger_yyyy (赞：4)

我们设 $dp_{i,j}$ 表示第 $i$ 到第 $j$ 个括号合并为序列且最外层不是括号 $i$ 的可能性，$f_{i,j}$ 表示最外层是括号 $i$ 的可能性。则有：

$$
\begin{cases}
dp_{i,j}=\sum f_{i,k}(dp_{k+1,j}+f_{k+1,j})\\
f_{i,j}=dp_{i+1,j}+f_{i+1,j}
\end{cases}
$$

当然，并不是所有情况都能合并，所以需要维护 $p_{i,j,k}$ 和 $q_{i,j,k}$，表示 $k$ 能否接在 $i$ 到 $j$ 的左侧/包住 $i$ 到 $j$。

时间、空间复杂度均为 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=305,md=998244353;
int t,n,m,f[N][N],dp[N][N];
int p[N][N][N],q[N][N][N];
void solve(){
	memset(dp,0,sizeof(dp));
	memset(f,0,sizeof(f));
	memset(p,0,sizeof(p));
	memset(q,0,sizeof(q));
	cin>>n>>m;
	int flag=0;
	while(m--){
		int x,y;cin>>x>>y;
		if(x==y||flag){
			flag=1;
			continue;
		}if(x<y) q[y][y][x]=1;
		else p[x][x][y]=1;
	}if(flag){
		cout<<"0\n";
		return;
	}for(int i=1;i<=n;i++)
		f[i][i]=1;
	for(int ln=2;ln<=n;ln++)
		for(int i=1,j=ln;j<=n;i++,j++)
			for(int k=1;k<=n;k++){
				p[i][j][k]|=p[i+1][j][k]|p[i][i][k];
				q[i][j][k]|=q[i+1][j][k]|q[i][i][k];
			}
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			for(int k=1;k<=n;k++)
				p[i][j][k]+=p[i][j][k-1];
	for(int ln=2;ln<=n;ln++)
		for(int i=1,j=ln;j<=n;i++,j++){
			for(int k=i;k<j;k++){
				if(p[k+1][j][k]-p[k+1][j][i-1]) continue;
				if(p[i][k][j]-p[i][k][k]) continue;
				dp[i][j]=(dp[i][j]+(ll)f[i][k]*(dp[k+1][j]+f[k+1][j])%md)%md;
			}if(!q[i+1][j][i]) f[i][j]=(f[i+1][j]+dp[i+1][j])%md;
		}
	cout<<(dp[1][n]+f[1][n])%md<<"\n";
}int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--) solve();
	return 0;
} 
```

---

## 作者：冷却心 (赞：3)

你是图论大神，首先拓扑排序一遍给定的限制，如果有环直接输出 $0$。

你是 `bitset` 大神，考虑拓扑排序出一个布尔数组 $F_{i,j}$，表示 $match_j$ 在限制中是否小于 $match_i$。然后再或一下得到一个数组 $s_{l,r,k}$ 表示 $l$ 到 $r$ 中是否存在任意一个满足其 $match$ 值大于 $match_k$，也就是 $F$ 从 $l$ 按位或到 $r$。

你是 dp 大神，定义状态 $f_{l,r}$ 表示第 $l$ 个到第 $r$ 个左括号及其右括号填满的方案数。你发现有两种转移：

- 形如 `(S)`，也就是左端点包住整个区间，仅当 $match_l$ 可以大于 $match_{l+1},match_{l+2},\cdots,match_{r}$，也就是 $s_{l+1,r,l}=0$ 时可以转移，$f_{l,r}\leftarrow f_{l+1,r}$。
- 形如 `ST`，也就是拆分成两个并列的区间，我们设 $k$ 为拆分出来的左区间的右端点，当且仅当没有限制使得右区间的 $match$ 会小于左边，也就是 $s_{l,k}$ 在 $[k+1,r]$ 这一段都为 $0$，可以通过对 $s$ 前缀和简单判断。$f_{l,r}\leftarrow f_{l,k}\times f_{k+1,r}$。

然后你轻松码完代码，发现样例都过不了。第三组数据你输出 $2$，而非 $1$。你发现对于 `()()()`，你在处理 $f_{1,3}$ 时，在 $k=1,2$ 的时候都会做贡献，但是是重复的贡献，然后倒闭。所以你决定修改方程。

为了避免重复贡献，我们考虑钦定左端点包住左区间，也就是：

- 形如 `(S)T`，在上文第二种转移的基础上，我们保证 $l$ 能包住 $[l+1,k]$，也就是 $match_l$ 可以大于 $match_{l+1}$ 到 $match_k$ 的所有，转移：$f_{l,r}\leftarrow f_{l+1,k}\times f_{k+1,r}$。
- 这时候，你睿智地发现，上文第一种转移其实就等于 $k=r$ 的时候转移，于是可以合并两部分的代码。

然后你就通过了。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 310;
const LL MOD = 998244353;
int n, m, in[N]; LL DP[N][N];
vector<int> G[N]; bitset<N> f[N], ff[N][N]; int pre[N][N][N];

LL DFS(int l, int r) {
	if (l >= r) return 1; // 因为 k 可能为 r，导致区间 r+1,r 产生贡献，所以钦定 l>r 也为 1
	if (DP[l][r] != -1) return DP[l][r];
	LL ret = 0, pt = l;
	while (pt < r && !f[pt + 1][l]) ++ pt; // 找到 l 最远能包住的点
	for (int k = l; k <= pt; k ++) if (pre[l][k][r] == pre[l][k][k]) {
		ret = (ret + DFS(l + 1, k) * DFS(k + 1, r)) % MOD;  // 转移
	} return DP[l][r] = ret;
}

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int _; cin >> _;
	while (_ --) {
		cin >> n >> m; 
		for (int i = 1; i <= n; i ++) in[i] = 0, G[i].clear(), f[i].reset();
		for (int i = 1, u, v; i <= m; i ++) {
			cin >> u >> v; in[v] ++; G[u].emplace_back(v);
		} queue<int> q; int cnt = 0;
		for (int i = 1; i <= n; i ++) if (!in[i]) q.push(i);
		while (!q.empty()) {
			++ cnt; int u = q.front(); q.pop();
			for (int v : G[u]) {
				f[v].set(u); f[v] |= f[u]; in[v] --; if (!in[v]) q.push(v);
			}
		} if (cnt < n) { cout << "0\n"; continue; }
		for (int i = 1; i <= n; i ++) {
			ff[i][i] = f[i];
			for (int j = i + 1; j <= n; j ++) ff[i][j] = ff[i][j - 1] | f[j];
		} // 也就是上文的 s 数组。
		for (int i = 1; i <= n; i ++) for (int j = i; j <= n; j ++) {
			for (int k = 1; k <= n; k ++) pre[i][j][k] = pre[i][j][k - 1] + ff[i][j][k];
		} // 前缀和便于判断。
		for (int i = 1; i <= n; i ++) for (int j = 1; j <= n; j ++) DP[i][j] = -1;
		cout << DFS(1, n) << "\n";
	}
	return 0;
}
```

---

## 作者：N0_1 (赞：2)

## 题意

- $match_i$ 第 $i$ 个左括号对应第 $match_i$ 个右括号。
- $match_2 = 2$ 表示第 2 个左括号对应第 2 个右括号。


输入 $m$ 条限制关系 $a_i$ $b_i$，表示 $match_{a_i} < match_{b_i}$。

形式化的表示：第 $a_i$ 个左括号对应的右括号，在第 $b_i$ 个左括号对应的右括号左边。

- $n$ 表示有 $n$ 个左括号。

询问有多少种合法的括号序列。

比如第三组样例：

$3$ 个左括号，$2$ 条信息：

- 第 $1$ 个左括号对应的右括号在第 $2$ 个左括号对应的右括号左边。
- 第 $2$ 个左括号对应的右括号在第 $3$ 个左括号对应的右括号左边。

只有 `()()()` 这一种情况。

考虑 $dp_{i, j}$ 为第 $i$ 个左括号到第 $j$ 个左括号（包括右括号）构成合法序列的方案数。

令 `isok` 表示一个完整的括号序列，则有以下三种情况：

1. ![](https://cdn.luogu.com.cn/upload/image_hosting/hsopewb4.png)

   对于所有的 $i \in [l+1, r]$， $match_l > match_{i}$。

   即不存在 $match_{l} < match_{i}$。
1. ![](https://cdn.luogu.com.cn/upload/image_hosting/miuhsfqp.png)

   对于所有的 $i\in [l+1,r]$，$match_{l} < match_{i}$。

   即不存在 $match_{i} < match_{l}$

1. ![](https://cdn.luogu.com.cn/upload/image_hosting/k8kvoq1v.png)

   对于所有的 $i\in [l+1,k]$，$match_{l} > match_{i}$。

   对于所有的 $j \in [k+1, r]$ 满足 $match_{i} < match_{j}$。

   条件 1：不存在 $match_{l} < match_{i}$。

   条件 2：不存在$match_{j} < match_{i}$。

考虑如何 $O(1)$ 判断转移：

若 $match_{a_i} < match_{b_i}$，则 $s_{a_i,b_i}$ 赋值为 $1$，反之，赋值为 $0$。

以上面第三种情况的条件 2 为例：

对于所有的 $i \in [k+1, r]$， $j\in [l+1, k]$，即 $s_{i,j} = 0$，显然可以通过矩阵前缀和进行判断。

## code
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N = 310;
const LL p = 998244353;
LL dp[N][N];
LL sum[N][N];

LL add(LL x, LL y) {
    x %= p; y %= p;
    return ((x + y) % p + p) % p;
}

LL mul(LL x, LL y) {
    x %= p; y %= p;
    return x * y % p;
}

int calc(int x, int xx, int y, int yy) {
    return sum[xx][yy] - sum[xx][y - 1] - sum[x - 1][yy] + sum[x - 1][y - 1];
}

void solve() {
    memset(dp, 0, sizeof dp);
    memset(sum, 0, sizeof sum);

    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        sum[a][b] = 1;
    }
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= n; j++) 
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + sum[i][j] - sum[i - 1][j - 1];

    for (int i = 1; i <= n; i++) {
        dp[i][i] = 1;
        if (calc(i, i, i, i)) {
            cout << 0 << '\n';
            return ;
        }
    }
    for (int len = 2; len <= n; len ++) {
        for (int l = 1; l <= n - len + 1; l ++) {
            int r = l + len - 1;
            // (  i  s  o   k  )    match[l,l] > match[l+1,r]
            // l l+1        r      不存在 match[l,l] < match[l+1,r]
            if (!calc(l, l, l + 1, r)) dp[l][r] = add(dp[l][r], dp[l + 1][r]);

            //   ( ) i   s o k    match[l,l] < match[l+1,r]
            //   l   l+1     r     不存在 match[l+1, r] < match[l]
            if (!calc(l + 1, r, l, l)) dp[l][r] = add(dp[l][r], dp[l + 1][r]);
            
            //  ( i    s ) o    k        match[l,l] > match[l+1,k] && match[l,k] < match[k+1,r]
            //  l l+1  k   k+1  r 不存在  match[l,l] < match[l+1,k] && match[k+1,r] < match[l, k]
            for (int k = l + 1; k < r; k++) 
                if (!calc(l, l, l + 1, k) && !calc(k + 1, r, l, k)) 
                    dp[l][r] = add(dp[l][r], mul(dp[l + 1][k], dp[k + 1][r]));
        }
    }
    cout << dp[1][n] << '\n';
}

int main() {

    int T;
    cin >> T;
    while (T --) solve();

    // system("pause");
    return 0;
}
```

---


# [Code+#6] 祖玛

## 题目背景

搬运自 [Code+ 第 6 次网络赛](https://gitlink.org.cn/thusaa/codeplus6/)。

------------


小粽还是一个小粽子的时候，特别喜欢玩一款叫作祖玛的游戏。现在，小粽长大了。为了纪念她的童年时光，她开发了一款新型祖玛游戏，并为你准备了一个问题。

## 题目描述

小粽的祖玛游戏的游戏规则可以抽象为如下模型：

初始时，有一段长度为 $n$ 的正整数序列 $a_1,a_2,\dots,a_n$。游戏过程中，小粽会对这个序列进行一系列规则相同的操作：从序列中选取连续且相同的一段数，设这段数的长度为 $X$，如果这些数的值都相等，那么小粽可以把这些数从序列中删除，并将序列从删除的位置接起来，例如，对于序列 `2 3 3 3 1`，可以删除中间的 `3 3 3`，得到 `2 1`。

不过，小粽觉得只是这样太简单了，于是她选择了两个数 $X_{min},X_{max}$，并且要求每次删除的那段数的长度 $X$ 要满足 $X_{min}\le X\le X_{max}$。

显然小粽能进行的操作次数是有限的，甚至她有可能不能把整个序列删除完。现在，小粽想要知道，她每次删除的数的长度的平方和是多少。即，设 $X_i$ 为第 $i$ 次删除的数的长度，最大化 $\sum X_i^2$。

出题固然很爽，但是小粽发现自己现在不会做了。请你帮小粽求出这个最大值吧！

## 说明/提示

### 样例解释

**【样例 1】**

最优策略为，先删除中间的两个 `2 2`，然后删除连续删除两个 `1 1`，最后删除剩下的 `2 2`。注意，由于 $x_{max}$ 的限制，无法删除 `1 1 1`。

**【样例 2】**

见题目目录下的 `2.in` 与 `2.ans`。

### 数据范围

对于所有的输入数据都满足 $1\le n\le 100$，$1\le a_i\le n$，$1\le X_{min}\le X_{max}\le n$。

## 样例 #1

### 输入

```
8
2 1 1 1 2 2 1 2
1 2```

### 输出

```
16```

# 题解

## 作者：szh_AK_all (赞：20)

好玩的区间 dp。

~~竟然是这题题解区的第一篇题解诶。~~

## 分析
根据套路，先设 $f_{l,r}$ 表示删完区间 $[l,r]$ 内的数可获得的最大权值。但是容易发现区间 $[l,r]$ 还可能与 $[1,l-1]$ 中的数有联系，因为可能在删完 $[l,r]$ 的一个前缀 $[l,k]$ 时，$[k+1,r]$ 与 $[1,l-1]$ 可以拼接在一起，即 $a_{l-1}=a_{k+1}$。

于是设 $f_{l,r,x,p}$ 表示删完区间 $[l,r]$ 内的数，且需要或不需要删掉 $a_{l-1}$（$p$ 为 $0$ 或 $1$），如果要删的话则删 $x$ 个的最大权值，接下来转移方程便很好推了。

枚举断点 $k$，则有两种转移：

- 当 $a_k=a_{l-1}$ 且 $p=1$ 时，可以选择先将区间 $[l,k-1]$ 删完，再将区间 $[1,l-1]$ 与区间 $[k,r]$ 拼起来，答案即 $f_{l,k-1,0,0}+f_{k+1,r,x+1,1}$。注意此时区间 $[l,k-1]$ 是与外界隔绝的。

- 当 $X_{min}\le x \le X_{max}$ 或者 $x=0$ 时，考虑将区间 $[l,r]$ 直接从 $k$ 处断开。那么与 $k$ 有联系的区间是 $[k+1,r]$，并且此时会产生 $x^2$ 的权值，答案即为 $f_{l,k-1,0,0}+f_{k+1,r,1,1}+x^2$。

细节：

- 答案应是所有可以转移到的 $f$ 的最大值；

- 个人认为写记忆化搜索更方便点；

- 边界情况需要特判，即 $l>r$ 时，权值为 $x^2$（前提是 $x$ 没有越界）；

- 转移的开始可以有很多种，这里是用 $f_{i,n,1,1}(2\le i\le n)$ 及 $f_{1,n,0,0}$ 作为转移的开始。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[105], f[105][105][105][2], mi, ma, tmp, k;

int dfs(int l, int r, int xuan, int p) {
	if (l > r) {
		if (xuan && (mi > xuan || xuan > ma))
			return -1000000000;
		tmp = max(tmp, xuan * xuan);
		return xuan * xuan;
	}
	if (f[l][r][xuan][p] > k)
		return f[l][r][xuan][p];
	if (xuan > ma)
		return 0;
	int ans = 0;
	for (int k = l; k <= r; k++)
		if (p && a[k] == a[l - 1])
			ans = max(ans, dfs(l, k - 1, 0, 0) + dfs(k + 1, r, xuan + 1, 1));
	for (int k = l; k <= r; k++)
		if ((!xuan || (mi <= xuan && xuan <= ma)))
			ans = max(ans, dfs(l, k - 1, 0, 0) + dfs(k + 1, r, 1, 1) + xuan * xuan);
	tmp = max(tmp, ans);
	return f[l][r][xuan][p] = ans;
}

signed main() {
	memset(f, -0x3f, sizeof(f));
	k = f[0][0][0][0];
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	cin >> mi >> ma;
	for (int i = 1; i <= n; i++)
		dfs(i + 1, n, 1, 1);
	tmp = max(tmp, dfs(1, n, 0, 0));
	cout << tmp;
}
```

---

## 作者：Demeanor_Roy (赞：4)

- [原题链接。](https://www.luogu.com.cn/problem/P11444)

---

套路地，我们考虑求出 $f_{l,r}$ 表示把区间 $[l,r]$ **删完**能得到的最大贡献。之后我们再做一个简单的线性 dp 就能求出操作区间 $[1,n]$（可以不删完）能得到的最大贡献。

在删除区间 $[l,r]$ 的若干次操作中，我们可以认为最后一次删除操作一定包含 $a_l$ 这个元素，因为如果不包含且最后一次删除操作包含的下标最小的元素是 $a_x$，那么区间 $[l,x-1]$ 和 区间 $[x,r]$ 的删除一定是独立的，于是我们可以将区间 $[l,r]$ 的最后一次删除操作调整成区间 $[l,x-1]$ 的最后一次删除操作。一直调整总能使最后一次删除操作一定包含 $a_l$。

假设最后一次删除操作包含的元素为 $a_{p_1=l},a_{p_2},\dots,a_{p_k}$，其中 $k \in [X_{\min},X_{\max}]$。那么我们可以用 $k^2+ \sum\limits_{i=1}^{k-1}f_{p_i+1,p_{i+1}-1}+f_{p_k+1,r}$ 来更新 $f_{l,r}$。一个暴力的想法是对每个 $[l,r]$ 做一遍线性 dp 来实现这个转移，但那样复杂度高达 $O(n^5)$ ，无法接受。

注意到当 $k \ge 2$ 时，我们在转移 $f_{l,r}$ 时选取的任意一个长为 $k$ 的子序列，都可以看作转移 $f_{p_2,r}$ 时选取的一个长度为 $k-1$ 的子序列加上 $a_l$。于是我们更改状态的定义为 $f_{l,r,x}$ 表示将区间 $[l,r]$ 删至只剩 $x$ 个 $a_l$ 的最大贡献，有转移：

- $f_{l,r,x} \gets f_{k,r,x-1}+f_{l+1,k-1,0} (k \in [l+1,r],a_k=a_l,x \ge 1)$。

- $f_{l,r,1} \gets f_{l+1,r,0}$（特殊处理 $k=1$）。

- $f_{l,r,0} \gets f_{l,r,x} + x^2 (x \in [X_{\min},X_{\max}])$。

于是这道题解决完毕，时间复杂度 $O(n^4)$。


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=110,inf=1e9;
int n,L,R,a[N],g[N],f[N][N][N];
inline void chkmax(int &x,int y){x=max(x,y);}
int main()
{
	memset(f,0xcf,sizeof f);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	scanf("%d%d",&L,&R);
	for(int i=1;i<=n+1;i++) f[i][i][0]=(L==1?1:-inf),f[i][i][1]=f[i][i-1][0]=0;
	for(int len=2;len<=n;len++)
		for(int l=1;l+len-1<=n;l++)
		{
			int r=l+len-1;
			f[l][r][1]=f[l+1][r][0];
			for(int k=l+1;k<=r;k++) if(a[k]==a[l])
				for(int x=1;x<=r-l+1;x++) chkmax(f[l][r][x],f[k][r][x-1]+f[l+1][k-1][0]);
			for(int x=L;x<=R;x++) chkmax(f[l][r][0],f[l][r][x]+x*x);
		}
	for(int i=1;i<=n;i++)
	{
		g[i]=g[i-1];
		for(int j=i;j>=1;j--) chkmax(g[i],g[j-1]+f[j][i][0]);
	}
	printf("%d",g[n]);
	return 0;
}
```

---


# 关路灯

## 题目描述

某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。

为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。

现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。

请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。

## 说明/提示

### 样例解释

此时关灯顺序为 `3 4 2 1 5`。

### 数据范围

$1\le n\le50$，$1\le c\le n$，$1\le W_i \le 100$。

## 样例 #1

### 输入

```
5 3
2 10
3 20
5 20
6 30
8 10```

### 输出

```
270  ```

# 题解

## 作者：z2415445508 (赞：382)

这是一道区间型的动态规划题；

我主要是对前方的一些dp题解补充一些小细节。

既然是动规，那么首先讲一下常用的填表法和刷表法：

填表法就是利用状态转移方程和上一个状态来推导出现在的状态（相当于知道已知条件，将答案填入）

刷表法就是利用当前的状态，把有关联的下一状态都推出来。

这道题我选用的是填表法。

理解一下题目大意：

关灯不需要额外的时间，经过了灯就关了。但是可能折返回去关某一个大灯会比继续往下走关接下来的一个小灯更优，

那么可以得到两种状态（沿着当前方向继续往下走，改变方向回去关灯）。

我们需要得到的整个关灯过程中的最优值（最小耗能）

那么要设计的状态转移方程中肯定有两种方案（折返的，不撞墙不回头的）

又因为如果想要关某一区间的灯的过程中耗能最小，所以可以转换成一个个区间来写：

去关某一区间的灯，那么整条街道上除了这一区间的灯会逐渐灭掉其他肯定会全亮。

那么我们把f[i][j]记为当从i到j的灯都熄灭后剩下的灯的总功率。

再进一步：f[i][j][0]表示关掉i到j的灯后，老张站在i端点，f[i][j][1]表示关掉[i][j]的灯后,老张站在右端点

（i为左端点，j为右端点）

又f[i][j][0]会由两种方案推导而来（上面有写。）：折返回来关i,j的灯、由i+1深入，继续关第i盏灯从而扩展到（i,j）；

所以得到状态转移方程：

f[i][j][0] = min ( f[i+1][j][0] + ( a[i+1] - a[i] ) \* ( sum[i] + sum[n] - sum[j] ) , f[i+1][j][1] + ( a[j]-a[i] ) \* ( sum[i]+sum[n]-sum[j]) );

f[i][j][1] = min ( f[i][j-1][0] + ( a[j] - a[i] ) \* ( sum[i-1] + sum[n] - sum[j-1] ) , f[i][j-1][1] + ( a[j]-a[j-1] ) \* ( sum[i-1] + sum[n] - sum[j-1] ) );

（枚举现在的路灯l（2-n,因为第c位的路灯已经被关了），i+l-1<=n（路只有这么长），j=i+l-1（右端点））

因为最后不知道老张到底站在左端点最优还是站在右端点最优

所以在f[1][n][0]和f[1][n][1]中取min输出。

下附代码（含解释）




```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXM=60;
int a[MAXM],b[MAXM],sum[MAXM],n,m,c;
int f[MAXM][MAXM][2];
int min(int a,int b)//这一点希望大家注意：最好max和min函数自己写，会有效的加快程序速度
{return a<b?a:b;}
int max(int a,int b)
{return a>b?a:b;}
int main()
{
  scanf("%d%d",&n,&c);
  memset(f,127,sizeof(f));//赋成极大值防止后面的min出问题
  for(int i=1;i<=n;i++)
    scanf("%d%d",&a[i],&b[i]),sum[i]=sum[i-1]+b[i];
  f[c][c][0]=f[c][c][1]=0;//瞬间被关（初始化）
  for(int l=2;l<=n;l++)
    for(int i=1;i+l-1<=n;i++)
      {
    int j=i+l-1;
    f[i][j][0]=min(f[i+1][j][0]+(a[i+1]-a[i])*(sum[i]+sum[n]-sum[j]),//继续走下去会更快吗？
               f[i+1][j][1]+(a[j]-a[i])*(sum[i]+sum[n]-sum[j]));//还是从j点折返回来会更快？（此时假设[i+1][j]被关，i亮，从j端点往回赶去关i）
//要注意的一点是sum[n]-(sum[j]-sum[i])是包括了i这一点的电能的，因为走过来的过程中灯i也会耗电
    f[i][j][1]=min(f[i][j-1][0]+(a[j]-a[i])*(sum[i-1]+sum[n]-sum[j-1]),//同上
               f[i][j-1][1]+(a[j]-a[j-1])*(sum[i-1]+sum[n]-sum[j-1]));
        }
  int ans=min(f[1][n][0],f[1][n][1]);
  printf("%d",ans);
  return 0;
}
```

---

## 作者：ButterflyDew (赞：196)

分析题目先--“然后可以向左也可以向右去关灯”也就是说，每关完一个灯就有两个选择。

于是我们产生了如下的备选方案

1. dfs+~~玄学~~减枝
2. 贪心
3. dp

一个一个来。
对于方案一，2^n的复杂度显然是不行的，我们需要用一些方法去掉某些明显不成立的分支。

比如说，老张在位置i，他左边的灯比右边的灯功率大还近，是不是一定去关呢？或者我们用数学方法推得i在j前面的条件，又或者我们在线更新答案进行减枝。

对于方案二，可以利用数学方法寻找先后条件，也可以结合方案一减枝。这里不过多赘述。~~（其实是我不会）~~

------------
重点在方案三

n<=50 我们可以考虑比较多的维度的dp

我们思考，朝一个方向走后，我们更新了什么状态呢？

答案是左边待开的灯和右边待开的灯的编号，这是很直观的。

我们考虑$dp[i][j]$代表**区间i，j的灯已经全部关闭**时的**时间点**已经浪费的电量

继续向下思考，我们发现还漏了一个状态，就是当前这个时间点老张是在i点还是j点。

这好办，加一维就行了

则$dp[i][j][k]$代表**区间i，j的灯已经全部关闭**时老王在 $i$ 处$(k==0)$或 $j$ 处$(k==1)$的**时间点**已经浪费的电量

我们尝试写出状态转移方程

	dp[i][j][0]=min(dp[i+1][j][0]+cal(),
				 	dp[i+1][j][1]+cal());
	dp[i][j][1]=min(dp[i][j-1][0]+cal(),
    				dp[i][j-1][1]+cal());
其中，$cal()$**函数计算从上一个区间转移过来时没关的路灯消耗的电力**

------------

这里详细一些的说一下$cal()$函数。

我们要计算某阶段消耗的电力，则需要知道这一段的路程（即时间）和没有关的电灯的功率之和。

想要尽快的计算，我们可以利用**前缀和**$O(1)$找到功率之和。
令$p[i]$为功率的前缀和数组，$loc[i]$存储路灯位置。

```cpp
int cal(int i,int j,int l,int r)
{
    return (loc[j]-loc[i])*(p[l]+p[n]-p[r-1]);
}
```
则$cal()$如上

于是完整的转移方程
```cpp
 dp[i][j][0]=
 min(dp[i+1][j][0]+cal(i,i+1,i,j+1),
 	 dp[i+1][j][1]+cal(i,j,i,j+1));
 dp[i][j][1]=
 min(dp[i][j-1][0]+cal(i,j,i-1,j),
     dp[i][j-1][1]+cal(j-1,j,i-1,j));
```
------------
然而还没完。

转移的顺序和边界的确定也是这个题的一个难点~~（反正我是开始没注意到QAQ）~~

很自然的觉得，这个dp就像扩散那样，从中间直接往两边更新即可

于是我~~们~~写出

```cpp
	dp[c][c+1][1]=cal(c,c+1,c-1,c+1);
    dp[c-1][c][0]=cal(c-1,c,c-1,c+1);
    for(int i=c-1;i>0;i--)
        for(int j=c+1;j<=n;j++)
        {
            dp[i][j][0]=min(dp[i+1][j][0]+cal(i,i+1,i,j+1),dp[i+1][j][1]+cal(i,j,i,j+1));
            dp[i][j][1]=min(dp[i][j-1][0]+cal(i,j,i-1,j),dp[i][j-1][1]+cal(j-1,j,i-1,j));
        }//c为初始地点
```
一交，哎呀30分...好尴尬呀

于是我开始思考~~（其实在看其他人的题解）~~

$dp[i][j][0]$所用的$dp[i+1][j][0]/[1]$有的根本没更新好喵？

好吧，我们仔细看看，对于$dp[i][j][0]$我们要确保$dp[i+1][j][0]/[1]$已经更新，那么，把 $j$ 放在外面循环仍然倒着做 $i$ 不就得了？

再看看$dp[i][j][1]$，正好，只用到了$dp[i][j-1][0]/[1]$, $j$ 又是正着做的。

于是...
```cpp
	dp[c][c][1]=dp[c][c][0]=0;
    for(int j=c;j<=n;j++)
        for(int i=j-1;i>0;i--)
        {
            dp[i][j][0]=min(dp[i+1][j][0]+cal(i,i+1,i,j+1),dp[i+1][j][1]+cal(i,j,i,j+1));
            dp[i][j][1]=min(dp[i][j-1][0]+cal(i,j,i-1,j),dp[i][j-1][1]+cal(j-1,j,i-1,j));
        }
```

------------
**code :**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=55;
int n,c;
int loc[N],p[N];
int dp[N][N][2];

int cal(int i,int j,int l,int r)
{
    return (loc[j]-loc[i])*(p[l]+p[n]-p[r-1]);
}

int main()
{
    cin>>n>>c;
    memset(p,0,sizeof(p));
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        loc[i]=a;
        p[i]=p[i-1]+b;
    }
    dp[c][c][1]=dp[c][c][0]=0;
    for(int j=c;j<=n;j++)
        for(int i=j-1;i>0;i--)
        {
            dp[i][j][0]=min(dp[i+1][j][0]+cal(i,i+1,i,j+1),dp[i+1][j][1]+cal(i,j,i,j+1));
            dp[i][j][1]=min(dp[i][j-1][0]+cal(i,j,i-1,j),dp[i][j-1][1]+cal(j-1,j,i-1,j));
        }
    cout<<min(dp[1][n][0],dp[1][n][1])<<endl;
    return 0;
}

```

---

## 作者：铁锤 (赞：164)

（写给管理员大大：这篇题解的前半部分是我为了方便其他选手的学习，对目前赞数最高的题解中的一些难点作出的解释，后半部分是我写的目前题解中还没有的新做法，求通过qwq）

这道题是一道区间dp。

前面的一些题解已经写的很清晰了，建议先看一下点赞最多的哪一篇，我这里对一些可能难以理解的部分做出一些解释并提供一个新的解法。

首先，请您移步[第一篇题解](https://www.luogu.org/blog/user44468/solution-p1220)，在看完之后，我把它的代码放上。

放代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXM=60;
int a[MAXM],b[MAXM],sum[MAXM],n,m,c;
int f[MAXM][MAXM][2];
int min(int a,int b)//这一点希望大家注意：最好max和min函数自己写，会有效的加快程序速度
{return a<b?a:b;}
int max(int a,int b)
{return a>b?a:b;}
int main()
{
  scanf("%d%d",&n,&c);
  memset(f,127,sizeof(f));//赋成极大值防止后面的min出问题
  for(int i=1;i<=n;i++)
    scanf("%d%d",&a[i],&b[i]),sum[i]=sum[i-1]+b[i];
  f[c][c][0]=f[c][c][1]=0;//瞬间被关（初始化）
  for(int l=2;l<=n;l++)
    for(int i=1;i+l-1<=n;i++)
      {
    int j=i+l-1;
    f[i][j][0]=min(f[i+1][j][0]+(a[i+1]-a[i])*(sum[i]+sum[n]-sum[j]),//继续走下去会更快吗？
               f[i+1][j][1]+(a[j]-a[i])*(sum[i]+sum[n]-sum[j]));//还是从j点折返回来会更快？（此时假设[i+1][j]被关，i亮，从j端点往回赶去关i）
//要注意的一点是sum[n]-(sum[j]-sum[i])是包括了i这一点的电能的，因为走过来的过程中灯i也会耗电
    f[i][j][1]=min(f[i][j-1][0]+(a[j]-a[i])*(sum[i-1]+sum[n]-sum[j-1]),//同上
               f[i][j-1][1]+(a[j]-a[j-1])*(sum[i-1]+sum[n]-sum[j-1]));
        }
  int ans=min(f[1][n][0],f[1][n][1]);
  printf("%d",ans);
  return 0;
}
```
请您看到dp转移方程部分，您可能刚看到它的时候有些疑惑，认为从一个区间的右端点向左端点移动的过程中，会关上这一部分的灯，所以亮着的灯的总功率是变化的。其实不然，我们对f[i][j][1]的定义是：从i到j的灯已经被全部关闭且此时老张站在右端点。所以，从右端点向左端点移动时，路径上的灯是已经关闭了的。
而从左端点向右端点也同理。

那么，在移动过程中，有多少灯是亮着的呢？拿从f[i+1][j][0]向f[i][j][0]转移作为一个例子，此时，区间外，也就是从1～i，j+1～n的灯是亮着的。注意，老张从i+1向i移动时，i这盏灯是亮着的。我们可以预处理出1到每个位置的功率的前缀和，那么，1～i，j+1～n的灯的总功率就是sum[i]+sum[n]-sum[j]。
上图
![](https://cdn.luogu.com.cn/upload/image_hosting/xisns3fm.png)
这一番操作之后，i+1~j的区间是不是都变成0了？
很神奇吧。

那么这个题差不多就讲完了。但是我看到所有题解中就没有人用刷表法的，感到很诧异。上面那段代码用的是填表法，也就是说，f[i][j]是由f[i+1][j]和f[i][j-1]得到的，而刷表法就是用f[i][j]推出f[i-1][j]和f[i][j+1]。所以，我写了一份刷表法的代码，以差不多的效率过了这题。

------------
终于要放上我自己写的代码了，~~有点激动~~
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n,c;
int dis[60];
int p[60];
int dp[60][60][2];
int main() {
	scanf("%d%d",&n,&c);
	int x;
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&dis[i],&x);
		p[i]=p[i-1]+x;
	}
	memset(dp,0x3f,sizeof(dp));
	dp[c][c][0]=dp[c][c][1]=0;
	for(int len=1;len<n;len++) {
		for(int l=1;l<=n-len+1;l++) {
			int r=l+len-1;
			dp[l-1][r][0]=min(dp[l-1][r][0],min(dp[l][r][0]+(dis[l]-dis[l-1])*(p[l-1]+p[n]-p[r]),dp[l][r][1]+(dis[r]-dis[l-1])*(p[l-1]+p[n]-p[r])));
			dp[l][r+1][1]=min(dp[l][r+1][1],min(dp[l][r][1]+(dis[r+1]-dis[r])*(p[l-1]+p[n]-p[r]),dp[l][r][0]+(dis[r+1]-dis[l])*(p[l-1]+p[n]-p[r])));
		}
	}
	printf("%d",min(dp[1][n][0],dp[1][n][1]));
	return 0;
}
```
这道题的话，刷表法确实比填表法难写一些，但是确实是可以过的。
好啦，这篇题解到这里就要结束了，感谢观看，喜欢的话就点个赞吧qwq！

---

## 作者：ww3113306 (赞：57)

并不会用dp做，，于是直接dfs，加个小小的剪枝，妥妥的0ms A了

```cpp
#include<bits/stdc++.h>
using namespace std;
struct abc{
    int p/*功率*/,place/*位置*/;
};
int ans=9999999,may,n,pl,all;abc s[55];bool z[55];//ans要取一个极大值，因为后面要取最小，不然的话就都是0
bool cmp(abc a,abc b)
{
    if(a.place!=b.place) return a.place<b.place;//p代表功率，place代表这个灯的位置
}
void search(int now/*当前位置(在那盏灯下)*/)
{
    bool is=false;int i;
    if(may>ans) return;//小剪枝，如果当前的中间结果（or最终结果）超过ans，就return，这里的话，当时我的ans初始值还是0，所以>=就会进不去这个函数，所以就去掉了=，但后来我把ans的初始值定为了一个极大值，这样应该是可以加=的，并且加等于应该会更优
    i=now;
    while(z[i]&&i<n)i++;//右拐
    if(!z[i])//如果灯是开的
    {
        z[i]=true;
        may+=all*(s[i].place-s[now].place);
        all-=s[i].p;
        search(i);
        all+=s[i].p;
        may-=all*(s[i].place-s[now].place);
        z[i]=false;
        is=true;
        i=now;//注意这里i要重置为now，因为不重置将可能把右拐的结果当做左拐来处理，然后就会出现负数，结果就偏小
    }
    while(z[i]&&i>1)i--;//左拐
    if(!z[i])//如果找到的位置是开着灯的
    {
        z[i]=true;
        may+=all*(s[now].place-s[i].place);
        all-=s[i].p;
        search(i);
        all+=s[i].p;
        may-=all*(s[now].place-s[i].place);    
        z[i]=false;
        is=true;
        i=now;
    }
    if(!is&&ans>may) ans=may;//一旦从当前位置可以左拐或右拐并找到开着的灯，is就会变成true，就代表灯没有关完，就不能改ans的值
}
int main()
{
    int i;bool can=false;
    scanf("%d%d",&n,&pl);
    memset(z,0,55);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&s[i].place,&s[i].p);
        all+=s[i].p;//all代表当前的总功率
        if(i==pl&&!can) pl=s[i].place,all-=s[i].p,z[i]=true,can=true;//因为老张所处的那一盏灯可以视为瞬间关闭，所以减去它的电功率，另外pl改为那盏灯的位置，因为后面要sort一下，防止出错，另外因为改变了pl的值，所以要用一个bool型来记录有没有改过，不然的话可能会二次修改pl的值，因为某一个灯的位置很可能是另一盏灯的序号
    }
    sort(s+1,s+n+1,cmp);//根据灯的位置排序,是为了方便函数里面的计算
    for(i=1;i<=n;i++)//根据之前pl里面存的初始位置来找初始的灯
        if(pl==s[i].place)
        {
            pl=i;
            break;//找到就break
        }
    search(pl);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ElevenX (赞：49)

因为关灯不需要时间，所以老张走过的路灯肯定会被随手关掉。因此，在关完路灯i~j时，老张要么在i处，要么在j处。因此分两种情况：

1、关完后在i处

	老张要么是在关完j路灯后再回头关i路灯的，要么是在关完第i+1盏后继续前进关掉i的，在这两种情况中选择耗能最小的。

2、关完后在i处

	老张要么是在关完i路灯后再回头关j路灯的，要么是在关完第j-1盏后继续前进关掉j的，在这两种情况中选择耗能最小的。
    
因此设dp[i][j][0]表示在关完第i盏灯到第j盏灯后停在i处的最小耗电量，dp[i][j][1]表示在关完第i盏灯到第j盏灯后停在j处的最小耗电量，lamp[i].m为第i盏灯的距离，sum[i][j]表示在关完第i盏灯到第j盏灯后每s所耗电量,可得状态转移方程：

```cpp
dp[i][j][0]=min(dp[i+1][j][0]+(lamp[i+1].m-lamp[i].m)*sum[i+1][j],dp[i+1][j][1]+(lamp[j].m-lamp[i].m)*sum[i+1][j]);
dp[i][j][1]=min(dp[i][j-1][0]+(lamp[j].m-lamp[i].m)*sum[i][j-1],dp[i][j-1][1]+(lamp[j].m-lamp[j-1].m)*sum[i][j-1]);
```
代码：
```cpp
#include<bits/stdc++.h>
#define left 0
#define right 1
#define INF 0x7ffffff
//INF一定不能设成0x7fffffff，否则就会像我在单词划分那道题一样爆int 
using namespace std;
struct node{
	int m;
	int w;
}lamp[105];
int dp[105][105][2],n,c;
int sum[105][105],v[105];
int main(){
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&lamp[i].m,&lamp[i].w);//读入 
	for(int i=1;i<=n;i++)
		v[i]=v[i-1]+lamp[i].w;//前缀和 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dp[i][j][0]=dp[i][j][1]=INF;//初始化dp数组 
	dp[c][c][0]=dp[c][c][1]=0;//因为老张一开始就在c处，所以c盏灯一开始就是关掉的
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			sum[i][j]=v[n]-(v[j]-v[i-1]);//表示在关完第i盏灯到第j盏灯后每s所耗电量 
	for(int i=c;i>0;i--){//此处要从大到小枚举，否则会在决策时用到之前没求过的量，从大到小枚举就可以有效的避免，（具体证明参见我的luogu blog中石子合并的题解），当然也可以在这一层循环枚举有限的长度，本质不变 
		for(int j=i+1;j<=n;j++){
			dp[i][j][left]=min(dp[i+1][j][left]+(lamp[i+1].m-lamp[i].m)*sum[i+1][j],dp[i+1][j][right]+(lamp[j].m-lamp[i].m)*sum[i+1][j]);
			dp[i][j][right]=min(dp[i][j-1][left]+(lamp[j].m-lamp[i].m)*sum[i][j-1],dp[i][j-1][right]+(lamp[j].m-lamp[j-1].m)*sum[i][j-1]);
		//状态转移 
		}
	}
	int ans=min(dp[1][n][0],dp[1][n][1]);//因为到了最后仍有两种情况，所以要判断 
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：jins3599 (赞：33)

蛮好的一道区间dp。

拿到题的第一感觉是贪心，好像是线段覆盖之类的贪心模型？

然后就用贪心的想法思考这道题目，考虑了很久，发现最优决策的路径一定是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/oa23l64i.png)

然后思路就出来了，显然可以用区间dp暴力做，$n$很小，也能承受$O(n^3)$的转移。

设`f[i][j][0/1]`是在区间`[i,j]`的左/右端点时的最小值。

显然这个状态可以从他的下一个极大区间转移过来。

简单的来说，就是:

`f[i][j][1]`可以从`f[i + 1][j][1 / 0]`转移

`f[i][j][0]`可以从`f[i][j - 1][1 / 0]`转移

转移的时候要加上**转移点到当前点的路程 乘 所有在当前转移区间外的路灯的费用和**

显然费用和可以用一个前缀和数组维护，这样这道题就顺利的做完了。

代码比较好写，具体方程可以看代码：

```cpp
#include <bits/stdc++.h>

const int N = 55;

int f[N][N][2] , n , c;
int pos[N] , w[N] , sum[N];

int _min(int a , int b) {
	return a < b ? a : b;
}

int main () {
	scanf("%d %d" , &n , &c);
	for(int i = 1 ; i <= n ; ++ i) scanf("%d %d" , pos + i , w + i) , sum[i] = sum[i - 1] + w[i];
	for(int i = 1 ; i <= n ; ++ i)
		for(int j = 1 ; j <= n ; ++ j) f[i][j][1] = f[i][j][0] = 1000000000; 
	f[c][c][0] = f[c][c][1] = 0;
	for(int len = 2 ; len <= n ; ++ len) {
		for(int i = 1 ; i <= n - len + 1 ; ++ i) {
			int j = i + len - 1;
			f[i][j][1] = _min(f[i + 1][j][1] + (pos[i + 1] - pos[i]) * (sum[n] - sum[j] + sum[i]) , f[i + 1][j][0] + (pos[j] - pos[i]) * (sum[n] - sum[j] + sum[i]));
			f[i][j][0] = _min(f[i][j - 1][0] + (pos[j] - pos[j - 1]) * (sum[i-1] + sum[n] - sum[j-1]) , f[i][j - 1][1] + (pos[j] - pos[i]) * (sum[i-1] + sum[n] - sum[j-1]));
		}
	}
	printf("%d" ,_min(f[1][n][1] , f[1][n][0]));
	return 0;
} 
```

---

## 作者：GCCCCCCCCC (赞：20)

### 暴力出奇迹系列

---

下面这一堆是我第一版的search函数

还美名其曰称它是记忆化搜索

然后事实证明我不但不会记忆化搜索而且就连爆搜都会出各自bug...
```c++
#define now (pos ? l : r)

void search(int l, int r, int pos, int t, int cost){
//已经走过[l,r]区间并且当前在pos(0:l,1:r)位置,过了时间t,已知消耗电费cost
    cost += W[now] * t;//循环到当前层更新
    if(l < 1 || r > n) return;
    if(solve[l][r][pos] <= cost) return;//*
    solve[l][r][pos] = cost;//*
    search(l - 1, r, 0, t + P[now] - P[l - 1], cost);
    search(l, r + 1, 1, t + P[r + 1] - P[now], cost);
}
```
出锅的最主要原因就是这两行
```c++
    "if(solve[l][r][pos] <= cost) return;"
    "solve[l][r][pos] = cost;"
```
当我们先循环到$(cost = 100, t = 100)$时
会错过$(cost = 101, t = 1)$这样很有可能是最优解的状态

为了解决这个问题,我把剪枝改成了下面这样,通过对$cost$最优和$t$最优的双重判定保证了它的正确性
```c++
void search(int l, int r, int pos, int t, int cost){ 
    int now = pos ? r : l;
    cost += W[now] * t;
    if(l < 1 || r > n) return;
    if(cost >= ans) return;
    if(solve[l][r][pos] >= cost && best[l][r][pos] <= t) return;
    if(solve[l][r][pos] < cost || (solve[l][r][pos] == cost && t < best[l][r][pos])) {
        solve[l][r][pos] = cost, best[l][r][pos] = t;
    }
    if(l == 1 && r == n) {
        ans = cost;
        return;
    }
    search(l, r + 1, 1, t + P[r + 1] - P[now], cost);
    search(l - 1, r, 0, t + P[now] - P[l - 1], cost);
}

int main(){
    n = read(), p = read();
    for(int i = 1; i <= n; ++ i) P[i] = read(), W[i] = read();
    memset(solve, 127, sizeof(solve));
    memset(best, 127, sizeof(best));
    search(p, p, 1, 0, 0);
    printf("%d", ans);
    return 0;
}
```
 但是这个剪枝并没有太大用处
 
 仅仅是保证了正确性
 
 该$T$的点还是会$T$掉
 
 ~~疯狂吸氧.jpg~~
  
最终,在题解和$xhc \ dalao$的帮助下,我找到了正确的爆搜方式
```c++    
void search(int i,int v,int sum,int k,int l, int r){
//表示当前在i点,已耗电v,正在工作的点灯总功率为sum,已经关了k盏灯,这些灯在区间[l,r]内
    if(v >= ans) return;//①
    if(k == n) { ans = v; return;}
    if(l > 1) search(l-1, v+(t[i]-t[l-1])*sum, sum-w[l-1], k+1, l-1, r);
    if(r < n) search(r+1, v+(t[r+1]-t[i])*sum, sum-w[r+1], k+1, l, r+1);
    //注意对于v的状态转移
    //相当于是考虑了全局的电量消耗
    //v的增长就会比我之前写的那种版本更快
    //从而使①处的最优性剪枝得到更加充分的利用
    //然后就跑的更快啦
}

int main(){
    n = read(), m = read();
    for(int i = 1; i <= n; ++ i) t[i] = read(), w[i] = read(), all += w[i];//前缀和优化
    search(m, 0, all - w[m], 1, m, m);//m处的灯已经关了
    printf("%d", ans);
    return 0;
}
```
最后跑出来是$31ms$

对于这样一个又好写又好调试的暴力搜索来说,我想这已经足够了

然后我在程序中的传参l与r处理应该会比最优解第一篇的while循环更优

但是偏偏就很慢..

---

---

## 作者：xiejinhao (赞：16)

# P1220 关路灯 题解

Part 1：稍微对某一些评论做下解释
------------


**1. 求前缀和以及查询的一些相关问题**

```cpp
  inline int count(int l, int r, int i, int j) {
      return (sum[l] + sum[n] - sum[r - 1]) * (d[j] - d[i]);
  } 
```

问：这里为什么是 $r-1$ 呢？

答：我们来**模拟一下前缀和**就清楚了：

设$S_5=a_1+a_2+a_3+a_4+a_5$ $S_1=a_1$ $S_2=a_1+a_2$

那么$a_2-a_5$的和$=?$ 不难发现，其值$=S_5-S_1$，这就是为什么是$r-1$的原因了。

**如果从理论上分析**：因为$S_i$包含了从$1$到$i$的前缀和，而$i$到$k(k>=i)$的和是要包括$a_i$的，但是$S_k-S_i$却没有包括$a_i$，所以就是这么写。

**2. 为什么要给f数组赋一个极大值和赋值的一些相关问题**

问1：为什么赋最大值：这个是显而易见的，因为我们的$dp$过程求的是最小值，而这个最小值很明显是大于0的，而**f数组的初值是0**，所以不小心我们就会取到这个0(~~大概是这样吧~~，~~这个问题有点浅显~~)

问2：
```cpp
  memset(f,127,sizeof(f);
```
这句话什么意思？

$f$是$int$类型的数组，能赋$4$种值：$0$、$-1$、极小值、极大值

那这里**127对应的就是极大值**了，当然我用的是**0x3f**


----------------以上是对我看到的问题的解答----------------

------------

Part 2：问题解答完毕，思路还是要讲的
------------
题目很明显，我们**定义**：

1. $f[i][j][0]$表示从$i-j$耗费的最小电力并且当前站在$i$处；
1. $f[i][j][1]$表示从$i-j$耗费的最小电力并且当前站在$j$处；

**目标状态**：$min(f[1][n][0],f[1][n][1])$

这不就很明确了吗？

我们知道起点$c$，那我们由$c$开始向两边走就行了，**向右是正向的，所以向右的状态需要正序搜索**，$f[l][r]$是由上一步$f[l][r-1]$转移来的，转移方程：

```cpp
  k1 = f[l][r - 1][0] + count(l - 1, r, l, r);
  k2 = f[l][r - 1][1] + count(l - 1, r, r - 1, r);
  f[l][r][1] = std::min(k1, k2);
  //k1 k2 只是为了让代码不那么长，count函数上文写了;
```
**向左就是反向，倒序搜索**，$f[l][r]$是由$f[l+1][r]$转移来的，转移方程：

```cpp
  k1 = f[l + 1][r][0] + count(l, r + 1, l, l + 1);
  k2 = f[l + 1][r][1] + count(l, r + 1, l, r);
  f[l][r][0] = std::min(k1, k2);
```
**思路到此为止，到这里就足够AC了。**


------------

part 3：下面是$Show$ $Time$
------------
~~**自从观摩了某篇std后码风大变（源于对Dalao的崇拜）**~~

思路上面讲的很清楚了，下面代码就不再赘述了

```cpp
#include<bits/stdc++.h>

template <class T>
inline void read(T &x) {
	static char c;
	static bool op;
	while(!isdigit(c = getchar()) && c != '-');
	x = (op = c == '-')? 0 : c - '0';
	while(isdigit(c = getchar()))
		x = x * 10 + c - '0';
	if(op) x = ~x + 1;
}

template <class T>
void putint(T x) {
	static char buf[15], *tail = buf;
	if(!x) putchar('0');
	else {
		if(x < 0) putchar('-'), x = ~x + 1;
		for(; x; x /= 10) *++tail = x % 10 + '0';
		for(; tail != buf; --tail) putchar(*tail);
	}
	putchar('\n');
}

const int N = 55;
int n, c, ans;

namespace DP {
	static int d[N],sum[N];
	static int f[N][N][2];
	void in() {
		std::memset(sum, 0, sizeof(sum));
		read(n), read(c); 
		for(int i = 1; i <= n; ++i) {
			read(d[i]), read(sum[i]);
			sum[i] += sum[i - 1];
		}
	}
	inline int count(int l, int r, int i, int j) {
		return (sum[l] + sum[n] - sum[r - 1]) * (d[j] - d[i]);
	} 
	void solve(int &ans) {
		std::memset(f, 0x3f, sizeof(f));   
		f[c][c][0] = f[c][c][1] = 0;
        
		for(int r = c; r <= n; ++r) {
			for(int l = r - 1; l; --l) {
				int k1, k2;
                
				k1 = f[l + 1][r][0] + count(l, r + 1, l, l + 1);
				k2 = f[l + 1][r][1] + count(l, r + 1, l, r);
				f[l][r][0] = std::min(k1, k2);
				
				k1 = f[l][r - 1][0] + count(l - 1, r, l, r);
				k2 = f[l][r - 1][1] + count(l - 1, r, r - 1, r);
				f[l][r][1] = std::min(k1, k2);
			}
		}
		ans = std::min(f[1][n][1], f[1][n][0]);
	}
} 

using DP::in;
using DP::solve;

int main() {
	in();
	solve(ans);
	putint(ans);
	return 0;
}
```

End
------------
~~走过路过**点个赞**呗QAQ~~



---

## 作者：dzz1537568241 (赞：15)

瞅了一眼题解区，貌似都是开三维数组的，\
但我觉的完全没什么必要啊，可读性也没有因此有很大的提高\
所以我想发一个两维的题解（蒟蒻第一次写，神犇勿喷\


刚开始做的时候我就是把整个路面想象成一根数轴来解决\
于是就想到用区间dp\
但问题就是这和区间dp有很大的不一样：\
区间dp总是左边数值<右边数值\
所以当务之急就是把问题转换成我们熟悉的区间dp
~~然后就看到题解区里面的大佬们想到很聪明的做法\
开个三维数组表示在左边和右边，我是蒟蒻，我想不到~~\



这个时候我就想到用\
 _左区间来表示出发的位置，右区间来表示将要前往的位置_\
 这很重要！！！这就是为什么我没有三维只用了两维的原因!!!\
 而且个人觉得按照这个思路非常的好想\
 按照这个思路走下去，我们就可以对问题稍微做一个简化\
 此时我们可以算出从任意左区间到右区间的花费\
 ```cpp
int cost(int i,int j){//i j 分别指从第i号位置到达第j号位置 
	int len=s[i][j];
	int costs=0;
	if(i>j){//此时应该是有第i+1号灯到N号灯以及从1号灯到第j号等没关 
		costs=len*(sum[N]-sum[i]+sum[j]);
		return costs;
	}
	//此时应该有i<j
	//即有第1号灯到第i-1号灯没关以及第j号灯到第N号灯没关 
	costs=len*(sum[N]-sum[j-1]+sum[i-1]);
	return costs;
}
```
这样就可以有效的防止接下来要写的状态转移方程式又臭又长

接下来遇到的问题就是写状态转移方程式\
可以写出伪代码（具体解释在下面\
f[出发的路灯编号][将要到达的路灯编号]=min(\
f[出发的路灯编号][将要到的路灯编号-1]+cost(出发的路灯编号，将要到达的编号-1）\
,f[将要到的路灯编号-1][出发的路灯编号]+cost(将要到达的编号-1，出发的路灯编号）\
仔细思考为什么是这么写\
首先老王（？）经过的路灯一定已经被关掉了，利用这一条性质我们可以发现，如果要到第j号去关灯，其中i~j-1号灯已经被关掉了，那么老王只有两种可能的方案：\
1)刚好处于第j-1号灯\
2）出于第i号灯，掉头回去关第j号灯
具体想法是这样，但是代码敲出来还是相当有难度的


```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#define INF 0x3f3f3f
using namespace std;
int s[51][51];int w[51];
int p[51];
int sum[51];
int a[51][51];
int f[51][51];
int N;int M;
int abs(int a){
	if(a>0)return a;
	return -a;
}
int cost(int i,int j){//i j 分别指从第i号位置到达第j号位置 
	int len=s[i][j];
	int costs=0;
	if(i>j){//此时应该是有第i+1号灯到N号灯以及从1号灯到第j号等没关 
		costs=len*(sum[N]-sum[i]+sum[j]);
		return costs;
	}
	//此时应该有i<j
	//即有第1号灯到第i-1号灯没关以及第j号灯到第N号灯没关 
	costs=len*(sum[N]-sum[j-1]+sum[i-1]);
	return costs;
}
int main(){
	cin>>N;cin>>M;
	memset(sum,0,sizeof(sum));
	memset(s,0,sizeof(s));
	memset(w,0,sizeof(w));
	memset(f,INF,sizeof(f));
	f[M][M]=0;
	for(int i=1;i<=N;i++){
		cin>>p[i];
		for(int j=1;j<=i;j++){
			s[i][j]=abs(p[i]-p[j]);
			s[j][i]=abs(p[i]-p[j]);
		}
		cin>>w[i];
		sum[i]=sum[i-1]+w[i];
	}
	for(int i=1;i<=N-1;i++){//i表示将要关掉的路灯数
		int P_head=M-i;
		int P_tail=M;
		if(M-i<=0){
			P_head=1;
			P_tail=P_head+i;
		} 
		while(P_tail<=N && P_head<=M){//计算从头区间到尾区间去关灯 
			int cost1=cost(P_head,P_tail);//延申一格去关灯，灯的输出功率还是一样的，只不过路程多算了，实际路程只是一点点 
			int cost2=cost(P_head,P_tail)*s[P_tail-1][P_tail]/(s[P_head][P_tail]);
			f[P_head][P_tail]=min(f[P_tail-1][P_head]+cost1,f[P_head][P_tail-1]+cost2);//计算从尾区间到头区间去头区间关灯 
			cost1=cost(P_tail,P_head);
			cost2=cost(P_tail,P_head)*s[P_head+1][P_head]/(s[P_tail][P_head]);
			f[P_tail][P_head]=min(f[P_head+1][P_tail]+cost1,f[P_tail][P_head+1]+cost2);
			P_head++;
			P_tail=P_head+i;//表示要到的位置，此时P_tail的路灯还没有关掉
		}
		
	}
	cout<<min(f[1][N],f[N][1]);
}

```


---

## 作者：Thinking (赞：10)

这题是一个明显的区间型动态规划。

对于一个已关区间（i，j），最后老张一定停在i或者j上，因为在从i到j的过程中，其它所有点一定碰到过了（当然也可以是从j到i，原理同）。

那么就可以写出状态转移方程了（f[i，j，1]表示关了i到j的灯并停在i，f[i，j，2]表示停在j,dist(i,j)表示从i到j的距离,sum(i,j)表示从i到j的灯的功率和）：

f[i，j，1]=min（f[i+1，j，1]+dist（i，i+1）\*sum（i+1，j），f[i+1，j，2]+dist（i，j）\*sum（i+1，j））

f[i，j，2]=min（f[i，j-1，1]+dist（i，j）\*sum（i，j-1），f[i，j-1，2]+dist（j-1，j）\*sum（i，j-1））

然后就很简单了。

```pascal
const
  inf=1000000;  //大点的初始值
var
  a,b,w:array[0..50] of longint;  //w是前缀和数组
  f:array[1..50,1..50,1..2] of longint;  //f数组用途同上
  n,p,i,j,k,t:longint;
function min(a,b:longint):longint;
  begin
    if a<b then exit(a)
    else exit(b)
  end;
begin
  readln(n,p);
  for i:=1 to n do readln(a[i],b[i]);
  w[0]:=0;
  for i:=1 to n do w[i]:=w[i-1]+b[i];  //前缀和
  for i:=1 to n do begin
    f[i,i,1]:=inf;
    f[i,i,2]:=inf
  end;  //设初始值（其实没必要）
  f[p,p,1]:=0;
  f[p,p,2]:=0;  //初始化搞定！
  for i:=2 to n do
    for j:=1 to n-i+1 do begin
      k:=i+j-1;
      t:=w[n]-w[k]+w[j];
      f[j,k,1]:=min(f[j+1,k,1]+(a[j+1]-a[j])*t,f[j+1,k,2]+(a[k]-a[j])*t);
      t:=w[n]-w[k-1]+w[j-1];
      f[j,k,2]:=min(f[j,k-1,1]+(a[k]-a[j])*t,f[j,k-1,2]+(a[k]-a[k-1])*t)
    end;  //状态计算
  write(min(f[1,n,1],f[1,n,2]))  //注意，最后有两种可能！
end.
```

---

## 作者：封禁用户 (赞：5)

# ~~很水的区间dp~~题
这道题目很明显是一道区间DP的题目，关于动态规划，我们最重要的就是要找到当前的状态是怎么样从上一个状态中过来的，OK，关于这道题目我们就来细细的分析。
首先我们可以根据区间dp的惯用套路设出来f[i][j]表示将从i到j的灯都关上时所要耗费掉的电能。
![](https://cdn.luogu.com.cn/upload/image_hosting/cj1u8cpq.png)
~~图画的有点丑，qwqwq~~
### 状态表示加一维
红色箭头所表示的便是老王所在的位置，我们很明显的可以看出老王在关完灯后可能在这个闭区间的左边位置，也可能在这个闭区间的右边，所以我们要在f中加一维，f[i][j][0]表示老王在i处（左边界）,f[i][j][1]表示老王在j处（右边界）

### 四种不同的转移方式
#### 情况1
![](https://cdn.luogu.com.cn/upload/image_hosting/tvuglpqw.png)
蓝色箭头表示老王目前所在的位置，绿色箭头表示老王要到达的位置
所以我们可以得到第一个状态转移方程
```cpp
	f[i][j][1]=min(f[i][j][1],f[i][j-1][1]+(d[j].pos-d[j-1].pos)*(tot-(qzh[j-1]-qzh[i-1])));
```
tot代表所有灯都打开时的功率，

qzh[j-1]-qzh[i-1]代表i到j-1这个闭区间的灯的功率。

这样就能得出老王在移动时有剩余的灯所消耗的电量。


d[j].pos代表绿色箭头的坐标，d[j-1].pos代表蓝色箭头的坐标，相减也就是老王所要移动的距离，又因为老王的速度为1m/s，所以这也就是老王移动所要消耗的时间。剩下的应该也就好理解了吧。
### 情况2
![](https://cdn.luogu.com.cn/upload/image_hosting/31b8uqwu.png)
这次绿色箭头指的是老王当前所在的位置，棕色是老王要到达的位置
```cpp
	f[i][j][0]=min(f[i][j][0],f[i+1][j][1]+(d[j].pos-d[i].pos)*(tot-(qzh[j]-qzh[i])));
```
棕色箭头指的是老王所要到达的位置，
不难看出又一个状态转移方程。
（后面的tot，qzh解释同上）
### 情况3
![](https://cdn.luogu.com.cn/upload/image_hosting/2n048x1e.png)
```cpp
f[i][j][0]=min(f[i][j][0],f[i+1][j][0]+(d[i+1].pos-d[i].pos)*(tot-(qzh[j]-qzh[i])));
```
### 情况4
![](https://cdn.luogu.com.cn/upload/image_hosting/5wz7qp4c.png)

```cpp
	f[i][j][1]=min(f[i][j][1],f[i][j-1][0]+(d[j].pos-d[i].pos)*(tot-(qzh[j-1]-qzh[i-1]))); 
```
我相信各位奆佬就不需要我这个大蒟蒻解释情况3和情况4了。

最后一些细节问题（但也不容忽视）
代码中见
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot;
int qzh[100005];
int f[1005][1005][2];
struct asd{
	int pos,w;
}d[1000005];//结构体：pos代表坐标，w代表耗电功率 
inline int read()//快读板子 
{
   int s=0,w=1;
   char ch;
   ch=getchar();
   while(ch>'9'||ch<'0')
   {
	  if(ch=='-')
	 {
	   w=-1;
	 }
	   ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
	  s=(s<<1)+(s<<3)+(ch^48);
	  ch=getchar();}
	  return s*w;
}
int main()
{
	int n,c;
	n=read();//读入数据（各位应该都懂）（我多嘴） 
	c=read();
	for(int i=1;i<=n;i++)
	{
		d[i].pos=read();
		d[i].w=read();
		qzh[i]=qzh[i-1]+d[i].w;//记录前缀和 
		tot+=d[i].w;//记录总功率 
	}
	memset(f,32,sizeof(f));//注意：把f数组初始值赋值为比较大的数，防止后面min出锅 
	f[c][c][0]=0;//边界条件，老王所在的地方一定是秒关了的 
	f[c][c][1]=0;
	for(int len=1;len<n;len++)
	{
		for(int i=1;i+len<=n;i++)
		{
			int j=i+len;
			f[i][j][0]=min(f[i][j][0],f[i+1][j][0]+(d[i+1].pos-d[i].pos)*(tot-(qzh[j]-qzh[i])));
			f[i][j][1]=min(f[i][j][1],f[i][j-1][1]+(d[j].pos-d[j-1].pos)*(tot-(qzh[j-1]-qzh[i-1]))); 
			f[i][j][0]=min(f[i][j][0],f[i+1][j][1]+(d[j].pos-d[i].pos)*(tot-(qzh[j]-qzh[i])));
			f[i][j][1]=min(f[i][j][1],f[i][j-1][0]+(d[j].pos-d[i].pos)*(tot-(qzh[j-1]-qzh[i-1]))); 
		}
	}
	int ans=min(f[1][n][0],f[1][n][1]);//得到最终结果，因为有两种方式把灯都关上，所以要找一个最小值 
	cout<<ans;
	return 0;

}



```
如有不足之处，恳请各位大佬指出（不能够自私哦/xyx,一定要让大家共同提高）！！！




---

## 作者：Timothy (赞：4)

来个动态规划的题解【呵呵】

【题目大意】

每天早晨他必须关掉他所在村庄的街灯以1m/s的速度行走。关灯不需要花费额外的时间，在耗能总数最少的情况下将所有的灯关掉，求最小的耗能。

【算法讨论】

这道题采用动态规划的思想，用f[i][j][0]表示关了[I,j]这个区间的灯，最后关的是第i盏；f[i][j][1]表示关了[I,j]这个区间的灯，最后关的是第j盏。Mon[i]表示从1到i的灯的费用。未wz[i]表示第i盏灯的位置。动归式如下：

f[i][j][0]=min(f[i+1][j][0]+(mon[n]-(mon[j]-mon[i]))\*(wz[i+1]-wz[i]),f[i+1][j][1]+(mon[n]-(mon[j]-mon[i]))\*(wz[j]-wz[i]));

f[i][j][1]=min(f[i][j-1][0]+(mon[n]-(mon[j-1]-mon[i-1]))\*(wz[j]-wz[i]),f[i][j-1][1]+(mon[n]-(mon[j-1]-mon[i-1]))\*(wz[j]-wz[j-1]));

得分：100

时间复杂度：O(N^2)

空间复杂度：O(N\*N\*2+2\*N)

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int f[1001][1001][2];
int n,wz[1001],mon[1001],v;
int main ()
{
    scanf ("%d%d",&n,&v);
    for (int b=1;b<=n;++b){scanf("%d%d",&wz[b],&mon[b]);mon[b]+=mon[b-1];}
    memset(f,127,sizeof(f));
    f[v][v][0]=f[v][v][1]=0;
    for (int j=v;j<=n;++j)
    {
        for (int i=j-1;i>=1;--i)
        {
            f[i][j][0]=min(f[i+1][j][0]+(mon[n]-(mon[j]-mon[i]))*(wz[i+1]-wz[i]),
                           f[i+1][j][1]+(mon[n]-(mon[j]-mon[i]))*(wz[j]-wz[i]));
            f[i][j][1]=min(f[i][j-1][0]+(mon[n]-(mon[j-1]-mon[i-1]))*(wz[j]-wz[i]),
                           f[i][j-1][1]+(mon[n]-(mon[j-1]-mon[i-1]))*(wz[j]-wz[j-1]));
        }
        
    }
    printf ("%d",min(f[1][n][0],f[1][n][1]));
    return 0;
}

```
速度！！！！！


---

## 作者：MedalPluS (赞：4)

楼下速度弱爆！

此题可以采用爬山法或者模拟退火来解！

可以利用数学知识得出i在j前面的条件

那么我们利用最优性剪枝以及试探性贪心的搜索方式进行搜索！

0ms虐爆数据！！！

【主要内容】

```cpp

        w1=g[left].w*(g[p].loc-g[left].loc)+g[right].w*(g[right].loc-g[left].loc);//贪心 
    w2=g[right].w*(g[p].loc-g[right].loc)+g[left].w*(g[right].loc-g[left].loc);
    if(w1>w2){
        climb(right,W+(tot-g[p].w)*(g[right].loc-g[p].loc),tot-g[p].w);
        climb(left,W+(tot-g[p].w)*(g[p].loc-g[left].loc),tot-g[p].w);
        op[p]=false;
        return;
    }
    else {        
        climb(left,W+(tot-g[p].w)*(g[p].loc-g[left].loc),tot-g[p].w);
        climb(right,W+(tot-g[p].w)*(g[right].loc-g[p].loc),tot-g[p].w);
        op[p]=false;
        return;
    }

```

---

## 作者：上进的z君 (赞：3)

**首先，膜楼下写DP的大神。**

在我们小测时，这道题我想了好久并没有想到什么DP，所以弃疗，写了个贪心，50。然而后来我后悔了，因为这题DFS是能过的，因为每次关灯一定是关旁边还亮着的灯。如果你越过去不关的话，那么我也没话说了。

所以这题DFS是100，而且是0ms。


```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

const int maxn=59;
const int INF=1e9;

int w[maxn],g[maxn],n,c,ans=INF;
bool vis[maxn];

int Abs(int x){
    if(x<0)return -x;
    return x;
}

void Dfs(int x,int sum,int tot,int y){
    if(sum>ans)return;
    if(y>=n){
        ans=sum;
        return;
    }
    
    int l=x,r=x;
    while(!vis[l]&&l>=1)l--;
    while(!vis[r]&&r<=n)r++;
    
    if(l>=1){
        vis[l]=false;
        Dfs(l,sum+tot*Abs(w[x]-w[l]),tot-g[l],y+1);
        vis[l]=true;
    }
    
    if(r<=n){
        vis[r]=false;
        Dfs(r,sum+tot*Abs(w[x]-w[r]),tot-g[r],y+1);
        vis[r]=true;
    }
    
    return;
}

int main()
{
    int tot=0;
    
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&w[i],&g[i]);
        tot+=g[i];
    }
    
    memset(vis,true,sizeof(vis));
    
    vis[c]=false;
    
    Dfs(c,0,tot-g[c],1);
    
    printf("%d\n",ans);
    
    return 0;
}

```

---

## 作者：shadowice1984 (赞：3)

dp三要素，状态定义，转移方程，边界条件！边界条件！边界条件！

不要以为方程出来了就万事大吉，还有边界条件！！！！！！

方程和楼下用的一样

dp[i][j][0]=min(dp[i+1][j][1]+sum(i+1,j)\*(t[j]-t[i]),dp[i+1][j][0]+sum(i+1,j)\*(t[i+1]-t[i]));

dp[i][j][1]=min(dp[i][j-1][1]+sum(i,j-1)\*(t[j]-t[j-1]),dp[i][j-1][0]+sum(i,j-1)\*(t[j]-t[i]));

其中dp[i][j][k]表示i到j区间的灯已灭，k=0老王在左端点，k=1老王在右端点。

sum（i，j）计算i到j的灯灭了以后剩余灯的功耗，t[i]是点i的距离。

然而我们发现，仅仅是dp[st][st][0]=0;dp[st][st][1]=0;

是不够的，这样在计算以st为起点和终点时，会有出发电灯亮着的鬼畜情况。。。

（因为方程鲁棒的把i+1，把j-1）

所以我们还需要专门针对i=st，j=st的转移方程！

```cpp
dp[st-1][j][1]=dp[st-1][j-1][1]+sum(st-1,j-1)*(t[j]-t[j-1]);
dp[st-1][j][0]=dp[st-1][j][1]+sum(st-1,j)*(t[j]-t[st-1]);
dp[i][st-1][0]=dp[i+1][st-1][0]+sum(i+1,st-1)*(t[i+1]-t[i]);
dp[i][st-1][1]=dp[i][st-1][0]+sum(i,st-1)*(t[st-1]-t[i]);
```
上代码~
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
int n;int st;
int t[50];int w[50];
int dp[50][50][2];
int sum(int a,int b)
{
    int res=0;
    if(a>st-1)a=st-1;//粗暴的处理边界转移方程的非法情况，但无法处理普通转移的非法情况
    if(b<st-1)b=st-1;
    for(int i=0;i<n;i++)
    {
        if(i>=a&&i<=b)continue;
        res+=w[i];
    }
    //printf("sum(%d,%d)is%d\n",a,b,res);
    return res;
}
int main()
{
    scanf("%d%d",&n,&st);
    for(int i=0;i<n;i++)
    {
        scanf("%d%d",&t[i],&w[i]);
    }
    if(n==1)
    {
        printf("0");return 0;
    }
    dp[st-1][st-1][0]=0;dp[st-1][st-1][1]=0;//定义原点
    for(int j=st;j<n;j++)//从零开始的数组
    {
        dp[st-1][j][1]=dp[st-1][j-1][1]+sum(st-1,j-1)*(t[j]-t[j-1]);//递推以出发点为起点情况
        dp[st-1][j][0]=dp[st-1][j][1]+sum(st-1,j)*(t[j]-t[st-1]);
    }
    for(int i=st-2;i>=0;i--)
    {
        dp[i][st-1][0]=dp[i+1][st-1][0]+sum(i+1,st-1)*(t[i+1]-t[i]);//递推以出发点为终点情况
        dp[i][st-1][1]=dp[i][st-1][0]+sum(i,st-1)*(t[st-1]-t[i]);
    }
    for(int i=st-2;i>=0;i--)//没啥好说的dp，楼下讲的很详细
    {
        for(int j=st;j<n;j++)
        {
            dp[i][j][0]=
            min(dp[i+1][j][1]+sum(i+1,j)*(t[j]-t[i]),
            dp[i+1][j][0]+sum(i+1,j)*(t[i+1]-t[i]));
            dp[i][j][1]=
            min(dp[i][j-1][1]+sum(i,j-1)*(t[j]-t[j-1]),
            dp[i][j-1][0]+sum(i,j-1)*(t[j]-t[i]));
        }
    }
    /*for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            printf("%-4d",dp[i][j][0]);
        }
        printf("\n");
    }
    printf("\n");
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            printf("%-4d",dp[i][j][1]);
        }
        printf("\n");
    }*/
    int res=min(dp[0][n-1][0],dp[0][n-1][1]);//不知道最后老王在路左还是路右，二者取其min
    printf("%d",res);
    return 0;//拜拜程序~
}

```

---

## 作者：B_K南神 (赞：3)

**这道题可以用暴搜**

\_蒟蒻看了一个小时也没弄明白区间动规，于是发扬NOIP的好作风——骗分过样例，暴力出奇迹！\_

\_一道暴力dfs就诞生了。（下面有注释）\_

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,l,r,t=0,a[55],b[55],d[55],w=0,s=0,minn=0x7fffffff;
void dfs(int x){
    if(s>minn)return;                       //剪枝，如果此时总电量大于已知最低电量，返回
    if(t==n){
        minn=min(minn,s);
        return;
    }                                                 //终止条件
    int i=--l;
    if(i>=1){
        s+=w*max(d[x]-d[i],d[i]-d[x]);
        w-=a[i];
        t++;
        dfs(i);
        t--;
        w+=a[i];
        s-=w*max(d[x]-d[i],d[i]-d[x]);
    }
    l++;                                                            //向左走
    i=++r;
    if(i<=n){
        s+=w*max(d[x]-d[i],d[i]-d[x]);
        w-=a[i];
        t++;
        dfs(i);
        t--;
        w+=a[i];
        s-=w*max(d[x]-d[i],d[i]-d[x]);
    }
    r--;                                                         //向右走
}
void in(){
    scanf("%d%d",&n,&m);
    l=r=m;
    for(int i=1;i<=n;i++){
        int j,k;
        scanf("%d%d",&j,&k);
        w+=k;
        d[i]=j;
        a[i]=k;
    }
    if(a[m]!=0){
        t++;
        w-=a[m];
        a[m]=0;
    }
    return;
}                                                                      //输入+初始化
int main(){
    in();
    dfs(m);
    printf("%d",minn);                                  //输出
    return 0;
} 

```

---

## 作者：元夕 (赞：2)

标签：区间dp。

1. 状态量

设：$f[i][j][0 / 1]$ 是在区间$[i, j]$内老王在左端点$(0)$和右端点$(1)$的情况。

2. 转移方程。

由状态量定义可得，我们进行转移是，一定是从这个区间少一个路灯的区间来进行转移。于是有：

$$f[i][j][0] = min \begin{cases}
	f[i+1][j][0] + dis(i, i + 1) * 
	\sum_{i = 1, i \not \in [i + 1, j]}^{n}
    P[i]
    \\
    f[i+1][j][1] + dis(i, j) * 
	\sum_{i = 1, i \not \in [i + 1, j]}^{n}
    P[i]
    \\
    \end{cases}$$
$$f[i][j][1] = min \begin{cases}
	f[i][j - 1][1] + dis(j - 1, j) * 
	\sum_{i = 1, i \not \in [i, j - 1]}^{n}
    P[i]
    \\
    f[i+1][j][1] + dis(i, j) * 
	\sum_{i = 1, i \not \in [i, j - 1]}^{n}
    P[i]
    \\
    \end{cases}$$
    
3. **特别注意**

(1)当且仅当，$ i <= c \ and \  c <= j$时， 可以转移， 不然就是inf。
至于为什么，自己脑补一下老王行走时的画面(瞬移)

(2)关于我一开始做这道题时没有过来的点。

```cpp
-> f[b][e][0] sum[n] - sum[e] + sum[b]
-> f[b][e][1] sum[n] - sum[e - 1] + sum[b - 1]
```
后来想了一下， 是因为在转移的过程中，i， 或j端同样在耗能。

4. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100 + 5;
int n, c;
int p[maxn], w[maxn], sum[maxn];
int f[maxn][maxn][2]; 
int main(){
	cin >> n >> c;
	for(int i = 1;i <= n;i ++){
		cin >> p[i] >> w[i];
		sum[i] = sum[i - 1] + w[i];
	}
	
	for(int i = 1;i <= n;i ++){
		for(int b = 1, e; (e = b + i - 1) <= n;b ++){
			if(b <= c && e >= c){
				f[b][e][0] = min (
					f[b + 1][e][0] + (p[b + 1] - p[b]) * (sum[n] - sum[e] + sum[b]),
					f[b + 1][e][1] + (p[e] - p[b]) * (sum[n] - sum[e] + sum[b])
				);
				f[b][e][1] = min (
					f[b][e - 1][1] + (p[e] - p[e - 1]) * (sum[n] - sum[e - 1] + sum[b - 1]),
					f[b][e - 1][0] + (p[e] - p[b]) * (sum[n] - sum[e - 1] + sum[b - 1])	
				);
			} else {
				f[b][e][0] = f[b][e][1] = 1e9;
			}
		}
	}
	cout << min(f[1][n][0], f[1][n][1]) << endl;
	return 0;
} 
```

[BLOG观看](https://www.luogu.org/blogAdmin/article/edit/184221)


---

## 作者：JustBlack (赞：2)

#  [题解] P1220 关路灯


[题目链接](https://www.luogu.org/problem/P1220)

算是比较经典的一道 区间 dp 问题了吧。



### 题意

有 n 盏路灯，在一定的位置上（随序号单调递增），每盏路灯有一个功率。某人在一个初始位置（在某盏路灯旁），要用最少的花费使所有灯都关上。



### 思路

看似比较无序，但其实仔细想想，会发现如果没有整个区间取，即两个区间中间有空，那么一定不是最优解！毕竟在回来然后又出去会做许多无用功。

所以最好是整个区间地取，区间 dp 的想法油然而生。

假设 dp\[i]\[j] 是关完 $(i,j)$ 间所有的灯，由于每次都是整个区间的关，那么最后一定是在端点（$i$ 或 $j$）上的。

那再进一步，定义 dp\[i]\[j]\[0] 表示取完后在左端点 ( $i$ ) 所花费的最少代价，dp\[i]\[j]\[1] 表示取完后在右端点 ( $j$ ) 所花费的最小代价。

不难推出 **转移方程**：

```c++
dp[i][j][0]=min(dp[i+1][j][0]+(a[i+1].c-a[i].c)*(a[n].w+a[i].w-a[j].w),
                dp[i+1][j][1]+(a[j].c-a[i].c)*(a[n].w+a[i].w-a[j].w));
dp[i][j][1]=min(dp[i][j-1][0]+(a[j].c-a[i].c)*(a[n].w+a[i-1].w-a[j-1].w),
                dp[i][j-1][1]+(a[j].c-a[j-1].c)*(a[n].w+a[i-1].w-a[j-1].w));
```

 其中：a[i].c 为第 i 盏灯位置，a[i].w 为前 i 个灯的总功率（前缀和处理）。



### 代码

AC Code: 

```c++
//
//  P1220 关路灯.cpp
//  OI
//
//  Created by USER on 2019/10/26.
//  Copyright © 2019年 USER. All rights reserved.
//

#include <bits/stdc++.h>

#define fo(i,x,y) for(int i=(x);i<=(y);i++)
#define dfo(i,x,y) for(int i=(x);i>=(y);i--)
#define cl(f,x) memset(f,x,sizeof(f))
#define lli long long
#define int long long

using namespace std;

const int sz=2333;
const int infm=2147483647;

struct hp {
    int c,w;
}a[sz];

bool cmp(hp a,hp b) {return a.c<b.c;}

void re(int &x) {
    x=0;char ch=getchar();bool t=0;
    while(ch<'0' || ch>'9') t|=(ch=='-'),ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    x=t?-x:x;
}

int cxkmin(int a,int b) {
//    if(a==-1) return b;
    return min(a,b);
}

int n;

inline int ca(int u,int v,int i,int j) {
    return (a[u].c-a[v].c)*(a[n].w-a[j-1].w+a[i-1].w);
}

int cc,dp[sz][sz][2];

signed main() {
    cl(dp,0x7f);
    re(n),re(cc);
    fo(i,1,n) {
        re(a[i].c),re(a[i].w);
    }
//    sort(a+1,a+n+1,cmp);
    fo(i,1,n) a[i].w+=a[i-1].w;
    dp[cc][cc][0]=dp[cc][cc][1]=0;
    fo(len,2,n) {
        fo(i,1,n-len+1) {
			int j=i+len-1;
			dp[i][j][0]=min(dp[i+1][j][0]+(a[i+1].c-a[i].c)*(a[n].w+a[i].w-a[j].w),dp[i+1][j][1]+(a[j].c-a[i].c)*(a[n].w+a[i].w-a[j].w));
			dp[i][j][1]=min(dp[i][j-1][0]+(a[j].c-a[i].c)*(a[n].w+a[i-1].w-a[j-1].w),dp[i][j-1][1]+(a[j].c-a[j-1].c)*(a[n].w+a[i-1].w-a[j-1].w));
        }
    }
    printf("%lld\n",min(dp[1][n][0],dp[1][n][1]));
    return 0;
}

```

AC log: 

---

## 作者：Lwen1243 (赞：2)

入口：[P1220](https://www.luogu.org/problemnew/show/P1220)

首先，我们了解一下区间dp：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

回到原题，对于求解区间(1,n)的最优解，求区间(2,n)或(1，n-1)的最优解**似乎**简单**一点点**~~我认为一点都不简单~~。于是可以这样想老张的位置在k，那么我们要求解的就是区间(1,k)和(k+1,n)的最优解这么想，我们就可以开出dp数组：
```cpp
dp[i][j]
```
表示区间（i,j）的最优解，那在这时，问题就来了：老张在左端和右端的最优解有可能不一样啊。

那不会有什么问题的，我们只要开一个三维的dp数组，第三位为0或1就可以了。当第三位是0时，说明老张的位置在区间的左端，如果第三位是1的话，老张的位置就在区间的右端。

那么数组已经开好了，那状态转移方程呢？

因为对于每一个状态，老张都有两种选择：向左和向右。对于向左和向右两个问题，在右端显然状态转移方程为
```cpp
dp[i][j][0]=min(dp[i+1][j][0]+上个区间消耗的电,dp[i+1][j][1]+上个区间消耗的电);
dp[i][j][1]=min(dp[i][j-1][0]+上个区间消耗的电,dp[i][j-1][1]+上个区间消耗的电);
```

然后我们又要引入另一个概念：前缀和

前缀和：给出一个数组a[666],那么它的前缀和数组的递推式为
```cpp
pre_a[n] = pre_a[n-1] + a[n] ;
```
前缀和的作用：降维，在O（1）的时间里求出a[i],a[i+1],……，a[j]的和。

那这一题为什么要用前缀和呢？

我们在算上一个区间消耗的电的时候因为是一个区间，如果每一次都要重新计算，那电脑岂不是累死？所以我们引入了前缀和进行优化。

剩下一些细节就不必多说了，大体上思路就是这样的。

code:

```cpp
#include<bits/stdc++.h>

#define f(i,a,b) for(int i=a;i<=b;i++)

#define ll long long

using namespace std;

const int MAXN=66;

int n,c;

int s[MAXN],w[MAXN];

int dp[MAXN][MAXN][6];

ll ans;

ll fi(int i , int j , int x , int y )
{

    return ( s[j] - s[i] ) * ( w[x] + w[n] - w[y-1] ) ;

}

int main()
{
    int tmp[2];

    cin >> n >> c;

    memset(dp,666666,sizeof(dp));

    dp[c][c][1]=dp[c][c][0]=0;

    f( i , 1, n )
    {
        cin >> tmp[0] >> tmp[1] ;
        s[i] = tmp[0] ;
        w[i] = w[i-1] + tmp[1] ;
    }

    f( i , c , n )
        for(int j = i - 1 ; j > 0 ; j -- )
        {
            dp[j][i][0] = min(dp[j+1][i][0] + fi(j,j+1,j,i+1) , dp[j+1][i][1] + fi(j,i,j,i+1) ) ;
            dp[j][i][1] = min(dp[j][i-1][0] + fi(j,i,j-1,i) , dp[j][i-1][1] + fi(i-1,i,j-1,i) ) ;
        }

    ans = min(dp[1][n][0],dp[1][n][1]);

    cout << ans << endl ;

    system("pause");

    return 0;
}
```
其他细节自己想一下吧.

---

## 作者：xukuan (赞：2)

毫无疑问，算法是dp之区间dp


首先，在区间(i,j)的灯都被关了之后，老张要么在i，要么在j。

```cpp
证明过程：
反设老张不在i或j
∴i<老张的位置为x<j
又∵i和j均被关闭
∴老张到过i和j
∴老张至少走了回头路(i,x)或(x,j)
这与dp数组的含义矛盾
∴老张在i或j
```

）

因此，我们可以推出两个状态：
```pascal
dp[i][j][1]表示关掉区间(i,j)的灯，老张在i所消耗功率的最小值
dp[i][j][2]表示关掉区间(i,j)的灯，老张在j所消耗功率的最小值
其中i<=p<=j
```

显而易见，二者均可由dp[i][j-1][1/2]和dp[i-1][j][1/2]推来

状态转移方程就有了：
```cpp
ll k=i+j-1,t=w[n]-w[k]+w[j];
dp[j][k][1]=min(dp[j+1][k][1]+(a[j+1]-a[j])*t,dp[j+1][k][2]+(a[k]-a[j])*t);
t=w[n]-w[k-1]+w[j-1];
dp[j][k][2]=min(dp[j][k-1][1]+(a[k]-a[j])*t,dp[j][k-1][2]+(a[k]-a[k-1])*t);
```

代码：
```cpp
#include<bits/stdc++.h>
#define INF 2147483647
typedef long long ll;
using namespace std;

ll n,p,a[100],b[100],w[100],dp[100][100][3];

inline ll read(){
    ll tmp=1,x=0;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
   
    while(isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
    return tmp*x;
}//读入优化

int main(){
	n=read(); p=read();
	for(ll i=1; i<=n; i++){
		a[i]=read();//位置
		b[i]=read();//功率
		w[i]=w[i-1]+b[i];//关于功率的前缀和
	}
	
	for(ll i=1; i<=n; i++){
		dp[i][i][1]=dp[i][i][2]=INF;//赋初值
	}
	dp[p][p][1]=dp[p][p][2]=0;//关掉当前所在位置的灯不用耗费功率
	for(ll i=2; i<=n; i++){
		for(ll j=1; i+j<=n+1; j++){//最左的灯
        	//人在左边
			ll k=i+j-1/*右边的灯*/,t=w[n]-w[k]+w[j];//剩下围观的灯所造成的代价
			dp[j][k][1]/*停在左边*/=min(dp[j+1][k][1]+(a[j+1]-a[j])*t/*上一次停在左*/,dp[j+1][k][2]+(a[k]-a[j])*t/*上一次停在右*/);
            
            //人在右边，下同
			t=w[n]-w[k-1]+w[j-1];
			dp[j][k][2]=min(dp[j][k-1][1]+(a[k]-a[j])*t,dp[j][k-1][2]+(a[k]-a[k-1])*t);
		}
	}
	cout<<min(dp[1][n][1],dp[1][n][2]);//因为关完灯后人可以在左，也可以在右，所以在二者之中去最小值
	return 0;
}
```

---

## 作者：dj114133643 (赞：2)

为了回馈洛谷这个平台，发这个感悟

------------------------------------------------------------------------

本题状态转移并不难，典型的区间型DP，关键是转移的顺序，边界不好确定

先上代码（后面有解释）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int f[55][55][2];
int d[55],sum[55];
int main()
{
    int n,c,i,j,l,w;
    scanf("%d%d",&n,&c);
    memset(f,0x7F,sizeof(f));
    f[c][c][0]=f[c][c][1]=0;
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&d[i],&w);
        sum[i]=sum[i-1]+w;
    }
    for(l=2;l<=n;l++)
        for(i=1;i+l-1<=n;i++)
        {
            j=i+l-1;
            f[i][j][0]=min(f[i+1][j][0]+(d[i+1]-d[i])*(sum[i]+sum[n]-sum[j]),
                                  f[i+1][j][1]+(d[j]-d[i])*(sum[i]+sum[n]-sum[j]));
            f[i][j][1]=min(f[i][j-1][0]+(d[j]-d[i])*(sum[i-1]+sum[n]-sum[j-1]),
                                  f[i][j-1][1]+(d[j]-d[j-1])*(sum[i-1]+sum[n]-sum[j-1]));
        }
    printf("%d\n",min(f[1][n][1],f[1][n][0]));
    return 0;
}
```
我是以区间长度最为第一层进行划分。
假设从C开始，正常情况下最优解应该是从C开始向外扩展的，但这样不太好写。

大家注意到，我的程序输出F[I][I](I!=C)是等于正无穷的，这是不合理的，毕竟这也是可以达到的。

但是，大家想，动态规划的本质是什么？不就是从已经得到的状态中找更优解吗？

数学中有归纳法，信息学也是，当一个状态存在且以最优，

就可从这个状态向外扩展，最终找到的必然是全局最优解。

既如此，部分的不合理是可以的，因为它们必然不会影响到最后。

最终答案必然是从C开始的。

再上一个代码


```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
int f[1001][1001][2];
int n,wz[1001],mon[1001],v;
int main ()
{
    scanf ("%d%d",&n,&v);
    for (int b=1;b<=n;++b){scanf("%d%d",&wz[b],&mon[b]);mon[b]+=mon[b-1];}
    memset(f,127,sizeof(f));
    f[v][v][0]=f[v][v][1]=0;
    for (int j=v;j<=n;++j)
    {
        for (int i=j-1;i>=1;--i)
        {
            f[i][j][0]=min(f[i+1][j][0]+(mon[n]-(mon[j]-mon[i]))*(wz[i+1]-wz[i]),
                           f[i+1][j][1]+(mon[n]-(mon[j]-mon[i]))*(wz[j]-wz[i]));
            f[i][j][1]=min(f[i][j-1][0]+(mon[n]-(mon[j-1]-mon[i-1]))*(wz[j]-wz[i]),
                           f[i][j-1][1]+(mon[n]-(mon[j-1]-mon[i-1]))*(wz[j]-wz[j-1]));
        }
    }
    printf ("%d",min(f[1][n][0],f[1][n][1]));
    //printf("%d %d\n",f[2][4][0],f[3][5][0]);
    return 0;
}
```
是不是觉得本做法递推顺序有些奇怪？
但仔细一推，所有需要状态均已求出。

但还是会有些F[I][J]是错误的，但这不要紧，理由同上。

本题还有一个性质很重要：

当从一个已走的端点走到另一个已走端点，

F[I][J][0]和F[I][J][1]的价值相同，知道一个就可以了————这只是把下次从这段区间可能走的路程提前走了而已




---

## 作者：地表最强男人 (赞：2)

这题我们假设每次只能走到下一个路灯去关，因为中间已经关的路灯是不会消耗电量的，所以只需要关心已经关的路灯的左端点和右端点就行了。每一次可以选择更新左端点以左的路灯或者是左端点以右的电灯，因为每一次关完就留在当前路灯的位置，而当前被更新的路灯只有可能是已经更新路灯的最左端或者是最右端，所以定义$f[0][l][r]$表示已经更新了$l-r$的路灯，然后当前的位置在最左端即$l$处，$f[1][l][r]$表示已经更新了$l-r$的路灯，然后当前的位置在最右端即$r$处，每次可以选择向左走或者向右走更新。最后输出$f[0][1][n]$和$f[1][1][n]$的最小值就可以了。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,f[2][55][55],c,a[55],b[55],ans;//0表示在左边,1表示在右边 
int calc(int l,int r)//计算没关电灯的总功率
{
	int ans1=0,ans2=0;
	for(int i=1;i<=n;i++)
		ans1+=b[i];
	for(int i=l;i<=r;i++)
		ans2+=b[i];
	return ans1-ans2;
}
int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	memset(f,0x3f,sizeof(f));
	f[0][c][c]=0,f[1][c][c]=0;//初始化初始位置为0
	for(int l=0;l<n;l++)//枚举区间的长度
		for(int i=1;i<=n-l;i++)//左端点
		{
			int r=i+l;//右端点
			if(i>1)
			{
				f[0][i-1][r]=min(f[0][i-1][r],f[0][i][r]+(a[i]-a[i-1])*calc(i,r));//向左走
				f[0][i-1][r]=min(f[0][i-1][r],f[1][i][r]+(a[r]-a[i-1])*calc(i,r));
			}
			if(r<n)
			{
				f[1][i][r+1]=min(f[1][i][r+1],f[0][i][r]+(a[r+1]-a[i])*calc(i,r));	//向右走			
				f[1][i][r+1]=min(f[1][i][r+1],f[1][i][r]+(a[r+1]-a[r])*calc(i,r));
			}
		}
	ans=min(f[0][1][n],f[1][1][n]);
	cout<<ans;
	return 0;
}
```


---

## 作者：tsrigo (赞：2)

## [万恶之源](https://www.luogu.org/problem/P1220)
## 前言
本来只是打算记下笔记的，但是发现越写越多，心想要不就顺便改成题解吧，于是有了此文，本文也参考了一些题解，因此本文仅作为其它题解的一些补充，一些做题可能遇到的问题。
## 正题

### 1. 这是一道区间动态规划（最重要的还是要有）

>> 区间dp：区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。

怎么看出来的呢，首先关灯是没有代价的，那么假如我们在最左边，那么只需要一路往右走就一定是最优解，但是如果在中间的话，那么可能一会往左一会往右，假如我们已经知道了某个区间的最优解，那么这个区间向左或向右再拓展一个单位也仍然会是最优的，因此**满足区间dp的特点**。

**每次的选择**也很简单，在一个区间里，要么往右走，要么往左走，并且我们可以很容易发现关完一个区间要么在最左边，要么在右边，否则会带来额外的浪费，所以我们的选择就可以表达成，在一个区间的最左边时，要么继续往左走，要么折返向右走，在最右边时也同理。由此我们可以得到状态转移方程为

```cpp
dp[i][j][0] = min(dp[i+1][j][0]+power(),dp[i+1][j][1]+power());
dp[i][j][1] = min(dp[i][j-1][0]+power(),dp[i][j-1][1]+power());
//其中dp[a][b][0/1]表示关闭区间[a,b]的灯后在左边或在右边 
//power（）表示未关的灯的耗能 
```
## 2.只有状态转移方程还不够 
虽然状态转移方程有了，但是这题并没有那么容易就可以水过去，这里**i和j的枚举方式**也是一个麻烦的点。

首先很显然dp[c][c][0/1]是为0的，那么我们可以考虑**从中间向两边拓展**，但是这里也有**两种方式**

一种是外层枚举i，内层枚举j，即先枚举起点再拓展终点

一种是外层枚举j，内层枚举i。即先枚举终点再拓展起点

详见代码↓↓↓
```cpp
 for(int i=c-1;i>0;i--)
        for(int j=c+1;j<=n;j++)
        {
            dp[i][j][0]=min(dp[i+1][j][0]+power(i,i+1,i,j+1),dp[i+1][j][1]+power(i,j,i,j+1));
            dp[i][j][1]=min(dp[i][j-1][0]+power(i,j,i-1,j),dp[i][j-1][1]+power(j-1,j,i-1,j));
        }//c为初始地点
        
for(int j=c;j<=n;j++){
	for(int i=j-1;i>0;i--){
		dp[i][j][0] = min(dp[i+1][j][0]+power(i,i+1,i,j+1),dp[i+1][j][1]+power(i,j,i,j+1));
		dp[i][j][1] = min(dp[i][j-1][0]+power(i,j,i-1,j),dp[i][j-1][1]+power(j-1,j,i-1,j));
		}
	}
```
他们并不一定都是正解，为此我们可以尝试模拟一下，第一种是先枚举起点再终点，拓展方式是这样的，觉得图~~奇丑无比~~难以接受的话可以直接看下面的结论。
~~高能预警~~
![](https://cdn.luogu.com.cn/upload/image_hosting/9bh0godg.png)

外层循环即圈圈由深蓝到绿再到浅蓝拓展，内层循环即圈圈向右拓展，由状态转移方程可以看出在这种枚举方式下，有一些区间并不能顺利的从子结构递推至父结构（例如深蓝的圈圈都没有不能转移到右子区间），所以这种方法是不行的，（其实我猜想这种枚举方式可以用于刷表法，但是不知道行不行）再看第二种，先枚举终点，再枚举起点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3lhppyzr.png)

枚举方式是蓝，粉，橙，紫，圈圈向左拓展。显然，这种枚举方式在求dp[i][j][0/1]时，其左右的子区间的答案都是已经确定下来了的，所以我们可以轻松得到最优解。

总之，对于$dp[i][j][0]$,我们要确保$dp[i+1][j][0]/[1]$和$dp[i][j-1][0]/[1]$已经更新，于是，我们正序枚举j，正序枚举i。

## 3. power（）函数（计算剩余能耗）
另外一个很麻烦的点时如何计算剩余灯的能耗，直观来讲就是全部灯的能耗减去区间灯的能耗乘以时间即可，我们很容易想到可以用**前缀和**（sumv[x]表示从1号灯到x号灯的能耗总和）来计算，但是这里隐含着一个**边界问题**，首先先上代码
```cpp
int power(int i,int j,int l,int r)
//l,r是左开右开区间（取不到） 
//表示从第i号灯走到第j号灯时，除l到r之外的灯（未关的灯）的耗能 
{
    return (L[j]-L[i])*(sumv[n]-(sumv[r-1]-sumv[l]));
}
//(L[j]-L[i])是路程，数值上等于时间
//sumv[x]是x的前缀和，(sumv[r-1]-sumv[l])是所求区间的能耗和
```
这里为什么是r-1呢，其实改成r也**没问题**，不过就需要你在其它地方也做出相应的更改，这里使用r-1是保证计算时用的区间时开区间，也就是不取它，达到两边的统一，~~有一种对称美~~，看起来舒服一点

最重要的是可以避免一些谜之bug。至于怎么知道它是左开右开的区间可以写个测试前缀和的程序来试一下，分块调试自己的程序可以省去很多干扰。

[附件1：前缀和测试程序](https://www.luogu.org/paste/tr7vya1r)


[附件2：AC代码](https://www.luogu.org/paste/ypaks6it)

---

## 作者：中二病 (赞：2)

dp+记忆化搜索  
首先，感觉是个区间dp  
然后设计状态，用dp[i][j]表示在处理[i,j]区间时总线路消耗的最少的电量  
但发现这样并不能完整的表示一个状态，于是加一个后缀，用[0]表示处理完区间后在左方，用[1]表示处理完区间后在右方  
可知dp[i][j][0]只能由dp[i+1][j]推得，用dp[i+1][j][0/1]+处理i到i+1所消耗的电量  
同理dp[i][j][1]只能由dp[i][j-1]推得  
同时因为有c的存在，dp需要从c开始往两边推，dp顺序很难想，所以干脆写成记忆化了  
最后，当dp有取min操作时，一般都给初始值赋值一个极大值  
```
#include<iostream>
#include<cstdio>
using namespace std;
int n,c,dp[60][60][2],w[60],p[60],sum[60],t;
int solve(int i,int j,int qaq)
{
	if(dp[i][j][qaq]<1e7+7)
	{
		return dp[i][j][qaq];
	}
	if(i<0||i>c||j>n)return 1e7+7;
	if(qaq==0)
	{
		dp[i][j][0]=min(solve(i+1,j,0)+(p[i+1]-p[i])*(sum[n]+sum[i]-sum[j]),solve(i+1,j,1)+(p[j]-p[i])*(sum[n]+sum[i]-sum[j]));
		if(dp[i][j][0]<=0)dp[i][j][1]=1e7+7;
	}
	else 
	{
		dp[i][j][1]=min(solve(i,j-1,1)+(p[j]-p[j-1])*(sum[n]+sum[i-1]-sum[j-1]),solve(i,j-1,0)+(p[j]-p[i])*(sum[n]+sum[i-1]-sum[j-1]));
		if(dp[i][j][1]<=0)dp[i][j][1]=1e7+7;
	}
	return dp[i][j][qaq];
}
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>p[i]>>w[i];
        sum[i]=sum[i-1]+w[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dp[i][j][1]=dp[i][j][0]=1e7+7;
        }
    }
    dp[c][c][1]=dp[c][c][0]=0;
    cout<<min(solve(1,n,0),solve(1,n,1));
    return 0;
}
```


---

## 作者：brealid (赞：2)

对于这道题目，看到第一想法：爆搜。事实上，这一方法确实是可行的。我写这篇题解只是想说明两个我跟别人不一样的地方。

### 1. 初始解
想必很多人的dfs程序里都会有这样一段吧：
```cpp
// ......
int ans = inf;
// ......
int dfs(/* ...... */)
{
	if (当前耗电 >= ans) return;
}
```
又由题目“贪心是错误的”，我们灵机一动：虽然贪心是错误的，但我们可以利用贪心获得一个不错的初始解（``ans``）呀！

~~这样会一定程度上提高程序的运行效率~~ 

假的，才快了 7ms (39ms -> 32ms)

### 2. 记忆化

有的人表示：记忆化不行，会炸。

~~我的脸可能不太黑~~

我的记忆化
```cpp
int record[53][53][53];

void dfs(int p, int tot, int secl, int secr)
{
	// p : 当前老张的位置
    // tot : 当前耗电
    // 1 ~ secl & secr ~ n : 还没有关灯的区间
	if (tot >= ans) return;
	if (tot >= record[secl][secr][p]) return;
	else record[secl][secr][p] = tot;
	if (secl == 0 && secr == n + 1) {
		ans = tot;
		return;
	}
	/*
    	一些继续递归的代码，不放了，大家都懂
        我的程序一个比较耗时的地方是“一次移动一个点”
    */
}
```

---

## 作者：Jμdge (赞：2)

一眼区间dp。


然鹅我是用深搜写的。

因为老了（半AFO），dp 转移不动了。

其实深搜就是想方便打麻烦嘛 ~~像我这样不会想又不会打的老龄OIer 就随意就好了嘛~~

反正就是考虑当前的 $f[l][r][0/1] $ 是 $f[l+1][r][0/1]$ 还是 $f[l][r-1][0/1]$ 转移过来的。 $0$ 表示在 $l$ 上， $1$ 表示在 $r$ 上。

然后记忆化搜着就好了、

结论：记忆化搜索是低智商老龄 OI 选手的最佳选择。

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int inf=1e9+7;
const int M=55;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline void cmax(int& a,int b){if(a<b)a=b;}
inline void cmin(int& a,int b){if(a>b)a=b;}
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,k,ans,a[M],s[M],f[M][M][2];
int dfs(int l,int r,int op){
	if(f[l][r][op]>=0) return f[l][r][op]; f[l][r][op]=inf;
	if(op) cmin(f[l][r][op],dfs(l,r-1,op)+(a[r]-a[r-1])*(s[n]-s[r-1]+s[l-1])),
		cmin(f[l][r][op],dfs(l,r-1,op^1)+(a[r]-a[l])*(s[n]-s[r-1]+s[l-1]));
	else cmin(f[l][r][op],dfs(l+1,r,op^1)+(a[r]-a[l])*(s[n]-s[r]+s[l])),
		cmin(f[l][r][op],dfs(l+1,r,op)+(a[l+1]-a[l])*(s[n]-s[r]+s[l]));
	return f[l][r][op];
}
int main(){ n=read(),k=read();
	for(int i=1;i<=n;++i)
		a[i]=read(),s[i]=s[i-1]+read();
	memset(f,-1,sizeof(f));
	for(int i=1;i<=n;++i)
		f[i][i][0]=f[i][i][1]=inf;
	f[k][k][0]=f[k][k][1]=0;
	ans=dfs(1,n,0),cmin(ans,dfs(1,n,1));
	return !printf("%d\n",ans);
}
```

---

## 作者：SCAU_Lnn (赞：1)

## 题解 P1220 【关路灯 】   

### 简单的剪枝加dfs解法

第一次发题解，主要是本来写的搜索TLE五个点，加了一条剪枝TLE两个点，再改了一下就过了，而且时间超级短。有被吓到，分享一下

搜索思路就是看一下左边有没有没关的，找最近的点，搜索完回来再看看右边有没有没关的点，找最近的点，这样子。

然后我第一次加的判定是if(sum>ans)return ;这个很好理解，就是当前耗电大于答案，剪掉。

第二次是if(sum+（当前已用的时间）*(当前没关的灯的总功率)>ans)return ;本来是剪着玩的，结果直接过了，搜索万岁~\(≧▽≦)/~，我去学dp了~。

show code：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;

int n,m,v[55],ans=0x7fffffff;
struct sty {int x,w;}a[55];

  ///函数变量：当前位置，已经关了的点，当前时间，当前总耗电，当前没关的灯的总功率。
void dfs(int now,int num,int t,int sum,int su)
{
    if(sum+su*t>=ans)return ;     ///这里是剪枝
    if(num==n-1){ans=min(ans,sum);return ;}
    for(int i=1;i<=n;++i){
        if(now+i<=n&&!v[now+i]){
            int t1=fabs(a[now].x-a[now+i].x);
            v[now+i]=1;
            dfs(now+i,num+1,t+t1,sum+a[now+i].w*(t+t1),su-a[now+i].w);
            v[now+i]=0;
            break;
        }
    }
    for(int i=-1;i>=-n;--i)
        if(now+i>=1&&!v[now+i]){
            int t2=fabs(a[now].x-a[now+i].x);
            v[now+i]=1;
            dfs(now+i,num+1,t+t2,sum+a[now+i].w*(t+t2),su-a[now+i].w);
            v[now+i]=0;
            break;
        }
}

int main()
{
    int i,j,k,su=0;
    cin >> n >> m ;
    for(i=1;i<=n;++i){
        scanf("%d%d",&a[i].x,&a[i].w);
        if(i!=m)su+=a[i].w;///统计除了出生点以外的所有点的总功率
    }
    v[m]=1;
    dfs(m,0,0,0,su);
    cout << ans << endl ;
    return 0;
}

///就是这样啦，bye~
```



---

## 作者：lemir3 (赞：1)

[*题面*](https://www.luogu.org/problem/P1220)

## 题目分析

老张关路灯有两种选择,一种是继续关下去,一种是调头关后面的.

显然,老张关的路灯是一个区间,并且老张可能在这个区间的左端点或是右端点.

定义状态$dp_{lrk}$,表示左端点为$l$,右端点为$r$,老张在左端点或是右端点时消耗的最少电能,其中$k$为$0$时表示老张在左端点,为$1$时表示老张在右端点.

再用一个前缀和数组$sum$,方便算出区间之外的灯的功耗.

在$l$,$r$区间之外没关的灯的能效为$sum_n$-($sum_l$-$sum_r$).

老张在左端点时,有两种决策,一种是继续往左关,一种是调头去关右端点.

往左走时,消耗时间为$a_{l+1}$-$a_l$,乘上区间外没关的灯的能效$sum_l$+$sum_n$-$sum_r$.

去关右端点时,消耗时间为$a_r$-$a_l$,没关的灯的能耗同上.

注意这里的$sum_l$其实是$sum_{l+1-1}$,在去关第$l$盏灯时,老张是在$l+1$这个点上的.

在右端点时,同样有两种决策,一种是继续往右关,一种是调头去关左端点.

往右走时,消耗时间为$a_r$-$a_{r-1}$,区间外没关的灯的能效为$sum_{l-1}$+$sum_n$-$sum_{r-1}$.

调头去关左边的灯时,消耗时间为$a_r$-$a_l$,没关的灯的能效同上.

## 代码

```cpp
#include "cstdio"
#include "cstring"
#include "iostream"
#include "algorithm"
#include "cmath"
#include "cstdlib"

#define lxl long long
#define R register
#define debug(x) cout<<"debug:"<<x<<endl
#define INF 2147483647

using namespace std;

lxl n,c;
lxl dp[110][110][2],a[110],w[110],sum[110];

signed main(void)
{
	memset(dp,0x3f,sizeof(dp));
	ios::sync_with_stdio(false);
	cin>>n>>c;
	for(R lxl _=1;_<=n;++_)
	{
		cin>>a[_]>>w[_];
		sum[_]=sum[_-1]+w[_];
	}
	dp[c][c][0]=dp[c][c][1]=0;
	for(R lxl len=2;len<=n;++len)
	{
		for(R lxl l=1;l+len-1<=n;++l)
		{
			lxl r=l+len-1;
			dp[l][r][0]=min(dp[l+1][r][0]+(a[l+1]-a[l])*(sum[l]+sum[n]-sum[r]),dp[l+1][r][1]+(a[r]-a[l])*(sum[l]+sum[n]-sum[r]));
			dp[l][r][1]=min(dp[l][r-1][0]+(a[r]-a[l])*(sum[l-1]+sum[n]-sum[r-1]),dp[l][r-1][1]+(a[r]-a[r-1])*(sum[l-1]+sum[n]-sum[r-1]));		
		}
	}
	cout<<min(dp[1][n][0],dp[1][n][1])<<endl;
return 0;
}
```

---

## 作者：aha浮云 (赞：1)

写一个记搜

~~这就是传说中的xjb记搜~~

~~我也不知道我在写什么....~~

就是你从初始原点开始扩展

然后dfs顺便记录即可....

前方高能,,,.....
```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n = 60;
const int INF = 0x7f7f7f7f;

int sum[max_n], s, n;

struct Light
{
    int p, w;
    bool operator < (const Light &lans000) const
    {
        return p < lans000.p;
    }
}A[max_n];

int F[max_n][max_n][2], S;

int run(int L, int R, bool flag) //搜索扩展并记录答案
{
    if(L == 1 && R == n) return 0;
    if(~F[L][R][flag]) return F[L][R][flag];
    int minn = INF;
    if(!flag)
    {
        if(L != 1 && R != n)
        minn = min(run(L - 1, R, flag) + (S - sum[R] + sum[L - 1]) * (A[L].p - A[L - 1].p), run(L, R + 1, flag ^ 1) + (S - sum[R] + sum[L - 1]) * (A[R + 1].p - A[L].p));
        else if(L == 1 && R != n) minn = min(minn, run(L, R + 1, flag ^ 1) + (S - sum[R] + sum[L - 1]) * (A[R + 1].p - A[L].p));
        else if(L != 1 && R == n) minn = min(minn, run(L - 1, R, flag) + (S - sum[R] + sum[L - 1]) * (A[L].p - A[L - 1].p));
    }
    else 
    {
        if(R != n && L != 1)
        minn = min(run(L - 1, R, flag ^ 1) + (S - sum[R] + sum[L - 1]) * (A[R].p - A[L - 1].p), run(L, R + 1, flag) + (S - sum[R] + sum[L - 1]) * (A[R + 1].p - A[R].p));
        else if(L != 1 && R == n) minn = min(minn, run(L - 1, R, flag ^ 1) + (S - sum[R] + sum[L - 1]) * (A[R].p - A[L - 1].p));
        else if(L == 1 && R != n) minn = min(minn, run(L, R + 1,  flag) + (A[R + 1].p - A[R].p) * (S - sum[R] + sum[L - 1]));
    }
    return F[L][R][flag] = minn;
}
int main()
{
    memset(F, -1, sizeof(F));
    cin >> n >> s;
    for(int i = 1;i <= n; i++)
    scanf("%d%d", &A[i].p, &A[i].w);
    for(int i = 1;i <= n; i++)
    {
        sum[i] = sum[i - 1] + A[i].w;
        S += A[i].w;
    }
    cout << min(run(s, s, 0), run(s, s, 1)) << endl;
    return 0;
}
```
能写dp就别跟我一样来xjb记搜
看着代码都不想调.......

---

## 作者：King__James (赞：1)

看了下面的dalao们的题解，发现都好高深，来一发简单的题解。

这题递归爆搜就可以了，不过要注意递归的变量不要搞错。



```cpp
var
  a,b:array[1..100000]of longint;
  i,j,min,k,v,x,s,n,m:longint;
procedure dfs(i,j,k,v,x:longint);//递归爆搜
begin
  if v>min then
    exit;
  if (i<=1)and(j>=n) then
    begin
      if v<min then
        min:=v;
      exit;
    end;
  if k=0 then
    begin
      if i>1 then dfs(i-1,j,0,v+x*abs(a[i-1]-a[i]),x-b[i-1])//这个if是一定要的，而且要注意变量
      if j<n then dfs(i,j+1,1,v+x*abs(a[i]-a[j+1]),x-b[j+1]);//同上
    end
         else
    begin
      if j<n then dfs(i,j+1,1,v+x*abs(a[j+1]-a[j]),x-b[j+1]);
      if i>1 then dfs(i-1,j,0,v+x*abs(a[j]-a[i-1]),x-b[i-1]);//同上
    end;
end;
begin
  readln(n,m);
  min:=maxlongint;
  for i:=1 to n do
    begin
      read(a[i],b[i]);
      s:=s+b[i];
    end;//输入
  s:=s-b[m];//别忘了减当前的这个位置的电灯
  dfs(m,m,0,0,s);//开始爆搜
  write(min);
end.
希望你们可以理解我的爆搜。
```

---

## 作者：panda_2134 (赞：1)

很类似lrj的紫书《算法竞赛入门经典》上面一个题目（P293）

首先我们发现当前时刻已经关闭的灯在一个连续区间里面最划算。这很显然：如果a和b是不连续的两盏灯，被灯c分开，那么我关了a再去关b的时候完全可以顺带把c关掉，答案只会更好。然后我们发现在关闭了一个连续的区间的灯之后，人一定在端点。

于是就可以dp了，设$f(i,j,k)$为已经关闭了区间$[i,j]$里面的灯时的最小耗电量，k=0表示人在区间左端点，k=1表示人在区间右端点。

于是$f(i,j,0)$就可以从$f(i+1,j,0/1)$转移而来。考虑从i+1或者j走到点i的路程中，还开着的灯的耗电即可。详见代码。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN=50;
int N,C,P[MAXN+10],W[MAXN+10],Sum[MAXN+10],opt[MAXN+10][MAXN+10][3];
int main(){
    scanf("%d%d",&N,&C);
    for(int i=1;i<=N;i++) {
        scanf("%d%d",&P[i],&W[i]);
        Sum[i]=Sum[i-1]+W[i];
    }
    for(int i=1;i<=N;i++)
        opt[i][i][0]=opt[i][i][1]=Sum[N]*abs(P[i]-P[C]);
    for(int len=2;len<=N;len++)
        for(int i=1;i<=N-len+1;i++) {
            int j=i+len-1;
            opt[i][j][0]=min(
                opt[i+1][j][0]+abs(P[i+1]-P[i])*(Sum[i]+Sum[N]-Sum[j]),
                opt[i+1][j][1]+abs(P[j]-P[i])*(Sum[i]+Sum[N]-Sum[j])
            );
            opt[i][j][1]=min(
                opt[i][j-1][0]+abs(P[i]-P[j])*(Sum[i-1]+Sum[N]-Sum[j-1]),
                opt[i][j-1][1]+abs(P[j]-P[j-1])*(Sum[i-1]+Sum[N]-Sum[j-1])
            );
        }
    printf("%d",min(opt[1][N][0],opt[1][N][1]));
    return 0;
}
```

---

## 作者：mengdai (赞：1)

来一发C++的记忆化搜索

首先显而易见，我们从a的点到a+2的点去关灯的过程，显然应该随手关了a+1的路灯，所以我们关的灯应该是连续的

所以，可以用dp[i][j]表示已经关了i点到j点之间的灯，再用0或1表示现在到底在哪一个点，0代表在i点，1表示在j点

此时状态转移方程显而易见，下面附上代码

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,i,ans;
int sum1[55],sum2[55],s[55],p[55];
int jiyi[55][55][2];
int dp(int a,int b,int z){
    int & fanhui=jiyi[a][b][z];
    if(fanhui!=0){
        return fanhui;
    }else{
        if(a==1&&b==n){
            fanhui=0;
        }else{
            if(a==1){
                if(z==0){
                    fanhui=dp(a,b+1,1)+sum2[b+1]*(s[b+1]-s[a]);
                }else{
                    fanhui=dp(a,b+1,1)+sum2[b+1]*(s[b+1]-s[b]);
                }
            }else{
                if(b==n){
                    if(z==0){
                        fanhui=dp(a-1,b,0)+sum1[a-1]*(s[a]-s[a-1]);
                    }else{
                        fanhui=dp(a-1,b,0)+sum1[a-1]*(s[b]-s[a-1]);
                    }
                }else{
                    if(z==0){
                        fanhui=dp(a-1,b,0)+(sum1[a-1]+sum2[b+1])*(s[a]-s[a-1]);
                        fanhui=min(fanhui,dp(a,b+1,1)+(sum1[a-1]+sum2[b+1])*(s[b+1]-s[a]));
                    }else{
                        fanhui=dp(a-1,b,0)+(sum1[a-1]+sum2[b+1])*(s[b]-s[a-1]);
                        fanhui=min(fanhui,dp(a,b+1,1)+(sum1[a-1]+sum2[b+1])*(s[b+1]-s[b]));
                    }
                }
             }
        }
    }
    return fanhui;
}
int main(){
    cin>>n>>m;
    for(i=1;i<=n;i++){
        cin>>s[i];
        cin>>p[i];
    }
    sum1[0]=0;
    sum1[n+1]=0;
    for(i=1;i<=n;i++){
        sum1[i]=sum1[i-1]+p[i];
    }
    for(i=n;i>=1;i--){
        sum2[i]=sum2[i+1]+p[i];
    }
    ans=dp(m,m,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：江海寄余生 (赞：1)

你看都进动规任务里了，就别深搜了，要跟着洛谷的道走。

观察题目我们可以发现：

1、一个正常的关灯顺序必然会产生一个区间的灯全灭，其余地方的灯全亮

2、区间必然会横跨开始点两边（也可能一端与开始点重叠）

3、人必然站在区间的一端

令人在区间左边为0，在右为1

由此可得出最优子结构：若要总消耗功最小，那么当人关完一区间[i,j]里的灯且人在区间给定一端时，所有灯所消耗的功要为关完区间[i,j]的可能耗功的最小值

（与时间关系不大，只要记录功即可，可视为未关灯的时间代价已蕴含在功里）





```cpp
var
  f:array[1..50,1..50,0..1] of longint;
  a,p,money:array[1..50] of longint;
  start,n,m,max,sum,num,i,j,k,x,y,z:longint;
function min(a,b:longint):longint;
begin
  if a<b then min:=a else min:=b;
end;
procedure solve;
begin
  for j:=start+1 to n do
  begin
    f[i,j,0]:=min(f[i+1,j,0]+(a[i+1]-a[i])*(money[n]-(money[j]-money[i])),f[i+1,j,1]+(a[j]-a[i])*(money[n]-(money[j]-money[i])));  //DP方程
    f[i,j,1]:=min(f[i,j-1,1]+(a[j]-a[j-1])*(money[n]-(money[j-1]-money[i-1])),f[i,j-1,0]+(a[j]-a[i])*(money[n]-(money[j-1]-money[i-1])));  //DP方程
  end;
end;
begin
  read(n,start);
  for i:=1 to n do
    read(a[i],p[i]);
  money[1]:=p[1];
  for i:=2 to n do
    money[i]:=money[i-1]+p[i];
  f[start,start,1]:=0;
  f[start,start,0]:=0;
//预处理
  for i:=start-1 downto 1 do
  begin
    f[i,start,0]:=f[i+1,start,0]+(a[i+1]-a[i])*(money[n]-(money[start]-money[i]));
    f[i,start,1]:=f[i+1,start,0]+(a[i+1]-a[i])*(money[n]-(money[start]-money[i]));
    f[i,start,1]:=f[i,start,1]+(a[start]-a[i])*(money[n]-(money[start]-money[i-1]));
  end;
  for i:=start+1 to n do
  begin
    f[start,i,1]:=f[start,i-1,1]+(a[i]-a[i-1])*(money[n]-(money[i-1]-money[start-1]));
    f[start,i,0]:=f[start,i-1,1]+(a[i]-a[i-1])*(money[n]-(money[i-1]-money[start-1]));
    f[start,i,0]:=f[start,i,0]+(a[i]-a[start])*(money[n]-(money[i]-money[start-1]));
  end;
//开始DP
  for i:=start-1 downto 1 do  //枚举区间的左端点
    solve;
  write(min(f[1,n,1],f[1,n,0]));
end.
```

---

## 作者：fy0123 (赞：1)

这道题用深搜就可以 加一点小优化（也可以用DP 不过搜索写起来方便）

每一个点往两个方向走 走过就标记 已经标记的不再重复走 每一步算一下消耗的功就好了

```cpp
var n,c,i,j,p,minw,w:longint;
    a,b:array[0..51]of longint;
    f:array[0..51]of boolean;   //标记数组
procedure dfs(v,k:longint);  //v表示当前所在的点 k表示已经走过了几个点
var i,j:longint;
begin
if w>minw then exit;   //当前数值已经超过最小值就退出 因为肯定不是最优
if k=n then
   begin
    if w<minw then minw:=w;
    exit;
   end;
i:=v-1;
while (i>=1)and(f[i]) do dec(i);
if i>=1 then
   begin
    w:=w+(a[v]-a[i])*p;p:=p-b[i];f[i]:=true;
    dfs(i,k+1);
    p:=p+b[i];w:=w-(a[v]-a[i])*p;f[i]:=false;
   end;                                                       //以上搜索往左边走
i:=v+1;
while (i<=n)and(f[i]) do inc(i);
if i<=n then
   begin
    w:=w+(a[i]-a[v])*p;p:=p-b[i];f[i]:=true;
    dfs(i,k+1);
    p:=p+b[i];w:=w-(a[i]-a[v])*p;f[i]:=false;
   end;                                                       //以上搜往右边走
end;
begin
readln(n,c);
for i:=1 to n do
    begin
      read(a[i],b[i]);
      p:=p+b[i];
    end;
for i:=1 to n-1 do
    for j:=i+1 to n do
        if a[i]>a[j] then
           begin
             a[0]:=a[i];a[i]:=a[j];a[j]:=a[0];
             b[0]:=b[i];b[i]:=b[j];b[j]:=b[0];
           end;  //选排 （我不知道读进来的时候是否按顺序 就排了一下）
f[c]:=true;p:=p-b[c];
minw:=maxlongint;//最小值一开始设为最大
dfs(c,1);//开始时所在点为c 走过一个点
writeln(minw);
end.

```

---

## 作者：Skywalker_David (赞：1)

额。。。。。。记忆化搜索

【附上代码】：

```delphi

var  
  n,c,ans,total:longint;  
  dis,w:array[0..60]of longint;  
  f:array[0..60]of boolean;  
  
procedure dfs(t,tot,total,t1:longint);  
var  
  i:longint;  
begin  
  for i:=t-1 downto 1 do  
    if f[i] then  
      begin  
        if tot+(dis[t]-dis[i])*(total-w[t])<ans then  
          begin  
            f[i]:=false;  
            dfs(i,tot+(dis[t]-dis[i])*(total-w[t]),total-w[t],t1+1);  
            f[i]:=true;  
            break;  
          end;  
      end;  
  for i:=t+1 to n do  
    if f[i] then  
      begin  
        if tot+(dis[i]-dis[t])*(total-w[t])<ans then  
          begin  
            f[i]:=false;  
            dfs(i,tot+(dis[i]-dis[t])*(total-w[t]),total-w[t],t1+1);  
            f[i]:=true;  
            break;  
          end;  
      end;  
  if t1=n then  
    if tot<ans then  
      begin  
        ans:=tot;  
        exit;  
      end;  
end;  
  
procedure main;  
var  
  i:longint;  
begin  
  readln(n,c);  
  total:=0;  
  for i:=1 to n do  
    begin  
      readln(dis[i],w[i]);  
      f[i]:=true;  
      total:=total+w[i];  
    end;  
  ans:=maxlongint;  
  f[c]:=false;  
  dfs(c,0,total,1);  
  writeln(ans);  
end;  

begin  
  main;  
end. 

```

---

## 作者：野菜汤 (赞：1)

题解：

```delphi
var
  a,w,d:array[0..51] of longint;
  i,j,n,sum,min,c:longint;
procedure dg(i,v,sum,k:longint);var x,y:longint;
begin
  if v>min then exit;{一步优化，如果当前的功率已经超过之前纪录的最小功率就直接跳出。}
  if k=n then begin  min:=v; exit; end;{如果如果所有的灯都关完了，那么记录（因之前已有判断最小，所以这里就不用再一次判断）然后跳出}
  x:=i-1;{x记录往左走}
  y:=i+1;{y记录往右走}
  while d[x]=1 do dec(x);{一直走到没有走过的灯（下同）}
  while d[y]=1 do inc(y);
  if x>=1 then begin d[x]:=1;dg(x,v+(a[i]-a[x])*sum,sum-w[x],k+1);d[x]:=0; end;{回溯搜索}
  if y<=n then begin d[y]:=1;dg(y,v+(a[y]-a[i])*sum,sum-w[y],k+1);d[y]:=0;end;{回溯搜索}
end;
begin
  readln(n,m);
  inc(k);
  for i:=1 to n do
  begin
    readln(a[i],w[i]);
    sum:=sum+w[i];  {记录路灯的总功率}
    end;
  d[m]:=1;
  min:=maxlongint;
  dg(m,0,sum-w[m],0);{递归搜索，变量具体意思如上}
  writeln(min);
end.
```

这题的中心思想是不需考虑灯的功率大小问题，直接用回溯搜索模拟每一种方法，因为灯的数量并不是很多（最多只有五十个），所以只要对回溯充满了信任，那么这题就不成问题了。


---

## 作者：YZhe (赞：1)

### 我这辈子都不想再写这样的状态转移方程了
这道题我们考虑区间dp，dp[i][j][0/1]表示在关掉闭区间[i,j]上所有的灯后，所花费的最小代价，0表示在区间左边，1表示在区间右边。

## 转移
状态转移方程很好想，就是太长了。

```cpp

inline int sum( int i , int j , int l , int r ){
	return ( pos[ i ] - pos[ j ] ) * ( qzh[ l - 1 ] + qzh[ n ] - qzh[ r ] );
}//这个函数用于计算，从灯i走到灯j，同时区间[l,r]内所有的灯已经被关闭的情况下，花费的代价。

dp[ i ][ j ][ 0 ] = min( min( dp[ i ][ j - 1 ][ 1 ] + sum( j , j - 1 , i , j - 1 ) + sum( j , i , i , j ) , dp[ i ][ j - 1 ][ 0 ] + sum( j , i , i , j - 1 ) + sum( j , i , i , j ) ) , min( dp[ i + 1 ][ j ][ 0 ] + sum( i + 1 , i , i + 1 , j ) , dp[ i + 1 ][ j ][ 1 ] + sum( j , i , i + 1 , j ) ) );  	  
dp[ i ][ j ][ 1 ] = min( min( dp[ i + 1 ][ j ][ 0 ] + sum( i + 1 , i , i + 1 , j ) + sum( j , i , i , j ) , dp[ i + 1 ][ j ][ 1 ] + sum( j , i , i + 1 , j ) + sum( j , i , i , j ) ) , min( dp[ i ][ j - 1 ][ 1 ] + sum( j , j - 1 , i , j - 1 ) , dp[ i ][ j - 1 ][ 0 ] + sum( j , i , i , j - 1 ) ) );
```

我们考虑dp[i][j][0]如何转移，有四种情况（严格来说的确有4种，但其中两种转移很**劣**，所以我看到很多dalao没有写那两种就过了）。四种情况分别是：

1.从i+1到i关灯

```cpp
dp[ i + 1 ][ j ][ 0 ] + sum( i + 1 , i , i + 1 , j )
```

2.从j到i+1关灯再到i

```cpp
dp[ i + 1 ][ j ][ 1 ] + sum( j , i , i + 1 , j )
```

3.从j-1到j关灯在再折返回i

```cpp
dp[ i ][ j - 1 ][ 1 ] + sum( j , j - 1 , i , j - 1 ) + sum( j , i , i , j )
```

4.从i到j关灯再折返回i

```cpp
dp[ i ][ j - 1 ][ 0 ] + sum( j , i , i , j - 1 ) + sum( j , i , i , j ) )
```

很容易发现，最后两种转移需要**折返**，似乎走了很多冤枉路。但为了保险起见，我还是加上了这两句话。

而dp[i][j][1]的转移类似，就不多提了。

## Besides

怎么枚举区间也很重要，由于我们是从中间某个位置出发，所以枚举的方式与平时有所不同（~~其实我也是参考了dalao的题解的~~）

```cpp
for( ri j = beg ; j <= n ; j++ )
  for( ri i = j - 1 ; i >= 1 ; i-- ){//注意i要比j至少少1,才方便转移
```

i是左端点，j是右端点。

### 完整代码(~~又臭又长~~)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define oo 0x3f3f3f3f
#define ri register int
int n,beg,pos[55],pow[55],qzh[55],dp[55][55][2];
template<class T>
inline void read(T &res){
    static char ch;T flag = 1;
	while( ( ch = getchar() ) < '0' || ch > '9' ) if( ch == '-' ) flag = -1;
	res = ch - 48;
	while( ( ch = getchar() ) >= '0' && ch <= '9' ) res = res * 10 + ch - 48;
	res *= flag;
}
inline int sum( int i , int j , int l , int r ){
	return ( pos[ i ] - pos[ j ] ) * ( qzh[ l - 1 ] + qzh[ n ] - qzh[ r ] );
}
inline int min( int a , int b ){
	return a < b ? a : b;
}
int main()
{
    read( n );read( beg );
    for( ri i = 1 ; i <= n ; i++ ){
    	read( pos[ i ] );read( pow[ i ] );
    	qzh[ i ] = qzh[ i - 1 ] + pow[ i ];
	}
	memset( dp , oo , sizeof( dp ) );
	dp[ beg ][ beg ][ 0 ] = dp[ beg ][ beg ][ 1 ] = 0;
    for( ri j = beg ; j <= n ; j++ )
      for( ri i = j - 1 ; i >= 1 ; i-- ){
      	dp[ i ][ j ][ 0 ] = min( min( dp[ i ][ j - 1 ][ 1 ] + sum( j , j - 1 , i , j - 1 ) + sum( j , i , i , j ) , dp[ i ][ j - 1 ][ 0 ] + sum( j , i , i , j - 1 ) + sum( j , i , i , j ) ) , min( dp[ i + 1 ][ j ][ 0 ] + sum( i + 1 , i , i + 1 , j ) , dp[ i + 1 ][ j ][ 1 ] + sum( j , i , i + 1 , j ) ) );
      	dp[ i ][ j ][ 1 ] = min( min( dp[ i + 1 ][ j ][ 0 ] + sum( i + 1 , i , i + 1 , j ) + sum( j , i , i , j ) , dp[ i + 1 ][ j ][ 1 ] + sum( j , i , i + 1 , j ) + sum( j , i , i , j ) ) , min( dp[ i ][ j - 1 ][ 1 ] + sum( j , j - 1 , i , j - 1 ) , dp[ i ][ j - 1 ][ 0 ] + sum( j , i , i , j - 1 ) ) );
      }
	cout<<min( dp[ 1 ][ n ][ 1 ] , dp[ 1 ][ n ][ 0 ] );
	return 0;
}
```

---

## 作者：lnyzoTwT (赞：1)

这道题似乎和以前做过的另一道题目一模一样，DP

f[i][j][k]表示i~j盏路灯均被点亮，且当前处于k位置是的最少能耗

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
int f[52][52][52];

inline int read(){
	char ch=getchar();int k=0;
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){k=(k<<1)+(k<<3)+ch-'0';ch=getchar();}
	return k;
}

int main(){
	int n,c,qzh[52],w[52];
	qzh[0]=0;
	memset(f,0x3f,sizeof(f));
	n=read();c=read();f[c][c][c]=0;
	for(int i=1;i<=n;i++){
		w[i]=read();qzh[i]=qzh[i-1]+read();
	}
	for(int len=1;len<=(n-1);len++)//主体
	   for(int i=max(1,c-len);i<=c&&(i+len)<=n;i++){
	      f[i][i+len][i]=min(f[i+1][i+len][i+1]+(w[i+1]-w[i])*(qzh[i]+qzh[n]-qzh[i+len]),f[i+1][i+len][i+len]+(w[i+len]-w[i])*(qzh[i]+qzh[n]-qzh[i+len]));
	      f[i][i+len][i+len]=min(f[i][i+len-1][i]+(w[i+len]-w[i])*(qzh[i-1]+qzh[n]-qzh[i+len-1]),f[i][i+len-1][i+len-1]+(w[i+len]-w[i+len-1])*(qzh[i-1]+qzh[n]-qzh[i+len-1]));
   }
   printf("%d\n",min(f[1][n][1],f[1][n][n]));
   return 0;
}
```

---

## 作者：安好 (赞：1)

其实很简单，不要往死里去想，想象现实。

这个人没走s距离，电灯就要消耗s\*w。

那么我们把t[i][j]记为当从i到j的电灯都熄灭后剩下的灯的总功率。

即
ref(i,1,n)ref(j,i,n)t[i][j]=t[i][j-1]+w[j];

int sum=t[1][n];

ref(i,1,n)ref(j,i,n)t[i][j]=sum-t[i][j];

然后进行区间dp。建立一个数组f[1001][1001][2]。f[i][j][0]表示从i到j这一段区间，这个人走到了左边；f[i][j][1]表示走到了右边。

那么在dp时，把前一个状态 加上 走到新状态的路程×剩下台灯的总功率，就是走到新状态电灯所消耗的能量。

得出：


```cpp
ref(l,2,n)ref(i,1,n-l+1)
{
int j=i+l-1;
f[i][j][0]=min(f[i+1][j][0]+t[i+1][j]*(a[i+1]-a[i]),
f[i+1][j][1]+t[i+1][j]*(a[j]-a[i]));
f[i][j][1]=min(f[i][j-1][1]+t[i][j-1]*(a[j]-a[j-1]),
f[i][j-1][0]+t[i][j-1]*(a[j]-a[i]));
}
```
代码：

```cpp
**#include <iostream>**
**#include <cstring>**
**#define ref(i,x,y)for(int i=x;i<=y;i++)**
**using namespace std;**
**long long n,s,a[1001],w[1001];**
**long long t[1001][1001],f[1001][1001][2];**
**int main()**
**{**
**cin>>n>>s;**
**ref(i,1,n)cin>>a[i]>>w[i];**
**ref(i,1,n)ref(j,i,n)t[i][j]=t[i][j-1]+w[j];**
**int sum=t[1][n];**
**ref(i,1,n)ref(j,i,n)t[i][j]=sum-t[i][j];**
**memset(f,1,sizeof f);**
**f[s][s][0]=f[s][s][1]=0;**
**ref(l,2,n)ref(i,1,n-l+1)**
**{**
**int j=i+l-1;**
**f[i][j][0]=min(f[i+1][j][0]+t[i+1][j]*(a[i+1]-a[i]),**
**f[i+1][j][1]+t[i+1][j]*(a[j]-a[i]));**
**f[i][j][1]=min(f[i][j-1][1]+t[i][j-1]*(a[j]-a[j-1]),**
**f[i][j-1][0]+t[i][j-1]*(a[j]-a[i]));**
**}**
**cout<<min(f[1][n][0],f[1][n][1]);**
**}**
```

---

## 作者：谁懂谁伤心 (赞：1)

这题最多只有50盏灯，所以深搜+最优化剪枝妥妥的。

```cpp
int dg(int i,int v,int sum,int k)
{
if (v>h)return 0; 
//如果耗电已经超出其它已完成方案的耗电，回朔
if (k==n){h=v; return 0;}
//如果已经关掉了所有的灯，记录耗电（此时已保证h>v），回朔。
//d[u]=1表示第u盏灯关着；d[u]=0表示第u盏灯开着。
int x=i-1;while (d[x]==1)x--; 
//往左走找到一盏开着的灯。
if (x>0){d[x]=1; dg(x,v+(a[i]-a[x])*sum,sum-w[x],k+1); d[x]=0;}
//如果这盏灯的位置合法(大于0)，就关掉它并递归。
int y=i+1;while (d[y]==1)y++;
//往右走找到一盏开着的灯。
if (y<=n){d[y]=1; dg(y,v+(a[y]-a[i])*sum,sum-w[y],k+1); d[y]=0;}
//如果这盏灯的位置合法(小于n+1)，就关掉它并递归。
return 0;}
int main()
{scanf ("%d%d",&n,&m);for (int i=1;i<=n;i++){scanf ("%d%d",&a[i],&w[i]);sum+=w[i];} 读入灯的数量及老张家的位置，每盏灯的位置和功率，并记录所有灯的总功率，以便接下来的计算。
d[m]=1;h=1000000000;dg(m,0,sum-w[m],1);printf ("%d",h);return 0;}

```

---

## 作者：封禁用户 (赞：0)

这题是个傻逼dp题

本来有点做不来，和神froggy聊了一会儿天后就做得来了，在此感谢神froggy的金光加身，拯救了我那同浆糊一样的大脑


废话少谈，我们讲正解

我们设$dp[l][r][0/1]$表示老王把区间[l,r]都给关了，而此时老王站在左端点/右端点时的最小值


然后我们发现这个东西的转移是显然的，$dp[l][r][0]$可以从$dp[l-1][r][0]$转移过来，也可以从$dp[l][r+1][1]$转移过来

$dp[l][r][1]$的情况也是差不多的

（似乎我是倒推的...感性理解一下？）


然后老王在从一个点跑到另一个点去关灯的时候，除了被老王关掉的灯以外，其他灯都会浪费，这个我们用前缀和维护一下就好了


就可以用一个$O(n^2)$的dp，愉快地把这题阿掉了





------------

顺便讲一下为什么要这样设计状态...


老王是站在一个点，向其他点去关灯的，想象有一排灯都是亮的，然后有人站在一个灯旁边，一直乱跑关灯，而且这个人他跑过的灯全部都关上，那么不论如何，都会有一段灯整齐地暗下...


所以我们能用区间来描述老王关灯的状态，然后就可以了




至于代码


```cpp
void digui(int l,int r,int d){
	if(l==1 && r==n) return;
	if(dp[l][r][d]) return;
	int ans=0x3f3f3f3f;
	if(d==0){
		if(l-1>0) digui(l-1,r,d);
		if(r+1<=n) digui(l,r+1,d^1);
		int k1=dp[l-1][r][d]+(pos[l]-pos[l-1])*(sum[n]-(sum[r]-sum[l-1])),k2=dp[l][r+1][d^1]+(pos[r+1]-pos[l])*(sum[n]-(sum[r]-sum[l-1]));
		if(l-1>0) ans=min(ans,k1);
		if(r+1<=n) ans=min(ans,k2);
		dp[l][r][d]=ans;
		return;
	}
	if(r+1<=n) digui(l,r+1,d);
	if(l-1>0) digui(l-1,r,d^1);
	int k1=dp[l-1][r][d^1]+(pos[r]-pos[l-1])*(sum[n]-(sum[r]-sum[l-1])),k2=dp[l][r+1][d]+(pos[r+1]-pos[r])*(sum[n]-(sum[r]-sum[l-1]));
	if(r+1<=n) ans=min(ans,k2);
	if(l-1>0) ans=min(ans,k1);
	dp[l][r][d]=ans;
	return;
} 
```


记忆化搜索实现一下，不过码风毒瘤，估计大家都看不懂

---

## 作者：一个昵称 (赞：0)

# 又是一个区间DP
看到这道题 第一反应就是dfs和dp 但是稍微算了一下时间复杂度 由于本蒟蒻不会玄学剪枝 果断dp

由于是区间dp 所以还是一样 先设出f(i,j) 用来表示将i到j这个区间内所有灯关闭所耗的电量 但是 由于这道题他需要考虑到方向的问题 所以很明显 单单一个状态f是没办法考虑到所有情况的 于是就可以再开一个状态g(i,j) 这个时候 f就表示将i-j这个区间灯全部关闭并且人停留在左边 g就表示人停留在右边的情况

那么现在设出了状态 该怎么转移呢？

我们可以假设老张每次只会关闭一个路灯 那么(i,j)就可以由(i+1,j)和(i,j-1)推出来 所以状态转移方程就是

f(i,j)=min(f(i,j),min(f(i+1,j)+走过来的耗电，g(i+1,j)+走过来的耗电))

这个仅仅只是通过(i+1,j)转移过来的f 同理可以推出来通过(i,j-1)转移的f，g及通过(i+1,j)转移过来的g

这里需要注意的是 f和g的区别 一个是停在了左边 一个是停在了右边 所以 转移状态时 从两边走过来所消耗的电能不同 并且 若是用(i+1,j)得到(i,j) 即向左关掉一个灯 要记得g状态在走过来关了灯后 还需要走回去 用(i,j-1)得到(i,j)时 同理f要走回去

然后还有就是耗电的计算 我这里是用了一个前缀和数组来优化时间（~~其实不优化也能过？毕竟n=50~~） 然后代码就比较混乱（至少我这么觉得） 总的来说 代码实现起来不难 注意一下细节问题就好了 终点是状态转移方程的推导

下面附上代码

```cpp
#include<iostream>
using namespace std;

struct lj{
	int wz,gl;
}a[51];

int dqgl=0;

int f[51][51];
int g[51][51];
int pre[51]={0};

int getz(int y,int z){
	return (dqgl-pre[z]+pre[y]);
}//向左走

int gety(int y,int z){
	return (dqgl-pre[z-1]+pre[y-1]);
}//向右走

int getzy(int y,int z){
	return (dqgl-pre[z]+pre[y-1]);
}//走回头路

int jl(int x,int y){
	return a[y].wz-a[x].wz;
}

int main(){
	int n,c;
	cin>>n>>c;
	for(int i=1;i<=n;i++){
		cin>>a[i].wz>>a[i].gl;
		dqgl+=a[i].gl;
		pre[i]=pre[i-1]+a[i].gl;
	}
	f[c-1][c]=getz(c-1,c)*jl(c-1,c);
	f[c][c+1]=gety(c,c+1)*jl(c,c+1)+getzy(c,c+1)*jl(c,c+1);
	g[c-1][c]= getz(c-1,c)*jl(c-1,c)+getzy(c-1,c)*jl(c-1,c); 
	g[c][c+1]=gety(c,c+1)*jl(c,c+1);
    	//赋初值 将老张位置左右两边先预处理一下
	for(int len=1;len<n;len++){
		for(int i=1;i+len<=n;i++){
			int j=i+len;
			if(f[i+1][j]!=0){
				if(f[i][j]==0)	f[i][j]=min(f[i+1][j]+getz(i,j)*jl(i,i+1),g[i+1][j]+getz(i,j)*jl(i,j));
				else 	f[i][j]=min(f[i][j],min(f[i+1][j]+getz(i,j)*jl(i,i+1),g[i+1][j]+getz(i,j)*jl(i,j)));
				if(g[i][j]==0) g[i][j]=min(g[i+1][j]+gety(i,j)*jl(i,j)+getzy(i,j)*jl(i,j),f[i+1][j]+getz(i,j)*jl(i,i+1)+getzy(i,j)*jl(i,j));
				else	g[i][j]=min(g[i][j],min(g[i+1][j]+gety(i,j)*jl(i,j)+getzy(i,j)*jl(i,j),f[i+1][j]+getz(i,j)*jl(i,i+1)+getzy(i,j)*jl(i,j)));
			}//这里需要一些特判 因为数组初值是0嘛 不特判就会误给数组赋值 下同
			if(g[i][j-1]!=0){
				if(f[i][j]==0) f[i][j]=min(g[i][j-1]+gety(i,j)*jl(j-1,j)+getzy(i,j)*jl(i,j),f[i][j-1]+gety(i,j)*jl(i,j)+getzy(i,j)*jl(i,j));
				else 	f[i][j]=min(f[i][j],min(g[i][j-1]+gety(i,j)*jl(j-1,j)+getzy(i,j)*jl(i,j),f[i][j-1]+gety(i,j)*jl(i,j)+getzy(i,j)*jl(i,j)));	
				if(g[i][j]==0) g[i][j]=min(g[i][j-1]+gety(i,j)*jl(j-1,j),f[i][j-1]+gety(i,j)*jl(i,j));
				else	g[i][j]=min(g[i][j],min(g[i][j-1]+gety(i,j)*jl(j-1,j),f[i][j-1]+gety(i,j)*jl(i,j)));
			}
		}
	}
	int ans=min(f[1][n],g[1][n]);
	cout<<ans;
	return 0;
}
```


---

## 作者：lightup37 (赞：0)

区间DP, 考虑设$dp[i][j][t]$为已经关掉了$[i,j]$的电灯, 人在t端点处时的最小代价

可以推出方程: 

$$ dp[i+1][j][0]+(p[n]-p[j]+p[i])*(loc[i+1]-loc[i]) -> dp[i][j][0] $$
$$ dp[i][j-1][0]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[i]) -> dp[i][j][1] $$
$$ dp[i][j-1][1]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[j-1]) -> dp[i][j][1] $$
$$ dp[i+1][j][1]+(p[n]-p[j]+p[i])*(loc[j]-loc[i]) -> dp[i][j][0] $$

直接DP... 且慢, 顺序是什么...... 好像很麻烦的样子......

但是其实可以不用考虑顺序问题的, 一位超强的选手$wyx$说过: 

$\text{「记忆化搜索, 就是用来解决这种顺序有关的DP的」}$

如果采用记忆化搜索, 啥都不用想一顿码, 码完AC, 极其快乐, 比那些DP不知道高到哪里去了

code:
```cpp
#include<bits/stdc++.h>
using namespace std; /*Copyright [tyqtyq](http://oiertyq.github.io). All rights served.*/
#define f(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
#define d(i,x,y) for(int i=x,i##end=y;i>=i##end;--i)
#define ri register int
#define ll long long
#define il inline
namespace intio{char ch; int read(){ ri x=0,f=1; while(!isdigit((ch=getchar()))) f=ch=='-'?-1:1; while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); return x*f; } void read(int& x) {x = read();}}; using namespace intio;
int max(int x, int y) {return x>y?x:y;} int min(int x, int y) {return x<y?x:y;}
#define _ 100
int loc[_], p[_];
int dp[_][_][2] ;
int n, c;
// dp[i][j][t]: 已经关掉了[i,j]的电灯, 人在t端点处 
// dp[i+1][j][0]+(p[n]-p[j]+p[i])*(loc[i+1]-loc[i]) -> dp[i][j][0]
// dp[i][j-1][0]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[i]) -> dp[i][j][1]
// dp[i][j-1][1]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[j-1]) -> dp[i][j][1]
// dp[i+1][j][1]+(p[n]-p[j]+p[i])*(loc[j]-loc[i]) -> dp[i][j][0]
void work(int i,int j){
	if(i>j) return ;
	if(dp[i+1][j][0]==0x3f3f3f3f) work(i+1, j);
	if(dp[i][j-1][0]==0x3f3f3f3f) work(i, j-1);
	dp[i][j][0] = min(dp[i+1][j][0]+(p[n]-p[j]+p[i])*(loc[i+1]-loc[i]), dp[i+1][j][1]+(p[n]-p[j]+p[i])*(loc[j]-loc[i]));
	dp[i][j][1] = min(dp[i][j-1][0]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[i]), dp[i][j-1][1]+(p[n]-p[j-1]+p[i-1])*(loc[j]-loc[j-1]));
}
int main(){
	memset(dp, 0x3f, sizeof(dp)) ;
	scanf("%d%d",&n,&c) ;
	f(i,1,n) scanf("%d%d", &loc[i], &p[i]), p[i] += p[i-1] ;
	dp[c][c][1] = dp[c][c][0] = 0 ;
	work(1,n);
	cout<<min(dp[1][n][1], dp[1][n][0]) ;
	return 0;
}

```

---

## 作者：Boxxxxxx (赞：0)

这道题是个dp的题目，首先我们就要考虑，老张去关路灯，存不存在一种情况就是我人在3的位置，我去走到5关灯，在走到4去关4的灯。这是不可能存在的是不是，**也就是说关灯只会是从已经关好灯的区间去延伸一个单位**，假设我们目前在3 的位置，那么我们接下来关的下一盏灯就是2或者是4.换一种表达就是，当前已经关好灯的区间是[3,3],那么我们下一步关完灯后就只可能是[2,3]或者是[3,4]，就是所在区间的左端点去-1，或者右端点去+1;如果我们设计状态是 f[i][j] 表示关完[i,j]这个区间的灯所花费的最少价值的话，那么从起点处去转移状态，答案应该就是f[1][n];
怎么转呢？
就是当前我是在[i,j]这个区间内，然后所在位置是node，我们所在这个区间所能延伸的区间也是固定的，就只是[i-1, j]和[i,j-1]；
那么
```cpp
int t = abs(street_light[L - 1].node - node);
f[L - 1][R] = min(f[L - 1][R], 
                  f[L][R] + t * sum[L - 1] + t * (sum[n] - sum[R]));
```
t就是从node这个位置走到L-1这个灯位置的时间，然后sum数组是一个所有路灯功率的前缀和，其实我们就是要算现在剩下还亮着的路灯经过这t秒后消耗了多少功率。
这是L-1,R+1的转移的基本一样的。
```cpp
f[L][R + 1] = min(f[L][R + 1], 
                  f[L][R]  + t * sum[L - 1] + t * (sum[n] - sum[R]));
```
如果这么去做，结果只有90分，wa最后一个点~~（数据太水了）~~ 。为什么只有90?因为我们这么去转移是会有一个问题，我们仅仅是表示了[i,j]区间的答案，但是我ij区间去往下一个区间转移的时候，有两种可能，一种是我在ij区间的i位置，一种是在ij区间的j位置。然后这两种位置对于下一个区间的贡献是不一样的，我们没有去分别讨论这两种情况,即使你是同样的[i,j]区间，从不同的地方到达ij他的贡献也不一样。所以就是在加一维度，去表示我现在在ij区间的左边还是右边，在去进行转移即可。
```cpp
void dp(int L,int R,int node,int value, int pan) {
	if (L == 1 && R == n) return;
	if (L - 1 >= 1) {
		//从当前node的位置走到street_light[L-1]的路灯的位置
		int t =  node - street_light[L - 1].node;
		if (f[L - 1][R][0] > f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R])) {
			f[L - 1][R][0] = min(f[L - 1][R][0], f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R]));
		    dp(L - 1, R, street_light[L - 1].node, f[L - 1][R][0], 0);
		}	
	}
	if (R + 1 <= n) {
		//从当前node的位置走到street_light[R+1]的路灯的位置
		int t = street_light[R + 1].node - node;
		if (f[L][R + 1][1] > f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R])) {
			f[L][R + 1][1] = min(f[L][R + 1][1], f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R]));
		    dp(L, R + 1, street_light[R + 1].node, f[L][R + 1][1], 1);
		}		
	}
}
```
我选择是去递归的形式去填，然后pan这个参量就是表示我现在在L，R区间的左边还是右边（0表示左边，1表示右边）；
我们从[L,R]往[L-1,R]去延伸，很明显延伸完我们是在左边，所以得到的是f[L-1][R][0];R+1的转移同理，就是我们往R+1去延伸也就是终点在右边，就是可以得到f[L][R+1][1]其实加了一维对于上面二维仅仅只是在去表示了你在这个区间是在左端点还是右端点而已。
最后答案就是min(f[1][n][1],f[1][n][0]);
```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<cstring>
#include<stack>
#define ll long long
using namespace std;
const long long max_ = 1e9 + 7;
inline ll read() {
	ll s = 0, f = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * f;
}
int n,sum[100], first,f[100][100][2];
//                    0表示在左边，1 表示在右边
struct k {
	int p, node;
}street_light[100];
void dp(int L,int R,int node,int value, int pan) {
	if (L == 1 && R == n) return;
	if (L - 1 >= 1) {
		//从当前node的位置走到street_light[L-1]的路灯的位置
		int t =  node - street_light[L - 1].node;
		if (f[L - 1][R][0] > f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R])) {
			f[L - 1][R][0] = min(f[L - 1][R][0], f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R]));
		    dp(L - 1, R, street_light[L - 1].node, f[L - 1][R][0], 0);
		}	
	}
	if (R + 1 <= n) {
		//从当前node的位置走到street_light[R+1]的路灯的位置
		int t = street_light[R + 1].node - node;
		if (f[L][R + 1][1] > f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R])) {
			f[L][R + 1][1] = min(f[L][R + 1][1], f[L][R][pan] + t * sum[L - 1] + t * (sum[n] - sum[R]));
		    dp(L, R + 1, street_light[R + 1].node, f[L][R + 1][1], 1);
		}		
	}
}
int main() {
	cin >> n >> first;
	for (int i = 0; i <= 70; i++) {
		for (int j = 0; j <= 70; j++) {
			f[i][j][1] = 100000;
		f[i][j][0] = 1000000;
		}
	}
	for (int i = 1; i <= n; i++) {
		cin>>street_light[i].node;
		cin>>street_light[i].p;
		sum[i] = sum[i - 1] + street_light[i].p;
	}
	f[first][first][1] = 0; f[first][first][0] = 0;
	dp(first, first, street_light[first].node,0,1);
	cout << min(f[1][n][1] , f[1][n][0]);
	return 0;
}
```



---

## 作者：Sol1 (赞：0)

# 区间动态规划。

通过题目，我们很容易想到这样一个方法：

- 设状态为区间

- 设$dp[\ i\ ][\ j\ ][\ 0\ ]$为老张关掉$[\ l,r\ ]$区间并且最后站在$l$位置时的最小功耗；

- 设$dp[\ i\ ][\ j\ ][\ 1\ ]$为老张关掉$[\ l,r\ ]$区间并且最后站在$r$位置时的最小功耗；

再设$pos[\ i\ ]$为第$i$盏路灯的位置，$power[\ i\ ]$为第$i$盏路灯的功率，$sum=\sum^{k=1}_{i-1}power[k]+\sum^{k=r+1}_{N}power[k]$，即有状态转移方程：

$dp[i][j][0]=\min \{ dp[i+1][j][0]+(sum + power[i]) \times (pos[i + 1] - pos[i]),dp[i+1][j][1]+(sum + power[i])\times(pos[j] - pos[i]) \}$

$dp[i][j][1]=\min \{ dp[i][j-1][1]+(sum + power[j]) \times (pos[j + 1] - pos[j]),dp[i][j-1][0]+(sum + power[j])\times(pos[j] - pos[i]) \}$

很容易得到记忆化搜索的代码。~~很不幸的是，只能得50分。~~为什么呢？因为如果$C$接近中间或$N$的话，记忆化需要搜索很多次。所以我们用迭代DP法求解。

## So, look at my code.
```cpp
/*
区间动态规划
author：David 
*/
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;
const int MAXN = 55;
int N, C, pos[MAXN], power[MAXN], fr[MAXN];
long long dp[MAXN][MAXN][2], INF;
//dp[i][j][0],表示当[i,j]的灯已经关掉，且人在i位置时消耗的最小电量 
//dp[i][j][1],表示当[i,j]的灯已经关掉，且人在j位置时消耗的最小电量 

//原来的记忆化。。。
//long long dfs(int l, int r, int d)
//{
//	if (l==C&&r==C) return 0;
//	if (l == r)
//		return dp[l][r][d];
//	
//	if (dp[l][r][d] != INF)
//		return dp[l][r][d];
//	printf("l=%d r=%d d=%d\n", l, r, d);
//	int sum = fr[l - 1] + fr[N] - fr[r];
//	if (d == 0)
//	{
//		dp[l][r][0] = min(dp[l][r][0], dfs(l + 1, r, 0)
//		+ (sum + power[l]) * (pos[l + 1] - pos[l]));
//		dp[l][r][0] = min(dp[l][r][0],
//		dfs(l + 1, r, 1) + (sum + power[l]) * (pos[r] - pos[l]));
////		printf("dp[%d][%d][1]=%lld\n", l + 1, r, dp[l + 1][r][1]);
//	}
//	else
//	{
//		dp[l][r][1] = min(dp[l][r][1], dfs(l, r - 1, 1)
//		+ (sum + power[r]) * (pos[r] - pos[r - 1]));
//		dp[l][r][1] = min(dp[l][r][1],
//		dfs(l, r - 1, 0) + (sum + power[r]) * (pos[r] - pos[l]));
////		printf("dp[%d][%d][0]=%lld\n", l, r - 1, dp[l][r - 1][0]);
//	}
//	printf("dp[%d][%d][%d]=%lld\n", l, r , d,dp[l][r][d]);
//	return dp[l][r][d];
//}
int main()
{
	scanf("%d%d", &N, &C);
	for (int i = 1;i <= N;i++)
	{
		scanf("%d%d", &pos[i], &power[i]);
		fr[i] = fr[i - 1] + power[i];
	}
	memset(dp, 42, sizeof(dp));//INF
	INF = dp[C][C][0];
//	cout << INF << endl;
	dp[C][C][0] = dp[C][C][1] = 0;
	for (int i = C;i <= N;i++)
		for (int j = i - 1;j >= 1;j--)
		{
			int sum = fr[j - 1] + fr[N] - fr[i];
			dp[j][i][0] = min(dp[j][i][0], dp[j + 1][i][0]
			+ (sum + power[j]) * (pos[j + 1] - pos[j]));
			dp[j][i][0] = min(dp[j][i][0], dp[j + 1][i][1]
			+ (sum + power[j]) * (pos[i] - pos[j]));
			dp[j][i][1] = min(dp[j][i][1], dp[j][i - 1][1]
			+ (sum + power[i]) * (pos[i] - pos[i - 1]));
			dp[j][i][1] = min(dp[j][i][1], dp[j][i - 1][0]
			+ (sum + power[i]) * (pos[i] - pos[j]));
		}
	printf("%lld", min(dp[1][N][0], dp[1][N][1]));
	return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

dp：
⑴每个路灯的花费为 ci\*ti ，即功率乘以关闭的时间。

⑵所关掉的路灯是一个连续的区间，越过一个亮着的路灯而去关其他路灯显然不是最优的。因为了连续区域可以用前缀和预处理。

F[i][j][0]表示区间i到j最后一个关的是第i盏灯所需最小电。F[i][j][1]表示区间i到j最后一个关的是第j盏灯所需的最小电。

状态转移：

F[i][j][0]=min((a[i+1]-a[i])\*(sum[n]-sum[j]+sum[i])+F[i+1][j][0],(a[j]-a[i])\*(sum[n]-sum[j]+sum[i])+F[i+1][j][1]);

F[i][j][1]=min((a[j]-a[j-1])\*(sum[n]-sum[j-1]+sum[i-1])+F[i][j-1][1],(a[j]-a[i])\*(sum[n]-sum[j-1]+sum[i-1])+F[i][j-1][0]);



```cpp
uses math;
var n,c,k,i,j,s,t,x:longint; ans:longint;
    f:array[1..50,1..50,0..1]of longint;
    a,sum:array[0..50]of longint;
begin
  readln(n,c);
  for i:=1 to n do begin
    readln(a[i],x);
    sum[i]:=sum[i-1]+x;
  end;
  fillchar(f,sizeof(f),$3F);
  f[c,c,0]:=0;f[c,c,1]:=0;
  for k:=1 to n-1 do begin
    s:=max(1,c-k);t:=min(n,c+k);
    for i:=s to t do begin
      j:=i+k;
      F[i][j][1]:=min(F[i][j-1][1]+(a[j]-a[j-1])*(sum[n]-sum[j-1]+sum[i-1]),F[i][j][1]);
      F[i][j][1]:=min(F[i][j-1][0]+(a[j]-a[i])*(sum[n]-sum[j-1]+sum[i-1]),F[i][j][1]);
      F[i][j][0]:=min(F[i+1][j][1]+(a[j]-a[i])*(sum[n]-sum[j]+sum[i]),F[i][j][0]);
      F[i][j][0]:=min(F[i+1][j][0]+(a[i+1]-a[i])*(sum[n]-sum[j]+sum[i]),F[i][j][0]);
     end;
  end;
  ans:=min(f[1,n,0],f[1,n,1]);
  writeln(ans);
end.

```

---

## 作者：✌yww (赞：0)

我们假设 dpij0 为目前最优值是在 i 位置,dpij1 为目前最优值是在 j 位置

则 i 到 j 表示已经关掉的灯的区间，因为我们要求最小的损耗，所以必然是从当前区间走向区间两端

再利用前缀和来算从前一个位置走向当前位置所需要的时间，再乘上没关掉电灯的功率即可

```cpp
for(i = c to 1)for(j = i+1 to n)
dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][0]+(a[i+1]-a[i])*(b[n]-(b[j]-b[i])));//分4情况，耗能计算，时间乘以功率 
            dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][1]+(a[j]-a[i])*(b[n]-(b[j]-b[i])));
            dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+(a[j]-a[j-1])*(b[n]-(b[j-1]-b[i-1])));
            dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+(a[j]-a[i])*(b[n]-(b[j-1]-b[i-1])));
```
代码不给出了，可以看博客有详细解释
http://www.cnblogs.com/oi-forever/p/7344325.html


---

## 作者：wcl95716 (赞：0)

原本想用搜索先超时一把

然后发现剪枝居然过了



首先 对于每个位置，去寻找左边没关掉的灯或者右边没有关掉的灯。

之后造深搜 ，寻找最优情况。

然后 在搜索中我们发现，如果此时的和大于记录中的和的话，

那么这个搜索是没有必要继续走下去的，所以就结束掉这个叶子。

就像动态规划只保留最大值一样。

搜索的好处是，不仅能知道最大值，而且可以输出其路径。



```cpp
- #include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <map>
using namespace std;
int d[10005];//记录灯的功率
int lef,righ,minx;
int run(int x,int y)//记录跑到了哪个位置
{
    while(d[x]==0&&x>=lef&&x<=righ)
        x+=y;
    return x;
}
void dfs(int l,int s,int sum,int n)
{
    //cout<<l<<' '<<s<<' '<<sum<<' '<<n<<endl;
    //cout<<run(l,1)<<' '<<run(l,-1)<<' '<<righ<<' '<<lef<<endl<<endl;
    if(s>minx) return;//如果现有和大于记录值  结束叶子。
    if(n==1)
    {
        if(s<minx)
            minx=s;
        return ;
    }
    int t=d[l];
    sum-=t;
    d[l]=0;
    int x;
    if(run(l,1)<=righ)//往右跑
    {
        x=run(l,1);
        dfs(x,s+sum*(x-l),sum,n-1);
    }
    if(run(l,-1)>=lef)//往左跑
    {
        x=run(l,-1);
        dfs(x,s+sum*(l-x),sum,n-1);
    }
    d[l]=t;//回溯
}
int main()
{
    int n,m;
    cin>>n>>m;
        int x,y;
        int sum=0;
        righ=0;
        lef=100000000;
        minx=1000000000;
        int t,l;
        for(int i=1;i<=n;i++)
        {
            cin>>x>>y;
            if(x<lef)  lef=x;
            if(x>righ) righ=x;
            d[x]=y;
            sum+=y;
            if(i==m)
            {
                d[x]=0;
                t=y;
                l=x;
            }
        }
        dfs(l,0,sum-t,n);
        cout<<minx<<endl;
}
```

---


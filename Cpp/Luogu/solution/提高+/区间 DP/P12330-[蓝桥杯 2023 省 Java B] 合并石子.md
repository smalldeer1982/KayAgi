# [蓝桥杯 2023 省 Java B] 合并石子

## 题目描述

在桌面从左至右横向摆放着 $N$ 堆石子。每一堆石子都有着相同的颜色，颜色可能是颜色 $0$，颜色 $1$ 或者颜色 $2$ 中的其中一种。现在要对石子进行合并，规定每次只能选择位置相邻并且颜色相同的两堆石子进行合并。合并后新堆的相对位置保持不变，新堆的石子数目为所选择的两堆石子数目之和，并且新堆石子的颜色也会发生循环式的变化。具体来说：两堆颜色 $0$ 的石子合并后的石子堆为颜色 $1$，两堆颜色 $1$ 的石子合并后的石子堆为颜色 $2$，两堆颜色 $2$ 的石子合并后的石子堆为颜色 $0$。本次合并的花费为所选择的两堆石子的数目之和。

给出 $N$ 堆石子以及他们的初始颜色，请问最少可以将它们合并为多少堆石子？如果有多种答案，选择其中合并总花费最小的一种，合并总花费指的是在所有的合并操作中产生的合并花费的总和。

## 说明/提示

### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/bifee2mb.png)

上图显示了两种不同的合并方式。其中节点中标明了每一堆的石子数目，在方括号中标注了当前堆石子的颜色属性。左图的这种合并方式最终剩下了两堆石子，所产生的合并总花费为 $15 + 14 + 15 = 44$；右图的这种合并方式最终也剩下了两堆石子，但产生的合并总花费为 $14 + 15 + 25 = 54$。综上所述，我们选择合并花费为 $44$ 的这种方式作为答案。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 10$。
- 对于 $50\%$ 的评测用例，$1 \leq N \leq 50$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 300$，$1 \leq$ 每堆石子的数目 $\leq 1000$。

## 样例 #1

### 输入

```
5
5 10 1 8 6
1 1 0 2 2```

### 输出

```
2 44```

# 题解

## 作者：MoonCake2011 (赞：5)

纯水题，就是几秒出思路，几分钟写代码的那种。

首先，我们先考虑区间 dp。

设 $dp_{i,j,k}$ 为区间 $[i,j]$ 合并完后颜色为 $k$ 的最小花费。

然后直接像[这道题](https://www.luogu.com.cn/problem/P1775)一样直接转移就是了。

我们求出每个区间的答案之后，我们可以继续考虑 dp。

因为要求最少的石头堆数，我们直接考虑分段 dp，每一段都是能合并成功的。

设 $f_{i,j}$ 为前 $i$ 个数分 $j$ 段的最小花费。

初值 $f_{0,0}=0$。

然后直接可以列出转移方程。

$$f_{i,j}=\sum_{k=0}^{i-1} f_{k,j-1}+\min_{0\le c\le 2}(dp_{k+1,c})$$。

接着我们从小到大枚举段数，第一个有值的 $dp_{n,i}$ 就是答案。

代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100010],c[100010],s[100010];
int dp[310][310][3],f[310][310];
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],s[i]=s[i-1]+a[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	memset(dp,0x3f,sizeof dp);
	for(int i=1;i<=n;i++) dp[i][i][c[i]]=0;
	for(int k=2;k<=n;k++){
		for(int i=1;i+k-1<=n;i++){
			int j=i+k-1;
			for(int p=i;p<j;p++){
				dp[i][j][0]=min(dp[i][j][0],dp[i][p][2]+dp[p+1][j][2]+s[j]-s[i-1]);
				dp[i][j][1]=min(dp[i][j][1],dp[i][p][0]+dp[p+1][j][0]+s[j]-s[i-1]);
				dp[i][j][2]=min(dp[i][j][2],dp[i][p][1]+dp[p+1][j][1]+s[j]-s[i-1]);
			}
		}
	}
	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){//分几段  
			for(int k=0;k<i;k++) f[i][j]=min(f[i][j],f[k][j-1]+min(dp[k+1][i][0],min(dp[k+1][i][1],dp[k+1][i][2])));
		}
	}
	for(int i=1;i<=n;i++) if(f[n][i]<=2e15){
		cout<<i<<" "<<f[n][i];
		break;
	}
	return 0;
}
```

---

## 作者：W_C_B_H (赞：2)

看到这道题的标题及内容后，不难想到本题需要用区间 dp 完成。设 $dp_{i,j,c}$ 表示将区间 $[i,j]$ 的石子合并为一堆颜色为 $c$ 的石子的最小花费（$0\le c\le2$，若无法做到则为 $+\infty$），$num_{i,j}$ 表示可以将区间 $[i,j]$ 的石子合并成的最小堆数，$cost_{i,j}$ 表示将区间 $[i,j]$ 的石子合并成最小堆数时的最小花费。

根据状态定义，初始状态为：对于所有 $1\le i\le N$，$dp_{i,i,a_i}=0$，且 $dp_{i,i}$ 中其他位置的值为 $+\infty$；$num_{i,i}=1,cost_{i,i}=0$；对于每个满足 $i<j$ 的 $i,j$，$dp_{i,j,c}=+\infty,num_{i,j}=j-i+1,cost_{i,j}=0$。

接下来考虑如何转移。对于每个满足 $i<j$ 的区间 $[i,j]$：

- 观察可得，合并两堆颜色为 $c$ 的石子时，会得到一堆颜色为 $(c+1)\bmod3$ 的石子。故可以枚举 $k\in[i,j)$ 和 $c\in[0,2]$，若 $dp_{i,k,c},dp_{k+1,j,c}$ 均不为 $+\infty$，则 $num_{i,j}\gets 1$，并尝试用 $dp_{i,k,c}+dp_{k+1,j,c}+sum_j-sum_{i-1}$ 更新 $dp_{i,j,(c+1)\bmod 3}$ 和 $cost_{i,j}$（注意合并两堆石子时颜色会改变）。

- 若经过前面的枚举，$num_{i,j}$ 仍无法为 $1$（即区间 $[i,j]$ 的石子无法合并为一堆），则枚举 $k\in[i,j)$：

  - 若 $num_{i,k}+num_{k+1,j}<num_{i,j}$，则 $num_{i,j}\gets num_{i,k}+num_{k+1,j}$ 并 $cost_{i,j}\gets cost_{i,k}+cost_{k+1,j}$；
  
  - 否则，若 $num_{i,k}+num_{k+1,j}=num_{i,j}$ 且 $cost_{i,k}+cost_{k+1,j}<cost_{i,j}$，则 $cost_{i,j}\gets cost_{i,k}+cost_{k+1,j}$。
 
按从短到长、从左到右的顺序枚举区间进行转移，最终答案为 $num_{1,n}$ 和 $cost_{1,n}$。时间复杂度 $O(N^3)$，可以通过本题。

注意无论何时 $num$ 变小，$cost$ 均需强制赋值为该方法的花费。

Code：

```java
import java.util.Scanner;
public class Main {
    static final int N = 305, inf = 2147483647;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 各种数组
        int[] v = new int[N], a = new int[N], sum = new int[N];
        int[][] num = new int[N][N], cost = new int[N][N];
        sum[0] = 0;
        int[][][] dp = new int[N][N][3];
        // 输入
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            v[i] = sc.nextInt();
            sum[i] = sum[i - 1] + v[i];    // 前缀和
            for(int c = 0; c <= 2; c++) {    // dp 的初始状态
                dp[i][i][c] = inf;
            }
        }
        for(int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
            
            // 初始状态
            dp[i][i][a[i]] = 0;
            num[i][i] = 1;
            cost[i][i] = 0;
            for(int j = i + 1; j <= n; j++) {
                for(int c = 0; c <= 2; c++) {
                    dp[i][j][c] = inf;
                }
                num[i][j] = j - i + 1;
                cost[i][j] = 0;
            }
        }
        // 按从短到长、从左到右的顺序枚举区间进行转移
        for(int len = 2; len <= n; len++) {
            for(int i = 1; i + len - 1 <= n; i++) {
                int j = i + len - 1;
                for(int k = i; k < j; k++) {    // 尝试将 [i,j] 合并为一堆
                    for(int c = 0; c <= 2; c++) {
                        if(dp[i][k][c] == inf || dp[k+1][j][c] == inf) {
                            continue;
                        }
                        int tot = dp[i][k][c] + dp[k+1][j][c] + sum[j] - sum[i - 1];
                        if(num[i][j] > 1) {
                            num[i][j] = 1;
                            cost[i][j] = tot;
                        }
                        else {
                            cost[i][j] = Math.min(cost[i][j], tot);
                        }
                        dp[i][j][(c + 1) % 3] = Math.min(dp[i][j][(c + 1) % 3], tot);
                    }
                }
                if(num[i][j] == 1) {    // 如果可以合并为一堆就不用继续计算
                    continue;
                }
                for(int k = i; k < j; k++) {    // 计算将 [i,j] 合并为若干堆时的最小堆数及其对应的最小花费
                    if(num[i][k] + num[k+1][j] < num[i][j]) {
                        num[i][j] = num[i][k] + num[k+1][j];
                        cost[i][j] = cost[i][k] + cost[k+1][j];
                    }
                    else if(num[i][k] + num[k+1][j] == num[i][j] && cost[i][k] + cost[k+1][j] < cost[i][j]) {
                        cost[i][j] = cost[i][k] + cost[k+1][j];
                    }
                }
            }
        }
        // 输出
        System.out.printf("%d %d", num[1][n], cost[1][n]);
    }
}
```

---

## 作者：linruicong_gegeji (赞：1)

这篇题解是来给楼上大佬 [MoonCake2011](https://www.luogu.com.cn/user/886055) 的题解做补充的。很巧，我的思路和大佬的思路非常相似。这篇题解相对于大佬的题解或许讲的更加详细，对初学者更友好一些，~~所以管理大大求过~~。

## 题目分析

很显然，做过[弱化版](https://www.luogu.com.cn/problem/P1775)的都知道，肯定就是用区间 DP 了。

### 什么是区间动态规划？

会的大佬请略过。

其实区间动态规划的含义很好理解，就是将普通的动态规划策略放到区间里而已，以此解决区间的一些最优解问题。解决的方式大体是相同的，都是通过一些子问题的最优解转移到大问题的最优解以此解决问题。放到区间动态规划里无非就是多个子区间对大区间的最优解的更新。

区间动态规划一般会有两个维度，分别表示一个区间的左端点和右端点。同时，我们使用循环来枚举区间，然后根据题意进行转移。

在必要的时候，我们还可以增加一些维度来表示更加复杂的状态。

接下来可以通过这道题的[弱化版](https://www.luogu.com.cn/problem/P1775)来给大家讲解最简单的区间动态规划。

#### 题目讲解

我们可以发现，这道题目就是去掉了颜色的区分而已。我们可以设 $f_{i,j}$ 为合并区间 $[i,j]$ 所需的最小花销。根据题意，我们就可以设立状态转移方程。

由于题目的意思是两个区间合并，那么我们可以枚举一个分割点 $k$ 以此把目标区间分成两部分。枚举不同的 $k$ 可以得到不同的合并花销。这些不同的方案中的最小值就是这个区间的最优合并花销了。

显然，公式为：
$$f_{i,j}=\min(f_{i,j},f_{l,k}+f_{k+1,j}+s_{i,j})$$

#### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[605],s[305][305],r,f[305][305]; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		a[n+i]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		s[i][i]=a[i];
		for(int j=i+1;j<=n;j++) s[i][j]=s[i][j-1]+a[j];//预处理区间数值和
	}
	for(int len=2;len<=n+1;len++)
	{
		for(int l=1;l+len-1<=n;l++)//枚举区间
		{
			r=l+len-1;
			f[l][r]=0x7f7f7f7f;
			for(int k=l;k<r;k++) f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[l][r]);//枚举分割点并且更新最优解
		}
	}
	printf("%d",f[1][n]);
	return 0;
}
```

### 本题题解

我们设 ${f_1}_{l,r,k}$ 为区间 $[l,r]$，颜色为 $k$ 的合并最小开销，$s_l$ 和 $s_r$ 分别为序列的前 $l$ 个数的和以及序列的前 $r$ 个数的和，$pos$ 为枚举的分割点（$l \le pos \le r-1$）。易得方程：

$$
{f_1}_{l,r,0}=\min({f_1}_{l,r,0},{f_1}_{l,pos,2}+{f_1}_{pos+1,r,2}+s_r-s_{l-1}) \\
{f_1}_{l,r,1}=\min({f_1}_{l,r,1},{f_1}_{l,pos,0}+{f_1}_{pos+1,r,0}+s_r-s_{l-1}) \\
{f_1}_{l,r,2}=\min({f_1}_{l,r,2},{f_1}_{l,pos,1}+{f_1}_{pos+1,r,1}+s_r-s_{l-1}) \\
$$

接下来，我们再定义一个动态规划数组 $f2$，这个数组用于答案的计算。

定义 $f2_{i,j}$ 为将前 $i$ 个石堆合并成 $j$ 个石堆的最小花销，$k$ 为枚举的分割点（$0 \le k \le i-1$）。易得方程：
$$f2_{i,j}=\min(f2_{i,j},f2_{k,{j-1}}+\min(f1_{{k+1},i,0},\min(f1_{{k+1},i,1},f1_{{k+1},i,2})))$$

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t[305],c[305],s[305],f1[305][305][5],f2[305][305],r;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&t[i]);
        s[i]=s[i-1]+t[i];//计算前缀和
    }
    for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    memset(f1,0x3f,sizeof f1);//初始化为极大值
    memset(f2,0x3f,sizeof f2);
    for(int i=1;i<=n;i++) f1[i][i][c[i]]=0;
    for(int len=2;len<=n;len++)
    {
        for(int l=1;l+len-1<=n;l++)
        {
            r=l+len-1;
            for(int k=l;k<r;k++)//参照上面的方程
            {
                f1[l][r][0]=min(f1[l][r][0],f1[l][k][2]+f1[k+1][r][2]+s[r]-s[l-1]);
                f1[l][r][1]=min(f1[l][r][1],f1[l][k][0]+f1[k+1][r][0]+s[r]-s[l-1]);
                f1[l][r][2]=min(f1[l][r][2],f1[l][k][1]+f1[k+1][r][1]+s[r]-s[l-1]);
            }
        }
    }
    f2[0][0]=0;//初始化
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            for(int k=0;k<i;k++)
            {
                int minn=min(f1[k+1][i][0],min(f1[k+1][i][1],f1[k+1][i][2]));
                f2[i][j]=min(f2[i][j],f2[k][j-1]+minn);//求出答案
            }
        }
    }
    for(int i=1;i<=n;i++)//枚举可能的答案
    {
        if(f2[n][i]<1e9)//假如这个答案符合标准，则这个答案一定是最优的
        {
            printf("%d %d",i,f2[n][i]);//输出答案
            return 0;
        }
    }
    return 0;
}
```

考虑到这个是 Java 的题目，但是蒟蒻根本不会 Java。于是我让 DeepSeek 帮我生成了一篇 Java 代码，供学习 Java 的同学参考。

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] t = new int[n + 1];
        int[] c = new int[n + 1];
        int[] s = new int[n + 1];
        
        // 读取石子数目并计算前缀和
        for (int i = 1; i <= n; i++) {
            t[i] = scanner.nextInt();
            s[i] = s[i - 1] + t[i];
        }
        
        // 读取石子颜色
        for (int i = 1; i <= n; i++) {
            c[i] = scanner.nextInt();
        }
        
        // 初始化三维DP数组 f1[l][r][k]
        int[][][] f1 = new int[n + 1][n + 1][3];
        // 初始化为极大值
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                Arrays.fill(f1[i][j], Integer.MAX_VALUE / 2); // 防止溢出
            }
        }
        
        // 初始化二维DP数组 f2[i][j]
        int[][] f2 = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(f2[i], Integer.MAX_VALUE / 2);
        }
        
        // 初始化单堆石子
        for (int i = 1; i <= n; i++) {
            f1[i][i][c[i]] = 0;
        }
        
        // 区间DP计算 f1
        for (int len = 2; len <= n; len++) {
            for (int l = 1; l + len - 1 <= n; l++) {
                int r = l + len - 1;
                for (int k = l; k < r; k++) {
                    // 颜色转移规则：0+0→1, 1+1→2, 2+2→0
                    f1[l][r][0] = Math.min(f1[l][r][0], f1[l][k][2] + f1[k + 1][r][2] + s[r] - s[l - 1]);
                    f1[l][r][1] = Math.min(f1[l][r][1], f1[l][k][0] + f1[k + 1][r][0] + s[r] - s[l - 1]);
                    f1[l][r][2] = Math.min(f1[l][r][2], f1[l][k][1] + f1[k + 1][r][1] + s[r] - s[l - 1]);
                }
            }
        }
        
        // 初始化f2
        f2[0][0] = 0;
        
        // 计算f2：将前i堆合并成j堆的最小花费
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                for (int k = 0; k < i; k++) {
                    int minColor = Math.min(f1[k + 1][i][0], Math.min(f1[k + 1][i][1], f1[k + 1][i][2]));
                    f2[i][j] = Math.min(f2[i][j], f2[k][j - 1] + minColor);
                }
            }
        }
        
        // 查找最小堆数和对应的最小花费
        for (int i = 1; i <= n; i++) {
            if (f2[n][i] < 1e9) {
                System.out.println(i + " " + f2[n][i]);
                return;
            }
        }
    }
}
```

---

## 作者：Chenyichen0420 (赞：1)

## 思路分析

直接两次动规解决，~~简称动规套动规~~。假的。

不难想到我们可以处理出以每一个点作为左端点能够跳到哪些右端点，以及相应的最小费用是多少。

这个可以使用板中板的区间动规 $O(n^3)$ 解决。

接下来就是从左到右分割区间的最优性了。要求优先保证区间数量少，随后费用小。

显然区间数是在 $n$ 及以下的，因此我们仍然设计两维状态，在哪里，分多少个区间对应的最小花费。

存下来可行的转移后我们每次暴力枚举完事。时间复杂度也是 $O(n^3)$ 的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<pair<int, int>>ed[305];
int n, a[305], b[305], dp[305][305][3], s[305], rd[305][305];
inline void tmin(int& l, const int r) { (l > r) && (l = r); }
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	memset(dp, 0x0f, sizeof dp);
	for (int i = 1; i <= n; ++i)
		cin >> a[i], s[i] = a[i] + s[i - 1];
	for (int i = 1; i <= n; ++i)
		cin >> b[i], dp[i][i][b[i]] = 0;
	for (int i = 1; i <= n; ++i)
#define r (l + i - 1)
		for (int l = 1; r <= n; ++l)
			for (int p = l; p != r; ++p) {
				tmin(dp[l][r][0], dp[l][p][2] + dp[p + 1][r][2] + s[r] - s[l - 1]);
				tmin(dp[l][r][1], dp[l][p][0] + dp[p + 1][r][0] + s[r] - s[l - 1]);
				tmin(dp[l][r][2], dp[l][p][1] + dp[p + 1][r][1] + s[r] - s[l - 1]);
			}
	for (int i = 1; i <= n; ++i)
		for (int j = i; j <= n; ++j)
			if (min({ dp[i][j][0],dp[i][j][1],dp[i][j][2] }) <= 1e12)
				ed[i].emplace_back(j + 1, min({ dp[i][j][0],dp[i][j][1],dp[i][j][2] }));
	memset(rd, 0x0f, sizeof rd); rd[1][0] = 0;
	for (int i = 1; i <= n; ++i)
		for (int j = 0; j <= n; ++j)
			if (rd[i][j] <= 1e12)
				for (const auto& v : ed[i])
					tmin(rd[v.first][j + 1], rd[i][j] + v.second);
	for (int i = 1; i <= n; ++i)
		if (rd[n + 1][i] <= 1e12) {
			cout << i << " " << rd[n + 1][i] << endl;
			return 0;
		}
}
```

---

## 作者：GDlh (赞：1)

## 题面
一个序列表示 $n$ 堆石子，第 $i$ 堆石子的数量为 $a_i$，颜色为 $c_i$，$c_i \in \{0,1,2\}$。

每次操作可以合并相邻且颜色相同的两堆石子 $x$、$y$，并消耗 $a_x+a_y$ 的花费，使新堆 $z$ 的数量 $a_z=a_x+a_y$，颜色 $c_z=(c_x+1)\bmod 3$。

求能合并成最少的堆数，以及合并成最少的堆数的最小花费。

## 解法
对于此类区间合并问题，自然可以想到使用区间dp求解。

规定 $dp_{l,r,j}$ 表示合并得到颜色为 $j$ 的区间 $[l,r]$ 的最小花费，$sum_{i}$ 表示 $a_i$ 的前缀和。

转移方程有：  
$$
dp_{l,r,j}=\min(dp_{l,r,j},dp_{l,k,(j+2)\bmod 3}+dp_{k+1,r,(j+2)\bmod 3}+sum_{r}-sum_{l-1})
$$  
即得到当前堆的花费等于得到左右两堆的花费再加上当前合并操作的花费。

那么现在我们得到了每个区间的最小花费，由于题目要求得到最少的堆数，我们再进行一次朴素dp，求解是否能将序列划分成不同区间的组合，且其最小花费为多少。

定义 $f_{i,k}$ 表示划分到第 $i$ 个位置，划分了 $k$ 个区间的最小花费。

转移方程有：  
$$
f_{i,k}=\min(f_{i,k},f_{j-1,k-1}+dp_{j,i,t})
$$  
即 $j-1$ 位置的 $f$ 值加上 $j$ 到 $i$ 区间的最小值得到当前位置的 $f$ 值。

最后从小到大枚举 $f_{n,i}$，若 $f_{n,k}$ 不为无穷大（即存在方法使序列划分成 $k$ 个区间)，即可输出最小堆数为 $k$，最小花费为 $f_{n,k}$。**注意** $f_{n,n}=0$，即不能合并时花费为 $0$。

时间复杂度：$O(n^{3})$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=333;
int n,a[N],col[N],sum[N];
int dp[N][N][3],f[N][N];

signed main(){
	ios::sync_with_stdio(0); cin.tie(0);
	cin>>n;
	memset(dp,0x3f,sizeof(dp));
	memset(f,0x3f,sizeof(f));
			
	for(int i=1;i<=n;++i) cin>>a[i],sum[i]=sum[i-1]+a[i]; 
	for(int i=1;i<=n;++i) {
		cin>>col[i];
		dp[i][i][col[i]]=0;
	}
	f[0][0]=0;
	for(int len=2;len<=n;++len){
		for(int l=1,r=len;r<=n;++l,++r){
			for(int k=l;k<r;++k){
				for(int j=0;j<=2;++j){
					dp[l][r][j]=min(1ll*dp[l][r][j],1ll*dp[l][k][(j+2)%3]+dp[k+1][r][(j+2)%3]+sum[r]-sum[l-1]);
				}
			}
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=i;j<=n;++j){
			for(int k=1;k<=n;++k){
				for(int l=0;l<=2;++l){
					f[j][k]=min(1ll*f[j][k],1ll*f[i-1][k-1]+dp[i][j][l]);
				}
			}
		}
	}
	f[n][n]=0;
	for(int i=1;i<=n;++i){
		if(f[n][i]<1e9) return cout<<i<<' '<<f[n][i],0;
	} 
	return 0;
}
```

---

## 作者：wurang (赞：1)

由于最终的答案是由多堆颜色相同的石子堆组合起来得到的，不难想到使用区间动态规划解决。

### 状态定义

由于石子的合并方式较复杂，需要使用动态规划。

$dp_{i,j,c}$ 表示使得区间 $\left[ i, j \right]$ 的石子颜色均为 $c$ 的最小代价，如果不能够达成，则用极大值表示。

### 边界条件

首先对整个数组赋极大值，接着对长度为 $1$ 的区间赋值，设一开始从左往右的第 $i$ 堆石子为 $color_i$，则 $dp_{i,i,color_i} = 0$。

### 状态转移

简单总结出规律，要使得新的石子堆的颜色为 $c$，显然是通过两堆颜色为 $(c - 1 + 3) \bmod 3$ 得到的。当然也可以分类讨论。

此处合并区间时，需要支付区间石子总数的总和，此处 $a_i$ 表示一开始从左往右的第 $i$ 堆石子的个数，写出转移方程：

$$
dp_{i,j,c} = \sum^{j - 1}_{k = i} \min \left( dp_{i,k,(c-1+3) \bmod 3} + dp_{k+1,j,(c-1+3) \bmod 3} + \sum^{j}_{s=i}a_s \right)
$$

### 答案计算

用 $g_{i,j}$ 表示从 $i$ 到 $j$ 合并后数目最少的石头堆数，$ans_{i,j}$ 表示对应的最小花费。

这里先计算出 $dp$ 数组。

在计算 $g_{i,j}$ 时，枚举转折点 $k$，用 $g_{i,k}$ 与 $g_{k+1,j}$ 转移。在最小化石头堆数的前提下，最小化花费即可。

$ans$ 数组的计算在 $g$ 数组计算时更新即可。

### 代码实现

这里整合了 $dp$ 数组的计算以及 $g$ 数组和 $ans$ 数组的计算，优化了常数。

此处使用前缀和优化 $\sum^{j}_{s=i}a_s$ 的计算。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){int x = 0, f = 1;char ch = getchar();while (ch < '0' || ch > '9'){if (ch == '-') f = -1; ch = getchar();}while (ch >= '0' && ch <= '9'){x = x * 10 + ch - 48; ch = getchar();}return x * f;}

const int inf = 0x3f3f3f3f3f3f3f3f;

int n;
int a[305];
int qz[305]; // 优化
int col[305];
int g[305][305]; // 表示从i到j合并后数目最少的石头堆数
int ans[305][305]; // 对应的最小花费
int dp[305][305][3];

inline void updata(int &gg, int &anss, int x, int y)
{
    if(x < gg) // 优先最小化石头堆数
        gg = x, anss = y;
    else if(x == gg) // 最小化花费
        anss = min(anss, y);
} // 代替更新操作

signed main()
{
    memset(dp, 0x3f, sizeof(dp));
    memset(g, 0x3f, sizeof(g));
    memset(ans, 0x3f, sizeof(ans));
    n = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        qz[i] = qz[i - 1] + a[i];
    }
    for(int i = 1; i <= n; i++)
        col[i] = read();
    for(int i = 1; i <= n; i++)
        dp[i][i][col[i]] = 0, g[i][i] = 1, ans[i][i] = 0;
    for(int l = 2; l <= n; l++)
    {
        for(int i = 1; i + l - 1 <= n; i++)
        {
            int j = i + l - 1;
            for(int k = i; k < j; k++)
            {
                for(int c = 0; c < 3; c++)
                    dp[i][j][c] = min(dp[i][j][c], dp[i][k][(c - 1 + 3) % 3] + dp[k + 1][j][(c - 1 + 3) % 3] + qz[j] - qz[i - 1]);
                updata(g[i][j], ans[i][j], g[i][k] + g[k + 1][j], ans[i][k] + ans[k + 1][j]);    
            }
            for(int c = 0; c < 3; c++)
                if(dp[i][j][c] != inf) updata(g[i][j], ans[i][j], 1, dp[i][j][c]);
        }
    }
    cout << g[1][n] << " " << ans[1][n] << '\n';
    return 0;
}
```

---


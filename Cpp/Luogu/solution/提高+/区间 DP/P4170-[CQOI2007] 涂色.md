# [CQOI2007] 涂色

## 题目描述

假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\texttt{RGBGR}$。

每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\texttt{RRRRR}$，第二次涂成 $\texttt{RGGGR}$，第三次涂成 $\texttt{RGBGR}$，达到目标。

用尽量少的涂色次数达到目标。


## 说明/提示

$40\%$ 的数据满足 $1\le n\le 10$。

$100\%$ 的数据满足 $1\le n\le 50$。



## 样例 #1

### 输入

```
AAAAA```

### 输出

```
1```

## 样例 #2

### 输入

```
RGBGR```

### 输出

```
3```

# 题解

## 作者：FZzzz (赞：92)

题意：给个没有任何颜色的序列，你每次可以选一段区间覆盖上一种颜色，给个目标状态，求达到它的最小步数。

我断言一定存在一种最优的方案满足对于任意两次染色：它们的区间要么不交，要么靠后的那次被靠前的那次包含并且不共端点。

证明只是反证法然后做一些分类讨论。比如，如果两次染色的区间相交但不包含，你可以缩短靠前的那次的区间使它们变得不相交，但不改变最终的结果。接下来我们只讨论满足上面条件的染色方案

设 $f_{l,r}$ 为给区间 $[l,r]$ 染色的最小步数。边界显然是 $f_{i,i}=1$。若 $l<r$ 则考虑两种情况：
- $s_l=s_r$。首先显然有 $f_{l,r}\ge f_{l,r-1}$。然后考虑对 $[l,r-1]$ 染色的方案，设覆盖了 $l$ 的唯一一次染色的右端点是 $x$。我们把这次染色的右端点改成 $r$，并且把所有在 $[x+1,r]$ 上进行的染色保持原来的顺序挪到这次染色之后，这样我们在不改变步数的情况下从一个对 $[l,r-1]$ 染色的方案得到了一个对 $[l,r]$ 染色的方案。故 $f_{l,r}=f_{l,r-1}$。
- $s_l\ne s_r$。此时不存在一次覆盖了 $[l,r]$ 的染色，故必然存在一个位置 $l\le x<r$ 使得不存在一次左端点小于等于 $x$ 且右端点大于 $x$ 的染色，枚举这个 $x$ 即可。即 $f_{l,r}=\min\limits_{i=l}^{r-1}f_{l,i}+f_{i+1,r}$。

于是我们在 $O(n^3)$ 时间和 $O(n^2)$ 空间内完整解决了问题。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=50+5;
int n;
char s[maxn];
int f[maxn][maxn];
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=n;i>0;i--) for(int j=i;j<=n;j++){
		if(i==j) f[i][j]=1;
		else if(s[i]==s[j]) f[i][j]=f[i][j-1];
		else{
			f[i][j]=n;
			for(int k=i;k<j;k++)
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
		}
	}
	printf("%d\n",f[1][n]);
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：深海鱼的眼泪 (赞：78)

讲一下前面的题解没有细讲的一个点。

用$dp[i][j]$表示$i\ to\ j$段的最少涂色次数

$dp[i][i] = 1$

当$s[i]=s[j]$，即首尾颜色相同时，作如下思考：

对于任意的$x\ to\ y$段，涂的底色不同时，最少涂色次数相差不超过1（假设用A作底色涂色次数最少，为m，那用B作底色时最少涂色次数必定不超过m+1，即在以A为底色的底下再涂一层B）。

对于当前我们讨论的$i\ to\ j$段，假设$s[i]=s[j]=C$，我们先看$i+1\ to\ j-1$段（假如有的话），令$t=dp[i+1][j-1]$，则假设以C为底色，$i+1\ to\ j-1$段最少涂色次数为t或t+1。

假设为t，即以C为底色$i+1\ to\ j-1$段可以达到最少次数，那么只要在第一次涂的时候涂到i即可得$i\ to\ j-1$段，即$dp[i][j-1]\leq t=dp[i+1][j-1]$，


又$dp[i][j-1]\geq dp[i+1][j-1]$（不可能多了一段涂色次数反而变少）

即可得$dp[i][j-1]=dp[i+1][j-1]$，且此时是以C为底色取得的最小值，同理可得$dp[i][j]=dp[i][j-1]$

假设为t+1，即C不是$i+1\ to\ j-1$段涂底色的最优选，则$dp[i][j-1]=t+1$且C为底色

可以归纳得到，对于区间$x\ to\ y$，总有一种方法可以以s[x]为底色且取得最小值，右边同理。

回到$i\ to\ j$段，易知$dp[i][j]=dp[i][j-1]$，只要$i\ to\ j-1$段以C为底色，往右多涂一段。右边同理。事实上，$dp[i][j-1]=dp[i+1][j]$，所以这
里其实不需要取min。
后面的思路就是一样的了，$s[i]\neq s[j]$时，把区间分成两段，枚举断点。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
int main()
{
    int n, i, j, k, l, t, dp[60][60];
    char s[60];
    scanf("%s", s);
    n = strlen(s);
    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < 26; ++j)
        {
            dp[i][i] = 1;
        }
    }
    for (l = 1; l < n; ++l)
    {
        for (i = 0; i + l < n; ++i)
        {
            if (s[i] == s[i + l])
            {
                dp[i][i + l] = dp[i][i + l - 1];
            }
            else
            {
                dp[i][i + l] = dp[i][i] + dp[i + 1][i + l];
                for (k = i + 1; k < i + l; ++k)
                {
                    dp[i][i + l] = min(dp[i][i + l], dp[i][k] + dp[k + 1][i + l]);
                }
            }
        }
    }
    printf("%d", dp[0][n - 1]);
    return 0;
}

---

## 作者：luxiaomao (赞：34)

## [P4170](https://www.luogu.com.cn/problem/P4170) 区间 DP

## Problem

题意不难理解，给出长度为 $n$ 的序列，每次可以将任意一段区间覆盖上一种颜色，求将全空的序列转化为目标序列的最小步数。

## Solution

$n \le 50$，不难想到区间 DP。

首先我们想想可以把涂色过程归类为几种策略：

1. 先涂一个大区间，然后一个小区间包含在大区间内。

   ```
   AAABBBBAAA
   ```

2. 涂两个并列且没有交集的区间。（如果有交集会互相覆盖，又相当于没有交集了，所以不用考虑）

   ```
   AAAABBBB
   ```

那么用这两个策略，我们针对一个区间 $[l,r]$ 进行讨论：

- 如果 $l=r$，显然有初始化 $f_{l,r} = 1$。

- 如果 $s_l=s_r$，那么这个区间有可能使用策略一，那么有 $f_{l,r} = \min\{f_{l+1,r},f_{l,r-1}\}$。我们想象把第一步的大区间向外延伸一格即可，即可得到当前状态且不用新增步数。

- 无论 $s_l$ 和 $s_r$ 是否相等，都有可能使用策略二。我们用区间 DP 的常规操作，枚举一下断点即可。有 $f_{l,r} = \min\{f_{l,r},f_{l,i}+f_{i+1,r}\}(l \le i < r)$。

时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$。

## Code

```cpp
#include<bits/stdc++.h>
#define N 55
using namespace std;

int n;
char s[N];
int f[N][N];

int main()
{
	scanf("%s",s+1),n = strlen(s+1);
	memset(f,0x3f3f,sizeof f);
	for(int i = 1;i <= n;i++) 
	{
		f[i][i] = 1;
	}
	for(int k = 2;k <= n;k++)
	{
		for(int l = 1;l+k-1 <= n;l++)
		{
			int r = l+k-1;
			if(s[l] == s[r])f[l][r] = min(f[l+1][r],f[l][r-1]);
			for(int i = l;i < r;i++)
				f[l][r] = min(f[l][r],f[l][i]+f[i+1][r]);
		}
	}
	printf("%d\n",f[1][n]);
	return 0;
}
```

---

## 作者：AnnaQ (赞：23)

# 思路
看完题目后觉得懵了或者没思路了？不要急，静下来分析一下，直接从题目不太好入手，转换一下思路或许可以实现出来，我的思路非常与众不同，但是自认为很好理解，把一个空木板涂成指定的图案和把指定的图案涂成一种颜色，然后再涂一下是不是一样？理解不了的可以用样例在纸上模拟一下，就会发现它确实是这样的。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,dp[100][100];
string a;
int main()
{
	cin >> a;
	a = " " + a;//为了方便接下来使用
	n = a.length() - 1;//虽然再前面加了一个空格，但是实际的使用长度不变，所以要减一
	memset(dp,127,sizeof(dp));//因为一会儿要取min，所以先赋成一个极大值
	for(int i = 1;i <= n;i++)
	{
		dp[i][i] = 0;//左右节点一样肯定不用涂色
	}
	for(int i = 2;i <= n;i++)
	{
		for(int j = 1;j + i - 1 <= n;j++)
		{
			int k = j + i - 1;
			for(int l = j;l < k;l++)
			{
				dp[j][k]=min(dp[j][k],dp[j][l]+dp[l+1][k]+(a[j]!=a[k]));//状态转移方程，求最小的涂色次数。a[l]为中转的字符a[j]~a[l]为同一个颜色，a[l+1]~a[k]为同一个颜色，首先，肯定得把把a[j]~a[l]变成一个颜色的涂色次数（,dp[j][l]）和把a[l+1]~a[k]变成一个颜色的涂色次数（dp[l+1][k]）给加上，如果a[j]和a[k]的颜色不一样，那么还得把这一整段再给涂成一个颜色的涂色次数（1次）给加上，最后在和自己本身取一个min，就OK了
			}
		}
	}
	cout << dp[1][n] + 1 << endl;//还得再加一次，因为它是从啥都没有开始涂得，但是咱们却是从标准图案涂成了同一个颜色，所以还得再涂一次，如果不懂可以往上翻翻，翻到一开始的文字区，还不懂我就帮不了你了
	return 0;
}
```

---

## 作者：ISTP (赞：19)

## Getting Start

管理撤了没有证明的题解咳咳，试着抢一发。

现在想起来这题是当初 dp 入门的噩梦（）。

## 题意简述

[原题链接：https://www.luogu.com.cn/problem/P4170](https://www.luogu.com.cn/problem/P4170)

把宽为 $1$ 的白板刷成指定颜色最少要刷几次，每次刷的长度和位置任意，新颜色会覆盖在旧颜色上。

## 解题思路

~~看 tag 知区间 dp（doge）~~

刷子每次对一个区间的颜色造成影响，可以倒着考虑。

由小到大考虑每个区间，长为 $1$ 的区间显然只要刷 $1$ 次。长度大于 $1$ 的区间，就假设已经处理好了所有长度更小的区间的答案（dp 和记忆化搜索的精髓：从子问题最优解逐步推到全局最优解）。

对于该区间两端的颜色来说，如果这两个颜色相同，完全可以最先刷上这个颜色，从一端直接刷到该区间另一端，把两端之间的别的颜色放后面再刷，覆盖在区间上。

设 $dp_{l,r}$ 表示当区间左端点为 $l$，右端点为 $r$ 时，最少要刷多少次，该种情况即有转移：

$$dp_{l,r} = \min{dp_{l+1,r},dp_{l,r-1}}$$

如果该区间两端的颜色不同，没法一刷子搞定。枚举断点 $k$，把整个区间分成左右两部分，答案即为两部分花费之和的最小值：

$$dp_{l,r} = \min_{k=l}^{r-1}{dp_{l,k} + dp_{k+1,r}}$$

考虑正确性。证明不太严谨但可以意会。

两端颜色相同时比较显然，一刷到底和两端各刷一次相比，节省了一刷子的花费。

因为除了一刷到底也没有别的节省花费的方法了，两端颜色不同时，肯定至少要刷两次，同时希望区间里别的颜色花费尽量小，就枚举断点找最小花费和：还是从子问题最优推到全局最优。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 55;

string board;
int dp[maxn][maxn];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);

    cin >> board;
    int n = board.size();

    memset(dp, 0x3f, sizeof dp);
    for(int i = 0; i < n; i ++)
        dp[i][i] = 1; //这个初始化其实就是区间长为 1 的情况

    for(int len = 2; len <= n; len ++) //所以直接从 2 开始了
        for(int l = 0; l + len - 1 < n; l ++){
            int r = l + len - 1;
            if(board[l] == board[r])
                dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]);
            else
                for(int k = l; k < r; k ++)
                    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]);
        }

    cout << dp[0][n - 1] << '\n';

    return 0;
}
```

## Ending

完结撒花。如果有解释的不到位的地方欢迎评论提出。

希望所有刚接触区间 dp 的 OIer 们都能吃透这道题。

---

## 作者：zzy2333 (赞：9)

翻遍了题解区发现没有一篇题解跟我的做法一样。。。

不知道我的做法正确性如何，反正洛谷上AC了，这里仅供参考，也欢迎各位大佬hack。


------------
设$f[i][j][k] $表示从i到j，第一次填色为k的最少步数

于是有初始化：
```cpp
	memset(f,0x3f,sizeof(f));
	scanf("%s",s);
	n=strlen(s);
	for(int i=1;i<=n;i++){
		color[i]=s[i-1]-'A'+1;
		for(int j=1;j<=26;j++){
			if(j==color[i])f[i][i][j]=1;
			else f[i][i][j]=2;
		} 
	//	cout<<color[i]<<" ";
	}
//	cout<<endl;
```
枚举断点，如果两边第一次涂的颜色一样，显然可以一次把整个区间都涂了，步数--
```cpp
for(int len=2;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			for(int k=1;k<=26;k++){
				for(int t=i;t<j;t++){
					f[i][j][k]=min(f[i][j][k],f[i][t][k]+f[t+1][j][k]-1);
				}
			}
		}
	}
```
但是这样样例都过不了，原因很简单：我们可以先涂一个无关颜色，再涂要涂的颜色，然后就死了。

所以有改进代码：
```cpp
	for(int len=2;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			int minn=1e9;
			for(int k=1;k<=26;k++){
				for(int t=i;t<j;t++){
					f[i][j][k]=min(f[i][j][k],f[i][t][k]+f[t+1][j][k]-1);
				}
				minn=min(minn,f[i][j][k]);
			}
			for(int k=1;k<=26;k++){
				f[i][j][k]=min(f[i][j][k],minn+1);
			}
		}
	}
```
最后输出最小的$f[1][n][i] $即可

最后声明：以上做法不是最优，而且正确性并不显然。。。仅供参考

---

## 作者：TLE_AK (赞：6)

### 题意
给定一个颜色序列，每次可以选择一个区间涂上任意颜色（会覆盖），求最少多少次可得此颜色序列。
## 思路
我们可以对先后两次涂色所在的段进行分讨：  

- 对于两个不交的段，最好的方法便是直接涂上。
- 对于两个包含的段，一定是先涂长的再涂短的，因为如果先涂短的再涂长的，那么短的就被覆盖上了，浪费了一次涂色。
- 对于两次相交的段，我们可以转化为两个不交的段（如下图，数字为次数，颜色为涂的颜色）。  
![](https://cdn.luogu.com.cn/upload/image_hosting/bfta6kul.png)

所以我们发现：对于两个**最优**的涂色段，**要么包含要么不交**！并且包含的情况**无后效性**！

设 $dp_{l,r}$ 表区间 $[l,r]$ 至少涂多少次。

- 当 $l=r$ 时，有 $dp_{l,r}=1$。
- 当 $l<r$ 时，若 $col_l = col_r$ 则考虑包含的情况（因为不交会多出中间的代价，不如包含），我们可以等价于从 $[l,r-1]$ 延申出来一个 $col_i$ 所以有 $dp_{l,r}=dp_{l,r-1}$。
- 当 $l<r$ 时，若 $col_l \ne col_r$ 只能选不交的，易得 $dp_{l,r}=\min dp_{l,i}+dp_{i+1,r} (l \le i < r)$。
## 代码
```
#include <bits/stdc++.h>
using namespace std;

namespace akak
{
	char A[60];
	int dp[60][60];
	int main()
	{
		cin>>A+1;
		int len=strlen(A+1);
		for(int i=0;i<len;i++)
		{
			for(int j=1;j<=len-i;j++)
			{
				int r=j+i;
				if(i==0)dp[j][r]=1;
				else if(A[j]==A[r])dp[j][r]=min(dp[j+1][r],dp[j][r-1]);
				else 
				{
					dp[j][r]=1e9;
					for(int k=j;k<r;k++)
					{
						dp[j][r]=min(dp[j][r],dp[j][k]+dp[k+1][r]);
					}
				}
			}
		}
		
		cout<<dp[1][len];
		return 0;
	} 
}
int main()
{

	akak::main();
	return 0;
}


```

---

## 作者：Reanap (赞：6)

这道题大家都用区间$dp$就没有意思了，我给大家带来一个记忆化搜索的题解吧，希望大家喜欢。

我们把这个染色过程看做一个动态的挑选区间的过程，因此就有下面的引理。

引理：在最优染色方案中我们挑选一段区间进行染色，则这个区间的开头和结尾的染色都是目标颜色。

证明：反证法，如果不都是目标染色，那么缩小区间不会影响其最优性质，所以仍是最优方案。

因此，这个区间的开头和结尾都不会被再次覆盖了，这就被划分成了三个独立的子问题，这也就完成了在搜索中运用减治法对原问题的分解。

细节见代码：

```cpp

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
char s[205];
int dp[205][205][150];
int dfs(int l , int r , int co) { // 区间和当前被染成的颜色
	if(r < l) return 0;
	if(l == r) return s[l] != co;
	if(dp[l][r][co]) return dp[l][r][co];
	dp[l][r][co] = 1e9;
	int f = 0 , tot = 0;
	for (int i = l; i <= r; ++i) {
		if(s[i] == co) {
        tot ++;
        continue;
       }
		f = 1;
		for (int j = i; j <= r; ++j) {
			if(s[i] == s[j]) { // 如果开头和结尾一样，证明他们可能构成区间
				dp[l][r][co] = min(dp[l][r][co] , 1 + dfs(l , i - 1 , co) + dfs(i + 1 , j - 1 , s[i]) + dfs(j + 1 , r , co));
                //状态转移
			}
		}
	}
	if(dp[l][r][co] == 1e9) {
		if(!f) return dp[l][r][co] = 0; // 如果区间颜色完全与当前染成颜色一致
		else return dp[l][r][co] = r - l + 1 - tot;//否则一个一个染
	}
	return dp[l][r][co];
}
int main() {
	scanf("%s" , s + 1);
	printf("%d" , dfs(1 , strlen(s + 1) , 0));
	return 0;
}
```

---

## 作者：XXh0919 (赞：6)

一道区间 dp。

令 $dp_{i,j}$ 表示给区间 $[i,j]$ 染色的最小步数，所以 $dp_{i,i}$ 显然等于 $1$。那么当 $i<j$ 时：

- 当左端点 $i$ 的颜色和右端点 $j$ 的颜色相同时，也就是 $[i,j]$ 被完全覆盖，那么答案很明显是 $[i,j-1]$ 与 $[i+1,j]$ 中的最小值（有种线段树的感觉），即两段相交部分的最小值（因为不相交的话可能得不出正确答案）。
- 当左端点 $i$ 的颜色和右端点 $j$ 的颜色不同，也就是$[i,j]$ 没有被完全覆盖，那么说明 $[i,j]$ 覆盖了不止一次，那么就枚举 $[i,j]$ 里面的每一个点 $k$，答案就为 $dp_{i,j}$ 与 $dp_{i,k}+dp_{k+1,j}$ 中的最小值。

那么最终答案就为每一个 $[i,i+n-1]$ 的最小值。

可以根据代码理解。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+15,M=1e3+15;

char col[N];
int dp[M][M];

signed main(){
	scanf("%s",col+1);
	int lent=strlen(col+1);
	memset(dp,0x3f,sizeof dp);//记得初始化
	for(int len=1;len<=lent;++len){
		for(int l=1;l+len-1<=lent;++l){
			int r=l+len-1;
			if(len==1){
				dp[l][l]=1;
				continue;
			}
			if(col[l]==col[r]) dp[l][r]=min(dp[l+1][r],dp[l][r-1]);
			for(int k=l;k<=r;++k){
				dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]);
			}
		}
	}//区间 dp
	int minn=0x3f3f3f;
	for(int i=1;i<=lent;++i){
		minn=min(minn,dp[i][i+lent-1]);
	}
	printf("%lld\n",minn);
	return  0;
}
```

---

## 作者：z_yq (赞：4)

### 题意
题目是给你一种操作，这个操作就是把 $l \le i \le r$ 的 $a_i$ 全部变成同样的字母，求变成题目给定的序列的最少次数是多少。（原本的序列没有进行过一次操作）

### 思路
我们定义 $dp_{i,j}$ 表示其子序列 $a_{i,j}$ 要满足条件的操作次数，显而易见 $dp_{1,n}$ 就是我们的答案，而因为 $n \le 50$ 所以我们可以想到区间 dp，我们就会去推转移式子：

对于一个区间 $[l,r]$ 我们分两类，如果 $a_l = a_r$ 则我们可以从 $dp_{l+1,r}$ 和 $dp_{l,r-1}$ 中去转移，我们想怎么转移：如果两边的值相等，则我们总是涂了最左边**和**最右边的，而两个子状态都是图了最左边**或者**最右边的，所以：$dp_{l,r} = \min(dp_{l,r-1},dp_{l+1,r})$，我们考虑另一种情况如果 $a_i \neq a_j$，则我们使用普通的区间dp，寻找一个最小的 $k$ 即可，就此我们已经推出了转移式子了。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[509];
int n=1,dp[509][509];
int main()
{
	while(cin>>s[n]) n++;
	n--;
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=n;i++) dp[i][i]=1;
	for(int len=1;len<=n;len++)
		for(int l=1;l<=n;l++)
		{
			int r=l+len-1;
			if(s[l]==s[r])
				dp[l][r]=min(dp[l][r],min(dp[l+1][r],dp[l][r-1]));
			else 
				for(int i=l;i<r;i++)
					dp[l][r]=min(dp[l][r],dp[l][i]+dp[i+1][r]);
		}
	cout<<dp[1][n];
	return 0;
}
```

---

## 作者：xMinh (赞：4)

### 看到这个数据范围

### 就没有人第一感觉是$n^4$的复杂度么

用$f_{i,j}$表示把i到j这段区间涂满的最小步数

设第j个点的权值是val，那么我们可以看做是在i到j的区间内取若干个值为val的点，把这段区间分成几段，再把这几段的步数加起来再加一，就是$f_{i,j}$的值

于是我们可以设$g_k$表示i到j的区间里第k个值为val的点到j的区间内的最小步数，我们特殊处理以下使得第一个点为i-1，那么$f_{i,j}=g_1+1$即可

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 100
#define INF 1000000000
using namespace std;
int n,len,tot,st[N],g[N],a[N],f[N][N],nxt[N],pos[N];
char s[N];

int main() {
    cin>>(s+1);
    len=strlen(s+1);
    for (int i=1; i<=len; i++) {
        if (s[i]==s[i-1]) continue;
		a[++n]=s[i]-'A'+1;
        nxt[n]=pos[a[n]];
        pos[a[n]]=n;
    }
    for (int i=1; i<=n; i++) f[i][i]=1;
    for (int i=n; i>=1; i--)
        for (int j=i+1; j<=n; j++) {
            int x=j; tot=0;
            st[++tot]=j;
            while (nxt[x]>=i) {
            	x=nxt[x];
				st[++tot]=x;
			} 
			st[++tot]=i-1;
			reverse(st+1,st+tot+1);
			for (int k=1; k<=tot; k++) g[k]=INF;
			g[tot]=0;
			for (int k=tot; k>=1; k--)
				for (int l=k+1; l<=tot; l++)
					g[k]=min(g[k],f[st[k]+1][st[l]-1]+g[l]);
			f[i][j]=g[1]+1;
        }
    printf("%d",f[1][n]);
}
```

---

## 作者：qwerta (赞：3)

一种略微奇怪的思路2333

[更棒的阅读体验（逃](https://www.cnblogs.com/qwerta/p/9688214.html)

因为题目上两个一样的点可以隔一个大区间而算作一次涂色，所以干脆**枚举中间隔的大区间**。

设F[L][R]为把[L,R]画完所需的最少次数，初始化F[i][j]=(j-i+1)，表示暴力的一格格涂。

   转移时，在[L,R]上枚举两个断点（L',R'），表示在[L,R]上直接覆盖一个区间[L',R']。
   
   .

   一开始让F[L][R]=F[L][L'-1]+F[L'][R']+F[R'+1][R]，表示把大区间视为三个小区间，不在乎他们边界可能有缘。

       如果L'上的颜色和L'-1相同，那么可以少画一次；
       如果R'上的颜色和R'+1相同，那么可以少画一次；
       如果L'-1上的颜色和R'+1上相同，那么又可以少画一次。

   最后注意一下，因为假设在[L,R]上涂一层时，就算证明了这一层完全融入背景色，也不可能给原区间一个-1的buff，所以最多只能少画两次。

   答案在F[1][n]。
   
   
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s[53];
int f[53][53];
int chek(int i,int j)
{
    if(s[i]==s[j])return 1;//相同就可以少画一笔
    else return 0;
}
int main()
{
    //freopen("a.in","r",stdin);
    cin>>s;
    int n=strlen(s);
    for(int i=n;i;--i)
    s[i]=s[i-1];
    for(int i=1;i<=n;++i)
    for(int j=i;j<=n;++j)
    f[i][j]=(j-i+1);//预处理
    for(int len=2;len<=n;++len)
    for(int l=1,r=len;r<=n;++l,++r)
    {
        for(int ll=l;ll<=r;++ll)
        for(int rr=ll;rr<=r;++rr)//枚举区间
        {
        int k=f[l][ll-1]+f[rr+1][r]+f[ll][rr],g=0;
        if(ll-1>=l)g+=chek(ll-1,ll);//左边界融入背景(///v///)
        if(rr+1<=r)g+=chek(rr,rr+1);//右边界融入背景(///v///)
        if(ll-1>=l&&rr+1<=r)g+=chek(ll-1,rr+1);//左右边界是一样哒！(>w<)
        k-=min(g,2);//最多只能少画两笔QAQ
        f[l][r]=min(f[l][r],k);
        }
    }
    cout<<f[1][n];
    return 0;
}
```

---


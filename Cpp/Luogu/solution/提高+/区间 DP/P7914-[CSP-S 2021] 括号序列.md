# [CSP-S 2021] 括号序列

## 题目描述

小 w 在赛场上遇到了这样一个题：一个长度为 $n$ 且符合规范的括号序列，其有些位置已经确定了，有些位置尚未确定，求这样的括号序列一共有多少个。

身经百战的小 w 当然一眼就秒了这题，不仅如此，他还觉得一场正式比赛出这么简单的模板题也太小儿科了，于是他把这题进行了加强之后顺手扔给了小 c。

具体而言，小 w 定义“超级括号序列”是由字符 `(`、`)`、`*` 组成的字符串，并且对于某个给定的常数 $k$，给出了“符合规范的超级括号序列”的定义如下：

1. `()`、`(S)` 均是符合规范的超级括号序列，其中 `S` 表示任意一个仅由**不超过** $\bm{k}$ **个**字符 `*` 组成的非空字符串（以下两条规则中的 `S` 均为此含义）；
2. 如果字符串 `A` 和 `B` 均为符合规范的超级括号序列，那么字符串 `AB`、`ASB` 均为符合规范的超级括号序列，其中 `AB` 表示把字符串 `A` 和字符串 `B` 拼接在一起形成的字符串；
3. 如果字符串 `A` 为符合规范的超级括号序列，那么字符串 `(A)`、`(SA)`、`(AS)` 均为符合规范的超级括号序列。
4. 所有符合规范的超级括号序列均可通过上述 3 条规则得到。

例如，若 $k = 3$，则字符串 `((**()*(*))*)(***)` 是符合规范的超级括号序列，但字符串 `*()`、`(*()*)`、`((**))*)`、`(****(*))` 均不是。特别地，空字符串也不被视为符合规范的超级括号序列。

现在给出一个长度为 $n$ 的超级括号序列，其中有一些位置的字符已经确定，另外一些位置的字符尚未确定（用 `?` 表示）。小 w 希望能计算出：有多少种将所有尚未确定的字符一一确定的方法，使得得到的字符串是一个符合规范的超级括号序列？

可怜的小 c 并不会做这道题，于是只好请求你来帮忙。

## 说明/提示

**【样例解释 #1】**

如下几种方案是符合规范的：

```plain
(**)*()
(**(*))
(*(**))
(*)**()
(*)(**)
```

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 3$ | $15$ | 无 |
| $4 \sim 8$ | $40$ | 无 |
| $9 \sim 13$ | $100$ | 无 |
| $14 \sim 15$ | $500$ | $S$ 串中仅含有字符 `?` |
| $16 \sim 20$ | $500$ | 无 |

对于 $100 \%$ 的数据，$1 \le k \le n \le 500$。

## 样例 #1

### 输入

```
7 3
(*??*??
```

### 输出

```
5
```

## 样例 #2

### 输入

```
10 2
???(*??(?)
```

### 输出

```
19
```

## 样例 #3

### 输入

```
见附件中的 bracket/bracket3.in```

### 输出

```
见附件中的 bracket/bracket3.ans```

## 样例 #4

### 输入

```
见附件中的 bracket/bracket4.in```

### 输出

```
见附件中的 bracket/bracket4.ans```

# 题解

## 作者：enucai (赞：857)

一篇不需要处理算重的题解

## 前言

~~作者是一个考场上没推出来的蒟蒻~~

看了一下现在已经有的3篇题解，都是要用两个dp数组或者要复杂地处理算重方案的，但是蒟蒻太菜，不想推这么复杂的，于是在赛后参考了@[wdssean](https://www.luogu.com.cn/user/34225)的思路，写了这一篇题解。个人觉得自己的思路还是蛮清晰的。

## 思路简述

首先肯定是区间dp，令 $dp_{i,j}$ 表示从位置 $i$ 到位置 $j$ 一共的合法序列总情况数量。

但是不同的形态可能会有不同的转移，如：`(S)`这种只能从`S`转移过来等等。所以只开两维的dp状态必然是不够的。

直接将方法吧。将两位的dp扩充为三维，第三位表示不同的形态种类，dp状态就变成了 $dp_{i,j,[0,5]}$。没种状态表示：

- $dp_{i,j,0}$: 形态如`***...*`的括号序列（即全部是`*`）。

- $dp_{i,j,1}$: 形态如`(...)`的括号序列（即左右直接被括号包裹且最左边括号与最右边的括号相互匹配）。

- $dp_{i,j,2}$: 形态如`(...)**(...)***`的括号序列（即左边以括号序列开头，右边以`*`结尾）。

- $dp_{i,j,3}$: 形态如`(...)***(...)*(...)`的括号序列（即左边以括号序列开头，右边以括号序列结尾，注意：第2种形态也属于这种形态）。

- $dp_{i,j,4}$: 形态如`***(...)**(...)`的括号序列（即左边以`*`开头，右边以括号序列结尾）。

- $dp_{i,j,5}$: 形态如`***(...)**(...)**`的括号序列（即左边以`*`开头，右边以`*`结尾，注意：第1种形态也属于这种形态）。

设定完状态以后，转移就直接出来了，注意：为了防止连续超过 $k$ 个`*`一起出现，转移的时候不能把两段`*`拼接起来，在状态1的时候暴力判断一下两端的距离是否是 $\le k$ 的，是的才能转移。

作为一篇题解，转移虽然很简单，但是好得说一下吧。

- $dp_{l,r,0}$（直接特判）

- - 没什么好解释的

- $dp_{l,r,1}=(dp_{l+1,r-1,0}+dp_{l+1,r-1,2}+dp_{l+1,r-1,3}+dp_{l+1,r-1,4})*compare(l,r)$

- - $compare(i,j)$ 表示第 $i$ 位与第 $j$ 位能否配对成括号，能则为 $1$，否则为 $0$。
- - 加括号时，里面可以是全`*`，可以是有一边是`*`，也可以是两边都不是`*`，唯独不能两边都是`*`且中间有括号序列。

- $dp_{l,r,2}=\sum\limits_{i=l}^{r-1} dp_{l,i,3}\times dp_{i+1,r,0}$
- - 左边以括号序列开头且以括号序列结尾的是第3种，右边接一串`*`，是第0种。

- $dp_{l,r,3}=\sum\limits_{i=l}^{r-1} (dp_{l,i,2}+dp_{l,i,3})\times dp_{i+1,r,1}+dp_{l,r,1}$
- - 左边以括号序列开头，结尾随便，符合的有第2和第3种，右边接一个括号序列，是第1种。
- - 记得加上直接一个括号序列的。

- $dp_{l,r,4}=\sum\limits_{i=l}^{r-1} (dp_{l,i,4}+dp_{l,i,5})\times dp_{i+1,r,1}$
- - 左边以`*`开头，结尾随便，符合的有第4和第5种，右边接一个括号序列，是第1种。

- $dp_{l,r,5}=\sum\limits_{i=l}^{r-1} dp_{l,i,4}\times dp_{i+1,r,0}+dp_{l,r,0}$
- - 左边以`*`开头，以括号序列结尾，符合的是第4种，右边接一串`*`，是第0种。
- - 记得加上全是`*`的。

最后，答案必须以括号序列开头，以括号序列结尾，所以直接是 $dp_{1,n,3}$。

这样，初始状态也就没什么问题了，对于所有的 $i$ 满足 $1\le i \le n$，有 $dp_{i,i-1,0}=1$ 。

最终时间复杂度 $O(6\times n^3)$ 不到，（后半部分填不满 $n^3$ ）。

记得开long long，并且取模。

## 代码示范

**Talk is cheap, show me the code.**

~~代码挺短的，去掉文件头才28行。~~

```cpp
#define int long long
#define mod 1000000007
int n,k,dp[510][510][6];
char s[510];
bool compare(int a,int b) {return (s[a]=='('||s[a]=='?')&&(s[b]==')'||s[b]=='?');}
signed main(){
    n=read(),k=read();
    scanf("%s",s+1);
    For(i,1,n) dp[i][i-1][0]=1;
    For(len,1,n){
        For(l,1,n-len+1){
            int r=l+len-1;
            if(len<=k) dp[l][r][0]=dp[l][r-1][0]&&(s[r]=='*'||s[r]=='?');
            if(len>=2){
                if(compare(l,r)) dp[l][r][1]=(dp[l+1][r-1][0]+dp[l+1][r-1][2]+dp[l+1][r-1][3]+dp[l+1][r-1][4])%mod;
                For(i,l,r-1){
                    dp[l][r][2]=(dp[l][r][2]+dp[l][i][3]*dp[i+1][r][0])%mod;
                    dp[l][r][3]=(dp[l][r][3]+(dp[l][i][2]+dp[l][i][3])*dp[i+1][r][1])%mod;
                    dp[l][r][4]=(dp[l][r][4]+(dp[l][i][4]+dp[l][i][5])*dp[i+1][r][1])%mod;
                    dp[l][r][5]=(dp[l][r][5]+dp[l][i][4]*dp[i+1][r][0])%mod;
                }
            }
            dp[l][r][5]=(dp[l][r][5]+dp[l][r][0])%mod;
            dp[l][r][3]=(dp[l][r][3]+dp[l][r][1])%mod;
        }
    }
    printf("%lld\n",dp[1][n][3]);
}
```

都看到这里了，点个赞再走呗qwq。

---

## 作者：I_am_Accepted (赞：167)

Upd 2022-1-26：更新了 LaTeX 和标题层级。（更好的阅读体验 OvO）

# Preface

感觉比 T3 难好多 qwq。

纪念我考场上写错的 $O(n^3)$ 区间 DP（边界条件没判 qwq）。

本文半数讲思路过程，所以本题解可能稍长，但最终得出的结论和公式是简洁滴~（大佬们可以直接跳转至 Algorithm 或 Code 部分）

# Analysis

这括号序列题一般是区间 DP。

单纯的想法是设 $dp_{l,r}$ 为 $[l,r]$ 这段子串为合法超级括号序列的方案数。

但这样有问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/dqn9y54t.png)

（$A,B,C,D,E$ 均为合法超级括号序列，$S$ 为题面中定义）

如图，此种情况会算两遍。

# Improve

设 $f_{l,r}$ 表示 $[l,r]$ 这段子串为合法超级括号序列**且两端（$l$ 和 $r$）的括号匹配**（$\mathtt{integral}$）的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/adb4xxzv.png)

设 $g_{l,r}$ 表示 $[l,r]$ 这段子串为合法超级括号序列**且两端（$l$ 和 $r$）的括号不匹配**（$\mathtt{separated}$）的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/sul4mzmf.png)

这样就能有效避免重复算的情况。

# Algorithm

区间 DP 基本：**按照子串长度从小到大枚举**。

设现在遍历到 $f_{l,r}$ 和 $g_{l,r}$，$len=r-l+1$。

设 $(bool)X_{l,r}$ 表示 $[l,r]$ 是（$1$）否（$0$）全为 `'*'` 和 `'?'`（$O(n^2)$ 预处理）。

（设原字符串为 $s$，从 $1$ 标号，与 DP 数组对齐）

## （一）特判


若 $s_l$ **不能成为** `'('` 或 $s_r$ **不能成为** `')'`，直接 `continue` 掉。

若 $len=2$，直接 $f_{l,r}=1$，`continue` 掉。

## （二） $\mathtt{integral}$

### (S)

$$f_{l,r}+=[X_{l+1,r-1}=true]$$

### (A)

$$f_{l,r}+=f_{l+1,r-1}+g_{l+1,r-1}$$

### (SA)

$$f_{l,r}+=\sum\limits^{k}_{i=1}(f_{l+i+1,r-1}+g_{l+i+1,r-1})[X_{l+1,l+i}=true]$$

### (AS)

$$f_{l,r}+=\sum\limits^{k}_{i=1}(f_{l+1,r-i-1}+g_{l+1,r-i-1})[X_{r-i,r-1}=true]$$

## （三） $\mathtt{separated}$

### ASB & AB

这部分比较麻烦，容易算重，需要谨慎。

我们规定 $B$ 为 $\mathtt{integral}$ 子串，这样就不重不漏了。

$$g_{l,r}+=\sum\limits_{l<i<j<r,j-i-1\leqslant k}((f_{l,i}+g_{l,i})\times f_{j,r})[X_{i+1,j-1}=true]$$

（规定 $X_{a,a-1}=true$）

# Optimization

发现 **ASB & AB** 部分为 $O(n^4)$，而你的愿望是 AK CSP-S 2021，怎么办呢？

思考：上面柿子中若 $i$ 增减 $1$ 则**可取的 $j$ 的范围变化量为 $O(1)$**。

优化成 $O(n^3)$。

为防止思维固化，请读者自行思考优化的具体方式（很简单的 DP 优化，若真不会则看代码）。

# Code

别忘了取模。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
#define ckmx(a,b) if(a<b){a=b;}
#define N 510
#define madd(a,b) a=(a+b%mod)%mod;
const ll mod=1000000007;
char s[N];
int n,k,R;
ll f[N][N],g[N][N],tmp,cur[N];
int id,nxt[N];
bool X[N][N];
signed main(){
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	For(l,1,n) For(r,l,n) X[l][r]=0;
	For(l,1,n){
		if(s[l]!='?' && s[l]!='*') continue;
		X[l][l]=1;
		For(r,l+1,n){
			if(s[r]=='?' || s[r]=='*'){
				X[l][r]=1;
			}
			else break;
		}
	}
	For(len,2,n){
		int r;
		For(l,1,n-len+1){
			r=l+len-1;
			f[l][r]=g[l][r]=0;
			if((s[l]!='(' && s[l]!='?') || (s[r]!=')' && s[r]!='?'))
				continue;
			if(l+1==r){
				madd(f[l][r],1);
				continue;
			}
			//integral
			if(r-l-1<=k && X[l+1][r-1]){
				madd(f[l][r],1);
			}
			madd(f[l][r],f[l+1][r-1]+g[l+1][r-1]);
			For(l1,l+1,min(r-2,l+k))//记得取 min，我考试挂在这 
				if(X[l+1][l1])
					madd(f[l][r],f[l1+1][r-1]+g[l1+1][r-1]);
			Rof(r1,r-1,max(l+2,r-k))//记得取 max，我考试挂在这 
				if(X[r1][r-1])
					madd(f[l][r],f[l+1][r1-1]+g[l+1][r1-1]);
			//separated
			id=0;
			For(i,l+1,r-2){
				if(id<=i) id=i+1;
				while((s[id]=='*' || s[id]=='?') && id<r-1) id++;
				nxt[i]=min(i+k+1,id);
			}
			tmp=0;
			For(j,l+2,nxt[l+1]){
				madd(tmp,f[j][r]);
			}
			madd(g[l][r],(f[l][l+1]+g[l][l+1])%mod*tmp);
			For(i,l+2,r-2){
				madd(tmp,mod-f[i][r]);
				For(j,nxt[i-1]+1,nxt[i]) madd(tmp,f[j][r]);
				madd(g[l][r],(f[l][i]+g[l][i])%mod*tmp);
			}
		}
	}
	printf("%lld\n",(f[1][n]+g[1][n])%mod);
	return 0;
}
```

---

## 作者：_bestow (赞：58)

赤裸裸的区间dp。设 $f[l,r]$ 区间 $[l,r]$ 可以形成多少合法串。根据题目条件得知合法串两边都必须是括号，且左边一定是左括号，右边一定是右括号。

第一种 $(S)$ 的情况，直接扫一遍 $O(n)$。然后考虑 $(A),(SA),(AS)$。第一种从 $[l+1,r-1]$ 转移，剩下的扫一遍，从 $f[i+1,r-1],f[l+1,i-1]$ ，其中 $s[l+1,i],s[i,r-1]$ 是 $S$， 转移，复杂度 $O(n)$。

最后一种考虑枚举断点，转移方程大概是 $f[l,i]\times f[j,r]$，$s[i+1,j-1]$ 是 $S$。随便前后缀和优化一些也可以做到 $O(n)$。

但是这样会算重，考虑 $(**)()*()$，会在每个断点处算一次，那么根据套路，直接让他在第一个断点被计算。

考虑给 dp 加一维状态，$f[i,j,0/1]$ 分别代表能或不能使用最后一种转移，那么 $f[l,i,0]\times f[j,r,1]$ 转移即可。

---

## 作者：比利♂海灵顿 (赞：45)

# CSP-S 2021 括号序列

这道题考场杀我 $2.5h$，写了两个错误算法，最后写了一个 $O(n^4)$，然后优化成 $O(n^3)$ 了。

## 题意

一开始读错题了，写了一个多小时的错解。当时以为只要括号都匹配，`*` 在哪里无所谓，只要连续的不超过 $k$ 就可以。

所以请务必好好读题，接下来解释一下题意，并且引出解题所需的定义:

如果有一个合法序列，这个序列左右两个端点是一对互相匹配的括号，将整个序列括起来，我们称之为 "完全合法序列"。也就是题目中，第三种情况的合法序列。

那么本题中合法情况可以这样描述:

由若干完全合法序列组成，相邻的完全合法序列之间可以有不超过 $k$ 个 `*` 分隔。

那么根据本题的要求，合法的序列的左端或右端加上不超过 $k$ 个 `*`，然后在外面加一对括号，就得到了一个完全合法序列。(特别注意，左右不能同时加，但是可以都不加)

特别地，在不超过 $k$ 个 `*` 外直接加括号也是完全合法序列。

## $O(n^4)$ DP

> 这里 $k$ 作为循环枚举的变量，所以用 $m$ 表示题目中要求最多的连续的 `*` 的数量。

我们设计状态 $f_{Len, i}$ 表示以 $i$ 为左端点，长度为 $Len$ 的区间为完全合法序列的方案数，$g_{Len, i}$ 表示以 $i$ 为左端点，长度为 $Len$ 的区间为合法序列的方案数。

首先发现任何合法的序列，其左右两端一定分别是 `(` 和 `)`，所以当输入序列左端点是 `*` 或 `)` 或右端点是 `*` 或 `(` 时，两个值都为 $0$。

两端点合法后，考虑转移:

$$
f_{Len, i} = g_{Len - 2, i + 1} + \sum_{j = 1}^{min(Len - 2, m)} g_{Len - 2 - j, i + 1 + j} + \sum_{k = 1}^{min(Len - 3, m)}g_{Len - 2 - k, i + 1}
$$

第一个转移表示直接在合法序列外加括号，第二个和第三个表示在合法序列的左边或右边加若干 `*` 后再加括号。

其中 $j$ 枚举过程中需要考虑区间 $[i + 1, i + j]$ 必须都是 `*` 或 `?`，否则直接 `break`。$k$ 也是一样的，枚举过程中判断当前位置是否可以变成 `*`。

至于为什么 $k \leq min(Len - 3, m)$，因为对于 $j = Len - 2$ 的情况，表示的是直接在连续的 `*` 外面加括号，如果 $k = Len - 2$ 再统计一次，就会重复统计。

接下来是 $g$ 的转移:

$$
g_{Len, i} = \sum_{j = 0}^{Len - 2} (g_{j, i} * \sum_{k = 0}^{min(Len - j - 2, m)} f_{Len - j - k, i + j + k})
$$

这里的转移表示先选一个长度为 $j$ 的合法序列 $[i, i + j - 1]$，然后在它后面加 $k$ 个 `*`，后面再接一个长度 $Len - j - k$ 的完全合法序列，组成一个新的合法序列。

当然，这里枚举 $k$ 的时候也要判断对应位置是否能赋成 `*`，否则 `break`。

枚举边界两个 $-2$ 是因为完全合法序列最短也要 $2$，所以要提前留至少两个长度给最后的完全合法序列。

答案便是 $g_{n, 1}$。

两个 DP 状态都是 $O(n^2)$，$f$ 的转移是 $O(n)$，$g$ 的转移是 $O(n^2)$，总复杂度 $O(n^4)$。

复杂度里面有一个 $n$ 是和连续的 `*` 的数量有关的，所以随机数据下 $O(n^4)$ 跑 $500$ 飞快。

## 优化到 $O(n^3)$

发现算法的瓶颈在于转移 $g$ 的时候，枚举中间的 `*` 的数量。

这时候，增加一个状态 $g_{Len, i, 0}$ 表示的信息和之前的 $g$ 相同，加一个 $g_{Len, i, 1}$ 表示这个区间内，除去右端的 $(0, m]$ 个 `*`，左边留下的是非空的合法序列的方案数。

这个状态不是一般的好求

$$
g_{Len, i, 1} = \sum_{j = 1}^{min(Len - 2, m)} g_{Len - j, i, 0}
$$

转移意义为在合法序列后加 $j$ 个 `*`。

这个 $j$ 枚举时仍要判断对应位置是否能取 `*`，否则 `break`。

然后就可以把 $g_{Len, i, 0}$ 的转移优化到 $O(n)$。

$$
g_{Len, i, 0} = \sum_{j = 0}^{Len - 2} ((g_{j, i, 0} + g_{j, i, 1}) *  f_{Len - j, i + j}))
$$

转移表示合法序列还是合法序列后加 $(0, m]$ 个 `*`，这些情况后面加完全和法序列，一定能得到合法序列。

总复杂度优化到了 $O(n^3)$。

而且这时 $f$ 的转移也简化了。

$$
f_{Len, i} = g_{Len - 2, i + 1, 0} + g_{Len - 2, i + 1, 1} + \sum_{j = 1}^{min(Len - 2, m)} g_{Len - 2 - j, i + 1 + j, 0} 
$$

接下来是去掉缺省源的考场代码:

```cpp
unsigned long long Mod(1000000007);
unsigned long long f[505][505], g[505][505][2];
unsigned n, m;
unsigned A, B, C, D;
unsigned Cnt(0), Ans(0), Tmp(0);
char a[505];
signed main() {
  n = RD(), m = RD();
  scanf("%s", a + 1);
  for (unsigned i(n); i; --i) g[0][i][0] = f[0][i] = 1;
  for (unsigned Len(2); Len <= n; ++Len) {
    for (unsigned i(n - Len + 1); i; --i) {
      for (unsigned len(1); len < Len && len <= m; ++len) {
        if((a[i + Len - len] == '(') || (a[i + Len - len] == ')')) break;
        g[Len][i][1] += g[Len - len][i][0];
        if(g[Len][i][1] >= Mod) g[Len][i][1] -= Mod;
      }
      if((a[i] == '*') || (a[i] == ')') || (a[i + Len - 1] == '*') || (a[i + Len - 1] == '(')) {
        continue;
      }
      unsigned Tol(min(Len - 2, m));
      f[Len][i] = g[Len - 2][i + 1][0] + g[Len - 2][i + 1][1];
      if(f[Len][i] >= Mod) f[Len][i] -= Mod; 
      for (unsigned len(1); len <= m && len + 2 <= Len; ++len) {
        if((a[i + len] == '(') || (a[i + len] == ')')) break;
        f[Len][i] += g[Len - 2 - len][i + len + 1][0]; 
        if(f[Len][i] >= Mod) f[Len][i] -= Mod; 
      }
      g[Len][i][0] = f[Len][i];
      for (unsigned len(2); len + 2 <= Len; ++len) {
        g[Len][i][0] = (g[Len][i][0] + g[len][i][1] * f[Len - len][i + len]) % Mod;
      }
      for (unsigned len(2); len + 2 <= Len; ++len) {
        g[Len][i][0] = (g[Len][i][0] + g[len][i][0] * f[Len - len][i + len]) % Mod;
      }
    }
  }
  printf("%llu\n", g[n][1][0]);
	return 0;
}
```

---

## 作者：Asrit (赞：31)

## 原题链接：[[CSP-S 2021] 括号序列](https://www.luogu.com.cn/problem/P7914)

本题解思路十分暴力。

## Semi-formed Idea

根据题目描述，符合要求的括号序列可以分成两类

1. 包含型： $(),(A),(S),(AS),(SA)$
2. 并列型： $AA,ASA$

于是我们就可以开始逐一枚举这几种情况并统计答案了！

对于 $(),(A)$ 和 $(S)$ ，我们可以直接进行判断。

对于 $(AS),(SA),AA$ 和 $ASA$ ，我们可以枚举一个断点，把中间的地方拆成两部分（对于 $ASA$ ，拆成 $A$ 和 $SA$ 两部分，同时维护一下 $SA$ ，便只需枚举一个断点就可以计算答案贡献了）。

这样我们在程序中需要枚举左断点 $l$ 与右端点 $r$ ，维护 $S[l][r],A[l][r],SA[l][r]$ （ $S[l][r]$ 表示 $[l,r]$ 这一段符合 $S$ 的方案数，其它两个同理）就可以算出答案了！

时间复杂度为 $O(n^3)$ （枚举 $l$ 一个 $n$ ，枚举 $r$ 一个 $n$ ，枚举断点一个 $n$ ）。

## Hack and Debug

这样打的话会激动地发现只有第一个样例$AC$了。

原因如下：

我们处理并列型的时候，是枚举在 $[l,r]$ 中的断点进行判断的，但是当我们遇到这样的序列：

$()()()$

在$2,3$之间断开会发现 $[1,2]$ 符合 $A$ ， $[3,6]$ 符合 $A$ ；

在$4,5$之间断开会发现 $[1,4]$ 符合 $A$ ， $[5,6]$ 符合 $A$ ；

于是这一个串就贡献了两次答案。

$ASA$ 同理，例如 $() * () * ()$ 以同样的方法统计也会贡献两次答案。

那我们该解决呢？

我们可以在枚举 $AA$ 的断点的时候，判断前一个 $A$ 为全部的符合要求的 $A$ ，而后一个 $A$ 为包含型的 $A$ （之后我们称包含型 $A$ 为 $\_A$ ），即 $A\_A$ 。

我们来模拟一遍：

$()()()$

当我们在 $2,3$ 之间断开的话， $[1,2]$ 符合 $A$ ，但 $[3,6]$ 不符合 $\_A$ ；

当我们在 $4,5$ 之间断开的话， $[1,4]$ 符合 $A$ ， $[5,6]$ 符合 $\_A$ ，计入一次贡献；

这样这个串就只贡献了一次答案，符合要求。

更多的 $()$ 同样只会贡献一次答案， $ASA$ 转化为 $AS\_A$ 后也同样只会贡献一次了。

可能有同学要问了，为什么不需要排除 $\_A$ 呢？

原因很好想，因为 $\_A$ 从中间断开后就不是合法的括号序列了，因此不会被重复计算贡献。

于是，我们产生贡献的括号序列就变成了这些： $(),(S),(A),(AS),(SA),A\_A,AS\_A$ 。

需要维护的数组有： $S[l][r],A[l][r],\_A[l][r],S\_A[l][r]$ 。

## Code

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define rop(i,a,b) for(int i=(a);i<(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define por(i,a,b) for(int i=(a);i>(b);i--)
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
ll n,k,S[502][502],A[502][502],_A[502][502],S_A[502][502];
char s[502];

bool isl(char c) {return c=='('||c=='?';}//判断该字符是否是/能填上(
bool isr(char c) {return c==')'||c=='?';}//判断该字符是否是/能填上)
bool isx(char c) {return c=='*'||c=='?';}//判断该字符是否是/能填上*

int main(){
	scanf("%lld%lld%s",&n,&k,s+1);
	rep(l,1,n){//预处理S[l][r]
		if(!isx(s[l])) continue;//不是*则枚举下一个l
		S[l][l]=1;
		rep(r,l+1,min(n,l+k-1)){//最多连续k个*，同时不能越界
			if(!isx(s[r])) break;//如果s[r]不是*，再往后就一定构不成连续的*
			S[l][r]=1;
		}
	}
	per(l,n-1,1){
		rep(r,l+1,n){
			if(r-l==1){//l与r连着，[l,r]只有作为()才能产生贡献
				if(isl(s[l])&&isr(s[r])) A[l][r]=_A[l][r]=1;//判断[l,r]是否为()
				continue;
			}
			if(isl(s[l])&&isr(s[r])){//判断外层()
				A[l][r]+=S[l+1][r-1],A[l][r]%=mod;//(S)
				A[l][r]+=A[l+1][r-1],A[l][r]%=mod;//(A)
				rop(i,l+1,r-1) A[l][r]+=S[l+1][i]*A[i+1][r-1]%mod,A[l][r]%=mod;//(SA)
				rop(i,l+1,r-1) A[l][r]+=A[l+1][i]*S[i+1][r-1]%mod,A[l][r]%=mod;//(AS)
			}
			_A[l][r]=A[l][r];//此时包含型情况的枚举完毕，_A[l][r]==此时的A[l][r]
			rop(i,l,r) S_A[l][r]+=S[l][i]*_A[i+1][r]%mod,S_A[l][r]%=mod;//维护S_A
			rop(i,l,r) A[l][r]+=A[l][i]*_A[i+1][r]%mod,A[l][r]%=mod;//A_A
			rop(i,l,r) A[l][r]+=A[l][i]*S_A[i+1][r]%mod,A[l][r]%=mod;//AS_A
		}
	}
	printf("%lld",A[1][n]);
	return 0;
}
```

PS：题解撰写人名字叫AS，但在考场上这道题爆0了，悲。

---

## 作者：BMTXLRC (赞：27)

~~不要试着拿这道题的暴力分。~~

#### 状态的设置

看了题面，我们发现有三个变量：长度，左端点，星号个数，那我们先不妨开三维的 DP 数组 $dp_{i,j,k}$，表示填满区间 $[i,j]$，这里面有 $k$ 个星号的方案数。经过一番推导，我们能得出两个结论：

- 时间复杂度高达 $\mathcal{O}(n^6)$。
- 完全没必要加上第三维。

那我们想办法消掉第三维，用 $dp_{i,j}$ 表示填满区间 $[i,j]$ 的方案数，我们暂且认为这是正确的，并进行接下来的推导。

#### 状态转移方程初版

挨个情况的考虑，这里设 $\text{condition}_{l,r}$ 表示区间 $[l,r]$ 是否全部为星号，如果是则返回 $1$，否则返回 $0$。

- $\texttt {(S)}$：只需要查看一段 $[i,j]$ 是否全为星号或问号，便可以在这两端加上一对括号（假如两端是括号的话）。

设当前区间为 $[l,r]$，那么我们要满足的条件是 $s_l=\tt ?$ 或者 $s_l=\tt ($，$s_r=\tt ?$ 或者 $s_r=\texttt {)}$，其边界条件是 $r-l\geqslant 2$，同时中间一段必须全部为星号或问号。则状态转移方程是：
$$
dp_{l,r}=\text{condition}_{l+1,r-1}
$$

- $\texttt{(A)}$：只需要查看这一段 $[i,j]$ 为合法括号序列的数量，$l,r$ 条件跟上面一样，则状态转移方程是：

$$
dp_{l,r}=dp_{l+1,r-1}
$$

- $\texttt{(SA)}$：可以枚举断点 $p$，使得 $[l+1,p]$ 全为星号或问号，且 $[p+1,r-1]$ 有合法括号序列。可以观察 $p$ 所满足的范围：$p-(l+1)+1\leqslant k$，根据这个确定 $p$ 的 `for` 循环范围，可以写出状态转移方程：

$$
dp_{l,r}=dp_{p+1,r-1}\times\text{condition}_{l+1,p}
$$

- $\texttt{(AS)}$：跟上面情况同理，但我们还是有必要求出 $p$ 的范围：$r+1-(p+1)+1\leqslant k$，写出状态转移方程如下：

$$
dp_{l,r}=dp_{l+1,p}\times\text{condition}_{p+1,r-1}
$$

- $\texttt{AB}$：我们可以直接考虑断点 $p$，作为括号序列的分割线，有状态转移方程如下：

$$
dp_{l,r}=dp_{l,p}\times dp_{p+1,r}
$$

- $\texttt{ASB}$：需要枚举断点 $p,q$，满足 $[l,p],[q+1,r]$ 为合法括号序列，$[p+1,q]$ 为合法星号序列，有：

$$
dp_{l,r}=dp_{l,p}\times dp_{q+1,r}\times \text{condition}_{p+1,q}
$$

写完这些我们有两个问题：

- 我们的算法真的正确吗？
- 如何求出 $\text{condition}$？

对于第一个问题，样例 $2$ 会告诉我们并不正确，比如 $\texttt{()?()?()}$ 这样的序列，答案是 $2$ 种，但是我们却错误的算出了 $3$ 种，因为我们反复的算了 $2$ 遍 $\texttt{()*()*()}$ 这个答案，这也是我们接下来的任务：**去重**。

对于第二个问题，我们可以定义前缀和，求和的是 $s_i$ 是否为两种括号中的任意一种，这样一段区间只有星号和问号，也就意味着这段区间起点和终点的前缀和值相等，这可以在 $\mathcal{O}(n)$ 的预处理内解决。总时间复杂度已经降到了 $\mathcal{O}(n^4)$。

#### 去重

为什么我们会重复的算一个答案，原因是有很多答案可以通过多种方式组合起来，比如 $\texttt{(**)*()()}$ 这种答案，既可以通过 $\texttt{(**)}$ 和 $\texttt{()()}$ 采取 $\texttt{ASB}$ 变换所得，也可以通过 $\texttt{(**)*()}$ 和 $\texttt{()}$ 通过 $\texttt{AB}$ 变换所得。也就是其实去重的关键在于正确处理 $\texttt{ASB}$ 和 $\texttt{AB}$ 上面。

我们不妨改一下我们原本的定义，经过一番思考，我们可以发现存在多解是由于 $\texttt{AB}$ 括号序列的可分割性方面，但是以 $\texttt{(}$ 开头，以 $\texttt{)}$ 结尾的所有串，都是不可分割的，这便与我们要去重的串产生了许多不同。设 $dp_{l,r,0/1}$ 表示区间 $[l,r]$ 的合法括号序列答案，但是 $0$ 代表左括号开头右括号结尾的所有合法括号序列，而 $1$ 则不是。通过这个我们可以重新思考上面的六种情况。

- $\texttt{(S)}$：一段星号被括号所框起来，那么得到的合法括号序列一定是 $0$ 型括号序列，即：

$$
dp_{l,r,0}=\text{condition}_{l+1,r-1}
$$

- $\texttt{(A)}$：一段合法括号序列被括号框起来，无论 $\texttt{A}$ 是 $0$ 型还是 $1$ 型括号序列，都会变成 $0$ 型序列，即：

$$
dp_{l,r,0}=dp_{l+1,r-1,0}+dp_{l+1,r-1,1}
$$

- $\texttt{(SA)}$：跟上面一样，无论是 $0$ 型序列还是 $1$ 型序列都会变成 $0$ 型序列，即：

$$
dp_{l,r,0}=(dp_{p+1,r-1,0}+dp_{p+1,r-1,1})\times\text{condition}_{l+1,p}
$$

- $\texttt{(AS)}$：跟上面一样，有状态转移方程：

$$
dp_{l,r,0}=(dp_{l+1,p,0}+dp_{l+1,p,1})\times \text{condition}_{p+1,r-1}
$$

- $\texttt{AB}$：通过以上的转换，我们发现一种 $0$ 型序列和 $0$ 型序列合并产生 $1$ 型序列，但是两个 $1$ 型序列是不可合并的，即如果我找到了两个存在分割点的合法括号序列，那么一定有一个另外的分割点，将这种分割方法转为 $0$ 型序列和 $1$ 型序列的合并方式，同理 $1$ 型序列与 $0$ 型序列也没有必要计算。即：

$$
dp_{l,r,1}=dp_{l,p,0}\times(dp_{p+1,r,0}+dp_{p+1,r,1})
$$

- $\tt{ASB}$：除了有两个分割点以外，都与 $\texttt{AB}$ 型一样，只需要计算上面所说的两种合并方式：

$$
dp_{l,r,1}=dp_{l,p,0}\times(dp_{q+1,r,0}+dp_{q+1,r,1})\times\text{condition}_{p+1,q}
$$

至此我们的去重工作就完成了，但是我们的时间复杂度仍然是 $\mathcal{O}(n^4)$ 的，其算法瓶颈在于计算 $\texttt{ASB}$ 情况时我们必须枚举两个断点，使得算法的复杂度很高，我们必须想办法消掉一个断点。

#### 算法优化

我们仔细观察 $\texttt{ASB}$ 这种串，它本质上是由 $\texttt{A}$ 和 $\texttt{SA}$ 串结合起来的，而 $\texttt{SA}$ 串的计算上面已经讨论过了，我们就可以只枚举断点 $p$，达到我们的目的。为了方便我们对 DP 数组多开一个数字 $2$，它用来表示区间 $[l,r]$ 组成 $\texttt{SA}$ 串的总方案数，而他的转移是 $\mathcal{O}(n^3)$，调用答案时间却达到了 $\mathcal{O}(1)$，成功的消掉了多余的复杂度。

如果你是 TLE 95 分，检查一下你是不是取模取多了，减少取模的式子可以有效减少时间。

#### 细节

计算 $\texttt{(SA)}$ 的情况时，一定要注意 $p$ 的上界，看看你是否因为这个而 RE。

对于所有的情况都要想清楚 $r$ 至少要在 $l$ 的多少位后，手推一下样例也是完全可行的。

最终输出一定要取模。

初始化是对于所有的问号和括号，看他下一位是否可能匹配，并进行初始化，单独的星号是没法成为合法括号序列的，不用管它。

#### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
const int N=5e2+5;
int n,k,dp[N][N][3],d[N];
char s[N];
signed main(){
    scanf("%lld %lld",&n,&k);
    scanf("%s",s+1);
    for(register int i=1;i<=n;i++){
        d[i]=d[i-1];
        if((s[i]=='('||s[i]=='?')&&(s[i+1]==')'||s[i+1]=='?')) dp[i][i+1][0]=1;
        if(s[i]=='('||s[i]==')') d[i]=d[i-1]+1;
    }
    for(register int i=2;i<=n;i++){
        for(register int l=1;l<=n;l++){
            int r=l+i-1;
            if(r>n) break;
            if(r-l>=2&&(s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?')){
                dp[l][r][0]=((dp[l][r][0]+dp[l+1][r-1][1])%mod+dp[l+1][r-1][0])%mod;//情况(A)
            }
            if(r-l>=2&&((d[r-1]-d[l])==0)&&(s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?')&&r-l-1<=k){//情况(S)
                dp[l][r][0]=(dp[l][r][0]+((d[r-1]-d[l])==0))%mod;
            }
            if(r-l>=3){
                for(register int p=l;p<r;p++){
                    dp[l][r][1]=((dp[l][p][0]%mod*(dp[p+1][r][0]+dp[p+1][r][1])%mod)%mod+dp[l][r][1])%mod;//情况AB
                }
            }
            if(r-l>=4&&(s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?')){
                for(register int p=r-k-1;p<r-1;p++){//情况(AS)
                    if(r-p-1<=k) dp[l][r][0]=(dp[l][r][0]+(dp[l+1][p][0]+dp[l+1][p][1])*((d[r-1]-d[p])==0))%mod;
                }
            }
            if(r-l>=4&&(s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?')){
                for(register int p=l+1;p<=min(l+k,r-1);p++){//情况(SA)
                    if(p-l<=k) dp[l][r][0]=(dp[l][r][0]+(dp[p+1][r-1][0]+dp[p+1][r-1][1])*((d[p]-d[l])==0))%mod;
                }
            }
            if(r-l>=2){//对于 ASB 串的优化
                for(register int p=l;p<=min(l+k-1,r);p++){
                    dp[l][r][2]=(dp[l][r][2]+(dp[p+1][r][0]+dp[p+1][r][1])%mod*((d[p]-d[l-1])==0))%mod;
                }
            }
            if(r-l>=4){
                for(register int p=l+1;p<r-1;p++){
                    dp[l][r][1]=(dp[l][r][1]+(dp[l][p][0]%mod*dp[p+1][r][2]%mod)%mod)%mod;
                }
            }
        }
    }
    printf("%lld",(dp[1][n][0]+dp[1][n][1])%mod);
}
```



---

## 作者：makerY (赞：21)

## 写在前面

这篇题解参考了大佬 [Enucai](https://www.luogu.com.cn/user/169574) 的[这篇题解](https://www.luogu.com.cn/blog/wsyear/solution-p7914)的思路和代码，但我这种蒟蒻第一次很难理解大佬的状态设计和转移方法，题解中没有给出详细的做题思路，我又太弱了，没法向大佬一样很快把 dp 状态表示出来，于是我花了较长时间完全搞懂这题，然后写了这篇题解来详细谈谈这题的思维过程和做题时 dp 状态的逐步建立过程，同时稍稍改良了一下大佬的做法，少用了一个状态，希望这篇题解能帮到大家 qwq。

## 简要题意

这里给出容易理解但不是很严谨的简要题意：

合法括号序列：每个左括号都能唯一地和它右边的一个右括号匹配且没有多余的括号（后文给出了更严谨的定义）。

**超级括号序列**是向合法括号序列中（不包括最左和最右）插入任意数量的 `*` 且满足任意连续的 `*` 长度不超过 $k$ 形成的序列。

现在给出一个仅由 `(`、`)`、`*`、`?` 构成的字符串 $S$，其中 `?` 可以填入 `(`、`)`、`*` 中任意一个字符，求使得填后字符串为超级括号序列的填法方案数。

## 思路

首先拿到题最容易想到的暴力是直接对每个 `?` 进行 dfs，枚举可以填三种字符，并判断可行性。显然不加剪枝搜索的状态数会达到 $3^{500}$，而观察题目发现答案要对 $10^9 +7$ 取模，就说明合法情况数本身都会超过这个值，所以只要是 **朴素的** dfs，无论如何剪枝都不可能通过（可以换一种方式记搜，题解里有大佬写了），这种时候就可以换一种思路，考虑 dp，使其一次能转移更多的情况数，不必枚举到每一个情况。

首先考虑线性 dp，从前到后，对于序列的每一个位置，我们需要使用前面的状态来转移答案，看似很好转移，但实际上很难判断每个转移是否合法，最主要的困难是题目要求最外层的括号两边都不能有 `*`，而内层的括号则只要求左右两边不能都是 `*`，这意味着某些前面位置结尾的不合法情况会转移成后面的合法情况，而某些后面位置结尾的合法情况又会转移成后面的不合法情况，所以每次转移我们必须知道前面每一个“比较具体”的情况对应的方案数，判断转移哪些，但我们无法把这些“比较具体”的情况表示成较少的状态，需要占很大的空间，这在空间上就已经不可接受了，仔细想想，这只是相当于把朴素的 dfs 转化成更麻烦的 dp 了，实际效果与朴素 dfs 相差无几。

所以目前能考虑的办法几乎只有区间 dp 了，显然直接用二维的状态 $dp_{i,j}$ 直接表示区间 $[i,j]$ 内的方案数无法进行状态转移，但区间的状态不同于线性 dp 所用的状态，可以更灵活地使用区间端点表示，所以我们接下来思考如何更好地进行状态表示。

## 设计状态

本题最难的地方在于状态转移的不重不漏，这就需要我们在设计状态时多花心思，使状态数量尽可能少并易于转移。

由于左右两边都有 `*` 的非超级括号序列的区间也能转移成是括号序列的区间（即区间左右套一对括号和编程合法的，就是前文分析线性 dp 提到的“不合法情况转移到合法情况”），所以我们需要扩大状态表示的范围。于是对于这类区间，最直接地根据区间端点分类，这类区间的 **所有情况** 很容易分成以下 **不重复的** 四类：

1. 左端点为 `(`，右端点为 `)`。

2. 左端点为 `(`，右端点为 `*`。

3. 左端点为 `*`，右端点为 `)`。

4. 左端点为 `*`，右端点为 `*`。

思考一下，这四种状态是不是每种都能在转移时被其他状态表示出来，对于第 1 种状态，容易想到，可以由子区间的两种方式合并：两个状态 1 的区间，或状态 2 和状态 3 的区间。但这样直接把情况数相加就会重复枚举，因为枚举了所有断点，同一个情况可以被多次累加，如 `()*()*()` 会在断点下标为 2 和断点下标为 5 时两次被计入情况，而显然这个序列是确定的，只表示同一种情况。

同样地，对于第 2、3 种状态（这两种情况对称），若只拿子区间的状态 1 的区间与第 4 种状态的区间合并来累加答案，也会重复计数，如 `()*()*()*` 这种情况会在断点下标为 2、5、8 时被累加 3 次。

状态 4 同样如此，都不能依靠已有状态表示，所以考虑增加状态。

### 表示和转移第 1 种状态

> 注：下文的字符串之间的 + 表示字符串拼接。

我们发现第 1 种状态的重复是由于形如 `(...)*(...)*(...)*(...)` 的序列以几种不同的组合方式计入答案：`(...)*(...)*(...)*` + `(...)`、 `(...)*(...)*` + `(...)*(...)`、`(...)*` + `(...)*(...)*(...)`，可以发现，后 2 种组合方式的后半部分都由多组 **最外层的括号** 和中间的一些 `*` 拼接而成，于是我们考虑去除这类情况，只保留形如上面第 1 种组合方式的情况。为此，可以增加一个比状态 1 范围更小的状态以去重：

> 状态 A：左端点为 `(`，右端点为 `)`，且最外层为且仅为这一组括号组成。

于是每个区间就可以唯一地表示为左子区间为状态 1 或 2 的区间、右子区间为状态 A 的区间的组合，以这种方式枚举每个断点的左右子区间，就可以做到不重不漏了。

如何转移？枚举每个断点，简单分析可以得到左边由于分状态 1、2 共两类，使用加法原理，左右子区间的所有方案可以随意组合，再使用乘法原理乘起来则为该断点分的左右区间的方案数。又由于每个断点考虑的情况都计算的是该区间至少由 $2$ 组最外层的括号组成的情况，没有考虑本身就是 $1$ 组最外层的括号（即状态 A）的情况，所以求和之后再加上状态 A 的方案数即可。

### 表示和转移第 2、3 种状态

这里以状态 2 为例，与表示第 1 种状态的思路一样，考虑重复的原因：形如 `(...)*(...)*(...)**` 的序列被以 `(...)*(...)*(...)` + `**`、`(...)*(...)` + `*(...)**`、`(...)` + `*(...)*(...)**` 三种组合方式计入答案。同样考虑保留只第一种枚举到的情况，去除后 $2$ 种。可以发现第一种组合方式的这类情况的右子区间都是一些连续的 `*`，我们以它表示枚举右子区间的状态，也相当于是增加了一个比状态 4 范围更小的状态以去重：

> 状态 B：整个区间全都由 `*` 组成。

这样每个区间就可以唯一地表示为左子区间为状态 1 的区间、右子区间为状态 B 的区间的组合，保证了枚举断点时累积不重不漏。

转移与状态 1 类似：枚举断点，左子区间状态 1 的方案数与右子区间状态 B 的方案数相乘，再对于每一个断点求和。由于状态 B 一定不包含于状态 2 或状态 3，所以最后不加状态 B 的方案数。

状态 3 的转移就是状态 2 左右子区间的状态反过来，即：左子区间状态 B 的方案数与右子区间状态 1 的方案数相乘，其他完全一样。

### 表示和转移状态 A

 > 注意：别忘了新加的状态也要被已有状态表示，不然没法转移。

由于状态 A 只需要满足最外层套了一对括号，里面是任意状态都行，所以直接去掉最外层的括号，其方案数就是最外层括号内部是这个大区间的状态 1、2、3 的方案数之和（注意内部区间的状态 A 属于状态 1，不必再加，而状态 4 由于左右两边都是 `*`，为题中所述的 `(SAS)` 形式，不计入答案 ）。

### 表示和转移状态 B

可以直接暴力判断区间是否全为 `*`，这层循环会和转移其他状态枚举区间断点的循环并列，不会影响整体复杂度。

当然，可以直接用子区间的的状态 B 答案更新，取去掉区间右边得到的子区间的状态 B 的答案，若为 $1$ 且区间右端点为 `*` 就可以知道这个区间全是 `*`，最后别忘了还要保证状态 B 的区间长度不超过 $k$，同时满足这三个条件，该状态的方案数就是 $1$，否则是 $0$。不过这样更新要注意边界的初始化。

### 状态 4

可以发现，现在其他状态的更新都已经用不到状态 $4$ 了，而状态 $4$ 也不是我们要求的答案，每次更新它没有意义，直接去掉这个状态即可。

## 总述

根据上面的分析过程，更形式化地给出本题 dp 的过程。

为了便于较严谨地描述，又由于本人语言表达能力欠佳，下面给出一些会用到的词语在这篇题解中的定义。

在下文中，$S$ 表示题中所给的用来确定字符超级括号序列方案数的字符串，默认第一个字符的下标从 1 开始。$i$ 表示左区间下标，$j$ 表示右区间下标，$t$ 表示枚举的区间断点下标。

>注意：在 $S$ 中的 `?` **可以**为 `(`、`)`、`*` 中的任意一个，所以 `?` 在对应的状态中都应该被算进去。

### 约定

- **合法括号序列**（这与很多和括号有关的思维题里的定义相同）：

1. 空串是合法括号序列。

2. 若 `A` 和 `B` 均是合法括号序列，则 `A` 和 `B` 连接而成的序列是合法括号序列。

3. 若 `A` 是合法括号序列，则 `(A)` 是合法括号序列。

- **合法状态序列**：

1. 空串是合法状态序列。

2. 若 `A` 是合法状态序列且 `A` 左侧的连续 `*` 数量严格小于 $k$，则 `*A` 是合法状态序列；若 `A` 是合法状态序列序列且 `A` 右侧的连续 `*` 数量严格小于 $k$，则 `A*` 是合法状态序列。

3. 若 `A` 和 `B` 均是合法状态序列，则 `A` 和 `B` 连接而成的序列是合法状态序列。

4. 若 `A` 是合法状态序列，则 `(A)` 是合法状态序列。

- 称 **在合法状态序列中** 位置为 $i$ 和 $j$ 的一组括号 **“匹配”** 当且仅当区间 $[i,j]$ 为合法状态序列且 $S_j$ 为 `(`，$S_j$ 为 `)`。

- 称 **在合法状态序列中** 位置为 $i$ 和 $j$ 的一组括号 **“单区间匹配”** 当且仅当这组括号**匹配**且区间 $[i+1,j-1]$ 为合法状态序列。

---
### 状态定义

定义 $dp_{i,j,p}$ 为在 $S$ 的区间 $[i,j]$ 中确定 `?` 字符，使 `S` 成为 **合法状态序列**，且状态为 $p$ 时的方案数（注意这里的状态编号不是前文的编号，为方便表示重新编了号）。

我们对 **所有合法状态序列** 的状态进行讨论。

- $p=0$：区间内字符全为 `*`。

- $p=1$：左右端点是一组 **单区间匹配** 的括号。

- $p=2$：左端点为 `(`，右端点为 `*`。

- $p=3$：左右端点是一组 **匹配** 的括号。

- $p=4$：左端点为 `*`，右端点为 `)`。

其中，$p=1$ 的状态包含于 $p=3$ 的状态。 

显然，对于 $S$ 的整个区间 $[1,n]$，$p=3$ 的状态即为答案。

初始化边界：对于 $\forall i$ ，有 $dp_{i,i-1,0}=1$。

### 状态转移

1. $dp_{i,j,0}=1$ 当且仅当 $dp_{i,j-1,0}=1$ 且 $S_j$ 可以为 `*` 且 $j-i+1<k$，否则 $dp_{i,j,0}=0$。

2. $dp_{i,j,1} = dp_{i+1,j-1,0}+dp_{i+1,j-1,2}+dp_{i+1,j-1,3}+dp_{i+1,j-1,4}$ 当且仅当 $S_i$ 和 $S_j$ 为一组匹配的括号，否则 $dp_{i,j,1}=0$。

3. $dp_{i,j,2} = \sum_{t=i}^{j-1} dp_{i,t,3} \times dp_{t+1,j,0}$ 。

4. $dp_{i,j,3} = dp_{i,j,1} + \sum_{t=i}^{j-1} (dp_{i,t,2}+dp_{i,t,3}) \times dp_{t+1,j,1}$ 。

5. $dp_{i,j,4} = \sum_{t=i}^{j-1} dp_{i,t,0} \times dp_{t+1,j,3}$ 

### 复杂度

时间复杂度和标准的区间 dp 相同，为 $O(n^3)$。空间上，使用了大小为 $N \times N \times 5$ 的 long long 数组作为 dp 数组（$N$ 为 $n$ 的最大值）。都可以通过此题数据范围。

## Code

明白了以上所述的状态定义和转移，直接照着转移写代码就很简单了，不过注意边界的初始化和同一个区间不同状态转移的顺序，每次更新需要保证用到的所有状态都被正确地更新了。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=550,mo=1e9+7;
LL dp[N][N][5];
int n,k;
char S[N];
signed main()
{
	scanf("%d%d",&n,&k);
	scanf("%s",S+1);
	for(int i=1;i<=n;++i) 
		dp[i][i-1][0]=1;//初始化边界 
	for(int len=1;len<=n;++len)//枚举区间长度 
		for(int i=1,j=i+len-1;j<=n;++i,++j)//枚举左右端点 
		{ 
			if(len<=k&&dp[i][j-1][0]&&(S[j]=='*'||S[j]=='?')) dp[i][j][0]=1;
			if(len>=2)//用小于2的子区间转移没有意义 
			{
				if((S[i]=='('||S[i]=='?')&&(S[j]==')'||S[j]=='?'))//判断左右端点是否为匹配的括号 
					dp[i][j][1]=(dp[i+1][j-1][0]+dp[i+1][j-1][2]+dp[i+1][j-1][3]+dp[i+1][j-1][4])%mo;
				for(int t=i;t<=j-1;++t)//枚举子区间的断点 
				{
					dp[i][j][2]=(dp[i][j][2]+dp[i][t][3]*dp[t+1][j][0])%mo;
					dp[i][j][3]=(dp[i][j][3]+(dp[i][t][2]+dp[i][t][3])*dp[t+1][j][1])%mo;
					dp[i][j][4]=(dp[i][j][4]+dp[i][t][0]*dp[t+1][j][3])%mo;
				}
			}
            dp[i][j][3]=(dp[i][j][3]+dp[i][j][1])%mo;
		}
	printf("%lld",dp[1][n][3]);
	return 0;
}
```

---

## 作者：Otue (赞：19)

## 前言
思路来源于@[cqbzzqw](https://www.luogu.com.cn/user/383782)。

提示：如果您此题超时 $15$ 分的话（一般就是爆搜），不妨改成记忆化搜索试试。

## 思路
采用的是记忆化搜索。

根据题目，有以下几种格式：`()`，`(S)`，`AB`，`ASB`，`(A)`，`(SA)`，`(AS)`。

定义 `dfs(l,r,t)` ，$t=0$ 表示普通超级序列个数，$t=1$ 表示 `SA` 形式个数，$t=2$ 表示 `AS` 形式个数，$t=3$ 表示不能直接“分割”的超级序列个数。




- 当 $t=0$ 时
   * 统计 `()`，`(S)`，`(A)`，`(SA)` 的方案。（前提是外面有个括号）
      * 若为 `()`，`(S)`，判断 $[l+1,r-1]$ 区间是否可以形成 $S$ 形式 ,如果可以，方案数加一。
      * 若为 `(A)` ，方案数加上 `dfs(l+1,r-1,0)`。
      * 若为 `(SA)`，方案数加上 `dfs(l+1,r-1,1)`。
      * 若为 `(AS)`，方案数加上 `dfs(l+1,r-1,2)`。
   * 若没有括号，那只能是 `AB`，`ASB` 的形式了
      * 若为 `AB` ，分割成 `A->B` ，分成两个部分，方案数肯定是要乘起来的。方案数加上 `dfs(l,i,3)*dfs(i+1,r,0)`（$i$ 为分割位置）。
      * 若为 `ASB`，分割成 `A->SB` ，同理也是要乘起来的。方案数加上 `dfs(l,i,3)*dfs(i+1,r,0)`（$i$ 为分割位置）。

      
- 当 $t=1$ 时，直接分割成 `S->A` ，枚举分割位置（假设位置为 $i$），如果 $[l,i]$ 可以形成 $S$ 形式，方案数加上 `dfs(i+1,r,0)`。

- 当 $t=2$ 时，分割成 `A->S` 形式，如果 $[i,r]$ 可以形成 $S$ 形式，方案数加上 `dfs(l,i-1 0)`。

- 当 $t=3$ 时，因为不能分割，所以只需统计 `()`，`(S)`，`(A)`，`(SA)` 的方案。

## 代码

思路大概就讲完了，如果还不理解就看代码吧

```c++
#include<bits/stdc++.h>
using namespace std;
int n,k;
char a[1005];
const int mod=1e9+7;
//() (S) AB ASB
//(A)、(SA)、(AS)
int dp[505][505][4];
int f[505][505],d[505][505];
bool check(int l,int r){//判断[l,r]区间是否可以为S形式
	if(d[l][r]!=-1) return d[l][r];//记忆化
	if(r-l+1>k) return 0;//因为不能有超过k个*
	if(l>r) return d[l][r]=1;
	if((a[l]=='*'||a[l]=='?')&&(a[r]=='*'||a[r]=='?')){
		return d[l][r]=check(l+1,r-1);
	}
	else{
		return d[l][r]=0;
	}
}
int dfs(int l,int r,int t){
	if(l>=r){
		return 0;
	}
	if(dp[l][r][t]!=-1) return dp[l][r][t];//记忆化
	int ans=0;
	if(t==0){
		bool ok=(a[l]=='('||a[l]=='?')&&(a[r]==')'||a[r]=='?');//首先判断两边有没有括号（问号是不确定的，也可行）
		if(ok){
			if(check(l+1,r-1)){
				ans++;
			}
			ans=(ans%mod+dfs(l+1,r-1,0)%mod)%mod;
			ans=(ans%mod+dfs(l+1,r-1,1)%mod)%mod;
			ans=(ans%mod+dfs(l+1,r-1,2)%mod)%mod;//解释过
		}
		else{
			return dp[l][r][t]=0;
		}
		for(int i=l;i<r;i++){//进行“分割”
			ans=(ans%mod+1ll*dfs(l,i,3)%mod*dfs(i+1,r,0)%mod)%mod;
			ans=(ans%mod+1ll*dfs(l,i,3)%mod*dfs(i+1,r,1)%mod)%mod;
		}
	}
	else if(t==1){//SA
		for(int i=l;i<r;i++){
			if(check(l,i)){
				ans=(ans%mod+dfs(i+1,r,0))%mod;
			}
			else{
				break;//如果[l,i]不能组成S形式，那么i更大也不能组成
			}
		}
	}
	else if(t==2){//AS
		for(int i=r;i>l;i--){
			if(check(i,r)){
				ans=(ans%mod+dfs(l,i-1,0))%mod;
			}
			else{
				break;
			}
		}
	} 
	else if(t==3){
		bool ok=(a[l]=='('||a[l]=='?')&&(a[r]==')'||a[r]=='?');
		if(ok){
			if(check(l+1,r-1)){
				ans++;
			}
		
			ans=(ans%mod+dfs(l+1,r-1,0)%mod)%mod;
			ans=(ans%mod+dfs(l+1,r-1,1)%mod)%mod;
			ans=(ans%mod+dfs(l+1,r-1,2)%mod)%mod;
			
		}
		else{
			return dp[l][r][t]=0;
		}
      //这里就不用分割了
	}
	return dp[l][r][t]=ans;//保存答案
} 
int main(){
	memset(dp,-1,sizeof dp);
	memset(d,-1,sizeof d);
	scanf("%d%d\n",&n,&k);

	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	cout<<dfs(1,n,0)%mod<<endl;
}
```

---

## 作者：maruize (赞：16)

注:本题解有众多dp数组没有显试的前缀和优化。

## [CSP-S 2021] T2 括号序列

看到数据范围想到是一个 $O(n^3)$ 区间 dp 。

有以下几种情况:

1. ()
2. (A)
3. (SA)
4. (AS)
5. (S)
6. AB
7. ASB

发现只有 ASB 的情况其余可以做到 $O(n^3)$ 。

发现 ASB = A+SA ,考虑维护SA的情况。

考虑多维护几个 dp 数组:

- $g_{i,j}$ : $[i,j]$ 是否可以是一种合法 S 串
- $h1_{i,j}$ : $[i,j]$ 是 AS 这中情况的方案数
- $h2_{i,j}$ : $[i,j]$ 是 SA 这中情况的方案数
- $f_{i,j}$ : $[i,j]$ 是合法超级括号序列的方案数

$g$ 最好维护, $h$ 可以枚举中间分界点 dp ,  $f$ 也可以按照上面可能的情况枚举分解点进行 dp 了。

写完发先第二个样例输出 28 , 算重了。

为什么呢?

考虑一种情况  `()()()` , 会由 `"()"+"()()"` 和 `"()()"+"()"`转移。

怎么处理呢? 

首先算重仅限情况6 ,其他情况不会算重。

我们考虑情况6转移时加一个限制, 令 A 为 "(C)" 这种形式 ( C 不要求合法, A 合法) , B无要求,可以发现这样就不会重了。

PS:情况7其实也可能重,比如 `()()*()` ,但是这种方法可以处理这种问题。


但是这样 $f$ 需要拆成 $f1$ 和 $f2$ , $f1$ 表示超级括号序列两个端点是匹配的括号的方案数, $f2$ 表示其他的方案。

于是 dp 就写成了! 注意转移的细节。

**以及不要忘记取模!!!(我有个地方忘了这题就挂了......)**

下面具体看一下转移。

首先前五种情况分一小类,祂们可以 $O(1)$ 转移。

```cpp
if(can(i,'(')&&can(j,')'))
	f1[i][j]=
		 (i+1==j)/*1*/
		+h1[i+1][j-1]/*2*/
		+h2[i+1][j-1]/*3*/
		+f1[i+1][j-1]+f2[i+1][j-1]/*4*/
		+g[i+1][j-1]/*5*/
```

$O(n)$ 的情况:

```cpp
for k in [i..j) //前闭后开
	f2[i][j]+=f1[i][k]*(f1[k+1][j]+f2[k+1][j]+h2[k+1][j])
	/*6,7*/
```

$g$ 最简单:

```cpp
g[x][x]=can(x,'*')
g[i][j]=(((j-i+1)<=m)&&g[i][j-1]&&can(j,'*'))
```

$h1$ 和 $h2$ 的转移:

```cpp
for k in [i..j)
	h1[i][j]+=(f1[i][k]+f2[i][k])*g[k+1][j]
	h2[i][j]+=g[i][k]*(f1[k+1][j]+f2[k+1][j])
```

最后`printf("%lld\n",((LL)f1[1][n]+(LL)f2[1][n])%mod); `

注: `can(i,c)` 表示字符串中第 $i$ 个字符是否可以变成字符 $c$。



---

## 作者：QAQQWQ (赞：15)

#### 题目分析
看到题面，容易想到是区间 dp。设 $dp_{i,j}$ 为将 i 到 j 的位置中所有问号填满，使其成为符合规范的超级括号序列的方案种数，考虑 $dp_{i,j}$ 可以由那些情况转移而来。

- i 与 j 可能是匹配的，那么一共有三种转移。将 i+1 到 j-1 的位置作为 S，由  $dp_{i+1,j-1}$ 转移，以及将 i+1 到 j-1 的位置为 SA 与 AS 类型的串。
- i 到 j 为 ASB 类型的种数。

开始 $O(n)$ 预处理一次可能成为 * 的长度可以做到 $O(1)$ 判断一段串是否可能全为 * 。

但是写完代码后发现第二个样例无法通过，会算重。考虑这样一种情况 ```()()()``` 它会在两个分割点被计算两次。那么我们可以限制它在一个方向上合并，这样做后答案是正确的，复杂度 $O(n^4)$ 可以得到 40 分，加上前缀和可以优化到 $O(n^3)$ 可以通过本题。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
const int mod=1e9+7;
long long dp[509][509],dps[509][509],sum[509][509];
int xh[509];
char s[509];
int read(){
	int sm=0,d=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-'){
			d=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		sm*=10;
		sm+=c-'0';
		c=getchar();
	}
	return sm*d;
}
bool check(int l,int r){
	return (xh[r]>=r-l+1&&r-l+1<=k);
}
int main(){
	n=read();
	k=read();
	cin>>s+1;
	for(int i=1;i<=n;i++){
		if(s[i]=='?'||s[i]=='*'){
			xh[i]=xh[i-1]+1;
		}
		else xh[i]=0;
	}
	for(int j=1;j<=n;j++){
		for(int i=j-1;i;i--){
			if((s[i]=='('||s[i]=='?')&&(s[j]==')'||s[j]=='?')){
				if(check(i+1,j-1)){
					dp[i][j]=(dp[i][j]+1)%mod;
				}
				dp[i][j]=(dp[i][j]+dps[i+1][j-1])%mod;
				for(int mid=i+1;mid<j-1;mid++){
					if(check(i+1,mid)){
						dp[i][j]=(dp[i][j]+dps[mid+1][j-1])%mod;
					}
					if(check(mid+1,j-1)){
						dp[i][j]=(dp[i][j]+dps[i+1][mid])%mod;
					}
				}
			}
			dps[i][j]=dp[i][j];
			for(int mid2=i+1;mid2<=j;mid2++){
//				for(int mid1=i;mid1<mid2;mid1++){
//					if(check(mid1+1,mid2-1)){
//						dps[i][j]=(dps[i][j]+dps[i][mid1]*dp[mid2][j]%mod)%mod;
//					}
//				}
				dps[i][j]=(dps[i][j]+(sum[i][mid2-1]-sum[i][mid2-min(k,xh[mid2-1])-2]+mod)%mod*dp[mid2][j]%mod)%mod;
			}
			sum[i][j]=(sum[i][j-1]+dps[i][j])%mod;
		}
	}
	cout<<dps[1][n];
	return 0;
}
```


---

## 作者：OMG_wc (赞：10)

题目中把超级括号序列分成了三类：

- 第一类`()`和`(S)`
- 第二类`AB`和`ASB`
- 第三类`(SA)`、`(AS)`、`(A)` 

显然这是一道区间DP题，我们就根据这三种构成方式来转移。

首先定义`f[i][j][0/1]`表示 $[i,j]$ 这个区间的合法超括序列数，最后一维表示 $s_i$ 和 $s_j$ 是否是匹配的括号对。之所以这样定义，是因为在计算第二类是时，为了避免重复计算，要枚举哪个右括号和 $s_i$ 是匹配的，这样拆分出第一个括号来转移就不会重复。

那么`f[i][j][0]`是从第二类转移过来的，而`f[i][j][1]`是从第一类和第三类转移过来的。

- 第一类其实就是唯一的情况，判断一下区间长度是否小于等于 $m+2$ 即可。

- 第三类 `(A)` 的情况就直接从`f[i+1][j-1][0]+f[i+1][j-1][1]`转移；

  `(SA)`就枚举一个 $k$ 表示 $[i+1,k]$ 全是`*`，$[k+1,j-1]$ 是另外一个合法的超括序列，从`f[k + 1][j - 1][0] + f[k + 1][j - 1][1]`转移；

  `(AS)`同理。

- 第二类需要把 $[i,j]$ 这个区间分成三段：$[i,k]$是第一对超括，$[k+1,z-1]$ 都是`*` （$z=k+1$ 就表示不存在这段），$[z,j]$ 是后面的合法超括序列，转移就是`f[i][k][1]*(f[z][j][0]+f[z][j][1])`。

  如果朴素枚举 $k$ 和 $z$ 会导致时间复杂度为 $O(n^4)$ ，见下面代码：

```c++
for (int k = i + 1; k < j; k++) {
    // s[i]和s[k]匹配
    if (s[k] == ')' || s[k] == '?') {
        LL t = 0;
        //[k+1,z-1] 全为*   [z,j] 为合法超级括号
        for (int z = k + 1; z <= j && z - 1 - k <= m; z++) {
            if (s[z] == '(' || s[z] == '?')
                t += f[z][j][0] + f[z][j][1];
            if (s[z] != '*' && s[z] != '?') break;
        }
        t %= mod;
        f[i][j][0] += f[i][k][1] * t % mod;
    }
}
```

显然代码中 $t$ 的计算不需要枚举，可以进行一个后缀和优化。首先预处理`b[i]`表示从 $1$ 开始`*`最多能持续到的位置，然后维护`g[j][i`] 表示所有`f[k][j][0/1]`的和，这样只需枚举一个 $k$，然后所需的一段区间和就通过两个后缀和相减得出。

总时间复杂度 $O(n^3)$ ，代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 505;

int n, m;
char s[N];
LL f[N][N][2];  //0/1 表示左右边界是否匹配
LL g[N][N];     //g[j][i] 表示 所有f[k][j][0/1]的和
int b[N];       // b[i] 表示从i开始*最多能持续到的位置
int main() {
    scanf("%d%d%s", &n, &m, s + 1);
    b[n + 1] = n;
    for (int i = n; i >= 1; i--) {
        if (s[i] == '*' || s[i] == '?')
            b[i] = min(b[i + 1], i + m - 1);
        else
            b[i] = i - 1;
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 1, j = i + len - 1; j <= n; i++, j++) {
            if (s[i] != '(' && s[i] != '?' || s[j] != ')' && s[j] != '?') {
                g[j][i] = g[j][i + 1];
                continue;
            }
            if (len - 2 <= m) {
                f[i][j][1] = 1;
                for (int k = i + 1; k < j; k++) {
                    if (s[k] != '*' && s[k] != '?') f[i][j][1] = 0;
                }
            }
            // (A)
            f[i][j][1] += f[i + 1][j - 1][0] + f[i + 1][j - 1][1];
            // (SA)
            for (int k = i + 1; k <= j - 1 && k - i <= m; k++) {
                if (s[k] != '*' && s[k] != '?') break;
                f[i][j][1] += f[k + 1][j - 1][0] + f[k + 1][j - 1][1];
            }
            // (AS)
            for (int k = j - 1; k >= i + 1 && j - k <= m; k--) {
                if (s[k] != '*' && s[k] != '?') break;
                f[i][j][1] += f[i + 1][k - 1][0] + f[i + 1][k - 1][1];
            }
            // ASB
            for (int k = i + 1; k < j; k++) {
                // s[i]和s[k]匹配
                if (s[k] == ')' || s[k] == '?') {
                    f[i][j][0] += f[i][k][1] * (g[j][k + 1] - g[j][min(j, b[k + 1] + 2)] + mod) % mod;
                }
            }
            f[i][j][0] %= mod;
            f[i][j][1] %= mod;
            g[j][i] = (g[j][i + 1] + f[i][j][0] + f[i][j][1]) % mod;
        }
    }
    printf("%lld\n", (f[1][n][0] + f[1][n][1]) % mod);
    return 0;
}
```

### 

---

## 作者：Mobius127 (赞：9)

[题传](https://www.luogu.com.cn/problem/P7914)

珂以，我考场少写一个 `-`，光荣爆零（实际上是写成 `+` 了不过也差不多）。

一个比较显然的东西是：合法串左右两边必然是 `(` 和 `)`，不管是否匹配。

整理一下格式，令 $S=\{t \times '*' | 1\le t \le k\}$，$A\text{、}B$ 为任意两个可行的方案，可行的组成方案有：

$$E=\{(),\, (S),\, (A),\, AB,\, ASB,\,(SA),\, (AS)\}$$

不难发现，一旦 $S$ 出现，其必然是被括号**两面包夹芝士**（ $S$ 左右两边的括号不一定要求匹配），考虑以 $S$ 的断点进行区间 DP。

设 $f_{l,r}$ 为只填 $[l, r]$ 的总方案数，$can_{l, r}$ 为整个区间是否都能填 `*`，根据题意有：

$$f_{l, r}=can_{l+1, r-1}+f_{l+1,r-1}+(\sum_{k=l+1}^{r-1} f_{l, k} \times f_{k+1, r}) + $$

$$(\sum_{l<i<j<r \wedge can_{i+1, j-1}}^{1<j-i-1 \le k} f_{l, i} \times f_{j, r}) + \sum_{k=l+1}^{r-2 \wedge (k-l-1 \le k)} f_{k+1, r-1} \times can_{l+1, k} + \sum_{l+2 \wedge (r-k-1 \le k)}^{k=r-1} f_{l+1, k-1} \times can_{k, r-1}$$


（柿子下标可能会有点混，6 个项正好对应 $E$ 中的第 2 -7 项，由于第一个是小区间所以直接判就珂以了）

**为了不产生歧义，以下的第 $x$ 项的意思是 $E$ 中的第 $x$ 项。**

其中第四项和第五项珂以并在一起，因为第三项就相当于 $S$ 中 $t=0$ 的情况。

然后你一通码出来发现挂了：（

为什么？因为你发现，对于第四五项来说，若 $A=CP$ 或 $A=CSP$ 那么以下这两种分法是一样的：

$$(CP)B=C(PB)$$

$$(CSP)SB=CS(PSB)$$

也就是说：**我们算重了！**

不过这种情况也很好考虑：我们让分界的位置 $p$ 之前的都是完整的一段，再拿一个数组去记录不含四五项的合法串个数，对于右边的，直接拿原来 $f$，然后套个乘法原理。

至于为什么这么做，注意到上面的 $C,P$ 都是珂以继续拆分的，所以我们要在这里面找到不变的地方（有我们数学老师那味儿了）——不可拆分极大块，这样就有效避免了重复。

但是你直接这么做还是萎了的，暴力算 $O(n^4)$，压根 AK 不了，考虑到一个字符往左右拓展 `*` 的最长长度是一定的（不会随着决策而改变），所以直接预处理出这两个值，然后你发现 $\Sigma$ 的上下界是确定的，而且里面都是 $f$，显然珂以前缀和优化了吧。

时间复杂度 $O(n^3)$，空间 $O(n^2)$。

### Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mo=1e9+7;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)) f=(ch=='-'?-1:f), ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0', ch=getchar();
	return x*f; 
}
const int N=505;
int strn, k, f[N][N][4], L[N], R[N];
bool can[N][N];
char sc[N];
bool check(int pos, char c2){
	if(sc[pos]=='?') return 1;
	return sc[pos]==c2;
}
void add(int &x, int y){x=(x+y)%mo;}
inline int rag(int l, int r){
	return r-l+1;
}
signed main(){
	strn=read(), k=read();
	scanf("%s", sc+1);
	for(int i=1; i<=strn; i++) can[i][i]=check(i, '*');
	for(int i=1; i<=strn; i++)
		for(int j=i+1; j<=strn; j++)
			can[i][j]=can[i][j-1]&check(j, '*');
	for(int i=1; i<=strn; i++)
		L[i]=check(i, '*')?L[i-1]:i;
	R[strn+1]=strn+1;
	for(int i=strn; i>=1; i--)
		R[i]=check(i, '*')?R[i+1]:i;
	for(int len=2; len<=strn; len++)
		for(int l=1; l+len-1<=strn; l++){
			int r=l+len-1;
			if(check(l, '(')&&check(r, ')')){
				if(R[l+1]>=r&&r-l-1<=k) f[l][r][0]=1;
				int fl=min(R[l+1], l+k+1), fr=max(L[r-1], r-k-1);
				add(f[l][r][0], (f[l+1][r-1][2]-f[fl+1][r-1][2])%mo);
				add(f[l][r][0], (f[l+1][r-1][3]-f[l+1][fr-1][3])%mo);
				add(f[l][r][0], mo-f[l+1][r-1][1]);//上面有一个重叠部分，所以要减去 
				f[l][r][1]=f[l][r][0];
				for(int t=l+1; t<=r-2; t++)//枚举前面无法再分割的位 
					add(f[l][r][1], 1ll*f[l][t][0]*(f[t+1][r][2]-f[min(t+k+1, R[t+1])+1][r][2])%mo);
			}
			add(f[l][r][2], (f[l+1][r][2]+f[l][r][1])%mo);//后缀和 
			add(f[l][r][3], (f[l][r-1][3]+f[l][r][1])%mo);//前缀和 
		}
	printf("%lld", ((f[1][strn][1])%mo+mo)%mo);
	return 0;
}
```















---

## 作者：Calculatelove (赞：6)

显然 dp。线性 dp 不易处理题目中的变换规则，可以考虑区间 dp。

首先可以 $\mathcal{O}(n^2)$ 预处理一个数组 $ok(i, j)$ 表示：区间 $[i, j]$ 中的字符串能否表示为**不超过 $k$ 个**字符 `*` 的非空字符串。

然后定义 dp 状态：

- $f_0(l, r)$：表示区间 $[l, r]$ 中的字符，能组成多少个符合规范的超级括号序列。
- $f_1(l, r)$：表示区间 $[l, r]$ 中的字符，能组成多少个形如 `(A)` 的超级括号序列。
- $f_2(l, r)$：表示区间 $[l, r]$ 中的字符，能组成多少个形如 `SA` 的超级括号序列。
- $f_3(l, r)$：表示区间 $[l, r]$ 中的字符，能组成多少个形如 `AS` 的超级括号序列。

---

- 对于 $f_0$ 的转移：
  - 第一种是形如 `(...)` 的转移。
  - 第二种是形如 `AB`、`ASB` 的转移。  
    为了做到不重复计数（例如 `ABC` 可以看成 `A + BC` 和 `AB + C`，但是这两种转移本质上是一个方案），我们可以强行认为 `AB`、`ASB` 中的 `A` 是形如 `(...)` 的串，这样就不会重复计数了。

$$
f_0(l, r) = f_1(l, r) + \sum\limits_{l \leq k < r} f_1(l, k) \times \left(f_0(k + 1, r) + f_2(k + 1, r)\right)
$$

- 对于 $f_1$ 的转移：
  - 首先要判断一下 $s_l$ 是否为字符 `(` 或 `?` 的其中一个，$s_r$ 是否为字符 `)` 或 `?` 的其中一个。  
    若不满足，则 $f_1(l, r) = 0$。
  - 第一种是形如 `(*...*)` 的转移。
  - 第二种是形如 `(A)` 的转移。
  - 第三种是形如 `(SA)` 的转移。
  - 第四种是形如 `(AS)` 的转移。

$$
f_1(l, r) = [ok(l + 1, r - 1) = 1] + f_0(l + 1, r - 1) + f_2(l + 1, r - 1) + f_3(l + 1, r - 1)
$$

- 对于 $f_2$ 的转移：

$$
f_2(l, r) = \sum\limits_{l \leq k < r, ok(l,k) = 1} f_0(k + 1, r)
$$

- 对于 $f_3$ 的转移：

$$
f_3(l, r) = \sum\limits_{l < k \leq r, ok(k, r) = 1} f_0(l, k - 1)
$$

最后的答案即为 $f_0(1, n)$，时间复杂度 $\mathcal{O}(n^3)$。

---

## 作者：Booksnow (赞：5)

# 括号序列

[更好的阅读体验](https://www.cnblogs.com/Defoliation-ldlh/p/15455662.html)

## 题面

给定一个长度为 $n$ ，包含 $*$、$?$、$($、$)$ 的字符串。

其中， $?$ 处字符串缺失，可能是 $*$、$($、$)$ 中的任意一种。

定义**超级括号序列**如下：

- $()$ 和 $(S)$ 均为符合规范超级括号序列，其中 $S$ 表示由**长度不超过 $k$** 的 $*$ 组成。

- 如果 $A$ 和 $B$ 为超级括号序列，那么 $AB$、$ASB$ 同样为符合规范的超级括号序列，其中 $AB$ 表示把 $A$ 和 $B$ 拼在一起形成的字符串。

- 如果 $A$ 为符合规范的超级括号序列，那么 $(A)$、$(SA)$、$(AS)$ 均为符合规范的超级括号序列。

- 所有符合规范的超级括号序列均可以由以上 $3$ 条规则得到。

求给出的字符串一共能对应多少种符合规范的超级括号序列。

给出 $n$、$k$ 和一个长度为 $n$ 的字符串，其中 $1\leq k\leq n\leq 500$ 。

## 分析

### 暴力

暴力分 $15$ 分应该是直接搜索？$O(3^n)$ ，期望能过前 $3$ 个点。

### 区间 $DP$ 

之后发现好像其他暴力不怎么会，注意到 $n$ 的范围只有 $500$ ，我们需要一个 $O(n^3)$ 的算法来解决这个问题。

考虑一个区间 $DP$ 。

设 $dp[l][r]$ 表示区间 $l$ 到 $r$ 的答案，之后，模拟上述的规则即可更新。

但之后你会发现你无法通过样例，思考这样 $dp$ 的正确性，发现我们**算重**了。

对于 $A$ ，我们也许会把它和后面一个匹配成功的 $BC$ 合并，但是我们也会将 $AB$ 合并，并在后面与 $C$ 合并，考虑给我们的状态多加一维。

设 $dp[l][r][0/1]$ 表示当前区间经历合并的方案数与没有经历合并的方案数，只让没有经历合并的方案和在它后面的经历过合并的方案合并，这样就能够避免这种情况。

### 一些细节

发现实现 $ASB$ 是最后一个难关，很容易会让复杂度退化到 $O(n^4)$ ，考虑设一个新的状态 $f[l][r]$ 表示该区间内 $SB$ 的方案数，之后可以与 $AB$ 的情况一起转移。

## CODE

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e2+10,MOD=1e9+7;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w*=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;	
}
int n,k;
int g[N][N],f[N][N],dp[N][N][2];
char arr[N];
inline bool check(int l,int r){
	if(arr[l]=='('&&arr[r]==')') return true;
	if(arr[l]=='('&&arr[r]=='?') return true;
	if(arr[l]=='?'&&arr[r]==')') return true;
	if(arr[l]=='?'&&arr[r]=='?') return true;
	return false;
}
signed main()
{
//	freopen("bracket.in","r",stdin);
//	freopen("bracket.out","w",stdout);
	n=read(),k=read();
	cin>>arr+1;
	for(int l=1;l<=n;l++){
		if(arr[l]!='('&&arr[l]!='?') continue;
		int cnt=0;
		for(int r=l+1;r<=n;r++){
			if(arr[r]==')'||arr[r]=='?') dp[l][r][0]=1;
			if(arr[r]!='*'&&arr[r]!='?') break;
			cnt++; if(cnt>k) break;
		}
	}
	for(register int len=2;len<=n;len++){ //枚举区间长度 
		for(register int l=1;l<=n-len+1;l++){ //枚举左端点 
			int r=l+len-1; //右端点
			int cnt=0;
			for(register int x=l;x<r;x++){
				if(arr[x]!='*'&&arr[x]!='?') break;
				cnt++; if(cnt>k) break;
				f[l][r]=(f[l][r]+(dp[x+1][r][0]+dp[x+1][r][1])%MOD)%MOD;
			}
			cnt=0;
			for(register int x=r;x>l;x--){
				if(arr[x]!='*'&&arr[x]!='?') break;
				cnt++; if(cnt>k) break;
				g[l][r]=(g[l][r]+(dp[l][x-1][0]+dp[l][x-1][1])%MOD)%MOD;
			}
			for(register int x=l;x<r;x++)
				dp[l][r][1]=(dp[l][r][1]+dp[l][x][0]*((f[x+1][r]+(dp[x+1][r][0]+dp[x+1][r][1])%MOD)%MOD)%MOD)%MOD;
			if(check(l,r)){ //端点可以为()
				dp[l][r][0]=((dp[l][r][0]+dp[l+1][r-1][0])%MOD+dp[l+1][r-1][1])%MOD;
				dp[l][r][0]=(dp[l][r][0]+f[l+1][r-1])%MOD;
				dp[l][r][0]=(dp[l][r][0]+g[l+1][r-1])%MOD;
			}
			
		}
	}
	printf("%lld\n",(dp[1][n][0]+dp[1][n][1])%MOD);
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：4)

这是一道区间 dp，思维难度与实现难度都不小，主要的瓶颈在于如何不重不漏地转移（这要求仔细地读题）。

和题目一样，`A` 表示一个符合规范的超级括号序列，`S` 表示任意一个仅由不超过 $k$ 个字符 `*` 组成的**非空字符串**，即 `*...*`。以下就不再赘述字符的含义。

先将状态分成以下几类：

- $dp_{i,j,0}$ 表示 $[i,j]$ 的符合规范的超级括号序列的数量

- $dp_{i,j,1}$ 表示 $[i,j]$ 的符合 `(A)` 的形式的数量

- $dp_{i,j,2}$ 表示 $[i,j]$ 的符合 `SA` 的形式的数量

- $dp_{i,j,3}$ 表示 $[i,j]$ 的符合 `AS` 的形式的数量

接下去就是状态转移的过程。

先预处理出一个布尔数组 $g$，若 $g_{i,j} = 1$ ，那么有 $[i,j]$ 为一个 $S$ 串。

对于 `(A)` 的形式，可以由 `*...*`，`SA`，`AS` 和 `A` 加上一对左右括号即可得到。也就是说若 $[i,j]$ 满足 `(A)` 的形式，也就有原字符串的第 $i$ 位为 `(` 或 `?`，第 $j$ 位为 `)` 或 `?`。转移为 $dp_{i,j,1} = g_{i + 1,j - 1} + dp_{i + 1,j - 1,0} + dp_{i + 1,j - 1,2} + dp_{i + 1,j - 1,3}$。相信大家读到这里会有一个疑问，若 $i + 1 = j$，那么会有 $i + 1 > j - 1$，导致答案出错。很简单，由于 `()` 也合法，所以只需要进行一个特判即可。

对于 `SA` 的形式，由一段 `S` 和 `A` 组成，一次设置 $[i,j]$ 的断点 $k$ 来进行转移。转移方程为 $dp_{i,j,2} = \sum_{k = i}^{r - 1} g_{i,k} \times dp_{j + 1,r,2}$。只有在 $[i,k]$ 是 `S` 串时才可以被转移，用乘法便很好的解决了这个问题。

对于 `AS` 的形式大致与上一个相同，转移方程为 $dp_{i,j,3} = \sum_{k = i}^{r - 1} g_{k + 1,r} \times dp_{i,k,3}$。

最后是 $dp_{i,j,0}$ 的转移。$dp_{i,j,1}$ 肯定符合情况，之后需要通过两个小区间来得到大区间，也就是 `AB` 以及 `ASB` 的情况，但是需要考虑到**重复计算的情况**。直接令 `A` 串属于 `(...)` 的情况，这样就能去掉重复计算，因此有转移方程 $dp_{i,j,0} = dp_{i,j,1} + \sum_{k = i}^{r - 1} dp_{i,k,1} \times (dp_{k + 1,r,0} + dp_{k + 1,r,2})$。

因此最后的时间复杂度是 $O(n^3)$ 的，代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 505;
const int MOD = 1e9 + 7;
int n,k;char str[MAX];
ll dp[MAX][MAX][4];bool g[MAX][MAX];
/*dp[l][r][0] 合法答案  最终答案即为 dp[1][n][0] 
dp[l][r][1] (A)     dp[l][r][2] SA    dp[l][r][3] AS*/
bool check (int x,int y);
int main ()
{
	scanf ("%d%d%s",&n,&k,str + 1);	
	for (int i = 1;i <= n;++i)
	{
		for (int j = i;j <= n;++j)
		{
			if (j - i + 1 > k) break;
			bool ok = 1;
			for (int k = i;k <= j;++k)
				if (str[k] != '*' && str[k] != '?') ok = 0;
			if (ok) g[i][j] = 1;//仅由 "*" 组成且不超过 k 个 
		}
	}
	for (int i = 1;i <= n;++i)
	{
		for (int l = 1;l <= n;++l)
		{
			int r = l + i;
			if (r > n) break;
			if (check (l,r))//括号匹配
			{
				if (l == r - 1) dp[l][r][1] = 1;//特判
				else dp[l][r][1] += (g[l + 1][r - 1] + dp[l + 1][r - 1][0] + dp[l + 1][r - 1][2] + dp[l + 1][r - 1][3]) % MOD;
			}
			dp[l][r][0] += dp[l][r][1];
			dp[l][r][0] %= MOD,dp[l][r][1] %= MOD;
			for (int k = l;k < r;++k)
			{
				dp[l][r][2] += g[l][k] * dp[k + 1][r][0];
				dp[l][r][3] += dp[l][k][0] * g[k + 1][r];
				dp[l][r][0] += dp[l][k][1] * (dp[k + 1][r][0] + dp[k + 1][r][2]) % MOD;//去重 所以把前面那个标记成 1 
				for (int p = 0;p < 4;++p) dp[l][r][p] %= MOD;
			}
		}
	}
	printf ("%lld\n",dp[1][n][0]);
	return 0;
}
bool check (int x,int y) {return ((str[x] == '(' || str[x] == '?') && (str[y] == ')' || str[y] == '?'));}
```

---

## 作者：loverintime (赞：4)

### 一道区间 $dp$ （考场居然做出来了）

容易想到令 $f(i,j)$ 表示使得区间 $[i,j]$ 是一个 “超级括号序列” 的方案数， $c(i,j)(=1/0)$ 表示区间 $[i,j]$ 能否构成不超过 $k$ 个 $*$ 的序列， 这个可以预处理。

思考转移（就是题中所给的定义）：

1. 如果 $i,j$ 可以分别是左括号和右括号， 那么 $f(i+1,j-1)$ 对 $f(i,j)$ 有贡献。 特别的， 如果 $c(i+1,j-1)=1$， 那么 $f(i,j)+=1$。

2. 枚举中间节点 $mid$， 如果 $c(i,mid)$ 那么 $f(mid+1,j)$ 对 $f(i,j)$ 有贡献。 如果 $c(mid,j)$ 同理。

3. 同样枚举中间节点 $mid$， 根据乘法原理， $f(i,mid)\times f(mid+1,j)$ 对 $f(i,j)$ 有贡献。 再枚举区间 $[mid,r]$ 中的一个点 $p$, 如果 $c(mid,p)$， 那么 $f(i,mid-1)\times f(p+1,j)$ 对 $f(i,j)$ 有贡献。


先不管时间复杂度， 如果我们按照现在的方程打代码， 如果没有其它问题， 我们会发现第二个样例输出 $28$ ~~（卡了我一个多小时）~~

为什么呢？

考虑序列 $()()()$, 正解显然是 $1$, 但现在的程序会输出 $2$。 现在我们大概明白了：

# 会算重

方程 $3$ 会把序列分成 $(), ()()$ 和 $()(),()$， 分别有一种， 所以会算重。

考虑加一维：

$f(i,j,p)(p=0/1)$ 表示 $[i,j]$ 区间能否用方程 $3$ 的方案数。 稍微改一下上面的转移方程：

1. 如果 $i,j$ 可以分别是左括号和右括号， 那么 $f(i+1,j-1,0)$ 对 $f(i,j,p)$ 有贡献。 特别的， 如果 $c(i+1,j-1)=1$， 那么 $f(i,j,p)+=1$。

2. 枚举中间节点 $mid$， 如果 $c(i,mid)$ 那么 $f(mid+1,j,0)$ 对 $f(i,j,p)$ 有贡献。 如果 $c(mid,j)$ 同理。

3. 同样枚举中间节点 $mid$， 根据乘法原理， $f(i,mid,1)\times f(mid+1,j,0)$ 对 $f(i,j)$ 有贡献。 再枚举区间 $[mid,r]$ 中的一个点 $p$, 如果 $c(mid,p)$， 那么 $f(i,mid-1,1)\times f(p+1,j,0)$ 对 $f(i,j)$ 有贡献。

现在样例就可以全部通过了。

考虑时间复杂度： 状态数 $n^2$, 转移 $n^2$， 总共 $\Theta(n^4)$， $65$ 分。

有一个定律是 满分=部分分+优化。 我们观察 $f(i,mid-1,1)\times f(p+1,j,0)$， 可以写成：

$$f(i,mid-1)\times \sum_{p\in[mid,j-1]\wedge c(mid,p)}f(p+1,j)$$

后面的求和与 $i$ 无关， 且对于不同的 $i$, 都要枚举 $mid$ 算一遍。 考虑记录下来。

令 
$$g(mid,j)=\sum_{p\in[mid,j]\wedge c(mid,p)}f(p+1,j)$$

这样，计算 $f$ 需要 $n^3$， $g$ 需要 $n^3$ （可以优化成 $n^2$， 但优不优化都能过）， 总时间 $\Theta(n^3)$， 可以通过。

考场代码：~~（写的丑，常数还大，还好过了）~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,t;
char a[505];
int f[505][505][2],vis[505][505][2],canbe[505][505],sum[505][505],county[505][505];
void add(int &a,int b){
	a+=b;if(a>=mod) a-=mod;
}
int dp(int l,int r,bool p){
	if(vis[l][r][p]) return f[l][r][p];
	if(l+1==r&&(a[l]=='('||a[l]=='?')&&(a[r]=='?'||a[r]==')')) return 1;
	if(l+1>=r) return 0;
	if(!(a[l]=='('||a[l]=='?')&&(a[r]=='?'||a[r]==')')) return 0;
	vis[l][r][p]=1;
	int &e=f[l][r][p];
	if(!p) for(int mid=l; mid<r; mid++){
		 e=(1ll*e+1ll*dp(l,mid,1)*dp(mid+1,r,0))%mod;
		 if(!county[mid][r]){
		 	  int t=0;
		 	  for(int p=mid; p<r; p++){
				if(canbe[mid][p]){
					t=(t+dp(p+1,r,0))%mod;
				}
			  }
			  sum[mid][r]=t;county[mid][r]=1;
		 }
		e=(e+dp(l,mid-1,1)*1ll*sum[mid][r])%mod;
	}
	if((a[l]=='('||a[l]=='?')&&(a[r]==')'||a[r]=='?')){
		if(canbe[l+1][r-1]) e++,e%=mod;
		add(e,dp(l+1,r-1,0));
		for(int mid=l+1; mid<=r-1; mid++){
			if(canbe[l+1][mid]) add(e,dp(mid+1,r-1,0));
			if(canbe[mid][r-1]) add(e,dp(l+1,mid-1,0));
		}
	}
	return e;
}
int main(){
	scanf("%d%d%s",&n,&t,a);
	for(int i=0; i<n; i++){
		for(int j=i; j<n; j++){
			if(j-i+1>t) break;
			if(a[j]=='*'||a[j]=='?') canbe[i][j]=1;
			else break;
		}
	}
	printf("%d\n",dp(0,n-1,0));
	return 0;
}

---

## 作者：tommymio (赞：4)

难度全部都在读题上。读完题，首先可以确认的是，由于 $(SAS)$ 是非法的，所以线性 $\text{DP}$ 是假算法！

可以将合法括号序列分为两类。

- $(A),(S),(AS),(SA)$ $\color{blue}(1)$
- $AB,ASB$ $\color{blue}(2)$

转移方程？

$f_{l,r}$ ：左端点与右端点匹配的合法括号序列数，例如序列 $\texttt{(((**)()**)***)}$。

$g_{l,r}$ ：左端点与右端点不匹配的合法括号序列数，例如序列 $\texttt{()**()*()}$。

$s_{l,r}$ ：区间 $[l,r]$ 是否是一个合法 $S$ 串。

为什么要这样定义状态呢？可以发现对于第 $\color{blue}(2)$ 类括号序列，可能会出现 $\texttt{(())**()**()**()**(())}$ 这样的串，如果不将序列分类将会多次计算此贡献。

**约定，此处 $a \rightarrow b$ 等同于 $a = a+b$。**

对于第 $\color{blue}(1)$ 类：
$$
f_{l,r} \rightarrow f_{l+1,i}+g_{l+1,i} \ (s_{i+1,r-1}=1)
$$

$$
f_{l,r}\rightarrow f_{i,r-1}+g_{i,r-1} \ (s_{l+1,i-1}=1)
$$

$$
f_{l,r} \rightarrow f_{l+1,r-1}+g_{l+1,r-1}
$$

$$
f_{l,r} \rightarrow 1 \ (s_{l+1,r-1}=1)
$$

对于第 $\color{blue}(2)$ 类：
$$
g_{l,r} \rightarrow (f_{l,i}+g_{l,i})\times f_{i+1,r}
$$

$$
g_{l,r} \rightarrow (f_{l,i}+g_{l,i})\times f_{i+j+1,r} \ (s_{i+1,i+j}=1)
$$
$g_{l,r}$ 的第二个转移式其实蕴含了第一个转移式。时间复杂度为 $O(n^4)$，瓶颈在第二个转移式。

记
$$
ss_{p,r}=\sum f_{l,r}(s_{p,l-1} = 1)
$$


则
$$
g_{l,r} \rightarrow (f_{l,i}+g_{l,i})\times ss_{i+1,r}
$$

时间复杂度降为 $O(n^3)$。

代码严格按照转移方程随手写的，看看就好 ×

```cpp
/* stuff you should look for
	* int overflow, array bounds, uppercase/lowercase
	* special cases (n=1?)
	* do sth. instead of nothing and stay organized
	* WRITE STUFF DOWN
	* DON'T GET STUCK ON ONE APPROACH
*/
#include<cstdio>
const int mod=1e9+7;
int n,k;
char s[1005];
int b[1005][1005],f[1005][1005],g[1005][1005],ss[1005][1005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
int main() {
	n=read(); k=read();
	scanf("%s",s+1);
	for(register int i=1;i<=n;++i) {
		for(register int j=i;j<=i+k-1;++j) {
			if(s[j]!='*'&&s[j]!='?') break;
			b[i][j]=1;
		}
	}
//	for(register int i=1;i<=n;++i) {
//		for(register int j=i;j<=n;++j) {
//			printf("(%d,%d)%d ",i,j,b[i][j]);
//		}
//		printf("\n");
//	}
	for(register int i=1;i<n;++i) {
		if((s[i]=='('||s[i]=='?')&&(s[i+1]==')'||s[i+1]=='?')) f[i][i+1]=1;
		for(register int p=i-1;p>=1&&i-p<=k;--p) {
			if(b[p][i-1]) {
				ss[p][i+1]+=f[i][i+1];
				if(ss[p][i+1]>=mod) ss[p][i+1]-=mod;
			}
		}
	}
	for(register int len=3;len<=n;++len) {
		for(register int l=1;l<=n-len+1;++l) {
			int r=l+len-1;
			if((s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?')) {
				for(register int i=l+1;i<r-1;++i) {
					if(!b[i+1][r-1]) continue;
					f[l][r]+=(f[l+1][i]+g[l+1][i])%mod;
					if(f[l][r]>=mod) f[l][r]-=mod;
				}
				for(register int i=r-1;i>l+1;--i) {
					if(!b[l+1][i-1]) continue;
					f[l][r]+=(f[i][r-1]+g[i][r-1])%mod;
					if(f[l][r]>=mod) f[l][r]-=mod;
				}
				f[l][r]+=(f[l+1][r-1]+g[l+1][r-1])%mod;
				if(f[l][r]>=mod) f[l][r]-=mod;
				if(b[l+1][r-1]) {
					++f[l][r];
					if(f[l][r]>=mod) f[l][r]-=mod;
				}
				for(register int i=l;i<r;++i) {
					g[l][r]+=(f[l][i]+g[l][i])%mod*1ll*f[i+1][r]%mod;
					if(g[l][r]>=mod) g[l][r]-=mod;
				}
				for(register int p=l-1;p>=1&&l-p<=k;--p) {
					if(b[p][l-1]) {
						ss[p][r]+=f[l][r];
						if(ss[p][r]>=mod) ss[p][r]-=mod;
					}
				}
				for(register int i=l;i<r;++i) {
					g[l][r]+=(f[l][i]+g[l][i])%mod*1ll*ss[i+1][r]%mod;
					if(g[l][r]>=mod) g[l][r]-=mod;
				}
//				for(register int i=l;i<r;++i) {
//					for(register int j=1;j<=k&&i+j<r;++j) {
//						if(!b[i+1][i+j]) continue;
//						g[l][r]+=(f[l][i]+g[l][i])%mod*1ll*f[i+j+1][r]%mod;
//						if(g[l][r]>=mod) g[l][r]-=mod;
//					}
//				}
			}
		}
	}
	printf("%d\n",(f[1][n]+g[1][n])%mod);
	return 0;
}

```



---

## 作者：halley20 (赞：3)

## 前言
本人是个考场上在那干坐着的蒟蒻。
赛后听了老师讲解才做出来这道题。看了众多大佬的思路，觉得还是看不懂。我太菜了，所以只能使用一个超级简化版的解法，有什么不足欢迎随时打脸。
~~（因为这是我的第一篇题解）~~


## 思路

### 状态定义
一般来说，这种需要考虑序列上最优解的都是区间DP。所以我们先进行状态定义。

令 $f_{l,r}=k$ 表示原字符串 $[l,r]$ 区间中能凑成符合题意的超级括号序列 $k$ 个（$k$ 已经取模）。

### 状态转移

在开始讲之前，我先定义如下字符串和变量。如无特殊说明，它们的边界条件都按照这里的为准。

- $str$ 表示原字符串，下标从 $1$ 到 $n$。
- $len$ 表示转移区间的长度，取值从 $2$ 到 $n$（从 $2$ 开始的原因是最短的超级括号序列长度为 $2$ ）。
- $l$ 表示转移区间的左边界，取值从 $1$ 到 $n-len+1$。
- $r$ 表示转移区间的右边界，取值为 $l+len-1$ 到 $n$。

然后我们对 $f_{l,r}$ 转移的方式进行分类讨论。

我们可以将转移方式，也就是超级括号序列的组成方式分为两大类：有括号包裹和没有括号包裹。

那什么叫“有括号包裹”？

顾名思义，当且仅当字符串 $s_{1 \ldots n}$ 中的 $s_1 = \texttt ($ 且 $s_n = \texttt )$ 时，我们称字符串 $s_{1...n}$“有括号包裹”。

言归正传，超级括号序列的构成方式中，有 5 种方式是有括号包裹的。

分别是：```()```、```(S)```、```(A)```、```(SA)``` 和 ```(AS)```。

#### 1. 我们先来考虑怎样转移前两种：```()``` 和 ```(S)```。

转移的方法很简单：$f_{l,r} = f_{l,r} + cmp(l,r) \cdot (S_{l+1,r-1} || l-r+1=2 )$。

- 其中，$cmp(l,r)$ 表示在原字符串中，$str_l$ 等于 ```(``` 或 ```?```，并且 $str_r$ 等于 ```)``` 或者 ```?```。如果是，那么返回 $1$，如果不是，那么返回 $0$。
- $S_{i,j}$ 则表示原字符串中区间 $[l,r]$ 是否全由 ```*``` 和 ```?``` 组成。如果是，那么 $S_{i,j}$ 取值为 $1$，反之则为 $0$。

#### 2. 我们再来考虑 ```(A)```。

$f_{l,r} = f_{l,r} + cmp(l,r) \cdot f_{l+1,r-1}$

- 没什么好补充的，但要注意不要和形式 ```(SA)``` 和 ```(AS)``` 弄混。

#### 3. 最后来考虑 ```(SA)``` 和 ```(AS)```。

这两种情况需要枚举一个分割中心点 $mid$ 来区分字符串 ```A``` 和字符串 ```S```。

$mid$ 的取值范围可以从 $l+1$ 一直到 $r-2$。状态转移方程如下。

(SA):


$f_{i,j} = f_{l,r} + S_{l+1,mid} \cdot f_{mid+1,r-1}$

(AS):

$f_{i,j} = f_{l,r} + f_{l+1,mid} \cdot S_{mid+1,r-1}$

- 这两个可以合并在一个循环里处理。

现在再来考虑没有括号包裹的。

没有括号包裹的只有两种：```AB``` 和 ```ASB```。

#### 1. 先考虑 ```AB```。

通过枚举中心点 $mid$（$l \leq mid \leq r-1$）,我们几乎可以直接得出下面的状态转移方程

$f_{l,r} = f_{l,r} + f_{l,mid} \cdot f_{mid+1,r}$

但我们得仔细考虑考虑，它的正确性有保障吗？

相信聪明的你不久就能想出来，它的确是有 bug 的。

考虑下面这个例子：

```
123456789
(**)(*)()

如果采用上面的状态转移方程：
f[1][4] = 1
f[5][7] = 1
f[8][9] = 1
---
f[1][7] = f[1][4] * f[5][7] = 1
f[5][9] = f[5][7] * f[8][9] = 1
---
f[1][9] += f[1][4] * f[5][9] = 1
		+= f[1][7] * f[8][9] = 1
		= 2
这明显不对
```
那该怎么解决这个问题呢？

我们考虑新维护一个 $pap_{l,r}$ 表示区间 $[l,r]$ 中能凑出多少个**必须有括号包裹且不是拼接起来的**超级括号序列。

思考一下，为什么必须要有括号包裹且不是拼接起来的呢？

那是因为如果序列 ```A``` 是 ```AC``` 形式的超级括号序列，原 ```AB``` 序列就会变成这样：```ACB```。

我们有两种分割方式：```A/CB``` 和 ```AC/B```。

而我们只允许其中的一种分割方式，不然会算重。因此原序列中的序列 ```A``` 不能是拼接起来的，这样就不会有第二种分割方式了，就像这样：```(A)/B```。

而且，如果 A 是类似 ```(D)(E)``` 这个形式的话，那就和没用括号隔开前没什么区别了，一样会算重（就像这样：```(D)/(E)B``` 和 ```(D)(E)/B```）。
 
因此，在合并的时候， ```A``` 序列必须是有括号包裹且不是拼接起来的，剩下的随意。

所以，我们得到了一个新的状态转移方程：

$f_{l,r} = pap_{l,mid} \cdot f_{mid+1,r} $

现在我们再次考虑刚才的例子。

```
123456789
(**)(*)()

如果采用新的状态转移方程
f[1][4] = pap[1][4] = 1
f[5][7] = pap[5][7] = 1
f[8][9] = pap[8][9] = 1
---
f[1][7] = pap[1][4] * f[5][7] = 1
f[5][9] = pap[5][7] * f[8][9] = 1
---
f[1][9] += pap[1][4] * f[5][9] = 1
		+= pap[1][7] * f[8][9] = 0
		= 1
这是正确的
```

#### 2. 考虑 ```ASB```。

通过枚举中心点 $q$ 和 $p$( $l \leq q < p \leq r-1$ )，我们可以得出下列状态转移方程：

$f_{l,r} = f_{l,r} + pap_{l,q} \cdot S_{q+1,p} \cdot f_{p+1,r}$

至于为什么要用 $pap$ 转移，和前面的原因类似，这里我就不再赘述了，请读者们自己思考。

### 优化

刚才我们已经得到了一份正确的代码……但是并不能 AC。因为我们最多用了四重循环（形式 ```ASB```），所以复杂度达到了惊人的 $O(n^4)$！这是肯定会TLE的（不信你算算 $500^4$ )。所以我们必须考虑一些优化。

考虑维护数组 $sb_{l,r}$ ~~（别想了，不是那个意思）~~ 表示区间 $[l,r]$ 中有多少种方法能凑成形式为 SB 的字符串（当然，它们都不是超级括号序列）。维护只要用 $O(n)$ 的复杂度枚举分割点 $mid$。其它形式的时间复杂度都没有超过 $O(n)$ 的。再加上本就有的枚举 $len$ 和 $l$ 所用的 $O(n^2)$ 时间，总时间复杂度保持在了 $O(n^3)$ 以内，可以通过本题。

## Code

对了，写代码的时候别忘了取模和开 ```long long```。而且刚才我认为我已经把思路说得挺清楚了，所以就不加注释了，还请见谅。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
int n,k;
int s[505][505];
char str[505];
long long f[505][505],pap[505][505],sb[505][505];
bool cmp(int l,int r)
{
	return (str[l]=='('||str[l]=='?')&&(str[r]==')'||str[r]=='?');
}
int main()
{
    scanf("%d %d",&n,&k);
    scanf("%s",str+1);
    for(int l=1;l<=n;l++)
    {
        s[l][l-1]=1;
        for(int r=l;r<=n&&r<=l+k-1;r++)
        {
            if(str[r]!='*'&&str[r]!='?')
            {
                break;
            }
            s[l][r]=1;
        }
    }
    for(int len=2;len<=n;len++)
    {
        for(int l=1;l<=n-len+1;l++)
        {
            int r=l+len-1;
            f[l][r]+=f[l+1][r-1]+s[l+1][r-1]*cmp(l,r);
            f[l][r]%=mod;
            pap[l][r]+=f[l+1][r-1]+s[l+1][r-1]*cmp(l,r);
            pap[l][r]%=mod;
            for(int m=l+1;m<=r-2;m++)
            {
                f[l][r]+=s[l+1][m]*f[m+1][r-1]*cmp(l,r);
                f[l][r]%=mod;
                pap[l][r]+=s[l+1][m]*f[m+1][r-1]*cmp(l,r);
                pap[l][r]%=mod;
                f[l][r]+=f[l+1][m]*s[m+1][r-1]*cmp(l,r);
                f[l][r]%=mod;
                pap[l][r]+=f[l+1][m]*s[m+1][r-1]*cmp(l,r);
                pap[l][r]%=mod;
            }
            for(int m=l;m<=r-1;m++)
            {
                f[l][r]+=pap[l][m]*f[m+1][r];
                f[l][r]%=mod;
                f[l][r]+=pap[l][m]*sb[m+1][r];
                f[l][r]%=mod;
                sb[l][r]+=s[l][m]*f[m+1][r];
                sb[l][r]%=mod;
            }
        }
    }
    printf("%lld\n",f[1][n]%mod);
    return 0;
}

```

## THE END

---

## 作者：Exschawasion (赞：2)

首先很容易可以看出这是一个区间 dp，设状态：

- $f[l][r]$ 表示区间 $[l,r]$ 合法的可能性之数目；

直接算很困难的，那就多设几种状态作为辅助：

- $S[l][r]$ 表示 $[l,r]$ 能不能是 `S` 型字符串，能则为 $1$，不能则为 $0$；
- $SA[l][r]$ 表示区间 $[l,r]$ 能够组成的 `SA` 型字符串的数目（这里忽略括号，也就是诸如 `***()` 的，下同）；
- $AS[l][r]$ 表示区间 $[l,r]$ 能够组成的 `AS` 型字符串的数目。

考虑如何计算这些辅助数组：

- $S[l][r]$：直接枚举每个字符检查 $[l,r]$ 能不能是 $S$ 型字符串即可；
- $SA[l][r]$：计算出 $S$ 后，通过枚举中点 $m$，答案为 $\sum_ {m=l}^{r-1} S[l][m] \times f[m+1][r]$；
- $AS[l][r]$：同理，答案为 $\sum_ {m=l+1}^{r} S[l][m-1] \times f[m][r]$。

这里递归地使用了 $f$ 数组，也就是要递归计算。具体见下。

接着用如上的三个辅助数组，来解决题目中所说的每种字符串。

- `(S)` 型字符串：判断两边能不能是对应括号即可，如果可以，贡献为 $S[l+1][r-1]$，否则为 $0$；
- `(A)` 型字符串：同上先做判断，贡献为 $f[l+1][r-1]$；
- `(SA)` 型字符串：同上先做判断，贡献为 $SA[l+1][r-1]$；
- `(AS)` 型字符串：同上先做判断，贡献为 $AS[l+1][r-1]$；
- `AB` 型字符串：

按套路枚举中点的话，会重复计算，考虑字符串 `()??()`，直接分割会把 `()()()` 算两次得到答案 $3$，其实答案是 $2$。

原因在于左右两部分都分割可能导致分割出重复的段。既然如此，**强制一段不允许分割**即可。把 $f$ 数组加一维变成 $f[l][r][c]$，$c=0$ 表示不允许分割，$c=1$ 表示允许。贡献为：

$$\sum_{m=l}^{r-1} f[l][m][0] \times f[m+1][r][1]$$

- `ASB` 型字符串：

与 `AB` 型很相似，可以看成是 `A` 和 `SA` 型连接。因为在计算 $SA$ 数组的时候**没有考虑是否能分割**，为了方便，强制左边的 `A` 为不可分割的。贡献为：

$$\sum_{m=l}^{r-1} f[l][m][0] \times SA[m+1][r][1]$$

于是六种字符串就都解决完了，每种数组都要开个记忆化来加快计算速度。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500+5;
const int mod=1e9+7;
#define int long long
char s[maxn];
int n,k;
inline bool eql(char a,char b){if(a=='?'||b=='?')return 1;return a==b;}
int Sf[maxn][maxn];
inline bool S(int l,int r){
	if(r-l+1>k)return 0;
	if(~Sf[l][r])return Sf[l][r];
	for(int i=l;i<=r;i++)if(!eql(s[i],'*'))return Sf[l][r]=0;
	return Sf[l][r]=1;
}
int dp(int l,int r,bool cuttable);
int SAf[maxn][maxn];
int SA(int l,int r){
	int ans=0;
	if(~SAf[l][r])return SAf[l][r];
	for(int i=l;i+1<=r;i++){
		if(S(l,i))ans=(ans+dp(i+1,r,1))%mod;
		else break;
	}
	return SAf[l][r]=ans;
}
int ASf[maxn][maxn];
int AS(int l,int r){
	int ans=0;
	if(~ASf[l][r])return ASf[l][r];
	for(int i=r;i-1>=l;i--){
		if(S(i,r))ans=(ans+dp(l,i-1,1))%mod;
		else break;
	}
	return ASf[l][r]=ans;
}

int f[maxn][maxn][2];
int dp(int l,int r,bool cuttable){
	int ans=0;
	if(l>=r)return 0;
	if(~f[l][r][cuttable])return f[l][r][cuttable];
	if(eql(s[l],'(')&&eql(s[r],')')){
		if(S(l+1,r-1))ans=(ans+1)%mod;
		ans=(ans+dp(l+1,r-1,1))%mod;
		ans=(ans+SA(l+1,r-1))%mod;
		ans=(ans+AS(l+1,r-1))%mod;
	}
	if(cuttable){
		for(int mid=l;mid+1<=r;mid++){
			ans=(ans+dp(l,mid,0)*dp(mid+1,r,1)%mod)%mod;
			ans=(ans+dp(l,mid,0)*SA(mid+1,r)%mod)%mod;
		}
	}
	return f[l][r][cuttable]=ans;
}
signed main(){
	memset(f,-1,sizeof(f));
	memset(SAf,-1,sizeof(SAf));
	memset(ASf,-1,sizeof(ASf));
	memset(Sf,-1,sizeof(Sf));
	cin>>n>>k;
	scanf("%s",s+1);
	cout<<dp(1,n,1)<<endl;
	return 0;
}
```


---

## 作者：Utilokasteinn (赞：2)

## [Link](https://www.luogu.com.cn/problem/P7914)

显然，这是一道区间 $\tt DP$。

$\tt DP$ 最重要的就是设状态。考虑如何设计才能不重不漏地统计所有状态。

然后会发现非常不好转移，容易会有重复计算的状态。

按照传统区间 $\tt DP$ 的思路，我们先设 $f_{l,r,0}$ 表示区间 $[l,r]$ 的左右端点都不为 ```*``` 的方案数，$f_{l,r,1}$ 表示区间 $[l,r]$ 的左端点为 ```*``` 且右端点不为 ```*``` 的方案数，$f_{l,r,2}$ 表示区间 $[l,r]$ 的左端点不为 ```*``` 且右端点为 ```*``` 的方案数，$f_{l,r,3}$ 表示区间 $[l,r]$ 的左右端点都为 ```*``` 的方案数。

为了方便，再设一个 $f_{l,r,4}$ 表示区间 $[l,r]$ 全为 ```*``` 的方案数。

显然，$f_{l,r,4}$ 属于 $f_{l,r,3}$。

然后开始想状态转移方程。

容易得出 $f_{l,r,0}=\sum_{i=l}^{r-1}(f_{l,i,2}+f_{l,i,0})\times f_{i+1,r,0}$。

但是这是错的，例如 ```()()()```，```()``` 和 ```()()``` 会算一次，```()()``` 和 ```()``` 会再算一次。

于是我们再设 $f_{l,r,5}$ 表示区间 $[l,r]$ 的左右端点都不为 ```*```，且左右端点是同一对括号时的方案数。

显然，$f_{l,r,5}$ 属于 $f_{l,r,0}$。

那么 $f_{l,r,0}=\sum_{i=l}^{r-1}(f_{l,i,2}+f_{l,i,0})\times f_{i+1,r,5}$。

剩下的转移方程同理。

这里再写一下如何判断是否 $k$ 个 ```*``` 连在一起。

其实很简单，状态转移的时候换一个思路转移，例如 ```()*****()()``` 总是可以从旁边转移。需要再注意一下 ```()*****()``` 和 ```()``` 会重复算一次。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
int n,k;
ll f[505][505][6];
char s[505];
int main()
{
    scanf("%d%d\n%s",&n,&k,s+1);
    for(int i=1;i<=n;i++)
		f[i][i-1][4]=1;
    for(int len=1;len<=n;len++)
	{
        for(int l=1;l+len-1<=n;l++)
		{
            int r=l+len-1;
            //0：左右都不是* 
			//1：左是*，右不是*
			//2：左不是*，右是*
			//3：左右都是* 
			//4：全都是* 
			//5：左右都不是*，且最左边与最右边对应 
			//4属于3，5属于0
            for(int i=l;i<r;i++)
			{
				f[l][r][0]=(f[l][r][0]+(f[l][i][2]+f[l][i][0])*f[i+1][r][5])%mod;
                f[l][r][1]=(f[l][r][1]+(f[l][i][1]+f[l][i][3])*f[i+1][r][5])%mod;
                f[l][r][2]=(f[l][r][2]+f[l][i][0]*f[i+1][r][4])%mod;
                f[l][r][3]=(f[l][r][3]+f[l][i][1]*f[i+1][r][4])%mod;
            }
            if(len<=k&&(s[r]=='*'||s[r]=='?'))
				f[l][r][4]=f[l][r-1][4];
            if((s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?'))
				f[l][r][5]=(f[l+1][r-1][4]+f[l+1][r-1][2]+f[l+1][r-1][0]+f[l+1][r-1][1])%mod;
			f[l][r][0]=(f[l][r][0]+f[l][r][5])%mod;
            f[l][r][3]=(f[l][r][3]+f[l][r][4])%mod;
        }
    }
    printf("%lld\n",f[1][n][0]);
    return 0;
}
```


---

## 作者：Unnamed114514 (赞：1)

看到括号序列，考虑区间 dp。

首先你求出 $chk_{l,r}$ 表示 $[l,r]$ 是否能改成全 `*`。

定义 $dp_{l,r}$ 表示 $[l,r]$ 的方案数。

- 情况 $1$：`SA` 或 `AS`

这种情况下，你肯定要枚举前后缀。

但是注意到你如果直接枚举，那么你枚举一次之后就会枚举第二次，就可能会出现左右都有 `*`（`SAS`，在题意中没有这种情况）或者两次枚举 `*` 在同一边导致长度超过了 $k$。

于是我们在 $dp$ 后面的定义再加一维：$0/1$ 表示两端是否能加 `*`，这个问题就处理了。

注意：在 $r-l+1\le k$ 时，$[l,r]$ 同时是前缀和后缀，要特判。

- 情况 $2$：`()` 或 `(S)` 或 `(A)` 或 `(SA)` 或 `(AS)` 

其实 `(SA)` 和 `(AS)` 就是 `(A)` 的情况。

这些情况会有统一特性：有匹配的括号。

你枚举左端点匹配的有括号的位置 $i$。

注意到 `(A)` 其实包含了 `ASB` 的情况。

那么就会存在一个问题：

这个 `SB` 部分，左边可以接 `*`，右边不能（否则出现了 `ABS` 的情况，是不允许的），那么一个 $0/1$ 显然是不够的，于是我们在定义后面接两个 $0/1$ 表示左右是否能接 `*`。

那么这个定义就完整了：$dp_{l,r,0/1,0/1}$ 表示 $[l,r]$ 中，$l$ 是否能是 `*`，$r$ 是否能是 `*`（这样能表示前后缀）的方案数。

为什么不会算重呢？首先 $l$ 不能是 `)`，$l$ 为 `(` 的情况就是情况 $2$ 以及 `AS`，$l$ 为 `*` 的情况就是 `SA`。

那么 `AS` 会在两种情况都算吗？不会的，因为我们枚举分割点 $i$ 之后，转移到 $dp_{i+1,r,1,0}$，$[i+1,r]$ 一定不会全是 `*`，因为 $s_r$ 一定不是 `*`。也就是说，不会出现 `AS` 的情况，所以不会算重。

题外话：不会出现 $dp_{l,r,0,1}$ 的情况，所以本质上只有 $3$ 个状态，具体实现用的记搜。

```cpp 
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,k,dp[505][505][2][2];
string s;
bool chk[505][505];
int dfs(int l,int r,bool op1,bool op2){
    if(l>r) return 1;
    if(!op1&&s[l]=='*') return 0;
    if(!op2&&s[r]=='*') return 0;
    if(l==r) return op1&&op2&&(s[l]=='*'||s[l]=='?');
    if(~dp[l][r][op1][op2]) return dp[l][r][op1][op2];
    dp[l][r][op1][op2]=0;
    if(op1){
        for(int i=l;i<=l+k-1&&i<r;++i) 
            if(chk[l][i]) dp[l][r][op1][op2]=(dp[l][r][op1][op2]+dfs(i+1,r,0,0))%mod; 
            else break;
    }
    if(op2){
        for(int i=r;i>=r-k+1&&i>l;--i) 
            if(chk[i][r]) dp[l][r][op1][op2]=(dp[l][r][op1][op2]+dfs(l,i-1,0,0))%mod;
            else break;
    }
    if(op1&&op2&&r-l+1<=k&&chk[l][r]) dp[l][r][op1][op2]=(dp[l][r][op1][op2]+1)%mod;
    if(s[l]=='('||s[l]=='?') for(int i=l+1;i<=r;++i) if(s[i]==')'||s[i]=='?') dp[l][r][op1][op2]=(dp[l][r][op1][op2]+dfs(l+1,i-1,1,1)*dfs(i+1,r,1,0))%mod;
    return dp[l][r][op1][op2];
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>k>>s,s=' '+s;
    for(int i=1;i<=n;++i) for(int j=i;j<=n;++j)
        if(s[j]=='*'||s[j]=='?') chk[i][j]=1;
        else break;
    if(s[1]==')'||s[1]=='*'||s[n]=='('||s[n]=='*'){
        cout<<0<<endl;
        return 0;
    }
    memset(dp,-1,sizeof(dp));
    cout<<dfs(1,n,0,0)<<endl;
    return 0;
}
```

---

## 作者：Yansuan_HCl (赞：1)

首先需要想到是区间 dp.

设 $f[l][r]$ 为 $[l,r]$ 区间合法的括号序列，则会发现根本没法做。

回顾题目的定义：

1. `()`、`(S)` 是合法的。
	- 若 $[l+1,r-1]$ 可以全为 `*`，则存在一种方案。特别地，$[i,i-1]$ 特定为可以全为 `*` 以支持 `()` 的转移。
    - 预处理 $g[l][r]$ 表示 $[l,r]$ 是否能全为 `*`。
    - $f[l][r][1] \gets [g[l+1][r-1]]$。
    
1. `AB`、`ASB` 是合法的。
	- 区间 dp 套路，枚举分割点 $k$，合并两边的合法序列（从 `A` 和 `B` 或 `AS` 和 `B` 转移）。
    - 这样会算重。例如 `() (()) (())`，其中空格是分割点。
    - 为了规避算重，我们可以**钦定**加入的一段是 `(...)` 的形式。
    - $f[l][r][0] \gets f[l][k][0..2] \times f[k+1][r][1]$。

1. `(A)`、`(SA)`、`(AS)` 是合法的。
	- 只需把 $[l+1][r-1]$ 的 `A`、`SA`、`AS` “套入”括号内即可。

具体实现可以参考代码。

```cpp
const int N = 505;
const ll P = 1000000007;
int n, k;
char s[N];

// f[l][r][0]: AB,ASB
// f[l][r][1]: (A)
// f[l][r][2]: AS
// f[l][r][3]: SA
// 钦定 ASB 是由 AS 和 (B) 转移而成。
// 钦定 AB 是 A 和 (B).

ll f[N][N][4];
int canS[N][N]; // [l, r] 能否全为 *

il int canLR(int i, int j) {
    return (s[i] == '(' || s[i] == '?') && (s[j] == ')' || s[j] == '?');
}

il void transfer(int i, int j) {
    U (k, i + 1, j - 2) {
        (f[i][j][0] += (f[i][k][0] + f[i][k][2] + f[i][k][1]) % P
        	* f[k + 1][j][1]) %= P;
        // 乘法原理，两边方案乘起来。
    }
    U (k, i, j) {
        if (canS[i][k]) // SA 由 S 和 A 转移。
            (f[i][j][3] += f[k + 1][j][0] + f[k + 1][j][1]) %= P;
        if (canS[k][j]) // AS 同理。
            (f[i][j][2] += f[i][k - 1][0] + f[i][k - 1][1]) %= P;
    }
}

int main() {
    rd(n, k);
    scanf("%s", s + 1);
    U (i, 1, n) { // 预处理 g
        U (j, i, min(n, i + k - 1)) {
            if (s[j] != '*' && s[j] != '?') break;
            canS[i][j] = 1;
        }
        if (i > 1)
            canS[i][i - 1] = 1;
    }
    
    U (l, 2, n) {
        for (int i = 1, j = l; j <= n; ++i, ++j) { // 大力转移
            if (canLR(i, j)) { // 首先 (i, j) 要有可能配成左右括号
                if (canS[i + 1][j - 1]) ++f[i][j][1];
                (f[i][j][1] += f[i + 1][j - 1][1] + f[i + 1][j - 1][0] + f[i + 1][j - 1][2] + f[i + 1][j - 1][3]) %= P;
                // A、SA、AS、(A) 套进括号里。
            }
  
            transfer(i, j);
        }
    }
    
    printf("%lld\n", (f[1][n][0] + f[1][n][1]) % P);
}
```

---


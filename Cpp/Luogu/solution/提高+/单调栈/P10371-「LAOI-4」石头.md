# 「LAOI-4」石头

## 题目描述

有一个长度为 $n$ 的排列 $a$，初始可以任意染白一个数，然后接下来每一步可以染白最小的一个与已经被染白的数相邻的数，显然 $n$ 步之后所有数都会被染白。

现在我们称满足以下要求的数对 $(i,j)$ 是好的数对：

- $1\leq i\leq j\leq n$。
- 存在一个 $k$，满足若从 $a_i$ 开始染白，$a_j$ 会在第 $k$ 步被染白；若从 $a_j$ 开始染白，$a_i$ 也会在第 $k$ 步被染白。

求好的数对的数量。

## 说明/提示

### 样例解释

对于样例组 #1，$a=\{4,3,1,5,2\}$，好的数对分别是：$(1,1),(1,3),(1,5),(2,2),(2,3),(2,4),(3,3),(4,4),(5,5)$。

### 数据范围

**「本题采用捆绑测试」**

|子任务编号|$n$|特殊性质|分值|
|:-:|:-:|:-:|:-:|
|$1$|$\le10^3$|无|$15$|
|$2$|$\le10^5$|无|$30$|
|$3$|$\le10^7$|$\text{A}$|$5$|
|$4$|$\le10^7$|无|$50$|

对于 $100\%$ 的数据，保证 $1\le n\le 10^7$，$0\leq s\leq 114514$，$a$ 为 $n$ 的排列。  

特殊性质 $\text{A}$：$a_i$ 单调递增，此时 $s=0$。  

## 样例 #1

### 输入

```
5 114514```

### 输出

```
9```

## 样例 #2

### 输入

```
10 113037```

### 输出

```
23```

## 样例 #3

### 输入

```
20 73555```

### 输出

```
49```

# 题解

## 作者：int_R (赞：11)

记 $l_{x,0},l_{x,1},r_{x,0},r_{x,1}$ 分别为位置 $x$ 左边第一个，左边第二个，右边第一个，右边第二个 $>a_x$ 的数。

对于 $(l,r),l<r$，记 $p$ 是区间 $[l,r]$ 的最大值的位置，$q$ 是区间 $[l,r]$ 的次大值的位置。

假设最大值不位于端点即 $l<p<r$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n7lnljh0.png)

则从 $l$ 到 $r$ 需要的步数是 $r-l_{p,0}$，因为左边所有 $<a_p$ 的数都会在 $p$ 被染色前被染色。

那么对于 $(l,r),l<p<r$ 是合法的区间，当且仅当 $r-l_{p,0}=r_{p,0}-l$ 即 $l-l_{p,0}=r_{p,0}-r$。

综上对于区间最大值为 $a_p$ 且最大值不位于端点的合法区间数是 $\min(p-l_{p,0}-1,r_{p,0}-p-1)$，即端点取满左边或右边。

枚举 $p$ 即可算出全部贡献。

----

当最大值位于一个端点，假设位于 $l$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ibbqt4qa.png)

此时 $l=p=l_{q,0}$，因为 $a_p$ 是最大值所以 $a_p>a_q$，因为 $a_q$ 是次大值，所以 $p$ 是左边第一个 $>a_q$ 的位置。

同时 $l$ 到 $r$ 的步数变为了 $r-l_{q,1}$，因为 $p$ 一开始就被染色所以左边只有 $<q$ 的才会被染色。

此时则要求 $p-l_{q,1}=r_{p,0}-r$ 即 $r=r_{p,0}-(p-l_{q,1})$，判断 $r$ 的位置在 $[q,r_{q,0})$ 中才能保证区间次大值为 $q$。

枚举 $q$ 即可算出全部贡献。

----

还要算上 $l=r$ 的情况，可以最后单独加，也可以直接在第一部分中计算上。

所以计算贡献的时间复杂度是 $O(n)$ 的。

问题转化成求每个位置 $x$ 左边第一个，左边第二个，右边第一个，右边第二个 $>a_x$ 的数。可以使用链表。

具体的，从小到大删去数，在删去之前从链表上找所在位置的前驱，前驱的前驱，后继，后继的后继即可。

所以总时间复杂度是 $O(n)$ 的。

```cpp
int main()
{
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>n>>s;srand_(s,n);
    u[0]=0,v[0]=1,u[n+1]=n,v[n+1]=n+1;//初始化链表
    for(int i=1;i<=n;++i)
        b[a[i]]=i,u[i]=i-1,v[i]=i+1;
    for(int i=1;i<=n;++i)
    {
        int cur=b[i];//找到 i 对应的位置
        l[cur][0]=u[cur],l[cur][1]=u[u[cur]];
        r[cur][0]=v[cur],r[cur][1]=v[v[cur]];
      	//下面计算第一部分，同时加上了 l=r 的情况
        ans+=min(r[cur][0]-cur,cur-l[cur][0]);
        u[v[cur]]=u[cur],v[u[cur]]=v[cur];
    }
    for(int q=1,p,cur;q<=n;++q)//计算第二部分
    {
        p=l[q][0],cur=r[p][0]-(p-l[q][1]);
        if(cur>=q&&cur<r[q][0]) ++ans;
        p=r[q][0],cur=l[p][0]+(r[q][1]-p);
        if(cur>l[q][0]&&cur<=q) ++ans;
    }
    cout<<ans<<'\n';return 0;
}
```

---

## 作者：Creeper_l (赞：4)

原题链接：[P10371](https://www.luogu.com.cn/problem/P10371)。

首先我们设 $l_{i,0/1}$ 表示 $i$ 左边的第一，二个比 $a_i$ 大的数的位置。$r_{i,0/1}$ 同理。

考虑一个区间 $[L,R]$ 在什么时候满足条件，设 $p,q$ 分别为区间中最大 / 次大值的位置，我们分三种情况讨论。

- 情况一：$L < p < R$。

考虑从 $L,R$ 开始选数分别会选到哪些数。

1. 从 $L$ 开始，会选到 $(l_{p,0},R]$ 这些数。因为当要选 $a_p$ 的时候，一定会先选完 $(l_{p,0},p-1]$ 这些数（因为这些数都比 $a_p$ 小），而且肯定不会选到 $l_{p,0}$，因为区间 $(l_{p,0},R]$ 中的所有数都比它小。

2. 从 $R$ 开始，会选到 $[L,r_{p,0})$ 这些数，证明同理。

会发现如果 $[L,R]$ 这个区间合法的充要条件为 $L-l_{p,0}=r_{p,0}-R$ 且 $L > l_{p,0},R < r_{p,0}$（否则 $a_p$ 就不是区间最大值了），所以我们可以枚举每一个 $p$，那么当前 $p$ 的贡献（$L,R$ 可取的位置数）为 $\min(r_{p,0} - p - 1,p - l_{p,0} - 1)$，时间复杂度 $O(n)$。

- 情况二：（$L = p$ 或 $R=p$）且 $L \le q \le R$。

假设 $L=p$（$R=p$ 时同理），还是考虑从 $L,R$ 开始选数分别会选到哪些数。

1. 从 $L=p$ 开始，会选到 $(l_{q,1},R]$ 这些数。因为当要选 $a_q$ 的时候，一定会先选完 $(l_{q,1},q-1]$ 这些数（因为这些数都比 $a_q$ 小（除了 $a_p$，但是 $a_p$ 第一次已经被选了）），而且肯定不会选到 $l_{q,1}$，因为区间 $(l_{q,1},R]$ 中的所有数都比它小（除了 $a_p$，但是 $a_p$ 第一次已经被选了）。

2. 从 $R$ 开始，会选到 $[L,r_{p,0})$ 这些数。因为第一次没有选 $a_p$，所以和情况一相同。

会发现如果 $[L=p,R]$ 这个区间合法的充要条件为 $p-l_{q,1}=r_{p,0}-R$。我们枚举每一个 $q$，会发现 $q$ 只能对应到唯一一个 $p$ 即 $l_{q,0}$，否则不满足（$p,q$ 分别为区间中最大 / 次大值的位置）这个条件。那么 $p-l_{q,1}$ 的值是固定的，于是我们可以直接求出唯一可能的 $R$，判断是否合法即可。$R$ 合法当且仅当 $q \le R < r_{q,0}$。时间复杂度 $O(n)$。

- 情况三：$L=R$。

显然每一个区间都满足条件，这种情况的总方案数为 $n$，在输出的时候加上即可。


------------

那么最后要解决的问题就是如何求 $l,r$ 数组了，这是一个较为经典的问题。

暴力用树状数组求的话复杂度是 $O(n \log n)$ 的，**应该**不能通过。其实我们可以用链表维护这一信息。我们从小到大考虑每一个数，已经考虑过了的数就直接在链表中删除该节点。那么考虑到每一个数的时候剩下的数一定都比它大，于是直接用链表的前驱后继计算答案即可，时间复杂度 $O(n)$。

```
signed main() {
	cin >> n >> S,srand_(S,n);
	for(int i = 1;i <= n;i++) 
		pos[a[i]] = i,lst[i] = i - 1,nxt[i] = i + 1;
	for(int i = 1;i <= n;i++) {
		int id = pos[i];
		l[id][0] = lst[id],l[id][1] = lst[lst[id]];
		r[id][0] = nxt[id],r[id][1] = nxt[nxt[id]];
		nxt[lst[id]] = nxt[id],lst[nxt[id]] = lst[id];//在链表上删除 a[id]
	}
	for(int i = 1;i <= n;i++) //情况一
		ans += max(0ll,1ll * min(r[i][0] - i - 1,i - l[i][0] - 1));
	for(int i = 1;i <= n;i++) { //情况二
		int q = i,p1 = l[q][0],p2 = r[q][0];
		int pos1 = r[p1][0] - (p1 - l[q][1]);
		int pos2 = l[p2][0] + (r[q][1] - p2);
		if(pos1 >= q && pos1 < r[q][0]) ans++; //L = P
		if(pos2 <= q && pos2 > l[q][0]) ans++; //R = P
	} cout << ans + n;return 0; // 情况三
} 
```

---

## 作者：聊机 (赞：1)

提供一种 $n\log n$ 的做法，供大家开拓思路。而且这种做法的实际运行效率在题目的第四组数据上的表现要比楼上的线性做法更好。

为了方便叙述，我们规定：

$Max[i,j]$ 表示 $a[i]$ 到 $a[j]$ 中最大的值的下标。

$fr[i]$ 表示 $i$ 前面第一个比 $a[i]$ 大的元素的下标。

$bk[i]$ 表示 $i$ 后面第一个比 $a[i]$ 大的元素的下标。

$nf[i]$ 表示 $i$ 前面第二个比 $a[i]$ 大的元素的下标。

$nb[i]$ 表示 $i$ 后面第二个比 $a[i]$ 大的元素的下标。

$(i,j)$ 表示要计算贡献的点对。

$fr$ 和 $bk$ 数组可以用单调栈线性处理出来，$nf$ 和 $nb$ 则需要在单调栈上二分，这也就是为什么我的做法会带一个 $\log$（实际上因为时随机数据，所以这一部分常数很小）。

考虑何时一对 $i,j(i<j)$ 会产生贡献，当且仅当 $bk[Max[i,j]]-j=i-fr[Max[i,j]]$ 时会产生一次贡献，这是为什么，因为如果要从 $i$ 出发染到 $j$ 则必定经过 $Max[i,j]$，而所有小于 $i$ 左侧小于 $Max[i,j]$ 的元素就都会被染到，由于是排列，所以没有相同元素，所以就会染到左侧 $fr[Max[i,j]]$。从 $j$ 染到 $i$ 是同理的。

可是我们按照这个思路看样例就会发现问题。当 $Max[i,j]=i$ 或 $Max[i,j]=j$ 时就会出问题。这是因为当我们第一个选的元素就是 $Max[i,j]$ 时你再往两侧扩展的边界大小就不是 $Max[i,j]$ 了，而是 $Max[i+1,j]$ 或 $Max[i,j-1]$。

而此时应该怎么判断呢，我们以 $i$ 为起点且 $Max[i,j]=i$ 为例，应该是当 $i-nf[Max[i+1,j]]=bk[i]-j$ 时会产生一次贡献。

而 $(i,i)$ 这类的点对不方便归到上面两类统计，我们单独加一遍就行了。至此所有会产生贡献的类型都被我们讨论清楚了，下面考虑如何统计这些贡献。

我们枚举以每一个点 $k$ 为 $Max$ 的情况，首先考虑一类贡献，以 $k$ 元素为 $Max$ 能覆盖到的边界显然是 $[fr[k]+1,bk[k]-1]$，能产生的一类贡献的个数就是 $\min(k-fr[k]-1,bk[k]-k-1)$，因为我们要保证 $Max[i,j]\neq k$，所以这里枚举的点对不能包含 $k$ 本身。

然后我们考虑二类贡献，我们还是考虑以 $k$ 为 $Max$ 的情况，也就是 $k$ 为前面说的 $Max[i+1,j]$ 或 $Max[i,j-1]$。我们就说当 $fr[k]=Max[fr[k],j]$ 时的情况，此时以 $fr[k]$ 为点对 $(i,j)$ 中的 $i$，那么它会往左侧扩展到 $nf[k]$，这是一个定值，也就是说最多会产生一的贡献，那么何时会产生贡献，我们只能在 $[i,bk[i]-1]$ 中选点，扩展到的右边界都是 $bk[fr[k]]$。所以只有当 $fr[k]-nf[k]\in [bk[fr[k]]-(bk[i]-1),bk[fr[k]]-i]$ 时才会产生贡献。

当 $bk[k]=Max[i,bk[k]]$ 时计算与之类似。

写代码时注意边界问题，我把 $a[0]$ 和 $a[n+1]$ 都设为了极大值来保证边界，空间有点紧。

```cpp
const int N=1e7+3; 
int a[N],id[N],val[N],siz;
void add(int x,int Id) {//单调栈插入
	while(siz&&val[siz]<x) --siz;
	val[++siz]=x;id[siz]=Id;
}
int n,s,fr[N],bk[N];
long long ans;
int nb[N],nf[N];
struct edge{//处理nf和nb，用vector空间会炸
	int v,nx;
}e[N];
int h[N],tot;
inline void Add(int u,int v) {
	e[++tot].v=v;
	e[tot].nx=h[u];
	h[u]=tot;
}
inline bool check(int x,int l,int r) {
	return x>=l&&x<=r;
}
int main() {
	cin>>n>>s;
	srand_(s,n);
	a[0]=a[n+1]=n+1;
	for(int i=0;i<=n;i++) {
		add(a[i],i);
		fr[i]=id[siz-1];
		if(fr[i]>=1) Add(fr[i],i);
	}
	siz=0;
	for(int i=0;i<=n;i++) {
		if(i>0) {
			for(int j=h[i];j;j=e[j].nx) {
				int l=1,r=siz,mid;
				while(l<=r) {
					mid=(l+r)>>1;
					if(val[mid]>a[e[j].v]) l=mid+1;
					else r=mid-1;
				}
				nf[e[j].v]=id[r];
			}
		}
		add(a[i],i);
	}
	siz=0;
	memset(h,0,sizeof h);tot=0;
	for(int i=n+1;i>=1;i--) {
		add(a[i],i);
		bk[i]=id[siz-1];
		if(i==n+1) continue;
		if(bk[i]<=n) Add(bk[i],i);
		++ans;
		ans+=min(i-fr[i],bk[i]-i)-1;
	}
	siz=0;
	for(int i=n+1;i>=1;i--) {
		if(i<=n) {
			for(int j=h[i];j;j=e[j].nx) {
				int l=1,r=siz,mid;
				while(l<=r) {
					mid=(l+r)>>1;
					if(val[mid]>a[e[j].v]) l=mid+1;
					else r=mid-1;
				}
				nb[e[j].v]=id[r];
			}
		}
		add(a[i],i);
	}
//	for(int i=1;i<=n;i++) printf("%d ",a[i]);puts("");
	for(int i=1;i<=n;i++) {
		if(bk[i]<=n) ans+=check(nb[i]-bk[i],fr[i]+1-fr[bk[i]],i-fr[bk[i]]);
		if(fr[i]>=1) ans+=check(fr[i]-nf[i],bk[fr[i]]-(bk[i]-1),bk[fr[i]]-i);
	}
	cout<<ans;	
	return 0;
}
```

---

## 作者：Rem_CandleFire (赞：0)

### 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P10371)

### 分析与做法

注意到本题 $n\le 10^7$，故考虑 $O(n)$ 做法。

根据题目，我们可以知道：对于区间 $[l,r]$，记区间中的最大值的位置为 $p$，若从 $l$ 染色到 $r$，则必先把从 $l$ 左边到第一个大于 $a_p$ 的数的位置之前的这一段全部染色。**从 $r$ 染到 $l$ 同理**。

所以，不妨设 $l_i,r_i$ 分别表示对于第 $i$ 个位置，其左边第一个大于 $a_i$ 的数的位置与右边第一个大于 $a_i$ 的数的位置，显然可以 $O(n)$ 求出。

那么，根据上文，从 $l$ 染到 $r$ 需要的步数 $k_1=r-l_p$，从 $r$ 染到 $l$ 需要的步数 $k_2=r_p-l$。

由题意，$k_1=k_2$ 代入移项得 $l-l_p=r_p-r$。

于是，我们枚举 $p$ 得到区间 $[l_p,r_p]$，假设两指针 $u,v$ 从第一个符合条件的位置同时向 $p$ 移动，那么一对 $(u,v)$ 就是好的数对。即，对于每一个 $p$，好的数对的数量为 $\min(p-l_p,r_p-p)$。

然而，上述方法是有漏洞的，重新整理观察，我们发现以上操作保证了选取的区间**不单调**，但模拟样例可以发现，在一个单调区间中也存在好的数对。
**此时，$p=l$ 或 $p=r$，即作为端点出现**。

考虑 $p=l$，延续以上思考方式，记 $q$ 为区间 $[l,r]$ 中的次大值的位置，那么有 $p=l=l_q$，类似的，我们还需要定义 $l_{i,1}$ 为 $i$ 左边第二个大于 $a_i$ 的数的位置，为了好写，更改 $l_q$ 为 $l_{q,0}$。

类似分析可得，若使 $(l,r)$ 为好的数对，则得等式 $r-l_{q,1}=r_{p,0}-l_{q,0}$，将 $p=l_{q,0}$ 代入并移项得 $r=r_{p,0}-p+l_{q,1}$。

考虑 $r$ 的位置，显然当且仅当 $r\in [q,r_{p,0})$ 时该数对 $(l,r)$ 为好的数对。

$p=r$ 同理。

于是，我们只需要对于任意一个 $i$，求出 $l_{i,0},l_{i_1},r_{i,0},r_{i,1}$ 即可。

注意到序列 $a$ 为 $[1,n]$ 的一个排列，那么可以通过映射知道大小关系，通过链表维护位置关系来更新（因为上述 $4$ 个值都代表某个位置）。

具体的，每次根据映射关系找到还未被操作的最小的数，记其位置为 $pos$，类似贪心地，我们有：

$$l_{pos,0}=lst_{pos},r_{pos,0}=nxt_{pos}$$

$$l_{pos,1}=lst_{lst_{pos}},r_{pos,1}=nxt_{nxt_{pos}}$$ 

计算答案之后删除位置 $pos$ 即可。

数组模拟链表的相关知识请百度。

### code 

实现起来跟官方题解差不多，不放了。

---


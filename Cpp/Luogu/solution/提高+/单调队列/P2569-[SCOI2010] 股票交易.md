# [SCOI2010] 股票交易

## 题目描述

最近 $\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。

通过一段时间的观察，$\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。

另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\text{MaxP}$。

在第 $1$ 天之前，$\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？



## 说明/提示

- 对于 $30\%$ 的数据，$0\leq W<T\leq 50,1\leq\text{MaxP}\leq50$；
- 对于 $50\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq50$；
- 对于 $100\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq2000$；
- 对于所有的数据，$1\leq BP_i\leq AP_i\leq 1000,1\leq AS_i,BS_i\leq\text{MaxP}$。

## 样例 #1

### 输入

```
5 2 0
2 1 1 1
2 1 1 1
3 2 1 1
4 3 1 1
5 4 1 1
```

### 输出

```
3```

# 题解

## 作者：Sooke (赞：409)

## 思路概述


首先，不难想到本题可以用动态规划来解，这里就省略是如何想到动态规划的了。


###Q：动态规划的状态应该如何设？

###A：

观察数据范围，我们发现开一个 2000 × 2000 的数组来表示状态是没有问题的。

第一个维度，绝对用来表示是第几天，这个不用多想。

第二个维度，就需要稍微思考思考，我们发现它应该记录拥有多少张股票。

结合一下，整理出： $f_{i,j}$ 表示第$i$天后拥有$j$张股票可以赚到的最多钱数。


###Q：动态规划的转移方程应该如何列？状态的初值怎么设？

###A：

分情况讨论。某一天，要么买股，要么卖股，要么不买也不卖。而买股又可分为两个情况，要么凭空买，跟前面交不交易没有任何关系，要么在前面交易的基础上买股，通俗一点说，也就是该状态是否需要由前面的状态转移而来。

那为什么卖股不用分为两个情况呢？仔细想想，怎么能凭空卖呢？既然和前面的贸易没有关系，也就是说手上没有任何一张股票，哪来的股票用来卖？

因此，一共有四种情况，其中只有一个情况并不需要其他状态转移，单独讨论：


**1 . 凭空买**

仅本情况下的状态可以直接赋值，其他状态初值为 -inf，即：

$f_{i,j}=-ap_i\ \times \ j$

$(0 \leqslant j \leqslant as_i)$


下面三种情况，分别可列三个状态转移方程：


**2 . 不买也不卖**

最好想也最好列转移方程的一种情况，直接由上一天转移，且拥有股票数量不变。即：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \, f_{i-1,j})$


**3 . 在之前的基础上买股票**

这里的方程就比较复杂了，这里详细解释一下：

题目中指明说两次交易需要至少隔 $w$ 天。也就是说，今天是第 $i$ 天交易，那么上一次交易最近是在第 $i - w - 1$ 天。

可我第 $i - w - 1$ 天之前也可以交易啊？为什么偏偏是那一天，而不是第 $i - w - 2$ 天？

回看刚刚讨论的第 2 种情况，我们已经把某一天以前的最优答案转移到了该天，所以从那一天转移，相当于从那一天包括前面任何一天开始转移，省去了大把时间。

接下来，我们已知第 $i$ 天拥有 $j$ 张股票，假设第 $i - w - 1$ 天拥有 $k$ 张股票。

$k$ 一定比 $j$ 小，因为这一种情况是买股票，股票只能多。

但股票又不能买太多，限制最多为 $as$ 张。所以 $j - as_i$ 是底线。

继续，这次交易买了 $j - k$ 张股票，要花去 $(j - k) \times ap_i$ 元。

整理一下，转移方程为：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}-(j-k)\times ap_i)$

$(j - as_i \leqslant k < j)$


**4 . 在之前的基础上卖股票**

和上面的情况特别类似，在此简单地说一下区别。

因为是卖股票，$k$ 这次要比 $j$ 大。但要小于等于 $j + bs_i$。

这次交易卖了 $k - j$ 张邮票，赚得 $(k - j) \times bp_i$ 元。

整理一下，转移方程为：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}+(k-j)\times bp_i)$

$(j < k \leqslant j + bs_i)$


###Q：为什么可以使用单调性优化？

###A：

上面的 3，4 两种情况，列起来头头是道，但我们深入计算，发现时间复杂度是三次方级的。很显然，我们要想尽办法，把时间复杂度降到二次方级。

这个时候发现那两种情况，实际上可以使用单调性优化。此时达到降时间复杂度的目标。

就以第 3 种情况，在之前的基础上买股票为例子吧。

再重复提一下那个转移方程：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}-(j-k)\times ap_i)$

$(j - as_i \leqslant k < j)$

运用乘法分配率：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}-j\times ap_i+k\times ap_i)$

$(j - as_i \leqslant k < j)$

既然要将状态转移给 $f_{i,j}$，此时 $j$ 可以从 $max$ 中提取出，此时转移方程变为：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}+k\times ap_i)-j\times ap_i$

$(j - as_i \leqslant k < j)$

此时，我们发现以上的转移方程符合单调性优化的条件，故可以使用单调性优化。

没有理解地，可以这么想：由于转移有这么一个区间前提：$(j - as_i \leqslant k < j)$，又因为转移方程中出现了 max，也就是说转移的目的是从该区间中，找到某个最大的值，基础好的你应该已经发现这就是滑动窗口了吧？只不过放进单调队列的元素，是 $f_{i-w-1,k}+k\times ap_i$，但这并不影响转移。

那么第 4 种情况的转移，我就不多解释了，它的转移方程可以整理为：

$f_{i,j}$=$max(f_{i,j}\ \,,\ \,f_{i-w-1,k}+k \times bp_i)-j \times bp_i$

$(j < k \leqslant j + bs_i)$

好像除了后面的转移区间要求，两个整理后的方程几乎都是一样的。

对了，还有一个细节，是第 3 种情况转移应该顺序，第 4 种情况转移应该逆序，这个不难理解，先自己想想吧。


## 代码实现

按照上面的思路，得到对应的代码：

```cpp
#include <cstdio>
#include <cstring>
#define Min(x , y) ((x) < (y) ? (x) : (y))
#define Max(x , y) ((x) > (y) ? (x) : (y))

int n , m , ap , bp , as , bs , w , ans = 0 , f[2001][2001] , l , r , q[2001];
// f[i][j] 表示第 i 天后拥有 j 张股票赚的最多钱数
// l , r , q[x] 用于单调队列

int main(){
    scanf("%d%d%d" , &n , &m , &w);
    memset(f , 128 , sizeof(f)); // 128 实际上给 f 数组赋的是 -inf，可以试试看
    for(int i = 1 ; i <= n ; i++){
        scanf("%d%d%d%d" , &ap , &bp , &as , &bs);
        for(int j = 0 ; j <= as ; j++)
            f[i][j] = -1 * j * ap; // 第 1 种情况，直接赋
        for(int j = 0 ; j <= m ; j++)
            f[i][j] = Max(f[i][j] , f[i - 1][j]); // 第 2 种情况，转移
        if(i <= w)
            continue; // 因为第 3，4 种情况都有 i - w - 1，如果 i <= w，会出现负下标
        // 第 3 种情况，从小转移到大
        l = 1 , r = 0; // 单调队列准备
        for(int j = 0 ; j <= m ; j++){
            while(l <= r && q[l] < j - as)
                l++; // 把过期的元素扔掉
            while(l <= r && f[i - w - 1][q[r]] + q[r] * ap <= f[i - w - 1][j] + j * ap)
                r--; // 更新单调队列元素
            q[++r] = j; // 插入最新元素
            if(l <= r)
                f[i][j] = Max(f[i][j] , f[i - w - 1][q[l]] + q[l] * ap - j * ap); 
            // 如果单调队列里有元素，即可转移
        }
        // 第 4 种情况，从大转移到小
        l = 1 , r = 0; // 单调队列再次准备
        for(int j = m ; j >= 0 ; j--){
            while(l <= r && q[l] > j + bs)
                l++; // 把过期的元素扔掉
            while(l <= r && f[i - w - 1][q[r]] + q[r] * bp <= f[i - w - 1][j] + j * bp)
                r--; // 更新单调队列元素
            q[++r] = j; // 插入最新元素
            if(l <= r)
                f[i][j] = Max(f[i][j] , f[i - w - 1][q[l]] + q[l] * bp - j * bp); 
            // 如果单调队列里有元素，即可转移
        }
    }
    for(int i = 0 ; i <= m ; i++)
        ans = Max(ans , f[n][i]); // 最后，可以留股票（实际上不留任何股票的就是最优答案），找出最优答案
    printf("%d\n" , ans);
    return 0;
}
```




---

## 作者：_LAUV_ (赞：25)

很显然的动态规划题（笑）

容易想到DP的数组 f[i][j] 表示第i天手上有j支股票时能赚到最多的钱。

接下来就是转移了，有这么多变量一定要看清楚，仔细地分情况讨论。

每次转移时一共有四种情况：

（先从简单的入手）

#### 一、第i天不买股票也不买

那就是从前一天相同的股票值更新过来

### f[i][j]=max(f[i][j],f[i-1][j]);

那为什么是前一天而不是前几天呢？因为前几天的最优值都已经更新到前一天了呀。



------------

 

#### 二、第i天凭空买股票（相当于从之前手持0股票的情况更新来）

其实就是第i天的DP数组的初始化

###  For(j,0,As[i]) f[i] [j]=-j * Ap[i];


------------


#### 三、第i天在第 i-w-1 天的基础上买股票

那我们设第i-w-1天的股票数为k，最直接的更新就是下面这样

### f[i][j]=max(f[i][j], f[i-w-1][k]-(j-k)* Ap[i]);

但我们此时要更新的是j，所以可以稍稍转化一下:

 ###  f[i][j]=max{ f[i-w-1][k]+ k Ap[i] } - j* Ap[i]

那么此时k的范围是多少呢 不难想到就是 **[ j-As[i], j)**

所以在k的取值范围上，有经验的OIer们应该都能想到单调队列了吧（！）

式子中有取max值，还有取值范围的经常都是用单调队列来优化（不知道具体如何操作的可以看代码）

 

------------


#### 四、第i天在第i-w-1天的基础上卖出股票

和上一种情况其实是一样的（式子的推导请参照上式自己操作）

###  f[i][j]=max{f[i-w-1][k]+k*Bp[i]}- j* Ap[i]

只是k的取值范围不一样了，变成了**(j, j+Bs[i] ]**

同样可以用**单调队列**来优化。

代码~ 

可以在[博客](https://www.cnblogs.com/HLAUV/p/9925646.html)中查看

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Re register 

using namespace std;

const int N=2e3+10;
int f[N][N],q[N*2],qf,qr;
int n,m,As[N],Ap[N],Bs[N],Bp[N],W,T,MaxP;
inline void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
int main(){
	read(T); read(MaxP); read(W);
	For(i,1,T){
		read(Ap[i]); read(Bp[i]);
		read(As[i]); read(Bs[i]);
	}
	memset(f,128,sizeof(f));
	For(i,1,T){
		// I bought some stocks from nowhere
		For(j,0,As[i]){
			f[i][j]=-1*j*Ap[i];
		}
		// I didn't buy anything
		For(j,0,MaxP){
			f[i][j]=max(f[i][j],f[i-1][j]);
		}
		
		if(i-W-1<=0)continue;
		
		// I bought some stock today after W days
		qf=1; qr=0;
		For(j,0,MaxP){
			while(qf<=qr&&q[qf]<j-As[i])qf++; 
			if(qf<=qr){
				int k=q[qf];
				f[i][j]=max(f[i][j],f[i-W-1][k]+k*Ap[i]-j*Ap[i]);
			}  
			while(qf<=qr&&f[i-W-1][q[qr]]+q[qr]*Ap[i]<=f[i-W-1][j]+j*Ap[i])qr--;
			q[++qr]=j;
		}
	 
		// I sold some stock today after W days
		qf=1; qr=0;
		Dwn(j,MaxP,0){
			while(qf<=qr&&q[qf]>j+Bs[i])qf++;
			if(qf<=qr){
				int k=q[qf];
				f[i][j]=max(f[i][j],f[i-W-1][k]+k*Bp[i]-j*Bp[i]);
			}
			while(qf<=qr&&f[i-W-1][q[qr]]+q[qr]*Bp[i]<=f[i-W-1][j]+j*Bp[i])qr--;
			q[++qr]=j;
		}
	}
	int fn=-2147483600;
	For(i,0,MaxP)fn=max(fn,f[T][i]);
	cout<<fn<<endl;
	return 0;
}
```

---

## 作者：Memorize (赞：21)

容易想到方程f[i][j]表示第 i 天结束后，手里剩下 j 股的最大利润

则 不买不卖：f[i][j]=f[i-1][j]

买入：    f[i][j]=max{f[i-w-1][k]-ap[i]\*(j-k)}(j-as[i]<=k<=j-1)

卖出：    f[i][j]=max{f[i-w-1][k]+bp[i]\*(k-j)}(j+1<=k<=j+bs[i])

此时复杂度为O(N\*W^2)

而将方程变形可得:

买入：f[i][j]=max{f[i-w-1][k]+k\*ap[i]}-ap[i]\*j

卖出：f[i][j]=max{f[i-w-1][k]+k\*bp[i]}-bp[i]\*j

所以可以将括号里面的方程式压入单调队列 此时复杂度降低为复杂度O(N\*W)

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int t,maxp,w;
int ap[2010],bp[2010],as[2010],bs[2010];
int f[2010][2010];
int q[10000],qhead=1,qtail=0;
int main()
{
    scanf("%d%d%d",&t,&maxp,&w);
    for(int i=1;i<=t;i++)
    scanf("%d%d%d%d",&ap[i],&bp[i],&as[i],&bs[i]);
    memset(f,-0x7f,sizeof(f));
    for(int i=0;i<=t;i++) f[i][0]=0;
    for(int i=1;i<=t;i++)
    {
        for(int j=0;j<=as[i];j++) f[i][j]=-ap[i]*j;
        for(int j=maxp;j>=0;j--)  f[i][j]=max(f[i][j],f[i-1][j]);
        if(i-w-1>=0)
        {
            qhead=1;qtail=0;
            for(int j=0;j<=maxp;j++)
            {
                while(qhead<=qtail&&q[qhead]<j-as[i]) qhead++;
                while(qhead<=qtail&&f[i-w-1][j]+ap[i]*j>=f[i-w-1][q[qtail]]+ap[i]*q[qtail]) qtail--;
                q[++qtail]=j;
                if(qhead<=qtail) f[i][j]=max(f[i][j],f[i-w-1][q[qhead]]-ap[i]*(j-q[qhead])); 
            } 
            qhead=1;qtail=0;
            for(int j=maxp;j>=0;j--)
            {
                while(qhead<=qtail&&q[qhead]>j+bs[i]) qhead++;
                while(qhead<=qtail&&f[i-w-1][j]+bp[i]*j>=f[i-w-1][q[qtail]]+bp[i]*q[qtail]) qtail--;
                q[++qtail]=j;
                if(qhead<=qtail) f[i][j]=max(f[i][j],f[i-w-1][q[qhead]]+bp[i]*(q[qhead]-j));
            } 
        } 
    }
    int ans=0;
    for(int i=0;i<=maxp;i++) ans=max(f[t][i],ans);
    printf("%d",ans);
    return 0;
}
//上面的想法和讲解引用的是常州一中的一位大神(Krydom)

```

---

## 作者：枫林晚 (赞：13)

### 题目大意：

你初始时有∞
元钱，并且每天持有的股票不超过
Maxp
。
有
T
天，你知道每一天的买入价格（
AP[i]
），卖出价格（
Bp[i]
），
买入数量限制（
AS[i]
），卖出数量限制（
BS[i]
）。
并且两次交易之间必须间隔
W
天。
现在问你
T
天结束后，最大收益是多少。

### 分析：

注意对题意的理解，虽然有无限的钱，但是买股票是要减少当前的收益的，收益是卖出的总钱数减去买入的钱数。收益并不是只增不减。

可以想到的是：动态规划。设f[i][j]表示前i天之后，剩下j股股票的最大收益。显然根据题意，在j相同的时候，i越往后的时候，f[i][j]越大。

状态转移方程，买入和卖出是相同的思路:

卖出：

f[i][j]=max(f[i-w-1][k]+(k-j)×bp[i]) (j<=k<=j+bs[i])

买入：

f[i][j]=max(f[i-w-1][k]-(j-k)×ap[i]) (j-as[i]<=k<=j)

这种情况的复杂度是O(T×Mp×Mp)直接T掉。

将转移方程括号展开，发现：

f[i-w-1][k]+(k-j)×bp[i]=(f[i-w-1][k]+k×bp[i])-j×bp[i]

在给定i，j的时候，唯一在变的变量就是k，k的取值会影响最大值。而且给予j正确的循环顺序，k的取值区间是逐渐在平移的。

#### 想到了什么？

滑动窗口！单调队列！单调队列优化DP！

我们外层循环i，内层循环j，每次先除去过期的解，加上新的选择，再从单调队列队头取出最优解，进行更新。

#### 注意：
1.在买入和卖出时，为了保证能转移德到j的所有元素都在队列里，j的循环顺序是不同的。

2.对于给定的i，处理买入卖出的顺序可以颠倒。无所谓。

3.当i-w-1小于0时，取0即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000+10;
int t,mp,w;
int f[N][N];
int ans;
int q[N],hd=1,tl=0;
int main()
{
	scanf("%d%d%d",&t,&mp,&w);
	int ap,bp,as,bs;//并不需要数组
	memset(f,0xcf,sizeof f);//初值负无穷
	f[0][0]=0;
	for(int i=1;i<=t;i++)
	{
		scanf("%d%d%d%d",&ap,&bp,&as,&bs);
		hd=1,tl=0;
		int from=max(0,i-w-1);//从何转移
		for(int j=mp;j>=0;j--)//卖出
		{
			f[i][j]=max(f[i][j],f[i-1][j]);//可以今天不买不卖
			while(hd<=tl&&(j+bs<q[hd])) hd++;//除去过期者
			while(hd<=tl&&(f[from][q[tl]]+q[tl]*bp<f[from][j]+j*bp)) tl--;//因为从i的上一个状态来，所以先加入新元素
			q[++tl]=j;
			 f[i][j]=max(f[i][j],f[from][q[hd]]+q[hd]*bp-j*bp);
		}	
		hd=1,tl=0;
		for(int j=0;j<=mp;j++)//买入
		{
			f[i][j]=max(f[i][j],f[i-1][j]);
			while(hd<=tl&&(j-as>q[hd])) hd++;
			while(hd<=tl&&(f[from][q[tl]]+q[tl]*ap<f[from][j]+j*ap)) tl--;
			q[++tl]=j;
			 f[i][j]=max(f[i][j],f[from][q[hd]]+q[hd]*ap-j*ap);
		}
	}
	for(int j=0;j<=mp;j++)
	 ans=max(ans,f[t][j]);
	printf("%d",ans);
	return 0;
}
```

#### 总结：

1.对于决策转移时，有明显单调性的情况，对于状态移动时，转移决策重复度较大。都可用单调队列优化。

2.单调队列利用每个元素只能进一次，出一次，使得O(n)变为均摊O(1)复杂度，简化时间。



---

## 作者：xs_siqi (赞：12)

貌似是新做法。

做法核心：二进制优化 dp。

显然是 dp。先设状态，第一维表示当前枚举到哪一天，第二维枚举手持股数。根据题意，有以下几条：

$f_{i,j}=\max{f_{k,j}}(k\in [i-w-1,i-1])$

$f_{i,j}=\max{f_{k,j-l}}+a_i\times l(k\in [1,i-w-1])$

$f_{i,j}=\max{f_{k,j+l}}+b_i\times l(k\in [1,i-w-1])$

其中，$a_i,b_i$ 分别代表买入卖出单股的价值。这个做法是 $O(n^4)$ 的。远远不能通过本题。

先考虑优化能否省去对 $k$ 的枚举。考虑到对于区间 $[1,i-w-1]$ 是静态的，显然可以前缀最大值。

我本来看标签，以为对于 $[i-w-1,i-1]$ 应当采用单调队列。仔细想了一下，显然 $i-1$ 状态比前面都大或相等。因为这个状态由前面转移过来，可以进行“不选”的操作，所以对于 $[1,i-1]$ 必然是单调递增的。所以其实可以直接调用 $i-1$。

这样目前就变成 $O(n^3)$ 的了。但是这也难以通过本题。所以考虑继续优化 $l$。

因为数量是给定的，于是想到了多重背包，记起多重背包可以单调队列优化，但是这里显然是用不了的，因为有前缀最大值操作，且代价可能是负数，单调队列是很难操作的。

所以考虑二进制优化。将物品拆分成二的次方个进行 dp。这样整个 dp 的过程就是 $O(n^2\log n)$ 了。

可能有人会说：你这样就假了。因为二进制分组后物品个数与原来的 $1$ 到 $n$ 不对等。但是你要从 $i-w-1$ 转移。这使得物品跟原来不一样，那你怎么转移？

针对这个问题可以采用前缀和优化。把每个物品拆成二进制的个数给前缀和了，就知道 $i$ 到 $i-w-1$ 之间隔了多少个物品。然后就能转移了。

但是这样还是不够。因为 $f$ 数组空间很大。我们考虑到前缀最大值的存在，所以我们可以直接用前缀最大值作为答案，这样对于 $f$ 数组，它的第一维就只与对于每个物品 $i$ 被二进制分组后的物品个数的数量有关，空间成为 $\log_2 2000\times 2000$ 了。非常宽裕。

答案是什么？有一个性质：枚举物品数量相同的情况下，持股数越少，赚的钱越多。所以答案就是持股为 $0$ 时的值。

看不懂没关系，代码还有注释。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2005;
char st;
int t,m,w,n,pow2[maxn],f[15][maxn],cntw[maxn],cntv[maxn],qcntw[maxn],qcntv[maxn];
/*
令股票个数为 w，买入卖出代价为v（买入就是负数） 
cntw:每个i被二进制分组后的个数 cntv就是个数对应的总价值
pow2是2的幂次方
qcntw，qcntv分别是两个cnt的前缀和 
*/ 
int Max[maxn][maxn];
struct edge{
	int x,id,win[15],wout[15],vin[15],vout[15];}a[maxn];
char ed;
int main(){
	scanf("%d%d%d",&n,&m,&w);
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			Max[i][j]=-1e9;//买入就是负数，所以初始化为-1e9 
	pow2[0]=1;
	for(int i=1;i<=11;i++)pow2[i]=pow2[i-1]*2;
	for(int x,y,sw,sv,i=1;i<=n;i++){
		scanf("%d%d%d%d",&x,&y,&sw,&sv);
		for(int j=0;j<=11;j++){
			if(sw<pow2[j])break;
			sw-=pow2[j];
			a[i].vin[++cntw[i]]=pow2[j]*x;
			a[i].win[cntw[i]]=pow2[j];}
		if(sw){
			a[i].vin[++cntw[i]]=sw*x;
			a[i].win[cntw[i]]=sw;}
		for(int j=0;j<=11;j++){
			if(sv<pow2[j])break;
			sv-=pow2[j];
			a[i].vout[++cntv[i]]=pow2[j]*y;
			a[i].wout[cntv[i]]=pow2[j];}
		if(sv){
			a[i].vout[++cntv[i]]=sv*y;
			a[i].wout[cntv[i]]=sv;}}//模板二进制分组，没看懂可以先去做二进制优化多重背包 
			
	for(int i=1;i<=n;i++)
		qcntw[i]=qcntw[i-1]+cntw[i],qcntv[i]=qcntv[i-1]+cntv[i];
		
	Max[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int k=1;k<=cntw[i];k++)
			for(int j=0;j<=m;j++)
				f[k][j]=-1e9;//针对每个i进行多重背包。每次显然初始化成-1e9，理由同Max数组初始化 
		for(int j=0;j<=m;j++)
			f[0][j]=Max[max(0,i-w-1)][j];//因为你要从[1,i-w-1]转移，但是对于每个j，最大值你是已知的，所以不如直接把转移的东西初始化了 
		
		for(int k=1;k<=cntw[i];k++){
			for(int j=a[i].win[k];j<=m;j++)
				f[k][j]=max(f[k-1][j],f[k-1][j-a[i].win[k]]-a[i].vin[k]); 
			for(int j=0;j<a[i].win[k];j++)
				f[k][j]=f[k-1][j];}//当然这个状态肯定不能选。但是你也不能不管这个状态 
				
		for(int j=0;j<=m;j++)
			Max[i][j]=max(Max[i][j],f[cntw[i]][j]);//买入给Max记录前缀最大值 
		
		for(int k=1;k<=cntv[i];k++)
			for(int j=0;j<=m;j++)
				f[k][j]=-1e9;
		for(int j=0;j<=m;j++)
			f[0][j]=Max[max(0,i-w-1)][j];
		
		for(int k=1;k<=cntv[i];k++){
			for(int j=m-a[i].wout[k];j>=0;j--)
				f[k][j]=max(f[k-1][j],f[k-1][j+a[i].wout[k]]+a[i].vout[k]);
			for(int j=m;j>m-a[i].wout[k];j--)
				f[k][j]=f[k-1][j];}//同上 
				
		for(int j=0;j<=m;j++)
			Max[i][j]=max(Max[i][j],f[cntv[i]][j]);//同上 
		for(int j=0;j<=m;j++)
			Max[i][j]=max(Max[i-1][j],Max[i][j]);}//这是整个物品不选的转移方程 
	printf("%d\n",Max[n][0]); 
	return 0;} 
```


---

## 作者：奇米 (赞：8)

## 题解- P2569 股票交易

* **题目意思**
	
    由于题面过长，不再描述。
    [戳这里](https://www.luogu.com.cn/problem/P2569)
    
* $Sol$

	这道题目想清楚后还是不难的，是一道不错的单调队列练习题。
    
    首先我们要明确**状态**： 
    
    $f_{i,j}$表式到第$i$天拥有$j$个股票的最大收益。
    
    这个状态还是挺显然的，不像某些题目卡状态。
    
    对于转移，要分成多种情况来考虑：
    
    $(I)$ 我们就是没有任何积蓄的情况下买（相当于一个初始化），此时转移显然
    
    $f_{i,j}=-j \times AP_i $ $(j\leq MaxP)$
     
    $(II)$ 我们当天选择不买也不买
     
    $f_{i,j}=\max [f_{i-1,j},f_{i,j}]$
    
    **这个应该比较好理解就是继承原来的最大收益。**
        
    $(III)$ 已经有资金基础下买股票,此时如何转移呢？
    
    我们考虑上次买有多少股票$k$，则转移很显然：
    
    $f_{i,j}=\max [f_{i-w-1,k}-(j-k) \times AP_i,f_{i,j}]$
    
    **如何理解呢？就是上次购买时间为$(i-w-1)$，间隔$w$天买嘛。且因为这次是买进，数量要比上次多，的所以$k\leq j$。所以这次转移是这样的。**
    
    $(IV)$ 已经有资金基础下卖股票,此时如何转移呢？
    
    我们考虑上次买有多少股票$k$，则转移很显然：
    
    $f_{i,j}=\max [f_{i-w-1,k}+(k-j) \times BP_i,f_{i,j}]$
    
    **如何理解呢（和$III$同理)？就是上次购买时间为$(i-w-1)$，间隔$w$天买嘛。且因为这次是卖出，数量要比上次少，的所以$j\leq k$。所以这次转移是这样的。**
    
    但是这样的时间复杂度是存在问题的，大概为$O(T \times MaxP^2)$，可以获得$50$分的好成绩。我们考虑优化，单调队列？线段树？
    
    此时我们可以发现转移符合单调性优化原则，所以可以用**单调队列**来优化。对于$(III),(IV)$情况我们就像滑动窗口一样做。只要做$(III)$的时候正着扫，$(IV)$时候到这做（因为卖出去，上次股票肯定比这次多）。应该比较好理解吧。
    
    这里还有一个显而易见的优化：就是如果现在的天数$\leq w$是不用做$(III),(IV)$的。
    
    这样复杂度就变为$O(T \times MaxP)$，可以轻松过掉这道题目。
    
* $Code$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int N=2005;

int T,MP,W,AP[N],BP[N],AS[N],BS[N],ans;
int f[N][N],q[N];

inline int max(int i,int j)
{
	return (i>j)?i:j;
}

signed main()
{
	T=read();
	MP=read();
	W=read();
	for ( int i=1;i<=T;i++ )
	{
		AP[i]=read();
		BP[i]=read();
		AS[i]=read();
		BS[i]=read();
	}
	memset(f,-63,sizeof(f));
	for ( int i=1;i<=T;i++ ) 
	{
		for ( int j=0;j<=AS[i];j++ ) 
			f[i][j]=-1ll*j*AP[i];
		for ( int j=0;j<=MP;j++ ) 
			f[i][j]=max(f[i][j],f[i-1][j]);
		if(i<=W) continue;
		int head=1,tail=0;
		for ( int j=0;j<=MP;j++ )
		{
			while(head<=tail && q[head]<j-AS[i]) head++;
			while(head<=tail && f[i-W-1][q[tail]]+q[tail]*AP[i]<=f[i-W-1][j]+j*AP[i]) tail--;
			q[++tail]=j;
			if(head<=tail) 
				f[i][j]=max(f[i-W-1][q[head]]-(j-q[head])*AP[i],f[i][j]);
		}
		head=1,tail=0;
		for ( int j=MP;j>=0;j-- )
		{
			while(head<=tail && q[head]>j+BS[i]) head++;
			while(head<=tail && f[i-W-1][q[tail]]+q[tail]*BP[i]<=f[i-W-1][j]+j*BP[i]) tail--;
			q[++tail]=j;
			if(head<=tail) 
				f[i][j]=max(f[i-W-1][q[head]]+(q[head]-j)*BP[i],f[i][j]);
		}
	}
	ans=-1e12;
	for ( int i=0;i<=MP;i++ ) ans=max(ans,f[T][i]);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：i207M (赞：6)

## 题目总结

![](https://cdn.luogu.com.cn/upload/pic/20550.png)

## 数据范围

0<=W<T<=2000,1<=MaxP<=2000

1<=BPi<=APi<=1000,1<=ASi,BSi<=MaxP

## 解题思路

一道裸的单调队列优化DP；

![](https://cdn.luogu.com.cn/upload/pic/20551.png)

如何单调队列？以买入为例：

```cpp
q.clear();
for (ri j = 0, ba; j <= mxp; ++j) {
	while (!q.empty() && j - q.front() > as[i]) q.pop_front();
	while (!q.empty() && f[i - w - 1][ba = q.back()] + ba * ap[i] <= f[i - w - 1][j] + j * ap[i]) q.pop_back();
	q.push_back(j);
	f[i][j] = max(f[i][j], f[i - w - 1][ba = q.front()] - (j - ba) * ap[i]);
}
```

首先弹出不符合要求的队头，队列中存放的是数组下标（即对应天数）；

所以当$j - q.front() > as[i]$时，很明显不能这样转移，弹出队头；

然后考虑插入队尾（这里一定要先插入再求$f[i][j]$，因为我可能一直不买），看看我们的转移方程，我们要维护$f[i-w-1][k]-ap[i]*(j-k)$即 $f[i-w-1][k]+k*ap[i]$，所以把不优的队尾pop就好了；

对于卖出，要倒序处理；

$f[i-w-1][k]+bp[i]*(k-j)$即 $f[i-w-1][k]+k*bp[i]$

## 易错误区

不要打错front和back……不过数据真的水，弄反了还有60分

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define ull unsigned long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define int ll
il char gc() {
	static const int BS = 1 << 22;
	static unsigned char buf[BS], *st, *ed;
	if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
	return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
	x = 0; bool f = 0; char c = gc();
	while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
	while (isdigit(c)) {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
	if (f) x = -x;
}
#undef gc
void out(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) out(x / 10);
	putchar(x % 10 + '0');
}
#define N 2010
#define int ll
#define f dp
int t, mxp, w;
int ap[N], bp[N], as[N], bs[N];
int dp[N][N];
deque<int>q;
signed main() {
	in(t), in(mxp), in(w);
	for (ri i = 1; i <= t; ++i) {
		in(ap[i]), in(bp[i]), in(as[i]), in(bs[i]);
	}
	memset(dp, 0xcf, sizeof dp);
	for (ri i = 1; i <= t; ++i) {
		dp[i][0] = 0;
		for (ri j = 0; j <= as[i]; ++j) dp[i][j] = -ap[i] * j;
		for (ri j = mxp; j >= 0; --j) dp[i][j] = max(dp[i][j], dp[i - 1][j]);
		if (i - w - 1 >= 0) {
			q.clear();
			for (ri j = 0, ba; j <= mxp; ++j) {
				while (!q.empty() && j - q.front() > as[i]) q.pop_front();
				while (!q.empty() && f[i - w - 1][ba = q.back()] + ba * ap[i] <= f[i - w - 1][j] + j * ap[i]) q.pop_back();
				q.push_back(j);
				f[i][j] = max(f[i][j], f[i - w - 1][ba = q.front()] - (j - ba) * ap[i]);
			}
			q.clear();
			for (ri j = mxp, ba; j >= 0; --j) {
				while (!q.empty() && q.front() - j > bs[i]) q.pop_front();
				while (!q.empty() && f[i - w - 1][ba = q.back()] + ba * bp[i] <= f[i - w - 1][j] + j * bp[i]) q.pop_back();
				q.push_back(j);
				f[i][j] = max(f[i][j], f[i - w - 1][ba = q.front()] + (ba - j) * bp[i]);
			}
		}
	}
	printf("%lld", f[t][0]);
	return 0;
}

```

---

## 作者：18811162081lyh (赞：6)

```
/*单调队列优化dp
首先设计状态，观察到当第i天结束以后，只有该天持有的股票数对之后的计算会产生影响：
而且交易的时间限制W可以用转移方程来实现，所以状态设计如下 
dp[i][j]：第i天结束后，持有股票数为j的情况下能获得的最大收益（可正可负），
观察发现在第i天要么买进要么卖出，既买进又卖出必定不赚(APi>=BPi)，则转移方程为：
dp[i][j] = max{dp[i-1][j]                  第i天不交易
			   - j * Api                   第i天从零买进，j <= ASi 
		 	   dp[i-W-1][j+x] + x * Bpi    第i天卖出，x <= BSi，i > W+1 
			   dp[i-W-1][j-x] - x * Api}   第i天买进，x <= ASi，i > W+1 
转移方程体现了交易天数W的约束，复杂度是O(n^3)，会TLE，需要优化
以卖出为例，我们要求最大值，使用单调递减队列，队列长度<=BSi
这里需要处理一下卖出的收益问题，入队列的时候我们将所有的股票转换成资产，
即单调队列内维护的是最大资产，出队列的时候再把资产转换成对应的股票，买进同理 */
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAXN 2005
using namespace std;
int n, m, W, h, t, ans, dp[MAXN][MAXN];
struct stock{
	int AP, BP, AS, BS; //AP买进价格，BP卖出价格，AS买入限制，BS卖出限制 
}a[MAXN];
struct asset{
	int v, id;
}q[MAXN];
inline int read()
{
    int x = 0; char c = getchar();
    while(c > '9' || c < '0') c = getchar();
    while(c <= '9' && c >= '0'){
        x = (x << 3) + (x << 1) + c - 48; c = getchar();}
    return x;
}
int main()
{
	n = read(); m = read(); W = read();
	for(int i = 1; i <= n; i++)
		a[i].AP = read(), a[i].BP = read(), a[i].AS = read(), a[i].BS = read();
	memset(dp, 0xb3, sizeof(dp));      //初始化为负无穷 
	dp[0][0] = 0; 
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= a[i].AS; j++)
			dp[i][j] = - j * a[i].AP;  //第一次买入 
		for(int j = 0; j <= m; j++)
			dp[i][j] = max(dp[i - 1][j], dp[i][j]); //不买进也不卖出
		if(i <= W + 1) continue;       //不满足交易时间限制，没得交易 
		h = 1; t = 0;
		for(int j = 0, d; j <= m; j++) //第i天买进
		{
			d = i - W - 1; 
			while(h <= t && j - q[h].id > a[i].AS) h++;    //队列长度<=ASi
			while(h <= t && q[t].v < dp[d][j] + j * a[i].AP) t--; //资产单调递减 
			q[++t] = asset{dp[d][j] + j * a[i].AP, j};
			dp[i][j] = max(dp[i][j], q[h].v - j * a[i].AP);//当天结束后的资产包括股票
		} 
		h = 1; t = 0; 
		for(int j = m, d; j >= 0; j--) //第i天卖出
		{ 
			d = i - W - 1;
			while(h <= t && q[h].id - j > a[i].BS) h++;    //队列长度<=BSi
			while(h <= t && q[t].v < dp[d][j] + j * a[i].BP) t--;//资产单调递减 
			q[++t] = asset{dp[d][j] + j * a[i].BP, j};
			dp[i][j] = max(dp[i][j], q[h].v - j * a[i].BP);//当天结束后的资产包括股票 
		}
	}
	for(int j = 0; j <= m; j++) ans = max(ans, dp[n][j]); 
	printf("%d", ans); 
	return 0;
} 
```

---

## 作者：_Sein (赞：4)

## 题面描述
[传送门](https://www.luogu.org/problemnew/show/P2569)
## 思路
这道题DP的很明显啊(~~可惜我就是不会写啊~~)
## 提前声明:
这里的$n$为$T$，$m$为$MaxP$，$t$为$W$，$a$为$AP_i$，$c$为$BP_i$，b为$AS_i$，$d$为$BS_i$

首先根据题意，因为$i$天买了股票，$i+t$天也不能买股票，干脆$t++$，

状态转移方程:
$$F_{i,j}=\begin{Bmatrix} F_{i-1,j}\\  -a*j(j\le b)\\ F_{i-t, k}-a*j+a*k(0\le k\le j-1\And j-k\le d)\\ F_{i-t,k}+c*k-c*j(j+1\le k\le m\And k-j\le d)\end{Bmatrix}$$

第一条方程就是这天啥都不干(真是个有趣的家伙)。

第二条方程就是在前$b$天买进$j$张股票。

第三条方程就是在前$i-t$天已经买了k张股票，在$i$天再买$i-k$张股票。

第三条方程就是在前$i-t$天买了k张股票，在$i$天卖剩$j$张股票。

这种$DP$已经可以拿下$70$分了,

然后呢？(就T的没边了)

![在这里插入图片描述](https://cdn.luogu.com.cn/upload/pic/61583.png)

观察许久，我发现貌似第$3$、$4$个方程可以单调队列优化。
(因为它们具有单调性)

踢队头很好写，踢队尾可以观察发现有共性:

$F_{i-t,k}+c(a)*k$

因此我们就可以以这个为标准，踢掉不优的队尾。
```cpp
while(l<=r&&f[i-t][j]+a*j>=f[i-t][q[r]]+a*q[r])--r;
while(l<=r&&f[i-t][j]+c*j>=f[i-t][q[r]]+c*q[r])--r;
```

貌似这道题就结束了？

## AC code
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<cmath>
#define gc getchar()
using namespace std;
const int N=2010;
inline void qr(int &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
void qw(int x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int f[N][N];
int q[N];
int main()
{
	int n,m,t;qr(n),qr(m),qr(t);t++;
	f[0][0]=-N*N;for(int j=1;j<=m+1;j++)f[0][j]=f[0][j-1];
	for(int i=1;i<=n;i++)
	{
		int a,b,c,d,l,r;
		qr(a),qr(c),qr(b),qr(d);
		for(int j=0;j<=m+1;j++)f[i][j]=f[i-1][j];
		for(int j=0;j<=b;j++)f[i][j]=max(f[i][j],-a*j);
		if(i>t)
		{
			l=1;r=0;q[1]=0;
			for(int j=0;j<=m;j++)
			{
				while(l<=r&&q[l]<j-b)++l;
				f[i][j]=max(f[i][j],f[i-t][q[l]]-a*j+a*q[l]);
				while(l<=r&&f[i-t][j]+a*j>=f[i-t][q[r]]+a*q[r])--r;
				q[++r]=j;
			}
			l=1;r=0;q[1]=m+1;
			for(int j=m;j>=0;j--)
			{
				while(l<=r&&q[l]-j>d)++l;
				f[i][j]=max(f[i][j],f[i-t][q[l]]+c*q[l]-c*j);
				while(l<=r&&f[i-t][j]+c*j>=f[i-t][q[r]]+c*q[r])--r;
				q[++r]=j;
			}
		}
	}
	qw(f[n][0]);puts("");
	return 0;
}
```



---

## 作者：龙翔凤翥 (赞：3)

### 方法楼上都讲了，DP+单调队列优化，主要讲一下为什么卖股票的时候j的枚举顺序是倒序。
**首先买入股票的转移方程j是顺序枚举的，因为是买入股票，手中的股票应该是越来越多的，当前的决策有可能在后面（ｊ更大）的时候用到，所以你需要先求出来，同理，卖出股票时，你手中的股票是越来越少的，即当前的决策有可能需要用到比你手中股票数更少的状态，所以需要提前处理，因此需要倒序枚举**

#### Code:
```
#include<bits/stdc++.h>
using namespace std;
#define RN register int 
const int N = 2050;
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return f*x;
}
int t,maxp,w;
struct P {
	int ap;
	int bp;
	int as;
	int bs;
}a[N];
int ans;
int f[N][N],q[N];
inline int calc1(int i,int k)
{
	return f[i-w-1][k]+a[i].ap*k;
}
inline int calc2(int i,int k)
{
	return f[i-w-1][k]+a[i].bp*k;
}
int main()
{
	t=read(),maxp=read(),w=read();
	for(RN i=1;i<=t;i++)
		a[i].ap=read(),a[i].bp=read(),a[i].as=read(),a[i].bs=read();
	memset(f,128,sizeof(f));
	for(RN i=1;i<=t;i++)
	{
		for(RN k=0;k<=a[i].as;k++)
			f[i][k]=-a[i].ap*k;
		for(RN j=0;j<=maxp;j++)
			f[i][j]=max(f[i][j],f[i-1][j]);
		int l=1,r=0;
		if(i>=w+1)
		{
			for(RN j=0;j<=maxp;j++)
			{
				while(l<=r&&q[l]<j-a[i].as)
					l++;
				while(l<=r&&calc1(i,q[r])<=calc1(i,j))
					r--;
				q[++r]=j;
				f[i][j]=std::max(f[i][j],calc1(i,q[l])-a[i].ap*j);
			}
			l=1,r=0;
			for(RN j=0;j<=maxp;j++)
			{
				while(l<=r&&q[l]>j+a[i].bs)
					l++;
				while(l<=r&&calc2(i,q[r])<=calc2(i,j))
					r--;
				q[++r]=j;
				f[i][j]=std::max(f[i][j],calc2(i,q[l])-a[i].bp*j);
			}
			//cout<<"f["<<i<<"]"<<"["<<j<<"]="<<f[i][j]<<endl;
		}
	}
	for(RN i=0;i<=maxp;i++)
		ans=std::max(ans,f[t][i]);
	cout<<ans<<endl;
	return 0;
}
 

```

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2569)。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该可以很快就看出是道$DP$题吧。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态没什么难度:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(i,j)$：第$i$天手上持有$j$股时的最大收益。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么就先把转移列出来：   
### 1.当前天啥也不干  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(i,j)=\max(DP(i,j),DP(i-1,j))$  
### 2.当前天卖股票  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(i,j)=\max(DP(i,j),\max_{0\le k\le \max(i-W-1,0)}\{\max_{1\le t\le \min(MaxP-j,BS_i)}\{DP(k,j+t)+BP_it\}\})$
### 3.当前天买股票
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(i,j)=\max(DP(i,j),\max_{0\le k\le \max(i-W-1,0)}\{\max_{1\le t\le \min(j,AS_i)}\{DP(k,j-t)-AP_it\}\})$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现的是，一些题解中“凭空买股票”之类的部分也被算了进来。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案即为$\max_{0\le i\le MaxP}\{DP(T,i)\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样暴力转移时间$O(j\times MaxP^3)$......  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑优化： 

---------  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，因为有了“当前天啥也不干”这种操作，所以我们显然不用枚举上次买股票的时间$k$，转而直接用$\max(i-W-1,0)$替代即可。现在的时间是$O(j\times MaxP^2)$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~看吧，$DP$优化其实也不怎么难。~~  

---------  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步，设$k=\max(i-W-1,0)$，观察我们现在的转移式子，着重看后面比较臃肿的那一部分：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(i,j)=\max(DP(i-1,j),\max_{1\le t\le \min(MaxP-j,BS_i)}\{DP(k,j+t)+BP_it\},\max_{1\le t\le \min(j,AS_i)}\{DP(k,j-t)-AP_it\})$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉到了么，这其实就是在一个区间中（接近于定长区间，就是边界的情况下长度会有所改变）寻找一个最大值，然后转移。随着$t$的移动，这个区间也会跟着移动。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这样的问题正好就是单调队列所擅长的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以用两个队列，分别维护后面两个东西，中间的转移均摊$O(1)$，总时间直接被砍成了$O(j\times MaxP)$。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXT = 2005, MAXP = 2005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

struct deque
{
	int q[MAXP];
	int h, t;
	int& operator [] ( const int indx ) { return q[indx]; }
	deque(){ h = 1, t = 0; }
	void clear() { h = 1, t = 0; }
	int front() const { return q[h]; }
	int back() const { return q[t]; }
	void push_front( const int val ) { q[--h] = val; }
	void push_back( const int val ) { q[++t] = val; }
	void pop_front() { h ++; }
	void pop_back() { t --; }
	bool empty() const { return h > t; }
	int size() const { return t - h + 1; }
}deq1, deq2;

LL DP[MAXT][MAXP];
int AP[MAXT], BP[MAXT], AS[MAXT], BS[MAXT];
int W, T, MP;

int main()
{
	read( T ), read( MP ), read( W );
	for( int i = 1 ; i <= T ; i ++ ) read( AP[i] ), read( BP[i] ), read( AS[i] ), read( BS[i] );
	memset( DP, 0xc0, sizeof( DP ) );
	DP[0][0] = 0;
	int k, t1;
	for( int i = 1 ; i <= T ; i ++ )
	{
		deq1.clear(), deq2.clear();
		k = MAX( 0, i - W - 1 );
		for( t1 = 1 ; t1 < BS[i] && t1 <= MP ; t1 ++ )
		{
			while( ! deq1.empty() && DP[k][deq1.back()] + BP[i] * deq1.back() <= DP[k][t1] + BP[i] * t1 ) deq1.pop_back();
			deq1.push_back( t1 );
		}
		for( int j = 0 ; j <= MP ; j ++ )
		{
			DP[i][j] = DP[i - 1][j];
			while( ! deq1.empty() && deq1.front() <= j ) deq1.pop_front();
			if( t1 <= MP ) 
			{
				while( ! deq1.empty() && DP[k][deq1.back()] + BP[i] * ( deq1.back() - j ) <= DP[k][t1] + BP[i] * ( t1 - j ) ) deq1.pop_back();
				deq1.push_back( t1 ++ );
			}
			if( ! deq1.empty() ) DP[i][j] = MAX( DP[i][j], DP[k][deq1.front()] + BP[i] * ( deq1.front() - j ) );
			if( ! j ) continue;
			while( ! deq2.empty() && deq2.front() < j - AS[i] ) deq2.pop_front();
			while( ! deq2.empty() && DP[k][deq2.back()] - AP[i] * ( j - deq2.back() ) <= DP[k][j - 1] - AP[i] ) deq2.pop_back();
			deq2.push_back( j - 1 );
			if( ! deq2.empty() ) DP[i][j] = MAX( DP[i][j], DP[k][deq2.front()] - AP[i] * ( j - deq2.front() ) );
		}
	}
	LL res = -0x3f3f3f3f3f3f3f3f;
	for( int i = 0 ; i <= MP ; i ++ ) res = MAX( res, DP[T][i] );
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：kkxhh (赞：2)

dp + 单调队列优化

令 $d(i,j)$ 表示**在 $i$ 天，手持 $j$ 股股票的最大利润**

那么显然有三种转移方式

什么也不做：

$$ d(i,j)=d(i-1,j) $$

买入股票：

$$ d(i,j)=max \{ d(i-w-1,j-k) - k * ap_{i} \} (k \le as_{i}) $$

卖出股票

$$ d(i,j)=max \{ d(i-w-1,j+k) + k * bp_{i} \} (k \le bs_{i}) $$

我们可以发现每次转移都是取一个区间的最大值，于是我们可以想到单调队列优化

把式子化为

$$ d(i,j)=max \{ d(i-w-1,k') + k' * ap_{i} \} - j * ap_{i} (j - k' \le as_{i}) $$

$$ d(i,j)=max \{ d(i-w-1,k') + k' * bp_{i} \} - j * bp_{i} (k' - j \le bs_{i}) $$

我们就可以愉快的使用单调队列了

完整代码如下：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int INF=2000000000;
int t,maxp,w,ap[2010],bp[2010],as[2010],bs[2010],d[2010][2010],q[2010],p[2010],head,tail;

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

int main(){
    t=read(); maxp=read(); w=read();
    for(int i=1;i<=maxp;i++) d[0][i]=-INF;
    for(int i=1;i<=t;i++) ap[i]=read(),bp[i]=read(),as[i]=read(),bs[i]=read();
    for(int cur=1,las;cur<=t;cur++){
        las=max(0,cur-w-1);
        for(int i=0;i<=maxp;i++) d[cur][i]=d[cur-1][i];
        head=1; tail=0;
        for(int i=0;i<=maxp;i++){
            while(head<=tail && q[tail]<=d[las][i]+i*ap[cur]) tail--;
            q[++tail]=d[las][i]+i*ap[cur]; p[tail]=i;
            while(head<=tail && i-p[head]>as[cur]) head++;
            d[cur][i]=max(d[cur][i],q[head]-i*ap[cur]);
        }
        head=1; tail=0;
        for(int i=maxp;i>=0;i--){
            while(head<=tail && q[tail]<=d[las][i]+i*bp[cur]) tail--;
            q[++tail]=d[las][i]+i*bp[cur]; p[tail]=i;
            while(head<=tail && p[head]-i>bs[cur]) head++;
            d[cur][i]=max(d[cur][i],q[head]-i*bp[cur]);
        }
    }
    printf("%d",d[t][0]);
    return 0;
}

```

---

## 作者：FlyInTheSky (赞：1)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj3675/)

------------

容易设$dp(i,j)$为前$i$天有$j$股票的最大收益

则分情况讨论

1、买入股票

$$dp(i,j)=\max_{k \in [j-AS[i], j-1]}\{dp(i,j), dp(i-w-1,k) + AP_i (k-j)\}$$

2、卖出股票

$$dp(i,j)=\max_{k \in [j+1,j+BS[i]]}\{dp(i,j), dp(i-w-1,k) + BP_i (j-k)\}$$

3、什么也不做

$$dp(i,j)=\max\{dp(i,j), dp(i-1,j)\}$$

初值：

$$dp(i,j)=-AP_i \cdot j$$

其中$0 \leq j \leq AS_i$

其余均为$-∞$

然后考虑优化

我们将$i,j$看作定值，则将与$k$无关式子移到$\max$外面，发现这可以单调队列优化。

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
#include<set>
#include<cmath>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db long double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {
    
    const int MAXN = 2000 + 5, INF = 2000000000;

    int n, maxP, w, AP[MAXN], BP[MAXN], AS[MAXN], BS[MAXN];
    int dp[MAXN][MAXN];
    int l, r, q[MAXN];
    
    void clean() {
    }
    int solve() {
    	
    	clean();
    	
    	cin >> n >> maxP >> w;
    	for (int i = 1; i <= n; ++i) {
    		scanf("%d%d%d%d", &AP[i], &BP[i], &AS[i], &BS[i]);
        }
        
        for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= maxP; ++j) dp[i][j] = -INF;
        
        for (int i = 1; i <= n; ++i) 
        for (int j = 0; j <= AS[i]; ++j) dp[i][j] = -AP[i] * j;

        for (int i = 1; i <= n; ++i) {
            l = 1, r = 0;
            for (int j = 0; j <= maxP; ++j) dp[i][j] = max(dp[i][j], dp[i - 1][j]);
            if (i <= w) continue ;
            for (int j = 0; j <= maxP; ++j) { // buy
                while (l <= r && q[l] < j - AS[i]) ++l;
                while (l <= r && dp[i - w - 1][j] + AP[i] * j >= dp[i - w - 1][q[r]] + AP[i] * q[r]) --r;
                q[++r] = j;
                if (l <= r) dp[i][j] = max(dp[i - w - 1][q[l]] + AP[i] * q[l] - AP[i] * j, dp[i][j]);
            }
            l = 1, r = 0;
            for (int j = maxP; j >= 0; --j) { // sell
                while (l <= r && q[l] > j + BS[i]) ++l;
                while (l <= r && dp[i - w - 1][j] + BP[i] * j >= dp[i - w - 1][q[r]] + BP[i] * q[r]) --r;
                q[++r] = j;
                if (l <= r) dp[i][j] = max(dp[i - w - 1][q[l]] + BP[i] * q[l] - BP[i] * j, dp[i][j]);
            }
        }
        
        //for (int i = 0; i <= n; ++i)
        //for (int j = 0; j <= maxP; ++j) printf("i=%d, j=%d, dp=%d\n", i, j, dp[i][j]);
        
        int ans = 0;
        for (int j = 0; j <= maxP; ++j) ans = max(ans, dp[n][j]);
        
        cout << ans;
    	
        return 0;
    }
}
int main() { 
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：zyzzyzzyzzyz (赞：1)

也可以在[我的博客](https://www.cnblogs.com/Zenyz/p/10139276.html)食用,效果更佳

----



第一道单调队列优化DP，写篇题解纪念一下

[P2569 [SCOI2010]股票交易](https://www.luogu.org/problemnew/show/P2569)

题面很简单,我用$n,m,buy,sell,blimit,slimit$来分别代表$T,MaxP,AP,BP,AS,BS$


## 1.暴力

​	应该挺好打的,转移如下

​		$f[i][j]=max(f[i-1][j],f[i][j])$

​		$f[i][j]=MAX_{k=0}^{j}(f[i-w-1][k]-buy[i]\times(j-k)),((j-k)<blimit[i])$

​		$f[i][j]=MAX_{k=j}^{j+sli}(f[i-w-1][k]+sell[i]\times(k-j)),((k-j)<slimit[i])$

​	$(MAX$表示区间最大$)$

​	这样做是$O(n^2)$的,TLE

## 2.单调队列优化DP

​	考虑优化,

​	每次转移如下(以买入为例):

​		$f[i][j]=f[i-w-1][k]-buy[i]\times(j-k)),((j-k)<blimit[i])$

​	$RHS=f[i-w-1][k]-buy[i]*j+buy[i]*k,((j-k)<blimit[i]) $

​	那么我们到底有没有必要枚举$k$ 呢?

​	在枚举$k$ 的过程中,$-buy[i]*j$ 是定值,我们把它放到一边

​	令数组$a[k]=f[i-w-1][k]+buy[i]*k$ 

​	那么$a$ 是一个与$i,j$ 无关的数组,

​	且$f[i-w-1][j]$的答案只会从$a$ 数组中产生

​	则转移的本质其实是从同层且满足限制条件(条件即为blimit)的答案中选取最大的进行转移

​	![]( https://cdn.luogu.com.cn/upload/pic/46564.png )

​	如上图每次只会增加一个元素,减去一个元素

​	然后就[滑动窗口](https://www.luogu.org/problemnew/show/P1886)了

## 3.代码

暴力(50pts):

```cpp
#include<bits/stdc++.h>
#define il inline 
#define R register int
#define ll long long
#define gc getchar
using namespace std;
il int rd()
{
    R x=0,flag=1;
    char ch=0;
    while((ch>'9'||ch<'0')&&ch!='-')ch=gc();
    if(ch=='-')flag=-1,ch=gc();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=gc();
    return x*flag;
}
const int N=2010;
int n,m,w,ans;
int f[2002][2002];
int buy[N],sell[N],slimit[N],blimit[N];
int main ()
{
    n=rd(),m=rd(),w=rd();
    for(R i=1;i<=n;i++)
        buy[i]=rd(),sell[i]=rd(),blimit[i]=rd(),slimit[i]=rd();
    memset(f,0xcf,sizeof(f));
    for(R i=1;i<=n;i++)
        for(R j=0;j<=blimit[i];j++)
            f[i][j]=-buy[i]*j;
    for(R i=1;i<=n;i++)
    {
        for(R j=0;j<=m;j++)
        {
   	        f[i][j]=max(f[i][j],f[i-1][j]);
            for(R k=0;k<=slimit[i];k++)
            {
                if(i>w)
                f[i][j]=max(f[i][j],f[i-w-1][j+k]+sell[i]*k);
            }
            for(R k=0;k<=blimit[i];k++)
            {
                if(i>w&&j>=k)
                    f[i][j]=max(f[i][j],f[i-w-1][j-k]-buy[i]*k);
            }
        }
    }
    for(R i=0;i<=m;i++)
        ans=max(ans,f[n][i]);
    cout<<ans<<endl;
    return 0;
}

```



正解(100pts,跑得巨慢):

```cpp
#include<bits/stdc++.h>
#define il inline 
#define R register int
#define ll long long
#define gc getchar
using namespace std;
il int rd()
{
    R x=0,flag=1;
    char ch=0;
    while((ch>'9'||ch<'0')&&ch!='-')ch=gc();
    if(ch=='-')flag=-1,ch=gc();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=gc();
    return x*flag;
}
const int N=2010;
int n,m,w,ans;
int f[2002][2002];
int buy[N],sell[N],slimit[N],blimit[N];
deque<int> dq,dq2;
int main ()
{
    n=rd(),m=rd(),w=rd();
    for(R i=1;i<=n;i++)
        buy[i]=rd(),sell[i]=rd(),blimit[i]=rd(),slimit[i]=rd();
   memset(f,0xcf,sizeof(f));f[0][0]=0;
    for(R i=1;i<=n;i++)
    {
        
        while (!dq.empty()) dq.pop_back();
        while (!dq2.empty()) dq2.pop_back();
        R t=max(0,i-w-1);
        for(R j=0;j<=m;j++)
        {
             f[i][j]=max(f[i][j],f[i-1][j]);
            while(dq.size()&&f[t][j]>=f[t][dq.back()]-buy[i]*(j-dq.back()))
                dq.pop_back();
            dq.push_back(j);
            while(dq.size()&&j-dq.front()>blimit[i])dq.pop_front();
            f[i][j]=max(f[i][j],f[t][dq.front()]-buy[i]*(j-dq.front()));
        
        }
        for(R j=m;j+1;j--)
        {
            while(dq2.size()&&f[t][j]>=f[t][dq2.back()]+sell[i]*(dq2.back()-j))
                dq2.pop_back();
            dq2.push_back(j);
            while(dq2.size()&&dq2.front()-j>slimit[i])dq2.pop_front();
            f[i][j]=max(f[i][j],f[t][dq2.front()]+sell[i]*(dq2.front()-j));
        }
    }
    for(R i=0;i<=m;i++)
        ans=max(ans,f[n][i]);
    cout<<ans<<endl;
    return 0;
}

```

​	

---

## 作者：xukuan (赞：1)

单调队列优化dp的模板题 类似题：[NOIP2017pj]跳房子

看到题解里只有一篇用双端队列实现单调队列的题解，同时思路的易理解度和代码可读性不高，所以再来一篇

状态：f[i][j]表示前i天持有j张股票获得价值的的最大值

状态转移方程(这题可能性比较多，所以分类讨论)：

1.之前不买不卖，今天买：

f[i][j]=-j*ap[i] (0<=j<=as[i])

2.今天不买不卖：

f[i][j]=max(f[i-1][j],f[i][j]) (0<=j<=p)

3.i-w-1天时有k张(k<=j且i-w-1>=0)：

f[i][j]=max(f[i][j],f[i-w-1][k]-ap[i]*(j-k)) (j-as[i]<=k<=j)

4.i-w-1天时有k张(k>j且i-w-1>=0)

f[i][j]=max(f[i][j],f[i-w-1][k]+bp[i]*(k-j)) (j<k<=j+bs[i])

别的：

1.开始时f要赋成极大值

2.注意边界

3.统计答案时有循环

代码（70分）：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define INF 2147483647
using namespace std;

ll t,p,w,ap[2010],bp[2010],as[2010],bs[2010],f[2010][2010],ans=-INF;

int main(){
    cin>>t>>p>>w;
    memset(f,128,sizeof(f));
    for(ll i=1; i<=t; i++) scanf("%lld %lld %lld %lld",&ap[i],&bp[i],&as[i],&bs[i]);
    for(ll i=1; i<=t; i++){
    	//手上可以一张股票都没有，所以j可以为0
        for(ll j=0; j<=as[i]; j++) f[i][j]=-j*ap[i];
        for(ll j=0; j<=p; j++) f[i][j]=max(f[i-1][j],f[i][j]);

        if(i-w-1<=0) continue;
        //此时i-w-1==0时也可以，但与上面第一个式子重合，不重复更新
        for(ll j=0; j<=p; j++){
            for(ll k=j-as[i]; k<=j; k++) f[i][j]=max(f[i][j],f[i-w-1][k]-ap[i]*(j-k));
            for(ll k=j+1; k<=j+bs[i]; k++) f[i][j]=max(f[i][j],f[i-w-1][k]+bp[i]*(k-j));
            //k==j也可以，但重复了
        }
    }
    for(ll i=0; i<=p; i++) ans=max(ans,f[t][i]);
    cout<<ans<<endl;
    return 0;
}
```

满分还要优化，优化方式：单调队列

接下来的说明和代码的注释仅包括单调队列的部分。

代码：

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define INF 2147483647
using namespace std;

deque<ll> q;
ll t,p,w,ap[2010],bp[2010],as[2010],bs[2010],f[2010][2010],ans=-INF;

int main(){
    cin>>t>>p>>w;
    memset(f,128,sizeof(f));
    for(ll i=1; i<=t; i++) scanf("%lld %lld %lld %lld",&ap[i],&bp[i],&as[i],&bs[i]);
    for(ll i=1; i<=t; i++){
        for(ll j=0; j<=as[i]; j++) f[i][j]=-j*ap[i];
        for(ll j=0; j<=p; j++) f[i][j]=max(f[i-1][j],f[i][j]);
        if(i-w-1<=0) continue;
        
        while(!q.empty()) q.pop_front();
        for(ll j=0; j<=p; j++){
            while(!q.empty()&&q.front()<j-as[i]) q.pop_front();//队头超出了可以直接转移的范围，队头出队
            while(!q.empty()&&f[i-w-1][q.back()]+q.back()*ap[i]<=f[i-w-1][j]+j*ap[i]) q.pop_back();//队尾的价值不如新进来的，队尾出队
            q.push_back(j);//入队
            f[i][j]=max(f[i][j],f[i-w-1][q.front()]+q.front()*ap[i]-j*ap[i]);//更新状态
        }

        while(!q.empty()) q.pop_front();
        for(ll j=p; j>=0; j--){//注意，为保持单调性，循环倒着跑
        	//接下来同上，不重复注释
            while(!q.empty()&&q.front()>j+bs[i]) q.pop_front();
            while(!q.empty()&&f[i-w-1][q.back()]+q.back()*bp[i]<=f[i-w-1][j]+j*bp[i]) q.pop_back();
            q.push_back(j);
            f[i][j]=max(f[i][j],f[i-w-1][q.front()]+q.front()*bp[i]-j*bp[i]);
        }
    }
    for(ll i=0; i<=p; i++) ans=max(ans,f[t][i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：sun123zxy (赞：1)

[博客链接](https://www.cnblogs.com/sun123zxy/p/luogu2569.html)

第一眼看题就觉得是个dp ，然后看到2000的范围，hmm大概是个n^2的2维dp

开始设状态，第一维肯定是天数的枚举，第二维...看着MaxP的范围，觉得应该是持有股票数量的枚举

那么dp[i][j]就是对于1~i天，第i天持有j张股票的情况下最多能赚的钱

然后想转移方程，分成几种情况

**case 1：**前面都不买，从第i天开始买

　　也就是从一无所有的情况下买j张股票dp[i][j]=-APi*j


**case 2：**不买不卖

　　这种情况下不会就不会受到W的限制，直接dp[i][j]=dp[i-1][j]

 

**case 3：**发生买卖

　　首先要考虑应该从前面哪一天的状态转移过来，也就是上一次买卖在哪一天发生。

　　乍一看好像没办法知道应该从哪一天转移，莫非又多一层1~i-W-1的循环？

　　其实不用。上一次买卖所获得的最大值可以根据case 2的dp方程向后转移

　　所以直接从i-W-1天转移就行

 

　　**case 3.1：**又卖又买

　　　　仔细想想，这种情况不可能成为最大值。因为有APi>=BPi，卖了又买不如买少点，多折腾是不行的

 

　　**case 3.2：**只买不卖

　　　　既然是买，那么之前持有的股票必然比j少，枚举之前持有的股票k，花钱(j-k)*APi

　　　　dp[i][j]=dp[i-W-1][k]-(j-k)*APi;

 

　　**case3.3：**只卖不买

　　　　与case 3.2类似

　　　　dp[i][j]=max dp[i-W-1][k]+(k-j)*BPi

 

大概就是这样。dp[T][0]就是最终答案（保险起见我写的是max dp[T][0~MaxP]）

 

时间大概是O(n*MaxP^2)

 

预期50pt做法（实际70pt）(附伪代码提纲)
 

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int T,MaxP,W;

struct pig {
    int APi,BPi,ASi,BSi;
} day[2005];

int dp[2005][2005];

int main() {
    cin>>T>>MaxP>>W;
    for(int i=1; i<=T; i++) {
        scanf("%d%d%d%d",&day[i].APi,&day[i].BPi,&day[i].ASi,&day[i].BSi);
    }
    for(int i=0; i<=T; i++) {
        for(int j=0; j<=MaxP; j++) {
            dp[i][j]=-999999999;
        }
    }
    dp[0][0]=0;
    
    for(int i=1;i<=T;i++){
        for(int j=0;j<=MaxP;j++){
            dp[i][j]=dp[i-1][j];
            if(j<=day[i].ASi){
                
                dp[i][j]=max(dp[i][j],-j*day[i].APi);
            }
            if(i-W-1<0){
                continue;
            }
            for(int k=j-day[i].ASi;k<j;k++){
                if(k<0){
                    continue;
                }
                dp[i][j]=max(dp[i][j],dp[i-W-1][k]-(j-k)*day[i].APi);
            }
            for(int k=j+1;k<=j+day[i].BSi;k++){
                if(k>MaxP){
                    break;
                }
                dp[i][j]=max(dp[i][j],dp[i-W-1][k]+(k-j)*day[i].BPi);
            }
        }
    }
    int ans=0;
    for(int j=0; j<=MaxP; j++) {
        ans=max(ans,dp[T][j]);
    }
    cout<<ans;
    return 0;
}
/*
输入
初始化 赋-inf，dp[0][0]=0 
dp循环
    i 天数1-T 
        j 当前持股数0-Maxp
            从当前天开买 j<=Asi dp[i][j]=-j*APi; 
            不买不卖 dp[i][j]=dp[i-1][j]
            如果i-W-1>=0
                k 前次购买时持股数 买股 (j-Asi)~j&&>=0
                    dp[i][j]=max dp[i-W-1][k]-(j-k)*APi;
                k 前次购买时持股数 卖股  j~(j+Bsi)&&<=MaxP
                    dp[i][j]=max dp[i-W-1][k]+(k-j)*BPi
输出，max(dp[0][0~MaxP]) 

自测数据 
1
1 1
1 1
1 1
1 1
1 1
0
1 1
1 1
1 1
1 1
1 1
*/
(附伪代码提纲)
```

 怎么继续优化呢？

如果仍然保持dp[i][j]的形式，i和j的循环肯定是不能去掉的，所以考虑优化k

 

用case 3.2：只买不卖 举例

它的dp方程是dp[i][j]=max dp[i-W-1][k]-(j-k)*APi;

乘法分配律得dp[i][j]=max dp[i-W-1][k]+k*APi-j*APi;

j是枚举出来的，所以可以拆分一下max，得dp[i][j]=max(dp[i-W-1][k]+k*APi)-j*APi;

因为对于每个确定的i和j，k属于区间 [j - ASi ,j-1] ，假设i是定值，ASi就是定值。那么对于所有j，k的区间大小是一样的

一个长度固定的区间一格一格的移动...这不就是滑动窗口吗

单调队列优化，O(n*MaxP)，100pt到手

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int T,MaxP,W;

struct MonoQue {
	int lim;//维持的长度 
	int size;//最大存储量 
	int que[2005];//单调队列 
	int data[2005];//维护的数据
	int head,tail;

	void init(int mys,int mylim) {
		size=mys;
		lim=mylim;
		head=0;
		tail=0;
	}
	void push(int id) {//向单调队列中加入并维护，id可以在特殊情况下跳跃前进 
		if(id<=size) {//防越界处理 
			for(; head<tail;) {
				if(data[que[tail-1]]>data[id]) {
					break;
				}
				tail--;
			}
			que[tail]=id;
			tail++;
		}
		if(que[head]+lim<=id) {
			pop();
		}
	}
	void pop() {
		head++;
	}
	int quetop() {
		return que[head];
	}
	int top() {
		return data[quetop()];
	}
};

struct pig {
	int APi,BPi,ASi,BSi;
} day[2005];

int dp[2005][2005];

int main() {
	cin>>T>>MaxP>>W;
	for(int i=1; i<=T; i++) {
		scanf("%d%d%d%d",&day[i].APi,&day[i].BPi,&day[i].ASi,&day[i].BSi);
	}
	for(int i=0; i<=T; i++) {
		for(int j=0; j<=MaxP; j++) {
			dp[i][j]=-999999999;
		}
	}
	dp[0][0]=0;

	MonoQue buy,sell;
	for(int i=1; i<=T; i++) {
		buy.init(MaxP,day[i].ASi+1);
		sell.init(MaxP,day[i].BSi+1);
		if(i-W-1>=0) {//防数组超下界
			for(int j=0; j<=MaxP; j++) {
				buy.data[j]=dp[i-W-1][j]+j*day[i].APi;
				sell.data[j]=dp[i-W-1][j]+j*day[i].BPi;
			}
		}
		for(int j=0; j<day[i].BSi; j++) {
			sell.push(j);//sell需要预先加入
		}
		for(int j=0; j<=MaxP; j++) {
			dp[i][j]=dp[i-1][j];

			if(j<=day[i].ASi) {
				dp[i][j]=max(dp[i][j],-j*day[i].APi);
			}
			if(i-W-1<0) {
				continue;
			}
			buy.push(j);
			dp[i][j]=max(dp[i][j],buy.top()-j*day[i].APi);

			sell.push(j+day[i].BSi);//单调队列里会处理超了MaxP的情况 
				
			dp[i][j]=max(dp[i][j],sell.top()-j*day[i].BPi);
		}
	}
	int ans=0;
	for(int j=0; j<=MaxP; j++) {
		ans=max(ans,dp[T][j]);
	}
	cout<<ans;
	return 0;
}
/*
自测数据
3 2 0
2 1 1 1
3 2 1 1
4 3 1 1
*/
```

---

## 作者：C20203030 (赞：0)

## 一、题目

[点此看题](https://www.luogu.org/problem/P2569)

## 二、解法

这道题操作有点多，我们来一步一步梳理。

设$dp[i][j]$为到第$i$天操作完还剩$j$份股的最大收益，则：

1、继承上一层的状态，$dp[i][j]=dp[i-1][j]$。

2、从当前天开始买，$dp[i][j]=-j*ap[i]$。

3、在以前的基础上买入，由于我们的$dp$已经继承了最优的状态，直接用$i-w-1$的状态就行了，$dp[i][j]=dp[i-w-1][k]-(j-k)\times ap[i]$

4、在以前的基础上卖出，同理$dp[i][j]=dp[i-w-1][k]+(j-k)\times bp[i]$

这样写$dp$时间复杂度$O(n^3)$，得分$60$。

考虑优化，发现时间主要主要消耗在$3,4$个操作上。

发现$3,4$个操作决策区间是定长的，可以用单调队列优化（其实就是一个滑动窗
口），然后就解决了这个问题，时间复杂度$O(n^2) **（jzm orz or2 orz）**。


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN = 2005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,w,ans,q[MAXN],dp[MAXN][MAXN];
int main()
{
	memset(dp,-0x3f,sizeof dp);
	n=read();m=read();w=read();
	//dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int ap=read(),bp=read(),as=read(),bs=read();
		for(int j=0;j<=m;j++)
			dp[i][j]=dp[i-1][j];
		for(int j=0;j<=as;j++)
			dp[i][j]=max(dp[i][j],-j*ap);
		if(i<=w) continue;
		int l=1,r=0;
		for(int j=0;j<=m;j++)
		{
			while(l<=r && q[l]<j-as) l++;
			while(l<=r && dp[i-w-1][q[r]]+q[r]*ap<=dp[i-w-1][j]+j*ap) r--;
			q[++r]=j;
			if(l<=r)
			dp[i][j]=max(dp[i][j],dp[i-w-1][q[l]]-(j-q[l])*ap);
		}
		l=1;r=0;
		for(int j=m;j>=0;j--)
		{
			while(l<=r && q[l]>j+bs) l++;
			while(l<=r && dp[i-w-1][q[r]]+q[r]*bp<=dp[i-w-1][j]+j*bp) r--;
			q[++r]=j;
			if(l<=r) 
			dp[i][j]=max(dp[i][j],dp[i-w-1][q[l]]+(q[l]-j)*bp);
		}
	}
	for(int i=0;i<=m;i++)
		ans=max(ans,dp[n][i]); 
	printf("%d\n",ans);
}
```


---

## 作者：nofind (赞：0)

题意:https://www.luogu.org/problem/P2569

容易列出方程:f[i][j]->第i天,手中有j股的手中钱的最大值

f[i][j]=

1.不行动 f[i-1][j]

2.买入:f[i-W-1][k]-(j-k)*ap[i] (0=<k<=j-as[i])

3.卖出:f[i-W-1][k]+(k-j)*bp[i] (0=<k<=j+bs[i])

对于2:

f[i-W-1][k]-(j-k)*ap[i] 

=max(f[i-W-1][k]+k*ap[i])-j*ap[i]

维护一个单调队列,其中f[i-W-1][q[x]]+k*ap[q[x]] 单调递减

对于3:

f[i-W-1][k]+(k-j)*bp[i]

=max(f[i-W-1][k]+k*bp[i])-j*bp[i]

同理,维护一个单调队列,其中f[i-W-1][q[x]]+k*bp[q[x]] 单调递减

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2010;
const int maxp=2010;
int n,maxP,W,ans;
int ap[maxn],bp[maxn],as[maxn],bs[maxn],q[maxp];
int f[maxn][maxp];
inline int read()
{
	char c=getchar();int res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
int main()
{
	memset(f,128,sizeof(f));
	n=read();maxP=read();W=read();
	for(int i=1;i<=n;i++)ap[i]=read(),bp[i]=read(),as[i]=read(),bs[i]=read();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=as[i];j++)f[i][j]=-1*ap[i]*j;//初始值 
		for(int j=0;j<=maxP;j++)f[i][j]=max(f[i][j],f[i-1][j]);
		if(i<=W)continue;//i<=W的不能从i-W-1转移 
		int l=1,r=0;
		for(int j=0;j<=maxP;j++)
		{
			while(l<=r&&q[l]+as[i]<j)l++;
			if(l<=r)f[i][j]=max(f[i][j],f[i-W-1][q[l]]+(q[l]-j)*ap[i]);
			while(l<=r&&f[i-W-1][q[r]]+q[r]*ap[i]<f[i-W-1][j]+j*ap[i])r--;
			q[++r]=j;
		}
		l=1,r=0;
		for(int j=maxP;j>=0;j--)
		{
			while(l<=r&&q[l]-bs[i]>j)l++;
			if(l<=r)f[i][j]=max(f[i][j],f[i-W-1][q[l]]+(q[l]-j)*bp[i]);
			while(l<=r&&f[i-W-1][q[r]]+q[r]*bp[i]<f[i-W-1][j]+j*bp[i])r--;
			q[++r]=j;
		}
	}
	for(int i=0;i<=maxP;i++)ans=max(ans,f[n][i]);
	printf("%d",ans);
	return 0;	
}
```


---


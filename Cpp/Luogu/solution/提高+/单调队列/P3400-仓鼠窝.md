# 仓鼠窝

## 题目描述

萌萌哒的 Created equal 是一只小仓鼠，小仓鼠自然有仓鼠窝啦。

仓鼠窝是一个由 $n\times m$ 个格子组成的行数为 $n$、列数为 $m$ 的矩阵。小仓鼠现在想要知道，这个矩阵中有多少个子矩阵。

比如说有一个 $2\times 3$ 的矩阵，那么 $1\times 1$ 的子矩阵有 $6$ 个，$1\times 2$ 的子矩阵有 $4$ 个，$1\times 3$ 的子矩阵有 $2$ 个，$2\times 1$ 的子矩阵有 $3$ 个，$2\times 2$ 的子矩阵有 $2$ 个，$2\times 3$ 的子矩阵有 $1$ 个，所以子矩阵共有 $6+4+2+3+2+1=18$ 个。

可是仓鼠窝中有的格子被破坏了。现在小仓鼠想要知道，有多少个内部不含被破坏的格子的子矩阵。


## 说明/提示

本题时限 $2\text{s}$，内存限制 $256\text{M}$，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。

|    数据编号     |     $n$       |     $m$      |        特殊性质        |
| :------------: | :-----------: | :----------: | :--------------------: |
|     $1, 2, 3$    |       $2$       |       $2$      |           无           |
|        $4$       |      $10$       |      $10$      |           无           |
|      $5, 6$      |      $2000$     |     $2000$     |   所有格子均未被破坏     |
|        $7$       |      $2500$     |     $3000$     |  有且仅有一个格子被破坏  |
|        $8$       |      $3000$     |     $2500$     |  有且仅有一个格子被破坏  |
|        $9$       |       $200$     |      $200$     |           无           |
|   $10, 11, 12$   |       $500$     |      $500$     |           无           |
|     $13, 14$     |      $1000$     |     $1000$     |           无           |
|       $15$       |      $1000$     |     $1500$     |           无           |
|       $16$       |      $2500$     |     $2500$     |           无           |
|       $17$       |      $2500$     |     $3000$     |           无           |
|       $18$       |      $3000$     |     $2500$     |           无           |
|     $19, 20$     |      $3000$     |     $3000$     |           无           |

## 样例 #1

### 输入

```
3 4
1 1 1 1
1 0 1 1
1 1 0 1```

### 输出

```
26```

# 题解

## 作者：Ofnoname (赞：38)

吾闻悬线法之名而来，却以单调栈为之。

十有九者闻单调队列而不闻单调栈，殊不知其外有不同，内为一体。

![](https://cdn.luogu.com.cn/upload/image_hosting/k469hez2.png)

统计每一个点作为右下角时可以得到多少矩形，加起来就是答案。这里以图中的红点为例。

对于这个红点，这些各色矩形内的点就是可取的答案，矩形的大小因为0的存在受到限制。容易发现，这些挡住矩形的‘0’从左往右是单调递增的，而比这些0更靠左还更高的‘0’显然是毫无用处的。

所以我们可以维护一个栈，从左往右扫时，就把显然没有用的‘0’直接排除。

统计答案时，因为本列的0一定不低于左边一列的0，所以之前左边一列的答案（浅蓝色）可以直接继承，同时还要加上最新一个形成的矩形(粉色矩形上端)贡献的答案。

相邻两横行的每列0高度是无法推出来的，所以每一行要重新弄一个单调栈。

要开long long
```cpp
#include <bits/stdc++.h>
#define u32 unsigned int
#define u64 unsigned long long
#define MAX (3000 + 7)
using namespace std;

u32 N,M,top,S[MAX],f[MAX],sum[MAX],a[MAX][MAX];
u64 ans;

int main()
{
	scanf("%u%u", &N, &M);
	for (u32 i = 1; i <= N; i++)
	for (u32 j = 1; j <= M; j++)
		scanf("%u", &a[i][j]);
	for (u32 i = 1; i <= N; i++, top = 0)//清空单调栈 
	for (u32 j = 1; j <= M; j++) 
	{
		if (!a[i][j]) f[j] = i;//统计本列最低的0. 
		while (top && f[S[top]]<f[j]) top--; S[++top] = j;//排除比我靠左还比我高的点 
		ans += (sum[top] = sum[top-1] + (i - f[S[top]]) * (S[top] - S[top-1]));
		//继承左列答案，加上新矩形的答案 
	} printf("%llu\n", ans);	
}
```
做完这个可以去做讨论里的两道双倍经验，数据范围比这个小多了

---

## 作者：bzy369258147 (赞：16)

似乎所有题解都想得有些复杂qwq

不如来个简单的单调栈。

首先分析问题，我们要求出所有的子矩形，不妨考虑以每一点为右下角的子矩形的个数，加起来正好就是总的子矩形数了。

然后考虑每一个点为左下角时的方案数，我们考虑每在它左上的点是否可以作为矩形的左上角。

如图(假装有图

> 01111

> 11011

> 10111

> 10111

> 1111X

我们考虑以X为子矩形右下角的的方案数，下图中#为可行的左上角


> 011##

> 110##

> 10###

> 10###

> #####

我们发现所有的'#'形成一个连通块，并且长度向上单调递减，递减的原因是'0'的限制，所以每一行最右边的'0'可以用一个数组维护，我们现在令第i行最右边的'0'的位置为height[i].

然后我们可以在扫描每一列时，用一个单调栈维护这个单调壳，并维护每一个位置的答案，每次望栈中添加元素时直接从上一状态转移答案，具体代码如下。似乎比别的题解短了一截。

P.S.
不用开读如优化，scanf就够用了(我猜cin也行

记得开long long

```cpp
#include<bits/stdc++.h>
using namespace std;

bool mpa[3005][3005];
int height[3005];
int STK[3005],ANS[3005],head;

int main(){
    int n,m;cin >> n >> m;
    for(int i = 1;i <= n;i ++)for(int j = 1;j <= m;j ++)scanf("%d",&mpa[i][j]);
    long long ans = 0;
    for(int i = 1;i <= n;i ++){
        for(int j = 1;j <= m;j ++){
            if( !mpa[i][j] )height[j] = i;
            while( head and height[ STK[head] ] < height[j] ){
                head --;
            }
            STK[ ++ head ] = j;
            ANS[ head ] = ANS[ head - 1 ] + (i - height[STK[head]] ) * ( STK[head] - STK[head - 1] );
            ans += ANS[ head ];
        }
        head = 0;
    }
    cout << ans;
    return 0;
}
```


---

## 作者：danihao123 (赞：7)

首先，强烈谴责出题人wys以及时限和题面不一致的无耻行为……（逃

Well，我们考虑枚举右下角的点，左上角的点有多少种取法，该点对答案的贡献就是多少。

首先，我们不妨记$g[i][j]$为$(i, j)$向左扩展不走到任何一个被破坏格能走多少步。首先这玩意是不是很好递推啊？嗯，只要分类别考虑该格被破坏和没破坏的情况即可。

然后我们对于同一列的点，我们考虑从上往下枚举，把之前所有点的$g$值依次记在一个栈里。

我们加入一个新的$g$值的时候，如果新的$g$比之前所有的$g$都要大，也就是说这一行上的左上角点的取值就是这个$g$值种，并且之前所有点的左上角都是合法的。

嗯，可要是$g$比当前栈顶的那个$g$要小呢？

不妨设栈顶的值为$f$，我们会发现，如果我们还选取上一行列相差为$[g + 1, f]$的点作为左上角点的话，就会“碰”到新加入一行中的某个被破坏的格子，所以说我们要更新栈顶的值，直到$f < g$。

嗯，看样子把一样的值压成一个pair是不是更好？那是当然的。

嗯，这个数据结构咋有点眼熟？怎么看上去是单调递增的？难道是单调栈？

就是如此。

BTW，一定要手写I/O优化并且不要用STL。否则你会被松成儿子。

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <stack>
#include <utility>
using namespace std;
const int maxn = 3003;
typedef long long ll;
int A[maxn][maxn];
int pre[maxn][maxn];
int n, m;
inline void calc_pre() {
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            if(A[i][j]) {
                pre[i][j] = pre[i][j - 1] + 1;
            }
        }
    }
}

typedef pair<ll, ll> pii;
#define mp make_pair
inline int readint() {
    int x = 0;
    char c; c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x;
}
pii S[maxn];
int main() {
    n = readint(), m = readint();
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            A[i][j] = readint();
        }
    }
    calc_pre();
    ll ans = 0;
    for(int i = 1; i <= m; i ++) {
        int S_c = 0;
        ll tot = 0;
        for(int j = 1; j <= n; j ++) {
            ll ruler = pre[j][i];
            ll cnt = 1;
            while(S_c > 0) {
                pii u = S[S_c - 1];
                if(u.first < ruler) {
                    break;
                }
                S_c --;
                tot -= u.first * u.second;
                cnt += u.second;
            }
            tot += ruler * cnt;
            ans += tot;
            S[S_c ++] = mp(ruler, cnt);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Imiya (赞：6)

翻了翻题解，发现没有笛卡尔树做法。

考虑一行一行的计数，算下端在这一行上的矩形的数量。

类似最大子矩形的做法，先 $O(n^2)$ 预处理 $dis_{i,j}$ 表示 $(i,j)$ 到它上方的第一个障碍物的距离。然后对于每一行，以 $dis$ 值为权值建小根笛卡尔树。

![](https://cdn.luogu.com.cn/upload/image_hosting/4gj6hkv7.png)

以上面的情况为例，设当前计算所在的行的编号为 $h$，当前节点编号为 $nd$ 其父节点编号为 $fa$，以 $nd$ 为根的子树的大小为 $siz$，则每个节点产生的贡献是 $(dis_{h,nd}-dis_{h,fa})\frac {sum\cdot(sum+1)}2$。

遍历整棵树计算每个点的贡献，单行复杂度 $O(m)$，全局复杂度 $O(nm)$。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define int long long
inline int read(){
    int i=getchar(),r=0;
    while(i<'0'||i>'9')i=getchar();
    while(i>='0'&&i<='9')r=(r<<1)+(r<<3)+(i^48),i=getchar();
    return r;
}
const int N=3010;
int n,m,dis[N][N],stk[N],top,ls[N],rs[N],siz[N];
bool a[N][N];
void init(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            a[i][j]=read();
            dis[i][j]=a[i][j]?dis[i-1][j]+1:0;
        }
}
int get_siz(int nd){
    if(!nd)return 0;
    return siz[nd]=get_siz(ls[nd])+get_siz(rs[nd])+1;
}
int dfs(int nd,int fa,int h){
    if(!nd)return 0;
    return siz[nd]*(siz[nd]+1)/2*(dis[h][nd]-dis[h][fa])+dfs(ls[nd],nd,h)+dfs(rs[nd],nd,h);
}
void build(int h){
    top=0;
    memset(stk,0,sizeof(stk));
    memset(siz,0,sizeof(siz));
    memset(ls,0,sizeof(ls));
    memset(rs,0,sizeof(rs));
    for(int i=1;i<=m;i++){
        int lst=0;
        while(top&&dis[h][stk[top]]>dis[h][i])lst=stk[top],stk[top--]=0;
        ls[i]=lst;
        rs[stk[top]]=i;
        stk[++top]=i;
    }
}
int ans;
signed main(){
    init();
    for(int i=1;i<=n;i++){
        build(i);
        get_siz(stk[1]);
        ans+=dfs(stk[1],0,i);
    }
    cout<<ans;
    return 0;
}
```

本题略卡常，需要加快读，模拟赛的时候我没加直接挂到 85pts。

---

## 作者：风羽跃 (赞：4)

比较经典的单调栈问题吧。

首先这是一道给定01矩阵求1子矩阵方案数。

那么有一道类似的变形：给定01矩阵求最大的1子矩阵面积。

这样的话就可以用单调栈/悬线法来解决。

由于单调栈本题会涉及，就先介绍一下悬线法。

### 悬线法

经典的 DP 手段，用途不广，其所能解决的问题是单调栈的真子集（qwq）……

一句话概括：求出每个点 $(i,j)$ 上的最大子矩阵,然后取最大值。

想象一下现在我们找到了一个值为 $1$ 的点，然后有一条线从该点出发,一直向上延伸，直至撞到 $0$ 为止，我们就得到了一条纵向的线段。

设该点 $(i,j)$，线段长度 $up(i,j)$，线段不断向左右两边扫，撞到 $0$ 停止的左端点和右端点分别为 $lmx(i,j)$，$rmx(i,j)$，这个子矩阵大小就是 $up(i,j)\times(rmx(i,j)-lmx(i,j)+1)$。

如何求出 $lmx(i,j)$ 和 $rmx(i,j)$？

$O(n\times m)$ 地预处理出每个单点最远能到达的左右端点，在自上而下 DP 时用每个点上面的点的左右端点去更新它自己的左右端点（此时这个点的所谓“左右端点”就变成了它所代表线段所能到达的左右边界）。

时间复杂度：$O(n\times m)$（~~好像是句废话~~）。

回归本题，变成了求方案数，悬线法就相形见绌了。

所以就轮到单调栈上场了！

### 单调栈

原理：及时排出不可能的选项，保持策略集合高度有效性。由于每个店最多进一次出一次，均摊时间复杂度 $O(1)$。

建议先完成[SP1805](https://www.luogu.com.cn/problem/SP1805)。

与[SP1805](https://www.luogu.com.cn/problem/SP1805)类似，考虑枚举每个点，统计以该点为右下角的矩形有多少，问题就转化成了矩形的左上角的可选位置有多少，显然与 0 点所在位置有关。

对于两个在当前矩形右下角左上方的 0 点 A 和 B，如果 A 点比 B 靠右并且 A 点还比 B 点低，那么删去 B 点依然不影响答案（想起那句名言：如果 OI 只看第一，有一个 OIer 比你小还比你强，那你就可以退役了，因为你能打的比赛他都能打，且你们同打一个比赛你一定赢不了，道理是一样的），用单调栈维护即可。

对每个矩形右下角统计答案时分为两部分：左边的答案继承+新形成的矩形方案（新的最大矩形长 $\times$ 宽）。

别忘了开 long long。

AC 代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>

#define maxn 3005

using namespace std;

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

int n,m,mp[maxn][maxn];

int up[maxn],s[maxn],top;

long long sum[maxn],ans;

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			mp[i][j]=read();
		}
	}
	for(int i=1;i<=n;i++){
		top=0;
		for(int j=1;j<=m;j++){
			if(!mp[i][j]) up[j]=i;
			while(top&&up[s[top]]<up[j]) top--;
			s[++top]=j;
			sum[top]=sum[top-1]+(i-up[s[top]])*(s[top]-s[top-1]);
			ans+=sum[top];
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：0xFF (赞：3)

#### 题目大意


------------
求内部元素全为 $1$ 的子矩阵个数。

#### 思路分析


------------
纯暴力做法：$\Theta(n^6)$ 期望得分 $10pts$

二维前缀和优化，枚举矩形的四个边界：$\Theta(n^4)$ 期望得分 $10pts$

枚举矩形的上下边界，将中间的问题转化为一个序列上的问题求解。利用这种做法可以通过[P1191](https://www.luogu.com.cn/problem/P1191)，但是对于[P3400](https://www.luogu.com.cn/problem/P3400)来说还是显得相形见绌。

想要通过此题，必须找到一种复杂度不超过 $\Theta(nm)$ 的做法。

枚举子矩形的右下角位置 $\Theta(nm)$，找出可能存在的左上角的位置，将答案累加即可。

考虑使用单调栈维护。

数组 $up[i][j]$ 表示从 $(i,j)$ 向上枚举最多能枚举几次，即位置 $(i,j)$ 上方最近的 $0$ 的距离，若 $(i,j)$ 本身就是 $0$，则 $up[i][j]=0$。

对于每一行分别建立单调栈维护，如果当前元素的 $up$ 值大于栈顶元素的 $up$ 值，则可以直接入栈，当前元素对于答案的贡献就是它的 $up$ 值加上以它左边的元素为右下角的矩形的个数，因为如果可以直接入栈，栈中的元素一定单调递增。

如果当前元素的 $up$ 值小于栈顶元素的 $up$ 值，则需进行分类讨论。

![rt](https://cdn.luogu.com.cn/upload/image_hosting/ewxkm8um.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图所示，红色的部分都是不满足以当前元素为右下角的矩阵，所以答案即为刚才的答案减去红色部分中点的个数。

减去的个数就是栈顶元素和栈顶后一个元素的差值乘上栈顶元素的 $up$ 值和当前元素的 $up$ 值的差。

需要注意的是，此题空间限制较小，需要有选择的开 `long long`

#### 代码实现


------------
```cpp
int main(){
	int n = read() , m = read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j] = read();
			if(a[i][j] == 1) up[i][j] = 1;
		}
	} 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j] == 1 && a[i-1][j] == 1){
				up[i][j] = up[i-1][j] + 1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		stack<int> s;
		for(int j=1;j<=m;j++){
			f[j] = f[j-1];
			int L,R; 
			while(!s.empty() && up[i][s.top()] > up[i][j]){
				R = s.top(); s.pop();
				if(s.empty()) L = 0;
				else L = s.top();
				f[j] -= (R - L) * (up[i][R] - up[i][j]);
			}
			s.push(j);
			f[j] += up[i][j];
			ans += f[j];
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：XL4453 (赞：2)

### 题目分析：

考虑对于每一个点对其算出以其为右下角有多少子矩形。

首先发现能构成矩形的边界是一个纵坐标单调不减的区间，这是因为每一个被破坏的点的所有左上的点都不会起到任何限制作用。

所以考虑用单调栈来维护这样的一个限制子矩形边界，每当有一个新的限制点进入就把其所有纵坐标比其大的点踢出。

------------
更具体的，对于每一列维护这一列最下方的那一个限制点，然后在单调栈中存入限制点的横坐标。

每一次计算答案时对于最高的限制点计算，直接把这一个限制点的上一个的答案继承，然后加上这一个限制点、矩形右下角、上一个限制点构成的矩形的额外贡献。

-----------
### 代码：

```cpp
#include<cstdio>
using namespace std;
long long st[3005],top,n,m,f[3005],a[3005][3005],sum[3005];
long long ans;
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	scanf("%lld",&a[i][j]);
	for(int i=1;i<=n;i++,top=0)
	for(int j=1;j<=m;j++){
		if(a[i][j]==0){
			f[j]=i;
			top=1;
			st[top]=j;
			sum[top]=0;
			continue;
		}
		while(f[st[top]]<f[j]&&top>=1)top--;
		st[++top]=j;
		sum[top]=sum[top-1]+(i-f[st[top]])*(st[top]-st[top-1]);
		ans+=sum[top];
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Jiang_zi_chuan (赞：2)

# 此题有坑！！！ 注意要开long long和常数优化。

大家可以看前几位大佬的思路，我也跟他们差不多


希望大家可以用我的博客看，那样更好[传送门](https://jzc.blog.luogu.org/solution-p3400)

第一次提交时卡无限Juding了 https://www.luogu.org/record/show?rid=14907781
```cpp
// luogu-judger-enable-o2
//#define LOCAL
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <bits/stdc++.h>

#define INF 0×7f
#define ull unsigned long long
#define FOR(a, b, n) for(int a = b; b >= n ? a >= n : a <= n; b >= n ? a-- : a++)
#define M(a, n) memset(a, n, sizeof(a));
#define S(n) scanf("%d", &n)
#define P(n) printf("%lld", n)
#define G(n) getline(cin, n)
#define PI acos(-1.0)
#define fi first
#define se second

using namespace std;

const int NR = 3005;

using namespace std;
typedef long long ll;
typedef pair<int,int> pa;
inline void read(int &x)
{
    x = 0; 
    char ch = getchar();
    while(ch < '0' || ch > '9') 
    	ch = getchar();
    while(ch >= '0' && ch <= '9')
   	{
   		x = (x << 1) + (x << 3) + (ch ^ 48);
   		ch = getchar();
   	}
}
int n, m, top; 
ll cnt, ans;
int A[NR][NR], pre[NR][NR], H[NR];
pa sta[NR];    
int main() {
	#ifdef LOCAL
		freopen(".in", "r", stdin);
		freopen(".out", "w", stdout);
	#endif
    read(n);
    read(m);
    FOR(i, 1, n) 
    	FOR(j, 1, m) 
    		read(A[i][j]);
    FOR(i, 1, n) {
        cnt = 0;
        top = 0; 
        pa tmp;
        FOR(j, 1, m) {
            if(!A[i][j])
            {
            	H[j] = 0; 
            	cnt = 0;
            	top = 0;
            	continue;
            }
            tmp.fi = ++H[j]; 
            tmp.se = 1;
            while(top && sta[top].fi >= tmp.fi) {
                tmp.se = tmp.se + sta[top].se;
                cnt -= 1ll * sta[top].fi * sta[top].se;
                top--;
            }
            sta[++top] = tmp;
            cnt += 1ll * tmp.fi * tmp.se;
            ans += cnt;
        }
    }
    P(ans);
    //cout<<"AC";
    return 0;
}
//Jiang_zi_chuan原创
//小号Jzc2008
//本人是个十足的蒟蒻没事不要@(有事请发到邮箱1799049774@qq.com)
```

---

## 作者：Xu_brezza (赞：1)

[传送门~](https://www.luogu.com.cn/problem/P3400)

# 题意
给定一个 $n * m$ 的矩阵，由 $ 0 1 $ 构成，代表该点是否可用，求出该矩阵的子矩阵数量。

## 分析
首先我们明确求子矩阵数量的策略，枚举点 $(i,j)$ 作为子矩阵的右下角，只需要求出当前点出发可以得到多少矩阵，最后加和即可得出答案。

## 算法实现
考虑如下的矩阵：

 0 0 1 1 0 0 1
 
 1 0 1 0 2 1 0
 
 0 1 0 2 0 0 1
 
 1 0 0 2 p 0 0
 
 对于点 $ p $ 显然只有标记为 $2$ 的点（假设大于$0$代表被破坏）对他能构成的子矩阵有影响，其余的不能走的点无法影响他，所以每次我们只需要记录这些点就可以了。
 
 对于这些点的记录，我们维护一个单调栈（不会的可以看注释，很好理解），记录每一列的最高点，这样扫到当前点就可以直接得到所以对他有影响的点。
 
 再考虑如何优化，我们记录一个 $sum$ 数组代表前面的点子矩阵个数，这样每次只需要加入当前新增的一个矩形，再加上 $sum$ 就能得到这个点的子矩阵个数，对于这个子矩阵，单调栈存储的是高度，也就是 $i$ ，再记录一个 $w$ 数组记录所在的列，通过 $w$ 得到宽，栈得到高，矩形就求出来了。
 
 
 ```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,a[3005][3005],f[3005],w[3005],sum[3005],top;//f是单调栈 
long long ans;//不开long long见祖宗 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;++i,top=0){//每一行都要清空栈重新维护 
		for(int j=1;j<=m;++j){
			if(!a[i][j])f[j] = i;//如果被破坏了，那么高度就是自己的高度 
			while(top && f[w[top]] < f[j])top--;//去除栈中比当前列高度高的，也就是得到“2”的那个点 
			w[++top] = j;/*记录列*/						//注意 i 小的反而高 
			sum[top] = sum[top-1] + (i-f[w[top]]) * (w[top] - w[top-1]);//该点子矩阵个数=前一个点子矩阵数 + 高 * 宽 ； 
			ans+=sum[top]; //累加答案 
		}
	}
	printf("%llu",ans);
}

```
管理大大求过 qwq

---

## 作者：szm_ (赞：1)

目前是洛咕rk1，830ms  

~~不会单调栈的人看这里！~~   

其实差不多就是把[我在P5300题解](https://www.luogu.org/blog/iwantac/solution-p5300)又复制一遍，加了个详细说明，求过qwq

---
考虑反色后的矩阵，只要一个子矩阵中有一个 $ 1 $ ，那么这个子矩阵就是无效的，要从总个数中扣掉。  


枚举每一个位置作为右下角，记 $ s_i $ 为到当前行为止，为 $ 1 $ 的数最后出现时的所在行。  

这个位置作为右下角的贡献就是以当前列作为右端点作后缀 $ Max $ ，再把后缀 $ Max $ 加起来的和。   

解释一下这一段，考虑这样一个东西：  

1 1 1 1  
0 1 0 1  
0 0 0 1  
0 0 a b  

那a这个位置作为右下角的可行左上角是被包在一个轮廓线里面的，大概长这样：  

1 1 1c 1    
0 1c 0  1  
cccc  
0 0 0 1  
0 0 a b  

b这个位置同理，大概长这样：  

1 1 1 1  
0 1 0 1  
0 0 0 1  
cccccc  
0 0 a b  

可以看出轮廓线内的面积是一个后缀最大值和。所以我们考虑维护的方式。

因为后缀 $ Max $ 是单调的，而且每次修改只有一种操作：把某个位置（此位为 $ 1 $）改成最大值（当前行号）。  

那么对于每个位置记 $ Pre_i $ ，表示在他之前最后一个比他大的，可以发现每个位置后缀最大值和可以用这个 $ Pre $ 求出。考虑一次修改的影响，我们只要扫一遍，记下最后一个改成最大值的位置，再和当前位的 $ Pre $ 取最大就可以了。  

时间效率 $ O(n^2) $  


```cpp
#include<cstdio>
#include<string>
const int N=3002;
int n,m,r[N],v[N],s[N];
long long c;
#define _(d) while(d(isdigit(c=getchar())))
int R(){
    int x;char c;_(!);x=c^48;
    _()x=(x<<3)+(x<<1)+(c^48);return x;
}
int main() {
    n=R(),m=R();
    for(int i=1;i<=n;i++)
        for(int j=1,w=0;j<=m;j++) {
			if(!R()) s[j]=i,r[w=j]=0;
            else if(w>r[j]) r[j]=w;
            v[j]=v[r[j]]+1ll*s[j]*(j-r[j]);
            c+=1ll*i*j-v[j];
        }
return printf("%lld\n",c),0;}
```


---

## 作者：jinqiu (赞：0)

看开没有题解，我先发一个复杂度高的

灵活运用pair模拟栈，相似的题目<http://syzoj.com/problem/156

模板神犇Fmuckss

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long
using namespace std;

const int maxn=3e3+10;
int n,m;
int top;
int rectangle[maxn][maxn];
pair<int,int>stack[maxn];//栈中保证最高位置是单调增的，这样出栈的都是比他高的... 
LL ans;

int tot[maxn];//记录最高的高度 

int read();

int main(){
    int i,j;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            rectangle[i][j]=read();
    for(i=1;i<=n;i++){
        LL cnt=0;
        top=0;//每一行重新计数 
        pair<int,int>tmp;//存储当前的最高位置和宽度 
        for(j=1;j<=m;j++){
            if(rectangle[i][j]==0){//如果需要跳过那就清空数据 
                tot[j]=0;
                cnt=top=0;
                continue;
            }
            tot[j]++;
            tmp.first=tot[j];tmp.second=1;
            while(top&&tmp.first<=stack[top].first){//如果可以与栈顶合并 
                tmp.second+=stack[top].second;//合并到一起，宽度++ 
                cnt-=stack[top].first*stack[top].second;//此部分会在下面重复计算所以减去 
                top--;
            }
            stack[++top]=tmp;//入栈 
            cnt+=tmp.first*tmp.second;//当前结果就等于入栈的那个点的计算结果
            ans+=cnt;//统计当前结果，因为前面需要重复计算多个点的结果，所以只在这里相加 
        }
    }
    cout<<ans;
    return 0;
}

int read(){
    int t=0;
    char s=getchar();
    while(s<'0'||s>'9')
        s=getchar();
    while(s>='0'&&s<='9'){
        t=t*10+s-'0';
        s=getchar();
    }
    return t;
}
```

---

## 作者：MikeisFool (赞：0)

本弱的题解。思路和SPOJ705不同的子串思路类似。

<http://218.28.19.228/cogs/problem/problem.php?pid=1709>

大体思路如下：

求出每个点能向右延伸的最大长度，即到右边最近的0的距离，记为down[i][j]。

枚举矩形的左边界，剩下的就是求这一列上的down的矩形个数。

首先对列上的点按照down升序排序，鉴于down的取值范围为[0,m]，我们可以使用基数排序做到O(n+m)

然后并查集维护当前每个连续点集的大小(s)和最小的down值(Min)，当左边或右边相邻的点被访问过之后向两侧合并，此时该点所在集合的最小down一定比旁边集合的小，因此这次合并对答案的贡献为(Min[l]-Min[r])\*s[l]\*(s[l]+1)/2

最后合并出的集合对答案的贡献为Min[x]\*s[x]\*(s[x]+1)/2

时间复杂度为O(nmα(n))

我写的常数太大了，还望神犇成功AC

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N=3010;
typedef long long ll;
int n,m,down[N][N],fa[N],a[N],Min[N],s[N],sum[N];
long long ans;bool vis[N],tag[N][N];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
inline void merge(int l,int r){
    l=find(l);r=find(r);
    if (l==r) return;
    if (Min[l]<Min[r]){int z=l;l=r;r=z;}
    ans+=ll(Min[l]-Min[r])*s[l]*(s[l]+1)/2;
    fa[l]=r;s[r]+=s[l];
}
inline bool read(){
    char ch=getchar();
    while (ch!='0'&&ch!='1') ch=getchar();
    return ch=='1';
}
int main()
{
    //freopen("a.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    for (int j=1;j<=m;j++)
        tag[i][j]=read();
    for (int i=1;i<=n;i++){
        int p=1,next=0;
        while (p<=m){
            for (next=p;tag[i][next];next++);
            for (int j=p;j<next;j++) down[j][i]=next-j;
            p=next+1;
        }
    }
    for (int i=1;i<=m;i++){//计算列 
        memset(vis,0,sizeof vis);
        memset(sum,0,sizeof sum);
        memcpy(Min,down[i],sizeof Min);
        for (int j=1;j<=n;j++) fa[j]=j,s[j]=1;
        for (int j=1;j<=n;j++) sum[Min[j]]++;
        for (int j=m;j>=0;j--) sum[j]+=sum[j+1];
        for (int j=1;j<=n;j++) a[sum[Min[j]]--]=j;
        for (int j=1;j<=n;j++){
            vis[a[j]]=1;
            if (vis[a[j]-1]) merge(a[j]-1,a[j]);
            if (vis[a[j]+1]) merge(a[j],a[j]+1);
        }
        int x=find(1);
        ans+=(ll)Min[x]*s[x]*(s[x]+1)/2;
    }
    cout<<ans<<endl;
    return 0;
}
```

---


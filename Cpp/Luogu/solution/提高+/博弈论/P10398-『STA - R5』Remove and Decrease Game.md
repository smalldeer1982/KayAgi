# 『STA - R5』Remove and Decrease Game

## 题目描述

给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个，**保证 $\bm{a_i}$ 互不相同**。

Alice 和 Bob 轮流执行以下两种操作中的一种，并在操作后移除石子数为 $0$ 的石子堆。Alice 先手，不能执行操作的人判负。

- 对于每堆石子均取走一个石子。
- 移除石子数量最小的一堆石子。

在两人均采取最优策略的情况下，问谁可以获胜。你需要回答 $T$ 次询问。

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据：

- $1 \le T \le 2 \times 10^5$；
- $1 \le n \le 2 \times 10^5$；
- $1 \le a_i \le 10^9$；
- $a_i$ 互不相同；
- $\sum n \le 2 \times 10^5$。

具体部分分分配如下：

|Subtask 编号|数据范围|分值|
|:--------:|:--------:|:--------:|
|1|$n \le 2$|$3$|
|2|$a_i \le 1000$, $\sum n \le 10^4$|$23$|
|3|$\sum n^2 \le 2 \times 10^6$|$23$|
|4|$10^8 \le a_i \le 10^9$|$23$|
|5|无特殊限制|$28$|


## 样例 #1

### 输入

```
3
1
7
3
6 7 3
4
2 8 5 6
```

### 输出

```
Alice
Bob
Alice
```

# 题解

## 作者：User_Unauthorized (赞：22)

下文的推导中默认 $a_i$ 已按降序排列。

## SubTask 1

起到了帮助选手理解题意的作用。

首先若 $n = 1$ 则先手必胜。

因此当 $n = 2$ 时移除第二堆石子的玩家输掉游戏，那么此时两位玩家均不会进行第二种操作，否则会直接输掉游戏。因此此时两位玩家会轮流进行第一种操作，直到第二堆石子被移除。显然获胜的玩家和第二堆石子数量 $a_2$ 的奇偶性有关。我们有：当 $a_2$ 为偶数时，Alice 获胜；否则 Bob 获胜。

## SubTask 2

不难发现在 $a_i$ 按降序排列后游戏的任何时刻场上剩余的 $a$ 序列均为原序列的一个前缀全局删去某个数后形成的。因此不妨设 $f_{i, j}$ 表示当场上剩余的 $a$ 序列为原序列的前缀 $i$ 的所有元素均减去 $j$ 后得到的时先手是否必胜。枚举两种操作之后的局面即可实现转移，复杂度为 $\mathcal{O}(nV)$，其中 $V = \max\limits_{2 \le i \le n} a_i$。

## SubTask 3

此子任务和子任务 2 的区别在于值域，因此我们考虑值域过大时对于答案的影响。我们不妨猜测当值域过大时我们可以通过某种方式将值域控制在 $\mathcal{O}(n)$。这里先给出结论，在 SubTask 5 的题解中会给出详细证明。我们有结论：若 $a_i - a_{i + 1} > 3$ ，那么我们可以进行 $a_i \leftarrow a_i - 2$ 直至 $a_i - a_{i + 1} \le 3$。进而我们将值域控制在了 $\mathcal{O}(n)$，使用 SubTask 2 的做法即可。

## SubTask 4 & 5

正解部分。

首先我们可以得出石子堆被删除的顺序一定是石子数量少的先被删除，同时通过 SubTask 1 的分析可以得出删除石子数量次大的一堆的玩家一定会输。进而我们不妨直接移除数量最多的石子堆，进而游戏转化为了第一个不能操作的人可以取得胜利。

可以发现，**在大多数情况下**，两种操作可以被执行的次数是一定的，具体的，第一种操作大多数情况下会被执行 $a_1$ 次，同时第二种操作大多数情况下会被执行 $n - 1$ 次。注意在这里及以后的分析中已经移除的数量最多的石子堆，即 $n \leftarrow n - 1, a_i \leftarrow a_{i + 1}$。不难发现若两种操作可以被执行的次数是确定的，那么通过其和的奇偶性即可判断出胜方。

但是若当前石子数量最小的一堆数量为 $1$，那么操作方可以通过进行一次第一种操作使得该石子堆被移除，同时第二种操作的可执行次数减少一次，进而改变了其和的奇偶性。可以发现在 SubTask 4 的限制下若一方希望达成此操作那么需要双方连续操作大约 $10^8$ 次第一种操作才可以使得当前石子数量最小的一堆数量为 $1$，这显然是不可能的，因此在 SubTask 4 的限制下无需考虑此种特殊情况。

让我们继续分析上述特殊操作的达成条件，若某一方希望对某堆石子达成此操作以改变操作数量奇偶性，设该堆石子数量为 $w$，那么双方需要连续操作 $w$ 次第一种操作，同时该堆石子不能是仅剩的一堆石子。可以发现当 $w \ge 2$ 时一定不可能达成此操作。因此某一方可以达成上述操作必须满足当前石子数量最小的一堆石子数量为 $1$。而这种情况只会在游戏刚开始时出现。

但是若石子数量次小的一堆石子数量为 $2$，那么当前玩家完成上述特殊操作后另一方操作前也满足石子数量最小的一堆石子数量为 $1$，其也可以继续进行上述特殊操作。

> 进而我们可以证明 SubTask 3 中提到的结论：若 $a_i - a_{i + 1} = 1$，那么其意味着对第 $i$ 堆石子进行特殊操作后可以继续对第 $i + 1$ 堆操作进行。反之特殊操作的可行性不会传递，因此仅有其奇偶性影响胜负。

同时先手会进行特殊操作当且仅当当前操作数量奇偶性对其为劣势，那么在其操作后的操作数量奇偶性一定对后手为劣势，此时若后手可以继续执行上述特殊操作那么一定会执行。

因此我们可以得出，双方在进行上述特殊操作时的策略为只要上一名玩家执行了特殊操作，那么便一直尽可能地执行下去直至不能执行为止。进而我们可以得出双方对于该特殊操作会进行的轮数。进而可以判断这种特殊操作对总计操作数奇偶性的影响。

不难发现是否进行特殊操作的决定权在先手，因此特殊操作一定会对 Alice 有利，具体的，若在不考虑特殊操作的情况下 Alice 必败且特殊操作可以进行奇数轮，那么 Alice 可以进行特殊操作进而取得胜利。

综上，我们得到了先手必胜的充要条件：不考虑特殊情况下其必胜或特殊操作可以进行的轮数为奇数。

时间复杂度为 $\mathcal{O}(\sum n \log n)$，瓶颈在于排序。

---

## 作者：251Sec (赞：8)

设 $a$ 从小到大排序。

考虑 $n=1$：显然先手必胜。

考虑 $n=2$：双方会轮流取一个石子直到第一堆被取完。所以答案只和 $a_1$ 的奇偶有关。

对于 $n>2$ 的情况，注意到以下结论**几乎**成立：

- 除了最后一次操作，每次操作中石子堆数 $n$ 和 $a_{n-1}$ 恰有一个的奇偶性改变。

我们知道 $n=2$ 时答案只和 $a_{n-1}$ 的奇偶性有关，所以这里 $n>2$ 时答案只和 $n+a_{n-1}$ 的奇偶性有关。你写了一发交上去发现只有 $26$ 分。

哪里错了？发现 $a_{1}=1$ 的时候进行取一个的操作，会使得 $n$ 和 $a_{n-1}$ 都改变，这样就错了。我们还需要继续发掘性质。我们不妨先令刚刚推出的状态为「几乎必胜」和「几乎必败」的状态。有性质：

- 「几乎必胜」的状态是必胜状态，「几乎必败」且 $a_1>1$ 的状态是必败状态。

证明：前者进行一次取最小值的操作会变成后者，后者无论如何都会变成前者。

现在唯一我们不知道会不会赢的状态是 $a_1=1$ 且「几乎必败」的状态，但这种状态下先手的选择是唯一的：只能进行取一个的操作拼一把，那么我们直接递归判断操作后的游戏是否必胜即可。总复杂度 $O(n \log n)$，瓶颈在排序。注意到发生递归的状态都满足 $a_i=i$，则存在 $O(n)$ 的实现方法。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n, a[200005];
bool Check(int x, int y) {
	if (x == 1) return 1;
	if (x == 2) return !((a[n - 1] - y) & 1);
	if (a[n - x + 1] - y != 1) return !((x + a[n - 1] - y) & 1);
	return !Check(x - 1, y + 1) || !Check(x - 1, y);
}
int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) scanf("%d", a + i);
		sort(a + 1, a + n + 1);
		puts(Check(n, 0) ? "Alice" : "Bob");
	}
	return 0;
}
```

---

## 作者：yrwricky (赞：7)

## 思路

### 预处理

我们观察题目中的两种操作：

- 第一种操作与石子堆的顺序**无关**。
- 第二种操作只与**最少**的一堆石子**有关**。

于是，我们选择**升序排序**。

后续的推理皆在升序排序的基础上进行。

### 观察

当 $n=1$ 时，先手只需执行第二种操作，即可取胜。

当 $n=2$ 时，最后一个拿第 $1$ 堆石子的必败。

当 $n=3$ 时，最后一个拿第 $2$ 堆石子的必败。

当 $n=4$ 时，最后一个拿第 $3$ 堆石子的必败。

于是，我们发现，最后一个拿第 $n-1$ 堆石子的必败。

### 思考1（Subtask 4）

#### 思路

应该看到 **Subtask 4** 中的 $a_i$ 有下限了罢

由于第一种操作在**大部分情况**下不会改变石子堆的数量，那么，第一个拿第 $n-1$ 堆石子的取决于 $n-1$ 的奇偶性。

同样的，最后一个拿第 $n-1$ 堆石子的取决于 $a_{n-1}+n-1$ 的奇偶性。

根据观察，我们发现：

- 当 $a_{n-1}+n-1$ 是奇数，后手将最后一个拿第 $n-1$ 堆石子，先手必胜。
- 当 $a_{n-1}+n-1$ 是偶数，先手将最后一个拿第 $n-1$ 堆石子，先手必败。

再结合 $n=1$ 的特判，我们有了：

#### 代码（26pts）

```cpp
sort(a+1,a+1+n);
if(n==1 || (a[n-1]+n-1)%2==1)
	puts("Alice");
else
	puts("Bob");
```

### 思考2

#### 思路

上述思路的问题在于，第一种操作也有可能改变总石子堆数量。

如下是一个反例：

```
1 2 3 6 7
```

正确输出：`Alice`

第一版代码输出：`Bob`

进一步观察，想让第一种操作改变总石子堆数量，只有当最小的数是 $1$ 时才会发生。

但是，改变总石子堆数量，能改变最后的胜负吗？

我们不妨设有最小的 $m$ 个数，使得任意两个相邻的数都相差 $1$ ，且最小的数是 $1$ 。

观察后，我们发现，最大的 $m$ 可能会改变最后的胜负，而且只有先手才能改变胜负。实际情况如下：

- 当 $m \neq n-1$ 且 $m$ 为奇数时，先手必胜。
- 当 $m=n-1$ 且 $m$ 为偶数时，先手必胜。
- 其他情况下，胜负不变。

综上，我们有了：

#### 代码（100pts）

```cpp
sort(a+1,a+1+n);
for(int i=1;i<=n;i++)
	if(a[i]==i)
		m++;
if(n==1 || (a[n-1]+n-1)%2==1 || m!=n-1 && m%2==1 || m==n-1 && m%2==0)
	puts("Alice");
else
	puts("Bob");
```

## 总代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, m, a[200001];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		m=0;
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		sort(a+1,a+1+n);
		for(int i=1;i<=n;i++)
			if(a[i]==i)
				m++;
		if(n==1 || (a[n-1]+n-1)%2==1 || m!=n-1 && m%2==1 || m==n-1 && m%2==0)
			puts("Alice");
		else
			puts("Bob");
	}
	return 0;
}
```

---

## 作者：sbno333 (赞：3)

这是一道博弈论题。

对于博弈论，一般有两种做法，一种是 NIM 的玩法，即强行找到怎么抉择并证明其正确性。

还有就是这道题的子问题考虑法，很多看上去是 NIM 游戏的变种，其实是这种的游戏。

对于子问题考虑我们一般从极小的子问题出发，逐渐扩大，知道与原问题相同，得到解。

这道题我们首先显然要从小到大排序。

我们发现大的数总是在小的后面取完。

对于 $n=1$，显然此时先手必胜。

对于 $n=2$，此时先取走某堆石子的显然输。

此时操作二显然不能动用，因此判断次大值奇偶性即可。

接着考虑如何从小问题出发到大问题。

发现如果以最小的几个为小问题，每一次加入一堆有更多石子的石子堆不太可做，考虑从大到小。

此时二人玩前 $k$ 多的石子堆，$k>2$，且前 $k-1$ 多的石子堆先手胜负状态已知。

假设先手在 $k-1$ 下必败。

则先手可以把最小的一堆取走，变成对方先手的 $k-1$ 子问题，由于 $k-1$ 中先手必败，此时 $k$ 问题中先手必胜。

假设先手在 $k-1$ 下必胜。

先手如果直接取走最小，显然会输，所以选择操作一。

此时减完后发现如果石堆数量减少会变得复杂，所以待会考虑。

因此不妨设所有都大于 $1$。

假设 $k=3$，都减 $1$ 后对于 $k-1$ 问题结果改变，由于大前提，所以是变成了必败，后手可以取走最小的石堆，变成先手的 $k-1$ 问题，此时为必败，由于 $k-1$ 问题为必败时 $k$ 问题为必胜，因此当 $k-1$ 问题改变时 $k$ 问题改变。

设 $k=4$，同理，$2$ 问题改变，导致 $k-1$ 问题改变，仿照上一个，$k$ 问题必败，$k$ 问题相对 $k-1$ 问题改变，当 $k-1$ 问题改变时 $k$ 问题改变。

因此我们可以先处理 $n=2$，此时较小的那个为奇数时先手必败，否则必胜。

接着 $n$ 每增加 $1$，答案取反。

接着就是考虑复杂的当前为 $1$ 的情况。

显然这只会在最后一次处理时出现。

此时取完后当前石子消失，$k-2$ 发生改变，从先手必败变成必胜，所以后手不能取走 $k-1$，而应当再次各取走一个石子，此时如果第 $k-1$ 大的不为 $1$，此时 $k-2$ 重新必败，回到先手时取走 $k-1$，先手必胜。

当 $k-1$ 在先手取完后为 $1$ 时，再次取走时 $k-3$ 从必败变为必胜，同理，如果 $k-2$ 两次取完后不为 $1$，则后手必胜。

以此类推，每次轮到一堆取得次数改变加一，胜负取反，即比上一堆多一，状态取反。

于是代码出炉。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000009];
signed main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		sort(a+1,a+1+n);
		if(n==1){
			cout<<"Alice"<<endl;
		}else{
			bool fl;
			fl=!(a[n-1]&1);
			for(int i=n-2;i>=1;i--){
				fl=!fl;
				if(a[i]==1&&fl==0){
					for(int j=i;j<=n-2;j++){
						if(a[j]==a[j-1]+1){
							fl=!fl;
						}else{
							break;
						}
					}
				}
				
			}
			cout<<(fl?"Alice":"Bob")<<endl;
		}
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

第一次场切蓝诶！

出题人给的部分分赛时启发了我，赞美出题人！

---

观察到石子堆的先后与答案并不存在什么关系，因为操作二是移走最少的一堆，执行若干次操作一先空掉的也必然是石子数量少的堆，所以不妨考虑将 $a_i$ 按升序排序。

首先我们知道当 $n=1$ 时显然先手糊个操作二上去就秒了，先手必胜。注意，此时的先手指的是拿到 $n=1$ 局面的那位选手，并不特指 Alice。下文中的先后手同理，并不特指某人。

由此可推出，没有人会心甘情愿的将 $n=1$ 的局面送出去。所以在某人拿到 $n=2$ 的局面时，他必不会想着去消堆使 $n-1$，定会做操作一把这一局面让给另一人，除非做操作一也会消去一堆。可以发现此时拥有必胜策略的人是和 $a_{n-1}$ 的奇偶性挂钩的。

具体的，在 $n=2$ 时，当 $a_{n-1} \bmod 2=0$，先手必胜；否则后手必胜。

思考到这里，恭喜你已经可以拿到第一部分的 $3$ 分。

---

接着往下想 $n>2$ 的情况。

因为保证了 $a_i$ 互不相同，所以不会出现一个操作一双消的情况。换句话说，一个操作能消的堆数为零或一。

所以，当每个操作一必消一堆时，必胜策略就是看 $n$ 的奇偶性。因为即使你不想用操作一改用操作二，也不影响对于 $n$ 奇偶性的依赖。而后手若想改用延时，先手学习就可以变成一样是原局面。

现在出现的唯一变数就是当有些数字连不上该怎么办。我们假设连上的数字有 $i$ 个。

当 $n-i<2$ 时显然该输的输，该赢的赢，结局已然注定，与 $n$ 的奇偶相挂钩。

其他的，当 $i \bmod 2=1$ 时，先手对于最后一个连续值的处置是随心所欲的，于是可以决定剩下数字的奇偶性。可以断言这样先手就能够运用智慧达到必胜。

其他情况下，后手必然还是采取学习策略，所以剩下数值是可以预见的。而之后，对于必胜的一方肯定会阻止操作一重新能够灭堆，操作一和操作二的贡献就分离了，我们于是可以钦定操作二执行完以后只剩两堆再进行操作一。

情况又化简成上面的了。所以操作数 $x$ 是易于计算的。

胜负显然与 $x$ 奇偶性挂钩。

---

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005];
signed main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        sort(a+1,a+1+n);
        int i;
        for(i=1;i<=n;i++){
            if(i!=a[i])break;
        }i--;
        if(n-i<2){
            if(n%2)puts("Alice");
            else puts("Bob");
            continue;
        }
        if(i%2){
            puts("Alice");
            continue;
        }
        int x=(n-2+a[n-1]-i)%2;
        if(x)puts("Bob");
        else puts("Alice");
    }
    return 0;
}
```

---

后记：这篇题解是从 2024 年 5 月 5 日开始写的，但由于后来颓废了一会所以咕到了 2025 年 3 月 17 日，作者的素质实在太高了！/cf

---

## 作者：fulichang (赞：2)

~~不知道为啥是蓝题，感觉有点好写，和正解有点不一样，交一发试试。~~

第一眼看见题目就是博弈论，直接先把最好拿的 3 分拿下。

思路：当 $n = 1$ 时，`Alice` 赢。

当 $n = 2$ 时，双方都只能每次把每堆石子都拿走一颗，否则双方各拿一堆自己就判负了。而一直重复以上操作最后只会剩下一堆石子，所以当操作时剩下的石子数为 $1,x$ 时，谁先手谁输，再所以，当剩下两堆石子时，石子数量较少的一堆为奇数则对方赢，否则自己赢（注意：是对方赢而不是 `Bob` 赢）。

# 3 分 Code：
```
#include <bits/stdc++.h>

const int N = 2e5 + 10;

int t;
int a[N];

int main (void) {
	std::cin >> t;
	while (t--) {
		int n, f = 0;
		std::cin >> n;
		if (n == 1) {
			std::cin >> a[1];
			puts("Alice");
			continue;
		}
		for (int i = 1; i <= n; i++)
			std::cin >> a[i];
		int t = std::min(a[1], a[2]);
		if (t % 2)
			puts("Bob");
		else
			puts("Alice");
	}
	return 0;
}
```
三分到手。

**接下来是 26 分。**

~~其实一开始想拿满分的。。。~~

我们继续往下考虑：想办法把 $n > 2$ 的情况转化为 $n \le 2$ 的情况。

其实 $n > 2$ 和 $n = 2$ 的情况类似，要想办法使得到自己进行操作时只剩下一堆石头，可以转化为对 $n$ 大小奇偶性和对**次小值**奇偶性的判断。即：要**给对方留下**偶数堆石头且次小值为奇数或者奇数堆石头且次小值偶数。

所以当 $n \bmod 2=0$ 且次小值 $mval \bmod 2=0$ 或者 $n \bmod 2=1$ 且次小值 $mval \bmod 2=1$ 时，应拿走一整堆石子，否则应把每堆石子拿走一颗。
# 26 分 Code：
```
#include <bits/stdc++.h>

const int N = 2e5 + 10;

int t;
int a[N];

std::string change (int x) {
	return x ? "Bob" : "Alice";
}

int main (void) {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> t;
	while (t--) {
		int n, f = 0; //f=0,A先手,f=1,B先手
		std::cin >> n;
		for (int i = 1; i <= n; i++)
			std::cin >> a[i];
		std::sort(a + 1, a + n + 1);
		int nm = a[n - 1];
		while (true) {
			if (n == 1) {
				std::cout << change(f) << std::endl;
				break;
			}
			if (n == 2) {
				std::cout << (nm % 2 ? change(f ^ 1) : change(f)) << std::endl;
				break;
			}
			if (n % 2 && nm % 2 || n % 2 == 0 && nm % 2 == 0)
				n--;
			else
				nm--;
			f ^= 1;
		}
	}
	return 0;
}
```
一遍过样例，自信提交。

26 分？！

凭啥啊？

看看啊，过了第一和第四个捆绑数据，第四个数据的特殊限制为 $10^8 \le a_i \le 10^9$ 那么 $a_i$ 就不会出现 1，所以问题应该和 1 有关系。

可以发现，当 $a_i$ 最小值为 1 时，不管进行什么操作，石子总堆数都会减 1，加个特判就可以了。

# 满分 Code：
```
#include <bits/stdc++.h>

const int N = 2e5 + 10;

int t;
int a[N];

std::string change (int x) {
	return x ? "Bob" : "Alice";
}

int main (void) {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> t;
	while (t--) {
		int n, f = 0, minum = 1, cnt = 0; //f=0,A先手,f=1,B先手,minum为最小值的编号，cnt为拿走所有石子堆一颗石子的次数
		std::cin >> n;
		for (int i = 1; i <= n; i++)
			std::cin >> a[i];
		std::sort(a + 1, a + n + 1);
		int nm = a[n - 1];
		while (true) {
			if (n == 1) {
				std::cout << change(f) << std::endl;
				break;
			}
			if (n == 2) {
				std::cout << (nm % 2 ? change(f ^ 1) : change(f)) << std::endl;
				break;
			}
			if (n % 2 && nm % 2 || n % 2 == 0 && nm % 2 == 0)
				n--, minum++;
			else
				nm--, cnt++;
			while (a[minum] <= cnt)
				minum++, n--;
			f ^= 1;
		}
	}
	return 0;
}
```
AC 辣！！！

欧耶！！！

---

## 作者：_Cheems (赞：2)

令 $a_1\dots a_n$ 升序排列。

* $n=1$：显然先手必胜。
* $n=2$：此时先拿走 $a_1$ 的必败，即 $2\mid a_1$ 时先手必胜。
* $n>2$：
	* $n=2$ 做法的拓展：不难发现，操作过程可以看成直接挪走 $a_1\dots a_{n-2}$、依次取走 $a_{n-1}$、最后直接挪走 $a_n$。即总步骤是 $a_{n-1}+n-1$，若为奇数先手必胜，称其为“胜方”（反之后手为“胜方”）。
    
   * hack：$a_1=1$ 就能 hack 上述做法，称其为特殊堆。
   
   * 先手为“胜方”：因为 $a_1<a_2\dots <a_n$，因此只要“胜方”优先使用操作二，那么任意局面都不可能出现特殊堆。因此，先手为“胜方”时一定必胜。
   
   * 先手为 “败方”：$a_1=1$ 时先手必然会使用操作一，使得自己逆袭为“胜方”。$a_1>1$ 时先手怎么操作都无法逆袭了。依次类推，不难发现双方会轮流挪走特殊堆实现逆袭，直到特殊堆不存在。具体地，记 $cnt$ 为特殊堆操作次数，则 $2\nmid cnt$ 时先手必胜，反之后手必胜。
   
   * 小细节：$cnt$ 只应该计算 $a_1\dots a_{n-2}$，而不能算 $a_{n-1}$。这是因为挪走 $a_{n-1}$ 后必输无疑。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int T, n, a[N];

int main(){
	cin >> T;
	while(T--){
		scanf("%d", &n);
		for(int i = 1; i <= n; ++i) scanf("%d", &a[i]);
		sort(a + 1, a + 1 + n);
		if(n == 1) printf("Alice\n");
		else if(n == 2) printf("%s\n", (a[1] & 1) ? "Bob" : "Alice");
		else{
			int cnt = 0;
			for(int i = 1; i <= n - 2; ++i) cnt += (a[i] == i); //a[i]=i时可以进行特殊操作。不用break是因为a[i]!=i则后面都不满足条件 
			if((n - 1 + a[n - 1]) & 1) printf("Alice\n");
			else printf("%s\n", (cnt & 1) ? "Alice" : "Bob");
		}
	}
	return 0;
}
```

---

## 作者：liangbowen (赞：1)

[blog](https://www.cnblogs.com/liangbowen/p/18573481)。博弈论。

---

考虑使用 AGC002E 的方法分析：将 $a_i$ 升序排列，然后画成下图状物。

![](https://cdn.luogu.com.cn/upload/image_hosting/zpf3nica.png)

一次操作相当于**消掉最下面的一行 / 最左边的一列**，消完的人胜利。

将这个问题转换为：你在左下角，每次可以往上面（上面是空的就走到右上）/ 右边走一步，谁先走到最后一列就赢了。

于是可以写出 $O(\sum a_i)$ 的弱智 DP，答案即 $dp_{1,1}$。获得 $23$ 分的高分。

---

下文令 $(a,b)$ 表示到达第 $a$ 堆石子第 $b$ 行的位置。

打表有一些观察：$(a,\text{?})$ 处，除去最顶上的位置，其余位置胜负态交替。出现这个的原因是「上面是空的就走到右上」，所以可能需要特判边界。

正解就是模拟这个 DP。考虑 $(2,1)$，由于 $a_i$ 互不相同，故 $a_2\ge2$，$(2,1)$ 不会受到边界情况牵制。于是 $(2,1)$ 为胜利当且仅当 $n=1$ 或 $a_{n-1}\equiv n\pmod 2$。

若 $(2,1)$ 输了，此时：

+ 若 $a_1\ge2$，此时考虑 $(1,2)$ 位。注意到此时 $a_2\ge3$，结合 $(2,1)$ 输了，则 $(1,2)$ 必胜，进而 $(1,1)$ 位的两个决策都会使对手进入必胜态，于是此时直接输出 `Bob`。
+ 否则 $a_1=1$，此时考虑 $(2,2)$ 位：也就是把下面一行删掉，进而成为了一个大小为 $(n-1)$ 的子问题，这个子问题的答案与原问题的答案相反。

想清楚后，这个「分治」的过程也可以用循环简单 $O(n)$ 实现。

---

## 作者：operator_ (赞：1)

# P10398 『STA - R5』Remove and Decrease Game

[题目传送门](https://www.luogu.com.cn/problem/P10398)

## 题解

记搜题解。

先把 $a$ 从小到大排序。考虑到两种操作都不改变相对顺序，设状态 $f_{i,j}$ 表示考虑从 $a_i$ 到 $a_n$ 这一段，前面进行了 $j$ 次 $1$ 操作的情况下先手能不能赢。转移也是简单的：

$$f_{i,j}=\begin{cases}1&j>a_i\\f_{i+1,j}&j=a_i\\\neg f_{i+1,j}\operatorname{or}\neg f_{i,j+1} &j<a_i\\\end{cases}$$

这个状态肯定爆了，但是打个表找找规律可以发现 $j<a_i$ 时这个东西大概率是 $01$ 相间的，更进一步即当 $j\le a_i-2$ 时，证明也许可以归纳（？）。

所以我们只需要保留 $O(1)$ 个状态，本题就做完了。不过这样直接 $dp$ 不太好写，可以考虑记忆化搜索。

代码：

```cpp
/*
 * @Author: operator_ 
 * @Date: 2024-05-02 13:51:14 
 * @Last Modified by: operator_
 * @Last Modified time: 2024-05-02 19:30:52
 */
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
int n,a[200005],f[200005][5],vis[200005][5];
bool get(int i,int j) {
    if(i==n||j>a[i]) return 1;
    if(j<a[i]-3) j+=(a[i]-2-j)/2*2;
    if(!vis[i][a[i]-j]) vis[i][a[i]-j]=1,f[i][a[i]-j]=(a[i]==j?get(i+1,j):!(get(i+1,j)&get(i,j+1)));
    return f[i][a[i]-j];
}
signed main(){
    for(int tt=rd();tt;tt--) {
        cin>>n;
        for(int i=1;i<=n;i++) a[i]=rd();
        for(int i=1;i<=n;i++) for(int j=0;j<=3;j++) f[i][j]=vis[i][j]=0;
        sort(a+1,a+n+1);
        puts(get(1,0)?"Alice":"Bob");
    }
    return 0;
}
```

---

## 作者：TimSwn090306 (赞：0)

提供一种二维平面建模的做法。

## 1.题意简述

> 给定 $n$ 堆石子，每次可以将最少的一堆石子全部拿走，或将每一堆石子都拿走一个。
>
> 无法操作者输，问先手必胜还是后手必胜。
>
> $n\le 2\times 10^5$。

## 2.解题分析

经典建模。

首先对 $a$ 排序，考虑在二维平面绘制 $a$ 的柱状图，即将 $(i,1\thicksim a_i)$ 格子染色。

然后每一种操作就转化为将横坐标轴向上挪一格或者将纵坐标向右挪一格，如果当前坐标轴第一象限内没有染色格子，则当前操作者输。

用 $F_{x,y}=0/1$ 表示当前横纵坐标构成的坐标系以 $(x,y)$ 格子为 $(1,1)$ 时当前操作者必胜或者必败。

则 $F_{x,y}$ 可以从 $F_{x+1,y},F_{x,y+1}$ 得到。特殊的，$F_{x,a_x}$ 从 $F_{x+1,y},F_{x+1,y+1}$ 得到，以及有 $F_{n,y}=1$。

不难发现每一列的 $F$ 值必然 $0/1$ 交错，除了 $F_{i,a_i},F_{n,y}$。数学归纳易证。

维护每一列最上端是 $0/1$，每一列从下往上是 $0/1$ 交错还是 $1/0$ 交错即可。

时间复杂度 $O(n\log n)$，瓶颈在于排序。

## 3.代码实现


```cpp
#include <bits/stdc++.h>
#define fin(str) freopen(str,"r",stdin)
#define fout(str) freopen(str,"w",stdout)
#define ll long long
using namespace std;

const int maxn=2e5+5;

int T,n,a[maxn],flag[maxn],top[maxn];

inline void solve(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	if (n==1) return (void)printf("Alice\n");
	sort(a+1,a+n+1);
	
	flag[n-1]=!(a[n-1]&1),top[n-1]=0;
	for (int i=n-2;i;i--){
		int x=(a[i]&1)^(!flag[i+1]);
		int y=!x;
		if (a[i]+1==a[i+1]) y=top[i+1];
		if (x&y){
			top[i]=0;
			flag[i]=!(a[i]&1);
		}else if (x==1 && y==0){
			top[i]=1;
			flag[i]=!(a[i]&1);
		}else{
			top[i]=1;
			flag[i]=a[i]&1;
		}
	}
	
	if (a[1]==1) printf("%s\n",top[1]?"Alice":"Bob");
	else printf("%s\n",flag[1]?"Alice":"Bob");
}

int main(){
	scanf("%d",&T);
	while (T--) solve();
	
	return 0;
}

```

---

## 作者：oyoham (赞：0)

### Problem  
给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个，**保证 $\bm{a_i}$ 互不相同**。

Alice 和 Bob 轮流执行以下两种操作中的一种，Alice 先手，不能执行操作的人判负。

1. 对于每堆石子均取走一个石子。
1. 移除石子数量最小的一堆石子。

问谁可以获胜。
### Solution
设下文所说的 $a$ 数组均为降序排序后的数组。  
$n=1$ 直接 Alice 胜。  
$n=2$ 时，双方必定选操作 $1$，此时，若 $a_2$ 为偶数，先手胜，否则后手胜。  
$n>2$ 时，若 $n+a_2$ 为偶数，则先手会在 $n>2$ 时优先选择操作 $2$，双方每次操作后，此时操作 $1$ 会 $a_2 \gets a_2-1$，操作 $2$ 会 $n \gets n-1$,此时先手胜，否则若 $a_n > 1$ 后手在先手操作后按照以上操作，则后手胜。  
若 $a_2+n$ 为奇数，但是 $a_n=1$，则先手使用操作 $1$ 即可使 $a_2 \gets a_2-1,n \gets n-1$，若操作后仍有 $a_n=1$，则另一方仍使用此操作，直到 $a_n\ne1$
 为止。  
综上，我们就可以判断是否有先手必胜。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x<0ll) putchar(45),x=~x+1;
	if(x>9ll) write(x/10);
	putchar(x%10|48);
}
int T=read();
int a[100005];
bool check(int x){
	int t=x,ret=0;
	while(a[t]==x+1-t&&t>=3){
		t--;
		ret^=1;
	}
	return ret;
}
signed main(){
	while(T--){
		int n=read();
		for(int i=1;i<=n;i++) a[i]=read();
		sort(a+1,a+n+1,greater<int>());
		if(n==1||(a[2]+n+1)%2==1||check(n)) puts("Alice");
		else puts("Bob");
	}
}
```

---

## 作者：cute_114514eggy (赞：0)

一道不难的数学题，有两种操作：  
1. 对于每堆石子均取走一个石子
2. 移除石子数量最小的一堆石子  

现在要问 T 局每一局谁能获胜，怎么办呢？

首先，我们要有一个从易到难的思维，但是乱序很难分析，所以要从小到大排序一下，排完后分析一下：  
当 $n=1$ 时，先者用 2 必胜。  
当  $n=2$ 时，若 $a_1$ 是奇数，后者必胜，若 $a_1$ 是偶数的话，先者必胜。  
后面就不好分析了，所以要找到前两次分析的规律，并且很合理。  
仔细观察可以发现几乎都跟 $a_{n-1}$ 相关，那么根据 $a_{n-1}$ 这个切入点就可以开始真正的找规律了！  
我们把 1 操作看成勤，把 2 操作看成贪，仔细观察可发现 $a_{n-1}+n-1$ 是奇数的时候胜者一定是先者，但 $a_{n-1}+n-1$ 是偶数的时候胜者不一定是后者（为什么？ 反例：1 3 4 6），我们没考虑到一个重要的点：如果开头有序的（有序的指从一开始的公差为一的等差数列），那么进行勤操作就会错，那么又得需要我们的惊人的注意力！  
根据简单的找特例可发现如果有序的数列的末项是 $n-1$ 并且 $n$ 是奇数的话先者胜，如果末项不是 $n-1$ 并且末项大于零并且末项是奇数的话，还是先者胜，所以我们就找到了规律！  
下面附上写了 2 小时的代码：
# code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a;
    cin>>a;
    while(a--)
    {
        long long b,sum=0;
        long long c[10000010];
        cin>>b;
        for(int i =1;i<=b;i++)
        {
            cin>>c[i];
        }
      //排序
        sort(c+1,c+b+1);
        for(int i = 1;i<=b;i++)
        {
          //找有序的数列的末项
            if(c[i]==i)
            {
                sum=i;
            }
            else
            {
                break;
            }
        }
      //特判
        if(b==1)
        {
            cout <<"Alice"<< endl;
        }
        else if(b==2)
        {
            if(c[1]%2==1)
            {
                cout <<"Bob"<< endl;
            }
            else
            {
                cout <<"Alice"<< endl;
            }
        }
        else
        {
          //判断谁胜
            if((c[b-1]+(b-1))%2==1)
            {
                cout <<"Alice"<< endl;
            }
            else if(sum==b-1&&b%2==1)
            {
                cout <<"Alice"<< endl;
            }
            else if(sum>0&&sum%2==1&&sum!=b-1)
            {
                cout <<"Alice"<< endl;
            }
            else
            {
                cout <<"Bob"<< endl;
            }
        }
    }
	return 0;
}
```
谢谢大家！

---

## 作者：qczrz6v4nhp6u (赞：0)

写一下考场做法。

### Solution

默认 $a$ 升序排序。

$n\le 2$ 的 case 是显然的，此处不再赘述。

一个简单的观察是一个局面仅与当前操作 1 的次数和最小数的下标决定。使用朴素的对抗搜索可以做到 $O(nV)$，结合 $n\le 2$ 的 case 可以获得 $26$ 分。

放一下 $26$ 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
constexpr int N=2e5+5;
int n,a[N];
int f[10005][1005];
int solve(int i,int j){
	if(i==n)return 0;
	if(j>=a[i+1])return solve(i+1,j);
	if(~f[i][j])return f[i][j];
	return f[i][j]=!solve(i+1,j)|!solve(i,j+1);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		if(n==1){
			cout<<"Alice\n";
		}
		else if(n==2){
			int minn=min(a[1],a[2]);
			cout<<(minn&1?"Bob":"Alice")<<'\n';
		}
		else{
			sort(a+1,a+n+1);
			for(int i=0;i<=n;i++)
				for(int j=0;j<=1000;j++)
					f[i][j]=-1;
			cout<<(solve(0,0)?"Alice":"Bob")<<'\n';
		}
	}
	return 0;
}
```

考虑观察 $n>2$ 时 `f` 数组有什么性质。考虑扫描线（？）。

不难发现第 $n-1$ 行 $[0,a_n)$ 范围内均为 $1$，第 $0$ 到 $n-2$ 行 $[0,a_{i+1}-1)$ 范围内是 $01$ 相间的，且第 $i$ 行的对应位置与 $i+1$ 行相反。证明考虑归纳。

此时发现递归中 $j\ge a_{i+1}$ 的 case 是混乱邪恶的。我们考虑解决 $a_i=i$ 的 case（为啥没有这个 subtask）。

不难发现 $n\equiv 1\pmod 2$ 时 Alice 胜，否则 Bob 胜。

考虑推广到一般情况。设 $pos$ 满足 $\forall i\in [1,pos],a_i=i$ 且 $a_{pos+1}\ne i$。那么给上述模型的输入只有三种：

1. 全 $0$。（对应 $pos=n$）

2. 全 $1$。（对应 $pos=n-1$）

3. $01$ 相间。（对应 $pos<n-1$）

全 $0$ 的情况已经讨论过。打表可以发现剩下两种情况对应的结论：

- 全 $1$：若 $pos\equiv 1\pmod 2$ 则 Bob 胜，否则 Alice 胜。

- $01$ 相间：若 $pos\equiv 1\pmod 2$ 则 Alice 胜；否则若输入以 $1$ 开头，Alice 胜，否则 Bob 胜。

获取输入的开头是容易的：注意到此时扫一行相当于取反，我们只需要知道最开始是多少，以及取反了多少次。

综合上述情况，我们可以写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
constexpr int N=2e5+5;
int n,a[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+n+1);
		bool ans;
		if(n==1)ans=1;
		else if(n==2)ans=!(a[1]&1);
		else{
			int pos=0;
			for(int i=1;i<=n;i++)
				if(a[i]==i)pos=i;
				else break;
			if(pos==n)ans=n&1;
			else if(pos==n-1)ans=!(pos&1);
			else ans=(pos&1)||!(a[n-1]&1)^((n-pos)&1);
		}
		cout<<(ans?"Alice":"Bob")<<'\n';
	}
	return 0;
}
```

时间复杂度 $O(\sum n\log n)$，可以通过。

---

## 作者：是青白呀 (赞：0)

首先特判掉 $n=1$ 的情况。通过手玩堆数较小的情况，可以总结出下面两条判据：

1. 设总的堆数为 $n$，将每一堆石头按其数量大小排序，次大的一堆中石头数量为 $x$，若 $n$ 与 $x$ 同奇偶，则先手必胜。

2. 若判据 $1$ 中 $n$ 与 $x$ 不同奇偶，设参数 $k$ 是满足下列两个条件的最大的非负整数：

    - $k\leq n-2$。
    - 对任意满足 $i\geq 1$ 且 $i\leq k$ 的正整数 $i$，均有第 $i$ 小的石子堆中的石子数为 $i$。
    
   若 $k$ 为奇数，则先手必胜，否则先手必败。
   
下面归纳地给出证明：

当 $n=2$ 时，显然两人都不会把最小的那一堆拿完。则两人会依次在每一堆中都拿走 $1$ 个石子。
- 较小的那一堆（也就是次大的那一堆）为偶数时，先手必胜，考虑判据 $1$：此时 $n$ 与 $x$ 奇偶性相同。
- 较小的那一堆为奇数时，先手必败。考虑判据 $2$：由于 $k\leq n-2=0$，故 $k=0$。

因此，$n=2$ 时两条判据均成立。

当 $n>2$ 时，假设堆数为 $n-1$ 时两条判据均成立。
- 当 $n$ 与 $x$ 奇偶性相同时，先手可以移除石子数最少的一堆石子，此时 $n$ 减少 $1$，$x$ 不变，且最小的一堆（即移除之前次小的一堆）中石子数一定不为 $1$，即 $k=0$。根据两条判据的描述得知，移除后的状态先手必败，故移除前  $n$ 与 $x$ 奇偶性相同时先手必胜。判据 $1$ 成立。
- 当 $n$ 与 $x$ 奇偶性不同，且 $k=0$ 时，先手有两种操作方案：
    - 移除石子数量最小的一堆，此时 $n$ 减少 $1$，$x$ 不变， $n$ 与 $x$ 奇偶性变得相同。根据判据 $1$ 可知移除后先手必胜，故在移除前，此操作方案先手必败。
    - 从每一堆中取走 $1$ 个石子，由于最小的一堆石子数不为 $1$，此时 $n$ 不变，$x$ 减少 $1$，$n$ 与 $x$ 奇偶性变得相同。根据判据 $1$ 可知移除后先手必胜，故在移除前，此操作方案先手必败。
    
  综上，当 $n$ 与 $x$ 奇偶性不同，且 $k=0$ 时，先手必败。
  
- 当 $n$ 与 $x$ 奇偶性不同，且 $k>0$ 时，同样考虑归纳证明：假设参数为 $k-1$ 时，判据 $2$ 成立，此时先手有两种操作方案：
     - 移除石子数量最小的一堆，与前文提到的一样，先手必败。
     - 从每一堆中取走 $1$ 个石子。由于最小的一堆石子数为 $1$，取走 $1$ 个后堆数 $n$ 减少 $1$，同时 $x$ 也减少 $1$。由于每一堆都减少了 $1$ 个，参数 $k$ 也减少 $1$。此时 $n$ 与 $x$ 奇偶性仍然不同，$k$ 变为 $k-1$。故若参数为 $k-1$ 时先手必胜，则此时先手必败；反之，则此时先手必胜。
     
   由于 $n$ 与 $x$ 奇偶性不同且 $k=0$ 时先手必败，故 $k>0$ 时，若 $k$ 为奇数，则先手必胜，否则先手必败。判据 $2$ 成立。
   
综上，可以证明得到两条判据均成立。

```cpp
int T,n,a[N];
void solve(){
	read(n);
	rep(i,1,n)
	    read(a[i]);
	sort(a+1,a+n+1);
	if(n==1){
		puts("Alice");
		return;
	}
	//判据1.次大的一个的数量为x，n与x同奇偶，则必胜.
	if(!((a[n-1]^n)&1)){
		puts("Alice");
		return;
	}
	//判据2.否则：若最小的为1，其次往上为1/2/3...直到次大为止之前停止，连续段长度为奇数，则必胜，否则必败.
	int targ=1,cnt=0;
	rep(i,1,n-2){
		if(a[i]!=targ)break;
		cnt++,targ++;
    }
    if(cnt&1)puts("Alice");
    else puts("Bob");
}
int main(){
	read(T);
	while(T--)
	    solve();
	return 0; 
}
```

---


# 魔法珠

## 题目描述

Freda 和 rainbow 是超自然之界学校（Preternatural Kingdom University，简称 PKU）魔法学院的学生。为了展示新学的魔法，Ta 们决定进行一场对弈~~~

起初 Freda 面前有 $n$ 堆魔法珠，其中第 $i$ 堆有 $a_i$ 颗。 Freda 和 rainbow 可以轮流进行以下操作：

1.选择 $n$ 堆中魔法珠数量大于 $1$ 的任意一堆。记该堆魔法珠的数量为 $p$，$p$ 有 $b_1,b_2 \cdots b_m$ 这 $m$ 个小于 $p$ 的约数。

2.施展魔法把这一堆魔法珠变成 $m$ 堆，每堆各有 $b_1$、$b_2 \cdots b_m$ 颗魔法珠。

3.选择这m堆中的一堆魔法珠，施展魔法令其消失。

注意一次操作过后，魔法珠的堆数会增加m-2，各堆中魔法珠数量的总和可能会发生变化。

当轮到某人操作时，如果每堆中魔法珠的数量均为1，那么ta就输了。

Freda 和 rainbow 都采取最好的策略，从 Freda 开始。请你预测一下，谁能获胜呢？

## 说明/提示

对于所有测试数据满足 $1\le n\le100$，$1\le a_i\le 1000$。

## 样例 #1

### 输入

```
3
2 2 2
3
1 3 5```

### 输出

```
freda
rainbow```

# 题解

## 作者：csb0118 (赞：7)

# P10506 魔法珠 题解

这道题很容易可以想到把每一个输入的
$ai$
作为一个有向图游戏的起点，只要求出这
$n$
个有向图游戏的和就可以得出结论。

## 具体实现
对于其中的每一个数
$m$，设它存在
$x$
个小于
$m$
的因数，那么
$m$
就一定存在
$x$
个子状态。
我们把每一个合法产生的子状态所构成的集合做
**mex**
运算，就可以求出
$m$
的
**SG**
值。

最后我们把所有数的
**SG**
值作异或运算，得到有向图游戏的和，就可以判断是先手必胜还是后手必胜。

### 代码：

```
#include<bits/stdc++.h>
using namespace std;
int sg[1001],a[1001];
int SG(int m){
    if(sg[m]!=-1)
		return sg[m];
    int k=0;
    for(int i=1;i*i<=m;++i)
        if(m%i==0){
	        if(i<m)
				k^=SG(i);
	        if(m/i>1&&m/i<m&&i*i!=m)
				k^=SG(m/i);
 	   }
 	bool flag[1001];
    memset(flag,0,sizeof flag);
    for(int i=1;i*i<=m;++i)
        if(m%i==0){
	      	if(i<m)
			  	flag[k^sg[i]]=1;
	        if(m/i>1&&m/i<m&&i*i!=m)
				flag[k^sg[(m/i)]]=1;
    	}
    int t=0;
    while(flag[t])
		t++;
    return sg[m]=t;
}
void work(int n){
	memset(sg,-1,sizeof(sg));
    sg[1]=0;
	int ans=0;
    for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		ans^=SG(a[i]);
	}
    if(ans!=0)
    	cout<<"freda"<<endl;
    else
    	cout<<"rainbow"<<endl;
    return ;
}
int main(){
    int n;
    while(cin>>n)
    	work(n);
	return 0;
}
```

---

## 作者：cybermage_liu (赞：3)

# 思路
$\operatorname{SG}(x)$ 表示一堆 $x$ 个的魔法珠的 $\operatorname{SG}$ 值，$x$ 为 $1$ 时，$\operatorname{SG}(x)$ 为 $0$。

$\operatorname{SG}$ 定理：若有有向图游戏 $G$，它包含 $G_1,G_2,\dots,G_n$ 共 $n$ 个子游戏，那么 $\operatorname{SG}(G)=\operatorname{SG}(G_1)\oplus\operatorname{SG}(G_2)\oplus\dots\oplus\operatorname{SG}(G_n)$。

设 $x$ 有 $m$ 个约数，  
$k$ 为 $x$ 的约数（除去 $x$ 本身）的 $\operatorname{SG}$ 值异或和，  
第 $i$ 个约数为 $x_i$。

因为会从这 $m$ 个约数之中删去一个，众所周知一个数异或上它本身为 $0$，再结合 $\operatorname{SG}$ 定理，可得 $k\oplus \operatorname{SG}(x_i)$ 为删去 $x_i$ 后的 $\operatorname{SG}$ 值。

那么 $\operatorname{SG}(x)=\operatorname{mex}({k \oplus \operatorname{SG}(x_i)|1 \le i < m})$。

根据 $\operatorname{SG}$ 定理可得 $ans=\operatorname{SG}(a_1)\oplus \operatorname{SG}(a_2)\oplus\dots\oplus \operatorname{SG}(a_n)$。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int sg[N];
int SG(int x){
	if(sg[x]!=-1) return sg[x];
	if(x==1) return sg[x]=0;
	int k=0;
	for(int i=2;i*i<=x;i++)
		if(x%i==0){
			k^=SG(i);
			if(i*i!=x) k^=SG(x/i);
		}
	bool v[N];
	memset(v,0,sizeof(v));
	v[k]=1;
	for(int i=2;i*i<=x;i++)
		if(x%i==0){
			v[k^sg[i]]=1;
			if(i*i!=x) v[k^sg[x/i]]=1;
		}
	for(int i=0;i<=1000;i++)
		if(!v[i]) return sg[x]=i;
}
int main(){
	memset(sg,-1,sizeof(sg));
	int n;
	while(~scanf("%d",&n)){
		int k=0,x;
		for(int i=1;i<=n;i++) scanf("%d",&x),k^=SG(x);
		printf(k?"freda\n":"rainbow\n");
	}
	return 0;
}
```

---

## 作者：longyitongxue (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10506)

# 主要思路

这是一道经典的博弈论——有向图游戏的题目。我们以每一个 $a_i$ 作为有向图游戏的起点，算出这 $n$ 个有向图游戏的和。对于每一个数 $x$，设 $m$ 为小于 $x$ 的约数个数，则 $x$ 必然有 $m$ 个子状态。对于所有合法行动产生的子状态构成的集合做 $\textmd{mex}$ 运算，即 $x$ 的 SG 值。最后我们将每个 $a_i$ 的 SG 值执行异或运算，得到有向图游戏的和，以此判断先手是否必胜。如果先手必胜（异或和不为 $0$），输出 `freda`，否则先手必输（异或和为 $0$），输出 `rainbow`。

# [AC](https://www.luogu.com.cn/record/228325148) 代码
::::success[]{open}
```cpp
#include<iostream>
#include<string.h>
using namespace std;
int a[1005],sg[1005];
int SG(int n){
	if(sg[n]!=-1)return sg[n]; 
	int k=0;
	for(int i=1;i*i<=n;++i){
		if(n%i==0){
			if(n>i)k^=SG(i);
			if(i*i!=n&&n>n/i&&n/i>1)k^=SG(n/i);
		}
	}
	bool f[1005]={};
	for(int i=1;i*i<=n;i++){
		if(n%i==0){
			if(n>i)f[k^sg[i]]=true;
			if(i*i!=n&&n>n/i&&n/i>1)f[k^sg[n/i]]=true;
		}
	}
	int ans=0;
	while(f[ans])++ans;
	return sg[n]=ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	int n;
	while(cin>>n){
		memset(sg,-1,sizeof sg);
		sg[0]=0;
		int ans=0;
		for(int i=1;i<=n;++i){
			cin>>a[i];
			ans^=SG(a[i]);
		}
//		cout<<ans<<'\n';
		if(ans)cout<<"freda\n";
		else cout<<"rainbow\n";
	}
	return 0;
}
```
::::

---

## 作者：mxjz666 (赞：1)

本题我们可以看到每一个数其实可以转化成一个有向图的节点，然后我们只要求出这 $n$ 个节点的 $\operatorname{SG}$ 值的异或和即可。

对于求 $\operatorname{SG}$ 值，我们可以将他的约数作为子状态，最后进行 $\operatorname{mex}$ 运算即可。

献上我丑陋的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1010;
int a[N],f[N],sg[N];
int crz(int x){
	if(sg[x]!=-1)return sg[x];
	int k=0,ans=0;
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			if(x>i)k^=crz(i);
			if(i*i!=x&&x>x/i)k^=crz(x/i);
		}
	}
	memset(f,0,sizeof(f));
	for(int i=1;i*i<=x;i++){
		if(x%i==0){
			if(x>i)f[k^crz(i)]=1;
			if(i*i!=x&&x>x/i)f[k^crz(x/i)]=1;
		}
	}
	for(;f[ans];ans++);
	return sg[x]=ans;
}
signed main(){
	memset(sg,-1,sizeof(sg));
	int n;
	while(cin>>n){
		sg[0]=0;
		for(int i=1;i<=n;i++)cin>>a[i];
		int ans=0;
		for(int i=1;i<=n;i++)ans^=crz(a[i]);
		if(ans)printf("freda\n");
		else printf("rainbow\n");
	}
	return 0;
}
```

---

## 作者：HirasawaYuii (赞：1)

# P10506 魔法珠 题解

[题目链接](https://www.luogu.com.cn/problem/P10506)

## 题目大意

$n$ 堆物品，分别有 $a_1,a_2,...,a_n$ 个。两人轮流选择一堆数量大于 $1$ 的物品，将其分解为他的所有因数，再选择这些因数中的一堆删除。当有人无法操作（物品数量皆为 $1$）时另一人胜利。

## 解题思路

显然本题是博弈论问题。因为本题是将一个物品（设数量为 $x$）分解成因数后再删除一个因数，所以先求出 $x$ 的子情况和再异或每个因数（通过异或性质，再次异或抵消），即可模拟出删掉一个因数的情况。最后将每个子问题异或后即可得到答案

## 代码

```c++
// Problem: P10506 魔法珠
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10506
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// Date: 2025-02-07 08:23:01
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define mst(x, y) memset(x, y, sizeof(x))
#define pii pair<int, int>
#define fi first
#define se second
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)

int read(){int x = 0, f = 1;char c = getchar();while(c < '0' || c > '9'){if(c == '-') f = -1;c = getchar();}while(c >= '0' && c <= '9'){x = 10*x+c-'0';c = getchar();}return f*x;}
void writ(int x){if(x < 0){putchar('-');x = -x;}if(x > 9) writ(x/10);putchar(x%10 | 0x30);return;}
void write(int x){writ(x);puts("");}
void wr(int x){writ(x);putchar(' ');}
const int N = 105, M = 1005, inf = 0x3f3f3f3f;

int n, a[N], maxn = 1000, sg[M], mk[M], ans;

void getsg(){
	for(int i = 1;i <= maxn;i++){
		mst(mk, 0);
		int sum = 0;
		for(int j = 1;j*j <= i;j++){
			if(i%j) continue;
			if(j < i) sum ^= sg[j];
			if(i/j < i && j != i/j) sum ^= sg[i/j];
		}
		for(int j = 1;j*j <= i;j++){
			if(i%j) continue;
			if(j < i) mk[sum^sg[j]] = 1;
			if(i/j < i && j != i/j) mk[sum^sg[i/j]] = 1;
		}
		for(int j = 0;j <= maxn;j++){
			if(!mk[j]){
				sg[i] = j;
				break;
			}
		}
	}
}
void solve(){
	getsg(); // 预处理sg函数
	while(scanf("%d", &n) != EOF){
		ans = 0;
		for(int i = 1;i <= n;i++){
			int x = read();
			ans ^= sg[x];
		}
		if(ans) puts("freda");
		else puts("rainbow");
	}
}

signed main(){
	solve();
	return 0; 
}
```

---

## 作者：lcy0506 (赞：1)

# P10506 魔法珠

此题为博弈论偏模版题，作者因为一些小问题卡了很久，特来此发一篇题解。

## 算法分析

几乎所有博弈论题目都能转换为有向图游戏，此题也不例外。每个数都是有向图的一个起点，只要求出这些有向图游戏的和即可。

对于每一个数 $m$，其的子状态为约数个数，我们把每一个合法产生的子状态所构成的集合做 mex 运算，就可以求出 $m$ 的 SG 值。

我们将所有 SG 值进行异或操作，即变为 NIM 博弈，判断是否先手必胜。

```
#include <bits/stdc++.h>
using namespace std;
int a[1001],sg[1001];
int SG(int x)
{
	if(sg[x]!=-1)//记忆化搜索
	return sg[x];
	int sum=0;
	for(int i=1;i*i<=x;i++)//寻找因数
	{
		if(x%i==0)
		{
			if(x>i)
			sum^=SG(i);
			if(x/i>1&&x/i<x&&i*i!=x)
			sum^=SG(x/i);
		}
	}
	int flag[1001];//最好开在SG函数内,否则会有未知错误
	memset(flag,0,sizeof(flag));
	for(int i=1;i*i<=x;i++)//打标记
	{
		if(x%i==0)
		{
			if(x>i)
			flag[sum^SG(i)]=1;
			if(x/i>1&&x/i<x&&i*i!=x)
			flag[sum^SG(x/i)]=1;			
		}
	}
	int ans=0;
	while(flag[ans])
	ans++;
	return sg[x]=ans;
}
int main()
{
	int n;
	while(cin>>n)
	{
		memset(sg,-1,sizeof(sg));//多次输入得清空
		sg[1]=0;
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			ans^=SG(a[i]);//进行异或运算
		}
		if(ans!=0)
		cout<<"freda"<<endl;
		else
		cout<<"rainbow"<<endl;
	}
}
```

---

## 作者：ttq012 (赞：1)

根据博弈论游戏的必胜条件，显然若先手必胜必须满足先手下一步的每一个状态的 $\text{SG}$ 值的 $\text{mex}$ 不等于 $0$。所以考虑对于当前的每一个游戏，将这个游戏可以到的每一个状态的 $\text{SG}$ 值都异或起来。问题是这个游戏可以选择删除一个状态，显然当前方希望获胜即 $\text{SG}$ 值不为 $0$。所以考虑枚举删除的是哪一个元素，判断删除了每一个元素之后得到的子 $\text{SG}$ 值的 $\text{mex}$ 值为多少，就是当前问题的 $\text{SG}$ 值。最后只需要将每一个子游戏的 $\text{SG}$ 值全部异或起来，判断总的 $\text{SG}$ 值是否为 $0$ 即可。

因为 $n\le 1000$，所以直接 $O(n^2)$ 求约数即可。

```cpp
int dfs(int x) {
    if (~sg[x]) {
        return sg[x];
    } else {
        map<int, bool> vis;
        int all = 0;
        for (auto &y : scc[x]) {
            all ^= dfs(y);
        }
        for (auto &y : scc[x]) {
            all ^= dfs(y);
            vis[all] = true;
            all ^= dfs(y);
        }
        F(i, 0, inf) {
            if (!vis[i]) {
                return sg[x] = i;
            }
        }
        return sg[x] = -1;
    }
}
void $() {
    memset(sg, -1, sizeof sg);
    int n;
    F(i, 1, 1000) {
        F(j, 1, i / 2) {
            if (i % j == 0) {
                scc[i].pb(j);
            }
        }
    }
    while (cin >> n) {
        int s = 0;
        F(i, 1, n) {
            cin >> a[i];
            s ^= dfs(a[i]);
        }
        if (s) {
            cout << "freda\n";
        } else {
            cout << "rainbow\n";
        }
    }
}

signed main() { $(); }
```

---

## 作者：粥2414 (赞：1)

# 思路
每一次操作会分裂出更多的子游戏，这与 [P10501 Cutting Game](https://www.luogu.com.cn/problem/P10501) 十分相似，做过那道题的做这道题应该不难。

本题可以转换为一个有向图游戏。有向图游戏先手必败当且仅当初始时的 SG 值为 $0$。于是考虑求 SG 值。

设 $sg_i$ 为石子数量为 $i$ 的一堆石子的 SG 值。显然有 $sg_1=0$。对于每堆石子，它的 SG 值为其所有可能后继局面的 SG 值的 $\operatorname{mex}$。对于每个局面，它的 SG 值为每堆石子的 SG 值的异或和。记忆化搜索即可。

可以提前预处理出每个数的约数以方便转移。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline ll read() {
	int x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
const ll N=1e2+9;
ll n,a[N];
vector<ll>yue[1009];
ll sg[1009];
void init(){
	memset(sg,-1,sizeof(sg));
	sg[1]=0;
	for(int i=1;i<=1000;i++){
		for(int j=1;j*j<=i;j++){
			if(i%j==0){
				yue[i].push_back(j);
				if(i/j!=j&&i/j!=i)yue[i].push_back(i/j);
			}
		}
	}
}
ll SG(ll x){
	if(sg[x]!=-1)return sg[x];
	ll ans=0;
	for(auto i:yue[x]){
		ans^=SG(i);
	}
	set<ll>v;
	for(auto i:yue[x]){
		ans^=SG(i);
		v.insert(ans);
		ans^=SG(i);
	}
	sg[x]=0;
	for(auto i:v){
		sg[x]++;
//		cout<<x<<' '<<sg[x]<<' '<<i<<endl;
		if(i!=sg[x]-1){
			sg[x]--;
			break;
		}
	}
	return sg[x];
}
int main(){
	init();
	while(n=read(),n!=0){
		for(int i=1;i<=n;i++){
			a[i]=read();
		}
		ll ans=0;
		for(int i=1;i<=n;i++){
			ans^=SG(a[i]);
		}
		puts(ans==0?"rainbow":"freda");
	}
	return 0;
}
```

---

## 作者：Reilher_lover (赞：0)

简单 SG 函数题目。

# 思路分析

不妨将一堆石子看成一个独立的有向图游戏，因为 $a_i$ 很小，我们只需要预处理出每个状态的 SG 值即可。

根据定义，$1$ 的 SG 值为 $0$。假设要计算 $x$ 的 SG 值，设 $x$ 有 $m$ 个小于 $x$ 的约数  $b_1,b_2,\dots,b_m$，且现在已经分别求出了这 $m$ 个数的 SG 值。

若干个有向图游戏的和为这些有向图游戏 SG 值的 xor 和，假设除去 $m$ 堆石子中的第 $i$ 堆，则剩下的有向图游戏和即为 $m$ 堆石子的 SG 值的异或和异或第 $i$ 堆石子的 SG 值，原因在于一个数异或他本身一定为 $0$。

然后直接模拟就可以了，时间复杂度 $O(V^2+\sum n)$，$V$ 是 $a_i$ 值域。


```cpp
#include <cstring>
#include <cstdio>
#include <iostream>
#include <unordered_map> 
#include <vector>
using namespace std;
int sg[1005];
void dfs(int x){
	if(sg[x]!=-1)return;
	vector<int>p;
	unordered_map<int,bool>H;
	p.push_back(1);
	for(int i=2;i*i<=x;i++){
		if(x%i==0){
			p.push_back(i);
			if(i*i!=x)p.push_back(x/i);
		}
	}
	int sum=0;
	for(auto b:p)dfs(b),sum^=sg[b];
	for(auto b:p)H[sum^sg[b]];
	for(int i=0;;i++){
		if(!H.count(i)){
			sg[x]=i;break;
		}
	}
	return;
}
signed main(){
	memset(sg,-1,sizeof(sg));
	sg[1]=0;
 	for(int i=2;i<=1000;i++)dfs(i);
 	int n;
	while(scanf("%d",&n)!=EOF){
 		int ans=0;
		for(int i=1,u;i<=n;i++)scanf("%d",&u),ans^=sg[u];
		if(ans)printf("freda\n");
		else printf("rainbow\n");	
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

很明显，这道题是道博弈论题，注意无法行动即输，所以易发现这是一个有向图游戏。

所以可以把 $a_i$ 当作一个游戏，而最终结果很容易发现就是这 $n$ 个游戏的和，即这 $n$ 个游戏的 SG 函数的异或和。

对于每个 SG 值，我们可以将他的约数作为子状态，最后进行 $\operatorname{mex}$ 运算即可。


```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N=1e3+5;
int a[N],sg[N],f[N],n;
int work(int x){
	if(sg[x]!=-1)return sg[x];
	int k=0,i;
	for(i=1;i*i<=x;i++)
		if(x%i==0){
			if(x>i)k^=work(i);
			if(i*i!=x&&x<x*i)k^=work(x/i);
		}
	memset(f,0,sizeof(f));
	for(i=1;i*i<=x;i++)
		if(x%i==0){
			if(x>i)f[k^work(i)]=1;
			if(i*i!=x&&x*i>x)f[k^work(x/i)]=1;
		}
	for(i=0;f[i];i++);
	return sg[x]=i;
}
void solve(){
	sg[0]=0;
	for(int i=1;i<=n;i++)cin>>a[i];
	int ans=0;
	for(int i=1;i<=n;i++)ans^=work(a[i]); 
	if(ans)puts("freda");
	else puts("rainbow");
}
signed main(){
	memset(sg,-1,sizeof(sg));
	while(cin>>n)solve();
	return 0;
}
```

---

## 作者：SpringQinHao (赞：0)

#### P10506 魔法珠 题解
非常经典的有向图游戏和 $\operatorname{SG}$ 函数，不懂请看[这里 oi-wiki ](https://oi-wiki.org/math/game-theory/impartial-game/#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E4%B8%8E-sg-%E5%87%BD%E6%95%B0)

重点就在 $\operatorname{SG}$ 函数和 $\operatorname{mex}$ 嘛，所以我们就要干这个：
以每一个 $a_i$ 为有向图的起点，则我们要算出这 $n$ 个有向图的游戏的和，即 $\operatorname{SG}(a_1)\oplus \operatorname{SG}(a_2)\oplus \ldots \operatorname{SG}(a_n)$ 与 0 的关系。

每一个 $x$。它的约数即为 $x$ 的后继状态，对这些后继做 $\operatorname{mex}$ 运算即为 $x$ 的 $\operatorname{SG}$ 值。

最后做一遍所有 $a_i$ 的 $\operatorname{SG}$ 值的异或运算，即得到游戏结果。

还有什么细节写在注释里。

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
using namespace std;
typedef long long ll;
const ll N=1005;
ll t,n,a[N];
ll sg[N];
ll SG(ll n)
{
	if(sg[n]!=-1) return sg[n];
	ll k=0;
	for(ll i=1;i*i<=n;i++)//两个对应约数一起处理 
	{
		if(n%i==0)
		{
			if(n>i)k^=SG(i);
			if(i*i!=n && n>n/i) k^=SG(n/i);
		}
	}
	bool f[N];
	ll cnt=0;
	memset(f,0,sizeof(f));
	for(ll i=1;i*i<=n;i++)//标注后继状态，求mex 
	{
		if(n%i==0)
		{
			if(n>i) f[k^SG(i)]=1;
			if(i*i!=n && n>n/i) f[k^SG(n/i)]=1;
		}
	}
	while(f[cnt]) cnt++;//求mex 
	return sg[n]=cnt;
} 

int main()
{
	memset(sg,-1,sizeof(sg));
	while(cin>>n)
	{
		sg[0]=0;
		for(ll i=1;i<=n;i++) cin>>a[i];
		ll ans=0;
		for(ll i=1;i<=n;i++) ans^=SG(a[i]);//异或和 
		if(ans)
			printf("freda\n");
		else printf("rainbow\n");
	}
	
	return 0;
}
```

---

## 作者：_Somutate_ (赞：0)

### [前置知识](https://oi-wiki.org/math/game-theory/impartial-game/)

我们可以将每个输入当作一个有向图游戏，对于每次操作后的石子堆数及其每堆的石子数为状态节点，然后将这个节点与其能进行一次操作就得到的状态节点相连，形成一个图。对于这张图，我们只要求出其每一位的 $\operatorname{SG}$ 函数的异或和，就可以判断先手/后手胜利。

注意：求 $\operatorname{mex}$ 函数时所用的数组不能开全局数组，会导致 WA（至少我因此错在 Subtask 7）。

代码如下：
```cpp
#include<bits/stdc++.h>
#define M 12414
using namespace std;
int SG[M],num[M];
int Query_SG(int x)
{
    if(SG[x]!=-1)return SG[x];
    bool v[M];
    memset(v,0,sizeof v);
    int p=0;
    for(int i=1;i*i<=x;++i)
	{
        if(x%i)continue;
        if(i<x)p^=Query_SG(i);
        if(x/i>1&&x/i<x&&i*i!=x)p^=Query_SG(x/i);
    }
    for(int i=1;i*i<=x;++i)
	{
        if(x%i)continue;
        if(i<x)v[p^SG[i]]=1;
        if(x/i>1&&x/i<x&&i*i!=x)v[p^SG[(x/i)]]=1;
    }
    int tg=0;
    while(v[tg])tg++;
    SG[x]=tg;
    return tg;
}
int solve(int n)
{
	memset(SG,-1,sizeof(SG));
    SG[1]=0;
	int ans=0;
    for(int i=1;i<=n;++i)
	{
		scanf("%d",&num[i]);
		ans^=Query_SG(num[i]);
	}
    return ans;
}
int main()
{
    int n;
    while(~scanf("%d",&n))puts(solve(n)?"freda":"rainbow");
	return 0;
}
```

---


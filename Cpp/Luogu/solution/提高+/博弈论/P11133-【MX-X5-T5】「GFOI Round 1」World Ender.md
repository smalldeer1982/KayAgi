# 【MX-X5-T5】「GFOI Round 1」World Ender

## 题目背景

原题链接：<https://oier.team/problems/X5F>。

---

> [$\small\text{The Border of \textbf{Divinity}}.$](https://music.163.com/#/song?id=1962519608)

## 题目描述

**这是一道交互题，仅支持 C++ 语言提交，且不支持 C++14（GCC 9）。**

Hikari 和 Tairitsu 用她们的玻璃渣子发明了新的游戏。

有 $n$ 堆碎片，编号为 $0\sim n-1$。

$a$ 为一个长度为 $n$，下标为 $0\sim n-1$ 的正整数序列，表示第 $i$ 堆碎片的数量为 $a_i$。

她们轮流进行操作，每轮操作如下：

- 选择一堆碎片 $i$，拿出不少于一个碎片并丢弃；
- 然后将 $i$ 这一堆中剩下的碎片随意分配到所有非空的堆中，**特别地，可以放回原来的堆**。

Hikari 先手，不能操作者输。

你将会成为 Hikari 或者 Tairitsu 中的一个，和另一个进行游戏。

具体地，给定 $a_0, a_1, \ldots, a_{n-1}$，你需要选定先后手并在 $a_0, a_1, \ldots, a_{n-1}$ 上和交互库进行游戏。

### 交互格式

**本题使用多组测试数据且采用捆绑测试**。

你的程序不需要，也不应该包含 `main` 函数。

然后你只需要实现如下 $3$ 个函数：

`bool Init(int n, int op, std::vector<int> a);`

- 这个函数用于你的程序的初始化与预处理。
- 其中 $n$ 为题意所述的碎片堆数，$op$ 为子任务编号。
- $a$ 为一个长度为 $n$，下标为 $0\sim n-1$ 的 `std::vector<int>`，表示上述的序列。
- 你需要返回一个 $\{0,1\}$ 中的数。返回 $0$ 表示在游戏中你选择先手 Hikari，返回 $1$ 表示你选择后手 Tairitsu。

`void Get(std::vector<int> a);`

- 这个函数用于你的程序**接收**交互库操作后的序列。
- $a$ 为一个长度为 $n$ 的 `std::vector<int>`，表示交互库操作后所给出的序列。

`std::vector<int> Play();` 

- 这个函数用于你的程序**返回**你操作后的序列。
- 你需要返回一个长度为 $n$ 的 `std::vector<int>` $a$，表示你操作后所给出的序列。

**本题每个测试点有多组测试数据**。在每个测试点中，对于每组数据，交互库的交互格式如下：

- 先调用一次 `Init()`。
- 当选手程序选择了先手，调用 `Play()`；否则跳过这一步。
- 交互库对 $a$ 进行一次操作后调用 `Get()`。
- 接下来交互库交替调用 `Play()` 和 `Get()`，保证每连续两次调用中操作恰好调用一次 `Play()` 和一次 `Get()`。
- 特别地，如果某次调用 `Play()` 后交互库将 $a$ 操作至终止状态，或者交互库无法操作时，交互库会得出结果并终止这组测试数据的调用过程，跳到下一组测试数据。也就是最后交互库并不会再调用一次 `Get()`。

本题将使用**自定义校验器**对你的交互过程进行评分，具体见 **【评分方式】**。

## 说明/提示

**本题使用多组测试数据。**

**【样例解释】**

该样例由两个测试数据构成。

第一个测试数据，选择先手 Hikari 必胜。

第二个测试数据，选择后手 Tairitsu 必胜。

**【说明/提示】**

本题附件中提供了 `grader.cpp` 文件和 `sample.cpp` 文件。`sample.cpp` 是选手示例程序，你可以在此基础上实现。`grader.cpp` 是下发交互库，其中下发交互库的策略不是最终交互库的策略，因此你的实现不应依赖于交互库的实现。

你需要将你的程序 `game.cpp` 和 `grader.cpp` 放置在同一目录下，并在该目录下使用如下编译命令得到可执行程序 `game(.exe)`：

`g++ -o game grader.cpp game.cpp -O2 -std=c++14`

可执行程序从标准输入读入以下格式的数据：

- 第一行两个正整数 $T$ 和 $op$，$T$ 为测试数据组数，$op$ 为子任务编号。有且仅有样例满足 $op=0$。
- 接下来每组测试数据，输入格式如下：
  - 第一行输入一个正整数 $n$，表示序列 $a$ 的长度。
  - 第二行输入 $n$ 个正整数，表示 $a_0,a_1,\ldots,a_{n-1}$。

在本地测试时，请务必保证你的输入与交互格式符合要求，否则我们不保证交互库会正常运行。

如果你的输入与交互格式合法且没有运行错误，下发的交互库将会根据你的调用输出如下信息：

- 若你成功打赢了交互库，交互库输出 `AC`。
- 否则交互库输出 `WA`。

你的程序不应该操作标准输入输出，否则视为攻击交互库。

**【评分方式】**

本题将使用**自定义校验器**对你的交互过程进行评分。在每个测试点中，如果你超出了时间限制，超出了空间限制，或发生了运行时错误，则你的得分为 $0$。否则你的分数取决于你的程序在交互过程中的表现：

- 参数 $S$ 与你的程序在交互过程中的表现有关：
  - 若你在测试点中的每个测试数据中，均选择了正确的先后手并且均打赢了交互库，则 $S=1$。
  - 若你在测试点中的每个测试数据中，均选择了正确的先后手但是有不合法操作或者打输了交互库，则 $S=0.2$。
  - 若你在测试点中的每个测试数据中，至少一次选择了错误的先后手但是均打赢了交互库，则若 $op\in \{4,5\}$，$S=1$；否则 $S=0.6$。
  - 否则 $S=0$。
- 最终你在该测试点的得分为 $S\times score$，$score$ 为测试点所在子任务的分数。
- 最终你在某个子任务的得分为你在子任务内所有测试点的得分的最小值。

**【数据范围】**

**本题采用捆绑测试**。

| 子任务编号（$op =$） | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :--------: | :----: | :------: | :------: | :--: |
|    $1$     |  $3$   |   $2$    |    无    | $5$  |
|    $2$     |  $10$  |   $2$    |    无    | $15$ |
|    $3$     | $100$  |  $100$   |    无    | $10$ |
|    $4$     | $2000$ |  $2000$  |    A     | $15$ |
|    $5$     | $2000$ |  $2000$  |    B     | $20$ |
|    $6$     | $2000$ |  $2000$  |    无    | $35$ |

- 特殊性质 A：交互库的策略为选择一个非空的堆，拿走若干个碎片并将剩余的碎片放回原堆中。
- 特殊性质 B：交互库的策略为选择一个非空的堆，拿走若干个碎片并将剩余的碎片全部放到一个堆中（可能为原堆）。

对于所有数据，满足 $1 \le T\le 2000$，$1 \le op \le 6$，$1 \le n\le 2000$，$1 \le a_i\le 2000$，$1 \le \sum a_i \le 4000$，$1 \le\sum n\le 2000$，$1 \le \sum\sum a_i\le 4000$。

保证每个测试点中 `Init()` 的调用次数不超过 `2000` 次，`Get()` 和 `Play()` 的调用次数总和不超过 `4000` 次。当选手交互格式正确时，交互库运行所占用的时间始终不超过 500ms。

## 样例 #1

### 输入

```
2 0
10
1 1 4 5 1 4 1 9 1 9
2
1 1
```

### 输出

```
AC
```

# 题解

## 作者：chenly8128 (赞：5)

## 前置知识

- 博弈论
- 状态转移
- ~~找规律~~

## 找规律

根据标准的博弈论思想，我们可以记录每一个状态下，先手有没有必胜策略。如果能转移到一个先手必败的状态，那么有先手必胜策略；反之亦然。

可以发现每一次操作碎片至少减少一块，所以不可能出现循环，状态转移是比较明确的。

然后开始手推不同的状态。我们用 $n$ 来表示剩余几堆。

### $n = 1$ 时：

很显然，先手必胜，全部丢弃即可。

### $n = 2$ 时：

根据博弈论的基本原理，可以得到如果先手率先把其中的一堆丢光，那么只剩下一堆了，会导致后手获胜，**先手必败**。

当两堆个数分别为 $i,j (i \leq j)$ 的情况。**首先给出结论：$i = j$，则先手败；$i \neq j$，则先手胜。**

证明：运用归纳法。

1. $k = 1$，在两堆都只有 1 个碎片的情况下，先手被迫减少堆数，**先手必败**。如果一堆有 1 个碎片，另一堆有 $j (j > 1)$ 个碎片那么可以将状态转移为每堆都是 1 的情况，**先手必胜**。
2. $k > 1$，假设在 $i = k-1$ 的情况下，该结论正确。那么当 $i = j = k$ 时，状态只能转移成 $i$ 更小的状态，而且转移形成的状态 $i \neq j$，所以**先手必败**。当 $i = k$，$j > k$ 时，可以转移成 $i = j = k$ 的状态，所以**先手必胜**。

证明完毕。

### $n = 3$ 时：

**结论：先手必胜**。

因为，可以把碎片数量最大的一堆给选出来，用它的碎片把数量最小的一堆给补到与另外一堆数量相等，然后把剩下的碎片全部丢弃。就转移到了两堆的先手必败情况，**所以 $n = 3$ 时先手必胜**。

### $n$ 为偶数时：

可以通过总结规律得到判断方法：
1. 设每一堆碎片的数量组成长度为 $n$ 的数组 $a_{1,2,\dots,n}$。
2. 将 $a$ 从小到大排序。
3. 如果存在 $i$ 使得 $a_{2i-1} < a_{2i}$，那么**先手必胜。反之先手必败**。

证明类似于 $n = 2$ 的情况，只是复杂一些，略。
### $n$ 为奇数时：

与 $n = 3$ 的情况类似，**先手必胜**。

证明类似。

## 实现

当你发现了上述规律，并且能够说明为什么了的时候，你就差不多解决了这道题了。

### Init

根据上述规律排序并判断即可。

### Get

记录上一步的数组，我的实现中 GET 函数几乎什么都没做。

### Play

这是重点！！！分成两种情况：
1. $n$ 是奇数：显然需要减少一堆碎片，并且转移为必败状态。我的方法是先进行排序，然后把碎片最多的一组的删掉，把排序好的 $a$ 数组中的 $a_{2i-1}$ 赋值为 $a_{2i}$。可以证明增加的碎片数比删掉的要少。最后把 $a$ 数组恢复成原来的顺序。
2. $n$ 是偶数：显然不应该删掉任何一堆，应该转移为先手必败的状态。我的方法是先进行排序，然后记录不同碎片数量的出现次数。将出现次数为奇数的碎片数量设为 $b_{1,2,\dots,m}$，要求 $b$ 严格单调递增。然后将 $b_m$ 改为 $b_1$，将剩下的 $b_{2i}$ 改为 $b_{2i+1}$，可以证明增加的碎片数比删掉的要少。将 $b$ 数组上的改动映射到 $a$ 上，最后把 $a$ 数组恢复成原来的顺序。

这样就转移成了必败状态。

## 代码

```cpp

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cassert>
using namespace std;
struct point {
	int id,val;
	bool operator < (const point b) const {
		return val < b.val;
	}
};
vector <point> v;
vector <int> Play(void) {
	int n = v.size();
	sort (v.begin(),v.end());
	if (n&1) {
		vector <int> res(n);
		for (int i = 0;i < n-1;i += 2) {
			res[v[i].id] = v[i+1].val;
			res[v[i+1].id] = v[i+1].val;
		}
		return res;
	}
	vector <int> res(n);
	vector <point> v2(0);
	for (int i = 0;i < n;i++) {
		if (i < n-1 && v[i].val == v[i+1].val) {
			res[v[i].id] = v[i].val;
			res[v[i+1].id] = v[i+1].val;
			i++;
			continue;
		}
		else v2.push_back(v[i]);
	}
	if (v2.size()) {
		assert (v2.size()>1);
		for (int i = 1;i < v2.size()-1;i += 2)
			res[v2[i].id] =  res[v2[i+1].id] = v2[i+1].val;
		res[v2[0].id] = v2[0].val;
		res[v2[v2.size()-1].id] = v2[0].val;
	}
	fflush(stdout);
	return res;
}
void Get(vector<int> a) {
	v.clear();
	for (int i = 0;i < a.size();i++)
		v.push_back((point){i,a[i]});
	return;
}
bool Init(int n, int op,vector<int> a) {
	v.clear();
	for (int i = 0;i < a.size();i++)
		v.push_back((point){i,a[i]});
	if (a.size()&1) return false;
	sort (a.begin(),a.end());
	for (int j = 0;j < a.size()-1;j += 2)
		if (a[j] != a[j+1]) return false;
	return true;
}
```
注意不要用 C++14（GCC 9）。轻松 AC。

---

## 作者：IYSY2009I (赞：5)

很好的博弈论题，就是难度似乎有点虚高了~~建议评蓝~~。

本题解前半部分主要介绍自己在赛时的思考过程，想直奔正解的可以跳过五段。

首先注意到有一档 $n \le 3$ 的部分分，于是我们考虑 $n=1,2,3$ 怎么做（事实证明这档分对于正解有较强的引导性）。

首先注意到 $n=1$ 时先手必胜，进一步可以得到 `1 1` 的状态是先手必败（因为不管怎么取显然都会取到 $n=1$ 的状态）。

接着考虑 $n=2$，不妨设 $a_1,a_2$ 是这两堆石子的数量，可以发现如果 $a_1$ 固定，那么最多只存在一个 $a_2$ 使当前状态为必败状态（假如有两个这样的状态都必败，显然 $a_2$ 更大的状态状可以另一个状态，故假设不成立）。数学直觉告诉我们，对于每个 $a_1$ 一定也能找到这样的 $a_2$，通过对小数据的枚举，我们大胆猜测 $a_2=a_1$，接下来是证明时间：

- 必败态只能转移到必胜态：显然。
- 必胜态可以转移到必败态：不妨设 $a_1 < a_2$ 只要把 $a_2$ 取成 $a_1$ 即可。

如果对 $n=2$ 的理解足够深刻，$n=3$ 时我们可以直接发现先手必胜，还是不妨设 $a_1 \le a_2 \le a_3$，我们只要把 $a_3$ 分成两部分，一部分将 $a_1$ 补至 $a_2$，另一部分全部拿走，于是我们就给对方了一个必败态。

~~所以第一档分怎么还要加上 $a$ 的限制，拉低了这一档的含金量 /fn。~~

$n$ 更大的时候我们似乎使用瞪眼法瞪不出来了（如果有能瞪出来的应该不需要看我这篇题解），但我们发现 $n\le 3$ 时的结论都十分简明，于是果断打表，发现先手必败当且仅当所有不同数量石子的非空石子堆的出现次数都为偶数。当然这是一道交互题，即使不考虑题解的严谨性也应该找出一个策略，还好这和上面的证明是类似轻松的。

- 必败态只能转移到必胜态：~~显然~~。似乎不算太显然，考虑我们拿走了一些石子，那么我们就要给另一堆数量比它小的石子补成这个数量，于是我们还要给数量较小的那种石子堆补一堆，补到最小的那一堆的时候就没得补了，然后就 GG 了。
- 必胜态可以转移到必败态：出现次数偶数堆石子都是没有用的，我们暂时抛之脑后，只专注于出现次数奇数堆的这些石子堆。将其排序后设其为 $b_1,b_2,...,b_m$，手玩两三个例子后给出转移方法：
 
  1. 操作 $b_m$ 这一堆石子。
  2. 将 $b_{m-2}$ 补到 $b_{m-1}$，$b_{m-4}$ 补到 $b_{m-3}$...... 以此类推。
  3. 如果 $m$ 时奇数，就把剩下的全拿走，如果 $m$ 时偶数，则会剩下一堆 $b_1$ 没有匹配，将 $b_m$ 拿成 $b_1$ 就行。

  可能有人会疑惑 $b_m$ 会不会不够用的。我们把这些石子所对应的数放在一个数轴上，那么 $b_m$ 这堆石子的数量就相当于 $0$ 到 $b_m$ 的长度，把小的一堆石子补成大的一堆用的石子数就是这两堆石子的数量在数轴上的距离。前者显然是包含后者的。

剩下的就是代码了。注意几个小细节：

- $a$ 的顺序不能打乱。
- 空的石子堆还要保留在 `vector` 里。
- 不能往空的石子堆里放石子。

个人推荐且使用的一个比较不错的的一种写法是开一个结构体把所有还有石子的石子堆数量、编号、奇偶性存起来，这样方便排序、操作。还原时按照存储的编号还原就可以了。

~~所以这个题真的只有蓝题难度，但水个紫不香吗。~~

代码配有注释且有良好的格式化。


```cpp
#include <cstdio>

#include<algorithm>

#include<iostream>

#include <vector>

using namespace std;
int n;
vector < int > a;
struct node {
    int num; //数量
    int id; //编号
    bool flag; //该数量出现次数奇偶性
};
node st[2005];
int tong[2005];
bool cmp(node x, node y) {
    if (x.flag ^ y.flag) return x.flag; //出现次数是奇数的拿到前面方便处理
    return x.num < y.num;
}
vector < int > Play() {
    for (int i = 0; i <= 2000; i++)
        tong[i] = 0;
    for (int i = 0; i < n; i++)
        if (a[i]) tong[a[i]]++;
    for (int i = 0; i < n; i++) {
        st[i + 1].id = i;
        st[i + 1].num = a[i];
        if (tong[a[i]] & 1) { //把出现次数奇数的堆都拿出来（注意只拿一堆）
            tong[a[i]]--;
            st[i + 1].flag = 1;
        } else st[i + 1].flag = 0;
    }
    sort(st + 1, st + n + 1, cmp);
    int id = 0;
    for (int i = 1; i <= n; i++)
        if (!st[i + 1].flag) {
            id = i;
            break;
        }
    if (!id) id = n;
    if (id & 1) { //按题解所述方法处理
        for (int i = 1; i < id; i += 2)
            st[i].num = st[i + 1].num;
        st[id].num = 0;
    } else {
        for (int i = 2; i < id; i += 2)
            st[i].num = st[i + 1].num;
        st[id].num = st[1].num;
    }
    for (int i = 1; i <= n; i++)
        a[st[i].id] = st[i].num;
    return a;
}
void Get(vector < int > aa) {
    a = aa;
    return;
}
bool Init(int x, int op, vector < int > aa) {
    n = x, a = aa;
    for (int i = 0; i <= 2000; i++)
        tong[i] = 0;
    for (int i = 0; i < n; i++)
        if (a[i]) tong[a[i]]++;
    for (int i = 1; i <= 2000; i++)
        if (tong[i] & 1) return 0; //如果有一种出现次数为奇数就选先手
    return 1;
}
```

---

## 作者：晴空一鹤 (赞：3)

~~赛后 $5$ min 就调出来了，火大。~~

~~会 T5 不会写 T3 点权 Dij 实锤了。~~

首先可以发现这是个披着交互题外套的博弈论题，开交互是为了输出方案。

我们尝试手玩一些小一点（比如 $n\leq 4$）的情况，容易发现只有在 $n=2$ 与 $n=4$ 且数是一对对的时候才是先手必败。于是我们推断当且仅当有出现奇数次的数时先手必胜。

随便交上去可以得到 $20pts$。结论证明可以模仿尼姆博弈，顺带还能得出构造方案：

- 所有数都出现偶数次（P 态）无法转移到另一个 P 态。考虑你取的那一堆玻璃渣子所对应的数（记为 $x$）在取完后肯定会变成出现奇数次，如果你想让另一堆渣子通过分配变成 $x$，那那堆渣子又会变成出现奇数次。而让你取的那一堆补上空缺是不可能的，因为你起码要丢掉 $1$ 个玻璃渣子。
-  有若干个数出现奇数次（N 态）一定可以转移到一个 P 态。记有 $n$ 个这样的数，把这 $n$ 个数按大小升序排序。如果 $n\equiv1\pmod2$，我们取出一堆最大的，再给每一个排序后处于奇数位的数中的一堆分配一些渣子，使其数值等于他后面的那个数，而分配所需的玻璃渣子显然是少于最大堆玻璃渣子数的，所以一定可以做到。如果 $n\equiv0\pmod2$，我们同样取出最大的那一堆，不过这次不能丢掉，而是减小到和最小的一堆一样大，此时中间偶数个堆两两配对（类似 $n\equiv1\pmod2$ 的情况）即可。

直接把上述过程实现即可。


```cpp
// Handsome Accepted
#include<bits/stdc++.h>
#include <cstdio>
#include <vector>

int tz[2005],ri[2005],nn,x;
std::vector<int>qp,q;
std::vector<int> Play() {
        memset(tz,0,sizeof(tz));q.clear();
        for(int i=0;i<nn;i++){tz[qp[i]]++;}
        for(int i=1;i<=2000;i++){if(tz[i]&1)q.push_back(i);ri[i]=-1;}ri[0]=-1;       
        if(q.size()%2==1){ri[q[q.size()-1]]=0;for(int i=0;i<q.size();i++)if((i%2==0)&&i+1<q.size())ri[q[i]]=(q[i+1]);}
        else {ri[q[q.size()-1]]=q[0];for(int i=1;i<(int)q.size()-1;i++)if(i%2==1) ri[q[i]]=q[i+1];}
        for(int i=0;i<nn;i++)if(ri[qp[i]]!=-1){x=ri[qp[i]];ri[qp[i]]=-1;qp[i]=x;}
        return qp;
}

void Get(std::vector<int> a) {
    qp=a;
    return;
}

bool Init(int n, int op, std::vector<int> a) {
        memset(tz,0,sizeof(tz));
        qp=a;nn=n;
        int x=0;for(int i=0;i<n;i++)tz[a[i]]++;
        for(int i=1;i<=2000;i++)if(tz[i]&1)return 0;
        return 1;
}
```

---

## 作者：cancan123456 (赞：2)

感觉这题没有 [P11131 【MX-X5-T3】「GFOI Round 1」Cthugha](https://www.luogu.com.cn/problem/P11131) 难啊，为啥 P11131 是蓝这题紫，没道理。

首先要选择先后手，考虑打表找规律，写一个[暴力](https://www.luogu.com.cn/paste/3dri997g)，观察 $n=4$ 的所有后手必胜状态，可以发现所有的数都出现了偶数次（设为 A 类状态），考虑证明这个结论。

当处于 A 类状态时，若进行一次操作后仍为 A 类状态，设原有 $x$ 个玻璃渣子的堆操作后变成了有 $y$ 个玻璃渣子的堆，则连边 $x\to y$ 后图应为一个环，但这是不可能的，因为总玻璃渣子数不变。

当不处于 A 类状态时，总有一种操作能使其变为 A 类状态。将所有出现奇数次的数从小到大排序为 $c_1,c_2,\dots,c_n$。

1. 若 $n$ 为奇数，则将 $c_n$ 拿出 $c_n-\sum_{i=1}^{(n-1)/2}c_{2i}-c_{2i-1}$ 个玻璃渣子扔掉，并将大小为 $c_{2i-1}$ 的玻璃渣子堆补充 $c_{2i}-c_{2i-1}$ 个玻璃渣子，则每个 $c_i$ 出现次数均为偶数。
2. 若 $n$ 为偶数，则将 $c_n$ 拿出 $c_n-c_1-\sum_{i=1}^{n/2-1}c_{2i+1}-c_{2i}$ 个玻璃渣子扔掉，拿出 $c_1$ 个玻璃渣子放回原堆，并将大小为 $c_{2i}$ 的玻璃渣子堆补充 $c_{2i+1}-c_{2i}$ 个玻璃渣子，则每个 $c_i$ 出现次数均为偶数。

该证明同时给出了选手程序的策略。

因此，设先手处于非 A 类状态，则先手总可以将其变为 A 类状态传给后手；设先手处于 A 类状态，则先手只能将其变为非 A 类状态。而终局状态是 A 类状态，此时先手必败，因此 A 类状态一定是先手必败态。

```cpp
#include <cstdio>
#include <vector>
#include <map>
int n;
std::vector < int > now;
std::vector < int > Play() {
	std::map < int, int > mp;
	for (int x : now) {
		if (x != 0) {
			mp[x]++;
		}
	}
	std::vector < int > vec;
	for (auto p : mp) {
		if (p.second % 2 == 1) {
			vec.push_back(p.first);
		}
	}
	for (int i = 0; i < n; i++) {
		if (now[i] != 0) {
			mp[now[i]] = i;
		}
	}
	if (vec.empty()) {
		return std::vector < int > ();
	}
	int m = vec.size() - 1;
	if (vec.size() % 2 == 0) {
		now[mp[vec.back()]] = vec.front();
		for (int i = 1; i < m; i += 2) {
			now[mp[vec[i]]] = vec[i + 1];
		}
	} else {
		now[mp[vec.back()]] = 0;
		for (int i = 0; i < m; i += 2) {
			now[mp[vec[i]]] = vec[i + 1];
		}
	}
	return now;
}
void Get(std::vector < int > a) {
	now = a;
}
bool Init(int n, int op, std::vector < int > a) {
	::n = n;
	now = a;
	std::map < int, int > mp;
	for (int x : a) {
		mp[x]++;
	}
	for (auto p : mp) {
		if (p.second % 2 == 1) {
			return 0;
		}
	}
	return 1;
}
```

---

## 作者：MisaYuzuki (赞：2)

一道中规中矩的博弈论题目。

对于 $n=2$ 和 $n=3$ 的情况，发现只有当 ```x x``` 的时候是先手必输态。（当然如果要让推出的结论更严谨建议写个打表程序）那此时结论大致只有两种：

- 若一个状态是必输态，则该状态对于非 $0$ 元素所构成的集合，必然可以划分为两个完全一致的子集。
- 若一个状态是必输态，则该状态对于非 $0$ 元素所构成的集合，必然可以划分为两个元素之和相等的子集。

考虑如何如证明一个结论是正确的。一个双人博弈结论正确当且仅当任意必赢态可以推到必输态，必输态的下一步一定是必赢态。

先来证明第二个结论（因为第二个结论是假的）。直接去证明错误的地方吧，正确的地方证明与下一条结论证明类似。假设结论成立。对于必输态 ```4 4 2 6```，显然可以得到 $4+4=2+6$，将其中一堆 $4$ 全部取走剩余状态为 ```4 2 6```，显然可以得到 $4+2=6$。说明一次操作后可以得到另外一个必输态，这与双人博弈结论性质相悖。故该结论为假。

接下来证明第一个结论。

先证明必输态下一步必然是必赢态。由结论可知，对于每一个非 $0$ 值，在状态中出现的次数必然为偶数。假设要对值为 $x$ 的堆进行删除操作。假设删除后结果为 $y$。当 $y=0$ 则非 $0$ 堆总数变为奇数，剩下的状态是必赢态。当 $y\neq0$ 时，发现此时值为 $y$ 的堆数量变为奇数。那么要让剩下最多 $x-y+1$ 的碎片如何分配才能使得其成为必赢态呢？显然不能对 $\lt y$ 的堆增加碎片，因为这样操作同时也需要保证原来 $\lt y$ 的堆两两配对，到头来是没有意义的。那么假设将一堆 $y$ 的值变到 $z$，然后继续同样的操作到 $w$……也就是继 $x$ 之后形成一个严格递增序列 $a_1,a_2,\dots a_k$，代价为 $(a_2-a_1)+(a_3-a_2)+\dots+(a_k-a_{k-1})=a_k-a_1$，且 $a_k-a_1\le x-a_1+1$，即 $a_k\lt x$，那么会导致值为 $a_k$ 和值为 $x$ 的堆数量为奇数，仍然是必赢态。

接下来证明必赢态可以推至必输态。设 $n$ 为非 $0$ 堆数（注意与上文 $n$ 的含义不一样），令 $a_1,a_2,\dots,a_n$ 为非 $0$ 堆升序排列的结果。分类讨论：

当 $n$ 是奇数时，考虑将 $a_n$ 删空，然后将 $\forall i\in[1,\lfloor\frac{n}{2}\rfloor]$ 的每一个 $a_{2i-1}$ 赋值为 $a_{2i}$。那么这样的代价为 $\sum_{i\in[1,\lfloor\frac{n}{2}\rfloor]}a_{2i}-a_{2i-1}$。由于该序列是递增序列，所以显然有
$$
w=\sum_{i\in[1,\lfloor\frac{n}{2}\rfloor]}a_{2i}-a_{2i-1}\le\sum_{i\in[1,n-1]}a_{i+1}-a_i=a_{n}-a_1
$$
将 $a_n$ 删除后最多能为其他堆提供 $a_n-1$ 个碎片，而又有 $a_1\ge 1$，所以易得
$$
w\le a_n-a_1\le a_n-1
$$
所以对于 $n$ 为奇数的构造显然合法。

当 $n$ 是偶数时，考虑将 $a_n$ 删至 $a_1$，然后将 $\forall i\in[1,\frac{n}{2})$ 的每一个 $a_{2i}$ 赋值为 $a_{2i+1}$。那么这样的代价为 $\sum_{i\in[1,\frac{n}{2})}a_{2i+1}-a_{2i}$。由于该序列是递增序列，所以显然有
$$
w=\sum_{i\in[1,\frac{n}{2})}a_{2i+1}-a_{2i}\le\sum_{i\in[1,n-1]}a_{i+1}-a_i=a_{n}-a_1
$$
将 $a_n$ 删至 $a_1$ 能为其他堆提供 $a_n-a_1-1$ 个碎片。但是这样还不够，因为若不等号取等，则不等式仍不成立。考虑啥时候不等号会取等，由于序列递增，不难发现是 $\forall i\in[1,\frac{n}{2}]$，$a_{2i-1}=a_{2i}$ 的情况。但是此情况是必输态，故可以证明出 $w\lt a_n-a_1$。

所以对于 $n$ 为偶数的构造显然合法。

然后模拟构造方案即可。记得 Init() 函数也需要为 Play() 函数处理信息。

```cpp
bool Init(int n,int op,vector<int>a){
	k=n;
    m=0;
	for(int i=0;i<n;i++){
		if(a[i]){
			f[++m]=node{i,a[i]};
		}
	}
	sort(f+1,f+m+1);
	if(m&1){
		return 0;
	}
	for(int i=1;i<m;i+=2){
		if(f[i].val!=f[i+1].val){
			return 0;
		}
	}
	return 1;
}
void Get(vector<int>a){
    k=a.size();m=0;
    for(int i=0;i<k;i++){
        if(a[i]){
            f[++m]=node{i,a[i]};
        }
    }
    sort(f+1,f+m+1);
}
vector<int>Play(){
    vector<int>a(k,0);
    if(m&1){
        for(int i=1;i<m;i++){
            if(i&1){
                f[i].val=f[i+1].val;
            }
        }
        f[m].val=0;
    }else{
        for(int i=2;i<m;i++){
            if(i&1){
                f[i-1].val=f[i].val;
            }
        }
        f[m].val=f[1].val;
    }
    for(int i=1;i<=m;i++){
        a[f[i].id]=f[i].val;
    }
    return a;
}
```

给珂爱的小妹妹点个赞吧 qwq

---


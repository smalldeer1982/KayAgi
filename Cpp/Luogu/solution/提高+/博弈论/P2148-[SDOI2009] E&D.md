# [SDOI2009] E&D

## 题目描述

小 E 与小 W 进行一项名为 `E&D` 游戏。

游戏的规则如下：桌子上有 $2n$ 堆石子，编号为 $1 \sim 2n$。其中，为了方便起见，我们将第 $2k-1$ 堆与第 $2k$ 堆（$1 \le k \le n$）视为同一组。第 $i$ 堆的石子个数用一个正整数 $S_i$ 表示。

一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子数必须保证大于 $0$。显然，被分割的一堆的石子数至少要为 $2$。两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为 $1$，则此时没有石子可以操作，判此人输掉比赛。

小 E 进行第一次分割。他想知道，是否存在某种策略使得他一定能战胜小 W。因此，他求助于小 F，也就是你，请你告诉他是否存在必胜策略。例如，假设初始时桌子上有 $4$ 堆石子，数量分别为 $1,2,3,1$。小 E 可以选择移走第 $1$ 堆，然后将第 $2$ 堆分割（只能分出 $1$ 个石子）。接下来，小 W 只能选择移走第 $4$ 堆，然后将第 $3$ 堆分割为 $1$ 和 $2$。最后轮到小 E，他只能移走后两堆中数量为 $1$ 的一堆，将另一堆分割为 $1$ 和 $1$。这样，轮到小 W 时，所有堆的数量均为 $1$，则他输掉了比赛。故小 E 存在必胜策略。

## 说明/提示

对于 $20\%$ 的数据，$N=2$。

对于另外 $20\%$ 的数据，$N \le 4$，$S_i \le 50$。

对于 $100\%$ 的数据，$1 \le T \le 20$，$1 \le N \le 2 \times 10^4$ 且 $N$ 为偶数，$1 \le S_i \le 2 \times 10^9$。

## 样例 #1

### 输入

```
2
4
1 2 3 1
6
1 1 1 1 1 1
```

### 输出

```
YES
NO
```

# 题解

## 作者：Sooke (赞：95)

### 前言

本文将对此题的关键结论进行粗略证明。似乎此前都只有找规律、而没有提到证明的题解？

------

### 预备

前置知识：SG 函数。篇幅关系就不扯了。

$f(x)$ 为 $x$ 的二进制末尾首个 $0$ 的出现位置（标号从 $0$ 开始）。例如 $f(5) = (101)_2 = 1$ 。

$\mathrm{sg}(x,\ y)$ 为一组分别有 $x + 1,\,y + 1$ 个石子的 $\mathrm{sg}$ 值。**注意有 $+1$** 。

$S_z$ 表示满足 $x + y + 1 = z$ 的 $\mathrm{sg}(x,\,y)$ 构成的自然数集合。特别地，$S_0 = \varnothing$ 。

------

### 引理

> 引理 $1$ ：$\mathrm{sg}(0,\,0) = 0$ 。

终止局面的 $\mathrm{sg}$ 值为 $0$ 。

> 引理 $2$ ：$\mathrm{sg}(x,\,y) = \mathrm{mex}(S_x \cup S_y)$ 。

SG 函数经典结论。后继局面可以分割 $x + 1$ 或 $y + 1$ 。注意事先的定义，$S_x$ 不是 $S_{x-1}$ 或 $S_{x+1}$ 。

------

### 结论

可能要叫“命题”？既然都知道了就当结论吧。~~（数学不好）~~

> 结论 $1$ ：$S_z$ 等同于 $z$ 二进制下 $1$ 的位置集合。例如 $S_5 = \{0,\,2\}$ 。

辅助结论。

> 结论 $2$ ：$\mathrm{sg}(x,\,y) = f(x\ |\ y)$ 。例如 $\mathrm{sg}(1,\,4) = f(5) = 1$ 。

关键结论。

------

### 证明

考虑归纳法证明以上两个结论。即逐步放大 $z$ ，证明该 $z$ 下结论 $1$ 及满足 $x + y = z$ 的结论 $2$ 的正确性。

根据引理 $1$ ，结论 $2$ 在 $z = 0$ 时正确。假设已证 $z - 1$ 时结论 $2$ 的正确性，考虑 $S_{z}$ 包含元素 $p$ 的条件。

由定义和结论 $2$ 可知，需存在 $x + y = z - 1$ 且 $f(x\ |\ y)=p$ ，得 $x,\,y$ 在二进制下，第 $p$ 位都为 $0$ ，第 $0 \sim p - 1$ 位都至少有一个是 $1$ 。

考虑最劣极限，第 $0 \sim p - 1$ 位只有其中一个是 $1$ ，由于交换律，这些 $1$ **都在 $x$ 中是没有关系的**。

此时，因为 $x + y + 1 = z$ ，模拟二进制运算（$+ 1$ 会导致上述所有 $1$ 进位到第 $p$ 位），$z$ 的第 $p$ 位为 $1$ ，**第 $0 \sim p - 1$ 位为 $0$** 。

反观最优极限下，$y$ 的第 $0 \sim p - 1$ 位也都是 $1$ ，实际上，这些位不管怎么安排 $0,\,1$ ，丝毫不影响 $z$ 的第 $p$ 位为 $1$ 的事实（见上方粗体文字）。

故 $z$ 二进制第 $p$ 位为 $0$ 时，$S_{z}$ 不可能包含元素 $p$ 。为 $1$ 时，显然令 $x = 2^{p} - 1,\,y = z - 2^p$ 即可满足条件。

既然有了 $z$ 时结论 $1$ 的正确性，不妨以此推出 $z$ 时结论 $2$ 的正确性。

$$\mathrm{sg}(x,\,y) = \mathrm{mex}(S_x \cup S_y)=\mathrm{mex}(S_{x\ |\ y}) = f(x\ |\ y)$$

根据结论 $1$ ，$S$ 是 $1$ 的位置集合，易证 $S_x \cup S_y = S_{x\ |\ y}$ ，并且 $x\ |\ y \leqslant x + y = z$ 在已证范围内。同时，$\mathrm{mex}$ 是最小未出现自然数，配上位置集合，正好就是 $f$ 的定义。故可证任意 $z$ 下两个结论。

---

## 作者：FlashHu (赞：54)

~~前面的Dalao们思路感觉不是很清晰啊，打表和代码实现也有点奇怪而不是很简洁~~

于是蒟蒻补一发题解

先安利蒟蒻仍在施工的[博弈论总结](http://www.cnblogs.com/flashhu/p/8665204.html)

首先根据题目，石子被两两分组了，于是根据SG定理，我们只要求出每一组的SG值再全部异或起来就好啦。

把每一对数看成一个ICG，首先，我们尝试构造游戏的状态转移DAG。把一堆石子拿掉，另一堆任意拆成两堆，等于说由状态$(a,b)$可以转移到$\{(c,d),c+d=a$或$c+d=b\}$

一眼看不出来这是要干神马。。。。。。然后开始打表。其实打表的方式可以更简单。首先，观察上式，对于每一个a，所有$c+d=a$的$(c,d)$的$SG$值集合我们可以先用一个bitset存起来，这样当我们求$(a,b)$的$SG$值时我们直接将$a$和$b$对应的两个集合并起来再求$mex$就好啦。于是得到了打表代码（bitset实在是太好用啦）
```
#include<cstdio>
#include<bitset>
#include<iostream>
using namespace std;
const int N=10,M=N+1;//随便调大小
typedef bitset<M> B;
B s[M];
int ans[M][M];
inline int mex(B b){//干什么就不解释了吧
	int i=0;
	while(b[i])++i;
	return i;
}
int main(){
	int i,j,k;
	for(i=2;i<=N;++i)
		for(j=1,k=i-1;k;++j,--k)
			s[i].set(ans[j][k]=mex(s[j]|s[k]));//枚举合并
	for(i=0;i<N;++i)printf("%3d",i);puts("");
	for(i=1;i<N;++i){//输出矩阵
		printf("%2d:",i);
		for(j=1;i+j<=N;++j)
			printf("%3d",ans[i][j]);
		puts("");
	}
	for(i=1;i<=N;++i){//输出对于每一个a，所有c+d=a的(c,d)的SG值集合
		printf("%2d:SG%d ",i,mex(s[i]));
		cout<<s[i]<<endl;
	}
	return 0;
}
```
打出来的答案矩阵
```
 0:  1  2  3  4  5  6  7  8  9
 1:  0  1  0  2  0  1  0  3  0
 2:  1  1  2  2  1  1  3  3
 3:  0  2  0  2  0  3  0
 4:  2  2  2  2  3  3
 5:  0  1  0  3  0
 6:  1  1  3  3
 7:  0  3  0
 8:  3  3
 9:  0
```
怎么看也没看出什么特别的地方

但接着看看对于每一个$a$，所有$c+d=a$的$(c,d)$的SG值集合
```
 1:SG0 00000000000
 2:SG1 00000000001
 3:SG0 00000000010
 4:SG2 00000000011
 5:SG0 00000000100
 6:SG1 00000000101
 7:SG0 00000000110
 8:SG3 00000000111
 9:SG0 00000001000
10:SG1 00000001001
```
诶，$S_i$等于$i-1$的二进制表示！！（我太弱了，不会证）

那对于询问的每一对数$(i,j)$，直接求$(i-1)\mid(j-1)$（按位或）的二进制的最低的0所在的二进制位，把所有的异或起来就好啦

代码应该很好懂啊，直接位运算搞一搞就行啦
```
#include<cstdio>
#define R register int
const int SZ=1<<21;
char ibuf[SZ],*pi=ibuf-1;
inline int in(){
	while(*++pi<'-');
	R x=*pi&15;
	while(*++pi>'-')x*=10,x+=*pi&15;
	return x;
}
int main(){
    fread(ibuf,1,SZ,stdin);
	R T=in(),n,x,cnt,ans;
	while(T--){
		ans=0;
		n=in()>>1;
		while(n--){
			cnt=0;
			x=(in()-1)|(in()-1);
			while(x&1)++cnt,x>>=1;
			ans^=cnt;
		}
		puts(ans?"YES":"NO");
	}
	return 0;
}
```

---

## 作者：Goes (赞：19)

其实对于只有一组的情况我们很容易发现只要根据两堆的奇偶性就能得出是否有必胜策略

sg函数据说是博弈论的必杀神器，有必要先学习一下sg.......


下面就是sg(x,y)函数在本题目中的代码实现

```cpp
int sg(int x,int y)
{
    long long tmp=2;
    for(int i=0;;i++,tmp*=2)
        if( ( x - 1 ) % tmp < tmp/2 && (y-1)%tmp < tmp/2 )
            return i;
}
```
这样我们知道了一组的情况，要推广到n组的情况，我们就可以用这样的性质更快地打表找规律
我们发现这些答案其实是有规律的，好像有个学名叫做阿达玛矩阵？


不过最后事实上就一个sg就可以了.....



```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int T,n;
int a,b;
int ans;
int sg(int x,int y)
{
    long long tmp=2;
    for(int i=0;;i++,tmp*=2)
        if( ( x - 1 ) % tmp < tmp/2 && (y-1)%tmp < tmp/2 )
            return i;
}
void work()
{
    cin>>n;ans=0;
    for(int i=1;i<=n/2;i++)
    {
        cin>>a>>b;
        ans^=sg(a,b);
    }
    if(ans)    puts("YES");
    else puts("NO");
    return;
}
int main()
{
    scanf("%d",&T);
    for(int i=1;i<=T;i++)
        work();
}
```

---

## 作者：Night_Aurora (赞：18)

面对一道毫无头绪的题目

首先可以发现N/2堆二元组都是独立游戏，所以只要求出每个二元组的SG函数就能解决问题

在毫无头绪的情况下，本蒟蒻准备先用[暴力](http://paste.ubuntu.com/25386637/)打50\*50的二元组的表格

再在上面找规律吧

对于一个二元组$(a,b) \Leftrightarrow(b,a)$

不难发现

- 若a,b是奇数,则SG[(a,b)]=0

然后看了一会，发现一个不太重要的结论

若a%2=0,则第a行后面每lowbit(a)个数都是一个数

然后动用大眼观察法，得到剩余两个规律

- 若a,b是偶数,则SG[(a,b)]=SG[(a/2,b/2)]+1

- 若a是偶数b是奇数,则SG[(a,b)]=SG[(a,b+1)]

然后我们就可以用这个和更正减损术差不多的算法log复杂度算出一个二元组的SG函数了

代码还是灰常短

```cpp
#include <stdio.h>
int GetSG(int a,int b)
{
    int py=0;
    while(1)
    {
        if(a&1&&b&1)
            return py;
        if(a&1)
            ++a;
        else if(b&1)
            ++b;
        else
        {
            a>>=1;
            b>>=1;
            ++py;
        }
    }
}

int T,N;

int main()
{
    scanf("%d",&T);
    int wia,wi;
    for(wia=1;wia<=T;++wia)
    {
        int Sgx=0;
        scanf("%d",&N);
        N/=2;
        int a,b;
        for(wi=1;wi<=N;++wi)
        {
            scanf("%d %d",&a,&b);
            Sgx^=GetSG(a,b);
        }
        if(Sgx)
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}
```

---

## 作者：Chaigidel (赞：10)

- 局面 $(x,y)~~~ x,y>0$
- 操作 $(x,y)\rightarrow(a,b)~~~a+b=x$ 或 $a+b=y$

$x,y\le 2\times 10^9$

先手必败还是必胜？

---

首先打个表，朴素算 $\operatorname{sg}$

```cpp
std::map<pii, int> sg;

int calc(pii c) {
    if (sg.count(c)) return sg[c];
    std::vector<int> s;
    rep(i, 1, c.first - 1) s.push_back(calc({i, c.first - i}));
    rep(i, 1, c.second - 1) s.push_back(calc({i, c.second - i}));
    std::sort(s.begin(), s.end());
    s.erase(std::unique(s.begin(), s.end()), s.end());
    int lst = -1;
    for (auto i : s) {
        if (i != lst + 1) return sg[c] = lst + 1;
        lst = i;
    }
    return sg[c] = lst + 1;
}
```

然后输到 Excel

![](https://cdn.luogu.com.cn/upload/image_hosting/bysauhxc.png)

非常的有规律

```cpp
#define c(x, p) (x % p ? x % p : p) // 0 % p = p
int sg(ui x, ui y) {
    for (ui i = 0, p = 2; i < 31; i++, p *= 2) {
        if ((c(x, p) <= p / 2) && (c(y, p) <= p / 2)) return i;
    }
    return 31;
}
```

$i$ 从小到大考虑， `if` 中的条件意思是在正方形的左上角 $1/4$

```cpp
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
#define per(i, l, r) for (int i = (l); i >= (r); --i)
typedef pair<int, int> pii;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;

#define c(x, p) (x % p ? x % p : p)

int sg(ui x, ui y) {
    for (ui i = 0, p = 2; i < 31; i++, p *= 2) {
        if ((c(x, p) <= p / 2) && (c(y, p) <= p / 2)) return i;
    }
    return 31;
}

int main() {
#ifdef LOCAL
    freopen("input", "r", stdin);
#endif
    std::ios::sync_with_stdio(false);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        cerr << "doing " << T << endl;
        int n;
        cin >> n;
        n /= 2;
        int ans = 0;
        rep(i, 1, n) {
            int x, y;
            cin >> x >> y;
            // cerr << x << ' ' << y << endl;
            ans ^= sg(x, y);
        }
        cout << (ans ? "YES" : "NO") << std::endl;
    }
    return 0;
}
```

---

## 作者：Mingoal (赞：10)

我看大家用的都是o(nlogn)的方法，我这里提供一种优化算法（不知道为什么，它的速度和nlogn的一样快，有知道的请私信我一下，谢谢）

其实我是参考@Goes的方法做的（第一篇），他的核心代码：

```cpp
int sg(int x,int y)
{
    long long tmp=2;
    for(int i=0;;i++,tmp*=2)
        if( ( x - 1 ) % tmp < tmp/2 && (y-1)%tmp < tmp/2 )
            return i;
}
```
我发现，这其实就是在求x-1和y-1最后一个0在倒数第几位（要减1，这个先不管），大家可以自己试一下

于是我们可以有如下算法：

先求出(x-1)|(y-1)，因为要求x-1和y-1的某一位同时为0，所以对于这一位两个数中有一个是1就是不符合条件的，按位取或了以后集中在最后的1都是不符合条件的，只要加一个1，这些1就都变成0，最后一个0就变成了1，这样就只要求最后一个1在倒数第几位就行了（用lowbit）

好像有点难理解，举个例子：

x-1:100110001

y-1:101110111（共同的0在倒数第四位）

  (x-1)|(y-1):101110111（0在倒数第四位）

(x-1)|(y-1)+1:101111000（1在倒数第四位）

最终结果是3，可以对照着例子理解一下

这个程序的时间复杂度是o(n)

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,i,n,x,y,z,ans;
int read(){
    int re=0;
    char ch;
    do ch=getchar();while (ch<'0'||ch>'9');
    while (ch>='0' && ch<='9') re=(re<<3)+(re<<1)+(ch^48),ch=getchar();
    return re;
}
int main(){
    T=read();
    while (T--){
        n=read();ans=0;
        n>>=1;
        for (i=0;i<n;i++){
            x=read();y=read();
            z=((x-1)|(y-1))+1;
            x=(int)log2(z&(-z));
            //估计程序慢的原因是这个log2
            ans^=x;
        }
        printf("%s\n",ans?"YES":"NO");
    }
}
```

---

## 作者：小越越 (赞：8)


虽然下面有大佬已经证过本题结论了，但是还是自己写了一个证明，感觉有一点不一样，不知道证明是否正确。请大佬查错。

# 题意

有一些游戏，每个游戏都是这样的：

有两堆石子，每次操作可以丢掉其中一堆，并且把另一堆分至少一个到丢掉的这堆，保证每堆至少有一个石子，不能操作的人输。

每次可以挑一个游戏操作，最后不能操作的人输。

# 思路

首先打表找出规律，我们知道了$sg(i,j)=f((i-1)|(j-1))$，$f(x)$表示$x$二进制下最低的0位。然后就可以做题了，事实胜于雄辩。

无聊之余，我们来证明这个思路的正确性。

设$S(i)=\{sg(x,y)|x+y=i\}$，那么$sg(i,j)=mex(S(i) \cup S(j))$。

然后我们只要说明$S(i)$中的元素就是$i-1$在二进制下的所有1位即可。

首先$i=1$时，$S(i)=\varnothing$，成立。

现在假设$i-1(i\ge 2)$时结论正确性已经被证明，考虑$i$时的情况，$S(i)=\{f(x|y)|x+y=i-2\}$。对于某一组$x$和$y$，假设$f(x|y)=k$，那么$x$和$y$的后$k+1$位大概长这个样子：

| | k | k-1 | k-2 | ...| 1 | 0 |
|-----------: |-----------: |-----------: |-----------: |-----------: |-----------: |-----------: |
|x| 0 | 1 | 0 | ... | 1 | 0 |
|y| 0 | 1 | 1 | ... | 0 | 1 |

所以$0$ ~ $k$位相加的和的范围是$[2^k-1,2^{k+1}-2]$，因为$i-1=x+y+1$，所以$i-1$的后$k+1$位的范围应该是$i-1\in [2^k,2^{k+1}-1]$，第$k$位肯定是1。所以我们证明了$S(i)$只可能包含$i-1$的1位，那么接下来证明$i-1$所有的1位都在$S(i)$中。

先系统地描述一下这个命题，即$\forall k \in S(i)$，都存在一组$x,y(x+y+1=i-1)$使得$f(x|y)=k$。
因为$x|y$的第k位是0，$0$ ~ $k-1$位全是1，所以类似上面的证法，
要想满足$f(x|y)=k$必须满足$(x+y+1)mod\; 2^{k+1} \in [2^k,2^{k+1}-1]$。
又因为$i-1$的第k位是1，所以$(x+y+1)mod \; 2^{k+1}=(i-1)mod \; 2^{k+1} \in [2^k,2^{k+1}-1]$。
所以一定存在一组$x,y(x+y+1=i-1)$，使得$f(x|y)=k$。

证毕！



# 代码



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e4+10;
int T, n, ans;

int lowzero(int x){
    for (int i = 0; ; ++i, x >>= 1)
        if (!(x & 1)) return i;
}

int main()
{
    for (scanf("%d", &T); T--; ){
        ans = 0;
        for (scanf("%d", &n), n >>= 1; n--; ){
            int x, y;
            scanf("%d%d", &x, &y);
            ans ^= lowzero((x - 1) | (y - 1));
        }
        printf("%s\n", ans ? "YES" : "NO");
    }
    return 0;
}
```


---

## 作者：王熙文 (赞：5)

## 思路

首先可以用 SG 定理把这个问题转换成求一组石子的 SG 值，然后再异或起来。

设 $\text{SG}(x,y)$ 为当前状态下的 SG 值。再设 $S_z=\{\text{SG}(x,y)|x+y=z,x,y\in N_{+}\}$，则根据题意，$\text{SG}(x,y)=\text{mex}(S_x \cup S_y)$。

接下来有一个重要结论：$S_z$ 是 $(z-1)$ 在二进制下 $1$ 的位置集合（位置从 $0$ 开始，下同）。

考虑使用数学归纳法证明。

首先，当 $z=1$ 的时候，$S_z=\varnothing$，等于 $0$ 在二进制下 $1$ 的位置集合。

接下来，假设 $1\sim z-1$ 的时候上面的结论已经证明了，现在来证明 $z$ 的时候是对的。

考虑 $x,y \le z-1$ 时 $\text{SG}(x,y)$ 有什么性质。因为 $S_x,S_y$ 都是 $x-1,y-1$ 在二进制下 $1$ 的位置，所以 $S_x \cup S_y$ 就是 $(x-1)|(y-1)$ 在二进制下 $1$ 的位置。设 $f(x)$ 为 $x$ 在二进制下第一个 $0$ 的位置，则 $\text{SG}(x,y)=f((x-1)|(y-1))$。

再来看 $S_z$ 的定义：$S_z=\{\text{SG}(x,y)|x+y=z,x,y\in N_{+}\}$。那么这里的 $x,y$ 一定都 $\le z-1$。所以 $S_z=\{f((x-1)|(y-1))|x+y=z,x,y\in N_{+}\}$。

转换一下，将 $z,x,y$ 都减一，变成了 $T_z=\{f(x|y)|x+y+1=z,x,y \in N\}$。所以现在就需要证明 $T_z$ 是 $z$ 在二进制下 $1$ 的位置集合。

现在就要对二进制位是 $1$ 或 $0$ 两种情况分别证明。

* 对于 $z$ 的二进制下 $1$ 的位置 $k$，存在一对 $x,y$ 满足 $x+y+1=z$ 使得 $f(x|y)=k$。当 $k=0$ 时，构造 $x=0,y=z-1$ 即可，因为 $z-1$ 的最后一位一定是 $0$。否则，构造 $x=2^k-1,y=i-2^k$ 即可。因为 $x$ 保证了第 $0 \sim k-1$ 位都是 $1$，此时 $x$ 第 $k$ 位已经没有了，而 $y$ 的第 $k$ 位一定是 $0$。

* 对于 $z$ 的二进制下 $0$ 的位置 $k$，不存在一对 $x,y$ 满足 $x+y+1=z$ 使得 $f(x|y)=k$。当 $z$ 的第 $0 \sim k-1$ 位都是 $0$ 的时候，减一后 $z$ 的第 $0 \sim k$ 位就都变成 $1$ 了。但要求 $x,y$ 的第 $k$ 位都是 $0$，这样就要求每一位都有进位。但是在第 $0$ 位的时候一定不会有进位，所以不存在。否则，减一之后不会影响第 $k$ 位，且前面必然至少存在一个 $0$。又因为 $x,y$ 的第 $0 \sim k-1$ 位 $x,y$ 至少有一个 $1$，所以 $0$ 必然会产生进位。接下来，每一位都会产生进位。一直到第 $k$ 位，此时 $x,y$ 的第 $k$ 位是 $0$，加上进位就变成 $1$ 了，与 $z$ 的第 $k$ 位是 $0$ 矛盾。所以不存在。

这样就证明了这个结论。

因为这个结论成立，所以根据上面，$\text{SG}(x,y)=f((x-1)|(y-1))$。这样求出每个 $\text{SG}(x,y)$ 然后异或起来即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; int a[20010];
int f(int x)
{
	int now=0;
	while(x%2) x/=2,++now;
	return now;
}
int main()
{
	int t; cin>>t; while(t--)
	{
		cin>>n;
		for(int i=1; i<=n; ++i) cin>>a[i];
		int now=0;
		for(int i=1; i<=n; i+=2) now^=f((a[i]-1)|(a[i+1]-1));
		cout<<(now?"YES":"NO")<<'\n';
	}
	return 0;
}
```

---


# [HEOI2014] 人人尽说江南好

## 题目描述

小 Z 是一个不折不扣的 ZRP（Zealot Round-game Player，回合制游戏狂热玩家），最近他想起了小时候在江南玩过的一个游戏。

在过去，人们是要边玩游戏边填词的，比如这首《菩萨蛮》就是当年韦庄在玩游戏时填的：人 人 尽 说 江 南 好， 游 人 只 合 江 南 老。

然而我们今天不太关心人们填的词是什么，我们只关心小 Z 那时玩过的游戏。游戏的规则是这样的，给定 $n$ 堆石子，每堆石子一开始只有 $1$ 个。小 Z 和他的小伙伴轮流操作，小 Z 先行操作。操作可以将任意两堆石子合并成为一堆，当谁不再能操作的时候，谁就输掉了。

不过，当一堆石子堆的太高时可能发生危险，因此小 Z 和他的小伙伴规定，任何时刻任意一堆石子的数量不能超过 $m$。即假如现在有两堆石子分别有 $a$ 个和 $b$ 个，而且 $a + b > m$，那么这两堆石子就不能合成一堆。

小 Z 和他的小伙伴都是很聪明的，所以他们总是会选择对自己最有利的策略。现在小 Z 想要知道，在这种情况下，对于一个给定的 $n$ 和 $m$，到底是谁能够获得胜利呢？


## 说明/提示

对于 $10 \%$ 的数据，$m \ge n$；  
对于 $20 \%$ 的数据，$n, m \le 10$；  
对于 $30 \%$ 的数据，$n, m \le 50$，$2 \cdot m \ge n$；  
对于 $50 \%$ 的数据，$n, m \le 100$；  
对于 $70 \%$ 的数据，$n, m \le {10}^6$；  
对于 $100 \%$ 的数据，$1 \le n, m \le {10}^9$，$1 \le T \le 100$。


## 样例 #1

### 输入

```
5
7 3
1 5
4 3
6 1
2 2```

### 输出

```
1
1
1
1
0```

# 题解

## 作者：Loi_Anina (赞：25)

首先，合并次数为奇数先手必胜，偶数后手必胜，那么两个人都会尽可能向着自己想要的方向去发展(即拉到总合并次数为奇数/偶数)

具体实现方式：

	当n ≤ m时，这种情况最后肯定能合成一堆，我们称这个较大的堆为【大堆】。
	假如现在轮到先手操作，先手还没动，这个时候最长合并次数为偶数次，那么先手有两种可能性，把后面一个堆丢进大堆里面，这样后手再丢一个小堆进去，或者把后面两个堆合成一个，那么后手就可以把这个合成的直接丢进去。
	无论怎么做，后手都能保证每轮完了之后，大堆的石子会增加两个，那么合并次数也会-2，一直保持为偶数。直到最后先手合无可合。
    
    
因此就可以保证剩下的合并次数为原始奇/偶，同时这种方式也会把局数拉到最多。

想办法弄到对自己有利

**如果拉到最长的操作次数我们必胜的话，那么不管对面怎么操作，我们都能用上述方法拉回来**

**同样如果最长的操作是对面必胜，不管我们怎么合并，对面也能用上述方法拉回来**
    
以及

我们已经发现最长的情况我们必胜，无论对手怎么操作我们都能拖到最长，我们必胜

对手发现最长他必胜，无论我们怎么操作，他也肯定能往下拖。

**所以对最长必胜的那一方来说，一直拖到最长就是最优策略**

而我们已经分析了必胜的那一方总是能拖下去

即这是一种必然取胜的方法，且如果对手不按套路出牌我们也能拖回来。


因此最终答案就是最长能拖到的次数，如果为奇先手胜，如果为偶后手胜。

#### 最长次数

在n<=m的情况下可以轻松判断出是n-1；


若n>m，则最后最大合并后堆数一定是{m,m,m,m,n%m};
（因为如果是形如{m,m,m,m-x,m-x}的形式，~~不好算~~，我觉得其实是没什么不一样的Orz，可能仅仅只是不好算吧Orz）

因此ans=(n/m)*(m-1)+n%m?n%m-1:0;

#### 代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int T;
long long int n,m;
int main()
{
	scanf("%d",&T);
	for(int i=1;i<=T;i++)
	{
		scanf("%lld%lld",&n,&m);
		long long int ans=(n/m)*(m-1)+((n%m)?(n%m-1):0);
		if(ans&1) printf("0\n");
		else printf("1\n");
	}
	return 0;
}
```



------------

向管理员道歉Orz，手滑交成题解了，不要管我Orz


---

## 作者：XTianShuo (赞：16)

## 题目概述
两个人玩游戏，有 $n$ 堆石子，轮流合并石子，且最高的石子堆不能大于 $m$ 个石子，最后不能操作的人失败。  
先给定你多组 $n$ 和 $m$，询问你是先手必胜还是后手必胜。

## 前置知识
这道题可以转化成巴什博奕来解决。  
巴什博奕是什么，我们先来看一个有趣的视频。  
[点我查看巴什博奕的视频。](https://view.inews.qq.com/a/20220819A0AIVN00)  
巴什博奕就是：
两个人玩游戏，规则为：从 $n$ 个物品中轮流取物，至少取一个，最多取 $m$ 个，定义最后取完者获胜。    
那必胜规则就是：  
如果 $n$ 能被 $(m+1)$ 整除，则对于先手来说，就是必败局。  
如果 $n$ 不能被 $(m+1)$ 整除，则对于先手来说，就是必胜局。   
为什么可以这样呢？  
就拿视频中的例子举例，$17$ 个豆子，每人只能拿 $1 \sim 3$ 颗，取到最后一颗豆子的获胜。   
如果我们拿到 $4$ 颗，$8$ 颗，$12$ 颗，$16$ 颗的点，那我们就拿到了必胜点，对方必败，对方无论取多少颗，我们都可以补满 $4$ 颗，使其继续为 $4$ 的倍数点，从而最后自己拿到最后一颗豆子获胜。
## 解法讲解
接下来，我们具体地分析这道题。  
我们可以把每一次合并点当做一个豆子，所以题意可以模型化为：  
共有 $n-1$ 个合并点，每次只能合并一次，且每堆石子最多不能超过 $m$ 个石子，问是否先手必胜。  
我们需要先处理第二个限制条件,每连续的 $m$ 堆的右方的合并点无法使用，如下图。  
如果 $n$ 能够除尽 $m$ 的话，我们只需要减去 $\lfloor n/m \rfloor +1$ 个合并点。   
因为最后一组的右方的合并点无效，所以我们要 $+1$，如下图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/zatuyost.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
如果 $n$ 不能除尽 $m$ 的话，我们需要减去 $\lfloor n/m \rfloor$ 个合并点。    
![](https://cdn.luogu.com.cn/upload/image_hosting/592wd0xi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
根据上方的巴什博奕前置知识，减去后的合并点若为 $2$ 的倍数则先手必胜，否则后手必胜。  
所以若先手必胜，需要满足：
$$((n-1)- \lfloor n/m \rfloor +[n \bmod m=0]) \bmod 2=1$$
整理可得：
$$(n- \lfloor n/m \rfloor +[n \bmod m \ne 0]) \bmod 2=1$$
否则后手必胜。
## code
代码很简单。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		if((n-n/m-(n%m!=0))%2==1)	printf("0\n");
		else printf("1\n");
	}
	return 0;
}
```

---

## 作者：Infiltrator (赞：14)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4101)

------------

# Solution

如果每个人每次都只是将一个大小为$1$的石子堆放到当前最大的石子堆里，那么当游戏不能玩的时候局面必定是有$n / m$个大小为$m$的石子堆和$\left [ n \mod m \neq 0 \right ]$个大小为$n \mod m$的石子堆。

一共需要$\left ( m - 1 \right ) \times \left (n / m \right ) + \left[ n \mod m \neq 0 \right ] \times \left ( n \mod m - 1 \right )$步达到最后的局面。

如果都按照这样的策略进行游戏，那么如果步数是奇数就是先手胜否则是后手胜利。但是现在还有别的决策可以执行，而且最终局面不是唯一的，但是可以采用一种策略使最终局面就是这样的。考虑如果按这个策略进行游戏本来是先手必胜那么当后手执行决策时有两种可能。

第一种将一个大小为$1$的石子堆和最大的石子堆合并，这样先手只要继续执行策略最后就能获胜。

第二种将两个大小为$1$的石子堆合并，这样先手下次只要将这个大小为$2$的石子堆和最大的合并就行，和上面的第一种情况一样都是得到一个最大的石子堆和一些大小为$1$的石子堆。

如果不能合就直接拿一个大小为$1$的石子堆和最大的合并就行，和上面第一种情况得到的局面还是一样的，都是一个大小为$m$的石子堆和一个大小为$2$的石子堆还有一些大小为$1$的石子堆。

所以无论是那种决策达到最终局面的步数不变，依然是先手必胜。如果一开始算的步数是后手必胜同理。

所以按这种决策计算的步数是奇数就是先手胜否则就是后手胜。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int n, m;

int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &n, &m);
		printf("%d\n", (n - (n / m) + (n % m != 0)) % 2 == 0 ? 1 : 0);
	}
	return 0;
} 
```

---

## 作者：Φρανκ (赞：4)

题意：有 $n$ 堆石子各含 $1$ 枚，两人轮流操作将两堆合一。要求每堆石子不能超过 $m$ 枚，不能操作者败。求有必胜策略者。

核心思想：递推

解：

显然，若共操作奇数步则先手胜，反之后手胜。

不妨设 $f(n,m)$ 表示必胜者的值。

首先，若 $n\le m$，无论如何操作石子都将在 $n-1$ 步后合为一堆，因此 $n\equiv 1\pmod 2$ 时后手胜，反之先手胜。

$\forall\: n\ge m$ 可证无论一方如何操作另一方均可以在 $m-1$ 步内合成出一个 $m$ 大小的堆。这是因为无论另一方如何操作，这一方均可以保证堆形如 $x,1,1,...,1$ 并可以不断把对方合成的 $2$（如有）增加到 $x$ 上。因此，对于 $2\nmid m$，$f(n,m)=f(n-m,m)$（花费偶数步，相当于先后手未改变），反之则有 $f(n,m)=f(n-m,m)$ 取反（花费奇数步，相当于先后手改变）。

根据上式，有 $f(n,m)=f(n\bmod m,m)=((n-1)\bmod m+1)\bmod 2\:(2\nmid m)$ 。类似地，有 $f(n,m)=f(n\bmod m,m)$ 取反 $(\lfloor\frac{n-1}{m}\rfloor \bmod 2)$ 次 $=(\lfloor\frac{n-1}{m}\rfloor \bmod 2)\oplus ((n-1)\bmod m+1)\bmod 2\:(2\mid m)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int t, n, m;
int sol(int n, int m)
{
	if(m%2==1)
		return ((n-1)%m+1)%2;//奇数
	return ((n-1)/m)%2^(((n-1)%m+1)%2);//偶数
}
int main()
{
	cin>>t;
	for(int i=1; i<=t; i++)
	{
		cin>>n>>m;
		cout<<sol(n, m)<<endl;
	}
	return 0;
}
```

---

## 作者：trsins (赞：4)

乍一看很难实际上很水的博弈论。

对于博弈论，两种做法：

1. 局部考虑，对于每一回合，分析每个玩家的策略，找到一个规律。

	算法：暴力模拟。时间复杂度较高，有时需要优化。

2. 整体考虑，宏观开头和结局，从而大致推出回合次数及结果。

	算法：数学方法，时间复杂度较低，一般为 $O(1)$ 或 $O(log\ n)$。

其中第一种思路基本上可以说是**通解**，但是第二种思路在某些特定情况下的做法比第一种简单很多。

这一题，很显然，采用第二种思路。

因为第一种思路主要是对于数据较小、玩家较多的题进行手玩~~口胡~~一下推出结论的。而且它有一个很重要的特征：**操作情况与玩家有关**。比如说第 $i$ 位玩家取走 $i$ 个石子，或者说第 $j$ 位玩家在第 $k$ 位玩家后进行等等诸如此类的情况，特征就是操作与玩家各种因素有关，比如编号。

然而这一题并非如此。两个玩家实际上没有任何区别，而且操作情况是与当前具体石子数量相关，与玩家因素**无关**。这一题具体分析每个人的做法其实也能做，只不过并不太适合。当然了，还是有[用第一种思路解题的题解](https://www.luogu.com.cn/blog/Loi---ys/solution-p4101)。

~~所以说到现在才讲正解是个什么玩意。~~

正解第二种思路。

来，看结果。题目中说明了结束边界：

>当谁不能再操作时，谁就输了。

怎么样是不能操作？当两堆石子不能合并时。

**石子数量是不变的**，总量为 $n$。所以，石子结局应该是这样的：

 $$\begin{matrix}\underbrace{m,m,\cdots,m}\\ \left\lfloor\dfrac{n}{m}\right\rfloor \times  m\end{matrix}+n \% m$$

共有 $\left\lceil\dfrac{n}{m}\right\rceil$ 堆，合并了 $n-\left\lceil\dfrac{n}{m}\right\rceil$ 次。

决定胜负的应该是最后一次合并时轮到的玩家，而这个正好与**合并次数的奇偶性**有关。

所以判断奇偶即可。

总结。先决策博弈思路，其次发现石子总数不变，再求出结局情况，然后推出合并次数，最后找出决定胜负的因素。


在线 $O(T)$。


---

## 作者：luqyou (赞：4)

# 前言

这题对于我来说~~比较水~~是一个比较好的练手题。

代码速度 $20ms$，并列第一。

代码时空复杂度排名第三。

~~这竟然是蓝题~~

[洛谷博客食用更佳](luogu.com.cn/luqyou/solution-p4101)

[csdn博客食用更佳](https://blog.csdn.net/weixin_50193039/article/details/119726904)

# 思路

如果每个人每次都只是将一个大小为1的石子堆放到当前最大的石子堆里，那么当游戏不能玩的时候局面必定是有 $\dfrac{n}{m}$ 个大小为 $m$ 的石子堆和 $n \bmod m≠0$ 个大小为 $n \bmod m$ 的石子堆。

一共需要 $(m-1)×(\dfrac{n}{m})+[n \bmod m≠0]×(n \bmod m-1)$ 步达到最后的局面。

如果**都按照这样的策略**进行游戏，那么如果**步数是奇数就是先手胜否则是后手胜利**。但是现在还有别的决策可以执行，而且最终局面**不是唯一的**，但是可以采用一种策略使最终局面就是这样的。考虑如果按这个策略进行游戏本来是先手必胜那么当后手执行决策时有两种可能。

第一种将一个大小为 $1$ 的石子堆和最大的石子堆合并，这样先手只要继续执行策略最后就能获胜。

第二种将两个大小为 $1$ 的石子堆合并，这样先手下次只要将这个大小为 $2$ 的石子堆和最大的合并就行，和上面的第一种情况一样都是得到一个最大的石子堆和一些大小为1的石子堆。

如果不能合就直接拿一个大小为 $1$ 的石子堆和最大的合并就行，和上面第一种情况得到的局面还是一样的，都是一个大小为 $m$ 的石子堆和一个大小为 $2$ 的石子堆还有一些大小为 $1$ 的石子堆。

所以**无论是哪种决策**达到最终局面的步数不变，依然是先手必胜。如果一开始算的步数是后手必胜同理。

所以按这种决策计算的步数是**奇数就是先手胜否则就是后手胜**。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main()
{
	int t;
	cin>>t;
	while (t--)
	{
		cin>>n>>m;
		cout<<(n-(n/m)+(n%m!=0))%2==0?1:0)<<endl;
	}
	return 0;
} 
```

[然后就AC啦！](https://www.luogu.com.cn/record/59681779)

更新：
2021/10/12 更新了提交记录


---

## 作者：LYP_ (赞：3)

[传送门](https://www.luogu.com.cn/problem/P4101)  
博弈论。

solution：  
简单分析题意可知当合并次数为奇数次的时候先手必胜，合并次数为偶数次的时候先手必败。

我们来分两种情况讨论。

当 $n \le m$ 时：  
简单的画图模拟可知无论怎么合并都只有 $n-1$ 次，所以当 $n$ 是偶数时先手必胜，$n$ 是奇数的时候先手必败。

当 $n > m $ 时：  
我们的游戏规则为：先手合并 $\to$ 后手合并 $\to$ 先手合并 $\to$ 后手合并…且合并的两堆加起来的数目不会超过 $m$。   

嘿，你发现什么没有。  

让我们先站在先手的位置上。先手很聪明，所以在合并石子的时候绝对不会让其出现最后剩下两堆石子数量都大于 $\dfrac m 2$ 以至于无法合并的情况。也就是说，我们先手的合并策略一定是小堆往大堆合并直到一堆石子的数量到达 $m$。  
当然，$n \le m$ 的时候也是这个策略只是因为没有限制所以随便合并也可以。

至于后手如何合并就显得无关紧要了，因为无论如何先手在下一步都会把它变成从小堆到大堆合并。  
故最后石子的分堆情况应该是 $\left\lceil\dfrac{n}{m}\right\rceil$ 堆，其中有一堆是不满 $m$ 的 $(n \bmod m)$。当然，如果 $n$ 是 $m$ 的倍数那就没有剩下石子。  
合并次数的计算就仿照当 $n \le m$ 时的合并，即数量为 $m$ 的合并 $m-1$ 次，不满 $m$ 的合并石子数量减一次。最后单堆石子的次数相加就行。  

计算式：```ans=(n/m)*(m-1)+((last)?(last-1):0)```，其中```last```为余下的石子。

上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,ans,last;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		last=n%m;
		ans=(n/m)*(m-1)+((last)?(last-1):0);
		if(ans%2) cout<<"0"<<"\n";
		else cout<<"1"<<"\n";
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：2)

首先，$(n-1)$ 次操作可以合并所有石子，如果答案的方案有 $t$ 堆石子，那么操作次数为 $(n-t-2)$ 次，答案与它的奇偶性有关。

奇数则先手败，偶数则先手胜。

那么我们来探究石子堆的数量吧，最优策略下一定会分成 $\lfloor \dfrac n m\rfloor$ 个石子数为 $m$ 的石子堆和一个石子数为 $(n\mod m)$ 的石子堆。

也就是说，答案与 $(n-\lfloor \dfrac n m\rfloor-[(n\mod m)>0]-2)$ 的奇偶性有关。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LD long double
using namespace std;
LL T,n,m;
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&n,&m);
		LL t=n/m;
		LL k=max(0ll,n%m-1);
		if((t*(m-1)+k)&1)
		{
			puts("0");
		}
		else
		{
			puts("1"); 
		}
	}
}
```

---

## 作者：—维尼— (赞：2)

## 题目描述
给你堆数和每堆最大容纳值，初始每堆一个，每次操作轮流合并任意两堆，谁最后无法操作谁就输
## 结论证明
我们知道的是，如果优先合并出满堆（就是每个大于$1$的堆都是$m$），最后剩下的就是$n%m$，然后手摸一下就知道不管先手是继续合并大堆（虽然合不出来）还是两两合并，只要后手愿意，可以保证经过这两次操作，较大堆只加了$2$

比如 先手将两个$1,1$合并，那后手就把合并出的$2$与未满$m$的最大堆合并，这样每次操作就相当于只加一个石子，我们从此考虑就可以求出操作次数

就是合并之后完的**数量为m的堆的数量 乘上m-1 加上最后剩下的石头数量-1**

为啥要减一：因为每次合并出有$x$个石头的堆，只需要$x-1$次操作

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int num=n/m;//可以合成的堆数
		int mod=n%m; 
		long long ans=0;
		ans+=num*(m-1);//每堆需要m-1次
		ans+=mod;
		if(mod>0)
		ans--;
		if(ans%2)
		cout<<0<<endl;
		else
		cout<<1<<endl;
	}
}
```

---

## 作者：cz666 (赞：2)

## 题意：

一开始给出 $n$ 堆石子，每堆石子个数均为 $1$ ，现在有两个人在玩石子合并的游戏，每次可以选择两堆石子合并，但是合并过后的一堆石子个数不能超过 $m$ ，一方无法合并石子时结束游戏，不能合并的那方输，问先手必胜还是后手必胜（分别输出 $0$ 和 $1$ ）。

## 思路：

很显然我们发现无法继续合并石子时，石子必定最多只有一堆个数小于 $m$ ，其余石子堆的个数均等于 $m$ （这个应该很显然的吧，如果有两堆都小于 $m$ 个那在这两堆形成之前必定可以通过单个的石子堆和 $m-1$ 个的石子堆合并变成个数为 $m$ 的石子堆和剩下并成一堆的石子堆）。

（下面思路介绍中的 $N$ 和上面的 $n$ **没有关系！没有关系！没有关系！**）

我们可以把最后某堆石子的中间合并过程看作一棵树，根节点为最后的合并大小， $N$ 个叶子节点表示最初合并成根节点的初始堆，不难发现不管这棵树形态如何，它都是棵二叉哈夫曼树（每个节点都没有儿子或者有两个儿子），每个父亲节点下两条连儿子的边为一个合并操作，这棵树共有 $N+(N-1)=2*N-1$ 个节点，所以有 $2*N-2$ 条边，每两条边构成一个操作，所以 $n$ 堆合并一堆要 $N-1$ 次操作。

想到了上面两个就能很容易得出从开始到结束最多会经过多久（为什么我们要知道最多会经过多久而不是最少会经过多久呢？因为在游戏中两人并不知道会赢还是会输，而两人又绝对聪明，不会失误，所以他们总是会尽可能地延长回合数而不是尽可能结束游戏（也许这就是所谓的~~不见棺材不落泪~~吧））。

得出了最长持续的回合数，因为这个游戏是你一次我一次这样持续的，所以最后一次操作如果是个偶数，那么难堪的一定是先手（因为下一个回合他就无法再合并了），反之则是后手难堪（道理亦然）。

## 下面给出蒟蒻的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define dd c=getchar()
inline int read(){int s=0,w=1;char c;while (dd,c>'9' || c<'0') if (c=='-') w=-1;while (c>='0' && c<='9') s=s*10+c-'0',dd;return s*w;}
inline void write(int x){if (x<0) putchar('-'),x=-x;if (x>=10) write(x/10);putchar(x%10|'0');}
inline void wln(int x){write(x);putchar(10);}
inline void wlk(int x){write(x);putchar(32);}
#undef dd//没用的快读。
signed  main(){
	int T=read();
	while(T--){
		int n=read(),m=read();
		int ans=(n/m)*(m-1);
//最后可以合并成n/m个m大小的堆，花费(n/m)*(m-1)次合并操作
		n=n%m;ans=ans+max(n-1,0ll);
//前面的操作数得出后别忘记把最后那个大小小于m的堆合并操作数加上
//n可能等于0，必须保证n-1大于等于0，所以取max
		if (ans%2) putchar('0'),putchar('\n');
		else putchar('1'),putchar('\n');
	}
	return 0;
}
```

完结撒花 $QwQ$

~~话说这还是唯一一道我这个大蒟蒻能一遍过的博弈论题目······~~

---

## 作者：zjyqwq (赞：2)

### P4101 [HEOI2014]人人尽说江南好 题解
Python 3 题解 qwq。


------------
#### 解题思路
首先，我们知道，合并次数如果是奇数，那么先手胜，否则后手胜。

如果$ n \leq m$ ,合并次数就为  $n-1$ 。

这时，我们直接判断即可。

如果 $n>m$ ，不能合成一堆，这就麻烦了。

这时，我们要想明白，如果我们想赢，就让合并数变成能让自己赢的次数。

同时，两个人就会把合并次数拖到最长，最后，就会变成：
| m | m |…| n%m |
| :----------: | :----------: | :----------: | :----------: |

这个时候借鉴一下 $rsins$ 大佬的博客，![](https://cdn.luogu.com.cn/upload/image_hosting/j0t0ftpr.png)
然后就可以写出代码了。


------------
#### $AC\ Code$
```Python3
t = int(input())
for i in range(t):
    x , y = map( int , input().split() )
    print(1 - ( x // y * ( y + 1) + ( x % y - 1 if x % y != 0 else 0)) % 2)
```

---

